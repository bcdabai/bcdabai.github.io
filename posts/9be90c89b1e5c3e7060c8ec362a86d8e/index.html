<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go 语言读取文件的几种方式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go 语言读取文件的几种方式" />
<meta property="og:description" content="前言 这篇文章将讨论如何在 Golang 中读取文件。我们将使用以下包来处理这些文件。
os 包提供了一个独立于平台的接口来执行操作级操作。IOutil 软件包提供了易于使用的实用程序函数来处理文件，而无需了解太多内部实现。bufio 包实现了缓冲 IO，这有助于我们提高输入和输出操作的性能和吞吐量。log 包实现一个简单的日志记录包。我们将在整个程序中使用它。我们将在程序中使用日志包的 Fatal() 函数。 整个文件读取 我们可以很容易地一次性读取整个文件并将其存储在一个变量中。但请记住，我们不应该对大文件这样做。我们将使用ioutil.ReadFile() 函数来读取文件并将文件的内容存储在一个变量中。
首先，让我们在我们程序所在的同一目录下存储一个文件。因此，我们的文件夹结构将是下面这样的。
___ | |_ _ _ _ ilovego.txt | |_ _ _ _ main.go 我们在 main.go 函数中写入如下的内容：
package main import ( &#34;fmt&#34; &#34;io/ioutil&#34; &#34;log&#34; ) func main() { content, err := ioutil.ReadFile(&#34;ilovego.txt&#34;) if err != nil { log.Fatal(err) } fmt.Println(string(content)) } 但首先，让我们讨论一下 ReadFile() 函数的情况：
定义：方法声明 func ReadFile(filename string) ([]byte, error)功能：读取路径被传入函数参数的文件，并返回文件的内容。在内部使用 os.ReadFile(fileName) 方法返回：在一个字节数组中返回文件的内容和错误。一个成功的调用将返回 err == nil 内部 ReadFile 函数实现如下:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9be90c89b1e5c3e7060c8ec362a86d8e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-19T00:00:00+08:00" />
<meta property="article:modified_time" content="2023-04-19T00:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go 语言读取文件的几种方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>这篇文章将讨论如何在 Golang 中读取文件。我们将使用以下包来处理这些文件。</p> 
<ul><li><a href="https://pkg.go.dev/os" rel="nofollow" title="os">os</a> 包提供了一个独立于平台的接口来执行操作级操作。</li><li><a href="https://pkg.go.dev/io/ioutil" rel="nofollow" title="IOutil">IOutil</a> 软件包提供了易于使用的实用程序函数来处理文件，而无需了解太多内部实现。</li><li><a href="https://pkg.go.dev/bufio" rel="nofollow" title="bufio">bufio</a> 包实现了缓冲 IO，这有助于我们提高输入和输出操作的性能和吞吐量。</li><li><a href="https://pkg.go.dev/log" rel="nofollow" title="log">log</a> 包实现一个简单的日志记录包。我们将在整个程序中使用它。我们将在程序中使用日志包的 <code>Fatal()</code> 函数。</li></ul> 
<h2>整个文件读取</h2> 
<p>我们可以很容易地一次性读取整个文件并将其存储在一个变量中。但请记住，我们不应该对大文件这样做。我们将使用<code>ioutil.ReadFile()</code> 函数来读取文件并将文件的内容存储在一个变量中。</p> 
<p>首先，让我们在我们程序所在的同一目录下存储一个文件。因此，我们的文件夹结构将是下面这样的。</p> 
<pre><code class="language-Go">___ 
| 
|_ _ _ _ ilovego.txt | 
|_ _ _ _ main.go
</code></pre> 
<p>我们在 <code>main.go</code> 函数中写入如下的内容：</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"io/ioutil"
	"log"
)

func main() {

	content, err := ioutil.ReadFile("ilovego.txt")

	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(string(content))
}
</code></pre> 
<p>但首先，让我们讨论一下 <code>ReadFile()</code> 函数的情况：</p> 
<ul><li>定义：方法声明 func <code>ReadFile(filename string) ([]byte, error)</code></li><li>功能：读取路径被传入函数参数的文件，并返回文件的内容。在内部使用 <code>os.ReadFile(fileName)</code> 方法</li><li>返回：在一个字节数组中返回文件的内容和错误。一个成功的调用将返回 err == nil</li></ul> 
<p>内部 ReadFile 函数实现如下:</p> 
<pre><code class="language-Go">func ReadFile(filename string) ([]byte, error) {
    return os.ReadFile(filename)
}
</code></pre> 
<p>现在，让我们回到我们的程序:</p> 
<ul><li><code>ioutil.ReadFile("readthisfile.txt")</code> 返回一个 byteArray 和一个 err。我们将byteArray 存储在 "<strong>content</strong> "变量中，错误存储在 " <strong>err</strong> "变量中。</li><li>然后我们放置了一个 if 条件，如果 err 值不为 nil，我们将使用 <code>log.Fatal()</code> 函数打印错误 err 。记住，<code>Fatal()</code> 函数等同于 <code>Print()</code> 函数，然后调用 <code>os.Exit(1)</code> 。</li><li>最后，我们将使用 <code>fmt.Println()</code> 函数打印文件的内容。 我们不能简单地打印 <code>content</code> 变量，因为它是一个字节数组，我们需要将它转换为字符串: <code>string(content)</code></li></ul> 
<p>然后新建一个 <code>ilovego.txt</code> 文件，写入如下内容：</p> 
<pre><code class="language-bash">I Love Golang,
This is One of the Best Languages on the World!
</code></pre> 
<p>最后，执行上述代码，可以看到如下输出：</p> 
<pre><code class="language-bash">$ go run main.go
I Love Golang, 
This is One of the Best Languages on the World!
</code></pre> 
<h2>按行读取</h2> 
<p>Scanner 扫描器提供了一个方便的接口来读取数据，比如一个由新行分隔的文本行组成的文件。它通过标记来读取数据；<code>Split</code> 函数定义了标记。默认情况下，该函数将数据分成几行，并剥离了行端。</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	// "io/ioutil"
	"bufio"
	"log"
	"os"
)

func main() {

	// opening the file using Open function
	f, err := os.Open("ilovego.txt")

	if err != nil {
		log.Fatal(err)
	}

	defer f.Close()

	// create a scanner for the file
	scanner := bufio.NewScanner(f)

	// loop through the scanner until it return fasle
	for scanner.Scan() {

		fmt.Println(scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
}
</code></pre> 
<ul><li><code>os.Open()</code> 打开参数中传递的文件。如果在打开文件时遇到任何错误，它将返回同样的错误。否则，错误将是 nil。</li><li>然后，我们使用扫描器来读取文件，并逐行扫描，直到文件内容结束。</li><li>最后，我们要关闭该文件。</li></ul> 
<p>执行程序，结果如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ce/6f/KMqJZm7i_o.png"></p> 
<h2>逐个单词读取</h2> 
<p>我们还可以通过逐个单词来读取文件：</p> 
<pre><code class="language-Go">package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {

	f, err := os.Open("ilovego.txt")

	if err != nil {
		fmt.Println(err)
	}

	defer f.Close()

	scanner := bufio.NewScanner(f)
	scanner.Split(bufio.ScanWords)

	for scanner.Scan() {

		fmt.Println(scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		fmt.Println(err)
	}
}</code></pre> 
<p>运行代码：</p> 
<pre><code class="language-bash">$ go run main.go
I
Love
Golang,
This
is
One
of
the
Best
Languages
on
the
World!
</code></pre> 
<h2>以数据块的形式读取文件</h2> 
<p>一次性读取整个文件似乎是一种简单的方法，但有时我们需要从内存管理的角度使我们的程序得到一些优化。Golang 提供了一种分块读取文件的方法，而不是整个或甚至逐行读取。因为如果一行的大小太大，逐行读取也可能是低效的。</p> 
<pre><code class="language-Go">package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
)

func main() {

	f, err := os.Open("ilovego.txt")

	if err != nil {
		log.Fatal(err)
	}

	defer f.Close()

	reader := bufio.NewReader(f)
	buf := make([]byte, 16)

	for {
                // reading a file upto buffer
		n, err := reader.Read(buf)

		if err != nil {

			if err != io.EOF {

				log.Fatal(err)
			}

			break
		}

		fmt.Print(string(buf[0:n]))
	}

	fmt.Println()
}</code></pre> 
<h2>二进制读取</h2> 
<p><code>hex</code> 包实现了十六进制的编码和解码。</p> 
<pre><code class="language-Go">package main

import (
	"bufio"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"
)

func main() {

	f, err := os.Open("sid.jpg")

	if err != nil {
		log.Fatal(err)
	}

	defer f.Close()

	reader := bufio.NewReader(f)
	buf := make([]byte, 256)

	for {
		_, err := reader.Read(buf)

		if err != nil {
			if err != io.EOF {
				fmt.Println(err)
			}
			break
		}

		fmt.Printf("%s", hex.Dump(buf))
	}
}</code></pre> 
<h2>总结</h2> 
<p>本文介绍了 Go 语言读取文件的几种方式，<code>ioutil.ReadFile</code> 函数将整个文件读成一个字符串。这个函数很方便，但不应该用于非常大的文件。希望能对你有所帮助！</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/204894dc3d31254702aed63e3046fbcc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PostMan笔记（二）发送请求</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4259924a248d211278a526a0b1cf7d7e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三更博客项目后台管理系统的BUG大集合</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>