<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WM 虚拟机下Ubuntu系统扩展硬盘容量教程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WM 虚拟机下Ubuntu系统扩展硬盘容量教程" />
<meta property="og:description" content="以管理员身份打开， 命令提示符窗口，然后利用命令cd进入Oracle VM VirtualBox安装目录，如下图：
我进入了Oracle VM VirtualBox安装目录：D:\Program Files\Oracle\VirtualBox，然后输入VBoxManage list hdds，回车，查看需要扩容的虚拟硬盘的UUID，然后输入输入命令：VBoxManage modifyhd be05c3ee-3f64-4564-a3e5-7a00bfc4e233 --resize 102400，102400代表要把虚拟硬盘改成多少M。注意，在调整硬盘之前，一定要先关闭该虚拟机，要扩容的虚拟硬盘在以前创建时应该是动态增长的。
然后打开虚拟机，可以看到硬盘空间并没有变化，这是因为虚拟硬盘还没有扩展，这里以windows server 2008 R2虚拟机为例：
点击开始，管理工具里的共享和存储管理，如下图：
右击需要扩展的硬盘，然后填写需要更改的空间大小，确定，然后再查看硬盘的大小。
遇到linux磁盘空间不足的问题，于是网上找了一下，实际操作后，可行！ 如下办法可以办到：（网上搜集） http://hi.baidu.com/zidanexun/item/dd320caf9d38a6ab28ce9df0 ============================================================== 随着Linux虚拟机的不断使用，在VMware中经常遇到 预先装好的 linux 虚拟机的硬盘空间过小的问题，造成很多软件不能安装， 而重新装一个，又挺麻烦。于是，上网搜了下关于 vmware 硬盘扩容的方法。 总结如下：
1、挂载点必须是一个目录。
2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。
一：首先使用VMware工具扩容分配的硬盘空间：
1 、 vmware 提供一个命令行工具， vmware-vdiskmanager.exe ，位于 vmware 的安装目录下，比如
C:\Program Files\VMware\VMware Workstation\vmware-vdiskmanager.exe.
在 windows 下运行 cmd ，转到 vmware 的安装目录
vmware-vdiskmanager.exe 可以查看帮助
2. 对于扩容，可以输入下列命令：
vmware-vdiskmanager -x 50Gb &#34;D:\VMware\WinXP\myLinux.vmdk&#34;
注： 要扩容的系统这时不能在运行 ，参数 &#34;-x&#34; 表示要扩展虚拟机硬盘空间，紧随其后的数字是要扩展到的大小 ( 本例为扩展到 50GB ，这是一个磁盘总量，包含了原先的磁盘容量 ) 。最后是指定要操作的虚拟机磁盘的具体文件，要是路径名中有空格，必须以双引号括起来。按回车键开始执行，执行完毕，退出命令提示符窗口，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fcea8d974bea25ca65403ffabd52f22d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-01-06T17:20:13+08:00" />
<meta property="article:modified_time" content="2013-01-06T17:20:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WM 虚拟机下Ubuntu系统扩展硬盘容量教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><span style="font-size:16px">以管理员身份打开， 命令提示符窗口，然后利用命令cd进入Oracle VM VirtualBox安装目录，如下图：</span></strong></p> 
<p><img alt="" src="https://images2.imgbox.com/4b/10/dWBtmSkx_o.gif"></p> 
<p><strong><span style="font-size:16px">我进入了Oracle VM VirtualBox安装目录：D:\Program Files\Oracle\VirtualBox，然后输入VBoxManage list hdds，回车，查看需要扩容的虚拟硬盘的UUID，然后输入输入命令：VBoxManage modifyhd be05c3ee-3f64-4564-a3e5-7a00bfc4e233 --resize 102400，102400代表要把虚拟硬盘改成多少M。<span style="color:#ff00">注意，在调整硬盘之前，一定要先关闭该虚拟机，要扩容的虚拟硬盘在以前创建时应该是动态增长的。</span></span></strong></p> 
<p><strong><span style="font-size:16px">然后打开虚拟机，可以看到硬盘空间并没有变化，这是因为虚拟硬盘还没有扩展，这里以windows server 2008 R2虚拟机为例：</span></strong></p> 
<p><strong><span style="font-size:16px">点击开始，管理工具里的共享和存储管理，如下图：</span></strong></p> 
<p><img alt="" src="https://images2.imgbox.com/2d/61/oPGnYWrm_o.gif" width="836" height="521"></p> 
<p><strong><span style="font-size:16px">右击需要扩展的硬盘，然后填写需要更改的空间大小，确定，然后再查看硬盘的大小。</span></strong></p> 
<p> </p> 
<p>遇到linux磁盘空间不足的问题，于是网上找了一下，实际操作后，可行！ </p> 
<div>
  如下办法可以办到：（网上搜集） 
</div> 
<div>
  http://hi.baidu.com/zidanexun/item/dd320caf9d38a6ab28ce9df0 
 <wbr></wbr> 
 <br> 
 <div>
   ============================================================== 
 </div> 
</div> 
<div> 
 <p>随着Linux虚拟机的不断使用，在VMware中经常遇到 预先装好的 linux 虚拟机的硬盘空间过小的问题，造成很多软件不能安装， 而重新装一个，又挺麻烦。于是，上网搜了下关于 vmware 硬盘扩容的方法。 总结如下：<br> <br> 1、挂载点必须是一个目录。<br> 2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。<br> <br> <br> 一：首先使用VMware工具扩容分配的硬盘空间：<br> <br> 1 、 vmware 提供一个命令行工具， vmware-vdiskmanager.exe ，位于 vmware 的安装目录下，比如<br> C:\Program Files\VMware\VMware Workstation\vmware-vdiskmanager.exe.<br> 在 windows 下运行 cmd ，转到 vmware 的安装目录<br> <wbr></wbr><wbr></wbr><wbr></wbr>vmware-vdiskmanager.exe 可以查看帮助<br> <br> 2. 对于扩容，可以输入下列命令：<br> <wbr></wbr><wbr></wbr><wbr></wbr>vmware-vdiskmanager -x 50Gb "D:\VMware\WinXP\myLinux.vmdk"<br> <br> <wbr></wbr><wbr></wbr>注： 要扩容的系统这时不能在运行 ，参数 "-x" 表示要扩展虚拟机硬盘空间，紧随其后的数字是要扩展到的大小 ( 本例为扩展到 50GB ，这是一个磁盘总量，包含了原先的磁盘容量 ) 。最后是指定要操作的虚拟机磁盘的具体文件，要是路径名中有空格，必须以双引号括起来。按回车键开始执行，执行完毕，退出命令提示符窗口，<br> <wbr></wbr><wbr></wbr><wbr></wbr>重启 VMware ，会发现虚拟机硬盘空间已变成 50GB 了。<br> <br> 我们重启虚拟机后，发现虚拟机的硬盘是变成 50GB 了，但进入 linux 系统后，用 "df -ah" 查看发现硬盘空间还是原先那么大。<br> <wbr></wbr>虽然已经扩大了磁盘，但是由于还没有经过分区，指定文件系统，所以 linux 操作系统无法识别（其实就相当于你的硬盘虽然大了，但是你并没有对其进行分区是一个道理）。下面我们进行分区处理。<br> <br> 方法二：使用VM图形界面，关闭虚拟机，编辑虚拟机配置，直接将硬盘空间扩容。<br> <br> 3. 分区：（ 这时要切换为 Root 用户，Ubuntu下使用sudo命令 ）<br> fdisk 命令： fdisk -l <wbr></wbr>: 打印当前的磁盘分区表，这时我们可以看到磁盘的总量的确增加到 50GB 了，但是分区只有以前的那几个原有的分区。<br> <wbr></wbr>键入命令： fdisk /dev/sda <wbr></wbr><wbr></wbr>“sda 就是经过扩容的硬盘，为 SCSI 硬盘， IDE 类型硬盘对应为 hda ，是对该硬盘进行操作 ”<br> <wbr></wbr>键入： <wbr></wbr><wbr></wbr><wbr></wbr>m <wbr></wbr><wbr></wbr><wbr></wbr>“ 列出 fdisk 的帮助 ”<br> <wbr></wbr>我们在这里是要添加一个新分区，即将扩容出来的那部分做成一个新分区，这样才能被操作系统挂载识别。<br> <wbr></wbr>键入： <wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr>n <wbr></wbr><wbr></wbr><wbr></wbr>” 命令 n 用于添加新分区 "<br> <wbr></wbr>此时， fdisk 会让你选择添加为逻辑分区呢（编号从 5 开始）还是主分区（编号 1 到 4 ）。选择主分区吧，则键入 p ；选择逻辑分区键入 l 。<br> <wbr></wbr>我们选择主分区于是：<br> <wbr></wbr>键入： <wbr></wbr><wbr></wbr><wbr></wbr>p <wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr>" 选择创建主分区 "<br> <br> <wbr></wbr>此时， fdisk 会让你选择主分区的编号，如果已经有了主分区 sda1 ， sda2 ，那么编号就选 3 ，即要创建的该分区为 sda3.<br> <wbr></wbr>键入： <wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr>3<br> <wbr></wbr>此时， fdisk 又会让你选择该分区的开始值这个就是分区的 Start 值（ start cylinder ）；这里最好直接按回车，<br> <wbr></wbr>如果您输入了一个非默认的数字，会造成空间浪费；<br> <wbr></wbr>此时键入： w <wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr>" 保存所有并退出，分区划分完毕 "<br> <br> 我们现在还不能用这个分区 , 因 没格式化 ，这时要重启系统就能够在 dev 下面看到 sda3 ，如果不重启不能进行下面操作<br> <br> 4. 格式化该新添加的分区：<br> <wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr>键入： mkfs -t ext3 <wbr></wbr>/dev/sda3 <wbr></wbr><br> <wbr></wbr>或者 <wbr></wbr><wbr></wbr>mkfs.ext3 <wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr>/dev/sda3 格式化指定的分区 , 依次类推 , 现在的系统大部分都是 ext3 格式 , 如果你需要其它的 , 可以查看 mkfs 的帮助。<br> 此时我们就可以使用该新增分区啦：<br> <br> 5 、挂载该分区：<br> <wbr></wbr>手动挂载，则键入：sudo mount /dev/sda3 <wbr></wbr>/mnt/sda3 <wbr></wbr>表示将该新分区挂载到 /mnt/sda3 / 这个目录下面<br> <br> (注：Ubuntu下默认是挂载到 /media对应目录下，并且手动挂载的信息在/etc/mtab文件下有登记信息）<br> <br> <wbr></wbr>开机自动挂载，则修改 /etc/fstab 文件，在这个文件里面添加一行：<br> /dev/sda3 <wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr>/mnt/sda3 <wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr>ext3 <wbr></wbr> <wbr></wbr><wbr></wbr>defaults <wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr>0 <wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr><wbr></wbr>0 <wbr></wbr><wbr></wbr><br> 到这里就可以使用该新加分区啦 。<br> <br> Redhat环境下手动挂载：<br> 1新建/oracledir文件夹<br> 2 mount /dev/sda3/ <wbr></wbr><wbr></wbr>/oracledir</p> 
 <p><br> 关于/etc/fstab文件的相信说明参见：<br> <br> <a href="http://www.5dlinux.com/article/1/2007/linux_10628.html" rel="nofollow">http://www.5dlinux.com/article/1/2007/linux_10628.html</a> <wbr></wbr></p> 
</div> 
<p> </p> 
<p> </p> 
<p>可能玩Linux的朋友都知道fstab这个文件，如果要用好linux，熟悉linux的一些核心配置文件是必要的，而fstab则是其中之一。这个文件描述系统中各种文件系统的信息，应用程序读取这个文件，然后根据其内容进行自动挂载的工作。因此，我们需要理解其中的内容，了解它如何与 mount命令配合工作，并能够针对自己的情况进行修改。<br> <br> 作为系统配置文件，fstab通常都位于/etc目录下，它包括了所有分区和存储设备的信息，以及它们应该挂载到哪里，以什么样子的方式挂载。如果遇到一些类似于无法挂载你的windows分区阿，无法使用你的光驱阿，无法对某个分区进行写入操作阿什么的，那么基本上可以断定，你的fstab内容有问题了。也就是说，你可以通过修改它来搞定这些问题，而不用去论坛冰天雪地裸体跪求答案了。<br> <br> 说了半天，/etc/fstab其实就是一个文本文件，用gedit或者vi都可以打开，当然，前提是root权限。在这个文件中，每个文件系统（包括分区或者设备）用一行来描述，在每一行中，用空格或TAB符号来分隔各个字段，文件中以*开头的行是注释信息。Fstab文件中的纪录的排序十分重要。因为 fsck，mount或umount等程序在做它们的工作时会按此顺序进行本。下面进行详细的讲解，本文假设读者已经有挂载文件系统和分区的基础知识。<br> <br> 在讲解之前要说一下，每个人所使用的系统情况都是不同的，包括硬件种类，所用系统等，因此fstab文件肯定是有所差异的。但是其基本结构，如上所述，都不会变。所以我们先以一个fstab内容作为<a class="wordstyle" href="http://mb.soucode.com/" rel="nofollow noopener noreferrer" target="_blank">模板</a>进行讲解。<br> <br> 首先请看下面这个例子：<br> /dev/hda2 / ext2 defaults 1 1<br> /dev/hdb1 /home ext2 defaults 1 2<br> /dev/cdrom /media/cdrom auto ro,noauto,user,exec 0 0<br> /dev/fd0 /media/floppy auto rw,noauto,user,sync 0 0<br> proc /proc proc defaults 0 0<br> /dev/hda1 swap swap pri=42 0 0<br> <br> 这些看起来毫无意义的字符代表了什么？在对应相应分区或者存储设备信息的每一行中，每一列又是什么意思？先大体讲一下，第一列表示设备的名称，第二列表示该设备的挂载点，第三列是文件系统，第四列是挂载选项，第五列是dump选项（用一个数字表示），第六列（接下来的数字）表示文件系统检查选项。好了，接下来，就要详细介绍这些参数的具体含义了。<br> <br> 第一、二列：设备和默认挂载点<br> <br> <br> 说实话，第一列和第二列的内容是最简单最直接的，它们的作用就是告诉mount命令，我想挂载什么分区或者什么设备，以及我所希望的挂载点在哪里。在fstab中为某一个设备指定的挂载点是其默认挂载点，也就是当你在挂载目录的时候没有手工指定其他目录的话，系统就将该设备挂载到这个目录。大多数 Linux发行版都会为挂载点创建专门的目录，大多数是在/mnt下，但是一些发行版（比如SUSE或者ubuntu）是在/media下。笔者使用的是 ubuntu，所以示例信息中也是用的/media目录。<br> <br> 按照我们给出的fstab示例，如果你敲入命令<br> <br> $ mount /dev/fd0<br> <br> 你的软驱就将挂载到/media/floppy，因为这是你告诉系统的软驱默认挂载点。如果没有这个信息，当你敲入mount命令时，mount 会感到很困惑：该死的，你想让我把这玩意挂载到哪里去呢？当然，如果你看fstab中发行版给你指定的默认挂载点不顺眼，也可以自由修改它，修改成任何一个你希望的目录都可以。如果还不存在，就首先创建这个目录。要知道，fstab是不会把所有工作都给你包干的哦。<br> <br> 另外，有一些分区和存储设备是在Linux系统启动的时候就自动挂载的，比如，让我们看看刚才列出来的fstab示例信息，有两行是这样的：<br> /dev/hda2 / ext2 defaults 1 1<br> /dev/hdb1 /home ext2 defaults 1 2<br> <br> 正如刚才我们讲到的那样，这两行表示/dev/hda2默认挂载到/根目录，而 /dev/hdb1则默认挂载到/home目录，。这些工作在你Linux系统启动的时候就会通过读取fstab自动完成，否则的话……想象你会遭受什么样的折磨吧，所有的程序都在/根目录下，而你却无法使用，因为你没有挂载/根目录！恩，我保证，这将是一次让人沮丧的系统使用经历。<br> <br> 除了显示的使用设备名，你可以使用设备的UUID或设备的卷标签，例如，你可以在这个字段写成“LABAL=root”或“UUID= 3e6be9de- 8139-11d1-9106-a43f08d823a6”，这将使系统更具伸缩性。例如，如果你的系统添加或移除了一个SCSI硬盘，这有可以改变你的设备名，但它不会修改你的卷标签。<br> <br> 对于NFS mount操作，这个字段应该包含host:dir格式的信息，例如:knuth.aeb.nl:/，对于进程文件系统procfs，使用proc。</p> 
<p>第三列：文件系统类型<br> <br> fstab中的第三列指示了设备或者分区的文件系统类型。它支持很多种类的文件系统，我们在这里只介绍最为常用的。如果想了解你的kernel目前支持哪些文件系统，可以查看/proc/filesystems的内容。如果这个字段定义为swap，这条纪录将关联到一个用于交换目的的文件或分区。如果这个字段定义为ignored，这行将被忽略。这对于显示目前没有使用的分区非常有用。<br> <br> ext2 和 ext3： Linux下的Ext2文件系统，是 GNU/Linux 系统中标准的文件系统，其特点为存取文件的性能极好，对于中小型的文件更显示出优势，这主要得利于其簇快取层的优良设计。至于Ext3文件系统，它属于一种日志文件系统，是对ext2系统的扩展。日志式文件系统的优越性在于，它会将整个磁盘的写入动作完整记录在磁盘的某个区域上，以便有需要时可以回朔追踪。由于详细纪录了每个细节，故当在某个过程中被中断时，系统可以根据这些记录直接回朔并重整被中断的部分，而不必花时间去检查其他的部分，故文件系统检测不一致时，重整的工作速度相当快，几乎不需要花时间。<br> <br> reiserfs： ReiserFS是一个非常优秀的文件系统。也是最早用于Linux的日志文件系统之一，其机制比Ext3要先进得多，风雷小弟一直使用的就是它，很多发行版现在也把它作为默认文件系统了。可惜其作者前段时间出事了……具体情况就不说了，也不知道下一代reiserfs4还能不能出来，因为ext4都有了。<br> <br> swap： Swap，即交换区，把它想象成虚拟内存就行了。<br> <br> vfat 和 ntfs：一看就知道是Windows分区格式了，呵呵。98，me等系统都是使用的vfat，也就是最流行的fat32格式，而NT系列则多使用 NTFS，当然也不是固定的，因此2000或者XP系统要具体情况具体分析。当初Linux对NTFS的写入支持不好，所以大多数资料都建议用户使用 vfat格式，但是现在支持已经很好了，即使不重新编译内核，也可以通过ntfs-3g来进行写入支持（具体方法请参考这篇文章），因此不用太在意这个了。<br> <br> auto：当然，这不是一个文件系统类型。auto只是表示，文件系统的类型将被自动检测。在上面的示例中，你会发现软驱和光驱的文件系统类型都是auto，为什么呢？因为它们的文件系统类型随时都可能改变，比如软驱，优盘这种设备，可能今天是vfat格式，明天你就把它格式化成了ntfs，因此，最明智的做法就是告诉系统，我没法确定这东西的当前类型，还是你自己检测吧。<br> <br> udf：由于刻录光驱越来越流行，现在很多发行版自带的fstab中，光驱的文件格式类型是UDF，UDF是Universal Disc Format的缩写，与ISO 9660格式相容。它采用标准的封装写入技术（PW，Packet Writing）将CD-R/CD-RW当作硬盘使用，用户可以在光盘上修改和删除文件。利用UDF格式进行刻录时，刻录软件将数据打包，并在内存中临时建立一个特殊文件目录表，同时接管系统对光盘的访问。<br> <br> iso9660：很多光驱也使用的这个选项。ISO9660是一种描述适合CD盘片的电脑文件结构的国际标准。采用此标准的盘片可以在不同的操作系统上使用，如MAC和Windows。<br> <br> 第四列：挂载选项<br> <br> fstab中的第四列表示设备或者分区所需要的挂载选项。这一列也是fstab中最复杂最容易出错的一列，当然，只要你能知道一些最常用的选项是什么意思，就可以让你从头疼中解脱出来。如果要把可用的选项一项一项介绍……恩，我估计我会写到明天，所以，我还是只是分析最常用的一些选项，如果你想知道更多的东西，还是求助于man吧。<br> <br> auto 和 noauto：这是控制设备是否自动挂载的选项。auto是默认选择的选项，这样，设备会在启动或者你使用mount -a命令时按照fstab的内容自动挂载。如果你不希望这样，就使用noauto选项，如果这样的话，你就只能明确地通过手工来挂载设备。<br> <br> user 和 nouser：这是一个非常有用的选项，user选项允许普通用户也能挂载设备，而nouser则只允许root用户挂载。nouser是默认选项，这也是让很多 Linux新手头疼的东西，因为他们发现没有办法正常挂载光驱，Windows分区等。如果你作为普通身份用户遇到类似问题，或者别的其他问题，就请把 user属性增加到fstab中。<br> <br> exec 和 noexec： exec允许你执行对应分区中的可执行二进制程序，同理，noexec的作用刚好相反。如果你拥有一个分区，分区上有一些可执行程序，而恰好你又不愿意，或者不能在你的系统中执行他们，就可以使用noexec属性。这种情况多发生于挂载Windows分区时。exec是默认选项，理由很简单，如果 noexec变成了你/根分区的默认选项的话……<br> <br> ro： 以只读来挂载文件系统。<br> <br> rw： 以可读可写的属性来挂载系统。<br> <br> sync 和 async：对于该文件系统的输入输出应该以什么方式完成。sync的意思就是同步完成，通俗点讲，就是当你拷贝一个东西到设备或者分区中时，所有的写入变化将在你输入cp命令后立即生效，这个东西应该立马就开始往设备或者分区里面拷贝了。而如果是async，也就是输入输出异步完成的话，当你拷贝一个东西到设备或者分区中时，可能在你敲击cp命令后很久，实际的写入操作才会执行，换句话说，就是进行了缓冲处理。<br> <br> 有时候这种机制蛮不错的，因为sync会影响你系统的运行速度，但是这也会带来一些问题。想一想，当你希望将一个文件拷贝到u盘上时，你执行了 cp 命令，却忘记执行umount命令（它会强行将缓冲区内容写入），那么你拷贝的文件实际上并没有在u盘上面。如果你是使用的mv命令，而你又很快将u盘拔出……恭喜你，文件会从这个星球上消失的。因此，虽然async是默认属性，但是对于u盘，移动硬盘这种可移动存储设备，最好还是让他们使用sync选项。<br> <br> defaults： 所有选项全部使用默认配置，包括rw, suid, dev, exec, auto, nouser, 和 async。<br> <br> 一般用户没有特殊需求，直接使用defaults就可以了。看完介绍，我们再回过头去看看前面的示例内容，以光驱为例，主要关注挂载选项这里，可以看到，光驱和其他分区设备的不同是ro，因为普通光驱是只读的。而exec则让你可以从光驱上直接执行某些程序。<br> <br> 第五、六列：dump和fsck选项<br> <br> Dump和fsck？这是什么东西？恩，dump是一个备份工具，而fsck是一个文件系统扫描检查工具。我不会在这里详细介绍它们，因为用man或者google都可以获得更加详细的信息。<br> <br> fstab的第五列是表示dump选项，dump工具通过这个选项位置上的数字来决定文件系统是否需要备份。如果是0，dump就会被忽略，事实上，大多数的dump设置都是0。而第六列是fsck选项，fsck命令通过检测该字段来决定文件系统通过什么顺序来扫描检查，根文件系统/对应该字段的值应该为1，其他文件系统应该为2。若文件系统无需在启动时扫描检查，则设置该字段为0.</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ffb4090c09794b60215ab7b95757ce4a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">虚拟机中系统扩展硬盘分区大小</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c080576ad4852206ea159e815b70740f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VS2010  Windows   API  串口编程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>