<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Override和new的区别 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Override和new的区别" />
<meta property="og:description" content="override
1. override是派生类用来重写基类中方法的；
2. override不能重写非虚方法和静态方法；
3. override只能重写用virtual、abstract、override修饰的方法；
4. 不能使用修饰符 new、static、virtual 或 abstract 来修改 override 方法。
new
1. new是派生类用来隐藏基类中的方法的；也就是说在派生类中“看不到”基类中的方法；
2. 如果要在派生类中隐藏（不是重写）基类中的方法，而没有使用new关键字，编译时会出现一个警告，提示如果是要隐藏基类中的方法，请使用new关键字；
3. 派生类可以隐藏基类中的虚方法，也可以隐藏基类中的普通方法。
4. 如果在派生类中用private来修饰new 方法，那么只在该派生类中隐藏了基类中的方法，在该派生类之外，相当于没有隐藏基类中的方法；
5. 如果在派生类中隐藏了基类中的方法，在该派生类的派生类中，将延续对该派生类对基类方法的隐藏。
代码：
class A { public virtual void Func() // 注意virtual,表明这是一个虚拟函数 { Console.WriteLine(&#34;Func In A&#34;); } } class B : A // 注意B是从A类继承,所以A是父类,B是子类 { public override void Func() // 注意override ,表明重新实现了虚函数 { Console.WriteLine(&#34;Func In B&#34;); } } class C : B // 注意C是从B类继承,所以B是父类,C是子类 { } class D : A // 注意D是从A类继承,所以A是父类,D是子类 { public new void Func() // 注意new，表明覆盖父类里的同名类，而不是重新实现 { Console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/60534943178643f50104c43ec9967638/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-17T19:57:07+08:00" />
<meta property="article:modified_time" content="2019-09-17T19:57:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Override和new的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>override</strong></p> 
<p>1. override是派生类用来重写基类中方法的；</p> 
<p>2. override不能重写非虚方法和静态方法；</p> 
<p>3. override只能重写用virtual、abstract、override修饰的方法；</p> 
<p>4. 不能使用修饰符 new、static、virtual 或 abstract 来修改 override 方法。</p> 
<p><strong>new</strong></p> 
<p>1. new是派生类用来隐藏基类中的方法的；也就是说在派生类中“看不到”基类中的方法；</p> 
<p>2. 如果要在派生类中隐藏（不是重写）基类中的方法，而没有使用new关键字，编译时会出现一个警告，提示如果是要隐藏基类中的方法，请使用new关键字；</p> 
<p>3. 派生类可以隐藏基类中的虚方法，也可以隐藏基类中的普通方法。</p> 
<p>4. 如果在派生类中用private来修饰new 方法，那么只在该派生类中隐藏了基类中的方法，在该派生类之外，相当于没有隐藏基类中的方法；</p> 
<p>5. 如果在派生类中隐藏了基类中的方法，在该派生类的派生类中，将延续对该派生类对基类方法的隐藏。</p> 
<p> </p> 
<p>代码：</p> 
<pre> class A
    {
        public virtual void Func() // 注意virtual,表明这是一个虚拟函数 
        {
            Console.WriteLine("Func In A");
        }
    }
    class B : A // 注意B是从A类继承,所以A是父类,B是子类 
    {
        public override void Func() // 注意override ,表明重新实现了虚函数 
        {
            Console.WriteLine("Func In B");
        }
    }
    class C : B // 注意C是从B类继承,所以B是父类,C是子类 
    {
    }
    class D : A // 注意D是从A类继承,所以A是父类,D是子类 
    {
        public new void Func() // 注意new，表明覆盖父类里的同名类，而不是重新实现 
        {
            Console.WriteLine("Func In D");
        }
    }
    class E : D // 注意E是从D类继承,所以D是父类,E是子类 
    {
      
    }
    class F : A
    {
        private new void Func() //注意new关键字前有private修饰符，故该隐藏只在F类内有效
        {
            Console.WriteLine("Func In F");
        }

        public void Func2() 
        {
            Func(); //在F类内隐藏了基类的Func方法，故此处调用的private new void Func()
        }
    }


 static void Main(string[] args)
        {
            A a; // 定义一个a这个A类的对象.这个A就是a的申明类 
            A b; // 定义一个b这个A类的对象.这个A就是b的申明类 
            A c; // 定义一个c这个A类的对象.这个A就是c的申明类 
            A d; // 定义一个d这个A类的对象.这个A就是d的申明类 
            A e; // 定义一个e这个A类的对象.这个A就是e的申明类 
            A f; // 定义一个f这个A类的对象.这个A就是f的申明类 
            a = new A(); // 实例化a对象,A是a的实例类 
            b = new B(); // 实例化b对象,B是b的实例类 
            c = new C(); // 实例化c对象,C是c的实例类 
            d = new D(); // 实例化d对象,D是d的实例类 
            e = new E(); // 实例化e对象,E是e的实例类
            f = new F(); // 实例化f对象,F是f的实例类
            Console.WriteLine("a.Func();");
            a.Func(); // 执行a.Func：1.先检查申明类A 2.检查到是虚拟方法 3.转去检查实例类A，就为本身 4.执行实例类A中的方法 5.输出结果 Func In A 
            Console.WriteLine("b.Func();");
            b.Func(); // 执行b.Func：1.先检查申明类A 2.检查到是虚拟方法 3.转去检查实例类B，有重载的 4.执行实例类B中的方法 5.输出结果 Func In B 
            Console.WriteLine("c.Func();");
            c.Func(); // 执行c.Func：1.先检查申明类A 2.检查到是虚拟方法 3.转去检查实例类C，无重载的 4.转去检查类C的父类B，有重载的 5.执行父类B中的Func方法 5.输出结果 Func In B 
            Console.WriteLine("d.Func();");
            d.Func(); // 执行d.Func：1.先检查申明类A 2.检查到是虚拟方法 3.转去检查实例类D，无重载的（这个地方要注意了，虽然D里有实现Func()，但没有使用override关键字，所以不会被认为是重载） 4.转去检查类D的父类A，就为本身 5.执行父类A中的Func方法 5.输出结果 Func In A 
            Console.WriteLine("e.Func();");
            e.Func(); // 执行e.Func：E继承D，E.Func没有重写父类中的方法，相当于执行父类D中的Func方法，输出结果 Func In A 
            Console.WriteLine("f.Func();");
            f.Func(); // 执行f.Func：F类中虽然隐藏了基类中的Func方法，但是有private修饰符，该隐藏只在F类范围内有效。执行f.Func相当于执行其基类中的Func方法，输出结果 Func In A 
            
            D d1 = new D();
            Console.WriteLine("d1.Func();");
            d1.Func(); // 执行D类里的Func()，输出结果 Func In D 

            E e1 = new E();
            Console.WriteLine("e1.Func();");
            e1.Func(); // 执行E类里的Func()，输出结果 Func In D

            F f1 = new F();
            Console.WriteLine("f1.Func();");
            f1.Func(); // 执行F类里的Func()，输出结果 Func In A
            Console.WriteLine("f1.Func2();");
            f1.Func2(); // 执行F类里的Func2()，输出结果 Func In F
           
            Console.ReadLine();
        }
</pre> 
<p>---------------------------------------------------------------------------------------------</p> 
<p>默认情况下，C# 方法不是虚方法 -- 如果将一种方法声明为虚方法，则继承该方法的任何类都可以实现其自己的版本。若要使方法成为虚方法，必须在基类的方法声明中使用 <strong>virtual</strong> 修饰符。然后，派生类可以使用 <strong>override</strong> 关键字重写基虚方法，或使用 <strong>new</strong> 关键字隐藏基类中的虚方法。如果 <strong>override</strong> 关键字和 <strong>new</strong> 关键字均未指定，编译器将发出警告，并且派生类中的方法将隐藏基类中的方法。</p> 
<p>使用 <strong>new</strong> 关键字告诉编译器您的定义将隐藏基类中包含的定义。这是默认行为。</p> 
<p> </p> 
<p>转载自<a href="https://www.cnblogs.com/xiaoyusmile/archive/2012/06/18/2553851.html" rel="nofollow">https://www.cnblogs.com/xiaoyusmile/archive/2012/06/18/2553851.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d6cd73b862233cc9c6a86187486be2d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">kafka 主题管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/761c87025fa10d8c5c7b06991ae191e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IntelliJ IDEA 创建Web项目（全教程）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>