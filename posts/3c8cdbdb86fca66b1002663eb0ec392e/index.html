<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【设计模式】-代理模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【设计模式】-代理模式" />
<meta property="og:description" content="在软件开发中，经常遇到需要对某个对象进行控制或者监控的场景。而直接修改对象的代码可能使代码变得复杂且难以维护。这时，使用代理模式（Proxy Pattern）可以很好地解决这个问题。
代理模式是一种结构型设计模式，通过引入一个代理对象来替代原始对象，实现对原有对象的控制或扩展。Java中的代理模式常用于实现日志记录、权限控制、事务控制等功能。
原理及实现思路 代理模式的核心思想是通过引入代理对象作为中间层，将客户端的请求转发给真正的对象，从而实现对真实对象的控制。
代理模式包含三个主要角色：
抽象主题（Subject）：定义了代理对象和真实对象的共同接口。
真实主题（RealSubject）：实现了抽象主题接口，是真正的业务逻辑处理对象。
代理主题（ProxySubject）：实现了抽象主题接口，内部持有一个真实主题对象的引用，通过代理对象间接调用真实对象。
实现代理模式的步骤如下：
创建抽象主题接口，定义需要代理的方法。
创建真实主题类，实现抽象主题接口，完成真正的业务逻辑。
创建代理主题类，实现抽象主题接口，持有一个真实主题对象的引用，在代理方法中调用真实主题的方法。
静态代理 静态代理是最简单的一种代理技术，由程序员手动编写代理类来代替真实对象。静态代理在编译期生成代理类，在运行时代理类不会发生变化。
静态代理的优点是简单易懂、易于实现，但缺点也显而易见，每个代理类只能代理一个具体类，当代理类的数量较多时，会导致代码冗余，并且每个代理类只能代理一个固定的类。
示例代码如下：
// 抽象主题接口 interface Subject { void doSomething(); } // 真实主题类 class RealSubject implements Subject { @Override public void doSomething() { System.out.println(&#34;RealSubject do something.&#34;); } } // 代理主题类 class ProxySubject implements Subject { private Subject realSubject; public ProxySubject(Subject realSubject) { this.realSubject = realSubject; } @Override public void doSomething() { // 对真实主题方法的增强 System.out.println(&#34;Before do something." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3c8cdbdb86fca66b1002663eb0ec392e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-07T15:51:17+08:00" />
<meta property="article:modified_time" content="2023-08-07T15:51:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【设计模式】-代理模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>在软件开发中，经常遇到需要对某个对象进行控制或者监控的场景。而直接修改对象的代码可能使代码变得复杂且难以维护。这时，使用代理模式（Proxy Pattern）可以很好地解决这个问题。</p> 
</blockquote> 
<p>         代理模式是一种结构型设计模式，<strong>通过引入一个代理对象来替代原始对象</strong>，实现对原有对象的控制或扩展。Java中的代理模式常用于<strong><span style="color:#fe2c24;">实现日志记录</span></strong>、<strong><span style="color:#fe2c24;">权限控制</span></strong>、<strong><span style="color:#fe2c24;">事务控制</span></strong>等功能。</p> 
<hr> 
<h3>原理及实现思路</h3> 
<p>代理模式的核心思想是通过引入代理对象作为中间层，将客户端的请求转发给真正的对象，从而实现对真实对象的控制。</p> 
<p><strong>代理模式包含三个主要角色：</strong></p> 
<ul><li> <p><strong>抽象主题（Subject）</strong>：定义了代理对象和真实对象的共同接口。</p> </li><li> <p><strong>真实主题（RealSubject）</strong>：实现了抽象主题接口，是真正的业务逻辑处理对象。</p> </li><li> <p><strong>代理主题（ProxySubject）</strong>：实现了抽象主题接口，内部持有一个真实主题对象的引用，通过代理对象间接调用真实对象。</p> </li></ul> 
<p><strong>实现代理模式的步骤如下：</strong></p> 
<ol><li> <p>创建抽象主题接口，定义需要代理的方法。</p> </li><li> <p>创建真实主题类，实现抽象主题接口，完成真正的业务逻辑。</p> </li><li> <p>创建代理主题类，实现抽象主题接口，持有一个真实主题对象的引用，在代理方法中调用真实主题的方法。</p> </li></ol> 
<h4>静态代理</h4> 
<p>        静态代理是最简单的一种代理技术，由程序员手动编写代理类来代替真实对象。静态代理在<strong>编译期</strong>生成代理类，<strong>在运行时代理类不会发生变化</strong>。</p> 
<p>        静态代理的优点是简单易懂、易于实现，但<strong>缺点</strong>也显而易见，<u><span style="background-color:#d7d8d9;">每个代理类只能代理一个具体类，当代理类的数量较多时，会导致代码冗余，并且每个代理类只能代理一个固定的类</span></u>。</p> 
<p>示例代码如下：</p> 
<pre><code class="language-java">// 抽象主题接口
interface Subject {
    void doSomething();
}

// 真实主题类
class RealSubject implements Subject {
    @Override
    public void doSomething() {
        System.out.println("RealSubject do something.");
    }
}

// 代理主题类
class ProxySubject implements Subject {
    private Subject realSubject;

    public ProxySubject(Subject realSubject) {
        this.realSubject = realSubject;
    }

    @Override
    public void doSomething() {
        // 对真实主题方法的增强
        System.out.println("Before do something.");
        realSubject.doSomething();
        System.out.println("After do something.");
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        RealSubject realSubject = new RealSubject();
        ProxySubject proxySubject = new ProxySubject(realSubject);
        proxySubject.doSomething();
    }
}</code></pre> 
<h4>动态代理</h4> 
<p>        动态代理是在运行时动态地生成代理对象，相比于静态代理，动态代理更加灵活。Java中提供了两种动态代理的实现方式：<strong>基于接口的动态代理</strong>和<strong>基于类的动态代理</strong>。</p> 
<p>        基于接口的动态代理使用<code>java.lang.reflect.Proxy</code>类以及<code>java.lang.reflect.InvocationHandler</code>接口来实现。</p> 
<p>        这种方式要求被代理类实现一个接口，并通过代理类来间接调用真实对象的方法。</p> 
<p>示例代码如下：</p> 
<pre><code class="language-java">import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 抽象主题接口
interface Subject {
    void doSomething();
}

// 真实主题类
class RealSubject implements Subject {
    @Override
    public void doSomething() {
        System.out.println("RealSubject do something.");
    }
}

// InvocationHandler实现类
class MyInvocationHandler implements InvocationHandler {
    private Object realSubject;

    public MyInvocationHandler(Object realSubject) {
        this.realSubject = realSubject;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 对真实主题方法的增强
        System.out.println("Before do something.");
        Object result = method.invoke(realSubject, args);
        System.out.println("After do something.");
        return result;
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        RealSubject realSubject = new RealSubject();
        InvocationHandler handler = new MyInvocationHandler(realSubject);
        Subject proxySubject = (Subject) Proxy.newProxyInstance(
                Client.class.getClassLoader(),
                new Class[]{Subject.class},
                handler);
        proxySubject.doSomething();
    }
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>基于类的动态代理使用<code>cglib</code>库，不要求被代理类实现接口，通过生成子类来实现代理。</strong></span></p> 
<p>示例代码如下：</p> 
<pre><code class="language-java">import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

// 真实主题类
class RealSubject {
    public void doSomething() {
        System.out.println("RealSubject do something.");
    }
}

// MethodInterceptor实现类
class MyMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        // 对真实主题方法的增强
        System.out.println("Before do something.");
        Object result = methodProxy.invokeSuper(object, args);
        System.out.println("After do something.");
        return result;
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(RealSubject.class);
        enhancer.setCallback(new MyMethodInterceptor());
        RealSubject proxySubject = (RealSubject) enhancer.create();
        proxySubject.doSomething();
    }
}</code></pre> 
<h4>不同代理模式的优缺点及适用场景</h4> 
<p><strong>优缺点</strong></p> 
<ul><li> <p>静态代理的优点在于简单易懂、易于实现。缺点是每个代理类只能代理一个具体类，导致代码冗余，不够灵活。</p> </li><li> <p>基于接口的动态代理的优点是可以代理实现了指定接口的任意对象，不需要修改原有代码。缺点是只能代理接口中定义的方法。</p> </li><li> <p>基于类的动态代理的优点是可以代理任意类的对象，不需要修改原有代码。缺点是不能代理<code>final</code>修饰的类和方法。</p> </li></ul> 
<p><strong>适用场景：</strong></p> 
<ul><li> <p>静态代理适用于只需要代理少数几个类，并且不需要频繁地修改代理类的情况。</p> </li><li> <p>基于接口的动态代理适用于需要对接口中的方法进行控制和扩展的情况。</p> </li><li> <p>基于类的动态代理适用于不需要修改原有代码、对类的任意方法进行控制和扩展的情况。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/859902a589f19ee871a14eb24e633a8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【vue回顾系列】25-一图看懂生命周期，并教你怎么口述出来</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92e8622e5a2e75ecbddae198885cdb3c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【设计模式】-建造者模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>