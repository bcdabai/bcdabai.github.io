<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>硬件SPI通信协议 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="硬件SPI通信协议" />
<meta property="og:description" content="1、简介 SPI（Serial Peripheral Interface，串行外设接口）是一种全双工同步串行通信接口，用于MCU与各种外围设备以串行方式进行通信以交换信息，通信速度最高可达25MHz以上。
SPI通常由四条线组成，一条主设备输出与从设备输入（Master Output Slave Input，MOSI），一条主设备输入与从设备输出（Master Input Slave Output，MISO），一条时钟信号（Serial Clock，SCLK），一条从设备使能选择（Chip Select，CS）。
2、物理层 1、连接方式 SPI可以一个主机连接多个从机，通过CS线来确定当前与哪一个从机进行通信，SPI的连接方式如下图所示：
1、当有多个SPI从设备与SPI主机相连时，设备的其它信号线SCK、MOSI及MISO同时并联到相同的SPI总线上，即无论有多少个从设备，都共同使用这3条总线；而每个从设备都有独立的这一条CS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。
2、输入的MISO为了防止两个设备同时响应造成短路，所以这里主机没有选中到的时候他们片选线都为高组态的状态
3、SPI使用CS信号线来进行寻址，当把要通信的设备的CS线拉低时，该设备被选中，即片选有效，开始进行通信。当CS线拉高时停止通信。
2、数据传输 数据的传输方式如图所示：
1、主机和从机都有一个移位寄存器，主机移位寄存器数据经过MOSI将数据写入从机的移位寄存器，此时从机移位寄存器的数据也通过MISO传给了主机，实现了两个移位寄存器的数据交换。无论主机还是从机，发送和接收都是同时进行的。
2、如果主机只对从机进行写操作，主机只需忽略接收的从机数据即可。如果主机要读取从机数据，需要发送一个空字节（0xff）来引发从机发送数据。
3、数据的传输可以选择低位先传输或者是高位先传输。
3、协议层 通过CPOL和CPHA的不同组合，SPI可以有四种不同的通信方式。
CPOL(时钟极性)：表示SCK在空闲时为高电平还是低电平，当CPOL=0时，SCK空闲时为低电平；当CPOL=1时，SCK空闲时为高电平。
CPHA(时钟相位)：表示SCK在第几个时钟边缘采样数据，当CPHA=0时，在SCK第一个时钟边缘采样；当CPHA时，在SCK第二个时钟边缘采样。
四种模式分别为：
SPI模式CPOLCPHA说明000时钟空闲状态为低电平，在第一个时钟边缘采样，即上升沿101时钟空闲状态为低电平，在第二个时钟边缘采样，即下降沿210时钟空闲状态为高电平，在第一个时钟边缘采样，即下降沿311时钟空闲状态为高电平，在第二个时钟边缘采样，即上升沿 时序图如下：
4、固件库的使用 1、初始化 /*********************************************** * @brief : SPI模式配置 * @param : void * @return: void * @date : 2023.10.20 * @author: L ************************************************/ void Spi1Init(void) { Spi1GpioInit();//初始化SPI使用的端口 SPI_InitTypeDef spi_config = {0};//spi初始化结构体句柄 //配置SPI模式 RCC_APB2PeriphClockCmd(SPI1_CLOCK,ENABLE);//开启SPI1时钟 spi_config.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;//4分频，即72M / 4，stm32f103c8t6在SPI最高支持18M spi_config.SPI_DataSize = SPI_DataSize_8b;//8位数据 spi_config." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6d5164ac14da3412b2cc0e6043fe6a55/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-04T22:20:19+08:00" />
<meta property="article:modified_time" content="2023-12-04T22:20:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">硬件SPI通信协议</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1、简介</h2> 
<p><strong>SPI</strong>（Serial Peripheral Interface，串行外设接口）是一种全双工同步串行通信接口，用于MCU与各种外围设备以串行方式进行通信以交换信息，通信速度最高可达25MHz以上。</p> 
<p>SPI通常由四条线组成，一条主设备输出与从设备输入（Master Output Slave Input，MOSI），一条主设备输入与从设备输出（Master Input Slave Output，MISO），一条时钟信号（Serial Clock，SCLK），一条从设备使能选择（Chip Select，CS）。</p> 
<h2>2、物理层</h2> 
<h3>1、连接方式</h3> 
<p>SPI可以一个主机连接多个从机，通过CS线来确定当前与哪一个从机进行通信，SPI的连接方式如下图所示：</p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/78/fb/wymmLIvB_o.png" width="608"></p> 
<p>1、当有多个SPI从设备与SPI主机相连时，设备的其它信号线SCK、MOSI及MISO同时并联到相同的SPI总线上，即无论有多少个从设备，都共同使用这3条总线；而每个从设备都有独立的这一条CS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。</p> 
<p>2、输入的MISO为了防止两个设备同时响应造成短路，所以这里主机没有选中到的时候他们片选线都为高组态的状态</p> 
<p>3、SPI使用CS信号线来进行寻址，当把要通信的设备的CS线拉低时，该设备被选中，即片选有效，开始进行通信。当CS线拉高时停止通信。</p> 
<h3>2、数据传输</h3> 
<p>数据的传输方式如图所示：</p> 
<p><img alt="" height="414" src="https://images2.imgbox.com/7d/e6/msR4zFZv_o.png" width="949"></p> 
<p>1、主机和从机都有一个移位寄存器，主机移位寄存器数据经过MOSI将数据写入从机的移位寄存器，此时从机移位寄存器的数据也通过MISO传给了主机，实现了两个移位寄存器的数据交换。无论主机还是从机，发送和接收都是同时进行的。</p> 
<p>2、如果主机只对从机进行写操作，主机只需忽略接收的从机数据即可。如果主机要读取从机数据，需要发送一个空字节（0xff）来引发从机发送数据。</p> 
<p>3、数据的传输可以选择低位先传输或者是高位先传输。</p> 
<h2>3、协议层</h2> 
<p>通过<strong>CPOL</strong>和<strong>CPHA</strong>的不同组合，SPI可以有四种不同的通信方式。</p> 
<blockquote> 
 <p><strong>CPOL(时钟极性)</strong>：表示SCK在空闲时为高电平还是低电平，当CPOL=0时，SCK空闲时为低电平；当CPOL=1时，SCK空闲时为高电平。</p> 
</blockquote> 
<blockquote> 
 <p>CPHA(时钟相位)：表示SCK在第几个时钟边缘采样数据，当CPHA=0时，在SCK第一个时钟边缘采样；当CPHA时，在SCK第二个时钟边缘采样。</p> 
</blockquote> 
<p>四种模式分别为：</p> 
<table><thead><tr><th>SPI模式</th><th>CPOL</th><th>CPHA</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>时钟空闲状态为低电平，在第一个时钟边缘采样，即上升沿</td></tr><tr><td>1</td><td>0</td><td>1</td><td>时钟空闲状态为低电平，在第二个时钟边缘采样，即下降沿</td></tr><tr><td>2</td><td>1</td><td>0</td><td>时钟空闲状态为高电平，在第一个时钟边缘采样，即下降沿</td></tr><tr><td>3</td><td>1</td><td>1</td><td>时钟空闲状态为高电平，在第二个时钟边缘采样，即上升沿</td></tr></tbody></table> 
<p>时序图如下：</p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/bd/d7/yjuhgrhW_o.png" width="950"></p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/cb/ea/5p7C43DG_o.png" width="907"></p> 
<h2>4、固件库的使用</h2> 
<h3>1、初始化</h3> 
<pre><code>/***********************************************
* @brief : SPI模式配置
* @param : void
* @return: void
* @date  : 2023.10.20
* @author: L
************************************************/
void Spi1Init(void)
{
    Spi1GpioInit();//初始化SPI使用的端口
    SPI_InitTypeDef spi_config = {0};//spi初始化结构体句柄
    
    //配置SPI模式
    RCC_APB2PeriphClockCmd(SPI1_CLOCK,ENABLE);//开启SPI1时钟
    spi_config.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;//4分频，即72M / 4，stm32f103c8t6在SPI最高支持18M
    spi_config.SPI_DataSize = SPI_DataSize_8b;//8位数据
    spi_config.SPI_Mode = SPI_Mode_Master;//主机模式
    spi_config.SPI_CPOL = SPI_CPOL_Low;//时钟空闲时为低电平
    spi_config.SPI_CPHA = SPI_CPHA_1Edge;//时钟的第一个跳变沿采样
    spi_config.SPI_Direction = SPI_Direction_2Lines_FullDuplex;//全双工
    spi_config.SPI_FirstBit = SPI_FirstBit_MSB;//高位数据先发送
    spi_config.SPI_NSS = SPI_NSS_Soft;//软件控制片选信号
    spi_config.SPI_CRCPolynomial = 7;//CRC值计算的多项式

    SPI_Init(SPI1,&amp;spi_config);//初始化SPI1

    SPI_Cmd(SPI1,ENABLE);
}
</code></pre> 
<h3>2、SPI+DMA模式(以LCD刷屏为例)</h3> 
<p>首先先初始化DMA：</p> 
<pre><code>/***********************************************
* @brief : 屏幕刷新使用的DMA初始化
* @param : buffer_size:传送的数据量
*          paddr:外设基地址
*          maddr:内存基地址
* @return: void
* @date  : 2023.11.4
* @author: L
************************************************/
void LcdDmaInit(uint32_t buffer_size,uint32_t paddr,uint32_t maddr)
{
    DMA_InitTypeDef lcd_dma = {0};//DMA句柄结构体

    //DMA模式配置
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);//开启DMA1时钟
    DMA_DeInit(DMA1_Channel3);//复位DMA1的通道3，SPI1_Tx

    lcd_dma.DMA_Mode = DMA_Mode_Normal;//不循环
    lcd_dma.DMA_DIR = DMA_DIR_PeripheralDST;//从内存到外设
    lcd_dma.DMA_PeripheralBaseAddr = paddr;//SPI1数据寄存器地址
    lcd_dma.DMA_MemoryBaseAddr = maddr;//存储区地址
    lcd_dma.DMA_BufferSize = buffer_size;//传送的数据量
    lcd_dma.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;//16位
    lcd_dma.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;//16位
    lcd_dma.DMA_M2M = DMA_M2M_Disable;//关闭存储器到存储器模式
    lcd_dma.DMA_Priority = DMA_Priority_Low;//最低等优先级
    lcd_dma.DMA_MemoryInc = DMA_MemoryInc_Enable;//存储区数据地址自增
    lcd_dma.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设地址不自增

    DMA_Init(DMA1_Channel3,&amp;lcd_dma);//初始化DMA1通道3
    DMA_ClearITPendingBit(DMA1_IT_TC3);//清除DMA1通道3发送完成标志位
    DMA_ITConfig(DMA1_Channel3,DMA_IT_TC,ENABLE);//使能传送完成中断
}
</code></pre> 
<p>由于初始化屏幕发送的命令和数据都是8位的，所以SPI初始化的时候配置为8位数据的模式，但是屏幕显示的颜色是是16位的数据，所以DMA设置为16位的传输，SPI也需要修改为16位，可以使用这几句：</p> 
<pre><code> 	SPI1-&gt;CR1 &amp;= 0xFFDF;//失能SPI1，CR1的SPE位置0，否则写入传输位数时会出错
											//这里没使用库函数给的失能函数是因为发现里面好像是写错的
	SPI1-&gt;CR1 |= 1 &lt;&lt; 11;//传输位数设置为16位，CR1的DFF位置1
	SPI_Cmd(SPI1, ENABLE);//使能SPI1

  SPI_I2S_DMACmd(SPI1,SPI_I2S_DMAReq_Tx,ENABLE);//发送DMA请求
</code></pre> 
<p>同时DMA的计数值每次都要重新载入：</p> 
<pre><code>/***********************************************
* @brief : DMA计数值重新载入
* @param : buffer_size:传送的数据量
*          paddr:外设基地址
*          maddr:内存基地址
* @return: void
* @date  : 2023.10.23
* @author: L
************************************************/
void DmaRestart(uint32_t buffer_size,uint32_t paddr,uint32_t maddr)
{
    DMA1_Channel3-&gt;CPAR = paddr;//重新写入外设地址
    DMA1_Channel3-&gt;CMAR = maddr;//重新写入内存地址

    DMA_Cmd(DMA1_Channel3,DISABLE);//失能DMA1通道3，才能重新写入计数值
    DMA_SetCurrDataCounter(DMA1_Channel3,buffer_size);//重新写入计数值
    DMA_Cmd(DMA1_Channel3,ENABLE);//使能DMA1通道3,开始传输数据
}
</code></pre> 
<p>同时配置了DMA传输完成中断：</p> 
<pre><code>/***********************************************
* @brief : DMA1通道2中断优先级配置
* @param : void
* @return: void
* @date  : 2023.11.2
* @author: L
************************************************/
void DmaNvicConfig(void)
{
    NVIC_InitTypeDef dma_nvic = {0};

    dma_nvic.NVIC_IRQChannel = DMA1_Channel3_IRQn;
    dma_nvic.NVIC_IRQChannelPreemptionPriority = 5;
    dma_nvic.NVIC_IRQChannelSubPriority = 0;
    dma_nvic.NVIC_IRQChannelCmd = ENABLE;

    NVIC_Init(&amp;dma_nvic);
    NVIC_EnableIRQ(DMA1_Channel3_IRQn);//使能NVIC控制器
}
</code></pre> 
<p>根据参考手册所说(如下图)，DMA传送完成后需要等待SPI全部发送完成。</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/62/c6/y0j6yid8_o.png" width="1199"></p> 
<pre><code>/***********************************************
* @brief : DMA1通道2中断回调函数
* @param : void
* @return: void
* @date  : 2023.11.2
* @author: L
************************************************/
void DMA1_Channel3_IRQHandler(void)
{
	if(DMA_GetITStatus(DMA1_IT_TC3))
	{
        while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) == RESET)
				while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_BSY));

        SPI1-&gt;CR1 &amp;= 0xFFDF;//失能SPI1，CR1的SPE位置0，否则写入传输位数时会出错	
        SPI1-&gt;CR1 &amp;= 0xF7FF;//传输位数设置为8位，CR1的DFF位置0
        SPI1-&gt;CR1 |= 1 &lt;&lt; 6;;//使能SPI1
    
        show_over = 1;//刷新完成

        DMA_ClearFlag(DMA1_FLAG_TC3);//清除发送完成标志位
				DMA_ClearITPendingBit(DMA1_IT_TC3);//清除发送完成中断标志位
	}
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c88d619f3126647447aa0c5c1e250bc1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">1-Hadoop原理与技术</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdb131321e950546df7e6e656ddcb7b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python之使用深度学习创建自己的表情符号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>