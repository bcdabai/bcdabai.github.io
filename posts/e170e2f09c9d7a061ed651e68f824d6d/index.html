<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>迭代法（迭代&#43;栈）模拟递归实现深度优先搜索（DFS）：以力扣原题[112. 路径总和]及[113. 路径总和 II]为例 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="迭代法（迭代&#43;栈）模拟递归实现深度优先搜索（DFS）：以力扣原题[112. 路径总和]及[113. 路径总和 II]为例" />
<meta property="og:description" content="我们以两道力扣原题作为例子来讲解如何用迭代法来实现深度优先搜索：
112. 路径总和
113. 路径总和 II
对于[112. 路径总和]，我们可以很容易写出以下递归版的深度优先搜索代码：
class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) { // 1.边界条件 return false; } if (targetSum - root.val == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) { // 3.边界条件及条件判断，符合条件的叶节点 return true; } // 2.状态转移 // 只要子递归有一个返回 true，由于 || 的运算逻辑，将直接返回 true （短路运算特性，如果是前面的返回 true，后面的递归将不会调用） return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); // targetSum - root." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e170e2f09c9d7a061ed651e68f824d6d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-14T19:32:34+08:00" />
<meta property="article:modified_time" content="2023-04-14T19:32:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">迭代法（迭代&#43;栈）模拟递归实现深度优先搜索（DFS）：以力扣原题[112. 路径总和]及[113. 路径总和 II]为例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>我们以两道力扣原题作为例子来讲解如何用迭代法来实现深度优先搜索：</p> 
<blockquote> 
 <p><a href="https://leetcode.cn/problems/path-sum/" rel="nofollow">112. 路径总和</a><br> <a href="https://leetcode.cn/problems/path-sum-ii/" rel="nofollow">113. 路径总和 II</a></p> 
</blockquote> 
<p>对于[112. 路径总和]，我们可以很容易写出以下递归版的深度优先搜索代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 1.边界条件</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 3.边界条件及条件判断，符合条件的叶节点</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

		<span class="token comment">// 2.状态转移</span>
		<span class="token comment">// 只要子递归有一个返回 true，由于 || 的运算逻辑，将直接返回 true （短路运算特性，如果是前面的返回 true，后面的递归将不会调用）</span>
        <span class="token keyword">return</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// targetSum - root.val 隐藏着回溯信息：因为是传值而非传引用，子递归返回时 targetSum 在该层的值不变</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>深度优先搜索有三大特点：</p> 
<ol><li>边界条件：到达搜索边界时就该停止继续搜索了</li><li>状态转移：深度优先搜索的任何一层递归（树的节点、图的节点）都可以视为一种状态，从一层递归到另一层递归可以认为是状态转移，求解过程其实就是在不断地状态转移中寻找符合要求的状态</li><li>条件判断：每转移到一个新的状态就要判断这是否是想要的答案。如果只求找到一个答案，找到一个答案后就可以通过返回值将这个答案不断 return 到调用者那儿去了；如果要求找所有符合要求的答案，找到一个答案就要记录一个答案，然后继续搜索直到穷尽所有状态为止。</li></ol> 
<p>在状态转移中有一个深度优先搜索中重之又重的概念：回溯。回溯指的是在从一个前状态转移到一个后状态的情景中，在从后状态返回前状态后，前状态应该和转移前一样，这里就涉及到从后状态返回前状态的状态恢复，我们称这个状态恢复为回溯。</p> 
<p>对二叉树进行递归遍历其实就可以看做是一种特殊的深度优先搜索。对二叉树进行递归遍历：有边界条件：空节点；有状态转移：递归遍历左子树和右子树；唯一没有的就是条件判断，因为任何一个非空节点都是所求的答案。<br> 注：对树进行深度优先搜索，条件判断一般位于对树进行前序遍历访问节点的位置（根左右的根处）</p> 
<p>所以对二叉树的迭代法（迭代+栈）模拟递归实现深度优先搜索（DFS）实际是在迭代法模拟递归实现对二叉树的遍历的基础上实现的。需要重点改造的其实就是实现状态转移中非树节点元素的回溯（树节点的回溯在对二叉树的迭代遍历中已经实现了）。</p> 
<p>在[112. 路径总和]中，非树节点元素需要回溯的只有 targetSum。<br> 迭代法实现深度优先搜索求解[112. 路径总和]：</p> 
<pre><code class="prism language-java"><span class="token comment">// 用栈模拟深度优先搜索 回溯思想 对应的递归版的回溯逻辑使用参数而非全局变量</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Integer</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> targetSum <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 3.边界条件及条件判断，符合条件的叶节点</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>


            <span class="token comment">// 2.状态转移</span>
            <span class="token comment">// 想象 node 是有左右子孩子，且左右子孩子都是叶节点的节点</span>
            <span class="token comment">// 右孩子先入栈，同时配对入栈从根节点到右孩子这条路径上所有节点值之和；左孩子后入栈，同时配对入栈从根节点到左孩子这条路径上所有节点值之和</span>
            <span class="token comment">// 左孩子先出栈，处理的是从根节点到左孩子这条路径上所有节点值之和，因为是叶节点，没有新入栈的节点；</span>
            <span class="token comment">// 然后紧接着右孩子出栈，处理的是从根节点到右孩子这条路径上所有节点值之和</span>
            <span class="token comment">// 左孩子出栈到右孩子出栈就有一个回溯的过程，而这个回溯是在处理它们的父节点，将父节点的左右孩子入栈时就设定好的</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 1.边界条件，空节点不入栈</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先入栈右节点，才会先出栈左节点</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sum + root.right.val 隐藏着回溯逻辑</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 1.边界条件，空节点不入栈</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sum + root.left.val 隐藏着回溯逻辑</span>
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>[112. 路径总和]属于找到一个答案后就通过返回值将这个答案不断 return 到调用者那儿的类型，而[113. 路径总和 II]属于要求找所有符合要求的答案，找到一个答案就要记录一个答案，然后继续搜索直到穷尽所有状态为止的类型。一般来说，前者更适合直接用函数返回值返回答案，后者更适合用成员变量（全局变量）记录所有答案，返回类型设为 void，因为后者需要搜索整颗树寻找所有答案。</p> 
<p>递归法实现深度优先搜索求解[113. 路径总和 II]：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> roads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> road <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 原则上应该新写一个 DFS 函数，设定返回值为 void，在 pathSum 中调用 DFS，然后返回记录了答案集的 roads</span>
    <span class="token comment">// 但这种类型其实也可以写成用返回值返回答案</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">pathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 1.边界条件</span>
            <span class="token keyword">return</span> roads<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 计算从根节点遍历到该节点的整数目标和（用减表示）和路径，属于前序遍历处理逻辑，对应深度优先搜索条件判断的位置</span>
        targetSum <span class="token operator">-=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 2.状态转移</span>
        road<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2.状态转移</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetSum <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 3.边界条件及条件判断，符合条件的叶节点</span>
            roads<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span>road<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 2.状态转移</span>
        <span class="token function">pathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// targetSum 隐藏着回溯逻辑：因为是传值而非传引用，子递归中对 targetSum 的改变不影响该层递归 targetSum 的值</span>
        <span class="token function">pathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// targetSum 隐藏着回溯逻辑：因为是传值而非传引用，子递归中对 targetSum 的改变不影响该层递归 targetSum 的值</span>
        road<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对指向对象不变的引用类型（一般在 DFS 中不作为参数）做回溯操作</span>

        <span class="token keyword">return</span> roads<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在[113. 路径总和 II]中，需要回溯的非树节点元素 road 有一个特点，它是引用类型的。如果直接将 road 作为参数，因为是传引用，子递归对 road 的改变将直接影响上层递归中 road 的值（毕竟自始至终都是在对同一个对象做操作），如果要以用 road 做参数的方式实现回溯，需要在传递 road 时 new 一个新的对象，新对象即是子递归需要的新 road，将新对象作为参数传递给子递归函数，这样，每次递归调用时传入的 road 都不同，子递归对 road 的改变也就不会影响上层递归中 road 的值了。<code>pathSum(root.left, targetSum, new LinkedList&lt;Integer&gt;(road){<!-- -->{ add(root.val); }}); // 匿名内部类 + 初始化块：初始化集合</code></p> 
<p>另外一种方式就是将 road 设为成员变量（全局变量），在递归后对 road 做回溯操作，即我在代码中使用的方式。</p> 
<p>迭代法实现深度优先搜索求解[113. 路径总和 II]：</p> 
<pre><code class="prism language-java"><span class="token comment">// 迭代实现深度优先搜索，对应的递归版的回溯逻辑使用全局变量而非参数</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">pathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> roads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> road <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Object</span> object <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// 如果 object 是 TreeNode 类对象，接下来该遍历</span>
                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token punctuation">)</span> object<span class="token punctuation">;</span>

                <span class="token comment">// 计算从根节点遍历到该节点的整数目标和（用减表示）和路径，属于前序遍历处理逻辑，对应深度优先搜索条件判断的位置</span>
                targetSum <span class="token operator">-=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 2.状态转移</span>
                road<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2.状态转移</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>targetSum <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 从根节点到该节点的整数目标和是否符合要求 // 3.条件判断</span>
                    roads<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span>road<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>


                <span class="token comment">// 在后序遍历的根处标记回溯节点：在后序遍历中，后序遍历访问节点值后，接下来就是返回父节点了，不会再用到该节点信息了，所以该回溯了</span>
                <span class="token comment">// 也可以使用 Deque&lt;TreeNode&gt; 类型的 stack，stack.push(node) 后紧接着 stack.push(null) 来标记回溯节点</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 标记回溯节点并存储该节点值，用于回溯时减去该节点信息  根</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 空节点不加入栈  右 // 1.边界条件</span>
                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先入栈右节点，才会先出栈左节点 // 2.状态转移</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 空节点不加入栈  左 // 1.边界条件</span>
                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2.状态转移</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果 object 是 Integer 类对象，说明即将从某节点回退父节点，需要回溯，减去该节点信息</span>
                <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> object<span class="token punctuation">;</span>
                targetSum <span class="token operator">+=</span> val<span class="token punctuation">;</span>
                road<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> roads<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>递归版的回溯逻辑使用全局变量而非参数，转换为迭代版时，重点关注是在代码中的什么位置 stack.push(node.val) 来标记回溯节点的。出栈时遇到回溯节点即做回溯操作。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ccd745731191133c16dee03f136a02e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">gradle瘦身/删除没有用的文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c1188fcb9fe4262777d5a3bef1cb05de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">hdfs命令行操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>