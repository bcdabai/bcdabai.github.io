<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AcWing 876. 快速幂、扩展欧几里得 求逆元（乘法逆元，费马小定理） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AcWing 876. 快速幂、扩展欧几里得 求逆元（乘法逆元，费马小定理）" />
<meta property="og:description" content="ps：“a整除b” 或 “b能被a整除” 或 “a|b”：b叫做a的倍数，a叫做b的约数(或因数)。
即：b%a==0，b是被除数，a是除数。
前置知识一： 乘法逆元定义：
若 整数b，m互质，且对于 任意的整数a，如果满足
b|a（即b能整除a，a%b==0），则存在一个整数x，使得：
a/b≡a*x(mod m)（即(a/b) mod m = a*x）
则称 x 为 b的模m 乘法逆元，记为：b^(-1)(mod m)。
（联想一下：除b等于乘b的负一次方）
前置知识二： 费马小定理：a ^ (p-1) ≡ 1 (mod p) （p为质数）。
它由欧拉定理：a ^ φ（p） ≡ 1 (mod p) (a，p互质)推导而来（令p为质数即可，将p的欧拉函数φ（p）= p-1代入即可）。
思路及推导： b存在乘法逆元的充要条件是：b与模数m互质。
结论：当模数 m 为质数时，b^(m-2) 即为 b 的乘法逆元。
推导（结合费马小定理）：
a / b ≡ a * x(mod m)
→ a / b ≡ a * b^(-1)(mod m)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5e433d79368583a5d1aeb748389a0500/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-03T19:16:50+08:00" />
<meta property="article:modified_time" content="2022-02-03T19:16:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AcWing 876. 快速幂、扩展欧几里得 求逆元（乘法逆元，费马小定理）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/3d/59/4P1oLYSU_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/43/2d/G27TlGkT_o.png" alt="在这里插入图片描述"></p> 
<p>ps：“a整除b” 或 “b能被a整除” 或 “a|b”：b叫做a的倍数，a叫做b的约数(或因数)。</p> 
<p>即：b%a==0，b是被除数，a是除数。</p> 
<h3><a id="font_colorred_size5_8"></a><font color="red" size="5">前置知识一：</font></h3> 
<blockquote> 
 <p><strong>乘法逆元定义</strong>：</p> 
 <p>若 <strong>整数b，m互质</strong>，且对于 <strong>任意的整数a</strong>，如果满足<br> <strong>b|a（即b能整除a，a%b==0）</strong>，则存在一个<strong>整数x</strong>，使得：</p> 
 <p><strong>a/b≡a*x(mod m)</strong>（即(a/b) mod m = a*x）</p> 
 <p>则称 <strong>x</strong> 为 <strong>b的模m</strong> <strong>乘法逆元</strong>，记为：<strong>b^(-1)(mod m)</strong>。</p> 
</blockquote> 
<p>（联想一下：除b等于乘b的负一次方）</p> 
<h3><a id="font_colorred_size5_31"></a><font color="red" size="5">前置知识二：</font></h3> 
<blockquote> 
 <p><strong>费马小定理</strong>：<strong>a ^ (p-1) ≡ 1 (mod p) （p为质数）</strong>。</p> 
</blockquote> 
<p>它由<strong>欧拉定理：a ^ φ（p） ≡ 1 (mod p) (a，p互质)<strong>推导而来（令p为质数即可，将p的欧拉函数</strong>φ（p）= p-1</strong>代入即可）。</p> 
<h3><a id="font_colorred_size5_39"></a><font color="red" size="5">思路及推导：</font></h3> 
<p><strong>b存在乘法逆元</strong>的充要条件是：<strong>b与模数m互质</strong>。</p> 
<p><strong>结论</strong>：当模数 <strong>m 为质数</strong>时，<strong>b^(m-2)</strong> 即为 b 的乘法逆元。</p> 
<p>推导（结合<strong>费马小定理</strong>）：</p> 
<p>a / b ≡ a * x(mod m)<br> → a / b ≡ a * b^(-1)(mod m)<br> → a ≡ a * b * b^(-1)(mod m)<br> → 1 ≡ b * b^(-1)(mod m)<br> → 1(mod m) ≡ b^(-1) * b<br> 根据<strong>费马小定理</strong>：a ^ (p-1) ≡ 1 (mod p) （<strong>p为质数</strong>）推出b ^ (m-1) ≡ 1 (mod m)（<strong>m也为质数</strong>）</p> 
<p>所以 b^(-1) * b = b^(m-1) = b * b^(m-2)。</p> 
<p><strong>结论：</strong><br> ①<strong>当 b 与 m 互质的时候，且模数 m 为质数时， b 的乘法逆元为 b^(m-2)。</strong></p> 
<p>②<strong>当 b 为 m 的倍数时，b 的逆元不存在</strong>。（此时也不满足 b存在乘法逆元的充要条件：b与模数m互质）</p> 
<p>此时上方推导出来的式子：1(mod m) ≡ b^(-1) * b 不成立，因为 b 是 m 的倍数，因此 b * b^(-1) 也是 m 的倍数，所以 b * b^(-1) 模 m 只能为 0 而不能为 1 ，因此 b 的乘法逆元 b^(-1) 不存在。</p> 
<p><strong>因此对于 b 的乘法逆元 b^(m-2) 我们可以用快速幂来求。</strong><a href="https://blog.csdn.net/Jacob0824/article/details/122690483?spm=1001.2014.3001.5501">（快速幂）</a></p> 
<p><strong>注意</strong>：<strong>快速幂</strong>这种方法只适合<strong>模数m为质数</strong>的情况（因为要用到<strong>费马小定理</strong>）</p> 
<h3><a id="font_colorred_size5_68"></a><font color="red" size="5">一些小扩展：</font></h3> 
<p>快速幂求<strong>一个数</strong> ai 的逆元比较理想，时间复杂度为<strong>O(log b)</strong>（b 表示几次幂，<strong>求逆元的时候即为 mod</strong>）。</p> 
<p>但如果我们要将<strong>1~n每个数</strong>的逆元求出来则需要<strong>O(nlog b)</strong>，所以当 n 的范围 <strong>&lt;=1e7</strong> 时，这个方法是不太可取的，需要优化，优化方式为：<a href="https://www.cnblogs.com/Ishtar/p/10010789.html" rel="nofollow">线性求逆元</a>（O(n)）。</p> 
<p>（为什么不可取呢？因为本题 mod 的范围是 &lt;=2e9，log2e9 大概是 30，因此当 n&lt;=1e7 时 nlog b ≈ 3e8 &gt; 1e8，不合法）</p> 
<p>题目保证输入的数据 p 是质数。（用快速幂求逆元的前提）</p> 
<p><strong>代码：</strong></p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
int qmi(int a,int k,int p)
{
    int res=1;
    while(k)
    {
        if(k&amp;1) res=(LL)res*a%p;
        k&gt;&gt;=1;
        a=(LL)a*a%p;
    }
    return res;
}
int main()
{
    int n;
    scanf("%d",&amp;n);
    while (n -- )
    {
        int a,p;
        scanf("%d%d",&amp;a,&amp;p);
        int res=qmi(a,p-2,p);
        if(a%p) cout&lt;&lt;res&lt;&lt;endl;
        else cout&lt;&lt;"impossible"&lt;&lt;endl;//当 b 为 m 的倍数时，b 的逆元不存在
    }
    return 0;
}
</code></pre> 
<h3><a id="font_colorred_size5p_110"></a><font color="red" size="5"><strong>思考一下，如果p不是质数怎么办呢？</strong></font></h3> 
<p><strong>答：当p不是质数时，我们可以用扩展欧几里得求逆元</strong></p> 
<p><a href="https://blog.csdn.net/Jacob0824/article/details/122696654?spm=1001.2014.3001.5501">AcWing 877. 扩展欧几里得算法（递归，裴蜀定理，gcd）</a></p> 
<p><strong>推导：</strong></p> 
<p>a 有逆元的<strong>充要条件</strong>是 <strong>a与p互质</strong>，所以 <strong>gcd(a, p) = 1</strong></p> 
<p>假设 <strong>a 的逆元为 x</strong> ，那么有 <strong>a * x ≡ 1 (mod p)</strong></p> 
<p>等价于 <strong>ax + py = 1</strong>，</p> 
<p>因此后续的工作就相当于用扩展欧几里得算法求解上方的<strong>线性同余方程</strong>，并输出<strong>系数 x</strong> 即可</p> 
<p><strong>代码：</strong></p> 
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

#define int long long

void exgcd(int a, int b, int &amp;d, int &amp;x, int &amp;y)
{
    if (!b) 
    {
        d = a, x = 1, y = 0;
        return ;
    }
    exgcd(b, a % b, d, y, x), y -= a / b * x;
}

signed main()
{
    int n; cin &gt;&gt; n;
    while (n --)
    {
        int a,p,d,x,y;
        cin&gt;&gt;a&gt;&gt;p;
        exgcd(a, p, d, x, y);//p放在标准线性同余方程b的位置
        if (d == 1) cout &lt;&lt; (x + p) % p &lt;&lt; endl;//保证x是正数
        else puts("impossible");//如不互质直接输出impossible
    }
    return 0;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d51a25a438059580d444f5b392658ff9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">conda创建/复制/删除虚拟环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/988c191957c1efc6b2ad6fb77a2ec691/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JWT工具类（拿来直接用就完了，注释解释的很详细，看不懂建议撞墙祛湿）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>