<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【网络】socket套接字编程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【网络】socket套接字编程" />
<meta property="og:description" content="文章目录 一. 预备知识1. IP地址2. 端口号（port）3. socket网络通信4. 认识TCP/UDP协议5. 网络字节序 二. socket编程1. 套接字说明2. socket函数简介3. socket编程说明4. socket地址说明及转换函数4.1 三种常见的结构类型4.2 整型数据字节序转化函数4.3 IP地址转换函数 5. socket主要函数说明5.1 基本套接字函数5.2 UDP读写函数 三. UDP套接字编程1. 普通UDP服务器编程模型1.1 UDP服务器端流程1.2 UDP客户端流程1.3 UDP服务器、客户端的编程模型图 2. 普通UDP服务器编程实现2.1 UDP服务器服务端代码2.2 UDP客户端客户端代码2.3 测试普通UDP服务器 四. TCP套接字编程1. TCP套接字编程模型图2. TCP编程流程说明2.1 服务器编程流程2.2 客户端编程流程 3. TCP网络数据读写说明4. 迭代服务器编程4.1 服务端代码4.2 客户端代码4.3 测试迭代服务器 5. 并发服务器编程5.1 并发服务器编程注意事项5.2 并发服务器文件描述符变化图5.3 TCP并发服务器代码实现 一. 预备知识 1. IP地址 因特网是在网络级进行互联的，因此，因特网在网络层（IP层）完成地址的统一工作，即将不同物理网络的地址统一到具有全球惟一性的IP地址上，IP层所用到的地址叫作因特网地址，又叫IP地址。
因特网采用一种全局通用的地址格式，为每一台主机都分配一个IP地址，以此屏蔽物理网络地址的差异，即IP地址的意义就是标识公网内唯一一台主机。
在IP数据包中的信息带有源IP地址和目的IP地址，它们分别标识通信的源结点和目的结点，即信源和信宿。IP数据包经由路由转发的时候，源IP和目的IP不会改变，除非做了NAT转换才能改变。
2. 端口号（port） 网络通信的本质是进程间通信，有了IP就可以标识公网内唯一的一台主句，想要完成网络通信我们还需要一个东西来标识一台主机上的某个进程，这个标识就是端口号（port）。
端口号是传输层协议的内容，它包括如下几个特点：
端口号是一个2字节，16比特位的整数。一台主机中，一个端口号只能被一个进程所占用。 理解 “端口号” 和 “进程ID”
我们之前在学习操作系统的时候，知道pid可以用来标识进程；此处我们的端口号也是唯一标识一个进程。那么这两者之间又存在怎样的关系呢?
二者的相同点都是唯一标识主机内的一个进程，区别在于pid强调在系统的范围呢标识进程；而端口号强调在网络的范围内去标识进程。
既然pid已经做到唯一标识一个进程，为何还要引入端口号呢？我们可以从生活的角度去理解这种情况：即然每个人都有了唯一标识自己的身份照号，为何学校还要给我们分配学号呢？直接用身份照号不行吗？
学校给学生引入学号后，除了唯一标识学生这个作用外还有其他两个优点：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/00d40df9643a7763d5ae054943d2fde9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-28T15:08:03+08:00" />
<meta property="article:modified_time" content="2023-03-28T15:08:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【网络】socket套接字编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#__1" rel="nofollow">一. 预备知识</a></li><li><ul><li><a href="#1_IP_2" rel="nofollow">1. IP地址</a></li><li><a href="#2_port_9" rel="nofollow">2. 端口号（port）</a></li><li><a href="#3_socket_32" rel="nofollow">3. socket网络通信</a></li><li><a href="#4_TCPUDP_38" rel="nofollow">4. 认识TCP/UDP协议</a></li><li><a href="#5__57" rel="nofollow">5. 网络字节序</a></li></ul> 
  </li><li><a href="#_socket_70" rel="nofollow">二. socket编程</a></li><li><ul><li><a href="#1__71" rel="nofollow">1. 套接字说明</a></li><li><a href="#2_socket_82" rel="nofollow">2. socket函数简介</a></li><li><a href="#3_socket_87" rel="nofollow">3. socket编程说明</a></li><li><a href="#4_socket_105" rel="nofollow">4. socket地址说明及转换函数</a></li><li><ul><li><a href="#41__106" rel="nofollow">4.1 三种常见的结构类型</a></li><li><a href="#42__146" rel="nofollow">4.2 整型数据字节序转化函数</a></li><li><a href="#43_IP_156" rel="nofollow">4.3 IP地址转换函数</a></li></ul> 
   </li><li><a href="#5_socket_183" rel="nofollow">5. socket主要函数说明</a></li><li><ul><li><a href="#51__184" rel="nofollow">5.1 基本套接字函数</a></li><li><a href="#52_UDP_295" rel="nofollow">5.2 UDP读写函数</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_UDP_346" rel="nofollow">三. UDP套接字编程</a></li><li><ul><li><a href="#1_UDP_349" rel="nofollow">1. 普通UDP服务器编程模型</a></li><li><ul><li><a href="#11_UDP_350" rel="nofollow">1.1 UDP服务器端流程</a></li><li><a href="#12_UDP_363" rel="nofollow">1.2 UDP客户端流程</a></li><li><a href="#13_UDP_372" rel="nofollow">1.3 UDP服务器、客户端的编程模型图</a></li></ul> 
   </li><li><a href="#2_UDP_376" rel="nofollow">2. 普通UDP服务器编程实现</a></li><li><ul><li><a href="#21_UDP_377" rel="nofollow">2.1 UDP服务器服务端代码</a></li><li><a href="#22_UDP_477" rel="nofollow">2.2 UDP客户端客户端代码</a></li><li><a href="#23_UDP_540" rel="nofollow">2.3 测试普通UDP服务器</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_TCP_611" rel="nofollow">四. TCP套接字编程</a></li><li><ul><li><a href="#1_TCP_612" rel="nofollow">1. TCP套接字编程模型图</a></li><li><a href="#2_TCP_619" rel="nofollow">2. TCP编程流程说明</a></li><li><ul><li><a href="#21__620" rel="nofollow">2.1 服务器编程流程</a></li><li><a href="#22__634" rel="nofollow">2.2 客户端编程流程</a></li></ul> 
   </li><li><a href="#3_TCP_643" rel="nofollow">3. TCP网络数据读写说明</a></li><li><a href="#4__653" rel="nofollow">4. 迭代服务器编程</a></li><li><ul><li><a href="#41__656" rel="nofollow">4.1 服务端代码</a></li><li><a href="#42__778" rel="nofollow">4.2 客户端代码</a></li><li><a href="#43__888" rel="nofollow">4.3 测试迭代服务器</a></li></ul> 
   </li><li><a href="#5__896" rel="nofollow">5. 并发服务器编程</a></li><li><ul><li><a href="#51__897" rel="nofollow">5.1 并发服务器编程注意事项</a></li><li><a href="#52__912" rel="nofollow">5.2 并发服务器文件描述符变化图</a></li><li><a href="#53_TCP_929" rel="nofollow">5.3 TCP并发服务器代码实现</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="__1"></a>一. 预备知识</h2> 
<h3><a id="1_IP_2"></a>1. IP地址</h3> 
<p>因特网是在网络级进行互联的，因此，因特网在网络层（IP层）完成地址的统一工作，即将不同物理网络的地址统一到<strong>具有全球惟一性</strong>的IP地址上，IP层所用到的地址叫作因特网地址，又叫IP地址。</p> 
<p>因特网采用一种全局通用的地址格式，为每一台主机都分配一个IP地址，以此屏蔽物理网络地址的差异，即IP地址的意义就是标识公网内唯一一台主机。</p> 
<p>在IP数据包中的信息带有源IP地址和目的IP地址，它们分别标识通信的源结点和目的结点，即信源和信宿。IP数据包经由路由转发的时候，源IP和目的IP不会改变，除非做了NAT转换才能改变。</p> 
<h3><a id="2_port_9"></a>2. 端口号（port）</h3> 
<p>网络通信的本质是进程间通信，有了IP就可以标识公网内唯一的一台主句，想要完成网络通信我们还需要一个东西来标识一台主机上的某个进程，这个标识就是端口号（port）。</p> 
<p>端口号是传输层协议的内容，它包括如下几个特点：</p> 
<ul><li>端口号是一个2字节，16比特位的整数。</li><li>一台主机中，一个端口号只能被一个进程所占用。</li></ul> 
<blockquote> 
 <p>理解 “端口号” 和 “进程ID”</p> 
</blockquote> 
<p>我们之前在学习操作系统的时候，知道pid可以用来标识进程；此处我们的端口号也是唯一标识一个进程。那么这两者之间又存在怎样的关系呢?</p> 
<p>二者的相同点都是唯一标识主机内的一个进程，区别在于pid强调在系统的范围呢标识进程；而端口号强调在网络的范围内去标识进程。</p> 
<p>既然pid已经做到唯一标识一个进程，为何还要引入端口号呢？我们可以从生活的角度去理解这种情况：即然每个人都有了唯一标识自己的身份照号，为何学校还要给我们分配学号呢？直接用身份照号不行吗？</p> 
<p>学校给学生引入学号后，除了唯一标识学生这个作用外还有其他两个优点：</p> 
<ol><li>方便记忆和书写。常见的学号例如：20204912，因为比较短，这样就方便记忆，而且考试的时候书写也容易。试想一下，如果以身份证代替学号，能不能正确背下来是一回事，太长了万一考试的时候记错或写错了一个数字就麻烦了。</li><li>可以自己设定数字的意义，方便组织和管理。例如学号：20204912，一眼就能看出你是2020级的学生；对应的身份证号不同位置的数字也有各自的意义，但于学校管理意义不大。</li></ol> 
<blockquote> 
 <p>源端口号和目的端口号</p> 
</blockquote> 
<p>对应到网络层协议的源IP和目的IP，传输层协议(TCP和UDP)的数据段中也有两个端口号, 分别叫做源端口号和目的端口号.，它们就是在描述 “数据是那个进程发送的, 要发给另外那个进程”。</p> 
<h3><a id="3_socket_32"></a>3. socket网络通信</h3> 
<p>socket通信的本质就是跨网络的进程间通信，任何的网络客户端和网络服务如果要进行正常的数据通信，它们必须要有自己的端口号和匹配所属主机的IP地址。</p> 
<p><img src="https://images2.imgbox.com/64/26/qH1pMzoL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_TCPUDP_38"></a>4. 认识TCP/UDP协议</h3> 
<p>我们进行网络编程时通常是在应用层编码，应用层下面就是传输层。应用层往下传输数据时不必担心也没有必要知道数据的传输情况如何，这个具体地交给传输层来解决，所以我们有必要简单了解一下传输层的两个重要协议TCP和UDP。</p> 
<p><strong>TCP协议</strong><br> TCP全称Transmission Control Protocol，即传输控制协议，它有如下特点：</p> 
<ul><li>属于传输层协议。</li><li>有连接。</li><li>可靠传输。</li><li>面向字节流。</li></ul> 
<p><strong>UDP协议</strong><br> UDP全称User Datagram Protocol，即用户数据报协议，它有如下特点：</p> 
<ul><li>属于传输层协议。</li><li>无连接。</li><li>不可靠传输。</li><li>面向数据报。</li></ul> 
<p>在我们的认知里一定要是安全的、稳定的才好，那传输层为什么还要引入一个不可靠传输方式的UDP协议呢？TCP协议虽然是可靠传输，但是“可靠”是要付出一些效率上的成本的，可能会导致传输速度比较慢，而且实现起来相对复杂；以这个角度去看UDP协议，虽然可能在传输过程中出现丢包的情况，但效率上是要更快的。通常两个协议可以搭配起来使用，网速快时用TCP协议，网速慢时用UDP协议，但如果是要传输重要数据的时候就应该只用TCP了。</p> 
<h3><a id="5__57"></a>5. 网络字节序</h3> 
<p>我们知道，内存中的数据权值排列相对于内存地址的大小有大端和小端之分：</p> 
<ul><li>大端存储：高权值数字存到内存的低地址位置上，低权值存到高地址上。</li><li>小端存储：高权值数字存到内存的高地址位置上，低权值存到高地址上。</li></ul> 
<p>数据在发送时，发送主机通常将发送缓冲区中的数据按内存地址<strong>从低到高</strong>的顺序以字节为单位发出；接收主机把接到的字节依次保存在接收缓冲区中，也是按内存地址<strong>从低到高</strong>的顺序以字节为单位保存的。即先发出低地址的数据，后发出高地址的数据；接收到的数据也是按低地址到高地址的顺序存。</p> 
<p>如果发送端和接收端主机的存储字节序不同，则会造成发送的数据和识别出来的数据不一致的问题，如下图所示：<br> <img src="https://images2.imgbox.com/36/1b/5DnJE7g2_o.png" alt="在这里插入图片描述"><br> 网络在传输数据时同样有大端小端之分，TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高权值，不管这台主机是大端机还是小端机,，最后都要按照TCP/IP规定的网络字节序（大端）来发送/接收数据：</p> 
<ul><li>如果发送主机是小端机， 就需要先进行数据转换；否则忽略，直接发送即可。</li><li>如果接受主机是小端机，则拿到数据后需要进行转换；否则忽略，直接读取即可。</li></ul> 
<h2><a id="_socket_70"></a>二. socket编程</h2> 
<h3><a id="1__71"></a>1. 套接字说明</h3> 
<p>socket通常也称为“套接字”，程序可以通过“套接字”向网络发出请求或者响应网络请求。socket位于传输层之上、应用层之下。socket编程是通过一系列系统调用完成应用层协议。如FTP、Telent、HTTP等应用层协议都是通过socket编程来实现的。</p> 
<p>从套接字所处的位置来讲，套接字上连应用进程，下接网络协议栈，是应用程序与网络协议栈进行交互的接口。<br> <img src="https://images2.imgbox.com/7e/fc/cQrLhzxX_o.png" alt="在这里插入图片描述"><br> 套接字是对网络中应用进程之间进行双向通信的抽象，他提供了应用层进程利用网络协议栈交换数据的机制。</p> 
<blockquote> 
 <p>套接字的本质</p> 
</blockquote> 
<p>Linux和UNIX的I/O内涵是系统中的一切都是文件。当程序在执行任何形式的I/O时，程序都是在读或者在写一个文件描述符，从而实现操作文件，但是，这个文件可能是一个socket网络连接、目录、FIFO、管道、终端、外设、磁盘上的文件。一样的道理，socket也是使用标准Linux文件描述符和其他网络进程进行通信的。</p> 
<h3><a id="2_socket_82"></a>2. socket函数简介</h3> 
<p>socket函数基本为系统调用函数，它是操作系统向网络通信进程提供的函数接口。<br> <img src="https://images2.imgbox.com/41/48/2lt8Yvwm_o.png" alt="在这里插入图片描述"><br> 从实现的角度来讲，套接字系列函数是一个复杂的软件模块，它包含了一定的数据结构和许多选项，由操作系统内核来管理。</p> 
<h3><a id="3_socket_87"></a>3. socket编程说明</h3> 
<p>Linux系统是通过套接字（socket）函数来进行网络编程的。socket技术提供了在TCP/IP模型各个层上的编程支持，该技术是先在内核中处理收到的各层协议数据，然后应用程序再以文件操作的方式接收内核返回的数据。</p> 
<p>其中应用程序对文件的处理是通过一个文件描述符来进行的，socket文件描述符可以看成普通的文件描述符来进行操作，这就是Linux设备无关性的好处，可以通过对文件描述符的读写操作来实现网络间数据流的传输。</p> 
<blockquote> 
 <p>重新理解IP地址与端口</p> 
</blockquote> 
<p>端口是指网络中面向连接服务和无连接服务的通信协议端口，它是一种抽象的软件结构，包括一些数据结构和I/O（基本输入/输出）缓冲区。</p> 
<p>IP地址用来标识网络中不同主机的地址，而端口号则是标识一台主机上不同网络通信进程的地址，IP地址与端口号合起来标识的就是网络中唯一的进程。</p> 
<p>如果把IP地址比作一栋旅馆，端口就是旅馆里的一个个房间。一个IP地址的端口可以有65536（即2^16）个之多。端口是通过端口号来标识的，端口号是个16byte位的整数，范围是0 ~ 65535（ 2^16-1）。其中端口1~1024是系统保留端口。</p> 
<p>一次socket通信连接会涉及源IP地址、源端口、目的IP地址和目的端口四个要素。源IP地址、源端口标识的是客户端进程，其中源端口是操作系统随机分配的；目的IP地址、目的端口标识的是服务端进程，其中目的端口是由服务器程序指定的。</p> 
<blockquote> 
 <p>IP地址、端口号、socket套接字三者在数据结构上的联系</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/00/73/yMCIVCB4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_socket_105"></a>4. socket地址说明及转换函数</h3> 
<h4><a id="41__106"></a>4.1 三种常见的结构类型</h4> 
<p>在套接字编程中，有三种常见的结构类型，它们用来存放<strong>socket地址信息</strong>。这三种结构类型分别为<code>struct in_addr</code>、<code>struct sockaddr</code>、<code>struct sockaddr_in</code>，对这三种结构类型说明如下，使用它们需要包含头文件#include &lt;netinet/in.h&gt;。</p> 
<ul><li><code>struct in_addr</code>专门用来存储IP地址，对于IPv4来说，IP地址为32位无符号整数，其定义可以在/usr/include/linux/in.h下找到，具体IP地址的值存储在成员变量s_addr中：<br> <img src="https://images2.imgbox.com/37/5e/kEfPeg5Y_o.png" alt="在这里插入图片描述"></li><li><code>struct sockaddr</code>结构用来保存保存套接字的完整地址信息，其定义如下：</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> sa_family<span class="token punctuation">;</span> <span class="token comment">/* 地址簇，AF_xxx */</span>
	<span class="token keyword">char</span> sa_data<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 14B的协议地址 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>struct sockaddr结构中sa_family成员说明的是地址簇类型，一般为“AF_INET”；而sa_data则包含主机的IP地址和端口等信息。</p> 
<p>struct sockaddr结构类型使用在socket相关的系统调用函数中，但这个结构中的sa_data字段可以包含较多的信息，不便于实际编程和对其进行赋值，因此，又建立了struct sockaddr_in结构，该结构与struct sockaddr结构的大小相等，能更好地处理struct sockaddr结构中的数据。对struct sockaddr_in结构变量进行赋值完成后进行socket相关的系统调用函数时，再将struct sockaddr_in结构变量强制转化为struct sockaddr结构类型即可。</p> 
<ul><li><code>sttruct sockaddr_in</code>结构定义如下：<br> <img src="https://images2.imgbox.com/74/2b/IoKpnzZR_o.png" alt="在这里插入图片描述"></li></ul> 
<p>在实际应用的编程中，对套接字地址结构的使用方法和流程如下：</p> 
<ol><li>定义一个struct sockaddr_in类型的结构变量，并将它初始化为0，代码如下：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> myad<span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myad<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="2"><li>给这个结构变量赋值，代码如下：</li></ol> 
<pre><code class="prism language-cpp">myad<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
myad<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myad<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="3"><li>在进行函数调用时，都要将这个结构强制转换为struct sockaddr类型，代码如下：</li></ol> 
<pre><code class="prism language-cpp"><span class="token function">bind</span><span class="token punctuation">(</span>serverFd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>myad<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>myad<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="42__146"></a>4.2 整型数据字节序转化函数</h4> 
<p>为保证“大端”和“小端”字节序机器之间能相互进行正常的网络通信，需在发送多字节的整数时，将主机字节序转换成网络字节序，或将网络字节序转换为主机字节序。字节序转换主要是针对整型数据进行的，字符型由于是单字节，所以不存在这个问题。整型整型字节序转换函数原型及其说明如下。</p> 
<table><thead><tr><th>所需头文件</th><th>#include &lt;arpa/inet.h&gt;</th></tr></thead><tbody><tr><td>函数说明</td><td>完成网络字节序与主机字节序的转换，注意已经完成转换了的整数就不要在重复转换了</td></tr><tr><td>函数原型</td><td>uint16_t htons(uint16_t hostshort) //短整型主机转换为网络字节序<br>uint32_t htonl(uint32_t hostlong) //长整型主机转换为网络字节序<br>uint16_t ntohs(uint16_t netshort) //短整型网络转换为主机字节序<br>uint32_t ntohl(uint32_t netlong) //长整型网络转换为主机字节序</td></tr><tr><td>函数传入值</td><td>hostshort、hostlong：为转换前的主机字节序数值<br>netshort、netlong为转换前的网络字节序数值</td></tr><tr><td>函数返回值</td><td>① htons、htonl返回转换后的网络字节序数值<br>② ntohs、ntohl返回转换后的主机字节序数值</td></tr><tr><td>附加说明</td><td>h表示主机，n表示网络，s表示短整数，l表示长整数，to表示转换</td></tr></tbody></table> 
<h4><a id="43_IP_156"></a>4.3 IP地址转换函数</h4> 
<p>IP地址转换函数是指完成点分十进制数IP地址与二进制数IP地址之间的<strong>相互转换</strong>。IP地址转换主要由inet_aton、inet_addr和inet_ntoa这三个函数完成，但它们都只能处理IPv4地址，而不能处理IPv6地址。这三个函数的函数原型及其具体说明如下。</p> 
<p><strong>1、inet_addr</strong></p> 
<table><thead><tr><th>函数原型</th><th>in_addr_t inet_addr(const char* cp)</th></tr></thead><tbody><tr><td>函数说明</td><td>将点分十进制数IP地址转换为二进制数IP地址并完成网络字节序的转换</td></tr><tr><td>所需头文件</td><td>#include &lt;sys/socket.h&gt;<br>#include &lt;netinet/in.h&gt;<br>#include &lt;arpa/inet.h&gt;</td></tr><tr><td>函数传入值</td><td>cp：点分十进制数IP地址，如“10.10.10.1”</td></tr><tr><td>函数返回值</td><td>in_addr_t 一般为32位的unsigned int<br>成功：返回二进制数形式的IP地址<br>失败：返回一个常值INADDR_NONE（32位均为1）</td></tr></tbody></table> 
<p><strong>2、inet_aton</strong></p> 
<table><thead><tr><th>函数原型</th><th>int inet_aton(const char* cp, struct in_addr* inp)</th></tr></thead><tbody><tr><td>函数说明</td><td>将点分十进制数IP地址转换为二进制数地址并完成网络字节序的转换</td></tr><tr><td>所需头文件</td><td>#include &lt;sys/socket.h&gt;<br>#include &lt;netinet/in.h&gt;<br>#include &lt;arpa/inet.h&gt;</td></tr><tr><td>函数传入值</td><td>cp：点分十进制数IP地址，如“10.10.10.1”<br>inp：转换后的二进制数地址信息保存在inp中</td></tr><tr><td>函数返回值</td><td>成功：非0<br>失败：0</td></tr></tbody></table> 
<p><strong>3、inet_ntoa</strong></p> 
<table><thead><tr><th>函数原型</th><th>char* inet_ntoa(struct in_addr in)</th></tr></thead><tbody><tr><td>函数说明</td><td>将二进制数地址转换为点分十进制数IP地址</td></tr><tr><td>所需头文件</td><td>#include &lt;sys/socket.h&gt;<br>#include &lt;netinet/in.h&gt;<br>#include &lt;arpa/inet.h&gt;</td></tr><tr><td>函数传入值</td><td>in：二进制数IP地址，注意类型是struct in_addr，该数据一般从套接字地址结构中拿到</td></tr><tr><td>函数返回值</td><td>成功：返回字符串指针，此指针指向了转换后的点分十进制数IP地址<br>失败：NULL</td></tr></tbody></table> 
<h3><a id="5_socket_183"></a>5. socket主要函数说明</h3> 
<h4><a id="51__184"></a>5.1 基本套接字函数</h4> 
<p>PS：基本套接字函数的头文件都为：#include &lt;sys/socket.h&gt;、#include&lt;sys/types.h&gt;这两个。</p> 
<p><mark>（1）socket函数</mark><br> 创建套接字要用到<code>socket</code>这个函数，该函数的原型如下：<br> <img src="https://images2.imgbox.com/0c/d5/qtRjuK31_o.png" alt="在这里插入图片描述"><br> <strong>头文件</strong>：#include &lt;sys/socket.h&gt;、#include&lt;sys/types.h&gt;</p> 
<p><strong>函数说明</strong>：创建一个socket文件描述符。<br> <img src="https://images2.imgbox.com/5d/ac/uIuIBCmn_o.png" alt="在这里插入图片描述"></p> 
<p><strong>函数返回值</strong>：</p> 
<ul><li>成功：socket文件描述符。</li><li>失败：-1，失败原因存于error中。</li></ul> 
<p><strong>参数说明</strong>：</p> 
<ul><li> <p><code>domain</code>：即协议簇。</p> 
  <ul><li>AF_INET：IPv4协议。</li><li>AF_INET6：IPv6协议。</li><li>AF_LOCAL：UNIX域协议。</li><li>AF_ROUTE：路由套接口。</li><li>AF_KEY：密钥套接口。</li></ul> </li><li> <p><code>type</code>：即服务类型。</p> 
  <ul><li>SOCK_STREAM：双向可靠数据流，对应TCP。</li><li>SOCK_DGRAM：双向不可靠数据报，对应UDP。</li><li>SOCK_RAM：提供传输层以下的协议，可以访问内部网络的接口，例如， 接收和发送ICMP报文。</li></ul> </li><li> <p><code>protocol</code>：即协议类型。</p> 
  <ul><li>type为SOCK_RAM时，需要设置此值说明协议类型。</li><li>其他类型统一设置为0即可，内部会根据前两个参数的值自动推导出协议结果。</li></ul> </li></ul> 
<p><strong>补充</strong>：下表列出了当进行socket调用时，其中的协议簇（domain）与服务类型（type）可能产生的组合。</p> 
<table><thead><tr><th>-</th><th>AF_INET</th><th>AF_INET6</th><th>AF_LOCAL</th><th>AF_ROUTE</th><th>AF_KEY</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>TCP</td><td>TCP</td><td>Yes</td><td></td><td></td></tr><tr><td>SOCK_DGRAM</td><td>UDP</td><td>UDP</td><td>Yes</td><td></td><td></td></tr><tr><td>SOCK_RAW</td><td>IPv4</td><td>IPv6</td><td></td><td>Yes</td><td>Yes</td></tr></tbody></table> 
<p><mark>（2）bind函数</mark><br> <img src="https://images2.imgbox.com/5a/79/XM8z7MN0_o.png" alt="在这里插入图片描述"></p> 
<p><strong>头文件</strong>：#include &lt;sys/socket.h&gt;、#include&lt;sys/types.h&gt;</p> 
<p><strong>函数说明</strong>：将一个套接字地址与socket文件描述符联系起来。利用bind绑定地址时，可以指定主机的IP地址和端口号。</p> 
<p>此函数一般为客户端调用，我们在填充IP地址时可以使用通配地址INADDR_ANY（为宏定义，其值等于0），此时的含义是让服务器端计算机上的所有网卡的IP地址都可以作为服务器的IP地址，也即监听外部客户端程序发送到服务器端所有网卡的网络请求。</p> 
<p><strong>参数说明</strong>：</p> 
<ul><li>socket：socket文件描述符。</li><li>address：指向sockaddr结构，该结构包含IP地址和端口等信息</li><li>address_len：sockaddr结构的大小，可设置为sizeof(struct sockaddr)</li></ul> 
<p><strong>函数返回值</strong>：</p> 
<ul><li>成功：0</li><li>失败：-1，失败原因存于error中</li></ul> 
<p><mark>（3）listen函数</mark><br> <img src="https://images2.imgbox.com/a1/01/uh5DrVA5_o.png" alt="在这里插入图片描述"></p> 
<p><strong>头文件</strong>：#include&lt;sys/socket.h&gt;、#incldue&lt;sys/types.h&gt;</p> 
<p><strong>函数说明</strong>：设置监听套接字</p> 
<p><strong>参数说明</strong>：</p> 
<ul><li>sockfd：需要设置为监听套接字的socket文件描述符。</li><li>backlog：连接队列长度，通常设置为5或10。</li></ul> 
<p><strong>函数返回值</strong>：成功返回0，失败返回-1，失败原因存于error中。</p> 
<blockquote> 
 <p>附加说明</p> 
</blockquote> 
<p>对于监听套接字文件描述符sockfd，内核要维护两个队列，分别为未完成连接队列和已完成连接队列，这两个队列之和不能超过backlog。</p> 
<p><mark>（4）accept函数</mark><br> <img src="https://images2.imgbox.com/c8/e3/xslIDjwW_o.png" alt="在这里插入图片描述"></p> 
<p><strong>头文件</strong>：#include&lt;sys/socket.h&gt;、#include&lt;types.h&gt;</p> 
<p><strong>函数说明</strong>：接受socket连接，返回一个新的socket文件描述符，原socket文件描述符仍为listen函数所用，而新的socket文件描述符用来处理连接的读写操作。</p> 
<p><strong>参数说明</strong>：</p> 
<ul><li>sockfd：监听套接字。</li><li>addr：写入远程主机的套接字地址，是一个输出型参数。</li><li>addrlen：写入addr的大小，也是一个输出型参数。</li></ul> 
<p><strong>函数返回值</strong>：</p> 
<ul><li>成功：返回实际读取的字节数。</li><li>失败：-1，错误码存放于error中。</li></ul> 
<blockquote> 
 <p>附加说明</p> 
</blockquote> 
<ul><li>accept函数由TCP服务器调用，为阻塞函数，从已完成连接的队列中返回一个连接；如果该队列为空，则进程进入阻塞等待。</li><li>函数返回的套接字为已新的连接套接字，监听套接字仍为listen函数所用。</li></ul> 
<p><mark>（5）connect函数</mark><br> <img src="https://images2.imgbox.com/84/ae/j9CvK9R4_o.png" alt="在这里插入图片描述"></p> 
<p><strong>头文件</strong>：#include&lt;sys/socket.h&gt;、#include&lt;sys/types.h&gt;</p> 
<p><strong>函数说明</strong>：主动建立socket连接</p> 
<p><strong>函数传入值</strong>：</p> 
<ul><li>sockfd：socket文件描述符</li><li>addr：对端主机的套接字地址</li><li>addrlen：sockaddr结构的大小，可设置为sizeof(struct sockaddr)</li></ul> 
<p><strong>函数返回值</strong>：成功返回0，失败返回-1，失败原因存于error中。</p> 
<hr> 
<h4><a id="52_UDP_295"></a>5.2 UDP读写函数</h4> 
<p>UDP套接字是无连续协议，必须使用sendto函数发送数据，使用recvfrom函数接收数据，且发送时需要指明目的地地址。sendto函数与send的功能基本相同，recvfrom与recv的功能基本相同，只是sendto和recvfrom函数参数中都带有对端的地址信息，这两个函数是专门为UDP协议提供的。</p> 
<p><strong>（1）sendto函数</strong><br> <img src="https://images2.imgbox.com/55/27/dpTRwNxR_o.png" alt="在这里插入图片描述"></p> 
<p><strong>头文件</strong>：#include &lt;sys/socket.h&gt;</p> 
<p><strong>函数说明</strong>：通过socket文件描述符发送数据到对端，用于UDP协议</p> 
<p><strong>参数说明</strong>：</p> 
<ul><li><code>socket</code>：socket文件描述符</li><li><code>message</code>：发送数据的首地址</li><li><code>length</code>：发送数据的长度</li><li><code>flags</code>：该参数可以设置为以下标志的组合 
  <ul><li>0：以阻塞方式发送数据。</li><li>MSG_OOB：发送带外数</li><li>MSG_DONTROUTE：告诉IP协议目的主机在本地网络，没有必要查找路由表</li><li>MSG_DONTWAIT：设置为非阻塞操作</li><li>MSG_NOSIGNAL：表示发送动作不愿被SIGPIPE信号中断</li></ul> </li><li><code>dest_addr</code>：存放目的主机的IP地址和端口信息，即socket地址</li><li><code>dest_len</code>：to的长度，可设置为sizeof(struct sockaddr)</li></ul> 
<p><strong>函数返回值</strong>：</p> 
<ul><li>成功：实际发送的字节数</li><li>失败：-1，失败原因存于error中</li></ul> 
<p><strong>（2）recvfrom函数</strong><br> <img src="https://images2.imgbox.com/c4/e7/Vwiq08Yp_o.png" alt="在这里插入图片描述"></p> 
<p><strong>头文件</strong>：#include &lt;sys/socket.h&gt;</p> 
<p><strong>函数说明</strong>：通过socket文件描述符从对方接收数据，用于UDP协议</p> 
<p><strong>参数说明</strong>：</p> 
<ul><li><code>socket</code>：文件描述符。</li><li><code>buffer</code>：接收数据的首地址（输出型参数）。</li><li><code>length</code>：需要接受数据的长度。</li><li><code>flags</code>：该参数可以设置为以下标志的组合。 
  <ul><li>0：以阻塞方式接收数据</li><li>MSG_OOB：接收带外数据</li><li>MSG_PEEK：查看数据标志，返回的数据并不在系统中删除，如果再次调用该函数，会返回相同的数据内容。</li><li>MSG_DONTWAIT：设置为非阻塞操作</li><li>MSG_WAITALL：强迫接收到length大小的数据后才返回，除非有错误或有信号产生。</li></ul> </li><li><code>address</code>：存放发送方的IP地址和端口（输出型参数）。</li><li><code>address_len</code>：socket地址的长度，可设置为sizeof(struct sockaddr)。</li></ul> 
<p><strong>函数返回值</strong></p> 
<ul><li>成功：实际接收到的字节数。</li><li>失败：-1，失败原因存于error中。</li></ul> 
<h2><a id="_UDP_346"></a>三. UDP套接字编程</h2> 
<p>UDP协议是非连接非可靠的数据传输，常用在对数据质量要求不高的场合。UDP服务器通常是非连接的，因而，UDP服务器进程不需要像TCP服务器那样在监听套接字上接收新建的连接；UDP只需要在绑定的端口上等待客户机发送来的UDP数据报文，并对其进行处理和响应。一个TCP服务进程只有在完成了对某客户机的服务后，才能为其他的客户机提供服务。而UDP服务器只是接收数据报文，处理并返回结果。UDP支持广播和多播，如果要使用广播和多播，必须使用UDP套接字。UDP套接字没有连接的建立和终止过程，UDP只需要两个分组来交换一个请求和答应。UDP不适合海量数据的传输。</p> 
<h3><a id="1_UDP_349"></a>1. 普通UDP服务器编程模型</h3> 
<h4><a id="11_UDP_350"></a>1.1 UDP服务器端流程</h4> 
<p>① 建立UDP套接字</p> 
<p>② 绑定套接字到特定的地址</p> 
<p>③ 等待并接受客户端信息</p> 
<p>④ 处理客户端请求</p> 
<p>⑤ 发送信息给客户端</p> 
<p>⑥ 关闭套接字</p> 
<h4><a id="12_UDP_363"></a>1.2 UDP客户端流程</h4> 
<p>① 建立UDP套接字</p> 
<p>② 发送信息给服务器</p> 
<p>③ 接收来自服务器的信息</p> 
<p>④ 关闭套接字</p> 
<h4><a id="13_UDP_372"></a>1.3 UDP服务器、客户端的编程模型图</h4> 
<p><img src="https://images2.imgbox.com/e0/d5/lSEhBCq9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_UDP_376"></a>2. 普通UDP服务器编程实现</h3> 
<h4><a id="21_UDP_377"></a>2.1 UDP服务器服务端代码</h4> 
<p><strong>基本框架</strong><br> 服务端只有两个成员变量，端口号和自己的socket文件描述符，服务端不需要指定自己的IP地址，原因下文会做说明。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">UdpServer</span> 
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 构造函数，创建一个服务端对象时需要显示传入一个端口号给服务端</span>
    <span class="token function">UdpServer</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span>
      <span class="token operator">:</span><span class="token function">_port</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span>
      <span class="token punctuation">,</span><span class="token function">_sockfd</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token comment">// 析构函数，当服务端对象销毁时关闭打开的socket文件描述符</span>
    <span class="token operator">~</span><span class="token function">UdpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>_sockfd <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
        <span class="token function">close</span><span class="token punctuation">(</span>_sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _port<span class="token punctuation">;</span>  <span class="token comment">// 服务端进程的端口号</span>
    <span class="token keyword">int</span> _sockfd<span class="token punctuation">;</span><span class="token comment">// 服务端进程的socket打开文件描述符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>初始化服务端</strong></p> 
<ul><li>创建socket文件描述符</li><li>将服务端自己的套接字地址和刚刚创建的socket文件描述符绑定起来</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">InitServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 1、创建socket文件描述符</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_sockfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cerr<span class="token operator">&lt;&lt;</span><span class="token string">"socket error"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">"socket sucess"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

  <span class="token comment">// 2、将服务端自己的套接字地址和刚刚创建的socket文件描述符绑定起来</span>
  <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> local<span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  local<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
  local<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>_port<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  local<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>_sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cerr <span class="token operator">&lt;&lt;</span><span class="token string">"bind error"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">"bind sucess"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>注意事项</strong></p> 
</blockquote> 
<p>绑定操作我们是通过bind函数来完成的，该函数是把套接字地址和socket文件描述符给绑定联系起来。而套接字地址就包括端口号和IP地址，在这里我们可以把IP地址设为INADDR_ANY，表示该服务器可以收发本主机中所有网卡的数据。</p> 
<p>最后还要注意通过htons、htonl等整型数据字节序转化函数把P地址和端口号这些整型数据的字节序转化成网络字节序，然后再放到套接字地址变量中。</p> 
<p><strong>启动服务端</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">128</span></span></span>
  <span class="token comment">// buffer用于接收客户端传来的数据</span>
  <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// peer用于接收客户端的套接字地址信息</span>
  <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> peer<span class="token punctuation">;</span>
  <span class="token comment">// len用来接收客户端套接字地址结构的大小</span>
  socklen_t len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 1、通过recvfrom函数不断接收客户端传来的数据和信息</span>
    ssize_t size <span class="token operator">=</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span>_sockfd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>peer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2、解析客户端的数据和信息</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      buffer<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
      <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>peer<span class="token punctuation">.</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
      string ip <span class="token operator">=</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>peer<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
      cout<span class="token operator">&lt;&lt;</span><span class="token char">'['</span><span class="token operator">&lt;&lt;</span>ip<span class="token operator">&lt;&lt;</span><span class="token char">' '</span><span class="token operator">&lt;&lt;</span>port<span class="token operator">&lt;&lt;</span><span class="token string">"]#"</span><span class="token operator">&lt;&lt;</span>buffer<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
      cerr<span class="token operator">&lt;&lt;</span><span class="token string">"recvfrom error"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>注意事项</strong></p> 
</blockquote> 
<p>recvfrom函数不仅可以拿到客户端传来的数据，还可以拿到客户端的IP地址和端口号，服务端有了客户端的IP地址和端口号之后我们可以通过sendto函数再发送数据回去给客户端进程，实现客户端、服务端的双向网络通信。</p> 
<h4><a id="22_UDP_477"></a>2.2 UDP客户端客户端代码</h4> 
<p><strong>基本框架</strong><br> 客户端一般是要把任务传给服务器端，让服务端去处理任务的，所以客户端进程需要知道服务端的IP地址和端口号。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">UdpClient</span> 
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 构造函数，需要显示传入目的服务端的IP地址和端口号，作为数据发送的目的地</span>
    <span class="token function">UdpClient</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> serverIp<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> serverPort<span class="token punctuation">)</span>
      <span class="token operator">:</span><span class="token function">_sockfd</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">,</span><span class="token function">_serverIp</span><span class="token punctuation">(</span>serverIp<span class="token punctuation">)</span>
      <span class="token punctuation">,</span><span class="token function">_serverPort</span><span class="token punctuation">(</span>serverPort<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token comment">// 析构函数，关闭打开的socket文件描述符</span>
    <span class="token operator">~</span><span class="token function">UdpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>_sockfd <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
        <span class="token function">close</span><span class="token punctuation">(</span>_sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _sockfd<span class="token punctuation">;</span>     <span class="token comment">// 客户端进程的socket文件描述符</span>
    string _serverIp<span class="token punctuation">;</span><span class="token comment">// 服务端进程的IP地址</span>
    <span class="token keyword">int</span> _serverPort<span class="token punctuation">;</span> <span class="token comment">// 服务端进程的端口号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>初始化客户端</strong><br> 这里只需要创建客户端网络进程的socket文件描述符即可，而不需要将socket文件描述符和自己的套接字地址进行绑定。因为没人会关心你客户端的IP地址和端口号，而服务端作为服务的提供者，所有客户端进程都需要向服务端进程发送任务，即服务端的IP地址和端口号是要被众所周知的，所以服务端需要进行绑定操作而客户端不需要。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">InitUdpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_sockfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cerr<span class="token operator">&lt;&lt;</span><span class="token string">"socket error"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>启动客户端</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  string msg<span class="token punctuation">;</span>
  <span class="token comment">// 在struct sockaddr_in结构中填入服务端的套接字地址</span>
  <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> peer<span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>peer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  peer<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
  peer<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>_serverPort<span class="token punctuation">)</span><span class="token punctuation">;</span>
  peer<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>_serverIp<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 通过sendto函数发送数据到服务端</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Please Enter# "</span><span class="token punctuation">;</span>
    <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sendto</span><span class="token punctuation">(</span>_sockfd<span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>peer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="23_UDP_540"></a>2.3 测试普通UDP服务器</h4> 
<p>把上面UDP的服务端和客户端的实现代码分别写到udp_server.h 和 udp_client.h两个头文件中。</p> 
<p><strong>udp_server.cpp</strong></p> 
<ul><li>创建一个服务端对象</li><li>初始化服务端对象</li><li>启动服务端对象</li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"udp_server.h"</span>                                                                                                        </span>
    
<span class="token comment">// 运行可执行程序时，这里通过命令行参数传入服务端的端口号    </span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span>    
<span class="token punctuation">{<!-- --></span>    
  <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>    
  <span class="token punctuation">{<!-- --></span>    
    cerr<span class="token operator">&lt;&lt;</span><span class="token string">"Usage："</span><span class="token operator">&lt;&lt;</span><span class="token string">"./ServerName"</span><span class="token operator">&lt;&lt;</span><span class="token string">" port"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    
  <span class="token punctuation">}</span>    
    
  <span class="token comment">// 1、把第二个命令行参数转为整型，拿到端口号，用这个端口号去构造一个服务端对象    </span>
  UdpServer<span class="token operator">*</span> svr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">UdpServer</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token comment">// 2、初始化服务端对象    </span>
  svr<span class="token operator">-&gt;</span><span class="token function">InitServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token comment">// 3、启动服务端对象    </span>
  svr<span class="token operator">-&gt;</span><span class="token function">Loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>    
</code></pre> 
<p><strong>udp_client.cpp</strong></p> 
<ul><li>创建一个客户端对象</li><li>初始化客户端对象</li><li>启动客户端对象</li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"udp_client.h"</span>    </span>
    
<span class="token comment">// 运行可执行程序时，通过命令行参数传入目的服务端的IP地址和端口号    </span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span>    
<span class="token punctuation">{<!-- --></span>    
  <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span>    
  <span class="token punctuation">{<!-- --></span>    
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Usage："</span><span class="token operator">&lt;&lt;</span><span class="token string">"./ServerName"</span><span class="token operator">&lt;&lt;</span><span class="token string">" ServerIp ServerPort"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    
  <span class="token punctuation">}</span>    
    
  <span class="token comment">// 1、解析命令行参数传入的IP地址和端口号    </span>
  string serverIp <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    
  <span class="token keyword">int</span> serverPort <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token comment">// 2、构造一个客户端对象    </span>
  UdpClient<span class="token operator">*</span> clt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">UdpClient</span><span class="token punctuation">(</span>serverIp<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token comment">// 3、初始化客户端    </span>
  clt<span class="token operator">-&gt;</span><span class="token function">InitUdpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token comment">// 4、启动客户端                                                                                                             </span>
  clt<span class="token operator">-&gt;</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span> 
</code></pre> 
<blockquote> 
 <p><strong>结果测试</strong></p> 
</blockquote> 
<p>编译生成可执行程序</p> 
<p><img src="https://images2.imgbox.com/c4/43/VixcqDb6_o.png" alt="在这里插入图片描述"></p> 
<p>分别启动可执行程序，进行本地环回测试</p> 
<p><img src="https://images2.imgbox.com/8c/68/ZTsy8gwL_o.png" alt="在这里插入图片描述"></p> 
<p>发现客户端发送的数据能被服务器接收到</p> 
<p><img src="https://images2.imgbox.com/10/38/DtUt70Hu_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_TCP_611"></a>四. TCP套接字编程</h2> 
<h3><a id="1_TCP_612"></a>1. TCP套接字编程模型图</h3> 
<p>TCP套接字编程经常使用在客户端/服务器编程模型（简称C/S模型）中，C/S模型根据复杂度，可分为简单的客户端/服务端模型和复杂的客户端/服务端模型。简单的客户端/服务端模型是一对一关系，即一个服务器端某一时间段内只对应处理一个客户端的请求，迭代服务器模型属于此模型。复杂的客户端/服务端模型是一对多关系，即一个服务器端某一时间段内对应处理多个客户端的请求，并发服务器模型属于此模型。迭代服务器模型和并发服务器模型是socket编程中最常使用的两种编程模型。</p> 
<p>迭代服务器模型和并发服务器模型的服务端处理流程如下图所示：<br> <img src="https://images2.imgbox.com/3e/77/Vq5lqqnm_o.png" alt="在这里插入图片描述"><br> 下图是更加具体的TCP套接字编程模型图，此模型不仅适合迭代服务器，也适合并发服务器，两者实现的流程类似，只不过并发服务器接收客户请求（accept）后会用fork调用子进程，由子进程处理客户端的请求。<br> <img src="https://images2.imgbox.com/ee/5b/5ZPsa5U7_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_TCP_619"></a>2. TCP编程流程说明</h3> 
<h4><a id="21__620"></a>2.1 服务器编程流程</h4> 
<p>①：创建套接字</p> 
<p>②：绑定套接字</p> 
<p>③：设置套接字为监听模式，进入被动接收连接状态</p> 
<p>④：接受请求，建立连接</p> 
<p>⑤：读写数据</p> 
<p>⑥：终止连接</p> 
<h4><a id="22__634"></a>2.2 客户端编程流程</h4> 
<p>①：创建套接字</p> 
<p>②：与远程服务器建立连接</p> 
<p>③：读写数据</p> 
<p>④：终止连接</p> 
<h3><a id="3_TCP_643"></a>3. TCP网络数据读写说明</h3> 
<p>在网络程序中，向套接字文件描述符写数据时有以下两种可能：</p> 
<ul><li>write的返回值大于等于0，表示写了部分或者全部的数据，最后数值为实际写入的字节数（0表明什么都没写）。</li><li>write的返回值等于-1，此时写出现错误，需要根据错误类型来处理。如果错误号为EINTR，则为中断引起的，可以忽略进行继续写操作；如果是其他错误号，表示网络连接出现了问题（可能对方关闭了连接），则需报错退出。</li></ul> 
<p>与向套接字文件描述符写数据不同，读数据有三种可能：</p> 
<ul><li>read的返回值大于0，表示读了部分或者全部的数据。</li><li>read的返回值等于0，表示写端关闭了。</li><li>read的返回值等于-1，表明读出现了错误，需要根据错误类型来处理，如果错误号为EINTR，则为中断引起的，可以忽略进行继续读操作；如果是其他错误号，表示网络连接出现了问题，则需要报错退出。</li></ul> 
<h3><a id="4__653"></a>4. 迭代服务器编程</h3> 
<p>下面代码实现的是典型的迭代服务器，服务端的功能是接收客户发送来的字符串数据并原封不动地发回去。</p> 
<h4><a id="41__656"></a>4.1 服务端代码</h4> 
<p><strong>tcp_server.h</strong>：用来存放服务端类的实现。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BACK_LOG</span> <span class="token expression"><span class="token number">10</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFF_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>

<span class="token keyword">class</span> <span class="token class-name">TcpServer</span>  
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">TcpServer</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span>
      <span class="token operator">:</span><span class="token function">_port</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span>
      <span class="token punctuation">,</span><span class="token function">_listenSock</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">TcpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>_listenSock <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
        <span class="token function">close</span><span class="token punctuation">(</span>_listenSock<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">InitServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 1、创建套接字</span>
      _listenSock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 2、绑定套接字</span>
      <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> local<span class="token punctuation">;</span>
      <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      local<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
      local<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
      local<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> INADDR_ANY<span class="token punctuation">;</span>
      <span class="token function">bind</span><span class="token punctuation">(</span>_listenSock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 3、设置监听套接字</span>
      <span class="token function">listen</span><span class="token punctuation">(</span>_listenSock<span class="token punctuation">,</span> BACK_LOG<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 服务客户端</span>
    <span class="token keyword">void</span> <span class="token function">Service</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> linkSock<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> ip<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">char</span> buff<span class="token punctuation">[</span>BUFF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
        ssize_t size <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>linkSock<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
          buff<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          cout<span class="token operator">&lt;&lt;</span><span class="token char">'['</span><span class="token operator">&lt;&lt;</span>ip<span class="token operator">&lt;&lt;</span><span class="token char">':'</span><span class="token operator">&lt;&lt;</span>port<span class="token operator">&lt;&lt;</span><span class="token string">"]# "</span><span class="token operator">&lt;&lt;</span>buff<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
          <span class="token function">write</span><span class="token punctuation">(</span>linkSock<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
          cout<span class="token operator">&lt;&lt;</span><span class="token string">"client close!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> 
        <span class="token punctuation">{<!-- --></span>
          cerr<span class="token operator">&lt;&lt;</span><span class="token string">"read error"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 服务完成后要记得关闭该连接套接字</span>
      <span class="token function">close</span><span class="token punctuation">(</span>linkSock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 启动服务器</span>
    <span class="token keyword">void</span> <span class="token function">LoopServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> peer<span class="token punctuation">;</span>
      <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>peer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      socklen_t len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 不断地监听获取客户端的连接请求</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> linkSock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>_listenSock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>peer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 若该套接字监听失败，继续监听下一个套接字即可</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>linkSock <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
          cout<span class="token operator">&lt;&lt;</span><span class="token string">"accept error, continue next link"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>peer<span class="token punctuation">.</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        string ip <span class="token operator">=</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>peer<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"get a new link, sockfd is "</span><span class="token operator">&lt;&lt;</span>linkSock<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token comment">// 连接成功后，为客户端提供服务</span>
        <span class="token function">Service</span><span class="token punctuation">(</span>linkSock<span class="token punctuation">,</span> ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _port<span class="token punctuation">;</span>
    <span class="token keyword">int</span> _listenSock<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>tcp_server.cpp</strong>：创建一个服务端对象，并初始化和启动它。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tcp_server.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Usage：./ServerProc Serverport"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 解析参数</span>
  <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 根据参数去创建一个服务端对象</span>
  TcpServer<span class="token operator">*</span> svr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TcpServer</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化、启动务端</span>
  svr<span class="token operator">-&gt;</span><span class="token function">InitServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  svr<span class="token operator">-&gt;</span><span class="token function">LoopServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 最后delete服务端对象</span>
  <span class="token keyword">delete</span> svr<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="42__778"></a>4.2 客户端代码</h4> 
<p><strong>tcp_client.h</strong>：用来存放客户端类的实现</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">TcpClient</span> 
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">TcpClient</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> serverIp<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> serverPort<span class="token punctuation">)</span>
      <span class="token operator">:</span><span class="token function">_serverIp</span><span class="token punctuation">(</span>serverIp<span class="token punctuation">)</span>
      <span class="token punctuation">,</span><span class="token function">_serverPort</span><span class="token punctuation">(</span>serverPort<span class="token punctuation">)</span>
      <span class="token punctuation">,</span><span class="token function">_linkSock</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">TcpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>_linkSock <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
        <span class="token function">close</span><span class="token punctuation">(</span>_linkSock<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 初始化客户端</span>
    <span class="token keyword">void</span> <span class="token function">InitClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 初始化阶段只需创建套接字即可</span>
      _linkSock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 连接成功后，发送信息给服务端，然后在接收服务端返回的信息</span>
    <span class="token keyword">void</span> <span class="token function">Request</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      string msg<span class="token punctuation">;</span>
      <span class="token keyword">char</span> echoBuff<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"please enter# "</span><span class="token punctuation">;</span>
        <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">write</span><span class="token punctuation">(</span>_linkSock<span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssize_t size <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>_linkSock<span class="token punctuation">,</span> echoBuff<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>echoBuff<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
          echoBuff<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          cout<span class="token operator">&lt;&lt;</span><span class="token string">"server echo# "</span><span class="token operator">&lt;&lt;</span>echoBuff<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
          cout<span class="token operator">&lt;&lt;</span><span class="token string">"server close!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> 
        <span class="token punctuation">{<!-- --></span>
          cerr<span class="token operator">&lt;&lt;</span><span class="token string">"read error"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// 启动客户端，用已经创建出来的套接字去连接服务端并请求其处理任务</span>
    <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> peer<span class="token punctuation">;</span>
      <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>peer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      peer<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
      peer<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>_serverPort<span class="token punctuation">)</span><span class="token punctuation">;</span>
      peer<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>_serverIp<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>_linkSock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>peer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
        cerr<span class="token operator">&lt;&lt;</span><span class="token string">"connect error"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">else</span> 
      <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"connect success"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token function">Request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

  <span class="token keyword">private</span><span class="token operator">:</span>
    string _serverIp<span class="token punctuation">;</span>
    <span class="token keyword">int</span> _serverPort<span class="token punctuation">;</span>
    <span class="token keyword">int</span> _linkSock<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>tcp_client.cpp</strong>：创建一个客户端对象并初始化和启动它。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tcp_client.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Usage：./clientProc serverIp serverPort"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 解析参数</span>
  string ip <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 根据参数去创建一个客户端对象</span>
  TcpClient<span class="token operator">*</span> clt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TcpClient</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化、启动客户端</span>
  clt<span class="token operator">-&gt;</span><span class="token function">InitClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  clt<span class="token operator">-&gt;</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 最后delete客户端对象</span>
  <span class="token keyword">delete</span> clt<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="43__888"></a>4.3 测试迭代服务器</h4> 
<p>两个会话分别启动服务端（左边）和客户端（右边），客户端发送数据给服务端，结果服务端能接收到数据并回响给客户端，说明该迭代服务器实现成功。</p> 
<p><img src="https://images2.imgbox.com/55/71/j5TRomsI_o.png" alt="在这里插入图片描述"></p> 
<p>迭代服务器存在明显的的缺点，即一个服务器端某一时间段内只对应处理一个客户端的请求，下图可以看到如果再另起一个客户端进程去连接服务器，因为上一个客户端的服务还没有完成所以新起的客户端进程并不能享受服务。</p> 
<p><img src="https://images2.imgbox.com/02/6c/Dou9hqmi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__896"></a>5. 并发服务器编程</h3> 
<h4><a id="51__897"></a>5.1 并发服务器编程注意事项</h4> 
<p>进程是一个程序的一次运行过程，它是一个动态实体，是独立的任务，它拥有独立的地址空间、执行堆栈、文件描述符等。每个进程拥有独立的地址空间，在进程不存在父子关系的情况下，互不影响。</p> 
<p>进程的终止存在两种可能：父进程先于子进程终止（由init进程领养），子进程先于主进程终止。对于后者，系统内核为子进程保留一定的状态信息（进程ID、终止状态、CPU时间等），并向其父进程发送SIGCHLD信号。当父进程调用wait或waitpid函数时，将获取这些信息，获取后内核将对僵尸进程进行清理。如果父进程设置了忽略SIGCHLD信号或对SIGCHLD信号提供了处理函数，即使不调用wait或waitpid函数，内核也会清理僵尸进程。</p> 
<p>父进程调用wait函数处理子进程退出信息时，会存在下面所述的问题。在有多个子进程的情况下，wait函数只等待最先到达的子进程的终止信息。比如下图中父进程有三个子进程，由于SIGCHLD信号不排队，在SIGCHLD信号同时到来后，父进程的wait函数只执行一次，这样将留下两个“僵尸进程”，使用waitpid函数并设置WNOHANG选项可以解决这个问题。</p> 
<p><img src="https://images2.imgbox.com/16/8a/CFxHB5UC_o.png" alt="在这里插入图片描述"><br> 综上所述，在多进程并发的情况下，防止子进程变成僵尸进程的常见方法有如下三种。</p> 
<p>①：父进程调用signal(SIGCHLD，SIG_IGN)对子进程退出信号进行忽略，或者把SIG_IGN替换为其他处理函数，设置对SIGCHLD信号的处理。</p> 
<p>②：父进程调用waitpid(-1, NULL, WNOHANG)对所有的子进程SIGCHLD信号进行处理。</p> 
<p>③：服务端进程先创建一个子进程（儿子进程），然后这个子进程再创建一个子进程（孙子进程），让孙子进程去处理任务并终止儿子进程，这样孙子进程处理完任务后因为没有父进程了，所以这个孙子进程会被init进程领养并释放。</p> 
<h4><a id="52__912"></a>5.2 并发服务器文件描述符变化图</h4> 
<p>下图画出了并发服务器文件描述符的变化流程图。其中listenfd为服务端的socket监听文件描述符，connfd为accept函数返回的socket连接文件描述符。</p> 
<p>服务器调用accept函数时，客户端与服务端文件描述符如图所示：<br> <img src="https://images2.imgbox.com/77/d9/Kns4tp3h_o.png" alt="在这里插入图片描述"></p> 
<p>服务器调用accept函数后，客户端与服务端文件描述符如图所示：<br> <img src="https://images2.imgbox.com/55/c5/r4MOVOQg_o.png" alt="在这里插入图片描述"></p> 
<p>服务端调用fork函数后，客户端与服务端文件描述符如下图所示：<br> <img src="https://images2.imgbox.com/79/e1/TAGKPLuG_o.png" alt="在这里插入图片描述"></p> 
<p>服务端父进程关闭连接套接字，子进程关闭监听套接字，客户端与服务端文件描述符状况如下图所示：<br> <img src="https://images2.imgbox.com/c1/b1/OtZC1wEJ_o.png" alt="在这里插入图片描述"></p> 
<p>PS：并发服务器fork后父进程一定要关闭子进程的连接套接字；而子进程要关闭父进程的监听套接字，以免误操作。</p> 
<h4><a id="53_TCP_929"></a>5.3 TCP并发服务器代码实现</h4> 
<p><strong>并发服务器处理流程</strong></p> 
<p>① 客户端首先发起链接。</p> 
<p>② 服务端进程accept打开一个新的连接套接字与客户端进行连接，accept在一个while(1)循环内等待客户端的连接。</p> 
<p>③ 服务端fork一个子进程，同时父进程close关闭子进程连接套接字，循环等待下一进程。</p> 
<p>④ 服务端子进程colse父进程监听套接字，并用连接套接字保持与客户端的连接，客户端发送数据到服务端进程，然后阻塞等待服务端返回。</p> 
<p>⑤ 子进程接收数据，进行业务处理，然后发送数据给客户端。</p> 
<p>⑥ 子进程关闭连接，然后退出。</p> 
<p><strong>并发服务器服务端代码</strong><br> 只需在迭代服务器的基础上修改服务端的启动部分代码即可，当服务端连接成功拿到新的连接套接字时，服务端进程fork创建子进程，让子进程去执行客户端发来的任务，注意服务端进程需要忽略对SIGCHLD信号的处理。<br> <img src="https://images2.imgbox.com/7f/58/BlCXxEZR_o.png" alt="在这里插入图片描述"></p> 
<p>先启动一个客户端1和一个服务端，发现确实能够正常通信：<br> <img src="https://images2.imgbox.com/86/20/YtXQiTIW_o.png" alt="在这里插入图片描述"></p> 
<p>再启动一个客户端2，也能够正常和服务端通信：<br> <img src="https://images2.imgbox.com/59/c4/kQuqLFO1_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>补充1：另一多进程版本的服务端编写</p> 
</blockquote> 
<p>服务端进程先创建一个子进程（儿子进程），然后这个子进程再创建一个子进程（孙子进程），让孙子进程去处理任务并终止儿子进程，这样孙子进程处理完任务后因为没有父进程了，所以这个孙子进程会被init进程领养并释放。</p> 
<p>只需修改服务端连接成功之后的那部分的代码即可：<br> <img src="https://images2.imgbox.com/04/08/SXOFqJVl_o.png" alt="在这里插入图片描述"></p> 
<p>结果演示，一个服务端进程依然可以同时为多个客户端进程提供服务：<br> <img src="https://images2.imgbox.com/92/24/02Eri7p7_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>补充2：多线程版本服务端编写</p> 
</blockquote> 
<p>创建进程的开销是要比创建线程大得多的，我们的主线程在连接成功后可以考虑去创建线程来处理任务，在编码时要注意以下几点：</p> 
<ul><li>子线程和主线程共享一个打开文件描述符表。</li><li>子线程执行函数如果要封装到服务端类中的话，需要给它的执行函数加上static关键字，以解除this指针对参数列表的影响。</li><li>类的静态成员函数只能访问类的静态成员变量和成员函数，非静态的不能够访问到。</li></ul> 
<p>涉及到的客户端类代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">TcpServer</span>                         
<span class="token punctuation">{<!-- --></span> 
  <span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//...其他成员函数省略</span>

    <span class="token comment">// 多线程版本</span>
    <span class="token comment">// 启动服务器</span>
    <span class="token keyword">void</span> <span class="token function">LoopServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> peer<span class="token punctuation">;</span>
      <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>peer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      socklen_t len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token comment">// 不断地监听获取客户端的连接请求</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> linkSock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>_listenSock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>peer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                     
        <span class="token comment">// 若该套接字监听失败，继续监听下一个套接字即可</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>linkSock <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
          cout<span class="token operator">&lt;&lt;</span><span class="token string">"accept error, continue next link"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>peer<span class="token punctuation">.</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        string ip <span class="token operator">=</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>peer<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"get a new link, sockfd is "</span><span class="token operator">&lt;&lt;</span>linkSock<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token comment">// 建立连接后，创建子线程去处理任务</span>
        Param<span class="token operator">*</span> pm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Param</span><span class="token punctuation">(</span>linkSock<span class="token punctuation">,</span> ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pthread_t tid<span class="token punctuation">;</span>
        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> Routine<span class="token punctuation">,</span> pm<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
	<span class="token comment">// 子线程处理任务函数（注意要设为静态的，要不然会参数里会有this指针）   </span>
    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Routine</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span>    
    <span class="token punctuation">{<!-- --></span>  
      <span class="token function">pthread_detach</span><span class="token punctuation">(</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
      Param<span class="token operator">*</span> pm <span class="token operator">=</span> <span class="token punctuation">(</span>Param<span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>    
      <span class="token function">Service</span><span class="token punctuation">(</span>pm<span class="token operator">-&gt;</span>_sockfd<span class="token punctuation">,</span> pm<span class="token operator">-&gt;</span>_ip<span class="token punctuation">,</span> pm<span class="token operator">-&gt;</span>_port<span class="token punctuation">)</span><span class="token punctuation">;</span>  
      <span class="token keyword">delete</span> pm<span class="token punctuation">;</span>    
      <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>      
                                                                                                                        
    <span class="token comment">// 服务客户端（也要设为静态的，因为Routine的逻辑中有使用到该函数）                                      </span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Service</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> linkSock<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> ip<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>                 
      <span class="token keyword">char</span> buff<span class="token punctuation">[</span>BUFF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>               
                                                                            
      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                                               
      <span class="token punctuation">{<!-- --></span>                                            
        ssize_t size <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>linkSock<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                                       
        <span class="token punctuation">{<!-- --></span>                      
          buff<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>               
          cout<span class="token operator">&lt;&lt;</span><span class="token char">'['</span><span class="token operator">&lt;&lt;</span>ip<span class="token operator">&lt;&lt;</span><span class="token char">':'</span><span class="token operator">&lt;&lt;</span>port<span class="token operator">&lt;&lt;</span><span class="token string">"]# "</span><span class="token operator">&lt;&lt;</span>buff<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
          <span class="token function">write</span><span class="token punctuation">(</span>linkSock<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>         
        <span class="token punctuation">}</span>                                                    
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                         
        <span class="token punctuation">{<!-- --></span>                            
          cout<span class="token operator">&lt;&lt;</span><span class="token string">"client close!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>                                    
          <span class="token keyword">break</span><span class="token punctuation">;</span>                                       
        <span class="token punctuation">}</span>                                                                                                                      
        <span class="token keyword">else</span>           
        <span class="token punctuation">{<!-- --></span>                                                                   
          cerr<span class="token operator">&lt;&lt;</span><span class="token string">"read error"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>                      
          <span class="token keyword">break</span><span class="token punctuation">;</span>                       
        <span class="token punctuation">}</span>      
      <span class="token punctuation">}</span>                                                                                                                        
      <span class="token comment">// 服务完成后要记得关闭该连接套接字</span>
      <span class="token function">close</span><span class="token punctuation">(</span>linkSock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
  <span class="token keyword">private</span><span class="token operator">:</span>  
    <span class="token keyword">int</span> _port<span class="token punctuation">;</span>  
    <span class="token keyword">int</span> _listenSock<span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
</code></pre> 
<p>结果演示：不论主线程还是其创造出来的子线程，它们都共属同一个进程，每一个子线程要使用一个自己的连接套接字去处理任务，又因为它们共用同一张打开文件描述符表，所以各自分配到的套接字不同。</p> 
<p><img src="https://images2.imgbox.com/9e/d3/kPiIn19R_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07f55960d341fc7883c0eac468d99fa6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【无标题】org.apache.hadoop.ipc.RemoteException</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50e383803b81aa02291e8b546f7e44d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RedHat7安装Mysql5.7</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>