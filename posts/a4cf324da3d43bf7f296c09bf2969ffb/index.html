<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>什么是动态链接库DLL？以及DLL所需要的三个函数详解（LoadLibrary,GetProcAddress,FreeLibrary） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="什么是动态链接库DLL？以及DLL所需要的三个函数详解（LoadLibrary,GetProcAddress,FreeLibrary）" />
<meta property="og:description" content="一、DLL的概念 DLL(Dynamic Link Library)，动态链接库文件，又称“应用程序拓展”，是软件文件类型，扩展名是“.dll”。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。例如：kernel32.dll中含有LoadLibrary()和GetProcAddress()，ws2_32.dll中含有winsock()函数。一个应用程序可使用多个DLL文件，一个DLL文件也可能被不同的应用程序使用，这样的DLL文件被称为“共享DLL文件”。
DLL文件中存放的是各类程序的函数(子过程)实现过程，当程序需要调用函数时需要先载入DLL，然后取得函数的地址，最后进行调用。使用DLL文件的好处是程序不需要在运行之初加载所有代码，只有在程序需要某个函数的时候才从DLL中取出。另外，使用DLL文件还可以减小程序的体积。
通过使用 DLL，程序可以实现模块化，由相对独立的组件组成。 例如，一个计帐程序可以按模块来销售。 可以在运行时将各个模块加载到主程序中（如果安装了相应模块）。因为模块是彼此独立的，所以程序的加载速度更快，而且模块只在相应的功能被请求时才加载。此外，可以更为容易地将更新应用于各个模块，而不会影响该程序的其他部分。 例如，您可能具有一个工资计算程序，而税率每年都会更改。 当这些更改被隔离到 DLL 中以后，您无需重新生成或安装整个程序就可以应用更新。
二、DLL故障排除工具 Dependency Walker
Dependency Walker 工具可以递归扫描以寻找程序所使用的所有依赖 DLL。 当在 Dependency Walker 中打开程序时，Dependency Walker 会执行下列检查：
Dependency Walker 检查是否丢失 DLL。
Dependency Walker 检查是否存在无效的程序文件或 DLL。
Dependency Walker 检查导入函数和导出函数是否匹配。
Dependency Walker 检查是否存在循环依赖性错误。
Dependency Walker 检查是否存在由于针对另一不同操作系统而无效的模块。
通过使用 Dependency Walker，您可以记录程序使用的所有 DLL。 这可能有助于避免和更正将来可能发生的 DLL 问题。 当安装 Microsoft Visual Studio 6.0 时，Dependency Walker 将位于以下目录中：http://www.dependencywalker.com/（下载地址）
DLL Universal Problem Solver
DLL Universal Problem Solver (DUPS) 工具用于审核、比较、记录和显示 DLL 信息。 下表说明了组成 DUPS 工具的实用工具：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a4cf324da3d43bf7f296c09bf2969ffb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-27T18:12:56+08:00" />
<meta property="article:modified_time" content="2020-01-27T18:12:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么是动态链接库DLL？以及DLL所需要的三个函数详解（LoadLibrary,GetProcAddress,FreeLibrary）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、DLL的概念</h3> 
<p>       DLL(Dynamic Link Library)，动态链接库文件，又称“应用程序拓展”，是软件文件类型，扩展名是“.dll”。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。例如：kernel32.dll中含有LoadLibrary()和GetProcAddress()，ws2_32.dll中含有winsock()函数。一个应用程序可使用多个DLL文件，一个DLL文件也可能被不同的应用程序使用，这样的DLL文件被称为“共享DLL文件”。</p> 
<p>       DLL文件中存放的是各类程序的函数(子过程)实现过程，当程序需要调用函数时需要先载入DLL，然后取得函数的地址，最后进行调用。使用DLL文件的好处是程序不需要在运行之初加载所有代码，只有在程序需要某个函数的时候才从DLL中取出。另外，使用DLL文件还可以减小程序的体积。</p> 
<p>      通过使用 DLL，程序可以实现模块化，由相对独立的组件组成。 例如，一个计帐程序可以按模块来销售。 可以在运行时将各个模块加载到主程序中（如果安装了相应模块）。因为模块是彼此独立的，所以程序的加载速度更快，而且模块只在相应的功能被请求时才加载。此外，可以更为容易地将更新应用于各个模块，而不会影响该程序的其他部分。 例如，您可能具有一个工资计算程序，而税率每年都会更改。 当这些更改被隔离到 DLL 中以后，您无需重新生成或安装整个程序就可以应用更新。</p> 
<p>  </p> 
<h4>二、DLL故障排除工具</h4> 
<p>    Dependency Walker</p> 
<p>    Dependency Walker 工具可以递归扫描以寻找程序所使用的所有依赖 DLL。 当在 Dependency Walker 中打开程序时，Dependency Walker 会执行下列检查：</p> 
<p>    Dependency Walker 检查是否丢失 DLL。<br>     Dependency Walker 检查是否存在无效的程序文件或 DLL。<br>     Dependency Walker 检查导入函数和导出函数是否匹配。<br>     Dependency Walker 检查是否存在循环依赖性错误。<br>     Dependency Walker 检查是否存在由于针对另一不同操作系统而无效的模块。</p> 
<p>通过使用 Dependency Walker，您可以记录程序使用的所有 DLL。 这可能有助于避免和更正将来可能发生的 DLL 问题。 当安装 Microsoft Visual Studio 6.0 时，Dependency Walker 将位于以下目录中：<a href="http://www.dependencywalker.com/" rel="nofollow">http://www.dependencywalker.com/</a>（下载地址）</p> 
<p><img alt="" class="has" height="583" src="https://images2.imgbox.com/50/4a/knjyLMkk_o.png" width="811"></p> 
<p>    DLL Universal Problem Solver</p> 
<p>    DLL Universal Problem Solver (DUPS) 工具用于审核、比较、记录和显示 DLL 信息。 下表说明了组成 DUPS 工具的实用工具：</p> 
<p>    Dlister.exe<br>     该实用工具枚举计算机中的所有 DLL，并且将此信息记录到一个文本文件或数据库文件中。<br>     Dcomp.exe<br>     该实用工具比较在两个文本文件中列出的 DLL，并产生包含差异的第三个文本文件。<br>     Dtxt2DB.exe<br>     该实用工具将通过使用 Dlister.exe 实用工具和 Dcomp.exe 实用工具创建的文本文件加载到 dllHell 数据库中。<br>     DlgDtxt2DB.exe<br>     该实用工具提供 Dtxt2DB.exe 实用工具的图形用户界面 (GUI) 版本。</p> 
<p>有关 DUPS 工具的更多信息，请单击下面的文章编号，以查看 Microsoft 知识库中相应的文章：</p> 
<p><a href="https://support.microsoft.com/zh-cn/help/247957/sample-using-dups-exe-to-resolve-dll-compatibility-problems" rel="nofollow">使用 DUPS.exe 解决 DLL 兼容性问题</a></p> 
<p>    DLL 帮助数据库</p> 
<p>    DLL 帮助数据库帮助您查找由 Microsoft 软件产品安装的特定版本的 DLL。 有关 DLL 帮助数据库的更多信息，请访问下面的 Microsoft 网站：</p> 
<p><a href="http://support.microsoft.com/dllhelp/" rel="nofollow">http://support.microsoft.com/dllhelp/</a><br>  </p> 
<h3>三、动态载入 DLL</h3> 
<p>     动态载入方式是指在编译之前并不知道将会调用哪些 DLL 函数， 完全是在运行过程中根据需要决定应调用哪些函数。<br><br> 方法是：用 LoadLibrary 函数加载动态链接库到内存，用 GetProcAddress函数动态获得 DLL 函数的入口地址。当一个 DLL 文件用 LoadLibrary 显式加载后，在任何时刻均可以通过调用 FreeLibrary 函数显式地从内存中把它给卸载。<br><br> 动态调用使用的 Windows API 函数主要有 3 个， 分别是 LoadLibrary、 GetProcAddress 和FreeLibrary。<br><br> 我们分别详细介绍这三个函数的功能，因为无论学习编程还是逆向这是三个函数都是非常常用滴。<br><br><br> （1）LoadLibrary 函数<br><br> 注：Delphi 中还提供了 SafeLoadLibrary 函数，它封装了 Loadlibrary 函数，可以装载由 Filename 参数指定的 WindowsDLL或 Linux 共享对象。它简化了DLL的装载并且使装载更加安全。<br><br> [格式]：</p> 
<ol><li>function LoadLibrary(LibFileName : PChar): Thandle;</li></ol> 
<p>复制代码</p> 
<p><br> [功能]：加载由参数 LibFileName 指定的 DLL 文件。<br><br> [说明]：参数 LibFileName 指定了要装载的 DLL 文件名，如果 LibFileName 没有包含一个路径，系统将按照：当前目录、Windows 目录、Windows 系统目录、包含当前任务可执行文件的目录、列在 PATH 环境变量中的目录等顺序查找文件。<br><br> 如果函数操作成功，将返回装载 DLL 库模块的实例句柄，否则，将返回一个错误代码，错误代码的定义如下表所示。<br><br>  </p> 
<table cellspacing="0"><tbody><tr><td> <p>错误代码</p> </td><td> <p>  含义</p> </td></tr><tr><td>  0</td><td>  系统内存不够，可执行文件被破坏或调用非法</td></tr><tr><td>  2</td><td>  文件没有被发现</td></tr><tr><td>  3</td><td>  路径没有被发现</td></tr><tr><td>  5</td><td>  企图动态链接一个任务错误或者有一个共享或网络保护错误</td></tr><tr><td>  6</td><td>  库需要为每个任务建立分离的数据段  </td></tr><tr><td>  8</td><td>  没有足够的内存启动应用程序  </td></tr><tr><td>  10</td><td>  Windows  版本不正确  </td></tr><tr><td>  11</td><td>  可执行文件非法或不是Windows  应用程序，或在.  EXE映像中有错误  </td></tr><tr><td>  12</td><td>  应用程序为一个不同的操作系统设计（如  OS/2）  </td></tr><tr><td>  13</td><td>  应用程序为  MS  DOS   4. 0  设计  </td></tr><tr><td>  14</td><td>  可执行文件的类型不知道  </td></tr><tr><td>  15</td><td>  试图装载一个实模式应用程序（为早期Windows  版本设计）</td></tr><tr><td>  16</td><td>  试图装载包含可写的多个数据段的可执行文件的第二个实例  </td></tr><tr><td>  19</td><td>  试图装载一个压缩的可执行文件（文件必须被解压后才能被装载）  </td></tr><tr><td>  20</td><td>  DLL  文件非法</td></tr><tr><td>  21</td><td>  应用程序需要  32  位扩展</td></tr></tbody></table> 
<p><br> 假如在应用程序中用 LoadLibrary 函数装入某一个 DLL 前， 其他应用程序已把该 DLL 装入内存中了，则系统将不再装入该 DLL 的另一个实例，而是使该 DLL 的“引用计数”加 1 。<br><br><br> （2）GetProcAddress 函数<br><br> [格式]：</p> 
<ol><li>function GetProcAddress(Module:Thandle; ProcName:PChar): TfarProc;</li></ol> 
<p>复制代码</p> 
<p><br> [功能]：返回参数 Module 指定的模块中，由参数 ProcName 指定的过程或函数的入口地址。<br><br> [说明]：参数 Module 包含被调用函数的 DLL 句柄，这个值由 LoadLibrary 返回， ProcName<br> 是指向含有函数名的以 nil 结尾的字符串指针，或者可以是函数的次序值，但大多数情况下，用函数名是一种更稳妥的选择。如果该函数执行成功，则返回 DLL 中由参数 ProcName 指定的过程或函数的入口地址，否则返回 nil 。<br><br><br> （3）FreeLibrary 函数<br><br> [格式]：</p> 
<ol><li>procedure  FreeLibrary(Module: Thandle);</li></ol> 
<p>复制代码</p> 
<p><br> [说明]：将由参数 Module 指定的 DLL 文件从内存中卸载 1 次。<br><br> [说明]：Module 为 DLL 库的句柄。这个值由 LoadLibrary 返回。由于 DLL 在内存中只装载一次，因此调用 FreeLibrary 首先使 DLL 的引用计数减 1，如果计数减为 0 则卸载该 DLL。<br><br> [注意]：每调用一次 LoadLibrary 函数就应调用一次 FreeLibrary 函数，以保证不会有多余的库模块在应用程序结束后仍留在内存中，否则导致内存泄漏。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e6ed9f0f1bc1962e41d9281701534aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">38-动态内存分配</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f488ec0394abe3b54e1b0ae54712c5ca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">问题 C: 神奇的口袋 （背包问题）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>