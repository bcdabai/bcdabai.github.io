<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中的友元和内联函数 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中的友元和内联函数" />
<meta property="og:description" content="友元函数 创建一个类，让他里面仅仅只有一个私有变量：
void Test(const Test&amp; a) { a._a = 1;//可以在友元函数内部直接访问类的私有变量 } class Test { friend void Test(const Test&amp; a);//友元函数的声明；在哪个类里面声明，这个函数就是哪个函数的友元函数 private: int _a; }; int main() { Test a; return 0; } 想要通过一个类外的函数去访问类中的私有变量在一般情况下是不可行的，友元函数可以直接访问类的非公有成员，它的定义是在类外部的普通函数，不输入任何类，但是它需要在类的内部进行声明，声明时需要加上friend关键字。 ●友元函数可以访问类的非公有成员，但它不是类的成员。 ●友元函数不能用const进行修饰。 ●友元函数可以在类中的任何地方进行友元声明，不受类访问限定符的限制。 ●一个函数可以是多个类的友元函数。 ●友元函数的调用和普通函数的调用原理相同。
友元函数的声明 友元函数的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。
友元类 class A { private: int _a; }; class B { friend class A;//声明A类为B类的友元类 public: void Test()//当A类为B类的友元类的，B类中的函数也可以访问A类中的任意成员 {} private: int _b; }; int main() { A a; B b; return 0; } 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。（友元类的所有成员函数都可以是另一个类的友元函数） 注意： ●友元关系是单向的，不具有交换性 ●友元关系不能继承 ●友元关系不能传递 友元类的优点：提高了程序的运行效率 友元类的缺点：破环了类的封装性和隐蔽性" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9c34cb7452dc84e9f4e3a1f9be13c4d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-02T21:13:15+08:00" />
<meta property="article:modified_time" content="2018-07-02T21:13:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中的友元和内联函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="友元函数">友元函数</h3> 
<p>创建一个类，让他里面仅仅只有一个私有变量：</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">void</span> Test(<span class="hljs-keyword">const</span> Test&amp; a)
{
    a._a = <span class="hljs-number">1</span>;<span class="hljs-comment">//可以在友元函数内部直接访问类的私有变量</span>
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{<!-- --></span>
friend <span class="hljs-keyword">void</span> Test(<span class="hljs-keyword">const</span> Test&amp; a);<span class="hljs-comment">//友元函数的声明；在哪个类里面声明，这个函数就是哪个函数的友元函数</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> _a;
};
<span class="hljs-keyword">int</span> main()
{
    Test a;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>想要通过一个类外的函数去访问类中的私有变量在一般情况下是不可行的，<strong>友元函数可以直接访问类的非公有成员，它的定义是在类外部的普通函数，不输入任何类，但是它需要在类的内部进行声明，声明时需要加上friend关键字。</strong> <br> ●<strong>友元函数可以访问类的非公有成员，但它不是类的成员。</strong> <br> ●<strong>友元函数不能用const进行修饰。</strong> <br> ●<strong>友元函数可以在类中的任何地方进行友元声明，不受类访问限定符的限制。</strong> <br> ●<strong>一个函数可以是多个类的友元函数。</strong> <br> ●<strong>友元函数的调用和普通函数的调用原理相同。</strong></p> 
<h5 id="友元函数的声明">友元函数的声明</h5> 
<p>友元函数的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。</p> 
<h3 id="友元类">友元类</h3> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">class</span> A
{
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> _a;
};
<span class="hljs-keyword">class</span> B
{
<span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> A;<span class="hljs-comment">//声明A类为B类的友元类</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">void</span> Test()<span class="hljs-comment">//当A类为B类的友元类的，B类中的函数也可以访问A类中的任意成员</span>
    {}
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> _b;
};
<span class="hljs-keyword">int</span> main()
{
    A a;
    B b;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p><strong>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</strong>（友元类的所有成员函数都可以是另一个类的友元函数） <br> 注意： <br> ●<strong>友元关系是单向的，不具有交换性</strong> <br> ●<strong>友元关系不能继承</strong> <br> ●<strong>友元关系不能传递</strong> <br> 友元类的优点：提高了程序的运行效率 <br> 友元类的缺点：破环了类的封装性和隐蔽性</p> 
<hr> 
<h3 id="内联函数">内联函数</h3> 
<p>●<strong>将一个函数定义为内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，提高了函数运行的效率，但是增大了函数的体积。</strong> <br> 作用：内联函数的作用类似于宏，再调用内联函数的地方用内联函数的内容进行替换，消去了函数调用时所需要的时间，提高了函数运行的效率，在Debug模式下不会替换，Release模式才会进行替换。 <br> ●<strong>inline是一种以空间换时间的做法，省去调用函数额外开销。所以代码很长或者有循环/递归的函数不适宜使用内联函数</strong> <br> ●<strong>inline对于编译器而言，只是一个建议，编译器自动优化，如果定义为inline的函数体内部有循环/递归时，编译器优化时会忽略掉内联函数</strong> <br> ●<strong>inline必须与函数定义放在一起，才能成为内联函数，仅将inline放在声明前是不会起到作用的</strong> <br> ●<strong>定义在类内的成员函数默认定义为内联函数</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e97de717aa29ca53e881531d65915c17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">thymeleaf&#43;bootstrap，onclick实现传订单id到模态框中</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1512077ca173017ff48ca1ce8eef31ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">操作系统总结之内存管理（除虚拟内存管理）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>