<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>高性能秒级定时器实现源码 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="高性能秒级定时器实现源码" />
<meta property="og:description" content="1、本文展示秒级定时器的源码，源码是封装成C&#43;&#43;类，然后再次封装成API函数的方式。
用户开发手册地址：https://blog.csdn.net/freeland008/article/details/107508749
2、TimerVM.h和TimerVM.cpp是用c&#43;&#43;类的方式实现了秒级时钟的封装，TimerMng.h、TimerMng.cpp实现了二次封装，更方便开发人员直接使用。
3、总体实现思路是使用双时间轮数组交换的方式。
4、TimerVM.h
#ifndef TIMERVM_H #define TIMERVM_H #include &lt;time.h&gt; typedef void* HANDLE; typedef struct _TIMERITEM {	unsigned int dwTimes;	unsigned int dwTimeOut; time_t dtExpire; void* fp; void* pPara;	void* pPosArray; _TIMERITEM* pPrev; _TIMERITEM* pNext; }TIMERITEM; typedef TIMERITEM* LPTIMERITEM; typedef struct _TIMERARRAY { time_t dtStart; HANDLE* hArray; _TIMERARRAY() { dtStart = 0; hArray = NULL; } }TIMERARRAY; typedef TIMERARRAY* LPTIMERARRAY; class CTimerMng { private: TIMERARRAY m_pTimerArrayA; TIMERARRAY m_pTimerArrayB; time_t m_dtLastCheck; int m_nArraySize; public: LPTIMERARRAY m_pArrayOld; LPTIMERARRAY m_pArrayNew; private: size_t m_nCount;	int m_nTimerOutCount; int m_nSetTimerCount; int m_nResetCycleTimerCount; int m_nResetOverTimerCount; public:	LPTIMERITEM m_pResetList; LPTIMERITEM m_pOverList; public: CTimerMng(); ~CTimerMng(); public: int Init(int nArraySize, time_t dtNow); int Destroy(); LPTIMERITEM SetTimer(time_t dtNow, unsigned int dwTimeOut, unsigned int dwTimes, void* fp, void* pPara);	void ResetTimerCycle(LPTIMERITEM pItem);	void ResetTimerOver(LPTIMERITEM pItem);	void KillTimer(LPTIMERITEM pItem); void CheckTimeOut(time_t dtNow); void OnProcTimeOut(LPTIMERITEM pItem, time_t dtNow);	size_t GetCount(){return m_nCount;}; }; #endif 5、TimerVM." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cefab329ec530dfb12f00d4bb4f54079/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-22T11:23:48+08:00" />
<meta property="article:modified_time" content="2020-07-22T11:23:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">高性能秒级定时器实现源码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、本文展示秒级定时器的源码，源码是封装成C++类，然后再次封装成API函数的方式。</p> 
<p>     用户开发手册地址：<a href="https://blog.csdn.net/freeland008/article/details/107508749">https://blog.csdn.net/freeland008/article/details/107508749</a></p> 
<p> </p> 
<p>2、TimerVM.h和TimerVM.cpp是用c++类的方式实现了秒级时钟的封装，TimerMng.h、TimerMng.cpp实现了二次封装，更方便开发人员直接使用。</p> 
<p>3、总体实现思路是使用双时间轮数组交换的方式。</p> 
<p> </p> 
<p>4、TimerVM.h</p> 
<pre><code class="language-cpp">#ifndef TIMERVM_H
#define TIMERVM_H

#include &lt;time.h&gt;

typedef void* HANDLE;

typedef struct _TIMERITEM
{	
	unsigned int dwTimes;	
	unsigned int dwTimeOut;
	time_t dtExpire;
	void* fp;
	void* pPara;			
	void* pPosArray;

	_TIMERITEM* pPrev;
	_TIMERITEM* pNext;
}TIMERITEM;
typedef TIMERITEM* LPTIMERITEM;

typedef struct _TIMERARRAY
{
	time_t dtStart;
	HANDLE* hArray;
	_TIMERARRAY()
	{
		dtStart = 0;
		hArray = NULL;
	}
}TIMERARRAY;
typedef TIMERARRAY* LPTIMERARRAY;

class CTimerMng
{ 
private:
	TIMERARRAY m_pTimerArrayA;
	TIMERARRAY m_pTimerArrayB;
	time_t m_dtLastCheck;
	int m_nArraySize;
public:
	LPTIMERARRAY m_pArrayOld;
	LPTIMERARRAY m_pArrayNew;
private:
	size_t m_nCount;	
	int m_nTimerOutCount;
	int m_nSetTimerCount;
	int m_nResetCycleTimerCount;
	int m_nResetOverTimerCount;
public:	
	LPTIMERITEM m_pResetList;
	LPTIMERITEM m_pOverList;
public:
	CTimerMng();
	~CTimerMng();
public:
	int Init(int nArraySize, time_t dtNow);
	int Destroy();
	LPTIMERITEM SetTimer(time_t dtNow, unsigned int dwTimeOut, unsigned int dwTimes, void* fp, void* pPara);	
	void ResetTimerCycle(LPTIMERITEM pItem);		
	void ResetTimerOver(LPTIMERITEM pItem);	
	void KillTimer(LPTIMERITEM pItem);
	void CheckTimeOut(time_t dtNow);
	void OnProcTimeOut(LPTIMERITEM pItem, time_t dtNow);		
	size_t GetCount(){return m_nCount;};
};

#endif</code></pre> 
<p> </p> 
<p>5、TimerVM.cpp</p> 
<p> </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "TimerVM.h"
#include "TimerMng.h"

CTimerMng :: CTimerMng()
{
	m_nCount = 0;		

	m_nTimerOutCount = 0;
	m_nSetTimerCount = 0;
	m_nResetCycleTimerCount = 0;
	 m_nResetOverTimerCount = 0;

	m_dtLastCheck = 0;
	m_pResetList = NULL;
	m_pOverList = NULL;

	m_pTimerArrayA.hArray = NULL;
	m_pTimerArrayB.hArray = NULL;
}

CTimerMng :: ~CTimerMng()
{
	Destroy();
}

int CTimerMng :: Init(int nArraySize, time_t dtNow)
{
	m_nArraySize = nArraySize;	

	m_pTimerArrayA.hArray = new HANDLE[m_nArraySize];
	int i;
	for (i = 0; i &lt; m_nArraySize; i++)
	{
		m_pTimerArrayA.hArray[i] = NULL;
	}

	m_pTimerArrayB.hArray = new HANDLE[m_nArraySize];
	for (i = 0; i &lt; m_nArraySize; i++)
	{
		m_pTimerArrayB.hArray[i] = NULL;
	}

	m_pArrayOld = &amp;m_pTimerArrayA;
	m_pArrayNew = &amp;m_pTimerArrayB;

	m_pArrayOld-&gt;dtStart = dtNow;
	m_pArrayNew-&gt;dtStart = m_pArrayOld-&gt;dtStart + m_nArraySize;

	m_dtLastCheck = dtNow;
	//		

	return 0;
}
/*
void CTimerMng :: Align(time_t dtNow)
{
	m_pArrayOld-&gt;dtStart = dtNow;
	m_pArrayNew-&gt;dtStart = m_pArrayOld-&gt;dtStart + m_nArraySize;

	m_dtLastCheck = dtNow;
}*/

int CTimerMng :: Destroy()
{	
	if(m_pTimerArrayA.hArray != NULL)
	{
		delete[] m_pTimerArrayA.hArray;
		m_pTimerArrayA.hArray = NULL;
	}

	if(m_pTimerArrayB.hArray != NULL)
	{
		delete[] m_pTimerArrayB.hArray;
		m_pTimerArrayB.hArray = NULL;
	}

	return 0;
}

LPTIMERITEM CTimerMng :: SetTimer(time_t dtNow, unsigned int nElapse, unsigned int dwTimes, void* fp, void* pPara)
{	
	if(nElapse == 0)
	{
		return NULL;
	}

	time_t dtExpire;
	dtExpire = dtNow + nElapse;

	LPTIMERITEM pItem;
	pItem = (LPTIMERITEM)malloc(sizeof(TIMERITEM));	

	pItem-&gt;dtExpire = dtExpire;
	pItem-&gt;dwTimeOut = nElapse;
	pItem-&gt;dwTimes = dwTimes;	
	pItem-&gt;pPara = pPara;	
	pItem-&gt;fp = fp;

	pItem-&gt;pPrev = NULL;
	pItem-&gt;pNext = NULL;

	void* pAddr;	
	if(dtExpire &gt;= m_pArrayNew-&gt;dtStart)
	{	
		int nIndex;
		nIndex = dtExpire - m_pArrayNew-&gt;dtStart;		
		nIndex = nIndex%m_nArraySize;		

		if(m_pArrayNew-&gt;hArray[nIndex] == NULL)
		{				
			m_pArrayNew-&gt;hArray[nIndex] = pItem;
		}
		else			
		{
			LPTIMERITEM pTmp;
			pTmp = (LPTIMERITEM)(m_pArrayNew-&gt;hArray[nIndex]);			
			pItem-&gt;pNext = pTmp;
			pTmp-&gt;pPrev = pItem;
			m_pArrayNew-&gt;hArray[nIndex] = pItem;
		}		

		pAddr = &amp;(m_pArrayNew-&gt;hArray[nIndex]);
	}
	else
	{		
		int nIndex;
		nIndex = dtExpire - m_pArrayOld-&gt;dtStart;	

		if(m_pArrayOld-&gt;hArray[nIndex] == NULL)
		{			
			m_pArrayOld-&gt;hArray[nIndex] = pItem;
		}
		else
		{			
			LPTIMERITEM pTmp;
			pTmp = (LPTIMERITEM)(m_pArrayOld-&gt;hArray[nIndex]);			
			pItem-&gt;pNext = pTmp;
			pTmp-&gt;pPrev = pItem;
			m_pArrayOld-&gt;hArray[nIndex] = pItem;
		}			

		pAddr = &amp;(m_pArrayOld-&gt;hArray[nIndex]);
	}
	//

	pItem-&gt;pPosArray = pAddr;

	m_nCount++;

	m_nSetTimerCount++;

	return pItem;
}


void CTimerMng :: ResetTimerOver(LPTIMERITEM pItem)
{	
	void* pAddr;	
	if(pItem-&gt;dtExpire &gt;= m_pArrayNew-&gt;dtStart)
	{		
		int nIndex;
		nIndex = pItem-&gt;dtExpire - m_pArrayNew-&gt;dtStart;	
		nIndex = nIndex%m_nArraySize;	

		if(m_pArrayNew-&gt;hArray[nIndex] == NULL)
		{				
			m_pArrayNew-&gt;hArray[nIndex] = pItem;
			pItem-&gt;pPrev = NULL;
			pItem-&gt;pNext = NULL;
		}
		else			
		{			
			LPTIMERITEM pTmp;
			pTmp = (LPTIMERITEM)(m_pArrayNew-&gt;hArray[nIndex]);
			pItem-&gt;pNext = pTmp;
			pItem-&gt;pPrev = NULL;
			pTmp-&gt;pPrev = pItem;
			m_pArrayNew-&gt;hArray[nIndex] = pItem;
		}		

		pAddr = &amp;(m_pArrayNew-&gt;hArray[nIndex]);
	}
	else
	{		
		int nIndex;
		nIndex = pItem-&gt;dtExpire - m_pArrayOld-&gt;dtStart;	

		if(m_pArrayOld-&gt;hArray[nIndex] == NULL)
		{			
			m_pArrayOld-&gt;hArray[nIndex] = pItem;
			pItem-&gt;pPrev = NULL;
			pItem-&gt;pNext = NULL;
		}
		else
		{			
			LPTIMERITEM pTmp;
			pTmp = (LPTIMERITEM)(m_pArrayOld-&gt;hArray[nIndex]);			
			pItem-&gt;pNext = pTmp;
			pItem-&gt;pPrev = NULL;
			pTmp-&gt;pPrev = pItem;
			m_pArrayOld-&gt;hArray[nIndex] = pItem;
		}			

		pAddr = &amp;(m_pArrayOld-&gt;hArray[nIndex]);
	}	
	
	pItem-&gt;pPosArray = pAddr;	

	m_nResetOverTimerCount++;
}

void CTimerMng :: ResetTimerCycle(LPTIMERITEM pItem)
{		
	time_t dtExpire;
	dtExpire = pItem-&gt;dtExpire + pItem-&gt;dwTimeOut;
	//
	void* pAddr;	
	if(dtExpire &gt;= m_pArrayNew-&gt;dtStart)
	{
		int nIndex;
		nIndex = dtExpire - m_pArrayNew-&gt;dtStart;		
		nIndex = nIndex%m_nArraySize;		

		if(m_pArrayNew-&gt;hArray[nIndex] == NULL)
		{				
			m_pArrayNew-&gt;hArray[nIndex] = pItem;
			pItem-&gt;pPrev = NULL;
			pItem-&gt;pNext = NULL;
		}
		else			
		{			
			LPTIMERITEM pTmp;
			pTmp = (LPTIMERITEM)(m_pArrayNew-&gt;hArray[nIndex]);			
			pItem-&gt;pNext = pTmp;
			pItem-&gt;pPrev = NULL;
			pTmp-&gt;pPrev = pItem;
			m_pArrayNew-&gt;hArray[nIndex] = pItem;
		}		

		pAddr = &amp;(m_pArrayNew-&gt;hArray[nIndex]);
	}
	else
	{
		int nIndex;
		nIndex = dtExpire - m_pArrayOld-&gt;dtStart;

		if(m_pArrayOld-&gt;hArray[nIndex] == NULL)
		{			
			m_pArrayOld-&gt;hArray[nIndex] = pItem;
			pItem-&gt;pPrev = NULL;
			pItem-&gt;pNext = NULL;
		}
		else
		{			
			LPTIMERITEM pTmp;
			pTmp = (LPTIMERITEM)(m_pArrayOld-&gt;hArray[nIndex]);			
			pItem-&gt;pNext = pTmp;
			pItem-&gt;pPrev = NULL;
			pTmp-&gt;pPrev = pItem;
			m_pArrayOld-&gt;hArray[nIndex] = pItem;
		}			

		pAddr = &amp;(m_pArrayOld-&gt;hArray[nIndex]);
	}
	//	
	pItem-&gt;dtExpire = dtExpire;		

	pItem-&gt;pPosArray = pAddr;	

	m_nResetCycleTimerCount++;
}

void CTimerMng :: KillTimer(LPTIMERITEM pItem)
{
	void* pAddr;
	pAddr = pItem-&gt;pPosArray;

	if(pItem-&gt;pPrev == NULL)
	{
		if(pItem-&gt;pNext == NULL)
		{
			*(size_t *)pAddr = NULL;	
		}		
		else
		{
			LPTIMERITEM pNext;
			pNext = pItem-&gt;pNext;
			pNext-&gt;pPrev = NULL;
			*(size_t *)pAddr = (size_t)pNext;	
		}
	}
	else
	{
		if(pItem-&gt;pNext == NULL)
		{
			LPTIMERITEM pPrev;
			pPrev = pItem-&gt;pPrev;
			pPrev-&gt;pNext = NULL;			
		}		
		else
		{
			LPTIMERITEM pNext;
			pNext = pItem-&gt;pNext;

			LPTIMERITEM pPrev;
			pPrev = pItem-&gt;pPrev;

			pPrev-&gt;pNext = pNext;
			pNext-&gt;pPrev = pPrev;
		}
	}
	
	free(pItem);	

	m_nCount--;
}

void CTimerMng :: CheckTimeOut(time_t dtNow)
{	
	if(dtNow &gt;= m_pArrayNew-&gt;dtStart)
	{
		if(m_dtLastCheck &lt; m_pArrayNew-&gt;dtStart)	
		{
			time_t dtTime;
			for(dtTime = m_dtLastCheck + 1; dtTime &lt; m_pArrayNew-&gt;dtStart; dtTime++)
			{					
				int nIndex;
				nIndex = dtTime - m_pArrayOld-&gt;dtStart;				
				if(nIndex &gt;= m_nArraySize || nIndex &lt; 0)
				{
					break;
				}
				
				HANDLE hList;
				hList = m_pArrayOld-&gt;hArray[nIndex];
				if(hList != NULL)
				{					
					OnProcTimeOut((LPTIMERITEM)hList, dtNow);
					m_pArrayOld-&gt;hArray[nIndex] = NULL;
				}								
			}						

			for(dtTime = m_pArrayNew-&gt;dtStart; dtTime &lt;= dtNow; dtTime++)
			{								
				int nIndex;
				nIndex = dtTime - m_pArrayNew-&gt;dtStart;				
				if(nIndex &gt;= m_nArraySize || nIndex &lt; 0)
				{
					break;
				}
				
				HANDLE hList;
				hList = m_pArrayNew-&gt;hArray[nIndex];
				if(hList != NULL)
				{					
					OnProcTimeOut((LPTIMERITEM)hList, dtNow);
					m_pArrayNew-&gt;hArray[nIndex] = NULL;
				}								
			}			
		}
		else
		{
			time_t dtTime;
			for(dtTime = m_dtLastCheck + 1; dtTime &lt;= dtNow; dtTime++)
			{			
				int nIndex;
				nIndex = dtTime - m_pArrayNew-&gt;dtStart;				
				if(nIndex &gt;= m_nArraySize || nIndex &lt; 0)
				{
					break;
				}
				
				HANDLE hList;
				hList = m_pArrayNew-&gt;hArray[nIndex];
				if(hList != NULL)
				{					
					OnProcTimeOut((LPTIMERITEM)hList, dtNow);
					m_pArrayNew-&gt;hArray[nIndex] = NULL;
				}										
			}			
		}
		//
		LPTIMERARRAY pTmp;
		pTmp = m_pArrayOld;
		m_pArrayOld = m_pArrayNew;
		m_pArrayNew = pTmp;
		m_pArrayNew-&gt;dtStart = m_pArrayOld-&gt;dtStart + m_nArraySize;
		//
	}
	else
	{
		time_t dtTime;
		for(dtTime = m_dtLastCheck + 1; dtTime &lt;= dtNow; dtTime++)
		{		
			int nIndex;
			nIndex = dtTime - m_pArrayOld-&gt;dtStart;			
			if(nIndex &gt;= m_nArraySize || nIndex &lt; 0)
			{
				break;
			}
			
			HANDLE hList;
			hList = m_pArrayOld-&gt;hArray[nIndex];
			if(hList != NULL)
			{				
				OnProcTimeOut((LPTIMERITEM)hList, dtNow);
				m_pArrayOld-&gt;hArray[nIndex] = NULL;
			}								
		}		
	}

	m_dtLastCheck = dtNow;
	//	
	while(m_pResetList != NULL)
	{
		LPTIMERITEM pItem;		
		pItem = m_pResetList;		
		m_pResetList = m_pResetList-&gt;pNext;
		ResetTimerCycle(pItem);
	}	
	
	while(m_pOverList != NULL)
	{
		LPTIMERITEM pItem;		
		pItem = m_pOverList;		
		m_pOverList = m_pOverList-&gt;pNext;		
		ResetTimerOver(pItem);					
	}	
}

void CTimerMng :: OnProcTimeOut(LPTIMERITEM pItem, time_t dtNow)
{	
	while(pItem != NULL)
	{
		LPTIMERITEM pTmp;
		pTmp = pItem-&gt;pNext;

		if(dtNow &lt; pItem-&gt;dtExpire)
		{				
			if(m_pOverList == NULL)
			{
				m_pOverList = pItem;
				m_pOverList-&gt;pNext = NULL;
			}
			else
			{				
				pItem-&gt;pNext = m_pOverList;
				m_pOverList = pItem;
			}
			pItem = pItem-&gt;pNext;
			pItem = pTmp;
			continue;
		}	
		
		//
		LPTIMEROUTPROC(pItem-&gt;fp)(this, pItem, pItem-&gt;pPara);
		//
		if(pItem-&gt;dwTimes != 0xFFFFFFFF)
		{
			pItem-&gt;dwTimes--;
		}		

		if(pItem-&gt;dwTimes &gt; 0)
		{
			if(m_pResetList == NULL)
			{
				m_pResetList = pItem;
				m_pResetList-&gt;pNext = NULL;
			}
			else
			{				
				pItem-&gt;pNext = m_pResetList;
				m_pResetList = pItem;
			}
			
			pItem = pItem-&gt;pNext;
			pItem = pTmp;
			continue;					
		}
		
		//if(bAutoRelease == true)
		//{
			//MMFree(pItem, 0);
			free(pItem);
			m_nCount--;		
		//}				

		pItem = pTmp;		
		
		m_nTimerOutCount++;		
	}	
}</code></pre> 
<p>6、TimerMng.h</p> 
<pre><code class="language-cpp">#ifndef TIMERMNG_H
#define TIMERMNG_H

#define TVMAPI extern "C"  __declspec(dllexport) 

typedef void* HANDLE;

typedef void (* LPTIMEROUTPROC)(HANDLE hTimerVM, HANDLE hTimerItem, void* pPara);

TVMAPI HANDLE TVSysCreate(int nArraySize, time_t dtNow);
TVMAPI int TVSysDestroy(HANDLE hTimerVM);
TVMAPI HANDLE TVSetTimerCycle(HANDLE hTimerVM, time_t dtNow, unsigned int dwCycle, unsigned int nTimes, LPTIMEROUTPROC pProc, void* pPara);
TVMAPI HANDLE TVSetTimerAtTime(HANDLE hTimerVM, time_t dtNow, char* sDateTime, LPTIMEROUTPROC pProc, void* pPara);
TVMAPI void TVKillTimer(HANDLE hTimerVM, HANDLE hTimerItem);
TVMAPI size_t TVGetCount(HANDLE hTimerVM);
TVMAPI void TVCheckTimeOut(HANDLE hTimerVM, time_t dtNow);

#endif</code></pre> 
<p> </p> 
<p>7、TimerMng.cpp</p> 
<p> </p> 
<pre><code class="language-cpp">#include "TimerVM.h"
#include "TimerMng.h"
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

TVMAPI HANDLE TVSysCreate(int nArraySize, time_t dtNow)
{
	if(nArraySize &lt;= 1)
	{
		return NULL;
	}

	CTimerMng* pTimerMng;
	pTimerMng = new CTimerMng;
	pTimerMng-&gt;Init(nArraySize, dtNow);
	return pTimerMng;
}

TVMAPI int TVSysDestroy(HANDLE hTimerVM)
{
	CTimerMng* pTimerMng;
	pTimerMng = (CTimerMng *)hTimerVM;
	
	pTimerMng-&gt;Destroy();
	delete pTimerMng;

	return 0;
}

TVMAPI HANDLE TVSetTimerCycle(HANDLE hTimerVM, time_t dtNow, unsigned int nElapse, unsigned int nTimes, LPTIMEROUTPROC pProc, void* pPara)
{
	CTimerMng* pTimerMng;
	pTimerMng = (CTimerMng *)hTimerVM;
	return(pTimerMng-&gt;SetTimer(dtNow, nElapse, nTimes, pProc, pPara));	
}

TVMAPI HANDLE TVSetTimerAtTime(HANDLE hTimerVM, time_t dtNow, char* sExpire, LPTIMEROUTPROC pProc, void* pPara)
{
	CTimerMng* pTimerMng;
	pTimerMng = (CTimerMng *)hTimerVM;
	
	char sPart[5];

	tm SystemTime;

	memcpy(sPart, sExpire, 4);
	sPart[4] = '\0';
	SystemTime.tm_year = atoi(sPart) - 1900;

	strncpy(sPart, sExpire + 4, 2);
	sPart[2] = '\0';
	SystemTime.tm_mon = atoi(sPart) - 1;

	strncpy(sPart, sExpire + 6, 2);
	sPart[2] = '\0';
	SystemTime.tm_mday = atoi(sPart);

	strncpy(sPart, sExpire + 8, 2);
	sPart[2] = '\0';
	SystemTime.tm_hour = atoi(sPart);

	strncpy(sPart, sExpire + 10, 2);
	sPart[2] = '\0';
	SystemTime.tm_min = atoi(sPart);

	strncpy(sPart, sExpire + 12, 2);
	sPart[2] = '\0';
	SystemTime.tm_sec = atoi(sPart);

	SystemTime.tm_isdst = 0;

	time_t dtExpire;	
	dtExpire = mktime(&amp;SystemTime);	

	if(dtExpire &lt;= dtNow)
	{
		return NULL;
	}

	return(pTimerMng-&gt;SetTimer(dtNow, dtExpire - dtNow, 1, pProc, pPara));		
}

TVMAPI void TVKillTimer(HANDLE hTimerVM, HANDLE hTimerItem)
{
	CTimerMng* pTimerMng;
	pTimerMng = (CTimerMng *)hTimerVM;
	pTimerMng-&gt;KillTimer((LPTIMERITEM)hTimerItem);
}

TVMAPI size_t TVGetCount(HANDLE hTimerVM)
{
	CTimerMng* pTimerMng;
	pTimerMng = (CTimerMng *)hTimerVM;
	return pTimerMng-&gt;GetCount();	
}

TVMAPI void TVCheckTimeOut(HANDLE hTimerVM, time_t dtNow)
{
	CTimerMng* pTimerMng;
	pTimerMng = (CTimerMng *)hTimerVM;
	pTimerMng-&gt;CheckTimeOut(dtNow);		
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab64fea29fdf9def1cafd7932127ac93/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高性能秒级定时器SDK编程参考手册</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/82cb09485f30120209f8d39fa30443fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">78. Subsets（子集）三种解法（C&#43;&#43; &amp; 注释）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>