<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c# web服务器传图片不显示不出来的,无法在c#中使用httpwebrequest上传图片 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c# web服务器传图片不显示不出来的,无法在c#中使用httpwebrequest上传图片" />
<meta property="og:description" content="我试图通过API以编程方式将图像上传到另一台服务器. API希望我在一个字节数组中上传图像,以便在字段中发送：“image_content”.
我的实现和调用代码如下. Web请求命中服务器,但服务器响应我的Web请求中不存在该图像.
当我运行以下代码时,我收到的错误是图像不在请求中.我在这里错过了什么？
public static class FormUpload
{
private static readonly Encoding encoding = Encoding.UTF8;
public static HttpWebResponse MultipartFormDataPost(string postUrl, string userAgent, Dictionary postParameters)
{
string formDataBoundary = String.Format(&#34;----------{0:N}&#34;, Guid.NewGuid());
string contentType = &#34;multipart/form-data; boundary=&#34; formDataBoundary;
byte[] formData = GetMultipartFormData(postParameters, formDataBoundary);
return PostForm(postUrl, userAgent, contentType, formData);
}
private static HttpWebResponse PostForm(string postUrl, string userAgent, string contentType, byte[] formData)
{
HttpWebRequest request = WebRequest.Create(postUrl) as HttpWebRequest;
if (request == null)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/357fbe25099b4f35a3f54fee58308bed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-09T17:21:49+08:00" />
<meta property="article:modified_time" content="2021-08-09T17:21:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c# web服务器传图片不显示不出来的,无法在c#中使用httpwebrequest上传图片</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>我试图通过API以编程方式将图像上传到另一台服务器. API希望我在一个字节数组中上传图像,以便在字段中发送：“image_content”.</p> 
 <p>我的实现和调用代码如下. Web请求命中服务器,但服务器响应我的Web请求中不存在该图像.</p> 
 <p>当我运行以下代码时,我收到的错误是图像不在请求中.我在这里错过了什么？</p> 
 <p>public static class FormUpload</p> 
 <p>{<!-- --></p> 
 <p>private static readonly Encoding encoding = Encoding.UTF8;</p> 
 <p>public static HttpWebResponse MultipartFormDataPost(string postUrl, string userAgent, Dictionary postParameters)</p> 
 <p>{<!-- --></p> 
 <p>string formDataBoundary = String.Format("----------{0:N}", Guid.NewGuid());</p> 
 <p>string contentType = "multipart/form-data; boundary=" formDataBoundary;</p> 
 <p>byte[] formData = GetMultipartFormData(postParameters, formDataBoundary);</p> 
 <p>return PostForm(postUrl, userAgent, contentType, formData);</p> 
 <p>}</p> 
 <p>private static HttpWebResponse PostForm(string postUrl, string userAgent, string contentType, byte[] formData)</p> 
 <p>{<!-- --></p> 
 <p>HttpWebRequest request = WebRequest.Create(postUrl) as HttpWebRequest;</p> 
 <p>if (request == null)</p> 
 <p>{<!-- --></p> 
 <p>throw new NullReferenceException("request is not a http request");</p> 
 <p>}</p> 
 <p>// Set up the request properties.</p> 
 <p>request.Method = "POST";</p> 
 <p>request.ContentType = contentType;</p> 
 <p>request.UserAgent = userAgent;</p> 
 <p>request.ContentLength = formData.Length;</p> 
 <p>// Send the form data to the request.</p> 
 <p>using (Stream requestStream = request.GetRequestStream())</p> 
 <p>{<!-- --></p> 
 <p>requestStream.Write(formData, 0, formData.Length);</p> 
 <p>requestStream.Close();</p> 
 <p>}</p> 
 <p>return request.GetResponse() as HttpWebResponse;</p> 
 <p>}</p> 
 <p>private static byte[] GetMultipartFormData(Dictionary postParameters, string boundary)</p> 
 <p>{<!-- --></p> 
 <p>Stream formDataStream = new System.IO.MemoryStream();</p> 
 <p>bool needsCLRF = false;</p> 
 <p>foreach (var param in postParameters)</p> 
 <p>{<!-- --></p> 
 <p>if (param.Value is FileParameter)</p> 
 <p>{<!-- --></p> 
 <p>FileParameter fileToUpload = (FileParameter)param.Value;</p> 
 <p>// Add just the first part of this param, since we will write the file data directly to the Stream</p> 
 <p>string header = string.Format("--{0}\r\nContent-Disposition: form-data; name=\"{1}\"; filename=\"{2}\"\r\nContent-Type: {3}\r\n\r\n",</p> 
 <p>boundary,</p> 
 <p>param.Key,</p> 
 <p>fileToUpload.FileName ?? param.Key,</p> 
 <p>fileToUpload.ContentType ?? "application/octet-stream");</p> 
 <p>formDataStream.Write(encoding.GetBytes(header), 0, encoding.GetByteCount(header));</p> 
 <p>// Write the file data directly to the Stream, rather than serializing it to a string.</p> 
 <p>formDataStream.Write(fileToUpload.File, 0, fileToUpload.File.Length);</p> 
 <p>}</p> 
 <p>else</p> 
 <p>{<!-- --></p> 
 <p>string postData = string.Format("--{0}\r\nContent-Disposition: form-data; name=\"{1}\"\r\n\r\n{2}",</p> 
 <p>boundary,</p> 
 <p>param.Key,</p> 
 <p>param.Value);</p> 
 <p>formDataStream.Write(encoding.GetBytes(postData), 0, encoding.GetByteCount(postData));</p> 
 <p>}</p> 
 <p>}</p> 
 <p>// Add the end of the request. Start with a newline</p> 
 <p>string footer = "\r\n--" boundary "--\r\n";</p> 
 <p>formDataStream.Write(encoding.GetBytes(footer), 0, encoding.GetByteCount(footer));</p> 
 <p>// Dump the Stream into a byte[]</p> 
 <p>formDataStream.Position = 0;</p> 
 <p>byte[] formData = new byte[formDataStream.Length];</p> 
 <p>formDataStream.Read(formData, 0, formData.Length);</p> 
 <p>formDataStream.Close();</p> 
 <p>return formData;</p> 
 <p>}</p> 
 <p>public class FileParameter</p> 
 <p>{<!-- --></p> 
 <p>public byte[] File { get; set; }</p> 
 <p>public string FileName { get; set; }</p> 
 <p>public string ContentType { get; set; }</p> 
 <p>public FileParameter(byte[] file) : this(file, null) { }</p> 
 <p>public FileParameter(byte[] file, string filename) : this(file, filename, null) { }</p> 
 <p>public FileParameter(byte[] file, string filename, string contenttype)</p> 
 <p>{<!-- --></p> 
 <p>File = file;</p> 
 <p>FileName = filename;</p> 
 <p>ContentType = contenttype;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>调用上述函数的代码是：</p> 
 <p>// Read file data</p> 
 <p>FileStream fs = new FileStream("c:\\myimage.jpeg", FileMode.Open, FileAccess.Read);</p> 
 <p>byte[] data = new byte[fs.Length];</p> 
 <p>fs.Read(data, 0, data.Length);</p> 
 <p>fs.Close();</p> 
 <p>// Generate post objects</p> 
 <p>Dictionary postParameters = new Dictionary();</p> 
 <p>postParameters.Add("image_content",data);</p> 
 <p>// Create request and receive response</p> 
 <p>string postURL = "myurl";</p> 
 <p>string userAgent = "Mozilla";</p> 
 <p>HttpWebResponse webResponse = FormUpload.MultipartFormDataPost(postURL, userAgent, postParameters);</p> 
 <p>// Process response</p> 
 <p>StreamReader responseReader = new StreamReader(webResponse.GetResponseStream());</p> 
 <p>string fullResponse = responseReader.ReadToEnd();</p> 
 <p>webResponse.Close();</p> 
 <p>Response.Write(fullResponse);</p> 
 <p>解决方法:</p> 
 <p>在我看来,你应该使用MultipartFormDataContent类,因为它“为使用multipart / form-data MIME类型编码的内容提供容器.”.试试这个</p> 
 <p>public static HttpWebResponse MultipartFormDataPost(string postUrl, string userAgent, byte[] data)</p> 
 <p>{<!-- --></p> 
 <p>string contentType;</p> 
 <p>byte[] formData = Program.GetMultipartFormData(data, out contentType);</p> 
 <p>return PostForm(postUrl, userAgent, contentType, formData);</p> 
 <p>}</p> 
 <p>public static byte[] GetMultipartFormData(byte[] data, out string contentType)</p> 
 <p>{<!-- --></p> 
 <p>var byteArrayContent = new ByteArrayContent(data);</p> 
 <p>byteArrayContent.Headers.ContentType = new MediaTypeHeaderValue("image/jpeg");</p> 
 <p>byteArrayContent.Headers.Add("image_content", "myimage.jpeg");</p> 
 <p>var content = new MultipartFormDataContent(String.Format("----------{0:N}", Guid.NewGuid())) { byteArrayContent };</p> 
 <p>contentType = content.Headers.ContentType.ToString();</p> 
 <p>return content.ReadAsByteArrayAsync().Result;</p> 
 <p>}</p> 
 <p>来源：http://www.icode9.com/content-1-212001.html</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a55b889f73c101c43ffd0b5270e363dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[C&#43;&#43;] 使用＜random＞头文件生成均匀分布、正态分布的数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ee5c6408f5ac550799660adb77b3f23/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器可以挂协议吗,云服务器可以挂快手协议吗</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>