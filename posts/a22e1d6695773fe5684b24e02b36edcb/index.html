<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RPC与HTTP的关系 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RPC与HTTP的关系" />
<meta property="og:description" content="首选理清楚关系 RPC与HTTP是两个不同维度的东西
HTTP 协议（Hyper Text Transfer Protocol），又叫做超文本传输协议，是一种传输协议，平时通过浏览器浏览网页网页，用到的就是 HTTP 协议。
而 RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。
RPC这种调用方式，主要有两部分组成
传输协议序列化方式 传输协议有多种，比如HTTP协议、自研协议等。
序列化方式有很多种，比如二进制流，JSON，XML等
所以HTTP协议只是RPC中传输协议中的一种
如果传输协议与序列化方式选择HTTP与JSON，只要封装的好，也能实现这个远程调用，也能称之为RPC。
只不过早期的RPC因为传输效率的原因，大多没有选择HTTP与JSON，而是自研协议与二进制传输。
网上区分RPC与HTTP的文章太多了，我也没必要重复，所以我提供一种新的角度，就是根据历史的发展进行解释。
历史发展 早期互联网，大多是C/S架构，并且不需要对外开发API，仅自己内部调用（中国互联网对外开放事件：3Q大战），并且大家的带宽还很低，此时的HTTP协议还是1.0（1.0传输效率低，具体为什么，后面会讲）。
基于以上背景，当时需要一种高效率的传输方式，并且不需要考虑兼容性。
所以在传输协议的选择上，基于TCP的自研协议的RPC就应运而生了。
也是因为上述相同的历史背景，所以当时传输信息的序列化方式不是现在流行的JSON或者XML，而是二进制流，因为体积更小，传输效率更高。
内部系统 但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；
其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。
RPC额外优势 一般RPC框架，不仅仅有传输功能，还添加了很多其他功能，比如服务发现、负载均衡、链路追踪、限流降级等等。比如这里的Dubbo
为什么不直接使用TCP协议？ 这里就不赘述，简单说TCP协议有自身的问题，比如粘包问题等，直接使用会有问题，所以都是基于TCP的自研协议。
RPC 协议 https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/
HTTP协议为什么效率低？ 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。
HTTP请求报文 这里可以看出，HTTP协议为了传输内容，前后增加了很多“冗余”的字段，当然这里的“冗余”是为了通用性与兼容性，毕竟HTTP协议要兼容大多数不同的浏览器与不同的设备。
但是如果不需要考虑兼容性，只针对具体的设备，那就是真冗余了
为什么现在用了HTTP协议？ 现在很多是直接使用HTTP协议，并且现在很多RPC框架也是使用的HTTP协议，原因如下
因为HTTP也一直在升级，也优化了性能网友的带宽也在提升，对性能要求没这么高了兼容性，之前接口仅需支持单个设备，现在需要支持多设备了，而HTTP的兼容性是最好的，几乎所有设备都会支持成本问题：自研也需要开发成本，还要考虑兼容性。 基于以上原因，如果对性能没有极致要求，没必要自研协议，直接使用HTTP协议
总结 而 RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式，只要能够实现这种调用方式都可以称为RPC
实现RPC有两个核心点，传输协议与序列化方式，而HTTP只是传输协议中的一种。
参考 RPC 协议 https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/
既然有 HTTP 协议，为什么还要有 RPC？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a22e1d6695773fe5684b24e02b36edcb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-29T21:38:36+08:00" />
<meta property="article:modified_time" content="2023-10-29T21:38:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RPC与HTTP的关系</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a>首选理清楚关系</h2> 
<p>RPC与HTTP是两个不同维度的东西</p> 
<p><strong>HTTP</strong> 协议（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），又叫做<strong>超文本传输协议</strong>，是一种传输协议，平时通过浏览器浏览网页网页，用到的就是 HTTP 协议。</p> 
<p>而 <strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。</p> 
<p>RPC这种调用方式，主要有两部分组成</p> 
<ol><li>传输协议</li><li>序列化方式</li></ol> 
<p>传输协议有多种，比如HTTP协议、自研协议等。</p> 
<p>序列化方式有很多种，比如二进制流，JSON，XML等</p> 
<p>所以HTTP协议只是RPC中<code>传输协议</code>中的一种</p> 
<p>如果传输协议与序列化方式选择HTTP与JSON，只要封装的好，也能实现这个远程调用，也能称之为RPC。</p> 
<p>只不过早期的RPC因为传输效率的原因，大多没有选择HTTP与JSON，而是自研协议与二进制传输。</p> 
<p>网上区分RPC与HTTP的文章太多了，我也没必要重复，所以我提供一种新的角度，就是根据历史的发展进行解释。</p> 
<h2><a id="_30"></a>历史发展</h2> 
<p>早期互联网，大多是C/S架构，并且不需要对外开发API，仅自己内部调用（中国互联网对外开放事件：3Q大战），并且大家的带宽还很低，此时的HTTP协议还是1.0（1.0传输效率低，具体为什么，后面会讲）。</p> 
<p>基于以上背景，当时需要一种高效率的传输方式，并且不需要考虑兼容性。</p> 
<p>所以在传输协议的选择上，基于TCP的自研协议的RPC就应运而生了。</p> 
<p>也是因为上述相同的历史背景，所以当时传输信息的序列化方式不是现在流行的JSON或者XML，而是二进制流，因为体积更小，传输效率更高。</p> 
<p><img src="https://images2.imgbox.com/9d/64/km3mc5Nj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/82/7d/s3RdV20z_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ee/e4/OOdB80qB_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_43"></a>内部系统</h2> 
<p>但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；</p> 
<p>其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。</p> 
<h2><a id="RPC_49"></a>RPC额外优势</h2> 
<p>一般RPC框架，不仅仅有传输功能，还添加了很多其他功能，比如服务发现、负载均衡、链路追踪、限流降级等等。比如这里的Dubbo</p> 
<p><img src="https://images2.imgbox.com/e3/1f/XIaOL45K_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="TCP_54"></a>为什么不直接使用TCP协议？</h2> 
<p>这里就不赘述，简单说TCP协议有自身的问题，比如粘包问题等，直接使用会有问题，所以都是基于TCP的自研协议。</p> 
<p>RPC 协议 https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/</p> 
<h2><a id="HTTP_60"></a>HTTP协议为什么效率低？</h2> 
<p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。</p> 
<p><img src="https://images2.imgbox.com/a5/54/EqEzFKjv_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="HTTP_67"></a>HTTP请求报文</h3> 
<p><img src="https://images2.imgbox.com/ea/fe/8qSHUZBk_o.png" alt="在这里插入图片描述"></p> 
<p>这里可以看出，HTTP协议为了传输内容，前后增加了很多“冗余”的字段，当然这里的“冗余”是为了通用性与兼容性，毕竟HTTP协议要兼容大多数不同的浏览器与不同的设备。</p> 
<p>但是如果不需要考虑兼容性，只针对具体的设备，那就是真冗余了</p> 
<h2><a id="HTTP_75"></a>为什么现在用了HTTP协议？</h2> 
<p>现在很多是直接使用HTTP协议，并且现在很多RPC框架也是使用的HTTP协议，原因如下</p> 
<ul><li>因为HTTP也一直在升级，也优化了性能</li><li>网友的带宽也在提升，对性能要求没这么高了</li><li>兼容性，之前接口仅需支持单个设备，现在需要支持多设备了，而HTTP的兼容性是最好的，几乎所有设备都会支持</li><li>成本问题：自研也需要开发成本，还要考虑兼容性。</li></ul> 
<p>基于以上原因，如果对性能没有极致要求，没必要自研协议，直接使用HTTP协议</p> 
<h2><a id="_86"></a>总结</h2> 
<p>而 <strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>，只要能够实现这种调用方式都可以称为RPC</p> 
<p>实现RPC有两个核心点，<code>传输协议</code>与<code>序列化方式</code>，而<code>HTTP</code>只是<code>传输协议</code>中的一种。</p> 
<h2><a id="_92"></a>参考</h2> 
<p>RPC 协议 https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/</p> 
<p><a href="https://www.xiaolincoding.com/network/2_http/http_rpc.html" rel="nofollow">既然有 HTTP 协议，为什么还要有 RPC？</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/de71a8e9f005250713cfd875dbfbd72f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ZYNQ连载06-EasyLogger日志组件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e87cf5928ec7e6a13a78a13e34f192be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux安装部署zabbix运维监控平台，实操，步骤明晰&#43;常见问题解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>