<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线上CPU飙升100%问题排查，一篇足矣 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="线上CPU飙升100%问题排查，一篇足矣" />
<meta property="og:description" content="Java架构学习交流 2019-09-27 17:16:56
一、引子 对于互联网公司，线上CPU飙升的问题很常见（例如某个活动开始，流量突然飙升时），按照本文的步骤排查，基本1分钟即可搞定！特此整理排查方法一篇，供大家参考讨论提高。
二、问题复现 线上系统突然运行缓慢，CPU飙升，甚至到100%，以及Full GC次数过多，接着就是各种报警：例如接口超时报警等。此时急需快速线上排查问题。
三、问题排查 不管什么问题，既然是CPU飙升，肯定是查一下耗CPU的线程，然后看看GC。
3.1 核心排查步骤
1.执行“top”命令：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。
2.执行“top -Hp 进程号”命令：查看java进程下的所有线程占CPU的情况。
3.执行“printf &#34;%x\n 10&#34;命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如, printf &#34;%x\n 10&#34; -》打印：a，那么在jstack中线程号就是0xa.
4.执行 “jstack 进程号 | grep 线程ID” 查找某进程下 -》线程ID（jstack堆栈信息中的nid）=0xa的线程堆栈信息。如果“&#34;VM Thread&#34; os_prio=0 tid=0x00007f871806e000 nid=0xa runnable”，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了
5.执行“jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大-》确认Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。
6.执行“jmap -dump:format=b,file=filename 进程ID”，导出某进程下内存heap输出到文件中。可以通过eclipse的mat工具查看内存中有哪些对象比较多。
3.2 原因分析
1.内存消耗过大，导致Full GC次数过多
执行步骤1-5：
多个线程的CPU都超过了100%，通过jstack命令可以看到这些线程主要是垃圾回收线程-》上一节步骤2通过jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。--》上一节步骤5 确定是Full GC,接下来找到具体原因：
生成大量的对象，导致内存溢出-》执行步骤6，查看具体内存对象占用情况。内存占用不高，但是Full GC次数还是比较多，此时可能是代码中手动调用 System.gc()导致GC次数过多， 这可以通过添加 -XX:&#43;DisableExplicitGC来禁用JVM对显示GC的响应。 2.代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢；
执行步骤1-4：在步骤4 jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。
3.由于锁使用不当，导致死锁。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c428c3c2ecb4e630749177029e951609/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-29T11:30:10+08:00" />
<meta property="article:modified_time" content="2019-09-29T11:30:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线上CPU飙升100%问题排查，一篇足矣</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Java架构学习交流 2019-09-27 17:16:56</p> 
<p><img alt="线上CPU飙升100%问题排查，一篇足矣" class="has" src="https://images2.imgbox.com/ed/df/fGlqY8wQ_o.png"></p> 
<p> </p> 
<h2><strong>一、引子</strong></h2> 
<p>对于互联网公司，线上CPU飙升的问题很常见（例如某个活动开始，流量突然飙升时），按照本文的步骤排查，基本1分钟即可搞定！特此整理排查方法一篇，供大家参考讨论提高。</p> 
<h2><strong>二、问题复现</strong></h2> 
<p>线上系统突然运行缓慢，CPU飙升，甚至到100%，以及Full GC次数过多，接着就是各种报警：例如接口超时报警等。此时急需快速线上排查问题。</p> 
<h2><strong>三、问题排查</strong></h2> 
<p>不管什么问题，既然是CPU飙升，肯定是查一下耗CPU的线程，然后看看GC。</p> 
<p><strong>3.1 核心排查步骤</strong></p> 
<p><span style="color:#f33b45;"><strong>1.执行“top”命令：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</strong></span></p> 
<p><span style="color:#f33b45;"><strong>2.执行“top -Hp 进程号”命令：查看java进程下的所有线程占CPU的情况。</strong></span></p> 
<p><span style="color:#f33b45;"><strong>3.执行“printf "%x\n 10"命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如, printf "%x\n 10"   -》打印：a，那么在jstack中线程号就是0xa.</strong></span></p> 
<p><span style="color:#f33b45;"><strong>4.执行 “jstack 进程号 | grep 线程ID” 查找某进程下  -》线程ID（jstack堆栈信息中的nid）=0xa的线程堆栈信息。如果“"VM Thread" os_prio=0 tid=0x00007f871806e000 nid=0xa runnable”，第一个双引号圈起来的就是线程名，</strong></span><span style="color:#7c79e5;"><strong>如果是“VM Thread”这就是虚拟机GC回收线程了</strong></span></p> 
<p><span style="color:#f33b45;"><strong>5.执行“jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大-》确认Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。</strong></span></p> 
<p><span style="color:#f33b45;"><strong>6.执行“jmap -dump:format=b,file=filename 进程ID”，导出某进程下内存heap输出到文件中。可以通过eclipse的mat工具查看内存中有哪些对象比较多。</strong></span></p> 
<p><strong>3.2 原因分析</strong></p> 
<p><strong>1.内存消耗过大，导致Full GC次数过多</strong></p> 
<p>执行步骤1-5：</p> 
<ul><li>多个线程的CPU都超过了100%，通过jstack命令可以看到这些线程主要是垃圾回收线程-》上一节步骤2</li><li>通过jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。--》上一节步骤5</li></ul> 
<p>确定是Full GC,接下来找到<strong>具体原因</strong>：</p> 
<ul><li>生成大量的对象，导致内存溢出-》执行步骤6，查看具体内存对象占用情况。</li><li>内存占用不高，但是Full GC次数还是比较多，此时可能是代码中手动调用 System.gc()导致GC次数过多，   这可以通过添加 <span style="color:#f33b45;"><strong>-XX:+DisableExplicitGC来禁用JVM对显示GC的响应。</strong></span></li></ul> 
<p><strong>2.代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢；</strong></p> 
<p>执行步骤1-4：在步骤4  jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。</p> 
<p><strong>3.由于锁使用不当，导致死锁。</strong></p> 
<p>执行步骤1-4： 如果有死锁，会直接提示。关键字：deadlock. 步骤四，会打印出业务死锁的位置。</p> 
<p>造成死锁的原因：最典型的就是2个线程互相等待对方持有的锁。</p> 
<p><strong>4.随机出现大量线程访问接口缓慢。</strong></p> 
<p>代码某个位置有阻塞性的操作，导致该功能调用整体比较耗时，但出现是比较随机的；平时消耗的CPU不多，而且占用的内存也不高。</p> 
<p>思路：</p> 
<p>首先找到该接口，通过压测工具不断加大访问力度，大量线程将阻塞于该阻塞点。</p> 
<p>执行步骤1-4：</p> 
<pre>"http-nio-8080-exec-4" #31 daemon prio=5 os_prio=31 tid=0x00007fd08d0fa000 nid=0x6403 waiting on condition [0x00007000033db000]
 java.lang.Thread.State: TIMED_WAITING (sleeping)-》期限等待
 at java.lang.Thread.sleep(Native Method)
 at java.lang.Thread.sleep(Thread.java:340)
 at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
 at com.*.user.controller.UserController.detail(UserController.java:18)-》业务代码阻塞点
</pre> 
<p>如上图，找到业务代码阻塞点，这里业务代码使用了TimeUnit.sleep()方法，使线程进入了TIMED_WAITING(期限等待)状态。</p> 
<p><strong>5.某个线程由于某种原因而进入WAITING状态，此时该功能整体不可用，但是无法复现；</strong></p> 
<p>执行步骤1-4：jstack多查询几次，每次间隔30秒，对比一直停留在parking 导致的WAITING状态的线程。例如CountDownLatch倒计时器，使得相关线程等待-&gt;AQS-&gt;LockSupport.park()。</p> 
<pre>"Thread-0" #11 prio=5 os_prio=31 tid=0x00007f9de08c7000 nid=0x5603 waiting on condition [0x0000700001f89000] 
java.lang.Thread.State: WAITING (parking) -&gt;无期限等待
at sun.misc.Unsafe.park(Native Method) 
at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304) 
at com.*.SyncTask.lambda$main$0(SyncTask.java:8)-》业务代码阻塞点
at com.*.SyncTask$$Lambda$1/1791741888.run(Unknown Source) 
at java.lang.Thread.run(Thread.java:748)

</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3792e96ed012aea3b0fe50c79e3716b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">React &#43; TypeScript 实现泛型组件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c2e383af72c52b6846edc7c2856aa0b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue 中 获取数据以后，操作DOM</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>