<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js中的跨域问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js中的跨域问题" />
<meta property="og:description" content="Ajax中的跨域问题 跨域问题 跨域问题，指从一个域名的网页去请求另一个域名的资源。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。
何为跨域访问 解决跨域问题常用的方法 1. 跨域资源共享（CORS） CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。
服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！
//指定允许其他域名访问 &#39;Access-Control-Allow-Origin:*&#39;//或指定域 //响应类型 &#39;Access-Control-Allow-Methods:GET,POST&#39; //响应头设置 &#39;Access-Control-Allow-Headers:x-requested-with,content-type&#39; 2. 服务器代理 例如需要调用www.baidu.com中的资源，可以写一php接口，由这个接口从后端去调用www.baidu.com中的资源并拿到返回值，然后再返回给前端，这就是一个代理的模式。因为它是通过后端进行调用的，没有经过浏览器，自然就不存在跨域问题。
3. document.domain&#43;iframe的设置 对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain =‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，代码如下
www.a.com中的a.html
document.domain = &#39;a.com&#39;; var ifr = document.createElement(&#39;iframe&#39;); ifr.src = &#39;http://script.a.com/b.html&#39;; ifr.style.display = &#39;none&#39;; document.body.appendChild(ifr); ifr.onload = function(){ var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(&#34;h1&#34;)[0].childNodes[0].nodeValue); }; script.a.com上的b.html
document.domain = &#39;a.com&#39;; 缺点 1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。
2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。
4. 使用HTML5的window.postMessage方法跨域 window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8&#43;、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。
调用postMessage方法的window对象是只要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。
需要接收消息的window对象，可以通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4359c1bdccc2da7ceb863777976ea13a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-20T09:18:08+08:00" />
<meta property="article:modified_time" content="2019-03-20T09:18:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js中的跨域问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Ajax_0"></a>Ajax中的跨域问题</h2> 
<h3><a id="_1"></a>跨域问题</h3> 
<p>跨域问题，指从一个域名的网页去请求另一个域名的资源。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。</p> 
<h3><a id="_3"></a>何为跨域访问</h3> 
<p><img src="https://images2.imgbox.com/be/0a/8JiYYJIq_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="_5"></a>解决跨域问题常用的方法</h3> 
<h4><a id="1_CORS_6"></a>1. 跨域资源共享（CORS）</h4> 
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。<br> 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。<br> 只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！</p> 
<pre><code>//指定允许其他域名访问
'Access-Control-Allow-Origin:*'//或指定域
//响应类型
'Access-Control-Allow-Methods:GET,POST'
//响应头设置
'Access-Control-Allow-Headers:x-requested-with,content-type'
</code></pre> 
<h4><a id="2__19"></a>2. 服务器代理</h4> 
<p>例如需要调用www.baidu.com中的资源，可以写一php接口，由这个接口从后端去调用www.baidu.com中的资源并拿到返回值，然后再返回给前端，这就是一个代理的模式。因为它是通过后端进行调用的，没有经过浏览器，自然就不存在跨域问题。</p> 
<h4><a id="3_documentdomainiframe_21"></a>3. document.domain+iframe的设置</h4> 
<p>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain =‘<a href="http://a.com" rel="nofollow">a.com</a>’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，代码如下<br> www.a.com中的a.html</p> 
<pre><code>document.domain = 'a.com';
var ifr = document.createElement('iframe');
ifr.src = 'http://script.a.com/b.html';
ifr.style.display = 'none';
document.body.appendChild(ifr);
ifr.onload = function(){
    var doc = ifr.contentDocument || ifr.contentWindow.document;
    // 在这里操纵b.html
    alert(doc.getElementsByTagName("h1")[0].childNodes[0].nodeValue);
};
</code></pre> 
<p>script.a.com上的b.html</p> 
<pre><code>document.domain = 'a.com';
</code></pre> 
<h4><a id="_41"></a>缺点</h4> 
<p>1、安全性，当一个站点（<a href="http://b.a.com" rel="nofollow">b.a.com</a>）被攻击后，另一个站点（<a href="http://c.a.com" rel="nofollow">c.a.com</a>）会引起安全漏洞。<br> 2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。</p> 
<h4><a id="4_HTML5windowpostMessage_45"></a>4. 使用HTML5的window.postMessage方法跨域</h4> 
<p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。<br> 调用postMessage方法的window对象是只要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。<br> 需要接收消息的window对象，可以通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。</p> 
<h4><a id="5_web_sockets_50"></a>5. web sockets</h4> 
<p>web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</p> 
<p>web sockets原理：在js创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。</p> 
<p>只有在支持web socket协议的服务器上才能正常工作。</p> 
<pre><code>var socket = new WebSockt('ws://www.baidu.com');//http-&gt;ws; https-&gt;wss
socket.send('hello WebSockt');
socket.onmessage = function(event){
    var data = event.data;
}
</code></pre> 
<h4><a id="6JSONP_64"></a>6.JSONP</h4> 
<p>script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。<br> jQuery使用jsonp代码如下</p> 
<pre><code>&lt;div id="divCustomers"&gt;&lt;/div&gt;
&lt;script&gt;
$.getJSON("http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?", function(data) {
    
    var html = '&lt;ul&gt;';
    for(var i = 0; i &lt; data.length; i++)
    {
        html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;';
    }
    html += '&lt;/ul&gt;';
    
    $('#divCustomers').html(html); 
});
&lt;/script&gt;
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/098006223c284e93f02c3d9049e3726c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在cisco官网上下载Cisco packet tracer模拟器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/11b0eb9ccc9536c010b489209ba8b101/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">idea 引入elasticsearch6.6.1源码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>