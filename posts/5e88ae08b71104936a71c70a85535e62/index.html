<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>node代理请求 vue_vue使用代理解决请求跨域问题详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="node代理请求 vue_vue使用代理解决请求跨域问题详解" />
<meta property="og:description" content="在日常开发中，我们前端必不可少的需要像后端请求数据。
但是一般前后端分离，所以域名、端口等肯定不尽相同，这样就不可避免的会遇到浏览器的同源策略限制。
在一般情况下，后端都会设置请求跨域允许的来源、方法等。
但是也保不准后端疏忽而忘记这个问题。
那为了不影响我们的开发，前端只能被动的去找后端解决跨域问题。
其实，我们前端也可以解决跨域问题，那就是使用代理。
举个例子：
我请求的地址是这个：http://192.168.12.36:9000/api/SourceManager
但是我本地的vue项目的端口号是8080，这里就涉及到了端口号不一致导致的同源策略问题(别想着改成同端口，会冲突)、
那么我发起请求就会跨域而被浏览器拦截，那么我们来看看解决办法：
在vue的config文件夹中有个index.js文件：
在proxyTable中配置代理(名字可以随便起，我用的是web)
proxyTable: {
&#39;/web&#39;: {
//设置你调用的接口域名和端口号 别忘了加http
target: &#39;http://192.168.12.36:9000/api/SourceManage&#39;,
changeOrigin: true,
pathRewrite: {
&#39;^/web&#39;: &#39;&#39;
//这里理解成用‘/web&#39;代替target里面的地址，后面组件中我们掉接口时直接用web代替 比如我要调用&#39;http://192.168.12.36:9000/api/SourceManage/user/add&#39;，直接写‘/web/user/add&#39;即可
}
}
}
因为我是把公共的请求地址抽离出来的，所以大家可以参考以下部分：
获取数据：http://192.168.12.36:9000/api/SourceManager/GetAll
增加数据：http://192.168.12.36:9000/api/SourceManager/AddSource
修改数据：http://192.168.12.36:9000/api/SourceManager/UpdateSource
删除数据：http://192.168.12.36:9000/api/SourceManager/DeleteSource
理论上代理中配置到端口号即可，但是我为了后期方便，把公共地址抽离出来，一直配置到公共的结束，所以代理中我配置的是http://192.168.12.36:9000/api/SourceManager
然后在config文件夹中的dev.env.js文件中配置生产环境(开发环境)：
这边写自己的路径端口号以及前面配置的代理名：
module.exports = merge(prodEnv, {
NODE_ENV: &#39;&#34;development&#34;&#39;,
API_ROOT: &#39; &#34;http://localhost:8080/web&#34; &#39;
})
然后在config文件夹中的prod.env.js文件中配置产品环境(上线环境)：
这边我暂时就不写了，大家上线打包的时候写成自己的实际请求地址即可。
module.exports = {
NODE_ENV: &#39;&#34;production&#34;&#39;,
API_ROOT: &#39; &#34;&#34; &#39;
}
然后在main.js里改为请求配置的地址：
// 引入axios
import axios from &#39;axios&#39;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5e88ae08b71104936a71c70a85535e62/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-19T12:16:45+08:00" />
<meta property="article:modified_time" content="2020-12-19T12:16:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">node代理请求 vue_vue使用代理解决请求跨域问题详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>在日常开发中，我们前端必不可少的需要像后端请求数据。</p> 
 <p>但是一般前后端分离，所以域名、端口等肯定不尽相同，这样就不可避免的会遇到浏览器的同源策略限制。</p> 
 <p>在一般情况下，后端都会设置请求跨域允许的来源、方法等。</p> 
 <p>但是也保不准后端疏忽而忘记这个问题。</p> 
 <p>那为了不影响我们的开发，前端只能被动的去找后端解决跨域问题。</p> 
 <p>其实，我们前端也可以解决跨域问题，那就是使用代理。</p> 
 <p>举个例子：</p> 
 <p>我请求的地址是这个：http://192.168.12.36:9000/api/SourceManager</p> 
 <p>但是我本地的vue项目的端口号是8080，这里就涉及到了端口号不一致导致的同源策略问题(别想着改成同端口，会冲突)、</p> 
 <p>那么我发起请求就会跨域而被浏览器拦截，那么我们来看看解决办法：</p> 
 <p>在vue的config文件夹中有个index.js文件：</p> 
 <p>在proxyTable中配置代理(名字可以随便起，我用的是web)</p> 
 <p>proxyTable: {<!-- --></p> 
 <p>'/web': {<!-- --></p> 
 <p>//设置你调用的接口域名和端口号 别忘了加http</p> 
 <p>target: 'http://192.168.12.36:9000/api/SourceManage',</p> 
 <p>changeOrigin: true,</p> 
 <p>pathRewrite: {<!-- --></p> 
 <p>'^/web': ''</p> 
 <p>//这里理解成用‘/web'代替target里面的地址，后面组件中我们掉接口时直接用web代替 比如我要调用'http://192.168.12.36:9000/api/SourceManage/user/add'，直接写‘/web/user/add'即可</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>因为我是把公共的请求地址抽离出来的，所以大家可以参考以下部分：</p> 
 <p>获取数据：http://192.168.12.36:9000/api/SourceManager/GetAll</p> 
 <p>增加数据：http://192.168.12.36:9000/api/SourceManager/AddSource</p> 
 <p>修改数据：http://192.168.12.36:9000/api/SourceManager/UpdateSource</p> 
 <p>删除数据：http://192.168.12.36:9000/api/SourceManager/DeleteSource</p> 
 <p>理论上代理中配置到端口号即可，但是我为了后期方便，把公共地址抽离出来，一直配置到公共的结束，所以代理中我配置的是http://192.168.12.36:9000/api/SourceManager</p> 
 <p>然后在config文件夹中的dev.env.js文件中配置生产环境(开发环境)：</p> 
 <p>这边写自己的路径端口号以及前面配置的代理名：</p> 
 <p>module.exports = merge(prodEnv, {<!-- --></p> 
 <p>NODE_ENV: '"development"',</p> 
 <p>API_ROOT: ' "http://localhost:8080/web" '</p> 
 <p>})</p> 
 <p>然后在config文件夹中的prod.env.js文件中配置产品环境(上线环境)：</p> 
 <p>这边我暂时就不写了，大家上线打包的时候写成自己的实际请求地址即可。</p> 
 <p>module.exports = {<!-- --></p> 
 <p>NODE_ENV: '"production"',</p> 
 <p>API_ROOT: ' "" '</p> 
 <p>}</p> 
 <p>然后在main.js里改为请求配置的地址：</p> 
 <p>// 引入axios</p> 
 <p>import axios from 'axios'</p> 
 <p>// 使用axios</p> 
 <p>Vue.prototype.axios = axios;</p> 
 <p>// 配置公共请求地址</p> 
 <p>Vue.prototype.baseURL = process.env.API_ROOT;</p> 
 <p>然后在每个页面请求即可，写法参考：</p> 
 <p>因为之前一直配置的是公共地址，所以这里只写后面变化的，前面的引用设置的路径即可。</p> 
 <p>this.axios({<!-- --></p> 
 <p>method: "get",</p> 
 <p>url:`${this.baseURL}/GetAll`,</p> 
 <p>})</p> 
 <p>.then((response)=&gt; {<!-- --></p> 
 <p>console.log(response)</p> 
 <p>})</p> 
 <p>.catch((error)=&gt; {<!-- --></p> 
 <p>console.log(error);</p> 
 <p>});</p> 
 <p>设置完代理别忘了重启服务器。</p> 
 <p>好了，以上就是vue中配置代理解决跨域的问题。</p> 
 <p>以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持脚本之家。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/82eff52c14f021752a43f4422d6c2292/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jwt token注销_退出登录时怎样实现JWT Token失效？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8426c9ba9f3e9725f3d141a022f4eaf1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">苹果序列号查询教程，鉴别手机真伪！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>