<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker必知必会 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker必知必会" />
<meta property="og:description" content="Docker必知必会
一、安装docker
二、镜像的所有操作
1.增加镜像（拉取镜像 ）
2.删除镜像
3.修改镜像
4.查询镜像
三、容器的所有操作
1.增加容器
2.删除容器
3.修改容器
4.查看容器
5.启动容器
6.容器的状态：
四、Dockerfile的使用
1.Dockefile是什么有什么用
2.Dockerfile的语法和规范
3.Dockerfile示例
4.使用Dockerfile创建自己的镜像：docker build
5. “.dockerignore”文件
五、docker使用常见问题
1.docker的登录
2.本地容器上传远端仓库
3.本地容器跨服务器传送
4.配置阿里云镜像加速
5.端口映射问题
6.防火墙放行端口问题
7.容器不支持telnet命令
8.容器不支持ps命令
9.容器不支持vim命令
一、安装docker
这里介绍在centos7系统上的docker安装，linux中不同系统不同版本安装docker都会有些差异。
具体步骤见后面链接：centos7中docker的安装
二、镜像的所有操作
这里介绍镜像操作的增删改查，这是docker中比较频繁的操作之一。做这些操作之前请正常安装完成docker并启动。使用docker version可查看是否正常启动了docker。
1.增加镜像（拉取镜像 ）
docker image pull nginx:tag # *****************************************实战分割线*****************************************
#举例子：拉取nginx的最新版本镜像
docker image pull nginx:latest docker pull nginx:latest 1
2
3
4
5
docker image pull 命令主体，其中image是可以省略的，在整个命令中nginx是镜像的名称，tag是版本号，他们使用冒号隔开。如果不显示指定tag时，则默认拉取最新版本也就是latest版本。
2.删除镜像
docker rmi 镜像:tag
docker image rm 镜像名/镜像id" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4493f3add73c05d0a64e17c04100f65f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-20T16:27:13+08:00" />
<meta property="article:modified_time" content="2023-12-20T16:27:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker必知必会</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Docker必知必会<br> 一、安装docker<br> 二、镜像的所有操作<br> 1.增加镜像（拉取镜像 ）<br> 2.删除镜像<br> 3.修改镜像<br> 4.查询镜像<br> 三、容器的所有操作<br> 1.增加容器<br> 2.删除容器<br> 3.修改容器<br> 4.查看容器<br> 5.启动容器<br> 6.容器的状态：<br> 四、Dockerfile的使用<br> 1.Dockefile是什么有什么用<br> 2.Dockerfile的语法和规范<br> 3.Dockerfile示例<br> 4.使用Dockerfile创建自己的镜像：docker build<br> 5. “.dockerignore”文件<br> 五、docker使用常见问题<br> 1.docker的登录<br> 2.本地容器上传远端仓库<br> 3.本地容器跨服务器传送<br> 4.配置阿里云镜像加速<br> 5.端口映射问题<br> 6.防火墙放行端口问题<br> 7.容器不支持telnet命令<br> 8.容器不支持ps命令<br> 9.容器不支持vim命令<br> 一、安装docker<br> 这里介绍在centos7系统上的docker安装，linux中不同系统不同版本安装docker都会有些差异。<br> 具体步骤见后面链接：centos7中docker的安装</p> 
<p>二、镜像的所有操作<br> 这里介绍镜像操作的增删改查，这是docker中比较频繁的操作之一。做这些操作之前请正常安装完成docker并启动。使用docker version可查看是否正常启动了docker。</p> 
<p>1.增加镜像（拉取镜像 ）<br> docker image pull nginx:tag    <br> # *****************************************实战分割线*****************************************<br> #举例子：拉取nginx的最新版本镜像<br> docker image pull nginx:latest <br> docker pull nginx:latest    <br> 1<br> 2<br> 3<br> 4<br> 5<br> docker image pull 命令主体，其中image是可以省略的，在整个命令中nginx是镜像的名称，tag是版本号，他们使用冒号隔开。如果不显示指定tag时，则默认拉取最新版本也就是latest版本。</p> 
<p>2.删除镜像<br> docker rmi 镜像:tag<br> docker image rm 镜像名/镜像id<br> # *****************************************实战分割线*****************************************<br> #举例子：删除tag为latest的nginx的镜像<br> docker rmi nginx:latest<br> #举例子：删除id为612开头的镜像（通过612能确认唯一id）<br> docker image rm 612<br> #举例子：强制删除id为612开头的镜像（即使镜像在使用也会删除）<br> docker image rm -f 612<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 这两个删除命令等价，都可以用来删除镜像，他们没有任何区别。只有使用容器名和id来做删除时会有区别。使用镜像名删除时只会删除当前镜像，不会删除与该镜像名同源的镜像，但是同源镜像的id都是相同的，所以若是使用id删除就会删除所有同源镜像。上面的示例中-f是强制的意思。这与linux的命令基本都是一致的。一般删除时还是建议使用镜像名来删除，若是使用id很可能会同时删除了多个镜像。</p> 
<p>3.修改镜像<br> docker tag nginx:latest mynginx:3.3.3    <br> # *****************************************实战分割线*****************************************<br> #举例子：将latest版本的nginx更名为3.3.3版本的mynginx，更改后原先的镜像会依然存在<br> docker tag nginx:latest mynginx:3.3.3    <br> #举例子：使用该命令可以查看所有的镜像<br> docker images <br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 为本地镜像添加新的标签，本地镜像只能改镜像名称和标签，其他改不了。修改以后会出现一个新的镜像，这个镜像和原先的镜像其实都是一个镜像的不同名称而已。他们本质上还是一个。这就像java中一个对象有多个引用一样，也可以类比spring中为bean起的别名，其实他们指向的都是一个镜像。</p> 
<p>4.查询镜像<br> docker images # 查询本地所有的镜像<br> docker image ls # 查询本地所有的镜像<br> docker image inspect nginx:latest # 查看本地tag为latest的nginx镜像的所有信息<br> docker inspect nginx:latest    # 查看本地tag为latest的nginx镜像的所有信息<br> docker search nginx<br> # 举例子：查询标星在200以上的nginx<br> docker search -f=stars=200<br> docker search --filter=stars=200 nginx <br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 上面介绍了三个命令，分别是查看本地所有镜像的命令images、查看本地镜像详细信息的命令inspect、查看远端所有镜像的命令。使用的话也就是上面介绍的那样了。</p> 
<p>三、容器的所有操作<br> 这一章节介绍关于容器的所有操作，当然这里的操作介绍的并不是非常全，但是作为基础使用基本够了。</p> 
<p>1.增加容器<br> docker create -it centos:centos8 # 创建一个tag为centos8的centos容器<br> docker run -it centos:centos8 /bin/bash<br> # *****************************************实战分割线*****************************************<br> docker create -it centos:centos8 <br> docker start 容器名/id<br> docker run -it -d centos:centos8 /bin/bash<br> docker ps -a # 查看本地的所有容器<br> docker ps # 查看所有运行中的容器<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> docker create和docker run命令需要说明的是，本地若是不存在该镜像，会先去远端拉取该镜像然后才会创建容器。docker run命令相当于docker create + docker start。所以说docker run是创建并启动。需要注意的是五路哪种方式创建的容器只要使用exit退出容器后，容器就会停止。<br> -it选项让 Docker 分配一个伪终端并绑定到容器的标准输入上，则让容器的标准输入保持打开。但是如果不连接这个终端是看不出效果的。<br> -d 让容器以守护进程的方式运行。容器以什么状态运行都是在创建容器时指定的，容器一旦创建完成则不能更改，若是想更改容器的运行方式只能是删除容器然后重新建立。<br> /bin/bash 创建容器的同时，打开一个bash终端。</p> 
<p>2.删除容器<br> docker pause 容器名/id，#暂停容器，不会删除容器，应该还可以重新启动。<br> docker unpause 容器名/id, #取消暂停，此时容器会恢复运行状态。<br> docker stop 容器名/id #暂停容器的运行<br> docker kill 容器名/id  #这是直接杀死容器<br> docker container prune #删除所有不在运行状态的容器。<br> # docker rmi （删镜像）、docker image rm（删除镜像），这俩命令与下面命令不一样需注意。<br> docker rm -f 容器名/id #强制删除容器，正在运行也会删除。<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 此命令区别与<br> 容器的删除与镜像没有关系，事实上容器是在只读镜像的基础上增加了一些操作数据而已。这也就是常说的镜像和容器的结构是分层的。<br> 需要注意的是docker stop命令会经过两个阶段，该命令会首先向容器发送 SIGTERM 信号，等待一段超时时间后（默认为 10 秒），再发送SIGKILL 信号来终止容器，所以stop命令并不会立即停止容器，但是docker kill 命令则会立即杀死容器。</p> 
<p>3.修改容器<br> 严格意义上来说容器是不可以修改的，这里所指的修改是进入到容器内部，可以对容器内部进行一些操作。我们可以将容器看成虚拟机里装了某个镜像然后构成了容器。我们可以进入到这个容器然后然后修改这个虚拟机的配置项。这里就介绍到如何进入到容器内部。</p> 
<p>docker attach 容器名/id<br> docker exec -it 容器名/id /bin/bash<br> #举例子：使用attach命令通过redis容器id进入到容器内部<br> docker attach 3b93 # 3b93是redis容器的id<br> #举例子：使用exec命令进入到redis容器的内部<br> docker exec -it 3b93 /bin/bash<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 注意进入容器后使用exit退出时，容器就会停止。默认退出方式是ctrl+p、ctrl+q（这里注意这两个都需要执行的，先执行ctrl+p再执行ctrl+q才可以正常退出容器 ）,退出时不影响容器的正确运行。不过也可以指定退出的快捷键，没什么意义，使用默认就好。不过attach命令有个很明显的缺陷，就是所有连接 到容器的客户端都是同步显示的，也就是一个终端执行命令，所有都会看到，一个终端卡住了，所有终端也会卡<br> 住，这样总感觉不对，好像是单线程同步操作，对于多个连接来说，自己的操作很容易被打断，所有又有了exec命令。这个命令是异步的，各个终端谁操作谁的，互不影响。可以看出是多线程应用。这里的-it与创建容器的-it都是一样 的作用就是创建一个伪终端然后保持打开，上面说只能在创建容器时使用-it是对于exec命令出来之前的docker来说的。并且exec -it id /bin/bash 是推荐的打开方式。默认退出方式都是一致的都是：ctrl+p、ctrl+q。</p> 
<p>4.查看容器<br> docker ps -a # 查看所有容器，包含停止运行和正在运行的容器<br> docker ps # 查看正在运行的所有容器<br> docker container inspect 容器名/id  # 查看某容器的具体信息<br> docker top 容器名/id # 这里的top与linux系统的top命令类似<br> docker stats 容器名/id # 查看容器中内存、cpu等的使用情况<br> docker container port 容器名/id # 查看容器内的端口映射情况<br> docker logs 容器名/id # 查看容器运行的日志<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 这里第一、二个和最后一个可能会比较常用，第一、二个没啥需要多余声明的，最后一个命令使用时docker container port是命令，后面跟容器的id或者名称即可。</p> 
<p>5.启动容器<br> docker start 容器名/id # 使用create命令创建的容器默认是关闭的，需要启动，还有容器一旦执行stop后也需要使用start启动。<br> docker restart 容器名/id # 重启运行中容器。<br> docker run -it 镜像:tag /bin/bash # 创建一个容器并运行他，并通过bash打开一个终端。<br> 1<br> 2<br> 3<br> 这三个是比较常用的命令，第一个是启动容器，第二个是重启，第三个是创建加启动，docker run相当于docker create 加 docker start命令的组合。</p> 
<p>6.容器的状态：<br> Created : 创建后未运行过，使用create命令。<br> Up ： 正在运行,使用run、start、unpause等命令<br> Up paused ：被暂停，使用了pause命令<br> Exited ：退出了，执行stop，或者bash中使用exit<br> 四、Dockerfile的使用<br> Dockerfile仓库提供了很多的镜像供我们下载使用，但是并不是所有都能满足我们的需求，因此我们有时就需要对镜像进行定制化。这就需要Dockerfile了，我们可以利用其实现镜像的定制化。</p> 
<p>1.Dockefile是什么有什么用<br> Dockerfile的作用主要就是实现定制化的镜像，当仓库里的镜像不能满足我们需求时我们就可以使用Dockerfile自己创建镜像了，如果不使用Dockerfile也可以自己下载一个镜像，然后在镜像里自己下载各种组件，从而满足我们的需求。Dockerfile其实就是将我们的操作提前到了文件里了而已。</p> 
<p>2.Dockerfile的语法和规范<br> 命名：默认是Dockerfile，如不是该名称，则需要手动指定，文件名后缀没有要求<br> 语法：严格区分大小写，内部命令必须大写，命令的参数大小写不同意，命令与注释使用空格隔开，注释使用 #<br> 下面根据具体的命令来说一说<br> 配置指令</p> 
<p>ARG 定义创建镜像过程中使用的变量<br> 需要注意的是该变量只在使用dockerfile创建镜像的过程中有用，在容器内无效</p> 
<p>格式：ARG &lt;name&gt;[=&lt;defaul七 value&gt;]<br> 举例1：ARG arg1 = "Hello World ! "<br> 举例2：ARG arg2 = "Hello Dockerfile ! "<br> 举例3：ARG arg3<br> 引用变量：${arg1} 、${arg2}<br> 注：&lt;&gt;内表示这里填值，实际是省略掉的。[]内的内容表示可以省略掉。<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 上面说到ARG后面可以不用声明具体的值，之所以可以不声明值是因为dockerfile允许接收外部参数的传参（声明了值也可以接收外部的参数），当我们使用镜像创建容器并启动时可以传参，如：</p> 
<p>docker build --build-arg arg3="你好"，dokerfile --build-arg arg2="你好，dockerfile"<br> 1<br> FROM 指定所创建镜像的基础镜像<br> 指定基础镜像，之后的操作都会基于基础镜像，若是有多个基础镜像，则最终形成的镜像是根据最后一个FROM 后的镜像来生成的，之前的镜像里的内容若迁移到最后一个镜像内，则失效。迁移需要使用COPY指令</p> 
<p>FROM允许三种格式<br> 格式1：FROM &lt;image&gt; [AS &lt;name&gt;] <br> 举例1：<br> FROM debian as MyLinuxOS<br> 格式2：FROM &lt;image&gt;: &lt;tag&gt; [AS &lt;name&gt;]<br> 举例2：<br> ARG VERSION=9.3<br> FROM debian=${VERSION}<br> 格式3：FROM &lt;image&gt;@&lt;digest&gt; [AS &lt;name&gt;]<br> 举例3：<br> FROM nginx@da86ecb516d8 <br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 需要特殊说明的是digest取的是镜像里的这个值：docker镜像仓库</p> 
<p>使用摘要的好处是可以100%确定你要的镜像信息，该值是根据镜像内容生成的摘要类似MD5.</p> 
<p>LABEL 为生成的镜像添加元数据标签信息<br> 一般使用该标签指定镜像的作者信息</p> 
<p>格式：LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br> 举例：<br> LABEL version="1.0.0-619"<br> LABEL author="phil"<br> 1<br> 2<br> 3<br> 4<br> EXPOSE 声明镜像内服务监听的端口<br> 使用expose声明的端口，不会自动映射也不会打开，只是起到声明的作用，若是需要端口映射我们需要在创建容器时使用-p进行手动声明，若是需要打开端口则需要我们在CMD命令里启动对应的进程,他的作用是帮助我们映射端口，却不能直接完成映射。</p> 
<p>格式：EXPOSE &lt;port&gt; [&lt;port/&lt;protocol&gt;... ]<br> 举例1：EXPOSE 6379 5672 22<br> 举例2：EXPOSE 6379/TCP 5672/TCP 22/TCP<br> 注：若不声明通讯协议，则默认是TCP<br> 1<br> 2<br> 3<br> 4<br> ENV 指定环境变量<br> 使用ENV可以指定环境变量，该变量会作用到镜像内部。前面介绍过ARG，使用ARG声明的参数引用时使用${arg1}，来进行参数引用。对于ENV声明的环境变量来说不是使用其来引用了，而是使用$即可直接引用.</p> 
<p>格式：ENV &lt;key&gt; &lt;value&gt;或ENV &lt;key&gt;=&lt;value&gt;...<br> 举例1：EVN key1=value1<br> 举例2：ENV PATH $PATH:/uar/java/bin<br> 1<br> 2<br> 3<br> 注EVN与ARG类似的是，他们的参数都可以被覆盖，比如使用如下质量覆盖上面的例子：</p> 
<p>docker run --env key1=value1 <br> 1<br> ENTRYPOINT 指定镜像的默认入口命令<br> 该命令与CMD指令的作用上基本一致，声明的命令均可以被覆盖，都是指定镜像启动时的默认指令的，但有一定的区别。CMD声明的内容可以作为ENTRYPOINT的参数，反之则不行。此外ENTRYPOINT支持两种格式：一种JSON、一种是shell。还有每个 Dockerfile 中只能有一个 ENTRYPOINT, 当指定多个时， 只有最后一个生效。</p> 
<p>格式1：ENTRYPOINT ["executable", "param1", "param2"]<br> 注意：这里的[]是代表数组的含义，不代表可省略的意思<br> 格式2：ENTRYPOINT command param1 param2<br> 这两种形式在功能上是等效的，都可以指定容器启动时要执行的命令或可执行文件，并可以附带参数。但是它们在参数处理和执行上略有不同。<br> 使用 JSON 数组形式的 ENTRYPOINT（第一种形式）时，Docker 将直接以数组的形式执行指定的可执行文件，并将后续的参数作为该可执行文件的参数传递。这意味着 param1 和 param2 将被传递给 executable。<br> 使用 Shell 命令形式的 ENTRYPOINT（第二种形式）时，Docker 将通过 /bin/sh -c 或类似的方式执行指定的命令。整个命令行（command param1 param2）将作为一个字符串传递给 Shell，并由 Shell 进行解析和执行。这意味着 param1 和 param2 将作为命令行参数传递给 command。<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 下面是具体的使用例子：</p> 
<p>举例1：ENTRYPOINT ["echo", "Hello", "World"]<br> 举例2：ENTRYPOINT echo "Hello" "World"<br> 在两种情况下，当容器启动时，将输出相同的结果："Hello World"。<br> JSON 数组形式更直接，不需要通过 Shell 解析<br> Shell 命令形式可以提供更多的 Shell 功能，例如变量替换和重定向等<br> 1<br> 2<br> 3<br> 4<br> 5<br> 此外还需要说明的是ENTRYPOINT声明的指令也是可以被覆盖的，运行容器时可以使用如下指令进行覆盖：</p> 
<p>docker run --entrypoint ["echo","Hello","World"]<br> 1<br> VOLUME 创建一个数据卷挂载点<br> VOLUME指定的数据卷，会默认挂载到宿主机的/var/lib/docker/volumes 这个目录下，在这个目录下创建一个文件夹进行挂载，使用dockerfile中的VOLUME命令无法显示指定挂载到宿主机的哪个目录下（因为这里是镜像，确定不了宿主机）。同时该指令也是可以被覆盖的，我们使用-v或者–volume参数均可以对VOLUME指令进行覆盖。-v是较老较简单的挂载命令，–volume则是交维强大和新的挂载命令。</p> 
<p>格式：VOLUME ["路径"]<br> 举例：VOLUME ["/data"]<br> 1<br> 2<br> USER 指定运行容器时的用户名或UID<br> 指定以何种身份运行容器，USER 指令在 Dockerfile 中是有持久性的，即它会影响到后续的指令。一旦指定了 USER，在后续的操作中都将使用该用户身份执行，直到另一个 USER 指令出现或者容器启动时通过 -u 参数指定不同的用户。</p> 
<p>格式：USER &lt;username&gt;<br> 举例：USER root<br> 1<br> 2<br> 注意：若是不指定USER，则默认使用root运行容器，一般为了安全考虑需要指定非root用户。</p> 
<p>WORKDIR 配置工作目录<br> 声明工作目录，可以声明为相对路径或者绝对路径，相对路径则是相对当前的路径来的。WORKDIR后面的指令都是基于这个目录进行操作的。</p> 
<p>格式：WORKDIR &lt;path&gt;<br> 举例：WORKDIR /app<br> 1<br> 2<br> 该命令是为了在构建容器时而指定的工作目录，可以更方便的看到在哪个目录下执行的RUN、COPY等指令。不存在被运行时覆盖的场景。</p> 
<p>ONBUILD 创建子镜像时指定自动执行的操作指令<br> 通俗说就是基于当前dockerfile构建出的镜像来创建子镜像时，ONBUILD后面的指令会自动执行，有点类似于ENTYPOINT，但是ONBUILD后面跟的操作可以是dockerfile允许的各种命令。不过我感觉没啥大用，因为需要指定的指令我们完全可以在创建子镜像时写在对应的dockerfile中</p> 
<p>格式：ONBUILD [INSTRUCTION]<br> 举例：<br> ONBUILD ADD /usr/* /usr/<br> ONBUILD RUN java -jar /usr/app.jar<br> 1<br> 2<br> 3<br> 4<br> STOPSIGNAL 指定退出的信号值<br> 指明容器退出的信号，当我们在docker环境下执行docker stop 容器id 命令时，docker就会向容器发送退出信号，这个信号就是我们使用该命令声明的信号，且不同信号对于容器退出时的动作是不同的，常有以下几种选择：</p> 
<p>SIGTERM：默认信号，如不声明退出信号，则默认为该值，该信号退出容器时会优雅退出，先进行清理然后会优雅退出。<br> SIGKILL：无条件终止信号。当容器收到 SIGKILL 信号时，容器内的进程会立即被终止，不会有额外的处理时间。这种信号可以用于强制终止容器，但可能导致未完成的操作或数据丢失。<br> SIGINT：终端中断信号，通常由用户在终端按下 Ctrl+C 触发。类似于 SIGTERM，可以被容器内的进程捕获并进行一些清理操作后退出。<br> 总结来说我们使用默认的即可，无需更改。除非特殊需求。<br> 格式：STOPSIGNAL &lt;signal&gt;<br> 举例：STOPSIGNAL SIGTERM<br> 1<br> 2<br> HEALTH_CHECK 配置所启动容器如何进行健康检查<br> 用以检查容器内的应用程序是否健康，如若不健康会默认反馈给docker服务，docker服务会检测容器启动时是否指定了自动重启策略，如若指定了则会执行自动重启策略，没指定则忽略。其中OPTIONS支持以下三个参数的组合：</p> 
<p>-interval=DUARTION # 默认间隔30s，做一次心跳检测<br> -timeout=DUARTION # 默认30s，等待结果的超时时间<br> -retries=N # 默认是3，失败重试次数，当失败重试次数执行完毕后还是失败则认为不健康<br> 格式：HEALTH HEC [OPTIONS] CMD commond<br> 举例：<br> HEALTHCHECK  NONE # 禁止监控检查<br> HEALTHCHECK --interval=30s --timeout=3s --retries=3 CMD curl -f http://localhost:8888/ || exit 1 # 监控容器内的应用，不健康就退出，此时会触发自动重启<br> 1<br> 2<br> 3<br> 4<br> 若是失败了则是需要执行自动重启策略，自动重启策略这里也需要说下，我们可以在docker run 命令中指定容器的自动重启策略。</p> 
<p>docker run --restart=no # 禁止自动重启<br> docker run --restart=always # 表示容器在任何异常情况均重启：正常退出、停止、错误终止等<br> docker run --restart=on-failure:2 # 非正常状态时会进行重启，最大重启次数为2<br> docker run --restart=unless-stopped # 非正常状态退出就会重启，除非手动终止<br> 1<br> 2<br> 3<br> 4<br> 一般选用on-failure即可，当容器异常时进行重启，还可以额外指定重启次数</p> 
<p>SHELL 指定默认shell类型<br> 该默认类型仅仅只作用镜像创建过程中，当镜像创建完毕就失去了作用，只是为了接下来执行的shell命令声明执行环境使用的，比如我们可能需要执行bash类型的shell或者powershell等，需要我们作不同的声明。</p> 
<p>格式：SHELL ["executable", "parameters"]<br> 举例1：SHELL ["/bin/sh", "-c"]  # 默认的shell类型，-c参数表示后面可以跟直接执行的命令，而不需要去解析文件<br> 举例2：SHELL ["/bin/bash", "-c"] # 这也是比较常用的shell类型，很多镜像内部都是使用的这种shell<br> 举例3：SHELL ["powershell", "-Command"] # 这是powershell，常使用在window环境<br> 1<br> 2<br> 3<br> 4<br> 假如有如下的dockerfile</p> 
<p>...<br> SHELL ["/bin/bash", "-c"]<br> RUN echo "Hello Dockerfile"<br> ...<br> 1<br> 2<br> 3<br> 4<br> 则是相当于直接在bashe shell环境直接执行echo “Hello Dockerfile”。</p> 
<p>操作指令</p> 
<p>RUN 运行指定命令<br> RUN指令是一个核心指令支持两种格式，在这个方面他与ENTRYPOINT、CMD都是类似的，他们都支持JSON格式和shell。JSON格式一般是三方的可执行程序，使用RUN指令进行执行。shell的话就无需多说了，正常的shell执行都可以加到RUN的后面。需要注意的是每一个RUN指令都会创建一个容器，故可以融合的RUN指令尽量放一起，若是一行不便于阅读，可使用 \ 进行分行。</p> 
<p>格式1：RUN &lt;command&gt;<br> 举例1：<br> RUN apt-get update &amp;&amp; apt-get \<br> install -y package-name<br> # 当前格式下，后面直接跟各种shell命令即可<br> 格式2：RUN ["executable", "param1", "param2"]<br> 举例2：<br> RUN ["echo", "Hello, Docker!"]<br> # 当前格式下，第一个参数会解析成命令，之后的都会解析成参数，当前命令可以用于执行三方程序<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> CMD 启动容器时指定默认执行的命令<br> 给命令同ENTRYPOINT、RUN类似都可以运行shell、json两种类型的指令。他们三个的区别主要在于使用点不同。ENTRYPOINT为容器启动时的默认命令，RUN则是镜像创建过程中产生的中间容器指令，CMD则是新容器启动时会默认执行的指令。他们三者支持的命令都没有什么区别，只是使用点不同。</p> 
<p>格式1：CMD command<br> 举例1：<br> CMD echo "Hello, Docker!"<br> # 当前直接在shell环境下执行echo  "Hello, Docker!"</p> 
<p>格式2：CMD ["executable", "param1", "param2"]<br> 举例2：，<br> CMD ["echo", "Hello, Docker!"]<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> ADD 添加内容到镜像<br> 添加内容到镜像，这里其实也是复制，该功能与COPY基本类似，区别在于ADD支持URL地址信息的复制，同时支持复制目标未tar时的自动解压，不过一般如无特殊需要还是推荐使用COPY命令</p> 
<p>格式：ADD &lt;src&gt; &lt;dest&gt;<br> 举例1：ADD /usr/test.txt /apps/<br> 举例2：ADD https://example.com/app.jar /app/<br> # 注意若src是目录，则该目录是Dockerfile所在地址的相对路径，dest则是镜像内的路径，若是使用了WORKDIR，则是基于WORKDIR的相对路径。当然dest若是绝对路径则不受WORKDIR的影响<br> 1<br> 2<br> 3<br> 4<br> COPY 复制内容到镜像<br> COPY与ADD功能上类似，不过他的功能更简单，不能复制URL资源，不能解压tar，其他则与ADD没啥区别了，不过一般推荐还是使用COPY</p> 
<p>格式：COPY &lt;src&gt; &lt;dest&gt;<br> 举例：COPY app.py /app/<br> # src目录同样是Dockerfile的相对路径，dest同样是WORKDIR的相对路径<br> 1<br> 2<br> 3<br> 3.Dockerfile示例<br> 下面是一个典型的Dockerfile的示例</p> 
<p>FROM golang:l.9 as builder # 定义基础镜像的别名，注意该镜像具有go语言环境<br> RUN mkdir -p /go/src/test  # 在基础镜像builder中创建目录<br> WORKDIR /go/src/test # 将工作目录调整到这里<br> COPY main.go . # 将Dockerfile同目录下的main.go复制到当前目录下（WORKDIR）<br> RUN CGO_ENABLED=O GOOS=linux go build -o app # 在builder镜像里编译go程序，<br> FROM alpine:latest # 声明基础镜像，该FROM是最后一个，所以最终镜像是基于当前镜像创建的<br> RUN apk --no-cache add ca-certif cates # 安装通讯相关的软件包<br> WORKDIR /root/  # 声明工作目录<br> COPY from=builder /go/src/test/app . # 将第一步镜像内编译好的go程序文件复制到当前目录下<br> CMD [”. /app "] # 容器启动时执行应用程序启动命令<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 一般为了追求镜像的大小较为小，都会使用较小的镜像作为基础镜像，这样可以节约磁盘空间，所以上面的例子中编译镜像和运行镜像是两个。</p> 
<p>4.使用Dockerfile创建自己的镜像：docker build<br> 有了Dockerfile则需要依据该文件进行镜像的创建了，此时就需要docker build 命令了，他可以帮助我们将dockerfile描述的信息编译成镜像文件。编译成镜像后，该镜像存在于本地，我们使用docker run 或者 docer start均可以正常操作该镜像。</p> 
<p>格式：docker [image] build <br> 举例：docker build -f /apps/test/mdm.dockerfile . # -f 指定dockerfile，如不指定则默认在当前文件夹下找Dockerfile的文件 . 表示使用当前目录为工作目录，这属于shell的语法<br> # 常用参数<br> -t : 指定标签名，如 docker build -t test-image:1.0.0 <br> -f : 指定dockerfile，后跟dockerfile名称，如 docker build -f /apps/customer.dockerfile<br> --build-arg : 指定dockerfile中ARG指令的属性值，如 docker build --build-arg arg3="你好"<br> --env: 指定dockerfile中ENV指令的属性值，ENV声明的是环境变量。如 docker build --env arg1="你好"<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 其他参数详见下表：</p> 
<p>-add- host l 工 s t 添加自定义的主机名到 IP 庆射<br> -cache-from strings 使用指定镜像作为缓存源<br> -cgroup-parent string 继承的上层 cgroup<br> -compress 使用 gzip 来压缩创建上下文数据<br> -cpu-period int 分配的 CFS 调度器时长<br> -cpu-quota int CFS调度都总份额<br> -c, -cpu-shares int CPU权重<br> -cpuset-cpus str ng PU 允许使用的 PU<br> -cpuset-mems str ng 允许使用的内存<br> -disable-content-trust 不进行镜像校验，默认为真<br> -force-rm 删除中间过程的容器<br> -iidfile string 将镜像 ID 写入到文件<br> -isolation string 容器的隔离机制<br> -label list 配置镜像的元数据<br> -m, -memory bytes 限制使用内存盘<br> -memory-swap bytes 限制内存和缓存的总盐<br> -network string 指定 RUN 命令时的网络模式<br> -no-cache 建镜像 不适用缓存<br> -platform string 指定平台类型<br> -pull 总是尝试获取镜像的最新版本<br> -q, -quiet 不打印创建过程中的日志信息<br> -rm 创建成功后自动删除中间过程容器，默认为真<br> -security-opt strings 指定安全相关的选项<br> -shm-size bytes /dev/shm 的大小<br> -squash 将新创建的多层挤压放入到一层<br> -stream 持续获取创建的上下文<br> -t, -tag list 指定镜像的标签列表<br> -target string 指定创建的目标阶段<br> -ulim ulmit 指定 ulimit 的配</p> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 使用举例：</p> 
<p>docker build -t pcc/mdm-legal:13.0.0 -f ./mdm-legal.dockerfile .<br> # -t 指定标签名<br> # -f 指定dockerfile文件<br> # . 工作目录为当前目录<br> 1<br> 2<br> 3<br> 4<br> 5. “.dockerignore”文件<br> 在运行dockerfile文件时可能会有部分文件不想编译到镜像中去，我们可以使用.dockerignore文件进行忽略相关文件。改文件命名格式固定就是点加dockerignore。此外该文件需和dockerfile放在一个文件夹下，使用时无需显示指定，其他则没有要求。</p> 
<p>举例：<br> */temp* <br> */*/t emp* <br> tmp?<br> !README.md <br> # * 表示省略任意多字符<br> # ？表示省略一个字符<br> # ！表示忽略文件中不包含该文件，他经常配合*使用，来剔除个别无需忽略的 文件<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 五、docker使用常见问题<br> 1.docker的登录<br> 不登录其实并不影响我们从docker官网下载镜像，只是我们不登录便不能上传自己的镜像了，若是想要将自己的镜像上传到远端仓库则是需要登录的，登录页比较简单。</p> 
<p>docker login # 然后根据提示输入用户名和密码即可。<br> 1<br> 2.本地容器上传远端仓库<br> 一个容器运行很久以后有很多配置和插件已经装的和齐全不方便大变动，或者做的比较好，希望分享出去，此时就需要使用将本地容器打包成镜像传递到远端的功能了。这个过程需要三步</p> 
<p># 第一步：将本地容器打包成镜像<br> docker commit -a "作者" -m "备注信息" -p  容器ID/容器名 新镜像名 # 举例 docker commit 6qsdf89er9er88 mdm-xxl-job-admin:1.0.0, -p 创建镜像前暂停容器，一般别这么用<br> # 第二步：登录dockerhub<br> docker login [仓库地址] # 根据提示输入用户名密码即可 <br> # 第三步：标记本地镜像的远端信息，发送到远端<br> docker tag 本地镜像名 仓库地址/远端镜像名:tag # 标记本地镜像所属的远端仓库和镜像名<br> docker push 仓库地址/远端镜像名:tag # 将本地镜像推送到远端<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 如此便可以将容器传送到远端服务器了</p> 
<p>3.本地容器跨服务器传送<br> 其实有三种方法可以实现类似的作用：<br> 第一种：使用dockerfile构建镜像，这样更加方便容器的迁移<br> 第二种：使用上面说的方法，将镜像传送到仓库再从另一个服务器上下载也是可以的<br> 第三种：这里主要说的是第三种，将本地容器打包成进行，然后再压成tar包，再从三方服务器上加载即可，下面说说这种方式</p> 
<p>第一步：将本地容器打包成镜像<br> docker commit -a "作者" -m "备注信息" -p  容器ID/容器名 新镜像名 # 举例 docker commit 6qsdf89er9er88 mdm-xxl-job-admin:1.0.0, -p 创建镜像前暂停容器，一般<br> 第二步：将本地镜像打包成tar包<br> docker save -o /mdm-legal.tar 镜像ID/镜像名 # 举例 docker save -o /mdm-legal.tar 8iuwr8we6wer987865wr ，将镜像达成mdm-legal.tar包放在根目录下 ,-o 指定输出哪个文件<br> 第三步：将tar包传输到目标服务器，然后加载为镜像<br> scp /mdm-legal.tar root@ip:/ # 将tar包传送到目标服务器<br> docker load -i /mdm-legal.tar # 将tar包加载为镜像，-i指定输入<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 如此也可以实现将本地镜像实现跨服务器传输</p> 
<p>4.配置阿里云镜像加速<br> 详情请参考这篇文章：阿里云镜像加速</p> 
<p>5.端口映射问题<br> # 下面是创建并打开mysql容器的典型命令，其中-p便是作端口映射使用的，-p后面冒号左面是宿主机端口，后面则是容器的占用端口。<br> docker run -d -e MYSQL_ROOT_PASSWORD=password --name=mymysql -p 3306:3306 mysql:5.7 <br> 1<br> 2<br> 尤其需要注意宿主机端口是否放行了，若是不放行累死也是访问不到的，最开始可以先用telnet命令测试下端口是否可以正常访问，若是不支持telnet命令请看第5部分，telnet不通就可以查看防火墙了，请看第4部分。</p> 
<p>6.防火墙放行端口问题<br> 下面列出了防火墙的常用操作命令，以供参考。</p> 
<p>sudo systemctl status firewalld # 查看防火墙是否运行，若是运行会显示running<br> sudo firewall-cmd --list-ports #查看端口有没有被防火墙放行，若是没有对应端口则说明未放行。<br> sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent # 放行3306端口，然后一定要重启防火墙<br> sudo systemctl restart firewalld.service # 重启防火墙<br> sudo firewall-cmd --list-ports # 再次查看端口有没有放行成功，下面出现3306就表示成功了</p> 
<p># 部分参数解释<br> # –zone 用以标识该端口放行的范围<br> # --add-port=3306/tcp 标识端口与通讯协议<br> # --permanent 标识重启放行依然生效<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 7.容器不支持telnet命令<br> 参考这位大佬的文章：linux下安装telnet命令</p> 
<p>8.容器不支持ps命令<br> 以下是ps的安装命令</p> 
<p>apt-get update &amp;&amp; apt-get install procps<br> 1<br> 9.容器不支持vim命令<br> 以下是安装vim命令的命令</p> 
<p>apt-get update<br> apt-get install vim<br> ————————————————<br> 版权声明：本文为CSDN博主「归去来 兮」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/m0_46897923/article/details/120526549</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/28e0a56e6dec0fd47affad690c63d10d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图片怎么存储到数据库里</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3554a76b540355a61c225b389b6665cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">实习期间 回忆大学生活的碎碎念</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>