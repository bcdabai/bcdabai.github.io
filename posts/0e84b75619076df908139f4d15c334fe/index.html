<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode刷题顺序（新手入门） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode刷题顺序（新手入门）" />
<meta property="og:description" content="本刷题策略为leetcode官方的新手村策略，跟着主页官方的新手村策略刷题，按照每天刷三简单题或两中等题或一难题的速度刷题，每天预计花费1.5h
下面的顺序是探索卡中的顺序
数组 分为三部分
1.做好初始定义 2.运用基础算法思想 3.双索引技巧-对撞指针 4.双索引技巧-滑动窗口
1.做好初始定义 移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
解法 难点就是不复制原数组要原地修改，解法为设置一个res，记录前面的0的个数，每次插入时只要插入到nums[i - res]中即可
移除元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
解法 和移动零一样，只不过换成了判断是否等于val
删除有序数组中的重复项
给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
解法 利用双指针，j用来存储应该插入的下标，i用来遍历
删除有序数组中的重复项II
给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
解法 int slow = 2, fast = 2; while(fast &lt; n) { if(nums[slow - 2] !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0e84b75619076df908139f4d15c334fe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-13T11:30:16+08:00" />
<meta property="article:modified_time" content="2022-11-13T11:30:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode刷题顺序（新手入门）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本刷题策略为leetcode官方的新手村策略，跟着主页官方的新手村策略刷题，按照每天刷三简单题或两中等题或一难题的速度刷题，每天预计花费1.5h</p> 
<p>下面的顺序是探索卡中的顺序</p> 
<h2>数组</h2> 
<p>分为三部分</p> 
<p>1.做好初始定义 2.运用基础算法思想 3.双索引技巧-对撞指针 4.双索引技巧-滑动窗口</p> 
<h2>1.做好初始定义</h2> 
<p><a class="link-info" href="https://leetcode.cn/problems/move-zeroes/" rel="nofollow" title="移动零">移动零</a></p> 
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p> 
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p> 
<h4>解法</h4> 
<p>难点就是不复制原数组要原地修改，解法为设置一个res，记录前面的0的个数，每次插入时只要插入到nums[i - res]中即可</p> 
<p><a class="link-info" href="https://leetcode.cn/problems/remove-element/" rel="nofollow" title="移除元素">移除元素</a></p> 
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p> 
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p> 
<h4>解法</h4> 
<p>和移动零一样，只不过换成了判断是否等于val</p> 
<p><a class="link-info" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" rel="nofollow" title="删除有序数组中的重复项">删除有序数组中的重复项</a></p> 
<p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" rel="nofollow" title=" 原地"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p> 
<h4>解法</h4> 
<p>利用双指针，j用来存储应该插入的下标，i用来遍历</p> 
<p><a class="link-info" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/" rel="nofollow" title="删除有序数组中的重复项II">删除有序数组中的重复项II</a></p> 
<p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p> 
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p> 
<h4>解法</h4> 
<pre><code class="language-cpp">int slow = 2, fast = 2;
        while(fast &lt; n)
        {
            if(nums[slow - 2] != nums[fast]) nums[slow ++] = nums[fast];
            fast ++;
        }</code></pre> 
<h3>2.运用基础算法思想 </h3> 
<p><a class="link-info" href="https://leetcode.cn/problems/sort-colors/" rel="nofollow" title="颜色分类">颜色分类</a></p> 
<p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p> 
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p> 
<p>必须在不使用库的sort函数的情况下解决这个问题。且仅使用常数空间</p> 
<h4>解法</h4> 
<p>指针p0,指向0应该插入的末尾，指针p1指向1应该插入的末尾。剩下的都是2，但是需要注意的是，在插入0的时候，1的指针要做相应的改变</p> 
<pre><code class="language-cpp">        for(int i = 0; i &lt; n; i ++)
        {
            if(nums[i] == 1) swap(nums[i], nums[p1 ++]);
            else if(nums[i] == 0)
            {
                swap(nums[i], nums[p0]);
                if(p0 &lt; p1)//如果p0小于p1，则此时nums[i] = 1 nums[p0] = 0,
                //因为1的区间为p0 到p1,此时1区间的一个开头被吃掉了，要补上去
                {
                    swap(nums[p1], nums[i]);
                }
                p0 ++, p1 ++;
            }
        }</code></pre> 
<p><a class="link-info" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" rel="nofollow" title="数组中第K个最大的数">数组中第K个最大的数</a></p> 
<p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p> 
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p> 
<p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p> 
<h4>解法</h4> 
<p>利用快速排序的变种求，模板题</p> 
<p><a class="link-info" href="https://leetcode.cn/problems/merge-sorted-array/" rel="nofollow" title="合并两个有序数组">合并两个有序数组</a></p> 
<p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p> 
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p> 
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p> 
<h4>解法</h4> 
<p>难点在于利用常数个存储空间，我们采用从尾开始遍历的方式，插入到nums1的尾部，此时不存在冲突问题。</p> 
<h2>3.双索引技巧-对撞指针</h2> 
<p><a class="link-info" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/" rel="nofollow" title="两数之和 II - 输入有序数组">两数之和 II - 输入有序数组</a></p> 
<p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。</p> 
<h4>解法</h4> 
<p>双指针，一个指向头，一个指向尾，往中间遍历。这题居然是中等题。。。。。。</p> 
<p><a class="link-info" href="https://leetcode.cn/problems/valid-palindrome/" rel="nofollow" title="验证回文串">验证回文串</a></p> 
<p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p> 
<p>字母和数字都属于字母数字字符。</p> 
<h4>解法</h4> 
<p>难点就是要先移除所有的非字母数字</p> 
<p>这里使用了<strong>isalnum()</strong>函数，判断是否为数字或字符，<strong>tolower()</strong>函数把字符串转换成小写，存储在sgood中</p> 
<pre><code class="language-cpp">if(isalnum(ch)) sgood += tolower(ch);</code></pre> 
<p><a class="link-info" href="https://leetcode.cn/problems/reverse-vowels-of-a-string/" rel="nofollow" title="反转字符串中的元音字母">反转字符串中的元音字母</a></p> 
<p>给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。</p> 
<p>元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现。</p> 
<h4>解法</h4> 
<p>难点是存储元音字母进行判断，之前采用了set方式但是很不方便，还是字符串最快</p> 
<pre><code class="language-cpp">string yuan = "aeiouAEIOU";

 bool isVolwer(char a, string yuan)//判断是否是元音
    {
        int n = yuan.size();
        for(int i = 0; i &lt; n; i ++)
            if(a == yuan[i]) return true;
        return false;
    }</code></pre> 
<p><a class="link-info" href="https://leetcode.cn/problems/container-with-most-water/" rel="nofollow" title="盛最多水的容器">盛最多水的容器</a></p> 
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p> 
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p> 
<p>返回容器可以储存的最大水量。</p> 
<p><img alt="" height="569" src="https://images2.imgbox.com/37/a3/40HP4mOe_o.png" width="767"></p> 
<h4> 解法</h4> 
<p>左右指针，移动较短的那一边</p> 
<h2>双索引技巧-滑动窗口</h2> 
<p><a class="link-info" href="https://leetcode.cn/problems/minimum-size-subarray-sum/" rel="nofollow" title="长度最小的子数组">长度最小的子数组</a></p> 
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p> 
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p> 
<h4>解法</h4> 
<p>滑动窗口模板题</p> 
<pre><code class="language-cpp">        while(end &lt; n)
        {
            sum += nums[end ++];
            while(sum &gt;= target)
            {
                res = min(res, end - start);
                sum -= nums[start];
                start ++;
            }
        }</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/358298092b187c274c05a8f6f993b026/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mac oh-my-zsh更改弹出路径：change prompt path</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/316fbedf482a128a9768fc0bc8e31837/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js题库-3{留言板的制作？jQuery}</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>