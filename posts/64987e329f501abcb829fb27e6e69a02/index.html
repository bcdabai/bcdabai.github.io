<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>centos7 nbd 挂在qcow2或qcow，raw，虚机镜像，virsh，virt，使用qemu-nbd挂载qcow2镜像文件 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="centos7 nbd 挂在qcow2或qcow，raw，虚机镜像，virsh，virt，使用qemu-nbd挂载qcow2镜像文件" />
<meta property="og:description" content="基本原理 nbd（网络块设备: Network Block Device），利用qemu-nbd将qemu虚拟机镜像挂载到Linux上。
展开来讲，nbd可以将一个远程主机的磁盘空间，当作一个块设备来使用，就像一块硬盘一样。使用它,你可以很方便的将另一台服务器的硬盘空间,增加到本地服务器上。
NBD与NFS有所不同：NFS只是提供一个挂载点供客户端使用，客户端无法改变这个挂载点的分区格式；而NBD提供的是一个块设备，客户端可以把这个块设备格式化成各种类型的分区，更便于用户的使用。
NBD是一个内核模块，大部分Linux发行版都已包含它。
在centos中, 编译成模块NBD, 保存在 /lib/modules/$version/kernel/driver/block/
远程服务器是一段轻量级的守护进程代码，它提供对远程设备的访问，而且该守护进程并不需要运行在linux平台之上。本地操作系统必须是linux，而且要支持Linux内核NBD驱动，并且能够运行本地客户端进程。
图1.NBD在本地客户端代表远程资源
文件系统能被挂载到NBD上（上图），而且NBD设备也能够用来组成冗余磁盘阵列（RAID）。在本地Linux上挂载一个EXT2文件系统到NBD，其传输率要比在同样的远程机器上挂载一个NFS快。
操作步骤 1.加载NBD驱动 某些版本的 Linux 不加 max_part 参数会导致没有设备节点 /dev/nbd0p{1,2,3,4…} 等。用 kpartx 也不行。
查看有没有加载nbd模块 sudo lsmod |grep nbd
加载nbd模块 sudo modprobe nbd max_part=16
备注信息：查看Linux 模块信息（modinfo），例如查看nbd模块的参数【执行命令modinfo nbd】 。 加载后，在/dev/目录下，根据参数创建nbdxx块设备文件。
2. 连接 qemu-nbd qemu-nbd -c nbd设备路径 虚拟机镜像路径 [$ sudo qemu-nbd -c /dev/nbd0 centos.qcow2]
这里注意查看分区: sudo fdisk -l nbd设备[sudo fdisk -l /dev/nbd0]，可能虚拟机不止一个分区（一般还会有一个boot分区）
3.挂载 sudo mount nbd分区 挂载路径 [$ sudo mount /dev/nbd0p1 /mnt/test1 ]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/64987e329f501abcb829fb27e6e69a02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-06T09:58:52+08:00" />
<meta property="article:modified_time" content="2023-05-06T09:58:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">centos7 nbd 挂在qcow2或qcow，raw，虚机镜像，virsh，virt，使用qemu-nbd挂载qcow2镜像文件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>基本原理</h2> 
<p>nbd（网络块设备: Network Block Device），利用qemu-nbd将qemu虚拟机镜像挂载到<a href="https://so.csdn.net/so/search?q=Linux&amp;spm=1001.2101.3001.7020" title="Linux">Linux</a>上。<br> 　　展开来讲，nbd可以将一个远程主机的磁盘空间，当作一个块设备来使用，就像一块硬盘一样。使用它,你可以很方便的将另一台服务器的硬盘空间,增加到本地服务器上。<br> 　　NBD与NFS有所不同：NFS只是提供一个挂载点供客户端使用，客户端无法改变这个挂载点的分区格式；而NBD提供的是一个块设备，客户端可以把这个块设备格式化成各种类型的分区，更便于用户的使用。<br> 　　NBD是一个内核模块，大部分Linux发行版都已包含它。<br> 　　在centos中, 编译成模块NBD, 保存在 /lib/modules/$version/kernel/driver/block/<br> 　　远程服务器是一段轻量级的守护进程代码，它提供对远程设备的访问，而且该守护进程并不需要运行在linux平台之上。本地操作系统必须是linux，而且要支持Linux内核NBD驱动，并且能够运行本地客户端进程。</p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/e8/2b/tIK4KWs8_o.png" width="464"></p> 
<p></p> 
<p>图1.NBD在本地客户端代表远程资源</p> 
<p>文件系统能被挂载到NBD上（上图），而且NBD设备也能够用来组成冗余磁盘阵列（RAID）。在本地Linux上挂载一个EXT2文件系统到NBD，其传输率要比在同样的远程机器上挂载一个NFS快。</p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/a5/65/4d3iqMBG_o.png" width="580"></p> 
<p></p> 
<h2>操作步骤</h2> 
<h3><a name="t3"></a><a id="1NBD_18"></a>1.加载NBD驱动</h3> 
<p>某些版本的 Linux 不加 max_part 参数会导致没有设备节点 /dev/nbd0p{1,2,3,4…} 等。用 kpartx 也不行。</p> 
<p>查看有没有加载nbd模块 <code>sudo lsmod |grep nbd</code></p> 
<p>加载nbd模块 <code>sudo modprobe nbd max_part=16</code></p> 
<p>备注信息：查看Linux 模块信息（modinfo），例如查看nbd模块的参数【<strong>执行命令</strong><code>modinfo nbd</code>】 。 加载后，在/dev/目录下，根据参数创建nbdxx块设备文件。</p> 
<h3>2. 连接 qemu-nbd</h3> 
<p>qemu-nbd -c nbd设备路径 虚拟机镜像路径 [<code>$ sudo qemu-nbd -c /dev/nbd0 centos.qcow2</code>]<br> 这里<strong>注意查看分区</strong>: sudo fdisk -l nbd设备[<code>sudo fdisk -l /dev/nbd0</code>]，可能虚拟机不止一个分区（一般还会有一个boot分区）</p> 
<h4>3.挂载</h4> 
<p>sudo mount nbd分区 挂载路径 [<code>$ sudo mount /dev/nbd0p1 /mnt/test1</code> ]</p> 
<h3>4.解挂</h3> 
<p>sudo qemu-nbd -d nbd分区[<code>$ sudo qemu-nbd -d /dev/nbd0p1</code>]</p> 
<h2>虚机文件系统为LVM实例</h2> 
<h3><a name="t8"></a><a id="1_33"></a>1.加载驱动</h3> 
<blockquote> 
 <p><strong>#查看加载的nbd模块</strong><br> lsmod |grep nbd<br><strong>#加载nbd模块</strong><br> modprobe nbd max_part=16</p> 
</blockquote> 
<h3>2.连接qemu-nbd</h3> 
<p>云课堂中，从日志查看镜像路径 <code>vi /var/log/qemu/vmmagent.log</code></p> 
<blockquote> 
 <p><strong>#连接命令qemu-nbd -f qcow2 -c /dev/your/nbddev /image/path</strong><br> qemu-nbd -f qcow2 -c /dev/nbd9 /opt/lessons/images/local_img.qcow2<br><strong>#更新lvm分区    </strong><br>  </p> 
 <pre><code class="hljs">目的更新 这样之后的lv pv 就可以看到数据了
[root@git qcow2]# pvscan --cache
  pvscan[4100284] PV /dev/sda2 online.
  pvscan[4100284] PV /dev/nbd0p2 online.
  pvscan[4100284] PV /dev/sdb online.
  pvscan[4100284] PV /dev/sdc1 online.</code></pre> 
 <pre><code class="hljs">[root@git qcow2]# lvscan 
  ACTIVE            '/dev/vg500/lv500' [999.99 GiB] inherit
  ACTIVE            '/dev/centos/swap' [&lt;3.88 GiB] inherit
  ACTIVE            '/dev/centos/home' [&lt;45.12 GiB] inherit
  ACTIVE            '/dev/centos/root' [50.00 GiB] inherit
  ACTIVE            '/dev/cl/root' [&lt;91.10 GiB] inherit
  ACTIVE            '/dev/cl/swap' [7.89 GiB] inherit</code></pre> 
 <pre><code class="hljs">[root@git qcow2]# vgscan 
  Found volume group "vg500" using metadata type lvm2
  Found volume group "centos" using metadata type lvm2
  Found volume group "cl" using metadata type lvm2</code></pre> 
 <p></p> 
 <pre><code class="hljs">[root@git qcow2]# vgchange -a y
  1 logical volume(s) in volume group "vg500" now active
  3 logical volume(s) in volume group "centos" now active
  2 logical volume(s) in volume group "cl" now active</code></pre> 
 <p><br><strong>#查看新增文件系统结构</strong></p> 
 <pre><code class="hljs">[root@git qcow2]# lsblk -f
NAME            FSTYPE      LABEL                      UUID                                   MOUNTPOINT
sda                                                                                           
├─sda1          ext4                                   87145844-8dd1-4316-8389-2cc035e406ef   /boot
└─sda2          LVM2_member                            KfNUVk-UyRL-IewQ-w1oa-LT8d-l7Fa-pg3J54 
  ├─cl-root     xfs                                    8d0db36b-b9ef-4ca9-92e1-9c8c2f17c4ac   /
  └─cl-swap     swap                                   4c5b215c-33c1-47bc-9ebc-04627cf1116f   [SWAP]
sdb             LVM2_member                            akE5ZB-G2Py-GjfU-8DEU-QEFM-ElW4-On8PKP 
└─vg500-lv500   xfs                                    1a213e4a-90ce-4d04-940d-bf059f2b92dd   /service
sdc                                                                                           
└─sdc1          LVM2_member                            Uq6lAF-nIRc-joym-byQk-KHeJ-dNiA-gw7oW9 
  └─vg500-lv500 xfs                                    1a213e4a-90ce-4d04-940d-bf059f2b92dd   /service
sr0             iso9660     CentOS-8-1-1911-x86_64-dvd 2020-01-03-21-42-40-00                 
nbd0                                                                                          
├─nbd0p1        xfs                                    2785a74c-1893-47c4-adde-59a746f71c24   /service/qcow2/boot
└─nbd0p2        LVM2_member                            XKIwmd-DUL5-BsSQ-dH1o-DDJh-PFhg-zF8aGG 
  ├─centos-swap swap                                   db9cfc96-3893-4e27-a777-5b33f73ba5ff   
  ├─centos-home xfs                                    50ffc57a-0986-4fd5-9ca2-b2869fe60aad   
  └─centos-root xfs                                    4cb93a60-5ff5-4ea0-bf1c-dbcc90d6acbd  </code></pre> 
 <p></p> 
</blockquote> 
<p>        </p> 
<h3>3.挂载lvm分区</h3> 
<blockquote> 
 <p><strong>#挂载分区mount /dev/vgname/lvname /your/mount/point</strong><br> [root@git qcow2]# mount /dev/centos/home sys/home/<br> [root@git qcow2]# mount /dev/centos/root sys/root</p> 
</blockquote> 
<h3>4.卸载盘符</h3> 
<blockquote> 
 <p><strong>#取消挂载</strong><br> umount sys/home/</p> 
 <p>umount sys/root<br> vgchange -an<br><strong>#断开NBD连接qemu-nbd -d /dev/your/nbddev</strong><br> qemu-nbd -d /dev/nbd9<br> pvscan --cache</p> 
</blockquote> 
<h2>虚机文件系统为非LVM</h2> 
<blockquote> 
 <p><strong>#连接镜像</strong><br> qemu-nbd -f qcow2 -c /dev/your/nbddev /image/path<br><strong>#查看新增文件系统结构</strong><br> lsblk -f<br><strong>#挂载分区</strong><br> mount /dev/[yournbddev][pn] /your/mount/point # 其中pn代表你要挂载的时镜像里的分区n<br><strong>#卸载分区</strong><br> umount /your/mount/point<br><strong>#断开nbd连接</strong><br> qemu-nbd -d /dev/your/nbddev</p> 
</blockquote> 
<h2>虚机文件系统为NTFS</h2> 
<blockquote> 
 <p><strong>#连接镜像</strong><br> qemu-nbd -f qcow2 -c /dev/your/nbddev /image/path<br> lsblk -f #查看新增文件系统结构</p> 
 <p><strong>#挂载分区</strong><br> mount -t ntfs-3g /dev/[yournbddev][pn] /your/mount/point # 其中pn代表你要挂载的时镜像里的分区n</p> 
 <p><strong>#卸载分区</strong><br> umount /your/mount/point</p> 
 <p><strong>#断开nbd连接</strong><br> qemu-nbd -d /dev/your/nbddev</p> 
</blockquote> 
<p><strong>注意</strong></p> 
<ol><li>一般如果虚机在运行中突然断电关机（比如直接杀死qemu进程或者用virsh destroy命令关闭），此时虚机文件系统可能损坏，这时候直接mount一般会出错，建议用-o ro,norecovery选项挂载</li><li>在卸载过程中需要考虑是否有进程正在占用文件，一般用fuser -k</li><li>注意mount和umount命令的用法</li></ol> 
<p><a href="https://www.cnblogs.com/hugetong/p/5903105.html" rel="nofollow" title="挂载qcow2文件，qcow2里边还有个lvm">挂载qcow2文件，qcow2里边还有个lvm</a><br><a href="https://www.cnblogs.com/doscho/p/7112916.html" rel="nofollow" title="linux nbd &amp; qemu-nbd">linux nbd &amp; qemu-nbd</a><br><a href="https://manpages.debian.org/testing/qemu-utils/qemu-nbd.8.en.html" rel="nofollow" title="QEMU-NBD">QEMU-NBD</a><br><a href="https://blog.csdn.net/cnyyx/article/details/33732709" title="通过qemu-nbd方式挂载qcow2镜像格式">通过qemu-nbd方式挂载qcow2镜像格式</a><br><a href="http://lzw.me/a/lvm-nbd-remote-mirror.html" rel="nofollow" title="基于LVM和NBD实现网络远程LVM镜像方法">基于LVM和NBD实现网络远程LVM镜像方法</a><br><a href="https://www.thegeekdiary.com/how-to-mount-guest-qcow2-virtual-disk-image-containing-lvm-on-kvm-host-machine/" rel="nofollow" title="How to Mount Guest Qcow2 Virtual disk Image containing LVM on KVM Host Machine">How to Mount Guest Qcow2 Virtual disk Image containing LVM on KVM Host Machine</a></p> 
<p>[root@localhost linux-3.10.63]# cat ../../../readme <br> https://blog.51cto.com/mshxuyi/5857760<br> https://blog.csdn.net/weixin_42097108/article/details/111414501   错误解决<br> １、nbd 模块未安装 </p> 
<p>登录后复制 <br> [root@localhost ~]# modprobe nbd<br> modprobe: FATAL: Module nbd not found.</p> 
<p>２、查看 linux 版本</p> 
<p>登录后复制 <br> [root@localhost ~]# cat /etc/redhat-release<br> CentOS Linux release 7.6.1810 (Core) 　　#查看系统版本</p> 
<p>[root@localhost ~]# uname -r    　　　　　#查看linux的内核信息<br> 3.10.0-957.el7.x86_64</p> 
<p>３、安装相关包</p> 
<p>yum install kernel-devel kernel-headers elfutils-libelf-devel　gcc+ gcc-c++</p> 
<p>４、下载内核包</p> 
<p>登录后复制 <br> http://vault.centos.org/7.6.1810/os/Source/SPackages/kernel-3.10.0-957.el7.src.rpm</p> 
<p>#根据自己的系统版本去下载<br> #7.6.1810 　为redhat-release　系统版本<br> #3.10.0-957.el7　　为uname -r  内核信息</p> 
<p><br> ５、编译</p> 
<p>登录后复制 <br> rpm -ivh kernel-3.10.0-957.el7.src.rpm</p> 
<p>cd rpmbuild/SOURCES/</p> 
<p>#解压 -C 指定目录　/usr/src/kernels<br> tar jxvf linux-3.10.0-957.el7.tar.xz -C /usr/src/kernels/</p> 
<p>#解压后生成两个文件<br> ll /usr/src/kernels/<br> drwxr-xr-x. 22 root root 4096 9月   6 08:07 3.10.0-957.27.2.el7.x86_64<br> drwxrwxr-x. 24 root root 4096 9月   6 08:17 linux-3.10.0-957.el7</p> 
<p>编译</p> 
<p>登录后复制 <br> cd /usr/src/kernels/linux-3.10.0-957.el7</p> 
<p>#删除所有编译生成文件，内核配置文件<br> make mrproper</p> 
<p>cp /usr/src/kernels/3.10.0-957.27.2.el7.x86_64/Module.symvers ./</p> 
<p>cp /boot/config-3.10.0-957.el7.x86_64 ./.config</p> 
<p>#备份当前.config文件为.config.old<br> make oldconfig</p> 
<p>make prepare</p> 
<p>make scripts</p> 
<p>６、编译 </p> 
<p>登录后复制 <br> make CONFIG_BLK_DEV_NBD=m M=drivers/block</p> 
<p>错误： </p> 
<p>登录后复制 <br> drivers/block/nbd.c: 在函数‘__nbd_ioctl’中:<br> drivers/block/nbd.c:619:19: 错误：‘REQ_TYPE_SPECIAL’未声明(在此函数内第一次使用)<br>    sreq.cmd_type = REQ_TYPE_SPECIAL;<br>                    ^<br> drivers/block/nbd.c:619:19: 附注：每个未声明的标识符在其出现的函数内只报告一次<br> make[1]: *** [drivers/block/nbd.o] 错误 1<br> make: *** [_module_drivers/block] 错误 2</p> 
<p>解决：</p> 
<p>vi drivers/block/nbd.c</p> 
<p>//sreq.cmd_type = REQ_TYPE_SPECIAL;<br> sreq.cmd_type = 7;　　#修改为7</p> 
<p>#重新执行一次<br> make CONFIG_BLK_DEV_NBD=m M=drivers/block<br><br>  ７、复制文件</p> 
<p>cp drivers/block/nbd.ko /lib/modules/3.10.0-957.el7.x86_64/kernel/drivers/block/</p> 
<p>depmod -a<br> ８、查看模块</p> 
<p>登录后复制 <br> [root@localhost linux-3.10.0-957.el7]# modinfo nbd<br> filename:       /lib/modules/3.10.0-957.el7.x86_64/kernel/drivers/block/nbd.ko<br> license:        GPL<br> description:    Network Block Device<br> retpoline:      Y<br> rhelversion:    7.6<br> srcversion:     EDE909A294AC5FE08E81957<br> depends:        <br> vermagic:       3.10.0 SMP mod_unload modversions <br> parm:           nbds_max:number of network block devices to initialize (default: 16) (int)<br> parm:           max_part:number of partitions per device (default: 0) (int)<br> parm:           debugflags:flags for controlling debug output (int)<br>  </p> 
<p></p> 
<h2 id="articleContentId">编译内核出现的问题解决办法</h2> 
<p>1.<strong>cc1: error: code model kernel does not support PIC mode</strong></p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/cf/5f/q2IalW6H_o.png"></p> 
<p> 2<br> include/linux/compiler-gcc.h:106:1: fatal error: linux/compiler-gcc7.h: 没有那个文件或目录<br> 直接将gcc4重命名为gcc7<br> mv include/linux/compiler-gcc4.h include/linux/compiler-gcc7.h<br>  </p> 
<p></p> 
<p>3.li@li-vir:~/dq/drivers/hello3$ insmod hello.ko<br> insmod: ERROR: could not insert module hello.ko: Operation not permitted</p> 
<p>4.</p> 
<p>insmod: ERROR: could not insert module hello.ko: Invalid module format</p> 
<blockquote> 
 <p>这里是引用<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/2e/ad/MQbDbDUc_o.png"><br> 版本不对，<br> 使用uname -r查看一下<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/d2/20/g3m5CwNO_o.png"><br> make时要确保一致</p> 
</blockquote> 
<p>方法1 挂在qcow2</p> 
<p></p> 
<p>1. 加载 nbd 驱动<br> 某些版本的 linux 不加 max_part 参数会导致没有没有设备节点 /dev/nbd0p{1,2,3,4…} 等. 用 kpartx 也不行.</p> 
<p>$ sudo modprobe nbd max_part=8<br> 备注信息：查看Linux 模块信息（modinfo），例如查看nbd模块的参数</p> 
<blockquote> 
 <p>$ modinfo nbd<br> filename:       /lib/modules/3.14.12/kernel/drivers/block/nbd.ko<br> license:        GPL<br> description:    Network Block Device<br> srcversion:     910DE7DFCE8A0AE76D3D428<br> depends:        <br> intree:         Y<br> vermagic:       3.14.12 SMP mod_unload modversions <br> parm:           nbds_max:number of network block devices to initialize (default: 16) (int)<br> parm:           max_part:number of partitions per device (default: 0) (int)<br> parm:           debugflags:flags for controlling debug output (int)</p> 
</blockquote> 
<h4 id="sec-5-1">2.连接 qemu-nbd</h4> 
<pre><code>$ sudo qemu-nbd -c /dev/nbd0 centos.qcow2</code></pre> 
<blockquote> 
 <p>查看分区:</p> 
 <p>$ sudo fdisk -l /dev/nbd0</p> 
 <p>Disk /dev/nbd0: 10.7 GB, 10737418240 bytes<br> 255 heads, 63 sectors/track, 1305 cylinders, total 20971520 sectors<br> Units = sectors of 1 * 512 = 512 bytes<br> Sector size (logical/physical): 512 bytes / 512 bytes<br> I/O size (minimum/optimal): 512 bytes / 512 bytes<br> Disk identifier: 0x0005d1fd</p> 
 <p>     Device Boot      Start         End      Blocks   Id  System<br> /dev/nbd0p1   *        2048     1026047      512000   83  Linux<br> /dev/nbd0p2         1026048    20971519     9972736   8e  Linux LVM</p> 
</blockquote> 
<p></p> 
<p>vgdisplay</p> 
<pre><code>$ sudo lvdisplay</code></pre> 
<blockquote> 
 <p> --- Logical volume ---<br>   LV Name                /dev/VolGroup/lv_root<br>   VG Name                VolGroup<br>   LV UUID                v60jyE-1lDm-7dMW-hkVf-YWBH-OKXI-ySHDkb<br>   LV Write Access        read/write<br>   LV Status              NOT available<br>   LV Size                8.51 GiB<br>   Current LE             2178<br>   Segments               1<br>   Allocation             inherit<br>   Read ahead sectors     auto<br>    <br>   --- Logical volume ---<br>   LV Name                /dev/VolGroup/lv_swap<br>   VG Name                VolGroup<br>   LV UUID                b1BctN-vPtc-8n6F-tokb-75pN-w34N-HXG1cB<br>   LV Write Access        read/write<br>   LV Status              NOT available<br>   LV Size                1.00 GiB<br>   Current LE             256<br>   Segments               1<br>   Allocation             inherit<br>   Read ahead sectors     auto<br>  </p> 
</blockquote> 
<p>Active VolGroup</p> 
<p></p> 
<pre><code>$ sudo vgchange -a y VolGroup</code></pre> 
<p>mount vg</p> 
<p></p> 
<pre><code>$ sudo mount /dev/VolGroup/lv_root /mnt/test2</code></pre> 
<p></p> 
<h4>3.挂载</h4> 
<p></p> 
<pre><code>$ sudo mount /dev/nbd0p1 /mnt/test1</code></pre> 
<h4>4.umount disconnect</h4> 
<p></p> 
<pre><code>$ sudo mount /dev/nbd0p1 /mnt/test1
$ sudo qemu-nbd -d /dev/nbd0p1</code></pre> 
<p> 方法2 挂在qcow2</p> 
<h3>方法二：libguestfs</h3> 
<h4><a name="t6"></a><a id="1libguestfs_46"></a>1.安装libguestfs工具</h4> 
<pre><code>$ sudo apt install libguestfs-tools </code></pre> 
<h4>2.挂载磁盘镜像中的分区到挂载点</h4> 
<p>语法：<code>guestmount -a 镜像文件 -m 镜像文件内包含的某个分区 [选项] 挂载点</code></p> 
<blockquote> 
 <p>$ sudo mkdir /mnt/a                                                  #创建挂载点目录    <br> sudo guestmount -a /XXX/XXX/imgname.qcow2  -m /dev/sda1 /mnt/a      #尝试挂载/dev/sda分区，将提示有两个有效的分区/dev/sda1(/boot)和/dev/sda2(/root),<br> libguestfs: error: mount_options: mount exited with status 32: mount: /sysroot: wrong fs type, bad option, bad superblock on /dev/sda, missing codepage or helper program, or other error.<br> guestmount: ‘/dev/sda’ could not be mounted.<br> guestmount: Did you mean to mount one of these filesystems?<br> guestmount:     /dev/sda1 (vfat)<br> guestmount:     /dev/sda2 (ext4)    <br> $ sudo guestmount -a /XXX/XXX/imgname.qcow2  -m /dev/sda2 /mnt/a        #将磁盘镜像中包含的/dev/sda2分区挂载到/mnt/a目录<br> sudo ls /mnt/a<br> bin  boot  dev    etc  home  lib    lib64  media  mnt  opt    proc  root  run  sbin  srv  sys  tmp  usr  var<br>  </p> 
</blockquote> 
<p><strong>也可以通过-i参数替代-m来实现自动挂载有效分区</strong></p> 
<blockquote> 
 <p>$ sudo mkdir /mnt/a                                                      #创建挂载点目录    <br> $ sudo guestmount -a /XXX/XXX/imgname.qcow2  -i /mnt/a                    #将自动将磁盘镜像中最有效的/dev/sda2分区挂载到/mnt/a目录<br> sudo ls /mnt/a<br> bin  boot  dev    etc  home  lib    lib64  media  mnt  opt    proc  root  run  sbin  srv  sys  tmp  usr  var<br>  </p> 
</blockquote> 
<h4>3.取消挂载</h4> 
<pre><code>$ sudo guestunmount /mnt/a
</code></pre> 
<ul><li>1</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ffa9ab833cc8c2eabb85cbde30603698/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何使用 SigNoz 快速搭建一个可观测系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e4794786debfe73993ac572cbc05b83/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mybatisplus-【3/3】高级操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>