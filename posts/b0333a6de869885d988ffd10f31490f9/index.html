<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入探究ASP.NET Core读取Request.Body的正确方式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入探究ASP.NET Core读取Request.Body的正确方式" />
<meta property="og:description" content="前言 相信大家在使用ASP.NET Core进行开发的时候，肯定会涉及到读取Request.Body的场景，毕竟我们大部分的POST请求都是将数据存放到Http的Body当中。因为笔者日常开发所使用的主要也是ASP.NET Core所以笔者也遇到这这种场景，关于本篇文章所套路的内容，来自于在开发过程中我遇到的关于Request.Body的读取问题。在之前的使用的时候，基本上都是借助搜索引擎搜索的答案，并没有太关注这个，发现自己理解的和正确的使用之间存在很大的误区。故有感而发，便写下此文，以作记录。学无止境，愿与君共勉。
常用读取方式 当我们要读取Request Body的时候，相信大家第一直觉和笔者是一样的，这有啥难的，直接几行代码写完，这里我们模拟在Filter中读取Request Body，在Action或Middleware或其他地方读取类似，有Request的地方就有Body，如下所示
public override void OnActionExecuting(ActionExecutingContext context) { //在ASP.NET Core中Request Body是Stream的形式 StreamReader stream = new StreamReader(context.HttpContext.Request.Body); string body = stream.ReadToEnd(); _logger.LogDebug(&#34;body content:&#34; &#43; body); base.OnActionExecuting(context); } 写完之后，也没多想，毕竟这么常规的操作，信心满满，运行起来调试一把，发现直接报一个这个错System.InvalidOperationException: Synchronous operations are disallowed. Call ReadAsync or set AllowSynchronousIO to true instead.大致的意思就是同步操作不被允许，请使用ReadAsync的方式或设置AllowSynchronousIO为true。虽然没说怎么设置AllowSynchronousIO，不过我们借助搜索引擎是我们最大的强项。
同步读取 首先我们来看设置AllowSynchronousIO为true的方式，看名字也知道是允许同步IO，设置方式大致有两种，待会我们会通过源码来探究一下它们直接有何不同，我们先来看一下如何设置AllowSynchronousIO的值。第一种方式是在ConfigureServices中配置，操作如下
services.Configure&lt;KestrelServerOptions&gt;(options =&gt; { options.AllowSynchronousIO = true; }); 这种方式和在配置文件中配置Kestrel选项配置是一样的只是方式不同，设置完之后即可，运行不在报错。还有一种方式，可以不用在ConfigureServices中设置，通过IHttpBodyControlFeature的方式设置，具体如下
public override void OnActionExecuting(ActionExecutingContext context) { var syncIOFeature = context.HttpContext.Features.Get&lt;IHttpBodyControlFeature&gt;(); if (syncIOFeature != null) { syncIOFeature." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b0333a6de869885d988ffd10f31490f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-23T18:08:02+08:00" />
<meta property="article:modified_time" content="2022-04-23T18:08:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入探究ASP.NET Core读取Request.Body的正确方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>相信大家在使用ASP.NET Core进行开发的时候，肯定会涉及到读取<code>Request.Body</code>的场景，毕竟我们大部分的POST请求都是将数据存放到<code>Http</code>的<code>Body</code>当中。因为笔者日常开发所使用的主要也是ASP.NET Core所以笔者也遇到这这种场景，关于本篇文章所套路的内容，来自于在开发过程中我遇到的关于<code>Request.Body</code>的读取问题。在之前的使用的时候，基本上都是借助搜索引擎搜索的答案，并没有太关注这个，发现自己理解的和正确的使用之间存在很大的误区。故有感而发，便写下此文，以作记录。学无止境，愿与君共勉。</p> 
<h3><a id="_3"></a>常用读取方式</h3> 
<p>当我们要读取<code>Request Body</code>的时候，相信大家第一直觉和笔者是一样的，这有啥难的，直接几行代码写完，这里我们模拟在<code>Filter</code>中读取<code>Request Body</code>，在<code>Action</code>或<code>Middleware</code>或其他地方读取类似，有<code>Request</code>的地方就有<code>Body</code>，如下所示</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnActionExecuting</span><span class="token punctuation">(</span><span class="token class-name">ActionExecutingContext</span> context<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//在ASP.NET Core中Request Body是Stream的形式</span>
    <span class="token class-name">StreamReader</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">string</span></span> body <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">ReadToEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _logger<span class="token punctuation">.</span><span class="token function">LogDebug</span><span class="token punctuation">(</span><span class="token string">"body content:"</span> <span class="token operator">+</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnActionExecuting</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>写完之后，也没多想，毕竟这么常规的操作，信心满满，运行起来调试一把，发现直接报一个这个错<code>System.InvalidOperationException: Synchronous operations are disallowed. Call ReadAsync or set AllowSynchronousIO to true instead</code>.大致的意思就是同步操作不被允许，请使用<code>ReadAsync</code>的方式或设置<code>AllowSynchronousIO</code>为<code>true</code>。虽然没说怎么设置<code>AllowSynchronousIO</code>，不过我们借助搜索引擎是我们最大的强项。</p> 
<h3><a id="_19"></a>同步读取</h3> 
<p>首先我们来看设置<code>AllowSynchronousIO</code>为<code>true</code>的方式，看名字也知道是允许同步IO，设置方式大致有两种，待会我们会通过源码来探究一下它们直接有何不同，我们先来看一下如何设置<code>AllowSynchronousIO</code>的值。第一种方式是在<code>ConfigureServices</code>中配置，操作如下</p> 
<pre><code class="prism language-csharp">services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Configure</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>KestrelServerOptions<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span>options <span class="token operator">=&gt;</span>
<span class="token punctuation">{<!-- --></span>
    options<span class="token punctuation">.</span>AllowSynchronousIO <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这种方式和在配置文件中配置<code>Kestrel</code>选项配置是一样的只是方式不同，设置完之后即可，运行不在报错。还有一种方式，可以不用在<code>ConfigureServices</code>中设置，通过<code>IHttpBodyControlFeature</code>的方式设置，具体如下</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnActionExecuting</span><span class="token punctuation">(</span><span class="token class-name">ActionExecutingContext</span> context<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name"><span class="token keyword">var</span></span> syncIOFeature <span class="token operator">=</span> context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Features<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Get</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>IHttpBodyControlFeature<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>syncIOFeature <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        syncIOFeature<span class="token punctuation">.</span>AllowSynchronousIO <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">StreamReader</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">string</span></span> body <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">ReadToEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _logger<span class="token punctuation">.</span><span class="token function">LogDebug</span><span class="token punctuation">(</span><span class="token string">"body content:"</span> <span class="token operator">+</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnActionExecuting</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这种方式同样有效，通过这种方式操作，不需要每次读取<code>Body</code>的时候都去设置，只要在准备读取<code>Body</code>之前设置一次即可。这两种方式都是去设置<code>AllowSynchronousIO</code>为<code>true</code>，但是我们需要思考一点，微软为何设置<code>AllowSynchronousIO</code>默认为<code>false</code>，说明微软并不希望我们去同步读取<code>Body</code>。通过查找资料得出了这么一个结论</p> 
<p><code>Kestrel</code>：默认情况下禁用 <code>AllowSynchronousIO</code>（同步IO），线程不足会导致应用崩溃，而同步I/O API（例如<code>HttpRequest.Body.Read</code>）是导致线程不足的常见原因。</p> 
<p>由此可以知道，这种方式虽然能解决问题，但是性能并不是不好，微软也不建议这么操作，当程序流量比较大的时候，很容易导致程序不稳定甚至崩溃。</p> 
<h3><a id="_52"></a>异步读取</h3> 
<p>通过上面我们了解到微软并不希望我们通过设置<code>AllowSynchronousIO</code>的方式去操作，因为会影响性能。那我们可以使用异步的方式去读取，这里所说的异步方式其实就是使用<code>Stream</code>自带的异步方法去读取，如下所示</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnActionExecuting</span><span class="token punctuation">(</span><span class="token class-name">ActionExecutingContext</span> context<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">StreamReader</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">string</span></span> body <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">ReadToEndAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _logger<span class="token punctuation">.</span><span class="token function">LogDebug</span><span class="token punctuation">(</span><span class="token string">"body content:"</span> <span class="token operator">+</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnActionExecuting</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>就这么简单，不需要额外设置其他的东西，仅仅通过<code>ReadToEndAsync</code>的异步方法去操作。ASP.NET Core中许多操作都是异步操作，甚至是过滤器或中间件都可以直接返回<code>Task</code>类型的方法，因此我们可以直接使用异步操作</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">OnActionExecutionAsync</span><span class="token punctuation">(</span><span class="token class-name">ActionExecutingContext</span> context<span class="token punctuation">,</span> <span class="token class-name">ActionExecutionDelegate</span> next<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">StreamReader</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">string</span></span> body <span class="token operator">=</span> <span class="token keyword">await</span> stream<span class="token punctuation">.</span><span class="token function">ReadToEndAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _logger<span class="token punctuation">.</span><span class="token function">LogDebug</span><span class="token punctuation">(</span><span class="token string">"body content:"</span> <span class="token operator">+</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这两种方式的操作优点是不需要额外设置别的，只是通过异步方法读取即可，也是我们比较推荐的做法。比较神奇的是我们只是将<code>StreamReader</code>的<code>ReadToEnd</code>替换成<code>ReadToEndAsync</code>方法就皆大欢喜了，有没有感觉到比较神奇。当我们感到神奇的时候，是因为我们对它还不够了解，接下来我们就通过源码的方式，一步一步的揭开它神秘的面纱。</p> 
<h3><a id="_79"></a>重复读取</h3> 
<p>上面我们演示了使用同步方式和异步方式读取<code>RequestBody</code>，但是这样真的就可以了吗？其实并不行，这种方式每次请求只能读取一次正确的<code>Body</code>结果，如果继续对<code>RequestBody</code>这个<code>Stream</code>进行读取，将读取不到任何内容，首先来举个例子</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">OnActionExecutionAsync</span><span class="token punctuation">(</span><span class="token class-name">ActionExecutingContext</span> context<span class="token punctuation">,</span> <span class="token class-name">ActionExecutionDelegate</span> next<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">StreamReader</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">string</span></span> body <span class="token operator">=</span> <span class="token keyword">await</span> stream<span class="token punctuation">.</span><span class="token function">ReadToEndAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _logger<span class="token punctuation">.</span><span class="token function">LogDebug</span><span class="token punctuation">(</span><span class="token string">"body content:"</span> <span class="token operator">+</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">StreamReader</span> stream2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">string</span></span> body2 <span class="token operator">=</span> <span class="token keyword">await</span> stream2<span class="token punctuation">.</span><span class="token function">ReadToEndAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _logger<span class="token punctuation">.</span><span class="token function">LogDebug</span><span class="token punctuation">(</span><span class="token string">"body2 content:"</span> <span class="token operator">+</span> body2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的例子中<code>body</code>里有正确的<code>RequestBody</code>的结果，但是<code>body2</code>中是空字符串。这个情况是比较糟糕的，为啥这么说呢？如果你是在<code>Middleware</code>中读取的<code>RequestBody</code>，而这个中间件的执行是在模型绑定之前，那么将会导致模型绑定失败，因为模型绑定有的时候也需要读取<code>RequestBody</code>获取<code>http</code>请求内容。至于为什么会这样相信大家也有了一定的了解，因为我们在读取完<code>Stream</code>之后，此时的<code>Stream</code>指针位置已经在<code>Stream</code>的结尾处，即<code>Position</code>此时不为<code>0</code>，而<code>Stream</code>读取正是依赖<code>Position</code>来标记外部读取<code>Stream</code>到啥位置，所以我们再次读取的时候会从结尾开始读，也就读取不到任何信息了。所以我们要想重复读取<code>RequestBody</code>那么就要再次读取之前重置<code>RequestBody</code>的<code>Position</code>为<code>0</code>，如下所示</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">OnActionExecutionAsync</span><span class="token punctuation">(</span><span class="token class-name">ActionExecutingContext</span> context<span class="token punctuation">,</span> <span class="token class-name">ActionExecutionDelegate</span> next<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">StreamReader</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">string</span></span> body <span class="token operator">=</span> <span class="token keyword">await</span> stream<span class="token punctuation">.</span><span class="token function">ReadToEndAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _logger<span class="token punctuation">.</span><span class="token function">LogDebug</span><span class="token punctuation">(</span><span class="token string">"body content:"</span> <span class="token operator">+</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//或者使用重置Position的方式 context.HttpContext.Request.Body.Position = 0;</span>
    <span class="token comment">//如果你确定上次读取完之后已经重置了Position那么这一句可以省略</span>
    context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Seek</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SeekOrigin<span class="token punctuation">.</span>Begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">StreamReader</span> stream2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">string</span></span> body2 <span class="token operator">=</span> <span class="token keyword">await</span> stream2<span class="token punctuation">.</span><span class="token function">ReadToEndAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//用完了我们尽量也重置一下，自己的坑自己填</span>
    context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Seek</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SeekOrigin<span class="token punctuation">.</span>Begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    _logger<span class="token punctuation">.</span><span class="token function">LogDebug</span><span class="token punctuation">(</span><span class="token string">"body2 content:"</span> <span class="token operator">+</span> body2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>写完之后，开开心心的运行起来看一下效果，发现报了一个错<code>System.NotSupportedException: Specified method is not supported.at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream.Seek(Int64 offset, SeekOrigin origin)</code>大致可以理解起来不支持这个操作，至于为啥，一会解析源码的时候咱们一起看一下。说了这么多，那到底该如何解决呢？也很简单，微软知道自己刨下了坑，自然给我们提供了解决办法，用起来也很简单就是加<code>EnableBuffering</code></p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">OnActionExecutionAsync</span><span class="token punctuation">(</span><span class="token class-name">ActionExecutingContext</span> context<span class="token punctuation">,</span> <span class="token class-name">ActionExecutionDelegate</span> next<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//操作Request.Body之前加上EnableBuffering即可</span>
    context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span><span class="token function">EnableBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">StreamReader</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">string</span></span> body <span class="token operator">=</span> <span class="token keyword">await</span> stream<span class="token punctuation">.</span><span class="token function">ReadToEndAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _logger<span class="token punctuation">.</span><span class="token function">LogDebug</span><span class="token punctuation">(</span><span class="token string">"body content:"</span> <span class="token operator">+</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>

    context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Seek</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SeekOrigin<span class="token punctuation">.</span>Begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">StreamReader</span> stream2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//注意这里！！！我已经使用了同步读取的方式</span>
    <span class="token class-name"><span class="token keyword">string</span></span> body2 <span class="token operator">=</span> stream2<span class="token punctuation">.</span><span class="token function">ReadToEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Seek</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SeekOrigin<span class="token punctuation">.</span>Begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    _logger<span class="token punctuation">.</span><span class="token function">LogDebug</span><span class="token punctuation">(</span><span class="token string">"body2 content:"</span> <span class="token operator">+</span> body2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过添加<code>Request.EnableBuffering()</code>我们就可以重复的读取<code>RequestBody</code>了，看名字我们可以大概的猜出来，他是和缓存<code>RequestBody</code>有关，需要注意的是<code>Request.EnableBuffering()</code>要加在准备读取<code>RequestBody</code>之前才有效果，否则将无效，而且每次请求只需要添加一次即可。而且大家看到了我第二次读取<code>Body</code>的时候使用了同步的方式去读取的<code>RequestBody</code>，是不是很神奇，待会的时候我们会从源码的角度分析这个问题。</p> 
<h3><a id="_144"></a>源码探究</h3> 
<p>上面我们看到了通过<code>StreamReader</code>的<code>ReadToEnd</code>同步读取<code>Request.Body</code>需要设置<code>AllowSynchronousIO</code>为true才能操作，但是使用<code>StreamReader</code>的<code>ReadToEndAsync</code>方法却可以直接操作。</p> 
<h4><a id="StreamReaderStream_147"></a><code>StreamReader</code>和<code>Stream</code>的关系</h4> 
<p>我们看到了都是通过操作<code>StreamReader</code>的方法即可，那关我<code>Request.Body</code>啥事，别急咱们先看一看这里的操作，首先来大致看下<code>ReadToEnd</code>的实现了解一下<code>StreamReader</code>到底和<code>Stream</code>有啥关联，找到<code>ReadToEnd</code>方法</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">ReadToEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">ThrowIfDisposed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CheckAsyncTaskInProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 调用ReadBuffer，然后从charBuffer中提取数据。</span>
    <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span>_charLen <span class="token operator">-</span> _charPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//循环拼接读取内容</span>
        sb<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>_charBuffer<span class="token punctuation">,</span> _charPos<span class="token punctuation">,</span> _charLen <span class="token operator">-</span> _charPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        _charPos <span class="token operator">=</span> _charLen<span class="token punctuation">;</span> 
        <span class="token comment">//读取buffer，这是核心操作</span>
        <span class="token function">ReadBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>_charLen <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//返回读取内容</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过这段源码我们了解到了这么个信息，一个是<code>StreamReader</code>的<code>ReadToEnd</code>其实本质是通过循环读取<code>ReadBuffer</code>然后通过<code>StringBuilder</code>去拼接读取的内容，核心是读取<code>ReadBuffer</code>方法，由于代码比较多，我们找到大致呈现一下核心操作</p> 
<pre><code class="prism language-csharp"><span class="token keyword">if</span> <span class="token punctuation">(</span>_checkPreamble<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//通过这里我们可以知道本质就是使用要读取的Stream里的Read方法</span>
    <span class="token class-name"><span class="token keyword">int</span></span> len <span class="token operator">=</span> _stream<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>_byteBuffer<span class="token punctuation">,</span> _bytePos<span class="token punctuation">,</span> _byteBuffer<span class="token punctuation">.</span>Length <span class="token operator">-</span> _bytePos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_byteLen <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            _charLen <span class="token operator">+=</span> _decoder<span class="token punctuation">.</span><span class="token function">GetChars</span><span class="token punctuation">(</span>_byteBuffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> _byteLen<span class="token punctuation">,</span> _charBuffer<span class="token punctuation">,</span> _charLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
            _bytePos <span class="token operator">=</span> _byteLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> _charLen<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    _byteLen <span class="token operator">+=</span> len<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//通过这里我们可以知道本质就是使用要读取的Stream里的Read方法</span>
    _byteLen <span class="token operator">=</span> _stream<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>_byteBuffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> _byteBuffer<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_byteLen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> _charLen<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过上面的代码我们可以了解到<code>StreamReader</code>其实是工具类，只是封装了对<code>Stream</code>的原始操作，简化我们的代码<code>ReadToEnd</code>方法本质是读取<code>Stream</code>的<code>Read</code>方法。接下来我们看一下<code>ReadToEndAsync</code>方法的具体实现</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> <span class="token function">ReadToEndAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">StreamReader</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">ReadToEndAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">ThrowIfDisposed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CheckAsyncTaskInProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//本质是ReadToEndAsyncInternal方法</span>
    <span class="token class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token function">ReadToEndAsyncInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _asyncReadTask <span class="token operator">=</span> task<span class="token punctuation">;</span>

    <span class="token keyword">return</span> task<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> <span class="token function">ReadToEndAsyncInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//也是循环拼接读取的内容</span>
    <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span>_charLen <span class="token operator">-</span> _charPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name"><span class="token keyword">int</span></span> tmpCharPos <span class="token operator">=</span> _charPos<span class="token punctuation">;</span>
        sb<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>_charBuffer<span class="token punctuation">,</span> tmpCharPos<span class="token punctuation">,</span> _charLen <span class="token operator">-</span> tmpCharPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        _charPos <span class="token operator">=</span> _charLen<span class="token punctuation">;</span> 
        <span class="token comment">//核心操作是ReadBufferAsync方法</span>
        <span class="token keyword">await</span> <span class="token function">ReadBufferAsync</span><span class="token punctuation">(</span>CancellationToken<span class="token punctuation">.</span>None<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ConfigureAwait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>_charLen <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过这个我们可以看到核心操作是<code>ReadBufferAsync</code>方法，代码比较多我们同样看一下核心实现</p> 
<pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> tmpByteBuffer <span class="token operator">=</span> _byteBuffer<span class="token punctuation">;</span>
<span class="token comment">//Stream赋值给tmpStream </span>
<span class="token class-name">Stream</span> tmpStream <span class="token operator">=</span> _stream<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>_checkPreamble<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name"><span class="token keyword">int</span></span> tmpBytePos <span class="token operator">=</span> _bytePos<span class="token punctuation">;</span>
    <span class="token comment">//本质是调用Stream的ReadAsync方法</span>
    <span class="token class-name"><span class="token keyword">int</span></span> len <span class="token operator">=</span> <span class="token keyword">await</span> tmpStream<span class="token punctuation">.</span><span class="token function">ReadAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Memory<span class="token punctuation">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>tmpByteBuffer<span class="token punctuation">,</span> tmpBytePos<span class="token punctuation">,</span> tmpByteBuffer<span class="token punctuation">.</span>Length <span class="token operator">-</span> tmpBytePos<span class="token punctuation">)</span><span class="token punctuation">,</span> cancellationToken<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ConfigureAwait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_byteLen <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            _charLen <span class="token operator">+=</span> _decoder<span class="token punctuation">.</span><span class="token function">GetChars</span><span class="token punctuation">(</span>tmpByteBuffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> _byteLen<span class="token punctuation">,</span> _charBuffer<span class="token punctuation">,</span> _charLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
            _bytePos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> _byteLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> _charLen<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    _byteLen <span class="token operator">+=</span> len<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//本质是调用Stream的ReadAsync方法</span>
    _byteLen <span class="token operator">=</span> <span class="token keyword">await</span> tmpStream<span class="token punctuation">.</span><span class="token function">ReadAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Memory<span class="token punctuation">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>tmpByteBuffer<span class="token punctuation">)</span><span class="token punctuation">,</span> cancellationToken<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ConfigureAwait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_byteLen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> _charLen<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过上面代码我可以了解到<code>StreamReader</code>的本质就是读取<code>Stream</code>的包装，核心方法还是来自<code>Stream</code>本身。我们之所以大致介绍了<code>StreamReader</code>类，就是为了给大家呈现出<code>StreamReader</code>和<code>Stream</code>的关系，否则怕大家误解这波操作是<code>StreamReader</code>的里的实现，而不是<code>Request.Body</code>的问题，其实并不是这样的所有的一切都是指向<code>Stream</code>的<code>Request</code>的<code>Body</code>就是<code>Stream</code>这个大家可以自己查看一下，了解到这一步我们就可以继续了。</p> 
<h4><a id="HttpRequestBody_267"></a><code>HttpRequest</code>的<code>Body</code></h4> 
<p>上面我们说到了<code>Request</code>的<code>Body</code>本质就是<code>Stream</code>，<code>Stream</code>本身是抽象类，所以<code>Request.Body</code>是<code>Stream</code>的实现类。默认情况下<code>Request.Body</code>的是<code>HttpRequestStream</code>的实例，我们这里说了是默认，因为它是可以改变的，我们一会再说。我们从上面<code>StreamReader</code>的结论中得到<code>ReadToEnd</code>本质还是调用的<code>Stream</code>的<code>Read</code>方法，即这里的<code>HttpRequestStream</code>的<code>Read</code>方法，我们来看一下具体实现</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Read</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> buffer<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> offset<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> count<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//知道同步读取Body为啥报错了吧</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_bodyControl<span class="token punctuation">.</span>AllowSynchronousIO<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">InvalidOperationException</span><span class="token punctuation">(</span>CoreStrings<span class="token punctuation">.</span>SynchronousReadsDisallowed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//本质是调用ReadAsync</span>
    <span class="token keyword">return</span> <span class="token function">ReadAsync</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过这段代码我们就可以知道了为啥在不设置<code>AllowSynchronousIO</code>为<code>true</code>的情下读取<code>Body</code>会抛出异常了吧，这个是程序级别的控制，而且我们还了解到<code>Read</code>的本质还是在调用<code>ReadAsync</code>异步方法</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">ValueTask<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> <span class="token function">ReadAsync</span><span class="token punctuation">(</span><span class="token class-name">Memory<span class="token punctuation">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">&gt;</span></span> destination<span class="token punctuation">,</span> <span class="token class-name">CancellationToken</span> cancellationToken <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">ReadAsyncWrapper</span><span class="token punctuation">(</span>destination<span class="token punctuation">,</span> cancellationToken<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>ReadAsync</code>本身并无特殊限制，所以直接操作<code>ReadAsync</code>不会存在类似<code>Read</code>的异常。</p> 
<p>通过这个我们得出了结论<code>Request.Body</code>即<code>HttpRequestStream</code>的同步读取<code>Read</code>会抛出异常，而异步读取<code>ReadAsync</code>并不会抛出异常只和<code>HttpRequestStream</code>的<code>Read</code>方法本身存在判断<code>AllowSynchronousIO</code>的值有关系。</p> 
<h4><a id="AllowSynchronousIO_296"></a><code>AllowSynchronousIO</code>本质来源</h4> 
<p>通过<code>HttpRequestStream</code>的<code>Read</code>方法我们可以知道<code>AllowSynchronousIO</code>控制了同步读取的方式。而且我们还了解到了<code>AllowSynchronousIO</code>有几种不同方式的去配置，接下来我们来大致看下几种方式的本质是哪一种。通过<code>HttpRequestStream</code>我们知道<code>Read</code>方法中的<code>AllowSynchronousIO</code>的属性是来自<code>IHttpBodyControlFeature</code>也就是我们上面介绍的第二种配置方式</p> 
<pre><code class="prism language-csharp"><span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">HttpRequestPipeReader</span> _pipeReader<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IHttpBodyControlFeature</span> _bodyControl<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token function">HttpRequestStream</span><span class="token punctuation">(</span><span class="token class-name">IHttpBodyControlFeature</span> bodyControl<span class="token punctuation">,</span> <span class="token class-name">HttpRequestPipeReader</span> pipeReader<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    _bodyControl <span class="token operator">=</span> bodyControl<span class="token punctuation">;</span>
    _pipeReader <span class="token operator">=</span> pipeReader<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么它和<code>KestrelServerOptions</code>肯定是有关系的，因为我们只配置<code>KestrelServerOptions</code>的是<code>HttpRequestStream</code>的<code>Read</code>是不报异常的，而<code>HttpRequestStream</code>的<code>Read</code>只依赖了<code>IHttpBodyControlFeature</code>的<code>AllowSynchronousIO</code>属性。<code>Kestrel</code>中<code>HttpRequestStream</code>初始化的地方在<code>BodyControl</code></p> 
<pre><code class="prism language-csharp"><span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">HttpRequestStream</span> _request<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token function">BodyControl</span><span class="token punctuation">(</span><span class="token class-name">IHttpBodyControlFeature</span> bodyControl<span class="token punctuation">,</span> <span class="token class-name">IHttpResponseControl</span> responseControl<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    _request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">HttpRequestStream</span><span class="token punctuation">(</span>bodyControl<span class="token punctuation">,</span> _requestReader<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>而初始化<code>BodyControl</code>的地方在<code>HttpProtocol</code>中,我们找到初始化<code>BodyControl</code>的<code>InitializeBodyControl</code>方法</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InitializeBodyControl</span><span class="token punctuation">(</span><span class="token class-name">MessageBody</span> messageBody<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_bodyControl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//这里传递的是bodyControl传递的是this</span>
        _bodyControl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BodyControl</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">bodyControl</span><span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">(</span>RequestBody<span class="token punctuation">,</span> ResponseBody<span class="token punctuation">,</span> RequestBodyPipeReader<span class="token punctuation">,</span> ResponseBodyPipeWriter<span class="token punctuation">)</span> <span class="token operator">=</span> _bodyControl<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>messageBody<span class="token punctuation">)</span><span class="token punctuation">;</span>
    _requestStreamInternal <span class="token operator">=</span> RequestBody<span class="token punctuation">;</span>
    _responseStreamInternal <span class="token operator">=</span> ResponseBody<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里我们可以看的到初始化<code>IHttpBodyControlFeature</code>既然传递的是<code>this</code>，也就是<code>HttpProtocol</code>当前实例。也就是说<code>HttpProtocol</code>是实现了<code>IHttpBodyControlFeature</code>接口，<code>HttpProtocol</code>本身是<code>partial</code>的，我们在其中一个分布类<code>HttpProtocol.FeatureCollection</code>中看到了实现关系</p> 
<pre><code class="prism language-csharp"><span class="token keyword">internal</span> <span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">HttpProtocol</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IHttpRequestFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IHttpRequestBodyDetectionFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IHttpResponseFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IHttpResponseBodyFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IRequestBodyPipeFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IHttpUpgradeFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IHttpConnectionFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IHttpRequestLifetimeFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IHttpRequestIdentifierFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IHttpRequestTrailersFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IHttpBodyControlFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IHttpMaxRequestBodySizeFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IEndpointFeature</span><span class="token punctuation">,</span> 
 <span class="token class-name">IRouteValuesFeature</span></span> 
 <span class="token punctuation">{<!-- --></span> 
     <span class="token return-type class-name"><span class="token keyword">bool</span></span> IHttpBodyControlFeature<span class="token punctuation">.</span>AllowSynchronousIO 
     <span class="token punctuation">{<!-- --></span> 
         <span class="token keyword">get</span> <span class="token operator">=&gt;</span> AllowSynchronousIO<span class="token punctuation">;</span> 
         <span class="token keyword">set</span> <span class="token operator">=&gt;</span> AllowSynchronousIO <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
 <span class="token punctuation">}</span>
</code></pre> 
<p>通过这个可以看出<code>HttpProtocol</code>确实实现了<code>IHttpBodyControlFeature</code>接口，接下来我们找到初始化<code>AllowSynchronousIO</code>的地方，找到了<code>AllowSynchronousIO = ServerOptions.AllowSynchronousIO;</code>这段代码说明来自于<code>ServerOptions</code>这个属性，找到初始化<code>ServerOptions</code>的地方</p> 
<pre><code class="prism language-csharp"><span class="token keyword">private</span> <span class="token class-name">HttpConnectionContext</span> _context<span class="token punctuation">;</span>
<span class="token comment">//ServiceContext初始化来自HttpConnectionContext </span>
<span class="token keyword">public</span> <span class="token return-type class-name">ServiceContext</span> ServiceContext <span class="token operator">=&gt;</span> _context<span class="token punctuation">.</span>ServiceContext<span class="token punctuation">;</span>
<span class="token keyword">protected</span> <span class="token return-type class-name">KestrelServerOptions</span> ServerOptions <span class="token punctuation">{<!-- --></span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token operator">!</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Initialize</span><span class="token punctuation">(</span><span class="token class-name">HttpConnectionContext</span> context<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    _context <span class="token operator">=</span> context<span class="token punctuation">;</span>
    <span class="token comment">//来自ServiceContext</span>
    ServerOptions <span class="token operator">=</span> ServiceContext<span class="token punctuation">.</span>ServerOptions<span class="token punctuation">;</span>
    <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    HttpResponseControl <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过这个我们知道<code>ServerOptions</code>来自于<code>ServiceContext</code>的<code>ServerOptions</code>属性，我们找到给<code>ServiceContext</code>赋值的地方，在<code>KestrelServerImpl</code>的<code>CreateServiceContext</code>方法里精简一下逻辑，抽出来核心内容大致实现如下</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token function">KestrelServerImpl</span><span class="token punctuation">(</span>
   <span class="token class-name">IOptions<span class="token punctuation">&lt;</span>KestrelServerOptions<span class="token punctuation">&gt;</span></span> options<span class="token punctuation">,</span>
   <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>IConnectionListenerFactory<span class="token punctuation">&gt;</span></span> transportFactories<span class="token punctuation">,</span>
   <span class="token class-name">ILoggerFactory</span> loggerFactory<span class="token punctuation">)</span>     
   <span class="token comment">//注入进来的IOptions&lt;KestrelServerOptions&gt;调用了CreateServiceContext</span>
   <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span>transportFactories<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">CreateServiceContext</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> loggerFactory<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">ServiceContext</span> <span class="token function">CreateServiceContext</span><span class="token punctuation">(</span><span class="token class-name">IOptions<span class="token punctuation">&lt;</span>KestrelServerOptions<span class="token punctuation">&gt;</span></span> options<span class="token punctuation">,</span> <span class="token class-name">ILoggerFactory</span> loggerFactory<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//值来自于IOptions&lt;KestrelServerOptions&gt; </span>
    <span class="token class-name"><span class="token keyword">var</span></span> serverOptions <span class="token operator">=</span> options<span class="token punctuation">.</span>Value <span class="token operator">??</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">KestrelServerOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ServiceContext</span>
    <span class="token punctuation">{<!-- --></span>
        Log <span class="token operator">=</span> trace<span class="token punctuation">,</span>
        HttpParser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">HttpParser<span class="token punctuation">&lt;</span>Http1ParsingHandler<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>trace<span class="token punctuation">.</span><span class="token function">IsEnabled</span><span class="token punctuation">(</span>LogLevel<span class="token punctuation">.</span>Information<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        Scheduler <span class="token operator">=</span> PipeScheduler<span class="token punctuation">.</span>ThreadPool<span class="token punctuation">,</span>
        SystemClock <span class="token operator">=</span> heartbeatManager<span class="token punctuation">,</span>
        DateHeaderValueManager <span class="token operator">=</span> dateHeaderValueManager<span class="token punctuation">,</span>
        ConnectionManager <span class="token operator">=</span> connectionManager<span class="token punctuation">,</span>
        Heartbeat <span class="token operator">=</span> heartbeat<span class="token punctuation">,</span>
        <span class="token comment">//赋值操作</span>
        ServerOptions <span class="token operator">=</span> serverOptions<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过上面的代码我们可以看到如果配置了<code>KestrelServerOptions</code>那么<code>ServiceContext</code>的<code>ServerOptions</code>属性就来自于<code>KestrelServerOptions</code>，即我们通过<code>services.Configure&lt;KestrelServerOptions&gt;()</code>配置的值，总之得到了这么一个结论</p> 
<p>如果配置了<code>KestrelServerOptions</code>即<code>services.Configure()</code>，那么<code>AllowSynchronousIO</code>来自于<code>KestrelServerOptions</code>。即<code>IHttpBodyControlFeature</code>的<code>AllowSynchronousIO</code>属性来自于<code>KestrelServerOptions</code>。如果没有配置，那么直接通过修改<code>IHttpBodyControlFeature</code>实例的<br> <code>AllowSynchronousIO</code>属性能得到相同的效果，毕竟<code>HttpRequestStream</code>是直接依赖的<code>IHttpBodyControlFeature</code>实例。</p> 
<h4><a id="EnableBuffering_414"></a><code>EnableBuffering</code>神奇的背后</h4> 
<p>我们在上面的示例中看到了，如果不添加<code>EnableBuffering</code>的话直接设置<code>RequestBody</code>的<code>Position</code>会报<code>NotSupportedException</code>这么一个错误，而且加了它之后我居然可以直接使用同步的方式去读取<code>RequestBody</code>，首先我们来看一下为啥会报错，我们从上面的错误了解到错误来自于<code>HttpRequestStream</code>这个类，上面我们也说了这个类继承了<code>Stream</code>抽象类,通过源码我们可以看到如下相关代码</p> 
<pre><code class="prism language-csharp"><span class="token comment">//不能使用Seek操作</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> CanSeek <span class="token operator">=&gt;</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token comment">//允许读</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> CanRead <span class="token operator">=&gt;</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token comment">//不允许写</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> CanWrite <span class="token operator">=&gt;</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token comment">//不能获取长度</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">long</span></span> Length <span class="token operator">=&gt;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NotSupportedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//不能读写Position</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">long</span></span> Position
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">get</span> <span class="token operator">=&gt;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NotSupportedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">set</span> <span class="token operator">=&gt;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NotSupportedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//不能使用Seek方法</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">long</span></span> <span class="token function">Seek</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">long</span></span> offset<span class="token punctuation">,</span> <span class="token class-name">SeekOrigin</span> origin<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NotSupportedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>相信通过这些我们可以清楚的看到针对<code>HttpRequestStream</code>的设置或者写相关的操作是不被允许的，这也是为啥我们上面直接通过<code>Seek</code>设置<code>Position</code>的时候为啥会报错，还有一些其他操作的限制，总之默认是不希望我们对<code>HttpRequestStream</code>做过多的操作，特别是设置或者写相关的操作。但是我们使用<code>EnableBuffering</code>的时候却没有这些问题，究竟是为什么?接下来我们要揭开它的什么面纱了。首先我们从<code>Request.EnableBuffering()</code>这个方法入手，找到源码位置在<code>HttpRequestRewindExtensions</code>扩展类中，我们从最简单的无参方法开始看到如下定义</p> 
<pre><code class="prism language-csharp"><span class="token comment">/// &lt;summary&gt;</span>
<span class="token comment">/// 确保Request.Body可以被多次读取</span>
<span class="token comment">/// &lt;/summary&gt;</span>
<span class="token comment">/// &lt;param name="request"&gt;&lt;/param&gt;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EnableBuffering</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">HttpRequest</span> request<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BufferingHelper<span class="token punctuation">.</span><span class="token function">EnableRewind</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的方法是最简单的形式，还有一个<code>EnableBuffering</code>的扩展方法是参数最全的扩展方法，这个方法可以控制读取的大小和控制是否存储到磁盘的限定大小</p> 
<pre><code class="prism language-csharp"><span class="token comment">/// &lt;summary&gt;</span>
<span class="token comment">/// 确保Request.Body可以被多次读取</span>
<span class="token comment">/// &lt;/summary&gt;</span>
<span class="token comment">/// &lt;param name="request"&gt;&lt;/param&gt;</span>
<span class="token comment">/// &lt;param name="bufferThreshold"&gt;内存中用于缓冲流的最大大小（字节）。较大的请求主体被写入磁盘。&lt;/param&gt;</span>
<span class="token comment">/// &lt;param name="bufferLimit"&gt;请求正文的最大大小（字节）。尝试读取超过此限制将导致异常&lt;/param&gt;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EnableBuffering</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">HttpRequest</span> request<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> bufferThreshold<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">long</span></span> bufferLimit<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BufferingHelper<span class="token punctuation">.</span><span class="token function">EnableRewind</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> bufferThreshold<span class="token punctuation">,</span> bufferLimit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>无论那种形式，最终都是在调用<code>BufferingHelper.EnableRewind</code>这个方法，话不多说直接找到<code>BufferingHelper</code>这个类，找到类的位置代码不多而且比较简洁，咱们就把<code>EnableRewind</code>的实现粘贴出来</p> 
<pre><code class="prism language-csharp"><span class="token comment">//默认内存中可缓存的大小为30K,超过这个大小将会被存储到磁盘</span>
<span class="token keyword">internal</span> <span class="token keyword">const</span> <span class="token class-name"><span class="token keyword">int</span></span> DefaultBufferThreshold <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">30</span><span class="token punctuation">;</span>

<span class="token comment">/// &lt;summary&gt;</span>
<span class="token comment">/// 这个方法也是HttpRequest扩展方法</span>
<span class="token comment">/// &lt;/summary&gt;</span>
<span class="token comment">/// &lt;returns&gt;&lt;/returns&gt;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">HttpRequest</span> <span class="token function">EnableRewind</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">HttpRequest</span> request<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> bufferThreshold <span class="token operator">=</span> DefaultBufferThreshold<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">long</span><span class="token punctuation">?</span></span> bufferLimit <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>request <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentNullException</span><span class="token punctuation">(</span><span class="token keyword">nameof</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//先获取Request Body</span>
    <span class="token class-name"><span class="token keyword">var</span></span> body <span class="token operator">=</span> request<span class="token punctuation">.</span>Body<span class="token punctuation">;</span>
    <span class="token comment">//默认情况Body是HttpRequestStream这个类CanSeek是false所以肯定会执行到if逻辑里面</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>body<span class="token punctuation">.</span>CanSeek<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//实例化了FileBufferingReadStream这个类，看来这是关键所在</span>
        <span class="token class-name"><span class="token keyword">var</span></span> fileStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileBufferingReadStream</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> bufferThreshold<span class="token punctuation">,</span>bufferLimit<span class="token punctuation">,</span>AspNetCoreTempDirectory<span class="token punctuation">.</span>TempDirectoryFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//赋值给Body，也就是说开启了EnableBuffering之后Request.Body类型将会是FileBufferingReadStream</span>
        request<span class="token punctuation">.</span>Body <span class="token operator">=</span> fileStream<span class="token punctuation">;</span>
        <span class="token comment">//这里要把fileStream注册给Response便于释放</span>
        request<span class="token punctuation">.</span>HttpContext<span class="token punctuation">.</span>Response<span class="token punctuation">.</span><span class="token function">RegisterForDispose</span><span class="token punctuation">(</span>fileStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> request<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>从上面这段源码实现中我们可以大致得到两个结论</p> 
<p><code>BufferingHelper</code>的<code>EnableRewind</code>方法也是<code>HttpRequest</code>的扩展方法，可以直接通过<code>Request.EnableRewind</code>的形式调用，效果等同于调用<code>Request.EnableBuffering</code>因为<code>EnableBuffering</code>也是调用的<code>EnableRewind</code></p> 
<p>启用了<code>EnableBuffering</code>这个操作之后实际上会使用<code>FileBufferingReadStream</code>替换掉默认的<code>HttpRequestStream</code>，所以后续处理<code>RequestBody</code>的操作将会是<code>FileBufferingReadStream</code>实例</p> 
<p>通过上面的分析我们也清楚的看到了，核心操作在于<code>FileBufferingReadStream</code>这个类，而且从名字也能看出来它肯定是也继承了<code>Stream</code>抽象类，那还等啥直接找到<code>FileBufferingReadStream</code>的实现，首先来看他类的定义</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileBufferingReadStream</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Stream</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>毋庸置疑确实是继承自<code>Steam</code>类，我们上面也看到了使用了<code>Request.EnableBuffering</code>之后就可以设置和重复读取<code>RequestBody</code>，说明进行了一些重写操作，具体我们来看一下</p> 
<pre><code class="prism language-csharp"><span class="token comment">/// &lt;summary&gt;</span>
<span class="token comment">/// 允许读</span>
<span class="token comment">/// &lt;/summary&gt;</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> CanRead
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">get</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/// &lt;summary&gt;</span>
<span class="token comment">/// 允许Seek</span>
<span class="token comment">/// &lt;/summary&gt;</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> CanSeek
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">get</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/// &lt;summary&gt;</span>
<span class="token comment">/// 不允许写</span>
<span class="token comment">/// &lt;/summary&gt;</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> CanWrite
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">get</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/// &lt;summary&gt;</span>
<span class="token comment">/// 可以获取长度</span>
<span class="token comment">/// &lt;/summary&gt;</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">long</span></span> Length
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">get</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> _buffer<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/// &lt;summary&gt;</span>
<span class="token comment">/// 可以读写Position</span>
<span class="token comment">/// &lt;/summary&gt;</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">long</span></span> Position
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">get</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> _buffer<span class="token punctuation">.</span>Position<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">set</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">ThrowIfDisposed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        _buffer<span class="token punctuation">.</span>Position <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">long</span></span> <span class="token function">Seek</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">long</span></span> offset<span class="token punctuation">,</span> <span class="token class-name">SeekOrigin</span> origin<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//如果Body已释放则异常</span>
    <span class="token function">ThrowIfDisposed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//特殊情况抛出异常</span>
    <span class="token comment">//_completelyBuffered代表是否完全缓存一定是在原始的HttpRequestStream读取完成后才置为true</span>
    <span class="token comment">//出现没读取完成但是原始位置信息和当前位置信息不一致则直接抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_completelyBuffered <span class="token operator">&amp;&amp;</span> origin <span class="token operator">==</span> SeekOrigin<span class="token punctuation">.</span>End<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NotSupportedException</span><span class="token punctuation">(</span><span class="token string">"The content has not been fully buffered yet."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_completelyBuffered <span class="token operator">&amp;&amp;</span> origin <span class="token operator">==</span> SeekOrigin<span class="token punctuation">.</span>Current <span class="token operator">&amp;&amp;</span> offset <span class="token operator">+</span> Position <span class="token operator">&gt;</span> Length<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NotSupportedException</span><span class="token punctuation">(</span><span class="token string">"The content has not been fully buffered yet."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_completelyBuffered <span class="token operator">&amp;&amp;</span> origin <span class="token operator">==</span> SeekOrigin<span class="token punctuation">.</span>Begin <span class="token operator">&amp;&amp;</span> offset <span class="token operator">&gt;</span> Length<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NotSupportedException</span><span class="token punctuation">(</span><span class="token string">"The content has not been fully buffered yet."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//充值buffer的Seek</span>
    <span class="token keyword">return</span> _buffer<span class="token punctuation">.</span><span class="token function">Seek</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> origin<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>因为重写了一些关键设置，所以我们可以设置一些流相关的操作。从<code>Seek</code>方法中我们看到了两个比较重要的参数<code>_completelyBuffered</code>和<code>_buffer</code>，<code>_completelyBuffered</code>用来判断原始的<code>HttpRequestStream</code>是否读取完成，因为<code>FileBufferingReadStream</code>归根结底还是先读取了<code>HttpRequestStream</code>的内容。<code>_buffer</code>正是承载从<code>HttpRequestStream</code>读取的内容,我们大致抽离一下逻辑看一下，切记这不是全部逻辑，是抽离出来的大致思想</p> 
<pre><code class="prism language-csharp"><span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">ArrayPool<span class="token punctuation">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">&gt;</span></span> _bytePool<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token class-name"><span class="token keyword">int</span></span> _maxRentedBufferSize <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token comment">//1MB</span>
<span class="token keyword">private</span> <span class="token class-name">Stream</span> _buffer<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token function">FileBufferingReadStream</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> memoryThreshold<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//即使我们设置memoryThreshold那么它最大也不能超过1MB否则也会存储在磁盘上</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>memoryThreshold <span class="token operator">&lt;=</span> _maxRentedBufferSize<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _rentedBuffer <span class="token operator">=</span> bytePool<span class="token punctuation">.</span><span class="token function">Rent</span><span class="token punctuation">(</span>memoryThreshold<span class="token punctuation">)</span><span class="token punctuation">;</span>
        _buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MemoryStream</span><span class="token punctuation">(</span>_rentedBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        _buffer<span class="token punctuation">.</span><span class="token function">SetLength</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//超过1M将缓存到磁盘所以仅仅初始化</span>
        _buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MemoryStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这些都是一些初始化的操作，核心操作当然还是在<code>FileBufferingReadStream</code>的<code>Read</code>方法里，因为真正读取的地方就在这，我们找到<code>Read</code>方法位置</p> 
<pre><code class="prism language-csharp"><span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">Stream</span> _inner<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token function">FileBufferingReadStream</span><span class="token punctuation">(</span><span class="token class-name">Stream</span> inner<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//接收原始的Request.Body</span>
    _inner <span class="token operator">=</span> inner<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Read</span><span class="token punctuation">(</span><span class="token class-name">Span<span class="token punctuation">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">&gt;</span></span> buffer<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">ThrowIfDisposed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//如果读取完成过则直接在buffer中获取信息直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_buffer<span class="token punctuation">.</span>Position <span class="token operator">&lt;</span> _buffer<span class="token punctuation">.</span>Length <span class="token operator">||</span> _completelyBuffered<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> _buffer<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//未读取完成才会走到这里</span>
    <span class="token comment">//_inner正是接收的原始的RequestBody</span>
    <span class="token comment">//读取的RequestBody放入buffer中</span>
    <span class="token class-name"><span class="token keyword">var</span></span> read <span class="token operator">=</span> _inner<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//超过设定的长度则会抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_bufferLimit<span class="token punctuation">.</span>HasValue <span class="token operator">&amp;&amp;</span> _bufferLimit <span class="token operator">-</span> read <span class="token operator">&lt;</span> _buffer<span class="token punctuation">.</span>Length<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">IOException</span><span class="token punctuation">(</span><span class="token string">"Buffer limit exceeded."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//如果设定存储在内存中并且Body长度大于设定的可存储在内存中的长度,则存储到磁盘中</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_inMemory <span class="token operator">&amp;&amp;</span> _memoryThreshold <span class="token operator">-</span> read <span class="token operator">&lt;</span> _buffer<span class="token punctuation">.</span>Length<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _inMemory <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">//缓存原始的Body流</span>
        <span class="token class-name"><span class="token keyword">var</span></span> oldBuffer <span class="token operator">=</span> _buffer<span class="token punctuation">;</span>
        <span class="token comment">//创建缓存文件</span>
        _buffer <span class="token operator">=</span> <span class="token function">CreateTempFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//超过内存存储限制，但是还未写入过临时文件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_rentedBuffer <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            oldBuffer<span class="token punctuation">.</span>Position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token class-name"><span class="token keyword">var</span></span> rentedBuffer <span class="token operator">=</span> _bytePool<span class="token punctuation">.</span><span class="token function">Rent</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">Min</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>oldBuffer<span class="token punctuation">.</span>Length<span class="token punctuation">,</span> _maxRentedBufferSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//将Body流读取到缓存文件流中</span>
                <span class="token class-name"><span class="token keyword">var</span></span> copyRead <span class="token operator">=</span> oldBuffer<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>rentedBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//判断是否读取到结尾</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>copyRead <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">//将oldBuffer写入到缓存文件流_buffer当中</span>
                    _buffer<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>rentedBuffer<span class="token punctuation">.</span><span class="token function">AsSpan</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> copyRead<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    copyRead <span class="token operator">=</span> oldBuffer<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>rentedBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">finally</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//读取完成之后归还临时缓冲区到ArrayPool中</span>
                _bytePool<span class="token punctuation">.</span><span class="token function">Return</span><span class="token punctuation">(</span>rentedBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            
            _buffer<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>_rentedBuffer<span class="token punctuation">.</span><span class="token function">AsSpan</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>oldBuffer<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            _bytePool<span class="token punctuation">.</span><span class="token function">Return</span><span class="token punctuation">(</span>_rentedBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            _rentedBuffer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//如果读取RequestBody未到结尾,则一直写入到缓存区</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>read <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _buffer<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> read<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//如果已经读取RequestBody完毕，也就是写入到缓存完毕则更新_completelyBuffered</span>
        <span class="token comment">//标记为以全部读取RequestBody完成，后续在读取RequestBody则直接在_buffer中读取</span>
        _completelyBuffered <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//返回读取的byte个数用于外部StreamReader判断读取是否完成</span>
    <span class="token keyword">return</span> read<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码比较多看着也比较复杂，其实核心思路还是比较清晰的，我们来大致的总结一下</p> 
<ul><li>首先判断是否完全的读取过原始的<code>RequestBody</code>,如果完全完整的读取过<code>RequestBody</code>则直接在缓冲区中获取返回</li><li>如果<code>RequestBody</code>长度大于设定的内存存储限定，则将缓冲写入磁盘临时文件中</li><li>如果是首次读取或为完全完整的读取完成<code>RequestBody</code>，那么将<code>RequestBody</code>的内容写入到缓冲区，知道读取完成</li></ul> 
<p>其中<code>CreateTempFile</code>这是创建临时文件的操作流，目的是为了将<code>RequestBody</code>的信息写入到临时文件中。可以指定临时文件的地址，若如果不指定则使用系统默认目录，它的实现如下</p> 
<pre><code class="prism language-csharp"><span class="token keyword">private</span> <span class="token return-type class-name">Stream</span> <span class="token function">CreateTempFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//判断是否制定过缓存目录，没有的话则使用系统临时文件目录</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_tempFileDirectory <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>_tempFileDirectoryAccessor <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        _tempFileDirectory <span class="token operator">=</span> <span class="token function">_tempFileDirectoryAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>_tempFileDirectory <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//临时文件的完整路径</span>
    _tempFileName <span class="token operator">=</span> Path<span class="token punctuation">.</span><span class="token function">Combine</span><span class="token punctuation">(</span>_tempFileDirectory<span class="token punctuation">,</span> <span class="token string">"ASPNETCORE_"</span> <span class="token operator">+</span> Guid<span class="token punctuation">.</span><span class="token function">NewGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".tmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//返回临时文件的操作流</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span>_tempFileName<span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Create<span class="token punctuation">,</span> FileAccess<span class="token punctuation">.</span>ReadWrite<span class="token punctuation">,</span> FileShare<span class="token punctuation">.</span>Delete<span class="token punctuation">,</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">,</span>
        FileOptions<span class="token punctuation">.</span>Asynchronous <span class="token operator">|</span> FileOptions<span class="token punctuation">.</span>DeleteOnClose <span class="token operator">|</span> FileOptions<span class="token punctuation">.</span>SequentialScan<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们上面分析了<code>FileBufferingReadStream</code>的<code>Read</code>方法这个方法是同步读取的方法可供<code>StreamReader</code>的<code>ReadToEnd</code>方法使用，当然它还存在一个异步读取方法<code>ReadAsync</code>供<code>StreamReader</code>的<code>ReadToEndAsync</code>方法使用。这两个方法的实现逻辑是完全一致的，只是读取和写入操作都是异步的操作，这里咱们就不介绍那个方法了，有兴趣的同学可以自行了解一下<code>ReadAsync</code>方法的实现</p> 
<p>当开启<code>EnableBuffering</code>的时候，无论首次读取是设置了<code>AllowSynchronousIO</code>为<code>true</code>的<code>ReadToEnd</code>同步读取方式，还是直接使用<code>ReadToEndAsync</code>的异步读取方式，那么再次使用<code>ReadToEnd</code>同步方式去读取<code>Request.Body</code>也便无需去设置<code>AllowSynchronousIO</code>为<code>true</code>。因为默认的<code>Request.Body</code>已经由<code>HttpRequestStream</code>实例替换为<code>FileBufferingReadStream</code>实例，而<code>FileBufferingReadStream</code>重写了<code>Read</code>和<code>ReadAsync</code>方法，并不存在不允许同步读取的限制。</p> 
<h3><a id="_718"></a>总结</h3> 
<p>本篇文章篇幅比较多，如果你想深入的研究相关逻辑，希望本文能给你带来一些阅读源码的指导。为了防止大家深入文章当中而忘记了具体的流程逻辑，在这里我们就大致的总结一下关于正确读取<code>RequestBody</code>的全部结论</p> 
<ul><li>首先关于同步读取<code>Request.Body</code>由于默认的<code>RequestBody</code>的实现是<code>HttpRequestStream</code>，但是<code>HttpRequestStream</code>在重写<code>Read</code>方法的时候会判断是否开启<code>AllowSynchronousIO</code>，如果未开启则直接抛出异常。但是<code>HttpRequestStream</code>的<code>ReadAsync</code>方法并无这种限制，所以使用异步方式的读取<code>RequestBody</code>并无异常。</li><li>虽然通过设置<code>AllowSynchronousIO</code>或使用<code>ReadAsync</code>的方式我们可以读取<code>RequestBody</code>，但是<code>RequestBody</code>无法重复读取，这是因为<code>HttpRequestStream</code>的<code>Position</code>和<code>Seek</code>都是不允许进行修改操作的，设置了会直接抛出异常。为了可以重复读取，我们引入了<code>Request</code>的扩展方法<code>EnableBuffering</code>通过这个方法我们可以重置读取位置来实现<code>RequestBody</code>的重复读取。</li><li>关于开启<code>EnableBuffering</code>方法每次请求设置一次即可，即在准备读取<code>RequestBody</code>之前设置。其本质其实是使用<code>FileBufferingReadStream</code>代替默认<code>RequestBody</code>的默认类型<code>HttpRequestStream</code>，这样我们在一次<code>Http</code>请求中操作<code>Body</code>的时候其实是操作<code>FileBufferingReadStream</code>，这个类重写<code>Stream</code>的时候<code>Position</code>和<code>Seek</code>都是可以设置的，这样我们就实现了重复读取。</li><li><code>FileBufferingReadStream</code>带给我们的不仅仅是可重复读取，还增加了对<code>RequestBody</code>的缓存功能，使得我们在一次请求中重复读取<code>RequestBody</code>的时候可以在<code>Buffer</code>里直接获取缓存内容而<code>Buffer</code>本身是一个<code>MemoryStream</code>。当然我们也可以自己实现一套逻辑来替换<code>Body</code>，只要我们重写的时候让这个<code>Stream</code>支持重置读取位置即可。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa2d6f81eea60196deb91360b9edeb79/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PTA node.js的读取和输出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f041ea4d47b7b61ddfd512926beb566/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">*CTF-2022 examination 题解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>