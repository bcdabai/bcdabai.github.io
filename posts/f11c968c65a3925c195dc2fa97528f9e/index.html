<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>蓝牙电话（hfp）与Android audio hal的关联 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="蓝牙电话（hfp）与Android audio hal的关联" />
<meta property="og:description" content="转自https://blog.csdn.net/bberdong/article/details/82912670
通话的时候，需要打开音频通路，音频设备（上下行都要）
我们从这里开始：
packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient
// in Connected state
private void processAudioEvent(int state, BluetoothDevice device) {
...
switch (state) {
...
case HeadsetClientHalConstants.AUDIO_STATE_CONNECTED:
routeHfpAudio(true);
}
}
​
private void acceptCall(int flag) {
...
if (flag == BluetoothHeadsetClient.CALL_ACCEPT_HOLD) {
// When unholding a call over Bluetooth make sure to route audio.
routeHfpAudio(true);
}
...
}
两种场景，一个是接通电话，一个是电话hold之后，unhold的时候。都需要去调用routeHfpAudio(true).我们简化问题，只分析打开的情况。
static synchronized void routeHfpAudio(boolean enable) {
...
if (enable &amp;&amp; !sAudioIsRouted) {
sAudioManager.setParameters(&#34;hfp_enable=true&#34;);
} else if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f11c968c65a3925c195dc2fa97528f9e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-03T20:10:01+08:00" />
<meta property="article:modified_time" content="2020-08-03T20:10:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">蓝牙电话（hfp）与Android audio hal的关联</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>转自<a href="https://blog.csdn.net/bberdong/article/details/82912670">https://blog.csdn.net/bberdong/article/details/82912670</a></p> 
<p> </p> 
<p>通话的时候，需要打开音频通路，音频设备（上下行都要）</p> 
<p>我们从这里开始：</p> 
<p>packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient</p> 
<pre><code class="language-html hljs"> </code></pre> 
<ol><li> <p><code>// in Connected state</code></p> </li><li> <p><code>private void processAudioEvent(int state, BluetoothDevice device) {<!-- --></code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>  switch (state) {<!-- --></code></p> </li><li> <p><code>          ...</code></p> </li><li> <p><code>          case HeadsetClientHalConstants.AUDIO_STATE_CONNECTED:</code></p> </li><li> <p><code>          routeHfpAudio(true);</code></p> </li><li> <p><code>  }</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>​</code></p> </li><li> <p><code>private void acceptCall(int flag) {<!-- --></code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   if (flag == BluetoothHeadsetClient.CALL_ACCEPT_HOLD) {<!-- --></code></p> </li><li> <p><code>           // When unholding a call over Bluetooth make sure to route audio.</code></p> </li><li> <p><code>           routeHfpAudio(true);</code></p> </li><li> <p><code>      }</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>两种场景，一个是接通电话，一个是电话hold之后，unhold的时候。都需要去调用routeHfpAudio(true).我们简化问题，只分析打开的情况。</p> 
<pre><code class="language-html hljs"> </code></pre> 
<ol><li> <p><code>static synchronized void routeHfpAudio(boolean enable) {<!-- --></code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>       if (enable &amp;&amp; !sAudioIsRouted) {<!-- --></code></p> </li><li> <p><code>           sAudioManager.setParameters("hfp_enable=true");</code></p> </li><li> <p><code>      } else if (!enable) {<!-- --></code></p> </li><li> <p><code>           sAudioManager.setParameters("hfp_enable=false");</code></p> </li><li> <p><code>      }</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>  }</code></p> </li></ol> 
<p>直接跳过中间繁琐的调用分析，欢迎查看我之前的博客。我们直接来到这里（路径都懒得贴了，搞audio的都知道）：</p> 
<p>audio_hw.c</p> 
<pre><code class="language-html hljs"> </code></pre> 
<ol><li> <p><code>static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   struct str_parms *parms;</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   //一猜就是通过等号把上面传下来的参数分割成对:hfp_enable,true</code></p> </li><li> <p><code>   parms = str_parms_create_str(kvpairs);</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   status = audio_extn_set_parameters(adev, parms);</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>hardware/qcom/audio/hal/audio_extn/audio_extn.c</p> 
<pre><code class="language-html hljs"> </code></pre> 
<ol><li> <p><code>int audio_extn_set_parameters(struct audio_device *adev,</code></p> </li><li> <p><code>                              struct str_parms *parms)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   ret = audio_extn_hfp_set_parameters(adev, parms);</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>hardware/qcom/audio/hal/audio_extn/hfp.c</p> 
<pre><code class="language-html hljs"> </code></pre> 
<ol><li> <p><code>int audio_extn_hfp_set_parameters(struct audio_device *adev, struct str_parms *parms)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   //解析字符串参数</code></p> </li><li> <p><code>   ret = str_parms_get_str(parms, AUDIO_PARAMETER_HFP_ENABLE, value,</code></p> </li><li> <p><code>                           sizeof(value));</code></p> </li><li> <p><code>   if (ret &gt;= 0) {                                                                                                                                                          </code></p> </li><li> <p><code>          if ((!strncmp(value,"true",sizeof(value))) &amp;&amp; (!hfpmod.is_hfp_running))</code></p> </li><li> <p><code>              ret = start_hfp(adev,parms);</code></p> </li><li> <p><code>          else if((!strncmp(value,"false",sizeof(value))) &amp;&amp; (hfpmod.is_hfp_running))</code></p> </li><li> <p><code>              stop_hfp(adev);</code></p> </li><li> <p><code>          else {<!-- --></code></p> </li><li> <p><code>              ...</code></p> </li><li> <p><code>          }</code></p> </li><li> <p><code>  }</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   //设置routing</code></p> </li><li> <p><code>   ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_ROUTING,</code></p> </li><li> <p><code>                               value, sizeof(value));</code></p> </li><li> <p><code>       if (ret &gt;= 0) {<!-- --></code></p> </li><li> <p><code>           val = atoi(value);</code></p> </li><li> <p><code>           if (val &gt; 0)</code></p> </li><li> <p><code>               select_devices(adev, hfpmod.ucid);</code></p> </li><li> <p><code>      }</code></p> </li><li> <p><code>   //设置hfp_volume</code></p> </li><li> <p><code>   memset(value, 0, sizeof(value));</code></p> </li><li> <p><code>   ret = str_parms_get_str(parms, AUDIO_PARAMETER_KEY_HFP_VOLUME,</code></p> </li><li> <p><code>                           value, sizeof(value));</code></p> </li><li> <p><code>   if (ret &gt;= 0) {<!-- --></code></p> </li><li> <p><code>      ...</code></p> </li><li> <p><code>       hfp_set_volume(adev, vol);</code></p> </li><li> <p><code>  }</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>也就是说routeHfpAudio的调用，最终对应着start_hfp和stop_hfp.</p> 
<p>这里我们就看看start_hfp就好。</p> 
<pre><code class="language-html hljs"> </code></pre> 
<ol><li> <p><code>static int32_t start_hfp(struct audio_device *adev,</code></p> </li><li> <p><code>                        struct str_parms *parms __unused)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   //直接来个usecase</code></p> </li><li> <p><code>   struct audio_usecase *uc_uplink_info;</code></p> </li><li> <p><code>   uc_uplink_info = (struct audio_usecase *)calloc(1, sizeof(struct audio_usecase));</code></p> </li><li> <p><code>   //初始化</code></p> </li><li> <p><code>   uc_uplink_info-&gt;id = hfpmod.ucid;</code></p> </li><li> <p><code>   uc_uplink_info-&gt;type = PCM_HFP_CALL;</code></p> </li><li> <p><code>   uc_uplink_info-&gt;stream.out = adev-&gt;primary_output;</code></p> </li><li> <p><code>   uc_uplink_info-&gt;devices = adev-&gt;primary_output-&gt;devices;</code></p> </li><li> <p><code>   uc_uplink_info-&gt;in_snd_device = SND_DEVICE_NONE;</code></p> </li><li> <p><code>   uc_uplink_info-&gt;out_snd_device = SND_DEVICE_NONE;</code></p> </li><li> <p><code>   </code></p> </li><li> <p><code>   list_add_tail(&amp;adev-&gt;usecase_list, &amp;uc_uplink_info-&gt;list);</code></p> </li><li> <p><code>   //hfpmod.ucid 的值为</code></p> </li><li> <p><code>   //USECASE_AUDIO_HFP_SCO_UPLINK(hfp_sco的上行链路的usecase)</code></p> </li><li> <p><code>   //用这个usecase去选出设备</code></p> </li><li> <p><code>   select_devices(adev, hfpmod.ucid);</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   //获取pcm设备id</code></p> </li><li> <p><code>   //上行 rx</code></p> </li><li> <p><code>   pcm_ul_rx_id = platform_get_pcm_device_id(uc_uplink_info-&gt;id, PCM_PLAYBACK);</code></p> </li><li> <p><code>   //上行 tx</code></p> </li><li> <p><code>   pcm_ul_tx_id = platform_get_pcm_device_id(uc_uplink_info-&gt;id, PCM_CAPTURE);</code></p> </li><li> <p><code>   pcm_dl_rx_id = platform_get_pcm_device_id(uc_downlink_info.id, PCM_PLAYBACK);</code></p> </li><li> <p><code>   pcm_dl_tx_id = platform_get_pcm_device_id(uc_downlink_info.id, PCM_CAPTURE);</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   //打开上行tx对应的pcm(一般是mic)</code></p> </li><li> <p><code>   hfpmod.hfp_ul_tx = pcm_open(adev-&gt;snd_card,</code></p> </li><li> <p><code>                                 pcm_ul_tx_id,</code></p> </li><li> <p><code>                                 PCM_IN, &amp;pcm_config_hfp);</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>  //另外三个打开操作类似</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>audio_hw.c中可以查到：</p> 
<p>USECASE_AUDIO_HFP_SCO_UPLINK对应的use_case_table名字:"hfp-sco"</p> 
<p>platform.c中可以查到:</p> 
<p>USECASE_AUDIO_HFP_SCO_UPLINK对应的hw_interface_table名字:</p> 
<p>"QUAT_TDM_TX_0"</p> 
<p>这些对应的mixer_paths.xml中都有:</p> 
<pre><code class="language-html hljs"> </code></pre> 
<ol><li> <p><code>&lt;path name="hfp-sco"&gt;  </code></p> </li><li> <p><code>       &lt;ctl name="QUAT_TDM_RX_2 Audio Mixer MultiMedia21" value="1" /&gt;</code></p> </li><li> <p><code>       &lt;ctl name="MultiMedia21 Mixer AUX_PCM_UL_TX" value="1" /&gt;</code></p> </li><li> <p><code>       &lt;ctl name="AUX_PCM_RX Audio Mixer MultiMedia6" value="1" /&gt;</code></p> </li><li> <p><code>       &lt;ctl name="MultiMedia6 Mixer QUAT_TDM_TX_0" value="1" /&gt;</code></p> </li><li> <p><code>   &lt;/path&gt;</code></p> </li></ol> 
<p>还有这个pcm_config_hfp的定义:</p> 
<pre><code class="language-html hljs"> </code></pre> 
<ol><li> <p><code>static struct pcm_config pcm_config_hfp = {<!-- --></code></p> </li><li> <p><code>  .channels = 1,</code></p> </li><li> <p><code>  .rate = 8000,</code></p> </li><li> <p><code>  .period_size = 240,</code></p> </li><li> <p><code>  .period_count = 2,</code></p> </li><li> <p><code>  .format = PCM_FORMAT_S16_LE,</code></p> </li><li> <p><code>  .start_threshold = 0,</code></p> </li><li> <p><code>  .stop_threshold = INT_MAX,</code></p> </li><li> <p><code>  .avail_min = 0,</code></p> </li><li> <p><code>};</code></p> </li></ol> 
<p>估计普通电话也差不多，单声道，8k采样率（窄带，宽带是这个:</p> 
<p>USECASE_AUDIO_HFP_SCO_WB_UPLINK），格式:PCM_FORMAT_S16_LE.</p> 
<p>到这里为止，pcm设备就准备完毕，可以使用了！</p> 
<p>那是什么时候开始使用这个pcm设备，调用pcm_read和pcm_write的呢？全局搜索了一遍也没看到，也没去调用audio_hw里的out_write!!!!.又仔细看了一遍start_hfp，难道是它：</p> 
<pre><code class="language-html hljs"> </code></pre> 
<ol><li> <p><code>static int32_t start_hfp(struct audio_device *adev,</code></p> </li><li> <p><code>                        struct str_parms *parms __unused)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   hfpmod.hfp_ul_tx = pcm_open(adev-&gt;snd_card,</code></p> </li><li> <p><code>                                 pcm_ul_tx_id,</code></p> </li><li> <p><code>                                 PCM_IN, &amp;pcm_config_hfp);</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>   if (pcm_start(hfpmod.hfp_ul_rx) &lt; 0) {<!-- --></code></p> </li><li> <p><code>       ALOGE("%s: pcm start for hfp ul rx failed", __func__);</code></p> </li><li> <p><code>       ret = -EINVAL;</code></p> </li><li> <p><code>       goto exit;</code></p> </li><li> <p><code>  }</code></p> </li><li> <p><code>  ...</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>这个过程中，总共pcm_open了四个设备:</p> 
<p>hfpmod.hfp_ul_rx</p> 
<p>hfpmod.hfp_ul_tx</p> 
<p>hfpmod.hfp_dl_rx</p> 
<p>hfpmod.hfp_dl_tx</p> 
<p>然后pcm_start了这四个FE(前端) PCM.</p> 
<p>tinymix中可以看到打开的通路有这些:</p> 
<pre><code class="language-html hljs"> </code></pre> 
<ol><li> <p><code>637 BOOL 1 QUAT_TDM_TX_0 Audio Mixer MultiMedia6   On</code></p> </li><li> <p><code>684 BOOL 1 QUAT_TDM_RX_2 Audio Mixer MultiMedia21   On</code></p> </li><li> <p><code>879 BOOL 1 MultiMedia6 Mixer QUAT_TDM_TX_0         On</code></p> </li><li> <p><code>987 BOOL 1 MultiMedia21 Mixer AUX_PCM_UL_TX         On</code></p> </li><li> <p><code>1027 BOOL 1 AUX_PCM_RX Audio Mixer MultiMedia6       On</code></p> </li></ol> 
<p>第一路:"QUAT_TDM_TX_0 Audio Mixer MultiMedia6"</p> 
<p>FE（前端）是MultiMedia6,BE（后端）是QUAT_TDM_TX_0，Audio Mixer表示DSP路由功能。</p> 
<p>未完待续。。。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4dd22e9a1d5d614ddfd21dcf9d35fc9d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">module ‘os‘ has no attribute ‘listdir‘   ----------------python报错解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ab215870a2e9d6607f302bf45b04bd1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RuntimeError: Address already in use</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>