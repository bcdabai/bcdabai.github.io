<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>理解 Python 中的 if __name__ == ‘__main__‘ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="理解 Python 中的 if __name__ == ‘__main__‘" />
<meta property="og:description" content="目录
1. 程序入口
2. __name__
3. __main__.py 文件与 python -m
if __name__ == &#39;__main__&#39; 简单的理解就是： 如果模块是被直接运行的，则代码块被运行，如果模块是被导入的，则代码块不被运行。
1. 程序入口 对于很多编程语言来说，程序都必须要有一个入口，比如 C，C&#43;&#43;，以及完全面向对象的编程语言 Java，C# 等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C 和 C&#43;&#43; 都需要有一个 main 函数来作为程序的入口，也就是程序的运行会从 main 函数开始。同样，Java 和 C# 必须要有一个包含 Main 方法的主类来作为程序入口。
而 Python 则有不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。
一个 Python 源码文件除了可以被直接运行（run）外，还可以作为模块（也就是库）被导入（import）。不管是导入还是直接运行，最顶层的代码都会被运行（Python 用缩进来区分代码层次）。而实际上在导入的时候，有一部分代码我们是不希望被运行的。
举一个例子来说明一下，假设我们有一个 const.py 文件，内容如下：
PI = 3.14 def main(): print &#34;PI:&#34;, PI main() 我们在这个文件里边定义了一些常量，然后又写了一个 main 函数来输出定义的常量，最后运行 main 函数就相当于对定义做一遍人工检查，看看值设置的都对不对。然后我们直接执行该文件(python const.py),输出：
PI: 3.14 现在，我们有一个 area.py 文件，用于计算圆的面积，该文件里边需要用到 const.py 文件中的 PI 变量，那么我们从 const.py 中把 PI 变量导入到 area." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7e912790a2124bac525fd0a91fd30593/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-03T16:26:53+08:00" />
<meta property="article:modified_time" content="2023-07-03T16:26:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">理解 Python 中的 if __name__ == ‘__main__‘</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%C2%A0%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3-toc" style="margin-left:0px;"><a href="#1.%C2%A0%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3" rel="nofollow">1. 程序入口</a></p> 
<p id="__name__-toc" style="margin-left:0px;"><a href="#__name__" rel="nofollow">2. __name__</a></p> 
<p id="__main__-py-python-m-toc" style="margin-left:0px;"><a href="#__main__-py-python-m" rel="nofollow">3. __main__.py 文件与 python -m</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <p><code>if __name__ == '__main__'</code> 简单的理解就是： <strong>如果模块是被直接运行的，则代码块被运行，如果模块是被导入的，则代码块不被运行</strong>。</p> 
</blockquote> 
<h2 id="1.%C2%A0%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3">1. 程序入口</h2> 
<p>        对于很多编程语言来说，程序都必须要有一个入口，比如 C，C++，以及完全面向对象的编程语言 Java，C# 等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C 和 C++ 都需要有一个 main 函数来作为程序的入口，也就是程序的运行会从 main 函数开始。同样，Java 和 C# 必须要有一个包含 Main 方法的主类来作为程序入口。</p> 
<p>        而 Python 则有不同，它属于<strong>脚本语言</strong>，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。</p> 
<p>        一个 Python 源码文件除了可以被直接运行（run）外，还可以作为模块（也就是库）被导入（import）。不管是导入还是直接运行，最顶层的代码都会被运行（Python 用缩进来区分代码层次）。而实际上在导入的时候，有一部分代码我们是不希望被运行的。</p> 
<p>举一个例子来说明一下，假设我们有一个 const.py 文件，内容如下：</p> 
<pre><code>PI = 3.14

def main():
    print "PI:", PI

main()
</code></pre> 
<p>我们在这个文件里边定义了一些常量，然后又写了一个 main 函数来输出定义的常量，最后运行 main 函数就相当于对定义做一遍人工检查，看看值设置的都对不对。然后我们直接执行该文件(python const.py),输出：</p> 
<pre><code>PI: 3.14
</code></pre> 
<p>现在，我们有一个 area.py 文件，用于计算圆的面积，该文件里边需要用到 const.py 文件中的 PI 变量，那么我们从 const.py 中把 PI 变量导入到 area.py 中：</p> 
<pre><code>from const import PI

def calc_round_area(radius):
    return PI * (radius ** 2)

def main():
    print "round area: ", calc_round_area(2)

main()
</code></pre> 
<p>运行 area.py，输出结果：</p> 
<pre><code>PI: 3.14
round area:  12.56
</code></pre> 
<p>可以看到，const 中的 main 函数也被运行了，实际上我们是不希望它被运行，提供 main 也只是为了对常量定义进行下测试。这时，<code>if __name__ == '__main__'</code> 就派上了用场。把 const.py 改一下：</p> 
<pre><code>PI = 3.14

def main():
    print "PI:", PI

if __name__ == "__main__":
    main()
</code></pre> 
<p>然后再运行 area.py，输出如下：</p> 
<pre><code>round area:  12.56
</code></pre> 
<p>再运行下 const.py，输出如下：</p> 
<pre><code>PI: 3.14
</code></pre> 
<p>这才是我们想要的效果。</p> 
<p><code>if __name__ == '__main__'</code> 就相当于是 Python <strong>模拟的程序入口</strong>。Python 本身并没有规定这么写，这只是一种编码习惯。由于模块之间相互引用，不同模块可能都有这样的定义，而入口程序只能有一个。到底哪个入口程序被选中，这取决于 <code>__name__</code> 的值。</p> 
<hr> 
<h2 id="__name__">2. __name__</h2> 
<p><code>__name__</code> 是内置变量，用于表示当前模块的名字，同时还能反映一个包的结构。来举个例子，假设有如下一个包：</p> 
<pre><code>a
├── b
│   ├── c.py
│   └── __init__.py
└── __init__.py
</code></pre> 
<p>目录中所有 py 文件的内容都为：</p> 
<pre><code>print __name__
</code></pre> 
<p>我们执行 <code>python -c "import a.b.c"</code>，输出结果：</p> 
<pre><code>a
a.b
a.b.c
</code></pre> 
<p>由此可见，<code>__name__</code> 可以清晰的反映一个模块在包中的层次。其实，所谓模块名就是 import 时需要用到的名字，例如：</p> 
<pre><code>import tornado
import tornado.web
</code></pre> 
<p>这里的 tornado 和 tornado.web 就被称为模块的模块名。</p> 
<p>如果一个模块被直接运行，则其没有包结构，其 <code>__name__</code> 值为 <code>__main__</code>。例如在上例中，我们直接运行 c.py 文件（python a/b/c.py），输出结果如下：</p> 
<pre><code>__main__
</code></pre> 
<blockquote> 
 <p>所以，<code>if __name__ == '__main__'</code> 我们简单的理解就是： <strong>如果模块是被直接运行的，则代码块被运行，如果模块是被导入的，则代码块不被运行</strong>。</p> 
</blockquote> 
<p>实际上，这个问题还可以衍生出其他的一些知识点，例如 <code>__main__.py</code> 文件与 Python 的 <code>-m</code> 参数。</p> 
<h2 id="__main__-py-python-m">3. __main__.py 文件与 python -m</h2> 
<p>Python 的 <code>-m</code> 参数用于将一个模块或者包作为一个脚本运行，而 <code>__main__.py</code> 文件则相当于是一个包的”入口程序“。</p> 
<p>首先我们需要来看看 <code>python xxx.py</code> 与 <code>python -m xxx.py</code> 的区别。两种运行 Python 程序的方式的不同点在于，<strong>一种是直接运行，一种是当做模块来运行。</strong></p> 
<p>先来看一个简单的例子，假设有一个 Python 文件 run.py，其内容如下：</p> 
<pre><code>import sys
print sys.path
</code></pre> 
<p>我们用直接运行的方式启动（python run.py），输出结果(为了说明问题，输出结果只截取了重要部分，下同)：</p> 
<pre><code>['/home/huoty/aboutme/pythonstudy/main', ...]
</code></pre> 
<p>然后以模块的方式运行（python -m run.py）:</p> 
<pre><code>['', ...]
/usr/bin/python: No module named run.py
</code></pre> 
<p>由于输出结果只列出了关键的部分，应该很容易看出他们之间的差异。直接运行是把 run.py 文件所在的目录放到了 sys.path 属性中。以模块方式运行是把你输入命令的目录（也就是当前工作路径），放到了 sys.path 属性中。以模块方式运行还有一个不同的地方是，多出了一行 <code>No module named run.py</code> 的错误。实际上以模块方式运行时，Python 先对 run.py 执行一遍 import，所以 <code>print sys.path</code> 被成功执行，然后 Python 才尝试运行 run.py 模块，但是，在 path 变量中并没有 run.py 这个模块，所以报错。而正确的运行方式，应该是 <code>python -m run</code>.</p> 
<p>这个例子并不能明显的说明问题。接着我们来看看 <code>__main__.py</code> 的作用。</p> 
<p>仍然先看例子，有如下一个包：</p> 
<pre><code>package
├── __init__.py
└── __main__.py
</code></pre> 
<ul><li>__init__.py</li></ul> 
<pre><code>import sys
print "__init__"
print sys.path
</code></pre> 
<ul><li>__main__.py</li></ul> 
<pre><code>import sys
print "__main__"
print sys.path
</code></pre> 
<p>用 <code>python -m package</code> 运行结果：</p> 
<pre><code>__init__
['', ...]
__main__
['', ...]
</code></pre> 
<p>用 <code>python package</code> 运行结果：</p> 
<pre><code>__main__
['package', ...]
</code></pre> 
<p>然后我们来总结一下：</p> 
<ul><li>1、 <strong>加上 -m 参数时会把当前工作目录添加到 sys.path 中，而不加时则会把脚本所在目录添加到 sys.path 中</strong>。</li><li>2、 <strong>加上 -m 参数时 Python 会先将模块或者包导入，然后再执行</strong></li><li>3、 <strong>__main__.py 文件是一个包或者目录的入口程序。</strong>不管是用 <code>python package</code> 还是用 <code>python -m package</code> 运行时，__main__.py 文件总是被执行。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72b9415879ee303094f38e4363816695/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最全的redis常用命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75d1f372d462db2df8109f304f56a501/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">牛客网_python入门_01</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>