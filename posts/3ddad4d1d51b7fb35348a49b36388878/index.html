<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python实现适配器模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python实现适配器模式" />
<meta property="og:description" content="请关注【来玩AI】公众号体验人工智能
来玩AI &gt;&gt;&gt;
Python实现适配器模式 简介Python实现适配器模式适配器的应用场景3.1 将不兼容的接口转换成可兼容的接口3.2 将已有的接口进行二次封装3.3 在不修改原有代码的情况下，增加新的功能3.4 软件系统扩展时的接口协作3.5 对象或类的子系统需要独立于其它子系统或者客户端 简介 适配器模式是一种常用的结构型设计模式，它的主要目的是将一个类的接口转化为客户端所期望的另一个接口。适配器可以充当两个不兼容接口之间的桥梁，使得原本由于接口不匹配而无法一起工作的类能够协同工作。
适配器模式通常包含几个组成部分，其中最关键的是适配器类，该类实现了客户端所期望的接口，并持有适配者（即需要被适配的类）的一个实例引用。当客户端调用适配器的方法时，该方法会通过适配者的实例来调用适配者的方法，以完成客户端的请求。
适配器模式的优点在于它可以让客户端与适配者解耦，从而提高代码的复用性和灵活性。它还可以简化系统设计，使得系统的不同部分可以更加方便地进行集成和协同工作。适配器模式的缺点在于它可能会增加系统复杂性，并且在使用多个适配器时需要谨防适配器的复杂嵌套，以避免代码难以维护。
Python实现适配器模式 在 Python 中实现适配器可以使用面向对象编程的方式，代码如下：
class Target: &#34;&#34;&#34; 客户端所期望使用的接口 &#34;&#34;&#34; def target_method(self): pass class Adaptee: &#34;&#34;&#34; 需要被适配的类 &#34;&#34;&#34; def adaptee_method(self): pass class Adapter(Target): &#34;&#34;&#34; 适配器类，将 Adaptee 类的接口转化为 Target 类的接口 &#34;&#34;&#34; def __init__(self, adaptee): self.adaptee = adaptee def target_method(self): self.adaptee.adaptee_method() 在上面的代码中，我们定义了一个 Target 接口，以及一个需要被适配的 Adaptee 类和一个适配器 Adapter 类。Adapter 类持有一个 Adaptee 的实例引用，并实现了 Target 接口的方法，该方法会通过 Adaptee 的实例来调用 Adaptee 的方法，从而完成客户端的请求。
使用时，我们可以先创建一个 Adaptee 的实例，然后将其传入 Adapter 类中，以创建一个适配器实例。最后，我们就可以使用适配器实例来调用 Target 接口的方法了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3ddad4d1d51b7fb35348a49b36388878/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-31T09:40:33+08:00" />
<meta property="article:modified_time" content="2023-05-31T09:40:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python实现适配器模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>请关注<font color="BLUE">【来玩AI】</font>公众号体验人工智能<br> <a href="https://www.zhiyidata.cn/chatgpt/play" rel="nofollow">来玩AI &gt;&gt;&gt;</a></p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>Python实现适配器模式</h4> 
 <ul><li><a href="#_7" rel="nofollow">简介</a></li><li><a href="#Python_13" rel="nofollow">Python实现适配器模式</a></li><li><a href="#_57" rel="nofollow">适配器的应用场景</a></li><li><ul><li><a href="#31__60" rel="nofollow">3.1 将不兼容的接口转换成可兼容的接口</a></li><li><a href="#32__63" rel="nofollow">3.2 将已有的接口进行二次封装</a></li><li><a href="#33__66" rel="nofollow">3.3 在不修改原有代码的情况下，增加新的功能</a></li><li><a href="#34__69" rel="nofollow">3.4 软件系统扩展时的接口协作</a></li><li><a href="#35__72" rel="nofollow">3.5 对象或类的子系统需要独立于其它子系统或者客户端</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/e4/27/2CYGeCCh_o.jpg" alt="图片来源于来玩AI文生图"></p> 
<h2><a id="_7"></a>简介</h2> 
<p>适配器模式是一种常用的结构型设计模式，它的主要目的是将一个类的接口转化为客户端所期望的另一个接口。适配器可以充当两个不兼容接口之间的桥梁，使得原本由于接口不匹配而无法一起工作的类能够协同工作。</p> 
<p>适配器模式通常包含几个组成部分，其中最关键的是适配器类，该类实现了客户端所期望的接口，并持有适配者（即需要被适配的类）的一个实例引用。当客户端调用适配器的方法时，该方法会通过适配者的实例来调用适配者的方法，以完成客户端的请求。</p> 
<p>适配器模式的优点在于它可以让客户端与适配者解耦，从而提高代码的复用性和灵活性。它还可以简化系统设计，使得系统的不同部分可以更加方便地进行集成和协同工作。适配器模式的缺点在于它可能会增加系统复杂性，并且在使用多个适配器时需要谨防适配器的复杂嵌套，以避免代码难以维护。</p> 
<h2><a id="Python_13"></a>Python实现适配器模式</h2> 
<p>在 Python 中实现适配器可以使用面向对象编程的方式，代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Target</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    客户端所期望使用的接口
    """</span>
    
    <span class="token keyword">def</span> <span class="token function">target_method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>


<span class="token keyword">class</span> <span class="token class-name">Adaptee</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    需要被适配的类
    """</span>
    
    <span class="token keyword">def</span> <span class="token function">adaptee_method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>


<span class="token keyword">class</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span>Target<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    适配器类，将 Adaptee 类的接口转化为 Target 类的接口
    """</span>
    
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> adaptee<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>adaptee <span class="token operator">=</span> adaptee
        
    <span class="token keyword">def</span> <span class="token function">target_method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>adaptee<span class="token punctuation">.</span>adaptee_method<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>在上面的代码中，我们定义了一个 Target 接口，以及一个需要被适配的 Adaptee 类和一个适配器 Adapter 类。Adapter 类持有一个 Adaptee 的实例引用，并实现了 Target 接口的方法，该方法会通过 Adaptee 的实例来调用 Adaptee 的方法，从而完成客户端的请求。</p> 
<p>使用时，我们可以先创建一个 Adaptee 的实例，然后将其传入 Adapter 类中，以创建一个适配器实例。最后，我们就可以使用适配器实例来调用 Target 接口的方法了。</p> 
<pre><code class="prism language-python">adaptee <span class="token operator">=</span> Adaptee<span class="token punctuation">(</span><span class="token punctuation">)</span>
adapter <span class="token operator">=</span> Adapter<span class="token punctuation">(</span>adaptee<span class="token punctuation">)</span>
adapter<span class="token punctuation">.</span>target_method<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h2><a id="_57"></a>适配器的应用场景</h2> 
<p>适配器模式是一种常用的结构型设计模式，主要用于将一个类的接口（或多个接口）转换成客户端所期望的接口。适配器模式的应用场景包括：</p> 
<h3><a id="31__60"></a>3.1 将不兼容的接口转换成可兼容的接口</h3> 
<p>解决在接口改变或者接口不同的系统之间进行数据交互的问题。例如，需要连接不同品牌的音响设备、计算机外设、数据库等。</p> 
<h3><a id="32__63"></a>3.2 将已有的接口进行二次封装</h3> 
<p>符合客户端的使用需求。例如，可以对第三方库的接口进行封装，使其更符合自己的开发规范或需要。</p> 
<h3><a id="33__66"></a>3.3 在不修改原有代码的情况下，增加新的功能</h3> 
<p>例如，为一个软件添加新的功能模块，但是不能暴露新的API接口，此时可以采用适配器模式实现。</p> 
<h3><a id="34__69"></a>3.4 软件系统扩展时的接口协作</h3> 
<p>例如，当扩展软件系统时，需要连接多个接口进行数据传递，这时就可以采用适配器模式来进行接口协同工作。</p> 
<h3><a id="35__72"></a>3.5 对象或类的子系统需要独立于其它子系统或者客户端</h3> 
<p>由于系统中的不同部分之间的关系会随时间改变而发生变化，因此通过介绍一个中间适配层，可以促使这些部分不会相互了解，并依此可以提高灵活性和可重用性。</p> 
<hr> 
<blockquote> 
 <p>请关注【来玩AI】公众号体验人工智能<br> <a href="https://www.zhiyidata.cn/chatgpt/play" rel="nofollow">来玩AI &gt;&gt;&gt;</a><br> https://www.zhiyidata.cn/chatgpt/play</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb593e24b3e5a37861659c87f8347b84/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pyhton打包成exe文件，failed to execute script ‘start‘ due to unhandled exception:No module named XXX。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71e94b06910b017eaae32ce2e8be31c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaScript 删除数组中指定元素(5种方法)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>