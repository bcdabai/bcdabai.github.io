<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【经典算法】N皇后问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【经典算法】N皇后问题" />
<meta property="og:description" content="✨前言✨ N皇后问题经典的解决方案是暴力递归，其时间复杂度是O(2^n),因此常用来测试计算机的算力。今天我会给大家带来经典方法的详解，也会给大家展示N皇后优化后的大神解法。做一道经典题目，来一场思维旅行。
目录
✨前言✨
💡题目：
🔑传统解法：
代码示例：
大神解法：
💡题目： n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。
力扣题目链接： N皇后问题
🔑传统解法： N皇后的传统解法是暴力递归，在我看来暴力递归的精髓就是尝试，N皇后问题要求任意两个皇后都不共行，不共列，不共斜线。因此在一个N*N的棋盘上放N个皇后，因此可以看成由上到下每一行放一个皇后的尝试模型。
为了更形象的解决这一问题，我们先来看一下图：（来自力扣）
因为我们尝试模型是遍历每一行，每一行尝试放一个皇后，所以所有皇后一定不共行，只需保证在尝试第i个皇后时，第i个皇后与第i-1个皇后不共列，不共斜线，因此我们应该在尝试0-i-1个皇后时，记录下其位置，这样在放第i个皇后时，就可以根据之前所有已经放好的皇后决定第i个皇后应该放哪里。
所以设计的递归函数的参数有三个：
1：变量i表示现在在尝试第i行放第i个皇后
2：变量n表示要放皇后的总数，是一个固定的值，用来标记递归终止条件。
3：数组 result[i] 记录已经放好的皇后在哪一行哪一列，表示第i个皇后所在的列数。
代码示例： //暴力递归：N皇后问题的朴素解法 //1:当你处理第i行时，我们默认[0...i-1]的皇后都有效摆好了 //2:当你摆第i个皇后时，你只需要考虑i个皇后与其它i-1个皇后不共列和不共斜线 //三个参数：record[i] 记录下第i个皇后所在的列数 //int n表示是几阶皇后问题 //int i表示当前处理到了哪一阶 public static int process1(int i,int n,int[] record){ if(i==n){//当i等于n时，说明N个皇后全部摆放完毕，此时应返回一种解法 return 1; } int res=0; //现在轮到摆第i个皇后， //通过遍历第i行的每一列试探每一个位置是否能放皇后 for(int j=0;j&lt;n;j&#43;&#43;){ if(isValid(record,i,j)){//通过isValid函数来判断这个位置是否能放皇后 record[i]=j; res&#43;=process1(i&#43;1,n,record); } } return res; } public static boolean isValid(int[] record,int i,int j){ //判断逻辑：如果这个位置与之前的i-1个皇后同列或者共斜线则不能放皇后 for(int k=0;k&lt;i;k&#43;&#43;){ //判断共列以及共斜线 if(record[k]==j||(Math." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f48c55b6cb700ee1ac4971a4e24142aa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-25T17:05:39+08:00" />
<meta property="article:modified_time" content="2021-11-25T17:05:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【经典算法】N皇后问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E2%9C%A8%E5%89%8D%E8%A8%80%E2%9C%A8">✨前言✨</h2> 
<p><strong>        N皇后问题经典的解决方案是暴力递归，其时间复杂度是O(2^n),因此常用来测试计算机的算力。今天我会给大家带来经典方法的详解，也会给大家展示N皇后优化后的大神解法。做一道经典题目，来一场思维旅行。</strong></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E2%9C%A8%E5%89%8D%E8%A8%80%E2%9C%A8-toc" style="margin-left:0px;"><a href="#%E2%9C%A8%E5%89%8D%E8%A8%80%E2%9C%A8" rel="nofollow" title="✨前言✨">✨前言✨</a></p> 
<p id="%F0%9F%92%A1%E9%A2%98%E7%9B%AE%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%F0%9F%92%A1%E9%A2%98%E7%9B%AE%EF%BC%9A" rel="nofollow" title="💡题目：">💡题目：</a></p> 
<p id="%F0%9F%94%91%E4%BC%A0%E7%BB%9F%E8%A7%A3%E6%B3%95%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%F0%9F%94%91%E4%BC%A0%E7%BB%9F%E8%A7%A3%E6%B3%95%EF%BC%9A" rel="nofollow" title="🔑传统解法：">🔑传统解法：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A" rel="nofollow" title="代码示例：">代码示例：</a></p> 
<p id="%E5%A4%A7%E7%A5%9E%E8%A7%A3%E6%B3%95%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%A4%A7%E7%A5%9E%E8%A7%A3%E6%B3%95%EF%BC%9A" rel="nofollow" title="大神解法：">大神解法：</a></p> 
<hr id="hr-toc"> 
<hr> 
<h2 id="%F0%9F%92%A1%E9%A2%98%E7%9B%AE%EF%BC%9A">💡题目：</h2> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</strong></span></p> 
</blockquote> 
<p><strong><span style="color:#0d0016;">力扣题目链接：</span></strong>  <a class="link-info" href="https://leetcode-cn.com/problems/n-queens-ii/" rel="nofollow">N皇后问题</a></p> 
<hr> 
<h2 id="%F0%9F%94%91%E4%BC%A0%E7%BB%9F%E8%A7%A3%E6%B3%95%EF%BC%9A">🔑传统解法：</h2> 
<p><strong>N皇后的传统解法是暴力递归，在我看来暴力递归的精髓就是尝试，N皇后问题要求任意两个皇后都不共行，不共列，不共斜线。因此在一个N*N的棋盘上放N个皇后，因此可以看成由上到下每一行放一个皇后的尝试模型。</strong></p> 
<p><strong><span style="color:#fe2c24;">为了更形象的解决这一问题，我们先来看一下图：（来自力扣）</span></strong></p> 
<p style="text-align:center;"><strong><span style="color:#fe2c24;"><img alt="" src="https://images2.imgbox.com/c2/08/87YU0j5W_o.png"></span></strong></p> 
<p>       <strong>因为我们尝试模型是遍历每一行，每一行尝试放一个皇后，所以所有皇后一定不共行，只需保证在尝试第i个皇后时，第i个皇后与第i-1个皇后不共列，不共斜线，因此我们应该在尝试0-i-1个皇后时，记录下其位置，这样在放第i个皇后时，就可以根据之前所有已经放好的皇后决定第i个皇后应该放哪里。</strong></p> 
<p><strong>所以设计的递归函数的参数有三个：</strong></p> 
<p><strong>     <span style="color:#fe2c24;">1：变量i表示现在在尝试第i行放第i个皇后</span></strong></p> 
<p><strong><span style="color:#fe2c24;">     2：变量n表示要放皇后的总数，是一个固定的值，用来标记递归终止条件。</span></strong></p> 
<p><strong><span style="color:#fe2c24;">     3：数组 result[i] 记录已经放好的皇后在哪一行哪一列，表示第i个皇后所在的列数。</span></strong></p> 
<p></p> 
<h3 id="%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A">代码示例：</h3> 
<pre><code class="language-java">    //暴力递归：N皇后问题的朴素解法

    //1:当你处理第i行时，我们默认[0...i-1]的皇后都有效摆好了
    //2:当你摆第i个皇后时，你只需要考虑i个皇后与其它i-1个皇后不共列和不共斜线

    //三个参数：record[i] 记录下第i个皇后所在的列数
    //int n表示是几阶皇后问题
    //int i表示当前处理到了哪一阶

    public static int process1(int i,int n,int[] record){
        if(i==n){//当i等于n时，说明N个皇后全部摆放完毕，此时应返回一种解法
            return 1;
        }
        int res=0;
        //现在轮到摆第i个皇后，
        //通过遍历第i行的每一列试探每一个位置是否能放皇后
        for(int j=0;j&lt;n;j++){
            if(isValid(record,i,j)){//通过isValid函数来判断这个位置是否能放皇后
                record[i]=j;
                res+=process1(i+1,n,record);
            }
        }
        return  res;
    }
    public static boolean isValid(int[] record,int i,int j){
        //判断逻辑：如果这个位置与之前的i-1个皇后同列或者共斜线则不能放皇后
        for(int k=0;k&lt;i;k++){
            //判断共列以及共斜线
            if(record[k]==j||(Math.abs(k-i)==Math.abs(record[k]-j))){
                return false;
            }
        }
        return true;
    }</code></pre> 
<hr> 
<h2 id="%E5%A4%A7%E7%A5%9E%E8%A7%A3%E6%B3%95%EF%BC%9A">大神解法：</h2> 
<p><strong><span style="color:#fe2c24;">我们可以通过位运算来加速算法的常数时间操作。</span></strong></p> 
<pre><code class="language-java">//n皇后问题大神解法
    //利用位运算加速，虽然时间复杂度任然是O（2^n）但是其常数时间要低的多
    //思路：默认每一次递归都能在每一行正确放置一个皇后
    //这种N皇后的效率比朴素解法要高
    //limit 范围限制  例如8皇后问题，那么其二进制序列的后8位全是1，左边其他位全是无效位
    //colLim 列限制   二进制序列中为0的地方标志这一列还没有放过皇后，如果是1表示这一列已经放了皇后
    //leftDiaLim左斜线限制    表示由于放了0-i-1个皇后，而导致在放第i个皇后时，由于左斜线限制，
    //                      使得第i行不能放皇后的列全标记为1
    //rightDiaLim 右斜线限制  同理
    public static int quickNQueue(int N){
        if(N&lt;1||N&gt;32){//因为int最多32个字节，超过32皇后问题要把in改成long
            return 0;
        }
        int limit=N==32?-1:(1&lt;&lt;N)-1;//定义出limit n皇后问题则limit的后n为全是1其他为全为0
       return process2(limit,0,0,0);
    }
    //因为我们要用位运算来加速，因此递归函数所有整型参数都应该看成0-1构成的序列
    public static int process2(int limit,int colLim,
                               int leftDiaLim,int rightDiaLim){
        if(colLim==limit){
            return 1;
        }
        int res=0;
        int pos=limit&amp;(~(colLim|leftDiaLim|rightDiaLim));//在范围内可以放皇后的位置全标记位1
        int mostRightOne=0;
        while(pos!=0){
            //摆第i个皇后逻辑
            //在pos中二进制序列为1的位置能放皇后，我们每一次取最右侧的1位置放皇后
            mostRightOne=pos&amp;(~pos+1);//拿出最右侧的一个1其它位全变成0，并在这个位置放皇后
            pos-=mostRightOne;//pos最右侧为1的位置改成0，说明这个位置已经放了皇后

            //更新参数直接递归摆剩下所有的皇后
            res+=process2(
                    limit,colLim|mostRightOne,//这一列已经放了皇后，标记为1
                    (leftDiaLim|rightDiaLim)&lt;&lt;1,//更新这个皇后的左斜线限制
                    (rightDiaLim|mostRightOne)&gt;&gt;&gt;1//更新这个皇后的右斜线限制
            );
        }
        return res;
    }</code></pre> 
<p></p> 
<h3>一道练习题：</h3> 
<p><strong>做一道题目来巩固所学知识吧！</strong></p> 
<p><strong>力扣链接：<a class="link-info" href="https://leetcode-cn.com/problems/eight-queens-lcci/" rel="nofollow">剑指offer 8皇后问题</a></strong></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>由于本人水平十分有限，若有错误请即使告知！如果有帮助别忘了，万分感谢。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>点赞👍         收藏✨    关注✌</strong></span></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be92a2a59fec99c04ba1d1906995a66d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2021-12-3【数据结构/严蔚敏】【弗洛伊德（Floyd）】【代码实现算法7.16】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eaf4f5ae3d542bf49263d852335d5683/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vuetify——解决点击v-combobox框外侧数据更新问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>