<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mockito的使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mockito的使用" />
<meta property="og:description" content="一：创建mock/spy对象 0：概述 Mockito可以帮助我们方便的创建被测对象、mock对象和spy对象。
创建被测对象： 先解释一下被测对象：就是单元测试中我们想要测试的那个类。如xxxService、xxxUtils等等。使用@InjectMocks注解创建： 配合@RunWith(MockitoJUnitRunner.class)使用或在@Before方法中使用MockitoAnnotations.openMocks(this)来激活Mockito 注解的相关功能。如果同时也使用了@Mock注解或者@Spy注解。Mockito可以方便的将这两个注解生成的对象注入到@InjectMocks注解的对象的成员变量中。直接创建： 当然我们可以直接new一个被测对象，但是我们不能方便的使用Mockito为我们提供的自动注入成员变量的功能了。当然我们可以手动的现在这些注入的工作。创建mock对象： mock对象：一般是被测对象依赖的对象（比如被测对象的成员变量）。使用@Mock注解： 配合@RunWith(MockitoJUnitRunner.class)使用或在@Before方法中使用MockitoAnnotations.openMocks(this)来激活Mockito 注解的相关功能。被@Mock注解的对象会被自动注入到@InjectMocks注解生成的被测对象中。使用Mockito.mock(); 生成的mock对象需要手动配置到被测对象中，不推荐。注意： mock对象中的方法被调用时默认会返回对应类型对象的空值。方法实际的代码不会被执行。当前如果我们想要执行实际的代码也是可以的： 我么可以先对此方法进行存根操作，此时使用doCallRealMethod()或者thenCallRealMethod()方法即可。下文会具体描述如何操作。也可以通过指定返回值策略（Mockito.CALLS_REAL_METHODS）的方式实现。即创建mock对象时指定返回值策略为Mockito.CALLS_REAL_METHODS。mock对象中的方法被调用时默认会返回对应类型对象的空值。许多情况下当我们不对某个方进行存根时那么返回的值就是null，测试过程中就会产生NPE。但是我们可以在创建mock对象时指定返回值生成策略（Answer策略）。下文会具体描述如何操作。创建spy对象： spy对象：部分mock的对象。一般是被测对象依赖的对象（比如被测对象的成员变量）。使用@Spy注解： 配合@RunWith(MockitoJUnitRunner.class)使用或在@Before方法中使用MockitoAnnotations.openMocks(this)来激活Mockito 注解的相关功能。被@Spy注解的对象会被自动注入到@InjectMocks注解生成的被测对象中。使用Mockito.spy(); 生成的spy对象需要手动配置到被测对象中，不推荐。注意： spy对象中的方法被调用时默认情况下方法实际的代码会被执行。当前如果我们想要不执行实际的代码也是可以的： 我么可以先对此方法进行存根操作，此时使用doXXXX()方法即可（注意不要使用或者thenXXXX()方法，会给我们带来麻烦：实际的代码会在此时被调用一次）。下文会具体描述如何操作。 1：创建mock对象 使用Mockito.mock()方法。
//org.mockito.Mockito.mock(java.lang.Class&lt;T&gt;) //org.mockito.Mockito.mock(java.lang.Class&lt;T&gt;, java.lang.String) //org.mockito.Mockito.mock(java.lang.Class&lt;T&gt;, org.mockito.stubbing.Answer) //org.mockito.Mockito.mock(java.lang.Class&lt;T&gt;, org.mockito.MockSettings) //方式1 Foo foo1 = Mockito.mock(Foo.class); //方式2：给mock指定名称 Foo foo2 = Mockito.mock(Foo.class, &#34;mock_1&#34;); //方式3：给mock指定自定义返回逻辑 Foo foo3 = Mockito.mock(Foo.class, new Answer() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { //自定义返回逻辑 return null; } }); //方式4：使用MockSettings配置当前mock Foo foo4 = Mockito.mock(Foo.class, Mockito.withSettings().defaultAnswer(Mockito.RETURNS_SMART_NULLS)); 复制代码 使用@InjectMocks和@Mock注解。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8646c80acdd24e4e906dc76251c0fb88/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-11T10:51:41+08:00" />
<meta property="article:modified_time" content="2021-11-11T10:51:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mockito的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一：创建mock/spy对象</h3> 
<h4>0：概述</h4> 
<p>Mockito可以帮助我们方便的创建<strong>被测对象</strong>、<strong>mock对象</strong>和<strong>spy对象</strong>。</p> 
<ul><li>创建被测对象： 
  <ul><li>先解释一下被测对象：就是单元测试中我们想要测试的那个类。如xxxService、xxxUtils等等。</li><li>使用@InjectMocks注解创建： 
    <ul><li>配合<code>@RunWith(MockitoJUnitRunner.class)</code>使用或在<code>@Before</code>方法中使用<code>MockitoAnnotations.openMocks(this)</code>来激活Mockito 注解的相关功能。</li><li>如果同时也使用了@Mock注解或者@Spy注解。Mockito可以方便的将这两个注解生成的对象注入到@InjectMocks注解的对象的成员变量中。</li></ul></li><li>直接创建： 
    <ul><li>当然我们可以直接new一个被测对象，但是我们不能方便的使用Mockito为我们提供的自动注入成员变量的功能了。当然我们可以手动的现在这些注入的工作。</li></ul></li></ul></li><li>创建mock对象： 
  <ul><li>mock对象：一般是被测对象依赖的对象（比如被测对象的成员变量）。</li><li>使用@Mock注解： 
    <ul><li>配合<code>@RunWith(MockitoJUnitRunner.class)</code>使用或在<code>@Before</code>方法中使用<code>MockitoAnnotations.openMocks(this)</code>来激活Mockito 注解的相关功能。</li><li>被@Mock注解的对象会被自动注入到@InjectMocks注解生成的被测对象中。</li></ul></li><li>使用Mockito.mock(); 
    <ul><li>生成的mock对象需要手动配置到被测对象中，不推荐。</li></ul></li><li>注意： 
    <ul><li>mock对象中的方法被调用时默认会返回对应类型对象的空值。方法实际的代码不会被执行。当前如果我们想要执行实际的代码也是可以的： 
      <ul><li>我么可以先对此方法进行存根操作，此时使用doCallRealMethod()或者thenCallRealMethod()方法即可。下文会具体描述如何操作。</li><li>也可以通过指定返回值策略（Mockito.CALLS_REAL_METHODS）的方式实现。即创建mock对象时指定返回值策略为Mockito.CALLS_REAL_METHODS。</li></ul></li><li>mock对象中的方法被调用时默认会返回对应类型对象的空值。许多情况下当我们不对某个方进行存根时那么返回的值就是null，测试过程中就会产生NPE。但是我们可以在创建mock对象时指定返回值生成策略（Answer策略）。下文会具体描述如何操作。</li></ul></li></ul></li><li>创建spy对象： 
  <ul><li>spy对象：部分mock的对象。一般是被测对象依赖的对象（比如被测对象的成员变量）。</li><li>使用@Spy注解： 
    <ul><li>配合<code>@RunWith(MockitoJUnitRunner.class)</code>使用或在<code>@Before</code>方法中使用<code>MockitoAnnotations.openMocks(this)</code>来激活Mockito 注解的相关功能。</li><li>被@Spy注解的对象会被自动注入到@InjectMocks注解生成的被测对象中。</li></ul></li><li>使用Mockito.spy(); 
    <ul><li>生成的spy对象需要手动配置到被测对象中，不推荐。</li></ul></li><li>注意： 
    <ul><li>spy对象中的方法被调用时默认情况下方法实际的代码<strong>会被执行</strong>。当前如果我们想要<strong>不执行</strong>实际的代码也是可以的： 
      <ul><li>我么可以先对此方法进行存根操作，此时使用doXXXX()方法即可（注意不要使用或者thenXXXX()方法，会给我们带来麻烦：实际的代码会在此时被调用一次）。下文会具体描述如何操作。</li></ul></li></ul></li></ul></li></ul> 
<h4>1：创建mock对象</h4> 
<ul><li> <p>使用Mockito.mock()方法。</p> <pre><code>        //org.mockito.Mockito.mock(java.lang.Class&lt;T&gt;)
        //org.mockito.Mockito.mock(java.lang.Class&lt;T&gt;, java.lang.String)
        //org.mockito.Mockito.mock(java.lang.Class&lt;T&gt;, org.mockito.stubbing.Answer)
        //org.mockito.Mockito.mock(java.lang.Class&lt;T&gt;, org.mockito.MockSettings)
        
        //方式1
        Foo foo1 = Mockito.mock(Foo.class);
        //方式2：给mock指定名称
        Foo foo2 = Mockito.mock(Foo.class, "mock_1");
        //方式3：给mock指定自定义返回逻辑
        Foo foo3 = Mockito.mock(Foo.class, new Answer() {
            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                //自定义返回逻辑
                return null;
            }
        });
        //方式4：使用MockSettings配置当前mock
        Foo foo4 = Mockito.mock(Foo.class, Mockito.withSettings().defaultAnswer(Mockito.RETURNS_SMART_NULLS));
复制代码</code></pre> </li><li> <p>使用@InjectMocks和@Mock注解。</p> 
  <ul><li>被@InjectMocks注解的对象就是要被我们测试的对象，它会被自动的实例化。且其包含的成员变量会被相应的@Mock注解的对象自动赋值。注意观察下面的示例：</li><li>注意使用了<code>@RunWith(MockitoJUnitRunner.class)</code>注解。</li></ul><pre><code>public class Foo {

    private Bar bar;

    public int sum(int a, int b) {
        return bar.add(a, b);
    }
}
复制代码</code></pre> <pre><code>public class Bar {

    public int add(int a, int b) {
        return a + b;
    }
}
复制代码</code></pre> <pre><code>//注意我们使用了MockitoJUnitRunner
@RunWith(MockitoJUnitRunner.class)
public class MockitoTest {
  	//foo 对象内部的成员变量会自动被 @Mock 注解的生成的对象注入。
    @InjectMocks
    private Foo foo;

  	//bar 对象会自动的注入到 @InjectMocks 注解的对象的成员变量中去。
    @Mock
    private Bar bar;

    @Test
    public void mockTest() {
      	//先对mock对象的待测方法进行存根，当真正执行到mock对象的此方法时
      	//会直接返回存根的结果而不会调用mock对象的实际代码
        Mockito.when(bar.add(1, 2)).thenReturn(7);
        
      	int result = foo.sum(1, 2);
      	//验证是否是存根返回的值
        Assert.assertEquals(7, result);
    }
}
复制代码</code></pre> </li><li> <p>注意事项:</p> 
  <ul><li> <p>默认情况下，对于所有方法的返回值，mock 视情况而定将返回 null、原始/原始包装值或空集合。例如 int/Integer 返回0，布尔值/布尔值返回false。我们可以在创建mock时通过指定默认的Answer策略来更改此返回。支持的Answer策略：</p> 
    <ul><li>Mockito.RETURNS_DEFAULTS; 
      <ul><li>这个实现首先尝试全局配置，如果没有全局配置，那么它将使用一个返回0、空集合、空值等的默认Answer。</li></ul></li><li>Mockito.RETURNS_DEEP_STUBS; 
      <ul><li>链式调用避免空指针。</li></ul></li><li>Mockito.RETURNS_MOCKS; 
      <ul><li>首先尝试返回普通值(0、空集合、空字符串等)，然后尝试返回mock。如果返回类型不能被mock(例如final)，则返回普通的null。</li></ul></li><li>Mockito.RETURNS_SELF; 
      <ul><li>允许Builder 的mock在调用方法时返回其本身，该方法返回的Type等于类或父类。 请记住，这个Answer使用方法的返回类型。如果此类型可分配给mock类，则它将返回mock。因此，如果您有一个返回超类(例如Object)的方法，它将匹配并返回mock。</li></ul></li><li>Mockito.RETURNS_SMART_NULLS; 
      <ul><li>此实现在处理遗留代码时很有帮助。非存根方法通常返回null。如果代码使用非存根调用返回的对象，则会得到NullPointerException。这个Answer的实现返回SmartNull而不是null。SmartNull给出了比NPE更好的异常消息，因为它指出了调用无存根方法的那一行。您只需单击堆栈即可跟踪。 SmartNull首先尝试返回普通值(0，空集合，空字符串等)，然后尝试返回SmartNull。如果返回类型是final，则返回纯null。 在Mockito 4.0.0中，ReturnsSmartNulls可能是默认的返回值策略。</li></ul></li><li>Mockito.CALLS_REAL_METHODS 
      <ul><li>一个调用实际方法(用于部分mock)的Answer。</li></ul></li></ul></li></ul></li></ul> 
<h4>2：创建spy对象</h4> 
<ul><li> <p>使用Mockito.spy()方法</p> <pre><code>    {
        //org.mockito.Mockito.spy(java.lang.Class&lt;T&gt;)
        //org.mockito.Mockito.spy(T)

        //方式1：spy一个具体的类型
        List spy1 = Mockito.spy(List.class);
        //方式2：spy一个已存在的对象
        List spy2 = Mockito.spy(new ArrayList&lt;&gt;());

        //便利的 API, 新的重载的 spy() 方法:
        SomeAbstract spy = spy(SomeAbstract.class);

        //Mocking 抽象, spy 接口的默认方法(从2.7.13可用)
        Function function = spy(Function.class);

        //健壮的 API, 来自 settings builder:
        OtherAbstract spy = mock(OtherAbstract.class, withSettings()
            .useConstructor().defaultAnswer(CALLS_REAL_METHODS));

        //Mock一个抽象类，使用构造函数(从 2.7.14 可用)
        SomeAbstract spy = mock(SomeAbstract.class, withSettings()
            .useConstructor("arg1", 123).defaultAnswer(CALLS_REAL_METHODS));

        //mock一个非静态内部抽象类
        InnerAbstract spy = mock(InnerAbstract.class,withSettings().useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
    }
复制代码</code></pre> </li><li> <p>使用@Spy注解。</p> 
  <ul><li>被@InjectMocks注解的对象一般就是我们被测的对象。它会被自动的实例化。且其包含的成员变量会被相应的@Spy注解的对象自动赋值。注意观察下面的示例：</li><li>注意使用了<code>@RunWith(MockitoJUnitRunner.class)</code>注解。</li></ul><pre><code>//注意我们使用了MockitoJUnitRunner
@RunWith(MockitoJUnitRunner.class)
public class MockitoTest {
    @InjectMocks
    private Foo foo;

    @Spy
    private Bar bar;

    //也可以这样
    @Spy
    private Bar bar2 = new Bar();

    @Test
    public void mockTest() {
        //对spy对象的add方法进行存根
        Mockito.when(bar.add(1, 2)).thenReturn(7);
        
      	int result = foo.sum(1, 2);
        Assert.assertEquals(7, result);
    }

    @Test
    public void mockTest2() {
        //不对spy对象存根，则调用实际的方法。
        //注意同mock对象的区别：mock对象默认是返回类型的空值。而spy对象是默认执行实际方法并返回。
        int result = foo.sum(1, 2);
        Assert.assertEquals(3, result);
    }
}
复制代码</code></pre> </li><li> <p>注意事项：</p> 
  <ul><li> <p>与mock对象的区别：</p> 
    <ul><li>mock对象的默认返回类型的空值（可以配置返回策略），不执行实际方法。</li><li>spy对象是默认执行实际方法并返回，可以对spy对象的某个方法进行存根以指定返回值且避免调用此方法实际逻辑。</li></ul></li><li> <p>有时将<code>when(Object)</code>用于已经存根的spy对象是不可能或不切实际的。因此在使用spy时请考虑使用<code>doReturn</code>|<code>Answer</code>|<code>Throw()</code>存根方法族。例子：</p> <pre><code>   List list = new LinkedList();
   List spy = spy(list);

   //以下代码是不可能: spy.get(0)方法实际的代码会被调用， 会抛出
	 //IndexOutOfBoundsException (list仍然是空的)。
   //为什么在存根的时候就会调用方法实际的代码？这样不就无法对此方法进行存根了吗？
   //因为在执行when(spy.get(0))的时候首先执行的是when()方法内的spy.get(0)；
   //而此时spy.get(0)还没有进行存根。故此方法的实际代码会被调用。要解决这个问题，
   //请使用doXXX()方法配合when()进行存根。
   when(spy.get(0)).thenReturn("foo");

   //你需要用 doReturn() 去存根
   doReturn("foo").when(spy).get(0);
 
复制代码</code></pre> </li><li> <p>Mockito <strong>不会</strong>将调用传递给的真实实例，实际上创建了它的副本。因此，如果您保留真实实例并与之交互，则不要指望监视的人会知道这些交互及其对真实实例状态的影响。相应的，当<strong>unstubbed</strong>（没有进行存根）的方法在<strong>spy对象上</strong>调用但<strong>不在真实实例上时</strong>，您将看不到对真实实例的任何影响。</p> 
    <ul><li>意思就是spy对象其实是真实对象的一个<strong>复制体</strong>；对spy中的方法的调用不会影响到真实对象。</li></ul></li><li> <p>注意<code>final方法</code>。Mockito 不会 mock <code>final方法</code>，所以底线是：当您监视真实对象时（使用spy()方法） + 尝试存根 <code>final方法</code> = 麻烦。您也将无法验证这些方法。</p> </li></ul></li></ul> 
<h4>3：创建被测对象</h4> 
<ul><li> <p>使用@InjectMocks注解。（需要配合<code>@RunWith(MockitoJUnitRunner.class)</code>使用或在<code>@Before</code>方法中使用<code>MockitoAnnotations.openMocks(this)</code>来激活Mockito 注解的相关功能。）</p> <pre><code>{
    @InjectMocks
    private Foo foo;

    @Mock
    private Bar bar; 
  
}
复制代码</code></pre> 
  <ul><li>说明：被测对象<code>foo</code>内如果包含<code>Bar</code>类型的成员变量，此时Mockito会自动将<code>bar</code>注入到<code>foo</code>中被<code>@InjectMocks</code>注解的对象<code>foo</code>在调用其方法时会执行其实际的代码逻辑。而被<code>@Mock</code>注解的对象<code>bar</code>中的方法被调用时不会执行实际的代码逻辑,而是返回类型相关的空值。</li></ul><pre><code>{
    @InjectMocks
    private Foo foo;

    @Spy
    private Bar bar = new Bar();

}
复制代码</code></pre> 
  <ul><li>说明：与上面不同的是<code>bar</code>对象是一个<code>spy</code>对象。默认情况下当<code>bar</code>对象的某个方法被调用时会执行实际的代码。当然可以对<code>bar</code>对象的某个方法进行存根，从而指定此方法的返回值，而不用调用其实际方法。要注意的是存根的方式要使用<code>doXXXX(x).when(spy).m1()</code>而不是<code>when(spy.m1()).thenReturn(x)</code>的方式；因为后者会在存根过程中会调用一次方法实际的代码逻辑。</li></ul></li><li> <p>注意事项：</p> 
  <ul><li> <p>@InjectMocks的作用：标记应执行注入的字段（指此对象内的字段应该被自动的注入，注入的值来自@Mock或@Spy注解的字段）。</p> 
    <ul><li>允许快速的mock和spy注入。</li><li>最大限度地减少重复的mock和spy注入代码。</li></ul><p><strong>【太长了这一段可以不看：主要说了@InjectMocks注解的对象如何自动注入@Mock和@Spy字段】<strong>Mockito 将尝试仅通过构造函数注入、setter 注入或属性注入依次注入mock对象，如下所述。如果以下任一策略失败，则 Mockito</strong>不会报告失败</strong>；即您必须自己提供依赖项。</p> 
    <ol><li> <p>构造函数注入：选择最大的构造函数（方法参数最多），然后使用仅在测试类中声明的mock来解析参数。如果使用构造函数成功创建了对象，则 Mockito 不会尝试其他策略。Mockito 决定不破坏具有参数构造函数的对象。</p> <p>注意：如果找不到参数，则传递 null。如果需要不可mock的类型，则不会发生构造函数注入。在这些情况下，您必须自己满足依赖项。</p> </li><li> <p>属性设置器注入（setter方法）：Mockito 将首先按类型解析（如果单个类型匹配则不管名称如何都会发生注入），然后，如果有多个相同类型的属性，则通过属性名称和mock名称匹配注入。</p> <p>注意1：如果你有相同类型（或类型擦除后相同）的属性，最好用匹配的属性命名所有@Mock注解的字段，否则 Mockito 可能会产生混淆并且不会注入。</p> <p>注意2：如果@InjectMocks 对象之前没有初始化并且有一个无参数构造函数，那么它将用这个构造函数初始化。</p> </li><li> <p>字段注入：Mockito 将首先按类型解析（如果单个类型匹配则不管名称如何都会发生注入），然后，如果有多个相同类型的属性，则通过字段名称和mock对象名称的匹配进行注入。</p> <p>注意1：如果你有相同类型（或类型擦除后相同）的字段，最好用匹配的字段命名所有@Mock注解的字段，否则 Mockito 可能会产生淆并且不会注入。</p> <p>注意2：如果@InjectMocks 对象之前没有初始化并且有一个无参数构造函数，那么它将用这个构造函数初始化。</p> </li></ol><p>例子：</p> <pre><code>public class ArticleManagerTest extends SampleBaseTestCase {

    @Mock
    private ArticleCalculator calculator;
    
    @Mock(name = "database")
    private ArticleDatabase dbMock; // note the mock name attribute
    
    @Spy
    private UserProvider userProvider = new ConsumerUserProvider();

    @InjectMocks
    private ArticleManager manager;

    @Test
    public void shouldDoSomething() {
        manager.initiateArticle();
        verify(database).addListener(any(ArticleListener.class));
    }
}

public class SampleBaseTestCase {

    private AutoCloseable closeable;

    @Before
    public void openMocks() {
        closeable = MockitoAnnotations.openMocks(this);
    }

    @After
    public void releaseMocks() throws Exception {
        closeable.close();
    }
}
复制代码</code></pre> <p>在上面的例子中，<code>@InjectMocks</code> 注解的字段 <code>ArticleManager</code>只能有一个参数化的构造函数或一个无参数的构造函数，或者两者都有。所有这些构造函数的可见性可以是package-protect、protected或private的，但是 Mockito 不能实例化内部类、本地类、抽象类，当然还有接口。 也要注意私有嵌套静态类。</p> <p>同样是 setter 或字段，它们的可见性声明可以是private的，Mockito 将通过反射看到它们。但是，静态或final字段将被忽略。</p> <p>所以在需要注入的领域，例如构造函数注入会在这里发生：</p> <pre><code>   public class ArticleManager {
       ArticleManager(ArticleCalculator calculator, ArticleDatabase database) {
           // parameterized constructor
       }
   }
 
复制代码</code></pre> <p>属性setter注入将在这里发生：</p> <pre><code>   public class ArticleManager {
       // no-arg constructor
       ArticleManager() {  }

       // setter
       void setDatabase(ArticleDatabase database) { }

       // setter
       void setCalculator(ArticleCalculator calculator) { }
   }
 
复制代码</code></pre> <p>此处将使用字段注入：</p> <pre><code>   public class ArticleManager {
       private ArticleDatabase database;
       private ArticleCalculator calculator;
   }
 
复制代码</code></pre> <p>最后，在这种情况下，不会发生注入：</p> <pre><code>   public class ArticleManager {
       private ArticleDatabase database;
       private ArticleCalculator calculator;

       ArticleManager(ArticleObserver observer, boolean flag) {
           // observer is not declared in the test above.
           // flag is not mockable anyway
       }
   }
 
复制代码</code></pre> <p>再次注意，@InjectMocks 只会注入使用 @Spy 或 @Mock 注解创建的mocks/spies对象。</p> <p>必须调用**<code>MockitoAnnotations.openMocks(this)</code>**方法来初始化带注解的对象。在上面的例子中，<code>openMocks()</code>在测试基类的@Before (JUnit4) 方法中调用。对于 JUnit3，<code>openMocks()</code>可以转到基类的<code>setup()</code>方法。 **相反，**您也可以将 openMocks() 放在 JUnit 运行程序 (@RunWith) 中或使用内置的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2Fjunit%2FMockitoJUnitRunner.html" rel="nofollow" title="MockitoJUnitRunner">MockitoJUnitRunner</a>. 另外，请确保在使用相应的钩子处理测试类后释放任何mock。</p> <p>Mockito 不是依赖注入框架，不要指望这个快速实用程序可以注入复杂的对象图，无论是mocks/spies对象还是真实对象。</p> </li></ul></li></ul> 
<h4>4：参考</h4> 
<ul><li>Mockito官方文档中的： 
  <ul><li>9.mocks的简单创建方式--<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23mock_annotation" rel="nofollow" title="@Mock注解">@Mock注解</a></li><li>16.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23partial_mocks" rel="nofollow" title="真正的部分mock">真正的部分mock</a>（自 1.8.0 起）</li><li>21.新注解：<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23captor_annotation" rel="nofollow" title="@Captor">@Captor</a>, <a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23spy_annotation" rel="nofollow" title="@Spy">@Spy</a>, <a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23injectmocks_annotation" rel="nofollow" title="@InjectMocks">@InjectMocks</a>（自 1.8.3 起）</li><li>23.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23automatic_instantiation" rel="nofollow" title="使用@Spies， @InjectMocks自动实例化对象">使用@Spies， @InjectMocks自动实例化对象</a>并具有<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23constructor_injection" rel="nofollow" title="良好的构造函数注入">良好的构造函数注入</a>（1.9.0以后）</li><li>30.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23spying_abstract_classes" rel="nofollow" title="监视或mock抽象类（自 1.10.12 起，在 2.7.13 和 2.7.14 中进一步增强）">监视或mock抽象类（自 1.10.12 起，在 2.7.13 和 2.7.14 中进一步增强）</a></li><li>32.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23better_generic_support_with_deep_stubs" rel="nofollow" title="对深存根（deep stubs）更好的通用支持（自 1.10.0 起）">对深存根（deep stubs）更好的通用支持（自 1.10.0 起）</a></li><li>33.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23mockito_junit_rule" rel="nofollow" title="Mockito JUnit rule（自 1.10.17 起）">Mockito JUnit rule（自 1.10.17 起）</a></li><li>37.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23Java_8_Custom_Answers" rel="nofollow" title="Java 8 自定义Answer支持">Java 8 自定义Answer支持</a>（自 2.1.0 起）</li><li>38.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23Meta_Data_And_Generics" rel="nofollow" title="元数据和泛型类型的保留">元数据和泛型类型的保留</a>（自 2.1.0 起）</li><li>39.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23Mocking_Final" rel="nofollow" title="mock final类、枚举和 final方法">mock final类、枚举和 final方法</a>（自 2.1.0 起）</li><li>48.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23static_mocks" rel="nofollow" title="mock静态方法">mock静态方法</a>（自 3.4.0 起）</li><li>49.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23mocked_construction" rel="nofollow" title="mock对象构造">mock对象构造</a>（自 3.5.0 起）</li></ul></li></ul> 
<h4>5：常见问题</h4> 
<ol><li>mock对象和spy对象有什么区别？ 
  <ol><li>mock对象的默认返回类型的空值（可以配置返回策略），其方法被调用时不会执行实际的代码逻辑而是直接返回。</li><li>spy对象是默认执行实际方法逻辑并返回，可以对spy对象的某个方法进行存根以指定返回值且避免调用此方法实际逻辑。</li></ol></li><li>mock对象的返回值策略（Answer策略）有那些？如何配置？ 
  <ol><li>上文已介绍，请查阅。</li></ol></li><li>对spy对象的某个方法进行存根时有什么特殊要求吗？为什么我有时明明做了存根操作，方法的实际逻辑还是会被调用？ 
  <ol><li>存根要求：使用doXXX(x).when(spy).m1()的方式而不是whenXXX(spy.m1()).thenXXX(x)的方式。</li><li>实际逻辑为什么会被调用：因为使用了whenXXX(spy.m1()).thenXXX(x)存根方式。具体上文已介绍。请查阅。</li></ol></li><li>创建这一系列测试相关的对象的最佳实践是什么？ 
  <ol><li>使用@InjectMocks注解，同时结合在类上使用注解@RunWith(MockitoJUnitRunner.class)而不是在@Before方法中使用MockitoAnnotations.openMocks(testClass)的方式创建被测对象。我们的原则是尽量使用注解的方式创建测试相关的对象。</li><li>使用@Mock而不是Mockito.mock()方法创建mock对象。</li><li>使用@Spy而不是Mockito.spy()方法创建spy对象。当然在某个具体测试方法内你发现@Spy不能方便的满足你的需求时请使用Mockito.spy()的方式。</li></ol></li></ol> 
<h3>二：存根方法调用</h3> 
<ul><li> <p>定义存根方法的方式:</p> 
  <ul><li> <p>Mockito.when(foo.sum()).thenXXX(...);</p> 
    <ul><li>即对foo.sum()方法存根。</li><li>注意： 
      <ul><li>foo对象应该是一个mock对象。spy对象不建议使用此方式进行存根。因为当代码执行到when(foo.sum())时。foo.sum()方法会首先执行。导致sum()方法的实际代码逻辑被执行。（sum()的实际代码逻辑是否会被执行要看被spy对象的类型，当被spy对象是一个mock对象或者接口时不会执行-这些类型也没有实际代码逻辑可以执行。当被spy对象一个具体的对象时则实际代码逻辑会被执行）</li></ul></li></ul></li><li> <p>Mockito.doXXX(...).when(foo).sum();</p> 
    <ul><li>即对foo.sum()方法存根。</li><li>可以存根void方法。</li><li>foo对象可以是一个mock对象，也可以是一个spy对象。</li></ul></li><li> <p>Mockito.doXXX(....).when(foo.sum());</p> 
    <ul><li> <p>你会得到一个异常，即不应该使用这种方式！</p> </li><li> <pre><code>org.mockito.exceptions.misusing.UnfinishedStubbingException: 
Unfinished stubbing detected here:
-&gt; at c.FooTest.verifyTest(FooTest.java:23)

E.g. thenReturn() may be missing.
Examples of correct stubbing:
    when(mock.isOk()).thenReturn(true);
    when(mock.isOk()).thenThrow(exception);
    doThrow(exception).when(mock).someVoidMethod();
Hints:
 1. missing thenReturn()
 2. you are trying to stub a final method, which is not supported
 3. you are stubbing the behaviour of another mock inside before 'thenReturn' instruction is completed
复制代码</code></pre> </li></ul></li></ul></li><li> <p>定义返回值的方式：</p> 
  <ul><li> 
    <table><thead><tr><th>then_xxx方法</th><th>do_XXX方法</th><th>功能</th></tr></thead><tbody><tr><td>then(Answer&lt;?&gt; answer)</td><td>doAnswer(Answer answer)</td><td>返回值使用自定义的Answer策略。</td></tr><tr><td>thenAnswer(Answer&lt;?&gt; answer)</td><td>同上</td><td>同上。</td></tr><tr><td>thenReturn(T value)</td><td>doReturn(Object toBeReturned)</td><td>直接指定返回值。</td></tr><tr><td>thenReturn(T value, T... values)</td><td>doReturn(Object toBeReturned, Object... toBeReturnedNext)</td><td>直接指定返回值，可以定义多个返回值。第一次调用到存根方法返回第一个返回值。以此类推。超过返回值数量的调用返回参数的最后一个返回值。</td></tr><tr><td>thenCallRealMethod()</td><td>doCallRealMethod()</td><td>调用实际的代码逻辑。不指定返回值。</td></tr><tr><td>thenThrow(Throwable... throwables)</td><td>doThrow(Throwable... toBeThrown)</td><td>调用到存根方法时抛出异常。</td></tr><tr><td>同上</td><td>doThrow(Class&lt;? extends Throwable&gt; toBeThrown)</td><td>调用到存根方法时抛出异常。可以定义多个异常。第一次调用到存根方法返回第一个异常。以此类推。超过异常数量的调用返回参数的最后一个异常。</td></tr><tr><td>同上</td><td>doThrow(Class&lt;? extends Throwable&gt; toBeThrown, Class&lt;? extends Throwable&gt;... toBeThrownNext)</td><td>同上。</td></tr><tr><td>无对应方法</td><td>doNothing()</td><td>void方法使用的存根方式。</td></tr></tbody></table></li></ul></li><li> <p>参数匹配器</p> 
  <ul><li>参数匹配器一般使用在存根方法的调用时。</li><li>参数匹配器也可以使用在方法的验证时。</li><li>3：参数匹配 
    <ul><li>有关于参数匹配器的介绍</li></ul></li></ul></li><li> <p>示例</p> 
  <ul><li>2：添加一些存根（stub）：指定mock对象方法调用的返回值 
    <ul><li>3个注意事项</li></ul></li><li>5.存根有异常的void方法</li><li>10.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23stubbing_consecutive_calls" rel="nofollow" title="存根连续调用">存根连续调用</a>（iterator-style stubbing）</li><li>11.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23answer_stubs" rel="nofollow" title="使用回调进行存根">使用回调进行存根</a></li><li>12.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23do_family_methods_stubs" rel="nofollow" title="doReturn()| doThrow()| doAnswer()| doNothing()| doCallRealMethod()方法族">doReturn()| doThrow()| doAnswer()| doNothing()| doCallRealMethod()方法族</a></li><li>13.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23spy" rel="nofollow" title="监视真实对象：使用spy">监视真实对象：使用spy</a> 
    <ul><li>包含了一些spy使用时的提示</li></ul></li><li>14.更改未<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23defaultreturn" rel="nofollow" title="存根调用的默认返回值">存根调用的默认返回值</a>（自 1.7 起）</li><li>16.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23partial_mocks" rel="nofollow" title="真正的部分mock">真正的部分mock</a>（自 1.8.0 起） 
    <ul><li>使用spy或者mock。</li><li>thenCallRealMethod()方法。</li></ul></li></ul></li><li> <p>注意事项：</p> 
  <ul><li>TODO</li></ul></li></ul> 
<h3>三：验证方法调用</h3> 
<h4>验证方法：</h4> 
<h4>方法是否被调用/方法的调用的次数</h4> 
<ul><li><code>atLeast(int minNumberOfInvocations)</code>允许至少 x 调用的验证。</li><li><code>atLeastOnce()</code>允许至少一次调用的验证。</li><li><code>atMost(int maxNumberOfInvocations)</code>允许最多 x 次调用的验证。</li><li><code>atMostOnce()</code>允许最多一次调用的验证。</li><li><code>never()</code> <code>times(0)</code>的别名，见<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23times-int-" rel="nofollow" title="times(int)">times(int)</a> 。</li><li><code>only()</code>允许检查给定的方法是否只调用一次。</li><li><code>times(int wantedNumberOfInvocations)</code>允许验证调用的确切次数。</li><li><code>verify(T mock)</code>验证某些行为<strong>发生过一次</strong>。</li><li><code>verify(T mock, VerificationMode mode)</code>验证某些行为至少发生过一次/确切的次数/从未发生过。</li><li><code>verifyNoInteractions(Object... mocks)</code>验证给定的模拟上没有发生交互。</li><li><code>verifyNoMoreInteractions(Object... mocks)</code>检查任何给定的模拟是否有任何未经验证的交互。</li></ul> 
<h4>方法执行的时间</h4> 
<ul><li><code>after(long millis)</code>在给定的毫秒数后将触发验证，允许测试异步代码。</li><li><code>timeout(long millis)</code>验证将一遍又一遍地触发，直到给定的毫秒数，允许测试异步代码。</li></ul> 
<h4>调用顺序验证</h4> 
<ul><li><code>calls(int wantedNumberOfInvocations)</code>允许按顺序进行非贪婪调用的验证。</li><li><code>inOrder(Object... mocks)</code>创建<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FInOrder.html" rel="nofollow" title="InOrder">InOrder</a>对象，允许按顺序验证mock的对象。</li></ul> 
<h4>示例：</h4> 
<ul><li>1：验证mock对象的行为（方法是否被调用以及调用返回值）</li><li>4：验证确切的调用次数/至少调用x次/从未调用</li><li>6：调用顺序验证</li><li>7.确保在mock对象从未发生交互</li><li>8.寻找多余的调用</li><li>15.为进一步的断言<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23captors" rel="nofollow" title="捕获参数">捕获参数</a>（自 1.8.0 起） 
  <ul><li>一些关于捕获参数进行断言的警告。</li></ul></li><li>22.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23verification_timeout" rel="nofollow" title="超时验证">超时验证</a>（自 1.8.5 起）</li><li>35.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23Custom_verification_failure_message" rel="nofollow" title="自定义验证失败信息">自定义验证失败信息</a>（自 2.1.0 起）</li><li>40.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23strict_mockito" rel="nofollow" title=" 使用“更严格”的 Mockito 提高生产力和编写更简明的测试"> 使用“更严格”的 Mockito 提高生产力和编写更简明的测试</a>（自 2.+ 起）</li></ul> 
<h4>验证方法参考：</h4> 
<table><thead><tr><th>修饰符和类型</th><th>方法和说明</th></tr></thead><tbody><tr><td><code>static VerificationAfterDelay</code></td><td><code>after(long millis)</code>在给定的毫秒数后将触发验证，允许测试异步代码。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>atLeast(int minNumberOfInvocations)</code>允许至少 x 调用的验证。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>atLeastOnce()</code>允许至少一次调用的验证。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>atMost(int maxNumberOfInvocations)</code>允许最多 x 次调用的验证。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>atMostOnce()</code>允许最多一次调用的验证。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>calls(int wantedNumberOfInvocations)</code>允许按顺序进行非贪婪调用的验证。</td></tr><tr><td><code>static Object[]</code></td><td><code>ignoreStubs(Object... mocks)</code>为了验证，忽略给定mock的存根方法。</td></tr><tr><td><code>static InOrder</code></td><td><code>inOrder(Object... mocks)</code>创建<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FInOrder.html" rel="nofollow" title="InOrder">InOrder</a>对象，允许按顺序验证mock的对象。</td></tr><tr><td><code>static LenientStubber</code></td><td><code>lenient()</code>宽松存根，绕过“严格存根”验证（请参阅参考资料<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2Fquality%2FStrictness.html%23STRICT_STUBS" rel="nofollow" title="Strictness.STRICT_STUBS">Strictness.STRICT_STUBS</a>）。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>never()</code> <code>times(0)</code>的别名，见<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23times-int-" rel="nofollow" title="times(int)">times(int)</a></td></tr><tr><td><code>static VerificationMode</code></td><td><code>only()</code>允许检查给定的方法是否只调用一次。</td></tr><tr><td><code>static &lt;T&gt; void</code></td><td><code>reset(T... mocks)</code>聪明 Mockito 用户几乎不使用此功能，因为他们知道这可能是测试不佳的迹象。</td></tr><tr><td><code>static VerificationWithTimeout</code></td><td><code>timeout(long millis)</code>验证将一遍又一遍地触发，直到给定的毫秒数，允许测试异步代码。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>times(int wantedNumberOfInvocations)</code>允许验证调用的确切次数。</td></tr><tr><td><code>static void</code></td><td><code>validateMockitoUsage()</code>首先，如果有任何问题，我鼓励您阅读 Mockito FAQ： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmockito%2Fmockito%2Fwiki%2FFAQ" rel="nofollow" title="github.com/mockito/moc…">github.com/mockito/moc…</a></td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>verify(T mock)</code>验证某些行为<strong>发生过一次</strong>。</td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>verify(T mock, VerificationMode mode)</code>验证某些行为至少发生过一次/确切的次数/从未发生过。</td></tr><tr><td><code>static void</code></td><td><code>verifyNoInteractions(Object... mocks)</code>验证给定的模拟上没有发生交互。</td></tr><tr><td><code>static void</code></td><td><code>verifyNoMoreInteractions(Object... mocks)</code>检查任何给定的模拟是否有任何未经验证的交互。</td></tr></tbody></table> 
<h2>四：Mockito中有用的操作</h2> 
<ul><li> <p>17.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23resetting_mocks" rel="nofollow" title="重置mock">重置mock</a>（自 1.8.0 起）</p> 
  <ul><li>Mockito会忘掉了所有的交互和存根。</li></ul></li><li> <p>18.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23framework_validation" rel="nofollow" title="故障排除和验证框架的使用">故障排除和验证框架的使用</a>（自 1.8.0 起）</p> </li><li> <p>19.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23bdd_mockito" rel="nofollow" title="行为驱动开发的别名">行为驱动开发的别名</a>（自 1.8.0 起）</p> </li><li> <p>20.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23serializable_mocks" rel="nofollow" title="可序列化的mock">可序列化的mock</a>（自 1.8.1 起）</p> </li><li> <p>24.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23one_liner_stub" rel="nofollow" title="单行存根">单行存根</a>（自 1.9.0 起）</p> </li><li> <p>25.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23ignore_stubs_verification" rel="nofollow" title="忽略存根的验证">忽略存根的验证</a>（自 1.9.0 起）</p> </li><li> <p>26.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23mocking_details" rel="nofollow" title="mockingDetails">mockingDetails</a>（2.2.x 改进）</p> </li><li> <p>27.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23delegating_call_to_real_instance" rel="nofollow" title="将调用委托给真实对象">将调用委托给真实对象</a>（自 1.9.5 起）</p> </li><li> <p>28.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23mock_maker_plugin" rel="nofollow" title="MockMaker API">MockMaker API</a>（从 1.9.5 开始）</p> </li><li> <p>29.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23BDD_behavior_verification" rel="nofollow" title="BDD 风格验证">BDD 风格验证</a>（自 1.10.0 起）</p> </li><li> <p>31.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23serilization_across_classloader" rel="nofollow" title="Mockito 模拟可以跨类加载器序列化/反序列化（自 1.10.0 起）">Mockito 模拟可以跨类加载器序列化/反序列化（自 1.10.0 起）</a></p> </li><li> <p>34.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23plugin_switch" rel="nofollow" title="切换插件的启用或禁用（15年10月1日以来）">切换插件的启用或禁用（15年10月1日以来）</a></p> </li><li> <p>36.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23Java_8_Lambda_Matching" rel="nofollow" title="Java 8 Lambda 匹配器支持">Java 8 Lambda 匹配器支持</a>（自 2.1.0 起）</p> </li><li> <p>41.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23framework_integrations_api" rel="nofollow" title=" 用于框架集成的高级公共 API（自 2.10.+ 起）"> 用于框架集成的高级公共 API（自 2.10.+ 起）</a></p> </li><li> <p>42.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23verifiation_started_listener" rel="nofollow" title=" 用于集成的新 API：监听验证开始事件（自 2.11.+ 起）"> 用于集成的新 API：监听验证开始事件（自 2.11.+ 起）</a></p> </li><li> <p>43.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23mockito_session_testing_frameworks" rel="nofollow" title=" 用于集成的新 API：可用于测试框架的MockitoSession（自 2.15.+ 起）"> 用于集成的新 API：可用于测试框架的MockitoSession（自 2.15.+ 起）</a></p> </li><li> <p>44.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23mockito_instantiator_provider_deprecation" rel="nofollow" title=" 已弃用，org.mockito.plugins.InstantiatorProvider因为它会泄漏内部 API。它被替换为org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)"> 已弃用，org.mockito.plugins.InstantiatorProvider因为它会泄漏内部 API。它被替换为org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)</a></p> </li><li> <p>45.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23junit5_mockito" rel="nofollow" title="新的 JUnit Jupiter (JUnit5+) 扩展">新的 JUnit Jupiter (JUnit5+) 扩展</a></p> </li><li> <p>46.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23mockito_lenient" rel="nofollow" title=" 新的Mockito.lenient()和MockSettings.lenient()的方法（自2.20.0）"> 新的Mockito.lenient()和MockSettings.lenient()的方法（自2.20.0）</a></p> </li><li> <p>47.<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23clear_inline_mocks" rel="nofollow" title="用于清除内联mock中mock状态的新 API（自 2.25.0 起）">用于清除内联mock中mock状态的新 API（自 2.25.0 起）</a></p> </li></ul> 
<h2>五：参考</h2> 
<p>Mockito Javadoc参考：</p> 
<table><thead><tr><th>修饰符和类型</th><th>方法和说明</th></tr></thead><tbody><tr><td><code>static VerificationAfterDelay</code></td><td><code>after(long millis)</code>在给定的毫秒数后将触发验证，允许测试异步代码。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>atLeast(int minNumberOfInvocations)</code>允许至少 x 调用的验证。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>atLeastOnce()</code>允许至少一次调用的验证。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>atMost(int maxNumberOfInvocations)</code>允许最多 x 次调用的验证。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>atMostOnce()</code>允许最多一次调用的验证。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>calls(int wantedNumberOfInvocations)</code>允许按顺序进行非贪婪调用的验证。</td></tr><tr><td><code>static void</code></td><td><code>clearAllCaches()</code>清除所有mock、类型缓存和检测。</td></tr><tr><td><code>static &lt;T&gt; void</code></td><td><code>clearInvocations(T... mocks)</code>仅在存根不重要时使用此方法清除调用。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>description(String description)</code>添加要在验证失败时打印的说明。</td></tr><tr><td><code>static Stubber</code></td><td><code>doAnswer(Answer answer)</code>当你想要和通用的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2Fstubbing%2FAnswer.html" rel="nofollow" title="Answer">Answer</a> 一起存根void方法时使用<code>doAnswer()</code>。</td></tr><tr><td><code>static Stubber</code></td><td><code>doCallRealMethod()</code>使用<code>doCallRealMethod()</code>时会调用（执行）真正的方法。</td></tr><tr><td><code>static Stubber</code></td><td><code>doNothing()</code>使用<code>doNothing()</code>设置void方法什么也不做。</td></tr><tr><td><code>static Stubber</code></td><td><code>doReturn(Object toBeReturned)</code>在那些极少数情况下，你不能使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23when-T-" rel="nofollow" title="when(Object)">when(Object)</a>时，使用<code>doReturn()</code>。</td></tr><tr><td><code>static Stubber</code></td><td><code>doReturn(Object toBeReturned, Object... toBeReturnedNext)</code>与<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23doReturn-java.lang.Object-" rel="nofollow" title="doReturn(Object)">doReturn(Object)</a>相同，但可以设置连续的返回值。</td></tr><tr><td><code>static Stubber</code></td><td><code>doThrow(Class&lt;? extends Throwable&gt; toBeThrown)</code> 要存根void方法并抛出异常时使用<code>doThrow()</code>。</td></tr><tr><td><code>static Stubber</code></td><td><code>doThrow(Class&lt;? extends Throwable&gt; toBeThrown, Class&lt;? extends Throwable&gt;... toBeThrownNext)</code>与<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23doThrow-java.lang.Class-" rel="nofollow" title="doThrow(Class)">doThrow(Class)</a>相同，但可以设置连续的异常。</td></tr><tr><td><code>static Stubber</code></td><td><code>doThrow(Throwable... toBeThrown)</code>要存根void方法并抛出异常时使用<code>doThrow()</code>,支持连续抛出异常。</td></tr><tr><td><code>static MockitoFramework</code></td><td><code>framework()</code>为高级用户或框架集成商提供。</td></tr><tr><td><code>static Object[]</code></td><td><code>ignoreStubs(Object... mocks)</code>为了验证，忽略给定mock的存根方法。</td></tr><tr><td><code>static InOrder</code></td><td><code>inOrder(Object... mocks)</code>创建<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FInOrder.html" rel="nofollow" title="InOrder">InOrder</a>对象，允许按顺序验证mock的对象。</td></tr><tr><td><code>static LenientStubber</code></td><td><code>lenient()</code>宽松存根，绕过“严格存根”验证（请参阅 参考资料<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2Fquality%2FStrictness.html%23STRICT_STUBS" rel="nofollow" title="Strictness.STRICT_STUBS">Strictness.STRICT_STUBS</a>）。</td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>mock(Class&lt;T&gt; classToMock)</code>创建给定类或接口的mock对象。</td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>mock(Class&lt;T&gt; classToMock, Answer defaultAnswer)</code>使用指定的Answer策略创建mock以交互。</td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>mock(Class&lt;T&gt; classToMock, MockSettings mockSettings)</code>创建具有一些非标准设置的mock。</td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>mock(Class&lt;T&gt; classToMock, String name)</code>指定mock名称。</td></tr><tr><td><code>static &lt;T&gt; MockedConstruction&lt;T&gt;</code></td><td><code>mockConstruction(Class&lt;T&gt; classToMock)</code>为给定类的所有构造器创建线程本地mock控制器。</td></tr><tr><td><code>static &lt;T&gt; MockedConstruction&lt;T&gt;</code></td><td><code>mockConstruction(Class&lt;T&gt; classToMock, java.util.function.Function&lt;MockedConstruction.Context,MockSettings&gt; mockSettingsFactory)</code>为给定类的所有构造器创建线程本地mock控制器。</td></tr><tr><td><code>static &lt;T&gt; MockedConstruction&lt;T&gt;</code></td><td><code>mockConstruction(Class&lt;T&gt; classToMock, java.util.function.Function&lt;MockedConstruction.Context,MockSettings&gt; mockSettingsFactory, MockedConstruction.MockInitializer&lt;T&gt; mockInitializer)</code>为为给定类的所有构造器创建线程本地mock控制器。</td></tr><tr><td><code>static &lt;T&gt; MockedConstruction&lt;T&gt;</code></td><td><code>mockConstruction(Class&lt;T&gt; classToMock, MockedConstruction.MockInitializer&lt;T&gt; mockInitializer)</code>为给定类的所有构造器创建线程本地mock控制器。</td></tr><tr><td><code>static &lt;T&gt; MockedConstruction&lt;T&gt;</code></td><td><code>mockConstruction(Class&lt;T&gt; classToMock, MockSettings mockSettings)</code>为给定类的所有构造器创建线程本地mock控制器。</td></tr><tr><td><code>static &lt;T&gt; MockedConstruction&lt;T&gt;</code></td><td><code>mockConstruction(Class&lt;T&gt; classToMock, MockSettings mockSettings, MockedConstruction.MockInitializer&lt;T&gt; mockInitializer)</code>为给定类的所有构造器创建线程本地mock控制器。</td></tr><tr><td><code>static &lt;T&gt; MockedConstruction&lt;T&gt;</code></td><td><code>mockConstructionWithAnswer(Class&lt;T&gt; classToMock, Answer defaultAnswer, Answer... additionalAnswers)</code>为给定类的所有构造器创建线程本地mock控制器。</td></tr><tr><td><code>static MockingDetails</code></td><td><code>mockingDetails(Object toInspect)</code>返回一个 MockingDetails 实例，该实例允许检查特定对象以获取 Mockito 相关信息。</td></tr><tr><td><code>static MockitoSessionBuilder</code></td><td><code>mockitoSession()</code> <code>MockitoSession</code> 是一个可选的、强烈推荐的功能，它通过消除样板代码和添加额外的验证来帮助推动更清晰的测试。</td></tr><tr><td><code>static &lt;T&gt; MockedStatic&lt;T&gt;</code></td><td><code>mockStatic(Class&lt;T&gt; classToMock)</code>为给定类或接口的所有静态方法创建线程本地mock控制器。</td></tr><tr><td><code>static &lt;T&gt; MockedStatic&lt;T&gt;</code></td><td><code>mockStatic(Class&lt;T&gt; classToMock, Answer defaultAnswer)</code>为给定类或接口的所有静态方法创建线程本地mock控制器。</td></tr><tr><td><code>static &lt;T&gt; MockedStatic&lt;T&gt;</code></td><td><code>mockStatic(Class&lt;T&gt; classToMock, MockSettings mockSettings)</code>为给定类或接口的所有静态方法创建线程本地mock控制器。</td></tr><tr><td><code>static &lt;T&gt; MockedStatic&lt;T&gt;</code></td><td><code>mockStatic(Class&lt;T&gt; classToMock, String name)</code>为给定类或接口的所有静态方法创建线程本地mock控制器。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>never()</code> <code>times(0)</code>的别名，见<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23times-int-" rel="nofollow" title="times(int)">times(int)</a></td></tr><tr><td><code>static VerificationMode</code></td><td><code>only()</code>允许检查给定的方法是否只调用一次。</td></tr><tr><td><code>static &lt;T&gt; void</code></td><td><code>reset(T... mocks)</code>聪明 Mockito 用户几乎不使用此功能，因为他们知道这可能是测试不佳的迹象。</td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>spy(Class&lt;T&gt; classToSpy)</code>请参阅 的文档<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23spy-T-" rel="nofollow" title="spy(Object)">spy(Object)</a>。</td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>spy(T object)</code>创建真实对象的监视。</td></tr><tr><td><code>static VerificationWithTimeout</code></td><td><code>timeout(long millis)</code>验证将一遍又一遍地触发，直到给定的毫秒数，允许测试异步代码。</td></tr><tr><td><code>static VerificationMode</code></td><td><code>times(int wantedNumberOfInvocations)</code>允许验证调用的确切次数。</td></tr><tr><td><code>static void</code></td><td><code>validateMockitoUsage()</code>首先，如果有任何问题，我鼓励您阅读 Mockito FAQ：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmockito%2Fmockito%2Fwiki%2FFAQ" rel="nofollow" title="https">https</a> : <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmockito%2Fmockito%2Fwiki%2FFAQ" rel="nofollow" title="//github.com/mockito/mockito/wiki/FAQ">//github.com/mockito/mockito/wiki/FAQ</a></td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>verify(T mock)</code>验证某些行为<strong>发生过一次</strong>。</td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>verify(T mock, VerificationMode mode)</code>验证某些行为至少发生过一次/确切的次数/从未发生过。</td></tr><tr><td><code>static void</code></td><td><code>verifyNoInteractions(Object... mocks)</code>验证给定的模拟上没有发生交互。</td></tr><tr><td><code>static void</code></td><td><code>verifyNoMoreInteractions(Object... mocks)</code>检查任何给定的模拟是否有任何未经验证的交互。</td></tr><tr><td><code>static void</code></td><td><code>verifyZeroInteractions(Object... mocks)</code>已弃用。 从 3.0.1 开始。请将您的代码迁移到<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fstatic%2Forg.mockito%2Fmockito-core%2F3.11.1%2Forg%2Fmockito%2FMockito.html%23verifyNoInteractions-java.lang.Object...-" rel="nofollow" title="verifyNoInteractions(Object...)">verifyNoInteractions(Object...)</a></td></tr><tr><td><code>static &lt;T&gt; OngoingStubbing&lt;T&gt;</code></td><td><code>when(T methodCall)</code>创建方法的存根。</td></tr><tr><td><code>static MockSettings</code></td><td><code>withSettings()</code>允许使用其他mock设置进行mock创建。</td></tr></tbody></table> 
<pre><code>    Mockito.after(100);
    Mockito.atLeast();
    Mockito.atLeastOnce();
    Mockito.atMost();
    Mockito.atMostOnce();
    Mockito.calls();
    Mockito.clearAllCaches();
    Mockito.clearInvocations();
    Mockito.description();
    Mockito.doAnswer();
    Mockito.doCallRealMethod();
    Mockito.doNothing();
    Mockito.doReturn();
    Mockito.doReturn(null,null);
    Mockito.doThrow(Object.class);
    Mockito.doThrow(null,null);
    Mockito.doThrow(new Exception())
    Mockito.framework()
    Mockito.ignoreStubs()
    Mockito.inOrder()
    Mockito.lenient()
    Mockito.mock(null)
    Mockito.mock(null,null)
    Mockito.mock(null, new MockSettings())
    Mockito.mock(Object.class,"xx")
    Mockito.mockConstruction(6)
    Mockito.mockConstructionWithAnswer()
    Mockito.mockingDetails()
    Mockito.mockitoSession()
    Mockito.mockStatic(4)
    Mockito.never()
    Mockito.only()
    Mockito.reset();
    Mockito.spy(2)
    Mockito.timeout()
    Mockito.times()
    Mockito.validateMockitoUsage();
    Mockito.verify(2)
    Mockito.verifyNoInteractions();
    Mockito.verifyNoMoreInteractions();
    Mockito.verifyZeroInteractions();
    Mockito.when()
    Mockito.withSettings()</code></pre> 
<p><br> 作者：汪进<br> 链接：https://juejin.cn/post/6975525979418525709<br> 来源：稀土掘金<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b31c373c76bb5ba3a20c6e63e9e6242c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java小问题总结第一期</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf8621c860ade1ea89ea60767fd073c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp nvue中的text标签 不能有空格，回车等 都会被识别进去 渲染出莫名的边距</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>