<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java基础笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java基础笔记" />
<meta property="og:description" content="基础 面向对象主要有四大特性 1、抽象
忽略一个主题中与当前目标无关的东西，专注的注意与当前目标有关的方面。(就是把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口)。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一个数据抽象，而是过程抽象。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
数据抽象 --&gt;表示世界中一类事物的特征，就是对象的属性。比如鸟有翅膀，羽毛等(类的属性)
过程抽象 --&gt;表示世界中一类事物的行为，就是对象的行为。比如鸟会飞，会叫(类的方法)
2、封装
封装是面向对象的特征之一，是对象和类概念的主要特性。封装就是把过程和数据包围起来，对数据的访问只能通过已定义的界面。如私有变量，用set，get方法获取。封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口
封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。
3、继承
继承为了重用父类代码，同时为实现多态性作准备。继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。
4、多态
多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。多态性语言具有灵活/抽象/行为共享/代码共享的优势，很好的解决了应用程序函数同名问题。总的来说，方法的重写，重载与动态链接构成多态性。java引入多态的概念原因之一就是弥补类的单继承带来的功能不足。
动态链接 --&gt;对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将调用子类中的这个方法，这就是动态链接。
面向对象五大基本原则是什么 单一职责
从字面意思其实就很好理解，只做一件事，不去多揽其他的事使自己烦心；单一职责原则可以看做是低耦合高内聚思想的延伸，提高高内聚来减少引起变化的原因。
开放封闭原则
在设计一个类或者一个模块，应该符合对外是可以扩展的，对修改时关闭的，这样的代码健壮性就很强，后续业务扩展增加新的需求也可以在保证现有代码不变的情况下实现扩展。
里氏替换原则
里氏替换原则对继承进行了规则上的约束，这种约束主要体现在四个方面：
1. 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。
2. 子类中可以增加自己特有的方法。
3. 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
接口隔离原则
接口端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。
如果一个提供接口的类中对于它的子类来说不是最小的接口，那么它的子类在实现该类的时候就必须实现一些自己不需要的功能，整个系统就会慢慢变得臃肿难以维护。
依赖倒置原则
高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象抽象不应该依赖于具体实现，具体实现应该依赖于抽象 java三大特征 1、封装
2、继承
3、多态
JDK 6 新特性 JDK 7的新特性 JDK8 的新特性 什么是Java程序的主类？应用程序和小程序的主类有何不同？ 一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。
而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。
数据类型四类八种 数据类型包装类占用内存取值范围默认值整型byteByte1个字节-2^7 ~ 2^7-10 shortshort2个字节-2^15 ~ 2^15-10intInteger4个字节-2^31 ~ 2^31-10longLong8个字节-2^63 ~ 2^63-10L浮点型floatFloat4个字节（正数）1.4E-45 - 3.4028235E38 （整体） -3.4028235E38 ~ 3.4028235E380.0FdoubleDouble8个字节1.7976931348623157E308 ~ 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/316d0e6f3034cef547a08cb9eedfaba9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-07T10:25:28+08:00" />
<meta property="article:modified_time" content="2022-11-07T10:25:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java基础笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E5%9F%BA%E7%A1%80">基础</h2> 
<hr> 
<h3><strong>面向对象主要有四大特性</strong></h3> 
<p><strong>1、抽象</strong></p> 
<p>忽略一个主题中与当前目标无关的东西，专注的注意与当前目标有关的方面。(就是把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口)。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。<span style="color:#fe2c24;"><strong>抽象包括两个方面，一个数据抽象，而是过程抽象。</strong></span><strong>抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</strong></p> 
<p>数据抽象 --&gt;表示世界中一类事物的特征，就是对象的属性。比如鸟有翅膀，羽毛等(类的属性)</p> 
<p>过程抽象 --&gt;表示世界中一类事物的行为，就是对象的行为。比如鸟会飞，会叫(类的方法)</p> 
<p><strong>2、封装</strong></p> 
<p>封装是面向对象的特征之一，是对象和类概念的主要特性。封装就是把过程和数据包围起来，对数据的访问只能通过已定义的界面。如私有变量，用set，get方法获取。<span style="color:#fe2c24;"><strong>封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口</strong></span></p> 
<p>封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。</p> 
<p><strong>3、继承</strong></p> 
<p>继承为了重用父类代码，同时为实现多态性作准备。继承是<strong>从已有类</strong>得到继承信息<strong>创建新类的过程</strong>。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是<strong>封装程序中可变因素</strong>的重要手段。</p> 
<p><strong>4、多态</strong></p> 
<p>多态性是指允许<strong>不同子类型</strong>的对象<strong>对同一消息</strong>作出<strong>不同的响应</strong>。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。多态性语言具有灵活/抽象/行为共享/代码共享的优势，很好的解决了应用程序函数同名问题。总的来说，<strong>方法的重写，重载与动态链接构成多态性。</strong>java引入多态的概念原因之一就是弥补类的单继承带来的功能不足。</p> 
<p>动态链接 --&gt;对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将调用子类中的这个方法，这就是动态链接。</p> 
<h3 id="37.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89">面向对象五大基本原则是什么</h3> 
<blockquote> 
 <p><strong>单一职责</strong></p> 
 <p>从字面意思其实就很好理解，只做一件事，不去多揽其他的事使自己烦心；单一职责原则可以看做是低耦合高内聚思想的延伸，提高高内聚来减少引起变化的原因。</p> 
 <p></p> 
 <p><strong>开放封闭原则</strong></p> 
 <p>在设计一个类或者一个模块，应该符合对外是可以扩展的，对修改时关闭的，这样的代码健壮性就很强，后续业务扩展增加新的需求也可以在保证现有代码不变的情况下实现扩展。</p> 
 <p></p> 
 <p><strong>里氏替换原则</strong></p> 
 <p>里氏替换原则对继承进行了规则上的约束，这种约束主要体现在四个方面：</p> 
 <p>        1. 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。</p> 
 <p>        2. 子类中可以增加自己特有的方法。</p> 
 <p>        3. 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</p> 
 <p>        4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p> 
 <p></p> 
 <p><strong>接口隔离原则</strong></p> 
 <p>接口端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。</p> 
 <p>如果一个提供接口的类中对于它的子类来说不是最小的接口，那么它的子类在实现该类的时候就必须实现一些自己不需要的功能，整个系统就会慢慢变得臃肿难以维护。</p> 
 <p></p> 
 <p><strong>依赖倒置原则</strong></p> 
 <ol><li>高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象</li><li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li></ol> 
</blockquote> 
<p></p> 
<h3>java三大特征</h3> 
<p>1、封装</p> 
<p>2、继承</p> 
<p>3、多态</p> 
<p></p> 
<h3>JDK 6 新特性</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b5/ec/3IHTpX3T_o.png"></p> 
<h3>JDK 7的新特性</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cd/05/CPXr1tMk_o.png"></p> 
<h3>JDK8 的新特性</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5e/3e/HBlpf3f0_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c0/38/HWSeXxFP_o.png"></p> 
<h3 id="8.%20%E4%BB%80%E4%B9%88%E6%98%AFJava%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB%EF%BC%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"> 什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3> 
<p>一个程序中可以有多个类，但<strong>只能有一个类是主类</strong>。在Java应用程序中，这个主类是指<strong>包含main()方法的类</strong>。</p> 
<p>而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求<strong>必须是public类</strong>。主类是Java程序执行的入口点。</p> 
<p></p> 
<p></p> 
<h3>数据类型四类八种</h3> 
<table><thead><tr><th></th><th>数据类型</th><th>包装类</th><th>占用内存</th><th>取值范围</th><th>默认值</th></tr></thead><tbody><tr><td colspan="1" rowspan="4">整型</td><td>byte</td><td>Byte</td><td>1个字节</td><td>-2^7 ~ 2^7-1</td><td>0        </td></tr><tr><td>short</td><td>short</td><td>2个字节</td><td>-2^15 ~ 2^15-1</td><td>0</td></tr><tr><td>int</td><td>Integer</td><td>4个字节</td><td>-2^31 ~ 2^31-1</td><td>0</td></tr><tr><td>long</td><td>Long</td><td>8个字节</td><td>-2^63 ~ 2^63-1</td><td>0L</td></tr><tr><td colspan="1" rowspan="2">浮点型</td><td>float</td><td>Float</td><td>4个字节</td><td>（正数）1.4E-45 - 3.4028235E38 （整体） -3.4028235E38 ~ 3.4028235E38</td><td>0.0F</td></tr><tr><td>double</td><td>Double</td><td>8个字节</td><td>1.7976931348623157E308 ~ 4.9E-324</td><td>0.0D</td></tr><tr><td>字符型</td><td>char</td><td>Character</td><td>2个字节</td><td>65536（看字符编码）</td><td>'\u0000'</td></tr><tr><td>布尔型</td><td>boolean</td><td>BOOlean</td><td>1个字节</td><td>两个值 true和false</td><td>false</td></tr></tbody></table> 
<ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li><code>char a = 'h'</code>char :单引号，<code>String a = "hello"</code> :双引号。</li></ol> 
<p></p> 
<h3 id="基本类型和包装类型的区别">基本类型和包装类型的区别？</h3> 
<ul><li><strong>成员变量包装类型</strong>不赋值就是<span style="color:#fe2c24;"><strong> <code>null</code></strong></span> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于<strong>泛型</strong>，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>相比于对象类型， 基本数据类型<strong>占用</strong>的空间<strong>非常小</strong>。</li></ul> 
<p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p> 
<p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p> 
<blockquote> 
 <p>第一条：八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以进行转换；</p> 
 <p>第二条：如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋值给byte,short,char 类型的变量；</p> 
 <p>第三条：小容量向大容量转换称为自动类型转换，容量从小到大的排序为：<br> byte &lt; short(char) &lt; int &lt; long &lt; float &lt; double，其中 short和 char 都占用两个字节，但是char 可以表示更大的正整数；</p> 
 <p>第四条：大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，但运行时可能出现精度损失，谨慎使用；</p> 
 <p>第五条：byte,short,char 类型混合运算时，先各自转换成 int 类型再做运算；</p> 
 <p>第六条：多种数据类型混合运算，各自先转换成容量最大的那一种再做运算；</p> 
 <p>所有的笔试题都超不出以上的6条规则。死记硬背</p> 
</blockquote> 
<h4 id="articleContentId">Integer a= 127 与 Integer b = 127相等吗</h4> 
<p>对于<strong><span style="color:#fe2c24;">对象引用类型</span></strong>：==比较的是对象的<strong>内存地址</strong>。<br> 对于<strong>基本数据类型</strong>：==比较的是<strong>值</strong>。</p> 
<p>如果整型字面量的<span style="color:#fe2c24;"><strong>值在-128到127之间</strong></span>，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false</p> 
<pre><code class="language-java">public static void main(String[] args) {
    Integer a = new Integer(3);
    Integer b = 3;  // 将3自动装箱成Integer类型
    int c = 3;
    System.out.println(a == b); // false 两个引用没有引用同一对象
    System.out.println(a == c); // true a自动拆箱成int类型再和c比较
    System.out.println(b == c); // true
 
    Integer a1 = 128;
    Integer b1 = 128;
    System.out.println(a1 == b1); // false
 
    Integer a2 = 127;
    Integer b2 = 127;
    System.out.println(a2 == b2); // true
}</code></pre> 
<p></p> 
<p></p> 
<h3><strong>String str="i"与 String str=new String("i")一样吗？</strong></h3> 
<blockquote> 
 <p>不一样，因为内存的分配方式不一样。</p> 
 <p>String str="i"的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。</p> 
</blockquote> 
<h3 id="75.%20%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">字符型常量和字符串常量的区别</h3> 
<p>1.形式上: 字符常量是单引号引起的一个字符，字符串常量是双引号引起的若千个字符<br> 2.含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置，相当于对象)<br> 3. 占内存大小：字符常量只占2个字节；字符串常量占若干个字节(至少一个字符结束标志) (注意: char 在Java中占两个字节)</p> 
<h3 id="76.%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F">String为什么是不可变的吗？</h3> 
<p>String 类是 fifinal 类，不可以被继承。</p> 
<p>通过源码知道String 底层是由char数组构成，我们创建一个字符串对象的时候，其实是将字符串保存在char数组中，因为数组是引用对象，为了防止数组可变，jdk加了final修饰，但是加了final修饰的数组只是代表了引用不可变，不代表数组内容不可变，因此jdk为了真正防止不可变，又加了private修饰符。</p> 
<h3 id="82.%20String%20str%3D%22i%22%E4%B8%8E%20String%20str%3Dnew%20String(%E2%80%9Ci%E2%80%9D)%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F">String str="i"与 String str=new String(“i”)一样吗？</h3> 
<p>不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p> 
<h3>String s = new String(“xyz“) 创建了几个字符串对象？</h3> 
<blockquote> 
 <p>一个或两个。</p> 
 <p>如果字符串常量池已经有“xyz”，则是一个；否则，两个。</p> 
 <p>当字符串常量池没有 “xyz”，此时会创建如下两个对象：</p> 
 <p>一个是字符串字面量 "xyz" 所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，此时该实例也是在堆中，字符串常量池只放引用。</p> 
 <p>另一个是通过 new String() 创建并初始化的，内容与"xyz"相同的实例，也是在堆中。</p> 
</blockquote> 
<h3>String s = "xyz" 和 String s = new String("xyz") 区别？</h3> 
<p>两个语句都会先去字符串常量池中检查是否已经存在 “xyz”，如果有则直接使用，如果没有则会在常量池中创建 “xyz” 对象。</p> 
<p>另外，String s = new String("xyz") 还会通过 new String() 在堆里创建一个内容与 "xyz" 相同的对象实例。</p> 
<p>所以前者其实理解为被后者的所包含。</p> 
<h3 id="86.%20String%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F">String 类的常用方法都有那些？</h3> 
<ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul> 
<p></p> 
<h3>java向上取整</h3> 
<p><img alt="" height="565" src="https://images2.imgbox.com/d1/92/APFia5Al_o.png" width="986"></p> 
<p></p> 
<p></p> 
<h3 id="java-语言关键字有哪些">Java 语言关键字有哪些？</h3> 
<table><thead><tr><th>分类</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td></tr></tbody></table> 
<p></p> 
<h3>重写与重载</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9a/f7/Y32hh6IP_o.png"></p> 
<p><strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p> 
<table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table> 
<p><strong>方法的重写要遵循“两同两小一大”</strong></p> 
<ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul> 
<p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p> 
<p></p> 
<h3 id="接口和抽象类有什么共同点和区别">接口和抽象类有什么共同点和区别？</h3> 
<p><strong>共同点</strong> ：</p> 
<ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul> 
<p><strong>区别</strong> ：</p> 
<ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul> 
<p></p> 
<h3>java 值传递与址（引用）传递</h3> 
<p><strong><span style="background-color:#f9eda6;">java中方法<span style="color:#fe2c24;">参数传递</span>方式是本质上<span style="color:#fe2c24;">都是“值”传递</span></span></strong></p> 
<p>如果参数是基本类型（<strong>传“实际值”</strong>）：</p> 
<blockquote> 
 <p>由于栈中存的就是“实际值”（java基本类型的值存储在栈中，不在堆中），所以传递的是基本类型的“实际值”的拷贝。</p> 
</blockquote> 
<p> 如果参数是引用类型（<strong>传“地址值”</strong>）：</p> 
<blockquote> 
 <p>由于栈中存的是地址（该地址指向<span style="color:#ff9900;"><strong>堆内存</strong></span>中存储位置，即引用），所以传递的是“堆中的地址”的拷贝。所以我们说成是“引用（址）传递”。<br><br><strong>注意：</strong><br> 1. “<strong>String和8大基本类型的包装类”是<span style="color:#fe2c24;">不可变类型</span></strong>，即特殊的引用类型，所以每次修改操作都是新创建的对象，栈中的地址不断更换，所以出现了不能修改值的效果，让大家<strong>误以为</strong>是值传递了。<br> 2. 而一般对我们自己创建的类进行修改操作，就会顺着引用的地址“找到并修改掉”原来的值，所以达到了引用传递的效果。</p> 
</blockquote> 
<h4><a name="t1"></a></h4> 
<h3><img alt="在这里插入图片描述" src="https://images2.imgbox.com/45/0d/8sZduWQf_o.png"></h3> 
<blockquote> 
 <p>如果是基本数据类型就不会改变，因为它只是<strong>复制（拷贝）</strong>了一份数据10给n2，并没有对自己产生任何影响和改变。因而说，基本数据类型的本质是值传递，或者说值拷贝。</p> 
 <p>但是这个数组就会改变。因为上面是将arr1<strong>的地址0x0011复制（拷贝）</strong>一份给arr2，并不是直接把值复制（拷贝）给arr2，所以它们共同指向了同一个地址，相当<span style="color:#fe2c24;"><strong>于一扇门有两把钥匙</strong></span>，这两把钥匙都可以打开这扇门。因而说，引用数据类型的本质是地址传递，或者说是地址拷贝。</p> 
</blockquote> 
<h4 id="案例1-传递基本类型参数">案例1：传递基本类型参数</h4> 
<pre><code class="language-java">public static void main(String[] args) {
    int num1 = 10;
    int num2 = 20;
    swap(num1, num2);
    System.out.println("num1 = " + num1);
    System.out.println("num2 = " + num2);
}

public static void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    System.out.println("a = " + a);
    System.out.println("b = " + b);
}
</code></pre> 
<p></p> 
<pre><code>a = 20
b = 10
num1 = 10
num2 = 20
</code></pre> 
<p>解析：</p> 
<p>在 <code>swap()</code> 方法中，<code>a</code>、<code>b</code> 的值进行交换，并不会影响到 <code>num1</code>、<code>num2</code>。因为，<code>a</code>、<code>b</code> 的值，只是从 <code>num1</code>、<code>num2</code> 的复制过来的。也就是说，a、b 相当于 <code>num1</code>、<code>num2</code> 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/67/47/YYTPDHUe_o.png"></p> 
<p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例2。</p> 
<h4 id="案例2-传递引用类型参数1">案例2：传递引用类型参数1</h4> 
<pre><code class="language-java">	public static void main(String[] args) {
      int[] arr = { 1, 2, 3, 4, 5 };
      System.out.println(arr[0]);
      change(arr);
      System.out.println(arr[0]);
	}

	public static void change(int[] array) {
      // 将数组的第一个元素变为0
      array[0] = 0;
	}

//1,0</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/30/13/E1CceYqw_o.png"></p> 
<p>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。</p> 
<p>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！</p> 
<p>也就是说 <code>change</code> 方法的参数拷贝的是 <code>arr</code> （实参）的地址，因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p> 
<h4 id="案例3-传递引用类型参数2">案例3 ：传递引用类型参数2</h4> 
<pre><code class="language-java">public class Person {
    private String name;
   // 省略构造函数、Getter&amp;Setter方法
}

public static void main(String[] args) {
    Person xiaoZhang = new Person("小张");
    Person xiaoLi = new Person("小李");
    swap(xiaoZhang, xiaoLi);
    System.out.println("xiaoZhang:" + xiaoZhang.getName());
    System.out.println("xiaoLi:" + xiaoLi.getName());
}

public static void swap(Person person1, Person person2) {
    Person temp = person1;
    person1 = person2;
    person2 = temp;
    System.out.println("person1:" + person1.getName());
    System.out.println("person2:" + person2.getName());
}

//person1:小李
//person2:小张
//xiaoZhang:小张
//xiaoLi:小李
</code></pre> 
<p> 怎么回事？？？两个引用类型的形参互换并没有影响实参啊！</p> 
<p><code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cb/80/iDdbhVky_o.png"></p> 
<h3 id="总结">总结</h3> 
<p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p> 
<ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul> 
<p></p> 
<h3>String与8种基本数据类型的包装类</h3> 
<blockquote> 
 <p><strong>8种基本数据类型采用值传递，其包装类型与String与其他我们手写的类都是引用传递</strong>。<strong>只是由于String和8种包装类型都是不可变类，所以每次操作都是新创一个对象并重新赋给引用</strong>；在函数调用的时候，如果形参是String或者8种包装类型，操作形参不会影响实参，操作形参相当于重新创建对象不会影响原实参。</p> 
</blockquote> 
<h3><a name="t3"></a>可变与不可变</h3> 
<blockquote> 
 <p><strong>不可变：</strong><br><strong><u>String</u>与<u>8种包装类型</u>、BigInteger、BigDecimal是不可变类</strong>，不可变的意思是每次更换值都会重新生成对象并赋给引用。不用考虑线程安全。我们也可以设计自己的不可变类。</p> 
 <p><strong>可变：</strong><br> 其他我们手写的实体类一般都是可变类。</p> 
</blockquote> 
<p></p> 
<h3>String、StringBuffer、StringBuilder 的区别？</h3> 
<p><code>String</code> 是不可变的（后面会详细分析原因）。</p> 
<blockquote> 
 <ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol> 
</blockquote> 
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p> 
<ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol> 
<p></p> 
<h3><strong> final 在 Java 中有什么作用？</strong></h3> 
<ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul> 
<hr> 
<h3></h3> 
<h2>异常与错误</h2> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c1/52/TirK74zK_o.png"></p> 
<p></p> 
<h3><img alt="" height="576" src="https://images2.imgbox.com/3a/a5/uVFPQr00_o.png" width="1075"></h3> 
<p></p> 
<h3 id="exception-和-error-有什么区别">Exception 和 Error 有什么区别？</h3> 
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p> 
<ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，<s>我们没办法通过 <code>catch</code> 来进行捕获</s>不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul> 
<h3 id="checked-exception-和-unchecked-exception-有什么区别">Checked Exception 和 Unchecked Exception 有什么区别？</h3> 
<p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p> 
<p></p> 
<h3 id="throwable-类常用方法有哪些">Throwable 类常用方法有哪些？</h3> 
<ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul> 
<p></p> 
<h3>throw和throws的区别？</h3> 
<p>一、语法位置不同。throw用于函数内部，后面跟的是异常对象，而throws用于函数结尾，后面跟的是异常类，后面可以跟多个不同的异常类，表示抛出不同的异常</p> 
<p>二、关键字功能不同。throw用于抛出异常，并将问题立即抛出给上一级的调用者，</p> 
<p>并且当throw执行到时，后面的其他语句不会执行。而throws只是用于声明异常，让调用者知道这里可能会出现问题，并提前处理异常发生情况，属于一种提前通知。</p> 
<p>相同点：那就是都是被动的方式（不主动处理）来处理异常，只是抛出异常，真正处理异常的往往是由调用他们的上层函数去捕获处理。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0f/6f/IQtTDpu8_o.png"></p> 
<p></p> 
<h3 id="try-catch-finally-如何使用">try-catch-finally 如何使用？</h3> 
<ul><li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li><li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul> 
<blockquote> 
 <ol><li>finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol> 
</blockquote> 
<h3></h3> 
<h3>自定义异常类型</h3> 
<p>​ Java 的异常机制中所定义的所有异常不可能预见所有可能出现的错误，某些特定的情境下，则需要我们自定义异常类型来向上报告某些错误信息。</p> 
<p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p> 
<ul><li>所有异常都必须是 Throwable 的子类。</li><li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li><li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li></ul> 
<p>是自定义运行时异常：</p> 
<pre><code class="language-java">
public class ServiceException extends RuntimeException{
    // 错误码
    private Integer code;

    // 错误信息
    private String message;
    
    // 空构造
    public ServiceException(){}

    public ServiceException(String message, Integer code)
    {
        this.message = message;
        this.code = code;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    @Override
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre> 
<p>在需要抛出这个异常的地方，我们可以这样：</p> 
<pre><code class="language-java">throw new ServiceException(102,"业务出问题了");
</code></pre> 
<h4 id="_3、异常链"></h4> 
<h2><span style="color:#38d8f0;">面向对象</span></h2> 
<h3>概念</h3> 
<blockquote> 
 <p>类：不存在的，人类大脑思考总结一个模板（这个模板当中描述了共同特征。）</p> 
 <p>对象：实际存在的个体。 实例：对象还有另一个名字叫做实例。</p> 
 <p>实例化：通过类这个模板创建对象的过程，叫做：实例化。</p> 
 <p>抽象：多个对象具有共同特征，进行思考总结抽取共同特征的过程。</p> 
</blockquote> 
<p><strong>类 --【实例化】--&gt; 对象(实例)</strong> <strong>​ </strong></p> 
<p><strong>对象 --【抽象】--&gt; 类</strong></p> 
<p></p> 
<h3>对象和引用的区别？</h3> 
<p><strong>对象</strong>是通过new出来的，在<strong>堆内存中存储</strong>。 ​</p> 
<p>引用是：但<strong>凡是变量</strong>，并且该<strong>变量中</strong>保存了<strong>内存地址</strong>指向了堆内存当中的<strong>对象</strong>的。</p> 
<p></p> 
<h3><strong>普通类和抽象类有哪些区别？</strong></h3> 
<ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li><li></ul> 
<h3><strong>抽象类能使用 final 修饰吗？</strong></h3> 
<p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类。</p> 
<p></p> 
<h3><strong>接口和抽象类有什么区别？</strong></h3> 
<ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul> 
<p></p> 
<h3>静态方法和实例方法有何不同？</h3> 
<ol><li>在外部调用静态方法时，只能使用"类名.方法名"的方式，不能使用"对象名.方法名"的方式。而实例方法可以使用"对象名.方法名"的方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ol> 
<p></p> 
<h3><strong><span style="background-color:#fbd4d0;">成员变量和静态变量和static</span></strong></h3> 
<p><strong><em>类变量==静态变量          </em></strong> <strong>实例变量</strong>实际上就是：<strong>对象级别</strong>的变量。</p> 
<p></p> 
<h4>成员变量和类变量的区别</h4> 
<blockquote> 
 <p>1、两个变量的生命周期不同</p> 
 <p>                成员变量随着对象的创建而存在，随着对象的回收而释放。</p> 
 <p>                静态变量随着类的加载而存在，随着类的消失而消失。</p> 
 <p>2、调用方式不同</p> 
 <p>                成员变量只能被对象调用。</p> 
 <p>                静态变量可以被对象调用，还可以被类名调用。</p> 
 <p>3、别名不同</p> 
 <p>                成员变量也称为实例变量。</p> 
 <p>                静态变量也称为类变量。</p> 
 <p>4、数据存储位置不同</p> 
 <p>                成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</p> 
 <p>                静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。</p> 
</blockquote> 
<p></p> 
<h4>static修饰成员方法</h4> 
<p>static修饰的方法一般称作<strong>静态方法</strong>，由于静态方法<strong>不依赖于任何对象</strong>就可以进行访问，因此对于静态方法来说，是<strong>没有this</strong>的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。</p> 
<p>并且由于这个特性，在<strong>静态方法</strong>中不能访问类的<strong>非</strong>静态成员变量和非静态成员方法，因为非静态成员方法/变量都<strong>必须依赖具体的对象</strong>才能够被调用。</p> 
<p>但是在<strong>非静态成员方法</strong>中是<strong>可以访问静态成员方法/变量</strong>的。</p> 
<p>static修饰的统一都是静态的，都是<strong>类相关</strong>的，<strong>不需要new对象</strong>。直接<strong>采用“类名.”访问</strong>。</p> 
<p></p> 
<h4>static修饰成员变量</h4> 
<p>static修饰的变量也称为<strong>静态变量</strong>，静态变量和非静态变量的区别是：<strong>静态变量被所有对象共享</strong>，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。<strong>（可以修改）==等于全局变量</strong></p> 
<p>static成员变量的初始化顺序按照定义的顺序进行初始化。</p> 
<p></p> 
<h4>static修饰代码块</h4> 
<p>static关键字还有一个比较重要的作用就是用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在<strong>类初次被加载的时候</strong>，会按照static块的顺序来<strong>依次执行每个static块</strong>，并且只会执行一次。</p> 
<p>static块可以优化程序性能，是因为它的特性：<strong>只会</strong>在类被初次加载的时候<strong>执行一次</strong>。(丢进内存)</p> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">优先级</span>：<span style="color:#fe2c24;">父类</span>静态代码块 &gt; <span style="color:#fe2c24;">子类</span>静态代码块 &gt; <span style="color:#fe2c24;">父类</span>构造代码块 &gt; <span style="color:#fe2c24;">父类</span>构造方法 &gt; 子类构造代码块 &gt; 子类构造方法</strong><br> 静态执行一次!</p> 
</blockquote> 
<pre><code class="language-java">import com.lgx.jdbc.TestJdbc;
//创建一个含有静态代码块、构造代码块和自己的构造方法（非继承父类）的类
public class TestStaticCoding {
    static {//静态代码块定义
        System.out.println("静态代码块");
    }
    {//构造代码块的创建
        System.out.println("构造代码块");
    }
    public TestStaticCoding(){//类的构造方法定义
        super();//先调用父类的构造方法
        System.out.println("构造方法");//在实例化自己的对象的时候，要做的事
    }
     public static void main(String[] args) throws ClassNotFoundException {
        Class.forName("com.study.staticcoding.TestStaticCoding");//这个时候类被加载，静态代码块被执行一次，类再进程中被加载过了，以后不会再加载了
 
        new TestStaticCoding();//创建一个类的对象，这个时候类早已被加载了，只会先执行构造代码块，再执行构造方法
        new TestStaticCoding();
    }
 
}</code></pre> 
<p> 执行的结果：</p> 
<p>类加载时，执行静态代码块，类的对象创建时 ，先执行构造代码块，再执行构造方法</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/ad/98/EuhMDNHW_o.png" width="418"></p> 
<p></p> 
<h4>弊端</h4> 
<blockquote> 
 <p>1、有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。</p> 
 <p>2、静态方法只能访问静态成员，不可以访问非静态成员。因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。</p> 
 <p>3、静态方法中不能使用this，super关键字。因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。</p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<h2><span style="color:#956fe7;">泛型</span></h2> 
<p></p> 
<h3>概念</h3> 
<p></p> 
<p><strong>Java泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常</strong>.</p> 
<p>泛型：<strong>把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型</strong></p> 
<p>参数化类型:</p> 
<ul><li> <p><strong>把类型当作是参数一样传递</strong></p> </li><li> <p><strong><code>&lt;数据类型&gt;</code> 只能是引用类型</strong></p> </li></ul> 
<p>相关术语：</p> 
<ul><li> <p><code>ArrayList&lt;E&gt;</code>中的<strong>E称为类型参数变量</strong></p> </li><li> <p><code>ArrayList&lt;Integer&gt;</code>中的<strong>Integer称为实际类型参数</strong></p> </li><li> <p><strong>整个称为<code>ArrayList&lt;E&gt;</code>泛型类型</strong></p> </li><li> <p><strong>整个<code>ArrayList&lt;Integer&gt;</code>称为参数化的类型ParameterizedType</strong></p> </li></ul> 
<blockquote> 
 <p>JDK8新特性：<strong>钻石表达式</strong> List&lt;String&gt; list = new ArrayList&lt;&gt;(); 类型自动推断！</p> 
</blockquote> 
<h3>泛型的作用</h3> 
<ul><li> <p>代码更加简洁【不用强制转换】</p> </li><li> <p>程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】</p> </li><li> <p>可读性和稳定性【在编写集合的时候，就限定了类型】</p> </li></ul> 
<blockquote> 
 <p><strong>早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题，这样程序就不太安全</strong></p> 
</blockquote> 
<h3>泛型后的遍历</h3> 
<p>在创建集合的时候，<strong>我们明确了集合的类型了</strong>，所以我们可以使用增强for来遍历集合！</p> 
<pre>    //创建集合对象
    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
​
    list.add("hello");
    list.add("world");
    list.add("java");
​
    //遍历,由于明确了类型.我们可以增强for
    for (String s : list) {
        System.out.println(s);
    }</pre> 
<h3>泛型类</h3> 
<pre>/*
    1:把泛型定义在类上
    2:类型变量定义在类上,方法中也可以使用
 */
public class ObjectTool&lt;T&gt; {
    private T obj;
​
    public T getObj() {
        return obj;
    }
​
    public void setObj(T obj) {
        this.obj = obj;
    }
}</pre> 
<blockquote> 
 <p><strong>用户想要使用哪种类型，就在创建的时候指定类型。使用的时候，该类就会自动转换成用户想要使用的类型了。</strong></p> 
</blockquote> 
<pre>    public static void main(String[] args) {
        //创建对象并指定元素类型
        ObjectTool&lt;String&gt; tool = new ObjectTool&lt;&gt;();
​
        tool.setObj(new String("罗海江"));
        String s = tool.getObj();
        System.out.println(s);
​
​
        //创建对象并指定元素类型
        ObjectTool&lt;Integer&gt; objectTool = new ObjectTool&lt;&gt;();
        /**
         * 如果我在这个对象里传入的是String类型的,它在编译时期就通过不了了.
         */
        objectTool.setObj(10);
        int i = objectTool.getObj();
        System.out.println(i);
    }</pre> 
<h3>泛型方法</h3> 
<ul><li> <p>定义泛型方法....<strong>泛型是先定义后使用的</strong></p> </li></ul> 
<pre>    //定义泛型方法..
    public &lt;T&gt; void show(T t) {
        System.out.println(t);
    }
​
​
    public static void main(String[] args) {
        //创建对象
        ObjectTool tool = new ObjectTool();
​
        //调用方法,传入的参数是什么类型,返回值就是什么类型
        tool.show("hello");
        tool.show(12);
        tool.show(12.5);
​
    }</pre> 
<h3>泛型类派生出的子类</h3> 
<p><strong>泛型类是拥有泛型这个特性的类，它本质上还是一个Java类，那么它就可以被继承</strong></p> 
<p>那它是怎么被继承的呢？？这里分两种情况</p> 
<h4>子类<strong>明确</strong>泛型类的类型参数变量</h4> 
<pre>/*
    把泛型定义在接口上
 */
interface Inter&lt;T&gt; {
    public abstract void show(T t);
​
}
​
​
/**
 * 子类明确泛型类的类型参数变量:
 */
​
class InterImpl implements Inter&lt;String&gt; {
    @Override
    public void show(String s) {
        System.out.println(s);
    }
}</pre> 
<p></p> 
<h4>子类<strong>不明确</strong>泛型类的类型参数变量</h4> 
<ul><li> <p>当子类不明确泛型类的类型参数变量时，<strong>外界使用子类的时候，也需要传递类型参数变量进来，在实现类上需要定义出类型参数变量</strong></p> </li></ul> 
<pre>/*
    把泛型定义在接口上
 */
interface Inter&lt;T&gt; {
    public abstract void show(T t);
}
​
/**
 * 子类不明确泛型类的类型参数变量:
 *      实现类也要定义出&lt;T&gt;类型的
 *
 */
class InterImpl&lt;T&gt; implements Inter&lt;T&gt; {
    @Override
    public void show(T t) {
        System.out.println(t);
    }
}</pre> 
<h4>测试代码</h4> 
<pre>    public static void main(String[] args) {
        //第一种情况测试
        Inter&lt;String&gt; i = new InterImpl();
        i.show("hello");
        //第二种情况测试
        Inter&lt;String&gt; ii = new InterImp2&lt;&gt;();
        ii.show("100");
    }</pre> 
<blockquote> 
 <ul><li> <p><strong>实现类的要是重写父类的方法，返回值的类型是要和父类一样的！</strong></p> </li><li> <p><strong>类上声明的泛形只对非静态成员有效</strong></p> </li></ul> 
</blockquote> 
<h3>类型通配符</h3> 
<p>题目：接收一个集合参数，遍历集合并把集合元素打印出来，怎么办？</p> 
<pre>//出现警告，说没有确定集合元素的类型....这样是不优雅的...
    public void test(List list) {
        for (Object o : list) {
            System.out.println(o);
        }
    }
//下面都可以
    public void test1(List&lt;Object&gt; list){
        for (Object o : list) {
            System.out.println(o);
        }
    }
​
    public void test2(List&lt;?&gt; list){
        for (Object o : list) {
            System.out.println(o);
        }
    }</pre> 
<p></p> 
<p></p> 
<p></p> 
<h3></h3> 
<p></p> 
<h3></h3> 
<p><br>  </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd4dd24a577cfefac51737a61754217b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">import _jpype ImportError: DLL load failed while importing _jpype: 动态链接库(DLL)初始化例程失败。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47053588eba60f0f53f850be9f73152a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UDS协议的项目应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>