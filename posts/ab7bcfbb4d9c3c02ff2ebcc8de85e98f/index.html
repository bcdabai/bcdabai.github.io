<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二十四种设计模式、七大原则 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二十四种设计模式、七大原则" />
<meta property="og:description" content=" 转自：http://www.taidous.com/thread-41942-1-3.html
程序：
1.可维护性 2.可复用性 3.可扩展性 4.灵活性好 通过封装、继承、多态把程序的耦合度降低 简单工厂模式: 用一个独立的类来做这个创造实例的过程 聚合表示一种弱的&#34;拥有关系&#34;，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。 合成表示一种强的&#34;拥有关系&#34;, 体现了严格的部分和整体的关系，部分和整体的生命周期一样。 优点：工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类。，对于客户端来说，去除了与具体产品的依赖。 策略模式： 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的用户。 装饰模式： 动态地给对象添加一些额外的职责（为功能动态添加更多功能的一种方式），就增加功能来说，装饰模式比生成子类更加的灵活。 好处：有效的把类的核心职责和装饰功能区分开了。 装饰模式将每个要装饰的功能都放在单独的类中，并让这个类包装它所要装饰的对象，一次，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。 有效的把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。 代理模式： （双方不需要知道对方的存在，通过中间人进行代码的调用） 为其他对象提供一种代理以控制对这个对象的访问 远程代理：也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。 虚拟代理：是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象[DP]。 安全代理：用来控制真实对象访问的权限[DP]。 智能指引：是指当调用真实的对象时，代理处理另外一些事[DP]。 工厂方法模式： 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 原型模式： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 （一般在初始化的信息不发生变化的情况下， 克隆是最好的方法。这即隐藏了对象的创建细节，又对性能是大大的提高） 浅复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 深复制：把引用对象的变量都指向复制过的新对象，而不是原有的被引用的对象。 简单来说：浅复制复制值类型，引用类型赋值的是引用的地址 深复制引用类型复制的是引用类型的对象，就是在需要改变的值的基类中声明一个克隆方法并在具体类中调用 模版方法模式： 定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 当我们要完成在某一细节层次一致的一个过程或一个系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们同城考虑使用模版方法。 通过把不变行为搬移到超类，去除子类中的重复代码来提现它的优势。模版方法模式提供了一很好的代码复用平台。 外观模式： 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 简单来说：就是将你一次需要调用的方法整理在一个接口里面，调用接口，直接就调用了方法。 建造者模式（生成器模式）: 用户只需制定需要建造的类型就可以得到它们，而具体建造过程和细节就不需知道了。 将一个复杂对象的构造与它的表示分离，使得同样的构建过程可以创建不同的表示。 简单来说：我们需要建造一样东西，客户端不需要知道建造过程，只需要知道要造什么就可以了。 观察者模式： 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自己更新自己。 抽象工厂模式: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 好处：易于交换产品系列。具体的创建实例过程与客户端分离。客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。 状态模式： 当一个对象的内在状态改变时允许改变其作为，这个对象看起来是像是改变了其类。 将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所有通过定义新的子类可以很容易地增加新的状态和转换。 简单来说“对象的行为取决于它的状态，并且需要在运行时改变它的状态。那么就应该用状态模式。 当你有大量的判断语句，那么将每一个判断写成一个方法。当达到某一个要求的时候，提供另外一个且只有一个方法，减少了相互之间的耦合性。 适配器模式： 当系统的数据和行为都正确，但结构不符时，我们应该考虑用适配器，目的就是使控制范围之外的一个原有对象和某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。 简单来说：当两个类需要互相调用，但是接口不符合的时候，就用适配器模式，讲接口适配成相同的，进行匹配。（当然，只有当无法改变原有设计和代码的情况下，才考虑适配模式） 备忘录模式： 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。这样以后就可将该对象恢复到原先保存的状态。 用于功能比较复杂的，但需要维护和记录属性历史的类。 缺点：会非常消耗内存 组合模式： 将对象组合成树形结构以表示&#34;部分-整体&#34;的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 当你发现需求中是体现部分与整体层次的结构时，以及你希望用于可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式。 组合模式的体现方式有点像树状结构，不断的细分下去。 迭代器模式： 提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。 类似于foreach循环 这样做的目的就是不让外部访问到内部的结构，但是可以访问到内部的数据。 单例模式： 保证一个类仅有一个实例，并提供一个访问它的全局的访问点。 通常我们可以让一个全局变量使得一个对象的被访问，但它不能放置你实例化对个对象。所以我们需要然各类自身负责保存它的唯一实例。这个类可以爆照没有其他实例可以被创建，并且它可以提供一个额访问该实例的方法。 简单来说：就是对唯一实例的受控访问。 多线程的单例模式：在多个线程中，我们需要同时访问某一个类的时候，这样就会同时创建多个实例，所以 我们需要加一把锁来处理（lock）,如果有一个线程已经处在代码的临界区内的时候，另外一个线程就需要等待，直到临界区内的线程被释放。 桥接模式： 将抽象部分与它的实现部分分离，使他们都可以独立地变化。 简单来说：我们需要多角度分类的时候，可以用桥接模式，让它们各自变化。这部分变化不会影响到其他实现。从而达到应对变化的目的，减少他们之间的耦合性。 命令模式： 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。 职责链模式： 当多个对象都有机会处理这个事件的时候，就将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 中介者模式： 用一个中介者对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而降低耦合性。而且可以独立地改变它们之间的交互。（缺点是：不容易维护） 享元模式： 运用共享技术有效地支持大量细粒度的对象。（当一个程序使用大量的对象的时候，就应该考虑享元模式） 简单来说：就是在程序的开发过程中，有许多实例大部分内容都是相同的，那么我们就需要通过享元模式大幅度的减少单个实例的数目，从而降低服务器的占用资源。 解释器模式： 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 简单来说：就是语言翻译器的功能，当输入一段文字后，通过返回得到一段固定不变的文字。 访问器模式（GoF中最复杂的模式）： 表示一个作用与某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用与这个元素的新操作。 访问器模式适用于数据结构相对稳定的系统，因为它的作用是把数据结构和作用于结构上的操作之间的耦合性解脱开，使得操作集合可以相对自由地演化。（假设如果你需要增加一个新的操作的时候，就要增加一个新的访问者，那么访问器模式就是讲有关的行为集中到一个访问者对象中，） 单一职责原则 就一个类而言，应该仅有一个引起它变化的原因（如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多一个的职责，就应该考虑类的职责分离） 开放-封闭原则 对扩展是开放的。对更改是关闭的。 依赖倒转原则 抽象不应该依赖细节，细节应该依赖于抽象 高层模块不应该依赖低层模块。两个都应该依赖抽象 里氏代换原则 子类型必须能够替换它们的父类型 只有当子类可以替换掉父类，软在·件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。 真是因为子类的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。 如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的射击，反之那就是过程化的设计。 迪米特原则 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 合成/聚合复用原则 如果新对象的某些功能在别的已经创建好的对象里面已经实现，那么尽量使用别的对象提供的功能，使之成为新对象的一部分，而不要自己再重新创建。新对象通过向这些对象的委派达到复用已有功能的。 简而言之，要尽量使用合成/聚合，尽量不要使用继承。 接口隔离原则 不需要将所有的东西都放在一个接口里面，应该是定义多个功能专一的接口。过于臃肿的接口只会强迫客户依赖于不需要的方法。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ab7bcfbb4d9c3c02ff2ebcc8de85e98f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-14T17:46:43+08:00" />
<meta property="article:modified_time" content="2017-01-14T17:46:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二十四种设计模式、七大原则</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">转自：http://www.taidous.com/thread-41942-1-3.html</span></span></span></p> 
<p><span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700"><br> </span></span></span></p> 
<p><span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">程序：</span></span></span></p> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>1.可维护性 2.可复用性   3.可扩展性  4.灵活性好 </span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>通过封装、继承、多态把程序的耦合度降低</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">简单工厂模式:</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>用一个独立的类来做这个创造实例的过程</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>聚合表示一种弱的"拥有关系"，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>合成表示一种强的"拥有关系", 体现了严格的部分和整体的关系，部分和整体的生命周期一样。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>优点：工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类。，对于客户端来说，去除了与具体产品的依赖。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">策略模式：</span></span></span> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> </span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的用户。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">装饰模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>动态地给对象添加一些额外的职责（为功能动态添加更多功能的一种方式），就增加功能来说，装饰模式比生成子类更加的灵活。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>好处：有效的把类的核心职责和装饰功能区分开了。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>装饰模式将每个要装饰的功能都放在单独的类中，并让这个类包装它所要装饰的对象，一次，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>有效的把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">代理模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>（双方不需要知道对方的存在，通过中间人进行代码的调用）</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>为其他对象提供一种代理以控制对这个对象的访问</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>远程代理：也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>虚拟代理：是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象[DP]。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>安全代理：用来控制真实对象访问的权限[DP]。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>智能指引：是指当调用真实的对象时，代理处理另外一些事[DP]。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='word-wrap:break-word; padding:0px; margin:0px; font-weight:700; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'><span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px">工厂方法模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">原型模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>（一般在初始化的信息不发生变化的情况下， 克隆是最好的方法。这即隐藏了对象的创建细节，又对性能是大大的提高）</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>浅复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>深复制：把引用对象的变量都指向复制过的新对象，而不是原有的被引用的对象。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>简单来说：浅复制复制值类型，引用类型赋值的是引用的地址   深复制引用类型复制的是引用类型的对象，就是在需要改变的值的基类中声明一个克隆方法并在具体类中调用</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">模版方法模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>当我们要完成在某一细节层次一致的一个过程或一个系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们同城考虑使用模版方法。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>通过把不变行为搬移到超类，去除子类中的重复代码来提现它的优势。模版方法模式提供了一很好的代码复用平台。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">外观模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>简单来说：就是将你一次需要调用的方法整理在一个接口里面，调用接口，直接就调用了方法。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">建造者模式（生成器模式）:</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>用户只需制定需要建造的类型就可以得到它们，而具体建造过程和细节就不需知道了。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>将一个复杂对象的构造与它的表示分离，使得同样的构建过程可以创建不同的表示。      </span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>简单来说：我们需要建造一样东西，客户端不需要知道建造过程，只需要知道要造什么就可以了。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">观察者模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自己更新自己。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='word-wrap:break-word; padding:0px; margin:0px; font-weight:700; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'><span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px">抽象工厂模式:</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>好处：易于交换产品系列。具体的创建实例过程与客户端分离。客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">状态模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>当一个对象的内在状态改变时允许改变其作为，这个对象看起来是像是改变了其类。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>          将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所有通过定义新的子类可以很容易地增加新的状态和转换。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>          简单来说“对象的行为取决于它的状态，并且需要在运行时改变它的状态。那么就应该用状态模式。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>          当你有大量的判断语句，那么将每一个判断写成一个方法。当达到某一个要求的时候，提供另外一个且只有一个方法，减少了相互之间的耦合性。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">适配器模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>当系统的数据和行为都正确，但结构不符时，我们应该考虑用适配器，目的就是使控制范围之外的一个原有对象和某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>            简单来说：当两个类需要互相调用，但是接口不符合的时候，就用适配器模式，讲接口适配成相同的，进行匹配。（当然，只有当无法改变原有设计和代码的情况下，才考虑适配模式）</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">备忘录模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。这样以后就可将该对象恢复到原先保存的状态。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>    用于功能比较复杂的，但需要维护和记录属性历史的类。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>    缺点：会非常消耗内存</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">组合模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>             当你发现需求中是体现部分与整体层次的结构时，以及你希望用于可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>             组合模式的体现方式有点像树状结构，不断的细分下去。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='word-wrap:break-word; padding:0px; margin:0px; font-weight:700; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'><span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px">迭代器模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。  </span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>            类似于foreach循环</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>            这样做的目的就是不让外部访问到内部的结构，但是可以访问到内部的数据。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:仿宋,仿宋_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">单例模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>保证一个类仅有一个实例，并提供一个访问它的全局的访问点。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>          通常我们可以让一个全局变量使得一个对象的被访问，但它不能放置你实例化对个对象。所以我们需要然各类自身负责保存它的唯一实例。这个类可以爆照没有其他实例可以被创建，并且它可以提供一个额访问该实例的方法。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>           简单来说：就是对唯一实例的受控访问。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>          多线程的单例模式：在多个线程中，我们需要同时访问某一个类的时候，这样就会同时创建多个实例，所以 我们需要加一把锁来处理（lock）,如果有一个线程已经处在代码的临界区内的时候，另外一个线程就需要等待，直到临界区内的线程被释放。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">桥接模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>将抽象部分与它的实现部分分离，使他们都可以独立地变化。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>          简单来说：我们需要多角度分类的时候，可以用桥接模式，让它们各自变化。这部分变化不会影响到其他实现。从而达到应对变化的目的，减少他们之间的耦合性。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">命令模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">职责链模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>当多个对象都有机会处理这个事件的时候，就将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">中介者模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>用一个中介者对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而降低耦合性。而且可以独立地改变它们之间的交互。（缺点是：不容易维护）</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='word-wrap:break-word; padding:0px; margin:0px; font-weight:700; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'><span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px">享元模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>运用共享技术有效地支持大量细粒度的对象。（当一个程序使用大量的对象的时候，就应该考虑享元模式）</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>          简单来说：就是在程序的开发过程中，有许多实例大部分内容都是相同的，那么我们就需要通过享元模式大幅度的减少单个实例的数目，从而降低服务器的占用资源。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='word-wrap:break-word; padding:0px; margin:0px; font-weight:700; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'><span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px">解释器模式：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>            简单来说：就是语言翻译器的功能，当输入一段文字后，通过返回得到一段固定不变的文字。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">访问器模式（GoF中最复杂的模式）：</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>表示一个作用与某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用与这个元素的新操作。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>           访问器模式适用于数据结构相对稳定的系统，因为它的作用是把数据结构和作用于结构上的操作之间的耦合性解脱开，使得操作集合可以相对自由地演化。（假设如果你需要增加一个新的操作的时候，就要增加一个新的访问者，那么访问器模式就是讲有关的行为集中到一个访问者对象中，）</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">单一职责原则</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>  就一个类而言，应该仅有一个引起它变化的原因（如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多一个的职责，就应该考虑类的职责分离）</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">开放-封闭原则</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>  对扩展是开放的。对更改是关闭的。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">依赖倒转原则</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>抽象不应该依赖细节，细节应该依赖于抽象</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>高层模块不应该依赖低层模块。两个都应该依赖抽象</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">里氏代换原则</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>  子类型必须能够替换它们的父类型</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>  只有当子类可以替换掉父类，软在·件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>  真是因为子类的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>  如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的射击，反之那就是过程化的设计。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">迪米特原则</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>  如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-size:14px; background-color:rgb(252,252,252)"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px"><span style="word-wrap:break-word; padding:0px; margin:0px; font-weight:700">合成/聚合复用原则</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>    如果新对象的某些功能在别的已经创建好的对象里面已经实现，那么尽量使用别的对象提供的功能，使之成为新对象的一部分，而不要自己再重新创建。新对象通过向这些对象的委派达到复用已有功能的。 </span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>简而言之，要尽量使用合成/聚合，尽量不要使用继承。 </span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='word-wrap:break-word; padding:0px; margin:0px; font-weight:700; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'><span style="font-family:楷体,楷体_GB2312; word-wrap:break-word; padding:0px; margin:0px"><span style="font-size:24px; word-wrap:break-word; padding:0px; margin:0px">接口隔离原则</span></span></span> 
<br style='word-wrap:break-word; padding:0px; margin:0px; color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'> 
<span style='color:rgb(68,68,68); font-family:"microsoft yahei"; font-size:14px; background-color:rgb(252,252,252)'>不需要将所有的东西都放在一个接口里面，应该是定义多个功能专一的接口。过于臃肿的接口只会强迫客户依赖于不需要的方法。</span>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e4cda49eb260dde615d4dae9b3572b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">easyui-datagrid获取行和列数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/37c98b5592c3bb96fc639fcec600b0ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">POJ1631——Bridging signals(动态规划)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>