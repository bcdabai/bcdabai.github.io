<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 进程(七) 进程地址空间 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 进程(七) 进程地址空间" />
<meta property="og:description" content="虚拟地址/线性地址 学习c语言的时候我们经常会用到 “&amp;” 符号，以及下面这张表，那么取出来的地址是否对应的是真实的物理地址呢？下面我们来写代码一步一步的验证。
从上面这张图不难看出，从正文代码，到命令行参数环境变量，的地址依次是从低到高的，我们来写一段代码验证一下。
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int g_unval; int g_val= 100; int main() { printf(&#34;code addr:%p\n&#34;,main); printf(&#34;init data addr:%p\n&#34;,&amp;g_val); printf(&#34;uninit data addr: %p\n&#34;,&amp;g_unval); char* heap = (char*)malloc(20); printf(&#34;heap addr:%p\n&#34;,heap); printf(&#34;stack addr:%p\n&#34;,&amp;heap); return 0; } 从这里我们不难发现：地址确实是从高到低依次出现的。
那么命令行参数以及环境变量呢，下面我们再多写几组代码。
int g_unval; int g_val= 100; int main(int argc,char* argv[],char* env[]) { printf(&#34;code addr:%p\n&#34;,main); printf(&#34;init data addr:%p\n&#34;,&amp;g_val); printf(&#34;uninit data addr: %p\n&#34;,&amp;g_unval); char* heap = (char*)malloc(20); char* heap1 = (char*)malloc(20); char* heap2 = (char*)malloc(20); char* heap3 = (char*)malloc(20); printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4d01f9336b4da7bafb4483a1450d227c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T21:46:18+08:00" />
<meta property="article:modified_time" content="2024-01-03T21:46:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 进程(七) 进程地址空间</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4> 虚拟地址/线性地址</h4> 
<p>        学习c语言的时候我们经常会用到 “&amp;” 符号，以及下面这张表，那么取出来的地址是否对应的是真实的物理地址呢？下面我们来写代码一步一步的验证。</p> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/db/cc/b1S76nvZ_o.png" width="213"></p> 
<p>        从上面这张图不难看出，从正文代码，到命令行参数环境变量，的地址依次是从低到高的，我们来写一段代码验证一下。</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int g_unval;
int g_val= 100;

int main()
{

  printf("code addr:%p\n",main);
  printf("init data addr:%p\n",&amp;g_val);
  printf("uninit data addr: %p\n",&amp;g_unval);
  
  char* heap = (char*)malloc(20);

  printf("heap addr:%p\n",heap);
  printf("stack addr:%p\n",&amp;heap);

  return 0;
}
</code></pre> 
<p>        从这里我们不难发现：地址确实是从高到低依次出现的。</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/bf/07/X359a4mL_o.png" width="616"></p> 
<p>        那么命令行参数以及环境变量呢，下面我们再多写几组代码。</p> 
<pre><code>int g_unval;
int g_val= 100;


int main(int argc,char* argv[],char* env[])
{

  printf("code addr:%p\n",main);
  printf("init data addr:%p\n",&amp;g_val);
  printf("uninit data addr: %p\n",&amp;g_unval);
  
  char* heap = (char*)malloc(20);
  char* heap1 = (char*)malloc(20);
  char* heap2 = (char*)malloc(20);
  char* heap3 = (char*)malloc(20);
  printf("heap addr:%p\n",heap);
  printf("heap1 addr:%p\n",heap1);
  printf("heap2 addr:%p\n",heap2);
  printf("heap3 addr:%p\n",heap3);

  printf("stack addr:%p\n",&amp;heap);
  printf("stack1 addr:%p\n",&amp;heap1);
  printf("stack2 addr:%p\n",&amp;heap2);
  printf("stack3 addr:%p\n",&amp;heap3);

  for(int i = 0; argv[i] ; i++)
  {
    printf("argv[%d] addr: %p\n",i,argv[i]);
  }

  for(int i = 0; env[i];i++)
  {
    printf("env[%d] addr: %p\n",i,env[i]);
  }

  return 0;
}
</code></pre> 
<p><img alt="" height="667" src="https://images2.imgbox.com/51/4f/siTrNt2b_o.png" width="913"></p> 
<p>        <strong>从上面的结果我们不难发现，栈和堆的地址的是相对而生的，而且命令行参数的的地址确实是在地址空间的最高处。</strong></p> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/88/e5/S0bfjRYN_o.png" width="300"></p> 
<p>        <strong>注意：使用static 定义的变量的地址在初始化变量地址的上面，并且在未初始化地址的下，因为static会初始化变量并且赋值为1。</strong></p> 
<p>        下面我们来看一段代码   </p> 
<pre><code>int g_val = 100;

int main()
{
  pid_t id = fork();

  int cnt = 0;

  if(id == 0)
  {
    while(1){
    printf("i am child    process,ppid: %d,pid: %d g_val:  %d,&amp;g_val:  %p\n "  ,getppid(),getpid(),g_val,&amp;g_val);
    sleep(1);
    cnt++;
    if(cnt == 5)
    {
      g_val = 200;
      printf("child change g_val: 100-&gt; 200\n");
    }
    }
  }

    else{

    while(1){ 
    printf("i am parent   process,ppid: %d,pid: %d g_val:  %d,&amp;g_val: %p\n "  ,getppid(),getpid(),g_val,&amp;g_val);
    sleep(1);
    } 
    }
  return 0;
}
</code></pre> 
<p>        <strong>上述代码，父进程和子进程同时创建，然后通过子进程修改全局变量的结果。</strong></p> 
<p><strong>        代码执行的结果。</strong></p> 
<p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/24/a7/zbWPiQZX_o.png" width="944"></p> 
<p>      <strong>  我们发现，g_val 的值在五秒之前没有发生变化，且父子进程中 g_val地址都是相同的，这没有什么好困惑的。</strong></p> 
<p>        <strong>五秒之后，我们修改了g_val 的值，但是此次，g_val 打印出来的值 是不同的，但是打印出来的地址却是相同的。</strong></p> 
<p>        <strong>那么这是我们错了，还是计算机错了？显然计算机肯定是不会错的。那这个地址是真实存在的物理地址吗？肯定不是的，这是计算机给我们的虚拟地址/线性地址。</strong></p> 
<p></p> 
<h4>进程地址空间：</h4> 
<p>        所以说我们平时说的程序的地址空间是不对的，应该叫进程地址空间，那么该如何理解呢？</p> 
<p>        什么是地址空间：每个进程都会存在一个进程地址空间，其大小为[0,4GB]。</p> 
<p>        那么为什么会出现上述这种情况呢？</p> 
<p><img alt="" height="715" src="https://images2.imgbox.com/bb/58/xFnVyQrT_o.png" width="1045"></p> 
<p>        父进程在创建子进程的的时候发生类似于浅拷贝的行为，所以子进程会继承大量父进程的属性，包括页表，页表是虚拟和物理地址真实映射的一种关系表。每一个进程都会有一张属于自己的页表。</p> 
<p>        当子进程要修改数据的时候,触发写时拷贝。操作系统就会介入进来，为子进程专门准备一块空间，存放修改后的数据，保护了进程的独立性。但是在子进程页表上所对应的虚拟地址却没有被修改，只是子进程页表上虚拟地址对应的物理地址被修改了。</p> 
<p>        <strong>页表上不仅仅有虚拟地址和物理地址的映射，还有权限位。当子进程尝试对数据进行修改的时候(代码默认不被修改)，会触发写时拷贝，这时候引起缺页中断，操作系统介入进来，然后判断写入是否合法，当行为合法时，操作系统会为子进程开辟物理空间。然后子进程对自己的数据进行写入和修改。</strong></p> 
<p>        <strong>不管是c/c++ 语言，“&amp;” 打印的都是进程的虚拟地址，所以说我们上述所观察到地址都没有改变。</strong></p> 
<p>        每个进程都会有进程地址空间，操作系统对这些进程地址空间 先组织在描述的管理。简单来说，进程地址空间是特定的数据结构对象。</p> 
<p><img alt="" height="429" src="https://images2.imgbox.com/68/cd/qD05WNr2_o.png" width="1200"></p> 
<p>        那么进程地址空间中都有哪些属性呢？</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/96/51/TtY606p6_o.png" width="736"></p> 
<p>        根据Linux公布的源代码，task_struct 中有 mm_struct 这样一个结构体，这也是进程控制块中的，上面我们可以看到，有些 “strart” “end”  这样的字符，不难猜出，这是对进程地址空间进行区域划分，在自己的区域内的内存资源都可以被进程使用，避免越界问题。</p> 
<p>        我们的地址空间，不具备对我们的代码和数据的保存能力，不管是代码还是数据都是在物理内存中存放的。进程给我提供了一张表，这张表页表，他映射了虚拟地址和物理地址的关系。进而将进程地址空间上(虚拟/线性)地址转化到物理内存上！</p> 
<p></p> 
<h4>为什么要有进程地址空间和页表呢？</h4> 
<p>        a.将物理内存从无序的状态，映射到也表上变成了有序的状态。</p> 
<p>        b.有了页表将进程管理和内存管理分开，由操作系统决定什么时候开辟内存再将物理地址写入到页表上。从而将进程管理和内存管理进行解耦。</p> 
<p>        c.地址空间加页表是保护内存安全的重要手段，不会让进程随便的访问内存(非法访问是可以通过页表进行拦截的)。</p> 
<p>        注意：cpu上有CR3寄存器，里面存储着页表的物理地址。</p> 
<p>        注意：当我们申请内存的时候，是在进程的虚拟空间中申请的，这时操作系统并没有在物理内存中为我们开辟物理空间(用户还没有尝试写入的情况下)。只有当用户真正的尝试在空间上进行写入的时候，操作系统才会去开辟物理空间并在页表上建立映射关系。这种把开辟虚拟地址和开辟物理地址分开的行为，大大的提高了操作系统的效率，因为用户在开辟空间是并不一定即刻使用，避免了内存出现空转和资源的浪费。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/590563d5bdb16fd4e9a7a630522cf633/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Yolov5 多边形标签转换，所有json文件自动转成txt格式[详细过程]</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/127499ca60537a046a195e2344de5dae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PLSQL存储过程中异常的传递</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>