<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>leetcode 028.实现strStr()，即查找重复字符串（KMP算法） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="leetcode 028.实现strStr()，即查找重复字符串（KMP算法）" />
<meta property="og:description" content="前言 本题是经典的字符串单模匹配的模型，因此可以使用字符串匹配算法解决，常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等，本文 ## 前言
本题是经典的字符串单模匹配的模型，因此可以使用字符串匹配算法解决，常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等，本文将讲解朴素解法（暴力匹配）和KMP算法
因为哈希方法可能出现哈希值相等但是字符串不相等的情况，而 strStr 函数要求匹配结果必定正确，因此本文不介绍哈希方法，有兴趣的读者可以自行了解滚动哈希的实现（如 Rabin-Karp 算法）。
方法一：暴力匹配 思路及算法 我们可以让字符串 needle 与字符串haystack 的所有长度为 mm 的子串均匹配一次。
为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 −1。
代码 class Solution { public int strStr(String haystack, String needle) { int n = haystack.length(), m = needle.length(); for (int i = 0; i &#43; m &lt;= n; i&#43;&#43;) { boolean flag = true; for (int j = 0; j &lt; m; j&#43;&#43;) { if (haystack." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8c41a2a3ae640390eba3877b4c86d585/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-20T17:16:14+08:00" />
<meta property="article:modified_time" content="2021-04-20T17:16:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">leetcode 028.实现strStr()，即查找重复字符串（KMP算法）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>本题是经典的字符串单模匹配的模型，因此可以使用字符串匹配算法解决，常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等，本文 ## 前言</p> 
<p>本题是经典的字符串单模匹配的模型，因此可以使用字符串匹配算法解决，常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等，本文将讲解<strong>朴素解法（暴力匹配）<strong>和</strong>KMP算法</strong></p> 
<p>因为哈希方法可能出现哈希值相等但是字符串不相等的情况，而 strStr 函数要求匹配结果必定正确，因此本文不介绍哈希方法，有兴趣的读者可以自行了解滚动哈希的实现（如 Rabin-Karp 算法）。</p> 
<h3><a id="_12"></a>方法一：暴力匹配</h3> 
<h4><a id="_14"></a>思路及算法</h4> 
<p>我们可以让字符串 needle 与字符串haystack 的所有长度为 mm 的子串均匹配一次。</p> 
<p>为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 −1。</p> 
<h4><a id="_26"></a>代码</h4> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>String haystack<span class="token punctuation">,</span> String needle<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> haystack<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">+</span> m <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">!=</span> needle<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_49"></a>复杂度分析</h4> 
<ul><li>时间复杂度：O(n×m)，其中n 是字符串haystack 的长度，m 是字符串needle 的长度。最坏情况下我们需要将字符串needle 与字符串haystack 的所有长度为 mm 的子串均匹配一次。</li><li>空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</li></ul> 
<h3><a id="KMP__56"></a>KMP 解法</h3> 
<p>讲解转自：三叶姐</p> 
<p>KMP 算法是一个快速查找匹配串的算法，它的作用其实就是本题问题：如何快速在「原字符串」中找到「匹配字符串」。</p> 
<p>上述的朴素解法，不考虑剪枝的话复杂度是 O(m∗n) 的，而 KMP 算法的复杂度为O(m+n)。</p> 
<p>KMP 之所以能够在 O(m+n) 复杂度内完成查找，是因为其能在「非完全匹配」的过程中提取到有效信息进行复用，以减少「重复匹配」的消耗。</p> 
<p>你可能不太理解，没关系，我们可以通过举 🌰 来理解 KMP。</p> 
<h4><a id="1__78"></a>1. 匹配过程</h4> 
<p>在模拟 KMP 匹配过程之前，我们先建立两个概念：</p> 
<p>前缀：对于字符串 abcxxxxefg，我们称 abc 属于 abcxxxxefg 的某个前缀。</p> 
<p>后缀：对于字符串 abcxxxxefg，我们称 efg 属于 abcxxxxefg 的某个后缀。</p> 
<p>然后我们假设原串为 abeababeabf，匹配串为 abeabf：</p> 
<p><img src="https://images2.imgbox.com/ac/23/nSndi6VV_o.png" alt="img"></p> 
<p>我们可以先看看如果不使用 KMP，会如何进行匹配（不使用 substring 函数的情况下）。</p> 
<p>首先在「原串」和「匹配串」分别各自有一个指针指向当前匹配的位置。</p> 
<p>首次匹配的「发起点」是第一个字符 a。显然，后面的 abeab 都是匹配的，两个指针会同时往右移动（黑标）。</p> 
<p>在都能匹配上 abeab 的部分，「朴素匹配」和「KMP」并无不同。</p> 
<p>直到出现第一个不同的位置（红标）：</p> 
<p><img src="https://images2.imgbox.com/3d/3d/WyBevtOF_o.png" alt="img"></p> 
<p>接下来，正是「朴素匹配」和「KMP」出现不同的地方：</p> 
<p>先看下「朴素匹配」逻辑：</p> 
<p>\1. 将原串的指针移动至本次「发起点」的下一个位置（b 字符处）；匹配串的指针移动至起始位置。</p> 
<p>\2. 尝试匹配，发现对不上，原串的指针会一直往后移动，直到能够与匹配串对上位置。</p> 
<p>如图：</p> 
<p><img src="https://images2.imgbox.com/75/3f/4Z46rHIK_o.png" alt="img"></p> 
<p>也就是说，对于「朴素匹配」而言，一旦匹配失败，将会将原串指针调整至下一个「发起点」，匹配串的指针调整至起始位置，然后重新尝试匹配。</p> 
<p>这也就不难理解为什么「朴素匹配」的复杂度是 O(m * n)O(m∗n) 了。</p> 
<p><strong>然后我们再看看「KMP 匹配」过程：</strong></p> 
<p>首先匹配串会检查之前已经匹配成功的部分中里是否存在相同的「前缀」和「后缀」。如果存在，则跳转到「前缀」的下一个位置继续往下匹配：</p> 
<p><img src="https://images2.imgbox.com/39/8d/zQsVU7GX_o.png" alt="img"></p> 
<p>跳转到下一匹配位置后，尝试匹配，发现两个指针的字符对不上，并且此时匹配串指针前面不存在相同的「前缀」和「后缀」，这时候只能回到匹配串的起始位置重新开始：</p> 
<p><img src="https://images2.imgbox.com/a4/6d/x6EX89Zf_o.png" alt="img"></p> 
<p><strong>到这里，你应该清楚 KMP 为什么相比于朴素解法更快：</strong></p> 
<ul><li>因为 KMP 利用已匹配部分中相同的「前缀」和「后缀」来加速下一次的匹配。</li><li>因为 KMP 的原串指针不会进行回溯（没有朴素匹配中回到下一个「发起点」的过程）。</li></ul> 
<p>第一点很直观，也很好理解。</p> 
<p>我们可以把重点放在第二点上，原串不回溯至「发起点」意味着什么？</p> 
<p><strong>其实是意味着：随着匹配过程的进行，原串指针的不断右移，我们本质上是在不断地在否决一些「不可能」的方案。</strong></p> 
<p><strong>当我们的原串指针从 i 位置后移到 j 位置，不仅仅代表着「原串」下标范围为 [i,j)[i,j) 的字符与「匹配串」匹配或者不匹配，更是在否决那些以「原串」下标范围为 [i,j)[i,j) 为「匹配发起点」的子集。</strong></p> 
<h4><a id="2__193"></a>2. 分析实现</h4> 
<p>到这里，就结束了吗？要开始动手实现上述匹配过程了吗？</p> 
<p>我们可以先分析一下复杂度。如果严格按照上述解法的话，最坏情况下我们需要扫描整个原串，复杂度为 O(n)O(n)。同时在每一次匹配失败时，去检查已匹配部分的相同「前缀」和「后缀」，跳转到相应的位置，如果不匹配则再检查前面部分是否有相同「前缀」和「后缀」，再跳转到相应的位置 … 这部分的复杂度是 O(m^2) ，因此整体的复杂度是 O(n * m^2)，而我们的朴素解法是 O(m∗n) 的。</p> 
<p>说明还有一些性质我们没有利用到。</p> 
<p>显然，扫描完整原串操作这一操作是不可避免的，我们可以优化的只能是「检查已匹配部分的相同前缀和后缀」这一过程。</p> 
<p>再进一步，我们检查「前缀」和「后缀」的目的其实是「为了确定匹配串中的下一段开始匹配的位置」。</p> 
<p>同时我们发现，对于匹配串的任意一个位置而言，由该位置发起的下一个匹配点位置其实与原串无关。</p> 
<p>举个 🌰，对于匹配串 abcabd 的字符 d 而言，由它发起的下一个匹配点跳转必然是字符 c 的位置。因为字符 d 位置的相同「前缀」和「后缀」字符 ab 的下一位置就是字符 c。</p> 
<p>可见从匹配串某个位置跳转下一个匹配位置这一过程是与原串无关的，我们将这一过程称为找 next 点。</p> 
<p>显然我们可以预处理出 next 数组，数组中每个位置的值就是该下标应该跳转的目标位置（ next 点）。</p> 
<p>当我们进行了这一步优化之后，复杂度是多少呢？</p> 
<p>预处理 next 数组的复杂度未知，匹配过程最多扫描完整个原串，复杂度为 O(n)O(n)。</p> 
<p>因此如果我们希望整个 KMP 过程是 O(m + n)O(m+n) 的话，那么我们需要在 O(m)O(m) 的复杂度内预处理出 next数组。</p> 
<p><strong>所以我们的重点在于如何在 O(m)O(m) 复杂度内处理处 next 数组。</strong></p> 
<h4><a id="3_next__247"></a>3. next 数组的构建</h4> 
<p>接下来，我们看看<code>next</code>数组是如何在 O(m) 的复杂度内被预处理出来的。</p> 
<p>假设有匹配串<code>aaabbab</code>，我们来看看对应的 next 是如何被构建出来的。</p> 
<p><img src="https://images2.imgbox.com/3d/62/NaOZ3RoX_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/1c/d2/fE3Zm0BH_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/44/c8/K0d4aZyE_o.png" alt="img"></p> 
<p>这就是整个 next 数组的构建过程，时空复杂度均为 O(m)O(m)。</p> 
<p>至此整个 KMP 匹配过程复杂度是 O(m + n)O(m+n) 的。</p> 
<h4><a id="4__273"></a>4. 代码实现</h4> 
<p>在实际编码时，通常我会往原串和匹配串头部追加一个空格（哨兵）。</p> 
<p>目的是让 j 下标从 0 开始，省去 j 从 -1 开始的麻烦。</p> 
<p>整个过程与上述分析完全一致，一些相关的注释我已经写到代码里。</p> 
<p>代码：</p> 
<pre><code>class Solution {
    // KMP 算法
    // ss: 原串(string)  pp: 匹配串(pattern)
    public int strStr(String ss, String pp) {
        if (pp.isEmpty()) return 0;
        
        // 分别读取原串和匹配串的长度
        int n = ss.length(), m = pp.length();
        // 原串和匹配串前面都加空格，使其下标从 1 开始
        ss = " " + ss;
        pp = " " + pp;

        char[] s = ss.toCharArray();
        char[] p = pp.toCharArray();

        // 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）
        int[] next = new int[m + 1];
        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】
        for (int i = 2, j = 0; i &lt;= m; i++) {
            // 匹配不成功的话，j = next(j)
            while (j &gt; 0 &amp;&amp; p[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++
            if (p[i] == p[j + 1]) j++;
            // 更新 next[i]，结束本次循环，i++
            next[i] = j;
        }

        // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】
        for (int i = 1, j = 0; i &lt;= n; i++) {
            // 匹配不成功 j = next(j)
            while (j &gt; 0 &amp;&amp; s[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++，结束本次循环后 i++
            if (s[i] == p[j + 1]) j++;
            // 整一段匹配成功，直接返回下标
            if (j == m) return i - m;
        }

        return -1;
    }
}
</code></pre> 
<h4><a id="5_332"></a>5.复杂度分析</h4> 
<ul><li>时间复杂度：n 为原串的长度，m 为匹配串的长度。复杂度为O(m+n)。</li><li>空间复杂度：构建了 next 数组。复杂度为O(m)。</li></ul> 
<h4><a id="6_337"></a>6.总结</h4> 
<p><strong>KMP 算法的应用范围要比 Manacher 算法广，Manacher 算法只能应用于「回文串」问题，相对比较局限，而「子串匹配」问题还是十分常见的。</strong></p> 
<p><strong>背过这样的算法的意义在于：相当于大脑里有了一个时间复杂度为 O(n) 的 api 可以使用，这个 api 传入一个原串和匹配串，返回匹配串在原串的位置。</strong></p> 
<p>因此，十分建议大家在「理解 KMP」的基础上，对模板进行背过 ~将讲解<strong>朴素解法（暴力匹配）<strong>和</strong>KMP算法</strong></p> 
<p>因为哈希方法可能出现哈希值相等但是字符串不相等的情况，而 strStr 函数要求匹配结果必定正确，因此本文不介绍哈希方法，有兴趣的读者可以自行了解滚动哈希的实现（如 Rabin-Karp 算法）。</p> 
<h3><a id="_355"></a>方法一：暴力匹配</h3> 
<h4><a id="_357"></a>思路及算法</h4> 
<p>我们可以让字符串 needle 与字符串haystack 的所有长度为 mm 的子串均匹配一次。</p> 
<p>为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 −1。</p> 
<h4><a id="_369"></a>代码</h4> 
<pre><code>class Solution {
    public int strStr(String haystack, String needle) {
        int n = haystack.length(), m = needle.length();
        for (int i = 0; i + m &lt;= n; i++) {
            boolean flag = true;
            for (int j = 0; j &lt; m; j++) {
                if (haystack.charAt(i + j) != needle.charAt(j)) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                return i;
            }
        }
        return -1;
    }
}
</code></pre> 
<h4><a id="_392"></a>复杂度分析</h4> 
<ul><li>时间复杂度：O(n×m)，其中n 是字符串haystack 的长度，m 是字符串needle 的长度。最坏情况下我们需要将字符串needle 与字符串haystack 的所有长度为 mm 的子串均匹配一次。</li><li>空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</li></ul> 
<h3><a id="KMP__399"></a>KMP 解法</h3> 
<p>讲解转自：三叶姐</p> 
<p>KMP 算法是一个快速查找匹配串的算法，它的作用其实就是本题问题：如何快速在「原字符串」中找到「匹配字符串」。</p> 
<p>上述的朴素解法，不考虑剪枝的话复杂度是 O(m∗n) 的，而 KMP 算法的复杂度为O(m+n)。</p> 
<p>KMP 之所以能够在 O(m+n) 复杂度内完成查找，是因为其能在「非完全匹配」的过程中提取到有效信息进行复用，以减少「重复匹配」的消耗。</p> 
<p>你可能不太理解，没关系，我们可以通过举 🌰 来理解 KMP。</p> 
<h4><a id="1__421"></a>1. 匹配过程</h4> 
<p>在模拟 KMP 匹配过程之前，我们先建立两个概念：</p> 
<p>前缀：对于字符串 abcxxxxefg，我们称 abc 属于 abcxxxxefg 的某个前缀。</p> 
<p>后缀：对于字符串 abcxxxxefg，我们称 efg 属于 abcxxxxefg 的某个后缀。</p> 
<p>然后我们假设原串为 abeababeabf，匹配串为 abeabf：</p> 
<p><img src="https://images2.imgbox.com/cf/a8/lCxOle1G_o.png" alt="img"></p> 
<p>我们可以先看看如果不使用 KMP，会如何进行匹配（不使用 substring 函数的情况下）。</p> 
<p>首先在「原串」和「匹配串」分别各自有一个指针指向当前匹配的位置。</p> 
<p>首次匹配的「发起点」是第一个字符 a。显然，后面的 abeab 都是匹配的，两个指针会同时往右移动（黑标）。</p> 
<p>在都能匹配上 abeab 的部分，「朴素匹配」和「KMP」并无不同。</p> 
<p>直到出现第一个不同的位置（红标）：</p> 
<p><img src="https://images2.imgbox.com/a6/db/BLw0ZjYR_o.png" alt="img"></p> 
<p>接下来，正是「朴素匹配」和「KMP」出现不同的地方：</p> 
<p>先看下「朴素匹配」逻辑：</p> 
<p>\1. 将原串的指针移动至本次「发起点」的下一个位置（b 字符处）；匹配串的指针移动至起始位置。</p> 
<p>\2. 尝试匹配，发现对不上，原串的指针会一直往后移动，直到能够与匹配串对上位置。</p> 
<p>如图：</p> 
<p><img src="https://images2.imgbox.com/af/4c/AlWIKZ5i_o.png" alt="img"></p> 
<p>也就是说，对于「朴素匹配」而言，一旦匹配失败，将会将原串指针调整至下一个「发起点」，匹配串的指针调整至起始位置，然后重新尝试匹配。</p> 
<p>这也就不难理解为什么「朴素匹配」的复杂度是 O(m * n)O(m∗n) 了。</p> 
<p><strong>然后我们再看看「KMP 匹配」过程：</strong></p> 
<p>首先匹配串会检查之前已经匹配成功的部分中里是否存在相同的「前缀」和「后缀」。如果存在，则跳转到「前缀」的下一个位置继续往下匹配：</p> 
<p><img src="https://images2.imgbox.com/9a/a7/LseQca8p_o.png" alt="img"></p> 
<p>跳转到下一匹配位置后，尝试匹配，发现两个指针的字符对不上，并且此时匹配串指针前面不存在相同的「前缀」和「后缀」，这时候只能回到匹配串的起始位置重新开始：</p> 
<p><img src="https://images2.imgbox.com/97/d6/odlr7jjy_o.png" alt="img"></p> 
<p><strong>到这里，你应该清楚 KMP 为什么相比于朴素解法更快：</strong></p> 
<ul><li>因为 KMP 利用已匹配部分中相同的「前缀」和「后缀」来加速下一次的匹配。</li><li>因为 KMP 的原串指针不会进行回溯（没有朴素匹配中回到下一个「发起点」的过程）。</li></ul> 
<p>第一点很直观，也很好理解。</p> 
<p>我们可以把重点放在第二点上，原串不回溯至「发起点」意味着什么？</p> 
<p><strong>其实是意味着：随着匹配过程的进行，原串指针的不断右移，我们本质上是在不断地在否决一些「不可能」的方案。</strong></p> 
<p><strong>当我们的原串指针从 i 位置后移到 j 位置，不仅仅代表着「原串」下标范围为 [i,j)[i,j) 的字符与「匹配串」匹配或者不匹配，更是在否决那些以「原串」下标范围为 [i,j)[i,j) 为「匹配发起点」的子集。</strong></p> 
<h4><a id="2__536"></a>2. 分析实现</h4> 
<p>到这里，就结束了吗？要开始动手实现上述匹配过程了吗？</p> 
<p>我们可以先分析一下复杂度。如果严格按照上述解法的话，最坏情况下我们需要扫描整个原串，复杂度为 O(n)O(n)。同时在每一次匹配失败时，去检查已匹配部分的相同「前缀」和「后缀」，跳转到相应的位置，如果不匹配则再检查前面部分是否有相同「前缀」和「后缀」，再跳转到相应的位置 … 这部分的复杂度是 O(m^2) ，因此整体的复杂度是 O(n * m^2)，而我们的朴素解法是 O(m∗n) 的。</p> 
<p>说明还有一些性质我们没有利用到。</p> 
<p>显然，扫描完整原串操作这一操作是不可避免的，我们可以优化的只能是「检查已匹配部分的相同前缀和后缀」这一过程。</p> 
<p>再进一步，我们检查「前缀」和「后缀」的目的其实是「为了确定匹配串中的下一段开始匹配的位置」。</p> 
<p>同时我们发现，对于匹配串的任意一个位置而言，由该位置发起的下一个匹配点位置其实与原串无关。</p> 
<p>举个 🌰，对于匹配串 abcabd 的字符 d 而言，由它发起的下一个匹配点跳转必然是字符 c 的位置。因为字符 d 位置的相同「前缀」和「后缀」字符 ab 的下一位置就是字符 c。</p> 
<p>可见从匹配串某个位置跳转下一个匹配位置这一过程是与原串无关的，我们将这一过程称为找 next 点。</p> 
<p>显然我们可以预处理出 next 数组，数组中每个位置的值就是该下标应该跳转的目标位置（ next 点）。</p> 
<p>当我们进行了这一步优化之后，复杂度是多少呢？</p> 
<p>预处理 next 数组的复杂度未知，匹配过程最多扫描完整个原串，复杂度为 O(n)O(n)。</p> 
<p>因此如果我们希望整个 KMP 过程是 O(m + n)O(m+n) 的话，那么我们需要在 O(m)O(m) 的复杂度内预处理出 next数组。</p> 
<p><strong>所以我们的重点在于如何在 O(m)O(m) 复杂度内处理处 next 数组。</strong></p> 
<h4><a id="3_next__590"></a>3. next 数组的构建</h4> 
<p>接下来，我们看看<code>next</code>数组是如何在 O(m) 的复杂度内被预处理出来的。</p> 
<p>假设有匹配串<code>aaabbab</code>，我们来看看对应的 next 是如何被构建出来的。</p> 
<p><img src="https://images2.imgbox.com/60/d7/GZFikIfY_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/5d/fb/wWDutnqO_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/5a/81/F5gmoYZZ_o.png" alt="img"></p> 
<p>这就是整个 next 数组的构建过程，时空复杂度均为 O(m)O(m)。</p> 
<p>至此整个 KMP 匹配过程复杂度是 O(m + n)O(m+n) 的。</p> 
<h4><a id="4__616"></a>4. 代码实现</h4> 
<p>在实际编码时，通常我会往原串和匹配串头部追加一个空格（哨兵）。</p> 
<p>目的是让 j 下标从 0 开始，省去 j 从 -1 开始的麻烦。</p> 
<p>整个过程与上述分析完全一致，一些相关的注释我已经写到代码里。</p> 
<p>代码：</p> 
<pre><code>class Solution {
    // KMP 算法
    // ss: 原串(string)  pp: 匹配串(pattern)
    public int strStr(String ss, String pp) {
        if (pp.isEmpty()) return 0;
        
        // 分别读取原串和匹配串的长度
        int n = ss.length(), m = pp.length();
        // 原串和匹配串前面都加空格，使其下标从 1 开始
        ss = " " + ss;
        pp = " " + pp;

        char[] s = ss.toCharArray();
        char[] p = pp.toCharArray();

        // 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）
        int[] next = new int[m + 1];
        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】
        for (int i = 2, j = 0; i &lt;= m; i++) {
            // 匹配不成功的话，j = next(j)
            while (j &gt; 0 &amp;&amp; p[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++
            if (p[i] == p[j + 1]) j++;
            // 更新 next[i]，结束本次循环，i++
            next[i] = j;
        }

        // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】
        for (int i = 1, j = 0; i &lt;= n; i++) {
            // 匹配不成功 j = next(j)
            while (j &gt; 0 &amp;&amp; s[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++，结束本次循环后 i++
            if (s[i] == p[j + 1]) j++;
            // 整一段匹配成功，直接返回下标
            if (j == m) return i - m;
        }

        return -1;
    }
}
</code></pre> 
<h4><a id="5_675"></a>5.复杂度分析</h4> 
<ul><li>时间复杂度：n 为原串的长度，m 为匹配串的长度。复杂度为O(m+n)。</li><li>空间复杂度：构建了 next 数组。复杂度为O(m)。</li></ul> 
<h4><a id="6_680"></a>6.总结</h4> 
<p><strong>KMP 算法的应用范围要比 Manacher 算法广，Manacher 算法只能应用于「回文串」问题，相对比较局限，而「子串匹配」问题还是十分常见的。</strong></p> 
<p><strong>背过这样的算法的意义在于：相当于大脑里有了一个时间复杂度为 O(n) 的 api 可以使用，这个 api 传入一个原串和匹配串，返回匹配串在原串的位置。</strong></p> 
<p>因此，十分建议大家在「理解 KMP」的基础上，对模板进行背过 ~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/175e92f0e61743856974dc5b7f3be3ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GB9706.1-2007名词解释：电压</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91c0b730b8a242d4a78a8f2ed577c054/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Metaspace内存溢出排查思路、定位、工具与解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>