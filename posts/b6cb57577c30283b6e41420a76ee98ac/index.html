<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ROS pluginlib步骤 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ROS pluginlib步骤" />
<meta property="og:description" content="1.创建插件
一般情况是有基类的，以move_base导航栈为例。其nav_core包下有几个头文件，这就是基类所在，其具体实现由继承类完成，基类的构造函数是protected
2.新建软件包
catkin_create_pkg package_name roscpp 基类包名 ......
3.
继承类头文件要包含 基类
#include &lt;基类包名/基类头文件名.h&gt; 这里是因为头文件在/include/包名/头文件名。如果就在include文件夹里 不用包名就可以了
.cpp文件要包含一个头文件 #include &lt;pluginlib/class_list_macros.h&gt;
在继承类的.cpp文件中，在头文件之后要写一个宏PLUGINLIB_EXPORT_CLASS，目的是可以到出插件类
PLUGINLIB_EXPORT_CLASS(继承类空间名::继承类名, 基类空间名::基类名)
4.CMakeLists.txt
这里是生成一个插件，是一个库，所以要加入
add_library(想要插件名 src/插件.cpp 插件.cpp ....)
5.为继承类创建一个插件.xml 与CMakeLists.txt一个目录下
例如
&lt;library path=&#34;lib/libpolygon_plugins&#34;&gt;
&lt;class name=&#34;polygon_plugins/Regular_Triangle&#34; type=&#34;polygon_plugins::Triangle&#34; base_class_type=&#34;polygon_base::RegularPolygon&#34;&gt;
&lt;description&gt;This is a triangle plugin.&lt;/description&gt;
&lt;/class&gt;
&lt;class name=&#34;polygon_plugins/Regular_Square&#34; type=&#34;polygon_plugins::Square&#34; base_class_type=&#34;polygon_base::RegularPolygon&#34;&gt;
&lt;description&gt;This is a square plugin.&lt;/description&gt;
&lt;/class&gt;
&lt;/library&gt;
//两个插件名的例子
&lt;library path=&#34;lib/lib插件名&#34;&gt;
&lt;class name=&#34;继承类空间/自定义插件名&#34; type=&#34;继承类空间::继承类名&#34; base_class_type=&#34;基类空间::基类名&#34;&gt;
&lt;description&gt;This is a triangle plugin.&lt;/description&gt;
&lt;/class&gt;
&lt;class name=&#34;polygon_plugins/Regular_Square&#34; type=&#34;polygon_plugins::Square&#34; base_class_type=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b6cb57577c30283b6e41420a76ee98ac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-10T23:24:57+08:00" />
<meta property="article:modified_time" content="2021-07-10T23:24:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ROS pluginlib步骤</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.创建插件<br> 一般情况是有基类的，以move_base导航栈为例。其nav_core包下有几个头文件，这就是基类所在，其具体实现由继承类完成，基类的构造函数是protected</p> 
<p>2.新建软件包<br> catkin_create_pkg  package_name roscpp  基类包名 ......</p> 
<p>3.<br> 继承类头文件要包含 基类<br> #include &lt;基类包名/基类头文件名.h&gt; 这里是因为头文件在/include/包名/头文件名。如果就在include文件夹里 不用包名就可以了</p> 
<p>.cpp文件要包含一个头文件 #include &lt;pluginlib/class_list_macros.h&gt;</p> 
<p>在继承类的.cpp文件中，在头文件之后要写一个宏PLUGINLIB_EXPORT_CLASS，目的是可以到出插件类<br> PLUGINLIB_EXPORT_CLASS(继承类空间名::继承类名, 基类空间名::基类名)</p> 
<p><br> 4.CMakeLists.txt<br> 这里是生成一个插件，是一个库，所以要加入<br> add_library(想要插件名 src/插件.cpp 插件.cpp ....)</p> 
<p>5.为继承类创建一个插件.xml 与CMakeLists.txt一个目录下<br> 例如<br> &lt;library path="lib/libpolygon_plugins"&gt;<br>   &lt;class name="polygon_plugins/Regular_Triangle" type="polygon_plugins::Triangle" base_class_type="polygon_base::RegularPolygon"&gt;<br>     &lt;description&gt;This is a triangle plugin.&lt;/description&gt;<br>   &lt;/class&gt;<br>   &lt;class name="polygon_plugins/Regular_Square" type="polygon_plugins::Square" base_class_type="polygon_base::RegularPolygon"&gt;<br>     &lt;description&gt;This is a square plugin.&lt;/description&gt;<br>   &lt;/class&gt;<br> &lt;/library&gt;</p> 
<p><br> //两个插件名的例子<br> &lt;library path="lib/lib插件名"&gt;<br>   &lt;class name="继承类空间/自定义插件名" type="继承类空间::继承类名" base_class_type="基类空间::基类名"&gt;<br>     &lt;description&gt;This is a triangle plugin.&lt;/description&gt;<br>   &lt;/class&gt;<br>   &lt;class name="polygon_plugins/Regular_Square" type="polygon_plugins::Square" base_class_type="polygon_base::RegularPolygon"&gt;<br>     &lt;description&gt;This is a square plugin.&lt;/description&gt;<br>   &lt;/class&gt;<br> &lt;/library&gt;</p> 
<p><br> 5.package.xml 的最后加入一行</p> 
<p>&lt;export&gt;<br>     &lt;!-- Other tools can request additional information be placed here --&gt;<br>     &lt;pluginlib_tutorials_ plugin="${prefix}/polygon_plugins.xml" /&gt;<br> &lt;/export&gt;</p> 
<p><br>   &lt;基类软件包名 plugin="${prefix}/上面4里的 插件名.xml" /&gt;<br> &lt;export&gt;不用加本来就有的；</p> 
<p><br> 6.验证</p> 
<p>终端下<br> rospack plugins --attrib=plugin 基类软件包名</p> 
<p>rospack plugins --attrib=plugin nav_core<br> 输出如下：<br> clear_costmap_recovery /opt/ros/noetic/share/clear_costmap_recovery/ccr_plugin.xml<br> global_planner /opt/ros/noetic/share/global_planner/bgp_plugin.xml<br> base_local_planner /opt/ros/noetic/share/base_local_planner/blp_plugin.xml<br> navfn /opt/ros/noetic/share/navfn/bgp_plugin.xml<br> rotate_recovery /opt/ros/noetic/share/rotate_recovery/rotate_plugin.xml<br> dwa_local_planner /opt/ros/noetic/share/dwa_local_planner/blp_plugin.xml</p> 
<p></p> 
<p></p> 
<p><br> 调用插件类的用法：<br> 包含头文件   #include &lt;pluginlib/class_loader.h&gt;   还有基类的头文件 等等<br> 1.先新建基类的插件对象<br> pluginlib::ClassLoader&lt;polygon_base::RegularPolygon&gt; poly_loader("pluginlib_tutorials_", "polygon_base::RegularPolygon");<br>  <br> 2.基类对象调用createInstance创建继承类实例<br> boost::shared_ptr&lt;polygon_base::RegularPolygon&gt; triangle = poly_loader.createInstance("polygon_plugins::Triangle");</p> 
<p>3.继承类的实例有了，就可以调用继承类里的函数了</p> 
<p>pluginlib::ClassLoader&lt;基类所在空间名：：基类名&gt;poly_loader("基类所在软件包名"，“基类所在空间::基类名”)</p> 
<p>boost::shared_ptr&lt;基类所在空间::基类名&gt;triangle = poly_loader.createInstance("继承类所在空间名::继承类名")</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd38c8d3abd1002211b4a06c778de73a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">6.830 / 6.814: Syllabus 2021 - MIT Lab 1 - SimpleDB</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f11470879b00b52bb127489414e660f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机软件自启动设置,设置开机启动项,详细教您电脑如何设置开机启动项</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>