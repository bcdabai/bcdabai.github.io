<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（六）UVC基本框架代码分析 --转 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（六）UVC基本框架代码分析 --转" />
<meta property="og:description" content="（六）UVC基本框架代码分析 --转
转载地址：https://www.cnblogs.com/blogs-of-lxl/p/5118384.html
仿照内核的自带UVC（usb video class）驱动程序写的一版简化驱动，仅供学习，实际项目开发中应该尽量使用内核自带的驱动，除非内核自带的驱动不支持此款硬件才需要自己写驱动。
下面就直接上代码了，要根据自己的设备信息修改相关配置参数。
#include &lt;linux/kernel.h&gt;
#include &lt;linux/list.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/usb.h&gt;
#include &lt;linux/videodev2.h&gt;
#include &lt;linux/vmalloc.h&gt;
#include &lt;linux/wait.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;asm/atomic.h&gt;
#include &lt;asm/unaligned.h&gt;
#include &lt;media/v4l2-common.h&gt;
#include &lt;media/v4l2-ioctl.h&gt;
#include &lt;media/videobuf-core.h&gt;
#include “uvcvideo.h”
#define sheldon_UVC_URBS 3
/* Values for bmHeaderInfo (Video and Still Image Payload Headers, 2.4.3.3) */
#define UVC_STREAM_EOH (1 &lt;&lt; 7)
#define UVC_STREAM_ERR (1 &lt;&lt; 6)
#define UVC_STREAM_STI (1 &lt;&lt; 5)
#define UVC_STREAM_RES (1 &lt;&lt; 4)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9f988ce689b3e2c0b6a776ed47e4ff3c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-15T17:04:05+08:00" />
<meta property="article:modified_time" content="2020-12-15T17:04:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（六）UVC基本框架代码分析 --转</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>（六）UVC基本框架代码分析 --转<br> 转载地址：https://www.cnblogs.com/blogs-of-lxl/p/5118384.html</p> 
<p>仿照内核的自带UVC（usb video class）驱动程序写的一版简化驱动，仅供学习，实际项目开发中应该尽量使用内核自带的驱动，除非内核自带的驱动不支持此款硬件才需要自己写驱动。</p> 
<p>下面就直接上代码了，要根据自己的设备信息修改相关配置参数。<br> #include &lt;linux/kernel.h&gt;<br> #include &lt;linux/list.h&gt;<br> #include &lt;linux/module.h&gt;<br> #include &lt;linux/usb.h&gt;<br> #include &lt;linux/videodev2.h&gt;<br> #include &lt;linux/vmalloc.h&gt;<br> #include &lt;linux/wait.h&gt;<br> #include &lt;linux/mm.h&gt;<br> #include &lt;asm/atomic.h&gt;<br> #include &lt;asm/unaligned.h&gt;</p> 
<p>#include &lt;media/v4l2-common.h&gt;<br> #include &lt;media/v4l2-ioctl.h&gt;<br> #include &lt;media/videobuf-core.h&gt;</p> 
<p>#include “uvcvideo.h”</p> 
<p>#define sheldon_UVC_URBS 3</p> 
<p>/* Values for bmHeaderInfo (Video and Still Image Payload Headers, 2.4.3.3) */<br> #define UVC_STREAM_EOH (1 &lt;&lt; 7)<br> #define UVC_STREAM_ERR (1 &lt;&lt; 6)<br> #define UVC_STREAM_STI (1 &lt;&lt; 5)<br> #define UVC_STREAM_RES (1 &lt;&lt; 4)<br> #define UVC_STREAM_SCR (1 &lt;&lt; 3)<br> #define UVC_STREAM_PTS (1 &lt;&lt; 2)<br> #define UVC_STREAM_EOF (1 &lt;&lt; 1)<br> #define UVC_STREAM_FID (1 &lt;&lt; 0)</p> 
<p>struct sheldon_uvc_streaming_control {<!-- --><br> __u16 bmHint;<br> __u8 bFormatIndex;<br> __u8 bFrameIndex;<br> __u32 dwFrameInterval;<br> __u16 wKeyFrameRate;<br> __u16 wPFrameRate;<br> __u16 wCompQuality;<br> __u16 wCompWindowSize;<br> __u16 wDelay;<br> __u32 dwMaxVideoFrameSize;<br> __u32 dwMaxPayloadTransferSize;<br> __u32 dwClockFrequency;<br> __u8 bmFramingInfo;<br> __u8 bPreferedVersion;<br> __u8 bMinVersion;<br> __u8 bMaxVersion;<br> };</p> 
<p>/<em>参考 drivers/media/video/uvc 下一系列代码</em>/</p> 
<p>struct frame_desc {<!-- --><br> int width;<br> int height;<br> };</p> 
<p>/* 参考uvc_video_queue定义一些结构体 <em>/<br> struct sheldon_uvc_buffer {<!-- --><br> struct v4l2_buffer buf;<br> int state;<br> int vma_use_count; /</em> 表示是否已经被mmap <em>/<br> wait_queue_head_t wait; /</em> APP要读某个缓冲区,如果无数据,在此休眠 */<br> struct list_head stream;<br> struct list_head irq;<br> };</p> 
<p>struct sheldon_uvc_queue {<!-- --><br> void *mem;<br> int count;<br> int buf_size;<br> struct sheldon_uvc_buffer buffer[32];</p> 
<pre><code>struct urb *urb[32];
char *urb_buffer[32];
dma_addr_t urb_dma[32];
unsigned int urb_size;

struct list_head mainqueue;   /* 供APP消费用 */
struct list_head irqqueue;    /* 供底层驱动生产用 */
</code></pre> 
<p>};</p> 
<p>static struct sheldon_uvc_queue sheldon_uvc_queue;</p> 
<p>static struct video_device *sheldon_uvc_vdev;<br> static struct usb_device <em>sheldon_uvc_udev;<br> static int sheldon_uvc_bEndpointAddress = 0x82; //lsusb - 人工确定参数<br> static int sheldon_uvc_streaming_intf;<br> static int sheldon_uvc_control_intf;<br> static int sheldon_uvc_streaming_bAlternateSetting = 1;<br> static struct v4l2_format sheldon_uvc_format;<br> static struct frame_desc framdesc[] = {<!-- -->{640,480},{320,240},{160,120}};//{<!-- -->{640, 480}, {352, 288}, {320, 240}, {176, 144}, {160, 120}};<br> static int frame_idx = 1;<br> static int bBitsPerPixel = 16; /</em> lsusb -v -d 0x1e4e: “bBitsPerPixel” <em>/<br> static int uvc_version = 0x0100; /</em> lsusb -v -d 0x1e4e: bcdUVC */<br> static int wMaxPacketSize = 128;<br> static int ProcessingUnitID = 5;</p> 
<p>static struct sheldon_uvc_streaming_control sheldon_uvc_params;</p> 
<p>/* A2 参考 uvc_v4l2_do_ioctl */</p> 
<p>/* sheldonUV_vidioc_querycap :用于判断是否为视频设备*/<br> static int sheldonUV_vidioc_querycap(struct file *file, void *priv,<br> struct v4l2_capability *cap)<br> {<!-- --><br> //strcpy(cap-&gt;driver, “sheldonUV”);<br> //strcpy(cap-&gt;card, “sheldonUV”);<br> //cap-&gt;version = 0x0001;<br> //cap-&gt;capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;</p> 
<pre><code>    memset(cap, 0, sizeof *cap);
    strcpy(cap-&gt;driver, "sheldonUV");
    strcpy(cap-&gt;card, "sheldonUV");

    cap-&gt;version = 1;
    cap-&gt;capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;

     return 0;
</code></pre> 
<p>}</p> 
<p>/* A3 列举支持哪种格式</p> 
<ul><li> <p>参考: uvc_fmts 数组<br> */<br> static int sheldonUV_vidioc_enum_fmt_vid_cap(struct file *file, void *priv,<br> struct v4l2_fmtdesc <em>f)<br> {<!-- --><br> /</em> 人工查看描述符可知我们用的摄像头只支持1种格式 */<br> if (f-&gt;index &gt;= 1)<br> return -EINVAL;</p> <p>/* 支持什么格式呢?</p> 
  <ul><li>查看VideoStreaming Interface的描述符,</li><li> <pre><code>       'Y''U''Y''V'
</code></pre> </li><li>得到GUID为"59 55 59 32 00 00 10 00 80 00 00 aa 00 38 9b 71"<br> */<br> strcpy(f-&gt;description, “4:2:2, packed, YUYV”);<br> f-&gt;pixelformat = V4L2_PIX_FMT_YUYV;</li></ul> <p>return 0;<br> }</p> </li></ul> 
<p>/* A4 返回当前所使用的格式 */<br> static int sheldonUV_vidioc_get_fmt_vid_cap(struct file *file, void *priv,<br> struct v4l2_format *f)<br> {<!-- --><br> memcpy(f, &amp;sheldon_uvc_format, sizeof(sheldon_uvc_format));<br> return (0);<br> }</p> 
<p>/* A5 测试驱动程序是否支持某种格式 ，强制设置为第一种格式</p> 
<ul><li>参考: uvc_v4l2_try_format</li><li> <pre><code>  sheldon_vivi_vidioc_try_fmt_vid_cap
</code></pre> </li></ul> 
<p>*/</p> 
<p>static int sheldonUV_vidioc_try_fmt_vid_cap(struct file *file, void *priv,<br> struct v4l2_format *f)<br> {<!-- --><br> if (f-&gt;type != V4L2_BUF_TYPE_VIDEO_CAPTURE)<br> {<!-- --><br> return -EINVAL;<br> }</p> 
<pre><code>if (f-&gt;fmt.pix.pixelformat != V4L2_PIX_FMT_YUYV)
    return -EINVAL;

/* 调整format的width, height,
 * 计算bytesperline, sizeimage
 */

/* 人工查看描述符, 确定支持哪几种分辨率 */
f-&gt;fmt.pix.width  = framdesc[frame_idx].width;
f-&gt;fmt.pix.height = framdesc[frame_idx].height;
f-&gt;fmt.pix.bytesperline =
    (f-&gt;fmt.pix.width * bBitsPerPixel) &gt;&gt; 3;
f-&gt;fmt.pix.sizeimage =
    f-&gt;fmt.pix.height * f-&gt;fmt.pix.bytesperline;


return 0;
</code></pre> 
<p>}</p> 
<p>/* A6 如果支持这种格式,则进行设置-参考 vivi_vidioc_s_fmt_vid_cap*/<br> static int sheldonUV_vidioc_set_fmt_vid_cap(struct file *file, void *priv,<br> struct v4l2_format *f)<br> {<!-- --><br> int ret = sheldonUV_vidioc_try_fmt_vid_cap(file, NULL, f);<br> if (ret &lt; 0)<br> return ret;</p> 
<pre><code>memcpy(&amp;sheldon_uvc_format, f, sizeof(sheldon_uvc_format));
</code></pre> 
<p>return 0;// ret;<br> }</p> 
<p>static int sheldon_uvc_free_buffers(void)<br> {<!-- --><br> if (sheldon_uvc_queue.mem)<br> {<!-- --><br> vfree(sheldon_uvc_queue.mem);<br> memset(&amp;sheldon_uvc_queue, 0, sizeof(sheldon_uvc_queue));<br> sheldon_uvc_queue.mem = NULL;<br> }<br> return 0;<br> }</p> 
<p>/* A7 APP 调用该ioctl让驱动程分配若干个缓存，APP将从这些缓存中读到视频数据</p> 
<ul><li> <p>参考: uvc_alloc_buffers<br> */<br> static int sheldonUV_vidioc_reqbufs(struct file *file, void *priv,<br> struct v4l2_requestbuffers *p)<br> {<!-- --><br> int nbuffers = p-&gt;count;<br> int bufsize = PAGE_ALIGN(sheldon_uvc_format.fmt.pix.sizeimage);<br> unsigned int i;<br> void *mem = NULL;<br> int ret;</p> <pre><code>  if ((ret = sheldon_uvc_free_buffers()) &lt; 0)
      goto done;

  /* Bail out if no buffers should be allocated. */
  if (nbuffers == 0)
      goto done;

  /* Decrement the number of buffers until allocation succeeds. */
  for (; nbuffers &gt; 0; --nbuffers) {
      mem = vmalloc_32(nbuffers * bufsize);
      if (mem != NULL)
          break;
  }

  if (mem == NULL) {
      ret = -ENOMEM;
      goto done;
  }

  /* 这些缓存是一次性作为一个整体来分配的 */
  memset(&amp;sheldon_uvc_queue, 0, sizeof(sheldon_uvc_queue));

  INIT_LIST_HEAD(&amp;sheldon_uvc_queue.mainqueue);
  INIT_LIST_HEAD(&amp;sheldon_uvc_queue.irqqueue);

  for (i = 0; i &lt; nbuffers; ++i) {
      sheldon_uvc_queue.buffer[i].buf.index = i;
      sheldon_uvc_queue.buffer[i].buf.m.offset = i * bufsize;
      sheldon_uvc_queue.buffer[i].buf.length = sheldon_uvc_format.fmt.pix.sizeimage;
      sheldon_uvc_queue.buffer[i].buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
      sheldon_uvc_queue.buffer[i].buf.sequence = 0;
      sheldon_uvc_queue.buffer[i].buf.field = V4L2_FIELD_NONE;
      sheldon_uvc_queue.buffer[i].buf.memory = V4L2_MEMORY_MMAP;
      sheldon_uvc_queue.buffer[i].buf.flags = 0;
      sheldon_uvc_queue.buffer[i].state    = VIDEOBUF_IDLE; //分配好后为空闲状态
      init_waitqueue_head(&amp;sheldon_uvc_queue.buffer[i].wait);
  }

  sheldon_uvc_queue.mem = mem;
  sheldon_uvc_queue.count = nbuffers;
  sheldon_uvc_queue.buf_size = bufsize;
  ret = nbuffers;
</code></pre> <p>done:<br> return ret;<br> }</p> </li></ul> 
<p>/<em>A8 查询buffer状态，获得偏移值,app可以调用mmap</em>/<br> static int sheldonUV_vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *v4l2_buf)<br> {<!-- --><br> int ret = 0;</p> 
<pre><code>if (v4l2_buf-&gt;index &gt;= sheldon_uvc_queue.count) {
    ret = -EINVAL;
    goto done;
}

memcpy(v4l2_buf, &amp;sheldon_uvc_queue.buffer[v4l2_buf-&gt;index].buf, sizeof(*v4l2_buf));

/* 更新flags */
if (sheldon_uvc_queue.buffer[v4l2_buf-&gt;index].vma_use_count)
    v4l2_buf-&gt;flags |= V4L2_BUF_FLAG_MAPPED;


switch (sheldon_uvc_queue.buffer[v4l2_buf-&gt;index].state) {
    case VIDEOBUF_ERROR:
    case VIDEOBUF_DONE:
        v4l2_buf-&gt;flags |= V4L2_BUF_FLAG_DONE;
        break;
    case VIDEOBUF_QUEUED:
    case VIDEOBUF_ACTIVE:
        v4l2_buf-&gt;flags |= V4L2_BUF_FLAG_QUEUED;
        break;
    case VIDEOBUF_IDLE:
    default:
        break;
}
</code></pre> 
<p>done:<br> return ret;<br> }</p> 
<p>/* A10 把缓冲区放入队列, 底层的硬件操作函数将会把数据放入这个队列的缓存</p> 
<ul><li> <p>参考: uvc_queue_buffer<br> */<br> static int sheldonUV_vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *v4l2_buf)<br> {<!-- --><br> struct sheldon_uvc_buffer *buf;</p> <pre><code> /* 0. APP传入的v4l2_buf可能有问题, 要做判断 */

 if (v4l2_buf-&gt;type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
     v4l2_buf-&gt;memory != V4L2_MEMORY_MMAP) {
     return -EINVAL;
 }

 if (v4l2_buf-&gt;index &gt;= sheldon_uvc_queue.count) {
     return -EINVAL;
 }

 buf = &amp;sheldon_uvc_queue.buffer[v4l2_buf-&gt;index];

 if (buf-&gt;state != VIDEOBUF_IDLE) {
     return -EINVAL;
 }


 /* 1. 修改状态 */
 buf-&gt;state = VIDEOBUF_QUEUED;
 buf-&gt;buf.bytesused = 0;

 /* 2. 放入2个队列 */
 /* 队列1: 供APP使用
  * 当缓冲区没有数据时,放入mainqueue队列
  * 当缓冲区有数据时, APP从mainqueue队列中取出
  */
 list_add_tail(&amp;buf-&gt;stream, &amp;sheldon_uvc_queue.mainqueue);

 /* 队列2: 供产生数据的函数使用
  * 当采集到数据时,从irqqueue队列中取出第1个缓冲区,存入数据
  */
 list_add_tail(&amp;buf-&gt;irq, &amp;sheldon_uvc_queue.irqqueue);

 return 0;
</code></pre> </li></ul> 
<p>}</p> 
<p>static void sheldon_uvc_print_streaming_params(struct sheldon_uvc_streaming_control *ctrl)<br> {<!-- --><br> printk(“video params:\n”);<br> printk(“bmHint = %d\n”, ctrl-&gt;bmHint);<br> printk(“bFormatIndex = %d\n”, ctrl-&gt;bFormatIndex);<br> printk(“bFrameIndex = %d\n”, ctrl-&gt;bFrameIndex);<br> printk(“dwFrameInterval = %d\n”, ctrl-&gt;dwFrameInterval);<br> printk(“wKeyFrameRate = %d\n”, ctrl-&gt;wKeyFrameRate);<br> printk(“wPFrameRate = %d\n”, ctrl-&gt;wPFrameRate);<br> printk(“wCompQuality = %d\n”, ctrl-&gt;wCompQuality);<br> printk(“wCompWindowSize = %d\n”, ctrl-&gt;wCompWindowSize);<br> printk(“wDelay = %d\n”, ctrl-&gt;wDelay);<br> printk(“dwMaxVideoFrameSize = %d\n”, ctrl-&gt;dwMaxVideoFrameSize);<br> printk(“dwMaxPayloadTransferSize = %d\n”, ctrl-&gt;dwMaxPayloadTransferSize);<br> printk(“dwClockFrequency = %d\n”, ctrl-&gt;dwClockFrequency);<br> printk(“bmFramingInfo = %d\n”, ctrl-&gt;bmFramingInfo);<br> printk(“bPreferedVersion = %d\n”, ctrl-&gt;bPreferedVersion);<br> printk(“bMinVersion = %d\n”, ctrl-&gt;bMinVersion);<br> printk(“bMinVersion = %d\n”, ctrl-&gt;bMinVersion);<br> }</p> 
<p>/* 参考: uvc_get_video_ctrl<br> (ret = uvc_get_video_ctrl(video, probe, 1, GET_CUR))<br> static int uvc_get_video_ctrl(struct uvc_video_device *video,<br> struct uvc_streaming_control *ctrl, int probe, __u8 query)<br> */<br> static int sheldon_uvc_get_streaming_params(struct sheldon_uvc_streaming_control *ctrl)<br> {<!-- --><br> __u8 *data;<br> __u16 size;<br> int ret;<br> __u8 type = USB_TYPE_CLASS | USB_RECIP_INTERFACE;<br> unsigned int pipe;</p> 
<pre><code>size = uvc_version &gt;= 0x0110 ? 34 : 26;
data = kmalloc(size, GFP_KERNEL);
if (data == NULL)
    return -ENOMEM;

pipe = (GET_CUR &amp; 0x80) ? usb_rcvctrlpipe(sheldon_uvc_udev, 0)
              : usb_sndctrlpipe(sheldon_uvc_udev, 0);
type |= (GET_CUR &amp; 0x80) ? USB_DIR_IN : USB_DIR_OUT;

ret = usb_control_msg(sheldon_uvc_udev, pipe, GET_CUR, type, VS_PROBE_CONTROL &lt;&lt; 8,
        0 &lt;&lt; 8 | sheldon_uvc_streaming_intf, data, size, 5000);

if (ret &lt; 0)
    goto done;

ctrl-&gt;bmHint = le16_to_cpup((__le16 *)&amp;data[0]);
ctrl-&gt;bFormatIndex = data[2];
ctrl-&gt;bFrameIndex = data[3];
ctrl-&gt;dwFrameInterval = le32_to_cpup((__le32 *)&amp;data[4]);
ctrl-&gt;wKeyFrameRate = le16_to_cpup((__le16 *)&amp;data[8]);
ctrl-&gt;wPFrameRate = le16_to_cpup((__le16 *)&amp;data[10]);
ctrl-&gt;wCompQuality = le16_to_cpup((__le16 *)&amp;data[12]);
ctrl-&gt;wCompWindowSize = le16_to_cpup((__le16 *)&amp;data[14]);
ctrl-&gt;wDelay = le16_to_cpup((__le16 *)&amp;data[16]);
ctrl-&gt;dwMaxVideoFrameSize = get_unaligned_le32(&amp;data[18]);
ctrl-&gt;dwMaxPayloadTransferSize = get_unaligned_le32(&amp;data[22]);

if (size == 34) {
    ctrl-&gt;dwClockFrequency = get_unaligned_le32(&amp;data[26]);
    ctrl-&gt;bmFramingInfo = data[30];
    ctrl-&gt;bPreferedVersion = data[31];
    ctrl-&gt;bMinVersion = data[32];
    ctrl-&gt;bMaxVersion = data[33];
} else {
    //ctrl-&gt;dwClockFrequency = video-&gt;dev-&gt;clock_frequency;
    ctrl-&gt;bmFramingInfo = 0;
    ctrl-&gt;bPreferedVersion = 0;
    ctrl-&gt;bMinVersion = 0;
    ctrl-&gt;bMaxVersion = 0;
}
</code></pre> 
<p>done:<br> kfree(data);</p> 
<pre><code>return (ret &lt; 0) ? ret : 0;
</code></pre> 
<p>}</p> 
<p>/* 参考: uvc_v4l2_try_format ∕uvc_probe_video</p> 
<ul><li> <pre><code>  uvc_set_video_ctrl(video, probe, 1)
</code></pre> </li></ul> 
<p>*/<br> static int sheldon_uvc_try_streaming_params(struct sheldon_uvc_streaming_control *ctrl)<br> {<!-- --><br> __u8 *data;<br> __u16 size;<br> int ret;<br> __u8 type = USB_TYPE_CLASS | USB_RECIP_INTERFACE;<br> unsigned int pipe;</p> 
<pre><code>memset(ctrl, 0, sizeof *ctrl);

ctrl-&gt;bmHint = 1;    /* dwFrameInterval */
ctrl-&gt;bFormatIndex = 1;
ctrl-&gt;bFrameIndex  = frame_idx + 1;
ctrl-&gt;dwFrameInterval = 333333;


size = uvc_version &gt;= 0x0110 ? 34 : 26;
data = kzalloc(size, GFP_KERNEL);


if (data == NULL)
    return -ENOMEM;


*(__le16 *)&amp;data[0] = cpu_to_le16(ctrl-&gt;bmHint);
data[2] = ctrl-&gt;bFormatIndex;
data[3] = ctrl-&gt;bFrameIndex;
*(__le32 *)&amp;data[4] = cpu_to_le32(ctrl-&gt;dwFrameInterval);
*(__le16 *)&amp;data[8] = cpu_to_le16(ctrl-&gt;wKeyFrameRate);
*(__le16 *)&amp;data[10] = cpu_to_le16(ctrl-&gt;wPFrameRate);
*(__le16 *)&amp;data[12] = cpu_to_le16(ctrl-&gt;wCompQuality);
*(__le16 *)&amp;data[14] = cpu_to_le16(ctrl-&gt;wCompWindowSize);
*(__le16 *)&amp;data[16] = cpu_to_le16(ctrl-&gt;wDelay);
put_unaligned_le32(ctrl-&gt;dwMaxVideoFrameSize, &amp;data[18]);
put_unaligned_le32(ctrl-&gt;dwMaxPayloadTransferSize, &amp;data[22]);


if (size == 34) {
    put_unaligned_le32(ctrl-&gt;dwClockFrequency, &amp;data[26]);
    data[30] = ctrl-&gt;bmFramingInfo;
    data[31] = ctrl-&gt;bPreferedVersion;
    data[32] = ctrl-&gt;bMinVersion;
    data[33] = ctrl-&gt;bMaxVersion;
}


pipe = (SET_CUR &amp; 0x80) ? usb_rcvctrlpipe(sheldon_uvc_udev, 0)
              : usb_sndctrlpipe(sheldon_uvc_udev, 0);


type |= (SET_CUR &amp; 0x80) ? USB_DIR_IN : USB_DIR_OUT;

ret = usb_control_msg(sheldon_uvc_udev, pipe, SET_CUR, type, VS_PROBE_CONTROL &lt;&lt; 8,
        0 &lt;&lt; 8 | sheldon_uvc_streaming_intf, data, size, 5000);


kfree(data);

return (ret &lt; 0) ? ret : 0;
</code></pre> 
<p>}</p> 
<p>/* 参考: uvc_v4l2_try_format ∕uvc_probe_video</p> 
<ul><li> <pre><code>  uvc_set_video_ctrl(video, probe, 1)
</code></pre> </li></ul> 
<p>*/<br> static int sheldon_uvc_set_streaming_params(struct sheldon_uvc_streaming_control *ctrl)<br> {<!-- --><br> __u8 *data;<br> __u16 size;<br> int ret;<br> __u8 type = USB_TYPE_CLASS | USB_RECIP_INTERFACE;<br> unsigned int pipe;</p> 
<pre><code>size = uvc_version &gt;= 0x0110 ? 34 : 26;
data = kzalloc(size, GFP_KERNEL);
if (data == NULL)
    return -ENOMEM;

*(__le16 *)&amp;data[0] = cpu_to_le16(ctrl-&gt;bmHint);
data[2] = ctrl-&gt;bFormatIndex;
data[3] = ctrl-&gt;bFrameIndex;
*(__le32 *)&amp;data[4] = cpu_to_le32(ctrl-&gt;dwFrameInterval);
*(__le16 *)&amp;data[8] = cpu_to_le16(ctrl-&gt;wKeyFrameRate);
*(__le16 *)&amp;data[10] = cpu_to_le16(ctrl-&gt;wPFrameRate);
*(__le16 *)&amp;data[12] = cpu_to_le16(ctrl-&gt;wCompQuality);
*(__le16 *)&amp;data[14] = cpu_to_le16(ctrl-&gt;wCompWindowSize);
*(__le16 *)&amp;data[16] = cpu_to_le16(ctrl-&gt;wDelay);
put_unaligned_le32(ctrl-&gt;dwMaxVideoFrameSize, &amp;data[18]);
put_unaligned_le32(ctrl-&gt;dwMaxPayloadTransferSize, &amp;data[22]);

if (size == 34) {
    put_unaligned_le32(ctrl-&gt;dwClockFrequency, &amp;data[26]);
    data[30] = ctrl-&gt;bmFramingInfo;
    data[31] = ctrl-&gt;bPreferedVersion;
    data[32] = ctrl-&gt;bMinVersion;
    data[33] = ctrl-&gt;bMaxVersion;
}

pipe = (SET_CUR &amp; 0x80) ? usb_rcvctrlpipe(sheldon_uvc_udev, 0)
              : usb_sndctrlpipe(sheldon_uvc_udev, 0);
type |= (SET_CUR &amp; 0x80) ? USB_DIR_IN : USB_DIR_OUT;

ret = usb_control_msg(sheldon_uvc_udev, pipe, SET_CUR, type, VS_COMMIT_CONTROL &lt;&lt; 8,
        0 &lt;&lt; 8 | sheldon_uvc_streaming_intf, data, size, 5000);

kfree(data);

return (ret &lt; 0) ? ret : 0;
</code></pre> 
<p>}</p> 
<p>static void sheldon_uvc_uninit_urbs(void)<br> {<!-- --><br> int i;<br> for (i = 0; i &lt; sheldon_UVC_URBS; ++i) {<!-- --><br> if (sheldon_uvc_queue.urb_buffer[i])<br> {<!-- --><br> usb_buffer_free(sheldon_uvc_udev, sheldon_uvc_queue.urb_size, sheldon_uvc_queue.urb_buffer[i], sheldon_uvc_queue.urb_dma[i]);<br> sheldon_uvc_queue.urb_buffer[i] = NULL;<br> }</p> 
<pre><code>    if (sheldon_uvc_queue.urb[i])
    {
        usb_free_urb(sheldon_uvc_queue.urb[i]);
        sheldon_uvc_queue.urb[i] = NULL;
    }
}
</code></pre> 
<p>}</p> 
<p>/* 参考: uvc_video_complete / uvc_video_decode_isoc */<br> static void sheldon_uvc_video_complete(struct urb *urb)<br> {<!-- --><br> u8 *src;<br> u8 *dest;<br> int ret, i;<br> int len;<br> int maxlen;<br> int nbytes;<br> struct sheldon_uvc_buffer *buf;</p> 
<pre><code>switch (urb-&gt;status) {
case 0:
    break;

default:
    printk("Non-zero status (%d) in video "
        "completion handler.\n", urb-&gt;status);
    return;
}

/* 从irqqueue队列中取出第1个缓冲区 */
if (!list_empty(&amp;sheldon_uvc_queue.irqqueue)) //如果队列不空
{
    buf = list_first_entry(&amp;sheldon_uvc_queue.irqqueue, struct sheldon_uvc_buffer, irq);


    for (i = 0; i &lt; urb-&gt;number_of_packets; ++i) {
        if (urb-&gt;iso_frame_desc[i].status &lt; 0) {
            printk("USB isochronous frame "
                "lost (%d).\n", urb-&gt;iso_frame_desc[i].status);
            continue;
        }

        src  = urb-&gt;transfer_buffer + urb-&gt;iso_frame_desc[i].offset; //源

        dest = sheldon_uvc_queue.mem + buf-&gt;buf.m.offset + buf-&gt;buf.bytesused; //目的

        len = urb-&gt;iso_frame_desc[i].actual_length; //整个数据长度
        /* 判断数据是否有效 */
        /* URB数据含义:
         * data[0] : 头部长度
         * data[1] : 错误状态
         */
        if (len &lt; 2 || src[0] &lt; 2 || src[0] &gt; len)
            continue;

        /* Skip payloads marked with the error bit ("error frames"). */
        if (src[1] &amp; UVC_STREAM_ERR) {
            printk("Dropping payload (error bit set).\n");
            continue;
        }

        /* 除去头部后的数据长度 */
        len -= src[0];

        /* 缓冲区最多还能存多少数据 */
        maxlen = buf-&gt;buf.length - buf-&gt;buf.bytesused;
        nbytes = min(len, maxlen);

        /* 复制数据 */
        memcpy(dest, src + src[0], nbytes);
        buf-&gt;buf.bytesused += nbytes;

        /* 判断一帧数据是否已经全部接收到 */
        if (len &gt; maxlen) {
            buf-&gt;state = VIDEOBUF_DONE;
        }

        /* Mark the buffer as done if the EOF marker is set. */
        if (src[1] &amp; UVC_STREAM_EOF &amp;&amp; buf-&gt;buf.bytesused != 0) {
            printk("Frame complete (EOF found).\n");
            if (len == 0)
                printk("EOF in empty payload.\n");
            buf-&gt;state = VIDEOBUF_DONE;
        }

    }

    /* 当接收完一帧数据,
     * 从irqqueue中删除这个缓冲区
     * 唤醒等待数据的进程
     */
    if (buf-&gt;state == VIDEOBUF_DONE ||
        buf-&gt;state == VIDEOBUF_ERROR)
    {
        list_del(&amp;buf-&gt;irq);
        wake_up(&amp;buf-&gt;wait);
    }
}

/* 再次提交URB */
if ((ret = usb_submit_urb(urb, GFP_ATOMIC)) &lt; 0) {
    printk("Failed to resubmit video URB (%d).\n", ret);
}
</code></pre> 
<p>}</p> 
<p>/* 参考: uvc_init_video_isoc */<br> static int sheldon_uvc_alloc_init_urbs(void)<br> {<!-- --><br> u16 psize;<br> u32 size;<br> int npackets;<br> int i;<br> int j;</p> 
<pre><code>struct urb *urb;

psize = wMaxPacketSize; /* 实时传输端点一次能传输的最大字节数 */
size  = sheldon_uvc_params.dwMaxVideoFrameSize;  /* 一帧数据的最大长度 */
npackets = DIV_ROUND_UP(size, psize);
if (npackets &gt; 32)
    npackets = 32;

size = sheldon_uvc_queue.urb_size = psize * npackets;

for (i = 0; i &lt; sheldon_UVC_URBS; ++i) {
    /* 1. 分配usb_buffers */

    sheldon_uvc_queue.urb_buffer[i] = usb_buffer_alloc(
        sheldon_uvc_udev, size,
        GFP_KERNEL | __GFP_NOWARN, &amp;sheldon_uvc_queue.urb_dma[i]); //sheldon_uvc_queue.urb_dma[i]存放分配的物理地址

    /* 2. 分配urb */
    sheldon_uvc_queue.urb[i] = usb_alloc_urb(npackets, GFP_KERNEL);

    if (!sheldon_uvc_queue.urb_buffer[i] || !sheldon_uvc_queue.urb[i])
    {
        sheldon_uvc_uninit_urbs();
        return -ENOMEM;
    }

}

/* 3. 设置urb */
for (i = 0; i &lt; sheldon_UVC_URBS; ++i) {
    urb = sheldon_uvc_queue.urb[i];

    urb-&gt;dev = sheldon_uvc_udev;
    urb-&gt;context = NULL;
    urb-&gt;pipe = usb_rcvisocpipe(sheldon_uvc_udev,sheldon_uvc_bEndpointAddress);
    urb-&gt;transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;
    urb-&gt;interval = 1;
    urb-&gt;transfer_buffer = sheldon_uvc_queue.urb_buffer[i]; //分配的urb buffer
    urb-&gt;transfer_dma = sheldon_uvc_queue.urb_dma[i]; //分配的urb 物理地址
    urb-&gt;complete = sheldon_uvc_video_complete; //收完数据的中断处理函数
    urb-&gt;number_of_packets = npackets; //要传输的数据次数
    urb-&gt;transfer_buffer_length = size; //总共的数据量

    for (j = 0; j &lt; npackets; ++j) {
        urb-&gt;iso_frame_desc[j].offset = j * psize;  //存放每次传输的数据
        urb-&gt;iso_frame_desc[j].length = psize;
    }

}

return 0;
</code></pre> 
<p>}</p> 
<p>/*打开视频流</p> 
<ul><li>参考: uvc_video_enable(video, 1):</li><li> <pre><code>      uvc_commit_video
</code></pre> </li><li> <pre><code>      uvc_init_video
</code></pre> </li></ul> 
<p>*/<br> static int sheldonUV_vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)<br> {<!-- --><br> int ret;</p> 
<pre><code>   /* 1. 向USB摄像头设置参数: 比如使用哪个format, 使用这个format下的哪个frame(分辨率)
    * 参考: uvc_set_video_ctrl / uvc_get_video_ctrl
    * 1.1 根据一个结构体uvc_streaming_control设置数据包: 可以手工设置,也可以读出后再修改
    * 1.2 调用usb_control_msg发出数据包
    */



   /* a. 测试参数 */
   ret = sheldon_uvc_try_streaming_params(&amp;sheldon_uvc_params);
   printk("sheldon_uvc_try_streaming_params ret = %d\n", ret);



   /* b. 取出参数 */
   ret = sheldon_uvc_get_streaming_params(&amp;sheldon_uvc_params);
   printk("sheldon_uvc_get_streaming_params ret = %d\n", ret);

   /* c. 设置参数 */
   ret = sheldon_uvc_set_streaming_params(&amp;sheldon_uvc_params);
   printk("sheldon_uvc_set_streaming_params ret = %d\n", ret);

   sheldon_uvc_print_streaming_params(&amp;sheldon_uvc_params);

   /* d. 设置VideoStreaming Interface所使用的setting
    * d.1 从sheldon_uvc_params确定带宽
    * d.2 根据setting的endpoint能传输的wMaxPacketSize
    *      找到能满足该带宽的setting
    */
   /* 手工确定:
    * bandwidth = sheldon_uvc_params.dwMaxPayloadTransferSize = 64
    * 观察lsusb -v -d 0x1e4e:的结果:
    *                 wMaxPacketSize     0x0080    1x128 bytes
    * bAlternateSetting       6
    */
   usb_set_interface(sheldon_uvc_udev, sheldon_uvc_streaming_intf, sheldon_uvc_streaming_bAlternateSetting);

   /* 2. 分配设置URB */
   ret = sheldon_uvc_alloc_init_urbs();
   if (ret)
       printk("sheldon_uvc_alloc_init_urbs err : ret = %d\n", ret);

   /* 3. 提交URB以接收数据 */
   for (i = 0; i &lt; sheldon_UVC_URBS; ++i) {
       if ((ret = usb_submit_urb(sheldon_uvc_queue.urb[i], GFP_KERNEL)) &lt; 0) {
           printk("Failed to submit URB %u (%d).\n", i, ret);
           sheldon_uvc_uninit_urbs();
           return ret;
       }
   }

   return 0;
</code></pre> 
<p>}</p> 
<p>/<em>底层的硬件操作函数取出队列的缓存</em>/<br> static int sheldonUV_vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer <em>v4l2_buf)<br> {<!-- --><br> /</em> APP发现数据就绪后, 从mainqueue里取出这个buffer */</p> 
<pre><code>struct sheldon_uvc_buffer *buf;
int ret = 0;

if (list_empty(&amp;sheldon_uvc_queue.mainqueue)) {
    ret = -EINVAL;
    goto done;
}

buf = list_first_entry(&amp;sheldon_uvc_queue.mainqueue, struct sheldon_uvc_buffer, stream);

switch (buf-&gt;state) {
case VIDEOBUF_ERROR:
    ret = -EIO;
case VIDEOBUF_DONE:
    buf-&gt;state = VIDEOBUF_IDLE;
    break;

case VIDEOBUF_IDLE:
case VIDEOBUF_QUEUED:
case VIDEOBUF_ACTIVE:
default:
    ret = -EINVAL;
    goto done;
}

list_del(&amp;buf-&gt;stream);
</code></pre> 
<p>done:<br> return ret;<br> }</p> 
<p>/*</p> 
<ul><li>A14 之前已经通过mmap映射了缓存, APP可以直接读数据</li><li>A15 再次调用sheldonUV_vidioc_qbuf把缓存放入队列</li><li>A16 poll…<br> */</li></ul> 
<p>/* A17 停止-关闭视频流</p> 
<ul><li>参考 : uvc_video_enable(video, 0)<br> */</li></ul> 
<p>static int sheldonUV_vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type t)<br> {<!-- --><br> struct urb *urb;<br> unsigned int i;</p> 
<pre><code>/* 1. kill URB */
for (i = 0; i &lt; sheldon_UVC_URBS; ++i) {
    if ((urb = sheldon_uvc_queue.urb[i]) == NULL)
        continue;
    usb_kill_urb(urb);
}

/* 2. free URB */
sheldon_uvc_uninit_urbs();

/* 3. 设置VideoStreaming Interface为setting 0 */
usb_set_interface(sheldon_uvc_udev, sheldon_uvc_streaming_intf, 0);

return 0;
</code></pre> 
<p>}</p> 
<p>/<em>[下面几个函数实现属性设置]</em>/</p> 
<p>/*<br> *Extract the bit string specified by mapping-&gt;offset and mapping-&gt;size</p> 
<ul><li> <p>from the little-endian data stored at ‘data’ and return the result as</p> </li><li> <p>a signed 32bit integer. Sign extension will be performed if the mapping</p> </li><li> <p>references a signed data type.<br> */<br> static __s32 sheldonUV_get_le_value(const __u8 *data)<br> {<!-- --><br> int bits = 16;<br> int offset = 0;<br> __s32 value = 0;<br> __u8 mask;</p> <p>data += offset / 8;<br> offset &amp;= 7;<br> mask = ((1LL &lt;&lt; bits) - 1) &lt;&lt; offset;</p> <p>for (; bits &gt; 0; data++) {<!-- --><br> __u8 byte = *data &amp; mask;<br> value |= offset &gt; 0 ? (byte &gt;&gt; offset) : (byte &lt;&lt; (-offset));<br> bits -= 8 - (offset &gt; 0 ? offset : 0);<br> offset -= 8;<br> mask = (1 &lt;&lt; bits) - 1;<br> }</p> <p>/* Sign-extend the value if needed. */<br> value |= -(value &amp; (1 &lt;&lt; (16 - 1)));</p> <p>return value;<br> }</p> </li></ul> 
<p>/* Set the bit string specified by mapping-&gt;offset and mapping-&gt;size</p> 
<ul><li> <p>in the little-endian data stored at ‘data’ to the value ‘value’.<br> */<br> static void sheldonUV_set_le_value(__s32 value, __u8 *data)<br> {<!-- --><br> int bits = 16;<br> int offset = 0;<br> __u8 mask;</p> <p>data += offset / 8;<br> offset &amp;= 7;</p> <p>for (; bits &gt; 0; data++) {<!-- --><br> mask = ((1LL &lt;&lt; bits) - 1) &lt;&lt; offset;<br> *data = (*data &amp; ~mask) | ((value &lt;&lt; offset) &amp; mask);<br> value &gt;&gt;= offset ? offset : 8;<br> bits -= 8 - offset;<br> offset = 0;<br> }<br> }</p> </li></ul> 
<p>/* 参考:uvc_query_v4l2_ctrl:调用VIDIOC_QUERYCTRL ioctl确定是否支持某个属性 */<br> int sheldonUV_vidioc_queryctrl (struct file *file, void *fh,<br> struct v4l2_queryctrl *ctrl)<br> {<!-- --><br> __u8 type = USB_TYPE_CLASS | USB_RECIP_INTERFACE;<br> unsigned int pipe;<br> int ret;<br> u8 data[2];</p> 
<pre><code>if (ctrl-&gt;id != V4L2_CID_BRIGHTNESS)
    return -EINVAL;

memset(ctrl, 0, sizeof *ctrl);
ctrl-&gt;id   = V4L2_CID_BRIGHTNESS;
ctrl-&gt;type = V4L2_CTRL_TYPE_INTEGER;
strcpy(ctrl-&gt;name, "sheldonUV_BRIGHTNESS");
ctrl-&gt;flags = 0;

pipe = usb_rcvctrlpipe(sheldon_uvc_udev, 0);
type |= USB_DIR_IN;

/* 发起USB传输确定这些值 */
ret = usb_control_msg(sheldon_uvc_udev, pipe, GET_MIN, type, PU_BRIGHTNESS_CONTROL &lt;&lt; 8,
        ProcessingUnitID &lt;&lt; 8 | sheldon_uvc_control_intf, data, 2, 5000);
if (ret != 2)
    return -EIO;
ctrl-&gt;minimum = sheldonUV_get_le_value(data);    /* Note signedness */


ret = usb_control_msg(sheldon_uvc_udev, pipe, GET_MAX, type,  PU_BRIGHTNESS_CONTROL &lt;&lt; 8,
        ProcessingUnitID &lt;&lt; 8 | sheldon_uvc_control_intf, data, 2, 5000);
if (ret != 2)
    return -EIO;
ctrl-&gt;maximum = sheldonUV_get_le_value(data);    /* Note signedness */

ret = usb_control_msg(sheldon_uvc_udev, pipe, GET_RES, type, PU_BRIGHTNESS_CONTROL &lt;&lt; 8,
         ProcessingUnitID &lt;&lt; 8 | sheldon_uvc_control_intf, data, 2, 5000);
if (ret != 2)
    return -EIO;
ctrl-&gt;step = sheldonUV_get_le_value(data);    /* Note signedness */

ret = usb_control_msg(sheldon_uvc_udev, pipe, GET_DEF, type, PU_BRIGHTNESS_CONTROL &lt;&lt; 8,
        ProcessingUnitID &lt;&lt; 8 | sheldon_uvc_control_intf, data, 2, 5000);
if (ret != 2)
    return -EIO;
ctrl-&gt;default_value = sheldonUV_get_le_value(data);    /* Note signedness */

printk("Brightness: min =%d, max = %d, step = %d, default = %d\n", ctrl-&gt;minimum, ctrl-&gt;maximum, ctrl-&gt;step, ctrl-&gt;default_value);

return 0;
</code></pre> 
<p>}</p> 
<p>/* 参考 : uvc_ctrl_get : 获得属性 */<br> int sheldonUV_vidioc_g_ctrl (struct file *file, void *fh,<br> struct v4l2_control *ctrl)<br> {<!-- --><br> __u8 type = USB_TYPE_CLASS | USB_RECIP_INTERFACE;<br> unsigned int pipe;<br> int ret;<br> u8 data[2];</p> 
<pre><code>if (ctrl-&gt;id != V4L2_CID_BRIGHTNESS)
    return -EINVAL;

pipe = usb_rcvctrlpipe(sheldon_uvc_udev, 0);
type |= USB_DIR_IN;

ret = usb_control_msg(sheldon_uvc_udev, pipe, GET_CUR, type, PU_BRIGHTNESS_CONTROL &lt;&lt; 8,
        ProcessingUnitID &lt;&lt; 8 | sheldon_uvc_control_intf, data, 2, 5000);
if (ret != 2)
    return -EIO;
ctrl-&gt;value = sheldonUV_get_le_value(data);    /* Note signedness */

return 0;
</code></pre> 
<p>}</p> 
<p>/* 参考: uvc_ctrl_set/uvc_ctrl_commit : 设置属性*/<br> int sheldonUV_vidioc_s_ctrl (struct file *file, void *fh,<br> struct v4l2_control *ctrl)<br> {<!-- --><br> __u8 type = USB_TYPE_CLASS | USB_RECIP_INTERFACE;<br> unsigned int pipe;<br> int ret;<br> u8 data[2];</p> 
<pre><code>if (ctrl-&gt;id != V4L2_CID_BRIGHTNESS)
    return -EINVAL;

sheldonUV_set_le_value(ctrl-&gt;value, data);

pipe = usb_sndctrlpipe(sheldon_uvc_udev, 0);
type |= USB_DIR_OUT;

ret = usb_control_msg(sheldon_uvc_udev, pipe, SET_CUR, type, PU_BRIGHTNESS_CONTROL &lt;&lt; 8,
        ProcessingUnitID  &lt;&lt; 8 | sheldon_uvc_control_intf, data, 2, 5000);
if (ret != 2)
    return -EIO;

return 0;
</code></pre> 
<p>}</p> 
<p>static const struct v4l2_ioctl_ops sheldonUV_ioctl_ops = {<!-- --><br> // 表示它是一个摄像头设备<br> .vidioc_querycap = sheldonUV_vidioc_querycap,</p> 
<pre><code>    /* 用于列举、获得、测试、设置摄像头的数据的格式 */
    .vidioc_enum_fmt_vid_cap  = sheldonUV_vidioc_enum_fmt_vid_cap,
    .vidioc_g_fmt_vid_cap     = sheldonUV_vidioc_get_fmt_vid_cap,
    .vidioc_try_fmt_vid_cap   = sheldonUV_vidioc_try_fmt_vid_cap,
    .vidioc_s_fmt_vid_cap     = sheldonUV_vidioc_set_fmt_vid_cap,

    /* 缓冲区操作: 申请/查询/放入队列/取出队列 */
    .vidioc_reqbufs       = sheldonUV_vidioc_reqbufs,
    .vidioc_querybuf      = sheldonUV_vidioc_querybuf,
    .vidioc_qbuf          = sheldonUV_vidioc_qbuf,
    .vidioc_dqbuf         = sheldonUV_vidioc_dqbuf,

     /* 查询/获得/设置属性 */
    .vidioc_queryctrl     = sheldonUV_vidioc_queryctrl,
    .vidioc_g_ctrl        = sheldonUV_vidioc_g_ctrl,
    .vidioc_s_ctrl        = sheldonUV_vidioc_s_ctrl,

    // 启动/停止
    .vidioc_streamon      = sheldonUV_vidioc_streamon,
    .vidioc_streamoff     = sheldonUV_vidioc_streamoff,
</code></pre> 
<p>};</p> 
<p>static int sheldonUV_open(struct file <em>file)<br> {<!-- --><br> /</em> 队列操作2: 初始化 <em>/<br> /</em> videobuf_queue_vmalloc_init(&amp;sheldonUV_vb_vidqueue, &amp;sheldonUV_video_qops,<br> NULL, &amp;sheldonUV_queue_slock, V4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FIELD_INTERLACED,<br> sizeof(struct videobuf_buffer), NULL); // 倒数第2个参数是buffer的头部大小</p> 
<pre><code>sheldonUV_timer.expires = jiffies + 1;
add_timer(&amp;sheldonUV_timer);
</code></pre> 
<p>*/<br> return 0;<br> }</p> 
<p>static void sheldon_uvc_vm_open(struct vm_area_struct *vma)<br> {<!-- --><br> struct sheldon_uvc_buffer *buffer = vma-&gt;vm_private_data;<br> buffer-&gt;vma_use_count++;<br> }</p> 
<p>static void sheldon_uvc_vm_close(struct vm_area_struct *vma)<br> {<!-- --><br> struct sheldon_uvc_buffer *buffer = vma-&gt;vm_private_data;<br> buffer-&gt;vma_use_count–;<br> }</p> 
<p>static struct vm_operations_struct sheldon_uvc_vm_ops = {<!-- --><br> .open = sheldon_uvc_vm_open,<br> .close = sheldon_uvc_vm_close,<br> };</p> 
<p>/*映射-&gt;应用程序空间,之后app可以直接操作这块</p> 
<ul><li> <p>参考: uvc_v4l2_mmap<br> */<br> static int sheldonUV_mmap(struct file *file, struct vm_area_struct *vma)<br> {<!-- --><br> struct sheldon_uvc_buffer *buffer;<br> struct page *page;<br> unsigned long addr, start, size;<br> unsigned int i;<br> int ret = 0;</p> <p>start = vma-&gt;vm_start;<br> size = vma-&gt;vm_end - vma-&gt;vm_start;</p> <p>/* 应用程序调用mmap函数时, 会传入offset参数</p> 
  <ul><li>根据这个offset找出指定的缓冲区<br> */<br> for (i = 0; i &lt; sheldon_uvc_queue.count; ++i) {<!-- --><br> buffer = &amp;sheldon_uvc_queue.buffer[i];<br> if ((buffer-&gt;buf.m.offset &gt;&gt; PAGE_SHIFT) == vma-&gt;vm_pgoff)<br> break;<br> }</li></ul> <p>if (i == sheldon_uvc_queue.count || size != sheldon_uvc_queue.buf_size) {<!-- --><br> ret = -EINVAL;<br> goto done;<br> }</p> <p>/*</p> 
  <ul><li>VM_IO marks the area as being an mmaped region for I/O to a</li><li>device. It also prevents the region from being core dumped.<br> */<br> vma-&gt;vm_flags |= VM_IO;</li></ul> <p>/* 根据虚拟地址找到缓冲区对应的page构体 */<br> addr = (unsigned long)sheldon_uvc_queue.mem + buffer-&gt;buf.m.offset;<br> while (size &gt; 0) {<!-- --><br> page = vmalloc_to_page((void *)addr);</p> <pre><code> /* 把此page映射到APP对应的虚拟地址上面 */
 if ((ret = vm_insert_page(vma, start, page)) &lt; 0)
     goto done;

 start += PAGE_SIZE;
 addr += PAGE_SIZE;
 size -= PAGE_SIZE;
</code></pre> <p>}</p> <p>vma-&gt;vm_ops = &amp;sheldon_uvc_vm_ops;<br> vma-&gt;vm_private_data = buffer;<br> sheldon_uvc_vm_open(vma);</p> </li></ul> 
<p>done:<br> return ret;<br> }</p> 
<p>/<em>APP 调用POLL/select确定缓存数据是否就绪</em>/<br> static unsigned int sheldonUV_poll(struct file *file, struct poll_table_struct *wait)<br> {<!-- --><br> struct sheldon_uvc_buffer *buf;<br> unsigned int mask = 0;</p> 
<pre><code>    /* 从mainqueuq中取出第1个缓冲区 */

    /*判断它的状态, 如果未就绪, 休眠 */

    if (list_empty(&amp;sheldon_uvc_queue.mainqueue)) {
        mask |= POLLERR;
        goto done;
    }

    buf = list_first_entry(&amp;sheldon_uvc_queue.mainqueue, struct sheldon_uvc_buffer, stream);

    poll_wait(file, &amp;buf-&gt;wait, wait);
    if (buf-&gt;state == VIDEOBUF_DONE ||
        buf-&gt;state == VIDEOBUF_ERROR)
        mask |= POLLIN | POLLRDNORM;

done:
    return mask;
</code></pre> 
<p>}</p> 
<p>static int sheldonUV_close(struct file *file)<br> {<!-- --><br> //del_timer(&amp;sheldonUV_timer);<br> //videobuf_stop(&amp;sheldonUV_vb_vidqueue);<br> //videobuf_mmap_free(&amp;sheldonUV_vb_vidqueue);</p> 
<p>return 0;<br> }</p> 
<p>static const struct v4l2_file_operations sheldonUV_fops = {<!-- --><br> .owner = THIS_MODULE,<br> .open = sheldonUV_open,<br> .release = sheldonUV_close,<br> .mmap = sheldonUV_mmap,<br> .ioctl = video_ioctl2, /* V4L2 ioctl handler -&gt; sheldonUV_ioctl_ops*/<br> .poll = sheldonUV_poll,<br> };</p> 
<p>static void sheldonUV_release(struct video_device *vdev)<br> {<!-- --><br> }</p> 
<p>//probe处理函数，有匹配usb设备时调用<br> static int sheldon_uvc_probe(struct usb_interface *intf, const struct usb_device_id *id)<br> {<!-- --><br> static int cnt;</p> 
<p>//根据interface结构体获得usb_devce结构体，其中包含了设备描述符<br> struct usb_device *dev = interface_to_usbdev(intf);<br> //此处需要定义一个描述符结构体<br> struct usb_device_descriptor *descriptor = &amp;dev-&gt;descriptor;<br> //从usb_device结构体中获得配置描述符相关信息<br> struct usb_host_config *host_config;<br> struct usb_config_descriptor *config;<br> //定义接口联合体描述符结构体,获得 IAD 接口<br> struct usb_interface_assoc_descriptor *assoc_desc;<br> //接口描述符<br> struct usb_interface_descriptor *interface;<br> //端点描述符<br> struct usb_endpoint_descriptor *endpoint;<br> //定义接口设置信息结构体<br> //struct usb_interface_descriptor *idesc;</p> 
<p>int i, j ,k ,l ,m;<br> unsigned char *buffer;<br> int buflen;</p> 
<p>int desc_len;<br> //int desc_cnt;</p> 
<p>sheldon_uvc_udev = dev;</p> 
<p>printk(“sheldn_uvc_probe : cnt = %d\n”, cnt++);</p> 
<pre><code>if (cnt == 1)
{
    sheldon_uvc_control_intf = intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber;
}
else if(cnt == 2)
{
    sheldon_uvc_streaming_intf = intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber;
}

if (cnt == 2)
{
    /*1.分配一个video_device结构体*/
    sheldon_uvc_vdev = video_device_alloc();
    /*2.设置*/
    /* 2.1 */
    sheldon_uvc_vdev-&gt;release = sheldonUV_release;

    /* 2.2 */
    sheldon_uvc_vdev-&gt;fops    = &amp;sheldonUV_fops;

    /* 2.3 */
    sheldon_uvc_vdev-&gt;ioctl_ops = &amp;sheldonUV_ioctl_ops;
    /*3.注册*/
    video_register_device(sheldon_uvc_vdev ,VFL_TYPE_GRABBER, -1);
}
</code></pre> 
<p>return 0;<br> }</p> 
<p>//disconnect函数，设备断开时调用<br> static void sheldon_uvc_disconnect(struct usb_interface *intf)<br> {<!-- --><br> static int cnt;<br> printk(“sheldon_uvc_disconnect : cnt = %d\n”,cnt++);</p> 
<pre><code>if (cnt == 2)
{
    video_unregister_device(sheldon_uvc_vdev);
    video_device_release(sheldon_uvc_vdev);
}
</code></pre> 
<p>}</p> 
<p>//支持的设备类型信息<br> static struct usb_device_id sheldon_uvc_ids[] = {<!-- --><br> /* Generic USB Video Class */<br> { USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, 0) },/<em>1-视频控制接口</em>/<br> { USB_INTERFACE_INFO(USB_CLASS_VIDEO, 2, 0) },/<em>2-视频流控制接口(被1包含)</em>/<br> {}<br> };</p> 
<p>//1.分配usb_driver结构体<br> //2.设置</p> 
<p>static struct usb_driver sheldon_uvc_driver = {<!-- --><br> .name = “sheldon_UV”,<br> .probe = sheldon_uvc_probe,<br> .disconnect = sheldon_uvc_disconnect,<br> .id_table = sheldon_uvc_ids,<br> };</p> 
<p>static int sheldon_uvc_init(void)<br> {<!-- --><br> //3.注册<br> printk(“sheldon_uvc_init ~\n”);<br> usb_register(&amp;sheldon_uvc_driver);<br> return 0;<br> }</p> 
<p>static void sheldon_uvc_exit(void)<br> {<!-- --><br> printk(“sheldon_uvc_exit ~\n”);<br> usb_deregister(&amp;sheldon_uvc_driver);<br> }</p> 
<p>module_init(sheldon_uvc_init);<br> module_exit(sheldon_uvc_exit);<br> MODULE_LICENSE(“GPL”);</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e239a13f07d18d84e54326121c79bd8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">工业光源</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67dbc2a4133671e2a437daf4473292a1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js高级 第二天 数据/变量/内存 内存图 变量在内存中 变量的赋值 函数传参 声明全局变量的三种方式 回调函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>