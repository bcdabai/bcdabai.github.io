<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【UOJ#61】【UR #5】怎样更有力气（最小生成树） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【UOJ#61】【UR #5】怎样更有力气（最小生成树）" />
<meta property="og:description" content="【UOJ#61】【UR #5】怎样更有力气（最小生成树） 题面 UOJ
题解 最最最暴力的想法是把所有边给处理出来然后跑\(MST\)。
考虑边权的情况，显然离线考虑，把么一天按照\(w_i\)进行排序，显然在这一天的可以连的所有点中，我们能连则连。
考虑把这一天的所有的限制给弄出来（也就是弄出限制的子图）。
如果限制的数量不超过这一天的\(dis(u,v)\)，显然任意两点之间都是可以直接连边的，那么直接连起来就好了。
否则的话我们要找到一个复杂度和限制数量相关的东西来连边，并且因为两点长度小于限制数量，所以可以暴力把路径上的所有点全部弄下来。
找到度数最小的一个点，那么点集被分成了两类：一类与这个点相连，记做集合\(V\)，另外一个与这个点不相邻，所以可以直接与这个点连在一起，记做集合\(U\)。
\(V\)集合中的点如果要连边，要么就是从\(U\)集合连过来的，要么是从\(V\)集合连过来的。
如果是从\(U\)集合连过来，考虑\(y\in V\)，如果\(deg[y]\lt |U|\)，显然至少和一个\(U\)集合中的点无边，所以可以直接连接。否则的话\(O(deg[y])\)的给周围的所有点暴力搞一搞。这样子复杂度是\(O(\sum deg[y])=O(k)\)的。
否则对于\(V\)集合连向\(V\)集合，可以暴力枚举集合中的两个点，因为度数最小的点的度数是根号级别的，所以这里\(O(d^2)=O(k)\)。
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define ll long long #define MAX 300300 inline int read() { int x=0;bool t=false;char ch=getchar(); while((ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&amp;&amp;ch!=&#39;-&#39;)ch=getchar(); if(ch==&#39;-&#39;)t=true,ch=getchar(); while(ch&lt;=&#39;9&#39;&amp;&amp;ch&gt;=&#39;0&#39;)x=x*10&#43;ch-48,ch=getchar(); return t?-x:x; } int n,m,P;ll ans; struct Work{int u,v,w,t;}p[MAX]; bool operator&lt;(Work a,Work b){return a.w&lt;b.w;} struct Limit{int a,b;}; vector&lt;Limit&gt; A[MAX]; vector&lt;int&gt; E[MAX];int dg[MAX]; struct DSU { int f[MAX]; int getf(int x){return x==f[x]?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/efd3f30e981880bc34bc882cdbec0502/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-23T15:38:00+08:00" />
<meta property="article:modified_time" content="2019-06-23T15:38:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【UOJ#61】【UR #5】怎样更有力气（最小生成树）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h2 id="uoj61ur-5怎样更有力气最小生成树">【UOJ#61】【UR #5】怎样更有力气（最小生成树）</h2> 
 <h3 id="题面">题面</h3> 
 <p><a href="http://uoj.ac/problem/61" rel="nofollow">UOJ</a></p> 
 <h3 id="题解">题解</h3> 
 <p>最最最暴力的想法是把所有边给处理出来然后跑<span class="math inline">\(MST\)</span>。<br> 考虑边权的情况，显然离线考虑，把么一天按照<span class="math inline">\(w_i\)</span>进行排序，显然在这一天的可以连的所有点中，我们能连则连。<br> 考虑把这一天的所有的限制给弄出来（也就是弄出限制的子图）。<br> 如果限制的数量不超过这一天的<span class="math inline">\(dis(u,v)\)</span>，显然任意两点之间都是可以直接连边的，那么直接连起来就好了。<br> 否则的话我们要找到一个复杂度和限制数量相关的东西来连边，并且因为两点长度小于限制数量，所以可以暴力把路径上的所有点全部弄下来。<br> 找到度数最小的一个点，那么点集被分成了两类：一类与这个点相连，记做集合<span class="math inline">\(V\)</span>，另外一个与这个点不相邻，所以可以直接与这个点连在一起，记做集合<span class="math inline">\(U\)</span>。<br><span class="math inline">\(V\)</span>集合中的点如果要连边，要么就是从<span class="math inline">\(U\)</span>集合连过来的，要么是从<span class="math inline">\(V\)</span>集合连过来的。<br> 如果是从<span class="math inline">\(U\)</span>集合连过来，考虑<span class="math inline">\(y\in V\)</span>，如果<span class="math inline">\(deg[y]\lt |U|\)</span>，显然至少和一个<span class="math inline">\(U\)</span>集合中的点无边，所以可以直接连接。否则的话<span class="math inline">\(O(deg[y])\)</span>的给周围的所有点暴力搞一搞。这样子复杂度是<span class="math inline">\(O(\sum deg[y])=O(k)\)</span>的。<br> 否则对于<span class="math inline">\(V\)</span>集合连向<span class="math inline">\(V\)</span>集合，可以暴力枚举集合中的两个点，因为度数最小的点的度数是根号级别的，所以这里<span class="math inline">\(O(d^2)=O(k)\)</span>。</p> 
 <pre><code class="language-cpp"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define ll long long
#define MAX 300300
inline int read()
{
    int x=0;bool t=false;char ch=getchar();
    while((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-')ch=getchar();
    if(ch=='-')t=true,ch=getchar();
    while(ch&lt;='9'&amp;&amp;ch&gt;='0')x=x*10+ch-48,ch=getchar();
    return t?-x:x;
}
int n,m,P;ll ans;
struct Work{int u,v,w,t;}p[MAX];
bool operator&lt;(Work a,Work b){return a.w&lt;b.w;}
struct Limit{int a,b;};
vector&lt;Limit&gt; A[MAX];
vector&lt;int&gt; E[MAX];int dg[MAX];
struct DSU
{
    int f[MAX];
    int getf(int x){return x==f[x]?x:f[x]=getf(f[x]);}
}B,C;
int fa[MAX],dep[MAX];
bool check(int u,int v,int k)
{
    while(k--)
    {
        if(dep[u]&lt;dep[v])swap(u,v);
        u=fa[u];if(u==v)return false;
    }
    return true;
}
void Merge(int u,int v,int w)
{
    u=B.getf(u);v=B.getf(v);
    if(u==v)return;
    B.f[u]=v;ans+=w;
}
int S[MAX],len;
int U[MAX],su;
void GetLine(int u,int v)
{
    len=0;
    while(u^v)
    {
        if(dep[u]&lt;dep[v])swap(u,v);
        S[++len]=u;u=fa[u];
    }
    S[++len]=u;
}
bool vis[MAX];
int main()
{
    n=read();m=read();P=read();dep[1]=1;
    for(int i=2;i&lt;=n;++i)fa[i]=read(),dep[i]=dep[fa[i]]+1;
    for(int i=1;i&lt;=m;++i)p[i].u=read(),p[i].v=read(),p[i].w=read(),p[i].t=i;
    for(int i=1;i&lt;=P;++i)
    {
        int t=read(),a=read(),b=read();
        A[t].push_back((Limit){a,b});
    }
    sort(&amp;p[1],&amp;p[m+1]);
    for(int i=1;i&lt;=n;++i)B.f[i]=C.f[i]=i;
    for(int i=1;i&lt;=m;++i)
    {
        if(check(p[i].u,p[i].v,A[p[i].t].size()))
        {
            int u=C.getf(p[i].u),v=C.getf(p[i].v);
            while(u^v)
            {
                if(dep[u]&lt;dep[v])swap(u,v);
                Merge(u,fa[u],p[i].w);
                C.f[u]=fa[u],u=C.getf(u);
            }
        }
        else
        {
            for(auto u:A[p[i].t])
            {
                dg[u.a]++;dg[u.b]++;
                E[u.a].push_back(u.b);
                E[u.b].push_back(u.a);
            }
            GetLine(p[i].u,p[i].v);
            int x,mn=1e9;su=0;
            for(int j=1;j&lt;=len;++j)if(dg[S[j]]&lt;mn)mn=dg[S[j]],x=S[j];
            for(int v:E[x])vis[v]=true;
            for(int j=1;j&lt;=len;++j)if(!vis[S[j]])U[++su]=S[j],Merge(S[j],x,p[i].w);
            for(int v:E[x])vis[v]=false;
            for(int y:E[x])
            {
                for(int v:E[y])vis[v]=true;
                for(int v:E[x])if(!vis[v])Merge(y,v,p[i].w);
                for(int v:E[y])vis[v]=false;
                if(E[y].size()&lt;su)Merge(x,y,p[i].w);
                else
                {
                    for(int v:E[y])vis[v]=true;
                    for(int j=1;j&lt;=su;++j)
                        if(!vis[U[j]])Merge(U[j],y,p[i].w);
                    for(int v:E[y])vis[v]=false;
                }
            }
            for(auto u:A[p[i].t])
            {
                --dg[u.a];--dg[u.b];
                E[u.a].clear();
                E[u.b].clear();
            }
        }
    }
    printf("%lld\n",ans);
    return 0;
}</code></code></pre> 
</div> 
<p>转载于:https://www.cnblogs.com/cjyyb/p/11073012.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/75310dcb01a34b464a799cb502af8236/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">桌面云之深信服VMP平台搭建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4001413afa5e5526ec8d80579ed48e15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tensorboard学习六之Tensorboard的实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>