<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker 常用命令 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker 常用命令" />
<meta property="og:description" content="本文目录 1. Docker 基础命令1.1 启动 docker1.2 关闭 docker1.3 重启 docker1.4 开机启动 docker1.5 查看 docker 运行状态1.6 查看 docker 版本信息1.7 查看 docker 系统信息，包括镜像和容器数1.8 docker 帮助命令 2. Docker 镜像命令2.1 查看自己服务器中 docker 镜像列表2.2 搜索镜像2.3 拉取镜像（从 Docker 镜像仓库获取镜像）2.4 运行镜像2.5 删除镜像2.6 保存镜像2.7 加载镜像2.8 镜像标签 3. Docker 容器命令3.1 查看正在运行容器列表3.2 查看所有容器3.3 运行容器3.4 停止容器3.5 删除容器3.6 容器端口与服务器端口映射3.7 进入容器3.8 从容器内退出到自己的服务器3.9 启动容器3.10 重启容器3.11 kill 容器3.12 容器文件拷贝3.13 查看容器日志3.14 设置开机自动启动容器3.15 更换容器名3.16 导出和导入3.17 在容器和主机之间复制文件/文件夹 1. Docker 基础命令 1.1 启动 docker systemctl start docker 1.2 关闭 docker systemctl stop docker 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/eef74464ce39ec6c449467e2e406d677/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-05T20:46:01+08:00" />
<meta property="article:modified_time" content="2023-07-05T20:46:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker 常用命令</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>本文目录</h4> 
 <ul><li><a href="#1_Docker__1" rel="nofollow">1. Docker 基础命令</a></li><li><ul><li><a href="#11__docker_2" rel="nofollow">1.1 启动 docker</a></li><li><a href="#12__docker_6" rel="nofollow">1.2 关闭 docker</a></li><li><a href="#13__docker_10" rel="nofollow">1.3 重启 docker</a></li><li><a href="#14__docker_14" rel="nofollow">1.4 开机启动 docker</a></li><li><a href="#15__docker__18" rel="nofollow">1.5 查看 docker 运行状态</a></li><li><a href="#16__docker__30" rel="nofollow">1.6 查看 docker 版本信息</a></li><li><a href="#17__docker__37" rel="nofollow">1.7 查看 docker 系统信息，包括镜像和容器数</a></li><li><a href="#18_docker__44" rel="nofollow">1.8 docker 帮助命令</a></li></ul> 
  </li><li><a href="#2_Docker__60" rel="nofollow">2. Docker 镜像命令</a></li><li><ul><li><a href="#21__docker__61" rel="nofollow">2.1 查看自己服务器中 docker 镜像列表</a></li><li><a href="#22__78" rel="nofollow">2.2 搜索镜像</a></li><li><a href="#23__Docker__87" rel="nofollow">2.3 拉取镜像（从 Docker 镜像仓库获取镜像）</a></li><li><a href="#24__108" rel="nofollow">2.4 运行镜像</a></li><li><a href="#25__145" rel="nofollow">2.5 删除镜像</a></li><li><a href="#26__178" rel="nofollow">2.6 保存镜像</a></li><li><a href="#27__193" rel="nofollow">2.7 加载镜像</a></li><li><a href="#28__213" rel="nofollow">2.8 镜像标签</a></li></ul> 
  </li><li><a href="#3_Docker__253" rel="nofollow">3. Docker 容器命令</a></li><li><ul><li><a href="#31__275" rel="nofollow">3.1 查看正在运行容器列表</a></li><li><a href="#32__285" rel="nofollow">3.2 查看所有容器</a></li><li><a href="#33__295" rel="nofollow">3.3 运行容器</a></li><li><a href="#34__320" rel="nofollow">3.4 停止容器</a></li><li><a href="#35__331" rel="nofollow">3.5 删除容器</a></li><li><a href="#36__352" rel="nofollow">3.6 容器端口与服务器端口映射</a></li><li><a href="#37__376" rel="nofollow">3.7 进入容器</a></li><li><a href="#38__423" rel="nofollow">3.8 从容器内退出到自己的服务器</a></li><li><a href="#39__433" rel="nofollow">3.9 启动容器</a></li><li><a href="#310__439" rel="nofollow">3.10 重启容器</a></li><li><a href="#311_kill__444" rel="nofollow">3.11 kill 容器</a></li><li><a href="#312__449" rel="nofollow">3.12 容器文件拷贝</a></li><li><a href="#313__462" rel="nofollow">3.13 查看容器日志</a></li><li><a href="#314__466" rel="nofollow">3.14 设置开机自动启动容器</a></li><li><a href="#315__501" rel="nofollow">3.15 更换容器名</a></li><li><a href="#316__508" rel="nofollow">3.16 导出和导入</a></li><li><a href="#317__550" rel="nofollow">3.17 在容器和主机之间复制文件/文件夹</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_Docker__1"></a>1. Docker 基础命令</h2> 
<h3><a id="11__docker_2"></a>1.1 启动 docker</h3> 
<pre><code class="prism language-shell">systemctl start <span class="token function">docker</span>
</code></pre> 
<h3><a id="12__docker_6"></a>1.2 关闭 docker</h3> 
<pre><code class="prism language-shell">systemctl stop <span class="token function">docker</span>
</code></pre> 
<h3><a id="13__docker_10"></a>1.3 重启 docker</h3> 
<pre><code class="prism language-shell">systemctl restart <span class="token function">docker</span>
</code></pre> 
<h3><a id="14__docker_14"></a>1.4 开机启动 docker</h3> 
<pre><code class="prism language-shell">systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>
</code></pre> 
<h3><a id="15__docker__18"></a>1.5 查看 docker 运行状态</h3> 
<pre><code class="prism language-shell">systemctl status <span class="token function">docker</span>
</code></pre> 
<ul><li>如果在运行中，输入命令后，会看到绿色的 <code>active</code>：</li></ul> 
<p><img src="https://images2.imgbox.com/38/c2/rBpsED5G_o.png" alt="在这里插入图片描述"></p> 
<ul><li>不再运行时，输入命令后，会发现绿色的 <code>active</code> 消失了，还会提示当前的 <code>docker</code> 状态是 <code>inactive（dead）</code>（死亡）：</li></ul> 
<p><img src="https://images2.imgbox.com/27/ef/qwnJdR0c_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="16__docker__30"></a>1.6 查看 docker 版本信息</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> version
</code></pre> 
<p><img src="https://images2.imgbox.com/2e/17/Q5bQyAmq_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="17__docker__37"></a>1.7 查看 docker 系统信息，包括镜像和容器数</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> info
</code></pre> 
<p><img src="https://images2.imgbox.com/55/95/EHkEW6TS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="18_docker__44"></a>1.8 docker 帮助命令</h3> 
<ul><li>如果忘记了某些命令，可以输入如下命令：</li></ul> 
<pre><code class="prism language-shell'">docker --help
</code></pre> 
<p><img src="https://images2.imgbox.com/c0/01/VHXtqtYV_o.png" alt="在这里插入图片描述"></p> 
<ul><li>如果忘记了某个特定命令，比如说忘记了拉取命令，则可以输入如下指令：</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull --help
</code></pre> 
<p><img src="https://images2.imgbox.com/c0/1d/XXPhGopd_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_Docker__60"></a>2. Docker 镜像命令</h2> 
<h3><a id="21__docker__61"></a>2.1 查看自己服务器中 docker 镜像列表</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> images
<span class="token comment"># 或</span>
<span class="token function">docker</span> image <span class="token function">ls</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/4b/38/mHMizfEl_o.png" alt="在这里插入图片描述"></p> 
<ul><li>查看镜像、容器、数据卷所占用的空间：</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> system <span class="token function">df</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/dd/af/1YFsL7EY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22__78"></a>2.2 搜索镜像</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> search <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span>
</code></pre> 
<ul><li>比如可以输入这样的命令：<code>docker search --filter=STARS=9000 mysql</code>：</li></ul> 
<p><img src="https://images2.imgbox.com/62/5a/9goJXz8r_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23__Docker__87"></a>2.3 拉取镜像（从 Docker 镜像仓库获取镜像）</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span>
<span class="token function">docker</span> pull <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span>:tag
</code></pre> 
<ul><li>不加 <code>tag</code>（版本号），即默认拉取 <code>docker</code> 仓库中该镜像的最新版本，相当于命令 <code>docker pull [镜像名]:latest</code>。比如说拉取最新版的 <code>mysql</code>，则可以输入如下命令：</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull mysql
</code></pre> 
<p><img src="https://images2.imgbox.com/21/86/Kmds7zCW_o.png" alt="在这里插入图片描述"></p> 
<ul><li>加 <code>tag</code>，则是拉取指定版本。比如说拉取 <code>mysql 5.7.30</code>，则可以输入如下命令：</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull mysql:5.7.30
</code></pre> 
<p><img src="https://images2.imgbox.com/ae/d2/nxIvBtKQ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24__108"></a>2.4 运行镜像</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span>
</code></pre> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span>:tag
</code></pre> 
<ul><li>例如拉取一个 <code>tomcat</code> ，运行以下命令：</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run tomcat
</code></pre> 
<p><img src="https://images2.imgbox.com/51/29/GoNZYeb9_o.png" alt="在这里插入图片描述"></p> 
<p>可以使用 <code>Ctrl+c</code> 退出。</p> 
<ul><li>下面用实例解释:几个参数：</li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。</span>
<span class="token comment"># 这里打算进入 bash 执行一些命令并查看返回结果，因此需要交互式终端。</span>

<span class="token comment"># --rm：这个参数的意思是，容器退出后随之将其删除。默认情况下，除了排障需求，退出的容器并不会立即删除，除非手动 docker rm。</span>
<span class="token comment"># 这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。</span>

<span class="token comment"># ubuntu:18.04：这里指用 ubuntu:18.04 镜像为基础来启动容器。</span>

<span class="token comment"># bash：放在镜像名后的是命令，这里希望有个交互式 Shell，因此用的是 bash。</span>
<span class="token function">docker</span> run -it --rm ubuntu:18.04 <span class="token function">bash</span>
</code></pre> 
<div></div> 
<h3><a id="25__145"></a>2.5 删除镜像</h3> 
<ul><li>当前镜像没有被任何容器使用才可以删除。</li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># 删除一个镜像</span>
<span class="token function">docker</span> rmi -f 镜像名/镜像ID

<span class="token comment"># 删除多个镜像：其镜像ID或镜像用空格隔开即可</span>
<span class="token function">docker</span> rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID

<span class="token comment"># 删除全部镜像：-a 意思为显示全部，-q 意思为只显示ID</span>
<span class="token function">docker</span> rmi -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images -aq<span class="token variable">)</span></span>
</code></pre> 
<pre><code class="prism language-shell"><span class="token comment"># 删除所有仓库名为 redis 的镜像</span>
<span class="token function">docker</span> image <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> image <span class="token function">ls</span> -q redis<span class="token variable">)</span></span>

<span class="token comment"># 删除所有在 mongo:3.2 之前的镜像</span>
<span class="token function">docker</span> image <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> image <span class="token function">ls</span> -q -f <span class="token assign-left variable">before</span><span class="token operator">=</span>mongo:3.2<span class="token variable">)</span></span>
</code></pre> 
<ul><li>强制删除镜像：</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> image <span class="token function">rm</span> 镜像名/镜像ID
</code></pre> 
<div></div> 
<h3><a id="26__178"></a>2.6 保存镜像</h3> 
<ul><li>可以将我们的镜像保存为 <code>tar</code> 压缩文件，这样方便镜像转移和保存，然后，可以在任何一台安装了 <code>docker</code> 的服务器上加载这个镜像。</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> save 镜像名/镜像ID -o 镜像要保存的位置和名字
</code></pre> 
<p>例如：<code>docker save tomcat -o /myimg.tar</code></p> 
<p>保存镜像任务执行完毕，我们可以看一下指定位置是否有该 <code>tar</code> ：</p> 
<p><img src="https://images2.imgbox.com/be/79/5ejGhKcU_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="27__193"></a>2.7 加载镜像</h3> 
<ul><li>任何装 <code>docker</code> 的地方加载镜像保存文件，使其恢复为一个镜像。</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> load -i 镜像保存文件位置
</code></pre> 
<p>可以先将之前的 <code>tomcat</code> 镜像删除掉，因为一开始就已经保存了：</p> 
<p><img src="https://images2.imgbox.com/77/d5/jdobWH1Y_o.png" alt="在这里插入图片描述"></p> 
<p>查看镜像，测试镜像功能是否正常。</p> 
<p>我们可以把解压的镜像 <code>run</code> 一下：</p> 
<p><img src="https://images2.imgbox.com/49/d0/9esAIsYN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="28__213"></a>2.8 镜像标签</h3> 
<ul><li>有时候，我们需要对一个镜像进行分类或版本迭代操作。比如一个微服务已经打为 <code>docker</code> 标签，但是根据环境进行区分为 <code>develop</code> 环境与 <code>alpha</code> 环境，这时候，我们就可以使用 <code>tag</code> ，来对镜像做一个标签添加，从而进行区分；版本迭代逻辑也一样，根据不同的 <code>tag</code> 进行区分。</li><li>注：<code>develop</code>：开发环境。 <code>alpha</code>：用于进行初步测试和验证的环境，常常是在软件开发的早期阶段使用。</li></ul> 
<pre><code class="prism language-shell'">app:1.0.0 基础镜像

# 分离为开发环境
app:develop-1.0.0

# 分离为 alpha 环境
app:alpha-1.0.0
</code></pre> 
<pre><code class="prism language-shell"><span class="token function">docker</span> tag SOURCE_IMAGE<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span> TARGET_IMAGE<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span>
<span class="token function">docker</span> tag 源镜像名<span class="token punctuation">;</span>TAG 想要生成新的镜像名:新的TAG

<span class="token comment"># 如果省略 TAG，则会为镜像默认打上 latest TAG</span>
<span class="token function">docker</span> tag aaa bbb

<span class="token comment"># 上面的操作等价于下面这行语句</span>
<span class="token function">docker</span> tag aaa:latest bbb:latest
</code></pre> 
<p>举例如下：</p> 
<pre><code class="prism language-shell"><span class="token comment"># 我们根据镜像 quay.io/minio/minio 添加一个新的镜像，名为 aaa，标签 Tag 设置为 1.2.3</span>
<span class="token function">docker</span> tag quay.io/minio/minio:1.2.3 aaa:1.2.3

<span class="token comment"># 我们根据镜像 app-user:1.0.0 添加一个新的镜像，名为 app-user，标签 Tag 设置为 alpha-1.0.0</span>
<span class="token function">docker</span> tag app-user:1.0.0 app-user:alpha-1.0.0
</code></pre> 
<div></div> 
<h2><a id="3_Docker__253"></a>3. Docker 容器命令</h2> 
<p>注：我是这样理解 <code>docker</code> 容器的：可以将它类比于 C++ 中 <code>new</code> 出来的对象（<code>docker run 镜像</code> ：产生一个该镜像具体容器实例），<code>docker</code> 容器的启动需要镜像的支持。</p> 
<ul><li>每一个 <code>docker</code> 容器都是独立和安全的应用平台。可以理解为：每一个 <code>docker</code> 容器都相当于在我们的服务器上占用资源然后开辟了属于自己的一个空间（也可以理解为服务器）。</li></ul> 
<p><img src="https://images2.imgbox.com/f8/4b/X1jZREA0_o.png" alt="img"></p> 
<p>这也是 <code>docker</code> 的一大特点，每个容器之间，环境都是隔离的。</p> 
<p>我们甚至可以在一个服务器上，使用 <code>docker</code> 镜像，来跑出 n 个 <code>mysql</code> 实例。尽管它们的默认端口都是一样的，但容器间，环境是隔离的，A 容器的 3306 与 B 容器的 3306 毫无关系。</p> 
<ul><li>默认情况下，我们是无法通过宿主机（安装 <code>docker</code> 的服务器）端口来直接访问容器的，因为 <code>docker</code> 容器自己开辟空间的端口与宿主机端口没有联系。</li><li>如果外部想要访问容器，那必须得让容器中的端口与宿主机的端口建立联系绑定起来，这个概念叫做 <strong>容器端口映射</strong>。有了端口映射，我们就可以将宿主机端口和容器端口绑定起来，比如我们建立宿主机的 6379 端口与容器 <code>redis</code> 6379 端口绑定起来，那么再访问宿主机 ip:6379 就可以访问到对应容器了。</li><li>容器端口与服务器端口映射的命令：</li></ul> 
<pre><code class="prism language-shell">-p 宿主机端口:容器端口
</code></pre> 
<div></div> 
<h3><a id="31__275"></a>3.1 查看正在运行容器列表</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">ps</span>
<span class="token comment"># 或</span>
<span class="token function">docker</span> container <span class="token function">ls</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c8/ac/xLfvvWjN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="32__285"></a>3.2 查看所有容器</h3> 
<ul><li>包含正在运行的和已停止的。</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">ps</span> -a
</code></pre> 
<p><img src="https://images2.imgbox.com/7c/7c/ZHinJ7Jm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="33__295"></a>3.3 运行容器</h3> 
<pre><code class="prism language-shell"><span class="token comment"># -it：表示与容器进行交互式启动</span>
<span class="token comment"># -d：表示可后台运行容器（守护式运行）</span>
<span class="token comment"># --name：要给运行的容器起的名字</span>
<span class="token comment"># /bin/bash：交互路径</span>
<span class="token function">docker</span> run -it -d --name 要取的别名 镜像名:tag /bin/bash
</code></pre> 
<p>举例：我们要启动一个 <code>redis</code> ，把它的别名取为 <code>redis001</code>，并交互运行，命令如下（这里指定版本号为 5.0.5）：</p> 
<pre><code class="prism language-shell"><span class="token comment"># 1. 拉取 redis 镜像</span>
<span class="token function">docker</span> pull redis:5.0.5

<span class="token comment"># 2. 命令启动</span>
<span class="token function">docker</span> run -it -d --name redis001 redis:5.0.5 /bin/bash

<span class="token comment"># 3. 查看已运行容器</span>
<span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/22/c4/kX1OAswd_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="34__320"></a>3.4 停止容器</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> stop 容器名/容器ID
</code></pre> 
<p>例如：停止之前运行的 <code>redis</code> 容器，就可以输入这样的命令：<code>docker stop redis001</code>：</p> 
<p><img src="https://images2.imgbox.com/6f/6c/PU5hIWtd_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="35__331"></a>3.5 删除容器</h3> 
<pre><code class="prism language-shell"><span class="token comment"># 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</span>

<span class="token comment"># 删除一个容器</span>
<span class="token function">docker</span> <span class="token function">rm</span> -f 容器名/容器ID

<span class="token comment">#删除多个容器：空格隔开要删除的 容器名/容器ID</span>
<span class="token function">docker</span> <span class="token function">rm</span> -f 容器名/容器ID 容器名/容器ID 容器名/容器ID

<span class="token comment"># 删除全部容器</span>
<span class="token function">docker</span> <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -aq<span class="token variable">)</span></span>

<span class="token comment"># 清除所有处于终止状态的容器</span>
<span class="token function">docker</span> container prune
</code></pre> 
<p><img src="https://images2.imgbox.com/b6/59/GGhaxrBt_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="36__352"></a>3.6 容器端口与服务器端口映射</h3> 
<pre><code class="prism language-shell">-p 宿主机端口:容器端口
</code></pre> 
<p>举例：可以使用前面的 <code>redis</code> 镜像，尝试将 6379 端口映射到服务器的 8888，如果成功的话，那么访问服务器的 8888 端口，就会访问到 <code>docker</code> 中的容器 <code>redis002</code>。可以输入下面这条命令：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -itd --name redis002 -p <span class="token number">8888</span>:6379 redis:5.0.5 /bin/bash
</code></pre> 
<ul><li><code>-p 8888:6379</code> 解析：将容器内部的 6379 端口与 <code>docker</code> 宿主机（<code>docker</code> 安装在哪台服务器，哪台服务器就是宿主机）8888 端口进行映射，那通过外部访问宿主机 8888 端口，即可访问到 <code>docker</code> 容器 6379 端口了。</li></ul> 
<p><img src="https://images2.imgbox.com/93/c8/IugUZvvy_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-shell"><span class="token comment"># netstat 是控制命令，是一个监控 TCP/IP 网络的非常有用的工具，它可以显示路由器，实际的网络连接以及每一个网络接口设备的状态信息</span>
<span class="token function">netstat</span> -untlp
</code></pre> 
<ul><li>容器端口映射的限制：虽然说每个容器之间，环境都是隔离的，但是宿主机每个端口都是一个。8888 端口被 <code>redis002</code> 容器绑定了，那么其它所有的容器都不可以使用 8888 这个端口了。</li></ul> 
<h3><a id="37__376"></a>3.7 进入容器</h3> 
<ul><li>进入容器方式 1：</li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># 只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然仍然可以返回。</span>
<span class="token comment"># 当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 容器名/容器ID /bin/bash
</code></pre> 
<p>举例 1：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -dit ubuntu
<span class="token function">docker</span> container <span class="token function">ls</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> -i ddf <span class="token function">bash</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it ddf <span class="token function">bash</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/57/73/FzUhqbWN_o.png" alt="在这里插入图片描述"></p> 
<p>举例 2：进入前面的 <code>redis001</code> 容器，就可以输入命令 <code>docker exec -it redis001 /bin/bash</code>。</p> 
<p><img src="https://images2.imgbox.com/cb/09/kWrAlvwg_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到，已经从主机 <code>yangbaqiaun</code> 跳到了容器 ID 对应下的 <code>/data</code> ，已经进入到容器内部了。</p> 
<ul><li>进入容器方式 2：</li></ul> 
<pre><code class="prism language-shell'">docker attach 容器名/容器ID
</code></pre> 
<p>举例：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -dit ubuntu
<span class="token function">docker</span> container <span class="token function">ls</span>
<span class="token function">docker</span> attach 12e
</code></pre> 
<p><img src="https://images2.imgbox.com/e3/06/Bh4bpVwS_o.png" alt="在这里插入图片描述"></p> 
<ul><li>以上两种进入容器的方式，推荐使用第一种 <code>exec</code> 方式。</li></ul> 
<h3><a id="38__423"></a>3.8 从容器内退出到自己的服务器</h3> 
<pre><code class="prism language-shell"><span class="token comment"># 1. 直接退出：未添加-d（持久化运行容器）时，执行此参数容器会被关闭</span>
<span class="token builtin class-name">exit</span>

<span class="token comment"># 2. 无论是否添加 -d 参数，执行此命令，容器都不会被关闭</span>
从键盘按下：Ctrl + p + q
</code></pre> 
<h3><a id="39__433"></a>3.9 启动容器</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> start 容器名/容器ID
</code></pre> 
<h3><a id="310__439"></a>3.10 重启容器</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> restart 容器名/容器ID
</code></pre> 
<h3><a id="311_kill__444"></a>3.11 kill 容器</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">kill</span> 容器名/容器ID
</code></pre> 
<h3><a id="312__449"></a>3.12 容器文件拷贝</h3> 
<ul><li>无论容器是否开启，都可以进行拷贝。</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">cp</span> 容器ID/名称：文件路径 要拷贝到外部的路径 <span class="token operator">|</span> 要拷贝到外部的路径 容器ID/名称：文件路径

<span class="token comment"># 从容器内拷出</span>
<span class="token function">docker</span> <span class="token function">cp</span> 容器ID/名称：容器内路径 容器外路径

<span class="token comment"># 从外部拷贝文件到容器内</span>
<span class="token function">docker</span> <span class="token function">cp</span> 容器外路径 容器ID/名称：容器内路径
</code></pre> 
<h3><a id="313__462"></a>3.13 查看容器日志</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> logs -f --tail<span class="token operator">=</span>要查看末尾多少行 默认all 容器ID
</code></pre> 
<h3><a id="314__466"></a>3.14 设置开机自动启动容器</h3> 
<ul><li>启动容器时，使用 <code>docker run</code> 命令时，添加参数 <code>--restart=always</code> 便表示该容器随 <code>docker</code> 服务启动而自动启动。</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -itd --name redis002 -p <span class="token number">8888</span>:6379 --restart<span class="token operator">=</span>always  redis:5.0.5 /bin/bash
</code></pre> 
<p>防止数据丢失的两种方法：</p> 
<ul><li>方法 1：数据挂载：简单来讲，就是将容器内的数据与外部宿主机文件绑定起来，类似一个双持久化，当容器删除时，宿主机文件数据目录仍在，下次启动容器只要将数据目录指向宿主机数据所在位置即可恢复。</li></ul> 
<pre><code class="prism language-shell">-v 宿主机文件存储位置:容器内文件位置
</code></pre> 
<p>如此操作，就将容器内指定文件挂载到了宿主机对应位置，<code>-v</code> 命令可以多次使用，即一个容器可以同时挂载多个文件。</p> 
<pre><code class="prism language-shell">-v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置
</code></pre> 
<p>举例：</p> 
<pre><code class="prism language-shell"><span class="token comment"># 运行一个 docker redis 容器 进行 端口映射 两个数据卷挂载 设置开机自启动</span>
<span class="token function">docker</span> run -d -p <span class="token number">6379</span>:6379 --name redis505 --restart<span class="token operator">=</span>always  -v /var/lib/redis/data/:/data -v /var/lib/redis/conf/:/usr/local/etc/redis/redis.conf  redis:5.0.5 --requirepass <span class="token string">"password"</span>
</code></pre> 
<ul><li>方法 2：不想删容器，又想让这个容器设置开机自启动，那么我们修改其启动配置即可。</li></ul> 
<pre><code class="prism language-shell"><span class="token function">docker</span>  update --restart<span class="token operator">=</span>always 容器Id/容器名
<span class="token comment"># 或</span>
<span class="token function">docker</span> container update --restart<span class="token operator">=</span>always 容器Id/容器名
</code></pre> 
<h3><a id="315__501"></a>3.15 更换容器名</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">rename</span> 容器ID/容器名 新容器名
</code></pre> 
<p><img src="https://images2.imgbox.com/63/3b/GysjEdJr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="316__508"></a>3.16 导出和导入</h3> 
<ul><li>导出容器</li></ul> 
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p> 
<p>举例：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> container <span class="token function">ls</span> -a
<span class="token function">docker</span> <span class="token builtin class-name">export</span> ddfc038b5dc2 <span class="token operator">&gt;</span> ubuntu.tar
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/08/7lxW6Lfp_o.png" alt="在这里插入图片描述"></p> 
<p>这样将导出容器快照到本地文件。</p> 
<ul><li>导入容器快照</li></ul> 
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像。</p> 
<p>举例：</p> 
<pre><code class="prism language-shell"><span class="token function">cat</span> ubuntu.tar <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> - test/ubuntu:v1.0
<span class="token function">docker</span> image <span class="token function">ls</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2f/54/2gjDRtpW_o.png" alt="在这里插入图片描述"></p> 
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">import</span> http://example.com/exampleimage.tgz example/imagerepo
</code></pre> 
<p>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p> 
<div></div> 
<h3><a id="317__550"></a>3.17 在容器和主机之间复制文件/文件夹</h3> 
<ul><li>语法格式</li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># 从容器里面拷文件到宿主机</span>
<span class="token function">docker</span> <span class="token function">cp</span> 容器名:要拷贝的文件在容器里面的路径   要拷贝到宿主机的相应路径
</code></pre> 
<p>举例：<code>docker cp project:/opt/cdc.txt /home/</code></p> 
<pre><code class="prism language-shell"><span class="token comment"># 从宿主机拷文件到容器里面</span>
<span class="token function">docker</span> <span class="token function">cp</span> 要拷贝的文件路径 容器名:要拷贝到容器里面对应的路径
</code></pre> 
<p>举例：<code>docker cp /home/ccc.txt project:/opt/</code></p> 
<p>【注意】：不管容器有没有启动，拷贝命令都会生效。如果拷贝的内容有重复，会直接覆盖，不会询问。</p> 
<p>另一种：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">cp</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER:SRC_PATH DEST_PATH<span class="token operator">|</span>-
<span class="token function">docker</span> <span class="token function">cp</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> SRC_PATH<span class="token operator">|</span>- CONTAINER:DEST_PATH
<span class="token comment"># option：-L，保持源目标中的链接</span>
</code></pre> 
<ul><li>SRC_PATH 和 DEST_PATH 说明：</li></ul> 
<ol><li>SRC_PATH 指定一个文件，若 DEST_PATH 不存在，创建 DEST_PATH 所需的文件夹，文件正常保存到 DEST_PATH 中。</li><li>若 DEST_PATH 不存在，并以 / 结尾<br> 错误：目标目录必须存在</li><li>若 DEST_PATH 存在并且是一个文件，目标被源文件的内容覆盖。</li><li>若 DEST_PATH 存在并且是目录，使用 SRC_PATH 中的基本名称将文件复制到此目录中。</li><li>SRC_PATH 指定目录，若 DEST_PATH 不存在，将 DEST_PATH 创建为目录，并将源目录的内容复制到该目录中。</li><li>若 DEST_PATH 存在并且是一个文件<br> 错误：无法将目录复制到文件</li><li>若 DEST_PATH 存在并且是目录，SRC_PATH 不以 <code>/.</code> 结尾，源目录复制到此目录；SRC_PATH 以 <code>/.</code> 结尾，源目录的内容被复制到该目录中。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a7666d72aa75bab741ce2288dcaf933/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Navicat 备份和恢复MongoDB库的数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c26e9de7f8ed5182ee6c6330868dc88d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Kibana的对索引库的操作(1)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>