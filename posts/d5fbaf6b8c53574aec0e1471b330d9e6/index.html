<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker的前世今生 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker的前世今生" />
<meta property="og:description" content="1. Docker介绍 1.1什么是容器? 简单地说，一个容器包含了完整的运行时环境：除了应用程序本身之外，这个应用所需的全部依赖、类库、其他二进制文件、配置文件等，都统一被打入了一个称为容器镜像的包中。通过将应用程序本身，和其依赖容器化，操作系统发行版本和其他基础环境造成的差异，都被抽象掉了。
1.2容器的前世 FreeBASE jail ------&gt; Linux vserver
chroot -----&gt; 完整的根文件系统(FHS)标准的
namespaces — &gt; UTS Mount IPC PID user network
cgroup —&gt; 资源的分配和监控;
通过比较复杂的代码开发的过程,调用以上三项技术
实现容器的创建----&gt;管理----&gt;销毁
1.3传统虚拟化技术和容器对比 首先，Container技术和服务器虚拟化并不是一样的技术：
两者虽然都属于虚拟化的技术，目标都是为了将一套应用程序所需的执行环境打包起来，建立一个孤立环境，方便在不同的硬件中移动，但两者的运作思维截然不同。
简单来说，传统虚拟化技术如vSphere或Hyper-V是以操作系统为中心，而Container技术则是一种以应用程序为中心的虚拟化技术。
传统虚拟化技术从操作系统层下手，目标是建立一个可以用来执行整套操作系统的沙盒独立执行环境，习惯以虚拟机(Virtual Machine)来称呼。Container技术则是直接将一个应用程序所需的相关程序代码、函式库、环境配置文件都打包起来建立沙盒执行环境，Container技术产生的环境就称为Container。
两者具体区别
​​​​​​​虚拟机需要安装操作系统(安装Guest OS)才能执行应用程序，而Container内不需要安装操作系统就能执行应用程序
Container技术不是在OS外来建立虚拟环境，而是在OS内的核心系统层来打造虚拟执行环境，透过共享Host OS的作法，取代一个一个Guest OS的功用。Container也因此被称为是OS层的虚拟化技术。
Container是轻量级虚拟化技术
​​​​​​​Container技术采取共享Host OS的作法，而不需在每一个Container内执行Guest OS，因此建立Container不需要等待操作系统开机时间，不用1分钟或几秒钟就可以启用，远比需要数分钟甚至数十分钟才能开启的传统虚拟机来的快。
Container技术的发展
早在1982年，Unix系统内建的chroot机制也是一种Container技术。其他如1998年的FreeBSD jails、2005年出现的Solaris Zones和OpenVZ，或像是Windows系统2004年就有的Sandboxie机制都属于在操作系统内建立孤立虚拟执行环境的作法，都可称为是Container的技术。直到2013年，dotCloud这家PaaS服务公司开源释出了一套将Container标准化的平台Docker，大受欢迎，所以，dotCloud决定以Docker为名成立新公司力推。
1.4容器的今生? 实现隔离能力!
LXC (LinuXContainer)
对于原有的常用功能进行了封装,方便我们做容器的生命周期
-----&gt; Docker ( dotc1oud)
2. Docker的安装 2.1 Docker的安装 yum install -y yum-utils device-mapper-persistent-data lvm2
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d5fbaf6b8c53574aec0e1471b330d9e6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-29T22:38:40+08:00" />
<meta property="article:modified_time" content="2020-09-29T22:38:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker的前世今生</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_Docker_0"></a>1. Docker介绍</h2> 
<h3><a id="11_1"></a>1.1什么是容器?</h3> 
<p>简单地说，一个容器包含了完整的运行时环境：除了应用程序本身之外，这个应用所需的全部依赖、类库、其他二进制文件、配置文件等，都统一被打入了一个称为容器镜像的包中。通过将应用程序本身，和其依赖容器化，操作系统发行版本和其他基础环境造成的差异，都被抽象掉了。</p> 
<h3><a id="12_3"></a>1.2容器的前世</h3> 
<p>FreeBASE jail ------&gt; Linux vserver<br> chroot -----&gt; 完整的根文件系统(FHS)标准的<br> namespaces — &gt; UTS Mount IPC PID user network<br> cgroup —&gt; 资源的分配和监控;<br> 通过比较复杂的代码开发的过程,调用以上三项技术<br> 实现容器的创建----&gt;管理----&gt;销毁</p> 
<h3><a id="13_10"></a>1.3传统虚拟化技术和容器对比</h3> 
<p>首先，Container技术和服务器虚拟化并不是一样的技术：</p> 
<p>两者虽然都属于虚拟化的技术，目标都是为了将一套应用程序所需的执行环境打包起来，建立一个孤立环境，方便在不同的硬件中移动，但两者的运作思维截然不同。</p> 
<p>简单来说，传统虚拟化技术如vSphere或Hyper-V是以操作系统为中心，而Container技术则是一种以应用程序为中心的虚拟化技术。</p> 
<p>传统虚拟化技术从操作系统层下手，目标是建立一个可以用来执行整套操作系统的沙盒独立执行环境，习惯以虚拟机(Virtual Machine)来称呼。Container技术则是直接将一个应用程序所需的相关程序代码、函式库、环境配置文件都打包起来建立沙盒执行环境，Container技术产生的环境就称为Container。</p> 
<p>两者具体区别</p> 
<ul><li> <p>​​​​​​​虚拟机需要安装操作系统(安装Guest OS)才能执行应用程序，而Container内不需要安装操作系统就能执行应用程序<br> Container技术不是在OS外来建立虚拟环境，而是在OS内的核心系统层来打造虚拟执行环境，透过共享Host OS的作法，取代一个一个Guest OS的功用。Container也因此被称为是OS层的虚拟化技术。</p> </li><li> <p>Container是轻量级虚拟化技术<br> ​​​​​​​Container技术采取共享Host OS的作法，而不需在每一个Container内执行Guest OS，因此建立Container不需要等待操作系统开机时间，不用1分钟或几秒钟就可以启用，远比需要数分钟甚至数十分钟才能开启的传统虚拟机来的快。</p> </li><li> <p>Container技术的发展<br> 早在1982年，Unix系统内建的chroot机制也是一种Container技术。其他如1998年的FreeBSD jails、2005年出现的Solaris Zones和OpenVZ，或像是Windows系统2004年就有的Sandboxie机制都属于在操作系统内建立孤立虚拟执行环境的作法，都可称为是Container的技术。直到2013年，dotCloud这家PaaS服务公司开源释出了一套将Container标准化的平台Docker，大受欢迎，所以，dotCloud决定以Docker为名成立新公司力推。</p> </li></ul> 
<h3><a id="14_28"></a>1.4容器的今生?</h3> 
<p>实现隔离能力!<br> LXC (LinuXContainer)<br> 对于原有的常用功能进行了封装,方便我们做容器的生命周期<br> -----&gt; Docker ( dotc1oud)</p> 
<h2><a id="2_Docker_34"></a>2. Docker的安装</h2> 
<h3><a id="21_Docker_35"></a>2.1 Docker的安装</h3> 
<p>yum install -y yum-utils device-mapper-persistent-data lvm2</p> 
<p>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</p> 
<p>yum -y install docker-ce</p> 
<h3><a id="22_Docker_42"></a>2.2 Docker服务阿里云镜像加速</h3> 
<p>vim /etc/docker/daemon.json</p> 
<pre><code>{
  "registry-mirrors": ["https://wixr7yss.mirror.aliyuncs.com"]
}
</code></pre> 
<p>systemctl daemon-reload<br> systemctl restart docker</p> 
<h3><a id="23_Docker_52"></a>2.3 启动Docker服务</h3> 
<p>systemctl daemon- reload<br> systemctl restart docker<br> docker version<br> docker info</p> 
<h2><a id="3Docker_58"></a>3.Docker的镜像基础管理</h2> 
<h3><a id="31_59"></a>3.1获取镜像</h3> 
<p>基础镜像拉取<br> docker search centos<br> docker pull centos:6.9<br> docker pull centos:7.5 .1804<br> docker pull nginx</p> 
<h3><a id="32_65"></a>3.2镜像基本查看</h3> 
<p>[rootadocker ~]# docker image ls<br> REPOSITORY TAG IMAGE ID CREATED SIZE<br> centos 6.8 82f3b5f3c58f 4 months ago 195 MB<br> oldguo/centos_ sshd v1 .0<br> oldguo/centos sshd v2 .0<br> o1dguo/centos sshd v3 .0<br> 标识镜像唯一性的方法:</p> 
<ol><li>REPOSITORY :TAG<br> centos7.5 :1804<br> 2.IMAGEID(sha256:64位的号码,默认只截取12位)<br> 82f3b5f3c58</li></ol> 
<h3><a id="33_77"></a>3.3镜像详细信息查看</h3> 
<p>[root@docker /]# docker image inspect ubuntu:latest<br> [root@docker /]# docker image inspect 82f3b5f3c58f</p> 
<h3><a id="34ID_80"></a>3.4只查看镜像ID</h3> 
<p>[root@docker ~] # docker image ls -q</p> 
<h3><a id="35_82"></a>3.5镜像的导入和导出</h3> 
<p>[root@docker ~]# docker image save 3556258649b2 &gt; /tmp/ubu.tar<br> [root@docker ~]# docker image rm 3556258649b2<br> [root@docker ~] # docker image load - i / tmp/ubu.tar<br> [root@docker ~] # docker image tag 3556258649b2 oldguo/ubu :v1</p> 
<h3><a id="36_87"></a>3.6镜像的删除</h3> 
<p>[root@docker ~] # docker image rm -f 3556258649b2<br> [root@docker ~]# docker image rm -f <code>docker image ls -q</code></p> 
<h2><a id="5_91"></a>5.容器的管理</h2> 
<h3><a id="51_92"></a>5.1运行第一个容器</h3> 
<p>交互式的容器:<br> [root@docker ~]# docker container run -it 9f38484d220f<br> [root@docker /]# docker container ls<br> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br> ecdb2cff1cd9 7e6257c9f8d8 “/bin/bash” 56 minutes ago Up 56 minutes centos</p> 
<p>CONTAINERID:容器的唯一号码(自动生成的)<br> NAMES : 容器的名字(可以自动,也可以手工指定)<br> [root@docker /]# docker container run -it --name=" cent7" 9f38484d220f<br> [root@docker /]# docker container ls -a<br> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br> 2f8e05e764de 295c7be07902 “nginx -g 'daemon of…” 56 minutes ago Exited (0) 56 minutes ago nginx<br> ecdb2cff1cd9 7e6257c9f8d8 “/bin/bash” 57 minutes ago Up 57 minutes centos<br> b3f39b603415 688353a31fde “/bin/bash” 2 hours ago Exited (0) About an hour ago centos-ansible<br> 1c45f487e201 3a5f278e66df “/usr/bin/supervisor…” 3 hours ago Exited (0) 2 hours ago centos7<br> b6c37edfe400 0d120b6ccaa8 “/bin/bash” 3 hours ago Exited (0) About an hour ago upbeat_wright<br> a633dd0a7877 0d120b6ccaa8 “/bin/bash” 3 hours ago Exited (0) 3 hours ago determined_ganguly</p> 
<p>容器的运行状态( Exited ，Up)</p> 
<h2><a id="5_114"></a>5.容器的管理</h2> 
<h3><a id="51_115"></a>5.1运行第一个容器</h3> 
<h4><a id="511_116"></a>5.1.1交互式的容器:</h4> 
<p>[root@docker ~]# docker container run -it 9f38484d220f<br> [root@ docker /]# docker container ls<br> CONTAINER ID TMAGE COMMAND CREATED STATUS PORTS<br> 4d1ef5a6ecfc 9f38484d220f “/bin/bash" 5 minutes ago Up 5 minutes nervous_ alle</p> 
<p>CONTAINERID:容器的唯一号码(自动生成的)<br> NAMES:容器的名字(可以自动,也可以手工指定)<br> 例子:手工指定容器名启动<br> [root@docker /]# docker container run -it --name= =“cent7” 9f38484d220f<br> [root@docker /]# docker container ls -a</p> 
<h4><a id="512_127"></a>5.1.2守护式容器</h4> 
<p>[root@docker /]# docker run -d --name= “nginx” nginx:1.14<br> 查询容器的详细信息:<br> [root@ docker /]# docker container inspect nginx</p> 
<h4><a id="513_132"></a>5.1.3容器的应用场景</h4> 
<p>交互式的容器:工具类:开发,测试，临时性的任务()<br> [root@ docker ~]# docker container run -it --name=cent76 --rm 9f38484d220f<br> 守护式容器:网络服务<br> [root@docker /]# docker run -d -p 8080:80 --name= =“nginx_80” nginx :1.14<br> ###5.1.4容器的启动\关闭\连接<br> 守护式容器的关闭和启动<br> [root@ docker /]# docker container stop nginx_80<br> [root@ docker /]# docker container start nginx_80<br> 交互式的容器的关闭和启动<br> [root@ docker /]# docker container stop nervous_ al1en<br> [root@ docker /]# docker container start -i nervous_ allen<br> 容器的连接方法:<br> [root@ docker /]# docker container attach centos<br> 子进程的方式登录(在己有工作容器中生成子进程,做登录,可以进行容器的调试,退出时也不会影响到当前容器)<br> [root@ docker ~]# docker container exec -it nervous_allen /bin/bash</p> 
<p>容器的后台及前台运行:<br> 1.ctr1+P，Q<br> attach调用到前台<br> 2.死循环<br> 3.让程序前台一直允许(夯在前台)</p> 
<h3><a id="52docker_155"></a>5.2docker容器的网络访问</h3> 
<p>指定映射(docker会自动添加一条iptables规则来实现端口映射)<br> -p hostport:containerPort<br> -p ip:hostPort:containerPort<br> -P ip: :containerPort(随机端口:32768-60999)<br> -p hostPort:containerPort/udp<br> -p 81:80 -p 443 :443<br> dockerrun-P80(随机端口)<br> [root@ docker ~]# docker container run -d -p 8080:80 --name = 'n2 ’ nginx:1.14<br> [root@ docker ~]# docker container run -d -p 10 .0.0.100 :8081:80 --name= 'n3 ’ nginx:1.14<br> [root@ docker ~]# docker container run -d -P 80 - -name= 'n5 ’ nginx:1 .14<br> [root@ docker ~]# docker container run -d -p 172.16.1.200: :80 - -name= 'n6 ’ nginx:1.14</p> 
<h3><a id="53_168"></a>5.3容器的其他管理</h3> 
<p>docker ps- -a -q<br> 等价于:<br> docker container ls -a -q<br> [root@ docker ~]# docker top ba9143bcaf74<br> 等价于:<br> [root@ docker ~]# docker container top ba9143bcaf74<br> 查看日志:<br> [root@ oldboy docker]# docker logs testxx<br> [root@ oldboy docker]# docker logs -tf testxx<br> [root@ oldboy docker]# docker logs -t testxx<br> [root@ oldboy docker]# docker logs -tf --tail 10 testxx<br> [root@ oldboy docker]# docker logs -tf --tail 0 testxx</p> 
<p>小结:<br> 1.镜像类:<br> docker image<br> search<br> pull<br> ls ★★★★★<br> inspect ★★★★★<br> rm ★★★★<br> save<br> load<br> 2.容器类<br> docker container <br> run ★★★★★<br> start ★★★★<br> stop ★★★★<br> restart<br> kil<br> attach<br> exec ★★★★★<br> ls ★★★★★<br> top ★★★★<br> logs<br> inspect ★★★★</p> 
<h3><a id="54docker_206"></a>5.4docker的数据卷实现持久化存储</h3> 
<h3><a id="54docker_208"></a>5.4docker的数据卷实现持久化存储</h3> 
<p>1.手工交互数据:<br> [root@docker opt]# docker container cp index.html n1:/usr/share/nginx/htm1/<br> [root@docker opt]# docker container cp n1:/usr/share/nginx/htm1/50x.html ./<br> 2.volume实现宿主机和容器的数据共享<br> [root@ docker opt]# mkdir -p /opt/html<br> [root@ docker ~]# docker run -d --name= “nginx_3” -p 83:80 -v /opt/html:/usr/share/nginx/html nginx<br> 作用:数据持久化<br> 3.例子:开启两个nginx容器(90,91),共同挂载-一个数据卷,实现静态资源共享<br> 4.数据卷容器:<br> (1)宿主机模拟数据目录<br> mkdir -p /opt/volume/a<br> mkdir -p /opt/volume/b<br> touch /opt/volume/a/a.txt<br> touch /opt/volume/b/b.txt<br> (2)启动数据卷容器<br> docker run -it --name “httpd_volumes” -v /opt/Volume/a:/opt/a -v /opt/volume/b:/opt/b centos:6.9 /bin/bash<br> ctrl p q<br> (3)使用数据卷容器<br> docker run -d -p 8085:80 --volumes-from httpd_volumes --name “n8085" nginx<br> docker run -d -p 8086:80 --volumes-from httpd_volumes --name “n8086" nginx<br> 作用:在集中管理集群中，大批量的容器都需要挂载相同的多个数据卷时,可以采用数卷容器进行统一管理</p> 
<h2><a id="6_231"></a>6.镜像制作</h2> 
<h3><a id="61_232"></a>6.1基于容器的镜像制作</h3> 
<h4><a id="611__ECS_233"></a>6.1.1 启动基础镜像容器 (ECS实现)</h4> 
<p>docker run -it --name=“oldguo_ centos” centos :6.9</p> 
<h4><a id="612__235"></a>6.1.2 安装所需要的软件包，并且启动测试</h4> 
<p>mv /etc/yum.repos.d/* .repo /tmp<br> echo -e "[ftp] \nname= =ftp\nbaseur1=ftp://172.17.0.1/ centos6.9\ngpgcheck=0”&gt;/etc/yum.repos.d/ftp.repo<br> yum makecache fast &amp;&amp; yum install openssh-server -y<br> /etc/init.d/sshd start -----&gt;重要:ssh第一次启动时,需要生成秘钥,生成pam验证配置文件<br> /etc/init.d/sshd stop<br> echo “123456” | passwd root --stdin</p> 
<h4><a id="613__242"></a>6.1.3 镜像的制作</h4> 
<p>docker<br> commit oldguo_ centos oldguo/centos6.9_sshd:v1</p> 
<h4><a id="614centos6_9sshd_245"></a>6.1.4基于新镜像启动容器实现，centos6 .9+sshd的功能</h4> 
<p>[root@docker ~]# docker container run -d --name=“sshd_2222” -p 2222:22 7c0d7daff04a /usr/sbin/sshd -D</p> 
<p>##7.2构建企业网站定制镜像 (Centos6.9_SSHD_LAMP_ BBS )</p> 
<h4><a id="621__249"></a>6.2.1 启动基础镜像容器</h4> 
<p>[root@ docker ~]# docker container rm -f `docker ps -a -q`<br> [root@ docker ~]# rm -rf /opt/*<br> [root@ docker ~]# mkdir -p /opt/vol/mysql /opt/vol/html<br> [root@ docker ~]# docker run -it --name= “oldguo_ centos_ bbs” -v /opt/vol/mysql :/var/lib/mysql -v /opt/vol/html:/var/www/html centos:6.9</p> 
<h3><a id="622yum_254"></a>6.2.2优化yum源并安装软件</h3> 
<p>mv /etc/yum.repos.d/*.repo /tmp<br> cho -e "[ftp] \nname=ftp\nbaseurl=ftp://172.17.0.1/centos6.9\ngpgcheck=0”&gt; /etc/yum.repos.d/ftp.repo<br> yum makecache fast &amp;&amp; yum install openssh-server httpd mysql-server mysql php php-mysql -y</p> 
<h4><a id="623_258"></a>6.2.3软件初始化</h4> 
<p>/etc/init.d/sshd start<br> /etc/init.d/sshd stop<br> echo “123456” | passwd root --stdin</p> 
<h4><a id="mysqld__263"></a>mysqld 初始化</h4> 
<p>[root@ c3fd597ec194 mysql]# /etc/init.d/mysqld start<br> mysql&gt; grant a11 on <em>.</em> to root@ ‘8’ identified by ‘123’;<br> mysql&gt; grant all on <em>.</em> to discuz@ ‘8’ identified by ‘123’ ;<br> mysql&gt; create database discuz charset utf8;</p> 
<h4><a id="apache_268"></a>apache初始化</h4> 
<p>[root! c3fd597ec194 mysql]# /etc/init.d/httpd start</p> 
<h3><a id="624_LAMP_270"></a>6.2.4 制作LAMP第一版基础镜像</h3> 
<p>[root@ docker mysql]# docker commit c3fd597ec194 oldguo/centos_ lamp:v1</p> 
<h3><a id="625__272"></a>6.2.5 根据第一版镜像，启动新容器</h3> 
<p>[root@docker ~]# docker run -it --name=“oldguo_centos_ bbs_v3” -v /opt/vol/mysql:/var/lib/mysql -v /opt/vol/html :/vax/www/html<br> -p 8080:80 1cd314cba420<br> [root@ f22496ebafaf /]# /etc/init.d/mysqld start<br> [root@ f22496ebafaf /]# /etc/init.d/httpd start</p> 
<h3><a id="626_php_277"></a>6.2.6 测试php功能</h3> 
<p>vim /var/www/html/index.php</p> &lt;?php phpinfo() ; ?&gt; 
<h4><a id="627_bbs_283"></a>6.2.7 安装bbs论坛</h4> 
<p>上传bbs代码到宿主机/opt/vol/html并解压<br> 安装</p> 
<h4><a id="628LAMPbbs_286"></a>6.2.8制作LAMP+bbs第二版镜像</h4> 
<p>[root@ docker ~]# docker commit oldguo_centos_ bbs_v3 oldguo/centos6.9 sshd_lamp_bbs:v1</p> 
<h4><a id="629__288"></a>6.2.9 创建启动脚本</h4> 
<p>[root@ docker html]# cd /opt/vol/html<br> [root@ docker html]# cat init.sh</p> 
<pre><code># !/bin/bash
/etc/init.d/mysqld start	
/etc/init.d/httpd start
/usr/sbin/sshd -D
</code></pre> 
<p>[root@docker html]# chmod 777 init.sh</p> 
<h4><a id="6210__299"></a>6.2.10 启动容器，映射端口，挂载数据卷，自动启动服务</h4> 
<p>[root@ docker html]# docker container run -d --name=“oldguoyun_lamp_bbs” -v /opt/vol/mysql:/var/lib/mysq1 -v /opt/vol/html:/var/www/html -p 22222:22 -p 8888:80 -p 33060:3306 ac8888ea3e21 /var/www/html/ init. sh</p> 
<h2><a id="63_centos751804_sshd_301"></a>6.3 centos:7.5.1804_sshd</h2> 
<h3><a id="631__302"></a>6.3.1 启容器</h3> 
<p>mv /etc/yum.repos.d/*.repo /tmp<br> echo -e "[ftp]\nname=ftp\nbaseurl=ftp://172 .17.0 .1/centos7.5\ngpgcheck=0”&gt;/etc/yum.repos.d/ftp.repo<br> yum makecache fast &amp;&amp; yum install openssh-server -y<br> mkdir /var/run/sshd<br> echo ‘UseDNS no’ &gt;&gt; /etc/ssh/sshd_config<br> sed -i -e ’ /pam_loginuid.so/d’ /etc/pam.d/sshd<br> echo ’ root:123456’ I chpasswd<br> /usr/bin/ssh-keygen -A<br> docker commit oldguo_c75sshd d2bcdbdfd0f8<br> [root@ docker ~]# docker container run -d --name=sshd_ 2222 -p 222:22 oldguo_c75sshd /usr/sbin/sshd -D</p> 
<h2><a id="7Dockerfile_314"></a>7.通过Dockerfile定制企业镜像</h2> 
<h3><a id="71_Dockerfilecentos69_sshd_315"></a>7.1 Dockerfile的基本使用初体验(centos6.9_sshd)</h3> 
<p>[root@ docker ~]# mkdir -p /opt/ dockerfile/centos6.9_sshd<br> [root@ docker centos6.9_ sshd]# vim Dockerfile</p> 
<pre><code># Centos6 .9 -SSHDv1.0
FROM centos@2199b8eb8390
RUN mv /etc/yum.repos.d/*.repo /tmp &amp;&amp; echo -e " [ftp]\nname=ftp\nbaseur1=ftp://172 .17.0.1/centos6. 9\ngpgcheck=0" &gt; /etc/yum.repos.d/ftp.repo &amp;&amp; yum makecache fast &amp;&amp; yum install openssh-server -y

RUN /etc/init.d/sshd start &amp;&amp; /etc/init.d/sshd stop &amp;&amp; echo "123456" I passwd root --stdin
CMD ["/usr/sbin/sshd", "-D"]
</code></pre> 
<ul><li> <p>FROM: 基础镜像<br> Syntax :<br> centos:6.9<br> centos@2199b8eb8390<br> RUN mv /etc/yum.repos.d/*.repo /tmp &amp;&amp; echo -e " [ftp]\nname=ftp\nbaseur1=ftp://172 .17.0.1/centos6. 9\ngpgcheck=0" &gt; /etc/yum.repos.d/ftp.repo &amp;&amp; yum makecache fast &amp;&amp; yum install openssh-server -y</p> </li><li> <p>RUN: 构建镜像过程中运行的命令<br> Syntax:<br> mv /etc/yum.repos.d/*.repo /tmp &amp;&amp; echo -e " [ftp]\nname=ftp\nbaseur1=ftp://172 .17.0.1/centos6. 9\ngpgcheck=0" &gt; /etc/yum.repos.d/ftp.repo &amp;&amp; yum makecache fast &amp;&amp; yum install openssh-server -y</p> <pre><code>  ["mysqld", "--initialize-insecure", "--user=mysql", "--basedir=/usr/local/mysql", "--datadir=/ data/mysql/data"] 
</code></pre> </li><li> <p>EXPOSE： 向外暴露端口<br> Syntax :<br> EXPOSE 22 暴露端口<br> EXPOSE 80</p> </li><li> <p>CMD 使用镜像启动容器时</p> </li></ul> 
<pre><code># CentOS6.9_sshd_LAMP

FROM centos:6.9
RUN mv /etc/yum.repos.d/*.repo /tmp &amp;&amp; echo -e "[ftp]\nname=ftp\nbaseurl=ftp://172.17.0.1/CentOS6.9\ngpgcheck=0" &gt; /etc/yum.repos.d/ftp.repo &amp;&amp; yum makecache fast &amp;&amp; yum install openssh-server httpd mysql-server mysql php php-mysql -y

RUN /etc/init.d/sshd start &amp;&amp; /etc/init.d/mysqld start &amp;&amp; /etc/init.d/httpd start &amp;&amp; echo "1" | passwd root --stdin

RUN mysql -e "grant all on \*.\* to root@'%' identified by '1';grant all on \*.\* to discuz@ '%' identified by '1';create database discuz charset utf8;"

COPY init.sh /

ADD bbs.tar.gz /var/www/html

EXPOSE 22
EXPOSE 80
EXPOSE 3306

CMD["/bin/bash","/init.sh"]
</code></pre> 
<p>init.sh脚本<br> [root@docker lamp]# cat init.sh</p> 
<pre><code>#!/bin/bash

/etc/init.d/mysqld start
/etc/init.d/httpd start
/usr/sbin/sshd -D
</code></pre> 
<h2><a id="73_376"></a>7.3通过例子学习其他指令</h2> 
<h3><a id="dockerfile_Lamp_377"></a>dockerfile 构建Lamp基础环境镜像</h3> 
<p>[root@ docker dockerfile]# mkdir -p /opt/dockerfile/lamp<br> [root@ docker dockerfile]# cd / opt/ dockerfile/lamp/<br> [root@ docker lamp]# vim Dockerfile</p> 
<pre><code># CentOS6.9_sshd_LAMP

FROM centos:6.9
RUN mv /etc/yum.repos.d/*.repo /tmp &amp;&amp; echo -e "[ftp]\nname=ftp\nbaseurl=ftp://172.17.0.1/CentOS6.9\ngpgcheck=0" &gt; /etc/yum.repos.d/ftp.repo &amp;&amp; yum makecache fast &amp;&amp; yum install openssh-server httpd mysql-server mysql php php-mysql -y

RUN /etc/init.d/sshd start &amp;&amp; /etc/init.d/mysqld start &amp;&amp; /etc/init.d/httpd start &amp;&amp; echo "1" | passwd root --stdin

COPY init.sh /

ADD bbs.tar.gz /var/www/html

EXPOSE 22
EXPOSE 80
EXPOSE 3306

CMD ["/bin/bash","/init.sh"]


 mv /etc/yum.repos.d/*.repo /tmp &amp;&amp; echo -e "[ftp]\nname=ftp\nbaseurl=ftp://172.17.0.1/CentOS6.9\ngpgcheck=0" &gt; /etc/yum.repos.d/ftp.repo &amp;&amp; yum makecache fast &amp;&amp; yum install openssh-server httpd mysql-server mysql php php-mysql -y
</code></pre> 
<ul><li> <p>Syntax:<br> &lt;src…&gt; <br> COPY index.php /var/www/html/<br> ADD bbs.tar.gz /var/www/html/<br> ADD https://mirrors.aliyun.com/centos/7.6.1810/os/x86_64/Packages/centos-bookmarks-7-1.e17.noarch.rpm /tmp</p> </li><li> <p>说明:<br> COPY命令:<br> Syntax :<br> … <br> 从dockerfile所在目录，拷贝目标文件到容器的制定目录下。<br> 可以支持统配符，如果拷贝的是目录，只拷贝目录下的子文件子目录。<br> cp yang/*<br> ADD命令<br> Syntax:<br> … <br> url </p> <p>比COPY命令多的功能是，可以自动解压.tar*的软件包到目标目录下可以指定源文件为URL地址</p> </li></ul> 
<p>VOLUME ["/var /www/html", “/data/mysql/data”] 自动挂载数据卷</p> 
<p>WORKDIR 切换到指定目录 不过以后执行的操作都在这个目录 可以使用RUN cd 来代替<br> ENV 在构建Dockerfile的时候来自定义环境变量<br> ENTRYPOINT 防止介入新的命令(手工输入命令替换掉CMD命令)，使容器down掉 和CMD作用类似</p> 
<h2><a id="8_Dockerregistry_429"></a>8. Docker构建私有registry</h2> 
<h3><a id="81_registry__430"></a>8.1 启动registry .</h3> 
<p>docker run -d -p 5000:5000 --restart=always --name=registry -v /opt/registry:/vax/lib/registry registry</p> 
<h3><a id="82__432"></a>8.2 修改配置文件</h3> 
<p>vim /etc/docker/daemon.json</p> 
<pre><code>"registry-mirrors": ["https://68rmyzg7.mirror.aliyuncs.com"] ,
"insecure-registries": ["172.16.69.145:5000"]
</code></pre> 
<p>[root@ docker docker]# systemctl restart docker<br> ##9.3制作本地镜像并push到镜像仓库<br> [root@ docker ~]# docker tag nginx 10.0.0.100:5000/oldguo/nginx:v1<br> [root@ docker ~]# docker images<br> [root@docker ~]# docker push 10.0.0.100:5000/oldguo/nginx:v1</p> 
<h3><a id="84pu11_444"></a>8.4异地进行pu11镜像</h3> 
<p>[root@ docker ~]# docker pull 10.0.0.100 :5000/oldguo/nginx:v1</p> 
<h3><a id="85_446"></a>8.5本地仓库加安全认证</h3> 
<p>生成密码:<br> yum install httpd-tools -y</p> 
<h3><a id="86registry_451"></a>8.6重新启动带有秘钥功能的registry容器</h3> 
<p>docker rm -f <code>docker ps -aq</code><br> docker run -d -p 5000:5000 -v /opt/registry-auth/:/auth/ -v /opt/registry:/var/lib/registry --name register-auth -e “REGISTRY_AUTH=htpasswd” -e “REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm” -e “REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd” registry</p> 
<h3><a id="87pushlogin_455"></a>8.7push镜像,需要进行login</h3> 
<p>[root@oldboy ~]# docker login 10.0.0.100:5000<br> Username: yang<br> Password: 123</p> 
<h3><a id="haborregister_460"></a>habor实现图形化register</h3> 
<p>第一步：安装docker和docker-compose<br> yum install -y docker-compose<br> 第二步：下载harbor-offline-installer-vxxx.tgz<br> 第三步：上传到/opt,并解压<br> 第四步：修改harbor.cfg配置文件<br> hostname = 10.0.0.11<br> harbor_admin_password = 123456<br> 第五步：执行install.sh</p> 
<p>2.使用方法:<br> 修改各个节点的docker配置文件<br> {<!-- --><br> "registry-mirrors ": [“https:/uoggbpok.mirror.aliyuncs.com”] ,<br> “insecure-registries”: [“172.16.69.145:5000”, “172.16.69.145”] ,<br> “live-restore”: true<br> }<br> systemctl restart docker</p> 
<p>3.在habor中添加项目<br> 4.制作镜像并上传habor<br> [root@ docker harbor]# docker tag centos:6.9 172.16.69.145/oldguo/centos:v1<br> [root@ docker harbor]# docker login 172.16.69.145:5000<br> [root@ docker harbor]# docker push 172.16.69.145:5000/yang/centos:v1<br> 5.在节点中pullhabor中的鏡像<br> docker pull 10.0.0.100:5000/oldguo/centos:v1</p> 
<ol><li>Docker本地网络类型<br> 1.1查看支持网络类型<br> docker network ls<br> 1.2 测试使用各类网络类型<br> docker run network=xxx<br> none : 无网络模式<br> bridge ： 默认模式，相当于NAT<br> host : 公用宿主机Network NameSapce<br> container：与其他容器公用Network Namespace</li><li>Docker跨主机网络介绍<br> macvlan<br> overlay</li><li>Docker跨主机访问-macvlan实现<br> docker network create --driver macvlan --subnet=172.16.69.0/24 --gateway=172.16.69.254 -o parent=ens37 macvlan_1</li></ol> 
<p>docker run -it --network macvlan_1 --ip=172.16.69.2 centos:6.9 /bin/bash</p> 
<p>ip link set eth0 promsic on (ubuntu或其他版本需要)</p> 
<ol start="4"><li>Docker 跨主机访问-overlay实现<br> docker run -d -p 8500:8500 -h consul --name consul progrium/consul -server -bootstrap</li></ol> 
<p>consul：kv类型的存储数据库（key:value）<br> docker01、02上：<br> vim /etc/docker/daemon.json<br> {<!-- --><br> “hosts”:[“tcp://0.0.0.0:2376”,“unix:///var/run/docker.sock”],<br> “cluster-store”: “consul://172.16.69.145:8500”,<br> “cluster-advertise”: “172.16.69.145:2376”<br> }<br> docker01<br> vim /usr/lib/systemd/system/docker.service<br> 把ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock改为下面<br> ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2376 -H unix:///var/run/docker.sock --cluster-store consul://172.16.69.145:8500 --cluster-advertise 172.16.69.145:2376<br> docker02<br> vim /usr/lib/systemd/system/docker.service<br> 把ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock改为下面<br> ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2376 -H unix:///var/run/docker.sock --cluster-store consul://172.16.69.145:8500 --cluster-advertise 172.16.69.152:2376</p> 
<p>-H来允许远程主机连接<br> –cluster-store指定consul的地址<br> –cluster-advertise告知consul自己的连接地址</p> 
<p>systemctl daemon-reload<br> systemctl restart docker</p> 
<p>2）创建overlay网络<br> docker network create -d overlay --subnet 172.16.0.0/24 --gateway 172.16.0.254 ol1</p> 
<p>3）两边启动容器测试<br> docker run -it --network ol1 --name oldboy01 busybox /bin/bash<br> 每个容器有两块网卡,eth0实现容器间的通讯,eth1实现容器访问外网<br> 4 docker企业级镜像仓库harbor(vmware 中国团队)<br> 第一步：安装docker和docker-compose<br> 第二步：下载harbor-offline-installer-v1.x.x.tgz<br> 第三步：上传到/opt,并解压<br> 第四步：修改harbor.cfg配置文件<br> hostname = 10.0.0.101<br> harbor_admin_password = 123456<br> 第五步：执行install.sh</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9498f7bb1d63f9ecc5bad1bb90c5994f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">批处理之for /f</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5638f02612cedf6c59a4aeddbdd2587a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">/ 和/* 和/**的区别(特别是对于请求路径和文件路径的问题)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>