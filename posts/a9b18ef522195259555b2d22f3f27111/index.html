<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>洛谷入门题基础算法知识笔记 基础算法笔记 算法知识储备 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="洛谷入门题基础算法知识笔记 基础算法笔记 算法知识储备" />
<meta property="og:description" content="22年1月算法笔记
文章目录 RE&amp;&amp;WA错误排列组合Scanner特殊符号printf大小写字母转换数据类型的转化integer.toString和String.valueOf的区别 char类型转化为int类型char转化为Strng String与int互相转换Int-----&gt;String（4种方法）String----&gt;Int (2种) 设置小数点位数 &amp;&amp; 有效数字方法一：String.foramt(&#34;%.f&#34;,d)方法二：使用DecimalFormat类方法三：方法四：浮点型强制转型（int）等于向下取整 格式化数字“001”科学计数法算数平方根数组集合排序基本数据类型的默认值：sort(一)给数组{2，3，1，5}按自小到大排序(二)把数组从大到小排序 Sort对数组升序降序 集合集合反转 数组标法记某个数出现的次数把ArrayList转换成普通数组大数字精度问题BigInteger、BigDecimal 字符串删除字符串 求最大公约数检测代码运行时间求最小值质数判断&amp;&amp;数字反转数字反转2质数判断数字反转 Math类的常用方法HashSet不重复集合Map遍历方法Map综合利用求集合出现最多次数 截取字符串&amp;&amp;替换字符串substring（） 方法截取v字符串 替换字符串中的片段替换字符串中的一个字符拆分字符串split()split() 方法根据匹配给定的正则表达式来 字符串反转&amp;&amp;字符串拆分判断字符串开头结尾indexOf函数两种用法计算某字符串中特定字符串出现次数的几种算法利用indexOf()方法出现次数 = (原字符串长度 - 替换后字符串长度) / 目标子串长度indexOf()方法 搭配 subString()方法 在指定位置拼接和插入字符串末尾插入位置插入字符后插入 String [StringBuffer](https://so.csdn.net/so/search?q=StringBuffer&amp;spm=1001.2101.3001.7020) StringBuilder 转换正则正则表达式中的 .*? 或 .*&#43; 或.* HashSet不重复集合 标题算法学习前的初步了解java知识集合学习Maphashmap遍历 1.随机数2.转义符3.substring（） 方法截取v字符串4.判断两个对象是否等价5.随机数控制概率6.toCharArray（） 获取字符串的每个字符7.BigInterger操作大数8.Math类的常用方法9.HashSet不重复集合10.长度不固定数组11.把ArrayList数组转换成普通数组12.替换字符串中的片段13.替换字符串中的一个字符14、科学计数法15、split() 方法根据匹配给定的正则表达式来拆分字符串16、将数值转化为字符串17、测试运行时间18、compareTo()方法比较字符串19、hasNextInt()判断控制台是否输入数字20、char型数字转为int型21、Scanner资源关闭22、array排列数组23、String与int互相转换Int-----&gt;String（4种方法）String----&gt;Int (2种) 24、Calendar 的用法25、indexOf() 方法26、scanner接受char类型字符27、正则表达式匹配字符串28、答案输出为txt文件（简化try/catch）29、进制转换30、java.util.Collections.ncopies()方法31、String.join()拼装字符串32、String.contains()用法34、两次回车结束运行 算法方法1.二分法查找2.冒泡排序查找 Typora加超链接实现页内跳转的三种方法_AZZJXHDSGIRL的博客-CSDN博客_typora超链接怎么用
RE&amp;&amp;WA错误 1.数组开太小
2.数组开太大
3.出现了除以0
4.算法不够优化
排列组合 有顺序用排列
无顺序用组合
Scanner String num = sc.nextLine(); String[] arr = num.split(&#34; &#34;); 以空格为分割，存到数组中 特殊符号 0为false 1为true" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a9b18ef522195259555b2d22f3f27111/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-16T10:48:54+08:00" />
<meta property="article:modified_time" content="2022-02-16T10:48:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">洛谷入门题基础算法知识笔记 基础算法笔记 算法知识储备</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>22年1月算法笔记<br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#REWA_4" rel="nofollow">RE&amp;&amp;WA错误</a></li><li><ul><li><a href="#_10" rel="nofollow">排列组合</a></li><li><a href="#Scanner_16" rel="nofollow">Scanner</a></li><li><a href="#_23" rel="nofollow">特殊符号</a></li><li><a href="#printf_35" rel="nofollow">printf</a></li><li><a href="#_43" rel="nofollow">大小写字母转换</a></li><li><a href="#_52" rel="nofollow">数据类型的转化</a></li><li><ul><li><ul><li><a href="#integertoStringStringvalueOf_54" rel="nofollow">integer.toString和String.valueOf的区别</a></li></ul> 
     </li><li><a href="#charint_71" rel="nofollow">char类型转化为int类型</a></li><li><ul><li><a href="#charStrng_89" rel="nofollow">char转化为Strng</a></li></ul> 
    </li></ul> 
    </li><li><a href="#Stringint_115" rel="nofollow">String与int互相转换</a></li><li><ul><li><ul><li><a href="#IntString4_117" rel="nofollow">Int-----&gt;String（4种方法）</a></li><li><a href="#StringInt_2_132" rel="nofollow">String----&gt;Int (2种)</a></li></ul> 
    </li></ul> 
    </li><li><a href="#___153" rel="nofollow">设置小数点位数 &amp;&amp; 有效数字</a></li><li><ul><li><ul><li><ul><li><a href="#Stringforamtfd_155" rel="nofollow">方法一：String.foramt("%.f",d)</a></li><li><a href="#DecimalFormat_161" rel="nofollow">方法二：使用DecimalFormat类</a></li><li><a href="#_175" rel="nofollow">方法三：</a></li><li><a href="#_184" rel="nofollow">方法四：</a></li><li><a href="#int_196" rel="nofollow">浮点型强制转型（int）等于向下取整</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#001_198" rel="nofollow">格式化数字“001”</a></li><li><a href="#_206" rel="nofollow">科学计数法</a></li><li><a href="#_220" rel="nofollow">算数平方根</a></li><li><a href="#_231" rel="nofollow">数组集合排序</a></li><li><ul><li><ul><li><a href="#_233" rel="nofollow">基本数据类型的默认值：</a></li><li><a href="#sort_243" rel="nofollow">sort</a></li><li><ul><li><a href="#2315_247" rel="nofollow">(一)给数组{2，3，1，5}按自小到大排序</a></li><li><a href="#_271" rel="nofollow">(二)把数组从大到小排序</a></li></ul> 
      </li><li><a href="#Sort_304" rel="nofollow">Sort对数组</a></li><li><ul><li><a href="#_306" rel="nofollow">升序</a></li><li><a href="#_334" rel="nofollow">降序</a></li></ul> 
      </li><li><a href="#_350" rel="nofollow">集合</a></li><li><ul><li><a href="#_369" rel="nofollow">集合反转</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#_375" rel="nofollow">数组标法记某个数出现的次数</a></li><li><a href="#ArrayList_453" rel="nofollow">把ArrayList转换成普通数组</a></li><li><a href="#_461" rel="nofollow">大数字精度问题</a></li><li><ul><li><ul><li><a href="#BigIntegerBigDecimal_463" rel="nofollow">BigInteger、BigDecimal</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_557" rel="nofollow">字符串</a></li><li><ul><li><ul><li><a href="#_559" rel="nofollow">删除字符串</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_572" rel="nofollow">求最大公约数</a></li><li><a href="#_586" rel="nofollow">检测代码运行时间</a></li><li><a href="#_599" rel="nofollow">求最小值</a></li><li><a href="#_609" rel="nofollow">质数判断&amp;&amp;数字反转</a></li><li><ul><li><ul><li><a href="#2_693" rel="nofollow">数字反转2</a></li><li><a href="#_714" rel="nofollow">质数判断</a></li><li><a href="#_737" rel="nofollow">数字反转</a></li></ul> 
    </li></ul> 
    </li><li><a href="#Math_752" rel="nofollow">Math类的常用方法</a></li><li><a href="#HashSet_764" rel="nofollow">HashSet不重复集合</a></li><li><a href="#Map_775" rel="nofollow">Map遍历方法</a></li><li><ul><li><ul><li><a href="#Map_804" rel="nofollow">Map综合利用求集合出现最多次数</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_854" rel="nofollow">截取字符串&amp;&amp;替换字符串</a></li><li><ul><li><ul><li><a href="#substring_v_856" rel="nofollow">substring（） 方法截取v字符串</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_863" rel="nofollow">替换字符串中的片段</a></li><li><a href="#_870" rel="nofollow">替换字符串中的一个字符</a></li><li><a href="#split_877" rel="nofollow">拆分字符串split()</a></li><li><ul><li><ul><li><a href="#split__879" rel="nofollow">split() 方法根据匹配给定的正则表达式来</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_922" rel="nofollow">字符串反转&amp;&amp;字符串拆分</a></li><li><a href="#_965" rel="nofollow">判断字符串开头结尾</a></li><li><a href="#indexOf_969" rel="nofollow">indexOf函数两种用法</a></li><li><a href="#_974" rel="nofollow">计算某字符串中特定字符串出现次数的几种算法</a></li><li><ul><li><ul><li><ul><li><a href="#indexOf_976" rel="nofollow">利用indexOf()方法</a></li><li><a href="#_______1005" rel="nofollow">出现次数 = (原字符串长度 - 替换后字符串长度) / 目标子串长度</a></li><li><a href="#indexOf__subString_1024" rel="nofollow">indexOf()方法 搭配 subString()方法</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#_1031" rel="nofollow">在指定位置拼接和插入字符串</a></li><li><ul><li><ul><li><ul><li><a href="#_1035" rel="nofollow">末尾插入</a></li><li><a href="#_1042" rel="nofollow">位置插入</a></li><li><a href="#_1050" rel="nofollow">字符后插入</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#String_StringBufferhttpssocsdnnetsosearchqStringBufferspm1001210130017020_StringBuilder__1058" rel="nofollow">String [StringBuffer](https://so.csdn.net/so/search?q=StringBuffer&amp;spm=1001.2101.3001.7020) StringBuilder 转换</a></li><li><a href="#_1090" rel="nofollow">正则</a></li><li><ul><li><ul><li><a href="#_____1104" rel="nofollow">正则表达式中的 .*? 或 .*+ 或.*</a></li></ul> 
    </li></ul> 
    </li><li><a href="#HashSet_1144" rel="nofollow">HashSet不重复集合</a></li></ul> 
   </li><li><a href="#_1157" rel="nofollow">标题算法学习前的初步了解</a></li><li><a href="#java_1160" rel="nofollow">java知识</a></li><li><ul><li><a href="#_1164" rel="nofollow">集合学习</a></li><li><ul><li><a href="#Map_1166" rel="nofollow">Map</a></li><li><ul><li><ul><li><a href="#hashmap_1172" rel="nofollow">hashmap遍历</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#1_1178" rel="nofollow">1.随机数</a></li><li><a href="#2_1184" rel="nofollow">2.转义符</a></li><li><a href="#3substring_v_1189" rel="nofollow">3.substring（） 方法截取v字符串</a></li><li><a href="#4_1196" rel="nofollow">4.判断两个对象是否等价</a></li><li><a href="#5_1202" rel="nofollow">5.随机数控制概率</a></li><li><a href="#6toCharArray__1212" rel="nofollow">6.toCharArray（） 获取字符串的每个字符</a></li><li><a href="#7BigInterger_1219" rel="nofollow">7.BigInterger操作大数</a></li><li><a href="#8Math_1225" rel="nofollow">8.Math类的常用方法</a></li><li><a href="#9HashSet_1237" rel="nofollow">9.HashSet不重复集合</a></li><li><a href="#10_1248" rel="nofollow">10.长度不固定数组</a></li><li><a href="#11ArrayList_1256" rel="nofollow">11.把ArrayList数组转换成普通数组</a></li><li><a href="#12_1264" rel="nofollow">12.替换字符串中的片段</a></li><li><a href="#13_1271" rel="nofollow">13.替换字符串中的一个字符</a></li><li><a href="#14_1278" rel="nofollow">14、科学计数法</a></li><li><a href="#15split__1292" rel="nofollow">15、split() 方法根据匹配给定的正则表达式来拆分字符串</a></li><li><a href="#16_1306" rel="nofollow">16、将数值转化为字符串</a></li><li><a href="#17_1312" rel="nofollow">17、测试运行时间</a></li><li><a href="#18compareTo_1324" rel="nofollow">18、compareTo()方法比较字符串</a></li><li><a href="#19hasNextInt_1338" rel="nofollow">19、hasNextInt()判断控制台是否输入数字</a></li><li><a href="#20charint_1348" rel="nofollow">20、char型数字转为int型</a></li><li><a href="#21Scanner_1355" rel="nofollow">21、Scanner资源关闭</a></li><li><a href="#22array_1366" rel="nofollow">22、array排列数组</a></li><li><a href="#23Stringint_1370" rel="nofollow">23、String与int互相转换</a></li><li><ul><li><ul><li><a href="#IntString4_1372" rel="nofollow">Int-----&gt;String（4种方法）</a></li><li><a href="#StringInt_2_1387" rel="nofollow">String----&gt;Int (2种)</a></li></ul> 
    </li></ul> 
    </li><li><a href="#24Calendar__1398" rel="nofollow">24、Calendar 的用法</a></li><li><a href="#25indexOf__1426" rel="nofollow">25、indexOf() 方法</a></li><li><a href="#26scannerchar_1451" rel="nofollow">26、scanner接受char类型字符</a></li><li><a href="#27_1462" rel="nofollow">27、正则表达式匹配字符串</a></li><li><a href="#28txttrycatch_1472" rel="nofollow">28、答案输出为txt文件（简化try/catch）</a></li><li><a href="#29_1481" rel="nofollow">29、进制转换</a></li><li><a href="#30javautilCollectionsncopies_1486" rel="nofollow">30、java.util.Collections.ncopies()方法</a></li><li><a href="#31Stringjoin_1508" rel="nofollow">31、String.join()拼装字符串</a></li><li><a href="#32Stringcontains_1524" rel="nofollow">32、String.contains()用法</a></li><li><a href="#34_1544" rel="nofollow">34、两次回车结束运行</a></li></ul> 
   </li><li><a href="#_1559" rel="nofollow">算法方法</a></li><li><ul><li><a href="#1_1561" rel="nofollow">1.二分法查找</a></li><li><a href="#2_1694" rel="nofollow">2.冒泡排序查找</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><a href="https://blog.csdn.net/AZZJXHDSGIRL/article/details/120754835?spm=1001.2014.3001.5502">Typora加超链接实现页内跳转的三种方法_AZZJXHDSGIRL的博客-CSDN博客_typora超链接怎么用</a></p> 
<h3><a id="REWA_4"></a>RE&amp;&amp;WA错误</h3> 
<p>1.数组开太小<br> 2.数组开太大<br> 3.出现了除以0<br> 4.算法不够优化<br> <img src="https://images2.imgbox.com/6d/07/7AiNs9gL_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_10"></a>排列组合</h4> 
<p>有顺序用排列<br> <img src="https://images2.imgbox.com/52/7e/37ghawFA_o.png" alt="在这里插入图片描述"><br> 无顺序用组合<br> <img src="https://images2.imgbox.com/27/4f/NF2vN03x_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Scanner_16"></a>Scanner</h4> 
<pre><code>		String num = sc.nextLine();
		String[] arr = num.split(" ");
		以空格为分割，存到数组中
</code></pre> 
<h4><a id="_23"></a>特殊符号</h4> 
<p>0为false 1为true</p> 
<pre><code>|=：两个二进制对应位都为0时，结果等于0，否则结果等于1；

&amp;=：两个二进制的对应位都为1时，结果为1，否则结果等于0；

^=：两个二进制的对应位相同，结果为0，否则结果为1。
</code></pre> 
<h4><a id="printf_35"></a>printf</h4> 
<p><a href="https://wenku.baidu.com/view/e2e9a279f4335a8102d276a20029bd64783e62b4.html" rel="nofollow">Java中printf()方法的用法 - 百度文库 (baidu.com)</a></p> 
<pre><code>printf（“%3d\t”）  输出一个整数定长为3字符的整数，按右对齐输出，在输出一个tab位
</code></pre> 
<h4><a id="_43"></a>大小写字母转换</h4> 
<pre><code>大写转小写   a.toLowerCase();
小写转大写   a.toUpperCase();
</code></pre> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J698s43Q-1642942908813)(22年1月算法笔记.assets/image-20220110153534267.png)]</p> 
<h4><a id="_52"></a>数据类型的转化</h4> 
<h6><a id="integertoStringStringvalueOf_54"></a>integer.toString和String.valueOf的区别</h6> 
<pre><code>通过源码,可以看到区别在于 当转换的obj==null的时候

Integer.toString() 会报空指针异常(NullPointerException)
String.valueOf()则会返回 “null” 字符串(return (obj == null) ? "null" : obj.toString();)
</code></pre> 
<pre><code>Float.toString(m);    //转化为字符串 
Float.parseFloat(b);  //转化为基本数据类型
(float)a;             //基本数据间的转化
Integer.parseInt(String.valueOf(arr[i])))    //char转化为int
char c=63;   //int类型转化为char（自动转化）  char c=(char)63  
</code></pre> 
<h5><a id="charint_71"></a>char类型转化为int类型</h5> 
<pre><code>char ch = '9';
if (Character.isDigit(ch)){  // 判断是否是数字
	int num = Integer.parseInt(String.valueOf(ch));
	System.out.println(num);
}	
</code></pre> 
<pre><code>char ch = '9';
if (Character.isDigit(ch)){  // 判断是否是数字
	int num = (int)ch - (int)('0');
	System.out.println(num);
}
</code></pre> 
<h6><a id="charStrng_89"></a>char转化为Strng</h6> 
<pre><code>public static void main(String[] args) {
		// char to string
		char c = 'a';
		String str = String.valueOf(c);
 
		// using Character class
		str = Character.toString(c);
 
		// another way
		str = new Character(c).toString();
		// string concatenation - worst performance
		str = "" + c;
		
		// char array to string
		char[] ca = { 'a', 'b', 'c' };
		str = String.valueOf(ca);
		// recommended way
		str = new String(ca);
	}
</code></pre> 
<h4><a id="Stringint_115"></a>String与int互相转换</h4> 
<h6><a id="IntString4_117"></a>Int-----&gt;String（4种方法）</h6> 
<pre><code>int num=100;
//1
String s1=""+num;
//2
String s2 =String.valueOf(num);   (Double.valueOf 转化为Double类型)
//3
Integer i =new Integer(num);
String s3 =i.toString();
//4
String s4 =Integer.toString(i);
</code></pre> 
<h6><a id="StringInt_2_132"></a>String----&gt;Int (2种)</h6> 
<pre><code>String s="100";
//1
Integer ii =new Integer(s);
int x=ii.intValue();
//2
int y = Integer.parseInt(s);
</code></pre> 
<p><strong>String—&gt;long</strong></p> 
<pre><code>long l = Long.parseLong([String],[int radix]);
long l = Long.valueOf(“123”).longValue();
区别：
Long.ValueOf(“String”)返回Long包装类型
Long.parseLong(“String”)返回long基本数据类型
</code></pre> 
<h4><a id="___153"></a>设置小数点位数 &amp;&amp; 有效数字</h4> 
<h6><a id="Stringforamtfd_155"></a>方法一：String.foramt("%.f",d)</h6> 
<pre><code>double d=6.235;
String s=String.format("%.2f", d);
System.out.println(s);
//输出：6.24，说明已经进行四舍五入了。
</code></pre> 
<h6><a id="DecimalFormat_161"></a>方法二：使用DecimalFormat类</h6> 
<pre><code>import java.text.DecimalFormat;
...
double d=6.345;

DecimalFormant df=new DecimalFormant("0.00");
System.out.println(df.formant(d));
//输出：6.34    进行四舍五入

...
</code></pre> 
<h6><a id="_175"></a>方法三：</h6> 
<pre><code>  double f = 12345.67890;
  BigDecimal bg = new BigDecimal(f);
  double f1 = bg.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();
  System.out.println(f1);
</code></pre> 
<h6><a id="_184"></a>方法四：</h6> 
<pre><code>	double f = 12345.67890;
	NumberFormat nf = NumberFormat.getNumberInstance();
    nf.setMaximumFractionDigits(2);
    System.out.println(nf.format(f));//12,345.68
</code></pre> 
<p>空格不能用"\t"<br> <img src="https://images2.imgbox.com/02/3b/ZOQaIlyG_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="int_196"></a>浮点型强制转型（int）等于向下取整</h6> 
<h4><a id="001_198"></a>格式化数字“001”</h4> 
<pre><code>DecimalFormat df1 = new DecimalFormat("000");//如果小于100就用他

String emNum = df1.format(1);//结果就是001
</code></pre> 
<h4><a id="_206"></a>科学计数法</h4> 
<pre><code>//科学计数法数字转普通数字
        double num1 = 50123.12E25;
        BigDecimal bd1 = new BigDecimal(num1);
        System.out.println(bd1.toPlainString());
//普通数字转科学计数法
        double num2 = 50123.12;
        BigDecimal bd2 = new BigDecimal(num2);
        System.out.println(bd2.toPlainString()); //法一
        System.out.println(String.format("%.6E",num2)); //法二
</code></pre> 
<h4><a id="_220"></a>算数平方根</h4> 
<pre><code>java.lang.Math.sqrt(double a)
</code></pre> 
<pre><code>向上取整用Math.ceil(double a) -----&gt;ceil天花板
向下取整用Math.floor(double a) -----&gt;floor地板
</code></pre> 
<h4><a id="_231"></a>数组集合排序</h4> 
<h6><a id="_233"></a>基本数据类型的默认值：</h6> 
<p>①byte short int long 这四种基本数据类型数组默认值为0</p> 
<p>②float double 这两种数组默认值是0.0</p> 
<p>③char这种类型数组默认值为空格</p> 
<p>④boolean类型数组默认值为false</p> 
<h6><a id="sort_243"></a>sort</h6> 
<p>在java.util.Collections类中有个sort()方法，主要是用来给数组排序，排序的规则可以自己重写。</p> 
<h6><a id="2315_247"></a>(一)给数组{2，3，1，5}按自小到大排序</h6> 
<pre><code>

public class Main{
public static void main(String[] args){
ArrayList list=new ArrayList&lt;&gt;();
list.add(2);
list.add(3);
list.add(1);
list.add(5);

Collections.sort(list);

for(Integer i:list)
System.out.print(i+" ");

}
}
输出结果为：
1 2 3 5
</code></pre> 
<h6><a id="_271"></a>(二)把数组从大到小排序</h6> 
<pre><code>public static void main(String[] args){
ArrayList list=new ArrayList&lt;&gt;();
list.add(2);
list.add(3);
list.add(1);
list.add(5);

Collections.sort(list,new Comparator() {
@Override

public int compare(Integer o1, Integer o2) {
if(o1&gt;o2)
return -1;
else if(o1
return 1;
else
return 0;
}
});

for(Integer i:list)

System.out.print(i+" ");
}

结果为：

5 3 2 1
</code></pre> 
<h6><a id="Sort_304"></a>Sort对数组</h6> 
<h6><a id="_306"></a>升序</h6> 
<p>使用 java.util.Arrays 类中的 sort() 方法对数组进行升序分为以下两步：</p> 
<ol><li>导入 java.util.Arrays 包。</li><li>使用 Arrays.sort(数组名) 语法对数组进行排序，排序规则是从小到大，即升序。</li></ol> 
<pre><code>public static void main(String[] args) {
    // 定义含有5个元素的数组
    double[] scores = new double[] { 78, 45, 85, 97, 87 };
    System.out.println("排序前数组内容如下：");
    // 对scores数组进行循环遍历
    for (int i = 0; i &lt; scores.length; i++) {
        System.out.print(scores[i] + "\t");
    }
    System.out.println("\n排序后的数组内容如下：");
    // 对数组进行排序
    Arrays.sort(scores);
    // 遍历排序后的数组
    for (int j = 0; j &lt; scores.length; j++) {
        System.out.print(scores[j] + "\t");
    }
}
排序后的数组内容如下：
45.0    78.0    85.0    87.0    97.0
</code></pre> 
<h6><a id="_334"></a>降序</h6> 
<p>1）利用 Collections.reverseOrder() 方法（Collections 是一个包装类。《<a href="http://c.biancheng.net/view/6884.html" rel="nofollow">Java Collections类</a>》一节详细了解）：</p> 
<pre><code>public static void main(String[] args) {
    Integer[] a = { 9, 8, 7, 2, 3, 4, 1, 0, 6, 5 };    // 数组类型为Integer
    Arrays.sort(a, Collections.reverseOrder());
    for (int arr : a) {
        System.out.print(arr + " ");
    }
}
输出结果如下：
9 8 7 6 5 4 3 2 1 0 
</code></pre> 
<h6><a id="_350"></a>集合</h6> 
<pre><code>    public static void main(String[] args){

        ArrayList list=new ArrayList&lt;&gt;();
        list.add(2);
        list.add(3);
        list.add(1);
        list.add(5);
        
		Collections.sort(list);//从小到大
        Collections.sort(list,Collections.reverseOrder());//从大到小
        for (Object o : list) {
            System.out.print(o+" ");
        }
    }
</code></pre> 
<h6><a id="_369"></a>集合反转</h6> 
<pre><code>Collections.reverse(arr);
</code></pre> 
<h4><a id="_375"></a>数组标法记某个数出现的次数</h4> 
<p><a href="#Map%E7%BB%BC%E5%90%88%E5%88%A9%E7%94%A8%E6%B1%82%E9%9B%86%E5%90%88%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E6%AC%A1%E6%95%B0" rel="nofollow">Map法记某个数出现的次数</a></p> 
<pre><code>import java.util.Scanner;
//梦中的婚礼
public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int M = input.nextInt(), N = input.nextInt();
        int[] num = new int[10];
        for (int i = M; i &lt;= N; i++)
            for (int temp = i; temp != 0; temp /= 10)
                num[temp%10]++;
        for (int i = 0; i &lt; 10; i++) {
            System.out.print(num[i] + " ");
        }
    }
}

public class p1554梦中的统计 {
public static void main(String[] args) {
	Scanner rd =new Scanner(System.in);
	int a = rd.nextInt();  //小的
	int b = rd.nextInt();  //大的
    int t = b - a;
    int arr [] = new int [10];   //存0~9的数组
    for(int i = a; i&lt;=b;i++) {   
    	int c = i;
    	while(c != 0) {
    		arr [c%10]++;
    		c/=10;
    	}   
    }
    for(int i = 0; i&lt;10; i++) {
    	System.out.print(arr[i] + " ");
    }
}
}
</code></pre> 
<pre><code>import java.util.Arrays;
import java.util.Scanner;

public class P2911G {
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        int [] a = new int[3];
        int [] b = new int [20000000];//计数数组
        int max =  - Integer.MAX_VALUE;


        for(int i = 0; i &lt; a.length; i++)
            a[i] = cin.nextInt();
        Arrays.sort(a);

        for(int x = 1; x &lt;= a[0]; x++) {
            for(int y = 1; y &lt;= a[1]; y++) {
                for(int z = 1; z &lt;= a[2]; z++)
                    b[x+y+z]++;
            }
        }
        for(int i = 0; i &lt; b.length; i++) {
            if(b[i] &gt; max)
                max = b[i];
        }
        for(int i = 0; i &lt; b.length; i++) {
            if (b[i]==max) {
                System.out.println(i);//输出最大那个数字的数组下标
                break;
            }
        }
    }
}
</code></pre> 
<h4><a id="ArrayList_453"></a>把ArrayList转换成普通数组</h4> 
<pre><code>int len = arr.size(); //获取集合长度
Integer[] newArr = new Integer[len];  //创建数组
arr.toArray(newArr);  //转为数组
</code></pre> 
<h4><a id="_461"></a>大数字精度问题</h4> 
<h6><a id="BigIntegerBigDecimal_463"></a>BigInteger、BigDecimal</h6> 
<pre><code>BigInteger
package ustc.lichunchun.bigdataapi; 
import java.math.BigInteger;
public class BigIntegerDemo1 {
 
	public static void main(String[] args) {
		BigInteger bi1 = new BigInteger("123456789") ;	// 声明BigInteger对象
		BigInteger bi2 = new BigInteger("987654321") ;	// 声明BigInteger对象
		System.out.println("加法操作：" + bi2.add(bi1)) ;	// 加法操作
		System.out.println("减法操作：" + bi2.subtract(bi1)) ;	// 减法操作
		System.out.println("乘法操作：" + bi2.multiply(bi1)) ;	// 乘法操作
		System.out.println("除法操作：" + bi2.divide(bi1)) ;	// 除法操作
		System.out.println("最大数：" + bi2.max(bi1)) ;	 // 求出最大数
		System.out.println("最小数：" + bi2.min(bi1)) ;	 // 求出最小数
		BigInteger result[] = bi2.divideAndRemainder(bi1) ;	// 求出余数的除法操作
		System.out.println("商是：" + result[0] + 
			"；余数是：" + result[1]) ;
	}
}
</code></pre> 
<pre><code>BigDecimal
package ustc.lichunchun.bigdataapi;
import java.math.BigDecimal;
public class BigDecimalDemo01 {
 
	public static void main(String[] args) {
		System.out.println("加法运算：" + MyMath.round(MyMath.add(10.345,3.333),1)) ;
		System.out.println("减法运算：" + MyMath.round(MyMath.sub(10.345,3.333),3)) ;
		System.out.println("乘法运算：" + MyMath.round(MyMath.mul(10.345,3.333),4)) ;
		System.out.println("除法运算：" + MyMath.div(10.345,3.333,3)) ;
	}
}
class MyMath{
	public static double add(double d1,double d2){		// 进行加法计算
		BigDecimal b1 = new BigDecimal(d1) ;
		BigDecimal b2 = new BigDecimal(d2) ;
		return b1.add(b2).doubleValue() ;
	}
	public static double sub(double d1,double d2){		// 进行减法计算
		BigDecimal b1 = new BigDecimal(d1) ;
		BigDecimal b2 = new BigDecimal(d2) ;
		return b1.subtract(b2).doubleValue() ;
	}
	public static double mul(double d1,double d2){		// 进行乘法计算
		BigDecimal b1 = new BigDecimal(d1) ;
		BigDecimal b2 = new BigDecimal(d2) ;
		return b1.multiply(b2).doubleValue() ;
	}
	public static double div(double d1,double d2,int len){		// 进行除法计算
		BigDecimal b1 = new BigDecimal(d1) ;
		BigDecimal b2 = new BigDecimal(d2) ;
		return b1.divide(b2,len,BigDecimal.ROUND_HALF_UP).doubleValue() ;
	}
	public static double round(double d,int len){	// 进行四舍五入
		BigDecimal b1 = new BigDecimal(d) ;
		BigDecimal b2 = new BigDecimal(1) ; // 技巧
		return b1.divide(b2,len,BigDecimal.ROUND_HALF_UP).doubleValue() ;
	}
};
</code></pre> 
<pre><code>import java.math.BigInteger;
import java.util.Scanner;

public class P1009阶层之和高精度 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();

        BigInteger sum =new BigInteger("0");
        for (int i=1;i&lt;=n;i++) {
            sum.add(mul(i));
        }
        System.out.println(sum);
    }
    //求单个数字的阶层
    public static BigInteger mul(int n) {
        BigInteger m=new BigInteger("1");
        for (int i=1;i&lt;=n;i++) {
            m=m.multiply(new BigInteger(String.valueOf(i)));
        }
        return m;
    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/73/84/6nlXgcyf_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_557"></a>字符串</h4> 
<h6><a id="_559"></a>删除字符串</h6> 
<pre><code>//要切割的字符串

String s = "123.jpg,113.jpg,121.jpg,122.jpg,131.jpg";
String sub = "";
System.out.println("编译前："+s);
//调用方法
sub = s.replaceAll( ",113.jpg|113.jpg,","");//.replaceAll( ",122.jpg|122.jpg,","");
System.out.println("编译后："+sub);
</code></pre> 
<h4><a id="_572"></a>求最大公约数</h4> 
<pre><code>    public static int common(int m,int n) {
        int r=1;
        for (int i=2;i&lt;=m &amp;&amp; i&lt;=n;i++) {
            if (m%i ==0 &amp;&amp; n%i==0) {
                r=i;
            }
        }
        return r;
    }
</code></pre> 
<h4><a id="_586"></a>检测代码运行时间</h4> 
<pre><code>一、以毫秒为单位。
long startTime = System.currentTimeMillis(); //获取开始时间

doSomething(); //测试的代码段

long endTime = System.currentTimeMillis(); //获取结束时间

System.out.println("程序运行时间：" + (endTime - startTime) + "ms"); //输出程序运行时间
</code></pre> 
<h4><a id="_599"></a>求最小值</h4> 
<pre><code>		int a[] = {10, 5, 8};
		
		int min = Arrays.stream(a).min().getAsInt();
//或				Arrays.sort(a);
		System.out.println(a[0]);
</code></pre> 
<h4><a id="_609"></a>质数判断&amp;&amp;数字反转</h4> 
<pre><code>    //数字反转
    public static boolean reverse(long a) {
        /*100分*/
        long x = a;
//        String y = "";//字符串会延长时间
        long y=0;
        while (x != 0) {
            y = y*10 + x % 10;
            x = x / 10;
        }
        if (y == a) {
            return true;
        } else {
            return false;
        }

/*88分*/
//        long d=a;
//        String mid ="";
//        while (a!=0) {
//            long b=a%10;
//            a=a/10;
//            mid+=b;
//        }
//        if ((Long.parseLong(mid)==d)){
//            return true;
//        }else {
//            return false;
//        }
    }

    //质数判断
    public static boolean judge3(long n) {
        if (n == 1 || n == 2 || n == 3) {
            return true;
        } else {
            for (int i = 2; i &lt;= (Math.sqrt(n)); i++) {
                if (n % i == 0) {
                    return false;
                }
            }
        }
        return true;
    }
</code></pre> 
<pre><code>//质数判断
	private static boolean isPrime(int src) {
        double sqrt = Math.sqrt(src);
        if (src &lt; 2) {
            return false;
        }
        if (src == 2 || src == 3) {
            return true;
        }
        if (src % 2 == 0) {// 先判断是否为偶数，若偶数就直接结束程序
            return false;
        }
        for (int i = 3; i &lt;= sqrt; i+=2) {//不带“=”  41分
            if (src % i == 0) {
                return false;
            }
        }
        return true;
    }
    //质数判读
    public static boolean judge(long i) {
        if (i&lt;2) {
            return false;
        }

        for (int j=2;j&lt;i;j++) {
            if (i%j==0) {
                return false;
            }
        }
        return true;
    }
</code></pre> 
<h6><a id="2_693"></a>数字反转2</h6> 
<pre><code>import java.util.Scanner;

public class P5705数字反转 {

    public static void main(String []args) {
        Scanner scanner = new Scanner(System.in);
        float m= scanner.nextFloat();
        String a = Float.toString(m);
        String b = new StringBuffer(a).reverse().toString();//

        float c = Float.parseFloat(b);
        if (m&gt;=100&amp;&amp;m&lt;1000) {
            System.out.println(c);
        }
    }
}
</code></pre> 
<h6><a id="_714"></a>质数判断</h6> 
<pre><code>    private static boolean isPrime(int src) {
        double sqrt = Math.sqrt(src);
        if (src &lt; 2) {
            return false;
        }
        if (src == 2 || src == 3) {
            return true;
        }
        if (src % 2 == 0) {// 先判断是否为偶数，若偶数就直接结束程序
            return false;
        }
        for (int i = 3; i &lt;= sqrt; i+=2) {
            if (src % i == 0) {
                return false;
            }
        }
        return true;
    }
</code></pre> 
<h6><a id="_737"></a>数字反转</h6> 
<pre><code>public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    int a= scanner.nextInt();
    int sum =0;
    while (a!=0) {
         sum = sum*10 + a%10;
        a=a/10;
    }
    System.out.println(sum);
}
</code></pre> 
<h4><a id="Math_752"></a>Math类的常用方法</h4> 
<pre><code>Math.sqrt()   //计算平方根
Math.cbrt()   //计算立方根
Math.hypot(x,y)   //计算 (x的平方+y的平方)的平方根
Math.pow(a,b)   //计算a的b次方
Math.abs(a)   //求绝对值
Math.ceil()   //向上取整
Math.floor()   //向下取整
</code></pre> 
<h4><a id="HashSet_764"></a>HashSet不重复集合</h4> 
<pre><code>Set&lt;String&gt; S = new HashSet&lt;String&gt;();	//构造字符串集合S
//主要方法
S.add()	//增加元素
S.clear()	//从此 set 中移除所有元素
S.remove()	//如果指定元素存在于此 set 中，则将其移除
S.size()	//返回此 set 中的元素的数量（set 的容量）
</code></pre> 
<h4><a id="Map_775"></a>Map遍历方法</h4> 
<pre><code>        Map&lt;Integer,Integer&gt; list = new TreeMap&lt;&gt;();
        list.put(1,3);
        list.put(3,7);
        list.put(4,2);
        list.put(2,5);
        
        int a = list.get(4);
        a++;
        list.put(4,a);
        System.out.println(a);
        //方法一单独遍历
        for (Integer key: list.keySet()) {
//            System.out.print(key+" ");
        }
        for (Integer values:list.values()) {
//            values++;
//            System.out.print("\n"+values+" ");
        }
        //方法二 一起遍历
        for (Map.Entry&lt;Integer,Integer&gt; arr :list.entrySet()) {
            int m=arr.getKey();
            int n=arr.getValue();
            System.out.println(m+","+n);
        }
</code></pre> 
<h6><a id="Map_804"></a>Map综合利用求集合出现最多次数</h6> 
<p><a href="#%E6%95%B0%E7%BB%84%E6%A0%87%E6%B3%95%E8%AE%B0%E6%9F%90%E4%B8%AA%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0" rel="nofollow">跳上去</a></p> 
<pre><code>{//P2911
        Scanner scanner = new Scanner(System.in);
        int s1=scanner.nextInt(),s2=scanner.nextInt(),s3=scanner.nextInt();
        List&lt;Integer&gt; arr = new ArrayList&lt;&gt;();
        int sum=0;
        for (int i =1;i&lt;=s1;i++) {
            for (int j =1;j&lt;=s2;j++) {
                for (int k =1;k&lt;=s3;k++) {
                    sum = i+j+k;
                    arr.add(sum);
                }
            }
        }
        Collections.sort(arr);

        Map &lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        for (Integer integer : arr) {
//            System.out.println(integer);
            if (!map.containsKey(integer)) {
                map.put(integer,1);
            }else {
              int a =  map.get(integer);
              a++;
              map.put(integer,a);
            }
        }
        int max=0;
        for (Integer a:map.values()) {
            if (a&gt;max) {
                max=a;
            }
        }
//        System.out.println(max);
        int key=0;
        for (Map.Entry&lt;Integer,Integer&gt; map1 :map.entrySet()){
//            System.out.println(map1.getKey()+","+map1.getValue());
            if (map1.getValue()==max) {
                key=map1.getKey();
                break;
            }
        }
        System.out.println(key);
 }
</code></pre> 
<h4><a id="_854"></a>截取字符串&amp;&amp;替换字符串</h4> 
<h6><a id="substring_v_856"></a>substring（） 方法截取v字符串</h6> 
<pre><code>    字符串.substring(int beginIndex, int endIndex) 
    //beginIndex 起始索引（包括）, 索引从 0 开始。endIndex 结束索引（不包括）。
</code></pre> 
<h4><a id="_863"></a>替换字符串中的片段</h4> 
<pre><code>StringBuilder str = new StringBuilder("abcdefghijklmn");
str=str.replace(3, 6, "这里被换了");    //变成了 abc这里被换了ghijklmn
</code></pre> 
<h4><a id="_870"></a>替换字符串中的一个字符</h4> 
<pre><code>String str = new String("abcdefghijklmn");
str=str.replace("a", "这里被换了");    //变成了 这里被换了bcdefghijklmn
</code></pre> 
<h4><a id="split_877"></a>拆分字符串split()</h4> 
<h6><a id="split__879"></a>split() 方法根据匹配给定的正则表达式来</h6> 
<p>针对string类型的split()函数。它主要是切割字符串，结果返回由字符串元素组成的一个列表</p> 
<ul><li> <p>当****没有参数*<em><strong>的情况下，函数默认会以</strong></em>*空格，回车符，空格符****等作为分割条件。</p> </li><li> <p>有参数函数会****以参数为分割条件*<em><strong>，把字符串进行分割，得到的每个分割段作为</strong>列表的元素返回</em>*。</p> </li><li> <p>两个参数，****第二个参数的意思是你想分多少次****</p> </li><li> <pre><code>a="My,name,is,zhangkang,and,I,am,a,student"
b1=a.split(",",1)
b2=a.split(",",2)
b8=a.split(",",8)
b9=a.split(",",9)  //大于最大值不会报错
 
print(b1)
print(b2)
print(b8)
print(b9)
 
输出：
['My', 'name,is,zhangkang,and,I,am,a,student']
['My', 'name', 'is,zhangkang,and,I,am,a,student']
['My', 'name', 'is', 'zhangkang', 'and', 'I', 'am', 'a', 'student']
['My', 'name', 'is', 'zhangkang', 'and', 'I', 'am', 'a', 'student']
</code></pre> 
  <hr> </li></ul> 
<pre><code>String str = new String("Welcome-to-here");
     for (String retval: str.split("-"))
            System.out.println(retval);  
/*
输出结果为：
Welcome
to
here
*/
</code></pre> 
<h4><a id="_922"></a>字符串反转&amp;&amp;字符串拆分</h4> 
<p>charAt(i) 函数 是获取字符串中i位置的字符</p> 
<pre><code>  String a= "123ad" ;
        //方法一  利用StringBuffer的reverse
        String a1=new StringBuffer(a).reverse().toString();
        System.out.println(a1);
        System.out.println("1.=====================");
        //方法二  利用String的toCharArray方法先将字符串转化为char类型的数组，然后将各个字符进行从新拼接
        char [] chars = a.toCharArray();
        String a2="";
        for (int i=chars.length-1;i&gt;=0;i--) {
            a2 +=chars[i];
        }
        System.out.println(a2);
        System.out.println("2.=====================");
        //方法三   利用String的CharAt方法取出字符串中的各个字符
        String a3 = "";
        for (int i=0;i&lt;a.length();i++){
            a3=a.charAt(i) + a3;
        }
        System.out.println(a3);
        System.out.println("3.===================");

</code></pre> 
<pre><code>public class RunoobTest {
    public static void main(String args[]) {
        String Str = new String("This is text");
        System.out.print("返回值 :" );
        System.out.println(Str.substring(4) );
 
        System.out.print("返回值 :" );
        System.out.println(Str.substring(4, 10) );
    }
}
返回值 : is text
返回值 : is te
</code></pre> 
<h4><a id="_965"></a>判断字符串开头结尾</h4> 
<p><img src="https://images2.imgbox.com/9c/4b/WYfwqJpQ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="indexOf_969"></a>indexOf函数两种用法</h4> 
<p>1、 indexOf(String str): 返回指定字符str在字符串中（方法调用者）第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。<br> 2、indexOf(String str, int index): 返回从 index 位置开始查找指定字符str在字符串中第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。</p> 
<h4><a id="_974"></a>计算某字符串中特定字符串出现次数的几种算法</h4> 
<h6><a id="indexOf_976"></a>利用indexOf()方法</h6> 
<pre><code>/**
 * str.indexOf(findstr,index)  从index开始 有这个字符串，返回这个字符串第一次出现的下标。没有则返回-1
 */

public class 标记某个字符出现的次数 {
    public static void main(String[] args) {
        String str = "jhdvjsdjava;osdfpojavalsdjfisjavlsdihgjavalsdihfsjava";
        String findstr = "java";
        int count = countstr5(str,findstr);
        System.out.println(count);
    }
    public static int countstr5(String str,String findstr){
        int count = 0;
        int index = 0;
        //如果！=-1,则说明找到了findstr首次出现的索引
        while((index = str.indexOf(findstr,index)) != -1){
            System.out.println(str.indexOf(findstr,index));
            System.out.println(index);
            index += findstr.length();//去除之前检测过的字符串
            count++;
        }
        return count;
    }
}
</code></pre> 
<ul><li> <h6><a id="_______1005"></a>出现次数 = (原字符串长度 - 替换后字符串长度) / 目标子串长度</h6> </li></ul> 
<pre><code>public class 标记某个字符串出现的次数_02 {
    public static void main(String[] args) {
        String str = "jhdvjsdjava;osdfpojavalsdjfisjavlsdihgjavalsdihfsjava";
        String findstr = "java";
        int count =countstr1(str,findstr);
        System.out.println(count);
    }

    public static int countstr1(String str,String findstr){
        int count = 0;
        count = (str.length() - str.replace(findstr,"").length())/findstr.length();
        return count;
    }
}
</code></pre> 
<h6><a id="indexOf__subString_1024"></a>indexOf()方法 搭配 subString()方法</h6> 
<p>select substring(‘abdcsef’,1,3)<br> 结果：‘abd’</p> 
<ul><li>利用substring方法截取（最近子串结束的位置 ，字符串末尾）</li></ul> 
<h4><a id="_1031"></a>在指定位置拼接和插入字符串</h4> 
<p><a href="https://blog.csdn.net/weixin_42290280/article/details/83060528?ops_request_misc=%7B%22request%5Fid%22%3A%22164272787116780271946730%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=164272787116780271946730&amp;biz_id=0&amp;spm=1018.2226.3001.4187">Java——在指定位置拼接和插入字符串_命中的缘分的博客-CSDN博客_java string 插入</a></p> 
<h6><a id="_1035"></a>末尾插入</h6> 
<pre><code>  StringBuilder stringBuilder=new StringBuilder("1234ac");
  stringBuilder.append("123");
</code></pre> 
<h6><a id="_1042"></a>位置插入</h6> 
<pre><code>StringBuffer stringBuilder1=new StringBuffer("20180918");
stringBuilder1.insert(6,"-");
stringBuilder1.insert(4,"-");
</code></pre> 
<h6><a id="_1050"></a>字符后插入</h6> 
<pre><code> StringBuilder stringBuilder2=new StringBuilder("1234abcdabc12");
 int index=stringBuilder2.indexOf("abc");
 stringBuilder2.insert(index,"131");
</code></pre> 
<h4><a id="String_StringBufferhttpssocsdnnetsosearchqStringBufferspm1001210130017020_StringBuilder__1058"></a>String <a href="https://so.csdn.net/so/search?q=StringBuffer&amp;spm=1001.2101.3001.7020">StringBuffer</a> StringBuilder 转换</h4> 
<blockquote> 
 <p><strong>String:不可变的字符序列</strong></p> 
 <p><strong>StringBuffer：可变的字符序列，线程安全、效率低</strong></p> 
 <p><strong>StringBuilder: 可变的字符序列，jdk5.0 新增 效率高</strong></p> 
</blockquote> 
<ol><li> <p>String开始创建的是一个长度为0的字符数组<br> StringBuffer StringBuilder <strong>底层创建了一个长度是16的字符数组</strong>。<br> 初始化有值时 创建一个长度为字符长度+16的字符数组。<br> 扩容为原来的两倍+2 同时将数组中的元素复制到新的数组中<br> 指定大小，防止持续扩容<br> StringBuffer(int capacity)<br> StringBuilder(int capacity)</p> </li><li> <p>对比String、StringBuffer、StringBuilder三者的执行效率<br> 从高到低排列：StringBuilder &gt; StringBuffer &gt; String</p> </li><li> <p>String与StringBuffer、StringBuilder之间的转换：<br> String --&gt;StringBuffer、StringBuilder:调用StringBuffer、StringBuilder构造器</p> </li><li> <p>StringBuffer、StringBuilder --&gt;String:</p> <p>①调用String构造器；</p> <p>②StringBuffer、StringBuilder的toString()</p> </li></ol> 
<p><a href="https://www.cnblogs.com/guoyafenghome/p/8542097.html" rel="nofollow">==和equals在比较字符串时候的区别 - 菜鸟~风 - 博客园 (cnblogs.com)</a></p> 
<p>简单说==指向同一对象（内存地址），equals用于比较两个对象是否相等</p> 
<h4><a id="_1090"></a>正则</h4> 
<ul><li> <p>find()方法是部分匹配，是查找输入串中与模式匹配的子串，如果该匹配的串有组还可以使用group()函数。</p> </li><li> <p>matches()是全部匹配，是将整个输入串与模式匹配，如果要验证一个输入的数据是否为数字类型或其他类型，一般要用matches()。</p> </li><li> <p><strong>1.matches</strong>：整个匹配，只有整个字符序列完全匹配成功，才返回True，否则返回False。但如果前部分匹配成功，将移动下次匹配的位置。</p> <p><strong>2.lookingAt</strong>：部分匹配，总是从第一个字符进行匹配,匹配成功了不再继续匹配，匹配失败了,也不继续匹配。从第一个匹配，匹配一次，只要第一个失败就返回false 不在匹配</p> <p><strong>3.find</strong>：部分匹配，从当前位置开始匹配，找到一个匹配的子串，将移动下次匹配的位置。</p> <p><strong>4.reset</strong>：给当前的Matcher对象配上个新的目标，目标是就该方法的参数；如果不给参数，<a href="https://so.csdn.net/so/search?q=reset&amp;spm=1001.2101.3001.7020">reset</a>会把Matcher设到当前字符串的开始处。</p> </li></ul> 
<h6><a id="_____1104"></a>正则表达式中的 .<em>? 或 .</em>+ 或.*</h6> 
<ul><li> <p>src=".*"<br> 匹配结果是：src=“test.jpg” width=“60px” height=“80px”<br> 意思是从="往后匹配，直到最后一个"匹配结束</p> </li><li> <p>懒惰模式正则：<br> src=".*?"<br> 结果：src=“test.jpg”<br> 因为匹配到第一个"就结束了一次匹配。不会继续向后匹配。因为他懒惰嘛。</p> </li><li> <p>.表示除\n之外的任意字符<br> *表示匹配0-无穷<br> +表示匹配1-无穷</p> </li></ul> 
<p><a href="https://blog.csdn.net/qq_35517448/article/details/82751648?ops_request_misc=%7B%22request%5Fid%22%3A%22164272729516780271575705%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=164272729516780271575705&amp;biz_id=0&amp;spm=1018.2226.3001.4187">Java 正则_我的博客-CSDN博客_java正则</a></p> 
<p>####find() + start() + end()<br> find() 方法用于在文本中查找出现的正则表达式，文本是创建Matcher时，通过 Pattern.matcher(text) 方法传入的。如果在文本中多次匹配，find() 方法返回第一个，之后每次调用 find() 都会返回下一个。<br> start() 和 end() 返回每次匹配的字串在整个文本中的开始和结束位置。实际上, end() 返回的是字符串末尾的后一位，这样，可以在把 start() 和 end() 的返回值直接用在String.substring() 里。</p> 
<pre><code>String text    =
        "This is the text which is to be searched " +
        "for occurrences of the word 'is'.";
String patternString = "is";
Pattern pattern = Pattern.compile(patternString);
Matcher matcher = pattern.matcher(text);
int count = 0;
while(matcher.find()) {
    count++;
    System.out.println("found: " + count + " : "  + matcher.start() + " - " + matcher.end());
      System.out.println(text.substring(matcher.start(), matcher.end()));
}

</code></pre> 
<p>Pattern pat = Pattern.compile(regEx,<strong>Pattern.CASE_INSENSITIVE</strong>);<br> 表示正则regEx不区分大小写</p> 
<h4><a id="HashSet_1144"></a>HashSet不重复集合</h4> 
<pre><code>Set&lt;String&gt; S = new HashSet&lt;String&gt;();	//构造字符串集合S
//主要方法
S.add()	//增加元素
S.clear()	//从此 set 中移除所有元素
S.remove()	//如果指定元素存在于此 set 中，则将其移除
S.size()	//返回此 set 中的元素的数量（set 的容量）
</code></pre> 
<h3><a id="_1157"></a>标题算法学习前的初步了解</h3> 
<p>注意：从此处到以下（到2.冒泡排序查找）是之前总结，大部分是从知乎和博文上复制来的。有些有附上博文链接，有些没附上，此博文仅代表是本人的笔记记录。</p> 
<h3><a id="java_1160"></a>java知识</h3> 
<p><a href="https://blog.csdn.net/weixin_44624410/article/details/100410634">(2条消息) java算法知识点_冲冲冲的博客-CSDN博客_java重点算法</a></p> 
<h4><a id="_1164"></a>集合学习</h4> 
<h5><a id="Map_1166"></a>Map</h5> 
<p><a href="https://www.bilibili.com/video/BV157411A7fv?from=search&amp;seid=8579906097497918682&amp;spm_id_from=333.337.0.0" rel="nofollow">Java Map集合讲解_哔哩哔哩_bilibili</a></p> 
<p>HashMap TreeMap</p> 
<h6><a id="hashmap_1172"></a>hashmap遍历</h6> 
<p><img src="https://images2.imgbox.com/3b/6f/EQtwoRfn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e3/50/G4KD2FPs_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e4/2f/NL3eoqZg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_1178"></a>1.随机数</h4> 
<pre><code>(Math.random() * 11 +10);	//产生10~20的随机数
</code></pre> 
<h4><a id="2_1184"></a>2.转义符</h4> 
<p><img src="https://images2.imgbox.com/ea/db/8IKRYQ5p_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3substring_v_1189"></a>3.substring（） 方法截取v字符串</h4> 
<pre><code>    字符串.substring(int beginIndex, int endIndex) 
    //beginIndex 起始索引（包括）, 索引从 0 开始。endIndex 结束索引（不包括）。
</code></pre> 
<h4><a id="4_1196"></a>4.判断两个对象是否等价</h4> 
<pre><code>A.equals(B)
</code></pre> 
<h4><a id="5_1202"></a>5.随机数控制概率</h4> 
<pre><code>int d = (int)(Math.random() * 101);		//产生100以内的随机数充当概率
if (d &lt;= 75)
	(75%的概率干嘛)
else
	(25%d 概率干嘛)
</code></pre> 
<h4><a id="6toCharArray__1212"></a>6.toCharArray（） 获取字符串的每个字符</h4> 
<pre><code>String Str = "www.runoob.com";
char[] 字符数组 = Str.toCharArray();	//字符串改为字符数组
</code></pre> 
<h4><a id="7BigInterger_1219"></a>7.BigInterger操作大数</h4> 
<p><img src="https://images2.imgbox.com/c8/b4/wMJQgMjJ_o.png" alt="在这里插入图片描述"></p> 
<p>BigInteger比较大小可以用compareTo方法来比较，小于则返回-1，等于则返回0，大于则返回1</p> 
<h4><a id="8Math_1225"></a>8.Math类的常用方法</h4> 
<pre><code>Math.sqrt()   //计算平方根
Math.cbrt()   //计算立方根
Math.hypot(x,y)   //计算 (x的平方+y的平方)的平方根
Math.pow(a,b)   //计算a的b次方
Math.abs(a)   //求绝对值
Math.ceil()   //向上取整
Math.floor()   //向下取整
</code></pre> 
<h4><a id="9HashSet_1237"></a>9.HashSet不重复集合</h4> 
<pre><code>Set&lt;String&gt; S = new HashSet&lt;String&gt;();	//构造字符串集合S
//主要方法
S.add()	//增加元素
S.clear()	//从此 set 中移除所有元素
S.remove()	//如果指定元素存在于此 set 中，则将其移除
S.size()	//返回此 set 中的元素的数量（set 的容量）
</code></pre> 
<h4><a id="10_1248"></a>10.长度不固定数组</h4> 
<pre><code>ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();
arr.add(1);
arr.add(3);
</code></pre> 
<h4><a id="11ArrayList_1256"></a>11.把ArrayList数组转换成普通数组</h4> 
<pre><code>int len = arr.size(); //获取集合长度
Integer[] newArr = new Integer[len];  //创建数组
arr.toArray(newArr);  //转为数组
</code></pre> 
<h4><a id="12_1264"></a>12.替换字符串中的片段</h4> 
<pre><code>StringBuilder str = new StringBuilder("abcdefghijklmn");
str=str.replace(3, 6, "这里被换了");    //变成了 abc这里被换了ghijklmn
</code></pre> 
<h4><a id="13_1271"></a>13.替换字符串中的一个字符</h4> 
<pre><code>String str = new String("abcdefghijklmn");
str=str.replace("a", "这里被换了");    //变成了 这里被换了bcdefghijklmn
</code></pre> 
<h4><a id="14_1278"></a>14、科学计数法</h4> 
<pre><code>//科学计数法数字转普通数字
        double num1 = 50123.12E25;
        BigDecimal bd1 = new BigDecimal(num1);
        System.out.println(bd1.toPlainString());
//普通数字转科学计数法
        double num2 = 50123.12;
        BigDecimal bd2 = new BigDecimal(num2);
        System.out.println(bd2.toPlainString()); //法一
        System.out.println(String.format("%.6E",num2)); //法二
</code></pre> 
<h4><a id="15split__1292"></a>15、split() 方法根据匹配给定的正则表达式来拆分字符串</h4> 
<pre><code>String str = new String("Welcome-to-here");
     for (String retval: str.split("-"))
            System.out.println(retval);  
/*
输出结果为：
Welcome
to
here
*/
</code></pre> 
<h4><a id="16_1306"></a>16、将数值转化为字符串</h4> 
<pre><code>String.valueOf(数值)
</code></pre> 
<h4><a id="17_1312"></a>17、测试运行时间</h4> 
<pre><code>long startTime = System.currentTimeMillis(); //获取开始时间

doSomething(); //测试的代码段

long endTime = System.currentTimeMillis(); //获取结束时间

System.out.println("程序运行时间：" + (endTime - startTime) + "ms"); //输出程序运行时间
</code></pre> 
<h4><a id="18compareTo_1324"></a>18、compareTo()方法比较字符串</h4> 
<pre><code>1 、如果两个字符串首字母不同，则该方法返回首字母的asc码的差值
若a=“ab”,b=“b”,则输出-1；
若a=“abcdef”,b="b"则输出-1；

2 、如果首字符相同，则比较下一个字符，直到有不同的为止，返回该不同的字符的asc码差值，如果两个字符串不一样长，可以参与比较的字符又完全一样，则返回两个字符串的长度差值
若a=“ab”,b=“a”,输出1；
若a=“abcdef”,b="a"输出5；
若a=“abcdef”,b="abc"输出3；
若a=“abcdef”,b="ace"输出-1；
</code></pre> 
<h4><a id="19hasNextInt_1338"></a>19、hasNextInt()判断控制台是否输入数字</h4> 
<pre><code>if(input.hasNextInt()){
	do something;
 }
else
	System.out.println("请输入正确数字！"); 
</code></pre> 
<h4><a id="20charint_1348"></a>20、char型数字转为int型</h4> 
<pre><code>char a = '5';
int b = a - '0';
</code></pre> 
<h4><a id="21Scanner_1355"></a>21、Scanner资源关闭</h4> 
<pre><code>流一旦打开，要记得关闭。所有资源型变量都是三部曲：

打开资源 Scanner sc = new Scanner(System.in);
操作数据
关闭资源 sc.close(); // 关闭
资源若没有关闭，会产生内存泄露，运行着运行着，内存越来越少，突然，崩溃××，
</code></pre> 
<h4><a id="22array_1366"></a>22、array排列数组</h4> 
<p><img src="https://images2.imgbox.com/9e/64/e2mZMfAs_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="23Stringint_1370"></a>23、String与int互相转换</h4> 
<h6><a id="IntString4_1372"></a>Int-----&gt;String（4种方法）</h6> 
<pre><code>int num=100;
//1
String s1=""+num;
//2
String s2 =String.valueOf(num);
//3
Integer i =new Integer(num);
String s3 =i.toString();
//4
String s4 =Integer.toString(i);
</code></pre> 
<h6><a id="StringInt_2_1387"></a>String----&gt;Int (2种)</h6> 
<pre><code>String s="100";
//1
Integer ii =new Integer(s);
int x=ii.intValue();
//2
int y = Integer.parseInt(s);
</code></pre> 
<h4><a id="24Calendar__1398"></a>24、Calendar 的用法</h4> 
<pre><code>Calendar rightNow = Calendar.getInstance(); // 子类对象
 // 获取当前年
 int year = rightNow.get(Calendar.YEAR);
 // 获取当前月，0~11对应1月到12月
 int month = rightNow.get(Calendar.MONTH);
 // 获取当前日
 int date = rightNow.get(Calendar.DATE);
 //获取当前钟点
 int hour=rightNow.get(Calendar.HOUR_OF_DAY);
 //获取上午下午
 int moa=rightNow.get(Calendar.AM_PM);
 if(moa==1)
     System.out.println("下午");
 else
     System.out.println("上午");
//当前时间
System.out.println(year + "年" + (month + 1) + "月" + date + "日"+hour+"时");

//set设置时间  add增加时间  get获取操作后的时间
rightNow.set(年 ， 月 ， 日); //年月日是设置的时间
rightNow.add(Calendar.YEAR,-10); //在设置的时间上减少10年
rightNow.add(Calendar.DATE, -10); //在设置的时间上减少10天
System.out.println(rightNow.getTime()); 
</code></pre> 
<h4><a id="25indexOf__1426"></a>25、indexOf() 方法</h4> 
<pre><code>String string = "aaa456ac";  
//查找指定字符在字符串中的下标。在则返回所在字符串下标；不在则返回-1.  
System.out.println(string.indexOf("b")); // indexOf(String str); 返回结果：-1，"b"不存在  

// 从第四个字符位置开始往后继续查找，包含当前位置  
System.out.println(string.indexOf("a",3));//indexOf(String str, int fromIndex); 返回结果：6  

//（与之前的差别：上面的参数是 String 类型，下面的参数是 int 类型）参考数据：a-97,b-98,c-99  

// 从头开始查找是否存在指定的字符  
System.out.println(string.indexOf(99));//indexOf(int ch)；返回结果：7  
System.out.println(string.indexOf('c'));//indexOf(int ch)；返回结果：7  

//从fromIndex查找ch，这个是字符型变量，不是字符串。字符a对应的数字就是97。  
System.out.println(string.indexOf(97,3));//indexOf(int ch, int fromIndex); 返回结果：6  
System.out.println(string.indexOf('a',3));//indexOf(int ch, int fromIndex); 返回结果：6  

//查找指定字符串在字符串中的下标。在则返回所在字符串下标；不在则返回-1.  
System.out.println("zhangchen".indexOf("chen"));
}
</code></pre> 
<h4><a id="26scannerchar_1451"></a>26、scanner接受char类型字符</h4> 
<pre><code>char sex=scanner.next().charAt(0);
//charAt()的用法
String str = "abc"; 
char ch = str.charAt(0); 
char ch2 = str.charAt(1); 
//这时候ch是a，ch2是b； 
</code></pre> 
<h4><a id="27_1462"></a>27、正则表达式匹配字符串</h4> 
<pre><code>String s = "zhangchen";
String z = "[^aeiou]+[aeiou]+[^aeiou]+[aeiou]+";//正则表达式
Pattern p = Pattern.compile(z);//模板
Matcher m = p.matcher(s);
System.out.println(m.matches());
</code></pre> 
<h4><a id="28txttrycatch_1472"></a>28、答案输出为txt文件（简化try/catch）</h4> 
<pre><code>File file = new File("c:\\1.txt");	//路径是这样的，没有错，运行后会在C盘目录下生成一个1.txt文件
FileWriter fw = new FileWriter(file);
fw.write("123213");//向文件中复制内容
fw.close();
</code></pre> 
<h4><a id="29_1481"></a>29、进制转换</h4> 
<p><img src="https://images2.imgbox.com/bd/20/FH5VLPlp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="30javautilCollectionsncopies_1486"></a>30、java.util.Collections.ncopies()方法</h4> 
<p>ncopies(int, T) 方法用于返回一个不可变列表组成的n个拷贝的指定对象。</p> 
<pre><code>//	参数
//	n-- 在返回列表中元素的个数。
//	o-- 在返回列表中反复出现的元素
//	返回值
//	方法调用返回的不可变列表组成的n个拷贝的指定对象。

List list = Collections.nCopies(5, "zhang");

// create an iterator
Iterator itr = list.iterator();

System.out.println("Values are :");
while (itr.hasNext()){
   System.out.println(itr.next());
}
</code></pre> 
<h4><a id="31Stringjoin_1508"></a>31、String.join()拼装字符串</h4> 
<pre><code>//	参数
//	参数一：每个元素要添加的分隔符
//	参数二：需要添加分隔符的字符串

//	返回值
//	拼接后的字符串
String joinString = String.join("-","welcome","to","China");
System.out.println(joinString);

//	输出结果为：
//	welcome-to-China
</code></pre> 
<h4><a id="32Stringcontains_1524"></a>32、String.contains()用法</h4> 
<p>从后往前遍历查找对应字符串，找到对应字符串结束返回数据，返回值为int类型，返回查找字符串首个字符位置（从0开始查找），未找到返回 -1；<br> lastIndexOf() 方法有以下四种形式：</p> 
<pre><code>int lastIndexOf(char ch)

int lastIndexOf(int ch, int fromIndex)

int lastIndexOf(String str)

int lastIndexOf(String str, int fromIndex)

//	参数
//	ch -- 字符。
//	fromIndex -- 开始搜索的索引位置。
//	str -- 要搜索的子字符串。
</code></pre> 
<h4><a id="34_1544"></a>34、两次回车结束运行</h4> 
<pre><code>while (true){
    //dosomething;
    if(in.nextLine().equals("")){
        if(!in.nextLine().equals("")){
            continue;
        }else{
            break;
        }
    }
}
</code></pre> 
<h3><a id="_1559"></a>算法方法</h3> 
<h4><a id="1_1561"></a>1.二分法查找</h4> 
<p><a href="https://blog.csdn.net/chenghui0317/article/details/10474405?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162402097216780271510004%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162402097216780271510004&amp;biz_id=0&amp;spm=1018.2226.3001.4187">链接</a></p> 
<p>二分法的解释是： 在一个按照升序排列的数组或集合中，首先判断数组的最中间的元素大于还是小于要查找的值，如果中间的元素大于查找的值，说明想要查找的值在这个数组的前半部分， 反之想要查找的值在这个数组的后半部分， 然后继续取出这个前半部分数组的中间元素 与要查找的值作比较，如此反复下去，直到找到为止。</p> 
<p>好处：大大缩减了查找次数，降低性能消耗，进而缩短查找时间。</p> 
<p>适用于：升序排列的数组</p> 
<p>原理：利用升序和用数组下标，分成区间来查找</p> 
<pre><code>package 算法方法最终精简版_带解析;


public class A01_二分法 {

	public int search(int[] nums, int target) {
		int left = 0, right = nums.length - 1;
		int count = 0;
		while (left &lt; right) {
			System.out.println("left"+left);
			System.out.println("right"+right);
			int mid = (left + right) / 2;
			System.out.println("mid"+mid);
			if (nums[mid] &gt;= target)
				right = mid;
			if (nums[mid] &lt; target)
				left = mid + 1;
		} 
//		第一个while循环执行完后  left=4，right=3（下标）
		while (left &lt; nums.length &amp;&amp; nums[left++] == target){	
//			nums[left++] 每执行一次，left自加一次
//			left &lt; nums.length 保证结果在最后一个的时候 不会超出数组长度，在最后一个检测完后立即退出循环
//			计算有几个相等的数字（执行几次循环 counter+几）
			count++;
			System.out.println("left&lt;len"+left);
		}
		return count;
	}
	public static void main(String[] args) {
		A01_二分法 demo = new A01_二分法();
		int a [] = {5,7,7,8,8,8};
		System.out.println(demo.search(a,8));
	}
}

</code></pre> 
<pre><code>package 算法方法最终精简版_带解析;

public class A01_my二分法 {
//	普通方法查找数字（暴力查找）
//	public static void main(String[] args) {
//		int a[] ={5,7,7,8,8,8};
//		int num=8;
//		int counter=0;
//		for(int i=0;i&lt;a.length;i++){
//			if(num==a[i]){
//				counter++;
//			}
//		}
//		System.out.println(counter);
//	}
	/*//二分法 直接查找第一个匹配元素
	public int binarySearch(int array[],int num){
		int count = 0;
		System.out.println("****************使用二分法查找****************");
		int mid = 0; // 检索的时候
		int left = 0;  //用left和right两个索引控制它的查询范围
		int right = array.length - 1;
		count = 0;
		for (int i = 0; i &lt; array.length; i++){ 
			count++;
			mid = (left + right) / 2;
			if(array.length - 1 == i){
				System.out.println("抱歉，没有找到");
			}else if (array[mid] &lt; num){
				left = mid;
			}else if (array[mid] &gt; num){
				right = mid;
			}else {
				System.out.println(array[mid] + "找到了，在数组下标为" + mid + "的地方,查找了" + count + "次。");
				break;
			}
		}
		return count;
	}
 
	public static void main(String[] args){
		Test demo = new Test();
		int array[] = {5,7,7,8,8,10,11};
		demo.binarySearch(array,10);
	}
	*/
//	二分法查找数字
	public int search(int []a,int b){
		int counter=0;  //匹配的次数
		int left=0, right=a.length-1;
		while(right&gt;left) {//计算出left最小值
			int mid=(left+right)/2;
			if(b&gt;a[mid]) {
				left = mid+1;
			}else if(b&lt;=a[mid]) {//等于的情况归为前半部分，往前找 直到找到最前面的一个
				right = mid;
			}
			System.out.println(left);
		}
//		left  3 4 5    		left 3 4 5      
		while(left&lt;a.length &amp;&amp;  a[left++]==b){//4 5 6
//		left  3 4 5			left 4 5 6
//		while( a[left++]==b &amp;&amp; left&lt;a.length){//4 5  执行两次没有6，因为6不能通过第二个条件
			
			counter++;	
//		left 4 5 6
			System.out.println(left);
			System.out.println(left-1);//在下标为此的地方匹配到了
		}
		return counter;		
	}
	public static void main(String[] args) {
		A01_my二分法 test = new A01_my二分法();
		int arr[] ={5,7,7,8,8,8};
		System.out.println(test.search(arr, 8));
	}
	
}

</code></pre> 
<h4><a id="2_1694"></a>2.冒泡排序查找</h4> 
<p>···待总结</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/930864f575399c642993c3392df540b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ssh 时报remove with ssh-keygen -f...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/469eb66152d72ed2e0c3df754f30a42b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WebView2 的初步集成与试用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>