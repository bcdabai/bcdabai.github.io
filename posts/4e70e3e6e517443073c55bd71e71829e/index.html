<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 迭代器Iterator的详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 迭代器Iterator的详解" />
<meta property="og:description" content="为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator).
对 Collection 进行迭代的类，称其为迭代器。还是面向对象的思想，专业对象做专业的事情，迭代器就是专门取出集合元素的对象。但是该对象比较特殊，不能直接创建对象（通过new），该对象是以内部类的形式存在于每个集合类的内部。
如何获取迭代器？Collection接口中定义了获取集合类迭代器的方法（iterator（）），所以所有的Collection体系集合都可以获取自身的迭代器。
1.Iterable
正是由于每一个容器都有取出元素的功能。这些功能定义都一样，只不过实现的具体方式不同（因为每一个容器的数据结构不一样）所以对共性的取出功能进行了抽取，从而出现了Iterator接口。而每一个容器都在其内部对该接口进行了内部类的实现。也就是将取出方式的细节进行封装。
Jdk1.5之后添加的新接口, Collection的父接口. 实现了Iterable的类就是可迭代的.并且支持增强for循环。该接口只有一个方法即获取迭代器的方法iterator（）可以获取每个容器自身的迭代器Iterator。（Collection）集合容器都需要获取迭代器（Iterator）于是在5.0后又进行了抽取将获取容器迭代器的iterator（）方法放入到了Iterable接口中。Collection接口进程了Iterable，所以Collection体系都具备获取自身迭代器的方法，只不过每个子类集合都进行了重写（因为数据结构不同）
2.Iterator iterator() 返回该集合的迭代器对象
该类主要用于遍历集合对象，该类描述了遍历集合的常见方法
1：java.lang. Itreable ---| Itreable 接口 实现该接口可以使用增强for循环
---| Collection 描述所有集合共性的接口
---| List接口 可以有重复元素的集合
---| Set接口 不可以有重复元素的集合
public interface Iterable&lt;T&gt;
Itreable 该接口仅有一个方法，用于返回集合迭代器对象。
Iterator&lt;T&gt; iterator() 返回集合的迭代器对象
Iterator接口定义的方法
Itreator	该接口是集合的迭代器接口类，定义了常见的迭代方法 1：boolean hasNext() 判断集合中是否有元素，如果有元素可以迭代，就返回true。 2： E next() 返回迭代的下一个元素，注意： 如果没有下一个元素时，调用 next元素会抛出NoSuchElementException 3： void remove() 从迭代器指向的集合中移除迭代器返回的最后一个元素（可选操 作）。 思考：为什么next方法的返回类型是Object的呢？ 为了可以接收任意类型的对象,那么返回的时候,不知道是什么类型的就定义为object
3.迭代器的遍历
第一种方式：while循环
public static void main(String[] args) { ArrayList list = new ArrayList(); // 增加：add() 将指定对象存储到容器中 list." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4e70e3e6e517443073c55bd71e71829e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-07-26T21:13:30+08:00" />
<meta property="article:modified_time" content="2016-07-26T21:13:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 迭代器Iterator的详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:14px; color:#ff0000">为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator).</span></p> 
<p><span style="font-size:14px">对 Collection 进行迭代的类，称其为迭代器。还是面向对象的思想，专业对象做专业的事情，迭代器就是专门取出集合元素的对象。但是该对象比较特殊，不能直接创建对象（通过new），该对象是以内部类的形式存在于每个集合类的内部。</span></p> 
<p><span style="font-size:14px">如何获取迭代器？Collection接口中定义了获取集合类迭代器的方法（iterator（）），所以所有的Collection体系集合都可以获取自身的迭代器。</span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="color:#ff0000"><span style="font-size:14px">1.</span><span style="font-size:14px">Iterable</span></span></p> 
<p><span style="font-size:14px">正是由于每一个容器都有取出元素的功能。这些功能定义都一样，只不过实现的具体方式不同（因为每一个容器的数据结构不一样）所以对共性的取出功能进行了抽取，从而出现了Iterator接口。而每一个容器都在其内部对该接口进行了内部类的实现。也就是将取出方式的细节进行封装。</span></p> 
<p><span style="font-size:14px"></span></p> 
<p>Jdk1.5<span style="font-family:宋体">之后添加的新接口</span><span style="font-family:Courier New">, Collection</span><span style="font-family:宋体">的父接口</span><span style="font-family:Courier New">. </span><span style="font-family:宋体">实现了</span><u>Iterable</u>的类就是可迭代的<span style="font-family:Courier New">.</span>并且支持增强<span style="font-family:Courier New">for</span><span style="font-family:宋体">循环</span>。该接口只有一个方法即获取迭代器的方法iterator（）可以获取每个容器自身的迭代器<span style="font-family:Courier New">Iterator</span><span style="font-family:宋体">。（</span><span style="font-family:Courier New">Collection</span><span style="font-family:宋体">）集合容器都需要获取迭代器（</span><span style="font-family:Courier New">Iterator</span><span style="font-family:宋体">）于是在</span><span style="font-family:Courier New">5.0</span><span style="font-family:宋体">后又进行了抽取将获取容器迭代器的</span>iterator（）方法放入到了<span style="font-family:Courier New">Iterable</span><span style="font-family:宋体">接口中。</span>Collection接口进程了Iterable<span style="font-family:宋体">，所以</span>Collection体系都具备获取自身迭代器的方法，只不过每个子类集合都进行了重写（因为数据结构不同）</p> 
<br> 
<p><span style="color:#ff0000"><span style="font-size:14px">2.</span><span style="font-size:14px">Iterator </span></span></p> 
<p><span style="font-size:14px">iterator() </span><span style="font-size:14px; font-family:宋体">返回该集合的迭代器对象</span></p> 
<p><span style="font-size:14px"></span></p> 
<p>该类主要用于遍历集合对象，该类描述了遍历集合的常见方法</p> 
<p>1<span style="font-family:宋体">：</span>java.lang. Itreable  </p> 
<p>---| Itreable      接口 实现该接口可以使用增强<span style="font-family:Courier New">for</span><span style="font-family:宋体">循环</span></p> 
<p>        ---| Collection 描述所有集合共性的接口</p> 
<p>             ---| List<span style="font-family:宋体">接口</span>     可以有重复元素的集合</p> 
<p>             ---| Set<span style="font-family:宋体">接口</span>     不可以有重复元素的集合</p> 
<p></p> 
<p>public interface Iterable&lt;T&gt;</p> 
<p>Itreable   该接口仅有一个方法，用于返回集合迭代器对象。</p> 
<p>  <span style="font-family:Courier New">Iterator&lt;T&gt; iterator()</span> 返回集合的迭代器对象</p> 
<p> </p> 
<p>Iterator<span style="font-family:宋体">接口定义的方法</span></p> 
<p><span style="font-family:宋体"></span></p> 
<pre><code class="language-java">Itreator	该接口是集合的迭代器接口类，定义了常见的迭代方法
	1：boolean hasNext() 
						判断集合中是否有元素，如果有元素可以迭代，就返回true。
	2： E next()  
						返回迭代的下一个元素，注意： 如果没有下一个元素时，调用
next元素会抛出NoSuchElementException

	3： void remove()
						从迭代器指向的集合中移除迭代器返回的最后一个元素（可选操
作）。</code></pre> 
<p></p> 
<p><span style="color:#ff0000">思考：为什么next方法的返回类型是Object的呢？ </span></p> 
<p>为了可以接收任意类型的对象,那么返回的时候,不知道是什么类型的就定义为object</p> 
<p><span style="color:#ff0000">3.迭代器的遍历</span></p> 
<p>第一种方式：while循环</p> 
<p></p> 
<pre><code class="language-java">public static void main(String[] args) {
		ArrayList list = new ArrayList();
		// 增加：add() 将指定对象存储到容器中
		list.add("计算机网络");
		list.add("现代操作系统");
		list.add("java编程思想");
		list.add("java核心技术");
		list.add("java语言程序设计");
		System.out.println(list);
		Iterator it = list.iterator();
		while (it.hasNext()) {
			String next = (String) it.next();
			System.out.println(next);
		}
	}</code></pre>第二种方式:for循环 
<p></p> 
<p></p> 
<pre><code class="language-java">public class Demo2 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		// 增加：add() 将指定对象存储到容器中
		list.add("计算机网络");
		list.add("现代操作系统");
		list.add("java编程思想");
		list.add("java核心技术");
		list.add("java语言程序设计");
		System.out.println(list);

		for (Iterator it = list.iterator(); it.hasNext();) {
             //迭代器的next方法返回值类型是Object，所以要记得类型转换。
			String next = (String) it.next();
			System.out.println(next);
		}
	}
}</code></pre> 
<p></p> 
<p>需要取出所有元素时，可以通过循环，java 建议使用for 循环。因为可以对内存进行一下优化。</p> 第三种方式：使用迭代器清空集合 
<p></p> 
<pre><code class="language-java">public class Demo1 {
	public static void main(String[] args) {
		Collection coll = new ArrayList();
		coll.add("aaa");
		coll.add("bbb");
		coll.add("ccc");
		coll.add("ddd");
		System.out.println(coll);
		Iterator it = coll.iterator();
		while (it.hasNext()) {
			it.next();
			it.remove();
		}
		System.out.println(coll);
	}
}</code></pre> 
<br> 
<br> 
<span style="color:#ff0000">需要注意的细节如下：</span> 
<p></p> 
<p></p> 
<p>细节一：</p> 
<p>如果迭代器的指针已经指向了集合的末尾，那么如果再调用next()会返回NoSuchElementException异常</p> 
<pre><code class="language-java">public class Demo2 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		// 增加：add() 将指定对象存储到容器中
		list.add("计算机网络");
		list.add("现代操作系统");
		list.add("java编程思想");
		list.add("java核心技术");
		list.add("java语言程序设计");
		System.out.println(list);

		Iterator it = list.iterator();
		while (it.hasNext()) {
			String next = (String) it.next();
			System.out.println(next);
		}
		// 迭代器的指针已经指向了集合的末尾
		// String next = (String) it.next();
		// java.util.NoSuchElementException
	}
}</code></pre> 
<p>细节二：</p> 
<p> 如果调用remove之前没有调用next是不合法的，会抛出IllegalStateException</p> 
<pre><code class="language-java">public class Demo2 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		// 增加：add() 将指定对象存储到容器中
		list.add("计算机网络");
		list.add("现代操作系统");
		list.add("java编程思想");
		list.add("java核心技术");
		list.add("java语言程序设计");
		System.out.println(list);

		Iterator it = list.iterator();
		while (it.hasNext()) {
			// 调用remove之前没有调用next是不合法的
			// it.remove();
			// java.lang.IllegalStateException
			String next = (String) it.next();
			System.out.println(next);
		}

	}
}</code></pre> 
<span style="color:#ff0000">4.迭代器的原理</span> 
<br> 
<p>查看<span style="font-family:Courier New">ArrayList</span><span style="font-family:宋体">源码</span></p> 
<pre><code class="language-java">private class Itr implements Iterator&lt;E&gt; {

		int cursor = 0;

		int lastRet = -1;

		int expectedModCount = modCount;

		public boolean hasNext() {
			return cursor != size();
		}

		public E next() {
			checkForComodification();
			try {
				E next = get(cursor);
				lastRet = cursor++;
				return next;
			} catch (IndexOutOfBoundsException e) {
				checkForComodification();
				throw new NoSuchElementException();
			}
		}

		public void remove() {
			if (lastRet == -1)
				throw new IllegalStateException();
			checkForComodification();

			try {
				AbstractList.this.remove(lastRet);
				if (lastRet &lt; cursor)
					cursor--;
				lastRet = -1;
				expectedModCount = modCount;
			} catch (IndexOutOfBoundsException e) {
				throw new ConcurrentModificationException();
			}
		}

		
	}</code></pre> 
<p><span style="color:#ff0000">注意：</span>1.在对集合进行迭代过程中，不允许出现迭代器以外的对元素的操作，因为这样会产生安全隐患，<span style="font-family:Courier New">java</span><span style="font-family:宋体">会抛出异常并发修改异常（</span>ConcurrentModificationException），普通迭代器只支持在迭代过程中的删除动作。</p> 
<p><span style="font-family:Courier New">     2.ConcurrentModificationException: </span> <span style="font-family:宋体">当一个集合在循环中即使用引用变量操作集合又使用迭代器操作集合对象， 会抛出该异常。</span></p> 
<pre><code class="language-java">public class Demo1 {
	public static void main(String[] args) {
		Collection coll = new ArrayList();
		coll.add("aaa");
		coll.add("bbb");
		coll.add("ccc");
		coll.add("ddd");
		System.out.println(coll);
		Iterator it = coll.iterator();
		while (it.hasNext()) {
			it.next();
			it.remove();
			coll.add("abc"); // 出现了迭代器以外的对元素的操作
		}
		System.out.println(coll);
	}
}</code></pre> 
<p>如果是<span style="font-family:Courier New">List</span><span style="font-family:宋体">集合，想要在迭代中操作元素可以使用</span><span style="font-family:Courier New">List</span><span style="font-family:宋体">集合的特有迭代器</span><span style="font-family:Courier New">ListIterator</span><span style="font-family:宋体">，该迭代器支持在迭代过程中，添加元素和修改元素。</span></p> 
<span style="color:#ff0000">5.List特有的迭代器ListIterator</span> 
<p></p> 
<p>public interface ListIterator extends Iterator</p> 
<p>ListIterator&lt;E&gt; listIterator()</p> 
<p></p> 
<pre><code class="language-java">---| Iterator
		hasNext()
		next()
		remove()
	   ------| ListIterator Iterator子接口 List专属的迭代器
                  add(E e)    将指定的元素插入列表（可选操作）。该元素直接插入到 next 返回的下一个元素的前面（如果有）
                  void set(E o)   用指定元素替换 next 或 previous 返回的最后一个元素
                  hasPrevious()    逆向遍历列表，列表迭代器有多个元素，则返回 true。
                  previous()       返回列表中的前一个元素。</code></pre> 
<p></p> 
<p>Iterator<span style="font-family:宋体">在迭代时，只能对元素进行获取</span><span style="font-family:Courier New">(next())</span><span style="font-family:宋体">和删除</span><span style="font-family:Courier New">(remove())</span><span style="font-family:宋体">的操作。</span></p> 
<p>对于 <span style="font-family:Courier New">Iterator </span><span style="font-family:宋体">的子接口</span><span style="font-family:Courier New">ListIterator </span><span style="font-family:宋体">在迭代</span><span style="font-family:Courier New">list </span><span style="font-family:宋体">集合时，还可以对元素进行添加</span></p> 
<p>(add(obj))<span style="font-family:宋体">，修改</span><span style="font-family:Courier New">set(obj)</span><span style="font-family:宋体">的操作。</span></p> 
<pre><code class="language-java">public class Demo2 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		// 增加：add() 将指定对象存储到容器中
		list.add("计算机网络");
		list.add("现代操作系统");
		list.add("java编程思想");
		list.add("java核心技术");
		list.add("java语言程序设计");
		System.out.println(list);
         // 获取List专属的迭代器
		ListIterator lit = list.listIterator();

		while (lit.hasNext()) {
			String next = (String) lit.next();
			System.out.println(next);
		}

	}
}</code></pre> 
<br> 
<p>倒序遍历</p> 
<pre><code class="language-java">public class Demo2 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		// 增加：add() 将指定对象存储到容器中
		list.add("计算机网络");
		list.add("现代操作系统");
		list.add("java编程思想");
		list.add("java核心技术");
		list.add("java语言程序设计");
		System.out.println(list);
        // 获取List专属的迭代器
		ListIterator lit = list.listIterator();
		while (lit.hasNext()) {
			String next = (String) lit.next();
			System.out.println(next);
		}
		System.out.println("***************");
		while (lit.hasPrevious()) {
			String next = (String) lit.previous();
			System.out.println(next);
		}

	}
}</code></pre> 
<p>Set<span style="font-family:宋体">方法：</span>用指定元素替换 next 或 previous 返回的最后一个元素</p> 
<pre><code class="language-java">public class Demo2 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		// 增加：add() 将指定对象存储到容器中
		list.add("计算机网络");
		list.add("现代操作系统");
		list.add("java编程思想");
		list.add("java核心技术");
		list.add("java语言程序设计");
		System.out.println(list);

		ListIterator lit = list.listIterator();
		lit.next(); // 计算机网络
		lit.next(); // 现代操作系统
		System.out.println(lit.next()); // java编程思想
		//用指定元素替换 next 或 previous 返回的最后一个元素
		lit.set("平凡的世界");// 将java编程思想替换为平凡的世界
		System.out.println(list);

	}
}</code></pre> 
<br> 
<p>add<span style="font-family:宋体">方法</span>将指定的元素插入列表，该元素直接插入到 <span style="font-family:Courier New"> next </span><span style="font-family:宋体">返回的元素的</span>后面</p> 
<p></p> 
<pre><code class="language-java">public class Demo2 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		// 增加：add() 将指定对象存储到容器中
		list.add("计算机网络");
		list.add("现代操作系统");
		list.add("java编程思想");
		list.add("java核心技术");
		list.add("java语言程序设计");
		System.out.println(list);

		ListIterator lit = list.listIterator();
		lit.next(); // 计算机网络
		lit.next(); // 现代操作系统
		System.out.println(lit.next()); // java编程思想
		// 将指定的元素插入列表，该元素直接插入到 next 返回的元素的后
		lit.add("平凡的世界");// 在java编程思想后添加平凡的世界
		System.out.println(list);

	}
}</code></pre> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/922edb67e7453ba77304be1b29087e89/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;和Java，绝不只是语法不同这么简单</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/85c5ada20540e73ed4597cdca210825a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java Set集合的详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>