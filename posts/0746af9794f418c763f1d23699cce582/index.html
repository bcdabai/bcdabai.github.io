<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>03-Thrift进阶 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="03-Thrift进阶" />
<meta property="og:description" content="Thrift进阶端口复用文件传输推送双向通信感受补充 Thrift进阶 在官网和大部分博客中，介绍的都是最简单的Hello World性质的东西。但是实际使用有很多问题考虑在内，比如目前的一个需求： - Thrift中一个服务对应一个端口，如果需要多个服务，则悲剧了，端口复用问题十分严重。 - 相比较，在ZeroC ICE中，不仅可以做到服务集合，而且端口复用是一个最最基础的用法。 - 下面我们来探究一下，端口复用问题。0.9.1版本之后原生支持。 集中解决三个问题：端口复用、文件续传、双向传输/推送。 参考Url 端口复用 1 端口复用 通过TMultiplexedxxxxx分别为服务器和客户端提供多服务共用端口的问题。 // 服务器修改, TMultiplexedProcessor shared_ptr&lt;TMultiplexedProcessor&gt; mprocessor(new TMultiplexedProcessor()); mprocessor-&gt;registerProcessor(&#34;mathService&#34;, processor); // 可以注册多个服务Processor TNonblockingServer _server(mprocessor, protocolFactory, 9090, threadManager); // 将原始的Processor替换 // 客户端, TMultiplexedProtocol shared_ptr&lt;TMultiplexedProtocol&gt; mProtocol(new TMultiplexedProtocol(clientProtocol, &#34;mathService&#34;)); // 添加一层Protocol MathServiceClient client(mProtocol); // 修改Protocol // 如果有多个Service则需要多个mProtocol，对应多个client。但是transport只用打开一次。 如果使用Golang，代码如下： 坑： golang库中的示例代码已经不可用，下面是修改后的！ 服务器使用NewTMultiplexedProcessor, 但是NewTMultiplexedProcessor2更强大，不会用::&gt;_&lt;:: // 服务器 package main import ( &#34;fmt&#34; &#34;mathservice&#34; &#34;os&#34; &#34;time&#34; &#34;git.apache.org/thrift.git/lib/go/thrift&#34; ) const ( NetWorkAddr = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0746af9794f418c763f1d23699cce582/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-07-26T17:34:13+08:00" />
<meta property="article:modified_time" content="2017-07-26T17:34:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">03-Thrift进阶</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <div class="toc"> 
  <ul><li><a href="#thrift%E8%BF%9B%E9%98%B6" rel="nofollow noopener noreferrer" target="_blank">Thrift进阶</a></li><li><a href="#1-%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8" rel="nofollow noopener noreferrer" target="_blank">端口复用</a></li><li><a href="#2-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93" rel="nofollow noopener noreferrer" target="_blank">文件传输</a></li><li><a href="#3-%E6%8E%A8%E9%80%81%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1" rel="nofollow noopener noreferrer" target="_blank">推送双向通信</a></li><li><a href="#4-%E6%84%9F%E5%8F%97" rel="nofollow noopener noreferrer" target="_blank">感受</a></li><li><a href="#5-%E8%A1%A5%E5%85%85" rel="nofollow noopener noreferrer" target="_blank">补充</a></li></ul> 
 </div> 
</div> 
<p></p> 
<h2 id="thrift进阶">Thrift进阶</h2> 
<p>在官网和大部分博客中，介绍的都是最简单的Hello World性质的东西。但是实际使用有很多问题考虑在内，比如目前的一个需求： <br> - Thrift中一个服务对应一个端口，如果需要多个服务，则悲剧了，端口复用问题十分严重。 <br> - 相比较，在ZeroC ICE中，不仅可以做到服务集合，而且端口复用是一个最最基础的用法。 <br> - 下面我们来探究一下，端口复用问题。0.9.1版本之后原生支持。 </p> 
<p>集中解决三个问题：端口复用、文件续传、双向传输/推送。 </p> 
<p>参考Url <a href="https://issues.apache.org/jira/browse/THRIFT-563" rel="nofollow noopener noreferrer" target="_blank">端口复用</a> </p> 
<h2 id="1-端口复用">1 端口复用</h2> 
<p>通过<code>TMultiplexedxxxxx</code>分别为服务器和客户端提供多服务共用端口的问题。 </p> 
<pre class="prettyprint"><code class="language-c++ hljs scss"><span class="hljs-comment">// 服务器修改, TMultiplexedProcessor</span>
shared_ptr&lt;TMultiplexedProcessor&gt; <span class="hljs-function">mprocessor(new <span class="hljs-function">TMultiplexedProcessor()</span>)</span>;
mprocessor-&gt;<span class="hljs-function">registerProcessor(<span class="hljs-string">"mathService"</span>, processor)</span>; <span class="hljs-comment">// 可以注册多个服务Processor</span>
TNonblockingServer _<span class="hljs-function">server(mprocessor, protocolFactory, <span class="hljs-number">9090</span>, threadManager)</span>; <span class="hljs-comment">// 将原始的Processor替换  </span>

<span class="hljs-comment">// 客户端, TMultiplexedProtocol  </span>
shared_ptr&lt;TMultiplexedProtocol&gt; <span class="hljs-function">mProtocol(new <span class="hljs-function">TMultiplexedProtocol(clientProtocol, <span class="hljs-string">"mathService"</span>)</span>)</span>; <span class="hljs-comment">// 添加一层Protocol  </span>
MathServiceClient <span class="hljs-function">client(mProtocol)</span>; <span class="hljs-comment">// 修改Protocol  </span>
<span class="hljs-comment">// 如果有多个Service则需要多个mProtocol，对应多个client。但是transport只用打开一次。  </span></code></pre> 
<p>如果使用Golang，代码如下： <br> <strong>坑：</strong> <em>golang库中的示例代码已经不可用，下面是修改后的！</em> <br> 服务器使用<code>NewTMultiplexedProcessor</code>, 但是<code>NewTMultiplexedProcessor2</code>更强大，不会用::&gt;_&lt;:: </p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// 服务器  </span>
<span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"mathservice"</span>
    <span class="hljs-string">"os"</span>
    <span class="hljs-string">"time"</span>
    <span class="hljs-string">"git.apache.org/thrift.git/lib/go/thrift"</span>
)

<span class="hljs-keyword">const</span> (
    NetWorkAddr = <span class="hljs-string">"127.0.0.1:9090"</span>
)

<span class="hljs-keyword">type</span> MyMathService <span class="hljs-keyword">struct</span> {
}

<span class="hljs-keyword">func</span> (this *MyMathService) Add(A <span class="hljs-typename">int32</span>, B <span class="hljs-typename">int32</span>) (r <span class="hljs-typename">int32</span>, err error) {
    r = A + B
    err = <span class="hljs-constant">nil</span>
    fmt.Println(<span class="hljs-string">"Add"</span>, A, B, <span class="hljs-string">"["</span>, time.Now(), <span class="hljs-string">"]"</span>)
    <span class="hljs-keyword">return</span>
}

<span class="hljs-keyword">func</span> main() {
    handler := &amp;MyMathService{}
    processor := mathservice.NewMathServiceProcessor(handler)

    serverTransport, err := thrift.NewTServerSocket(NetWorkAddr)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        fmt.Println(<span class="hljs-string">"Error!"</span>, err)
        os.Exit<span class="hljs-number">(1</span>)
    }
    transportFactory := thrift.NewTTransportFactory()
    framedtransportFactory := thrift.NewTFramedTransportFactory(transportFactory)
    protocolFactory := thrift.NewTBinaryProtocolFactoryDefault()
    mProcessor := thrift.NewTMultiplexedProcessor()
    mProcessor.RegisterProcessor(<span class="hljs-string">"mathService"</span>, processor)
    mProcessor.RegisterProcessor(<span class="hljs-string">"testService"</span>, processor)

    server := thrift.NewTSimpleServer4(mProcessor, serverTransport, framedtransportFactory, protocolFactory)
    fmt.Println(<span class="hljs-string">"thrift server in"</span>, NetWorkAddr)
    server.Serve()
}</code></pre> 
<p>客户端目前只有两种初始化方法，<code>NewMathServiceClientFactory</code>和<code>NewMathServiceClientProtocol</code>,之前使用第一种，但是这里只能使用第二种。 <br> <strong>坑：</strong> <em>官方示例代码中的NewMathServiceClient方法已经不存在！</em> </p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// 客户端</span>
<span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"mathservice"</span>
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"os"</span>
    <span class="hljs-string">"time"</span>
    <span class="hljs-string">"git.apache.org/thrift.git/lib/go/thrift"</span>
)

<span class="hljs-keyword">func</span> tt(strName <span class="hljs-typename">string</span>) {
    client_socket, _ := thrift.NewTSocket(<span class="hljs-string">"127.0.0.1:9090"</span>)
    <span class="hljs-comment">//client_transport := thrift.NewTBufferedTransport(client_socket, 512)</span>
    client_transport := thrift.NewTFramedTransport(client_socket)
    protocol := thrift.NewTBinaryProtocolTransport(client_transport)

    mProtocol := thrift.NewTMultiplexedProtocol(protocol, strName)

    client := mathservice.NewMathServiceClientProtocol(client_transport, mProtocol, mProtocol)

    <span class="hljs-keyword">if</span> err := client_transport.Open(); err != <span class="hljs-constant">nil</span> {
        fmt.Fprintln(os.Stderr, <span class="hljs-string">"Error opening socket"</span>, err)
        os.Exit<span class="hljs-number">(1</span>)
    }
    <span class="hljs-keyword">defer</span> client_transport.Close()

    <span class="hljs-keyword">for</span> i := <span class="hljs-typename">int32</span><span class="hljs-number">(0</span>); i &lt;<span class="hljs-number"> 100</span>; i++ {
        nRet, _ := client.Add(i, i)
        fmt.Println(strName, i, <span class="hljs-string">"Add"</span>, nRet)
        time.Sleep<span class="hljs-number">(100</span> *<span class="hljs-number"> 1000</span> *<span class="hljs-number"> 1000</span>)
    }
    fmt.Println(<span class="hljs-string">"Over!"</span>)
}

<span class="hljs-keyword">func</span> main() {
    <span class="hljs-keyword">go</span> tt(<span class="hljs-string">"mathService"</span>) <span class="hljs-comment">// 并行运行两个客户端</span>
    tt(<span class="hljs-string">"testService"</span>)
}</code></pre> 
<h2 id="2-文件传输">2 文件传输</h2> 
<p>Thrift的坑很大，比如这里。其实有很多关于文件处理的类，但是没有完善的文档说明，所以，基本没法用。 <br> 这里，我们使用一种稍显麻烦，但是比较通用的方案处理。 </p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// 接口定义文件</span>
<span class="hljs-keyword">struct</span> FileChunk{
   <span class="hljs-number"> 1</span>:<span class="hljs-typename">string</span> fileName
   <span class="hljs-number"> 2</span>:i64 offset
   <span class="hljs-number"> 3</span>:i64 size
   <span class="hljs-number"> 4</span>:binary data
}
service FileIface{
    i64 uploadFile<span class="hljs-number">(1</span>:FileChunk fileChunk)
}</code></pre> 
<p><strong>原理：</strong>客户端将本地文件分成很多块，每次上传一个小块。（可扩展为断点续传） <br> <strong>瓶颈：</strong>每次操作都需要打开关闭文件，这里会成为I/O瓶颈。优化？ </p> 
<p>优化思路： <br> 1. 文件Open后建立Handle Map，不要每次打开。制作一个超时关闭Handle功能。 <br> 2. 增加文件信息查询接口，后续打开可以先查询，后传输。以便断点续传。 <br> 3. 服务器增加锁机制，以免读写问题。 <br> 4. 服务器针对小文件，增加缓冲模式。提高写性能。 <br> 5. 读文件接口同样适用。 </p> 
<p>具体代码不实现了。 </p> 
<h2 id="3-推送双向通信">3 推送/双向通信</h2> 
<p>Thrift默认是被动服务器，即只能处理客户端向服务器主动请求，服务器无法主动向客户端发数据。 <br> 如果需要Pub/Sub订阅服务，则最简单是使用MQ一类的单独服务器。 </p> 
<p><strong>原理原文：</strong> <a href="http://joelpm.com/2009/04/03/thrift-bidirectional-async-rpc.html" rel="nofollow noopener noreferrer" target="_blank">http://joelpm.com/2009/04/03/thrift-bidirectional-async-rpc.html</a> <br> <strong>翻译参考：</strong> <a href="http://blog.csdn.net/qq_27989757/article/details/50725973" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/qq_27989757/article/details/50725973</a> <br> <strong>Java实现：</strong> <a href="http://www.w2bc.com/article/189387" rel="nofollow noopener noreferrer" target="_blank">http://www.w2bc.com/article/189387</a> </p> 
<p>虽然这样，但是由于版本和用词等很含糊，也没有C++的版本，所以，在自习研读其他语言的代码后，做出如下修改，并且实验成功！ </p> 
<p><strong>中心思想是：</strong>两端分别使用已经建立好的连接，在客户端模拟服务器，在服务器模拟客户端。 </p> 
<p>以下代码可能是全球独一份啦！！！！ </p> 
<pre class="prettyprint"><code class="language-c++ hljs cpp"><span class="hljs-comment">// msgPush.thrift</span>
service CallbackService{
    oneway <span class="hljs-keyword">void</span> Push(<span class="hljs-number">1</span>: <span class="hljs-built_in">string</span> msg); 
}

<span class="hljs-comment">// 服务器，支持一对多发送  </span>
<span class="hljs-preprocessor">#include "CallbackService.h"</span>
<span class="hljs-preprocessor">#include &lt;thrift/protocol/TBinaryProtocol.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;thrift/server/TThreadPoolServer.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;thrift/server/TThreadedServer.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;thrift/transport/TServerSocket.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;thrift/transport/TBufferTransports.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift::protocol;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift::transport;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift::server;

<span class="hljs-keyword">using</span> boost::<span class="hljs-built_in">shared_ptr</span>;

<span class="hljs-keyword">void</span> PushThread(<span class="hljs-keyword">const</span> TConnectionInfo&amp; connInfo) {
    <span class="hljs-keyword">int</span> nMsgCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">char</span> buff[<span class="hljs-number">128</span>];
    <span class="hljs-built_in">shared_ptr</span>&lt;CallbackServiceClient&gt; client(<span class="hljs-keyword">new</span> CallbackServiceClient(connInfo.input, connInfo.output));

    <span class="hljs-keyword">while</span> (nMsgCount&lt;<span class="hljs-number">100</span>)
    {
        Sleep(<span class="hljs-number">500</span>);
        nMsgCount++;
        <span class="hljs-built_in">sprintf</span>(buff, <span class="hljs-string">"Hello, msg %d!\n"</span>, nMsgCount);
        <span class="hljs-comment">// run in thread</span>
        <span class="hljs-built_in">printf</span>(buff);
        <span class="hljs-keyword">try</span>{
            client-&gt;Push(buff);
        }
        <span class="hljs-keyword">catch</span> (TException&amp; e) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error:  %s\n"</span>, e.what());
        }

    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Server Send Thread Exit!\n"</span>);
}

<span class="hljs-keyword">class</span> MyTProcessorFactory : <span class="hljs-keyword">public</span> CallbackServiceProcessorFactory {
<span class="hljs-keyword">public</span>:
    MyTProcessorFactory(<span class="hljs-keyword">const</span> ::boost::<span class="hljs-built_in">shared_ptr</span>&lt; CallbackServiceIfFactory &gt;&amp; handlerFactory) : CallbackServiceProcessorFactory(handlerFactory){

    }
    boost::<span class="hljs-built_in">shared_ptr</span>&lt;TProcessor&gt; getProcessor(<span class="hljs-keyword">const</span> TConnectionInfo&amp; connInfo) override
    {
        <span class="hljs-comment">// 每有一个客户端连接上，就会有一个getProcessor调用，然后单独通信  </span>
        <span class="hljs-built_in">std</span>::thread* t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">std</span>::thread(PushThread, connInfo);
        t-&gt;detach();
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"MyTProcessorFactory getProcessor~\n"</span>);
        <span class="hljs-keyword">return</span> CallbackServiceProcessorFactory::getProcessor(connInfo);
    }
};

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv) {
    <span class="hljs-keyword">int</span> port = <span class="hljs-number">9090</span>;
    <span class="hljs-comment">//shared_ptr&lt;CallbackServiceHandler&gt; handler(new CallbackServiceHandler());</span>
    <span class="hljs-built_in">shared_ptr</span>&lt;CallbackServiceIfFactory&gt; processorFactory(<span class="hljs-keyword">new</span> CallbackServiceIfSingletonFactory(NULL));
    <span class="hljs-built_in">shared_ptr</span>&lt;MyTProcessorFactory&gt; myProcessorFactory(<span class="hljs-keyword">new</span> MyTProcessorFactory(processorFactory));
    <span class="hljs-built_in">shared_ptr</span>&lt;TServerTransport&gt; serverTransport(<span class="hljs-keyword">new</span> TServerSocket(port));
    <span class="hljs-built_in">shared_ptr</span>&lt;TTransportFactory&gt; transportFactory(<span class="hljs-keyword">new</span> TBufferedTransportFactory());
    <span class="hljs-built_in">shared_ptr</span>&lt;TProtocolFactory&gt; protocolFactory(<span class="hljs-keyword">new</span> TBinaryProtocolFactory());

    TThreadedServer server(myProcessorFactory, serverTransport, transportFactory, protocolFactory);
    server.serve();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// 客户端  </span>
<span class="hljs-preprocessor">#include "CallbackService.h"</span>
<span class="hljs-preprocessor">#include &lt;thrift/protocol/TBinaryProtocol.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;thrift/transport/TSocket.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;thrift/transport/TBufferTransports.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;thrift/TProcessor.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift::protocol;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift::transport;

<span class="hljs-keyword">using</span> boost::<span class="hljs-built_in">shared_ptr</span>;

<span class="hljs-keyword">class</span> CallbackServiceImply : <span class="hljs-keyword">public</span> CallbackServiceIf {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> msgCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">void</span> Push(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; msg) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[CallbackService] Push %d %s\n"</span>, msgCount++, msg.c_str());
    }
};

<span class="hljs-keyword">void</span> RunRecv(<span class="hljs-built_in">shared_ptr</span>&lt;TProtocol&gt; clientProtocol) {
    <span class="hljs-keyword">int</span> nLoopCount = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">shared_ptr</span>&lt;CallbackServiceImply&gt; clientCallback(<span class="hljs-keyword">new</span> CallbackServiceImply());
    <span class="hljs-built_in">shared_ptr</span>&lt;CallbackServiceProcessor&gt; clientProcessor(<span class="hljs-keyword">new</span> CallbackServiceProcessor(clientCallback));
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">while</span> (clientProcessor-&gt;process(clientProtocol, clientProtocol, NULL))
        {
            nLoopCount++;
            <span class="hljs-keyword">if</span> ( nLoopCount&gt;<span class="hljs-number">10000</span> )
            {
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">catch</span> (TException* e)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: %s\n"</span>, e-&gt;what());
    }

}

<span class="hljs-keyword">int</span> main2(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv) {
    <span class="hljs-keyword">int</span> port = <span class="hljs-number">9090</span>;

    <span class="hljs-built_in">shared_ptr</span>&lt;TTransport&gt; clientSocket(<span class="hljs-keyword">new</span> TSocket(<span class="hljs-string">"127.0.0.1"</span>, port));
    <span class="hljs-built_in">shared_ptr</span>&lt;TTransport&gt; clientTransport(<span class="hljs-keyword">new</span> TBufferedTransport(clientSocket));
    <span class="hljs-built_in">shared_ptr</span>&lt;TProtocol&gt; clientProtocol(<span class="hljs-keyword">new</span> TBinaryProtocol(clientTransport));

    CallbackServiceClient client(clientProtocol);

    <span class="hljs-keyword">try</span>
    {
        clientTransport-&gt;open();
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Open Remote Transport, wait call it!\n"</span>);
        <span class="hljs-comment">// start thread</span>
        <span class="hljs-built_in">std</span>::thread* t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">std</span>::thread(RunRecv, clientProtocol);
        t-&gt;join(); <span class="hljs-comment">// wait</span>
    }
    <span class="hljs-keyword">catch</span> (TException&amp; e)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ERROR:%s\n"</span>, e.what());
    }
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>在这里，再一次地感受到<code>Thrift</code>无情地被<code>ZeroC ICE</code>秒杀了。ZeroC在Pub/Sub和双向通讯已经甩Thrift无数条街，尽管ZeroC已经开源，可惜官方不给力，对新语言的支持跟进速度，以及扩展开发都没有详细的文档，实在是一大遗憾（捶胸顿足，有木有！！）。 </p> 
<p><strong>优化：</strong>完善方案完全可以借鉴ZeroC的做法。这里先说点简单优化： <br> 1. 使用端口复用，然后专门增加一个双向通信的接口。 <br> 2. 在<code>getProcessor</code>中添加Client，对发送的消息队列，通过单独的线程(池)集中一对多发送和Client管理。 <br> 3. 增加发送异常处理，处理异常次数，管理Client列表，从而优化发送效率。 <br> 4. 整体加心跳?重连?(正规产品还是需要的)</p> 
<h2 id="4-感受">4 感受</h2> 
<p>C++写这些服务，真的很麻烦，不管是库的配置还是线程、内存管理，明显能感受到巨大的工作量和优化的坑。如果能有Golang类型的并行语言完全替代C++，真的是开发人员的一大福音。 </p> 
<p>后续会慢慢将1和3重点关注，开发出实际应用的可用项目来。 </p> 
<p>PS：许多国人很自私，许多已经研究出来的东西不愿意分享，加上国内的大环境，真的是一种悲哀~ </p> 
<h2 id="5-补充">5 补充</h2> 
<blockquote> 
 <p>Golang在网络和并发做的比较好，其他方面真的一般般。这里将双向通信改为Golang版本，自此结束。 </p> 
</blockquote> 
<p>服务器的核心思想是重载getProcessor接口，在服务器端通过已经建立的Transport创建通信用客户端，然后用它进行通信。 </p> 
<p>客户端的核心思想是Open通信后，使用现有的Protocol创建Processor进行Push的数据解析(回调)。 </p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// 服务器  </span>
<span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"msgpush"</span>
    <span class="hljs-string">"os"</span>

    <span class="hljs-string">"time"</span>

    <span class="hljs-string">"git.apache.org/thrift.git/lib/go/thrift"</span>
)

<span class="hljs-keyword">func</span> PushThread(trans thrift.TTransport) {
    nMsgCount :=<span class="hljs-number"> 0</span>
    <span class="hljs-keyword">var</span> buff <span class="hljs-typename">string</span>
    callbackClient := msgpush.NewCallbackServiceClientFactory(trans,
        thrift.NewTBinaryProtocolFactoryDefault())
    <span class="hljs-keyword">for</span> nMsgCount =<span class="hljs-number"> 0</span>; nMsgCount &lt;<span class="hljs-number"> 100</span>; nMsgCount++ {
        time.Sleep<span class="hljs-number">(500</span> * time.Millisecond)
        buff = fmt.Sprintf(<span class="hljs-string">"Hello, msg %v!"</span>, nMsgCount)
        fmt.Println(buff)
        callbackClient.Push(buff)
    }
    fmt.Println(<span class="hljs-string">"Server Send Thread Exit!\n"</span>)

}

<span class="hljs-comment">// myProcessorFactory 实现 thrift.TProcessorFactory 的 getProcessor接口</span>
<span class="hljs-keyword">type</span> myProcessorFactory <span class="hljs-keyword">struct</span> {
    processor thrift.TProcessor
}

<span class="hljs-keyword">func</span> NewmyTProcessorFactory(p thrift.TProcessor) thrift.TProcessorFactory {
    <span class="hljs-keyword">return</span> &amp;myProcessorFactory{processor: p}
}

<span class="hljs-keyword">func</span> (p *myProcessorFactory) GetProcessor(trans thrift.TTransport) thrift.TProcessor {
    <span class="hljs-comment">// 每有一个客户端连接上，就会有一个getProcessor调用，然后单独通信</span>
    <span class="hljs-keyword">go</span> PushThread(trans)
    fmt.Println(<span class="hljs-string">"MyTProcessorFactory getProcessor~\n"</span>)
    <span class="hljs-keyword">return</span> p.processor
}

<span class="hljs-keyword">func</span> main() {
    fmt.Println(<span class="hljs-string">"Callback Service start..."</span>)
    sock, err := thrift.NewTServerSocket(<span class="hljs-string">"127.0.0.1:9090"</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        fmt.Println(<span class="hljs-string">"Socket Bind Failed!"</span>)
        os.Exit<span class="hljs-number">(0</span>)
    }
    transFactory := thrift.NewTTransportFactory()
    framedTransFactory := thrift.NewTFramedTransportFactory(transFactory)
    protocolFactory := thrift.NewTBinaryProtocolFactoryDefault()

    processor1 := msgpush.NewCallbackServiceProcessor(<span class="hljs-constant">nil</span>)
    processorFactory := NewmyTProcessorFactory(processor1)

    _server := thrift.NewTSimpleServerFactory4(processorFactory, sock,
        framedTransFactory, protocolFactory)

    _server.Serve()
}

<span class="hljs-comment">// 客户端  </span>
<span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"msgpush"</span>
    <span class="hljs-string">"os"</span>

    <span class="hljs-string">"git.apache.org/thrift.git/lib/go/thrift"</span>
)

<span class="hljs-keyword">type</span> MyMsgPushService <span class="hljs-keyword">struct</span> {
    msgCount <span class="hljs-typename">int</span>
}

<span class="hljs-keyword">func</span> (p *MyMsgPushService) Push(msg <span class="hljs-typename">string</span>) (err error) {
    p.msgCount++
    fmt.Printf(<span class="hljs-string">"[Go CallbackService] Push %v %v\n"</span>, p.msgCount, msg)
    <span class="hljs-keyword">return</span> err
}

<span class="hljs-keyword">func</span> RunRecv(_client *msgpush.CallbackServiceClient) {
    <span class="hljs-keyword">var</span> nLoopCount <span class="hljs-typename">int</span>
    clientCallback := &amp;MyMsgPushService{}
    clientProcessor := msgpush.NewCallbackServiceProcessor(clientCallback)

    <span class="hljs-keyword">for</span> {
        clientProcessor.Process(_client.InputProtocol, _client.OutputProtocol)
        nLoopCount++
        <span class="hljs-keyword">if</span> nLoopCount &gt;<span class="hljs-number"> 10000</span> {
            <span class="hljs-keyword">break</span>
        }
    }
    fmt.Println(<span class="hljs-string">"Client RunRecv exit!"</span>)

}

<span class="hljs-keyword">func</span> main() {
    fmt.Println(<span class="hljs-string">"Callback Client start..."</span>)
    sock, err := thrift.NewTSocket(<span class="hljs-string">"127.0.0.1:9090"</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        fmt.Println(<span class="hljs-string">"Socket connect Failed!"</span>)
        os.Exit<span class="hljs-number">(0</span>)
    }

    client_transport := thrift.NewTFramedTransport(sock)
    protocolFactory := thrift.NewTBinaryProtocolFactoryDefault()

    _client := msgpush.NewCallbackServiceClientFactory(client_transport, protocolFactory)

    <span class="hljs-keyword">if</span> err := client_transport.Open(); err != <span class="hljs-constant">nil</span> {
        fmt.Println(<span class="hljs-string">"Error in open Socket"</span>)
        os.Exit<span class="hljs-number">(0</span>)
    }
    <span class="hljs-keyword">defer</span> client_transport.Close()

    <span class="hljs-comment">// wait</span>
    RunRecv(_client)
}</code></pre> 
<p>Thrift坑实在是有点多，下一步会尝试和研究Hprose这个框架，最终目的是替代ZeroC。 </p> 
<p>理想方案：<strong>Rust + Hprose</strong>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2194eeac3bc3828bdb21e33e9185bf8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">javafx中radiobutton使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4504a9f344b2f0c31623d7d28aed61bd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Bean 后处理器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>