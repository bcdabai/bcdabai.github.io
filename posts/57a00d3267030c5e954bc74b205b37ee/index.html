<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>秒懂设计模式之状态模式（State Pattern） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="秒懂设计模式之状态模式（State Pattern）" />
<meta property="og:description" content="[版权申明] 非商业目的注明出处可自由转载
博文地址：https://blog.csdn.net/ShuSheng0007/article/details/116375477
出自：shusheng007
设计模式汇总篇，一定要收藏：
永不磨灭的设计模式（有这一篇真够了，拒绝标题党）
文章目录 概述类型难度 定义使用场景UML类图实例第一，定义一个状态接口第二，定义一个物流Context类第三，实现各种状态类第四， 客户端使用 技术要点总结优缺点优点缺点 状态模式与策略模式总结 概述 状态模式在日常开发中是一个非常实用的模式，可以将你的代码逼格迅速提升一个档次，所以让我们开始今天的卓越之旅吧。
类型 行为型（behavioral）
难度 3颗星
定义 当一个对象内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
定义对于初学者没啥用，因为字都认识却无法理解其中的含义。必须等学完了，回过头来看才能更加深刻的理解其含义
使用场景 你发现你的代码里面存在一个很长的if else列表，而这些分支都是因为不同状态下执行的操作不一样时考虑使用此模式
UML类图 照例先上一张俺手撕的UML类图
从上图可见，状态模式共有3个角色
State 是一个接口，封装了状态及其行为
ConcreteState X State的实现类，表示具体的状态
Context 保持并切换各个状态，其持有一个State的引用。它将依赖状态的各种操作委托给不同的状态对象执行。其负责与客户端交互
实例 最近王二狗又要过生日了，近两年他内心中是非常抗拒过生日的，因为每过一个生日就意味着自己又老一岁，离被辞退的35岁魔咒又近了一步。可惜时间是不以人的意志为转移的，任何人都阻止不了时间的流逝，所以该过还的过。令二狗比较欣慰的时，这次过生日老婆送了他一个自己一直想要的机械键盘作为生日礼物… 翠花于是在二狗生日前3天在京东上下了一个单…
自从下单以来，二狗天天看物流状态信息，心心念念着自己的机械键盘快点到…
这个物流系统就很适合使用状态模式来开发，因为此过程存在很多不同的状态，例如接单，出库，运输，送货，收货，评价等等。而订单在每个不同的状态下的操作可能都不一样，例如在接单状态下，商家就需要通知仓库拣货，通知用户等等操作，其他状态类似
下面是实例的UML类图
第一，定义一个状态接口 此接口定义各个状态的统一操作接口
public interface LogisticsState { void doAction(JdLogistics context); } 第二，定义一个物流Context类 此类持有一个LogisticsState 的引用，负责在流程中保持并切换状态
public class JdLogistics { private LogisticsState logisticsState; public void setLogisticsState(LogisticsState logisticsState) { this.logisticsState = logisticsState; } public LogisticsState getLogisticsState() { return logisticsState; } public void doAction(){ Objects." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/57a00d3267030c5e954bc74b205b37ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-03T14:09:08+08:00" />
<meta property="article:modified_time" content="2021-05-03T14:09:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">秒懂设计模式之状态模式（State Pattern）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>[版权申明] 非商业目的注明出处可自由转载<br> 博文地址：https://blog.csdn.net/ShuSheng0007/article/details/116375477<br> 出自：shusheng007</p> 
</blockquote> 
<p>设计模式汇总篇，一定要收藏：</p> 
<p><a href="https://blog.csdn.net/ShuSheng0007/article/details/115980889">永不磨灭的设计模式（有这一篇真够了，拒绝标题党）</a></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_11" rel="nofollow">概述</a></li><li><ul><li><a href="#_14" rel="nofollow">类型</a></li><li><a href="#_17" rel="nofollow">难度</a></li></ul> 
  </li><li><a href="#_20" rel="nofollow">定义</a></li><li><a href="#_25" rel="nofollow">使用场景</a></li><li><a href="#UML_28" rel="nofollow">UML类图</a></li><li><a href="#_46" rel="nofollow">实例</a></li><li><ul><li><a href="#_58" rel="nofollow">第一，定义一个状态接口</a></li><li><a href="#Context_67" rel="nofollow">第二，定义一个物流Context类</a></li><li><a href="#_89" rel="nofollow">第三，实现各种状态类</a></li><li><a href="#__111" rel="nofollow">第四， 客户端使用</a></li></ul> 
  </li><li><a href="#_144" rel="nofollow">技术要点总结</a></li><li><a href="#_155" rel="nofollow">优缺点</a></li><li><ul><li><a href="#_156" rel="nofollow">优点</a></li><li><a href="#_160" rel="nofollow">缺点</a></li></ul> 
  </li><li><a href="#_163" rel="nofollow">状态模式与策略模式</a></li><li><a href="#_170" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_11"></a>概述</h2> 
<p>状态模式在日常开发中是一个非常实用的模式，可以将你的代码逼格迅速提升一个档次，所以让我们开始今天的卓越之旅吧。</p> 
<h3><a id="_14"></a>类型</h3> 
<p>行为型（behavioral）</p> 
<h3><a id="_17"></a>难度</h3> 
<p>3颗星</p> 
<h2><a id="_20"></a>定义</h2> 
<blockquote> 
 <p>当一个对象内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p> 
</blockquote> 
<p>定义对于初学者没啥用，因为字都认识却无法理解其中的含义。必须等学完了，回过头来看才能更加深刻的理解其含义</p> 
<h2><a id="_25"></a>使用场景</h2> 
<p>你发现你的代码里面存在一个很长的<code>if else</code>列表，而这些分支都是因为不同状态下执行的操作不一样时考虑使用此模式</p> 
<h2><a id="UML_28"></a>UML类图</h2> 
<p>照例先上一张俺手撕的UML类图</p> 
<p><img src="https://images2.imgbox.com/1d/fb/A0B1nl3k_o.jpg" alt="在这里插入图片描述"><br> 从上图可见，状态模式共有3个角色</p> 
<ul><li>State</li></ul> 
<p>是一个接口，封装了状态及其行为</p> 
<ul><li>ConcreteState X</li></ul> 
<p>State的实现类，表示具体的状态</p> 
<ul><li>Context</li></ul> 
<p>保持并切换各个状态，其持有一个State的引用。它将依赖状态的各种操作委托给不同的状态对象执行。其负责与客户端交互</p> 
<h2><a id="_46"></a>实例</h2> 
<p>最近王二狗又要过生日了，近两年他内心中是非常抗拒过生日的，因为每过一个生日就意味着自己又老一岁，离被辞退的35岁魔咒又近了一步。可惜时间是不以人的意志为转移的，任何人都阻止不了时间的流逝，所以该过还的过。令二狗比较欣慰的时，这次过生日老婆送了他一个自己一直想要的机械键盘作为生日礼物… 翠花于是在二狗生日前3天在京东上下了一个单…</p> 
<p>自从下单以来，二狗天天看物流状态信息，心心念念着自己的机械键盘快点到…</p> 
<p>这个物流系统就很适合使用状态模式来开发，因为此过程存在很多不同的状态，例如接单，出库，运输，送货，收货，评价等等。而订单在每个不同的状态下的操作可能都不一样，例如在接单状态下，商家就需要通知仓库拣货，通知用户等等操作，其他状态类似</p> 
<p>下面是实例的UML类图<br> <img src="https://images2.imgbox.com/9e/6f/aEd2w8zS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_58"></a>第一，定义一个状态接口</h3> 
<p>此接口定义各个状态的统一操作接口</p> 
<pre><code>public interface LogisticsState {
    void doAction(JdLogistics context);
}
</code></pre> 
<h3><a id="Context_67"></a>第二，定义一个物流Context类</h3> 
<p>此类持有一个<code>LogisticsState</code> 的引用，负责在流程中保持并切换状态</p> 
<pre><code>public class JdLogistics {
    private LogisticsState logisticsState;

    public void setLogisticsState(LogisticsState logisticsState) {
        this.logisticsState = logisticsState;
    }

    public LogisticsState getLogisticsState() {
        return logisticsState;
    }
    
    public void doAction(){
        Objects.requireNonNull(logisticsState);
        logisticsState.doAction(this);
    }
}
</code></pre> 
<h3><a id="_89"></a>第三，实现各种状态类</h3> 
<ul><li>接单状态类，其需要实现<code>LogisticsState</code>接口</li></ul> 
<pre><code>public class OrderState implements LogisticsState {
    @Override
    public void doAction(JdLogistics context) {
        System.out.println("商家已经接单，正在处理中...");
    }
}
</code></pre> 
<ul><li>出库状态类</li></ul> 
<pre><code>public class ProductOutState implements LogisticsState {
    @Override
    public void doAction(JdLogistics context) {
        System.out.println("商品已经出库...");
    }
}
</code></pre> 
<p>依次类推，可以建立任意多个状态类</p> 
<h3><a id="__111"></a>第四， 客户端使用</h3> 
<pre><code>public class StateClient {

    public void buyKeyboard() {
        //状态的保持与切换者
        JdLogistics jdLogistics = new JdLogistics();

        //接单状态
        OrderState orderState = new OrderState();
        jdLogistics.setLogisticsState(orderState);
        jdLogistics.doAction();

        //出库状态
        ProductOutState productOutState = new ProductOutState();
        jdLogistics.setLogisticsState(productOutState);
        jdLogistics.doAction();

        //运输状态
        TransportState transportState = new TransportState();
        jdLogistics.setLogisticsState(transportState);
        jdLogistics.doAction();
    }
}
</code></pre> 
<p>输出结果：</p> 
<pre><code>商家已经接单，正在处理中...
商品已经出库...
商品正在运往天津分发中心
</code></pre> 
<p>可见，我们将每个状态下要做的具体动作封装到了每个状态类中，我们只需要切换不同的状态即可。如果不使用状态模式，我们的代码中可能会出现很长的<code>if else</code>列表，这样就不便于扩展和修改了。</p> 
<h2><a id="_144"></a>技术要点总结</h2> 
<ul><li>必须要有一个Context类，这个类持有State接口，负责保持并切换当前的状态。</li><li>状态模式没有定义在哪里进行状态转换，本例是在Context类进行的，也有人在具体的State类中转换</li></ul> 
<p><strong>当使用Context类切换状态时</strong>，状态类之间互相不认识，他们直接的依赖关系应该由客户端负责。<br> 例如，只有在接单状态的操作完成后才应该切换到出库状态，那么出库状态就对接单状态有了依赖，这个依赖顺序应该由客户端负责，而不是在状态内判断。</p> 
<p><strong>当使用具体的State类切换时</strong>，状态直接就可能互相认识，一个状态执行完就自动切换到了另一个状态去了</p> 
<h2><a id="_155"></a>优缺点</h2> 
<h3><a id="_156"></a>优点</h3> 
<ul><li>增强了程序的可扩展性，因为我们很容易添加一个State</li><li>增强了程序的封装性，每个状态的操作都被封装到了一个状态类中</li></ul> 
<h3><a id="_160"></a>缺点</h3> 
<p>类变多了</p> 
<h2><a id="_163"></a>状态模式与策略模式</h2> 
<p>状态模式与策略模式的UML类图都是一样的，从表面上看他们非常相似。特别是将状态切换任务放在Context中做的时候就更像了，但是其背后的思想却非常不同。</p> 
<ul><li><strong>策略模式</strong>定义了一组可互相代替的算法，这一组算法对象完成的是同一个任务，只是使用的方式不同，例如同样是亿万富翁，马云通过卖东西实现，而王思聪通过继承实现。</li><li><strong>状态模式</strong>不同的状态完成的任务完全不一样。</li></ul> 
<h2><a id="_170"></a>总结</h2> 
<p>设计模式值得你刻意练习！</p> 
<p>最后，如果你从本文中有所收获，可否点赞转发支持一下博主，你小小的鼓励，是激发博主持续写作的动力…</p> 
<p><strong>GitHub源码地址</strong>：<a href="https://github.com/shusheng007/design-patterns">design-patterns</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32e34fc5e5f88ff392765d6029f86aeb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2021-05-03</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f040f569ce4d46c28b813a99758f5630/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">彻底搞懂String：字符串常量池</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>