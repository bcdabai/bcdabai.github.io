<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>EA-可执行状态机-延迟事件模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="EA-可执行状态机-延迟事件模式" />
<meta property="og:description" content="前言
因为最近在做EA的模型搭建，查阅资料的时候，发现这篇示例说明比较实用，但是英文版理解起来比较慢，中文版在火龙果网站有，但是机翻增加了理解难度，因此，我打算整理一下中文版的翻译，作为学习记录。
火龙果网站中的EA软件参考文档【中文】
———————————————————————————
Enterprise Architect支持延迟事件模式。
在状态中创建延迟事件：
为状态（state）创建自我过渡(self transition)。将过渡的种类更改为“内部过渡”。指定触发器（Trigger）成为你需要延迟的事件。在“效果”(Effect)字段中，键入“ defer（）;”。 进行模拟：
打开&#34;模拟窗口&#34;:选择“模拟&gt;动态模拟&gt;模拟器&gt;打开模拟窗口”。
打开&#34;模拟事件窗口&#34;:选择“模拟&gt;动态模拟&gt;事件”。 模拟器事件窗口（Simulation Event Window）可帮助您触发事件；双击“等待触发器”列中的触发器。
Simulation窗口以文本形式显示执行。您可以在Simulator命令行中键入“ dump”，以显示队列中延迟了多少个事件。
输出可能类似于以下内容： 24850060]事件池：[NEW，NEW，NEW，NEW，NEW，]
延迟事件示例 本示例显示了使用“延迟事件”的模型，“模拟事件”窗口显示了所有可用事件。
我们首先建立上下文(context)（包含状态机的类中元素），在简单的上下文中模拟它们，并从外部引发事件；然后在使用Send事件机制的客户端-服务器（client-server）上下文中进行仿真。
创建上下文和状态机 创建服务器上下文
创建一个类图：
一个类元素：TransactionServer ，向其中添加一个状态机，名为ServerStateMachine一个类元素TestClient ，向其中添加一个状态机，名为ClientStateMachine从TestClient到TransactionServer的关联(association)，目标角色名为server。 为 ServerStateMachine 建模
向状态机图中添加一个初始化结点，名为Initial ，然后过渡到状态idle转换（事件NEW_REQUEST作为触发器）到状态busy过渡（使用事件QUIT作为触发）到最终状态Final转换（事件AUTHORIZED作为触发器）到idle转换为繁忙状态 （事件NEW_REQUEST作为触发器，defer（）；作为效果（effect）） ClientStateMachine的 建模
在状态机图中添加一个初始化结点initial，转换到状态State0转换（以事件RUN_TEST作为触发器）到状态State1 。过渡到状态State2 （转移中的效果effect为：％SEND_EVENT（“ NEW_REQUEST”，CONTEXT_REF（服务器））％;） 。过渡到状态State3 （转移中的效果effect为：％SEND_EVENT（“ NEW_REQUEST”，CONTEXT_REF（server））％;）。过渡到状态State4 （转移中的效果effect为：“％BROADCAST_EVENT（“ NEW_REQUEST”）％;）。过渡到状态State5（转移中的效果effect为：％SEND_EVENT（ “AUTHORIZED”，CONTEXT_REF（server））％）。过渡到最终状态Final。 在简单环境中进行仿真 创建仿真工件
创建名称为Simulation with Deferred Event的可执行状态机工件，并将”语言“（“ Language”）字段设置为JavaScript。【此处的语言设置也可以是java、C&#43;&#43;、C】将其放大，然后按住Ctrl键并将TransactionServer元素拖动到工件上，并将其粘贴为可执行状态机的一个属性，命名为server。 运行模拟
选择工件，然后选择“模拟&gt;可执行状态&gt;状态机&gt;生成，构建和运行”选项，并为您的代码指定目录（注意：目录中的所有文件将在模拟开始前被删除）。单击生成按钮。（Generate）
-选择“模拟&gt;动态模拟&gt;事件”选项，以打开“模拟事件”窗口。
当模拟开始时， idle状态将变为活动状态。
在“模拟事件”窗口中双击NEW_REQUEST，将其作为触发器执行；退出idle状态并激活busy状态 。
在“模拟事件”窗口中双击NEW_REQUEST，再次将其作为触发器执行； busy状态保持激活状态，同时，一个NEW_REQUEST的实被例添加入事件池。在“模拟事件”窗口中双击NEW_REQUEST，第三次将其作为触发器执行；busy状态保持激活状态，同时，一个NEW_REQUEST的实被例添加入事件池。在“模拟”窗口的命令行中键入dump ；请注意，此时事件池具有两个NEW_REQUEST实例。
在“模拟事件”窗口中双击AUTHORIZED，将其作为触发器执行；如下动作将会发生： 从busy状态退出，idle状态被激活，成为活跃状态；一个NEW_REQUEST事件从事件池中被检索出来，busy状态退出，busy状态被激活，成为活跃状态; 在“模拟”窗口命令行中键入dump ；现在，事件池中只剩余一个NEW_REQUEST实例。
通过发送/广播事件进行交互式模拟 创建仿真工件" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/49131eb1aa0377e4c0515542041d4780/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-16T15:54:25+08:00" />
<meta property="article:modified_time" content="2021-04-16T15:54:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">EA-可执行状态机-延迟事件模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>前言</strong><br> 因为最近在做EA的模型搭建，查阅资料的时候，发现这篇示例说明比较实用，但是英文版理解起来比较慢，中文版在火龙果网站有，但是机翻增加了理解难度，因此，我打算整理一下中文版的翻译，作为学习记录。<br> <a href="http://tool.uml.com.cn/ToolsEA/User%20Guide15.2-cn/model_simulation/deferred_event_pattern.html" rel="nofollow">火龙果网站中的EA软件参考文档【中文】</a><br> ———————————————————————————<br> Enterprise Architect支持延迟事件模式。</p> 
<p><strong>在状态中创建延迟事件：</strong></p> 
<ul><li>为状态（state）创建自我过渡(self transition)。</li><li>将过渡的种类更改为“内部过渡”。</li><li>指定触发器（Trigger）成为你需要延迟的事件。</li><li>在“效果”(Effect)字段中，键入“ defer（）;”。</li></ul> 
<p><strong>进行模拟：</strong></p> 
<ul><li>打开"模拟窗口":选择“模拟&gt;动态模拟&gt;模拟器&gt;打开模拟窗口”。<br> 打开"模拟事件窗口":选择“模拟&gt;动态模拟&gt;事件”。 <img src="https://images2.imgbox.com/bd/20/i8V4pZ4k_o.png" alt="在这里插入图片描述"></li><li>模拟器事件窗口（Simulation Event Window）可帮助您触发事件；双击“等待触发器”列中的触发器。<br> <img src="https://images2.imgbox.com/6b/96/1v78hL7Y_o.png" alt="在这里插入图片描述"></li><li>Simulation窗口以文本形式显示执行。您可以在Simulator命令行中键入“ dump”，以显示队列中延迟了多少个事件。<br> 输出可能类似于以下内容：</li></ul> 
<blockquote> 
 <p><em>24850060]事件池：[NEW，NEW，NEW，NEW，NEW，]</em></p> 
</blockquote> 
<h3><a id="_22"></a>延迟事件示例</h3> 
<p>本示例显示了使用“延迟事件”的模型，“模拟事件”窗口显示了所有可用事件。</p> 
<p>我们首先建立<strong>上下文</strong>(context)（包含状态机的类中元素），在简单的上下文中模拟它们，并从外部引发事件；然后在使用Send事件机制的客户端-服务器（client-server）上下文中进行仿真。</p> 
<h3><a id="_28"></a>创建上下文和状态机</h3> 
<p><strong>创建服务器上下文</strong></p> 
<p><img src="https://images2.imgbox.com/47/25/jN06uWVe_o.png" alt="在这里插入图片描述"></p> 
<p>创建一个类图：</p> 
<ul><li>一个类元素：TransactionServer ，向其中添加一个状态机，名为<em>ServerStateMachine</em></li><li>一个类元素TestClient ，向其中添加一个状态机，名为<em>ClientStateMachine</em></li><li>从TestClient到TransactionServer的关联(association)，目标角色名为server。</li></ul> 
<p><strong>为 ServerStateMachine 建模</strong></p> 
<p><img src="https://images2.imgbox.com/ec/f8/b3OmTuDk_o.png" alt="在这里插入图片描述"></p> 
<ul><li>向状态机图中添加一个初始化结点，名为Initial ，然后过渡到状态idle</li><li>转换（事件NEW_REQUEST作为触发器）到状态busy</li><li>过渡（使用事件QUIT作为触发）到最终状态Final</li><li>转换（事件AUTHORIZED作为触发器）到idle</li><li>转换为繁忙状态 （事件NEW_REQUEST作为触发器，defer（）；作为效果（effect））</li></ul> 
<p><strong>ClientStateMachine的 建模</strong><br> <img src="https://images2.imgbox.com/12/94/nMHo586i_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在状态机图中添加一个初始化结点initial，转换到状态State0</li><li>转换（以事件RUN_TEST作为触发器）到状态State1 。</li><li>过渡到状态State2 （转移中的效果effect为：％SEND_EVENT（“ NEW_REQUEST”，CONTEXT_REF（服务器））％;） 。</li><li>过渡到状态State3 （转移中的效果effect为：％SEND_EVENT（“ NEW_REQUEST”，CONTEXT_REF（server））％;）。</li><li>过渡到状态State4 （转移中的效果effect为：“％BROADCAST_EVENT（“ NEW_REQUEST”）％;）。</li><li>过渡到状态State5（转移中的效果effect为：％SEND_EVENT（ “AUTHORIZED”，CONTEXT_REF（server））％）。</li><li>过渡到最终状态Final。</li></ul> 
<h3><a id="_62"></a>在简单环境中进行仿真</h3> 
<p><strong>创建仿真工件</strong></p> 
<p><img src="https://images2.imgbox.com/0c/02/43LHpJ1E_o.png" alt="Model Simulation with Executable StateMachine in Sparx Systems Enterprise Architect"></p> 
<ul><li>创建名称为<strong>Simulation with Deferred Event</strong>的可执行状态机工件，并将”语言“（“ Language”）字段设置为JavaScript。【此处的语言设置也可以是java、C++、C】</li><li>将其放大，然后按住Ctrl键并将TransactionServer元素拖动到工件上，并将其粘贴为可执行状态机的一个属性，命名为server。</li></ul> 
<p><strong>运行模拟</strong></p> 
<ul><li>选择工件，然后选择“模拟&gt;可执行状态&gt;状态机&gt;生成，构建和运行”选项，并为您的代码指定目录（注意：目录中的所有文件将在模拟开始前被删除）。</li><li>单击生成按钮。（Generate）<br> -<img src="https://images2.imgbox.com/5b/be/vocf9RAt_o.png" alt="在这里插入图片描述"></li><li>选择“模拟&gt;动态模拟&gt;事件”选项，以打开“模拟事件”窗口。<br> <img src="https://images2.imgbox.com/6e/fd/Q4jBFbQM_o.png" alt="在这里插入图片描述"></li></ul> 
<p>当模拟开始时， idle状态将变为活动状态。<br> <img src="https://images2.imgbox.com/a9/fa/BGKagxON_o.png" alt="在这里插入图片描述"></p> 
<ol><li>在“模拟事件”窗口中双击NEW_REQUEST，将其作为触发器执行；退出idle状态并激活busy状态 。<br> <img src="https://images2.imgbox.com/20/c1/W3B1yuH9_o.png" alt="在这里插入图片描述"></li><li>在“模拟事件”窗口中双击NEW_REQUEST，再次将其作为触发器执行； busy状态保持激活状态，同时，一个NEW_REQUEST的实被例添加入事件池。</li><li>在“模拟事件”窗口中双击NEW_REQUEST，第三次将其作为触发器执行；busy状态保持激活状态，同时，一个NEW_REQUEST的实被例添加入事件池。</li><li>在“模拟”窗口的命令行中键入dump ；请注意，此时事件池具有两个NEW_REQUEST实例。<br> <img src="https://images2.imgbox.com/b4/6d/sJZNQQd0_o.png" alt="在这里插入图片描述"></li><li>在“模拟事件”窗口中双击AUTHORIZED，将其作为触发器执行；如下动作将会发生： 
  <ul><li>从busy状态退出，idle状态被激活，成为活跃状态；</li><li>一个NEW_REQUEST事件从事件池中被检索出来，busy状态退出，busy状态被激活，成为活跃状态;</li></ul> </li><li>在“模拟”窗口命令行中键入dump ；现在，事件池中只剩余一个NEW_REQUEST实例。<br> <img src="https://images2.imgbox.com/90/dd/FdJog2fw_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="_93"></a>通过发送/广播事件进行交互式模拟</h3> 
<p><strong>创建仿真工件</strong><br> <img src="https://images2.imgbox.com/64/f7/XjQlqiwn_o.png" alt="在这里插入图片描述"></p> 
<ul><li>创建一个可执行状态机工件，命名为“ Interactive Simulation with Deferred Event”，并将“ Language”字段设置为JavaScript；拉大元素范围。</li><li>按住Ctrl键，将TransactionServer元素拖放到工件上，并将其作为可执行状态机的一个属性，命名为server。</li><li>按住Ctrl键，将TestClient元素拖放到工件上，并将其作为可执行状态机的一个属性，命名为client。</li><li>创建一个从client到server的连接(connector)。</li><li>单击连接器，然后按Ctrl + L以选择从TestClient元素到TransactionServer元素的关联。</li></ul> 
<p><strong>运行交互式仿真</strong></p> 
<ol><li> <p>以与简单上下文相同的方式启动仿真。</p> <p>模拟开始后， client端将保持在State0 ，而server端将保持idle状态 。 <br> <img src="https://images2.imgbox.com/f3/bb/oLUKINcK_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在“模拟事件”窗口中双击RUN_TEST，从而触发该事件。 NEW_REQUEST事件将被触发3次（由SEND_EVENT和BROADCAST_EVENT触发），而AUTHORIZED事件将由SEND_EVENT触发1次。<br> <img src="https://images2.imgbox.com/20/f0/At14GRKv_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在“模拟”窗口命令行中键入dump ，事件池中还有一个NEW_REQUEST实例。结果与我们的手动触发测试相符。</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7952e8088f6f4daa844d65bb3f16cfb5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mooc python 程序设计 2-4</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71bb85c2351294d1b6e54a83a958a53b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决win10服务主机：网络服务占用网络宽带的方法（自测有效）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>