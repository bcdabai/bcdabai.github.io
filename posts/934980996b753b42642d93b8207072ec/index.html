<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第四章　WINDOWS绘图程序设计 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第四章　WINDOWS绘图程序设计" />
<meta property="og:description" content="图形设备接口（GDI：Graphics Device Interface）是Windows的子系统，它负责在视频显示器和打印机上显示图形。正如您所认为的那样，GDI是Windows非常重要的部分。不但您为Windows编写的应用系统在显示视觉信息时只使用GDI，就连Windows本身也只使用GDI来显示用户界面对象，诸如菜单、滚动条、图标和鼠标光标。
不幸的是，如果要对GDI进行全面的讲述，将需要一整本书。在本章中，我只是想向您提供画线和填充区域的基本知识，这对于理解GDI 已经足够了。
GDI的结构
从程序员的观点来看，GDI由几百个函数调用和一些相关的数据类型、宏和结构组成。 但是在开始讲述这些函数的细节之前，让我们先从宏观上了解一下GDI的整体结构。
一、GDI原理
Windows 98 / NT / 2000 中的图形主要由GDI32．DLL动态链接库输出的函数来处理。在 Windows98中，这个 GDI32．DLL实际是利用 16位 GDI．EXE动态链接库来执行许多函数。在 Windows NT中，GDI．EXE只用于16位的程序。
这些动态链接库为您安装的视频显示器和任何打印机调用设备驱动程序中的例程。视频驱动程序访问视频显示器的硬件，打印机驱动程序将GDI命令转换为各种打印机能够理解的代码或命令。显然，不同的视频显示适配器和打印机要求不同的设备驱动程序。
因为ＰＣ兼容机上可以连接许多种不同的视频设备，所以，GDI的主要目的之一是支持与设备无关的图形。Windows程序应该能够毫无困难地在Windows支持的任意一种图形输出设备上运行，GDI通过将您的程序和不同输出设备的特性隔离开来的方法来达到这一目的。
图形输出设备分为两大类：光栅设备和矢量设备。大多数ＰＣ的输出设备是光栅设备，这意味着它们以点模式来表示图像，这类设备包括视频显示适配器、点阵打印机和激光打印机。矢量设备使用线来绘制图像，通常局限于绘图仪。
许多传统的计算机图形编程都是完全基于矢量的，这意味着使用矢量图形系统的程序是在硬件之上一定层次的抽象。输出设备用像素表示图形，但是程序与编程接口之间并不是用像素进行对话的。您当然可以使用 Windows GDI作为一个高层次的矢量绘制系统，同时也可以将它用于比较低层次的像素操作。
从这方面来看，Windows GDI和传统的图形接口语言之间的关系，就如同Ｃ和其他编程语言之间的关系一样。Ｃ以它在不同操作系统和环境之间的高度可移植性而闻名，然而Ｃ也以它允许程序员进行低层次系统调用而闻名，这些调用在其他高级语言中通常是不可能的。正如 Ｃ有时被认为是一种“高级汇编语言”一样，您可以认为 GDI是图形设备硬件之间的一种高层接口。
已经看到，默认时Windows使用基于像素的坐标系。大多数传统的图形语言使用“虚拟”坐标系，其水平和垂直轴的范围从 0~32767。虽然有些图形语言不让您使用像素坐标，但是 Windows GDI允许您使用两者之一（甚至基于物理度量的坐标系）。您可以使用虚拟坐标系以便程序远离硬件，或者也可以使用设备坐标系而完全接近硬件。
早期，许多用户在一种单色显示器上运行Windows。即使近几年，笔记本计算机还只有灰度级别。为此，GDI的设计保证了您可以在编写一个程序时不必过多地担心色彩问题——也就是说，Windows可以将色彩转换为灰度级别。甚至在今天，Windows 98使用的视频显示已经具有了不同的色彩能力（16色、256色、“高彩色”，以及“真彩色”）。虽然，彩色喷墨打印机的成本已经很低了，但是大多数用户仍然坚持使用黑白打印机。不加区别地使用这些设备是可以的，但是您的程序也应该能决定在某种显示设备上有多少色彩可以使用，从而最好地利用硬件。
当然，就如同您编写Ｃ程序时，为了使它在其他计算机上运行而遇到一些微妙的移植性问题一样，您也可能不小心让设备依赖性溜进您的Windows程序，这就是不与硬件完全隔离的代价。您还应该知道 Windows GDI的局限。虽然可以在显示器上到处移动图形对象，但GDI通常是一个静态的显示系统，只有有限的动画支持。如果需要为游戏编写复杂的动画，就应该研究一下 Microsoft DirectX，它提供了您需要的支持。
二、GDI函数调用
组成GDI的几百个函数调用可以分为几大类：
获取《或创建》和释放（或清除）设备描述表的函数 在绘图时需要设备描述表句柄。GetDC和RealseDC函数让您在非WM_PAINT 的消息期间来做到这一点，而BeginPaint和 EndPaint函数（虽然在技术上它们是 USER模　块而不是GDI模块的一部分）在进行绘图的WM_PAINT消息期间使用。获取有关设备描述表信息的函数GetTextMetrics函数来获取有关设备描述表中当前所选字体的尺寸信息。绘图函数 显然，在所有前提条件都得以满足之后，这些函数是真正重要的部分。我们使用TextOut函数在窗口的客户区显示一些文本。我们将看到，其他GDI函数还可以让您画线、填充区域。
设置和获取设备描述表参数的函数 设备描述表的“属性”决定有关绘图函数如何工作的细节。例如，用SetTextColor来指定TextOut（或者其他文本输出函数）所绘制的文本色彩。我们使用SetTextAlign来告诉GDI:TextOut函数中的文本串的开始位置应该在串的右边而不是默认的左边。设备描述表的所有属性都有默认值，当获取设备描述表时设置这些默认值。对于所有的Set函数，都有相应的Set函数，以允许您获取当前设备描述表属性。
使用GDI对象的函数 GDI在这里变得有点混乱。首先举一个例子：默认时使用GDI绘制的所有直线都是实线，并具有一个标准的宽度。您可能希望绘制更细的直线，或者是由一系列的点或短划线组成的直线。这种线的宽度和这种线的线型不是设备描述表的属性，而是一个“逻辑画笔”的特征。
您可以通过在CreatePen、CreatePenIndirect或ExtCreatePen函数中指定这些特征来创建一个逻辑画笔，这些函数返回一个逻辑画笔的句柄（虽然这些函数被认为是GDI的一部分，但是和大多数GDI函数调用不一样，它们不要求设备描述表的句柄）。要使用这个画笔，就要将画笔句柄选进设备描述表。我们认为，设备描述表中当前选中的画笔就是设备描述表的一个属性。这样，您画任何线都使用这个画笔，然后，您可以取消设备描述表中的画笔选择，并清除画笔对象。清除画笔对象是必要的，因为画笔定义占用了分配的内存空间。除了画笔以外，GDI对象还用于创建填充封闭区域的刷子、字体、位图，以及GDI的其他一些方面。
三、GDI图元
在屏幕或打印机上显示的图形类型本身可以被分为几类，通常被称为“图元”，它们是:
直线和曲线 线条是所有矢量图形绘制系统的基础。GDI支持直线、矩形、椭（包括椭圆的子集，也就是我们所说的“圆”）、椭圆圆周上的部分曲线即所谓“弧”，以及贝塞尔曲线，我们将在本章中分别对它们进行介绍。所有更复杂的曲线可由折线（ polyline）代替，折线通过一组非常短的直线来定义一条曲线。线条用设备描述表中选中的当前画笔绘制。
填充区域 当一系列直线或者曲线封闭了一个区域时，该区域可以使用当前GDI画剧对象进行填充。这个画刷可以是实心色彩、图案（可以是一系列的水平、垂直或者对角标记），也可以是在区域内垂直或者水平重复的位图图像。
位图 位图是位的矩形数组，这些位对应于显示设备上的像素，它们是光栅图形的基础工具。位图通常用于在视频显示器或者打印机上显示复杂（一般都是真实的图像。位图还可以用于显示必须很快绘制的小图像，诸如图标、鼠标光标，以及在应用工具栏中出现的按钮等。ＧＤＩ支持两种类型的位图——老的（虽然还非常有用）“设备有关”位图，是 ＧＤＩ对象；新的（如 Windows 3 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/934980996b753b42642d93b8207072ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-07-24T21:51:47+08:00" />
<meta property="article:modified_time" content="2012-07-24T21:51:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第四章　WINDOWS绘图程序设计</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p align="left" class="style4" style="font-family:Simsun; background-color:rgb(204,204,204)"> 　　图形设备接口（GDI：Graphics Device Interface）是Windows的子系统，它负责在视频显示器和打印机上显示图形。正如您所认为的那样，GDI是Windows非常重要的部分。不但您为Windows编写的应用系统在显示视觉信息时只使用GDI，就连Windows本身也只使用GDI来显示用户界面对象，诸如菜单、滚动条、图标和鼠标光标。<br> 　　不幸的是，如果要对GDI进行全面的讲述，将需要一整本书。在本章中，我只是想向您提供画线和填充区域的基本知识，这对于理解GDI 已经足够了。</p> 
<p align="center" class="style1" style="font-family:楷体_GB2312; font-size:18px; background-color:rgb(204,204,204)"> GDI的结构</p> 
<p align="left" class="style4" style="font-family:Simsun; background-color:rgb(204,204,204)"> 　　从程序员的观点来看，GDI由几百个函数调用和一些相关的数据类型、宏和结构组成。 但是在开始讲述这些函数的细节之前，让我们先从宏观上了解一下GDI的整体结构。<br> <strong>一、GDI原理</strong><br> 　　Windows 98 / NT / 2000 中的图形主要由GDI32．DLL动态链接库输出的函数来处理。在 Windows98中，这个 GDI32．DLL实际是利用 16位 GDI．EXE动态链接库来执行许多函数。在 Windows NT中，GDI．EXE只用于16位的程序。<br> 　　这些动态链接库为您安装的视频显示器和任何打印机调用设备驱动程序中的例程。视频驱动程序访问视频显示器的硬件，打印机驱动程序将GDI命令转换为各种打印机能够理解的代码或命令。显然，不同的视频显示适配器和打印机要求不同的设备驱动程序。<br> 　　因为ＰＣ兼容机上可以连接许多种不同的视频设备，所以，GDI的主要目的之一是支持与设备无关的图形。Windows程序应该能够毫无困难地在Windows支持的任意一种图形输出设备上运行，GDI通过将您的程序和不同输出设备的特性隔离开来的方法来达到这一目的。<br> 　　图形输出设备分为两大类：光栅设备和矢量设备。大多数ＰＣ的输出设备是光栅设备，这意味着它们以点模式来表示图像，这类设备包括视频显示适配器、点阵打印机和激光打印机。矢量设备使用线来绘制图像，通常局限于绘图仪。<br> 　　许多传统的计算机图形编程都是完全基于矢量的，这意味着使用矢量图形系统的程序是在硬件之上一定层次的抽象。输出设备用像素表示图形，但是程序与编程接口之间并不是用像素进行对话的。您当然可以使用 Windows GDI作为一个高层次的矢量绘制系统，同时也可以将它用于比较低层次的像素操作。<br> 　　从这方面来看，Windows GDI和传统的图形接口语言之间的关系，就如同Ｃ和其他编程语言之间的关系一样。Ｃ以它在不同操作系统和环境之间的高度可移植性而闻名，然而Ｃ也以它允许程序员进行低层次系统调用而闻名，这些调用在其他高级语言中通常是不可能的。正如 Ｃ有时被认为是一种“高级汇编语言”一样，您可以认为 GDI是图形设备硬件之间的一种高层接口。<br> 　　已经看到，默认时Windows使用基于像素的坐标系。大多数传统的图形语言使用“虚拟”坐标系，其水平和垂直轴的范围从 0~32767。虽然有些图形语言不让您使用像素坐标，但是 Windows GDI允许您使用两者之一（甚至基于物理度量的坐标系）。您可以使用虚拟坐标系以便程序远离硬件，或者也可以使用设备坐标系而完全接近硬件。<br> 　　早期，许多用户在一种单色显示器上运行Windows。即使近几年，笔记本计算机还只有灰度级别。为此，GDI的设计保证了您可以在编写一个程序时不必过多地担心色彩问题——也就是说，Windows可以将色彩转换为灰度级别。甚至在今天，Windows 98使用的视频显示已经具有了不同的色彩能力（16色、256色、“高彩色”，以及“真彩色”）。虽然，彩色喷墨打印机的成本已经很低了，但是大多数用户仍然坚持使用黑白打印机。不加区别地使用这些设备是可以的，但是您的程序也应该能决定在某种显示设备上有多少色彩可以使用，从而最好地利用硬件。<br> 　　当然，就如同您编写Ｃ程序时，为了使它在其他计算机上运行而遇到一些微妙的移植性问题一样，您也可能不小心让设备依赖性溜进您的Windows程序，这就是不与硬件完全隔离的代价。您还应该知道 Windows GDI的局限。虽然可以在显示器上到处移动图形对象，但GDI通常是一个静态的显示系统，只有有限的动画支持。如果需要为游戏编写复杂的动画，就应该研究一下 Microsoft DirectX，它提供了您需要的支持。<br> <strong>二、GDI函数调用</strong><br> 组成GDI的几百个函数调用可以分为几大类：<br> 　　获取《或创建》和释放（或清除）设备描述表的函数 在绘图时需要设备描述表句柄。GetDC和RealseDC函数让您在非WM_PAINT 的消息期间来做到这一点，而BeginPaint和 EndPaint函数（虽然在技术上它们是 USER模　　块而不是GDI模块的一部分）在进行绘图的WM_PAINT消息期间使用。获取有关设备描述表信息的函数GetTextMetrics函数来获取有关设备描述表中当前所选字体的尺寸信息。绘图函数 显然，在所有前提条件都得以满足之后，这些函数是真正重要的部分。我们使用TextOut函数在窗口的客户区显示一些文本。我们将看到，其他GDI函数还可以让您画线、填充区域。<br> 　　设置和获取设备描述表参数的函数 设备描述表的“属性”决定有关绘图函数如何工作的细节。例如，用SetTextColor来指定TextOut（或者其他文本输出函数）所绘制的文本色彩。我们使用SetTextAlign来告诉GDI:TextOut函数中的文本串的开始位置应该在串的右边而不是默认的左边。设备描述表的所有属性都有默认值，当获取设备描述表时设置这些默认值。对于所有的Set函数，都有相应的Set函数，以允许您获取当前设备描述表属性。<br> 　　使用GDI对象的函数 GDI在这里变得有点混乱。首先举一个例子：默认时使用GDI绘制的所有直线都是实线，并具有一个标准的宽度。您可能希望绘制更细的直线，或者是由一系列的点或短划线组成的直线。这种线的宽度和这种线的线型不是设备描述表的属性，而是一个“逻辑画笔”的特征。<br> 　　您可以通过在CreatePen、CreatePenIndirect或ExtCreatePen函数中指定这些特征来创建一个逻辑画笔，这些函数返回一个逻辑画笔的句柄（虽然这些函数被认为是GDI的一部分，但是和大多数GDI函数调用不一样，它们不要求设备描述表的句柄）。要使用这个画笔，就要将画笔句柄选进设备描述表。我们认为，设备描述表中当前选中的画笔就是设备描述表的一个属性。这样，您画任何线都使用这个画笔，然后，您可以取消设备描述表中的画笔选择，并清除画笔对象。清除画笔对象是必要的，因为画笔定义占用了分配的内存空间。除了画笔以外，GDI对象还用于创建填充封闭区域的刷子、字体、位图，以及GDI的其他一些方面。<br> <strong>三、GDI图元</strong><br> 　　在屏幕或打印机上显示的图形类型本身可以被分为几类，通常被称为“图元”，它们是:<br> 　　直线和曲线 线条是所有矢量图形绘制系统的基础。GDI支持直线、矩形、椭（包括椭圆的子集，也就是我们所说的“圆”）、椭圆圆周上的部分曲线即所谓“弧”，以及贝塞尔曲线，我们将在本章中分别对它们进行介绍。所有更复杂的曲线可由折线（ polyline）代替，折线通过一组非常短的直线来定义一条曲线。线条用设备描述表中选中的当前画笔绘制。<br> 　　填充区域 当一系列直线或者曲线封闭了一个区域时，该区域可以使用当前GDI画剧对象进行填充。这个画刷可以是实心色彩、图案（可以是一系列的水平、垂直或者对角标记），也可以是在区域内垂直或者水平重复的位图图像。<br> 　　<strong>位图</strong> 位图是位的矩形数组，这些位对应于显示设备上的像素，它们是光栅图形的基础工具。位图通常用于在视频显示器或者打印机上显示复杂（一般都是真实的图像。位图还可以用于显示必须很快绘制的小图像，诸如图标、鼠标光标，以及在应用工具栏中出现的按钮等。ＧＤＩ支持两种类型的位图——老的（虽然还非常有用）“设备有关”位图，是 ＧＤＩ对象；新的（如 Windows 3 .0的）“设备无关”位图（或者DIB），可以存储在磁盘文件中。<br> 　　文本 文本的数学味道不像计算机图形的其他方面那样浓。文本和几百年的传统印刷术有关，它被许多印刷工人作为一门艺术看待。因此，文本通常不仅是所有的计算机图形系统中最复杂的部分，而且也是最重要的部分（如果识字还是社会基本要求的话）。<br> 用于定义GDI字体对象和获取字体信息的数据结构是Windows中最庞大的部分之一。从Windows 3.1开始，GDI开始支持 TrueType字体，该字体是在填充轮廓线基础上创建的，这样的填充轮廓线可由其他GDI函数处理。基于兼容性和存储大小的考虑，Windows 98继续支持旧式的基于位图的字体。<br> <strong>四、其他方面</strong><br> GDI的其他方面无法这么容易地分类，它们是：<br> 　　映射模式和交换虽然默认时以像素为单位进行绘图，但是并非局限于此。GDI映射模式允许您以英寸（或者甚至以几分之一英寸）、mm或者任何您想使用的单位来绘图（Windows NT还支持传统的以 3x3矩阵表示的“坐标变换”，这允许倾斜和旋转图形对象。不幸的是，在 Windows 98中不支持坐标变换）元文件元文件是以二进制形式存储的GDI命令的集合。元文件主要用于通过剪贴板传输矢量图形表示。<br> 　　<strong>区域</strong> 区域是形状任意的复杂区，通常定义为较简单区域的布尔组合。在GDI内部，区域除了存储为最初用来定义区域的线条组合以外，还以一系列扫描线的形式存储。您可以将区域用于绘制轮廓、填充和剪裁。<br> 　　<strong>路径</strong> 路径是GDI内部存储的直线和曲线的集合。路径可以用于绘图、填充和剪裁，还可以转换为区域。剪裁 绘图可以限制在客户区的某一部分中，这就是所谓的剪裁。剪裁区域可以是矩形或非短形，剪裁通常是通过区域或者路径来定义的。<br> 　　<strong>调色板</strong> 定制调色板通常限于显示256色的显示器。Windows仅保留这些色彩之中的２０种供系统使用，您可以改变其他236种色彩，以准确显示按位图形式存储的真实图像。打印虽然本章限于视频显示，但是您在本章中所学到的全部知识都适用于打印。</p> 
<p align="center" class="style1" style="font-family:楷体_GB2312; font-size:18px; background-color:rgb(204,204,204)"> 设备描述表</p> 
<p align="left" class="style4" style="font-family:Simsun; background-color:rgb(204,204,204)"> 　　在开始绘图之前，让我们更精确地讨论一下设备描述表当您想在一个图形输出设备（诸如屏幕或者打印机）上绘图时，您首先必须获得个设备描述表（或者DC）的句柄。将句柄返回给程序时，Windows就给了您使用设备的权限。然后您在GDI函数中将这个句柄作为一个参数，向Windows标识您想在其上进行绘图的设备。<br> 　　设备描述表中包含许多确定GDI函数如何在设备上工作的当前“属性”，这些属性允许传递给GDI函数的参数只包含起始坐标或者尺寸信息，而不必包含Windows在设备上显示对象时需要的所有其他信息。例如，调用TextOut时，您只需要在函数中给出设备描述表句柄、起始坐标、文本和文本的长度。您不必指定字体、文本色、文本后面的背景色彩，以及字符间距，因为这些属性都是设备描述表的一部分。当您想改变这些属性之一时，您调用一个可以改变设备描述表中属性的函数，以后针对该设备描述表的TextOut调用来使用改变后的属性。<br> <strong>一、获取设备描述表句柄</strong><br> 　　Windows提供了几种获取设备描述表句柄的方法。如果在处理一条消息时获取了设备描述表句柄,应该在退出窗口函数之前释放它（或者删除它）。一旦释放了句柄，它就不再有效了。最常用的获取并释放设备描述表句柄的方法是，在处理WM_PAINT消息时，使用BeginPaint和 EndPaint调用：<br> hdc =BeginPaint(hwnd,&amp;ps )；<br> …….<br> EndPaint ( hwnd,&amp;ps )；<br> 变量 ps是类型为 PAINTSTRUCT的结构，该结构的 hdc字段是 BeginPaint返回的设备投述表句柄。　　PAINTSTRUCT结构又包含一个名为rcPaint的RECT（短形）结构，cPaint定义一个包围窗口客户区无效范围的矩形。使用从BeginPaint获得的设备描述表句柄，只能在这个区域内绘图。BeginPaint调用使该区域有效。Windows程序还可以在处理非WM_PAINT消息时获取设备描述表句柄：<br> hdc=GetWindowDC(hwnd) ;<br> ………<br> ReleaseDC(hwnd,hdc); <br> 　　这个设备描述表适用于窗口句柄为 hwnd的客户区。这些调用与 BeginPaint和EdPaint的组合之间的基本区别是，利用从GetDC返回的句柄可以在整个客户区上绘图。当然，GetDC和ReleaseDC不使客户区中任何可能的无效区域变成有效。<br> Windows程序还可以获取适用于整个窗口（而<br> 不仅限于窗口的客户区）的设备描述表句柄：<br> hdc=GetWindowDC(hwnd) ;<br> ………<br> ReleaseDC(hwnd,hdc); <br> 这个设备描述表除了客户区之外，还包括窗口的标题栏、菜单、滚动条和框架（frame）。<br> GetWindowsDC函数很少使用，如果想尝试用一用它，则必须捕获WM_NCPAINT（“非客户绘制”）消息，Windows使用该消息在窗口的非客户区上绘图。<br> BeginPaint、GetDC和GetWindowDC获得的设备描述表都与视频显示器上的某个特定窗口相关。获取设备描述表句柄的另一个更通用的函数是CreateDC：<br> hdc=CreateDC (pszDriver,pszDevice,pszOutput,pData) ;<br> ………<br> DeleteDC(hdc);<br> 例如，您可以通过下面的调用来获取整个屏幕的设备描述表句柄：<br> hdc=CreateDC (TEXT(“DISPLAY”) , NULL , NULL , NULL) ;<br> 　　在窗口之外写东西一般是不合适的，但对于一些不同寻常的应用程序来说，这样做很方便（您还可以通过在调用GetDC时使用一个NULL参数，从而获取整个屏幕的设备描述表句柄，不过这一事实并没有载人文档）。<br> <strong>二、获取设备描述表信息</strong><br> 　　一个设备描述表通常是指一个物理显示设备，如视频显示器和打印机。通常，您需要获取有关该设备的信息，其中包括显示器的显示尺寸（单位为像素或者物理度量）和色彩范围。您可以通过调用GetDeviceCaps（“获取设备能力”）函数来获取这些信息：<br> iValue = GetDeviceCaps (hdc, ilndex);<br> 　　其中，参数 ilndex取值为 WINGDI.H头文件中定义的２９个标识符之一。例如，当ilndex的值为HORZRES时，将导致GetDeviceCaps返回设备的宽度（单位为像素）；当GetDeviceCaps的值为 VERTRES时，将导致GetDeviceCaps返回设备的高度（单位为像素）。如果hdc屏幕设备描述表的句柄，则GetDeviceCaps返回打印机显示区域的高度和宽度，它们也是以像素为单位的。<br> 　　还可以使用GetDeviceCaps来确定设备处理各种不同类型的图形的能力，这通常对于处理视频显示并不十分重要，但是对于使用打印设备却是非常重要。<br> 例如，大多数笔式绘图仪不能画位图图像，而GetDeviceCaps就可以将这一情况告诉您。<br> <strong>三、 WINDOWS GDI 函数</strong><br> GetDC()函数<br> 功能： 用于获取指定窗体客户区的显示器设备描述表句柄。<br> 函数声明： HDC GetDC(HWND hWnd);<br> 参数：hWnd：窗体句柄。<br> 返回值：如果成功，返回指定窗体客户区的设备描述表句柄，否则返回NULL。</p> 
<p align="center" class="style1" style="font-family:楷体_GB2312; font-size:18px; background-color:rgb(204,204,204)"> 窗体客户区绘图</p> 
<p align="left" class="style4" style="font-family:Simsun; background-color:rgb(204,204,204)"> <strong>一、步骤</strong><br> 1．获取设备环境句柄<br> 2．获取绘图工具<br> 3．选择绘图工具<br> 4．利用选择的绘图工具绘图<br> 5．恢复原来的绘图工具并删除选择的绘图工具<br> 6．释放设备环境句柄<br> <br> ReleaseDC () 函数<br> 功能：用于释放设备描述表句柄。<br> 函数声明：int ReleaseDC(HWND hWnd, HDC hDC);<br> 参数：hWnd：窗体句柄；<br> hDC： 设备描述表句柄。<br> 返回值：如果成功，返回1，否则返回0。<br> 注释：GetDC()函数与ReleaseDC()函数必须匹配使用，而且不能在WM_PAINT中使用。<br> <br> BeginPaint()函数<br> 功能：用于获取窗体客户区绘图的相关信息，并为绘图做好准备。<br> 函数声明：HDC BeginPaint(HWND hwnd, LPPAINTSTRUCT lpPaint);<br> 参数：hWnd：窗体句柄；<br> lpPaint：指向绘图结构类型的指针变量。<br> 返回值：如果成功，返回指定窗体客户区的设备描述表句柄，否则返回NULL。<br> PAINTSTRUC 结构类型<br> PAINTSTRUCT 结构类型包含一些窗体绘图的基本信息，定义如下：<br> typedef struct tagPAINTSTRUCT<br> { <br> 　　HDC hdc; // 窗体句柄； <br> 　　BOOL fErase; // 窗体客户区背景是否删除标记；<br> 　　RECT rcPaint; // 需要绘制的窗体客户区区域标记；<br> 　　BOOL fRestore; // 系统保留；<br> 　　BOOL fIncUpdate; // 系统保留；<br> 　　BYTE rgbReserved[32]; // 系统保留； <br> } PAINTSTRUCT;<br> RECT 结构类型<br> RECT 结构类型用于描述一个矩形，定义如下：<br> typedef struct _RECT<br> { <br> 　　LONG left; // 矩形左边界坐标； <br> 　　LONG top; // 矩形上边界坐标； <br> 　　LONG right; // 矩形右边界坐标；<br> 　　LONG bottom; // 矩形下边界坐标；<br> } RECT;<br> <br> EndPaint()函数<br> 功能：用于结束窗体客户区绘图。<br> 函数声明：BOOL EndPaint(HWND hWnd, CONST PAINTSTRUCT *lpPaint);<br> 参数：hWnd：窗体句柄；<br> lpPaint：指向绘图结构类型的指针变量。<br> 返回值：如果成功，返回TRUE，否则返回FALSE。<br> 注释：BeginPaint()函数与EndPaint()函数必须匹配使用，而且只能在WM_PAINT中使用。<br> <br> SetPixel()函数<br> 功能：用于在窗体客户区绘制点（像素）。<br> 函数声明：COLORREF SetPixel(HDC hdc, int X, int Y, COLORREF crColor);<br> 参数：<br> hdc： 设备描述表句柄；<br> X： 点（像素）的x坐标；<br> Y： 点（像素）的y坐标；<br> crColor：点（像素）的颜色；<br> 返回值：如果成功，返回点（像素）的颜色值，否则返回-1。<br> COLORREF 类型<br> COLORREF 类型用于描述32位<br> RGB颜色值，<br> 其十六进制颜色值定义如下：0x00bbggrr <br> <br> RGB()宏<br> 功能： 用于设置颜色。<br> 宏定义： COLORREF RGB(BYTE bRed, BYTE bGreen, BYTE bBlue);<br> 参数：<br> bRed： 红色辉度级别；<br> bGreen：绿色辉度级别；<br> bBlue： 兰色辉度级别；<br> 返回值：返回颜色值。<br> <br> CreatePen()函数<br> 功能： 用于建立逻辑笔。<br> 函数声明：HPEN CreatePen(int fnPenStyle, int nWidth, COLORREF crColor);<br> 参数：<br> fnPenStyle：逻辑笔类型；<br> nWidth： 逻辑笔宽度；<br> crColor： 逻辑笔颜色。<br> 逻辑笔类型：<br> PS_SOLID<br> PS_DASH<br> PS_DOT<br> PS_DASHDOTDOT<br> PS_INSIDEFRAME<br> PS_NULL<br> 返回值：如果成功，返回逻辑笔句柄，否则返回NULL。<br> <br> MoveToEx()函数<br> 功能：用于窗体客户区移动逻辑笔。<br> 函数声明： BOOL MoveToEx(HDC hdc, int X, int Y, LPPOINT lpPoint);<br> 参数：<br> hdc： 设备描述表句柄；<br> X： 移动位置的x坐标；<br> Y： 移动位置的y坐标；<br> lpPoint：原位置坐标；<br> 返回值：如果成功，返回TRUE，否则返回FALSE。<br> <br> LineTo()函数<br> 功能：用于在窗体客户区当前位置画线。<br> 函数声明： BOOL LineTo(HDC hdc, int nXEnd, int nYEnd);<br> 参数：<br> hdc： 设备描述表句柄；<br> nXEnd：目标点的x坐标；<br> nYEnd：目标点的y坐标。<br> 返回值：<br> 如果成功，返回TRUE，否则返回FALSE。<br> <br> Ellipse()函数<br> 功能：用于窗体客户区绘制椭圆。<br> 函数声明：BOOL Ellipse(HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect);<br> 参数：<br> hdc： 设备描述表句柄；<br> nLeftRect： 椭圆外边界左边界坐标；<br> nTopRect： 椭圆外边界上边界坐标；<br> nRightRect： 椭圆外边界右边界坐标；<br> nBottomRect：椭圆外边界下边界坐标；<br> 返回值：如果成功，返回TRUE，否则返回FALSE。<br> <br> SelectObject()函数<br> 功能：用于选择一种绘图工具柄将其装入设备描述表。<br> 函数声明：HGDIOBJ SelectObject(HDC hdc,HGDIOBJ hgdiobj);<br> 参数：<br> hdc：设备描述表句柄；<br> hgdiobj：绘图工具句柄。<br> 返回值：如果成功，返回原设备描述表中绘图工具句柄，否则返回NULL。<br> ? <br> DeleteObject()函数<br> 功能：用于删除一个绘图工具。<br> 函数声明：BOOL DeleteObject(HGDIOBJ hObject);<br> 参数：<br> hObject：绘图工具句柄。<br> 返回值：如果成功，返回TRUE，否则返回FALSE。<br> <br> TextOut()函数<br> 功能：用于在窗体客户区输出文本。<br> 函数声明：BOOL TextOut(HDC hdc,int nXStart,int nYStart,LPCTSTR lpString,int cbString);<br> 参数：<br> hdc： 设备描述表句柄；<br> nXStart： 文本左上角坐标；<br> nYStart： 文本左上角坐标；<br> lpString：指向文本字符串的指针变量；<br> cbString：文本字符串长度；<br> 返回值：如果成功，返回TRUE，否则返回FALSE。<br> <br> SetBkMode()函数<br> 功能：用于设置窗体客户区背景填充方式。<br> 函数声明：int SetBkMode(HDC hdc, int iBkMode);<br> 参数：<br> hdc： 设备描述表句柄；<br> iBkMode：填充方式。<br> OPAQUE： 不透明方式；<br> TRANSPARENT：透明方式；<br> 返回值：如果成功，返回填充方式，否则返回0。<br> <br> SetTextColor()函数<br> 功能：用于文本颜色。<br> 函数声明： COLORREF SetTextColor(HDC hdc, COLORREF crColor);<br> 参数：<br> hdc： 设备描述表句柄；<br> crColor：文本笔颜色。<br> 返回值：如果成功，返回原文本笔颜色，否则返回 CLR_INVALID。<br> <br> CreateFont()函数<br> 功能：用于建立逻辑字模。<br> 函数声明：<br> HFONT CreateFont(int nHeight,<br> 　　　　　　　　 int nWidth,<br> 　　　　　　　　 int nEscapement,<br> 　　　　　　　　 int nOrientation,<br> 　　　　　　　　 int fnWeight,<br> 　　　　　　　　 DWORD fdwItalic,<br> 　　　　　　　　 DWORD fdwUnderline,<br> 　　　　　　　　 DWORD fdwStrikeOut,<br> 　　　　　　　　 DWORD fdwCharSet,<br> 　　　　　　　　 DWORD fdwOutputPrecision,<br> 　　　　　　　　 DWORD fdwClipPrecision,<br> 　　　　　　　　 DWORD fdwQuality,<br> 　　　　　　　　 DWORD fdwPitchAndFamily,<br> 　　　　　　　　 LPCTSTR lpszFace);<br> 参数：<br> nHeight：逻辑字符高度；<br> nWidth：逻辑字符宽度；<br> nEscapement：字符旋转角度；<br> nOrientation：字符与基线的夹角；<br> fnWeight：字符黑度；<br> fdwItalic：是否斜体；<br> fdwUnderline：是否代下划线；<br> fdwStrikeOut：非零时为删除线字体；<br> fdwCharSet：字符集；<br> fdwOutputPrecision：输出精度；<br> fdwClipPrecision：剪切精度<br> fdwQuality：输出质量控制；<br> fdwPitchAndFamily：字符间距和字符集；<br> lpszFace：引用名。<br> 返回值：如果成功，返回逻辑字模句柄，否则返回 NULL。<br> <br> <strong>三、其它函数</strong><br> <br> SetTimer()函数<br> 功能：用于建立产生时间消息的时间控件。<br> 函数声明：UINT SetTimer(HWND hWnd,UINT nIDEvent,UINT uElapse,TIMERPROC lpTimerFunc);<br> 参数：<br> hWnd： 窗体句柄；<br> nIDEvent： 时间控件的索引号；<br> uElapse： 产生时间消息的时间间隔；<br> lpTimerFunc：时间控件控制过程指针；<br> 返回值：如果成功，返回时间控件的索引号，否则返回0。<br> <br> KillTimer()函数<br> 功能：用于取消时间控件。<br> 函数声明：BOOL KillTimer(HWND hWnd, UINT uIDEvent);<br> 参数：<br> hWnd： 窗体句柄；<br> nIDEvent：时间控件的索引号；<br> 返回值：如果成功，返回TRUE，否则返回FALSE。<br> ? <br> GetClientRect()函数<br> 功能：用于获取窗体客户区范围。<br> 函数声明：BOOL GetClientRect(HWND hWnd, LPRECT lpRect);<br> 参数：<br> hWnd： 窗体句柄；<br> lpRect：指向RECT结构类型的指针变量。<br> 返回值：如果成功，返回TRUE，否则返回FALSE。</p> 
<p align="center" class="style1" style="font-family:楷体_GB2312; font-size:18px; background-color:rgb(204,204,204)"> 应用实例</p> 
<p align="left" class="style4" style="font-family:Simsun; background-color:rgb(204,204,204)"> <strong>画点和线：</strong><br> 　　我们已谈论过Windows图形设备接口将图形输出设备的设备驱动程序与计算机连在一起的方式。在理论上，只要提供SetPixel和GetPixel函数，就可以使用图形设备驱动程序绘制一切东西了。其余的一切都可以使用 GDI模块中实现的更高级的例程来处理。例如画线时，只需GDI调用 SetPixel数次，并适当地调整Ｘ和Y坐标。<br> 在实际情况中，也的确可以仅使用SetPixel和GetPixel函数进行您需要的任何绘制。您也可以在这些函数的基础上设计出简洁和构造良好的图形编程系统。唯一的问题是性能。如果一个函数通过几次调用才能到达。　　SetPixel函数，那么它运行起来会非常慢。如果一个图形系统画线和进行其他复杂的图形操作是在设备驱动程序的层次上，它就会更有效得多，因为设备驱动程序对完成这些操作的代码进行了优化。此外，一些视频适配器卡包含了图形协处理器，它允许视频硬件自己绘制图形。<br> <strong>直线</strong><br> 　　Windows可以画直线、椭圆线（椭圆圆周上的曲线）。 Windows画线函数是：<br> LineTo画直线；<br> Poiyline和PoiylineTo画一系列相连的直线；<br> PolyPolyline 画多组相连的线；<br> Arc 画椭圆线；<br> 　　设备描述表的5个属性影响着用这些函数所画线的外观：当前画笔的位置（仅用于LineTo、PoiylineTo和 Arc）、画笔、背景方式、背景色和绘图模式。<br> 画一条直线，必须调用两个函数。第一个函数指定了线的开始点，第二个函数指定了线的终点：<br> MoveToEx（hdc,xBeg,yBeg,NULL）；<br> LineTo (hdc, xEnd,yEnd);<br> 　　MoveToEx实际上不会画线，它只是设置了设备描述表的“当前位置”属性。然后LineTo 函数从当前的位置到它所指定的点画一条直线。当前位置只是用于其他几个GDI函数的开始点。在默认的设备描述表中，当前位置最初设置在点（0，0）。如果在调用LineTo之前没有设置当前位置，那么它将从客户区的左上角开始画线。<br> <strong>一、画点程序</strong><br> ? <br> #include &lt;windows.h&gt;<br> #include &lt;time.h&gt;<br> ? <br> #define IDC_TIMER 100<br> ? <br> int WINAPI WinMain(HINSTANCE, HINSTANCE,LPSTR,int);<br> LRESULT CALLBACK WndProc(HWND, UINT,WPARAM,LPARAM);<br> int randomize();<br> int random(int); <br> int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br> {<!-- --><br> 　　randomize();<br> 　　WNDCLASSEX wcex;<br> 　　wcex.cbSize = sizeof(WNDCLASSEX); <br> 　　wcex.style = CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;<br> 　　wcex.lpfnWndProc = (WNDPROC)WndProc;<br> 　　wcex.cbClsExtra = 0;<br> 　　wcex.cbWndExtra = 0;<br> 　　wcex.hInstance = hInstance;<br> 　　wcex.hIcon = LoadIcon(hInstance,(LPCTSTR)IDI_APPLICATION);<br> 　　wcex.hCursor = LoadCursor(NULL,IDC_ARROW);<br> 　　wcex.hbrBackground = (HBRUSH)COLOR_ACTIVECAPTION;<br> 　　wcex.lpszMenuName = NULL;<br> 　　wcex.lpszClassName = "WndCls";<br> 　　wcex.hIconSm = LoadIcon(hInstance,(LPCTSTR)IDI_APPLICATION);<br> 　　if(!RegisterClassEx(&amp;wcex)) return FALSE;<br> 　　int SW_XFS = GetSystemMetrics(SM_CXSCREEN);<br> 　　int SW_YFS = GetSystemMetrics(SM_CYSCREEN);<br> 　　HWND hWnd;<br> 　　hWnd = CreateWindowEx(WS_EX_CLIENTEDGE,<br> 　　　　　　　　　　　　　"WndCls",<br> 　　　　　　　　　　　　　"Drawing Spot of Windows Program",<br> 　　　　　　　　　　　　　WS_OVERLAPPEDWINDOW,<br> 　　　　　　　　　　　　　0,<br> 　　　　　　　　　　　　　0,<br> 　　　　　　　　　　　　　SW_XFS,<br> 　　　　　　　　　　　　　SW_YFS-25,<br> 　　　　　　　　　　　　　NULL,<br> 　　　　　　　　　　　　　NULL,<br> 　　　　　　　　　　　　　hInstance,<br> 　　　　　　　　　　　　　NULL);<br> 　　if(!hWnd) return FALSE;<br> 　　ShowWindow(hWnd, SW_SHOWNORMAL);<br> 　　UpdateWindow(hWnd);<br> 　　SetTimer(hWnd,IDC_TIMER,10,NULL);<br> 　　MSG msg;<br> <br> 　　while(GetMessage(&amp;msg,NULL,0,0)) <br> 　　{<!-- --><br> 　　　　TranslateMessage(&amp;msg);<br> 　　　　DispatchMessage(&amp;msg);<br> 　　}<br> 　　return msg.wParam;<br> }<br> <br> LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<br> {<!-- --><br> 　　static RECT rect;<br> 　　static int ww,wh;<br> 　　HDC hDC;<br> 　　static int x,y;<br> 　　COLORREF color;<br> 　　switch (message) <br> 　　{<!-- --><br> 　　　　case WM_CREATE:<br> 　　　　GetClientRect(hWnd,&amp;rect);<br> 　　　　ww = rect.right-rect.left;<br> 　　　　wh = rect.bottom-rect.top; <br> 　　　　break;<br> <br> 　　　　case WM_SIZE:<br> 　　　　ww = LOWORD(lParam);<br> 　　　　wh = HIWORD(lParam);<br> 　　　　break;<br> <br> 　　　　case WM_TIMER:<br> 　　　　hDC = GetDC(hWnd);<br> 　　　　x = rect.left+random(ww);<br> 　　　　y = rect.top+random(wh);<br> 　　　　color = RGB(random(128)+127,random(128)+127,random(128)+127);<br> 　　　　SetPixelV(hDC,x,y,color);<br> 　　　　ReleaseDC(hWnd,hDC); <br> 　　　　break;<br> 　　<br> 　　　　case WM_DESTROY:<br> 　　　　KillTimer(hWnd,IDC_TIMER);<br> 　　　　PostQuitMessage(0);<br> 　　　　break;<br> <br> 　　　　default:<br> 　　　　return DefWindowProc(hWnd,message,wParam,lParam);<br> 　　}<br> 　　return 0;<br> }<br> ? <br> int randomize()<br> {<!-- --><br> 　　srand((unsigned int)time(NULL));<br> 　　return 0; <br> }<br> <br> int random(int number)<br> {<!-- --><br> 　　int rn;<br> 　　rn = (int)(((long)rand()*number)/(RAND_MAX+1));<br> 　　return rn;<br> }<br> <br> <strong>二、画线程序</strong><br> #include &lt;windows.h&gt;<br> int WINAPI WinMain(HINSTANCE, HINSTANCE,LPSTR,int);<br> LRESULT CALLBACK WndProc(HWND,UINT, WPARAM,LPARAM);<br> int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br> {<!-- --><br> 　　WNDCLASSEX wcex;<br> 　　wcex.cbSize = sizeof(WNDCLASSEX); <br> 　　wcex.style = CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;<br> 　　wcex.lpfnWndProc = (WNDPROC)WndProc;<br> 　　wcex.cbClsExtra = 0;<br> 　　wcex.cbWndExtra = 0;<br> 　　wcex.hInstance = hInstance;<br> 　　wcex.hIcon = LoadIcon(hInstance,(LPCTSTR)IDI_APPLICATION);<br> 　　wcex.hCursor = LoadCursor(NULL,IDC_ARROW);<br> 　　wcex.hbrBackground = (HBRUSH)COLOR_ACTIVECAPTION;<br> 　　wcex.lpszMenuName = NULL;<br> 　　wcex.lpszClassName = "WndCls";<br> 　　wcex.hIconSm 　= LoadIcon(hInstance,(LPCTSTR)IDI_APPLICATION);<br> 　　if(!RegisterClassEx(&amp;wcex)) return FALSE;<br> 　　int SW_XFS = GetSystemMetrics(SM_CXSCREEN);<br> 　　int SW_YFS = GetSystemMetrics(SM_CYSCREEN);<br> 　　HWND hWnd;<br> 　　hWnd = CreateWindowEx(WS_EX_CLIENTEDGE,<br> 　　　　　　　　　　　　　"WndCls",<br> 　　　　　　　　　　　　　"Drawing Line of Windows Program",<br> 　　　　　　　　　　　　　WS_OVERLAPPEDWINDOW,<br> 　　　　　　　　　　　　　0,<br> 　　　　　　　　　　　　　0,<br> 　　　　　　　　　　　　　SW_XFS,<br> 　　　　　　　　　　　　　SW_YFS-25,<br> 　　　　　　　　　　　　　NULL,<br> 　　　　　　　　　　　　　NULL,<br> 　　　　　　　　　　　　　hInstance,<br> 　　　　　　　　　　　　　NULL);<br> 　　if(!hWnd) return FALSE;<br> 　　ShowWindow(hWnd, SW_SHOWNORMAL);<br> 　　UpdateWindow(hWnd);<br> 　　MSG msg;<br> 　　while(GetMessage(&amp;msg,NULL,0,0)) <br> 　　{<!-- --><br> 　　　　TranslateMessage(&amp;msg);<br> 　　　　DispatchMessage(&amp;msg);<br> 　　}<br> 　　return msg.wParam;<br> }<br> <br> LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<br> {<!-- --><br> 　　static int y,y0;<br> 　　static RECT rect;<br> 　　static int ww,wh;<br> 　　HPEN hOldPen,hNewPen;<br> 　　HDC hDC;<br> 　　PAINTSTRUCT ps;<br> 　　COLORREF color;<br> 　　switch (message) <br> 　　{<!-- --><br> 　　　　case WM_CREATE:<br> 　　　　GetClientRect(hWnd,&amp;rect);<br> 　　　　ww = rect.right-rect.left;<br> 　　　　wh = rect.bottom-rect.top;<br> 　　　　break;<br> <br> 　　　　case WM_SIZE:<br> 　　　　ww = LOWORD(lParam);<br> 　　　　wh = HIWORD(lParam);<br> 　　　　break;<br> <br> 　　　　case WM_PAINT:<br> 　　　　hDC = BeginPaint(hWnd,&amp;ps);<br> 　　　　y0 = rect.top;<br> 　　　　for(y=0;y&lt;wh/3;y++)<br> 　　　　{<!-- --><br> 　　　　　　color = RGB(y+255-wh/3,0,0);<br> 　　　　　　hNewPen = CreatePen(PS_SOLID,0,color);<br> 　　　　　　hOldPen = (HPEN)SelectObject(hDC,hNewPen);<br> 　　　　　　MoveToEx(hDC,rect.left,y+y0,NULL);<br> 　　　　　　LineTo(hDC,rect.right,y+y0);<br> 　　　　　　hNewPen = (HPEN)SelectObject(hDC,hOldPen);<br> 　　　　　　DeleteObject(hNewPen);<br> 　　　　}<br> 　　　　y0 = rect.top+wh/3;<br> 　　　　for(y=0;y&lt;wh/3;y++)<br> 　　　　{<!-- --><br> 　　　　　　color = RGB(0,y+255-wh/3,0);<br> 　　　　　　hNewPen = CreatePen(PS_SOLID,0,color);<br> 　　　　　　hOldPen = (HPEN)SelectObject(hDC,hNewPen);<br> 　　　　　　MoveToEx(hDC,rect.left,y+y0,NULL);<br> 　　　　　　LineTo(hDC,rect.right,y+y0);<br> 　　　　　　hNewPen = (HPEN)SelectObject(hDC,hOldPen);<br> 　　　　　　DeleteObject(hNewPen);<br> 　　　　}<br> 　　　　y0 = rect.top+2*wh/3;<br> 　　　　for(y=0;y&lt;wh/3;y++)<br> 　　　　{<!-- --><br> 　　　　　　color = RGB(0,0,y+255-wh/3);<br> 　　　　　　hNewPen = CreatePen(PS_SOLID,0,color);<br> 　　　　　　hOldPen = (HPEN)SelectObject(hDC,hNewPen);<br> 　　　　　　MoveToEx(hDC,rect.left,y+y0,NULL);<br> 　　　　　　LineTo(hDC,rect.right,y+y0);<br> 　　　　　　hNewPen = (HPEN)SelectObject(hDC,hOldPen);<br> 　　　　　　DeleteObject(hNewPen);<br> 　　　　}<br> 　　　　EndPaint(hWnd,&amp;ps);<br> 　　　　break;<br> <br> 　　　　case WM_DESTROY:<br> 　　　　PostQuitMessage(0);<br> 　　　　break;<br> 　　　　default:<br> 　　　　return DefWindowProc(hWnd,message,wParam,lParam);<br> 　　}<br> 　　return 0;<br> }<br> <br> <strong>三、画椭圆程序</strong><br> ? <br> #include &lt;windows.h&gt;<br> #include &lt;time.h&gt;<br> ? <br> #define IDC_TIMER 100<br> ? <br> int WINAPI<br> WinMain(HINSTANCE,HINSTANCE,LPSTR,int);<br> LRESULT CALLBACK WndProc(HWND, UINT,WPARAM,LPARAM);<br> int randomize();<br> int random(int);<br> int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br> {<!-- --><br> 　　randomize();<br> 　　WNDCLASSEX wcex;<br> 　　wcex.cbSize = sizeof(WNDCLASSEX); <br> 　　wcex.style = CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;<br> 　　wcex.lpfnWndProc = (WNDPROC)WndProc;<br> 　　wcex.cbClsExtra = 0;<br> 　　wcex.cbWndExtra = 0;<br> 　　wcex.hInstance = hInstance;<br> 　　wcex.hIcon = LoadIcon(hInstance,(LPCTSTR)IDI_APPLICATION);<br> 　　wcex.hCursor = LoadCursor(NULL,IDC_ARROW);<br> 　　wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);<br> 　　wcex.lpszMenuName = NULL;<br> 　　wcex.lpszClassName = "WndCls";<br> 　　wcex.hIconSm = LoadIcon(hInstance,(LPCTSTR)IDI_APPLICATION);<br> 　　if(!RegisterClassEx(&amp;wcex)) return FALSE;<br> 　　int SW_XFS = GetSystemMetrics(SM_CXSCREEN);<br> 　　int SW_YFS = GetSystemMetrics(SM_CYSCREEN);<br> 　　HWND hWnd;<br> 　　hWnd = CreateWindowEx(WS_EX_CLIENTEDGE,<br> 　　　　　　　　　　　　　"WndCls",<br> 　　　　　　　　　　　　　"Drawing Ellipse of Windows Program",<br> 　　　　　　　　　　　　　WS_OVERLAPPEDWINDOW,<br> 　　　　　　　　　　　　　0,<br> 　　　　　　　　　　　　　0,<br> 　　　　　　　　　　　　　SW_XFS,<br> 　　　　　　　　　　　　　SW_YFS-25,<br> 　　　　　　　　　　　　　NULL,<br> 　　　　　　　　　　　　　NULL,<br> 　　　　　　　　　　　　　hInstance,<br> 　　　　　　　　　　　　　NULL);<br> 　　if(!hWnd) return FALSE;<br> 　　ShowWindow(hWnd, SW_SHOWNORMAL);<br> 　　UpdateWindow(hWnd);<br> 　　SetTimer(hWnd,IDC_TIMER,500,NULL);<br> 　　MSG msg;<br> 　　while(GetMessage(&amp;msg,NULL,0,0)) <br> 　　{<!-- --><br> 　　　　TranslateMessage(&amp;msg);<br> 　　　　DispatchMessage(&amp;msg);<br> 　　}<br> 　　return msg.wParam;<br> }<br> <br> LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<br> {<!-- --><br> 　　static RECT rect;<br> 　　static int ww,wh;<br> 　　HPEN hOldPen,hNewPen;<br> 　　HBRUSH hOldBrush,hNewBrush;<br> 　　LOGBRUSH LogBrush;<br> 　　HDC hDC;<br> 　　COLORREF color;<br> 　　switch (message) <br> 　　{<!-- --><br> 　　　　case WM_CREATE:<br> 　　　　GetClientRect(hWnd,&amp;rect);<br> 　　　　ww = rect.right-rect.left;<br> 　　　　wh = rect.bottom-rect.top;<br> 　　　　break;<br> <br> 　　　　case WM_SIZE:<br> 　　　　ww = LOWORD(lParam);<br> 　　　　wh = HIWORD(lParam);<br> 　　　　break;<br> <br> 　　　　case WM_TIMER:<br> 　　　　hDC = GetDC(hWnd);<br> 　　　　color = RGB(250*random(2),250*random(2),250*random(2));<br> 　　　　hNewPen = CreatePen(PS_SOLID,0,color);<br> 　　　　hOldPen = (HPEN)SelectObject(hDC,hNewPen);<br> 　　　　LogBrush.lbStyle = BS_SOLID;<br> 　　　　LogBrush.lbHatch = HS_CROSS;<br> 　　　　LogBrush.lbColor = color; <br> 　　　　hNewBrush = CreateBrushIndirect(&amp;LogBrush);<br> 　　　　hOldBrush = (HBRUSH)SelectObject(hDC,hNewBrush);<br> 　　　　Ellipse(hDC,random(ww),random(wh),random(ww),random(wh));<br> 　　　　hNewPen = (HPEN)SelectObject(hDC,hOldPen);<br> 　　　　hNewBrush = (HBRUSH)SelectObject(hDC,hOldBrush);<br> 　　　　DeleteObject(hNewPen);<br> 　　　　DeleteObject(hNewBrush);<br> 　　　　ReleaseDC(hWnd,hDC); <br> 　　　　break;<br> <br> 　　　　case WM_DESTROY:<br> 　　　　PostQuitMessage(0);<br> 　　　　break;<br> 　　　　default:<br> 　　　　return DefWindowProc(hWnd,message,wParam,lParam);<br> 　　}<br> 　　return 0;<br> }<br> ? <br> int randomize()<br> {<!-- --><br> 　　srand((unsigned int)time(NULL));<br> 　　return 0; <br> }<br> ? <br> int random(int number)<br> {<!-- --><br> 　　int rn;<br> 　　rn = (int)(((long)rand()*number)/(RAND_MAX+1));<br> 　　return rn;<br> }<br> <br> <strong>四、输出文本程序</strong><br> #include &lt;windows.h&gt;<br> int WINAPI<br> WinMain(HINSTANCE,HINSTANCE,LPSTR,int);<br> LRESULT CALLBACK<br> WndProc(HWND,UINT,WPARAM,LPARAM);<br> int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br> {<!-- --><br> 　　WNDCLASSEX wcex;<br> 　　wcex.cbSize = sizeof(WNDCLASSEX); <br> 　　wcex.style = CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;<br> 　　wcex.lpfnWndProc = (WNDPROC)WndProc;<br> 　　wcex.cbClsExtra = 0;<br> 　　wcex.cbWndExtra = 0;<br> 　　wcex.hInstance = hInstance;<br> 　　wcex.hIcon = LoadIcon(hInstance,(LPCTSTR)IDI_APPLICATION);<br> 　　wcex.hCursor = LoadCursor(NULL, IDC_ARROW);<br> 　　wcex.hbrBackground = (HBRUSH)COLOR_INACTIVECAPTION;<br> 　　wcex.lpszMenuName = NULL;<br> 　　wcex.lpszClassName = "WndCls";<br> 　　wcex.hIconSm = LoadIcon(hInstance,(LPCTSTR)IDI_APPLICATION);<br> 　　if(!RegisterClassEx(&amp;wcex)) return FALSE;<br> 　　int SW_XFS = GetSystemMetrics(SM_CXSCREEN);<br> 　　int SW_YFS = GetSystemMetrics(SM_CYSCREEN);<br> 　　HWND hWnd;<br> 　　hWnd = CreateWindowEx(WS_EX_CLIENTEDGE,<br> 　 　　　　　　　　　　　 "WndCls",<br> 　 　　　　　　　　　　　"Drawing text of Windows Program",<br> 　 　　　　　　　　　　　 WS_OVERLAPPEDWINDOW,<br> 　 　　　　　　　　　　　 0,<br> 　 　　　　　　　　　　　 0,<br> 　 　　　　　　　　　　　 SW_XFS,<br> 　 　　　　　　　　　　　 SW_YFS-25,<br> 　 　　　　　　　　　　　 NULL,<br> 　 　　　　　　　　　　　 NULL,<br> 　 　　　　　　　　　　　 hInstance,<br> 　 　　　　　　　　　　　 NULL);<br> 　　if(!hWnd) return FALSE;<br> 　　ShowWindow(hWnd, SW_SHOWNORMAL);<br> 　　UpdateWindow(hWnd);<br> 　　MSG msg;<br> 　　while(GetMessage(&amp;msg,NULL,0,0)) <br> 　　{<!-- --><br> 　　　　TranslateMessage(&amp;msg);<br> 　　　　DispatchMessage(&amp;msg);<br> 　　}<br> 　　return msg.wParam;<br> }<br> <br> LRESULT CALLBACK WndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<br> {<!-- --><br> 　　static int ch,cw;<br> 　　char *s;<br> 　　int sl;<br> 　　int xs,ys;<br> 　　static RECT rect;<br> 　　static int ww,wh;<br> 　　HFONT hOldFont,hNewFont;<br> 　　COLORREF color;<br> 　　HDC hDC;<br> 　　PAINTSTRUCT ps;<br> 　　switch (message) <br> 　　{<!-- --><br> 　　　　case WM_CREATE:<br> 　　　　GetClientRect(hWnd,&amp;rect);<br> 　　　　ww = rect.right-rect.left;<br> 　　　　wh = rect.bottom-rect.top;<br> 　　　　break;<br> <br> 　　　　case WM_SIZE:<br> 　　　　ww = LOWORD(lParam);<br> 　　　　wh = HIWORD(lParam);<br> 　　　　break;<br> <br> 　　　　case WM_PAINT:<br> 　　　　hDC = BeginPaint(hWnd,&amp;ps);<br> 　　　　SetBkMode(hDC,TRANSPARENT);<br> 　　　　ch = 48;<br> 　　　　cw = 24;<br> 　　　　hNewFont = CreateFont(-ch,<br> 　　　　　　　　　　　　　　　cw,<br> 　　　　　　　　　　　　　　　0,<br> 　　　　　　　　　　　　　　　0,<br> 　　　　　　　　　　　　　　　FW_BOLD,<br> 　　　　　　　　　　　　　　　FALSE,<br> 　　　　　　　　　　　　　　　FALSE,<br> 　　　　　　　　　　　　　　　FALSE,<br> 　　　　　　　　　　　　　　　GB2312_CHARSET,<br> 　　　　　　　　　　　　　　　OUT_DEFAULT_PRECIS,<br> 　　　　　　　　　　　　　　　CLIP_DEFAULT_PRECIS,<br> 　　　　　　　　　　　　　　　PROOF_QUALITY,<br> 　　　　　　　　　　　　　　　DEFAULT_PITCH,<br> 　　　　　　　　　　　　　　　"隶书"); <br> 　　　　hOldFont = (HFONT)SelectObject(hDC, hNewFont);<br> 　　　　s = "在窗体客户区输出文本";<br> 　　　　sl = strlen(s);<br> 　　　　xs = (ww-cw*sl)/2;<br> 　　　　ys = (wh)/2-ch;<br> 　　　　color = RGB(255,0,0);<br> 　　　　SetTextColor(hDC,color);<br> 　　　　TextOut(hDC,xs+1,ys+1,s,sl);<br> 　　　　color = RGB(255,255,0);<br> 　　　　SetTextColor(hDC,color);<br> 　　　　TextOut(hDC,xs,ys,s,sl);<br> 　　　　hNewFont = (HFONT)SelectObject(hDC,hOldFont);<br> 　　　　DeleteObject(hNewFont);<br> 　　　　EndPaint(hWnd,&amp;ps);<br> 　　　　break;<br> <br> 　　　　case WM_DESTROY:<br> 　　　　PostQuitMessage(0);<br> 　　　　break;<br> 　　　　default:<br> 　　　　return DefWindowProc(hWnd,message,wParam,lParam);<br> 　　}<br> 　　return 0;<br> }<br> <br> <strong>直线</strong><br> Windows可以画直线、椭圆线（椭圆圆周上的曲线）。 <br> Windows画线函数是：<br> 　　LineTo画直线；Poiyline和PoiylineTo画一系列相连的直线；PolyPolyline画多组相连的线；Arc 画椭圆线；<br> 　　设备描述表的5个属性影响着用这些函数所画线的外观：当前画笔的位置（仅用于LineTo、PoiylineTo和 Arc）、画笔、背景方式、背景色和绘图模式。<br> 　画一条直线，必须调用两个函数。第一个函数指定了线的开始点，第二个函数指定了线的终点：</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c7805772456ca0d82fd9d7bc3fc0a4a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">zoj 2672</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92d5ae2cdd725c02ae89e2242e7391b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Like SQL语句的优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>