<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java8新特性3--lambda表达式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java8新特性3--lambda表达式" />
<meta property="og:description" content="开发中，经常需要给一个方法传递一个接口类型的参数，为了传递不同的行为，我们需要创建不同的实现类，而通常这些类没什么重用价值，只使用一次就没用了。
考虑一个从一堆苹果中筛选符合条件的苹果的场景。
为了更好的应对需求变更，一个比较好的解决办法是将过滤的标准抽象出来，我们先定义一个接口作为抽象的选择标准.
public interface ApplePredicate{ boolean test(Apple apple); } 接下来就可以定义多个ApplePredicate接口的实现类来代表不同的过滤标准。
public class AppleHeavyWeightPredicate implements ApplePredicate{ public boolean test(Apple apple){ return apple.getWeight() &gt; 150; } } //select only green apple public class AppleGreenColorPredicate implements ApplePredicate{ public boolean test(Apple apple){ return &#34;green&#34;.equals(apple.getColor); } } 上面每一个实现了ApplePredicate接口的类都代表了一种筛选策略。
在此基础上，我们可以将筛选方法修改成下面的样子,将ApplePredicate作为参数传入。这就是所谓的行为参数化。
public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, ApplePredicate p){ List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple : inventory){ if(p.test(apple)){ result.add(apple); } } return result; } 现在的筛选方法很灵活，如果想改变筛选标准，只需创建不同的ApplePredicate对象，并传入filterApples方法即可。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d027a77b6c5b5d12099c96a18531f9c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-01-04T11:04:06+08:00" />
<meta property="article:modified_time" content="2018-01-04T11:04:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java8新特性3--lambda表达式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre> 
 <div>
  
  <p>开发中，经常需要给一个方法传递一个接口类型的参数，为了传递不同的行为，我们需要创建不同的实现类，而通常这些类没什么重用价值，只使用一次就没用了。</p>


  
  <p>考虑一个从一堆苹果中筛选符合条件的苹果的场景。</p>

  
  <p>为了更好的应对需求变更，一个比较好的解决办法是将过滤的标准抽象出来，我们先定义一个接口作为抽象的选择标准.</p>

  
  <pre><code class="language-java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplePredicate</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span></span>;
}
</code></code></pre>
  
  <p>接下来就可以定义多个ApplePredicate接口的实现类来代表不同的过滤标准。</p>
  
  <pre><code class="language-java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleHeavyWeightPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplePredicate</span></span>{ 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span></span>{
        <span class="hljs-keyword">return</span> apple.getWeight() &gt; <span class="hljs-number">150</span>;
    }
}

</code></code></pre>
  
  <pre><code class="language-java"><code class="java"><span class="hljs-comment">//select only green apple</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleGreenColorPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplePredicate</span></span>{ 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"green"</span>.equals(apple.getColor);
    }
}
</code></code></pre>
  
  <p>上面每一个实现了ApplePredicate接口的类都代表了一种筛选策略。</p>
  
  <p>在此基础上，我们可以将筛选方法修改成下面的样子,将ApplePredicate作为参数传入。这就是所谓的行为参数化。</p>
  
  <pre><code class="language-php"><code class="php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">List</span>&lt;Apple&gt; filterApples(<span class="hljs-keyword">List</span>&lt;Apple&gt; inventory, ApplePredicate p){
    <span class="hljs-keyword">List</span>&lt;Apple&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span>(Apple apple : inventory){
        <span class="hljs-keyword">if</span>(p.test(apple)){
            result.add(apple);
        }
    }
    <span class="hljs-keyword">return</span> result;
}

</code></code></pre>
  
  <p>现在的筛选方法很灵活，如果想改变筛选标准，只需创建不同的ApplePredicate对象，并传入filterApples方法即可。</p>
  
  <p>例如新增了选出红色并且重量大于150g的苹果的需求，我们可以创建一个实现ApplePredicate接口的类即可，代码如下:</p>
  
  <pre><code class="language-java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleRedAndHeavyPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplePredicate</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"red"</span>.equals(apple.getColor()) &amp;&amp; apple.getWeight() &gt; <span class="hljs-number">150</span>;
    }
}
 
List&lt;Apple&gt; redAndHeavyApples = filter(inventory, <span class="hljs-keyword">new</span> AppleRedAndHeavyPredicate());

</code></code></pre>
  
  <p>但是上面的实现有一个缺点，就是太啰嗦了，每新增一个筛选标准都要新增一个类。下面来继续优化一下。</p>
  
  <h2>使用匿名类</h2>
  
  <p>匿名类是没有名字的类，使用匿名类可以创建一个临时的实现。下面的代码展示了如何利用匿名类创建实现了ApplePredicate的对象。</p>
  
  <pre><code class="language-java"><code class="java">List&lt;Apple&gt; redApples = filterApples(inventory, <span class="hljs-keyword">new</span> ApplePredicate(){
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"red"</span>.equals(apple.getColor());
    }
});
</code></code></pre>
  
  <p>但是尽管匿名类解决了为一个接口声明多个实现类的问题，使用匿名类还不足够好。使用匿名类代码看起来有些笨重，可读性差，而且有一些开发者对匿名类感到困惑。</p>
  
  <h2>Lambda</h2>
  
  <p>Java 8中推出了解决这个问题的新工具——Lambda表达式。它可以让你很简洁地表示一个行为或传递代码。</p>
  
  <p>可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式:它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。</p>
  
  <ol><li>匿名——我们说匿名，是因为它不像普通的方法那样有一个明确的名称!</li><li>函数——我们说它是函数，是因为Lambda函数不像方法那样属于某个特定的类。但和方法一样，Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表。</li><li>传递——Lambda表达式可以作为参数传递给方法或存储在变量中。</li><li>简洁——无需像匿名类那样写很多模板代码。</li></ol>
  
  <p>利用Lambda 表达式，你可以更为简洁地自定义一个Comparator对象。</p>
  
  <p>先前:</p>
  
  <pre><code class="language-java"><code class="java"> Comparator&lt;Apple&gt; byWeight = <span class="hljs-keyword">new</span> Comparator&lt;Apple&gt;() {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Apple a1, Apple a2)</span></span>{
        <span class="hljs-keyword">return</span> a1.getWeight().compareTo(a2.getWeight());
    }; 
 }
</code></code></pre>
  
  <p>用了Lambda表达式后:</p>
  
  <pre class="hljs xml"><code class="xml"> Comparator<span class="hljs-tag">&lt;<span class="hljs-name">Apple</span>&gt;</span> byWeight =
(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());
</code></pre>
  
  <p>不得不承认，代码看起来更清晰了!</p>
  
  <h2>Lambda 表达式的结构</h2>
  
  <p>上面的Lambda表达式我们可以将其分解成三个部分:</p>
  
  <ol><li>参数列表——这里它采用了Comparator中compare方法的参数，两个Apple。</li><li>箭头—— 箭头-&gt;把参数列表与Lambda主体分隔开。</li><li>Lambda主体——a1.getWeight().compareTo(a2.getWeight())，表达式就是Lambda的返回值。</li></ol>
  
  <p>以下是一些 Lambda 表达式的例子：</p>
  
  <pre><code class="language-cpp"><code class="cpp">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; {  <span class="hljs-keyword">return</span> a + b; }

() -&gt; System.out.println(<span class="hljs-string">"Hello World"</span>);

(String s) -&gt; { System.out.println(s); }

() -&gt; <span class="hljs-number">42</span>

() -&gt; { <span class="hljs-keyword">return</span> <span class="hljs-number">3.1415</span> };

Runnable run= () -&gt; System.out.println(<span class="hljs-string">"Hello World"</span>);

</code></code></pre>
  
  <p>Lambda表达式的特点：</p>
  
  <ul><li><p>一个 Lambda 表达式可以有零个或多个参数</p></li><li><p>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</p></li><li><p>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)</p></li><li><p>空圆括号代表参数集为空。例如：() -&gt; 42</p></li><li><p>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; a*a</p></li><li><p>Lambda 表达式的主体可包含零条或多条语句</p></li><li><p>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。</p></li><li><p>匿名函数的返回类型与该主体表达式一致</p></li><li><p>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。</p></li><li><p>表达式就是Lambda的返回值，意味着你无需写return，若表达式没有返回则为空</p></li><li><p>可以显示的通过return关键字返回值，但必须将主体写在{}中，如(Integer i) -&gt; return "Alan" + i;是错误的写法</p></li><li><p>Lambda表达式可以用变量接收。</p></li></ul>
  
  <h2>在哪里以及如何使用Lambda</h2>
  
  <p>现在你可能在想，在哪里可以使用Lambda表达式。在上一个例子中，你把Lambda赋给了一<br>个Comparator&lt;Apple&gt;类型的变量。</p>
  
  <p>你也可以在上面的filter方法中使用Lambda:</p>
  
  <pre><code class="language-php"><code class="php"><span class="hljs-keyword">List</span>&lt;Apple&gt; greenApples =
filter(inventory, (Apple a) -&gt; <span class="hljs-string">"green"</span>.equals(a.getColor())); 
</code></code></pre>
  
  <p>事实上，你可以在函数式接口上使用Lambda表达式。</p>
  
  <h2>函数式接口</h2>
  
  <p>函数式接口就是只定义了一个抽象方法的接口。像Java中的Runnable,Comparator等等都只定义了一个方法，这种接口就都是函数式接口。</p>
  
  <p>Java8中接口还可以拥有默认方法(即在类没有对方法进行实现时， 其主体为方法提供默认实现的方法)。哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。</p>
  
  <p>继承了其他接口的接口，如果它总共的抽象方法不止一个，也不是函数式接口。</p>
  
  <p>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例(具体说来，是函数式接口一个具体实现的实例)。你用匿名内部类也可以完成同样的事情，只不过比较笨拙:需要提供一个实现，然后 再直接内联将它实例化。</p>
  
  <p><em>请注意，任何函数式接口都不允许抛出受检异常(checked exception)。如果你需要Lambda<br>表达式来抛出异常，有两种办法:定义一个自己的函数式接口，并声明受检异常，或者把Lambda 包在一个try/catch块中。</em></p>
  
  <p>示例：</p>
  
  <pre><code class="language-java"><code class="java"><span class="hljs-comment">//旧方法:</span>
<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
    System.out.println(<span class="hljs-string">"Hello from thread"</span>);
}
}).start();

<span class="hljs-comment">//新方法:</span>
<span class="hljs-keyword">new</span> Thread(
() -&gt; System.out.println(<span class="hljs-string">"Hello from thread"</span>)
).start();

</code></code></pre>
  
  <h2>@FunctionalInterface</h2>
  
  <p>如果你去看看新的Java API，会发现函数式接口带有@FunctionalInterface的标注.</p>
  
  <p>这个标注用于表示该接口会设计成 一个函数式接口。</p>
  
  <p>如果你用@FunctionalInterface定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误,表明存在多个抽象方法。请注意，@FunctionalInterface不是必需的，但对于为此设计的接口而言，使用它是比较好的做法。它就像是@Override 标注表示方法被重写了。</p>
  
  <p>我相信，从此你会对Lambda爱不释手的，赶紧用起来吧</p>
 
 </div><br><br>作者：不迷失<br>链接：https://www.jianshu.com/p/a879229b64e9<br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/861d8d03176d9e45f8cca4aa592ed041/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java8新特性2--注解变化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39325b2b92df2ff168686621b44622fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决ie8中文传值乱码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>