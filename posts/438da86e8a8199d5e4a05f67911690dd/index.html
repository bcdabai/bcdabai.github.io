<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL驱动扯后腿？Spring Boot用虚拟线程可能比用物理线程还差 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL驱动扯后腿？Spring Boot用虚拟线程可能比用物理线程还差" />
<meta property="og:description" content="之前已经分享过多篇关于Spring Boot中使用 Java 21新特性虚拟线程 的性能测试案例：
Spring Boot 3.2虚拟线程搭建静态文件服务器有多快？
Spring Boot 虚拟线程与Webflux的性能比较
早上看到群友问到一个关于虚拟线程遇到MySQL连接不兼容导致的性能问题：
这个问题确实之前就有看到过相关的评测，顺着个这个问题，重新把相关评测找出来，给大家分享一下。
以下内容主要参考文章：https://medium.com/deno-the-complete-reference/springboot-physical-vs-virtual-threads-vs-webflux-performance-comparison-for-jwt-verify-and-mysql-23d773b41ffd
评测案例 评测采用现实场景中的处理流程，具体如下：
从HTTP授权标头（authorization header）中提取 JWT
验证 JWT 并从中提取用户的电子邮件
使用提取到的电子邮件执行 MySQL 查询用户
返回用户记录
这个场景其实是 Spring Boot 虚拟线程与Webflux的性能比较 测试的后续。前文主要对比了虚拟线程和WebFlux的，但没有对比虚拟线程与物理线程的区别。所以，接下来的内容就是本文关心的重点：在物理线程和虚拟线程下，MySQL驱动是否有性能优化。
测试环境 Java 20（使用预览模式，开启虚拟线程）
Spring Boot 3.1.3
依赖的第三方库：jjwt、mysql-connector-java
测试工具：Bombardier
采用了开源负载测试工具：Bombardier。在测试场景中预先创建 100,000 个 JWT 列表。
在测试期间，Bombardier 从该池中随机选择了JWT，并将它们包含在HTTP请求的Authorization标头中。
MySQL表结构与数据准备
User表结构如下：
mysql&gt; desc users; &#43;--------&#43;--------------&#43;------&#43;-----&#43;---------&#43;-------&#43; | Field | Type | Null | Key | Default | Extra | &#43;--------&#43;--------------&#43;------&#43;-----&#43;---------&#43;-------&#43; | email | varchar(255) | NO | PRI | NULL | | | first | varchar(255) | YES | | NULL | | | last | varchar(255) | YES | | NULL | | | city | varchar(255) | YES | | NULL | | | county | varchar(255) | YES | | NULL | | | age | int | YES | | NULL | | &#43;--------&#43;--------------&#43;------&#43;-----&#43;---------&#43;-------&#43; 6 rows in set (0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/438da86e8a8199d5e4a05f67911690dd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-18T15:05:57+08:00" />
<meta property="article:modified_time" content="2024-01-18T15:05:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL驱动扯后腿？Spring Boot用虚拟线程可能比用物理线程还差</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>之前已经分享过多篇关于Spring Boot中使用 <a href="" rel="nofollow">Java 21新特性虚拟线程</a> 的性能测试案例：</p> 
 <ul><li><p><a href="" rel="nofollow">Spring Boot 3.2虚拟线程搭建静态文件服务器有多快？</a></p></li><li><p><a href="" rel="nofollow">Spring Boot 虚拟线程与Webflux的性能比较</a></p></li></ul> 
 <p>早上看到群友问到一个关于虚拟线程遇到MySQL连接不兼容导致的性能问题：</p> 
 <img src="https://images2.imgbox.com/78/76/4NTkKsgh_o.png" alt="d6ddfca4f859cd0c24ce5ffaef3256c8.png"> 
 <p>这个问题确实之前就有看到过相关的评测，顺着个这个问题，重新把相关评测找出来，给大家分享一下。</p> 
 <blockquote> 
  <p>以下内容主要参考文章：https://medium.com/deno-the-complete-reference/springboot-physical-vs-virtual-threads-vs-webflux-performance-comparison-for-jwt-verify-and-mysql-23d773b41ffd</p> 
 </blockquote> 
 <h3>评测案例</h3> 
 <p>评测采用现实场景中的处理流程，具体如下：</p> 
 <ol><li><p>从HTTP授权标头（authorization header）中提取 JWT</p></li><li><p>验证 JWT 并从中提取用户的电子邮件</p></li><li><p>使用提取到的电子邮件执行 MySQL 查询用户</p></li><li><p>返回用户记录</p></li></ol> 
 <p>这个场景其实是 <a href="" rel="nofollow">Spring Boot 虚拟线程与Webflux的性能比较</a> 测试的后续。前文主要对比了虚拟线程和WebFlux的，但没有对比虚拟线程与物理线程的区别。所以，接下来的内容就是本文关心的重点：在物理线程和虚拟线程下，MySQL驱动是否有性能优化。</p> 
 <h3>测试环境</h3> 
 <ul><li><p>Java 20（使用预览模式，开启虚拟线程）</p></li><li><p>Spring Boot 3.1.3</p></li><li><p>依赖的第三方库：jjwt、mysql-connector-java</p></li></ul> 
 <p><strong>测试工具：Bombardier</strong></p> 
 <p>采用了开源负载测试工具：Bombardier。在测试场景中预先创建 100,000 个 JWT 列表。</p> 
 <p>在测试期间，Bombardier 从该池中随机选择了JWT，并将它们包含在HTTP请求的Authorization标头中。</p> 
 <p><strong>MySQL表结构与数据准备</strong></p> 
 <p>User表结构如下：</p> 
 <pre class="has"><code class="language-go">mysql&gt; desc users;
+--------+--------------+------+-----+---------+-------+
| Field  | Type         | Null | Key | Default | Extra |
+--------+--------------+------+-----+---------+-------+
| email  | varchar(255) | NO   | PRI | NULL    |       |
| first  | varchar(255) | YES  |     | NULL    |       |
| last   | varchar(255) | YES  |     | NULL    |       |
| city   | varchar(255) | YES  |     | NULL    |       |
| county | varchar(255) | YES  |     | NULL    |       |
| age    | int          | YES  |     | NULL    |       |
+--------+--------------+------+-----+---------+-------+
6 rows in set (0.00 sec)</code></pre> 
 <p>准备大约10w条数据：</p> 
 <pre class="has"><code class="language-go">mysql&gt; select count(*) from users;
+----------+
| count(*) |
+----------+
|    99999 |
+----------+
1 row in set (0.01 sec)</code></pre> 
 <h3>测试代码：使用物理线程</h3> 
 <p>配置文件：</p> 
 <pre class="has"><code class="language-go">server.port=3000
spring.datasource.url= jdbc:mysql://localhost:3306/testdb?useSSL=false&amp;allowPublicKeyRetrieval=true
spring.datasource.username= dbuser
spring.datasource.password= dbpwd
spring.jpa.hibernate.ddl-auto= update
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect</code></pre> 
 <p>User实体定义：</p> 
 <pre class="has"><code class="language-go">@Entity
@Table(name = "users")
public class User {
  @Id
  private String email;

  private String first;

  private String last;

  private String city;

  private String county;

  private int age;

  // 省略了getter和setter
}</code></pre> 
 <p>数据访问实现：</p> 
 <pre class="has"><code class="language-go">public interface UserRepository extends CrudRepository&lt;User, String&gt; {

}</code></pre> 
 <p>API实现：</p> 
 <pre class="has"><code class="language-go">@RestController
public class UserController {

    @Autowired
    UserRepository userRepository;

    private SignatureAlgorithm sa = SignatureAlgorithm.HS256;
    private String jwtSecret = System.getenv("JWT_SECRET");

    @GetMapping("/")
    public User handleRequest(@RequestHeader(HttpHeaders.AUTHORIZATION) String authHdr) {
        String jwtString = authHdr.replace("Bearer","");
        Claims claims = Jwts.parser()
            .setSigningKey(jwtSecret.getBytes())
            .parseClaimsJws(jwtString).getBody();

        Optional&lt;User&gt; user = userRepository.findById((String)claims.get("email"));
        return user.get();
    }
}</code></pre> 
 <p>应用主类：</p> 
 <pre class="has"><code class="language-go">@SpringBootApplication
public class UserApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }
}</code></pre> 
 <h3>测试代码：使用虚拟线程</h3> 
 <p>主要调整应用主类，其他一样，具体修改如下：</p> 
 <pre class="has"><code class="language-go">@SpringBootApplication
public class UserApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }

    @Bean
    public TomcatProtocolHandlerCustomizer&lt;?&gt; protocolHandlerVirtualThreadExecutorCustomizer() {
        return protocolHandler -&gt; {
            protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor());
        };
    }
}</code></pre> 
 <h3>测试代码：使用WebFlux</h3> 
 <pre class="has"><code class="language-go">server.port=3000
spring.r2dbc.url=r2dbc:mysql://localhost:3306/testdb?allowPublicKeyRetrieval=true&amp;ssl=false
spring.r2dbc.username=dbuser
spring.r2dbc.password=dbpwd
spring.r2dbc.pool.initial-size=10
spring.r2dbc.pool.max-size=10</code></pre> 
 <pre class="has"><code class="language-go">@Table(name = "users")
public class User {
  @Id
  private String email;

  private String first;

  private String last;

  private String city;

  private String county;

  private int age;

  // 省略getter、setter和构造函数
}</code></pre> 
 <p>数据访问实现：</p> 
 <pre class="has"><code class="language-go">public interface UserRepository extends R2dbcRepository&lt;User, String&gt; {

}</code></pre> 
 <p>业务逻辑实现：</p> 
 <pre class="has"><code class="language-go">@Service
public class UserService {

  @Autowired
  UserRepository userRepository;

  public Mono&lt;User&gt; findById(String id) {
    return userRepository.findById(id);
  }
}</code></pre> 
 <p>API实现：</p> 
 <pre class="has"><code class="language-go">@RestController
@RequestMapping("/")
public class UserController {
  @Autowired
  UserService userService;

  private SignatureAlgorithm sa = SignatureAlgorithm.HS256;
  private String jwtSecret = System.getenv("JWT_SECRET");

  @GetMapping("/")
  @ResponseStatus(HttpStatus.OK)
  public Mono&lt;User&gt; getUserById(@RequestHeader(HttpHeaders.AUTHORIZATION) String authHdr) {
    String jwtString = authHdr.replace("Bearer","");
    Claims claims = Jwts.parser()
        .setSigningKey(jwtSecret.getBytes())
        .parseClaimsJws(jwtString).getBody();
    return userService.findById((String)claims.get("email"));
  }
}</code></pre> 
 <p>应用主类：</p> 
 <pre class="has"><code class="language-go">@EnableWebFlux
@SpringBootApplication
public class UserApplication {

  public static void main(String[] args) {
    SpringApplication.run(UserApplication.class, args);
  }

}</code></pre> 
 <h3>测试结果</h3> 
 <p>每次测试都包含 100 万个请求，分别评估了它们在不同并发（50、100、300）水平下的性能。下面是结果展示：</p> 
 <img src="https://images2.imgbox.com/b4/51/aspRs8ph_o.png" alt="cb78259b4fe6e8b3727c09552194b908.png"> 
 <img src="https://images2.imgbox.com/7a/15/1sDDYWul_o.png" alt="c5412dccf4e484ef6449c492c6b89a13.png"> 
 <img src="https://images2.imgbox.com/73/34/PQk6AR7e_o.png" alt="1f727233ba95e3f60f1b293715961fdc.png"> 
 <img src="https://images2.imgbox.com/e8/d4/y715lCnr_o.png" alt="9f68d73b67b80926494ef007b24a864d.png"> 
 <img src="https://images2.imgbox.com/a1/7d/oDDAmxl4_o.png" alt="878b252e73a3abb97d5ec39579e03652.png"> 
 <img src="https://images2.imgbox.com/00/01/kdPwkvXl_o.png" alt="664cbd99284e983d27c61361aa4098b2.png"> 
 <img src="https://images2.imgbox.com/3b/8c/8vPVxTXQ_o.png" alt="c3650468e68d2a4b7caeec2c156af650.png"> 
 <img src="https://images2.imgbox.com/a7/dd/lKaXHs2s_o.png" alt="fcb57374eb338386370e9fab63e98488.png"> 
 <img src="https://images2.imgbox.com/ca/6e/1d4ekyyV_o.png" alt="d41e780574b25129d0f4f8dd2c31ef42.png"> 
 <img src="https://images2.imgbox.com/50/da/tQHNepIV_o.png" alt="8edaed769da7a89a1942ff7ac3a8198e.png"> 
 <img src="https://images2.imgbox.com/3c/e1/hGZ1Mheb_o.png" alt="0038dcbce573ec4962f4c5680d6bc898.png"> 
 <img src="https://images2.imgbox.com/91/05/45Cuqjpn_o.png" alt="2e8a1e70550523872b4669cf6d915465.png"> 
 <img src="https://images2.imgbox.com/ac/77/N9DmNV8f_o.png" alt="6f70ea8f45ff7a3962d26ca819d53816.png"> 
 <h3>分析总结</h3> 
 <p>在这个测试案例中使用了MySQL驱动，虚拟线程的实现方式性能最差，WebFlux依然保持领先。所以，主要原因在于这个MySQL的驱动对虚拟线程不友好。如果涉及到数据库访问的情况下，需要寻找对虚拟线程支持最佳的驱动程序。另外，该测试使用的是Java 20和Spring Boot 3.1。对于Java 21和Spring Boot 3.2建议读者在使用的时候自行评估。</p> 
 <p>最后，对于MySQL驱动对虚拟线程支持好的，欢迎留言区推荐一下。</p> 
 <p style="text-align:left;">你还在购买国内的各种昂贵又低质的技术教程吗？这里给大家推荐下我们自研的Youtube视频语音转换插件（https://youtube-dubbing.com/），一键外语转中文，英语不好的小伙伴也可以轻松的学习油管上的优质教程了，下面是演示视频，可以直观的感受一下：</p> 
 <p style="text-align:center;">------</p> 
 <p>我们创建了一个高质量的技术交流群，与优秀的人在一起，自己也会优秀起来，赶紧<a href="" rel="nofollow">点击加群</a>，享受一起成长的快乐。</p> 
 <h4>推荐阅读</h4> 
 <ul><li><p><a href="" rel="nofollow">Spring Boot 整合 Camunda 实现工作流</a><br></p></li><li><p><a href="" rel="nofollow">使用Java 17中的 record 替代 Lombok 的部分功能</a><br></p></li><li><p><a href="" rel="nofollow">使用Spring AI让你的Spring Boot应用快速拥有生成式AI能力</a><br></p></li></ul> 
 <p style="text-align:center;">··································</p> 
 <p style="text-align:center;">点击卡片关注我，分享一线前沿干货</p> 
 <p style="text-align:center;">点击阅读原文，直达Java新特性专栏</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/390de99e0d93998508affbe094d32186/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">羡慕同学进了大厂核心部门，看懂这本书你也能行！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/255392c3a99390010dc3a65d078576e7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL运维实战(4.5) SQL_MODE之NO_ZERO_DATE和NO_ZERO_IN_DATE</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>