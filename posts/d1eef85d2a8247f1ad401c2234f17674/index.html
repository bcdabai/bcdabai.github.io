<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MVVM介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MVVM介绍" />
<meta property="og:description" content="MVVM 和 MVVMLight介绍 MVVM是Model-View-ViewModel的简写。类似于目前比较流行的MVC、MVP设计模式，主要目的是 为了分离视图（View）和模型（Model）的耦合。 它是一种极度优秀的设计模式，但并非框架级别的东西，由MVP（Model-View-Presenter）模式与 WPF结合的应用方式时发展演变过来的一种新型架构。 立足于原有MVP框架并且把WPF的新特性糅合进去，以应对PC端开发日益复杂的需求变化。 结构如图所示:
相对于之前把逻辑结构写在Code Behind 里面的方式，MVVM几乎完全解耦了视图和逻辑业务的关系，通过数据绑定和命令来处理UI属性及事件驱动。 同理，ViewModel的视图交互业务逻辑处理导致的属性变更也会通知到View前端，让View前端实时更 新。Model中存放数据模型和数据逻辑、业务逻辑。 这种类型的双向绑定非常优秀，View的变动，会自动反应到ViewModel上，反之亦然。目前JS前端框 架AngularJS也是采用这种设计模式。 MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点:
低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上， 当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 2. 可重用性：可以把一些视图逻辑放在一个ViewModel里面，让很多View重用这段视图逻辑。 3. 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面 设计，使用Expression Blend可以很容易设计界面并生成xml代码。 4. 可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写 如果你目前正在进行微软的 WPF 、Windows Phone、Windows 8、SilverLight相关项目的开发，很有必要了解一下MVVM Light框架。 它轻量（相对于Prism），专注（仅负责MVVM架构模式的实现，没有其他多余的组件），高效（使 用简易，省时减力）,能够帮助你更好的开发你的应用。
如何在你的WPF应用中使用MVMLight 主要使用方式有两种; 一种是去官网上下载MVVMLight Toolkit，安装之后，VS模板中会出现MvvmLight项目模板，你可以 直接使用该项目模板来创建项目了。 里面会包含默认的ViewModelLocator和MainViewModel，MainViewModel就是你Main视图的 ViewModel了，而ViewModelLocator是一个全局的ViewModel加载注册器，这个第二篇会详细说到。
另一种方式就是去NuGet上安装，这无疑是最便捷的事了。在NuGet 工具箱上搜索 MVVM Light，可以看到两个项目，一个是MVVM Light ， 一个是 MVVM Light libraries only。
当前版本是5.3，说明MVVM Light的更新速度还是挺快的，Prerelease中还有 V5.4 的 ALAPHA 版 本。 Nuget上这两个项目的区别就是MVVM Light除了必要的GalaSoft 组件之外，还会额外添加相关分层文件目录形成简单的MVVMLight成型框架 如图它会帮你生成ViewModel文件夹，里面包含MainViewModel和ViewModelLocator文件
至此，一个基于MVVMLight的WPF项目框架基本搭建完成了" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d1eef85d2a8247f1ad401c2234f17674/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-01T20:35:00+08:00" />
<meta property="article:modified_time" content="2022-04-01T20:35:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MVVM介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li style="text-align:justify;">MVVM 和 MVVMLight介绍 MVVM是Model-View-ViewModel的简写。类似于目前比较流行的MVC、MVP设计模式，主要目的是 为了分离视图（View）和模型（Model）的耦合。 它是一种极度优秀的设计模式，但并非框架级别的东西，由MVP（Model-View-Presenter）模式与 WPF结合的应用方式时发展演变过来的一种新型架构。 立足于原有MVP框架并且把WPF的新特性糅合进去，以应对PC端开发日益复杂的需求变化。</li></ul> 
<p style="margin-left:.0001pt;text-align:justify;">结构如图所示:</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="261" src="https://images2.imgbox.com/a9/0e/bo1YSe33_o.png" width="787"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">相对于之前把逻辑结构写在Code Behind 里面的方式，MVVM几乎完全解耦了视图和逻辑业务的关系，通过数据绑定和命令来处理UI属性及事件驱动。 同理，ViewModel的视图交互业务逻辑处理导致的属性变更也会通知到View前端，让View前端实时更 新。Model中存放数据模型和数据逻辑、业务逻辑。 这种类型的双向绑定非常优秀，View的变动，会自动反应到ViewModel上，反之亦然。目前JS前端框 架AngularJS也是采用这种设计模式。 MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点:</p> 
<ol><li style="text-align:justify;">低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上， 当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li style="text-align:justify;"> 2. 可重用性：可以把一些视图逻辑放在一个ViewModel里面，让很多View重用这段视图逻辑。 3. 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面 设计，使用Expression Blend可以很容易设计界面并生成xml代码。 4. 可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">如果你目前正在进行微软的 WPF 、Windows Phone、Windows 8、SilverLight相关项目的开发，很有必要了解一下MVVM Light框架。 它轻量（相对于Prism），专注（仅负责MVVM架构模式的实现，没有其他多余的组件），高效（使 用简易，省时减力）,能够帮助你更好的开发你的应用。</p> 
<ul><li style="text-align:justify;">如何在你的WPF应用中使用MVMLight 主要使用方式有两种;</li></ul> 
<p style="margin-left:.0001pt;text-align:justify;">一种是去官网上下载MVVMLight Toolkit，安装之后，VS模板中会出现MvvmLight项目模板，你可以 直接使用该项目模板来创建项目了。 里面会包含默认的ViewModelLocator和MainViewModel，MainViewModel就是你Main视图的 ViewModel了，而ViewModelLocator是一个全局的ViewModel加载注册器，这个第二篇会详细说到。</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 另一种方式就是去NuGet上安装，这无疑是最便捷的事了。在NuGet 工具箱上搜索 MVVM Light，可以看到两个项目，一个是MVVM Light ， 一个是 MVVM Light libraries only。</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 当前版本是5.3，说明MVVM Light的更新速度还是挺快的，Prerelease中还有 V5.4 的 ALAPHA 版 本。 Nuget上这两个项目的区别就是MVVM Light除了必要的GalaSoft 组件之外，还会额外添加相关分层文件目录形成简单的MVVMLight成型框架 </p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="510" src="https://images2.imgbox.com/b9/d5/eCqPtcIL_o.png" width="770"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">如图它会帮你生成ViewModel文件夹，里面包含MainViewModel和ViewModelLocator文件</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="577" src="https://images2.imgbox.com/04/3d/E9IhNId3_o.png" width="553"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">至此，一个基于MVVMLight的WPF项目框架基本搭建完成了</p> 
<h2 style="text-align:center;"></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f1bde1bb5cf1749e937731f6fa935b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【记录】vue&#43;element使用resetFields重置，保存表单会出现一闪而过上次赋的值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7d820d821d59a95f7c875f975e358c40/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">教师信息管理系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>