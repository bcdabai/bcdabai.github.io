<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 多态 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 多态" />
<meta property="og:description" content="多态 多态基本介绍 方法或对象具有多种形态。是面向对象的三大特征，多态是建立在封装和继承基础之上的。
多态的具体体现 1、方法的多态： 重写和重载就能体现多态。
2、对象的多态：【背下来，记住】
一个对象的编译类型和运行类型可以不一致
编译类型在定义对象时，就已经被确定，不能再改变
运行类型是可以变化的
编译类型看定义时 = 号的左边，运行类型看 = 号的右边
// 可以让父类的引用指向子类的类型。 Animal animal = new Dog(); //animal编译类型是Animal， 运行类型是Dog animal = new Cat(); // animal的运行类型变成了Cat，编译类型仍然为Animal 多态的注意事项和细节讨论 多态的前提是： 1、两个对象(类)存在继承关系。
2、多态的向上转型
3、多态的向下转型
4、类的属性没有重写之说，当调用类的属性时，属性的值为编译类型对应的值,如果在编译类型中没有查到，则去父类中查找属性
package com.encap.poly; public class PolyDetail { public static void main(String[] args) { Animal animal = new Dog(); // 判断运行结果 System.out.println(animal.count); } } class Animal{ int count = 10; } class Dog extends Animal{ int count = 20; } 5、instanceOf比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX类型的子类型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/66df1f366431362dd68a891d47aa1506/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-01T18:27:44+08:00" />
<meta property="article:modified_time" content="2023-08-01T18:27:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 多态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>多态</h2> 
<h3><a id="_2"></a>多态基本介绍</h3> 
<p><strong>方法或对象</strong>具有多种形态。是面向对象的三大特征，多态是建立在封装和继承基础之上的。</p> 
<h3><a id="_6"></a>多态的具体体现</h3> 
<p>1、方法的多态： 重写和重载就能体现多态。</p> 
<p>2、对象的多态：【背下来，记住】</p> 
<ul><li> <p>一个对象的编译类型和运行类型可以不一致</p> </li><li> <p>编译类型在定义对象时，就已经被确定，不能再改变</p> </li><li> <p>运行类型是可以变化的</p> </li><li> <p>编译类型看定义时 = 号的左边，运行类型看 = 号的右边</p> </li></ul> 
<pre><code class="prism language-Java">// 可以让父类的引用指向子类的类型。
Animal animal = new Dog(); //animal编译类型是Animal， 运行类型是Dog  
animal = new Cat();    // animal的运行类型变成了Cat，编译类型仍然为Animal
</code></pre> 
<h3><a id="_27"></a>多态的注意事项和细节讨论</h3> 
<h4><a id="_29"></a>多态的前提是：</h4> 
<p>1、两个对象(类)存在继承关系。</p> 
<p>2、多态的<strong>向上转型</strong></p> 
<p>3、多态的<strong>向下转型</strong></p> 
<p>4、类的属性没有重写之说，<strong>当调用类的属性时，属性的值为编译类型对应的值,如果在编译类型中没有查到，则去父类中查找属性</strong></p> 
<pre><code class="prism language-Java">package com.encap.poly;

public class PolyDetail {
  public static void main(String[] args) {
      Animal animal = new Dog();
      // 判断运行结果
      System.out.println(animal.count);
  }
}

class Animal{
  int count = 10;
}

class Dog extends Animal{
  int count = 20;
}
</code></pre> 
<p>5、instanceOf比较操作符，用于判断<strong>对象的运行类型</strong>是否为 XX 类型或 XX类型的子类型</p> 
<pre><code class="prism language-Java">String str = "hello";
str isstanceOf Object;    // true。   判断对象的运行类型【String】 是否为 XXX（Object）类型或 XX（Object）类型的子类型。
</code></pre> 
<h4><a id="_68"></a>什么叫向上转型：</h4> 
<p>1、本质：父类的引用指向了子类的对象</p> 
<p>2、语法：父类类型 引用名 = new 子类类型();</p> 
<blockquote> 
 <p>Animal animal = new Cat();</p> 
</blockquote> 
<p>3、使用特点：</p> 
<ul><li> <p>编译类型看左边，运行类型看右边。</p> </li><li> <p>可以调用父类中的所有成员(<strong>需遵循父类的访问权限)</strong></p> </li><li> <p>不能调用子类中的特有成员</p> </li></ul> 
<blockquote> 
 <p>对上面两句的解释：在编译阶段，能调用哪些成员，是由编译类型来决定的。javac指令</p> 
</blockquote> 
<ul><li><strong>最终运行效果看运行类型的具体实现</strong>。 即调用成员时，按照从子类(运行类型)开始查找成员，找到则调用，找到没权限则报错。 java指令</li></ul> 
<h4><a id="_88"></a>向下转型</h4> 
<p>1、语法： 子类类型 引用名 = (子类类型) 父类引用;</p> 
<blockquote> 
 <p>Cat cat = (Cat)animal;</p> 
</blockquote> 
<p>2、只能强转<strong>父类的引用</strong>，不能强转<strong>父类的对象。</strong></p> 
<p>3、要求<strong>父类的引用</strong>必须指向的是<strong>当前目标类型的对象</strong></p> 
<p>4、当向下转型后，可以调用子类类型中的所有成员</p> 
<pre><code class="prism language-Java">Animal animal = new Cat();   // 向上转型，子类的对象，指向父类的引用名
Cat cat = (Cat)animal;   // 向下转型， 将父类的引用进行强转，转成 当前目标类型的对象。    
// animal此引用名指向堆中的Cat类，这是向上转型，此时编译类型为Animal，但运行类型为 Cat    
// 向下转型则为，将堆中的Cat类重新创建一个引用，所以要求父类的引用必须指向的是当前目标类型的对象。
</code></pre> 
<h3><a id="_108"></a>动态绑定机制</h3> 
<p>1、当调用对象方法的时候，该方法会对该对象的内存地址/运行类型进行绑定。即为方法从运行类型开始查找。</p> 
<p>2、当调用对象属性时，则没有动态绑定机制，即为，<strong>属性哪个编译类调用，就用哪个编译类的属性</strong></p> 
<p><img src="https://images2.imgbox.com/34/2e/t136yoVt_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>第二点是在方法中使用到属性，所以是对应着声明类。</p> 
</blockquote> 
<blockquote> 
 <p>「多态的前提」是，「类的属性没有重写之说，<strong>当调用类的属性时，属性的值直接对应编译类型得到,如果编译类型中没有，则去父类中查找属性」 。属性没有重写机制，则不需要从子类向父类查找属性，记住这两种情况即可。</strong></p> 
</blockquote> 
<h4><a id="_121"></a>测试题</h4> 
<pre><code class="prism language-Java">package com.encap.test;

public class Test {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.getSum()); 
        System.out.println(a.getSum1()); 
    }
}

class A {
    public int i = 10;

    public int getI() {
        return i;
    }

    public int getSum() {
        return getI() + 10;
    }

    public int getSum1() {
        return i + 10;
    }

}

class B extends A{
    public int i = 20;

    public int getI() {
        return i;
    }

//    public int getSum() {
//        return getI() + 20;
//    }

//    public int getSum1() {
//        return i + 10;
//    }
}
</code></pre> 
<h3><a id="_169"></a>多态数组</h3> 
<p>多态数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。</p> 
<pre><code class="prism language-Java">package com.encap.extend_.Exercise03;

public class Test {
    public static void main(String[] args) {
        PC pc = new PC("inter", 16, 256, "IBM");

//        创建多态数组方法一：
//        Computer[] c = new Computer[2];
//        c[0] = pc;
//        c[1] = new Computer("Mac", 256, 512);
        // 创建多态数组方法二：
        Computer[] c = {pc, new Computer("Mac", 256, 512)};
        for (int i = 0; i &lt; c.length; i++) {
            if (c[i] instanceof PC){
                // 向下转型方法一：
                ((PC)c[i]).printInfo();
                // 向下转型方法二：
//                PC p1 = (PC)c[i];
//                p1.printInfo();
            } else{
                System.out.println(c[i].getDetail());
            }
        }
    }
}


class PC extends Computer{
    private String brand;

    public PC(String CPU, int memory, int disk, String brand) {
        super(CPU, memory, disk);
        this.brand = brand;
    }

    public void printInfo(){
        System.out.println("PC信息为：");
        System.out.println(getDetail() + "品牌为： " + brand);
    }
}

class Computer {
    private String CPU;
    private int memory;
    private int disk;

    public Computer(String CPU, int memory, int disk) {
        this.CPU = CPU;
        this.memory = memory;
        this.disk = disk;
    }

    public String getDetail(){
        return "电脑的详细信息：" + "CPU： " + CPU + " 内存为： " + memory  + " 硬盘为:" + disk;
    }
}


</code></pre> 
<h3><a id="_235"></a>多态参数</h3> 
<p>方法定义的<strong>形参类型为父类类型，实参类型则允许传入子类类型。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42f5a3a730839284501fd2236f62b872/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java 数组的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d71dc04176a806282ca0d6cdedca283/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TypeChat源码分析：基于大语言模型的定制化 AI Agent 交互规范</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>