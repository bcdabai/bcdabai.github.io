<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法-双指针（Java实现） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法-双指针（Java实现）" />
<meta property="og:description" content="算法-双指针（Java实现） 双指针-合并两个有序的数组
双指针-判断是否是回文字符串
双指针-合并区间
双指针-最小覆盖子串
双指针-反转字符串
双指针-最长无重复子数组
双指针-盛水最多的容器
双指针-接雨水问题
双指针-合并两个有序的数组 合并两个有序的数组 描述：给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组
数据范围： 0≤n,m≤100，∣Ai∣&lt;=100，∣Bi∣&lt;=100
注意：
1.保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m&#43;n
2.不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了，且后台会自动将合并后的数组 A 的内容打印出来，所以也不需要自己打印
3.A 数组在[0,m-1]的范围也是有序的
示例2 输入：
[1,2,3],[2,5,6]
返回值：
[1,2,2,3,5,6]
import java.util.*; public class Solution { public void merge(int A[], int m, int B[], int n) { int[] res = new int[m&#43;n]; int i=0,j=0,r=0; while(i&lt;m &amp;&amp; j&lt;n){ //遍历A." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f6378f99f33f5a75d3a164140745c53b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-01T10:43:03+08:00" />
<meta property="article:modified_time" content="2023-03-01T10:43:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法-双指针（Java实现）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="font_face_colorredJavafont_0"></a><font face="黑体" color="red">算法-双指针（Java实现）</font></h3> 
<p><a href="" rel="nofollow">双指针-合并两个有序的数组</a><br> <a href="" rel="nofollow">双指针-判断是否是回文字符串</a><br> <a href="" rel="nofollow">双指针-合并区间</a><br> <a href="" rel="nofollow">双指针-最小覆盖子串</a><br> <a href="" rel="nofollow">双指针-反转字符串</a><br> <a href="" rel="nofollow">双指针-最长无重复子数组</a><br> <a href="" rel="nofollow">双指针-盛水最多的容器</a><br> <a href="" rel="nofollow">双指针-接雨水问题</a></p> 
<h3><a id="font_face_colorredfont_11"></a><font face="黑体" color="red">双指针-合并两个有序的数组</font></h3> 
<h4><a id="_12"></a>合并两个有序的数组</h4> 
<p>描述：给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组<br> 数据范围： 0≤n,m≤100，∣Ai∣&lt;=100，∣Bi∣&lt;=100</p> 
<p>注意：<br> 1.保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m+n<br> 2.不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了，且后台会自动将合并后的数组 A 的内容打印出来，所以也不需要自己打印<br> 3.A 数组在[0,m-1]的范围也是有序的</p> 
<h4><a id="2_21"></a>示例2</h4> 
<p>输入：<br> [1,2,3],[2,5,6]</p> 
<p>返回值：<br> [1,2,2,3,5,6]</p> 
<pre><code>import java.util.*;
public class Solution {
   public void merge(int A[], int m, int B[], int n) {
        int[] res = new int[m+n];  
        int i=0,j=0,r=0;
        while(i&lt;m &amp;&amp; j&lt;n){      //遍历A.B中的元素
            if(A[i]&lt;=B[j]){    //如果A&lt;=B,A先放
                res[r++] = A[i++];
            }else{             //如果A&gt;B，B先放
                res[r++] = B[j++];
            }
        }
        //如果A，B其中有一个遍历完，另一个没遍历完，则将未遍历完的数组中的元素全部加入res中
        while(i&lt;m){     //当A中的元素未遍历完时，将A中剩下的元素全部放入res中
            res[r++]=A[i++];
        }
        while(j&lt;n){     //当B中的元素未遍历完时，将B中剩下的元素全部放入res中
            res[r++]=B[j++];
        }
        for(int k=0;k&lt;res.length;k++){ //最后将数组res中的元素全部存入数组A中
            A[k]=res[k];
        }
    }
}
</code></pre> 
<h3><a id="font_face_colorredfont_54"></a><font face="黑体" color="red">双指针-判断是否是回文字符串</font></h3> 
<p>描述：给定一个长度为 n 的字符串，请编写一个函数判断该字符串是否回文。如果是回文请返回true，否则返回false。<br> 字符串回文指该字符串正序与其逆序逐字符一致。</p> 
<p>数据范围：0&lt;n≤1000000<br> 要求：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)</p> 
<pre><code>import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    public boolean judge (String str) {
        // write code here
        // 判断特殊情况
        if (str == null || str.length() == 0) {
            return false;
        }
        // 定义双指针，不相同则不是回文串
        for (int i = 0, j = str.length()-1; i &lt; j; i++, j--){
            if (str.charAt(i) != str.charAt(j)) return false;
        }

        return true;
    }
}
</code></pre> 
<h3><a id="font_face_colorredfont_87"></a><font face="黑体" color="red">双指针-合并区间</font></h3> 
<p>描述:<br> 给出一组区间，请合并所有重叠的区间。<br> 请保证合并后的区间按区间起点升序排列。</p> 
<p>数据范围：区间组数 0≤n≤2×10^5，区间内 的值都满足 0≤val≤2×10^5</p> 
<p>要求：空间复杂度 O(n)O(n)，时间复杂度 O(nlogn)O(nlogn)<br> 进阶：空间复杂度 O(val)O(val)，时间复杂度O(val)O(val)</p> 
<pre><code>import java.util.*;
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public ArrayList&lt;Interval&gt; merge(ArrayList&lt;Interval&gt; intervals) {
        ArrayList&lt;Interval&gt; res = new ArrayList&lt;&gt;();
        //去除特殊情况
        if(intervals.size() == 0){
            return res;
        }

        Collections.sort(intervals, new Comparator&lt;Interval&gt;(){
            public int compare(Interval o1, Interval o2){
                if(o1.start != o2.start)
                    return o1.start - o2.start;
                else
                    return o1.end - o2.end;
            }
        });

        //放入第一个区间
        res.add(intervals.get(0));
        int count = 0;
        //遍历后续区间，查看是否与末尾有重叠
        for(int i = 1; i &lt; intervals.size(); i++){
            Interval o1 = intervals.get(i);
            Interval origin = res.get(count);
            if(o1.start &gt; origin.end){
                res.add(o1);
                count++;
            //区间有重叠，更新结尾
            }else{
                res.remove(count);
                Interval s = new Interval(origin.start, o1.end);
                if(o1.end &lt; origin.end)
                    s.end = origin.end;
                res.add(s);
            }
        }
        return res;
    }

  
}
</code></pre> 
<h3><a id="font_face_colorredfont_151"></a><font face="黑体" color="red">双指针-最小覆盖子串</font></h3> 
<p>描述:<br> 给出两个字符串 s 和 t，要求在 s 中找出最短的包含 t 中所有字符的连续子串。</p> 
<p>数据范围：0≤∣S∣,∣T∣≤10000，保证s和t字符串中仅包含大小写英文字母</p> 
<p>例如：<br> S ="XDOYEZODEYXNZ"S=“XDOYEZODEYXNZ”<br> T =“XYZ"T=“XYZ”<br> 找出的最短子串为"YXNZ”“YXNZ”.</p> 
<p>注意：<br> 如果 s 中没有包含 t 中所有字符的子串，返回空字符串 “”；<br> 满足条件的子串可能有很多，但是题目保证满足条件的最短的子串唯一。</p> 
<h4><a id="1_166"></a>示例1</h4> 
<p>输入：<br> “XDOYEZODEYXNZ”,“XYZ”</p> 
<p>返回值：<br> “YXNZ”</p> 
<pre><code>import java.util.*;


public class Solution {
    /**
     * 
     * @param S string字符串 
     * @param T string字符串 
     * @return string字符串
     */
    public String minWindow (String S, String T) {
        // 定义边界排序特殊情况
        if(S.length() == 0 || T.length() == 0) {
        return "" ;
        }
        // hash初始化
        int minCount = Integer.MAX_VALUE ;
        int[] hash = new int[128] ;
        for(int i = 0 ; i &lt; T.length() ; i ++) {
            hash[T.charAt(i)] -- ;
        }
        int minLen = Integer.MAX_VALUE ;//记录最小覆盖子串的长度
        int ri = 0 ;//记录最小覆盖子串的左边界
        int rj = 0 ;//记录最小覆盖子串的右边界
        int f = 0 ;//窗口右边界
        int s = 0 ;//窗口左边界
        while(f &lt; S.length()) {//右边界向右移动
            hash[S.charAt(f)]++ ;//将当前右边界坐对对应的字符加入hash
            while(s &lt;= f &amp;&amp; check(hash)) {//如果已经覆盖了,则不断让左边界右移，寻找最短的满足要求的子串
                if(f - s + 1 &lt; minLen) {//更新小覆盖子串的记录
                    minLen = f - s + 1 ;
                    ri = s ;
                    rj = f ;
                }
                hash[S.charAt(s)] -- ;//将左边界移除hash
                s ++ ;//左边界右移
            }
            f ++ ;//右边界右移
        }
        if(f - s + 1 &gt; S.length()) {//如果右边界超出S时左边界都没动过，说明不存在覆盖子串
            return "" ;
        } else {//截取
            return S.substring(ri , rj + 1) ;
        }
    }

      //检查是否有小于0的
    boolean check(int[] hash) {
        for (int i = 0; i &lt; hash.length; i++) {
            if (hash[i] &lt; 0)
                return false;
        }
        return true;
    };
}
</code></pre> 
<h3><a id="font_face_colorredfont_231"></a><font face="黑体" color="red">双指针-反转字符串</font></h3> 
<p>描述:<br> 写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</p> 
<p>数据范围： 0≤n≤1000<br> 要求：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)</p> 
<h4><a id="1_238"></a>示例1</h4> 
<p>输入：<br> “abcd”</p> 
<p>返回值：<br> “dcba”</p> 
<pre><code>import java.util.*;


public class Solution {
    /**
     * 反转字符串
     * @param str string字符串 
     * @return string字符串
     */
    public String solve (String str) {
        // write code here
        char[] ans = str.toCharArray();
        int len = str.length();
        for(int i = 0 ; i &lt; len ;i++){
                ans[i] = str.charAt(len-1-i);
        }
        return new String(ans);
    }
}
</code></pre> 
<h3><a id="font_face_colorredfont_266"></a><font face="黑体" color="red">双指针-最长无重复子数组</font></h3> 
<p>描述:<br> 给定一个长度为n的数组arr，返回arr的最长无重复元素子数组的长度，无重复指的是所有数字都不相同。<br> 子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组</p> 
<h4><a id="1_272"></a>示例1</h4> 
<p>输入：<br> [1,2,3,1,2,3,2,2]</p> 
<p>返回值：<br> 3</p> 
<p>说明：<br> 最长子数组为[1,2,3]</p> 
<h4><a id="_282"></a>解法一，双指针方法</h4> 
<pre><code>import java.util.*;


public class Solution {
    /**
     * 
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxLength (int[] arr) {
        // write code here
        if (arr.length == 0){
            return 0;
        }
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        int max = 0;
        for (int i = 0, j = 0; i &lt; arr.length; ++i) {
            if (map.containsKey(arr[i])) {
                j = Math.max(j, map.get(arr[i]) + 1);
            }
            map.put(arr[i], i);
            max = Math.max(max, i - j + 1);
        }
        return max;
    }
}
</code></pre> 
<h4><a id="_312"></a>解法二，队列</h4> 
<pre><code>import java.util.*;


public class Solution {
    /**
     * 
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxLength (int[] arr) {
    //用链表实现队列，队列是先进先出的
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        int res = 0;
        for (int c : arr) {
            while (queue.contains(c)) {
                //如果有重复的，队头出队
                queue.poll();
            }
            //添加到队尾
            queue.add(c);
            res = Math.max(res, queue.size());
        }
        return res;
    }
}
</code></pre> 
<h4><a id="set_343"></a>解法三，set集合</h4> 
<pre><code>import java.util.*;


public class Solution {
 /**
  * 
  * @param arr int整型一维数组 the array
  * @return int整型
  */
 public int maxLength (int[] arr) {
     int left = 0, right = 0, max = 0;
     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
     while (right &lt; arr.length) {
 		// 有重复的，直接删除前面的数字
         if (set.contains(arr[right])) {
             set.remove(arr[left++]);
         } else {
             set.add(arr[right++]);
             max = Math.max(max, set.size());
         }
     }
     return max;
 }
}
</code></pre> 
<h3><a id="font_face_colorredfont_373"></a><font face="黑体" color="red">双指针-盛水最多的容器</font></h3> 
<p>描述：<br> 给定一个数组height，长度为n，每个数代表坐标轴中的一个点的高度，height[i]是在第i点的高度，请问，从中选2个高度与x轴组成的容器最多能容纳多少水<br> 1.你不能倾斜容器<br> 2.当n小于2时，视为不能形成容器，请返回0<br> 3.数据保证能容纳最多的水不会超过整形范围，即不会超过2^31-1</p> 
<p>数据范围:<br> 0&lt;=height.length&lt;=10^5<br> 0&lt;=height[i]&lt;=10^4</p> 
<h4><a id="1_384"></a>示例1</h4> 
<p>输入：<br> [1,7,3,2,4,5,8,2,7]</p> 
<p>返回值：<br> 49</p> 
<h4><a id="_391"></a>解法一，双指针两边同时移动</h4> 
<pre><code>import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param height int整型一维数组 
     * @return int整型
     */
    public int maxArea (int[] height) {
        int i = 0, j = height.length - 1;
        int h = 1, max = 0;
        while (i &lt; j) {
            if (height[i] &lt; h) { // 左板不达标
                i++;
            } else if (height[j] &lt; h) { // 右板不达标
                 j--;
            } else {
            max = Math.max(h++ * (j - i), max); // 记录水高度为h时的最大盛水量
         }
        }
    return max;
    }
}
</code></pre> 
<h4><a id="_421"></a>解法二，双指针两边同时移动</h4> 
<pre><code>import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param height int整型一维数组 
     * @return int整型
     */
    public int maxArea (int[] height) {
        // write code here
        int left =0,right = height.length-1;
        int max = 0;
        while(left&lt;right){
            if(height[left]&lt;height[right]){
                max = Math.max(max,(height[left]*(right-left)));
                left++;
            }else {
                max = Math.max(max,(height[right]*(right-left)));
                right--;
            }
        }
        return max;
    }
}
</code></pre> 
<h3><a id="font_face_colorredfont_453"></a><font face="黑体" color="red">双指针-接雨水问题</font></h3> 
<p>描述:<br> 给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个柱子高度图，计算按此排列的柱子，下雨之后能接多少雨水。(数组以外的区域高度视为0)</p> 
<p>数据范围：数组长度 0≤n≤2×10^5，数组中每个值满足 0&lt;val≤10^9 ，保证返回结果满足 0≤val≤10^9</p> 
<p>要求：时间复杂度 O(n)O(n)</p> 
<pre><code>import java.util.*;


public class Solution {
    /**
     * max water
     * @param arr int整型一维数组 the array
     * @return long长整型
     */
    public long maxWater (int[] arr) {
        //排除空数组
        if(arr.length == 0)
            return 0;
        long res = 0;
        //左右双指针
        int left = 0;
        int right = arr.length - 1;
        //中间区域的边界高度
        int maxL = 0;
        int maxR = 0;
        //直到左右指针相遇
        while(left &lt; right){
            //每次维护往中间的最大边界
            maxL = Math.max(maxL, arr[left]);
            maxR = Math.max(maxR, arr[right]);
            //较短的边界确定该格子的水量
            if(maxR &gt; maxL)
                res += maxL - arr[left++];
            else
                res += maxR - arr[right--];
        }
        return res;
    }
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5401199cd94f96f4c3bb8c01ae9914ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【项目展示】基于Unity开发的3DRPG游戏</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cfaa5fbacc9a02c5ee5c03e992f4fc16/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Simulink对调制-解调系统的仿真（BASK&#43;BFSK&#43;BPSK）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>