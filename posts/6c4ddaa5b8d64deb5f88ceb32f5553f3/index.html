<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>13- OpenCV：霍夫检测：直线、圆检测 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="13- OpenCV：霍夫检测：直线、圆检测" />
<meta property="og:description" content="目录
一、霍夫变换简介
1、霍夫变换的原理
2、霍夫变换的优点
3、霍夫变换的缺点
4、霍夫变换的应用场景
5、使用霍夫变换的步骤
二、霍夫变换—直线检测
1、霍夫直线变换介绍
2、霍夫直线变换的例子
3、相关API学习（代码例子）
三、霍夫变换—圆检测
1、霍夫圆检测原理
2、相关API学习（代码例子）
一、霍夫变换简介 霍夫变换（Hough Transform）是一种在图像处理中常用的技术，用于检测图像中的直线、圆或其他形状。
在霍夫变换中，直线通常由两个参数表示：斜率和截距。对于每个图像中的点，都可以在参数空间中绘制出与该点相关的曲线。当多个点共线时，它们在参数空间中的曲线会相交于同一个点，从而形成一个峰值。通过寻找参数空间中的峰值，我们可以确定图像中存在的直线。
1、霍夫变换的原理 它的原理是将图像中的每个点转换为参数空间中的曲线或曲面，并通过对这些曲线或曲面进行累加来找到图像中的特定形状。
（1）霍夫空间：对于待检测的形状，霍夫变换将其在参数空间中表示。对于直线检测，参数空间通常是极坐标空间，其中两个参数分别表示直线的长度和角度。对于圆和椭圆检测，参数空间则包括圆心和半径或椭圆参数。
（2）累加过程：对于图像中的每个边缘点，通过遍历参数空间，将其转换为参数空间中的曲线或曲面。当多个边缘点共线或共圆时，在参数空间中会出现峰值。这些峰值表示了可能存在的形状。
（3）阈值和筛选：根据设定的阈值，选择参数空间中的峰值作为检测结果。通常选择峰值强度高于阈值的部分，并进行进一步的筛选和优化。
（4）反变换：根据检测到的参数，在原始图像中绘制出相应的形状。对于直线检测，可以通过计算两个端点的坐标；对于圆和椭圆检测，可以通过计算圆心和半径或椭圆参数。
通过以上步骤，霍夫变换可以在图像中检测出特定形状的位置和参数。
2、霍夫变换的优点 （1）霍夫变换是一种基于几何特征的图像处理方法，对于形状检测具有较好的鲁棒性。它不依赖于形状的大小、方向和位置，能够在图像中准确地检测出各种形状。
（2）霍夫变换可以应用于不同类型的形状检测，包括直线、圆、椭圆等。通过适当选择参数表示方式和累加过程，可以扩展到其他形状的检测。
（3）霍夫变换可以应用于图像中存在噪声或部分遮挡的情况下。通过合适的预处理和参数设置，可以提高对形状的检测准确性。
3、霍夫变换的缺点 （1）霍夫变换的计算复杂度较高，特别是对于大尺寸图像和复杂形状的检测。这会导致算法的执行时间较长，不适用于实时应用或对计算资源要求较高的场景。
（2）霍夫变换对图像中的噪声比较敏感，因此需要进行预处理来降低噪声的影响。这可能会引入额外的步骤和计算开销。
（3）霍夫变换对参数的选择较为敏感，不同形状的检测可能需要不同的参数设置。这对于非专业用户来说可能会增加使用的难度。
（4）霍夫变换在处理曲线或曲面交叉的情况下可能会出现误检测或漏检的问题。特别是当形状之间存在相似性或重叠时，可能会导致结果的不准确性。
总体而言，霍夫变换是一种强大的图像处理技术，但在实际应用中需要综合考虑其优点和缺点，并结合具体场景进行参数调整和算法改进。
4、霍夫变换的应用场景 （1）直线检测：霍夫变换最常用的应用之一是检测图像中的直线。通过将图像中的每个点转换为参数空间中的曲线，可以找到共线点形成的峰值，从而确定直线的位置和方向。
（2）圆检测：除了直线，霍夫变换也可以用于检测图像中的圆。通过将图像中的每个点转换为参数空间中的曲面，可以找到共圆心的曲面交点，从而确定圆的位置和半径。
（3）椭圆检测：类似地，霍夫变换还可以用于检测图像中的椭圆。通过将图像中的每个点转换为参数空间中的曲面，可以找到共椭圆参数的曲面交点，从而确定椭圆的位置、长轴和短轴。
（4）形状匹配：除了检测特定形状，霍夫变换还可以用于形状匹配。通过将待匹配形状在参数空间中表示，并与图像中的曲线或曲面进行匹配，可以找到与待匹配形状相似的图像区域。
5、使用霍夫变换的步骤 （1）边缘检测：首先对图像进行边缘检测，例如使用Canny边缘检测算法。这可以帮助减少噪声和提取出形状的边缘。
（2）参数空间设置：根据待检测的形状类型，选择合适的参数空间。对于直线检测，通常使用极坐标空间，其中两个参数分别表示直线的长度和角度。对于圆和椭圆检测，参数空间则包括圆心和半径或椭圆参数。
（3）累加过程：遍历边缘点，并将其转换为参数空间中的曲线或曲面。通过累加过程，找到在参数空间中出现峰值的位置，这些峰值表示可能存在的形状。
（4）阈值和筛选：根据设定的阈值，选择参数空间中的峰值作为检测结果。通常选择峰值强度高于阈值的部分，并进行进一步的筛选和优化。
（5）反变换：根据检测到的参数，在原始图像中绘制出相应的形状。对于直线检测，可以通过计算两个端点的坐标；对于圆和椭圆检测，可以通过计算圆心和半径或椭圆参数。
（6）参数调优：根据实际需求，可能需要对参数进行调优，以获得更好的检测结果。这包括阈值的选择、参数空间的分辨率等。
（7）结果分析和后处理：对于检测到的形状，可以进行进一步的分析和处理。例如，可以根据形状的位置和特征进行分类或其他操作。
需要注意的是：霍夫变换对图像中的噪声比较敏感，因此在应用之前通常需要进行预处理，如边缘检测或滤波操作。
二、霍夫变换—直线检测 1、霍夫直线变换介绍 （1）Hough Line Transform用来做直线检测
（2）前提条件 – 边缘检测已经完成 （cv::Canny，输入的是8位的图像可以是单通道或多通道，输出的是8位单通道的灰度图像，再通过threshold转化为二值化图像）
（3）平面空间到极坐标空间转换 极坐标也就是霍夫空间的坐标。
2、霍夫直线变换的例子 （1）对于任意一条直线上的所有点来说
（2）变换到极坐标中，从[0~360]空间，可以得到r的大小
（3）属于同一条直线上点在极坐标空(r, theta)必然在一个点上有最强的信号出现，根据此反算到平面坐标中就可以得到直线上各点的像素坐标。从而得到直线
（4）从平面坐标变换到霍夫空间（极坐标）
3、相关API学习（代码例子） （1）标准的霍夫变换 cv::HoughLines从平面坐标转换到霍夫空间，最终输出是极坐标空间；表示形式为：。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6c4ddaa5b8d64deb5f88ceb32f5553f3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T18:27:56+08:00" />
<meta property="article:modified_time" content="2024-01-22T18:27:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">13- OpenCV：霍夫检测：直线、圆检测</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%AE%80%E4%BB%8B" rel="nofollow">一、霍夫变换简介</a></p> 
<p id="1%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E5%8C%96%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:120px;"><a href="#1%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E5%8C%96%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">1、霍夫变换的原理</a></p> 
<p id="2%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:120px;"><a href="#2%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E4%BC%98%E7%82%B9" rel="nofollow">2、霍夫变换的优点</a></p> 
<p id="3%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E7%BC%BA%E7%82%B9-toc" style="margin-left:120px;"><a href="#3%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E7%BC%BA%E7%82%B9" rel="nofollow">3、霍夫变换的缺点</a></p> 
<p id="4%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:120px;"><a href="#4%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">4、霍夫变换的应用场景</a></p> 
<p id="5%E3%80%81%E4%BD%BF%E7%94%A8%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4-toc" style="margin-left:120px;"><a href="#5%E3%80%81%E4%BD%BF%E7%94%A8%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4" rel="nofollow">5、使用霍夫变换的步骤</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E2%80%94%E7%9B%B4%E7%BA%BF%E6%A3%80%E6%B5%8B-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E2%80%94%E7%9B%B4%E7%BA%BF%E6%A3%80%E6%B5%8B" rel="nofollow">二、霍夫变换—直线检测</a></p> 
<p id="1%E3%80%81%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E4%BB%8B%E7%BB%8D-toc" style="margin-left:120px;"><a href="#1%E3%80%81%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E4%BB%8B%E7%BB%8D" rel="nofollow">1、霍夫直线变换介绍</a></p> 
<p id="2%E3%80%81%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E7%9A%84%E4%BE%8B%E5%AD%90-toc" style="margin-left:120px;"><a href="#2%E3%80%81%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E7%9A%84%E4%BE%8B%E5%AD%90" rel="nofollow">2、霍夫直线变换的例子</a></p> 
<p id="3%E3%80%81%E7%9B%B8%E5%85%B3API%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89-toc" style="margin-left:120px;"><a href="#3%E3%80%81%E7%9B%B8%E5%85%B3API%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89" rel="nofollow">3、相关API学习（代码例子）</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E2%80%94%E5%9C%86%E6%A3%80%E6%B5%8B-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E2%80%94%E5%9C%86%E6%A3%80%E6%B5%8B" rel="nofollow">三、霍夫变换—圆检测</a></p> 
<p id="1%E3%80%81%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86-toc" style="margin-left:120px;"><a href="#1%E3%80%81%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86" rel="nofollow">1、霍夫圆检测原理</a></p> 
<p id="2%E3%80%81%E7%9B%B8%E5%85%B3API%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89-toc" style="margin-left:120px;"><a href="#2%E3%80%81%E7%9B%B8%E5%85%B3API%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89" rel="nofollow">2、相关API学习（代码例子）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E4%B8%80%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%AE%80%E4%BB%8B"><strong>一、霍夫变换简介</strong></h4> 
<blockquote> 
 <p>霍夫变换（Hough Transform）是一种在图像处理中常用的技术，用于检测图像中的直线、圆或其他形状。</p> 
</blockquote> 
<p>在霍夫变换中，直线通常由两个参数表示：<strong>斜率和截距</strong>。对于每个图像中的点，都可以在参数空间中绘制出与该点相关的曲线。当多个点共线时，它们在参数空间中的曲线会相交于同一个点，从而形成一个峰值。通过寻找参数空间中的峰值，我们可以确定图像中存在的直线。</p> 
<h5 id="1%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E5%8C%96%E7%9A%84%E5%8E%9F%E7%90%86"><strong>1、霍夫变换的原理</strong></h5> 
<blockquote> 
 <p>它的原理是将图像中的每个点转换为参数空间中的曲线或曲面，并通过对这些曲线或曲面进行累加来找到图像中的特定形状。</p> 
</blockquote> 
<p>（1）霍夫空间：对于待检测的形状，霍夫变换将其在参数空间中表示。对于直线检测，参数空间通常是极坐标空间，其中两个参数分别表示直线的长度和角度。对于圆和椭圆检测，参数空间则包括圆心和半径或椭圆参数。</p> 
<p>（2）累加过程：对于图像中的每个边缘点，通过遍历参数空间，将其转换为参数空间中的曲线或曲面。当多个边缘点共线或共圆时，在参数空间中会出现峰值。这些峰值表示了可能存在的形状。</p> 
<p>（3）阈值和筛选：根据设定的阈值，选择参数空间中的峰值作为检测结果。通常选择峰值强度高于阈值的部分，并进行进一步的筛选和优化。</p> 
<p>（4）反变换：根据检测到的参数，在原始图像中绘制出相应的形状。对于直线检测，可以通过计算两个端点的坐标；对于圆和椭圆检测，可以通过计算圆心和半径或椭圆参数。</p> 
<p>通过以上步骤，霍夫变换可以在图像中检测出特定形状的位置和参数。</p> 
<h5 id="2%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E4%BC%98%E7%82%B9"><strong>2、霍夫变换的优点</strong></h5> 
<p>（1）霍夫变换是一种基于几何特征的图像处理方法，对于形状检测具有较好的鲁棒性。它不依赖于形状的大小、方向和位置，能够在图像中准确地检测出各种形状。</p> 
<p>（2）霍夫变换可以应用于不同类型的形状检测，包括直线、圆、椭圆等。通过适当选择参数表示方式和累加过程，可以扩展到其他形状的检测。</p> 
<p>（3）霍夫变换可以应用于图像中存在噪声或部分遮挡的情况下。通过合适的预处理和参数设置，可以提高对形状的检测准确性。</p> 
<h5 id="3%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E7%BC%BA%E7%82%B9"><strong>3、霍夫变换的缺点</strong></h5> 
<p>（1）霍夫变换的计算复杂度较高，特别是对于大尺寸图像和复杂形状的检测。这会导致算法的执行时间较长，不适用于实时应用或对计算资源要求较高的场景。</p> 
<p>（2）霍夫变换对图像中的噪声比较敏感，因此需要进行预处理来降低噪声的影响。这可能会引入额外的步骤和计算开销。</p> 
<p>（3）霍夫变换对参数的选择较为敏感，不同形状的检测可能需要不同的参数设置。这对于非专业用户来说可能会增加使用的难度。</p> 
<p>（4）霍夫变换在处理曲线或曲面交叉的情况下可能会出现误检测或漏检的问题。特别是当形状之间存在相似性或重叠时，可能会导致结果的不准确性。</p> 
<p>总体而言，霍夫变换是一种强大的图像处理技术，但在实际应用中需要综合考虑其优点和缺点，并结合具体场景进行参数调整和算法改进。</p> 
<h5 id="4%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>4、霍夫变换的应用场景</strong></h5> 
<p>（1）直线检测：霍夫变换最常用的应用之一是检测图像中的直线。通过将图像中的每个点转换为参数空间中的曲线，可以找到共线点形成的峰值，从而确定直线的位置和方向。</p> 
<p>（2）圆检测：除了直线，霍夫变换也可以用于检测图像中的圆。通过将图像中的每个点转换为参数空间中的曲面，可以找到共圆心的曲面交点，从而确定圆的位置和半径。</p> 
<p>（3）椭圆检测：类似地，霍夫变换还可以用于检测图像中的椭圆。通过将图像中的每个点转换为参数空间中的曲面，可以找到共椭圆参数的曲面交点，从而确定椭圆的位置、长轴和短轴。</p> 
<p>（4）形状匹配：除了检测特定形状，霍夫变换还可以用于形状匹配。通过将待匹配形状在参数空间中表示，并与图像中的曲线或曲面进行匹配，可以找到与待匹配形状相似的图像区域。</p> 
<h5 id="5%E3%80%81%E4%BD%BF%E7%94%A8%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4"><strong>5、使用霍夫变换的步骤</strong></h5> 
<p>（1）边缘检测：首先对图像进行边缘检测，例如使用Canny边缘检测算法。这可以帮助减少噪声和提取出形状的边缘。</p> 
<p>（2）参数空间设置：根据待检测的形状类型，选择合适的参数空间。对于直线检测，通常使用极坐标空间，其中两个参数分别表示直线的长度和角度。对于圆和椭圆检测，参数空间则包括圆心和半径或椭圆参数。</p> 
<p>（3）累加过程：遍历边缘点，并将其转换为参数空间中的曲线或曲面。通过累加过程，找到在参数空间中出现峰值的位置，这些峰值表示可能存在的形状。</p> 
<p>（4）阈值和筛选：根据设定的阈值，选择参数空间中的峰值作为检测结果。通常选择峰值强度高于阈值的部分，并进行进一步的筛选和优化。</p> 
<p>（5）反变换：根据检测到的参数，在原始图像中绘制出相应的形状。对于直线检测，可以通过计算两个端点的坐标；对于圆和椭圆检测，可以通过计算圆心和半径或椭圆参数。</p> 
<p>（6）参数调优：根据实际需求，可能需要对参数进行调优，以获得更好的检测结果。这包括阈值的选择、参数空间的分辨率等。</p> 
<p>（7）结果分析和后处理：对于检测到的形状，可以进行进一步的分析和处理。例如，可以根据形状的位置和特征进行分类或其他操作。</p> 
<p><strong>需要注意的是：</strong>霍夫变换对图像中的噪声比较敏感，因此在应用之前通常需要进行预处理，如边缘检测或滤波操作。</p> 
<p></p> 
<h4 id="%E4%BA%8C%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E2%80%94%E7%9B%B4%E7%BA%BF%E6%A3%80%E6%B5%8B" style="background-color:transparent;"><strong>二、霍夫变换—直线检测</strong></h4> 
<h5 id="1%E3%80%81%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E4%BB%8B%E7%BB%8D"><strong>1、霍夫直线变换介绍</strong></h5> 
<p>（1）Hough Line Transform用来做直线检测</p> 
<p>（2）前提条件 – 边缘检测已经完成 （cv::Canny，输入的是8位的图像可以是单通道或多通道，输出的是8位单通道的灰度图像，再通过threshold转化为二值化图像）</p> 
<p>（3）平面空间到极坐标空间转换        </p> 
<p>        极坐标也就是霍夫空间的坐标。</p> 
<p><img alt="" height="169" src="https://images2.imgbox.com/1d/19/edFfb3qH_o.png" width="846"></p> 
<h5 id="2%E3%80%81%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E7%9A%84%E4%BE%8B%E5%AD%90"><strong>2、霍夫直线变换的例子</strong></h5> 
<p>（1）对于任意一条直线上的所有点来说</p> 
<p>（2）变换到极坐标中，从[0~360]空间，可以得到r的大小</p> 
<p>（3）属于同一条直线上点在极坐标空(r, theta)必然在一个点上有最强的信号出现，根据此反算到平面坐标中就可以得到直线上各点的像素坐标。从而得到直线</p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/f3/2e/hm4KTCkl_o.png" width="914"></p> 
<p>（4）从平面坐标变换到霍夫空间（极坐标）</p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/2d/dc/2D7JinjC_o.png" width="638"></p> 
<h5 id="3%E3%80%81%E7%9B%B8%E5%85%B3API%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89" style="background-color:transparent;"><strong>3、相关API学习（代码例子）</strong></h5> 
<p>（1）标准的霍夫变换 <strong>cv::HoughLines</strong>从平面坐标转换到霍夫空间，最终输出是极坐标空间；表示形式为：<img alt="" height="51" src="https://images2.imgbox.com/89/94/srcF2uQZ_o.png" width="94">。</p> 
<blockquote> 
 <p>cv::HoughLines(</p> 
 <p>InputArray src, // 输入图像，必须8-bit的灰度图像</p> 
 <p>OutputArray lines, // 输出的极坐标来表示直线</p> 
 <p>double rho, // 生成极坐标时候的像素扫描步长</p> 
 <p>double theta, //生成极坐标时候的角度步长，一般取值CV_PI/180</p> 
 <p>int threshold, // 阈值，只有获得足够交点的极坐标点才被看成是直线</p> 
 <p>double srn=0;// 是否应用多尺度的霍夫变换，如果不是设置0表示经典霍夫变换</p> 
 <p>double stn=0;//是否应用多尺度的霍夫变换，如果不是设置0表示经典霍夫变换</p> 
 <p>double min_theta=0; // 表示角度扫描范围 0 ~180之间， 默认即可</p> 
 <p>double max_theta=CV_PI</p> 
 <p>) // <strong>一般情况是有经验的开发者使用，需要自己反变换到平面空间（少用）</strong></p> 
</blockquote> 
<p>（2）霍夫变换直线概率 <strong>cv::HoughLinesP</strong>最终输出是直线的两个点<strong>（常用）</strong></p> 
<blockquote> 
 <p>cv::HoughLinesP(</p> 
 <p>InputArray src, // 输入图像，必须8-bit的灰度图像</p> 
 <p>OutputArray lines, // 输出的极坐标来表示直线</p> 
 <p>double rho, // 生成极坐标时候的像素扫描步长</p> 
 <p>double theta, //生成极坐标时候的角度步长，一般取值</p> 
 <p>CV_PI/180 int threshold, // 阈值，只有获得足够交点的极坐标点才被看成是直线</p> 
 <p>double minLineLength=0;// 最小直线长度</p> 
 <p>double maxLineGap=0;// 最大间隔</p> 
 <p>)</p> 
</blockquote> 
<p>（3）检测结果</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/e0/a4/ymwy6gOb_o.png" width="568"></p> 
<p>（4）代码演示：</p> 
<pre><code class="language-cpp">#include&lt;opencv2\opencv.hpp&gt;
#include&lt;iostream&gt;
#include &lt;math.h&gt;

using namespace cv;
using namespace std;

// Hough Line霍夫直线检测
int main(int argc, char** argv) {
	Mat src, src_gray, dst;
	src = imread("line.jpg");
	if (!src.data) {
		printf("could not load image...\n");
		return -1;
	}

	char INPUT_TITLE[] = "input image";
	char OUTPUT_TITLE[] = "hough-line-detection";
	namedWindow(INPUT_TITLE, CV_WINDOW_AUTOSIZE);
	namedWindow(OUTPUT_TITLE, CV_WINDOW_AUTOSIZE);
	imshow(INPUT_TITLE, src);

	// extract edge
	Canny(src, src_gray, 150, 200);
	cvtColor(src_gray, dst, CV_GRAY2BGR);
	imshow("edge image", src_gray);

	vector&lt;Vec2f&gt; lines;
	HoughLines(src_gray, lines, 1, CV_PI / 180, 150, 0, 0);
	for (size_t i = 0; i &lt; lines.size(); i++) {
		float rho = lines[i][0]; // 极坐标中的r长度
		float theta = lines[i][1]; // 极坐标中的角度
		Point pt1, pt2;
		double a = cos(theta), b = sin(theta);
		double x0 = a * rho, y0 = b * rho;
		// 转换为平面坐标的四个点
		pt1.x = cvRound(x0 + 1000 * (-b));
		pt1.y = cvRound(y0 + 1000 * (a));
		pt2.x = cvRound(x0 - 1000 * (-b));
		pt2.y = cvRound(y0 - 1000 * (a));
		line(dst, pt1, pt2, Scalar(0, 0, 255), 1, CV_AA);
	}

	/*
	vector&lt;Vec4f&gt; plines;
	HoughLinesP(src_gray, plines, 1, CV_PI / 180.0, 10, 0, 10);
	Scalar color = Scalar(0, 0, 255);
	for (size_t i = 0; i &lt; plines.size(); i++) {
		Vec4f hline = plines[i];
		line(dst, Point(hline[0], hline[1]), Point(hline[2], hline[3]), color, 3, LINE_AA);
	}*/
	imshow(OUTPUT_TITLE, dst);

	waitKey(0);
	return 0;
}</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/d9/66/JiDba682_o.png" width="1200"></p> 
<h4 id="%E4%B8%89%E3%80%81%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E2%80%94%E5%9C%86%E6%A3%80%E6%B5%8B" style="background-color:transparent;"><strong>三、霍夫变换—圆检测</strong></h4> 
<h5 id="1%E3%80%81%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86"><strong>1、霍夫圆检测原理</strong></h5> 
<p>（1）从平面坐标到极坐标转换三个参数</p> 
<p>（2）假设平面坐标的任意一个圆上的点，转换到极坐标中：<img alt="" height="24" src="https://images2.imgbox.com/55/e0/zDnyP5B5_o.png" width="188">                         处有最大值，霍夫变换正是利用这个原理实现圆的检测。</p> 
<p><img alt="" height="177" src="https://images2.imgbox.com/c2/f7/FjNjtNdY_o.png" width="545"></p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/55/ee/1t3R5Y52_o.png" width="487"></p> 
<h5 id="2%E3%80%81%E7%9B%B8%E5%85%B3API%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89" style="background-color:transparent;"><strong>2、相关API学习（代码例子）</strong></h5> 
<p>（1）cv::HoughCircles</p> 
<p>因为霍夫圆检测对噪声比较敏感，所以首先要对图像做<strong>中值滤波</strong>。</p> 
<p>基于效率考虑，Opencv中实现的霍夫变换圆检测是基于图像梯度的实现，分为两步：     </p> 
<p>        1）检测边缘，发现可能的圆心     </p> 
<p>        2）基于第一步的基础上从候选圆心开始计算最佳半径大小</p> 
<blockquote> 
 <p>HoughCircles(</p> 
 <p>InputArray image, // 输入图像 ,必须是8位的单通道灰度图像</p> 
 <p>OutputArray circles, // 输出结果，发现的圆信息</p> 
 <p>Int method, // 方法 - HOUGH_GRADIENT</p> 
 <p>Double dp, // dp = 1;</p> 
 <p>Double mindist, // 10 最短距离-可以分辨是两个圆的，否则认为是同心圆- src_gray.rows/8 Double param1, // canny edge detection low threshold</p> 
 <p>Double param2, // 中心点累加器阈值 – 候选圆心</p> 
 <p>Int minradius, // 最小半径 Int maxradius//最大半径</p> 
 <p>)</p> 
</blockquote> 
<p>（2）代码演示：</p> 
<pre><code class="language-cpp">#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;

using namespace cv;
using namespace std;
int main(int argc, char** argv) {
	Mat src, dst;
	src = imread("circle.jpg");
	if (!src.data) {
		printf("could not load image...\n");
		return -1;
	}
	char INPUT_TITLE[] = "input image";
	char OUTPUT_TITLE[] = "hough circle demo";
	namedWindow(INPUT_TITLE, CV_WINDOW_AUTOSIZE);
	namedWindow(OUTPUT_TITLE, CV_WINDOW_AUTOSIZE);
	imshow(INPUT_TITLE, src);

	// 中值滤波
	Mat moutput;
	medianBlur(src, moutput, 3);
	cvtColor(moutput, moutput, CV_BGR2GRAY);

	// 霍夫圆检测
	vector&lt;Vec3f&gt; pcircles;
	HoughCircles(moutput, pcircles, CV_HOUGH_GRADIENT, 1, 10, 100, 30, 5, 50);
	src.copyTo(dst);
	for (size_t i = 0; i &lt; pcircles.size(); i++) {
		Vec3f cc = pcircles[i];
		circle(dst, Point(cc[0], cc[1]), cc[2], Scalar(0, 0, 255), 2, LINE_AA);
		circle(dst, Point(cc[0], cc[1]), 2, Scalar(198, 23, 155), 2, LINE_AA);
	}
	imshow(OUTPUT_TITLE, dst);

	waitKey(0);
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f771027bae77fe5e8d3c38206ae926d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">云风网（www.niech.cn）个人网站搭建（九）html静态菜单列表替换为接口请求动态数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96aa672ef2fa16db450d70114a25a53a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【JS基础】对象的一些基本使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>