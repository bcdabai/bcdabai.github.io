<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mysql索引（一看就会！！！） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mysql索引（一看就会！！！）" />
<meta property="og:description" content="老规矩先上理论知识~
索引是什么
索引是为了加速查询的一种数据结构
类似于书的目录，所有的数据类型都可以被索引
为快速查找数据而排好序的一种数据结构
三种索引结构：Btree，B&#43;Tree，Hash
优点：
提高mysql检索速度
索引减小了服务需要扫描的数据量
避免排序和临时i表
缺点：
降低更新表的速度
会占用磁盘空间的索引文件，如果创建了很多组合索引，索引文件会膨胀很快
如果数据列包含太多重复内容，建立建立索引没有太大实际效果
对于非常小的表，大部分情况下简单的全表扫描更高效，索引对于数据量越大，索引效果越明显
索引分类：
功能
普通索引
唯一索引
全文索引
作用字段
单列索引
多列索引
理论说的差不多了，那接下开始操作吧~
索引操作
创建索引
mysql&gt; CREATE TABLE execdb.t11(name CHAR(20),uid INT, shell CHAR(20),INDEX(name),INDEX(uid),INDEX(shell)); #建表时创建索引
#命令——在哪个库. 创建的表名——字段设计——创建的索引字段index(字段名)
mysql&gt; DESC execdb.t11; #查看表结构MUL
语法格式：
已有表添加索引
语法格式：
mysql&gt; CREATE TABLE execdb.t12(name CHAR(20),uid INT, shell CHAR(20)); #建表
mysql&gt; DESC execdb.t12; #查看表结构（key位置为空代表没有索引）
mysql&gt; CREATE INDEX name ON execdb.t12(name); #添加索引
# 命令——索引名字——on对哪个库表的哪个字段添加索引
mysql&gt; DESC execdb.t12; #查看表结构（key字段有MUL代表有索引）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e2fc2e052495891ee534467974a438e6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-23T14:40:37+08:00" />
<meta property="article:modified_time" content="2023-05-23T14:40:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mysql索引（一看就会！！！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#956fe7;"><strong>老规矩先上理论知识~</strong></span></p> 
<p><strong>索引是什么</strong></p> 
<p>索引是为了加速查询的一种数据结构</p> 
<p>类似于书的目录，所有的数据类型都可以被索引</p> 
<p>为快速查找数据而排好序的一种数据结构</p> 
<p>三种索引结构：Btree，B+Tree，Hash</p> 
<p><strong> 优点：</strong></p> 
<p>提高mysql检索速度</p> 
<p>索引减小了服务需要扫描的数据量</p> 
<p>避免排序和临时i表</p> 
<p><strong>缺点：</strong></p> 
<p>降低更新表的速度</p> 
<p>会占用磁盘空间的索引文件，如果创建了很多组合索引，索引文件会膨胀很快</p> 
<p>如果数据列包含太多重复内容，建立建立索引没有太大实际效果</p> 
<p>对于非常小的表，大部分情况下简单的全表扫描更高效，索引对于数据量越大，索引效果越明显</p> 
<p></p> 
<p><strong>索引分类：</strong></p> 
<ul><li> <p><strong>功能</strong></p> 
  <ul><li> <p>普通索引</p> </li><li> <p>唯一索引</p> </li><li> <p>全文索引</p> </li></ul></li><li> <p><strong>作用字段</strong></p> 
  <ul><li> <p>单列索引</p> </li><li> <p>多列索引</p> </li></ul></li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/85/a0/yC3DFter_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dd/02/fHvw3b5B_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/09/Rkep4B7d_o.png"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/e9/03/d8Ysobvk_o.png"></p> 
<p><span style="color:#511b78;"><strong> 理论说的差不多了，那接下开始操作吧~</strong></span></p> 
<p> <strong>索引操作</strong></p> 
<p><strong>创建索引</strong><br> mysql&gt; CREATE TABLE execdb.t11(name CHAR(20),uid INT, shell CHAR(20),INDEX(name),INDEX(uid),INDEX(shell));       #建表时创建索引</p> 
<p>#命令——在哪个库. 创建的表名——字段设计——创建的索引字段index(字段名)</p> 
<p>mysql&gt; DESC execdb.t11;                                                #查看表结构MUL</p> 
<p><strong>语法格式：</strong></p> 
<p style="text-align:center;"><img alt="" class="left" height="232" src="https://images2.imgbox.com/11/a8/A88DKOkm_o.png" width="401"></p> 
<p></p> 
<p><strong>已有表添加索引</strong></p> 
<p><strong>语法格式：</strong></p> 
<p style="text-align:center;"><strong><img alt="" class="left" height="167" src="https://images2.imgbox.com/d5/38/bjFUHAMh_o.png" width="311"></strong></p> 
<p></p> 
<p>mysql&gt; CREATE TABLE execdb.t12(name CHAR(20),uid INT, shell CHAR(20));    #建表</p> 
<p>mysql&gt; DESC execdb.t12;                                       #查看表结构（key位置为空代表没有索引）</p> 
<p>mysql&gt; CREATE INDEX name ON execdb.t12(name);    #添加索引</p> 
<p># 命令——索引名字——on对哪个库表的哪个字段添加索引</p> 
<p>mysql&gt; DESC execdb.t12;                                          #查看表结构（key字段有MUL代表有索引）</p> 
<p>#查看具体索引信息<br> mysql&gt; SHOW INDEX FROM execdb.t12\G               #查看表中所有索引</p> 
<p>*************************** 1. row ***************************</p> 
<p><span style="color:#0d0016;">Table: t12                           #表名<br>  Non_unique: 1                  #是否为唯一索引，是0否1<br>  Key_name: name             #索引名称<br>  Seq_in_index: 1                #该列在索引中的位置，因为有组合索引<br>  Column_name: name        #字段名<br>  Collation: A                        #列以何种顺序存储在索引中，A为升序，NULL表示无分类<br>  Cardinality: 0                     #索引中唯一数目的估计值<br>  Sub_part: NULL                #列中被编入索引字符的数量，整列编入显示NULL<br>  Packed: NULL                   #关键字如何被压缩，NULL表示没有被压缩<br>  Null: YES                           #索引列中是否包含NULL<br>  Index_type: BTREE           #索引类别（BTREE、FULLTEXT、HASH、RTREE）<br>  Comment:                          #显示评注<br> Index_comment:                 #索引单独评注</span></p> 
<p></p> 
<p><strong> 删除已有索引</strong></p> 
<p> mysql&gt; DROP INDEX name ON execdb.t12;    #删除指定索引</p> 
<p>mysql&gt; DESC execdb.t12;                                 #查看表结构</p> 
<p></p> 
<p><span style="color:#511b78;"><strong> 举例一个索引案例能更好的理解哦~  一起看看吧~</strong></span></p> 
<p> <strong>编写shell脚本生成1000000条数据</strong><br> [root@server51 ~]# vim gendata.sh <br> [root@server51 ~]# cat gendata.sh <br> #!/bin/bash<br> #向execdb.t12表写入1000000条数据</p> 
<p>shells=("/bin/bash" "/sbin/nologin" "/bin/false" "/sbin/shutdown")<br> for i in {1..1000000}<br> do<br>     name="name$i"<br>     uid=$i<br>     num=$[RANDOM%4]<br>     shell="${shells[$num]}"<br>     echo ${name} ${uid} ${shell}<br>     mysql -hlocalhost -uroot -p'123qqq...A' -e "INSERT INTO execdb.t12 VALUES(\"${name}\",${uid},\"${shell}\")" &amp;&gt; /dev/null<br>     if [ $[i%10000] -eq 0 ];then<br>         echo "已经写入${i}条数据"<br>     fi<br> done</p> 
<p><br> [root@server51 ~]# bash gendata.sh    #执行脚本生成随机数据</p> 
<p>[root@server51 ~]# mysql -hlocalhost -uroot -p'123qqq...A'    #登录MySQL服务</p> 
<p>mysql&gt; SELECT COUNT(*) FROM execdb.t12;                        #查询表记录数据</p> 
<p>mysql&gt; SELECT * FROM execdb.t12 WHERE name="name999999";    #查询100w条及记录中的1条<br> +------------+--------+-----------+<br> | name       | uid    | shell     |<br> +------------+--------+-----------+<br> | name999999 | 999999 | /bin/bash |<br> +------------+--------+-----------+<br> 1 row in set (0.14 sec)                    #注意无索引情况下的时间</p> 
<p>mysql&gt; CREATE INDEX name ON execdb.t12(name);                #name字段添加索引</p> 
<p>mysql&gt; SELECT * FROM execdb.t12 WHERE name="name999999";    #查询100w条及记录中的1条<br> +------------+--------+-----------+<br> | name       | uid    | shell     |<br> +------------+--------+-----------+<br> | name999999 | 999999 | /bin/bash |<br> +------------+--------+-----------+<br> 1 row in set (0.00 sec)                    #注意有索引情况下的时间</p> 
<p></p> 
<p><strong>最后是索引的引用</strong></p> 
<p>#explain语句各个字段解释如下：</p> 
<p>explain select * from execdb.t13 where name="lisi"\G       #<br> id： 表示当前select语句的编号，该值可能为空，如果行联合了其他行的结果；在这种情况下table列显示的是，引用的行的并集。<br> select_type： 这个值有很多，暂时可以先记以下几个：<br> 　　SIMPLE: 简单查询，不包含连接查询和子查询。<br> PRIMARY: 最外层查询，主键查询<br> UNION：连接查询的第二个或后面的查询语句。　其余参数可以查看https://dev.mysql.com/doc/refman/5.7/en/explain-output.html<br>   table： 查询的表名</p> 
<p>partitions：显示查询使用的分区，若为NULL则未使用分区。<br> type：表示表的连接类型，有如下取值：<br> const   ：表示表中有多条记录，但只从表中查询一条记录;<br> eq_ref ：表示多表连接时，后面的表使用了UNIQUE或者PRIMARY KEY;<br> ref       ：表示多表查询时，后面的表使用了普通索引;<br> unique_ subquery：表示子查询中使用了UNIQUE或者PRIMARY KEY;<br> index_ subquery：表示子查询中使用了普通索引;<br> range  ：表示查询语句中给出了查询范围;<br> index   ：表示对表中的索引进行了完整的扫描;<br> all        ：表示此次查询进行了全表扫描;（一般来说全表扫描需要优化，表的记录很少除外）<br> possible_keys：表示查询中可能使用的索引；如果备选的数量大于3那说明已经太多了，因为太多会导致选择索引而损耗性能， 所以建表时字段最好精简，同时也要建立联合索引，避免无效的单列索引；<br> key： 查询实际使用的索引（不太准确，可以查阅官方文档）。<br> key_len：索引的长度<br> ref： REF列显示哪些列或常量与键列中所命名的索引进行比较，以从表中选择行。<br> rows： 查询扫描的行数。<br> filtered：表示按条件过滤表行的百分比，最大为100表示100%。<br> Extra： 表示查询额外的附加信息说明</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/539a2c798b6e1fe57147953743fff0e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java基础之对象类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/049761f61294d9885f6b32a07cf0e46d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Lua学习笔记：浅谈对闭包的认识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>