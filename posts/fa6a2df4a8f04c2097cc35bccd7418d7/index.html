<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java实现双向链表 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java实现双向链表" />
<meta property="og:description" content="目录
大家好！欢迎大家来到利物浦痛失欧冠冠军的第一期文章。
一、双向链表的简单理解
1、双向链表是什么？
2、双向链表长什么样子？
二、代码演示
1、结点的构建
2、链表的创建
3、打印链表
4、得到链表长度
5、查找元素
6、插入元素
（1）、头插法
（2）、尾插法
（3）、中间插入
7、删除元素
（1）、删除元素为头结点。
（2）、删除元素为中间结点或者尾巴结点
三、总结
大家好！欢迎大家来到利物浦痛失欧冠冠军的第一期文章。 一、双向链表的简单理解 1、双向链表是什么？ 在前面的文章中，我们仔细讲解了单向链表，并且用代码实现了单向链表。单向链表的好处很多，虽然单链表能 100% 解决逻辑关系为 &#34;一对一&#34; 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，如果算法中需要大量地找某指定结点的前趋结点，使用单链表无疑是灾难性的，因为单链表更适合 &#34;从前往后&#34; 找，而 &#34;从后往前&#34; 找并不是它的强项，因此我们就有了双向链表这个东西，双向链表顾名思义就是链表的高级版，他与单向链表有所不同的一点在于在具有尾巴结点，并且双向链表的每一个结点都会有两个指向，一个指向前面的结点，一个指向后面的结点，当然头结点的前端指向为null，后结点的后端指向为null。
2、双向链表长什么样子？ 双向链表的一个结点，具有包括三个信息：1、前端指针域。2、数据域。3、后端指针域
如图所示
双向链表正是由这些一个个结点组合而成
接下来我们将会用代码的方式来实现双向链表
二、代码演示 1、结点的构建 和单向链表一样，链表的实现离不开结点，这构建也与单向链表相似，只不过不同的是我们需要加一个前端指针
class ListNode{ public ListNode prev; public ListNode next; public int val; public ListNode(int num){ this.val = num; } public ListNode(){ } } 2、链表的创建 链表的创建中有个很重要的东西，就是我们需要给链表设置一个头结点指针与尾巴结点指针，因为链表初始化只有一个结点，因此头结点指针 == 尾巴结点指针
public ListNode head; public ListNode last; public TowWayNodeList(int num){ this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fa6a2df4a8f04c2097cc35bccd7418d7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-01T00:10:30+08:00" />
<meta property="article:modified_time" content="2022-06-01T00:10:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java实现双向链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%A4%A7%E5%AE%B6%E5%A5%BD%EF%BC%81%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E6%9D%A5%E5%88%B0%E5%88%A9%E7%89%A9%E6%B5%A6%E7%97%9B%E5%A4%B1%E6%AC%A7%E5%86%A0%E5%86%A0%E5%86%9B%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%9F%E6%96%87%E7%AB%A0%E3%80%82-toc" style="margin-left:0px;"><a href="#%E5%A4%A7%E5%AE%B6%E5%A5%BD%EF%BC%81%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E6%9D%A5%E5%88%B0%E5%88%A9%E7%89%A9%E6%B5%A6%E7%97%9B%E5%A4%B1%E6%AC%A7%E5%86%A0%E5%86%A0%E5%86%9B%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%9F%E6%96%87%E7%AB%A0%E3%80%82" rel="nofollow">大家好！欢迎大家来到利物浦痛失欧冠冠军的第一期文章。</a></p> 
<p id="%E4%B8%80%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3" rel="nofollow">一、双向链表的简单理解</a></p> 
<p id="1%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">1、双向链表是什么？</a></p> 
<p id="2%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%EF%BC%9F-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%EF%BC%9F" rel="nofollow">2、双向链表长什么样子？</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow">二、代码演示</a></p> 
<p id="1%E3%80%81%E7%BB%93%E7%82%B9%E7%9A%84%E6%9E%84%E5%BB%BA-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%BB%93%E7%82%B9%E7%9A%84%E6%9E%84%E5%BB%BA" rel="nofollow">1、结点的构建</a></p> 
<p id="2%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">2、链表的创建</a></p> 
<p id="3%E3%80%81%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8" rel="nofollow">3、打印链表</a></p> 
<p id="4%E3%80%81%E5%BE%97%E5%88%B0%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%BE%97%E5%88%B0%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6" rel="nofollow">4、得到链表长度</a></p> 
<p id="5%E3%80%81%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0" rel="nofollow">5、查找元素</a></p> 
<p id="%C2%A06%E3%80%81%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#%C2%A06%E3%80%81%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0" rel="nofollow"> 6、插入元素</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81%E5%A4%B4%E6%8F%92%E6%B3%95-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81%E5%A4%B4%E6%8F%92%E6%B3%95" rel="nofollow">（1）、头插法</a></p> 
<p id="%EF%BC%882%EF%BC%89%E3%80%81%E5%B0%BE%E6%8F%92%E6%B3%95-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E3%80%81%E5%B0%BE%E6%8F%92%E6%B3%95" rel="nofollow">（2）、尾插法</a></p> 
<p id="%EF%BC%883%EF%BC%89%E3%80%81%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E3%80%81%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5" rel="nofollow">（3）、中间插入</a></p> 
<p id="7%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0" rel="nofollow">7、删除元素</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A4%B4%E7%BB%93%E7%82%B9%E3%80%82-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A4%B4%E7%BB%93%E7%82%B9%E3%80%82" rel="nofollow">（1）、删除元素为头结点。</a></p> 
<p id="%C2%A0%EF%BC%882%EF%BC%89%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%B8%BA%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%E6%88%96%E8%80%85%E5%B0%BE%E5%B7%B4%E7%BB%93%E7%82%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%EF%BC%882%EF%BC%89%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%B8%BA%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%E6%88%96%E8%80%85%E5%B0%BE%E5%B7%B4%E7%BB%93%E7%82%B9" rel="nofollow"> （2）、删除元素为中间结点或者尾巴结点</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">三、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%A4%A7%E5%AE%B6%E5%A5%BD%EF%BC%81%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E6%9D%A5%E5%88%B0%E5%88%A9%E7%89%A9%E6%B5%A6%E7%97%9B%E5%A4%B1%E6%AC%A7%E5%86%A0%E5%86%A0%E5%86%9B%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%9F%E6%96%87%E7%AB%A0%E3%80%82">大家好！欢迎大家来到利物浦痛失欧冠冠军的第一期文章。</h2> 
<h2 id="%E4%B8%80%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3">一、双向链表的简单理解</h2> 
<h3 id="1%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">1、双向链表是什么？</h3> 
<p>在前面的文章中，我们仔细讲解了单向链表，并且用代码实现了单向链表。单向链表的好处很多，虽然单链表能 100% 解决逻辑关系为 "一对一" 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，如果算法中需要大量地找某指定结点的前趋结点，使用单链表无疑是灾难性的，因为单链表更适合 "从前往后" 找，而 "从后往前" 找并不是它的强项，因此我们就有了双向链表这个东西，双向链表顾名思义就是链表的高级版，他与单向链表有所不同的一点在于在具有尾巴结点，并且双向链表的每一个结点都会有两个指向，一个指向前面的结点，一个指向后面的结点，当然头结点的前端指向为null，后结点的后端指向为null。</p> 
<h3 id="2%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%EF%BC%9F">2、双向链表长什么样子？</h3> 
<p>双向链表的一个结点，具有包括三个信息：1、前端指针域。2、数据域。3、后端指针域</p> 
<p>如图所示<img alt="" height="306" src="https://images2.imgbox.com/37/41/UFig2h6d_o.png" width="727"></p> 
<p></p> 
<p>双向链表正是由这些一个个结点组合而成</p> 
<p><img alt="" height="389" src="https://images2.imgbox.com/44/cd/MYxhQ4yI_o.png" width="999"></p> 
<p></p> 
<p></p> 
<p>接下来我们将会用代码的方式来实现双向链表</p> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">二、代码演示</h2> 
<h3 id="1%E3%80%81%E7%BB%93%E7%82%B9%E7%9A%84%E6%9E%84%E5%BB%BA">1、结点的构建</h3> 
<p>和单向链表一样，链表的实现离不开结点，这构建也与单向链表相似，只不过不同的是我们需要加一个前端指针</p> 
<pre><code class="language-java">class ListNode{
    public ListNode prev;
    public ListNode next;
    public int val;
    public ListNode(int num){
        this.val = num;
    }
 public ListNode(){
       
    }
}</code></pre> 
<h3 id="2%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA">2、链表的创建</h3> 
<p>链表的创建中有个很重要的东西，就是我们需要给链表设置一个头结点指针与尾巴结点指针，因为链表初始化只有一个结点，因此头结点指针 == 尾巴结点指针</p> 
<pre><code class="language-java">  public ListNode head;
    public ListNode last;
    public TowWayNodeList(int num){
        this.head = new ListNode(num);
        this.last = this.head;
    }</code></pre> 
<h3 id="3%E3%80%81%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">3、打印链表</h3> 
<pre><code class="language-java"> public void display(){
        ListNode cur = this.head;
        while(cur != null){
            System.out.print(cur.val+" ");
            cur = cur.next;
        }
        System.out.println();
    }</code></pre> 
<h3 id="4%E3%80%81%E5%BE%97%E5%88%B0%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6">4、得到链表长度</h3> 
<pre><code class="language-java">   public int size(){
        ListNode cur = this.head;
        int size = 0;
        while(cur != null){
            size++;
            cur = cur.next;
        }
        return size;
    }</code></pre> 
<h3 id="5%E3%80%81%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0">5、查找元素</h3> 
<pre><code class="language-java"> public boolean contains(int key){
        ListNode cur = this.head;
        while(cur != null){
            if(cur.val == key){
                return true;
            }
        }
        return false;
    }</code></pre> 
<h3 id="%C2%A06%E3%80%81%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"> 6、插入元素</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81%E5%A4%B4%E6%8F%92%E6%B3%95">（1）、头插法</h4> 
<p>当我们想把新的结点插入到第一个结点位置处，可以先建立一个结点，然后把头结点的prev变为我们新建立结点的next值，然后将我们新建立的结点值变为null，最后将头结点指向新的插入的结点。</p> 
<p><img alt="" height="1103" src="https://images2.imgbox.com/43/2c/jl2iMoET_o.png" width="1200"></p> 
<p>注意我们需要首先判断这个链表是否为空，假如为空就直接构建链表即可</p> 
<pre><code class="language-java"> //头插法
    public void addFirst(int num){
        ListNode node = new ListNode(num);
        if(head == null){
            this.head = node;
            this.last = node;
        }else{
            node.next = this.head;
            this.head.prev = node;
            this.head = node;
        }
    }</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89%E3%80%81%E5%B0%BE%E6%8F%92%E6%B3%95">（2）、尾插法</h4> 
<p>尾插法顾名思义就是从结尾插入新的结点，这个和头插法过程差不多，只不过一个是改变head的位置，一个是改变last的位置。</p> 
<p><img alt="" height="995" src="https://images2.imgbox.com/2c/04/JcV3SQGT_o.png" width="1200"></p> 
<p>和头插法一样，这个同样需要判断链表是否初始为空</p> 
<pre><code>   public void addLast(int data){
        ListNode node = new ListNode(data);
        if(head == null){
            this.head = node;
            this.last = node;
        }else{
            this.last.next = node;
            node.prev = this.last;
            this.last = node;
        }
    }</code></pre> 
<h4 id="%EF%BC%883%EF%BC%89%E3%80%81%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5">（3）、中间插入</h4> 
<p>这个是最复杂的一种插入方式，我们需要先找到需要插入位置的结点cur，然后利用cur就可以得出前后两个结点，直接插入即可。</p> 
<p>首先我们建立一个方法来查找cur的位置，一个返回值为结点的元素</p> 
<pre><code class="language-java">   public ListNode searchIndex (int index){
        ListNode cur = this.head;
        while(index != 0){
            cur = cur.next;
            index--;
        }
        return cur;
    }</code></pre> 
<p> 然后利用cur附近的结点来直接插入即可</p> 
<p><img alt="" height="382" src="https://images2.imgbox.com/01/f4/vlDmQAEp_o.png" width="747"> 这是cur附近各个指针域的图，我们只需要改变cur附近的结点指针域的指向即可，首先node指向cur的地址也就是cur.prev.next</p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/15/4f/8lMbhaUt_o.png" width="910"></p> 
<p>然后cur.prev.next指向node的地址，然后再开始前端指针的指向 </p> 
<p><img alt="" height="373" src="https://images2.imgbox.com/db/60/PSkehr5C_o.png" width="887"></p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/39/f8/Aze7LjV1_o.png" width="765"> </p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/ff/03/prEbyjvK_o.png" width="764"> </p> 
<pre><code class="language-java"> //任意位置插入,第一个数据节点为0号下标
    public void addIndex(int index,int data){
        if(index &lt; 0|| index &gt; size()){
            System.out.println("非法");
            return;
        }
        //ListNode node = new ListNode(data);
        if(index == 0){
            addLast(data);
        }else if(index == size()){
            addLast(data);
        }else{
            ListNode node = new ListNode(data);
            ListNode cur = searchIndex(index);
            node.next = cur.prev.next;
            cur.prev.next = node;
            node.prev = cur.prev;
            cur.prev = node;
        }
    }</code></pre> 
<h3 id="7%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">7、删除元素</h3> 
<p>删除元素的话，我们需要：</p> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A4%B4%E7%BB%93%E7%82%B9%E3%80%82">（1）、删除元素为头结点。</h4> 
<p> 假如是头结点的话我们还需要判断这个链表是否只有一个结点，如果是那么last指针也会为空，head指针也会为空，否则，我们只移动头指针结点就可以。</p> 
<p><img alt="" height="633" src="https://images2.imgbox.com/f8/31/r6yBqDvk_o.png" width="1039"></p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/db/76/YHwg2MR4_o.png" width="1088"> </p> 
<h4 id="%C2%A0%EF%BC%882%EF%BC%89%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%B8%BA%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%E6%88%96%E8%80%85%E5%B0%BE%E5%B7%B4%E7%BB%93%E7%82%B9"> （2）、删除元素为中间结点或者尾巴结点</h4> 
<p>当删除中间结点的时候我们可以先找到对于位置的结点cur，利用对应位置的cur.prev和cur.next确定附近两个结点，然后进行删除即可，这个删除与链表相似，只是多了一个删除头结点而已。</p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/93/bd/QDfDkff9_o.png" width="901"> </p> 
<p> 首先跳过后端结点cur.prev.next = cur.next </p> 
<p> <img alt="" height="386" src="https://images2.imgbox.com/10/32/E4JlrPLa_o.png" width="999"></p> 
<p>然后跳过前端结点cur.next.prev = cur.prev </p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/a7/26/71oUxGqM_o.png" width="960"></p> 
<p>但是假如我们遇到了删除结点为尾巴结点该怎么办呢？</p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/fe/db/2LFeitAM_o.png" width="1079"> </p> 
<p>很简单，只需让last = last.prev即可！</p> 
<pre><code class="language-java"> //删除第一次出现关键字为key的节点
    public void remove(int key){
      ListNode cur = this.head;
      while(cur != null){
          if(cur.val == key){
              if(cur == head){//假如为头结点
                  head = head.next;//Next指针移动完毕接下来就是prev指针
                  if(head != null){
                      //判断head是否为空，为空说明这个链表就只有一个元素，不为空说明不止一个
                      //这是说明这个属于中间位置hah
                     head.prev = null;
                  }else{
                     last = null;
                  }
              }else{
                  cur.prev.next = cur.next;
                  if(cur.next != null){
                      //中间位置
                      cur.next.prev = cur.prev;
                  }else{
                      last = last.prev;
                      //假如是最后一个结点，last结点始终指向双向链表最后一个结点，最后一个删除last变为其前驱即可
                  }

              }
              return;
          }
          cur = cur.next;
      }
    }</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93">三、总结</h2> 
<p>双向链表算是对于链表进行了更加全面的优化，需要注意的是，与单链表不同，双链表创建过程中，每创建一个新节点，都要与其前驱节点建立两次联系，分别是：</p> 
<ul><li>将新节点的 prior 指针指向直接前驱节点；</li><li>将直接前驱节点的 next 指针指向新节点；</li></ul> 
<p>这样也更好的利用了前后指针，更加具体的防止了，当我们进行对于链表的增加与删除时，操作不当整个链表丢失的情况。 </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32200dd6791dd3a313dbbc6e1ae30423/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot 企业级开发课后题答案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/23b7d05b8bcf08b2916c577dae2d28f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">brpc组件bvar源码解析（四）Sampler、SamplerCollector和Window类簇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>