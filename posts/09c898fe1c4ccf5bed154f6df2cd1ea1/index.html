<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JS 基本数据类型和引用数据类型的区别及浅拷贝和深拷贝 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JS 基本数据类型和引用数据类型的区别及浅拷贝和深拷贝" />
<meta property="og:description" content="1.栈（stack）和堆（heap）
栈（stack）：
栈会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。
堆（heap）：
动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。
2.基本数据类型和引用数据类型
基本数据类型： Number、String、Boolean、Null、 Undefined、Symbol（ES6），这些类型可以直接操作保存在变量中的实际值
特点： 1.占用空间固定，保存在栈中
当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，
这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，
基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址
的引用变量）
2.保存与复制的是值本身
3.基本数据类型是指存放在栈中的简单数据段、数据大小确定、内存空间大小可分配、直接按值存放的，按值访问
4.引用数据类型存放在堆中
引用类型是存放在堆内存中的对象，变量其实是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址），这个指针指向堆内存引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象 var a = { name: &#39;lily&#39;, age: &#39;16&#39; } var b = a; b.name = &#39;lokka&#39;; console.log(a); // {name: &#34;lokka&#34;, age: &#34;16&#34;} 把 a 赋值给 b ，就相当于把 a 的内存地址指向 b ，即 a 和 b 指向同一内存地址， 改变了 b 就相当于改变了 a
浅拷贝和深拷贝 1.概念：
浅拷贝： 只拷贝一层，深层次的对象级别只拷贝引用。
深拷贝： 拷贝多层，每一级别的数据都会被拷贝出来。
2.浅拷贝的实现方式
1.方法一：通用循环
function shallowCopy(obj) { if (typeof obj !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/09c898fe1c4ccf5bed154f6df2cd1ea1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-21T17:33:04+08:00" />
<meta property="article:modified_time" content="2023-02-21T17:33:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JS 基本数据类型和引用数据类型的区别及浅拷贝和深拷贝</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.栈（stack）和堆（heap）</p> 
<p>栈（stack）：<br> 栈会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。<br> 堆（heap）：<br> 动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。</p> 
<p>2.基本数据类型和引用数据类型</p> 
<blockquote> 
 <p>基本数据类型： <code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Null</code>、 <code>Undefined</code>、<code>Symbol（ES6）</code>，这些类型可以直接操作保存在变量中的实际值</p> 
 <p>特点： </p> 
 <p>       1.占用空间固定，保存在栈中</p> 
 <p>当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，<br> 这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，<br> 基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址<br> 的引用变量）<br>  </p> 
 <p>2.保存与复制的是值本身</p> 
</blockquote> 
<p>3.基本数据类型是指存放在栈中的简单数据段、数据大小确定、内存空间大小可分配、直接按值存放的，按值访问</p> 
<p>4.引用数据类型存放在堆中</p> 
<blockquote> 
 <ul><li>引用类型是存放在堆内存中的对象，变量其实是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址），这个指针指向堆内存</li><li>引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象</li></ul> 
</blockquote> 
<pre><code>  var a = {
    name: 'lily',
    age: '16'
  }

  var b = a;
  b.name = 'lokka';

  console.log(a); // {name: "lokka", age: "16"}
</code></pre> 
<p><strong>把 a 赋值给 b ，就相当于把 a 的内存地址指向 b ，即 a 和 b 指向同一内存地址， 改变了 b 就相当于改变了 a</strong></p> 
<p></p> 
<h3><span style="color:#ed7976;">浅拷贝</span>和深拷贝</h3> 
<p>1.概念：</p> 
<p>浅拷贝： 只拷贝一层，深层次的对象级别只拷贝引用。</p> 
<p>深拷贝： 拷贝多层，每一级别的数据都会被拷贝出来。</p> 
<p>2.浅拷贝的实现方式</p> 
<p>1.方法一：通用循环</p> 
<pre><code class="language-javascript">function shallowCopy(obj) {
  if (typeof obj !== 'object') return;

  const newObj = obj instanceof Array ? [] : {};

  for(let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = obj[key];
    }
  }

  return newObj;
}
</code></pre> 
<p>2.方法二： Object.assign</p> 
<pre><code class="language-javascript">const newObj = Object.assign({}, oldObj);
</code></pre> 
<blockquote> 
 <p>注：对象只有一层是深拷贝 </p> 
</blockquote> 
<pre><code class="language-javascript">let obj = {
   name: 'lokka'
};
let obj2 = Object.assign({},obj);
obj2.name = 'cola';
console.log(obj);//{username: "lokka"}
</code></pre> 
<p>3.方法三：Array.slice</p> 
<pre><code class="language-javascript">const newArray = oldArray.slice();
</code></pre> 
<p>4. 方法四：Array.concat</p> 
<pre><code class="language-javascript">const newArray = oldArray.concat();</code></pre> 
<p>5.方法5: es6</p> 
<pre><code class="language-javascript">const newObj = { ...oldObj};
const newArray = [ ...oldArray ];</code></pre> 
<p>深拷贝的实现方式：</p> 
<p>1.通用循环</p> 
<pre><code class="language-javascript">function deepCopy(obj) {
  if (typeof obj !== 'object') return;

  const newObj = obj instanceof Array ? [] : {};

  for(let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];
    }
  }

  return newObj;
}
</code></pre> 
<p>2.方法二： JSON.parse、JSON.stringify</p> 
<pre><code class="language-javascript">const newObj = JSON.parse(JSON.stringify(oldObj));</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8592eceeb62553a214bbfe7e8998cd42/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OSS上传（Java和Js）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fba987d61fcc443e2cd76f104f17747a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VUE经典面试题总结（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>