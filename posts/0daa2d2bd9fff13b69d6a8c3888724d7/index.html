<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flutter 基于getX搭建通用项目架构 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flutter 基于getX搭建通用项目架构" />
<meta property="og:description" content="一. 网络封装 网络主要使用的是dio 和 retrofit来实现的,关于dio的封装,思路基本上和网上的教程大同小异.大致思路就是创建options对象,设置超时时间,域名,responseType,超时时间等等.然后在创建dio单例对象,给dio对象添加拦截器,我基本上添加三个拦截器分别为
* MiddleInterceptor (获取请求路径,请求参数,打印日志)
* ErrorInterceptor (获取错误原因,打印日志)
* ApiResultInterceptor(获取后端返回结果,处理逻辑,数据返回,比如多设备登录同一账号异常处理等等)
在这里代码就不贴出来了,有兴趣的可以下载demo查看.
为什么要使用retrofit?
retrofit是一个非常好用强大的代码生成器,支持POST GET PATCH PUT等请求.定义好请求方法,返回类型执行一行命令就会自动生成代码,在Controller中直接使用自己使用好的model即可.
常用命令:
* flutter packages pub run build_runner build
* flutter pub run build_runner build --delete-conflicting-outputs
代码定义如下所示
/// 列表接口 @GET(&#34;searchV5&#34;) Future&lt;Result&lt;InfoWorkModel&gt;&gt; getInfoListData( @Query(&#39;pn&#39;) int page, @Query(&#39;ps&#39;) int pageSize, @Query(&#39;q&#39;) String name, @Query(&#39;t&#39;) String t, ); /// 详情接口 @GET(&#34;pc/items/info&#34;) Future&lt;Result&lt;InfoWorkModel&gt;&gt; getInfoDetailData( @Query(&#39;entityId&#39;) int entityId, ); /// 点赞接口 @POST(&#34;thumbsUpOrDown&#34;) Future&lt;Result&lt;InfoWorkModel&gt;&gt; likeThumbsUpOrDown( @Body() Map&lt;String, String&gt; param); Result 类里面就是返回的最外层数据包括 code,msg,data其中data是一个 泛型T可以接受任何类型,然后再定义data里面对象,也就是InfoWorkModel,这样层层定义保障每个对象都转化成modle即可." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0daa2d2bd9fff13b69d6a8c3888724d7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-06T13:57:22+08:00" />
<meta property="article:modified_time" content="2023-12-06T13:57:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flutter 基于getX搭建通用项目架构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h6>一. 网络封装</h6> 
<p>网络主要使用的是<code>dio</code> 和 <code>retrofit</code>来实现的,关于<code>dio</code>的封装,思路基本上和网上的教程大同小异.大致思路就是创建<code>options</code>对象,设置<code>超时时间</code>,<code>域名</code>,<code>responseType</code>,<code>超时时间</code>等等.然后在创建<code>dio</code>单例对象,给<code>dio</code>对象添加拦截器,我基本上添加三个拦截器分别为</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><code><span style="background-color:#cccccc;">* MiddleInterceptor (获取请求路径,请求参数,打印日志)</span></code><br><code><span style="background-color:#cccccc;">* ErrorInterceptor (获取错误原因,打印日志)</span></code><br><code><span style="background-color:#cccccc;">* ApiResultInterceptor(获取后端返回结果,处理逻辑,数据返回,比如多设备登录同一账号异常处理等等)</span></code></span></p> 
</blockquote> 
<p>在这里代码就不贴出来了,有兴趣的可以下载demo查看.<br> 为什么要使用<code>retrofit?</code><br><code>retrofit</code>是一个非常好用强大的代码生成器,支持<code>POST GET PATCH PUT</code>等请求.定义好请求方法,返回类型执行一行命令就会自动生成代码,在<code>Controller</code>中直接使用自己使用好的<code>model</code>即可.<br> 常用命令:</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><code><span style="background-color:#d7d8d9;">* flutter packages pub run build_runner build</span></code><br><code><span style="background-color:#d7d8d9;">* flutter pub run build_runner build --delete-conflicting-outputs</span></code></span></p> 
</blockquote> 
<p>代码定义如下所示</p> 
<p></p> 
<pre><code class="language-Dart">/// 列表接口
  @GET("searchV5")
  Future&lt;Result&lt;InfoWorkModel&gt;&gt; getInfoListData(
    @Query('pn') int page,
    @Query('ps') int pageSize,
    @Query('q') String name,
    @Query('t') String t,
  );

  /// 详情接口
  @GET("pc/items/info")
  Future&lt;Result&lt;InfoWorkModel&gt;&gt; getInfoDetailData(
    @Query('entityId') int entityId,
  );

  /// 点赞接口
  @POST("thumbsUpOrDown")
  Future&lt;Result&lt;InfoWorkModel&gt;&gt; likeThumbsUpOrDown(
      @Body() Map&lt;String, String&gt; param);

</code></pre> 
<blockquote> 
 <p>Result 类里面就是返回的最外层数据包括 <code>code,msg,data</code>其中<code>data</code>是一个 <code>泛型T</code>可以接受任何类型,然后再定义<code>data</code>里面对象,也就是<code>InfoWorkModel</code>,这样层层定义保障每个对象都转化成modle即可.</p> 
</blockquote> 
<p>yaml如下代码所示:</p> 
<p></p> 
<pre><code class="language-Dart">dependencies:
  retrofit: '&gt;=4.0.0 &lt;5.0.0'
  dio: ^4.0.6
dev_dependencies:
  retrofit_generator: '&gt;=5.0.0 &lt;6.0.0'
  build_runner: '&gt;=2.3.0 &lt;4.0.0' 
  json_serializable: ^4.4.0
</code></pre> 
<h6>二. 路由设计</h6> 
<p>将真心话使用了<code>GetX</code>之后基本就不需要路由设计了,<code>GetX</code>都封装好了,在这里就说几个<code>Api</code>吧.</p> 
<blockquote> 
 <p>1.跳转界面<br><code>Get.toNamed('/test');</code><br> 2.跳转界面传值<br><code>Get.toNamed('/test', arguments: {'id': '0'});</code><br> 3.跳转界面并执行页面返回事件(比如刷新数据)<br><code>Get.toNamed("/test",)?.then((value) { print('执行事件'); });</code><br> 4.返回上一界面<br><code>Get.back();</code><br> 5.返回上一界面并回调传值<br><code>Get.back(result: { 'id':1 });</code><br> 6.返回上一界面并关闭当前页面<br><code>Get.offNamed("/test");</code><br> 7.返回上一界面并关闭之前所有页面<br><code>Get.offAll("/test");</code><br> 8.返回指定页面<br><code>Get.until((route) =&gt; Get.currentRoute == '/test');</code></p> 
</blockquote> 
<h6>三.状态管理</h6> 
<p>1.使用<code>GetBuilder</code>:<br> 在<code>buildContent</code>中直接返回<code>GetBuilder</code>,然后在<code>Controller</code>中数据发生变化后调用<code>update()</code>方法整个页面都会发生变化，适合列表页面的开发。</p> 
<p></p> 
<pre><code class="language-Dart">GetBuilder&lt;HomeController&gt;(
     builder: (_) {
       return Container();
     },
   );
</code></pre> 
<p>2.使用<code>RxX..</code>和<code>Obx()</code>配合使用进行小部件的状态刷新。</p> 
<h6>关于状态管理的设计原理：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.zhihu.com%2Ftardis%2Fbd%2Fart%2F491860840%3Fsource_id%3D1001" rel="nofollow" title="参考这篇文章">参考这篇文章</a></h6> 
<h6>四.Base类设计</h6> 
<ol><li>BaseView 设计</li></ol> 
<p></p> 
<pre><code class="language-Dart">import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:get/get_state_manager/get_state_manager.dart';

abstract class BaseView&lt;T&gt; extends GetView&lt;T&gt; {
  BaseView({Key? key}) : super(key: key);

  /// 状态栏高度
  double statusBarH = ScreenUtil().statusBarHeight;

  /// 导航栏高度
  double navBarH = AppBar().preferredSize.height;

  /// 安全区域高度
  double safeBarH = ScreenUtil().bottomBarHeight;

  /// 设置背景颜色
  Color? contentColor;

  /// 设置标题文字
  String? navTitle;

  /// 设置导航栏颜色
  Color? navColor;

  /// 设置左边按钮
  Widget? leftButton;

  /// 设置左边宽度
  double? leftWidth;

  /// 设置右边按钮数组
  List&lt;Widget&gt;? rightActionList;

  /// 是否隐藏导航栏
  bool? isHiddenNav;

  /// 设置主主视图内容(子类不实现会报错)
  Widget buildContent();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        backgroundColor: contentColor ?? Colors.white,
        appBar: isHiddenNav == true
            ? null
            : AppBar(
                backgroundColor: navColor ?? Colors.white70,
                title: Text(
                  navTitle ?? '',
                ),
                leading: leftButton ?? const SizedBox(),
                leadingWidth: leftWidth ?? 0,
                actions: rightActionList ?? [],
              ),
        body: buildContent());
  }
}

</code></pre> 
<h6><code>新创建的widget都继承自BaseView 这样在集成于BaseView 的widget中可以方便设置和获取一些常用的页面属性以及完成页面基本布局。</code></h6> 
<ol><li>BaseController 设计</li></ol> 
<p></p> 
<pre><code class="language-Dart">import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';

enum NetState {
  /// 初始状态
  initializeState,
  /// 加载状态
  loadingState,

  /// 错误状态,显示失败界面
  errorState,

  /// 错误状态,只弹错误信息
  erroronlyTotal,

  /// 错误状态,显示刷新按钮
  errorshowRelesh,

  /// 没有更多数据
  noMoreDataState,

  /// 是否还有更多数据
  hasMoreDataState,

  /// 空数据状态
  emptyDataState,

  /// 数据获取成功状态
  dataSussessState,
}

abstract class BaseController extends SuperController {
  /// 定义网络状态方便子控制器使用
  NetState netState = NetState.initializeState;

  @override
  void onReady() {
    super.onReady();
    initData();
  }

  @override
  void onDetached() {
    debugPrint("a11111");
  }

  @override
  void onInit() {
    // TODO: implement onInit
    super.onInit();
  }

  @override
  void onInactive() {
    debugPrint("a11112");
  }

  @override
  void onPaused() {
    //彻底离开回调
    debugPrint("a11113");
  }

  @override
  void onResumed() {
    //彻底恢复回调
    debugPrint("a11114");
  }

  void initData();
}

</code></pre> 
<p>这个类不需要多说就是重写了一下Getx的生命周期方法，以及添加了一个<code>网络状态的属性</code>,为什么把网络状态加在<code>BaseController</code>中呢？稍后再讲。</p> 
<h6>分析：正常来说到了这一步就可以利用这两个base来做项目了，无非就是在<code>Controller</code>里面请求数据，然后根据接口的返回在<code>Controller</code>里面更新<code>netState</code>网络状态，然后在<code>widget</code>里面根据<code>netState</code>的状态，判断返回<code>LoadingWidget</code>，或者<code>EmptyWidget</code>，或者<code>ErrorWidget</code>，数据请求成功返回<code>SussessWidget</code>，总之需要在<code>widget</code>里面写大量的判断逻辑，并且凡是涉及到<code>根据网络请求接口返回来展示页面(实际上90%都是这样)</code>的都要把这些判断复制一遍，非常麻烦，那么重点来了：</h6> 
<ol><li>BaseCommonView 设计</li></ol> 
<p></p> 
<pre><code class="language-Dart">import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:get_demo/base/base_view.dart';
import 'package:get_demo/widget/loading_widget.dart';
import '../widget/empty_status.dart';
import 'base_common_controller.dart';
import 'base_controller.dart';

abstract class BaseCommonView&lt;T&gt; extends BaseView&lt;T&gt; {
  BaseCommonView({Key? key}) : super(key: key);

  /// 创建空视图 (子视图实现的话 Widget就是子视图实现的)
  Widget creatEmptyWidget() {
    return const EmptyStatusWidget(
      emptyType: EmptyStatusType.noMessage,
    );
  }

  /// 创建错误视图 (子视图实现的话 Widget就是子视图实现的)
  Widget creatFailWidget(BaseCommonController controller) {
    return EmptyStatusWidget(
      emptyType: EmptyStatusType.fail,
      refreshTitle: '重新加载',
      width: 1.sw,
      height: 1.sh,
      onTap: () {
        /// 重新请求数据
        controller.getnetworkdata(controller.configNetWorkParmas());
      },
    );
  }

  /// 创建页面主视图
  Widget creatCommonView(BaseCommonController controller, Widget commonView) {
    return _refresherListView(controller, commonView);
  }

  Widget _refresherListView(
      BaseCommonController controller, Widget commonView) {
    if (controller.netState == NetState.loadingState) {
      /// loading 不会有这个状态,只是写一个这样的判断吧(控制器里面已经封装好了单例了,防止在网络层直接操作控制不了loading的场景)
      return const LoadingWidget();
    } else if (controller.netState == NetState.emptyDataState) {
      /// 返回站位视图
      return creatEmptyWidget();
    } else if (controller.netState == NetState.errorshowRelesh) {
      /// 返回站位刷新视图
      return creatFailWidget(controller);
    } else if (controller.netState == NetState.dataSussessState) {
      return commonView;
    } else if (controller.netState == NetState.initializeState) {
      return const SizedBox();
    } else {
      return const Center(child: Text('未知情况,待排查'));
    }
  }
}

</code></pre> 
<h6>继承自<code>BaseCommonView</code>的<code>widget（view）</code>只需要调用<code>creatCommonView</code>方法，</h6> 
<h6>然后将自己绑定的<code>controller(继承BaseCommonController稍后会讲)</code>和自己页面<code>（view）</code>将要实现的页面<code>widget</code>传递<code>BaseCommonView</code>就可以了，在<code>BaseCommonView</code>中会根据<code>controller</code>中的网络状态<code>(这就是把网络状态定义在BaseController中的原因了，子类都要使用不需要每次都创建了)</code>展示不同的<code>widget</code>，这样就不需要在每个页面中进行重复的判断了，然后如果想自定义<code>EmptyStatusWidget</code>那么只需要在子页面重写<code>creatEmptyWidget方法</code>或者<code>creatFailWidget方法</code>就可以了。</h6> 
<ol><li>BaseCommonController 设计<br> 和BaseCommonView配套的还有BaseCommonController。方便网络请求的方法和一些参数调用。</li></ol> 
<p></p> 
<pre><code class="language-Dart">import 'package:pull_to_refresh/pull_to_refresh.dart';
import '../../base/abstract_network.dart';
import '../../base/base_controller.dart';

/**
 *  普通视图控制器
 * */

abstract class BaseCommonController extends BaseController
    with AbstractNetWork {

  @override
  void getnetworkdata(Map&lt;String, dynamic&gt; info) {
    // TODO: implement getnetworkdata
  }

  @override
  Map&lt;String, dynamic&gt; configNetWorkParmas() {
    // TODO: implement configNetWorkParmas
    throw UnimplementedError();
  }
}

</code></pre> 
<h6><code>BaseCommonController</code>就是为了方便在<code>子Controller</code>进行网络请求而设计的。子类直接重写网络请求方法<code>getnetworkdata</code>和设置<code>Map</code>就可以了，不需要重复定义。<code>BaseCommonController</code>混入<code>with AbstractNetWork</code>类。</h6> 
<ol><li> <p>AbstractNetWork 设计</p>   <p class="img-center"><img alt="" height="615" src="https://images2.imgbox.com/26/95/PE2RYyqI_o.png" width="532"></p> <p>image.png</p> </li></ol> 
<p>6.总结：有了这几个base类在开发中就非常方便了，只需要注意自己的widget<code>（view）</code>和业务逻辑<code>controller</code>就行了，不需要在<code>view</code>中进行繁琐的判断了，还是非常适合快速开发的，另外在项目里面还有针对列表设计的<code>BaseListController</code>和<code>BaseListView</code>使用方法和<code>BaseCommonView</code>大同小异，在这里就不贴代码了，感兴趣的可以自己下载 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2FTTGF%2Fgitx_demo" rel="nofollow" title="demo">demo</a>观看。</p> 
<h2><code>总体设计图</code></h2> 
<p class="img-center"><img alt="" height="607" src="https://images2.imgbox.com/60/50/wFXhfvo6_o.png" width="1200"></p> 
<p>总体设计</p> 
<h6>六.架构升级</h6> 
<p>新增<code>state</code>状态层，负责定义属性，赋值等操作。因为随着业务的增加，一个页面在业务层既要定义属性又要处理逻辑代码维护起来很是头层。</p> 
<h6>七.局部刷新方法</h6> 
<p>为了性能考虑，有些需要局部刷新的页面，就不需要刷新全部。有两种方法实现吧。<br> 1.使用<code>Obx</code>来实现，在需要改变的<code>widget</code>外面嵌套一层<code>Obx</code>，当状态改变时只刷新被<code>Obx</code>包裹的<code>widget</code>。<br> 2.使用<code>GetBuilder</code>来实现，多个GetBuilder使用同一个CounterController的变量，但是我们只想更新其中一个GetBuilder的变量，就可以在添加id参数</p> 
<p></p> 
<pre><code class="language-Dart">update(["id"]); // 只对id为“id”的GetBuilder
</code></pre> 
<p>view层</p> 
<p></p> 
<pre><code class="language-Dart">GetBuilder&lt;CounterController1&gt;( // 不刷新
  builder: (controller){
   return Text(
     "count的值为：${counter.count}",
     style: const TextStyle(color: Colors.redAccent,fontSize: 20),
   );
},
</code></pre> 
<h6>八.GetX 遇到的坑</h6> 
<p>跳转相同页面时比如说:1-2-3-2,会发现2页面的数据不会刷新,这是GetX内部的缓存机制造成,传一个唯一tag值就可以了.</p> 
<h6>六.项目配置项,手动更改环境(后端域名)</h6> 
<p>实际开发中会有开发换进,测试环境,发布环境,正式环境等,每次给测试发包会很麻烦,所以就做了一个切换环境的功能.思路就是通过全局环境一个字段来进行读取<code>baseUrl</code>,有需要直接看代码即可,思路很简单.</p> 
<p>demo地址请移步: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2FTTGF%2Fgitx_demo" rel="nofollow" title="项目地址">项目地址</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e6d02a2d676f7a1acf5bb7664e551a7a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TG2016SKA/TG2016SLA TCXO适用于车载GNSS和V2X</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81f5e7c69c7e3ee663f49f90b8e8dd5a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Gradle】mac环境安装Gradle及配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>