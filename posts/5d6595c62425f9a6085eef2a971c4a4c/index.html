<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>POD 以及POD调度 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="POD 以及POD调度" />
<meta property="og:description" content="目录 一、Pod的基本概念二、pod存在意义三、Pod的实现机制 3.1 共享网络3.2 共享存储四、Pod镜像拉取策略五、Pod资源限制六、Pod重启机制七、Pod健康检查八、Pod调度策略-创建pod流程九、影响Pod调度 1.Pod的资源限制2.节点选择器标签3.节点亲和性4.污点 (1)基本介绍(2)应用场景(3)具体演示(4)节点添加污点(5)节点删除污点5.污点容忍 一、Pod的基本概念 ​ Pod是k8s系统中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最 小资源对象模型，也是在 k8s 上运行容器化应用的资源对象，其他的资源对象都是用来支 撑或者扩展 Pod 对象功能的，比如控制器对象是用来管控 Pod 对象的，Service 或者 Ingress 资源对象是用来暴露 Pod 引用对象的，PersistentVolume 资源对象是用来为 Pod 提供存储等等，k8s 不会直接处理容器，而是 Pod，Pod 是由一个或多个 container 组成
Pod 是 Kubernetes 的最重要概念，每一个 Pod 都有一个特殊的被称为”根容器“的 Pause 容器。Pause 容器对应的镜 像属于 Kubernetes 平台的一部分，除了 Pause 容器，每个 Pod 还包含一个或多个紧密相关的用户业务容器
最小部署单元pod里面可以包含多个容器(一组容器的集合)一个pod中容器共享网络命名空间pod是短暂的 二、pod存在意义 创建容器使用docker ，一个docker对应是一个容器，一个容器有进程，一个容器运行一个运用程序pod是多进行设计，运行多个应用程序 一个pod有多个容器，一个容器里面运行一个应用程序 pod存在为了亲密性应用 两个应用之间进行交互网络之间调用两个应用需要频繁调用 三、Pod的实现机制 3.1 共享网络 pod实现共享网络机制：
首先创建Pause容器也可以叫做info容器或者根容器再创建业务容器，每次创建业务容器都会加入到info容器里面，这样pod就在同一个namespace下面，这样就可以网络共享 3.2 共享存储 pod实现共享存储机制：
引入Volumn数据卷的概念，使用数据卷进行持久化存储 四、Pod镜像拉取策略 imagePullPolicy
ifNotPresent:宿主机不存在则拉取Always:每次创建pod都会重新拉取一次镜像Never：pod永远都不糊主动拉取镜像 五、Pod资源限制 六、Pod重启机制 restartPullPolicy" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5d6595c62425f9a6085eef2a971c4a4c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-04T23:59:00+08:00" />
<meta property="article:modified_time" content="2021-09-04T23:59:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">POD 以及POD调度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown" style="font-size: 16px;"> 
 <div class="toc"> 
  <div class="toc-container-header">
    目录 
  </div> 
  <ul><li><a href="#%E4%B8%80pod%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">一、Pod的基本概念</a></li><li><a href="#%E4%BA%8Cpod%E5%AD%98%E5%9C%A8%E6%84%8F%E4%B9%89" rel="nofollow">二、pod存在意义</a></li><li><a href="#%E4%B8%89pod%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6" rel="nofollow">三、Pod的实现机制</a> 
    <ul><li><a href="#31-%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C" rel="nofollow">3.1 共享网络</a></li><li><a href="#32-%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8" rel="nofollow">3.2 共享存储</a></li></ul></li><li><a href="#%E5%9B%9Bpod%E9%95%9C%E5%83%8F%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5" rel="nofollow">四、Pod镜像拉取策略</a></li><li><a href="#%E4%BA%94pod%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6" rel="nofollow">五、Pod资源限制</a></li><li><a href="#%E5%85%ADpod%E9%87%8D%E5%90%AF%E6%9C%BA%E5%88%B6" rel="nofollow">六、Pod重启机制</a></li><li><a href="#%E4%B8%83pod%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5" rel="nofollow">七、Pod健康检查</a></li><li><a href="#%E5%85%ABpod%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5-%E5%88%9B%E5%BB%BApod%E6%B5%81%E7%A8%8B" rel="nofollow">八、Pod调度策略-创建pod流程</a></li><li><a href="#%E4%B9%9D%E5%BD%B1%E5%93%8Dpod%E8%B0%83%E5%BA%A6" rel="nofollow">九、影响Pod调度</a> 
    <ul><li><a href="#1pod%E7%9A%84%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6" rel="nofollow">1.Pod的资源限制</a></li><li><a href="#2%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9%E5%99%A8%E6%A0%87%E7%AD%BE" rel="nofollow">2.节点选择器标签</a></li><li><a href="#3%E8%8A%82%E7%82%B9%E4%BA%B2%E5%92%8C%E6%80%A7" rel="nofollow">3.节点亲和性</a></li><li><a href="#4%E6%B1%A1%E7%82%B9" rel="nofollow">4.污点</a> 
      <ul><li><a href="#1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D" rel="nofollow">(1)基本介绍</a></li><li><a href="#2%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">(2)应用场景</a></li><li><a href="#3%E5%85%B7%E4%BD%93%E6%BC%94%E7%A4%BA" rel="nofollow">(3)具体演示</a></li><li><a href="#4%E8%8A%82%E7%82%B9%E6%B7%BB%E5%8A%A0%E6%B1%A1%E7%82%B9" rel="nofollow">(4)节点添加污点</a></li><li><a href="#5%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4%E6%B1%A1%E7%82%B9" rel="nofollow">(5)节点删除污点</a></li></ul></li><li><a href="#5%E6%B1%A1%E7%82%B9%E5%AE%B9%E5%BF%8D" rel="nofollow">5.污点容忍</a></li></ul></li></ul> 
 </div> 
 <h3 id="一pod的基本概念">一、Pod的基本概念</h3> 
 <p>​ Pod是k8s系统中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最 小资源对象模型，也是在 k8s 上运行容器化应用的资源对象，其他的资源对象都是用来支 撑或者扩展 Pod 对象功能的，比如控制器对象是用来管控 Pod 对象的，Service 或者 Ingress 资源对象是用来暴露 Pod 引用对象的，PersistentVolume 资源对象是用来为 Pod 提供存储等等，k8s 不会直接处理容器，而是 Pod，Pod 是由一个或多个 container 组成</p> 
 <p>Pod 是 Kubernetes 的最重要概念，每一个 Pod 都有一个特殊的被称为”根容器“的 Pause 容器。Pause 容器对应的镜 像属于 Kubernetes 平台的一部分，除了 Pause 容器，每个 Pod 还包含一个或多个紧密相关的用户业务容器</p> 
 <ul><li>最小部署单元</li><li>pod里面可以包含多个容器(一组容器的集合)</li><li>一个pod中容器共享网络命名空间</li><li>pod是短暂的</li></ul> 
 <h3 id="二pod存在意义">二、pod存在意义</h3> 
 <ul><li>创建容器使用docker ，一个docker对应是一个容器，一个容器有进程，一个容器运行一个运用程序</li><li>pod是多进行设计，运行多个应用程序 
   <ul><li>一个pod有多个容器，一个容器里面运行一个应用程序</li></ul> </li><li>pod存在为了亲密性应用 
   <ul><li>两个应用之间进行交互</li><li>网络之间调用</li><li>两个应用需要频繁调用</li></ul> </li></ul> 
 <h3 id="三pod的实现机制">三、Pod的实现机制</h3> 
 <h4 id="31-共享网络">3.1 共享网络</h4> 
 <p><img src="https://images2.imgbox.com/42/0d/b3bFYzvd_o.png" alt="" style="outline: none;"></p> 
 <p><strong>pod实现共享网络机制</strong>：</p> 
 <ul><li>首先创建<code>Pause容器</code>也可以叫做<code>info容器</code>或者<code>根容器</code></li><li>再创建业务容器，每次创建业务容器都会加入到<code>info容器</code>里面，这样pod就在同一个<code>namespace</code>下面，这样就可以<strong>网络共享</strong></li></ul> 
 <h4 id="32-共享存储">3.2 共享存储</h4> 
 <p><img src="https://images2.imgbox.com/da/3d/8zaOALrt_o.png" alt="" style="outline: none;"></p> 
 <p><strong>pod实现共享存储机制</strong>：</p> 
 <ul><li>引入<code>Volumn</code>数据卷的概念，使用数据卷进行持久化存储</li></ul> 
 <h3 id="四pod镜像拉取策略">四、Pod镜像拉取策略</h3> 
 <p><img src="https://images2.imgbox.com/ac/b0/RYb4TcJn_o.png" alt="" style="outline: none;"></p> 
 <p><strong>imagePullPolicy</strong></p> 
 <ul><li>ifNotPresent:宿主机不存在则拉取</li><li>Always:每次创建pod都会重新拉取一次镜像</li><li>Never：pod永远都不糊主动拉取镜像</li></ul> 
 <h3 id="五pod资源限制">五、Pod资源限制</h3> 
 <p><img src="https://images2.imgbox.com/d7/1d/hFQHiDh3_o.png" alt="" style="outline: none;"></p> 
 <h3 id="六pod重启机制">六、Pod重启机制</h3> 
 <p><img src="https://images2.imgbox.com/be/a3/tt9FoHuy_o.png" alt="" style="outline: none;"></p> 
 <p><strong>restartPullPolicy</strong></p> 
 <ul><li>Always：当容器终止退出后，总是重启容器，默认策略</li><li>onFailure: 当容器异常退出(退出状态码非0)时，才重启容器</li><li>Never：当容器终止退出，从不重启容器。</li></ul> 
 <h3 id="七pod健康检查">七、Pod健康检查</h3> 
 <p><img src="https://images2.imgbox.com/6b/e7/8dlO23AW_o.png" alt="" style="outline: none;"></p> 
 <h3 id="八pod调度策略-创建pod流程">八、Pod调度策略-创建pod流程</h3> 
 <p><img src="https://images2.imgbox.com/3d/07/vcvRnaLO_o.png" alt="" style="outline: none;"></p> 
 <p><strong>创建pod流程</strong></p> 
 <ul><li><strong>createPod</strong> 首先到<code>Api Server</code>创建<code>Pod</code>然后在etcd里面存储pod的信息</li><li><code>Scheduler</code>会实时监控<code>Api Server</code>有没有新的<code>Pod</code>创建，如果发现有新的<code>Api Server</code>有新的Pod创建，通过<code>Api Server</code>读取<code>etcd</code>信息根据<code>调度算法</code>把读取出来pod调度到某个node上面,然后把最终的结果返回给api server然后存储在etcd中</li><li><strong>Node节点</strong>通过<code>kubelet</code>到api server 读取etcd，查询分配给当前node的pod信息，然后通过docker把容器创建，创建之后把状态返回给api server，并且在etcd中进行存储</li></ul> 
 <h3 id="九影响pod调度">九、影响Pod调度</h3> 
 <p><img src="https://images2.imgbox.com/0d/76/zyMg2JEW_o.png" alt="" style="outline: none;"></p> 
 <h4 id="1pod的资源限制">1.Pod的资源限制</h4> 
 <pre class="has"><code class="language-,">resources:
	requests:
		memory; "64Mi",
		cpu: "250m"</code></pre> 
 <ul><li>根据request找到足够node节点进行调度</li></ul> 
 <h4 id="2节点选择器标签">2.节点选择器标签</h4> 
 <pre class="has"><code>nodeSelector:
	env_role: dev</code></pre> 
 <h4 id="3节点亲和性">3.节点亲和性</h4> 
 <p><img src="https://images2.imgbox.com/66/2a/4lZOJn4L_o.png" alt="" style="outline: none;"></p> 
 <ul><li> <p>硬亲和性</p> <p>约束条件必须满足</p> </li><li> <p>软亲和性</p> </li></ul> 
 <h4 id="4污点">4.污点</h4> 
 <h5 id="1基本介绍">(1)基本介绍</h5> 
 <ul><li><code>nodeSelect</code>和<code>nodeAffinity</code>:Pod调度到某些节点上，<strong>pod属性</strong>，调度的时候实现</li><li><code>Taint污点</code>：节点不做普通分配调度，是节点属性</li></ul> 
 <h5 id="2应用场景">(2)应用场景</h5> 
 <ul><li>专用节点</li><li>配置特点硬件节点</li><li>基于Taint驱逐</li></ul> 
 <h5 id="3具体演示">(3)具体演示</h5> 
 <ul><li> <p>查看节点污点情况</p> <pre class="has"><code>kubectl describe node k8smaster | grep Taint</code></pre> </li><li> <p>污点里面的值3个</p> 
   <ul><li>NoSchedule: 表示这个节点一定不被调度</li><li>PreferNoSchedule:尽量不被调度</li><li>NoExecute:不会被调度，并且还会被驱逐Node已有的Pod</li></ul> </li></ul> 
 <h5 id="4节点添加污点">(4)节点添加污点</h5> 
 <pre class="has"><code>kubectl taint node [node主机名称] key=value:污点3个值</code></pre> 
 <h5 id="5节点删除污点">(5)节点删除污点</h5> 
 <pre class="has"><code>kubectl taint node [node主机名称] key:污点3个值 -</code></pre> 
 <h4 id="5污点容忍">5.污点容忍</h4> 
 <pre class="has"><code>spec:
	tolerations:
	- key: "key" // 当初设置node的key
		opreator："Equl"
		value: "value"
		effect: "NoSchedule"
	
	containers:
	- name: webdemo
		image: nginx</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb719a1cc09265376ec78cbf33cf37f8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言-哈希查找(HASH)-详解（完整代码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fad2420e150fab4c0aea31d0c3d6056e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">开关电源之PCB安规设计规范</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>