<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java基础：文件上传案例 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java基础：文件上传案例" />
<meta property="og:description" content="文件上传案例的客户端: 读取本地文件,上传到服务器,读取服务器回写的数据
明确:
数据源:c:\\1.jpg
目的地:服务器
实现步骤:
1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源
2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号
3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象
4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件
5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器
6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象
7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据
8.释放资源(FileInputStream,Socket)
public class TCPClient { public static void main(String[] args) throws IOException{ //1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(&#34;day01-code\\5.png&#34;); //2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号 Socket socket = new Socket(&#34;xxx.xxx.xxx.xxx&#34;,9999); //3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象 OutputStream os = socket.getOutputStream(); //4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件 int len = 0; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes))!= -1) { //5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器 os.write(bytes,0 ,len); } /* 解决:上传完文件,给服务器写一个结束标记 void shutdownOutput() 禁用此套接字的输出流。 对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 */ socket." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/11e14467d6f7239a037f90a662555522/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-01T19:41:04+08:00" />
<meta property="article:modified_time" content="2022-06-01T19:41:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java基础：文件上传案例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><strong>文件上传案例的客户端:</strong></h4> 
<p>    读取本地文件,上传到服务器,读取服务器回写的数据</p> 
<p><strong>明确:</strong><br>     数据源:c:\\1.jpg<br>     目的地:服务器</p> 
<p><strong>实现步骤:</strong><br>     1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源<br>     2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号<br>     3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象<br>     4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件<br>     5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器<br>     6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象<br>     7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据<br>     8.释放资源(FileInputStream,Socket)</p> 
<pre><code class="language-java">public class TCPClient {
    public static void main(String[] args) throws IOException{
        //1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream("day01-code\\5.png");
        //2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号
        Socket socket = new Socket("xxx.xxx.xxx.xxx",9999);
        //3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象
        OutputStream os = socket.getOutputStream();
        //4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = fis.read(bytes))!= -1) {
            //5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器
            os.write(bytes,0 ,len);
        }

        /*
            解决:上传完文件,给服务器写一个结束标记
            void shutdownOutput() 禁用此套接字的输出流。
            对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。
         */
        socket.shutdownOutput();

        //6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象
        InputStream is = socket.getInputStream();
        //7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据
        while ((len = is.read(bytes))!= -1) {
            System.out.println(new String(bytes,0,len));
        }
        //8.释放资源(FileInputStream,Socket)
        fis.close();
        socket.close();
    }
}</code></pre> 
<h4><strong>文件上传案例服务器端:</strong></h4> 
<p>        读取客户端上传的文件,保存到服务器的硬盘,给客户端回写"上传成功"</p> 
<p><strong>明确:</strong><br>         数据源:客户端上传的文件<br>         目的地:服务器的硬盘 d:\\upload\\1.jpg</p> 
<p><strong>实现步骤:</strong><br>         1.创建一个服务器ServerSocket对象,和系统要指定的端口号<br>         2.使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象<br>         3.使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象<br>         4.判断d:\\upload文件夹是否存在,不存在则创建<br>         5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地<br>         6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件<br>         7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上<br>         8.使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象<br>         9.使用网络字节输出流OutputStream对象中的方法write,给客户端回写"上传成功"<br>         10.释放资源(FileOutputStream,Socket,ServerSocket)</p> 
<pre><code class="language-java">public class TCPServer {
    public static void main(String[] args) throws IOException{
        //1.创建一个服务器ServerSocket对象,和系统要指定的端口号
        ServerSocket server = new ServerSocket(9999);
        //2.使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象
        Socket socket = server.accept();
        //3.使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象
        InputStream is = socket.getInputStream();
        //4.判断d:\\upload文件夹是否存在,不存在则创建
        File file = new File("day01-code\\新建文件夹2");
        if (!file.exists()){
            file.mkdirs();
        }
        //5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地
        FileOutputStream fos = new FileOutputStream(file+"\\6.png");
        //6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = is.read(bytes)) != -1) {
            //7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上
            fos.write(bytes,0,len);
        }
        //8.使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象
        //9.使用网络字节输出流OutputStream对象中的方法write,给客户端回写"上传成功"
        socket.getOutputStream().write("上传成功".getBytes());
        //10.释放资源(FileOutputStream,Socket,ServerSocket)
        fos.close();
        socket.close();
        server.close();
    }
}</code></pre> 
<h4><strong>服务器端优化：</strong></h4> 
<p><strong>功能：</strong></p> 
<p><strong>        </strong>文件命名&amp;循环接收&amp;多线程提高效率</p> 
<pre><code class="language-java">public class TCPServer_youhua {
    public static void main(String[] args) throws IOException{
        //1.创建一个服务器ServerSocket对象,和系统要指定的端口号
        ServerSocket server = new ServerSocket(9999);

        /*
            使用多线程技术,提高程序的效率
            有一个客户端上传文件,就开启一个线程,完成文件的上传
         */
        while (true){
            //2.使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象
            Socket socket = server.accept();

            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        //3.使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象
                        InputStream is = socket.getInputStream();
                        //4.判断d:\\upload文件夹是否存在,不存在则创建
                        File file = new File("day01-code\\新建文件夹2");
                        if (!file.exists()){
                            file.mkdirs();
                        }

                        /*
                            自定义一个文件的命名规则:防止同名的文件被覆盖
                            规则:域名+毫秒值+随机数
                        */
                        String fileName = "域名"+System.currentTimeMillis()+new Random().nextInt(9999)+".jpg";

                        //5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地
                        FileOutputStream fos = new FileOutputStream(file+"\\"+fileName);
                        //6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件
                        int len = 0;
                        byte[] bytes = new byte[1024];
                        while ((len = is.read(bytes)) != -1) {
                            //7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上
                            fos.write(bytes,0,len);
                        }
                        //8.使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象
                        //9.使用网络字节输出流OutputStream对象中的方法write,给客户端回写"上传成功"
                        socket.getOutputStream().write("上传成功".getBytes());
                        //10.释放资源(FileOutputStream,Socket,ServerSocket)
                        fos.close();
                        socket.close();
                    }catch (IOException e){
                        System.out.println(e);
                    }
                }
            }).start();
        }

        //因为在死循环，服务器就不用关闭
        //server.close();
    }
}</code></pre> 
<p><strong>注：本文仅用来记录本人的学习笔记，方便以后复习查阅。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db000091421fe7db6e7869112358c4a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method报错解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab7ea605e3b301131fa35f144da9191c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Webstorm配置autoprefixer插件-css3自动补全兼容前缀</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>