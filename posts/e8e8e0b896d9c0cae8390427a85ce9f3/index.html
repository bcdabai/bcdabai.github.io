<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>标签传播算法（半监督图算法） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="标签传播算法（半监督图算法）" />
<meta property="og:description" content="graphx 实现 参数调优很简单。LPA 使用最大迭代参数运行，并且使用默认值 5 就可以得到一些好的结果。Raghavan 和她的合作者在几个有标签的网络上测试了 LPA。他们发现至少 95% 的节点在 5 次迭代中被正确分类。运行时间内近线性。LPA 的每次迭代都是 O (m)，边的数量是线性的。与 以前的一些社区检测解决方案中的O (n log n) 或 O (m&#43;n) 相比，整个步骤序列的运行时间几乎是线性的。可解释性。当有人问起时，您可以解释为什么将节点分组到某个社区中。 标签传播算法（Label Propagation）及Python实现 https://blog.csdn.net/zouxy09/article/details/49105265 标签传播（Label Propagation）算法详解
http://www.go60.top/view/89.html
（1）为每个节点随机的指定一个自己特有的标签；
（2）逐轮刷新所有节点的标签，直到所有节点的标签不再发生变化为止。对于每一轮刷新，节点标签的刷新规则如下：
对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋值给当前节点。当个数最多的标签不唯一时，随机选择一个标签赋值给当前节点（选择标签值最大的那个）。
算法的每个迭代过程中节点的标签更新是基于它的邻接节点的标签
同步更新是指，节点x在t时刻的更新是基于邻接节点在t-1时刻的标签。异步更新是指，节点x在t时刻更新时，其部分邻接节点是t时刻更新的标签，还有部分的邻接节点是t-1时刻更新的标签。LPA算法在标签传播过程中采用的是同步更新，研究者们发现同步更新应用在二分结构网络中，容易出现标签震荡的现象。因此，之后的研究者大多采用异步更新策略来避免这种现象的出现
在网络中，每一个样本点只能属于一个社区，这样的问题称为非重叠社区划分
对于网络中的每一个节点，在初始阶段，Label Propagation 算法对每个节点初始化一个唯一的标签，在每次的迭代过程中，每个节点根据与其相连的节点所属的标签改变自己的标签，更改的原则是选择与其相连的节点中所属标签最多的社区标签为自己的社区标签，这便是标签传播的含义。随着社区标签不断传播，最终，连接紧密的节点将有共同的标签
Label Propagation算法利用网络自身的结构指导标签的传播过程，在这个过程中无需优化任何函数。在算法开始前我们不必知道社区的个数，随着算法的迭代，在最终的过程中，算法将自己决定社区的个数
在图 2 中所示的标签传播的过程中，对于 c 节点，在选择了与 a 节点一致的标签后，与 d 节点相邻的节点中，属于 a 社区的节点最多，因此 c 节点的标签也被设置成 a，这样的过程不断持续下去，直到所有可能聚集到一起的节点都具有了相同的社区标签，此时，图 2 中的所有节点的标签都变成了 a。在传播过程的最终，具有相同社区标签的节点被划到相同的社区中成为一个个独立的社区。
同步更新是指对于节点 x，在第 t 代时，根据其所有邻居节点在第 t-1 代时的社区标签，对其标签进行更新。即：
其中，Cx(t) 表示的是节点 x 在第 t 代时的社区标签。函数 f 表示的是取的参数节点中所有社区个数最大的社区。同步更新的方法存在一个问题，即对于一个二分或者近似二分的网络来说，这样的结构会导致标签的震荡，如图 3 所示。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e8e8e0b896d9c0cae8390427a85ce9f3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-13T16:12:37+08:00" />
<meta property="article:modified_time" content="2021-03-13T16:12:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">标签传播算法（半监督图算法）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>graphx 实现</h2> 
<p> </p> 
<ul><li>参数调优很简单。LPA 使用最大迭代参数运行，并且使用默认值 5 就可以得到一些好的结果。Raghavan 和她的合作者在几个有标签的网络上测试了 LPA。他们发现至少 95% 的节点在 5 次迭代中被正确分类。</li><li>运行时间内近线性。LPA 的每次迭代都是 O (m)，边的数量是线性的。与 以前的一些社区检测解决方案中的O (n log n) 或 O (m+n) 相比，整个步骤序列的运行时间几乎是线性的。</li><li>可解释性。当有人问起时，您可以解释为什么将节点分组到某个社区中。</li></ul> 
<h2>标签传播算法（Label Propagation）及Python实现</h2> 
<p>https://blog.csdn.net/zouxy09/article/details/49105265 </p> 
<p>标签传播（Label Propagation）算法详解</p> 
<p><a href="http://www.go60.top/view/89.html" rel="nofollow">http://www.go60.top/view/89.html</a></p> 
<hr> 
<p><strong>（1）为每个节点随机的指定一个自己特有的标签；</strong></p> 
<p><strong>（2）逐轮刷新所有节点的标签，直到所有节点的标签不再发生变化为止。对于每一轮刷新，节点标签的刷新规则如下：</strong></p> 
<p><strong>对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋值给当前节点。当个数最多的标签不唯一时，随机选择一个标签赋值给当前节点（选择标签值最大的那个）。</strong></p> 
<p><strong>算法的每个迭代过程中节点的标签更新是基于它的邻接节点的标签</strong></p> 
<p><strong>同步更新是指，节点x在t时刻的更新是基于邻接节点在t-1时刻的标签。异步更新是指，节点x在t时刻更新时，其部分邻接节点是t时刻更新的标签，还有部分的邻接节点是t-1时刻更新的标签。LPA算法在标签传播过程中采用的是同步更新，研究者们发现同步更新应用在<span style="color:#f33b45;">二分结构网络中，容易出现标签震荡的现象</span>。因此，之后的研究者大多采用<span style="color:#f33b45;">异步更新策略</span>来避免这种现象的出现</strong><br>  </p> 
<p>在网络中，每一个样本点只能属于一个社区，这样的问题称为<span style="color:#f33b45;">非重叠社区划分</span></p> 
<p>对于网络中的每一个节点，在初始阶段，Label Propagation 算法对每个节点初始化一个唯一的标签，在每次的迭代过程中，每个节点根据与其相连的节点所属的标签改变自己的标签，更改的原则是选择与其相连的节点中所属标签最多的社区标签为自己的社区标签，这便是标签传播的含义。随着社区标签不断传播，最终，连接紧密的节点将有共同的标签</p> 
<p>Label Propagation算法利用网络自身的结构指导标签的传播过程，在这个过程中无需优化任何函数。在算法开始前我们不必知道社区的个数，随着算法的迭代，在最终的过程中，算法将自己决定社区的个数</p> 
<p><img alt="æ ç­¾ä¼ æ­" class="has" src="https://images2.imgbox.com/3f/8f/v4040Igs_o.gif"></p> 
<p>在图 2 中所示的标签传播的过程中，对于 c 节点，在选择了与 a 节点一致的标签后，与 d 节点相邻的节点中，属于 a 社区的节点最多，因此 c 节点的标签也被设置成 a，这样的过程不断持续下去，直到所有可能聚集到一起的节点都具有了相同的社区标签，此时，图 2 中的所有节点的标签都变成了 a。在传播过程的最终，具有相同社区标签的节点被划到相同的社区中成为一个个独立的社区。</p> 
<p><span style="color:#f33b45;">同步更新</span>是指对于节点 x，在第 t 代时，根据其所有邻居节点在第 t-1 代时的社区标签，对其标签进行更新。即：</p> 
<p><br><img alt="" class="has" src="https://images2.imgbox.com/d3/73/sa6N6yMl_o.gif"></p> 
<p><br> 其中，Cx(t) 表示的是节点 x 在第 t 代时的社区标签。函数 f 表示的是取的参数节点中所有社区个数最大的社区。同步更新的方法存在一个问题，即对于一个二分或者近似二分的网络来说，这样的结构会导致标签的震荡，如图 3 所示。</p> 
<p><br><img alt="标签震荡" class="has" src="https://images2.imgbox.com/77/f4/BcunahIe_o.gif"><br> 图 3 标签震荡</p> 
<p><br> 在图 3 中，在第一步的更新中，若左侧节点的标签更改为 a，右侧节点的标签更改为 b，在第二步中，左侧的节点又会更改为 b，右侧的节点又会更改为 a，如此往复，<span style="color:#f33b45;">两边的标签会在社区标签 a 和 b 间不停地震荡</span>。<br><br> 对于<span style="color:#f33b45;">异步更新</span>方式，其更新公式为：</p> 
<p><br><img alt="" class="has" src="https://images2.imgbox.com/68/b7/57KWgqzV_o.gif"></p> 
<p><br> 其中，邻居节点 xi1 ，…，xim 的社区标签在第t代已经更新过，则使用其最新的社区标签。而邻居节点 xi(m+1) ，…，xik 在第 t 代时还没有更新，则对于这些邻居节点还是用其在第（t-1）代时的社区标签。</p> 
<p><span style="color:#f33b45;">上述的迭代终止条件修改为：对于每一个节点，在其所有的邻居节点所属的社区中，其所属的社区标签是最大的</span></p> 
<hr> 
<p> </p> 
<p>二、标签传播算法</p> 
<p>       标签传播算法（label propagation）的核心思想非常简单：相似的数据应该具有相同的label。LP算法包括两大步骤：1）构造相似矩阵；2）勇敢的传播吧。</p> 
<p>2.1、相似矩阵构建</p> 
<p>       LP算法是基于Graph的，因此我们需要先构建一个图。我们为所有的数据构建一个图，图的节点就是一个数据点，包含labeled和unlabeled的数据。节点i和节点j的边表示他们的相似度。这个图的构建方法有很多，这里我们假设这个图是全连接的，节点i和节点j的边权重为：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/0f/85/I5W5YmhK_o.png"></p> 
<p>       这里，α是超参。</p> 
<p>       还有个非常常用的图构建方法是knn图，也就是只保留每个节点的k近邻权重，其他的为0，也就是不存在边，因此是稀疏的相似矩阵。</p> 
<p>2.2、LP算法</p> 
<p>       标签传播算法非常简单：通过节点之间的边传播label。边的权重越大，表示两个节点越相似，那么label越容易传播过去。我们定义一个NxN的概率转移矩阵P：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/40/30/mkvXFk5v_o.png"></p> 
<p>       Pij表示从节点i转移到节点j的概率。假设有C个类和L个labeled样本，我们定义一个LxC的label矩阵YL，第i行表示第i个样本的标签指示向量，即如果第i个样本的类别是j，那么该行的第j个元素为1，其他为0。同样，我们也给U个unlabeled样本一个UxC的label矩阵YU。把他们合并，我们得到一个NxC的soft label矩阵F=[YL;YU]。soft label的意思是，我们保留样本i属于每个类别的概率，而不是互斥性的，这个样本以概率1只属于一个类。当然了，最后确定这个样本i的类别的时候，是取max也就是概率最大的那个类作为它的类别的。那F里面有个YU，它一开始是不知道的，那最开始的值是多少？无所谓，随便设置一个值就可以了。</p> 
<p>       千呼万唤始出来，简单的LP算法如下：</p> 
<p>       1）执行传播：F=PF</p> 
<p>       2）重置F中labeled样本的标签：FL=YL</p> 
<p>       3）重复步骤1）和2）直到F收敛。</p> 
<p>       步骤1）就是将矩阵P和矩阵F相乘，这一步，每个节点都将自己的label以P确定的概率传播给其他节点。如果两个节点越相似（在欧式空间中距离越近），那么对方的label就越容易被自己的label赋予，就是更容易拉帮结派。步骤2）非常关键，因为labeled数据的label是事先确定的，它不能被带跑，所以每次传播完，它都得回归它本来的label。随着labeled数据不断的将自己的label传播出去，最后的类边界会穿越高密度区域，而停留在低密度的间隔中。相当于每个不同类别的labeled样本划分了势力范围。</p> 
<p>2.3、变身的LP算法</p> 
<p>       我们知道，我们每次迭代都是计算一个soft label矩阵F=[YL;YU]，但是YL是已知的，计算它没有什么用，在步骤2）的时候，还得把它弄回来。我们关心的只是YU，那我们能不能只计算YU呢？Yes。我们将矩阵P做以下划分：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/46/79/EAhAimYW_o.png"></p> 
<p>       这时候，我们的算法就一个运算：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/e7/98/toXirZvs_o.png"></p> 
<p>       迭代上面这个步骤直到收敛就ok了，是不是很cool。可以看到FU不但取决于labeled数据的标签及其转移概率，还取决了unlabeled数据的当前label和转移概率。因此LP算法<span style="color:#f33b45;">能额外运用unlabeled数据的分布特点</span>。</p> 
<p>       这个算法的收敛性也非常容易证明，具体见参考文献[1]。实际上，它是可以收敛到一个凸解的：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/63/cf/6JQebsRp_o.png"></p> 
<p>       所以我们也可以直接这样求解，以获得最终的YU。但是在实际的应用过程中，由于矩阵求逆需要O(n3)的复杂度，所以如果unlabeled数据非常多，那么I – PUU矩阵的求逆将会非常耗时，因此这时候一般选择迭代算法来实现。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cbedcc9884edb891be1508931e5e8aba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端框架及项目面试一</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2de311a29686223f1d928456b3e5e745/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Winform实时刷新界面的正确姿势</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>