<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解类加载 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解类加载" />
<meta property="og:description" content="深入理解类加载 一:类文件到虚拟机二: 类加载过程2.1：装载2.2 验证2.2.1 文件格式验证2.2.2 元数据验证2.2.3 字节码验证2.2.4 符号引用验证 2.3 准备2.4 解析2.5 初始化2.6 使用2.7 卸载 一:类文件到虚拟机 💡:类加载就是将字节码文件加载到内存，并生成数据访问入口的机制，
类加载的最终目的是生成数据访问入口。
图示:
那么字节码文件是如何加载进内存的呢？这就要涉及类加载机制。
二: 类加载过程 所谓类加载本质上就是把Class文件加载进内存，并对数据进行校验，解析，初始化，最终生成Java虚拟机能够之间使用的数据，即java.lang.Class对象。
2.1：装载 装载:
通过一个类的全限定名获取一个类的二进制字节流。将这个二进制字节流所代表的静态储存结构转化为方法区运行时数据结构。在内存中生成代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口。 注意：JVM官方并为指定从class文件中获取一个类的二进制字节流，也就是说并为指定从哪里获取二进制字节流，这给开发者提供了开发的环境，我们一般有以下几种方式获取一个类的二进制字节流。
从本地系统中直接加载
典型场景：这个我就不废话了通过网络下载.class文件
典型场景：Web Applet，也就是我们的小程序应用从zip，jar等归档文件中加载.class文件
典型场景：后续演变为jar、war格式从专有数据库中提取.class文件
典型场景：JSP应用从专有数据库中提取.class文件，较为少见将Java源文件动态编译为.class文件，也就是运行时计算而成
典型场景：动态代理技术从加密文件中获取， 典型场景：典型的防Class文件被反编译的保护措施 2.2 验证 验证主要是为了确保Class文件中的字节流包含的信息完全符合当前虚拟机的要求，并且还要求我们的信息不会危害虚拟机自身的安全，导致虚拟机的崩溃。
而验证过程主要分为以下四种验证
2.2.1 文件格式验证 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。这阶段的验证是基于二进制字节流进行的，只有经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面验证都是基于方法区的存储结构进行的。
2.2.2 元数据验证 对类的元数据信息进行语义校验（其实就是对Java语法校验），保证不存在不符合Java语法规范的元数据信息。
2.2.3 字节码验证 进行数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。获取类的二进制字节流的阶段是我们JAVA程序员最关注的阶段，也是操控性最强的一个阶段。因为这个阶段我们可以对于我们的类加载器进行操作，比如我们想自定义类加载器进行操作用以完成加载又或者我们想通过JAVA Agent来完成我们的字节码增强操作。
2.2.4 符号引用验证 这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，可以看作是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。符号引用验证的目的是确保解析动作能正常执行。
2.3 准备 为类变量赋初值，这里的初值是类型的默认值，即零值。
注意:这里会为基础数据类型赋对应的初值，而引用数据类型为空值。final static 修饰的变量在编译的阶段就已经赋值了，在准备阶段会显示初始化。准备阶段不会为实例变量赋值，实例变量会随类一起被加载到堆区去。 2.4 解析 我们只需要知道在解析阶段注意发生的事就是将符号引用转换为直接引用。
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。
2.5 初始化 初始化阶段主要是执行类构造器()方法的过程。
在准备阶段类变量已经赋值过零值，在该阶段主要是按照程序员设置的计划为类变量赋值。
说的通俗些该过程是执行&lt; clinit &gt;()方法的过程，这个方法不需要我们程序员编写，会由编译器在编译的时候自动收集类变量的直接初始化和静态代码块中初始化的信息生成的类构造方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/971f9728ac68c5e99bf7ad116592a0ce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-29T17:45:50+08:00" />
<meta property="article:modified_time" content="2022-04-29T17:45:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解类加载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>深入理解类加载</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">一:类文件到虚拟机</a></li><li><a href="#__11" rel="nofollow">二: 类加载过程</a></li><li><ul><li><a href="#21_16" rel="nofollow">2.1：装载</a></li><li><a href="#22__38" rel="nofollow">2.2 验证</a></li><li><ul><li><a href="#221__43" rel="nofollow">2.2.1 文件格式验证</a></li><li><a href="#222__47" rel="nofollow">2.2.2 元数据验证</a></li><li><a href="#223__51" rel="nofollow">2.2.3 字节码验证</a></li><li><a href="#224__55" rel="nofollow">2.2.4 符号引用验证</a></li></ul> 
    </li><li><a href="#23__59" rel="nofollow">2.3 准备</a></li><li><a href="#24__65" rel="nofollow">2.4 解析</a></li><li><a href="#25__72" rel="nofollow">2.5 初始化</a></li><li><a href="#26__89" rel="nofollow">2.6 使用</a></li><li><a href="#27__102" rel="nofollow">2.7 卸载</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>一:类文件到虚拟机</h3> 
<blockquote> 
 <p><strong>💡:类加载就是将字节码文件加载到内存，并生成数据访问入口的机制，<br> 类加载的最终目的是生成数据访问入口。</strong></p> 
</blockquote> 
<p><code>图示:</code><br> <img src="https://images2.imgbox.com/48/11/HbJyocse_o.png" alt="在这里插入图片描述"><br> 那么字节码文件是如何加载进内存的呢？这就要涉及类加载机制。</p> 
<hr> 
<h3><a id="__11"></a>二: 类加载过程</h3> 
<blockquote> 
 <p><code>所谓类加载本质上就是把Class文件加载进内存，并对数据进行校验，解析，初始化，最终生成Java虚拟机能够之间使用的数据，即java.lang.Class对象。</code></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/cc/24/wlHYJC8g_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="21_16"></a>2.1：装载</h4> 
<blockquote> 
 <p>装载:</p> 
 <ol><li>通过一个类的全限定名获取一个类的二进制字节流。</li><li>将这个二进制字节流所代表的静态储存结构转化为方法区运行时数据结构。</li><li><code>在内存中生成代表这个类的java.lang.Class对象</code>，作为方法区中这个类的各种数据的访问入口。</li></ol> 
</blockquote> 
<p>注意：JVM官方并为指定从class文件中获取一个类的二进制字节流，也就是说并为指定从哪里获取二进制字节流，这给开发者提供了开发的环境，我们一般有以下几种方式获取一个类的二进制字节流。</p> 
<blockquote> 
 <ul><li>从本地系统中直接加载<br> 典型场景：这个我就不废话了</li><li>通过网络下载.class文件<br> 典型场景：Web Applet，也就是我们的小程序应用</li><li>从zip，jar等归档文件中加载.class文件<br> 典型场景：后续演变为jar、war格式</li><li>从专有数据库中提取.class文件<br> 典型场景：JSP应用从专有数据库中提取.class文件，较为少见</li><li>将Java源文件动态编译为.class文件，也就是运行时计算而成<br> 典型场景：动态代理技术</li><li>从加密文件中获取， 典型场景：典型的防Class文件被反编译的保护措施</li></ul> 
</blockquote> 
<hr> 
<h4><a id="22__38"></a>2.2 验证</h4> 
<blockquote> 
 <p><strong>验证主要是为了确保Class文件中的字节流包含的信息完全符合当前虚拟机的要求，并且还要求我们的信息不会危害虚拟机自身的安全，导致虚拟机的崩溃。</strong></p> 
</blockquote> 
<p>而验证过程主要分为以下四种验证</p> 
<h5><a id="221__43"></a>2.2.1 文件格式验证</h5> 
<blockquote> 
 <p><strong>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。这阶段的验证是基于二进制字节流进行的，只有经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面验证都是基于方法区的存储结构进行的。</strong></p> 
</blockquote> 
<h5><a id="222__47"></a>2.2.2 元数据验证</h5> 
<blockquote> 
 <p><strong>对类的元数据信息进行语义校验（其实就是对Java语法校验），保证不存在不符合Java语法规范的元数据信息。</strong></p> 
</blockquote> 
<h5><a id="223__51"></a>2.2.3 字节码验证</h5> 
<blockquote> 
 <p><strong>进行数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。获取类的二进制字节流的阶段是我们JAVA程序员最关注的阶段，也是操控性最强的一个阶段。因为这个阶段我们可以对于我们的类加载器进行操作，比如我们想自定义类加载器进行操作用以完成加载又或者我们想通过JAVA Agent来完成我们的字节码增强操作。</strong></p> 
</blockquote> 
<h5><a id="224__55"></a>2.2.4 符号引用验证</h5> 
<blockquote> 
 <p><strong>这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，可以看作是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。符号引用验证的目的是确保解析动作能正常执行。</strong></p> 
</blockquote> 
<hr> 
<h4><a id="23__59"></a>2.3 准备</h4> 
<blockquote> 
 <ol><li>为类变量赋初值，这里的初值是类型的默认值，即零值。<br> <code>注意:这里会为基础数据类型赋对应的初值，而引用数据类型为空值。</code></li><li>final static 修饰的变量在编译的阶段就已经赋值了，在准备阶段会显示初始化。</li><li>准备阶段不会为实例变量赋值，实例变量会随类一起被加载到堆区去。</li></ol> 
</blockquote> 
<hr> 
<h4><a id="24__65"></a>2.4 解析</h4> 
<p><strong>我们只需要知道在解析阶段注意发生的事就是将符号引用转换为直接引用。</strong></p> 
<blockquote> 
 <p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。<br> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</strong></p> 
</blockquote> 
<hr> 
<h4><a id="25__72"></a>2.5 初始化</h4> 
<p><strong>初始化阶段主要是执行类构造器()方法的过程。</strong></p> 
<p>在准备阶段类变量已经赋值过零值，在该阶段主要是按照程序员设置的计划为类变量赋值。<br> 说的通俗些该过程是执行&lt; clinit &gt;()方法的过程，这个方法不需要我们程序员编写，会由编译器在编译的时候自动收集类变量的直接初始化和静态代码块中初始化的信息生成的类构造方法。<br> <code>在这里我们可以看出来以下信息 1.静态代码块就是在初始化阶段执行的 2.给类变量初始化要么直接在定义的时候赋值，要么通过静态代码块赋值。</code></p> 
<blockquote> 
 <p><strong>类初始化的步骤:</strong><br> <strong>1. 如果这个类还没有被加载链接，则先执行加载链接操作</strong><br> <strong>2. 如果这个类的直接父类还没有初始化，则先初始化这个类的直接父类。</strong><br> <strong>3. 假如类中有初始化语句则依次执行这些初始化语句。</strong></p> 
</blockquote> 
<hr> 
<h4><a id="26__89"></a>2.6 使用</h4> 
<p><strong>并不是JVM启动就会将所有类初始化，在启动时只会讲JVM运行所需要的基础类库加载并初始化，其它的类都需要在主动引用时再初始化。</strong></p> 
<p><code>只有类的主动引用会引起类的初始化，类的主动引用有以下6种情况:</code></p> 
<blockquote> 
 <ul><li><strong>创建类的实例，也就是new的方式</strong></li><li><strong>访问某个类或接口的静态变量，或者对该静态变量赋值</strong></li><li><strong>调用类的静态方法</strong></li><li><strong>反射（如 Class.forName(“com.carl.Test”)</strong></li><li><strong>初始化某个类的子类，则其父类也会被初始化</strong></li><li><strong>Java虚拟机启动时被标明为启动类的类（JvmCaseApplication ），直接接使用 java.exe 命令来运行某个主类</strong></li></ul> 
</blockquote> 
<hr> 
<h4><a id="27__102"></a>2.7 卸载</h4> 
<p>类的卸载需要满足以下三种情况:</p> 
<blockquote> 
 <ul><li><strong>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</strong></li><li><strong>加载该类的ClassLoader已经被回收</strong>。</li><li><strong>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</strong></li></ul> 
</blockquote> 
<p>如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。但是一般情况下启动类加载器加载的类不会被卸载，而我们的其他两种基础类型的类加载器只有在极少数情况下才会被卸载。</p> 
<p><code>从上面可以看出来类一般加载到JVM运行时数据区中的方法区后就不会被回收，直到JVM虚拟机实例销毁时进行类卸载，除了极少数的情况下类才会被卸载。</code></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a9a27c76c508ddb1492fb3ee7606c2de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">聊聊微服务拆分原则之 AKF</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/569e80a05a4d759dd4b7bb2338ff99a1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Arduino安全和警报系统项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>