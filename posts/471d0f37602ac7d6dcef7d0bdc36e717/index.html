<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java面试题及答案整理（2023年11月最新版，持续更新） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java面试题及答案整理（2023年11月最新版，持续更新）" />
<meta property="og:description" content="2024年马上快到了，发现网上很多Java面试题都没有答案，所以花了很长时间搜集整理出来了这套Java面试题大全~
这套互联网 Java 工程师面试题包括了：MyBatis、ZK、Dubbo、EL、Redis、MySQL、并发编程、Java面试、Spring、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题
一、Java 基础
1. JDK 和 JRE 有什么区别？
JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。
2. == 和 equals 的区别是什么？
== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。
3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？
不对，两个对象的 hashCode()相同，equals()不一定 true。
代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/471d0f37602ac7d6dcef7d0bdc36e717/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-27T13:54:52+08:00" />
<meta property="article:modified_time" content="2023-11-27T13:54:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java面试题及答案整理（2023年11月最新版，持续更新）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>2024年马上快到了，发现网上很多Java面试题都没有答案，所以花了很长时间搜集整理出来了这套Java面试题大全~<br><strong>这套互联网 Java 工程师面试题包括了：MyBatis、ZK、Dubbo、EL、Redis、MySQL、并发编程、Java面试、Spring、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong><br><br><strong>一、Java 基础</strong><br><strong>1. JDK 和 JRE 有什么区别？</strong></p> 
<ul><li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li></ul> 
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。<br><strong>2. == 和 equals 的区别是什么？</strong><br> == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。<br><strong>3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</strong><br> 不对，两个对象的 hashCode()相同，equals()不一定 true。<br> 代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。<br><strong>4. final 在 java 中有什么作用？</strong></p> 
<ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul> 
<p><strong>5. java 中的 Math.round(-1.5) 等于多少？</strong><br> 等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。<br><strong>6. String 属于基础的数据类型吗？</strong><br> String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。<br><strong>7. java 中操作字符串都有哪些类？它们之间有什么区别？</strong><br> 操作字符串的类有：String、StringBuffer、StringBuilder。<br> String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。<br> StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。<br><strong>8. String str="i"与 String str=new String("i")一样吗？</strong><br> 不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。<br><strong>9. 如何将字符串反转？</strong><br> 使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br><strong>10. String 类的常用方法都有那些？</strong></p> 
<ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul> 
<p><strong>11. 抽象类必须要有抽象方法吗？</strong><br> 不需要，抽象类不一定非要有抽象方法。</p> 
<ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul> 
<p><strong>13. 抽象类能使用 final 修饰吗？</strong><br> 不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类<br><strong>14. 接口和抽象类有什么区别？</strong></p> 
<ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul> 
<p><strong>15. java 中 IO 流分为几种？</strong><br> 按功能来分：输入流（input）、输出流（output）。<br> 按类型来分：字节流和字符流。<br> 字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。<br><strong>16. BIO、NIO、AIO 有什么区别？</strong></p> 
<ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul> 
<p><strong>17. Files的常用方法都有哪些？</strong></p> 
<ul><li>Files.exists()：检测文件路径是否存在。</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory()：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件。</li></ul> 
<p><br><strong>二、容器</strong><br><strong>18. java 容器都有哪些？</strong><br> 常用容器的图录：</p> 
<p></p> 
<p class="img-center"><img alt="" height="521" src="https://images2.imgbox.com/2d/40/fv06sv1e_o.png" width="720"></p> 
<p>​</p> 
<p><strong>19. Collection 和 Collections 有什么区别？</strong></p> 
<ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul> 
<p><strong>20. List、Set、Map 之间的区别是什么？</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="326" src="https://images2.imgbox.com/a9/30/WU6pvwVw_o.png" width="720"></p> 
<p>​</p> 
<p><strong>21. HashMap 和 Hashtable 有什么区别？</strong></p> 
<ul><li>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</li><li>hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。</li><li>hashMap允许空键值，而hashTable不允许。</li></ul> 
<p><strong>22. 如何决定使用 HashMap 还是 TreeMap？</strong><br> 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。<br><strong>23. 说一下 HashMap 的实现原理？</strong><br> HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br> HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p> 
<ul><li>HashSet底层由HashMap实现</li><li>HashSet的值存放于HashMap的key上</li><li>HashMap的value统一为PRESENT</li></ul> 
<p><strong>25. ArrayList 和 LinkedList 的区别是什么？</strong><br> 最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。<br><strong>26. 如何实现数组和 List 之间的转换？</strong></p> 
<ul><li>List转换成为数组：调用ArrayList的toArray方法。</li><li>数组转换成为List：调用Arrays的asList方法。</li></ul> 
<p><strong>27. ArrayList 和 Vector 的区别是什么？</strong></p> 
<ul><li>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</li><li>ArrayList比Vector快，它因为有同步，不会过载。</li><li>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</li></ul> 
<p><strong>28. Array 和 ArrayList 有何区别？</strong></p> 
<ul><li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li><li>Array是指定大小的，而ArrayList大小是固定的。</li><li>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</li></ul> 
<p><strong>29. 在 Queue 中 poll()和 remove()有什么区别？</strong><br> poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。<br><strong>30. 哪些集合类是线程安全的？</strong></p> 
<ul><li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li><li>statck：堆栈类，先进后出。</li><li>hashtable：就比hashmap多了个线程安全。</li><li>enumeration：枚举，相当于迭代器。</li></ul> 
<p><strong>31. 迭代器 Iterator 是什么？</strong><br> 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。<br><strong>32. Iterator 怎么使用？有什么特点？</strong><br> (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。<br> (2) 使用next()获得序列中的下一个元素。<br> (3) 使用hasNext()检查序列中是否还有元素。<br> (4) 使用remove()将迭代器新返回的元素删除。<br> Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。<br><strong>33. Iterator 和 ListIterator 有什么区别？</strong></p> 
<ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ul> 
<p>三、<strong>多线程</strong><br><strong>35. 并行和并发有什么区别？</strong></p> 
<ul><li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</li></ul> 
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。<br><strong>36. 线程和进程的区别？</strong><br> 简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。<br><strong>37. 守护线程是什么？</strong><br> 守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。<br><strong>38. 创建线程有哪几种方式？</strong><br> ①. 继承Thread类创建线程类<br> ②. 通过Runnable接口创建线程类<br> ③. 通过Callable和Future创建线程<br><strong>39. 说一下 runnable 和 callable 有什么区别？</strong></p> 
<ul><li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li><li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li></ul> 
<p><strong>40. 线程有哪些状态？</strong><br> 线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。<br><strong>41. sleep() 和 wait() 有什么区别？</strong><br> sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。<br> wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。<br><strong>42. notify()和 notifyAll()有什么区别？</strong></p> 
<ul><li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ul> 
<p><strong>43. 线程的 run()和 start()有什么区别？</strong><br> start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br> run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。<br><strong>44. 创建线程池有哪几种方式？</strong><br> ①. newFixedThreadPool(int nThreads)<br> 创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。<br> ②. newCachedThreadPool()<br> 创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。<br> ③. newSingleThreadExecutor()<br> 这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。<br> ④. newScheduledThreadPool(int corePoolSize)<br> 创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br><strong>45. 线程池都有哪些状态？</strong><br> 线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。<br> 线程池各个状态切换框架图：</p> 
<p></p> 
<p class="img-center"><img alt="" height="406" src="https://images2.imgbox.com/bf/fa/Qry4U53K_o.png" width="1033"></p> 
<p>​</p> 
<p><strong>46. 线程池中 submit()和 execute()方法有什么区别？</strong></p> 
<ul><li>接收的参数不一样</li><li>submit有返回值，而execute没有</li><li>submit方便Exception处理</li></ul> 
<p><strong>47. 在 java 程序中怎么保证多线程的运行安全？</strong><br> 线程安全在三个方面体现：</p> 
<ul><li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li></ul> 
<p><strong>48. 多线程锁的升级原理是什么？</strong><br> 在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。<br> 锁升级的图示过程：</p> 
<p></p> 
<p class="img-center"><img alt="" height="399" src="https://images2.imgbox.com/b0/3e/7olVIj6i_o.png" width="720"></p> 
<p>​</p> 
<p><strong>49. 什么是死锁？</strong><br> 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。<br><strong>50. 怎么防止死锁？</strong><br> 死锁的四个必要条件：</p> 
<ul><li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li><li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li><li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li><li>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li></ul> 
<p><strong>51. ThreadLocal 是什么？有哪些使用场景？</strong><br> 线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。<br><strong>52.说一下 synchronized 底层实现原理？</strong><br> synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。<br> Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p> 
<ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ul> 
<p><strong>53. synchronized 和 volatile 的区别是什么？</strong></p> 
<ul><li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li></ul> 
<p><strong>54. synchronized 和 Lock 有什么区别？</strong></p> 
<ul><li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li><li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li><li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li><li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li><li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li><li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li></ul> 
<p><strong>55. synchronized 和 ReentrantLock 区别是什么？</strong><br> synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。</p> 
<ul><li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li><li>ReentrantLock可以获取各种锁的信息</li><li>ReentrantLock可以灵活地实现多路通知</li></ul> 
<p>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。<br><strong>56. 说一下 atomic 的原理？</strong><br> Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。<br><br> 四、反射<br><strong>57. 什么是反射？</strong><br> 反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力<br> Java反射：<br> 在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法<br> Java反射机制主要提供了以下功能：</p> 
<ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li></ul> 
<p><strong>58. 什么是 java 序列化？什么情况下需要序列化？</strong><br> 简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。<br><br> 什么情况下需要序列化：<br> a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br> b）当你想用套接字在网络上传送对象的时候；<br> c）当你想通过RMI传输对象的时候；<br><strong>59. 动态代理是什么？有哪些应用？</strong><br> 动态代理：<br> 当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。<br> 动态代理的应用：</p> 
<ul><li>Spring的AOP</li><li>加事务</li><li>加权限</li><li>加日志</li></ul> 
<p><strong>60. 怎么实现动态代理</strong><br> 首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。<br> 五、<strong>对象拷贝</strong><br> 六、<strong>Java Web</strong><br><strong>64. jsp 和 servlet 有什么区别？</strong><br><strong>65. jsp 有哪些内置对象？作用分别是什么？</strong><br><strong>66. 说一下 jsp 的 4 种作用域？</strong><br><strong>67. session 和 cookie 有什么区别？</strong><br><strong>68. 说一下 session 的工作原理？</strong><br><strong>69. 如果客户端禁止 cookie 能实现 session 还能用吗？</strong><br><strong>70. spring mvc 和 struts 的区别是什么？</strong><br><strong>......</strong><br><strong>Java面试题目录</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="754" src="https://images2.imgbox.com/50/69/vVXjYrml_o.png" width="456"></p> 
<p>MyBatis面试篇</p> 
<p></p> 
<p class="img-center"><img alt="" height="357" src="https://images2.imgbox.com/e3/03/dCiCUzGD_o.png" width="720"></p> 
<p>​</p> 
<p>Zookeeper面试篇</p> 
<p></p> 
<p class="img-center"><img alt="" height="342" src="https://images2.imgbox.com/65/dd/dv4lwgrn_o.png" width="720"></p> 
<p>​</p> 
<p><strong>Java基础篇（45道面试题）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="543" src="https://images2.imgbox.com/51/79/Y3jeexsT_o.png" width="720"></p> 
<p>​</p> 
<p><strong>字符串&amp;&amp;集合篇（74道）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="537" src="https://images2.imgbox.com/fd/6c/sUkEzfFc_o.png" width="720"></p> 
<p>​</p> 
<p><strong>并发编程篇（79道）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="560" src="https://images2.imgbox.com/69/a6/vcBJC5GA_o.png" width="720"></p> 
<p>​</p> 
<p><strong>JVM篇（56道）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="509" src="https://images2.imgbox.com/82/a9/wK6lU4tm_o.png" width="720"></p> 
<p>​</p> 
<p><strong>数据结构与算法（56道）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="502" src="https://images2.imgbox.com/31/96/FlhksWXA_o.png" width="720"></p> 
<p>​</p> 
<p><strong>MySQL篇（59道）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="523" src="https://images2.imgbox.com/04/05/CV8iPJNW_o.png" width="720"></p> 
<p>​</p> 
<p><br><strong>另外还附带了 52条SQL优化策略 以及一千行SQL命令</strong><br><strong>Redis篇（48道）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="431" src="https://images2.imgbox.com/66/24/5O8UBkAX_o.png" width="720"></p> 
<p>​</p> 
<p><strong>Mongo篇（83道）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="544" src="https://images2.imgbox.com/be/78/MyDmx7R9_o.png" width="720"></p> 
<p>​</p> 
<p><strong>Spring篇（58道）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="509" src="https://images2.imgbox.com/03/04/17acnC0d_o.png" width="720"></p> 
<p>​</p> 
<p><strong>MyBatis篇（47道）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="417" src="https://images2.imgbox.com/37/a7/a65YUpXF_o.png" width="720"></p> 
<p>​</p> 
<p><strong>SpringBoot篇（43道）</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="387" src="https://images2.imgbox.com/94/24/8TtreJn0_o.png" width="720"></p> 
<p>​</p> 
<p><strong>常用注解篇</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="373" src="https://images2.imgbox.com/7e/1c/2RKy5wcU_o.png" width="720"></p> 
<p>​</p> 
<blockquote>
  除此之外还有SpringCloud（31道）、Nginx（28道）、MQ（45道）、Dubbo（38道）、Kafka（12道）、ES（47道）、Linux（38道）等内容。。 
 <br> 
 <br> 这里就不一一展示了。就以截图主要内容的形式让大家参考啦 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6010e8b1ce4d4ae77923ecf8ce9e9a25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">本地Nginx服务搭建结合内网穿透实现多个Windows Web站点公网访问</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed292d037fa813bc6718edbd42dd930d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp自定义tabBar</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>