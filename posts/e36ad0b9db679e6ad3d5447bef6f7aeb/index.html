<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java刷题错题笔记-day06-集合 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java刷题错题笔记-day06-集合" />
<meta property="og:description" content="1.遍历List集合时删除元素可能会发生什么异常？ ConcurrentModificationException
在 Java 中，ArrayList 是一个使用 Fail-Fast 机制的例子。
ConcurrentHashMap是一个使用 Fail-Safe机制的例子。
Fail-Fast 机制，当在迭代过程中检测到集合被修改（添加、删除元素）时，立即抛出ConcurrentModificationException异常，以避免出现并发修改导致的不确定性行为。
在Java中，Fail-Fast 和 Fail-Safe 是两种不同的迭代器（Iterator）机制，它们主要涉及到在遍历集合时对集合的修改的处理方式。以下是它们的简要介绍：
Fail-Fast（快速失败）机制： 定义： 当在迭代过程中检测到集合被修改（添加、删除元素）时，立即抛出ConcurrentModificationException异常，以避免出现并发修改导致的不确定性行为。
实现： 基于集合（AbstractList）内部维护的一个&#34;modCount&#34;变量，该变量记录了集合被修改的次数。在每次迭代开始时，迭代器会自己维护一个&#34;expectedModCount&#34;变量，初始值取自集合的&#34;modCount&#34;变量，在迭代过程中，如果&#34;modCount&#34;和&#34;expectedModCount&#34;不一致，就抛出异常。
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt; { // ... //继承自AbstractList，写在这里便于理解 private int modCount = 0; // ... public Iterator&lt;E&gt; iterator() { return new Itr(); } //迭代器 private class Itr implements Iterator&lt;E&gt; { int cursor; // 当前元素的索引 int expectedModCount = modCount; // 迭代器创建时的集合修改次数 // ... public E next() { checkForComodification(); // 检查是否有并发修改 // 返回下一个元素 } final void checkForComodification() { if (modCount !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e36ad0b9db679e6ad3d5447bef6f7aeb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T19:32:25+08:00" />
<meta property="article:modified_time" content="2024-01-06T19:32:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java刷题错题笔记-day06-集合</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1List_0"></a>1.遍历List集合时删除元素可能会发生什么异常？</h3> 
<p><strong>ConcurrentModificationException</strong></p> 
<blockquote> 
 <p><em>在 Java 中，ArrayList 是一个使用 Fail-Fast 机制的例子。<br> ConcurrentHashMap是一个使用 Fail-Safe机制的例子。</em><br> <code>Fail-Fast </code>机制，当在迭代过程中检测到集合被修改（添加、删除元素）时，立即抛出ConcurrentModificationException异常，以避免出现并发修改导致的不确定性行为。</p> 
 <p>在Java中，<code>Fail-Fast </code> 和 <code>Fail-Safe </code> 是两种不同的迭代器（Iterator）机制，它们主要涉及到在遍历集合时对集合的修改的处理方式。以下是它们的简要介绍：</p> 
 <ol><li><strong>Fail-Fast（快速失败）机制：</strong></li></ol> 
 <ul><li> <p><strong>定义：</strong> 当在迭代过程中检测到集合被修改（添加、删除元素）时，立即抛出<code>ConcurrentModificationException</code>异常，以避免出现并发修改导致的不确定性行为。</p> </li><li> <p><strong>实现：</strong> 基于集合（<code>AbstractList</code>）内部维护的一个"modCount"变量，该变量记录了集合被修改的次数。在每次迭代开始时，迭代器会自己维护一个"expectedModCount"变量，初始值取自集合的"modCount"变量，在迭代过程中，如果"modCount"和"expectedModCount"不一致，就抛出异常。</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
	<span class="token comment">//继承自AbstractList，写在这里便于理解</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// ...</span>

    <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token comment">//迭代器</span>
    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> cursor<span class="token punctuation">;</span>       <span class="token comment">// 当前元素的索引</span>
        <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span> <span class="token comment">// 迭代器创建时的集合修改次数</span>

        <span class="token comment">// ...</span>

        <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查是否有并发修改</span>
            <span class="token comment">// 返回下一个元素</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// ...</span>
	<span class="token comment">//集合的add方法</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">// 添加元素的实现</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>应用：</strong> 主要用于单线程环境，以尽早发现并发修改问题，帮助开发者排除错误。</p> </li><li> <p><strong>错误示例</strong>：</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> myList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Item1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Item2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Item3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> iterator <span class="token operator">=</span> myList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">String</span> item <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2.抛出ConcurrentModificationException</span>
            myList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1.在迭代过程中删除元素</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> </li></ul> 
 <ol start="2"><li><strong>Fail-Safe（安全失败）机制：</strong></li></ol> 
 <ul><li> <p><strong>定义：</strong> 允许在迭代过程中对集合进行修改，但不会抛出异常。迭代器仅仅对原始集合的一个快照进行操作，而不会直接操作原始集合。</p> </li><li> <p><strong>实现：</strong> 通常使用迭代器的副本或者复制的集合来遍历，这样就不会受到原始集合的修改影响。</p> <pre><code class="prism language-java">   <span class="token comment">//ConcurrentHashMap源码较为繁琐。此处略过</span>
</code></pre> </li><li> <p><strong>应用：</strong> 主要用于多线程环境，以确保在遍历集合时不会被其他线程的修改所干扰。</p> </li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>总体来说，选择使用哪种机制取决于具体的应用场景。</strong></p> 
 <ol><li>在单线程环境下，fail-fast机制可以帮助尽早发现错误。</li><li>在多线程环境下，fail-safe机制可以提供更好的并发性能和稳定性。在选择时，需要根据应用的需求和性能要求进行权衡。</li></ol> 
</blockquote> 
<h3><a id="2ConcurrentHashMap_null_88"></a>2.ConcurrentHashMap 为什么不允许有null值？</h3> 
<p><strong>因无法区分空值和键不存在两种情况</strong></p> 
<blockquote> 
 <p>以下仅供参考<br> HashMap可以有null值，HashMap因为不需要保证多线程环境下的线程安全问题。所以只需要考虑单线程环境下能否区分空值和键不存在两种情况。显然，是可知的<br> 多线程环境下，ConcurrentHashMap无法区分空值和键不存在两种情况，即使当前线程key不为null，也可能在get时被其他线程修改为null</p> 
</blockquote> 
<h3><a id="3_94"></a>3.为什么不建议双括号"{<!-- -->{}}"初始化集合？</h3> 
<p><strong>有内存泄漏风险</strong><br> <strong>性能问题</strong></p> 
<blockquote> 
 <p>双括号初始化集合是指在集合初始化的时候使用两层花括号的形式，比如：</p> 
 <pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>
   <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"item1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"item2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
 <p>虽然这种语法可以实现在初始化时直接添加元素，但通常不被推荐使用，原因如下：</p> 
 <ol><li> <p><strong>匿名内部类的创建：</strong> 双括号初始化实际上创建了一个匿名内部类的实例。每次使用双括号初始化时，都会创建一个新的类，这可能会导致类数量增加，增加类加载和内存开销。</p> </li><li> <p><strong>继承关系：</strong> 双括号初始化实际上创建了一个匿名内部类，该类继承了指定集合类。这可能导致继承关系的混乱和不必要的复杂性。</p> </li><li> <p><strong>内存泄漏风险：</strong> 由于创建了匿名内部类，如果在初始化时引用了外部类的实例，那么可能会导致对外部类实例的引用，从而增加了内存泄漏的风险。</p> </li><li> <p><strong>性能问题：</strong> 双括号初始化的方式可能对性能造成一些微小的影响，尤其是在大型集合的情况下。</p> </li></ol> 
 <p>相对而言，使用正常的初始化方式更为清晰、简洁，并且没有上述的问题：</p> 
 <pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"item1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"item2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
 <p>如果你想在一行代码中初始化和添加元素，可以使用 <code>Arrays.asList</code>：</p> 
 <pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"item1"</span><span class="token punctuation">,</span> <span class="token string">"item2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
 <p>这种方式更为简洁，不引入额外的复杂性和潜在的问题。所以，一般来说，推荐使用正常的初始化方式来创建和初始化集合。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1ce28b79f38b0f72dfcbeafcfbb05726/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【提示学习论文五】Conditional Prompt Learning for Vision-Language Models论文原理及复现工作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ead34078150287cabf26721a3aaf15f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux Bonding 技术解析与配置指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>