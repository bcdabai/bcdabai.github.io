<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;11 - thread多线程编程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;11 - thread多线程编程" />
<meta property="og:description" content="1 线程创建与结束 C&#43;&#43;11 新标准中引入了四个头文件来支持多线程编程，他们分别是&lt;atomic&gt; ,&lt;thread&gt;,&lt;mutex&gt;,&lt;condition_variable&gt;和&lt;future&gt;。
&lt;atomic&gt;：该头文主要声明了两个类, std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。&lt;thread&gt;：该头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在该头文件中。&lt;mutex&gt;：该头文件主要声明了与互斥量(mutex)相关的类，包括 std::mutex 系列类，std::lock_guard, std::unique_lock, 以及其他的类型和函数。&lt;condition_variable&gt;：该头文件主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any。&lt;future&gt;：该头文件主要声明了 std::promise, std::package_task 两个 Provider 类，以及 std::future 和 std::shared_future 两个 Future 类，另外还有一些与之相关的类型和函数，std::async() 函数就声明在此头文件中。 #include &lt;iostream&gt; #include &lt;utility&gt; #include &lt;thread&gt; #include &lt;chrono&gt; #include &lt;functional&gt; #include &lt;atomic&gt; void f1(int n) { for (int i = 0; i &lt; 5; &#43;&#43;i) { std::cout &lt;&lt; &#34;Thread &#34; &lt;&lt; n &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/76dfeb9a84b3b35bf55fc9ecd785211f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-04T18:50:36+08:00" />
<meta property="article:modified_time" content="2021-12-04T18:50:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;11 - thread多线程编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1 线程创建与结束</h2> 
<p>C++11 新标准中引入了四个头文件来支持多线程编程，他们分别是&lt;atomic&gt; ,&lt;thread&gt;,&lt;mutex&gt;,&lt;condition_variable&gt;和&lt;future&gt;。</p> 
<ul><li>&lt;atomic&gt;：该头文主要声明了两个类, std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</li><li>&lt;thread&gt;：该头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在该头文件中。</li><li>&lt;mutex&gt;：该头文件主要声明了与互斥量(mutex)相关的类，包括 std::mutex 系列类，std::lock_guard, std::unique_lock, 以及其他的类型和函数。</li><li>&lt;condition_variable&gt;：该头文件主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any。</li><li>&lt;future&gt;：该头文件主要声明了 std::promise, std::package_task 两个 Provider 类，以及 std::future 和 std::shared_future 两个 Future 类，另外还有一些与之相关的类型和函数，std::async() 函数就声明在此头文件中。</li></ul> 
<pre><code>#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;atomic&gt;

void f1(int n)
{
  for (int i = 0; i &lt; 5; ++i) {
    std::cout &lt;&lt; "Thread " &lt;&lt; n &lt;&lt; " executing\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
  }
}

void f2(int&amp; n)
{
  std::cout &lt;&lt; "thread-id:" &lt;&lt; std::this_thread::get_id() &lt;&lt; "\n";
  for (int i = 0; i &lt; 5; ++i) {
    std::cout &lt;&lt; "Thread 2 executing:" &lt;&lt; n &lt;&lt; "\n";
    ++n;
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
  }
}

int main()
{
  int n = 0;
  std::thread t1; // t1 is not a thread t1 不是一个线程
  std::thread t2(f1, n + 1); // pass by value 传值
  std::thread t3(f2, std::ref(n)); // pass by reference  传引用

  std::this_thread::sleep_for(std::chrono::milliseconds(2000));
  std::cout &lt;&lt; "\nThread 4 create :\n";
  std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread 这时候t3将不是线程,t4接替t3继续运行f2
  t2.join();
  t4.join();
  std::cout &lt;&lt; "Final value of n is " &lt;&lt; n &lt;&lt; '\n';
}</code></pre> 
<h3>线程的创建方式：</h3> 
<ul><li>(1). 默认构造函数，创建一个空的 thread 执行对象。</li><li>(2). 初始化构造函数，创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。</li><li>(3). 拷贝构造函数(被禁用)，意味着 thread 不可被拷贝构造。</li><li>(4). move 构造函数，move 构造函数，调用成功之后 x 不代表任何 thread 执行对象。</li><li>注意：可被 joinable 的 thread 对象必须在他们销毁之前被主线程 join 或者将其设置为 detached.</li></ul> 
<p>std::thread定义一个线程对象，传入线程所需要的线程函数和参数，线程自动开启</p> 
<h3>线程的结束方式：</h3> 
<h4>join()</h4> 
<p>创建线程执行线程函数，调用该函数会阻塞当前线程，直到线程执行完join才返回；等待t线程结束，当前线程继续往下运行</p> 
<h4>detach()</h4> 
<p>detach调用之后，目标线程就成为了守护线程，驻留后台运行，与之关联的std::thread对象失去对目标线程的关联，无法再通过std::thread对象取得该线程的控制权，由操作系统负责回收资源；主线程结束，整个进程结束，所有子线程都自动结束了！</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std;

void threadHandle1(int time)
{
	//让子线程睡眠time秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout &lt;&lt; "hello thread1!" &lt;&lt; endl;
}
void threadHandle2(int time)
{
	//让子线程睡眠time秒ace this_thread是namespace 
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout &lt;&lt; "hello thread2!" &lt;&lt; endl;
}
int main()
{
	//创建了一个线程对象,传入一个线程函数(作为线程入口函数),
	//新线程就开始运行了，没有先后顺序，随着CPU的调度算法执行 
	std::thread t1(threadHandle1, 2);
	std::thread t2(threadHandle2, 3);

	//主线程(main)运行到这里，等待子线程结束，主线程才继续往下运行
	t1.join();
	t2.join();

	//把子线程设置为分离线程，子线程和主线程就毫无关系了
	//主线程结束的时候查看其他线程
	//但是这个子线程运行完还是没运行完都和这个主线程没关系了
	//这个子线程就从这个main分离出去了
	//运行程序时也看不到这个子线程的任何输出打印了
    //t1.detach();

	cout &lt;&lt; "main thread done!" &lt;&lt; endl;

	//主线程运行完成，查看如果当前进程还有未运行完成的子线程
	//进程就会异常终止
	return 0;
}
</code></pre> 
<h3>2 互斥锁</h3> 
<p>Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 &lt;mutex&gt; 头文件中，所以如果你需要使用 std::mutex，就必须包含 &lt;mutex&gt; 头文件。</p> 
<h4>&lt;mutex&gt; 头文件介绍</h4> 
<p>Mutex 系列类(四种)</p> 
<ul><li>std::mutex，最基本的 Mutex 类。</li><li>std::recursive_mutex，递归 Mutex 类。</li><li>std::time_mutex，定时 Mutex 类。</li><li>std::recursive_timed_mutex，定时递归 Mutex 类。</li></ul> 
<p>Lock 类（两种）</p> 
<ul><li>std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。</li><li>std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li></ul> 
<p>其他类型</p> 
<ul><li>std::once_flag</li><li>std::adopt_lock_t</li><li>std::defer_lock_t</li><li>std::try_to_lock_t</li></ul> 
<p>函数</p> 
<ul><li>std::try_lock，尝试同时对多个互斥量上锁。</li><li>std::lock，可以同时对多个互斥量上锁。</li><li>std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。</li></ul> 
<h3>std::mutex 介绍</h3> 
<p>下面以 std::mutex 为例介绍 C++11 中的互斥量用法。</p> 
<p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。</p> 
<p>std::mutex 的成员函数</p> 
<ul><li>构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。</li><li>lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li><li>unlock()， 解锁，释放对互斥量的所有权。</li><li>try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)</li></ul> 
<p>        为了保证lock()和unlock()对应使用，一般不直接使用mutex，而是和lock_guard、unique_lock一起使用；<br>  </p> 
<h3 id="stdlock_guard">std::lock_guard</h3> 
<p>std::lock_guard是<code>RAII模板类</code>的简单实现，功能简单。</p> 
<blockquote> 
 <p>1.std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。</p> 
</blockquote> 
<pre><code>		// CLASS TEMPLATE lock_guard
template&lt;class _Mutex&gt;
	class lock_guard
	{	// class with destructor that unlocks a mutex
public:
	using mutex_type = _Mutex;

	explicit lock_guard(_Mutex&amp; _Mtx)
		: _MyMutex(_Mtx)
		{	// construct and lock
		_MyMutex.lock();
		}

	lock_guard(_Mutex&amp; _Mtx, adopt_lock_t)
		: _MyMutex(_Mtx)
		{	// construct but don't lock
		}

	~lock_guard() noexcept
		{	// unlock
		_MyMutex.unlock();
		}

	lock_guard(const lock_guard&amp;) = delete;
	lock_guard&amp; operator=(const lock_guard&amp;) = delete;
private:
	_Mutex&amp; _MyMutex;
	};</code></pre> 
<p>从lock_guard源码可以看出，它在构造时进行上锁，在出作用域执行析构函数释放锁；同时不允许拷贝构造和赋值运算符；比较简单，不能用在函数参数传递或者返回过程中，因为它的拷贝构造和赋值运算符被禁用了；只能用在简单的临界区代码的互斥操作</p> 
<h3 id="stdunique_lock">std::unique_lock</h3> 
<blockquote> 
 <p>类 unique_lock 是通用互斥包装器，允许<code>延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用</code>。<br> unique_lock比lock_guard使用更加灵活，功能更加强大。<br> 使用unique_lock需要付出更多的时间、性能成本。</p> 
</blockquote> 
<pre><code>template&lt;class _Mutex&gt;
	class unique_lock
	{	// whizzy class with destructor that unlocks mutex
public:
	typedef _Mutex mutex_type;

	// CONSTRUCT, ASSIGN, AND DESTROY
	unique_lock() noexcept
		: _Pmtx(nullptr), _Owns(false)
		{	// default construct
		}

	explicit unique_lock(_Mutex&amp; _Mtx)
		: _Pmtx(_STD addressof(_Mtx)), _Owns(false)
		{	// construct and lock
		_Pmtx-&gt;lock();
		_Owns = true;
		}

	unique_lock(_Mutex&amp; _Mtx, adopt_lock_t)
		: _Pmtx(_STD addressof(_Mtx)), _Owns(true)
		{	// construct and assume already locked
		}

	unique_lock(_Mutex&amp; _Mtx, defer_lock_t) noexcept
		: _Pmtx(_STD addressof(_Mtx)), _Owns(false)
		{	// construct but don't lock
		}

	unique_lock(_Mutex&amp; _Mtx, try_to_lock_t)
		: _Pmtx(_STD addressof(_Mtx)), _Owns(_Pmtx-&gt;try_lock())
		{	// construct and try to lock
		}

	template&lt;class _Rep,
		class _Period&gt;
		unique_lock(_Mutex&amp; _Mtx,
			const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time)
		: _Pmtx(_STD addressof(_Mtx)), _Owns(_Pmtx-&gt;try_lock_for(_Rel_time))
		{	// construct and lock with timeout
		}

	template&lt;class _Clock,
		class _Duration&gt;
		unique_lock(_Mutex&amp; _Mtx,
			const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)
		: _Pmtx(_STD addressof(_Mtx)), _Owns(_Pmtx-&gt;try_lock_until(_Abs_time))
		{	// construct and lock with timeout
		}

	unique_lock(_Mutex&amp; _Mtx, const xtime *_Abs_time)
		: _Pmtx(_STD addressof(_Mtx)), _Owns(false)
		{	// try to lock until _Abs_time
		_Owns = _Pmtx-&gt;try_lock_until(_Abs_time);
		}

	unique_lock(unique_lock&amp;&amp; _Other) noexcept
		: _Pmtx(_Other._Pmtx), _Owns(_Other._Owns)
		{	// destructive copy
		_Other._Pmtx = nullptr;
		_Other._Owns = false;
		}

	unique_lock&amp; operator=(unique_lock&amp;&amp; _Other)
		{	// destructive copy
		if (this != _STD addressof(_Other))
			{	// different, move contents
			if (_Owns)
				_Pmtx-&gt;unlock();
			_Pmtx = _Other._Pmtx;
			_Owns = _Other._Owns;
			_Other._Pmtx = nullptr;
			_Other._Owns = false;
			}
		return (*this);
		}

	~unique_lock() noexcept
		{	// clean up
		if (_Owns)
			_Pmtx-&gt;unlock();
		}

	unique_lock(const unique_lock&amp;) = delete;
	unique_lock&amp; operator=(const unique_lock&amp;) = delete;

	void lock()
		{	// lock the mutex
		_Validate();
		_Pmtx-&gt;lock();
		_Owns = true;
		}

	_NODISCARD bool try_lock()
		{	// try to lock the mutex
		_Validate();
		_Owns = _Pmtx-&gt;try_lock();
		return (_Owns);
		}

	template&lt;class _Rep,
		class _Period&gt;
		_NODISCARD bool try_lock_for(const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time)
		{	// try to lock mutex for _Rel_time
		_Validate();
		_Owns = _Pmtx-&gt;try_lock_for(_Rel_time);
		return (_Owns);
		}

	template&lt;class _Clock,
		class _Duration&gt;
		_NODISCARD bool try_lock_until(const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)
		{	// try to lock mutex until _Abs_time
		_Validate();
		_Owns = _Pmtx-&gt;try_lock_until(_Abs_time);
		return (_Owns);
		}

	_NODISCARD bool try_lock_until(const xtime *_Abs_time)
		{	// try to lock the mutex until _Abs_time
		_Validate();
		_Owns = _Pmtx-&gt;try_lock_until(_Abs_time);
		return (_Owns);
		}

	void unlock()
		{	// try to unlock the mutex
		if (!_Pmtx || !_Owns)
			_THROW(system_error(
				_STD make_error_code(errc::operation_not_permitted)));

		_Pmtx-&gt;unlock();
		_Owns = false;
		}

	void swap(unique_lock&amp; _Other) noexcept
		{	// swap with _Other
		_STD swap(_Pmtx, _Other._Pmtx);
		_STD swap(_Owns, _Other._Owns);
		}

	_Mutex *release() noexcept
		{	// disconnect
		_Mutex *_Res = _Pmtx;
		_Pmtx = nullptr;
		_Owns = false;
		return (_Res);
		}

	_NODISCARD bool owns_lock() const noexcept
		{	// return true if this object owns the lock
		return (_Owns);
		}

	explicit operator bool() const noexcept
		{	// return true if this object owns the lock
		return (_Owns);
		}

	_NODISCARD _Mutex *mutex() const noexcept
		{	// return pointer to managed mutex
		return (_Pmtx);
		}

private:
	_Mutex *_Pmtx;
	bool _Owns;

	void _Validate() const
		{	// check if the mutex can be locked
		if (!_Pmtx)
			_THROW(system_error(
				_STD make_error_code(errc::operation_not_permitted)));

		if (_Owns)
			_THROW(system_error(
				_STD make_error_code(errc::resource_deadlock_would_occur)));
		}
	};
</code></pre> 
<p>其中，有_Mutex *_Pmtx; 指向一把锁的指针；不允许使用左值拷贝构造和赋值，但是可以使用右值拷贝构造和赋值，可以在函数调用过程中使用。因此可以和条件变量一起使用:cv.wait(lock);//可以作为函数参数传入；</p> 
<h4>示例：</h4> 
<p>在多线程环境中运行的代码段，需要考虑是否存在竞态条件，如果存在竞态条件，我们就说该代码段不是线程安全的，不能直接运行在多线程环境当中，对于这样的代码段，我们经常称之为临界区资源，对于临界区资源，多线程环境下需要保证它以原子操作执行，要保证临界区的原子操作，就需要用到线程间的互斥操作-锁机制，thread类库还提供了更轻量级的基于CAS操作的原子操作类。</p> 
<p>无锁时：</p> 
<pre><code>​

#include &lt;iostream&gt;
#include &lt;atomic&gt;//C++11线程库提供的原子类
#include &lt;thread&gt;//C++线程类库的头文件
#include &lt;vector&gt;


int count = 0;

//线程函数
void sumTask()
{
  
  //每个线程给count加10次
  for (int i = 0; i &lt; 10; ++i)
  {
    count++;
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
  }
}

int main()
{
  //创建10个线程放在容器当中
  std::vector&lt;std::thread&gt; vec;
  for (int i = 0; i &lt; 10; ++i)
  {
    vec.push_back(std::thread(sumTask));
  }

  //等待线程执行完成
  for (unsigned int i = 0; i &lt; vec.size(); ++i)
  {
    vec[i].join();
  }

  //所有子线程运行结束
  std::cout &lt;&lt; "count : " &lt;&lt; count &lt;&lt; std::endl;

  return 0;
}


​</code></pre> 
<p>多线程同时对count进行操作，并不能保证同时只有一个线程对count执行++操作，最后的的结果不一定是100；</p> 
<p></p> 
<p>使用lock_guard:</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;atomic&gt;//C++11线程库提供的原子类
#include &lt;thread&gt;//C++线程类库的头文件
#include &lt;mutex&gt;
#include &lt;vector&gt;


int count = 0;
std::mutex mutex;

//线程函数
void sumTask()
{
  
  //每个线程给count加10次
  for (int i = 0; i &lt; 10; ++i)
  {
    {
      std::lock_guard&lt;std::mutex&gt; lock(mutex);
      count++;
    }
;
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
  }
}

int main()
{
  //创建10个线程放在容器当中
  std::vector&lt;std::thread&gt; vec;
  for (int i = 0; i &lt; 10; ++i)
  {
    vec.push_back(std::thread(sumTask));
  }

  //等待线程执行完成
  for (unsigned int i = 0; i &lt; vec.size(); ++i)
  {
    vec[i].join();
  }

  //所有子线程运行结束，count的结果每次运行应该都是10000
  std::cout &lt;&lt; "count : " &lt;&lt; count &lt;&lt; std::endl;

  return 0;
}
</code></pre> 
<p>对count++ 操作上锁，保证一次只有一个线程能对其操作，结果是100</p> 
<h2>原子变量</h2> 
<p>上面的保证原子操作需要在多线程环境下添加互斥操作，但是mutex互斥锁毕竟比较重，对于系统消耗有些大，C++11的thread类库提供了针对简单类型的原子操作类，如std::atomic_int，atomic_long，atomic_bool等，它们值的增减都是基于CAS操作的，既保证了线程安全，效率还非常高。</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;atomic&gt;//C++11线程库提供的原子类
#include &lt;thread&gt;//C++线程类库的头文件
#include &lt;vector&gt;

//原子整型，CAS操作保证给count自增自减的原子操作
std::atomic_int count = 0;

//线程函数
void sumTask()
{
  //每个线程给count加10次
  for (int i = 0; i &lt; 10; ++i)
  {
    count++;
  }
}

int main()
{
  //创建10个线程放在容器当中
  std::vector&lt;std::thread&gt; vec;
  for (int i = 0; i &lt; 10; ++i)
  {
    vec.push_back(std::thread(sumTask));
  }

  //等待线程执行完成
  for (unsigned int i = 0; i &lt; vec.size(); ++i)
  {
    vec[i].join();
  }

  //所有子线程运行结束，count的结果每次运行应该都是10000
  std::cout &lt;&lt; "count : " &lt;&lt; count &lt;&lt; std::endl;

  return 0;
}
</code></pre> 
<h2>线程同步通信</h2> 
<p>        多线程在运行过程中，各个线程都是随着OS的调度算法，占用CPU时间片来执行指令做事情，每个线程的运行完全没有顺序可言。但是在某些应用场景下，一个线程需要等待另外一个线程的运行结果，才能继续往下执行，这就需要涉及线程之间的同步通信机制。</p> 
<p>        线程间同步通信最典型的例子就是生产者-消费者模型，生产者线程生产出产品以后，会通知消费者线程去消费产品；如果消费者线程去消费产品，发现还没有产品生产出来，它需要通知生产者线程赶快生产产品，等生产者线程生产出产品以后，消费者线程才能继续往下执行。</p> 
<p>C++11 线程库提供的条件变量condition_variable，就是Linux平台下的Condition Variable机制，用于解决线程间的同步通信问题，下面通过代码演示一个生产者-消费者线程模型：</p> 
<p>        </p> 
<pre><code>#include &lt;iostream&gt;           //std::cout
#include &lt;thread&gt;             //std::thread
#include &lt;mutex&gt;              //std::mutex, std::unique_lock
#include &lt;condition_variable&gt; //std::condition_variable
#include &lt;vector&gt;

//定义互斥锁(条件变量需要和互斥锁一起使用)
std::mutex mtx;
//定义条件变量(用来做线程间的同步通信)
std::condition_variable cv;
//定义vector容器，作为生产者和消费者共享的容器
std::vector&lt;int&gt; vec;

//生产者线程函数
void producer()
{
  //生产者每生产一个，就通知消费者消费一个
  for (int i = 1; i &lt;= 10; ++i)
  {
    //获取mtx互斥锁资源
    std::unique_lock&lt;std::mutex&gt; lock(mtx);

    //如果容器不为空，代表还有产品未消费，等待消费者线程消费完，再生产
    while (!vec.empty())
    {
      //判断容器不为空，进入等待条件变量的状态，释放mtx锁，
      //让消费者线程抢到锁能够去消费产品
      cv.wait(lock);
    }
    vec.push_back(i); // 表示生产者生产的产品序号i
    std::cout &lt;&lt; "producer生产产品:" &lt;&lt; i &lt;&lt; std::endl;

    /*
    生产者线程生产完产品，通知等待在cv条件变量上的消费者线程，
    可以开始消费产品了，然后释放锁mtx
    */
    cv.notify_all();

    //生产一个产品，睡眠100ms
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
  }
}
//消费者线程函数
void consumer()
{
  //消费者每消费一个，就通知生产者生产一个
  for (int i = 1; i &lt;= 10; ++i)
  {
    //获取mtx互斥锁资源
    std::unique_lock&lt;std::mutex&gt; lock(mtx);

    //如果容器为空，代表还有没有产品可消费，等待生产者生产，再消费
    while (vec.empty())
    {
      //判断容器为空，进入等待条件变量的状态，释放mtx锁，
      //让生产者线程抢到锁能够去生产产品
      cv.wait(lock);
    }
    int data = vec.back(); // 表示消费者消费的产品序号i
    vec.pop_back();
    std::cout &lt;&lt; "consumer消费产品:" &lt;&lt; data &lt;&lt; std::endl;

    /*
    消费者消费完产品，通知等待在cv条件变量上的生产者线程，
    可以开始生产产品了，然后释放锁mtx
    */
    cv.notify_all();

    //消费一个产品，睡眠100ms
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
  }
}
int main()
{
  //创建生产者和消费者线程
  std::thread t1(producer);
  std::thread t2(consumer);

  //main主线程等待所有子线程执行完
  t1.join();
  t2.join();

  return 0;
}
</code></pre> 
<p></p> 
<h2>线程死锁</h2> 
<p></p> 
<p><strong>死锁概述</strong></p> 
<p><br>         线程死锁是指两个或两个以上的线程互相持有对方所需要的资源，由于synchronized的特性，一个线程持有一个资源，或者说获得一个锁，在该线程释放这个锁之前，其它线程是获取不到这个锁的，而且会一直死等下去，因此这便造成了死锁。</p> 
<p><strong>死锁产生的条件</strong></p> 
<ul><li>互斥条件：一个资源，或者说一个锁只能被一个线程所占用，当一个线程首先获取到这个锁之后，在该线程释放这个锁之前，其它线程均是无法获取到这个锁的。</li><li>占有且等待：一个线程已经获取到一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁。</li><li>不可剥夺条件：任何一个线程都无法强制获取别的线程已经占有的锁</li><li>循环等待条件：线程A拿着线程B的锁，线程B拿着线程A的锁。</li></ul> 
<p><strong>示例：</strong><br>         当一个程序的多个线程获取多个互斥锁资源的时候，就有可能发生死锁问题，比如线程A先获取了锁1，线程B获取了锁2，进而线程A还需要获取锁2才能继续执行，但是由于锁2被线程B持有还没有释放，线程A为了等待锁2资源就阻塞了；线程B这时候需要获取锁1才能往下执行，但是由于锁1被线程A持有，导致A也进入阻塞。</p> 
<p>线程A和线程B都在等待对方释放锁资源，但是它们又不肯释放原来的锁资源，导致线程A和B一直互相等待，进程死锁了。下面代码示例演示这个问题：<br>  </p> 
<pre><code>#include &lt;iostream&gt;           //std::cout
#include &lt;thread&gt;             //std::thread
#include &lt;mutex&gt;              //std::mutex, std::unique_lock
#include &lt;condition_variable&gt; //std::condition_variable
#include &lt;vector&gt;

//锁资源1
std::mutex mtx1;
//锁资源2
std::mutex mtx2;

//线程A的函数
void taskA()
{
  //保证线程A先获取锁1
  std::lock_guard&lt;std::mutex&gt; lockA(mtx1);
  std::cout &lt;&lt; "线程A获取锁1" &lt;&lt; std::endl;

  //线程A睡眠2s再获取锁2，保证锁2先被线程B获取，模拟死锁问题的发生
  std::this_thread::sleep_for(std::chrono::seconds(2));

  //线程A先获取锁2
  std::lock_guard&lt;std::mutex&gt; lockB(mtx2);
  std::cout &lt;&lt; "线程A获取锁2" &lt;&lt; std::endl;

  std::cout &lt;&lt; "线程A释放所有锁资源，结束运行！" &lt;&lt; std::endl;
}

//线程B的函数
void taskB()
{
  //线程B先睡眠1s保证线程A先获取锁1
  std::this_thread::sleep_for(std::chrono::seconds(1));
  std::lock_guard&lt;std::mutex&gt; lockB(mtx2);
  std::cout &lt;&lt; "线程B获取锁2" &lt;&lt; std::endl;

  //线程B尝试获取锁1
  std::lock_guard&lt;std::mutex&gt; lockA(mtx1);
  std::cout &lt;&lt; "线程B获取锁1" &lt;&lt; std::endl;

  std::cout &lt;&lt; "线程B释放所有锁资源，结束运行！" &lt;&lt; std::endl;
}
int main()
{
  //创建生产者和消费者线程
  std::thread t1(taskA);
  std::thread t2(taskB);

  //main主线程等待所有子线程执行完
  t1.join();
  t2.join();

  return 0;
}
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/d7/d5/MbHQqcCt_o.png" width="345"></p> 
<p>可以看到，线程A获取锁1、线程B获取锁2以后，进程就不往下继续执行了，一直等待在这里，如果这是我们碰到的一个问题场景，<strong>我们如何判断出这是由于线程间死锁引起的呢？</strong></p> 
<p></p> 
<p>打开process Explorer.找到该进程，查看线程状态，发现线程的cpu利用率为0,那么应该不是死循环，应该是死锁了： </p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/be/51/Dkht6FRK_o.png" width="819"> 点击vs 的全部中断：查看每一个线程的函数执行的位置</p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/ad/c3/kGUPaOEJ_o.png" width="937"></p> 
<p> 发现当前线程正在申请锁的位置,判断出应该是锁了。</p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/64/0e/o6NbDqcy_o.png" width="1081"></p> 
<p> 同时主线程走了等待子线程结束;</p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/5f/df/1FskSTJB_o.png" width="1118"></p> 
<p></p> 
<p>那如果是死循环的情况呢？，如将线程2加一个死循环：</p> 
<pre><code>#include &lt;iostream&gt;           //std::cout
#include &lt;thread&gt;             //std::thread
#include &lt;mutex&gt;              //std::mutex, std::unique_lock
#include &lt;condition_variable&gt; //std::condition_variable
#include &lt;vector&gt;

//锁资源1
std::mutex mtx1;
//锁资源2
std::mutex mtx2;

//线程A的函数
void taskA()
{
  //保证线程A先获取锁1
  std::lock_guard&lt;std::mutex&gt; lockA(mtx1);
  std::cout &lt;&lt; "线程A获取锁1" &lt;&lt; std::endl;

  //线程A睡眠2s再获取锁2，保证锁2先被线程B获取，模拟死锁问题的发生
  std::this_thread::sleep_for(std::chrono::seconds(2));

  //线程A先获取锁2
  std::lock_guard&lt;std::mutex&gt; lockB(mtx2);
  std::cout &lt;&lt; "线程A获取锁2" &lt;&lt; std::endl;

  std::cout &lt;&lt; "线程A释放所有锁资源，结束运行！" &lt;&lt; std::endl;
}

//线程B的函数
void taskB()
{
  while (true)
  {

  }
}
int main()
{
  //创建生产者和消费者线程
  std::thread t1(taskA);
  std::thread t2(taskB);

  //main主线程等待所有子线程执行完
  t1.join();
  t2.join();

  return 0;
}
</code></pre> 
<p><img alt="" height="531" src="https://images2.imgbox.com/23/6c/FC42AdUj_o.png" width="1200"> </p> 
<p> 这时候工作线程占满了CPU,我的电脑是8核，因此占满一个cpu是12.5%</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c28fb1465f7757814df4c215a37f59f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity ScriptableObject 序列化遇到一些问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/06b1f450998c461a9b9826f1c5e2ba57/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vscode的c/c&#43;&#43;环境配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>