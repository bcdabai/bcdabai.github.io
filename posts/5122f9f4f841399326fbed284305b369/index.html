<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>matlab牛顿法_数值优化（Numerical Optimization）(3)-牛顿法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="matlab牛顿法_数值优化（Numerical Optimization）(3)-牛顿法" />
<meta property="og:description" content="3基本牛顿法
牛顿法的基本思想是用迭代点的梯度信息和二阶导数对目标函数进行二次函数逼近，然后把二次函数的极小值作为新的迭代点，并不断重复这一过程，直到求出极小点。
假设函数 的二阶导数 连续，函数 在 处的二阶泰勒展开为 其中 ，求函数的 驻点那就是求导并令 导数为零，即 如果二阶导数非奇异，可以得到下一个迭代点为（上式求出来的 就是 ） 如果二阶导数奇异，那么可以求解下面线性方程确定搜索方向 后计算下一个迭代点 。 基本牛顿法可以归结为以下四步
初值设置：初始点以及终止准则检验是否满足终止准则 计算二阶导数，确定搜索方向 : 计算下一个迭代点 ，回到步骤2 注意：牛顿法的好处在于收敛速度快，缺点在于计算二阶导数的计算量大以及求解线性方程组确定搜索方向可能是病态的。
修正牛顿法 最基础的改进是在基本牛顿法中加入线搜索方法求得步长 且令 ，这种方法称为 阻尼牛顿法。 牛顿法面临的一个主要困难是二阶导数不正定，在这一情况下，下降方向就很难获得。Goldfeld 修正法在二阶导数不正定时对其进行修正
其中 为修正阵。 带有线搜索的修正牛顿法可以表述为
输入：初始点，终止阈值
循环：
找到修正阵 使得 正定 求解线性方程组 得到下降方向 线搜法计算步长 更新迭代点 可以看到修正阵 的选择对算法起关键作用，针对这个有不少修正的方案，这里简要介绍一下 基于 Cholesky 分解法的思想，这种算法在对二阶导数矩阵分解过程中调整对角元使得修正后的二阶导数充分正定，也就是说在矩阵的 分解中， 的对角元不小于某一个给定常数；并且如果原矩阵正定，那么修正后的二阶导数矩阵也是就原矩阵。 Ps: 信赖域牛顿法在上一篇博文仿真案例用的就是了，感兴趣的可以去看一下。
养生的控制人：数值优化（Numerical Optimization）(2)-信赖域法​zhuanlan.zhihu.com 拟牛顿法 拟牛顿法的思想是模拟牛顿方向的生成路径，利用相邻两个点的位移和一阶导数信息构造与二阶导数阵相似的正定矩阵。所需的计算量比牛顿法少，收敛速度达到超线性。
假设函数 二次连续可微，在 的二次近似为 对上式两边求导可得
如果令 可得 等价于
假设二阶导数矩阵的逆矩阵 近似为 满足 上式也称为拟牛顿方程，可以看到 和迭代点的 位移 和 梯度差 决定。 DFP 下面介绍一下第一个拟牛顿法，DFP算法，算法中假设 由 修正得到，且修正矩阵为秩二矩阵 根据假设 以及拟牛顿方程可以得到 其中 为位移， 为梯度差。这里 的选择并不是唯一的，可以取 ，则 因此有" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5122f9f4f841399326fbed284305b369/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-30T02:52:45+08:00" />
<meta property="article:modified_time" content="2020-11-30T02:52:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">matlab牛顿法_数值优化（Numerical Optimization）(3)-牛顿法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/22/80/42TyFUQp_o.png" alt="7ce630618a66cef7d1857ea1970141b3.png"> 
 </div> 
 <p>3基本牛顿法</p> 
 <p>牛顿法的基本思想是用迭代点的<b>梯度信息</b>和<b>二阶导数</b>对目标函数进行<b>二次函数</b>逼近，然后把二次函数的极小值作为新的迭代点，并不断重复这一过程，直到求出极小点。</p> 
 <p>假设函数 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 的二阶导数 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 连续，函数 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 在 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 处的二阶泰勒展开为 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>其中 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> ，求函数的 
 </div> 
 <b>驻点</b>那就是求导并令 
 <b>导数为零</b>，即 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>如果二阶导数非奇异，可以得到下一个迭代点为（上式求出来的 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 就是 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> ） 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>如果二阶导数奇异，那么可以求解下面线性方程确定搜索方向 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>后计算下一个迭代点 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 。 
 </div> 
 <p>基本牛顿法可以归结为以下四步</p> 
 <ol><li>初值设置：初始点以及终止准则</li><li>检验是否满足终止准则</li><li> 计算二阶导数，确定搜索方向 
   <div style="text-align:center;"> 
    <img src="" alt=""> : 
   </div> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 计算下一个迭代点 
   <div style="text-align:center;"> 
    <img src="" alt=""> ，回到步骤2 
   </div></li></ol> 
 <p>注意：牛顿法的好处在于收敛速度快，缺点在于计算二阶导数的计算量大以及求解线性方程组确定搜索方向可能是病态的。</p> 
 <h3>修正牛顿法</h3> 
 <p>最基础的改进是在基本牛顿法中<b>加入线搜索方法求得步长</b> </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 且令 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> ，这种方法称为 
 </div> 
 <b>阻尼牛顿法</b>。 
 <p>牛顿法面临的一个主要困难是二阶导数不正定，在这一情况下，下降方向就很难获得。<b>Goldfeld 修正法</b>在二阶导数不正定时对其进行修正</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>其中 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 为修正阵。 
 </div> 
 <p>带有线搜索的修正牛顿法可以表述为</p> 
 <p>输入：初始点，终止阈值</p> 
 <p>循环：</p> 
 <ul><li> 找到修正阵 
   <div style="text-align:center;"> 
    <img src="" alt=""> 使得 
   </div> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 正定 
   </div></li><li> 求解线性方程组 
   <div style="text-align:center;"> 
    <img src="" alt=""> 得到下降方向 
   </div> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 线搜法计算步长 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 更新迭代点 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li></ul> 
 <p>可以看到修正阵 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 的选择对算法起关键作用，针对这个有不少修正的方案，这里简要介绍一下 
 </div> 
 <b>基于 Cholesky 分解法</b>的思想，这种算法在对二阶导数矩阵分解过程中调整对角元使得修正后的二阶导数充分正定，也就是说在矩阵的 
 <div style="text-align:center;"> 
  <img src="" alt=""> 分解中， 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 的对角元不小于某一个给定常数；并且如果原矩阵正定，那么修正后的二阶导数矩阵也是就原矩阵。 
 </div> 
 <p>Ps: <b>信赖域牛顿法</b>在上一篇博文仿真案例用的就是了，感兴趣的可以去看一下。</p> 
  
 养生的控制人：数值优化（Numerical Optimization）(2)-信赖域法​zhuanlan.zhihu.com 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/6f/b0/iEExNdFs_o.png" alt="c93f1fd205afb821a3806bb43cdf9cdf.png"> 
 </div> 
 <h3>拟牛顿法</h3> 
 <p>拟牛顿法的思想是<b>模拟牛顿方向的生成路径</b>，利用相邻两个点的<b>位移</b>和<b>一阶导数信息</b>构造与二阶导数阵相似的正定矩阵。所需的计算量比牛顿法少，收敛速度达到超线性。</p> 
 <p>假设函数 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 二次连续可微，在 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 的二次近似为 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>对上式两边求导可得</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>如果令 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 可得 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>等价于</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>假设二阶导数矩阵的<b>逆矩阵</b> </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 近似为 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 满足 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>上式也称为<b>拟牛顿方程</b>，可以看到 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 和迭代点的 
 </div> 
 <b>位移</b> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 和 
 </div> 
 <b>梯度差</b> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 决定。 
 </div> 
 <h3>DFP</h3> 
 <p>下面介绍一下第一个拟牛顿法，<b>DFP算法</b>，算法中假设 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 由 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 修正得到，且修正矩阵为秩二矩阵 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>根据假设 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 以及拟牛顿方程可以得到 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>其中 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 为位移， 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 为梯度差。这里 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 的选择并不是唯一的，可以取 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> ，则 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>因此有</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>从而求出 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 并带入 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 的修正表达式得到 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>这个公式也称为 DFP校正公式。</p> 
 <p>DFP算法流程</p> 
 <ol><li>选择初值 
   <div style="text-align:center;"> 
    <img src="" alt=""> 以及收敛阈值 
   </div></li><li>检验终止条件</li><li> 计算搜索方向 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 确定步长 
   <div style="text-align:center;"> 
    <img src="" alt=""> 和下一个迭代点 
   </div> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 根据 DFP 校正公式计算矩阵 
   <div style="text-align:center;"> 
    <img src="" alt=""> ，令 
   </div> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 并返回步骤2 
   </div></li></ol> 
 <h3>BFGS</h3> 
 <p><b>BFGS算法</b>的推导过程和 DFP 完全类似，令 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 可以得到拟牛顿方程的另一个表达式 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>得到的更新公式为</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>BFGS算法流程</p> 
 <ol><li>设置初值 
   <div style="text-align:center;"> 
    <img src="" alt=""> 和收敛阈值 
   </div></li><li> 求解线性方程 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 线搜索得到步长 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 令 
   <div style="text-align:center;"> 
    <img src="" alt=""> 更新 
   </div> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 更新梯度差 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 计算矩阵 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li></ol> 
 <p>在算法中 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 可以初始化为单位阵，第一步的矩阵求逆可以根据 Sherman-Morrison 公式进行转化后得到 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>一种更有效的计算为</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <h3>L-BFGS</h3> 
 <p>对于 BFGS 算法，需要储存近似逆二阶导数矩阵 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> ，对于维度较大的问题不再适用，因此有了 
 </div> 
 <b>内存受限的 BFGS 算法</b> （Limited-memory BFGS）。虽然 L-BFGS 不需要储存近似逆矩阵，但要保存每次迭代的中间信息，不过都是一维数组，且迭代次数不会有很多，所以对储存要求大大降低。 
 <p>定义</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>则 BFGS 的公式可以改写为</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>在第 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 次迭代，当前点为 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> ，且存有 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 总共 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 步的位移和梯度差。选择一个初始的 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> ，则可以推导出 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 的表达式为 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>根据这个表达式我们可以推导出计算 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 的递归算法 
 </div> 
 <p>令 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>循环1： </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <ul><li> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li></ul> 
 <p>令 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>循环2： </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <ul><li> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li></ul> 
 <p>输出 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>上面的递归算法涉及了 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 的选择，一种有效的方式是 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>这里的 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 叫做尺度因子用来估计沿最近搜索方向的真实二阶导数矩阵的大小。 
 </div> 
 <p>综上，完整的 L-BFGS 算法可以描述为</p> 
 <p>输入：初始点 </p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> ，记忆步长 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> ，令 
 </div> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>循环直到收敛：</p> 
 <ul><li> 选择 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 根据双循环递归算法计算 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 计算下一迭代点 
   <div style="text-align:center;"> 
    <img src="" alt=""> 其中 
   </div> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 的选择需要满足 Wolfe 条件 
   </div></li><li> 如果 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 计算并保存 
   <div style="text-align:center;"> 
    <img src="" alt=""> ， 
   </div> 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li><li> 令 
   <div style="text-align:center;"> 
    <img src="" alt=""> 
   </div></li></ul> 
 <h3>MATLAB示例</h3> 
 <p>求 <b>Rosenbrock</b>函数的最小点</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>计算梯度为</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>计算二阶导数为</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="" alt=""> 
 </div> 
 <p>首先把这个函数写成输入输出的函数形式</p> 
 <div class="has"> 
  <pre><code>function [f,g,H] = RosenFunc(x0)

x = x0(1);
y = x0(2);
f = (1-x)^2 + 100*(y-x^2)^2;
if (nargout &gt; 1)
    g = [-2 + 2*x - 400*x*y + 400*x^3;
        200*(y-x^2)];
end
if (nargout &gt; 2)
   H = [2 - 400*(y-x^2) + 800*x^2, -400*x;
       -400*x, 200];
end</code></pre> 
 </div> 
 <p>另外也附上 Branin 函数用于测试</p> 
 <div class="has"> 
  <pre><code>function [f,g,H] = BraninFunc(x0)
x1 = x0(1);
x2 = x0(2);
f = (x2-0.129*x1^2+1.6*x1-6)^2+6.07*cos(x1)+10;
if (nargout &gt; 1)
    g = [2*(x2-0.129*x1^2+1.6*x1-6)*(-0.258*x1+1.6)-6.07*sin(x1);...
        2*(x2-0.129*x1^2+1.6*x1-6)];
end
if (nargout &gt; 2)
    H = [2*(-0.258*x1+1.6)^2-0.516*(x2-0.128*x1^2+1.6*x1-6)-6.07*cos(x1),...
    -0.516*x1+3.2;-0.516*x1+3.2,2];
end</code></pre> 
 </div> 
 <p>阻尼牛顿法（线搜索用回溯法）</p> 
 <div class="has"> 
  <pre><code>function [x_opt,x_eval,f_eval] = Newton_basic(fun,x0,epsilon,iter)
x_eval = [];
f_eval = [];
xk = x0;
[fk,gk,Hk] = fun(xk);
for k = 1:iter  
    if norm(gk,2) &lt;= epsilon
        break
    end
    x_eval = [x_eval,xk];
    f_eval = [f_eval,fk];
    dk = -inv(Hk)*gk;
    alpha = backstracking_linesearch(fun,xk,dk);
    xk = xk + alpha*dk;
    [fk,gk,Hk] = fun(xk);
end
x_opt = xk;</code></pre> 
 </div> 
 <p>BFGS法（线搜索用回溯法）</p> 
 <div class="has"> 
  <pre><code>function [x_opt,x_eval,f_eval] = Newton_BFGS(fun,x0,epsilon,iter)
x_eval = [];
f_eval = [];
xk = x0;
n = length(x0);
Hk = eye(n);
[fk,gk] = fun(xk);
for k = 1:iter
    if norm(gk,2) &lt;= epsilon
        break
    end
    x_eval = [x_eval,xk];
    f_eval = [f_eval,fk];
    dk = -Hk*gk;
    % line search
    alpha = backstracking_linesearch(fun,xk,dk);
    x_next = xk + alpha*dk;
    [f_next,g_next] = fun(x_next);
    % BFGS
    sk = alpha*dk;
    yk = g_next - gk;
    rho = 1/(yk'*sk);
    Hk = (eye(n) - rho*sk*yk')*Hk*(eye(n)-rho*yk*sk') + rho*sk*sk';
    % 更新
    gk = g_next;
    xk = x_next;
    fk = f_next;
end
x_opt = xk;</code></pre> 
 </div> 
 <p>L-BFGS法（线搜索用回溯法）</p> 
 <div class="has"> 
  <pre><code>function [x_opt,x_eval,f_eval] = Newton_LBFGS(fun,x0,m,epsilon,iter)
x_eval = [];
f_eval = [];
n = length(x0);
S = zeros(n,m);
Y = zeros(n,m);
xk = x0;
[fk,gk] = fun(x0);
for k = 1:iter
    if norm(gk,2) &lt;= epsilon
        break
    end
    x_eval = [x_eval,xk];
    f_eval = [f_eval,fk];
    if k &gt; 1
        gamma = (S(:,1)'*Y(:,1))/(Y(:,1)'*Y(:,1));
        H0 = gamma*eye(n);
        % two-loop
        q = gk;
        rho = zeros(m,1);
        ALPHA = zeros(m,1);
        for i = 1:min(k-1,m)
            rho(i) = 1/(Y(:,i)'*S(:,i));
            ALPHA(i) = rho(i)*S(:,i)'*q;
            q = q - ALPHA(i)*Y(:,i);
        end
        dk = H0*q;
        for j = 1:min(k-1,m)-1
            i = min(k,m)-j+1;
            beta = rho(i)*Y(:,i)'*dk;
            dk = dk +S(:,i)*(ALPHA(i)-beta);
        end
        dk = -dk;
    else
        H0 = eye(n);
        dk = -H0*gk;
    end
    % line search
    alpha = backstracking_linesearch(fun,xk,dk);
    x_next = xk + alpha*dk;
    [f_next,g_next] = fun(x_next);
    % 更新位移和梯度差
    S(:,2:m) = S(:,1:m-1);
    Y(:,2:m) = Y(:,1:m-1);
    sk = x_next - xk;
    yk = g_next - gk;
    S(:,1) = sk;
    Y(:,1) = yk;
    % 更新
    xk = x_next;
    fk = f_next;
    gk = g_next;
end
x_opt = xk;</code></pre> 
 </div> 
 <p>选择一个比较有意思的对比展示一下，采用 Branin 函数，初始点为 </p> 
 <div style="text-align:center;"> 
  <img src="" alt="">，L-BFGS的记忆步数为 30 步。 
 </div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/c3/b4/eYhSm1Hl_o.png" alt="071b4143f44e9e82f76942844135b0b8.png"> 
 </div> 
 <p>三种算法跑到了三个地方去了，两个局部最小点，基本牛顿法停留在一个在非常平的地段。对应的函数值也不一样。</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/5c/10/7oQSs8ZI_o.png" alt="4ef446acb00fe5809e0041cfd1deb7f9.png"> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e901d14dfd23fcb4adedbb2b779ad0c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">脑机接口全球Top20实验室信息与概括（有空更新）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c9c3c0f3e8b96e8fec4052f745ba404e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">word排版插件_8款堪称神器的Office插件，让你工作效率直线飙升！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>