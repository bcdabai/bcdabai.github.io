<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[C&#43;&#43;] 哈希详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[C&#43;&#43;] 哈希详解" />
<meta property="og:description" content="目录 1. 哈希概念2. 实现机制2.1 插入时2.2 查找时2.3 缺陷2.4 常见哈希函数2.4.1 直接定制法2.4.2 除留余数法2.4.3 平方取中法2.4.4 折叠法注意 3. 解决哈希冲突3.1 闭散列3.1.1 线性探测3.1.2 二次探测3.1.3 闭散列缺点 3.2 开散列3.2.1 容量问题 4. 开散列的代码实现 1. 哈希概念 哈希是一种高效用来搜索的数据结构，与传统的查找方式进行比较，发现传统的方式都需要进行元素的比较，性能高低取决于元素的比较次数。让元素在查找时不进行比较，或者减少比较次数。
顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(log2 N)，搜索的效率取决于搜索过程中元素的比较次数。
理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一对一映射的关系，那么在查找时通过该函数可以很快找到该元素。
2. 实现机制 2.1 插入时 1.通过函数计算插入位置，该函数成为哈希函数
2.通过计算出的存储位置进行元素的插入，通过这种方法构造出来结构称为哈希表(散列表)
2.2 查找时 1.通过哈希函数对关键码进行计算，得出元素的存储位置
2.根据存储位置在哈希表中，取出元素进行比较，若关键码相同，则查找成功。
这里使用除留余数法举例
2.3 缺陷 对于两个数据元素的关键字 ki 和 kj (i != j)，有 ki != kj，但有：Hash(ki) == Hash(kj)，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。
举例：
上述图片中，1的位置上已经插入了一，如果我们还想插入11，使用除留余数法11 % 10 = 1，插入位置还是 1 的位置，这就发生了哈希冲突。
2.4 常见哈希函数 2.4.1 直接定制法 原理：取关键字的某个线性函数为散列地址：Hash（Key）= A*Key &#43; B" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dad364989c1a33f8d2980297360d1e51/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-29T20:05:00+08:00" />
<meta property="article:modified_time" content="2021-08-29T20:05:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[C&#43;&#43;] 哈希详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1__3" rel="nofollow">1. 哈希概念</a></li><li><a href="#2__8" rel="nofollow">2. 实现机制</a></li><li><ul><li><a href="#21__9" rel="nofollow">2.1 插入时</a></li><li><a href="#22__13" rel="nofollow">2.2 查找时</a></li><li><a href="#23__21" rel="nofollow">2.3 缺陷</a></li><li><a href="#24__29" rel="nofollow">2.4 常见哈希函数</a></li><li><ul><li><a href="#241__30" rel="nofollow">2.4.1 直接定制法</a></li><li><a href="#242__35" rel="nofollow">2.4.2 除留余数法</a></li><li><a href="#243__39" rel="nofollow">2.4.3 平方取中法</a></li><li><a href="#244__43" rel="nofollow">2.4.4 折叠法</a></li><li><a href="#_47" rel="nofollow">注意</a></li></ul> 
  </li></ul> 
  </li><li><a href="#3__51" rel="nofollow">3. 解决哈希冲突</a></li><li><ul><li><a href="#31__52" rel="nofollow">3.1 闭散列</a></li><li><ul><li><a href="#311__55" rel="nofollow">3.1.1 线性探测</a></li><li><a href="#312__65" rel="nofollow">3.1.2 二次探测</a></li><li><a href="#313__77" rel="nofollow">3.1.3 闭散列缺点</a></li></ul> 
   </li><li><a href="#32__89" rel="nofollow">3.2 开散列</a></li><li><ul><li><a href="#321__97" rel="nofollow">3.2.1 容量问题</a></li></ul> 
   </li><li><a href="#4__136" rel="nofollow">4. 开散列的代码实现</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__3"></a>1. 哈希概念</h2> 
<p>  哈希是一种高效用来搜索的数据结构，与传统的查找方式进行比较，发现传统的方式都需要进行元素的比较，性能高低取决于元素的比较次数。<strong>让元素在查找时不进行比较，或者减少比较次数。</strong></p> 
<blockquote> 
 <p>  顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(log2 N)，搜索的效率取决于搜索过程中元素的比较次数。<br>   理想的搜索方法：<strong>可以不经过任何比较，一次直接从表中得到要搜索的元素</strong>。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立<strong>一对一映射</strong>的关系，那么在查找时通过该函数可以很快找到该元素。</p> 
</blockquote> 
<h2><a id="2__8"></a>2. 实现机制</h2> 
<h3><a id="21__9"></a>2.1 插入时</h3> 
<blockquote> 
 <p>1.通过函数计算插入位置，该函数成为<strong>哈希函数</strong><br> 2.通过计算出的存储位置进行元素的插入，通过这种方法构造出来结构称为<strong>哈希表(散列表)</strong></p> 
</blockquote> 
<h3><a id="22__13"></a>2.2 查找时</h3> 
<blockquote> 
 <p>1.通过哈希函数对关键码进行计算，得出元素的存储位置<br> 2.根据存储位置在哈希表中，取出元素进行比较，若关键码相同，则查找成功。</p> 
</blockquote> 
<p>这里使用除留余数法举例<br> <img src="https://images2.imgbox.com/04/59/0Yi9dx8A_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23__21"></a>2.3 缺陷</h3> 
<p>  对于两个数据元素的关键字 ki 和 kj (i != j)，有 ki != kj，但有：Hash(ki) == Hash(kj)，即：<strong>不同关键字通过相同哈希哈数计算出相同的哈希地址</strong>，该种现象称为<strong>哈希冲突或哈希碰撞</strong>。把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。</p> 
<p><strong>举例：</strong><br> 上述图片中，1的位置上已经插入了一，如果我们还想插入<code>11</code>，使用除留余数法<code>11 % 10 = 1</code>，插入位置还是 1 的位置，这就发生了哈希冲突。</p> 
<h3><a id="24__29"></a>2.4 常见哈希函数</h3> 
<h4><a id="241__30"></a>2.4.1 直接定制法</h4> 
<blockquote> 
 <p><strong>原理</strong>：取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B<br> <strong>优点</strong>：简单、均匀 缺点：需要事先知道关键字的分布情况<br> <strong>使用场景</strong>：适合查找比较小且连续的情况</p> 
</blockquote> 
<h4><a id="242__35"></a>2.4.2 除留余数法</h4> 
<blockquote> 
 <p><strong>原理</strong>：设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：Hash(key) = key% p(p&lt;=m),将关键码转换成哈希地址。<br> <strong>注意</strong>: 一般情况下，<strong>p最好是一个不超过m的最大素数</strong></p> 
</blockquote> 
<h4><a id="243__39"></a>2.4.3 平方取中法</h4> 
<blockquote> 
 <p><strong>原理</strong>：假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址； 再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址<br> <strong>场景</strong>：平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况</p> 
</blockquote> 
<h4><a id="244__43"></a>2.4.4 折叠法</h4> 
<blockquote> 
 <p><strong>原理</strong>：折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。<br> <strong>场景</strong>：折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况</p> 
</blockquote> 
<h4><a id="_47"></a>注意</h4> 
<blockquote> 
 <p>不论一个哈希函数设计的有多么精妙，都不能完全解决哈希冲突，只能是，<strong>哈希函数越精妙，产生的哈希冲突概率越低</strong></p> 
</blockquote> 
<h2><a id="3__51"></a>3. 解决哈希冲突</h2> 
<h3><a id="31__52"></a>3.1 闭散列</h3> 
<p>  闭散列也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以<strong>把key存放到冲突位置中的“下一个” 空位置中去</strong>。</p> 
<h4><a id="311__55"></a>3.1.1 线性探测</h4> 
<p><strong>原理</strong><br>   从发生冲突的位置逐个挨着一次往后查找，如果查找到空间的末尾，也没有发现空位置时，再折回空间起始位置继续查找，直到找到空位置插入进去。</p> 
<p><strong>缺陷</strong><br>   容易产生数据堆积，如果发生了冲入，冲突的元素可能连成一片，因为查找下一个空位置的方式，是逐个向后查找到。</p> 
<p><strong>如何避免</strong><br> 不要挨着依次向后查找空位置，<code>二次探测</code>。</p> 
<h4><a id="312__65"></a>3.1.2 二次探测</h4> 
<p>  解决数据堆积的问题，每次查找空位置时，<strong>都向后偏移不同的举例进行检测</strong>。</p> 
<p><strong>查找下一个空位置的方法</strong></p> 
<blockquote> 
 <p><code>H(i) = (H0 + i ^ 2) % cap</code> / <code>H(i) = (H0 - i ^ 2) % cap</code><br> 所以: <code>H(i + 1) = H(i) + 2 * i + 1</code></p> 
</blockquote> 
<p><strong>缺陷</strong><br>   当表格中空位置比较少时，可能需要查找很多次</p> 
<h4><a id="313__77"></a>3.1.3 闭散列缺点</h4> 
<p>  当表格中数据较多时，或者哈希表中的空位置较少时，发生冲突的概率非常高，而且找下一个空位置的效率比较低，不论是线性探测还是二次探测都需要找好多次才能找到。</p> 
<blockquote> 
 <p>  当哈希表中有效元素比较多时，对哈希表的性能影响非常大。<br>   哈希期望查找时间复杂度是 O(1)，但空位置比较少时，性能远远超过O(1).<br> <strong>哈希使用时间换空间</strong></p> 
</blockquote> 
<p><strong>解决方法</strong><br>   不要让表格存储太多元素，达到一定程度时就进行扩容，即: <strong>哈希表中的元素一定不会存满</strong></p> 
<p>  <code>负载因子 = 填入表的有效元素的个数 / 散列表的长度</code> 线性探测为：70%左右，二次探测为：50%~60%，在<strong>这个区间内就需要扩容了</strong>，存的多了就会导致冲突概率上升，存的少了就会空间利用率降低。</p> 
<h3><a id="32__89"></a>3.2 开散列</h3> 
<p>  开散列法又叫链地址法(开链法)，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，<strong>每一个子集合称为一个桶</strong>，各个<strong>桶中的元素通过一个单链表链接起来</strong>，各链表的头结点存储在哈希表中。<br>   <strong>数组中的每个元素都是链表，每条链表中挂的都是发生哈希冲突的元素</strong></p> 
<p><img src="https://images2.imgbox.com/73/b1/FihlOvPB_o.png" alt="在这里插入图片描述"><br> <strong>操作</strong><br>   插入或查找时，当中存在一个循环，即：遍历链表，检测data是否存在，表面上时间复杂度O(n)，但实际认为操作时的时间复杂度为O(1)，因为<strong>链表不会很长</strong></p> 
<h4><a id="321__97"></a>3.2.1 容量问题</h4> 
<p><strong>1. 如果元素特别多，或元素特别特殊，大部分元素都集中到了某一个链表中</strong></p> 
<p>  导致某些链表特别长，在哈希桶中查找某个元素，就退化成了在单链表中查找。</p> 
<blockquote> 
 <p>  如果每个哈希桶中的元素不是特别多的情况下，哈希桶的时间复杂度为O(1).<br>   如果哈希桶当中某些链表中挂的结点非常多，哈希桶就退化成了在链表中进行查找，时间复杂度变成了O(n)。</p> 
</blockquote> 
<p>  所以在插入元素的过程中，需要避免上述的情况，在闭散列中，元素多到一定程度通过扩容来降低冲突概率，哈希桶中也是如此，通过扩容，把链表中的结点分散开来。</p> 
<p><strong>2. 什么情况下进行扩容？什么情况下哈希桶最优(空间利用率高、查找性能高)?</strong><br>   最优状态: 每个桶只挂一个结点。<strong>当哈希桶中元素个数与桶的个数相同时就要考虑扩容</strong>。因为扩容之后，哈希桶的容量变了，哈希函数计算出来的结果就发生了变化，再将旧哈希桶中的元素往新哈希桶中插入，就可以基本到达较优。</p> 
<p><strong>3. 随着哈希桶中的元素不断增多，哈希桶的的容量也会不断增大，怎么解决？</strong><br>   扩容之后，继续往哈希桶中插入元素，或者对方在向哈希表中插入元素是，每个插入哈希桶中的元素都是发生哈希冲突的，可能又会出现某些链表特别长的场景出现，扩容之后依旧不能达到目的。(哈希桶性能又下降了，但是还没有达到扩容的时机)。</p> 
<p><strong>解决方案</strong><br>   当链表中的结点达到一定的阈值，还没有达到扩容的条件时，可以将链表转换成<strong>红黑树</strong>，当结点个数小于阈值就转换成链表。</p> 
<p><strong>4. 哈希函数</strong><br>   除留取余法：最好模上一个素数，发生冲突的概率相对而言能稍微低一些，而元素的个数与表格容量相等时，需要扩容，按照两倍的方式扩容。可以用素数表将含有两倍关系的素数存下来。</p> 
<pre><code class="prism language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> PRIMECOUNT <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token class-name">size_t</span> primeList<span class="token punctuation">[</span>PRIMECOUNT<span class="token punctuation">]</span> <span class="token operator">=</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token number">53ul</span><span class="token punctuation">,</span> <span class="token number">97ul</span><span class="token punctuation">,</span> <span class="token number">193ul</span><span class="token punctuation">,</span> <span class="token number">389ul</span><span class="token punctuation">,</span> <span class="token number">769ul</span><span class="token punctuation">,</span>
	<span class="token number">1543ul</span><span class="token punctuation">,</span> <span class="token number">3079ul</span><span class="token punctuation">,</span> <span class="token number">6151ul</span><span class="token punctuation">,</span> <span class="token number">12289ul</span><span class="token punctuation">,</span> <span class="token number">24593ul</span><span class="token punctuation">,</span>
	<span class="token number">49157ul</span><span class="token punctuation">,</span> <span class="token number">98317ul</span><span class="token punctuation">,</span> <span class="token number">196613ul</span><span class="token punctuation">,</span> <span class="token number">393241ul</span><span class="token punctuation">,</span> <span class="token number">786433ul</span><span class="token punctuation">,</span>
	<span class="token number">1572869ul</span><span class="token punctuation">,</span> <span class="token number">3145739ul</span><span class="token punctuation">,</span> <span class="token number">6291469ul</span><span class="token punctuation">,</span> <span class="token number">12582917ul</span><span class="token punctuation">,</span> <span class="token number">25165843ul</span><span class="token punctuation">,</span>
	<span class="token number">50331653ul</span><span class="token punctuation">,</span> <span class="token number">100663319ul</span><span class="token punctuation">,</span> <span class="token number">201326611ul</span><span class="token punctuation">,</span> <span class="token number">402653189ul</span><span class="token punctuation">,</span> <span class="token number">805306457ul</span><span class="token punctuation">,</span>
	<span class="token number">1610612741ul</span><span class="token punctuation">,</span> <span class="token number">3221225473ul</span><span class="token punctuation">,</span> <span class="token number">4294967291ul</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>5. 泛型存储</strong><br>   哈希函数中任意类型都能存储，但是使用除留取余法，只能转换整数，所以还要传入一个模板参数，可以将其它类型进行转换，使之能够使用除留取余法。</p> 
<h3><a id="4__136"></a>4. 开散列的代码实现</h3> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Common.h"</span></span>

<span class="token comment">// 哈希桶：数组+链表(无头单链表)</span>

template<span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">HashBucketNode</span>
<span class="token punctuation">{<!-- --></span>
	HashBucketNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
	T data<span class="token punctuation">;</span>

	<span class="token function">HashBucketNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">next</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">data</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">// T 如果是整形家族</span>
template<span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span>
class T2IntDef
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


class Str2Int
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token class-name">size_t</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed <span class="token operator">=</span> <span class="token number">131</span><span class="token punctuation">;</span> <span class="token comment">// 31 131 1313 13131 131313</span>
		<span class="token keyword">unsigned</span> <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			hash <span class="token operator">=</span> hash <span class="token operator">*</span> seed <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">// 假设：当前实现的哈希表中元素唯一</span>
<span class="token comment">// T：哈希表中存储的元素的类型</span>
<span class="token comment">// T2Int: 将T转换为整形的结果</span>

template<span class="token operator">&lt;</span>class T<span class="token punctuation">,</span> class T2Int <span class="token operator">=</span> T2IntDef<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
class HashBucket
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> HashBucketNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
public<span class="token operator">:</span>
	<span class="token function">HashBucket</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> capacity <span class="token operator">=</span> <span class="token number">53</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">table</span><span class="token punctuation">(</span><span class="token function">GetNextPrime</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// n个值为data的构造方法在构造哈希桶</span>
		<span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">HashBucket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/*
	虽然从代码层面来看，Insert当中存在一个循环，即：遍历链表，检测data是否存在----&gt;表面上Insert的时间复杂度O(N)
	但是实际认为Insert的时间复杂度仍旧为O(1)----&gt;因为：在哈希桶中，每个桶对应的链表当中的节点的格式都不是非常多
	*/</span>
	bool <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 0. 检测是否需要扩容</span>
		<span class="token function">CheckCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 1. 通过哈希函数计算元素所在桶号</span>
		<span class="token class-name">size_t</span> bucketNo <span class="token operator">=</span> <span class="token function">HashFunc</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 2. 检测元素是否存在</span>
		Node<span class="token operator">*</span> cur <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> cur<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span>
				<span class="token keyword">return</span> false<span class="token punctuation">;</span>

			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 3. 插入元素</span>
		cur <span class="token operator">=</span> new <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">;</span>
		table<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>
		<span class="token operator">++</span>size<span class="token punctuation">;</span>
		<span class="token keyword">return</span> true<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool <span class="token function">Erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 1. 先通过哈希函数计算元素所在的桶号</span>
		<span class="token class-name">size_t</span> bucketNo <span class="token operator">=</span> <span class="token function">HashFunc</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 2. 找元素在bucketNo桶中是否处在，存在则删除</span>
		<span class="token comment">// 核心操作---&gt;删除链表当中只为data的节点</span>
		<span class="token comment">//  该节点可能是链表中的第一个节点</span>
		<span class="token comment">//  该节点可能是链表中的非第一个节点</span>

		Node<span class="token operator">*</span> cur <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">;</span>
		Node<span class="token operator">*</span> prev <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>   <span class="token comment">// 标记cur的前一个节点</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> cur<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 删除cur节点</span>
				<span class="token comment">// 删除的节点如果是第一个节点</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>nullptr <span class="token operator">==</span> prev<span class="token punctuation">)</span>
					table<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
				<span class="token keyword">else</span>
					prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

				delete cur<span class="token punctuation">;</span>
				<span class="token operator">--</span>size<span class="token punctuation">;</span>
				<span class="token keyword">return</span> true<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 当前节点不是要找的data，则两个指针同时往后移动</span>
				prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 哈希桶中不存在值为data的元素，无法删除即删除失败</span>
		<span class="token keyword">return</span> false<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Node<span class="token operator">*</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 1. 先通过哈希函数计算元素所在的桶号</span>
		<span class="token class-name">size_t</span> bucketNo <span class="token operator">=</span> <span class="token function">HashFunc</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 2. 在检测该元素是否存在对应的链表中</span>
		Node<span class="token operator">*</span> cur <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> cur<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span>
				<span class="token keyword">return</span> cur<span class="token punctuation">;</span>

			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token class-name">size_t</span> <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">==</span> size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/</span>
	<span class="token comment">// 为了方便对哈希桶的理解，实现打印哈希桶的方法</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> table<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"table["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"]:"</span><span class="token punctuation">;</span>

			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				cout <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-&gt;</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">"---&gt;"</span><span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"NULL"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"========================================="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>HashBucket<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T2Int<span class="token operator">&gt;</span><span class="token operator">&amp;</span> ht<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		table<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>ht<span class="token punctuation">.</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>
		std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> ht<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

private<span class="token operator">:</span>
	<span class="token comment">// 哈希函数---除留余数法</span>
	<span class="token class-name">size_t</span> <span class="token function">HashFunc</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		T2Int t2Int<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token function">t2Int</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">%</span> table<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 循环去销毁：table中的每个链表</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> table<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			Node<span class="token operator">*</span> cur <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

			<span class="token comment">// 采用：头删法删除链表中的每个节点</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
				delete cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">CheckCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> table<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 扩容---将表格放大----然后将桶中的元素往新桶中插入</span>
			HashBucket<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T2Int<span class="token operator">&gt;</span> <span class="token function">newHT</span><span class="token punctuation">(</span><span class="token function">GetNextPrime</span><span class="token punctuation">(</span>table<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// 将就哈希桶中的节点拆下来，移动到新哈希桶中</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> table<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				Node<span class="token operator">*</span> cur <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 1. 将cur节点拆下来</span>
					table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

					<span class="token comment">// 2. 将cur节点往newHT中插入</span>
					<span class="token comment">// 找位置</span>
					<span class="token class-name">size_t</span> bucketNo <span class="token operator">=</span> newHT<span class="token punctuation">.</span><span class="token function">HashFunc</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

					<span class="token comment">// 头插法</span>
					cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newHT<span class="token punctuation">.</span>table<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">;</span>
					newHT<span class="token punctuation">.</span>table<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>
					newHT<span class="token punctuation">.</span>size<span class="token operator">++</span><span class="token punctuation">;</span>

					cur <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// 已经将旧哈希桶中的元素全部移动到新哈希桶当中了</span>
			this<span class="token operator">-&gt;</span><span class="token function">Swap</span><span class="token punctuation">(</span>newHT<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
private<span class="token operator">:</span>
	<span class="token comment">// table当中将来存放所有的链表---&gt;实际只需要存放链表首节点的地址</span>
	std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> table<span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> size<span class="token punctuation">;</span>   <span class="token comment">// 有效元素的个数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/924fdfe7f554dcd0265ebde327b2dcbb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于2D特征的运动估计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a961750544f828ecd44be56edf58b669/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">多普勒频率的推导(纯公式版)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>