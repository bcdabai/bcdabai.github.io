<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>达梦数据库-linux环境下断网后连接卡住问题解决 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="达梦数据库-linux环境下断网后连接卡住问题解决" />
<meta property="og:description" content="问题描述 应用：x86 centos7
数据库：1-2-128-22.08.12-166927-20005-ENT
测试数据库有两个相互隔离的IP，应用可通过两个IP连接数据库，当断开正在连接的一个网卡后，不能立即切换，程序卡住时间过长问题。应用部署于windows时正常。
如上图所示客户端初始连接ip为192.168.44.130 当关闭改网卡后程序卡住12分钟。
问题原因分析 通过设置连接超时等参数均未解决，通过咨询专家提供TCP/IP连接排查方向。通过程序跟踪，确定确为与TCP连接相关，测试修改TCP相关内核参数，最终确定与linux tcp 断网重连net.ipv4.tcp_retries2参数相关
具体分析过程 创建测试用户和表 CREATE USER &#34;USER01&#34; IDENTIFIED BY &#34;Dameng88.&#34;; CREATE TABLE &#34;USER01&#34;.&#34;TAB02&#34; ( &#34;C1&#34; INT, &#34;C2&#34; VARCHAR(50)); 配置服务名连接 vim /etc/dm_svc.config TIME_ZONE=(480) LANGUAGE=(cn) DMTEST=(192.168.183.128:5236,192.168.44.128:5236) [DMTEST] AUTO_RECONNECT=(1) CONNECT_TIMEOUT=(500) 编写DCI测试用例 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;malloc.h&gt; #include &lt;unistd.h&gt; #include &#34;DCI.h&#34; /* 声明句柄 */ OCIEnv* envhp; /* 环境句柄 */ OCISvcCtx* svchp; /* 服务环境句柄 */ OCIServer* srvhp; /* 服务器句柄 */ OCISession* authp; /* 会话句柄 */ OCIStmt* stmthp; /* 语句句柄 */ OCIDescribe* dschp; /* 描述句柄 */ OCIError* errhp; /* 错误句柄 */ OCIDefine* defhp[3]; /* 定义句柄 */ OCIBind* bidhp[4]; /* 绑定句柄 */ sb2 ind[3]; /* 指示符变量 */ /* 绑定select结果集的参数 */ int szc1; /* 存储personid列 */ text szc2[30]; /* 存储sex列 */ char sql[256]; /* 存储执行的sql语句*/ void connDB(){ char strServerName[50]; char strUserName[50]; char strPassword[50]; int ret; text errbuf[100]; /* 设置服务器，用户名和密码 */ strcpy(strServerName, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3890fe96e5ae3f26cc290ef29b121698/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-11T17:29:00+08:00" />
<meta property="article:modified_time" content="2022-10-11T17:29:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">达梦数据库-linux环境下断网后连接卡住问题解决</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>问题描述</h2> 
<p style="margin-left:0cm;text-align:left;">应用：x86 centos7</p> 
<p style="margin-left:0cm;text-align:left;">数据库：1-2-128-22.08.12-166927-20005-ENT</p> 
<p style="margin-left:0cm;text-align:left;">测试数据库有两个相互隔离的IP，应用可通过两个IP连接数据库，当断开正在连接的一个网卡后，不能立即切换，程序卡住时间过长问题。应用部署于windows时正常。</p> 
<p style="margin-left:0cm;text-align:left;"><img alt="" height="351" src="https://images2.imgbox.com/09/db/cLSHB73d_o.png" width="198"></p> 
<p style="margin-left:0cm;text-align:left;">如上图所示客户端初始连接ip为192.168.44.130 当关闭改网卡后程序卡住12分钟。</p> 
<h2 style="margin-left:0cm;text-align:left;">问题原因分析</h2> 
<p style="margin-left:0;text-align:left;">        通过设置连接超时等参数均未解决，通过咨询专家提供TCP/IP连接排查方向。通过程序跟踪，确定确为与TCP连接相关，测试修改TCP相关内核参数，最终确定与linux tcp 断网重连net.ipv4.tcp_retries2参数相关</p> 
<h3 style="margin-left:0px;text-align:left;">具体分析过程</h3> 
<ul><li style="text-align:justify;">创建测试用户和表</li></ul> 
<pre><code class="hljs">CREATE USER "USER01" IDENTIFIED BY "Dameng88.";
CREATE TABLE "USER01"."TAB02"
(
"C1" INT,
"C2" VARCHAR(50));
</code></pre> 
<ul><li style="text-align:justify;">配置服务名连接</li></ul> 
<pre><code class="hljs">vim /etc/dm_svc.config
TIME_ZONE=(480)
LANGUAGE=(cn)
DMTEST=(192.168.183.128:5236,192.168.44.128:5236)

[DMTEST]
AUTO_RECONNECT=(1)
CONNECT_TIMEOUT=(500)
</code></pre> 
<ul><li style="text-align:justify;">编写DCI测试用例</li></ul> 
<pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;unistd.h&gt;
#include "DCI.h"
/* 声明句柄 */
OCIEnv* envhp; /* 环境句柄 */
OCISvcCtx* svchp; /* 服务环境句柄 */
OCIServer* srvhp; /* 服务器句柄 */
OCISession* authp; /* 会话句柄 */
OCIStmt* stmthp; /* 语句句柄 */
OCIDescribe* dschp; /* 描述句柄 */
OCIError* errhp; /* 错误句柄 */
OCIDefine* defhp[3]; /* 定义句柄 */
OCIBind* bidhp[4]; /* 绑定句柄 */
sb2 ind[3]; /* 指示符变量 */
/* 绑定select结果集的参数 */
int szc1; /* 存储personid列 */
text szc2[30]; /* 存储sex列 */
char sql[256]; /* 存储执行的sql语句*/

void connDB(){
        char strServerName[50];
        char strUserName[50];
        char strPassword[50];
        int ret;
        text errbuf[100];
        /* 设置服务器，用户名和密码 */
        strcpy(strServerName, "DMTEST");
        strcpy(strUserName, "SYSDBA");
        strcpy(strPassword, "SYSDBA");
        /* 初始化OCI应用环境*/
        OCIInitialize(OCI_DEFAULT, NULL, NULL, NULL, NULL);
        /* 初始化环境句柄 */
        OCIEnvInit(&amp;envhp, OCI_DEFAULT, 0, 0);
        /* 分配句柄 */
        OCIHandleAlloc(envhp, (dvoid**)&amp;svchp, OCI_HTYPE_SVCCTX, 0, 0); /*服务器环境句柄*/
        OCIHandleAlloc(envhp, (dvoid**)&amp;srvhp, OCI_HTYPE_SERVER, 0, 0); /* 服务器句柄*/
        OCIHandleAlloc(envhp, (dvoid**)&amp;authp, OCI_HTYPE_SESSION, 0, 0); /* 会话句柄 */
        OCIHandleAlloc(envhp, (dvoid**)&amp;errhp, OCI_HTYPE_ERROR, 0, 0); /* 错误句柄 */
        OCIHandleAlloc(envhp, (dvoid**)&amp;dschp, OCI_HTYPE_DESCRIBE, 0, 0); /*描述符句柄*/
        /* 连接服务器 */
        OCIServerAttach(srvhp, errhp, (text*)strServerName, (sb4)strlen(strServerName), OCI_DEFAULT);
        /* 设置用户名和密码 */
        OCIAttrSet(authp, OCI_HTYPE_SESSION, (text*)strUserName, (ub4)strlen(strUserName), OCI_ATTR_USERNAME, errhp);
        OCIAttrSet(authp, OCI_HTYPE_SESSION, (text*)strPassword, (ub4)strlen(strPassword), OCI_ATTR_PASSWORD, errhp);
        /* 设置服务器环境句柄属性 */
        OCIAttrSet((dvoid*)svchp, (ub4)OCI_HTYPE_SVCCTX,(dvoid*)srvhp, (ub4)0, OCI_ATTR_SERVER, errhp);
        OCIAttrSet(svchp, OCI_HTYPE_SVCCTX, (dvoid*)authp,0, OCI_ATTR_SESSION, errhp);
        /* 创建并开始一个用户会话 */
        ret=OCISessionBegin(svchp, errhp, authp, OCI_CRED_RDBMS, OCI_DEFAULT);
        while(ret != 0)
        {
                OCIErrorGet(errhp, 1, NULL, &amp;ret, (OraText*)errbuf, sizeof(errbuf), OCI_HTYPE_ERROR);
                printf("\n%d,%s\n",ret,errbuf);
                sleep(2);
                ret=OCIServerAttach(srvhp, errhp, (text*)strServerName, (sb4)strlen(strServerName), OCI_DEFAULT);
        }

}

void closeDB(){
        //结束会话
        OCISessionEnd(svchp, errhp, authp, (ub4)0);
        //断开与数据库的连接
        OCIServerDetach(srvhp, errhp, OCI_DEFAULT);
        //释放OCI句柄
        OCIHandleFree((dvoid*)dschp, OCI_HTYPE_DESCRIBE);
        OCIHandleFree((dvoid*)stmthp, OCI_HTYPE_STMT);
        OCIHandleFree((dvoid*)errhp, OCI_HTYPE_ERROR);
        OCIHandleFree((dvoid*)authp, OCI_HTYPE_SESSION);
        OCIHandleFree((dvoid*)svchp, OCI_HTYPE_SVCCTX);
        OCIHandleFree((dvoid*)srvhp, OCI_HTYPE_SERVER);
}

int main(int argc, char* argv[])
{
        char strServerName[50];
        char strUserName[50];
        char strPassword[50];
        int ret;
        text errbuf[100];
        connDB();       
	int i=1;
	for(i=1;i&lt;100;i++){
                /* 分配和初始化句柄 */
                ret=OCIHandleAlloc(envhp, (dvoid**)&amp;stmthp, OCI_HTYPE_STMT, 0, 0);
                if (ret != 0){
                        OCIErrorGet(errhp, 1, NULL, &amp;ret, (OraText*)errbuf, sizeof(errbuf), OCI_HTYPE_ERROR);
                        printf("\n%d,%s\n",ret,errbuf);
                        OCISessionEnd(svchp, errhp, authp, (ub4)0);
                        sleep(2);
                        closeDB();
                        connDB();
                        ret=OCIHandleAlloc(envhp, (dvoid**)&amp;stmthp, OCI_HTYPE_STMT, 0, 0);
                }
        	memset(sql, 0, sizeof(sql));
                strcpy(sql, "delete from user01.tab02");
                // 准备SQL语句
                OCIStmtPrepare(stmthp, errhp, (text*)sql, strlen(sql), OCI_NTV_SYNTAX, OCI_DEFAULT);
        	// 执行SQL语句
                ret = OCIStmtExecute(svchp, stmthp, errhp, (ub4)1, (ub4)0, (CONST OCISnapshot*) 0, (OCISnapshot*)0, (ub4)OCI_DEFAULT);
        	if (ret != 0)
                {
                        OCIErrorGet(errhp, 1, NULL, &amp;ret, (OraText*)errbuf, sizeof(errbuf), OCI_HTYPE_ERROR);
                        printf("\n%s\n", errbuf);
                        sleep(2);
        		continue;
                }
                else
                {
        		//提交到数据库
        		OCITransCommit(svchp, errhp, OCI_DEFAULT);
                        printf("Delete OK!\n");
                }
        	memset(sql, 0, sizeof(sql));
        	printf("Insert ...\n");
        	strcpy(sql,"insert into user01.tab02 values(1,'test'||sysdate)");
        	OCIStmtPrepare(stmthp, errhp, (text*)sql, strlen(sql), OCI_NTV_SYNTAX, OCI_DEFAULT);
        	ret=OCIStmtExecute(svchp, stmthp, errhp, (ub4)1, (ub4)0, (CONST OCISnapshot*) 0, (OCISnapshot*)0, (ub4)OCI_DEFAULT);
        	if(ret!=0){
        	   OCIErrorGet(errhp, 1, NULL, &amp;ret, (OraText*)errbuf, sizeof(errbuf), OCI_HTYPE_ERROR);
        	   printf("\n%s\n", errbuf);
                   sleep(2);
        	   continue;
        	}
        	else{
        	   // 提交到数据库
        	   OCITransCommit(svchp, errhp, OCI_DEFAULT);
        	   printf("Insert ok!\n");
        	}
                ///************************************************************************/
                ///* 查询表 */
                ///************************************************************************/
                memset(sql, 0, sizeof(sql));
        	printf("Select ...\n");
                strcpy(sql, "select C1,C2 from USER01.TAB02 union select SESS_ID as C1,CLNT_IP AS C2 from v$sessions where state='ACTIVE'");
                /* 准备SQL语句 */
                OCIStmtPrepare(stmthp, errhp, (text*)sql, strlen(sql), OCI_NTV_SYNTAX, OCI_DEFAULT);
                /* 绑定输出列 */
                OCIDefineByPos(stmthp, &amp;defhp[0], errhp, 1, &amp;szc1,sizeof(szc1), SQLT_INT, &amp;ind[0], 0, 0,OCI_DEFAULT);
                OCIDefineByPos(stmthp, &amp;defhp[1], errhp, 2, (ub1*)szc2,sizeof(szc2), SQLT_STR, &amp;ind[1], 0, 0, OCI_DEFAULT);
                //OCIDefineByPos(stmthp, &amp;defhp[2], errhp, 3, (ub1*)szphone,sizeof(szphone), SQLT_STR, &amp;ind[2], 0, 0, OCI_DEFAULT);
                /* 执行SQL语句 */
                ret = OCIStmtExecute(svchp, stmthp, errhp, (ub4)0, 0, NULL, NULL, OCI_DEFAULT);
                if (ret != 0)
                {
                        OCIErrorGet(errhp, 1, NULL, &amp;ret, (OraText*)errbuf, sizeof(errbuf), OCI_HTYPE_ERROR);
                        printf("%s\n", errbuf);
                        sleep(2);
        		continue;
                }
        	else{
                	printf("%-10s%-10s\n", "C1", "C2");
                	while ((OCIStmtFetch(stmthp, errhp, 1, OCI_FETCH_NEXT, OCI_DEFAULT)) != OCI_NO_DATA)
                	{
                        	printf("%-8d", szc1);
                        	printf("%s\n", szc2);
                 	//       printf("%-10s\n", szphone);
                	}
        		printf("\nSelect ok!\n");
        	}
                sleep(2);
	}//结束循环
	closeDB();
        return 0;
</code></pre> 
<ul><li style="text-align:justify;">编译脚本并运行</li></ul> 
<pre><code class="hljs">[root@test OCI]# g++ -o testOci testOci.cpp -I/home/dmdba/dmdbms/include -L/home/dmdba/dmdbms/bin -ldmoci

执行
./testOci
</code></pre> 
<ul><li style="text-align:justify;">断网卡住后进行跟踪</li></ul> 
<p style="margin-left:0;text-align:justify;">pstack查看</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="372" src="https://images2.imgbox.com/db/3b/stsNcCY2_o.jpg" width="1200"></p> 
<p style="margin-left:0;text-align:justify;">通过跟踪发现tcp连接已建立，但一直未断开</p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/74/67/C1cSJR9t_o.png" width="696"> <img alt="" height="60" src="https://images2.imgbox.com/44/08/7Gd2O64v_o.png" width="866"></p> 
<h2> 解决办法</h2> 
<p>修改应用端内核参数</p> 
<pre><code class="hljs">vim /etc/sysctl.conf

net.ipv4.tcp_retries2=3</code></pre> 
<p style="margin-left:0;text-align:justify;">修改后sysctl -p生效</p> 
<p style="margin-left:0;text-align:justify;">再次执行脚本，断网测试，时间缩短为12s，确定断网程序卡住时间过长是因为内核参数导致</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="520" src="https://images2.imgbox.com/5f/96/wV0uwzMY_o.png" width="287"></p> 
<p style="margin-left:0;text-align:justify;">tcp_retries2 ：INTEGER</p> 
<p style="margin-left:0;text-align:justify;">默认值为15</p> 
<p style="margin-left:0;text-align:justify;">在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).</p> 
<p style="margin-left:0;text-align:justify;">更多问题可访问达梦社区：</p> 
<p><a href="https://eco.dameng.com/" rel="nofollow" title="达梦数据库 - 新一代大型通用关系型数据库 | 达梦云适配中心">达梦数据库 - 新一代大型通用关系型数据库 | 达梦云适配中心</a></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2655e88c2d576b479a3794f0914576b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python使用numpy进行排序后返回相应的索引</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0508b926fb176433f4691e37e16bbfc6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java语言写入Excel</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>