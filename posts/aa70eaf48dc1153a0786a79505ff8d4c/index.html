<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>nginx-ingress配置(注解) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="nginx-ingress配置(注解)" />
<meta property="og:description" content="ingress-nginx配置(注解) 注解 您可以将这些Kubernetes批注添加到特定的Ingress对象，以自定义其行为。
小费
注释键和值只能是字符串。其他类型，如布尔或数值必须被引用，即&#34;true&#34;，&#34;false&#34;，&#34;100&#34;。
注意
可以使用--annotations-prefix命令行参数更改注释前缀 ，但默认值为nginx.ingress.kubernetes.io，如下表所述。
Nametypenginx.ingress.kubernetes.io/app-rootstringnginx.ingress.kubernetes.io/affinitycookienginx.ingress.kubernetes.io/affinity-mode&#34;balanced&#34; or &#34;persistent&#34;nginx.ingress.kubernetes.io/auth-realmstringnginx.ingress.kubernetes.io/auth-secretstringnginx.ingress.kubernetes.io/auth-secret-typestringnginx.ingress.kubernetes.io/auth-typebasic or digestnginx.ingress.kubernetes.io/auth-tls-secretstringnginx.ingress.kubernetes.io/auth-tls-verify-depthnumbernginx.ingress.kubernetes.io/auth-tls-verify-clientstringnginx.ingress.kubernetes.io/auth-tls-error-pagestringnginx.ingress.kubernetes.io/auth-tls-pass-certificate-to-upstream&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/auth-urlstringnginx.ingress.kubernetes.io/auth-cache-keystringnginx.ingress.kubernetes.io/auth-cache-durationstringnginx.ingress.kubernetes.io/auth-proxy-set-headersstringnginx.ingress.kubernetes.io/auth-snippetstringnginx.ingress.kubernetes.io/enable-global-auth&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/backend-protocolstringnginx.ingress.kubernetes.io/canary&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/canary-by-headerstringnginx.ingress.kubernetes.io/canary-by-header-valuestringnginx.ingress.kubernetes.io/canary-by-header-patternstringnginx.ingress.kubernetes.io/canary-by-cookiestringnginx.ingress.kubernetes.io/canary-weightnumbernginx.ingress.kubernetes.io/client-body-buffer-sizestringnginx.ingress.kubernetes.io/configuration-snippetstringnginx.ingress.kubernetes.io/custom-http-errors[]intnginx.ingress.kubernetes.io/default-backendstringnginx.ingress.kubernetes.io/enable-cors&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/cors-allow-originstringnginx.ingress.kubernetes.io/cors-allow-methodsstringnginx.ingress.kubernetes.io/cors-allow-headersstringnginx.ingress.kubernetes.io/cors-allow-credentials&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/cors-max-agenumbernginx.ingress.kubernetes.io/force-ssl-redirect&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/from-to-www-redirect&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/http2-push-preload&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/limit-connectionsnumbernginx.ingress.kubernetes.io/limit-rpsnumbernginx.ingress.kubernetes.io/permanent-redirectstringnginx.ingress.kubernetes.io/permanent-redirect-codenumbernginx.ingress.kubernetes.io/temporal-redirectstringnginx.ingress.kubernetes.io/proxy-body-sizestringnginx.ingress.kubernetes.io/proxy-cookie-domainstringnginx.ingress.kubernetes.io/proxy-cookie-pathstringnginx.ingress.kubernetes.io/proxy-connect-timeoutnumbernginx.ingress.kubernetes.io/proxy-send-timeoutnumbernginx.ingress.kubernetes.io/proxy-read-timeoutnumbernginx.ingress.kubernetes.io/proxy-next-upstreamstringnginx.ingress.kubernetes.io/proxy-next-upstream-timeoutnumbernginx.ingress.kubernetes.io/proxy-next-upstream-triesnumbernginx.ingress.kubernetes.io/proxy-request-bufferingstringnginx.ingress.kubernetes.io/proxy-redirect-fromstringnginx.ingress.kubernetes.io/proxy-redirect-tostringnginx.ingress.kubernetes.io/proxy-http-version&#34;1.0&#34; or &#34;1.1&#34;nginx.ingress.kubernetes.io/proxy-ssl-secretstringnginx.ingress.kubernetes.io/proxy-ssl-ciphersstringnginx.ingress.kubernetes.io/proxy-ssl-namestringnginx.ingress.kubernetes.io/proxy-ssl-protocolsstringnginx.ingress.kubernetes.io/proxy-ssl-verifystringnginx.ingress.kubernetes.io/proxy-ssl-verify-depthnumbernginx.ingress.kubernetes.io/enable-rewrite-log&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/rewrite-targetURInginx.ingress.kubernetes.io/satisfystringnginx.ingress.kubernetes.io/server-aliasstringnginx.ingress.kubernetes.io/server-snippetstringnginx.ingress.kubernetes.io/service-upstream&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/session-cookie-namestringnginx.ingress.kubernetes.io/session-cookie-pathstringnginx.ingress.kubernetes.io/session-cookie-change-on-failure&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/session-cookie-samesitestringnginx.ingress.kubernetes.io/session-cookie-conditional-samesite-none&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/ssl-redirect&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/ssl-passthrough&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/upstream-hash-bystringnginx.ingress.kubernetes.io/x-forwarded-prefixstringnginx.ingress.kubernetes.io/load-balancestringnginx.ingress.kubernetes.io/upstream-vhoststringnginx.ingress.kubernetes.io/whitelist-source-rangeCIDRnginx.ingress.kubernetes.io/proxy-bufferingstringnginx.ingress.kubernetes.io/proxy-buffers-numbernumbernginx.ingress.kubernetes.io/proxy-buffer-sizestringnginx.ingress.kubernetes.io/proxy-max-temp-file-sizestringnginx.ingress.kubernetes.io/ssl-ciphersstringnginx.ingress.kubernetes.io/connection-proxy-headerstringnginx.ingress.kubernetes.io/enable-access-log&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/enable-opentracing&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/enable-influxdb&#34;true&#34; or &#34;false&#34;nginx.ingress.kubernetes.io/influxdb-measurementstringnginx.ingress.kubernetes.io/influxdb-portstringnginx.ingress.kubernetes.io/influxdb-hoststringnginx.ingress.kubernetes.io/influxdb-server-namestringnginx.ingress.kubernetes.io/use-regexboolnginx.ingress.kubernetes.io/enable-modsecurityboolnginx.ingress.kubernetes.io/enable-owasp-core-rulesboolnginx.ingress.kubernetes.io/modsecurity-transaction-idstringnginx.ingress.kubernetes.io/modsecurity-snippetstringnginx.ingress.kubernetes.io/mirror-request-bodystringnginx.ingress.kubernetes.io/mirror-targetstring 金丝雀 在某些情况下，您可能希望通过向少量与生产服务不同的服务发送少量请求来“取消”一组新的更改。Canary注释使Ingress规范可以充当路由请求的替代服务，具体取决于所应用的规则。nginx.ingress.kubernetes.io/canary: &#34;true&#34;设置后，可以启用以下用于配置金丝雀的注释：
nginx.ingress.kubernetes.io/canary-by-header：用于通知Ingress将请求路由到Canary Ingress中指定的服务的标头。当请求标头设置always为时，它将被路由到Canary。当标头设置never为时，它将永远不会路由到金丝雀。对于任何其他值，标头将被忽略，并且按优先级将请求与其他金丝雀规则进行比较。
nginx.ingress.kubernetes.io/canary-by-header-value：匹配的报头值，用于通知Ingress将请求路由到Canary Ingress中指定的服务。当请求标头设置为此值时，它将被路由到Canary。对于任何其他标头值，标头将被忽略，并按优先级将请求与其他金丝雀规则进行比较。此注释必须与一起使用。注释是的扩展，nginx.ingress.kubernetes.io/canary-by-header允许自定义标头值，而不使用硬编码值。如果nginx.ingress.kubernetes.io/canary-by-header未定义注释，则没有任何作用。
nginx.ingress.kubernetes.io/canary-by-header-pattern：这与canary-by-header-valuePCRE Regex匹配相同。请注意，canary-by-header-value设置时，此注释将被忽略。当给定的正则表达式在请求处理期间导致错误时，该请求将被视为不匹配。
nginx.ingress.kubernetes.io/canary-by-cookie：用于通知Ingress将请求路由到Canary Ingress中指定的服务的cookie。当cookie值设置always为时，它将被路由到canary。当cookie设置never为时，它将永远不会路由到Canary。对于任何其他值，将忽略cookie，并按优先级将请求与其他canary规则进行比较。
nginx.ingress.kubernetes.io/canary-weight：随机请求的整数百分比（0-100），应将其路由到canary Ingress中指定的服务。权重0表示此Canary规则不会在Canary入口中将任何请求发送到服务。权重为100表示​​所有请求都将发送到Ingress中指定的替代服务。
金丝雀规则按优先级进行评估。优先级如下： canary-by-header -&gt; canary-by-cookie -&gt; canary-weight
请注意，当您将某个入口标记为canary时，除nginx.ingress.kubernetes.io/load-balance和之外，所有其他非canary注释将被忽略（从相应的主要入口继承）nginx.ingress.kubernetes.io/upstream-hash-by。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/aa70eaf48dc1153a0786a79505ff8d4c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-02T17:32:35+08:00" />
<meta property="article:modified_time" content="2020-12-02T17:32:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">nginx-ingress配置(注解)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="ingressnginx_0"></a>ingress-nginx配置(注解)</h2> 
<h2 id="注解">注解</h2> 
<p>您可以将这些Kubernetes批注添加到特定的Ingress对象，以自定义其行为。</p> 
<p>小费</p> 
<p>注释键和值只能是字符串。其他类型，如布尔或数值必须被引用，即<code>"true"</code>，<code>"false"</code>，<code>"100"</code>。</p> 
<p>注意</p> 
<p>可以使用<a href="../../cli-arguments/" rel="nofollow"><code>--annotations-prefix</code>命令行参数</a>更改注释前缀 ，但默认值为<code>nginx.ingress.kubernetes.io</code>，如下表所述。</p> 
<table><thead><tr><th>Name</th><th>type</th></tr></thead><tbody><tr><td><a href="#rewrite" rel="nofollow">nginx.ingress.kubernetes.io/app-root</a></td><td>string</td></tr><tr><td><a href="#session-affinity" rel="nofollow">nginx.ingress.kubernetes.io/affinity</a></td><td>cookie</td></tr><tr><td><a href="#session-affinity" rel="nofollow">nginx.ingress.kubernetes.io/affinity-mode</a></td><td>"balanced" or "persistent"</td></tr><tr><td><a href="#authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-realm</a></td><td>string</td></tr><tr><td><a href="#authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-secret</a></td><td>string</td></tr><tr><td><a href="#authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-secret-type</a></td><td>string</td></tr><tr><td><a href="#authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-type</a></td><td>basic or digest</td></tr><tr><td><a href="#client-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-tls-secret</a></td><td>string</td></tr><tr><td><a href="#client-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-tls-verify-depth</a></td><td>number</td></tr><tr><td><a href="#client-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-tls-verify-client</a></td><td>string</td></tr><tr><td><a href="#client-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-tls-error-page</a></td><td>string</td></tr><tr><td><a href="#client-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-tls-pass-certificate-to-upstream</a></td><td>"true" or "false"</td></tr><tr><td><a href="#external-authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-url</a></td><td>string</td></tr><tr><td><a href="#external-authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-cache-key</a></td><td>string</td></tr><tr><td><a href="#external-authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-cache-duration</a></td><td>string</td></tr><tr><td><a href="#external-authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-proxy-set-headers</a></td><td>string</td></tr><tr><td><a href="#external-authentication" rel="nofollow">nginx.ingress.kubernetes.io/auth-snippet</a></td><td>string</td></tr><tr><td><a href="#external-authentication" rel="nofollow">nginx.ingress.kubernetes.io/enable-global-auth</a></td><td>"true" or "false"</td></tr><tr><td><a href="#backend-protocol" rel="nofollow">nginx.ingress.kubernetes.io/backend-protocol</a></td><td>string</td></tr><tr><td><a href="#canary" rel="nofollow">nginx.ingress.kubernetes.io/canary</a></td><td>"true" or "false"</td></tr><tr><td><a href="#canary" rel="nofollow">nginx.ingress.kubernetes.io/canary-by-header</a></td><td>string</td></tr><tr><td><a href="#canary" rel="nofollow">nginx.ingress.kubernetes.io/canary-by-header-value</a></td><td>string</td></tr><tr><td><a href="#canary" rel="nofollow">nginx.ingress.kubernetes.io/canary-by-header-pattern</a></td><td>string</td></tr><tr><td><a href="#canary" rel="nofollow">nginx.ingress.kubernetes.io/canary-by-cookie</a></td><td>string</td></tr><tr><td><a href="#canary" rel="nofollow">nginx.ingress.kubernetes.io/canary-weight</a></td><td>number</td></tr><tr><td><a href="#client-body-buffer-size" rel="nofollow">nginx.ingress.kubernetes.io/client-body-buffer-size</a></td><td>string</td></tr><tr><td><a href="#configuration-snippet" rel="nofollow">nginx.ingress.kubernetes.io/configuration-snippet</a></td><td>string</td></tr><tr><td><a href="#custom-http-errors" rel="nofollow">nginx.ingress.kubernetes.io/custom-http-errors</a></td><td>[]int</td></tr><tr><td><a href="#default-backend" rel="nofollow">nginx.ingress.kubernetes.io/default-backend</a></td><td>string</td></tr><tr><td><a href="#enable-cors" rel="nofollow">nginx.ingress.kubernetes.io/enable-cors</a></td><td>"true" or "false"</td></tr><tr><td><a href="#enable-cors" rel="nofollow">nginx.ingress.kubernetes.io/cors-allow-origin</a></td><td>string</td></tr><tr><td><a href="#enable-cors" rel="nofollow">nginx.ingress.kubernetes.io/cors-allow-methods</a></td><td>string</td></tr><tr><td><a href="#enable-cors" rel="nofollow">nginx.ingress.kubernetes.io/cors-allow-headers</a></td><td>string</td></tr><tr><td><a href="#enable-cors" rel="nofollow">nginx.ingress.kubernetes.io/cors-allow-credentials</a></td><td>"true" or "false"</td></tr><tr><td><a href="#enable-cors" rel="nofollow">nginx.ingress.kubernetes.io/cors-max-age</a></td><td>number</td></tr><tr><td><a href="#server-side-https-enforcement-through-redirect" rel="nofollow">nginx.ingress.kubernetes.io/force-ssl-redirect</a></td><td>"true" or "false"</td></tr><tr><td><a href="#redirect-fromto-www" rel="nofollow">nginx.ingress.kubernetes.io/from-to-www-redirect</a></td><td>"true" or "false"</td></tr><tr><td><a href="#http2-push-preload" rel="nofollow">nginx.ingress.kubernetes.io/http2-push-preload</a></td><td>"true" or "false"</td></tr><tr><td><a href="#rate-limiting" rel="nofollow">nginx.ingress.kubernetes.io/limit-connections</a></td><td>number</td></tr><tr><td><a href="#rate-limiting" rel="nofollow">nginx.ingress.kubernetes.io/limit-rps</a></td><td>number</td></tr><tr><td><a href="#permanent-redirect" rel="nofollow">nginx.ingress.kubernetes.io/permanent-redirect</a></td><td>string</td></tr><tr><td><a href="#permanent-redirect-code" rel="nofollow">nginx.ingress.kubernetes.io/permanent-redirect-code</a></td><td>number</td></tr><tr><td><a href="#temporal-redirect" rel="nofollow">nginx.ingress.kubernetes.io/temporal-redirect</a></td><td>string</td></tr><tr><td><a href="#custom-max-body-size" rel="nofollow">nginx.ingress.kubernetes.io/proxy-body-size</a></td><td>string</td></tr><tr><td><a href="#proxy-cookie-domain" rel="nofollow">nginx.ingress.kubernetes.io/proxy-cookie-domain</a></td><td>string</td></tr><tr><td><a href="#proxy-cookie-path" rel="nofollow">nginx.ingress.kubernetes.io/proxy-cookie-path</a></td><td>string</td></tr><tr><td><a href="#custom-timeouts" rel="nofollow">nginx.ingress.kubernetes.io/proxy-connect-timeout</a></td><td>number</td></tr><tr><td><a href="#custom-timeouts" rel="nofollow">nginx.ingress.kubernetes.io/proxy-send-timeout</a></td><td>number</td></tr><tr><td><a href="#custom-timeouts" rel="nofollow">nginx.ingress.kubernetes.io/proxy-read-timeout</a></td><td>number</td></tr><tr><td><a href="#custom-timeouts" rel="nofollow">nginx.ingress.kubernetes.io/proxy-next-upstream</a></td><td>string</td></tr><tr><td><a href="#custom-timeouts" rel="nofollow">nginx.ingress.kubernetes.io/proxy-next-upstream-timeout</a></td><td>number</td></tr><tr><td><a href="#custom-timeouts" rel="nofollow">nginx.ingress.kubernetes.io/proxy-next-upstream-tries</a></td><td>number</td></tr><tr><td><a href="#custom-timeouts" rel="nofollow">nginx.ingress.kubernetes.io/proxy-request-buffering</a></td><td>string</td></tr><tr><td><a href="#proxy-redirect" rel="nofollow">nginx.ingress.kubernetes.io/proxy-redirect-from</a></td><td>string</td></tr><tr><td><a href="#proxy-redirect" rel="nofollow">nginx.ingress.kubernetes.io/proxy-redirect-to</a></td><td>string</td></tr><tr><td><a href="#proxy-http-version" rel="nofollow">nginx.ingress.kubernetes.io/proxy-http-version</a></td><td>"1.0" or "1.1"</td></tr><tr><td><a href="#backend-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/proxy-ssl-secret</a></td><td>string</td></tr><tr><td><a href="#backend-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/proxy-ssl-ciphers</a></td><td>string</td></tr><tr><td><a href="#backend-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/proxy-ssl-name</a></td><td>string</td></tr><tr><td><a href="#backend-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/proxy-ssl-protocols</a></td><td>string</td></tr><tr><td><a href="#backend-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/proxy-ssl-verify</a></td><td>string</td></tr><tr><td><a href="#backend-certificate-authentication" rel="nofollow">nginx.ingress.kubernetes.io/proxy-ssl-verify-depth</a></td><td>number</td></tr><tr><td><a href="#enable-rewrite-log" rel="nofollow">nginx.ingress.kubernetes.io/enable-rewrite-log</a></td><td>"true" or "false"</td></tr><tr><td><a href="#rewrite" rel="nofollow">nginx.ingress.kubernetes.io/rewrite-target</a></td><td>URI</td></tr><tr><td><a href="#satisfy" rel="nofollow">nginx.ingress.kubernetes.io/satisfy</a></td><td>string</td></tr><tr><td><a href="#server-alias" rel="nofollow">nginx.ingress.kubernetes.io/server-alias</a></td><td>string</td></tr><tr><td><a href="#server-snippet" rel="nofollow">nginx.ingress.kubernetes.io/server-snippet</a></td><td>string</td></tr><tr><td><a href="#service-upstream" rel="nofollow">nginx.ingress.kubernetes.io/service-upstream</a></td><td>"true" or "false"</td></tr><tr><td><a href="#cookie-affinity" rel="nofollow">nginx.ingress.kubernetes.io/session-cookie-name</a></td><td>string</td></tr><tr><td><a href="#cookie-affinity" rel="nofollow">nginx.ingress.kubernetes.io/session-cookie-path</a></td><td>string</td></tr><tr><td><a href="#cookie-affinity" rel="nofollow">nginx.ingress.kubernetes.io/session-cookie-change-on-failure</a></td><td>"true" or "false"</td></tr><tr><td><a href="#cookie-affinity" rel="nofollow">nginx.ingress.kubernetes.io/session-cookie-samesite</a></td><td>string</td></tr><tr><td><a href="#cookie-affinity" rel="nofollow">nginx.ingress.kubernetes.io/session-cookie-conditional-samesite-none</a></td><td>"true" or "false"</td></tr><tr><td><a href="#server-side-https-enforcement-through-redirect" rel="nofollow">nginx.ingress.kubernetes.io/ssl-redirect</a></td><td>"true" or "false"</td></tr><tr><td><a href="#ssl-passthrough" rel="nofollow">nginx.ingress.kubernetes.io/ssl-passthrough</a></td><td>"true" or "false"</td></tr><tr><td><a href="#custom-nginx-upstream-hashing" rel="nofollow">nginx.ingress.kubernetes.io/upstream-hash-by</a></td><td>string</td></tr><tr><td><a href="#x-forwarded-prefix-header" rel="nofollow">nginx.ingress.kubernetes.io/x-forwarded-prefix</a></td><td>string</td></tr><tr><td><a href="#custom-nginx-load-balancing" rel="nofollow">nginx.ingress.kubernetes.io/load-balance</a></td><td>string</td></tr><tr><td><a href="#custom-nginx-upstream-vhost" rel="nofollow">nginx.ingress.kubernetes.io/upstream-vhost</a></td><td>string</td></tr><tr><td><a href="#whitelist-source-range" rel="nofollow">nginx.ingress.kubernetes.io/whitelist-source-range</a></td><td>CIDR</td></tr><tr><td><a href="#proxy-buffering" rel="nofollow">nginx.ingress.kubernetes.io/proxy-buffering</a></td><td>string</td></tr><tr><td><a href="#proxy-buffers-number" rel="nofollow">nginx.ingress.kubernetes.io/proxy-buffers-number</a></td><td>number</td></tr><tr><td><a href="#proxy-buffer-size" rel="nofollow">nginx.ingress.kubernetes.io/proxy-buffer-size</a></td><td>string</td></tr><tr><td><a href="#proxy-max-temp-file-size" rel="nofollow">nginx.ingress.kubernetes.io/proxy-max-temp-file-size</a></td><td>string</td></tr><tr><td><a href="#ssl-ciphers" rel="nofollow">nginx.ingress.kubernetes.io/ssl-ciphers</a></td><td>string</td></tr><tr><td><a href="#connection-proxy-header" rel="nofollow">nginx.ingress.kubernetes.io/connection-proxy-header</a></td><td>string</td></tr><tr><td><a href="#enable-access-log" rel="nofollow">nginx.ingress.kubernetes.io/enable-access-log</a></td><td>"true" or "false"</td></tr><tr><td><a href="#enable-opentracing" rel="nofollow">nginx.ingress.kubernetes.io/enable-opentracing</a></td><td>"true" or "false"</td></tr><tr><td><a href="#influxdb" rel="nofollow">nginx.ingress.kubernetes.io/enable-influxdb</a></td><td>"true" or "false"</td></tr><tr><td><a href="#influxdb" rel="nofollow">nginx.ingress.kubernetes.io/influxdb-measurement</a></td><td>string</td></tr><tr><td><a href="#influxdb" rel="nofollow">nginx.ingress.kubernetes.io/influxdb-port</a></td><td>string</td></tr><tr><td><a href="#influxdb" rel="nofollow">nginx.ingress.kubernetes.io/influxdb-host</a></td><td>string</td></tr><tr><td><a href="#influxdb" rel="nofollow">nginx.ingress.kubernetes.io/influxdb-server-name</a></td><td>string</td></tr><tr><td><a href="#use-regex" rel="nofollow">nginx.ingress.kubernetes.io/use-regex</a></td><td>bool</td></tr><tr><td><a href="#modsecurity" rel="nofollow">nginx.ingress.kubernetes.io/enable-modsecurity</a></td><td>bool</td></tr><tr><td><a href="#modsecurity" rel="nofollow">nginx.ingress.kubernetes.io/enable-owasp-core-rules</a></td><td>bool</td></tr><tr><td><a href="#modsecurity" rel="nofollow">nginx.ingress.kubernetes.io/modsecurity-transaction-id</a></td><td>string</td></tr><tr><td><a href="#modsecurity" rel="nofollow">nginx.ingress.kubernetes.io/modsecurity-snippet</a></td><td>string</td></tr><tr><td><a href="#mirror" rel="nofollow">nginx.ingress.kubernetes.io/mirror-request-body</a></td><td>string</td></tr><tr><td><a href="#mirror" rel="nofollow">nginx.ingress.kubernetes.io/mirror-target</a></td><td>string</td></tr></tbody></table> 
<h4 id="金丝雀">金丝雀</h4> 
<p>在某些情况下，您可能希望通过向少量与生产服务不同的服务发送少量请求来“取消”一组新的更改。Canary注释使Ingress规范可以充当路由请求的替代服务，具体取决于所应用的规则。<code>nginx.ingress.kubernetes.io/canary: "true"</code>设置后，可以启用以下用于配置金丝雀的注释：</p> 
<ul><li> <p><code>nginx.ingress.kubernetes.io/canary-by-header</code>：用于通知Ingress将请求路由到Canary Ingress中指定的服务的标头。当请求标头设置<code>always</code>为时，它将被路由到Canary。当标头设置<code>never</code>为时，它将永远不会路由到金丝雀。对于任何其他值，标头将被忽略，并且按优先级将请求与其他金丝雀规则进行比较。</p> </li><li> <p><code>nginx.ingress.kubernetes.io/canary-by-header-value</code>：匹配的报头值，用于通知Ingress将请求路由到Canary Ingress中指定的服务。当请求标头设置为此值时，它将被路由到Canary。对于任何其他标头值，标头将被忽略，并按优先级将请求与其他金丝雀规则进行比较。此注释必须与一起使用。注释是的扩展，<code>nginx.ingress.kubernetes.io/canary-by-header</code>允许自定义标头值，而不使用硬编码值。如果<code>nginx.ingress.kubernetes.io/canary-by-header</code>未定义注释，则没有任何作用。</p> </li><li> <p><code>nginx.ingress.kubernetes.io/canary-by-header-pattern</code>：这与<code>canary-by-header-value</code>PCRE Regex匹配相同。请注意，<code>canary-by-header-value</code>设置时，此注释将被忽略。当给定的正则表达式在请求处理期间导致错误时，该请求将被视为不匹配。</p> </li><li> <p><code>nginx.ingress.kubernetes.io/canary-by-cookie</code>：用于通知Ingress将请求路由到Canary Ingress中指定的服务的cookie。当cookie值设置<code>always</code>为时，它将被路由到canary。当cookie设置<code>never</code>为时，它将永远不会路由到Canary。对于任何其他值，将忽略cookie，并按优先级将请求与其他canary规则进行比较。</p> </li><li> <p><code>nginx.ingress.kubernetes.io/canary-weight</code>：随机请求的整数百分比（0-100），应将其路由到canary Ingress中指定的服务。权重0表示此Canary规则不会在Canary入口中将任何请求发送到服务。权重为100表示​​所有请求都将发送到Ingress中指定的替代服务。</p> </li></ul> 
<p>金丝雀规则按优先级进行评估。优先级如下： <code>canary-by-header -&gt; canary-by-cookie -&gt; canary-weight</code></p> 
<p><strong>请注意</strong>，当您将某个入口标记为canary时，除<code>nginx.ingress.kubernetes.io/load-balance</code>和之外，所有其他非canary注释将被忽略（从相应的主要入口继承）<code>nginx.ingress.kubernetes.io/upstream-hash-by</code>。</p> 
<p><strong>已知局限性</strong></p> 
<p>目前，每个Ingress规则最多可以应用一个Canary Ingress。</p> 
<h4 id="rewrite">Rewrite</h4> 
<p>在某些情况下，后端服务中公开的URL与Ingress规则中指定的路径不同。如果没有重写，则任何请求都将返回404。将注释设置<code>nginx.ingress.kubernetes.io/rewrite-target</code>为服务所需的路径。</p> 
<p>如果应用程序根目录暴露在其他路径中，并且需要重定向，请设置注释<code>nginx.ingress.kubernetes.io/app-root</code>以重定向的请求<code>/</code>。</p> 
<p>例</p> 
<p>请检查<a href="../../../examples/rewrite/" rel="nofollow">重写</a>示例。</p> 
<h4 id="session-affinity">Session Affinity</h4> 
<p>注释<code>nginx.ingress.kubernetes.io/affinity</code>在Ingress的所有上游中启用和设置相似性类型。这样，请求将始终定向到同一上游服务器。NGINX唯一可用的相似性类型是<code>cookie</code>。</p> 
<p>注释<code>nginx.ingress.kubernetes.io/affinity-mode</code>定义了会话的粘性。<code>balanced</code>如果将部署规模扩大，则将此选项设置为（默认）将重新分配一些会话，从而重新平衡服务器上的负载。将此设置为<code>persistent</code>不会重新平衡与新服务器的会话，因此提供了最大的粘性。</p> 
<p>注意</p> 
<p>如果为一个主机定义了多个Ingress <code>nginx.ingress.kubernetes.io/affinity: cookie</code>，并且至少一个Ingress使用，则只有Ingress使用的路径<code>nginx.ingress.kubernetes.io/affinity</code>将使用会话Cookie相似性。通过随机选择后端服务器，可以在主机的其他入口定义的所有路径进行负载均衡。</p> 
<p>例</p> 
<p>请检查<a href="../../../examples/affinity/cookie/" rel="nofollow">相似性</a>示例。</p> 
<h5 id="cookie-affinity">Cookie Affinity</h5> 
<p>如果使用<code>cookie</code>亲缘关系类型，则还可以指定将用于通过注释路由请求的cookie的名称<code>nginx.ingress.kubernetes.io/session-cookie-name</code>。默认是创建一个名为“ INGRESSCOOKIE”的cookie。</p> 
<p>NGINX批注<code>nginx.ingress.kubernetes.io/session-cookie-path</code>定义将在cookie上设置的路径。除非注释<code>nginx.ingress.kubernetes.io/use-regex</code>设置为true，否则这是可选的。会话Cookie路径不支持正则表达式。</p> 
<p>使用<code>nginx.ingress.kubernetes.io/session-cookie-samesite</code>的应用<code>SameSite</code>属性粘饼干。浏览器接受的值是<code>None</code>，<code>Lax</code>和<code>Strict</code>。某些浏览器会拒绝带有的cookie <code>SameSite=None</code>，包括在<code>SameSite=None</code>规范之前创建的cookie （例如Chrome 5X）。其他浏览器错误地将<code>SameSite=None</code>cookie视为<code>SameSite=Strict</code>（例如，在OSX 14上运行的Safari）。要从<code>SameSite=None</code>浏览器中忽略这些不兼容的内容，请添加注释<code>nginx.ingress.kubernetes.io/session-cookie-conditional-samesite-none: "true"</code>。</p> 
<h4 id="认证方式">认证方式</h4> 
<p>可以添加身份验证，并在Ingress规则中添加其他注释。身份验证的来源是包含用户名和密码的机密。</p> 
<p>注释是：</p> 
<p><code>nginx.ingress.kubernetes.io/auth-type: [basic|digest]</code></p> 
<p>指示<a href="https://tools.ietf.org/html/rfc2617" rel="nofollow">HTTP身份验证类型：基本或摘要访问身份验证</a>。</p> 
<p><code>nginx.ingress.kubernetes.io/auth-secret: secretName</code></p> 
<p>Secret的名称，其中包含用户名和密码，这些用户名和密码被授予<code>path</code>对Ingress规则中定义的的访问权限。此注释还接受替代形式“名称空间/ secretName”，在这种情况下，秘密查找在引用的名称空间而不是Ingress名称空间中执行。</p> 
<p><code>nginx.ingress.kubernetes.io/auth-secret-type: [auth-file|auth-map]</code></p> 
<p>本<code>auth-secret</code>可以有两种形式：</p> 
<ul><li><code>auth-file</code>-默认情况下，密钥<code>auth</code>内的htpasswd文件为秘密</li><li><code>auth-map</code> -机密密钥是用户名，值是哈希密码</li></ul> 
<p><code>nginx.ingress.kubernetes.io/auth-realm: "realm string"</code></p> 
<p>例</p> 
<p>请检查<a href="../../../examples/auth/basic/" rel="nofollow">身份验证</a>示例。</p> 
<h4 id="自定义nginx上游哈希">自定义NGINX上游哈希</h4> 
<p>NGINX支持客户端-服务器映射的负载平衡，该映射基于给定密钥的<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash" rel="nofollow">一致哈希</a>值。键可以包含文本，变量或其任何组合。此功能允许请求粘性而不是客户端IP或cookie。将使用<a href="http://www.last.fm/user/RJ/journal/2007/04/10/392555/" rel="nofollow">ketama</a>一致的哈希方法，该方法确保在上游组更改时仅将少数密钥重新映射到不同的服务器。</p> 
<p>上游哈希的一种特殊模式称为子集。在这种模式下，上游服务器被分组为子集，粘性通过将密钥映射到子集而不是单个上游服务器来工作。从选定的粘性子集中随机选择特定的服务器。它提供了粘性和负载分配之间的平衡。</p> 
<p>要为后端启用一致的哈希：</p> 
<p><code>nginx.ingress.kubernetes.io/upstream-hash-by</code>：nginx变量，文本值或它们的任意组合，以用于一致的哈希。例如<code>nginx.ingress.kubernetes.io/upstream-hash-by: "$request_uri"</code>，通过当前请求URI一致地哈希上游请求。</p> 
<p>可以启用“子集”散列设置<code>nginx.ingress.kubernetes.io/upstream-hash-by-subset</code>：“ true”。这会将请求映射到节点的子集，而不是单个请求。<code>upstream-hash-by-subset-size</code>确定每个子集的大小（默认为3）。</p> 
<p>请检查<a href="../../../examples/chashsubset/deployment.yaml" rel="nofollow">chashsubset</a>示例。</p> 
<h4 id="自定义nginx负载平衡">自定义NGINX负载平衡</h4> 
<p>这与<a href="../configmap/#load-balance" rel="nofollow"><code>load-balance</code>ConfigMap中的</a>类似，但是每个入口配置负载平衡算法。</p> 
<blockquote> 
 <p>请注意，<code>nginx.ingress.kubernetes.io/upstream-hash-by</code>优先于此。如果<code>nginx.ingress.kubernetes.io/upstream-hash-by</code>未设置，则我们将退回到使用全局配置的负载平衡算法。</p> 
</blockquote> 
<h4 id="自定义nginx上游虚拟主机">自定义NGINX上游虚拟主机</h4> 
<p>通过此配置设置，您可以在以下语句中控制host的值：<code>proxy_set_header Host $host</code>，它是位置块的一部分。如果您需要通过以外的方式调用上游服务器，这将非常有用<code>$host</code>。</p> 
<h4 id="客户端证书认证">客户端证书认证</h4> 
<p>可以使用“入口规则”中的附加注释来启用“客户端证书认证”。</p> 
<p>注释是：</p> 
<ul><li><code>nginx.ingress.kubernetes.io/auth-tls-secret: secretName</code>：包含完整的证书颁发机构链的密钥的名称，该链<code>ca.crt</code>可以针对此Ingress进行身份验证。此注释还接受替代形式“名称空间/ secretName”，在这种情况下，秘密查找在引用的名称空间而不是Ingress名称空间中执行。</li><li><code>nginx.ingress.kubernetes.io/auth-tls-verify-depth</code>：提供的客户证书和证书颁发机构链之间的验证深度。</li><li><code>nginx.ingress.kubernetes.io/auth-tls-verify-client</code>：启用客户端证书的验证。</li><li><code>nginx.ingress.kubernetes.io/auth-tls-error-page</code>：如果发生证书身份验证错误，应重定向用户的URL /页面</li><li><code>nginx.ingress.kubernetes.io/auth-tls-pass-certificate-to-upstream</code>：指示是否应将收到的证书传递给上游服务器。默认情况下是禁用的。</li></ul> 
<p>例</p> 
<p>请检查<a href="../../../examples/auth/client-certs/" rel="nofollow">客户端证书</a>示例。</p> 
<p>注意</p> 
<p>Cloudflare中<strong>无法</strong>使用带有客户端身份验证的TLS，<strong>这</strong>可能会导致意外行为。</p> 
<p>Cloudflare仅允许使用Authenticated Origin Pulls，并且需要使用其自己的证书：<a href="https://blog.cloudflare.com/protecting-the-origin-with-tls-authenticated-origin-pulls/" rel="nofollow">https</a> : <a href="https://blog.cloudflare.com/protecting-the-origin-with-tls-authenticated-origin-pulls/" rel="nofollow">//blog.cloudflare.com/protecting-the-origin-with-tls-authenticated-origin-pulls/</a></p> 
<p>仅允许通过身份验证的原产拉取，并且可以按照其教程进行配置：<a href="https://support.cloudflare.com/hc/en-us/articles/204494148-Setting-up-NGINX-to-use-TLS-Authenticated-Origin-Pulls" rel="nofollow">https</a> : <a href="https://support.cloudflare.com/hc/en-us/articles/204494148-Setting-up-NGINX-to-use-TLS-Authenticated-Origin-Pulls" rel="nofollow">//support.cloudflare.com/hc/en-us/articles/204494148-Setting-up-NGINX-to-use-TLS-Authenticated-Origin -拉</a></p> 
<h4 id="后端证书认证">后端证书认证</h4> 
<p>使用入口规则中的附加注释，可以使用证书对代理的HTTPS后端进行身份验证。</p> 
<ul><li><code>nginx.ingress.kubernetes.io/proxy-ssl-secret: secretName</code>：使用证书<code>tls.crt</code>（<code>tls.key</code>PEM格式的密钥）指定用于对代理HTTPS服务器进行身份验证的密钥。它还应包含<code>ca.crt</code>PEM格式的受信任CA证书，该证书用于验证代理HTTPS服务器的证书。此注释还接受替代形式“名称空间/ secretName”，在这种情况下，秘密查找在引用的名称空间而不是Ingress名称空间中执行。</li><li><code>nginx.ingress.kubernetes.io/proxy-ssl-verify</code>：启用或禁用对代理HTTPS服务器证书的验证。（默认值：关闭）</li><li><code>nginx.ingress.kubernetes.io/proxy-ssl-verify-depth</code>：设置代理HTTPS服务器证书链中的验证深度。（默认值：1）</li><li><code>nginx.ingress.kubernetes.io/proxy-ssl-ciphers</code>：指定对代理HTTPS服务器的请求的启用<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ssl_ciphers" rel="nofollow">密码</a>。密码以OpenSSL库可以理解的格式指定。</li><li><code>nginx.ingress.kubernetes.io/proxy-ssl-name</code>：允许设置<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ssl_name" rel="nofollow">proxy_ssl_name</a>。这允许覆盖用于验证代理HTTPS服务器的证书的服务器名称。建立与代理HTTPS服务器的连接时，也会通过SNI传递此值。</li><li><code>nginx.ingress.kubernetes.io/proxy-ssl-protocols</code>：启用对代理HTTPS服务器的请求的指定<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ssl_protocols" rel="nofollow">协议</a>。</li></ul> 
<h4 id="配置片段">配置片段</h4> 
<p>使用此注释，您可以将其他配置添加到NGINX位置。例如：</p> 
<p><code>nginx.ingress.kubernetes.io/configuration-snippet: | more_set_headers "Request-Id: $req_id";</code></p> 
<h4 id="自定义http错误">自定义HTTP错误</h4> 
<p>就像<a href="../configmap/#custom-http-errors" rel="nofollow"><code>custom-http-errors</code></a>ConfigMap中的值一样，此批注将设置NGINX <code>proxy-intercept-errors</code>，但仅针对与此入口相关联的NGINX位置。如果在入口上指定了<a href="#default-backend" rel="nofollow">默认后端注释</a>，则错误将路由到该注释的默认后端服务（而不是全局默认后端）。不同的入口可以指定不同的错误代码集。即使多个入口对象共享相同的主机名，此注释也可以用于为每个入口截取不同的错误代码（例如，如果每个路径在不同的入口上，则对于同一主机名上的不同路径将截取不同的错误代码） 。如果<code>custom-http-errors</code> 也是全局指定的，在此批注中指定的错误值将覆盖给定入口的主机名和路径的全局值。</p> 
<p>用法示例：</p> 
<p><code>nginx.ingress.kubernetes.io/custom-http-errors: "404,415"</code></p> 
<h4 id="默认后端">默认后端</h4> 
<p>此批注具有<code>nginx.ingress.kubernetes.io/default-backend: &lt;svc name&gt;</code>指定自定义默认后端的形式。这<code>&lt;svc name&gt;</code>是对您在其中应用此批注的相同名称空间中的服务的引用。此注释将覆盖全局默认后端。</p> 
<p>当Ingress规则中的服务没有活动的端点时，将处理该服务的响应。如果同时设置了此注释和<a href="#custom-http-errors" rel="nofollow">custom-http-errors注释，</a>它还将处理错误响应。</p> 
<h4 id="启用cors">启用CORS</h4> 
<p>要在Ingress规则中启用跨域资源共享（CORS），请添加注释 <code>nginx.ingress.kubernetes.io/enable-cors: "true"</code>。这将在服务器位置中添加一个部分以启用此功能。</p> 
<p>可以使用以下注释来控制CORS：</p> 
<ul><li> <p><code>nginx.ingress.kubernetes.io/cors-allow-methods</code> 控制接受哪些方法。这是一个多值字段，以“，”分隔，仅接受字母（大写和小写）。</p> </li><li> <p>默认： <code>GET, PUT, POST, DELETE, PATCH, OPTIONS</code></p> </li><li> <p>例： <code>nginx.ingress.kubernetes.io/cors-allow-methods: "PUT, GET, POST, OPTIONS"</code></p> </li><li> <p><code>nginx.ingress.kubernetes.io/cors-allow-headers</code> 控制接受哪些标题。这是一个多值字段，以“，”分隔，并接受字母，数字，_和-。</p> </li><li> <p>默认： <code>DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization</code></p> </li><li> <p>例： <code>nginx.ingress.kubernetes.io/cors-allow-headers: "X-Forwarded-For, X-app123-XPTO"</code></p> </li><li> <p><code>nginx.ingress.kubernetes.io/cors-allow-origin</code> 控制CORS接受的原产地。这是一个单字段值，格式如下：<code>http(s)://origin-site.com</code>或<code>http(s)://origin-site.com:port</code></p> </li><li> <p>默认： <code>*</code></p> </li><li> <p>例： <code>nginx.ingress.kubernetes.io/cors-allow-origin: "https://origin-site.com:4443"</code></p> </li><li> <p><code>nginx.ingress.kubernetes.io/cors-allow-credentials</code> 控制在CORS操作期间是否可以传递凭据。</p> </li><li> <p>默认： <code>true</code></p> </li><li> <p>例： <code>nginx.ingress.kubernetes.io/cors-allow-credentials: "false"</code></p> </li><li> <p><code>nginx.ingress.kubernetes.io/cors-max-age</code> 控制可以将预检请求缓存多长时间。默认值：<code>1728000</code> 示例：<code>nginx.ingress.kubernetes.io/cors-max-age: 600</code></p> </li></ul> 
<p>注意</p> 
<p>有关更多信息，请参见<a href="https://enable-cors.org/server_nginx.html" rel="nofollow">https://enable-cors.org</a></p> 
<h4 id="http2推送预加载">HTTP2推送预加载。</h4> 
<p>启用将“链接”响应标题字段中指定的预加载链接自动转换为推送请求的功能。</p> 
<p>例</p> 
<ul><li><code>nginx.ingress.kubernetes.io/http2-push-preload: "true"</code></li></ul> 
<h4 id="服务器别名">服务器别名</h4> 
<p>允许使用注解在NGINX配置的服务器定义中定义一个或多个别名<code>nginx.ingress.kubernetes.io/server-alias: "&lt;alias 1&gt;,&lt;alias 2&gt;"</code>。这将创建具有相同配置的服务器，但是会向<code>server_name</code>指令添加新值。</p> 
<p>注意</p> 
<p>服务器别名不能与现有服务器的主机名冲突。如果是这样，服务器别名注释将被忽略。如果创建了服务器别名，然后又创建了具有相同主机名的新服务器，则新服务器配置将取代别名配置。</p> 
<p>欲了解更多信息，请参阅<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#server_name" rel="nofollow">该<code>server_name</code>文档</a>。</p> 
<h4 id="server-snippet段">Server Snippet段</h4> 
<p>使用注释<code>nginx.ingress.kubernetes.io/server-snippet</code>，可以在服务器配置块中添加自定义配置。</p> 
<p>`apiVersion: networking.k8s.io/v1beta1<br> kind: Ingress<br> metadata:<br> annotations:<br> nginx.ingress.kubernetes.io/server-snippet: |<br> set $agentflag 0;</p> 
<pre><code>    if ($http_user_agent ~* "(Mobile)" ){
      set $agentflag 1;
    }
</code><pre><code>if ( $agentflag = 1 ) {
  return 301 https://m.example.com;
}` 
</code></pre>
</pre> 
<p></p> 
<p>注意</p> 
<p>每个主机只能使用一次此注释。</p> 
<h4 id="客户端主体缓冲区大小">客户端主体缓冲区大小</h4> 
<p>设置缓冲区大小，以读取每个位置的客户端请求正文。如果请求主体大于缓冲区，则将整个主体或仅将其一部分写入临时文件。默认情况下，缓冲区大小等于两个内存页。在x86，其他32位平台和x86-64上为8K。在其他64位平台上，通常为16K。此注释将应用于入口规则中提供的每个位置。</p> 
<p>注意</p> 
<p>注释值必须以Nginx可以理解的格式给出。</p> 
<p>例</p> 
<ul><li><code>nginx.ingress.kubernetes.io/client-body-buffer-size: "1000"</code> ＃1000字节</li><li><code>nginx.ingress.kubernetes.io/client-body-buffer-size: 1k</code> ＃1千字节</li><li><code>nginx.ingress.kubernetes.io/client-body-buffer-size: 1K</code> ＃1千字节</li><li><code>nginx.ingress.kubernetes.io/client-body-buffer-size: 1m</code> ＃1兆字节</li><li><code>nginx.ingress.kubernetes.io/client-body-buffer-size: 1M</code> ＃1兆字节</li></ul> 
<p>有关更多信息，请参见<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" rel="nofollow">http://nginx.org</a></p> 
<h4 id="外部认证">外部认证</h4> 
<p>要使用提供身份验证的现有服务，可以对Ingress规则进行注释，<code>nginx.ingress.kubernetes.io/auth-url</code>以指示应将HTTP请求发送到的URL。</p> 
<p><code>nginx.ingress.kubernetes.io/auth-url: "URL to the authentication service"</code></p> 
<p>另外，可以设置：</p> 
<ul><li><code>nginx.ingress.kubernetes.io/auth-method</code>： <code>&lt;Method&gt;</code>指定要使用的HTTP方法。</li><li><code>nginx.ingress.kubernetes.io/auth-signin</code>： <code>&lt;SignIn_URL&gt;</code>指定错误页面的位置。</li><li><code>nginx.ingress.kubernetes.io/auth-response-headers</code>： <code>&lt;Response_Header_1, ..., Response_Header_n&gt;</code>指定在身份验证请求完成后传递给后端的标头。</li><li><code>nginx.ingress.kubernetes.io/auth-proxy-set-headers</code>： <code>&lt;ConfigMap&gt;</code>ConfigMap的名称，该名称指定要传递给身份验证服务的标头</li><li><code>nginx.ingress.kubernetes.io/auth-request-redirect</code>： <code>&lt;Request_Redirect_URL&gt;</code> 指定X-Auth-Request-Redirect标头值。</li><li><code>nginx.ingress.kubernetes.io/auth-cache-key</code>： <code>&lt;Cache_Key&gt;</code>这将启用对身份验证请求的缓存。指定身份验证响应的查找键。例如<code>$remote_user$http_authorization</code>。每个服务器和位置都有其自己的密钥空间。因此，缓存的响应仅在按服务器和按位置的基础上有效。</li><li><code>nginx.ingress.kubernetes.io/auth-cache-duration</code>： <code>&lt;Cache_duration&gt;</code>根据身份验证响应的响应代码（例如）指定身份验证响应的缓存时间<code>200 202 30m</code>。有关详细信息，请参见<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_valid" rel="nofollow">proxy_cache_valid</a>。您可以指定多个逗号分隔的值：<code>200 202 10m, 401 5m</code>。默认为<code>200 202 401 5m</code>。</li><li><code>nginx.ingress.kubernetes.io/auth-snippet</code>： <code>&lt;Auth_Snippet&gt;</code>指定用于外部身份验证的自定义代码段，例如</li></ul> 
<p><code>nginx.ingress.kubernetes.io/auth-url: http://foo.com/external-auth nginx.ingress.kubernetes.io/auth-snippet: | proxy_set_header Foo-Header 42;</code></p> 
<blockquote> 
 <p>注意：<code>nginx.ingress.kubernetes.io/auth-snippet</code>是可选注释。但是，它只能与结合使用<code>nginx.ingress.kubernetes.io/auth-url</code>，如果<code>nginx.ingress.kubernetes.io/auth-url</code>未设置，则将被忽略</p> 
</blockquote> 
<p>例</p> 
<p>请检查<a href="../../../examples/auth/external-auth/" rel="nofollow">external-auth</a>示例。</p> 
<h5 id="全局外部认证">全局外部认证</h5> 
<p>默认情况下，如果<code>global-auth-url</code>在NGINX ConfigMap中设置，则控制器会将所有请求重定向到提供身份验证的现有服务。如果您想为该入口禁用此行为，则可以<code>enable-global-auth: "false"</code>在NGINX ConfigMap中使用。 <code>nginx.ingress.kubernetes.io/enable-global-auth</code>：指示是否应将GlobalExternalAuth配置应用于此Ingress规则。默认值设置为<code>"true"</code>。</p> 
<p>注意</p> 
<p>有关更多信息，请参见<a href="../configmap/#global-auth-url" rel="nofollow">global-auth-url</a>。</p> 
<h4 id="限速">限速</h4> 
<p>这些注释定义了对连接和传输速率的限制。这些可以用来减轻<a href="https://www.nginx.com/blog/mitigating-ddos-attacks-with-nginx-and-nginx-plus" rel="nofollow">DDoS攻击</a>。</p> 
<ul><li><code>nginx.ingress.kubernetes.io/limit-connections</code>：单个IP地址允许的并发连接数。超出此限制时，将返回503错误。</li><li><code>nginx.ingress.kubernetes.io/limit-rps</code>：每秒从给定IP接受的请求数。突发限制设置为限制的5倍。当客户端超过此限制时， <a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#limit-req-status-code" rel="nofollow">将</a> 返回<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#limit-req-status-code" rel="nofollow">limit-req-status-code</a> <strong><em>默认值：</em></strong> 503。</li><li><code>nginx.ingress.kubernetes.io/limit-rpm</code>：每分钟从给定IP接受的请求数。突发限制设置为限制的5倍。当客户端超过此限制时， <a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#limit-req-status-code" rel="nofollow">将</a> 返回<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#limit-req-status-code" rel="nofollow">limit-req-status-code</a> <strong><em>默认值：</em></strong> 503。</li><li><code>nginx.ingress.kubernetes.io/limit-rate-after</code>：初始千字节数，之后将进一步限制对给定连接的响应的进一步传输。必须在启用<a href="#proxy-buffering" rel="nofollow">代理缓冲的情况</a>下使用此功能。</li><li><code>nginx.ingress.kubernetes.io/limit-rate</code>：每秒允许发送到给定连接的千字节数。零值禁用速率限制。必须在启用<a href="#proxy-buffering" rel="nofollow">代理缓冲的情况</a>下使用此功能。</li><li><code>nginx.ingress.kubernetes.io/limit-whitelist</code>：客户端IP源范围要从速率限制中排除。该值是逗号分隔的CIDR列表。</li></ul> 
<p>如果你在一个单一的入口规则指定多个注释，限制在顺序应用<code>limit-connections</code>，<code>limit-rpm</code>，<code>limit-rps</code>。</p> 
<p>要为所有Ingress规则全局配置设置，可以在<a href="../configmap/#limit-rate" rel="nofollow">NGINX ConfigMap中</a>设置<code>limit-rate-after</code>和<code>limit-rate</code>值。在Ingress注释中设置的值将覆盖全局设置。<a href="../configmap/#limit-rate" rel="nofollow"></a></p> 
<p>当启用<a href="../configmap/#use-forwarded-headers" rel="nofollow">use-forwarded-header</a>时，将基于<a href="../configmap/#use-proxy-protocol" rel="nofollow">PROXY协议</a>的使用或从<code>X-Forwarded-For</code>标头值设置客户端IP地址。<a href="../configmap/#use-forwarded-headers" rel="nofollow"></a></p> 
<h4 id="永久重定向">永久重定向</h4> 
<p>此注释允许返回永久重定向，而不是向上游发送数据。例如<code>nginx.ingress.kubernetes.io/permanent-redirect: https://www.google.com</code>，将所有内容重定向到Google。</p> 
<h4 id="永久重定向码">永久重定向码</h4> 
<p>此注释使您可以修改用于永久重定向的状态代码。例如，<code>nginx.ingress.kubernetes.io/permanent-redirect-code: '308'</code>将以308返回您的永久重定向。</p> 
<h4 id="temporal-redirect">Temporal Redirect</h4> 
<p>此注释使您可以返回时间重定向（返回代码302），而不是将数据发送到上游。例如<code>nginx.ingress.kubernetes.io/temporal-redirect: https://www.google.com</code>，将所有内容重定向到Google，返回码为302（临时移动）</p> 
<h4 id="ssl直通">SSL直通</h4> 
<p>注释<code>nginx.ingress.kubernetes.io/ssl-passthrough</code>指示控制器将TLS连接直接发送到后端，而不是让NGINX解密通信。另请参阅《用户指南》中的<a href="../../tls/#ssl-passthrough" rel="nofollow">TLS / HTTPS</a>。</p> 
<p>注意</p> 
<p>SSL直通<strong>默认情况下</strong>处于**禁用状态，**并且需要使用该<a href="../../cli-arguments/" rel="nofollow"><code>--enable-ssl-passthrough</code></a>标志启动控制器 。</p> 
<p>注意</p> 
<p>由于SSL Passthrough在OSI模型（TCP）的第4层而不是第7层（HTTP）上起作用，因此使用SSL Passthrough会使在Ingress对象上设置的所有其他注释无效。</p> 
<h4 id="service-upstream">Service Upstream</h4> 
<p>默认情况下，NGINX入口控制器使用NGINX上游配置中所有端点（Pod IP /端口）的列表。</p> 
<p>该<code>nginx.ingress.kubernetes.io/service-upstream</code>注释禁用该行为，而是使用在NGINX，该服务的群集IP和端口的单一上游。</p> 
<p>这对于零停机时间部署之类的事情可能是理想的，因为它减少了Pod上下时重新加载NGINX配置的需求。参见问题<a href="https://github.com/kubernetes/ingress-nginx/issues/257">＃257</a>。</p> 
<h5 id="已知的问题">已知的问题</h5> 
<p>如果<code>service-upstream</code>指定了注释，则应考虑以下事项：</p> 
<ul><li>粘性会话将不起作用，因为仅支持循环负载平衡。</li><li>该<code>proxy_next_upstream</code>指令不会有任何影响，因为如果出错，该请求将不会分派到另一个上游。</li></ul> 
<h4 id="通过重定向执行服务器端https">通过重定向执行服务器端HTTPS</h4> 
<p>默认情况下，如果为该入口启用了TLS，则控制器将重定向（308）到HTTPS。如果要全局禁用此行为，可以<code>ssl-redirect: "false"</code>在NGINX <a href="../configmap/#ssl-redirect" rel="nofollow">ConfigMap中使用</a>。</p> 
<p>要为特定的入口资源配置此功能，可以<code>nginx.ingress.kubernetes.io/ssl-redirect: "false"</code> 在特定资源中使用注释。</p> 
<p>在群集外部（例如AWS ELB）上使用SSL卸载时，即使没有可用的TLS证书，强制执行到HTTPS的重定向也可能很有用。这可以通过使用<code>nginx.ingress.kubernetes.io/force-ssl-redirect: "true"</code>特定资源中的注释来实现。</p> 
<h4 id="从重定向到www">从/重定向到www</h4> 
<p>在某些情况下，需要从重定向<code>www.domain.com</code>到<code>domain.com</code>，反之亦然。要启用此功能，请使用注释<code>nginx.ingress.kubernetes.io/from-to-www-redirect: "true"</code></p> 
<p>注意</p> 
<p>如果在某个时候创建​​了一个新的Ingress，且其宿主等于选项之一（如<code>domain.com</code>），则注释将被省略。</p> 
<p>注意</p> 
<p>对于从HTTPS到HTTPS的重定向是强制性的，位于Ingress TLS部分中的Secret中定义的SSL证书包含两个通用名称的FQDN。</p> 
<h4 id="白名单来源范围">白名单来源范围</h4> 
<p>您可以通过<code>nginx.ingress.kubernetes.io/whitelist-source-range</code>注释指定允许的客户端IP源范围。该值是逗号分隔的<a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" rel="nofollow">CIDR</a>列表，例如 <code>10.0.0.0/24,172.10.0.1</code>。</p> 
<p>要为所有Ingress规则全局配置此设置，<code>whitelist-source-range</code>可以在<a href="../configmap/#whitelist-source-range" rel="nofollow">NGINX ConfigMap中</a>设置该值。</p> 
<p>注意</p> 
<p>向Ingress规则添加注释会覆盖所有全局限制。</p> 
<h4 id="自定义超时">自定义超时</h4> 
<p>使用配置configmap可以为与上游服务器的连接设置默认的全局超时。在某些情况下，要求具有不同的值。为此，我们提供了允许进行此自定义的注释：</p> 
<ul><li><code>nginx.ingress.kubernetes.io/proxy-connect-timeout</code></li><li><code>nginx.ingress.kubernetes.io/proxy-send-timeout</code></li><li><code>nginx.ingress.kubernetes.io/proxy-read-timeout</code></li><li><code>nginx.ingress.kubernetes.io/proxy-next-upstream</code></li><li><code>nginx.ingress.kubernetes.io/proxy-next-upstream-timeout</code></li><li><code>nginx.ingress.kubernetes.io/proxy-next-upstream-tries</code></li><li><code>nginx.ingress.kubernetes.io/proxy-request-buffering</code></li></ul> 
<h4 id="代理重定向">代理重定向</h4> 
<p>使用注释<code>nginx.ingress.kubernetes.io/proxy-redirect-from</code>，<code>nginx.ingress.kubernetes.io/proxy-redirect-to</code>可以在<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_redirect" rel="nofollow">代理服务器响应</a>的<code>Location</code>和<code>Refresh</code>标头字段中设置应更改的文本<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_redirect" rel="nofollow"></a></p> 
<p>在注释中设置为“ off”或“ default” <code>nginx.ingress.kubernetes.io/proxy-redirect-from</code>会禁用<code>nginx.ingress.kubernetes.io/proxy-redirect-to</code>，否则，必须同时使用两个注释。请注意，每个注释必须是不带空格的字符串。</p> 
<p>默认情况下，每个注释的值为“ off”。</p> 
<h4 id="custom-max-body-size">Custom max body size</h4> 
<p>对于NGINX，当请求中的大小超过客户端请求正文的最大允许大小时，将向客户端返回413错误。该大小可以通过参数来配置<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size" rel="nofollow"><code>client_max_body_size</code></a>。</p> 
<p>要为所有Ingress规则全局配置此设置，<code>proxy-body-size</code>可以在<a href="../configmap/#proxy-body-size" rel="nofollow">NGINX ConfigMap中</a>设置该值。要在Ingress规则中使用自定义值，请定义以下注释：</p> 
<p><code>nginx.ingress.kubernetes.io/proxy-body-size: 8m</code></p> 
<h4 id="代理cookie域">代理Cookie域</h4> 
<p>设置<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cookie_domain" rel="nofollow">应在</a>代理服务器响应的“ Set-Cookie”标头字段<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cookie_domain" rel="nofollow">的domain属性</a>中<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cookie_domain" rel="nofollow">更改</a>的文本。</p> 
<p>要为所有Ingress规则全局配置此设置，<code>proxy-cookie-domain</code>可以在<a href="../configmap/#proxy-cookie-domain" rel="nofollow">NGINX ConfigMap中</a>设置该值。</p> 
<h4 id="代理cookie路径">代理Cookie路径</h4> 
<p>设置<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cookie_path" rel="nofollow">应在</a>代理服务器响应的“ Set-Cookie”标头字段<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cookie_path" rel="nofollow">的path属性</a>中<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cookie_path" rel="nofollow">更改</a>的文本。</p> 
<p>要为所有Ingress规则全局配置此设置，<code>proxy-cookie-path</code>可以在<a href="../configmap/#proxy-cookie-path" rel="nofollow">NGINX ConfigMap中</a>设置该值。</p> 
<h4 id="代理缓冲">代理缓冲</h4> 
<p>启用或禁用代理缓冲<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffering" rel="nofollow"><code>proxy_buffering</code></a>。默认情况下，NGINX配置中禁用代理缓冲。</p> 
<p>要为所有Ingress规则全局配置此设置，<code>proxy-buffering</code>可以在<a href="../configmap/#proxy-buffering" rel="nofollow">NGINX ConfigMap中</a>设置该值。要在Ingress规则中使用自定义值，请定义以下注释：</p> 
<p><code>nginx.ingress.kubernetes.io/proxy-buffering: "on"</code></p> 
<h4 id="代理缓冲区数">代理缓冲区数</h4> 
<p>设置<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffers" rel="nofollow"><code>proxy_buffers</code></a>用于读取从代理服务器接收到的响应的第一部分的缓冲区数。默认情况下，代理缓冲区数设置为4</p> 
<p>要全局配置此设置，请<code>proxy-buffers-number</code>在<a href="../configmap/#proxy-buffers-number" rel="nofollow">NGINX ConfigMap中进行</a>设置。要在Ingress规则中使用自定义值，请定义以下注释：</p> 
<p><code>nginx.ingress.kubernetes.io/proxy-buffers-number: "4"</code></p> 
<h4 id="代理缓冲区大小">代理缓冲区大小</h4> 
<p>设置<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffer_size" rel="nofollow"><code>proxy_buffer_size</code></a>用于读取从代理服务器接收到的响应的第一部分的缓冲区的大小。默认情况下，代理缓冲区大小设置为“ 4k”</p> 
<p>要全局配置此设置，请<code>proxy-buffer-size</code>在<a href="../configmap/#proxy-buffer-size" rel="nofollow">NGINX ConfigMap中进行</a>设置。要在Ingress规则中使用自定义值，请定义以下注释：</p> 
<p><code>nginx.ingress.kubernetes.io/proxy-buffer-size: "8k"</code></p> 
<h4 id="代理最大临时文件大小">代理最大临时文件大小</h4> 
<p>如果<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffering" rel="nofollow"><code>buffering</code></a>启用了来自代理服务器的响应，并且整个响应不适合通过<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffer_size" rel="nofollow"><code>proxy_buffer_size</code></a>和<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_buffers" rel="nofollow"><code>proxy_buffers</code></a>指令设置的缓冲区，则可以将响应的一部分保存到临时文件中。此伪指令设置<code>size</code>临时文件的最大值，设置为<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_max_temp_file_size" rel="nofollow"><code>proxy_max_temp_file_size</code></a>。一次写入临时文件的数据大小由<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_temp_file_write_size" rel="nofollow"><code>proxy_temp_file_write_size</code></a>指令设置。</p> 
<p>零值禁用对临时文件的响应的缓冲。</p> 
<p>要在Ingress规则中使用自定义值，请定义以下注释：</p> 
<p><code>nginx.ingress.kubernetes.io/proxy-max-temp-file-size: "1024m"</code></p> 
<h4 id="代理http版本">代理HTTP版本</h4> 
<p>使用此注释设置<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_http_version" rel="nofollow"><code>proxy_http_version</code></a>Nginx反向代理将用于与后端通信的。默认情况下，它设置为“ 1.1”。</p> 
<p><code>nginx.ingress.kubernetes.io/proxy-http-version: "1.0"</code></p> 
<h4 id="ssl密码">SSL密码</h4> 
<p>指定<a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_ciphers" rel="nofollow">启用的密码</a>。</p> 
<p>使用此注释将<code>ssl_ciphers</code>在服务器级别设置指令。该配置对主机中的所有路径均有效。</p> 
<p><code>nginx.ingress.kubernetes.io/ssl-ciphers: "ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP"</code></p> 
<h4 id="连接代理头">连接代理头</h4> 
<p>使用此注释将覆盖NGINX设置的默认连接头。要在Ingress规则中使用自定义值，请定义注释：</p> 
<p><code>nginx.ingress.kubernetes.io/connection-proxy-header: "keep-alive"</code></p> 
<h4 id="启用访问日志">启用访问日志</h4> 
<p>默认情况下，访问日志处于启用状态，但在某些情况下，可能需要针对给定的入口禁用访问日志。为此，请使用注释：</p> 
<p><code>nginx.ingress.kubernetes.io/enable-access-log: "false"</code></p> 
<h4 id="启用重写日志">启用重写日志</h4> 
<p>默认情况下，未启用重写日志。在某些情况下，可能需要启用NGINX重写日志。请注意，重写日志将在通知级别发送到error_log文件。要启用此功能，请使用注释：</p> 
<p><code>nginx.ingress.kubernetes.io/enable-rewrite-log: "true"</code></p> 
<h4 id="启用开放追踪">启用开放追踪</h4> 
<p>可以通过ConfigMap在全局范围内启用或禁用Opentracing，但是有时需要重写它才能启用它或针对特定入口禁用它（例如，关闭对外部运行状况检查端点的跟踪）</p> 
<p><code>nginx.ingress.kubernetes.io/enable-opentracing: "true"</code></p> 
<h4 id="x转发前缀报头">X转发前缀报头</h4> 
<p>要<code>X-Forwarded-Prefix</code>使用字符串值将非标准标头添加到上游请求中，可以使用以下注释：</p> 
<p><code>nginx.ingress.kubernetes.io/x-forwarded-prefix: "/path"</code></p> 
<h4 id="modsecurity">ModSecurity</h4> 
<p><a href="http://modsecurity.org/" rel="nofollow">ModSecurity</a>是一个开源Web应用程序防火墙。可以为一组特定的入口位置启用它。首先必须通过在<a href="../configmap/#enable-modsecurity" rel="nofollow">ConfigMap中</a>启用ModSecurity来启用ModSecurity模块 。请注意，这将为所有路径启用ModSecurity，并且必须手动禁用每个路径。</p> 
<p>可以使用以下注释启用它：</p> 
<p><code>nginx.ingress.kubernetes.io/enable-modsecurity: "true"</code></p> 
<p>ModSecurity将使用<a href="https://github.com/SpiderLabs/ModSecurity/blob/v3/master/modsecurity.conf-recommended">推荐的配置</a>以“仅检测”模式<a href="https://github.com/SpiderLabs/ModSecurity/blob/v3/master/modsecurity.conf-recommended">运行</a>。</p> 
<p>您可以通过设置以下注释来启用<a href="https://www.modsecurity.org/CRS/Documentation/" rel="nofollow">OWASP核心规则集</a>：</p> 
<p><code>nginx.ingress.kubernetes.io/enable-owasp-core-rules: "true"</code></p> 
<p>您可以通过设置以下内容从nginx传递transactionID：</p> 
<p><code>nginx.ingress.kubernetes.io/modsecurity-transaction-id: "$request_id"</code></p> 
<p>您还可以通过代码段添加自己的modsecurity规则集：</p> 
<p><code>nginx.ingress.kubernetes.io/modsecurity-snippet: | SecRuleEngine On SecDebugLog /tmp/modsec_debug.log</code></p> 
<p>注意：如果同时使用<code>enable-owasp-core-rules</code>和和<code>modsecurity-snippet</code>批注，则只有 <code>modsecurity-snippet</code>会生效。如果要包括<a href="https://www.modsecurity.org/CRS/Documentation/" rel="nofollow">OWASP核心规则集</a>或 <a href="https://github.com/SpiderLabs/ModSecurity/blob/v3/master/modsecurity.conf-recommended">建议的配置，</a>只需使用include语句：</p> 
<p>nginx 0.24.1及以下</p> 
<p><code>nginx.ingress.kubernetes.io/modsecurity-snippet: | Include /etc/nginx/owasp-modsecurity-crs/nginx-modsecurity.conf Include /etc/nginx/modsecurity/modsecurity.conf</code></p> 
<p>nginx 0.25.0及更高版本</p> 
<p><code>nginx.ingress.kubernetes.io/modsecurity-snippet: | Include /etc/nginx/owasp-modsecurity-crs/nginx-modsecurity.conf</code></p> 
<h4 id="influxdb">InfluxDB</h4> 
<p>使用<code>influxdb-*</code>批注，我们可以使用<a href="https://github.com/influxdata/nginx-influxdb-module/">nginx-influxdb-module</a>将请求发送到暴露UDP套接字的InfluxDB后端，从而监视通过位置的请求。</p> 
<p><code>nginx.ingress.kubernetes.io/enable-influxdb: "true" nginx.ingress.kubernetes.io/influxdb-measurement: "nginx-reqs" nginx.ingress.kubernetes.io/influxdb-port: "8089" nginx.ingress.kubernetes.io/influxdb-host: "127.0.0.1" nginx.ingress.kubernetes.io/influxdb-server-name: "nginx-ingress"</code></p> 
<p>对于<code>influxdb-host</code>参数，您有两个选择：</p> 
<ul><li>使用配置为启用<a href="https://docs.influxdata.com/influxdb/v1.5/supported_protocols/udp/" rel="nofollow">UDP协议</a>的InfluxDB服务器 。</li><li>将Telegraf作为Sidecar代理部署到Ingress控制器，该控制器配置为使用<a href="https://github.com/influxdata/telegraf/tree/release-1.6/plugins/inputs/socket_listener">套接字侦听器输入</a>侦听UDP，并使用任何<a href="https://github.com/influxdata/telegraf/tree/release-1.7/plugins/outputs">输出插件（</a>例如InfluxDB，Apache Kafka，Prometheus等）进行写入。（推荐）</li></ul> 
<p>重要的是要记住，此阶段没有DNS解析器，因此您必须将IP地址配置为<code>nginx.ingress.kubernetes.io/influxdb-host</code>。如果将Influx或Telegraf部署为Sidecar（同一吊舱中的另一个容器），这将变得很简单，因为您可以直接使用<code>127.0.0.1</code>。</p> 
<h4 id="后端协议">后端协议</h4> 
<p>使用<code>backend-protocol</code>注释可以指示NGINX应如何与后端服务通信。（<code>secure-backends</code>在旧版本中替换）有效值：HTTP，HTTPS，GRPC，GRPCS和AJP</p> 
<p>默认情况下，NGINX使用<code>HTTP</code>。</p> 
<p>例：</p> 
<p><code>nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"</code></p> 
<h4 id="使用正则表达式">使用正则表达式</h4> 
<p>注意</p> 
<p>当将此注释与<code>nginx.ingress.kubernetes.io/affinity</code>类型为NGINX的注释一起使用时<code>cookie</code>， <code>nginx.ingress.kubernetes.io/session-cookie-path</code>还必须设置；会话Cookie路径不支持正则表达式。</p> 
<p>使用<code>nginx.ingress.kubernetes.io/use-regex</code>注释将指示Ingress上定义的路径是否使用正则表达式。默认值为<code>false</code>。</p> 
<p>下面将指示正在使用正则表达式路径：</p> 
<p><code>nginx.ingress.kubernetes.io/use-regex: "true"</code></p> 
<p>以下内容将指示<strong>未</strong>使用正则表达式路径：</p> 
<p><code>nginx.ingress.kubernetes.io/use-regex: "false"</code></p> 
<p>当此批注设置为时<code>true</code>，不区分大小写的正则表达式<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#location" rel="nofollow">位置修饰符</a>将在给定主机的所有路径上强制执行，无论它们定义在什么Ingress上。</p> 
<p>此外，如果在给定主机的任何Ingress上使用了<a href="#rewrite" rel="nofollow"><code>rewrite-target</code>注释</a>，则不区分大小写的正则表达式<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#location" rel="nofollow">位置修饰符</a>将在给定主机的所有路径上强制执行，无论它们定义在什么Ingress上。</p> 
<p>在使用此修饰符之前，请阅读有关<a href="../../ingress-path-matching/" rel="nofollow">入口路径匹配的信息</a>。</p> 
<h4 id="satisfy">Satisfy</h4> 
<p>默认情况下，请求将需要满足所有身份验证要求才能被允许。通过使用此批注，基于配置值，允许满足任何或所有身份验证要求的请求。</p> 
<p><code>nginx.ingress.kubernetes.io/satisfy: "any"</code></p> 
<h4 id="mirror">Mirror</h4> 
<p>允许将请求镜像到镜像后端。镜像后端的响应将被忽略。此功能很有用，可以查看请求在“测试”后端中的反应。</p> 
<p>可以通过以下方式设置镜像后端：</p> 
<p><code>nginx.ingress.kubernetes.io/mirror-target: https://test.env.com/$request_uri</code></p> 
<p>默认情况下，请求正文发送到镜像后端，但可以通过应用以下命令将其关闭：</p> 
<p><code>nginx.ingress.kubernetes.io/mirror-request-body: "off"</code></p> 
<p><strong>注意：</strong> mirror指令将应用于入口资源内的所有路径。</p> 
<p>发送到镜像的请求链接到原始请求。如果您的镜像后端速度较慢，则原始请求将受到限制。</p> 
<p>有关镜像模块的更多信息，请参见<a href="https://nginx.org/en/docs/http/ngx_http_mirror_module.html" rel="nofollow">ngx_http_mirror_module</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f2444a7cac3bd415e1637992e3eaf4a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">达梦数据库创建定时作业</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6d81cf14f8b9b5e4c93b0e7e00d5552/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解线性方程组的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>