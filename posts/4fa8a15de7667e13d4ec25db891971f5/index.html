<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>洛谷题单【算法1-7】搜索 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="洛谷题单【算法1-7】搜索" />
<meta property="og:description" content="P1135 奇怪的电梯 一开始以为深搜肯定没问题，从a点出发，衍生出一个二叉树，遍历所有情况就好了，但是会重复，所以加了一个vis防止重复，但是只拿了64pts，因为有可能某个点并不是最短被到达的，但是已经被标记上了vis，所以如果要遍历这一个整个合法的最短二叉树，应该要用BFS。
DFS的话因为是一直在搜，所以加一个dis数组，更新每个点的最短次数。
#include &lt;bits/stdc&#43;&#43;.h&gt; //#define int long long #define per(i,j,k) for(int (i)=(j);(i)&lt;=(k);&#43;&#43;(i)) #define rep(i,j,k) for(int (i)=(j);(i)&gt;=(k);--(i)) #define fr first #define se second #define endl &#39;\n&#39; using namespace std; const int N=200&#43;5; int n,k[N],a,b,ans=INT_MAX,dis[N]; void dfs(int x,int step){ if(x&lt;1 or x&gt;n or step&gt;=dis[x] or step&gt;=ans)return; if(x==b)return ans=step,void(); dis[x]=step; dfs(x&#43;k[x],step&#43;1); dfs(x-k[x],step&#43;1); } void solve(){ cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; per(i,1,n)cin&gt;&gt;k[i],dis[i]=INT_MAX; dfs(a,0); ans=ans==INT_MAX?-1:ans; cout&lt;&lt;ans&lt;&lt;endl; } signed main(){ ios::sync_with_stdio(false),cin.tie(nullptr); int t=1; while(t--)solve(); return 0; } P2895 [USACO08FEB] Meteor Shower S 坑也太多了，下面列举一下坑，题不是很难，就模拟&#43;BFS。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4fa8a15de7667e13d4ec25db891971f5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-21T19:49:31+08:00" />
<meta property="article:modified_time" content="2024-01-21T19:49:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">洛谷题单【算法1-7】搜索</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h6><a class="link-info" href="https://www.luogu.com.cn/problem/P1135" rel="nofollow" title="P1135 奇怪的电梯">P1135 奇怪的电梯</a></h6> 
<p>一开始以为深搜肯定没问题，从a点出发，衍生出一个二叉树，遍历所有情况就好了，但是会重复，所以加了一个vis防止重复，但是只拿了64pts，因为有可能某个点并不是最短被到达的，但是已经被标记上了vis，所以如果要遍历这一个整个合法的最短二叉树，应该要用BFS。</p> 
<p>DFS的话因为是一直在搜，所以加一个dis数组，更新每个点的最短次数。</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
//#define int long long
#define per(i,j,k) for(int (i)=(j);(i)&lt;=(k);++(i))
#define rep(i,j,k) for(int (i)=(j);(i)&gt;=(k);--(i))
#define fr first
#define se second
#define endl '\n'
using namespace std;

const int N=200+5;
int n,k[N],a,b,ans=INT_MAX,dis[N];

void dfs(int x,int step){
	if(x&lt;1 or x&gt;n or step&gt;=dis[x] or step&gt;=ans)return;
	if(x==b)return ans=step,void();
	dis[x]=step;
    dfs(x+k[x],step+1);
    dfs(x-k[x],step+1);
}

void solve(){
    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;
    per(i,1,n)cin&gt;&gt;k[i],dis[i]=INT_MAX;
    dfs(a,0);
    ans=ans==INT_MAX?-1:ans;
    cout&lt;&lt;ans&lt;&lt;endl;
}

signed main(){
    ios::sync_with_stdio(false),cin.tie(nullptr);
    int t=1;
    while(t--)solve();
    return 0;
}</code></pre> 
<hr> 
<h6><a class="link-info" href="https://www.luogu.com.cn/problem/P2895" rel="nofollow" title="P2895 [USACO08FEB] Meteor Shower S">P2895 [USACO08FEB] Meteor Shower S</a></h6> 
<p>坑也太多了，下面列举一下坑，题不是很难，就模拟+BFS。</p> 
<p>1. 流星只会在0&lt;=x&lt;=300，0&lt;=y&lt;=300出现，但是没说人不能走出这个范围，人在<strong>第一象限</strong>移动</p> 
<p>2. 多个流星降落的点，要取最早的那一个</p> 
<p>3. 每个点最多被走一次，如果返回来走第二次，肯定不会更优，重复走还会MLE</p> 
<p>4. 陨石还有2降落的时候才能走那个点，走上去1，走出去0，如果是1走进去就被砸了</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
//#define int long long
#define per(i,j,k) for(int (i)=(j);(i)&lt;=(k);++(i))
#define rep(i,j,k) for(int (i)=(j);(i)&gt;=(k);--(i))
#define fr first
#define SAFE INT_MAX
#define se second
#define endl '\n'
using namespace std;
using pii=pair&lt;int,int&gt;;

const int N=300+5;
int m,x,y,t,a[N][N],step[N][N],dx[4]={0,0,1,-1},dy[4]={1,-1,0,0},cnt=1,precnt;
bool vis[N][N];

bool isingrid(pii x){//并不需要&lt;=300
    return x.fr&gt;=0 and x.se&gt;=0 ;
}

bool safe(pii x){//输入的时候已经延伸陨石了,所以判断的时候不需要延伸
    if(a[x.fr][x.se]!=SAFE)return false;
    else return true;
}

void ans(pii x){
    cout&lt;&lt;step[x.fr][x.se]&lt;&lt;endl;
}

void noans(){
    cout&lt;&lt;-1&lt;&lt;endl;
}

void updateMeteor(){//更新陨石,所有不安全的点均有陨石,时间-1
    per(i,0,304)per(j,0,304)if(a[i][j]!=SAFE)a[i][j]--;
}

void solve(){
    per(i,0,304)per(j,0,304)a[i][j]=SAFE;//标记为安全

    cin&gt;&gt;m;
    per(i,1,m){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;
        a[x][y]=min(a[x][y],t);//有陨石就不安全,标记一下降落时间，取最早时间
        per(j,0,3){//四个方向都标记
            pii nxt={x+dx[j],y+dy[j]};
            if(isingrid(nxt)){//范围是否合法
                a[nxt.fr][nxt.se]=min(a[nxt.fr][nxt.se],t);
            }
        }
    }

    queue&lt;pii&gt;q;
    q.push({0,0});
    while(!q.empty()){
        pii now=q.front();q.pop();cnt--;
        vis[now.fr][now.se]=true;

        if(safe(now))return ans(now);//当前点安全，输出答案
        per(i,0,3){
            pii nxt={now.fr+dx[i],now.se+dy[i]};
            if(isingrid(nxt) and a[nxt.fr][nxt.se]&gt;=2 and !vis[nxt.fr][nxt.se]){
                q.push(nxt),precnt++;//记录一下进队的数量
                step[nxt.fr][nxt.se]=step[now.fr][now.se]+1;
                vis[nxt.fr][nxt.se]=true;//标记一下被使用过了,不要重复走,不然会MLE
            }
        }

        if(cnt==0){//若每一层遍历cnt都用完了,则说明要更新陨石降落时间
            cnt=precnt;
            precnt=0;
            updateMeteor();
        }
    }

    return noans();//无路可走,没有答案
}

signed main(){
    ios::sync_with_stdio(false),cin.tie(nullptr);
    int t=1;
    while(t--)solve();
    return 0;
}</code></pre> 
<hr> 
<p><a href="https://www.luogu.com.cn/problem/P1825" rel="nofollow" title="P1825 [USACO11OPEN] Corn Maze S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)">P1825 [USACO11OPEN] Corn Maze S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p> 
<p>一道dfs做不了的题，果然还是需要做之前进行谨慎的思考。</p> 
<p><img alt="" height="573" src="https://images2.imgbox.com/45/2b/QT65bp8W_o.png" width="1200"></p> 
<p>此题本质上是在求最短路，每个节点最多4个方向，那么从这个角度去考虑，dfs实际上是在对所有方向进行全排列，而bfs是从最短距离的方向去搜索。</p> 
<p>那显而易见dfs大概率就会TLE，而bfs大概率可以AC。</p> 
<p>本题bfs的每个点最多入队一次或者2次，而dfs每个点就不一定了，运气差也许会入队n次。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0f89741fac28f6e802933caf4292d0f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">7. 整数反转-LeetCode（Java）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/deafcf95f0821b1c7b695218d5aa2b29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【跳槽面试】Redis的过期键删除策略？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>