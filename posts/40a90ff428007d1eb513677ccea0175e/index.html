<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>“DSO missing from command line”解决及其原理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="“DSO missing from command line”解决及其原理" />
<meta property="og:description" content="1 前言 这两天在编写一个插件系统Demo的时候，发现了个很奇怪的问题：插件加载器中已经链接了ld库，但是应用程序在链接插件加载器的时候，却还需要显式的来链接ld库。否则就会报：DSO missing from command line。这个报错翻译过来就是没有在命令行中指定该动态库。
这个报错就很搞事了，你说你明明知道需要哪个库，为什么不直接帮我链接呢，非得我显示的在命令行中指定呢？
2 现象描述 问题可以简单描述为：当链接可执行文件时，依赖于libA.so，而libA.so又依赖于libB.so，而且可执行文件中还直接调用了libB.so中的函数，那么此时链接就会出现错误。
2.1 问题发生的前置条件
libA.so在编译过程中显式的链接了libB.so
可执行文件中使用了libB.so的函数
binuntils版本 ≥ 2.22
2.2 Talk is cheap. Show me the code
话不多说，先看看可以复现改问题的代码吧
libB.so的源码：
#include &lt;stdio.h&gt; int funB1(){ printf(&#34;in funB1&#34;); return 0; } int funB2(){ printf(&#34;in funB2&#34;); return 0; } 这里面有两个函数：funB1和funB2。
其中funB1函数会被libA调用，而funB2会被可执行文件调用。
编译libB.so:
$ gcc libB.cpp -fPIC -shared -o libB.so libA.so的源码：
#include &lt;stdio.h&gt; int funB1(); int funA1(){ printf(&#34;in funA1 \n&#34;); funB1(); return 0; } 该库中只有一个函数funA1，该函数在内部调用了libB中的funB1函数。且该函数会被可执行文件调用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/40a90ff428007d1eb513677ccea0175e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-07T11:47:29+08:00" />
<meta property="article:modified_time" content="2020-05-07T11:47:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">“DSO missing from command line”解决及其原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1__0"></a>1 前言</h3> 
<p>这两天在编写一个插件系统Demo的时候，发现了个很奇怪的问题：插件加载器中已经链接了ld库，但是应用程序在链接插件加载器的时候，却还需要显式的来链接ld库。否则就会报：DSO missing from command line。这个报错翻译过来就是没有在命令行中指定该动态库。<br> 这个报错就很搞事了，你说你明明知道需要哪个库，为什么不直接帮我链接呢，非得我显示的在命令行中指定呢？</p> 
<h3><a id="2__5"></a>2 现象描述</h3> 
<p>问题可以简单描述为：当链接可执行文件时，依赖于libA.so，而libA.so又依赖于libB.so，而且可执行文件中还直接调用了libB.so中的函数，那么此时链接就会出现错误。</p> 
<p><strong>2.1 问题发生的前置条件</strong><br> libA.so在编译过程中显式的链接了libB.so<br> 可执行文件中使用了libB.so的函数<br> binuntils版本 ≥ 2.22<br> 2.2 Talk is cheap. Show me the code<br> 话不多说，先看看可以复现改问题的代码吧</p> 
<p>libB.so的源码：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">funB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in funB1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">funB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in funB2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里面有两个函数：funB1和funB2。<br> 其中funB1函数会被libA调用，而funB2会被可执行文件调用。</p> 
<p>编译libB.so:</p> 
<pre><code class="prism language-bash">$ gcc libB.cpp -fPIC -shared -o libB.so
</code></pre> 
<p>libA.so的源码：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">funB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">funA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in funA1 \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">funB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该库中只有一个函数funA1，该函数在内部调用了libB中的funB1函数。且该函数会被可执行文件调用。</p> 
<p>编译libA.so:</p> 
<pre><code class="prism language-bash">$ gcc libA.cpp -fPIC -shared -o libA.so -Wl,-rpath<span class="token operator">=</span>./ -L./ -lB
</code></pre> 
<p>main.cpp的源码：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">funA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">funB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token function">funA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">funB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译main.cpp:(复现错误的编译方法)</p> 
<pre><code class="prism language-bash">gcc main.cpp -L./ -lA
</code></pre> 
<p>当我们按照上面的指令编译main.cpp的时候，便报错了。</p> 
<pre><code class="prism language-bash">/usr/bin/ld: /tmp/ccDQXTKy.o: undefined reference to symbol <span class="token string">'_Z5funB2v'</span>
.//libB.so: error adding symbols: DSO missing from <span class="token function">command</span> line
collect2: error: ld returned 1 <span class="token keyword">exit</span> status
</code></pre> 
<p>（问号.jpg）这，这GCC不是搞事吗，你明明知道我需要连接libB.so为啥就不帮我链接上去呢？难道我libA.so没有指明要使用libB.so?我们使用下面的指令来看一下</p> 
<pre><code class="prism language-bash">$ ldd libA.so
</code></pre> 
<p>得到如下信息：</p> 
<pre><code class="prism language-bash">	linux-vdso.so.1 <span class="token operator">=</span><span class="token operator">&gt;</span>  <span class="token punctuation">(</span>0x00007ffd09def000<span class="token punctuation">)</span>
	libB.so <span class="token operator">=</span><span class="token operator">&gt;</span> ./libB.so <span class="token punctuation">(</span>0x00007fc513d7d000<span class="token punctuation">)</span>
	libc.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="token punctuation">(</span>0x00007fc5139b3000<span class="token punctuation">)</span>
	/lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007fc514181000<span class="token punctuation">)</span>
</code></pre> 
<p>明明libA.so已经显式的指明我要依赖libB.so了，那为啥在编译main.cpp的时候链接了libA.so，GCC却还要我们显式的链接libB.so呢？</p> 
<h3><a id="3__108"></a>3 答案</h3> 
<p>答案很简单，那就是GCC就是想要你显式链接呗。（你是编译器，你牛好吧。）那这是为啥呢？<br> 官方一点的答案就是，自从binutils 2.22版本以后，如果你在程序中使用了你依赖的动态库所依赖的动态库中的函数时，你就必须显式的指定你依赖的动态库所依赖的动态库。</p> 
<p>说那么多，我们更想知道的是，通过修改什么参数可以解决这个问题呢？因为你可能不想在编译程序的时候要把动态库所依赖的所有动态库都显示链接一遍。</p> 
<h3><a id="4__115"></a>4 究极答案</h3> 
<p>实际上，这是binutils在2.22版本以后，默认把–no-copy-dt-needed-entries这个选项打开了。当打开了这个选项的时候，编译器在链接的时候是不会递归的去获取依赖动态库的依赖项的，于是就会出现上述的问题。关于该配置项的详细说明如下：</p> 
<pre><code class="prism language-bash">   --copy-dt-needed-entries
   --no-copy-dt-needed-entries
       This option affects the treatment of dynamic libraries referred to by DT_NEEDED tags inside ELF dynamic libraries mentioned on the <span class="token function">command</span> line.  Normally the linker won't add a DT_NEEDED
       tag to the output binary <span class="token keyword">for</span> each library mentioned <span class="token keyword">in</span> a DT_NEEDED tag <span class="token keyword">in</span> an input dynamic library.  With --copy-dt-needed-entries specified on the <span class="token function">command</span> line however any dynamic
       libraries that follow it will have their DT_NEEDED entries added.  The default behaviour can be restored with --no-copy-dt-needed-entries.

       This option also has an effect on the resolution of symbols <span class="token keyword">in</span> dynamic libraries.  With --copy-dt-needed-entries dynamic libraries mentioned on the <span class="token function">command</span> line will be recursively
       searched, following their DT_NEEDED tags to other libraries, <span class="token keyword">in</span> order to resolve symbols required by the output binary.  With the default setting however the searching of dynamic
       libraries that follow it will stop with the dynamic library itself.  No DT_NEEDED links will be traversed to resolve symbols.
</code></pre> 
<p>大概意思就是，跟在–no-copy-dt-needed-entries它后面的库都不会遍历其依赖项，使用–copy-dt-needed-entries则相反。也就是使用下面的指令来编译mian.cpp就可以避免该问题了。</p> 
<pre><code class="prism language-bash">$ gcc main.cpp -L./ -Wl,--copy-dt-needed-entries -lA
</code></pre> 
<p><strong>题外话</strong></p> 
<p>在Linux的ELF文件中，如果依赖于其他的动态库，那么改ELF文件会存在一个.dynamic的段，这个段里面会记录其依赖的动态库信息，其标志位为DT_NEEDED。</p> 
<h3><a id="5__140"></a>5 参考文档</h3> 
<p>1，DSO missing from command line原因及解决办法：https://segmentfault.com/a/1190000002462705<br> 2，折腾gcc/g++链接时.o文件及库的顺序问题： https://www.cnblogs.com/OCaml/archive/2012/06/18/2554086.html#sec-1-4-1</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b26cff12b4d03a67f243df31d30008c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用华为eNSP仿真校园网</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1cae830da6fff4d17d570e2c8c7abff0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue项目的H5如何通过WebViewJavascriptBridge和原生通信</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>