<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[官方培训]23-为UE创建美术资产 Epic 李文磊 笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[官方培训]23-为UE创建美术资产 Epic 李文磊 笔记" />
<meta property="og:description" content="为UE创建美术资产 资产一般存在哪些问题？ “太过游戏化”
“太不游戏化”
解决方式
Streaming（流送）
虚拟几何体和虚拟贴图
虚拟几何体和虚拟纹理的工作方式 把各种情况下（包括中近远）的模型和贴图打散成更小的单位，然后屏幕上看到哪些就加载绘制哪些。从而减小渲染，内存及显存的开销；
反过来看就是可以负担更多的资产。从而提高效果和效率。
啥时候用Nanite？ 能用则用除了一些特例。
Nanite的剔除，剔除的单位是cluster簇。因此相对于普通的模型，Nanite模型有极大的剔除效率。可以渲染更多的三角面。
另外就是在制作镂空的结构时，建议使用Nanite的几何体的顶点或者三角面表现，而不要使用镂空的材质或者Mask的材质。Nanite更好。镂空材质使用最多就是植被。
对于草这种比较小的物体制作的时候更Lumen一起工作有个问题需要注意。它有可能在Lumen scene里面是黑色的或者Lumen surface cache是黄色的。代表它完全没有捕获。是因为做的时候模型太小导致的。
在模型的层面放大三倍就解决了。
对于Nanite Mesh当我们使用WPO做顶点位移的材质效果的时候，要注意不能使用太大的位移，否则遮挡剔除会产生问题。
这边在材质里做比较大的WPO位移效果。当遮挡物还没挡到小球前面的时候，就已经把它剔除了。
除了遮挡剔除，视锥剔除也是不正确的。
这边随便验证Nanite是以簇（cluster）这个单位剔除的。
对于这种问题我们可以增加对象的包围盒的大小来减轻这种问题发生的几率。但剔除的敏感度也降低了，有时候反而没有剔除。
对于地形现在也加入了转成Nanite Mesh渲染的功能。
地形转成Nanite Mesh有几个好处
同样品质下效率会更高。阴影渲染的效率，主要是虚拟阴影贴图，也是从三角面以及渲染批次两个方面进行优化的。 但是地形也有其特殊性，尤其和别的渲染模块一起工作的时候。
第一个是Lumen的Surface Cache的捕获需要地形的high field高度场信息。所以这些信息需要来自传统地形。
第二个是RVT（实时的虚拟贴图）它的cache并不支持Nanite Mesh。因此这些信息也是需要来自传统地形表面。
具体演示看视频
模型需要多少面？ 归根结底可以参考贴图大小的确定，贴图是以像素的大小和屏幕像素大小的比例来确定贴图的分辨率的。模型就是顶点的法线变化的频率。它这个变化的频率或者细节和屏幕像素大小的一个关系。
对于开放模型就是通过对边缘轮廓线的平滑程度和像素或者分辨率的比较关系来确定最少需要多少三角面。
具体演示看视频
模型还要分UV吗？ 三角面的密度如果达到了像素级自然可能会产生一个疑问就是模型是否需要分UV？可不可以用顶点色表现颜色？
一般来说还是需要分UV，因为表面的细节不仅仅是凹凸还有颜色。引擎绘制的是三角面而不是顶点。模型顶点的密度也不均匀，所以光栅化的三角面的颜色无法提供足够高的高频细节。也就是如果有适当分辨率的颜色贴图，它的信息量会远远大于三角面光栅化后的颜色变化。所以仅仅用顶点色来表现颜色效果是不佳的。而且很高顶点数量的模型，如果加入了顶点色也会带来很大的数据量。
还有在Nanite的渲染时，三角面的优化过程当中。如果有顶点色结合一起工作，可能会带来一些其它的问题。这个后面会有所提及。
下面是高模斩UV的视频，可以自行搜索。
关于模型UV/顶点色/法线/LOD 关于模型的UV/顶点色/法线/LOD对Nanite的渲染效率以及数据量的影响。
UV它的cluster或者被拆分时候打散的程度，以及UV顶点是否被焊起来，还有就是UV的通道数量，这些都会非常大的影响数据量。另外UV cluster的拆分也会影响减面和剔除效果。
顶点色本身会占用额外的数据。另外顶点色也会影响减面的效果，并有可能产生问题。比如拉远减面的过程中会产生一些跳变。另外，Nanite目前还不支持在实例上直接绘制顶点色。
顶点的法线的复杂程度或者是否被打散或者说光滑组的多少都会影响Nanite在渲染是的一个减面效果。同时打散的顶点法线也会增加数据量。
关于LOD，Nanite没有LOD一说。但是它有一个Fallback Mesh，它是用来作为复杂的碰撞体或者Lumen在渲染时候的Lumen Scence的一个捕获对象。以及如果使用光线追踪的阴影的话，默认的投影对象。所以在这个层面上我们是需要生成这个Fallback Mesh。但生成的复杂度不用太高，主要还是为了Lumen Scence的捕获。
具体演示看视频。
如何减少Nanite的数据量？ 在内容浏览器里把鼠标放在资产上会显示一些相关的数字。
Disk Size也就是资产在磁盘上的大小。另外，这里有一个Nanite的压缩的尺寸（Est Nanite Compressed Size）以及最终压缩总的一个包的尺寸(Est Compressed Size)。Est Compressed Size是打包以后的大小。尺寸相差非常大。因为Nanite的压缩率比普通的Mesh要大得多。但是在编辑器里面因为我们有可能随时开关的Nanite，所以它的资产里面其实保留了原始的模型的数据。所以磁盘上的数据大小是原始的模型数据加上Nanite的模型数据。所以对于数据量的减少我们不能指望Nanite的高压缩率，而是得回到模型本身或者在做法上面实实在在的去优化它。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/820068de1d099e7b84a0c52b63da6b66/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-30T00:42:42+08:00" />
<meta property="article:modified_time" content="2023-09-30T00:42:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[官方培训]23-为UE创建美术资产 Epic 李文磊 笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="UE_0"></a>为UE创建美术资产</h2> 
<h3><a id="_2"></a>资产一般存在哪些问题？</h3> 
<p><strong><font color="orange">“太过游戏化”</font></strong></p> 
<p><strong><font color="orange">“太不游戏化”</font></strong></p> 
<p><strong>解决方式</strong></p> 
<p><strong><font color="orange">Streaming（流送）</font></strong></p> 
<p>虚拟几何体和虚拟贴图</p> 
<h3><a id="_14"></a>虚拟几何体和虚拟纹理的工作方式</h3> 
<p>把各种情况下（包括中近远）的模型和贴图打散成更小的单位，然后屏幕上看到哪些就加载绘制哪些。从而减小渲染，内存及显存的开销；</p> 
<p>反过来看就是可以负担更多的资产。从而提高效果和效率。</p> 
<p><img src="https://images2.imgbox.com/c8/e6/6SjElVET_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Nanite_23"></a>啥时候用Nanite？</h3> 
<p>能用则用除了一些特例。</p> 
<p>Nanite的剔除，剔除的单位是cluster簇。因此相对于普通的模型，Nanite模型有极大的剔除效率。可以渲染更多的三角面。</p> 
<p><img src="https://images2.imgbox.com/75/b1/7wKjl2bZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/69/bf/XRTwTEjB_o.png" alt="在这里插入图片描述"></p> 
<p>另外就是在制作镂空的结构时，建议使用Nanite的几何体的顶点或者三角面表现，而不要使用镂空的材质或者Mask的材质。Nanite更好。镂空材质使用最多就是植被。</p> 
<p>对于草这种比较小的物体制作的时候更Lumen一起工作有个问题需要注意。它有可能在Lumen scene里面是黑色的或者Lumen surface cache是黄色的。代表它完全没有捕获。是因为做的时候模型太小导致的。<br> <img src="https://images2.imgbox.com/9d/03/9K99JQyf_o.png" alt="在这里插入图片描述"></p> 
<p>在模型的层面放大三倍就解决了。</p> 
<p><img src="https://images2.imgbox.com/f9/18/593aLf8f_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6c/d7/MiOSYd2v_o.png" alt="在这里插入图片描述"></p> 
<p>对于Nanite Mesh当我们使用WPO做顶点位移的材质效果的时候，要注意不能使用太大的位移，否则遮挡剔除会产生问题。</p> 
<p>这边在材质里做比较大的WPO位移效果。当遮挡物还没挡到小球前面的时候，就已经把它剔除了。</p> 
<p><img src="https://images2.imgbox.com/c7/8b/6pWfgATW_o.png" alt="在这里插入图片描述"></p> 
<p>除了遮挡剔除，视锥剔除也是不正确的。<br> <img src="https://images2.imgbox.com/65/1c/kDMuXkaw_o.png" alt="在这里插入图片描述"></p> 
<p>这边随便验证Nanite是以簇（cluster）这个单位剔除的。<br> <img src="https://images2.imgbox.com/3b/4c/M044A0Ix_o.gif" alt="在这里插入图片描述"></p> 
<p>对于这种问题我们可以增加对象的包围盒的大小来减轻这种问题发生的几率。但剔除的敏感度也降低了，有时候反而没有剔除。</p> 
<p>对于地形现在也加入了转成Nanite Mesh渲染的功能。</p> 
<p>地形转成Nanite Mesh有几个好处</p> 
<ol><li>同样品质下效率会更高。</li><li>阴影渲染的效率，主要是虚拟阴影贴图，也是从三角面以及渲染批次两个方面进行优化的。</li></ol> 
<p>但是地形也有其特殊性，尤其和别的渲染模块一起工作的时候。</p> 
<p>第一个是Lumen的Surface Cache的捕获需要地形的high field高度场信息。所以这些信息需要来自传统地形。</p> 
<p>第二个是RVT（实时的虚拟贴图）它的cache并不支持Nanite Mesh。因此这些信息也是需要来自传统地形表面。<br> <img src="https://images2.imgbox.com/10/18/XuCufzBU_o.png" alt="在这里插入图片描述"></p> 
<p><strong>具体演示看视频</strong></p> 
<h3><a id="_87"></a>模型需要多少面？</h3> 
<p>归根结底可以参考贴图大小的确定，贴图是以像素的大小和屏幕像素大小的比例来确定贴图的分辨率的。模型就是顶点的法线变化的频率。它这个变化的频率或者细节和屏幕像素大小的一个关系。</p> 
<p>对于开放模型就是通过对边缘轮廓线的平滑程度和像素或者分辨率的比较关系来确定最少需要多少三角面。</p> 
<p><strong>具体演示看视频</strong></p> 
<h3><a id="UV_95"></a>模型还要分UV吗？</h3> 
<p>三角面的密度如果达到了像素级自然可能会产生一个疑问就是模型是否需要分UV？可不可以用顶点色表现颜色？</p> 
<p>一般来说还是需要分UV，因为表面的细节不仅仅是凹凸还有颜色。引擎绘制的是三角面而不是顶点。模型顶点的密度也不均匀，所以光栅化的三角面的颜色无法提供足够高的高频细节。也就是如果有适当分辨率的颜色贴图，它的信息量会远远大于三角面光栅化后的颜色变化。所以仅仅用顶点色来表现颜色效果是不佳的。而且很高顶点数量的模型，如果加入了顶点色也会带来很大的数据量。</p> 
<p>还有在Nanite的渲染时，三角面的优化过程当中。如果有顶点色结合一起工作，可能会带来一些其它的问题。这个后面会有所提及。</p> 
<p>下面是高模斩UV的视频，可以自行搜索。<br> <img src="https://images2.imgbox.com/1b/64/xjx7Tcvr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="UVLOD_108"></a>关于模型UV/顶点色/法线/LOD</h3> 
<p>关于模型的UV/顶点色/法线/LOD对Nanite的渲染效率以及数据量的影响。</p> 
<p>UV它的cluster或者被拆分时候打散的程度，以及UV顶点是否被焊起来，还有就是UV的通道数量，这些都会非常大的影响数据量。另外UV cluster的拆分也会影响减面和剔除效果。</p> 
<p>顶点色本身会占用额外的数据。另外顶点色也会影响减面的效果，并有可能产生问题。比如拉远减面的过程中会产生一些跳变。另外，Nanite目前还不支持在实例上直接绘制顶点色。</p> 
<p>顶点的法线的复杂程度或者是否被打散或者说光滑组的多少都会影响Nanite在渲染是的一个减面效果。同时打散的顶点法线也会增加数据量。</p> 
<p>关于LOD，Nanite没有LOD一说。但是它有一个Fallback Mesh，它是用来作为复杂的碰撞体或者Lumen在渲染时候的Lumen Scence的一个捕获对象。以及如果使用光线追踪的阴影的话，默认的投影对象。所以在这个层面上我们是需要生成这个Fallback Mesh。但生成的复杂度不用太高，主要还是为了Lumen Scence的捕获。</p> 
<p><img src="https://images2.imgbox.com/23/6c/ZXV0nVKl_o.png" alt="在这里插入图片描述"></p> 
<p><strong>具体演示看视频</strong>。</p> 
<h3><a id="Nanite_125"></a>如何减少Nanite的数据量？</h3> 
<p>在内容浏览器里把鼠标放在资产上会显示一些相关的数字。<br> <img src="https://images2.imgbox.com/0b/f8/J6lEr90m_o.png" alt="在这里插入图片描述"></p> 
<p>Disk Size也就是资产在磁盘上的大小。另外，这里有一个Nanite的压缩的尺寸（Est Nanite Compressed Size）以及最终压缩总的一个包的尺寸(Est Compressed Size)。Est Compressed Size是打包以后的大小。尺寸相差非常大。因为Nanite的压缩率比普通的Mesh要大得多。但是在编辑器里面因为我们有可能随时开关的Nanite，所以它的资产里面其实保留了原始的模型的数据。所以磁盘上的数据大小是原始的模型数据加上Nanite的模型数据。所以对于数据量的减少我们不能指望Nanite的高压缩率，而是得回到模型本身或者在做法上面实实在在的去优化它。</p> 
<p><strong>第一点</strong>也是最重要的，需要仔细的根据模型的使用场合去评估一下需要多少三角面。用刚才说的评估的方式，而这种方式下面至少给我们一个概念或者极限值一个数量级，多大的模型需要多少三角面，而不至于出现很离谱的非常少的影响品质的或者非常多的大几千甚至上亿的情况出现。如果必须要用那么高的面去表现足够的细节，可能就需要考虑拆分模型。</p> 
<p><strong>第二点</strong>就是尽量精简模型的数据，刚才提到的想光滑组法线，UV，还有那个顶点色等等。这边的原则并不是说尽量的去少用这些东西，而是在保证质量和需求的前提下尽量避免出现一些错误的操作，来产生额外的不需要的那些数据。</p> 
<p>另外关于Nanite的Fallback模型，它的模型面数是可以调整的，但是它的数据量的大小只会影响打包以后的大小，并不会影响磁盘的大小。因此对于做影视的来说Fallback Mesh的面的高低，其实是不会影响资产的工程里的大小的。但并不是建议大家都用很高的Fallback Mesh面数。因为它还是会影响渲染的效率。</p> 
<p>下面演示怎么去看数据以及优化或清理一些工具的使用，<strong>具体看视频</strong>。</p> 
<p><strong>第三点</strong>就是减小模型的种类的数量把模型合理的拆分重复使用，也就是<strong>模块化</strong>。</p> 
<h3><a id="_144"></a>模块化的优缺点</h3> 
<p>模块化有很多优势，但也有些缺点。</p> 
<p>我觉得最大的优点主要是提高了模型的精度。因为同样的三角面，当模块的模型比较小的时候，它可以表现更多的细节。又因为模型是可以复用的，所以对整个包体来说，整个数据量是减少的。另外相对小的模块，它对贴图的尺寸或者分辨率的要求没那么高，还有就是模块是通过拼来制作的。所以可以进行快速的修改和调整。</p> 
<p>至于缺点的话，因为都是复用的模块可能会缺少变化。比如说模块和模块之间的衔接缺少对环境，使用，天气一些细节的变化。这块会在后面具体提到如何去弥补这样的一个缺点。</p> 
<h3><a id="_152"></a>如何模块化？</h3> 
<p>可以从流程和如何拆分两个层面来讨论。</p> 
<p>在流程上面，简单地说我们可以在UE里面使用工具。比如Geometry Script搭建Block Out，并且拆分成模块，模块导出为Proxy Mesh。然后在DCC里面细化，然后导回UE更新Block Out。Block Out的模型的pivot，也就是轴心点以及包围盒的尺寸都要捕捉到网格，拼接的时候也要捕捉到网格。另外DCC里细化模型时，不能改变它的轴心和边界范围。拼接的话模型最好是在UE里面组装，因为在外面面数高的话交互比较慢，UE里渲染快，也可以看到更多细节。另外DCC里组装的话，我们也可以使用实例的方式组装。导入UE的时候，UE可以识别到这些实例。完了以后我们可以在UE里对这一组模型进行Level Instance Actor的创建。作为一个prefab（预制），以便今后使用。</p> 
<p>第二个问题就是怎么拆，需要考虑两方面的因素。一个是需要能够复用，第二个是大小要核实。</p> 
<p>关于大小的话可以参考观看最近距离，如果大于可以看到1/2整体就可以拆分了。根据刚才的面数评估这种拆法的话模型最多的面数不会超过1600万面。当然植被这种开放型三角面的模型除外，它比较随机。另外如果小的物体最近观看距离远远达不到模型整体充满整个屏幕的时候，就可以考虑合并。当然合并的时候也要符合可以复用这个前提。</p> 
<p>举几个具体的例子，对于地砖，柱子这些建筑的模块不大不小，而且很容易看出可以复用。对于不太好判断的，比如非常大的山崖，这种模型如果要非常近的距离观察它肯定是精度不够的，否则的话就需要非常多的三角面。而且它不好被拆分。这种情况下近距离看的时候就会去覆盖一些其它的模型作为近景来弥补它三角面的缺失问题。</p> 
<p>而对于很小的模型，比如一个瓦片，大部分时候不能达到撑满整个屏幕的，就需要合并。比如把多片瓦片合成一溜，在拼接的时候也可以重复。也不至于每个模块太小。</p> 
<p>这下面是黑客帝国建筑的一个拆分方式，可以参考。<br> <img src="https://images2.imgbox.com/59/25/gd2tlyht_o.png" alt="在这里插入图片描述"></p> 
<p><strong>后续演示具体看视频</strong>。</p> 
<h3><a id="_173"></a>为模块化的环境添加变化</h3> 
<p>模块化的构建方式会带来重复性，下面介绍怎样为这种环境添加一些额外的变化。</p> 
<p>首先可以通过材质为每个对象添加一些变化，通常做法就是换贴图或者改变材质的某些属性等等。但这样做往往会增加贴图的数量或者说增加材质的数量，会增加开销。</p> 
<p>接下来主要提一下，我们怎样在不改变材质或材质实例的情况下，利用材质中一些外部信息的接口帮助实现这个目的。</p> 
<p>这些接口或者数据的信息主要来自于模型或者对象本身，也可以来自于环境。</p> 
<p>下面列了一些，<strong>具体介绍看视频</strong>。<br> <img src="https://images2.imgbox.com/33/16/rLTxtmzF_o.png" alt="在这里插入图片描述"></p> 
<p>还有一种利用材质改变环境增加变化的方法是分层，就是把材质分成不同的功能层。比如基础层构建成环境层，这样的话每个层可以复用，也可以叠加，从而产生更多的变化。</p> 
<p>下面是黑客帝国案例墙面的分层制作，<strong>具体演示看视频</strong>。<br> <img src="https://images2.imgbox.com/0d/c9/lDpCBoNo_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_195"></a>需要使用虚拟贴图吗？</h3> 
<p>虚拟贴图有自己的优缺点。</p> 
<p>优点是对内存的管理或者使用比较优化。另外可以使用很大的贴图精度比较高，还有可以减少材质的数量，增加外表的变化。</p> 
<p>缺点的话，它本身会比普通的贴图采样增加一定的开销。另外，有些Filter会产生闪烁的问题，还有加载延迟的问题。</p> 
<p><strong>问题演示具体看视频</strong>。</p> 
<h3><a id="_205"></a>如何减小贴图内存占用</h3> 
<p>首先是尽量使用虚拟贴图，虚拟贴图看到多少才加载多少。</p> 
<p>第二个影响大的因素是压缩和非压缩，有的时候为了品质直接不压缩，这个和非压缩的差距是很大的。如果需要品质我们可以选择BC7的压缩方式。</p> 
<p>第三个影响大的因素是Mipmap的关闭，有的时候觉得贴图看着比较糊就不map了这个影响很大。我们可以通过改变map的生成方式。比如说sharpen的方式来改进map的清晰度。另外制作的时候贴图长宽的分辨率需要是2的幂次，否则不会产生Mipmap。从而增加开销和绘制的效率。另外就是把不同的纹理可以pack到贴图的RGBA不同的通道里面，从而减少贴图的采样和内存的消耗。</p> 
<p>但是这里要注意的是如果有带Alpha通道就建议用BC7的压缩方式。</p> 
<h3><a id="_215"></a>需要多大的贴图？</h3> 
<p>需要多大的贴图？也就是贴图的分辨率。这取决于像素的密度和贴图的texture密度的比值。编辑器也有检查工具之前LookDev的章节已经有所提及。这里补充一下，如果是Nanite的模型要看贴图密度的视图需要暂时的通过actor上的Disable Nanite关闭。</p> 
<p><strong>具体演示看视频</strong>。</p> 
<p>一般来说贴图最大不建议超过4K，否则的话会增加贴图编辑的难度，提高的品质也不是那么多。如果真的需要更加高的密度，那可能就需要利用UDIM的贴图或者拆分模型。从这个层面看的话，模型也不建议做的太大。</p> 
<h3><a id="UDIM_223"></a>关于UDIM的使用</h3> 
<ol><li>它最大支持的象限是9000个象限（900纵×10横）</li><li>它可以支持不同的分辨率，也就是说在不同象限里，可以使用不同的分辨率，小的分辨率的贴图并不会额外增加内存的使用。</li><li>考虑哪些贴图可以合在一起。比如刚才黑客帝国例子里，把同一类型的贴图比如墙面的各种砖块的贴图放在一起。然后我们通过UV的偏移进行采样不同的区域增加变化。第二种是把经常放在一起的模型的贴图。比如说一个建筑，把建筑上的梁，墙和瓦这种放在一起。这样的好处是在一个角度我看到这个建筑整体的时候，可以减少材质的数量。但使用不同Shading Model的材质贴图可能就需要分开。比如角色的毛发，皮肤和衣服的材质。还有一个就是刚才例子里提到的，我们可以巧妙的利用UDIM的各种象限，有规则的把不同的UV放在不同的象限里面。然后通过材质而产生一些特定的效果。</li></ol> 
<h3><a id="_229"></a>总结</h3> 
<ul><li>实时流程相对传统CG需要兼顾品质和效率，尤其效率有其现实意义</li><li>技术改进拉进目标：更加细腻和高效的Streaming流送方式</li><li>理解Nanite和VT（虚拟贴图），如何兼顾品质和效率的思路和做法</li></ul> 
<p><strong><font color="orange">最后：能用尽用</font></strong></p> 
<h3><a id="_240"></a>学习地址</h3> 
<p><a href="https://www.bilibili.com/video/BV18X4y1k7R1/?spm_id_from=333.999.0.0&amp;vd_source=0d7a033ae3857de534c8d7dde0403880" rel="nofollow">地址</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b34dd0c4ed75ba0f448ecc152143ce4b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot如何整合mongodb</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/52d94fedaaa9af60b2de32ecb8986f11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[c&#43;&#43;] [1043] 最高的分数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>