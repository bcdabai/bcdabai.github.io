<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue组件化、插槽（Vue全局组件和局部组件定义、创建组件和注册组件，组件中使用methods和data，component、keep-alive标签、父子组件的数据与方法传递和多级传递bus通信） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue组件化、插槽（Vue全局组件和局部组件定义、创建组件和注册组件，组件中使用methods和data，component、keep-alive标签、父子组件的数据与方法传递和多级传递bus通信）" />
<meta property="og:description" content="目录
Vue组件化
Vue全局组件
创建全局组件
注册全局组件
Vue局部组件
解决template下编写HTML代码没有提示问题
组件中使用methods
组件中使用data
component标签
切换组件动画
keep-alive标签
slot标签
匿名插槽
具名插槽
v-slot:(#)
作用域插槽
v-slot:(#)补充
父子组件
父子组件数据传递和多级传递
父子组件方法传递和多级传递
$event
父子组件数据传递和多级传递补充
任意组件之间数据传递补充：bus通信
组件渲染方式
方式一
方式二（render）
Vue-CLI（Command Line Interface）
Vue组件化 需要先创建组件构造器，然后注册已经创建好的组件，最后才能使用。使用时直接使用注册的组件名称，例如下面中可以直接使用&lt;name&gt;&lt;/name&gt;，网页渲染时便会使用template中的HTML代码替换name标签。
Vue全局组件 创建全局组件 通过var Compo=Vue.extend({template:&#39;&lt;div&gt;&lt;/div&gt;&#39;})创建全局组件，template：后直接跟组件的HTML代码即可。注意template中只能有一个根元素，多个元素只会显示一条。
注册全局组件 通过Vue.component(&#39;name&#39;,Compo)注册已经创建好的组件，第一个参数为指定已经创建好的名称，第二个参数为已经创建好的组件构造器。注意第二个参数还可以为一个对象obj，系统会调用Vue.extend(obj)，将返回结果再传入其中（Vue.component(&#39;name&#39;,{template:&lt;div&gt;&lt;/div&gt;})可以将创建和注册全局组件变成一步）。注意如果在注册的命名时使用了驼峰命名，那么使用组件时需要将大写变为小写字母并且在之前加上-，例如Vue.component(&#39;myName&#39;,Compo)，使用时为&lt;my-name&gt;&lt;/my-name&gt;，还需注意注册名不能与HTML已有标签重名。
Vue局部组件 不需要注册，直接在实例中的component属性中定义即可，例如new Vue（{el:&#39;#app&#39;,data:{},components:{&#39;name&#39;:{template:&#39;&lt;div&gt;&lt;/div&gt;&#39;}}})，局部组件和全局组件重名时只有局部组件生效。
解决template下编写HTML代码没有提示问题 在新建的script标签中添加type和id属性，例如：&lt;script id= &#39;info&#39; type=&#39;text/html&#39;&gt;&lt;/script&gt;，并在此标签中编写HTML代码，这样会有提示，最后在注册时的template中写上template:&#39;#info&#39;即可。使用Vue提供的template标签并给其添加id，其它同上。 组件中使用methods 组件中只能使用组件中定义的methods而不是Vue实例中的methods，即需要给Vue.extend中传入的对象添加methods属性，在methods指向的对象中定义方法，这些方法才能在组件中使用，例如{template:&#39;&lt;div&gt;&lt;/div&gt;&#39;,methods:{fun(){}}}，这样便可已在在该组件中使用fun函数（可以在template中使用），局部组件也是同理，在methods中使用this加属性名的方法拿到的数据是组件中定义的data函数返回对象的数据。
组件中使用data 组件中同样也只能使用组件中定义的data而不是Vue实例中的data，和methods不同的是，组件中定义的data需要是一个函数，该函数返回的对象可以理解为data，例如{template:&#39;&lt;div&gt;&lt;/div&gt;&#39;,data(){return {abc:123}}}，在template中便可以用插值语法{{abc}}来显示123。这样的好处是复用多个组件时，每个组件都会运行一遍data函数，并将其与当前组件绑定起来，使每个组件的数据相互独立，避免了多个组件公有一份数据。
component标签 用于切换组件，该标签上有is属性，我们通过v-bind：给is属性绑定不同的属性名，便会将该标签替换为属性名对应相同的组件名的标签（也可以使用v-if和v-else实现替换组件功能）。
切换组件动画 在Vue中通过transition标签包裹component标签进行切换组件的动画，这时现有组件消失和新组件的进入动画是同时进行的，要想改变进行的次序，则在transition标签上添加mode属性，分别可以取&#39;in-out&#39;和&#39;out-in&#39;两值，&#39;in-out&#39;代表新元素先进行过度，完成之后当前元素离开，另一个相反。
keep-alive标签 用于在切换组件的之前缓存数据，当切换回来时候，还会有相同的数据。使用方法：将该标签包裹component标签即可。示例：比如component切换的组件中有复选框，切换前选中了，如果切换后再次切换回来，加了该标签后仍然会显示勾选状态。
slot标签 匿名插槽 用于在组件标签中动态添加内容（默认是不能添加的）。通过将slot标签写入组件的template中，此时我们使用该组件，如果在组件标签中添加了内容，那么该内容将会替换template中的slot标签全部内容，如果没有添加内容，那么会显示slot中的内容。注意当template中的slot标签有多个时，会将在组件标签中的全部内容内容复制多份分别替换。
具名插槽 用于当有多个slot标签时，在组件标签中动态添加内容时能替换指定的slot标签。当slot标签上添加了name属性时便为具名插槽（例如name=&#39;one&#39;），这时组件标签中动态添加的内容便不会替换该slot标签，要想替换该内容需要在组件标签添加的元素中加入slot属性等于相应的名称（例如v-slot:one便会替换name=&#39;one&#39;的slot标签），那么该内容才会去替换（不会叠加，指定多条slot=&#39;name&#39;，这些内容将全部替换）。
v-slot:(#) 用于解决具名插槽中多个元素需要给每个元素添加slot（slot=&#39;one&#39;）属性。该指令必须搭配template标签，在template标签上添加属性v-slot:one，这样便会将template中的内容替换slot标签中name=&#39;one&#39;的标签。v-slot:可以简写为#。
作用域插槽 用于解决父组件标签中填充内容无法使用子组件的数据问题。通过在子组件内部的slot标签上添加属性例如v-bind:son=&#39;sondata&#39;，其中sondata为子组件中的数据，son为传递的数据名，在父组件的标签中的template标签上添加属性slot-scope=&#39;abc&#39;，便可以在template标签下使用{{abc.son}}，代替sondata数据。
v-slot:(#)补充 v-slot:也可以解决父组件标签中填充内容无法使用子组件的数据问题。例如通过v-slot:default=&#39;abc&#39;（匿名插槽时default可以省略即v-slot=），表示接收匿名插槽传递的数据，如果插槽有name=&#39;one&#39;属性，则将default替换为one即可，同上便可以在template标签下使用{{abc.son}}。
注意可以解构赋默认值例如：v-slot={son:child=&#39;process&#39;}和slot-scope={son:child=&#39;process&#39;}都表示将组件slot上绑定的son属性解构为变量名child，且child不存在赋值为字符串&#39;process&#39;。例如下面当子组件中的sondata没有值或值为undefined时，父组件中插槽的child为&#39;process&#39;，否则为子组件中的sondata的值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/39250821eed6b3280703b7a8dfc4bb08/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-21T09:56:25+08:00" />
<meta property="article:modified_time" content="2023-01-21T09:56:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue组件化、插槽（Vue全局组件和局部组件定义、创建组件和注册组件，组件中使用methods和data，component、keep-alive标签、父子组件的数据与方法传递和多级传递bus通信）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="Vue%E7%BB%84%E4%BB%B6%E5%8C%96-toc" style="margin-left:0px;"><a href="#Vue%E7%BB%84%E4%BB%B6%E5%8C%96" rel="nofollow">Vue组件化</a></p> 
<p id="Vue%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px;"><a href="#Vue%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6" rel="nofollow">Vue全局组件</a></p> 
<p id="var%20Compo%3DVue.extend(%7Btemplate%3A'%3Cdiv%3E%3C%2Fdiv%3E'%7D)-toc" style="margin-left:80px;"><a href="#var%20Compo%3DVue.extend%28%7Btemplate%3A'%20rel=">创建全局组件</a></p> 
<p id="Vue.component('name'%2CCompo)-toc" style="margin-left:80px;"><a href="#Vue.component%28'%20rel=">注册全局组件</a></p> 
<p id="Vue%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px;"><a href="#Vue%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6" rel="nofollow">Vue局部组件</a></p> 
<p id="%E8%A7%A3%E5%86%B3template%E4%B8%8B%E7%BC%96%E5%86%99HTML%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E6%8F%90%E7%A4%BA%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E5%86%B3template%E4%B8%8B%E7%BC%96%E5%86%99HTML%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E6%8F%90%E7%A4%BA%E9%97%AE%E9%A2%98" rel="nofollow">解决template下编写HTML代码没有提示问题</a></p> 
<p id="%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8methods-toc" style="margin-left:40px;"><a href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8methods" rel="nofollow">组件中使用methods</a></p> 
<p id="%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8data-toc" style="margin-left:40px;"><a href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8data" rel="nofollow">组件中使用data</a></p> 
<p id="component%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#component%E6%A0%87%E7%AD%BE" rel="nofollow">component标签</a></p> 
<p id="%E5%88%87%E6%8D%A2%E7%BB%84%E4%BB%B6%E5%8A%A8%E7%94%BB-toc" style="margin-left:80px;"><a href="#%E5%88%87%E6%8D%A2%E7%BB%84%E4%BB%B6%E5%8A%A8%E7%94%BB" rel="nofollow">切换组件动画</a></p> 
<p id="keep-alive%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#keep-alive%E6%A0%87%E7%AD%BE" rel="nofollow">keep-alive标签</a></p> 
<p id="slot%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#slot%E6%A0%87%E7%AD%BE" rel="nofollow">slot标签</a></p> 
<p id="%E5%8C%BF%E5%90%8D%E6%8F%92%E6%A7%BD-toc" style="margin-left:80px;"><a href="#%E5%8C%BF%E5%90%8D%E6%8F%92%E6%A7%BD" rel="nofollow">匿名插槽</a></p> 
<p id="%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD-toc" style="margin-left:80px;"><a href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD" rel="nofollow">具名插槽</a></p> 
<p id="v-slot%3A(%23)-toc" style="margin-left:80px;"><a href="#v-slot%3A%28%23%29" rel="nofollow">v-slot:(#)</a></p> 
<p id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD-toc" style="margin-left:80px;"><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD" rel="nofollow">作用域插槽</a></p> 
<p id="v-slot%3A(%23)%E8%A1%A5%E5%85%85-toc" style="margin-left:80px;"><a href="#v-slot%3A%28%23%29%E8%A1%A5%E5%85%85" rel="nofollow">v-slot:(#)补充</a></p> 
<p id="%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6" rel="nofollow">父子组件</a></p> 
<p id="%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E5%92%8C%E5%A4%9A%E7%BA%A7%E4%BC%A0%E9%80%92-toc" style="margin-left:80px;"><a href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E5%92%8C%E5%A4%9A%E7%BA%A7%E4%BC%A0%E9%80%92" rel="nofollow">父子组件数据传递和多级传递</a></p> 
<p id="%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%92%8C%E5%A4%9A%E7%BA%A7%E4%BC%A0%E9%80%92-toc" style="margin-left:80px;"><a href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%92%8C%E5%A4%9A%E7%BA%A7%E4%BC%A0%E9%80%92" rel="nofollow">父子组件方法传递和多级传递</a></p> 
<p id="%C2%A0%24event-toc" style="margin-left:80px;"><a href="#%C2%A0%24event" rel="nofollow"> $event</a></p> 
<p id="%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E5%92%8C%E5%A4%9A%E7%BA%A7%E4%BC%A0%E9%80%92%E8%A1%A5%E5%85%85-toc" style="margin-left:80px;"><a href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E5%92%8C%E5%A4%9A%E7%BA%A7%E4%BC%A0%E9%80%92%E8%A1%A5%E5%85%85" rel="nofollow">父子组件数据传递和多级传递补充</a></p> 
<p id="%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E8%A1%A5%E5%85%85%EF%BC%9Abus%E9%80%9A%E4%BF%A1-toc" style="margin-left:80px;"><a href="#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E8%A1%A5%E5%85%85%EF%BC%9Abus%E9%80%9A%E4%BF%A1" rel="nofollow">任意组件之间数据传递补充：bus通信</a></p> 
<p id="%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F" rel="nofollow">组件渲染方式</a></p> 
<p id="%E6%96%B9%E5%BC%8F%E4%B8%80-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E5%BC%8F%E4%B8%80" rel="nofollow">方式一</a></p> 
<p id="%E6%96%B9%E5%BC%8F%E4%BA%8C-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E5%BC%8F%E4%BA%8C" rel="nofollow">方式二（render）</a></p> 
<p id="Vue-CLI%EF%BC%88Command%20Line%20Interface%EF%BC%89-toc" style="margin-left:80px;"><a href="#Vue-CLI%EF%BC%88Command%20Line%20Interface%EF%BC%89" rel="nofollow">Vue-CLI（Command Line Interface）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="Vue%E7%BB%84%E4%BB%B6%E5%8C%96">Vue组件化</h2> 
<p>需要先<strong>创建组件构造器</strong>，然后<strong>注册已经创建好的组件</strong>，最后才能使用。使用时直接使用注册的组件名称，例如下面中可以直接使用&lt;name&gt;&lt;/name&gt;，网页渲染时便会使用template中的HTML代码替换name标签。</p> 
<p></p> 
<h3 id="Vue%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6">Vue全局组件</h3> 
<h4 id="var%20Compo%3DVue.extend(%7Btemplate%3A'%3Cdiv%3E%3C%2Fdiv%3E'%7D)">创建全局组件</h4> 
<p>通过<strong>var Compo=Vue.extend({template:'&lt;div&gt;&lt;/div&gt;'})</strong>创建全局组件，template：后直接跟组件的HTML代码即可。注意<span style="color:#f33b45;"><strong>template中只能有一个根元素</strong></span>，多个元素只会显示一条<strong>。</strong></p> 
<h4 id="Vue.component('name'%2CCompo)">注册全局组件</h4> 
<p>通过<strong>Vue.component('name',Compo)</strong>注册已经创建好的组件，第一个参数为指定已经创建好的名称，第二个参数为已经创建好的组件构造器。注意第二个参数还可以为一个对象obj，系统会调用Vue.extend(obj)，将返回结果再传入其中（<strong>Vue.component('name',{template:&lt;div&gt;&lt;/div&gt;})<span style="color:#f33b45;">可以将创建和注册全局组件变成一步</span></strong>）。<strong>注意如果<span style="color:#f33b45;">在注册的命名时使用了驼峰命名，那么使用组件时需要将大写变为小写字母并且在之前加上-</span></strong><strong>，例如Vue.component('myName',Compo)，使用时为&lt;my-name&gt;&lt;/my-name&gt;，还需注意<span style="color:#f33b45;">注册名不能与HTML已有标签重名</span>。</strong></p> 
<h3 id="Vue%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6">Vue局部组件</h3> 
<p id="new%20Vue%EF%BC%88%7Bel%3A'%23app'%2Cdata%3A%7B%7D%2Ccomponents%3A%7B'name'%3A%7Btemplate%3A'%3Cdiv%3E%3C%2Fdiv%3E'%7D%7D%7D)">不需要注册，直接在实例中的component属性中定义即可，例如new Vue（{el:'#app',data:{},<strong>components:{'name':{template:'&lt;div&gt;&lt;/div&gt;'}}</strong>})，局部组件和全局组件重名时只有局部组件生效。</p> 
<p></p> 
<h3 id="%E8%A7%A3%E5%86%B3template%E4%B8%8B%E7%BC%96%E5%86%99HTML%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E6%8F%90%E7%A4%BA%E9%97%AE%E9%A2%98">解决template下编写HTML代码没有提示问题</h3> 
<ol><li>在新建的script标签中添加type和id属性，例如：<strong>&lt;script id= 'info' type='text/html'&gt;</strong>&lt;/script&gt;，并在此标签中编写HTML代码，这样会有提示，最后在注册时的template中写上template:'#info'即可。</li><li>使用Vue提供的<strong>template标签并给其添加id</strong>，其它同上。</li></ol> 
<p></p> 
<h3 id="%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8methods">组件中使用methods</h3> 
<p>组件中只能使用组件中定义的methods而不是Vue实例中的methods，即需要给Vue.extend中传入的对象添加methods属性，在methods指向的对象中定义方法，这些方法才能在组件中使用，例如{template:'&lt;div&gt;&lt;/div&gt;',<strong>methods:{fun(){}}</strong>}，这样便可已在在该组件中使用fun函数（可以在template中使用），局部组件也是同理，在methods中使用this加属性名的方法拿到的数据是组件中定义的data函数返回对象的数据。</p> 
<p></p> 
<h3 id="%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8data">组件中使用data</h3> 
<p>组件中同样也只能使用组件中定义的data而不是Vue实例中的data，和methods不同的是，<strong>组件中定义的data需要是一个函数，该函数返回的对象可以理解为data</strong>，例如{template:'&lt;div&gt;&lt;/div&gt;',<strong>data(){return {abc:123}}</strong>}，在template中便可以用插值语法{<!-- -->{abc}}来显示123。这样的<strong>好处是复用多个组件时，每个组件都会运行一遍data函数，并将其与当前组件绑定起来，使每个组件的数据相互独立</strong>，避免了多个组件公有一份数据<strong>。</strong></p> 
<p></p> 
<h3 id="component%E6%A0%87%E7%AD%BE">component标签</h3> 
<p>用于切换组件，该标签上有is属性，我们通过<strong>v-bind：</strong>给<strong>is属性绑定不同的属性名</strong>，便会将该标签替换为属性名对应相同的组件名的标签（也可以使用v-if和v-else实现替换组件功能）。</p> 
<h4 id="%E5%88%87%E6%8D%A2%E7%BB%84%E4%BB%B6%E5%8A%A8%E7%94%BB">切换组件动画</h4> 
<p>在Vue中通过transition标签包裹component标签进行切换组件的动画，这时现有组件消失和新组件的进入动画是同时进行的，要想改变进行的次序，则在transition标签上添加<strong>mode属性</strong>，分别可以取<strong>'in-out'和'out-in'</strong>两值，<strong>'in-out'代表新元素先进行过度，完成之后当前元素离开</strong>，另一个相反。</p> 
<p></p> 
<h3 id="keep-alive%E6%A0%87%E7%AD%BE">keep-alive标签</h3> 
<p><strong>用于在切换组件的之前缓存数据</strong>，当切换回来时候，还会有相同的数据。使用方法：将该标签包裹component标签即可。示例：比如component切换的组件中有复选框，切换前选中了，如果切换后再次切换回来，加了该标签后仍然会显示勾选状态。</p> 
<p></p> 
<h3 id="slot%E6%A0%87%E7%AD%BE">slot标签</h3> 
<h4 id="%E5%8C%BF%E5%90%8D%E6%8F%92%E6%A7%BD">匿名插槽</h4> 
<p><strong>用于在组件标签中动态添加内容（默认是不能添加的）</strong>。通过将slot标签写入组件的template中，此时我们使用该组件，如果在组件标签中添加了内容，那么该内容将会替换template中的slot标签全部内容，如果没有添加内容，那么会显示slot中的内容。注意当template中的slot标签有多个时，会将在组件标签中的全部内容内容复制多份分别替换。</p> 
<h4 id="%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">具名插槽</h4> 
<p><strong>用于当有多个slot标签时，在组件标签中动态添加内容时能替换指定的slot标签</strong>。当slot标签上添加了name属性时便为具名插槽（例如name='one'），这时组件标签中动态添加的内容便不会替换该slot标签，要想替换该内容需要在组件标签添加的元素中加入slot属性等于相应的名称（例如v-slot:one便会替换name='one'的slot标签），那么该内容才会去替换（不会叠加，指定多条slot='name'，这些内容将全部替换）。</p> 
<h4 id="v-slot%3A(%23)">v-slot:(#)</h4> 
<p>用于解决具名插槽中多个元素需要给每个元素添加slot（slot='one'）属性。该<strong>指令<span style="color:#fe2c24;">必须搭配template标签</span></strong>，在template<strong>标签上添加属性v-slot:one</strong>，这样便会将template中的内容<strong>替换slot标签中name='one'的标签</strong>。v-slot:可以简写为#。</p> 
<h4 id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">作用域插槽</h4> 
<p>用于解决父组件标签中填充内容无法使用子组件的数据问题。通过在子组件内部的<strong>slot标签上添加属性</strong>例如v-bind:son='sondata'，其中sondata为子组件中的数据，son为传递的数据名，在父组件的标签中的template标签上添加属性<span style="color:#fe2c24;"><strong>slot-scope=</strong></span>'abc'，便可以在template标签下使用{<!-- -->{abc.son}}，代替sondata数据。</p> 
<h4 id="v-slot%3A(%23)%E8%A1%A5%E5%85%85">v-slot:(#)补充</h4> 
<p>v-slot:也可以解决父组件标签中填充内容无法使用子组件的数据问题。例如通过<span style="color:#fe2c24;">v-slot:</span><strong>default='abc'（匿名插槽时default可以省略即<span style="color:#fe2c24;">v-slot=</span>）</strong>，表示接收匿名插槽传递的数据，如果<strong>插槽有name='one'属性，则将default替换为one</strong>即可，同上便可以在template标签下使用{<!-- -->{abc.son}}。</p> 
<p>注意可以解构赋默认值例如：v-slot={son:child='process'}和slot-scope={son:child='process'}都表示将组件slot上绑定的son属性解构为变量名child，且child不存在赋值为字符串'process'。例如下面当子组件中的sondata没有值或值为undefined时，父组件中插槽的child为'process'，否则为子组件中的sondata的值。</p> 
<pre><code class="language-html">//父组件
&lt;child&gt;
    &lt;slot v-slot={son:child='procss'}&gt;
        &lt;div&gt;{<!-- -->{child}}&lt;/div&gt;
    &lt;/slot&gt;
&lt;/child&gt;


//子组件child.vue
&lt;span&gt;
  &lt;slot v-bind:son="sondata"&gt;
  &lt;/slot&gt;
&lt;/span&gt;</code></pre> 
<p></p> 
<h3 id="%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6">父子组件</h3> 
<p>理解：<strong>Vue实例其实可以看做为一个父组件，实例中定义的局部组件，可以看做它中的子组件。</strong>同理，例如全局自定义组件，我们可以在传入的对象中添加components属性来定义子组件即var ff=Vue.extend({template:'&lt;div&gt;father&lt;/div&gt;'，components:<strong>{'son':{template:'&lt;div&gt;son&lt;/div&gt;'}}</strong>})，注意<strong>son组件只能在其父组件中使用</strong>，即上例中注册组件Vue.component('father',ff)后，那么son组件便只能在father组件中使用。局部自定义组件的父子组件定义规则也相同。</p> 
<h4 id="%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E5%92%8C%E5%A4%9A%E7%BA%A7%E4%BC%A0%E9%80%92">父子组件数据传递和多级传递</h4> 
<p>默认情况下是不能互相直接使用数据，但是我们可以通过下面方法<strong>由父组件向子组件传递数据：</strong></p> 
<ol><li>在父组件标签上使用v-bind:绑定传递数据（<span style="color:#f33b45;"><strong>可以不使用，不使用拿到的就是字符串'name1</strong>'</span>），例如:fathername1='name1'和:fathername2='name2'，其中name1为father中的数据，fathername1为传递数据的名称。</li><li>在子组件中添加属性props（数组）接收该数据，var ff=Vue.extend({template:'&lt;div&gt;father&lt;/div&gt;'，components:{'son':{template:'&lt;div&gt;son&lt;/div&gt;',<strong>props:['fathername1','fathername2']</strong>}}})。<strong>注意如果想要接收的数据使用驼峰命名，在第一步中需要将传递的数据名称去掉大写字母并在之前加-连接，例如1中使用father-name1为传递数据的名称，则2中接收的数据名将会变为fatherName。可以多级传递（爷向父向子等逐一传递），方法一样，<span style="color:#f33b45;">props数组中的数据时不允许修改的（修改后可以正常运行，但会报错）</span>。</strong></li><li><strong><span style="color:#f33b45;">props属性可以是对象写法例如props:{fathername1:String,fathername2:Boolean}，此时会指定fathername1的数据类型为字符串类型</span>，而2为布尔类型，如果传递的值不是该类型会报错。此时注意<span style="color:#f33b45;">fatername1还可以为一个对象，例如fatername1:{type:String,default:'pyf'}，代表可以指定数据类型和默认值为'pyf'</span>（不传数据时为默认值）</strong></li></ol> 
<h4 id="%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%92%8C%E5%A4%9A%E7%BA%A7%E4%BC%A0%E9%80%92">父子组件方法传递和多级传递</h4> 
<p>同样不能互相直接使用方法，通过下面方法实现<strong>父组件向子组件传递方法：</strong></p> 
<ol><li>子组件标签中使用v-on:绑定传递方法，例如：@fatherfun=‘fun’，其中fun为father中的函数，fatherfun为传递函数的名称。</li><li>和传递数据不同子组件不用接收，子组件在自己方法中<strong>直接通过this.$emit('fatherfun')运行传递的方法</strong>。注意$emit()中还可以接收其它参数，<strong>它会将后面的参数传递个运行的方法</strong>，例如<strong>this.$emit('fatherfun','a1','a2',...,'an')，相当于运行了fatherfun（'a1','a2',...,'an'）<span style="color:#f33b45;">而且是在父组件的环境中运行的即fatherfun函数体中的this.拿到的数据是父组件的数据，而不是当前组件的</span>（其它的this依然是当前组件的数据，例如参数使用this.a1,this.a2...是拿到当前组件的数据）。注意方法的传递不能使用驼峰命名，只能使用短横线命名即1中使用father-fun，2中也使用同样的</strong>。<strong>可以多级传递（爷向父向子等逐一传递）</strong>，<strong>将父组件中传递的方法this.$emit('fatherfun')放入该组件的methods中定义的方法中（例如methods中定义myfun），然后再通过将以上方法（@grandsun='myfun'）传递给孙组件即可</strong>。</li></ol> 
<p>注意<span style="color:#f33b45;"><strong>在组件标签上使用v-model例如v-model=username相当于:value=username和@input=函数，即我们在prop数组中可以直接用value接收，也可以通过this.$emit('input','pyf'),将数据'pyf'传给父组件中的username。</strong></span></p> 
<h4 id="%C2%A0%24event"> $event</h4> 
<p>在html中@绑定的函数中可以用作事件对象入参，也可以在父子组件传递的过程中用emit触发事件中的参数传递给绑定函数</p> 
<p><a href="https://blog.csdn.net/violateer/article/details/108900251" title="Vue中的$event详解_violateer的博客-CSDN博客_vue $even">Vue中的$event详解_violateer的博客-CSDN博客_vue $even</a></p> 
<p><a href="https://blog.csdn.net/xiaojin21cen/article/details/126883966" title="Vue 方法中 $event 的用法_猎人在吃肉的博客-CSDN博客_vue中$event用法">Vue 方法中 $event 的用法_猎人在吃肉的博客-CSDN博客_vue中$event用法</a></p> 
<h4 id="%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E5%92%8C%E5%A4%9A%E7%BA%A7%E4%BC%A0%E9%80%92%E8%A1%A5%E5%85%85">父子组件数据传递和多级传递补充</h4> 
<p>由于上例方法传递中fatherfun函数体中的this.拿到的数据是父组件的数据，那么我们也可以变相的<strong>实现子组件向父组件传递数据：</strong></p> 
<ol><li>父组件向子组件传递方法。</li><li>子组件通过this.$emit()运行方法例如this.$emit('fatherfun',a1,a2,...,an)，并将子组件的数据放在a1,a2,...,an参数中。</li><li>在fatherfun的函数体中定义this.mya1=a1...这样就将父组件中的mya1改变为子组件中的数据a1。</li></ol> 
<p>父子组件传递传递数据补充：<span style="color:#f33b45;"><strong>可以通过Vue实例属性中的$ref拿到组件标签中的任何方法和数据直接修改</strong></span>（不方便查找数据出错，故不推荐）</p> 
<h4 id="%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E8%A1%A5%E5%85%85%EF%BC%9Abus%E9%80%9A%E4%BF%A1">任意组件之间数据传递补充：bus通信</h4> 
<p>定义2个全局组件bro1，bro2，在Vue实例对象vm1中实现bro1向bro2传递数据：这时需要借助新建的空Vue实例vm2，如果是bro1向bro2传递消息，则在bro2组件的组件已挂载生命周期方法mounted()中定义vm2上自定义事件vmBus即vm2.$on('vmBus',<span style="color:#fe2c24;"><strong>()=&gt;{}</strong></span>)，然后在bro1的方法中通过vm2.$emit.('vmBus',data1,..,datan)触发事件并传递bro1中的数据，注意<span style="color:#fe2c24;"><strong>在接收消息的组件中定义自定义事件时使用箭头函数，因为这样在箭头函数中this指向当前组件，如果用普通函数，则this指向借助的vm实例</strong></span>。</p> 
<h3 id="%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F">组件渲染方式</h3> 
<h4 id="%E6%96%B9%E5%BC%8F%E4%B8%80">方式一</h4> 
<p>在Vue控制区域使用组件标签渲染。</p> 
<h4 id="%E6%96%B9%E5%BC%8F%E4%BA%8C">方式二（render）</h4> 
<p>在实例Vue对象中通过render属性对应的方法渲染（Vue生命周期中会自动调用该方法），<strong>渲染方式会替换整个Vue的控制区域</strong>，例如new Vue（{el:'#app',data:{},<strong>render:function(fun){let html=fun('one');return html;}</strong>})，系统会给render指向的函数传一个函数名，该函数接收一个组件名的参数（已注册的组件名），可以生成对应组件的模板，最后将return的内容渲染到页面上去。</p> 
<p></p> 
<h4 id="Vue-CLI%EF%BC%88Command%20Line%20Interface%EF%BC%89">Vue-CLI（Command Line Interface）</h4> 
<p><a href="https://blog.csdn.net/AIWWY/article/details/117332396" title="Vue-CLI入门（webpack入门、安装配置Vue-CLI（命令、手动、自动版本）、使用Vue-CLI创建组件和Vuex和Vue-router、配置跨域请求数据以及配置webpack添加插件等）_AIWWY的博客-CSDN博客">Vue-CLI入门（webpack入门、安装配置Vue-CLI（命令、手动、自动版本）、使用Vue-CLI创建组件和Vuex和Vue-router、配置跨域请求数据以及配置webpack添加插件等）_AIWWY的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2de095f3f032cdeba23d095ea22cdcc0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一行代码解决PyTorch训练模型时突然出现的For debugging consider passing CUDA_LAUNCH_BLOCKING=1报错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b13d62cdc69a052905366387afd3c11e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于java的实验室预约系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>