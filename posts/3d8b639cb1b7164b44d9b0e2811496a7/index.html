<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>对象转型（向上转型和向下转型） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="对象转型（向上转型和向下转型）" />
<meta property="og:description" content="一、对象转型介绍 对象转型分为两种：一种叫向上转型(父类对象的引用或者叫基类对象的引用指向子类对象，这就是向上转型)，另一种叫向下转型。转型的意思是：如把float类型转成int类型，把double类型转成float类型，把long类型转成int类型，这些都叫转型。把一种形式转成另外一种形式就叫转型。除了基础数据类型的转型之外（基础数据类型的转型：大的可以转成小的，小的也可以转成大的。），对象领域里面也有对象之间的转型。
1.1.对象转型实例一 public class TestClassCast {
public static void main(String[] args) {
Animal a = new Animal(&#34;name&#34;);
Cat c = new Cat(&#34;catname&#34;,&#34;blue&#34;);
/**
* a instanceof Animal这句话的意思是a是一只动物吗？
* a是Animal这个类里面的是一个实例对象，所以a当然是一只动物，其结果为true。
*/
System.out.println(String.format(&#34;a instanceof Animal的结果是%s&#34;,a instanceof Animal));//true
/**
* 这里判断说“动物是一只猫”，不符合逻辑，所以打印出来的结果是false。
*/
System.out.println(String.format(&#34;a instanceof Cat的结果是%s&#34;,a instanceof Cat));
/**
* 这句话比较有意思了，a本身是Animal类的实例对象的引用，
* 但现在这个引用不指向Animal类的实例对象了，而是指向了Dog这个类的一个实例对象了，
* 这里也就是父类对象的引用指向了子类的一个实例对象。
*/
a = new Dog(&#34;bigyellow&#34;, &#34;yellow&#34;);
System.out.println(a.name);//bigyellow
/**
* 这里的furColor属性是子类在继承父类的基础上新增加的一个属性，是父类没有的。
* 因此这里使用父类的引用对象a去访问子类对象里面新增加的成员变量是不允许的，
* 因为在编译器眼里，你a就是Animal类对象的一个引用对象，你只能去访问Animal类对象里面所具有的name属性，
* 除了Animal类里面的属性可以访问以外，其它类里面的成员变量a都没办法访问。
* 这里furColor属性是Dog类里面的属性，因此你一个Animal类的引用是无法去访问Dog类里面的成员变量的，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3d8b639cb1b7164b44d9b0e2811496a7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-05-09T17:04:04+08:00" />
<meta property="article:modified_time" content="2016-05-09T17:04:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">对象转型（向上转型和向下转型）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="blogTitle0" style="margin-top:10px; font-size:21px; font-weight:bold; color:rgb(0,0,0); font-style:normal; font-variant:normal; letter-spacing:normal; line-height:20.8px; text-align:start; text-indent:0px; text-transform:none; white-space:normal; word-spacing:0px"> <span style="font-family:KaiTi_GB2312; font-size:24px">一、对象转型介绍</span></h3> 
<p><img src="https://images2.imgbox.com/6d/d1/rvFe1Ki0_o.jpg" alt=""></p> 
<p><br> </p> 
<p><span style="font-family:KaiTi_GB2312; font-size:18px">对象转型分为两种：一种叫向上转型(<span style="color:#FF0000">父类对象的引用或者叫基类对象的引用指向子类对象，这就是向上转型</span>)，另一种叫向下转型。转型的意思是：如把float类型转成int类型，把double类型转成float类型，把long类型转成int类型，这些都叫转型。把一种形式转成另外一种形式就叫转型。除了基础数据类型的转型之外（基础数据类型的转型：大的可以转成小的，小的也可以转成大的。），对象领域里面也有对象之间的转型。</span></p> 
<p><span style="font-family:KaiTi_GB2312; font-size:18px"></span></p> 
<h4 class="p0" id="blogTitle1" style=""><span style="font-family:宋体; line-height:24px">1.1.对象转型实例一</span></h4> 
<p></p> 
<p><img src="https://images2.imgbox.com/99/ca/vhyqtZef_o.png" alt=""><br> </p> 
<p><br> </p> 
<p> public class TestClassCast {<!-- --><br> <br>       public static void main(String[] args) {<!-- --><br>  <br>          Animal a = new Animal("name");<br>          Cat c = new Cat("catname","blue");<br> <br>         /**<br>          * a instanceof Animal这句话的意思是a是一只动物吗？<br>          * a是Animal这个类里面的是一个实例对象，所以a当然是一只动物，其结果为true。<br>          */<br>          System.out.println(String.format("a instanceof Animal的结果是%s",a instanceof Animal));//true<br>  <br>          /**<br>           * 这里判断说“动物是一只猫”，不符合逻辑，所以打印出来的结果是false。<br>          */<br>         System.out.println(String.format("a instanceof Cat的结果是%s",a instanceof Cat));<br>         /**<br>           * 这句话比较有意思了，a本身是Animal类的实例对象的引用，<br>          * 但现在这个引用不指向Animal类的实例对象了，而是指向了Dog这个类的一个实例对象了，<br>           * 这里也就是父类对象的引用指向了子类的一个实例对象。<br>          */<br>          a = new Dog("bigyellow", "yellow");<br>          System.out.println(a.name);//bigyellow<br>          /**<br>           * 这里的furColor属性是子类在继承父类的基础上新增加的一个属性，是父类没有的。<br>           * 因此这里使用父类的引用对象a去访问子类对象里面新增加的成员变量是不允许的，<br>           * 因为在编译器眼里，你a就是Animal类对象的一个引用对象，你只能去访问Animal类对象里面所具有的name属性，<br>           * 除了Animal类里面的属性可以访问以外，其它类里面的成员变量a都没办法访问。<br>           * 这里furColor属性是Dog类里面的属性，因此你一个Animal类的引用是无法去访问Dog类里面的成员变量的，<br>           * <span style="color:#FF0000">尽管a指向的是子类Dog的一个实例对象，但因为子类Dog从父类Animal继承下来，</span><br>           * <span style="color:#FF0000">所以new出一个子类对象的时候，这个子类对象里面会包含有一个父类对象，</span><br>           * <span style="color:#FF0000">因此这个a指向的正是这个子类对象里面的父类对象，<span style="color:#000000">因此尽管a是指向Dog类对象的一个引用</span></span>，<br>           * 但是在编译器眼里你a就是只是一个Animal类的引用对象，你a就是只能访问Animal类里面所具有的成员变量，<br>           * 别的你都访问不了。<br>           * <span style="color:#FF0000">因此一个父类(基类)对象的引用是不可以访问其子类对象新增加的成员(属性和方法)的。</span><br>          */<br>          <br>          //System.out.println(a.furColor);<br>          System.out.println(String.format("a指向了Dog，a instanceof Animal的结果是%s",a instanceof Animal));//true<br>          /**<br>          *<span style="color:#FF0000"> <span style="color:#000000">这里判断说“a是一只Dog”是true。</span><br>          * 因为instanceof探索的是实际当中你整个对象到底是什么东西，<br>          * 并不是根据你的引用把对象看出什么样来判断的。</span><br>           */<br>          System.out.println(String.format("a instanceof Dog的结果是%s",a instanceof Dog));//true<br>          <br>          /**<br>        <span style="color:#FF0000">  * 这里使用强制转换，把指向Animal类的引用对象a转型成指向Dog类对象的引用，<br>           * 这样转型后的引用对象d1就可以直接访问Dog类对象里面的新增的成员了。</span><br>          */<br>          Dog d1 = (Dog)a;<br>          System.out.println(d1.furColor);//yellow<br>     }<br> <br>  }</p> 
<p><br> </p> 
<p></p> 
<h4 id="blogTitle2" style="">内存分析</h4> 
<p></p> 
<p><img src="https://images2.imgbox.com/d5/0b/YEwgOuiX_o.png" alt=""><br> </p> 
<p>   在内存中可以看到，指向Dog类实例对象的引用对象a是一个Animal类型的引用类型，这就比较有意思了，Animal类型指向了Dog这个对象，那么，在程序的眼睛里会把这只Dog当成一只普通的Animal，既然是把Dog当成一只普通的Animal，那么Dog类里面声明的成员变量furColor就不能访问了，因为Animal类里面没有这个成员变量。因此，从严格意义上来讲，这个a眼里只看到了这个子类对象里面的父类对象Animal,因此能访问得到的也只是这个Animal对象里面的name属性，而这个Animal对象外面的furColor属性是访问不到的，虽然Dog对象确实有这个属性存在，但a就是看不到，a门缝里看Dog——把Dog看扁了，不知道Dog还有furColor这个属性存在，因此a访问不了furColor属性，因此从<span style="color:#FF0000">严格意义上来讲，a指向的只是这个Dog对象里面的Animal对象，也就是黄色箭头指向的那部分</span>，a就只看到了Dog里面这部分，而Dog外面的部分都看不到了。这就是父类引用指向子类对象，<span style="color:#FF0000">父类引用指向子类对象的时候，它看到的只是作为父类的那部分所拥有的属性和方法，至于作为子类的那部分它没有看到。</span><br> <br> 　　如果真的<span style="color:#FF0000">想访问Dog对象的furColor属性</span>，那就采用对象转型的办法，<span style="color:#FF0000">把父类对象的引用转型成子类对象的引用。Dog d1 = (Dog)a;这里采用的就是对象转型的办法</span>，把a强制转换成一只Dog对象的引用，然后将这个引用赋值给Dog型的引用变量d1，这样d1和a都是指向堆内存里面的Dog对象了，而且d1指向的就是这只Dog所有的部分了，通过这个d1就可以访问Dog对象里面所有的成员了。<br> </p> 
<span style=""></span> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/febc6af2d0d006090895653173f341e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows 性能监视器的基本指标说明（CPU,内存,硬盘参数）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7401b8232b95e1f76801131d7726965f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Arduino与L298N(红板) 驱动直流电机</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>