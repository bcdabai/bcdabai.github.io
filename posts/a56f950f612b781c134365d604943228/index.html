<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统 知识点总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统 知识点总结" />
<meta property="og:description" content="文章目录 第一章 概论第二章 进程管理第三章 内存管理第四章 文件管理第五章 I/O管理实验实验1实验2实验3操作其他 题目 第一章 概论 单处理中，进程之间叫并发不是并行用户通过命令接口（批处理和交互式）和系统调用来使用计算机缓存全部由os管分时time-sharing有批处理、分时和实时os中断使得io和cpu可以并行多道程序cpu利用率高，吞吐量大，io利用率高资源利用率不是实时os目标优先级加非抢占式调度，可以改善系统响应时间分时系统期待快速响应用户定义原语的方式是关闭中断，让其所有动作不可分割的完成之后再打开命令解释在用户态进行中断处理和子程序调用都会压栈来保护现场，中断一定会保存程序状态字寄存器（PSWR）关中断指令不能在用户态内部异常处理后，不一定能回到异常指针，可能跳过异常也称内中断外部中断时，os需要保存通用寄存器内容并发和共享是现代os基础 第二章 进程管理 调度是分配给资源。现有资源调度，后有进程切换进程通信，pv是低级操作，高级有： 共享存储消息传递（直接和间接）管道通信（半双工）。管道大小可以设置，管道在空或者满的时候，会读或写阻塞。只允许一边写入，一边读出 进程是为了多道程序，线程是为了提高并发性能。有就绪阻塞运行三种状态。就是轻量级进程在支持线程的os中，线程是独立调度的基本单位，进程是拥有资源的基本单位。有了线程，则调度的时候可能发生进程切换也可能不发生，所以平均开销变小了。设备分配是io系统，不新进程。P操作会导致阻塞态Cpu抢占，进程变为就绪态不能调度与切换：1）处理中断时，2）临界区，3）源自操作Preemptive周转时间是完成减去提交，带权周转是周转除以实际运行时间等待是周转减运行响应是提交到首次响应高响应比优先调度：响应比R=（等待&#43;要求服务时间）/要求服务时间。它综合考虑了等待时间和执行时间；满足短作业优先且不会饥饿为了提高利用率，io越长应该越先 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VXFqf2xp-1583500272226)(file:///C:/Users/Kfor/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)]
时间片用完，执行态变就绪态临界区也可以调度。比如打印机时间片轮转，不会饥饿硬件实现同步，可以中断屏蔽或者硬件指令。满足互斥但不有限等待 boolean TestAndSet(boolean *target) { boolean rv = *target; *target = true; return rv; } // boolean lock = false 对于第i个进程: do { while (TestAndSet(&amp;lock)) ; Critical Section lock = false; Remainder Section }while(1); 使用信号量完成前驱关系。只需要画出前驱图，然后每个分支设置一个信号量即可。Semaphore。注意，两个wait在一起，同步wait在互斥wait前管程。每次只能有一个进程进入管程。在x.wait()，x是条件变量，则其阻塞该进程并插入x的阻塞队列中Cs full = 0, empty = n, mutex = 1 // producer while (true) { // produce an item wait (empty); wait (mutex); // add the item to the buffer signal (mutex); signal (full); } // consumer while (true) { wait (full); wait (mutex); //remove an item from buffer signal (mutex); signal (empty); // consume the removed item } Read and write mutex = 1, wrt = 1 //readers readcount = 0 wait(mutex); readcount&#43;&#43;; if (readcount == 1) wait(rt); signal(mutex); //reading is performed wait(mutex); readcount--; if (readcount == 0) signal(wrt); signal(mutex)； //writers wait(wrt); //writing is performed signal(wrt); 哲学家 semaphore chopstick[5] = 1。 对于第i哲学家： do { wait(chopstick[i]); wait(chopstick[(i&#43;1) % 5]); eat; signal(chopstick[i]); signal(chopstick[(i&#43;1) % 5]); think; } while (1); 死锁。预防保守，是要破坏四个必要条件（互斥、不剥夺、hold and wait、循环等待），宁可资源闲置。避免是找安全序列。检测是通过剥夺等来检测并解除死锁避免：银行家算法 Banker’s Algorithm(Deadlock Avoidance) Resource-Request Algorithm 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a56f950f612b781c134365d604943228/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-06T21:17:54+08:00" />
<meta property="article:modified_time" content="2020-03-06T21:17:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统 知识点总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#__3" rel="nofollow">第一章 概论</a></li><li><a href="#__24" rel="nofollow">第二章 进程管理</a></li><li><a href="#__198" rel="nofollow">第三章 内存管理</a></li><li><a href="#__237" rel="nofollow">第四章 文件管理</a></li><li><a href="#_IO_267" rel="nofollow">第五章 I/O管理</a></li><li><a href="#_271" rel="nofollow">实验</a></li><li><ul><li><a href="#1_273" rel="nofollow">实验1</a></li><li><a href="#2_299" rel="nofollow">实验2</a></li><li><a href="#3_309" rel="nofollow">实验3</a></li><li><a href="#_319" rel="nofollow">操作</a></li><li><a href="#_347" rel="nofollow">其他</a></li></ul> 
  </li><li><a href="#_390" rel="nofollow">题目</a></li></ul> 
</div> 
<p></p> 
<h2><a id="__3"></a>第一章 概论</h2> 
<ol><li>单处理中，进程之间叫并发不是并行</li><li>用户通过命令接口（批处理和交互式）和系统调用来使用计算机</li><li>缓存全部由os管</li><li>分时time-sharing</li><li>有批处理、分时和实时os</li><li>中断使得io和cpu可以并行</li><li>多道程序cpu利用率高，吞吐量大，io利用率高</li><li>资源利用率不是实时os目标</li><li>优先级加非抢占式调度，可以改善系统响应时间</li><li>分时系统期待快速响应用户</li><li>定义原语的方式是关闭中断，让其所有动作不可分割的完成之后再打开</li><li>命令解释在用户态进行</li><li>中断处理和子程序调用都会压栈来保护现场，中断一定会保存程序状态字寄存器（PSWR）</li><li>关中断指令不能在用户态</li><li>内部异常处理后，不一定能回到异常指针，可能跳过</li><li>异常也称内中断</li><li>外部中断时，os需要保存通用寄存器内容</li><li>并发和共享是现代os基础</li></ol> 
<h2><a id="__24"></a>第二章 进程管理</h2> 
<ol><li>调度是分配给资源。现有资源调度，后有进程切换</li><li>进程通信，pv是低级操作，高级有： 
  <ol><li>共享存储</li><li>消息传递（直接和间接）</li><li>管道通信（半双工）。管道大小可以设置，管道在空或者满的时候，会读或写阻塞。只允许一边写入，一边读出</li></ol> </li><li>进程是为了多道程序，线程是为了提高并发性能。有就绪阻塞运行三种状态。就是轻量级进程</li><li>在支持线程的os中，线程是独立调度的基本单位，进程是拥有资源的基本单位。</li><li>有了线程，则调度的时候可能发生进程切换也可能不发生，所以平均开销变小了。</li><li>设备分配是io系统，不新进程。</li><li>P操作会导致阻塞态</li><li>Cpu抢占，进程变为就绪态</li><li>不能调度与切换：1）处理中断时，2）临界区，3）源自操作</li><li>Preemptive</li><li>周转时间是完成减去提交，带权周转是周转除以实际运行时间</li><li>等待是周转减运行</li><li>响应是提交到首次响应</li><li>高响应比优先调度：响应比R=（等待+要求服务时间）/要求服务时间。它综合考虑了等待时间和执行时间；满足短作业优先且不会饥饿</li><li>为了提高利用率，io越长应该越先</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VXFqf2xp-1583500272226)(file:///C:/Users/Kfor/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)]</p> 
<ol start="16"><li>时间片用完，执行态变就绪态</li><li>临界区也可以调度。比如打印机</li><li>时间片轮转，不会饥饿</li><li>硬件实现同步，可以中断屏蔽或者硬件指令。满足互斥但不有限等待</li></ol> 
<pre><code class="prism language-c">boolean <span class="token function">TestAndSet</span><span class="token punctuation">(</span>boolean <span class="token operator">*</span>target<span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span>
    boolean rv <span class="token operator">=</span> <span class="token operator">*</span>target<span class="token punctuation">;</span>
    <span class="token operator">*</span>target <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token keyword">return</span> rv<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">// boolean lock = false 对于第i个进程:</span>
<span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">TestAndSet</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
	Critical Section
	lock <span class="token operator">=</span> false<span class="token punctuation">;</span>
	Remainder Section
<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="20"><li>使用信号量完成前驱关系。只需要画出前驱图，然后每个分支设置一个信号量即可。Semaphore。注意，两个wait在一起，同步wait在互斥wait前</li><li>管程。每次只能有一个进程进入管程。在x.wait()，x是条件变量，则其阻塞该进程并插入x的阻塞队列中</li><li>Cs</li></ol> 
<pre><code class="prism language-c">full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> empty <span class="token operator">=</span> n<span class="token punctuation">,</span> mutex <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">// producer</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

  <span class="token comment">// produce an item</span>
  wait <span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
  wait <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// add the item to the buffer</span>
  signal <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  signal <span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">// consumer</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	wait <span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
	wait <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//remove an item from buffer</span>
	signal <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
	signal <span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// consume the removed item</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="23"><li>Read and write</li></ol> 
<pre><code class="prism language-c">mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> wrt <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">//readers</span>
readcount <span class="token operator">=</span> <span class="token number">0</span>
<span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
readcount<span class="token operator">++</span><span class="token punctuation">;</span> 
<span class="token keyword">if</span> <span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>      
<span class="token function">wait</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//reading is performed</span>

<span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
readcount<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token function">signal</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>；

<span class="token comment">//writers</span>
<span class="token function">wait</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//writing is performed</span>
<span class="token function">signal</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="24"><li>哲学家</li></ol> 
<pre><code class="prism language-c">semaphore chopstick<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>。

对于第i哲学家：

<span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	eat<span class="token punctuation">;</span>

	<span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	think<span class="token punctuation">;</span>

<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<ol start="25"><li>死锁。预防保守，是要破坏四个必要条件（互斥、不剥夺、hold and wait、循环等待），宁可资源闲置。避免是找安全序列。检测是通过剥夺等来检测并解除死锁</li><li>避免：银行家算法</li></ol> 
<pre><code>Banker’s Algorithm(Deadlock Avoidance)

Resource-Request Algorithm

1. If Requesti £ Needi go to step 2. Otherwise, raise error condition, since process has exceeded its maximum claim.

2. If Requesti £ Available, go to step 3.  Otherwise Pi must wait, since resources are not available.

3. Pretend to allocate requested resources to Pi by modifying the state as follows:

​       Available = Available - Requesti

​       Allocationi = Allocationi + Requesti

​       Needi = Needi – Requesti

If safe Þ the resources are allocated to Pi 

If unsafe Þ Pi must wait, and the old resource-allocation state is restored

Safety Algorithm

1.Let Work and Finish be vectors of length m and n, respectively. Initialize:
(a) Work = Available
(b) Finish [i] = false for i = 0, 1, …, n- 1.

2.Find an index i such that both:
(a)Finish[i] == false
(b)Requesti £ Work

If no such i exists, go to step 4. 

3.Work = Work + Allocationi
Finish[i] = true
go to step 2.

4.If Finish [i] == true for all i, then the system is in a safe state.
</code></pre> 
<ol start="27"><li>资源分配图，无环一定没有死锁</li><li>死锁避免不会闲置用户申请资源顺序</li></ol> 
<h2><a id="__198"></a>第三章 内存管理</h2> 
<ol><li> <p>在连接阶段得到逻辑地址</p> </li><li> <p>进程中的块称为页，内存中的称为页帧（frame）外存称为块。</p> </li><li> <p>分页没有外部碎片</p> </li><li> <p>地址分为页号加偏移，偏移12位为4K</p> </li><li> <p>页表用于页号到物理块号的转换</p> </li><li> <p>页表寄存器PTR，存放页表的始址和页表长度</p> </li><li> <p>物理地址E=b（A对L整除）*L+W（A对L取余）</p> </li><li> <p>页表项是用来找到页在内存中的位置。内存以字节为单位。如果也存在内存中，就需要两次访问，找页表和找地址。于是加快第一次，tlb快表加速</p> </li><li> <p>当然，这会导致页表非常大。每个进程都要有一个页表。所以要分级。是的顶级页表最多只有一个页面。</p> </li><li> <p>二级页表例子。4KB的页，4B一个页表项，则一个页能容纳1k个，占用地址10位。偏移12位，所以余下10位。格式为一级页号、二级页号、页内偏移。</p> </li><li> <p>多级页表可以减少页表所占的连续内存空间</p> </li><li> <p>分段，段号，段长，在主存的始址</p> </li><li> <p>可以段页式管理。注意，一个进程可能有多个页表，但只有一个段表</p> </li><li> <p>虚拟内存实际上建立了“内存-外存”量级储存器结构，实现高速缓存。即，页表不一定真实在内存中</p> </li><li> <p>请求调页。需要在原有的分页上，添加状态位、访问字段、修改位、外存地址</p> </li><li> <p>如果不在内存中，就缺页中断。阻塞。（调页时候在唤醒）。内部中断</p> </li><li> <p>如果不够调入，就要页面置换。有opt，fifo，lru，clock（也叫nru）等算法。只有fifo会随着物理块数增大而出现更多页故障（belady）。</p> </li><li> <p>Clock：有个使用位，首次装入为1，被访问到也为1，每当需要替换一页，就扫描缓冲区，找到为0的，并把1都置位0。</p> </li><li> <p>改进clock：添加一个修改位。U和m组合，淘汰顺序为00,01,10,11</p> </li><li> <p>不需要吧所有也都读入主存，所以分配给每个进程几个frame，就是进程驻留集。通常有固定分配局部、可变分配全局、可变分配局部。</p> </li><li> <p>抖动是因为物理页帧少。撤销进程。</p> </li><li> <p>增大tlb可以加快虚实地址转换</p> </li><li> <p>Lru可以从后往前数，没有用的。</p> </li></ol> 
<h2><a id="__237"></a>第四章 文件管理</h2> 
<ol><li> <p>打开文件时，要用计数器记录多少进程打开该文件。为0才从打开文件表中删除，最后释放fcb。</p> </li><li> <p>每个打开文件都要维护：文件指针，文件打开计数，文件磁盘位置，访问权限</p> </li><li> <p>目录结构：单，两（master fiile dir+user file directory），树，无环图</p> </li><li> <p>目录实现靠线性链表或者hash表</p> </li><li> <p>文件分配，连续、链接、索引</p> </li><li> <p>磁盘存取时间</p> </li><li> <p>磁盘管理</p> </li></ol> 
<h2><a id="_IO_267"></a>第五章 I/O管理</h2> 
<h2><a id="_271"></a>实验</h2> 
<h3><a id="1_273"></a>实验1</h3> 
<ol><li>tar xvf linux-4.6.tar解压</li><li>xz -d patch-4.6.xz | patch -p1补丁</li><li>ln -s /usr/src/linux-4.6/ l</li><li>make mrproper清.o</li><li>make bzImage -jN编译内核</li><li>make modules -jN编译内核模块</li><li>make modules_install安装模块</li><li>make install安装内核</li><li>mkinitramfs 4.6.0 -o /boot/initrd.img-4.6.0并update-grub2修改grub。内核bzImage，initrd.img等都放到/boot</li></ol> 
<p>QA</p> 
<ol><li>.config文件的作用为：内核编译时，主makefile文件调用它来进行内核编译配置。Make menuconfig时，也会自动更新这个值。</li><li>Makefile和Kconfig文件的作用：makefile用于集成编译；Kconfig为分布在各目录下的文件，构成了一个分布式的内核配置数据库。每个Kconfig分别描述了所属目录源文件相关的内核配置菜单。在内核配置make menuconfig时，从Kconfig中读出配置菜单，用户配置完后保存到.config(在顶层目录下生成)</li><li>System.map-4.6.0和initrd.img-4.6.0的作用：system.map是一个符号表，因为内核直接使用地址来引用变量，所以需要一个变量和地址的映射表。Initrd.img是内核镜像文件，保存了驱动模块等信息。</li><li>有pthread_create(&amp;thread, &amp;attr, &amp;dataArray); pthread_join(thread,NULL); pthread_mutex_lock(mutex); pthread_mutex_unlock(mutex);pthread_mutex_t mutex; pthread_cond_t cond;pthread_cond_signal(cond); pthread_cond_wait(cond, mutex);</li><li>gcc -o out in.c -lpthread</li><li>用for(p=init_task; (p=p-&gt;next_task!=&amp;init_tak;)或者list_for_each(pos,&amp;(initTask-&gt;tasks)来遍历进程；然后其中的p有comm,pid,real_parent, nr_dirtied，state等，state的TASK_RUNNING来判断状态</li><li>要加module_init()来初始化</li><li>Make之后insmod .ko dmesg即可</li><li>Pwd显示当前工作目录</li></ol> 
<h3><a id="2_299"></a>实验2</h3> 
<ol><li>Syscall_64.tbl里面修改系统调用号</li><li>在sched.h下，有task_struct进程pcb。有state，stack，usage，flags，ptrace</li><li>在kernel/sys.c中添加我的系统调用</li><li>之后用户态syscall(号)，再dmesg</li><li>修改内核法，内核模块法（拦截系统调用，修改其服务）</li></ol> 
<h3><a id="3_309"></a>实验3</h3> 
<ol><li>Linux/fs/ext2</li><li>全局匹配替换 :%s/ext2/myext2/g</li><li>Cat /proc/filesystems | grep myext2</li><li>操作为make; insmod .ko; dd if=/dev/zero of=myfs bs=1M count=1; /sbin/mkfs.ext2 myfs; mount -t myext2 -o loop ./myfs /mnt; mount; umount /mnt; rmmod myext2</li><li>其namei.c下有各个功能的实现；read和write操作在file.c下</li></ol> 
<h3><a id="_319"></a>操作</h3> 
<ol><li>Chmod 777 file</li></ol> 
<p>文件保护和访问权限:</p> 
<p>mode of access: read, write, execute</p> 
<p>three classes of users ＲＷＸ</p> 
<p>a) owner access 7 1 1 1<br> b) group access 6 1 1 0</p> 
<p>c) public access 1 0 0 1</p> 
<ol start="2"><li>Chown user file</li><li>Tar -c是打包-x是拆包，-f后接文件名，-v显示全过程</li><li>Grep “root” /etc/password</li><li>Find . -name “*.h” -print</li><li>Ps -a 显示所有进程</li><li>Top用来实时显示process的动态</li><li>Cat连接文件并打印到标准输出上cat /dev/null &gt; /etc/test.txt</li><li>Touch file创建文件</li><li>Echo 内容&gt;文件</li><li>Echo 内容&gt;&gt;文件（追加）</li></ol> 
<h3><a id="_347"></a>其他</h3> 
<ol><li>在创建Linux分区时，至少要创建的两个分区是: Swap/root</li><li>哪一个只是在内核运行时存在的 : proc</li><li>Linux的内核受严格保护，与进程的用户态代码几乎隔绝。若想从用户态进入内核态，可以通过 : int 0x80</li><li>第一个扇区是mbr，读取前512字节。最后两个是55aa</li><li>缺页寄存器CR2</li><li>系统调用号EAX</li><li>ESP（Extended Stack Pointer）为扩展栈指针寄存器，是指针寄存器的一种，用于存放函数栈顶指针。与之对应的是EBP（Extended Base Pointer），扩展基址指针寄存器，也被称为帧指针寄存器，用于存放函数栈底指针。</li><li>Ds数据段寄存器</li><li>Cs代码段寄存器</li><li>图<br> <img src="https://images2.imgbox.com/43/d4/RyMmaoBY_o.png" alt="在这里插入图片描述"></li><li>Rt是实时的意思rt_priority</li><li>在do_fork()函数中首先创建一个task_struct结构体指针，再对传递给do_fork的flag参数进行处理和检查，看当前进程是否设置了跟踪标记ptrace。然后进入了copy_process函数，实现将父进程的寄存器以及所有进程执行环境的相关部分复制给子进程。在copy_process()函数中：首先对一些标志进行合法性检查，检查完之后调用dup_task_struct函数来为新进程创建一个内核栈、thread_info和task_struct，这里完全copy父进程的内容。</li><li>在32位Linux系统中，每个进程都有一个4G的虚拟地址空间，其中3G为进程独有的用户空间，1G为共享的内核空间。</li><li>0到16M是dma用的，16M到896是内核直接使用的，之后是不可以的</li><li>Inode索引节点，包含文件的元信息。Size,uid,gid(group id),access,blocks…</li><li>Vfs的一个目录项为dentry</li><li>Task_struct (comm是文件名</li></ol> 
<p>VFS并不是一种实际的文件系统。ext2/ext4等物理文件系统是存在于外存空间的，而VFS仅存在于内存。<br> <img src="https://images2.imgbox.com/5a/cb/66REfX7D_o.png" alt="在这里插入图片描述"><br> 通用文件模型由四种数据对象组成：</p> 
<p>超级块对象 superblock :存储已安装文件系统的信息，通常对应磁盘文件系统的文件系统超级块或控制块。 是文件系统中描述整体组织和结构的信息体。Linux中对于每种已安装的文件系统，在内存中都有与其对应的超级块</p> 
<p>索引节点对象 inode object ：存储某个文件的信息。通常对应磁盘文件系统的文件控制块。物理文件系统的inode在外存中并且是长期存在的， VFS的inode 对象在内存中，它仅在需要时才建立，不再需要时撤消(存在于&lt;include/linux/fs.h&gt;中)</p> 
<p>目录项对象dentry object ：dentry对象主要是描述一个目录项，是路径的组成部分。</p> 
<p>文件对象 file object：存储一个打开文件和一个进程的关联信息。只要文件一直打开，这个对象就一直存在于内存。</p> 
<p>进程文件管理</p> 
<p>fs_struct结构记录着进程所在文件系统根目录和当前目录，</p> 
<p>files_struct结构包含着进程的打开文件表。</p> 
<h2><a id="_390"></a>题目</h2> 
<ol><li> <p>注意缺页时候的块变化问题</p> </li><li> <p>The sequential file is good for sequential storage devices, however not fit for disks.是错的</p> </li><li> <p>For the same file, different physical organization structures are OK to be defined for different storage media with different file names.正确</p> </li><li> <p>Threads that belong to the same process share one set of registers and the same stack错误。堆是共享的栈和寄存器都是独享的</p> </li><li> <p>The cache technology is to solve the speed mismatch between CPU and I/O devices, but is not dedicated for that</p> </li><li> <p>Consider a file system on a disk that has both logical and physical block size of 512 bytes. Assume that the information about each file is already in memory. For each of the three allocation strategies (contiguous, linked, indexed), answer these questions:</p> </li></ol> 
<p>(1). How is the logical-to-physical address mapping accomplished in this system? (For the indexed allocation, assume that a file is always less than 512 blocks long.)</p> 
<p>(2). If we are currently at logical block 10 (the last block accessed was 20) and want to access logical block 5, how many physical blocks must be read from the disk?</p> 
<ol start="7"><li>If a file is accessed in direct access and the file length is not fixed, then it is suitable to use indexed file structure.</li><li>即Simultaneous Peripheral Operations On-Line的缩写，它是关于慢速字符设备如何与计算机主机交换信息一种技术，通常称为“假脱机技术”</li><li>The main purpose to introduce buffer technology is to improve the I/O efficiency.是错的</li><li>If a file system use two-level index allocation method(block size is 2KB, index address of each block occupies 4 bytes), what is the maximum size of a file which the file system can manage? 512MB</li><li>An I/O channel is a special processor</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d555e91f05a2cdc0170acd08d80dab6a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vmware虚拟机搭建开发环境经验总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae17938655413111a0bef2d902d8b4a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Game101课程笔记_lecture07_着色1（光照与基本着色模型）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>