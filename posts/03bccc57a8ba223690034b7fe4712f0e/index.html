<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>5.Mybatis 缓存详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="5.Mybatis 缓存详解" />
<meta property="og:description" content="5.1 一级缓存 一级缓存(也叫本地缓存)，默认会开启，并且不能控制。想要关闭一级缓存可以在select标签上配置flushCache=“true”；一级缓存存在于 SqlSession 的生命周期中，在同一个 SqlSession 中查询时， MyBatis 会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个 Map对象中。如果同一个 SqlSession 中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当 Map 缓存对象中己经存在该键值时，则会返回缓存中的对象;任何的 **INSERT 、UPDATE 、 DELETE 操作都会清空一级缓存；
一级缓存的执行过程：
每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。具体实现类的类关系图如下图所示。
5.3.1 一级缓存的测试 下面举两个例子来说明一级缓存
案例一： 在同一个SqlSession 查询两次id = 1的客户
测试代码如下：
@Test public void selectUserById(){ SqlSession sqlSession = sqlSessionFactory.openSession(); try{ UserMapper mapper = sqlSession.getMapper(UserMapper.class); // 查询id = 1 的用户 UserInfo userInfo = mapper.selectUserById(1L); System.out.println(&#34;userInfo==&#34;&#43;userInfo); // 查询id = 1 的用户 UserInfo userInfo2 = mapper.selectUserById(1L); System.out.println(&#34;userInfo2==&#34;&#43;userInfo); }finally{ sqlSession.close(); } } 下面是执行的日志:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/03bccc57a8ba223690034b7fe4712f0e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-12T23:09:07+08:00" />
<meta property="article:modified_time" content="2022-09-12T23:09:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">5.Mybatis 缓存详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="51__0"></a>5.1 一级缓存</h3> 
<p>一级缓存(也叫本地缓存)，默认会开启，并且不能控制。想要关闭一级缓存可以在select标签上配置<strong>flushCache=“true”</strong>；一级缓存存在于 <strong>SqlSession</strong> 的生命周期中，在同一个 SqlSession 中查询时， MyBatis 会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个 Map对象中。如果同一个 SqlSession 中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当 Map 缓存对象中己经存在该键值时，则会返回缓存中的对象;任何的 **INSERT 、UPDATE 、 <strong>DELETE</strong> 操作都会清空一级缓存；</p> 
<p>一级缓存的执行过程：</p> 
<p><img src="https://images2.imgbox.com/e0/04/zuMzucnr_o.png" alt="在这里插入图片描述"></p> 
<p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成<code>MappedStatement</code>，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入<code>Local Cache</code>，最后返回结果给用户。具体实现类的类关系图如下图所示。</p> 
<p><img src="https://images2.imgbox.com/45/b9/qgDoEenP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="531__15"></a>5.3.1 一级缓存的测试</h4> 
<p>下面举两个例子来说明一级缓存</p> 
<p><strong>案例一： 在同一个SqlSession 查询两次id = 1的客户</strong><br> <img src="https://images2.imgbox.com/1d/2f/dxJNdagd_o.png" alt="在这里插入图片描述"></p> 
<p>测试代码如下：</p> 
<pre><code>@Test
    public void selectUserById(){
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try{
            UserMapper mapper = sqlSession.getMapper(UserMapper.class);
            // 查询id = 1 的用户
            UserInfo userInfo = mapper.selectUserById(1L);

            System.out.println("userInfo=="+userInfo);
            // 查询id = 1 的用户
            UserInfo userInfo2 = mapper.selectUserById(1L);
            System.out.println("userInfo2=="+userInfo);
        }finally{
            sqlSession.close();
        }
    }
</code></pre> 
<p>下面是执行的日志:</p> 
<pre><code>[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@57f23557]
[com.xa02.mapper.UserMapper.selectUserById]-==&gt;  Preparing: SELECT id,user_name,sex,birthday,address FROM t_user where id = ? 
[com.xa02.mapper.UserMapper.selectUserById]-==&gt; Parameters: 1(Long)
[com.xa02.mapper.UserMapper.selectUserById]-&lt;==      Total: 1

</code></pre> 
<p>上面只执行了一次sql查询数据库，第二次查询走的是一级缓存。</p> 
<p><strong>案例二： 在同一个SqlSession 查询两次id = 1的客户的中间对客户进行更新</strong></p> 
<p><img src="https://images2.imgbox.com/82/45/Aw8qSdbh_o.png" alt="在这里插入图片描述"></p> 
<p>代码如下：</p> 
<pre><code>  @Test
    public void selectUserById(){
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try{
            UserMapper mapper = sqlSession.getMapper(UserMapper.class);
            // 查询id = 1 的用户
            UserInfo userInfo = mapper.selectUserById(1L);

            System.out.println("userInfo=="+userInfo);

            //更新id = 1的用户
            UserInfo ui = new UserInfo();
            ui.setId(1L);
            ui.setUserName("wanghan");
            mapper.updateUser(ui);
            // 查询id = 1 的用户
            UserInfo userInfo2 = mapper.selectUserById(1L);
            System.out.println("userInfo2=="+userInfo);
        }finally{
            sqlSession.close();
        }
    }

</code></pre> 
<p>测试日志：</p> 
<pre><code>[com.xa02.mapper.UserMapper.selectUserById]-==&gt;  Preparing: SELECT id,user_name,sex,birthday,address FROM t_user where id = ? 
[com.xa02.mapper.UserMapper.selectUserById]-==&gt; Parameters: 1(Long)
[com.xa02.mapper.UserMapper.selectUserById]-&lt;==      Total: 1
userInfo==UserInfo{id=1, userName='zhangsan', sex='0', birthday=Tue Nov 17 15:07:08 CST 2020, address='上海市', orderInfoList=null}
[com.xa02.mapper.UserMapper.updateUser]-==&gt;  Preparing: update t_user SET user_name = ? where id = ? 
[com.xa02.mapper.UserMapper.updateUser]-==&gt; Parameters: wanghan(String), 1(Long)
[com.xa02.mapper.UserMapper.updateUser]-&lt;==    Updates: 1
[com.xa02.mapper.UserMapper.selectUserById]-==&gt;  Preparing: SELECT id,user_name,sex,birthday,address FROM t_user where id = ? 
[com.xa02.mapper.UserMapper.selectUserById]-==&gt; Parameters: 1(Long)
[com.xa02.mapper.UserMapper.selectUserById]-&lt;==      Total: 1
userInfo2==UserInfo{id=1, userName='zhangsan', sex='0', birthday=Tue Nov 17 15:07:08 CST 2020, address='上海市', orderInfoList=null}
</code></pre> 
<p><strong>说明：</strong></p> 
<ol><li> <p>第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息，将查询到的用户信息存储到一级缓存中。</p> </li><li> <p>如果中间sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</p> </li></ol> 
<p>3.第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。</p> 
<p><strong>注意:</strong></p> 
<p>如果不想让selectUserById 方法使用以及缓存，可以对该方法做如下修改：</p> 
<pre><code>    &lt;select id="selectUserById"  parameterType="long" resultMap="userResultMap" flushCache="true"&gt;
        SELECT
           id,user_name,sex,birthday,address
        FROM
            t_user  where id = #{id}
    &lt;/select&gt;
</code></pre> 
<p>在原来的方法上加上 flushCache = true,会在查询数据前清空一级缓存，因此该方法每次都会从数据库查询，</p> 
<p><strong>一级缓存的使用条件：</strong></p> 
<ol><li> <p>必须是相同的SQL和参数</p> </li><li> <p>必须是相同的会话</p> </li><li> <p>必须是相同的namespace 即同一个mapper</p> </li><li> <p>必须是相同的statement 即同一个mapper 接口中的同一个方法</p> </li><li> <p>查询语句中间没有执行session.clearCache() 方法</p> </li><li> <p>查询语句中间没有执行 insert update delete 方法（无论变动记录是否与 缓存数据有无关系）</p> </li></ol> 
<h4><a id="532__155"></a>5.3.2 一级缓存源码分析</h4> 
<p>一级缓存的逻辑最终调用BaseExecutor执行器里面。当会话接收到一个查询请求时，会交给执行器的query方法执行，通过CacheKey的hashCode+checkNum + statementId + sql+ 参数等参数组成一个缓存key, 基于这个key去PerpetualCache 中查找对应的缓存值，如果有主直接返回。没有就会查询数据库，然后在填充缓存。</p> 
<p>调试方法的Mapper.xml 如下：</p> 
<pre><code>&lt;select id="selectUserList"  parameterType="UserInfo" resultMap="userResultMap" flushCache="true"&gt;
        SELECT
           id,user_name,sex,birthday,address
        FROM
            t_user
        &lt;where&gt;
            &lt;if test="userName!=null and userName !=''"&gt;
               and  user_name = #{userName}
            &lt;/if&gt;
            &lt;if test="sex!=null and sex !=''"&gt;
                and  sex = #{sex}
            &lt;/if&gt;
            &lt;if test="birthday!=null and birthday !=''"&gt;
                and birthday = #{birthday}
            &lt;/if&gt;
            &lt;if test="address!=null and address !=''"&gt;
                and address = #{address}
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre> 
<p>&gt;mapper.mapper.selectList(UserInfo)</p> 
<p>&gt;org.apache.ibatis.session.defaults.DefaultSqlSession#selectList()</p> 
<pre><code>//statement: com.xa02.mapper.UserMapper.selectUserById
// parameter : 1
  @Override
  public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) {
    return this.selectList(statement, parameter, RowBounds.DEFAULT);
  }

  @Override
  public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      MappedStatement ms = configuration.getMappedStatement(statement);
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException("Error querying database.  Cause: " + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
</code></pre> 
<p>此时的执行器 是CacheExecutor,用的是装饰器模式</p> 
<p><img src="https://images2.imgbox.com/98/50/HBYK6YRC_o.png" alt="在这里插入图片描述"></p> 
<p>即 executor = CacheingExecutor(SimpleExecutor)</p> 
<p><strong>&gt;org.apache.ibatis.executor.CachingExecutor#query()</strong></p> 
<pre><code>  @Override
  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    BoundSql boundSql = ms.getBoundSql(parameterObject);
    // 创建缓存的key
    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }
  
</code></pre> 
<p>此方法由两个任务</p> 
<p>1.创建cachekey</p> 
<p>2.从数据库中查询数据，并存储到缓存中</p> 
<blockquote> 
 <p>创建cachekey</p> 
</blockquote> 
<p>CacheKey 类中的属性：</p> 
<pre><code>public class CacheKey implements Cloneable, Serializable {
  public static final CacheKey NULL_CACHE_KEY = new NullCacheKey();

  private static final int DEFAULT_MULTIPLYER = 37;
  private static final int DEFAULT_HASHCODE = 17;

  private final int multiplier;
  private int hashcode;//CacheKey 的hashCode,初始值是17
  private long checksum;//校验和
  private int count;
  // 8/21/2017 - Sonarlint flags this as needing to be marked transient.  While true if content is not serializable, this is not always true and thus should not be marked transient.
  private List&lt;Object&gt; updateList;// 由该集合中的所有对象共同决定两个cacheKey是否相同
</code></pre> 
<pre><code class="prism language-java">  <span class="token comment">// 此时的 delegate = SimpleExecutor</span>
  <span class="token annotation punctuation">@Override</span>  
  <span class="token keyword">public</span> <span class="token class-name">CacheKey</span> <span class="token function">createCacheKey</span><span class="token punctuation">(</span><span class="token class-name">MappedStatement</span> ms<span class="token punctuation">,</span> <span class="token class-name">Object</span> parameterObject<span class="token punctuation">,</span> <span class="token class-name">RowBounds</span> rowBounds<span class="token punctuation">,</span> <span class="token class-name">BoundSql</span> boundSql<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> delegate<span class="token punctuation">.</span><span class="token function">createCacheKey</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameterObject<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
 
  # <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>executor<span class="token punctuation">.</span></span>SimpleExecutor</span>#<span class="token function">createCacheKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
 
  <span class="token keyword">public</span> <span class="token class-name">CacheKey</span> <span class="token function">createCacheKey</span><span class="token punctuation">(</span><span class="token class-name">MappedStatement</span> ms<span class="token punctuation">,</span> <span class="token class-name">Object</span> parameterObject<span class="token punctuation">,</span> <span class="token class-name">RowBounds</span> rowBounds<span class="token punctuation">,</span> <span class="token class-name">BoundSql</span> boundSql<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutorException</span><span class="token punctuation">(</span><span class="token string">"Executor was closed."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">CacheKey</span> cacheKey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CacheKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//  statementId其实就是select语句标签中的的id，如果两条select的id不同，那么必定不会命中。</span>
     <span class="token comment">// statementId：com.xa02.mapper.UserMapper.selectUserList</span>
    cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token comment">// 这里的分页指的是mybatis自带的分页功能，它是查询出来数据库的所有数据到本地进行的一个物理分页。而不是从数据库获取分页之后的结果。不推荐使用。</span>
    cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>rowBounds<span class="token punctuation">.</span><span class="token function">getOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//默认为0</span>
    cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>rowBounds<span class="token punctuation">.</span><span class="token function">getLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 默认为 Integer.MAX_VALUE 即：-1355182933</span>
    cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>boundSql<span class="token punctuation">.</span><span class="token function">getSql</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// SQL 语句 ，其中可能包含 ? 占位符</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ParameterMapping</span><span class="token punctuation">&gt;</span></span> parameterMappings <span class="token operator">=</span> boundSql<span class="token punctuation">.</span><span class="token function">getParameterMappings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">TypeHandlerRegistry</span> typeHandlerRegistry <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTypeHandlerRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// mimic DefaultParameterHandler logic</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ParameterMapping</span> parameterMapping <span class="token operator">:</span> parameterMappings<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>parameterMapping<span class="token punctuation">.</span><span class="token function">getMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">ParameterMode</span><span class="token punctuation">.</span>OUT<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Object</span> value<span class="token punctuation">;</span>
        <span class="token class-name">String</span> propertyName <span class="token operator">=</span> parameterMapping<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>boundSql<span class="token punctuation">.</span><span class="token function">hasAdditionalParameter</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          value <span class="token operator">=</span> boundSql<span class="token punctuation">.</span><span class="token function">getAdditionalParameter</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>parameterObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>typeHandlerRegistry<span class="token punctuation">.</span><span class="token function">hasTypeHandler</span><span class="token punctuation">(</span>parameterObject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          value <span class="token operator">=</span> parameterObject<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
          <span class="token class-name">MetaObject</span> metaObject <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">newMetaObject</span><span class="token punctuation">(</span>parameterObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
          value <span class="token operator">=</span> metaObject<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 传入sql 每个参数的值</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>configuration<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// issue #176</span>
      cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>configuration<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取Environmentid ,在mybatis全局文件中有配置</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//-529818025:1137442865:com.xa02.mapper.UserMapper.selectUserById:0:2147483647:SELECT</span>
           id<span class="token punctuation">,</span>user_name<span class="token punctuation">,</span>sex<span class="token punctuation">,</span>birthday<span class="token punctuation">,</span>address
        FROM
            t_user  where id <span class="token operator">=</span> <span class="token operator">?</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span>mysql_jdbc2
    <span class="token keyword">return</span> cacheKey<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
</code></pre> 
<p>此时的CacheKey<br> <img src="https://images2.imgbox.com/e3/4b/SD6i5txB_o.png" alt="在这里插入图片描述"></p> 
<pre><code>-1355182933:867372649:com.xa02.mapper.UserMapper.selectUserList:0:2147483647:SELECT
           id,user_name,sex,birthday,address
        FROM
            t_user
         WHERE   user_name = ?,
            
            
                and  sex = ?,
            
            
            
                and address = ?,:lisi:0:beijing:mysql_jdbc2
</code></pre> 
<p>上面的冒号是分隔符。</p> 
<p>整个key的组成如下：</p> 
<p>Cache key HashCode：Cache key 的checksum 校验和:statementid:offset:limit:sql语句：每个参数：environmentId</p> 
<blockquote> 
 <p>查询数据，并存储到缓存中</p> 
</blockquote> 
<pre><code>@Override
  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
      throws SQLException {
    Cache cache = ms.getCache();
    // 判断是否开启了二级缓存，如果开启了，会执行 if 里的代码
    if (cache != null) {
      flushCacheIfRequired(ms);
      if (ms.isUseCache() &amp;&amp; resultHandler == null) {
        ensureNoOutParams(ms, boundSql);
        @SuppressWarnings("unchecked")
        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);
        if (list == null) {
        // delegate = SimpleExcutor 去数据库中查询数据
          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
          // 查询完成后放到缓存中
          tcm.putObject(cache, key, list); // issue #578 and #116
        }
        return list;
      }
    }
    // 调用 BaseExecutor 下的query方法
    return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }
</code></pre> 
<p>&gt;org.apache.ibatis.BaseExecutor#query()</p> 
<pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity("executing a query").object(ms.getId());
    if (closed) {
      throw new ExecutorException("Executor was closed.");
    }
    // 
    // isFlushCacheRequired 是否刷新配置，清除hashMap的缓存
    // 刷新缓存的时候需要检查有没有正在查询的操作
    // queryStack 是全局变量，在高并发的时候会出问题
    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&lt;E&gt; list;
    try {
    // 为什么需要做 ++，为了 安全。
      queryStack++;
      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;
      if (list != null) {
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      // issue #601
      deferredLoads.clear();
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        // issue #482
        clearLocalCache();
      }
    }
    return list;
  }
</code></pre> 
<p>&gt;org.apache.ibatis.executor#queryFromDatabase</p> 
<pre><code>private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&lt;E&gt; list;
    // localCache = PerpetualCache
    // 1. 把key存入缓存，value放一个占位符
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
    //数据库查询数据 2. 与数据库交互
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
    //3. 如果第2步出了什么异常，把第1步存入的key删除
      localCache.removeObject(key);
    }
    //4.把结果放到本地缓存中 
    localCache.putObject(key, list);
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }
</code></pre> 
<p>&gt;org.apache.ibatis.cache.impl.PerpetualCache#putObject</p> 
<pre><code>public class PerpetualCache implements Cache {

  private final String id;

  private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();

  public PerpetualCache(String id) {
    this.id = id;
  }

  @Override
  public String getId() {
    return id;
  }

  @Override
  public int getSize() {
    return cache.size();
  }

  @Override
  public void putObject(Object key, Object value) {
    cache.put(key, value);
  }

  @Override
  public Object getObject(Object key) {
    return cache.get(key);
  }

  @Override
  public Object removeObject(Object key) {
    return cache.remove(key);
  }

  @Override
  public void clear() {
    cache.clear();
  }

  @Override
  public ReadWriteLock getReadWriteLock() {
    return null;
  }

  @Override
  public boolean equals(Object o) {
    if (getId() == null) {
      throw new CacheException("Cache instances require an ID.");
    }
    if (this == o) {
      return true;
    }
    if (!(o instanceof Cache)) {
      return false;
    }

    Cache otherCache = (Cache) o;
    return getId().equals(otherCache.getId());
  }

  @Override
  public int hashCode() {
    if (getId() == null) {
      throw new CacheException("Cache instances require an ID.");
    }
    return getId().hashCode();
  }

}

</code></pre> 
<p><img src="https://images2.imgbox.com/7b/1a/aNJR2oVF_o.png" alt="在这里插入图片描述"></p> 
<p>通过上图得知，最终的缓存存储在一个HashMap中。</p> 
<p><strong>触发清空缓存</strong></p> 
<ol><li>手动调用 clearCache</li><li>执行提交回滚</li><li>执行 update</li><li>配置 flushCache=true</li><li>缓存作用域为 Statement</li></ol> 
<p>下面我们看 flushCache=true的参数</p> 
<ol><li>在执行 BaseExecutor # query 方法时，会判断 flushCache有没有设置，如果设置，会清空 本地缓存。</li></ol> 
<pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
  ......
    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    ......
    return list;
  }
</code></pre> 
<ol start="2"><li> <p>当执行update方法时，直接调用了 clearLocalCache() 方法</p> <p>同时 insert 和 update 方法也调用了 update方法。</p> </li></ol> 
<pre><code> @Override
  public int insert(String statement, Object parameter) {
    return update(statement, parameter);
  }
    @Override
  public int delete(String statement) {
    return update(statement, null);
  }
</code></pre> 
<p>BaseExecutor#update</p> 
<pre><code>  @Override
  public int update(MappedStatement ms, Object parameter) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity("executing an update").object(ms.getId());
    if (closed) {
      throw new ExecutorException("Executor was closed.");
    }
    clearLocalCache();
    return doUpdate(ms, parameter);
  }
</code></pre> 
<blockquote> 
 <p>注意：clearLocalCache 不是清空某条具体数据，而清当前会话下所有一级缓存数据。</p> 
</blockquote> 
<p><strong>一级缓存存在的问题</strong></p> 
<p>一级缓存存在脏数据，因为无法感知其他sqlSession修改其数据。</p> 
<p>比如SqlSessionA 执行 selectUserById(1) 两次，按照一级缓存的规则，第二次查询selectUserById() 不会查询数据库。假如在 sqlSessionA 两次查询之间</p> 
<p>使用SqlSessionB 执行了 对用户ID=1的数据，此时 第二次执行selectUserById(1) 时，查到的就是脏数据。测试代码如下：</p> 
<pre><code>  @Test
    public void selectUserById(){
        SqlSession sqlSessionA = sqlSessionFactory.openSession();
        SqlSession sqlSessionB = sqlSessionFactory.openSession();
        try{
            UserMapper mapperA = sqlSessionA.getMapper(UserMapper.class);
            UserMapper mapperB = sqlSessionB.getMapper(UserMapper.class);

            UserInfo userInfo = new UserInfo();
            userInfo.setId(1L);
            List&lt;UserInfo&gt; userInfoList = mapperA.selectUserList(userInfo);
            System.out.println("第一次查询......"+userInfoList);

            UserInfo updateUserInfo = new UserInfo();
            updateUserInfo.setId(1L);
            updateUserInfo.setUserName("lisi");
            mapperB.updateUser(updateUserInfo);
            sqlSessionB.commit();

            Thread.sleep(20000);
            List&lt;UserInfo&gt; userInfoList2 =mapperA.selectUserList(userInfo);
            System.out.println("第二次查询......"+userInfoList2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally{
            sqlSessionA.close();
            sqlSessionB.close();
        }
    }
</code></pre> 
<p>日志如下：</p> 
<pre><code>[com.xa02.mapper.UserMapper.selectUserList]-==&gt;  Preparing: SELECT id,user_name,sex,birthday,address FROM t_user WHERE id = ? 
[com.xa02.mapper.UserMapper.selectUserList]-==&gt; Parameters: 1(Long)
[com.xa02.mapper.UserMapper.selectUserList]-&lt;==      Total: 1
第一次查询结果......[UserInfo{id=1, userName='zhangsan', sex='0', birthday=Tue Nov 17 15:07:08 CST 2020, address='上海市', orderInfoList=null}]
[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Opening JDBC Connection
[org.apache.ibatis.datasource.pooled.PooledDataSource]-Created connection 341853399.
[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@146044d7]
[com.xa02.mapper.UserMapper.updateUser]-==&gt;  Preparing: update t_user SET user_name = ? where id = ? 
[com.xa02.mapper.UserMapper.updateUser]-==&gt; Parameters: lisi(String), 1(Long)
[com.xa02.mapper.UserMapper.updateUser]-&lt;==    Updates: 1
[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@146044d7]
第二次查询结果.....[UserInfo{id=1, userName='zhangsan', sex='0', birthday=Tue Nov 17 15:07:08 CST 2020, address='上海市', orderInfoList=null}]
</code></pre> 
<p>从日志可以看到，在使用sqlSessionA 查询一次后，用sqlSessionB对id=1的用户名更新为lisi,但是第二次用sqlSessionA查询时，没有打印sql,即从缓存中获取的，取到的是修改前的记录，所以存在脏数据。</p> 
<p><img src="https://images2.imgbox.com/e7/7e/KBiKcbRr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="52__647"></a>5.2 二级缓存</h3> 
<p>一级缓存的共享范围是SqlSession内部，如果多个SqlSesison之间需要共享呢？这时需要 用到二级缓存，二级缓存存在于SqlSessionFactory的生命周期；缓存以namespace为单位，不同的namespace下的操作互不影响。<br> <img src="https://images2.imgbox.com/1d/90/rDdUGcSf_o.png" alt="在这里插入图片描述"></p> 
<p>当开启缓存后，数据的查询执行流程是 二级缓存–&gt; 一级缓存 --&gt; 数据库。</p> 
<h4><a id="521__656"></a>5.2.1 二级缓存的配置</h4> 
<p>Mybatis 对二级缓存的粒度支持到每一个查询语句，在Mapper 的配置中，为 每个Mapper分配了一个Cache对象，这并不表示我们在mapper定义的查询语句</p> 
<p>语句都会存放到缓存中，<strong>必须指定Mapper中的某条语句是否支持缓存</strong>。</p> 
<p>在 节点中配置useCache=“true”，Mapper才会对此Select的查询支持缓存特性(默认useCache为true)，否则，不会对此Select查询经过Cache缓存。</p> 
<p>要使用二级缓存，需要完成以下的配置。</p> 
<p>1.在myatis全局配置文件中开启二级缓存</p> 
<pre><code>&lt;!-- 开启二级缓存总开关 --&gt;
&lt;settings&gt;
	&lt;setting name="cacheEnabled" value="true"/&gt;
&lt;/settings&gt;
</code></pre> 
<p>2.在UserMapper映射文件中，需要配置 cache 或者 caceh-ref</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.xa02.mapper.UserMapper"&gt;
&lt;!-- 开启本mapper下的namespace的二级缓存，默认使用的是mybatis提供的PerpetualCache --&gt;
    &lt;cache&gt;&lt;/cache&gt;
&lt;/mapper&gt;
</code></pre> 
<p>参数如下：</p> 
<ul><li> <p>type: cache 的使用类型，默认是 PerpetualCache,</p> </li><li> <p>eviction: 定义收回的策略，常见的FIFO，LRU 等</p> 
  <ul><li>LRU 最近最少使用的：移除最长时间不被使用的对象，这是默认值</li><li>FIFO 先进先出，按对象缓存的顺序来移除他们</li><li>SOFT 软引用：移除基于垃圾回收状态和软引用规则的对象</li><li>WEAK 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象</li></ul> </li><li> <p>flushInterval: 配置一定时间自动刷新缓存，单位是毫秒。默认情况不设置，即没有刷新间隔，缓存仅仅在调用语句时刷新。</p> </li><li> <p>size: 最多缓存对象的个数。默认1024</p> </li><li> <p>readOnly: 是否只读，属性可以被设置为true 或 false。默认为false, 若配置可读写，则需要对应的实体类能够序列化。</p> </li><li> <p>blocking: 若缓存中找不到对应的key,是否会一直blocking,直到有对应的数据进入缓存。</p> </li></ul> 
<p><code>cache-ref</code>代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p> 
<pre><code>&lt;cache-ref namespace=com.xa02.mapper.OrderMapper"/&gt;
</code></pre> 
<p>由于二级缓存的数据不一定都是存储到内存中，它的存储介质多种多样，比如说存储到文件系统中，所以需要给缓存的对象执行序列化。</p> 
<p>如果该类存在父类，那么父类也要实现序列化</p> 
<pre><code>public class UserInfo implements Serializable {
    private Long id;
    private String userName;
    private String sex;
    private Date birthday;
    private String address;
  }
</code></pre> 
<p><strong>禁用二级缓存</strong></p> 
<p>默认二级缓存的粒度是Mapper级别的，但是如果在同一个Mapper文件中某个查询不想使用二级缓存的话，就需要对缓存的控制粒度更细。</p> 
<p>在select标签中设置<strong>useCache=false</strong>，可以禁用当前select语句的二级缓存，即每次查询都是去数据库中查询，<strong>默认情况下是true</strong>，即该statement使用二级缓存。</p> 
<pre><code>    &lt;select id="selectUserById"  parameterType="long" resultMap="userResultMap" useCache="false" &gt;
        SELECT
           id,user_name,sex,birthday,address
        FROM
            t_user
     where  id = #{id}
    &lt;/select&gt;
</code></pre> 
<p><strong>刷新二级缓存</strong></p> 
<p>l <strong>通过flushCache属性，可以控制select、insert、update、delete标签是否强制刷新缓存</strong></p> 
<p>l <strong>默认设置</strong></p> 
<p>​ * 默认情况下如果是select语句，那么flushCache是false。</p> 
<p>​ * 如果是insert、update、delete语句，那么flushCache是true。</p> 
<p>l <strong>默认配置解读</strong></p> 
<p>​ * 如果查询语句设置成true，那么每次查询都是去数据库查询，即意味着该查询的二级缓存失效。</p> 
<p>​ * 如果增删改语句设置成false，即使用二级缓存，那么如果在数据库中修改了数据，而缓存数据还是原来的，这个时候就会出现脏读</p> 
<p>flushCache设置如下：</p> 
<pre><code>    &lt;select id="selectUserById"  parameterType="long" resultMap="userResultMap" useCache="false"  flushCache="true"&gt;
        SELECT
           id,user_name,sex,birthday,address
        FROM
            t_user
     where  id = #{id}
    &lt;/select&gt;
</code></pre> 
<p><strong>二级缓存使用条件:</strong></p> 
<ol><li> <p>当会话提交或关闭之后才会填充二级缓存</p> </li><li> <p>必须是在同一个命名空间之下</p> </li><li> <p>必须是相同的statement 即同一个mapper 接口中的同一个方法</p> </li><li> <p>必须是相同的SQL语句和参数</p> </li><li> <p>如果readWrite=true ，实体对像必须实现Serializable 接口</p> </li></ol> 
<p><strong>二级缓存清除条件</strong></p> 
<ol><li> <p>xml中配置的update 不能清空 @CacheNamespace 中的缓存数据</p> </li><li> <p>只有修改会话提交之后 才会执行清空操作</p> </li><li> <p>任何一种增删改操作 都会清空整个namespace 中的缓存</p> </li></ol> 
<h4><a id="522__801"></a>5.2.2 二级缓存的测试</h4> 
<p><strong>案例一</strong></p> 
<p>测试二级缓存效果，不关闭sqlSession，<code>sqlSession1</code>查询完数据后，<code>sqlSession2</code>相同的查询是否会从缓存中获取数据。</p> 
<p><strong>测试</strong></p> 
<pre><code>@Test
    public void selectUserById(){
        SqlSession sqlSessionA = sqlSessionFactory.openSession();
        SqlSession sqlSessionB = sqlSessionFactory.openSession();
        UserMapper mapperA = sqlSessionA.getMapper(UserMapper.class);
        UserMapper mapperB = sqlSessionB.getMapper(UserMapper.class);

            UserInfo userInfo = new UserInfo();
            userInfo.setId(1L);
            // 第一次查询id = 1的用户
            List&lt;UserInfo&gt; userInfoList = mapperA.selectUserList(userInfo);
            System.out.println("first query:"+userInfoList);
           

            // 第二次查询 id = 1 的用户
            List&lt;UserInfo&gt; userInfoList2 =mapperB.selectUserList(userInfo);
            System.out.println("second qyery: "+userInfoList2);
    
    }
</code></pre> 
<p>输出结果：</p> 
<p><img src="https://images2.imgbox.com/01/be/hSUhtuCj_o.png" alt="在这里插入图片描述"></p> 
<p>Cache Hit Radio ： 缓存命中率</p> 
<p>第一次缓存中没有记录，则命中率 0.0；</p> 
<p>第二次缓存中没有记录，则命中率 0.0</p> 
<p><strong>结论:</strong> 如果sqlSession 不执行 commit 或者 close ，SqlSession 不会保存查询数据到二级缓存中，所以上面才会看到两次命中率都是0。</p> 
<p><strong>案例2</strong></p> 
<p>查询完成后，sqlSession 关闭</p> 
<pre><code>  @Test
    public void selectUserById(){
        SqlSession sqlSessionA = sqlSessionFactory.openSession();
        SqlSession sqlSessionB = sqlSessionFactory.openSession();
        UserMapper mapperA = sqlSessionA.getMapper(UserMapper.class);
        UserMapper mapperB = sqlSessionB.getMapper(UserMapper.class);

            UserInfo userInfo = new UserInfo();
            userInfo.setId(1L);
            List&lt;UserInfo&gt; userInfoList = mapperA.selectUserList(userInfo);
            System.out.println("first query:"+userInfoList);
            sqlSessionA.close();

            List&lt;UserInfo&gt; userInfoList2 =mapperB.selectUserList(userInfo);
            System.out.println("second qyery: "+userInfoList2);
            sqlSessionB.close();
    }

</code></pre> 
<p>SQL输出结果：</p> 
<p><img src="https://images2.imgbox.com/b0/32/p6CzVmr1_o.png" alt="在这里插入图片描述"></p> 
<p>第一次缓存中没有记录，则命中率 0.0；</p> 
<p>第二次缓存中没有记录，则命中率 0.5，因为执行了两次，一次命中，所以是 50%。</p> 
<p><strong>结论:</strong> 如果 sqlSession 执行 commit 或者 close ，SqlSessionA查询数据完成后会加入到缓存，然后sqlSessionB 会从缓存中查询。</p> 
<p><strong>案例3</strong></p> 
<p>测试 update 操作是否会清空namespace 下的二级缓存。</p> 
<pre><code> @Test
    public void selectUserById(){
        SqlSession sqlSessionA = sqlSessionFactory.openSession();
        SqlSession sqlSessionB = sqlSessionFactory.openSession();
        SqlSession sqlSessionC = sqlSessionFactory.openSession();
            UserMapper mapperA = sqlSessionA.getMapper(UserMapper.class);
            UserMapper mapperB = sqlSessionB.getMapper(UserMapper.class);
            UserMapper mapperC = sqlSessionC.getMapper(UserMapper.class);

            UserInfo userInfo = new UserInfo();
            userInfo.setId(1L);
            List&lt;UserInfo&gt; userInfoList = mapperA.selectUserList(userInfo);
            sqlSessionA.commit();
            System.out.println("first query ......"+userInfoList);

            UserInfo updateUserInfo = new UserInfo();
            updateUserInfo.setId(1L);
            updateUserInfo.setUserName("Jack");
            mapperB.updateUser(updateUserInfo);
            sqlSessionB.commit();

            List&lt;UserInfo&gt; userInfoList2 =mapperC.selectUserList(userInfo);
            sqlSessionC.commit();
            System.out.println("second query ......"+userInfoList2);
    }
</code></pre> 
<p>SQL输出结果：</p> 
<p>根据SQL分析，确实是清空了二级缓存了。</p> 
<p><img src="https://images2.imgbox.com/43/b1/NFyRluVH_o.png" alt="在这里插入图片描述"></p> 
<p><strong>案例4</strong></p> 
<p>验证多表查询中，牵涉到多个namespace ,比如有一个用户表，订单表，一个用户有多个订单。测试如下：</p> 
<p>1.查询id =1 的用户 的订单信息</p> 
<p>2.更新id = 1的用户的某一条订单信息</p> 
<p>3.再次查询id = 1的用户的订单信息</p> 
<pre><code>@Test
    public void selectUserById(){
        SqlSession sqlSessionA = sqlSessionFactory.openSession(true);
        SqlSession sqlSessionB = sqlSessionFactory.openSession(true);
        SqlSession sqlSessionC = sqlSessionFactory.openSession(true);

        UserMapper userMapperA = sqlSessionA.getMapper(UserMapper.class);
        OrderMapper orderMapper = sqlSessionB.getMapper(OrderMapper.class);
        UserMapper userMapperC = sqlSessionC.getMapper(UserMapper.class);

        UserInfo userInfo = new UserInfo();
        userInfo.setId(1L);
        // 第一次查询用户 id = 1 用户的所有订单
        List&lt;UserInfo&gt; userInfoList = userMapperA.selectOrderListByUserId(1L);
        sqlSessionA.close();
        System.out.println("first query ......"+userInfoList);
       
       // 更新 订单 id = 6 的订单
        OrderInfo orderInfo = new OrderInfo();
        orderInfo.setId(6L);
        orderInfo.setAmount(new BigDecimal(66666));
        orderMapper.updateOrder(orderInfo);
        sqlSessionB.commit();

        // 第二次查询用户id = 1 的所有订单
        List&lt;UserInfo&gt; userInfoList2 =userMapperC.selectOrderListByUserId(1L);
        sqlSessionC.close();
        System.out.println("second query ......"+userInfoList2);
    }
</code></pre> 
<p>测试结果：</p> 
<p><img src="https://images2.imgbox.com/0b/b2/PwHVKoV7_o.png" alt="在这里插入图片描述"></p> 
<p>当sqlSessionA 通过 selectOrderListByUserId 查询id=1用户的订单列表，二级缓存失效。保存到 UserMapper 的namespace 下的cache,我们从上面能看到</p> 
<p>查询到 订单Id= 6 的 金额是 99999.00</p> 
<p>接下来我们使用sqlSessionB 去更新 OrderMapper 的 updateOrder(6L),更新orderId = 6 的订单金额为 66666。</p> 
<p>然后使用sqlSessionC 通过 selectOrderListByUserId 查询id=1用户的订单列表，此时会从缓存中渠道，得到的订单id = 6 的订单金额还是 99999.00.</p> 
<p><strong>所以第二次查询到的是脏数据。</strong></p> 
<p><strong>案例5</strong></p> 
<p>为了解决案例4的问题，我们使用cache ref ,让 OrderMapper 引用 UserMapper的命名空间，这样这两个映射文件对应的SQL操作都使用了同一块缓存。</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.xa02.mapper.OrderMapper"&gt;
    &lt;cache-ref namespace="com.xa02.mapper.UserMapper"/&gt;
    &lt;update id="updateOrder" parameterType="OrderInfo"&gt;
        update  t_order
        &lt;set&gt;
            &lt;if test="amount !=null"&gt;
                amount = #{amount},
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #{id}
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre> 
<p>测试结果：<br> <img src="https://images2.imgbox.com/f8/dd/0zE4eIzj_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="523__1014"></a>5.2.3 二级缓存的源码分析</h4> 
<p>源码模块主要分为两个部分: 二级缓存的创建和二级缓存的使用</p> 
<h5><a id="5231__1018"></a>5.2.3.1 二级缓存的创建</h5> 
<p>整个的创建流程如下：</p> 
<p><img src="https://images2.imgbox.com/c0/4c/j1IziMOf_o.png" alt="在这里插入图片描述"></p> 
<p>&gt;org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElement</p> 
<pre><code>// 二级缓存 namespace 之间的引用
cacheRefElement(context.evalNode("cache-ref"));
// 二级缓存的开启
cacheElement(context.evalNode("cache"));
</code></pre> 
<p>&gt;org.apache.ibatis.builder.MapperBuilderAssistant#useNewCache</p> 
<pre><code>Cache cache = new CacheBuilder(currentNamespace)
     // cache 最终的实现类是 PerpetualCache，可以自定义
    .implementation(valueOrDefault(typeClass, PerpetualCache.class))
    // 默认使用 LruCache,可以自定义
    .addDecorator(valueOrDefault(evictionClass, LruCache.class))
    .clearInterval(flushInterval)
    .size(size)
    .readWrite(readWrite)
    .blocking(blocking)
    .properties(props)
    .build();
</code></pre> 
<p>&gt;org.apache.ibatis.mapping.CacheBuilder#build</p> 
<pre><code>public Cache build() {
  // 设置默认cache 实现类
    setDefaultImplementations();
    // 初始化默认cache实现类，默认是 PerpetualCache
    Cache cache = newBaseCacheInstance(implementation, id);
    setCacheProperties(cache);
    // issue #352, do not apply decorators to custom caches
    // 判断做cache实现类是否是PerpetualCache
    if (PerpetualCache.class.equals(cache.getClass())) {
      for (Class&lt;? extends Cache&gt; decorator : decorators) {
        cache = newCacheDecoratorInstance(decorator, cache);
        setCacheProperties(cache);
      }
      // 最终实现的装饰类如下：&gt; SynchronizedCache -&gt; LoggingCache -&gt; SerializedCache -&gt; ScheduledCache-&gt;FifoCache -&gt; PerpetualCache。
      cache = setStandardDecorators(cache);
    } else if (!LoggingCache.class.isAssignableFrom(cache.getClass())) {
      cache = new LoggingCache(cache);
    }
    return cache;
  }
</code></pre> 
<p>此时的Cache 是 装饰器模式 + 责任链模式</p> 
<blockquote> 
 <p>SynchronizedCache -&gt; LoggingCache -&gt; SerializedCache -&gt; ScheduledCache-&gt;FifoCache -&gt; PerpetualCache。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/5f/25/B4nzrsaV_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/28/88/4Nw3R9C1_o.png" alt="在这里插入图片描述"></p> 
<p>在上面的类图中，只有 PerpetualCache 是具体的实现类，其他都是装饰类。装饰类的特点都实现了Cache接口，持有 一个 Cache 成员变量。</p> 
<p>按功能分类，缓存装饰器类可以分为以下几类：</p> 
<ul><li>同步装饰器： 为缓存增加同步功能，SynchronizedCache。</li><li>日志装饰器： 为缓存增加日志功能，用于记录缓存的命中率，如果开了DEBUG模式，则会出书命中率。LoggingCache。</li><li>清理装饰器： 为缓存中增加各种清理功能，如 LruCache, FifoCache,WeakCache等</li><li>阻塞装饰器：为缓存增加阻塞的功能，如BlockingCache。</li><li>定时清理装饰器： 为缓存添加定时清理的功能，如ScheduledCache</li><li>序列化装饰器：为缓存增加序列化功能，如SerializedCache</li><li>事务装饰器: 用于支持事务操作，如 TransactionalCache</li></ul> 
<p>最基础的缓存类（PerpetualCache）： 只有 PerpetualCache 提供了Cache接口的基本实现，PerpetualCache在装饰器模式中扮演了ConcreteComponent,底层</p> 
<p>实现比较简单，使用了HashMap 来缓存。</p> 
<h5><a id="5232___1105"></a>5.2.3.2 二级缓存的保存</h5> 
<p>源码分析还要从CachingExecutor的query 开始，具体为什么会执行这个类，可以参考 一级缓存的源码分析</p> 
<p><strong>&gt;org.apache.ibatis.executor.CachingExecutor#query</strong></p> 
<pre><code>  @Override
  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
      throws SQLException {
     // 每个 Mapper如果打开了缓存，都有自己的一个缓存空间。
    // 二级缓存的装饰 Cache类 SynchronizedCache -&gt; LoggingCache -&gt; SerializedCache -&gt; LruCache -&gt; PerpetualCache。
    Cache cache = ms.getCache();
    if (cache != null) {
    // 判断是否配置了flushCache=true,若配置了清空暂存区
    // 在 &lt;select&gt; 标签中也可以配置flushCache属性来设置是否查询前要刷新缓存，默认增删改刷新缓存，查询不刷新缓存。
      flushCacheIfRequired(ms);
      // 判断这个mapper 是否开启了二级缓存
      if (ms.isUseCache() &amp;&amp; resultHandler == null) {
      // 主要用来处理存储过程的
        ensureNoOutParams(ms, boundSql);
        @SuppressWarnings("unchecked")
        // 查询二级缓存
        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);
        if (list == null) {//若为空查询数据库并将数据填充到暂存区
          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
          tcm.putObject(cache, key, list); // issue #578 and #116
        }
        return list;
      }
    }
    // 一级缓存就在下面的方法调用的
    return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }
</code></pre> 
<p>Mybatis在查询数据时，首先判断这个mapper有没有开启二级缓存，如果开启了，则先从二级缓存中获取，如果二级缓存中没有，</p> 
<p>1.首先判断是否要刷新缓存</p> 
<pre><code>flushCacheIfRequired(ms);
</code></pre> 
<p>在默认情况下，select 语句不会刷新缓存，insert/update/delete 会刷新缓存，进入该方法，代码如下所示：</p> 
<pre><code> private void flushCacheIfRequired(MappedStatement ms) {
    Cache cache = ms.getCache();
    // 如果xml中配置了 flushCache = true,则会情况缓存
    if (cache != null &amp;&amp; ms.isFlushCacheRequired()) {      
      tcm.clear(cache);
    }
  }
  
  org.apache.ibatis.cache.decorators.TransactionalCache#clear
  @Override
  public void clear() {
    clearOnCommit = true;
    // 清空暂存区
    entriesToAddOnCommit.clear();
  }
</code></pre> 
<p>CachingExecutor 持有了一个 缓存类 TransactionalCacheManager 事务缓存类。</p> 
<p>TransactionalCacheManager 是一个缓存事务管理器，内部用一个Map来记录Cache对象和对应事务TransactionalCache缓存对象。</p> 
<p>内部事务提交、回滚等操作实际都是调用TransactionalCache。</p> 
<pre><code>final Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;Cache, TransactionalCache&gt;();
</code></pre> 
<ul><li>key: cache 对象，每个 MappedStatement一个cache对象，即 一个Mapper.xml对应 一个Cache对象.</li><li>value: 用 TransactionalCache 包裹的 cache对象</li></ul> 
<p><img src="https://images2.imgbox.com/a0/c9/lCjUwVs9_o.png" alt="在这里插入图片描述"></p> 
<p>TransactionalCache 比其他 Cache 对象多出了 2 个方法：commit () 和 rollback ()。TransactionalCache 对象内部存在暂存区，所有对缓存对象的写操作都不会</p> 
<p>直接作用于缓存对象，而是被保存在暂存区，只有调用 TransactionalCache 的 commit () 方法时，所有的更新操作才会真正同步到缓存对象中。</p> 
<p>2.继续 CachingExecutor#query往下走</p> 
<p>从二级缓存中获取数据</p> 
<pre><code> List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);
</code></pre> 
<pre><code class="prism language-.">org.apache.ibatis.cache.decorators.TransactionalCache#getObject
</code></pre> 
<pre><code> @Override
  public Object getObject(Object key) {
    // issue #116
    Object object = delegate.getObject(key);
    if (object == null) {
      entriesMissedInCache.add(key);
    }
    // issue #146
    if (clearOnCommit) {
      return null;
    } else {
      return object;
    }
  }
</code></pre> 
<p>此时的delegate = SynchronizedCache -&gt; LoggingCache -&gt; SerializedCache -&gt; ScheduledCache-&gt;FifoCache -&gt; PerpetualCache。最终到PerpetualCache。</p> 
<p>如果没有查到，会把key加入到 entriesMissedInCache 集合中，主要功能是统计命中率。</p> 
<p>继续 CachingExecutor#query往下走</p> 
<pre><code>if (list == null) {
  //若为空查询数据库并将数据填充到暂存区
   list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
   tcm.putObject(cache, key, list); // issue #578 and #116
 }
</code></pre> 
<p>上面方法首先从一级缓存—&gt;数据库查询，然后加入二级缓存中。</p> 
<p>org.apache.ibatis.cache.decorators.TransactionalCache#putObject</p> 
<pre><code> @Override
  public void putObject(Object key, Object object) {
    entriesToAddOnCommit.put(key, object);
  }
</code></pre> 
<p>// 事务提交前，把从数据库查询出的结果缓存到该集合中<br> private final Map&lt;Object, Object&gt; entriesToAddOnCommit;</p> 
<p>到现在为止，查询的数据放到 二级缓存中的暂存区中，并没有真正的保存到内存中或则第三方存储中。</p> 
<p>那么 ，什么时候才会真正的存储到内存或者第三方存储中。</p> 
<p><strong>只有 SqlSession 调用 close 方法或 commit方法 缓存才会生效：</strong></p> 
<p>源码调用栈如下：</p> 
<p>&gt; org.apache.ibatis.executor.CachingExecutor#commit</p> 
<pre><code>  @Override
  public void commit(boolean required) throws SQLException {
  // BaseExecutor#commit
    delegate.commit(required);
    tcm.commit();
  }
</code></pre> 
<p>tcm.commit 最终会调用 TrancationalCache的commit方法</p> 
<pre><code> public void commit() {
    if (clearOnCommit) {
      delegate.clear();
    }
    //  把暂存区的数据委托给包装后的Cache类，进行 putObject操作
    flushPendingEntries();
    //清空暂存区
    reset();
  }
</code></pre> 
<p>这里的清理标志 ，是在上面方法 flushCacheIfRequired 中设置的标志位，真正的清理 cache是放到这里进行的。具体清理的职责委托给了包装的cache类</p> 
<p>flushPendingEntries 方法是把暂存区的缓存数据</p> 
<p>​ &gt;org.apache.ibatis.cache.decorators.TransactionalCache#flushPendingEntries</p> 
<pre><code>  private void flushPendingEntries() {
  // 把暂存区的数据委托给包装后的Cache类，进行 putObject操作
    for (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) {
      delegate.putObject(entry.getKey(), entry.getValue());
    }

  }
</code></pre> 
<p>​ &gt;org.apache.ibatis.cache.decorators.SynchronizedCache#putObject</p> 
<p>​ &gt;org.apache.ibatis.cache.decorators.LoggingCache#putObject</p> 
<p>​ &gt;org.apache.ibatis.cache.decorators.SerializedCache#putObject</p> 
<p>​ &gt;org.apache.ibatis.cache.decorators.ScheduledCache#putObject</p> 
<p>​ &gt;org.apache.ibatis.cache.decorators.LruCache#putObject</p> 
<p>​ &gt;org.apache.ibatis.cache.impl.PerpetualCache#putObject</p> 
<p>到此为止，二级缓存的源码分析已分析完。</p> 
<h4><a id="524__1329"></a>5.2.4 二级缓存的扩展</h4> 
<p>Mybatis 默认提供的缓存实现是基于Map实现的内存缓存，但是当需要缓存大量的数据时，不能仅仅通过提高内存来适用Mybatis的二级缓存，还可以</p> 
<p>选择Ehcache 或者 redis缓存数据库等工具来保存Mybatis 的二级缓存数据。</p> 
<p>为了提高mybatis的性能，所以需要mybatis和第三方缓存数据库整合，比如ehcache、memcache、redis等</p> 
<h5><a id="5241__Ehcache__1339"></a>5.2.4.1 集成Ehcache 缓存</h5> 
<p>1.Ehcache 介绍</p> 
<p>Ehcache是一种广泛使用的<strong>开源Java分布式缓存</strong>。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。</p> 
<p>特点：</p> 
<ol><li> <p>快速</p> </li><li> <p>简单</p> </li><li> <p>多种缓存策略</p> </li><li> <p>缓存数据有两级：内存和磁盘，因此无需担心容量问题</p> </li><li> <p>缓存数据会在虚拟机重启的过程中写入磁盘</p> </li><li> <p>可以通过RMI、可插入API等方式进行分布式缓存</p> </li><li> <p>具有缓存和缓存管理器的侦听接口</p> </li><li> <p>支持多缓存管理器实例，以及一个实例的多个缓存区域</p> </li><li> <p>整合ehcache的步骤</p> </li></ol> 
<p>​ 2.1 添加项目依赖</p> 
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
            &lt;version&gt;1.2.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre> 
<p>2.2 配置 Ehcache</p> 
<p>在src/main/resources 目录下 新增 ehcache.xml文件</p> 
<pre><code>&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:noNamespaceSchemaLocation="../config/ehcache.xsd"&gt;

&lt;diskStore path="d:/cache" /&gt;

&lt;defaultCache maxElementsInMemory="1000"
              maxElementsOnDisk="10000000" eternal="false" overflowToDisk="false"
              timeToIdleSeconds="120" timeToLiveSeconds="120"
              diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt;
&lt;/defaultCache&gt;
&lt;/ehcache&gt;
</code></pre> 
<ul><li>diskStore：指定数据在磁盘中的存储位置。</li><li>defaultCache: 当借助CacheManager.add(“demoCache”)创建Cache时，EhCache便会采用指定的的管理策略 
  <ul><li>以下属性是必须的：</li><li>maxElementsInMemory - 在内存中缓存的element的最大数目</li><li>maxElementsOnDisk- 在磁盘上缓存的element的最大数目，若是0表示无穷大</li><li>eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断</li><li>overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</li><li>以下属性是可选的：</li><li>timeToLiveSeconds:- 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB<br> 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.</li><li>diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。</li><li>diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作</li><li>memoryStoreEvictionPolicy - - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt;</li></ul> </li></ul> 
<p>2.3 在Mapper文件中，配置cache标签的type为ehcache对cache接口的实现类</p> 
<p>修改UserMapper.xm 中的配置如下：</p> 
<pre><code>    &lt;cache eviction="FIFO" flushInterval="60000" size="512"
           type="org.mybatis.caches.ehcache.EhcacheCache"/&gt;
</code></pre> 
<p>2.4 测试</p> 
<pre><code>    @Test
    public void selectUserById(){
        SqlSession sqlSessionA = sqlSessionFactory.openSession();
        SqlSession sqlSessionB = sqlSessionFactory.openSession();
        UserMapper mapperA = sqlSessionA.getMapper(UserMapper.class);
        UserMapper mapperB = sqlSessionB.getMapper(UserMapper.class);

        UserInfo userInfo = mapperA.selectUserById(1L);
        sqlSessionA.close();

        UserInfo userInfo2 = mapperB.selectUserById(1L);
        sqlSessionB.close();
    }
</code></pre> 
<p><img src="https://images2.imgbox.com/a6/e3/8Y7S85Yh_o.png" alt="在这里插入图片描述"></p> 
<p>2.5 源码分析</p> 
<p>我们值需要分析Cache创建的职责链即可，其他同 二级缓存源码分析章节。</p> 
<p><img src="https://images2.imgbox.com/d5/c7/5OUm98bd_o.png" alt="在这里插入图片描述"></p> 
<p>此时职责链式: Loggingcache --&gt; EhcacheCache</p> 
<p><img src="https://images2.imgbox.com/4e/d0/8XvhxKLv_o.png" alt="在这里插入图片描述"></p> 
<p>2.6 使用场景：</p> 
<p>​ 对于访问响应速度要求高，但是实时性不高的查询，可以采用二级缓存技术。</p> 
<p>注意事项：</p> 
<p>​ 在使用二级缓存的时候，要设置一下<strong>刷新间隔</strong>（cache标签中有一个<strong>flashInterval</strong>属性）来定时刷新二级缓存，这个刷新间隔根据具体需求来设置，比如设置30分钟、60分钟等，<strong>单位为毫秒</strong>。</p> 
<p>2.7 Mybatis二级缓存对细粒度的数据级别的缓存实现不好。</p> 
<p>l 场景：</p> 
<p>​ 对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次查询都是最新的商品信息，此时如果使用二级缓存，就无法实现当一个商品发生变化只刷新该商品的缓存信息而不刷新其他商品缓存信息，因为二级缓存是mapper级别的，当一个商品的信息发送更新，所有的商品信息缓存数据都会清空。</p> 
<p>l 解决方法</p> 
<p>​ 此类问题，需要在业务层根据需要对数据有针对性的缓存。</p> 
<p>​ 比如可以对经常变化的 数据操作单独放到另一个namespace的mapper中。</p> 
<h5><a id="5242_redis_1482"></a>5.2.4.2 集成redis缓存</h5> 
<p><strong>Mybatis自身无法实现分布式缓存，需要和其它分布式缓存框架进行整合。</strong></p> 
<p>如果不使用分布式缓存，缓存的数据在各个服务单独存储，会存在缓存不一致等问题。所以要使用分布式缓存对缓存数据进行集中式管理。</p> 
<p>集成步骤如下：</p> 
<p>1.添加POM依赖</p> 
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-redis&lt;/artifactId&gt;
            &lt;version&gt;1.0.0-beta2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre> 
<p>2.配置redis</p> 
<p>在src/main/resources 目录下新增 redis.properties配置文件</p> 
<pre><code>host=localhost
port=6379
connectionTimeout=5000
password=
database=0
</code></pre> 
<p>3.修改 UserMapper</p> 
<pre><code> &lt;cache type="org.mybatis.caches.redis.RedisCache"/&gt;
</code></pre> 
<p>RedisCache 在保存数据和获取缓存数据的时候，使用了Java的序列化和反序列化，因为 java中被缓存的对象需要实现Serializable 接口。</p> 
<p>4.测试</p> 
<pre><code>    @Test
    public void selectUserById(){
        SqlSession sqlSessionA = sqlSessionFactory.openSession();
        SqlSession sqlSessionB = sqlSessionFactory.openSession();
        UserMapper mapperA = sqlSessionA.getMapper(UserMapper.class);
        UserMapper mapperB = sqlSessionB.getMapper(UserMapper.class);

        UserInfo userInfo = mapperA.selectUserById(1L);
        sqlSessionA.close();

        UserInfo userInfo2 = mapperB.selectUserById(1L);
        sqlSessionB.close();
    }
</code></pre> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-67eOOfb4-1662994753807)(C:\Users\wyy\AppData\Roaming\Typora\typora-user-images\image-20220909235235589.png)]</p> 
<p>redis中缓存如下：</p> 
<p><img src="https://images2.imgbox.com/04/ee/xxu8Eu9w_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9a8e63135a3088fe37093b06293750d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nginx学习笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/57c9e45ab0a1cbc744f3dcacba3ba97a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">markdown基本语法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>