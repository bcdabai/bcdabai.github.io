<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python数据结构11：树的实现，树的应用，前中后序遍历，二叉查找树BST，平衡二叉树AVL树，哈夫曼树和哈夫曼编码 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python数据结构11：树的实现，树的应用，前中后序遍历，二叉查找树BST，平衡二叉树AVL树，哈夫曼树和哈夫曼编码" />
<meta property="og:description" content="1.概念 树一种基本的“非线性”数据结构。
相关术语：
节点Node：组成树的基本部分。每个节点具有名称，或“键值”，节点还可以保存额外数据项，数据项根据不同的应用而变。边Edge：边是组成树的另一个基本部分。每条边恰好连接两个节点，表示节点之间具有关联，边具有出入方向。每个节点（除根节点）恰有一条来自另一节点的入边。每个节点可以有多条连到其它节点的出边。根Root：树种唯一一个没有入边的节点。路径path：边依次连接的节点的有序列表子节点Children：入边均来自于同一个节点的若干节点，称为这个节点的子节点父节点Parent：一个节点是其所有出边所连接节点的父节点兄弟节点Sibling：具有同一个父节点的节点之间成为兄弟节点子树SubTree：一个节点和其所有子孙节点，以及相关边的集合叶节点Leaf：没有子节点的节点。层级Level：从根节点开始到达一个节点的路径，所包含的边的数量，称为这个节点的层级。根节点的层级为0。高度：树中所有节点的最大层级称为树的高度完全二叉树：叶节点只出现在最底层和次底层, 最底层的叶节点集中在树左侧。 - 下标性质：当前节点为P， 则他的父节点是$\frac{P}{2}$，左子节点是2P，右子节点是2P &#43; 1 2.树的数据结构表示方法： 2.1 嵌套列表法 用嵌套的列表表示树。
[根节点root, 左子树left, 右子树right] 例如
这个数表示就是 [a, [b, [d, [], []], [e, [], [] ]], [c, [f, [], []], []]] 2.2 嵌套列表法树插入新节点、返回根节点、返回子树的操作代码实现 def binary_tree(root): # 创建只有根节点的二叉树 return [root, [], []] def insert_left(root, new_branch): # 将新节点插入到树的根节点的左节点，作为其左子树的根节点 # 注：不是将新节点直接插入到左子树的最后一个节点上 temp = root.pop(1) if len(temp) &gt; 1: root.insert(1, [new_branch, temp, []]) else: root.insert(1, [new_branch, [], []]) def insert_right(root, new_branch): # 将新节点插入到树的根节点的右节点，作为其右子树的根节点 # 注：不是将新节点直接插入到右子树的最后一个节点上 temp = root." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0c2a140540c36efcdff85359a8ed3ec8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-11T11:02:18+08:00" />
<meta property="article:modified_time" content="2023-02-11T11:02:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python数据结构11：树的实现，树的应用，前中后序遍历，二叉查找树BST，平衡二叉树AVL树，哈夫曼树和哈夫曼编码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1.概念</h2> 
<p>树一种基本的<font color="red">“非线性”</font>数据结构。</p> 
<p>相关术语：</p> 
<ul><li>节点Node：组成树的基本部分。每个节点具有名称，或“键值”，节点还可以保存额外数据项，数据项根据不同的应用而变。</li><li>边Edge：边是组成树的另一个基本部分。每条边恰好连接两个节点，表示节点之间具有关联，边具有出入方向。每个节点（除根节点）恰有一条来自另一节点的入边。每个节点可以有多条连到其它节点的出边。</li><li>根Root：树种唯一一个没有入边的节点。</li><li>路径path：边依次连接的节点的有序列表</li><li>子节点Children：入边均来自于同一个节点的若干节点，称为这个节点的子节点</li><li>父节点Parent：一个节点是其所有出边所连接节点的父节点</li><li>兄弟节点Sibling：具有同一个父节点的节点之间成为兄弟节点</li><li>子树SubTree：一个节点和其所有子孙节点，以及相关边的集合</li><li>叶节点Leaf：没有子节点的节点。</li><li>层级Level：从根节点开始到达一个节点的路径，所包含的边的数量，称为这个节点的层级。根节点的层级为0。</li><li>高度：树中所有节点的最大层级称为树的高度</li><li>完全二叉树：叶节点只出现在<font color="red">最底层和次底层</font>, 最底层的叶节点集中在树<font color="red">左侧</font>。</li></ul> 
<center> 
 <img src="https://images2.imgbox.com/75/c1/PT9hREfX_o.png" width="50%"> 
</center> - 下标性质：当前节点为P， 则他的父节点是$\frac{P}{2}$，左子节点是2P，右子节点是2P + 1 
<h2><a id="2_19"></a>2.树的数据结构表示方法：</h2> 
<h3><a id="21__20"></a>2.1 嵌套列表法</h3> 
<p>用嵌套的列表表示树。</p> 
<pre><code>[根节点root, 左子树left, 右子树right]
</code></pre> 
<p>例如</p> 
<center> 
 <img src="https://images2.imgbox.com/bf/71/r6sFNcRu_o.png"> 
</center> 这个数表示就是 
<pre><code>[a, [b, [d, [], []], [e, [], [] ]], [c, [f, [], []], []]]
</code></pre> 
<h3><a id="22__35"></a>2.2 嵌套列表法树插入新节点、返回根节点、返回子树的操作代码实现</h3> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">binary_tree</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 创建只有根节点的二叉树</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>root<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>


<span class="token keyword">def</span> <span class="token function">insert_left</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> new_branch<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 将新节点插入到树的根节点的左节点，作为其左子树的根节点</span>
    <span class="token comment"># 注：不是将新节点直接插入到左子树的最后一个节点上</span>
    temp <span class="token operator">=</span> root<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>
        root<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>new_branch<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        root<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>new_branch<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">insert_right</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> new_branch<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 将新节点插入到树的根节点的右节点，作为其右子树的根节点</span>
    <span class="token comment"># 注：不是将新节点直接插入到右子树的最后一个节点上</span>
    temp <span class="token operator">=</span> root<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>
        root<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>new_branch<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        root<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>new_branch<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">get_root_val</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> root<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>


<span class="token keyword">def</span> <span class="token function">set_root_val</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">:</span>
    root<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> new_val


<span class="token keyword">def</span> <span class="token function">get_left_child</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> root<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>


<span class="token keyword">def</span> <span class="token function">get_right_child</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> root<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>


r <span class="token operator">=</span> binary_tree<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
insert_left<span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
insert_left<span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
insert_right<span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>
insert_right<span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>
l <span class="token operator">=</span> get_left_child<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span>

set_root_val<span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
insert_left<span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>get_right_child<span class="token punctuation">(</span>get_right_child<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>[5, [4, [], []], []]<br> [3, [9, [4, [], []], []], [7, [], [6, [], []]]]<br> [3, [9, [11, [4, [], []], []], []], [7, [], [6, [], []]]]<br> [6, [], []]</p> 
</blockquote> 
<h3><a id="22__97"></a>2.2 链表实现：节点链接法</h3> 
<p>每个节点保存根节点的数据项，以及指向左右子树的链接</p> 
<center> 
 <img src="https://images2.imgbox.com/be/dd/hxDafhPV_o.png"> 
</center> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root_obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> root_obj
        self<span class="token punctuation">.</span>left_child <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>right_child <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">insert_left</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>left_child <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>left_child <span class="token operator">=</span> BinaryTree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
            <span class="token comment"># 和之前的操作是一样的，意思是插入到根节点的左节点上</span>
            <span class="token comment"># 原来的左子树插入到现在这个左子树的左子树上</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            t <span class="token operator">=</span> BinaryTree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
            t<span class="token punctuation">.</span>left_child <span class="token operator">=</span> self<span class="token punctuation">.</span>left_child
            self<span class="token punctuation">.</span>left_child <span class="token operator">=</span> t

    <span class="token keyword">def</span> <span class="token function">insert_right</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>right_child <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>right_child <span class="token operator">=</span> BinaryTree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            t <span class="token operator">=</span> BinaryTree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
            t<span class="token punctuation">.</span>right_child <span class="token operator">=</span> self<span class="token punctuation">.</span>right_child
            self<span class="token punctuation">.</span>right_child <span class="token operator">=</span> t

    <span class="token keyword">def</span> <span class="token function">set_root_val</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> obj

    <span class="token keyword">def</span> <span class="token function">get_root_val</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>key

    <span class="token keyword">def</span> <span class="token function">get_left_child</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>left_child

    <span class="token keyword">def</span> <span class="token function">get_right_child</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>right_child


r <span class="token operator">=</span> BinaryTree<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>insert_left<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>insert_right<span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_root_val<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>insert_right<span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>a<br> hello<br> b<br> d</p> 
</blockquote> 
<p>上述操作画成图就是：</p> 
<center> 
 <img src="https://images2.imgbox.com/44/64/KlBXxGqU_o.png" width="40%"> 
</center> 
<h2><a id="3__158"></a>3. 树的应用：解析树</h2> 
<p>树可以应用到自然语言处理（机器翻译、语义理解）中，用来分析句子的语法成分，进而可以对句子的各成分进行处理。</p> 
<p>语法分析树包含：<br> 主谓宾，定状补</p> 
<center> 
 <img src="https://images2.imgbox.com/4c/d5/oG1n9r6l_o.png" width="50%"> 
</center> 
<p>语法树还可以用于程序设计语言的编译当中：<br> 词法、语法检查<br> 从语法树中生成目标代码</p> 
<h2><a id="4__170"></a>4. 树的应用：表达式解析</h2> 
<p>树结构可以表示表达式：</p> 
<ul><li>叶节点：保存操作数</li><li>内部节点：保存操作符</li></ul> 
<p>例如 ((7 + 3) * (5 - 2))的树结构的写法如下：</p> 
<center> 
 <img src="https://images2.imgbox.com/02/ba/f5O6r0Qv_o.png" width="50%"> 
</center> 
<p>由于括号的存在，需要计算*的话，就必须先计<br> 算7+3和5-2。<br> 表达式层次决定计算的优先级。<br> 越底层的表达式，优先级越高。</p> 
<center> 
 <img src="https://images2.imgbox.com/b8/49/XKZVydQS_o.png" width="50%"> 
</center> 
<p>树中每个子树都表示一个子表达式。<br> 将子树替换为子表达式值的节点，即可实现求值。<br> 例如把左子树的 7 + 3 表示成根节点的左叶子节点10的图示如下。</p> 
<center> 
 <img src="https://images2.imgbox.com/4b/dd/vM7DVO5m_o.png" width="50%"> 
</center> 
<p>下面，我们用树结构来做如下尝试：</p> 
<ol><li>从全括号表达式构建表达式解析树</li><li>利用表达式解析树对表达式求值</li><li>从表达式解析树恢复原表达式的字符串形式</li></ol> 
<p>实例：</p> 
<ol><li>将全括号表达式分解为符号Token列表<br> 符号包括：</li></ol> 
<ul><li>括号“（ ）”</li><li>操作符“+ - * /”</li><li>操作数“0～9”这几类</li></ul> 
<p>左括号就是表达式的开始，而右括号是表达式的<br> 结束。</p> 
<p>如对于全括号表达式：(3 + (4 * 5))，将其分解为token表：</p> 
<p>[‘(’, ‘3’, ‘+’, ‘(’, ‘4’, ‘*’, ‘5’, ‘)’, ‘)’]</p> 
<ol start="2"><li>创建表示解析树过程</li><li></ol> 
<center> 
 <font size="6">（3 + (4 * 5)）</font> 
</center> 
<ul><li>创建空树，当前节点为根节点</li><li>读入’('，创建了左子节点，当前节点<font color="red">下降</font></li><li>读入’3’，当前节点<font color="red">设置</font>为3，<font color="red">上升</font>到父节点</li><li>读入’+'，当前节点<font color="red">设置</font>为+，<font color="red">创建</font>右子节点，当前节点<font color="red">下降</font></li></ul> 
<center> 
 <img src="https://images2.imgbox.com/67/d9/OKoYx9sY_o.png" width="50%"> 
</center> 
<ul><li>读入’('，创建左子节点，当前节点<font color="red">下降</font></li><li>读入’4’，当前节点设置为4，<font color="red">上升</font>到父节点</li><li>读入’*‘，当前节点设置为’*'，<font color="red">创建</font>右子节点，当前节点<font color="red">下降</font></li></ul> 
<center> 
 <img src="https://images2.imgbox.com/94/42/gZyHzYTQ_o.png" width="50%"> 
</center> 
<ul><li>读入’5’，当前节点设置为5，<font color="red">上升</font>到父节点</li><li>读入’)'，<font color="red">上升</font>到父节点</li><li>读入’)'，再<font color="red">上升</font>到父节点</li></ul> 
<center> 
 <img src="https://images2.imgbox.com/27/07/gqYeoCZm_o.png" width="20%"> 
</center> 
<p>建立表达式解析树的顺序就是：<br> 从左到右扫描全括号表达式的每个<font color="red">字符token</font>，依据<font color="red">规则</font>建立解析树</p> 
<ul><li>如果当前字符是"<font color="red">(</font>"：为当前节点添加一个新节点作为其左子节点，当前节点下降为这个新节点</li><li>如果当前字符是<font color="red">操作符"+, -, /, *"</font>：将当前节点的值设为此符号，为当前节点添加一个新节点作为其右子节点，当前节点下降为这个新节点</li><li>如果当前字符是<font color="red">操作数</font>：将当前节点的值设为此数，当前节点上升到父节点</li><li>如果字符单词是"<font color="red">)</font>" ：则当前节点上升到父节点</li></ul> 
<p>对全括号表达式 (3 + (4 * 5))，建立表达式解析树的流程就是：</p> 
<center> 
 <img src="https://images2.imgbox.com/0e/51/Z5XNQMCM_o.png" width="50%"> 
</center> 
<p>从图示过程中我们看到，创建树过程中关键的是对当前节点的跟踪：</p> 
<ul><li><font color="red">创建</font>左右子树可调用insert_left/right</li><li>当前节点<font color="red">设置</font>值，可以调用set_root_val</li><li><font color="red">下降</font>到左右子树可调用get_left/right_child</li><li>但是，<font color="red">上升</font>到父节点，这个<font color="red">没有方法</font>支持！</li></ul> 
<p>我们可以用一个<font color="red">栈</font>来记录跟踪父节点。<br> 当前节点下降时，将下降前的节点push入栈。<br> 当前节点需要上升到父节点时，上升到pop出栈的节点即可！</p> 
<pre><code class="prism language-python"><span class="token comment"># 定义一个节点链接法实现的树</span>
<span class="token keyword">class</span> <span class="token class-name">Tree</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root_obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> root_obj
        self<span class="token punctuation">.</span>left_child <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>right_child <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">insert_left</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>left_child <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>left_child <span class="token operator">=</span> Tree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            temp_tree <span class="token operator">=</span> Tree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
            temp_tree<span class="token punctuation">.</span>left_child <span class="token operator">=</span> self<span class="token punctuation">.</span>left_child
            self<span class="token punctuation">.</span>left_child <span class="token operator">=</span> temp_tree

    <span class="token keyword">def</span> <span class="token function">insert_right</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>right_child <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>right_child <span class="token operator">=</span> Tree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            temp_tree <span class="token operator">=</span> Tree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
            temp_tree<span class="token punctuation">.</span>right_child <span class="token operator">=</span> self<span class="token punctuation">.</span>right_child
            self<span class="token punctuation">.</span>right_child <span class="token operator">=</span> temp_tree

    <span class="token keyword">def</span> <span class="token function">get_root_val</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>key

    <span class="token keyword">def</span> <span class="token function">set_root_val</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> new_node

    <span class="token keyword">def</span> <span class="token function">get_left_child</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>left_child

    <span class="token keyword">def</span> <span class="token function">get_right_child</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>right_child


<span class="token comment"># 建构表达解析式树</span>
<span class="token keyword">def</span> <span class="token function">build_parse_tree</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">:</span>
    expression_list <span class="token operator">=</span> expression<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 先把表达解析式拆分到列表当中</span>
    father_node_stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment"># 用栈存储父节点，便于做上下节点的操作</span>

    parse_tree <span class="token operator">=</span> Tree<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
    father_node_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parse_tree<span class="token punctuation">)</span>
    cur_node <span class="token operator">=</span> parse_tree

    <span class="token keyword">for</span> token <span class="token keyword">in</span> expression_list<span class="token punctuation">:</span>
        <span class="token keyword">if</span> token <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>
            cur_node<span class="token punctuation">.</span>insert_left<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
            father_node_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
            cur_node <span class="token operator">=</span> cur_node<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 当前节点下降到左子节点</span>

        <span class="token keyword">if</span> token <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            cur_node<span class="token punctuation">.</span>set_root_val<span class="token punctuation">(</span>token<span class="token punctuation">)</span>
            parent <span class="token operator">=</span> father_node_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 当前节点上升到父节点</span>
            cur_node <span class="token operator">=</span> parent

        <span class="token keyword">if</span> token <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            cur_node<span class="token punctuation">.</span>set_root_val<span class="token punctuation">(</span>token<span class="token punctuation">)</span>
            cur_node<span class="token punctuation">.</span>insert_right<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
            father_node_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
            cur_node <span class="token operator">=</span> cur_node<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 当前节点下降到右子节点</span>

        <span class="token keyword">if</span> token <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> father_node_stack <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                cur_node <span class="token operator">=</span> father_node_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> parse_tree


ex_tree <span class="token operator">=</span> build_parse_tree<span class="token punctuation">(</span><span class="token string">'( 3 * ( 4 + 5 ) )'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ex_tree<span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ex_tree<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ex_tree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ex_tree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ex_tree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h2><a id="5__341"></a>5. 用表达式解析树求值</h2> 
<p>表达式解析树是用来求全括号表达式的值的。<font color="red">二叉树</font>是<font color="red">递归数据结构</font>，可用递归算法处理。</p> 
<p>求值递归函数evaluate：<br> 由前述对子表达式的描述，可从树的底层子树开始，逐步向上层求值，最终得到整个表达式的值。</p> 
<center> 
 <img src="https://images2.imgbox.com/4f/7b/cgjtja1g_o.png" width="50%"> 
</center> 
<p>求值函数evaluate的递归三要素：</p> 
<ul><li>基本结束条件：叶节点是最简单的子树，没有左右子节点，其根节点的数据项即为子表达式树的值</li><li>缩小规模：将表达式树分为左子树、右子树，即为缩小规模</li><li>调用自身：分别调用evaluate计算左子树和右子树的值，然后将左右子树的值依根节点的操作符进行计算，从而得到表达式的值</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">import</span> operator


<span class="token keyword">def</span> <span class="token function">evaluate</span><span class="token punctuation">(</span>parseTree<span class="token punctuation">)</span><span class="token punctuation">:</span>
    operators <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'+'</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>add<span class="token punctuation">,</span>
                 <span class="token string">'-'</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>sub<span class="token punctuation">,</span>
                 <span class="token string">'*'</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>mul<span class="token punctuation">,</span>
                 <span class="token string">'/'</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>truediv<span class="token punctuation">}</span>
    <span class="token comment"># 缩小规模</span>
    leftC <span class="token operator">=</span> parseTree<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 范围缩小到左子树，先求左子树的小表达式的值</span>
    rightC <span class="token operator">=</span> parseTree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 范围缩小到右子树，再求右子树的小表达式的值</span>

    <span class="token keyword">if</span> leftC <span class="token keyword">and</span> rightC<span class="token punctuation">:</span>
        fn <span class="token operator">=</span> operators<span class="token punctuation">[</span>parseTree<span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment"># 每棵子树的根节点，保存着操作符</span>
        <span class="token keyword">return</span> fn<span class="token punctuation">(</span>evaluate<span class="token punctuation">(</span>leftC<span class="token punctuation">)</span><span class="token punctuation">,</span> evaluate<span class="token punctuation">(</span>rightC<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 递归调用</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span>parseTree<span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 基本结束条件，到叶节点就直接返回值了</span>


the_result <span class="token operator">=</span> evaluate<span class="token punctuation">(</span>ex_tree<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The result of the expression: "</span><span class="token punctuation">,</span> the_result<span class="token punctuation">)</span>
</code></pre> 
<p>整个构建表达式解析树和求解的过程如下：</p> 
<pre><code class="prism language-python"><span class="token comment"># 定义一个节点链接法实现的树</span>
<span class="token keyword">class</span> <span class="token class-name">Tree</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root_obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> root_obj
        self<span class="token punctuation">.</span>left_child <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>right_child <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">insert_left</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>left_child <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>left_child <span class="token operator">=</span> Tree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            temp_tree <span class="token operator">=</span> Tree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
            temp_tree<span class="token punctuation">.</span>left_child <span class="token operator">=</span> self<span class="token punctuation">.</span>left_child
            self<span class="token punctuation">.</span>left_child <span class="token operator">=</span> temp_tree

    <span class="token keyword">def</span> <span class="token function">insert_right</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>right_child <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>right_child <span class="token operator">=</span> Tree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            temp_tree <span class="token operator">=</span> Tree<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>
            temp_tree<span class="token punctuation">.</span>right_child <span class="token operator">=</span> self<span class="token punctuation">.</span>right_child
            self<span class="token punctuation">.</span>right_child <span class="token operator">=</span> temp_tree

    <span class="token keyword">def</span> <span class="token function">get_root_val</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>key

    <span class="token keyword">def</span> <span class="token function">set_root_val</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> new_node

    <span class="token keyword">def</span> <span class="token function">get_left_child</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>left_child

    <span class="token keyword">def</span> <span class="token function">get_right_child</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>right_child


<span class="token comment"># 建构表达解析式树</span>
<span class="token keyword">def</span> <span class="token function">build_parse_tree</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">:</span>
    expression_list <span class="token operator">=</span> expression<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 先把表达解析式拆分到列表当中</span>
    father_node_stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment"># 用栈存储父节点，便于做上下节点的操作</span>

    parse_tree <span class="token operator">=</span> Tree<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
    father_node_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parse_tree<span class="token punctuation">)</span>
    cur_node <span class="token operator">=</span> parse_tree

    <span class="token keyword">for</span> token <span class="token keyword">in</span> expression_list<span class="token punctuation">:</span>
        <span class="token keyword">if</span> token <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>
            cur_node<span class="token punctuation">.</span>insert_left<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
            father_node_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
            cur_node <span class="token operator">=</span> cur_node<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 当前节点下降到左子节点</span>

        <span class="token keyword">if</span> token <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            cur_node<span class="token punctuation">.</span>set_root_val<span class="token punctuation">(</span>token<span class="token punctuation">)</span>
            parent <span class="token operator">=</span> father_node_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 当前节点上升到父节点</span>
            cur_node <span class="token operator">=</span> parent

        <span class="token keyword">if</span> token <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            cur_node<span class="token punctuation">.</span>set_root_val<span class="token punctuation">(</span>token<span class="token punctuation">)</span>
            cur_node<span class="token punctuation">.</span>insert_right<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
            father_node_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
            cur_node <span class="token operator">=</span> cur_node<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 当前节点下降到右子节点</span>

        <span class="token keyword">if</span> token <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> father_node_stack <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                cur_node <span class="token operator">=</span> father_node_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> parse_tree


ex_tree <span class="token operator">=</span> build_parse_tree<span class="token punctuation">(</span><span class="token string">'( 3 * ( 4 + 5 ) )'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ex_tree<span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ex_tree<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ex_tree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ex_tree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ex_tree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">import</span> operator


<span class="token keyword">def</span> <span class="token function">evaluate</span><span class="token punctuation">(</span>parseTree<span class="token punctuation">)</span><span class="token punctuation">:</span>
    operators <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'+'</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>add<span class="token punctuation">,</span>
                 <span class="token string">'-'</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>sub<span class="token punctuation">,</span>
                 <span class="token string">'*'</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>mul<span class="token punctuation">,</span>
                 <span class="token string">'/'</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>truediv<span class="token punctuation">}</span>
    <span class="token comment"># 缩小规模</span>
    leftC <span class="token operator">=</span> parseTree<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 范围缩小到左子树，先求左子树的小表达式的值</span>
    rightC <span class="token operator">=</span> parseTree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 范围缩小到右子树，再求右子树的小表达式的值</span>

    <span class="token keyword">if</span> leftC <span class="token keyword">and</span> rightC<span class="token punctuation">:</span>
        fn <span class="token operator">=</span> operators<span class="token punctuation">[</span>parseTree<span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment"># 每棵子树的根节点，保存着操作符</span>
        <span class="token keyword">return</span> fn<span class="token punctuation">(</span>evaluate<span class="token punctuation">(</span>leftC<span class="token punctuation">)</span><span class="token punctuation">,</span> evaluate<span class="token punctuation">(</span>rightC<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 递归调用</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span>parseTree<span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 基本结束条件，到叶节点就直接返回值了</span>


the_result <span class="token operator">=</span> evaluate<span class="token punctuation">(</span>ex_tree<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The result of the expression: "</span><span class="token punctuation">,</span> the_result<span class="token punctuation">)</span>
</code></pre> 
<h2><a id="6__487"></a>6. 树的遍历</h2> 
<center> 
 <img src="https://images2.imgbox.com/6b/b1/5v2ZSqFC_o.png" width="30%"> 
</center> 
<p>例图来源于：<a href="https://zhuanlan.zhihu.com/p/404837352" rel="nofollow">一文搞懂二叉树的前序遍历，中序遍历，后序遍历</a></p> 
<h3><a id="61__preorder_493"></a>6.1 前序遍历 preorder</h3> 
<p>遍历顺序：<strong>根节点 -&gt; 左子树 -&gt; 右子树</strong></p> 
<p>对上图： 4-&gt;2-&gt;1-&gt;3-&gt;6-&gt;5-&gt;7</p> 
<p>Python代码:</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> tree<span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>getRootVal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		preorder<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>getLeftChild<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		preorder<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>getRightChild<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="62__inorder_506"></a>6.2 中序遍历 inorder</h3> 
<p>遍历顺序：<strong>左子树 -&gt; 根节点 -&gt; 右子树</strong></p> 
<p>对上图：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7</p> 
<p>Python代码:</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> tree <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
		inorder<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>getLeftChild<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>getRootVal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		inorder<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>getRightChild<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="63__postorder_521"></a>6.3 后序遍历 postorder</h3> 
<p>遍历顺序：<strong>左子树 -&gt; 右子树 -&gt; 根节点</strong></p> 
<p>对上图：1-&gt;3-&gt;2-&gt;5-&gt;7-&gt;6-&gt;4</p> 
<p>Python代码:</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">postorder</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> tree <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
		postorder<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>getLeftChild<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		postorder<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>getRightChild<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>getRootVal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="64__536"></a>6.4 前序遍历还有可以写在建树的代码里</h3> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
    <span class="token keyword">if</span> self<span class="token punctuation">.</span>left_child<span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>left_child<span class="token punctuation">.</span>preorder<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> self<span class="token punctuation">.</span>right_child<span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>right_child<span class="token punctuation">.</span>preorder<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="65__546"></a>6.5 后序遍历：表达式求值</h3> 
<p>回顾第5节的内容，表达式解析树求值，也是一个后序遍历的过程。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> operator


<span class="token keyword">def</span> <span class="token function">post_order_evaluate</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">:</span>
    opers <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"+"</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>add<span class="token punctuation">,</span>
        <span class="token string">"-"</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>sub<span class="token punctuation">,</span>
        <span class="token string">"*"</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>mul<span class="token punctuation">,</span>
        <span class="token string">"/"</span><span class="token punctuation">:</span> operator<span class="token punctuation">.</span>truediv
    <span class="token punctuation">}</span>

    res1 <span class="token operator">=</span> <span class="token boolean">None</span>
    res2 <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">if</span> tree<span class="token punctuation">:</span>
        res1 <span class="token operator">=</span> post_order_evaluate<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left_child<span class="token punctuation">)</span>
        res2 <span class="token operator">=</span> post_order_evaluate<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right_child<span class="token punctuation">)</span>
        <span class="token keyword">if</span> res1 <span class="token keyword">and</span> res2<span class="token punctuation">:</span>
            <span class="token keyword">return</span> opers<span class="token punctuation">[</span>tree<span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>res1<span class="token punctuation">,</span> res2<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> tree<span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="66__572"></a>6.6 中序遍历建立全括号中缀表达式</h3> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">print_exp</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">:</span>
    the_exp <span class="token operator">=</span> <span class="token string">""</span>
    <span class="token keyword">if</span> tree<span class="token punctuation">:</span>
        <span class="token keyword">if</span> tree<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            the_exp <span class="token operator">=</span> <span class="token string">'('</span> <span class="token operator">+</span> print_exp<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            the_exp <span class="token operator">=</span> print_exp<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>get_left_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        the_exp <span class="token operator">=</span> the_exp <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>get_root_val<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> tree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            the_exp <span class="token operator">=</span> the_exp <span class="token operator">+</span> print_exp<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">')'</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            the_exp <span class="token operator">=</span> the_exp <span class="token operator">+</span> print_exp<span class="token punctuation">(</span>tree<span class="token punctuation">.</span>get_right_child<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> the_exp

<span class="token keyword">print</span><span class="token punctuation">(</span>print_exp<span class="token punctuation">(</span>ex_tree<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 接在第5节的后，结果是 (3*(4+5))</span>
</code></pre> 
<h2><a id="7_Binary_Heap_Priority_Queue_591"></a>7. 二叉堆Binary Heap和优先队列 Priority Queue</h2> 
<h3><a id="71__593"></a>7.1 优先队列</h3> 
<p>前面我们学习了一种FIFO数据结构队列，队列有一种变体称为“<font color="red">优先队列</font>”。<br> 例如：银行窗口取号排队，VIP客户可以插到队首。操作系统中执行关键任务的进程或用户特别指定进程在调度队列中靠前。</p> 
<center> 
 <img src="https://images2.imgbox.com/0b/7c/ZicSLS3g_o.png" width="50%"> 
</center> 
<p>优先队列的出队跟队列一样从<font color="red">队首</font>出队；</p> 
<p>但在优先队列内部，数据项的次序却是由“<font color="red">优先级</font>”来确定：</p> 
<ul><li><font color="red">高优先级</font>的数据项排在队首，而<font color="red">低优先级</font>的数据项则排在后面。</li><li>这样，优先队列的<font color="red">入队</font>操作就比较<font color="red">复杂</font>，需要将数据项根据其优先级尽量挤到队列前方。</li></ul> 
<h3><a id="72_Binary_Heap_605"></a>7.2 二叉堆Binary Heap实现优先队列</h3> 
<p>实现优先队列的经典方案是采用<font color="red">二叉堆</font>数据结构。<br> 二叉堆能够将优先队列的<font color="red">入队</font>和<font color="red">出队</font>复杂度都保持在<font color="red">O(log n)</font>。<br> 二叉堆的有趣之处在于，其逻辑结构上像二叉树，却是用非嵌套的列表来实现的！<br> 最小key排在队首的称为“最小堆min heap”，反之，最大key排在队首的是“最大堆max heap”</p> 
<p>BinaryHeap数据结构的类，包含以下操作：</p> 
<ul><li>BinaryHeap()：创建一个空二叉堆对象；</li><li>insert(k)：将新key加入到堆中；</li><li>findMin()：返回堆中的最小项，最小项仍保留在堆中；</li><li>delMin()： 返回堆中的最小项，同时从堆中删除；</li><li>isEmpty()：返回堆是否为空；</li><li>size()：返回堆中key的个数；</li><li>buildHeap(list)：从一个key列表创建新堆</li></ul> 
<p>对这个类的操作如下：</p> 
<center> 
 <img src="https://images2.imgbox.com/d6/9f/Z9h9WeEx_o.png" width="50%"> 
</center> 
<h3><a id="73__624"></a>7.3 用非嵌套列表实现二叉堆</h3> 
<p>为了使堆操作能保持在对数水平上，就必须采用二叉树结构；</p> 
<p>同样，如果要使操作<font color="red">始终</font>保持在对数数量级上，就必须始终保持二叉树的“平衡”，即树根左右子树拥有相同数量的节点。</p> 
<center> 
 <img src="https://images2.imgbox.com/a4/aa/tRNWptAk_o.png" width="50%"> 
</center> 
<p>可采用“<font color="red">完全二叉树</font>”的结构来<font color="red">近似</font>实现“平衡”。<br> 完全二叉树，叶节点最多只出现在最底层和次底层，而且最底层的叶节点都连续集中在最左边，每个内部节点都有两个子节点，最多可有1个节点例外（即最后一个节点，有可能时单独的一个子节点）</p> 
<center> 
 <img src="https://images2.imgbox.com/55/7e/kvnCzxtR_o.png" width="50%"> 
</center> 
<p>我们给上面这个图，按照从上往下，从左往右的顺序打上索引。可以看出，如果节点的下标为p，那么：</p> 
<ul><li>左子节点下标为2p</li><li>右子节点为2p+1</li><li>父节点下标为p // 2</li></ul> 
<center> 
 <img src="https://images2.imgbox.com/e8/06/hyCoqEZd_o.png" width="50%"> 
</center> 
<p>可见，完全二叉树由于其特殊性，可以用非嵌套列表，以简单的方式实现，具有很好性质。</p> 
<h3><a id="74_Heap_Order_646"></a>7.4 堆排序Heap Order</h3> 
<p>堆排序应该放在排序那一章节的，但是其实现时树这一章的，所以在这里将。</p> 
<p>对于一个 最小堆<br> 任何一个节点x，其父节点 p 中的 key 均小于 x 中的 key。<br> 这样，符合“堆”性质的二叉树，其中任何一条路径，均是一个已排序数列，<font color="blue"><u>根节点的key最小</u></font>。</p> 
<center> 
 <img src="https://images2.imgbox.com/ae/a0/PFRgW5vj_o.png" width="50%"> 
</center> 
<h2><a id="4__Binary_Search_Tree_BST_657"></a>4. 树的应用：二叉排序（查找）树 Binary Search Tree BST</h2> 
<h3><a id="41__658"></a>4.1 定义</h3> 
<p>就是一颗 左子树所有节点的关键字值 &lt; 根节点关键字值 &lt; 右子树所有节点的关键字值 的树<br> 所有的子树都符合这个规律</p> 
<p>由于二叉查找树 左&lt;根&lt;右的特点，对二叉排序树<strong>中序遍历</strong>，就可以得到 <strong>递增序列</strong><br> <img src="https://images2.imgbox.com/95/8e/O7VxAg81_o.png" alt="在这里插入图片描述"><br> 如中序遍历这个 BST得到 123468 序列</p> 
<h3><a id="42__666"></a>4.2 查找节点</h3> 
<p>BST的查找过程和二分法差不多：</p> 
<ol><li>目标和根节点对比，相等，查找成功</li><li>目标&gt;根节点，查找右子树</li><li>目标&lt;根节点，查找左子树</li></ol> 
<h3><a id="43__672"></a>4.3 插入节点</h3> 
<p>BST插入节点的过程和查找的过程是一样的，</p> 
<ol><li>BST为空时，直接插入</li><li>若关键字小于根节点就插入左子树</li><li>关键字小于根节点就插入右子树<br> <img src="https://images2.imgbox.com/e5/36/Xxp1reMC_o.png" alt="在这里插入图片描述"><br> 就像这个图 ， 分别是插入28和58，虚线是搜索插入位置的路径</li></ol> 
<h3><a id="44__680"></a>4.4 删除节点</h3> 
<ol><li> <p>如果删除的是叶节点，直接删除，不影响BST的性质</p> </li><li> <p>如果删除的节点只有一颗子树（左或右），让这个子树成为删除节点的父节点的子树，代替原来的位置<img src="https://images2.imgbox.com/85/0b/rLxli146_o.png" alt="在这里插入图片描述"></p> </li><li> <p>如果删除的节点有两颗子树，让节点的直接后继（即在大小上刚好大于它的，在列表中处于他后面的那个位置的节点）代替他<br> <img src="https://images2.imgbox.com/04/f5/ay4YWypP_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<h3><a id="45__687"></a>4.5 构造二叉查找树</h3> 
<p>和插入节点的操作是一样的，就是依次用上面的方法插入节点</p> 
<h3><a id="46__690"></a>4.6 二叉树查找效率分析</h3> 
<p><img src="https://images2.imgbox.com/07/35/5IiExrkl_o.png" alt=""></p> 
<p>平均查找长度ASL可表示查找效率：计算方法，就是查找每个节点需要走多少步，加起来，除以总的节点的个数</p> 
<p>对于左边的树<br> ASL = (1 + 2 * 2 + 3 * 4 + 4 * 3) / 10 = 2.9<br> 对于右边的树<br> ASL = (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10) / 10 = 5.5</p> 
<h2><a id="5__AVL_699"></a>5. 树的应用：平衡二叉树 AVL树</h2> 
<h3><a id="51__700"></a>5.1 定义</h3> 
<p>任意节点的左右子树高度差绝对值不超过1的二叉排序树叫做AVL树（平衡二叉树）</p> 
<p><strong>平衡因子</strong>：左右子树的高度差， AVL树的平衡因子只能是 -1， 0， 1<br> <img src="https://images2.imgbox.com/6c/d9/S57iZnE0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="52__705"></a>5.2 平衡二叉树插入节点旋转</h3> 
<p>插入新节点可能导致平衡二叉树变得不平衡，然后就需要旋转<br> 旋转的方法这篇博客讲的很好<br> <a href="https://blog.csdn.net/saasanken/article/details/80796178">二叉平衡树的旋转操作</a></p> 
<h2><a id="6__711"></a>6. 树的应用：哈夫曼树和哈夫曼编码</h2> 
<h3><a id="61__712"></a>6.1 定义</h3> 
<p>在许多实际应用中，树的节点带有权重。</p> 
<p>带权路径长度WPL：从根节点到任意节点的路径长度（经过的边数）与该节点的权值的乘积，记为：<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         W 
        
       
         P 
        
       
         L 
        
       
         = 
        
        
        
          ∑ 
         
         
         
           i 
          
         
           = 
          
         
           1 
          
         
        
          n 
         
        
        
        
          w 
         
        
          i 
         
        
        
        
          l 
         
        
          i 
         
        
       
      
        WPL = \sum_{i = 1}^{n}w_il_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.104em; vertical-align: -0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8043em;"><span class="" style="top: -2.4003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2997em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0197em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          w 
         
        
          i 
         
        
       
      
        w_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是第i个节点的权值<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          l 
         
        
          i 
         
        
       
      
        l_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0197em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是根节点到该节点的路径长度</p> 
<p>哈夫曼树是带权路径长度最小的二叉树，也称最优二叉树</p> 
<h3><a id="62__722"></a>6.2 构造哈夫曼树</h3> 
<p>每次选最小的两个节点作为子节点，他们的和作为父节点。</p> 
<p>例如<br> <img src="https://images2.imgbox.com/7f/12/UWIoEgT5_o.png" alt="在这里插入图片描述"><br> 我这个可能看不清楚，<a href="https://blog.csdn.net/dongfei2033/article/details/80657360?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164722717516780269858869%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164722717516780269858869&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80657360.es_vector_control_group&amp;utm_term=%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91&amp;spm=1018.2226.3001.4187">哈夫曼树以及哈夫曼编码的构造步骤</a><br> 这篇文章讲的不错<br> 这颗哈夫曼树的WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3= 35</p> 
<h3><a id="63__731"></a>6.3 哈夫曼编码</h3> 
<p>前缀编码：没有一个编码是另一个编码的前缀，如 0，101和100是前缀编码。前缀编码不容易造成混淆，所以翻译简单。</p> 
<p>由哈夫曼树得到的哈夫曼编码就是前缀编码，至于怎么得到的<br> 还是这篇文章讲的更好一些<a href="https://blog.csdn.net/dongfei2033/article/details/80657360?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164722717516780269858869%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164722717516780269858869&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80657360.es_vector_control_group&amp;utm_term=%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91&amp;spm=1018.2226.3001.4187">哈夫曼树以及哈夫曼编码的构造步骤</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a7a860e947f5f3b843c5bf1d7d8dc359/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在局域网中禁止内网通软件通信，该怎样操作？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2aab533ed9afe39c0dde0c8d1b87de8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis常见架构及其原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>