<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】平衡树之红黑树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】平衡树之红黑树" />
<meta property="og:description" content="AVL树解决了二叉搜索树退化为单支树而引发的效率问题，是一种绝对平衡的二叉搜索树，其性质（每个节点的左右子树高度差绝对值都不超过1）使其在对数据进行搜索时始终能保持高效（详见【数据结构】平衡树之AVL树）。但是，当涉及一些结构上的修改场景（例如增删），因为要频繁通过旋转来维护其绝对平衡的结构特性，代价较高，使得其在这样的场景中性能十分低下。
为了继续优化效率问题，后来又不断有大佬提出新的解决方案。1972年，Rudolf Bayer发明了最初红黑树（当时被称为平衡二叉B树）。而后在1978年， Leo J. Guibas 和 Robert Sedgewick 将其修改成了如今的红黑树。 红黑树（RBTree）是一种特殊的二叉平衡搜索树，通过一种特殊的“手法”来控制着二叉搜索树的平衡，使其效率与AVL树相当，且在应用和维护等方面整体优于AVL树。
对于平衡的控制，红黑树放弃了AVL树中调整平衡因子的方式（任一节点的左右子树高度差的绝对值不大于1），而是在树的每个节点上增加了一个用于表示节点的颜色（可以是Red或Black）的存储位，通过对任意一条从根到某个叶子节点的路径上，各个节点着色方式的限制，确保最长路径不超过最短路径的2倍，以此来使一整棵树接近平衡。
红黑树的应用十分的广泛，例如Java的集合框架 (HashMap、TreeMap、TreeSet)、C&#43;&#43; 的 STL（map/set、mutil_map/mutil_set）、linux内核等等，都将红黑树作为底层结构来使用过。
本篇博客将通过，对红黑树性质的梳理和主要功能的模拟实现，来帮助读者更加全面地了解红黑树。
目录
一、红黑树的性质 二、红黑树的模拟实现
1 - 树的构建
2 - 插入
3 - 完整代码
补、一些迷思
1.控制节点的红和黑，怎么就做到了“最长路径不超过最短路径的2倍”？
2.由红黑树与AVL树的性能比较，来说明为什么放弃绝对平衡
3.为什么新创建的节点/新插入的节点默认为红色？
4.对两种需控制平衡的情景的更多说明
5.插入构建红黑树的过程图解
一、红黑树的性质 红黑树是因其维护平衡的手段而得名的，通过对树节点颜色的控制，来实现“最长路径不超过最短路径的2倍”的近似平衡。它主要具备以下性质（或者说是它的平衡规则），且这些性质与维护平衡息息相关：
任意一个树节点的颜色非红即黑；根节点的颜色必为黑； 任意一个颜色为红的树节点，其孩子节点均为黑，双亲节点为黑（这意味着任意路径上没有连续的红色节点）； 对于任意一条从（不为空的叶节点下的）空节点通往根节点的路径，每条路径上黑色节点数量均相同； 每个空节点默认为黑色。 （ps：NIL节点指的是空节点 ）
二、红黑树的模拟实现 1 - 树的构建 //用枚举体来标识节点的颜色 enum Colour { RED, //0 BLACK, //1 }; //创建一个树节点（三叉链结构） template&lt;class K, class V&gt; struct RBTreeNode { RBTreeNode&lt;K, V&gt;* _left; //左孩子 RBTreeNode&lt;K, V&gt;* _right; //右孩子 RBTreeNode&lt;K, V&gt;* _parent; //双亲 pair&lt;K, V&gt; _kv; //节点的值 Colour _col; //放弃了AVL树的平衡因子，改用颜色标识来控制平衡 //一个树节点的构造函数 RBTreeNode(const pair&lt;K, V&gt;&amp;kv) : _left(nullptr) , _right(nullptr) , _parent(nullptr) , _kv(kv) , _col(RED) //默认一个新节点为红色 {} }; //创建一棵红黑树 template&lt;class K, class V&gt; class RBTree { typedef RBTreeNode&lt;K, V&gt;Node; private: //根节点 Node*_root = nullptr; }; 2 - 插入 红黑树可以看作是引入了颜色标识的二叉搜索树，与AVL树类似（详见【数据结构】平衡树之AVL树），它插入过程也大致分为两步：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/33c7360204b5b12904bf102c8ada07e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-20T17:26:32+08:00" />
<meta property="article:modified_time" content="2023-11-20T17:26:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】平衡树之红黑树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        AVL树解决了二叉搜索树退化为单支树而引发的效率问题，是一种绝对平衡的二叉搜索树，其性质（每个节点的左右子树高度差绝对值都不超过1）使其在对数据进行搜索时始终能保持高效（详见<a class="link-info" href="https://blog.csdn.net/waluolandao/article/details/134122645?spm=1001.2014.3001.5501" title="【数据结构】平衡树之AVL树">【数据结构】平衡树之AVL树</a>）。但是，当涉及一些结构上的修改场景（例如增删），因为要频繁通过旋转来维护其绝对平衡的结构特性，代价较高，使得其在这样的场景中性能十分低下。</p> 
<p>        为了继续优化效率问题，后来又不断有大佬提出新的解决方案。1972年，Rudolf Bayer发明了最初红黑树（当时被称为平衡二叉B树）。而后在1978年， Leo J. Guibas 和 Robert Sedgewick 将其修改成了如今的红黑树。 </p> 
<p>       红黑树（RBTree）是一种特殊的二叉平衡搜索树，通过一种特殊的“手法”来控制着二叉搜索树的平衡，使其效率与AVL树相当，且在应用和维护等方面整体优于AVL树。</p> 
<p>        对于平衡的控制，红黑树放弃了AVL树中调整平衡因子的方式（任一节点的左右子树高度差的绝对值不大于1），而是在树的每个节点上增加了一个用于表示节点的颜色（可以是Red或Black）的存储位，通过对任意一条从根到某个叶子节点的路径上，各个节点着色方式的限制，确保<strong>最长路径不超过最短路径的2倍</strong>，以此来使一整棵树接近平衡。</p> 
<p>        红黑树的应用十分的广泛，例如Java的集合框架 (HashMap、TreeMap、TreeSet)、C++ 的 STL（map/set、mutil_map/mutil_set）、linux内核等等，都将红黑树作为底层结构来使用过。</p> 
<p>        本篇博客将通过，对红黑树性质的梳理和主要功能的模拟实现，来帮助读者更加全面地了解红黑树。</p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%C2%A0" rel="nofollow">一、红黑树的性质 </a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">二、红黑树的模拟实现</a></p> 
<p id="1%20-%20%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA-toc" style="margin-left:40px;"><a href="#1%20-%20%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA" rel="nofollow">1 - 树的构建</a></p> 
<p id="2%20-%20%E6%8F%92%E5%85%A5-toc" style="margin-left:40px;"><a href="#2%20-%20%E6%8F%92%E5%85%A5" rel="nofollow">2 - 插入</a></p> 
<p id="3%20-%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#3%20-%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">3 - 完整代码</a></p> 
<p id="%E8%A1%A5%E3%80%81%E4%B8%80%E4%BA%9B%E8%BF%B7%E6%80%9D-toc" style="margin-left:0px;"><a href="#%E8%A1%A5%E3%80%81%E4%B8%80%E4%BA%9B%E8%BF%B7%E6%80%9D" rel="nofollow">补、一些迷思</a></p> 
<p id="1.%E6%8E%A7%E5%88%B6%E8%8A%82%E7%82%B9%E7%9A%84%E7%BA%A2%E5%92%8C%E9%BB%91%EF%BC%8C%E6%80%8E%E4%B9%88%E5%B0%B1%E5%81%9A%E5%88%B0%E4%BA%86%E2%80%9C%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E4%B8%8D%E8%B6%85%E8%BF%87%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%842%E5%80%8D%E2%80%9D%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.%E6%8E%A7%E5%88%B6%E8%8A%82%E7%82%B9%E7%9A%84%E7%BA%A2%E5%92%8C%E9%BB%91%EF%BC%8C%E6%80%8E%E4%B9%88%E5%B0%B1%E5%81%9A%E5%88%B0%E4%BA%86%E2%80%9C%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E4%B8%8D%E8%B6%85%E8%BF%87%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%842%E5%80%8D%E2%80%9D%EF%BC%9F" rel="nofollow">1.控制节点的红和黑，怎么就做到了“最长路径不超过最短路径的2倍”？</a></p> 
<p id="2.%E7%94%B1%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%EF%BC%8C%E6%9D%A5%E8%AF%B4%E6%98%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E5%BC%83%E7%BB%9D%E5%AF%B9%E5%B9%B3%E8%A1%A1-toc" style="margin-left:40px;"><a href="#2.%E7%94%B1%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%EF%BC%8C%E6%9D%A5%E8%AF%B4%E6%98%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E5%BC%83%E7%BB%9D%E5%AF%B9%E5%B9%B3%E8%A1%A1" rel="nofollow">2.由红黑树与AVL树的性能比较，来说明为什么放弃绝对平衡</a></p> 
<p id="3.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B0%E5%88%9B%E5%BB%BA%E7%9A%84%E8%8A%82%E7%82%B9%2F%E6%96%B0%E6%8F%92%E5%85%A5%E7%9A%84%E8%8A%82%E7%82%B9%E9%BB%98%E8%AE%A4%E4%B8%BA%E7%BA%A2%E8%89%B2%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B0%E5%88%9B%E5%BB%BA%E7%9A%84%E8%8A%82%E7%82%B9%2F%E6%96%B0%E6%8F%92%E5%85%A5%E7%9A%84%E8%8A%82%E7%82%B9%E9%BB%98%E8%AE%A4%E4%B8%BA%E7%BA%A2%E8%89%B2%EF%BC%9F" rel="nofollow">3.为什么新创建的节点/新插入的节点默认为红色？</a></p> 
<p id="4.%E5%AF%B9%E4%B8%A4%E7%A7%8D%E9%9C%80%E6%8E%A7%E5%88%B6%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%83%85%E6%99%AF%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#4.%E5%AF%B9%E4%B8%A4%E7%A7%8D%E9%9C%80%E6%8E%A7%E5%88%B6%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%83%85%E6%99%AF%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%AF%B4%E6%98%8E" rel="nofollow">4.对两种需控制平衡的情景的更多说明</a></p> 
<p id="5.%E6%8F%92%E5%85%A5%E6%9E%84%E5%BB%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3-toc" style="margin-left:40px;"><a href="#5.%E6%8F%92%E5%85%A5%E6%9E%84%E5%BB%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3" rel="nofollow">5.插入构建红黑树的过程图解</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%C2%A0">一、红黑树的性质 </h2> 
<p>        红黑树是因其维护平衡的手段而得名的，通过对树节点颜色的控制，来实现“<strong>最长路径不超过最短路径的2倍</strong>”的近似平衡。它主要具备以下性质（或者说是它的平衡规则），且这些性质与维护平衡息息相关：</p> 
<blockquote> 
 <ol><li>任意一个树节点的颜色非红即黑；</li><li>根节点的颜色必为黑；  </li><li>任意一个颜色为红的树节点，其孩子节点均为黑，双亲节点为黑（这意味着任意路径上没有连续的红色节点）；  </li><li>对于任意一条从（不为空的叶节点下的）空节点通往根节点的路径，每条路径上黑色节点数量均相同； </li><li>每个空节点默认为黑色。</li></ol> 
</blockquote> 
<p><img alt="" height="558" src="https://images2.imgbox.com/b4/85/X5k4K5Js_o.png" width="1170"></p> 
<p>（ps：NIL节点指的是空节点 ）</p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">二、红黑树的模拟实现</h2> 
<h3 id="1%20-%20%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA">1 - 树的构建</h3> 
<pre><code class="language-cpp">//用枚举体来标识节点的颜色
enum Colour
{
	RED,    //0
	BLACK,  //1
};

//创建一个树节点（三叉链结构）
template&lt;class K, class V&gt;
struct RBTreeNode
{
	RBTreeNode&lt;K, V&gt;* _left;    //左孩子
	RBTreeNode&lt;K, V&gt;* _right;   //右孩子
	RBTreeNode&lt;K, V&gt;* _parent;  //双亲
	pair&lt;K, V&gt; _kv;             //节点的值
	Colour _col;                //放弃了AVL树的平衡因子，改用颜色标识来控制平衡

	//一个树节点的构造函数
	RBTreeNode(const pair&lt;K, V&gt;&amp;kv)
		: _left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		, _kv(kv)
		, _col(RED)    //默认一个新节点为红色
	{}
};

//创建一棵红黑树
template&lt;class K, class V&gt;
class RBTree
{
	typedef RBTreeNode&lt;K, V&gt;Node;
private:
	//根节点
	Node*_root = nullptr;
};
</code></pre> 
<h3 id="2%20-%20%E6%8F%92%E5%85%A5">2 - 插入</h3> 
<p>        红黑树可以看作是引入了颜色标识的二叉搜索树，与AVL树类似（详见<a class="link-info" href="https://blog.csdn.net/waluolandao/article/details/134122645?spm=1001.2014.3001.5501" title="【数据结构】平衡树之AVL树">【数据结构】平衡树之AVL树</a>），它插入过程也大致分为两步：</p> 
<blockquote> 
 <ol><li><strong>按照二叉搜索树的方式插入新节点</strong>：利用插入的值创建一个新的树节点。树为空，就直接将新节点赋给根节点的指针；树不为空，就按二叉搜索树的性质查找到合适的插入位置，在合适位置插入新节点。</li><li><strong>控制树的平衡</strong>：调整颜色+旋转。</li></ol> 
</blockquote> 
<pre><code class="language-cpp">	bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{
        //1.按照二叉搜索树的方式插入新节点

		if (_root == nullptr)
		{
			_root = new Node(kv);
			_root-&gt;_col = BLACK;
			return true;
		}

		Node* parent = nullptr;
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_kv.first &lt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_kv.first &gt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}
		}

		cur = new Node(kv);
		cur-&gt;_col = RED;
		if (parent-&gt;_kv.first &lt; kv.first)
		{
			parent-&gt;_right = cur;
		}
		else
		{
			parent-&gt;_left = cur;
		}

		cur-&gt;_parent = parent;

        
        //2.控制树的平衡

        //...


}</code></pre> 
<p>        因为默认一个新插入的节点为红色（原因见下文“一些迷思”），所以插入后就存在两种情况：</p> 
<blockquote> 
 <ol><li>新插入节点的双亲为黑色，则仍满足红黑树的平衡性质，无需控制平衡；</li><li>新插入节点的双亲为红色，则违背平衡性质三，需控制平衡。</li></ol> 
</blockquote> 
<p><img alt="" height="429" src="https://images2.imgbox.com/b1/46/YMQzUcKq_o.png" width="1200">        而当新插入节点的双亲为红色，该如何控制平衡呢？</p> 
<p>       插入节点的双亲一定是红色的，双亲的双亲一定是黑色的，这两个节点的颜色是始终确定的。 插入的节点为红色，插入后出现了两个连续的红色节点，此时就需要调整节点的颜色。</p> 
<p>        <strong>调整颜色既是控制树平衡的手段，也是检验是否需要旋转的途径</strong>。<strong>调整颜色的对象不是新插入的节点，而是其双亲、双亲的兄弟和双亲的双亲</strong>。</p> 
<p>        详情见下图：</p> 
<p><img alt="" height="494" src="https://images2.imgbox.com/a4/7b/xoJ9eCN1_o.png" width="1200"></p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/74/45/YXGouVpH_o.png" width="1200"></p> 
<p><img alt="" height="408" src="https://images2.imgbox.com/8b/fd/EJlua8C6_o.png" width="1200"></p> 
<blockquote> 
 <p> 【Tips】新节点插入后，平衡的控制具体取决于其双亲的兄弟节点：</p> 
 <ol><li>双亲的兄弟节点存在且为红色，调整颜色后，继续向上更新；</li><li>双亲的兄弟节点不存在，或存在且为黑色，需先旋转，然后再调整颜色。</li></ol> 
</blockquote> 
<p>（关于将特殊情景下的结论推广到一般性结论的说明，以及旋转分类讨论的图解，见下文“一些迷思”）</p> 
<blockquote> 
 <p> 【Tips】旋转的分类讨论：</p> 
 <p>        设：c为当前节点，p为其双亲节点，g为其祖父节点，u为其双亲的兄弟节点，并且cur为红色，p为红色，g为黑色，u不存在或u存在且为黑色。</p> 
 <p>1、p为g的左孩子，c为p的左孩子，则针对g做右单旋转；</p> 
 <p><img alt="" height="97" src="https://images2.imgbox.com/77/e3/ujJIkewM_o.png" width="475"></p> 
 <p>2、p为g的左孩子，c为p的右孩子，则针对p做左单旋转，再针对g做右单旋转；</p> 
 <p><img alt="" height="98" src="https://images2.imgbox.com/a9/d7/ZJ1YF65A_o.png" width="550"></p> 
 <p>3、p为g的右孩子，c为p的右孩子，则针对g做左单旋转；</p> 
 <p><img alt="" height="97" src="https://images2.imgbox.com/b7/60/SIEHibeC_o.png" width="426"></p> 
 <p>4、p为g的右孩子，c为p的左孩子，则针对p做右单旋转；</p> 
 <p><img alt="" height="99" src="https://images2.imgbox.com/02/ed/UMFG7egR_o.png" width="497"></p> 
</blockquote> 
<pre><code class="language-cpp">	bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{
        //1.按照二叉搜索树的方式插入新节点

        //...（见前文）


		
        //2.控制平衡

		while (parent &amp;&amp; parent-&gt;_col == RED)//其双亲存在且双亲为红，才需要处理
		{
			Node* grandfather = parent-&gt;_parent;
			if (parent == grandfather-&gt;_left)//parent是grandfather的左孩子
			{
				Node* uncle = grandfather-&gt;_right;//则uncle是grandfather的右孩子
				//uncle存在且为红
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					//变色
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					//继续向上处理
					cur = grandfather;
					parent = cur-&gt;_parent;
				}
				//uncle不存在，或存在且为黑
				else
				{
					if (cur == parent-&gt;_left)
					{
						//     g
						//   p
						// c
						//旋转
						RotateR(grandfather);
						//变色
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;

					}
					else
					{
						//     g
						//   p
						//		c
						//旋转
						RotateL(parent);
						RotateR(grandfather);
						//变色
						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}

					break;
				}
			}
			else //parent == grandfather-&gt;_right //parent是grandfather的右孩子
			{
				Node* uncle = grandfather-&gt;_left;//则uncle是grandfather的左孩子
				// uncle存在且为红
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					//变色
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					//继续向上处理
					cur = grandfather;
					parent = cur-&gt;_parent;
				}
				//uncle不存在，或存在且为黑
				else 
				{
					if (cur == parent-&gt;_right)
					{
						// g
						//	  p
						//       c
						//旋转
						RotateR(grandfather);
						//变色
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					else 
					{
						// g
						//	  p
						// c
						//旋转
						RotateL(parent);
						RotateR(grandfather);
						//变色
						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}

					break;
				}
			}
		}

		_root-&gt;_col = BLACK;//无论什么情况，根始终要置为黑


		return true;
	}</code></pre> 
<p>（旋转的细节详见<a class="link-info" href="https://blog.csdn.net/waluolandao/article/details/134122645?spm=1001.2014.3001.5501" title="【数据结构】平衡树之AVL树">【数据结构】平衡树之AVL树</a>） </p> 
<pre><code class="language-cpp">    //左单旋
	void RotateL(Node* parent)
	{        
		Node* cur = parent-&gt;_right;    //cur是parent的右孩子
		Node* curleft = cur-&gt;_left;    //curleft是cur的左孩子
 
        //将parent及其左子树整体旋转下来，并将parent与cur、curleft与parent、cur与ppnode一一正确链接
 	
		parent-&gt;_right = curleft;
		if (curleft)
		{
			curleft-&gt;_parent = parent;    //curleft可能为空，若为空则无需将curleft-&gt;_parent与parent链接
		}
		cur-&gt;_left = parent;
 
		//需要旋转的树，可能是一个局部的子树
        //cur可能需要跟parent的双亲节点ppnode链接
		Node* ppnode = parent-&gt;_parent;
		parent-&gt;_parent = cur;
 
		if (parent == _root /*ppnode==nullptr*/)    //旋转点在根，cur无需跟parent的双亲节点链接
		{
			_root = cur;
			cur-&gt;_parent = nullptr;
		}
		else		            //旋转点不在根，cur需要跟parent的双亲节点链接
		{
			if (ppnode-&gt;_left == parent)    //parent是ppnode的左孩子，就让cur代替其成为左孩子
			{
				ppnode-&gt;_left = cur;
			}
			else                            //parent是ppnode的右孩子，就让cur代替其成为右孩子
			{
				ppnode-&gt;_right = cur;
			}
 
			cur-&gt;_parent = ppnode;        //将cur的双亲节点置为ppnode
		} 
	}


    //右单旋
	void RotateR(Node* parent)
	{
		Node* cur = parent-&gt;_left;    //cur是parent的左孩子
		Node* curright = cur-&gt;_right; //curright是cur的右孩子
 
         //将parent及其右子树整体旋转下来，并将parent与cur、curleft与parent、cur与ppnode一一正确链接
 
        //链接curright与parent
		parent-&gt;_left = curright;
		if (curright)
		{
			curright-&gt;_parent = parent;
		}
 
        //链接cur与parent、cur与parent的双亲ppnode
		Node* ppnode = parent-&gt;_parent;
		cur-&gt;_right = parent;
		if (ppnode == nullptr)
		{
			_root = cur;
			cur-&gt;_parent = nullptr;
		}
		else
		{
			if (ppnode-&gt;_left == parent)
			{
				ppnode-&gt;_left = cur;
			}
			else
			{
				ppnode-&gt;_right = cur;
			}
 
			cur-&gt;_parent = ppnode;
		}
	}

</code></pre> 
<p></p> 
<h3 id="3%20-%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" style="background-color:transparent;">3 - 完整代码</h3> 
<pre><code class="language-cpp">#pragma once

#include&lt;iostream&gt;
using namespace std;


enum Colour
{
	RED,
	BLACK
};

template&lt;class K,class V&gt;
struct RBTreeNode
{
	RBTreeNode&lt;K, V&gt;* _left;
	RBTreeNode&lt;K, V&gt;* _right;
	RBTreeNode&lt;K, V&gt;* _parent;

	pair&lt;K, V&gt; _kv;
	Colour _col;

	RBTreeNode(const pair&lt;K, V&gt;&amp; kv)
		:_left(nullptr)
		,_right(nullptr)
		,_parent(nullptr)
		,_kv(kv)
		,_col(RED)
	{}
};

template&lt;class K, class V&gt;
struct RBTree
{
	typedef RBTreeNode&lt;K, V&gt; Node;
public:
	bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{
		if (_root == nullptr)
		{
			_root = new Node(kv);
			_root-&gt;_col = BLACK;
			return true;
		}

		Node* parent = nullptr;
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_kv.first &lt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_kv.first &gt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}
		}

		cur = new Node(kv);
		cur-&gt;_col = RED;
		if (parent-&gt;_kv.first &lt; kv.first)
		{
			parent-&gt;_right = cur;
		}
		else
		{
			parent-&gt;_left = cur;
		}

		cur-&gt;_parent = parent;

    	//红黑树插入的关键是uncle
    	//1、uncle存在且为红，则变色+继续向上更新
    	//2、uncle不存在，或uncle存在且为黑，则旋转+变色
		
		while (parent &amp;&amp; parent-&gt;_col == RED)
		{
			Node* grandfather = parent-&gt;_parent;
			if (parent == grandfather-&gt;_left)
			{
				Node* uncle = grandfather-&gt;_right;
				//uncle存在且为红
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					//变色
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					//继续向上处理
					cur = grandfather;
					parent = cur-&gt;_parent;
				}
				//uncle不存在，或存在且为黑
				else
				{
					if (cur == parent-&gt;_left)
					{
						//     g
						//   p
						// c
						RotateR(grandfather);
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;

					}
					else
					{
						//     g
						//   p
						//		c
						RotateL(parent);
						RotateR(grandfather);

						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}

					break;
				}
			}
			else // parent == grandfather-&gt;_right
			{
				Node* uncle = grandfather-&gt;_left;
				// uncle存在且为红
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					//变色
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					//继续向上处理
					cur = grandfather;
					parent = cur-&gt;_parent;
				}
				//uncle不存在，或存在且为黑
				else 
				{
					if (cur == parent-&gt;_right)
					{
						// g
						//	  p
						//       c
						//旋转+变色
						RotateR(grandfather);

						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					else 
					{
						// g
						//	  p
						// c
						//旋转+变色
						RotateL(parent);
						RotateR(grandfather);

						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}

					break;
				}
			}
		}

		_root-&gt;_col = BLACK;


		return true;
	}

	//左单旋
	void RotateL(Node* parent)
	{
		++_rotateCount;

		Node* cur = parent-&gt;_right;
		Node* curleft = cur-&gt;_left;

		parent-&gt;_right = curleft;
		if (curleft)
		{
			curleft-&gt;_parent = parent;
		}

		cur-&gt;_left = parent;

		Node* ppnode = parent-&gt;_parent;

		parent-&gt;_parent = cur;


		if (parent == _root)
		{
			_root = cur;
			cur-&gt;_parent = nullptr;
		}
		else
		{
			if (ppnode-&gt;_left == parent)
			{
				ppnode-&gt;_left = cur;
			}
			else
			{
				ppnode-&gt;_right = cur;

			}

			cur-&gt;_parent = ppnode;
		}
	}
    //右单旋
	void RotateR(Node* parent)
	{
		++_rotateCount;

		Node* cur = parent-&gt;_left;
		Node* curright = cur-&gt;_right;

		parent-&gt;_left = curright;
		if (curright)
			curright-&gt;_parent = parent;

		Node* ppnode = parent-&gt;_parent;
		cur-&gt;_right = parent;
		parent-&gt;_parent = cur;

		if (ppnode == nullptr)
		{
			_root = cur;
			cur-&gt;_parent = nullptr;
		}
		else
		{
			if (ppnode-&gt;_left == parent)
			{
				ppnode-&gt;_left = cur;
			}
			else
			{
				ppnode-&gt;_right = cur;
			}

			cur-&gt;_parent = ppnode;
		}
	}


    //验树的平衡
	bool CheckColourNum(Node* root, int blackNum,int benchmark)//递归查询连续的红色节点和验证黑色节点数量
	{
		if (root == nullptr)
		{
			if (blackNum != benchmark)//若某一条路径上的黑色节点数量与基准值不符，则说明树不平衡（无论基准值本身是否正确）
			{
				return false;
			}
			return true;
		}
			
        //递归记录某一条路径上的黑色节点数量
		if (root-&gt;_col == BLACK)
		{
			++blackNum;
		}

        //出现两个连续的红色节点，则说明树不平衡
		if (root-&gt;_col == RED &amp;&amp; root-&gt;_parent &amp;&amp; root-&gt;_parent-&gt;_col == RED)
		{
			cout &lt;&lt; root-&gt;_kv.first &lt;&lt; "RED show up" &lt;&lt; endl;
			return false;
		}
        
        //递归至左子树和右子树里去验证平衡
		return CheckColourNum(root-&gt;_left,blackNum,benchmark)
			&amp;&amp; CheckColourNum(root-&gt;_right, blackNum, benchmark);
	}
	bool IsBalance()//封装一次“bool IsBalance(Node* root)”
	{
		return IsBalance(_root);
	}
	bool IsBalance(Node* root)//验树的平衡
	{
        //空树是平衡的
		if (root == nullptr)
			return true;

        //根节点不是黑色的，则说明树不平衡				
		if (root-&gt;_col != BLACK)
		{
			return false;
		}

		//取最左路径上的黑色节点数量作为基准值
		Node* cur = _root;
		int benchmark = 0;
		while (cur)
		{
			if (cur-&gt;_col == BLACK)
			{
				++benchmark;
			}
			cur = cur-&gt;_left;
		}
        //查询连续的红色节点和验证黑色节点数量
		return CheckColourNum(root,0,benchmark);//参数：根节点，当前路径的黑节点数量，黑节点数量的基准值
	}

	//求树的高度
	int Height()
	{
		return Height(_root);
	}
	int Height(Node* root)
	{
		if (root == nullptr)
			return 0;

		int leftHeight = Height(root-&gt;_left);
		int rightHeight = Height(root-&gt;_right);

		return leftHeight &gt; rightHeight ? leftHeight + 1 : rightHeight + 1;
	}

private:
	Node* _root = nullptr;
};</code></pre> 
<p></p> 
<h2 id="%E8%A1%A5%E3%80%81%E4%B8%80%E4%BA%9B%E8%BF%B7%E6%80%9D">补、一些迷思</h2> 
<p></p> 
<h3 id="1.%E6%8E%A7%E5%88%B6%E8%8A%82%E7%82%B9%E7%9A%84%E7%BA%A2%E5%92%8C%E9%BB%91%EF%BC%8C%E6%80%8E%E4%B9%88%E5%B0%B1%E5%81%9A%E5%88%B0%E4%BA%86%E2%80%9C%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E4%B8%8D%E8%B6%85%E8%BF%87%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%842%E5%80%8D%E2%80%9D%EF%BC%9F">1.控制节点的红和黑，怎么就做到了“<strong>最长路径不超过最短路径的2倍</strong>”？</h3> 
<p>        如下图，是一棵满足“最长路径不超过最短路径的2倍”的合法红黑树，它的最长路径为4（例如13-&gt;17-&gt;25-&gt;22），最短路径为3（例如13-&gt;8-&gt;1）。</p> 
<p><img alt="" height="558" src="https://images2.imgbox.com/dc/ee/Vqm9zpQA_o.png" width="1170"></p> 
<p>         同样的，下图中是一种极端情况下的红黑树，但它仍是合法的。它的最长路径为4（例如13-&gt;17-&gt;25-&gt;22），最短路径为2（例如13-&gt;8）。</p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/f8/f1/xfdYjrII_o.png" width="1200"></p> 
<p>        由此可见，控制节点的红和黑，保证最短路径全黑、最长路径是一黑一红相间的（或每条路径上黑色节点的总数占整棵树节点总数的1/2），就满足了“最长路径不超过最短路径的2倍”。</p> 
<p></p> 
<h3 id="2.%E7%94%B1%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%EF%BC%8C%E6%9D%A5%E8%AF%B4%E6%98%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E5%BC%83%E7%BB%9D%E5%AF%B9%E5%B9%B3%E8%A1%A1">2.由红黑树与AVL树的性能比较，来说明为什么放弃绝对平衡</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>平衡树</td><td>特点</td><td>查找效率大致为</td><td>创建一棵树的数据量</td><td>创建后树的高度</td><td>所需时间约为</td></tr><tr><td>AVL树</td><td>高度差的绝对值不超过1</td><td>O(logN)</td><td>1000个值</td><td>10</td><td>0.000001s</td></tr><tr><td>红黑树</td><td>最长路径不超过最短路径的2倍</td><td>O(2*logN)</td><td>1000个值</td><td>20</td><td>0.000002s</td></tr></tbody></table> 
<p>        对于红黑树与AVL树，两者的性能在同一量级上，效率差距并不大，虽然在维护平衡时均需旋转，但AVL树因控制平衡更加严格，需在插入和删除时频繁通过旋转维护其结构，会付出较大的代价，故红黑树整体优于AVL树。</p> 
<p></p> 
<h3 id="3.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B0%E5%88%9B%E5%BB%BA%E7%9A%84%E8%8A%82%E7%82%B9%2F%E6%96%B0%E6%8F%92%E5%85%A5%E7%9A%84%E8%8A%82%E7%82%B9%E9%BB%98%E8%AE%A4%E4%B8%BA%E7%BA%A2%E8%89%B2%EF%BC%9F">3.为什么新创建的节点/新插入的节点默认为红色？</h3> 
<p>        当插入的节点为黑色，此时在所插入的路径上，黑色节点的数量比其他路径上多1，就违背了红黑树的性质四（对于任意一条从空节点通往根节点的路径，每条路径上黑色节点数量均相同）。</p> 
<p>        当插入的节点为红色，若此时所插入位置的双亲为红色，即出现了连续的红色节点，就违背了红黑树的性质三（任意路径上没有连续的红色节点）。</p> 
<p>        也就是说，插入的节点无论是什么颜色的，都会对红黑树的平衡有潜在的影响。</p> 
<p>        不过具体而言，若插入的节点为黑色，则是“一定会因违背性质四而破坏平衡”，此时是必须对红黑树进行调整的，且要对多条路径进行调整；而插入的节点为红色，则是“可能会因性质三而破坏平衡”，此时既可能要进行调整，也可能不进行调整，且调整时仅对一条路径进行调整。</p> 
<p>        基于这样的利弊，插入节点为红色时维护平衡的代价在理论上更小，故使插入的新节点/新创建的节点默认为红色。</p> 
<p><img alt="" height="915" src="https://images2.imgbox.com/ba/65/L2ThzK5c_o.png" width="1200"></p> 
<p><img alt="" height="978" src="https://images2.imgbox.com/e6/60/maepLF1N_o.png" width="1200"></p> 
<p></p> 
<h3 id="4.%E5%AF%B9%E4%B8%A4%E7%A7%8D%E9%9C%80%E6%8E%A7%E5%88%B6%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%83%85%E6%99%AF%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%AF%B4%E6%98%8E" style="background-color:transparent;">4.对两种需控制平衡的情景的更多说明</h3> 
<p>        设：cur为当前节点，p为其双亲节点，g为其祖父节点，u为其双亲的兄弟节点。</p> 
<p>        <strong>情景一</strong>：cur为红，p为红，g为黑，u存在且为红。cur和p均为红，违背了性质三。解决方法为，将p,u改为黑，g改为红，然后把g当成cur，继续向上调整。</p> 
<p><img alt="" height="932" src="https://images2.imgbox.com/48/fa/Z88azuKL_o.png" width="978"></p> 
<p>        当a/b/c/d/e为空树，cur是新插入的节点，情况较为简单，上述解决方法是适用的。 </p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/42/d5/6wJXrgNW_o.png" width="858"></p> 
<p>        而当a/b/c/d/e不为空树，cur不是新插入的节点，尽管情况较为复杂，但上述解决方法仍适用。</p> 
<p><img alt="" height="506" src="https://images2.imgbox.com/5e/31/ZIqCOnum_o.png" width="1200"></p> 
<p>        更复杂的情况又例如，c/d/e是每条路径都有两个黑色节点的子树...</p> 
<p><img alt="" height="572" src="https://images2.imgbox.com/87/d0/RCpouGJO_o.png" width="1200"></p> 
<p></p> 
<p>       <strong> 情景二</strong>：cur为红，p为红，g为黑，u不存在/u存在且为黑。 </p> 
<p>        u不存在，做旋转的处理。</p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/53/7a/GmdPRlud_o.png" width="1200"></p> 
<p>        u存在且为黑，做旋转和变色的处理。</p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/51/b4/zh72HWAn_o.png" width="1200"></p> 
<blockquote> 
 <p>【Tips】旋转的分类讨论：</p> 
 <p>1、p为g的左孩子，cur为p的左孩子，则针对g做右单旋转；</p> 
 <p><img alt="" height="97" src="https://images2.imgbox.com/3f/41/zdujZBoK_o.png" width="475"></p> 
 <p>2、p为g的左孩子，cur为p的右孩子，则针对p做左单旋转，再针对g做右单旋转；</p> 
 <p><img alt="" height="98" src="https://images2.imgbox.com/ae/d4/fvhsGxnY_o.png" width="550"></p> 
 <p>3、p为g的右孩子，cur为p的右孩子，则针对g做左单旋转；</p> 
 <p><img alt="" height="97" src="https://images2.imgbox.com/9d/51/Q1xzO74U_o.png" width="426"></p> 
 <p>4、p为g的右孩子，cur为p的左孩子，则针对p做右单旋转；</p> 
 <p><img alt="" height="99" src="https://images2.imgbox.com/95/92/KuUmE9Pb_o.png" width="497"></p> 
</blockquote> 
<p> </p> 
<h3 id="5.%E6%8F%92%E5%85%A5%E6%9E%84%E5%BB%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3" style="background-color:transparent;">5.插入构建红黑树的过程图解</h3> 
<p><strong>        升序构建红黑树</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/39/2f/tmc3iTgg_o.gif"></strong></p> 
<p><strong>        降序构建红黑树</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/16/83/H0CWN9Sd_o.gif"></strong></p> 
<p><strong>        随机插入构建红黑树 </strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6f/ac/GzEJXWFo_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/76e63c9232313eb258aa9605bb1d9e49/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Dev C&#43;&#43;使用简明教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4f7f15f33a5930a7cb9601367b91f756/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【深度学习】浅浅记录卸载旧版本anaconda&#43;安装pytorch环境&#43;跑通YOLOv5源代码所遇到的一系列问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>