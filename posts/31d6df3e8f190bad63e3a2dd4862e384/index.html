<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OkHttp3-使用详解-OkHttpClient - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OkHttp3-使用详解-OkHttpClient" />
<meta property="og:description" content="首先附上官网地址：http://square.github.io/okhttp/3.x/okhttp/(点击传送官网，如果进不去，请自行翻墙)
翻译官网：
public class OkHttpClient extends Object implements Cloneable, Call.Factory, WebSocket.Factory Factory for calls, which can be used to send HTTP requests and read their responses.
Call.Factory可以发送一个HTTP请求和读取返回的响应。
OkHttpClients should be shared
OkHttpClient应该被共享。
OkHttp performs best when you create a single OkHttpClient instance and reuse it for all of your HTTP calls. This is because each client holds its own connection pool and thread pools. Reusing connections and threads reduces latency and saves memory." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/31d6df3e8f190bad63e3a2dd4862e384/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-07T14:45:23+08:00" />
<meta property="article:modified_time" content="2019-01-07T14:45:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OkHttp3-使用详解-OkHttpClient</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>首先附上官网地址：<a href="http://square.github.io/okhttp/3.x/okhttp/" rel="nofollow">http://square.github.io/okhttp/3.x/okhttp/</a>(点击传送官网，如果进不去，请自行翻墙)<br> 翻译官网：</p> 
<pre><code>public class OkHttpClient
extends Object
implements Cloneable, Call.Factory, WebSocket.Factory
</code></pre> 
<p>Factory for calls, which can be used to send HTTP requests and read their responses.<br> Call.Factory可以发送一个HTTP请求和读取返回的响应。<br> OkHttpClients should be shared<br> OkHttpClient应该被共享。<br> OkHttp performs best when you create a single OkHttpClient instance and reuse it for all of your HTTP calls. This is because each client holds its own connection pool and thread pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a client for each request wastes resources on idle pools.<br> OkHttp最好的使用时创建一个单列的OkHttpClient 和重复使用它为你应用中的所有的请求。<br> 这是因为不同的客户端持有自己的连接池和线程池。重使用连接和线程可以减少延迟和节省内存。相对地，在空闲池中为每一个请求创建一个客户端是浪费资源的。<br> Use new OkHttpClient() to create a shared instance with the default settings:<br> 使用 new OkHttpClient()创建一个默认设置共享的实例</p> 
<pre><code> public final OkHttpClient client = new OkHttpClient();
</code></pre> 
<p>Or use new OkHttpClient.Builder() to create a shared instance with custom settings:<br> 或者是使用new OkHttpClient.Builder()创建一个自定义设置的实例。</p> 
<pre><code> // The singleton HTTP client.
   public final OkHttpClient client = new OkHttpClient.Builder()
       .addInterceptor(new HttpLoggingInterceptor())
       .cache(new Cache(cacheDir, cacheSize))
       .build();
</code></pre> 
<p>Customize your client with newBuilder()<br> 使用newBuilder()定制自己的client<br> You can customize a shared OkHttpClient instance with newBuilder(). This builds a client that shares the same connection pool, thread pools, and configuration. Use the builder methods to configure the derived client for a specific purpose.<br> 你可以使用newBuilder()共享一个OkHttpClient实例，这将建立一个具有相同的 connection pool, thread pools, 和configuration的客户端。使用builder方法去配置一个具有特殊目的的client。<br> This example shows a call with a short 500 millisecond timeout:<br> 这个例子展示了一个500毫秒的超时</p> 
<pre><code>  OkHttpClient eagerClient = client.newBuilder()
       .readTimeout(500, TimeUnit.MILLISECONDS)
       .build();
   Response response = eagerClient.newCall(request).execute();
</code></pre> 
<p>Shutdown isn’t necessary<br> Shutdown不是必须的。<br> The threads and connections that are held will be released automatically if they remain idle. But if you are writing a application that needs to aggressively release unused resources you may do so.<br> 这些线程和连接持有将被自动地释放，如果他们保持空闲。但是如果你需要一个主动地释放不使用的资源，那你需要这样做。<br> Shutdown the dispatcher’s executor service with shutdown(). This will also cause future calls to the client to be rejected.<br> 关闭dispatcher’s executor service使用shutdown()。这也会导致将来对客户端的调用被拒绝。</p> 
<p>client.dispatcher().executorService().shutdown();</p> 
<p>Clear the connection pool with evictAll(). Note that the connection pool’s daemon thread may not exit immediately.<br> 清除连接池使用evictAll().注意这个连接池的守护线程不会立马退出。</p> 
<pre><code> client.connectionPool().evictAll();
</code></pre> 
<p>If your client has a cache, call close(). Note that it is an error to create calls against a cache that is closed, and doing so will cause the call to crash.</p> 
<p>如果你的client有cache，使用close().注意这里有一个错误，创建一个calls去反对它的关闭将会引起crash。</p> 
<pre><code> client.cache().close();
</code></pre> 
<p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they remain idle.</p> 
<p>OkHttp也使用守护线程去HTTP/2 连接。如果他们保持空闲这个将会自动退出。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dbe55af9d2506388c41dd8e13fe363bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">cgpwn2 writeup</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e0817a039882aebbaa735b4880479e60/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">着色器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>