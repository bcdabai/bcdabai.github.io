<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C - 结构体内存分配 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C - 结构体内存分配" />
<meta property="og:description" content="最近又捡起了C语言，遇到了大量对结构体操作的业务，在操作期间，发现对结构体在内存中的分配仍然存有一定的疑问。，经过学习，特把有关结构体内存分配的相关知识记录下来。
内存对齐：要了解结构体的内存分配，首先需要了解内存对齐的概念。之所以会有内存对齐的概念，是因为，在操作系统中，数据的存放时按照字节存放的，而结构体又不像数组，结构体中可以存放不同类型的数据，它的大小也不是简单的各个数据成员大小之和，限于读取内存的要求，而是每个成员在内存中的存储都要按照一定偏移量来存储，根据类型的不同，每个成员都要按照一定的对齐数进行对齐存储，最后整个结构体的大小也要按照一定的对齐数进行对齐。关于具体的概念以及为什么要采用内存对齐的方式可以参考博文：https://blog.csdn.net/Misszhoudandan/article/details/81570548。
下面就结合具体的例子来描述结构体的内存空间是怎么分配的：
1、请看下面的结构体： struct MsgTest { char a; int b; }; MsgTest占多少个字节呢？刚开始我以为是5字节（char 1字节&#43;int 4字节），但实际上是8字节，请看下图：
由上图可以看出，char类型的元素a的起始地址为0x43fd50，而int型元素b的起始地址为0x43fd54，也就是说，系统为元素a总共分配了4个字节的内存（虽然a本身只占用了一个字节长度的内存），剩下的3字节长度的内存就是基于内存对齐的概念进行填充的，不计入操作。
2、接下来看如下的结构体： struct MsgTest { char a; char b; int c; }; 按照上节讲述的原则，那这个结构体所占的内存应该是12字节，但实际上他占了多少个字节呢？请看下图：
这个结构体也是占了8字节。为什么会这样呢，那是因为基于内存对齐的概念，每一个元素应该是按照4字节的标准进行补齐，但是元素a和元素b各占1字节，所以还剩下2字节需要补齐，右上图也可以看出，元素a和元素b的内存只相差了一个字节。实际上，在该结构体中即使是如下样式：
struct MsgTest { char a; char b; char c; char d; int e; }; 它所占的内存仍然是8个字节：
3、下面是一些其他格式的结构体： 1）： 2）： 在该结构体中，a占了4字节，b占了40字节（16进制为28）,c占了4字节，d占了8字节，e占了8字节。
3）： 可以看一下如下的题目，各位可以先算一下占多少个字节：
需要注意的是，对char*类型的元素，在内存中存放的其实是它的地址（占4字节），_int64类型的占8字节，unsigned其实是unsigned int的简写，也占了4字节。
参看答案如下所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/28dc92dee337a6cf96015141cdbaf702/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-07T14:41:39+08:00" />
<meta property="article:modified_time" content="2018-11-07T14:41:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C - 结构体内存分配</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-indent:50px;">最近又捡起了C语言，遇到了大量对结构体操作的业务，在操作期间，发现对结构体在内存中的分配仍然存有一定的疑问。，经过学习，特把有关结构体内存分配的相关知识记录下来。</p> 
<p style="text-indent:50px;"><span style="color:#f33b45;"><strong>内存对齐</strong></span>：要了解结构体的内存分配，首先需要了解内存对齐的概念。之所以会有内存对齐的概念，是因为，在操作系统中，数据的存放时按照字节存放的，而结构体又不像数组，结构体中可以存放不同类型的数据，它的大小也不是简单的各个数据成员大小之和，限于读取内存的要求，而是每个成员在内存中的存储都要按照一定偏移量来存储，根据类型的不同，每个成员都要按照一定的对齐数进行对齐存储，最后整个结构体的大小也要按照一定的对齐数进行对齐。关于具体的概念以及为什么要采用内存对齐的方式可以参考博文：<a href="https://blog.csdn.net/Misszhoudandan/article/details/81570548">https://blog.csdn.net/Misszhoudandan/article/details/81570548</a>。</p> 
<p style="text-indent:50px;">下面就结合具体的例子来描述结构体的内存空间是怎么分配的：</p> 
<h2>1、请看下面的结构体：</h2> 
<pre class="has"><code class="language-cpp">struct MsgTest
{
	char a;
	int b;
};</code></pre> 
<p style="text-indent:50px;">MsgTest占多少个字节呢？刚开始我以为是5字节（char 1字节+int 4字节），但实际上是8字节，请看下图：</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="130" src="https://images2.imgbox.com/75/be/VfH0vKXh_o.png" width="801"></p> 
<p style="text-indent:50px;">由上图可以看出，char类型的元素a的起始地址为0x43fd50，而int型元素b的起始地址为0x43fd54，也就是说，系统为元素a总共分配了4个字节的内存（<span style="color:#f33b45;"><strong>虽然a本身只占用了一个字节长度的内存</strong></span>），剩下的3字节长度的内存就是基于<strong>内存对齐</strong>的概念进行填充的，不计入操作。</p> 
<h2>2、接下来看如下的结构体：</h2> 
<pre class="has"><code class="language-cpp">struct MsgTest
{
	char a;
	char b;
	int c;
};</code></pre> 
<p style="text-indent:50px;">按照上节讲述的原则，那这个结构体所占的内存应该是12字节，但实际上他占了多少个字节呢？请看下图：</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="147" src="https://images2.imgbox.com/74/5e/fw2Z64iL_o.png" width="295"></p> 
<p style="text-indent:50px;">这个结构体也是占了8字节。为什么会这样呢，那是因为基于内存对齐的概念，每一个元素应该是按照4字节的标准进行补齐，但是元素a和元素b各占1字节，所以还剩下2字节需要补齐，右上图也可以看出，元素a和元素b的内存只相差了一个字节。实际上，在该结构体中即使是如下样式：</p> 
<pre class="has"><code class="language-cpp">struct MsgTest
{
    char a;
    char b;
    char c;
    char d;
    int e;
};</code></pre> 
<p style="text-indent:50px;">它所占的内存仍然是8个字节：</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="188" src="https://images2.imgbox.com/37/a0/Tnwd4KFf_o.png" width="219"></p> 
<h2>3、下面是一些其他格式的结构体：</h2> 
<h3>1）：</h3> 
<p style="text-indent:0;"><img alt="" class="has" height="196" src="https://images2.imgbox.com/fe/c5/IO0sJe8r_o.png" width="152"><img alt="" class="has" height="190" src="https://images2.imgbox.com/8a/3a/rajq0fOl_o.png" width="228"></p> 
<h3>2）：</h3> 
<p><img alt="" class="has" height="193" src="https://images2.imgbox.com/be/82/oLgnmpvo_o.png" width="160"><img alt="" class="has" height="190" src="https://images2.imgbox.com/b4/06/AEPv2oHf_o.png" width="222"></p> 
<p style="text-indent:50px;">在该结构体中，a占了4字节，b占了40字节（16进制为28）,c占了4字节，d占了8字节，e占了8字节。</p> 
<h3>3）：</h3> 
<p style="text-indent:50px;">可以看一下如下的题目，各位可以先算一下占多少个字节：</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="503" src="https://images2.imgbox.com/4f/28/0u6D3Fms_o.png" width="293"></p> 
<p style="text-indent:50px;">需要注意的是，对char*类型的元素，在内存中存放的其实是它的地址（占4字节），_int64类型的占8字节，unsigned其实是unsigned int的简写，也占了4字节。</p> 
<p style="text-indent:50px;">参看答案如下所示：</p> 
<p style="text-indent:50px;"><img alt="" class="has" src="https://images2.imgbox.com/59/ee/9zMYyiXw_o.png"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/879bbaa7cbcedb8fdaabe5c6563ff28d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">String[]与List&lt;String&gt;的区别及相互转换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b65a9185710a5483e1adc27d888064bd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">matplotlib绘图，设置坐标格式，比如科学计数法、公式表示等</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>