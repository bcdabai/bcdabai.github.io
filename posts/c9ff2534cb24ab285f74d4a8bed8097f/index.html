<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MFC-线程同步 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MFC-线程同步" />
<meta property="og:description" content="线程同步有四种方法.
两个简单的线程函数例子:
UINT Thread1(LPVOID lParam) { for (int i = 0; i &lt; 10000000;i&#43;&#43;) { sum&#43;&#43;; } SetDlgItemInt(AfxGetApp()-&gt;m_pMainWnd-&gt;m_hWnd, IDC_STATIC,sum,TRUE); return 0; } UINT Thread2(LPVOID lParam) { for (int i = 0; i &lt; 10000000; i&#43;&#43;) { sum&#43;&#43;; } SetDlgItemInt(AfxGetApp()-&gt;m_pMainWnd-&gt;m_hWnd, IDC_STATIC, sum, TRUE); return 0; } 方法一:使用临界区对象(CCriticalSection类) 1.在构造函数中创建一个临界区对象
g_critical_section = new CCriticalSection(); 2.分别给两个(或多个)线程加锁
for (int i = 0; i &lt; 10000000;i&#43;&#43;) { //加锁 g_critical_section-&gt;Lock(); sum&#43;&#43;; //当操作共享数据时为了防止同时被操作导致结果错误, //所以要加锁,这个时候其它线程就不能对这个加锁的数据进程操作,需要等到这个数据解锁才能进程操作 //解锁 g_critical_section-&gt;Unlock(); } 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c9ff2534cb24ab285f74d4a8bed8097f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-04-02T16:31:14+08:00" />
<meta property="article:modified_time" content="2016-04-02T16:31:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MFC-线程同步</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>线程同步有四种方法.</p> 
<p>两个简单的线程函数例子:</p> 
<pre class="prettyprint"><code class=" hljs lasso">UINT Thread1(LPVOID lParam)
{
    for (int i <span class="hljs-subst">=</span> <span class="hljs-number">0</span>; i <span class="hljs-subst">&lt;</span> <span class="hljs-number">10000000</span>;i<span class="hljs-subst">++</span>)
    {
      <span class="hljs-keyword">sum</span><span class="hljs-subst">++</span>;
    }
    SetDlgItemInt(AfxGetApp()<span class="hljs-subst">-&gt;</span>m_pMainWnd<span class="hljs-subst">-&gt;</span>m_hWnd, IDC_STATIC,<span class="hljs-keyword">sum</span>,<span class="hljs-literal">TRUE</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
UINT Thread2(LPVOID lParam)
{
    for (int i <span class="hljs-subst">=</span> <span class="hljs-number">0</span>; i <span class="hljs-subst">&lt;</span> <span class="hljs-number">10000000</span>; i<span class="hljs-subst">++</span>)
    {
        <span class="hljs-keyword">sum</span><span class="hljs-subst">++</span>;
    }
    SetDlgItemInt(AfxGetApp()<span class="hljs-subst">-&gt;</span>m_pMainWnd<span class="hljs-subst">-&gt;</span>m_hWnd, IDC_STATIC, <span class="hljs-keyword">sum</span>, <span class="hljs-literal">TRUE</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>方法一:使用临界区对象(CCriticalSection类) <br> 1.在构造函数中创建一个临界区对象</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">g_critical_section </span>=<span class="hljs-string"> new CCriticalSection();</span></code></pre> 
<p>2.分别给两个(或多个)线程加锁</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>;i++)
    {
        <span class="hljs-comment">//加锁</span>
        g_critical_section-&gt;Lock();
        <span class="hljs-keyword">sum</span>++; <span class="hljs-comment">//当操作共享数据时为了防止同时被操作导致结果错误,</span>
               <span class="hljs-comment">//所以要加锁,这个时候其它线程就不能对这个加锁的数据进程操作,需要等到这个数据解锁才能进程操作</span>
        <span class="hljs-comment">//解锁</span>
        g_critical_section-&gt;Unlock();
    }
</code></pre> 
<p>3.在析构函数中释放临界区对象</p> 
<pre class="prettyprint"><code class=" hljs sql">    <span class="hljs-operator"><span class="hljs-keyword">delete</span> g_critical_section;</span>
    g_critical_section = nullptr;</code></pre> 
<p>这个同步方法相对于其它三种方法是最快的</p> 
<p>方法二:使用互斥对象(CMutex类)</p> 
<p>1.在构造函数中创建互斥对象</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">g_mutex </span>=<span class="hljs-string"> new CMutex();</span></code></pre> 
<p>2.分别给两个(或多个)线程加锁</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-comment">//利用互斥对象作为参数,创建一个信号锁</span>
    CSingleLock singlelock(g_mutex);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++)
    {
        <span class="hljs-comment">//加锁</span>
        singlelock.Lock();
        <span class="hljs-comment">//可能加锁失败,要判断是否加锁成功</span>
        <span class="hljs-keyword">if</span> (singlelock.IsLocked())
        {
            <span class="hljs-keyword">sum</span>++; <span class="hljs-comment">//当操作共享数据时为了防止同时被操作导致结果错误,</span>
                   <span class="hljs-comment">//所以要加锁,这个时候其它线程就不能对这个加锁的数据进程操作,需要等到这个数据解锁才能进程操作</span>
                   <span class="hljs-comment">//解锁</span>
            singlelock.Unlock();
        }

    }</code></pre> 
<p>3.在析构函数中释放互斥对象</p> 
<pre class="prettyprint"><code class=" hljs sql">    <span class="hljs-operator"><span class="hljs-keyword">delete</span> g_mutex;</span>
    g_mutex = nullptr;</code></pre> 
<p>这个方法比方法一慢了许多</p> 
<p>方法三:使用信号量对象(CSemaphore类)</p> 
<p>信号量是CSemaphore的对象，该对象的作用是对访问某个共享资源的线程的数目进行控制。 <br> CSemaphore类的构造函数原型如下：</p> 
<pre class="prettyprint"><code class=" hljs cs">CSemaphore( 
    LONG lInitialCount <span class="hljs-comment">/* = 1 */</span>,    <span class="hljs-comment">//计数器的初始值 </span>
    LONG lMaxCount <span class="hljs-comment">/* = 1 */</span>,        <span class="hljs-comment">//计数器的最大计数值 </span>
    LPCTSTR pstrName<span class="hljs-comment">/* =NULL */</span>,        <span class="hljs-comment">//信号的名称 </span>
    LPSECURITY_ATTRIBUTES lpsaAttributes <span class="hljs-comment">/* = NULL */</span>    <span class="hljs-comment">//指向一个SECURITY_ATTRIBUTES结构的指针 </span>
) </code></pre> 
<p>1.在构造函数中创建信号量对象</p> 
<pre class="prettyprint"><code class=" hljs cs">    <span class="hljs-comment">//因为这个例子只有2个线程,所以计数器只要一个就行</span>
    g_semaphore = <span class="hljs-keyword">new</span> CSemaphore(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);</code></pre> 
<p>2.分别给两个(或多个)线程加锁</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-comment">//利用信号量对象作为参数,创建一个信号锁</span>
    CSingleLock singlelock(g_semaphore);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++)
    {
        <span class="hljs-comment">//加锁</span>
        singlelock.Lock();
        <span class="hljs-comment">//可能加锁失败,要判断是否加锁成功</span>
        <span class="hljs-keyword">if</span> (singlelock.IsLocked())
        {
            <span class="hljs-keyword">sum</span>++; <span class="hljs-comment">//当操作共享数据时为了防止同时被操作导致结果错误,</span>
                   <span class="hljs-comment">//所以要加锁,这个时候其它线程就不能对这个加锁的数据进程操作,需要等到这个数据解锁才能进程操作</span>
                   <span class="hljs-comment">//解锁</span>
            singlelock.Unlock();
        }

    }</code></pre> 
<p>3.在析构函数中释放信号量对象</p> 
<pre class="prettyprint"><code class=" hljs sql">    <span class="hljs-operator"><span class="hljs-keyword">delete</span> g_semaphore;</span>
    g_semaphore = nullptr;</code></pre> 
<p>方法4:使用事件对象(CEvent类)</p> 
<p>1.在构造函数创建事件对象</p> 
<pre class="prettyprint"><code class=" hljs php">g_event = <span class="hljs-keyword">new</span> CEvent(<span class="hljs-keyword">TRUE</span>);</code></pre> 
<p>2.分别给两个(或多个)线程加锁</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-comment">//利用事件对象作为参数,创建一个信号锁</span>
    CSingleLock singlelock(g_event);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++)
    {
        <span class="hljs-comment">//加锁</span>
        singlelock.Lock();
        <span class="hljs-comment">//可能加锁失败,要判断是否加锁成功</span>
        <span class="hljs-keyword">if</span> (singlelock.IsLocked())
        {
            <span class="hljs-keyword">sum</span>++; <span class="hljs-comment">//当操作共享数据时为了防止同时被操作导致结果错误,</span>
                   <span class="hljs-comment">//所以要加锁,这个时候其它线程就不能对这个加锁的数据进程操作,需要等到这个数据解锁才能进程操作</span>
                   <span class="hljs-comment">//解锁</span>
            singlelock.Unlock();
            g_event-&gt;SetEvent();<span class="hljs-comment">//必须要告诉其它线程本线程已经解锁,你可以加锁了</span>
        }

    }</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/14d6df337c14e13addc6f22440e66085/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Build2016两场Keynote的干货汇总</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/967f0c7798b58f65559889df743139d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Socket编程-1V1聊天</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>