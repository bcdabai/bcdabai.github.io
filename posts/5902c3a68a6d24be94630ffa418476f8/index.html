<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python文件编译与pyc反编译 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python文件编译与pyc反编译" />
<meta property="og:description" content="pyc是编译py之后生成的二进制文件。当我们发布系统的时候不想让别人看到源代码，就需要将py文件编译生成pyc文件，对外只提供pyc文件。同样，如果拿到一个python程序，只有pyc文件，我们就无法看到源码，希望有办法反编译pyc文件以获得源码。
既然有反编译的需求，为了保护pyc文件不被反编译，我们又希望找到一个方法来防止pyc文件被反编译。
本文介绍了如何将py文件编译成pyc和pyo文件，也介绍了如何反编译pyc文件， 又给出了一种字节码混淆方法来防止pyc文件被反编译。
1 编译py文件到pyc和pyo pyc是编译py之后生成的二进制文件，由python虚拟机来执行的。当我们发布系统的时候不想让别人看到源代码，就需要将py文件编译生成pyc文件，对外只提供pyc文件。
同时，在模块被加载时，.pyc文件比.py文件更快
但是pyc的内容跟python的版本相关，不同的版本编译后的pyc文件不同，2.5编译的pyc文件不能到3.5上执行.
发布python软件的过程为：
1. 生产pyc文件: python -m compileall . 2. 删除py文件: find . -name “*.py” |xargs rm -rf 3. 删除pycache目录: find . -name “pycache” |xargs rm -rf
1.1 Python2 编译 命令：
python -m py_compile file.py
python -m py_compile {file1,file2}.py
编译完成后，生成的 .pyc文件在当前目录。
可以使用-O或者-OO转换python命令来减少编译模块的大小
-O转换会帮你去掉assert语句
-OO转换会帮你去掉assert语句和__doc__文档字符串
由于一些程序可能依赖于assert语句或文档字符串，应该在确认需要的情况下使用这些选项。
例如 python –O -m py_compile file.py 会在本目录生成 file.pyo
1.2 python3 编译 Python3的编译和python2一样，只是在python3之后编译后的文件在pycache目录下，而不是与源文件同一目录。
那么如何让python3实现生成的pyc与源代码在同一目录呢？可以加上-b参数，例如
Python3 -m py_compile -b file." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5902c3a68a6d24be94630ffa418476f8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-10T17:02:41+08:00" />
<meta property="article:modified_time" content="2020-07-10T17:02:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python文件编译与pyc反编译</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;">pyc是编译py之后生成的二进制文件。当我们发布系统的时候不想让别人看到源代码，就需要将py文件编译生成pyc文件，对外只提供pyc文件。同样，如果拿到一个python程序，只有pyc文件，我们就无法看到源码，希望有办法反编译pyc文件以获得源码。</p> 
<p style="margin-left:0cm;">既然有反编译的需求，为了保护pyc文件不被反编译，我们又希望找到一个方法来防止pyc文件被反编译。</p> 
<p style="margin-left:0cm;">本文介绍了如何将<span style="color:#365f91;">py文件编译成pyc和pyo文件，也介绍了如何反编译pyc文件， 又给出了一种</span>字节码混淆方法来防止pyc文件被反编译。</p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><span style="color:#365f91;">1 编译py文件到pyc和pyo</span></h3> 
<p style="margin-left:0cm;">pyc是编译py之后生成的二进制文件，由python虚拟机来执行的。当我们发布系统的时候不想让别人看到源代码，就需要将py文件编译生成pyc文件，对外只提供pyc文件。</p> 
<p style="margin-left:0cm;">同时，在模块被加载时，.pyc文件比.py文件更快</p> 
<p style="margin-left:0cm;">但是pyc的内容跟python的版本相关，不同的版本编译后的pyc文件不同，2.5编译的pyc文件不能到3.5上执行.</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#333333;">发布</span><span style="color:#333333;">python</span><span style="color:#333333;">软件的过程为：</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">1. </span><span style="color:#333333;">生产</span><span style="color:#333333;">pyc</span><span style="color:#333333;">文件</span><span style="color:#333333;">: python -m compileall . </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">2. </span><span style="color:#333333;">删除</span><span style="color:#333333;">py</span><span style="color:#333333;">文件</span><span style="color:#333333;">: find . -name “*.py” |xargs rm -rf </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">3. </span><span style="color:#333333;">删除</span><strong><span style="color:#333333;">pycache</span></strong><span style="color:#333333;">目录</span><span style="color:#333333;">: find . -name “<strong>pycache</strong>” |xargs rm -rf</span></p> 
<h3 style="margin-left:0cm;"><span style="color:#365f91;">1.1 Python2 编译</span></h3> 
<p style="margin-left:0cm;">命令：</p> 
<p style="margin-left:0cm;"><span style="color:#333333;">python -m py_compile file.py</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">python -m py_compile {file1,file2}.py</span></p> 
<p style="margin-left:0cm;">编译完成后，生成的 .pyc文件在当前目录。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">可以使用-O或者-OO转换python命令来减少编译模块的大小</p> 
<p style="margin-left:0cm;">    -O转换会帮你去掉assert语句</p> 
<p style="margin-left:0cm;">    -OO转换会帮你去掉assert语句和__doc__文档字符串</p> 
<p style="margin-left:0cm;">由于一些程序可能依赖于assert语句或文档字符串，应该在确认需要的情况下使用这些选项。</p> 
<p style="margin-left:0cm;"><span style="color:#333333;">例如</span><span style="color:#333333;"> python –O -m py_compile file.py </span><span style="color:#333333;">会在本目录生成</span><span style="color:#333333;"> file.pyo</span></p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><span style="color:#365f91;">1.2 python3 编译</span></h3> 
<p style="margin-left:0cm;">Python3的编译和python2一样，只是在python3之后编译后的文件在pycache目录下，而不是与源文件同一目录。</p> 
<p style="margin-left:0cm;">那么如何让python3实现生成的pyc与源代码在同一目录呢？可以加上-b参数，例如</p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Python3 -m py_compile -b file.py</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><span style="color:#365f91;">1.3 批量编译</span></h3> 
<p style="margin-left:0cm;">python -m compileall DIR</p> 
<p style="margin-left:0cm;">python3 -m compileall –b DIR</p> 
<p style="margin-left:0cm;">DIR为需要编译的目录</p> 
<p style="margin-left:0cm;">例如： python -m compileall .</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">参数说明：</p> 
<p style="margin-left:0cm;">usage: python compileall.py [-l] [-f] [-q] [-d destdir] [-x regexp] [-i list] [directory|file ...]</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">arguments: zero or more file and directory names to compile; if no arguments given,</p> 
<p style="margin-left:0cm;">           defaults to the equivalent of -l sys.path</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">options:</p> 
<p style="margin-left:0cm;">-l: don't recurse into subdirectories</p> 
<p style="margin-left:0cm;">-f: force rebuild even if timestamps are up-to-date</p> 
<p style="margin-left:0cm;">-q: output only error messages</p> 
<p style="margin-left:0cm;">-d destdir: directory to prepend to file paths for use in compile-time tracebacks and in</p> 
<p style="margin-left:0cm;">            runtime tracebacks in cases where the source file is unavailable</p> 
<p style="margin-left:0cm;">-x regexp: skip files matching the regular expression regexp; the regexp is searched for</p> 
<p style="margin-left:0cm;">           in the full path of each file considered for compilation</p> 
<p style="margin-left:0cm;">-i file: add all the files and directories listed in file to the list considered for</p> 
<p style="margin-left:0cm;">         compilation; if "-", names are read from stdin</p> 
<h3 style="margin-left:0cm;">1.4 代码实现</h3> 
<p style="margin-left:0cm;">单文件编译:</p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">import py_compile<br> py_compile.compile('path') //path</span><span style="color:#00b0f0;">是包括</span><span style="color:#00b0f0;">.py</span><span style="color:#00b0f0;">文件名的路径</span></p> 
<p style="margin-left:0cm;">批量编译：</p> 
<p style="margin-left:0cm;">      <span style="color:#00b0f0;">import compileall</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">compileall.compile_dir('$dir')</span></p> 
<p style="margin-left:0cm;"> </p> 
<h2 style="margin-left:0cm;"><strong>2反编译pyc</strong></h2> 
<p style="margin-left:0cm;">如果只有pyc文件，我们是无法直接查看内容的，这时，就需要反编译工具将pyc文件反编译成py源程序。 这里介绍uncompyle6反编译工具。Pyc文件能够反编译的前提是文件没有被加密或者代码混淆。</p> 
<h3 style="margin-left:0cm;"><span style="color:#365f91;">2.1 Uncompyle6安装</span></h3> 
<p style="margin-left:0cm;">&gt; git clone <a href="https://github.com/rocky/python-uncompyle6.git">https://github.com/rocky/python-uncompyle6.git</a></p> 
<p style="margin-left:0cm;">&gt; git checkout python-2.4</p> 
<p style="margin-left:0cm;">&gt; sudo python setup.py install</p> 
<p style="margin-left:0cm;">如果没有报错，则安装成功了。</p> 
<h3 style="margin-left:0cm;"><span style="color:#365f91;">2.2反编译</span></h3> 
<p style="margin-left:0cm;">执行命令：</p> 
<p style="margin-left:0cm;">&gt;uncompyle6 -o . *.pyc</p> 
<p style="margin-left:0cm;">这时会在当前目录生成.py源文件。</p> 
<h2 style="margin-left:0cm;"><strong>3 防止反编译pyc文件</strong></h2> 
<p style="margin-left:0cm;">如何防止pyc文件被反编译呢? 这里介绍字节码混淆的方法，此方法能够抵挡低端的反编译手段，例如第2章的方法，但是，要到高手，还是抵挡不住。</p> 
<p style="margin-left:0cm;">字节码混淆可以非常容易的欺骗通常的反汇编器和反编译器，同时不影响代码的正常执行。下面这个例子展示了如何欺骗Uncompyle6反编译器以及dis反汇编器：</p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">#</span><span style="color:#00b0f0;">一个简单的</span><span style="color:#00b0f0;">Python</span><span style="color:#00b0f0;">应用</span><span style="color:#00b0f0;"> sample1.py</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">print 'Hello World'</span></p> 
<p style="margin-left:0cm;">对其进行编译：</p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">python -m py_compile sample1.py</span></p> 
<p style="margin-left:0cm;">对编译后的sample1.pyc使用Python内置dis模块反汇编：</p> 
<p style="margin-left:0cm;">      <span style="color:#00b0f0;">&gt;&gt;&gt; import marshal,dis</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt; fd = open('sample1.pyc', 'rb')</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt; fd.seek(8)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt; sample1_code_obj = marshal.load(fd)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt; fd.close()</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt; dis.dis(sample1_code_obj)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">  1           0 LOAD_CONST               0 ('Hello World')</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">              3 PRINT_ITEM</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">              4 PRINT_NEWLINE</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">              5 LOAD_CONST               1 (None)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">              8 RETURN_VALUE</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt;</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">以上的汇编代码笔者肉眼反汇编的结果如下：</p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">0 LOAD_CONST     0 ('Hello World') #</span><span style="color:#00b0f0;">加载</span><span style="color:#00b0f0;">co_consts[0]</span><span style="color:#00b0f0;">到栈顶，</span><span style="color:#00b0f0;">co_consts[0]</span><span style="color:#00b0f0;">存储着常量字符串</span><span style="color:#00b0f0;">'Hello World'</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">3 PRINT_ITEM                       #</span><span style="color:#00b0f0;">打印栈顶到</span><span style="color:#00b0f0;">sys.stdout</span><span style="color:#00b0f0;">，即</span><span style="color:#00b0f0;">print 'Hello World'</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">4 PRINT_NEWLINE                    #</span><span style="color:#00b0f0;">打印新行到</span><span style="color:#00b0f0;">sys.stdout</span><span style="color:#00b0f0;">，此指令因</span><span style="color:#00b0f0;">print</span><span style="color:#00b0f0;">语句而由编译器自动生成</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">5 LOAD_CONST     1 (None)          #</span><span style="color:#00b0f0;">加载</span><span style="color:#00b0f0;">co_consts[1]</span><span style="color:#00b0f0;">到栈顶，</span><span style="color:#00b0f0;">co_consts[1]</span><span style="color:#00b0f0;">存储着</span><span style="color:#00b0f0;">None</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">8 RETURN_VALUE                     #</span><span style="color:#00b0f0;">将栈顶返回给调用者，此两条指令为编译器自动生成</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">现在我们修改sample1.pyc，在程序入口增加一条绝对跳转指令（可以使用UltraEdit 16进制插入功能修改pyc文件，”JUMP_ABSOLUTE 3”在Python 2.7中对应的字节码为 0x71 0x03 0x00。修改code string内容的同时应修改code string的长度，此处增加了一个3字节指令)，使用内置dis模块反汇编的结果如下：</p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">  1           0 JUMP_ABSOLUTE            3                 #</span><span style="color:#00b0f0;">自行添加</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">        &gt;&gt;    3 LOAD_CONST               0 ('Hello World')</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">              6 PRINT_ITEM</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">              7 PRINT_NEWLINE</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">              8 LOAD_CONST               1 (None)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">             11 RETURN_VALUE</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">如果读者对汇编代码有一定认识，就会明白此处的绝对跳转对Python虚拟机执行此程序基本没有影响（除了增加一个指令执行周期），然而这个绝对跳转将成功欺骗反编译器。使用Uncompyle6反编译的结果如下：</p> 
<p style="margin-left:0cm;">&lt;&lt;&lt; Error: Decompiling stopped due to &lt;class 'uncompyle6.semantics.pysource.ParserError'&gt;</p> 
<p style="margin-left:0cm;">如果一个pyc文件无法被反编译，初级的破解者可能就会止步于此了，但对于有经验的工程师来说这还远远不够。同样的，我们还要让通常的反汇编器也无法工作才行。按下面的汇编代码继续加工上面的sample1.pyc。</p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">|   1           0 JUMP_ABSOLUTE        [71 06 00]     6 </span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">|               3 LOAD_CONST           [64 FF FF] 65535 (FAKE!)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">|         &gt;&gt;    6 LOAD_CONST           [64 00 00]     0 (Hello World)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">|               9 PRINT_ITEM           [47 -- --]</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">|              10 PRINT_NEWLINE        [48 -- --]</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">|              11 LOAD_CONST           [64 01 00]     1 (None)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">|              14 RETURN_VALUE         [53 -- --]</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">以上第二条指令的意思是加载code object常量表的第65535项到栈顶。在上述sample1.pyc中，常量表的长度为2，下标65535已超出常量表的范围，所以这是条非法指令。但由于第一条绝对跳转的存在，第二条指令永远都不会被执行。通常的反汇编器如dis会尽全力列举有用的信息，但并不能理解实际执行的控制流，当反汇编器尝试反汇编第二条指令时，会试着去读取code object常量表的第65535项并且抛出一个’tuple index out of range’的意外。Python内置dis模块的出错信息如下：</p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt; fd = open('sample1.pyc', 'rb')</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt; fd.seek(8)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt; import marshal,dis</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt; sample1_code_obj = marshal.load(fd)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt; dis.dis(sample1_code_obj)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">  1           0 JUMP_ABSOLUTE            6</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">              3 LOAD_CONST           65535</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">Traceback (most recent call last):</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">  File "C:\Python27\lib\dis.py", line 43, in dis</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">    disassemble(x)</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">  File "C:\Python27\lib\dis.py", line 96, in disassemble</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">    print '(' + repr(co.co_consts[oparg]) + ')',</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">IndexError: tuple index out of range</span></p> 
<p style="margin-left:0cm;"><span style="color:#00b0f0;">&gt;&gt;&gt;</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">现在Uncompyle6和dis都被欺骗了，代码得到了有效的保护。</p> 
<h2 style="margin-left:0cm;"><strong>4 Reference</strong></h2> 
<p style="margin-left:0cm;"><span style="color:#0000FF;"><u><a href="https://blog.csdn.net/ir0nf1st/article/details/61650984">https://blog.csdn.net/ir0nf1st/article/details/61650984</a></u></span></p> 
<p style="margin-left:0cm;"><span style="color:#0000FF;"><u><a href="https://www.cnblogs.com/nickchen121/p/10802465.html" rel="nofollow">https://www.cnblogs.com/nickchen121/p/10802465.html</a></u></span></p> 
<p style="margin-left:0cm;"><span style="color:#0000FF;"><u><a href="https://www.cnblogs.com/dkblog/archive/2009/04/16/1980757.html" rel="nofollow">https://www.cnblogs.com/dkblog/archive/2009/04/16/1980757.html</a></u></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b226831282310b959ef4fcc06b786904/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python使用中常见问题总结（五）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e93683e983b5ead4246b0a899818fa64/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot2.x整合kafka【详细】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>