<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java常见面试题（160道） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java常见面试题（160道）" />
<meta property="og:description" content="1. JDK 和 JRE 有什么区别？ JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。
2. == 和 equals 的区别是什么？ 基本数据类型：比较的值是否相等；
引用数据类型：如String，==比较的是引用是否指向同一块内存；euqals被重写了，比较的是引用指向内存中的值是否相等
String、StringBuffer和StringBuilder的区别？ String 大小固定，不可变
StringBuffer 大小可变，线程安全（有锁），同步，效率低，适用于多线程，低并发
StringBuilder 大小可变，线程不安全（无锁），不同步，效率高，适用于单线程，高并发
4. final 在 Java 中有什么作用？ final 修饰的类叫最终类，该类不能被继承。
final 修饰的方法不能被重写。
final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。
5. Java 中的 Math. round(-1. 5) 等于多少？ 等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5d28a0bf773a9e8020ab1cfd231e3a75/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-30T11:44:14+08:00" />
<meta property="article:modified_time" content="2023-06-30T11:44:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java常见面试题（160道）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><strong>1. JDK 和 JRE 有什么区别？</strong></span></strong></strong></span></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#ffffff;">JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</span></li><li style="text-align:justify;"><span style="background-color:#ffffff;">JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;">具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</span></span></p> 
<h4 style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><strong><span style="background-color:#ffffff;"><strong>2. == 和 equals 的区别是什么？</strong></span></strong></strong></span></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">基本数据类型：比较的值是否相等；</span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">引用数据类型：如String，==比较的是引用是否指向同一块内存；euqals被重写了，比较的是引用指向内存中的值是否相等</span></span></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">String、StringBuffer和StringBuilder的区别？</span></span></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">String 大小固定，不可变</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">StringBuffer 大小可变，线程安全（有锁），同步，效率低，适用于多线程，低并发</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">StringBuilder 大小可变，线程不安全（无锁），不同步，效率高，适用于单线程，高并发</span></span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>4. final 在 Java 中有什么作用？</strong></span></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#f6f6f6;">final 修饰的类叫最终类，该类不能被继承。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#f6f6f6;">final 修饰的方法不能被重写。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#f6f6f6;">final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>5. Java 中的 Math. round(-1. 5) 等于多少？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>6. String 属于基础的数据类型吗？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</span></p> 
<ol><li style="text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>什么是</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>自动装箱与拆箱？</strong></span></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">装箱：将基本类型用包装器类型包装起来</p> 
<p style="margin-left:.0001pt;text-align:justify;">拆箱：将包装器类型转换为基本类型</p> 
<ol><li style="text-align:left;"><strong><span style="background-color:#f6f6f6;"><strong>方法覆写和方法重载的区别</strong></span></strong></li></ol> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">方法的重写（Overriding）和重载（Overloading）是Java多态性的不同表现。重写（也可以叫覆盖，覆写）是父类与子类之间多态性的一种表现，而重载是一个类中多态性的一种表现。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">重载发生在一个类里面，方法名相同，参数列表不同（参数类型，个数、顺序不同），方法的返回值和修饰符可以不同。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">重写发生在父类与子类之间，方法名相同，参数列表相同，返回值的范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类，如果父类方法访问修饰符为private则子类不能重写该方法。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>9. 如何将字符串反转？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">示例代码：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">StringBuffer stringBuffer = </span><span style="background-color:#f5f5f5;">new</span><span style="background-color:#f5f5f5;"> StringBuffer();</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">stringBuffer. </span><span style="background-color:#f5f5f5;">append</span><span style="background-color:#f5f5f5;">(</span><span style="background-color:#f5f5f5;">"abcdefg"</span><span style="background-color:#f5f5f5;">);</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">System. out. </span><span style="background-color:#f5f5f5;">println</span><span style="background-color:#f5f5f5;">(stringBuffer. reverse()); </span><span style="background-color:#f5f5f5;">// gfedcba</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">StringBuilder stringBuilder = </span><span style="background-color:#f5f5f5;">new</span><span style="background-color:#f5f5f5;"> StringBuilder();</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">stringBuilder. </span><span style="background-color:#f5f5f5;">append</span><span style="background-color:#f5f5f5;">(</span><span style="background-color:#f5f5f5;">"abcdefg"</span><span style="background-color:#f5f5f5;">);</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">System. out. </span><span style="background-color:#f5f5f5;">println</span><span style="background-color:#f5f5f5;">(stringBuilder. reverse()); </span><span style="background-color:#f5f5f5;">// gfedcba</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>10. String 类的常用方法都有那些？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">inexOf()：返回指定字符的索引。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">charAt()：返回指定索引处的字符。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">replace()：字符串替换。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">trim()：去除字符串两端空白。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">split()：分割字符串，返回一个分割后的字符串数组。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">getBytes()：返回字符串的 byte 类型数组。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">length()：返回字符串长度。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">toLowerCase()：将字符串转成小写字母。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">toUpperCase()：将字符串转成大写字符。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">substring()：截取字符串。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">equals()：字符串比较。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>11. 抽象类必须要有抽象方法吗</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">不需要，抽象类不一定非要有抽象方法。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>12. 普通类和抽象类有哪些区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">普通类不能包含抽象方法，抽象类可以包含抽象方法。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">抽象类不能直接实例化，普通类可以直接实例化。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>13. 抽象类能使用 final 修饰吗？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>14. 接口和抽象类有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">构造函数：抽象类可以有构造函数；接口不能有。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>15. Java 中 IO 流分为几种？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">按功能来分：输入流（input）、输出流（output）。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">按类型来分：字节流和字符流。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>16. BIO、NIO、AIO 有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>17. Files的常用方法都有哪些？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Files. exists()：检测文件路径是否存在。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Files. createFile()：创建文件。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Files. createDirectory()：创建文件夹。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Files. delete()：删除一个文件或目录。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Files. copy()：复制文件。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Files. move()：移动文件。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Files. size()：查看文件个数。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Files. read()：读取文件。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Files. write()：写入文件。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>容器</strong></span></strong></strong></h4> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>18. Java 容器都有哪些？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Collection</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">List</span> 
  <ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ArrayList</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">LinkedList</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Vector</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Stack</span></li></ul></li></ul> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Set</span> 
  <ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">HashSet</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">LinkedHashSet</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">TreeSet</span></li></ul></li></ul> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Map</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">HashMap</span> 
  <ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">LinkedHashMap</span></li></ul></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">TreeMap</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ConcurrentHashMap</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Hashtable</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>19. Collection 和 Collections 有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法：Collections. sort(list)。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>20. List、Set、Map 之间的区别是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">三者之间的区别，如下表：</span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="326" src="https://images2.imgbox.com/70/9a/xBlGRcDr_o.png" width="1038"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>21. HashMap 和 Hashtable 有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>22. 如何决定使用 HashMap 还是 TreeMap？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key </span><a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&amp;spm=1001.2101.3001.7020" title="集合">集合</a><span style="background-color:#f6f6f6;">进行有序的遍历，那 TreeMap 是更好的选择。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>23. 说一下 HashMap 的实现原理？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>24. 说一下 HashSet 的实现原理？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>25. ArrayList 和 LinkedList 的区别是什么？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>26. 如何实现数组和 List 之间的转换？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">数组转 List：使用 Arrays. asList(array) 进行转换。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">List 转数组：使用 List 自带的 toArray() 方法。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>27. ArrayList 和 Vector 的区别是什么？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">性能：ArrayList 在性能方面要优于 Vector。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>28. Array 和 ArrayList 有何区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>29. 在 Queue 中 poll()和 remove()有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">相同点：都是返回第一个元素，并在队列中删除返回的对象。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">代码示例：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">Queue&lt;String&gt; queue = </span><span style="background-color:#f5f5f5;">new</span> <span style="background-color:#f5f5f5;">LinkedList</span><span style="background-color:#f5f5f5;">&lt;String&gt;();</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">queue. </span><span style="background-color:#f5f5f5;">offer</span><span style="background-color:#f5f5f5;">(</span><span style="background-color:#f5f5f5;">"string"</span><span style="background-color:#f5f5f5;">); </span><span style="background-color:#f5f5f5;">// add</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">System. out. </span><span style="background-color:#f5f5f5;">println</span><span style="background-color:#f5f5f5;">(queue. </span><span style="background-color:#f5f5f5;">poll</span><span style="background-color:#f5f5f5;">());</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">System. out. </span><span style="background-color:#f5f5f5;">println</span><span style="background-color:#f5f5f5;">(queue. </span><span style="background-color:#f5f5f5;">remove</span><span style="background-color:#f5f5f5;">());</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">System. out. </span><span style="background-color:#f5f5f5;">println</span><span style="background-color:#f5f5f5;">(queue. </span><span style="background-color:#f5f5f5;">size</span><span style="background-color:#f5f5f5;">());</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>30. 哪些集合类是线程安全的？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>31. 迭代器 Iterator 是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合</span><a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&amp;spm=1001.2101.3001.7020" title="框架">框架</a><span style="background-color:#f6f6f6;">中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>32. Iterator 怎么使用？有什么特点？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Iterator 使用代码如下：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">List&lt;</span><span style="background-color:#f5f5f5;">String</span><span style="background-color:#f5f5f5;">&gt; list = </span><span style="background-color:#f5f5f5;">new</span><span style="background-color:#f5f5f5;"> ArrayList&lt;&gt;();</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">Iterator</span><span style="background-color:#f5f5f5;">&lt;</span><span style="background-color:#f5f5f5;">String</span><span style="background-color:#f5f5f5;">&gt; it = list. </span><span style="background-color:#f5f5f5;">iterator</span><span style="background-color:#f5f5f5;">();</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">String</span><span style="background-color:#f5f5f5;"> obj = it. </span><span style="background-color:#f5f5f5;">next</span><span style="background-color:#f5f5f5;">();</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">System. out. println(obj);</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>33. Iterator 和 ListIterator 有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>34. 怎么确保一个集合不能被修改？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">示例代码如下：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">List&lt;String&gt; list = </span><span style="background-color:#f5f5f5;">new</span><span style="background-color:#f5f5f5;"> ArrayList&lt;&gt;();</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">clist. </span><span style="background-color:#f5f5f5;">add</span><span style="background-color:#f5f5f5;">(</span><span style="background-color:#f5f5f5;">"y"</span><span style="background-color:#f5f5f5;">); </span><span style="background-color:#f5f5f5;">// 运行时此行报错</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">System. </span><span style="background-color:#f5f5f5;">out</span><span style="background-color:#f5f5f5;">. println(list. size());</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>多线程</strong></span></strong></strong></h4> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>35. 并行和并发有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">并行：多个处理器或多核处理器同时处理多个任务。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>36. 线程和进程的区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>37. 守护线程是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>38. 创建线程有哪几种方式？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">创建线程有三种方式：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">继承 Thread 重写 run 方法；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">实现 Runnable 接口；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">实现 Callable 接口。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>39. 说一下 runnable 和 callable 有什么区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>40. 线程有哪些状态？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">线程的状态：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">NEW 尚未启动</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">RUNNABLE 正在执行中</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">WAITING 永久等待状态</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">TIMED_WAITING 等待指定的时间重新被唤醒的状态</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">TERMINATED 执行完成</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>41. sleep() 和 wait() 有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">类的不同：sleep() 来自 Thread，wait() 来自 Object。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">释放锁：sleep() 不释放锁；wait() 释放锁。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>42. notify()和 notifyAll()有什么区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>43. 线程的 run() 和 start() 有什么区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>44. 创建线程池有哪几种方式？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">线程池创建有七种方式，最核心的是最后一种：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>45. 线程池都有哪些状态？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>46. 线程池中 submit() 和 execute() 方法有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">execute()：只能执行 Runnable 类型的任务。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">submit()：可以执行 Runnable 和 Callable 类型的任务。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>47. 在 Java 程序中怎么保证多线程的运行安全？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">方法一：使用安全类，比如 Java. util. concurrent 下的类。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">方法二：使用自动锁 synchronized。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">方法三：使用手动锁 Lock。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>48. 创建线程池有哪几种方式？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;">①. newFixedThreadPool(int nThreads)</p> 
<p style="margin-left:0;text-align:left;">创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p> 
<p style="margin-left:0;text-align:left;">②. newCachedThreadPool()</p> 
<p style="margin-left:0;text-align:left;">创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p> 
<p style="margin-left:0;text-align:left;">③. newSingleThreadExecutor()</p> 
<p style="margin-left:0;text-align:left;">这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p> 
<p style="margin-left:0;text-align:left;">④. newScheduledThreadPool(int corePoolSize)</p> 
<p style="margin-left:0;text-align:left;">创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>49. 什么是死锁？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>50. 怎么防止死锁？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">尽量使用 Java. util. concurrent 并发类代替自己手写锁。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">尽量减少同步的代码块。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>51. ThreadLocal 是什么？有哪些使用场景？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>52. 说一下 synchronized 底层实现原理？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>53. synchronized 和 volatile 的区别是什么？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>54. synchronized 和 Lock 有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>55. synchronized 和 ReentrantLock 区别是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">主要区别如下：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>56. 说一下 atomic 的原理？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。 </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>57. 什么是反射？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>58. 什么是 Java 序列化？什么情况下需要序列化？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">以下情况需要使用 Java 序列化：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">想把的内存中的对象状态保存到一个文件中或者数据库中时候；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">想用套接字在网络上传送对象的时候；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">想通过RMI（远程方法调用）传输对象的时候。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>59. 动态代理是什么？有哪些应用？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">动态代理是运行时动态生成代理类。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">动态代理的应用有 spring aop、</span><a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=hibernate&amp;spm=1001.2101.3001.7020" title="hibernate">hibernate</a><span style="background-color:#f6f6f6;"> 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>60. 怎么实现动态代理？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>对象拷贝</strong></span></strong></strong></h4> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>61. 为什么要使用克隆？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>62. 如何实现对象克隆？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>63. 深拷贝和浅拷贝区别是什么？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>64. JSP 和 servlet 有什么区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>65. JSP 有哪些内置对象？作用分别是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">JSP 有 9 大内置对象：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">response：封装服务器对客户端的响应；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">pageContext：通过该对象可以获取其他对象；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">session：封装用户会话的对象；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">application：封装服务器运行环境的对象；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">out：输出服务器响应的输出流对象；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">config：Web 应用的配置对象；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">page：JSP 页面本身（相当于 Java 程序中的 this）；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">exception：封装页面抛出异常的对象。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>66. 说一下 JSP 的 4 种作用域？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">page：代表与一个页面相关的对象和属性。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>67. session 和 cookie 有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>68. 说一下 session 的工作原理？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>69. 如果客户端禁止 cookie 能实现 session 还能用吗？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>70. spring mvc 和 struts 的区别是什么？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>71. 如何避免 SQL 注入？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">使用预处理 PreparedStatement。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">使用正则表达式过滤掉字符中的特殊字符。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>72. 什么是 XSS 攻击，如何避免？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">预防 XSS 的核心是必须对输入的数据做过滤处理。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>73. 什么是 CSRF 攻击，如何避免？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">防御手段：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">验证请求来源地址；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">关键操作添加验证码；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">在请求地址添加 token 并验证。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>74. throw 和 throws 的区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">throw：是真实抛出一个异常。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">throws：是声明可能会抛出一个异常。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>75. final、finally、finalize 有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">finalize：是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>76. try-catch-finally 中哪个部分可以省略？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>78. 常见的异常类有哪些？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">NullPointerException 空指针异常</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ClassNotFoundException 指定类不存在</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">NumberFormatException 字符串转换为数字异常</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">IndexOutOfBoundsException 数组下标越界异常</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ClassCastException 数据类型转换异常</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">FileNotFoundException 文件未找到异常</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">NoSuchMethodException 方法不存在异常</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">IOException IO 异常</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">SocketException Socket 异常</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>网络</strong></span></strong></strong></h4> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>79. http 响应码 301 和 302 代表的是什么？有什么区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">301：永久重定向。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">302：暂时重定向。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>80. forward 和 redirect 的区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">forward 是转发 和 redirect 是重定向：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">效率：forward 比 redirect 效率高。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>81. 简述 tcp 和 udp的区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">两者的区别大致如下：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">tcp 提供可靠的服务（数据传输），udp 无法保证；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">tcp 面向字节流，udp 面向报文；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">tcp 数据传输慢，udp 数据传输快；</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>82. tcp 为什么要三次握手，两次不行吗？为什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>83. 说一下 tcp 粘包是怎么产生的？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>84. OSI 的七层模型都有哪些？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">数据链路层：负责建立和管理节点间的链路。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">会话层：向两个实体的表示层提供建立和使用连接的方法。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>85. get 和 post 请求有哪些区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">get 请求会被浏览器主动缓存，而 post 不会。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">get 传递参数有大小限制，而 post 没有。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>86. 如何实现跨域？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">实现跨域有以下几种方案：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">服务器端运行跨域 设置 CORS 等于 *；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">在单个接口使用注解 @CrossOrigin 运行跨域；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">使用 jsonp 跨域；</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>87. 说一下 JSONP 实现原理？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>设计模式</strong></span></strong></strong></h4> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>88. 说一下你熟悉的设计模式？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">单例模式：保证被创建一次，节省系统开销。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">工厂模式（简单工厂、抽象工厂）：解耦代码。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>89. 简单工厂和抽象工厂有什么区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>90. 为什么要使用 spring？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">spring 提供了事务支持，使得事务操作变的更加方便。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>91. 解释一下什么是 aop？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>92. 解释一下什么是 ioc？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>93. spring 有哪些主要模块？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">spring dao：Data Access Object 提供了JDBC的抽象层。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>94. spring 常用的注入方式有哪些？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">setter 属性注入</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">构造方法注入</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">注解方式注入</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>95. spring 中的 bean 是线程安全的吗？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">有状态就是有数据存储功能。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">无状态就是不会保存数据。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>96. spring 支持几种 bean 的作用域？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">spring 支持 5 种作用域，如下：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Web 环境下的作用域：</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">request：每次 http 请求都会创建一个 bean；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">session：同一个 http session 共享一个 bean 实例；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">「注意：」 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>97. spring 自动装配 bean 有哪些方式？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">byName：它根据 bean 的名称注入对象依赖项。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">byType：它根据类型注入对象依赖项。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>98. spring 事务实现方式有哪些？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">编码方式：提供编码的形式管理和维护事务。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>99. 说一下 spring 的事务隔离？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">「脏读」 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">「不可重复读」 ：是指在一个事务内，多次读同一数据。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">「幻读」 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>100. 说一下 spring mvc 运行流程？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">spring mvc 先将请求发送给 DispatcherServlet。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">DispatcherServlet 再把请求提交到对应的 Controller。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Controller 进行业务逻辑处理后，会返回一个ModelAndView。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">视图对象负责渲染返回给客户端。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>101. spring mvc 有哪些组件？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">前置控制器 DispatcherServlet。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">映射控制器 HandlerMapping。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">处理器 Controller。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">模型和视图 ModelAndView。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">视图解析器 ViewResolver。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>102. @RequestMapping 的作用是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">将 http 请求映射到相应的类/方法上。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>103. @Autowired 的作用是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>104. 什么是 spring boot？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>105. 为什么要用 spring boot？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">配置简单</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">独立运行</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">自动装配</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">无代码生成和 xml 配置</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">提供应用监控</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">易上手</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">提升开发效率</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>106. spring boot 核心配置文件是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">spring boot 核心的两个配置文件：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>107. spring boot 配置文件有哪几种类型？它们有什么区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">. properties </span><span style="background-color:#f6f6f6;">格式特点</span><span style="background-color:#f6f6f6;">如下：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f5f5f5;">以键值对形式呈现，如：</span><span style="background-color:#f5f5f5;">spring.datasource.username=root</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">. ym</span><span style="background-color:#f6f6f6;">l格式特点</span><span style="background-color:#f6f6f6;">如下：</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">1.YAML 是 JSON 的超集，是一种专门用来书写配置文件的语言，可以替代 application.properties。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">2.在创建一个 SpringBoot 项目时，引入的 spring-boot-starter-web 依赖间接地引入了 snakeyaml 依赖， snakeyaml 会实现对 YAML 配置的解析。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">3.YAML 的使用非常简单，利用缩进来表示层级关系，并且大小写敏感。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>108. spring boot 有哪些方式可以实现热部署？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>109. jpa 和 hibernate 有什么区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>110. 什么是 spring cloud？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>111. spring cloud 断路器的作用是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>112. spring cloud 的核心组件有哪些？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Eureka：服务注册于发现。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>11</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>3</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 什么是 ORM 框架？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>MyBatis</strong></span></strong></strong></h4> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>14</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. MyBatis 中 #{}和 ${}的区别是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">\#{}</span><span style="background-color:#f6f6f6;">是预编译处理，</span><span style="background-color:#f6f6f6;">${}</span><span style="background-color:#f6f6f6;">是字符替换。在使用 </span><span style="background-color:#f6f6f6;">#{}</span><span style="background-color:#f6f6f6;">时，</span><a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=MyBatis&amp;spm=1001.2101.3001.7020" title="MyBatis">MyBatis</a><span style="background-color:#f6f6f6;"> 会将 SQL 中的 </span><span style="background-color:#f6f6f6;">#{}</span><span style="background-color:#f6f6f6;">替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>15</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. MyBatis 有几种分页方式？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">分页方式：逻辑分页和物理分页。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">「逻辑分页：」 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">「物理分页：」 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>16</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RowBounds 是一次性查询全部结果吗？为什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>17</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. MyBatis 逻辑分页和物理分页的区别是什么？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>18</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>19</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 说一下 MyBatis 的一级缓存和二级缓存？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>20</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. MyBatis 和 hibernate 的区别有哪些？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>21</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. MyBatis 有哪些执行器（Executor）？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">MyBatis 有三种基本的Executor执行器：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>22</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. MyBatis 分页插件的实现原理是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。 </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>23</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RabbitMQ 的使用场景有哪些？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">抢购活动，削峰填谷，防止系统崩塌。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>24</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RabbitMQ 有哪些重要的角色？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=RabbitMQ&amp;spm=1001.2101.3001.7020" title="RabbitMQ">RabbitMQ</a><span style="background-color:#f6f6f6;"> 中重要的角色有：生产者、消费者和代理：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">生产者：消息的创建者，负责创建和推送数据到消息服务器；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">消费者：消息的接收方，用于处理数据和确认消息；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>25</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RabbitMQ 有哪些重要的组件？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Channel（信道）：消息推送使用的通道。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Exchange（交换器）：用于接受、分配消息。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Queue（队列）：用于存储生产者的消息。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>26</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RabbitMQ 中 vhost 的作用是什么？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>27</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RabbitMQ 的消息是怎么发送的？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>28</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RabbitMQ 怎么保证消息的稳定性？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">提供了事务的功能。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">通过将 channel 设置为 confirm（确认）模式。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>29</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RabbitMQ 怎么避免消息丢失？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">把消息持久化磁盘，保证服务器重启消息不丢失。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">每个集群中至少有一个物理磁盘，保证消息落入磁盘。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>30</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RabbitMQ 持久化有什么缺点？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>31</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RabbitMQ 有几种广播类型？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">headers：与 direct 类似，只是性能很差，此类型几乎用不到。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">fanout：分发模式，把消费分发给所有订阅者。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>32</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. RabbitMQ 怎么实现延迟消息队列？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">延迟队列的实现有两种方式：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>146. RabbitMQ 集群有什么用？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">集群主要有以下两个用途：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">高容量：集群可以承载更多的消息量。</span><span style="background-color:#f6f6f6;">   </span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>33</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 数据库的三范式是什么？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">第三范式：任何非主属性不依赖于其它非主属性。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>34</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">表类型如果是 MyISAM ，那 id 就是 8。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">表类型如果是 InnoDB，那 id 就是 6。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>166. 如何获取当前数据库版本？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">使用 select version() 获取当前 MySQL 数据库版本。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>35</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 说一下 ACID 是什么？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>36</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. char 和 varchar 的区别是什么？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">「char(n)」 ：固定长度类型，比如订阅 char(10)，当你输入"abc"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">「varchar(n)」 ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>37</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. float 和 double 的区别是什么？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>38</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. </strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>MySQL 的内连接、左连接、右连接有什么区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">内连接关键字：inner join；左连接：left join；右连接：right join。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>39</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. MySQL 索引是怎么实现的？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>40</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 怎么验证 MySQL 的索引是否满足需求？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">explain 语法：explain select * from table where type=1。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>41</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 说一下数据库的事务隔离？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#f6f6f6;"><span style="background-color:#f6f6f6;">❝transaction-isolation = REPEATABLE-READ</span><br><span style="background-color:#f6f6f6;">❞</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">「脏读」 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">「不可重复读」 ：是指在一个事务内，多次读同一数据。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">「幻读」 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>42</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 说一下 MySQL 常用的引擎？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>43</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 说一下 MySQL 的行锁和表锁？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>44</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 说一下乐观锁和悲观锁？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>45</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. MySQL 问题排查都有哪些手段？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">使用 show processlist 命令查看当前所有连接信息。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">使用 explain 命令查询 SQL 语句执行计划。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">开启慢查询日志，查看慢查询的 SQL。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>46</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 如何做 MySQL 的性能优化？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">为搜索字段创建索引。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">避免使用 select *，列出需要查询的字段。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">垂直分割分表。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">选择正确的存储引擎。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>47</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. Redis 是什么？都有哪些使用场景？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Redis 是一个使用 C 语言开发的高速缓存数据库。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Redis 使用场景：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">记录帖子点赞数、点击数、评论数；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">缓存近期热帖；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">缓存文章详情信息；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">记录用户会话信息。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>48</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. Redis 有哪些功能？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">数据缓存功能</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">分布式锁的功能</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">支持数据持久化</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">支持事务</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">支持消息队列</span><span style="background-color:#f6f6f6;"> </span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>49</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. Redis 为什么是单线程的？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>50</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong> 什么是缓存穿透？怎么解决？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>51</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. Redis 支持的数据类型有哪些？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>52</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. Redis 支持的 Java 客户端都有哪些？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">支持的 Java 客户端有 Redisson、jedis、lettuce 等。 </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>53</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 怎么保证缓存和数据库数据的一致性？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">合理设置缓存的过期时间。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>54</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. Redis 持久化有几种方式？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">Redis 的持久化有两种方式，或者说有两种策略：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</span><span style="background-color:#f6f6f6;"> </span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>55</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. Redis 如何做内存优化？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>56</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. Redis 淘汰策略有哪些？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">no-enviction（驱逐）：禁止驱逐数据。</span><span style="background-color:#f6f6f6;"> </span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>JVM</strong></span></strong></strong></h4> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>57</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 说一下 JVM 的主要组成部分？及其作用？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">类加载器（ClassLoader）</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">运行时数据区（Runtime Data Area）</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">执行引擎（Execution Engine）</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">本地库接口（Native Interface）</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">「组件的作用：」 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。 </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>58</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 说一下堆栈的区别？</strong></span></strong></strong></h4> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">功能方面：堆是用来存放对象的，栈是用来执行程序的。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">共享性：堆是线程共享的，栈是线程私有的。</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">空间大小：堆大小远远大于栈。</span></li></ul> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>59</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 队列和栈是什么？有什么区别？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">队列和栈都是被用来预存储数据的。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">栈和队列很相似，但它运行对元素进行后进先出进行检索。 </span></p> 
<h4 style="margin-left:0pt;text-align:left;"><strong><strong><span style="background-color:#f6f6f6;"><strong>1</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>60</strong></span></strong><strong><span style="background-color:#f6f6f6;"><strong>. 说一下类装载的执行过程？</strong></span></strong></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">类装载分为以下 5 个步骤：</span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#f6f6f6;">加载：根据查找路径找到相应的 class 文件然后导入；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">检查：检查加载的 class 文件的正确性；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">准备：给类中的静态变量分配内存空间；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</span></li><li style="text-align:justify;"><span style="background-color:#f6f6f6;">初始化：对静态变量和静态代码块执行初始化工作。</span></li></ul> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;"> ===============================结束==================================</span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#f6f6f6;">关注公众号获取更多信息：</span></p> 
<p class="img-center"><img alt="" height="430" src="https://images2.imgbox.com/ee/0d/XfpgfgWx_o.png" width="430"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7622df283000c76f1a70d42a508d34a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Spring Boot的在线作业管理系统的设计与实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e1fcae9229ac5439355bf38aa8cbd7f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于stm32cubemx的串口中断处理（stm32F205）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>