<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何理解mqtt用到的101交换协议？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何理解mqtt用到的101交换协议？" />
<meta property="og:description" content="使用过mqtt的同学都知道，mqtt连接时，在Network面板中的status是101。
NameStatusTimemqtt101（Switching Protocols）Pending 那么101（Switching Protocols）到底是什么意思呢？
这篇文章将带你理解101交换协议是什么，以及101交换协议运用的协议升级机制。
101交换协议协议升级机制 101交换协议 HTTP的101交换协议意味着client向server发送的消息中包含了Upgrade请求头，server会根据client发送的这个请求头切换协议。
server会在response中添加一个Upgrade响应头，来指示server切换到的协议。
用一句话来说就是：client通过在请求头中添加Upgrade告诉server切换协议，server在响应头中添加upgrade说明切换后的协议。
再简单一点就是：客户端告诉服务端去切换协议。
General Request URL: wss://foo.bar Request Method: GET Status Code: 101 Switching Protocols Request Headers Connection: Upgrade Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits Sec-WebSocket-Key: xxx Sec-WebSocket-Protocol: mqtt Sec-WebSocket-Version: 13 Upgrade: websocket // client告诉server使用websocket协议 ... Response Headers connection: Upgrade sec-websocket-accept: fNs9ByuvC&#43;rD75&#43;tj2GMQAzbJms= // server基于client发出的Sec-WebSocket-Key:xxx计算得出，计算过程文章末尾有介绍 sec-websocket-protocol: mqtt Upgrade: websocket // server告诉client，我们（client，server）使用的是websocket协议 ... 其中这些请求头是什么意思呢？Connection，Sec-WebSocket-Extensions，Sec-WebSocket-Key，Sec-WebSocket-Protocol，Sec-WebSocket-Version等等。
响应头呢？sec-websocket-accept，sec-websocket-protocol。
看了下面的协议升级机制就明白了。
协议升级机制 HTTP1.1版本的协议有一个特殊的机制：升级一个已经建立的连接为另外一个协议，一般是通过Upgrade头来实现。
这个机制是可选的，它不能强制协议改变。虽然实现支持新协议，但是也可以选择不升级。在实际应用中，通常这个机制用于引导WebSocket进行连接。
注意，HTTP2.0版本明确禁止使用这个机制。只能用于HTTP1.1。
升级HTTP/1.1连接 client可以使用Upgrade头去邀请服务器去切换为协议列表中的某一项，按照降序。
因为Upgrade是一个逐跳头，因此它需要一个Connection头。
这也就意味着一个典型的包含Upgrade报文头的请求为：
GET /index." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/421bf229ee362093306abed9c0c45785/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-26T00:17:36+08:00" />
<meta property="article:modified_time" content="2021-05-26T00:17:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何理解mqtt用到的101交换协议？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/c4/ab/IswWzi2S_o.png" alt="在这里插入图片描述"></p> 
<p>使用过mqtt的同学都知道，mqtt连接时，在Network面板中的status是101。</p> 
<table><thead><tr><th>Name</th><th>Status</th><th>Time</th></tr></thead><tbody><tr><td>mqtt</td><td>101（Switching Protocols）</td><td>Pending</td></tr></tbody></table> 
<p>那么101（Switching Protocols）到底是什么意思呢？<br> 这篇文章将带你理解101交换协议是什么，以及101交换协议运用的协议升级机制。</p> 
<ul><li>101交换协议</li><li>协议升级机制</li></ul> 
<h4><a id="101_14"></a>101交换协议</h4> 
<p>HTTP的101交换协议意味着client向server发送的消息中包含了Upgrade请求头，server会根据client发送的这个请求头切换协议。</p> 
<p>server会在response中添加一个Upgrade响应头，来指示server切换到的协议。</p> 
<p>用一句话来说就是：<strong>client通过在请求头中添加Upgrade告诉server切换协议，server在响应头中添加upgrade说明切换后的协议。</strong></p> 
<p>再简单一点就是：客户端告诉服务端去切换协议。</p> 
<h5><a id="General_24"></a>General</h5> 
<pre><code>Request URL: wss://foo.bar
Request Method: GET
Status Code: 101 Switching Protocols
</code></pre> 
<h5><a id="Request_Headers_31"></a>Request Headers</h5> 
<pre><code>Connection: Upgrade 
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits
Sec-WebSocket-Key: xxx
Sec-WebSocket-Protocol: mqtt
Sec-WebSocket-Version: 13
Upgrade: websocket // client告诉server使用websocket协议
...
</code></pre> 
<h5><a id="Response_Headers_42"></a>Response Headers</h5> 
<pre><code>connection: Upgrade
sec-websocket-accept: fNs9ByuvC+rD75+tj2GMQAzbJms= // server基于client发出的Sec-WebSocket-Key:xxx计算得出，计算过程文章末尾有介绍
sec-websocket-protocol: mqtt
Upgrade: websocket // server告诉client，我们（client，server）使用的是websocket协议
...
</code></pre> 
<p>其中这些请求头是什么意思呢？Connection，Sec-WebSocket-Extensions，Sec-WebSocket-Key，Sec-WebSocket-Protocol，Sec-WebSocket-Version等等。<br> 响应头呢？sec-websocket-accept，sec-websocket-protocol。</p> 
<p>看了下面的协议升级机制就明白了。</p> 
<h4><a id="_56"></a>协议升级机制</h4> 
<p>HTTP1.1版本的协议有一个特殊的机制：<strong>升级一个已经建立的连接为另外一个协议，一般是通过Upgrade头来实现。</strong></p> 
<p>这个机制是可选的，它<strong>不能强制协议改变</strong>。虽然实现支持新协议，但是也可以选择不升级。在实际应用中，通常这个机制用于<strong>引导WebSocket进行连接</strong>。</p> 
<p><strong>注意，HTTP2.0版本明确禁止使用这个机制。只能用于HTTP1.1。</strong></p> 
<h5><a id="HTTP11_63"></a>升级HTTP/1.1连接</h5> 
<p>client可以使用Upgrade头去邀请服务器去切换为协议列表中的某一项，按照降序。</p> 
<p>因为Upgrade是一个逐跳头，因此它需要一个Connection头。<br> 这也就意味着一个典型的包含Upgrade报文头的请求为：</p> 
<pre><code>GET /index.html HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: example/1, foo/2
</code></pre> 
<p>其他的头一般是依赖请求协议的；例如，WebSocket升级允许额外的头去配置WebSocket连接，并在打开时就有一定的安全性。</p> 
<p>如果服务器决定去升级连接，分为升级成功和升级失败两种情况：</p> 
<ul><li>升级成功：它会返回一个<strong>101 Switching Protocols</strong>响应状态，并且Upgrade头中指明它切换后的协议。</li><li>升级失败：如果服务端不能升级连接，它会忽略Upgrade头，然后返回一个常规的响应（例如 200 OK）</li></ul> 
<p>服务器发送完101状态码之后，它可以立即开始使用新协议，并且进行与其他协议的handshake。一旦连接建立完成，连接就变为双向管道，初始化升级的请求可以再协议之上初始化。</p> 
<h5><a id="_83"></a>协议升级机制的常规用法</h5> 
<p>Upgrade这个头会用在哪些场景呢？而且与WebSocket连接有关的请求头都有哪些呢？</p> 
<ul><li>升级为WebSocket连接</li><li>与WebSocket连接有关的请求头 
  <ul><li>Sec-WebSocket-Extensions</li><li>Sec-WebSocket-Key</li><li>Sec-WebSocket-Protocol</li><li>Sec-WebSocket-Version</li><li>Sec-WebSocket-Accept（只读）</li></ul> </li></ul> 
<h6><a id="WebSocket_93"></a>升级为WebSocket连接</h6> 
<p>最常见的升级HTTP连接的场景，就是使用WebSockets的场景，通常是通过升级HTTP或者HTTPS连接的方式来实现。如果你使用WebSocket API去开启一个连接，或者任何WebSockets的库，大多数或者说所有的事情都已经为你做好了。</p> 
<p>例如：建立一个WebSocket连接非常简单，只需要这样既可：</p> 
<pre><code class="prism language-js">webSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"ws://destination.server.ext"</span><span class="token punctuation">,</span> <span class="token string">"optionalProtocol"</span><span class="token punctuation">)</span>
</code></pre> 
<p><code>WebSockek()</code>构造函数为开发者在内部做了所有创建一个HTTP/1.1连接，握手和升级的事情。</p> 
<blockquote> 
 <p>可以用"wss://" 去建立一个安全的WebSocket连接。</p> 
</blockquote> 
<p>如果你想自己手动建立一个WebSocket连接的话，你需要自己去处理握手过程。在创建完HTTP/1.1会话之后，你需要在请求上添加Upgrade和Connection这两个请求头。</p> 
<pre><code>Connection: Upgrade
Upgrade: websocket
</code></pre> 
<h6><a id="WebSocket_111"></a>与WebSocket连接有关的请求头</h6> 
<p>下面这些请求头是WebSocket升级过程中包含的请求头。与Upgrade和Connection头不同，下面这些请求头</p> 
<h6><a id="SecWebSocketExtensions_113"></a>Sec-WebSocket-Extensions</h6> 
<p>声明一个或者多个协议级的WebSocket扩展区告诉服务器使用。在一个请求里使用一个或者多个Sec-WebSocket-Extension头是可以的；放在一起用分号隔开也可以。</p> 
<pre><code>Sec-WebSocket-Extensions: extensions
</code></pre> 
<p>extensions需要用分号分开。需要从<a href="https://www.iana.org/assignments/websocket/websocket.xml#extension-name" rel="nofollow">插件列表</a>里选择。</p> 
<p>例如：<code>Sec-WebSocket-Extensions: superspeed, colormode; depth=16</code></p> 
<p>我们上面例子中的permessage-deflate也在其中。</p> 
<p><code>permessage-deflate | WebSocket Per-Message Deflate | [RFC7692] | None | [RFC7692]</code></p> 
<h6><a id="SecWebSocketKey_130"></a>Sec-WebSocket-Key</h6> 
<p>向服务端提供客户端有权升级为WebSocket的信息。这个头可用于不安全的HTTP想要升级时，为了提供某种程度的保护，防止滥用。key的值使用在WebSocket规范中定义的算法生成，所以这并不保证安全性。</p> 
<p>这个key是为了放置非WebSocket的客户端无意中进行websocket连接或者滥用。<br> 本质上，这个key代表着：“是的，我确实是要开启一个WebSocket连接的。”</p> 
<p>这个头会自动被使用它的客户端添加，不能被XMLHttpRequest.setRequestHeader() 添加</p> 
<pre><code>Sec-WebSocket-Key: key
</code></pre> 
<p>基于这个key，服务器会在响应的Sec-WebSocket-Accept头中加一个基于这个key的计算数据。</p> 
<h6><a id="SecWebSocketProtocol_142"></a>Sec-WebSocket-Protocol</h6> 
<p>这个头会声明一个或者多个你想要使用的WebSocket协议。<br> 请求头发送Sec-WebSocket-Protocol，响应头也会返回Sec-WebSocket-Protocol。</p> 
<pre><code>Sec-WebSocket-Protocol: subprotocols
</code></pre> 
<p>subprotocols包括以下这些协议：https://www.iana.org/assignments/websocket/websocket.xml#subprotocol-name</p> 
<p>上面示例中的mqtt也在其中：<code>mqtt | mqtt | [MQTT Version 5.0]</code></p> 
<h6><a id="SecWebSocketVersion_154"></a>Sec-WebSocket-Version</h6> 
<p>作为请求头：<br> 声明客户端使用的WebSocket协议版本。</p> 
<pre><code>Sec-WebSocket-Version: version
</code></pre> 
<p>服务器与客户端通信的WebSocket协议版本：https://www.iana.org/assignments/websocket/websocket.xml#version-number</p> 
<p>最常用的是13。<br> <img src="https://images2.imgbox.com/75/0e/hsAxFR4j_o.png" alt="image"></p> 
<p>作为响应头：<br> 如果服务器不支持WebSocket协议，会返回类似426（Upgrade Required）并且在Sec-WebSocket-Version头中返回支持的WebSocket版本列表。如果不支持，不返回Sec-WebSocket-Version头。</p> 
<pre><code>Sec-WebSocket-Version: supportedVersions
</code></pre> 
<h6><a id="SecWebSocketAccept_172"></a>Sec-WebSocket-Accept</h6> 
<p>服务器与客户端建立握手过程中的响应头。至多出现一次：</p> 
<pre><code>Sec-WebSocket-Accept: hash
</code></pre> 
<p>如果有Sec-WebSocket-Key，将字符串“ 258EAFA5-E914-47DA-95CA-C5AB0DC85B11”连接到该字符串，并且取SHA-1的20位 hash值。最后进行base64编码。</p> 
<p>在我们的例子中：</p> 
<pre><code>Sec-WebSocket-Key: xxx
Sec-WebSocket-Accept: fNs9ByuvC+rD75+tj2GMQAzbJms=
</code></pre> 
<p>通过Sec-WebSocket-Key生成Sec-WebSocket-Accept的编码过程如下：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> SecWebSocketKey <span class="token operator">=</span> <span class="token string">"xxx"</span>
<span class="token keyword">const</span> helper <span class="token operator">=</span> <span class="token string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> SecWebSocketKey <span class="token operator">+</span> helper

<span class="token keyword">const</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> shasum <span class="token operator">=</span> crypto<span class="token punctuation">.</span><span class="token function">createHash</span><span class="token punctuation">(</span><span class="token string">'sha1'</span><span class="token punctuation">)</span>
shasum<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token keyword">const</span> SecWebSocketAccept <span class="token operator">=</span> shasum<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>SecWebSocketAccept<span class="token punctuation">)</span> <span class="token comment">// fNs9ByuvC+rD75+tj2GMQAzbJms=</span>
</code></pre> 
<p>在线demo：https://www.jdoodle.com/ia/e3G</p> 
<p>既然key到accept的算法已经很明晰了，那么可以通过accept反向求解出key吗？<br> 答案是否定的。这是因为用到了sha1加密。</p> 
<p>密码强哈希函数有两个特点:其中一个很重要的特点就是不可逆。不可逆性意味着原始数据无法从其散列中重建，所以不能通过accept反向求解出key。</p> 
<p>参考资料：</p> 
<p>https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101<br> https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism<br> https://stackoverflow.com/questions/6984139/how-can-i-get-the-sha1-hash-of-a-string-in-node-js<br> https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings<br> https://stackoverflow.com/questions/10918983/how-can-decode-sha1-code</p> 
<blockquote> 
 <p>文章首发于前端公众号：大大大前端</p> 
</blockquote> 
<p>努力成为优秀的前端开发工程师！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d578a92c096ad17cd4cc7726bec32e4d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue实现前端实现数据查询</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c2a99348a4c75cc481de058d7a0c0a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android 第三方圆弧进度条,android 可配置的圆弧进度条</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>