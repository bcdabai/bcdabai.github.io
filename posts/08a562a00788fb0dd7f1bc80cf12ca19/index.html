<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库和缓存如何保证一致性？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库和缓存如何保证一致性？" />
<meta property="og:description" content="📢📢📢📣📣📣
哈喽！大家好，我是【一心同学】，一位上进心十足的【Java领域博主】！😜😜😜
✨【一心同学】的写作风格：喜欢用【通俗易懂】的文笔去讲解每一个知识点，而不喜欢用【高大上】的官方陈述。
✨【一心同学】博客的领域是【面向后端技术】的学习，未来会持续更新更多的【后端技术】以及【学习心得】。
✨如果有对【后端技术】感兴趣的【小可爱】，欢迎关注【一心同学】💞💞💞
❤️❤️❤️感谢各位大可爱小可爱！❤️❤️❤️ 目录
前言
一、先更新数据库，还是先更新缓存？
🌴 先更新数据库，再更新缓存
🌴 先更新缓存，再更新数据库
🚀 小结
二、先更新数据库，还是先删除缓存？
🌵 旁路缓存策略
🌵 先删除缓存，再更新数据库
🌵 先更新数据库，再删除缓存
三、数据一致性解决方案
🌴 先更新数据库，再更新缓存
🌴 先删除缓存，再更新数据库
前言 在我们的项目开发中，为了提高数据的访问速度以及降低数据库负载，我们通常会将热点数据存储在缓存当中，像Redis缓存是基于内存的缓存系统，读取数据的速度非常快，通常可以在微秒级别内进行响应数据，但是由于缓存的存在，也同时引入了缓存与数据库的一致性问题，本文将进行解析如何保证其一致性。
本文针对数据不一致性提供四种策略进行解析，一心在这里就不卖关子了，先直接展开：
先更新缓存，再更新数据库。先更新数据库，再更新缓存。先删除缓存，再更新数据库。先更新数据库，再删除缓存。 四种策略无非就是先后顺序，一心把他总结为两个问题：
问题一：先更新数据库，还是先更新缓存？
问题二：先更新数据库，还是先删除缓存？
在这里，我们带着这两个问题来进行逐一展开。
一、先更新数据库，还是先更新缓存？ 🌴 先更新数据库，再更新缓存 流程：【请求A】先将数据库的数据更新为 1，然后在更新缓存前，【请求 B】 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 【请求A】更新缓存为 1。
此时，数据库中的数据是 2，而缓存中的数据却是 1，出现了缓存和数据库中的数据不一致的现象。（此方案在实际中不建议采用）
🌴 先更新缓存，再更新数据库 流程：【请求A】先将缓存的数据更新为 1，然后在更新数据库前，【请求B】来了， 将缓存的数据更新为 2，紧接着把数据库更新为 2，然后 【请求A】将数据库的数据更新为 1。
此时，数据库中的数据是 1，而缓存中的数据却是 2，出现了缓存和数据库中的数据不一致的现象。（此方案在实际中不建议采用）
🚀 小结 无论是【先更新数据库，再更新缓存】，还是【先更新缓存，再更新数据库】，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。
二、先更新数据库，还是先删除缓存？ 🌵 旁路缓存策略 对于不更新缓存，而是删除缓存中的数据。然后读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。我们将这种策略称为Cache Aside 策略，中文是叫旁路缓存策略。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/08a562a00788fb0dd7f1bc80cf12ca19/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-01T08:00:00+08:00" />
<meta property="article:modified_time" content="2023-09-01T08:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库和缓存如何保证一致性？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>📢📢📢📣📣📣</p> 
 <p><strong>哈喽！大家好</strong>，我是【<strong>一心同学</strong>】，一位上进心十足的【<strong>Java领域博主】！</strong>😜😜😜</p> 
 <p>✨【<strong>一心同学</strong>】的<strong>写作风格</strong>：喜欢用【<strong>通俗易懂</strong>】的文笔去讲解每一个知识点，而不喜欢用【<strong>高大上</strong>】的官方陈述。</p> 
 <p></p> 
 <p>✨【<strong>一心同学</strong>】博客的<strong>领域</strong>是【<strong>面向后端技术</strong>】的学习，未来会持续更新更多的【<strong>后端技术</strong>】以及【<strong>学习心得</strong>】。</p> 
 <p></p> 
 <p>✨如果有对【<strong>后端技术</strong>】感兴趣的【<strong>小可爱</strong>】，<strong>欢迎关注</strong>【<strong>一心同学</strong>】💞💞💞</p> 
 <p></p> 
 <p>❤️❤️❤️<strong>感谢各位大可爱小可爱！</strong>❤️❤️❤️ </p> 
</blockquote> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%9F" rel="nofollow">一、先更新数据库，还是先更新缓存？</a></p> 
<p id="%F0%9F%8C%B4%20%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B4%20%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98" rel="nofollow">🌴 先更新数据库，再更新缓存</a></p> 
<p id="%F0%9F%8C%B4%20%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B4%20%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow">🌴 先更新缓存，再更新数据库</a></p> 
<p id="%F0%9F%9A%80%20%E5%B0%8F%E7%BB%93-toc" style="margin-left:40px;"><a href="#%F0%9F%9A%80%20%E5%B0%8F%E7%BB%93" rel="nofollow">🚀 小结</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%9F" rel="nofollow">二、先更新数据库，还是先删除缓存？</a></p> 
<p id="%F0%9F%8C%B5%20%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B5%20%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5" rel="nofollow">🌵 旁路缓存策略</a></p> 
<p id="%F0%9F%8C%B5%20%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B5%20%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow">🌵 先删除缓存，再更新数据库</a></p> 
<p id="%F0%9F%8C%B5%20%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B5%20%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98" rel="nofollow">🌵 先更新数据库，再删除缓存</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="nofollow">三、数据一致性解决方案</a></p> 
<p id="%F0%9F%8C%B4%20%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B4%20%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98" rel="nofollow">🌴 先更新数据库，再更新缓存</a></p> 
<p id="%F0%9F%8C%B4%20%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B4%20%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow">🌴 先删除缓存，再更新数据库</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<blockquote> 
 <p>在我们的项目开发中，为了提高数据的访问速度以及降低数据库负载，我们通常会将热点数据存储在缓存当中，像Redis缓存是基于内存的缓存系统，读取数据的速度非常快，通常可以在微秒级别内进行响应数据，但是由于缓存的存在，也同时引入了<strong>缓存与数据库的一致性问题</strong>，本文将进行解析如何保证其一致性。</p> 
</blockquote> 
<p>本文针对数据不一致性提供四种策略进行解析，一心在这里就不卖关子了，先直接展开：</p> 
<ol><li>先更新缓存，再更新数据库。</li><li>先更新数据库，再更新缓存。</li><li>先删除缓存，再更新数据库。</li><li>先更新数据库，再删除缓存。</li></ol> 
<p>四种策略无非就是先后顺序，一心把他总结为两个问题：</p> 
<p><strong>问题一：<span style="color:#1a439c;">先更新数据库，还是先更新缓存？</span></strong></p> 
<p><strong>问题二：<span style="color:#1a439c;">先更新数据库，还是先删除缓存？</span></strong></p> 
<p>在这里，我们带着这两个问题来进行逐一展开。</p> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%9F">一、先更新数据库，还是先更新缓存？</h2> 
<h3 id="%F0%9F%8C%B4%20%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98">🌴 先更新数据库，再更新缓存</h3> 
<p><strong>流程</strong>：【<span style="color:#be191c;">请求A</span>】先将数据库的数据更新为 <strong>1</strong>，然后在更新缓存前，【<span style="color:#be191c;">请求 B</span>】 将数据库的数据更新为 <strong>2</strong>，紧接着也把缓存更新为 <strong>2</strong>，然后 【<span style="color:#be191c;">请求A</span>】更新缓存为 <strong>1</strong>。</p> 
<p>此时，数据库中的数据是 2，而缓存中的数据却是 1，<strong>出现了缓存和数据库中的数据不一致的现象</strong>。（此方案在实际中不建议采用）</p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/cd/e9/87TTbsyr_o.png" width="782"></p> 
<p></p> 
<h3 id="%F0%9F%8C%B4%20%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93">🌴 先更新缓存，再更新数据库</h3> 
<p><strong>流程</strong>：【<span style="color:#be191c;">请求A</span>】先将缓存的数据更新为 <strong>1</strong>，然后在更新数据库前，【<span style="color:#be191c;">请求B</span>】来了， 将缓存的数据更新为 <strong>2</strong>，紧接着把数据库更新为 <strong>2</strong>，然后 【<span style="color:#be191c;">请求A</span>】将数据库的数据更新为 <strong>1</strong>。</p> 
<p>此时，数据库中的数据是 1，而缓存中的数据却是 2，<strong>出现了缓存和数据库中的数据不一致的现象</strong>。（此方案在实际中不建议采用）</p> 
<p><img alt="" height="425" src="https://images2.imgbox.com/3c/b5/VTkjMbUH_o.png" width="762"></p> 
<p></p> 
<h3 id="%F0%9F%9A%80%20%E5%B0%8F%E7%BB%93">🚀 小结</h3> 
<blockquote> 
 <p>无论是【先更新数据库，再更新缓存】，还是【先更新缓存，再更新数据库】，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。</p> 
</blockquote> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%9F">二、先更新数据库，还是先删除缓存？</h2> 
<h3 id="%F0%9F%8C%B5%20%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5">🌵 旁路缓存策略</h3> 
<blockquote> 
 <p>对于不更新缓存，而是删除缓存中的数据。然后读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。我们将这种策略称为<strong>Cache Aside 策略</strong>，中文是叫旁路缓存策略。</p> 
</blockquote> 
<p>旁路缓存策略又可以细分为「<strong>读策略</strong>」和「<strong>写策略</strong>」。</p> 
<p><strong>写策略的步骤：</strong></p> 
<ul><li>更新数据库中的数据；</li><li>删除缓存中的数据。</li></ul> 
<p><strong>读策略的步骤：</strong></p> 
<ul><li>如果读取的数据命中了缓存，则直接返回数据；</li><li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li></ul> 
<p><img alt="" height="640" src="https://images2.imgbox.com/6f/97/ubE4nPG0_o.png" width="750"></p> 
<p></p> 
<p></p> 
<h3 id="%F0%9F%8C%B5%20%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93">🌵 先删除缓存，再更新数据库</h3> 
<p><strong>流程</strong>：现有一个数据初始值为<strong>20</strong>，【<span style="color:#be191c;">请求A</span>】此时要将数据更新为<strong>21</strong>，先执行删除缓存操作，此时，另一个【<span style="color:#be191c;">请求B</span>】要读取这个数据，查询缓存未命中后，会从数据库读取到该数据为<strong>20</strong>，并写入到缓存中，这时【<span style="color:#be191c;">请求A</span>】继续更改数据库，将数据进行更新为<strong>21</strong>。</p> 
<p>此时，缓存中的数据是<strong>20</strong>(旧值），而数据库中却是<strong>21</strong>（新值），缓存和数据库的数据不一致。</p> 
<p>所以<strong>先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题</strong>。（此方案在实际中不建议采用）</p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/03/29/X5zghqVN_o.png" width="774"></p> 
<p></p> 
<h3 id="%F0%9F%8C%B5%20%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98">🌵 先更新数据库，再删除缓存</h3> 
<p><strong>流程</strong>：假如某个数据在缓存中不存在，【<span style="color:#be191c;">请求 A</span>】 读取数据时从数据库中查询到其为 <strong>20</strong>，在未写入缓存中时另一个【<span style="color:#be191c;">请求 B</span>】 更新数据。它更新数据库中的数据为 <strong>21</strong>，并且清空缓存。这时【<span style="color:#be191c;">请求 A </span>】把从数据库中读到的 数据<strong>20</strong>写入到缓存中。</p> 
<p>最终，该数据在缓存中是 <strong>20</strong>（旧值），在数据库中是 <strong>21</strong>（新值），缓存和数据库数据不一致。</p> 
<p><img alt="" height="531" src="https://images2.imgbox.com/ba/e5/cRQT86d5_o.png" width="773"></p> 
<p></p> 
<p>从理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p> 
<p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。</p> 
<p>而一旦【<span style="color:#be191c;">请求 A</span>】 早于【<span style="color:#be191c;">请求 B</span>】 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p> 
<p>所以，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。</p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">三、数据一致性解决方案</h2> 
<h3>🌴 先更新数据库，再更新缓存</h3> 
<blockquote> 
 <p>先更新缓存，再更新数据库 也同理。</p> 
</blockquote> 
<p><strong>方案：</strong></p> 
<ul><li>在更新缓存前先加个<strong>分布式锁</strong>，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。</li><li>在更新完缓存时，给缓存加上较短的<strong>过期时间</strong>，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。</li></ul> 
<h3 id="%F0%9F%8C%B4%20%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93">🌴 先删除缓存，再更新数据库</h3> 
<p><strong>方案：</strong></p> 
<p>伪代码：</p> 
<pre><code class="language-bash">#删除缓存
redis.delKey(X)
#更新数据库
db.update(X)
#睡眠
Thread.sleep(N)
#再删除缓存
redis.delKey(X)</code></pre> 
<p><strong>「延迟双删」：</strong></p> 
<p>加个睡眠时间，主要是为了确保【请求 A】 在睡眠的时候，【请求 B】 能够在这这一段时间完成「<strong>从数据库读取数据，再把缺失的缓存写入缓存</strong>」的操作，然后【请求 A】 睡眠完，再删除缓存。</p> 
<p>所以，【请求 A】 的睡眠时间就需要大于【请求 B】 「<strong>从数据库读取数据 + 写入缓存</strong>」的时间。但具体睡眠多久，很难评估出来，所以这个方案也只是<strong>尽可能</strong>保证一致性而已，极端情况下，依然也会出现缓存不一致的现象。</p> 
<p></p> 
<p>故以上的所有策略中，最建议使用的还是「<strong>先更新数据库，再删除缓存</strong>」。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bc1014ec131adb1d4cb49360ba16c0a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unable to make field final int java.math.BigInteger.signum accessible: module java.base does not ***</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc57aa47ceb7661969bce00900aeb165/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Unity 顶点vertices，uv，与图片贴图，与mesh</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>