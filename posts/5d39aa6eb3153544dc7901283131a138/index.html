<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python 使用 with open() as 读写文件的操作方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python 使用 with open() as 读写文件的操作方法" />
<meta property="og:description" content="读文件: 要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：
1
&gt;&gt;&gt; f = open(&#39;E:\python\python\test.txt&#39;, &#39;r&#39;)
标示符&#39;r&#39;表示读，这样，我们就成功地打开了一个文件。
如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：
1
2
3
4
f=open(&#39;E:\python\python\notfound.txt&#39;, &#39;r&#39;)
Traceback (most recent call last):
File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
FileNotFoundError: [Errno 2] No such file or directory: &#39;E:\python\python\notfound.txt&#39;
如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：
1
2
&gt;&gt;&gt; f.read()
&#39;Hello, python!
最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：
1
&gt;&gt;&gt; f.close()
由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：
1
2
3
4
5
6
try:
f = open(&#39;/path/&#39;, &#39;r&#39;)
print(f.read())
finally:
if f:
f.close()
每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：
1
2" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5d39aa6eb3153544dc7901283131a138/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-20T13:10:59+08:00" />
<meta property="article:modified_time" content="2022-11-20T13:10:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python 使用 with open() as 读写文件的操作方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>读文件:</h3> 
<p>要以读文件的模式打开一个文件对象，使用Python内置的<code>open()</code>函数，传入文件名和标示符：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>&gt;&gt;&gt; f = open('E:\python\python\test.txt', 'r')</code></p> </td></tr></tbody></table> 
<p>标示符'r'表示读，这样，我们就成功地打开了一个文件。</p> 
<p>如果文件不存在，<code>open()</code>函数就会抛出一个<code>IOError</code>的错误，并且给出错误码和详细的信息告诉你文件不存在：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>f=open('E:\python\python\notfound.txt', 'r')</code></p> <p><code>Traceback (most recent call last):</code></p> <p><code>  </code><code>File "&lt;stdin&gt;", line 1, in &lt;module&gt;</code></p> <p><code>FileNotFoundError: [Errno 2] No such file or directory: 'E:\python\python\notfound.txt'</code></p> </td></tr></tbody></table> 
<p>如果文件打开成功，接下来，调用<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个<code>str</code>对象表示：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>&gt;&gt;&gt; f.read()</code></p> <p><code>'Hello, python!</code></p> </td></tr></tbody></table> 
<p>最后一步是调用<code>close()</code>方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>&gt;&gt;&gt; f.close()</code></p> </td></tr></tbody></table> 
<p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>try</code><code>:</code></p> <p><code>    </code><code>f </code><code>=</code> <code>open</code><code>(</code><code>'/path/'</code><code>, </code><code>'r'</code><code>)</code></p> <p><code>    </code><code>print</code><code>(f.read())</code></p> <p><code>finally</code><code>:</code></p> <p><code>    </code><code>if</code> <code>f:</code></p> <p><code>        </code><code>f.close()</code></p> </td></tr></tbody></table> 
<p>每次都这么写实在太繁琐，所以，Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>with open('/path/to/file', 'r') as f:</code></p> <p><code>    </code><code>print(f.read())</code></p> </td></tr></tbody></table> 
<p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p> 
<p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有20G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取size个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p> 
<p></p> 
<p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>for</code> <code>line </code><code>in</code> <code>f.readlines():</code></p> <p><code>    </code><code>print</code><code>(line.strip()) </code><code># 把末尾的'\n'删掉</code></p> </td></tr></tbody></table> 
<p><a name="_label1"></a></p> 
<h3>写文件</h3> 
<p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>'w'</code>或者<code>'wb'</code>表示写文本文件或写二进制文件：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>&gt;&gt;&gt; f = open('E:\python\python\test.txt', 'w')</code></p> <p><code>&gt;&gt;&gt; f.write('Hello, python!')</code></p> <p><code>&gt;&gt;&gt; f.close()</code></p> </td></tr></tbody></table> 
<p>可以反复调用<code>write()</code>来写入文件，但是务必要调用<code>f.close()</code>来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用<code>close()</code>的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用<code>with</code>语句来得保险：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>with open('E:\python\python\test.txt', 'w') as f:</code></p> <p><code>    </code><code>f.write('Hello, python!')</code></p> </td></tr></tbody></table> 
<p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码</p> 
<p><a name="_label2"></a></p> 
<h3>字符编码</h3> 
<p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数，例如，读取GBK编码的文件：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>&gt;&gt;&gt; f = open('E:\python\python\gbk.txt', 'r', encoding='gbk')</code></p> <p><code>&gt;&gt;&gt; f.read()</code></p> <p><code>'测试'</code></p> </td></tr></tbody></table> 
<p>遇到有些编码不规范的文件，你可能会遇到<code>UnicodeDecodeError</code>，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，<code>open()</code>函数还接收一个<code>errors</code>参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>&gt;&gt;&gt; f = open('E:\python\python\gbk.txt', 'r', encoding='gbk', errors='ignore')</code></p> </td></tr></tbody></table> 
<p><a name="_label3"></a></p> 
<h3>二进制文件</h3> 
<p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用<code>'rb'</code>模式打开文件即可：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>&gt;&gt;&gt; f = open('E:\python\python\test.jpg', 'rb')</code></p> <p><code>&gt;&gt;&gt; f.read()</code></p> <p><code>b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节</code></p> </td></tr></tbody></table> 
<p><strong>总结：以后读写文件尽量使用with open语句，少使用f = open()语句</strong></p> 
<p><strong>对于多个文件的读写，可以写成以下两种方式：</strong></p> 
<p><strong>1、</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>with open('C:\Desktop\text.txt','r') as f:</code></p> <p><code>    </code><code>with open('C:\Desktop\text1.txt','r') as f1:</code></p> <p><code>        </code><code>with open('C:\Desktop\text2.txt','r') as f2　　　　　　</code></p> <p><code>        </code><code>........　　　　　　　</code></p> <p><code>        </code><code>........　　　　　　　</code></p> <p><code>        </code><code>........</code></p> </td></tr></tbody></table> 
<p><strong>2、</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>with open(''C:\Desktop\text.txt','r') as f:</code></p> <p><code>........</code></p> <p><code>with open(''C:\Desktop\text1.txt','r') as f1:</code></p> <p><code>........</code></p> <p><code>with open('C:\Desktop\text2.txt','r') as f2:</code></p> <p><code>........</code></p> </td></tr></tbody></table> 
<p><strong>文件的读写方式列表：</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/52/39/KigiClXt_o.jpg"></p> 
<p><a name="_label4"></a></p> 
<h3><strong>File 对象属性：</strong></h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3d/93/OlkoYjjU_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/44cc0e7f6e166a768f06b93c4cfb6501/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu22.04 Zabbix6.0 替换国内阿里云源</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/496038b482248d5e52fe34a7d578bcb3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据—Hadoop（二十二）_ 生产调优手册_05、MapReduce</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>