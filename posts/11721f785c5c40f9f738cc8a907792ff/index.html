<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件设计师上午题#2程序设计语言zst_2001 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件设计师上午题#2程序设计语言zst_2001" />
<meta property="og:description" content="一. 编译程序和解释程序 1.1 教材重点内容，看一遍就行 低级语言和高级语言
计算机硬件只能识别由 0、1组成的机器指令序列，即机器指令程序，因此机器指令是最基本的计算机语言。由于机器指令是特定的计算机系统所固有的、面向机器的语言，所以用机器语言进行程序设计时效率很低，程序的可读性很差，也难以修改和维护。因此，人们就用容易记忆的符号代替0、1序列来表示机器指令，例如，用 ADD 表示加法、用SUB 表示减法等。用符号表示的指令称为汇编指令，汇编指令的集合被称为汇编语言。汇编语言与机器语言十分接近，其书写格式在很大程度上取决于特定计算机的机器指令，因此它仍然是一种面向机器的语言，人们称机器语言和汇编语言为低级语言。在此基础上，人们开发了功能更强、抽象级别更高的语言以支持程序设计，于是就产生了面向各类应用的程序设计语言，称为高级语言。常见的有 Java、C、C&#43;&#43;、PHP、Python、Delphi、PASCAL 等。这类语言与人们使用的自然语言比较接近，提高了程序设计的效率。
编译程序和解释程序
计算机只能理解由0、1序列构成的机器语言，因此高级程序设计语言需要翻译，担负这一任务的程序称为 “语言处理程序”。语言之间的翻译形式有多种，基本方式为汇编、解释和编译。
用某种高级语言或汇编语言编写的程序称为源程序，源程序不能直按在计算机上执行。如果源程序是用汇编语言编写的，则需要一个汇编程序将其翻译成目标程序后才能执行。如果源程序是用某种高级语言编写的，则需要对应的解释程序或编译程序对其进行翻译，然后在机器上运行。
解释程序也称为解释器，它或者直按解释执行源程序，或者将源程序翻译成某种中间代码后再加以执行；而编译程序（编译器）则是将源程序翻译成目标语言程序，然后在计算机上运行目标程序。这两种语言处理程序的根本区别是：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程：而在解释方式下，解释程序和源程序(或其某种等价表示）要参与到程序的运行过程中，运行程序的控制权在解释程序。简单来说，在解释方式下，翻译源程序时不生成独立的目标程序，而编译器则将源程序翻译成独立保存的目标程序。
1.2重点总结 解释器：
翻译源程序时不生成独立的目标程序
解释程序和源程序要参与到程序的运行过程中
编译器：
翻译时将源程序翻译成独立的目标程序
机器上运行的是于源程序等价的目标程序，
源程序和编译程序都不再参与目标程序的运行过程
二. 程序设计语言基本成分 2.1 教材重点内容 2.1.2程序设计语言的基本成分
程序设计语言的基本成分包括数据、运算、控制和传输等。
1.程序设计语言的数据成分
程序设计语言的数据成分指一种程序设计语言的数据类型。数据对象总是对应着应用系统中某些有意义的东西，数据表示则指明了程序中值的组织形式。数据类型用于代表数据对象，还用于在基础机器中完成对值的布局，同时还可用于检查表达式中对运算的应用是否正确。
数据是程序操作的对象，具有存储类别、类型、名称、作用域和生存期等属性，在使用时要为它分配内存空间。数据名称由用户通过标识符命名，标识符是由字母、数字和下划线“”组成的标记：类型说明数据占用内存的大小和存放形式：存储类别说明数据在内存中的位置和生存期：作用域则说明可以使用数据的代码范围：生存期说明数据占用内存的时间特点。从不同角度可将数据进行不同的划分。
1)常量和变量
按照程序运行时数据的值能否改变，将数据分为常量和变量。程序中的数据对象可以具有左值和（或）右值，左值指存储单元(或地址、容器)，右值是值（或内容）。变量具有左值和右值，在程序运行过程中其右值可以改变：常量只有右值，在程序运行过程中其右值不能改变。
2)全局量和局部量
数据按在程序代码中的作用范围（作用域）可分为全局量和局部量。一般情况下，全局变量的作用域为整个文件或程序，系统为全局变量分配的存储空间在程序运行的过程中是不改变的，局部变量的作用域为定义它的函数或语句块，为局部变量分配的存储单元是动态改变的。
3)数据类型
按照数据组织形式的不同可将数据分为基本类型、用户定义类型、构造类型及其他类型。
C(C&#43;&#43;)的数据类型如下。
(1)基本类型：整型(int)、字符型(char)、实型(foat、double)和布尔类型(bool).
(2)特殊类型：空类型(void).
(3)用户定义类型：枚举类型(enum).
(4)构造类型：数组、结构、联合。
(5)指针类型：ype*。
(6)抽象数据类型：类类型。
其中，布尔类型和类类型由C&#43;&#43;语言提供。
3.程序设计语言的控制成分
控制成分指明语言允许表述的控制结构，程序员使用控制成分来构造程序中的控制逻辑。理论上已经证明，可计算问题的程序都可以用顺序、选择和循环这3种控制结构来描述。
1)顺序结构
顺序结构用来表示一个计算操作序列。计算过程从所描述的第一个操作开始，按顺序依次执行后续的操作，直到序列的最后一个操作，如图2-1所示。在顺序结构内也可以包含其他控
制结构。
2)选择结构
选择结构提供了在两种或多种分支中选择其中一个的逻辑。基本的选择结构是指定一个条件P,然后根据条件的成立与否决定控制流计算A还是计算B,从两个分支中选择一个执行，如图2-2（a）所示。选择结构中的计算A或计算B还可以包含顺序、选择和重复结构。程序设计语言中还通常提供简化了的选择结构，也就是没有计算B的分支结构，如图2-2(b)所示。
3)循环结构
循环结构描述了重复计算的过程，通常由三部分组成：初始化、循环体和循环条件，其中初始化部分有时在控制的逻辑结构中不进行显式的表示。循环结构主要有两种形式：while型循环结构和do-while型循环结构。while型结构的逻辑含义是先判断条件P,若成立，则执行循环体A,然后再去判断循环条件，否则控制流就退出重复结构，如图2-3(a)所示。do-while型结构的逻辑含义是先执行循环体A,再判断条件P,若成立则继续执行A,然后再判断条件P,否则控制流就退出循环结构，如图2-3(b)所示。
三. 传值调用与传地址调用 函数定义
函数的定义包括两部分：函数首部和函数体。函数的定义描述了函数做什么和怎么做。函数定义的一般形式为：
返回值类型 函数名 （形式参数表） //函数首部 函数名（实参表）；
{
函数体;
}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/11721f785c5c40f9f738cc8a907792ff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-17T19:09:06+08:00" />
<meta property="article:modified_time" content="2022-11-17T19:09:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件设计师上午题#2程序设计语言zst_2001</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="__0"></a>一. 编译程序和解释程序</h3> 
<h4><a id="11__1"></a>1.1 教材重点内容，看一遍就行</h4> 
<ol><li> <p>低级语言和高级语言<br> 计算机硬件只能识别由 0、1组成的机器指令序列，即机器指令程序，因此机器指令是最基本的计算机语言。由于机器指令是特定的计算机系统所固有的、面向机器的语言，所以用机器语言进行程序设计时效率很低，程序的可读性很差，也难以修改和维护。因此，人们就用容易记忆的符号代替0、1序列来表示机器指令，例如，用 ADD 表示加法、用SUB 表示减法等。用符号表示的指令称为汇编指令，汇编指令的集合被称为汇编语言。汇编语言与机器语言十分接近，其书写格式在很大程度上取决于特定计算机的机器指令，因此它仍然是一种面向机器的语言，人们称机器语言和汇编语言为低级语言。在此基础上，人们开发了功能更强、抽象级别更高的语言以支持程序设计，于是就产生了面向各类应用的程序设计语言，称为高级语言。常见的有 <mark>Java、C、C++、PHP、Python、Delphi、PASCAL</mark> 等。这类语言与人们使用的自然语言比较接近，提高了程序设计的效率。</p> </li><li> <p>编译程序和解释程序<br> 计算机只能理解由0、1序列构成的机器语言，因此高级程序设计语言需要翻译，担负这一任务的程序称为 “语言处理程序”。语言之间的翻译形式有多种，基本方式为汇编、解释和编译。<br> 用某种高级语言或汇编语言编写的程序称为源程序，源程序不能直按在计算机上执行。如果源程序是用汇编语言编写的，则需要一个汇编程序将其翻译成目标程序后才能执行。如果源程序是用某种高级语言编写的，则需要对应的解释程序或编译程序对其进行翻译，然后在机器上运行。<br> 解释程序也称为解释器，它或者直按解释执行源程序，或者将源程序翻译成某种中间代码后再加以执行；而编译程序（编译器）则是将源程序翻译成目标语言程序，然后在计算机上运行目标程序。这两种语言处理程序的根本区别是：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程：而在解释方式下，解释程序和源程序(或其某种等价表示）要参与到程序的运行过程中，运行程序的控制权在解释程序。简单来说，在解释方式下，翻译源程序时不生成独立的目标程序，而编译器则将源程序翻译成独立保存的目标程序。</p> </li></ol> 
<h4><a id="12_11"></a>1.2<mark>重点总结</mark></h4> 
<ol><li> <p>解释器：<br> 翻译源程序时不生成独立的目标程序<br> 解释程序和源程序要参与到程序的运行过程中</p> </li><li> <p>编译器：<br> 翻译时将源程序翻译成独立的目标程序<br> 机器上运行的是于源程序等价的目标程序，<br> 源程序和编译程序都不再参与目标程序的运行过程</p> </li></ol> 
<h3><a id="__21"></a>二. 程序设计语言基本成分</h3> 
<h4><a id="21__22"></a>2.1 教材重点内容</h4> 
<ul><li>2.1.2程序设计语言的基本成分<br> 程序设计语言的基本成分包括数据、运算、控制和传输等。<br> 1.程序设计语言的数据成分<br> 程序设计语言的数据成分指一种程序设计语言的数据类型。数据对象总是对应着应用系统中某些有意义的东西，数据表示则指明了程序中值的组织形式。数据类型用于代表数据对象，还用于在基础机器中完成对值的布局，同时还可用于检查表达式中对运算的应用是否正确。<br> 数据是程序操作的对象，具有存储类别、类型、名称、作用域和生存期等属性，在使用时要为它分配内存空间。数据名称由用户通过标识符命名，标识符是由字母、数字和下划线“”组成的标记：类型说明数据占用内存的大小和存放形式：存储类别说明数据在内存中的位置和生存期：作用域则说明可以使用数据的代码范围：生存期说明数据占用内存的时间特点。从不同角度可将数据进行不同的划分。<br> 1)常量和变量<br> 按照程序运行时数据的值能否改变，将数据分为常量和变量。程序中的数据对象可以具有左值和（或）右值，左值指存储单元(或地址、容器)，右值是值（或内容）。变量具有左值和右值，在程序运行过程中其右值可以改变：常量只有右值，在程序运行过程中其右值不能改变。<br> 2)全局量和局部量<br> 数据按在程序代码中的作用范围（作用域）可分为全局量和局部量。一般情况下，全局变量的作用域为整个文件或程序，系统为全局变量分配的存储空间在程序运行的过程中是不改变的，局部变量的作用域为定义它的函数或语句块，为局部变量分配的存储单元是动态改变的。<br> 3)数据类型<br> 按照数据组织形式的不同可将数据分为基本类型、用户定义类型、构造类型及其他类型。<br> C(C++)的数据类型如下。<br> (1)基本类型：整型(int)、字符型(char)、实型(foat、double)和布尔类型(bool).<br> (2)特殊类型：空类型(void).<br> (3)用户定义类型：枚举类型(enum).<br> (4)构造类型：数组、结构、联合。<br> (5)指针类型：ype*。<br> (6)抽象数据类型：类类型。<br> 其中，布尔类型和类类型由C++语言提供。<br> 3.程序设计语言的控制成分<br> 控制成分指明语言允许表述的控制结构，程序员使用控制成分来构造程序中的控制逻辑。理论上已经证明，可计算问题的程序都可以用顺序、选择和循环这3种控制结构来描述。<br> <mark>1)顺序结构</mark><br> 顺序结构用来表示一个计算操作序列。计算过程从所描述的第一个操作开始，按顺序依次执行后续的操作，直到序列的最后一个操作，如图2-1所示。在顺序结构内也可以包含其他控<br> 制结构。<br> <mark>2)选择结构</mark><br> 选择结构提供了在两种或多种分支中选择其中一个的逻辑。基本的选择结构是指定一个条件P,然后根据条件的成立与否决定控制流计算A还是计算B,从两个分支中选择一个执行，如图2-2（a）所示。选择结构中的计算A或计算B还可以包含顺序、选择和重复结构。程序设计语言中还通常提供简化了的选择结构，也就是没有计算B的分支结构，如图2-2(b)所示。<br> <mark>3)循环结构</mark><br> 循环结构描述了重复计算的过程，通常由三部分组成：初始化、循环体和循环条件，其中初始化部分有时在控制的逻辑结构中不进行显式的表示。循环结构主要有两种形式：while型循环结构和do-while型循环结构。while型结构的逻辑含义是先判断条件P,若成立，则执行循环体A,然后再去判断循环条件，否则控制流就退出重复结构，如图2-3(a)所示。do-while型结构的逻辑含义是先执行循环体A,再判断条件P,若成立则继续执行A,然后再判断条件P,否则控制流就退出循环结构，如图2-3(b)所示。<br> <img src="https://images2.imgbox.com/4d/5c/CYRQH0uL_o.jpg" alt="在这里插入图片描述"></li></ul> 
<h3><a id="__52"></a>三. 传值调用与传地址调用</h3> 
<ol><li>函数定义<br> 函数的定义包括两部分：函数首部和函数体。函数的定义描述了函数做什么和怎么做。函数定义的一般形式为：<br> 返回值类型</li></ol> 
<blockquote> 
 <p>函数名 （形式参数表） //函数首部 函数名（实参表）；<br> {<!-- --><br> 函数体;<br> }</p> 
</blockquote> 
<ol start="2"><li>传值调用：<br> 将实参的值传递给形参，实参可以是变量、常量和表达式。<br> 不可以实现形参和实参间双向传递数据的效果<br> 传引用（地址）调用：<br> 将实参的地址传递给形参，形参必须有地址，实参不能是常量（值），表达式。<br> 可以实现形参和实参间双向传递数据的效果，即改变形参的值同时也改变了实参的值。</li></ol> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 代码实现</li></ul> 
<pre><code class="prism language-c">
</code></pre> 
<h3><a id="__74"></a>四. 编译、解释程序翻译阶段</h3> 
<ol><li>编译方式：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成<br> 解释方式：词法分析、语法分析、语义分析<br> <strong>编译器和解释器都不可省略词法分析、语法分析、语义分析且顺序不可交换<br> 编译器方式中中间代码生成和代码优化不是必要，可省略。</strong><br> 即编译器方式可以在词法分析、语法分析、语义分析阶段后直接生成目标代码</li></ol> 
<ul><li> <p>解释器：<br> 翻译源程序时不生成独立的目标程序<br> 解释程序和源程序要参与到程序的运行过程中</p> </li><li> <p>编译器：<br> 翻译时将源程序翻译成独立保存的目标程序<br> 机器上运行的是与源程序等价的目标程序，<br> 源程序和编译程序都不再参与目标程序的运行过程</p> </li></ul> 
<p><img src="https://images2.imgbox.com/f3/ac/Ajzp5vNL_o.jpg" alt=""></p> 
<h3><a id="___91"></a>五. 符号表</h3> 
<ol><li>符号表：<br> 不断收集、记录和使用源程序中一些相关符号的类型和特征等信息，并将其存入符号表中。记录源程序中各个字符的必要信息，以辅助语义的正确性检查和代码生成。符号表的使用贯穿6个过程，分别是：词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成。</li></ol> 
<ul><li>课本符号表内容：<br> 7） 符号表管理<br> <em>符号表的作用是记录源程序中的各个符号的必要信息，以辅助语义的正确性检查和代码生成，在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。符号表的建立可以始于词法分析阶段，也可以放到语法分析和语义分析阶段，但符号表的使用有时会延续到目标代码的运行阶段。</em></li></ul> 
<h3><a id="__98"></a>六. 编译程序基本原理</h3> 
<h4><a id="61_99"></a>6.1词法分析</h4> 
<ul><li>源程序可以简单地被看成是一个多行的字符串。词法分析阶段是编译过程的第一个阶段，这个阶段的任务是对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号。“单词’符号是程序设计语言的基本语法单位，如关键字（或称保留字）、标识符、常数、运算符和分隔符（如标点符号、左右括号）等。词法分析程序输出的“单词”常以二元组的方式输出，即单词种别和单词自身的值。<br> 词法分析过程依据的是语言的词法规则，即描述“单词”结构的规则。例如，对于某PASCAL<br> 源程序中的一条声明语句和赋值语句：<br> VAR X,Y,Z:real;<br> X:=Y+Z*60;<br> 词法分析阶段将构成这条语句的字符串分割成如下的单词序列。<br> <img src="https://images2.imgbox.com/f0/83/LtsdSVBb_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1c/30/dGvVVEH8_o.jpg" alt="在这里插入图片描述"></li></ul> 
<h4><a id="62_110"></a>6.2语法分析</h4> 
<p>2）语法分析<br> 语法分析的任务是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位，如“表达式”“语句”和“程序”等。语法规则就是各类语法单位的构成规则。通过语法分析确定整个输入串是否构成一个语法上正确的程序。如果源程序中没有语法错误，语法分析后就能正确地构造出其语法树；否则指出语法错误，并给出相应的诊断信息。对id1:=id2 id3*60进行语法分析后形成的语法树如图2-5所示。<br> <img src="https://images2.imgbox.com/ae/ea/nbceNS6q_o.jpg" alt="在这里插入图片描述"><br> 词法分析和语法分析在本质上都是对源程序的结构进行分析。</p> 
<h4><a id="63_115"></a>6.3语义分析</h4> 
<p>3)语义分析</p> 
<ul><li>语义分析阶段分析各语法结构的含义，检查源程序是否包含静态语义错误，并收集类型信息供后面的代码生成阶段使用。只有语法和语义都正确的源程序才能翻译成正确的目标代码。语义分析的一个主要工作是进行类型分析和检查。程序设计语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。例如，整除取余运算符只能对整型数据进行运算，若其运算对象中有浮点数就认为是类型不匹配的错误。</li><li>在确认源程序的语法和语义之后，即可对其进行翻译并给出源程序的内部表示。对于声明语句，需要记录所遇到的符号的信息，所以应进行符号表的填查工作。在图2-6所示的符号表中，每一行存放一个符号的信息。第一行存放标识符X的信息，其类型为eal,为它分配的逻辑地址是0：第二行存放Y的信息，其类型是real,为它分配的逻辑地址是4。在这种语言中，为一个ral型数据分配的存储空间是4个存储单元。对于可执行语句，则检查结构合理的表达式是否有意义。对id1:=id2 id3*60进行语义分析后的语法树如图2-6所示，其中增加了一个语义处理结点inttoreal,该运算用于将一个整型数转换为浮点数。</li></ul> 
<h4><a id="64_119"></a>6.4目标代码生成</h4> 
<p>6)目标代码生成<br> 目标代码生成是编译器工作的最后一个阶段。这一阶段的任务是把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码，这个阶段的工作与具体的机器密<br> 切相关。例如，使用两个寄存器R1和R2,可对上述的四元式生成下面的目标代码：<br> <img src="https://images2.imgbox.com/08/1f/oTqq7N4r_o.jpg" alt="在这里插入图片描述">这里用#表明60.0为常数。</p> 
<p>(3)寄存器的分配。由于访问寄存器的速度远远快于访问内存单元的速度，所以人们总是希望尽可能多地使用寄存器存储数据，而寄存器的个数是有限的，因此，如何分配及使用寄存器是目标代码生成时需要着重考虑的。</p> 
<h4><a id="64__127"></a>6.4 总结</h4> 
<p>词法分析<br> 输入：源程序；输出：记号流<br> 词法分析阶段的主要作用是：<br> 分析构成程序的字符；及由字符按照构造规则构成的符号是否符合程序语言的规定</p> 
<p>语法分析<br> 输入：记号流；输出：语法树（分析树）<br> 语法分析阶段可以发现程序中所有的语法错误<br> 语法分析阶段的主要作用是：<br> 对各条语句的结构进行合法性分析；分析程序中的句子结构是否正确</p> 
<p>语义分析<br> 输入：语法树（分析树）<br> 语义分析阶段的主要作用是进行类型分析和检查</p> 
<p>语法分析阶段可以发现程序中的所有语法错误<br> 语义分析阶段不能发现程序中所有的语义错误<br> 语义分析阶段可以发现静态语义错误<br> 不能发现动态语义错误，动态语义错误运行时才能发现</p> 
<p>目标代码生成<br> 目标代码生成阶段的工作与具体的机器密切相关<br> 寄存器的分配工作处于目标代码生成阶段</p> 
<h3><a id="_153"></a>七.中间代码生成</h3> 
<ol><li>教材重点内容：<br> 中间代码生成阶段的工作是根据语义分析的输出生成中间代码。“中间代码”是一种简单且含义明确的记号系统，可以有若干种形式，它们的共同特征是与机器无关。最常用的一种中间代码是与汇编语言的指令非常相识的三地址码，其实现方式常采用四元式。四元式的形式为：（运算符，运算对象1，运算对象2，运算结果）<br> 例如，对于语句X:=Y+Z*60,可生成以下四元式序列：</li></ol> 
<table><thead><tr><th>1</th><th>（inttoreal,60,-,tl )</th></tr></thead><tbody><tr><td>2</td><td>(*, id3,tl,t2)</td></tr><tr><td>3</td><td>(+, id2,t2,t3)</td></tr><tr><td>4</td><td>(:=,t3,-,idl)</td></tr></tbody></table> 
<p>其中，t1、2、3是编译程序生成的临时变量，用于存放临时的运算结果。<br> 语义分析和中间代码生成所依据的是语言的语义规则。</p> 
<ol start="2"><li><mark>重点总结</mark><br> 常见的中间代码有：后缀式、三地址码、三元式、四元式和树（图）等形式。<br> 中间代码与具体的机器无关（不依赖具体的机器），可以将不同的高级程序语言翻译成同一种中间代码。中间代码可以跨平台。<br> 因为与具体的机器无关，使用中间代码有利于进行与机器无关的优化处理和提高编译程序的可移植性。</li></ol> 
<h3><a id="_174"></a>八.正规式</h3> 
<p><img src="https://images2.imgbox.com/ab/24/dFntAwfe_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>没有星号就是出现一次<br> “ * ”代表出现一次或者多次<br> “ | ” 代表二者选其一<br> 这种类型的题目使用假设法，假设它出现多少次，然后排除法</p> 
</blockquote> 
<h3><a id="_182"></a>九.有限自动机</h3> 
<p>有限自动机是词法分析的一个工具，它能正确地识别正规集</p> 
<ul><li>确定的有限自动机（DFA）：对每一个状态来说识别字符后只有一个转移状态</li><li>不确定的有限自动机（NFA）：对每一个状态来说识别字符后有一个以上的转移状态</li><li>做题总结：我认为用排除法做题，一个一个去排除，只要能到达终态的选项就行。</li></ul> 
<p><img src="https://images2.imgbox.com/3a/2e/YhscPyWP_o.jpg" alt="在这里插入图片描述"></p> 
<p>例如：串（010）可以被自动机识别，串（000）不能被自动机识别<br> <img src="https://images2.imgbox.com/a0/e5/lNpZmQGv_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="_193"></a>十.上下文无关文法</h3> 
<p>1)上下文无关文法<br> 上下文无关文法属于乔姆斯基定义的2型文法，<strong>被广泛地用于表示各种程序设计语言的语法规则</strong>。对于上下文无关文法，G[S=(VxV,P,S,其产生式的形式都是A→B,其中A∈V,<br> B∈(WxU’r)'。<br> 若不加特别说明，下面用大写英文字母A、B、C等表示非终结符，小写英文字母a、b、c等表示终结符号，u、v、w等表示终结符号串，小写希腊字母a、B、八6等表示终结符和非终结符混合的文法符号串。由于一个上下文无关文法的核心部分是其产生式集合，所以文法可以简写为其产生式集合的描述形式。<br> <img src="https://images2.imgbox.com/8d/6a/ksBznbmA_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>E是开始符号，N是结束符，|是或者，一直需要推导到结束</p> 
</blockquote> 
<h3><a id="__201"></a>十一. 中缀、后缀表达式转换</h3> 
<ol><li>转换优先级</li></ol> 
<blockquote> 
 <p>从高到低<br> （）&gt; * &gt; \ &gt;+、-<br> 优先级相同从右向左</p> 
</blockquote> 
<table><thead><tr><th>中缀式</th><th>后缀式</th></tr></thead><tbody><tr><td>a?b</td><td>ab?</td></tr><tr><td>1+2</td><td>12+</td></tr><tr><td>1-2</td><td>12-</td></tr><tr><td>1*2</td><td>12*</td></tr><tr><td>2/1</td><td>21/</td></tr></tbody></table> 
<ol start="2"><li> <p>中缀式转后缀式<br> <img src="https://images2.imgbox.com/b2/30/t7YAjHtm_o.png" alt="在这里插入图片描述"></p> </li><li> <p>后缀式转中缀式<br> <img src="https://images2.imgbox.com/03/b2/wuhaRey4_o.png" alt="在这里插入图片描述"></p> </li><li> <p>语法树中后序遍历</p> </li></ol> 
<blockquote> 
 <p>中缀式就是中序遍历<br> 后缀式就是后序遍历</p> 
</blockquote> 
<table><thead><tr><th>遍历</th><th>方式</th></tr></thead><tbody><tr><td>前序遍历</td><td>根左右</td></tr><tr><td>中序遍历</td><td>左根右</td></tr><tr><td>后序遍历</td><td>左右根</td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/70/a7/QGms4IK6_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c4b912550594abb745eb5a1acf04781e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Quartus 实例应用（2）——创建设计工程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/28bdc8bf608f429005c31662eda8060d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>