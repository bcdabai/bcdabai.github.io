<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言--函数指针的用法总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言--函数指针的用法总结" />
<meta property="og:description" content="函数指针的由来 一个函数在编译时被分配一个入口地址，这个入口地址就称为函数的指针。
函数名代表函数的入口地址，这一点和数组一样。我们可以用一个指针变量来存放这个入口地址，然后通过该指针变量调用函数。如：假设有一个求两者较大的函数如下：
int max(int x, int y); 当我们调用这个函数时可以这样：
int c; c max(a,b); 这是通常调用方法，其实我们还可以定义一个函数指针，通过指针来调用，如：
int (*p)(a,b); 有些朋友可能对(*p)()不大理解，其实它的意思就是定义一个指向函数的指针变量p,p不是固定指向哪个函数的，而是专门用来存放函数入口地址的变量。在程序中把哪个函数入口地址赋给它，它就指向哪个函数。但是注意，p不能像指向变量的指针变量一样进行p&#43;&#43;p--等无意义的操作。
既然p是一个指针变量，那么久可以作为函数的参数进行传递。其实函数的指针变量最常用的用途之一就是作为函数参数传递到其它函数。这也是c语言中应用的比较深入的部分了。
函数指针的定义 函数指针就是指向函数的指针变量。 因此“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。如上所述，C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。
函数指针有两个用途：调用函数和做函数的参数。
函数指针的用法 第一种用法（1.c）
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void (*pfun)(int data); void myfun(int data) { printf(&#34;get data:%d\n&#34;,data); } int main(int argc,char *argv[]) { pfun = myfun; (*pfun)(100); return 0; } 从这个例子可以看到，我们首先定义了一个函数指针 pfun ,这个函数指针的返回值为void型,然后我们给函数指针赋值，赋值为 myfun,也就是myfun函数的首地址，在C99中myfun函数名就是myfun函数的首地址，此时 pfun 获得了 myfun 的地址，pfun的地址等于myfun的地址，所以最终调用 pfun();也就相当于调用了 myfun();
第二种用法 (2.c)
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef void (*pfun)(int data); /*typedef的功能是定义新的类型。第一句就是定义了一种 pfun 的类型，并定义这种类型为指向某种函数的指针，这种函数以一个 int 为参数并返回 void 类型。*/ void myfun(int data) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a17681fc7fbc8084a0ee72b0c96079fa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-15T21:54:22+08:00" />
<meta property="article:modified_time" content="2018-05-15T21:54:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言--函数指针的用法总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>函数指针的由来</h4> 
<p>一个函数在编译时被分配一个入口地址，这个入口地址就称为函数的指针。</p> 
<p>函数名代表函数的入口地址，这一点和数组一样。我们可以用一个指针变量来存放这个入口地址，然后通过该指针变量调用函数。如：假设有一个求两者较大的函数如下：</p> 
<pre><code class="language-cpp">int max(int x, int y);</code></pre> 
<p>当我们调用这个函数时可以这样：</p> 
<pre class="has"><code class="language-cpp">int c;
c max(a,b);</code></pre> 
<p>这是通常调用方法，其实我们还可以定义一个函数指针，通过指针来调用，如：</p> 
<pre class="has"><code class="language-cpp">int (*p)(a,b);</code></pre> 
<p>有些朋友可能对(*p)()不大理解，其实它的意思就是定义一个指向函数的指针变量p,p不是固定指向哪个函数的，而是专门用来存放函数入口地址的变量。在程序中把哪个函数入口地址赋给它，它就指向哪个函数。但是注意，p不能像指向变量的指针变量一样进行p++p--等无意义的操作。<br> 既然p是一个指针变量，那么久可以作为函数的参数进行传递。其实函数的指针变量最常用的用途之一就是作为函数参数传递到其它函数。这也是c语言中应用的比较深入的部分了。</p> 
<hr> 
<h4>函数指针的定义</h4> 
<p>函数指针就是指向函数的指针变量。 因此“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。如上所述，C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p> 
<p>函数指针有两个用途：调用函数和做函数的参数。</p> 
<h4>函数指针的用法</h4> 
<p><strong>第一种用法（1.c）</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void (*pfun)(int data);
void myfun(int data)
{
	printf("get data:%d\n",data);
}
int main(int argc,char *argv[])
{
	pfun = myfun;
	(*pfun)(100);
	return 0;
}</code></pre> 
<p>从这个例子可以看到，我们首先定义了一个函数指针 pfun ,这个函数指针的返回值为void型,然后我们给函数指针赋值，赋值为 myfun,也就是myfun函数的首地址，在C99中myfun函数名就是myfun函数的首地址，此时 pfun 获得了 myfun 的地址，pfun的地址等于myfun的地址，所以最终调用 pfun();也就相当于调用了 myfun();</p> 
<p><strong>第二种用法 (2.c)</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef void (*pfun)(int data);
/*typedef的功能是定义新的类型。第一句就是定义了一种 pfun 的类型，并定义这种类型为指向某种函数的指针，这种函数以一个 int 为参数并返回 void 类型。*/
void myfun(int data)
{
	printf("get data:%d\n",data);
}
int main(int argc,char *argv[])
{
	pfun p= myfun;      //函数指针指向执行函数的地址
	p(100);
	return 0;
}</code></pre> 
<p>第二种用法：typedef 原变量类型 别名<br> 也可以用typedef来定义一个指针函数这样使在大型代码中更加简洁<br> 这里面的 pfun 代表的是函数的类型，通过 pfun 来代表 void (*)(int) 函数类型即 pfun 是指针函数的别名，pfun p相当于定义了一个<br> void (*p)(int)函数指针。p = myfun 可以理解为将函数指针 p 指向 myfun 函数的地址，p(100);相当于执行myfun(100);</p> 
<p><strong>第三种用法（3.c）</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct gfun{
	void (*pfun)(int);	
}gfun;

void myfun(int data)
{
	printf("get data:%d\n",data);
}

int main(int argc,char *argv[])
{
	gfun gcode={
		.pfun = myfun,   //将函数指针指向要调用函数的地址
	};
	gcode.pfun(100);
	return 0;
} </code></pre> 
<p>第三种用结构体函数指针的方法。</p> 
<p>这三种用法的结果如下：</p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/8d/d6/pAShWU9H_o.jpg" width="571"></p> 
<p>可以看到上面这三种使用方法其结果一致。</p> 
<h4>函数指针的作用</h4> 
<p>其实项目中用到了很多封装在struct中的函数指针，以前在MFC里面经常用到则个作为回调函数，还以为是微软设计的特色呢。在网上查了一下它的用法，做个总结。</p> 
<p><strong>1. 提供调用的灵活性。</strong></p> 
<p>设计好了一个函数框架，但是设计初期并不知道自己的函数会被如何使用。比如C的“stdlib”中声明的qsort函数，用来对数值进行排序。显然，顺序还是降序，元素谁大谁小这些问题，库程序员在编写qsort的时候不可能决定。这些问题是要在用户调用这个函数的时候才能够决定。那边qsort如何保证通用性和灵活性呢?采用的办法是让函数的使用者来制定排序规则。于是调用者应该自己设计comparator函数，传给qsort函数。这就在程序设计初期保证了灵活性。尽管使用函数指针使得程序有些难懂，但是这样的牺牲还是值得的。</p> 
<p><strong>2. 提供封装性能。</strong></p> 
<p>有点面向对象编程的特点。比如设计一个栈结构。</p> 
<pre><code class="language-cpp">typedef struct _c_stack{
    int base_size;
    int point;
    int * base;
    int size;
    int  (*pop)(struct _c_stack *);
    int  (*push)(int,struct _c_stack *);
    int  (*get_top)(struct _c_stack);
}c_stack;</code></pre> 
<p>在初始化完之后，用户调用这个结构体上的pop函数，只需要s.pop(&amp;s)即可。即使这个时候，工程内部有另外一个函数名字也叫pop，他们之间是不会发生名字上的冲突的。</p> 
<p>原因很简单，因为结构体中的函数指针指向的函数名字可能是int ugly_stupid_no_one_will_use_this_name_pop(c_stack *)，只是stack的用户是不知道他在调用s.pop(&amp;s)，实际上起作用的是这样一个有着冗长名字的函数。</p> 
<p>函数指针这种避免命名冲突上的额外好处对于一些库函数的编写者是很有意义的，因为库可能被很多的用户在许多不同的环境下使用，这样就能有效的避免冲突而保证库的可用性。</p> 
<p style="margin-left:0px;"><span style="color:#4d4d4d;">关于函数指针，一般的时候用不到。主要还是一个简化结构和程序通用性的问题，也是实现面向对象编程的一种途径。简单的总结为：</span></p> 
<p style="margin-left:0px;"><span style="color:#4d4d4d;">实现面向对象编程中的多态性和回调函数</span></p> 
<hr> 
<h4>回调函数的定义</h4> 
<p>回调函数即是通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p> 
<p>回调函数的例子（4.c）</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct gfun{
    int (*pfun)(int);	
}gfun;

int myfun(int data)
{
    printf("get data:%d\n",data);
	return (data*2);
}

int rt_data(int data,int (*tr_fun)())
{
	return ((*tr_fun)(data));
}  

int main(int argc,char *argv[])
{
	int ret;
	gfun gf;
	gf.pfun = myfun;
	ret = rt_data(100,gf.pfun);
	printf("return data:%d\n",ret);
	return 0;
}</code></pre> 
<p>通过上面的例子我们可以看到将结构体中的函数指针指向了 myfun 函数地址，在回调函数中我们将函数指针 gf.pfun 作为 rt_data(int data,int (*tr_fun)()) 函数的参数即为 int (*tr_fun)()；回调函数中的 return (*tr_fun)(data) 相当于对指针进行了简单引用，返回这个指针指向地址的内容值。</p> 
<p>运行结果如下：</p> 
<p><img alt="" height="73" src="https://images2.imgbox.com/b8/45/XPv09d0f_o.jpg" width="555"></p> 
<h4>回调函数的意义</h4> 
<p>回调函数可以把调用者与被调用者分开，所以调用者不关心谁是被调用者。它只需知道存在一个具有特定原型和限制条件的被调用函数。简而言之，回调函数就是允许用户把需要调用的函数的指针作为参数传递给一个函数，以便该函数在处理相似事件的时候可以灵活的使用不同的方法。</p> 
<p>回调函数在实际中有什么作用？先假设有这样一种情况：我们要编写一个库，它提供了某些排序算法的实现（如冒泡排序、快速排序、shell排序、shake排序等等），为了能让库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，能让库可用于多种数据类型（int、float、string），此时，该怎么办呢？可以使用函数指针，并进行回调。</p> 
<p>回调函数还可用于通知机制。例如，有时要在A程序中设置一个计时器，每到一定时间，A程序会得到相应的通知，但通知机制的实现者对A程序一无所知。那么，就需一个具有特定原型的函数指针进行回调，通知A程序事件已经发生。实际上，API使用一个回调函数SetTimer()来通知计时器。如果没有提供回调函数，它还会把一个消息发往程序的消息队列。</p> 
<p>谈完回调函数的意义，我们就有了用户和开发者之间的概念，举个例子，用户是实现myfun这个函数，开发者是实现rt_data函数，根据需求用户将myfun函数以参数的形式传入开发者的rt_data函数中，rt_data函数就能返回给相应的数据给用户，开发者不用告诉用户它实现了什么，用户也并不知道开发者怎么实现，用户只用传入自己的函数，便可以得到开发者实现的函数返回值，开发者可以将内容封装起来，将头文件以及库文件提供给用户。</p> 
<p>main.c代码：</p> 
<pre><code class="language-cpp">#include "fun.h"
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef struct gfun{
    int (*pfun)(int);	
}gfun;

int myfun(int data)
{
	printf("get data:%d\n",data);
	return (data*2);
}
 
int main(int argc,char *argv[])
{
	int ret;
	gfun gf;
	gf.pfun = myfun;
	ret = rt_data(100,gf.pfun);
	printf("return data:%d\n",ret);
	return 0;
}</code></pre> 
<p>fun.c代码：</p> 
<pre><code class="language-cpp">#include "fun.h"

int rt_data(int data,int (*tr_fun)())
{
	return ((*tr_fun)(data));
}  
</code></pre> 
<p>fun.h代码：</p> 
<pre><code class="language-cpp">#ifndef _FUN_H_
#define _FUN_H_
int rt_data(int data,int (*tr_fun)());

#endif
</code></pre> 
<p>执行命令：gcc main.c fun.c -o main</p> 
<p>运行结果如下：</p> 
<p><img alt="" height="71" src="https://images2.imgbox.com/46/e4/GKkZ9Xvg_o.jpg" width="706"></p> 
<p>在linux下制作动态链接库，将fun.c和fun.h打包成一个动态链接库。</p> 
<p>先明白以下几个命令是什么意思：</p> 
<p><strong>生成动态库:</strong> gcc -shared -fPIC fun.c -o libfun.so</p> 
<p>-shared 表示生成动态库，-fPIC 表示生成与位置无关代码，-o 表示指定生成的目标文件，</p> 
<p><strong>使用动态库: </strong>gcc main.c -L . –lfun -o main</p> 
<p>-L 表示指定库的路径(编译时); 不指定就使用默认路径(/usr/lib/lib)</p> 
<p>-lfun 表示指定需要动态链接的库是谁</p> 
<p><strong>代码运行时需要加载动态库:</strong> ./main 加载动态库 (默认加载路径:/usr/lib /lib ./ …)</p> 
<p>./main 我们将编译动态生成的libfun.so拷贝到/usr/lib后，现在就不需要fun.c了，此时我们将fun.c移除也可以正常的编译并执行main函数的结果。</p> 
<p>具体操作如下：</p> 
<p>（这里编译时出了问题，记录一下，有时间再看看）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b78febc4d7e44102c04af483cef9ebec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">超详细JavaWeb应用实例，无框架实现增删改查及分页</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21e782a2e1464ef3e33e5dfbd99f8149/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网站随机页面随机时间出现违规外链</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>