<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅谈单例模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅谈单例模式" />
<meta property="og:description" content="饿汉式懒汉式/Double check（双重检索）静态内部类枚举单例 饿汉式 private static final DispatchSingleton instence = new DispatchSingleton(); public static DispatchSingleton getInstence() { return instence; } 饿汉式是在jvm加载这个单例类的时候，就会初始化这个类中的实例，在使用单例中的实例时直接拿来使用就好，因为加载这个类的时候就已经完成初始化，并且由于是已经加载好的单例实例因此是线程安全的，并发获取的情况下不会有问题，是一种可投入使用的可靠单例。
优点：使用起来效率高、线程安全
缺点：由于jvm在加载单例类的时候需要初始化单例实例，因此在加载单例的时候针对jvm内存不够友好。
懒汉式 private static DispatchSingleton mSluggardInstence; public static DispatchSingleton getSluggardInstence(){ if (mSluggardInstence==null){ mSluggardInstence=new DispatchSingleton(); } return mSluggardInstence; } 最简单的懒汉式，核心思想就是弥补饿汉式的缺点，在jvm加载单例类的时候不去初始化实例，而是在第一次获取实例的时候再去初始化实例。但是这样理论完美的单例在使用的时候有一个致命的缺点，在多线程使用的情况下，有时会出现不同线程从单例实例中获取不同的实体。针对多线程环境中并不可靠。
优点：针对jvm内存比较友好，实现了实例的懒加载。
缺点：多线程环境下不安全，会出现不同线程从单例实例中获取不同的实体的情况。
private static volatile DispatchSingleton mSluggardInstence; public static DispatchSingleton getSluggardInstence() { if (mSluggardInstence == null) { synchronized (DispatchSingleton.class) { if (mSluggardInstence == null) { mSluggardInstence = new DispatchSingleton(); } } } return mSluggardInstence; } synchronized 针对懒汉式的这种线程不安全的现：在单例初始化时，多线程存在创建多次实例的风险" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/77298cbcee29d4cde762e712c117fcac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-19T12:23:25+08:00" />
<meta property="article:modified_time" content="2023-10-19T12:23:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅谈单例模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <ul><li>饿汉式</li><li>懒汉式/Double check（双重检索）</li><li>静态内部类</li><li>枚举单例</li></ul> 
</blockquote> 
<h6> 饿汉式</h6> 
<pre><code class="language-java">    private static final DispatchSingleton instence = new DispatchSingleton();

    public static DispatchSingleton getInstence() {
        return instence;
    }</code></pre> 
<p>饿汉式是在jvm加载这个单例类的时候，就会初始化这个类中的实例，在使用单例中的实例时直接拿来使用就好，因为加载这个类的时候就已经完成初始化，并且由于是已经加载好的单例实例因此是线程安全的，并发获取的情况下不会有问题，是一种可投入使用的可靠单例。</p> 
<p>优点：使用起来效率高、线程安全</p> 
<p>缺点：由于jvm在加载单例类的时候需要初始化单例实例，因此在加载单例的时候针对jvm内存不够友好。</p> 
<h6>懒汉式</h6> 
<pre><code class="language-java">    private static DispatchSingleton mSluggardInstence;
    
    public static DispatchSingleton getSluggardInstence(){
        if (mSluggardInstence==null){
            mSluggardInstence=new DispatchSingleton();
        }
        return mSluggardInstence;
    }</code></pre> 
<p>最简单的懒汉式，核心思想就是弥补饿汉式的缺点，在jvm加载单例类的时候不去初始化实例，而是在第一次获取实例的时候再去初始化实例。但是这样理论完美的单例在使用的时候有一个致命的缺点，在多线程使用的情况下，有时会出现不同线程从单例实例中获取不同的实体。针对多线程环境中并不可靠。</p> 
<p>优点：针对jvm内存比较友好，实现了实例的懒加载。</p> 
<p>缺点：多线程环境下不安全，会出现不同线程从单例实例中获取不同的实体的情况。</p> 
<pre><code class="language-java">    private static volatile DispatchSingleton mSluggardInstence;

    public static DispatchSingleton getSluggardInstence() {
        if (mSluggardInstence == null) {
            synchronized (DispatchSingleton.class) {
                if (mSluggardInstence == null) {
                    mSluggardInstence = new DispatchSingleton();
                }
            }
        }
        return mSluggardInstence;
    }</code></pre> 
<h6>synchronized</h6> 
<p> 针对懒汉式的这种线程不安全的现：在单例初始化时，多线程存在创建多次实例的风险</p> 
<p>“<strong>锁的粒度</strong>"，锁的粒度: 粗和细加锁代码涉及到的范围，<strong>加锁代码的范围越大，认为锁的粒度越粗范围越小</strong>，则认为粒度越细</p> 
<p>所以synchronized锁住获取实例的整个方法也可以解决问题，且在并发获取单例实例的时候会有性能问题。故此减小锁的粒度。</p> 
<h6>volatile  </h6> 
<p>在于jdk1.5开始针对volatile进行了增强，因为<a href="https://so.csdn.net/so/search?q=Volatile&amp;spm=1001.2101.3001.7020" title="Volatile">Volatile</a>会<strong>禁止指令重排序</strong></p> 
<h6>静态内部类</h6> 
<div> 
 <pre><code class="language-java">    private static class Holder{
        private static DispatchSingleton singleton = new DispatchSingleton();
    }

    public static DispatchSingleton getHolderInstence() {
        return Holder.singleton;
    }</code></pre> 
</div> 
<p>静态内部类的优点是：外部类加载时并不会立即加载内部类，内部类不被加载就不去初始化实例，因此实现了懒加载。当DispatchSingleton第一次被加载时，并不需要去加载内部类Holder，只有当getInstance()方法第一次被调用时，才会导致虚拟机加载Holer类菜会去初始化StaticSingle实例。这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p> 
<h6>枚举单例</h6> 
<p>以上解决了效率或者懒加载以及线程安全的问题，但是它们都有两个共同的缺点： <strong>序列化可能会破坏单例模式</strong></p> 
<pre><code class="language-java">    public enum DispatchSingle {

        INSTANCE;
        
        public void doSomething(){}
    }</code></pre> 
<p></p> 
<blockquote> 
 <ul><li>自由序列化</li><li>保证只有一个实例</li><li>线程安全</li><li>与静态内部类的区别 
   <ul><li>枚举单例为直接加载，静态内部类为懒加载</li><li>两者相比较，静态内部类比较节省资源开销</li></ul></li></ul> 
</blockquote> 
<p>我们也可以像常规类一样编写enum类，为其添加变量和方法，访问方式也更简单，使用DispatchSingle .INSTANCE进行访问，这样也就避免调用getInstance方法，更重要的是使用枚举单例的写法，我们完全不用考虑序列化和反射的问题。枚举序列化是由jvm保证的，每一个枚举类型和定义的枚举变量在JVM中都是唯一的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20990ccf02ace619211019dde4ed8d32/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[常用组件]文本省略 &#43; Tooltip提示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dce749495a7309ec1234645c8bc05034/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mac虚拟机安装配置qt遇到的坑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>