<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java数据结构-树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java数据结构-树" />
<meta property="og:description" content="目录 一、简介二、相关术语三、二叉树1. 相关概念2. 特殊二叉树（1）满二叉树（2）完全二叉树（3）二叉排序树（4）平衡二叉树 3. 二叉查找树的创建（1）二叉树的结点类（2）二叉查找树插入实现（3）二叉查找树查询实现（4）二叉查找树删除实现 4. 二叉树的遍历（1）前序遍历（2）中序遍历（3）后序遍历（4）层次遍历 5. 最大深度问题6. 折纸问题 一、简介 树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。
树是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”，是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
树具有以下特点：
每个结点有零个或多个子结点；没有父结点的结点为根结点；每一个非根结点只有一个父结点；每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树； 二、相关术语 结点的度：
一个结点含有的子树的个数称为该结点的度；
叶结点：
度为0的结点称为叶结点，也可以叫做终端结点
分支结点：
度不为0的结点称为分支结点，也可以叫做非终端结点
结点的层次：
从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推
结点的层序编号：
将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。
树的度：
树中所有结点的度的最大值
树的高度(深度)：
树中结点的最大层次
森林：
m（m&gt;=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树
孩子结点：
一个结点的直接后继结点称为该结点的孩子结点
双亲结点(父结点)：
一个结点的直接前驱称为该结点的双亲结点
兄弟结点：
同一双亲结点的孩子结点间互称兄弟结点
三、二叉树 1. 相关概念 二叉树就是度不超过2的树(每个结点最多有两个子结点)
2. 特殊二叉树 （1）满二叉树 一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为 2。
（2）完全二叉树 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。
（3）二叉排序树 左子树上所有结点的关键字均小于根结点的关键字;右子树上的所有结点的关键字均大于根结点的关键字;左子树和右子树又各是一棵二叉排序树。
（4）平衡二叉树 树上任一结点的左子树和右子树的深度之差不超过1。
3. 二叉查找树的创建 二叉查找树是二叉树中一种常用的一种类型。二叉查找树是为了实现快速查找产生的。不过，它不仅支持快速查找，还支持快速插入和删除。这主要归功于二叉查找树的一个特性，那就是树中任一节点，这个节点的左子树的值总是小于这个节点的值，这个节点右子树的值总是大于这个节点的值。
二叉查找树API设计
（1）二叉树的结点类 根据对图的观察，我们发现二叉树其实就是由一个一个的结点及其之间的关系组成的，按照面向对象的思想，我们设计一个结点类来描述结点这个事物。
private class Node { // 存储键 public Key key; // 存储值 private Value value; // 记录左子结点 public Node left; // 记录右子结点 public Node right; public Node(Key key, Value value, Node left, Node right) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/87e7ae75c3bcc037a5ede1bf34d7a03a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-16T09:22:02+08:00" />
<meta property="article:modified_time" content="2022-10-16T09:22:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java数据结构-树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、简介</a></li><li><a href="#_15" rel="nofollow">二、相关术语</a></li><li><a href="#_40" rel="nofollow">三、二叉树</a></li><li><ul><li><a href="#1__41" rel="nofollow">1. 相关概念</a></li><li><a href="#2__45" rel="nofollow">2. 特殊二叉树</a></li><li><ul><li><a href="#1_46" rel="nofollow">（1）满二叉树</a></li><li><a href="#2_50" rel="nofollow">（2）完全二叉树</a></li><li><a href="#3_54" rel="nofollow">（3）二叉排序树</a></li><li><a href="#4_59" rel="nofollow">（4）平衡二叉树</a></li></ul> 
   </li><li><a href="#3___65" rel="nofollow">3. 二叉查找树的创建</a></li><li><ul><li><a href="#1_77" rel="nofollow">（1）二叉树的结点类</a></li><li><a href="#2_100" rel="nofollow">（2）二叉查找树插入实现</a></li><li><a href="#3_140" rel="nofollow">（3）二叉查找树查询实现</a></li><li><a href="#4_178" rel="nofollow">（4）二叉查找树删除实现</a></li></ul> 
   </li><li><a href="#4__398" rel="nofollow">4. 二叉树的遍历</a></li><li><ul><li><a href="#1_411" rel="nofollow">（1）前序遍历</a></li><li><a href="#2_452" rel="nofollow">（2）中序遍历</a></li><li><a href="#3_492" rel="nofollow">（3）后序遍历</a></li><li><a href="#4_535" rel="nofollow">（4）层次遍历</a></li></ul> 
   </li><li><a href="#5__574" rel="nofollow">5. 最大深度问题</a></li><li><a href="#6__604" rel="nofollow">6. 折纸问题</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、简介</h2> 
<p>树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。<br> 树是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”，是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p> 
<p><img src="https://images2.imgbox.com/b7/5a/MXiAfyQR_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>树具有以下特点：</strong></p> 
 <ol><li>每个结点有零个或多个子结点；</li><li>没有父结点的结点为根结点；</li><li>每一个非根结点只有一个父结点；</li><li>每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；</li></ol> 
</blockquote> 
<hr> 
<h2><a id="_15"></a>二、相关术语</h2> 
<p><strong>结点的度：</strong><br> 一个结点含有的子树的个数称为该结点的度；<br> <strong>叶结点：</strong><br> 度为0的结点称为叶结点，也可以叫做终端结点<br> <strong>分支结点：</strong><br> 度不为0的结点称为分支结点，也可以叫做非终端结点<br> <strong>结点的层次：</strong><br> 从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推<br> <strong>结点的层序编号：</strong><br> 将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。<br> <strong>树的度：</strong><br> 树中所有结点的度的最大值<br> <strong>树的高度(深度)：</strong><br> 树中结点的最大层次<br> <strong>森林：</strong><br> m（m&gt;=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树<br> <strong>孩子结点：</strong><br> 一个结点的直接后继结点称为该结点的孩子结点<br> <strong>双亲结点(父结点)：</strong><br> 一个结点的直接前驱称为该结点的双亲结点<br> <strong>兄弟结点：</strong><br> 同一双亲结点的孩子结点间互称兄弟结点</p> 
<hr> 
<h2><a id="_40"></a>三、二叉树</h2> 
<h3><a id="1__41"></a>1. 相关概念</h3> 
<p>二叉树就是度不超过2的树(每个结点最多有两个子结点)</p> 
<p><img src="https://images2.imgbox.com/f1/93/yxGxb4tL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__45"></a>2. 特殊二叉树</h3> 
<h4><a id="1_46"></a>（1）满二叉树</h4> 
<p>一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为 2。</p> 
<p><img src="https://images2.imgbox.com/c9/2c/GsVlS6iw_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_50"></a>（2）完全二叉树</h4> 
<p>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。<br> <img src="https://images2.imgbox.com/75/48/7MsGevbZ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_54"></a>（3）二叉排序树</h4> 
<p>左子树上所有结点的关键字均小于根结点的关键字;右子树上的所有结点的关键字均大于根结点的关键字;左子树和右子树又各是一棵二叉排序树。</p> 
<h4><a id="4_59"></a>（4）平衡二叉树</h4> 
<p>树上任一结点的左子树和右子树的深度之差不超过1。</p> 
<hr> 
<h3><a id="3___65"></a>3. 二叉查找树的创建</h3> 
<p>二叉查找树是二叉树中一种常用的一种类型。二叉查找树是为了实现快速查找产生的。不过，它不仅支持快速查找，还支持快速插入和删除。这主要归功于二叉查找树的一个特性，那就是树中任一节点，这个节点的左子树的值总是小于这个节点的值，这个节点右子树的值总是大于这个节点的值。<br> <img src="https://images2.imgbox.com/0f/03/3dKfrh6b_o.png" alt="在这里插入图片描述"></p> 
<p><strong>二叉查找树API设计</strong></p> 
<p><img src="https://images2.imgbox.com/fc/7c/eCqg9gDF_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_77"></a>（1）二叉树的结点类</h4> 
<p>根据对图的观察，我们发现二叉树其实就是由一个一个的结点及其之间的关系组成的，按照面向对象的思想，我们设计一个结点类来描述结点这个事物。</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 存储键</span>
	<span class="token keyword">public</span> <span class="token class-name">Key</span> key<span class="token punctuation">;</span>
	<span class="token comment">// 存储值</span>
	<span class="token keyword">private</span> <span class="token class-name">Value</span> value<span class="token punctuation">;</span>
	<span class="token comment">// 记录左子结点</span>
	<span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>
	<span class="token comment">// 记录右子结点</span>
	<span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>
	
	<span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span> left<span class="token punctuation">,</span> <span class="token class-name">Node</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="2_100"></a>（2）二叉查找树插入实现</h4> 
<blockquote> 
 <p><strong>插入方法put实现思想：</strong></p> 
 <ol><li>如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</li><li>如果当前树不为空，则从根结点开始：</li></ol> 
 <ul><li>如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</li><li>如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</li><li>如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</li></ul> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">// 向树中添加元素 key-value</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 向指定的树x中添加key-value,并返回添加元素后新的树</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//如果 x 子树为空，</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 如果x子树不为空</span>
	<span class="token comment">// 比较x结点的键和key的大小：</span>
	<span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果key大于x结点的键，则继续找x结点的右子树</span>
		x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果key小于x结点的键，则继续找x结点的左子树</span>
		x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果key等于x结点的键，则替换x结点的值为value即可</span>
		x<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="3_140"></a>（3）二叉查找树查询实现</h4> 
<blockquote> 
 <p><strong>查询方法get实现思想：</strong><br> 从根节点开始：</p> 
 <ol><li>如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</li><li>如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</li><li>如果要查询的key等于当前结点的key，则树中返回当前结点的value。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">// 查询树中指定key对应的value</span>
<span class="token keyword">public</span> <span class="token class-name">Value</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 从指定的树x中，查找key对应的值</span>
<span class="token keyword">public</span> <span class="token class-name">Value</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// x树为null</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// x树不为null</span>
	<span class="token comment">// 比较key和x结点的键的大小</span>
	<span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果key大于x结点的键，则继续找x结点的右子树</span>
		<span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果key小于x结点的键，则继续找x结点的左子树</span>
		<span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可</span>
		<span class="token keyword">return</span> x<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="4_178"></a>（4）二叉查找树删除实现</h4> 
<blockquote> 
 <p><strong>删除方法delete实现思想：</strong></p> 
 <ol><li>找到被删除结点；</li><li>找到被删除结点右子树中的最小结点minNode</li><li>删除右子树中的最小结点</li><li>让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子 树</li><li>让被删除结点的父节点指向最小结点minNode</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">// 删除树中key对应的value</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	root <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 删除指定树x中的key对应的value，并返回删除后的新树</span>
<span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// x树为null</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// x树不为null</span>
	<span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果key大于x结点的键，则继续找x结点的右子树</span>
		x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果key小于x结点的键，则继续找x结点的左子树</span>
		x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x；</span>
		<span class="token comment">// 让元素个数-1</span>
		<span class="token class-name">N</span> <span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token comment">// 得找到右子树中最小的结点</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Node</span> minNode <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
		<span class="token class-name">Node</span> curNode <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
		<span class="token comment">// 若右结点无左结点，则它就为替换删除结点的结点</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			minNode<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 找到右子树中最小的结点</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 找到最小结点</span>
					minNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
					<span class="token comment">// 断开此最小结点</span>
					curNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 让x结点的左子树成为minNode的左子树</span>
			minNode<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
			<span class="token comment">// 让x结点的右子树成为minNode的右子树</span>
			minNode<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 让x结点的父结点指向minNode</span>
		x <span class="token operator">=</span> minNode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>完整代码</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinaryTree</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Value</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 记录根结点</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span> root<span class="token punctuation">;</span>
    <span class="token comment">// 记录树中元素的个数</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 存储键</span>
        <span class="token keyword">public</span> <span class="token class-name">Key</span> key<span class="token punctuation">;</span>
        <span class="token comment">// 存储值</span>
        <span class="token keyword">private</span> <span class="token class-name">Value</span> value<span class="token punctuation">;</span>
        <span class="token comment">// 记录左子结点</span>
        <span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>
        <span class="token comment">// 记录右子结点</span>
        <span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span> left<span class="token punctuation">,</span> <span class="token class-name">Node</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取树中元素的个数</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 向树中添加元素 key-value</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 向指定的树x中添加key-value,并返回添加元素后新的树</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//如果 x 子树为空，</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">N</span> <span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果x子树不为空</span>
        <span class="token comment">// 比较x结点的键和key的大小：</span>
        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//如果key大于x结点的键，则继续找x结点的右子树</span>
            x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果key小于x结点的键，则继续找x结点的左子树</span>
            x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果key等于x结点的键，则替换x结点的值为value即可</span>
            x<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 查询树中指定key对应的value</span>
    <span class="token keyword">public</span> <span class="token class-name">Value</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 从指定的树x中，查找key对应的值</span>
    <span class="token keyword">public</span> <span class="token class-name">Value</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// x树为null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// x树不为null</span>
        <span class="token comment">// 比较key和x结点的键的大小</span>
        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果key大于x结点的键，则继续找x结点的右子树</span>
            <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果key小于x结点的键，则继续找x结点的左子树</span>
            <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可</span>
            <span class="token keyword">return</span> x<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// 删除树中key对应的value</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token comment">// 删除指定树x中的key对应的value，并返回删除后的新树</span>
	<span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// x树为null</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// x树不为null</span>
		<span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 如果key大于x结点的键，则继续找x结点的右子树</span>
			x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 如果key小于x结点的键，则继续找x结点的左子树</span>
			x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x；</span>
			<span class="token comment">// 让元素个数-1</span>
			<span class="token class-name">N</span> <span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token comment">// 得找到右子树中最小的结点</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token class-name">Node</span> minNode <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
			<span class="token class-name">Node</span> curNode <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
			<span class="token comment">// 若右结点无左结点，则它就为替换删除结点的结点</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				minNode<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 找到右子树中最小的结点</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
						<span class="token comment">// 找到最小结点</span>
						minNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
						<span class="token comment">// 断开此最小结点</span>
						curNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
						<span class="token keyword">break</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token comment">// 让x结点的左子树成为minNode的左子树</span>
				minNode<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
				<span class="token comment">// 让x结点的右子树成为minNode的右子树</span>
				minNode<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 让x结点的父结点指向minNode</span>
			x <span class="token operator">=</span> minNode<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="4__398"></a>4. 二叉树的遍历</h3> 
<p>很多情况下，我们可能需要像遍历数组数组一样，遍历树，从而拿出树中存储的每一个元素，由于树状结构和线性结构不一样，它没有办法从头开始依次向后遍历，所以存在如何遍历，也就是按照什么样的搜索路径进行遍历的问题。<br> <img src="https://images2.imgbox.com/5c/cf/eFZwpYs2_o.png" alt="在这里插入图片描述"><br> 我们把树简单的画作上图中的样子，由一个根节点、一个左子树、一个右子树组成，那么按照根节点什么时候被访问，我们可以把二叉树的遍历分为以下三种方式：<br> <strong>1. 前序遍历；</strong><br> 先访问根结点，然后再访问左子树，最后访问右子树<br> <strong>2. 中序遍历；</strong><br> 先访问左子树，中间访问根节点，最后访问右子树<br> <strong>3. 后序遍历；</strong><br> 先访问左子树，再访问右子树，最后访问根节点</p> 
<p>如果我们分别对下面的树使用三种遍历方式进行遍历，得到的结果如下：<br> <img src="https://images2.imgbox.com/e1/90/mv1QH08j_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_411"></a>（1）前序遍历</h4> 
<p>我们在（3）中创建的树上，添加前序遍历的API：</p> 
<blockquote> 
 <ul><li><code>public Deque&lt;Key&gt; preErgodic()</code>：使用前序遍历，获取整个树中的所有键</li><li><code>private void preErgodic(Node x, Deque&lt;Key&gt; keys)</code>：使用前序遍历，把指定树x中的所有键放入到keys队列中</li></ul> 
</blockquote> 
<p>实现过程中，我们通过前序遍历，把,把每个结点的键取出，放入到队列中返回即可。</p> 
<blockquote> 
 <p><strong>实现步骤：</strong></p> 
 <ol><li>把当前结点的key放入到队列中</li><li>找到当前结点的左子树，如果不为空，递归遍历左子树</li><li>找到当前结点的右子树，如果不为空，递归遍历右子树</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">// 获取整个树中所有的键 -- 前序遍历</span>
<span class="token keyword">public</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> <span class="token function">preErgodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">preErgodic</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> keys<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取指定树x的所有键，并放到 keys 队列中</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preErgodic</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 把x结点的key放入到 队列</span>
	keys<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 递归遍历x结点的左子树</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">preErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 递归遍历x结点的右子树</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">preErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="2_452"></a>（2）中序遍历</h4> 
<p>我们在（3）中创建的树上，添加中序遍历的API：</p> 
<blockquote> 
 <ul><li><code>public Deque&lt;Key&gt; midErgodic()</code>：使用中序遍历，获取整个树中的所有键</li><li><code>private void midErgodic(Node x, Deque&lt;Key&gt; keys)</code>：使用中序遍历，把指定树x中的所有键放入到keys队列中</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>实现步骤：</strong></p> 
 <ol><li>找到当前结点的左子树，如果不为空，递归遍历左子树</li><li>把当前结点的key放入到队列中</li><li>找到当前结点的右子树，如果不为空，递归遍历右子树</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">// 使用中序遍历获取树中所有的键</span>
<span class="token keyword">public</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> <span class="token function">midErgodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">midErgodic</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> keys<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用中序遍历，获取指定树x中所有的键，并存放到key中</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">midErgodic</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span><span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 先递归，把左子树中的键放到keys中</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">midErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 把当前结点x的键放到keys中</span>
	keys<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 在递归，把右子树中的键放到keys中</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">midErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="3_492"></a>（3）后序遍历</h4> 
<p>我们在（3）中创建的树上，添加后序遍历的API：</p> 
<blockquote> 
 <p><code>public Deque&lt;Key&gt; afterErgodic()</code>：使用后序遍历，获取整个树中的所有键 <code>private void afterErgodic(Node x, Deque&lt;Key&gt; keys)</code>：使用后序遍历，把指定树x中的所有键放入到keys队列中</p> 
</blockquote> 
<blockquote> 
 <p><strong>实现步骤：</strong></p> 
 <ol><li>找到当前结点的左子树，如果不为空，递归遍历左子树</li><li>找到当前结点的右子树，如果不为空，递归遍历右子树</li><li>把当前结点的key放入到队列中;</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">// 使用后序遍历，把整个树中所有的键返回</span>
<span class="token keyword">public</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> <span class="token function">afterErgodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">afterErgodic</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> keys<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用后序遍历，把指定树x中所有的键放入到keys中</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">afterErgodic</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span><span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 通过递归把左子树中所有的键放入到keys中</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">afterErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 通过递归把右子树中所有的键放入到keys中</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">afterErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 把x结点的键放入到keys中</span>
	keys<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="4_535"></a>（4）层次遍历</h4> 
<p>所谓的层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值，有二叉树如下：<br> <img src="https://images2.imgbox.com/23/a7/u52mh9BA_o.png" alt="在这里插入图片描述"></p> 
<p>那么层序遍历的结果是：<code>EBGADFHC</code><br> 我们在（3）中创建的树上，添加层序遍历的API：</p> 
<blockquote> 
 <ul><li><code>public Deque&lt;Key&gt; layerErgodic()</code>：使用层序遍历，获取整个树中的所有键</li></ul> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">// 使用层序遍历，获取整个树中所有的键</span>
<span class="token keyword">public</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> <span class="token function">layerErgodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

	<span class="token comment">// 定义两个队列，分别存储树中的键和树中的结点</span>
	<span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 默认，往队列中放入根结点</span>
	nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>nodes<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 从队列中弹出一个结点，把key放入到keys中</span>
		<span class="token class-name">Node</span> n <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		keys<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 判断当前结点还有没有左子结点，如果有，则放入到nodes中</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 判断当前结点还有没有右子结点，如果有，则放入到nodes中</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> keys<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="5__574"></a>5. 最大深度问题</h3> 
<p>给定一棵树，请计算树的最大深度（树的根节点到最远叶子结点的最长路径上的结点数）<br> <img src="https://images2.imgbox.com/5a/57/irCmApXo_o.png" alt="在这里插入图片描述"></p> 
<p>上面这棵树的最大深度为4。</p> 
<p>我们在（3）中创建的树上，添加如下的API求最大深度：</p> 
<blockquote> 
 <ul><li><code>public int maxDepth()</code>：计算整个树的最大深度</li><li><code>private int maxDepth(Node x)</code>:计算指定树x的最大深度</li></ul> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">//获取整个树的最大深度</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//获取指定树x的最大深度</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 比较左子树最大深度和右子树最大深度，取较大值+1即可</span>
	<span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="6__604"></a>6. 折纸问题</h3> 
<p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。<br> 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向<br> 例如：N=1时，打印： down；N=2时，打印： down down up</p> 
<p><img src="https://images2.imgbox.com/ab/4b/SWWhaT0X_o.png" alt="在这里插入图片描述"></p> 
<p>我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构来描述对折后产生的折痕。</p> 
<blockquote> 
 <p><strong>这棵树有这样的特点：</strong></p> 
 <ol><li>根结点为下折痕</li><li>每一个结点的左子结点为下折痕</li><li>每一个结点的右子结点为上折痕</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4e/5e/Dx1Iu92W_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>实现步骤：</strong></p> 
 <ol><li>定义结点类</li><li>构建深度为N的折痕树</li><li>使用中序遍历，打印出树中所有结点的内容</li></ol> 
 <hr> 
 <p><strong>构建深度为N的折痕树：</strong></p> 
 <ol><li>第一次对折，只有一条折痕，创建根结点；</li><li>如果不是第一次对折，则使用队列保存根结点；</li><li>循环遍历队列</li></ol> 
 <ul><li>从队列中拿出一个结点；</li><li>如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；</li><li>如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；</li><li>判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点</li></ul> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Deque</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedList</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PagerFoldingTest</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 模拟折纸过程，产生树</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> tree <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 遍历树，打印每个结点</span>
        <span class="token function">printTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 通过模拟对折 N 次纸，产生树</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">createTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 定义根结点</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 当前是第一次对折</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"down"</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 当前不是第一次对折</span>
            <span class="token comment">// 定义一个辅助队列，通过层序遍历的思想，找到叶子结点，叶子结点添加子节点</span>
            <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 循环遍历队列</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 从队列中弹出一个结点</span>
                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> tmp <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 如果有左子结点，则把左子结点放入到队列中</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 如果有右子结点，则把右子结点放入到队列中</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 如果同时没有左子结点和右子结点，那么证明该节点是叶子结点，只需要给该节点添加左子结点和右子结点即可</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    tmp<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"down"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    tmp<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"up"</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// 打印树中每个结点到控制台</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printTree</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 使用中序遍历完成</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 打印左子树的每个结点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">printTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 打印当前结点</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>item <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印右子树的每个结点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">printTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 结点类</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 存储元素</span>
        <span class="token keyword">public</span> <span class="token class-name">T</span> item<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">,</span> <span class="token class-name">Node</span> left<span class="token punctuation">,</span> <span class="token class-name">Node</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a89520e32d25b6edd538709d7540e25a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python开平方计算（求平方根）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1edeb3f6986a5bb389183d723949f3c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java如何接收命令行参数呢？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>