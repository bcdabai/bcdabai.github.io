<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA学习- 集合接口 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA学习- 集合接口" />
<meta property="og:description" content="一、Collection集合接口
在之前学习链表的时候可以发现，当使用add()方法向链表增加数据的时候，每次保存的都是一个对象的数据，而Collection操作过程之中每次也只能够保存一个对象。在Collection接口之中一共定义了15个方法，那么常用的方法如下：
No.
方法名称
类型
描述
1
public boolean add(E e)
普通
向集合之中保存数据
2
public void clear()
普通
清空集合
3
public boolean contains(Object o)
普通
查询集合之中是否包含有指定对象，需要equals()
4
public boolean remove(Object o)
普通
删除对象，需要equals()
5
public boolean isEmpty()
普通
判断集合是否为空集合
6
public int size()
普通
取得集合的长度
7
public Object[] toArray()
普通
将集合以对象数组的形式返回
8
public Iterator iterator()
普通
为Iterator接口实例化
在以上所给出的方法之中，99%的情况下是使用add()、iterator()两个方法，其它的方法都很少使用。但是在开发之中不会去直接使用Collection（时代已经结束了），都会使用Collection下的两个子接口：List（允许重复）、Set（不允许重复）。
二、List集合接口
List接口是Collection之中最为常用的子接口，也是大家在开发过程之中主要使用的接口。但是List子接口针对于Collection子接口做了大量的功能扩充，而主要扩充的方法有如下几个：
No.
方法名称
类型
描述
1
public E get(int index)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6ce5c5d2abb43fa84b734e64765e2c56/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T05:51:05+08:00" />
<meta property="article:modified_time" content="2019-07-05T05:51:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA学习- 集合接口</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p style="text-align:center;"><span style="font-size:14pt;"><strong>一、Collection集合接口</strong></span></p> 
 <p> </p> 
 <p>在之前学习链表的时候可以发现，当使用add()方法向链表增加数据的时候，每次保存的都是一个对象的数据，而Collection操作过程之中每次也只能够保存一个对象。在Collection接口之中一共定义了15个方法，那么常用的方法如下：</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="36"> <p align="center"><strong>No.</strong></p> </td><td width="282"> <p align="center"><strong>方法名称</strong></p> </td><td width="42"> <p align="center"><strong>类型</strong></p> </td><td width="276"> <p align="center"><strong>描述</strong></p> </td></tr><tr><td width="36"> <p align="center"><strong>1</strong></p> </td><td width="282"> <p align="center"><strong>public boolean add(E e)</strong></p> </td><td width="42"> <p align="center"><strong>普通</strong></p> </td><td width="276"> <p><strong>向集合之中保存数据</strong></p> </td></tr><tr><td width="36"> <p align="center">2</p> </td><td width="282"> <p align="center">public void clear()</p> </td><td width="42"> <p align="center">普通</p> </td><td width="276"> <p>清空集合</p> </td></tr><tr><td width="36"> <p align="center">3</p> </td><td width="282"> <p align="center">public boolean contains(Object o)</p> </td><td width="42"> <p align="center">普通</p> </td><td width="276"> <p>查询集合之中是否包含有指定对象，需要equals()</p> </td></tr><tr><td width="36"> <p align="center">4</p> </td><td width="282"> <p align="center">public boolean remove(Object o)</p> </td><td width="42"> <p align="center">普通</p> </td><td width="276"> <p>删除对象，需要equals()</p> </td></tr><tr><td width="36"> <p align="center">5</p> </td><td width="282"> <p align="center">public boolean isEmpty()</p> </td><td width="42"> <p align="center">普通</p> </td><td width="276"> <p>判断集合是否为空集合</p> </td></tr><tr><td width="36"> <p align="center">6</p> </td><td width="282"> <p align="center">public int size()</p> </td><td width="42"> <p align="center">普通</p> </td><td width="276"> <p>取得集合的长度</p> </td></tr><tr><td width="36"> <p align="center">7</p> </td><td width="282"> <p align="center">public Object[] toArray()</p> </td><td width="42"> <p align="center">普通</p> </td><td width="276"> <p>将集合以对象数组的形式返回</p> </td></tr><tr><td width="36"> <p align="center"><strong>8</strong></p> </td><td width="282"> <p align="center"><strong>public Iterator iterator()</strong></p> </td><td width="42"> <p align="center"><strong>普通</strong></p> </td><td width="276"> <p><strong>为</strong><strong>Iterator</strong><strong>接口实例化</strong></p> </td></tr></tbody></table> 
 <p>         在以上所给出的方法之中，99%的情况下是使用add()、iterator()两个方法，其它的方法都很少使用。但是在开发之中不会去直接使用Collection（时代已经结束了），都会使用Collection下的两个子接口：List（允许重复）、Set（不允许重复）。</p> 
 <p style="text-align:center;"> </p> 
 <p style="text-align:center;"><span style="font-size:14pt;"><strong>二、List集合接口</strong></span></p> 
 <p> </p> 
 <p>List接口是Collection之中最为常用的子接口，也是大家在开发过程之中主要使用的接口。但是List子接口针对于Collection子接口做了大量的功能扩充，而主要扩充的方法有如下几个：</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="36"> <p align="center"><strong>No.</strong></p> </td><td width="282"> <p align="center"><strong>方法名称</strong></p> </td><td width="42"> <p align="center"><strong>类型</strong></p> </td><td width="276"> <p align="center"><strong>描述</strong></p> </td></tr><tr><td width="36"> <p align="center"><strong>1</strong></p> </td><td width="282"> <p align="center"><strong>public E get(int index)</strong></p> </td><td width="42"> <p align="center"><strong>普通</strong></p> </td><td width="276"> <p><strong>取得指定索引位置上的对象</strong></p> </td></tr><tr><td width="36"> <p align="center">2</p> </td><td width="282"> <p align="center">public E set(int index, E element)</p> </td><td width="42"> <p align="center">普通</p> </td><td width="276"> <p>修改指定索引位置上的对象</p> </td></tr><tr><td width="36"> <p align="center">3</p> </td><td width="282"> <p align="center">public ListIterator listIterator()</p> </td><td width="42"> <p align="center">普通</p> </td><td width="276"> <p>为ListIterator接口实例化</p> </td></tr></tbody></table> 
 <p>         那么接口完成后如果要想使用接口那么一定需要子类，而常用的两个子类：ArrayList、Vector。</p> 
 <h4>1、新的子类：ArrayList（90%）</h4> 
 <p>         ArrayList是在JDK 1.2之后引入的，或者更加明确的讲像Collection、List等都是JDK 1.2之后引入的，也是在List接口使用过程之中最为常见的一个子类。</p> 
 <p><strong>范例：</strong>使用ArrayList</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.ArrayList;</p> <p align="left"><strong>import</strong> java.util.List;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        List all = <strong>new</strong> ArrayList() ;</p> <p align="left">        all.add("HELLO") ;</p> <p align="left">        all.add("HELLO") ;  // 保存了重复数据</p> <p align="left">        all.add("WORLD") ;</p> <p align="left">        System.<strong><em>out</em></strong>.println(all);</p> <p align="left">    }</p> <p align="left">}</p> </td></tr></tbody></table> 
 <p>         但是在很多时候可以采用循环的方式输出，因为在List子接口里面扩充了一个get()方法，所以就可以使用for循环。</p> 
 <p><strong>范例：</strong>循环输出List集合</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.ArrayList;</p> <p align="left"><strong>import</strong> java.util.List;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        List all = <strong>new</strong> ArrayList() ;</p> <p align="left">        all.add("HELLO") ;</p> <p align="left">        all.add("HELLO") ;  // 保存了重复数据</p> <p align="left">        all.add("WORLD") ;</p> <p align="left">        <strong>for</strong> (<strong>int</strong> x = 0; x &lt; all.size(); x++) {<!-- --></p> <p align="left">            System.<strong><em>out</em></strong>.println(all.get(x));</p> <p align="left">        }</p> <p align="left">    }</p> <p align="left">}</p> </td></tr></tbody></table> 
 <p><strong>范例：</strong>验证其它方法</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.ArrayList;</p> <p align="left"><strong>import</strong> java.util.List;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        List all = <strong>new</strong> ArrayList() ;</p> <p align="left">        System.<strong><em>out</em></strong>.println(all.isEmpty());</p> <p align="left">        all.add("HELLO") ;</p> <p align="left">        all.add("HELLO") ;  // 保存了重复数据</p> <p align="left">        all.add("WORLD") ;</p> <p align="left">        System.<strong><em>out</em></strong>.println(all.isEmpty());</p> <p align="left">        all.set(0, "hello") ;   // 此方法也是List扩充</p> <p align="left">        all.remove("WORLD") ;</p> <p align="left">        System.<strong><em>out</em></strong>.println(all);</p> <p align="left">    }</p> <p align="left">}</p> </td></tr></tbody></table> 
 <p>         但是以上的程序之中发现操作的数据类型都是String，那么String类是一个比较完善的类，那么下面使用一个自定义的类进行操作。</p> 
 <p><strong>范例：</strong>保存自定义类对象</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.ArrayList;</p> <p align="left"><strong>import</strong> java.util.List;</p> <p align="left"><strong>class</strong> Person {<!-- --></p> <p align="left">    <strong>private</strong> String name ;</p> <p align="left">    <strong>private</strong> <strong>int</strong> age ;</p> <p align="left">    <strong>public</strong> Person(String name,<strong>int</strong> age) {<!-- --></p> <p align="left">        <strong>this</strong>.name = name ;</p> <p align="left">        <strong>this</strong>.age = age ;</p> <p align="left">    }</p> <p align="left">    @Override</p> <p align="left">    <strong>public</strong> String toString() {<!-- --></p> <p align="left">        <strong>return</strong> "姓名：" + <strong>this</strong>.name + "，年龄 :" + <strong>this</strong>.age + "\n" ;</p> <p align="left">    }</p> <p align="left">    @Override</p> <p align="left">    <strong>public</strong> <strong>boolean</strong> equals(Object obj) {<!-- --></p> <p align="left">        <strong>if</strong> (obj == <strong>null</strong>) {<!-- --></p> <p align="left">            <strong>return</strong> <strong>false</strong> ;</p> <p align="left">        }</p> <p align="left">        <strong>if</strong> (<strong>this</strong> == obj) {<!-- --></p> <p align="left">            <strong>return</strong> <strong>true</strong> ;</p> <p align="left">        }</p> <p align="left">        <strong>if</strong> (!(obj <strong>instanceof</strong> Person)) {<!-- --></p> <p align="left">            <strong>return</strong> <strong>false</strong> ;</p> <p align="left">        }</p> <p align="left">        Person per = (Person) obj ;</p> <p align="left">        <strong>if</strong> (per.name.equals(<strong>this</strong>.name) &amp;&amp; per.age == <strong>this</strong>.age) {<!-- --></p> <p align="left">            <strong>return</strong> <strong>true</strong> ;</p> <p align="left">        }</p> <p align="left">        <strong>return</strong> <strong>false</strong> ;</p> <p align="left">    }</p> <p align="left">}</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        List all = <strong>new</strong> ArrayList() ;</p> <p align="left">        all.add(<strong>new</strong> Person("张三",20)) ;</p> <p align="left">        all.add(<strong>new</strong> Person("李四",21)) ;</p> <p align="left">        all.add(<strong>new</strong> Person("王五",19)) ;</p> <p align="left">        all.remove(<strong>new</strong> Person("王五",19)) ;  // 删除</p> <p align="left">        System.<strong><em>out</em></strong>.println(all.contains(<strong>new</strong> Person("李四",21)));</p> <p align="left">        System.<strong><em>out</em></strong>.println(all);</p> <p align="left">    }</p> <p align="left">}</p> </td></tr></tbody></table> 
 <p>         那么在之前使用的链表操作，在List接口上可以方便的使用，使用的规则与之前完全一样，可是List所采用的程序的逻辑更加合理，性能更好，所以不会使用自定义链表，都会使用List接口操作。</p> 
 <h4>2、旧的子类：Vector（10%）</h4> 
 <p>         Vector是从JDK 1.0的时候引入的操作类，最早是用于纯粹的保存多个对象，同时在JDK 1.2之后为了让其可以继续使用，于是让Vector类多实现了一个List接口，所以List接口下有两个常用的子类：ArrayList、Vector。</p> 
 <p>         既然Vector也是List接口的子类，所以在使用上，不管使用ArrayList还是Vector不会有任何的区别。</p> 
 <p><strong>范例：</strong>验证Vector</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.List;</p> <p align="left"><strong>import</strong> java.util.Vector;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        List all = <strong>new</strong> Vector() ;</p> <p align="left">        all.add("HELLO") ;</p> <p align="left">        all.add("HELLO") ;  // 保存了重复数据</p> <p align="left">        all.add("WORLD") ;</p> <p align="left">        System.<strong><em>out</em></strong>.println(all);</p> <p align="left">    }</p> <p align="left">}</p> </td></tr></tbody></table> 
 <p><strong>面试题：</strong>请解释ArrayList和Vector区别？</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="36"> <p align="center"><strong>No.</strong></p> </td><td width="84"> <p align="center"><strong>区别</strong></p> </td><td width="258"> <p align="center"><strong>ArrayList</strong></p> </td><td width="258"> <p align="center"><strong>Vector</strong></p> </td></tr><tr><td width="36"> <p align="center">1</p> </td><td width="84"> <p align="center">推出时间</p> </td><td width="258"> <p align="center">JDK 1.2时推出</p> </td><td width="258"> <p align="center">JDK 1.0时推出</p> </td></tr><tr><td width="36"> <p align="center">2</p> </td><td width="84"> <p align="center">性能</p> </td><td width="258"> <p align="center">采用异步处理方式，性能较高</p> </td><td width="258"> <p align="center">采用同步处理方式，性能较低</p> </td></tr><tr><td width="36"> <p align="center">3</p> </td><td width="84"> <p align="center">安全性</p> </td><td width="258"> <p align="center">数据安全性差</p> </td><td width="258"> <p align="center">数据安全性高</p> </td></tr><tr><td width="36"> <p align="center">4</p> </td><td width="84"> <p align="center">输出</p> </td><td width="258"> <p align="center">Iterator、ListIterator、foreach</p> </td><td width="258"> <p align="center">Iterator、ListIterator、foreach、Enumeration</p> </td></tr></tbody></table> 
 <p>         考虑到日后的开发异步开发居多，所以以ArrayList类为主。</p> 
 <p style="text-align:center;"><span style="font-size:18px;"><strong>三、Set集合接口</strong></span></p> 
 <p>Set之中保存的元素是不能够有重复，但是Set接口并不像List接口那样对Collection进行了方法的扩充，而是完整的继承了Collection接口的所有方法，那么也就意味着，在之前使用的get()方法无法使用了。</p> 
 <p>         Set子接口之中重要使用两个常用的子类：HashSet、TreeSet。</p> 
 <h4>1、散列存放的子类：HashSet（90%）</h4> 
 <p>         Hash是一种散列算法，指的保存数据没有序列。</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.HashSet;</p> <p align="left"><strong>import</strong> java.util.Set;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        Set all = <strong>new</strong> HashSet() ;</p> <p align="left">        all.add("HELLO") ;</p> <p align="left">        all.add("HELLO") ;  // 保存了重复数据</p> <p align="left">        all.add("WORLD") ;</p> <p align="left">        all.add("小金子") ;</p> <p align="left">        all.add("小谢子") ;</p> <p align="left">        System.<strong><em>out</em></strong>.println(all);</p> <p align="left">    }}</p> </td></tr></tbody></table> 
 <p>         使用HashSet是不能够保存重复数据的。而且保存的数据没有任何的顺序。</p> 
 <h4>2、排序存放的子类：TreeSet（10%）</h4> 
 <p>         如果希望里面的数据排序，则可以使用TreeSet子类。</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.Set;</p> <p align="left"><strong>import</strong> java.util.TreeSet;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        Set all = <strong>new</strong> TreeSet() ;</p> <p align="left">        all.add("B") ;</p> <p align="left">        all.add("D") ;  // 保存了重复数据</p> <p align="left">        all.add("E") ;</p> <p align="left">        all.add("A") ;</p> <p align="left">        all.add("C") ;</p> <p align="left">        System.<strong><em>out</em></strong>.println(all);</p> <p align="left">    }}</p> </td></tr></tbody></table> 
 <p>         但是对于排序一般意义不大，所以使用的时候还是以HashSet为主。</p> 
 <h4>3、关于数据排序的说明</h4> 
 <p>         使用TreeSet可以实现集合中数据排序的保存，那么在之前使用的是String型数据，下面使用自定义类。但是这个类如果要想正常的使用TreeSet保存，那么一定要在此类上实现java.lang.Comparable接口，以区分大小。</p> 
 <p>         但是在此时覆写compareTo()方法的时候必须注意到：所有的属性都必须进行比较，否则就会出现部分属性内容相同也会认为是同一对象的情况，造成数据的保存错误。</p> 
 <p><strong>范例：</strong>使用自定义类</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.Set;</p> <p align="left"><strong>import</strong> java.util.TreeSet;</p> <p align="left"><strong>class</strong> Person <strong>implements</strong> Comparable {<!-- --></p> <p align="left">    <strong>private</strong> String name ;</p> <p align="left">    <strong>private</strong> <strong>int</strong> age ;</p> <p align="left">    <strong>public</strong> Person(String name,<strong>int</strong> age) {<!-- --></p> <p align="left">        <strong>this</strong>.name = name ;</p> <p align="left">        <strong>this</strong>.age = age ;</p> <p align="left">    }</p> <p align="left">    @Override</p> <p align="left">    <strong>public</strong> String toString() {<!-- --></p> <p align="left">        <strong>return</strong> "姓名：" + <strong>this</strong>.name + "，年龄 :" + <strong>this</strong>.age + "\n" ;</p> <p align="left">    }</p> <p align="left">    @Override</p> <p align="left">    <strong>public</strong> <strong>int</strong> compareTo(Person o) {<!-- --></p> <p align="left">        <strong>if</strong> (<strong>this</strong>.age &gt; o.age) {<!-- --></p> <p align="left">            <strong>return</strong> -1 ;</p> <p align="left">        } <strong>else</strong> <strong>if</strong> (<strong>this</strong>.age &lt; o.age) {<!-- --></p> <p align="left">            <strong>return</strong> 1 ;</p> <p align="left">        }</p> <p align="left">        <strong>return</strong> <strong>this</strong>.name.compareTo(o.name);</p> <p align="left">    }</p> <p align="left">}</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        Set all = <strong>new</strong> TreeSet() ;</p> <p align="left">        all.add(<strong>new</strong> Person("张三",20)) ;</p> <p align="left">        all.add(<strong>new</strong> Person("李四",21)) ;</p> <p align="left">        all.add(<strong>new</strong> Person("赵六",21)) ; // 年龄重复</p> <p align="left">        all.add(<strong>new</strong> Person("王五",19)) ;</p> <p align="left">        all.add(<strong>new</strong> Person("王五",19)) ; // 彻底重复</p> <p align="left">        System.<strong><em>out</em></strong>.println(all);</p> <p align="left">    }</p> <p align="left">}</p> </td></tr></tbody></table> 
 <p>         通过此时的程序也可以得出一个结论：TreeSet使用过程之中一定要使用到Comparable接口，而且TreeSet集合里面是依靠Comparable接口的compareTo()方法返回的数据来区分是否为重复数据。</p> 
 <h4>4、关于重复数据的说明</h4> 
 <p>         Set子接口之中不允许保留重复数据，之前使用的TreeSet子类虽然依靠了Comparable接口进行重复数据判断，但是此判断的方式也只是针对于TreeSet这种排序结构起作用，而<strong>真正意义上的排序操作是不依靠接口的，而是依靠</strong><strong>Object</strong><strong>类之中的两个方法：</strong></p> 
 <p><strong>                  </strong> <strong>·</strong> <strong>取得对象的</strong><strong>hash</strong><strong>码：</strong><strong>public int hashCode()</strong><strong>；</strong></p> 
 <p><strong>                  </strong> <strong>·</strong> <strong>对象比较：</strong><strong>public boolean equals(Object obj)</strong><strong>；</strong></p> 
 <p><strong>        </strong> <strong>在判断对象是否重复的过程之中，其基本流程如下：</strong></p> 
 <p><strong>                  </strong> <strong>·</strong> <strong>首先使用要查询对象的</strong><strong>hashCode</strong><strong>与集合之中的保存对象的每一个</strong><strong>hashCode</strong><strong>进行比较；</strong></p> 
 <p><strong>                  </strong> <strong>·</strong> <strong>如果</strong><strong>hashCode</strong><strong>相同，则再使用</strong><strong>equals()</strong><strong>方法进行内容的比较。</strong></p> 
 <p><strong><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=777f59990102v92a&amp;url=http://album.sina.com.cn/pic/002bG55Lzy6Nyn96YPZ07" rel="nofollow"><img title="01500097_MLDN-魔乐科技-李兴华【Java核心技术】_Set集合接口" src="https://images2.imgbox.com/f9/ce/Kib785Tg_o.gif" alt="01500097_MLDN-魔乐科技-李兴华【Java核心技术】_Set集合接口" name="image_operate_50251415779305938" width="312" height="125"></a></strong></p> 
 <p><strong><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=777f59990102v92a&amp;url=http://album.sina.com.cn/pic/002bG55Lzy6NynaKDwGd6" rel="nofollow"><img title="01500097_MLDN-魔乐科技-李兴华【Java核心技术】_Set集合接口" src="https://images2.imgbox.com/c5/cd/tESYx8X7_o.gif" alt="01500097_MLDN-魔乐科技-李兴华【Java核心技术】_Set集合接口" name="image_operate_47261415779328831" width="427" height="302"></a></strong></p> 
 <p align="center"> </p> 
 <p align="center"> </p> 
 <p><strong>范例：</strong>重复对象判断</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.HashSet;</p> <p align="left"><strong>import</strong> java.util.Set;</p> <p align="left"><strong>class</strong> Person {<!-- --></p> <p align="left">    <strong>private</strong> String name ;</p> <p align="left">    <strong>private</strong> <strong>int</strong> age ;</p> <p align="left">    <strong>public</strong> Person(String name,<strong>int</strong> age) {<!-- --></p> <p align="left">        <strong>this</strong>.name = name ;</p> <p align="left">        <strong>this</strong>.age = age ;</p> <p align="left">    }</p> <p align="left">    @Override</p> <p align="left">    <strong>public</strong> String toString() {<!-- --></p> <p align="left">        <strong>return</strong> "姓名：" + <strong>this</strong>.name + "，年龄 :" + <strong>this</strong>.age + "\n" ;</p> <p align="left">    }</p> <p align="left">    @Override</p> <p align="left">    <strong>public</strong> <strong>int</strong> hashCode() {<!-- --></p> <p align="left">        <strong>final</strong> <strong>int</strong> prime = 31;</p> <p align="left">        <strong>int</strong> result = 1;</p> <p align="left">        result = prime * result + age;</p> <p align="left">        result = prime * result + ((name == <strong>null</strong>) ? 0 : name.hashCode());</p> <p align="left">        <strong>return</strong> result;</p> <p align="left">    }</p> <p align="left">    @Override</p> <p align="left">    <strong>public</strong> <strong>boolean</strong> equals(Object obj) {<!-- --></p> <p align="left">        <strong>if</strong> (<strong>this</strong> == obj)</p> <p align="left">            <strong>return</strong> <strong>true</strong>;</p> <p align="left">        <strong>if</strong> (obj == <strong>null</strong>)</p> <p align="left">            <strong>return</strong> <strong>false</strong>;</p> <p align="left">        <strong>if</strong> (getClass() != obj.getClass())</p> <p align="left">            <strong>return</strong> <strong>false</strong>;</p> <p align="left">        Person other = (Person) obj;</p> <p align="left">        <strong>if</strong> (age != other.age)</p> <p align="left">            <strong>return</strong> <strong>false</strong>;</p> <p align="left">        <strong>if</strong> (name == <strong>null</strong>) {<!-- --></p> <p align="left">            <strong>if</strong> (other.name != <strong>null</strong>)</p> <p align="left">                <strong>return</strong> <strong>false</strong>;</p> <p align="left">        } <strong>else</strong> <strong>if</strong> (!name.equals(other.name))</p> <p align="left">            <strong>return</strong> <strong>false</strong>;</p> <p align="left">        <strong>return</strong> <strong>true</strong>;</p> <p align="left">    }</p> <p align="left">}</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        Set all = <strong>new</strong> HashSet() ;</p> <p align="left">        all.add(<strong>new</strong> Person("张三",20)) ;</p> <p align="left">        all.add(<strong>new</strong> Person("李四",21)) ;</p> <p align="left">        all.add(<strong>new</strong> Person("赵六",21)) ; // 年龄重复</p> <p align="left">        all.add(<strong>new</strong> Person("王五",19)) ;</p> <p align="left">        all.add(<strong>new</strong> Person("王五",19)) ; // 彻底重复</p> <p align="left">        System.<strong><em>out</em></strong>.println(all);</p> <p align="left">    }</p> <p align="left">}</p> </td></tr></tbody></table> 
 <p>         任何情况下如果是对象的重复判断，永恒都使用hashCode()和equals()。</p> 
 <p style="text-align:center;"><span style="font-size:14pt;"><strong>四、Map集合接口</strong></span></p> 
 <p>Collection每次只能够保存一个对象，而Map每次可以保存一对对象。那么这对对象会按照“key=value”的形式进行存储，随后可以通过key找到对应的value，就好比电话号码本一样，例如，现在存了如下数据：</p> 
 <p>                   · name = 张三，tel = 110；</p> 
 <p>                   · name = 李四，tel = 119；</p> 
 <p>         现在找到了张三（找到了name），就可以找到与之对应的电话（tel），而这样的操作可以通过Map集合表示（public interface Map）。在使用Map接口的时候需要设置两个泛型类型，一个是key的类型，另外一个是value的类型，而在Map接口中定义了如下常用方法。</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="36"> <p align="center"><strong>No.</strong></p> </td><td width="282"> <p align="center"><strong>方法名称</strong></p> </td><td width="42"> <p align="center"><strong>类型</strong></p> </td><td width="276"> <p align="center"><strong>描述</strong></p> </td></tr><tr><td width="36"> <p align="center"><strong>1</strong></p> </td><td width="282"> <p align="center"><strong>public V put(K key, V value)</strong></p> </td><td width="42"> <p align="center"><strong>普通</strong></p> </td><td width="276"> <p><strong>集合之中保存数据</strong></p> </td></tr><tr><td width="36"> <p align="center"><strong>2</strong></p> </td><td width="282"> <p align="center"><strong>public V get(Object key)</strong></p> </td><td width="42"> <p align="center"><strong>普通</strong></p> </td><td width="276"> <p><strong>根据</strong><strong>key</strong><strong>取得对应的</strong><strong>value</strong></p> </td></tr><tr><td width="36"> <p align="center">3</p> </td><td width="282"> <p align="center">public Set keySet()</p> </td><td width="42"> <p align="center">普通</p> </td><td width="276"> <p>取得全部的key，key不能重复</p> </td></tr><tr><td width="36"> <p align="center">4</p> </td><td width="282"> <p align="center">public Collection values()</p> </td><td width="42"> <p align="center">普通</p> </td><td width="276"> <p>取得全部的value</p> </td></tr><tr><td width="36"> <p align="center"><strong>5</strong></p> </td><td width="282"> <p align="center"><strong>public Set&gt; entrySet()</strong></p> </td><td width="42"> <p align="center"><strong>普通</strong></p> </td><td width="276"> <p><strong>将</strong><strong>Map</strong><strong>集合变为</strong><strong>Set</strong><strong>集合</strong></p> </td></tr></tbody></table> 
 <p>         而在Map接口下又有两个常见的子类：HashMap、Hashtable。</p> 
 <h4>1、新的子类：HashMap（90%）</h4> 
 <p>         HashMap是Map接口中最为常用的一个子类，下面将使用HashMap验证Map的使用操作。</p> 
 <p><strong>范例：</strong>保存数据</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.HashMap;</p> <p align="left"><strong>import</strong> java.util.Map;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        Map map = <strong>new</strong> HashMap();</p> <p align="left">        map.put(1, "张三");</p> <p align="left">        map.put(1, "李四"); // key重复</p> <p align="left">        map.put(2, "王五");</p> <p align="left">        map.put(3, <strong>null</strong>);</p> <p align="left">        map.put(<strong>null</strong>, "赵六");</p> <p align="left">        System.<strong><em>out</em></strong>.println(map);</p> <p align="left">    }</p> <p>}</p> </td></tr></tbody></table> 
 <p>         在使用Map集合的时候如果发生了key重复的问题，那么会使用新的值替换掉旧的值。但是从实际来讲，设置在Map之中的数据主要是为了查找使用。</p> 
 <p><strong>         Collection</strong><strong>设置数据的目的主要是为了输出，而</strong><strong>Map</strong><strong>设置数据的目的主要是为了查找。</strong></p> 
 <p><strong>范例：</strong>查找数据</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.HashMap;</p> <p align="left"><strong>import</strong> java.util.Map;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        Map map = <strong>new</strong> HashMap();</p> <p align="left">        map.put(1, "张三");</p> <p align="left">        map.put(1, "李四"); // key重复</p> <p align="left">        map.put(2, "王五");</p> <p align="left">        map.put(3, <strong>null</strong>);</p> <p align="left">        map.put(<strong>null</strong>, "赵六");</p> <p align="left">        System.<strong><em>out</em></strong>.println(map.get(1));</p> <p align="left">        System.<strong><em>out</em></strong>.println(map.get(<strong>null</strong>));</p> <p align="left">        System.<strong><em>out</em></strong>.println(map.get(200));   // 没有返回null</p> <p align="left">    }</p> <p>}</p> </td></tr></tbody></table> 
 <p>         整个过程之中都是可以进行null操作的。</p> 
 <h4>2、旧的子类：Hashtable（10%）</h4> 
 <p>         Hashtable与Vector、Enumeration一样，都是最早提供的集合操作类，在JDK 1.2之后为了保护其可以继续使用，所以让Hashtable多实现了一个Map接口。</p> 
 <p><strong>范例：</strong>验证Hashtable</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.Hashtable;</p> <p align="left"><strong>import</strong> java.util.Map;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        Map map = <strong>new</strong> Hashtable();</p> <p align="left">        map.put(1, "张三");</p> <p align="left">        map.put(1, "李四"); // key重复</p> <p align="left">        map.put(2, "王五");</p> <p align="left">        System.<strong><em>out</em></strong>.println(map.get(1));</p> <p align="left">        System.<strong><em>out</em></strong>.println(map.get(200));   // 没有返回null</p> <p align="left">    }</p> <p>}</p> </td></tr></tbody></table> 
 <p>         在Hashtable的操作之中可以发现，里面是不能够存在有null数据的。</p> 
 <p><strong>面试题：</strong>请解释HashMap和Hashtable区别？</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="36"> <p align="center"><strong>No.</strong></p> </td><td width="84"> <p align="center"><strong>区别</strong></p> </td><td width="258"> <p align="center"><strong>HashMap</strong></p> </td><td width="258"> <p align="center"><strong>Hashtable</strong></p> </td></tr><tr><td width="36"> <p align="center">1</p> </td><td width="84"> <p align="center">推出时间</p> </td><td width="258"> <p align="center">JDK 1.2时推出</p> </td><td width="258"> <p align="center">JDK 1.0时推出</p> </td></tr><tr><td width="36"> <p align="center">2</p> </td><td width="84"> <p align="center">性能</p> </td><td width="258"> <p align="center">采用异步处理方式，性能较高</p> </td><td width="258"> <p align="center">采用同步处理方式，性能较低</p> </td></tr><tr><td width="36"> <p align="center">3</p> </td><td width="84"> <p align="center">安全性</p> </td><td width="258"> <p align="center">数据安全性差</p> </td><td width="258"> <p align="center">数据安全性高</p> </td></tr><tr><td width="36"> <p align="center">4</p> </td><td width="84"> <p align="center">处理null</p> </td><td width="258"> <p align="center">允许保存null</p> </td><td width="258"> <p align="center">不允许保存null，会出现NullPointerException</p> </td></tr></tbody></table> 
 <p>         考虑到日后的开发异步开发居多，所以以HashMap类为主。</p> 
 <h4>3、关于Map集合的输出说明（核心）</h4> 
 <p>         在Map接口里面存在有一个keySet()的方法，此方法返回的是所有的key的数据，并且是以Set集合的形式返回，于是下面就使用此方法输出数据。</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.HashMap;</p> <p align="left"><strong>import</strong> java.util.Iterator;</p> <p align="left"><strong>import</strong> java.util.Map;</p> <p align="left"><strong>import</strong> java.util.Set;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        Map map = <strong>new</strong> HashMap();</p> <p align="left">        map.put(1, "张三");</p> <p align="left">        map.put(2, "李四");</p> <p align="left">        map.put(3, "王五");</p> <p align="left">        Set set = map.keySet() ;   // 取得全部的key</p> <p align="left">        Iterator iter = set.iterator() ;</p> <p align="left">        <strong>while</strong> (iter.hasNext()) {<!-- --></p> <p align="left">            Integer key = iter.next() ;</p> <p align="left">            System.<strong><em>out</em></strong>.println(key + " --&gt; " + map.get(key));</p> <p align="left">        }</p> <p align="left">    }</p> <p>}</p> </td></tr></tbody></table> 
 <p>         就本程序而言，已经实现了Map集合的输出操作，但是这个输出操作存在以下问题：首先取得了全部key，需要进行迭代输出，而且每一个key又要去查询集合中对应的value（循环），所以这样的输出形式是不可取的。</p> 
 <p>         如果要想输出Map集合，那么一定还是需要使用到Iterator接口，可是Map接口里面并没有定义像Collection接口之中定义的iterator()方法，那么下面就需要分析一下Collection和Map的数据保存区别。</p> 
 <p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=777f59990102v92c&amp;url=http://album.sina.com.cn/pic/002bG55Lzy6NynoakPX35" rel="nofollow"><img style="margin-left:auto;" title="01500099_MLDN-魔乐科技-李兴华【Java核心技术】_Map集合接口" src="https://images2.imgbox.com/4c/02/YCs1YLmH_o.gif" alt="01500099_MLDN-魔乐科技-李兴华【Java核心技术】_Map集合接口" name="image_operate_65791415779501964" width="633" height="475"></a></p> 
 <p>         可以发现在Map接口里面存在有一个static定义的子接口：Map.Entry，而所有的key和value都自动的封装在了此接口对象之中，而在<strong>Map.Entry</strong><strong>接口里面存在有两个方法：</strong></p> 
 <p><strong>                  </strong> <strong>·</strong> <strong>取得包装的</strong><strong>key</strong><strong>：</strong><strong>public K getKey()</strong><strong>；</strong></p> 
 <p><strong>                  </strong> <strong>·</strong> <strong>取得包装的</strong><strong>value</strong><strong>：</strong><strong>public V getValue()</strong><strong>；</strong></p> 
 <p><strong>关于</strong><strong>Map</strong><strong>接口使用</strong><strong>Iterator</strong><strong>输出的过程：</strong></p> 
 <p>         1、   首先使用Map集合之中的entrySet()方法将Map集合变为Set集合，而此时Set集合中的每一个元素类型都是Map.Entry接口实例；</p> 
 <p>         2、   利用Set接口的iterator()方法取得Iterator接口对象，同时Iterator中操作的类型依然是Map.Entry；</p> 
 <p>         3、   利用Iterator进行迭代输出，取出每一个Map.Entry对象，并且利用getKey()和getValue()方法取出数据。</p> 
 <p><strong>范例：</strong>利用Iterator输出Map集合</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.HashMap;</p> <p align="left"><strong>import</strong> java.util.Iterator;</p> <p align="left"><strong>import</strong> java.util.Map;</p> <p align="left"><strong>import</strong> java.util.Set;</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        Map map = <strong>new</strong> HashMap();</p> <p align="left">        map.put(1, "张三");</p> <p align="left">        map.put(2, "李四");</p> <p align="left">        map.put(3, "王五");</p> <p align="left">        Set&gt; set = map.entrySet();</p> <p align="left">        Iterator&gt; iter = set.iterator();</p> <p align="left">        <strong>while</strong> (iter.hasNext()) {<!-- --></p> <p align="left">            Map.Entry me = iter.next();</p> <p align="left">            System.<strong><em>out</em></strong>.println(me.getKey() + " --&gt; " + me.getValue());</p> <p align="left">        }</p> <p align="left">    }</p> <p>}</p> </td></tr></tbody></table> 
 <p>         这一程序在工作之中一定会出现，建议下面多写几次，同时一定要记住Map.Entry的作用。</p> 
 <h4>4、关于Map集合之中key的说明</h4> 
 <p>         通过之前的代码演示发现一直都是使用Integer作为key的类型，而且Integer本身也是系统类。那么在实际上Map也可以使用自定义类型作为key。但是此时必须有一个要求：由于map集合根据key的查找属于对象的匹配过程，所以作为自定义的key类型，类一定要覆写Object类的hashCode()和equals()两个方法。</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="636"> <p align="left"><strong>package</strong> cn.mldn.demo;</p> <p align="left"><strong>import</strong> java.util.HashMap;</p> <p align="left"><strong>import</strong> java.util.Map;</p> <p align="left"><strong>class</strong> Person {<!-- --></p> <p align="left">    <strong>private</strong> String name ;</p> <p align="left">    <strong>private</strong> <strong>int</strong> age ;</p> <p align="left">    <strong>public</strong> Person(String name,<strong>int</strong> age) {<!-- --></p> <p align="left">        <strong>this</strong>.name = name ;</p> <p align="left">        <strong>this</strong>.age = age ;</p> <p align="left">    }</p> <p align="left">    @Override</p> <p align="left">    <strong>public</strong> String toString() {<!-- --></p> <p align="left">        <strong>return</strong> "姓名：" + <strong>this</strong>.name + "，年龄：" + <strong>this</strong>.age ;</p> <p align="left">    }</p> <p align="left">    @Override</p> <p align="left">    <strong>public</strong> <strong>int</strong> hashCode() {<!-- --></p> <p align="left">        <strong>final</strong> <strong>int</strong> prime = 31;</p> <p align="left">        <strong>int</strong> result = 1;</p> <p align="left">        result = prime * result + age;</p> <p align="left">        result = prime * result + ((name == <strong>null</strong>) ? 0 : name.hashCode());</p> <p align="left">        <strong>return</strong> result;</p> <p align="left">    }</p> <p align="left">    @Override</p> <p align="left">    <strong>public</strong> <strong>boolean</strong> equals(Object obj) {<!-- --></p> <p align="left">        <strong>if</strong> (<strong>this</strong> == obj)</p> <p align="left">            <strong>return</strong> <strong>true</strong>;</p> <p align="left">        <strong>if</strong> (obj == <strong>null</strong>)</p> <p align="left">            <strong>return</strong> <strong>false</strong>;</p> <p align="left">        <strong>if</strong> (getClass() != obj.getClass())</p> <p align="left">            <strong>return</strong> <strong>false</strong>;</p> <p align="left">        Person other = (Person) obj;</p> <p align="left">        <strong>if</strong> (age != other.age)</p> <p align="left">            <strong>return</strong> <strong>false</strong>;</p> <p align="left">        <strong>if</strong> (name == <strong>null</strong>) {<!-- --></p> <p align="left">            <strong>if</strong> (other.name != <strong>null</strong>)</p> <p align="left">                <strong>return</strong> <strong>false</strong>;</p> <p align="left">        } <strong>else</strong> <strong>if</strong> (!name.equals(other.name))</p> <p align="left">            <strong>return</strong> <strong>false</strong>;</p> <p align="left">        <strong>return</strong> <strong>true</strong>;</p> <p align="left">    }</p> <p align="left">}</p> <p align="left"><strong>public</strong> <strong>class</strong> TestDemo {<!-- --></p> <p align="left">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {<!-- --></p> <p align="left">        Map map = <strong>new</strong> HashMap();</p> <p align="left">        map.put(<strong>new</strong> Person("张三", 20), <strong>new</strong> String("ZS"));</p> <p align="left">        System.<strong><em>out</em></strong>.println(map.get(<strong>new</strong> Person("张三", 20)));</p> <p align="left">    }</p> <p>}</p> </td></tr></tbody></table> 
 <p>         以上的代码只是在一次重复强调了hashCode()和equals()的作用，但是从实际的角度来看，作为key的类型99%的情况下都会使用<strong>String</strong><strong>表示</strong>，或者使用Integer等系统类表示。</p> 
</div> 
<p>转载于:https://www.cnblogs.com/kvikon/p/4676518.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d758198da93351eb309528f5ed1655b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">android  权限清单</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7f41edb26fc1823a223db19ccdf4da7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot集成Sharding-JDBC</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>