<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>最小生成树（MST）的性质及算法 [转】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="最小生成树（MST）的性质及算法 [转】" />
<meta property="og:description" content="转自：
chensohg的博客 http://blog.sina.com.cn/u/1182060252 最小生成树性质1：设G=(V，E)是一个连通网络，U是顶点集V的一个真子集。若(u，v)是G中所有的一个端点在U(u∈U)里、另一个端点不在U(即v∈V-U)里的边中，具有最小权值的一条边，则一定存在G的一棵最小生成树包括此边(u，v)。
证明：
为方便说明，先作以下约定：
①将集合U中的顶点看作是红色顶点，②而V-U中的顶点看作是蓝色顶点，③连接红点和蓝点的边看作是紫色边，④权最小的紫边称为轻边(即权重最&#34;轻&#34;的边)。于是，MST性质中所述的边(u，v)就可简称为轻边。
用反证法证明MST性质：
假设G中任何一棵MST都不含轻边(u，v)。则若T是G的一棵MST，则它不含此轻边。
由于T是包含了G中所有顶点的连通图，所以T中必有一条从红点u到蓝点v的路径P，且P上必有一条紫边(u&#39;，v&#39;)连接红点集和蓝点集，否则u和v不连通。当把轻边(u，v)加入树T时，该轻边和P必构成了一个回路。删去紫边(u&#39;，v&#39;)后回路亦消除，由此可得另一生成树T&#39;。
T&#39;和T的差别仅在于T&#39;用轻边(u，v)取代了T中权重可能更大的紫边(u&#39;，v&#39;)。因为w(u，v)≤w(u&#39;，v&#39;)，所以 w(T&#39;)=w(T)&#43;w(u，v)-w(u&#39;，v&#39;)≤w(T)
故T&#39;亦是G的MST，它包含边(u，v)，这与假设矛盾。
所以，MST性质成立。
最小生成树性质2：其最大边权为生成树中最大边权最小的。
证明
反证法：假设Ta为一棵最小生成树，Tb为一棵非最小生成树且其最大边权小于Ta的最大边权。
e是最小生成树Ta的最大边，e将最小生成树Ta分为连通的2个部分A-&gt;B，Tb的连接A-&gt;B的边权为e1，e1&lt;=eb(Tb上最大边权）&lt;e,即A-&gt;B之间存在一条权值比e更小的连通A和B的边，故Ta不是最小生成树，矛盾，故假设不成立。
==========================================================================
Prim算法与Kruskal算法是寻找最小生成树的经典方法，两者皆为贪心法，一次“生成”一条“安全边”，如下所示：
GENERIC-MST-FUNCTION (G,w)
1 T := 空集合
2 while T 还不是生成树
3 do 找出对 T 来说是不会形成cycle，且权重最低的边 (u, v)
4 T := T U {(u, v)}
5 return T" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0a557e91ee7fbbcbbca5497394324f83/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-17T18:03:39+08:00" />
<meta property="article:modified_time" content="2017-04-17T18:03:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">最小生成树（MST）的性质及算法 [转】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>转自：</p> 
<p></p> 
<h2 id="blogname" class="blogtitle" style="margin:0px; padding:0px; border:0px; list-style:none; font-family:微软雅黑,黑体; font-size:24px; color:rgb(255,255,255); font-weight:300; background-color:rgb(188,211,229)"> <a target="_blank" href="http://blog.sina.com.cn/u/1182060252" rel="nofollow noopener noreferrer" style="text-decoration:none; color:rgb(255,255,255)">chensohg的博客</a></h2> 
<div id="bloglink" class="bloglink" style="color:rgb(255,255,255); padding-top:5px; font-family:Verdana,宋体,sans-serif; background-color:rgb(188,211,229)"> 
 <a target="_blank" href="http://blog.sina.com.cn/u/1182060252" rel="nofollow noopener noreferrer" style="text-decoration:none; color:rgb(255,255,255)">http://blog.sina.com.cn/u/1182060252</a> 
</div> 
<br> 
<p></p> 
<p>最小生成树性质1：设G=(V，E)是一个连通网络，U是顶点集V的一个真子集。若(u，v)是G中所有的一个端点在U(u∈U)里、另一个端点不在U(即v∈V-U)里的边中，具有最小权值的一条边，则一定存在G的一棵最小生成树包括此边(u，v)。<br> <br> 证明：<br> 为方便说明，先作以下约定：<br> 　　①将集合U中的顶点看作是红色顶点，②而V-U中的顶点看作是蓝色顶点，③连接红点和蓝点的边看作是紫色边，④权最小的紫边称为轻边(即权重最"轻"的边)。于是，MST性质中所述的边(u，v)就可简称为轻边。<br> 　　用反证法证明MST性质：<br> 　　假设G中任何一棵MST都不含轻边(u，v)。则若T是G的一棵MST，则它不含此轻边。<br> 由于T是包含了G中所有顶点的连通图，所以T中必有一条从红点u到蓝点v的路径P，且P上必有一条紫边(u'，v')连接红点集和蓝点集，否则u和v不连通。当把轻边(u，v)加入树T时，该轻边和P必构成了一个回路。删去紫边(u'，v')后回路亦消除，由此可得另一生成树T'。<br> T'和T的差别仅在于T'用轻边(u，v)取代了T中权重可能更大的紫边(u'，v')。因为w(u，v)≤w(u'，v')，所以 w(T')=w(T)+w(u，v)-w(u'，v')≤w(T)<br> 故T'亦是G的MST，它包含边(u，v)，这与假设矛盾。<br> 所以，MST性质成立。<br> <br> 最小生成树性质2：其最大边权为生成树中最大边权最小的。<br> <br> 证明<br> 反证法：假设Ta为一棵最小生成树，Tb为一棵非最小生成树且其最大边权小于Ta的最大边权。<br> e是最小生成树Ta的最大边，e将最小生成树Ta分为连通的2个部分A-&gt;B，Tb的连接A-&gt;B的边权为e1，e1&lt;=eb(Tb上最大边权）&lt;e,即A-&gt;B之间存在一条权值比e更小的连通A和B的边，故Ta不是最小生成树，矛盾，故假设不成立。<br> <br> ==========================================================================<br> Prim算法与Kruskal算法是寻找最小生成树的经典方法，两者皆为贪心法，一次“生成”一条“安全边”，如下所示：<br> <br> GENERIC-MST-FUNCTION (G,w)<br> 1 T := 空集合<br> 2 while T 还不是生成树<br> 3 do 找出对 T 来说是不会形成cycle，且权重最低的边 (u, v)<br> 4 T := T U {(u, v)}<br> 5 return T<br> <br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f7f6ae9d9055d14c209504fb18753eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Simulink中Simscape—Fluids模块（原Simhydraulics）学习记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bcbfe71ab4d8eea55300db93f4094cc8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SMOTE算法(人工合成数据)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>