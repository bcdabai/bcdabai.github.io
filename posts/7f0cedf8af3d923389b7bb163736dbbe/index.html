<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>高并发与负载均衡——网络TCP-IP基础知识 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="高并发与负载均衡——网络TCP-IP基础知识" />
<meta property="og:description" content="一、网络分层 1.七层（接口）：解耦，便于开发 应用层：
7.应用层：nginx，软件，浏览器，DNS6.表示层 传输层：
5.会话层4.传输层：lvs负载均衡 网络层：
3.网络层 链路层
2.链路层1.物理层 2.四层：TCP/IP协议，OSI 7L参考模型对7层的简化分层和实现 举例：GET / www.baidu.com/
1.应用层（应用层&#43;表示层糅合）:对数据与字符串的封装
http：字符串书写格式与两端方法的交互方式的定义smtpssh 4.传输层（会话层&#43;传输层糅合）（控制）:[三次握手&gt;&gt;（传输数据）&gt;&gt;四次挥手]
连接的定义：非物理的连接，是逻辑连接，是一种状态的确认（对TCP来说，就是三次握手的状态确认）tcp：面向连接（状态）的可靠传输协议 过程：客户端和服务端通信，客户端从65535个端口号中申请一个端口号和服务器固定端口进行通信（一般来说是80端口），三次握手成功后，客户端和服务端会各自开辟一个线程来进行通信。所以高并发问题会产生在线程数量和线程池方面。udp：不是面向连接的，不可靠的socket: IP:PORT-IP:PORT -netstat -natp 5.网络层：192.168.9.11
ip.icmpROUTE:下一跳 -route -n 6.链路层（链路层&#43;物理层糅合）：
以太网：Ethernet：MACARP:全F,两点通信，交换机学习 arp -a nginx：负载5w台，处在应用层，需要在传输层建立三次握手后才能进行应用层数据解析和负载
lvs负载均衡：负载10w台，工作在传输层，在三次握手&gt;&gt;数据传输&gt;&gt;四次挥手的整个过程中都可以监视数据包的状态，来进行快速的负载均衡，但是由于lvs没有权限观看应用层数据，所以属于瞎子负载，不会根据数据包的真实业务需求来进行业务负载，可能导致将数据包发送到错误的服务器（不干这个业务的服务器），这时需要nginx和lvs负载搭配使用来可以达到百万级别负载能力。也就是流量先集中在lvs负载均衡服务器，然后这些lvs负载均衡服务器将这些数据发送给它后面的nginx服务器，再由nginx服务器做负载均衡，发送给后台的各种业务功能的tomcat服务器。
二、高并发与负载均衡的三种模型推导 1.名词补充 2.四层网络对应模型 知识补充：NAT(网络地址/IP转换) S_NAT：数据源地址NAT转换 图1 图2 工作过程：
家里上网：假设在192.168.1.1的路由器网关下有192.168.1.88和192.168.1.66两个私有IP地址笔记本，他们要访问百度的公有ip123.123.123.88.他们的数据包会通过四层网络封装发送给广播地址192.168.1.255并由路由器的网关来接收并由路由器通过寻找下一跳的方式最终发送给百度服务器。由于在互联网中，第一点：不允许私有ip的存在，一旦发现源数据来自私有IP（192.168.1.88/66就是私有IP），则会丢弃掉该数据包，所以路由器会对私有IP进行转换，将私有IP转换为路由器内部由网络运营商分配给的公网IP也就是18.18.18.8。第二点：很有可能两个笔记本在建立连接开始申请的端口号都为21212，那么他们的完整端口号为192.168.1.88：21212和192.168.1.66.21212（图1）。那么在经过路由器的私有到公有IP的转换，两者的转换后的公有IP都为18.18.18.8:21212，那么到时候数据从百度回来后，路由器就不知道应该还给哪个笔记本了，所以路由器会在里面维护一个MAP，来对地址转换做记录（图2），路由器会申请两个不同的端口，例如123与212，分配给两个笔记本（图2）.最终两个笔记本的公有IP和端口号为18.18.18.8:123与18.18.18.8:212。这样数据包从百度服务器送回的时候，就可以根据MAP中的数据来区分应该送回给哪个笔记本了。这样的地址转换过程，称之为S_NAT地址转换。虚拟机上网：虚拟机如果想要访问百度，则虚拟机的宿主机先通过S_NAT将虚拟机的IP地址和端口号转换成宿主机的网卡IP地址，然后通过宿主机网卡再发送给路由器，路由器再经过S_NAT转换发送给百度服务器。 拓扑简略图 负载均衡器只做转发，不做三次握手，并保证三次握手&gt;&gt;数据传输&gt;&gt;四次挥手之间整体的过程完整统一，不被切分。
这里的四层负载均衡是一个简单实现，后台的Server是集群式部署而不是分布式部署，所以存储容量并没有提升。
具体实施 D_NAT:目标地址转换 图3 工作原理：客户端CIP通过TCP/IP访问负载均衡服务器VIP（也就是负载均衡服务器），然后负载均衡服务器再将客户端的数据包发送给真实服务器Server（RIP），但是由于客户端的目标是VIP，而不是RIP，那么RIP在拿到CIP_VIP的数据包后，由于发现其本身RIP与数据包目标VIP不同，那么服务器会丢弃掉这个数据包。那么握手就不能够建立起来了。所以在这个过程中，负载均衡服务器会将客户端的CIP_VIP数据包监视并修改为CIP_RIP数据包（原理类似S_NAT），并自己内部维护一个MAP来记录修改前的地址与修改后的地址以便数据会回送给客户端（将CIP_RIP的ip对应关系改回CIP_VIP的对应关系，如果不这样做的话，CIP_RIP的数据包直接发送给客户端，那么客户端发现和自己建立的CIP_VIP连接的IP对应关系不对应，则会丢弃改数据包），之后将CIP_RIP数据包发送给RIP，这个修改目标IP的转换，称之为D_NAT。
不足：所有的数据都是通过网线发送的，我们假设客户端有10000个，负载均衡服务器一个，server两个分别负载5000，首先我们要明确一个概念，网络的上行速度和下行速度是不一样的，换句话说，我们访问百度，只需要包装一个几百字节的数据包给服务器（上行），而服务器返回给我们html网页则是很大的，可能几个MB（下行），那么如果我们负载均衡服务器的网线带宽不够，能承受上行而不能承受如此高并发的下行（也就是说能经受访问，但是经受不了数据都从负载均衡服务器回送给客户端）。那么，速度还是很慢的，所以这时候我们想，下行这件事情不由负载均衡来干，由真实服务器RIP来做，来降低负载均衡服务器的下行压力，于是有了下面的模型。
改善后的具体实施：DR模型——直接路由模型 图4 PS:一台机器是可以配置两个IP的，IP对外网和公网是唯一不同的。我们的负载均衡服务器VIP为公网IP，配置在eth0的子接口eth0：2下，私网IP为DIP，确保和RealServer在同一网段下，配置在eth0接口下，我们可以通过ifconfig指令来查看。
关键点：
1.IP冲突问题：为了能够让RIP向客户端发送数据，则Server（RIP）的IP应该为VIP，这样才会匹配客户端的CIP_VIP请求数据包。但是RealServer的IP已经是RIP了并且IP必须是唯一的，而且负载均衡服务器的IP也是VIP，那么就不符合IP唯一的规则。解决办法是在RealServer中配置一个隐含IP为VIP（图4中的*VIP），且该隐含IP只对自己可见，对外网公网不可见，保证了IP地址对外和公网的唯一性，那么就可以实现向客户端回送数据包VIP_CIP。，并且解决了IP冲突的问题。
2.数据包发送问题：在解决了IP冲突问题后，还存在一个问题就是数据包循环问题，当负载均衡服务器收到CIP_VIP的数据包后，它会根据自己的路由表进行负载均衡，但是发现自己本身就是VIP，所以会将这个数据包又直接发给自己，不会做负载均衡。解决这一问题是要干扰负载均衡器，将CIP_VIP数据包进行一个加工，将数据包的目标MAC地址，拼接成RealServer(RIP)的MAC地址：CIP_VIP&#43;RIP_MAC。也就是说与D_NAT不同，D_NAT是更改IP地址将CIP_VIP变成CIP_RIP发送给RealServ-er，是IP层做的工作；而我们现在做的工作是IP层的目标IP不做改动，将链路层的MAC地址由负载均衡的MAC地址修改成RealServer的MAC地址。
3.局域网局限性问题：在解决了1和2之后，还是有问题，就是负载均衡服务器和RealServer必须在同一网段，也就是在同一个局域网下。如果不在同一个局域网下的话，那么负载均衡和RealServer之间相当于是互联网了，那么数据包从负载均衡要走到RealServer的过程是要经过路由判定的，要经过多个跳跃寻找网关了。而路由判定是IP层的工作，那么在IP层，MAC地址是要被替代的，那么根据路由最近判定原则，在第二跳MAC地址又会被刷新覆盖为负载均衡服务器的IP地址，那么数据包又发不出去了，被送回到负载均衡服务器。
4.后端RealServer不能使用NAT模式：在解决了1,2,3后，CIP_VIP&#43;RIP_MAC的数据包终于发送到了RealServer。RealServer在确认后将同样以Tcp/IP的方式发送给客户端，这时候不能使用NAT模式了，因为NAT模式会更改IP地址，将导致客户端因为IP地址不匹配同样不会接受数据包。所以RealServer不能以连接路由或者交换机的方式接入互联网，要直接连网线接入互联网。所以RealServer的默认网关应该直接指向运营商（ISP）,并有一个公网IP地址（PIP，也就是RealServer的下一跳）。
DR模型的再改善：TUN隧道模型——突破DR模型物理限制（LVS与RealServer必须在同一局域网下，也就是同一个区域下） 图5 工作原理：就是在IP层封装两层，最好理解TUN隧道技术的就是VPN，我们要访问VIP，那么客户端数据包通过路由转发到了负载均衡服务器，负载均衡服务器再在CIP_VIP外层包一层IP层信息DIP_RIP，则DIP与RIP之间通过配置好的隧道技术可以通信了。这就是VPN翻墙的原理，我们（CIP）如果要访问美国（RIP），那么我们会先访问香港（VIP），香港再访问美国。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7f0cedf8af3d923389b7bb163736dbbe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-22T21:28:28+08:00" />
<meta property="article:modified_time" content="2018-12-22T21:28:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">高并发与负载均衡——网络TCP-IP基础知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、网络分层</h2> 
<h3>1.七层（接口）：解耦，便于开发</h3> 
<p>应用层：</p> 
<ul><li>7.应用层：nginx，软件，浏览器，DNS</li><li>6.表示层</li></ul> 
<p>传输层：</p> 
<ul><li>5.会话层</li><li>4.传输层：<strong>lvs负载均衡</strong></li></ul> 
<p>网络层：</p> 
<ul><li>3.网络层</li></ul> 
<p>链路层</p> 
<ul><li>2.链路层</li><li>1.物理层 </li></ul> 
<h3>2.四层：TCP/IP协议，OSI 7L参考模型对7层的简化分层和实现</h3> 
<p>举例：GET / www.baidu.com/</p> 
<p>1.应用层（应用层+表示层糅合）:<strong>对数据与字符串的封装</strong></p> 
<ul><li>http：字符串书写格式与两端方法的交互方式的定义</li><li>smtp</li><li>ssh</li></ul> 
<p>4.传输层（会话层+传输层糅合）<span style="color:#f33b45;">（<strong>控制</strong>）:<strong>[三次握手&gt;&gt;（传输数据）&gt;&gt;四次挥手]</strong></span></p> 
<ul><li><strong>连接的定义：非物理的连接，是逻辑连接，是一种状态的确认（对TCP来说，就是三次握手的状态确认）</strong></li><li>tcp：<strong>面向连接（状态）的可靠传输协议</strong> 
  <ul><li><strong>过程：客户端和服务端通信，客户端从65535个端口号中申请一个端口号和服务器固定端口进行通信（一般来说是80端口），三次握手成功后，客户端和服务端会各自开辟一个线程来进行通信。所以高并发问题会产生在线程数量和线程池方面。</strong></li></ul></li><li>udp：不是面向连接的，不可靠的</li><li><span style="color:#f33b45;"><strong>socket:   IP:PORT-IP:PORT</strong></span></li><li><span style="color:#f33b45;"><strong>         -netstat  -natp</strong></span></li></ul> 
<p>5.网络层：192.168.9.11</p> 
<ul><li>ip.icmp</li><li><span style="color:#f33b45;"><strong>ROUTE:下一跳</strong></span></li><li><span style="color:#f33b45;"><strong>      -route   -n</strong></span></li></ul> 
<p>6.链路层（链路层+物理层糅合）：</p> 
<ul><li>以太网：Ethernet：MAC</li><li><span style="color:#f33b45;"><strong>ARP:全F,两点通信，交换机学习</strong></span> 
  <ul><li><span style="color:#f33b45;"><strong>arp -a</strong></span></li></ul></li></ul> 
<p><img alt="" class="has" height="492" src="https://images2.imgbox.com/ab/29/pCQvI1ik_o.png" width="737"></p> 
<p><img alt="" class="has" height="490" src="https://images2.imgbox.com/a0/dc/Cp0hs05c_o.png" width="728"></p> 
<p>nginx：负载5w台，处在<strong>应用层</strong>，<strong>需要在传输层建立三次握手后才能进行应用层数据解析和负载</strong></p> 
<p>lvs负载均衡：负载10w台，工作在<strong>传输层</strong>，<strong>在三次握手&gt;&gt;数据传输&gt;&gt;四次挥手的整个过程中都可以监视数据包的状态，来进行快速的负载均衡</strong>，但是由于lvs没有权限观看应用层数据，所以属于瞎子负载，<strong>不会根据数据包的真实业务需求来进行业务负载</strong>，<strong>可能导致将数据包发送到错误的服务器（不干这个业务的服务器）</strong>，<strong>这时需要nginx和lvs负载搭配使用来可以达到百万级别负载能力。也就是流量先集中在lvs负载均衡服务器，然后这些lvs负载均衡服务器将这些数据发送给它后面的nginx服务器，再由nginx服务器做负载均衡，发送给后台的各种业务功能的tomcat服务器。</strong></p> 
<p> </p> 
<h2><strong>二、高并发与负载均衡的三种模型推导</strong></h2> 
<h3><strong>1.名词补充</strong></h3> 
<p><img alt="" class="has" height="492" src="https://images2.imgbox.com/2e/2c/CThYPqDL_o.png" width="728"></p> 
<h3><strong>2.四层网络对应模型</strong></h3> 
<ul><li> <h4>知识补充：NAT(网络地址/IP转换)</h4> 
  <ul><li> <h4>S_NAT：数据源地址NAT转换</h4> </li></ul></li></ul> 
<h4><strong>图1</strong></h4> 
<p>          <img alt="" class="has" height="483" src="https://images2.imgbox.com/84/5d/mI2byTLs_o.png" width="814"></p> 
<h4><strong>图2</strong></h4> 
<p>          <img alt="" class="has" height="484" src="https://images2.imgbox.com/a8/12/F9pJZDF2_o.png" width="817"></p> 
<p><strong>工作过程</strong>：</p> 
<ul><li><strong>家里上网：</strong>假设在192.168.1.1的路由器网关下有192.168.1.88和192.168.1.66两个私有IP地址笔记本，他们要访问百度的公有ip123.123.123.88.<strong>他们的数据包会通过四层网络封装发送给广播地址192.168.1.255并由路由器的网关来接收并由路由器通过寻找下一跳的方式最终发送给百度服务器</strong>。由于在互联网中，<strong>第一点</strong>：<strong>不允许私有ip的存在</strong>，一旦发现源数据来自私有IP（192.168.1.88/66就是私有IP），<strong>则会丢弃掉该数据包</strong>，所以<strong>路由器会对私有IP进行转换，将私有IP转换为路由器内部由网络运营商分配给的公网IP也就是18.18.18.8</strong>。<strong>第二点：</strong>很有可能两个笔记本在建立连接开始申请的端口号都为21212，那么他们的完整端口号为192.168.1.88：21212和192.168.1.66.21212（图1）。那么在经过路由器的私有到公有IP的转换，两者的转换后的公有IP都为18.18.18.8:21212，那么到时候数据从百度回来后，路由器就不知道应该还给哪个笔记本了，<strong>所以路由器会在里面维护一个MAP，来对地址转换做记录（图2），路由器会申请两个不同的端口，例如123与212，分配给两个笔记本（图2）.最终两个笔记本的公有IP和端口号为18.18.18.8:123与18.18.18.8:212。这样数据包从百度服务器送回的时候，就可以根据MAP中的数据来区分应该送回给哪个笔记本了。这样的地址转换过程，称之为S_NAT地址转换。</strong></li><li><strong>虚拟机上网：虚拟机如果想要访问百度，则虚拟机的宿主机先通过S_NAT将虚拟机的IP地址和端口号转换成宿主机的网卡IP地址，然后通过宿主机网卡再发送给路由器，路由器再经过S_NAT转换发送给百度服务器。</strong></li><li> <h4><strong>拓扑简略图</strong></h4> </li></ul> 
<p><img alt="" class="has" height="472" src="https://images2.imgbox.com/88/6c/iTnn6OVC_o.png" width="734"></p> 
<p><strong>负载均衡器只做转发，不做三次握手，并保证<span style="color:#f33b45;">三次握手&gt;&gt;数据传输&gt;&gt;四次挥手</span>之间整体的过程完整统一，不被切分。</strong></p> 
<p><strong>这里的四层负载均衡是一个简单实现，后台的Server是集群式部署而不是分布式部署，所以存储容量并没有提升。</strong></p> 
<ul><li> <h4><strong>具体实施</strong></h4> 
  <ul><li> <h4><strong>D_NAT:目标地址转换</strong></h4> </li></ul></li></ul> 
<h4><strong>图3</strong></h4> 
<p><img alt="" class="has" height="503" src="https://images2.imgbox.com/10/ae/39LkVobz_o.png" width="874"></p> 
<p> </p> 
<p><strong>工作原理</strong>：客户端CIP通过TCP/IP访问负载均衡服务器VIP（也就是负载均衡服务器），然后负载均衡服务器再将客户端的数据包发送给真实服务器Server（RIP），但是由于客户端的目标是VIP，而不是RIP，<strong>那么RIP在拿到CIP_VIP的数据包后，由于发现其本身RIP与数据包目标VIP不同，那么服务器会丢弃掉这个数据包。那么握手就不能够建立起来了。</strong>所以在这个过程中，负载均衡服务器会<strong>将客户端的CIP_VIP数据包监视并修改为CIP_RIP数据包（原理类似S_NAT）</strong>，<strong>并自己内部维护一个MAP来记录修改前的地址与修改后的地址以便数据会回送给客户端（将CIP_RIP的ip对应关系改回CIP_VIP的对应关系，如果不这样做的话，CIP_RIP的数据包直接发送给客户端，那么客户端发现和自己建立的CIP_VIP连接的IP对应关系不对应，则会丢弃改数据包），之后将CIP_RIP数据包发送给RIP，这个修改目标IP的转换，称之为D_NAT。</strong></p> 
<p><strong>不足：所有的数据都是通过网线发送的，</strong>我们假设客户端有10000个，负载均衡服务器一个，server两个分别负载5000，<strong>首先我们要明确一个概念，网络的上行速度和下行速度是不一样的，换句话说，我们访问百度，只需要包装一个几百字节的数据包给服务器（上行），而服务器返回给我们html网页则是很大的，可能几个MB（下行），那么如果我们负载均衡服务器的网线带宽不够，能承受上行而不能承受如此高并发的下行（也就是说能经受访问，但是经受不了数据都从负载均衡服务器回送给客户端</strong><strong>）。那么，速度还是很慢的，所以这时候我们想，下行这件事情不由负载均衡来干，由真实服务器RIP来做，来降低负载均衡服务器的下行压力，于是有了下面的模型。</strong></p> 
<ul><li> <h4><strong>改善后的具体实施：DR模型——直接路由模型</strong></h4> </li></ul> 
<h4>图4</h4> 
<p><img alt="" class="has" height="471" src="https://images2.imgbox.com/dd/59/h2WiHDi6_o.png" width="848"></p> 
<p><strong>PS:一台机器是可以配置两个IP的，<span style="color:#f33b45;">IP对外网和公网是唯一不同的</span>。我们的负载均衡服务器VIP为公网IP，配置在eth0的子接口eth0：2下，私网IP为DIP，确保和RealServer在同一网段下，配置在eth0接口下，我们可以通过ifconfig指令来查看。</strong></p> 
<p><strong>关键点：</strong></p> 
<p><strong>1.IP冲突问题：为了能够让RIP向客户端发送数据，则Server（RIP）的IP应该为VIP，这样才会匹配客户端的CIP_VIP请求数据包。但是RealServer的IP已经是RIP了并且IP必须是唯一的，而且负载均衡服务器的IP也是VIP，那么就不符合IP唯一的规则。解决办法是在RealServer中配置一个隐含IP为VIP（图4中的*VIP），且<span style="color:#f33b45;">该隐含IP只对自己可见，对外网公网不可见，保证了IP地址对外和公网的唯一性</span>，那么就可以实现向客户端回送数据包VIP_CIP。，并且解决了IP冲突的问题。</strong></p> 
<p><strong>2.数据包发送问题：在解决了IP冲突问题后，还存在一个问题就是数据包循环问题，当负载均衡服务器收到CIP_VIP的数据包后，它会根据自己的路由表进行负载均衡，但是发现自己本身就是VIP，所以会将这个数据包又直接发给自己，不会做负载均衡。解决这一问题是要干扰负载均衡器，将CIP_VIP数据包进行一个加工，将数据包的目标MAC地址，拼接成RealServer(RIP)的MAC地址：CIP_VIP+RIP_MAC。<span style="color:#f33b45;">也就是说与D_NAT不同，D_NAT是更改IP地址将CIP_VIP变成CIP_RIP发送给RealServ-er，是IP层做的工作</span>；而我们现在做的工作是IP层的<span style="color:#f33b45;">目标IP不做改动，将链路层的MAC地址由负载均衡的MAC地址修改成RealServer的MAC地址。</span></strong></p> 
<p>3.<strong>局域网局限性问题</strong>：在解决了1和2之后，还是有问题，<strong><span style="color:#f33b45;">就是负载均衡服务器和RealServer必须在同一网段，也就是在同一个局域网下</span>。如果不在同一个局域网下的话，那么负载均衡和RealServer之间相当于是互联网了，那么数据包从负载均衡要走到RealServer的过程是要经过路由判定的，要经过多个跳跃寻找网关了。而路由判定是IP层的工作，那么在IP层，MAC地址是要被替代的，那么根据路由最近判定原则，在第二跳MAC地址又会被刷新覆盖为负载均衡服务器的IP地址，那么数据包又发不出去了，被送回到负载均衡服务器。</strong></p> 
<p><strong>4.后端RealServer不能使用NAT模式：在解决了1,2,3后，CIP_VIP+RIP_MAC的数据包终于发送到了RealServer。RealServer在确认后将同样以Tcp/IP的方式发送给客户端，<span style="color:#f33b45;">这时候不能使用NAT模式了，因为NAT模式会更改IP地址，将导致客户端因为IP地址不匹配同样不会接受数据包。所以RealServer不能以连接路由或者交换机的方式接入互联网，要直接连网线接入互联网。所以RealServer的默认网关应该直接指向运营商（ISP）,并有一个公网IP地址（PIP，也就是RealServer的下一跳）。</span></strong></p> 
<ul><li> <h4><strong>DR模型的再改善：TUN隧道模型——突破DR模型物理限制（LVS与RealServer必须在同一局域网下，也就是同一个区域下）</strong></h4> </li></ul> 
<h4><strong>图5</strong></h4> 
<p><img alt="" class="has" height="476" src="https://images2.imgbox.com/2e/ed/ZCJ7bOYG_o.png" width="786"></p> 
<p><strong>工作原理：就是在IP层封装两层，最好理解TUN隧道技术的就是VPN，我们要访问VIP，那么客户端数据包通过路由转发到了负载均衡服务器，负载均衡服务器再在CIP_VIP外层包一层IP层信息DIP_RIP，则DIP与RIP之间通过配置好的隧道技术可以通信了。这就是VPN翻墙的原理，我们（CIP）如果要访问美国（RIP），那么我们会先访问香港（VIP），香港再访问美国。</strong></p> 
<h2> </h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5fe0c653fd3ab055a5003f318b09ee1d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx中部署vue前端项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb14948bc6fb94ac248a2f895452091a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Typescript 静态字段（static）的声明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>