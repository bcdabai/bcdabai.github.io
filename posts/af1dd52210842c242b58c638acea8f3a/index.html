<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vision Transformer with Deformable Attention - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vision Transformer with Deformable Attention" />
<meta property="og:description" content="🌞欢迎来到一起看论文
🌈博客主页：卿云阁
💌欢迎关注🎉点赞👍收藏⭐️留言📝
✉️希望可以和大家一起完成进阶之路！
🙏作者水平很有限，如果发现错误，请留言轰炸哦！万分感谢！
核心思想 DAT的核心思想主要包括以下几个方面：
可变形注意力（Deformable Attention）：传统的Transformer使用标准的自注意力机制，这种机制会处理图像中的所有像素，导致计算量很大。而DAT引入了可变形注意力机制，它只关注图像中的一小部分关键区域。这种方法可以显著减少计算量，同时保持良好的性能。
动态采样点：在可变形注意力机制中，DAT动态地选择采样点，而不是固定地处理整个图像。这种动态选择机制使得模型可以更加集中地关注于那些对当前任务最重要的区域。
即插即用：DAT的设计允许它适应不同的图像大小和内容，使其在多种视觉任务中都能有效工作，如图像分类、对象检测等。
attention机制中的query，key，value Query、Key的作用是用来在token之间搬运信息的，而Value本身就是从当前token当中提取出来的信息。本质上都是 对X的线性变换。
本文提出了一种简单有效的可变形的自注意力模块，并在此模块上构造了一个强大的Pyramid Backbone，即可变形的注意力Transformer(Deformable Attention Transformer, DAT)，用于图像分类和各种密集的预测任务。不同于DCN，在整个特征图上针对不同像素学习不同的offset，作者建议学习几组query无关的offset，将key和value移到重要区域(如图1(d)所示)，这是针对不同query的全局注意力通常会导致几乎相同的注意力模式的观察结果。这种设计既保留了线性空间的复杂性，又为Transformer的主干引入了可变形的注意力模式。
具体来说：
对于每个注意力模块，首先将参考点生成为统一的网格，这些网格在输入数据中是相同的；
然后，offset网络将query特征作为输入，并为所有参考点生成相应的offset。这样一来，候选的key /value被转移到重要的区域，从而增强了原有的自注意力模块的灵活性和效率，从而捕获更多的信息特征。
本文提出了Deformable Attention，在特征映射中重要区域的引导下，有效地建模Token之间的关系。这些集中的regions由offset网络从query中学习到的多组Deformable sampling点确定。采用双线性插值对特征映射中的特征进行采样，然后将采样后的特征输入key投影得到Deformable Key。
给定输入特征图，生成一个点的统一网格作为一个token，利用Linear layer把我们的query做出来，query留着后面直接做attention。
用这个query做一个offset，（告诉我attention的范围是什么），原始的图像经过down sample，比如上图剩下了4个Reference Points，然后加上offsets，对Reference Points发生了移动，移动到相应的位置，然后在这个位置我们取它临近的4个token，然后经过线性插值操作，这些token叫做Sample Features，然后把插值出来的token送到我们的这个value projection，key projection有了query，key，value，然后一起做attention。由于我们时间上取的token的位置不是一个整数，所以position of embedding也要相应的变化，对其进行Relative Position Bias Offsets 操作，然后一起做attention操作。Offset，首先输入是H*W*C，这个是我们query的尺寸，经过stride=r的，卷积核大小的k*k的，DWConv，然后是激活函数，然后再做一个1*1的convolution，就是对每一个channel做MLP。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/af1dd52210842c242b58c638acea8f3a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-28T19:04:46+08:00" />
<meta property="article:modified_time" content="2024-01-28T19:04:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vision Transformer with Deformable Attention</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>🌞欢迎来到<strong>一起看论文</strong><br> 🌈博客主页：<a class="link-info" href="https://blog.csdn.net/zzqingyun?spm=1011.2415.3001.5343" title="卿云阁">卿云阁</a></p> 
 <p>💌欢迎关注🎉点赞👍收藏⭐️留言📝</p> 
 <p>✉️希望可以和大家一起完成进阶之路！</p> 
 <p>🙏作者水平很有限，如果发现错误，请留言轰炸哦！万分感谢！</p> 
 <hr> 
 <h4>核心思想</h4> 
 <p>DAT的核心思想主要包括以下几个方面：</p> 
 <ol><li> <p><strong>可变形注意力（Deformable Attention）</strong>：传统的Transformer使用标准的自注意力机制，这种机制会处理图像中的所有像素，导致计算量很大。而DAT引入了可变形注意力机制，它只关注图像中的一小部分关键区域。这种方法可以显著减少计算量，同时保持良好的性能。</p> </li><li> <p><strong>动态采样点</strong>：在可变形注意力机制中，DAT动态地选择采样点，而不是固定地处理整个图像。这种动态选择机制使得模型可以更加集中地关注于那些对当前任务最重要的区域。</p> </li><li> <p><strong>即插即用</strong>：DAT的设计允许它适应不同的图像大小和内容，使其在多种视觉任务中都能有效工作，如图像分类、对象检测等。</p> </li></ol> 
 <hr> 
 <h4>attention机制中的query，key，value</h4> 
 <p>      Query、Key的作用是用来在token之间搬运信息的，而Value本身就是从当前token当中提取出来的信息。<strong>本质上都是</strong> 对X<strong>的线性变换</strong>。</p> 
 <p><img alt="" height="644" src="https://images2.imgbox.com/23/ea/EPFCCGx3_o.png" width="634"></p> 
 <hr> 
 <p>   本文提出了一种简单有效的可变形的自注意力模块，并在此模块上构造了一个强大的Pyramid Backbone，即可变形的注意力Transformer(Deformable Attention Transformer, DAT)，用于图像分类和各种密集的预测任务。不同于DCN，在整个特征图上针对不同像素学习不同的offset，作者建议学习几组query无关的offset，将key和value移到重要区域(如图1(d)所示)，这是针对不同query的全局注意力通常会导致几乎相同的注意力模式的观察结果。这种设计既保留了线性空间的复杂性，又为Transformer的主干引入了可变形的注意力模式。</p> 
 <p>具体来说：</p> 
 <ul><li> <p>对于每个注意力模块，首先将参考点生成为统一的网格，这些网格在输入数据中是相同的；</p> </li><li> <p>然后，offset网络将query特征作为输入，并为所有参考点生成相应的offset。这样一来，候选的key /value被转移到重要的区域，从而增强了原有的自注意力模块的灵活性和效率，从而捕获更多的信息特征。</p> </li></ul> 
 <p><img alt="" height="472" src="https://images2.imgbox.com/1f/28/alTzPZdV_o.png" width="939"></p> 
 <p>    本文提出了Deformable Attention，在特征映射中重要区域的引导下，有效地建模Token之间的关系。这些集中的regions由offset网络从query中学习到的多组Deformable sampling点确定。采用双线性插值对特征映射中的特征进行采样，然后将采样后的特征输入key投影得到Deformable Key。</p> 
 <p><img alt="" height="420" src="https://images2.imgbox.com/70/ef/roDTv3E7_o.png" width="1080"></p> 
 <p>    给定输入特征图，生成一个点的统一网格作为一个token，利用Linear layer把我们的query做出来，query留着后面直接做attention。</p> 
 <p>     用这个query做一个offset，（告诉我attention的范围是什么），原始的图像经过down sample，比如上图剩下了4个Reference Points，然后加上offsets，对Reference Points发生了移动，移动到相应的位置，然后在这个位置我们取它临近的4个token，然后经过线性插值操作，这些token叫做Sample Features，然后把插值出来的token送到我们的这个value projection，key projection有了query，key，value，然后一起做attention。由于我们时间上取的token的位置不是一个整数，所以position of embedding也要相应的变化，对其进行Relative Position Bias Offsets 操作，然后一起做attention操作。<strong>Offset，</strong>首先输入是H*W*C，这个是我们query的尺寸，经过stride=r的，卷积核大小的k*k的，DWConv，然后是激活函数，然后再做一个1*1的convolution，就是对每一个channel做MLP。</p> 
 <p><img alt="" height="284" src="https://images2.imgbox.com/f8/02/WXLX3V9E_o.png" width="928"></p> 
 <p></p> 
</blockquote> 
<p></p> 
<p></p> 
<h3></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dfe8b6f67f90e37f6ef27f14e1f2e758/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Compose | UI组件(九) | Column,Row - 线性布局</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/218f5da29fc099bc33c621232808c669/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">stompcmd安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>