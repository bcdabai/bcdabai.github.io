<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>洛谷1982-小朋友的数字-noip2013 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="洛谷1982-小朋友的数字-noip2013" />
<meta property="og:description" content="/*
主要考察语文能力，关键把题读懂。 (分数&#43;特征值)的最大值！
读完题就能发现这是个（几乎是裸的）最大子段和问题。对于最大子段和问题，我们有O(N)的算法。 具体的做法是这样的：当前要求第I位及之前的最大子段和，如果第（I-1）位及之前的最大子段和大于0，则显然这一位取了也未尝不可（不会减少），也就是当前这一位和前面一段连接起来。否则的话，就新开一段——把前面的最大子段和改成0以后继续往下扫描。 如果一定要说这是DP也可以。 这样朴素的做能得50分， 在计算特征值与分数的过程中记录一下最大值可以的得到80分 原因在与最后两个点的分数值超过了longlong。 进一步分析可以发现除了第一个小朋友外剩下的小朋友的分数值是不下降的。所以对于一个小朋友他的分数只有两种情况。 1.如果他的前一个小朋友的特征值大于0，那他的分数就为前一个小朋友的分数加上前一个小朋友的特征值。更新当前最大值。 2.如果他的前一个小朋友的特征值小于0，那他的分数就为第二个小朋友的分数。 （特征值小于0，也就是其前面的数字里面没有正的，都是负的，所以才是第二个小朋友的分数。）
当一个小朋友的分数值大于1000000000时我们取模 因为第一个小朋友的分数不会大于1000000000，所以我们就可以在计算过程中判断出来是否有小朋友的分数大于第一个小朋友。 这样就可以拿到满分。
*/
#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; long long maxx,a[1000001],n,m,p,f[1000001]={0},b[1000001],ff[1000001],ans; bool zf; int main() { cin&gt;&gt;n&gt;&gt;p; for (int i=1;i&lt;=n;i&#43;&#43;) scanf(&#34;%lld&#34;,&amp;a[i]); f[1]=a[1];maxx=a[1]; ff[1]=a[1]; for (int i=2;i&lt;=n;i&#43;&#43;) { f[i]=max(f[i-1]&#43;a[i],a[i]); ff[i]=max(maxx,f[i]); maxx=ff[i]; } b[1]=ff[1]; b[2]=ff[1]&#43;b[1]; if (b[2]&gt;=b[1]) zf=true; maxx=b[2]; for (int i=3;i&lt;=n;i&#43;&#43;) { if (ff[i-1]&gt;0) { b[i]=b[i-1]&#43;ff[i-1]; if (b[i]&gt;b[1]) zf=true; if (b[i]&gt;1000000000) b[i]%=p; } else b[i]=b[2]; } if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f3c7cc001239ca1689477a892b63d9aa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-06T14:48:29+08:00" />
<meta property="article:modified_time" content="2018-09-06T14:48:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">洛谷1982-小朋友的数字-noip2013</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>/*<br> 主要考察语文能力，关键把题读懂。 </p> 
<p>(分数+特征值)的最大值！<br> 读完题就能发现这是个（几乎是裸的）最大子段和问题。对于最大子段和问题，我们有O(N)的算法。 具体的做法是这样的：当前要求第I位及之前的最大子段和，如果第（I-1）位及之前的最大子段和大于0，则显然这一位取了也未尝不可（不会减少），也就是当前这一位和前面一段连接起来。否则的话，就新开一段——把前面的最大子段和改成0以后继续往下扫描。 如果一定要说这是DP也可以。 <br> 这样朴素的做能得50分， <br> 在计算特征值与分数的过程中记录一下最大值可以的得到80分 <br> 原因在与最后两个点的分数值超过了longlong。 <br> 进一步分析可以发现除了第一个小朋友外剩下的小朋友的分数值是不下降的。所以对于一个小朋友他的分数只有两种情况。 <br> 1.如果他的前一个小朋友的特征值大于0，那他的分数就为前一个小朋友的分数加上前一个小朋友的特征值。更新当前最大值。 <br> 2.如果他的前一个小朋友的特征值小于0，那他的分数就为第二个小朋友的分数。 （特征值小于0，也就是其前面的数字里面没有正的，都是负的，所以才是第二个小朋友的分数。）<br> 当一个小朋友的分数值大于1000000000时我们取模 <br> 因为第一个小朋友的分数不会大于1000000000，所以我们就可以在计算过程中判断出来是否有小朋友的分数大于第一个小朋友。 <br> 这样就可以拿到满分。<br> */</p> 
<pre class="has"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt; 
using namespace std;
long long maxx,a[1000001],n,m,p,f[1000001]={0},b[1000001],ff[1000001],ans;
bool zf;
int main()
{
    cin&gt;&gt;n&gt;&gt;p;
    for (int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]);
    f[1]=a[1];maxx=a[1];
    ff[1]=a[1];
    for (int i=2;i&lt;=n;i++)
      {
        f[i]=max(f[i-1]+a[i],a[i]);
        ff[i]=max(maxx,f[i]);
        maxx=ff[i];
     }
    b[1]=ff[1];
    b[2]=ff[1]+b[1];
    if (b[2]&gt;=b[1]) zf=true;
    maxx=b[2];
    for (int i=3;i&lt;=n;i++)
      {
         if (ff[i-1]&gt;0)
           {
             b[i]=b[i-1]+ff[i-1];
             if (b[i]&gt;b[1]) zf=true;
             if (b[i]&gt;1000000000) b[i]%=p;
           }
         else
             b[i]=b[2];  
      }
    if (!zf) ans=b[1];
    else ans=b[n];
    ans%=p; 
    printf("%lld",ans);        
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be923b3500635941d73239757d64eebf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">根据Select的value、text值选中option</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17cb7606588bc8a3091934b6c2c5ac28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jCanvas插件使用手册</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>