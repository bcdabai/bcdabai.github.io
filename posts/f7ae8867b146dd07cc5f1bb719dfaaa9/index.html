<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网络-TCP - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网络-TCP" />
<meta property="og:description" content="TCP介绍 TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。
TCP通信需要经过创建连接、数据传送、终止连接三个步骤。
TCP通信模型中，在通信开始之前，一定要先建立相关的连接，才能发送数据，类似于生活中，&#34;打电话&#34;.
TCP特点 1. 面向连接 通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。
双方间的数据传输都可以通过这一个连接进行。
完成数据交换后，双方必须断开此连接，以释放系统资源。
这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。
2. 可靠传输 TCP采用发送应答机制 TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功
超时重传 发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。
TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。
错误校验 TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。
流量控制和阻塞管理 流量控制用来避免主机发送得过快而使接收方来不及完全收下。
TCP与UDP的不通点 面向连接（确认有创建三方交握，连接已创建才作传输。）有序数据传输重发丢失的数据包舍弃重复的数据包无差错的数据传输阻塞/流量控制 UDP通信模型 udp通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，&#34;写信&#34;
TCP通信模型 udp通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，&#34;打电话&#34;
TCP注意点 tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。关闭accept返回的套接字意味着这个客户端已经服务完毕当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线 UDP/TCP流程 UDP流程TCP客户端流程TCP服务器socketsocketsocketbindbindbindsend/recvconnectlistenclosecloseacceptsend/recvclose TCP三次握手 在UDP中, 一大特点是我们发的数据,接收端有没有收到我们并不知
而TCP的特点, 操作系统的底层会相互打交道告诉对方消息收到了
更详细的过程请看百度百科三次握手
缩写全称翻译描述SYNSynchronize Sequence Numbers同步序列编号TCP连接的第一个包，非常小的一种数据包。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息。ACKAcknowledgement确认字符在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。SYN_SENTTransmission Control Protocol, TCP传输控制协议SYN_SENT表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为ESTABLISHED，此时SYN_SENT状态非常短暂。SYN_RECVSYN_RECV是指,服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。ESTABLISHED含义TCP:连接成功，establish的过去式 至于为什么是三次握手, 知乎上也有很多人解答TCP 为什么是三次握手，而不是两次或四次？
简单梳理一下流程
第一次握手
client(客户端)向server(服务器)发送一个SYN(同步序列编号) = j的包, 同时进入SYN_SENT状态, 等待服务器回复
第二次握手
server(服务器)收到client(客户端)的SYN(同步序列编号)包, 会进行确认得到ACK = j&#43;1.与此同时自己也会发送一个(SYN(同步序列编号) = k)&#43;ACK(确认字符)的包给client(客户端), 此时服务器进入SYN_RECV的状态, 等待客户端再次回复
第三次握手
client(客户端)收到server(服务器)的SYN(同步序列编号)&#43;ACK(确认字符)包, 会再次向server(服务器)发送一个ACK(确认字符) = k&#43;1确认包, 此包发送完毕，客户端会进入ESTABLISHED（TCP连接成功）状态." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f7ae8867b146dd07cc5f1bb719dfaaa9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-28T06:27:33+08:00" />
<meta property="article:modified_time" content="2018-12-28T06:27:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网络-TCP</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <h4 class="heading">TCP介绍</h4> 
 <p><strong>TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP</strong>是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。</p> 
 <p>TCP通信需要经过创建连接、数据传送、终止连接三个步骤。</p> 
 <p>TCP通信模型中，在通信开始之前，一定要先建立相关的连接，才能发送数据，类似于生活中，"打电话".</p> 
 <h4 class="heading">TCP特点</h4> 
 <h5 class="heading">1. 面向连接</h5> 
 <p>通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。</p> 
 <p>双方间的数据传输都可以通过这一个连接进行。</p> 
 <p>完成数据交换后，双方必须断开此连接，以释放系统资源。</p> 
 <p>这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。</p> 
 <h5 class="heading">2. 可靠传输</h5> 
 <ol><li>TCP采用发送应答机制</li></ol> 
 <blockquote> 
  <p>TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功</p> 
 </blockquote> 
 <ol start="2"><li>超时重传</li></ol> 
 <blockquote> 
  <p>发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。</p> 
 </blockquote> 
 <blockquote> 
  <p>TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。</p> 
 </blockquote> 
 <ol start="3"><li>错误校验</li></ol> 
 <blockquote> 
  <p>TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p> 
 </blockquote> 
 <ol start="4"><li>流量控制和阻塞管理</li></ol> 
 <blockquote> 
  <p>流量控制用来避免主机发送得过快而使接收方来不及完全收下。</p> 
 </blockquote> 
 <h5 class="heading">TCP与UDP的不通点</h5> 
 <ul><li>面向连接（确认有创建三方交握，连接已创建才作传输。）</li><li>有序数据传输</li><li>重发丢失的数据包</li><li>舍弃重复的数据包</li><li>无差错的数据传输</li><li>阻塞/流量控制</li></ul> 
 <h5 class="heading">UDP通信模型</h5> 
 <p>udp通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，"写信"</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h5 class="heading">TCP通信模型</h5> 
 <p>udp通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，"打电话"</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h4 class="heading">TCP注意点</h4> 
 <ul><li>tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器</li><li>tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机</li><li>tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的</li><li>当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信</li><li>当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务</li><li>listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的</li><li>关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。</li><li>关闭accept返回的套接字意味着这个客户端已经服务完毕</li><li>当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线</li></ul> 
 <h4 class="heading">UDP/TCP流程</h4> 
 <table><thead><tr><th style="text-align:center;">UDP流程</th><th style="text-align:center;">TCP客户端流程</th><th style="text-align:center;">TCP服务器</th></tr></thead><tbody><tr><td style="text-align:center;">socket</td><td style="text-align:center;">socket</td><td style="text-align:center;">socket</td></tr><tr><td style="text-align:center;">bind</td><td style="text-align:center;">bind</td><td style="text-align:center;">bind</td></tr><tr><td style="text-align:center;">send/recv</td><td style="text-align:center;">connect</td><td style="text-align:center;">listen</td></tr><tr><td style="text-align:center;">close</td><td style="text-align:center;">close</td><td style="text-align:center;">accept</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">send/recv</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">close</td></tr></tbody></table> 
 <h4 class="heading">TCP三次握手</h4> 
 <p>在UDP中, 一大特点是我们发的数据,接收端有没有收到我们并不知</p> 
 <p>而TCP的特点, 操作系统的底层会相互打交道告诉对方消息收到了</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>更详细的过程请看<a href="https://link.juejin.im?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E4%25B8%2589%25E6%25AC%25A1%25E6%258F%25A1%25E6%2589%258B%2F5111559%235" rel="nofollow">百度百科三次握手</a></p> 
 <table><thead><tr><th style="text-align:center;">缩写</th><th style="text-align:center;">全称</th><th style="text-align:center;">翻译</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">SYN</td><td style="text-align:center;">Synchronize Sequence Numbers</td><td style="text-align:center;">同步序列编号</td><td style="text-align:center;">TCP连接的第一个包，非常小的一种数据包。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息。</td></tr><tr><td style="text-align:center;">ACK</td><td style="text-align:center;">Acknowledgement</td><td style="text-align:center;">确认字符</td><td style="text-align:center;">在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。</td></tr><tr><td style="text-align:center;">SYN_SENT</td><td style="text-align:center;">Transmission Control Protocol, TCP</td><td style="text-align:center;">传输控制协议</td><td style="text-align:center;">SYN_SENT表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为ESTABLISHED，此时SYN_SENT状态非常短暂。</td></tr><tr><td style="text-align:center;">SYN_RECV</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">SYN_RECV是指,服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。</td></tr><tr><td style="text-align:center;">ESTABLISHED</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">含义TCP:连接成功，establish的过去式</td></tr></tbody></table> 
 <p>至于为什么是三次握手, 知乎上也有很多人解答<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F24853633%3Fsort%3Dcreated" rel="nofollow">TCP 为什么是三次握手，而不是两次或四次？</a></p> 
 <p>简单梳理一下流程</p> 
 <p><strong>第一次握手</strong></p> 
 <p><code>client(客户端)</code>向<code>server(服务器)</code>发送一个<code>SYN(同步序列编号) = j</code>的包, 同时进入<code>SYN_SENT</code>状态, 等待服务器回复</p> 
 <p><strong>第二次握手</strong></p> 
 <p><code>server(服务器)</code>收到<code>client(客户端)</code>的<code>SYN(同步序列编号)</code>包, 会进行确认得到<code>ACK = j+1</code>.与此同时自己也会发送一个<code>(SYN(同步序列编号) = k)</code>+<code>ACK(确认字符)</code>的包给<code>client(客户端)</code>, 此时服务器进入<code>SYN_RECV</code>的状态, 等待客户端再次回复</p> 
 <p><strong>第三次握手</strong></p> 
 <p><code>client(客户端)</code>收到<code>server(服务器)</code>的<code>SYN(同步序列编号)</code>+<code>ACK(确认字符)</code>包, 会再次向<code>server(服务器)</code>发送一个<code>ACK(确认字符) = k+1</code>确认包, 此包发送完毕，客户端会进入<code>ESTABLISHED（TCP连接成功）</code>状态. 如果服务器有收到这个<code>ACK(确认字符)</code>, 服务器也进入<code>ESTABLISHED（TCP连接成功）</code>. 此时三次握手完毕.</p> 
 <p>图解如下</p> 
</div> 
<p>转载于:https://juejin.im/post/5c247b0af265da611c2707a0</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9046d3f2e704241e40754d2c72dcdda2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C# byte[]数组和string的互相转化 (四种方法)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74ea0ecc6a2ecf4fe45dcaafce8fc8d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">给服务器开启手机热点的网络配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>