<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UVa #1380 A Scheduling Problem (例题9-26) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UVa #1380 A Scheduling Problem (例题9-26)" />
<meta property="og:description" content="居然一次就过了。。做了两天，泪流满面啊。不过代码跑得很慢。。有机会优化一下
这道题想清楚了还是很简单的，但是一开始的思路不容易理顺。下面文中我的f和g与Rujia书中的定义相反，请注意区分。
题目里说，把所有的无向边去掉之后，最终答案则一定是由剩下的有向边组成的最长路径长度k或者k&#43;1。
所以我们的工作就变成了：给无向边分配方向，使得最后得到的树里，最长路径长度不大于k。若可以做到则答案为k，否则答案为k&#43;1
对于树中某一个以结点a为根的子树来说（即不考虑a的祖先），经过a的最长有向路经s等于下行最长路&#43;上行最长路。我们设这两条路的长度分别为f和g，则经过a的最长路经s的结点数为f&#43;g&#43;1。
转化无向边的过程分为两种情况：
a. 如果一个子树中不存在无向边，则经过子树的根结点的最长有向路结点数为f&#43;g&#43;1（recall that f是下行的最长路长度，g是上行的最长路长度）。
b. 如果一个结点a的子结点存在无向边，则我们先递归求出所有a的子结点的f和g，然后暴力枚举将所有无向边转化为上行/下行有向边，对于每一种枚举，按照上面不存在无向边时的方法，求出f, g和f&#43;g&#43;1，检查是否大于k。枚举的过程中，记下所有成功的枚举中最小的f和g，把它们和原本就是有向边子结点的最小的f和g比较，取较大值。（f和g本身是最长路的长度，这里要取的是不同成功的枚举情况下，遇到的最小的f和g。概念有点绕，可能要多考虑一下）
但是如果我们完全枚举无向边的转换方法，则复杂度为O(2^n)，n为子结点中无向边的数量。这里有一个非常棒的优化：
求出所有子结点的f和g之后，把无向边的f和g值存到一个数组中，按照f值排序。
之后我们从第一位开始考虑，将无向边换为下行有向边，考虑到第p位的时候，我们可以将前p-1位的无向边一并换为下行有向边。因为第p位的f值大于前p-1位无向边的f值，将前p-1位同时换为下行有向边，整个树的f值不会变（f为最长路的长度，而排序后，前p-1位形成的路都不会比第p位长），而g值有可能变小。这时，我们找出第p&#43;1位到第n位中最大的g值，求出f&#43;g&#43;1，检查是否小于等于k即可。一旦有某一个p满足了要求就可以得出结果并终止枚举。复杂度为线性。
求g的过程相同，按照g值排序、枚举即可。
需要注意的细节包括
1、容易混淆边的长度和边上结点的数量
2、f、g值在计算的时候什么时候要&#43;1，什么时候不应该&#43;1，要仔细考虑
3、dir数组的大小问题
4、枚举的边界值 - 全部换成下行/上行的情况
Run Time: 0.022s
#define UVa &#34;LT9-26.1380.cpp&#34;	//A Scheduling Problem char fileIn[30] = UVa, fileOut[30] = UVa; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;iostream&gt; using namespace std; //Global Variables. Reset upon Each Case! typedef pair&lt;int,int&gt; Pair; const int maxn = 200 &#43; 5, DOWN = 0, UP = 1, UND = 2, INF = 1&lt;&lt;30; int dir[150]; vector&lt;int&gt; G[maxn]; vector&lt;int&gt; Gdir[maxn]; int f[maxn], g[maxn]; int n, x, k; int vis[maxn], len[maxn][2], lenvis[maxn][2]; / int dfs(int u, int direction); void readSon(int fa); void readG(int u); void clearG(); void dp(int u, int&amp; ans_f, int&amp; ans_g) { if(vis[u]) { ans_f = f[u]; ans_g = g[u]; return; } vis[u] = 1; f[u] = g[u] = INF; if(G[u]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/697fbbee724511e605c5304cdd43f97c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-03-20T15:58:00+08:00" />
<meta property="article:modified_time" content="2015-03-20T15:58:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UVa #1380 A Scheduling Problem (例题9-26)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>居然一次就过了。。做了两天，泪流满面啊。不过代码跑得很慢。。有机会优化一下</p> 
<p><br> </p> 
<p>这道题想清楚了还是很简单的，但是一开始的思路不容易理顺。下面文中我的f和g与Rujia书中的定义相反，请注意区分。</p> 
<p><br> </p> 
<p>题目里说，把所有的无向边去掉之后，最终答案则一定是由剩下的有向边组成的最长路径长度k或者k+1。</p> 
<p><br> </p> 
<p>所以我们的工作就变成了：给无向边分配方向，使得最后得到的树里，最长路径长度不大于k。若可以做到则答案为k，否则答案为k+1</p> 
<p><br> </p> 
<p>对于树中某一个以结点a为根的子树来说（即不考虑a的祖先），经过a的最长有向路经s等于下行最长路+上行最长路。我们设这两条路的长度分别为f和g，则经过a的最长路经s的结点数为f+g+1。</p> 
<p><br> </p> 
<p>转化无向边的过程分为两种情况：</p> 
<p>a. 如果一个子树中不存在无向边，则经过子树的根结点的最长有向路结点数为f+g+1（recall that f是下行的最长路长度，g是上行的最长路长度）。</p> 
<p>b. 如果一个结点a的子结点存在无向边，则我们先递归求出所有a的子结点的f和g，然后暴力枚举将所有无向边转化为上行/下行有向边，对于每一种枚举，按照上面不存在无向边时的方法，求出f,  g和f+g+1，检查是否大于k。枚举的过程中，记下所有成功的枚举中最小的f和g，把它们和原本就是有向边子结点的最小的f和g比较，取较大值。（f和g本身是最长路的长度，这里要取的是不同成功的枚举情况下，遇到的最小的f和g。概念有点绕，可能要多考虑一下）</p> 
<p><br> </p> 
<p>但是如果我们完全枚举无向边的转换方法，则复杂度为O(2^n)，n为子结点中无向边的数量。这里有一个非常棒的优化：</p> 
<p>求出所有子结点的f和g之后，把无向边的f和g值存到一个数组中，按照f值排序。</p> 
<p>之后我们从第一位开始考虑，将无向边换为下行有向边，考虑到第p位的时候，我们可以将前p-1位的无向边一并换为下行有向边。因为第p位的f值大于前p-1位无向边的f值，将前p-1位同时换为下行有向边，整个树的f值不会变（f为最长路的长度，而排序后，前p-1位形成的路都不会比第p位长），而g值有可能变小。这时，我们找出第p+1位到第n位中最大的g值，求出f+g+1，检查是否小于等于k即可。一旦有某一个p满足了要求就可以得出结果并终止枚举。复杂度为线性。</p> 
<p>求g的过程相同，按照g值排序、枚举即可。</p> 
<p><br> </p> 
<p>需要注意的细节包括</p> 
<p>1、容易混淆边的长度和边上结点的数量</p> 
<p>2、f、g值在计算的时候什么时候要+1，什么时候不应该+1，要仔细考虑</p> 
<p>3、dir数组的大小问题</p> 
<p>4、枚举的边界值 - 全部换成下行/上行的情况</p> 
<p><br> </p> 
<p><br> </p> 
<p>Run Time: 0.022s</p> 
<p></p> 
<pre><code class="language-cpp">#define UVa  "LT9-26.1380.cpp"		//A Scheduling Problem
char fileIn[30] = UVa, fileOut[30] = UVa;

#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;

using namespace std;

//Global Variables. Reset upon Each Case!
typedef pair&lt;int,int&gt; Pair;
const int maxn = 200 + 5, DOWN = 0, UP = 1, UND = 2, INF = 1&lt;&lt;30;
int dir[150];
vector&lt;int&gt; G[maxn];
vector&lt;int&gt; Gdir[maxn];
int f[maxn], g[maxn];
int n, x, k;
int vis[maxn], len[maxn][2], lenvis[maxn][2];
/

int dfs(int u, int direction);
void readSon(int fa);
void readG(int u);
void clearG();

void dp(int u, int&amp; ans_f, int&amp; ans_g) {
    if(vis[u]) {
        ans_f = f[u];
        ans_g = g[u];
        return;
    }
    vis[u] = 1;
    f[u] = g[u] = INF;
    if(G[u].size() == 0) {              //leaf node
        ans_f = ans_g = f[u] = g[u] = 0;
        return;
    }

    int f_prime = 0, g_prime = 0, f_w, g_w;
    vector&lt;Pair&gt; und_f, und_g;
    for(int i = 0; i &lt; G[u].size(); i ++) {
        dp(G[u][i], f_w, g_w);
        if(Gdir[u][i] == UND) {
            und_f.push_back(Pair(f_w, g_w));
            und_g.push_back(Pair(g_w, f_w));
        }
        else if(Gdir[u][i] == DOWN)
            f_prime = max(f_prime, f_w+1);
        else if(Gdir[u][i] == UP)
            g_prime = max(g_prime, g_w+1);
    }
    //f_prime and g_prime is len of longest directed path of sons.
    //und_f and und_g is the array of undirected path.
    if(und_f.size() == 0) {
        if(f_prime + g_prime +1 &lt;= k)           //all the '+1' in this kind of inequation is for current node.
            ans_f = f[u] = f_prime, ans_g = g[u] = g_prime;
        else
            ans_f = ans_g = f[u] = g[u] = INF;
        return;
    }

    sort(und_f.begin(), und_f.end());
    sort(und_g.begin(), und_g.end());

    int max_und_f[maxn], max_und_g[maxn];
    max_und_f[und_g.size()-1] = und_g[und_g.size() - 1].second;
    max_und_g[und_f.size()-1] = und_f[und_f.size() - 1].second;
    for(int i = und_f.size() - 2; i &gt;= 0; i --) {
        max_und_f[i] = max(max_und_f[i+1], und_g[i].second);
        max_und_g[i] = max(max_und_g[i+1], und_f[i].second);
    }
    max_und_g[und_f.size()] = max_und_f[und_g.size()] = -1;
    //max_und_g/f is the longest path up/down in element i - n.

    if(f_prime + max(max_und_g[0]+1, g_prime) + 1 &lt;= k) {       //turn all und into up
        f[u] = f_prime;
    }
    else
        for(int p = 0; p &lt; und_f.size(); p ++) {
        if(max(und_f[p].first+1, f_prime) + max(max_und_g[p+1]+1, g_prime) + 1 &lt;= k) {
            f[u] = max(und_f[p].first+1, f_prime);
            break;
        }
    }

    if(max(max_und_f[0]+1, f_prime) + g_prime +1 &lt;= k) {     //turn all und into down
        g[u] = g_prime;
    }
    else
        for(int p = 0; p &lt; und_g.size(); p ++) {
        if(max(max_und_f[p+1]+1, f_prime) + max(und_g[p].first+1, g_prime) + 1 &lt;= k) {
            g[u] = max(und_g[p].first+1, g_prime);
            break;
        }
    }
    ans_f = f[u];
    ans_g = g[u];
}


int main() {
    int u;
    dir['d'] = DOWN, dir['u'] = UP, dir[' '] = UND;

    clearG();
    while(scanf("%d", &amp;u) &amp;&amp; u) {
        readG(u);

        //k is the # of vertices of the longest monotonically directed path in the tree.
        //the answer shuold be k or k+1.

        memset(lenvis, 0, sizeof(lenvis));
        memset(len, 0, sizeof(len));
        k = 0;
        for(int i = 1; i &lt;= n; i ++) {
            k = max(k, dfs(i, UP)+dfs(i, DOWN)+1);
        }

        memset(f, -1, sizeof(f));
        memset(g, -1, sizeof(g));
        memset(vis, 0, sizeof(vis));
        int f_root, g_root;
        dp(1, f_root, g_root);
        if(f_root == INF || g_root == INF) k++;
        printf("%d\n", k);
        clearG();

    }

    return 0;
}


int dfs(int u, int direction) {     //calculate the value of k
    if(lenvis[u][direction]) return len[u][direction];
    lenvis[u][direction] = 1;
    len[u][direction] = 0;
    for(int i = 0; i &lt; G[u].size(); i ++) {
        if(Gdir[u][i] == direction){
            len[u][direction] = max(len[u][direction], dfs(G[u][i], direction) + 1);
        }
    }
    return len[u][direction];
}


void readSon(int fa) {
    int son; char c;
    while( scanf("%d%c", &amp;son, &amp;c) &amp;&amp; son ) {
        G[fa].push_back(son);
        Gdir[fa].push_back(dir[c]);
    }
}

void readG(int u) {
    readSon(u);
    n = 1;
    while(scanf("%d", &amp;u) &amp;&amp; u &amp;&amp; n++) readSon(u);
}

void clearG() {
    for(int i = 1; i &lt; maxn; i ++) {
        G[i].clear();
        Gdir[i].clear();
    }
}
</code></pre> 
<br> 
<p></p> 
<p></p> 
<p><br> </p> 
<div style="top:169px">
  ﻿﻿ 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b3664c34d8c611ada919d27f2da9e136/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">树莓派CPU、内存及硬盘使用情况查看</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e28fa510bb5cd6a967b657ed5cc64f2b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JNI中方法签名</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>