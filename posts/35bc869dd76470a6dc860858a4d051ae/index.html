<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>服务端控件 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="服务端控件" />
<meta property="og:description" content="服务端控件
ClientID 我们以后在客户端操作服务端控件的时候，不要用ID,而是最好是使用ClinetID。因为服务端控件的ID不一定等于“服务端控件渲染到客户端后生成的HTML中的ID”
比如说在ListView等控件的模板中。因此如果在客户端通过JavaScript，Dom,Jquery的documnet.getElementById(&#34;id&#34;) ,或者$(&#34;#id&#34;)来操作控件的话最好不要直接
写服务端控件的ID,而是通过 $(&#34;#&lt;%=Button1.ClientID%&gt;&#34;)这种形式来操作。
用jquery时间设置鼠标移动到控件上和控件移开的不同样式，在用户控件中就可以看到ClientID和Id的不同。 UserControl,母版，ListView，推荐永远用ClientID
例如：
&lt;%@ Page Language=&#34;C#&#34; AutoEventWireup=&#34;true&#34; CodeBehind=&#34;WebForm3.aspx.cs&#34; Inherits=&#34;WebApp.WebForm3&#34; %&gt; &lt;!DOCTYPE html&gt; &lt;html xmlns=&#34;http://www.w3.org/1999/xhtml&#34;&gt; &lt;head runat=&#34;server&#34;&gt; &lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&#34;form1&#34; runat=&#34;server&#34;&gt; &lt;div&gt; &lt;%--获取由ASP.NET生成的HTML标记的控件ID 这里虽然也是输出Button1--%&gt; &lt;%=this.Button1.ClientID %&gt; &lt;/div&gt; &lt;asp:Button ID=&#34;Button1&#34; runat=&#34;server&#34; Text=&#34;Button&#34; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; Visible属性 表示控件是否可见，如果Visible=False那么在在渲染的时候就会忽略掉这个控件，也就是说这个控件不会生成HTML代码。也就表明根本不存在这个控件，既然控件都不存在，也就不会占用区域。
怎么给服务器端控件设置Class样式？ using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.UI; using System.Web.UI.WebControls; namespace WebApp { public partial class WebForm3 : System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/35bc869dd76470a6dc860858a4d051ae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-09-18T22:02:16+08:00" />
<meta property="article:modified_time" content="2015-09-18T22:02:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">服务端控件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>服务端控件</p> 
<h2>ClientID</h2> 
<p>我们以后在客户端操作服务端控件的时候，不要用ID,而是最好是使用ClinetID。因为服务端控件的ID不一定等于“服务端控件渲染到客户端后生成的HTML中的ID”</p> 
<p>比如说在ListView等控件的模板中。因此如果在客户端通过JavaScript，Dom,Jquery的documnet.getElementById("id") ,或者$("#id")来操作控件的话最好不要直接</p> 
<p>写服务端控件的ID,而是通过 $("#&lt;%=Button1.ClientID%&gt;")这种形式来操作。</p> 
<p>用jquery时间设置鼠标移动到控件上和控件移开的不同样式，在用户控件中就可以看到ClientID和Id的不同。 UserControl,母版，ListView，推荐永远用ClientID</p> 
<p>例如：</p> 
<p></p> 
<pre><code class="language-html">&lt;%@ Page Language="C#" AutoEventWireup="true" CodeBehind="WebForm3.aspx.cs" Inherits="WebApp.WebForm3" %&gt;

&lt;!DOCTYPE html&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head runat="server"&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id="form1" runat="server"&gt;
        &lt;div&gt;
            &lt;%--获取由ASP.NET生成的HTML标记的控件ID    这里虽然也是输出Button1--%&gt;
            &lt;%=this.Button1.ClientID %&gt;
        &lt;/div&gt;
        &lt;asp:Button ID="Button1" runat="server" Text="Button" /&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p></p> 
<p><br> </p> 
<h2>Visible属性</h2> 
<p><span style="color:rgb(85,85,85); font-family:'microsoft yahei'; font-size:15px; line-height:35px">表示控件是否可见，如果Visible=False那么在在渲染的时候就会忽略掉这个控件，也就是说这个控件不会生成HTML代码。也就表明根本不存在这个控件，既然控件都不存在，也就不会占用区域。</span><br> <br> </p> 
<h2>怎么给服务器端控件设置Class样式？</h2> 
<p></p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace WebApp
{
    public partial class WebForm3 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            //给服务端控件Button1这个控件设置一个Class样式
            //这样在客户端生成的HTML就是：
            //&lt;input type="submit" name="Button1" value="Button" id="Button1" class="MyClass" /&gt;
            this.Button1.CssClass = "MyClass";
        }
   </code></pre> 
<br> 或者在WebForma.aspx源代码中设置：添加一个CssClass属性"  
<p></p> 
<p></p> 
<pre><code class="language-html"> &lt;asp:Button ID="Button1" runat="server" Text="Button"  CssClass="MyClass"/&gt;</code></pre>这样经过渲染的时候也会生成一下这段代码： 
<p></p> 
<p></p> 
<pre><code class="language-html">&lt;input type="submit" name="Button1" value="Button" id="Button1" class="MyClass" /&gt;</code></pre> 
<br> 
<p></p> 
<h2>给服务控件设置一些额外的属性：Attributes</h2> 
<p></p> 
<p>比如：控件本身没有UserName这个，但是在某些操作的时候，我就是想用一个UserName属性，比如在用jquery操作的时候。</p> 
<p>那怎么给控件加一个额外的属性呢?</p> 
<p></p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace WebApp
{
    public partial class WebForm3 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            //给Button1这个控件添加一个额外的属性UserName，并将这个属性设置一个值，这里指定值为“张三”

            //这样Button1这个控件在客户端生成的Html代码为：
            //&lt;input type="submit" name="Button1" value="Button" id="Button1" UserName="张三" /&gt;
            this.Button1.Attributes.Add("UserName", "张三");
        }
    }
}</code></pre> 
<br> 利用可以给服务端控件添加一个额外属性这一点，我们好可以更好的利用这一点： 
<p></p> 
<p></p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace WebApp
{
    public partial class WebForm3 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            //给Button1这个控件添加一个额外的属性UserName，并将这个属性设置一个值，这里指定值为“张三”

            //这样Button1这个控件在客户端生成的Html代码为：
            //&lt;input type="submit" name="Button1" value="Button" id="Button1" UserName="张三" /&gt;

            //这样等于给Button这个控件添加了一个onMouseOver事件了。
            this.Button1.Attributes.Add("onMouseOver", "alert('你好！')");

            //也可以换一种写法：这种写法相当于也是给控件添加了一个事件
            this.Button1.Attributes["onmouseleave"] = "this.style.backgroundColor='red'";

        }
    }
}</code></pre> 
<br> 
<h2>TextBox 控件</h2> 
<p></p> 
<p>TextBox控件，有一个自动提交属性AutoPostBack</p> 
<p>只要将这个属性的值设为true，那么当这个控件失去焦点时候会立刻出发一个onchange事件，在这个事件里会其实就是执行了一个名字叫__doPostBack的函数，并在这个函数里提交了表单。</p> 
<p>下面我们可以看看当将一个TextBox控件的AutoPostBack属性设为True的时候，服务端为我们在客户端生成了什么代码？ </p> 
<p></p> 
<pre><code class="language-html">&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;

&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;form method="post" action="WebForm4.aspx" id="form1"&gt;
&lt;div class="aspNetHidden"&gt;
&lt;input type="hidden" name="__EVENTTARGET" id="__EVENTTARGET" value="" /&gt;
&lt;input type="hidden" name="__EVENTARGUMENT" id="__EVENTARGUMENT" value="" /&gt;
&lt;input type="hidden" name="__LASTFOCUS" id="__LASTFOCUS" value="" /&gt;
&lt;input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="jDEYukuMkwLgZ/lmoQJjSHiidrhaHlkEpHU1ULbVH2ES2yd4TOtefiOc97f6WzzjCyNUU33CfdXBW0O3q+8wtyJhfkeoh023M24FK7yr7eM=" /&gt;
&lt;/div&gt;

&lt;!--这都是将一个TextBox控件的AutoPostBack属性设为True的时候服务自动我们生成的一段js代码--&gt;
&lt;script type="text/javascript"&gt;
//&lt;![CDATA[
var theForm = document.forms['form1'];
if (!theForm) {
    theForm = document.form1;
}
function __doPostBack(eventTarget, eventArgument) {
    if (!theForm.onsubmit || (theForm.onsubmit() != false)) {
        theForm.__EVENTTARGET.value = eventTarget;
        theForm.__EVENTARGUMENT.value = eventArgument;
        theForm.submit();
    }
}
//]]&gt;
&lt;/script&gt;


&lt;script src="/WebResource.axd?d=pynGkmcFUV13He1Qd6_TZNUN7LZkz3OUIcz5FRy2P7fXFY_ewwxCDhpw62pOTb2PoNFDLdb7SVnCbGvNY8r3DA2&amp;t=635586541120000000" type="text/javascript"&gt;&lt;/script&gt;

&lt;div class="aspNetHidden"&gt;

	&lt;input type="hidden" name="__VIEWSTATEGENERATOR" id="__VIEWSTATEGENERATOR" value="D51E3F29" /&gt;
	&lt;input type="hidden" name="__EVENTVALIDATION" id="__EVENTVALIDATION" value="BNUoHCx0FgLnaebhPSPBkmflIXE/4+YoMKJYoVLoyc2D7FhBHTXkaqQ4ziDvOCSOKtNc9LAnIg4216uvt4OVJJ/g+SJR6zTGBI1NBDJHz9voxPl4OgUtLlv4Cxz217kP" /&gt;
&lt;/div&gt;
    &lt;div&gt;
	&lt;!--这都是将一个TextBox控件的AutoPostBack属性设为True的时候服务自动我们生成的HTML代码，里面给我们自动添加了一个onchange事件，里面调用了__doPostBack函数--&gt;
        &lt;input name="TextBox1" type="text" οnchange="javascript:setTimeout('__doPostBack(\'TextBox1\',\'\')', 0)" οnkeypress="if (WebForm_TextBoxKeyHandler(event) == false) return false;" id="TextBox1" /&gt;
    &lt;/div&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<br> 
<h2><strong>Button控件</strong></h2> 
<p>Button控件有一个OnClientClick属性，这个属性不是给服务端设置一个点击事件，而为客户端生成一个单击事件。</p> 
<p><strong></strong></p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace WebApp
{
    public partial class WebForm4 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            //给这个按钮注册一个客户端的单击事件。这样这个按钮在客户端生成的HTML代码里，就多了一个OnClick事件
            //到时候这个Button控件会在客户端解析成：
            //&lt;input type="submit" name="Button1" value="Button" οnclick="alert(new Date().toString());" id="Button1" /&gt;
            Button1.OnClientClick = "alert(new Date().toString())";

            //Button1.OnClientClick = "return confirm('你确定要删除吗？')";
        }
    }
}</code></pre> 
<br> 
<p></p> 
<h2><strong>LinkButton控件</strong></h2> 
<p></p> 
<p>LinkButton用法和Button控件差不多，区别在于Button控件渲染成按钮。而LinkButton渲染成一个超链接的样子而已。一般情况下我们都是用Button按钮，只有用户要求将按钮变成超链接的样子的时候才采用LinkButton按钮。</p> 
<p><br> </p> 
<h2><strong>HyperLink控件</strong></h2> 
<p><strong>这个控件是一个超链接控件</strong></p> 
<p><strong></strong></p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace WebApp
{
    public partial class WebForm4 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {

           //要链接到的网站
            //this.HyperLink1.NavigateUrl = "WebForm3.aspx";

            
            this.HyperLink1.NavigateUrl = "http://www.baidu.com";
            
            this.HyperLink1.Text = "百度";
            

            //我们也可以给这个超链接加一个图片。这样点击图片的时候就链接到百度去了。
            this.HyperLink1.ImageUrl = "e.jpg";

            //渲染后生成的HTML代码是这样的：
            // &lt;a id="HyperLink1" href="http://www.baidu.com"&gt;&lt;img src="e.jpg" alt="百度" /&gt;&lt;/a&gt;
        }
    }
}</code></pre> 
<br> 
<p>ImageButton控件</p> 
<p>ImageButton控件和Button也差不多，只不过显示为图片。</p> 
<p></p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace WebApp
{
    public partial class WebForm4 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {


            this.ImageButton1.ImageUrl = "e.jpg";

            //当点击图片的时候，将表单提交到WebForm3.aspx这个页面
            this.ImageButton1.PostBackUrl = "WebForm3.aspx";
        }

    }
}</code></pre> 
<br> 
<strong>Button,LinkButton，ImageButton等控件都有CommandName,CommandArgument两个属性和Command事件，可以让多个按钮控件共享一个属性读取被点击按钮上设置的这个两个参数来指向不同的操作。例子：编辑，删除多行数据。这种用法，在ListView等控件中用的最多。</strong> 
<p></p> 
<p></p> 
<p><strong><br> </strong></p> 
<h2><strong>Panel控件</strong></h2> 
<p>Panel控件经过渲染后生成的代码其实就是一个div</p> 
<p></p> 
<pre><code class="language-html">&lt;div id="Panel1"&gt;&lt;/div&gt;</code></pre> 
<br> 但是panel控件有一个属性：GroupingText。 
<p></p> 
<p></p> 
<pre><code class="language-csharp">namespace WebApp
{
    public partial class WebForm5 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            this.Panel1.GroupingText = "国家";
          
        }
    }
}</code></pre>给GroupingText属性赋值后的Panel控件渲染出的HTML代码： 
<p></p> 
<p></p> 
<pre><code class="language-html">&lt;div id="Panel1"&gt;
	&lt;fieldset&gt;
		&lt;legend&gt;
			国家
		&lt;/legend&gt;
            中国
	&lt;/fieldset&gt;
&lt;/div&gt;</code></pre> 
<br> 
<p><img src="https://images2.imgbox.com/dd/35/1JouQ1T9_o.png" alt=""></p> 
<h2>DropDownList下拉控件</h2> 
<p></p> 
<p></p> 
<pre><code class="language-html">&lt;asp:DropDownList ID="DropDownList1" runat="server" SelectedValue="男"&gt;
                            &lt;asp:ListItem Value="男"&gt;男&lt;/asp:ListItem&gt;
                            &lt;asp:ListItem Value="女"&gt;女&lt;/asp:ListItem&gt;
                        &lt;/asp:DropDownList&gt;</code></pre> 
<br> 
<br> 
<p></p> 
<p><br> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ddf9e1358a5ebd927f39420c0a1a396d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FFmpeg与SDL双剑合璧之ubuntu</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0ce2fae5c0d4de92c496bb4418e25e06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">配置SQl Server 2008R2端口号详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>