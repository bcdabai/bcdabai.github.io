<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TypeScript进阶 之 重难点梳理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TypeScript进阶 之 重难点梳理" />
<meta property="og:description" content="点击上方“全栈前端精选“，回复“1”进交流群
加入我们一起学习，天天进步
THE LAST TIME ❝ The last time, I have learned
❞ 【THE LAST TIME】 一直是我想写的一个系列，旨在厚积薄发，重温前端。
也是给自己的查缺补漏和技术分享。
笔者文章集合详见：
GitHub 地址：Nealyang/personalBlog
公众号：「全栈前端精选」
前言 JavaScript 毋庸置疑是一门非常好的语言，但是其也有很多的弊端，其中不乏是作者设计之处留下的一些 “bug”。当然，瑕不掩瑜~
话说回来，JavaScript 毕竟是一门弱类型语言，与强类型语言相比，其最大的编程陋习就是可能会造成我们类型思维的缺失（高级词汇，我从极客时间学到的）。而「思维方式决定了编程习惯，编程习惯奠定了工程质量，工程质量划定了能力边界」，而学习 Typescript，最重要的就是我们类型思维的重塑。
那么其实，Typescript 在我个人理解，并不能算是一个编程语言，它只是 JavaScript 的一层壳。当然，我们完全可以将它作为一门语言去学习。网上有很多推荐 or 不推荐 Typescript 之类的文章这里我们不做任何讨论，学与不学，用或不用，利与弊。各自拿捏~
再说说 typescript（下文均用 ts 简称），其实对于 ts 相比大家已经不陌生了。更多关于 ts 入门文章和文档也是已经烂大街了。「此文不去翻译或者搬运各种 api或者教程章节。只是总结罗列和解惑，笔者在学习 ts 过程中曾疑惑的地方」。道不到的地方，欢迎大家评论区积极讨论。
其实 Ts 的入门非常的简单:.js to .ts; over!
「但是为什么我都会写 ts 了，却看不懂别人的代码呢？」 这！就是入门与进阶之隔。也是本文的目的所在。
首先推荐下 ts 的编译环境：typescriptlang.org
再推荐笔者收藏的几个网站：
Typescript 中文网
深入理解 Typescript
TypeScript Handbook
TypeScript 精通指南" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5aee5f6d58e7ae6271ed1e6a6daf2cfd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-23T12:50:00+08:00" />
<meta property="article:modified_time" content="2020-03-23T12:50:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TypeScript进阶 之 重难点梳理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align: center">点击上方“全栈前端精选“，回复“1”进交流群<br></p> 
 <p style="text-align: center">加入我们一起学习，天天进步</p> 
 <h3>THE LAST TIME</h3> 
 <blockquote> 
  ❝ 
  <p>The last time, I have learned</p> 
  ❞ 
 </blockquote> 
 <p>【THE LAST TIME】 一直是我想写的一个系列，旨在厚积薄发，重温前端。</p> 
 <p>也是给自己的查缺补漏和技术分享。</p> 
 <p>笔者文章集合详见：</p> 
 <ul><li><p>GitHub 地址：Nealyang/personalBlog</p></li><li><p>公众号：<strong>「全栈前端精选」</strong></p></li></ul> 
 <h3>前言</h3> 
 <p><code>JavaScript</code> 毋庸置疑是一门非常好的语言，但是其也有很多的弊端，其中不乏是作者设计之处留下的一些 “bug”。当然，瑕不掩瑜~</p> 
 <p>话说回来，<code>JavaScript</code> 毕竟是一门弱类型语言，与强类型语言相比，其最大的编程陋习就是可能会造成我们类型思维的缺失（高级词汇，我从极客时间学到的）。而<strong>「思维方式决定了编程习惯，编程习惯奠定了工程质量，工程质量划定了能力边界」</strong>，而学习 Typescript，最重要的就是我们类型思维的重塑。</p> 
 <p>那么其实，<code>Typescript</code> 在我个人理解，并不能算是一个编程语言，它只是 <code>JavaScript</code> 的一层壳。当然，我们完全可以将它作为一门语言去学习。网上有很多推荐 or 不推荐 Typescript 之类的文章这里我们不做任何讨论，学与不学，用或不用，利与弊。各自拿捏~</p> 
 <p>再说说 typescript（下文均用 ts 简称），其实对于 ts 相比大家已经不陌生了。更多关于 ts 入门文章和文档也是已经烂大街了。<strong>「此文不去翻译或者搬运各种 api或者教程章节。只是总结罗列和解惑，笔者在学习 ts 过程中曾疑惑的地方」</strong>。道不到的地方，欢迎大家评论区积极讨论。</p> 
 <p>其实 Ts 的入门非常的简单:<code>.js</code> to <code>.ts</code>; over!</p> 
 <img src="https://images2.imgbox.com/d0/f7/t7zJM3Xn_o.png"> 
 <p><strong>「但是为什么我都会写 ts 了，却看不懂别人的代码呢？」</strong> 这！就是入门与进阶之隔。也是本文的目的所在。</p> 
 <p>首先推荐下 ts 的编译环境：typescriptlang.org</p> 
 <p>再推荐笔者收藏的几个网站：</p> 
 <ul><li><p>Typescript 中文网</p></li><li><p>深入理解 Typescript</p></li><li><p>TypeScript Handbook</p></li><li><p>TypeScript 精通指南</p></li></ul> 
 <p>下面，逐个难点梳理，逐个击破。</p> 
 <h3>可索引类型</h3> 
 <p>关于ts 的类型应该不用过多介绍了，<strong>「多用多记」</strong> 即可。介绍下关于 ts 的可索引类型。准确的说，这应该属于接口的一类范畴。说到接口（interface），我们都知道 <strong>「ts 的核心原则之一就是对值所具有的结构进行类型检查。」</strong> 它有时被称之为“鸭式辩型法”或“结构性子类型”。而接口就是其中的契约。可索引类型也是接口的一种表现形式，非常实用！</p> 
 <pre class="has"><code class="language-go">interface StringArray {
  [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];
</code></pre> 
 <p>上面例子里，我们定义了<code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用<code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。 Typescript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p> 
 <p>这是因为当使用<code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。 也就是说用100（一个number）去索引等同于使用"100"（一个string）去索引，因此两者需要保持一致。</p> 
 <pre class="has"><code class="language-go">class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
</code></pre> 
 <p>下面的例子里，name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p> 
 <pre class="has"><code class="language-go">interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}
</code></pre> 
 <p>当然，我们也可以将索引签名设置为只读，这样就可以防止给索引赋值</p> 
 <pre class="has"><code class="language-go">interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error!
</code></pre> 
 <h3>interface  和 type 关键字</h3> 
 <p>stackoverflow 上的一个高赞回答还是非常赞的。typescript-interfaces-vs-types</p> 
 <p><code>interface</code> 和 <code>type</code> 两个关键字的含义和功能都非常的接近。这里我们罗列下这两个主要的区别：</p> 
 <p><code>interface</code>：</p> 
 <ul><li><p>同名的 <code>interface</code> 自动聚合，也可以跟同名的 <code>class</code> 自动聚合</p></li><li><p>只能表示 <code>object</code>、<code>class</code>、<code>function</code> 类型</p></li></ul> 
 <p><code>type</code>:</p> 
 <ul><li><p>不仅仅能够表示 <code>object</code>、<code>class</code>、<code>function</code></p></li><li><p>不能重名（自然不存在同名聚合了），扩展已有的 <code>type</code> 需要创建新 <code>type</code></p></li><li><p>支持复杂的类型操作</p></li></ul> 
 <p>举例说明下上面罗列的几点：</p> 
 <h4>Objects/Functions</h4> 
 <p>都可以用来表示 <code>Object</code> 或者 <code>Function</code> ，只是语法上有些不同而已</p> 
 <pre class="has"><code class="language-go">interface Point{
  x:number;
  y:number;
}

interface SetPoint{
  (x:number,y:number):void;
}
</code></pre> 
 <pre class="has"><code class="language-go">type Point = {
  x:number;
  y:number;
}

type SetPoint = (x:number,y:number) =&gt; void;
</code></pre> 
 <h4>其他数据类型</h4> 
 <p>与 <code>interface</code> 不同，<code>type</code> 还可以用来标书其他的类型，比如基本数据类型、元素、并集等</p> 
 <pre class="has"><code class="language-go">type Name = string;

type PartialPointX = {x:number;};
type PartialPointY = {y:number;};

type PartialPoint = PartialPointX | PartialPointY;

type Data = [number,string,boolean];
</code></pre> 
 <h4>Extend</h4> 
 <p>都可以被继承，但是语法上会有些不同。另外需要注意的是，<strong>「interface 和 type 彼此并不互斥」</strong>。</p> 
 <h5>interface extends interface</h5> 
 <pre class="has"><code class="language-go">interface PartialPointX {x:number;};
interface Point extends PartialPointX {y:number;};
</code></pre> 
 <h5>type extends type</h5> 
 <pre class="has"><code class="language-go">type PartialPointX = {x:number;};
type Point = PartialPointX &amp; {y:number;};
</code></pre> 
 <h5>interface extends type</h5> 
 <pre class="has"><code class="language-go">type PartialPointX = {x:number;};
interface Point extends PartialPointX {y:number;};
</code></pre> 
 <h5>type extends interface</h5> 
 <pre class="has"><code class="language-go">interface ParticalPointX = {x:number;};

type Point = ParticalPointX &amp; {y:number};
</code></pre> 
 <h4>implements</h4> 
 <p>一个类，可以以完全相同的形式去实现<code>interface</code> 或者 <code>type</code>。但是，类和接口都被视为静态蓝图（static blueprints），因此，他们不能实现/继承 联合类型的 <code>type</code></p> 
 <pre class="has"><code class="language-go">interface Point {
  x: number;
  y: number;
}

class SomePoint implements Point {
  x: 1;
  y: 2;
}

type Point2 = {
  x: number;
  y: number;
};

class SomePoint2 implements Point2 {
  x: 1;
  y: 2;
}

type PartialPoint = { x: number; } | { y: number; };

// FIXME: can not implement a union type
class SomePartialPoint implements PartialPoint {
  x: 1;
  y: 2;
}
</code></pre> 
 <img src="https://images2.imgbox.com/58/6d/YKAbZCaz_o.png"> 
 <h4>声明合并</h4> 
 <p>和 <code>type</code> 不同，<code>interface</code> 可以被重复定义，并且会被自动聚合</p> 
 <pre class="has"><code class="language-go">interface Point {x:number;};
interface Point {y:number;};

const point:Pint = {x:1,y:2};
</code></pre> 
 <h4>only interface can</h4> 
 <p>在实际开发中，有的时候也会遇到 <code>interface</code> 能够表达，但是 <code>type</code> 做不到的情况：<strong>「给函数挂载属性」</strong></p> 
 <pre class="has"><code class="language-go">interface FuncWithAttachment {
  (param: string): boolean;
  someProperty: number;
}

const testFunc: FuncWithAttachment = function(param: string) {
  return param.indexOf("Neal") &gt; -1;
};
const result = testFunc("Nealyang"); // 有类型提醒
testFunc.someProperty = 4;
</code></pre> 
 <img src="https://images2.imgbox.com/20/3c/fFqb64JD_o.png"> 
 <h3>&amp; 和 | 操作符</h3> 
 <p>这里我们需要区分，<code>|</code> 和 <code>&amp;</code> 并非位运算符。我们可以理解为<code>&amp;</code>表示必须同时满足所有的契约。<code>|</code>表示可以只满足一个契约。</p> 
 <pre class="has"><code class="language-go">interface IA{
  a:string;
  b:string;
}

type TB{
  b:number;
  c:number [];
}

type TC = TA | TB;// TC 的 key，包含 ab 或者 bc 即可，当然，包含 bac 也可以
type TD = TA &amp; TB;// TD 的 可以,必须包含 abc
</code></pre> 
 <h3>交叉类型</h3> 
 <p>交叉类型，我们可以理解为合并。其实就是<strong>「将多个类型合并为一个类型」</strong>。</p> 
 <pre class="has"><code class="language-go">Man &amp; WoMan
</code></pre> 
 <ul><li><p>同时是 Man 和 Woman</p></li><li><p>同时拥有 Man 和 Woman 这两种类型的成员</p></li></ul> 
 <pre class="has"><code class="language-go">interface ObjectConstructor{
  assign&lt;T,U&gt;(target:T,source:U):T &amp; U;
}
</code></pre> 
 <p>以上是 ts 的源码实现，下面我们再看一个我们日常使用中的例子</p> 
 <pre class="has"><code class="language-go">interface A{
  name:string;
  age:number;
  sayName:(name:string)=&gt;void
}

interface B{
  name:string;
  gender:string;
  sayGender:(gender:string)=&gt;void
}

let a:A&amp;B;

// 这是合法的
a.age
a.sayGender
</code></pre> 
 <p>注意：16446</p> 
 <pre class="has"><code class="language-go">T &amp; never = never 
</code></pre> 
 <h3>extends</h3> 
 <p><code>extends</code> 即为扩展、继承。在 ts 中，<strong>「extends 关键字既可以来扩展已有的类型，也可以对类型进行条件限定」</strong>。在扩展已有类型时，不可以进行类型冲突的覆盖操作。例如，基类型中键<code>a</code>为<code>string</code>，在扩展出的类型中无法将其改为<code>number</code>。</p> 
 <pre class="has"><code class="language-go">type num = {
  num:number;
}

interface IStrNum extends num {
  str:string;
}

// 与上面等价
type TStrNum = A &amp; {
  str:string;
}
</code></pre> 
 <p>在 ts 中，我们还可以通过条件类型进行一些三目操作：<code>T extends U ? X : Y</code></p> 
 <pre class="has"><code class="language-go">type IsEqualType&lt;A , B&gt; = A extends B ? (B extends A ? true : false) : false;

type NumberEqualsToString = IsEqualType&lt;number,string&gt;; // false
type NumberEqualsToNumber = IsEqualType&lt;number,number&gt;; // true
</code></pre> 
 <h3>keyof</h3> 
 <p><strong>「keyof 是索引类型操作符」</strong>。用于获取一个“常量”的类型,这里的“常量”是指任何可以在编译期确定的东西，例如<code>const</code>、<code>function</code>、<code>class</code>等。它是从 <strong>「实际运行代码」</strong> 通向 <strong>「类型系统」</strong> 的单行道。理论上，任何运行时的符号名想要为类型系统所用，都要加上 <code>typeof</code>。</p> 
 <p>在使用<code>class</code>时，<code>class</code>名表示实例类型，<code>typeof class</code>表示 <code>class</code>本身类型。是的，这个关键字和 js 的 <code>typeof</code> 关键字重名了 。</p> 
 <p>假设 T 是一个类型，那么<code>keyof T</code>产生的类型就是 <code>T</code> 的属性名称字符串字面量类型构成的联合类型(联合类型比较简单，和交叉类型对立相似，这里就不做介绍了)。</p> 
 <p><strong>「注意！上述的 T 是数据类型，并非数据本身」</strong>。</p> 
 <pre class="has"><code class="language-go">interface IQZQD{
    cnName:string;
    age:number;
    author:string;
}
type ant = keyof IQZQD;
</code></pre> 
 <p>在 <code>vscode</code> 上，我们可以看到 <code>ts</code> 推断出来的 <code>ant</code>：</p> 
 <img src="https://images2.imgbox.com/06/1c/cL9FCSgg_o.png"> 
 <p>注意，如果 <code>T</code> 是带有字符串索引的类型，那么<code>keyof T</code>是 <code>string</code>或者<code>number</code>类型。</p> 
 <p>索引签名参数类型必须为 "string" 或 "number"</p> 
 <pre class="has"><code class="language-go">interface Map&lt;T&gt; {
  [key: string]: T;
}

//T[U]是索引访问操作符;U是一个属性名称。
let keys: keyof Map&lt;number&gt;; //string | number
let value: Map&lt;number&gt;['antzone'];//number
</code></pre> 
 <h3>泛型</h3> 
 <p>泛型可能是对于前端同学来说理解起来有点困难的知识点了。通常我们说，泛型就是指定一个表示类型的变量，用它来代替某个实际的类型用于编程，而后再通过实际运行或推导的类型来对其进行替换，以达到一段使用泛型程序可以实际适应不同类型的目的。说白了，<strong>「泛型就是不预先确定的数据类型，具体的类型在使用的时候再确定的一种类型约束规范」</strong>。</p> 
 <p>泛型可以应用于 <code>function</code>、<code>interface</code>、<code>type</code> 或者 <code>class</code> 中。但是注意，<strong>「泛型不能应用于类的静态成员」</strong></p> 
 <p>几个简单的例子，先感受下泛型</p> 
 <pre class="has"><code class="language-go">function log&lt;T&gt;(value: T): T {
    console.log(value);
    return value;
}

// 两种调用方式
log&lt;string[]&gt;(['a', ',b', 'c'])
log(['a', ',b', 'c'])
log('Nealyang')
</code></pre> 
 <ul><li><p>泛型类型、泛型接口</p></li></ul> 
 <pre class="has"><code class="language-go">type Log = &lt;T&gt;(value: T) =&gt; T
let myLog: Log = log

interface Log&lt;T&gt; {
    (value: T): T
}
let myLog: Log&lt;number&gt; = log // 泛型约束了整个接口，实现的时候必须指定类型。如果不指定类型，就在定义的之后指定一个默认的类型
myLog(1)
</code></pre> 
 <p><strong>「我们也可以把泛型变量理解为函数的参数，只不过是另一个维度的参数，是代表类型而不是代表值的参数。」</strong></p> 
 <pre class="has"><code class="language-go">class Log&lt;T&gt; { // 泛型不能应用于类的静态成员
    run(value: T) {
        console.log(value)
        return value
    }
}

let log1 = new Log&lt;number&gt;() //实例化的时候可以显示的传入泛型的类型
log1.run(1)
let log2 = new Log()
log2.run({ a: 1 }) //也可以不传入类型参数，当不指定的时候，value 的值就可以是任意的值
</code></pre> 
 <p>类型约束，需预定义一个接口</p> 
 <pre class="has"><code class="language-go">interface Length {
    length: number
}
function logAdvance&lt;T extends Length&gt;(value: T): T {
    console.log(value, value.length);
    return value;
}

// 输入的参数不管是什么类型，都必须具有 length 属性
logAdvance([1])
logAdvance('123')
logAdvance({ length: 3 })
</code></pre> 
 <p>泛型的好处：</p> 
 <ul><li><p>函数和类可以轻松的支持多种类型，增强程序的扩展性</p></li><li><p>不必写多条函数重载，冗长的联合类型声明，增强代码的可读性</p></li><li><p>灵活控制类型之间的约束</p></li></ul> 
 <p>泛型，在 ts 内部也都是非常常用的，尤其是对于容器类非常常用。而对于我们，还是要多使用，多思考的，这样才会有更加深刻的体会。同时也对塑造我们类型思维非常的有帮助。</p> 
 <h4>小试牛刀</h4> 
 <pre class="has"><code class="language-go">function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] {
    return names.map(n =&gt; o[n]);
}

interface Person {
    name: string;
    age: number;
}

let person: Person = {
    name: 'Jarid',
    age: 35
};
let strings: string[] = pluck(person, ['name', 'name', 'name']); //["Jarid", "Jarid", "Jarid"]
</code></pre> 
 <p>所谓的小试牛刀，就是结合上面我们说的那几个点，分析下<code>pluck</code>方法的意思</p> 
 <ul><li><p><code>&lt;T, K extends keyof T&gt;</code>约束了这是一个泛型函数</p></li><li><ul><li><p><code>keyof T</code> 就是取 T 中的所有的常量 key（这个例子的调用中）,即为：<code>"name" | "age"</code></p></li><li><p><code>K extends keyof Person</code> 即为 K 是 <code>"name"</code> or <code>"age"</code></p></li></ul> 
  </li><li><p>结合以上泛型解释，再看形参</p></li><li><ul><li><p><code>K[]</code> 即为 只能包含<code>"name"</code> or <code>"age"</code>的数组</p></li></ul> 
  </li><li><p>再看返回值</p></li><li><ul><li><p><code>T[K][]</code> 后面的<code>[]</code>是数组的意思。而 <code>T[K]</code>就是去对象的 T 下的<code>key</code>: <code>K</code>的 <code>value</code></p></li></ul> 
 </li></ul> 
 <h3>infer</h3> 
 <p>infer 关键字最早出现在 PR 里面，<strong>「表示在 extends 条件语句中待推断的类型变量」</strong></p> 
 <p>是在 ts2.8 引入的，在条件判断语句中，该关键字用于<strong>「替换手动获取类型」</strong>。</p> 
 <pre class="has"><code class="language-go">type PramType&lt;T&gt; = T extends (param : infer p) =&gt; any ? p : T;
</code></pre> 
 <p>在上面的条件语句中，<code>infer P</code> 表示待推断的函数参数，如果<code>T</code>能赋值给<code>(param : infer p) =&gt; any</code>,则结果是<code>(param: infer P) =&gt; any</code>类型中的参数 <code>P</code>,否则为<code>T</code>.</p> 
 <pre class="has"><code class="language-go">interface INealyang{
  name:'Nealyang';
  age:'25';
}

type Func = (user:INealyang) =&gt; void;

type Param = ParamType&lt;Func&gt;; // Param = INealyang
type Test = ParamType&lt;string&gt;; // string
</code></pre> 
 <h3>工具泛型</h3> 
 <p>所谓的工具泛型，其实就是泛型的一些语法糖的实现。完全也是可以自己的写的。我们也可以在<code>lib.d.ts</code>中找到他们的定义</p> 
 <h4>Partial</h4> 
 <p><code>Partial</code>的作用就是将传入的属性变为可选。</p> 
 <p>由于 <code>keyof</code> 关键字已经介绍了。其实就是可以用来取得一个对象接口的所有 key 值。在介绍 <code>Partial</code> 之前，我们再介绍下 <code>in</code> 操作符:</p> 
 <pre class="has"><code class="language-go">type Keys = "a" | "b"
type Obj =  {
  [p in Keys]: any
} // -&gt; { a: any, b: any }
</code></pre> 
 <p>然后再看 Partial 的实现：</p> 
 <pre class="has"><code class="language-go">type Partial&lt;T&gt; = { [P in keyof T]?: T[P] };
</code></pre> 
 <p>翻译一下就是<code>keyof T</code> 拿到 <code>T</code> 所有属性名, 然后 <code>in</code> 进行遍历, 将值赋给 <code>P</code>, 最后 <code>T[P]</code> 取得相应属性的值,然后配合<code>?:</code>改为可选。</p> 
 <h4>Required</h4> 
 <p><code>Required</code> 的作用是将传入的属性变为必选项, 源码如下</p> 
 <pre class="has"><code class="language-go">type Required&lt;T&gt; = { [P in keyof T]-?: T[P] };
</code></pre> 
 <h4>Readonly</h4> 
 <p>将传入的属性变为只读选项, 源码如下</p> 
 <pre class="has"><code class="language-go">type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P] };
</code></pre> 
 <h4>Record</h4> 
 <p>该类型可以将 <code>K</code> 中所有的属性的值转化为 <code>T</code> 类型，源码实现如下：</p> 
 <pre class="has"><code class="language-go">/**
 * Construct a type with a set of properties K of type T
 */
type Record&lt;K extends keyof any, T&gt; = {
    [P in K]: T;
};
</code></pre> 
 <p>可以根据 <code>K</code> 中的所有可能值来设置 <code>key</code>，以及 <code>value</code> 的类型，举个例子：</p> 
 <pre class="has"><code class="language-go">type T11 = Record&lt;'a' | 'b' | 'c', Person&gt;; // -&gt; { a: Person; b: Person; c: Person; }
</code></pre> 
 <h4>Pick</h4> 
 <p>从 <code>T</code> 中取出 一系列 <code>K</code> 的属性</p> 
 <pre class="has"><code class="language-go">/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Pick&lt;T, K extends keyof T&gt; = {
    [P in K]: T[P];
};
</code></pre> 
 <h4>Exclude</h4> 
 <p>Exclude 将某个类型中属于另一个的类型移除掉。</p> 
 <pre class="has"><code class="language-go">/**
 * Exclude from T those types that are assignable to U
 */
type Exclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre> 
 <p>以上语句的意思就是 如果 <code>T</code> 能赋值给 <code>U</code> 类型的话，那么就会返回 <code>never</code> 类型，否则返回 <code>T</code>，最终结果是将 <code>T</code> 中的某些属于 <code>U</code> 的类型移除掉</p> 
 <p>举个栗子：</p> 
 <pre class="has"><code class="language-go">type T00 = Exclude&lt;'a' | 'b' | 'c' | 'd', 'a' | 'c' | 'f'&gt;;  // -&gt; 'b' | 'd'
</code></pre> 
 <p>可以看到 <code>T</code> 是 <code>'a' | 'b' | 'c' | 'd'</code> ，然后 <code>U</code> 是 <code>'a' | 'c' | 'f'</code> ，返回的新类型就可以将 <code>U</code> 中的类型给移除掉，也就是 <code>'b' | 'd'</code> 了。</p> 
 <h4>Extract</h4> 
 <p><code>Extract</code> 的作用是提取出 <code>T</code> 包含在 <code>U</code> 中的元素，换种更加贴近语义的说法就是从 <code>T</code> 中提取出 <code>U</code>，源码如下：</p> 
 <pre class="has"><code class="language-go">/**
 * Extract from T those types that are assignable to U
 */
type Extract&lt;T, U&gt; = T extends U ? T : never;
</code></pre> 
 <p>Demo:</p> 
 <pre class="has"><code class="language-go">type T01 = Extract&lt;'a' | 'b' | 'c' | 'd', 'a' | 'c' | 'f'&gt;;  // -&gt; 'a' | 'c'
</code></pre> 
 <h4>Omit</h4> 
 <p><code>Pick</code> 和 <code>Exclude</code> 进行组合, 实现忽略对象某些属性功能, 源码如下:</p> 
 <pre class="has"><code class="language-go">/**
 * Construct a type with the properties of T except for those in type K.
 */
type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;
</code></pre> 
 <p>Demo:</p> 
 <pre class="has"><code class="language-go">// 使用
type Foo = Omit&lt;{name: string, age: number}, 'name'&gt; // -&gt; { age: number }
</code></pre> 
 <h4>更多工具泛型</h4> 
 <img src="https://images2.imgbox.com/d9/2d/gupLjV4Z_o.png"> 
 <p>其实常用的工具泛型大概就是我上面介绍的几种。更多的工具泛型，可以通过查看 <code>lib.es5.d.ts</code>里面查看。</p> 
 <p>毕竟。。。搬运几段声明着实没啥意思。</p> 
 <img src="https://images2.imgbox.com/e5/5e/jk8IePLO_o.png"> 
 <figcaption> 
  罗列 api 的写着也怪无聊的... 
 </figcaption> 
 <h3>类型断言</h3> 
 <p>断言这种东西还是少用。。。。不多对于初学者，估计最快熟练掌握的就是类型断言了。毕竟 <strong>「any 大法好」</strong></p> 
 <p>Typescript 允许我们覆盖它的推断（毕竟代码使我们自己写的），然后根据我们自定义的类型去分析它。这种机制，我们称之为 <strong>「类型断言」</strong></p> 
 <pre class="has"><code class="language-go">const nealyang = {};
nealyang.enName = 'Nealyang'; // Error: 'enName' 属性不存在于 ‘{}’
nealyang.cnName = '一凨'; // Error: 'cnName' 属性不存在于 '{}'
</code></pre> 
 <pre class="has"><code class="language-go">interface INealyang = {
  enName:string;
  cnName：string;
}

const nealyang = {} as INealyang; // const nealyang = &lt;INealyang&gt;{};
nealyang.enName = 'Nealyang';
nealyang.cnName = '一凨'; 
</code></pre> 
 <p>类型断言比较简单，其实就是“纠正”<code>ts</code>对类型的判断,当然，是不是纠正就看你自己的了。</p> 
 <p>需要注意一下两点即可：</p> 
 <ul><li><p>推荐类型断言的预发使用 <code>as</code>关键字，而不是<code>&lt;&gt;</code> ,防止歧义</p></li><li><p>类型断言并非类型转换，类型断言发生在编译阶段。类型转换发生在运行时</p></li></ul> 
 <h3>函数重载</h3> 
 <blockquote> 
  ❝ 
  <p>在我刚开始使用 ts 的时候，我一直困惑。。。为什么会有函数重载这么鸡肋的写法，可选参数它不香么？</p> 
  ❞ 
 </blockquote> 
 <img src="https://images2.imgbox.com/c9/fb/4FvfS7no_o.png"> 
 <figcaption> 
  慢慢你品 
 </figcaption> 
 <p>函数重载的基本语法：</p> 
 <pre class="has"><code class="language-go">declare function test(a: number): number;
declare function test(a: string): string;

const resS = test('Hello World');  // resS 被推断出类型为 string；
const resN = test(1234);           // resN 被推断出类型为 number;
</code></pre> 
 <p>这里我们申明了两次？！为什么我不能判断类型或者可选参数呢？后来我遇到这么一个场景，</p> 
 <pre class="has"><code class="language-go">interface User {
  name: string;
  age: number;
}

declare function test(para: User | number, flag?: boolean): number;
</code></pre> 
 <p>在这个 test 函数里，我们的本意可能是当传入参数 para 是 User 时，不传 flag，当传入 para 是 number 时，传入 flag。TypeScript 并不知道这些，当你传入 para 为 User 时，flag 同样允许你传入：</p> 
 <pre class="has"><code class="language-go">const user = {
  name: 'Jack',
  age: 666
}

// 没有报错，但是与想法违背
const res = test(user, false);
</code></pre> 
 <p>使用函数重载能帮助我们实现：</p> 
 <pre class="has"><code class="language-go">interface User {
  name: string;
  age: number;
}

declare function test(para: User): number;
declare function test(para: number, flag: boolean): number;

const user = {
  name: 'Jack',
  age: 666
};

// bingo
// Error: 参数不匹配
const res = test(user, false);
</code></pre> 
 <h3>Ts 的一些实战</h3> 
 <p>我之前在公众号里面发表过两篇关于TS在实战项目中的介绍：</p> 
 <ul><li><p><a target="_blank" href="https://blog.csdn.net/qq_29438877/article/details/103740486" rel="noopener noreferrer">如何用 Decorator 装饰你的 Typescript？</a></p></li><li><p><a target="_blank" href="https://blog.csdn.net/qq_29438877/article/details/104935519" rel="noopener noreferrer">一张页面引起的项目架构思考（rax+Typescript+hooks）</a></p></li></ul> 
 <h3>参考文献</h3> 
 <ul><li><p><a target="_blank" href="https://blog.csdn.net/qq_29438877/article/details/104787954" rel="noopener noreferrer">未来可期的TypeScript</a></p></li><li><p>Typescript 中文文档</p></li><li><p>深入理解 Typescript</p></li><li><p>TypeScript 2.8下的终极React组件模式</p></li><li><p>【速查手册】TypeScript 高级类型 cheat sheet</p></li><li><p>高级类型</p></li><li><p>TypeScript 在 React 中使用总结</p></li></ul> 
 <blockquote> 
  ❝ 
  <p>点击阅读原文可查外链</p> 
  ❞ 
 </blockquote> 
 <p>完</p> 
 <p>如果你觉得这篇内容对你挺有启发，我想邀请你帮我三个小忙：<br></p> 
 <ul><li><p>点个【在看】，或者分享转发，让更多的人也能看到这篇内容</p></li><li><p>关注公众号【全栈前端精选】，不定期分享原创&amp;精品技术文章。</p></li><li><p>公众号内回复：【 1 】。加入全栈前端精选公众号交流群。</p></li></ul> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/51/c2/CplYFPms_o.png"></p> 
 <p style="text-align: center">欢迎评论区留下你的精彩评论~<br></p> 
 <p>觉得文章不错可以分享到朋友圈让更多的小伙伴看到哦~</p> 
 <p>客官！在看一下呗</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3098adf136a1ffb41630a9a5a316436a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">记一次Idea 内存消耗严重，CPU资源占比严重的彻底解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/19e0a3eab00ec2428dd3f5c6c406251b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Gitee 代码搜索上线了，居然还可以搜索这些东西</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>