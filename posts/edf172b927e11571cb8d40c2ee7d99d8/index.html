<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>elasticsearch java实现类似sql group by - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="elasticsearch java实现类似sql group by" />
<meta property="og:description" content="学习es查询总是想往sql方面靠齐，学习了一段时间，总结一些如下
BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); //添加时间范围过滤 boolQueryBuilder.must(QueryBuilders.rangeQuery(&#34;@timestamp&#34;).format(&#34;yyyy-MM-dd HH:mm:ss&#34;).gte(conditionMap.get(&#34;createTimeB&#34;)).lte(conditionMap.get(&#34;createTimeE&#34;))); AggregationBuilder aggregationBuilder = AggregationBuilders .terms(查询字段别名).field(分组字段) .order(Terms.Order.aggregation(ES_COUNT_ALIAS, false)) .size(10) .subAggregation(AggregationBuilders.count(统计字段别名).field(统计的字段)); SearchRequestBuilder searchRequestBuilder = ElasticsearchHelper.getInstance().getClient().prepareSearch(ES_INDEX).setTypes(ES_TYPE) .setQuery(boolQueryBuilder) .addAggregation(aggregationBuilder) .setSize(0); SearchResponse sr = searchRequestBuilder.execute().actionGet(); Terms genders = sr.getAggregations().get(统计字段别名); for (Terms.Bucket entry : genders.getBuckets()) { list.add((String) entry.getKey()&#43;&#34;-(&#34;&#43;entry.getDocCount()&#43;&#34;)&#34;); }现在对上面进行修改，例如想group by 时间，并且按天来进行分组 AggregationBuilder aggregation = AggregationBuilders .dateHistogram(&#34;agg&#34;) .field(&#34;@timestamp&#34;) .format(&#34;yyyy-MM-dd&#34;) .dateHistogramInterval(DateHistogramInterval.DAY);然后现在可能有新需求，group by 时间，姓名 AggregationBuilder nameAgg = AggregationBuilders.terms(姓名别名).field(姓名).size(10); aggregation.subAggregation(nameAgg);如果可以能需要进行名称统计，但是需要distinct nameAgg.subAggregation(AggregationBuilders.cardinality(别名).field(姓名)) 其他的总结如下
（1）统计某个字段的数量 ValueCountBuilder vcb= AggregationBuilders.count(&#34;count_uid&#34;).field(&#34;uid&#34;); （2）去重统计某个字段的数量（有少量误差） CardinalityBuilder cb= AggregationBuilders.cardinality(&#34;distinct_count_uid&#34;).field(&#34;uid&#34;); （3）聚合过滤 FilterAggregationBuilder fab= AggregationBuilders." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/edf172b927e11571cb8d40c2ee7d99d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-28T09:41:18+08:00" />
<meta property="article:modified_time" content="2017-06-28T09:41:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">elasticsearch java实现类似sql group by</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>学习es查询总是想往sql方面靠齐，学习了一段时间，总结一些如下</p> 
<p></p> 
<pre><code class="language-html">BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
//添加时间范围过滤
        boolQueryBuilder.must(QueryBuilders.rangeQuery("@timestamp").format("yyyy-MM-dd HH:mm:ss").gte(conditionMap.get("createTimeB")).lte(conditionMap.get("createTimeE")));
        AggregationBuilder aggregationBuilder = AggregationBuilders
                .terms(查询字段别名).field(分组字段)
                .order(Terms.Order.aggregation(ES_COUNT_ALIAS, false))
                .size(10)
                .subAggregation(AggregationBuilders.count(统计字段别名).field(统计的字段));
        SearchRequestBuilder searchRequestBuilder = ElasticsearchHelper.getInstance().getClient().prepareSearch(ES_INDEX).setTypes(ES_TYPE)
                .setQuery(boolQueryBuilder)
                .addAggregation(aggregationBuilder)
                .setSize(0);

        SearchResponse sr = searchRequestBuilder.execute().actionGet();
        Terms genders = sr.getAggregations().get(<span style="font-family: Arial, Helvetica, sans-serif;">统计字段别名</span><span style="font-family: Arial, Helvetica, sans-serif;">);</span>
for (Terms.Bucket entry : genders.getBuckets()) { list.add((String) entry.getKey()+"-("+entry.getDocCount()+")"); }</code></pre>现在对上面进行修改，例如想group by 时间，并且按天来进行分组 
<br> 
<pre><code class="language-html">AggregationBuilder aggregation = AggregationBuilders
                .dateHistogram("agg")
                .field("@timestamp")
                .format("yyyy-MM-dd")
                .dateHistogramInterval(DateHistogramInterval.DAY);</code></pre>然后现在可能有新需求，group by 时间，姓名 
<br> 
<pre><code class="language-html">AggregationBuilder nameAgg = AggregationBuilders.terms(姓名别名).field(姓名).size(10);
aggregation.subAggregation(nameAgg);</code></pre>如果可以能需要进行名称统计，但是需要distinct 
<br> 
<pre><code class="language-html">nameAgg.subAggregation(AggregationBuilders.cardinality(别名).field(姓名))</code></pre> 
<p><br> </p> 
<p>其他的总结如下</p> 
<p></p> 
<pre><code class="language-html">（1）统计某个字段的数量
  ValueCountBuilder vcb=  AggregationBuilders.count("count_uid").field("uid");
（2）去重统计某个字段的数量（有少量误差）
 CardinalityBuilder cb= AggregationBuilders.cardinality("distinct_count_uid").field("uid");
（3）聚合过滤
FilterAggregationBuilder fab= AggregationBuilders.filter("uid_filter").filter(QueryBuilders.queryStringQuery("uid:001"));
（4）按某个字段分组
TermsBuilder tb=  AggregationBuilders.terms("group_name").field("name");
（5）求和
SumBuilder  sumBuilder=	AggregationBuilders.sum("sum_price").field("price");
（6）求平均
AvgBuilder ab= AggregationBuilders.avg("avg_price").field("price");
（7）求最大值
MaxBuilder mb= AggregationBuilders.max("max_price").field("price"); 
（8）求最小值
MinBuilder min=	AggregationBuilders.min("min_price").field("price");
（9）按日期间隔分组
DateHistogramBuilder dhb= AggregationBuilders.dateHistogram("dh").field("date");
（10）获取聚合里面的结果
TopHitsBuilder thb=  AggregationBuilders.topHits("top_result");
（11）嵌套的聚合
NestedBuilder nb= AggregationBuilders.nested("negsted_path").path("quests");
（12）反转嵌套
AggregationBuilders.reverseNested("res_negsted").path("kps ");</code></pre> 
<br> 
<br> 
<p></p> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6b0de2e0572534e72c872ffff70767a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">eclipse 配置信息迁移</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/368ef233db80b9a99b4607640ffc181d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">stm32 I2C自收发测试例程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>