<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试记录_ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试记录_" />
<meta property="og:description" content="1: ❀公司 三道编程题，可以运用你最擅长的语言编写：可以尝试搜索、查找、暴力遍历等方法
稍微复杂点的题目，基本上通过递归、BFS/DFS 解决，暴力也可尝试。
常考知识点&amp;算法：
1、排序
2、查找
3、字符串切割、子串查找、统计，替换
4、数的不同进制表示及转换
5、区间合并
6、全排列
7、二叉树，并查集，单调栈
8、位运算
9、数学表达式计算
10、广度/深度优先搜索
11、图类的单源路径搜索
https://blog.csdn.net/armstronghappy/article/details/119236183
线上笔试 进程流调，最大快乐数（读书），内存操作
现场🍣代码 同构字符串
def main(): s = &#34;badc&#34; t = &#34;bada&#34; list_s = list(s) list_t = list(t) dic_s2t = {} dic_t2s = {} for i in range(len(list_t)): x, y = list_s[i], list_t[i] if (x in dic_s2t and dic_s2t[x] != y) or (y in dic_t2s and dic_t2s[y] != x): return False dic_s2t[x] = y dic_t2s[y] = x return True if __name__ == &#39;__main__&#39;: print(main()) 三角形最大周长" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ebf9c8868def1e1e809a32da078348cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-03T19:37:17+08:00" />
<meta property="article:modified_time" content="2023-11-03T19:37:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试记录_</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__0"></a>1: ❀公司</h2> 
<p>三道编程题，可以运用你最擅长的语言编写：可以尝试搜索、查找、暴力遍历等方法<br> 稍微复杂点的题目，基本上通过递归、BFS/DFS 解决，暴力也可尝试。<br> 常考知识点&amp;算法：<br> 1、排序<br> 2、查找<br> 3、字符串切割、子串查找、统计，替换<br> 4、数的不同进制表示及转换<br> 5、区间合并<br> 6、全排列<br> 7、二叉树，并查集，单调栈<br> 8、位运算<br> 9、数学表达式计算<br> 10、广度/深度优先搜索<br> 11、图类的单源路径搜索</p> 
<p>https://blog.csdn.net/armstronghappy/article/details/119236183</p> 
<h3><a id="_18"></a>线上笔试</h3> 
<p>进程流调，最大快乐数（读书），内存操作</p> 
<h3><a id="_20"></a>现场🍣代码</h3> 
<p>同构字符串</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    s <span class="token operator">=</span> <span class="token string">"badc"</span>
    t <span class="token operator">=</span> <span class="token string">"bada"</span>
    list_s <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    list_t <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
    dic_s2t <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    dic_t2s <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>list_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        x<span class="token punctuation">,</span> y <span class="token operator">=</span> list_s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> list_t<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">in</span> dic_s2t <span class="token keyword">and</span> dic_s2t<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> y<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>y <span class="token keyword">in</span> dic_t2s <span class="token keyword">and</span> dic_t2s<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        dic_s2t<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> y
        dic_t2s<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> x
    <span class="token keyword">return</span> <span class="token boolean">True</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>三角形最大周长</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>


    <span class="token keyword">def</span> <span class="token function">largestPerimeter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">check</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">&gt;</span> z<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> z <span class="token operator">&gt;</span> y<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>y <span class="token operator">+</span> z <span class="token operator">&gt;</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>

        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token comment"># print(i,j,k)</span>
                    <span class="token keyword">if</span> check<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token number">0</span>

</code></pre> 
<h2><a id="1python_67"></a>1：面试杉岩数据（python开发）</h2> 
<h4><a id="111__68"></a>1.1.1 选择题</h4> 
<pre><code class="prism language-python">	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token builtin">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token builtin">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">=</span>j<span class="token operator">+</span>i<span class="token punctuation">)</span>		
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

O<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>O<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> O<span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> O<span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> O<span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> O<span class="token punctuation">(</span>n<span class="token operator">/</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
在最坏情况下，内部循环的迭代次数为 n<span class="token operator">/</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> n<span class="token operator">/</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> n<span class="token operator">/</span>n，这是一个等差数列求和，近似等于 n <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">/</span>n<span class="token punctuation">)</span>。
这个和级数是调和级数，其增长率约为对数级别，因此可以近似表示为 O<span class="token punctuation">(</span>log<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>。
所以，总的时间复杂度为：
O<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">*</span> O<span class="token punctuation">(</span>log<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> O<span class="token punctuation">(</span>n <span class="token operator">*</span> log<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
因此，上述嵌套循环的时间复杂度为 O<span class="token punctuation">(</span>n <span class="token operator">*</span> log<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>


copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span> 和 copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>

copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span> 是浅拷贝方法，用于创建原始对象的浅层副本。这意味着它会复制原始对象，但不会递归复制原始对象内部包含的对象。
如果原始对象内部包含其他可变对象（例如列表或字典），那么浅拷贝后的副本和原始对象将共享这些内部对象。因此，如果你修改副本内部的可变对象，原始对象可能也会受到影响。
<span class="token keyword">import</span> copy

original_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
shallow_copy <span class="token operator">=</span> copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>original_list<span class="token punctuation">)</span>

shallow_copy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">999</span>  <span class="token comment"># 修改副本中的内部对象</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>original_list<span class="token punctuation">)</span>  <span class="token comment"># 输出: [1, [999, 3]]，原始对象受影响</span>
copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span><span class="token punctuation">)</span> 是深拷贝方法，用于创建原始对象及其内部所有对象的完全副本。它递归地复制了整个对象层次结构，包括内部包含的所有对象。
这意味着深拷贝后的副本是原始对象的完全独立副本，对副本的任何修改都不会影响原始对象。

<span class="token keyword">import</span> copy

original_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
deep_copy <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>original_list<span class="token punctuation">)</span>

deep_copy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">999</span>  <span class="token comment"># 修改副本中的内部对象</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>original_list<span class="token punctuation">)</span>  <span class="token comment"># 输出: [1, [2, 3]]，原始对象不受影响</span>


</code></pre> 
<blockquote> 
 <p>1 / 1</p> 
 <p>举例不同的设计模式</p> 
</blockquote> 
<p>1 / 1</p> 
<p>设计模式是在软件工程中常用的解决问题的通用方法或模板。它们可以帮助开发人员更有效地解决常见问题，并提供了一种共享经验的方式。以下是一些不同的常见设计模式以及简要的示例：</p> 
<ol><li> <p><strong>单例模式 (Singleton Pattern)</strong>:</p> 
  <ul><li>单例模式确保一个类只有一个实例，并提供一个全局访问点。它通常用于管理全局资源。</li><li>示例：数据库连接池。只需一个数据库连接池来管理数据库连接。</li></ul> </li><li> <p><strong>工厂模式 (Factory Pattern)</strong>:</p> 
  <ul><li>工厂模式用于创建对象，但不暴露创建逻辑。它可以根据需要创建不同类型的对象。</li><li>示例：图形库中的图形对象工厂，可以根据用户需求创建不同类型的图形对象，如圆形、矩形等。</li></ul> </li><li> <p><strong>观察者模式 (Observer Pattern)</strong>:</p> 
  <ul><li>观察者模式定义了一种对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。</li><li>示例：图形用户界面中的事件处理。多个UI元素（观察者）可以订阅某个事件源（主题），当事件发生时，观察者会收到通知并更新。</li></ul> </li><li> <p><strong>策略模式 (Strategy Pattern)</strong>:</p> 
  <ul><li>策略模式定义了一系列算法，并将每个算法封装成对象，使它们可以互相替换。客户端可以灵活地选择使用哪个算法。</li><li>示例：排序算法。根据不同需求可以选择使用冒泡排序、快速排序等不同的排序策略。</li></ul> </li><li> <p><strong>适配器模式 (Adapter Pattern)</strong>:</p> 
  <ul><li>适配器模式用于将一个类的接口转换成另一个接口，以满足客户端的需求。它通常用于集成已有代码或库。</li><li>示例：将不同供应商的支付接口适配成统一的支付接口，以便客户端可以无缝切换供应商。</li></ul> </li><li> <p><strong>装饰器模式 (Decorator Pattern)</strong>:</p> 
  <ul><li>装饰器模式允许在不改变对象接口的情况下动态地添加行为或责任。它通过一系列包装（装饰器）来扩展对象的功能。</li><li>示例：文本处理中的格式化功能。可以通过添加装饰器来增加文本的格式化，如加粗、斜体、颜色等。</li></ul> </li><li> <p><strong>模板方法模式 (Template Method Pattern)</strong>:</p> 
  <ul><li>模板方法模式定义了一个算法的骨架，但将某些步骤的具体实现延迟到子类。它允许子类重新定义算法的某些部分，而不改变算法的结构。</li><li>示例：咖啡和茶的制备过程。制备过程的步骤（如煮水、冲泡、加调料等）是相同的，但具体实现可以有所不同。</li></ul> </li></ol> 
<p>这只是一些常见的设计模式示例。设计模式有助于提高代码的可维护性、可扩展性和可重用性，但要根据具体情况选择适当的模式。在实际应用中，通常会组合多个设计模式来解决复杂问题。</p> 
<blockquote> 
 <p>1 / 1</p> 
 <p>在python里面看到@dec</p> 
</blockquote> 
<p>1 / 1</p> 
<p>在Python中，<code>@</code> 符号通常用于装饰器（Decorator）语法。装饰器是一种高级的Python功能，允许你修改或增强函数或类的行为而不必修改它们的源代码。</p> 
<p>装饰器的一般语法如下：</p> 
<p>python</p> 
<pre><code class="prism language-python"><span class="token decorator annotation punctuation">@decorator_function</span>
<span class="token keyword">def</span> <span class="token function">some_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 函数的主体代码</span>
</code></pre> 
<p>或者对于类方法：</p> 
<p>python</p> 
<pre><code class="prism language-python"><span class="token decorator annotation punctuation">@decorator_function</span>
<span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span>
    <span class="token comment"># 类的定义</span>
</code></pre> 
<p>在这里，<code>@decorator_function</code> 是一个装饰器函数，它会作用于下面的函数或类。当你调用 <code>some_function</code> 或创建 <code>SomeClass</code> 的实例时，装饰器函数将修改或增强这些对象的行为。</p> 
<p>示例：</p> 
<p>python</p> 
<pre><code class="prism language-python"><span class="token comment"># 定义一个简单的装饰器</span>
<span class="token keyword">def</span> <span class="token function">my_decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Something is happening before the function is called."</span><span class="token punctuation">)</span>
        func<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Something is happening after the function is called."</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> wrapper

<span class="token comment"># 使用装饰器</span>
<span class="token decorator annotation punctuation">@my_decorator</span>
<span class="token keyword">def</span> <span class="token function">say_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span>

<span class="token comment"># 调用被装饰的函数</span>
say_hello<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>在这个示例中，<code>my_decorator</code> 是一个装饰器函数，它修改了 <code>say_hello</code> 函数的行为，在调用函数前后添加了额外的输出。</p> 
<p>Python有许多内置装饰器，例如 <code>@staticmethod</code>、<code>@classmethod</code> 等，还可以创建自定义的装饰器来满足特定需求，例如身份验证、性能分析、日志记录等。装饰器提供了一种优雅而强大的方式来扩展和自定义Python代码的功能。</p> 
<blockquote> 
 <p>1 / 1</p> 
 <p>*args 和 *kw</p> 
</blockquote> 
<p>1 / 1</p> 
<p>在Python中，<code>*args</code> 和 <code>**kwargs</code> 是用于处理可变数量的参数的特殊语法，通常在函数定义中使用。它们允许你编写接受不定数量参数的函数，这些参数可以是位置参数、关键字参数或它们的组合。</p> 
<ol><li><code>*args</code>（星号args）: 
  <ul><li><code>*args</code> 用于传递不定数量的位置参数给函数。它将传入的所有位置参数打包成一个元组（tuple），这个元组可以在函数内部进行迭代或处理。</li><li><code>*</code> 后面的名称可以是任何名称，但通常约定使用 <code>*args</code>。</li></ul> </li></ol> 
<p>示例：</p> 
<p>python</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">sum_numbers</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
    result <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> num <span class="token keyword">in</span> args<span class="token punctuation">:</span>
        result <span class="token operator">+=</span> num
    <span class="token keyword">return</span> result

<span class="token keyword">print</span><span class="token punctuation">(</span>sum_numbers<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出：15</span>
</code></pre> 
<ol start="2"><li><code>**kwargs</code>（双星号kwargs）: 
  <ul><li><code>**kwargs</code> 用于传递不定数量的关键字参数给函数。它将传入的所有关键字参数打包成一个字典（dictionary），这个字典可以在函数内部进行访问。</li><li><code>**</code> 后面的名称可以是任何名称，但通常约定使用 <code>**kwargs</code>。</li></ul> </li></ol> 
<p>示例：</p> 
<p>python</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">print_info</span><span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> kwargs<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>key<span class="token punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>value<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

print_info<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">"New York"</span><span class="token punctuation">)</span>
<span class="token comment"># 输出：</span>
<span class="token comment"># name: Alice</span>
<span class="token comment"># age: 30</span>
<span class="token comment"># city: New York</span>
</code></pre> 
<p>通常情况下，<code>*args</code> 和 <code>**kwargs</code> 可以与其他参数一起使用。当定义函数时，<code>*args</code> 必须在位置参数之后，而 <code>**kwargs</code> 必须在所有参数之后。这允许函数接受固定数量的位置参数和不定数量的位置参数和关键字参数。</p> 
<p>示例：</p> 
<p>python</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">example_function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"a=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>a<span class="token punctuation">}</span></span><span class="token string">, b=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>b<span class="token punctuation">}</span></span><span class="token string">, args=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>args<span class="token punctuation">}</span></span><span class="token string">, x=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">}</span></span><span class="token string">, y=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>y<span class="token punctuation">}</span></span><span class="token string">, kwargs=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>kwargs<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

example_function<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>
<span class="token comment"># 输出：</span>
<span class="token comment"># a=1, b=2, args=(3, 4, 5), x=10, y=20, kwargs={'name': 'Alice', 'age': 30}</span>
</code></pre> 
<p>使用 <code>*args</code> 和 <code>**kwargs</code> 可以增加函数的灵活性，允许你处理不同数量和类型的参数，这在某些情况下非常有用。</p> 
<h4><a id="131__273"></a>1.3.1 括号匹配</h4> 
<blockquote> 
 <p>给你一个只包含三种字符的字符串，支持的字符类型分别是 ‘(’、‘)’ 和 ‘*’。请你检验这个字符串是否为有效字符串，如果是有效字符串返回<br> true 。</p> 
 <p>有效字符串符合如下规则：</p> 
 <p>任何左括号 ‘(’ 必须有相应的右括号 ‘)’。 任何右括号 ‘)’ 必须有相应的左括号 ‘(’ 。 左括号 ‘(’ 必须在对应的右括号之前<br> ‘)’。 ‘*’ 可以被视为单个右括号 ‘)’ ，或单个左括号 ‘(’ ，或一个空字符串。 一个空字符串也被视为有效字符串。<br> https://leetcode.cn/problems/valid-parenthesis-string/solutions/992347/you-xiao-de-gua-hao-zi-fu-chuan-by-leetc-osi3/</p> 
</blockquote> 
<pre><code class="prism language-python">
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">checkValidString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        leftStack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        asteriskStack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"("</span><span class="token punctuation">:</span>
                leftStack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>
                asteriskStack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>leftStack<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">:</span>
                    leftStack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">elif</span> <span class="token builtin">len</span><span class="token punctuation">(</span>asteriskStack<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">:</span>
                    asteriskStack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>leftStack<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>asteriskStack<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">:</span>
            leftIndex<span class="token operator">=</span>leftStack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            asteriskIndex<span class="token operator">=</span>asteriskStack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>leftIndex<span class="token operator">&gt;</span>asteriskIndex<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>leftStack<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span>

way<span class="token operator">=</span>Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>way<span class="token punctuation">.</span>checkValidString<span class="token punctuation">(</span><span class="token string">"(*******)"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre> 
<h4><a id="132random10_313"></a>1.3.2不使用random库生成10个随机数</h4> 
<pre><code class="prism language-python">可以使用time库获取随机数字
</code></pre> 
<h4><a id="133__318"></a>1.3.3 二叉树层次遍历</h4> 
<blockquote> 
 <p>https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244853/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/</p> 
</blockquote> 
<pre><code class="prism language-python"><span class="token keyword">import</span> collections
<span class="token keyword">from</span> typing <span class="token keyword">import</span> Optional<span class="token punctuation">,</span> List


<span class="token comment"># Definition for a binary tree node.</span>
<span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
        self<span class="token punctuation">.</span>left <span class="token operator">=</span> left
        self<span class="token punctuation">.</span>right <span class="token operator">=</span> right

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span>TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        deque<span class="token operator">=</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> deque<span class="token punctuation">:</span>
            length<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span>
            level<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node<span class="token operator">=</span>deque<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                level<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>level<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre> 
<h2><a id="2python_354"></a>2：面试迪普科技（python开发）</h2> 
<p><img src="https://images2.imgbox.com/11/8b/FGSZzrPV_o.png" alt="请添加图片描述"></p> 
<blockquote> 
 <p>1 / 1</p> 
 <p>ls=[1,2,3,4,5] ls[3]=[a,b,c]</p> 
</blockquote> 
<p>1 / 1</p> 
<p>在您提供的代码中，您似乎希望将列表 <code>ls</code> 中的第三个元素（索引为3的元素）替换为一个新的列表 <code>[a, b, c]</code>。但是，这不是有效的Python语法，因为您试图将一个列表赋值给另一个列表的某个索引位置。要达到您的目标，您可以使用以下方式：</p> 
<p>python</p> 
<pre><code class="prism language-python">ls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
ls<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span>
</code></pre> 
<p>上述代码将会把列表 <code>ls</code> 中索引为3的元素（原来的数字4）替换为一个新的包含字符串 ‘a’、‘b’ 和 ‘c’ 的列表。现在，<code>ls</code> 的值将变为 <code>[1, 2, 3, ['a', 'b', 'c'], 5]</code>。如果您希望将元素替换为单个字符而不是字符串列表，可以将字符放入单引号或双引号中。</p> 
<blockquote> 
 <p>1 / 1</p> 
 <p>Python读取txt文件的方法</p> 
</blockquote> 
<p>1 / 1</p> 
<p>在Python中，你可以使用内置的文件操作来读取文本文件（.txt 文件）。以下是一种常见的方法：</p> 
<p>python</p> 
<pre><code class="prism language-python"><span class="token comment"># 打开文本文件以读取内容</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'example.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用with语句，确保文件在使用后自动关闭</span>

    <span class="token comment"># 读取文件的全部内容</span>
    file_contents <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 或者逐行读取文件内容</span>
    <span class="token comment"># for line in file:</span>
    <span class="token comment">#     print(line)</span>

<span class="token comment"># 现在，file已经被自动关闭</span>

<span class="token comment"># 处理文件内容</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>file_contents<span class="token punctuation">)</span>
</code></pre> 
<p>上述代码的关键点如下：</p> 
<ol><li> <p>使用 <code>open</code> 函数打开文件，第一个参数是文件的路径，第二个参数是文件的模式。在这里，我们使用 <code>'r'</code> 模式以只读方式打开文件。</p> </li><li> <p>使用 <code>with</code> 语句来自动管理文件的打开和关闭，这是一种良好的做法，可以确保文件在使用后被正确关闭，从而避免资源泄漏。</p> </li><li> <p>使用 <code>read</code> 方法来读取整个文件的内容，将其存储在一个字符串中。你也可以使用 <code>readlines</code> 方法逐行读取文件内容，或者使用迭代方式遍历文件的每一行。</p> </li><li> <p>处理文件内容，可以将其打印出来或进行其他操作。</p> </li></ol> 
<p>请注意，上述代码中的文件路径 <code>'example.txt'</code> 应该替换为你要读取的实际文件路径。此外，还可以使用绝对路径或相对路径，具体取决于文件的位置。</p> 
<blockquote> 
 <p>1 / 1</p> 
 <p>介绍和readlines 类似的函数</p> 
</blockquote> 
<p>1 / 1</p> 
<p>在Python中，除了 <code>readlines</code> 方法，还有一些其他函数可以用来读取文本文件的内容，每种方法都有其自身的特点。以下是一些类似于 <code>readlines</code> 的函数和方法：</p> 
<ol><li> <p><strong>readline() 方法</strong>：<code>readline()</code> 方法用于逐行读取文本文件的内容。每次调用该方法，它会返回文件中的下一行作为字符串。当到达文件末尾时，它返回一个空字符串。</p> <p>python</p> <pre><code class="prism language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'example.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
    line <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> line<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>
        line <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> </li><li> <p><strong>for 循环遍历文件</strong>：你可以将文件对象用于 <code>for</code> 循环，以便逐行遍历文件内容。这会自动将文件分割成行，并在每次迭代中返回一行。</p> <p>python</p> <pre><code class="prism language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'example.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>
</code></pre> </li><li> <p><strong>read(n) 方法</strong>：<code>read(n)</code> 方法用于读取文件中的前 n 个字符，而不是逐行读取。你可以指定要读取的字符数。</p> <p>python</p> <pre><code class="prism language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'example.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
    content <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>  <span class="token comment"># 读取前100个字符</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>
</code></pre> </li><li> <p><strong>readline(n) 方法</strong>：类似于 <code>readline()</code>，但可以指定要读取的字符数。它会返回文件中的下一行，或者直到达到指定的字符数为止。</p> <p>python</p> <pre><code class="prism language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'example.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
    line <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>  <span class="token comment"># 读取50个字符或下一行，以先到者为准</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>
</code></pre> </li></ol> 
<p>这些方法可以根据你的需求选择，从而更灵活地读取文本文件的内容。请根据具体情况选择最适合你的方法。</p> 
<h2><a id="3__468"></a>3：某某国企 （软件软件开发工程师）</h2> 
<blockquote> 
 <p>1 / 1</p> 
 <p>介绍下码元的定义</p> 
</blockquote> 
<p>1 / 1</p> 
<p>码元是数字通信中的基本时间单位，通常用来表示数字信号的一个离散时间间隔或一个符号。它是数字信号调制和解调的基本构建块之一，用于传输数字信息。</p> 
<p>在数字通信中，码元可以有不同的表示方式，取决于信号调制的方式。以下是一些常见的调制方式和它们的码元表示：</p> 
<ol><li> <p>频移键控（FSK）调制：在FSK中，不同的码元代表不同的频率。例如，两个码元可以分别表示高频和低频信号。</p> </li><li> <p>相移键控（PSK）调制：在PSK中，不同的码元代表不同的相位。常见的PSK调制包括二进制PSK（BPSK，两个相位）和四进制PSK（QPSK，四个相位）。</p> </li><li> <p>振幅键控（ASK）调制：在ASK中，不同的码元代表不同的振幅水平。通常用于基于振幅的调制，如调幅（AM）广播。</p> </li><li> <p>正交振幅调制（QAM）：在QAM中，不同的码元表示不同的相位和振幅组合，通常用于高速数字通信，如有线电视和数字调制解调器。</p> </li><li> <p>脉冲振幅调制（PAM）：在PAM中，不同的码元代表不同的脉冲幅度，通常用于数字通信系统中的基带传输。</p> </li></ol> 
<p>通过将数字信息映射到不同的码元，数字通信系统能够传输和接收信息。码元的速率通常由波特（Baud）来表示，它表示每秒传输的码元数。了解码元的定义对于理解数字通信和通信系统设计非常重要。</p> 
<blockquote> 
 <p>1 / 1</p> 
 <p>码间干扰</p> 
</blockquote> 
<p>1 / 1</p> 
<p>码间干扰（Inter-Symbol Interference，简称ISI）是数字通信中一个常见的问题，它发生在接收端由于码元之间的时域重叠或延迟引起的信号干扰。ISI可能会导致接收端无法准确地解码数字信号，从而导致通信错误。</p> 
<p>ISI的主要原因包括：</p> 
<ol><li> <p>信道传输延迟：信号在传输过程中会经历不同的传播延迟，导致相邻码元之间的时间间隔发生变化。这可能会使得信号在接收端的码元间出现重叠。</p> </li><li> <p>信道色散：在光纤等传输介质中，不同频率的成分会以不同的速度传播，导致信号中的不同频率部分在接收端的时间偏移，进一步引发ISI。</p> </li></ol> 
<p>为了克服ISI并提高数字通信的可靠性，通常采取以下方法：</p> 
<ol><li> <p>码间等化（Inter-Symbol Interference Equalization）：这是一种在接收端对接收到的信号进行处理的技术，旨在消除或减小不同码元之间的干扰。等化器可以根据信道的特性来调整接收信号，以恢复原始数据。</p> </li><li> <p>增加保护间隔：通过增加码元之间的间隔来减小ISI的发生概率。这通常通过调整传输速率或使用更复杂的调制技术来实现。</p> </li><li> <p>使用特定的编码和调制方案：一些编码和调制方案设计时考虑了ISI的问题，可以在一定程度上减小ISI的影响。例如，Trellis编码和低密度奇偶校验（LDPC）编码。</p> </li><li> <p>自适应均衡：这是一种动态调整等化器参数的方法，以适应信道条件的变化，从而最小化ISI的影响。</p> </li></ol> 
<p>ISI是数字通信中需要考虑和处理的重要问题，特别是在高比特率和长传输距离的通信系统中。有效的ISI管理可以显著提高通信系统的性能和可靠性。</p> 
<blockquote> 
 <p>1 / 1</p> 
 <p>还有啥干扰</p> 
</blockquote> 
<p>1 / 1</p> 
<p>除了码间干扰（ISI），在数字通信中还存在其他一些常见的干扰类型，这些干扰可能会影响信号质量和通信性能。以下是一些其他常见的数字通信干扰类型：</p> 
<ol><li> <p><strong>噪声干扰（Noise Interference）</strong>：噪声是由于环境、电子设备或通信信道本身引入的随机信号。噪声会在接收端添加到信号中，导致信号的失真和误差。常见的噪声类型包括热噪声、白噪声和陷波噪声。</p> </li><li> <p><strong>多径干扰（Multipath Interference）</strong>：多径干扰是由于信号在传播过程中经历多个不同路径的反射和折射而引起的。这些多个信号路径可能会导致在接收端的不同时间到达，从而导致码元重叠和失真。</p> </li><li> <p><strong>频率偏移干扰（Frequency Offset Interference）</strong>：频率偏移是指发送端和接收端的时钟频率之间的差异。这种差异会导致信号频率发生偏移，影响解调和解码过程。</p> </li><li> <p><strong>相位噪声干扰（Phase Noise Interference）</strong>：相位噪声是指信号的相位随时间发生随机波动。相位噪声可以影响调制信号的相位稳定性，从而降低信号的质量。</p> </li><li> <p><strong>电磁干扰（Electromagnetic Interference，EMI）</strong>：电磁干扰是由其他电子设备、无线通信、电源线等发出的电磁信号干扰引起的。EMI可能会导致信号质量下降，特别是在无线通信环境中。</p> </li><li> <p><strong>多用户干扰（Multi-User Interference）</strong>：在多用户通信系统中，其他用户的信号可能会干扰到目标用户的信号。这种干扰通常需要通过多址分配和多用户检测技术来管理。</p> </li><li> <p><strong>时钟漂移干扰（Clock Drift Interference）</strong>：时钟漂移是时钟信号的频率或相位发生变化，可能会影响定时和同步，导致通信错误。</p> </li></ol> 
<p>为了减小这些干扰的影响，数字通信系统通常采用各种技术，包括纠错编码、自适应均衡、频率和相位同步、抗噪声方法等。此外，合适的信号设计和传输系统规划也可以减少干扰的影响，提高通信的可靠性和性能。</p> 
<blockquote> 
 <p>1 / 1</p> 
 <p>简单介绍下口令安全</p> 
</blockquote> 
<p>1 / 1</p> 
<p>口令安全是指保护和管理用户在计算机系统、应用程序、网络或其他信息系统中使用的口令（密码）的安全性。口令通常用于验证用户身份，并授权其访问受保护的资源或数据。以下是口令安全的一些关键概念和最佳实践：</p> 
<ol><li> <p><strong>强密码要求</strong>：为了提高口令安全性，系统通常要求用户创建强密码。强密码包括足够的长度、包含字母、数字和特殊字符，并避免使用容易猜测的信息（如生日或常用词汇）。</p> </li><li> <p><strong>定期更改密码</strong>：为了降低潜在的风险，用户通常被要求定期更改其口令。这有助于防止口令被滥用或暴露在网络上。</p> </li><li> <p><strong>双因素认证</strong>：双因素认证是一种增加安全性的方法，它要求用户提供两个或更多验证因素才能获得访问权限。通常，这包括“知识因素”（口令）和“拥有因素”（例如手机生成的临时验证码）。</p> </li><li> <p><strong>加密存储</strong>：存储口令时，系统应该使用安全的加密算法来保护用户口令的机密性。这样，即使存储的数据被盗取，黑客也无法轻易获取明文口令。</p> </li><li> <p><strong>防止口令泄露</strong>：用户应该小心保护自己的口令，避免将其共享给其他人，尤其是通过不安全的渠道（如电子邮件）。此外，应避免使用相同的口令在多个不同的系统上。</p> </li><li> <p><strong>安全的密码恢复流程</strong>：系统应该有安全的密码恢复机制，以便用户可以重置忘记的密码，但这一流程应该足够安全，以防止未经授权的访问。</p> </li><li> <p><strong>监控和审计</strong>：系统管理员应该定期监控口令安全性，并记录口令变更和访问事件，以便在出现异常情况时进行调查和追踪。</p> </li><li> <p><strong>教育和培训</strong>：用户应该接受关于口令安全最佳实践的培训，以了解如何创建和保护强密码，以及如何避免社交工程和钓鱼攻击。</p> </li></ol> 
<p>口令安全对于保护个人隐私和组织敏感信息至关重要。不安全的口令管理可能导致数据泄露、未经授权的访问和其他安全问题。因此，组织和个人都应重视口令安全，并采取适当的措施来维护其安全性。</p> 
<blockquote> 
 <p>1 / 1</p> 
 <p>采样量化编码</p> 
</blockquote> 
<p>1 / 1</p> 
<p>采样、量化和编码是数字信号处理中的三个重要步骤，通常用于将连续模拟信号转换为离散数字信号。这一过程被称为采样量化编码（Sampling, Quantization, and Coding）。</p> 
<ol><li> <p><strong>采样（Sampling）</strong>：采样是将连续模拟信号在时间上离散化的过程。这意味着周期性地测量模拟信号的振幅值，并在每个采样点上记录其值。采样频率决定了每秒采样的次数，通常以赫兹（Hz）为单位表示。根据奈奎斯特定理，采样频率应至少是信号带宽的两倍，以便准确还原原始信号。</p> </li><li> <p><strong>量化（Quantization）</strong>：量化是将连续的采样值映射到有限数量的离散值（通常是二进制值）的过程。这个过程引入了量化误差，因为它不可能完美地表示所有可能的连续信号值。量化过程通常使用ADC（模数转换器）来完成，其中模拟信号的振幅值被映射到最接近的离散级别。</p> </li><li> <p><strong>编码（Coding）</strong>：编码是将量化后的信号值表示为数字编码的过程，以便传输、存储或处理。常见的编码方式包括二进制编码（将每个量化值映射到一个二进制数），格雷编码（用于减小在两个连续值之间的差异），或其他编码方式，取决于应用的需求。</p> </li></ol> 
<p>采样量化编码的目的是将连续的模拟信号转化为数字形式，以便在数字系统中进行处理和传输。这一过程在许多领域中广泛应用，包括音频处理、图像处理、通信系统、传感器技术等。采样频率、量化位数和编码方案的选择会影响到数字信号的质量和精度，因此需要根据具体应用的要求进行仔细的设计和调整。</p> 
<p>口令安全不取决于（）。</p> 
<p>A.口令长度</p> 
<p>B.口令复杂度</p> 
<p>C.口令的更换周期</p> 
<p>D.口令是否合理存放</p> 
<p>E.口令是否便于记忆</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3da0702a12c456b7e13803d28e81ee2d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通过sed在文档下面添加内容</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03d736c92f2428d5781937847d0ec813/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【华为网络-配置-004】-VLAN 及三层交换配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>