<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java：面向对象（类与对象） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java：面向对象（类与对象）" />
<meta property="og:description" content="面向对象思想引入：前面我们讲过数组，当有多个数组都需要遍历时，我们可以将遍历的代码封装到方法中，需要遍历时，就调用相应的方法即可，提高代码的复用性。在对数组遍历的基础上继续增加需求，比如获取最值，数值逆序等，同样需要将这些功能封装到相应的方法中。这样继续封装会发现方法越来越多，于是就想能不能将这些方法继续进行封装呢？通过前面的讲解我们知道类是可以存放方法的，所以，我们就考虑使用类封装来这多个方法，将来再做数组的操作时，不用去找具体的方法，先找到这个类，然后使用这个类中的方法。这就是面向对象思想的编程方式。
面向对象思想概述：完成一个需求的步骤：首先是搞清楚我们要做什么，然后在分析怎么做，最后我们再代码体现。一步一步去实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。 在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。 那么什么是面向过程开发呢? 面向过程开发，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。 面向过程的代表语言：C语言
事物：
属性：用来描述事物的信息
行为：用来事物能够做什么
类：是一组相关对象的集合
成员变量：事物的属性
成员方法：事物的行为
定义一个类其实就是定义它的成员变量和成员方法；
对象：是该类事物的具体表现
举例：
类：学生（属性：性别、姓名、年龄、、、、、；行为：学习、吃饭、睡觉、、、、）；
对象：班长
类：成员变量：gender,name,age......;成员方法：study(),eat(),sleep().......
定义成员变量：位置：在类中，方法外；格式：数据类型 变量名
定义成员方法：位置：在类中；格式：修饰符 返回值类型 方法名 参数列表{ 方法体；}；
成员变量与局部变量的区别：
1、定义的位置不同：
成员变量定义在类中，方法外；
局部变量定义在类中，方法内；
2.内存位置也不同：
成员变量在栈内存中；
局部变量在堆内存中；
3.初始化值不同：
成员变量系统会给予默认值；
局部变量系统不会给予默认值，必须在定义的时候赋值，或者在方法使用中赋值，才能使用；
4.生命周期不同：
成员变量随着对象的创建而创建，随着对象的消失而消失；
局部变量随着方法的调用而创建，随着方法的消失而消失；
class Bianliang { String name; int age; public void show(int n){ n=10; int a=20; System.out.println(n); System.out.println(a); String name=&#34;车厘子&#34;; System.out.println(name); } } public class TestBianliang1{ public static void main(String[] args) { Bianliang s1=new Bianliang(); s1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ae00c22bd6c80fabf6936ae780354e73/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-11T21:31:37+08:00" />
<meta property="article:modified_time" content="2022-01-11T21:31:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java：面向对象（类与对象）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>面向对象思想引入：</strong>前面我们讲过数组，当有多个数组都需要遍历时，我们可以将遍历的代码封装到方法中，需要遍历时，就调用相应的方法即可，提高代码的复用性。在对数组遍历的基础上继续增加需求，比如获取最值，数值逆序等，同样需要将这些功能封装到相应的方法中。这样继续封装会发现方法越来越多，于是就想能不能将这些方法继续进行封装呢？通过前面的讲解我们知道类是可以存放方法的，所以，我们就考虑使用类封装来这多个方法，将来再做数组的操作时，不用去找具体的方法，先找到这个类，然后使用这个类中的方法。这就是面向对象思想的编程方式。</p> 
<p><strong>面向对象思想概述：</strong>完成一个需求的步骤：首先是搞清楚我们要做什么，然后在分析怎么做，最后我们再代码体现。一步一步去实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。 在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。 那么什么是面向过程开发呢? 面向过程开发，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。 面向过程的代表语言：C语言</p> 
<p><strong>事物：</strong></p> 
<p><strong>属性：</strong>用来描述事物的信息</p> 
<p><strong>行为：</strong>用来事物能够做什么</p> 
<p><strong>类：</strong>是一组相关对象的集合</p> 
<p><strong>成员变量：</strong>事物的属性</p> 
<p><strong>成员方法：</strong>事物的行为</p> 
<p><strong>定义一个类其实就是定义它的成员变量和成员方法；</strong></p> 
<p><strong>对象：</strong>是该类事物的具体表现</p> 
<p><strong>举例：</strong></p> 
<p><strong>类：学生（属性：性别、姓名、年龄、、、、、；行为：学习、吃饭、睡觉、、、、）；</strong></p> 
<p><strong>对象：班长</strong></p> 
<p><strong>类：成员变量：gender,name,age......;成员方法：study(),eat(),sleep().......</strong></p> 
<p><strong>定义成员变量：位置：在类中，方法外；格式：数据类型 变量名</strong></p> 
<p><strong>定义成员方法：位置：在类中；格式：修饰符 返回值类型 方法名 参数列表{ 方法体；}；</strong></p> 
<p><strong>成员变量与局部变量的区别：</strong></p> 
<p><strong>1、定义的位置不同：</strong></p> 
<p>成员变量定义在类中，方法外；</p> 
<p>局部变量定义在类中，方法内；</p> 
<p><strong>2.内存位置也不同：</strong></p> 
<p>成员变量在栈内存中；</p> 
<p>局部变量在堆内存中；</p> 
<p><strong>3.初始化值不同：</strong></p> 
<p>成员变量系统会给予默认值；</p> 
<p>局部变量系统不会给予默认值，必须在定义的时候赋值，或者在方法使用中赋值，才能使用；</p> 
<p><strong>4.生命周期不同：</strong></p> 
<p>成员变量随着对象的创建而创建，随着对象的消失而消失；</p> 
<p>局部变量随着方法的调用而创建，随着方法的消失而消失；</p> 
<pre><code class="language-java">class Bianliang {
     String name;
    int age;
    public void show(int n){
        n=10;
        int a=20;
        System.out.println(n);
        System.out.println(a);
        String name="车厘子";
        System.out.println(name);
    }
}
public class TestBianliang1{
    public static void main(String[] args) {
        Bianliang s1=new Bianliang();
        s1.age=18;
        s1.name="车厘子";
        System.out.println(s1.age+","+s1.name);
        s1.show(100);

    }

}</code></pre> 
<p>形式参数问题：</p> 
<p>1.当形式参数是基本数据类型的时候，将来调用方法的时候传入的是常量值，或者是该类型的变量；</p> 
<p>2.当形式参数是引用数据类型的时候，将来调用方法的时候传的是该类对象的地址值；</p> 
<p>3.当形式参数是基本参数类型的时候，在方法中对变量进行修改不会影响到外部实际的栈内存中的值；</p> 
<p>4.当形式参数是引用数据类型的时候，在方法中对变量进行修改会影响到堆内存中的值；</p> 
<pre><code class="language-java">class Test21 {
    public int getSum() {
        int a = 10;
        int b = 20;
        return a + b;
    }
}
class student{
        String name;
        public void speak(){
            System.out.println("我爱学习");
        }
    }
class Students1{
    public void function(student s){
        s.name="车厘子";
        s.speak();
    }
}

public class Test2 {
    public static void main(String[] args) {
        Test21 s = new Test21();
        int a = 100;
        int b = 200;
        System.out.println(a + "," + b);？\\100,200
        System.out.println(s.getSum());\\30
       student x=new student();
       Students1 y=new Students1();
        System.out.println(x.name);\\null
        y.function(x);
        System.out.println(x.name);\\车厘子

    }
}</code></pre> 
<p>匿名对象：没有名字的对象</p> 
<p>使用场景：</p> 
<p>1.调用次数仅调用一次的时候；</p> 
<p>2.当放法的参数类型同一个类的时候；</p> 
<pre><code class="language-java">package com.one;
class Phone1{
    public void show(){
        System.out.println("手机可以打电话");
    }
}
class PhoneDemo{
    public void function(Phone1 p) {
     p.show();
    }
}
public class Phone4 {
    public static void main(String[] args) {
        PhoneDemo s =new PhoneDemo();
        Phone1 pd = new  Phone1();
       s.function(pd);

    }
}
</code></pre> 
<p><strong>获取成员变量的方法：</strong></p> 
<p>1.提供一个公共的方法，打印所有的变量值； </p> 
<p>2.单个使用获取方法，一个一个获取打印，更加方便灵活；</p> 
<p><strong>private：私有的</strong></p> 
<p>1.它可以修饰成员</p> 
<p>2.被private修饰的成员只能在本类中访问使用</p> 
<pre><code class="language-java">public class Phone {
    private String brand;
    private int price;
    private String color;
//提供一个公共set方法
//    成员变量：被private修饰
//            成员方法：getXxx()和setXxx()，其中setXxx(..)形参的名字与成员变量名字一致，使用this关键字赋值
//                    show()
    public void setBrand(String brand) {
        this.brand = brand;
    }
//提供一个公共get方法
    public String getBrand() {
        return brand;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public int getPrice() {
        return price;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getColor() {
        return color;
    }

    public void show() {
        System.out.println(brand + "," + price + "," + color);
    }

}

class Testphone {
    public static void main(String[] args) {
        Phone s = new Phone();
//        赋值
        s.setBrand("小米");
        s.setPrice(2999);
        s.setColor("黑");
        System.out.println(s.getBrand() + s.getPrice() + s.getColor());
        s.show();
//        单独获取数据
        String brand= s.getBrand();
        System.out.println(brand);
        String color=s.getColor();
        System.out.println(color);
        int price=s.getPrice();
        System.out.println(price);
    }
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd4b49e47461bc9403f2d5df4c97d2c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python入门之print()函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0b1bebf7c76320eede4a67f874e694f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WPS创建多级级联菜单</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>