<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python yield含义 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python yield含义" />
<meta property="og:description" content="提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、yield迭代器二、使用步骤1.引入库2.读入数据 总结 前言 提示：这里可以添加本文要记录的大概内容：
例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
一、yield迭代器 在python深度学习模型读取数据时，经常遇到yield，互联网搜索后，将比较容易理解的说明记录一下。
二、使用步骤 1.引入库 代码如下（示例）：
def batch(data, batch_size): for ex in data: yield ex 2.读入数据 代码如下（示例）：
p_batch = batch(p_batch, self.batch_size) 总结 如果不太好理解yield，可以先把yield当作return的同胞兄弟来看，他们都在函数中使用，并履行着返回某种结果的职责。
这两者的区别是：
有return的函数直接返回所有结果，程序终止不再运行，并销毁局部变量；
def batch(data, batch_size): for ex in data: return ex 而有yield的函数则返回一个可迭代的 generator（生成器）对象，你可以使用for循环或者调用next()方法遍历生成器对象来提取结果。
什么是生成器呢？在 Python 中，使用了yield的函数被称为生成器。有点套娃的感觉，但事实就是这样，调用一个yield函数，就会返回一个生成器对象。
def test: x=1 y=10 while x&lt;y: yield x x&#43;=1 t = test() 在调用生成器函数的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息（保留局部变量），返回yield的值, 并在下一次执行next()方法时从当前位置继续运行，直到生成器被全部遍历完。
举个例子
def test: x=1 yield x yield x&#43;1 yield x&#43;2 t = test() for tmp in t: print(tmp) #输出结果为： 1 2 3 也可以调用next方法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f063fda25bae9e371fd8a33209c06d14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-03T11:33:02+08:00" />
<meta property="article:modified_time" content="2022-11-03T11:33:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python yield含义</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">前言</a></li><li><a href="#yield_16" rel="nofollow">一、yield迭代器</a></li><li><a href="#_19" rel="nofollow">二、使用步骤</a></li><li><ul><li><a href="#1_20" rel="nofollow">1.引入库</a></li><li><a href="#2_30" rel="nofollow">2.读入数据</a></li></ul> 
  </li><li><a href="#_38" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_7"></a>前言</h2> 
<p><code>提示：这里可以添加本文要记录的大概内容：</code></p> 
<p>例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。</p> 
<hr> 
<p><code>提示：以下是本篇文章正文内容，下面案例可供参考</code></p> 
<h2><a id="yield_16"></a>一、yield迭代器</h2> 
<p>在python深度学习模型读取数据时，经常遇到yield，互联网搜索后，将比较容易理解的说明记录一下。</p> 
<h2><a id="_19"></a>二、使用步骤</h2> 
<h3><a id="1_20"></a>1.引入库</h3> 
<p>代码如下（示例）：</p> 
<pre><code class="prism language-c">def <span class="token function">batch</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token operator">:</span>
	<span class="token keyword">for</span> ex in data<span class="token operator">:</span>
		yield ex

</code></pre> 
<h3><a id="2_30"></a>2.读入数据</h3> 
<p>代码如下（示例）：</p> 
<pre><code class="prism language-c"> p_batch <span class="token operator">=</span> <span class="token function">batch</span><span class="token punctuation">(</span>p_batch<span class="token punctuation">,</span> self<span class="token punctuation">.</span>batch_size<span class="token punctuation">)</span>
</code></pre> 
<hr> 
<h2><a id="_38"></a>总结</h2> 
<p>如果不太好理解yield，可以先把yield当作return的同胞兄弟来看，他们都在函数中使用，并履行着返回某种结果的职责。</p> 
<p>这两者的区别是：<br> 有return的函数直接返回所有结果，程序终止不再运行，并销毁局部变量；</p> 
<pre><code>def batch(data, batch_size):
	for ex in data:
		return ex
</code></pre> 
<p>而有yield的函数则返回一个可迭代的 generator（生成器）对象，你可以使用for循环或者调用next()方法遍历生成器对象来提取结果。</p> 
<p>什么是生成器呢？在 Python 中，使用了yield的函数被称为生成器。有点套娃的感觉，但事实就是这样，调用一个yield函数，就会返回一个生成器对象。</p> 
<pre><code>def test:
	x=1
	y=10
	while x&lt;y:
		yield x
		x+=1
t = test()


</code></pre> 
<p>在调用生成器函数的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息（保留局部变量），返回yield的值, 并在下一次执行next()方法时从当前位置继续运行，直到生成器被全部遍历完。</p> 
<p>举个例子</p> 
<pre><code>def test:
	x=1
	yield x
	yield x+1
	yield x+2
	
t = test()
for tmp in t:
	print(tmp)
#输出结果为：
1
2
3

</code></pre> 
<p>也可以调用next方法：</p> 
<pre><code>next（t）
#输出：
1
next（t）
#输出：
2
next（t）
#输出：
3
</code></pre> 
<p>可以看到，test函数返回一个生成器，调用next()方法后，函数开始运行，遇到第一个yield关键字，返回生成的值（1），程序暂停；</p> 
<p>第二次调用next()方法，代码从上次暂停的位置开始执行，并遇到了第二个yield关键字，再返回生成的值（2），程序暂停；</p> 
<p>第三次调用也是如此，返回生成的值（3），生成器耗尽，程序终止；</p> 
<p>带yield的函数是一个生成器，这个生成器有一个方法就是next，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的。</p> 
<p>所以调用next的时候，生成器<em>并不会从函数的开始执行，只是接着上一步停止的地方开始</em>，然后遇到yield后，return出要生成的数，此步就结束。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8bd9d0f2b3f85afeb8ddc85d29646817/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NVDLA NV_small代码生成</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c8aec1f8306cb73f0d6b1666f3ac93d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue中pdf.js在线展示base64文件流</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>