<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>随笔四——IO/进程和线程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="随笔四——IO/进程和线程" />
<meta property="og:description" content="IO 标准IO 标准I/O，也称为stdio，是C语言标准库中提供的一套I/O函数，用于实现与外部设备（如终端、磁盘文件等）的输入和输出操作。标准I/O主要包括文件操作、缓冲区和流控制等方面的功能，是一套通用的、可移植的I/O接口。
标准I/O的优点在于它提供了一些缓冲机制，能够有效地减少对磁盘或其他外设的I/O操作次数，提高了I/O效率。此外，标准I/O还提供了一些方便的I/O控制函数，如文件定位函数、错误处理函数等，使得文件I/O操作更加简单、高效和安全。
标准I/O主要使用FILE结构体来表示文件，它包含了文件的缓冲区、文件指针、文件描述符等信息。标准I/O库中提供了许多函数来处理文件，如fopen()、fclose()、fread()、fwrite()、fseek()、ftell()等，这些函数可以进行打开、关闭、读写、定位等操作。标准I/O还支持流控制函数，如fflush()、feof()、ferror()等，用于控制流的行为。
标准I/O的缓冲机制包括全缓冲、行缓冲和不带缓冲三种模式。全缓冲模式下，输出数据会先存放在内存缓冲区中，当缓冲区满或遇到fflush()、fclose()等函数时才进行实际的写操作；行缓冲模式下，输出数据会先存放在行缓冲区中，直到缓冲区满或遇到换行符才进行实际的写操作；不带缓冲模式下，每次操作都会直接读写磁盘或其他外设，效率最低。
以下是标准IO常用的函数：
fopen()：用于打开一个文件，并返回一个指向FILE类型的指针。fclose()：用于关闭一个已打开的文件。fread()：用于从文件中读取数据。fwrite()：用于向文件中写入数据。fseek()：用于移动文件指针。ftell()：用于返回当前文件指针的位置。fflush()：用于刷新缓冲区，将缓冲区中的数据写入文件中。fprintf()：用于向文件中输出格式化的数据。fscanf()：用于从文件中读取格式化的数据。fgets()：用于从文件中读取一行数据。fputs()：用于向文件中输出一行数据。getchar()：用于从标准输入设备中读取一个字符。putchar()：用于向标准输出设备中输出一个字符。gets()：用于从标准输入设备中读取一行数据。puts()：用于向标准输出设备中输出一行数据。 在使用标准I/O时，需要注意一些问题，如缓冲区的刷新、文件位置指针的控制、文件打开模式的设置等。另外，标准I/O也存在一些缺点，如不支持并发访问、不支持定位到任意位置读写等。
文件IO 文件I/O主要通过文件描述符（File Descriptor）来实现。文件描述符是一个非负整数，用于唯一标识一个打开的文件，系统中每个进程都有一张打开文件的表格，其中每个打开的文件对应一个文件描述符。
Linux系统下的文件I/O主要包括打开文件、读取文件、写入文件、关闭文件等操作，下面分别介绍这些操作：
打开文件
在Linux系统下，可以使用open()函数来打开文件，其基本格式如下： #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; int open(const char *path, int flags, mode_t mode); 其中，path是文件路径名，flags是文件打开模式，mode是文件权限模式。flags可以是以下值的组合：
O_RDONLY：只读模式。
O_WRONLY：只写模式。
O_RDWR：读写模式。
O_CREAT：文件不存在则创建。
O_EXCL：与O_CREAT一起使用，文件存在则失败。
O_TRUNC：文件存在则截断。
O_APPEND：追加模式。
读取文件
打开文件之后，可以使用read()函数来从文件中读取数据，其基本格式如下： #include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count); 其中，fd是文件描述符，buf是读取的数据缓冲区，count是读取的字节数。如果读取成功，则返回实际读取的字节数；如果读取失败，则返回-1。
写入文件
除了读取文件，还可以使用write()函数来向文件中写入数据，其基本格式如下： #include &lt;unistd.h&gt; ssize_t write(int fd, const void *buf, size_t count); 其中，fd是文件描述符，buf是写入的数据缓冲区，count是写入的字节数。如果写入成功，则返回实际写入的字节数；如果写入失败，则返回-1。
关闭文件
在文件使用完成之后，需要使用close()函数来关闭文件，其基本格式如下： #include &lt;unistd.h&gt; int close(int fd); 其中，fd是要关闭的文件描述符。如果关闭成功，则返回0；如果关闭失败，则返回-1。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d4e30a9e3aa404f9a79a48986eed201f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-03T22:33:19+08:00" />
<meta property="article:modified_time" content="2023-05-03T22:33:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">随笔四——IO/进程和线程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="IO_0"></a>IO</h2> 
<h3><a id="IO_1"></a>标准IO</h3> 
<p>标准I/O，也称为stdio，是C语言标准库中提供的一套I/O函数，用于实现与外部设备（如终端、磁盘文件等）的输入和输出操作。标准I/O主要包括文件操作、缓冲区和流控制等方面的功能，是一套通用的、可移植的I/O接口。</p> 
<p>标准I/O的优点在于它提供了一些缓冲机制，能够有效地减少对磁盘或其他外设的I/O操作次数，提高了I/O效率。此外，标准I/O还提供了一些方便的I/O控制函数，如文件定位函数、错误处理函数等，使得文件I/O操作更加简单、高效和安全。</p> 
<p>标准I/O主要使用FILE结构体来表示文件，它包含了文件的缓冲区、文件指针、文件描述符等信息。标准I/O库中提供了许多函数来处理文件，如fopen()、fclose()、fread()、fwrite()、fseek()、ftell()等，这些函数可以进行打开、关闭、读写、定位等操作。标准I/O还支持流控制函数，如fflush()、feof()、ferror()等，用于控制流的行为。</p> 
<p>标准I/O的缓冲机制包括全缓冲、行缓冲和不带缓冲三种模式。全缓冲模式下，输出数据会先存放在内存缓冲区中，当缓冲区满或遇到fflush()、fclose()等函数时才进行实际的写操作；行缓冲模式下，输出数据会先存放在行缓冲区中，直到缓冲区满或遇到换行符才进行实际的写操作；不带缓冲模式下，每次操作都会直接读写磁盘或其他外设，效率最低。<br> 以下是标准IO常用的函数：</p> 
<ol><li>fopen()：用于打开一个文件，并返回一个指向FILE类型的指针。</li><li>fclose()：用于关闭一个已打开的文件。</li><li>fread()：用于从文件中读取数据。</li><li>fwrite()：用于向文件中写入数据。</li><li>fseek()：用于移动文件指针。</li><li>ftell()：用于返回当前文件指针的位置。</li><li>fflush()：用于刷新缓冲区，将缓冲区中的数据写入文件中。</li><li>fprintf()：用于向文件中输出格式化的数据。</li><li>fscanf()：用于从文件中读取格式化的数据。</li><li>fgets()：用于从文件中读取一行数据。</li><li>fputs()：用于向文件中输出一行数据。</li><li>getchar()：用于从标准输入设备中读取一个字符。</li><li>putchar()：用于向标准输出设备中输出一个字符。</li><li>gets()：用于从标准输入设备中读取一行数据。</li><li>puts()：用于向标准输出设备中输出一行数据。</li></ol> 
<p>在使用标准I/O时，需要注意一些问题，如缓冲区的刷新、文件位置指针的控制、文件打开模式的设置等。另外，标准I/O也存在一些缺点，如不支持并发访问、不支持定位到任意位置读写等。</p> 
<h3><a id="IO_27"></a>文件IO</h3> 
<p>文件I/O主要通过文件描述符（File Descriptor）来实现。文件描述符是一个非负整数，用于唯一标识一个打开的文件，系统中每个进程都有一张打开文件的表格，其中每个打开的文件对应一个文件描述符。</p> 
<p>Linux系统下的文件I/O主要包括打开文件、读取文件、写入文件、关闭文件等操作，下面分别介绍这些操作：</p> 
<ol><li>打开文件<br> 在Linux系统下，可以使用open()函数来打开文件，其基本格式如下：</li></ol> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中，path是文件路径名，flags是文件打开模式，mode是文件权限模式。flags可以是以下值的组合：</p> 
<p>O_RDONLY：只读模式。<br> O_WRONLY：只写模式。<br> O_RDWR：读写模式。<br> O_CREAT：文件不存在则创建。<br> O_EXCL：与O_CREAT一起使用，文件存在则失败。<br> O_TRUNC：文件存在则截断。<br> O_APPEND：追加模式。</p> 
<ol start="2"><li>读取文件<br> 打开文件之后，可以使用read()函数来从文件中读取数据，其基本格式如下：</li></ol> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中，fd是文件描述符，buf是读取的数据缓冲区，count是读取的字节数。如果读取成功，则返回实际读取的字节数；如果读取失败，则返回-1。</p> 
<ol start="3"><li>写入文件<br> 除了读取文件，还可以使用write()函数来向文件中写入数据，其基本格式如下：</li></ol> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中，fd是文件描述符，buf是写入的数据缓冲区，count是写入的字节数。如果写入成功，则返回实际写入的字节数；如果写入失败，则返回-1。</p> 
<ol start="4"><li>关闭文件<br> 在文件使用完成之后，需要使用close()函数来关闭文件，其基本格式如下：</li></ol> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中，fd是要关闭的文件描述符。如果关闭成功，则返回0；如果关闭失败，则返回-1。</p> 
<p>除了上述函数之外，Linux系统还提供了其他一些函数，用于进行文件的控制。</p> 
<ol start="5"><li>lseek() 函数<br> lseek() 函数用于设置文件的读写位置，其函数原型如下：</li></ol> 
<pre><code class="prism language-c"><span class="token class-name">off_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中，fd 是文件描述符，offset 是要设置的偏移量，whence 表示偏移量的起始位置。lseek() 函数返回设置后的偏移量，如果返回-1，则表示设置失败。</p> 
<ol start="6"><li>pread() 函数<br> pread() 函数和 read() 函数类似，但是它可以在不改变当前文件偏移量的情况下读取文件数据。其函数原型如下：</li></ol> 
<pre><code class="prism language-c"><span class="token class-name">ssize_t</span> <span class="token function">pread</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中，fd 是文件描述符，buf 是存放读取数据的缓冲区，count 是要读取的数据字节数，offset 是读取位置的偏移量。pread() 函数返回实际读取的数据字节数，如果返回-1，则表示读取失败。</p> 
<ol start="7"><li>pwrite() 函数<br> pwrite() 函数和 write() 函数类似，但是它可以在不改变当前文件偏移量的情况下写入文件数据。其函数原型如下：</li></ol> 
<pre><code class="prism language-c"><span class="token class-name">ssize_t</span> <span class="token function">pwrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中，fd 是文件描述符，buf 是要写入的数据缓冲区，count 是要写入的数据字节数，offset 是写入位置的偏移量。pwrite() 函数返回实际写入的数据字节数，如果返回-1，则写入失败。</p> 
<h2><a id="_113"></a>进程</h2> 
<p>在操作系统中，进程是指正在运行的程序的一个实例。每个进程都有自己的地址空间、堆栈、数据段、代码段等。操作系统可以同时运行多个进程，它们之间是相互独立的。进程可以与其他进程通信，共享资源，互相协作完成各自的任务。</p> 
<h3><a id="_116"></a>进程的相关概念</h3> 
<ol><li> <p>进程 ID<br> 进程 ID（PID）是用于唯一标识一个进程的数字。每个进程都有一个 PID，操作系统通过 PID 来管理进程。</p> </li><li> <p>进程控制块<br> 进程控制块（PCB）是操作系统用于管理进程的数据结构。每个进程都有一个对应的 PCB，PCB 中保存了进程的状态、优先级、程序计数器、堆栈指针等信息。</p> </li><li> <p>进程状态<br> 进程可以有多种状态，如运行态、就绪态、等待态等。进程状态的转换是由操作系统控制的，例如当一个进程在等待某个事件时，它就会进入等待态。</p> </li><li> <p>进程调度<br> 进程调度是操作系统将 CPU 分配给各个进程的过程。操作系统通过调度算法决定哪个进程应该获得 CPU 时间片。</p> </li><li> <p>进程同步<br> 多个进程之间需要相互协作完成任务，因此需要进行进程同步。进程同步的方法包括信号量、互斥锁、条件变量等。</p> </li><li> <p>进程间通信<br> 进程间通信是指不同进程之间交换数据的过程。常用的进程间通信方法包括管道、消息队列、共享内存、套接字等。</p> </li><li> <p>父子进程关系<br> 在操作系统中，每个进程都有一个父进程。一个进程可以通过系统调用 fork() 创建一个新的子进程，子进程是父进程的副本，它们共享代码段和数据段。</p> </li><li> <p>进程组和会话<br> 进程组是多个进程的集合，这些进程可以相互通信和协作。一个进程组有一个进程组 ID，每个进程组都有一个组长进程。会话是一个或多个进程组的集合，通常是由一个用户登录产生的。</p> </li><li> <p>进程信号<br> 进程信号是一种异步通信机制，用于在进程之间传递信息。进程可以向其他进程发送信号，例如终止信号、中断信号等。操作系统也可以向进程发送信号，例如 SIGKILL、SIGTERM 等。</p> </li></ol> 
<h3><a id="_145"></a>进程的相关函数</h3> 
<ol><li> <p>fork()<br> fork() 函数用于创建一个新的进程，新进程是当前进程的一个副本。在调用 fork() 之后，父进程和子进程将会并行执行，它们共享代码段和数据段，但是拥有各自独立的堆栈段和进程 ID。</p> </li><li> <p>exec()<br> exec() 函数用于在当前进程中执行一个新的程序，它将当前进程的地址空间替换为新程序的地址空间。在调用 exec() 函数之后，当前进程的代码段、数据段和堆栈段将会被新程序的代码段、数据段和堆栈段所代替。</p> </li><li> <p>wait()<br> wait() 函数用于等待子进程的结束，并获取子进程的退出状态。如果子进程已经结束，wait() 函数将立即返回子进程的退出状态。如果子进程还没有结束，wait() 函数将会阻塞当前进程，直到子进程结束。</p> </li><li> <p>exit()<br> exit() 函数用于结束当前进程的执行，并返回一个退出状态。在调用 exit() 函数之后，当前进程将会立即终止，并释放它占用的系统资源。</p> </li><li> <p>getpid()<br> getpid() 函数用于获取当前进程的进程 ID。每个进程都有一个唯一的进程 ID，用于在操作系统中标识该进程。</p> </li><li> <p>kill()<br> kill() 函数用于向其他进程发送信号。发送信号的进程需要知道被发送进程的进程 ID，以及要发送的信号类型。</p> </li><li> <p>pipe()<br> pipe() 函数用于创建一个管道，用于在两个进程之间进行通信。管道可以实现单向通信，其中一个进程将数据写入管道，另一个进程从管道中读取数据。</p> </li><li> <p>dup2()<br> dup2() 函数用于将一个文件描述符复制到另一个文件描述符上。这个函数可以用于重定向标准输入、标准输出和标准错误输出。</p> </li></ol> 
<h3><a id="_171"></a>进程间的通信</h3> 
<ol><li> <p>管道 (Pipe)<br> 管道是一种半双工的通信方式，它可以在两个相关进程之间传输数据。在 Linux 中，管道是由内核创建的，它通过文件描述符来引用。进程可以使用 pipe() 函数创建一个管道，然后使用 write() 函数将数据写入管道，另一个进程使用 read() 函数从管道中读取数据。</p> </li><li> <p>命名管道 (Named Pipe)<br> 命名管道与普通管道类似，但是它可以在不相关的进程之间进行通信。在 Linux 中，命名管道也称为 FIFO，它是一种特殊的文件类型，可以通过文件系统来访问。进程可以使用 mkfifo() 函数创建一个命名管道，然后使用 open() 函数打开管道文件，使用 read() 函数从管道中读取数据，使用 write() 函数将数据写入管道。</p> </li><li> <p>共享内存 (Shared Memory)<br> 共享内存是一种高效的 IPC 方式，它允许多个进程共享同一块内存区域。在 Linux 中，进程可以使用 shmget() 函数创建一个共享内存区域，然后使用 shmat() 函数将这个内存区域映射到进程的地址空间中。进程可以通过这个共享内存区域进行通信，读取和写入共享内存区域中的数据。</p> </li><li> <p>信号量 (Semaphore)<br> 信号量是一种用于进程同步的 IPC 方式，它可以控制多个进程对共享资源的访问。在 Linux 中，进程可以使用 semget() 函数创建一个信号量集，然后使用 semop() 函数对信号量进行操作。进程可以使用信号量来进行进程同步和互斥。</p> </li><li> <p>消息队列 (Message Queue)<br> 消息队列是一种进程间通信的方式，它可以在多个进程之间传递数据。在 Linux 中，进程可以使用 msgget() 函数创建一个消息队列，然后使用 msgsnd() 函数将消息发送到队列中，使用 msgrcv() 函数从队列中接收消息。</p> </li></ol> 
<h2><a id="_188"></a>线程</h2> 
<h3><a id="_190"></a>线程的相关概念</h3> 
<p>线程（Thread）是操作系统中能够运行并执行任务的最小单位。线程是进程中的一个实体，是 CPU 调度和分派的基本单位，一个进程可以包含多个线程，这些线程可以并发执行，共享进程资源。</p> 
<p>线程具有以下几个特点：</p> 
<p><strong>轻量级</strong>：线程是操作系统中最小的可调度单元，相比进程，线程所占用的资源更少。</p> 
<p><strong>共享进程资源</strong>：同一进程内的所有线程可以共享进程的内存空间、文件描述符、信号处理等资源。</p> 
<p><strong>独立运行</strong>：线程具有自己的调用栈、程序计数器、寄存器等执行上下文，可以独立运行。</p> 
<p><strong>并发执行</strong>：多个线程可以在同一时间并发执行，提高程序的运行效率。</p> 
<h3><a id="_202"></a>线程的相关函数</h3> 
<p>使用 pthread 库来创建和管理线程，pthread 库提供了一套函数，包括创建线程、销毁线程、线程同步、线程调度等。<br> 常用的线程函数包括：</p> 
<p>pthread_create()：创建一个新的线程。</p> 
<p>pthread_join()：等待指定的线程结束。</p> 
<p>pthread_detach()：将一个线程设置为分离状态，线程结束时自动释放资源。</p> 
<p>pthread_mutex_lock() 和 pthread_mutex_unlock()：用于保护临界区的互斥锁。</p> 
<p>pthread_cond_wait() 和 pthread_cond_signal()：用于线程之间的条件变量同步。</p> 
<h3><a id="_216"></a>线程间的通信</h3> 
<p>线程间通信是指在多线程并发执行的情况下，线程之间进行数据交换、同步操作的过程。线程间通信的方式主要有以下几种：</p> 
<ol><li> <p>共享内存：多个线程可以访问同一块共享内存，实现数据共享和通信。需要注意同步和互斥的问题，以避免数据的不一致性和竞争条件。</p> </li><li> <p>互斥锁：线程间通过互斥锁来实现对共享资源的互斥访问，保证同一时刻只有一个线程访问共享资源。</p> </li><li> <p>信号量：线程间通过信号量来实现同步和互斥操作。信号量可以用来控制多个线程的执行顺序，也可以用来限制并发访问某个资源的线程数。</p> </li><li> <p>条件变量：线程间通过条件变量来实现同步操作。条件变量可以用来等待某个特定条件的发生，从而决定线程是否继续执行。</p> </li><li> <p>管道：线程间通过管道来实现进程间通信。管道是一种半双工的通信方式，具有一定的缓冲区，可以在两个进程之间传递数据。</p> </li><li> <p>消息队列：线程间通过消息队列来实现进程间通信。消息队列是一种先进先出的数据结构，可以在多个进程之间传递消息，具有一定的缓冲区。</p> </li><li> <p>读写锁：线程间通过读写锁来实现对共享资源的读写操作，可以同时允许多个线程对共享资源进行读操作，但只允许一个线程进行写操作。</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c9adec91a2505f5716c0ac1af17aa404/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Android】串口通信的理论与使用教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1820fa09ef2f2d74bf67e431fcb77b8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度剖析记忆化搜索（非dp）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>