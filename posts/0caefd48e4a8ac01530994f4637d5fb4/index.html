<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java详细讲解OOP面向对象 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java详细讲解OOP面向对象" />
<meta property="og:description" content="简介 OOP=对象&#43;类&#43;继承&#43;多态&#43;消息，其中核心概念是类和对象。面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。
对于Java，简单来说oop就是将某种现实生活中的东西用编程语言来描述(即变成类)。
对象：现实生活中客观存在的，万物皆可为对象，是类对应的实体，不同的对象有不同或者相同的运动规律和内部属性，对象之间存在交互和复杂的关系
类：是将现实中的对象抽象成java代码世界中的类(建模)，用来封装对象的相关数据和处理这些数据的方法，当java中的一个类被创建/实例化(类--&gt;对象)后就会加载进入内存
类是抽象的，而对象是具体的，换言而之，类相当于狗，类相当于哈士奇，哈士奇是狗类。
变量 变量类似于高中数学课上定义的x或者y这样的未知数，他们的值由自己定义
类变量：static修饰的变量成员变量，可以通过类型/类名访问
实例变量：没有static修饰的成员变量，必须通过实例对象访问
成员变量：java中，成员变量是指在类体的变量部分中定义的变量，也称为属性。成员变量声明在类中，方法体之外，在创建对象时实例化；成员变量可被类中的方法、构造方法以及特定类的语句块访问。如果声明成员变量时没对其初始化，则系统会使用默认值初始化成员
全局变量：定义在类中，作用于整个类，要考虑线程安全
局部变量：定义在方法中，只作用于某一块
类中的static代码块的特点：
在类加载完成，进行初始化时执行，且整个生命周期只被执行一次，一般的可用于资源初始化，使用过数据库的一定知道DBHelper这个类，它是数据库连接类，在这个类中的第一步就是加载数据库驱动资源，其代码就写在static代码块中： 修饰符 访问修饰符 public、protected、friendly(默认)、private
作用域当前类同一包中的类子类其他包中的类public√√√√protected√√√×friendly√√××private√××× 为提高安全性，在开发过程中尽量选择较小的修饰符
abstract： 抽象修饰服，当类添加abstract修饰符不能实例化对象，是对类的建模，常用于定义公共的属性让其子类们继承。抽象类中可以写抽象方法(在方法前加入abstract)，当方法添加抽象修饰符，该方法不再具有方法体，用来规范继承该类的方法（动物都需要跑的方法，狗用四条腿跑，鸡用两条腿跑），抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类
final：最终类，不能有子类，在java中的游戏工具类会用final修饰符修饰，其目的就是为了让使用者只能直接实例化使用，不能修改和继承，常用于定义常量
封装 封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别
继承 概念：继承的英文是extends，继承在java中存在的原因是因为在现实世界中存在着事物的分类，比如“花”是一个大类，而不同品种的花就是不同的小类，小类中即有大类的相关特征又具备自己的特征
这种分类的现象中代码中被形容成了继承，即父类和子类的关系，子类可以继承父类，具备父类的方法，也可以添加自己的方法，或者重写父类的方法，方法就是现实生活中事物的各种动作、行为
作用：其重要作用就是实现多态(下面会讲)，除此之外还可以复用父类的代码，提高代码利用率
多态 概念 多态是同一个行为具有多个不同表现形式或形态的能力。
同样的类型(如动物类和狮子类，老虎类...)，因为不同的实例产生不同的行为
类之间的关系也是一种多态的体现：类的对象对同一消息作出不同的响应，这些不同类要么是继承了相同的父类，要么是实现了相同的接口
作用 解耦，各种设计模式的基础
条件 有继承或实现关系子类重写父类的方法实现同一接口使用父类或接口类型来引用子类或接口的实现类(里氏替换)，即一个父类可以继承的子类是多个的，比如人这个父类就可以继承男人，女人，按国家分就有更多了 特殊情况
static方法，因为被static修饰的方法是属于类的，而不是属于实例的，static方法可以通过类直接访问或获得final修饰的方法，不能被子类不重写private修饰的方法，对子类不可见，更不能被重写protected修饰的方法，虽然子类可见也能重写，但不能再外部引用 方法的概念 方法在现实生活中是事物的各种动作、行为，在java的世界中方法是类的行为(或者叫功能)
方法可以类比为是遥控器上的按钮，不同的按钮触发不同的控制效果
方法不能嵌套定义，即方法中不能再写方法
不能在方法体外直接写逻辑代码（static块除外）
重载（Overload） 一个类里面，方法名字相同，而参数不同，最常用的地方就是构造器的重载的好处：传入不同的方法参数，具有不同的行为。（静态多态或叫编译时多态）
重载的规则：
必须改变参数列表(参数个数或类型不一样)可以改变返回类型可以改变访问修饰符可以声明新的或更广的检查异常方法能够在同一个类中或者在一个子类中被重载无法以返回值类型作为重载函数的区分标准 重写（Override） 是子类对父类的允许访问的方法的实现过程进行重新编写，但返回值和形参都不能改变 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。（运行时多态或叫动态多态 ，继承类，实现接口也是动态多态 ）
重写的规则：
参数列表必须完全与被重写方法的相同返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（说明：java5 及更早版本返回类型要一样，java7 及更高版本可以不同）访问权限不能比父类中被重写的方法的访问权限更低，例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected父类的成员方法只能被它的子类重写声明为 final 的方法不能被重写（最终方法，不能被重写）声明为 static 的方法不能被重写，但是能够被再次声明子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法构造方法不能被重写重写的方法能够抛出任何【非强制异常】，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的【强制性异常】，或者比被重写方法声明的更广泛的【强制性异常】，反之则可以 接口 接口中所有方法均为抽象方法（jdk8之后不太合适）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0caefd48e4a8ac01530994f4637d5fb4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-20T18:55:27+08:00" />
<meta property="article:modified_time" content="2022-06-20T18:55:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java详细讲解OOP面向对象</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="java%E4%B8%ADOOP%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">简介</h2> 
<blockquote> 
 <p>OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。</p> 
 <p>对于Java，简单来说oop就是将某种现实生活中的东西用编程语言来描述(即变成类)。</p> 
</blockquote> 
<blockquote> 
 <p>对象：现实生活中客观存在的，万物皆可为对象，是类对应的实体，不同的对象有不同或者相同的运动规律和内部属性，对象之间存在交互和复杂的关系</p> 
 <p>类：是将现实中的对象抽象成java代码世界中的类(建模)，用来封装对象的相关数据和处理这些数据的方法，当java中的一个类被创建/实例化(类--&gt;对象)后就会加载进入内存</p> 
 <p>类是抽象的，而对象是具体的，换言而之，类相当于狗，类相当于哈士奇，哈士奇是狗类。</p> 
</blockquote> 
<h2>变量</h2> 
<blockquote> 
 <p>变量类似于高中数学课上定义的x或者y这样的未知数，他们的值由自己定义</p> 
 <p><strong>类变量</strong>：static修饰的变量成员变量，可以通过类型/类名访问</p> 
 <p><strong>实例变量</strong>：没有static修饰的成员变量，必须通过实例对象访问</p> 
 <p><strong>成员变量</strong>：java中，成员变量是指在类体的变量部分中定义的变量，也称为属性。成员变量声明在类中，方法体之外，在创建对象时实例化；成员变量可被类中的方法、构造方法以及特定类的语句块访问。如果声明成员变量时没对其初始化，则系统会使用默认值初始化成员</p> 
 <p><strong>全局变量</strong>：定义在类中，作用于整个类，要考虑线程安全</p> 
 <p><strong>局部变量</strong>：定义在方法中，只作用于某一块</p> 
</blockquote> 
<p><strong>类中的static代码块的特点：</strong></p> 
<blockquote> 
 <p>在类加载完成，进行初始化时执行，且整个生命周期只被执行一次，一般的可用于资源初始化，使用过数据库的一定知道DBHelper这个类，它是数据库连接类，在这个类中的第一步就是加载数据库驱动资源，其代码就写在static代码块中： <img alt="" height="654" src="https://images2.imgbox.com/32/e6/Oww4DG8y_o.png" width="1200"></p> 
</blockquote> 
<h2>修饰符</h2> 
<blockquote> 
 <h3>访问修饰符</h3> 
 <p><strong>public、protected、friendly(默认)、private</strong></p> 
 <table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:82px;">作用域</td><td style="width:76px;">当前类</td><td style="width:132px;">同一包中的类</td><td style="width:79px;">子类</td><td style="width:129px;">其他包中的类</td></tr><tr><td style="width:82px;">public</td><td style="width:76px;">√</td><td style="width:132px;">√</td><td style="width:79px;">√</td><td style="width:129px;">√</td></tr><tr><td style="width:82px;">protected</td><td style="width:76px;">√</td><td style="width:132px;">√</td><td style="width:79px;">√</td><td style="width:129px;">×</td></tr><tr><td style="width:82px;">friendly</td><td style="width:76px;">√</td><td style="width:132px;">√</td><td style="width:79px;">×</td><td style="width:129px;">×</td></tr><tr><td style="width:82px;">private</td><td style="width:76px;">√</td><td style="width:132px;">×</td><td style="width:79px;">×</td><td style="width:129px;">×</td></tr></tbody></table> 
 <p>为提高安全性，在开发过程中尽量选择较小的修饰符</p> 
</blockquote> 
<blockquote> 
 <p><strong>abstract：</strong> 抽象修饰服，当类添加abstract修饰符不能实例化对象，是对类的建模，常用于定义公共的属性让其子类们继承。抽象类中可以写抽象方法(在方法前加入abstract)，当方法添加抽象修饰符，该方法不再具有方法体，用来规范继承该类的方法（动物都需要跑的方法，狗用四条腿跑，鸡用两条腿跑）<strong>，抽象类中不一定有抽象方法，但有抽象方法的<span style="color:#fe2c24;">类</span>一定是抽象类</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>final：</strong>最终类，不能有子类，在java中的游戏工具类会用final修饰符修饰，其目的就是为了让使用者只能直接实例化使用，不能修改和继承，常用于定义常量</p> 
</blockquote> 
<h3>封装</h3> 
<blockquote> 
 <p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别</p> 
</blockquote> 
<h3>继承</h3> 
<blockquote> 
 <p><strong>概念：</strong>继承的英文是extends，继承在java中存在的原因是因为在现实世界中存在着事物的分类，比如“花”是一个大类，而不同品种的花就是不同的小类，小类中即有大类的相关特征又具备自己的特征</p> 
 <p>这种分类的现象中代码中被形容成了继承，即父类和子类的关系，子类可以继承父类，具备父类的方法，也可以添加自己的方法，或者重写父类的方法，方法就是现实生活中事物的各种动作、行为</p> 
 <p><strong>作用：</strong>其重要作用就是实现<strong>多态</strong>(下面会讲)，除此之外还可以复用父类的代码，提高代码利用率</p> 
</blockquote> 
<h3>多态</h3> 
<blockquote> 
 <h4>概念</h4> 
 <p>多态是同一个行为具有多个不同表现形式或形态的能力。</p> 
 <p>同样的类型(如动物类和狮子类，老虎类...)，因为不同的实例产生不同的行为</p> 
 <p>类之间的关系也是一种多态的体现：类的对象对同一消息作出不同的响应，这些不同类要么是继承了相同的父类，要么是实现了相同的接口</p> 
 <h4>作用</h4> 
 <p>解耦，各种设计模式的基础</p> 
 <h4>条件</h4> 
 <ol><li><strong>有继承或实现关系</strong></li><li><strong>子类重写父类的方法</strong></li><li><strong>实现同一接口</strong></li><li><strong>使用父类或接口类型来引用子类或接口的实现类(里氏替换)，即一个父类可以继承的子类是多个的，比如人这个父类就可以继承男人，女人，按国家分就有更多了</strong></li></ol> 
 <p>特殊情况</p> 
 <ul><li>static方法，因为被static修饰的方法是属于类的，而不是属于实例的，static方法可以通过类直接访问或获得</li><li>final修饰的方法，不能被子类不重写</li><li>private修饰的方法，对子类不可见，更不能被重写</li><li>protected修饰的方法，虽然子类可见也能重写，但不能再外部引用</li></ul> 
</blockquote> 
<blockquote> 
 <h4>方法的概念</h4> 
 <p>方法在现实生活中是事物的各种动作、行为，在java的世界中方法是类的行为(或者叫功能)</p> 
 <p>方法可以类比为是遥控器上的按钮，不同的按钮触发不同的控制效果</p> 
 <p>方法不能嵌套定义，即方法中不能再写方法</p> 
 <p><strong>不能在方法体外直接写逻辑代码（static块除外）</strong></p> 
</blockquote> 
<blockquote> 
 <h4>重载（Overload）</h4> 
 <p>一个类里面，<strong>方法名字相同，而参数不同</strong>，最常用的地方就是构造器的<strong>重载的好处：</strong>传入不同的方法参数，具有不同的行为。（<strong>静态多态或叫编译时多态</strong>）</p> 
 <p><strong>重载的规则：</strong></p> 
 <ul><li>必须改变参数列表(参数个数或类型不一样)</li><li>可以改变返回类型</li><li>可以改变访问修饰符</li><li>可以声明新的或更广的检查异常</li><li>方法能够在同一个类中或者在一个子类中被重载</li><li>无法以返回值类型作为重载函数的区分标准</li></ul> 
</blockquote> 
<blockquote> 
 <h4><strong>重写（Override）</strong></h4> 
 <p>是子类对父类的允许访问的<strong>方法</strong>的实现过程进行<strong>重新编写</strong>，但返回值和形参都不能改变 </p> 
 <p><strong>重写的好处</strong>在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。（<strong>运行时多态或叫动态多态 ，</strong><strong>继承类，实现接口也是动态多态 </strong>）</p> 
 <p>重写的规则：</p> 
 <ul><li>参数列表必须完全与被重写方法的相同</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（说明：java5 及更早版本返回类型要一样，java7 及更高版本可以不同）</li><li>访问权限不能比父类中被重写的方法的访问权限更低，例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected</li><li>父类的成员方法只能被它的子类重写</li><li>声明为 final 的方法不能被重写（最终方法，不能被重写）</li><li>声明为 static 的方法不能被重写，但是能够被再次声明</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法</li><li>构造方法不能被重写</li><li>重写的方法能够抛出任何【非强制异常】，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的【强制性异常】，或者比被重写方法声明的更广泛的【强制性异常】，反之则可以</li></ul> 
</blockquote> 
<h3>接口</h3> 
<blockquote> 
 <p>接口中所有方法均为抽象方法（jdk8之后不太合适）</p> 
 <p>接口不可实例化，jdk8：接口支持申明带<strong>实现</strong>的方法，关键字（default ） </p> 
 <p>类只能单一继承，但可以实现多个接口</p> 
 <p>可以将接口理解为职责或契约，用于<strong>树立规范</strong></p> 
 <p>接口是对行为的建模，也是多态的体现</p> 
</blockquote> 
<h3 id="5%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB">异常</h3> 
<blockquote> 
 <p><strong>强制异常（或叫受检异常）Exception，即该异常报出时有解决的方式，开发人员捕获后可以解决</strong></p> 
 <p><strong>非强制异常（或叫非受检异常）RuntimeException</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>异常抛出的方式</strong></p> 
 <ul><li>try-catch-finally</li><li>throw、throws：用于抛出异常实例，在方法定义中声明该方法可能抛出的异常，如果异常为强制异常则方法调用者必须trycatch捕获或者继续抛出</li></ul> 
</blockquote> 
<p><strong>常见的异常</strong></p> 
<table align="left" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th style="width:228px;">方法名</th><th style="width:270px;">说明</th></tr></thead><tbody><tr><td style="width:228px;">Exception</td><td style="width:270px;">异常层级结构的根类</td></tr><tr><td style="width:228px;">ArithmeticException</td><td style="width:270px;">算数异常情形,如以零为除数</td></tr><tr><td style="width:228px;">ArrayIndexOutOfBoundsException</td><td style="width:270px;">数组下标越界</td></tr><tr><td style="width:228px;">NullPointerException</td><td style="width:270px;">尝试访问null对象成员</td></tr><tr><td style="width:228px;">ClassNotFoundException</td><td style="width:270px;">不能加载所需的类</td></tr><tr><td style="width:228px;">InputMismatchException</td><td style="width:270px;">欲得到数据类型与实际输入类型不匹配</td></tr><tr><td style="width:228px;">IllegalArgumentException</td><td style="width:270px;">方法接收到非法参数</td></tr><tr><td style="width:228px;">ClassCastException</td><td style="width:270px;">对象强制类型转换出错</td></tr><tr><td style="width:228px;">NumberFormatException</td><td style="width:270px;">数字格式转换异常,如把“abc”转换成数字</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e7f4de8a8cfc9e4909d667c59fd91f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2022年T电梯修理考试题库及在线模拟考试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b0d483dfbca4689b66c4e6474451dc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot或者springsecurity跨域问题 ---简单有效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>