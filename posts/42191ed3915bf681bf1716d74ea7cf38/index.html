<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数组的顺序存储 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数组的顺序存储" />
<meta property="og:description" content="数组作为一种线性存储结构，对存储的数据通常只做查找和修改操作，因此数组结构的实现使用的是顺序存储结构。
要知道，对数组中存储的数据做插入和删除操作，算法的效率是很差的。
由于数组可以是多维的，而顺序存储结构是一维的，因此数组中数据的存储要制定一个先后次序。通常，数组中数据的存储有两种先后存储方式：
以列序为主（先列后行）：按照行号从小到大的顺序，依次存储每一列的元素以行序为主（先行后序）：按照列号从小到大的顺序，依次存储每一行的元素。 多维数组中，我们最常用的是二维数组。比如说，当二维数组 a[6][6] 按照列序为主的次序顺序存储时，数组在内存中的存储状态如图 1 所示：
图 1 以列序为主的二维数组存储状态
同样，当二维数组 a[6][6] 按照行序为主的次序顺序存储时，数组在内存中的存储状态如图 2 所示：
图 2 以行序为主的二维数组存储状态
C 语言中，多维数组的存储采用的是以行序为主的顺序存储方式。
通过以上内容，我们掌握了将多维数组存储在一维内存空间的方法。那么，后期如何对指定的数据进行查找和修改操作呢？
多维数组查找指定元素 当需要在顺序存储的多维数组中查找某个指定元素时，需知道以下信息：
多维数组的存储方式；多维数组在内存中存放的起始地址；该指定元素在原多维数组的坐标（比如说，二维数组中是通过行标和列标来表明数据元素的具体位置的）；数组中数组的具体类型，即数组中单个数据元素所占内存的大小，通常用字母 L 表示； 根据存储方式的不同，查找目标元素的方式也不同。如果二维数组采用以行序为主的方式，则在二维数组 anm 中查找 aij 存放位置的公式为：
LOC(i,j) = LOC(0,0) &#43; (i*m &#43; j) * L;
其中，LOC(i,j) 为 aij 在内存中的地址，LOC(0,0) 为二维数组在内存中存放的起始位置（也就是 a00 的位置）。
而如果采用以列存储的方式，在 anm 中查找 aij 的方式为：
LOC(i,j) = LOC(0,0) &#43; (i*n &#43; j) * L;
数组定义和运算
① 数组是高级语言一般都支持的数据类型，这里学习数组在计算机内部如何处理，主要是存取，地址计算；
② 从逻辑结构上看，数组可以看成是一般线性表的扩充。
二维数组视作线性表" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/42191ed3915bf681bf1716d74ea7cf38/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-29T21:21:02+08:00" />
<meta property="article:modified_time" content="2023-04-29T21:21:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数组的顺序存储</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>数组作为一种线性存储结构，对存储的数据通常只做查找和修改操作，因此数组结构的实现使用的是顺序存储结构。</p> 
<p>要知道，对数组中存储的数据做插入和删除操作，算法的效率是很差的。</p> 
<p>由于数组可以是多维的，而顺序存储结构是一维的，因此数组中数据的存储要制定一个先后次序。通常，数组中数据的存储有两种先后存储方式：</p> 
<ol><li>以列序为主（先列后行）：按照行号从小到大的顺序，依次存储每一列的元素</li><li>以行序为主（先行后序）：按照列号从小到大的顺序，依次存储每一行的元素。</li></ol> 
<p><br> 多维数组中，我们最常用的是二维数组。比如说，当二维数组 a[6][6] 按照列序为主的次序顺序存储时，数组在内存中的存储状态如图 1 所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/af/fa/gl6CRMVq_o.png"></p> 
<p><br> 图 1 以列序为主的二维数组存储状态</p> 
<p><br> 同样，当二维数组 a[6][6] 按照行序为主的次序顺序存储时，数组在内存中的存储状态如图 2 所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8f/52/BakB2Huj_o.png"></p> 
<p><br> 图 2 以行序为主的二维数组存储状态</p> 
<p>C 语言中，多维数组的存储采用的是以行序为主的顺序存储方式。</p> 
<p>通过以上内容，我们掌握了将多维数组存储在一维内存空间的方法。那么，后期如何对指定的数据进行查找和修改操作呢？</p> 
<h3>多维数组查找指定元素</h3> 
<p>当需要在顺序存储的多维数组中查找某个指定元素时，需知道以下信息：</p> 
<ul><li>多维数组的存储方式；</li><li>多维数组在内存中存放的起始地址；</li><li>该指定元素在原多维数组的坐标（比如说，二维数组中是通过行标和列标来表明数据元素的具体位置的）；</li><li>数组中数组的具体类型，即数组中单个数据元素所占内存的大小，通常用字母 L 表示；</li></ul> 
<p><br> 根据存储方式的不同，查找目标元素的方式也不同。如果二维数组采用以行序为主的方式，则在二维数组 anm 中查找 aij 存放位置的公式为：</p> 
<p>LOC(i,j) = LOC(0,0) + (i*m + j) * L;</p> 
<p>其中，LOC(i,j) 为 aij 在内存中的地址，LOC(0,0) 为二维数组在内存中存放的起始位置（也就是 a00 的位置）。<br><br> 而如果采用以列存储的方式，在 anm 中查找 aij 的方式为：</p> 
<p>LOC(i,j) = LOC(0,0) + (i*n + j) * L;</p> 
<p><strong>数组定义和运算</strong><br> ① 数组是高级语言一般都支持的数据类型，这里学习数组在计算机内部如何处理，主要是存取，地址计算；<br> ② 从逻辑结构上看，数组可以看成是一般线性表的扩充。</p> 
<p><span style="color:#fe2c24;">二维数组视作线性表</span><br> ① 把矩阵Am×n看成n个列向量的线性表：<br> A=(α1,α2…αj…αn),<br> αj=(a1j,a2j, …,amj),(1 ≤ j ≤ n)本身也是一个线性表，称为列向量。</p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/76/ab/ENrMucjH_o.png" width="677"><br> ②把矩阵Am×n看成m个行向量的线性表：<br> B=(β1,β2, ...βi…,βm),<br> βi = (ai1, ai2, …, aij, …, ain),(1 ≤ i≤ m)称为行向量。</p> 
<p> <img alt="" height="306" src="https://images2.imgbox.com/b4/2c/blVFb25P_o.png" width="679"></p> 
<p> <br> 高维数组<br> 同理，嵌套（或降维）思路。<br> 三维数组：每个元素为二维数组的线性表。<br> N维数据：每个元素为N-1维数据的线性表。</p> 
<p>数组运算<br> ① 数组是一组有固定个数的元素的集合。<br> 维数、每维上下限确定，元素个数就确定，使得对数组的操作不象对线性表的操作那样，可以在表中任意一个合法的位置插入或删除一个元素。<br> ② 数组操作一般只有两类：<br> 取值：获得特定位置的元素值；<br> 修改：修改特定位置的元素值。<br> PS：数组的抽象数据类型定义数组下标从1开始，与C语言不同。</p> 
<p>数组的顺序存储和实现<br> 数组的顺序存储结构有两种：<br> 一种是按行序存储，如高级语言BASIC、COBOL、PASCAL和C语言都是以行序为主。<br> 另一种是按列序存储，如高级语言中的FORTRAN语言就是以列序为主。</p> 
<p>二维数组略（见前）。</p> 
<p>三维数组：可行纵列为主序存储，如A3×4×2逻辑结构图：</p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/90/c1/P84m0hvO_o.png" width="543"></p> 
<p></p> 
<p>数组地址计算：<br> 元素地址 = 首元素地址 + 偏移量（与首距离）<br> 偏移量 = 间隔元素个数 x size（单元素空间）</p> 
<p>一维数组：<br> Loc(A[i])=Loc(A[i])+(i-1)*size.</p> 
<p>二维数组：<br> 行存储二维数组Am×n，下标从1开始，任意元素aij的地址<br> Loc[i,j]=Loc[1,1]+(n×(i-1)+j-1)×size，每个元素占size个存储单元，每个元素占1个存储单元 Loc[i,j]=Loc[1,1]+n×(i-1)+(j-1)。</p> 
<p><img alt="" height="333" src="https://images2.imgbox.com/59/d1/GAXFc8F1_o.png" width="792"><br> 三维数组：<br> 三维数组A(1..r,1..m,1..n)可以看成是r个m×n的二维数组。</p> 
<p> <img alt="" height="270" src="https://images2.imgbox.com/a1/7b/KnQcuqSB_o.png" width="474"></p> 
<p> </p> 
<p>假定每个元素占1个存储单元，行主序存放，首元素a111地址为Loc[1][1][1]<br> ai11地址：<br> Loc[i][1][1] = Loc[1][1][1] + (i-1)*m*n ，<br> aijk地址：<br> Loc[i][j][k] = Loc[1][1][1] + (i-1)*m*n + (j-1)*n+(k-1)<br> 其中1≤i≤r,1≤j≤ｍ,1≤k≤ｎ。</p> 
<p>代码实现：</p> 
<p>以下给出了采用以行序为主的方式存储三维数组 a[3][4][2] 的 C 语言代码实现，这里不再对该代码进行分析（代码中有详细注释），有兴趣的读者可以自行拷贝运行：</p> 
<blockquote> 
 <pre>#include&lt;stdarg.h&gt;
#include&lt;malloc.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt; // atoi()
#include&lt;io.h&gt; // eof()
#include&lt;math.h&gt;

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW 3
#define UNDERFLOW 4
typedef int Status; //Status是函数的类型,其值是函数结果状态代码，如OK等
typedef int Boolean; //Boolean是布尔类型,其值是TRUE或FALSE
typedef int ElemType;

#define MAX_ARRAY_DIM 8 //假设数组维数的最大值为8
typedef struct
{
    ElemType *base; //数组元素基址，由InitArray分配
    int dim; //数组维数
    int *bounds; //数组维界基址，由InitArray分配
    int *constants; // 数组映象函数常量基址，由InitArray分配
} Array;

Status InitArray(Array *A,int dim,...)
{
    //若维数dim和各维长度合法，则构造相应的数组A，并返回OK
    int elemtotal=1,i; // elemtotal是元素总值
    va_list ap;
    if(dim&lt;1||dim&gt;MAX_ARRAY_DIM)
        return ERROR;
    (*A).dim=dim;
    (*A).bounds=(int *)malloc(dim*sizeof(int));
    if(!(*A).bounds)
        exit(OVERFLOW);
    va_start(ap,dim);
    for(i=0; i&lt;dim; ++i)
    {
        (*A).bounds[i]=va_arg(ap,int);
        if((*A).bounds[i]&lt;0)
            return UNDERFLOW;
        elemtotal*=(*A).bounds[i];
    }
    va_end(ap);
    (*A).base=(ElemType *)malloc(elemtotal*sizeof(ElemType));
    if(!(*A).base)
        exit(OVERFLOW);
    (*A).constants=(int *)malloc(dim*sizeof(int));
    if(!(*A).constants)
        exit(OVERFLOW);
    (*A).constants[dim-1]=1;
    for(i=dim-2; i&gt;=0; --i)
        (*A).constants[i]=(*A).bounds[i+1]*(*A).constants[i+1];
    return OK;
}
Status DestroyArray(Array *A)
{
    //销毁数组A
    if((*A).base)
    {
        free((*A).base);
        (*A).base=NULL;
    }
    else
        return ERROR;
    if((*A).bounds)
    {
        free((*A).bounds);
        (*A).bounds=NULL;
    }
    else
        return ERROR;
    if((*A).constants)
    {
        free((*A).constants);
        (*A).constants=NULL;
    }
    else
        return ERROR;
    return OK;
}
Status Locate(Array A,va_list ap,int *off) // Value()、Assign()调用此函数 */
{
    //若ap指示的各下标值合法，则求出该元素在A中的相对地址off
    int i,ind;
    *off=0;
    for(i=0; i&lt;A.dim; i++)
    {
        ind=va_arg(ap,int);
        if(ind&lt;0||ind&gt;=A.bounds[i])
            return OVERFLOW;
        *off+=A.constants[i]*ind;
    }
    return OK;
}
Status Value(ElemType *e,Array A,...)  
{
    //依次为各维的下标值，若各下标合法，则e被赋值为A的相应的元素值
    va_list ap;
    Status result;
    int off;
    va_start(ap,A);
    if((result=Locate(A,ap,&amp;off))==OVERFLOW) //调用Locate()
        return result;
    *e=*(A.base+off);
    return OK;
}
Status Assign(Array *A,ElemType e,...)
{
    //依次为各维的下标值，若各下标合法，则将e的值赋给A的指定的元素
    va_list ap;
    Status result;
    int off;
    va_start(ap,e);
    if((result=Locate(*A,ap,&amp;off))==OVERFLOW) //调用Locate()
        return result;
    *((*A).base+off)=e;
    return OK;
}

int main()
{
    Array A;
    int i,j,k,*p,dim=3,bound1=3,bound2=4,bound3=2; //a[3][4][2]数组
    ElemType e,*p1;
    InitArray(&amp;A,dim,bound1,bound2,bound3); //构造3＊4＊2的3维数组A
    p=A.bounds;
    printf("A.bounds=");
    for(i=0; i&lt;dim; i++) //顺序输出A.bounds
        printf("%d ",*(p+i));
    p=A.constants;
    printf("\nA.constants=");
    for(i=0; i&lt;dim; i++) //顺序输出A.constants
        printf("%d ",*(p+i));
    printf("\n%d页%d行%d列矩阵元素如下:\n",bound1,bound2,bound3);
    for(i=0; i&lt;bound1; i++)
    {
        for(j=0; j&lt;bound2; j++)
        {
            for(k=0; k&lt;bound3; k++)
            {
                Assign(&amp;A,i*100+j*10+k,i,j,k); // 将i*100+j*10+k赋值给A[i][j][k]
                Value(&amp;e,A,i,j,k); //将A[i][j][k]的值赋给e
                printf("A[%d][%d][%d]=%2d ",i,j,k,e); //输出A[i][j][k]
            }
            printf("\n");
        }
        printf("\n");
    }
    p1=A.base;
    printf("A.base=\n");
    for(i=0; i&lt;bound1*bound2*bound3; i++) //顺序输出A.base
    {
        printf("%4d",*(p1+i));
        if(i%(bound2*bound3)==bound2*bound3-1)
            printf("\n");
    }
    DestroyArray(&amp;A);
    return 0;
}</pre> 
</blockquote> 
<p>运行结果为：</p> 
<p>A.bounds=3 4 2<br> A.constants=8 2 1<br> 3页4行2列矩阵元素如下:<br> A[0][0][0]= 0 A[0][0][1]= 1<br> A[0][1][0]=10 A[0][1][1]=11<br> A[0][2][0]=20 A[0][2][1]=21<br> A[0][3][0]=30 A[0][3][1]=31<br><br> A[1][0][0]=100 A[1][0][1]=101<br> A[1][1][0]=110 A[1][1][1]=111<br> A[1][2][0]=120 A[1][2][1]=121<br> A[1][3][0]=130 A[1][3][1]=131<br><br> A[2][0][0]=200 A[2][0][1]=201<br> A[2][1][0]=210 A[2][1][1]=211<br> A[2][2][0]=220 A[2][2][1]=221<br> A[2][3][0]=230 A[2][3][1]=231<br><br> A.base=<br>    0   1  10  11  20  21  30  31<br> 100 101 110 111 120 121 130 131<br> 200 201 210 211 220 221 230 231</p> 
<p></p> 
<p>参考：</p> 
<p><a href="https://blog.csdn.net/HLXchamp/article/details/105357166" title="数组的定义与存储顺序_数组的顺序存储_HLXchamp的博客-CSDN博客">数组的定义与存储顺序_数组的顺序存储_HLXchamp的博客-CSDN博客</a></p> 
<p><a href="http://c.biancheng.net/view/3368.html" rel="nofollow" title="数组的顺序存储（C语言版）">数组的顺序存储（C语言版）</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6bfc6a28ffbb5355d6921dcad0d2706b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【QT上位机编写第一步】QT5环境搭建和了解C&#43;&#43;及类的运用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb64ac857d31f19340c1563bafb4dc6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">天启词典 5.4 英汉版（Free Edition）发布</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>