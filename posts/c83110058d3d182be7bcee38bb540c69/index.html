<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>cocos2dx 3.12 各平台资源加密解密 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="cocos2dx 3.12 各平台资源加密解密" />
<meta property="og:description" content="前言，一般项目发包基本会加密 lua代码，图片资源，现在3.12自带一套加密解密流程，但是这套加密流程只适用于lua代码解密，现在需要对框架进行修改，从而可以解密图片资源。
准备，首先要想好自己的加密解密的密钥 和 文件头签名。 {
如: String key = &#34;KEY_FOR_ENCRYPT_OR_DECRYPT&#34;; String Sign = &#34;SIGN_FOR_ENCRYPT_OR_DECRYPT&#34;; }
一 加密流程，先将lua代码和图片资源进行加密，可以写批处理方法，使用刚才想好的密钥和签名调用cocos2d-x/external/xxtea/xxtea.cpp里面的加密方法(这个加密方法可以改成我们自己的, 同理解密也可改)。将需要加密的lua代码和图片资源进行加密即可。最好可以批处理文件。(注：函数参数不用去改它的) 二 cocos2dx 解密流程
1，首先要在Classes/AppDelegate.cpp里面设置解密密钥
applicationDidFinishLaunching(){ ... LuaStack* stack = engine-&gt;getLuaStack(); String key = &#34;加密Key&#34;; //想好的密钥 String Sign = &#34;文件头签名&#34;; //想好的签名 stack-&gt;setXXTEAKeyAndSign(key, strlen(key), Sign, strlen(Sign)); ... } 实际上就是将密钥和签名设置进去了CCLuaStack，可以用这些去解密lua文件代码 ，如下 （注：如果不做图片的加密，这一步做完lua代码的解密就已经完成了） 2，可以看下lua自带的代码解密流程，实际上就是加载Lua代码的时候CCLuaStack调用CCFileUtil去调用各个平台的FileUtil的GetContens函数，获取文件内容buff，然后在CCLuaStack里面在调用LoadBuff()将解密后的内容buff进行加载的解密流程 (此过程cocos2d 3.12已经自带，所以文章开头说lua代码可以做到自动解密) 如下：
CCLuaStack.cpp int LuaStack::executeScriptFile(const char* filename) { ... //调用各平台的获取文件Utils FileUtils *utils = FileUtils::getInstance(); std::string fullPath = utils-&gt;fullPathForFilename(filename); ... //拿到了文件的**内容buff**, data Data data = utils-&gt;getDataFromFile(fullPath); int rn = 0; if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c83110058d3d182be7bcee38bb540c69/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-22T11:19:37+08:00" />
<meta property="article:modified_time" content="2016-12-22T11:19:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">cocos2dx 3.12 各平台资源加密解密</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>前言，一般项目发包基本会加密 <strong>lua代码</strong>，<strong>图片资源</strong>，现在3.12自带一套加密解密流程，但是这套加密流程只适用于lua代码解密，现在需要对框架进行修改，从而可以解密图片资源。</p> 
<p>准备，首先要想好自己的加密解密的<strong>密钥</strong> 和 <strong>文件头签名</strong>。 <br> {<!-- --></p> 
<pre><code>如: 
String key = "KEY_FOR_ENCRYPT_OR_DECRYPT";
String Sign = "SIGN_FOR_ENCRYPT_OR_DECRYPT";
</code></pre> 
<p>}</p> 
<p>一 <strong>加密流程，先将lua代码和图片资源进行加密，可以写批处理方法，使用刚才想好的密钥和签名调用cocos2d-x/external/xxtea/xxtea.cpp里面的加密方法(这个加密方法可以改成我们自己的, 同理解密也可改)。将需要加密的lua代码和图片资源进行加密即可。最好可以批处理文件。(注：函数参数不用去改它的)</strong> <br> <img src="https://images2.imgbox.com/66/35/JIXaHJna_o.png" alt="这里写图片描述" title=""></p> 
<p>二 <strong>cocos2dx 解密流程</strong></p> 
<p>1，首先要在Classes/AppDelegate.cpp里面设置解密密钥</p> 
<pre><code>applicationDidFinishLaunching(){

...

LuaStack* stack = engine-&gt;getLuaStack();
String key = "加密Key"; //想好的密钥
String Sign = "文件头签名"; //想好的签名
stack-&gt;setXXTEAKeyAndSign(key, strlen(key), Sign, strlen(Sign));

...
}  

实际上就是将密钥和签名设置进去了CCLuaStack，可以用这些去解密lua文件代码 ，如下
</code></pre> 
<p><img src="https://images2.imgbox.com/c0/b1/bFuYr0mi_o.png" alt="这里写图片描述" title=""></p> 
<pre><code>（注：如果不做图片的加密，这一步做完lua代码的解密就已经完成了）
</code></pre> 
<p>2，可以看下lua自带的代码解密流程，实际上就是加载Lua代码的时候CCLuaStack调用CCFileUtil去调用各个平台的FileUtil的GetContens函数，获取文件<strong>内容buff</strong>，然后在CCLuaStack里面在调用LoadBuff()将解密后的<strong>内容buff</strong>进行加载的解密流程 (此过程cocos2d 3.12已经自带，所以文章开头说lua代码可以做到自动解密) 如下：</p> 
<pre><code>CCLuaStack.cpp
int LuaStack::executeScriptFile(const char* filename)
{ 
    ...

    //调用各平台的获取文件Utils
    FileUtils *utils = FileUtils::getInstance();

    std::string fullPath = utils-&gt;fullPathForFilename(filename);

    ...
    //拿到了文件的**内容buff**, data
    Data data = utils-&gt;getDataFromFile(fullPath);
    int rn = 0;

    if (!data.isNull()) { 
        //**luaLoadBuffer**此函数就是lua解密函数
        if (luaLoadBuffer(_state, (const char*)data.getBytes(), (int)data.getSize(), fullPath.c_str()) == 0) {
            rn = executeFunction(0);
        }
    }
    return rn;
} 
</code></pre> 
<p>lualoadBuffer如下，红线圈的部分就是解密过程，调用了我们在AppDelegate.cpp设置的密钥进行<strong>内容buff</strong>的解密，当然，只有判断出文件头是我们设置的签名才会进入这个函数进行解密，其他没加密的文件走else里面的语句，直接加载lua代码 <br> <img src="https://images2.imgbox.com/b9/b6/HNkWnPvk_o.png" alt="这里写图片描述" title=""></p> 
<p>3, 接下来我们想让图片也支持解密，同理，我们可以通过lua解密加载流程推测出 加载图片的时候，肯定会调用FileUtil里面的GetContents获取文件的<strong>内容buff</strong>，然后通过<strong>内容buff</strong>进行图片的加载。那么我们需要做的就是-&gt;找到获取这个<strong>图片内容buff</strong>加载的地方（修改各个平台的调用函数），判断如果是加密过的<strong>内容buff</strong>那么就将<strong>内容buff</strong>解密了，然后在return回去，binggo！</p> 
<pre><code>想要获取图片加载 “内容buff” 的流程，我们可以在从Sprite::create打个断点，一步步跟下去，看看堆栈过程。

... 

最终可以发现堆栈过程
FileUtilsWin32::getContents
Image::initWithImageFile
TextureCache::addImage
Sprite::initWithFile
Sprite::create 

... 

那么可以总结:
CCImages的initWithImageFile()函数
CCImages的initWithImageFileThreadSafe()函数
上面两个是加载图片读取文件内容buff的

还有另外一个CCFileutils里面的getValueMapFromFile()读取文件字典(plist等)
即是CCSAXParser.cpp里面的parse()函数读取内容buff来加载plsit
...

因此我们只需要将上面的3个函数加点料，即可实现解密 - -!

...
</code></pre> 
<p><strong>4，CCImages的修改如下 (图片加载文件地方)</strong> <br> 先包含头文件: <br> <img src="https://images2.imgbox.com/7e/c1/O6eWaB0a_o.png" alt="这里写图片描述" title=""> <br> 然后修改initWithImageFile()函数 <br> <img src="https://images2.imgbox.com/53/3d/gn5TKKzo_o.png" alt="这里写图片描述" title=""> <br> 然后修改initWithImageFileThreadSafe()函数 <br> <img src="https://images2.imgbox.com/b2/04/jEL2m6Nn_o.png" alt="这里写图片描述" title=""></p> 
<p><strong>5, CCSAXParser.cpp的修改（字典类文件读取地方）</strong> <br> <img src="https://images2.imgbox.com/06/d5/L1KePTDk_o.png" alt="这里写图片描述" title=""></p> 
<p><strong>6, CCBundle3D.cpp的修改（.c3b文件读取地方）</strong> <br> <img src="https://images2.imgbox.com/8d/2d/j8cFtfgB_o.png" alt="这里写图片描述" title=""></p> 
<p><strong>7, CCFileUtil.cpp的修改（.json文件读取地方，所有getStringFromFile需要解密的地方）</strong> <br> <img src="https://images2.imgbox.com/57/6a/GffZ3Ez9_o.png" alt="这里写图片描述" title="" style="outline: red dashed 1px;"></p> 
<p><strong>总结：</strong>至此图片解密也可以做到啦，其他粒子特效，图集文件，字体文件…. …. 的加密，是否可以通过找到加载文件<strong>内容buff</strong>的地方，然后对这个<strong>内容buff</strong>修改而达到解密的目的呢，留给大家去猜想和试探了！啊哈哈哈哈</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5532b421d495b8dcd2691515962565b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">某餐厅在线服务APP涉众识别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f75f50b59351580b188047553f1c8940/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TensorFlow的卷积神经网络例子解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>