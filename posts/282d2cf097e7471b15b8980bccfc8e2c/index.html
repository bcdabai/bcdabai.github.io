<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java中面向对象（OOP）基础概念 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java中面向对象（OOP）基础概念" />
<meta property="og:description" content="本文连接：https://blog.csdn.net/MDWJJ/article/details/105820938
什么是对象
1.软件系统中的事物个体也称为业务实体，一切皆对象
2.每个对象包含一组数据和相关的操作方法
类：将对象的公共属性和行为抽取到定义类中，可以作为模板复用创建对象
实例化：利用类创建对象的过程称为实例化
构造器：用于封装对象属性实例化过程，创建对象时调用
语法:
1.在类中声明，方法名与类名一致
2.不能有返回值，不能使用void
3.可以有参数，用来实例化对象
4.使用new运算调用构造器，创建对象
5.如果类不定义构造器，Java编译器会自动提默认供构造器；如果类定构造器，Java编译器就不会提供默认构造器
6.构造器重载用于实现：对象有多种数据初始化方式
引用
1.也称为引用变量，Java中除了基本类型变量其他都是引用类型变量
2.用于操作对象的“句柄handle”
3.应用变量中存储了对象的首地址，利用收地址间接操作内存对象
4.简单说：引用用于操作对象
5.Java自动维护引用的地址，对外不可见，屏蔽了平台差异（跨平台）
面向对象的3个重要概念
1.封装：将数据以及算法尽可能隐藏到类的内部，只暴露必要的操作方法和数据
2.继承：复用，利用父类复用子类中公共属性和方法，将子类公共属性很方法“泛化”到父类中（画图子类箭头指向父类）。泛化：将子类的公共属性和方法抽取到父类的过程称为泛化。
3.多态：父类型变量引用的子类型个体是多种多样的，使用子类型方法的时候其功能也是多种多样的
重载
1.在类中（包含父类）定义的方法名一样参数（个数、顺序）不同的方法
2.一般这些的方法封装的算法（方法体）都不相同
3.只是为了表示设计的优雅而将方法名定义为一样
4.调用方法时候，根据方法名和参数列表 识别调用哪个方法。
如果参数不相同，Java会尝试自动转换类型
方法签名
方法名&#43;参数类型列表 = 方法签名 this 引用
this 引用当前的这个对象
1.this 用于区别方法（构造器）中的局部变量和实例变量
2.当方法中局部变量和实例变量同名的时候，可以使用this.实例变量与局部变量加以区分
3.当实例变量名和局部变量名没有冲突，可以省略this
局部变量：方法的参数是局部变量
this()用于调用当前类的其他构造器
1.其目的是为了将构造器的逻辑进行复用
(a) 多个构造器使用一个初始化逻辑
2.this()只能在构造器使用
3.this()写在构造器的第一行
继承
子类可以继承（获得）父类中的属性和方法。子类无需声明就可以获得父类中的属性和方法。
利用“泛化”实现继承！ 泛化：将对象相同的属性进行抽象同一的过程称为泛化
继承语法：
1.使用extends实现继承
2.被继承者是父类（超类super class）中的属性和方法被子类继承
3.继承者是子类
4.Java是单继承语言
5.如果没有父类，则自动继承于Object 类型
重写：
1.在子类中修改从父类中继承的方法
在子类中定义一个与父类型具有相同“方法签名（方法名&#43;参数类型列表）”的方法 2.能够继承的方法才能重写
语法：子类定义一与父类“一样”的方法
a)方法名一样；
b)参数一样" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/282d2cf097e7471b15b8980bccfc8e2c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-28T18:35:14+08:00" />
<meta property="article:modified_time" content="2020-04-28T18:35:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java中面向对象（OOP）基础概念</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文连接：<a href="https://blog.csdn.net/MDWJJ/article/details/105820938">https://blog.csdn.net/MDWJJ/article/details/105820938</a></p> 
<p><strong>什么是对象</strong><br>   1.软件系统中的事物个体也称为业务实体，一切皆对象<br>   2.每个对象包含一组数据和相关的操作方法</p> 
<p><strong>类</strong>：将对象的公共属性和行为抽取到定义类中，可以作为模板复用创建对象<br>   实例化：利用类创建对象的过程称为实例化<br>   构造器：用于封装对象属性实例化过程，创建对象时调用<br>   语法:<br>     1.在类中声明，方法名与类名一致<br>     2.不能有返回值，不能使用void<br>     3.可以有参数，用来实例化对象<br>     4.使用new运算调用构造器，创建对象<br>     5.如果类不定义构造器，Java编译器会自动提默认供构造器；如果类定构造器，Java编译器就不会提供默认构造器<br>     6.构造器重载用于实现：对象有多种数据初始化方式</p> 
<p><strong>引用</strong><br>     1.也称为引用变量，Java中除了基本类型变量其他都是引用类型变量<br>     2.用于操作对象的“句柄handle”<br>     3.应用变量中存储了对象的首地址，利用收地址间接操作内存对象<br>     4.简单说：引用用于操作对象<br>     5.Java自动维护引用的地址，对外不可见，屏蔽了平台差异（跨平台）</p> 
<p><strong>面向对象的3个重要概念</strong><br>     1.封装：将数据以及算法尽可能隐藏到类的内部，只暴露必要的操作方法和数据<br>     2.继承：复用，利用父类复用子类中公共属性和方法，将子类公共属性很方法“泛化”到父类中（画图子类箭头指向父类）。泛化：将子类的公共属性和方法抽取到父类的过程称为泛化。<br>     3.多态：父类型变量引用的子类型个体是多种多样的，使用子类型方法的时候其功能也是多种多样的</p> 
<p><strong>重载</strong><br>     1.在类中（包含父类）定义的方法名一样参数（个数、顺序）不同的方法<br>     2.一般这些的方法封装的算法（方法体）都不相同<br>     3.只是为了表示设计的优雅而将方法名定义为一样<br>     4.调用方法时候，根据方法名和参数列表 识别调用哪个方法。<br> 如果参数不相同，Java会尝试自动转换类型</p> 
<p><strong>方法签名</strong></p> 
<pre><code>方法名+参数类型列表 = 方法签名
</code></pre> 
<p><strong>this 引用</strong><br> this 引用当前的这个对象<br>     1.this 用于区别方法（构造器）中的局部变量和实例变量<br>     2.当方法中局部变量和实例变量同名的时候，可以使用this.实例变量与局部变量加以区分<br>     3.当实例变量名和局部变量名没有冲突，可以省略this</p> 
<p>局部变量：方法的参数是局部变量<br> this()用于调用当前类的其他构造器<br>     1.其目的是为了将构造器的逻辑进行复用<br>       (a) 多个构造器使用一个初始化逻辑<br>     2.this()只能在构造器使用<br>     3.this()写在构造器的第一行</p> 
<p><strong>继承</strong><br> 子类可以继承（获得）父类中的属性和方法。子类无需声明就可以获得父类中的属性和方法。<br> 利用“泛化”实现继承！ 泛化：将对象相同的属性进行抽象同一的过程称为泛化<br> 继承语法：<br>     1.使用extends实现继承<br>     2.被继承者是父类（超类super class）中的属性和方法被子类继承<br>     3.继承者是子类<br>     4.Java是单继承语言<br>     5.如果没有父类，则自动继承于Object 类型</p> 
<p><strong>重写</strong>：<br>   1.在子类中修改从父类中继承的方法<br>     在子类中定义一个与父类型具有相同“方法签名（方法名+参数类型列表）”的方法 <br>   2.能够继承的方法才能重写</p> 
<p>  语法：子类定义一与父类“一样”的方法<br>       a)方法名一样；<br>       b)参数一样<br>       c)返回值，一般都是一样的，可以是更小的类型<br>       d)修饰词，可以更加扩大<br>       e)异常，可以更加具体<br>       f)static修饰方法不能重写</p> 
<p>  super.在子类中代表父类型<br>       1.当子类的属性或方法命名与父类冲突的时候，可以利用super.引用父类中的属性方法<br>       2.在重写的时候，子类与父类的方法相同，如果需要利用父类的逻辑。super.父类方法（）</p> 
<p><strong>内部类</strong>（知识点）<br>   在类内部定义的类，称为内部类<br>   内部类的优点：可以隐藏类的定义，可以共享外部的属性、方法<br>   何时使用内部类：<br>     如果需要隐藏类的定义，或者内部类共享外部的属性或者方法时候，使用内部类。<br>     如果不需要如上特性，就不要使用内部类！<br>   提示：内部类一般只在类的内部使用，不在外部使用。<br> <strong>访问控制修饰符</strong><br>   什么是访问控制：用于控制类、属性、方法等的可见范围。<br>   为啥使用访问控制：可以控制数据及方法的可见范围，保护软件组织（对象）的安全可靠<br>   访问控制修饰词<br>     1.public公有的<br>       a)可以修饰类：类可以在任何位置被访问<br>       b)可以修饰属性：属性可以在任何位置被访问<br>       c)可以修饰方法：方法可以在任何位置被访问<br>     2.protected 保护的 <br>       a)包内可用，包外不可用（外包子类不可用）<br>       b)外包子类不可用<br>     3.默认的，不写任何修饰词<br>       a)默认属性和类在同包中可以访问<br>     4.private私有的 仅仅在类内部可见，用于修饰类内部成员<br>       a)修饰属性：属性 仅仅在类的内部可见<br>       b)修饰方法：方法 仅仅在类的内部可见<br>       c)修饰内部类：内部类 仅仅在内部类可见</p> 
<table><thead><tr><th>修饰符</th><th>本类</th><th>同包类</th><th>子类</th><th>其他类</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>默认</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr></tbody></table> 
<p>    使用原则<br>       1.竟可能封装，在不确定的时候使用private<br>       2.一般不使用默认的<br>       3.给子类使用的属性和方法，使用protected<br>       4.需要公开的属性和方法，使用public<br> <strong>static静态</strong>：<br>   1.属于类的被全部对象共享的唯一一份资源（属于对象的属性和方法是动态的）<br>   2.静态属性是唯一一份属于类的属性<br>   3.静态方法是唯一一份属于类的方法，不能重写！<br>   4.静态代码块，用于初始化静态资源<br> 静态的用途：<br>   1.修饰类的成员变量，称为静态变量<br>     a)静态变量属于类的变量，可以使用“类名.变量名”访问，在类的内部可以省略类名<br>     b)静态变量只有一份，可以被全体对象共享！软件中只有一份的数据应该使用static修饰<br>     c)静态变量在类加载期间，随着类在方法区中初始化，只有一份属于类。<br>   classCircle{<!-- --><br>     static double PI；<br>   }<br>   2.修饰方法，称为静态方法<br>     a)静态方法是属于类的方法<br>     b)一般使用“类名.方法”<br>     c)相对于对象方法（非静态方法），静态方法可以不创建任何对象直接使用类名调用<br>     d)静态方法的好处是：直接使用类名就可以调用方法<br>     e)一般情况下当方法计算时候用到当前对象（this）的属性（数据）时候，使用非静态方法。相反方法在计算的时候没有用到当前方法的属性，则应定义为静态方法<br> 非静态方法中，包含默认的局部变量this引用当前的对象，静态方法中没有this这个变量！！！<br>   3.修饰代码块，称为静态代码块：再类中使用static修饰的代码块。<br>     a)在加载期间按照顺序执行<br>     b)一般用于初始化静态资源（静态属性）<br>   4.修饰内部类，称为静态内部类<br>   静态方法只能访问静态资源：静态方法中没有this，不能使用当前对象的属性，不能使用当前的方法，也不能使用成员内部类</p> 
<p><strong>final</strong><br>   1.final修饰变量（局部变量，方法参数，实例变量）<br>     a)可以初始化一次，以后不能再改变<br>   2.final 可以修饰方法，表示这个方法不能在子类中重写（不能被子类修改）<br>     a)经常为了保护类中声明的方法，避免被子类意外修改<br>     b)工作中很少用！！！<br>   3.final 可以修饰类，表示这个类不能再继承了。不能再有子类了<br>     a)一般用于限制子类，避免再次被扩展（修改）。String就是final类，String是极其重要的Java API，为了避免String功能被篡改，所以定义为final的类型。Java.lang包中的很多类都是final的类。<br>     b)工作中很少用！！！</p> 
<p><strong>static fianl定义常量</strong><br>   static 一份，final表示不能改<br>   一份且不能改的数据，就是Java中的常量。<br>   软件中一份切不能改的数据，都定义为常量</p> 
<p><strong>抽象(abstract)类</strong><br>   使用abstract声明的类是抽象了类，抽象类不能实例化，只能被继承。<br>     1.软件中作为父类使用的“半成品”类，在逻辑上不应该直接实例化<br>     2.Java提供了abstract关键字，实现在语法层面上限制一个类，避免实例化。<br>     3.软件的编写者，在团队协作时候，利用abstract限制类的实例化，可以使用合作者避免不必要的错误。<br>     4.何时使用：一般情况下，作为半成品的父类，建议定义为抽象类<br>     5.抽象类可以作为父类声明变量，只能引用子类的实例。</p> 
<p><strong>抽象(abstract)方法</strong><br>   使用abstract关键字声明方法<br>     1.抽象方法不能有方法体<br>     2.包含抽象方法的类必须定义为抽象类<br>     3.子类继承抽象类的时候，必须实现（重写）父类声明的抽象方法。<br>   何时使用抽象方法，将子类方法泛化到父类的时候，如果每个子类具体方法体都不一样的时候，建议将方法签名(方法名+数据类型列表)抽象到父类中，定义为抽象方法。<br>   抽象类型可以作为父类声明变量，只能引用子类的实例<br>   这样就可以统一使用父类型变量管理子类型实例</p> 
<p><strong>多态</strong><br>   父类型定义的变量引用的子类型实例是多种多样的！</p> 
<p><strong>接口interface</strong><br>   接口:不同类别的公共行为抽象为接口<br>   实体类既是敌人，又是计分接口：这种现象叫多继承<br>     1.在软件继承关系中，部分类型拥有的公共方法，需要抽取到接口中<br>     2.当一个类型继承了自己的父类，同时又实现了接口，这种现象称为多继承<br>     3.如果软件集成结构中出现了一部分类型拥有相同方法的时候，需要使用接口进行抽象射击<br>   -如果全部类型都拥有的公共方法，抽取到父类中</p> 
<p>  语法：<br>     1.接口中只能定义常量和抽象方法<br>     2.可以省略常量的修饰词（只能用public 和 默认）<br>     3.可以省略抽象方法的修饰词，编写简洁方便<br>   接口相当于全部是抽象方法的抽象类<br>   关于实现接口：<br>     1.Java中只能单继承，也就是一个类只能继承（extends）一个父类<br>     2.一个类可以实现对个接，口implements的后面可以实现多个接口<br>     3.在逻辑上表达了既是也是关系，如：石头既是飞行物也是奖励也是敌人<br> <strong>向上造型</strong></p> 
<p><strong>匿名内部类</strong><br>   匿名：没有名字。在类的内部定义，没有名字的类<br>   优点：<br>     1.书写简单<br>     2.具有内部类的全部功能<br>       a)封装类的定义<br>       b)与外部类共享数据和方法<br>     3.由于语法间简洁，使用很广泛<br>       a)简洁实现接口时候使用<br>       b)简洁继承抽象类的时候使用<br>       c)简洁继承类的时候使用<br>   使用匿名内部类<br>     1.必须有父类型，可以抽象类或者接口<br>     2.必须作为子类派生自父类<br>     3.子类没有类名，直接继承自父类，并且直接创建了对象<br> Java源文件编译后，每个生成一个class文件，内部类和匿名类都会生成独立的class文件</p> 
<p><strong>内存泄露和内存溢出</strong><br>   Java中的内存管理<br>     1.所有的局部变量在栈分配<br>       a)每个方法一个栈帧<br>       b)方法中的变量在栈帧中分配<br>       c)方法结束以后栈帧弹出销毁，其变量也全部销毁<br>     2.所有的对象都在栈中分配<br>       a)new运算时候在栈中分配对象存储空间<br>       b)对象存储空间存储对象的属性<br>       c)当对象不被任何变量引用的时候，对象变成内存”垃圾”<br>       d)Java 提供垃圾回收期自动回收内存来“垃圾”<br>     3.内存泄露<br>       a)Java垃圾回收其无法回收不可使用的对象，这些对象在内存中积累，不断消耗内存<br>       b)内存泄露的终极表现：内存溢出<br>     4.解决内存泄露<br>       a)当对象不再使用的时候，及时释放对象的使用，使对象可以被及时回收</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/abfb3316d86122df321f0ec2ae9d0bbb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一文带你搞懂Spring MVC和servlet（面试必备）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9604ba14f3fac2023f554fc8166fa5a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ZigBee入门-CC2530-实验（五）-串口通信控制LED代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>