<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅谈View的绘制流程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅谈View的绘制流程" />
<meta property="og:description" content="Window：每个Activity都会创建一个Window用于承载View视图的显示，Window是一个抽象类存在了一个唯一实现类PhoneWindow
DecorView：最顶层的View，是一个FrameLayout子类，最终会被加载到Window当中，它内部只有一个垂直方向的LinearLayout分为两部分： TitleBar：屏幕顶部的状态栏ContentView：Activity对应的XML布局，通过setContentView设置到DecorView中 Activity和Window关联 ActivityThread调用scheduleLaunchActivity()scheduleLaunchActivity发送消息sendMessage(H.LAUNCH_ACTIVITY, r);handleLaunchActivity初始化WindowMannagerServiceperformLaunchActivity创建Activity执行activity的attachnew PhoneWindow(this,window) &#43; 将window和windowMangerService绑定：同时，此时完成了window和activity的绑定 private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); handleResumeActivity(r.token, false, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); } private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent){ //省略 Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); return activity; } final void handleResumeActivity(IBinder token,boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason){ //省略 View decor = r." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c5a324da3e3b98b861e83576f48f8b7a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-18T17:10:40+08:00" />
<meta property="article:modified_time" content="2023-10-18T17:10:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅谈View的绘制流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <ul><li> <p id="1d4nc">Window：每个<code>Activity</code>都会创建一个<code>Window</code>用于承载View视图的显示，<code>Window</code>是一个抽象类存在了一个唯一实现类<code>PhoneWindow</code></p> </li><li>DecorView：最顶层的View，是一个<code>FrameLayout</code>子类，最终会被加载到Window当中，它内部只有一个垂直方向的<code>LinearLayout</code>分为两部分： 
   <ul><li>TitleBar：屏幕顶部的状态栏</li><li>ContentView：<code>Activity</code>对应的XML布局，通过<code>setContentView</code>设置到<code>DecorView</code>中</li></ul></li></ul> 
</blockquote> 
<h4>Activity和Window关联</h4> 
<blockquote> 
 <ul><li>ActivityThread调用scheduleLaunchActivity()</li><li>scheduleLaunchActivity发送消息sendMessage(H.LAUNCH_ACTIVITY, r);</li><li>handleLaunchActivity初始化WindowMannagerService</li><li>performLaunchActivity创建Activity</li><li>执行activity的attach</li><li>new PhoneWindow(this,window) + 将window和windowMangerService绑定：同时，此时完成了window和activity的绑定</li></ul> 
</blockquote> 
<pre><code class="language-java">    private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
        // Initialize before creating the activity
        WindowManagerGlobal.initialize();
        Activity a = performLaunchActivity(r, customIntent);
        handleResumeActivity(r.token, false, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);
    }

    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent){
        //省略
        Activity activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
        activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window, r.configCallback);
        return activity;
    }

final void handleResumeActivity(IBinder token,boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason){
        //省略
        View decor = r.window.getDecorView();
        ViewManager wm = a.getWindowManager();
        WindowManager.LayoutParams l = r.window.getAttributes();
        wm.addView(decor, l);
    }</code></pre> 
<h4>Activity和window和view 的关系</h4> 
<p>activity是系统可视化交互组件，四大组件都由AMS统一管理生命周期，事实上它的职责只是生命周期的管理，处于单一职责的原则，那势必需要将activity和其上的视图View进行解耦，那么久引入window的概念，它是个抽象类，对于activity来说，它的具体实现类是PhoneWindow，在activity执行attach的时候，会创建一个PhoneWindow对象，PhoneWindow作为装载根视图DecorView的顶级容器，activity通过setContentView实际上是调用了PhoneWindow来创建DecorView，并解析xml布局加载到DecorView的contentView部分。</p> 
<p>了解Activity中setContentView源码：</p> 
<pre><code class="language-java">public void setContentView(@LayoutRes int layoutResID) {
        //将xml布局传递到Window当中
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
}</code></pre> 
<p>从代码可以看出，<code>Activity</code>的<code>setContentView</code>实质是将<code>View</code>传递到<code>Window</code>的<code>setContentView()</code>方法中，<code>Window</code>的<code>setContenView</code>会在内部调用<code>installDecor()</code>方法创建<code>DecorView</code>，看一下它的部分源码: </p> 
<pre><code class="language-java"> public void setContentView(int layoutResID) { 
        ...............
        //初始化DecorView以及其内部的content
        installDecor();
        //将contentView加载到DecorVoew当中
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
  private void installDecor() {
        ...............
        //实例化DecorView
        mDecor = generateDecor(-1);
        mDecor.setWindow(this);
        //获取Content
        mContentParent = generateLayout(mDecor);
 }
 protected DecorView generateDecor(int featureId) {
        ...............
        return new DecorView(context, featureId, this/*PhoneWindow*/, getAttributes());
 }</code></pre> 
<p>通过<code>generateDecor()</code>new一个<code>DecorView</code>，然后调用<code>generateLayout()</code>获取<code>DecorView</code>中<code>content</code>，最终通过<code>inflate</code>将<code>Activity</code>视图添加到<code>DecorView</code>中的<code>content</code>中，但此时<code>DecorView</code>还未被添加到<code>Window</code>中。添加操作需要借助<code>ViewRootImpl</code>。</p> 
<p><code>ViewRootImpl</code>的作用是用来衔接<code>WindowManager</code>和<code>DecorView</code>，在<code>Activity</code>被创建后会通过<code>WindowManager</code>将<code>DecorView</code>添加到<code>PhoneWindow</code>中并且创建<code>ViewRootImpl</code>实例，随后将<code>DecorView</code>与<code>ViewRootImpl</code>进行关联，最终通过执行<code>ViewRootImpl</code>的<code>performTraversals()</code>开启整个View树的绘制。</p> 
<h4 id="5de3f">绘制过程</h4> 
<p>对应于ViewRootImpl类，它是连接WindowMannager和DecorView的纽带，View的三大流程均是通过ViewRootImpl完成的，当activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联在ViewRootImpl里面performTraversals（）方法开始，从最顶层的<code>View(ViewGroup)</code>开始逐层对每个<code>View</code>进行绘制操作，下面来看一下该方法部分源代码：</p> 
<pre><code class="language-java">private void performTraversals() {
     ...............
    //measur过程
    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    //layout过程
    performLayout(lp, desiredWindowWidth, desiredWindowHeight);
    //draw过程
    performDraw();
}</code></pre> 
<h4>View与window的逻辑结构</h4> 
<p>对应于ViewRootImpl类，它是连接WindowMannager和DecorView的纽带，View的三大流程均是通过ViewRootImpl完成的，当activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联在ViewRootImpl里面performTraversals（）分发</p> 
<p>Android的View绘制流程是一个复杂的过程，主要包括了几个关键的步骤：Measure（测量）、Layout（布局）、Draw（绘制）。</p> 
<h5>Measure（测量）</h5> 
<p>在View的绘制流程中，首先进行的是Measure阶段。这个阶段的主要任务是确定View及其子View的大小和宽高。在源代码中，这个过程主要由onMeasure()方法完成。在这个方法中，我们需要根据MeasureSpec（它表示的是父View希望子View占据的尺寸）来确定子View的尺寸。MeasureSpec是一个int类型，包含了两个部分：大小和模式。大小表示父View希望子View占据的尺寸，模式则表示父View是如何希望我们处理这个尺寸的。</p> 
<h5>Layout（布局）</h5> 
<p>测量阶段完成后，View会得到一个大小，然后进入Layout阶段。这个阶段的主要任务是将每个View按照它们在XML文件中定义的布局进行排列。在源代码中，这个过程主要由onLayout()方法完成。在此方法中，我们需要根据View的布局参数（如宽、高、左、上、右、下的margin等）来确定View在屏幕上的具体位置。</p> 
<h5>Draw（绘制）</h5> 
<p>Layout阶段完成后，每个View都会被放置在屏幕上的一个具体位置。然后进入Draw阶段，这个阶段的主要任务是将View及其子View的内容绘制到屏幕上。在源代码中，这个过程主要由onDraw()方法完成。在此方法中，我们可以在Canvas上绘制任何我们想要的内容。例如，可以在这个方法中绘制一个背景色、一个文字、一个图片等等。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c87bccad7402b703fc2f48a7473bb31/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">猴子管理法则</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac46a39b8a4c8651bc52a4c502dc5421/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023Java后端开发面试题尝鲜版，认真看完拿个25K没问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>