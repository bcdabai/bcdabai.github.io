<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第十四章：二叉搜索树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第十四章：二叉搜索树" />
<meta property="og:description" content="第十四章：二叉搜索树 1.二叉搜索树的概念 二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
它的左右子树也分别为二叉搜索树
2.二叉搜索树的实现 #include&lt;iostream&gt; using namespace std; template&lt;class K&gt; struct BSTNode { BSTNode(const K&amp; key = K()) :_left(nullptr) ,_right(nullptr) ,_key(key) {} BSTNode&lt;K&gt;* _left; BSTNode&lt;K&gt;* _right; K _key; }; template&lt;class K&gt; class BSTree { typedef BSTNode&lt;K&gt; Node; public: BSTree() :_root(nullptr) {} BSTree(const BSTree&lt;K&gt;&amp; t) { _root = _Copy(t._root); } BSTree&lt;K&gt;&amp; operator=(const BSTree&lt;K&gt;&amp; t) { swap(_root, t._root); return *this; } ~BSTree() { _Destory(_root); } //递归插入 bool InsertR(const K&amp; key) { return _InsertR(_root, key); } //递归查找 Node* FindR(const K&amp; key) { return _FindR(_root, key); } //递归删除 bool EraseR(const K&amp; key) { return _EraseR(_root, key); } bool Insert(const K&amp; key) { if (_root == nullptr) { _root = new Node(key); return true; } Node* pre_cur = nullptr; Node* cur = _root; while (cur) { if (cur-&gt;_key &lt; key) { pre_cur = cur; cur = cur-&gt;_right; } else if (cur-&gt;_key &gt; key) { pre_cur = cur; cur = cur-&gt;_left; } else { return false; } } cur = new Node(key); if (pre_cur-&gt;_key &lt; key) { pre_cur-&gt;_right = cur; } else { pre_cur-&gt;_left = cur; } return true; } //查找 Node* Find(const K&amp; key) { Node* cur = _root; while (cur) { if (cur-&gt;_key &lt; key) { cur = cur-&gt;_right; } else if (cur-&gt;_key &gt; key) { cur = cur-&gt;_left; } else { return cur; } } return nullptr; } //删除 bool Erase(const K&amp; key) { //空二叉树 if (_root == nullptr) { return false; } //查找 Node* pre_cur = nullptr; Node* cur = _root; while (cur!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/26b07b85826e1f68184a63adfd6a96a4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-25T12:26:39+08:00" />
<meta property="article:modified_time" content="2022-03-25T12:26:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第十四章：二叉搜索树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>第十四章：二叉搜索树</h2> 
<h3><a id="1_2"></a>1.二叉搜索树的概念</h3> 
<p><strong>二叉搜索树</strong>又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:</p> 
<ul><li> <p>若它的左子树不为空，则左子树上所有节点的值都小于根节点的值</p> </li><li> <p>若它的右子树不为空，则右子树上所有节点的值都大于根节点的值</p> </li><li> <p>它的左右子树也分别为二叉搜索树</p> </li></ul> 
<h3><a id="2_14"></a>2.二叉搜索树的实现</h3> 
<pre><code class="prism language-C++">#include&lt;iostream&gt;
using namespace std;

template&lt;class K&gt;
struct BSTNode
{
    BSTNode(const K&amp; key = K())
        :_left(nullptr)
        ,_right(nullptr)
        ,_key(key)
    {}  
    BSTNode&lt;K&gt;* _left;
    BSTNode&lt;K&gt;* _right;
    K _key;
};

template&lt;class K&gt;
class BSTree
{
    typedef BSTNode&lt;K&gt; Node;
public:
    BSTree()
        :_root(nullptr)
    {}

    BSTree(const BSTree&lt;K&gt;&amp; t)
    {
        _root = _Copy(t._root);
    }

    BSTree&lt;K&gt;&amp; operator=(const BSTree&lt;K&gt;&amp; t)
    {
        swap(_root, t._root);
        return *this;
    }

    ~BSTree()
    {
        _Destory(_root);
    }

    //递归插入
    bool InsertR(const K&amp; key)
    {
        return _InsertR(_root, key);
    }

    //递归查找
    Node* FindR(const K&amp; key)
    {
        return _FindR(_root, key);
    }

    //递归删除
    bool EraseR(const K&amp; key) 
    {
        return _EraseR(_root, key);
    }

    bool Insert(const K&amp; key)
    {
        if (_root == nullptr)
        {
            _root = new Node(key);
            return true;
        }
        Node* pre_cur = nullptr;
        Node* cur = _root;
        while (cur)
        {
            if (cur-&gt;_key &lt; key) {
                pre_cur = cur;
                cur = cur-&gt;_right;
            }
            else if (cur-&gt;_key &gt; key) {
                pre_cur = cur;
                cur = cur-&gt;_left;
            }
            else {
                return false;
            }
        }
        cur = new Node(key);
        if (pre_cur-&gt;_key &lt; key) {
            pre_cur-&gt;_right = cur;
        }
        else {
            pre_cur-&gt;_left = cur;
        }
        return true;
    }

    //查找
    Node* Find(const K&amp; key)
    {
        Node* cur = _root;
        while (cur)
        {
            if (cur-&gt;_key &lt; key) {
                cur = cur-&gt;_right;
            }
            else if (cur-&gt;_key &gt; key) {
                cur = cur-&gt;_left;
            }
            else {
                return cur;
            }
        }
        return nullptr;
    }

    //删除
    bool Erase(const K&amp; key)
    {
        //空二叉树
        if (_root == nullptr)
        {
            return false;
        }
        //查找
        Node* pre_cur = nullptr;
        Node* cur = _root;
        while (cur!=nullptr)
        {
            if (cur-&gt;_key &lt; key) {
                pre_cur = cur;
                cur = cur-&gt;_right;
            }
            else if (cur-&gt;_key &gt; key) {
                pre_cur = cur;
                cur = cur-&gt;_left;
            }
            else {
                //找到了
                if (cur-&gt;_left == nullptr)
                {
                    //左子树为空或者左、右子树都空
                    if (cur == _root)//要删除的节点为根节点
                    {
                        _root = cur-&gt;_right;
                        delete cur;
                        cur = nullptr;
                    }
                    else
                    {
                        if (pre_cur-&gt;_left == cur)
                        {
                            pre_cur-&gt;_left = cur-&gt;_right;
                        }
                        else
                        {
                            pre_cur-&gt;_right = cur-&gt;_right;
                        }
                        delete cur;
                        cur = nullptr;
                    }
                    
                }
                else if (cur-&gt;_right == nullptr)
                {
                    //只有右子树为空
                    if (cur == _root)//要删除的节点为根节点
                    {
                         _root = cur-&gt;_left;
                        delete cur;
                        cur = nullptr;
                    }
                    else
                    {
                        if (pre_cur-&gt;_left == cur)
                        {
                            pre_cur-&gt;_left = cur-&gt;_left;
                        }
                        else
                        {
                            pre_cur-&gt;_right = cur-&gt;_left;
                        }
                        delete cur;
                        cur = nullptr;
                    }
                }
                else
                {
                    //左右都不为空，找右子树最小的节点
                    Node* pre_min_right = cur;
                    Node* min_right = cur-&gt;_right;
                    while (min_right-&gt;_left)
                    {
                        pre_min_right = min_right;
                        min_right = min_right-&gt;_left;
                    }
                    cur-&gt;_key = min_right-&gt;_key;
                    if (pre_min_right-&gt;_left == min_right)
                    {
                        pre_min_right-&gt;_left = min_right-&gt;_right;
                    }
                    else
                    {
                        pre_min_right-&gt;_right = min_right-&gt;_right;
                    }
                    delete min_right;
                    min_right = NULL;
                }
            }
        }
        return false;
    }

    //递归中序遍历
    void InOrder()
    {
        if (_root == nullptr)
        {
            cout &lt;&lt; "树空！" &lt;&lt; endl;
        }
        _InOrder(_root);
        cout &lt;&lt; endl;
    }

private:
    Node* _root;

    //删除
    void _Destory(Node* root)
    {
        if (root == nullptr)
        {
            return;
        }
        _Destory(root-&gt;_left);
        _Destory(root-&gt;_right);
        delete root;
        root = nullptr;
    }

    //复制
    Node* _Copy(Node* root)
    {
        if (root == nullptr)
        {
            return nullptr;
        }
        Node* copyNode = new Node(root-&gt;_key);
        copyNode-&gt;_left = _Copy(root-&gt;_left);
        copyNode-&gt;_right = _Copy(root-&gt;_right);
        return copyNode;
    }

    //递归插入
    bool _InsertR(Node*&amp; root, const K&amp; key)
    {
        if (root == nullptr)
        {
            root = new Node(key);
            return true;
        }
        if (root-&gt;_key &lt; key)
        {
            return _InsertR(root-&gt;_right, key);
        }
        else if (root-&gt;_key &gt; key)
        {
            return _InsertR(root-&gt;_left, key);
        }
        else 
        {
            return false;
        }
    }

    //递归查找
    Node* _FindR(Node* root, const K&amp; key)
    {
        if (root == nullptr)
        {
            return nullptr;
        }
        if (root-&gt;_key &lt; key)
        {
            return _FindR(root-&gt;_right, key);
        }
        else if (root-&gt;_key &gt; key)
        {
            return _FindR(root-&gt;_left, key);
        }
        else
        {
            return root;
        }
    }

    //递归删除
    bool _EraseR(Node*&amp; root, const K&amp; key)
    {
        if (root == nullptr)
        {
            return false;
        }
        if (root-&gt;_key &lt; key)
        {
            return _EraseR(root-&gt;_right, key);
        }
        else if (root-&gt;_key &gt; key)
        {
            return _EraseR(root-&gt;_left, key);
        }
        else
        {
            //找到了
            if (root-&gt;_left == nullptr)
            {
                Node* del = root;
                root = root-&gt;_right;
                delete del;
                del = nullptr;
            }
            else if (root-&gt;_right == nullptr)
            {
                Node* del = root;
                root = root-&gt;_left;
                delete del;
                del = nullptr;
            }
            else
            {
                Node* pre_min_right = root;
                Node* min_right = root-&gt;_right;
                while (min_right-&gt;_left)
                {
                    pre_min_right = min_right;
                    min_right = min_right-&gt;_left;
                }
                root-&gt;_key = min_right-&gt;_key;
                if (pre_min_right-&gt;_left == min_right)
                {
                    pre_min_right-&gt;_left = min_right-&gt;_right;
                }
                else
                {
                    pre_min_right-&gt;_right = min_right-&gt;_right;
                }
                delete min_right;
                min_right = NULL;
            }
        }
        return false;
    }

    //递归中序遍历
    void _InOrder(Node* root)
    {
        if (root == nullptr)
            return;
        _InOrder(root-&gt;_left);
        cout &lt;&lt; root-&gt;_key &lt;&lt; " ";
        _InOrder(root-&gt;_right);
    }
};
</code></pre> 
<h3><a id="3_379"></a>3.二叉搜索树的应用</h3> 
<p><strong>K模型</strong>：<strong>K模型即只有key作为关键码，结构中只需要存储Key即可，关键码即为需要搜索到的值</strong>。</p> 
<p>比如：给一个单词word，判断该单词是否拼写正确，具体方式如下：</p> 
<blockquote> 
 <ul><li> <p>以单词集合中的每个单词作为key，构建一棵二叉搜索树</p> </li><li> <p>在二叉搜索树中检索该单词是否存在，存在则拼写正确，不存在则拼写错误。</p> </li></ul> 
</blockquote> 
<p><strong>KV模型</strong>：<strong>每一个关键码key，都有与之对应的值Value，即&lt;Key, Value&gt;的键值对</strong>。</p> 
<p>该种方式在现实生活中非常常见：比如英汉词典就是英文与中文的对应关系，通过英文可以快速找到与其对应的中文，英文单词与其对应的中文&lt;word, chinese&gt;就构成一种键值对；再比如统计单词次数，统计成功后，给定单词就可快速找到其出现的次数，单词与其出现次数就是&lt;word, count&gt;就构成一种键值对。</p> 
<p>比如：实现一个简单的英汉词典dict，可以通过英文找到与其对应的中文，具体实现方式如下：</p> 
<blockquote> 
 <ul><li> <p>&lt;单词，中文含义&gt;为键值对构造二叉搜索树，注意：二叉搜索树需要比较，键值对比较时只比较Key</p> </li><li> <p>查询英文单词时，只需给出英文单词，就可快速找到与其对应的key</p> </li></ul> 
</blockquote> 
<pre><code class="prism language-c++">//kv和k类似，在前面实现的基础上进行了一定程度的改造
#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;iostream&gt;
using namespace std;

template&lt;class K,class V&gt;
struct BSTNode
{
    BSTNode(const K&amp; key, const V&amp; value)
        :_left(nullptr)
        , _right(nullptr)
        , _key(key)
        ,_value(value)
    {}
    BSTNode&lt;K,V&gt;* _left;
    BSTNode&lt;K,V&gt;* _right;
    K _key;
    V _value;
};

template&lt;class K,class V&gt;
class BSTree
{
    typedef BSTNode&lt;K,V&gt; Node;
public:
    BSTree()
        :_root(nullptr)
    {}

    BSTree(const BSTree&lt;K,V&gt;&amp; t)
    {
        _root = _Copy(t._root);
    }

    BSTree&lt;K,V&gt;&amp; operator=(const BSTree&lt;K,V&gt;&amp; t)
    {
        swap(_root, t._root);
        return *this;
    }

    ~BSTree()
    {
        _Destory(_root);
    }

    //递归插入
    bool InsertR(const K&amp; key,const V&amp; value)
    {
        return _InsertR(_root, key, value);
    }

    //递归查找
    Node* FindR(const K&amp; key)
    {
        return _FindR(_root, key);
    }

    //递归删除
    bool EraseR(const K&amp; key)
    {
        return _EraseR(_root, key);
    }

    //递归中序遍历
    void InOrder()
    {
        if (_root == nullptr)
        {
            cout &lt;&lt; "树空！" &lt;&lt; endl;
        }
        _InOrder(_root);
        cout &lt;&lt; endl;
    }

private:
    Node* _root;

    //删除
    void _Destory(Node* root)
    {
        if (root == nullptr)
        {
            return;
        }
        _Destory(root-&gt;_left);
        _Destory(root-&gt;_right);
        delete root;
        root = nullptr;
    }

    //复制
    Node* _Copy(Node* root)
    {
        if (root == nullptr)
        {
            return nullptr;
        }
        Node* copyNode = new Node(root-&gt;_key, root-&gt;_value);
        copyNode-&gt;_left = _Copy(root-&gt;_left);
        copyNode-&gt;_right = _Copy(root-&gt;_right);
        return copyNode;
    }

    //递归插入
    bool _InsertR(Node*&amp; root, const K&amp; key,const V&amp; value)
    {
        if (root == nullptr)
        {
            root = new Node(key, value);
            return true;
        }
        if (root-&gt;_key &lt; key)
        {
            return _InsertR(root-&gt;_right, key, value);
        }
        else if (root-&gt;_key &gt; key)
        {
            return _InsertR(root-&gt;_left, key, value);
        }
        else
        {
            return false;
        }
    }

    //递归查找
    Node* _FindR(Node* root, const K&amp; key)
    {
        if (root == nullptr)
        {
            return nullptr;
        }
        if (root-&gt;_key &lt; key)
        {
            return _FindR(root-&gt;_right, key);
        }
        else if (root-&gt;_key &gt; key)
        {
            return _FindR(root-&gt;_left, key);
        }
        else
        {
            return root;
        }
    }

    //递归删除
    bool _EraseR(Node*&amp; root, const K&amp; key)
    {
        if (root == nullptr)
        {
            return false;
        }
        if (root-&gt;_key &lt; key)
        {
            return _EraseR(root-&gt;_right, key);
        }
        else if (root-&gt;_key &gt; key)
        {
            return _EraseR(root-&gt;_left, key);
        }
        else
        {
            //找到了
            if (root-&gt;_left == nullptr)
            {
                Node* del = root;
                root = root-&gt;_right;
                delete del;
                del = nullptr;
            }
            else if (root-&gt;_right == nullptr)
            {
                Node* del = root;
                root = root-&gt;_left;
                delete del;
                del = nullptr;
            }
            else
            {
                Node* minRight = root-&gt;_right;
                while (minRight-&gt;_left)
                {
                    minRight = minRight-&gt;_left;
                }
                K kmin = minRight-&gt;_key;
                V vmin = minRight-&gt;_value;
                _EraseR(root-&gt;_right, kmin);
                root-&gt;_key = kmin;
                root-&gt;_value = vmin;
            }
        }
        return false;
    }

    //递归中序遍历
    void _InOrder(Node* root)
    {
        if (root == nullptr)
            return;
        _InOrder(root-&gt;_left);
        cout &lt;&lt; root-&gt;_key &lt;&lt; "---" &lt;&lt; root-&gt;_value &lt;&lt; "  ";
        _InOrder(root-&gt;_right);
    }
};

void test1()//功能测试
{
    BSTree&lt;int, int&gt; t;
    int key[] = { 5,3,4,1,7,8,2,6,0,9 };
    int value[] = { 1,2,3,4,5,6,7,8,9,10 };
    for (size_t i = 0; i &lt; 10; ++i)
    {
        t.InsertR(key[i], value[i]);
    }
    t.InOrder();
    BSTree&lt;int, int&gt; t1(t);
    BSTree&lt;int, int&gt; t2 = t;
    t1.InOrder();
    t2.InOrder();
    BSTNode&lt;int, int&gt;* newnode = t.FindR(5);
    cout &lt;&lt; newnode-&gt;_key &lt;&lt; "---" &lt;&lt; newnode-&gt;_value &lt;&lt; endl;
    for (auto e : key)
    {
        t.EraseR(e);
    }
    t.InOrder();
}

void test2()//简单翻译
{
    BSTree&lt;string, string&gt; dict;
    dict.InsertR("string", "字符串");
    dict.InsertR("tree", "树");
    dict.InsertR("left", "左边");
    dict.InsertR("right", "右边");
    dict.InsertR("sort", "排序");
    dict.InsertR("dragon", "龙");
    
    string str;
    while (cin &gt;&gt; str)
    {
        BSTNode&lt;string, string&gt;* ret = dict.FindR(str);
        if (ret == nullptr)
        {
            cout &lt;&lt; "单词拼写错误或者词库中未收录！" &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; "中文翻译：" &lt;&lt; ret-&gt;_value &lt;&lt; endl;
        }
    }
}

void test3()//计数器
{
    string arr[] = { "苹果","苹果","菠萝","香蕉","苹果","苹果","西瓜","苹果" };
    BSTree&lt;string, int&gt; countTree;
    for (const auto&amp; str : arr)
    {
        auto ret = countTree.FindR(str);
        if (ret == nullptr)
        {
            countTree.InsertR(str, 1);
        }
        else
        {
            ret-&gt;_value++;
        }
    }
    countTree.InOrder();
}
</code></pre> 
<h3><a id="4_678"></a>4.二叉搜索树的性能分析</h3> 
<p>插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能。</p> 
<p>对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是结点在二叉搜索树的深度的函数，即结点越深，则比较次数越多。</p> 
<p>但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树</p> 
<p>最优情况下，二叉搜索树为完全二叉树，其平均比较次数为：<strong>log₂N</strong></p> 
<p>最差情况下，二叉搜索树退化为单支树，其平均比较次数为： <strong>N/2</strong></p> 
<p>如果退化成单支树，二叉搜索树的性能就失去了，所以为了提高二叉搜索树操作的效率，在构建二叉搜索树时尽量避免出现单支树的情况出现，通过一些机制是可以避免在构建二叉树时出现单支树的情况，例如：平衡二叉搜索树。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a1f9f70235013ff6ba0dc6b1a86d56d1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Centos7 安装nginx-1.9.9教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb5b8bcd84faa77b2624f43591a8d8c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【亲测可用】Hadoop分布式集群扩缩容</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>