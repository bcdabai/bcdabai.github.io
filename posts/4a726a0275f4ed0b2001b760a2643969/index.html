<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【区块链】关于访问控制的一些思考 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【区块链】关于访问控制的一些思考" />
<meta property="og:description" content="一. 概念 1. 主体 访问的发起者，并造成了信息的流动或者系统状态的改变。如人，进程，设备等。
2. 客体 包含信息或接收信息的被动接受访问的资源，对客体的访问意味着对其中所包含信息的访问。如文件，设备，信号量，网络节点等。
3. 权限 是否允许主体(s)对客体(o)执行某种动作(a)，如果主体可以访问，则为允许(pass)；否则为禁止(deny)。权限的概念本质上描述的是一种对主体是否拥有许可的判定，用函数F可以表示为F(s, o, a)={pass/deny}或者F(s, o, a)={1/0}。例如，在Windows系统中，具有管理员权限的用户Alice对注册表执行修改的操作，访问权限=pass；没有管理员权限的来宾用户Guest对注册表执行修改的操作，访问权限=deny。
4. 授权 授权是指将访问权限授予一个主体的行为。该定义至少包含了2个层次的含义：
断言一个主体可以被授予一组特权或者安全属性的行为；
在确定主体拥有对应的访问权限之后，允许主体访问资源的操作行为。
第一个层次的含义描述的是一种授权管理行为，通常需要安全管理员的参与；而第二层含义描述的是一种自动化的访问控制操作行为，是由计算机系统自动实施的。
5. 访问控制 指在鉴别用户的合法身份后，通过某种途径显式地准许或限制用户对数据信息的访问能力及范围，阻止未经授权的资源访问，包括阻止以未经授权的方式使用资源。当主体提出资源访问请求时，系统必须先要确认是合法的主体，而不是假冒的欺骗者，也就是对主体进行鉴别（也称认证）的过程。主体通过鉴别以后，就会获得一个主体标识用来区别其身份，此时系统才能根据预设的访问控制策略来判定主体是否拥有权限对客体执行访问动作。该定义说明，授权管理过程往往发生在访问控制之前，前者是后者的执行依据。
二. 访问矩阵，访问控制列表(ACL)，能力列表(CL) 1. 访问矩阵 行对应主体，列对应客体，矩阵元素定义了主体可以对客体执行的访问操作。
2. ACL 记录允许访问客体的主体及允许的访问操作集合，针对客体。
从主体的角度实施权限分配与管理困难。
3. CL 记录主体定义允许访问的所有客体及对应的访问操作，针对主体。
感觉访问控制并不侧重资源产生者，而是侧重访问主体，客体和策略。资源产生者不体现，而体现在制定的策略中。
有学者通过研究提出，ACL方法和CL方法可以结合使用。在分布式系统中，这种混合的方法可以避免重复的用户认证。主要的原理是：由系统中的服务提供对客体的管理，用户如果要访问客体，将在通过认证后获得一个CL，通过使用该CL中描述的主体允许访问服务的能力来访问系统中的服务，服务则可以依据ACL进一步实施细粒度的访问控制。
CL讲真可以通过zxy_ABE实现。一种思路：将发放CL的过程以zxy_CP-ABE的方式写入交易中，用户自行获得CL，访问服务。服务由所有者保管，所有者可以自行实现CL对应的细粒度访问控制，然后发给用户，用户使用自己的CL对之进行解密获取权限。（自黑：没有改变方法的原理，只是提出了一种可行方案，而且实际上没有上链的必要。）
或许可以让服务集群上链？感觉类似知识产权的细粒度保护，GitHub或区块链？区块链实现知识产权的细粒度保护可以研究一下。感觉上链还是不靠谱，讲真没有办法做到我目前方案的非传播性访问控制，也就是如果资源不被允许再授权，放到链上是很难保证这一点的安全的。如果不上链的话服务集群还是要交给第三方保管，那么或许可以选择代理？我们抛开公有链的场景，假设是联盟链or私有链，那么可以选取可信代理进行服务集群的托管？类似工作量证明里的将工作量替换为存储资源？（自黑：没有必要。因为服务对客体的细粒度控制不可能让大家讨论来决定。）
等等，如果访问控制针对的是资源，那么真的没办法控制不被传播；但如果是某种行为或特权，是否可以实现不被传播呢。首先，访问控制是授予主体对资源的读写执行权限，写权限可以让全网验证是否有写权限从而更改资源内容。所以我们要对客体进行分类，客体包括资源，行为，特权，服务等，然后针对性地设想访问控制场景。
So… 我需要上链的场景是什么？
场景：首先，主体是用户，而不是进程和设备等。客体是服务，行为等动态变化的资源（静态资源上链意义不大）；其次，授权主体与访问主体可能是跨域的，因而客体和访问策略需要放在网络上传播（或许用访问策略对客体加密？），访问者满足访问策略获得权限，可以对客体执行相应操作提交给所有者，所有者可对客体进行相应的操作，从而使后续得到该客体的主体都能得到最新的客体。
如果将客体的更新过程交给区块链来完成，即区块链中每个节点都保存着对客体的所有合法操作过程和最新结果，访问主体在访问客体时能够得到最新客体，区块链使得对客体的操作过程可追溯，且需多方验证超过51%才被全网认可。
上链的价值需要体现在对资源的操作需要多方认可才得以执行，那么适用的具体场景—多方协作，所以用区块链做GitHub的中心化托管会更好吗？知识产权目前的问题是什么？（Q1）
我们是否可以将权限直接加到资源上，比如多根访问树之类的？（Q2）
是否可以跳出区块链的局限，将区块链中用某个技术解决某个问题的思想应用到我们需要的场景，重新建构安全框架？-总结一下区块链各技术意义所在，是否缺一不可/可以改进。（Q3）
4. ACL与CL实现技术的特点对比 了解到将权限分配给主体和客体带来的某些方面的便利和另一些方面的困难，两种方法没有绝对的好坏，因此在设计方案时，应该根据场景权衡利弊。
三. 访问控制模型 1. 自主访问控制模型（DAC model） 将用户权限与用户直接对应-较高访问效率与灵活度
客体拥有者持有对该客体的完全控制权
权限传播可控性差
用户可以自主地把自己所拥有的客体的访问权限授予用户组其他用户，例如Linux和Windows系统中客体拥有者对自己所属用户组进行授权管理的操作。
有些场景是需要权限可传播的，会带来极大的灵活性，但对于某些场景就是灾难，因此需要尽量做到&#34;可控”。
2. 强制访问控制（MAC） 依据主体和客体的安全级别实施权限管理
通过控制信息的单向流动来防止信息扩散
3. 基于角色的访问控制（RBAC） 上述两者对于权限的授权变动工作繁琐，且容易引发安全漏洞
角色是指一个可以完成一定事务的命名组。事务是指一个完成一定功能的过程。用户能被指派到哪些角色受时间，地点，事件等诸多因素的影响。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4a726a0275f4ed0b2001b760a2643969/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-20T14:12:13+08:00" />
<meta property="article:modified_time" content="2021-01-20T14:12:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【区块链】关于访问控制的一些思考</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5><a id="__0"></a>一. 概念</h5> 
<h6><a id="1__1"></a>1. 主体</h6> 
<p>访问的发起者，并造成了信息的流动或者系统状态的改变。如人，进程，设备等。</p> 
<h6><a id="2__4"></a>2. 客体</h6> 
<p>包含信息或接收信息的被动接受访问的资源，对客体的访问意味着对其中所包含信息的访问。如文件，设备，信号量，网络节点等。</p> 
<h6><a id="3__7"></a>3. 权限</h6> 
<p>是否允许主体(s)对客体(o)执行某种动作(a)，如果主体可以访问，则为允许(pass)；否则为禁止(deny)。权限的概念本质上描述的是一种对主体是否拥有许可的判定，用函数F可以表示为F(s, o, a)={pass/deny}或者F(s, o, a)={1/0}。例如，在Windows系统中，具有管理员权限的用户Alice对注册表执行修改的操作，访问权限=pass；没有管理员权限的来宾用户Guest对注册表执行修改的操作，访问权限=deny。</p> 
<h6><a id="4__11"></a>4. 授权</h6> 
<p>授权是指将访问权限授予一个主体的行为。该定义至少包含了2个层次的含义：</p> 
<ul><li> <p>断言一个主体可以被授予一组特权或者安全属性的行为；</p> </li><li> <p>在确定主体拥有对应的访问权限之后，允许主体访问资源的操作行为。</p> </li></ul> 
<p>第一个层次的含义描述的是一种授权管理行为，通常需要安全管理员的参与；而第二层含义描述的是一种自动化的访问控制操作行为，是由计算机系统自动实施的。</p> 
<h6><a id="5__21"></a>5. 访问控制</h6> 
<p>指在鉴别用户的合法身份后，通过某种途径显式地准许或限制用户对数据信息的访问能力及范围，阻止未经授权的资源访问，包括阻止以未经授权的方式使用资源。当主体提出资源访问请求时，系统必须先要确认是合法的主体，而不是假冒的欺骗者，也就是对主体进行鉴别（也称认证）的过程。主体通过鉴别以后，就会获得一个主体标识用来区别其身份，此时系统才能根据预设的访问控制策略来判定主体是否拥有权限对客体执行访问动作。该定义说明，授权管理过程往往发生在访问控制之前，前者是后者的执行依据。</p> 
<h5><a id="_ACLCL_25"></a>二. 访问矩阵，访问控制列表(ACL)，能力列表(CL)</h5> 
<h6><a id="1__27"></a>1. 访问矩阵</h6> 
<p>行对应主体，列对应客体，矩阵元素定义了主体可以对客体执行的访问操作。</p> 
<h6><a id="2_ACL_31"></a>2. ACL</h6> 
<p>记录允许访问客体的主体及允许的访问操作集合，针对客体。</p> 
<p>从主体的角度实施权限分配与管理困难。</p> 
<h6><a id="3_CL_37"></a>3. CL</h6> 
<p>记录主体定义允许访问的所有客体及对应的访问操作，针对主体。</p> 
<blockquote> 
 <p>感觉访问控制并不侧重资源产生者，而是侧重访问主体，客体和策略。资源产生者不体现，而体现在制定的策略中。</p> 
</blockquote> 
<p>有学者通过研究提出，ACL方法和CL方法可以结合使用。在分布式系统中，这种混合的方法可以避免重复的用户认证。主要的原理是：<strong>由系统中的服务提供对客体的管理，用户如果要访问客体，将在通过认证后获得一个CL，通过使用该CL中描述的主体允许访问服务的能力来访问系统中的服务，服务则可以依据ACL进一步实施细粒度的访问控制。</strong></p> 
<blockquote> 
 <p>CL讲真可以通过zxy_ABE实现。<s>一种思路：将发放CL的过程以zxy_CP-ABE的方式写入交易中，用户自行获得CL，访问服务。服务由所有者保管，所有者可以自行实现CL对应的细粒度访问控制，然后发给用户，用户使用自己的CL对之进行解密获取权限。（自黑：没有改变方法的原理，只是提出了一种可行方案，而且实际上没有上链的必要。）</s></p> 
 <p><s>或许可以让服务集群上链？感觉类似知识产权的细粒度保护，GitHub或区块链？区块链实现知识产权的细粒度保护可以研究一下。感觉上链还是不靠谱，讲真没有办法做到我目前方案的非传播性访问控制，也就是如果资源不被允许再授权，放到链上是很难保证这一点的安全的。如果不上链的话服务集群还是要交给第三方保管，那么或许可以选择代理？我们抛开公有链的场景，假设是联盟链or私有链，那么可以选取可信代理进行服务集群的托管？类似工作量证明里的将工作量替换为存储资源？（自黑：没有必要。因为服务对客体的细粒度控制不可能让大家讨论来决定。）</s></p> 
 <p>等等，如果访问控制针对的是资源，那么真的没办法控制不被传播；但如果是某种行为或特权，是否可以实现不被传播呢。首先，访问控制是授予主体对资源的读写执行权限，写权限可以让全网验证是否有写权限从而更改资源内容。所以我们要对客体进行分类，客体包括资源，行为，特权，服务等，然后针对性地设想访问控制场景。</p> 
 <p>So… 我需要上链的场景是什么？</p> 
 <p>场景：首先，主体是用户，而不是进程和设备等。客体是服务，行为等动态变化的资源（静态资源上链意义不大）；其次，授权主体与访问主体可能是跨域的，因而客体和访问策略需要放在网络上传播（或许用访问策略对客体加密？），访问者满足访问策略获得权限，可以对客体执行相应操作提交给所有者，所有者可对客体进行相应的操作，从而使后续得到该客体的主体都能得到最新的客体。</p> 
 <p>如果将客体的更新过程交给区块链来完成，即区块链中每个节点都保存着对客体的所有合法操作过程和最新结果，访问主体在访问客体时能够得到最新客体，区块链使得对客体的操作过程可追溯，且需多方验证超过51%才被全网认可。</p> 
 <p>上链的价值需要体现在对资源的操作需要多方认可才得以执行，那么适用的具体场景—多方协作，所以<strong>用区块链做GitHub的中心化托管会更好吗？知识产权目前的问题是什么？（Q1）</strong></p> 
 <p>我们<strong>是否可以将权限直接加到资源上，比如多根访问树之类的？（Q2）</strong></p> 
 <p>是否可以跳出区块链的局限，将区块链中用某个技术解决某个问题的思想应用到我们需要的场景，重新建构安全框架？-总结一下<strong>区块链各技术意义所在，是否缺一不可/可以改进。（Q3）</strong></p> 
</blockquote> 
<h6><a id="4_ACLCL_63"></a>4. ACL与CL实现技术的特点对比</h6> 
<p><img src="https://images2.imgbox.com/0c/33/01eyn96I_o.png" alt="img"></p> 
<blockquote> 
 <p>了解到将权限分配给主体和客体带来的某些方面的便利和另一些方面的困难，两种方法没有绝对的好坏，因此在设计方案时，应该根据场景权衡利弊。</p> 
</blockquote> 
<h5><a id="__69"></a>三. 访问控制模型</h5> 
<h6><a id="1_DAC_model_71"></a>1. 自主访问控制模型（DAC model）</h6> 
<ul><li> <p>将用户权限与用户直接对应-较高访问效率与灵活度</p> </li><li> <p>客体拥有者持有对该客体的完全控制权</p> </li><li> <p>权限传播可控性差</p> </li><li> <p>用户可以自主地把自己所拥有的客体的访问权限授予用户组其他用户，例如Linux和Windows系统中客体拥有者对自己所属用户组进行授权管理的操作。</p> </li></ul> 
<blockquote> 
 <p>有些场景是需要权限可传播的，会带来极大的灵活性，但对于某些场景就是灾难，因此需要尽量做到"可控”。</p> 
</blockquote> 
<h6><a id="2_MAC_82"></a>2. 强制访问控制（MAC）</h6> 
<ul><li> <p>依据主体和客体的安全级别实施权限管理</p> </li><li> <p>通过控制信息的单向流动来防止信息扩散</p> </li></ul> 
<h6><a id="3_RBAC_88"></a>3. 基于角色的访问控制（RBAC）</h6> 
<p>上述两者对于权限的授权变动工作繁琐，且容易引发安全漏洞</p> 
<p>角色是指一个可以完成一定事务的命名组。事务是指一个完成一定功能的过程。用户能被指派到哪些角色受时间，地点，事件等诸多因素的影响。</p> 
<p>将对客体对象的访问权限授予角色而非用户，再为用户分配角色，用户通过角色获得访问权限。</p> 
<blockquote> 
 <p>感觉像ABE了，但角色和属性还是不太一样吧。角色或许是属性的集合？从这个角度来看和ABE很像。</p> 
</blockquote> 
<h6><a id="4_TBAC_98"></a>4. 基于任务的访问控制（TBAC）</h6> 
<p>从工作流处理角度解决安全问题，即任务执行过程中用户和权限都在变化中，因此提供了一种动态实时的安全管理。</p> 
<p>五元祖（S,O,P,L,AS），引入授权步(AS)与生命期(L)，因此权限的使用是有时效性的</p> 
<p>适用于<strong>分布式计算</strong>和多点访问控制的信息处理控制以及在工作流，分布式处理和事务管理系统中的访问控制。</p> 
<blockquote> 
 <p>基于任务的访问控制可以用于分布式计算！也就是说，联邦学习和访问控制是可以结合的？？？</p> 
 <p>我理解的联邦学习大约是任务分发，各节点在本地训练，然后由一个中心汇总训练结果参数，再分发下去，如此几个轮次，得到系统最终模型参数。</p> 
 <p>算是分布式AI，也就是分布式多方计算模型参数的问题，在机器学习模型训练的过程中，某个阶段需要多方协作训练模型，而该问题是跨域的。也就是比方说，同一个模型，需要多方的训练与优化来完成，在每一个轮次/阶段，都需要多方的协作，在这个过程中需要对资源有一定的管理。目前这个管理是通过可信第三方来做的，这其实也带来了不信任的问题。假设我们将对资源的管理自动化（如智能合约），将对资源的操作上链，那<strong>是否需要引入访问控制实现对资源在各阶段的控制呢，也就是是否需要基于任务的访问控制。（Q3）</strong></p> 
</blockquote> 
<h5><a id="__112"></a>四. 跨域访问控制</h5> 
<p>在开放的互联网中，由于参与主体数量规模大、运行环境的异构性、活动目标的动态性以及自主性等特点，各资源主体往往隶属于不同的权威管理机构，使基于身份的访问控制技术在跨多安全域进行授权及访问控制时显得力不从心，暴露出许多弱点。-&gt;需要可信第三方</p> 
<blockquote> 
 <p>经常说跨域场景适合上链。这里或将可以上链。可以根据前文提到的多方协作（GitHub），知识产权细粒度保护，联邦学习场景进行思考。</p> 
</blockquote> 
<h5><a id="__118"></a>五. 小结</h5> 
<h6><a id="Q_120"></a>Q</h6> 
<ol><li> <p>通过访问控制实现多方协作中主体对客体的合法操作，将操作上链。用区块链代替Github的中心化托管，这样会更好吗？知识产权的细粒度保护是指什么？</p> 
  <blockquote> 
   <p>区块链取代Github进行多方协作的优点无非是防止单点失效，但是面临的是公链，恐怕不如GitHub本身。或者说，多方协作面临的是一个第三方不完全可信的环境，在这种环境下就需要公开可追溯可审计的管理，同时没有单点失效的问题当然是锦上添花，这样子的多方协作才有足够的上链需求。</p> 
   <p>而这样其实也是和联邦学习可以联系起来的。在这种环境下，访问控制就作为一种对资源的保护存在。</p> 
  </blockquote> </li><li> <p>在1的方案中，我们要将对资源的操作上链，那么资源及操作的读写执行权限都要进行相应的保护，映射到ABE的秘密共享，就是要构造多根访问树对资源加密？</p> 
  <blockquote> 
   <p>实际上，只需要对不同的权限（读，写，执行）分配不同的密钥，在主体提交对客体的操作时证明自己的身份（拥有某种权限的密钥）即可。可以将三种权限附加到资源前。</p> 
  </blockquote> </li><li> <p>联邦学习+访问控制：在机器学习模型训练的过程中，某个阶段需要多方协作训练模型，而该问题是跨域的。也就是比方说，同一个模型，需要多方的训练与优化来完成，在每一个轮次/阶段，都需要多方的协作，在这个过程中需要对资源有一定的管理。目前这个管理是通过可信第三方来做的，这其实也带来了不信任的问题。假设我们将对资源的管理自动化（如智能合约），将对资源的操作上链，那是否需要引入访问控制实现对资源在各阶段的控制呢，也就是是否需要基于任务的访问控制。</p> 
  <blockquote> 
   <p>访问控制的使用需求还需思考。</p> 
  </blockquote> </li></ol> 
<h6><a id="A_136"></a>A</h6> 
<p><strong>场景</strong>：多方协作，如知识产权细粒度保护，联邦学习。</p> 
<p><strong>需求</strong>：</p> 
<ol><li>跨域；</li><li>第三方中心不完全可信 -&gt; 面临单点失效的问题；</li><li>对资源的操作和管理需要公开，可追溯，可审计；</li><li>对资源的操作有读，写，执行权限限制。</li></ol> 
<p><strong>方案</strong>：</p> 
<ol><li>发布资源时附带加密后的权限一起公布；</li><li>将对资源的操作上链，上链时验证权限；</li><li>增量式计算资源最新状态。</li></ol> 
<p>其中，资源映射为访问控制模型中动态的客体。</p> 
<h3><a id="__lz_156"></a>访问控制 + lz</h3> 
<h5><a id="1__158"></a>1. 多方协作（如知识产权）</h5> 
<blockquote> 
 <p>场景：所有人都可以读，但是只有有权限的人可以编辑</p> 
 <p>有两条链：权限链与修改链</p> 
</blockquote> 
<ol><li> <p>发布内容</p> <p>内容发布者发布原始文稿page，附加写(w)权限密钥树（ABE/IBE等方法构建树），写权限公钥(w_pub)，一个指向修改id的指针。将该文稿原始信息作为交易与其他交易打包进区块上链。</p> </li><li> <p>多方协作</p> <p>Alice拥有该文稿的写权限，在区块链中找到该文稿相关信息，从密钥树中解得写权限密钥(w_pri)，对文稿进行相应的更改后，用w_pri对更改信息的hash 进行加密(w_hash)，打包上该文稿修改id对应的区块链。</p> <p>验证过程：全网节点使用w_pub对w_hash信息进行解密，若与更改信息的hash相等则将其上链。</p> </li></ol> 
<blockquote> 
 <p>场景：拥有读权限的人才可以读，拥有写权限的人才可以编辑</p> 
 <p>有两条链：权限链与修改链</p> 
</blockquote> 
<ol><li> <p>发布内容</p> <p>内容发布者发布原始文稿page，附加读(r，可为空)，写(w)权限密钥树（ABE/IBE等方法构建树，其中优先级w_pri&gt;r_key，r_key是对称密钥，w_pri是非对称密钥），写权限公钥(w_pub)。page由r_key加密，有一个指向修改id的指针。将该文稿原始信息作为交易与其他交易打包进区块上链。</p> </li><li> <p>多方协作</p> <p>Alice拥有该文稿的写权限，在区块链中找到该文稿相关信息，从密钥树中解得读权限密钥(r_key)，写权限密钥(w_pri)，通过r_key解密page，进行相应更改，将更改的信息使用r_key进行加密，并用w_pri对文稿hash 进行加密，得w_hash，打包上该文稿修改id对应的区块链。</p> <p>验证过程：全网使用w_pub对w_hash信息进行解密，若与更改信息的hash相等则将其上链。</p> </li></ol> 
<h5><a id="2__188"></a>2. 联邦学习</h5> 
<blockquote> 
 <p>有两条链：权限链与修改链</p> 
</blockquote> 
<ol><li> <p>发布内容</p> <p>类似多方协作，将机器学习模型和规则上链，有读，写密钥；</p> </li><li> <p>联邦学习</p> <p>类似多方协作，将训练结果（参数的更新）上链，大家通过验证写权限上修改链，对于参数等资源各取所需。</p> </li></ol> 
<blockquote> 
 <p>在机器学习模型训练的过程中，某个阶段需要多方协作训练模型，而该问题是跨域的。也就是比方说，同一个模型，需要多方的训练与优化来完成，在每一个轮次/阶段，都需要多方的协作，在这个过程中需要对资源有一定的管理。目前这个管理是通过可信第三方来做的，这其实也带来了不信任的问题。假设我们将对资源的管理自动化（如智能合约），将对资源的操作上链，那是否需要引入访问控制实现对资源在各阶段的控制呢，也就是是否需要基于任务的访问控制。</p> 
</blockquote> 
<h5><a id="3_lz__202"></a>3. lz: 跨层授权，隐形推理</h5> 
<blockquote> 
 <p>跨层授权，隐形推理，自动判断计算规则，漏权/错权/滥权检测，增加维度</p> 
 <p>跨层授权，隐形推理等内容主要涉及读写权限的发放过程，即如何构造读写权限密钥</p> 
</blockquote> 
<p>思路：增加指向资源的指针，“权限密钥-指针-资源”，资源所有者将对权限的操作转化为对权限密钥的操作，将操作上链，并将指针指向最新权限密钥。</p> 
<ol><li> <p>发放权限</p> <p>ABE/IBE，将构造的密钥树与指向权限的指针上链。</p> </li><li> <p>更新权限</p> <p>构造新的访问树，将指向权限的指针指向这棵树。</p> </li><li> <p>获取权限</p> <p>在设备加入时获得对应属性的值，从链上找到权限的最新访问树，计算对应密钥。</p> </li></ol> 
<h5><a id="_223"></a>参考文献</h5> 
<p>【1】<a href="http://www.sohu.com/a/255057665_653604" rel="nofollow">网络安全之访问控制</a></p> 
<p>【2】<a href="https://baike.baidu.com/item/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF/5652430" rel="nofollow">访问控制技术百度百科</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/40423d8c61e1bdeb8c0e503b5619daf6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VIM查看文章快捷键</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1a09baad12ff07c0c7e32e2b95d1371/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql查询学号和姓名_数据库SQL语句中 查询选修了全部课程的学生的学号和姓名...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>