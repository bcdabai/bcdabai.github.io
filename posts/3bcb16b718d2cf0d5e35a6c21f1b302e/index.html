<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>树形DP求树的直径 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="树形DP求树的直径" />
<meta property="og:description" content="思路： 非常套路性的一个东西，记录一下，防止遗忘
设\(f[i]\)表示以\(i\)为根，到其子树的叶节点的最大距离。
考虑如何用子节点更新父节点，
当前点到叶节点的最大距离=max{子节点到叶节点的距离&#43;当前点到子节点的距离}。
设\(u\)为当前节点，\(v\)为\(u\)的子节点，\(dis(u,v)\)是从\(u-&gt;v\)这条路径上的距离
得到转移方程：
\[f[u]=max\{f[v]&#43;dis(u,v)\}\]
如何维护以\(u\)为根的子树中的直径呢
以\(u\)为根子树的直径=max{u到叶节点的最大距离&#43;子节点到叶节点的最大距离&#43;\(u\)到叶节点的距离}
然后我们钦定一个节点为根，比如1
得到转移方程：
\[ans=max\{f[u]&#43;f[v]&#43;dis(u,v)\}\]
\(ans\)即为树的直径
需要注意的是，我们要在更新\(f[u]\)之前更新\(ans\)，因为从u经过v到叶节点的路径是最长的路径，这样这条路径会被更新两次
这样做一定会选出u到叶节点最长的两条路径
分类讨论一下
更新\(f[u]\)的路径是\(u\)到叶节点的所有路径中最长的，次长的还未被选，那它会和次长（相等）的一同更新最大值更新\(f[u]\)的路径是\(u\)到叶节点的所有路径中次长的，最长的还未被选，那它会和最长的一同更新最大值更新\(f[u]\)路径不是最长也不是次长，那么\(f[u]\)就会被最长或次长的路径更新，然后在转化成上两种情况 代码 void dfs(int u, int fa) { for (int i = head[u]; ~i; i = e[i].nx) { int v = e[i].v; if (v == fa) continue; dfs(v, u); ans = max(ans, f[u] &#43; f[v] &#43; e[i].w); f[u] = max(f[u], f[v] &#43; e[i].w); } } 练手题 #10155. 「一本通 5.2 例 3」数字转换
边权全为1的树的直径" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3bcb16b718d2cf0d5e35a6c21f1b302e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-17T11:15:00+08:00" />
<meta property="article:modified_time" content="2019-07-17T11:15:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">树形DP求树的直径</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h3 id="思路">思路：</h3> 
 <p>非常套路性的一个东西，记录一下，防止遗忘<br> 设<span class="math inline">\(f[i]\)</span>表示以<span class="math inline">\(i\)</span>为根，到其子树的叶节点的最大距离。</p> 
 <p>考虑如何用子节点更新父节点，<br> 当前点到叶节点的最大距离=max{子节点到叶节点的距离+当前点到子节点的距离}。</p> 
 <p>设<span class="math inline">\(u\)</span>为当前节点，<span class="math inline">\(v\)</span>为<span class="math inline">\(u\)</span>的子节点，<span class="math inline">\(dis(u,v)\)</span>是从<span class="math inline">\(u-&gt;v\)</span>这条路径上的距离<br> 得到转移方程：<br><span class="math display">\[f[u]=max\{f[v]+dis(u,v)\}\]</span></p> 
 <p>如何维护以<span class="math inline">\(u\)</span>为根的子树中的直径呢<br> 以<span class="math inline">\(u\)</span>为根子树的直径=max{u到叶节点的最大距离+子节点到叶节点的最大距离+<span class="math inline">\(u\)</span>到叶节点的距离}<br> 然后我们钦定一个节点为根，比如1<br> 得到转移方程：<br><span class="math display">\[ans=max\{f[u]+f[v]+dis(u,v)\}\]</span><br><span class="math inline">\(ans\)</span>即为树的直径<br> 需要注意的是，我们要在更新<span class="math inline">\(f[u]\)</span>之前更新<span class="math inline">\(ans\)</span>，因为从u经过v到叶节点的路径是最长的路径，这样这条路径会被更新两次</p> 
 <p>这样做一定会选出u到叶节点最长的两条路径<br> 分类讨论一下</p> 
 <ul><li>更新<span class="math inline">\(f[u]\)</span>的路径是<span class="math inline">\(u\)</span>到叶节点的所有路径中最长的，次长的还未被选，那它会和次长（相等）的一同更新最大值</li><li>更新<span class="math inline">\(f[u]\)</span>的路径是<span class="math inline">\(u\)</span>到叶节点的所有路径中次长的，最长的还未被选，那它会和最长的一同更新最大值</li><li>更新<span class="math inline">\(f[u]\)</span>路径不是最长也不是次长，那么<span class="math inline">\(f[u]\)</span>就会被最长或次长的路径更新，然后在转化成上两种情况</li></ul> 
 <h3 id="代码">代码</h3> 
 <pre><code class="language-cpp"><code>void dfs(int u, int fa) {
    for (int i = head[u]; ~i; i = e[i].nx) {
        int v = e[i].v;
        if (v == fa) continue;
        dfs(v, u);
        ans = max(ans, f[u] + f[v] + e[i].w);
        f[u] = max(f[u], f[v] + e[i].w);
    }
}</code></code></pre> 
 <h3 id="练手题">练手题</h3> 
 <p><a href="https://loj.ac/problem/10155" rel="nofollow">#10155. 「一本通 5.2 例 3」数字转换</a><br> 边权全为1的树的直径</p> 
 <pre><code class="language-cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1e5 + 10;

int n, m, num, ans;

int head[N], f[N];

struct node {
    int nx, v;
} e[N];

inline int sum(int x) {
    int tmp = 1;
    for (int i = 2; i * i &lt;= x; ++i) if (x % i == 0) {
        tmp += i;
        if (x / i != i) tmp += x / i; 
    }
    return tmp;
}

inline void add(int u, int v) {
    e[++num].nx = head[u], e[num].v = v, head[u] = num;
}

void dfs(int u, int fa) {
    for (int i = head[u]; ~i; i = e[i].nx) {
        int v = e[i].v;
        if (v == fa) continue;
        dfs(v, u);
        ans = max(ans, f[u] + f[v] + 1);
        f[u] = max(f[u], f[v] + 1);
    }
}

int main() {
    ios::sync_with_stdio(false);
    memset(head, -1, sizeof head);
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; ++i) if (sum(i) &lt; i) 
        add(sum(i), i), add(i, sum(i));
    dfs(1, 0);
    cout &lt;&lt; ans;
}</code></code></pre> 
</div> 
<p>转载于:https://www.cnblogs.com/lykkk/p/11199812.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c48f87c9be101f37769f7d3c0585a44d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java在Map中存放重复key</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dfcf2ba6643f0cae1916bacdf8a94297/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android中JNI&amp;NDK入门(四) 之 使用CMake方式编译NDK</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>