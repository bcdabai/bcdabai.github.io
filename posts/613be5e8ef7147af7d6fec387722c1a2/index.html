<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CString 与 LPCWSTR、LPSTR、char*、LPWSTR 等类型的转换 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CString 与 LPCWSTR、LPSTR、char*、LPWSTR 等类型的转换" />
<meta property="og:description" content="From：https://www.cnblogs.com/leanee/articles/2940088.html
char [] 到 LPWSTR转换的一个具体应用：http://www.cppblog.com/lateCpp/articles/153358.html
CString详细讲解：https://blog.csdn.net/qq_41786318/article/details/81989217
CString 应用操作指南【转】：https://blog.csdn.net/iteye_13411/article/details/82092838
VS2010/MFC编程入门之四十二（MFC常用类：CString类）
http://www.jizhuomi.com/software/228.html
因为 C&#43;&#43; 支持两种字符串 ：
1. 常规的 ANSI 编码（使用 &#34;&#34; 包裹）2. Unicode 编码（使用 L&#34;&#34; 包裹） UNICODE 宏 和 _UNICODE 宏 （Windows 核心编程 第五版 2.4 节）
这样对应的就有了两套字符串字符串处理函数，比如：strlen 和 wcslen，分别用于处理两种字符串。微软将这两套字符集及其操作进行了统一，通过条件编译（通过 _UNICODE 和 UNICODE 宏）控制实际使用的字符集，这样就有了 _T(&#34;&#34;) 这样的字符串，对应的就有了_tcslen 这样的函数。为了存储这样的通用字符，就有了TCHAR：
当 没有定义 _UNICODE宏 时，TCHAR = char，_tcslen = strlen当 定义 _UNICODE宏 时，TCHAR = wchar_t ， _tcslen = wcslen[1] 当我们定义了 UNICODE宏，就相当于告诉了编译器：我准备采用 UNICODE 版本。这个时候，TCHAR 就会摇身一变，变成了wchar_t 。而未定义 UNICODE宏 时，TCHAR 摇身一变，变成了unsigned char。这样就可以很好的切换宽窄字符集。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/613be5e8ef7147af7d6fec387722c1a2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-13T18:07:40+08:00" />
<meta property="article:modified_time" content="2019-10-13T18:07:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CString 与 LPCWSTR、LPSTR、char*、LPWSTR 等类型的转换</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p>From：<a href="https://www.cnblogs.com/leanee/articles/2940088.html" rel="nofollow">https://www.cnblogs.com/leanee/articles/2940088.html</a></p> 
<p>char [] 到 LPWSTR转换的一个具体应用：<a href="http://www.cppblog.com/lateCpp/articles/153358.html" rel="nofollow">http://www.cppblog.com/lateCpp/articles/153358.html</a></p> 
<p>CString详细讲解：<a href="https://blog.csdn.net/qq_41786318/article/details/81989217">https://blog.csdn.net/qq_41786318/article/details/81989217</a></p> 
<p>CString 应用操作指南【转】：<a href="https://blog.csdn.net/iteye_13411/article/details/82092838">https://blog.csdn.net/iteye_13411/article/details/82092838</a></p> 
<p>VS2010/MFC编程入门之四十二（MFC常用类：CString类）<br><a href="http://www.jizhuomi.com/software/228.html" rel="nofollow">http://www.jizhuomi.com/software/228.html</a></p> 
<p> </p> 
<p> </p> 
<p>因为 C++ 支持两种字符串 ：</p> 
<ul><li>1. 常规的 ANSI 编码（使用 "" 包裹）</li><li>2. Unicode 编码（使用 L"" 包裹）</li></ul> 
<p> </p> 
<p><span style="color:#f33b45;"><strong>UNICODE 宏 和 _UNICODE 宏 （</strong></span><span style="color:#7c79e5;"><strong>Windows 核心编程 第五版 2.4 节</strong></span><span style="color:#f33b45;"><strong>）</strong></span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/82/15/lbzTdrkA_o.png"></p> 
<p>这样对应的就有了两套字符串字符串处理函数，比如：strlen 和 wcslen，分别用于处理两种字符串。微软将这两套字符集及其操作进行了统一，通过条件编译（通过 _UNICODE 和 UNICODE 宏）控制实际使用的字符集，这样就有了 _T("") 这样的字符串，对应的就有了_tcslen 这样的函数。为了存储这样的通用字符，就有了TCHAR：</p> 
<ul><li>当 没有定义  _UNICODE宏 时，TCHAR = char，_tcslen = strlen</li><li>当 定义 _UNICODE宏 时，TCHAR = wchar_t ， _tcslen = wcslen[1]</li></ul> 
<p>当我们定义了 UNICODE宏，就相当于告诉了编译器：我准备采用 UNICODE 版本。这个时候，TCHAR 就会摇身一变，变成了wchar_t 。而未定义 UNICODE宏 时，TCHAR 摇身一变，变成了unsigned char。这样就可以很好的切换宽窄字符集。<br> tchar 可用于双字节字符串，使程序可以用于中日韩等国 语言文字处理、显示。使编程方法简化。</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/75/5b/RRLzsEP5_o.png"></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/1e/eb/LQNVFCQX_o.png"></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/53/dc/Rpf43UnQ_o.png"></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/ee/11/EGz6tKCR_o.png"></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/d1/ff/p0cKGSS4_o.png"></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/e9/23/aZectO3i_o.png"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2>C++ 中的 wchar_t 数据类型</h2> 
<p> </p> 
<p>标准里面是这样解释的：<strong>Wide character ( 宽字节字符 )</strong><br> Type whose range of values can represent distinct codes for all members of the largest extended character set specified among the supported locales.<br> In C++, wchar_t is a distinct fundamental type (and thus it is not defined in &lt;cwchar&gt; nor any other header).<br><span style="color:#f33b45;"><strong>在 C++ 中，wchar_t 是一个特有的基本类型</strong></span>（ 因此它并没有在 &lt;cwchar&gt; 或其他 header 中被定义）<br> In C, this is a typedef of an integral type.(<span style="color:#f33b45;"> <strong>在 C 中，wchar_t 是一个整数类型的 typedef </strong></span>)</p> 
<p>wchar_t  是 C/C++ 的字符类型，一种扩展的存储方式，主要用在国际化程序的实现中。<br> char 是8位字符类型，最多能包含256种字符，许多的外文字符集所包含的字符数目超过256个，char 型不能表示。比如对于汉字，韩文以及日文这样的字符，它们的每一个文字都占据两个字节，<strong>所以 C++ 提出了 wchar_t 类型，也称为双字节类型，或宽字符类型。</strong></p> 
<p>截图来自：<strong><span style="color:#7c79e5;">windows 核心编程 第五版 第二章</span><span style="color:#f33b45;"> 2.2 ANSI字符和Unicode字符与字符串数据类型</span></strong></p> 
<p style="text-align:center;"><img alt="" class="has" height="184" src="https://images2.imgbox.com/c1/ee/63cENsNK_o.png" width="1200"></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/c4/ff/g3bwTvqE_o.png"></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/7b/e6/I0qWszr8_o.png"></p> 
<p>示例代码：</p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;locale&gt;           //setlocale函数在locale头文件中定义
using namespace std;
int main()
{
	//使用setlocale函数将本机的语言设置为中文简体
	//LC_ALL表示设置所有的选项（包括金融货币、小数点，时间日期格式、语言字符串的使用习惯等），chs表示中文简体
	setlocale(LC_ALL, "chs");
	wchar_t wt[] = L"中国伟大复兴梦";   //大写字母L告诉编译器为"中"字分配两个字节的空间
	wcout &lt;&lt; wt &lt;&lt; endl;               //使用wcout来代替cout输出宽字符
	return 0;
}</code></pre> 
<p> </p> 
<p> </p> 
<h2><span style="color:#7c79e5;"><strong>LPSTR</strong></span>、<span style="color:#7c79e5;">LPCSTR</span>、<span style="color:#7c79e5;">LPTSTR </span>和 <span style="color:#7c79e5;">LPCTSTR </span>的意义及区别</h2> 
<p> </p> 
<ul><li>1、<strong>ANSI（ 即 MBCS ）</strong>：为 <strong>多字节字符集</strong>，<span style="color:#86ca5e;"><strong>它是不定长表示世界文字的编码方式。ANSI 表示英文字母时就和 ASCII 一样，但表示其他文字时就需要用多字节。</strong></span></li><li>2、<strong>Unicode：用两个字节表示一个字符的编码方式</strong>。比如 字符  'A'  在 ASCII 下面用一个字节表示，而在 Unicode 下面用两个字节表示，其中高字节用 “0” 填充；中文字符  '程' 在 ASCII 下面用两个字节表示，而在 Unicode下面也是用两个字节表示。<span style="color:#f33b45;"><strong>Unicode 的用处就是定长表示世界文字</strong></span>，据统计，用两个字节可以编码现存的所有文字而没有二义。</li><li>3、Windows 下的程序设计可以支持 ANSI 和 Unicode 两种编码方法的字符串，具体使用哪种就要看定义了 MBCS宏 还是Unicode宏。MBCS宏 对应的字符串指针为 LPSTR（ 即 char* ），Unicode 对应的指针为 LPWSTR（ 即 unsigned char* ）。为了写程序的方便，微软定义了类型 LPTSTR，在 MBCS 下它表示 char*，在 Unicode 下它表示 unsigned char*，这就可以重定义一个宏进行不同字符集的转换了。</li><li>4、关系。<br>         LPSTR：   LPSTR = char*；  指向一个字符串的32位指针，每个字符占1个字节。<br>         LP<span style="color:#f33b45;"><strong>C</strong></span>STR： LPCSTR = const char*；指向一个常量字符串的32位指针，每个字符占1个字节。<br>         LP<span style="color:#f33b45;"><strong>T</strong></span>STR：指向一个字符串的32位指针，每个字符可能占1个字节或2个字节。<br>         LP<span style="color:#f33b45;"><strong>CT</strong></span>STR：指向一个常量字符串的32位指针，每个字符可能占1个字节或2个字节。        <br>                LPWSTR = wchar_t*；L            PCWSTR = const wchar_t*； <p><br> 多字节 编码： char，string，CStringA。<br> Unicode 编码：wchar_t，wstring，CStringW。<br> 注意：如果项目是 Unicode，那么 CString 就被定义为 CStringW，否则就是 CStringA。</p> <p>至于 LPCTSTR 也是根据项目字符集来定义为 LPCWSTR（Unicode）或 LPCSTR（多字节）。<br> OK，上面的定义很明显了，注意用的时候别弄混了，最好的方式是使用 wchar_t 和 wstring（ api大多使用 unicode，即使是多字节版本也是把多字节转成 unicode 再去调用 unicode 版 api ）</p> </li><li>5、Windows 使用两种字符集 ANSI 和 Unicode，前者在处理英文字符时使用单字节方式，在处理中文字符时使用双字节方式。后者不管是英文字符还是中文字符都是采用双字节方式表示。Windows NT的所有与字符有关的函数都提供了两种方式的版本，而 Windows 9x 只支持 ANSI 方式。_T 一般同字符常量相关，如 _T("你好！"); 。如果编码方式为 ANSI，_T 不起任何作用；如果编码方式为 Unicode，编译器会把 "你好！" 以 Unicode 方式进行保存。 _T 和 _L 的区别在于，_L 不管你是以什么方式编译，一律以 Unicode 方法保存。</li><li>6、L 表示 字符串 采用 Unicode 编码方式，<br>         示例如下：wchar_t Str[] = L"Hello World!";     // 每个字符都用2个字节来存储</li><li>7、_T 是一个适配宏。当定义了 _UNICODE 时，_T 和 L 相同；否则，_T 的字符串采用 ANSI 编码方式。<br>     示例如下：<br>         LPTSTR lptStr = new TCHAR[32];<br>         TCHAR* szBuf = _T("Hello");<br>     以上两个语句，无论是在 ANSI 编码方式，还是在 Unicode 编码方式下都是正确的。</li><li>8、微软推荐使用相匹配的字符串函数。例如，在处理 LPTSTR 或 LPCTSTR 的时候，应该使用 _tcslen 来替代 strlen 函数。否则，在 Unicode 编码方式下，strlen 不能处理 wchar_t* 的字符串。</li><li>9、<span style="color:#f33b45;"><strong>T 是一个非常重要的符号</strong></span><span style="color:#7c79e5;"><strong>（</strong></span><span style="color:#f33b45;"><strong>T</strong></span><span style="color:#7c79e5;"><strong>CHAR、LP</strong></span><span style="color:#f33b45;"><strong>T</strong></span><span style="color:#7c79e5;"><strong>STR、LPC</strong></span><span style="color:#f33b45;"><strong>T</strong></span><span style="color:#7c79e5;"><strong>STR、_T() 和 _TEXT() 等 ），</strong></span><span style="color:#f33b45;"><strong>它表示使用一个中间类型，既不明确表示使用 MBCS，也不明确表示使用 Unicode。到底使用哪种字符集，在编译的时候才决定。</strong></span></li><li>10、注意 L 和　_T 的使用方法。<br> 　　LPTSTR，LPCTSTR，及 _T(常量字符串) 受 _T 影响。<br> 　　介绍字符串类型：char， wchar_t，TCHAR， CHAR， WCHAR。<br> 　　TCHAR　的定义：<br> 　　#ifdef UNICODE <br> 　　    typedef wchar_t TCHAR; <br> 　　#else <br> 　　    typedef unsigned char TCHAR; <br> 　　#endif <br> 　　<br> 　　typedef unsigned char CHAR; <br> 　　typedef unsigned wchar_t WCHAR; <br> 　　<br><span style="color:#7c79e5;"><strong>由此可以看出，unsigned char 和　wchar_t 都是基本数据类型，CHAR 实施上就是 unsigned char， WCHAR 为 wchar_t ，而 TCHAR 根据是否支持 unicode 而不同。在程序中，可以用的名称有５种，unsigned char（CHAR），wchar_t（WCHAR），TCHAR，但为了扩展性和兼容性，推荐使用 TCHAR。</strong></span></li><li>11、CString 类型到 LPTSTR 类型的转换<br>         CString path1;<br>         LPTSTR path2 = path1.GetBuffer(path1.GetLenght());</li></ul> 
<p> </p> 
<p> </p> 
<h2>字符串 的 <span style="color:#f33b45;"><strong>ASCII </strong></span>和 <span style="color:#f33b45;"><strong>UNICODE </strong></span>之间的转换</h2> 
<p> </p> 
<p> </p> 
<p> Win32 提供了 API 函数 <strong><span style="color:#7c79e5;">MultiByteToWideChar</span> </strong>和 <span style="color:#7c79e5;"><strong>WideCharToMultiByte</strong> </span>来提供这种功能</p> 
<p> </p> 
<p><span style="color:#7c79e5;"><strong>char*</strong></span> 转换成 <span style="color:#7c79e5;"><strong>LPCTSTR</strong></span>。代码如下：</p> 
<p>int MultiByteToWideChar（）函数。根据 MSDN 描述，这个方法：This function maps a character string to a wide-character (Unicode) string。</p> 
<pre class="has"><code>char text[20] = "hello world";
TCHAR buffer[50];
MultiByteToWideChar(0, 0, text, -1, buffer, 20);


char ch[1024] = "hello world";
int num = MultiByteToWideChar(0,0,ch,-1,NULL,0);
wchar_t *wide = new wchar_t[num];
MultiByteToWideChar(0,0,ch,-1,wide,num);

解析：
num 获得长字节所需的空间
MultiByteToWideChar() 表示将 ch 中的字符传递到 wide 指向的内存中。
-1 表示传输至ch中的'\0'处，
num 表示传递的字节个数。</code></pre> 
<p><strong>总结：</strong>MultiByteToWideChar()函数，首先得用 TCHAR 来定义一个数组</p> 
<p>另外：<strong>网上有另外推荐将项目的 unicode 环境关掉，就可避免这个问题。不推荐，这实际上是回避问题。现在已经是 Unicode 的应用已经越来越广，程序不支持 Unicode 环境，走的了一时，走不了一世。</strong></p> 
<p> </p> 
<p><span style="color:#7c79e5;"><strong>LPCTSTR </strong></span>转换成 <strong><span style="color:#7c79e5;">char *</span></strong></p> 
<pre><code>wchar_t widestr[1024] = L"hello world";
int num = WideCharToMultiByte(CP_OEMCP, NULL, widestr, -1, NULL, 0, NULL, FALSE);
char *pchar = new char[num];
WideCharToMultiByte (CP_OEMCP, NULL, widestr, -1, pchar, num, NULL, FALSE);</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2>一. CString 与 LPCWSTR </h2> 
<p> </p> 
<p>        两者的不同：LPCWSTR 是 Unicode 字符串指针，初始化时串有多大，申请空间就有多大，以后存贮若超过则出现无法预料的结果，这是它与 CString 的不同之处。而 CString 是一个 字符串类，内存空间类会自动管理。</p> 
<p> </p> 
<h3>CString 转换成 LPCWSTR    </h3> 
<p>方法 1：</p> 
<pre class="has"><code>CString strFileName;
LPCWSTR lpcwStr = strFileName.AllocSysString();</code></pre> 
<p>方法 2：CString str=_T("TestStr");</p> 
<pre class="has"><code>CString str=_T("TestStr"); 
USES_CONVERSION; 
LPCWSTR lpcwStr = A2CW((LPCSTR)str);</code></pre> 
<p>        MFC 中 CString 和 LPSTR 是可以通用，其中 A2CW 表示 (LPCSTR)  -&gt; (LPCWSTR)，USER_CONVERSION 表示用来定义一些中间变量，在使用 ATL 的转换宏之前必须定义该语句。</p> 
<p> </p> 
<h3>LPCWSTR 转换成 CString</h3> 
<pre class="has"><code>LPCWSTR lpcwStr = L"TestWStr"; 
CString str(lpcwStr);</code></pre> 
<p> </p> 
<p> </p> 
<h2>二. CString 与 LPSTR 转换</h2> 
<p> </p> 
<h3>CString 转换成 LPSTR</h3> 
<p>方法一：</p> 
<pre class="has"><code>CString strFileName;
LPSTR lpStr = strFileName.GetBuffer();
strFileName.ReleaseBuffer();</code></pre> 
<p>方法二：</p> 
<pre class="has"><code>CString strFileName;
LPSTR lpStr = (LPSTR)(LPCSTR)strFimeName;</code></pre> 
<p> </p> 
<h3>LPSTR 转换成 CString</h3> 
<pre class="has"><code>LPSTR lpStr = L"TestStr"; 
CString str(lpStr);</code></pre> 
<p>注意：CString 和 LPCSTR 可直接转换，如下:</p> 
<pre class="has"><code>CString str;
LPCSTR lpcStr = (LPCSTR)str;</code></pre> 
<p> </p> 
<p> </p> 
<h2>三. CString 和 char* 转换</h2> 
<p> </p> 
<h3>CString 转换成 char*</h3> 
<p>方法 1：</p> 
<pre class="has"><code>CString str;
char* p = str.GetBuffer();</code></pre> 
<p>方法 2：</p> 
<pre class="has"><code>CString str;
char* p = (LPSTR)(LPCSTR)str;</code></pre> 
<p> </p> 
<h3>char* 转换成 CString</h3> 
<pre class="has"><code>char* p = "test";
CString str = ("%s",p);</code></pre> 
<p> </p> 
<p> </p> 
<h2>四. String 和 int、float 的转换</h2> 
<p> </p> 
<p>可以使用 atoi、atof、atol 等函数来完成。</p> 
<p> </p> 
<p> </p> 
<h2>五. LPSTR (char*) 和 LPWSTR 的转换</h2> 
<p> </p> 
<p>可以使用下面的ATL宏来进行，<span style="color:#f33b45;"><strong>最好是将变量定义成 TCHAR、LPTSTR 等T类型，可以避免转换</strong></span>。</p> 
<p>ATL宏介绍：</p> 
<p>     A2BSTR   OLE2A             T2A            W2A <br>      A2COLE   OLE2BSTR    T2BSTR    W2BSTR <br>      A2CT         OLE2CA         T2CA          W2CA <br>      A2CW        OLE2CT         T2COLE    W2COLE <br>      A2OLE       OLE2CW       T2CW         W2CT <br>      A2T            OLE2T            T2OLE        W2OLE <br>      A2W           OLE2W          T2W             W2T</p> 
<p>    A ：ANSI 字符串，也就是 MBCS。 <br>     W、OLE 宽字符串，也就是 UNICODE。 <br>     T 中间类型T。如果定义了 _UNICODE，则T表示W；如果定义了 _MBCS，则T表示A <br>     C const 的缩写</p> 
<p>利用这些宏，可以快速的进行各种字符间的转换。使用前必须包含头文件，并且申明USER_CONVERSION；使用 ATL 转换宏，由于不用释放临时空间，所以使用起来非常方便。但是考虑到栈空间的尺寸（VC 默认2M），使用时要注意几点：</p> 
<p>    1、只适合于进行短字符串的转换； <br>     2、不要试图在一个次数比较多的循环体内进行转换； <br>     3、不要试图对字符型文件内容进行转换，因为文件尺寸一般情况下是比较大的； <br>     4、对情况 2 和 3，要使用 MultiByteToWideChar() 和 WideCharToMultiByte()；</p> 
<p> </p> 
<p>void Func1(LPSTR lpStr);</p> 
<p>void Func2(LPWSTR lpwStr);</p> 
<p>TCHAR   name[256];</p> 
<p>TCHAR*   pName = new  TCHAR[256];</p> 
<p>Func1(name); // Func1(pName);</p> 
<p>Func2(name); // Func2(pName);</p> 
<p>注意在VS2005中上面用红色标记的代码已经不成立。</p> 
<p>VS2005中CString已经改为宽字符型，一些转换如下：</p> 
<p>char name[10];<br>  TCHAR sex[5] ;<br>  char *p = name;<br>  TCHAR *pw = sex;</p> 
<p> LPSTR lpstr = name;<br>  LPCSTR lpcstr = name;<br>  lpcstr = lpstr;<br>  <br>  lpstr = p;<br>  p = (char*)sex;<br>  pw = (WCHAR*)name;<br>  LPWSTR lpwstr = (LPWSTR)lpstr;<br>  lpwstr = (LPWSTR)lpcstr;<br>  LPCWSTR lpcwstr = (LPCWSTR)lpstr;<br>  lpcwstr = (LPCWSTR)name;</p> 
<p> CString str(lpstr);<br>  CString str1(lpcstr);<br>  CString str2(lpwstr);<br>  CString str3(lpcwstr);<br>  CString str4(name);<br>  CString str5(sex);</p> 
<p> lpwstr = (LPWSTR)(LPCWSTR)str;<br>  lpstr = (LPSTR)(LPCWSTR)str;<br>  lpcstr = (LPCSTR)(LPCWSTR)str;</p> 
<p> p = (char*)str.GetBuffer();<br>  pw = str.GetBuffer();</p> 
<p>可以看出转换更加简单了，基本上可以直接转换，A2W 等宏基本上不需要啦。</p> 
<p> </p> 
<p> </p> 
<p>接下来就是转换：</p> 
<p>// C++<br> char*  到 string：string str("char"); 或者 string str = "char";<br> string 到 char*： const char* ch = str.c_str();<br> wchar_t* 和 wstring 与上相同。</p> 
<p>// MFC</p> 
<p>char* 到 CStringA：CStringA str("char");<br> CStringA 到 char*：const char* ch = str.operator LPCSTR(); <br> 注意：反对使用 GetBuffer，因为使用这个，必须要 ReleaseBuffer，而且很多时候没必要去分配空间<br> wchar_t* 和 CStringW 与上相同。</p> 
<p>// 字符集之间转换<br> char* 到 wchar_t*：CA2W a2w("char");  const wchar_t* wch = a2w.operator LPCWSTR();<br> wchar_t* 到 char*：CW2A w2a(L"wchar_t"); const char* ch = w2a.operator LPCSTR();  （注意：反对使用_T("chs")这种方式，程序字符集在一开始就该确定，而且最好选择Unicode）</p> 
<p>关于 CA2W 和 CW2A 这两个类，可以在 atlconv.h 中找到源代码，其实就是对 WideCharToMultiByte 和 MultiByteToWideChar 的封装。</p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a96c10daf383748b43d895e0aca5025/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FTP 主动模式与被动模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c85a17c8b3e6e0fb5a06858a81441bc7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">筛选重要特征的方法feature_importance_</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>