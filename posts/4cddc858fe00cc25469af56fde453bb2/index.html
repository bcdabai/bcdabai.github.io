<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ARMv7体系结构汇总 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ARMv7体系结构汇总" />
<meta property="og:description" content="文章目录 1 .处理器工作模式2. 处理器工作状态3. ARM寄存器3.1 通用寄存器3.2 状态寄存器3.3 备份的程序状态寄存器SPSR3.4 Thumb寄存器 4. ARM指令系统4.1 指令和指令格式4.2 指令的可选后缀S后缀!后缀 4.3指令的条件执行4.4 ARM指令分类 5 . ARM指令的寻址方式5.1 立即数寻址5.2 寄存器寻址5.3 寄存器间接寻址5.4 寄存器移位寻址5.5 基址变址寻址5.6 多寄存器寻址5.7 相对寻址5.8 堆栈寻址 6. 数据处理指令6.1 数据传送指令MOV指令MVN指令 6.2 移位操作1．LSL逻辑左移2．LSR逻辑右移3．ASR算术右移4．ROR循环右移5．RRX带扩展的循环右移 6.3 算术指令1. ADD 加法指令2. ADC带进位加法指令3. SUB减法指令4. SBC 带借位减法指令5. RSB 逆向减法指令6. RSC带借位的逆向减法指令 6.4 逻辑运算指令1. AND 逻辑与指令2. ORR 逻辑或指令3. EOR 逻辑异或指令4. BIC 位清除指令 6.5 比较指令1. CMP比较指令2. CMN反值比较指令3. TST位测试指令4. TEQ相等测试指令 6.6 乘法指令1. MUL 32位乘法指令2. MLA 32位乘加指令3. SMULL　64位有符号数乘法指令4. SMLAL　64位有符号数乘加指令5. UMULL 64位无符号数乘法指令6." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4cddc858fe00cc25469af56fde453bb2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-07T20:51:55+08:00" />
<meta property="article:modified_time" content="2022-05-07T20:51:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ARMv7体系结构汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1__2" rel="nofollow">1 .处理器工作模式</a></li><li><a href="#2__14" rel="nofollow">2. 处理器工作状态</a></li><li><a href="#3_ARM_23" rel="nofollow">3. ARM寄存器</a></li><li><ul><li><a href="#31__25" rel="nofollow">3.1 通用寄存器</a></li><li><a href="#32__38" rel="nofollow">3.2 状态寄存器</a></li><li><a href="#33_SPSR_63" rel="nofollow">3.3 备份的程序状态寄存器SPSR</a></li><li><a href="#34_Thumb_74" rel="nofollow">3.4 Thumb寄存器</a></li></ul> 
   </li><li><a href="#4_ARM_89" rel="nofollow">4. ARM指令系统</a></li><li><ul><li><a href="#41__91" rel="nofollow">4.1 指令和指令格式</a></li><li><a href="#42__152" rel="nofollow">4.2 指令的可选后缀</a></li><li><ul><li><a href="#S_154" rel="nofollow">S后缀</a></li><li><a href="#_168" rel="nofollow">!后缀</a></li></ul> 
    </li><li><a href="#43_188" rel="nofollow">4.3指令的条件执行</a></li><li><a href="#44_ARM_212" rel="nofollow">4.4 ARM指令分类</a></li></ul> 
   </li><li><a href="#5___ARM_230" rel="nofollow">5 . ARM指令的寻址方式</a></li><li><ul><li><a href="#51__232" rel="nofollow">5.1 立即数寻址</a></li><li><a href="#52___242" rel="nofollow">5.2 寄存器寻址</a></li><li><a href="#53__250" rel="nofollow">5.3 寄存器间接寻址</a></li><li><a href="#54__259" rel="nofollow">5.4 寄存器移位寻址</a></li><li><a href="#55__274" rel="nofollow">5.5 基址变址寻址</a></li><li><a href="#56__290" rel="nofollow">5.6 多寄存器寻址</a></li><li><a href="#57__312" rel="nofollow">5.7 相对寻址</a></li><li><a href="#58__325" rel="nofollow">5.8 堆栈寻址</a></li></ul> 
   </li><li><a href="#6__338" rel="nofollow">6. 数据处理指令</a></li><li><ul><li><a href="#61__362" rel="nofollow">6.1 数据传送指令</a></li><li><ul><li><a href="#MOV_372" rel="nofollow">MOV指令</a></li><li><a href="#MVN_387" rel="nofollow">MVN指令</a></li></ul> 
    </li><li><a href="#62__405" rel="nofollow">6.2 移位操作</a></li><li><ul><li><a href="#1LSL_424" rel="nofollow">1．LSL逻辑左移</a></li><li><a href="#2LSR_470" rel="nofollow">2．LSR逻辑右移</a></li><li><a href="#3ASR_487" rel="nofollow">3．ASR算术右移</a></li><li><a href="#4ROR_507" rel="nofollow">4．ROR循环右移</a></li><li><a href="#5RRX_524" rel="nofollow">5．RRX带扩展的循环右移</a></li></ul> 
    </li><li><a href="#63__541" rel="nofollow">6.3 算术指令</a></li><li><ul><li><a href="#1__ADD__557" rel="nofollow">1. ADD 加法指令</a></li><li><a href="#2__ADC_605" rel="nofollow">2. ADC带进位加法指令</a></li><li><a href="#3__SUB_620" rel="nofollow">3. SUB减法指令</a></li><li><a href="#4__SBC__634" rel="nofollow">4. SBC 带借位减法指令</a></li><li><a href="#5__RSB__649" rel="nofollow">5. RSB 逆向减法指令</a></li><li><a href="#6__RSC_663" rel="nofollow">6. RSC带借位的逆向减法指令</a></li></ul> 
    </li><li><a href="#64__675" rel="nofollow">6.4 逻辑运算指令</a></li><li><ul><li><a href="#1_AND__687" rel="nofollow">1. AND 逻辑与指令</a></li><li><a href="#2__ORR__700" rel="nofollow">2. ORR 逻辑或指令</a></li><li><a href="#3_EOR__712" rel="nofollow">3. EOR 逻辑异或指令</a></li><li><a href="#4_BIC__725" rel="nofollow">4. BIC 位清除指令</a></li></ul> 
    </li><li><a href="#65__739" rel="nofollow">6.5 比较指令</a></li><li><ul><li><a href="#1_CMP_751" rel="nofollow">1. CMP比较指令</a></li><li><a href="#2__CMN_764" rel="nofollow">2. CMN反值比较指令</a></li><li><a href="#3_TST_779" rel="nofollow">3. TST位测试指令</a></li><li><a href="#4_TEQ_792" rel="nofollow">4. TEQ相等测试指令</a></li></ul> 
    </li><li><a href="#66__808" rel="nofollow">6.6 乘法指令</a></li><li><ul><li><a href="#1___MUL_32_820" rel="nofollow">1. MUL 32位乘法指令</a></li><li><a href="#2__MLA_32_833" rel="nofollow">2. MLA 32位乘加指令</a></li><li><a href="#3__SMULL%E3%80%8064_846" rel="nofollow">3. SMULL　64位有符号数乘法指令</a></li><li><a href="#4__SMLAL%E3%80%8064_859" rel="nofollow">4. SMLAL　64位有符号数乘加指令</a></li><li><a href="#5__UMULL_64_872" rel="nofollow">5. UMULL 64位无符号数乘法指令</a></li><li><a href="#6__UMLAL_64_885" rel="nofollow">6. UMLAL 64位无符号数乘加指令</a></li></ul> 
   </li></ul> 
   </li><li><a href="#7__924" rel="nofollow">7. 数据加载与存储指令</a></li><li><ul><li><a href="#71_926" rel="nofollow">7.1数据加载与存储指令概述</a></li><li><a href="#72_1034" rel="nofollow">7.2单寄存器加载与存储指令</a></li><li><ul><li><a href="#1_LDRSTR_1046" rel="nofollow">1. LDR/STR字数据加载/存储指令</a></li><li><a href="#2__LDRBSTRB__1147" rel="nofollow">2. LDRB/STRB 字节数据加载/存储指令</a></li><li><a href="#4___LDRSBLDRSH____1223" rel="nofollow">4. LDRSB/LDRSH 有符号数字节/半字加载指令</a></li></ul> 
    </li><li><a href="#73_1243" rel="nofollow">7.3多寄存器加载与存储指令</a></li><li><ul><li><a href="#1_LDMSTM_1249" rel="nofollow">1. LDM/STM批量数据加载/存储指令</a></li><li><a href="#2_LDMSTM_1293" rel="nofollow">2. LDM/STM指令寻址的区别</a></li></ul> 
    </li><li><a href="#74__1331" rel="nofollow">7.4 堆栈操作</a></li><li><a href="#75_1398" rel="nofollow">7.5交换指令</a></li><li><ul><li><a href="#1_SWP_1416" rel="nofollow">1. SWP字数据交换指令</a></li><li><a href="#2_SWPB_1430" rel="nofollow">2. SWPB字节数据交换指令</a></li></ul> 
   </li></ul> 
   </li><li><a href="#8__1450" rel="nofollow">8. 分支指令</a></li><li><ul><li><a href="#1_B_1463" rel="nofollow">1. 分支指令B</a></li><li><a href="#2_BL_1494" rel="nofollow">2. 带返回的分支指令BL</a></li><li><a href="#3_BX_1525" rel="nofollow">3. 带状态切换的分支指令BX</a></li><li><a href="#4_BLX_1560" rel="nofollow">4. 带返回和状态切换的分支指令BLX</a></li></ul> 
   </li><li><a href="#9__1592" rel="nofollow">9. 程序状态寄存器访问指令</a></li><li><ul><li><a href="#1_MRS_1598" rel="nofollow">1. MRS程序状态寄存器到通用寄存器的数据传送指令</a></li><li><a href="#2_MSR_1624" rel="nofollow">2. MSR通用寄存器到程序状态寄存器的数据传送指令</a></li></ul> 
   </li><li><a href="#10__1673" rel="nofollow">10. 协处理器指令</a></li><li><ul><li><a href="#1_CDP_1682" rel="nofollow">1. CDP协处理器数据处理指令</a></li><li><a href="#2_LDC_1708" rel="nofollow">2. LDC协处理器数据加载指令</a></li><li><a href="#3_STC_1742" rel="nofollow">3. STC协处理器数据存储指令</a></li><li><a href="#4_MCR_ARM_1761" rel="nofollow">4. MCR ARM处理器寄存器到协处理器寄存器的数据传送指令</a></li><li><a href="#5MRCARM_1789" rel="nofollow">5.MRC协处理器寄存器到ARM处理器寄存器的数据传送指令</a></li></ul> 
   </li><li><a href="#11__1808" rel="nofollow">11. 软件中断指令</a></li><li><ul><li><a href="#1_SWI_1814" rel="nofollow">1. SWI软件中断指令</a></li><li><a href="#2SWI_1844" rel="nofollow">2．SWI的调用</a></li></ul> 
   </li><li><a href="#12__ARM_1907" rel="nofollow">12. ARM伪指令</a></li><li><ul><li><a href="#1_ADR___1917" rel="nofollow">1. ADR 小范围的地址读取伪指令</a></li><li><a href="#2_ADRL__1938" rel="nofollow">2. ADRL 中等范围的地址读取伪指令</a></li><li><a href="#3_LDR__1962" rel="nofollow">3. LDR 大范围的地址读取伪指令</a></li><li><a href="#4___NOP__2000" rel="nofollow">4. NOP 空操作伪指令</a></li></ul> 
   </li><li><a href="#13__Thumb_2017" rel="nofollow">13 . Thumb指令集</a></li><li><ul><li><ul><li><a href="#1__2019" rel="nofollow">1. 概述</a></li><li><a href="#2_Thumb_2021" rel="nofollow">2. Thumb指令寄存器的使用</a></li><li><a href="#3__ARMThumb_2023" rel="nofollow">3. ARM-Thumb交互</a></li><li><a href="#4__2025" rel="nofollow">4. 数据处理指令</a></li><li><a href="#5__2027" rel="nofollow">5. 单寄存器加载和存储指令</a></li><li><a href="#6___2029" rel="nofollow">6 . 多寄存器加载和存储指令</a></li><li><a href="#7__2031" rel="nofollow">7. 堆栈指令</a></li><li><a href="#8__2033" rel="nofollow">8. 软件中断指令</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1__2"></a>1 .处理器工作模式</h3> 
<p><strong>ARM微处理器支持7种工作模式，分别为：</strong></p> 
<ul><li>用户模式（usr）：ARM处理器正常的程序执行状态</li><li>快速中断模式（fiq）：用于高速数据传输或通道处理</li><li>外部中断模式（irq）：用于通用的中断处理</li><li>管理模式（svc）：操作系统使用的保护模式</li><li>中止模式(abt)：当数据或指令预取终止时进入该模式，用于虚拟存储及存储保护。</li><li>未定义指令模式（und）：当未定义的指令执行时进入该模式，用于支持硬件协处理器的软件仿真。</li><li>系统模式（sys）：运行具有特权的操作系统任务。</li></ul> 
<h3><a id="2__14"></a>2. 处理器工作状态</h3> 
<p>自从ARM7TDMI核产生后,体系结构中具有T变种的ARM处理器核可工作在两种状态,并可在两种状态之间切换：</p> 
<ul><li> <p><strong>ARM状态</strong>: ARM微处理器执行32位的ARM指令集。</p> </li><li> <p><strong>Thumb状态</strong>：ARM微处理器执行16位的Thumb指令集</p> <p>处理器开始执行时候处于ARM状态。</p> </li></ul> 
<h3><a id="3_ARM_23"></a>3. ARM寄存器</h3> 
<h4><a id="31__25"></a>3.1 通用寄存器</h4> 
<ul><li> <p>未分组寄存器</p> <p>未分组寄存器包括R0～R7,在所有工作模式下，未分组寄存器都指向同一个物理寄存器，他们未被系统用作特殊的用途，因此，在中断或异常处理进行工作模式转换时，由于不同的处理器工作模式均使用相同的物理寄存器，可能会造成寄存器中数据的破坏，这一点在进行程序设计时应引起注意</p> </li><li> <p>分组寄存器</p> <p>分组寄存器包括R8～R14，对于分组寄存器，他们每一次所访问的物理寄存器与处理器当前的工作模式有关。如图所示。对于R8～R12来说，每个寄存器对应两个不同的物理寄存器，当使用fiq模式时，访问寄存器R8_fiq～R12_fiq；当使用除fiq模式以外的其它模式时，访问寄存器R8_usr～R12_usr。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/e2/c2/rLqifA0a_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="32__38"></a>3.2 状态寄存器</h4> 
<p>ARM体系结构包含一个当前程序状态寄存器CPSR (R16)和五个备份的程序状态寄存器（SPSRs）。CPSR可在任何工作模式下被访问，用来保存ALU中的当前操作信息、控制允许和禁止中断、设置处理器的工作模式等。备份的程序状态寄存器用来进行异常处理。程序状态寄存器的基本格式如图所示：</p> 
<p><img src="https://images2.imgbox.com/26/43/pcbtIsek_o.png" alt="在这里插入图片描述"></p> 
<ul><li>条件码标志</li></ul> 
<p><img src="https://images2.imgbox.com/f6/35/0F0OkL9i_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>控制位</p> 
  <ol><li>中断禁止位<br> 中断禁止位包括I、F，用来禁止或允许IRQ和FIQ两类中断,当I=1时，表示禁止IRQ中断，I=0时，表示允许IRQ中断;当F=1时，表示禁止FIQ中断，F=0时，表示允许FIQ中断。</li><li>T标志位<br> T标志位用来标识/设置处理器的工作状态。对于ARM体系结构v4及以上的版本的T系列处理器，当该位为1时，程序运行于Thumb状态；当该位为0时，表示运行于ARM状态。ARM指令集和Thumb指令集均有切换处理器状态的指令。这些指令通过修改T位的值为1或0来实现在两种工作状态之间切换，但ARM微处理器在开始执行代码时，应该处于ARM状态。</li><li>工作模式位<br> 工作模式位（M[4：0]）用来标识或设置处理器的工作模式。M4 、M3 、M2、M1、M0决定了处理器的工作模式。<img src="https://images2.imgbox.com/e8/42/1LDY40Xc_o.png" alt="在这里插入图片描述"></li></ol> </li><li> <p>保留位</p> <p>CPSR中的其余位为保留位，当改变CPSR中的条件码标志位或者控制位时，保留位不要被改变，在程序中也不要使用保留位来存储数据。保留位将用于ARM版本的扩展。</p> </li></ul> 
<h4><a id="33_SPSR_63"></a>3.3 备份的程序状态寄存器SPSR</h4> 
<p>每一种工作模式下又都有一个专用的物理状态寄存器，称为SPSR（Saved Program Status Register，），当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时则可由SPSR来恢复CPSR。由于用户模式和系统模式不属于异常模式，他们没有SPSR，当在这两种模式下访问SPSR，结果是未知的。CPSR和SPSR通过特殊指令进行访问。</p> 
<p>【示例】假设某一刻，寄存器CPSR的值如图2-11所示，试说明处理器的条件标志、中断允许情况、工作状态以及工作模式。</p> 
<p><img src="https://images2.imgbox.com/40/de/8PQTwPhv_o.png" alt="在这里插入图片描述"></p> 
<p>分析：CPSR的bit[31～27]表示条件标志NZCVQ，其值分别为00100，为了便于阅读常常用字母表示其值，如图中所示：某一位为0则用小写字母表示，某一位为1，则用大写字母表示，则上述条件标志可表示为:nzCvq，即C标志位置位为1，其它标志位为0。因为bit[7～6]为iF,所以IRQ中断被使能，即允许CPU响应IRQ中断，FIQ中断被禁止。因为bit[5]为t,所以处理器工作在ARM状态。因为Bit[4～0]为10011,可知系统工作于管理模式(SVC) 。</p> 
<h4><a id="34_Thumb_74"></a>3.4 Thumb寄存器</h4> 
<p>Thumb状态下的寄存器集是ARM状态下寄存器集的一个子集，程序可以直接访问8个通用寄存器（R7～R0）、程序计数器（PC）、堆栈指针（SP）、连接寄存器（LR）和CPSR。同时，在每一种特权模式下都有一组SP、LR和SPSR。</p> 
<p><img src="https://images2.imgbox.com/77/c2/yLMR99vO_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Thumb状态下的寄存器组织与ARM状态下的寄存器组织的关系：</strong></p> 
<ul><li>Thumb状态下和ARM状态下的R0～R7是相同的。</li><li>Thumb状态下和ARM状态下的CPSR和所有的SPSR是相同的。</li><li>Thumb状态下的SP对应于ARM状态下的R13。</li><li>Thumb状态下的LR对应于ARM状态下的R14。</li><li>Thumb状态下的程序计数器对应于ARM状态下R15</li></ul> 
<p><img src="https://images2.imgbox.com/0c/8e/ozVTnpKK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_ARM_89"></a>4. ARM指令系统</h3> 
<h4><a id="41__91"></a>4.1 指令和指令格式</h4> 
<ol><li>指令和指令系统<br> 指令是指示计算机进行某种操作的命令<br> 指令的集合称为指令系统。指令系统的功能强弱在很大程度上决定了这类计算机智能<br> 的高低，它集中地反映了微处理器的硬件功能和属性。</li><li>指令的表示方法<br> 从形式上看，ARM指令在机器中的表示格式是用32位的二进制数表示。计算机根据二<br> 进制代码去完成所需的操作，如ARM中有一条指令为：<br> ADDEQS R0,R1,#8；<br> 其二进制代码形式为：<br> <img src="https://images2.imgbox.com/ae/20/ceW4P0A9_o.png" alt="在这里插入图片描述"></li></ol> 
<p>ARM指令代码一般可以分为5个域：</p> 
<ul><li> <p>第1个域是4位[31:28]的条件码域，4位条件码共有16种组合；</p> </li><li> <p>第2个域是指令代码域[27:20],除了指令编码外，还包含几个很重要的指令特征和可选后缀的编码；</p> </li><li> <p>第3个域是地址基址Rn，是4位[19:16],为R0～R15共16个寄存器编码；</p> </li><li> <p>第4个域是目标或源寄存器Rd，是4位[15:12],为R0～R15共16个寄存器编码；第5个域是地址偏移或操作寄存器、操作数区[11:0]。</p> </li></ul> 
<ol start="3"><li> <p>汇编指令格式<br> <strong>用助记符表示的ARM指令一般格式如下：</strong></p> <pre><code> &lt;opcode&gt; {&lt;cond&gt;} {S}&lt;Rd&gt;，&lt;Rn&gt; {，&lt;OP2&gt;}
</code></pre> <p>​ 格式中&lt;&gt;的内容必不可少，{}中的内容可省略。如是指令<br> ​ 助记符，是必须的。而{}为指令的执行条件，是可选的，缺省<br> ​ 的情况下表示使用默认条件AL(无条件执行)。</p> 
  <ul><li> <p>表示操作码，如ADD表示算术加法。</p> </li><li> <p>{}表示指令执行的条件域，如EQ、NE等。</p> </li><li> <p>{S}决定指令的执行结果是否影响CPSR的值，使用该后缀则指令执行的结果影响CPSR的值，否则不影响。</p> </li><li> <p>表示目的寄存器。</p> </li><li> <p>表示第一个操作数，为寄存器。</p> </li><li> <p>表示第二个操作数，可以是立即数、寄存器和寄存器移位操作数。</p> <p>​ 例如上述指令ADDEQS R0,R1,#8；其中操作码为ADD，条件域cond为EQ，<br> ​ S表示该指令的执行影响CPSR寄存器的值，目的寄存器Rd为R0，第一个操<br> ​ 作数寄存器Rn为R1，第二个操作数OP2为立即数＃8。</p> <p><strong>指令格式举例：</strong></p> <pre><code class="prism language-assembly">     LDR R0,[R1] ;读取R1地址上的存储单元的数据到寄存器R0
     BEQ ENDDATA  ;条件分支执行指令，执行条件EQ，即相等则跳转到ENDDATA处
     ADDS R2,R1,#1 ;寄存器R1中的内容加1存入寄存器R2，并影响CPSR寄存器的值
</code></pre> </li></ul> </li></ol> 
<h4><a id="42__152"></a>4.2 指令的可选后缀</h4> 
<h5><a id="S_154"></a>S后缀</h5> 
<p>指令中使用S后缀时，指令执行后程序状态寄存器的条件标志位将被刷新，不使用S后缀时，指令执行后程序状态寄存器的条件标志将不会发生变化。 S后缀通常用于对条件进行测试，例如是否有溢出，是否进位等；根据这些变化，就可以进行一些判断，如是否大于，是否相等；从而可能影响指令执行的顺序。</p> 
<blockquote> 
 <p>示例 假设R0=0x1,R3=0x3,指令执行之前 CPSR=nzcvqIFt_SVC,分别执行如下指令CPSR的值有何变化？</p> 
 <pre><code class="prism language-assembly"> SUB R1,R0,R3    ；R0的值减去R3的值，结果存入R1
 SUBS R1,R0,R3   ；R0的值减去R3的值，结果存入R1，影响标志位
</code></pre> 
 <p>执行第1条指令对于标志寄存器的值没有任何影响，因此CPSR的值不变。执行第2条指令后CPSR=NzcvqIFt_SVC,因为R0的值减去R3值，结果变成了一个负数，故而N被置位了。</p> 
</blockquote> 
<h5><a id="_168"></a>!后缀</h5> 
<p>如果指令地址表达式中不含！后缀，则基址寄存器中的地址值不会发生变化。指令中的地址表达式中含有!后缀时，指令执行后，基址寄存器中的地址值将发生变化，变化的结果如下：</p> 
<p>基址寄存器中的值（指令执行后）＝指令执行前的值＋地址偏移量</p> 
<blockquote> 
 <p>示例 分别执行下面两条指令有何区别？</p> 
 <pre><code class="prism language-assembly">LDR R3,[R0,#4] 
LDR R3,[R0,#4]！
</code></pre> 
 <p>分析：在上述指令中，第1条指令没有后缀！，指令的结果是把R0加4作为地址指针，把这个指针所指向的地址单元所存储的数据读入R3，R0的值不变。第2条指令除了实现以上操作外，还把R0＋4的结果送到R0中。</p> 
</blockquote> 
<ul><li>使用!后缀需要注意如下事项： 
  <ol><li>！后缀必须紧跟在地址表达式后面，而地址表达式要有明确的地址偏移量。</li><li>!后缀不能用于R15(PC)的后面。</li><li>当用在单个地址寄存器后面时，必须确信这个寄存器有隐性的偏移量，例如“STMDB R1!{R3,R5,R7}”此时地址基址寄存器R1的隐性偏移量是4。</li></ol> </li></ul> 
<h4><a id="43_188"></a>4.3指令的条件执行</h4> 
<p>程序要执行的指令，均保存在存储器中，当计算机需要执行一条指令时，首先产生这条指令的地址，并根据地址号打开相应的存储单元，取出指令代码，CPU根据指令代码的要求以及指令中的操作数，去执行相应的操作。<br> <img src="https://images2.imgbox.com/4b/f8/fkvteKQJ_o.png" alt="指令的条件码"></p> 
<blockquote> 
 <p>示例 下面三条指令有何区别？</p> 
 <pre><code class="prism language-assembly">ADD R4,R3,#1
ADDEQ R4,R3,#1
ADDS R4,R3,#1
</code></pre> 
 <p>分析：第1条指令不带条件标志（无条件AL），指令的执行不受条件标志位的影响，完成加法运算：将R3的值加1存入寄存器R4。第2条 ADD指令加上后缀EQ变为ADDEQ表示“相等则相加”，即当CPSR中的Z标志置位时该指令执行，否则不执行。第3条指令的执行也不受条件标志的影响，但是由于附带了后缀S，这条指令执行的结果将影响CPSR中条件标志位的值。</p> 
 <p>条件后缀只是影响指令是否执行，不影响指令的内容，如上述ADDEQ指令，可选后缀EQ并不影响本指令的内容，它执行时仍然是一条加法指令。</p> 
</blockquote> 
<p><strong>条件后缀和S后缀的关系如下：</strong></p> 
<ul><li>如果既有条件后缀又有S后缀，则书写时S排在后面，如：ADDEQS R1,R0,R2</li><li>该指令在Z=1时执行，将R0+R2的值放入R1，同时刷新条件标志位。</li><li>条件后缀是要测试条件标志位，而S后缀是要刷新条件标志位。</li><li>条件后缀要测试的是执行前的标志位，而S后缀是依据指令的结果改变条件标志。</li></ul> 
<h4><a id="44_ARM_212"></a>4.4 ARM指令分类</h4> 
<p>ARM微处理器的指令集是加载/存储型的，即指令集中的大部分指令仅能处理寄存器中的数据，而且处理结果都要放回寄存器，而对系统存储器的访问则需要通过专门的加载/存储指令来完成。</p> 
<p><strong>ARM微处理器的指令集可以分为六大类：</strong></p> 
<ul><li> <p>数据处理指令</p> </li><li> <p>数据加载与存储指令</p> </li><li> <p>分支指令</p> </li><li> <p>程序状态寄存器（PSR）处理指令</p> </li><li> <p>协处理器指令</p> </li><li> <p>异常产生指令</p> </li></ul> 
<h3><a id="5___ARM_230"></a>5 . ARM指令的寻址方式</h3> 
<h4><a id="51__232"></a>5.1 立即数寻址</h4> 
<p>立即数寻址也叫立即寻址，操作数本身就在指令中给出，取出指令也就取到了操作数。这个操作数被称为立即数，对应的寻址方式也就叫做立即寻址。</p> 
<blockquote> 
 <p>例 MOV R0,#15</p> 
 <p><img src="https://images2.imgbox.com/84/17/HlJsQPUB_o.png" alt="在这里插入图片描述"></p> 
 <p>立即数要求以“＃”为前缀，对于以十六进制表示的立即数，还要求在“＃”后加上“0x”或“&amp;”；对于以二进制表示的立即数，要求在“#”后加上“0b”； 对于以十进制表示的立即数，要求在“#”后加上“0d”或缺省。此指令是将立即数15传送到R0中，该指令的机器编码为E3A0000FH，由指令编码中0x00F即可得到一个32位的立即0x0000000FH，这个数再送入R0。</p> 
</blockquote> 
<h4><a id="52___242"></a>5.2 寄存器寻址</h4> 
<p>寄存器寻址就是利用寄存器中的数值作为操作数，这种寻址方式是各类微处理器经常采用的一种方式，也是一种执行效率较高的寻址方式。</p> 
<blockquote> 
 <p>例 ADD R0,R1,R2 ;R0←R1＋R2</p> 
 <p><img src="https://images2.imgbox.com/9e/eb/QuDKd3A1_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="53__250"></a>5.3 寄存器间接寻址</h4> 
<p>寄存器间接寻址就是以寄存器中的值作为操作数的地址，而操作数本身存放在存储器中。</p> 
<blockquote> 
 <p>例 LDR R0,[R4] ;R0←[R4]</p> 
 <p><img src="https://images2.imgbox.com/56/da/nNdlPk5C_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="54__259"></a>5.4 寄存器移位寻址</h4> 
<p>寄存器移位寻址的操作数由寄存器中的数值做相应移位而得到。</p> 
<blockquote> 
 <p>例</p> 
 <pre><code class="prism language-assembly">ADD R0,R1,R2,LSL #1

MOV R0,R1,LSL R3
</code></pre> 
 <p><img src="https://images2.imgbox.com/87/91/vndh2qK8_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="55__274"></a>5.5 基址变址寻址</h4> 
<p>基址变址寻址就是将寄存器（该寄存器一般称作基址寄存器）的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。</p> 
<blockquote> 
 <p>例</p> 
 <pre><code class="prism language-assembly">LDR R0,[R1,＃4]    ;R0←[R1＋4]
LDR R0,[R1,＃4]！ ;R0←[R1＋4]、R1←R1＋4
LDR R0,[R1],＃4   ;R0←[R1]、R1←R1＋4
LDR R0,[R1,R2]    ;R0←[R1＋R2]
</code></pre> 
 <p><img src="https://images2.imgbox.com/16/b5/QAsqFnlG_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="56__290"></a>5.6 多寄存器寻址</h4> 
<p>采用多寄存器寻址方式，一条指令可以完成多个寄存器值的传送。这种寻址 方式中用一条指令最多可传送16个通用寄存器的值。连续的寄存器间用“-”连接，否则用“，”分隔。</p> 
<blockquote> 
 <p>例</p> 
 <pre><code class="prism language-assembly">LDMIA R0！,{R1-R4}  ;R1←[R0]
                    ;R2←[R0＋4]		
                    ;R3←[R0＋8]
</code></pre> 
 <p>指令执行前内存和寄存器值</p> 
 <p><img src="https://images2.imgbox.com/03/b9/dOBLPQ4s_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>指令执行后内存和寄存器值</p> 
 <p><img src="https://images2.imgbox.com/0e/a7/hR3LRcLT_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="57__312"></a>5.7 相对寻址</h4> 
<p>与基址变址寻址方式相类似，相对寻址以程序计数器PC的当前值为 基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数 的有效地址。</p> 
<blockquote> 
 <p>以下程序段完成子程序的调用，分支指令BL采用了相对寻址方式：</p> 
 <pre><code class="prism language-assembly">         BL proc  ;跳转到子程序proc处执行
                   …		
          proc  MOV R0,#1
                   …	 
</code></pre> 
</blockquote> 
<h4><a id="58__325"></a>5.8 堆栈寻址</h4> 
<p>堆栈是一种数据结构，按后进先出（Last In First Out， LIFO）的方式工作， 使用一个称作堆栈指针的专用寄存器指示当前的操作位置，堆栈指针总是指向栈顶。</p> 
<p>ARM中采用LDMFD和STMFD指令分别用来支持POP操作（出栈）和PUSH操作（进栈），R13作为堆栈指针。</p> 
<blockquote> 
 <p>例</p> 
 <pre><code class="prism language-assembly">STMFD R13!,{R0-R4};
LDMFD R13!,{R0-R4};
</code></pre> 
</blockquote> 
<h3><a id="6__338"></a>6. 数据处理指令</h3> 
<p>数据处理指令对存放在寄存器中的数据进行操作，分为:</p> 
<ul><li>数据传送指令</li><li>移位操作</li><li>算术指令</li><li>逻辑运算指令</li><li>比较指令</li><li>乘法指令</li></ul> 
<p>算术逻辑运算指令完成常用的算术与逻辑运算，这两类指令不但将运算结果保存在目的寄存器中，同时更新CPSR中的相应条件标志位。比较指令不保存运算结果，只更新CPSR中相应的条件标志位。</p> 
<p><img src="https://images2.imgbox.com/39/25/gQKlDh94_o.png" alt="在这里插入图片描述"></p> 
<ul><li>cond： 指令执行的条件码</li><li>I ：用于区别第二操作数是立即数(I=1)还是寄存器移位(I=0)</li><li>opcode： 数据处理指令操作码</li><li>S ： 用于设置条件码，S=0，条件码不改变, S=1，条件码根据具体指令的结果修改</li><li>Rn ： 第一操作数寄存器</li><li>Rd ：目标寄存器</li><li>Operand2 ：第二操作数，该数可以是立即数或寄存器移位数。</li></ul> 
<h4><a id="61__362"></a>6.1 数据传送指令</h4> 
<p>数据传送指令主要用于将一个寄存器中的数据传送到另一个寄存器，或者将一个立即数传送到寄存器，这类指令通常用来设置寄存器的初始值。</p> 
<p><strong>数据传送指令包括：</strong></p> 
<ul><li> <p>MOV数据传送指令</p> </li><li> <p>MVN数据取反传送指令</p> </li></ul> 
<h5><a id="MOV_372"></a>MOV指令</h5> 
<blockquote> 
 <p>汇编格式：MOV {} {S} Rd,operand2</p> 
</blockquote> 
<p>功 能：MOV指令将源操作数operand2传送到目的寄存器Rd中。通常 operand2是一个立即数、寄存器Rm或被移位的寄存器。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令 执行后的结果影响CPSR中条件标志位N和Z值，在计算第2操作数时更新标志C，不影响V标志。</p> 
<blockquote> 
 <p>例 3.12 MOV指令示例：</p> 
 <pre><code class="prism language-assembly"> MOV  R1,R0           ;将寄存器R0的值传送到寄存器R1
 MOV  PC,R14          ;将寄存器R14的值传送到PC，常用于子程序返回
 MOV  R1,R0,LSL＃3   ;将寄存器R0的值左移3位后传送到R1  
 MOV  R0,#5           ;将立即数5传送到寄存器R0
</code></pre> 
</blockquote> 
<h5><a id="MVN_387"></a>MVN指令</h5> 
<blockquote> 
 <p>汇编格式：MVN{}{S} Rd，operand2</p> 
</blockquote> 
<p>功 能：MVN指令可完成从另一个寄存器、被移位的寄存器或将一个立即数传送到目的寄存器Rd。与MOV指令不同之处是:数据在传送之前被按位取反了，即把一个被取反的值传送到目的寄存器中。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N和Z值，在计算第2操作数时更新标志C，不影响V标志。</p> 
<blockquote> 
 <p>​ 例 3.13 MVN指令示例：</p> 
 <pre><code class="prism language-assembly">     MVN R0,＃0 ;将立即数0取反传送到寄存器R0中，完成后R0=-1
     MVN R1,R2  ;将R2取反，结果存到R1中
</code></pre> 
</blockquote> 
<h4><a id="62__405"></a>6.2 移位操作</h4> 
<p>ARM微处理器一个显著的特征是：在操作数进入ALU之前，对操作数进行预处理。如：指定位数的左移或右移，这种功能明显增强了数据处理操作的灵活性。这种预处理是通过ARM微处理器内嵌的桶形移位器（Barrel Shifter）来实现的。</p> 
<p>桶形移位器和ALU的关系如图所示</p> 
<p><img src="https://images2.imgbox.com/1e/ab/glwJnmUU_o.png" alt="在这里插入图片描述"></p> 
<p>桶形移位器支持数据的各种移位操作，移位操作在ARM指令集中不作为单独的指令 使用，它只能作为指令格式中的一个字段， 在汇编语言中作为指令中的选项。例如，数据处理指令的第二个操作数为寄存器时，就可以加入移位操作选项对它进行各种移位操作。</p> 
<p><strong>移位操作包括如下5种类型：</strong></p> 
<ul><li>LSL 逻辑左移</li><li>LSR 逻辑右移</li><li>ASR 算术右移</li><li>ROR 循环右移</li><li>RRX 带扩展的循环右移</li></ul> 
<h5><a id="1LSL_424"></a>1．LSL逻辑左移</h5> 
<blockquote> 
 <p>汇编格式：Rm，LSL </p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/27/3d/dz4ZQEgV_o.png" alt="在这里插入图片描述"></p> 
<p>功 能：LSL指令可完成对通用寄存器Rm中的内容进行逻辑左移操作，按操作数op1所指定的数量向左移位，低位用零来填充。逻辑左移一次相当于将无符号数据做乘2操作。逻辑左移如图3-12所示。指令格式中的操作数op1 用来控制左移的次数，op1有如下两种表示方式：</p> 
<ul><li> <p>立即数控制方式<br> 立即数控制方式就是寄存器Rm移位的位数由一个数值常量来控制，例如：</p> <pre><code class="prism language-assembly">Rm，LSL #2
</code></pre> <p>在这个表达式中，对Rm中的数据逻辑左移2位。使用立即数控制方式时必须满足：<br> 0≤立即数≤31。</p> <p>在这个表达式中，对Rm中的数据逻辑左移2位。使用立即数控制方式时必须满足：<br> 0≤立即数≤31。</p> </li><li> <p>寄存器控制方式<br> 寄存器控制方式就是寄存器Rm移位的位数由另一个寄存器Rs来控制，Rs是通用寄存器，但不可使用R15（程序计数器）。例如：</p> <pre><code>Rm,LSL Rs
</code></pre> <p>假设Rs的值为3，则在这个表达式中表示对Rm中的数据逻辑左移3位。同样使用寄存器控制方式也必须满足：0≤Rs≤31。</p> </li></ul> 
<blockquote> 
 <p>例1 设指令操作之前R0=0x00000000,R1=0x80000004,则执行如下指令后R0，R1的值有何变化？</p> 
 <pre><code class="prism language-assembly">MOV  R0, R1, LSL#1
</code></pre> 
 <p>例 2 设指令操作之前CPSR=nzcvqiFt_USER，R0=0x00000000，R1=0x80000004，则执行如下指令后R0，R1，CPSR中的值有何变化？</p> 
 <pre><code class="prism language-assembly">MOVS  R0, R1, LSL#1
</code></pre> 
 <p><img src="https://images2.imgbox.com/1b/c7/co7dnD1u_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="2LSR_470"></a>2．LSR逻辑右移</h5> 
<blockquote> 
 <p>汇编格式：Rm，LSR </p> 
</blockquote> 
<p>功 能：LSR指令可完成对通用寄存器Rm中的数据，按操作数op1所指定的数量向右移位，空出的最高位用零来填充。逻辑右移一次相当于将无符号数据做除2 操作。逻辑右移如图所示</p> 
<p><img src="https://images2.imgbox.com/dc/3f/MNkW0REa_o.png" alt="在这里插入图片描述"></p> 
<p>指令格式中的操作数op1用来控制右移的次数，关于操作数op1的要求如LSL指令所述，唯一区别是取值范围要求：1≤立即数或Rs≤32。同样地，当指令中附加了S选项时，移位指令操作的结果还将影响CPSR中的标志位。</p> 
<blockquote> 
 <p>例 设指令操作之前CPSR=nzcvqiFt_USER，R0=0xFFFFFFFF，R1=0x00000001，则执行如下指令后R0，R1，CPSR中的值有何变化？</p> 
 <pre><code class="prism language-assembly">MOVS  R0, R1, LSR#1
</code></pre> 
</blockquote> 
<h5><a id="3ASR_487"></a>3．ASR算术右移</h5> 
<blockquote> 
 <p>汇编格式：Rm，ASR </p> 
</blockquote> 
<p>功 能：ASR可完成对通用寄存器中的内容，按操作数所指定的数量向右移位，左端用第31位的值来填充。算术右移如图所示。</p> 
<p><img src="https://images2.imgbox.com/f9/ba/XbrAytX2_o.png" alt="在这里插入图片描述"></p> 
<p>指令格式中的操作数op1用来控制右移的次数，关于操作数op1的要求如LSL指令所述，唯一区别是取值范围要求：1≤立即数或Rs≤32。同样地，当指令中附加了S选项时，移位指令操作的结果还将影响CPSR中的标志位。</p> 
<blockquote> 
 <p>例 设指令操作之前CPSR=nzcvqiFt_USER，R0=0x00000000，R1=0x80000001，则执行如下指令后R0，R1，CPSR中的值有何变化？</p> 
 <pre><code class="prism language-assembly"> MOVS  R0, R1, ASR#1
</code></pre> 
</blockquote> 
<h5><a id="4ROR_507"></a>4．ROR循环右移</h5> 
<blockquote> 
 <p>汇编格式：Rm，ROR </p> 
</blockquote> 
<p>功 能：ROR可完成对通用寄存器中的内容，按操作数所指定的数量向右循环移位，左端用右端移出的位来填充。循环右移如图所示。</p> 
<p><img src="https://images2.imgbox.com/9f/22/1zlv8f1C_o.png" alt="在这里插入图片描述"></p> 
<p>指令格式中的操作数op1用来控制右移的次数，关于操作数op1的要求如LSL指令所述，取值范围要求：1≤立即数或Rs≤31。同样地，当指令中附加了S选项时，移位指令操作的结果还将影响CPSR中的标志位。</p> 
<blockquote> 
 <p>例 设指令操作之前R0=0x00000000,R1=0x40000001,则执行如下指令后R0，R1的值有何变化？</p> 
 <pre><code class="prism language-assembly">MOV  R0, R1, ROR #1
</code></pre> 
</blockquote> 
<h5><a id="5RRX_524"></a>5．RRX带扩展的循环右移</h5> 
<blockquote> 
 <p>汇编格式：Rm，RRX</p> 
</blockquote> 
<p>功 能：RRX可完成对通用寄存器中的内容进行带扩展的循环右移一位的操 作，右移时32位数据和C标志位共33位数据组成一个循环往右移一次。 C标志位移入最高位，最低位移入C位。带扩展的循环右移如图所示。</p> 
<p><img src="https://images2.imgbox.com/ba/91/kGxNKYjV_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>例 设指令操作之前CPSR=nzcvqiFt_USER，R0=0x00000000，R1=0x80000001，则执行如下指令后R0，R1，CPSR中的值有何变化 ?</p> 
 <pre><code class="prism language-assembly"> MOVS  R0, R1, RRX
</code></pre> 
</blockquote> 
<h4><a id="63__541"></a>6.3 算术指令</h4> 
<p>ARM中的算术指令主要指加法和减法，这些指令主要实现两个32位数据的加 减操作，该类指令常常和桶形移位器结合起来，获得许多灵活的功能。算术指令主要包括：</p> 
<ul><li> <p>ADD 加法指令</p> </li><li> <p>ADC 带进位加法指令</p> </li><li> <p>SUB 减法指令</p> </li><li> <p>SBC 带借位减法指令</p> </li><li> <p>RSB 逆向减法指令</p> </li><li> <p>RSC 带借位的逆向减法指令</p> </li></ul> 
<h5><a id="1__ADD__557"></a>1. ADD 加法指令</h5> 
<blockquote> 
 <p>汇编格式：ADD{}{S} Rd，Rn，operand2</p> 
</blockquote> 
<p>功 能：ADD指令用于把寄存器Rn的值和操作数operand2相加，并将结果存放到Rd寄存器中。即Rd=Rn+ operand2,其中Rd为目的寄存器，Rn为操作数1，要求是一个寄存器，operand2是操作数2，可以是一个寄 存器，被移位的寄存器，或一个立即数。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N、Z、C、V标志。</p> 
<blockquote> 
 <p>例 ADD指令示例：</p> 
 <pre><code class="prism language-assembly"> ADD R0,R1,R2         ; R0 = R1 + R2
 ADD R0,R1,#5         ; R0 = R1 + 5
 ADD R0,R1,R2,LSL#2   ; R0 = R1 + (R2左移2位)
</code></pre> 
</blockquote> 
<ul><li>立即数控制的寄存器移位表达式</li></ul> 
<p>立即数控制方式就是寄存器Rm移位的位数由一个数值常量来控制，例如：</p> 
<pre><code class="prism language-assembly">   ADD R0，R1，R2，LSL#2  ； R0 = R1 + (R2左移2位)
</code></pre> 
<p>在这个表达式中，对R2中的数据逻辑左移2位, 然后和R1相加，其结果放入寄存器R0中。</p> 
<ul><li>寄存器控制的寄存器移位方式<br> 寄存器控制方式就是寄存器Rm移位的位数由另一个寄存器Rs来控制，Rs是通用寄存器，但不可使用R15（程序计数器）。例如：</li></ul> 
<pre><code class="prism language-assembly">  ADD R0,R1,R2,LSL R3
</code></pre> 
<p>假设R3的值为3，则在这个表达式中表示对R2中的数据逻辑左移3位，然后和R1相加，其结果放入寄存器R0中。</p> 
<ul><li>数字常量表达式</li></ul> 
<p>数字常量表达式可以简单到一个立即数，还可以使用单目操作符、双目操 作符、逻辑操作符和算术操作符等。例如：</p> 
<pre><code>＃0x88               ;立即数
＃0x40+0x20          ;使用加法
#0x40+0x20*4         ;使用加减乘除算术运算
#0x80:ROR:02         ;使用移位操作，循环右移2位
#2_11010010          ;使用二进制
#0xFF:MOD:08         ;取模操作
#0xFF0000:AND:660000 ;逻辑操作，两数相与
</code></pre> 
<h5><a id="2__ADC_605"></a>2. ADC带进位加法指令</h5> 
<blockquote> 
 <p>汇编格式：ADC{}{S} Rd，Rn， operand2</p> 
</blockquote> 
<p>功能：ADC指令用于把寄存器Rn的值和操作数operand2相加，再 加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器Rd中。即Rd=Rn+ operand2+C, 其中Rn为操作数1，必须是一个寄存器，operand2为操作数2，可以是一个寄存器，被移位的寄存器，或一个立即数。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N、Z、C、V标志。该指令使用一个进位标志位，这样就可以做比32位大的数的加法，注意不要忘记设置S后缀来更改进位标志。该指令用于实现超过32位的加法。</p> 
<blockquote> 
 <p>例 用ADC指令完成64位加法，设第一个64位操作数放在R2、R3中，第二个64位操作数放在R4、R5中。64位结果放在R0、R1中。</p> 
 <p>分析：首先将两个64位数中的低32位相加，相加结果影响C标志位。然后将64位中的高32位以及低32位产生的进位相加。程序如下：</p> 
 <pre><code class="prism language-assembly">ADDS R0,R2,R4 	;加第32位，S表示影响条件标志位的值
ADC R1,R3,R5	;加高32位，带进位
</code></pre> 
</blockquote> 
<h5><a id="3__SUB_620"></a>3. SUB减法指令</h5> 
<blockquote> 
 <p>汇编格式：SUB{}{S} Rd，Rn，operand2</p> 
</blockquote> 
<p>功能：SUB指令用于把寄存器Rn的值减去操作数operand2，并将结果存放到目的寄存器Rd中。即Rd=Rn- operand2, 其中Rd为目的寄存器，Rn为操作数1，必须是一个寄存器，operand2是操作数2，可以是一个寄存器，被移位的寄存器或一个立即数。该指令可用于有符号数或无符号数的减法运算。S选项决定指令操作的结果是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N、Z、C、V标志。</p> 
<blockquote> 
 <p>SUB指令示例：</p> 
 <pre><code class="prism language-assembly">SUB R0,R1,R2        	;R0 = R1 - R2
SUB R0,R1,#6        	;R0 = R1 - 6
SUB R0,R2,R3，LSL#1 	    ;R0 = R2 - (R3 左移一位)
</code></pre> 
</blockquote> 
<h5><a id="4__SBC__634"></a>4. SBC 带借位减法指令</h5> 
<blockquote> 
 <p>汇编格式：SBC{}{S} Rd，Rn，operand2</p> 
</blockquote> 
<p>功能：SBC指令用于把寄存器Rn的值减去操作数operand2，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器Rd中。即Rd=Rn-operand2-!C, 其中Rd为目的寄存器，Rn为操作数1，必须是一个寄存器，operand2是操作数2，可以是一个寄存器，被移位的寄存器或一个立即数。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N、Z、 C、V标志。</p> 
<blockquote> 
 <p>例 用SBC指令完成64位减法，设第一个64位操作数0x20000000 50000000放在R2、R3中，第二个64位操作数0x3000000040000000放在R4、R5中。64位结果放在R0、R1中</p> 
 <p>分析：首先将两个64位数的低32位相减，其结果影响C标志位。此例子中低32位相减必然产生借位，即影响CPSR中的C值，使得C=0，表示有借位。然后将64位数的高32位以及C 位的取反的值相减。</p> 
 <pre><code class="prism language-assembly">SUBS R0,R2,R4  ;低32位相减，S表示结果影响条件标志位的值
SUC	 R0,R2,R4  ;高32位相减
</code></pre> 
</blockquote> 
<h5><a id="5__RSB__649"></a>5. RSB 逆向减法指令</h5> 
<blockquote> 
 <p>汇编格式：RSB{}{S} Rd，Rn，operand2</p> 
</blockquote> 
<p>功能：RSB指令称为逆向减法指令，指令表示把操作数2减去操作数1，并将结果存放到目的寄存器中。即Rd= operand2-Rn,其中Rn为操作数1，应是一个寄存器，operand2为操作数2，可以是一个寄存器，被移位的寄存器或一个立即数。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N、Z、 C、V标志。该指令可用于有符号数或无符号数的减法运算。</p> 
<blockquote> 
 <p>例 RSB指令示例：</p> 
 <pre><code class="prism language-assembly">RSB R0,R1,R2          ;R0 = R2-R1
RSB R0,R1,#6          ;R0 =6-R1
RSB R0,R2,R3,LSL#1    ;R0 = (R3左移一位)-R2
</code></pre> 
</blockquote> 
<h5><a id="6__RSC_663"></a>6. RSC带借位的逆向减法指令</h5> 
<blockquote> 
 <p>汇编格式：RSC{}{S} Rd，Rn，operand2</p> 
</blockquote> 
<p>功 能：RSC指令表示把操作数operand2减去寄存器Rn的值，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器Rd中。即Rd=operand2-Rn-!C, 其中Rd为目的寄存器，Rn为操作数1，必须是一个寄存器operand2是操作数2，可以是一个寄存器，被移位的寄存器，或一个立即数。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N、Z、C、V标志。</p> 
<blockquote> 
 <p>例 RSC指令示例：</p> 
 <pre><code class="prism language-assembly"> RSC R0,R1,R2      ;R0 = R2–R1-!C
</code></pre> 
</blockquote> 
<h4><a id="64__675"></a>6.4 逻辑运算指令</h4> 
<p>逻辑运算是对操作数按位进行操作的，位与位之间无进位或借位，无数的正负与数的大小之分，这种运算的操作数称为逻辑数或逻辑值。逻辑运算指令主要包括：</p> 
<ul><li> <p>AND 逻辑与指令</p> </li><li> <p>ORR 逻辑或指令</p> </li><li> <p>EOR 逻辑异或指令</p> </li><li> <p>BIC 位清除指令</p> </li></ul> 
<h5><a id="1_AND__687"></a>1. AND 逻辑与指令</h5> 
<blockquote> 
 <p>汇编格式：AND{}{S} Rd，Rn，operand2</p> 
</blockquote> 
<p>功能：AND指令将两个操作数按位进行逻辑与运算，结果放置到目的寄存器Rd中。即Rd=Rn AND operand2，其中Rn为操作数1，是一个寄存器，operand2为操作数2，可以是一个寄存器，被移位的寄存器或一个立即数。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N和Z值，在计算第2操作数时更新标志C，不影响V标志。该指令常用于将操作数1的特定位清零的操作，所谓将某位清零就是将该位置0。</p> 
<blockquote> 
 <p>例 设R0＝0xFFFFFFFF,则执行下列指令后R0的值是多少？</p> 
 <pre><code class="prism language-assembly">AND R0,R0,＃0xF                 
</code></pre> 
 <p>分析：执行后R0 = 0x0000000F</p> 
</blockquote> 
<h5><a id="2__ORR__700"></a>2. ORR 逻辑或指令</h5> 
<blockquote> 
 <p>汇编格式：ORR{}{S} Rd，Rn，operand2</p> 
</blockquote> 
<p>功 能：ORR指令将两个操作数按位进行逻辑或运算，结果放置到目的寄存器Rd中。即Rd=Rn OR N，其中Rn为操作数1，是一个寄存器， operand2为操作数2，可以是一个寄存器，被移位的寄存器或一个 立即数。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N和Z值，在计算第2操作数时更新标志C，不影响V标志。该指令常用于将操作数1的特定位置位的操作，所谓将特定位置位就是将该位置1。</p> 
<blockquote> 
 <p>例 R0的第0位和第3位设置为1，其余位不变</p> 
 <pre><code class="prism language-assembly">ORR   R0,R0,#5
</code></pre> 
</blockquote> 
<h5><a id="3_EOR__712"></a>3. EOR 逻辑异或指令</h5> 
<blockquote> 
 <p>汇编格式：EOR{}{S} Rd，Rn，operand2</p> 
</blockquote> 
<p>功 能：EOR指令将两个操作数按位进行逻辑异或运算，并把结果放置到目的寄存器Rd中。即Rd=Rn EOR operand2，其中Rn为操作数1，是一个寄存器，operand2为操作数2，可以是一个寄存器、被移位的寄存器或一个立即数。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志<br> 位N和Z值，在计算第2操作数时更新标志C，不影响V标志。该指令常用于反转操作数1的某些位。</p> 
<blockquote> 
 <p>例 将R0的低4位取反，其余位不变</p> 
 <pre><code class="prism language-assembly">EOR  R0,R0,#F
</code></pre> 
</blockquote> 
<h5><a id="4_BIC__725"></a>4. BIC 位清除指令</h5> 
<blockquote> 
 <p>汇编格式：BIC{}{S} Rd，Rn，operand2</p> 
</blockquote> 
<p>功能：BIC指令用于清除操作数Rn的某些位，并把结果放置到目的寄存器Rd中。即Rd=Rn AND (!operand2)，其中Rn为操作数1，是一个寄存器，operand2为操作数2，可以是一个寄存器，被移位的寄存器，或一个立即数。这里operand2可以看作一个32位的掩码，如果在掩码中设置了某一位，则清除Rn中相应的位。未设置掩码位的则Rn中相应位保持不变。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N和Z值，在计算第2操作数时更新标志C，不影响V标志。</p> 
<blockquote> 
 <p>例 将R0的第0位和第3位清0，其余位不变</p> 
 <pre><code class="prism language-assembly">BIC   R0,R0,#9
</code></pre> 
</blockquote> 
<h4><a id="65__739"></a>6.5 比较指令</h4> 
<p>比较指令通常用于把一个寄存器与一个32位的值进行比较或测试。比较指令根据结果更新CPSR中的标志位，但不影响其它的寄存器。在设置标志位 后，其它指令可以通过条件执行来改变程序的执行顺序。对于比较指令，不需要使用S后缀就可以改变标志位的值。比较指令包括：</p> 
<ul><li> <p>CMP 比较指令</p> </li><li> <p>CMN 反值比较指令</p> </li><li> <p>TST 位测试指令</p> </li><li> <p>TEQ 相等测试指令</p> </li></ul> 
<h5><a id="1_CMP_751"></a>1. CMP比较指令</h5> 
<blockquote> 
 <p>汇编格式：CMP{}{S} Rn，operand2</p> 
</blockquote> 
<p>功能：CMP指令将寄存器Rn的内容和另一个操作数operand2进行比较，同时更新CPSR中条件标志位的值。该指令实质上是进行一次减法运算，但不存储结果，只更改条件标志位。后面的指令就可以根据条件标志位来决定是否执行。例如，当操作数Rn大于操作操作数operand2时，执行CMP指令后，则此后带有GT 后缀的指令将可以执行。</p> 
<blockquote> 
 <p>CMP指令示例：</p> 
 <pre><code class="prism language-assembly">CMP R1,＃10       ;将寄存器R1的值与10相减，并设置CPSR的标志位
ADDGT R0,R0,#5    ;如果R1&gt;10，则执行ADDGT指令，将R0加5
</code></pre> 
</blockquote> 
<h5><a id="2__CMN_764"></a>2. CMN反值比较指令</h5> 
<blockquote> 
 <p>汇编格式：CMN{}{S} Rn，operand2</p> 
</blockquote> 
<p>功 能：CMN指令用于把一个寄存器Rn的内容和另一个操作数operand2取反后进行比较，同时更新CPSR中条件标志位的值。该指令实际上是将操作数Rn和操作数operand2相加，并根据结果更改条件标志位。同样，后面的指令就可以根据条件标志位来决定是否执行。</p> 
<blockquote> 
 <p>CMN指令示例：</p> 
 <pre><code class="prism language-assembly">CMN  R0,R1    ;将寄存器R0的值与寄存器R1的值相加，
              ;并根据结果设置CPSR的标志位
CMN  R0,＃10  ;将寄存器R0的值与立即数10相加，
              ;并根据结果设置CPSR的标志位
</code></pre> 
</blockquote> 
<h5><a id="3_TST_779"></a>3. TST位测试指令</h5> 
<blockquote> 
 <p>汇编格式：TST{}{S} Rn，operand2</p> 
</blockquote> 
<p>功能：TST指令用于把一个寄存器Rn的内容和另一个操作数operand2按位进行与运算，并根据运算结果更新CPSR中条件标志位的值。该指令通常用来检查是否设置了特定的位。其中操作数Rn是要测试的数据，这里操作数operand2可以看作一个32位的掩码，如果在掩码中设置了某一位，表示检查该位。未设置的掩码位则表示不检查。</p> 
<blockquote> 
 <p>例 如要检查R0中的第0位和第1位是否为1则应执行什么指令？<br> 分析：检查R0 中的第0位和第1位是否为1则不应改变R0的值，因此执行如下指令：</p> 
 <pre><code class="prism language-assembly">TST    R1,＃3	
</code></pre> 
</blockquote> 
<h5><a id="4_TEQ_792"></a>4. TEQ相等测试指令</h5> 
<blockquote> 
 <p>汇编格式：TEQ{}{S} Rn，operand2</p> 
</blockquote> 
<p>功 能：TEQ指令用于把一个寄存器Rn的内容和另一个操作数operand2按位进行异或运算，并根据运算结果更新CPSR中条件标志位的值。该指令通常用于比较操作数Rn和操作数operand2是否相等。</p> 
<blockquote> 
 <p>TEQ指令示例：</p> 
 <pre><code class="prism language-assembly">TEQ  R1,R2     ;将寄存器R1的值与寄存器R2的值按位异或，
                ;并根据结果设置CPSR的标志位
</code></pre> 
</blockquote> 
<h4><a id="66__808"></a>6.6 乘法指令</h4> 
<p>乘法指令把一对寄存器的内容相乘，然后根据指令类型把结果累加到其它的寄存器。 ARM微处理器支持的乘法指令与乘加指令共有6条，根据运算结果可分为32位运算和64位运算两类。64位乘法又称为长整型乘法指令，由于结果太大，不能在放在一个32位的寄存器中，所以把结果存放在2个32位的寄存器Rdlo和Rdhi中。Rdlo存放低32<br> 位，Rdhi存放高32位。与前面的数据处理指令不同，指令中的所有源操作数、目的寄存器必须为通用寄存器，不能对操作数使用立即数或被移位的寄存器。同时，目的寄存器Rd和操作数Rm必须是不同的寄存器。乘法指令与乘加指令共有以下6条：</p> 
<ul><li>MUL 32位乘法指令</li><li>MLA 32位乘加指令</li><li>SMULL 64位有符号数乘法指令</li><li>SMLAL 64位有符号数乘加指令</li><li>UMULL 64位无符号数乘法指令</li><li>UMLAL 64位无符号数乘加指令</li></ul> 
<h5><a id="1___MUL_32_820"></a>1. MUL 32位乘法指令</h5> 
<blockquote> 
 <p>汇编格式：MUL{}{S} Rd,Rm,Rs</p> 
</blockquote> 
<p>功能：MUL指令完成将操作数Rm与操作数Rs 的乘法运算，并把结果放置到目的寄存器Rd中，即Rd=Rm×Rs。S选项决定指令的操作是否影响CPSR中条件标志位的值，有S时指令执行后的结果影响CPSR中条件标志位N和Z值，在ARMv4及以前版本中，标志 C和V不可靠，在ARMV5及以后版本中不影响C和V标志（以下几个乘法指令对于S的规定与此相同）。</p> 
<blockquote> 
 <p>MUL指令示例：</p> 
 <pre><code class="prism language-assembly">MUL　R0,R1,R2　　　;R0 = R1 × R2
MULS R0,R1,R2     ;R0 = R1 × R2，同时设置CPSR中的相关条件标志位
</code></pre> 
</blockquote> 
<h5><a id="2__MLA_32_833"></a>2. MLA 32位乘加指令</h5> 
<blockquote> 
 <p>汇编格式：MLA{}{S} Rd,Rm,Rs,Rn</p> 
</blockquote> 
<p>功能：MLA指令完成将操作数Rm与操作数Rs的乘法运算，再将乘积加上Rn，并把结果放置到目的寄存器Rd中，即Rd=（Rm×Rs）+Rn。如果书写了S，同时根据运算结果设置CPSR中相应的条件标志位。</p> 
<blockquote> 
 <p>MLA指令示例：</p> 
 <pre><code class="prism language-assembly">MLA　 R0,R1,R2,R3  ;R0 = R1× R2+ R3
MLAS  R0,R1,R2,R3  ;R0 = R1× R2+ R3，同时设置CPSR中的相关条件标志位
</code></pre> 
</blockquote> 
<h5><a id="3__SMULL%E3%80%8064_846"></a>3. SMULL　64位有符号数乘法指令</h5> 
<blockquote> 
 <p>汇编格式：SMULL{}{S} Rdlo,Rdhi,Rm,Rs</p> 
</blockquote> 
<p>​ 功 能：SMULL指令实现32位有符号数相乘，得到64位结果。32操作数Rm与32操作数Rs作乘法运算，并把结果的低32位放置到目的寄存器Rdlo中，结果的高32位放置到目的寄存器Rdhi中，即[Rdhi Rdlo]=Rm×Rs。如果书写了S，同时根据运算结果设置CPSR中相应的条件标志位。其中，操作数Rm和操作数Rs均为32位的有符号数。</p> 
<blockquote> 
 <p>SMULL指令示例：</p> 
 <pre><code class="prism language-assembly">SMULL　R0,R1,R2,R3　 ;R0 = （R2×R3）的低32位  Rdlo
                       ;R1 = （R2×R3）的高32位  Rdhi
</code></pre> 
</blockquote> 
<h5><a id="4__SMLAL%E3%80%8064_859"></a>4. SMLAL　64位有符号数乘加指令</h5> 
<blockquote> 
 <p>汇编格式：SMLAL{}{S} Rdlo,Rdhi,Rm,Rs</p> 
</blockquote> 
<p>功能：SMLAL指令实现32位有符号数相乘并累加，得到64位结果。32位操作数Rm与32位操作数Rs作乘法运算，并把结果的低32位同目的寄存器Rdlo中的值相加后又放置到目的寄存器Rdlo中，结果的高32位同目的寄存器Rdhi中的值相加后又放置到目的寄存器Rdhi中，即[Rdhi Rdlo]= [Rdhi Rdlo]+Rm×Rs。如果书写了S，同时根据运算结果设置CPSR中相应的条件标志位。其中，操作数Rm和操作数Rs均为32位的有符号数。对于目的寄存器Rdlo ，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位。对于目的寄存器Rdhi，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</p> 
<blockquote> 
 <p>SMLAL指令示例指令示例：</p> 
 <pre><code class="prism language-assembly">SMLAL　R0,R1,R2,R3　 ;R0 = （R2×R3）的低32位 ＋ R0   Rdlo
                    ;R1 = （R2×R3）的高32位 ＋ R1   Rdhi
</code></pre> 
</blockquote> 
<h5><a id="5__UMULL_64_872"></a>5. UMULL 64位无符号数乘法指令</h5> 
<blockquote> 
 <p>汇编格式：UMULL{}{S} Rdlo,Rdhi,Rm,Rs</p> 
</blockquote> 
<p>功能：UMULL指令实现32位无符号数相乘，得到64位结果。32操作数Rm与32操作数Rs作乘法运算，并把结果的低32位放置到目的寄存器Rdlo中，结果的高32位放置到目的寄存器Rdhi中，即[Rdhi Rdlo]=Rm×Rs。如果书写了S，同时根据运算结果设置CPSR中相应的条件标志位。其中，操作数Rm和操作数Rs均为32位的无符号数。</p> 
<blockquote> 
 <p>UMULL指令示例：</p> 
 <pre><code class="prism language-assembly">UMULL  R0,R1,R2,R3 ;R0 =（R2×R3）的低32位  Rdlo
                   ;R1 =（R2× R3）的高32位  Rdhi
</code></pre> 
</blockquote> 
<h5><a id="6__UMLAL_64_885"></a>6. UMLAL 64位无符号数乘加指令</h5> 
<blockquote> 
 <p>汇编格式：UMLAL{}{S} Rdlo,Rdhi,Rm,Rs</p> 
</blockquote> 
<p>功 能：UMLAL指令实现32位无符号数相乘并累加，得到64位结果。</p> 
<blockquote> 
 <p>UMLAL指令示例指令示例：</p> 
 <pre><code class="prism language-assembly"> UMLAL　R0，R1，R2，R3　	;R0 = （R2×R3）的低32位 ＋ R0   Rdlo
						;R1 = （R2×R3）的高32位 ＋ R1   Rdlo
</code></pre> 
</blockquote> 
<p><strong>使用乘法指令应该注意如下事项</strong></p> 
<ul><li> <p>在操作中使用寄存器，但R15不可用。</p> </li><li> <p>在寄存器的使用中，注意Rd不能同时作为Rm，其它无限制。</p> </li><li> <p>有符号运算和无符号运算的低32位是没有区别的。</p> </li><li> <p>Rdlo、Rdhi和Rm必须使用不同的寄存器</p> </li><li> <p>对于UMULL和UMLAL，即使操作数的最高位为1，也解释为无符号数</p> 
  <blockquote> 
   <p>例 下列指令都是错误的：</p> 
   <pre><code class="prism language-assembly">MUL R1,R1,R6 	;错误，目标寄存器R1不能同时作第一个操作数
MUL R1,R6,[R5]	;错误，不能使用[]
MLA R4,R5,R6	;错误，少1个操作数
MULSNE R6,R3,R0 ;错误，应该写成MULNES
UMLAL R6,R4,R4,R1 ;错误，R4不能同时作Rdlo、Rdlo
SMULL R5,R3,R0  ;错误，少1个操作数
MUL R2,R5,#0x20 ;错误，不可用立即数
</code></pre> 
  </blockquote> </li></ul> 
<h3><a id="7__924"></a>7. 数据加载与存储指令</h3> 
<h4><a id="71_926"></a>7.1数据加载与存储指令概述</h4> 
<p>ARM处理器是加载/存储体系结构的处理器，对存储器的访问只能通过加载和存储指令实现。</p> 
<ul><li> <p><strong>数据加载与存储的方向问题</strong></p> <p>数据加载与存储（Load-store）指令用于在存储器和处理器的寄存器之间传送数据。如图3-18所示，Load用于把内存中的数据装载到寄存器中，而Store则用于把寄存器中的数据存入内存。<img src="https://images2.imgbox.com/90/82/vUaa3cLs_o.png" alt="在这里插入图片描述"></p> <p>数据加载与存储指令共有三种类型：</p> 
  <ul><li> <p>单寄存器加载与存储指令</p> </li><li> <p>多寄存器加载与存储指令</p> </li><li> <p>交换指令。</p> </li></ul> </li><li> <p><strong>数据加载与存储指令的寻址</strong></p> <p>数据加载与存储类指令的基本格式为 opcode{} Rd，addr。格式中opcode为指令代码，如LDR表示将存储器中的数据加载到寄存器中。addr为存储器的地址表达式,也称为第2操作数，可表示为[Rn,offset],其中Rn表示基址寄存器，offset表示偏移量。Addr有如下几种表示形式：</p> 
  <ul><li> <p>立即数<br> 立即数可以是一个无符号的数值，这个数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。如：</p> <pre><code class="prism language-assembly">LDR R5,[R6,#0x08]
STR R6,[R7],#-0x08
</code></pre> </li><li> <p>寄存器<br> 寄存器中的数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。如：</p> </li></ul> <pre><code class="prism language-assembly">LDR R5,[R6,R3]
STR R6,[R7],-R8
</code></pre> 
  <ul><li> <p>寄存器移位<br> 这种格式由一个通用寄存器和一个立即数组成，寄存器中的数值可以根据指令中的移位标志以及移位常数作一定的移位操作，生成一个地址偏移量。这个地址偏移量可以加到基址寄存器，也可以从基址寄存器中减去这个数值。如：</p> <pre><code class="prism language-assembly">LDR R3,[R2,R4,LSL#2]  
LDR R3,[R2],-R4,LSR#3
</code></pre> </li><li> <p>标号<br> 这是一种简单的寻址方法。在这种方法中，程序计数器PC是隐含的基址寄存器，偏移量是语句标号所在的地址和PC（当前正在执行的指令）之间的差值。例如：</p> <pre><code class="prism language-assembly">LDR R4,START 
</code></pre> </li></ul> </li><li> <p><strong>地址索引</strong></p> <p>ARM指令中的地址索引也是指令的一个功能，索引作为指令的一部分，它影响指令的执行结果。地址索引分为前索引(Pre-indexed)、自动索引(Auto-indexed)和后索引(Post-indexed)。</p> 
  <ul><li><strong>前索引</strong></li></ul> <p>前索引也称为前变址，这种索引是在指令执行前把偏移量和基址相加/减，得到的值作为寻址的地址。例如：</p> <pre><code class="prism language-assembly">LDR R5,[R6,#0x04]
STR R0,[R5,-R8]
</code></pre> <p>在上述第1条指令中，在寻址前先把R6加上偏移量4，作为寻址的地址值；在第2条指令中，在寻址前先把基址R5和偏移量R8相减，以计算的结果作为地址值。在这两条指令中，指令完成后，基址寄存器的地址值和指令执行前相同，并不发生变化。</p> <p>在上述第1条指令中，在寻址前先把R6加上偏移量4，作为寻址的地址值；在第2条指令中，在寻址前先把基址R5和偏移量R8相减，以计算的结果作为地址值。在这两条指令中，指令完成后，基址寄存器的地址值和指令执行前相同，并不发生变化。</p> 
  <ul><li><strong>自动索引</strong></li></ul> <p>自动索引也称为自动变址，有时为了修改基址寄存器的内容，使之指向数据传送地址，可使用这种方法自动修改基址寄存器。例如：</p> <pre><code class="prism language-assembly">LDR R5,[R6,#0x04]!
</code></pre> <p>这条指令在寻址前先把R6加上偏移量4，作为寻址的地址值，通过可选后缀“！”完成基址寄存器的更新，本例中执行完操作后R6(基址寄存器)的内容加4。</p> <p>这条指令在寻址前先把R6加上偏移量4，作为寻址的地址值，通过可选后缀“！”完成基址寄存器的更新，本例中执行完操作后R6(基址寄存器)的内容加4。</p> 
  <ul><li> <p><strong>后索引</strong><br> 后索引也称为后变址，后索引就是用基址寄存器的地址值寻址，找出操作数进行操作，操作完成后，再把地址偏移量和基址相加/减，结果送到基址寄存器，作为下一次寻址的基址。例如：</p> <pre><code class="prism language-assembly">LDR R5,[R6],#0x04
STR R6,[R7],#-0x08
</code></pre> <p>在上述指令中，先把R6指向的地址单元的数据赋给R5，再把偏移量4加到基址寄存器R6中去；在第2条指令中，先把R6的值存储到R7指向的地址单元中去，再把偏移量－8加到R7上。在后索引中，基址在指令的执行前后是不相同的。</p> <p>在上述指令中，先把R6指向的地址单元的数据赋给R5，再把偏移量4加到基址寄存器R6中去；在第2条指令中，先把R6的值存储到R7指向的地址单元中去，再把偏移量－8加到R7上。在后索引中，基址在指令的执行前后是不相同的。</p> </li></ul> </li></ul> 
<blockquote> 
 <p><strong>不同索引方式的区别</strong></p> 
 <ul><li> <p>前索引和自动索引的区别是：前索引方式利用对基址寄存器的改变值进行寻址，但是基址寄存器在操作之后仍然保持原值。自动索引在计算出新的地址后要用新的地址更新基址寄存器的内容，然后再利用新的基址寄存器进行寻址；</p> </li><li> <p>前索引和后索引的区别：前索引在指令执行完成后并没有改变基址寄存器的值，后索引在指令执行完成后改变了基址寄存器的地址值。<br> 后索引和自动索引的区别：后索引和自动索引类似，也要更新基址寄存器的内容，但是变址方式先利用基址寄存器的原值进行寻址操作，然后再更新基址寄存器。这两种方式在遍历数组时是很有用的。</p> </li></ul> 
</blockquote> 
<h4><a id="72_1034"></a>7.2单寄存器加载与存储指令</h4> 
<p>这种指令用于把单一的数据传入或者传出一个寄存器。支持的数据类型有字(32位)、半字(16位)和字节。常用的单寄存器加载与存储指令包括：</p> 
<ul><li> <p>LDR/STR 字数据加载/存储指令</p> </li><li> <p>LDRB/STRB 字节数据加载/存储指令</p> </li><li> <p>LDRH/STRH 半字数据加载/存储指令</p> </li><li> <p>LDRSB/LDRSH 有符号数字节/半字加载指令</p> </li></ul> 
<h5><a id="1_LDRSTR_1046"></a>1. LDR/STR字数据加载/存储指令</h5> 
<p>LDR/STR指令的格式和功能如下 ：</p> 
<p>机器编码格式：LDR/STR指令的机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/75/b9/haJQuRbi_o.png" alt="在这里插入图片描述"></p> 
<p>其中：</p> 
<ul><li> <p>cond： 指令执行的条件编码</p> </li><li> <p>I、P、U、W： 用于区别不同的地址模式(偏移量)。I为0时，偏移量为12位立即数；I 为1时，偏移量为寄存器移位</p> </li><li> <p>P表示前/后索引</p> </li><li> <p>U表示加/减</p> </li><li> <p>W表示回写</p> </li><li> <p>L： L为1表示加载，L为0表示存储。</p> </li><li> <p>B： B为1表示字节访问，B为0表示字访问</p> </li><li> <p>Rd： 源/目标寄存器</p> </li><li> <p>Rn： 基址寄存器</p> </li><li> <p>addr_mode： 表示偏移量,是一个12位的无符号二进制数,与Rn一起构成地址 addr</p> </li></ul> 
<blockquote> 
 <p>汇编格式:LDR{}{T} Rd，addr</p> 
</blockquote> 
<p>功能:LDR指令用于从存储器中将一个32位的字数据加载到目的寄存器Rd中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p> 
<blockquote> 
 <p>LDR指令示例：</p> 
 <pre><code class="prism language-assembly">;使用标号
LDR R4,START          ;将存储地址为START的字数据读入R4   
STR R5,DATA1          ;将R5存入存储地址为DATA1中

;前索引
LDR R0，[R1]            ;将存储器地址为R1的字数据读入寄存器R0。
LDR R0，[R1，R2]         ;将存储器地址为R1+R2的字数据读入寄存器R0。
LDR R0，[R1，＃8]        ;将存储器地址为R1+8的字数据读入寄存器R0。
LDR R0，[R1，R2，LSL＃2] ;将存储器地址为R1＋R2×4的字数据读入寄存器R0。

;自动索引
STR R0，[R1，R2]！      ;将R0字数据存入存储器地址为R1+R2的存储单元
						;中，并将新地址R1＋R2写入R1。
STR R0，[R1，＃8]！      ;将R0字数据存入存储器地址为R1+8的存储单元中，
						;并将新地址R1＋8写入R1
STR R0，[R1，R2，LSL＃2]！;将R0字数据存入地址为R1＋R2×4的存储单元中
						;并将新地址R1＋R2×4写入R1。
						
;后索引
LDR R0，[R1]，＃8     		;将存储器地址为R1的字数据读入寄存器R0，并将新地址R1＋8写入R1
LDR R0，[R1]，R2			;将存储器地址为R1的字数据读入寄存器R0，并将新地址R1＋R2写入R1。
LDR R0，[R1]，R2，LSL＃2  ;将存储器地址为R1的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。
</code></pre> 
</blockquote> 
<p><strong>注意事项：</strong></p> 
<ul><li> <p>立即数的规定<br> 立即数绝对值不大于4095的数值，可使用带符号数，即在－4095～＋4095之间。</p> </li><li> <p>标号使用的限制 要注意语句标号不能指向程序存储器的程序存储区，而是指向程序存储器 的数据存储区或数据存储器的数据存储区。另外指向的区域是可修改的，例如，在用户模式下，有些存储区是不能访问的或是只读的。</p> </li><li> <p>地址对齐<br> 字传送时，偏移量必须保证偏移的结果能够使地址对齐。</p> </li><li> <p>使用移位时需注意<br> 使用寄存器移位的方法计算偏移量时，移位的位数不能超过规定的数值。各类移位指令的移位位数规定如下：<br> ASR #n:算术右移（1≤n≤32）<br> LSL #n:逻辑左移（0≤n≤31）<br> LSR #n:逻辑右移（1≤n≤32）<br> ROR #n:循环右移 （1≤n≤31）</p> </li><li> <p>注意程序计数器R15<br> R15作为基址寄存器Rn时，不可以使用回写功能,即使用后缀“！”。另外，R15不可作为偏移寄存器使用。</p> </li></ul> 
<p>针对以上注意事项，在书写汇编指令时要注意指令的正误问题，如下所示。</p> 
<pre><code class="prism language-assembly">LDR R1,[R2,R5]!         ;正确
STR R2,[R3],#0xFFFF8    ;错误，超出了立即数的范围
STREQ R4,[R0,R4,LSL R5] ;错误，不能用寄存器表示移位的位数
LDR R4,[R0,R1,LSL #32]  ;错误，超出了移位的范围
STREQ R3,[R6],#-0x08    ;正确
LDR R0,[R2]!,-R6        ;错误，后索引不用！后缀
LDR R4,START            ;正确
LDR R1,[SP,#-0x04]      ;正确
STR R1,START            ;格式正确，但必须保证标号处可以存储数据
LDR PC,R6               ;错误，R6不表示一个存储地址
LDR PC,[R6]             ;正确
LDR R1,[R3,R15]         ;错误，R15不可作为偏移寄存器
</code></pre> 
<h5><a id="2__LDRBSTRB__1147"></a>2. LDRB/STRB 字节数据加载/存储指令</h5> 
<p>指令的格式和功能如下：<br> 机器编码格式：LDRB/STRB指令的机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/ac/d8/qtuyz6Aj_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>汇编格式: LDRB/STRB {}{T} Rd，addr</p> 
</blockquote> 
<p>功能: LDRB指令用于从存储器中将一个8位的字节数据加载到目的寄存器中，同时将寄存器的高24位清零。该指令通常用于从存储器中读取8位的字节数据到通用寄存器，然后对数据进行处理。当程序计数器 PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p> 
<p>STRB指令用于从源寄存器中将一个8位的字节数据存储到存储器中。该字节数据为源寄存器中的低8位。STRB指令和LDRB指令的区别在于数据的传送方向。</p> 
<p>后缀T为可选后缀，若指令中有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下。T在用户模式下无效，不能与前索引一起使用。</p> 
<p>必须明确的是：即使传送的是8位数据，地址总线仍然以32位的宽度工作，而数据总线也是以32位的宽度工作，传送16位的半字数据，地址总线 和数据总 线也是以32位的宽度工作的，字节传送过程和字传送过程相差很大，下面详细说明。</p> 
<ul><li> <p>从寄存器存储到存储器的过程<br> 由于寄存器中的数据是32位结构，在向存储器存储8位字节时，怎样去选择寄存器中4个字节中的一个字节呢？在ARM指令中，从寄存器到存储器的一字节数据存储只能传送最低8位，即最低字节[7:0]。如果想要存储其它字节，可以采用移位的方法把要存储的字节移至最低字节。从寄存器到存储器的8位字节传送如图所示。<img src="https://images2.imgbox.com/3b/05/QVseWwOS_o.png" alt="在这里插入图片描述"></p> </li><li> <p>从存储器到寄存器的加载过程<br> 和上述不同的是，在实现从存储器到寄存器的加载过程时，可以选择任何一个存储器的地址单元，这时是不要求地址对齐的。也就是说，可以不加限制地选择任何存储器中的字节加载。从存储器到寄存器的8位字节传送如图所示。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/59/07/0wFLHDIl_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>LDRB/STRB指令示例：</p> 
 <pre><code class="prism language-assembly">LDRB R0,[R1]        ;将存储器地址为R1的字节数据读入寄存器R0，并将R0的高24位清零。
LDRB R0,[R1,＃8]    ;将存储器地址为R1＋8的字节数据读入寄存器R0,并将R0的高24位清零。
STRB R0,[R1]        ;将寄存器R0中的字节数据写入以R1,为地址的存储器中。
STRB R0,[R1,＃8]    ;将寄存器R0中的字节数据写入以R1＋8为地址的存储器中。
</code></pre> 
</blockquote> 
<ul><li>LDRH/STRH半字数据加载/存储指令<br> 机器编码格式：LDRH/STRH半字数据加载/存储指令的机器编码格式如图所示。</li></ul> 
<p><img src="https://images2.imgbox.com/6d/eb/YBeBLVji_o.png" alt="在这里插入图片描述"></p> 
<p>图中各位的含义如下：</p> 
<ul><li> <p>cond： 指令执行的条件编码</p> </li><li> <p>I、P、U、W： 用于区别不同的地址模式(偏移量)。I为0时，偏移量为8位立即数；I为1时，偏移量为寄存器移位。P表示前/后变址，U表示加/减，W表示回写。</p> </li><li> <p>L： L为1表示加载，L为0表示存储。</p> </li><li> <p>S： 用于区别有符号访问（S为1）和无符号访问（S为0）</p> </li><li> <p>H： 用于区别半字访问（H为1）或字节访问（H为0）</p> </li><li> <p>Rd： 源/目标寄存器</p> </li><li> <p>Rn： 基址寄存器</p> </li><li> <p>addr_H addr_L： 表示偏移量, I为0时，偏移量为8位立即数由addr_H和addr_L组成；I为1时，偏移量为寄存器移位addr_H为0，addr_L表示寄存器编号。</p> </li><li> <p>汇编格式:</p> 
  <blockquote> 
   <p>LDRH/STRH{} Rd，addr</p> 
  </blockquote> </li></ul> 
<p>功能:LDRH指令用于从存储器中将一个16位的半字数据加载到目的寄存器Rd中，同时将寄存器的高16位清零。该指令通常用于从存储器中读取16位的半字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p> 
<blockquote> 
 <p>LDRH/STRH指令示例：</p> 
 <pre><code class="prism language-assembly">LDRH R0,[R1]   ;将存储器地址为R1的半字数据读入寄存器R0，并将R0的高16位清零。
LDRH R0,[R1,＃8]  ;将存储器地址为R1＋8的半字数据读入寄存器R0，并将R0的高16位清零。
LDRH R0,[R1,R2]   ;将存储器地址为R1＋R2的半字数据读入寄存器R0，并将R0的高16位清零。
STRH R0,[R1]   ;将寄存器R0中的半字数据写入以R1为地址的存储器中。
</code></pre> 
</blockquote> 
<p><strong>使用半字加载/存储指令需要注意如下事项：</strong></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 必须半字地址对齐。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 对于R15的使用需要慎重，R15作为基址寄存器Rn时，不可以使用回写功能；不可使用R15作为目的寄存器。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 立即数偏移使用的是8位无符号数。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 不能使用寄存器移位寻址</li></ul> 
<h5><a id="4___LDRSBLDRSH____1223"></a>4. LDRSB/LDRSH 有符号数字节/半字加载指令</h5> 
<p>机器编码格式：LDRSB/STRSH指令的机器编码格式如图所示。</p> 
<p><img src="https://images2.imgbox.com/0c/26/z1dJx4k4_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>汇编格式:LDRSB/LDRSH{} Rd，addr</p> 
</blockquote> 
<p>功能:LDRSB指令用于从存储器中将一个8位的字节数据加载到目的寄存器中，同时将寄存器的高24位设置为该字节数据的符号位的值，即将该8 位字节 数据进行符号位扩展，生成32位数据。</p> 
<p>LDRSH指令用于从存储器中将一个16位的半字数据加载到目的寄存器Rd中，同时将寄存器的高16位设置为该字数据的符号位的值，即将该16位字数据进行符号位扩展，生成32位数据。</p> 
<blockquote> 
 <p>LDRSB/LDRSH指令示例</p> 
 <pre><code class="prism language-assembly">LDRSB R0,[R1,#4] ;将存储地址为R1+4的有符号字节数据读入R0,R0中的高24位设置成该字节数据的符号位。
LDRSH R6,[R2],#2 ;将存储地址为R2+2的有符号半字数据读入R6,R6中的高16位设置成该字节数据的符号位         			 ;R2=R2+2
</code></pre> 
</blockquote> 
<h4><a id="73_1243"></a>7.3多寄存器加载与存储指令</h4> 
<p>多寄存器加载与存储指令也称为批量数据加载/存储指令，ARM微处理器所支持批量数据加载/存储指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令用于将一片连续的存储器中的数据加载到多个寄存器，批量数据存储指令则完成相反的操作。</p> 
<p>多寄存器加载与存储指令在数据块操作、上下文切换、堆栈操作等方面，比单寄存器加载与存储指令会有更高的执行效率。常用的加载存储指令有LDM和STM指令。</p> 
<h5><a id="1_LDMSTM_1249"></a>1. LDM/STM批量数据加载/存储指令</h5> 
<p>机器编码格式：LDM/STM指令的机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/ff/0c/rV1f3MKx_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图中各位的含义如下：</strong></p> 
<ul><li>cond： 指令执行的条件编码</li><li>P、U、W： 用于区别不同的地址模式(偏移量)。P表示前/后变址，U表示加/减，W表示回写。</li><li>S: 用于区别有符号访问(S为1)和无符号访问(S为0)。</li><li>L： L为1表示加载，L为0表示存储。</li><li>Rn： 基址寄存器</li><li>regs: 表示寄存器列表</li></ul> 
<blockquote> 
 <p>汇编格式：LDM/STM{}{} Rn{！}，{∧}</p> 
</blockquote> 
<p>功能：LDM指令用于从基址寄存器所指示的一片连续存储器中读取数据到寄存器列表所指示的多个寄存器中，内存单元的起始地址为基址寄存器Rn的值，各个寄存器由寄存器列表regs表示。该指令一般 用于多个寄存器数据的出栈操作。</p> 
<p>STM指令用于将寄存器列表所指示的多个寄存器中的值存入到由基址寄存器所指示的一片连续存储器中，内存单元的起始地址为基址寄存器Rn的值，各 个寄存器由寄存器列表regs表示。指令的其它参数的用法和LDM指令是相同的。该指令一般用于多个寄存器数据的进栈操作。</p> 
<p>指令中，type表示类型，用于数据的存储与读取有以下几种情况：</p> 
<ul><li>IA每次传送后地址值加</li><li>IB每次传送前地址值加</li><li>DA每次传送后地址值减</li><li>DB每次传送前地址值减</li><li>用于堆栈操作时有如下几种情况：</li><li>FD 满递减堆栈</li><li>ED 空递减堆栈</li><li>FA满递增堆栈</li><li>EA空递增堆栈</li></ul> 
<p>{！}为可选后缀，若选用该后缀，则当数据加载与存储完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。基址寄存器不允许为R15，寄存器列表可以为R0～R15的任意组合。</p> 
<p>{∧}为可选后缀，当指令为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据加载与存储之外，还将SPSR复制到CPSR。同时，该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。<br> LDM/STM指令依据其后缀名（如IA、IB）的不同，其寻址的方式也有很大不同。具体如表所示</p> 
<p><img src="https://images2.imgbox.com/d1/b8/ORrL1Cls_o.png" alt="在这里插入图片描述"></p> 
<p>从表中可以看出，指令分为两组：一组用于数据的存储与读取，对应于IA、IB、DA、DB；一组用于堆栈操作，即进行压栈与出栈的操作，对应于FD、ED、FA、EA。</p> 
<h5><a id="2_LDMSTM_1293"></a>2. LDM/STM指令寻址的区别</h5> 
<p>下图给出了数据块操作的用法，从图中可以看出，每条指令是如何将4个寄存器的数据存入存储器的，以及在使用自动变址的情况下基址寄存器是如何变化的。执行指令之前基址寄存器为R0，自动变址之后为R0’。需要注意的是，在递增方式下(即图中的IA、IB方式)，寄存器存储的顺序是R1、R2、R3、R4；而在递减方式下(即图中的DA、DB方式)，寄存器存储的顺序是R4、R3、R2、R1。</p> 
<p><img src="https://images2.imgbox.com/45/76/W4LCY7Oz_o.png" alt="在这里插入图片描述"></p> 
<p>【例】 设执行前：R0=0x00090010、R6=R7=R8=0x00000000，存储器地址为0x00090010存储的内容如图1所示</p> 
<p><img src="https://images2.imgbox.com/17/82/ievMW7Jq_o.png" alt="在这里插入图片描述"></p> 
<p>​ 图1 指令执行前</p> 
<p>则分别执行指令</p> 
<p>LDMIA R0!,{R6-R8}<br> LDMIB R0!,{R6-R8}<br> 各相关寄存器值的变化分别如何？</p> 
<blockquote> 
 <p>分析：指令"LDMIA R0!,{R6-R8}"的执行过程如下：以R0的值(0x00090010)为基地址取出一个32位数据（0x00000001）放入寄存器R6，然后R0的值加4写回到R0，继续取出一个32位数据放入R7，一次类推，最后执行完的结果如图2所示：</p> 
 <p><img src="https://images2.imgbox.com/09/f9/58QfIqCC_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>​ 图2 LDMIA指令执行后</p> 
 <p>指令LDMIB R0!,{R6-R8}的执行过程如下：以R0的值加4 (0x00090014)为基址取出一个32位数(0x00000002)放入寄存器R6,然后将地址值(0x00090014)写回到R0，继续取出一个32位数据放入R7,依次类推，最后LDMIB R0!,{R6-R8}指令执行完后各寄存器的值如图3所示</p> 
 <p><img src="https://images2.imgbox.com/6a/86/gOAnTtRE_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>​ 图3 LDMIB指令执行后</p> 
 <p>通过以上例子可以比较出IA和IB的区别：IA是每次取值后增加地址值，IB是每次地址值增加后再取值。同理可以得出DA和DB的区别，只不过此时地址值不是做加法，是做减法而已。</p> 
</blockquote> 
<h4><a id="74__1331"></a>7.4 堆栈操作</h4> 
<ul><li><strong>堆栈概念:</strong></li></ul> 
<blockquote> 
 <p>堆栈就是在RAM存储器中开辟(指定)的一个特定的存储区域，在这个区域中，信息的存入（此时称为推入）与取出（此时称为弹出）的原则不再是“随机存取”，而是按照“后进先出”的原则进行存取。我们称该“存储区”为堆栈。</p> 
</blockquote> 
<p>按照上述定义，我们可以把堆栈想像成一个开口朝下的容器。堆栈的构造如图所示。</p> 
<p><img src="https://images2.imgbox.com/d4/56/njYP1oIN_o.png" alt="在这里插入图片描述"></p> 
<p>堆栈的一端是固定的，另一端是浮动的。堆栈固定端是堆栈的底部，称为栈底。堆栈浮动端可以推入或弹出数据。向堆栈推入数据时，新推入的数据堆放在以前推入数据的上面，而最先推入的数据被推至堆栈底部，最后推入的 数据堆放在堆栈顶部，这称为栈顶。从堆栈弹出数据时，堆栈顶部数据最先弹出，而最先推入的数据则是最后弹出。</p> 
<p>由于堆栈顶部是浮动的，为了指示现在堆栈中存放数据的位置，通常设置一个堆栈指针SP（R13），它始终指向堆栈的顶部。这样，堆栈中数据的进出都由SP来“指挥”。</p> 
<p>当一个数据（32位）推入堆栈时，SP（R13的值减4）向下浮动指向下一个地址，即新的栈顶。当数据从堆栈中弹出时，SP（R13的值加4）向上浮动指向新的栈顶。</p> 
<ul><li> <p><strong>堆栈操作</strong><br> 堆栈的操作包括建栈、进栈、出栈三种基本操作。</p> 
  <ol><li> <p>建栈<br> 建栈就是规定堆栈底部在RAM存储器中的位置，如:用户可以通过<br> LDR命令设置SP的值来建立堆栈。<br> LDR R13,=0x90010<br> LDR SP,= 0x90010<br> 这时，SP指向地址0x90010,栈中无数据，堆栈的底部与顶部是重<br> 叠，是一个空栈。</p> </li><li> <p>进栈</p> <p>ARM体系结构中使用多寄存器指令来完成堆栈操作。出栈使用 LDM指令，进栈使用STM指令。LDM和STM指令往往结合下面一些参数实现堆栈的操作。</p> </li></ol> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> FD满递减堆栈</p> 
  <ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> ED空递减堆栈</li></ul> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> FA满递增堆栈</p> 
  <ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> EA空递增堆栈</li></ul> <p>在使用一个堆栈的时候，需要确定堆栈在存储器空间中是向上生长还是向下生长的。向上称为递增(Ascending),向下称为递减(Descending)。</p> <pre><code>满堆栈(Full stack)是指堆栈指针SP(R13)指向堆栈的最后一个已使用的地址或满位置（也就是SP指向堆栈的最后一个数据项的位置）；相反，空堆栈（Empty stack）是指SP指向堆栈的第一个没有使用的地址或空位置。
</code></pre> <p>ARM制定了ARM-Thumb过程调用标准（ATPCS）,定义了例程如何被调用，寄存器如何被分配。在ATPCS中，堆栈被定义为满递减式堆栈，因此LDMFD和STMFD指令分别用来支持POP操作（出栈）和PUSH操作（进栈）。进栈(PUSH)操作就是把数据推入堆栈的操作。ARM中进栈或出栈操作都是以字（32位）为单位的。</p> 
  <ol start="3"><li> <p>出栈</p> <p>出栈(POP)操作就是把数据从堆栈中读出的操作，ARM中使用LDMFD实现出栈的操</p> </li></ol> 
  <blockquote> 
   <p>【例】下列指令说明了进栈和出栈的过程，设指令执行之前SP＝0x00090010（R13）,R4=0x00000003, R3=0x00000002, R2=0x00000001, 将R2-R4入栈，然后出栈，注意进栈和出栈后SP的值？</p> 
  </blockquote> </li></ul> 
<blockquote> 
 <pre><code>                       STMFD SP!,{R2-R4}
                       LDMFD SP!,{R6-R8}
</code></pre> 
 <p>分析：第一条指令将R2-R4的数据入栈,指令执行前SP的值为0x00090010,指令执行时SP指向下一个地址（SP-4）存放R4，然后依次存放R3、R2，数据 入栈后SP的值为0x00090004,指向堆栈的满位置，如果有数据继续入栈则下一地址为 0x90000。其过程如图1所示，注意入栈的顺序。</p> 
 <p><img src="https://images2.imgbox.com/d1/a1/CsrzapoA_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>​ 图1 进栈操作</p> 
 <p>第二条指令实现退栈操作,在第一条指令的基础上，表示将刚才入栈的数<br> 据分别退栈到R6-R8，退栈后SP指向0x00090010。实际上STMFD指令相<br> 当于STMDB指令，LDMFD指令相当于LDMIA指令。</p> 
</blockquote> 
<h4><a id="75_1398"></a>7.5交换指令</h4> 
<p>ARM微处理器所支持数据交换指令能在存储器和寄存器之间交换数据。数据交换指令是数据加载与存储指令的一种特例，交换指令是一个原子操作，在操作期间阻止其它任何指令对该存储单元的读/写。 数据交换指令有如下两条：<br> SWP 字数据交换指令<br> SWPB 字节数据交换指令<br> 机器编码格式：交换指令的机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/2a/d7/lkUWtbLR_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图中各位的含义如下：</strong></p> 
<ul><li>cond： 指令执行的条件编码</li><li>B： 表示字交换（B=0）或字节交换（B=1）</li><li>Rn： 基址寄存器</li><li>Rd： 目的寄存器</li><li>Rm： 源寄存器</li></ul> 
<h5><a id="1_SWP_1416"></a>1. SWP字数据交换指令</h5> 
<blockquote> 
 <p>汇编格式：SWP{} ，,[]</p> 
</blockquote> 
<p>功能：SWP指令用于将寄存器Rn所指向的存储器中的字数据加载到目的寄存器Rd中，同时将源寄存器Rm中的字数据存储到寄存器Rn所指 向的存储器中，即Rd=[Rn] ,[Rn]=Rm。显然，当寄存器Rm和目的寄存器Rd为同一个寄存器时（两者应与Rn不同），指令交换该寄存器和存储器的内容。</p> 
<blockquote> 
 <p>SWP指令示例：</p> 
 <pre><code class="prism language-assembly">SWP R0,R1,[R2]  ;将R2所指向的存储器中的字数据加载到R0，
				;同时将R1中的字数据存储到R2所指向的存储单元。
SWP R0,R0,[R1]  ;将R1所指向的存储器中的字数据与R0中的字数据交换
</code></pre> 
</blockquote> 
<h5><a id="2_SWPB_1430"></a>2. SWPB字节数据交换指令</h5> 
<blockquote> 
 <p>汇编格式：SWPB{} ，,[]</p> 
</blockquote> 
<p>功 能：SWPB指令用于将寄存器Rn所指向的存储器中的字节数据加载到目的寄存器Rd中，目的寄存器的高24清零，同时将源寄存器Rm中的字数据存储到寄存器Rn所指向的存储器中。显然，当寄存器Rm和目的寄存器Rd 为同一个寄存器时（两者应与Rn不同），指令交换该寄存器和存储器的内容。</p> 
<blockquote> 
 <p>SWPB指令示例：</p> 
 <pre><code class="prism language-assembly">SWPB R0,R1,[R2] ;将R2所指向的存储器中的字节数据加载到R0，R0的高24位清零
				;同时将R1中的低8位数据存储到R2所指向的存储单元。
SWPB R0,R0,[R1] ;将R1所指向的存储器中的字节数据与R0中的低8位数据交换。
</code></pre> 
</blockquote> 
<p><strong>使用SWP和SWPB指令时需要注意：</strong></p> 
<ul><li>PC不能用作指令中的任何寄存器。</li><li>基址寄存器Rn不应与源寄存器Rm或目的寄存器Rd相同，但是Rm和Rd可以相同。</li><li>寄存器位置不可为空，必须满足3个寄存器。</li></ul> 
<h3><a id="8__1450"></a>8. 分支指令</h3> 
<p>分支指令是一种很重要的指令，分支指令用于实现程序流程的跳转，这类指令可用来改变程序的执行流程或者调用子程序。</p> 
<p>在ARM程序中有两种方法可以实现程序流程的跳转：一种是使用分支指令，另一种是直接向程序计数PC（R15）写入目标地址值。通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，而使用分支指令，其跳转空间受到限制。</p> 
<p>ARMV5E架构指令集中的分支指令如表3-7所示，分支指令可以完成从当前指令向前或向后的32MB的地址空间的跳转。</p> 
<p><img src="https://images2.imgbox.com/b0/6d/lZV2HQGi_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_B_1463"></a>1. 分支指令B</h4> 
<p>B指令的格式和功能如下：<br> 机器编码格式：B和BL分支指令的机器编码格式如图所示。</p> 
<p><img src="https://images2.imgbox.com/d4/f0/3zl3aJzo_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图中各位的含义如下：</strong></p> 
<ul><li>cond： 表示指令执行的条件</li><li>L： 用来区分分支（L=0）和带返回的分支（L=1）指令。</li><li>Label： 表示偏移量，是一个24位有符号立即数。</li></ul> 
<blockquote> 
 <p>汇编格式：B{} label</p> 
</blockquote> 
<p><strong>功能</strong>：B指令是最简单的分支指令。一旦遇到 B 指令，ARM 处理器 将立即跳转到给定的目标地址label，即PC=label,从那里继续执行。这里label表示一个符号地址，它的实际值是相当前PC值的一个偏移量，而不是一个绝对地址，它的值由汇编器来计算。它是 24 位有符号数，左移两位后有符号扩展为 32 位，然后与PC值相加，即得到跳转的目的地址。跳转的范围为－32M～＋32M。</p> 
<blockquote> 
 <p>B指令示例：</p> 
 <pre><code class="prism language-assembly">backword    SUB  Rl,R1,＃1
			CMP  R1,＃0      ;比较R1和0 
			BEQ  forward      ;如果R1=0 则跳转到forward处执行
			SUB R1,R2,#3
			SUB R1,R1,#1
forward     ADD R1,R2,#4
			ADD R2,R3,#2
			B backword        ;程序无条件跳转到标号backword处执行
</code></pre> 
</blockquote> 
<h4><a id="2_BL_1494"></a>2. 带返回的分支指令BL</h4> 
<p>BL指令的格式和功能如下：<br> 机器编码格式：机器编码格式如图所示。</p> 
<p><img src="https://images2.imgbox.com/bd/1c/vfox4sV6_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>汇编格式：BL{} label</p> 
</blockquote> 
<p><strong>功 能</strong>：BL指令是另一个跳转指令，与B指令不同的是：在跳转之前，将PC的当前内容保存在寄存器R14（LR）中保存。因此，可以通过将R14 的内容重新加载到PC中，返回到跳转指令之后的那个指令处执行。该指令用于实现子程序的调用，程序的返回可通过把LR寄存器的值复制到PC寄存器中来实现。</p> 
<blockquote> 
 <p>BL指令示例</p> 
 <pre><code class="prism language-assembly">…
BL func         ;跳转到子程序
ADD R1,R2,#2    ;子程序调用完返回后执行的语句，返回地址
…
func            ;子程序
…               ;子程序代码
MOV R15,R14     ;复制返回地址到PC，实现子程序的返回
</code></pre> 
 <p>分析：该例说明了子程序调用和返回的结构，程序执行到BL语句时，PC指向下一个要执行的语句，此时PC(R15)中的值为下一个语句ADD指令所在的地址。由于BL是一个分支指令，这个指令将改变PC的值使之指向子程序所在的地址，从而调用子程序，子程序调用完后就涉及到程序返回到断点地址重新执行的问题。BL指令不但修改PC的值使之指向子程序，而且还将断点地址保存在LR（R14）寄存器中，此例中即ADD指令所在的地址。子程序的功能实现完后，常常用一个MOV指令将LR(14)中的值复制到PC(R15)中，从而实现了子程序调用的返回功能,其调用关系如图所示。</p> 
 <p><img src="https://images2.imgbox.com/3f/26/U4FXz3OE_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>​ 图 BL指令实现子程序调用</p> 
</blockquote> 
<h4><a id="3_BX_1525"></a>3. 带状态切换的分支指令BX</h4> 
<p>BX指令的格式和功能如下：<br> 机器编码格式:机器编码格式如图所示。</p> 
<p><img src="https://images2.imgbox.com/3b/26/fRPfhduS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图中各位的含义如下：</strong></p> 
<ul><li>cond: 指令执行的条件。</li><li>op: 用来区别BX指令（op=0）和BLX指令(op=1)</li></ul> 
<blockquote> 
 <p>汇编格式：BX{} Rm</p> 
</blockquote> 
<p><strong>功 能</strong>：BX指令跳转到指令中所指定的目标地址，并实现状态的切换。Rm是一个表达目标地址的寄存器。当Rm中的最低位Rm[0]为1时，强制程序从ARM指令状态跳到Thumb指令状态；当Rm中的最低位Rm[0]为0时，强制程序从Thumb指令状态跳到ARM指令状态。</p> 
<blockquote> 
 <p>BX指令示例</p> 
 <pre><code class="prism language-assembly">CODE32                  ;ARM程序段，32位编码
arm1   ADR R0,thumb1+1  ;伪指令，把语句标号thumb1所在的地址赋给R0，
                        ;末位R0[0]置1，要跳转到THUMB指令集
MOV LR,PC       		;设置返回地址
BX R0           		;跳转
ADD R1,R2,#2    		;返回地址处，第4条指令

CODE16           		;THUMB程序段，16位编码
thumb1 ADD R1,R3,#1     ;THUMB程序
…
BX LR            		;跳转到返回地址处，执行第4条指令
</code></pre> 
 <p>分析：该例说明了带状态切换的子程序调用和返回的结构，ARM程序段执行MOV LR,PC语句时将返回地址保存到了LR寄存器中。执行到BX语句时，PC指向下一个要执行的语句，此时PC(R15)中的值为下一个语句ADD指令所在的地址，并根据R0中的bit[0]实现了由ARM状态切换到Thumb状态。从而调用Thumb子程序，子程序调用完后使用BX LR指令，从而实现了子程 序调用的返回并切换到ARM状态。</p> 
</blockquote> 
<h4><a id="4_BLX_1560"></a>4. 带返回和状态切换的分支指令BLX</h4> 
<p>BLX指令是在ARMv5架构(如ARM1020E)下支持的分支指令</p> 
<p>机器编码格式:机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/2f/20/NtOgCUkn_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>汇编格式：BLX{} label|Rm</p> 
</blockquote> 
<p><strong>功能</strong>：BLX指令跳转到指令中所指定的目标地址，并实现状态的切换,同时将PC(R15)的值保存到LR寄存器（R14）中。其目标地址可以是一个符号地址（label）,或者是一个表达目标地址的寄存器Rm。如果目标地址处为Thumb指令，则程序状态从ARM状态切换为Thumb状态。因此，当子程序使用Thumb指令集，而调用者使用ARM指令<br> 集时，可以通过BLX指令实现子程序的调用和处理器工作状态的切换。同时，子程序的返回可以通过将寄存器R14值复制到PC中来完成。</p> 
<blockquote> 
 <p>BL指令示例</p> 
 <pre><code class="prism language-assembly">CODE32           		;ARM程序段，32位编码
arm1  ADR R0,thumb1+1   ;伪指令，把语句标号thumb1所在的地址赋
						;给R0，末位R0[0]置1，要跳转到THUMB指令集
;MOV LR,PC       		；该指令注销 ，比较BL指令
BLX R0         			;跳转,同时设置返回地址 即PCLR
ADD R1,R2,#2    		;返回地址处，第4条指令

CODE16           		;THUMB程序段，16位编码
thumb1 ADD R1,R3,#1     ；THUMB程序
…
BX LR            		;跳转到返回地址处，执行第4条指令
</code></pre> 
 <p>分析：使用BLX指令代替BX指令简化了Thumb例程的调用，因为BLX指令在连接寄存器LR中自动设置了返回地址。比较上例，该例中不需要使用MOV LR，PC指令来保存PC的值了。</p> 
</blockquote> 
<h3><a id="9__1592"></a>9. 程序状态寄存器访问指令</h3> 
<p>ARM微处理器中的程序状态寄存器不属于通用寄存器，为了使用方便，ARM专门为程序状态寄存器设立了2条访问指令，用于在程序状态寄存器和通用寄存器之间传送数据，程序状态寄存器访问指令如下表所示。</p> 
<p><img src="https://images2.imgbox.com/16/1d/YRJSfG7O_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_MRS_1598"></a>1. MRS程序状态寄存器到通用寄存器的数据传送指令</h4> 
<p>机器编码格式:机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/23/87/B7W31kZ7_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图中各位的含义如下：</strong></p> 
<ul><li>cond ： 指令执行的条件</li><li>R ： 用来区别CPSR(R=0)和SPSR（R=1）。</li><li>Rd ： 表示目标寄存器，Rd不允许为R15。</li></ul> 
<blockquote> 
 <p>汇编格式：MRS{}，&lt;CPSR|SPSR&gt;</p> 
</blockquote> 
<p><strong>功 能</strong>：MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。该指令一般用在以下情况：</p> 
<ol><li>当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用 该指令读出程序状态寄存器的值，然后保存。</li><li>当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器。</li></ol> 
<blockquote> 
 <p>MRS指令示例：</p> 
 <pre><code class="prism language-assembly">MRS R0,CPSR	;传送CPSR的内容到R0
MRS R0,SPSR	;传送SPSR的内容到R0
</code></pre> 
</blockquote> 
<h4><a id="2_MSR_1624"></a>2. MSR通用寄存器到程序状态寄存器的数据传送指令</h4> 
<p>MRS指令的格式和功能如下：<br> 机器编码格式:机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/9a/17/VVNlD9zB_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图中各位的含义如下</strong>：</p> 
<ul><li>cond ： 指令执行的条件</li><li>R ： 用来区别CPSR(R=0)和SPSR（R=1）。</li><li>Field_mask ： 域屏蔽</li><li>immed ： 8位立即数</li><li>Rm ： 操作数寄存器</li></ul> 
<blockquote> 
 <p>汇编格式：MSR{}&lt;CPSR|SPSR&gt;_，&lt;Rm|#immed&gt;</p> 
</blockquote> 
<p><strong>功能</strong>：MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中。其中，状态寄存器是指CPSR或SPSR，一般指当前工作模式下的状态寄存器。操作数可以为通用寄存器Rm或立即数#immed。域用于设<br> 置程序状态寄存器中需要操作的位，32位的程序状态寄存器可分为4个域， 如图所示：</p> 
<p><img src="https://images2.imgbox.com/da/d4/eojxTGvv_o.png" alt="在这里插入图片描述"></p> 
<ul><li>位[31：24]为条件标志位域，用f表示；</li><li>位[23：16]为状态位域，用s表示；</li><li>位[15：8]为扩展位域，用x表示；</li><li>位[7：0]为控制位域，用c表示；</li></ul> 
<p>**位域的表示方法：**在CPSR或SPSR后面使用一下划线，然后是位域。上述位域可以任意组合，之间不用隔点，必须小写才有效。例如CPSR_c和 CPSR_cxsf都是正确的表达式。该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。</p> 
<blockquote> 
 <p>MSR指令示例：</p> 
 <pre><code class="prism language-assembly">MSR CPSR,R0   ;传送R0的内容到CPSR
MSR SPSR,R0   ;传送R0的内容到SPSR
MSR CPSR_c,R0 ;传送R0的内容到CPSR，仅修改CPSR中的控制位域
</code></pre> 
</blockquote> 
<p>将MRS和MSR指令结合起来可以对程序状态寄存器进行修改，从而可以实现处理器模式转换，设置异常中断的开和关。正确的修改方法是对状态寄存器进行读，然后修改，再写入状态寄存器。例如，下列指令序列说明了使能IRQ中断的过程：</p> 
<pre><code class="prism language-assembly">MRS R1,CPSR
BIC R1,R1,#0x80
MSR CPSR_c,R1
</code></pre> 
<p>MRS指令先把CPSR的值复制到R1,然后使用BIC清除R1的位7；再使用MSR把R1的值复制到CPSR，从而实现了使能IRQ中断的功能。这个例子中只是修改了控制域的I位，而没有修改其它位。该例是在SVC模式下执行。在用户模式下可以读取CPSR，但是只能更改条件标志域f。</p> 
<h3><a id="10__1673"></a>10. 协处理器指令</h3> 
<p>协处理器指令用于扩展指令集。协处理器指令既可用于提供附加的计算能力，又可用于控制包括Cache和内存管理的存储子系统。</p> 
<p>协处理器指令包括数据处理、寄存器传输及内存传输指令。这里介绍的协处理器指令主要用于ARM处理器初始化、ARM协处理器的数据处理操作、在ARM处理器的寄存器和协处理器的寄存器之间传送数据以及在ARM协处理器的寄存器和存储器之间传送数据。ARM协处理器指令如表3-9所示。</p> 
<p><img src="https://images2.imgbox.com/ce/3f/bXJ2CPGS_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_CDP_1682"></a>1. CDP协处理器数据处理指令</h4> 
<p>CDP指令的格式和功能如下：<br> 机器编码格式:机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/b7/d3/6RaLqtLs_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图中各位含义如下：</strong></p> 
<ul><li>cond： 指令执行的条件</li><li>opcode1 opcode2： 协处理器将执行的操作。</li><li>CRm CRn： 存放操作数的协处理器寄存器</li><li>CRd： 作为目的寄存器的协处理器寄存器</li><li>p： 协处理器编号,0≤p≤15</li></ul> 
<blockquote> 
 <p>汇编格式：CDP{}</p> 
 <p>，opcode1，CRd，CRm，CRn{，opcode2}</p> 
 <p></p> 
</blockquote> 
<p><strong>功能</strong>：ARM处理器通过CDP指令通知ARM协处理器p,要求其在寄存器CRn 和CRm上，进行操作opcode1，并把结果放到CRd中，可以使用opcode2 提供与操作有关的补充信息。若协处理器不能成功完成特定的操作，则产 生未定义指令异常。指令中的所有寄存器均为协处理器的寄存器，操作由协处理器完成,指令不涉及ARM处理器的寄存器和存储器。</p> 
<blockquote> 
 <p>CDP指令示例：</p> 
 <pre><code class="prism language-assembly">CDP P3,2,C12,C10,C3,4  ;该指令完成协处理器P3的初始化
</code></pre> 
</blockquote> 
<h4><a id="2_LDC_1708"></a>2. LDC协处理器数据加载指令</h4> 
<p>LDC指令的格式和功能如下：<br> 机器编码格式:机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/c8/de/1Y3sCqDh_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图中各位含义如下：</strong></p> 
<ul><li>cond ： 指令执行的条件</li><li>P、U、W ： 用于区别不同的地址模式。</li><li>N： 数据的大小(依赖于协处理器)</li><li>Op ： 用于区别LDC指令(op=1)还是STC指令（op=0）</li><li>Rn ： ARM处理器中的作为基地址的寄存器</li><li>CRd： 作为目的寄存器的协处理器寄存器</li><li>P ： 为协处理器编号,0≤p≤15</li><li>addr ： 8位立即数偏移量</li></ul> 
<blockquote> 
 <p>汇编格式：LDC{}{L} </p> 
 <p>,,</p> 
 <p></p> 
</blockquote> 
<p><strong>功 能</strong>：LDC指令将addr所表示的存储器中的字数据传送到目的寄存器CRd中，若协处理器不能成功完成传送操作，则产生未定义指令异常。其中，{L}选项表示指令为长读取操作，例如：用于双精度数据的传输。addr为存储器的地址表达式，可表示为[Rn,offset],其中Rn表示基址寄存器，是ARM处理器中的寄存器，offset表示偏移量，是一个8位的无符号二进制数。addr的有如下3种表达形式：</p> 
<ul><li>偏移为0的地址表达式，如：[R6]；</li><li>前索引立即数偏移的表达式，如：[R0,#0x04]；</li><li>后索引立即数偏移的表达式，如：[R4],#0x08。</li></ul> 
<blockquote> 
 <p>LDC指令示例：</p> 
 <pre><code class="prism language-assembly">LDC P5,C1,[R0]  ;将ARM处理器的寄存器R0所指向的存储器中
				;的字数据传送到协处理器P5的寄存器C1中。
</code></pre> 
</blockquote> 
<h4><a id="3_STC_1742"></a>3. STC协处理器数据存储指令</h4> 
<p>STC指令的格式和功能如下：<br> 机器编码格式:机器编码格式如图示</p> 
<p><img src="https://images2.imgbox.com/b4/0d/t1mWZv75_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>汇编格式：STC{}{L} </p> 
 <p>,,</p> 
 <p></p> 
</blockquote> 
<p><strong>功能</strong>：STC指令用于将寄存器CRd的字数据传送到addr所表示的存储器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。STC指令格式中参数的约定和LDC指令格式一致。</p> 
<blockquote> 
 <p>STC指令示例：</p> 
 <pre><code class="prism language-assembly">STC P3,C4,[R0]  ;将协处理器P3的寄存器C4中的字数据传送到ARM
                 ;处理器的寄存器R0所指向的存储器中。
</code></pre> 
</blockquote> 
<h4><a id="4_MCR_ARM_1761"></a>4. MCR ARM处理器寄存器到协处理器寄存器的数据传送指令</h4> 
<p>MCR指令的格式和功能如下：<br> 机器编码格式:机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/23/b7/Kt0nKgEF_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图中各位含义如下：</strong></p> 
<ul><li>Cond ： 指令执行的条件</li><li>opcode1、opcode2 ：协处理器将执行的操作。</li><li>op ： 用于区别MCR指令(op=0)还是MRC指令（op=1）</li><li>CRm、CRn ： 存放操作数的协处理器寄存器</li><li>Rd ： ARM处理器中的作为源或目标的寄存器</li><li>P ： 协处理器编号,0≤p≤15</li></ul> 
<blockquote> 
 <p>汇编格式：MCR{}</p> 
 <p>，opcode1，Rd，CRm，CRn{，opcode2}</p> 
 <p></p> 
</blockquote> 
<p><strong>功能</strong>：MCR指令用于将ARM处理器寄存器Rd中的数据传送到协处理器寄存器CRm，CRn中,若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码opcode1和opcode2为协处理器将要执行的操作，Rd为源寄存器，是ARM处理器的寄存器，CRm,CRn为目的寄存器，均为协处理器的寄存器。</p> 
<blockquote> 
 <p>MCR指令示例：</p> 
 <pre><code class="prism language-assembly">MCR P5,5,R1,C1,C2,9  ;将ARM处理器寄存器R1中的数据传送到协处理器P5的寄存器C1和C2中，
					;协处理器执行操作5和9。
</code></pre> 
</blockquote> 
<h4><a id="5MRCARM_1789"></a>5.MRC协处理器寄存器到ARM处理器寄存器的数据传送指令</h4> 
<p>MRC指令的格式和功能如下：<br> 机器编码格式:机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/0d/46/NJYmXnAD_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>汇编格式：MRC{}</p> 
 <p>，opcode1，Rd，CRm，CRn{，opcode2}</p> 
 <p></p> 
</blockquote> 
<p><strong>功能</strong>：MRC指令用于将协处理器寄存器中的数据传送到ARM处理器寄存器中, 若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码opcode1和opcode2为协处理器将要执行的操作，Rd为目的寄存器，是ARM处理器的寄存器，CRm,CRn为源寄存器，均为协处理器的寄存器。</p> 
<blockquote> 
 <p>MRC指令示例：</p> 
 <pre><code class="prism language-assembly">MRC P3,3,R0,C4,C5,6    ;协处理器P3执行操作3和6，操作数为C4、C5，
					   ;其操作的结果传送到ARM处理器寄存器R0中
</code></pre> 
</blockquote> 
<h3><a id="11__1808"></a>11. 软件中断指令</h3> 
<p>ARM指令集中的软件中断指令是唯一一条不使用寄存器的ARM指令，也是一条可以条件执行的指令。</p> 
<p>ARM指令在用户模式中受到很大的局限，有一些资源不能访问，在需要访问这些资源时，使用软件控制的唯一可行的方法就是使用SWI（SoftWare Interrupt）指令，也称为软件中断指令。</p> 
<h4><a id="1_SWI_1814"></a>1. SWI软件中断指令</h4> 
<p>指令的格式和功能如下：</p> 
<p>机器编码格式:机器编码格式如图所示</p> 
<p><img src="https://images2.imgbox.com/28/24/nFwPn9Ur_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图中各位的含义如下：</strong></p> 
<ul><li>cond ： 指令执行的条件</li><li>swi_num： 24位立即数，表示调用类型。</li></ul> 
<blockquote> 
 <p>汇编格式：SWI{} SWI_number</p> 
</blockquote> 
<p><strong>功能</strong>：SWI指令用于产生软件中断，以便用户程序能调用操作系统的系统例程。操作系统在SWI的异常处理程序中提供相应的系统服务，指令中SWI_number 为24位的立即数，该数指定用户程序调用系统例程的类型，相关参数通过通用寄存器传递，当指令中24位的立即数被忽略时，用户程序调用系统例程的类型由通用寄存器R0的内容决定，同时，参数通过其它通用寄存器传递。</p> 
<blockquote> 
 <p>指令示例：</p> 
 <pre><code class="prism language-assembly">SWI  0x02 ;该指令调用操作系统编号为02的系统例程。
</code></pre> 
</blockquote> 
<p><strong>说明：</strong></p> 
<ol><li>软件中断进入的是管理模式，中断后会改变程序状态寄存器中的相关位。</li><li>中断后处理器把0x00000008赋给PC，并把中断处地址保存在LR 中，把CPSR保存在SPSR中。</li><li>SWI_number是向中断服务程序传递一个参数。不需要传递参数时，应该把表达式写作0，表达式不可省略。</li></ol> 
<h4><a id="2SWI_1844"></a>2．SWI的调用</h4> 
<p>当程序执行这条语句时，将进入异常中断。此时，需要把ARM处理器从用户模式改变到管理模式。执行这条指令，ARM处理器硬件会实现下列操作：</p> 
<ul><li>（1）把中断处的地址值（PC-4）拷贝到R14中，保留中断处地址；</li><li>（2）把CPSR拷贝到SWI模式的SPSR，保存状态寄存器的值；</li><li>（3）把状态寄存器的其他模式改变成管理模式；</li><li>（4）把中断向量0x00000008赋值给PC;</li><li>（5）禁止IRQ中断，使CPSR[7]=1。随后，程序执行0x00000008处的指令，通常是一个跳转指令或PC赋值指令。</li></ul> 
<blockquote> 
 <p>例如：</p> 
 <p>跳转指令</p> 
 <pre><code class="prism language-assembly">0x00000008    B INSTART         ;跳转
            …
INTSTART    ADD R4,R5,R0
            …
MOV PC,R14        				;返回
</code></pre> 
 <p>赋值指令</p> 
 <pre><code class="prism language-assembly">0x00000008   LDR PC, INSTART    ;跳转
            …
INTSTART     ADD R1,R2,R0
             … 
MOV PC,R14         				;返回
</code></pre> 
 <p>在上述例子中，跳转和赋值效果是一样的。执行完中断后使用一条语句返回。在一般情况下，程序会不止一处使用SWI中断指令，程序会从很多中断入口处进入同一个中断服务程序，例如上例中的INTSTART。假如同一个中断服务程序能满足所有中断的要求，那么，上例中的中断服务程序的机构就可以了。但是很多情况下，不同的中断入口会有不同的要求，同一个中断入口因每次进入的条件不同也会有不同的要求。因此，一段服务程序是不够的，往往要有很多不同功能的程序段。</p> 
 <p>假设把他们编为子功能1、子功能2、…、子功能n，那么软中断的入口INSTART处就应该设置一个向量表，如以下代码。</p> 
 <pre><code class="prism language-assembly">INTSTART  MOV R0,R0,LSL#2  ；把R0乘以4，R0＝功能号×4
ADD PC,PC,R0     ;PCPC+R0
NOP              ;空语句
B  SUBSEG0       ;跳转到功能段0，R0=0时
B  SUBSEG1       ;跳转到功能段1，R0=1时
B  SUBSEG2       ;跳转到功能段2，R0=2时
…
B  SUBSEGn       ;跳转到功能段n，R0=n时
</code></pre> 
 <p>在这个例子中，进入INTSTART后，首先要知道中断所需要的程序功能号，把程序功能号作为地址偏移量赋值给PC，程序就跳转到相应的程序段中去。在上例中，假设R0所存储的是程序功能号，先把这个功能号乘以4（即0号功能指向第0功能偏移为0，1号功能指向第1功能偏移为4，2号功能指向第2功能偏移为8,…），换算成地址偏移，然后加到PC中去。</p> 
 <p>在上例中，假设R0中是2，也就是说中断要调用2号功能段，在执行第1条语句时，用2乘以4后，R0＝8。此时，PC正指向空语句下 面的一条(B SUBSEG0)语句，给PC加8使程序跳转到SUBSEG2。在执行这条语句后，程序跳转到功能段2处。 因此，在这种情况下，程序在中断前，应该存储所需要的功能号；在中断服务程序开始后，再读出这个功能号。这样就实现了一个中断服务程序入口地址的传递。中断时一般有两种方法进行功能号传递（可能还有其他参数需要传递）。<br> （1）把准备传递的参数通过寄存器进行传递</p> 
 <pre><code class="prism language-assembly">MOV R0,#0x8   ;使用8号功能段
SWI 0         ;实现中断，不指明调用的功能号
</code></pre> 
 <p>​ （2）用SWI指令传递中断号</p> 
 <pre><code class="prism language-assembly"> SWI 8         ;实现中断，指明调用的功能号
</code></pre> 
</blockquote> 
<h3><a id="12__ARM_1907"></a>12. ARM伪指令</h3> 
<p>ARM伪指令不是ARM指令集中的指令，只是为了编程方便而定义的，伪指令可以象其它ARM指令一样使用，但在编译时这些指令将被等效的ARM指令代替。<br> <strong>ARM伪指令有4条：</strong></p> 
<ul><li>ADR 小范围的地址读取伪指令</li><li>ADRL 中等范围的地址读取伪指令</li><li>LDR 大范围的地址读取伪指令</li><li>NOP 空操作伪指令</li></ul> 
<h4><a id="1_ADR___1917"></a>1. ADR 小范围的地址读取伪指令</h4> 
<blockquote> 
 <p>格 式：ADR{cond} Rm,addr</p> 
</blockquote> 
<p><strong>功 能</strong>：ADR指令将基于PC相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中。在汇编编译源程序时，ADR伪指令被编译器替换成一条合适的指令。通常，编译器用一条ADD或SUB指令来实现该ADR伪指令的功能，若不能用一条指令实现，则产生错误，编译失败。</p> 
<ul><li>Rm：表示要加载的目标寄存器。</li><li>Addr：地址表达式。当地址值是非字对齐时，取值范围－255～255字节之间；当地址值是字对齐时，取值范围－1020～1020字节之间。对于基于PC相对偏移的地址值时，给定范围是相对当前指令地址后两（ARM7TDMI为三级流水线）。</li></ul> 
<blockquote> 
 <p>【例】 使用ADR伪指令加载地址，实现查表功能。</p> 
 <pre><code class="prism language-assembly">．．．
ADR R0,ADDR_TAB     ;加载转换表地址
LDRB R1,[R0,R2]     ;使用R2作为参数，进行查表
．．．
ADDR_TAB  DCB 0xA0,0xF8, 0x80,0x48, 0xE0,0x4F, 0xA3,0xD2
</code></pre> 
 <p>分析：通过ADR伪指令将转换表的首地址值（ADDR_TAB）加载到R0 中，每个表项的偏移地址值由R2传入，从而可以实现查表功能。</p> 
</blockquote> 
<h4><a id="2_ADRL__1938"></a>2. ADRL 中等范围的地址读取伪指令</h4> 
<blockquote> 
 <p>格 式：ADRL{cond} Rm,addr</p> 
</blockquote> 
<p><strong>功 能</strong>：ADRL指令将基于PC相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中。ADRL比ADR伪指令可以读取更大范围的地址。在汇编编译源程序时，ADRL伪指令被编译器替换成两条合适的指令。若不能用实现，则产生错误，编译失败。</p> 
<ul><li>Rm：表示要加载的目标寄存器。</li><li>Addr：地址表达式。当地址值是非字对齐时，取值范围－64K～64K字节之间；当地址值是字对齐时，取值范围－256K～256K字节之间。</li></ul> 
<blockquote> 
 <p>使用ADRL加载地址，可以实现程序跳转，例如：</p> 
 <pre><code class="prism language-assembly">．．．
ADR LR,RETURN1　　    　;设置返回地址
ADRL R1,Thumb_sub+1    ;取得Thumb子程序入口地址，且R1的0位置1
BX R1                  ;调用Thumb子程序，并切换处理器状态
RETURN1  
．．．

CODE16
Thumb_sub MOV R1,#10
．．．
</code></pre> 
</blockquote> 
<h4><a id="3_LDR__1962"></a>3. LDR 大范围的地址读取伪指令</h4> 
<blockquote> 
 <p>格 式：LDR{cond} Rm,=addr</p> 
</blockquote> 
<p><strong>功 能</strong>：LDR指令用于加载32位立即数或一个地址值到指定寄存器。在汇编编译源程序时，LDR伪指令被编译器替换成一条合适的指令。若加载的常数未超出MOV或MVN的范围，则使用MOV或MVN指令代替该LDR伪指令。否则，汇编器将常量放入文字池，并使用一条程序相对偏移的LDR指令从文字池读出常量。</p> 
<p>格式中：</p> 
<ul><li>Rm： 表示要加载的目标寄存器。</li><li>Addr：32位立即数或基于PC的地址表达式或外部表达式。</li></ul> 
<blockquote> 
 <p>【例】LDR伪指令举例如下：</p> 
 <pre><code class="prism language-assembly">LDR R0,=0x12345678     ;加载32位立即数0x12345678
LDR R0,=DATA_BUF+60    ;加载DATA_BUF地址＋60
．．．
LTORG　　　　　　　  　   ;声明文字池
．．．
</code></pre> 
</blockquote> 
<p>伪指令LDR常用于加载芯片外围功能部件的寄存器地址（32位立即数），以实现各种控制操作，如程序：</p> 
<pre><code class="prism language-assembly">．．．
LDR R0,=IOPIN   ;加载GPIO的寄存器IOPIN的地址
LDR R1,[R0]     ;读取IOPIN寄存器的值
．．．
LDR R0,=IOSET
LDR R1,=0x00500500
STR R1,[R0]          ；IOSET＝0x00500500
．．．
</code></pre> 
<p>注意：<br> (1)从PC到文字池的偏移量必须小于4KB。<br> (2)与ARM指令的LDR相比，伪指令的LDR的参数有“=”号。</p> 
<h4><a id="4___NOP__2000"></a>4. NOP 空操作伪指令</h4> 
<blockquote> 
 <p>格式：NOP</p> 
</blockquote> 
<p><strong>功能</strong>：NOP伪指令在汇编时将会被代替成ARM中的空操作，比如可能为“MOV R0,R0”指令等。NOP可用于延时操作，如：</p> 
<pre><code class="prism language-assembly">．．．
DELAY
NOP
NOP
NOP
SUBS R1,R1,#1
BNE DELAY1
．．．
</code></pre> 
<h3><a id="13__Thumb_2017"></a>13 . Thumb指令集</h3> 
<h5><a id="1__2019"></a>1. 概述</h5> 
<h5><a id="2_Thumb_2021"></a>2. Thumb指令寄存器的使用</h5> 
<h5><a id="3__ARMThumb_2023"></a>3. ARM-Thumb交互</h5> 
<h5><a id="4__2025"></a>4. 数据处理指令</h5> 
<h5><a id="5__2027"></a>5. 单寄存器加载和存储指令</h5> 
<h5><a id="6___2029"></a>6 . 多寄存器加载和存储指令</h5> 
<h5><a id="7__2031"></a>7. 堆栈指令</h5> 
<h5><a id="8__2033"></a>8. 软件中断指令</h5> 
<p><strong>参考</strong></p> 
<blockquote> 
 <p>《ARM体系结构与编程》<br> 《汇编语言程序设计——基于ARM体系结构 (第4版)》</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/78589586ca19030f0f7d135443bc9cb2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">snmp监控设备运行启动时间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/431481de05761223b7ab69255dd1b10f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">笔记：STM32——使用ADC通道采集端口电压数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>