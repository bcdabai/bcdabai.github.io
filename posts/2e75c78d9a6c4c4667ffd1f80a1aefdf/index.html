<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt编程-QTableView同时冻结行和列 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt编程-QTableView同时冻结行和列" />
<meta property="og:description" content="前言 Qt编程-QTableView同时冻结行和列。如题，先看效果是不是你需要的。网上找到的代码片段要么不全要么不是想要的。如果你只需要需要冻结行或冻结列，请看上篇博客 Qt编程-QTableView冻结行或冻结列或冻结局部单元格 ，代码更少一些。
同时冻结行列带表头：
同时冻结行列不带表头：
原理 冻结行或者冻结列原理: 使用3个tableview ，内容一样，最上层tableview显示交叉部分内容，中间层显示冻结的行tableview和冻结列tableview 把非冻结的内容隐藏掉，下层显示全部内容 下层tableview正常滑动就有冻结行或者列的效果了。
代码 代码改造来自 Qt自带例子 。可通过宏变量FREEZE_COL和FREEZE_ROW控制冻结行或冻结列，宏变量TABLE_HEAD控制表头显示。完整工程代码下载。
主要代码如下：
freezetablewidget.h
#ifndef FREEZETABLEWIDGET_H #define FREEZETABLEWIDGET_H #include &lt;QTableView&gt; //! [Widget definition] class FreezeTableWidget : public QTableView { Q_OBJECT public: FreezeTableWidget(QAbstractItemModel * model); ~FreezeTableWidget(); protected: void resizeEvent(QResizeEvent *event) override; QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers) override; void scrollTo (const QModelIndex &amp; index, ScrollHint hint = EnsureVisible) override; private: QTableView *frozenCroTableView; //冻结行冻结列交叉部分的TableView QTableView *frozenColTableView; //冻结列的TableView QTableView *frozenRowTableView; //冻结行的TableView void initCroTable(); void initColTable(); void initRowTable(); void updateFrozenCroTableGeometry(); void updateFrozenColTableGeometry(); void updateFrozenRowTableGeometry(); private slots: void updateSectionWidth(int logicalIndex, int oldSize, int newSize); void updateSectionHeight(int logicalIndex, int oldSize, int newSize); private: //冻结的行列数 int m_iFreezeCols = 3; int m_iFreezeRows = 3; }; //!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2e75c78d9a6c4c4667ffd1f80a1aefdf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-10T13:57:12+08:00" />
<meta property="article:modified_time" content="2023-10-10T13:57:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt编程-QTableView同时冻结行和列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<p>Qt编程-QTableView同时冻结行和列。如题，先看效果是不是你需要的。网上找到的代码片段要么不全要么不是想要的。如果你只需要需要冻结行或冻结列，请看上篇博客 <a href="https://lcxing.blog.csdn.net/article/details/133745084" rel="nofollow">Qt编程-QTableView冻结行或冻结列或冻结局部单元格</a> ，代码更少一些。</p> 
<p>同时冻结行列带表头：<br> <img src="https://images2.imgbox.com/bf/44/ILsG3sak_o.gif" alt="在这里插入图片描述"></p> 
<p>同时冻结行列不带表头：<br> <img src="https://images2.imgbox.com/f0/8a/FX6FvDCr_o.gif" alt="在这里插入图片描述"></p> 
<h2><a id="_12"></a>原理</h2> 
<p>冻结行或者冻结列原理: 使用3个tableview ，内容一样，最上层tableview显示交叉部分内容，中间层显示冻结的行tableview和冻结列tableview 把非冻结的内容隐藏掉，下层显示全部内容 下层tableview正常滑动就有冻结行或者列的效果了。</p> 
<h2><a id="_16"></a>代码</h2> 
<p>代码改造来自 <a href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/itemviews/frozencolumn?h=5.14" rel="nofollow">Qt自带例子</a> 。可通过宏变量FREEZE_COL和FREEZE_ROW控制冻结行或冻结列，宏变量TABLE_HEAD控制表头显示。<a href="https://download.csdn.net/download/qq_29542611/88411733?spm=1001.2101.3001.9500">完整工程代码下载</a>。</p> 
<p>主要代码如下：</p> 
<p>freezetablewidget.h</p> 
<pre><code class="prism language-c++">#ifndef FREEZETABLEWIDGET_H
#define FREEZETABLEWIDGET_H

#include &lt;QTableView&gt;

//! [Widget definition]
class FreezeTableWidget : public QTableView {
    Q_OBJECT

public:
    FreezeTableWidget(QAbstractItemModel * model);
    ~FreezeTableWidget();


protected:
    void resizeEvent(QResizeEvent *event) override;
    QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers) override;
    void scrollTo (const QModelIndex &amp; index, ScrollHint hint = EnsureVisible) override;

private:
    QTableView *frozenCroTableView; //冻结行冻结列交叉部分的TableView
    QTableView *frozenColTableView; //冻结列的TableView
    QTableView *frozenRowTableView; //冻结行的TableView
    void initCroTable();
    void initColTable();
    void initRowTable();
    void updateFrozenCroTableGeometry();
    void updateFrozenColTableGeometry();
    void updateFrozenRowTableGeometry();


private slots:
    void updateSectionWidth(int logicalIndex, int oldSize, int newSize);
    void updateSectionHeight(int logicalIndex, int oldSize, int newSize);
private:
    //冻结的行列数
    int m_iFreezeCols = 3;
    int m_iFreezeRows = 3;
};
//! [Widget definition]
#endif // FREEZETABLEWIDGET_H

</code></pre> 
<p>freezetablewidget.cpp</p> 
<pre><code class="prism language-c++">#include "freezetablewidget.h"

#include &lt;QScrollBar&gt;
#include &lt;QHeaderView&gt;
#include &lt;QDebug&gt;

#define FREEZE_COL 1 //冻结列开关
#define FREEZE_ROW 1 //冻结行开关
#define TABLE_HEAD 0 //表头是否显示

//! [constructor]
FreezeTableWidget::FreezeTableWidget(QAbstractItemModel * model)
{
    /*
      冻结行或者冻结列 原理:实质上有2个tableview
            FreezeTableWidget 这个正常显示所有的表格数据
            frozenColTableView 这个表格放在FreezeTableWidget的上面 只显示 冻结的列，这样下面的 FreezeTableWidget 正常滑动就有冻结列的效果了。
      同时冻结行列 原理类似，不过是3个tableview，冻结行和冻结列的tableview交叉部分单独作为一个tableview要放在最顶层，下面是冻结行和冻结列的tableview 最下面是 FreezeTableWidget的tableview。
     */
    verticalHeader()-&gt;setVisible(TABLE_HEAD);
    horizontalHeader()-&gt;setVisible(TABLE_HEAD);

    setModel(model);

#if (FREEZE_COL &amp;&amp; FREEZE_ROW)
    frozenCroTableView = new QTableView(this);
    initCroTable();
#endif

#if FREEZE_COL
    frozenColTableView = new QTableView(this);
    initColTable();
#endif

#if FREEZE_ROW
    frozenRowTableView = new QTableView(this);
    initRowTable();
#endif


    //connect the headers and scrollbars of both tableviews together
#if FREEZE_COL
    connect(horizontalHeader(),&amp;QHeaderView::sectionResized, this,
            &amp;FreezeTableWidget::updateSectionWidth);
#endif
#if FREEZE_ROW
    connect(verticalHeader(),&amp;QHeaderView::sectionResized, this,
            &amp;FreezeTableWidget::updateSectionHeight);
#endif

    //LUpdate
    //冻结列，纵向滚动条可正常滑动
#if FREEZE_COL
    connect(frozenColTableView-&gt;verticalScrollBar(), &amp;QAbstractSlider::valueChanged,
            verticalScrollBar(), &amp;QAbstractSlider::setValue);
    connect(verticalScrollBar(), &amp;QAbstractSlider::valueChanged,
            frozenColTableView-&gt;verticalScrollBar(), &amp;QAbstractSlider::setValue);
#endif
    //冻结行，横向向滚动条可正常滑动
#if FREEZE_ROW
    connect(frozenRowTableView-&gt;horizontalScrollBar(), &amp;QAbstractSlider::valueChanged,
            horizontalScrollBar(), &amp;QAbstractSlider::setValue);
    connect(horizontalScrollBar(), &amp;QAbstractSlider::valueChanged,
            frozenRowTableView-&gt;horizontalScrollBar(), &amp;QAbstractSlider::setValue);
#endif

}
//! [constructor]

FreezeTableWidget::~FreezeTableWidget()
{
#if FREEZE_COL
    delete frozenColTableView;
#endif
#if FREEZE_ROW
    delete frozenRowTableView;
#endif
#if FREEZE_COL &amp;&amp; FREEZE_ROW
    delete frozenCroTableView;
#endif
}

//! [init part1]
void FreezeTableWidget::initCroTable()
{
    frozenCroTableView-&gt;setModel(model());
    frozenCroTableView-&gt;setObjectName("frozenCroTableView");
    frozenCroTableView-&gt;setFocusPolicy(Qt::NoFocus);
    frozenCroTableView-&gt;verticalHeader()-&gt;setFixedWidth(verticalHeader()-&gt;width());
    frozenCroTableView-&gt;verticalHeader()-&gt;setSectionResizeMode(QHeaderView::Fixed);
    frozenCroTableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::Fixed);
#if !TABLE_HEAD
    frozenCroTableView-&gt;horizontalHeader()-&gt;hide();
    frozenCroTableView-&gt;verticalHeader()-&gt;hide();
#endif

    viewport()-&gt;stackUnder(frozenCroTableView);
    //! [init part1]

    //! [init part2]
    frozenCroTableView-&gt;setStyleSheet("#frozenCroTableView{ border: none;"
                                      "background-color: #AEC8FF;"
                                      "selection-background-color: #999}"); //for demo purposes
    frozenCroTableView-&gt;setSelectionModel(selectionModel());

    //LUpdate
    //隐藏冻结列以外的数据
    for (int col = m_iFreezeCols; col &lt; model()-&gt;columnCount(); ++col)
        frozenCroTableView-&gt;setColumnHidden(col, true);

    for(int i = 0; i &lt; m_iFreezeCols; i++)
    {
        frozenCroTableView-&gt;setColumnWidth(i, columnWidth(0));
    }
    //隐藏冻结行以外的行的数据
    for (int row = m_iFreezeRows; row &lt; model()-&gt;rowCount(); ++row)
        frozenCroTableView-&gt;setRowHidden(row, true);
    for(int i = 0; i &lt; m_iFreezeRows; i++)
    {
        frozenCroTableView-&gt;setRowHeight(i, rowHeight(0));
    }

    frozenCroTableView-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    frozenCroTableView-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    frozenCroTableView-&gt;show();

    updateFrozenCroTableGeometry();

    setHorizontalScrollMode(ScrollPerPixel);
    setVerticalScrollMode(ScrollPerPixel);
    frozenCroTableView-&gt;setVerticalScrollMode(ScrollPerPixel);
    frozenCroTableView-&gt;setHorizontalScrollMode(ScrollPerPixel);
}

//! [init part1]
void FreezeTableWidget::initColTable()
{
    frozenColTableView-&gt;setModel(model());
    frozenColTableView-&gt;setObjectName("frozenColTableView");
    frozenColTableView-&gt;setFocusPolicy(Qt::NoFocus);
    frozenColTableView-&gt;verticalHeader()-&gt;setFixedWidth(verticalHeader()-&gt;width());
    frozenColTableView-&gt;verticalHeader()-&gt;setSectionResizeMode(QHeaderView::Fixed);
    frozenColTableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::Fixed);
#if !TABLE_HEAD
    frozenColTableView-&gt;horizontalHeader()-&gt;hide();
    frozenColTableView-&gt;verticalHeader()-&gt;hide();
#endif

#if FREEZE_COL &amp;&amp; FREEZE_ROW
    frozenColTableView-&gt;stackUnder(frozenCroTableView);
#else
    viewport()-&gt;stackUnder(frozenColTableView);
#endif

    //! [init part1]

    //! [init part2]
    frozenColTableView-&gt;setStyleSheet("#frozenColTableView{ border: none;"
                                      "background-color: #8EDE21;"
                                      "selection-background-color: #999}"); //for demo purposes
    frozenColTableView-&gt;setSelectionModel(selectionModel());

    //LUpdate
    //隐藏冻结列以外的数据
    for (int col = m_iFreezeCols; col &lt; model()-&gt;columnCount(); ++col)
        frozenColTableView-&gt;setColumnHidden(col, true);

    for(int i = 0; i &lt; m_iFreezeCols; i++)
    {
        frozenColTableView-&gt;setColumnWidth(i, columnWidth(0));
    }

    frozenColTableView-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    frozenColTableView-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    frozenColTableView-&gt;show();

    updateFrozenColTableGeometry();

    setHorizontalScrollMode(ScrollPerPixel);
    setVerticalScrollMode(ScrollPerPixel);
    frozenColTableView-&gt;setVerticalScrollMode(ScrollPerPixel);
    frozenColTableView-&gt;setHorizontalScrollMode(ScrollPerPixel);
}

void FreezeTableWidget::initRowTable()
{
    frozenRowTableView-&gt;setModel(model());
    frozenRowTableView-&gt;setObjectName("frozenRowTableView");
    frozenRowTableView-&gt;setFocusPolicy(Qt::NoFocus);
    frozenRowTableView-&gt;verticalHeader()-&gt;setFixedWidth(verticalHeader()-&gt;width());
    frozenRowTableView-&gt;verticalHeader()-&gt;setSectionResizeMode(QHeaderView::Fixed);
    frozenRowTableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::Fixed);
#if !TABLE_HEAD
    frozenRowTableView-&gt;horizontalHeader()-&gt;hide();
    frozenRowTableView-&gt;verticalHeader()-&gt;hide();
#endif

#if FREEZE_COL
    frozenRowTableView-&gt;stackUnder(frozenColTableView);
#else
    viewport()-&gt;stackUnder(frozenRowTableView);
#endif

    //! [init part1]

    //! [init part2]
    frozenRowTableView-&gt;setStyleSheet("#frozenRowTableView{ border: none;"
                                      "background-color: #f44c46;"
                                      "selection-background-color: #999}"); //for demo purposes
    frozenRowTableView-&gt;setSelectionModel(selectionModel());

    //LUpdate
    //隐藏冻结行以外的行的数据
    for (int row = m_iFreezeRows; row &lt; model()-&gt;rowCount(); ++row)
        frozenRowTableView-&gt;setRowHidden(row, true);
    for(int i = 0; i &lt; m_iFreezeRows; i++)
    {
        frozenRowTableView-&gt;setRowHeight(i, rowHeight(0));
    }

    frozenRowTableView-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    frozenRowTableView-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    frozenRowTableView-&gt;show();

    updateFrozenRowTableGeometry();

    setHorizontalScrollMode(ScrollPerPixel);
    setVerticalScrollMode(ScrollPerPixel);
    frozenRowTableView-&gt;setVerticalScrollMode(ScrollPerPixel);
    frozenRowTableView-&gt;setHorizontalScrollMode(ScrollPerPixel);
}
//! [init part2]


//! [sections]
void FreezeTableWidget::updateSectionWidth(int logicalIndex, int /* oldSize */, int newSize)
{
    qDebug() &lt;&lt; "updateSectionWidth" &lt;&lt; logicalIndex &lt;&lt; newSize;
    //LUpdate
#if FREEZE_COL
    if (logicalIndex == m_iFreezeCols-1){

        int width = 0;
        for(int i = 0; i&lt; m_iFreezeCols-1; i++)
        {
            width += columnWidth(i);
        }

        for(int i = 0; i&lt; m_iFreezeCols; i++)
        {
            frozenColTableView-&gt;setColumnWidth(i, (newSize+width)/m_iFreezeCols);
        }
        updateFrozenColTableGeometry();
    }
#else
    frozenColTableView-&gt;setColumnWidth(logicalIndex, newSize);
#endif
}

void FreezeTableWidget::updateSectionHeight(int logicalIndex, int /* oldSize */, int newSize)
{
    qDebug() &lt;&lt; "updateSectionHeight" &lt;&lt; logicalIndex &lt;&lt; newSize;
    //LUpdate
#if FREEZE_ROW
    if (logicalIndex == m_iFreezeRows-1){

        int height = 0;
        for(int i = 0; i&lt; m_iFreezeRows-1; i++)
        {
            height += rowHeight(i);
        }

        for(int i = 0; i&lt; m_iFreezeRows; i++)
        {
            frozenRowTableView-&gt;setRowHeight(i, (newSize+height)/m_iFreezeRows);
        }
        updateFrozenRowTableGeometry();
    }
#else
    frozenRowTableView-&gt;setRowHeight(logicalIndex, newSize);
#endif
}
//! [sections]


//! [resize]
void FreezeTableWidget::resizeEvent(QResizeEvent * event)
{
    QTableView::resizeEvent(event);
#if FREEZE_COL
    updateFrozenColTableGeometry();
#endif

#if FREEZE_ROW
    updateFrozenRowTableGeometry();
#endif

#if FREEZE_ROW &amp;&amp; FREEZE_COL
    updateFrozenCroTableGeometry();
#endif

}
//! [resize]


//! [navigate]
QModelIndex FreezeTableWidget::moveCursor(CursorAction cursorAction,
                                          Qt::KeyboardModifiers modifiers)
{
    QModelIndex current = QTableView::moveCursor(cursorAction, modifiers);

#if FREEZE_COL
    if (cursorAction == MoveLeft &amp;&amp; current.column() &gt; 0
            &amp;&amp; visualRect(current).topLeft().x() &lt; frozenColTableView-&gt;columnWidth(0) ){
        const int newValue = horizontalScrollBar()-&gt;value() + visualRect(current).topLeft().x()
                - frozenColTableView-&gt;columnWidth(0);
        horizontalScrollBar()-&gt;setValue(newValue);
    }
#endif
#if FREEZE_ROW
    if(cursorAction == MoveDown &amp;&amp; current.row() &gt; 0
            &amp;&amp; visualRect(current).topLeft().y() &lt; frozenRowTableView-&gt;rowHeight(0))
    {
        const int newValue = verticalScrollBar()-&gt;value() + visualRect(current).topLeft().y()
                - frozenRowTableView-&gt;rowHeight(0);
        verticalScrollBar()-&gt;setValue(newValue);
    }
#endif
    return current;
}
//! [navigate]

void FreezeTableWidget::scrollTo (const QModelIndex &amp; index, ScrollHint hint){
    if (index.column() &gt; 0)
        QTableView::scrollTo(index, hint);
}

//! [geometry]
void FreezeTableWidget::updateFrozenCroTableGeometry()
{
    qDebug() &lt;&lt; "updateFrozenCroTableGeometry ==";
    //LUpdate
    int width = 0, height = 0, x = 0, y = 0;
    qDebug() &lt;&lt; "ver:" &lt;&lt; verticalHeader()-&gt;width() &lt;&lt; verticalHeader()-&gt;height();
    qDebug() &lt;&lt; "hor:" &lt;&lt; horizontalHeader()-&gt;width() &lt;&lt; horizontalHeader()-&gt;height();
    qDebug() &lt;&lt; "frame:" &lt;&lt; frameWidth() &lt;&lt; frameRect().width()&lt;&lt; frameRect().height() &lt;&lt; frameRect().x() &lt;&lt; frameRect().y();
    x = frameWidth();
    y = frameWidth();

#if FREEZE_COL &amp;&amp; FREEZE_ROW
    width = verticalHeader()-&gt;width();
    for(int i = 0; i&lt; m_iFreezeCols; i++)
    {
        width += columnWidth(i);
    }
    height = horizontalHeader()-&gt;height();
    for(int i = 0; i&lt; m_iFreezeRows; i++)
    {
        height += rowHeight(i);
    }
#else
    width = viewport()-&gt;width()+verticalHeader()-&gt;width();
    height = viewport()-&gt;height()+horizontalHeader()-&gt;height();
#endif

    qDebug() &lt;&lt; "x, y, width, height" &lt;&lt; x &lt;&lt; y &lt;&lt; width &lt;&lt; height;
    frozenCroTableView-&gt;setGeometry(x, y, width, height);
}
//! [geometry]

//! [geometry]
void FreezeTableWidget::updateFrozenColTableGeometry()
{
    qDebug() &lt;&lt; "updateFrozenColTableGeometry ==";
    //LUpdate
    int width = 0, height = 0, x = 0, y = 0;
    qDebug() &lt;&lt; "ver:" &lt;&lt; verticalHeader()-&gt;width() &lt;&lt; verticalHeader()-&gt;height();
    qDebug() &lt;&lt; "hor:" &lt;&lt; horizontalHeader()-&gt;width() &lt;&lt; horizontalHeader()-&gt;height();
    qDebug() &lt;&lt; "frame:" &lt;&lt; frameWidth() &lt;&lt; frameRect().width()&lt;&lt; frameRect().height() &lt;&lt; frameRect().x() &lt;&lt; frameRect().y();
    x = frameWidth();
    y = frameWidth();

#if FREEZE_COL
    width = verticalHeader()-&gt;width();
    for(int i = 0; i&lt; m_iFreezeCols; i++)
    {
        width += columnWidth(i);
    }
#else
    width = viewport()-&gt;width()+verticalHeader()-&gt;width();
#endif

    height = viewport()-&gt;height()+horizontalHeader()-&gt;height();

    qDebug() &lt;&lt; "x, y, width, height" &lt;&lt; x &lt;&lt; y &lt;&lt; width &lt;&lt; height;
    frozenColTableView-&gt;setGeometry(x, y, width, height);
}
//! [geometry]

//! [geometry]
void FreezeTableWidget::updateFrozenRowTableGeometry()
{
    qDebug() &lt;&lt; "updateFrozenRowTableGeometry ==";
    //LUpdate
    int width = 0, height = 0, x = 0, y = 0;
    qDebug() &lt;&lt; "ver:" &lt;&lt; verticalHeader()-&gt;width() &lt;&lt; verticalHeader()-&gt;height();
    qDebug() &lt;&lt; "hor:" &lt;&lt; horizontalHeader()-&gt;width() &lt;&lt; horizontalHeader()-&gt;height();
    qDebug() &lt;&lt; "frame:" &lt;&lt; frameWidth() &lt;&lt; frameRect().width()&lt;&lt; frameRect().height() &lt;&lt; frameRect().x() &lt;&lt; frameRect().y();
    x = frameWidth();
    y = frameWidth();
    width = viewport()-&gt;width()+verticalHeader()-&gt;width();
#if FREEZE_ROW
    height = horizontalHeader()-&gt;height();
    for(int i = 0; i&lt; m_iFreezeRows; i++)
    {
        height += rowHeight(i);
    }
#else
    height = viewport()-&gt;height()+horizontalHeader()-&gt;height();
#endif

    qDebug() &lt;&lt; "x, y, width, height" &lt;&lt; x &lt;&lt; y &lt;&lt; width &lt;&lt; height;
    frozenRowTableView-&gt;setGeometry(x, y, width, height);
}
//! [geometry]



</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7879eab326dbbd65fb5ee07f91e5254/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">服务器与网站部署知识体系目录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/491e2988c202f2a328c8320ac0ab841d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">K8S：配置资源管理 Secret和configMap</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>