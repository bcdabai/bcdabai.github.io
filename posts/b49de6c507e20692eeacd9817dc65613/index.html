<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>promise generator aysnc/await三者区别 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="promise generator aysnc/await三者区别" />
<meta property="og:description" content="三者都是异步编程的解决方案,不同的是,promise为较早出来的,其次generator,最后为async/await,三者象征了前端进行解决异步编程的进化路程。
promise promise比较简单，也是最常用的，主要就是将原来用 回调函数异步编程的方法 转成 relsove和reject触发事件； 对象内含有四个方法，then()异步请求成功后 catch()异步请求错误的回调方法 finally()请求之后无论是什么状态都会执行 resolve()将现有对象转换为Promise对象 all()此方法用于将多个Promise实例包装成一个新的promise实例。 race()也是将多个Promise实例包装成一个新的promise实例 reject()返回一个状态为Rejected的新Promise实例。 有点：让回调函数变成了规范的链式写法，程序流程可以看的很清楚 缺点:编写的难度比传统写法高，阅读代码也不是一眼可以看懂 Generator generator是一个迭代生成器,其返回值为迭代器(lterator),是ES6标准引入的新的数据类型，主要用于异步编程,它借鉴于Python中的generator概念和语法； generator函数内有两个重要方法，1 yield表达式 2.next() Generator 函数是分段执行的，yield表达式是暂停执行的标记，而 next方法可以恢复执行 优点：1.利用循环，每调用一次，就使用一次，不占内存空间 2.打破了普通函数执行的完整性 缺点: 需要用next()方法手动调用,直接调用返回无效iterator 2. async/await async：异步函数 await：同步操作 es7中提出来的异步解决方法,是目前解决异步编程终它基极解决方案,于promise为基础,其实也就是generator的高级语法糖,本身自己就相当于一个迭代生成器(状态机),它并不需要手动通过next()来调用自己,与普通函数一样 async就相当于generator函数中的*,await相当于yield, async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 function getSomething() { return &#34;something&#34;; } async function testAsync() { return Promise.resolve(&#34;hello async&#34;); } async function test() { //await是在等待一个async函数完成 const v1 = await getSomething(); //await后面不仅可以接Promise，还可以接普通函数或者直接量 const v2 = await testAsync(); console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b49de6c507e20692eeacd9817dc65613/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-10T15:20:34+08:00" />
<meta property="article:modified_time" content="2023-04-10T15:20:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">promise generator aysnc/await三者区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>三者都是异步编程的解决方案,不同的是,promise为较早出来的,其次generator,最后为async/await,三者象征了前端进行解决异步编程的进化路程。</strong></p> 
<h2><a id="promise_1"></a>promise</h2> 
<pre><code class="prism language-javascript"> promise比较简单，也是最常用的，主要就是将原来用  回调函数异步编程的方法  转成  relsove和reject触发事件；


    <span class="token function">对象内含有四个方法，then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>异步请求成功后
                      <span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>异步请求错误的回调方法
                      <span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">)</span>请求之后无论是什么状态都会执行
                      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>将现有对象转换为Promise对象
                      <span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>此方法用于将多个Promise实例包装成一个新的promise实例。
                      <span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">)</span>也是将多个Promise实例包装成一个新的promise实例
                      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回一个状态为Rejected的新Promise实例。
                      
    有点：让回调函数变成了规范的链式写法，程序流程可以看的很清楚
    <span class="token literal-property property">缺点</span><span class="token operator">:</span>编写的难度比传统写法高，阅读代码也不是一眼可以看懂


</code></pre> 
<h2><a id="Generator_21"></a>Generator</h2> 
<pre><code class="prism language-javascript">generator是一个迭代生成器<span class="token punctuation">,</span><span class="token function">其返回值为迭代器</span><span class="token punctuation">(</span>lterator<span class="token punctuation">)</span><span class="token punctuation">,</span>是<span class="token constant">ES6</span>标准引入的新的数据类型，主要用于异步编程<span class="token punctuation">,</span>它借鉴于Python中的generator概念和语法；

generator函数内有两个重要方法，<span class="token number">1</span> <span class="token keyword">yield</span>表达式 <span class="token number">2.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

Generator 函数是分段执行的，<span class="token keyword">yield</span>表达式是暂停执行的标记，而 next方法可以恢复执行

优点：<span class="token number">1.</span>利用循环，每调用一次，就使用一次，不占内存空间 <span class="token number">2.</span>打破了普通函数执行的完整性
<span class="token literal-property property">缺点</span><span class="token operator">:</span> <span class="token function">需要用next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法手动调用<span class="token punctuation">,</span>直接调用返回无效iterator <span class="token number">2.</span>

</code></pre> 
<h2><a id="asyncawait_35"></a>async/await</h2> 
<pre><code class="prism language-javascript">    <span class="token keyword">async</span>：异步函数
    <span class="token keyword">await</span>：同步操作

     es7中提出来的异步解决方法<span class="token punctuation">,</span>是目前解决异步编程终它基极解决方案<span class="token punctuation">,</span>于promise为基础<span class="token punctuation">,</span>其实也就是generator的高级语法糖<span class="token punctuation">,</span><span class="token function">本身自己就相当于一个迭代生成器</span><span class="token punctuation">(</span>状态机<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">它并不需要手动通过next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>来调用自己<span class="token punctuation">,</span>与普通函数一样
     
    <span class="token keyword">async</span>就相当于generator函数中的<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">await</span>相当于<span class="token keyword">yield</span><span class="token punctuation">,</span>

    <span class="token keyword">async</span> 用于申明一个 <span class="token keyword">function</span> 是异步的，而 <span class="token keyword">await</span> 用于等待一个异步方法执行完成。
     <span class="token keyword">function</span> <span class="token function">getSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">return</span> <span class="token string">"something"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"hello async"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//await是在等待一个async函数完成</span>
        <span class="token keyword">const</span> v1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//await后面不仅可以接Promise，还可以接普通函数或者直接量</span>
        <span class="token keyword">const</span> v2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">testAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre> 
<h2><a id="_64"></a>多步操作</h2> 
<pre><code class="prism language-javascript"><span class="token function">step1</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">step2</span><span class="token punctuation">(</span>value1<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">step3</span><span class="token punctuation">(</span>value2<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value3</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">step4</span><span class="token punctuation">(</span>value3<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value4</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// Do something with value4</span>
			<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//采用promise改写：</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>step1<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>step2<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>step3<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>step4<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value4</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// Do something with value4</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// Handle any error from step1 through step4</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//使用generator函数</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">longRunningTask</span><span class="token punctuation">(</span><span class="token parameter">value1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">var</span> value2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">step1</span><span class="token punctuation">(</span>value1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">var</span> value3 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">step2</span><span class="token punctuation">(</span>value2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">var</span> value4 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">step3</span><span class="token punctuation">(</span>value3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">var</span> value5 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">step4</span><span class="token punctuation">(</span>value4<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// Do something with value4</span>
	<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Handle any error from step1 through step4</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>从回调函数，到promise,再到generator,再到Async/await,这四种分别代表了JavaScript异步编程解决方案的进化路程。async和generator函数主要就是为了解决异步的并发调用使用的 ，直接将参数从then里取出来，相比promise的链式调用，传参更加方便，异步顺序更加清晰</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74069f7de7f2580e4f7c7b32ea726e58/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">S32DS编译ld文件报错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/588eb38d8af6110c1b65feb4882da065/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GreenDao进阶篇 GreenDao分页查询</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>