<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89710dd29fe8479777df23fc6dd6b91a/" rel="bookmark">
			C&#43;&#43;构造函数和析构函数中调用虚拟函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）C++构造器可以为虚拟函数吗？
不行。因为构造器调用的时候会设置当前类的虚表地址，然后如果构造函数本身为虚拟函数，那么调用构造函数就需要提前访问虚表，此时虚表指针还没有指向虚表，就没法访问虚表。
（2）构造函数中可以调用虚拟函数吗？
可以，但是调用虚拟函数就是调用跟调用普通函数效果一样。
因为子类在创建的时候是先调用父类的构造器，父类的构造器先设置好父类的虚表地址，然后再执行构造器中的代码，然后在回到子类构造器，先将虚表地址替换为子类的虚表地址，然后执行子类构造器的代码。
因此如果在父类构造器中调用虚函数，那么此时是从父类的虚表中查找函数地址，查找到的还是父类的虚函数地址。因此会调用父类的虚函数，而不会调用子类的虚函数。
（3）析构函数中可以调用虚拟函数吗？
可以。但是调用虚拟函数跟调用普通函数没啥区别。
因为析构的时候先执行子类的析构函数，再执行父类的析构函数，在执行当前类的析构函数的时候会先将虚表地址设置为当前类的虚表地址，然后再从虚表里查找函数地址，因此找到的只能是当前的虚函数的地址。
（4）父类的析构函数为什么要为虚函数？
因为如果父类析构函数不为虚函数，那么当对象析构的时候只会调用指针当前类型的析构函数，不会调用父类或者子类的析构函数，会导致资源泄漏。
如果父类的析构函数为虚函数，那么子类的析构函数在析构的时候会先调用子类的析构函数，再调用父类的析构函数。这样子就不会存在资源泄漏。
注：
（1）将子类和父类构造器和析构器调用串起来是编译器实现的
（2）子类和父类都有自己的虚表。子类或者父类的构造器和析构器在最开始都是将虚表设置为当前类的虚表。然后才真正调用构造函数和析构函数里的代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/344e1c039d00266c1983e28310e2f6ac/" rel="bookmark">
			MAC 搭建vue开发环境，配置环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.官网下载nodejs安装包 http://nodejs.p2hp.com/
下载完成后安装，一直点击下一步即可
2.自定以配置全局模块路径和缓存路径 先自己找一个路径创建两个文件夹，node_cache 和 node_global
打开终端，执行一下俩条命令,注意引号中的路径要换成你创建的文件夹所在的路径
npm config set prefix “/Users/yangjunbo/kaifa/nodejs/node_global”
npm config set cache “/Users/yangjunbo/kaifa/nodejs/node_cache”
3.配置环境变量 因为改变了全局安装路径，所以需要配置环境变量，不然出现新安装的工具命令找不到的问题。
在终端输入：vi ~/.bash_profile，按i进入编辑模式，加入箭头所指两行配置。
按esc，输入:wq保存退出。
输入source ～/.bash_profile使配置生效。
4.更改镜像源 npm config set registry https://registry.npm.taobao.org
5.安装vue脚手架 npm install -g @vue/cli
6.创建vue项目 创建一个存放vue项目的目录
在终端中进入这个目录，输入vue create 项目名，创建一个vue项目，项目名不能包括大写字母和中文等
创建好后，根据提示的命令，启动项目。
启动项目后，根据提示的地址，访问，可以看到下图界面，表示启动成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2315f2552e46eea9a10fc72e3d3be6fc/" rel="bookmark">
			pygame库基础模块汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.安装
2.使用
3.display显示模块
4.draw模块
5.event模块
① event可以判断的事件
②键盘事件key
6.font模块 7.time模块
8.基本框架
Pygame 是一个专门用来开发游戏的 Python 模块，主要为开发、设计 2D 电子游戏而生，它是一个免费、开源的第三方软件包，支持多种操作系统，具有良好的跨平台性（比如 Windows、Linux、Mac 等）
1.安装 (使用win+r打开运行，输入cmd)，接着输入以下代码
pip3 install pygame 2.使用 在使用时，先引入pygame库，然后对其进行初始化
import pygame #导入pygame库 pygame.init() #pygame库初始化 pygame.quit() #取消初始化
3.display显示模块 pygame.display.set_mode((width,height)) #创建一个窗口对象（宽高） pygame.display.set_caption("游戏") #更改窗口的标题为游戏 pygame.display.get_surface()	#获取当前显示的 Surface 对象。 pygame.display.flip()	#更新整个待显示的 Surface 对象到屏幕上。(一般来说第一次更新用flip，后续更新使用update) pygame.display.update()	#更新部分软件界面显示。 pygame.display.Info()	#产生一个 VideoInfo 对象，包含了显示界面的相关信息。 pygame.display.set_icon()	#设置左上角的游戏图标，图标尺寸大小为 32*32。 pygame.display.iconify()	#将显示的主窗口即 Surface 对象最小化，或者隐藏。 pygame.display.get_active()	#当前显示界面显示在屏幕上时返回 True，如果窗口被隐藏和最小化则返回 False。 pygame.display.get_driver() #获取pygame显示后端的名称 pygame.display.toggle_fullscreen() #切换全屏显示和窗口显示 pygame.display。set_palette() #为索引显示设置显示调色板 填充颜色：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2315f2552e46eea9a10fc72e3d3be6fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c026823923de78a33a3777e2e732e255/" rel="bookmark">
			【毕业设计】大数据心血管疾病数据分析（医学大数据分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 课题背景2 数据处理3 数据可视化4 最后 0 前言 🔥 Hi，大家好，这里是丹成学长的毕设系列文章！
🔥 对毕设有任何疑问都可以问学长哦!
这两年开始，各个学校对毕设的要求越来越高，难度也越来越大… 毕业设计耗费时间，耗费精力，甚至有些题目即使是专业的老师或者硕士生也需要很长时间，所以一旦发现问题，一定要提前准备，避免到后面措手不及，草草了事。
为了大家能够顺利以及最少的精力通过毕设，学长分享优质毕业设计项目，今天要分享的新项目是
🚩 基于大数据的心血管疾病分析
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：4分工作量：4分创新点：3分 🧿 选题指导, 项目分享：
https://gitee.com/yaa-dc/BJH/blob/master/gg/cc/README.md
1 课题背景 本项目的任务是利用患者的检查结果预测心血管疾病(CVD)的存在与否。
2 数据处理 数据集包括年龄、性别、收缩压、舒张压等12个特征的患者数据记录7万份。
当患者有心血管疾病时，目标类“cardio”等于1，如果患者健康，则为0。
数据描述
有三种类型的输入特征:
Objective: 客观事实;Examination: 体检检查结果;Subjective: 病人提供的信息 数据信息概览
import numpy as np import pandas as pd import seaborn as sns from matplotlib import pyplot as plt import os df.head() 变量分析
df.info() 所有特征都是数字，12个整数和1个小数(权值)。第二列告诉我们数据集有多大，每个字段有多少非空值。
我们可以使用’ describe() ‘来显示每个属性的样本统计信息，比如’ min ‘、’ max ‘、’ mean ‘、’ std ':
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c026823923de78a33a3777e2e732e255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/466192dcf2e8959fd883f96810da227e/" rel="bookmark">
			空域图像增强-图像灰度变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.图像灰度变换。自选一张图片，完成以下图像处理：①显示图像的灰度直方图；②直方图均衡化，对比变化前后的图像和灰度直方图；③对图像进行线性灰度变换，对某部分灰度值进行扩展，压缩其它灰度值区域，对比变化前后的图像和灰度直方图。
图像增强:
·图像不清晰、不突出是由多种因素造成的, 如采集中未突出所需部分, 有干扰(噪声、散斑、运动模糊等等).
·目标是比原图像更适合于特定的应用, 便于识别和后继处理.
·不同的问题采用不同的方法, 评价结果好坏没有统一的标准.
改善降质图像的方法:
·图像增强: 不考虑降质原因, 关心有用信息, 抑制次要部分, 去干扰, 增强对比度, 不一定要逼近原图像.
·复原技术: 针对降质原因, 设法补偿降质因素, 尽可能逼近原始图像, 恢复原图.
图像增强和复原技术有重叠部分. 增强带有恢复性质, 突出有用信息, 且是局部性恢复.
图像灰度变换:
·按一定变换关系, 逐点改变原图像中每一个像素灰度值的方法.
·是图像增强处理技术中一种非常基础、直接的空间域图像处理方法.
·目的是为了改善画质, 使图像的显示效果更加清晰.
点运算:
·输入图像为f(x, y), 输出图像为g(x, y).
·点运算为g(x, y) = T[f(x, y)], 是一种像素的逐点运算. ·描述了输入和输出值之间的转换关系.
·不改变空间位置关系.
·点运算又称为”对比度增强”、”对比度拉伸”、”灰度变换”.
根据g(x, y) = T[f(x, y)], 可以将灰度变换分为线性变换和非线性变换.
灰度线性变换:
·输出灰度级与输入灰度级呈线性关系的点运算.
.
·如果a &gt; 1, 输出图像的对比度增大.
·如果a &lt; 1, 输出图像的对比度减小.
·如果a=1, b≠0, 使所有像素的灰度值上移或下移, 使整张图像更暗或更亮.
·如果a=1, b=0, 输出图像与输入图像相同.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/466192dcf2e8959fd883f96810da227e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4421512b4bb309d81fd538f0b4a8f602/" rel="bookmark">
			电脑外放没有声音，插耳机或者外接音箱有声音（Win 10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没有重装系统，无缘无故电脑外放没有声音，插耳机或者外接音箱才有声音，之前一直连音箱将就着，突然外接小音箱坏了，然后就开启了边百度边尝试修复的漫长过程o(╥﹏╥)o
尝试过下面这些都没用：
设备管理器—声音，视频和游戏控制器
控制面板—声音
卸载重安装Realtek驱动好多次o(╥﹏╥)o
解决：
最后在官网（https://think.lenovo.com.cn/support/driver/mainpage.aspx#ThinkPad）下载了联想驱动管理 自动安装工具：
将检测出来有问题的驱动都更新重安装了一遍，最后在安装完NVIDIA驱动后终于外放出声啦啦啦，那一刻真是太激动了！
害，也是完全没料到突然就解决问题了所以过程没啥截图QAQ，就只记住了这个驱动的名字
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a56121e4feb6e786594365b365cedd2c/" rel="bookmark">
			java迭代器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java速解 迭代器 1. 迭代器是什么 它是一种接口，用于遍历集合，集的元素。
它位于集，集合每个元素的中间，通过移动迭代器其位置来遍历元素。
集合，集（比集合更严格的一种）中都存在迭代器。
如图： 2.迭代器的方法解释 方法如图：
//询问是否有下一个元素，如果有返回true boolean hasNext() //返回将要访问的下一个对象，如果已到达了集合末尾,返回异常NoSuchElementException E next() //删除的是上次访问的对象。这个方法必须紧跟访问一个元素之后。 //使用next让迭代器越过下一位元素，随后next返回越过的对象，remove删除的就是越过的那位元素 //记住：不能连续使用remove（）方法，他必须和next配合使用 void remove() 、 default void forEachRemaning(Consumer&lt;?super E&gt; action) 我们可能会疑惑为什么没有add方法？
这就是我们要讲的iterator的子接口ListIterator
子接口ListIterator ​ ListIterator是Iterator的子接口，较比Iterator来说它多了一个在迭代器前面添加的元素的add（）方法。
为什么不在Iterator方法里面设置add方法呢？
​ 我们需要明白Iterator存在于所有集合，集（set）中，这些集合有些是有序的（如List）还有些是无序的（如Map，Set等等）。add方法在Iterator方法中添加元素是在迭代器前面添加一个元素，对于有序的集合很简单，但是对于map，set等无序的添加一个元素在迭代器前面 ，是没有意义的同时添加所需要的散列函数也十分麻烦。但如果添加元素在集合的最末尾的话，集合本身也具有add方法何需Iterator呢？ 对吧
ListIterator方法（含所有Iterator方法）：
E previous();//类似next，返回越过的元素. boolean hasPrevious();//查询是否有上一个元素，有则返回true /* previous和hasPrevious可用来逆循环遍历 */ void set(E e); //set()方法替换迭代器前面的元素 void add(E e); //添加一个元素在迭代器前面 int nextIndex(); //返回下一元素的目录索引 int previousIndex(); //返回当前元素的目录索引 注意： 在调用next之后，remove方法确实会删除迭代器左侧的元素。但是，如果调用了previous，则会删除迭代器右侧的元素。而且不能连续调用两次 remove。 add方法只依赖于迭代器的位置，而remove方法不同，它依赖于迭代器的状态 */ Iterator，ListIterator的举例** 对Iterator的使用：
//集合可以存储任意类型的对象 //当集合中不用泛型指定存储的数据类型时，集合什么都存。 Collection coll = new ArrayList(); coll.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a56121e4feb6e786594365b365cedd2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/333d232f82fb471b09a3226445d368d6/" rel="bookmark">
			docker搭建wordpress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、准备一台Linux服务器
2、安装mysql
3、安装wordpress
4、配置wordpress
1、准备一台Linux服务器 准备一台已经安装Docker的Linux主机，这里我选择的是云服务器centos系统。
2、安装mysql docker container run \ -d \ --rm \ --name wordpressdb \ --env MYSQL_ROOT_PASSWORD=123456 \ --env MYSQL_DATABASE=wordpress \ mysql:5.7 * 参数释义：
mysql镜像版本为5.7--rm：停止运行后，自动删除容器文件。--name wordpress：容器的名字叫做wordpressdb。--env MYSQL_ROOT_PASSWORD=123456：向容器进程传入一个环境变量MYSQL_ROOT_PASSWORD，该变量会被用作 MySQL 的根密码。--env MYSQL_DATABASE=wordpress：向容器进程传入一个环境变量MYSQL_DATABASE，容器里面的 MySQL 会根据该变量创建一个同名数据库（本例是wordpress） 3、安装wordpress docker container run \ -d \ -p 8080:80 \ --rm \ --name wordpress \ --env WORDPRESS_DB_PASSWORD=123456 \ --link wordpressdb:mysql \ --volume "$PWD/wordpress":/var/www/html \ wordpress * 参数释义：
-p 8080:80：将容器的 80 端口映射到当前物理机的8080端口（可根据实际情况做更改）。--volume "$PWD/wordpress":/var/www/html：将容器的`/var/www/html`目录映射到当前目录的wordpress子目录，操作$pwd/wordpress目录，相当于操作容器里面的/var/www/html目录了。 4、配置wordpress 执行上面安装wordpress命令后，会在当前目录下创建出wordpress目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/333d232f82fb471b09a3226445d368d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36e869e302b22191d1e0fd5ce555201/" rel="bookmark">
			服务器端文档组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器端文档组件 项目中需要使用文档组件操作文档(导入，导出)操作文档的框架有如下几种 1.Apache POI 1.概述 1.Apache POI是用Java编写的免费开源的跨平台的 Java API2.Apache POI提供API给Java程序对Microsoft Office（Excel、WORD、PowerPoint、Visio等）格式文档读和写的功能3.POI为Poor Obfuscation Implementation的首字母缩写，意为：可怜的模糊实现 2.功能 1.操作Excel(向下兼容) 1.HSSF － 提供读写Microsoft Excel(1997~2003版本)格式档案的功能(.xls)(依赖-poi)2.XSSF － 提供读写Microsoft Excel(2007版本)格式档案的功能(.xlsx)(依赖-poi-ooxml)3.SXSSF - XSSF的升级版本(POI3.8版本及以上)，支持低内存占用(.xlsx)(依赖-poi-ooxml) //三种方式的接口及方法 HSSF：HSSFWorkbook、HSSFSheet、HSSFRow、HSSFCell…… XSSF：XSSFWorkbook、XSSFSheet、XSSFRow、XSSFCell…… SXSSF：SXSSFWorkbook、Sheet、Row、Cell…… //SXSSF之所以是一种低内存操作方式，是因为他的构造方法SXSSFWorkbook w3= new SXSSFWorkbook(100); //100可理解为POI操作时，内存中最多只有100行数据，当超过这个数据时，就将内存之前的数据删除，并且会在硬盘中生成临时文件，从而保证了低内存消耗。也可以将这个数字调大一点 2.操作Word 1.HWPF － 提供读写Microsoft Word DOC97格式档案的功能(.doc)(依赖-poi-scratchpad)2.XWPF － 提供读写Microsoft Word DOC2003格式档案的功能(.docx)(依赖-poi-ooxml) 3.操作PowerPoint HSLF － 提供读写Microsoft PowerPoint格式档案的功能(.ppt)(依赖-poi-scratchpad) 4.操作Visio HDGF － 提供读Microsoft Visio格式流程图的功能(.vsd)(依赖-poi-scratchpad) 5.操作Publisher HPBF － 提供读Microsoft Publisher格式排版设计的功能(.pub)(依赖-poi-scratchpad) 6.操作Outlook HSMF － 提供读Microsoft Outlook格式电子邮件的功能(.msg)(依赖-poi-scratchpad) 3.依赖 4.特点 5.不同文档操作步骤 1.操作Excel // HSSF(Horrible SpreadSheet Format)：通过HSSF可以用纯Java代码来读取、写入、修改Excel文件 // HSSF为读取操作提供了两类API：usermodel和eventusermodel。即“用户模型”和“事件-用户模型” 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e36e869e302b22191d1e0fd5ce555201/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3198d0fbeb1fed7fc3144ddcc9dae71/" rel="bookmark">
			九联UNT413A_S905L3A__AI语音_默认打开ADB_完美线刷固件包【可救砖】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNT413A_S905L3A__AI语音_默认打开ADB_完美线刷固件包【可救砖】_基于云南原机制作_端口5555
固件特点：
1、修改dns，三网通用；
2、开放原厂固件屏蔽的市场安装和u盘安装apk；
3、无开机广告，无系统更新，不在被强制升级；
4、大量精简内置的没用的软件，运行速度提升30%以上，多出大量的存储空间；
5、原生9.0设置，有线蓝牙语音均正常，支持多遥控；
6、纯净优化，除必要系统软件无任何预装；
7、超稳定，运行速度快；
准备工作
1、 硬件：电视盒子、USB公对公刷机线一条、刷机用Win10或Win7电脑一台、显示器、质量过关的U盘一个（8G左右容量皆可）；
2、 工具软件：USB Burning Tool 工具。（2.2版本及以上）
教程：刷机工具默认打双钩刷机。建议使用短接神器，免拆刷机也可以用复位键。
【拆机】 拆机做好线刷准备：拧下盒子固定螺丝，拆开盒子上盖板，找到两个焊点位置，线刷需要找个导电工具（镊子、剪刀啥的都可以）短接这两个焊点。
【免拆】顶住标记图片的复位键 或者 晶晨免拆短接神器。
1、在电脑上安装Amlogic USB Burning Tool 固件烧录软件 → 打开软件 → 文件 → 导入盒子线刷包（UNT413A.img）→ 保持【擦除flash】和【擦除bootloader】两项勾上 → 点击【开始】→ 把USB线一端插上电脑另一端插上盒子 → 保持两个焊点短接 → 接上盒子电源线通电开机。
【有免拆晶晨短接神器则省略】 2、烧录软件正确识别盒子后，就会开始线刷包的烧录（这时就可以松开短接了），正常的话大约2-3分钟进度条到达100%即完成线刷。
3、点击停止烧录，断开USB线并关闭盒子电源。
刷机固件： 链接1：https://pan.baidu.com/s/1MDsbR7fBxLgX18teFFEUyg 提取码：nph3 链接2：https://wwt.lanzoux.com/b021zsq3g 提取码：g31g 声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab905ad3c87f20875e8358389813f4d6/" rel="bookmark">
			Hbuilderx Eslint配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Hbuilderx中，我们使用uniapp开发小程序。
当我们发现代码格式化出问题的时候，强迫症患者难以忍受，所以在Hbuilderx中安装完eslint-js 和eslint-vue这两个插件，整理了一下对应的配置，方便以后查阅：
1、eslint-js的配置，打开设置-&gt;插件配置&gt;找到eslint-js的 eslintrc.js文件，进行如下配置
module.exports = { 'plugins': [ 'html' ], 'parserOptions': { 'ecmaVersion': 2018, 'sourceType': 'module', 'ecmaFeatures': { 'jsx': true }, 'allowImportExportEverywhere': false }, 'rules': { 'no-alert': 0, 'eqeqeq': ['error', 'always'], // 用强等于做判断 'semi': ['error', 'never'], // 结尾不分号 'no-multi-spaces': 'error', 'indent': [2, 4], //缩进风格 'quotes': ['error', 'single'], // 使用单引号 'arrow-parens': ['error', 'as-needed'], // 简略箭头函数 'object-curly-newline': ['error', { 'multiline': true }], // 在属性内部或属性之间有换行符，就要求有换行符 'object-curly-spacing': ['error', 'always'] // 要求花括号内有空格 (除了 {}) } } 2、eslint-vue的配置，打开设置-&gt;插件配置&gt;找到eslint-js的 eslint-vue文件，进行如下配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab905ad3c87f20875e8358389813f4d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208e9f0ed9bddeb34ab01dc31976e9c8/" rel="bookmark">
			uni-app基础知识补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex 初始化 store/index.js import Vuex from 'vuex'; import Vue from 'vue'; Vue.use(Vuex) export default new Vuex.Store({ state:{}, mutations:{}, actions:{}, getters:{}, modules:{} }) main.js import store from './store/index.js' Vue.prototype.$store = store; vuex的模块 state：状态，存储数据 state定义数据 state:{ gTitle:{ title:"你好Vuex", color:"#f00", fontSize:"24px", backgroundColor:"#0f0" }, joks:[], }, 在页面中使用：$store.state.gTitle.title修改只能通过mutations组件中简写 import {mapState} from 'vuex' computed:{ ...mapState(["gTitle"]) } mutations：修改数据的唯一方法 定义 //更改字体大小 setSize(state,data){ state.gTitle.fontSize = data + "px" }, //更改背景颜色 setBackgroundColor(state,data){ state.gTitle.backgroundColor = data }, setJok(state,data){ state.joks = data } 页面中使用：this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208e9f0ed9bddeb34ab01dc31976e9c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfd85e6a25baacca34afd21d6f95385/" rel="bookmark">
			超百个免费api接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API（应用程序编程接口）
API（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。
免费api访问网址（不需要注册）
一、教书先生
稳定、快速、免费的 API 接口服务
https://api.oioweb.cn/
二、UomgAPI
稳定、快速、免费的 API 接口服务
https://api.uomg.com/
三、短网址API
稳定、快速、免费的 API 接口服务
https://api.d5.nz
四、韩小韩API
我好像在哪里见过你
https://api.vvhan.com
五、JSON API免费接口
各种提供JSON格式数据返回服务网站的API接口
http://www.bejson.com/knownjson/webInterface/
五、末日API
http://api.weijieyue.cn/#
六、顾宇API
http://47.94.135.214/
七、free-api
https://www.free-api.com/
免费api接口（需要注册）
一、聚合数据
https://www.juhe.cn/docs?bd_vid=12366660879320847918
二、万维易源
https://www.showapi.com/?renqun_youhua=259537
三、极速数据
https://www.jisuapi.com/api/?isfree=1
四、百度AI平台
https://ai.baidu.com/
五、阿里云免费api
https://www.aliyun.com/?spm=a2c4e.11155472.1280361.1.3f665d02tWDTRR
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fccab2b2a9e6f0f1b0f421020fb2824/" rel="bookmark">
			使用python实现高清壁纸批量下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.高清壁纸批量下载 1.概述 此代码是使用python多线程批量下载高清壁纸的一个小脚本,代码略为简陋.
此代码仅供学习与交流,请不要用于违法用途.
import requests from lxml import etree import re import time from concurrent.futures import ThreadPoolExecutor, wait, ALL_COMPLETED # 爬取高清壁纸排行榜 # 获取图片下载地址 def getPicUrl(): url = "https://wallhaven.cc/toplist?page=9999" req = requests.get(url); html = etree.HTML(req.text) # 通过获取报错页面获取最大页数 img_list = html.xpath('//*[@id="thumbs"]/section[1]/header/h2/text()[2]')[0] comp = re.compile("-?[1-9]\d*") list_int = comp.findall(img_list)[0] print("一共有"+list_int+"页") for i in range(1,int(list_int)): #可修改int(list_int)指定需要下载的页数 url = "https://wallhaven.cc/toplist?page={}".format(i) req = requests.get(url); html = etree.HTML(req.text) for j in range(1,30): # 每一页的图片数 try: ''' 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fccab2b2a9e6f0f1b0f421020fb2824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5389682cec86b1e5fe9c0cdf69cada0c/" rel="bookmark">
			【mysql】dump
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dump文件用于恢复数据
mysql进行dump 定时任务 脚本文件 文件 mysqldump.sh.
#!/bin/bash ################################################################# # 1. 与该脚本同级目录下，需存在.sql.cnf文件（用于数据库备份）、.back.cnf文件（用于读取配置） # 2. 需配置ssh-keygen支持免密登录 ################################################################# # 保存备份个数，备份31天数据 NUMBER=15 # 备份保存路径，当前路径 BACKUP_DIR=$(dirname $(readlink -f "$0")) # 日期，用于备份文件名后缀 NOW=$(date +"%Y-%m-%d-%H-%M-%S") ############################################## # 以下配置从.back.cnf文件中读取 # 将要备份的数据库 DATABASE_NAME= # SCP配置 SCP_FLAG=no SCP_HOST= SCP_PORT= SCP_USER= ############################################## # 从.back.cnf读取配置 loadConfig() { while read line; do eval "$line" done &lt; .back.cnf } # 根据.sql.cnf配置备份数据库 backup() { # 当前备份的文件名 backup_file=$BACKUP_DIR/$DATABASE_NAME-$NOW.sql echo "create $backup_file begin..." # mysqldump mysqldump --defaults-extra-file=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5389682cec86b1e5fe9c0cdf69cada0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438e0f0dcde137c375332f1d8cc87f99/" rel="bookmark">
			easyX常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据以前学习笔记整理，分享给正在学习easyX的朋友。
(一)：与设备相关的函数
1.void clearcliprgn()：此函数以当前背景色清除裁剪区域，无参，无返回值。
2.void cleardevice()：此函数用于清除绘图设备，无参，无返回值。具体地说，就是绘图设备将以当前背景色清空，并将当前点移动到(0,0)。
3.void closegraph(); 此函数用于关闭图形窗口，无参，无返回值。
4.void getaspectratio(float *pxasp,float *pyasp)：获取当前图形模式的纵横比，无返回值。使用方法：分别声明x方向和y方向两个float变量，用&amp;符号取址后作为函数的参数；函数执行后这两个变量的值即是当前窗口在x方向及y方向的缩放比，这两个值有正负号，负号表示坐标轴方向被置反向了。
5.void graphdefaults()：此函数将视图、当前点、绘图颜色、背景颜色、线条样式、填充样式、字体样式等重置为默认；无参，无返回值。
6.HWND initgraph(int width,int height,int flag = NULL)：此函数用于初始化图形窗口，参1 窗口宽度；参2 窗口高度，参3 是否同时显示控制台窗口，返回值是窗口的句柄。
7.void setaspectratio(float xasp, float yasp)：此函数用于设置当前长、宽方向缩放比（相当于比例尺）及x轴、y轴的朝向。如：setaspectratio(1,-1)表示x、y两轴无缩放，但Y轴朝向改为向上。无返回值，参数含义同getaspectratio（）。
8.void setcliprgn(HRGN hrgn);此功能用于设置当前绘图设备的剪切区域，将该区域设置为裁剪区后，任何区域外的绘图都将无效。参数 裁剪区域句柄；无返回值。
HRGN类型是 Windows 定义的表示区域的句柄。可以使用 Windows GDI 函数创建一个区域。例如，创建矩形区域可以使用函数：HRGN hrgn=CreateRectRgn(int left, int top, int right, int bottom);此外，还可以使用函数 CreateEllipticRgn 创建椭圆形的区域，使用 CreatePolygonRgn 创建多边形的区域等等。
9.void setorigin(int x, int y);该函数用于设置相对坐标原点；参1、2 拟设置为原点的物理坐标。easyX物理坐标系的原点在屏幕左上角，x轴的正方向向右，y轴的正方向向下，与习惯不一致，如需改变，可以通过本函数。
(二)：与颜色相关函数
10. COLORREF BGR(COLORREF color)：BGR 宏用于交换颜色中的红色和蓝色。参 color需要交换红色和蓝色的颜色；返回值 返回交换红色和蓝色后的颜色。
颜色在内存中的表示形式为：0xbbggrr (bb=蓝，gg=绿，rr=红)，但是显示缓冲区中的颜色表现形式为 0xrrggbb。注意，两者的红色和蓝色是相反的。直接操作显示缓冲区时，可以通过 BGR 宏交换颜色的红色和蓝色部分。（这个宏也可看做函数一般很少使用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/438e0f0dcde137c375332f1d8cc87f99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/531f67003d8d57b993e5ef2637e709a3/" rel="bookmark">
			FlinkSql中的窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		窗口可以将无界流切割成大小有限的“桶”（bucket）来做计算，通过截取有限数据集来处理无限的流数据。 窗口表值函数（Window TVF） 从 1.13 版本开始，Flink 开始使用窗口表值函数（Windowing table-valued functions，
Windowing TVFs）来定义窗口。窗口表值函数是 Flink 定义的多态表函数（PTF），可以将表
进行扩展后返回。表函数（table function）可以看作是返回一个表的函数。
目前 Flink 提供了以下几个窗口 TVF： 滚动窗口（Tumbling Windows）； 滑动窗口（Hop Windows，跳跃窗口）； 累积窗口（Cumulate Windows）； 会话窗口（Session Windows，目前尚未完全支持）。 在窗口 TVF 的返回值中，除去原始表中的所有列，还增加了用来描述窗口的额外 3 个列：窗口起始点（window_start）、窗口结束点（window_end）、窗口时间（window_time）。起始点和结束点比较好理解，这里的“窗口时间”指的是窗口中的时间属性，它的值等于window_end - 1ms，所以相当于是窗口中能够包含数据的最大时间戳。
滚动窗口（TUMBLE） 滚动窗口在 SQL 中的概念与 DataStream API 中的定义完全一样，是长度固定、时间对齐、无重叠的窗口，一般用于周期性的统计计算。在 SQL 中通过调用 TUMBLE()函数就可以声明一个滚动窗口，只有一个核心参数就是窗口大小（size）。在 SQL 中不考虑计数窗口，所以滚动窗口就是滚动时间窗口，参数中还需要将当前的时间属性字段传入；另外，窗口 TVF 本质上是表函数，可以对表进行扩展，所以还应该把当前查询的表作为参数整体传入。具体声明如下：
TUMBLE(TABLE EventTable, DESCRIPTOR(ts), INTERVAL '1' HOUR) 这里基于时间字段 ts，对表 EventTable 中的数据开了大小为 1 小时的滚动窗口。窗口会将表中的每一行数据，按照它们 ts 的值分配到一个指定的窗口中。
应用场景：统计每小时的pv，uv。
滑动窗口（HOP） 滑动窗口的使用与滚动窗口类似，可以通过设置滑动步长来控制统计输出的频率。在 SQL中通过调用 HOP()来声明滑动窗口；除了也要传入表名、时间属性外，还需要传入窗口大小（size）
和滑动步长（slide）两个参数。
HOP(TABLE EventTable, DESCRIPTOR(ts), INTERVAL '5' MINUTES, INTERVAL '1' HOURS)); 这里我们基于时间属性 ts，在表 EventTable 上创建了大小为 1 小时的滑动窗口，每 5 分钟滑动一次。需要注意的是，紧跟在时间属性字段后面的第三个参数是步长（slide），第四个参数才是窗口大小（size）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/531f67003d8d57b993e5ef2637e709a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448f2f2515c7324fe03ce33d95881a8e/" rel="bookmark">
			8个免费的高清视频素材下载网站，资源超多，随意下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
分享8个高清视频素材下载网站，不仅免费而且是无版权的，各种类型的视频都有，不管是个人使用还是商用都可以！
1、Pexels 一个比较受欢迎无版权素材网站，它里面有图片素材和视频素材可以下载使用，素材质量都挺高的，视频素材类型也比较全面，并且支持中文搜索。
下载也方便，在视频详情界面点击下载按钮，会在新的播放页播放视频，觉得合适将视频保存下来就好了。
2、Mixkit 一个高清免费视频下载网站，它里面的视频类型还挺丰富的，并且有详细的分类，可以直接按照分类查看，也可以直接搜索，不过只支持中文搜索。
在视频列表中，鼠标点到视频就会自动播放，可以预览，在视频详情界面可以将视频下载到本地，不需要注册登录。
除了视频素材之外，它里面还有音乐素材、音效素材、视频模板等素材，也可以下载使用。
​
3、Pixabay 一个免费无版权素材网站，它里面有图片素材、插画素材、向量素材、视频素材、音乐素材等等，所有的素材都可以免费下载。
视频的质量还挺高的，想要什么视频直接搜索就行，支持中文搜索，进入视频详情界面就可以下载视频了，下载视频的时候可以选择不同尺寸下载，并且下载不需要注册登录。
​
4、Distill 一个免费提供创意短视频的网站，它每10天就会更新10个高清短视频，各种类型的都有，直接搜索你想要的视频就行，还可以直接订阅，会自动将更新的视频发送到你的邮箱。
在视频列表中，将鼠标移动到视频上就可以快速预览，点击下载按钮就会打开播放页，就可以将视频保存下来了，也不需要注册登录。
​
5、Coverr 一个完全免费的库存素材网站，它里面的视频类型有自然、人们、爱情与人际关系、商业与工作、健康、航拍、宠物和动物、缩放虚拟背景等等，还挺丰富的。
在视频列表中可以预览视频，点击下载按钮，可以下载高清视频或者4K视频，下载高清视频不需要注册登录，但是下载4K视频是需要注册登录的。
​
6、Mazwai 一个由专业视频团队打造的视频素材网站，它里面的视频都是人工精挑细选出来的，所以视频的质量还挺高的，大多数视频都是4K画质的，根据标签就可以查看视频，也可以直接搜索。
在视频详情界面就可以预览并下载视频了，下载是不需要注册登录的，不过要注意，这里里面的视频可以免费商用，但是需要署名。
​
7、Ignite Motion 一个提供动态视频背景的网站，它里面的视频类型有抽象的、航空、城市、云、地球与太空、齿轮等等，需要这类视频素材就可以看看这个网站。
在视频详情界面就可以下载视频了，不需要注册登录，不过不支持预览视频。
​
8、Monzoom 一个特效视频素材下载网站，它里面提供了各种各样的视频背景、视频元素和视频效果素材，比如想要下载视频转场、视频叠加效果等素材，就可以在这个网站找。
视频可以免费下载，不过需要注册登录账号。
​
好了，以上就是一些免费好用的无版权视频素材网站，大家可以收藏一下，有需要的时候就可以拿出来用了！
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a1adfd8382cffd317ee91aaf8454a9/" rel="bookmark">
			mysql基础入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.2 数据库介绍 1.2.1 作用 数据库是用来存放数据的仓库
数据库中存放的是表，表中存放的是数据。
1.2.2 数据库的发展史 萌芽阶段：文件系统
最初始的数据库是用磁盘来存储数据的。文件就是最早的数据库。
第一代数据库：层次模型
优点：这是导航结构
优点：结构清晰，分类查询方便
缺点：有可能造成数据无效
第一代数据库：网状模型
网状模型解决了层次模型的数据不一致的问题，但没有解决导航问题。导航结构在查询中有时候效率低下，比如查询整个公司的四月的营业额。
第二阶段：关系模型
特点：
1、每个表都是独立的
2、通过关系字段将两个表连接起来
3、关系：两个表的公共字段
4、关系型数据库中多表联合查询效率低下。
多学一招：为了解决关系型数据库多表查询效率的问题，项目中使用了NoSQL(非关系型数据库，Redis、mongodb等等)，在数据库中按照键值对来存储，它是关系型数据库的补充。
1.2.3 SQL Structured Query Language（结构化查询语言），是用来操作关系型数据库的一门语言。这是一个关系型数据库的通用操作语言，也成为标准SQL，也叫SQL-92。
脚下留心：数据库的生产厂商为了占有市场份额，都会在标准SQL的基础上扩展一些自己的东西以吸引用户。
1.2.4 常用的关系型数据库 关系型数据库开发公司使用语言access微软公司SQLSQL Server微软公司T-SQLOracle甲骨文公司PL/SQLMySQL被甲骨文公司收购MySQL 思考：已知标准SQL可以在所有的关系型数据库上运行，在Oracle上编写的PL/SQL能否在MySQL上运行？
答：不可以，只能运行标准SQL
1.3 连接服务器 数据库是CS模式的软件，所以要连接数据库必须要有客户端软件。
MySQL数据库默认端口号是3306
1.3.1 window界面连接服务器 1、Navicat
2、MySQL-Front
1.3.2 通过web窗体连接 主要有浏览器就可以访问数据库
1.3.3 命令行连接 host	-h	主机 port	-P	端口号 （大写） user	-u	用户名 password	-p	密码 （小写） 例题
-- 连接数据库 F:\wamp\PHPTutorial\MySQL\bin&gt;mysql -h127.0.0.1 -P3306 -uroot -proot -- 明文 -- 如果连接本地数据库 -h可以省略 如果服务器端口是3306，-P端口号也可以省略 F:\wamp\PHPTutorial\MySQL\bin&gt;mysql -uroot -proot	-- 明文 -- 密文 F:\wamp\PHPTutorial\MySQL\bin&gt;mysql -uroot -p Enter password: **** 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41a1adfd8382cffd317ee91aaf8454a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91245ea6c60ddb03824ac4605cfb35eb/" rel="bookmark">
			CIFAR-10 数据集简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 CIFAR-10 简介 CIFAR-10 简介 官网：http://www.cs.toronto.edu/~kriz/cifar.html
CIFAR-10和CIFAR-100是8000个万小图像数据集的标记子集。它们由Alex Krizhevsky, Vinod Nair和Geoffrey Hinton收集。
CIFAR-10数据集包含60000张32x32彩色图像，分为10个类，每类6000张。有50000张训练图片和10000张测试图片。
数据集分为五个训练batches和一个测试batch，每个batch有10000张图像。测试batch包含从每个类中随机选择的1000个图像。训练batches以随机顺序包含剩余的图像，但有些训练batches可能包含一个类的图像多于另一个类的图像。在它们之间，训练batches包含来自每个类的5000张图像。
下面是数据集中的类，以及每个类的10张随机图片:
一共包含10 个类别的RGB 彩色图片：飞机（ airplane ）、汽车（ automobile ）、鸟类（ bird ）、猫（ cat ）、鹿（ deer ）、狗（ dog ）、蛙类（ frog ）、马（ horse ）、船（ ship ）和卡车（ truck ）。
这些类是完全相互排斥的。汽车和卡车之间没有重叠。“汽车”包括轿车、越野车之类的东西。“卡车”只包括大卡车。这两项都不包括皮卡。
该数据集的Python版本的布局：
存档包含文件data_batch_1, data_batch_2，…、data_batch_5以及test_batch。它们中各有10000 个样本。这些文件中的每一个都是使用 cPickle 生成的 Python“pickle” 对象（Python的序列化数据，详情参见：【Python】Python 中实现数据序列化）。下面是一个 Python2 的例子，它将打开这样一个文件并返回一个字典（Python2 的反序列化过程）：
def unpickle(file): import cPickle with open(file, 'rb') as fo: dict = cPickle.load(fo) return dict Python3 的反序列化过程：
def unpickle(file): import pickle with open(file, 'rb') as fo: dict = pickle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91245ea6c60ddb03824ac4605cfb35eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e99da3a18d0ddad2d498c0e094fecf31/" rel="bookmark">
			多线程与高并发（13）——Java常见并发容器总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文总结常见的并发容器，包含ConcurrentHashMap、CopyOnWriteArrayList 、ConcurrentLinkedQueue、BlockingQueue 、ConcurrentSkipListMap，本文仅做简单的总结，不做详细的源码分析。
一、ConcurrentHashMap HashMap不是线程安全的，ConcurrentHashMap是线程安全的。
ConcurrentHashMap的数组结构也是Node 数组 + 链表 / 红黑树，同时它采用的Synchronized 锁加CAS的机制，引用了锁升级的策略，所以性能方面没有太多问题。
在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。
这里不过多总结了，回头单独写一篇文章，从源码理解ConcurrentHashMap。
二、CopyOnWriteArrayList CopyOnWriteArrayList 是一个线程安全且读操作无锁的ArrayList ，ArrayList 是什么呢，查询速度很快，有序且可重复，底层是一个数组。
public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable { 由于日常使用时，读操作远远大于写操作，类似于ReentrantReadWriteLock（读写锁），为了进一步增加读取的效率，这里直接就不给读操作加锁，而且：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。
我们先看读操作源码：
@SuppressWarnings("unchecked") private E get(Object[] a, int index) { return (E) a[index]; } public E get(int index) { return get(getArray(), index); } final Object[] getArray() { return array; } 嗯，平平无奇，就是正常获取数组的值。
再看写操作的代码，我们看add的源码：
public boolean add(E e) { final ReentrantLock lock = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e99da3a18d0ddad2d498c0e094fecf31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d30421aa6ac68e91aa195a2b053084ee/" rel="bookmark">
			C&#43;&#43;继承的相关访问归纳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		举例三个类：公共（public）继承 class A class B :public A calss C:public B
{ { {
public: public: public: void fa1(); void fb1(); void fc1();
int a1; int b1; int c1;
protected: protected: protected:
void fa2; void fb2(); void fc2();
int a2; int b2; int c2;
private: private: private:
void fa3(); void fb3(); void fc3();
int a3; int b3; int c3;
}; }; };
分别创建各自对象A a，B b，C c；
1、问：A类中的成员能访问到A中的那些成员？
理解题意：A类所以问的是类内访问
类内访问的权限public，protected、private。
2、问：A类的对象a可以访问到A的那些成员？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d30421aa6ac68e91aa195a2b053084ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2500d3b1dce043ee241af86036f07511/" rel="bookmark">
			AndroidStudio的安装和插件配置大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AndroidStudio 配置 下载和安装ASSdkJdk GradleAS4.2 gradle user homeAS4.2 Gradle面板中Tasks消失 常见问题1. 控制台乱码2. 光标所在当前行的背景色3. 其他颜色修改4. 配置Logcat的颜色输出5. 可编辑的代码范围内的主题修改6.代码字体调节7.代码区域背景色 常用插件1. 找到Plugins2. 安装插件3. 主题 Material Theme UI4. GsonFormat5. Android ButterKnife Zelezny6. Android Parcelable code generator7. Android Methods Count8. Lifecycle Sorter9. Android Styler10. Gradle Dependencies Helper11. .ignore12. SingletonTest13. Alibaba Java Coding Guidelines14. ADB idea ; ADB WiFi Connect15. InnerBuilder16. Translation17. AndroidProguardPlugin18. CodeGlance19. FindBugs20. jimu Mirror21. Biu22. 接口调试 JsonOnlineViewer23. EventBus3 Intellij Plugin24. lombox25. Android Drawable Preview26、Statistics 参考地址 下载和安装 AS 每次重新下载都需要配置，记录下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2500d3b1dce043ee241af86036f07511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3706e4328ff6eab7e5b88f324b44357/" rel="bookmark">
			光谱数据作图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现光谱仪配套的软件在半高宽的计算上好像有些问题，试了试python能不能解决。 目录 1.光谱原图
2.光谱数据标准化
3.光谱标注峰值和半高宽
1.光谱原图 首先，导入光谱数据，做图；
import pandas as pd import matplotlib.pyplot as plt df1 = pd.read_excel('D:/desktop/data.xlsx')#读取.xlsx文件 data = df1.values #data为除了第一行以外的数据 print(data.shape) #查看data的size WL = data[:,0] Intensity = data[:,1] font1 = {'family' : 'Times New Roman', 'weight' : 'normal', 'size' : 16, } plt.figure(figsize=(5,5)) plt.title('guangputu',font1) plt.xlabel('lambda/nm',font1) plt.plot(WL,Intensity,'-*') plt.legend(['intensity']) plt.show() 运行结果：（1044,2） 2.光谱数据标准化 起初，出现了这样的问题
from sklearn.preprocessing import MinMaxScaler scaler = MinMaxScaler(feature_range=(0, 1)) #将数据归一到0到1 Intensity = scaler.fit_transform(Intensity) plt.figure(figsize=(5,5)) plt.title('biaozhunhua',font1) plt.xlabel('lambda/nm',font1) plt.plot(WL,Intensity,'-*') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3706e4328ff6eab7e5b88f324b44357/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbca3049ff69cdc8a9e44e5bbbe34c6d/" rel="bookmark">
			微信小程序自带git工具，操作后丢失代码的恢复操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在上传github的时候遇到了pull failed问题,于是搜了一篇如何解决的文章如下:
https://blog.csdn.net/mcp1490644562/article/details/89878803 使用该文章方法后,可能因为使用不当,本地的分支和远程分支的代码都不见了。
于是我尝试百度 ,但是百度出来的 要么是工作区本来就存储了 要么之前点了存储
对我来说一点用都没有,于是我尝试自己找方法
下面是我自行查找恢复的过程：
步骤 首先打开你误删除代码的文件夹,打开电脑的设置,把显示隐藏文件夹勾选了,你会看到.git的隐藏文件夹
然后点开.git文件夹
进入logs
进入refs
进入heads
用记事本打开master (这个master是我本地分支的命名)
我们可以发现 00000开头的一定是有特殊意义的 然后第二条信息是我不小心重置的记录
我们再观察得到 上面ced17开头的字符串比较可疑
在git extension上面链接这个文件夹 然后输入 git reset --hard ced17…(完整字符串)
然后再看文件夹
兄弟们 ,他们回来了,他们回家了!!! 而且git log 命令显示的 没有我上面说可疑的那个字符串的日志,上图 总结:老子以后使用不熟悉的技术,必备份! 20220923更新：
今天发现有私信看了原本的那篇文章，现在我已经懂了为什么会不见了却能找回来了
那篇文章其实意思是有多个人一起开发，你上传代码之前先把其他人的代码合并了再传代码
其实可以用命令git pull -r来实现。
log里面的内容有提交备注为init commit的commit，其实本质还是我操作之前commit了一次。
另外学习git的资料：百度git branchlearing，是一个外网，打怪升级的模式
学习完之后，还有几个常用命令，git stash/pop、git cherry-pick、git add . 、 git commit --amend --no-edit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02c592f45ffa5690634f8376321865d2/" rel="bookmark">
			服务器存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器存储 前言一、开放系统的存储简介1.DAS2.NAS3.SAN4.直连式存储（DAS）和网络存储（NAS、SAN）的区别NAS和SAN的区别 二、存储接口简介 前言 存储架构根据服务器类型分为
1、封闭系统的存储（此处的封闭系统可理解为一些只为特定硬件提供系统服务的机器，如大型机、AS400等服务器）
2、开放系统的存储（此处的开放系统可理解为基于Windows、UNIX、Linux等操作系统的服务器）
开放系统存储又分为
1、内置存储（存储在服务器内）
2、外挂存储（存储外挂在服务器外）
封闭存储的系统开放存储的系统-内置存储-外挂存储 一、开放系统的存储简介 名称介绍DAS直连式存储(Direct-AttachedStorage)NAS网络附属存储(Network Attached Storage)SAN存储区域网络(Storage Area Network) 1.DAS 存储设备通过电缆（通常是SCSI接口电缆）直接挂到服务器总线上
2.NAS 存储设备通过标准的网络拓扑结构(例如以太网)连接
NAS有文件系统和IP地址，可以类似的理解为网上邻居的共享磁盘，或者NFS的服务端，即导出目录的一端。NAS是文件级的存储方法，它有自己的文件系统，如NFS，SMB的CIFS，所以它是真正即插即用的产品。
3.SAN 在SAN网络中，所有的数据传输在高速、高带宽的网络中进行，SAN存储实现的是直接对物理硬件的块级存储访问，提高了存储的性能和升级能力。
早期的SAN采用的是光纤通道（FC，Fiber Channel）技术，所以，以前的SAN多指采用光纤通道的存储局域网络，到了iSCSI协议出现以后，为了区分，业界就把SAN分为FC-SAN和IP-SAN。
SAN连接又分ISCSI（网口）SAS（SAS口）以及FC（光纤口）连接
注：这种连接需要单独的存储产品，可以通过光纤交换机连接。
4.直连式存储（DAS）和网络存储（NAS、SAN）的区别 直连式存储，一个服务器挂一个或多个存储，由单个服务器独自使用
网络存储，多个存储组成存储池，可供多个服务器按需使用
NAS和SAN的区别 最大的区别
NAS和SAN本质上的不同点在于NAS有自己的文件系统，而SAN的文件系统在应用程序服务器上而非存储服务器上
其他区别
NAS性能比SAN要差很多，但相对成本也低很多
总的来说
如果用户需要通过FC访问block，就用SAN；如果需要通过Ethernet访问file system，就用NAS。
二、存储接口简介 接口名称介绍IDE电子集成驱动器（Integrated Drive Electronics）ATA高级技术附件（Advanced Technology Attachment）【IDE接口别称】SATA串行ATA（Serial ATA）PATA并行ATA（Parallel ATA）【原ATA】SCSI小型计算机系统接口(Small Computer System Interface)SAS串行连接SCSI（Serial Attached SCSI） IDE接口
曾经主流的硬盘接口，2003年推出SATA后，ATA改名为PATA
SATA接口
采用串行连接方式的ATA接口
SCSI接口
目前各种计算机与外部设备之间的接口标准。
SCSI其内有控制芯片，可以代替cpu完成90%多的IO工作（如计算、控制、转换等），CPU不必浪费时间进行等待，可提高整体性能。
SAS接口
SAS技术引入SAS扩展器，使SAS系统可以连接更多的设备，其中每个扩展器允许连接多个端口，每个端口可以连接SAS设备、主机或其他SAS扩展器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af9301778db42928698cc150670c375/" rel="bookmark">
			CAN XL ：CAN协议家族新成员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十年之前，你不认识我，我也不认识CAN FD。如今，CAN FD已经陆续进入乘用车领域，几乎所有汽车制造商都将在未来几年内逐步推出搭载CAN FD的乘用车。那十年之后，车载网络又会向什么方向发展呢？
根据现在的形势来看，车载架构将从历史悠久的平面网络方案迁移到与域相关的方案。而域相关的车载网络体系结构，就需要通用的标准化高层协议。对于高层协议来说，它们应尽可能独立于下层协议，这样不同通信技术的专用技术和商业功能就能够被使用。当然，要支持TCP / IP，经典的CAN和CAN FD并不是最好的下层方法。因此，CiA（CAN in Automation，以下简称CiA）及其成员已经开始开发具有支持10 Mbit / s甚至更多的物理层的CAN XL。虽然TCP / IP不一定是最佳的传输/网络层的解决方案，但是DoIP已经在ISO中标准化并且广泛应用了，所以能够支持TCP/IP对于CAN XL来说还是非常重要的。
CAN XL规范尚未最终确定，仍然存在一些未解决的问题。已经决定的是数据字段长度最大为2048字节和11位优先级字段。此外，该协议为使用的下一个更高协议提供8位指示符。可以说这是不适合经典OSI参考模型的嵌入式层设置参数。这样的嵌入式层设置参数对于其他高层协议也将很有帮助，以简化多协议堆栈。如今，标准化了太多不同的高层协议，它们并不完全独立于所使用的较低层协议。一些ISO专家希望克服这一点。
CAN XL原计划于3月中旬在德国-巴登举行的国际CAN大会（iCC）上正式推出。今年晚些时候，当CAN XL规范发布并且相关的互操作性测试证明了第一个实现的互操作性时，CiA会将它们提交给ISO进行国际标准化。
下面就一起来看一下CAN XL与CAN FD的异同。
▲ 图 1：CAN FD, CAN XL帧格式
与CAN FD相比，CAN XL增加了位的数量；这些附加位位于报文头与报文末尾处；大多数的所需位是CRC，必须增加它才能保护超出的更多的字节。 CAN FD&amp; CAN XL报头比较
▲ 图 2：CAN FD, CAN XL帧头部
上图中顶部的黑线表示隐性，底部的黑线表示显性。那么我们分析上图可得出以下结论：
SOF和11位的CAN ID场在CAN、CAN FD、CAN XL中是通用的；CAN FD和CAN XL始终不支持RTR远程请求；CAN XL不支持IDE标识符扩展（29位CAN ID），该位始终处于显性；隐性FDF位指示CAN FD，隐性FDF、XLF位指示CAN XL；CAN FD中res位始终处于显性，隐性BRS位（波特率切换）会提升传输速率；CAN FD中ESI位通常处于显性，但处于被动错误时会变为隐性；CAN XL中resXL位是隐性的，可用于将来的扩展；CAN XL中AL1、DH1和DL1作为新的波特率切换序列；CAN XL中Payload 8-bit用于不同数据包的预定义多路复用位；CAN XL中DLC是一个11位整数，其中数据字节数是该整数加1；CAN XL中Header-CRC用于保证DLC正确，DLC定义数据CRC从何处开始。 ▲ 表 1：DLC编码表
CAN FD&amp; CAN XL报尾比较
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af9301778db42928698cc150670c375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/729010509a9f8c6ba284a0b551a1eff7/" rel="bookmark">
			pytorch初学笔记（五）：torchvision中dataset的最详细使用（以CIFAR10和MNIST为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、torchvision介绍
1. 作用与结构
2. torchvision中常用数据集
二、CIFAR10的介绍
1. 数据集简介
2. 使用该数据集的所需参数 3. 数据集下载
3.1 pycharm在线下载（下载速度较快时） 3.2 第三方下载
3.3 数据库的下载总结 三、 CIFAR10的具体使用
1. 数据集对象的显示（PIL型）
2. 把数据集中的图片对象转换为tensor型
2.1 转换所需transform的定义
2.2 使用tensorboard进行图片显示
四、练习：MNIST数据集的下载和使用
1. 可能的报错和修改 2. 代码实现
2.1 PIL对象实现
2.2 tensor对象实现
3. 运行结果 一、torchvision介绍 1. 作用与结构 torchvision — Torchvision main documentation
torchvision是pytorch下的一个包，主要由计算机视觉中的流行数据集、模型体系结构和常见图像转换等模块组成。
常用的包：
Transforming and augmenting images：进行图片变换等。Models and pre-trained weights：提供一些预训练好的神经网络或权重参数等。Dataset ：提供常用的数据集。 2. torchvision中常用数据集 Datasets — Torchvision main documentation
Datasets模块提供了需要常用的数据集以及其具体的使用方法，比如下图所示的图像分类中常用的CIFAR10数据集，图像检测中常用的COCO数据集等。
下面具体说明如何对CIFAR10进行下载和使用。
二、CIFAR10的介绍 1. 数据集简介 CIFAR-10 and CIFAR-100 datasets (toronto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/729010509a9f8c6ba284a0b551a1eff7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45172a085904212b881c08fecbe40206/" rel="bookmark">
			判断浮点数是否相等以及CompareTo()的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
CompareTo()比较字符串类型
如何判断两个浮点数是否相等？
CompareTo()比较字符串类型 1.返回参与比较的前后两个字符串的ASCII码的差值，如果两个字符串首字母不同，则该方法返回首字母的ASCII码的差值。
String a1 = "a"; String a2 = "c"; System.out.println(a1.compareTo(a2));//结果为-2 2.参与比较的两个字符串如果首字符相同，则比较下一个字符，直到有不同的为止，返回该不同的字符的asc码差值。
String a1 = "aa"; String a2 = "ad"; System.out.println(a1.compareTo(a2));//结果为-3 3.如果两个字符串不一样长，可以参与比较的字符又完全一样，则返回两个字符串的长度差值。
String a1 = "aa"; String a2 = "aa12345678"; System.out.println(a1.compareTo(a2));//结果为-8 4.返回为正数表示a1&gt;a2, 返回为负数表示a1&lt;a2, 返回为0表示a1==a2。
5.int型可以直接比较，所以没有用到compareTo比较，如果声明的是Date、String、Integer、或者其他的，可以直接使用compareTo比较。
Integer n1 = 5; Integer n2 = 6; System.out.println(n1.compareTo(n2));//-1 compareTo()方法_Luke@的博客-CSDN博客_compareto 如何判断两个浮点数是否相等？ 问题场景
/** * 两个浮点数直接判断 */ double value1 = 0.9 - 0.8; double value2 = 0.8 - 0.7; System.out.println(value1 == value2); // false 因为不论是float还是double都是浮点数，计算机是二进制，浮点数会失去一定的精确度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45172a085904212b881c08fecbe40206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3388ee2fd9cac67a854a50df5d17e00/" rel="bookmark">
			在C#中使用Halcon开发视觉检测程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文的初衷是希望帮助那些有其它平台视觉算法开发经验的人能快速转入Halcon平台下，通过文中的示例开发者能快速了解一个Halcon项目开发的基本步骤，让开发者能把精力完全集中到算法的开发上面。
首先，你需要安装Halcon，HALCON 18.11.0.1的安装包会放在文章末尾。安装包分开发和运行时两个版本，运行时版本一般用于生产环境。
注：开发版本自带运行时可替代运行时版本，但安装的东西会比较多。
然后，你需要学会查看Halcon的帮助手册，这是很重要的一件事。
本文涉及到帮助文档的主要章节如下：
原文 HALCON 18.11.0.1 / Programmer's Guide / Programming With HALCON/.NET 翻译 HALCON 18.11.0.1/程序员指南/使用 HALCON/.NET 编程 原文 HALCON 18.11.0.1 / HALCON Operator Reference 翻译 HALCON 18.11.0.1/ HALCON 运算符参考 文中的示例是我第一次接触Halcon时的学习测试用例，在电脑里面躺了一年，最近才有时间整理一下发出来，希望能对你有所帮助。
注：运行本文示例程序前至少安装Halcon的运行时，否则Halcon的dll无法正常使用。
将 HALCON/.NET 添加到应用程序# 添加控件# 右键单击工具箱，然后选择“选择项”，弹出的对话框选择“.NET Framework组件”，单击下面的“浏览”，导航到HALCON安装目录下的\bin\dotnet35（VS2008以下版本的选择dotnet20） ，然后选择halcondotnet.dll。
完成上述操作后，HSmartWindowControl和HWindowControl控件就会出现在工具箱中，其中HWindowControl控件已经过时官方不再推荐使用。
与HWindowControl相比，HSmartWindowControl控件具有以下几个优点：
可以像任何其他控件一样使用提供预定义的鼠标交互（移动窗口内容并使用鼠标滚轮进行缩放）， 可以通过双击窗口来重置视图控件会自动重新缩放，而不会闪烁 注：与HSmartWindowControlWPF 相反，HSmartWindowControl需要一个回调才能使用鼠标滚轮进行缩放。
引用dll# 在HALCON安装目录下的\bin\dotnet35中，引用以下dll：
hdevenginedotnet.dllhalcondotnet.dll 注：使用 HALCON XL 开发应用程序时，必须选择以xl结尾的dll，hhdevelop xl适用于大分辨率的图像（大于 32k x 32k ）。
引用以下命名空间：
HalconDotNet：控件所在的命名空间HalconType：Line、Rectangle2等数据类型所在的命名空间 调用Halcon算子# 以ReadImage操作为例，函数原型如下：
static void HOperatorSet.ReadImage(out HObject image, HTuple fileName) public HImage(HTuple fileName) public HImage(string fileName) void HImage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3388ee2fd9cac67a854a50df5d17e00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd216fdcd6dfaf25099d791ba23a43d/" rel="bookmark">
			黑马点评--用户签到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户签到 BitMap用法签到功能签到统计 BitMap用法：
我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.（布隆过滤器就是采用这种结构）
把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。
Redis是利用string类型数据结构实现BitMap，因此最大上限512M，转换为bit则是2^32个bit位。
BitMap的操作命令有：‘
SETBIT：向指定位置（offset）存入一个0或1
GETBIT：获取指定位置（offset）的bit值
BITCOUNT：统计BitMap中值为1的bit位
BITFIELD：操作（查询，修改，自增）BitMap中bit数组中的指定位置（offset）的值
BITFIELD_RD：获取BitMap中bit数组，并以十进制形式返回
BITOP：将多个BitMap的结果做位运算（与，或，异或）
BITPOS：查找bit数组中指定范围内第一个0或1出现的位置
签到功能
需求：实现签到接口，将当前用户当天签到信息保存到Redis中
提示：因为BitMap底层是基于String数据结构，因此其操作也都封装在字符串相关操作中了。
代码实现
public Result sign() { //1.获取当前登录的用户 Long userId = UserHolder.getUser().getId(); //2.获取日期 LocalDateTime now = LocalDateTime.now(); //3.拼接key String keySuffix = now.format(DateTimeFormatter.ofPattern(":yyyy-MM")); String key=USER_SIGN_KEY+userId+keySuffix; //4.获取今天是本月的第几天 int dayOfMonth = now.getDayOfMonth(); //5.写入Redis SETBIT key offset 1 stringRedisTemplate.opsForValue().setBit(key,dayOfMonth-1,true); return Result.ok(); } 统计连续签到
什么叫连续签到天数？
从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BTQliNoL-1669736765623)(C:\Users\20745\AppData\Roaming\Typora\typora-user-images\image-20221129225245656.png)]
如何得到本月到今天为止的所有签到数据？
BITFELD key GET u[dayOfMonth]0 如何从后向前遍历每一个bit位？
与1做运算，就能得到最后一个bit位
随后右移1位，下一个bit为就成为最后一个bit为。
代码实现：
public Result signCount() { //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bd216fdcd6dfaf25099d791ba23a43d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a79a0c2e1ee2dc8faad8913bcd70a9b/" rel="bookmark">
			RtspServer之LibRtsp解决闪退 新增鉴权（用户名密码登录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程语言：C
目标平台：arm（hi3519）注：因为代码是纯C语言按道理可以移植到各种平台 基础库：librtsp（存在功能补全，有一定的bug） 因为项目需求需要在海思平台实现IPC的全部功能，实现RTSPServer的方案很多，冲浪了github平台发现有很多开源的方案，但是也有一些假开源比如EasyRtspServer（一个平台授权几万米^_^），有一些RtspServer是用C++写的，目前海思的交叉编译工具对C++高版本（大于C++11）支持并不好虽然可以编译过去但是运行的时候会有很多意向不到的问题，这也是本文为什么选用librtsp的原因。
因为以前接触过librtsp，并在海思平台实现了RtspServer（相对来讲还是比较稳定的），但项目需求需要新增鉴权的功能（使用用户名密码登录），翻遍github发现能支持鉴权的开源项目并不多而且多数移植存在兼容性的问题比如前面提到的问题，因此下定决心在librtsp的基础上新增用户名密码鉴权的功能，并修复以前就存在闪退的bug。
1、首先通读代码 主要的代码集中在了rtsp_demo.c和rtsp_msg.c里，demo里主要解决客户端连接和相关消息发送的功能，msg主要封装了协议解析的部分，因此本文的功能新增也都是在这两个文件中处理的。
2、熟悉鉴权协议和信息交互流程 新增鉴权的功能，首先需要了解RTSP协议鉴权的步骤《参见》。
3、抓包分析 3.1、找来海康的摄像头，使用Wireshark抓包工具对鉴权的过程进行分析，如下图
3.2、未通过验证客户端（VLC）的发送和服务器应答如下（海康摄像头应答）
VLC发送
服务器应答如下（海康摄像头） 其中红框内指明了密码加密的方式，目前有两种一种是Digest，MD5加解密，一种是Basic，base64加解密，因为base64相对好实现一些因此本文先采用Basic的验证方式（VLC播放器会自动匹配），当然服务器（相机）可以做两种鉴权方式都支持（接下来再去完善MD5加解密的功能）。
3.3、客户端回复如下（VLC播放器）
3.4、通过以上的抓包分析可知，只需要在librtsp内完善DESCRIBE请求中的验证和解密即可（因为本文先用BASIC即base64加解密）
4、修改代码 4.1、首先在rtsp client结构体内新增passed标志，表明该连接是否通过验证，未通过验证则不发送数据包，如下图
4.2、在rtsp_do_event函数修改发送的地方新增passed判断（数据发送地方很多自行查找，涉及到音频和视频的发送）
4.3、处理DESCRIBE请求
在rtsp_handle_DESCRIBE函数内，新增加解密的功能，如下
4.4、处理完DESCRIBE请求后还有socket的接收和发送的处理，完善authorization的相关处理函数
4.5、base64代码如下 《参考》
static int base64Decode(uint8_t *input) { unsigned int inlen = strlen(input); uint8_t output[1024] = {0}; //解码需要一张反着的表 const char *base64_tbl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; int off = 0; unsigned int i; uint8_t reverse_tbl[256] = {0}; if (NULL == input) { return -1; } if (inlen == 0) { return -2; } uint8_t *p = input; while (isprint(*p) &amp;&amp; *p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a79a0c2e1ee2dc8faad8913bcd70a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89770bafb39c404d8bc0915a770a2524/" rel="bookmark">
			Java之okhttp3请求方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java开发中，发起http请求是非常常见的需求，常用的有HttpClient，下面聊一下okhttp3的请求方式。
1、引入okhttp3依赖
&lt;dependency&gt; &lt;groupId&gt;io.github.admin4j&lt;/groupId&gt; &lt;artifactId&gt;http&lt;/artifactId&gt; &lt;version&gt;0.4.0&lt;/version&gt; &lt;/dependency&gt; 2、提供springboot工程及http接口
@RestController public class HelloController { /** * @description: get请求 */ @GetMapping("/hello") public String hello(@RequestParam String name) { return "hello," + name; } /** * @description: get请求 */ @GetMapping("hello2/{name}") public String hello2(@PathVariable("name") String name) { return "hello2," + name; } /** * @description: post请求 */ @PostMapping("hello3") public String hello3(@RequestBody Map map) { return map.get("name").toString(); } /** * @description: form表单请求 */ @RequestMapping("hello4") public String hello4(@RequestParam Map map) { return map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89770bafb39c404d8bc0915a770a2524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ffcdbe56dee7a13b3a8602b9e31b7e/" rel="bookmark">
			117.Django-缓存redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 ​ 动态网站的基本权衡是，它们是动态的。每次用户请求页面时，Web服务器都会进行各种计算 - 从数据库查询到模板呈现再到业务逻辑 - 以创建站点访问者看到的页面。从处理开销的角度来看，这比标准的文件读取文件系统服务器要耗时多了。对于大多数Web应用程序来说，这种开销并不是什么大问题。因为大多数Web应用程序只是中小型网站，没有拥有一流的流量。但对于中到高流量的站点，尽可能减少开销是至关重要的，这就是缓存的用武之地。缓存某些内容是为了保存昂贵计算的结果，这样就不必在下次执行计算。
​ Django框架带有一个强大的缓存系统，可以保存动态页面，因此不必为每个请求计算它们。Django提供不同级别的缓存粒度：可以缓存特定视图的输出，也可以只缓存页面中难以生成的部分或者可以缓存整个站点。
​ Redis，是一个内存数据库（现在已经支持内存数据持久化到硬盘当中，重新启动时，会自动从硬盘进行加载），由于其性能极高，因此经常作为中间件、缓存使用。
​ 本文档介绍就是Django框架使用Redis数据库来应用缓存框架
2. Windows开发环境下安装并使用Redis 之前已经有学习过在Linux环境下使用Redis，这里就试试看使用Windows
​ redis默认不支持windows，由于一般开发环境在windows，因为需要使用第三方团队维护的windows版本，下载地址：
​ window开发环境使用redis的安装包地址
推荐使用稳定版本
​ 直接减压压缩包，安装好之后，启动redis
​ 启动redis（如果没有配置环境变量，到解压好的文件夹中启用）：
redis-server 连接redis数据库（另开一个终端！！！！）
redis-cli 核心配置，在redis.windows.conf下
绑定IP：如果需要远程访问，可以将此注释，或绑定一个真是IP bind 127.0.0.1 端口：默认为6379 port 6379 日志文件 logfile "Logs/redis_log.txt" 数据库个数 databases 16 基本命令
检测 redis 服务是否启动 PING 设置键值对: set uname baizhan 取出键值对: get uname 删除键值对： del uname 查看所有键值对： keys * 删除所有的键值对 flushall 运行结果：
3. 应用redis缓存 ​ django中应用redis，目前一般使用第三方库 django-redis
​ 安装：pip install django-redis
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ffcdbe56dee7a13b3a8602b9e31b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb779f9ba6c15b54499784ce41b5599/" rel="bookmark">
			【Android App】GPS获取定位经纬度和根据经纬度获取详细地址讲解及实战（附源码和演示 超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要全部代码请点赞关注收藏后评论区留言私信~~~
一、获取定位信息 开启定位相关功能只是将定位的前提条件准备好，若想获得手机当前所处的位置信息，还要依靠下列的3种定位工具。
（1）定位条件器Criteria 定位条件器用于设置定位的前提条件，比如精度、速度、海拔、方位等。 （2）定位管理器LocationManager 定位管理器用于获取定位信息的提供者、设置监听器，并获取最近一次的位置信息。
（3）定位监听器LocationListener 定位监听器用于监听定位信息的变化事件。
定位管理器的常用方法如下。 getBestProvider：获取最佳的定位提供者。
isProviderEnabled：判断指定的定位提供者是否可用。
getLastKnownLocation：获取最近一次的定位地点。
requestLocationUpdates：设置定位监听器。
removeUpdates：移除定位监听器。
addGpsStatusListener：添加定位状态的监听器。
removeGpsStatusListener：移除定位状态的监听器。
registerGnssStatusCallback：注册全球导航卫星系统的状态监听器。 unregisterGnssStatusCallback：注销全球导航卫星系统的状态监听器。
实战效果如下
可知定位的精确度还是比较高的，但是给出的是经纬度还是有点不够直观，下面我们把经纬度转换成具体的地址
代码如下
Java类 package com.example.location; import android.Manifest; import android.annotation.SuppressLint; import android.content.Context; import android.content.pm.PackageManager; import android.location.Criteria; import android.location.Location; import android.location.LocationListener; import android.location.LocationManager; import android.os.Bundle; import android.os.Handler; import android.os.Looper; import android.util.Log; import android.widget.TextView; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.ActivityCompat; import com.example.location.util.DateUtil; import com.example.location.util.SwitchUtil; import java.util.HashMap; import java.util.Map; @SuppressLint(value={"DefaultLocale","SetTextI18n"}) public class LocationBeginActivity extends AppCompatActivity { private final static String TAG = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb779f9ba6c15b54499784ce41b5599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a80bb770a4f14d0da1d7463ed42d74b/" rel="bookmark">
			Linux系统的 vmware 虚拟机扩展 磁盘容量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关闭虚拟机
2、点击“编辑虚拟机设置”——&gt;"磁盘" ——&gt;"扩展"，输入扩展后的大小，然后点击“扩展”，完成后点击“确定”即可；
3、安装gparted
sudo apt-get install gparted
4、在终端中执行gprated即可 gprated控制界面：
5、点击要扩展的盘“/dev/sda2”,设置“free space folloeing” 为 “0”，即把所有剩余大小全扩展至此盘
6、完成后点击“Resize/Move” ,即可看到 “/dev/sda2”的大小已扩展
7、同样此操作，扩展 “/dev/sda2”的根路径大小 8、完成后点击“✔" 即可
9、查看 df -h即可查看此盘大小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc3167bc35d2306ae0dd767598cc21d/" rel="bookmark">
			java23种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单例模式 单例模式一共有8种，除了常见的饿汉式，懒汉式，还有双重检查（实际开发中推荐使用）,静态内部类
1、双重检查 voliated和 synchronized 的组合使用（推荐使用） volatile：多个线程拿到一个共享变量，如果一个线程改变了共享变量里面的值，则其他的线程的共享变量的值也发生改变
例子:
package voliteaed; /** * &lt;简述&gt; * &lt;详细描述&gt; * * @author LiuShanshan * @version $Id$ */ public class Singleton { private static volatile Singleton singleton; private Singleton(){ } public static Singleton getInstance(){ if(singleton == null){ synchronized (Singleton.class){ if(singleton == null){ singleton = new Singleton(); } } } return singleton; } } 线程安全；延迟加载；效率较高
2、静态内部类(推荐使用，jvm帮我们控制线程安全) package voliteaed; /** 静态内部类 * &lt;简述&gt; * &lt;详细描述&gt; * * @author LiuShanshan * @version $Id$ */ public class StaticSingleton { public static void main(String[] args) { SingletonDemo1 instance = SingletonDemo1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcc3167bc35d2306ae0dd767598cc21d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e1cf108d89031a69ecf90ffdcec4e1/" rel="bookmark">
			详解 Spring Boot 项目中的配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. Spring Boot 项目中配日文件的作用是什么
2. Spring Boot 配置文件的两种格式
3. properties 配置文件
3.1 properties 配置文件的基本语法
3.2 properties 配置文件的分类
3.3 如何读取配置文件
3.4 properties 配置文件的优缺点分析
4. yml 配置文件
4.1 yml 的基本语法
4.2 yml 配置文件的优点
4.3 yml 配置基本数据类型
4.4 yml 配置对象
4.5 yml 读取对象
4.6 yml 配置集合
5. 设置多平台的配置文件
1. Spring Boot 项目中配日文件的作用是什么 配置文件中最主要的两个作用: 连接数据库和用于定位问题的关键日志.
一个项目中没有数据库的话那就谈不上一个完整的项目,假如今天王者出新皮肤了, 你心智勃勃花了一千多块钱买了好几款喜欢的皮肤, 没有数据库的话, 过两天你上线发现皮肤没了, 你心里肯定有一万只 XXX 奔腾而过. 如果没有配置文件 , 程序出问题, 很难查找时, 都无法定位到关键日志, 所以配置文件还是相当的重要的.
配置文件的作用:
连接数据库的信息用于发现和定位问题的关键日志设置项目的启动端口第三方系统的调用密钥等信息 (例如老师在某平台给我们上课时, 他能在平台上拿到我们的数据, 就是通过配置文件中设置的标识来调用第三方接口获取的) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e1cf108d89031a69ecf90ffdcec4e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c4a70fdee89f17a179c9588385b586/" rel="bookmark">
			[附源码]Python计算机毕业设计Django仓库管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Pychram社区版+ python3.7.7 + Mysql5.7 + HBuilderX+list pip+Navicat11+Django+nodejs。
项目技术：
django + python+ Vue 等等组成，B/S模式 +pychram管理等等。
环境需要
1.运行环境：最好是python3.7.7，我们在这个版本上开发的。其他版本理论上也可以。
2.pycharm环境：pycharm都可以。推荐pycharm社区版;
3.mysql环境：建议是用5.7版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
6.Navcat11：这个版本不限10/11/14/15都可以。；
python毕设帮助，指导，本源码(见文末)，调试部署
5 系统详细设计 5. 1 管理员功能模块 管理员登录，管理员通过输入用户名、密码、选择角色等信息，然后点击登录就能登录到系统进行系统的使用了，如图5-1所示。
图5-1管理员登录界面图
管理员登录进入系统之后，就可以对所有的信息进行查看，可以查看到首页、个人中心、物品分类管理、仓库信息管理、入库信息管理、出库信息管理、清点信息管理、普通管理员管理等，并且还可以对其进行相应的操作管理，如图5-2所示。
图5-2管理员功能界面图
物品分类管理，在物品分类管理页面中可以对索引、物品分类等信息进行详情、修改或删除等操作，如图5-3所示。
图5-3物品分类管理界面图
仓库信息管理，在仓库信息管理页面中可以对索引、物品编号、物品名称、物品分类、数量、存放位置、登记时间等信息进行详情、修改或删除等操作，如图5-4所示。
图5-4仓库信息管理界面图
入库信息管理，在入库信息管理页面中可以对索引、物品编号、物品名称、物品分类、数量、登记时间等信息进行详情、删除等操作，如图5-5所示。
图5-5入库信息管理界面图
出库信息管理，在出库信息管理页面中可以对索引、物品编号、物品名称、物品分类、数量、登记时间等信息进行详情、删除等操作，如图5-6所示。
图5-6出库信息管理界面图
清点信息管理，在清点信息管理页面中可以对索引、物品编号、物品名称、物品分类、清单数量、登记时间等信息进行详情、删除等操作，如图5-7所示。
图5-7清点信息管理界面图
普通管理员管理，在普通管理员管理页面中可以对索引、管理员账号、管理员姓名、性别、联系电话等信息进行详情、删除等操作，如图5-8所示。
图5-8普通管理员管理界面图
5.2 普通管理员功能模块 普通管理员注册，在普通管理员注册页面中通过填写管理员账号、管理员姓名、密码、联系电话等信息完成普通管理员注册，如图5-9所示。
图5-9普通管理员注册界面图
普通管理员登录进入系统后台可以查看首页、个人中心、物品分类管理、仓库信息管理、入库信息管理、出库信息管理、清点信息管理等信息进行详细操作，如图5-10所示。
图5-10普通管理员功能界面图
物品分类管理，在物品分类管理页面中可以对索引、物品分类等信息进行详情、修改或删除等操作，如图5-11所示。
图5-11物品分类管理界面图
仓库信息管理，在仓库信息管理页面中可以对索引、物品编号、物品名称、物品分类、数量、存放位置、登记时间等信息进行详情、入库、出库、清点、修改或删除等操作，如图5-12所示。
图5-12仓库信息管理界面图
入库信息管理，在入库信息管理页面中可以对索引、物品编号、物品名称、物品分类、数量、登记时间等信息进行详情、删除等操作，如图5-13所示。
图5-13入库信息管理界面图
出库信息管理，在出库信息管理页面中可以对索引、物品编号、物品名称、物品分类、数量、登记时间等信息进行详情、删除等操作，如图5-14所示。
图5-14出库信息管理界面图
清点信息管理，在清点信息管理页面中可以对索引、物品编号、物品名称、物品分类、清单数量、登记时间等信息进行详情、删除等操作，如图5-15所示。
图5-15清点信息管理界面图
python毕设帮助，指导，源码获取，调试部署
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a2f55b76899e527f3c163c53f4bba3/" rel="bookmark">
			基于 vue3 利用 vuex 状态控制路由和按钮的权限 - 路由权限（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3-router-permission 基于 vue3 利用 vuex 状态控制路由和按钮的权限 - 路由权限（2）
gitee: vue3-router-permission
新建本地存储 src -&gt; utils -&gt; localDb.js
const localdb = { get(key) { return JSON.parse(localStorage.getItem(key)) }, set(key, value) { localStorage.setItem(key, JSON.stringify(value)) }, remove(key) { localStorage.removeItem(key) }, clear() { localStorage.clear() }, } export default localdb 新建 vuex 状态管理 新建文件夹 和 文件
- src - store - modules - account.js - index.ts account.ts
import localDb from '../../utils/localDb' export default { namespaced: true, state: { userInfo: localDb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a2f55b76899e527f3c163c53f4bba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c842cb798ebeaa11b452e87ac0c8dcf/" rel="bookmark">
			torch-geometric使用过程中的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这次记录自己在使用torch-geometric时，出现的各种问题： 1. 安装问题： Python 3.8torch-geometric 1.6.1pytorch 1.6.0pandas 1.0.5numpy 1.18.5 这里使用的各个版本依赖包如上所述。
（1）安装好torch，注意自己显卡版本，我用的是cpu版本，在官网可以直接复制命令安装。 （2）建立自己的Anaconda虚拟环境，并激活环境开始准备安装。 （3）依次安装torch-cluster、pytorch-scatter、torch-sparse、pytorch-spline-conv依赖库，没有这四个库是万万不行的，无法继续安装torch-geometric，可以从这个链接进入https://pytorch-geometric.com/whl/index.html，找到自己torch对应的版本，这个地方注意，各个版本依赖性还是比较强的，若此时版本出现问题，版本由于依赖性后期会出现各种bug。 torch-geometric 1.6.1对应的四个版本的依赖包已经上传到本人账号的免费资源，需要的可自行下载。 （4）可以直接将四个whl文件复制到自己创建的虚拟conda环境下的Scripts文件夹下，这样激活环境后可以直接pip安装。 例如：pip install torch_cluster-1.5.9-cp38-cp38-win_amd64.whl 注意安装的路径，保证命令能找到当前文件。 （5）安装好四个依赖包后，下面就可以继续安装geometric，pip install torch-geometric==？问好处记得写入自己需要的版本，否则默认最新版。 2. bug调试与注意事项： （1）使用pycharm的最好是使用conda命令，管理员身份运行Anaconda prompt，激活自己的虚拟环境，conda list看一下当前环境下所有的安装包的版本。pycharm有时候并不怎么好用，并且重启一下有些问题也会解决，所以配置环境建议使用conda。 （2）电脑中如果有其他python版本的，又用的pycharm编译器的，建议直接使用Anaconda，并在（1）所列方法下下载安装。 （3） ImportError: numpy.core.multiarray failed to import试着降低一下numpy版本，如果不行，试着降低一下matplotlib版本。 （4）cmd命令下，有可能会报numpy版本冲突的错误，那就是python的和Anaconda的冲突了应该是，检查一下版本问题和包的安装问题。 （5）[Errno 13] Permission denied: 权限问题，在pip install后面加上--user即可，使用（1）的管理员身份运行也可能会避免该问题。 （6）torch、numpy、matplotlib、pandas在这其中，彼此都有很强的依赖性，所以随时每次安装和卸载其中一个都要看一下其他的版本是否有被自动修改或者连带升级等问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88edaa677232e10593e55cc100c9212/" rel="bookmark">
			动态路由协议——OSPF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态路由协议 静态路由的缺点在于无法适应网络中的各种变化，每一条路由都是管理员自己手动配置的。
动态路由协议的基本原理不像静态路由那样，它的基本原理就是各个路由器之间通过交互某种报文信息，这种报文中包含了很多自身路由器的信息。这些路由通过报文就可以知道整个网络的情况，当网络中的某些设备发生故障时，这些路由器也会通过这种报文获取得到，从而进行某种算法重新的计算出一个可用的网络。
OSPF——链路状态路由协议 ospf（开放式最短路径优先）是一个基于链路状态的内部网关协议。
目前针对IPv4协议使用的是OSPF Version 2（RFC2328）；针对IPv6协议使用OSPF Version 3（RFC2740）
运行OSPF路由器之间交互的是LS（Link State，链路状态）信息，而不是直接交互路由。LS信息是OSPF能够正常进行拓扑及路由计算的关键信息。
OSPF路由器将网络中的LS信息收集起来，存储在LSDB中。路由器都清楚区域内的网络拓扑结构，这有助于路由器计算无环路径。
每台OSPF路由器都采用SPF算法计算达到目的地的最短路径。路由器依据这些路径形成路由加载到路由表中。 基本术语 区域 OSPF Area用于标识一个OSPF的区域。
区域是从逻辑上将设备划分为不同的组，每个组用区域号（Area ID）来标识。
RouteID Router-ID（Router Identifier，路由器标识符），用于在一个OSPF域中唯一地标识一台路由器。
度量值 OSPF使用Cost（开销）作为路由的度量值。每一个激活了OSPF的接口都会维护一个接口Cost值。 报文协议 报文作用Hello周期性发送，用来发现和维护OSPF邻居关系。Datebase Description描述本地LSDB的摘要信息，用于两台设备进行数据库同步。LinkState Request用于向对方请求所需要的LSA。设备只有在OSPF邻居双方成功交换DD报文，后才会向对方发出LSR报文。Link StateUpdate用于向对方发送其所需要的LSA。Link State ACK用来对收到的LSA进行确认。 三大表项 邻居表 OSPF在传递链路状态信息之前，需先建立OSPF邻居关系。
OSPF的邻居关系通过交互Hello报文建立。
OSPF邻居表显示了OSPF路由器之间的邻居状态，使用display osp fpeer查看。
LSDB表 LSDB会保存自己产生的及从邻居收到的LSA信息
使用命令行display ospf lsdb查看LSDB表。
Type标识LSA的类型，AdvRouter标识发送LSA的路由器。
OSPF路由表 OSPF路由表和路由器路由表是两张不同的表项。
OSPF路由表包含Destination、Cost和NextHop等指导转发的信息。
使用命令display ospfrouting查看OSPF路由表。
工作原理 DR和BDR 在MA网络中，如果每台OSPF路由器都与其他的所有路由器建立OSPF邻接关系，便会导致网络中存在过多的OSPF邻接关系，增加设备负担，也增加了网络中泛洪的OSPF报文数量。
当拓扑出现变更，网络中的LSA泛洪可能会造成带宽的浪费和设备资源的损耗。
为优化MA网络中OSPF邻接关系，OSPF指定了三种OSPF路由器身份，DR（Designated Router，指定路由器）、BDR（Backup Designated Router，备用指定路由器）和DRother路由器。
只允许DR、BDR与其他OSPF路由器建立邻接关系。DRother之间不会建立全毗邻的OSPF邻接关系，双方停滞在2-way状态。
BDR会监控DR的状态，并在当前DR发生故障时接替其角色。
OSPF单区域和多区域 OSPF路由器在同一个区域（Area）内网络中泛洪LSA。如果OSPF域仅有一个区域，随着网络规模越来越大，OSPF路由器
的数量越来越多，这将导致诸多问题：
LSDB越来越庞大，同时导致OSPF路由表规模增加。路由器资源消耗多，设备性能下降，影响数据转发。
基于庞大的LSDB进行路由计算变得困难。
当网络拓扑变更时，LSA全域泛洪和全网SPF重计算带来巨大负担。
OSPF引入区域（Area）的概念，将一个OSPF域划分成多个区域，可以使OSPF支撑更大规模组网。
OSPF多区域的设计减小了LSA泛洪的范围，有效的把拓扑变化的影响控制在区域内，达到网络优化的目的。
OSPF路由器根据其位置或功能不同，有这样几种类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f88edaa677232e10593e55cc100c9212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14cb3120bc67f5efe014574e4a6dc1ec/" rel="bookmark">
			JWT在线解码网址和结构介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JWT介绍 JWT简介JWT 概念JWT 优点 JWT 在线解码工具JWT 结构解析1.Header2.Payload3.Signature 写在最后 JWT简介 JWT 概念 JWT 全称为 JSON Web Token是目前最流行的跨域认证解决方案，官网地址链接，
JWT 优点 基于token的认证方式相比传统的session认证方式能够解决移动端和分布式开发中跨域问题，具有下列优点：
减少服务器压力：服务端不需要存储session信息，token可以携带登录用户服务器所需信息支持跨域访问：将token放到请求头中，就不需要cookie存储信息，所以跨域后不会因为cookie是无法跨域而导致信息丢失更适用于移动端：当客户端是非浏览器平台时或者cookie被禁止时，采用token认证方式会简单很多更适用CDN：可以通过内容分发网络请求服务端的所有资料无需考虑CSRF：由于不再依赖cookie，所以采用token认证方式不会发生CSRF，所以也就无需考虑CSRF的防御 JWT 在线解码工具 这个解码工具只能解析Base64编码后的header以及Payload部分，对于加密的Signature部分是无法解密的只有服务器端使用secretKey进行解密才能知道具体的内容。
JWT在线解码工具入口
JWT 结构解析 JWT由3部分组成：标头(Header)，有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的三个部分分别进行Base64编码后，拼接成最终传输的字符串，也就是我们的Json Web Token。
JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret) header和payload可以直接利用base64解码出原文，从header中获取哈希签名的算法，从payload中获取有效数据
signature由于使用了不可逆的加密算法，无法解码出原文，它的作用是校验token有没有被篡改。服务端获取header中的加密算法之后，利用该算法加上secretKey对header、payload进行加密，比对加密后的数据和客户端发送过来的是否一致，注意其中secretKey只能保存在服务端，以保证数据的安全性。
1.Header JWT头是一个描述JWT元数据的JSON对象，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存
{ "alg": "HS256", "typ": "JWT" } 2.Payload 有效载荷部分，JWT主体内容部分，是一个包含需要传递数据的JSON对象。 其中有七个默认字段供选择。
{ "iss"：发行人 "exp"：到期时间 "sub"：主题 "aud"：用户 "nbf"：在此之前不可用 "iat"：发布时间 "jti"：JWT ID用于标识该JWT } 以上默认字段并不要求强制使用。我们还可以自定义私有字段，一般会把包含用户信息的非保密数据放到payload中。
{ "admin_id": "93b5909c927c235ed5f9ee655e0e01abf988f5ebaeff4788542fde9573d79f3b4556c462b332493d2d34c7421dca804bf407dcf51815671cf8ce832165296441e3ca9b42ddc00a7e4914bbc536e1cec84afa6c61785c27b597b492de60baff8f", "merchant_id": "93b5909c927c235ed5f9ee655e0e01abf988f5ebaeff4788542fde9573d79f3b4556c462b332493d2d34c7421dca804bf407dcf51815671cf8ce832165296441e3ca9b42ddc00a7e4914bbc536e1cec84afa6c61785c27b597b492de60baff8f" } 注意：默认情况下JWT是未加密的，只是采用base64算法，拿到JWT字符串后可以转换回原本的JSON数据，任何人都可以解读其内容，因此不要构建隐私信息字段，比如用户的密码一定不能保存到JWT中，以防止信息泄露。JWT只是适合在网络中传输一些非敏感的信息
3.Signature 签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以确保数据不会被篡改。首先，需要指定一个密钥（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名
HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret) 写在最后 JWT作为现在主流的验证方式，在各种语言中都有着对应使用方法，还是十分值得研究学习的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e8fd0f0f333d7d0a6c9eedff1b3f2d/" rel="bookmark">
			腾讯云开源项目Crane成FinOps首个认证降本增效开源方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚刚，腾讯云开源项目 Crane(Cloud Resource Analytics and Economics)正式成为FinOps认证解决方案（FinOps Certified Solutions）。作为全球范围内首个开源的FinOps认证解决方案，Crane能够助力云原生用户充分发挥云上资源的最大价值，帮助企业降本增效。
据了解，为推进云原生用户在确保业务稳定性的基础上做到真正的极致降本，腾讯云率先在国内推出了第一个基于云原生技术的成本优化开源项目 Crane。Crane 遵循 FinOps 标准，旨在为云原生用户提供云成本优化一站式解决方案，也是全球范围内首个纯开源、免费的应用于云原生领域降本增效的解决方案。
在 Crane 之前，FinOps 社区主要看重的是云成本的可视化问题，重点关注在问题的发现上面，然后通过机型的选择、计费类型的调优等运营手段实现降本。而 Crane 依托于云原生技术，结合监控预测、调度增强、业务混部等多项硬核科技，将优化措施应用到了云成本优化的多个关键环节，从而辅助用户决策、简化运维效率、提升系统稳态、全面降本增效。
值得一提的是今年9月15日，中国电子技术节能协会2022年“云计算中心科技奖”正式颁布，腾讯云Crane荣获“云计算中心科技奖卓越奖”，成为国内首个获得该国家级奖项的云原生解决方案。
目前，Crane并已经被腾讯、小红书、网易、思必驰、酷家乐、明源云、数数科技等公司部署在生产系统，其主要贡献者来自腾讯、小红书、谷歌、eBay、微软、特斯拉等知名公司。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d1716cfc6ea227080e0450daaabc06/" rel="bookmark">
			Java的小题目练习。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目
小明去超市买东西，带多少钱自己输入，书12元一本，铅笔1元一支，橡皮2元一块，可乐3元一瓶，零食5元一包。
小明必须要买一本书，买了书还剩多少钱，剩下的钱如果买其他的东西能买多少，还剩多少钱。
首先理一下思路：1，要给商品定价格。2，要问他有多少钱。3，如果刚好够买一本书，就说刚好买一本书。4，如果带的钱不够买一本书，就说带的钱不够买书。5，带的钱多了，剩下的钱可以买多少铅笔、橡皮、可乐、零食。
主要运用了if 格式。
接下来就是代码了。
package com; import java.util.Scanner; public class xiaoming { public static void main(String[] args) { Scanner sc = new Scanner(System.in); double book = 12; double qianbi = 1; double xiangpi = 2; double kele = 3; double linshi = 5; System.out.println("超市商品价格如下"); System.out.println("书本：" + book + "元"); System.out.println("铅笔；" + qianbi + "元"); System.out.println("橡皮：" + xiangpi + "元"); System.out.println("可乐" + kele + "元"); System.out.println("零食" + linshi + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82d1716cfc6ea227080e0450daaabc06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6d0b5a6549ede7a9d0cf23db499159/" rel="bookmark">
			JDBC连接Mysql数据库步骤(Mysql8.0以上)以及 MySql数据库连接时DriverManager.getConnection（url，user，pass）出错 解决在文章末尾请耐心观看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近我们学到JSP数据库应用开发，在运行程序时遇到了一些问题，我们先看JDBC连接Mysql数据库步骤。
1.加载JDBC驱动程序
通过forName（String className)实现
MySQL数据库的驱动为：
String driverClass="com.mysql.jdbc.Driver";
连接MySQL数据库需要用到的包为:
mysql-connector-java-5.1.20-bin.jar
引用jar包的方法，直接下载jar包（注意不需要解压）
1.我们直接把他拖到WEB-INF下的lib下即可，或者复制粘贴到WEB-INF下的lib下。
2.右键单击jar包、点击Bulid Path、再点击Add to Bulud Path
之后会有这个红框里的，代表引入成功。
注意这里我就遇到了问题，因为老师讲课时使用的是mysql5.5版本的，我在学习mysql时是在官网下载的mysql8.0，没想到学完mysql还要再次用到，老师发给我们的是mysql-connector-java-5.1.20-bin.jar的jar包。在连接数据库时报错了，如下图所示：
我在网上查了一下，是mysql8.0在获取密码是好象有所改动，
5.0.X版本与8.0.X版本的区别
1. 5.0.X版本连接的驱动地址为："com.mysql.jdbc.Driver"，而8.0.X版本的更改为："com.mysql.cj.jdbc.Driver"
2. 建立连接时url增加了一些参数： 5.0.X版本的url为String url = "jdbc:mysql://localhost:3306/information"
而8.0.X版本的需要在后面加上一串字母变为：String url = jdbc:mysql://local:3306/information
?&amp;useSSL=false&amp;serverTimezone=UTC"
例如我的数据库名字叫做"information"，也不用管为什么，就是把编码格式，身份验证，时区改改，8.0.X版本要求的就是这么多。
原文链接：https://blog.csdn.net/sinat_41721615/article/details/84346249
这个问题一直没解决（利用以上方法就可以解决了），所以我找了一个笨办法，就是又下载了一个mysql5.5，最后是可以运行出结果的。
连接mysql数据库的URL为：
String url="jdbc:mysql://localhost:3307/information";
information为你创建的数据库的名字,student 为你创建的表的名字。
还有3307为数据库的端口号（这个为我又下载的mysql5.5版本自定义的端口号），3306为mysql数据库默认的端口号。
2.创建数据库连接
通过调用DriverManager.getConnection(url, username, password);建立连接，三个入口参数依次为要连接数据库的路径、用户名和密码，该防范的返回值类型为java.sql.Connection。
String url="jdbc:mysql://127.0.0.13306/information";
url为主要通信协议 :mysql为次要通信协议 ://127.0.0.1 3306（也可以换成localhost:3306）
"127.0.0.1"为数据库所在机器的IP的地址，该IP代表本机。 information为你要连接的数据库的名字
String url="jdbc:mysql://localhost:3307/information";
String username="root";
String password="123456";
3.执行SQL语句
Statement stmt=conn.createStatement();
ResultSet rs=stmt.executeQuery("select * from student");
我用的是Navicat ，依次创建information数据库，student表，表里字段的的类型为学号 char、姓名 varchar、性别 char、年龄 int
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a6d0b5a6549ede7a9d0cf23db499159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a8a79d927eb4cbe07a026815c1b01f9/" rel="bookmark">
			Ubuntu22.04 安装深度微信报错 依赖: libsasl2-2 (＞= 2.1.27.1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现象：
(base) pang@pang-HP:$ sudo apt-get install com.qq.weixin.deepin 正在读取软件包列表... 完成 正在分析软件包的依赖关系树... 完成 正在读取状态信息... 完成 有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是 因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件 包尚未被创建或是它们已被从新到(Incoming)目录移出。 下列信息可能会对解决问题有所帮助： 下列软件包有未满足的依赖关系： libldap-2.4-2 : 依赖: libsasl2-2 (&gt;= 2.1.27.1) 但是 2.1.27+dfsg2-3ubuntu1 正要被安装 E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。 (base) pang@pang-HP:$ 原因：怀疑是Ubuntu22.04缺少包的原因
解决：参考ISSUES-310说明，去http://mirrors.163.com/ubuntu/pool/main/c/cyrus-sasl2/下载libsasl2-2_2.1.28+dfsg-6ubuntu2_i386.deb和libsasl2-modules-db_2.1.28+dfsg-6ubuntu2_i386.deb
安装：
sudo dpkg -i libsasl2-2_2.1.28+dfsg-6ubuntu2_i386.deb libsasl2-modules-db_2.1.28+dfsg-6ubuntu2_i386.deb 然后在安装:
sudo apt-get install com.qq.weixin.deepin 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e661b5d1eadb252c668fd95417465dc/" rel="bookmark">
			Linux学习之安装CentOS7-Mac版&#43;避坑指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021款MacBook M1 pro安装CentOS7虚拟机+避坑指南 前言一、准备VMware Fusion 13虚拟机1.下载安装2.激活3.启动VMware Fusion 13 二、准备CentOS7镜像官网下载镜像（1. 打开官网，点击Download；2. 选择ARM64版本；3. 选择清华大学的镜像下载地址；4. 点击【CentOS-7-aarch64-Everything-2009.iso】，开始下载； 三、配置CentOS7虚拟机1. 启动VMware Fusion 13，选择从光盘或映像中安装2. 选择刚刚下载或配置好的镜像3. 选择操作系统，选最后一个4. 选择存储位置5. 关机，更改设置6. 配置内存、硬盘、网络7. 配置完成后，安装系统8. 语言选择，作为小白，选择了中文9. 安装信息设置，安装目的地-默认，软件选择-带GUI的服务器，时间和日期-亚洲上海，根密码-设置密码，创建用户-创建登陆用户10. 安装完成，重启系统11. 初始设置，进入系统12. 启动成功！ 总结 前言 Linux学习之前，需要先准备一个Linux环境，可以是一台装有Linux系统的电脑(退役下来的Win10，可以安装双系统)，也可以购买一台云服务器。为了方便携带，同时也为了能在断网的环境下使用，我选择安装一个Linux虚拟机。下面是我在MacBook pro上安装CentOS7的过程，相关资源均从官网下载，适用于大多数苹果电脑，作为记录和参考。
一、准备VMware Fusion 13虚拟机 写在前面：
安装过程中，如果打开dmg文件时闪退，查看解决方案。
1.下载安装 官网地址：VMware Fusion 13下载
2.激活 网上序列号：查看序列号
3.启动VMware Fusion 13 复制序号就可以安装了，安装激活过程比较简单，完成后启动软件。
二、准备CentOS7镜像 写在前面：
安装过程中，如果是M1芯片，使用官网下载的CentOS7镜像创建虚拟机，会在安装系统时出现点击Install CentOS 7无反应的情况，请参考以下方法：
1.Apple社区解决方案（推荐）；
2.替换镜像文件（推荐）；
3.调整CentOS官网下载的镜像（比较麻烦）；
官网下载镜像（ 1. 打开官网，点击Download； 官网地址：CentOS7下载
2. 选择ARM64版本； 3. 选择清华大学的镜像下载地址； 4. 点击【CentOS-7-aarch64-Everything-2009.iso】，开始下载； 三、配置CentOS7虚拟机 如果上面将VMware Fusion 13设置为英文，此处可还原为中文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e661b5d1eadb252c668fd95417465dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc64d2c611324f699ff0b91b85cc632/" rel="bookmark">
			BurpSuite官方实验室之逻辑漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BurpSuite官方实验室之逻辑漏洞 这是BurpSuit官方的实验室靶场，以下将记录个人逻辑漏洞共11个Lab的通关过程
Web Security Academy: Free Online Training from PortSwigger
lab1： Excessive trust in client-side controls
过度信任客户端控件
目标是买一件Lightweight “l33t” Leather Jacket，给了账号和密码账户wiener:peter
登录后账号只有100美金但购买的商品是1337美金，直接购买会提示余额不足。
查看了apply和place order的请求包并不存在相关的金额数量参数
重新将商品加入购物车拦截请求包
请求包如下
猜测price为金额字段进行修改，修改为0和0.1失败，修改为1成功加入购物车，金额为0.01美元
成功提交订单
lab2： High-level logic vulnerability
高级逻辑漏洞
目标同样是买一件Lightweight “l33t” Leather Jacket
同样拦截加入购物车的请求包，发现没了price只能更改数量
加入另一个商品，抓包更改请求quantity属性为-20
总价为负数提交失败，增加到正数
购买成功
lab3： Inconsistent security controls
不一致的安全控制
目标到管理后台删除Carlos用户
在target=&gt;site map
可以线程数设置大一点，扫的有点慢
也可以用脚本，扫到存在/admin的路径
尝试访问/admin,访问失败说只有DontWannaCry用户才能访问这个界面
这个DontWannaCry是什么鬼，进入注册页面给了提示，使用@dontwannacry.com的邮箱地址就可以了
用@dontwannacry.com结尾的邮箱注册失败
在email client界面找到了我们的邮箱
格式为
@exploit-0a98002904e66735c1014106016d00d1.exploit-server.net 注册一个
tpaer@exploit-0a98002904e66735c1014106016d00d1.exploit-server.net 找到响应的link
访问url注册成功
登录来到如下页面
直接把邮箱后缀修改为@dontwannacry.com结尾，成功多出Admin pannel
删除Carlos用户成功通关
lab4： Flawed enforcement of business rules
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cc64d2c611324f699ff0b91b85cc632/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80356b286294b21ab1184a1f3801330/" rel="bookmark">
			水晶报表示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List item private void Form_PrintOrder_Load(object sender, EventArgs e) { CreateDataTable(); ReportDocument doc = new ReportDocument(); string str = Application.StartupPath.ToString(); int strLenth = Application.StartupPath.Length; int strSite = Application.StartupPath.LastIndexOf("\\"); string strSubstr = Application.StartupPath.Substring(0, Application.StartupPath.LastIndexOf("\\")); string strPath = Application.StartupPath.Substring( 0, Application.StartupPath.Substring(0, Application.StartupPath.LastIndexOf("\\")).LastIndexOf("\\") ); //计算报表路径 strPath += @"\CrystalReport1.rpt"; //添加报表名称 doc.Load(strPath); doc.SetDataSource(table); // 设置数据源 this.crystalReportViewer1.ShowCloseButton = false; this.crystalReportViewer1.ShowGroupTreeButton = false; this.crystalReportViewer1.ShowParameterPanelButton = false; this.crystalReportViewer1.ShowLogo = false; this.crystalReportViewer1.DisplayBackgroundEdge = false; this.crystalReportViewer1.ToolPanelView = CrystalDecisions.Windows.Forms.ToolPanelViewType.None; //TextObject to = (TextObject)doc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80356b286294b21ab1184a1f3801330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc853fdc44837dc02c97bc82c3dca6a/" rel="bookmark">
			【头歌】神经网络学习之机器学习基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：机器学习类型 1、下列说法错误的的是 A、监督学习不需要一定量级的数据作为训练数据。 B、监督学习可以根据输出类型分为回归和分类两种类型。 C、强化学习不需要训练数据。 D、非监督学习的结果具有不确定性。 【答案】AC 2、下列关于回归和分类问题的说法错误的是： A、回归问题的输出y为离散的类别标记或者数值。 B、分类问题的主要手段为概率计算。 C、支持向量机解决的是回归问题。 D、回归问题以距离计算为主。 【答案】ACD 第2关：激活函数 import numpy as np class ActivationFunction(object): def sigmoid(self,x): """ Sigmoid 函数 :param x: 函数的输入，类型为list :return: y, 函数的计算结果 """ ########## Begin ########## y =1/(1+(np.exp((-x)))) ########## End ########## return y def tanh(self,x): """ Tanh 函数 :param x: 函数的输入，类型为list :return: y, 函数的计算结果 """ ########## Begin ########## y = (np.exp(x)-np.exp(-x))/(np.exp(x)+np.exp(-x)) ########## End ########## return y def ReLU(self,x): """ ReLU 函数 :param x: 函数的输入，类型为list :return: y, 函数的计算结果 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cc853fdc44837dc02c97bc82c3dca6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4383699124fe82f574d3279797a07f/" rel="bookmark">
			操作无法完成，因为已在Windows资源管理器中打开。（YunShellExtV164.dll文件无法删除）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为在电脑上来回安装卸载百度网盘，导致有些文件没有卸载干净，在安装路径里会留下一个dll文件怎么删都删除不掉，会显示操作无法完成，因为已在Windows资源管理器中打开。
这种情况下重启是没有用的，重启之后还是删除不了，这时候我们应该怎么办呢？
1、首先找到该文件所在的位置，例如我之前是把百度网盘安装在D盘里，所以没卸载干净的dll文件也在此路径中。
2、我们要打开任务管理器，选择性能那一栏，最下面有一个打开资源监视器，在资源监视器的CPU哪一栏中找到explorer.exe的文件，右键结束任务。这时候电脑桌面会消失变白，任务栏也不见了，不用担心，后面会操作变回来的。
3、在任务管理器界面，选择文件栏，点击运行新任务，这时候会进入新建任务界面。
4、进入新建任务，输入cmd，勾选以系统管理权限创建此任务。如果不勾选的话，后面删除的过程中会出现访问被拒的情况。界面，
5、点击确定，进入如下界面。
由于dll文件是在D盘中，所以按照以下顺序输入路径，输入“D:”进入D盘，输入“cd ”是进入所选的文件目录中，输入“del ”是删除所选择的文件目录，删除成功后会出现下图所示的界面。这时，dll文件便被删除了。注意如果在第4步中没有勾选以系统管理权限创建此任务，那么在del命令后会出现访问被拒的情况，从而删除失败。
6、删除完毕后，在任务管理器的文件栏运行新任务（同步骤3），输入explorer.exe，取消勾选。这时步骤2中电脑桌面和任务栏消失的情况就会恢复，电脑恢复正常，dll文件也被删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c8dbec736fce8d3604a9b76308b0e0e/" rel="bookmark">
			华为虚拟局域网VLAN技术及其配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 什么是VLANVLAN的原理VLAN的帧格式接口类型接口处理VLAN数据的方式access端口处理数据的方式trunk端口处理数据的方式hybrid端口处理数据的方式 基本配置命令 什么是VLAN vlan即虚拟局域网技术，作用是将物理的局域网在逻辑上划分为多个广播域的技术。
VLAN的原理 1、同一个VLAN内的主机共享一个广播域。
2、同一个VLAN可以直接进行二层通信。
3、VLAN间的主机不能进行二层通信。
VLAN的帧格式 带有tag的是802.1Q数据帧，untag的为标准的以太网帧，通过Tag中的信息来区分不同的VALN。
接口类型 1、acess端口：主要用来连接终端设备。
2、trunk端口：主要用来连接交换机、路由器等能识别Tag的设备
3、hybrid端口：是access端口与trunk端口的结合
接口处理VLAN数据的方式 PVID：表示端口默认情况下所属的VLAN，默认为1。
access端口处理数据的方式 1、当access端口收到不带tag的数据帧时，会打上端口的PVID的tag。
2、当access端口接收到Tagged帧时，如果该数据帧的VLAN ID与端口的PVID相同则接收，不同则丢弃。
3、当access端口发送时，数据帧中的VLAN ID与PVID相同则剥离tag后发送，如果不同则禁止发送。
trunk端口处理数据的方式 1、当trunk端口接收到untagged的数据帧时，先打上端口的PVID的tag，后检查改帧的VLAN ID是否在允许通过的列表中，如果在允许通过列表则接收，反之丢弃。
2、当trunk端口接收到tagged的数据帧时，检查改帧的VLAN ID是否在允许通过的列表中，如果在允许通过列表则接收。
3、当trunk端口发送数据帧时，如果802.1q数据帧中的VLAN ID与端口PVID相同，且在允许通过列表，就剥离tag发送。
4、当trunk端口发送数据帧时，如果802.1q数据帧中的VLAN ID与端口PVID不相同，且在允许通过列表，则直接发送。
hybrid端口处理数据的方式 1、当hybrid端口接收到untagged的数据帧时，先打上端口的PVID的tag，后检查改帧的VLAN ID是否在允许通过的列表中，如果在允许通过列表则接收，反之丢弃。
2、当hybrid端口接收到tagged的数据帧时，检查改帧的VLAN ID是否在允许通过的列表中，如果在允许通过列表则接收。
3、发送的时候一般是网络管理员自己手动配置是否带tag，一般情况下连接终端设备的端口都设置为untagged，交换机、路由器等能识别tag帧的设备设置为带tag，一般不改变交换机与交换机之间的PVID。
基本配置命令 1、access端口：
[SWA-GigabitEthernet0/0/1]port link-type access
[SWA-GigabitEthernet0/0/1]port default vlan vlanid //指定端口的PVID
2、trunk端口：
[SWA-GigabitEthernet0/0/2]port link-type trunk
[SWA-GigabitEthernet0/0/2]port trunk pvid vlan vlanid //指定端口的PVID
[SWA-GigabitEthernet0/0/2]port trunk allow-pass vlan vlanid vlanid //指定通过的vlanid
3、hybrid端口
[SWA-GigabitEthernet0/0/3]port link-type hybrid
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c8dbec736fce8d3604a9b76308b0e0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52e4dae1f8be47b5c64193ac798502a7/" rel="bookmark">
			java 实现多文件分文件夹打成压缩包下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：项目需要把流程中所有的文件分类打包成压缩包下载的功能，代码很简单，主要是需要组装分类文件
@GetMapping("/download") public void download(HttpServletRequest request, HttpServletResponse response,String spxxId) throws Exception { long timeCode = DateUtils.getMillis(); YwTySpxx spxx = spxxService.getById(spxxId); if(null==spxx){ return; } YwItem item = ywItemService.getById(spxx.getYwid()); YwBpmLcxx lcxx = bpmLcxxService.getById(spxx.getSplx());//流程主表 //查询任务历史表按照时间正序需要根据lcxx去重 List&lt;YwBpmRwrz&gt; list = ywBpmRwrzService.list(new QueryWrapper&lt;YwBpmRwrz&gt;() .eq("ywid", spxx.getYwid()) .eq("lcid", spxx.getSplx()) .orderByAsc("create_time") ); ArrayList&lt;YwBpmRwrz&gt; collect = list.stream().collect(Collectors.collectingAndThen (Collectors.toCollection(() -&gt; new TreeSet&lt;YwBpmRwrz&gt;(Comparator.comparing(YwBpmRwrz::getHjid))), ArrayList::new)); //循环节点信息 查询表 List&lt;Map&lt;String,String&gt;&gt; dowloadList = new ArrayList&lt;&gt;(); for(YwBpmRwrz rz : collect){ String hjid = rz.getHjid(); YwBpmLcxxHjxx hjxx = lcxxHjxxService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52e4dae1f8be47b5c64193ac798502a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef1a36da451d2fe71b1e9eb1edd0f076/" rel="bookmark">
			Linux之SSH、rsync
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Linux下的SSH服务
SSH服务简介和原理
SSH结构
SSH服务附带的SCP命令
使用ssh服务
ssh基本用法
ssh服务的两种认证类型
基于口令认证
基于密钥认证 ssh服务常见配置
1.修改ssh端口
2.禁止root用户登录
3.限制ssh监听的IP
4.禁止使用密码登录
​​Rsync远程同步备份工具
Rsync工作原理
Rsync安装与启动
Rsync的两种认证方式
1、Rsync --daemon认证
2、ssh认证
两者的区别
Rsync命令参数
Rsync基于SSH认证的使用
rsync类似与cp命令
rsync类似与scp命令
rsync类似与rm命令
rsync类似与ls 命令
rsync基于rsync-daemon认证
服务端的配置
客户端配置
rsync的完全备份和增量备份
rsync+inotify
内核参数
事件
操作
rsync+inotify实践
Linux下的SSH服务 SSH服务简介和原理 SSH协议中文名叫远程登录协议，是一种远程终端连接工具，可以通过客户端连接到服务端，从而远程控制电脑或服务器。默认端口为22号端口，基于TCP协议
SSH协议的优点就是数据传输是加密的，并且在传输时数据是压缩传输。既保障了数据的安全性，又大大提高了数据传输速率。
登陆原理
SSH结构 SSH由服务端 (openssh) 和客户端 (常见为ssh) 组成。
SSH的服务端为守护进程 (daemon)，它在后台进行并且相应来自客户端的连接请求。服务端的进程名为sshd，负责实时监听和控制远端的连接请求。一般包括公共密钥认证，密钥交换，对称密钥加密和非安全连 接等。
SSH客户端包含 ssh 和 scp (远程拷贝)，slogin (远程登录)，sftp (ftp的文件传输)等应用程序
SSH服务附带的SCP命令 scp命令是用于远程拷贝文件或目录的命令
格式：scp [参数] 文件 用户@IP地址:目标目录
scp参数：
-r 复制目录 -p 复制目录时保留属性 -P 接端口，默认22号端口 -l 限制速度 scp可以将文件或目录推送至目标主机；也可以从目标主机拉取文件到本机。举例说明，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef1a36da451d2fe71b1e9eb1edd0f076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a52c59ba4c87952eb3768f0d43b7e25/" rel="bookmark">
			VQGAN-CLIP: Open Domain Image Generationand Editing with Natural Language Guidance
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.VQGAN-CLIP: 在自然语言指导下开放域图像生成和编辑
机构：EleutherAI
github:GitHub - EleutherAI/vqgan-clip
2.介绍和摘要
摘要：从开放域文本提示生成和编辑图像是一项具有挑战性的任务，迄今为止，它需要昂贵且经过专门训练的模型。我们为这两个任务演示了一种新颖的方法，该方法能够通过使用多模态编码器来指导图像生成，而无需任何训练就可以从具有显着语义复杂性的文本提示中产生高视觉质量的图像。我们在各种任务上演示了如何使用CLIP 来指导VQGAN产生比以前更高的视觉质量输出，尽管没有为提出的任务进行培训。
示例vqgan-clip世代及其文本提示。选择提示以演示vqgan-clip能够产生的一系列视觉样式，包括古典艺术 (g，i)，现代艺术 (l)，图纸 (e)，油 画(a) 以及其他由于空间而未包括在内的样式。
贡献：
1.图像生成和处理的高视觉质量。
2.文本和生成物之间的语义保真度高，特别是当语义上不可能的内容共同出现时。
3.效率，因为我们的方法不需要除了预先训练的模型之外的额外训练，只需要使用少量的每个推理优化。
4.开放开发和研究的价值。这项技术是在公共场合开发的，开放式协作对于其在现实世界中的快速成功至关重要。非作者已经将我们的方法扩展到其他方式 (例如，为音频替换文本) 和商业应用程序
3.方法（method） 为了证明我们方法的有效性，我们使用VQGAN 和CLIP 作为预先训练的模型来应用它，因此将我们的方法称为vqgan-clip。然而，我们强调，我们的方法并不特定于这两个模型，随后的工作已经显示出成功的基础是我们使用其他模型的工作，甚至在其他模式。
我们从文本提示开始，使用 GAN 迭代生成候选图像，在每一步使用 CLIP 改进图像。我们通过处理 VQGAN-CLIP 的嵌入之间的平方球面距离来优化图像：候选图像嵌入和文本提示的嵌入来计算他们之间的损失函数，并通过clip区分图像的GAN潜在矢量表示，我们将其称为Oord，Vinyals和Kavukcuoglu之后的 “z矢量” 。这个过程在图1中概述。
显示如何添加增强以稳定和改进优化的图。应用多种crop，每种crop具有不同的随机增强，以在单个来源产生平均损失。这改善了相对于单个潜在Z矢量的结果。 要生成图像，“初始图像”包含随机像素值。重复优化过程以改变图像，直到输出图像逐渐改善，使其在语义上与目标文本匹配。我们还可以通过将要编辑的图像作为“初始图像”来编辑现有图像。用于描述我们希望用文本提示来更改图像，并且除了如何选择“初始图像”之外，在生成和操作之间不存在架构变化 （模型架构统一） 3.1图像的离散潜在空间
通过使用编码器 E 和解码器 G 构建卷积自动编码器，将其应用于图像。输入图像 x ∈ I 首先嵌入编码器 z = E(x)。然后我们可以将向量量化嵌入 x 计算为：
然后我们可以将其乘以词汇表以执行重建。然后，我们可以在量化步骤上使用直通式估计器，以便让 CNN 和码本进行端到端的联合训练。我们使用流行的 VQGAN [11] 模型进行本文的实验
3.2 Contrastive Text-Image Models
为了指导生成模型，我们需要一种方法来调整候选生成与指导文本的相似度。为实现这一目标，我们使用 CLIP 独立嵌入文本和生成图像，并测量嵌入之间的余弦相似度。然后将这种相似性重新定义为我们可以使用梯度下降来最小化的损失。
3.3 Augmentations
使用 vqgan-clip 的一个挑战是，如果在单个图像上计算，来自 CLIP 损失的梯度更新非常嘈杂。为了克服这个问题，我们采用生成的候选图像并对其进行多次修改，从而产生大量增强图像。我们随机裁剪生成的候选图像，然后应用进一步的增强，例如翻转、颜色抖动、噪声等。图像的大多数高级语义特征对这些变化相对不变，因此平均 CLIP 损失相对于所有增强图像都减少了每个更新步骤的方差。随机裁剪可能会显着改变图像的语义内容（例如裁剪掉一个重要的对象），但我们发现在实践中这不会导致任何问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a52c59ba4c87952eb3768f0d43b7e25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91dbf8bf679197dcf250dff079d06e52/" rel="bookmark">
			java重复注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 应用场景 基于注解功能的多功能适配
@GetMapping(“/hello”)
@PostMapping(“/hello1”)
2. 开发步骤 定义注解 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) #### 指定重复注解的list对象 @Repeatable(HList.class) public @interface H { String value(); } 2. `注解list对象的定义 ` @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface HList { #### 指定采集重复注解的集合对象 H[] value(); } 3 获取 ```java ReflectionUtils.doWithLocalMethods(Lcpol.class, new ReflectionUtils.MethodCallback() { @Override public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException { HList hList = method.getAnnotation(HList.class); if(hList!=null){ for (H h : hList.value()) { System.out.println(h.value()); } } } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca5cd0f473a57f5ed5abc74c8d5240cc/" rel="bookmark">
			fabric.js操作canvas画不规则图形时去掉fill填充颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是用这玩意画图片，再在图片上画一些不规则框框，后面还要加文字上去，但是拿到的例子都是有填充颜色，去掉 fill后填充颜色变成黑色，我想要图形内部无填充变得透明
原因：fabric会有fill默认值#000000也就是黑色
解决方法：把fill设置为false或者"transparent"即可，代码如下
this.myCanvas = new fabric.Canvas("myCanvas"); var path = new fabric.Path("M 20 20 L 100 80 L 150 100 z"); path.set({ stroke: "red", strokeWidth: 2, fill: false }); this.myCanvas.add(path); var path1 = new fabric.Path("M 300 100 L 500 180 L 400 400 z"); path1.set({ stroke: "red", fill: "transparent" }); this.myCanvas.add(path1); 结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f96f6a6e630a9be9ae17ffd3d4e066/" rel="bookmark">
			MobaXterm连接报错Network error: Connection timed out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开MobaXterm远程连接我VMware虚拟机的时候出现以下界面，问题详情如下：
Network error: Connection timed out
Session stopped
- Press &lt;return&gt; to exit tab
- Press R to restart session
- Press S to save terminal output to file
解决办法： 第一种：
去VMware中关闭并禁用防火墙
1）检测虚拟机ip地址是否正常 2）检测虚拟机防火墙状态是否禁用 关闭并禁用防火墙 systemctl stop firewalld systemctl disable firewalld 查看状态 systemctl status firewalld 3）检测物理机的IP地址 4）对比观察虚拟机ip和物理机ip是否在同一个网段 5）如果物理机上有很多物理网卡,建议把不用的停止，即检查物理机上是否有其他网卡干扰了正常网络。 实操如下：
再去MobaXterm中就可以连接成功
第二种：
是不是修改过ssh的端口号
比如我是为了搭建Gitlab服务器
实现CI，需要使用到Gitlab远程仓库，通过Docker搭建Gitlab
在Vmware中通过以下命令，把ssh服务的端口号修改成60022了
vi /etc/ssh/sshd_config #编辑sshd_config文件 PORT 22 -&gt; 60022 systemctl restart sshd #重启服务 所以在MobaXterm连接时这里Port要对应
查看sshd端口号：systemctl status sshd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72f96f6a6e630a9be9ae17ffd3d4e066/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789859a85cb6b54dff6f00283a4d58fe/" rel="bookmark">
			关于将AAB转化为APK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章讲了关于AAB的内容，什么是AAB，AAB与APK的关系、AAB的优势，如何打包AAB，感兴趣的同学可以去看看，链接如下：
关于Google推出的AAB，你了解多少_水很清的博客-CSDN博客
本篇文章主要讲如何将AAB转化为APK，虽然说我们上传到Google Play的AAB，是有Google Play自己去转化为APK给用户下载的，但是作为开发者的我们，也是需要知道应该如何转化的，毕竟我们还是要做测试的，当你拿到一个AAB文件的时候，你得知道如何将它转化成APK，然后安装在手机上，测试需要测试的内容。
好了话不多说，开干。
第一步：下载bundletool工具
下载地址：https://github.com/google/bundletool/releases
bundletool官方文档：bundletool | Android 开发者 | Android Developers
第二步：将AAB文件转化为APKS文件
很多人会问，为什么是APKS文件，而不是APK，看过我前面文章的同学肯定知道，因为AAB是生成适配不同设备的APK的一个集合，也就是说，AAB里面是包含多种设备资源的，那么我们转化出来的，肯定是多个APK的，每一种资源对应一个APK，所以是一个APKS文件，然后再解压APKS文件，我们就可以发现，里面有很多个APK，对应不同资源的APK。这些APK就是我们需要的，自己选择相匹配的安装到手机上即可。
使用如下命令就可，前提是先用终端进入到bundletool所在目录
java -jar bundletool.jar build-apks	//jar包及路径 --mode=universal //模式 --bundle= XXX //等于号后面填写需要修改的aab包以及所在路径 --output=aa.apks //等于号后面是apks包输出路径 --ks= //等于号后面填写签名以及路径 --ks-pass=pass: //冒号后面填写签名密码 --ks-key-alias= //等于号后面填写签名 --key-pass=pass: //冒号后面填写签名密码 你们是说看不懂，不知道怎么写，好吧，好人做到底，我再放一个完整的例子，但是要学会修改
//	jar包及路径 模式 需要修改的aab包以及所在路径 apks包输出路径 签名以及路径 签名密码 签名 签名密码 java -jar bundletool.jar build-apks --mode=universal --bundle=D:\work_file\20211230.aab --output=aa.apks --ks=D:\work_file\sign.jks --ks-pass=pass:sign666 --ks-key-alias=sign --key-pass=pass:sign666 将apks安装到手机上
1、电脑连接上设备；
2、在bundletool目录下打开终端（最好将bundletool的路径配置为全局变量；adb也是）；
3、执行如下命令：java -jar bundletool-all-1.9.0.jar路径 install-apks --apks=apks路径 --adb=adb路径
例子：java -jar /Users/xxx/bundletool-all-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/789859a85cb6b54dff6f00283a4d58fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf56c92276321da06de02ad8fab13d6c/" rel="bookmark">
			C# 使用QRCoder生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 使用QRCoder生成二维码 简介第一步 安装Nuget包 QRCoder第二步 创建一个公共类 QRCoderHelper.cs第三步 窗体代码第四步 实现方式 简介 最近瞎琢磨的一些小东西，也算是一个比较完整的二维码生成了，上手也很快，可自行扩展。
现在生成二维码有多种方式，我使用的是QRCoder。
第一步 安装Nuget包 QRCoder 也可以通过命令行来引入，看自己的习惯
第二步 创建一个公共类 QRCoderHelper.cs 这个类用来处理二维码的生成，也方便后续的扩展
using QRCoder; using System; using System.Drawing; using System.Drawing.Imaging; using System.IO; using static QRCoder.QRCodeGenerator; namespace QRCoderRWM { /// &lt;summary&gt; /// 二维码公共处理类 /// &lt;/summary&gt; public static class QRCoderHelper { ///生成二维码 /// &lt;/summary&gt; /// &lt;param name="TextContent"&gt;文本信息&lt;/param&gt; /// &lt;param name="level"&gt;容错等级&lt;/param&gt; /// &lt;param name="version"&gt;版本&lt;/param&gt; /// &lt;param name="pixel"&gt;像素点大小&lt;/param&gt; /// &lt;param name="darkColor"&gt;数点颜色&lt;/param&gt; /// &lt;param name="lightColor"&gt;背景颜色&lt;/param&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf56c92276321da06de02ad8fab13d6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f7cf8fa9b0780abae2ba0047eb59be7/" rel="bookmark">
			FPGA-基本通信协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、 小知识 串行：一次只发送一位数据；
并行：是指每次发送多位数据；
单工：通信只能从发送方到接收方，不能从接收方发送数据，也就是数据只能单向发送；
半双工：数据可以双向通信，但不能同时双向通信，一个时刻只能有一个方向上通信；
双工：数据可以同时，双向通信；
波特率：用于描述串口通信时的通信速度，指每秒可以发送的bit（位）的数量；
二、UART、I2C、SPI通信的对比 终于搞清了：SPI、UART、I2C通信的区别与应用
对比项UARTSPII2C信号线数目3根，RX、TX、GND4根，SDO、SDI、SCLK、SS2根，SDA、SCLK设备从属关系无存在主从设备。SPI用片选信号选择从机存在主从设备。IIC用地址选择从机。通信方式全双工通信全双工通信半双工通信通信速率速度慢比I2C总线要快，速度可达到几MbpsI2C的速度比SPI慢应用领域1、UART常用于控制计算机与串行设备的芯片2、就是我们经常所说的串口，基本都用于调试。主要应用在EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间I2C一般是用在同一个板子上的2个IC之间的通信 ，它可以替代标准的并行总线，连接各种集成电路和功能模块。传输距离I2C需要有双向IO的支持，而且使用上拉电阻，抗干扰能力较弱，一般用于同一板卡上芯片之间的通信，较少用于远距离通信通信特征异步，一帧可以传5/6/7/8位同步，SPI允许数据一位一位的传送，甚至允许暂停。从最高位开始传。同步，电平信号，一次连续8bit。从最高位开始传协议复杂度结构比较复杂SPI实现要比UART简单，UART需要固定的波特率，就是说两位数据的间隔要相等，而SPI则无所谓，因为它是有时钟的协议。协议比SPI复杂，但是连线比标准的SPI要少对比在点对点的通信中，SPI接口不需要进行寻址操作，且为全双工通信,显得简单高效。在多个从器件的系统中,每个从器件需要独立的使能信号,硬件上比I2C系统要稍微复杂一些。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9a3295d68fee7613a80d66615e6a6e/" rel="bookmark">
			【springBoot】springBoot配置拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springBoot配置拦截器
拦截器：
package com.ycwl.smartPark.interceptor; import com.fasterxml.jackson.databind.ObjectMapper; import com.ycwl.smartPark.annotation.IgnoreToken; import com.ycwl.smartPark.constant.BaseContextHandler; import com.ycwl.smartPark.exception.CheckTokenException; import com.ycwl.smartPark.exception.MissTokenException; import com.ycwl.smartPark.exception.TokenExpireException; import com.ycwl.smartPark.model.pc.jwt.JwtInfo; import com.ycwl.smartPark.utils.JwtTokenUtil; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.web.method.HandlerMethod; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; @Slf4j @Component public class AuthInterceptor extends HandlerInterceptorAdapter { @Autowired JwtTokenUtil jwtTokenUtil; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e9a3295d68fee7613a80d66615e6a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fd450bb5b792a276c2f0a321e2097a/" rel="bookmark">
			python 使用enumerate()函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、enumerate() 函数简介 enumerate()是python的内置函数，将一个可遍历iterable数据对象(如list列表、tuple元组或str字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在for循环当中。
函数返回一个enumerate对象，是一个可迭代对象。具体元素值可通过遍历取出。
函数语法为：
语法： enumerate(sequence, [start=0])
参数
sequence -- 一个序列、迭代器或其他支持迭代对象。
start -- 下标起始位置。
返回值
返回 enumerate(枚举) 对象。
函数参数有：
sequence是一个可迭代对象start是一个可选参数，表示索引从几开始计数 二、使用enumerate()函数 （1）使用for循环 1
2
3
4
1、迭代列表时如何访问列表下标索引
ll=[22, 36, 54, 41, 19, 62, 14, 92, 17, 67]
for i in range(len(ll)):
print(i, "=", ll[i])
（2）使用enumerate（） 1
2
3
# 优雅版：
for index,item in enumerate(ll):
print(index, "=",item)
此外，enumerate()函数还有第二个参数，用于指定索引的起始值
1
2
3
# 优雅版：
for index,item in enumerate(ll,10):
print(index, "=",item)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288834b5244af585d97335c20fddb1db/" rel="bookmark">
			vim全局替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. vim 中可用 :s 命令来替换字符串，具体如下： :s/str1/str2/ 替换当前行第一个 str1 为 str2 :s/str1/str2/g 替换当前行中所有 str1 为 str2 :m,ns/str1/str2/ 替换第 n 行开始到最后一行中每一行的第一个 str1 为 str2 :m,ns/str1/str2/g 替换第 n 行开始到最后一行中所有的 str1 为 str2 :1,$s/mpks/mpkss/g 将第一行到最后一行的mpks都替换成mpkss (注：m和n 为数字，若m为 .，表示为当前行开始；若n为$，则表示到最后一行结束) 如果使用 # 作为分隔符，则中间出现的 / 不会作为分隔符，比如： :s#str1/#str2/# 替换当前行第一个 str1/ 为 str2/ :%s+/oradata/apras/+/user01/apras1+ (使用+ 来 替换 / )： /oradata/apras/替换成/user01/apras1/ 2. 其他:%s/str1/str2/（等同于 :g/str1/s//str2/） 替换每一行的第一个 str1 为 str2 :%s/str1/str2/g（等同于 :g/str1/s//str2/g 和 :1,$ s/str1/str2/g ） 替换文中所有 str1 为 str2 从替换命令可以看到，g 放在命令末尾，表示对搜索字符串的每次出现进行替换；不加 g，表示只对搜索 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a1625bfb19301ccdd12078d8a4b413a/" rel="bookmark">
			java 常用正则表达式记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字母，数字 ^[A-Za-z0-9]+$ 字母，数字，英文符号(不包括空格) 英文符号=》ASCII表!到~，需要校验空格可以把\s去掉
^[A-Za-z0-9!-~\s]+$ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4114208ea8cf01689e24da9f72c1fc37/" rel="bookmark">
			Spring Boot 引入jar 包中的 controller
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题】
Spring Boot 引入jar 包中的 controller
【解决】
默认情况下 Spring Boot 在启动时, 只会扫描启动类对应的包以及子包进行装配， 因此jar包中的controller与主应用的包名保持一致即可。通过import注解引入对应的controller bean对象，在主程序中引入对应的注解类即可加载对应的controller. 【例子】
比如：这里的baseLocation就是com.nt而不是com.nt.a，如果其他第三方jar里面的路径有com.nt.xxx ，那么第三方的jar也是可以被引入的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff1575ae7dcf71b64cf7711cb9e05a74/" rel="bookmark">
			speaker-test报错问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 把用户添加进audio组。（通过usermod -a -G usergroup username命令），参考Linux添加用户（user）到用户组（group）_写回的博客-CSDN博客_linux添加用户到用户组。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ce8e882a3750b3597473962eb4da77/" rel="bookmark">
			CVE-2022-28060 i春秋云镜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 CVE-2022-28060 CVE-2022-28060 1:
2：
3：
4：直接丢sqlmap跑没没跑出来，手注一下感觉也不对
5：后面问师傅博客才知道还有burp post请求可以存文本注入(又学到了一种新的姿势)，直接抓包保存就好然后丢sqlmap
6：Python sqlmap.py -r 1.txt –file-read “/flag” –dbms Mysql
等会就出来了
总结文本注入：新的姿势收获多多
1：SQLMAP可以从一个文本文件中获取HTTP请求,根据这个文本文件我们可以不设置其他参数，譬如Cookie,POST等,对文本中的Web数据包进行分析注入
2：file-read: SQLmap --file-read从服务器中读取文件
当用户权限足够大并且具有特定的函数，即可读取服务器中的文件，可以是文本，也可以是二进制文件
3:dbms mysql 指定数据库类型
拓展知识网页：https://www.cnblogs.com/icui4cu/p/15148971.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9fb75d8c6df8146d1d29a2d75d14cba/" rel="bookmark">
			为什么我在公司里访问不了家里的电脑？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为掘金社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！
上篇文章「为什么我们家里的IP都是192.168开头的？」提到，因为IPv4地址有限，最大42亿个。为了更好的利用这有限的IP数量，网络分为局域网和广域网，将IP分为了私有IP和公网IP，一个局域网里的N多台机器都可以共用一个公网IP，从而大大增加了"可用IP数量"。
当我们需要发送网络包的时候，在IP层，需要填入源IP地址，和目的IP地址，也就是对应快递的发货地址和收货地址。
但是我们家里的局域网内，基本上都用192.168.xx.xx这样的私有IP。
如果我们在发送网络包的时候，这么填。对方在回数据包的时候该怎么回？毕竟千家万户人用的都是192.168.0.1，网络怎么知道该发给谁？
所以肯定需要将这个192.168.xx私有IP转换成公有IP。
因此在上篇文章最后，留了这么个问题。局域网内用的是私有IP，公网用的都是公有IP。一个局域网里的私有IP想访问局域网外的公有IP，必然要做个IP转换，这是在哪里做的转换呢？
答案是NAT设备，全称Network Address Translation，网络地址转换。基本上家用路由器都支持这功能。
我们来聊下它是怎么工作的。
NAT的工作原理 为了简单，我们假设你很富，你家里分到了一个公网IP地址 20.20.20.20，对应配到了你家自带NAT功能的家用路由器上，你家里需要上网的设备有很多，比如你的手机，电脑都需要上网，他们构成了一个局域网，用的都是私有IP，比如192.168.xx。其中你在电脑上执行ifconfig命令，发现家里的电脑IP是192.168.30.5。 你要访问的公网IP地址是30.30.30.30。
于是就有下面这样一张图
当你准备发送数据包的时候，你的电脑内核协议栈就会构造一个IP数据包。这个IP数据包报头里的发送端IP地址填的就是192.168.30.5，接收端IP地址就是30.30.30.30。将数据包发到NAT路由器中。
此时NAT路由器会将IP数据包里的源IP地址修改一下，私有IP地址192.168.30.5改写为公网IP地址20.20.20.20，这叫SNAT（Source Network Address Translation，源地址转换）。并且还会在NAT路由器内部留下一条 192.168.30.5 -&gt; 20.20.20.20的映射记录，这个信息会在后面用到。之后IP数据包经过公网里各个路由器的转发，发到了接收端30.30.30.30，到这里发送流程结束。
如果接收端处理完数据了，需要发一个响应给你的电脑，那就需要将发送端IP地址填上自己的30.30.30.30，将接收端地址填为你的公网IP地址20.20.20.20，发往NAT路由器。NAT路由器收到公网来的消息之后，会检查下自己之前留下的映射信息，发现之前留下了这么一条 192.168.30.5 -&gt; 20.20.20.20记录，就会将这个数据包的目的IP地址修改一下，变成内网IP地址192.168.30.5, 这也叫DNAT（Destination Network Address Translation，目的地址转换）。 之后将其转发给你的电脑上。
整个过程下来，NAT悄悄的改了IP数据包的发送和接收端IP地址，但对真正的发送方和接收方来说，他们却对这件事情，一无所知。
这就是NAT的工作原理。
NAPT的原理 到这里，相信大家都有一个很大的疑问。
局域网里并不只有一台机器，局域网内 每台机器都在NAT下留下的映射信息都会是 192.168.xx.xx -&gt; 20.20.20.20，发送消息是没啥事，但接收消息的时候就不知道该回给谁了。
这问题相当致命，因此实际上大部分时候不会使用普通的NAT。
那怎么办呢？
问题出在我们没办法区分内网里的多个网络连接。
于是乎。
我们可以加入其他信息去区分内网里的各个网络连接，很自然就能想到端口。
但IP数据包（网络层）本身是没有端口信息的。常见的传输层协议TCP和UDP数据报文里才有端口的信息。
于是流程就变成了下面这样子。
当你准备发送数据包的时候，你的电脑内核协议栈就会先构造一个TCP或者UDP数据报头，里面写入端口号，比如发送端口是5000，接收端口是3000，然后在这个基础上，加入IP数据报头，填入发送端和接收端的IP地址。
那数据包长这样。
假设，发送端IP地址填的就是192.168.30.5，接收端IP地址就是30.30.30.30。
将数据包发到NAT路由器中。
此时NAT路由器会将IP数据包里的源IP地址和端口号修改一下，从192.168.30.5:5000改写成20.20.20.20:6000。并且还会在NAT路由器内部留下一条 192.168.30.5:5000 -&gt; 20.20.20.20:6000的映射记录。之后数据包经过公网里各个路由器的转发，发到了接收端30.30.30.30:3000，到这里发送流程结束。
接收端响应时，就会在数据包里填入发送端地址是30.30.30.30:3000，将接收端是20.20.20.20:6000，发往NAT路由器。NAT路由器发现下自己之前留下过这么一条 192.168.30.5:5000 -&gt; 20.20.20.20:6000的记录，就会将这个数据包的目的IP地址和端口修改一下，变回原来的192.168.30.5:5000。 之后将其转发给你的电脑上。
如果局域网内有多个设备，他们就会映射到不同的公网端口上，毕竟端口最大可达65535，完全够用。这样大家都可以相安无事。
像这种同时转换IP和端口的技术，就是NAPT（Network Address Port Transfer , 网络地址端口转换 ）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9fb75d8c6df8146d1d29a2d75d14cba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a18b2a8abf3259c29c2fe9d051925d61/" rel="bookmark">
			windows 10 ssh免密登录linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows 10 ssh使用密钥登录linux
桌面左下角搜素栏里输入powershell 找到powershell
在win10 的 powershell里面输入
ssh-keygen -t rsa -C “你的email或者名字等任意字符串都行”
回车
会在C:\Users\你的用户名\.ssh 会生成一对秘钥, .pub后缀的是公钥,用于上传到服务器的.
在linux服务器的 /root/.ssh/authorized_keys 文件里面 填写上面生成的公钥的内容.
或者用ssh-copy-id命令写入
ssh-copy-id -i ~/.ssh/id_rsa.pub user@serverip 再在windows C:\Users\用户名\ssh\config 文件写入快速登录的方法
Host myserver1 HostName 你的服务器ip User root Port 22 IdentityFile C:\Users\用户名\.ssh\id_rsa myserver1是给服务器起的名字,自己命名
下次 用 ssh myserver1 命令就能登录服务器了 .就不用 ssh user@ip 了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826af1912e74d58518b3e02ccd07188c/" rel="bookmark">
			背八股上岸的，试用期感觉够呛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：阿秀
校招八股文学习网站：https://interviewguide.cn
这是阿秀的第「220」篇原创
每年的六七月份是毕业季，大多数选择参加工作的毕业生都会在七月份入职，正式开启自己的打工人生涯。
第一关就是顺利度过试用期，但是不同公司的试用期是不一样的，有的公司试用期只有1个月，有的则是3-4个月，有的公司试用期甚至长达6个月之久，试用期结束后有的可能还需要答辩或者作总结，比如携程的试用期就是4个月，而字节跳动的试用期就是在6个月。
前几天阿秀的学习圈内有个学弟说自己在校招期间是背八股文进去的，以前是C++技术栈，现在在逐步转Go中，但极度不适应，感觉试用期可能都够呛，阿秀在看完他的问题后也是给了他一些建议和意见，今天就来分享一下。
1、学弟的提问 秀哥你好，本人是22届毕业生一枚，校招拿了字节的offer，签三方后没提前来实习，现在大概入职了差不多3个月半左右，现在感觉我试用期肯定都过不去了。
我当初是靠背八股文和算法进去的，技术栈是C++，现在则是在转Go中，主要是做web那套，目前遇到的问题是对工作非常的不适应，感觉不会的东西已经多到难以接受了，我也是有不懂都去问，但还是不足以解决我的问题。
我跟星球里的另一位小伙伴比较像，他当初是实习遇到的这些问题，我则是正式入职后才遇到的这些问题。
我也分析过原因，也问过同组实习生，他们都是Java技术栈的，至少也做过什么电商的项目，他们说结构都差不多，而我的项目只是牛客webserver并且也没有完全理解，项目经验可以认为是0，我的底子也很差，甚至连数据库都没有正式连过。
我对项目中的那些文件也不知道是放什么的，甚至最开始连数据连接层、业务处理层这些都不知道，日志也不会看，虽然一直在努力学努力问，但工作也很紧，有一些不懂的也只能先放过去。
入职前两周我都在配环境，然后在Monter的帮助下开始做需求。从前两周到现在的3.5个月我一共做了3个需求，其中前两个都是Monter带着做的，就差手把手教我做了，第三个也是Monter兜底才最终没有延期，顺利交付。
现在我是在做第四个需求，Monter有点放手让我自己从0开始做的意思了，我的天，我瞬间就不行了。
虽然在你们看来可能比较简单，只是写几个接口，但是数据库这些东西都要我自己来弄，这还不是让我觉得最难的，最让我觉得难以客服的就是和别人对接，我都不明白前端同学想要的是什么，真的是这段时间的工作让我深感自己的能力现在不足以满足开发。
我有没有必要请两周假去补充go web的知识，我希望跟星球里的那位同学一样，也能在这两周能够尽可能的学到东西，目前比较焦虑，希望秀哥能给一点学习和工作上的建议，以及应该如何抉择？
2、阿秀的回答 学弟，你好，我看了你的情况，你这应该是缺少实践导致的，并且缺的不是一点两点，看到你说“靠背八股文 + 算法”进来的，我就更确定这一点了。
你的问题比较碎，我挨个说说：
第一、计算机是一门需要动手实践的科目，一些你们看起来能够背的八股文其实依然可以实践。
说个最简单的八股文计算机网络三握四挥就是可以实践的内容，以前我就试过自己去抓包看三握四挥的具体细节，还记录下来了：https://zhuanlan.zhihu.com/p/455678474，更不要说操作系统、数据库这些都是可以实践的，SQL如何写？怎么链接数据库这些都是可以自己试试的。。。
第二、“不明白前端同学想要什么” + “请假两周学习go web的知识”：请假倒没这个必要，其实前段发过来的请求一般就那几种：get、post、put、delete，有时候还还有patch等。
你可以在接下来的时候里自己用postman模拟这些请求，加上请求参数或者body，自己写个go web后端去接受这些请求，后端接到这些请求后，一般会分为三步来处理这些请求：
1、请求层：将前端发来的请求打到对应的处理函数上
2、逻辑层：主要是通过前端发来请求的参数里看前端想要做什么，处理好逻辑
3、数据接入层：这层主要就是用来连接数据库，组装SQL 取数据，
然后返回第二层进行一些数据处理和组装，最后再返回第一层，返回给前端，主要的过程基本就是这样的，就好像洋葱模型一样。
你可以按照这个过程来练练手，当然了，如果有中间件逻辑的话需要再第一步和最后一步再走一下中间件。
第三、最大的建议就是自己多动手实操，不管是写SQL（知识星球置顶帖知识图谱里有关于SQL的学习方法，可以看看）、还是写接口，都要自己动手做，即使gorm有帮你写SQL的功能，你也要自己知道是什么意思才可以。
最后看到你打算做go，推荐给你这本go的开源书吧，手把手带着你做项目的，陈煎鱼写的，还不错，我做过其中的服务器项目：https://golang2.eddycjy.com/。
以前我写过的go的学习路线中有几个好视频和练手的，你可以去看看：https://interviewguide.cn/notes/02-learning_route/02-language/02-golang.html
其实工作没你想的那么难，很多人调侃自己是CRUD工程师不是没有道理的，最重要的就是理解一下业务，吃透业务是最重要的。
至于请假两周倒那没必要，你的这段经历也是让我想到了我以前刚参加工作那段时间，我也是C++技术栈上岸的校招，也没有选择签完三方后来实习，入职后才知道需要我从前端切进来，所以入职之初的两三个月我过得非常痛苦，经常晚上下班后自己加班加点的学前端知识学到一两点，因为第二天去了就要写。
不过那段时间也是我成长最快的一段时间，是比较辛苦，但收获也很多，你可以效仿一下我，晚上多花点时间学，没必要请长假，那样成本太高。
能留在大厂一定要留在大厂，前期狼狈点就狼狈点，没什么关系，多下功夫去补全就好，试用期也没你想的那么难过，没你想得那么严重。。。。
现在想想也挺后悔的，当初签完三方后应该争取一下来实习一两个月，提前熟悉一下组内业务，了解一下技术栈，不说别的，实习期间80%的薪资就挺香的了。
以上就是给你的建议，有问题可以再给我留言。
下面是一些已经发表在公众号上的秋招总结和分享，自取即可，基本都是一些23届的秋招/实习总结经验，其中既有一些985、211出身的学弟学妹，也有跟阿秀一样普通二三本出身的学弟学妹，学习计算机的都知道一个局部性原理，其实你现在踩的坑，你的学长学姐大概率已经都已经踩过了，如果可以的话建议你多看看他们的总结也许会对你以后的校招求职或者计算机学习有所帮助。
Java👍：大厂去不了，中小厂我也满意
Java👍：顺利上岸字节电商后端，但也真的很不顺利
Java👍：民办三本，我从3K到15K的一年
C++👍：上岸字节基础架构，大二转专业后我终于走到这一步
C++👍：抖音后端，实习offer。
C++👍：四非选手，上岸互联网后端/服务端开发
C++👍：7天五面，提前批顺利上岸飞书后端
C++👍：前脚结束面试，后脚意向书就发来了。。。
C++👍：算法转开发，拿了3个offer！
C++👍：不管那么多，offer先接了再说
C++👍：毫无保留，这是我全部的嵌入式学习&amp;秋招经验!
C++👍：今年嵌入式硬件这块也挺香
前端👍：上岸快手，我选择一条不一样的路
前端👍：非科班转码，上岸小公司我也很满意了
测开/测试👍：算法转开发&amp;测开，拿了四个offer（上）
测开/测试👍：算法转开发&amp;测开，拿了四个offer（下）
算法👍：头铁！我就硬钢算法岗！
offer选择👍：offer选择，哭了，我又被倒挂了。。。
offer选择👍：晚生一年就是这样的结果吗？真的很不甘心。
offer选择👍：小厂10K vs 大厂20K，咋选？
offer选择👍：双非本，拿到这些offer我真的很满足！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/826af1912e74d58518b3e02ccd07188c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0fc81c2da5fb6bed6526f5c11daabda/" rel="bookmark">
			在CDH6.3中单独升级Impala到Apache Impala 3.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		１. 实验环境 一个CDH6.3.3集群，部署在三台Ubuntu16.04机器上一台同样环境的Ubuntu16.04机器用来编译Apache Impala 3.4 CDH6.3.3对应的Impala基础版本是Apache Impala 3.2，当然还打了不少补丁。从Impala网页上能看到版本号是3.2.0-cdh6.3.3
2. 编译Apache Impala 3.4 Apache Impala是以源码的形式release的，因此需要自行在对应的平台上编译。找一个跟集群环境一致的机器，我这里是64位的ubuntu16.04。
2.1 下载源码 根据文档中的“Building Impala without Test Data (for testing Impala)”章节来编译Impala:
https://cwiki.apache.org/confluence/display/IMPALA/Building+Impala
所不同的是我们要编译的是3.4版本，不是最新的master分支，所以clone时要选好版本，这里选择3.4.1：
git clone --single-branch --branch 3.4.1 https://github.com/apache/impala.git impala-3.4 cd impala-3.4 注：若选的是3.4.0，由于Cloudera maven repo URL变更，需要修改pom.xml才能编译成功（IMPALA-9815），要打上 IMPALA-9815 的commit: https://github.com/apache/impala/commit/481ea4ab0d476a4aa491f99c2a4e376faddc0b03
git fetch origin 481ea4ab0d476a4aa491f99c2a4e376faddc0b03 git cherry-pick 481ea4ab0d476a4aa491f99c2a4e376faddc0b03 建议还是使用3.4.1，包含更多bug修复。
2.2 安装依赖和开始编译 然后用 bin/bootstrap_system.sh 脚本来安装编译依赖：
export IMPALA_HOME=`pwd` $IMPALA_HOME/bin/bootstrap_system.sh 如果之前在这台机器上编译过Impala，也可以跳过上面这一步。
接下来是 source 一下 impala-config.sh 设置环境变量
source $IMPALA_HOME/bin/impala-config.sh 然后开始编译：
$IMPALA_HOME/buildall.sh -noclean -notests -release 注：如果是测试用途，可以把 -release 去掉，这样编译出来的 impalad 在遇到 bug 时能打出更多信息，比如 bug 能提前被 DCHECK 判定，更容易定位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0fc81c2da5fb6bed6526f5c11daabda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c431b9ba89def145bd6ddf815d8b504/" rel="bookmark">
			Linux安装nginx-1.9.9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装nginx的教程 前提：
百度网盘
提取码：xliu
nginx官方下载
一键下载：
1.安装依赖插件
一键安装四个依赖 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 进入/usr/local/java 目录,如果不存在java目录,则创建
#下载安装包 wget http://nginx.org/download/nginx-1.9.9.tar.gz 步骤一： 安装前先检测安装的软件命令：yum -y install gcc pcre-devel zlib-devel openssl openssl-devel
上传ngnix:
步骤二： 配置命令：
./configure --prefix=/usr/local/nginx
步骤三： 安装make
命令：make
命令：make install
显示这个说明你安装成功 步骤四： 测试： cd到刚才配置的安装目录/usr/loca/nginx/
./sbin/nginx -t
出现这个说明成功
注意：出现bug，请自行百度吧。
启动nginx
cd /usr/local/nginx/sbin
./nginx
//启动nginx
条件 开发80端口：
下面我们开启80端口： firewall-cmd --add-port=80/tcp --permanent
#重启防火墙
systemctl restart firewalld
配置nginx开机自启动 vim /etc/rc.d/rc.local
添加：/usr/local/nginx/sbin/nginx
最后开启nginx查看进程会看到：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c431b9ba89def145bd6ddf815d8b504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9771d00790a461a4812c9232acb2d439/" rel="bookmark">
			【学习笔记46】JavaScript购物车的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、案例效果 1、将通过数据重构页面 查询数据, 渲染页面
2、全选 选中全选按钮后, 根据全选按钮的选中状态, 修改所有商品的选中状态重新渲染视图 3、清空购物车 清空商品数据重新渲染视图 4、结算 找到所有选中的商品计算所有选中商品各自的总价计算所有选中商品的总价之和 5、删除已选中 在原数组中, 找到选中的商品, 然后删除重新渲染视图 6、商品数量调整 找到对应的商品, 修改收藏数量重新渲染视图 7、选中商品 找到对应的商品, 修改选中状态重新渲染视图 8、删除某一项 找到对应商品, 将删除重新渲染视图 9、数据持久化 (浏览器关闭, 数据能保存) 本地存储
二、案例分析 1. 数组数据分析 id: 数据的唯一值status: true代表该商品被选中, false则为没被选中pic: 图片地址name: 商品名price: 价格number: 商品收藏数量total: 库存 2. 数据驱动视图 查: 查询数据, 渲染到页面增删改: 找到源数据, 然后对源数据做修改, 修改完成, 重新渲染页面 3. 逻辑思维 准备一个渲染函数首次打开页面时 调用在各种事件触发之后, 重新调用 三、html代码 &lt;div class="header"&gt;页面顶部&lt;/div&gt; &lt;!-- 动态生成数据 --&gt; &lt;div class="content"&gt;&lt;/div&gt; &lt;div class="footer"&gt;页面底部&lt;/div&gt; &lt;script src="./index.js"&gt;&lt;/script&gt; 四、css代码 * { margin: 0; padding: 0; } ul,ol,li { list-style: none; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9771d00790a461a4812c9232acb2d439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/febc86db3448331649349addb6ac24c1/" rel="bookmark">
			堆、堆排序、堆应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 “堆”（Heap），原地排序、时间复杂度O(nlogn)的排序算法。
堆是一个完全二叉树；堆中每一个节点的值都必须大于等于（或者小于等于）其子树中每个节点的值； 二、如何实现一个堆 使用数组来存储
数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 2i​ 的节点。
往堆中插入一个数据（堆化）
从下往上堆化
从上往下堆化
删除堆顶元素
可以选择删除堆顶元素后，将堆中的最后一个元素放到堆顶，然后进行从上往下堆化。包含n个节点的完全二叉树，树的高度不会查过log2​n，所以堆化的时间复杂度和树的高度成正比，也就是O(logn)。
三、如何基于堆实现排序 1、建堆
起始堆中只有一个元素，下标为1的数据，然后根据前面的插入操作，将2到下标n的数据依次插入到堆中；从后往前处理数据，叶子节点往下堆化只能自己跟自己比较，所以从最后一个非叶子节点开始，依次堆化；
private static void buildHeap(int[] a, int n) { for (int i = n/2; i &gt;= 1; --i) { heapify(a, n, i); } } private static void heapify(int[] a, int n, int i) { while (true) { int maxPos = i; if (i*2 &lt;= n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2; if (i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1; if (maxPos == i) break; swap(a, i, maxPos); i = maxPos; } } 那么建堆时间复杂度是多少？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/febc86db3448331649349addb6ac24c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4bda0662843bcf5f0f200dc1be84cf5/" rel="bookmark">
			CVE-2022-28060(Victor CMS v1.0 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CVE-2022-28060(Victor CMS v1.0 ) 存在问题本：Victor CMS v1.0
看到页面简单，然后旁边有一个登陆框，尝试登陆框哪里进行套路尝试(弱口令万能和注入)，见过注入有戏，吧他拿到sqlmp跑一下。
python sqlmap.py -r post.txt --batch --dump 然后找到flag。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40bfb1f70a2cd5fc29099abaf109ff7c/" rel="bookmark">
			解决问题:Class path contains multiple SLF4J bindings.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在整合SpringBoot项目于Dubbo的时候，遇到Class path contains multiple SLF4J bindings的错误，具体报错如下所示：
读取报错信息可以知道，问题出在我们的jar出现了冲突！
对于此类问题，我们可以插件Maven Helper快速定位解决！当然也可以在模块的依赖图中手动排错！
使用Maven Helper解决 打开IDEA，点击文件（file），选择设置（setting），在弹出的弹框在选择插件，在里面搜索Maven Helper，具体如下所示：
安装完毕后重启IDEA。重启IDEA后，找到对应模块的pom.xml,可以看到在其下方有一个Dependency Analyzer，具体如下所示：
在出现的弹框中，输入slf4j-log4j12，然后找到冲突项后右击删除即可！
删除冲突项后即可启动后项目成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef892ae1b91ba077b736b8048c51079/" rel="bookmark">
			RFSoC应用笔记 - RF数据转换器 -22- API使用指南之配置DAC相关工作状态和中断相关函数使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文完结后，关于RFSoC的配置的API函数部分就全部介绍完毕，后续有空将更新介绍简单的射频收发回环示例工程，不定时更新，敬请期待。
配置DAC相关工作状态 XRFdc_SetInterpolationFactor 函数原型
u32 XRFdc_SetInterpolationFactor(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 InterpolationFactor); 参数
*XRFdc InstancePtr：指向驱动程序实例的指针。u32 Tile_Id：RF-DAC tile 编号。 有效值为 0-3。u32 Block_Id：块内的RF-DAC 块编号。 有效值为 0-3。u32 InterpolationFactor：要为RF-DAC 设置的插值因子。 带标注的只有GEN 3代的有该参数配置。
描述
此 API 函数为请求的 RF-DAC 设置插值因子，并根据插值因子更新 FIFO 读取宽度。插值的动态变化对块吞吐量有影响。 可以动态更改 AXI4-Stream 时钟速率以适应吞吐量的变化。 在非 MTS 模式下，推荐的程序是关闭 FIFO（Xrfdc_setupfifo），更改时钟速率（Xrfdc_SetfabClkOutDiv），清除 FIFO 中断，然后重新启动 FIFO（Xrfdc_SetupFifo）。
返回值
XRFDC_SUCCESS
XRFDC_FAILURE
XRFdc_SetFabWrVldWords 函数原型
u32 XRFdc_SetFabWrVldWords(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 FabricWrVldWords); 参数
*XRFdc InstancePtr：指向驱动程序实例的指针。u32 Tile_Id：RF-DAC tile 编号。 有效值为 0-3。u32 Block_Id：块内的RF-DAC 块编号。 有效值为 0-3。u32 FabricWrVldWords ：写入要为RF-DAC 设置的结构数据速率。 说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ef892ae1b91ba077b736b8048c51079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a76e837ec95374753615778103c978/" rel="bookmark">
			从 Mysql binlog 过滤抽取指定条件的SQL语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用场景 适用于希望从mysql的binlog恢复数据。并且希望快速抽取出自己关注的部分数据表，以及特定数据的SQL操作脚本。可以进行精准恢复。 使用须知 Mysql开启了binlog日志功能，并确实记录了想要查找的SQL语句本次使用到了 Linux系统的 grep命令 用于过滤并抽取目标sql脚本到新的文件（效率好高，近2百兆的日志文件瞬间完成过滤写入新文件）。windows 可以尝试安装 grep命令试试，本人没测试过。 开始 获取Mysql的binlog文件 根据mysql的配置找到binlog文件
查找 binlog 文件位置，可以执行语句
SHOW VARIABLES LIKE 'log_%'; 关注 字段： log_bin_basename 。后面的value是路径+最后的是binlog文件名，所以访问路径要去掉最后路径分隔符的那个字符串。
例如：D:\mysql-5.6.20-winx64\mysql-5.6.20-winx64\data\mysql-bin
实际binlog文件路径：D:\mysql-5.6.20-winx64\mysql-5.6.20-winx64\data
结尾的myslq-bin 是binlog日志生成的文件名前缀。
解析binlog文件，获取可读的SQL文件 使用命令 mysqlbinlog。只要windows或者Linux上安装过Mysql 命令行可识别此命令就可以用。
# 参数介绍 inlog --base64-output=decode-rows -v /全路径（如果执行命令时不跟binlog文件在一个目录下）/要解析的binlog文件名 --result-file=结果sql脚本文件 # 例子: inlog --base64-output=decode-rows -v /opt/data/mysql-bin.000118 --result-file=000118.sql 节选了一个update（相对其他操作内容更复杂）语句内容如下。
忽略每行开头的### 符号和用@列的顺序号替代了列名,就是一个标准的 SQL语句，
### UPDATE `testdb`.`test_table` ### WHERE ### @1=614305 ### @2=182759 ### @3=182749 ### @4=6668 ### @5=1876 ### @6=NULL ### @7=1668128408 ### @8=1 ### @9=0 ### SET ### @1=614305 ### @2=182759 ### @3=182749 ### @4=6668 ### @5=1876 ### @6=NULL ### @7=1668136095 ### @8=2 ### @9=0 grep命令简介 本次使用的 grep命令是在Linux环境上，所以把解析好的sql文件我上传到了Linux服务器进行后续操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a76e837ec95374753615778103c978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d6a6694b41082a66e493560d98a403/" rel="bookmark">
			CentOS环境下Minio的安装，并实现文件的上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CentOS环境下安装Minio CentOS环境下安装Minio的方式有多种，下面将依次介绍常规安装方式及docker安装方式。
常规安装方式
1.创建Minio安装目录，并在线下载Minio
mkdir -p /usr/local/minio/data #创建minio安装目录 cd /usr/local/minio yum -y install wget wget https://dl.min.io/server/minio/release/linux-amd64/minio #使用wget下载minio chmod +x minio #修改权限 2.开放Minio访问端口号
firewall-cmd --zone=public --add-port=9000/tcp --permanent firewall-cmd --zone=public --add-port=9001/tcp --permanent firewall-cmd --reload 3.使用vim start-minio.sh 命令创建可运行Minio的Shell脚本，切换到start-minio.sh文件所在目录，并使用./start-minio.sh命令运行执行脚本，使用tailf minio.log 命令可查看Minio的运行状况。start-minio.sh文件内容如下所示。
MINIO_ROOT_USER=minioadmin MINIO_ROOT_PASSWORD=minioadmin nohup /usr/local/minio/minio server --address ':9000' --console-address ':9001' /usr/local/minio/data &gt; /usr/local/minio/minio.log 2&gt;&amp;1 &amp; 基于docker的安装方式
1.查看docker环境是否正常
docker search minIO 2.拉取Minio镜像
docker pull minio/minio 3.查看镜像
docker images 4.创建Minio容器
docker run -d -p 9000:9000 --name minio \ -p 9001:9001 \ -e 'MINIO_ACCESS_KEY=minioadmin' \ -e 'MINIO_SECRET_KEY=minioadmin' \ -v /usr/share/minio/data:/data \ -v /usr/share/minio/config:/root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d6a6694b41082a66e493560d98a403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2dab89154d8dcb95a0470cd1a48e32/" rel="bookmark">
			未配置springboot配置处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点开扳手，设置自动配置即可
如果不进行勾选，则会影响数据自动注入，导致数据为空
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6067d31223f64d8f94140e837fc780c/" rel="bookmark">
			基于密度的聚类算法（1）——DBSCAN详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于密度的聚类算法（1）——DBSCAN详解
基于密度的聚类算法（2）——OPTICS详解
基于密度的聚类算法（3）——DPC详解
1. DBSCAN简介
DBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种典型的基于密度的空间聚类算法。和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。该算法将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，它将簇定义为密度相连的点的最大集合。
该算法利用基于密度的聚类的概念，即要求聚类空间中的一定区域内所包含对象（点或其他空间对象）的数目不小于某一给定阈值。DBSCAN算法的显著优点是聚类速度快且能够有效处理噪声点和发现任意形状的空间聚类。但是当空间聚类的密度不均匀、聚类间距差相差很大时，聚类质量较差。
2. DBSCAN的优缺点
和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。
那么什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。
（1）DBSCAN的优点：
1） 可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。
2） 可以在聚类的同时发现异常点，对数据集中的异常点不敏感。
3） 聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。
（2）DBSCAN的缺点：
1）如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。
2） 如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。
3） 调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值ϵ，邻域样本数阈值MinPts联合调参，不同的参数组合对最后的聚类效果有较大影响
3. DBSCAN详细描述及参数含义
DBSCAN是基于一组邻域来描述样本集的紧密程度的，参数(ϵ, MinPts)用来描述邻域的样本分布紧密程度。其中，ϵ描述了某一样本的邻域距离阈值，MinPts描述了某一样本的距离为ϵ的邻域中样本个数的阈值。
假设样本集是*D=(x1,x2,...,xm)*,则DBSCAN具体的密度描述如下：
1） ϵ-邻域：对于xj∈D，其ϵ-邻域包含样本集D中与xj的距离不大于ϵ的子样本集，即Nϵ(xj)={xi∈D|distance(xi,xj)≤ϵ}, 这个子样本集的个数记为|Nϵ(xj)|　2) 核心对象：对于任一样本xj∈D，如果其ϵ-邻域对应的Nϵ(xj)至少包含MinPts个样本，即如果|Nϵ(xj)|≥MinPts，则xj是核心对象。　3）密度直达：如果xi位于xj的ϵ-邻域中，且xj是核心对象，则称xi由xj密度直达。注意反之不一定成立，即此时不能说xj由xi密度直达, 除非且xi也是核心对象。
4）密度可达：对于xi和xj,如果存在样本样本序列p1,p2,...,pT,满足p1=xi,pT=xj, 且pt+1由pt密度直达，则称xj由xi密度可达。也就是说，密度可达满足传递性。此时序列中的传递样本p1,p2,...,pT−1均为核心对象，因为只有核心对象才能使其他样本密度直达。注意密度可达也不满足对称性，这个可以由密度直达的不对称性得出。
5）密度相连：对于xi和xj,如果存在核心对象样本xk，使xi和xj均由xk密度可达，则称xi和xj密度相连。注意密度相连关系是满足对称性的。
从下图可以很容易看出理解上述定义，图中MinPts=5，红色的点都是核心对象，因为其ϵ-邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的ϵ-邻域内所有的样本相互都是密度相连的。
4. DBSCAN思想
DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。
这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的ϵ-邻域里；如果有多个核心对象，则簇里的任意一个核心对象的ϵ-邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的ϵ-邻域里所有的样本的集合组成的一个DBSCAN聚类簇。
那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。
这基本上就是DBSCAN算法的主要内容了，但是还有三个问题没有考虑：
1）一些异常样本点或者说少量游离于簇外的样本点，这些点不在任何一个核心对象在周围，在DBSCAN中，我们一般将这些样本点标记为噪音点。
2）距离的度量问题，即如何计算某样本和核心对象样本的距离。在DBSCAN中，一般采用最近邻思想，采用某一种距离度量来衡量样本距离，比如欧式距离。这和KNN分类算法的最近邻思想完全相同。对应少量的样本，寻找最近邻可以直接去计算所有样本的距离，如果样本量较大，则一般采用KD树或者球树来快速的搜索最近邻。
3）第三种问题比较特殊，某些样本可能到两个核心对象的距离都小于ϵ，但是这两个核心对象由于不是密度直达，又不属于同一个聚类簇，那么如果界定这个样本的类别呢？一般来说，此时DBSCAN采用先来后到，先进行聚类的类别簇会标记这个样本为它的类别。也就是说DBSCAN的算法不是完全稳定的算法
5. DBSCAN算法步骤
下面是DBSCAN聚类算法的主要步骤
输入：样本集D=(x1,x2,...,xm)，邻域参数(ϵ,MinPts), 样本距离度量方式
输出： 簇划分C.　1）初始化核心对象集合Ω=∅, 初始化聚类簇数k=0，初始化未访问样本集合Γ = D, 簇划分C = ∅
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6067d31223f64d8f94140e837fc780c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b2595ab96580cb3e0cf57c63689bb47/" rel="bookmark">
			Linux安装Samba服务，基于Fedora
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux安装Samba服务，基于Fedora 1 安装samba服务2 启动samba服务3 更改配置信息4 使用windows系统进行连接5 其他说明 1 安装samba服务 1 关闭防火墙及关闭防火墙开机自启
[whs02@fedora ~]$ ：sudo systemctl stop firewalld.service [whs02@fedora ~]$ ：sudo disable firewalld.service 2 关闭SElinux，将SELINUX 改为disabled
[whs02@fedora ~]$ ：sudo vim /etc/selinux/config 更改后的部分文件内容
# SELINUX=enforcing SELINUX=disabled #将原来一行注释掉，新增加一行 3 安装samba服务
[whs02@fedora ~]$ ：sudo dnf install samba 2 启动samba服务 1 启动命令
[whs02@fedora ~]$ service smb start Redirecting to /bin/systemctl start smb.service 2 读取启动状态，正常运行状态是active（running）
[whs02@fedora ~]$ service smb status Redirecting to /bin/systemctl status smb.service ● smb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b2595ab96580cb3e0cf57c63689bb47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94beaab9f6141a2ff4423fdb9d2f78d/" rel="bookmark">
			统计字符串长度，strlen和sizeof有啥区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文来自公众号：C语言编程技术分享
一、练习 字符串函数strlen和运算符sizeof是我们学习C语言很常见的两个东东，也是用的比较多的。如果把这二位用在统计字符串的长度上，它们有什么区别呢？就比如这面这段C程序：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { char string[5] = {'\0'}; printf("%d ", strlen(string)); printf("%u\n", sizeof(string)); system("pause"); return 0; } 这段C程序声明了一个字符数组string，它有五个元素，每个元素的值都是空字符 \0 。然后分别用字符串函数strlen和运算符sizeof带上字符数组string作为参数，以此计算string的长度。
先运行一般，运行结果如下图所示：
字符串函数strlen的计算结果是：0
运算符sizeof的计算结果是：5
二、知识点 字符串函数strlen接一个字符数组名，表示的是该字符数组中的有效字符数，也就是非空字符的个数。
运算符sizeof接一个字符数组名，表示的是该字符数组的存储空间个数，也就是有多少个位置来放字符。
三、拓展下 那么如下的C程序会输出什么呢？欢迎留言评论。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { char string[5] = {'1', '2'}; printf("%d ", strlen(string)); printf("%u\n", sizeof(string)); system("pause"); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e301cef0fc699271085f0a991c0e6cc/" rel="bookmark">
			Vue2怎么实现响应式原理的？前端面试必知必会100题（八股文汇总）第1题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今年的就业行情不容乐观，随着一线互联网大厂的裁员潮不断涌来，流入社会的专业人士越来越多，这便导致互联网行业的就业压力和竞争越来越大，为了让各位开发者拥有更强的竞争力，这里小编把曾经总结的一些必知必会八股文分享出来，希望大家能找到心仪的工作！亲测，打遍中小厂无敌手，面试通过率高达90%~
第1题：Vue2怎么实现响应式原理的？ （主要讲的是数据双向绑定）
核心点：Object.defineProperty() 接收3个参数
defineProperty是设置对象属性，利用属性里的set和get实现了响应式双向绑定;
·
语法:Object.defineProperty(要设置的对象,要修改的对象的属性,属性描述)
·
属性描述:
1、configurable - 表示此属性能否被delete，默认false;
2、enumerable - 表示此属性能否被枚举，默认为false;
3、value - 设置此属性对应的值，默认为undefined;
4、writable - 设置value属性能否被修改值，为true时方可被改变，默认为false;
5、get - 给属性提供getter方法，默认为undefined，访问该属性时，该方法会被执行，默认参数为this 对象;
6、set - 给属性提供setter方法，默认为undefined，属性值修改时，会执行该方法，唯一参数为新的 值;
初始化时，对data对象进行遍历，用defineProperty重新定义所有属性，当页面取到对应属性时，进行 依赖收集Dep，收集当前组件的watcher,如果属性发生变化，通知相关的依赖进行更新操作update。
总结:
数据劫持结合发布者-订阅者模式的方式来实现数据的响应式。
vue在初始化的时候:在initState方法中会调取initData方法初始化data数据，对data对象进行遍历， 在这个方法中会调observe(监听器，观察者)对用户的数据进行监听，在observe中会对对象new Observe实例化创建监听，在observe中对数据进行判断:
如果是数组执行observeArray深度进行监听，继续执行observe方法，如果当前传入的是对象则执行 this.walk，对对象进行循环，重新定义对象的属性，这时使用的就是defineReactive，它是vue中的一个 核心方法，用来定义响应式。在defineReactive方法中实例化了一个Dep(发布者)，通过 Object.defineProperty对数据进行拦截，把这些 property 全部转为 getter/setter。get数据的时候，通 过dep.depend触发Watcher(订阅者)的依赖收集，收集订阅者。
如果数据是数组，执行dependArray，对数组中的每个值通过depend都添加到依赖。set时，会对数据 进行比较，如果数据发生了变化会通过dep.notify发布通知，通知watcher，更新视图。
vue源代码路径:src/core/instance/state.js src/core/observe/index.js
更多题目：后续不断更新中～可前往个人主页查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36fc3711463e2892c9cf4cb7aa35981/" rel="bookmark">
			DIFFUSIONCLIP: TEXT-GUIDED IMAGE MANIPULATION USING DIFFUSION MODELS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.DIFFUSIONCLIP: TEXT-GUIDED IMAGE MANIPULATION USING DIFFUSION MODELS(使用扩散模型的文本引导图像处理)
机构：韩国高等科学技术研究院
github:GitHub - gwang-kim/DiffusionCLIP: [CVPR 2022] Official PyTorch Implementation for DiffusionCLIP: Text-guided Image Manipulation Using Diffusion Models
2.介绍和摘要：
摘要：
扩散模型是最近的生成模型，在具有最新性能的图像生成中显示出巨大的成功。然而，对于使用扩散模型进行图像处理的研究很少。在这里，我们提出了一种新颖的DiffusionCLIP，它使用对比语言-图像预训练 (CLIP) 丢失，使用扩散模型执行文本驱动的图像处理。对于域内外图像处理任务，我们的方法具有与现代基于GAN的图像处理方法相当的性能，即使没有额外的编码器或优化，也具有几乎完美的反演优势。此外，我们的方法可以轻松地用于各种新颖的应用程序，从而可以将图像从看不见的域转换为另一个看不见的域，或者在看不见的域中生成笔画条件的图像，等等。最后，我们通过结合多个微调的扩散模型，提出了一种新颖的带有扩散剪辑的多属性控制。
3.diffusionClip
用于图像处理的 DiffusionCLIP 的整体流程如图 2 所示。这里，输入图像 x0 首先通过前向扩散转换为潜在 xl。然后，在 CLIP 损失的指导下，对扩散模型进行微调，并从微调扩散模型生成更新样本。在扩散模型微调方面，可以修改潜在模型或扩散模型。在这项工作中，我们发现直接模型微调更有效，这将在后面的实验中显示.
其中x0是原始图像，而这些参数为优化参数 的被操纵图像，tref是参考文本，ttar是要操纵的目标文本.
我们使用以下由 CLIP 损失和身份损失组成的目标
direction loss
id loss
其中 Lface 是人脸身份损失 (Deng et al., 2019)。 λL1 &gt; 0 和 λface &gt; 0 是每个损失的权重参数。身份丢失的必要性取决于控件的类型。对于某些控件，像素相似性和人类身份的保留很重要（例如表情、头发颜色），而其他控件则更喜欢剧烈的形状和颜色变化 4.EXPERIMENTAL RESULTS
对于 DiffusionCLIP 的所有操作结果，我们使用 256×256 大小的图像。我们使用在 CelebA-HQ (Karras et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36fc3711463e2892c9cf4cb7aa35981/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87c422b4b56d36a523cc6977cbaf4f4/" rel="bookmark">
			unity实现坦克对战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI坦克建模 感知
在游戏中，程序是可以获得游戏世界任意信息的，设计一个杀死玩家的算法通常是比较容易的，因此如何限制信息获取是设计不同级别 agent 的核心问题。在AI坦克大战的游戏中，AI坦克获取的信息是通过视觉（Vision）得到的。每个AI坦克获取的信息是导航信息，但是因为有障碍物的阻挡，使得AI坦克不会“一窝蜂”的同时涌向玩家。同时，AI坦克并不能实时瞄准玩家，也增加了游戏的可玩性。
思考
主要使用了Unity自带的寻路组件Navigation 进行“思考”寻路。
行动
每个AI坦克都会发射子弹，但是不能让AI坦克一直发射子弹，这样就没得玩了。所以会有一个子弹的准备时间，每间隔一段时间再发射子弹。同时地形凹凸不平，也会使得子弹的轨迹有所偏差。
游戏实现 1. 下载资源 从Assets Store下载tanks tutorial资源
2.动作状态机 3. 制作地图 将想要的颜色所对应的材质拖到地图上
最终地图为
4. 制作子弹 Bullet 实现了子弹的相关设计，设置了子弹的爆炸范围，对于玩家和敌方坦克，子弹会有不同的伤害
using System.Collections; using System.Collections.Generic; using UnityEngine; // 子弹设置 √ public class Bullet : MonoBehaviour { // 设置爆炸范围 public float range = 3.0f; private TankType tankType; // 设置坦克的类型 public void setTankType (TankType type) { tankType = type; } // 设置碰撞事件 private void OnCollisionEnter (Collision collision) { // 打到自己不算 if (collision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b87c422b4b56d36a523cc6977cbaf4f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5693546ed7e321b0d8cf7fccbcdbf4b/" rel="bookmark">
			排序算法简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 常见的排序算法有冒泡排序、插入排序、选择排序、快速排序、归并排序、桶排序、基数排序，这些排序各自有各自的特点。按照时间时间复杂度可以分为
O(n^2):冒泡、插入、选择排序；O(nlogn):归并、快速排序；O(n):桶排序、计数排序、基数排序； 二、如何分析一个排序算法 最好、最坏、平均情况下的时间复杂度；时间复杂度的常数、系数、低阶；比较次数和交换（移动次数）；堆内存的消耗：针对空间复杂度，引入原地排序概念，就是指空间复杂度为O(1)的算法；排序的稳定性：原序列中相同值数据的前后顺序在排序后会不会被打乱，分为稳定排序和不稳定排序； 三、冒泡排序 每次八前后两个元素比较，判断是否需要互换，一直到序列最后面，这样重复n次。最好情况在第一次排序后看有没有数据交换，如果没有的话说明此时已经有序了，时间复杂度时O(n^2)。 平均时间复杂度也是O(n^2)。
四、插入排序 将数据分为有序区间和无序区间，开始有序区间只有一个元素，然后从后面无序区间区第一个元素插入到有序区间中对应的位置。是原地排序，当遇到相同值时可以选择位置前后的防止，所以是稳定排序。可以选择从有序区间后面开始进行大小的比较，所以最好情况下时间复杂度为O(n)，平均和最坏情况下时间复杂度都是O(n^2)。
相对于冒泡排序，插入排序在每次数据的移动比冒泡排序的数据交换简单，因此插入排序忧郁冒泡排序。
五、选择排序 将数据分为有序区间和无序区间，每次从无需区间找到最小值，放到有序区间的后面。空间复杂度是原地排序。不是稳定排序
六、归并排序 将序列递归的差分为左右两个区间，直到区间不能再拆分，然后在每次回归时将左右两个有序区间合并排序（类似两个有序链表的合并）。
//A是数组，n是数组大小 merge_sort(A, n) { merge_sort_c(A, p, r); } //A是数组，p是开始位置，r是结束位置 merge_sort_c(A, p, r) { if(q &gt;= r) { return; } q = (p + r) / 2; merge_sort_c(A, p, q); merge_sort_c(A, q+1, r); //将有序区间A[p, q],和A[q+1, r]合并为 A[p, r] merge(A[p, q], A[q+1, r], A[p, r]); } 对于merge(A[p, q], A[q+1, r], A[p, r])合并函数设计思路：建立一个大小为[p, r]的临时数组temp，将A[p, q], A[q+1, r]中数据按照大小一次放入，然后将temp的值赋给A[p, r]。因此归并排序不是原地排序。当[p, q], A[q+1, r]存在相同值时，我们可以选择总是将[p, q]的值放在前面，从而保证了数据的稳定性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5693546ed7e321b0d8cf7fccbcdbf4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e214eef91482226e702282e81025cf5e/" rel="bookmark">
			递归和排序算法的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、递归常见问题和注意事项 1. 堆栈溢出；
2. 警惕重复运算：
可以使用一个数据结构（散列表）将已经计算过的f(k)保存起来，每当调用到f(k)时，先产看下是否已经求结果，从而避免重复计算。
3. 将递归代码修改为非递归代码
二、冒泡、插入、选择排序 时间复杂度都是O(n^2)；
**稳定性：**原序列中相同值得元素，经过排序后前后顺序不变；
**原地排序：**空间复杂度O(1)；
冒泡排序：每次便利剩余的全部找出剩余最小的值；
插入排序：前面是有序的，从后面序列拿出最前面的元素插入到前面有序队列中合适的位置。分为已排序空间和未排序空间；
选择排序：分为已排序空间和未排序空间，从未排序空间找出最小值放入已排序空间的末尾；
插入排序相对于冒泡排序的优势？
冒泡排序中数据的交换操作： if (a[j] &gt; a[j+1]) { // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; } 插入排序中数据的移动操作： if (a[j] &gt; value) { a[j+1] = a[j]; // 数据移动 } else { break; } 使用冒泡排序需要K次交换操作，每次交换需要3次赋值语句，所需时间为3*k，而插入排序只需要K个时间。
三、归并排序和快速排序 归并排序：先分解，再合并。将数组采用递归的思想从中间分解拆分，知道不能拆分，然后再将拆分的进行排序后合并，使用分治思想。
归并排序可以使稳定排序
// 归并排序算法, A是数组，n表示数组大小 merge_sort(A, n) { merge_sort_c(A, 0, n-1) } // 递归调用函数 merge_sort_c(A, p, r) { // 递归终止条件 if p &gt;= r then return // 取p到r之间的中间位置q q = (p+r) / 2 // 分治递归 merge_sort_c(A, p, q) merge_sort_c(A, q+1, r) // 将A[p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e214eef91482226e702282e81025cf5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94bbd7ba431903cbf96cf03e82a61c22/" rel="bookmark">
			socket学习一、socket、bind/connect、listen函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Socket是什么？ Socket本意是插座，在计算机通信领域中被翻译为“套接字”，是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。通过Socket，两台计算机可以通过网络进行信息的传递。
头文件：&lt;sys/socket.h&gt;
详细教程见：socket()函数
二、socket()函数 2.1、函数定义 int socket (int af, int type, int protocol); 作用： 用来创建套接字，确定套接字的各种属性，以进行网络通信。
2.2、参数详解： 1) int af： 地址族(Address Family)，又称协议族，也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6，分别代表IPv4地址和IPv6地址。
2) int type： 数据传输方式或套接字类型，最常见的有SOCK_STREAM和 SOCK_DGRAM。
SOCK_STREAM：面向连接的数据传输方式，是基于TCP的协议；SOCK_DGRAM：无连接的数据传输方式，是基于UDP的协议。 3) int protocol： 传输协议。对应上述的type，常用的有IPPROTO_TCP 和 IPPTOTO_UDP，分别代表TCP和UDP协议。系统会根据af与type的值自行选择protocol，因此该项一般可直接指定为0。
2.3、返回值： int 类型的套接字文件描述符。
2.4、使用方法： int serv_sock = socket(AF_INET, SOCK_STREAM, 0); 2.5、参考资料： 1、socket()函数用法详解：创建套接字
三、bind()函数 3.1、函数定义 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 作用： 用于服务端将通信的地址和端口绑定到 socket上。只有这样，流经该 ip地址和端口的数据才能交给该socket处理。
3.2、参数详解： 1) int sockfd： 用来标识服务端套接字，由socket函数返回的文件描述符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94bbd7ba431903cbf96cf03e82a61c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a04b2bccb1b4f1c11a3dcfbaed182566/" rel="bookmark">
			which is not on PATH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：执行pip3 install virtualenv
出现WARNING错误，如下：
WARNING: The script virtualenv is installed in ‘/home/local/bin’ which is not on PATH.
Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
解决办法：
echo ‘export PATH=/home/xxx/bin:$PATH’ &gt;&gt;~/.bashrc
1
source ~/.bashrc
1
其中“/home/xxx/bin”为WARNING提示的PATH
然后卸载掉刚才安装的包，并重新安装：
pip3 uninstall virtualenv
1
pip3 install virtualenv
————————————————
版权声明：本文为CSDN博主「可爱的煤气罐」的原创文章。
原文链接：https://blog.csdn.net/qq_33659001/article/details/109438291
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2060292ee33289d497dc3d3f2b48149e/" rel="bookmark">
			【网络教程】Iptables官方教程-学习笔记5--IPTABLES MATCH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇博客介绍iptables和netfilter中所有可用的匹配，章节比较厂，没必要去学习每个匹配的具体细节，大致了解下即可，后续要用到再深入掌握它。
一 、Iptables 的匹配(match) 在本篇中，我们将讨论更多关于匹配的内容。我选择将匹配范围缩小到五个不同的子类别。首先我们有通用匹配，它可以在所有规则中使用。然后我们有TCP匹配，它只能应用于TCP数据包。UDP匹配只适用于UDP报文，ICMP匹配只适用于ICMP报文。最后，我们有特殊的匹配，例如状态、所有者和限制匹配等等。
前面几篇内容中，我们已经了解过，匹配是在包中指定一个必须为真(或假)的特殊条件。一条规则可以包含任意类型的多个匹配。例如，我们可能想要匹配来自本地网络上特定主机的数据包，而在此基础上只匹配来自该主机上特定端口的数据包。然后，我们可以使用匹配来告诉规则只对具有特定源地址的数据包应用目标(或跳转)规范，这些数据包从连接到LAN的接口进入，并且数据包必须是指定的端口之一。如果其中任何一个匹配失败(例如，源地址不正确，但其他一切都是正确的)，整个规则失败，并在包上测试下一个规则。但是，如果所有匹配都为真，则应用规则指定的目标。
1.1 通用匹配 通用匹配（generic match ）指不管是什么协议，或者加载了什么插件，通用匹配项一直有效。通用匹配项也不需要什么特殊的参数。换句话说。我们在这里还包括–protocol 匹配，尽管它更特定于协议匹配。例如，如果我们想使用TCP匹配，我们需要使用–protocol匹配并将TCP作为一个选项发送给匹配。然而，–protocol本身也是一个匹配，因为它可以用来匹配特定的协议。
表1
匹配(match)-p, --protocol内核(kernel)2.3, 2.4, 2.5 and 2.6示例(example)iptables -A INPUT -p tcp释义该项匹配用于检查某些协议，协议的例子有TCP、UDP和ICMP。协议必须是内部指定的TCP、UDP或ICMP之一。也可以用数值定义，ICMP为1，TCP为6，UDP为17，取0意味着所有协议。该匹配可以用!表示取反，即–protoclol ! tcp表示匹配UDP和ICMP匹配(match)-s, --src, --source内核(kernel)2.3, 2.4, 2.5 and 2.6示例(example)iptables -A INPUT -s 192.168.1.1释义源地址匹配，基于数据包的源地址进行匹配。主表单可用于匹配单个IP地址，如192.168.1.1。它还可以与CIDR“位”形式的网络掩码一起使用，具体方法是在网络掩码左侧指定1(1)的数量。这意味着，例如我们可以添加/24来使用255.255.255.0的网络掩码。然后我们可以匹配整个IP范围，例如我们的本地网络或防火墙后的网段。 比如192.168.0.0/24，将匹配192.168.0.x范围。另一种方法是使用255.255.255.255形式的常规网络掩码(即192.168.0.0/255.255.255.0)。!表示取非，即–source !192.168.0.0/24,我们将匹配所有源地址不在192.168.0.X内的包。默认情况是匹配所有IP地址的包匹配(match)-d, --dst, --destination内核(kernel)2.3, 2.4, 2.5 and 2.6示例(example)iptables -A INPUT -d 192.168.1.1释义基于目的地址进行匹配数据包。它的工作原理与——source匹配非常相似，并且具有相同的语法，除了匹配是基于包的去向。为了匹配一个IP范围，我们可以添加一个精确的网络掩码形式的网络掩码，或者添加一个从网络掩码位左侧计数的1(1)的数量。例如:192.168.0.0/255.255.255.0和192.168.0.0/24。另外：–d destination ! 192.168.0.1将匹配除192.168.0.1 IP地址外的所有数据包匹配(match)-i, --in-interface内核(kernel)2.3, 2.4, 2.5 and 2.6示例(example)iptables -A INPUT -i eth0释义用于匹配数据包进入时的接口。注意，此选项仅在INPUT、FORWARD和PREROUTING链中合法，在其他任何地方使用时将返回错误消息。如果没有指定特定的接口，此匹配的默认行为是假定字符串值为+。+值用于匹配由字母和数字组成的字符串。换句话说，一个+将告诉内核匹配所有数据包，而不考虑它是从哪个接口进入的。字符串+还可以附加到接口类型后，因此eth+将是所有以太网设备。-i !eth0表示匹配所有进入接口，除了eth0匹配(match)-o, --out-interface内核(kernel)2.3, 2.4, 2.5 and 2.6示例(example)iptables -A FORWARD -o eth0释义–out-interface匹配用于配数据包离开时所在的接口。它与–in-interface相反，因此只能用在OUTPUT、FORWARD和POSTROUTING链。扩展名+被理解为匹配所有类似类型的设备，因此eth+将匹配所有eth设备。如果没有指定–out-interface,默认匹配所有设备，不管数据包去往何处匹配(match)-f, --fragment内核(kernel)2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2060292ee33289d497dc3d3f2b48149e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5efd54083aefea51c308c177903c851/" rel="bookmark">
			异步请求-AJAX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是同步交互
首先用户向HTTP服务器提交一个处理请求。接着服务器端接收到请求后，按照预先编写好的程序中的业务逻辑进行处理，比如和数据库服务器进行数据信息交换。最后，服务器对请求进行响应，将结果返回给客户端，返回一个HTML在浏览器中显示，通常会有CSS样式丰富页面的显示效果。
优点
可以保留浏览器后退按钮的正常功能。在动态更新页面的情况下，用户可以回到前一个页面状态，浏览器能记下历史记录中的静态页面,用户通常都希望单击后退按钮时，就能够取消他们的前一次操作，同步交互可以实现这个需求.
缺点
1同步交互的不足之处，会给用户一种不连贯的体验，当服务器处理请求时，用户只能等待状态，页面中的显示内容只能是空白。
2因为已经跳转到新的页面,原本在页面上的信息无法保存,好多信息需要重新填写
什么是异步交互
指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式。将用户请求放入消息队列，并反馈给用户，系统迁移程序已经启动，你可以关闭浏览器了。然后程序再慢慢地去写入数据库去。这就是异步。异步不用等所有操作等做完，就响应用户请求。即先响应用户请求，然后慢慢去写数据库，用户体验较好
优点
1前端用户操作和后台服务器运算可以同时进行,可以充分利用用户操作的间隔时间完成运算
2页面没有跳转,响应回来的数据直接就在原页面上,页面原有信息得以保留
缺点
可能破坏浏览器后退按钮的正常行为。在动态更新页面的情况下，用户无法回到前一个页面状态，这是因为浏览器仅能记录的始终是当前一个的静态页面。用户通常都希望单击后退按钮，就能够取消他们的前一次操作，但是在AJAX这样异步的程序，却无法这样做。
1.AJAX介绍 AJAX 即
“Asynchronous Javascript And XML”（异步 JavaScript和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
AJAX关键技术
使用CSS构建用户界面样式,负责页面排版和美工使用DOM进行动态显示和交互,对页面进行局部修改使用XMLHttpRequest异步获取数据使用JavaScript将所有的元素绑定在一起 AJAX的最大的特点: 异步访问,局部刷新
AJAX之验证用户名是否被占用
JS表单验证只能校验格式是否正确,但是无法验证用户名是否已经存在,这个就需要后台程序接受到数据后通过查询才能够完成的,那么这里就非常适用于使用异步方式校验,保证用于数据提交后,业务完成的成功率.提升用于体验感
代码示例:
jsp代码
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title%sSourceCode%lt;/title&gt; &lt;script&gt; var xhr ; function checkUname(){ // 获取输入框中的内容 var unameDOM=document.getElementById("unameI"); var unameText =unameDOM.value; var unameInfoDom =document.getElementById("unameInfo"); if(null == unameText || unameText == ''){ unameInfoDom.innerText="用户名不能为空"; return; } unameInfoDom.innerText=""; // 发送异步请求 // 获取一个 XMLHttpRequest对象 ,对象可以帮助我们发送异步请求 xhr =new XMLHttpRequest(); // 使用xhr对象设置打开链接,设置请求方式和参数xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5efd54083aefea51c308c177903c851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12269a1f9527efbacfbeadc529c56cf8/" rel="bookmark">
			nacos启动一闪而过？可能是你的目录中带了特殊字符！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos启动一闪而过？可能是你的目录中带了特殊字符 例如&amp;符号，nacos按照教程配置了很久，启动页面一闪而逝，bin下的logs内也没有错误日志，见了鬼了，无意间看了下bin目录地址，难道是目录名字中带了特殊符号或者中文，redis&amp;nacos，没错，改了这个缺德的命名目录，就可以了。以后目录再也不加特殊符号了，找问题都是懵逼的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a01b5cdc3681271b104a8036e152708/" rel="bookmark">
			Mybatis&#43;Mybatis-plus&#43;SpringBoot整合(完整版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Mybatis（一）Mybatis简介1、Mybatis历史2、Mybatis特性3、Mybatis下载4、和其它持久化层技术对比 （二）搭建Mybatis1、MySQL不同版本的注意事项2、创建Maven工程1、引入依赖 3、创建MyBatis的核心配置文件3.1、核心配置文件的作用3.3、核心配置文件存放的位置3.4、核心配置文件中的标签必须按照固定的顺序：3.5、核心配置文件详解 4、创建mapper接口5、创建MyBatis的映射文件5.1、相关概念：1、ORM（Object Relationship Mapping）对象关系映射。2、映射文件的命名规则：3、MyBatis映射文件的作用和目的：4、MyBatis映射文件存放的位置：5、MyBatis映射文件中标记的说明6、MyBatis中可以面向接口操作数据，要保证两个一致：7、Mybatis映射文件如下 6、通过junit测试功能（mapper接口是如何去对应mybatis映射文件及如何去执行对应的sql语句的流程） （三）log4j日志功能1、log4j的依赖2、log4j的配置文件3、日志的级别 （四）在Idea中创建模板的方法1、方法2、模板 （五）MyBatis获取参数值的两种方式1、概念2、单个字面量类型的参数3、多个字面量类型的参数4、map集合类型的参数5、实体类类型的参数6、使用@Param标识参数7、总结 （六）MyBatis的各种查询功能1、查询多条数据为map集合2、模糊查询的三种方案3、批量删除4、动态设置表名5、添加功能获取自增的主键 （七）自定义映射resultMap1、resultMap中标签及属性的用法2、处理字段名和属性名不一致的三种方法方法一：可以通过为字段起别名的方式，保证和实体类中的属性名保持一致方法二：可以在MyBatis的核心配置文件中设置一个全局配置信息方法三：使用resultMap自定义映射处理 3、一对一或多对一映射处理（属性中存在另一个类的对象）方法一：级联方式处理一对一或多对一映射关系方法二：使用association处理一对一或多对一映射关系方法三：分步查询处理一对一或多对一映射关系 4、分布查询的优点：5 、使用延迟加载的原因及配置 （八）一对多映射处理方法一：collection处理一对多查询方法二：分步查询处理一对多查询 （九）动态SQL1、if2、where3、trim4、choose、when、otherwise5、foreach （十）MyBatis的缓存1、MyBatis的一级缓存(是默认开启的)2、MyBatis的二级缓存（需要手动开始）3、二级缓存的相关配置（了解）4、MyBatis缓存查询的顺序5、整合第三方缓存EHCache5.1、添加依赖5.2、创建EHCache的配置文件ehcache.xml5.3、设置二级缓存的类型5.4、各jar包功能5.5 、EHCache配置文件说明5.6、加入logback日志 （十）MyBatis的逆向工程1、创建逆向工程的步骤①添加依赖和插件②创建MyBatis的核心配置文件③创建逆向工程的配置文件④执行MBG插件的generate目标（双击mybatis-generatot:generate） 2、逆向工程清新简洁版和奢华尊享版3、奢华尊享版的使用，有时需要使用QBC查询 （十一）分页插件1、分页插件的使用步骤①添加依赖②在MyBatis的核心配置文件中配置分页插件 2、分页插件的使用 （十二）Mybatis的注解式编程 二、Mybatis-plus及和SpringBoot的整合1、简介2、特点3、支持数据库1、简介2、特点3、支持数据库 三、SpringBoot整合Mybatis四、SpringBoot整合Mybatis-plus 一、Mybatis （一）Mybatis简介 1、Mybatis历史 1、MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。
2、MyBatis是一个持久层的框架（就是DAO与数据库的交互），MyBatis也叫半自动的ORM框
架，ORM(Object Relational Mapping):数据库的表与java对象domain之间的映射关系
2、Mybatis特性 1） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架
2） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集
3） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录
4） MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架
3、Mybatis下载 MyBatis下载地址：https://github.com/mybatis/mybatis-3
解压之后的目录：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a01b5cdc3681271b104a8036e152708/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c0867db0338cf4928958636e2f6be4/" rel="bookmark">
			mongodb官网下载不了， MongoDB下载、安装、配置、使用，如何下载MongoDB数据库，MongoDB入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、关于MongoDB数据库：
二、MongoDB数据库下载：
1、官方下载地址： Try MongoDB Atlas Products | MongoDB
2、其他下载方式：除了上面的下载方式以外，也可以试试下面的下载链接！！
三、MongoDB数据库的安装：
四、MongoDB数据库可视(图形)化管理工具：
1、下载地址：MongoDB Compass Download | MongoDB
2、注意事项：在MongoDB Compass选择下载时，可选择对应的系统版本（这里以windows系统为例）：
五、文件功能解释：
1、MongoDB v3.6版安装目录的文件
2、 MongoDB v4.4版安装目录文件
六、环境变量配置：
1、配置MongoDB全局环境变量（就是在电脑中任何地方都可以合用mongo、mongod等命令）！
2、MongoDB数据库中的常用述语：
3、进入MongoDB数据库的语法环境：
七、MongoDB账户权限配置：
1、创建MongoDB超级管理用户：
2、修改MongoDB数据库配置：
3、重新启动MongoDB服务
4、用刚才创建好的超级管理账户连接数据库：
5、给指定的数据库存配置账户：
6、连接指定的MongoDB数据库
八、MongoDB数据库常用命令：
1、查看所有数据库：
2、查看当前所在数据库：
3、查看当前所在数据库中所有集合：
4、查看当前数据库相关信息（名称、文档个数、视图、索引、大小等）：
5、创建、打开、切换 数据库：
6、删除数据库（注：这里是删除当前所在的数据库）
7、清屏（这是Dos的命令，当窗口中的内容太多时，可以使用该命令，清除屏幕内容，保持界面清晰）：
8、MongoDB 数据库备份与恢复，集合导入与导出：
9、操作帮助命令（列出MongoDB数据库所有的操作方法）
九、启动 或 创建 指定的MongoDB数据库：
1、使用 mongod 命令： 创建 或 启动 指定的MongoDB数据库！
2、如果mongodb数据库路径太长，要输入很久，还可这样做
3、注意事项：
十、MongoDB数据库-复制集
1、为什么要用复制集？
2、在windows系统下搭建MongoDB复制集：
3、启动复制集节点
4、关联复制集节点
5、查看从节点是否正常同步数据
十一、MongoDB数据库-模型设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c0867db0338cf4928958636e2f6be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcefb65122b6e1c814a96315fab2b129/" rel="bookmark">
			Android中SQLite数据库查询详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLite在线教程网址https://www.yiibai.com/sqlite
文章目录 SQLite中查询方法query（）查询全部数据示例一些查询用法示例 rawQuery查询select语句查询 Android SQLite的增删改查详解链接 SQLite中查询方法query（） query(String table, String[] columns, String selection, String [] selectionArgs, String groupBy, String having, String orderBy, String limit) table ：表名。相当于select *** from table语句中的table 。如果是多表联合查询，可以用逗号将两个表名分开。columns ：要查询出来的列名（字段），全部查询就写null。相当于 select *** from table语句中的 ***部分 。如果是查询多个参数，可以用逗号将两个表名分开。例：new String[]{“name”,“age”,“sex”}selection：查询条件子句，相当于select *** from table where &amp;&amp; 语句中的&amp;&amp;部分，在条件子句允许使用占位符“?”表示条件值 ，例：“name=?,age=?,sex=?”selectionArgs ：查询条件对应的内容。对应于 selection参数 占位符的值，值在数组中的位置与占位符在语句中的位置必须一致，否则就会有异常。 例：与 new String[]{“lisa”,“1”,“女”}groupBy ：分组。相当于 select *** from table where &amp;&amp; group by … 语句中 … 的部分 ，作用是：将同一列的相同名字的参数合并在一起 例;在name列有两个Jame（name:Jame --salay:100，name:Jame --salay:200）,使用…group by name查询后 只显示一个Jame的集合（name:Jame–salay:300）having ：相当于 select *** from table where &amp;&amp; group by …having %%% 语句中 %%% 的部分， 作用于groupBy的条件，例：havig name&gt;2意思是name列相同参数&gt;2orderBy ：相当于 select ***from ？？ where&amp;&amp; group by …having %%% order by@@语句中的@@ 部分，如： personid desc（按person 降序）, age asc（按age升序）;limit：指定偏移量和获取的记录数，查询显示的条数（分页，可以不写，默认全部显示）。相当于select语句limit关键字后面的部分。 查询全部数据示例 /** * 查询全部数据 */ public List&lt;PersonModel&gt; queryAllPersonData(){ //查询全部数据 Cursor cursor = getWritableDatabase().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcefb65122b6e1c814a96315fab2b129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a581d6a864a1de7149c0a942b6c2743a/" rel="bookmark">
			Linux AP3216C驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux AP3216C驱动 1. 介绍2. 代码3. 设备树4. 运行 AP3216C是一个近距离环境光传感器，包含了光强传感器（ALS:AmbientLight Sensor），接近传感器（PS: Proximity Sensor），还有一个红外LED（IR LED）。
1. 介绍 AP3216C是通过IIC进行操作的，操作地址为0x1E，芯片有多种工作模式使用，详细的寄存器操作可以阅读芯片手册。我这里利用IIC子系统和IIO子系统进行开发，向应用层提供的sysfs接口。
2. 代码 // SPDX-License-Identifier: GPL-2.0-only #include &lt;linux/kernel.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/device.h&gt; #include &lt;linux/i2c.h&gt; #include &lt;linux/regmap.h&gt; #include &lt;linux/iio/iio.h&gt; #include &lt;linux/iio/sysfs.h&gt; #include &lt;linux/iio/buffer.h&gt; #include &lt;linux/iio/trigger.h&gt; #include &lt;linux/iio/triggered_buffer.h&gt; #include &lt;linux/iio/trigger_consumer.h&gt; #define AP3216C_REGMAP_NAME	"ap3216c_regmap" #define AP3216C_DRV_NAME	"ap3216c" #define AP3216C_SYSTEMCONG	0x00	/* System Configuration */ #define AP3216C_INTSTATUS	0X01	/* Interrupt Status */ #define AP3216C_INTCLEAR	0X02	/* INT Clear Manner */ #define AP3216C_IRDATALOW	0x0A	/* IR Data Low */ #define AP3216C_IRDATAHIGH	0x0B	/* IR Data High */ #define AP3216C_ALSDATALOW	0x0C	/* ALS Data Low */ #define AP3216C_ALSDATAHIGH	0X0D	/* ALS Data High */ #define AP3216C_PSDATALOW	0X0E	/* PS Data Low */ #define AP3216C_PSDATAHIGH	0X0F	/* PS Data High */ #define AP3216C_ALSCONFIG	0X10	/* ALS Configuration */ #define AP3216C_PSCONFIG	0X20	/* PS Configuration */ #define AP3216C_PSLEDCONFIG 0X21	/* PS LED Driver */ enum ap3216c_idx { AP3216C_ALS, AP3216C_PS, AP3216C_IR, }; struct ap3216c_data { struct i2c_client *client; struct iio_dev *indio_dev; struct mutex lock; struct regmap *regmap; }; static const struct regmap_config ap3216c_regmap_config = { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a581d6a864a1de7149c0a942b6c2743a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9499240d51ffec9ed69502b6d94365/" rel="bookmark">
			【一包通刷】晶晨S905L3A/B_完美AI语音线刷包_打开ADB_ROOT权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【9.0一包通刷】晶晨S905L3A/B_完美AI语音线刷包_默认打开ADB ROOT权限支持游戏启动_万物互联启动动画
适用型号：M401A、CM311-1a、CM311-1sa、B863AV3.1-M2、B863AV3.2-M、UNT403A、M411A等等；
系统版本：Android9
系统桌面：超级桌面
说明：（自备短接神器或网上自查每个型号各自的短接点） 1、9.0通刷包，烧录时默认打双勾；
2、设备型号显示Tvbox；
3、预装最新语音插件；
4、默认打开ADB ROOT权限 可切换游戏系统；
5、首页，指示灯正常；
6、华为万物互联启动动画。
固件特点：
1、修改dns，三网通用；
2、开放原厂固件屏蔽的市场安装和u盘安装apk；
3、无开机广告，无系统更新，不在被强制升级；
4、大量精简内置的没用的软件，运行速度提升30%以上，多出大量的存储空间； 刷机固件： 链接1：https://pan.baidu.com/s/1MDsbR7fBxLgX18teFFEUyg 提取码：nph3 链接2：https://wwt.lanzoux.com/b021zsq3g 提取码：g31g 声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/120/">«</a>
	<span class="pagination__item pagination__item--current">121/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/122/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>