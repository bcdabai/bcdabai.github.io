<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e3decb467744831632639568129dccd/" rel="bookmark">
			QST青软实训学员学习总结-2020/4/22-ZigBee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时光飞逝，日月如梭，时间滴答滴答的就过去了。
转眼间就迎来了四月的尾声，我国国内的疫情情况呈逐渐向好的方向，外防输入，内防反弹。成为我国当前防疫工作的主要目标。但纵观世界的疫情局面任然严峻，我们还是不能掉以轻心。我国加快复工复产的节奏更快了，各个省市直辖市的初中、高中已经开学，有的省市也在为学校开学筹备相应的计划，武汉也得以解封，整个城市整个被新冠病毒打压患者，都在慢慢好起来。至此，我依然还想对那些义无反顾的白衣天使们，致以最崇高的敬意。
今天内蒙古自治区教育厅发出通知：5月13日起，经评估达到开学复课疫情防控标准的高等院校，可以安排开学复课。这条通知的发出，评论区瞬间炸开了锅，众多大学生感叹到：幸好我没有放弃，终于等到你！可我依然高兴不起来，因为我在苦等山东青岛的开学复课通知，希望早日能得到你消息！亲！
在四月份的网课学习中，主要是以《ZigBee技术开发》这门课程开展学习的。我认为学习ZigBee技术与之前所学的其他技术有一个很明显区别，之前我们在学习《单片机》课程，我们就是要学会熟练掌握相关MCU的一些基础功能。就比如我们在学习STC89S52时，我们主要的一些实验就是一些对GPIO、串口通信、定时器/计数器，还有相关的LED、LCD、DS18B20温度传感器的驱动和使用方法。其实本质就是看着数据手册对各个寄存器去赋值罢了。而对于学习ZigBee技术来说是CC2530 MCU + Z_Stack。
CC2530结合了RF 收发器的优良性能，业界标准的增强型8051 CPU，系统内可编程闪存，8-KB RAM 和许多其它强大的功能。CC2530 具有不同的运行模式，使得它尤其适应超低功耗要求的系统。和我们之前所学的STC89S52都是8051的内核，这一点对我们来说对CC2530的学习就更加熟悉了。有一些区别就是功能更多了更强大了，比如：有RF收发器、DMA读写、ADC采集、睡眠定时器等功能。一下是我对一些突出学习问题的总结：
1.关于中断服务子程序的编辑写。
1）不要在中断里使用for/while …类似的循环语句。
2）不要在中断里运算float…。
3）不要在中断里解释UART的数据。
4）尽量不要在中断中设置EA=0/1。
5）中断服务子程序的代码越短越好，要简洁高效。
：因为中断的产生会打断原本CPU的正常运行流程，在进入中断后应该尽可能的快速跳出中断，更少的占用CPU资源，才能减少对CPU的影响，所以类似的循环、大量的运算，数据转换，我们可以利用协议栈中消息、事件的方法来实现，中断里也可以执行osla_start_timerEx()…这样的软定时，通过这个函数再去触发事件。
Z_Stack协议栈是我们第一次所接触的知识点，ZigBee协议栈就是将各个层定义的协议都集合在一起，以函数的形式实现，并给用户提供一些API，给用户调用。Z-Stack协议栈一个核心就是OSAL操作系统。
OSAL操作系统是一个基于任务轮询方式的操作系统，其任务调度和资源分配由操作系统抽象层OSAL管理着。在任务轮询过程中，系统将会不断查询每个任务是否有事件发生，如果有事件发生，就执行相应的事件处理函数，如果没有事件发生，则查询下一个任务。深入理解OSAL的调度机制和工作机理，是灵活应用Z-Satck协议栈进行Zigbee无线应用开发的重要基础。关键是要理解任务初始化函数osalInitTasks()、任务标识符taskID、任务事件数组taskEvents[]和任务事件处理函数指针数组tasksArr[]之间的对应关系以及它们在OSAL运行过程中的执行情况。
总之对于Zigbee技术的学习，Z_Stack协议栈毫无疑问是一块比较难啃的骨头，学习就是从一切的未知开始，进行不断的摸索，寻找解决问题的突破口，从而对这个问题加深印象，积累经验，学习不再是从入门到“入土”，而是让我们一起携手打开ZigBee的大门，从入门到“巅峰”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8dd8cc48de4fdfbbe97571891661cd0/" rel="bookmark">
			Wireshark安装及使用--捕获不到无线接口怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载和安装Wireshark Wireshark下载连接：Wireshark下载官网 ##选择最新的版本下载
下载完毕后除了Install USBPcap可以不用勾选外，其余可以选择默认或全选
二、打开Wireshark并使用 打开wireshark后会发现没有任何接口可以捕获，原因是：你没有下载WinPcap
win10的小伙伴们，要注意！！！在装了Win10Pcap之后，WireShark里面可捕获的并没有无线接口！
通过输入net start npf会发现
“服务名无效，请输入NET HELPMSG 2185 以获得更多的帮助” ，即并没有NPF这个服务，需要自己手动安装
自己再手动装麻烦太多了！
最好的解决方案是：卸载掉Win10Pcap，重新安装旧版本的WinPcap，下载自然会带上NPF这个服务了
下载地址：WinPcap_4_1_3--此处跳转到华军软件园的下载入口，直接下载即可
下载完成后，解压并安装WinPcap
此时再输入net start npf服务就会被启用成功
WireShark里面的接口除了蓝牙、以太网就会出现本地连接和WLAN可以被捕获了！！亲测有效！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/536f5d6eaccd3872ee70988316db2631/" rel="bookmark">
			web.xml配置cookie-config的secure为true时引发的血案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个普通的不能再普通的登录场景：登录成功之后把用户信息放入session：
request.getSession().setAttribute("antiUser", user); 以后使用的时候再从session里面取出：
AntiUser antiUser = (AntiUser)request.getSession().getAttribute("antiUser"); 本地运行没有任何问题，开玩笑，搞了那么多年java，这点功能还不是小意思？但是，接下来问题来了，当把项目部署到测试环境上之后，死活都从session里面取不到值，开始郁闷，没有网上说的ajax跨域问题，这到底是为什么呢？
查看f12开发者工具发现如下现象：
图1
再次按f5刷新页面：
图2
大家发现什么问题了吗？两个问题：
1.正常的情况下，对响应头Response Headers来说，只有我们第一次访问该网址时，响应头里面才会有Set-Cookie字段，之后不管你刷新多少次，响应头里面都不会有Set-Cookie字段了。对请求头Request Headers来说，第一次请求时，不发送Cookie字段，之后不管你刷新多少次，请求头都会发送Cookie字段，并且每次都有JSESSIONID这个键和值：
图3
这是正常的流程。
但是，上面每次刷新的时候都有Set-Cookie字段，请求头里没有Cookie字段。请求头不发送JSESSIONID，服务器就认为这是一个新的用户，就会为它分配一次session并把sessionid返回，就是上面Set-Cookie里的JSESSIONID。JSESSIONID的作用就是让后台java程序识别你是谁，通过JSESSIONID找到对应的session。也就是说，可以发现问题所在了：我登录成功之后，把用户信息放入了sessionid=123的session里，下一次请求却到sessionid=456的session里面去找，自然是获取不到呀。
2.问题发现之后，就要探究为什么会出现上面的问题，注意看我截取的Set-Cookie字段，后边有个“Secure; HttpOnly”，我在本地跑了个项目，设置了一个cookie，并没有这个东西啊：
难道是"Secure; HttpOnly"的原因导致了请求头Request Headers每次都不携带JSESSIONID，从而导致服务器认为是新用户而创建新的session？答案是正确的。
当在web.xml中做了如下配置
&lt;session-config&gt; &lt;session-timeout&gt;240&lt;/session-timeout&gt; &lt;cookie-config&gt; &lt;secure&gt;true&lt;/secure&gt; &lt;/cookie-config&gt; &lt;/session-config&gt; 之后，浏览器的响应头设置的Set-Cookie字段就如图1所示，会在JSESSIONID后加入“Secure; HttpOnly”，作用就是让请求头在http协议 下的Cookie字段不能携带JSESSIONID这个键，只能在https协议下才能携带，而我测试环境是http协议的，因此才导致了每次请求都创建一个session的问题。我们只需要配置
&lt;secure&gt;false&lt;/secure&gt; 就可以了。记住：只需要在web.xml的cookie-config里面配置&lt;secure&gt;false&lt;/secure&gt;，就可以解决sessionid每次请求都不同的问题,从而使session回归正常的使用方法。
说了这么多，归纳为一句话，&lt;secure&gt;true&lt;/secure&gt;通过在Set-Cookie字段的JSESSIONID后加入“Secure; HttpOnly”的方式控制了请求头里面的Cookie不能在http协议下携带JSESSIONID这个键，而JSESSIONID这个键用于java后端识别客户端是谁，是否已经为它创建了session。
当然，我在java程序里面自己向浏览器加入的cookie也可以控制是否只能在https下才能被请求头的Cookie字段携带。
下面是普通的设置cookie和获取cookie的java代码：
package aaa; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet("/TestServlet") public class TestServlet extends HttpServlet { private static final long serialVersionUID = 1L; public TestServlet() { super(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String flag = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/536f5d6eaccd3872ee70988316db2631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d9b28ab148ff9848437f8449258b3b/" rel="bookmark">
			Jupyter对标的Spyder代码块：#%% 分割cell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道，Jupyter有很好用的代码块。其实Jupyter和Spyder有着相同的内核IPython。
它也能实现类似的功能：利用专有标识号分割代码块（Cell）
#%% code.... #%% 如下图所示。
一旦分割好，快捷键和Jupyter中的是一致的：
Ctrl + Enter ：执行当前cell
Shift+Enter ：运行当前cell并将光标移到下一个cell
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22637ae24ad60ef9d82dbb8afa5c753/" rel="bookmark">
			C语言 循环结构打印*号三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编写程序，使用循环结构语句打印输出如下图形
* *** ***** ******* #include&lt;stdio.h&gt; int main() { int i,j; for(i=0; i&lt;4; i++) { for(j=4-i; j&gt;0; j--) { printf(" "); } for(j=1; j&lt;=i*2+1; j++) { printf("*"); } printf("\n"); } } 小剧场：同样一天，有人比你更努力！On the same day, someone works harder than you! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0894c07cc10ba278edeb04b388458237/" rel="bookmark">
			webpack面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/gaoht/p/11310365.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a1693d05fc3938b42d7485b0d37f849/" rel="bookmark">
			控制工程专业网络复试专业课问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年采取的是网络复试，下面是为应对网络复试利用百度搜索和课本整理的相关的专业课问题，我认为还是很有用的，希望对大家有帮助。
一、电路原理 电路原理面试题目 1.什么是受控源?种类? 1.受控源是一种电源，其源电压或源电流受外电路的电压或电流控制。 2.种类有4种，具体不再展开。 2.介绍下基尔霍夫定律 1.基尔霍夫定律分为KCL和KVL 2.KCL是指电路中任一个节点，在任一时刻，流入节点的电流之和等于流出节点的电流之和。 3.KVL是指在任何一个闭合回路中，各元件上的电压降的代数和等于电动势的代数和。 3.介绍下电路的类型 1.线性电路，由线性无源元件、线性受控源和独立电源组成的电路。 2.电阻电路，构成电路的线性无源元件均为线性电阻。 3.直流电路，电路中的独立电源都是直流电源。 4.等效变换的条件 1.两个一端口网络的伏安特性完全相同。 5.求解带有受控源电路的等效电阻的方法 1.加压求流和加流求压 6.n个结点列写的独立方程数 1.n-1个独立的kcl方程 2.b-n+1个独立的kvl方程 7.电路的2b法是什么 1.对于一个具有n个节点b条支路的电路，若以支路电压、电流为变量，则未知量是2b个 2.b个VCR方程，n-1个kcl方程，b-n+1个kvl方程，共2b个方程。 8.求解电路中电压或电流变量的方法 1.支路电流法 2.回路电流法 3.网孔电流法 4.节点电压法 9.电路定理有哪些 1.叠加定理，将各个独立源单独作用的结果进行叠加 2.戴维南定理，利用开路电压和等效电阻进行等效 3.诺顿定理，利用短路电流和等效电阻进行等效 4.最大功率传输，当负载电阻等于一端口输入电阻时，获得最大功率 5.特勒根定理 6.互易定理 10.理想运放的特点 1.输入阻抗无穷大，输出阻抗趋近于零 2.满足虚短(电压相等)和虚断(电流为零) 11.零输入响应、零状态响应、全响应 1.零输入响应，换路后电路无外加电源，其响应由储能元件的初始值引起 2.零状态响应，换路后储能元件的初始值为零，其响应是由外加电源引起 3.全响应，换路后的响应由储能元件的初始值和外加电源共同产生 13.什么是阻抗 1.无源一端口网络，在正弦电源激励作用下，端口的电压相量和电流相量的比值 14.视在功率、无功功率、有功功率的关系 1.P = Scosφ 2.Q = Ssinφ 3.S = √(S^2+Q^2) 15.互感电路的耦合方式 1.串联、并联、单点联 16.三相电路中 1.负载为Y接，线电压=√3相电压，相位超前30°，线电流=相电流 2.负载为△接，线电压=相电压，线电流=√3相电流，相位滞后30° 电路原理选择和判断整理 1.自动满足基尔霍夫第一定律(KCL)的是网孔电流法 2.自动满足基尔霍夫第二定律(KVL)的是节点电压法 3.电路动态过程产生的实质是能量不能跃变 4.一个含有直流分量的非正弦波作用于线性电路，其电路响应电流中含有直流分量 5.一阶电路的三要素包括初始值、新稳态值、时间常数 6.电路方程包括支路电流法、网孔电流法、结点电压法、回路电流法 7.三相四线制电路无论对称与否，都可以用"三功率表"测量三相总有功功率 8.RLC多参数串联电路由感性变为容性的过程中，必然经过谐振点 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a1693d05fc3938b42d7485b0d37f849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef7e4c73668cac04feb3a229f56094a2/" rel="bookmark">
			钉钉机器人MarkDown类型的消息不支持@人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做告警系统的过程中，需要用到钉钉机器人进行告警，创建自定义机器人后，发送相关消息。我们需要@群内的相关人员，使用过程中发现只有text类型的消息支持@相关人，其余类型不支持。百思不得其解，下面是钉钉的开发文档
钉钉机器人开发文档
如需要@人，只需要在at这个json对象中加入对应手机号就ok，而其他类型的消息，比如MarkDown类型则不能@相关人
起初我以为是我哪里配置的问题，找了很久始终没有找到原因。最后提了工单，他们告诉我在text中也要吧手机号当作文本拼接在后面
文档中没有任何说明，而且这是什么反人类的设计……坑啊！
记录一下，避免大家遇到类似的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5849a082e2c7cea36de4462c221a41e2/" rel="bookmark">
			ArcGIS Python如何将py脚本制作成python工具(自定义地理处理工具)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么将py脚本制作成python工具（自定义地理处理工具） 1、arcgis中Python脚本工具和 Python 工具箱的区别1.1、什么是Python脚本工具？1.2、什么是 Python 工具箱？1.3 比较自定义工具箱和 Python 工具箱 2、在IDE中制作并运行.py文件3、修改py脚本为创建python脚本工具作准备4、创建Python工具（自定义地理处理工具）4.1 新建工具箱（Add Toolbox）4.1.1 工具箱上右键Add Toolbox4.1.2 catalog上右键Add Toolbox 4.2 在工具箱中创建脚本工具4.2.1 工具箱上添加脚本（Add Scripts）4.2.1 如何确定python工具参数类型 5、运行创建的Python工具（自定义地理处理工具） 背景：如何实现一键制作等高线；前面讲过等高线制作流程：
1.Excel to table
2.display X Y Data
3.Create TIN
4.生成DEM数据。
5.生成等高线。
是由这五个步骤完成的，那么怎么把五个GP工具直接塞进一个python脚本工具呢？ 并且直接生成等高线。
注：本篇先以创建 TIN为例说明如何有.py脚本文件 制作成 GP工具，也就是下面所说要讲解的；
然后在将4、5步骤的工具生成DEM数据和生成等高线制作成一个python脚本工具。
arcgis根据经纬度xyz坐标点生成等高线
目的：也即是有 CreateTin.py这么一个脚本文件（往下面看有完整脚本），生成下面这个一个python工具：
1、arcgis中Python脚本工具和 Python 工具箱的区别 1.1、什么是Python脚本工具？ 通过创建脚本工具，可以将自己的 Python 脚本和功能转变为地理处理工具，这些工具的外观和操作都和系统地理处理工具相类似。创建后，脚本工具具有许多优势：
您创建的脚本工具会像系统工具一样成为地理处理的组成部分，您可以从搜索 或目录 窗口中打开它，可在模型构建器和 Python 窗口中使用它，还可以从其他脚本中调用它。
您可以将消息写入结果 窗口和进度对话框。
使用内置的文档工具，可以创建文档。
将脚本作为脚本工具运行时，arcpy 完全知道从哪个应用程序（如 ArcMap）调用该脚本。在应用程序中所做的设置（如 arcpy.env.overwriteOutput 和 arcpy.env.scratchWorkspace）都可从脚本工具中的 ArcPy 中获得。
要在自定义工具箱中创建脚本工具，需要以下三项：
脚本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5849a082e2c7cea36de4462c221a41e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc95ebd941086dabe0c3f4bc433f34c9/" rel="bookmark">
			Pytorch相似度计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 余弦相似度
余弦相似度是一种我们较为常用的计算向量相似度的方法。下面就是计算余弦相似度的公式：
import torch import torch.nn as nn import math class ConineSimilarity(nn.Module): def forward(self, tensor_1,tensor_2): normalized_tensor_1=tensor_1/tensor_1.norm(dim=-1,keepdim=True) normalized_tensor_2=tensor_2/tensor_2.norm(dim=-1,keepdim=True) return (normalized_tensor_1*normalized_tensor_2).sum(dim=-1) input_1=torch.randn(3,5,requires_grad=True) print(input_1) input_2=torch.randn(3,5,requires_grad=True) print(input_2) con=ConineSimilarity() CS=con(input_1,input_2) CS2=torch.cosine_similarity(input_1,input_2) print(CS) print(CS2) 输出：
tensor([[ 0.5389, 1.7485, -0.5183, 1.5721, -0.3880], [-1.3460, 1.8793, -1.9676, 0.8554, -2.6176], [-0.5190, -0.4626, -1.5462, 0.5101, -0.3836]], requires_grad=True) tensor([[-0.3151, 0.0500, -0.2004, -0.8795, 0.2460], [ 0.1276, 1.0000, 0.6290, -0.0722, -0.1960], [-0.6387, -0.7833, -0.1992, 0.3575, 0.7043]], requires_grad=True) tensor([-0.5903, 0.1863, 0.3887], grad_fn=&lt;SumBackward2&gt;) tensor([-0.5903, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc95ebd941086dabe0c3f4bc433f34c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0d0009e020a5803ecb3feda3c7a789/" rel="bookmark">
			数据研发学习笔记06：数据挖掘分析方法概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 分类2 聚类3 关联分析4 数值预测5 异常点挖掘6 序列分析7 社会网络分析 数据挖掘是从大量数据中自动发现隐含的信息和知识的过程，属于主动分析方法，不需要分析者的先验假设，可以发现未知的知识。 1 分类 分类（classification） 是通过对具有类别的对象的数据集进行学习，概括其主要特征，构建分类模型，根据该模型预测对象的类别的一种数据挖掘和机器学习技术。
例如，电信公司的客户可以分为两类，一类是忠诚的，一类是流失的。根据这两类客户的个人特征方面的数据以及在公司的消费方面的数据，利用分类技术可以构建分类模型。
2 聚类 聚类（clustering） 是依据物以类聚的原理，将没有类别的对象根据对象的特征自动聚集成不同簇的过程，使得属于同一个簇的对象之间非常相似，属于不同簇的对象之间不相似。
其典型应用是客户分群，根据客户特征把客聚成不同的客户群。
3 关联分析 关联分析最早用于分析超市中顾客一次购买的物品之间的关联性。
发现数据之间的关联规则，这些规则展示属性－值频繁的在给定的数据中所一起出现的条件。广泛的用于购物篮或事务数据分析。
例如，发现关联规则（association rule）“尿不湿®啤酒（0.5%，60%）”，其含义为，0.5%的交易中会同时购买尿不湿和啤酒，且买尿不湿的交易中有60%会同时买啤酒。
4 数值预测 数值预测用于预测连续变量的取值。常用的预测方法是回归分析。
例如，可以根据客户个人特征，如年龄、工作类型、受教育程度、婚姻状况等，来预测其每月的消费额度。
5 异常点挖掘 孤立点分析（outlier analysis)，一些与数据一般特点不一致的孤立点。
例如，信用卡客户欺诈检测。
6 序列分析 序列分析是对序列数据库进行分析，从中挖掘出有意义模式的技术。
序列模式（sequential pattern）的发现属于序列分析，它是从序列数据库中发现的一种有序模式.。
7 社会网络分析 社会网络（social network）是由个人或组织及其之间的关系构成的网络。
社会网络分析（social network analysis）是对社会网络的结构和属性进行分析，以发现其中的局部或全局特点，发现其中有影响力的个人或组织，发现网络的动态变化规律等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d395fbfc03853be55e86fcd04220e6e/" rel="bookmark">
			!!! no internal routing support, rebuild with pcre support !!!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip uninstall uwsgi
sudo apt-get install libpcre3 libpcre3-dev
pip install uwsgi
或者
ubuntu环境下
pip uninstall uwsgi
sudo apt-get install libpcre3 libpcre3-dev
pip install uwsgi --no-cache-dir
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f148c016e63b697588496547946c1760/" rel="bookmark">
			Python的数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的数据可视化 本文参考书籍：《Python编程：从入门到实践》
目录 Python的数据可视化生成数据绘制简单的折线图修改标签文字和线条粗细给plot()同时提供输入和输出值使用scatter()绘制散点图并设置样式使用scatter()绘制一系列点自动计算数据，绘制1000个散点删除数据点的轮廓自定义颜色使用颜色映射自动保存图表 随机漫步创建RandomWalk()类选择方向绘制随机漫步图模拟多次随机漫步设置随机漫步图的样式给点着色重新绘制起点和终点隐藏坐标轴增加点数调整尺寸以适合屏幕 使用Pygal模拟掷骰子创建Die类掷骰子分析结果绘制直方图同时掷两个骰子同时掷两个面数不同的骰子 下载数据CSV文件格式分析CSV文件头打印文件头及其位置提取并读取数据绘制气温图表模块datetime在图表中添加日期涵盖更长的时间再绘制一个数据系列给图表区域着色错误检查 制作交易收盘价走势图：JSON格式下载收盘价数据提取相关的数据将字符串转换为数字值绘制收盘价折线图时间序列特征初探收盘价均值收盘价数据仪表盘 使用API使用Web API使用API调用请求数据requests处理API响应处理响应字典打印API调用返回的信息：概述最受欢迎的仓库 使用Pygal可视化仓库信息改进Pygal图表添加自定义工具提示根据数据绘图在图表中添加可单击的链接 Hacker News网站的 API调用 生成数据 matplotlib:数学绘图库
Pygal包：专注于生成适合在数字设备上显示的图表
绘制简单的折线图 import matplotlib.pyplot as plt	#导入模块pyplot，并给它指定别名为plt squares = [1, 4, 9, 16, 25] #默认第一个数据点对应的x为0，以此类推 plt.plot(squares)	#(0,1) (1,4) (2,9) (3,16) (4,25) plt.show() 修改标签文字和线条粗细 import matplotlib.pyplot as plt squares = [1, 4, 9, 16, 25] #参数linewidth决定了plot()绘制的线条的粗细 plt.plot(squares, linewidth=5)	#设置图表标题，并给坐标轴加上标签 #函数title()给图表指定标题 #参数fontsize指定了图表中文字的大小 plt.title("Square Numbers", fontsize=24) #函数xlabel(),ylabel()为每条轴设置标题 plt.xlabel("Value", fontsize=14) plt.ylabel("Square of Value", fontsize=14) #设置刻度标记的大小 #函数tick_params()设置刻度样式， #其中指定的实参将影响x、y轴上的刻度(axis='both') #并将刻度标记的字号设置为14(labelsize=14) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f148c016e63b697588496547946c1760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8d88785a17b1db21bea0bfa1cdb214/" rel="bookmark">
			unity中代码设置鼠标的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置鼠标API: Cursor.SetCursor(Texture2D,Vector2,CursorMode)
参数1 是要设置的鼠标图片；
参数2是 鼠标的作用点在图片上的位置，一般是Vector2.zero,也就是图片的左上角，如果
改变这个作用点的位置，以图片大小为标准，例如一张32*32的图片，要以左下角做为作用点，
则为new Vector2(0,32);
参数3 是渲染方式 一般是CursorMode.Auto
Texture2D paintCursor = Resources.Load(“xxx”);
Cursor.SetCursor(paintCursor, new Vector2(0,32), CursorMode.Auto);
这里我使用了一张32*32的画笔图片(笔尖朝左下角),如果是Vector2.zero,表现上的异常
是 线条出现在笔尖的上方，有点奇怪。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389b14664cf92fa79cfb72cd9bc4d974/" rel="bookmark">
			unity-光照探针简单应用（Light Probe Group）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）讲光照探针前，首先需要清楚LightMap，静态物体的灯光烘焙（如果对此不了解，请查看前几篇关于烘焙GI的介绍操作），因为光照探针是对lightMap烘焙的一个补充。
（2）光照探针，是对lightMap的补充，我们在烘焙的时候，动态物体收到的光照影响是不能直接烘焙进bakedLightMap，用实时光照就会产生强大的额外开销。而反射探针能够将动态物体的实时光照烘焙进GI中，这样就可以取代实时光照而减少渲染的开销：
（3）下面开始操作步骤：
1.搭建场景：一个Plane，俩sphere（名字为：sphere，shpere_Static），俩点光源（红和蓝）去掉自带的平行光，（灯，sphere，plane摆放位置在最下面的图中）
在windows-Rendering-light setting中关闭 Auto Generate
2.将俩光源设置为Baked3.将 sphere_static 和plane标记为“static”
4.烘焙，点击Generate Lighting
5.查看烘焙结果：sphere_static 有颜色，而sphere没有颜色，现在移动sphere是没有任何颜色变化的。
6.新建Light Probe Group：并且拖动lightProbe的小球，扩大立体体积，包围sphere，结果如下图
7.再次点击烘焙，发现sphere有了颜色，关闭俩光源，左右移动小球：
移动到左侧，shpere的颜色变蓝：
移动到右侧，shpere的颜色变红：
这样就实现了，在没有实时光的情况下，动态小球依然能够自动切换光照颜色~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35a712c0008a2af2be05fc50eaa9cba/" rel="bookmark">
			Centos7 Apache安装php-gd库（PHP7.0.33）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行如下代码
yum install php70w-gd.x86_64 执行完成后重启Apache
systemctl restart httpd 完成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384ef60436539ab6e29416aca9e89f90/" rel="bookmark">
			Unity的使用（三）：编译顺序，文件类型和生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们写好的脚本，是经过编译之后才被使用，而Unity游戏引擎对脚本的编译顺序也是顺序的，了解这个顺序会对程序编码大有裨益。同时，写在我们脚本中的函数也是按一个固定的执行顺序执行的，这个固定的执行顺序就是Unity的生命周期，这是Unity学习者必须掌握的。
一. Unity中脚本编译顺序 编译的原则是在第一个引用前编译它，因此，将脚本放在Assets不同文件夹下不同位置会有不同的编译顺序。官方给出的编译顺序如下：
其中各个特殊文件夹是什么请参考本系列的第一篇文章。可以看到，编译一共分为四个阶段，两大块（标准资源配置块和自定义块），且每个块下的Editor文件夹中的资源编译靠后（可以理解Editor编写的为引擎工具，是对其所属块内资源的编辑使用，因此要靠后编译）。
二. Unity中的文件类型 在Unity中一般存在这么几种文件类型：资源文件(Imported Assset)，代码文件，序列化文件(Native Asset)，文本文档，非序列化文件，meta文件。
1. 编译产生的文件 每个编译阶段都会产生对应的项目文件。以C#为例，当项目中包含有C#脚本时，Unity引擎会产出以Assembly-CSharp为前缀，csproj为后缀的文件，名称中包含“vs”表示是给Visual Studio用的，不含则是给Mono Develop用的。
可能部分初学者没看过Assembly-CSharp-firstpass.csproj文件，那是因为你的项目里没有Standard Assets, Pro Standard Assets和Plugins三个文件夹中的任何一个，自然也不会编译产生这个项目文件。
在产生这些项目文件的编译过程中，同时也会在工程根目录/Library/ScriptAssemblies下生成dll，分别为：
Assembly-CSharp-Editor.dll：包含所有Editor下的脚本；
Assembly-CSharp-firstpass.dll：包含Standard Assets, Pro Standard Assets, Plugins文件夹下的脚本(不含Editor文件夹)
Assembly-CSharp.dll：包含除了以上两种所有位于Assets目录中的脚本；
不同语言的脚本，编译出的工程文件的前后缀也不同，也会生成不同的dll文件，下面为不同语言对应的前后缀：
2. Assets中常见文件类型 资源文件(Imported Asset)：指一些创建好，并且不再修改的文件。比如美术给的FBX文件，贴图，音频，视频等等。这类文件在导入时都会对应一个Asset Importer，生成对应的.meta文件和存储在Library目录下Unity可识别的内部格式。每次修改原始文件，Unity都会重新导入一次，当删除Library或里面某个文件，会让Unity重新导入相应的资源，不会对工程造成影响；
代码文件：包括所有的代码文件，代码库文件，shader文件等，在导入时Unity会进行一次编译。
序列化文件(Nativa Asset)：序列化文件是指Unity能够序列化的文件，一般为Unity自身的类型，如prefab，场景文件，.mat文件(材质球)，asset(ScriptableObject)文件。这些文件能够在运行时直接反序列化为对应类的一个实例。
文本文档：不是序列化文件，但是Unity可以识别为TextAsset，如txt, xml, json等；
非序列化文件：Unity无法识别的文件。
3. meta文件 Assets文件夹中所有文件，文件夹，经过Unity导入过程后，都会在其同目录下生成一个.meta文件，该文件Unity内部用来管理文件的，记录着重要内容。meta文件本质上是一个使用YAML格式编写的文本文档。1
GUID guid，global unique ID，是meta中最重要的数据。它是该项目中全局唯一的，代表了这个文件。只要通过这个GUID就可以找到工程中的这个文件。对于Unity的序列文件来说，引用的对象就是这个GUID，故一旦meta中GUID变更了，会造成一场引用丢失的灾难。
ImportSetting数据 当该文件为从外部导入的资源文件，那么会有一个对应的ImportSetting。不同文件类型对应着不同的ImportSetting数据，如：NativeFormatImporter, ModelImporter, AudioImporter等等。ImportSetting中每一行都对应着Inspector面板中的条目。因此，当我们将一个文件和该文件的meta文件从一个Unity工程复制到另一个工程中，它的配置是不会变的。
FileID 当一个文件下有多个其它文件，如一个图集下面有若干图片，那么一个GUID怎么对应其下的文件呢？这个时候就需要FileID，通过GUID找到任何一个文件，再通过FileID找到其中某个子文件。
对于非序列化的资源文件，由于不会更改源文件，所以FileID存储在meta文件中，像FBX文件，图集就是这种类型；对于序列化文件，其自身数据中存储自身的FileID，也会记录所有子文件的FileID，因此mete文件中只有自身的FileID，如AnimatorController, prefab等。
4. 其它特殊文件 当文件名为"CVS"或者该文件拓展名为".tmp"时，该文件会被隐藏（在Project视图中不可见）。
三. Unity的生命周期 对于游戏场景中所有继承了MonoBehaviour的组件（自定义脚本），MonoBehaviour提供了一系列函数供调用。当游戏运行时，进程会按照生命周期中函数的顺序自动调用，如：当执行完所有游戏物体的OnMouseXXX()后才会执行所有游戏物体的Update()。
这里推荐一篇关于Unity生命周期的文章。下面为Unity生命周期图：
开发中生命周期需要注意的地方：
生命周期中的函数2都与游戏物体是否激活有关，当游戏物体的状态为激死状态时，生命周期中的函数都无法被调用，但是已经正在执行的生命周期函数会继续执行直到完成，外部依旧可以对游戏物体的状态参量（如transform, 脚本状态等）进行更改，依旧可以使用脚本中的属性，函数方法；Awake() 在Monobehaviour创建后且游戏对象初始状态为激活，脚本甚至都可以是不激活状态的情况下，会被立刻调用且在整个生命周期仅执行一次（除非将该游戏物体销毁再重新创建或重新加载场景）；如果创建的游戏物体对象初始状态为关闭，那么Awake()函数不会执行。OnEnable() 启用函数，当对应脚本被启用的时候执行（如果原脚本已经是启用状态则不会）；如gameObject.SetActive(true), enabled = true。Start() 同样也只会执行一次， 且一定在OnEnable()之后执行，Start()只在Monobehaviour创建后Update()函数第一次执行前执行一次。和Awake()不同的是，Start()是若创建游戏物体，游戏物体为激活状态(gameObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/384ef60436539ab6e29416aca9e89f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1426b6fdfa769f9c6ed628a1345afb3/" rel="bookmark">
			函数指针求三个数最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用函数指针求三个数的最大值，如输入1，2，3三个数，输出3。
具体代码如下：
#include&lt;iostream&gt; using namespace std; //判断最大值 int Max(int *p1,int *p2,int *p3) { int max=*p1; if(max&lt;*p2) max=*p2; if(max&lt;*p3) max=*p3; return max; } int main() { int n1,n2,n3; cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;n3; int *p1,*p2,*p3; p1=&amp;n1; p2=&amp;n2; p3=&amp;n3; cout&lt;&lt;Max(p1,p2,p3)&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c564967c85c4a0fe14db4a5422698ff/" rel="bookmark">
			Python datetime去除毫秒 返回当前时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 datetime模块返回当前时间 转载链接：python datetime去除毫秒
参考链接：datetime的使用
import datetime if __name__ == '__main__': a = datetime.datetime.now().replace(microsecond=0) print(a, type(a)) 运算结果： 2020-05-22 12:13:42 &lt;class 'datetime.datetime'&gt; Process finished with exit code 0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c19db89644f09f97d0c9544e29d4fc/" rel="bookmark">
			Nmap常用参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nmap是一款开源免费的网络发现（NetworkDiscovery）和安全审计（SecurityAuditing）工具。Nmap最初是由Fyodor在1997年开始创建的。随后在开源社区众多的志愿者参与下，该工具逐渐成为最为流行安全必备工具之一。
一般情况下，Nmap用于列举网络主机清单、管理服务升级调度、监控主机或服务运行状况。Nmap可以检测目标机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。
Nmap的优点： 1. 灵活。支持数十种不同的扫描方式，支持多种目标对象的扫描 2. 强大。Nmap可以用于扫描互联网上大规模的计算机 3.可移植。支持主流操作系统：Windows/Linux/Unix/MacOS等等；源码开放，方便移植 4. 简单。提供默认的操作能覆盖大部分功能，基本端口扫描nmap targetip，全面的扫描nmap –A targetip 5. 自由。Nmap作为开源软件，在GPL License的范围内可以自由的使用 6. 文档丰富。Nmap官网提供了详细的文档描述。Nmap作者及其他安全专家编写了多部Nmap参考书籍 7. 社区支持。Nmap背后有强大的社区团队支持 Nmap包含四项基本功能：
1. 主机发现 (Host Discovery) 2. 端口扫描 (Port Scanning) 3. 版本侦测 (Version Detection) 4. 操作系统侦测 (Operating System Detection) 而这四项功能之间，又存在大致的依赖关系(通常情况下的顺序关系，但特殊应用另外考虑)，首先需要进行主机发现，随后确定端口状态，然后确定端口上运行的具体应用程序和版本信息，然后可以进行操作系统的侦测。而在这四项功能的基础上，nmap还提供防火墙和 IDS 的规避技巧，可以综合运用到四个基本功能的各个阶段。另外nmap还提供强大的NSE(Nmap Scripting Language)脚本引擎功能，脚本可以对基本功能进行补充和扩展。
接下来为大家讲解一下windows下和linux下nmap的安装方法 去官网下载https://nmap.org/download.html
当然啦，大家可以直接使用kali linux系统，以前kali linux系统自带了Zenmap，现在已经去除了，但是我们还有nmap
下面整理一些nmap参数及其意义 ：
1. nmap -iflist : 查看本地主机的接口信息和路由信息 2. -A ：选项用于使用进攻性方式扫描 3.-T4：指定扫描过程使用的时序，总有6个级别（0-5）,级别越高,扫描速度越快,但也容易被防火墙或IDS检测并屏蔽掉,在网络通讯状况较好的情况下推荐使用T4
4. -oX test.xml：将扫描结果生成 test.xml 文件，如果中断，则结果打不开 5. -oA test.xml: 将扫描结果生成 test.xml 文件，中断后，结果也可保存 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1c19db89644f09f97d0c9544e29d4fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c667a24d98181cfd4fa242ba377072/" rel="bookmark">
			中文NLP工具介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/KnightTen/article/details/89138602
中文 NLP 工具总结
KnightTen 2019-04-09 11:00:44 3419 收藏 10
展开
文章目录
中文 NLP 工具总结
1. Jieba 分词
1.1 简介
1.2 模型原理
1.3 安装
1.4 使用
1.5 分词评测
2. pyltp——哈工大
2.1 简介
2.2 模型原理
2.2.1 分词
2.2.2 词性标注
2.2.3 依存分析
2.3 安装
2.4 使用
2.4.1 分词
2.4.2 词性标注
2.4.3 依存分析
2.4.4 分词、词性标注和依存分析的整合
2.5 分词评测
3. thulca——清华
3.1 简介
3.2 模型原理
3.3 安装
3.4 使用
3.5 分词评测
4. NLPIR —— 中科院
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c667a24d98181cfd4fa242ba377072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4d1ef490e51c37351e3b9b5f63a33c9/" rel="bookmark">
			TensorFlow 2.x调试错误解决：_SymbolicException: Inputs to eager execution function cannot be Keras symbolic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现的这样错误：
调试TensorFlow 2.0 程序时，发现错误如下：
_SymbolicException: Inputs to eager execution function cannot be Keras symbolic tensors, but found [&lt;tf.Tensor 'my_rnn/lstm_cell/cond/Identity:0' shape=(None, 100) dtype=float32&gt;, &lt;tf.Tensor 'my_rnn/lstm_cell_1/cond/Identity:0' shape=(128, 64) dtype=float32&gt;]
查阅资料发现的一种解决方案：
Keras在编译模型阶段，区分训练状态和非训练状态，二者的逻辑是不一样的。比如说，模型使用了Dropout，在训练时要随机失活部分神经元，而在正式运行（模型已经训练完毕后，在运行时），所有神经元都要保留的。
如果是训练状态，则在编译参数里增加一个选项即可：experimental_run_tf_function = False
training = True #设置一个布尔量，根据不同情况，调用不同的模型编译（装配）
if training: #
# 装配
model.compile(optimizer = optimizers.RMSprop(0.001),
loss = losses.BinaryCrossentropy(),
metrics=['accuracy'],
experimental_run_tf_function = False
)
else:
# 装配
model.compile(optimizer = optimizers.RMSprop(0.001),
loss = losses.BinaryCrossentropy(),
metrics=['accuracy']
)
设置之后，模型就可以运行了。
x_train shape: (25000, 80) tf.Tensor(1, shape=(), dtype=int64) tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4d1ef490e51c37351e3b9b5f63a33c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dea1666df45feee792d07ccc81623990/" rel="bookmark">
			ssh-keygen -R
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用shh-keygen 命令（强烈建议使用此方法）
比如我们要将 的公钥信息清除，使用命令（请自己将 替换成自己的IP或域名）：
ssh-keygen -R xxx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d013fbf17cc9ca071c7195f83049ac7/" rel="bookmark">
			在CMD中连接服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在CMD命令窗口中，输入ssh root@xxx.xxx.xxx.xxx#xxx为服务器IP地址。然后输入之前设置的密码即可成功连接。在操作服务器的时候不推荐用root用户直接操作,于是我们先创建一个用户
创建用户的命令是 adduser
3.Ubuntu下测试ssh时使用ssh localhost 命令，出现错误提示connect to host localhost port 22:Connection refused 造成这个错误的原因可能是ssh-server未安装或者未启动。ubuntu 11.10 默认安装openssh-client，但是木有安装server 运行 ps -e | grep ssh，查看是否有sshd进程 如果没有，说明server没启动，通过 /etc/init.d/ssh -start 启动server进程，如果提示ssh不存在 那么就是没安装server 通过 sudo apt-get install openssh-server命令安装即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c4390f5d06e40e844d1fc03dcfa54bd/" rel="bookmark">
			域名不加端口号访问django
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8000
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac6bf3279f99fb51d14e58ae59a8b27/" rel="bookmark">
			springboot1.5集成flowable6.5.0和对应的modelerUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.jar包依赖必须的；
&lt;!-- flowable工作流 springboot1.5最高6.5 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;6.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-ui-modeler-rest&lt;/artifactId&gt; &lt;version&gt;6.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-ui-modeler-conf&lt;/artifactId&gt; &lt;version&gt;6.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-ui-modeler-logic&lt;/artifactId&gt; &lt;version&gt;6.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- flowable工作流end --&gt; 2.配置可视化页面需要的接口；
import liquibase.Liquibase; import liquibase.database.Database; import liquibase.database.DatabaseConnection; import liquibase.database.DatabaseFactory; import liquibase.database.jvm.JdbcConnection; import liquibase.exception.DatabaseException; import liquibase.resource.ClassLoaderResourceAccessor; import org.apache.tomcat.jdbc.pool.DataSource; import org.flowable.ui.common.service.exception.InternalServerErrorException; import org.flowable.ui.common.service.idm.RemoteIdmService; import org.flowable.ui.modeler.properties.FlowableModelerAppProperties; import org.flowable.ui.modeler.rest.app.EditorGroupsResource; import org.flowable.ui.modeler.rest.app.EditorUsersResource; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.autoconfigure.web.WebMvcRegistrations; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aac6bf3279f99fb51d14e58ae59a8b27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a917456f2fd2156a5ca048fc3d113fa/" rel="bookmark">
			elementUI select下拉框在ios移动端需要点击两次才能选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法:
添加scss代码：
.el-scrollbar { &gt; .el-scrollbar__bar { opacity: 1 !important; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39cc97c617ffad796063b77ab79fe784/" rel="bookmark">
			用c&#43;&#43;写出带交互界面的简单计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用devc++和QT写交互界面的计算器 一.先下载一个QT 下载地址
http://download.qt.io/archive/qt/
我下载的是 5.12.8 版本的
第四个是windos的
第五个是mac的
第六个是linux的
按需下载就行了
这里有一篇下载安装教程可以看看
https://blog.csdn.net/cfan927/article/details/98115783?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;depth_1-utm_source=distribute.pc_releva
（转@Cfan927）
比较详细
二. 学习Qt b站有个教学视频，可以先看看，他讲的比较详细
https://www.bilibili.com/video/BV1g4411H78N
我个人感觉看到 P10 就行了，因为我知道看我这篇文章的多半都是合工大的孩子被数据结构作业逼疯才来的，先学这么多
弄懂怎么实现按钮的操作，弄懂什么是信号，什么是槽就可以了
三.实现计算器代码 有两点可能要注意一下（没有这个大作业的可以不看后面这段）
我们的大作业里面有&amp;&amp; || ！三种逻辑运算符
！问题不大
主要是&amp;&amp;和||
这个到时候在计算器输入的时候要输入两个&amp;&amp;
但是我们只入栈一个&amp; 这样方便后面运算
那怎么实现呢？
我们用a来代表你的输入的算式
a[i]遍历这个式子，当 i 指向第一个&amp;时，i++
再入栈运算符，这样就只入栈了一个运算符
|| 和上面的处理方式一样
但是要注意的时 | 的ascii码是 124 ，判断运算符和数字时要注意
其次要注意&amp;&amp; || ！之间的优先级，还有运算联系等
else if(a[i]=='&amp;') { if(a[i+1]=='&amp;') i++; } 类似于上面这样的代码来让它判断
下面放上源码
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cmath&gt; #include&lt;stack&gt; using namespace std; int symbol(char c) //赋予优先级 { switch (c) { case '#': return 0; case '+': return 2; case '-': return 2; case '*': return 3; case '/': return 3; case '(': return 6; case ')': return 1; case '&amp;': return 4; case '|': return 4; case '!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39cc97c617ffad796063b77ab79fe784/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c8a870c5642ef96693e464022eb9fa/" rel="bookmark">
			c&#43;&#43;11 lamdba
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++11 lamdba详解 一、 语法 [capture] (parameters) mutable -&gt;return_type{statement}
1、 [capture] 捕获列表： 捕捉列表总是出现在lamdba函数的开始处。事实上，[]是lambda引出符。编译器根据该引出符判断接下来的代码是否是lambda函数。
捕获类型说明[var]值传递方式捕捉变量var[=]值传递方式捕捉所有父作用域的变量(包括this)[&amp;var]引用传递捕捉变量var[&amp;]引用传递捕捉所有父作用域的变量（包括this)[this]值传递方式捕捉当前的this指针 2、 (parameters) 参数列表： 和函数的参数列表一致。如果不需要参数列表，则可以连同括号()一起省略。
3、 mutable：mutable 修饰符。 默认情况下，lamdba捕获的变量都是const的，要想在lamdba的函数体里修改通过值捕获的变量，需要使用mutable修饰符。
4、 -&gt; return_type： 返回类型，不需要返回值的时候可以连同符合-&gt;一起省略。
5、 {statement}： 函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。
二、 实例 实例1、 以值捕获a
void test1() {
int a = 3;
[a]()-&gt;int{ return a + 4; }();
[a]()-&gt;int{ return ++a; }(); // error，因为以值捕获a，捕获的变量a在lamdba里是const的，所以不能修改a的值
[a]() mutable -&gt; int {return ++a;}(); // ok, 通过mutable修饰符之后，可以修改a的值了。这里要注意a的值，执行完lamdba表达式后，a=3,原因见实例2.
}
实例2、 以值捕获a，详解捕获的时机
void test2_1(){
int a = 3;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4c8a870c5642ef96693e464022eb9fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94676003137e5695f05ecc00c44a23a/" rel="bookmark">
			Xcode在同一个工程下创建多个可分别运行程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里主要用到的功能就是Target这个功能。
首先，点到工程文件
然后在该工程文件下：
然后选择C/C++等等就可以做到同一个工程下分别运行了。
只需要调整这个，然后点运行就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192c68190ab54e5e029a6d623593d980/" rel="bookmark">
			查找每位领导的直接下属数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 显示：领导的员工编号（EmployeeID），下属数量（重命名为（countSub））
select ema.EmployeeID,count(em.ReportsTo) as countSub from employees em,employees ema where em.ReportsTo=ema.EmployeeID group by ema.EmployeeID 标题在订单表中查找特定国家且平均运费不小于10的信息 (20分) 查询订单表(orders)中查找所在国家（ShipCountry）为Belgium，Switzerland，且平均运费不小于10的的顾客及运费信息，结果显示为顾客编号(CustomerID)和平均运费(avgFreight)
提示：请使用SELECT语句作答。
select CustomerID,avg(Freight) as avgFreight from orders where ShipCountry in('Belgium','Switzerland') group by CustomerID having avg(Freight)&gt;=10 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18df8dfd9f72fc718472c1aa8e0ea4c/" rel="bookmark">
			百度地图—地址解析/逆地址解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、地址解析：根据地址获取坐标
key就是百度地图ak，可以去百度开发者中心去免费申请
接口：http://api.map.baidu.com/geocoder?address=地址&amp;output=输出格式类型&amp;key=用户密钥&amp;city=城市名
2、逆地址解析：根据坐标获取地址
接口：http://api.map.baidu.com/geocoder?location=纬度,经度&amp;output=输出格式类型&amp;key=用户密钥
代码如下：
public function GetAddressLatLng($city,$address){ $result = array(); $ak = '';//您的百度地图ak，可以去百度开发者中心去免费申请 //逆地址解析：根据坐标获取地址 //http://api.map.baidu.com/geocoder?location=纬度,经度&amp;output=输出格式类型&amp;key=用户密钥 //地址解析：根据地址获取坐标 $url = "http://api.map.baidu.com/geocoder?address=".$address."&amp;output=json&amp;key=".$ak."&amp;city=".$city; $data = file_get_contents($url); $data = json_decode($data,true); if (!empty($data) &amp;&amp; $data['status'] == "OK") { $result['lat'] = $data['result']['location']['lat']; $result['lng'] = $data['result']['location']['lng']; $arrHint = array('nStatus'=&gt;0,'sMsg'=&gt;'查询成功','arrData'=&gt;$result); }else{ $arrHint = array('nStatus'=&gt;1,'sMsg'=&gt;'查询失败'); } $this-&gt;output-&gt;set_content_type('application/json')-&gt;set_output(json_encode($arrHint)); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51863e4c06478d1a44330c7f99c664f5/" rel="bookmark">
			程序员电脑配置推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工欲善其事必先利其器，自己靠它吃饭赚钱的宝贝，一定要给它一个完美的衣服，并加倍爱护，把它看成自己的孩子一样。
很多人问了，做开发的要什么样的电脑配置比较好，这个是有不同的说法的，像ios之类，像前端开发，像跟图形，颜色打交道的，自然是Mac最好，
公认全世界图形处理最好的电脑，但是价格确实也不低呀。只能忍痛花掉自己的工资去买。。
当然除了专门的开发需要专门的电脑以外，其实大部分都可以windows。
一般公司会给你配专门的属于你工作的电脑，基本上满足日常开发，但是，时间长了，内存占有率轻轻松松超80%，运行太慢，严重影响效率！！自己用着也是巨TM的心烦！
以下就拿Java开发举个例子，因为小编就是做java开发的。为了排除打广告的例子，就不写电脑品牌了。
屏幕：至少1920*1080 分辨率。太低就经常需要滚屏，严重影响效率。一页只显示几行代码的电脑，相信你一定会心烦的。
内存：8G起步，编程很吃内存，内存越高越好，现在内存便宜，直接扩展到最大才好。
显卡：独显不仅仅是玩游戏，还有GPU计算。由于Nvidia在GPU方面的领先，推荐N卡。
处理器：做开发，如果不跑集群，分布式，英特尔i5足够了。
硬盘：有固态最好，没有得到话机械硬盘500G起。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60008d90f1dde6a46494a63c362e5586/" rel="bookmark">
			liquibase报错：Waiting for changelog lock....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在数据库搜索DATABASECHANGELOGLOCK的表；
2.找到LOCKED值为1的并修改为0；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abecdb559a19907e6ac48fbdc113f07b/" rel="bookmark">
			python的变量和C&#43;&#43;的变量有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; int main(int argc,char *argv[]){ int a = 10; for (int i = 0; i &lt; 5; i++) { a = a+1; cout &lt;&lt; &amp;a &lt;&lt; endl; } return 0; } a = 10 print("a += 1") for i in range(5): a += 1; print(id(a)) print("a = a + 1") for i in range(5): a += 1; print(id(a)) 根据上面两段代码可知python每次赋值都是指针的迁移,原本地址的值不会改变,C++则是在原来的地址进行操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e610c950249d1d1af00ebe5a116086/" rel="bookmark">
			构建django到服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssh-keygen -R XXX.XXX.XXX.XXX
ssh root@xxx.xxx.xxx.xxx
file zilla 上传company项目到/home
cd /home
apt install python3
apt-get install python3-venv
python3 -m venv venv
source venv/bin/activate &amp;&amp; cd company
pip install --upgrade pip setuptools -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com
pip install -r requirements.txt -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com
首先得保证Django项目没有问题
python manage.py runserver 0.0.0.0:8001
uwsgi --http :8001 --plugin python --module company.wsgi
查看端口：netstat -ntlp //查看当前所有tcp端口·
杀掉uwsgi进行pkill -f uwsgi -9
apt-get install python3-dev
apt-get install gcc
pip install uwsgi
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e610c950249d1d1af00ebe5a116086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc8e3dab7674c06645c53ec60b1f9c3/" rel="bookmark">
			Python中的sort和lambda函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、sort在Python中存在两种形式，分别是sorted(str)，另一种是list.srot() sorted()函数是Python的内置函数，具体形式为sorted(iterable, cmp=None, key=None, reverse=False)，其中iterable是可迭代对象，包括列表、元组、字典、字符串；cmp代表比较函数；key代表迭代对象中的某个属性，如某个元素的下标；reverse代表升序或者降序
例如：
students = [(‘john’, ‘A’, 15), (‘jane’, ‘B’, 12), (‘dave’, ‘B’, 10)]
sorted(students, key=lambda student : student[2])
结果如图：
lambda函数用法举例：L=[('b',2),('a',1),('c',3),('d',4)] #2、利用参数 cmp 排序 sorted(L, cmp=lambda x,y:cmp(x[1],y[1])) 结果： [('a', 1), ('b', 2), ('c', 3), ('d', 4)] #3、利用参数 key 排序 sorted(L, key=lambda x:x[1]) #结果： [('a', 1), ('b', 2), ('c', 3), ('d', 4)] #4、按年龄升序 students = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)] sorted(students, key=lambda s: s[2]) 结果： [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] #5、按年龄降序 sorted(students, key=lambda s: s[2], reverse=True) #结果： [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)] sort函数是针对列表的，不改变原有的列表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc8e3dab7674c06645c53ec60b1f9c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92790e02e5a06b8692ddba6a08cf9873/" rel="bookmark">
			Spring源码分析衍生篇四：后处理器 BeanPostProcessor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、BeanPostProcessor1. 什么是 BeanPostProcessor2. BeanPostProcessor 的种类3. BeanPostProcessor 的创建 三、基本介绍四、源码中的调用场景1. InstantiationAwareBeanPostProcessor1.1. IBP.postProcessBeforeInstantiation1.2. IBP.postProcessAfterInstantiation &amp; IBP.postProcessProperties &amp; IBP.postProcessPropertyValues 2. BeanPostProcessor2.1. BP.postProcessBeforeInitialization2.2. BP.postProcessAfterInitialization2.2.1 resolveBeforeInstantiation2.2.2 initializeBean2.2.3 postProcessObjectFromFactoryBean 3. SmartInstantiationAwareBeanPostProcessor 一、前言 本文是 Spring源码分析：单例bean的获取 - createBean 的衍生文章。主要是因为本人菜鸡，在分析源码的过程中还有一些其他的内容不理解，故开设衍生篇来完善内容以学习。
二、BeanPostProcessor 所谓的 BeanPostProcessor 翻译过来就是Bean后处理器。实际上Spring还有一类后处理器BeanFactoryPostProcessor，源码还没看到这，暂不分析。
1. 什么是 BeanPostProcessor BeanPostProcessor 是 Spring提供给我们的一个非常重要的扩展接口，并且Spring内部的很多功能也是通过 BeanPostProcessor 来完成的(目前看到最典型的就是 AnnotationAwareAspectJAutoProxyCreator 的 注入)。
2. BeanPostProcessor 的种类 BeanPostProcessor 在Spring 中的子类非常多(idea 显是有46个)，比如
InstantiationAwareBeanPostProcessorAdapter ： 在Spring 的bean加载过程中起了非常重要的作用AnnotationAwareAspectJAutoProxyCreator ： bean 创建过程中的 属性注入时起作用AspectJAwareAdvisorAutoProxyCreator ： Aspect 的 AOP 功能实现也全仰仗BeanPostProcessor 的特性。 3. BeanPostProcessor 的创建 个人认为 Bean的 创建时可以认为分为两个过程： 一是Bean对应的BeanDefinition 的创建。二是Bean 实例的创建。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92790e02e5a06b8692ddba6a08cf9873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c626d30a775a1c5309ab9a72ed5e7998/" rel="bookmark">
			【菜鸟进阶之路】P1765 手机 - 洛谷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目部分
题目描述
一般的手机的键盘是这样的：
（九宫格）
要按出英文字母就必须要按数字键多下。例如要按出 x 就得按 9 两下，第一下会出 w，而第二下会把 w 变成 x。0 键按一下会出一个空格。
你的任务是读取若干句只包含英文小写字母和空格的句子，求出要在手机上打出这个句子至少需要按多少下键盘。
输入格式
一行句子，只包含英文小写字母和空格，且不超过 200 个字符。
输出格式
一行一个整数，表示按键盘的总次数。
输入输出样例
输入 #1
i have a dream
输出 #1
23
二、解题过程
思路
（1）输入字符串s（getline();可以读取空格）；
（2）对字符串里每个字母/空格 按一次性按键次数进行分类，分别为1/2/3/4次，进行暴力循环打表；
（3）输出cnt。
提交AC答案
#include&lt;bits/stdc++.h&gt; using namespace std; string s; int cnt; int main() { getline(cin,s); for(int i=0;i&lt;s.length();i++) { if(s[i]==' '||s[i]=='a'||s[i]=='d'||s[i]=='g'||s[i]=='j'||s[i]=='m'||s[i]=='p'||s[i]=='t'||s[i]=='w') cnt++; if(s[i]=='b'||s[i]=='e'||s[i]=='h'||s[i]=='k'||s[i]=='n'||s[i]=='q'||s[i]=='u'||s[i]=='x') cnt+=2; if(s[i]=='c'||s[i]=='f'||s[i]=='i'||s[i]=='l'||s[i]=='o'||s[i]=='r'||s[i]=='v'||s[i]=='y') cnt+=3; if(s[i]=='s'||s[i]=='z') cnt+=4; } printf("%d",cnt); return 0; } 三、小结
（以下均为搬运，均为参考学习，无其他用途）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c626d30a775a1c5309ab9a72ed5e7998/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4817625d19061e4a623accb72a0a53c4/" rel="bookmark">
			Python2 PyQt5安装方法  ， 使用pyinstaller打包pyqt5，sip包错误解决方法：No module named sip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装PyQt5 使用Python通用的安装方法不行，提示找不到对应的版本问题，
pip install pyqt5 不能使用此方法安装，
Python2 中安装PyQt5的方法是：
pip install python-qt5 打包PyQt程序 第一次打包失败： 报错信息如下：
解决方法：
找到 /Library/plugins路径下的PyQt5文件夹，将里面的dll动态库pyqt5qmlplugin.dll复制到按照错误提示的路径，一个个的新建文件夹，形成目录C:\qt5b\qt_1524647842210_h_env\Library\plugins，将刚才复制出来的dll动态库拷贝进去即可。
能够生成exe打包文件了，
接着运行程序，有报错了。
第二次报错： 报错信息如下：
提示：No module named sip
在网上各种搜索，找解决方法，都没有能够成功安装sip。
解决方法：
在Python的安装包的目录下PyQt5的文件夹里找到sip.pyd文件拷贝到Lib\site-packages目录下：
文件位置：
拷贝路径：
在Python2中使用pyqt5需要sip的依赖，虽然在写代码的时候没有用到，
还需要在代码里引入sip
import sip 然后重新打包，继续运行程序，结果还是报错。
第三次报错： 解决方法：
把PyQt5文件夹里面的libEGL.dll文件和PyQt5里面的plugins里面的platforms文件夹一块拷贝到打包好的exe文件目录里面，和exe在同一个文件夹里面，
结果如下：
最后再次执行exe文件，完美运行，再也不需要一直截屏查看错误了，哈哈哈。
解决参考：https://www.cnblogs.com/jkn1234/p/9672957.html
http://www.bubuko.com/infodetail-2908388.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04aad457a55e3fe255dadca4cffaa617/" rel="bookmark">
			mysql索引失效场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.条件or
2.多列索引
3.like查询是以%开头
4.列类型是字符串
5.全表索引
6.没有查询条件，或者查询条件没有建立索引 7.在查询条件上没有使用引导列 8.查询的数量是大表的大部分，应该是30％以上 9.索引本身失效
10.查询条件使用函数在索引列上，或者对索引列进行运算
11. 对小表查询 12.提示不使用索引
13.统计数据不真实 14.CBO计算走索引花费过大的情况
15.隐式转换导致索引失效
16. 1,&lt;&gt; 2,单独的&gt;,&lt;,(有时会用到，有时不会) 17.like "%_" 百分号在前. 18.表没分析. 19.单独引用复合索引里非第一位置的索引列. 20.字符型字段为数字时在where条件里不添加引号. 21.对索引列进行运算.需要建立函数索引. 22.not in ,not exist. 19,当变量采用的是times变量
23.B-tree索引 is null不会走,is not null会走,位图索引 is null,is not null 都会走 24.联合索引
索引并不是时时都会生效的，比如以下几种情况，将导致索引失效 1.条件or 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)
注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引
2.多列索引 对于多列索引，不是使用的第一部分，则不会使用索引
3.like查询是以%开头 4.列类型是字符串 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5.全表索引 如果mysql估计使用全表扫描要比使用索引快,则不使用索引
此外，查看索引的使用情况
show status like ‘Handler_read%';
大家可以注意：
handler_read_key:这个值越高越好，越高表示使用索引查询到的次数
handler_read_rnd_next:这个值越高，说明查询低效
6.没有查询条件，或者查询条件没有建立索引 7.在查询条件上没有使用引导列 8.查询的数量是大表的大部分，应该是30％以上 9.索引本身失效 10.查询条件使用函数在索引列上，或者对索引列进行运算 运算包括(+，-，*，/，! 等) 错误的例子：select * from test where id-1=9;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04aad457a55e3fe255dadca4cffaa617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b4f99a75b742d7941df04018b69a0b/" rel="bookmark">
			Linux 命令自用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 tar的xzvf和xjvf命令 x是解压
c是压缩z指.gz文件，j指.jv文件f指定文件 tar xzvf FileName.tar.gz ——解压gz文件tar czvf FileName.tar.gz ——压缩gz文件tar cjvf FileName.tar.bz2 ——压缩bz2文件tar xjvf FileName.tar.bz2 ——解压bz2文件 解压/root/zihan 目录下的123.tar.gz文件 解压到/root/zihan2 目录下。
tar xzvf 123.tar.gz -C ../zihan2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/951a4a5936f7190946bfc96b52aa6400/" rel="bookmark">
			geowebcache1.10,引用arcgis瓦片图遇到的坑，已解决~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了N多方案，基本配置都是一样。
基础配置，jdk8，tomcat8。
1.下载geowebcache1.10.0，或者1.10.3的war包。
https://sourceforge.net/projects/geowebcache/files/geowebcache/
（喜欢哪个版本下哪个吧~~~baby）
2.tomcat运行解压，配置web.xml。
&lt;context-param&gt; &lt;param-name&gt;GEOWEBCACHE_CACHE_DIR&lt;/param-name&gt; &lt;param-value&gt;D:\MapDownload\gisserver&lt;/param-value&gt; &lt;/context-param&gt; 3.再次运行tomcat，在上一步配置的目录中出现的geowebcache.xml文件，中layers标签中加入以下
&lt;arcgisLayer&gt; &lt;name&gt;gis-a&lt;/name&gt; &lt;tilingScheme&gt;D:/MapDownload/gisserver/ArcGIS/conf.xml&lt;/tilingScheme&gt; &lt;tileCachePath&gt;D:/MapDownload/gisserver/ArcGIS/_alllayers&lt;/tileCachePath&gt; &lt;/arcgisLayer&gt; arcgis中的配置如下。
conf.cdi:
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;EnvelopeN xmlns:typens="http://www.esri.com/schemas/ArcGIS/10.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="typens:EnvelopeN"&gt; &lt;XMin&gt;8174481.552929789760&lt;/XMin&gt; &lt;YMin&gt;2299225.810818073810&lt;/YMin&gt; &lt;XMax&gt;15033023.226902000600&lt;/XMax&gt; &lt;YMax&gt;7088464.255054018460&lt;/YMax&gt; &lt;/EnvelopeN&gt; conf.xml：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;CacheInfo xmlns:typens="http://www.esri.com/schemas/ArcGIS/10.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="typens:CacheInfo"&gt;&lt;TileCacheInfo xsi:type="typens:TileCacheInfo"&gt;&lt;SpatialReference xsi:type="typens:ProjectedCoordinateSystem"&gt;&lt;WKT&gt;PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",0.0],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0],AUTHORITY["EPSG",3857]]&lt;/WKT&gt;&lt;XOrigin&gt;-20037700&lt;/XOrigin&gt;&lt;YOrigin&gt;-30241100&lt;/YOrigin&gt;&lt;XYScale&gt;148923141.92838538&lt;/XYScale&gt;&lt;ZOrigin&gt;-100000&lt;/ZOrigin&gt;&lt;ZScale&gt;10000&lt;/ZScale&gt;&lt;MOrigin&gt;-100000&lt;/MOrigin&gt;&lt;MScale&gt;10000&lt;/MScale&gt;&lt;XYTolerance&gt;0.001&lt;/XYTolerance&gt;&lt;ZTolerance&gt;0.001&lt;/ZTolerance&gt;&lt;MTolerance&gt;0.001&lt;/MTolerance&gt;&lt;HighPrecision&gt;true&lt;/HighPrecision&gt;&lt;WKID&gt;3857&lt;/WKID&gt;&lt;/SpatialReference&gt;&lt;TileOrigin xsi:type="typens:PointN"&gt;&lt;X&gt;-20037508.3427892&lt;/X&gt;&lt;Y&gt;20037508.3430388&lt;/Y&gt;&lt;/TileOrigin&gt;&lt;TileCols&gt;256&lt;/TileCols&gt;&lt;TileRows&gt;256&lt;/TileRows&gt;&lt;DPI&gt;96&lt;/DPI&gt;&lt;LODInfos xsi:type="typens:ArrayOfLODInfo"&gt; &lt;LODInfo xsi:type="typens:LODInfo"&gt;&lt;LevelID&gt;1&lt;/LevelID&gt;&lt;Scale&gt;295829355.454566&lt;/Scale&gt;&lt;Resolution&gt;78271.516960&lt;/Resolution&gt;&lt;/LODInfo&gt; &lt;LODInfo xsi:type="typens:LODInfo"&gt;&lt;LevelID&gt;2&lt;/LevelID&gt;&lt;Scale&gt;147914677.727283&lt;/Scale&gt;&lt;Resolution&gt;39135.758480&lt;/Resolution&gt;&lt;/LODInfo&gt; &lt;LODInfo xsi:type="typens:LODInfo"&gt;&lt;LevelID&gt;3&lt;/LevelID&gt;&lt;Scale&gt;73957338.863641&lt;/Scale&gt;&lt;Resolution&gt;19567.879240&lt;/Resolution&gt;&lt;/LODInfo&gt; &lt;LODInfo xsi:type="typens:LODInfo"&gt;&lt;LevelID&gt;4&lt;/LevelID&gt;&lt;Scale&gt;36978669.431821&lt;/Scale&gt;&lt;Resolution&gt;9783.939621&lt;/Resolution&gt;&lt;/LODInfo&gt; &lt;LODInfo xsi:type="typens:LODInfo"&gt;&lt;LevelID&gt;5&lt;/LevelID&gt;&lt;Scale&gt;18489334.715910&lt;/Scale&gt;&lt;Resolution&gt;4891.969810&lt;/Resolution&gt;&lt;/LODInfo&gt; &lt;LODInfo xsi:type="typens:LODInfo"&gt;&lt;LevelID&gt;6&lt;/LevelID&gt;&lt;Scale&gt;9244667.357955&lt;/Scale&gt;&lt;Resolution&gt;2445.984905&lt;/Resolution&gt;&lt;/LODInfo&gt; &lt;LODInfo xsi:type="typens:LODInfo"&gt;&lt;LevelID&gt;7&lt;/LevelID&gt;&lt;Scale&gt;4622333.678978&lt;/Scale&gt;&lt;Resolution&gt;1222.992453&lt;/Resolution&gt;&lt;/LODInfo&gt; &lt;/LODInfos&gt;&lt;/TileCacheInfo&gt;&lt;TileImageInfo xsi:type="typens:TileImageInfo"&gt;&lt;CacheTileFormat&gt;JPEG&lt;/CacheTileFormat&gt;&lt;CompressionQuality&gt;0&lt;/CompressionQuality&gt;&lt;Antialiasing&gt;false&lt;/Antialiasing&gt;&lt;/TileImageInfo&gt;&lt;CacheStorageInfo xsi:type="typens:CacheStorageInfo"&gt;&lt;StorageFormat&gt;esriMapCacheStorageModeExploded&lt;/StorageFormat&gt;&lt;PacketSize&gt;0&lt;/PacketSize&gt;&lt;/CacheStorageInfo&gt;&lt;/CacheInfo&gt; _alllayers的目录结构
4.好了，所有的博文到这就完事了，剩下的就是访问geowebcache以及后续的操作了，我也想操作啊，但是我走不下去了啊，都遇不到我的问题吗。。。
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'gwcXmlConfig' defined in ServletContext resource [/WEB-INF/geowebcache-core-context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/951a4a5936f7190946bfc96b52aa6400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2224b8030c57b9b4d56ebcdc189dec5a/" rel="bookmark">
			redis 介绍及String 、bitmap 使用、key查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表很大的时候，性能下降？ 如果表有索引，增删改变慢，需要维护索引。
1.如果1个或少量查询以然很快
2.当并发或sql复杂会受硬盘带宽影响速度。
常识：
硬盘：寻址慢、带宽慢。
Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。
为什么redis 单线程的还很快呢？
因为cpu很快，磁盘IO很慢。很多请求来了之后，由于cpu的速度很快，所以执行起来依然很快。一笔一笔处理，所以线程安全。
内核的epoll同步，非阻塞多路复用。
redist 取的是字节流，而不是字符流。所以redis是二进制安全的
redis 安装这里就不教了下面使用的是window的
打开redis的目录，启动 redis-server.exe，redis-cli.exe 。顺序的，否则报错。 server为服务端。
redis默认有16个库。0和1号不能更名。
help @generic 查看指令帮助文档
help @string 会出现string相关的使用
flushdb 清库
help set 查看当前组的类型
redis String ， String 类型又分为三种存储类型 ： String、数值、bitmap set key value 设置一个key和value
get key value 查询一个key和value
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2224b8030c57b9b4d56ebcdc189dec5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/883b07c78974d6f1f6566e921235e896/" rel="bookmark">
			部署Redis作为MySQL缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		server1：192.168.1.11 安装nginx和php为用户提供服务访问入口
server3：192.168.1.13 安装mysql，存储数据
server2：192.168.1.12 安装redis作为缓存服务器，缓存mysql数据
一、搭建LNMP+Redis 1. server1安装nginx和php以及php相关插件 安装nginx
解压
tar zxf nginx-1.18.0.tar.gz vim auto/cc/gcc ###这一步是为了取消debug模式，比较省空间，可以不做 安装依赖
yum install -y pcre-devel zlib-devel 编译
./configure --prefix=/usr/local/nginx 安装
make &amp;&amp; make install 安装php及相关插件 gearman（后面会用到，为了实现redis更新mysql内容）
配置nginx为系统服务
vim /usr/lib/systemd/system/nginx.service 软连接，将nginx配置文件连接到/etc下
ln -s /usr/local/nginx/conf/nginx.conf /etc/ 修改nginx配置文件如下
vim /etc/nginx.conf 开启nginx测试
systemctl start nginx.service 浏览器测试访问 开启php，编写php页面测试
systemctl start php-fpm.service 浏览器测试访问
2. server2安装redis 上一篇讲过安装redis步骤，这里就跳过了，详情见
https://blog.csdn.net/qq_36023219/article/details/106179458
打开redis
3. server3安装数据库 这里直接用官方yum源自带的mariadb
yum install -y mariadb-server 启动服务
systemctl start mariadb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/883b07c78974d6f1f6566e921235e896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc1947be21835519fe9a79abc8e0d9db/" rel="bookmark">
			pom下载包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先检查idea配置的maven是否正确，修改idea默认的maven地址，正确的情况下：
1、pom下载文件出现lastUpdated：在pom文件里面添加镜像私服
repositories 如：
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/libs-milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 再如阿里云的镜像：
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 2、pom不下载包问题：进入pom所在目录，mvn clean或者mvn clean package一下。
3、下载包报错 Return code is: 501, ReasonPhrase: HTTPS Required：
这是因为2020年1月15日起，中央存储库不再支持通过纯HTTP进行的不安全通信，并且要求对存储库的所有请求都通过HTTPS进行加密。于是我们在构建过程中所依赖的settings文件中，加入了一以下配置：
&lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;https://repo1.maven.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d6497b092ef72b2a9591326c98ee7e/" rel="bookmark">
			MYSQL无法启动。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2019-09-29T09:16:07.029209Z 0 [ERROR] [MY-011071] [Server] D:\phpstudy_pro\COM\..\Extensions\MySQL8.0.12\\bin\mysqld.exe: Error while setting value 'STRICT_TRANS_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_ENGINE_SUBSTITUTION' to 'sql_mode' 2019-09-29T09:16:07.029551Z 0 [ERROR] [MY-010119] [Server] Aborting 2019-09-29T09:16:07.029648Z 0 [Note] [MY-010120] [Server] Binlog end **解决办法 找到my.ini 找到sql_mode 是每次升级后sql_mode的值。逗号后面都会自动加上空格导致无法启动，要手动删掉空格就可以了** 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593ad9b9bb68e8bafbbd56f7b4725fb9/" rel="bookmark">
			win10系统VMware虚拟机无法运行(报错)的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象描述：
1.Windows更新后第一次打开VMware，出现连接异常（报错如下），而且左边状态栏的虚拟机也无法操作，新建虚拟机也无法显示在我的计算机，在过程中也出现“该虚拟机似乎正在使用中”“VMware Workstation 不可恢复错误: (vmx)错误”等错误。
“VMware Workstation 无法连接到虚拟机。请确保您有权运行该程序、访问该程序使用的所有目录以及访问所有临时文件目录。VMware Authorization Service 当前未运行。”
2.因强制关闭VM虚拟机导致的虚拟机重新打开时提示报错无法运行。报错如下：
“VMware Workstation 无法连接到虚拟机。请确保您有权运行该程序、访问该程序使用的所有目录以及访问所有临时文件目录。VMX进程已提前结束。”
3.win10系统开启hyper-V服务后一些系统服务与VM虚拟机配置冲突或不兼容，导致VM虚拟机无法使用。报错如下：
“VMware workstations 与 Device/credential guard不兼容。在禁用Device/ Credential Guard后，可以运行VMware Workstation”。
考虑到情况，环境不一样，特将使用到的操作都列出来，以供参考。
各问题对应解决方法：
1.第一种问题较好解决，这里提供4种方法（推荐使用前两种）：
A.考虑服务VMware Authorization Service没有打开。
操作：cmd-&gt;services.msc-&gt;Vmware Authorization Service-&gt;选择自动、右击选择启动。重启VM虚拟机。
B.以管理员身份运行VMware。
C.修改vmci0.present="TRUE" 找到虚拟机相对应的“***.VMX文件”；用记事本打开它，找到这一行:vmci0.present="TRUE"将TRUE改为FALSE或者直接将这行删除。（只是临时解决兼容性问题）。重启VM虚拟机。
D.删除HKEY_CURRENT_USER\Software\VMware, Inc.
操作：cmd-&gt;regedit-&gt;删除HKEY_CURRENT_USER\Software\VMware, Inc.这个项，并按F5刷新注册表。把虚拟机目录下的以.lck名的文件夹删除，可以使用一些快捷的文件搜索器，比如Everything。若还是出现了VMware Workstation 不可恢复错误: (vmx)错误，则进行如下操作：
找到并删除这个*.vmss文件给删了,再重新打开虚拟机。
2.该问题相较于第一种问题稍微麻烦一点，这里提供3种方法：
A.将第一种问题的A、B解决方法尝试一遍。
B.打开任务管理器，将进程中的VM相关进程全部结束。重启电脑，重新打开VM。
C.以上方法若都不能解决，打开VM，选中自己打不开的虚拟机，右键-电源-关机；然后右键-管理-克隆，选择创建完整虚拟机克隆（进行该操作根据配置不同需要10-30分钟不等）。然后克隆出来的虚拟机就可以运行了，原虚拟机可以选择删除掉。
3.该问题最难解决，这里也提供3种方法：
A.取消hyper-v，具体操作：控制面板-&gt;程序和功能-&gt;启用或关闭windows功能-&gt;找到hyper-v的选项-&gt;取消勾选（win10家庭版，若没有该选项，则拉至底部找到虚拟机服务-&gt;取消勾选），重启电脑。（家庭版使用该方法大概率失败，需尝试其他方法）
B.以管理员身份运行命令提示符，运行以下命令：
bcdedit /set hypervisorlaunchtype off
重启系统后再次运行VMware Player，就不会再出现与Device/Credential Guard不兼容的错误提示了。（win10家庭版仍然不行,可继续尝试其他方法）
C.运行框输入“gpedit.msc”，回车进入“本地组策略编辑器”。在本地组策略编辑器，依次选择“计算机配置-管理模板-系统-Device Guard（设备保护）”。然后双击打开“打开基于虚拟化的安全”的设置。再“打开基于虚拟化的安全”的设置界面，选中“已禁用”，然后点击“确定”。
D.使用UEFI启动方式引导配置。
搜索框输入cmd，以管理员身份打开。然后粘贴如下命令运行：
mountvol X: /s
copy %WINDIR%\System32\SecConfig.efi X:\EFI\Microsoft\Boot\SecConfig.efi /Y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/593ad9b9bb68e8bafbbd56f7b4725fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2a6b75b63baebc4405968b2f030ea8/" rel="bookmark">
			Windows 常用技术命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Excel的方向键被锁定： Dell笔记本按Fn+F6或者直接F6
2.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ffd3283dc1664cb9ba1248da9946874/" rel="bookmark">
			如何在Java中更改文件的上次修改日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个示例，显示使用File.setLastModified（）更改文件的上次修改日期。 此方法接受以毫秒为单位的新修改日期（长类型），需要一些数据类型转换。 package com.mkyong.file; import java.io.File; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class ChangeFileLastModifiedExample { public static void main(String[] args) {	try{ File file = new File("C:\\logfile.log"); //print the original last modified date SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy"); System.out.println("Original Last Modified Date : " + sdf.format(file.lastModified())); //set this date String newLastModified = "01/31/1998"; //need convert the above date to milliseconds in long value Date newDate = sdf.parse(newLastModified); file.setLastModified(newDate.getTime()); //print the latest last modified date System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ffd3283dc1664cb9ba1248da9946874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e204720cb22a41a5075748200e9ecacb/" rel="bookmark">
			idea springboot与redis整合（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea springboot与redis整合（1） idea springboot与redis整合的一部分创建springbot项目java目录如下添加依赖编写redis.properties编写RedisConfig类编写 RedisUtil类 idea springboot与redis整合的一部分 创建springbot项目 java目录如下 这篇文章主要介绍base层
添加依赖 编写redis.properties 编写RedisConfig类 设置redis的属性，端口号，最大连接数，最小连接数，密码账号，主机地址
连接redis
编写 RedisUtil类 上图中jedis.close()如果报错，选用旧版本redis依赖
log报错 ，idea下载lombok插件及相关依赖
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24cc7a6f92f81c3fb65ed02c79e7952/" rel="bookmark">
			齐次坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		齐次坐标 一、背景二、齐次坐标与笛卡尔坐标三、进阶 一、背景 在数学里，齐次坐标（homogeneous coordinates），或投影坐标（projective coordinates）是指一个用于投影几何里的坐标系统。该词由奥古斯特·费迪南德·莫比乌斯于1827年在其著作《Der barycentrische Calcul》一书内引入。
齐次坐标可让包括无穷远点的点坐标以有限坐标表示。使用齐次坐标的公式通常会比用笛卡儿坐标表示更为简单，且更为对称。齐次坐标广泛的应用于计算机图形及3D计算机视觉。使用齐次坐标可让计算机进行仿射变换，通常其投影变换能简单地使用矩阵来表示。
在齐次坐标的定义中，一个点的齐次坐标乘上一个非零标量，所得坐标会表示同一个点。因此齐次坐标也用来表示无穷远点，为此一扩展而需用来表示坐标的数值比投影空间的维度多一。
二、齐次坐标与笛卡尔坐标 在齐次坐标里，需要两个值来表示在投影线上的一点，需要三个值来表示投影平面上的一点。则点 ( X , Y ) (X, Y) (X,Y) 在齐次坐标里面变成了 ( x , y , w ) (x, y, w) (x,y,w) ，并且有 X = x / w X = x/w X=x/w ， Y = y / w Y = y/w Y=y/w 。笛卡尔坐标系下 ( 1 ， 2 ) (1，2) (1，2) 的齐次坐标可以表示为 ( 1 , 2 , 1 ) (1, 2, 1) (1,2,1) ，如果点 ( 1 , 2 ) (1, 2) (1,2) 移动到无限远处，在笛卡尔坐标下它变为 ( ∞ , ∞ ) (∞, ∞) (∞,∞)，然后它的齐次坐标表示为 ( 1 , 2 , 0 ) (1, 2, 0) (1,2,0) ，因为 ( 1 0 , 2 0 ) = ( ∞ , ∞ ) (\frac{1}{0}, \frac{2}{0}) = (∞, ∞) (01​,02​)=(∞,∞)，我们可以不用 ∞ ∞ ∞ 来表示一个无穷远处的点。下面为齐次坐标与笛卡尔坐标的转换关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c24cc7a6f92f81c3fb65ed02c79e7952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60cc94172e47ab8832a2ad40b8a2203b/" rel="bookmark">
			鸟哥的私房菜基础篇：十四，磁盘配额与进阶文件系统管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸟哥的私房菜基础篇：十四，磁盘配额与进阶文件系统管理 概念14.1 磁盘配额（quota）的应用 概念 linux的例行性工作的调度，是通过crontab与at这来实现的。
14.1 磁盘配额（quota）的应用 什么是quota
Linux多用户多任务环境，多人共同使用一个硬盘空间，需要给使用者限制磁盘的容量，妥善分配系统资源。 一般用途：
a. 限制某一群组所能使用的最大磁盘配额。
b. 限制某一使用者的最大磁盘配额
c. 限制某一目录的最大磁盘配额： 默认文件系统是EXT家族，该种文件系统的磁盘配额主要是针对整个文件系统来处理，大多数针对挂载点设计，xfs可以使用project这种模式，能够针对个别的目录（非文件系统）来设计磁盘配额。
quota的使用限制：
a. EXT文件系统家族仅能针对整个FS。无法针对单一目录来设计。
b. 核心必须支持quota。
c. 只对一般身份使用者有效。 root不能设置，因为具有管理整个系统的所有数据的权限。
d. 若启用SELinux，不是所有的目录均可设置。启用之后，/home才可以，限制SELinux就能设置其他的了。
quota针对XFS FS的限制project分为下面几部分：
a. 针对使用者，群组或个别目录（user，group，project）
b. 文件限制或文件数量限制（block或inode）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5062b25d8803afff9b66991bba57e5fe/" rel="bookmark">
			鸟哥基础篇之--------例行性工作（crontab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是例行性工作 如，周报，周会等定期的。
如果计算机能够主动通知，则轻松方便很多。这就产生了定时任务。
不由得 让人想到相关的几点内容，时钟周期，定时器，和AI。特此总结了一个图片，如下，不由得感慨，当年计算机的诞生其中关键一点时钟周期的思想真是优秀。让死的一行一行的文字内容成了活的可执行的，crontab让一项一项功能成了活的，小到闹铃大到机械化的工业制造，而如今津津乐道的AI，也是在此基础上进行深度学习或者训练模型，进行功能的自我迭代和数据模拟建模分析等，以达到更高的要求。一切的思想是有共性的。向前辈看齐。
1.1 Linux工作调度的种类 例行性：crontab。对应的服务是crond。定时器。
# .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 突发性：at。对应的服务是atd。处理仅执行一次的任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5062b25d8803afff9b66991bba57e5fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877849208ef620787a409d10bada8e88/" rel="bookmark">
			MySQL Shell副本集和MGR快速搭建详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		墨墨导读：本文是 MySQL Shell 快速搭建 副本集 和 MGR集群的全过程，分享至此，希望对大家有帮助。
简介
MySQL Shell是MySQL Server的高级客户端和代码编辑器。除了和mysql命令行客户端程序一样，使用常规的SQL功能外，MySQL Shell还提供了JavaScript和Python的脚本功能，并包含多个API，其中的AdminAPI用于操作InnoDB Cluster。
安装部署
下载：
https://dev.mysql.com/downloads/shell/
安装
#tar -zxvf mysql-shell-8.0.20-linux-glibc2.12-x86-64bit.tar.gz -C /opt/idc/mysql-shell8.0.20 ####配置 #vi /etc/profilt export PATH=/opt/idc/mysql-shell8.0.20/bin:$PATH #Source /etc/profile 说明：
https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-connections.html
备注：是不是很简单，但需要注意每个mysql版本都有对应shell版本。建议对应版本使用。shell 是跟着mysql版本进行维护的。
ReplicaSet：只能搭建主从架构
通过shell脚本 搭建主从
创建集群
[root@ens8 idc]# mysqlsh MySQL Shell 8.0.20 Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/877849208ef620787a409d10bada8e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a15a5dcd1dabeedff466873f32135e/" rel="bookmark">
			PostgreSQL修改数据目录方法记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看当前数据库的data目录 进入psql查看当前数据库的data目录
[root@localhost ~]# su - postgres -bash-4.1$ psql psql (8.4.18) Type "help" for help. postgres=# show data_directory ; data_directory --------------------------------- /postgres_5432 (1 row) 关闭数据库 [root@localhost ~]# /bin/su -l postgres -c "/usr/bin/pg_ctl -D /postgres_5432/ stop" # 如果是yum方式安装的话可以使用service postgresql stop或systemctl stop postgresql 把当前数据库拷贝到新位置 用rsync方式把数据库内容拷贝到新位置
-a 保留的权限和其他目录属性, 能避免未来的权限问题-v 提供详细输出，以便能够看到进度 [root@localhost ~]# rsync -av /postgres_5432 /data/pgdata_5432 修改postgresql.conf配置文件 编辑postgresql.conf文件，找到data_directory字段，修改该字段，保存退出
如果配置文件中没有该字段则直接加在文件末尾即可
data_directory = '/data/pgdata_5432/postgres_5432/' 启动数据库 [root@localhost ~]# /bin/su -l postgres -c "/usr/bin/pg_ctl -D /postgres_5432/ start"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27a15a5dcd1dabeedff466873f32135e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75cb6be0ed7158f906bf6a7cac64f2cb/" rel="bookmark">
			sql server 学习教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql server 学习教程 SQL Server 系统数据库mastermodelmsdbtempdb 索引定义分类唯一索引主键索引聚集索引(Clustered)非聚集索引(Non-clustered) 作用优点缺点创建索引的原则创建索引修改索引删除索引查看索引 视图创建视图查询视图修改视图删除视图 存储过程定义优点创建存储过程执行存储过程修改存储过程删除存储过程 触发器定义优点作用分类DML(数据操作语言,Data Manipulation Language)触发器DDL(数据定义语言,Data Definition Language)触发器登录触发器注意 工作原理创建触发器修改触发器禁用触发器启用触发器查询已存在的触发器查看触发器触发事件查看创建触发器语句删除触发器 作业同步（一主多从）链接服务器连接远程/局域网数据openrowsetopenqueryopendatasource/openrowset SQL 语句变量局部变量全局变量 判断语句IF ELSECASE 循环 while复制表(只复制结构,源表名：a 新表名：b) (Access可用)拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)跨数据库之间表的拷贝(具体数据使用绝对路径)(Access可用)初始化表table1删除数据库表分页并集 UNION 运算符交集 INTERSECT去重 EXCEPTROW_NUMBER() SQL Server 系统数据库 在我们安装 SQL Server 的时候，会自动创建下面的四个数据库。
master master 数据库记录了所有的 SQL Server 数据库系统的系统级信息，如用户帐户，配置设置，并在所有其他数据库信息。
model model 数据库是一个模板数据库。每当创建一个新的数据库（包括系统数据库的TempDB），会创建一个以 Model 数据库为副本数据库，并更改成你创建数据库时所用的名称。
msdb msdb 数据库是 SQL Server 代理的数据库，用于配置警报使用 SQL Server 代理和预定作业等。
tempdb tempddb 数据库是由 SQL Server 用于暂时存储数据的，这其中包含所有临时表，临时存储过程，并通过 SQL Server 生成任何其他临时存储需求。
这些系统数据库有它们特有的用处，系统数据库是我们新建数据库的模板。
SQL Server 是不区分大小写的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75cb6be0ed7158f906bf6a7cac64f2cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92663d23a1388ec7c69b01a537d0b5ad/" rel="bookmark">
			js设置单选框为选中状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js设置单选框为选中状态
HTML部分 &lt;input type="radio" value="1" name="onlinestatus" /&gt; &lt;input type="radio" value="2" name="onlinestatus" /&gt; js部分 $("[name='onlinestatus']").get(0).checked = true; // get()函数是jq自带的获取第N个radio 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/079a052e353b73312a8c8a5f8ca19a4d/" rel="bookmark">
			Linux 之 Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装redis 1. 获取安装包并解压
这里使用5.0.4版本，最新版为5.0.5，尝试安装发现有很多问题，makefile文件似乎不完整
2. make
确保安装了编译器yum install gcc
make 3. 安装
make install 安装redis服务 默认6379端口
查看端口
netstat -antulpe | grep redis 默认绑定本地6379端口
修改配置文件，更改绑定ip端口
vim /etc/redis/6379.conf 重启服务
刚才修改的绑定ip端口已生效
依照刚才操作，在server2也安装redis
二、Redis主从复制 配置server2为server1的slave
在server2更改配置文件
vim /etc/redis/6379.conf 重启服务
测试：
在server1利用redis-cli工具输入数据
在server2读取
可以看到，server1写入的数据，server2已经复制了（注：server2为slave节点，只读，无法写入）
三、Redis高可用（哨兵） Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：
监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。 在搭建高可用时，需要用到三个节点，所以我们再创建一台虚拟机安装redis
配置server3也是server1的slave
修改哨兵配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/079a052e353b73312a8c8a5f8ca19a4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36496730ef5505c8ec7101554a5cceda/" rel="bookmark">
			第四章（2）：通过SYSREF实现确定性延时（subclass 1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2. 通过SYSREF实现确定性延时（subclass 1） subclass 1主要通过SYSREF信号实现TX和RX设备之间LMFC的对齐，SYSREF信号必须被分配到所有的转换设备和逻辑设备。
通过使用高准确度的device clock和SYSREF信号，可以最小化延时的不确定度。规范强烈建议所有TX和RX设备的SYSREF信号都来自于同一个芯片。关于SYSREF和本地时钟的性能要求和调整能力在前面的文章中已经描述过了。
由于SYSREF有多种格式，比如周期的、单脉冲和多个脉冲，并不是所有器件都支持这三种模式。为了使SYSREF在设备正常工作时关闭，subclass 1设备需要满足以下要求。
RX端的逻辑设备（如接收ADC数据的FPGA）应该具备发送generate SYSREF请求的能力，该请求使时钟发生器为系统中的所有设备产生一个或多个SYSREF 脉冲。任何时间，只要一个link通过SYNC接口发送重同步请求，RX端的逻辑设备都可以发送generate SYSREF请求，该功能是否使能可以由用户决定。 TX端的逻辑设备（如向DAC发送数据的FPGA）应该具备发送generate SYSREF请求的能力，该请求使时钟发生器为系统中的所有设备产生一个或多个SYSREF 脉冲。任何时间，只要一个link通过SYNC接口发送重同步请求，RX端的逻辑设备都可以发送generate SYSREF请求，该功能是否使能可以由用户决定。 TX和RX设备能够决定是否响应第一个SYSREF之后的其他SYSREF脉冲，并根据该脉冲对本地帧和多帧时钟进行相位对齐。根据规范，TX和RX设备一般会提供以下选项。
检测每一个SYSREF脉冲，如果当前LMFC和frame clock需要进行相位调整，则进行相应的相位调整。 通过一个输入管脚，或者通过配置接口发送配置命令来控制设备，使其在接收到后续SYSREF时对LMFC和frame clock进行强制相位对齐。 通过一个输入管脚，或者通过配置接口发送配置命令来控制设备，使其忽略后续的所有SYSREF。 上述情况只有在设备已经完成初始化并发送了重同步请求，或者link发现错误并发送了重同步请求的情况下才会发生。此外，subclass 1设备应该给出以下时序参数：
从采样到SYSREF脉冲的Device clock的上升沿，到LMFC上升沿之间的延迟。 2.1 示例1：确定性延时等于multiframe周期 如果需要确定性延时等于一个multiframe周期，需要将RBD的值设置为K。下图描述了这种延时的实现过程。
图中上半部分为TX设备，下半部分为RX设备。TX设备一直在发送K码。当TX设备监测到SYSREF之后应该产生本地的LMFC，TX设备需要给出从检测到SYSREF的device clock的上升沿，到下一个LMFC之间的延迟参数。该延迟应该是一个确定的值。
RX设备的所有lane能够正确接收K码之后，会将在下一个LMFC上升沿后撤销SYNC信号（SYNC低有效）。当TX设备检测到SYNC撤销后，会在下一个LMFC上升沿开始发送ILA。
由于不同lane延时不同，RX设备中每个lane收到ILA的时间有差异，但是这些ILA都被elastic buffer缓存。当RX端检测到所有lane都接收到ILA启动信号后（即所有lane都至少检测到R码），将会在下一个LMFC开始同步释放elastic buffer。
最后需要提一下的是，上图是基于TX端和RX端的LMFC严格对齐的前提。如果两者的LMFC有偏差，自然也会导致延时出现一定的偏差。
2.2 示例2：最小化确定性延时 当需要确定性延时小于multiframe周期时，需要将RBD值设置为小于K的值。
同样假设TX和RX端的LMFC对齐。该例中，RBD设置值小于K。这样elastic buffer才有可能提前释放缓冲区。
当RX端所有lane都完成组同步后，将在下一个LMFC上升沿撤销SYNC。紧接着TX设备检测到SYNC撤销，并且在下一个LMFC开始发送ILA。RX设备的所有lane将会检测ILA起始信号。
在LMFC上升沿后的RBD个frame clock周期后，正常情况下RX设备的所有lane应该都检测到了ILA的起始信号，此时会同步释放elastic buffer。这种情况下，确定性延时等于RBD个frame clock周期。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca6e786f60d170eed037eb3550d6fa9/" rel="bookmark">
			IDEA 设置背景颜色为黑色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑夜给了我黑色的眼睛我却用它来寻找光明。既然是黑色的眼睛那就设置一波黑色背景吧。在黑色额背景中寻找光明。
设置步骤：
File-&gt;Settings-&gt;Appearance&amp;Behavior-&gt;Appearance
就是如此的简单迅速，黑色诱惑一波。
就很nice！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53403b751bdde6ed772b80584767bcdb/" rel="bookmark">
			要不要做会员？解构会员体系的本质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每款产品都在做会员。
无论电商、外卖、视频、音乐，甚至墨迹天气，都在做会员。
为什么大家要做会员？会员提供了什么价值？
会员的本质又是什么？做会员能带来多大收益？
思考清楚上述问题，我们才能明白会员的背后逻辑。同样，我们也才能更好的将会员应用于自身业务，达到预期。
那么，到底什么是会员？
01
会员的两大特征
透过现象看本质，会员有两大特征。
会员是有成本的用户粘性
会员首先是粘性体系。
会员是用户，会员体系是用户运营，目的是用户粘性。
从产品的角度出发，会员让部分用户获得更好的服务，享受更好的权益，然后用户认可平台价值，从而依赖平台，长期使用。这个过程就是粘性。
但产品没有义务免费提供增值服务，也没有能力服务于全部用户，因此需要筛选出部分用户。成本就是筛选的方式。
1 成本是筛选分层的过程
用户有成本，需要付出代价才能享受增值权益。这里的成本一般是金钱，或者用户在平台付出的金钱等价物。
涉及到成本，用户就会自发分层。愿意付钱的区分不愿意付钱的，愿意付大钱的区分愿意付小钱的用户。
2 成本是价值传递的过程
市面上竞品很多，用户用钱投票。投票的过程是对产品认可的过程。
有价值才会被认可，能够让用户付费的价值，才是真正的价值。因此，成本在一定程度上，也是价值的体现。
3 成本是加强粘性的过程
用户不会珍惜没有付出任何成本的免费送。但只要用户付出了金钱，有了金钱的沉没成本，就会格外珍惜。
珍惜才能带来用户粘性。这是用户的内驱力，驱动用户使用产品以保证购买的等值或超值。
综上，会员的第一大特征就是有成本的用户粘性。
会员是无反感的用户歧视
会员的另一个明显特征，就是用户歧视。
歧视是不同的用户待遇不同，福利不同，服务也不同。但依托于存在的会员体系，用户一般不反感，甚至支持。
1 用户会自发站队
会员是一种方式，一种解决歧视的方式。
利用会员，把问题抛给用户。产品的权益就在那里，让用户自己决策，做出选择。
用户此时会自发分层，快速站队。大家各取所需，其乐融融。
2 平台会保持公平
公平体现在产品只负责机制设计，不界定谁是特殊用户。
平台对每个用户都公平。不公平的是角色，但用户可以自由选择成为特殊角色。此时，就保证了无反感的用户歧视。
3 平台会保持底线
但，凡事都有例外。若产品做的过分，就会招致强烈的抵触情绪。比如某度的网盘，普通用户的上传下载体验被严重阉割，基本无法使用。
这个问题的根源在于角色设计差异巨大，让普通用户无法接受。所以，凡事留一线，平台有底线。
02 会员的价值
会员是一套成熟的体系。对用户和产品都有价值，这个价值可以从两个方面来看。
用户价值
用户价值的逻辑很简单。普通用户解决问题，会员用户更快更好的解决问题。这个更快更好就是价值。
产品做会员体系，其实也是定义更快更好的过程，将稀缺的价值包装出来，应用到部分人身上，让他们有偿使用。
会员让高价值用户更顺畅，这个顺畅体现在以下几个方面：
1 价格更低
所有的用户都是价格敏感型，所有的用户都想着得到实惠。让用户收益大于付出，就是最大的转化动力。价格就是用户价值的第一梯队。
会员有更低的价格，这个价格对比，会刺激用户成为会员，且由于买的越多便宜的越多，用户的会员价格也会被不断稀释。用户会觉得越来越划算。
比如海豚家的美妆，会员价和非会员价，差异巨大。
2 速度更快
速度，决定了用户的体验。
一方面是使用体验。速度代表着资源倾斜，产品将资源倾斜给会员用户，开辟专属通道、免排队、加速抢票等各种服务，叫好又叫坐。
另一方面是竞争体验。在用户间存在竞争关系的体系里，付费的一方也占据先发优势。
比如QQ的等级体系，游戏的会员激励等等。
3 尊贵标识
装逼是人的第一刚需，所以尊贵身份必须摊牌。
标识存在于有社交需求的场景，除了极少数隐私产品外，尊贵的标识都是外漏的。一方面给会员一定的身份认同，另一方面也能促进普通用户的对比心理、引导转化。
尊贵标识的核心是营造用户间的差异性，借助差异性引导用户引导用户行为，因此可以有其他变种玩法。
比如，微博为什么要把用户发微博的手机型号漏出来？
4 专享权益
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53403b751bdde6ed772b80584767bcdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae429322a164e7bcfe7f64e6dfa3916e/" rel="bookmark">
			C#模拟鼠标和键盘操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文旨在自己动手实现一个类似于“按键精灵”的桌面软件。第一部分介绍了简单的模拟方式，但是有些软件能够屏蔽掉这种简单模拟带来的效果，因此第二部分将介绍如何从驱动级层面进行模拟。
“游戏外挂一般分为三个级别：初级是鼠标、键盘模拟，中级是Call游戏内部函数，读写内存，高级是抓包，封包的“脱机挂”（完全模拟客户端网络数据，不用运行游戏）。用C#写外挂的不是很多，大部分是C++，主要原因是MS的C#目前不支持内联汇编功能。因此用C++写底层库，然后用C#调用成为DONET爱好者开发外挂的首选。”——某开发者言
简单的模拟方式
模拟鼠标操作
Windows API介绍
.NET没有提供改变鼠标指针位置、模拟点击操作的函数,但是可以通过调用Windows API函数实现。
[DllImport("user32.dll")]
static extern bool SetCursorPos(int X,int Y);
该函数用于设置鼠标的位置,其中X和Y是相对于屏幕左上角的绝对位置.
[DllImport("user32.dll")]
static extern void mouse_event(MouseEventFlag flags,int dx,int dy,uint data,UIntPtr extraInfo);
该函数不仅可以设置鼠标指针绝对位置,而且可以以相对坐标来设置位置.
其中flags标志位集,指定点击按钮和鼠标动作的多种情况.dx指鼠标沿x轴绝对位置或上次鼠标事件位置产生以来移动的数量.dy指沿y轴的绝对位置或从上次鼠标事件以来移动的数量.data如果flags为MOUSE_WHEEL则该值指鼠标轮移动的数量(否则为0),正值向前转动.extraInfo指定与鼠标事件相关的附加32位值.
[DllImport("user32.dll")]
static extern IntPtr FindWindow(string strClass, string strWindow);
该函数根据类名和窗口名来得到窗口句柄,但是这个函数不能查找子窗口,也不区分大小写.如果要从一个窗口的子窗口查找需要使用FIndWindowEX函数.
[DllImport("user32.dll")]
static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string strClass, string strWindow);
该函数获取一个窗口的句柄,该窗口的类名和窗口名与给定的字符串相匹配,该函数查找子窗口时从排在给定的子窗口后面的下一个子窗口开始。其中参数hwnParent为要查找子窗口的父窗口句柄,若该值为NULL则函数以桌面窗口为父窗口,查找桌面窗口的所有子窗口。 hwndChildAfter子窗口句柄,查找从在Z序中的下一个子窗口开始,子窗口必须为hwnParent直接子窗口而非后代窗口,若hwnChildAfter为NULL,查找从父窗口的第一个子窗口开始。 strClass指向一个指定类名的空结束字符串或一个标识类名字符串的成员的指针。 strWindow指向一个指定窗口名(窗口标题)的空结束字符串.若为NULL则所有窗体全匹配。返回值:如果函数成功,返回值为具有指定类名和窗口名的窗口句柄,如果函数失败,返回值为NULL。
实现步骤
1-引入命名空间using System.Runtime.InteropServices; 因为要使用user32.dll中的接口。
2-创建一个新类MouseFlag
3-声明函数 - 此处的位置都是屏幕绝对位置 - 设置鼠标位置：public static extern int SetCursorPos(int x, int y); - 鼠标事件：static extern void mouse_event(MouseEventFlag flags, int dx, int dy, uint data, UIntPtr extraInfo);虽然这个已经弃用了，但是上手简单。这里需要一个类型：MouseEventFlag
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae429322a164e7bcfe7f64e6dfa3916e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2237509e2e39f12a2f9a83bd361de837/" rel="bookmark">
			SSLContext.getInstance()中参数设置TLS版本无效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题:SSLContext sc = SSLContext.getInstance(“TLSv1.1”)设置后，https握手连接使用中使用的TLS版本还是jdk的默认版本（jdk7默认是TLSv1，jdk8默认是TLSv1.2）。
原因：代码中有这个段conn.getOutputStream().write(postBody.toString().getBytes());// 输入参数 进行输入参数，而SSLContext sc = SSLContext.getInstance(“TLSv1.1”)放在conn.getOutputStream().write(postBody.toString().getBytes())代码的后面，导致设置的TLSv1.1不生效。
解决办法：将SSLContext.getInstance(“TLSv1.1”)放到conn.getOutputStream().write(postBody.toString().getBytes())的前面即可。
以下在jdk8环境下的测试：
这样设置不生效
这样设置才生效
具体·的原因是因为在conn.getOutputStream()获取输出流的过程中，conn就已经做了conn.connect（）方法了，一条连接已经建立了，后面再进行SSLContext sc = SSLContext.getInstance(“TLSv1.1”);指定TLS的版本自然就不会生效了。
这仅仅是我个人的理解，不一定对，仅供大家参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b4803f41282a1d1aa9e50f6f1f8b279/" rel="bookmark">
			解决谷歌浏览器无法更新【4:0x80070005】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		碰到的问题 点击这个关于Google Chrome,发现更新失败，错误代码【4:0x80070005】 但是，因为碰到问题没有截图，这里就不能放在失败的截图啦，哎呀妈耶。
官网给的方法，总结就是重装浏览器，但是，我那么多数据在浏览器，怎么可以删除呢？ 解决问题 进入服务窗口 如何打开，不会打开的话，进入传送门https://jingyan.baidu.com/article/495ba841e2f83638b30ede0b.html
找到下面这两个，右键点击属性修改成手动（2个都修改） 再进入浏览器的更新页面，就可以了。 如果还是不行，就多刷新几次页面，或者重启就可以了 参考
https://blog.csdn.net/qq_41448272/article/details/85268802?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-13.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-13.nonecase
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5517326358f538f59ed721083d5f4abb/" rel="bookmark">
			unity中error CS0117是什么原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		症状
你试着访问某个类型的某个成员（变量、方法等），然后得到了这样子的错误：
error CS0117: __’ does not contain a definition for__’
原因
发生这个错误的原因是该数据类型不含被引用的成员。
CS0117号错误
本例中的错误信息如下：
error CS0117: UnityEngine.PlayerPrefs’ does not contain a definition forSaveGame’
解决方案
查看该类型的定义，检查是否存在该成员，使用这个存在定义的成员。
使用存在定义的成员
更多信息
https://msdn.microsoft.com/en-us/library/c4aad8at(v=vs.90).aspx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab58c0a095621ccf7163da9a3206448/" rel="bookmark">
			计算机网络自顶向下方法 第一章 复习题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer
R1. “主机”和“端系统”之间有什么不同？列举几种不同类型的端系统。Web服务器是一种端系统吗？
答案：
主机和端系统并没有不同。常见的端系统比如笔记本电脑，智能手机等等。Web服务器是一种端系统。
R2. “协议”一词常被用于描述外交关系。维基百科是怎样描述外交协议的？
答案：
百度百科： 国家之间或政府之间缔结的据以确定其相互权利和义务的协议文书，多用于重大的政治、经济、军事、法律等问题的协议。有双边的，也有多边的。狭义仅指以条约命名的协议，如同盟条约、友好条约、和平条约、互不侵犯条约等。广义指不论以何种名称或形式缔结的协议，如条约、公约、协定、联合宣言、联合公报、联合声明、议定书、会谈纪要、换文、合同等。条约、公约等属于国际法律文件,是最重要的外交文书。其缔结和生效程序很严格，需经国家宪法规定的机关批准，完成其法律手续。一般由缔约国各方派代表经正式谈判达成原则协议后,共同拟订条文;次经缔约方国家元首批准,再按商定日期和地点举行换文仪式,交换批准书。通常规定双方缔结的条约，自互换批准书之日起开始生效。条约或公约经签订后，在其有效期内对各缔约国均具有约束力。协定用于缔结意义不十分重大或短期性的协议，其应用较广泛，如贸易协定、海运协定等。议定书通常用于某些具体问题的协议，或用于对已经缔结的条约进行解释、补充、修改或延长其有效期等。协定和议定书的有效期较短，缔结手续也比较简单。换文指双方用互换照会的形式对达成协议的内容予以确认，有时它是条约、协定等的附件。
R3. 标准对于协议为什么重要？
答案：
标准定义了协议的要做什么和具体内容。
R4. 列出6种接入技术。将它们分类为住宅接入、公司接入或广域无线接入。
答案：
住宅接入：光纤接入 DSL接入
公司接入：以太网 WiFi
广域无线接入：3G 4G
R5. HFC宽带是专用的，还是用户间共享的？在下行HFC信道中，有可能发生碰撞吗？为什么？
答案：
HFC带宽是用户间共享的。
下行HFC信道中不会发生碰撞。因为分组是由一个源发出，由不同的端系统接受，因此不存在冲突。
R6. 列出你所在城市中的可供使用的住宅接入技术。对于每种类型的接入方式，给出所宣称的下行速率、上行速率和每月的价格。
答案：
光纤到户。 几十M大概。
R7. 以太LAN的传输速率是多少？
答案：
10M-10G不等。
R8. 能够运行以太网的一些物理媒体是什么？
答案：
双绞铜线，同轴电缆，光纤等等。
R9. 拨号调制解调器、HFC、DSL和FTTH都用于住宅接入。对于这些技术中的每一种，给出传输速率的范围。并讨论有关宽带是共享的还是专用的。
答案：
拨号调制解调器： 速率56kbps 带宽专用（未查到 看其他人答案）
HFC： 下行速率：42.8Mbps 上行速率：30.7Mbps 带宽共享
DSL： 下行速率：24Mbps 上行速率:2.5Mbps 带宽共享
FTTH: 平均下行速率：20Mbps 带宽共享
R10. 描述今天最流行的无线因特网接入技术。对它们进行比较和对照。
答案：
WiFi和4G接入。 WiFi速度快但距离短，4G速度慢但距离远。
R11. 假定在发送主机和接收主机间只有一台分组交换机。发送主机和交换机间以及交换机和接收主机间的传输速率分别是R1和R2。假设该交换机使用存储转发分组交换方式，发送一个长度为L的分组的端到端总时延是什么？（忽略排队时延、传播时延和处理时延）
答案：
总时延=L/R1+L/R2
R12. 与分组交换网络相比，电路交换网络有哪些优点？在电路交换网络中，TDM比FDM有哪些优点？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab58c0a095621ccf7163da9a3206448/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71313c9bf15720adddf11cf3cc333d40/" rel="bookmark">
			数据库定义参照完整性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关系模型的参照完整性在CREATE TABLE 中用FOREIGN KEY 短语定义哪些列为外码，用REFERENCES短语指定这些外码参照哪些表的主码。
例如：关系SC中一个元组表示一个学生选修的某门课程的成绩，（Sno，Cno）是主码，Sno，Cno分别参照引用Student表的主码和Course表的主码。
定义SC中的参照完整性
CREATE TABLE Student
（Sno char（9） not null，　Cno char（4） not null，
Grade SMALLINT，
PRIMARY KEY(Sno，Cno)，　//主键，在表级定义实体完整性
foreign key （Sno）REFERENCES Student（Sno），　//在表级定义参照完整性
foreign key （Cno）REFERENCES Student（Cno），　//在表级定义参照完整性
）;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83e7d07be3d5fedcff56b01e9b3297c/" rel="bookmark">
			计算机 原码、反码、补码（相互转化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念 在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以用补码统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
原码：二进制表示。二进制首位是符号位，0为正，1为负反码：正数，反码和原码一样；负数，符号位不变，其他各位取反补码：正数，补码和原码一样；负数，反码末位加1，有进位则进位，但不改变符号位 二、举个例子：（假设是字节长度为8位） 三、注意：（总结一下就是，-127~127都是正常转换，只有-128一个特殊的只有补码） 八位字节的二进制转化的十进制的最大 正数 为 127（0111 1111）-127只能表示（原码1111 1111）（反码1000 0000）（补码1000 0001）八位字节的二进制转化为十进制的最大 负数 为 -128 （1000 0000）+0和-0的补码是一样的。即 0的补码只有一种表示所以为了避免面混淆，有了-0的原码，便不能有-128的原码反码，这是8位比特位位数限制决定的补码能表示的数的个数中，比原码反码少了一个，所以补码可以多表示一个真值为-128的数 这里有一个很好的文案，可以看看：
https://www.cnblogs.com/flowerslip/p/5933833.html（关于 -128 ，+128，-0，+0，-1 的反码补码）
# 但是在（三.-128的补码为什么是1000 0000）的数学方法的证明那里有个正负好像有点问题
四、比如求解 -127+128 = -1 （两者补码想加，然后转成反码，再转成原码，在把这个二进制转成十进制）
补码相加：0111 1111 + 1000 0000 = 1111 1111
转成反码（末位－1）：（1111 1111）--&gt; 1111 1110
转成原码（除符号位之外按位取反）：（1111 1110）--&gt; 1000 0001
转成二进制：（1000 0001）--&gt; -1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5900f0a5ce46dfa014abcbbcb26f923/" rel="bookmark">
			大学物理实验 空气比热容比的测定 数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		东北林业大学 大学物理实验（A1,B）空气比热容比的测定
实验目的，器材，原理，自行参考实验指导书。
数据处理部分，使用C语言完成，代码如下：
#include &lt;stdio.h&gt; #include &lt;math.h&gt;//后面使用到了log()函数与fabs函数，需要引入math库 int main() { /*定义变量部分。其中p0是实验环境气压，后面会有详细说明。 u1，u2为实验中采集的原始数据。sum是对空气比热容比进行累和，ave是多次实验得到的sum取的平均值 delt是不确定度。 数组a[8]是用来存储空气比热容比的结果，因为答主做实验的时候是采集了8次数据，取平均值， 所以定义了a[8]，如果次数不同，直接修改数组元素个数和循环控制语句即可。*/ double p0,u1,u2,r,p1,p2; double sum,ave,delt; double a[8]; int i;//循环控制变量 p0=0.9768; /*p0为标准大气压，使用时务必注意是否与实验环境一致！ 如不一致，请用仪器显示数值/100作为p0初值！ */ sum=0.0; printf("请输入u1,u2，每一组两个数字输入完后按enter键:"\n"); printf("请注意：每组输入u1和u2时，必须要用英文状态下逗号分开！否则无法得到数据！"\n"); for(i=0;i&lt;8;i++)//循环操作8次，如果实验次数不同，请直接更改循环条件与数组容量即可 { scanf("%lf,%lf",&amp;u1,&amp;u2); /*每组输入u1和u2时，必须要用英文状态下逗号分开！ 否则无法得到数据！*/ p1=p0+(u1/2000.0);//由u1计算p1 p2=p0+(u2/2000.0);//由u2计算p2 a[i]=(log10(p0)-log10(p1))/(log10(p2)-log10(p1)); //计算空气比热容比 printf("p1=%lf,p2=%lf,",p1,p2);//输出每一组计算出的p1，p2的值 printf("r[%d]=%lf\n",i,a[i]);//输出每一组计算出的空气比热容比 sum=sum+a[i];//空气比热容比累和 } ave=sum/8; //求空气比热容比的平均值 delt=fabs(ave-1.402);//利用绝对值求出相对不确定度 printf("ave=%lf\ndelt=%lf",ave,delt);//输出平均值（最终结果）和不确定度 return 0;	} 几点说明：
1.数据类型问题：我没有记错的话，这个实验仪显示的电压值，应该是两位小数。（一年多了，记不清了）为了保证后面计算中间值的准确性，数据类型采用了double型（双精度类型）。
2.说到double型，就必须要注意几个问题：
C语言中常用的小数有两种类型，分别是float和double；float称为单精度浮点型，double称为双精度浮点型。float 始终占用4个字节，double 始终占用8个字节。
在输入double类型的时候，必须使用以下格式：
scanf(%lf,&amp;a[i]); 只有使用%lf，才能正常的得到数据。
但是在输出的时候，使用以下两行语句其中之一都可以：
printf(%f,a[i]); printf(%lf,a[i]); 根据“默认参数提升”规则（在printf这样的函数的可变参数列表中，不论作用域内有没有原型，都适用这一规则）float型会被提升为double型。因此printf()只会看到双精度数。
但需要注意的是，printf中没有定义%lf，但是很多系统可能会接受它。确保可移植性，还是要使用%f。
答主写这个代码的时候，用的是DEV C++，是可以正常运行的。
3.使用VS（Visual Studio）注意
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5900f0a5ce46dfa014abcbbcb26f923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8a5278f1f3cbbbaed7caaebe38adad/" rel="bookmark">
			VS下编译protobuf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/wangshubo1989/article/details/53437190
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ec8af95214252fe06ea2bd4eca1182/" rel="bookmark">
			CSS3-2D转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css3-2D转换 2d转换 转换(transform) 是css3中具有颠覆性的特征之一，可以实现元素的位移、缩放等效果。
移动：translate选转: rotate缩放： scale
2d转换之移动 translate 2d移动时2d转换里面的一种功能，可以改变在页面中的位置，类似定位。
定义2D转换中的移动，验证X和Y轴移动元素tanslate最大的优点: 不会影响到其他元素的位置tanslate中的百分比单位是对于自身元素的tanslate:(50%,50%);对行内标签没有效果 &lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div{ height: 200px; width:200px; } /* 移动荷载的位置：定位 盒子的玩边境 2d转换移动 */ div:nth-child(1){ background-color: red; /* x就是x轴是哪个移动位置 就是y轴上移动位置 中间用逗号隔开 */ /* transform: translate(x,y); */ /* transform: translate(100px,100px); */ /* transform: translateX(x); 只移动x轴 */ /* transform: translateY(y); 只移动y轴*/ } div:nth-child(2){ background-color:blue; transform: translateX(50%); } /* translate里面的参数是可以用 %, 用%移动的距离是盒子自身的高度和宽度来对比的 */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 运用 苏宁 商品页 鼠标hover效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76ec8af95214252fe06ea2bd4eca1182/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f9d0fe21e11a31deefd891d842dd222/" rel="bookmark">
			卷积神经网络性能优化（提高准确率）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文先讲解理论部分，之后会用pytorch给出示例
神经网络是一种在很多用例中能够提供最优准确率的机器学习算法。但是，很多时候我们构建的神经网络的准确率可能无法令人满意，或者无法让我们在数据科学竞赛中拿到领先名次。所以，我们总是在寻求更好的方式来改善模型的性能。有很多技术可以帮助我们达到这个目标。本文将介绍这些技术，帮助大家构建更准确的神经网络。
过拟合 过拟合，典型的表现为训练集损失远远小于验证集损失。而欠拟合则表现为训练集损失大于验证集损失。
保证神经网络在测试集上运行良好的第一步就是验证神经网络没有过拟合。
我们要清楚远远大于的概念，如果训练集损失只比验证集损失多一点点的话，同等数量级(例如0.8与0.9)这种情况下并不是过拟合的表现。我们一般遇到的过拟合应该是0.8(训练集损失)与2.0(验证集损失)这种不在一个量级的损失比。
什么是过拟合呢？
当你的模型开始记录训练数据而不是从中学习的时候，就发生了过拟合。然后，当你的模型遇到之前没有见过的数据时，它就无法很好的运行。为了更好地理解，我们来看一个类比。
我们有一个记性特好的同学，假设一次数学考试马上就要来临了。你和这位擅长记忆的同学开始学习课本。这名同学记住课本中的每一个公式、问题以及问题的答案，然而你要比他来得聪明一些，所以你决定以直觉为基础、解决问题、学习这些公式是如何发挥作用的。考试来了，如果试卷中的问题是直接来源于课本的，那么可以想像那名记忆力超群的同学发挥得更好，但是，如果试题是涉及应用直观知识的全新问题，那么你将会做得更好，而你的朋友会惨败。
如何鉴别模型是否过拟合呢？
你仅仅需要交叉检查训练准确率和测试准确率。如果训练准确率远远高出了测试准确率，那么可以断定你的模型是过拟合了。你也可以在图中画出预测点来验证。下面是一些避免过拟合的技术：
数据正则化（L1 或 L2）；Dropout：随机丢弃一些神经元之间的连接，强制神经网络寻找新的路径并泛化； Dropout类似于bagging ensemble减少variance。也就是投通过投票来减少可变性。通常我们在全连接层部分使用dropout，在卷积层则不使用。但要声明，dropout并不适合所有的情况，请大家不要无脑上Dropout。
Dropout一般适合于全连接层部分，而卷积层由于其参数并不是很多，所以不需要dropout，加上的话对模型的泛化能力并没有太大的影响。如下图：
我们一般在网络的最开始和结束的时候使用全连接层，而hidden layers则是网络中的卷积层。所以一般情况，在全连接层部分，采用较大概率的dropout而在卷积层采用低概率或者不采用dropout。
早停（Early Stopping）：促使神经网络训练早点停止，以减少在测试集中的误差。 超参数调节 超参数是你必须给网络初始化的值，这些数值不能在训练的过程中学到。在卷积神经网络中，这些超参数包括：核大小、神经网络层数、激活函数、损失函数、所用的优化器（梯度下降、RMSprop）、批大小、训练的 epoch 数量等等。
每个神经网络都会有最佳超参数组合，这组参数能够得到最大的准确率。你也许会问，「有这么多超参数，我如何选择每个参数呢？
不幸的是，对每个神经网络而言，并没有确定最佳超参数组合的直接方法，所以通常都是通过反复试验得到的。但是也有一些关于上述超参数的最佳实践：
学习率：
选择最优学习率是很重要的，因为它决定了神经网络是否可以收敛到全局最小值。选择较高的学习率几乎从来不能到达全局最小值，因为你很可能跳过它。所以，你总是在全局最小值附近，但是从未收敛到全局最小值。选择较小的学习率有助于神经网络收敛到全局最小值，但是会花费很多时间。这样你必须用更多的时间来训练神经网络。较小的学习率也更可能使神经网络困在局部极小值里面，也就是说，神经网络会收敛到一个局部极小值，而且因为学习率比较小，它无法跳出局部极小值。所以，在设置学习率的时候你必须非常谨慎。
比如下图利用fastai中的lr_find()函数寻找合适的学习率，根据下方的学习率-损失曲线得到此时合适的学习率为1e-2
如果想要了解更多，这里推荐一篇fastai首席设计师Sylvain Gugger的一篇博客：How Do You Find A Good Learning Rate以及相关的论文Cyclical Learning Rates for Training Neural Networks。
神经网络架构：
并不存在能够在所有的测试集中带来高准确率的标准网络架构。你必须实验，尝试不同的架构，从实验结果进行推断，然后再尝试。我建议使用已经得到验证的架构，而不是构建自己的网络架构。例如：对于图像识别任务，有 VGG、Resnet、谷歌的 Inception 网络等。这些都是开源的，而且已经被证明具有较高的准确率。所以你可以把这些架构复制过来，然后根据自己的目的做一些调整。
优化器和损失函数：
这方面有很多可供选择。事实上，如果有必要，你可以自定义损失函数。常用的优化器有 RMSprop、随机梯度下降和 Adam。这些优化器貌似在很多用例中都可以起作用。如果你的任务是分类任务，那么常用的损失函数是类别交叉熵。如果你在执行回归任务，那么均方差是最常用的损失函数。你可以自由地使用这些优化器超参数进行试验，也可以使用不同的优化器和损失函数。
批大小和 epoch 次数：
同样，没有适用于所有用例的批大小和 epoch 次数的标准值。你必须进行试验，尝试不同的选择。在通常的实践中，批大小被设置为 8、16、32……epoch 次数则取决于开发者的偏好以及他/她所拥有的计算资源。
权重初始化
权重初始化相比于其他的trick来说在平常使用并不是很频繁。为什么呢？原因很简单，因为大部分人使用的模型都是预训练模型，使用的权重都是在大型数据集上训练好的模型，当然不需要自己去初始化权重了。只有没有预训练模型的领域会自己初始化权重，或者在模型中去初始化神经网络最后那几个全连接层的权重。那么大家喜欢用什么初始化权重算法？
当然是kaiming_normal或者xavier_normal。
相关论文：
Delving deep into rectifiers: Surpassing human-level performance on ImageNet classificationUnderstanding the difficulty of training deep feedforward neural networks
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f9d0fe21e11a31deefd891d842dd222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408f859956648dc40aadc0796907e851/" rel="bookmark">
			Spring 源码分析衍生篇三 : lookup-method 和 replaced-method
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、基本使用1. 作用 三、原理实现1. 预处理1.1 AbstractBeanDefinition#prepareMethodOverrides1.2 AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors 2. 真正处理 一、前言 本文是 Spring源码分析：单例bean的获取 - createBean 的衍生文章。主要是因为本人菜鸡，在分析源码的过程中还有一些其他的内容不理解，故开设衍生篇来完善内容以学习。
二、基本使用 1. 作用 lookup-method ：用于注入方法返回结果，也就是说能通过配置方式替换方法返回结果。(在方法或者抽象方法上使用@Lookup注解，将会根据该方法的返回值，自动在BeanFactory中调用getBean()来注入该Bean)replaced-method ：可以实现方法主体或返回结果的替换
通俗来讲 ： lookup-method 可以注入属性bean， replaced-method 替换方法实现。 下面跟着一个Demo来理解
// 基类接口 public interface DemoBase { String hello(); } ... public class DemoA implements DemoBase { public DemoBase getDemoBase() { return new DemoB(); } @Override public String hello() { return "demoA hello"; } } ... public class DemoB implements DemoBase { @Override public String hello() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/408f859956648dc40aadc0796907e851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36964858370bf66b2d92f336ac496a2/" rel="bookmark">
			Spring源码分析五 ：bean的获取③ - getSingleton
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、获取单例 - getSingleton三、创建bean - createBean概述四、创建bean - createBean详解1、resolveBeanClass2、prepareMethodOverrides3、resolveBeforeInstantiation3.1 determineTargetType(beanName, mbd);3.2 postProcessBeforeInstantiation3.3 postProcessAfterInitialization 4、创建bean - doCreateBean4.1 createBeanInstance4.2 applyMergedBeanDefinitionPostProcessors4.3 addSingletonFactory4.4 populateBean4.5 initializeBean4.6 循环依赖检查4.7 registerDisposableBeanIfNecessary 一、前言 本文是笔者阅读Spring源码的记录文章，由于本人技术水平有限，在文章中难免出现错误，如有发现，感谢各位指正。在阅读过程中也创建了一些衍生文章，衍生文章的意义是因为自己在看源码的过程中，部分知识点并不了解或者对某些知识点产生了兴趣，所以为了更好的阅读源码，所以开设了衍生篇的文章来更好的对这些知识点进行进一步的学习。
全集目录：Spring源码分析：全集整理
本文衍生篇：
Spring 源码分析衍生篇三 : lookup-method 和 replaced-methodSpring 源码分析衍生篇四 : 后处理器 BeanPostProcesser 在 Spring 源码分析四 ：bean的加载② - doGetBean详解 文章中，我们介绍了Spring对 获取bean的过程，但是并没有详细解释 Bean 是如何创建的，本文就来分析Spring是如何创建的bean。阅读本文前，建议先阅读衍生篇，方便更好理解，本文有很多涉及到 BeanPostProcesser 的部分。
在 Spring 源码分析四 ：bean的加载② - doGetBean详解 中，我们知道
DefaultSingletonBeanRegistry#getSingleton(java.lang.String, ObjectFactory&lt;?&gt;)这一步创建了bean，如下图：
到了这一步，Spring 就基本对 Bean已经创建好了 不抱什么希望了，所以着手开始自己创建bean。
本文就来分析 getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) 方法整个流程。
二、获取单例 - getSingleton 如下， 是整个 getSingleton方法的代码，做了一些基本注释
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e36964858370bf66b2d92f336ac496a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7188f76dc07267464d89e08cfc2ba630/" rel="bookmark">
			[Android 基础] -- 深入理解 Android Build 系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：
Android Build 系统是用来编译 Android 系统、Android SDK 以及相关文档的一套框架。在 Android 系统中，Android 的源码中包含了许许多多的模块。不同产商的不同设备对于 Android 系统的定制都是不一样的。如何将这些模块统一管理起来，如何能够在不同的操作系统上进行编译，如何在编译时能够支持面向不同的硬件设备，不同的编译类型，且还要提供面向各个厂商的定制扩展，Android 系统如何解决这些问题呢？这就是我们不得不谈的 Android Build 系统。
Android 源码目录结构：
Linux 系统的make命令 在讲解 Android 编译系统之前，我们首先需要了解 Linux 系统的 make 命令。在 Linux 系统中，我们可以通过 make 命令来编译代码。Make 命令在执行的时候，默认会在当前目录找到一个 Makefile 文件，然后根据 Makefile 文件中的指令来对代码进行编译。如 gcc，Linux 系统中的 shell 命令 cp、rm 等等。
看到这里，有的小伙伴可能会说，在 Linux 系统中， shell 和 make 命令有什么区别呢？
make 命令事实也是通过 shell 命令来完成任务的，但是它的神奇之处是可以帮我们处理好文件之间的依赖关系。例如有一个文件T，它依赖于另外一个文件 D，要求只有当文件 D 的内容发生变化，才重新生成文件T。
Make 命令是怎么知道两个文件之间存在依赖关系，以及当被依赖文件发生变化时如何处理目标文件的呢？答案就是在前面提到的 Makefile 文件。Makefile 文件实际上是一个脚本文件，就像普通的 shell 脚本文件一样，只不过它遵循的是 Makefile 语法。Makefile 文件最基础的功能就是描述文件之间的依赖关系，以及怎么处理这些依赖关系。
Android Build 系统核心 Android Build 系统是 Android 系统的一部分，主要用来编译 Android 系统，Android SDK 以及相关文档。该系统主要由 Make 文件，Shell 脚本以及 Python 脚本组成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7188f76dc07267464d89e08cfc2ba630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b00acf9dc8f28eb909a396ec532a89/" rel="bookmark">
			区间DP-----------------凸多边形的划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个具有 NN 个顶点的凸多边形，将顶点从 11 至 NN 标号，每个顶点的权值都是一个正整数。
将这个凸多边形划分成 N−2N−2 个互不相交的三角形，对于每个三角形，其三个顶点的权值相乘都可得到一个权值乘积，试求所有三角形的顶点权值乘积之和至少为多少。
输入格式
第一行包含整数 NN，表示顶点数量。
第二行包含 NN 个整数，依次为顶点 11 至顶点 NN 的权值。
输出格式
输出仅一行，为所有三角形的顶点权值乘积之和的最小值。
数据范围
N≤50N≤50,
数据保证所有顶点的权值都小于109109
输入样例：
5
121 122 123 245 231
输出样例：
12214884
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 55, M = 35; typedef long long LL; int w[N]; LL f[N][N][M]; void add(LL a[], LL b[]){ static LL c[M]; memset(c, 0, sizeof c); for (int i = 0, t = 0; i &lt; M; i ++){ t += a[i] + b[i]; c[i] = t % 10; t /= 10; } memcpy(a, c, sizeof c); } void mul(LL a[], LL b){ static LL c[M]; memset(c, 0, sizeof c); LL t = 0; for (int i = 0; i &lt; M; i ++){ t += a[i] * b; c[i] = t % 10; t /= 10; } memcpy(a, c, sizeof c); } int cmp(LL a[], LL b[]){ for (int i = M - 1; i &gt;= 0; i --) if (a[i] &gt; b[i]) return 1; else if (a[i] &lt; b[i]) return -1; return 0; } void print(LL a[]){ int k = M - 1; while(k &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b00acf9dc8f28eb909a396ec532a89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd698227a3041ab174cd9d0d742be5f/" rel="bookmark">
			java：IO流（缓冲流、对象流、控制台IO、转换流、java.io.File 类 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、IO 流的结构体系
二、缓冲流：BufferedInputStream &amp; BufferedOutputStream
三、对象流：ObjectInputStream &amp; ObjectOutputStream
四、控制台IO
五、转换流 InputStreamReader &amp; OutputStreamWriter
六、java.io.File 类 ：
一、IO 流的结构体系 字符流：用于操作文本文件 .txt .java字节流：用于操作非文本文件 .avi .mp3 .jpg 二、缓冲流：BufferedInputStream &amp; BufferedOutputStream 处理流的一种，包装现有节点流，用于提高效率，内置缓冲区
//非文本文件的复制 @Test public void test1(){ //3. 创建 BufferedInputStream 的实例，包装对应的节点流，用于提高效率 BufferedInputStream bis = null; //4. 创建 BufferedOutputStream 的实例，包装对应的节点流，用于提高效率 BufferedOutputStream bos = null; try { //1. 创建 FileInputStream 的实例，同时打开指定文件 FileInputStream fis = new FileInputStream("C:\\Users\\LI/Desktop/1.jpg"); //2. 创建 FileOutputStream 的实例，同时打开指定文件 FileOutputStream fos = new FileOutputStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd698227a3041ab174cd9d0d742be5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d886a703cefef287b8b08aa7778afd/" rel="bookmark">
			Ngnix 和 uwsgi的区别和作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx和uwsgi的区别和作用：
1, nginx是对外的服务器，外部浏览器通过url访问nginx, uwsgi是对内的服务器，主要用来处理动态请求。
2, nginx接收到浏览器发送过来的http请求，将包进行解析，分析url， a.如果是静态文件请求就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件， b.如果不是静态文件，而是一个动态的请求，那么nginx就将请求转发给uwsgi,
uwsgi接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi,
wsgi根据请求调用应用程序的某个文件，某个文件的某个函数，最后处理完将
返回值再次交给wsgi,wsgi将返回值进行打包，打包成uwsgi能够接收的格式，
uwsgi接收wsgi发送的请求，并转发给nginx,nginx最终将返回值返回给浏览器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a0ce63b37e15dae8005dbc16709bfc/" rel="bookmark">
			docker 进阶 之容器数据卷 DockerFile Docker网络 --- 狂神说
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记整理自 B站UP 狂神说Java Docker https://www.bilibili.com/video/BV1og4y1q7M4
容器数据卷 什么是容器数据卷 docker的理念回顾
将应用和环境打包成一个镜像！
数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化
MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！
容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！
这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！
总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！
使用数据卷 方式一 ：直接使用命令挂载 -v
-v, --volume list Bind mount a volume docker run -it -v 主机目录:容器内目录 -p 主机端口:容器内端口 ➜ ~ docker run -it -v /home/ceshi:/home centos /bin/bash #通过 docker inspect 容器id 查看 测试文件的同步
再来测试！
1、停止容器
2、宿主机修改文件
3、启动容器
4、容器内的数据依旧是同步的
好处：我们以后修改只需要在本地修改即可，容器内会自动同步！
实战：安装MySQL 思考：MySQL的数据持久化的问题
# 获取mysql镜像 ➜ ~ docker pull mysql:5.7 # 运行容器,需要做数据挂载 #安装启动mysql，需要配置密码的，这是要注意点！ # 参考官网hub docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag #启动我们得 -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 -- name 容器名字 ➜ ~ docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a0ce63b37e15dae8005dbc16709bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d54dff578a91cee14c92262ed67ff1/" rel="bookmark">
			ROS Kinetic安装过程以及Website may be down问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于ROS的安装，网上有很多比较详细的教程。最近在安装ROS的过程中遇到一个Website may be down的问题。写这篇博客总结并记录一下。
1、安装过程
(1)添加源:
$ sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list' 或者来自中国的源：
$ sudo sh -c '. /etc/lsb-release &amp;&amp; echo "deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main" &gt; /etc/apt/sources.list.d/ros-latest.list' (2)添加Key：
$ sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 我查过的资料有的地方使用的不同的Key，这里都放在这里备用：
$ sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 当然这里以第一个Key为主，第一个不行再使用第二个Key。
(3)更新：
$ sudo apt-get update (4) 安装ROS，当然推荐Desktop-Full安装，包括了ROS的基础功能（核心功能包、构建工具和通信机制等），还包括丰富的通用函数库、功能包以及常见ROS工具等：
$ sudo apt-get install ros-kinetic-desktop-full (5)初始化rosdep：
$ sudo rosdep init $ rosdep update (6)设置ROS环境变量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d54dff578a91cee14c92262ed67ff1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167a17ac4f9cb9682d24043de9dc7209/" rel="bookmark">
			Google benchmark（C&#43;&#43;性能测试）hmh_1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		google/benchmark是一个由Google开发的基于googletest框架的c++ benchmark工具，它易于安装和使用，并提供了全面的性能测试接口。 Benchmark 是 Google 一个用来对代码片段进行基准测试的库，类似单元测试。 一、Google benchmark的安装 google/benchmark基于c++11标准和googletest框架，所以安装前需要先做一些准备工作。 1、首先是安装g++和cmake
ubuntu：sudo apt install cmake g++ 2、查看g++的版本，确保版本在5.0以上，否则可能不会很好的支持C++11的某些特性
3、随后是googletest框架，你可以选择单独安装，不过这里我选择将其作为benchmark源码树的依赖而不单独安装它，因为benchmark在编译安装时需要googletest但是在使用时并不需要，为了篇幅我们选择后者。
4、源码安装：登录 linux环境
注：准备工作完成后，选择一个合适的目录，然后运行下面的命令：执行以下命令，进行编译安装：
git clone https://github.com/google/benchmark.git cd benchmark git clone https://github.com/google/googletest.git mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE=RELEASE make sudo make install 特别注意：头文件会被安装至/usr/local/include，库文件会安装至/usr/local/lib。
二、google/benchmark的简单使用 接下来，我们将会对比三种访问`std::array`容器内元素方法的性能，进而演示benchmark的使用方法。
1、代码展示：
#include &lt;benchmark/benchmark.h&gt; #include &lt;array&gt; constexpr int len = 6; // constexpr function具有inline属性，你应该把它放在头文件中 constexpr auto my_pow(const int i) { return i * i; } // 使用operator[]读取元素，依次存入1-6的平方 static void bench_array_operator(benchmark::State&amp; state) { std::array&lt;int, len&gt; arr; constexpr int i = 1; for (auto _: state) { arr[0] = my_pow(i); arr[1] = my_pow(i+1); arr[2] = my_pow(i+2); arr[3] = my_pow(i+3); arr[4] = my_pow(i+4); arr[5] = my_pow(i+5); } } BENCHMARK(bench_array_operator); // 使用at()读取元素，依次存入1-6的平方 static void bench_array_at(benchmark::State&amp; state) { std::array&lt;int, len&gt; arr; constexpr int i = 1; for (auto _: state) { arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/167a17ac4f9cb9682d24043de9dc7209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d3a300fbaf6ca2259f681da10946393/" rel="bookmark">
			WebApi参数接收参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.Net中使用WebApi参数接收一直是个问题，不同的传参方式后台接收的方式也不一样。之后.Net Core出来后WebApi也发生了变化，在.Net Framework时WebApi是有单独的ApiController的，在.Net Core时没有独立的ApiController了，这样接收参数上也会有一定的区别。传参有两种Get和Post方式，通过使用发现Get方式接受参数主要是Url传递其实还是比较简单的，Post方式就比较特殊了，内容是放在Body中的，因此不同时形式的传递方式接收就不一样了，为此做了个Demo测试了不同的传参方式对应的不同的接收方式，做了Post参数接收方式表格仅供参考。日后在使用WebApi开发时可以参考下。
.Net Core下的WebApi接口 参数
调用方式字符串多个字符参数[FromBody]特性字符串实体类[FromBody]特性实体类动态类型[FromBody]特性动态类型[FromForm]特性实体类[FromForm]特性字符串[FromForm]特性多个字符串[FromForm]特性动态类型示例string useridstring userid ,string name[FromBody]string useridUserDto dto[FromBody]UserDto dtodynamic dto[FromBody]dynamic dto[FromForm]UserDto dto[FromForm]string userid[FromForm]string userid, [FromForm] string name[FromForm]dynamic dto(PostMan)通过url传参YYNNNNNNNNN(PostMan)form-dataNNNNNYNYYYN(PostMan)x-www-from-urlencodedNNNNNYNYYYN(PostMan)Json application/jsonNNNNYNYNNNN.NetCore HttpClient 通过HttpContent内容为Dictionary键值对形式NNNNNNNYYYN.NetCore HttpClient 通过HttpContent内容为Json格式NNNYYYYNNNN.Net HttpWebRequest Dictionary键值对形式NNNNNNNYYYN.Net HttpWebRequest 内容为Json格式NNNYYYYNNNN.Net HttpClient Dictionary键值对形式NNNNNNNYYYN.Net HttpClient 内容为Json格式NNNYYYYNNNN .Net Framework下的WebApi接口 参数
调用方式字符串多个字符参数[FromBody]特性字符串实体类[FromBody]特性实体类动态类型[FromBody]特性动态类型示例string useridstring userid ,string name[FromBody]string useridUserDto dto[FromBody]UserDto dtodynamic dto[FromBody]dynamic dto(PostMan)通过url传参YYNNNNN(PostMan)form-dataNNNNNYN(PostMan)x-www-from-urlencodedNNNYYNN(PostMan)Json application/jsonNNNYYYY.NetCore HttpClient 通过HttpContent内容为Dictionary键值对形式NNNYYNN.NetCore HttpClient 通过HttpContent内容为Json格式NNNYYYY.Net HttpWebRequest Dictionary键值对形式NNNYYNN.Net HttpWebRequest 内容为Json格式NNNYYYY.Net HttpClient Dictionary键值对形式NNNYYNN.Net HttpClient 内容为Json格式NNNYYYY TIP:Y表示可以接收此类型参数,N表示不能接收此类型参数
以上测试我有通过PostMan工具的各种方式测试，其中通过程序后台调用的是自己封装的HttpClient和HttpWebRequest类库来调用测试，分.Net Framework和.Net Core版本来测试的,下次把测试代码也附上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f972add520fa65cafe22a7deb3a0717f/" rel="bookmark">
			opencv-python包（cv2）中我经常用到的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对图像进行裁剪：
import cv2 img = cv2.imread("pic.jpg") print(img.shape) cropped = img[0:100, 0:400] # 裁剪坐标为[y0:y1, x0:x1] cv2.imwrite("pic_cut.jpg", cropped) 这里，我们先用imread方法读取待裁剪的图片，然后查看它的shape，shape的输出是(1080, 1920, 3)，输出的顺序的是高度、宽度、通道数。之后我们利用数组切片的方式获取需要裁剪的图片范围。这里需要注意的是切片给出的坐标为需要裁剪的图片在原图片上的坐标，顺序为[y0:y1, x0:x1]，其中原图的左上角是坐标原点。最后我们用cv2.imwrite()方法将裁剪得到的图片保存到本地（第一个参数为图片名，第二参数为需要保存的图片） 参考
cv2.resize(img, (w, h))
这个就比较迷了，虽然cv2.imread()进来是以高、宽、通道这样一个顺序的，但是resize的时候使用的顺序是宽高，我佛了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0cb3753451543abaa7632768aec707/" rel="bookmark">
			linux主机间传输数据，No route to host解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在虚拟机上对两台机器进行连接，主机间能ping通，但是在传输数据时报错，错误信息是No route to host。
这种情况一般是数据包命中了iptables的--reject-with icmp-host-prohibited规则。
解决方法是：
在节点上执行iptables -F
iptables -F命令的作用是清除规则链中所有规则。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff64d0366860a6cd7ae4a78cae1ff8b4/" rel="bookmark">
			03_反向传播算法（BP算法）· 原理&#43;演算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反向传播算法（Backpropagation Algorithm，BP算法）是深度学习的重要思想基础
目录
一、BP算法的推导
1、前向传播的计算
第一层隐藏层的计算
第二层隐藏层的计算
输出层计算
2、反向传播计算
计算偏导数
二、实际数据代入推导BP算法
1、前向传播计算
第一层隐藏层的计算
第二层隐藏层的计算
输出层计算
2、误差反向传播
输出层误差计算
第二层隐藏层误差计算
第一层隐藏层误差计算
3、更新参数
其实，大概意思就是在输入和输出之间构造神经网络（像人的大脑神经网络一样），当然这个神经网络里面会有很多的神经节点和节点之间相连的边（就想神经元由前到后相连）。然后，这个神经网络作为一个计算的网络，里面会有一些参数，要是参数选的好的话，那么这个模型就可以拿去用了，比如说，看到一张狗的照片，就知道这个是狗了。而反向传播算法就是从结果出发一步步去约束其中的参数，然后使得参数达到最优的状态。
看一看神经元，这里的：
a1、a2、a3指的是输入
w1、w2、w3指的是权重（对应输入的）
b 表示偏置（这里没有呢）
f 表示激活函数（你可以想成是平时数学课上的函数，一般都是比较简单的函数，表现出输入和输出的关系）
z 指的是输出
一、BP算法的推导 这个是一个简单的三层神经网络结构（两个隐藏层，一个输出层）
比如我们来解决一个二分类问题，给一个样本输入，通过前向运算得到输出
输出值域为（0，1），输出的结果越靠近0，就代表样本是0类的可能性越大，反之，1类的可能性越大
1、前向传播的计算 基本上都是矩阵运算
第一层隐藏层的计算 第二层隐藏层的计算 输出层计算 2、反向传播计算 假设我们使用随机梯度下降的方式来训练神经网络的参数：
损失函数（loss function）或代价函数（cost function），通常作为学习准则与优化问题相联系，即通过最小化损失函数求解和评估模
型。定义为，其中 y 定义为该样本的真实类标，而 是模型的输出。
这里有一些损失函数，我们一般用的是第二个平方损失函数：
当损失函数的值为0时，那么表示模型参数训练的炒鸡好的！因为没有损失了。
使用梯度下降法进行参数的学习，必须计算出损失函数关于神经网络中各层参数（权重w和偏置b）的偏导数。
计算偏导数 BP算法基本就是这些
二、实际数据代入推导BP算法 我们对上述的神经网络代值进行计算验证，所有的参数的初始值如下:
注意：这里面的所有的权值w和所有的偏置b的具体的值都是初始值，当然也可以换成其他数字
1、前向传播计算 第一层隐藏层的计算 第二层隐藏层的计算 输出层计算 2、误差反向传播 输出层误差计算 第二层隐藏层误差计算 第一层隐藏层误差计算 3、更新参数 我们已经计算出每一层的误差了，现在我们要利用每一层的误差和梯度来更新每一层的参数
权重w和偏置b的更新公式如下：
一般来说，权重w的更新会在前面加上一个正则化项来避免过拟合，这里为了简化运算，我们省去正则化项。
正则化：必须有一种自动的东西来告诉我们哪种程度将最适合所提供的数据，同时告诉我们需要把那些特征的影响降低至最低，以获得最好的预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff64d0366860a6cd7ae4a78cae1ff8b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3194c704704df9e0439449aa5b8b6aa0/" rel="bookmark">
			Proxmox ve（Pve） 安装windows server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装proxmox ve
点击直达 官网地址
下载下来
如果下载速度太慢 可以去安装个IDM https://www.52pojie.cn/thread-1013874-1-1.html
然后需要制作u盘启动器
下载一个 Rufus
选择proxmox ve的iso文件 点击开始
制作完成后插入到服务器上启动
启动后会进入这个界面
点击 i agree
选择硬盘，点击“Next”
设定国家、时区和键盘，Country输入China即可，点击“Next”
设置管理员root账号密码和邮箱
设定主机名，IP，网关，掩码和DNS，在安装过程中这里的IP等信息自动获取了（上述2步骤会自动检查网络，这边数据来源，固定IP可以自己设定）
安装中，等待几分钟
安装完提示重启（重启前请先移除ISO启动）
启动选项，默认5S，从硬盘启动PVE
启动完成后的控制台，会提示控制台访问URL
语言可以选择中文，对于中文支持不错
2. 通过 pve安装windows server
准备工作
1.WinServer 2012 镜像 （根据实际情况来）
2.virtual io win 驱动
将上面的镜像上传到local里面
我这里已经上传了
virtual io win 驱动下载地址：
https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/
上传后 开始创建虚拟机 点击 创建虚拟机
后面的按照你需求进行选择 ，我这里不一一截图了。
创建完虚拟机后先不要忙着开启，先到【硬件 – 添加 – CD/DVD驱动器】添加第二个CDROM，选择IDE模式，挂载镜像选择 virtual IO 驱动，如下图
然后 开启虚拟机，等一会。
就进入windwos的安装界面
然后去这里找到你对应版本的windows拿激活码
https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys
在安装中，选择自定义安装，然后在显示磁盘的界面会不显示任何磁盘，不要慌刚刚已经把驱动上传上去了！这时点击左下角的【加载驱动程序】，选择【浏览】
在路径选择窗口，选择加载了驱动的光驱，不要直接点它，展开他，选择目录【amd64 – w10】当然你可以根据你windwos版本选择其他的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3194c704704df9e0439449aa5b8b6aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65ad7bab4ac6d4ccc810b537fce68558/" rel="bookmark">
			Objective-C 基础入门（三） 读写文件与回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
四、通过 NSString 和 NSData 读写文件
1.通过 NSString 写入文件
NSError
2.通过 NSString 读取文件
3.将 NSData 对象的数据写入文件
4.从文件读取数据到 NSData 对象
五、回调
1.运行循环
2.目标 - 动作对
3.辅助对象
4.通知
5.回调与对象所有权
6.Block 对象
声明 Block 变量
编写 Block 对象
传递 Block 对象
使用 typedef 修饰 Block
外部变量
在 Block 变量中使用 self
四、通过 NSString 和 NSData 读写文件 1.通过 NSString 写入文件 在将字符串对象写入文件时，要指定字符串编码。字符串编码是描述字符和代表的数字之间的映射关系。常用的编码有 ASII编码、UTF-8 和 UTF-16。
NSMutableString *str = [NSMutableString new]; for(int i=0;i&lt;10;i++) { [str appendString:@"Aaron is cool!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65ad7bab4ac6d4ccc810b537fce68558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d0881650b2fe59d3c3f6fafae502a1/" rel="bookmark">
			ifstream 的使用方法介绍 一(转载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此文为转载 原文在https://blog.csdn.net/jllongbell/article/details/79087281 因为排版问题自己整理了一下
——————————————————————————————————————————————————————
ofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间;这里我们说的输入输出主语都是程序在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符： 1、插入器(&lt;&lt;)　向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;"Write Stdout"&lt;&lt;'/n';就表示把字符串"Write Stdout"和换行字符('/n')输出到标准输出流。2、析取器(&gt;&gt;)　从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的要用这种方式操作文件，就必须加入头文件fstream.h。一、打开文件　在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是： void open(const char* filename,int mode,int access); 参数： filename：　要打开的文件名mode：　要打开文件的方式 打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下： ios::app：以追加的方式打开文件 打开文件在文件尾进行写入，即使使用了seekp改变了写入位置，仍将在文件尾写入ios::ate：文件打开后定位到文件尾ios:app就包含有此属性 打开文件在文件尾进行写入，但seekp有效。ios::binary：　以二进制方式打开文件， 默认是ios::text，但最好指定这种读写方式，即使要读写的是文本。 因为在ios::text模式下，在写入时'/ n'字符将转换成两个字符：回车+换行（HEX: 0D 0A) 写入，读入时作逆转换，这容易引起不必要的麻烦。ios::in：文件以输入方式打开（文件数据输入到内存）ios::out：　文件以输出方式打开（内存数据输出到文件）如果文件不存在，则新建一个；存在则清空其内容。ios::nocreate： 不建立文件，所以文件不存在时打开失败ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败ios::trunc：　如果文件存在，把文件长度设为0　可以用“或”把以上属性连接起来，如ios::out|ios::binaryaccess：　打开文件的属性 打开文件的属性取值是： 0：普通文件，打开访问1：只读文件2：隐含文件4：系统文件　可以用“或”或者“+”把以上属性连接起来，如3或1|2就是以只读和隐含属性打开文件。例如： 1.以二进制输入方式打开文件c:/config.sys fstream file1;file1.open("c://config.sys",ios::binary|ios::in,0);2.如果open函数只有文件名一个参数，则是以读/写普通文件打开 file1.open("c://config.sys");&lt;=&gt;file1.open("c://config.sys",ios::in|ios::out,0);&lt;=&gt;fstream file1("c://config.sys"); 构造函数在定义的时候就能打开文件fstream有两个子类： ifstream(input file stream) ifstream默认以输入方式打开文件ifstream file2("c://pdos.def");ofstream(outpu file stream) ofstream默认以输出方式打开文件ofstream file3("c://x.123");实际应用中 如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。二、关闭文件 打开的文件使用完成后一定要关闭。fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。三、读写文件 读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式1、文本文件的读写　文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。示例如下： 假设file1是以输入方式打开，file2以输出打开。向文件写入字符串"I Love You"　file2&lt;&lt;"I Love You";//从文件输入一个整数值。 int i;file1&gt;&gt;i;这种方式还有一种简单的格式化能力 具体操作符 操纵符 功能 输入/输出dec 格式化为十进制数值数据 输入和输出endl 输出一个换行符并刷新此流 输出ends 输出一个空字符 输出hex 格式化为十六进制数值数据 输入和输出oct 格式化为八进制数值数据 输入和输出setpxecision(int p) 设置浮点数的精度位数 输出比如 要把123当作十六进制输出：file1&lt;&lt;hex&lt;&lt;123;要把3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90d0881650b2fe59d3c3f6fafae502a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f268fedf2f95c3d5aca242460a9d5b3f/" rel="bookmark">
			Flutter permission_handler仅一行代码解决授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文由动哒公众号（dongda_5g），QQ群（174353204）提供，欢迎关注获取技术支持，有任何问题群里都会回复。
最近flutter 1.17出来了，初步体验了下，感觉非常好，首先控制台一堆无用的错误输出没有了（用过1.12的小伙伴懂的）。
那最近在将项目迁移到1.17的flutter上，出现了好多的问题，比如发现permission_handler这个升级了，变化的还挺多，咱们这篇小短文来讲讲permission_handler。
先来看一个小demo：
///检查是否有权限 checkPermission() async { //检查是否已有读写内存权限 PermissionStatus status = await PermissionHandler().checkPermissionStatus(PermissionGroup.storage); //判断如果还没拥有读写权限就申请获取权限 if(status != PermissionStatus.granted){ var map = await PermissionHandler().requestPermissions([PermissionGroup.storage]); if(map[PermissionGroup.storage] != PermissionStatus.granted){ return false; } } } 上面这段代码是获取存储授权的方法，使用的是permission_handler: ^4.3.0，现在咱们看看5.0.0版本的。
// 检查是否有权限 checkPermission() async { // 检查是否已有读写内存的权限 bool status = await Permission.storage.isGranted; //判断如果还没拥有读写权限就申请获取权限 if(!status) { return await Permission.storage.request().isGranted; } } 对比下，发现咱们可以省去授权之后的结果检查，直接Permission.storage.request().isGranted的结果就是是否授权的结果。
这个还是太麻烦了，咱们再看下更简化的。
if(await Permission.storage.request().isGranted) { // 干你该干的事 } 在Permission上调用request()以请求它，如果以前已授予它，则什么也不会发生，如果没有授权，则提示用户去授权，然后返回授权之后的结果，一个语句解决，再也不用单独写个方法了。
赶紧升级到最新的版本吧，小伙伴们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5681a06f5d28d4b7a29d7e169cc821c3/" rel="bookmark">
			求解质因子（模板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【基础】质因子
时间限制: 1.000 Sec 内存限制: 16 MB
题目描述
任意输入一正整数N，求出它的所有质因子。如：10＝（2 5）；20＝（2 2 5）。
输入
输入只有一行，包括1个整数n (1&lt;n&lt;32768 )。
输出
输出若干行，按从小到大的顺序给出这个数的所有质因子，每行一个。
样例
输入
36 输出
2 2 3 3 ***题目分析：***首先要了解质因子的定义，知道求解质因子的方法，按照求解质因子的算法写成代码即可。从1到N先找出最小的质因数，如果等于本身，那么说明只有一个质因数，如果不是，那么将该质因数打印出来，并将N/该质因数作为新的N值进行运算。
质因子的定义：质因数，也叫质因子，在数论里，是指一个数的约数，并且是质数。根据算术基本定理，任何正整数皆有独一无二的质因子分解式，只有一个质因子的正整数为质数。
求解质因子算法：　1、如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。
2、如果n!=k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你n,重复执行第一步。
3、如果n不能被k整除，则用k+1作为k的值,重复执行第一步。
代码如下：
//将一个正整数分解质因数
#include&lt;stdio.h&gt; int main() { int i,n; scanf("%d",&amp;n); for(i=2;i&lt;=n;i++) { while(n!=i) //若i=n，则质因数就是n本身 { if(n%i==0) //若i是质因数，则打印出i的值，并用商给n赋新值 { printf("%d\n",i); n=n/i; } else break;//若不能被i整除，则算下一个i } } printf("%d\n",n); //这里是打印最后一个质因数，也就是等于i时的那个 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d17ef79ce8e246a496c7310dd08e706/" rel="bookmark">
			三维激光扫描仪点云数据处理与建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无意间看到的一段话，记录下来可以在写本子时借鉴一下。
点云的预处理 由于三维激光扫描仪在扫描过程中，外界环境因素对扫描目标的阻挡和遮掩，如移动的车辆、行人树木的遮挡，及实体本身的反射特性不均匀，需要对点云经行过滤，剔除点云数据内含有的不稳定点和错误点。实际操作中，需要选择合适的过滤算法来配合这一过程自动完成。
点云配准 使用控制点配准，将点云配准到控制网坐标系下;靶标缺失的点云，利用公共区域寻找同名点对其进行两两配准，当同名点对不能找到时，利用人工配准法。后两种方法均为两两配准，为了将所有点云转换到统一的控制网坐标系下与控制点配准法得到点云配在一起，两两配准时要求其中一站必须为已经配到控制网坐标系下的点云。
点云拼接 采集的数据导入至软件时会根据坐标点自动拼接，但由于人为操作和角架的误差，一些点云接合处不太理想，这时需要进行手动拼接，对一些无坐标补扫面的拼接也需手动处理。手动拼接时对点云应适当压缩，选择突出、尖角、不同平面的特征点，以降低操作误差。如采用1cm激光间隔扫描时拼接后的误差在3mm以下较为理想。
建立三维模型 当建筑物数字化为大量离散的空间点云数据后，在此基础上来构造建筑物的三维模型。
点云的漏洞修复 由于点云本身的离散性，会导致模型存在一定缺陷，需要在多边形阶段对其进行修补、调整等操作后，才能得到准确的实物数字模型。由于建筑物形状复杂多样，所以目前网格的修补难以实现全自动化。三维激光扫描仪点云数据的漏洞修复主要采用两种方法:当空洞出现在平面区域内，比如窗户或者墙面上的洞，可采用线性插值的方法填补空洞数据;当空洞出现在非平面区域，如圆柱上出现的漏洞，可采取二次曲面插值方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26baf94f69c547a5c81dcac81b88387a/" rel="bookmark">
			java实现线索化二叉树(前序线索、中序线索、后序线索)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线索化指的是：一般二叉树的叶子结点的左右子结点都指向空，但是线索化后，叶子结点的左子结点指向的是“前驱结点”，右子结点指向的是“后继结点”
三种线索化，直接上图、不多说
代码如下，后序线索遍历本人没有写出来
1.结点
class Node{ private int no; private String name; private Node left; private Node right; /** * leftType=0 表示left指向的是左子结点 =1指向的是前驱结点 * rightType=0 表示left指向的是右子结点 =1指向的是后继结点 */ private int leftType; private int rightType; public Node(int no, String name) { this.no = no; this.name = name; } /** * 前序遍历 */ public void preVisit(){ System.out.println(this); if (this.left!=null){ this.left.preVisit(); } if (this.right!=null){ this.right.preVisit(); } } /** * 中序遍历 */ public void midVisit(){ if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26baf94f69c547a5c81dcac81b88387a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d0b3c054793eddfdab0cfd95d98515/" rel="bookmark">
			点云数据处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚好最近在学习pcl点云处理，在腾讯云找到了这篇文章，对于点云处理的介绍比较详细，特转载过来备用。
原文：概述 | 点云数据处理方法都有哪些？
点云数据处理方法概述
ICP点云配准就是我们非常熟悉的点云处理算法之一。实际上点云数据在形状检测和分类、立体视觉、运动恢复结构、多视图重建中都有广泛的使用。点云的存储、压缩、渲染等问题也是研究的热点。随着点云采集设备的普及、双目立体视觉技术、VR和AR的发展，点云数据处理技术正成为最有前景的技术之一。PCL是三维点云数据处理领域必备的工具和基本技能，这篇文章也将粗略介绍。
三维点云数据处理技术 1. 点云滤波（数据预处理） 点云滤波，顾名思义，就是滤掉噪声。原始采集的点云数据往往包含大量散列点、孤立点，比如下图为滤波前后的点云效果对比。
点云滤波的主要方法有：双边滤波、高斯滤波、条件滤波、直通滤波、随机采样一致滤波、VoxelGrid滤波等，这些算法都被封装在了PCL点云库中。
2. 点云关键点 我们都知道在二维图像上，有Harris、SIFT、SURF、KAZE这样的关键点提取算法，这种特征点的思想可以推广到三维空间。从技术上来说，关键点的数量相比于原始点云或图像的数据量减小很多，与局部特征描述子结合在一起，组成关键点描述子常用来形成原始数据的表示，而且不失代表性和描述性，从而加快了后续的识别，追踪等对数据的处理了速度，故而，关键点技术成为在2D和3D 信息处理中非常关键的技术。
常见的三维点云关键点提取算法有一下几种：ISS3D、Harris3D、NARF、SIFT3D
这些算法在PCL库中都有实现，其中NARF算法是博主见过用的比较多的。
3. 特征和特征描述 如果要对一个三维点云进行描述，光有点云的位置是不够的，常常需要计算一些额外的参数，比如法线方向、曲率、文理特征等等。如同图像的特征一样，我们需要使用类似的方式来描述三维点云的特征。
常用的特征描述算法有：法线和曲率计算、特征值分析、PFH、FPFH、3D Shape Context、Spin Image等。
PFH：点特征直方图描述子，FPFH：跨苏点特征直方图描述子，FPFH是PFH的简化形式。这里不提供具体描述了，具体细节去谷歌吧。
4. 点云配准 点云配准的概念也可以类比于二维图像中的配准，只不过二维图像配准获取得到的是x，y，alpha，beta等放射变化参数，二三维点云配准可以模拟三维点云的移动和对其，也就是会获得一个旋转矩阵和一个平移向量，通常表达为一个4×3的矩阵，其中3×3是旋转矩阵，13是平移向量。严格说来是6个参数，因为旋转矩阵也可以通过罗格里德斯变换转变成13的旋转向量。
常用的点云配准算法有两种：正太分布变换和著名的ICP点云配准，此外还有许多其它算法，列举如下：
ICP：稳健ICP、point to plane ICP、point to line ICP、MBICP、GICP
NDT 3D、Multil-Layer NDT
FPCS、KFPSC、SAC-IA
Line Segment Matching、ICL
5. 点云分割与分类 点云的分割与分类也算是一个大Topic了，这里因为多了一维就和二维图像比多了许多问题，点云分割又分为区域提取、线面提取、语义分割与聚类等。同样是分割问题，点云分割涉及面太广，确实是三言两语说不清楚的。只有从字面意思去理解了，遇到具体问题再具体归类。一般说来，点云分割是目标识别的基础。
分割：区域声场、Ransac线面提取、NDT-RANSAC、K-Means、Normalize Cut、3D Hough Transform(线面提取)、连通分析
分类：基于点的分类，基于分割的分类，监督分类与非监督分类
6. SLAM图优化 SLAM又是大Topic，SLAM技术中，在图像前端主要获取点云数据，而在后端优化主要就是依靠图优化工具。而SLAM技术近年来的发展也已经改变了这种技术策略。在过去的经典策略中，为了求解LandMark和Location，将它转化为一个稀疏图的优化，常常使用g2o工具来进行图优化。下面是一些常用的工具和方法。
g2o、LUM、ELCH、Toro、SPA
SLAM方法：ICP、MBICP、IDC、likehood Field、 Cross Correlation、NDT
7. 目标识别检索 这是点云数据处理中一个偏应用层面的问题，简单说来就是Hausdorff距离常被用来进行深度图的目标识别和检索，现在很多三维人脸识别都是用这种技术来做的。
8. 变化检测 当无序点云在连续变化中，八叉树算法常常被用于检测变化，这种算法需要和关键点提取技术结合起来，八叉树算法也算是经典中的经典了。
9. 三维重建 我们获取到的点云数据都是一个个孤立的点，如何从一个个孤立的点得到整个曲面呢，这就是三维重建的topic。
在玩kinectFusion时候，如果我们不懂，会发现曲面渐渐变平缓，这就是重建算法不断迭代的效果。我们采集到的点云是充满噪声和孤立点的，三维重建算法为了重构出曲面，常常要应对这种噪声，获得看上去很舒服的曲面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58d0b3c054793eddfdab0cfd95d98515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbc9506dbe7981914d94930b4eb1a191/" rel="bookmark">
			cuda、cudnn和tensorrt的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cuda、cudnn和tensorrt的关系 CUDA是NVIDIA推出的用于自家GPU的并行计算框架，也就是说CUDA只能在NVIDIA的GPU上运行，而且只有当要解决的计算问题是可以大量并行计算的时候才能发挥CUDA的作用。CUDA的主要作用是连接GPU 和 应用程序，方便用户通过 CUDA 的 API 调度 GPU 进行计算。
cuDNN（CUDA Deep Neural Network library）：是NVIDIA打造的针对深度神经网络的加速库，是一个用于深层神经网络的GPU加速库。它能将模型训练的计算优化之后，再通过 CUDA 调用 GPU 进行运算.
当然你也可直接使用 CUDA，而不通过 cuDNN ，但运算效率会低好多。因为你的模型训练计算没有优化。
TensorRT是英伟达针对自家平台做的加速包，只负责模型的推理（inference）过程，一般不用TensorRT来训练模型的，而是用于部署时加速模型运行速度。
TensorRT主要做了这么两件事情，来提升模型的运行速度。
1、TensorRT支持INT8和FP16的计算。深度学习网络在训练时，通常使用 32 位或 16 位数据。TensorRT则在网络的推理时选用不这么高的精度，达到加速推断的目的。
2、 TensorRT对于网络结构进行了重构，把一些能够合并的运算合并在了一起，针对GPU的特性做了优化。现在大多数深度学习框架是没有针对GPU做过性能优化的，而英伟达，GPU的生产者和搬运工，自然就推出了针对自己GPU的加速工具TensorRT。一个深度学习模型，在没有优化的情况下，比如一个卷积层、一个偏置层和一个reload层，这三层是需要调用三次cuDNN对应的API，但实际上这三层的实现完全是可以合并到一起的，TensorRT会对一些可以合并网络进行合并。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ae5ceb077f30b3cbe6b543fe6a8b70/" rel="bookmark">
			浅谈Git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git 核心概念 Git 最核心的一个概念就是工作流 工作区(Workspace)是电脑中实际的目录。 暂存区(Index)类似于缓存区域，临时保存你的改动。 仓库区(Repository)，分为本地仓库和远程仓库。 初始化 $ git init# 在当前目录新建一个Git代码库 $ git clone [url]# 下载一个项目和它的整个代码历史 [Git only] 配置--- Git 用户的配置文件位于 ~/.gitconfig Git 单个仓库的配置文件位于 ~/$PROJECT_PATH/.git/config $ git config -l# 列举所有配置 $ git config --global alias.co checkout# 为命令配置别名$ git config --global alias.ci commit $ git config --global alias.st status $ git config --global alias.br branch $ git config [--global] user.name "[name]"# 设置提交代码时的用户信息$ git config [--global] user.email "[email address]" 增删文件---把文件名 file1 添加到 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5ae5ceb077f30b3cbe6b543fe6a8b70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b74ae812cbb193a8c42c1ce52f0d01/" rel="bookmark">
			浅谈JdbcDaoSupport
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义操作API public interface ICommonDao { /** * 方法描述:查询出唯一的一条数据，查询不到返回空，查询出多条抛出异常 * @param sql 执行的sql语句 * @param paramMap 参数注入的HashMap&lt;String,Object&gt;对象 * @return 查询到的结果集 * date:2017-07-31 * add by: lurufeng */ public Map&lt;String,Object&gt; queryForMap(String sql,Map&lt;String,?&gt; paramMap) throws SPTException; /** * 方法描述:查询出唯一的一条数据，并且将这条数据自动映射成指定的类型返回，查询不到返回空，查询出多条抛出异常. * @param sql 执行的sql语句 * @param paramMap 参数注入的HashMap&lt;String,Object&gt;对象 * @param clazz 需要自动映射类型的class * @return 查询到的对象 * date:2017-07-31 * add by: lurufeng */ public &lt;T&gt; T queryForObject(String sql,Map&lt;String,?&gt; paramMap,Class&lt;T&gt; clazz) throws SPTException; /** * 方法描述:不带参数查询出唯一的一条数据，并且将这条数据自动映射成指定的类型返回，查询不到返回空，查询出多条抛出异常.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b74ae812cbb193a8c42c1ce52f0d01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c318240f349a6e74737b97a70c3b40cf/" rel="bookmark">
			Windows右键新建一个cpp文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win+r，输入regedit，HKEY_CLASSES_ROOT下找到.CPP
右键—&gt;新建—&gt;项，名字叫ShellNew
然后在右边：右键—&gt;新建—&gt;字符串值，名字叫做NullFile
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87876fee088255b804c1fbf4e8135101/" rel="bookmark">
			轨迹回放与echarts图表响应变化（基于mapbox/mineMap）此方式适用于目前绝大部分地图服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：需求分析 1.场景：多数道路车辆信息都会设计到历史轨迹回放，包含当前车辆信息，道路信息，已经随之变化的响应数据变更，常采用图表形式展现
2：效果展示静态：
二 核心分析 轨迹 要素：点[经纬度]，车头的方向（保证车的反向是当前的行进方向），速度(车的行驶速度)
2.图表联动时数据的传输：当前点位与之对应的变化图表的数据应该时同步的 三 解决方案 1.了解可以实时播放的数据处理方式：
1-1:后端提供接口，按照约定的时间间隔实时获取
1-2：前端一次获取，使用定时器触发
利弊分析：后端实时获取可以省去前端数据处理的过程，但会长时间占用接口服务资源；前端一次获取请求之发起一次，初始静态数据和历史轨迹播放数据同源只需要一个接口；
2.解决echarts实时更新变化的方式：dispatchAction 这是核心
具体做法：为了和小车播放同步必须保证暂定，播放，重新播放时所在的位置，速度保持一致：
/** * 获取当前单车底部图表实例，播放动画 * @speed 速度 * @index 当前播放所在的位置下标 */ startChart(speed,index){ let _this=this; let chart=this.$refs.detailData.trendLine; //当前使用图表的实例 let currentIndex =index; //播放所在下标 _this.mTime = setInterval(function() { chart.dispatchAction({ type: 'showTip', seriesIndex: 0, name: '车速', dataIndex: currentIndex }); currentIndex++; _this.setIndex = currentIndex; //存贮当前移动到的位置 if(index &gt; _this.chartDataX.length) { //当播放到最后一位时表示已经结束 清除任务 currentIndex = 0; _this.setIndex= 0; clearInterval(_this.mTime); _this.mTime=null; } }, speed); } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87876fee088255b804c1fbf4e8135101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99536016ade72d4383100aa65db91f02/" rel="bookmark">
			mysql学习进一步学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 事务：
个人理解事务是数据库逻辑集合操作的最小单元，也就是说在做数据库的一系列操作要么全部执行，要不全部不执行。
事务的四大特性：
原子性：
不可分割的操作单元，一个事务中的所有操作要么全部成功，要么全部callback到执行前的状态。举例：a和b两人转账操作，a账户余额500，b账户余额500，a向b转账100成功，b接收a100失败，那个转账操作全部callback回之前状态。
一致性：
一个事务在对数据库操作前后，数据库的状态一致。举例：a和b两人转账操作，a账户余额500，b账户余额500，a向b转账100，a的余额变为400，b的余额变为600，a和b两人在做转账之前余额总和为1000，转账之后余额综合认为1000，那么他就符合事物的一致性。否则不满足事物的一致性。
隔离性：
在并发访问数据的时候，一个正在执行的事物在执行完毕之前，对其他的会话是不可见的，多个并发事物之间的数据是独立的。
持久性：
一个事务一旦被提交，它对数据库中的数据影响是永久性的。
事务的隔离级别：
读未提交（read uncommitted）：
读到没有被提交的数据，所有这个隔离机制无法解决脏读，不可重复读，幻读中的任何一种，实际应用中也很少用到。
读已提交（read commited）：
一个事务要等待另一个事务提交之后才能读取数据
可重复读（repeatable read）：
在开始读取数据库时不允许修改数据。
序列化（serializble）:
序列化的隔离级别最高，能避免脏读，重复度，幻读等问题，但是效率低下，比较消耗数据库性能，一般也不推荐使用。
脏读：一般体现在查询过程
幻读： 一般体现在插入和删除过程
存储过程示例：
定义存储过程：
示例表结构：
DELIMITER $ CREATE PROCEDURE insertTest() BEGIN INSERT INTO admin (`username`,`password`) VALUE ("A","root"),("B","root"),("C","root"),("D","root"),("E","root"); END $ 调用：
CALL interTest() $ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/243/">«</a>
	<span class="pagination__item pagination__item--current">244/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/245/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>