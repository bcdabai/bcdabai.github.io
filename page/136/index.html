<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9444e1f8c165b64862206a7d9850e83/" rel="bookmark">
			Spring核心——SPEL Bean定义中的表达式、实例应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bean 定义中的表达式 我们可以使用带有基于 XML 或基于注释的配置元数据的 SpEL 表达式来定义 BeanDefinition 实例。 在这两种情况下，定义表达式的语法都采用 #{ &lt;表达式字符串&gt; } 的形式。
这里我们只研究注解形式
注解形式配置 要指定默认值，您可以将 @Value 注释放在字段、方法以及方法或构造函数参数上。
以下示例设置字段的默认值：
@Component public class BeanAnnoTest { @Value("#{systemProperties['user.name']}") private String name; public void setName(String name) { this.name = name; } public String getName() { return this.name; } } @RestController public class TestController { @Autowired private BeanAnnoTest bean; @GetMapping("/test") public String test(){ System.out.println(bean.getName()); return bean.getName(); } } 当然也可以
@Value("#{systemProperties['user.name']}") public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9444e1f8c165b64862206a7d9850e83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd9a9260211e0ea5274f5972c60f7722/" rel="bookmark">
			vue3的axios使用,vue3的axios封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue项目中使用axios获取网页数据问题 现在我们通过webpack+vue-cli搭建起了一个vue项目的框架，如果我们需要在vue组件中使用axios向后台获取数据应该怎么办呢？
通常情况下，我们搭建好的项目目录应该是这样子的首先需要安装axios，这个会npm的都知道下一步，在中引入axiosimportaxiosfrom"axios";与很多第三方模块不同的是，axios不能使用use方法，转而应该进行如下操作Vue.prototype.$axios=axios;接着，我们就可以在中使用axios了created:function(){this.$("/seller",{"id":123}).then(res=&gt;{();});}。
谷歌人工智能写作项目：小发猫
vue axios渲染 typescript教程视频，typescript高级教程。
我这是直接用response来获取的返回数据类型，如果你要获取js的这个表里数据可以用['prodSpecs']就可以得到这个数组，下面是我的使用：this.axios({/*headers:{'Authorization':'bearer'+this.$store.state.users.currentUser.UserToken},*/method:'post',url:'/test',data:{"test":"123456"}}).then(function(response){/*(response);*/this.value=;}.bind(this)).catch(function(error){(error);});。
vue.js 怎么引入axios 首先在中引入axios?1importaxiosfrom'axios'这时候如果在其它的组件中，是无法使用axios命令的。
但如果将axios改写为Vue的原型属性，就能解决这个问题Vue.prototype.$ajax=axios在中添加了这两行代码之后，就能直接在组件的methods中使用$ajax命令methods:{submitForm(){this.$ajax({method:'post',url:'/user',data:{name:'wise',info:'wrong'}})}。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487f057795044aa4ec661a7945cc324c/" rel="bookmark">
			typescript入门与实践,typescript深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在vue组件里面使用typescript 使用构造modal组件的方法是使用v-model指令：v-model指令在表单控件元素上创建双向数据绑定。根据控件类型它自动选取正确的方法更新元素。
比如，多个勾选框，绑定到同一个数组：JackJohnMikeCheckednames:{{checkedNames|json}}newVue({el:'...',data:{checkedNames:[]}})。
谷歌人工智能写作项目：小发猫
前端常用的框架有哪些？ 前端三大框架，是Angular、React、Vue，这三个框架现在是最为流行也是最多人用的框架typescript深度解析，深入浅出typescript。React：1.声明式设计：React采用声明范式，可以轻松描述应用。
2.高效：React通过对DOM的模拟，最大限度地减少与DOM的交互。3.灵活：React可以与已知的库或框架很好地配合。
优点：1.速度快：在UI渲染过程中，React通过在虚拟DOM中的微操作来实现对实际DOM的局部更新。
2.跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。
3.模块化：为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。
4.单向数据流：Flux是一个用于在JavaScript应用中创建单向数据层的架构5.同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。
6.兼容性好：比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。
缺点：React本身只是一个V而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux才能写大型应用。
Vue：Vue是尤雨溪编写的一个构建数据驱动的Web界面的库，准确来说不是一个框架，它聚焦在V（view）视图层。
它有以下的特性：1.轻量级的框架2.双向数据绑定3.指令4.插件化优点：1.简单：官方文档很清晰，比Angular简单易学。2.快速：异步批处理方式更新DOM。
3.组合：用解耦的、可复用的组件组合你的应用程序。4.紧凑：~18kbmin+gzip，且无依赖。5.强大：表达式无需声明依赖的可推导属性(computedproperties)。
6.对模块友好：可以通过NPM、Bower或Duo安装，不强迫你所有的代码都遵循Angular的各种规定，使用场景更加灵活。缺点：1.新生儿：是一个新的项目，没有angular那么成熟。
2.影响度不是很大：google了一下，有关于多样性或者说丰富性少于其他一些有名的库。3.不支持IE8。Angular：Angular是一款优秀的前端JS框架，已经被用于Google的多款产品当中。
它有以下的特性：1.良好的应用程序结构2.双向数据绑定3.指令4.HTML模板5.可嵌入、注入和测试优点：1.模板功能强大丰富，自带了极其丰富的angular指令。
2.是一个比较完善的前端框架，包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能；3.自定义指令，自定义指令后可以在项目中多次使用。
4.ng模块化比较大胆的引入了Java的一些东西（依赖注入），能够很容易的写出可复用的代码，对于敏捷开发的团队来说非常有帮助。
5.angularjs是互联网巨人谷歌开发，这也意味着他有一个坚实的基础和社区支持。缺点：1.angular入门很容易但深入后概念很多,学习中较难理解。
2.文档例子非常少,官方的文档基本只写了api,一个例子都没有,很多时候具体怎么用都是google来的,或直接问misko,angular的作者。
3.对IE6/7兼容不算特别好,就是可以用jQuery自己手写代码解决一些。
4.指令的应用的最佳实践教程少,angular其实很灵活,如果不看一些作者的使用原则,很容易写出四不像的代码,例如js中还是像jQuery的思想有很多dom操作。
5.DI依赖注入如果代码压缩需要显示声明。
2020年前端最火的技术是什么？ 我认为的2020年前端开发者最应该掌握的一些比较火爆的技术与知识点。
1，前端框架和语言层面9月份Vue3.0发布，声称对TypeScript有着更好的开发体验，通过从不同框架级别TS支持上，我们可以看出社区的整个风向从2019年的大家都去学习应用TS，变成了大家如何把TS用的更好这个方向上来了。
所以我认为今年TypeScript的火热程度还是应该排名很靠前的，我今年也使用TypeScript重构了Daruk的服务框架推出了2.0版本，让TS开发者拥有更好的TS开发体验。
接下来就是两大重磅框架的更新历程对比，Vue3前面说了一句。而React也在十月也发布了React17的release版本。这两大主流框架的频繁更新，也说明了社区和作者都在一同演化。
在Vue3中除了更好的支持TS外，还更新了CompositionAPI。
而React17主要是集中精力在升级体验上，虽然没有新的Feature但是提升了和解决了很多之前版本潜在的问题。
要说哪个最火还是要看个人实际的使用场景和喜好，但是2020年来看还没有别的框架可以与之一战。
2，大前端相关技术栈今年基于Chromium的微软edge浏览器也已经推出。google在web端的发展产生了对开发者深刻的影响。
Chrome80+也已经发布多个版本，提供了一系列的新特性，比如CoreWebVitals标准，DesktopPWA等都值得我们去关注。
我们说完了浏览器相关的那点技术之后，再聊聊大前端相关的一些技术实践，比如Flutter。
很多前端在今年已经从web开发转型为Flutter开发，学习和使用Dart技术来构建UI，这是很多大厂的前端工程师正在经历的事情（包括我的部门也在尝试这个事情），这个趋势应该在未来几年还会持续。
客户端electron在今年也有着长足的进展，一年内多次更新版本一路到了10.1.5。随着疫情影响，国内在线教育的又一波兴起。
很多桌面软件，网课软件都在采用这个技术来进行开发，市场上的岗位也开始变多，electron技术可以说在今年也有火的趋势。
然后我们再看看BFF层，nestjs依然坚挺，越来越多的人开始跳过学习express和koa开始学习更丰富的web框架了，比如egg或者我的daruk，开发者已经在慢慢形成共识，在webframework的路上开始越走越远，裸写nodejsweb服务的时代已经开始慢慢褪去。
不得不提的还有serverless在前端的普及，在2020年到达了一个新的高潮。
阿里云，腾讯云，头条云等等国内的互联网厂商也都开始大玩serverless概念。从对内服务开始转向对外服务，普及的势头很猛，也有落地的趋势和场景。
今年的D2同样也有serverless的专场，可见受重视程度非比寻常。
3，工程化提效和个人素质提升再离我们近一些的推动生产力的技术，比如据我所知在用CI/CD和pipeline管理上线流程的公司越来越多，这种去年还可以出去吹一吹的东西，今年也逐步变成了业界标配基础能力，如果不会的同学可要抓紧学习了。
2019年前大家都疯狂吐槽面试刷medium题目没用，而2020年后大家开始默认面试某些公司都至少要刷到medium程度的题目。
这对很多前端来说是一个心智和素质的提升与转变，大家在接触新技术的同时，也慢慢发现，前端整个职业环境的变化，越来越多的公司对人的整体综合素质要求变高了。
web前端主要包含了哪些技术？ Web前端是为了协调前端设计与后端开发之间工作的岗位，是最接近产品和设计的工程师，起到衔接产品和技术的作用，前端为用户可以看到的部分负责，所以也是最接近用户的工程师。
Web前端开发基础技能：HTML、CSS、JavaScript前端的开发中，在页面的布局时，HTML将元素进行定义，CSS对展示的元素进行定位，再通过JavaScript实现相应的效果和交互。
虽然表面看起来很简单，但这里面需要掌握的东西绝对不会少。在进行开发前，需要对这些概念弄清楚、弄明白，这样在开发的过程中才会得心应手。
Web前端开发必知标准：http标准、W3C标准、ECMAScript标准浏览器要从服务端获取网页，网页也可能将信息再提交给服务器，这其中都有http的连接。
W3C标准不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构(Structure)、表现(Presentation)和行为(Behavior)。
JS是在ES的基础上，为Web浏览器做了一部分封装(增加了DOM操作、BOM操作等)。
Web前端开发加薪技能：jQuery、Ajax、ReactjQuery一定是大部分Web前端开发者不可或缺的工具，对jQuery的学习不能停留在只使用它的API和插件上，还要会自己去写jQuery插件、会读jQuery源码、了解jQuery的设计思路。
Ajax是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换，Ajax可以在无需重新加载整个网页的情况下，更新部分网页的技术。
React主要用于构建UI，你可以在React里传递多种类型的参数，如声明代码，帮助你渲染出UI、也可以是静态的HTMLDOM元素、也可以传递动态变量、甚至是可交互的应用组件。
除了要掌握技术层面的知识，Web前端工程师还要掌握理论层面的知识，包括代码的可维护性、组件的易用性、分层语义模板和浏览器分级支持等等。
现在前端开发主要学习哪些框架？ 学习Web框架可以加快Web开发速度，节约时间。就目前来说，Web前端要学什么框架呢？分享目前比较流行且常用的Web前端框架有Angular、React、Bootstrap和Vue。
1、AngularAngular框架包含的东西比较完善，包含模板、数据双向绑定、路由、模块化、服务、过滤器、依赖注入等所有功能。
对于刚开始学习使用框架的小伙伴们，可以推荐这个框架。使用TypeScript能够提高代码可维护性，有利于后期重构。。
2、React这个框架本身比较容易理解，他的结构很清晰，就是由十几个API组成，然后异步渲染，我们只需要处理好接口和维护就好了，但是很多人反映上手还是有一定的的难度的。
React是单向数据流，代码写起来会较双向数据流的多一些，但是同样的排查问题时思路清晰很多。3、VueVue是行内的大趋势，还可以用来开发小程序。同时他也是双向数据流。
有些人认为Vue是Angular和React的结合，既有Angular的模板语法也有React的组件化体系。
4、BootstrapBoostrap绝对是目前使用广泛的一款框架。它是一套优美，直观并且给力的Web设计工具包，可以用来开发跨浏览器兼容并且美观大气的页面。
它提供了很多流行的样式简洁的UI组件，栅格系统以及一些常用的JavaScript插件。以上就是Web前端要学的几款框架，希望对大家有帮助。
typescript，vue项目里的依赖指向js文件，没有指向ts文件，为什么？ 用vue监听单行文本框是最最最容易的事。只需用到v-model就能监听。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/487f057795044aa4ec661a7945cc324c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c17f7e3ee1e40bf64edf18ce764b60/" rel="bookmark">
			（一）数据结构绪论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏：数据结构与算法分析
下一篇：（二）算法分析
文章目录 什么是数据结构(Data Structures)一、数据结构的基本概念和数据1. 数据(data)2. 数据相关的基本概念2.1 数据元素(data element)2.2 数据项(data item)2.3 数据对象(data object)2.4 数据结构(data structure) 二、数据的逻辑机构和物理结构1. 逻辑结构1.1 集合1.2 线性结构1.3 树形结构1.4 图状结构 2. 存储结构2.1 顺序存储 和非顺序存储2.1.1 虚拟地址与物理地址2.1.1 不同编程语言中顺序存储的含义 2.2 四种存储结构2.2.1 顺序存储结构2.2.2 链式存储结构2.2.3 索引存储结构2.2.4 散列存储结构 什么是数据结构(Data Structures) 随着计算机运行速度的不断提高和存储容量的持续增长，计算机的功能日益强大，从而处理数据和解决问题的规模和复杂程度与日俱增。这不仅带来了需要认真研究的新课题，而且突出了原有数据结构和算法效率低下的缺点。为了解决这方面的问题，发展出了 “数据结构” 这一门学科。
数据结构 这一门学科主要研究计算机组织和存储大量数据的方式。同时，数据结构 也是指相互之间存在一种或多种特定关系的数据元素的集合。
一、数据结构的基本概念和数据 数据结构主要研究的是计算机组织和存储大量数据的方式，那数据是什么呢？
1. 数据(data) 数据 是指所有能输入到计算机中并被计算机程序处理的信息的总称。一切能被编码的信息都可以称之为数据，如声音、图像等可以以某种方式编码成二进制数值后输入到计算机中进行处理。
2. 数据相关的基本概念 2.1 数据元素(data element) 数据元素 是组成数据的，有一定意义的基本单位。数据元素在计算机程序中通常作为一个整体进行考虑和处理。
2.2 数据项(data item) 一个数据元素可由多个数据项组成。例如一本书的书目信息为一个数据元素，书目信息中的每一项（如书名、作者名、出版社等）为一个数据项。数据项是数据的不可分割的最小单位。
2.3 数据对象(data object) 数据对象 是性质相同的数据元素的集合，数据的子集。
性质相同是指数据元素具有相同数量和类型的数据项。
2.4 数据结构(data structure) 数据结构 相互之间存在一种或多种特定关系的数据元素的集合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c17f7e3ee1e40bf64edf18ce764b60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539f986206113df8a08a2219aa30da72/" rel="bookmark">
			Aop的失效场景和原理，以及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 失效场景
首先我们只要知道什么样的方法不能被子类重写，也就知道了aop失效的一部分情况 比如 final 修饰的、static 修饰的 、private 修饰的和构造方法
调用与被调用的方法在同一个类中，显而易见，如果当前在一个类中有两个方法A、B，其中B被aop加强了，然后A调用B，因为是在类内部调用的，此时A调用的是当前类中的方法，而不是其子类加强后的方法，所以会失效引用公共模块时，如果包路径不相同则会失效。因为spring boot中会默认扫面包路径下的类来加入到ioc的容器中，如果公共类的中的包路径和引用模块的路径不相同，导致公共模块下的对象不能被ioc管理，导致aop失效（下附解决方法） 解决方法：
首先第一种和第三种没什么好说的，主要是第二种的解决方法：
可以在代理的接口实现类上加一个注解：
1.@EnableAspectJAutoProxy(exposeProxy = true) 2.调用被加强的方法时，强制获取代理对象，通过代理对象去调用
if (null != AopContext.currentProxy()) { list = ((动态代理实现类)AopContext.currentProxy()).加强方法(); }else{ //这里表示获取到代理对象，则直接调用代理方法即可 加强方法() } 两种代理方法的区别：
jdk动态代理：有接口的地方，会去创建接口实现类的代理对象(目前使用都是jdk，效率低于cglib，如果要使用cglib，需要进行特殊配置)
cglib动态代理：只有类的地方，会去创建子类的代理对象 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41a9b051c407494ff4ad71e1e1f7c07/" rel="bookmark">
			UE4、UE5通过FPaths获取各目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的几个目录：
FPaths::ProjectDir(); 工程根目录。
FPaths::GameSourceDir(); 工程的Source目录
FPaths::ProjectContentDir(); 工程的Content目录
通过直接查看FPaths的脚本源码：
// Copyright Epic Games, Inc. All Rights Reserved. #pragma once #include "CoreTypes.h" #include "Containers/UnrealString.h" #include "HAL/CriticalSection.h" namespace UE::Core::Private { const TCHAR* GetBindingType(const TCHAR* Ptr); const FString&amp; GetBindingType(const FString&amp; Str); // This is used to force the arguments of FString::Combine to implicitly convert (if necessary) // to FString when calling CombineImpl(), allowing them to remain as temporaries on the stack // so that they stay allocated during the combining process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e41a9b051c407494ff4ad71e1e1f7c07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebca93d726fbffd09f6a9e6c1b9f983a/" rel="bookmark">
			android 串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常的开发过程中，我们多少会在一些开发板子上进行app开发，其中就会涉及到一些串口数据的处理，今天就记录一下，用到的串口连接和数据接收和发送
1、首先去现在下载用到的串口开发的android-serialport-api库，我这边用到的和在github上下载的可能有点出入，但是经开发过程中测试是好的
其中在SerialPort.java中需要注意的有
(1) Runtime.getRuntime().exec("/system/bin/su"); 这里面的/system/bin/su路径可能每个系统版本不一样，我开发中的路径就是/system/xbin/su
（2）确认波特率
（3）确认端口
以上两点若没有确认好的话，都会造成串口连接失败；
2、连接串口
public void initSerialPort() { try { SerialPort serial = new SerialPort(new File(""/dev/ttymxc1""), 115200, 8, 0, 1, 0); if(serial != null) { mOutputStream = serial.getOutputStream(); mInputStream = serial.getInputStream(); HandlerThread handlerThread = new HandlerThread("SerialThread"); handlerThread.start(); mHandler = new Handler(handlerThread.getLooper()); mHandler.post(threadRunnable); } } catch (Exception e) { e.printStackTrace(); } } 接收串口数据
Runnable threadRunnable = new Runnable() { @Override public void run() { try { while (true) { try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebca93d726fbffd09f6a9e6c1b9f983a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f43ad65fedccadf581411aca06da0db5/" rel="bookmark">
			MySQL数据库之多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、表的关联关系二、多表查询案例2.1 案例演示2.2 错误分析2.3 笛卡尔积 三、多表查询分类3.1 等值连接 vs 非等值连接3.2 自连接 vs 非自连接3.3 内连接 vs 外连接3.4 UNION的使用 四、左外连接和右外连接的区别4.1 数据集合不同4.2 运算方式不同4.3 语法不同(outer可省略) 五、SQL99 实现7中join操作5.1 7种SQL JOINS的实现5.2 NATURAL JOIN连接5.3 USING连接5.4 多表查询练习题 前言 记录B站尚硅谷康师傅MySQL数据库教学视频的多表查询部分学习笔记。
一、表的关联关系 1.1 表与表之间的数据记录有关系，现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。
1.2 四种关联关系：一对一关联、一对多关联、多对多关联、自我引用。
1.2.1 一对一关联
在实际的开发中应用不多，因为一对一可以创建成一张表。
举例：设计学生表 ：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、… 可以将学生表拆分为两个表，两个表的记录是一一对应关系，如下图所示。
基础信息表(常用信息)：学号、姓名、手机号码、班级、系别。
档案信息表(不常用信息)：学号、身份证号码、家庭住址、籍贯、紧急联系人、…
两种建表原则：
(1)外键唯一：主表的主键和从表的外键(唯一)，形成主外键关系，外键唯一。
(2)外键是主键：主表的主键和从表的主键，形成主外键关系。
1.2.2 一对多关系
常见实例场景： 客户表和订单表， 分类表和商品表， 部门表和员工表。
举例：
员工表：编号、姓名、…、所属部门
部门表：编号、名称、简介
一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键。如下图：一方(部门表主表)的部门 id 为 x1 对应多方(员工表从表) id 为 y1 与 y2 的员工，而两表之间通过从表oid相关联。
1.2.3 多对多关联
要表示多对多关系必须创建第三个表该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。如下图：左表与中间表形成一对多的关系，右表与中间表也形成一对多的关系，整体形成多对多的关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f43ad65fedccadf581411aca06da0db5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f509d36e6b8a13dbea87979e2a90fe9/" rel="bookmark">
			rangenet_lib &amp;&amp; tensorRT8.** &amp;&amp; ubuntu20.04 &amp;&amp; suma&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在复现suma++时，由于是ubuntu20.04 ，所以安装tensorRT8.2.* .导致了编译不通过rangenet_lib网络库。
因为tensorRT版本更新了，现在修改了代码，可以编译通过，正常运行。
github地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0248bb1a5efec20ed8e0e544bd102b17/" rel="bookmark">
			运用C在Linux系统中写贪吃蛇小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习Linux操作系统的运用。通过写下贪吃蛇这个小游戏，加深对c语言的理解以及Linux操作系统的运用。在文章中逐步解析贪吃蛇的整个构建逻辑。并将它记录下来。
1.运用ncurses库编写贪吃蛇小游戏
在开始编译贪吃蛇小游戏时就发现一个难题，运用#include &lt;stdio.h&gt;的头文件实现贪吃蛇小游戏并不现实，在该头文件中每次的输出都要按一次回车键。也就是说，每按一个方向键就需要按下一次回车键程序才能输出。这样写下的的贪吃蛇小游戏无疑是愚蠢的。所以，这里要用到ncurses库。
Ncurses：Ncurses是一套编程库，它提供了一系列的函数以便使用者调用它们去生成基于文本的用户界面。其中的函数“getch()”就不需要按下回车键进行输出。在后续编写中一些函数也适用于贪吃蛇游戏的编写。
#include &lt;curses.h&gt; //ncurses上下左右键的获取 void initcurses() { initscr();//初始化 keypad(stdscr,1);//在std中接受键盘的功能键 noecho(); //控制键盘输入进来的字符 } 2.贪吃蛇地图程序编写
我们编写一个20×20的小地图：
结果如图所示这是一个20×20的小地图在第0行和第20行中我们用“--”作为边界，在第0列和第20列中我们用“|”作为边界。用函数封装游戏地图，然后对每一行要实现的结果进行编写。头和尾我们需要打印“--”封住，中间的空间用“|”封住，中间的区域打印空格。
void gameworld() { int hang; int lie; move(0,0);//改变光标位置 for(hang=0;hang&lt;=20;hang++) { if(hang==0) { for(lie=0;lie&lt;20;lie++) { printw("--"); } printw("\n"); } if(hang&gt;=0&amp;&amp;hang&lt;=20) { for(lie=0;lie&lt;=20;lie++) { if(lie==0||lie==20) { printw("|"); } else if(hasSnakenode(hang,lie))//蛇身子模块在地图显现 { printw("[]"); } else if(hasFoodnode(hang,lie))//食物模块在地图显现 { printw("##"); } else { printw(" "); } } printw("\n"); } if(hang==20) { for(lie=0;lie&lt;20;lie++) { printw("--"); } } } printw("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0248bb1a5efec20ed8e0e544bd102b17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86eb2558cc47268d6c5d355fbbf4c7a/" rel="bookmark">
			【TCP通讯、socket套接字、TCP并发编程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、预备知识 1.什么是ip、port(端口）
2.如何查看本机ip
ifconfig
3.如何查看tcp 端口号是否被使用和查看缓冲区数据量
netstat -ntlp
二、socket套接字 1.概念
概念一：API是什么？
大多数操作系统使用系统调用的机制在应用程序和操作系统之间传递控制权。
系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口。由于应用程序在使用系统调用之前要编写一些程序，特別是需要 设置系统调用中的许多参数，因此这种系统调用接口又称为应用编程接口API。
概念二：套接字作为应用进程和运输层协议之间的接口。
（1）socket 地址API
socket还有一个概念就是（指端口号拼接到IP地址），我们在这里称为socket地址。
我们都知道,TCP把连接作为最基本的抽象，TCP 的许多特性都与TCP是面向连接的这个基本特性有关。
每一条TCP连接有两个端点。那么，TCP连接的端点是什么呢?不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议端口。TCP连接的端点叫做套接字(socket)或插口。根据RFC 793的定义:端口号拼接到(contatenated with)IP地址即构成了套接字。因此套接字的表示方法是在点分十进制的IP地址后面写上端口号，中间用冒号或逗号隔开。例如，若IP地址是192.3.4.5而端口号是80，那么得到的套接字就是(192.3.4.5:80)。总之，我们有
套接字socket =(IP地址:端口号)
每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。即:
TCP连接::= { socket,， socket2} = {(IP1:port), (IP2: portz)}
这里IP,和IP2分别是两个端点主机的IP地址，而 port和 portz分别是两个端点主机中的端口号。TCP连接的两个套接字就是socket,和 sockety。
总之，TCP连接就是由协议软件所提供的一种抽象。虽然有时为了方便，我们也可以说，在-一个应用进程和另一个应用进程之间建立了一条TCP连接，**但一定要记住:TCP连接的端点是套接字，即(IP地址:端口号)。**也还应记住:同-个IP地址可以有多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中。
（2）socket 基础API（创建、命名。监听、接受连接、发起连接socket）
1.主机字节序和网络字节序
现代CPU的累加器一次都能装载（至少）4字节，（这里考虑32位机，下同），即一个整数。那么这4字节在内存中排列的顺序将影响他被累加器装载成整数的值。这就是字节序问题。
现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序。
大端字节序也称为网络字节序，他给所有接受数据的主机提供了一个正确解释收到的格式化数据的保证。
2.socket地址
2.1通用socket地址
2.2专用socket地址
通用结构体显然不好用，比如设置与获取ip地址个端口号就需要执行繁琐的位操作，所以提供专门的SOCKET地址结构体。
所有专用socket地址（以及socketaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr(强制转换即可），因为所有socket编程使用的地址参数的类型都是sockaddr 。
saddr.sin_family = AF_INET;//地址族 saddr.sin_port = htons(6000);//端口号：需要网络字节序表示。 1024 知名端口 ，4096 保留的端口 , 大于4096 临时端口 saddr.sin_addr.s_addr = inet_addr("127.0.0.1"); 3.Ip地址转换函数
4.创建socket
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a86eb2558cc47268d6c5d355fbbf4c7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ca6abc37514fa10ab6277dfcdec368/" rel="bookmark">
			【idea插件jrebel 运行报错 】JRebel-JVMTI [FATAL] Couldn‘t write to C:\Users\ 报错 已解决 亲测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 事件起因idea插件jrebel xrebel运行debug报错错误信息： 环境：安装明确问题：解决办法：1、修改VM options位置：2、修改jrebel插件的位置： 参考资料：结束语 不想听我在这儿逼逼叨叨的，请直接通过目录跳转 环境、安装和解决办法 事件起因 因为前不久重装了电脑系统，然后重新安装完系统后我修改了用户的名字（修改为了中文）
c盘的用户路径名也为中文：
从而导致了在安装完idea的jrebel后执行它的debug时就报了错
idea插件jrebel xrebel运行debug报错 错误信息： JRebel-JVMTI [FATAL] Couldn't write to C:\Users\ 之前找到网上什么去配置vm options等设置 但配置了之后又出现了新的问题
配置了vmoptions中的路劲后（直接运行jrebel）仍然报错，但是提示的错误信息不一样了：
环境： idea的版本：2021.1.1
jrebel版本：2022.2.0 （其他版本是一样的效果，不影响）
安装 在idea的 File&gt;setting里的plugins里搜索jrebel 并下载好
明确问题： 安装好后直接运行会报这个错误：
错误原因就是系统的用户名设置为了中文所导致的，之前找了不少的其他文章看，没找到合适的解决办法，摸索出来后特地来记录一下这个错误原因
解决办法： 需要配置两个东西：
1、修改VM options位置： 找到 help &gt; edit Custom VM options
增加一个-Duser.home= 自己定义一个不含中文的路径
注：记住修改这个文件后 需要重启idea后才能发挥作用，也可在下面的配置完成后 再重启idea 2、修改jrebel插件的位置： 找到 File&gt;settings 里安装好的jrebel 选中JRebel Advanced 修改插件的默认位置（因为默认位置是在自己c盘用户名下的，又因为自己的用户名为中文导致启动解析路径出错） （下图是我已经修改完成后的样子了）
从默认路径下复制一份插件到自己的不含中文路径下（下图为笔者自己的默认路径）：
我复制过来的路径：
将复制出来的插件jar包路径：
回到设置页面将配置的路径给重新指定一下
这个配置不需要重启idea，apply之后就可直接使用了 上面第一步那个配置记得需要重启才能发挥作用 然后你就可以去重启你的项目了
最后成功使用jrebel启动：
参考资料： 下面写到的参考资料及评价 并没有诋毁作者的意思，软件更新迭代本来就快，教程随着时间的流逝也确实会失效，所以才会不断的有人来更新不同版本的相应的教程，说不定未来就会有新的作者来说我这篇文章 无效 就是垃圾，呵呵
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31ca6abc37514fa10ab6277dfcdec368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ecddb337481fb22f3eb69f4fa7377b/" rel="bookmark">
			给浏览器开挂，超好用的全平台快捷指令工具推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给大家推荐个超好用的快捷指令工具——「万能命令」。
可以实现和油猴脚本类似的功能，更加简单直接。
最重要的是没有平台限制，手机电脑都可以使用，堪称“万能工具箱”！
万能命令
万能命令 - 快捷寻找和直达你想要的各类工具
万能命令是一个在线工具快捷跳转平台，聚合了很多好用的高质量在线工具。
可以帮我们一键直达各种工具，快速完成各种操作。
介绍 wn万能命令是一个在线工具快捷跳转平台，将各种高质量的在线工具按应用站点聚合起来，让你以方便快捷好记的方式寻找和使用网页型在线平台。比如下载视频、网页翻译、商品历史价格查询、文档下载、网页截屏等……全都不在话下 特色功能：
方便快捷，一键调用；
各种工具类型全面，资源丰富；
无需下载安装、登录注册，即用即走；
只在点击时生效，节省资源；
无平台限制，支持电脑、安卓、iOS 等……
# 使用方法 # &gt; 方法一： 在任意网址前面加上 wn.run/，回车，即可展示能用于该网页的全部工具。
有工具类型和功能描述，一键点击使用。
&gt; 方法二： 拖动官网的书签按钮到书签栏，添加「万能命令书签」。
想用时点击下这个书签即可，更加方便快捷。
不方便拖动操作的话，也可以手动添加网页书签，名称输入“万能命令”，网址输入下面代码：
javascript:(function(){window.open("https://wannengrun.com/f/#"+document.location.href)})() 两种方法都可用于电脑和手机端，推荐使用添加书签的方法，使用时点一下就行，更加方便。
万能命令由于不像油猴脚本那样需要扩展支持，只要添加个书签或者输入网址即可使用。
不管电脑手机，只要是浏览器就支持，兼容性更强，相当于给所有浏览器都开了个挂，强烈推荐给大家！
喜欢本文的话，记得点赞支持我 ！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/827e239b25b6fb80a0f99deb98f55f24/" rel="bookmark">
			Cesium与IndexDB结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IndexDB与Cesium的深度融合。 第一次加载，将影像和3dtiles数据均缓存起来，第二次加载直接取缓存数据，不发起请求，实现秒加载。
//1、启用影像缓存 var viewer = new Cesium.Viewer("cesiumContainer", { imageryProvider: new Cesium.ArcGisMapServerImageryProvider({ useDBCache:true, url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer', }), }); //2、启用3dtiles缓存 var tileset = new Cesium.Cesium3DTileset({ useDBCache:true, url:"/3dtiles/jzw-shanghai/tileset.json", }); Cesium与IndexDB结合
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6ff7042351a9cfb4dd4376cfef3b637/" rel="bookmark">
			Sentinel集成Nacos对流控与降级规则的持久化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		往期回顾 Nacos的安装与配置
Spring Cloud集成Nacos作为注册中心
LoadBalacer集成Nacos实现负载均衡
常见的负载均衡策略分析
Spring Cloud集成Dubbo实现RPC调用
SpringCloud集成Nacos作为配置中心
Nacos整合OpenFegin实现RPC调用
Nacos整合Gateway入门实例
Spring Cloud Gateway的过滤器配置
Nacos整合Gateway实现动态路由
Sentinel的安装与配置 @SentinelResource详解
Sentinel的流控与熔断降级规则详解 在上一篇我们介绍了流控和降级熔断这几个概念，并对Sentinel的流控与降级的规则进行了进一步的阐述。但是我们之前在控制台配置的规则，控制台是默认通过API推送至客户端并直接更新到内存中。一旦我们重启应用，这些规则便会消失，所以，接下来就让我们一起来看看如何将这些规则持久化吧。
规则的管理及推送 一般来说，规则的推送有下面三种模式：
推送模式说明优点缺点原始模式API 将规则推送至客户端并直接更新到内存中，扩展写数据源简单，无任何依赖不保证一致性；规则保存在内存中，重启即消失。严重不建议用于生产环境Pull 模式扩展写数据源， 客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 RDBMS、文件 等简单，无任何依赖；规则持久化不保证一致性；实时性不保证，拉取过于频繁也可能会有性能问题。Push 模式扩展读数据源，规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用 Nacos、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证。生产环境下一般采用 push 模式的数据源。规则持久化；一致性；快速引入第三方依赖 前面两种模式不是我们的重点，这里不再做赘述，感兴趣的同学可以自行查阅官网
Push模式 生产环境下一般更常用的是 push 模式的数据源。对于 push 模式的数据源,如远程配置中心（ZooKeeper, Nacos, Apollo等等），推送的操作不应由 Sentinel 客户端进行，而应该经控制台统一进行管理，直接进行推送，数据源仅负责获取配置中心推送的配置并更新到本地。因此推送规则正确做法应该是 配置中心控制台/Sentinel 控制台 → 配置中心 → Sentinel 数据源 → Sentinel，而不是经 Sentinel 数据源推送至配置中心。这样的流程就非常清晰了：
Sentinel对Nacos做了适配，这让我们很容易集成Nacos作为数据源进行配置，接下来我们就以Nacos为例来演示一下如何对Sentinel的规则进行持久化
快速开始 引入Nacos作为数据源还需要引入以下依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;version&gt;1.8.3&lt;/version&gt; &lt;/dependency&gt; 然后在配置文件中配置数据源： spring: application: name: user-service cloud: sentinel: transport: #配置 Sentinel dashboard 地址 dashboard: 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6ff7042351a9cfb4dd4376cfef3b637/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccab9ebd99c78469121e6526362ea031/" rel="bookmark">
			linux安装 python3-pip没有安装候选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 环境：linux ubuntu 22.04版本 LTS windows： 使用vmware 执行以下命令报错 apt-get install python3-pip 解决方案 1、添加语义库： sudo add-apt-repository universe 2、更新apt sudo apt update 3、安装 sudo apt install python3-pip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d0a6909e3aa6fc437f4f4fd20c618c/" rel="bookmark">
			PR（Pull Request）简单介绍以及git的相关使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用git往gitee上提交PR，发现对于git的使用以及提交PR的一些相关术语不大熟悉，通过网上查阅资料加上自己的实际动手操作在此进行整理本次学习收获。在此感谢提供解答的各位老师。
一、PR简介 PR（Pull Request）：简单的说就是人A觉得另一个人B的仓库写的代码有问题或者可以修改提高啥的，但A不能直接去直接修改仓库的的源码（万一A写错了，源码没有备份不久完犊子了），所以A先复制一份（fork操作）B仓库中的源码，之后clone下来在A的本地修改，修改完后commit提交Pull Request给B（Pull Request上要写明修改了啥啥啥的，让B明白A要干啥）。B看到A提供的PR后发现A是对的便采纳了A的代码（merge）。
我觉得这里的Pull是一个计算机使用术语和Push相对应，和其本身的汉语意思拉一样，把我修改的东西接受进去的请求。
Branch： 在提交PR过程中有一个叫Branch（分支）的东西，这东西就和树枝一样，树枝主干为master（原始分支），分支名称可以自定义，A可以创建一个分支用来进行Pull Request，A的相关操作都在新建的分支上进行，Pull Request时请求将分支合并到master上。
我觉得Branch的目的是为了因为可能不止A一个人要进行Pull Request操作，可能还有C、D啥啥啥的，在不同的分支上进行操作有助于减少冲突，同时便于溯源。
二、git简介和使用 1.git简介
Git為分散式版本控制系統，是為了更好管理Linux內核而開發的。
Git可以把檔案的狀態作為更新歷史記錄保存起來。因此可以把編輯過的檔案復原到以前的狀態，也可以顯示編輯過內容的差異。
而且，當有人想將編輯過的舊檔案上傳到伺服器、覆蓋其他人的最新檔案時，系統會發出警告，因此可以避免在無意中覆蓋他人的編輯內容。
2.git的使用
这里只介绍部分使用。
安装
关于Git的安装请参考： Git 安装配置，或者其它博客。
配置
在本地寻找想要修改代码的文件，鼠标右击有一个Git Bash Here（Git GUI Here为互动界面），点击进去。
输入
git config --global user.name "zrf编程小白" git config --global user.email niubi@qq.com 注 这里的user.name和user.email自定义，如果提交PR需要签署CLA的邮箱，user.email 需要填写签署CLA的邮箱。
使用（Windows版）
找到B的代码仓库，点击fork，复制一份下来。下面拿Gitee界面举例子。
点击完fork后我们便可以得到以下界面（没有可以去自己的代码仓库找）
之后复制界面网址，在本地寻找想要修改代码的文件，鼠标右击有一个Git Bash Here（Git GUI Here为互动界面），点击进去。
输入代码
cd user/git_clone # 如果文件位置不对，可以用cd命令进入想要存放的文件夹 git clone http:www.niubi.com # clone后添加网址 现在我们在文件所在位置便可以看到下载好的代码。如果需要更改则直接在本地下载好的代码上进行更改即可。
修改好后输入以下代码
git add . git commit -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1d0a6909e3aa6fc437f4f4fd20c618c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/556acaae47759c37c39461edab37cdde/" rel="bookmark">
			C#学习记录——Visual Studio为项目添加DLL文件引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例说明 DLL文件引用就是在当前项目中引用别的DLL文件，可以是用C#编写的类库，也可以是别的语言编写的类库，这样主要是为了提高程序的开发效率，将DLL文件中的一些已有功能直接进行使用，而不用再去编写实现相同功能的代码。本实例在创建完的项目中添加PCHMI.dll引用，添加完PCHMI.dll引用之后的效果如图1所示。
设计过程 （1）打开Visual Studio 2019开发环境，新建一个Windows窗体应用程序，命名为AddDLL。
（2）首先将PCHMI.dll放在…\bin\Debug\下；
（3）在“解决方案资源管理器”中选中项目单击右键，选择“添加”——&gt;“引用”命令，或者在菜单栏中选择“项目”/“添加引用”命令。
（4）弹出如下”引用管理器窗口。““添加引用”对话框。
（5）点击”“浏览”/“浏览”，选中“PCHMI.dll”，点击“添加”按钮。完成DLL文件的添加。
（6）添加完的效果如图
秘笈心法 心法领悟：DLL文件的使用。
DLL文件是一种最常用的第3方组件表示形式，在C#中引用Dll文件后，可以直接使用其中编写好的方法来实现相应的功能，从而提高程序的开发效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4c960f3dfb06db7588dd2cfcb8f611/" rel="bookmark">
			Greenplum广播与重分布原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Greenplum 的执行计划和 PostgreSQL 基本一致，但是在表关联的时候还是会有区别，因为 greenplum 中数据不同于 pg，greenplum 是将数据分布在多个节点上。所以当两表关联时关联列又不是表的分布键时就会出现表的广播和重分布。本文将详细介绍广播和重分布的区别及场景。
在此之前，我们需要先了解下在 greenplum 中表之间分布式关联有哪些类型？
表的分布式关联主要分为两大类：
1、单库关联，即表的关联键和分布键一致，所以只需要在单个库中得到结果后再关联即可，因此也不会涉及到广播和重分布；
2、跨库关联，即表的关联键和分布键不一致，因此数据需要重新分布来达到单库关联的效果，这也是本文主要讲解的地方。
对于跨库关联又分为两种情况：
2.1、一张表的关联键是分布列，另一张表不是；
2.2、两张表的关联键均不是分布列。
详细情况如下图所示 (a、b 两表中 c1 列是分布列)：
下面结合实例来讲解广播和重分布的原理及场景。
构建环境：
postgres=# CREATE table a(c1 int,c2 int)distributed by(c1); CREATE TABLE postgres=# CREATE table b(c1 int,c2 int)distributed by(c1); CREATE TABLE 现在主要来看看跨库关联的两种情况：
— 情况一：a.c1=b.c2
即 a 表关联键是分布列，b 表不是。这种情况可以通过两种方法来实现表的关联：
1、重分布：将 b 表按照 c2 字段将数据重新分布到每个节点上，然后再和 a 表关联。这种情况下重分布的数据量就是 b 表的数据量 N；
2、广播：将 a 表上的数据进行广播，即每个节点都放一份全量数据，然后再和 b 表关联。这种情况下数据量大小就是 a 表数据量 M * 节点数 L。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d4c960f3dfb06db7588dd2cfcb8f611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e9e083bc9de29a2b17bdcf28589dd91/" rel="bookmark">
			Cesium材质节点编辑器V0.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cesium材质节点编辑器V0.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb664dbac19dcf373c2512406ffefa7/" rel="bookmark">
			Spring Bean的lookup-mehtod和replace-method原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Bean的lookup-mehtod和replace-method原理解析 解析阶段 1、在解析xml文件的时候，会把配置了lookup-method、replace-method的属性的值放入到GenericBeanDefinition的overrides中。如下代码：
BeanDefinitionParserDelegate#parseLookupOverrideSubElements方法：
/** * Parse lookup-override sub-elements of the given bean element. */ public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) { NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) { Element ele = (Element) node; String methodName = ele.getAttribute(NAME_ATTRIBUTE); String beanRef = ele.getAttribute(BEAN_ELEMENT); LookupOverride override = new LookupOverride(methodName, beanRef); override.setSource(extractSource(ele)); overrides.addOverride(override); } } } BeanDefinitionParserDelegate#parseReplacedMethodSubElements方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fb664dbac19dcf373c2512406ffefa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c64c1ec5de8249d44b7203b3f8f55ef6/" rel="bookmark">
			UNNC 2022秋季学期课表导入日历指南 - v1.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读须知 使用ics文件作为新日历导入outlook时，可以更方便地管理（修改、删除等）日历账户中的日程，并且可以通过连接账户实现多端日历同步
如果你的设备使用的是iOS12-iOS15系统日历或其他日历，想要通过链接直接订阅，并且不对日程标题做任何修改，请查看UNNC Smart Scheduling首页的使用指南
如果你使用的是上述系统或应用，但想更改日程标题，请查看此教程
如果你使用的是其他设备日历，需要ics日历文件导入的，如Windows系统日历或其他移动设备的系统日历，请查看此教程
步骤一 登陆 UNNC Smart Scheduling，点击左侧的My Timetable，再点击右上角下载图标。
DOWNLOAD弹框
步骤二 根据需求，可重新生成个人偏好的提醒时间，重新生成时会有弹框提示新链接会覆盖老链接。
复制灰框内webcal://之后的URL到新窗口，会跳转到如下页面
日历内容页面
步骤三 点击浏览器右上角的三个点 -&gt; 更多工具 -&gt; 保存页面为 -&gt; 选择保存路径 -&gt; 保存类型选择All files，命名成XXX.ics -&gt; 保存
保存页
课程代码替换为课程名称（可选） 有同学指出添加的日程只显示课程代码，点进日程详情后才能看到课程名称。
这种情况可以通过替换ics文件中的课程代码为课程名称，来实现日程正常显示课程名称。
注意：如果你已经通过旧版本的教程步骤添加过日程，再进行此步骤前可以先删除之前添加过的日历
在ics文件保存目录下，右键ics文件 -&gt; 打开方式选择记事本 -&gt; Ctrl+H打开替换功能，在查找内容中输入课程代码，替换内容中输入课程名称，点击全部替换即可。
重复上述替换步骤直至秋季学期选课的课程代码都被改成课程名称，选N门课就替换N个课程代码。
关于课程代码和对应的课程名称查询，可在NottinghamHub的Modules (Courses)中找到，复制课程代码后查找时请注意ics文件中的课程代码格式里没有“-”，请记得删除。
替换完成后，进行步骤四或步骤五
记事本打开ics文件后的替换页面
通过Windows系统日历打开修改后的ics文件
通过手机系统日历添加修改后的ics文件
步骤四 在保存目录找到ics文件，打开后会自动跳转到系统日历页面，点击添加到日历就可以在系统日历里看到课表了。使用outlook打开时，最好选择“作为新日历打开”，这样导入为一个单独的日历账户方便后续的日程管理和iOS端的同步。
ics文件打开后的添加页面
点击Windows右下角时间出现的系统日历
步骤五（可选） - 移动设备 把ics文件传到手机/平板后（以微信文件传输助手为例），用其他应用打开，选择相应的系统日历 -&gt; 仅一次 -&gt; 添加日程，之后就可以在手机/平板的日历里看到课表了。
在微信中打开ics文件显示的窗口
手机日历中的课表显示效果
iOS日历与outlook同步 将日历导入到outlook后，在outlook的日历页面把导入的日历从“其他日历”拖到“我的日历”，这个操作的目的是让课表日历同步到邮箱账号
然后在iOS设备中打开设置 -&gt; 邮件 -&gt; 账户 -&gt; 添加账户 -&gt; 选择Microsoft Exchange，并登陆学校邮箱 -&gt; 返回账户页面 -&gt; 点击刚才添加的Exchange账户，确保日历同步开关已经打开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c64c1ec5de8249d44b7203b3f8f55ef6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4e6d02f400c289a036880a3a859072d/" rel="bookmark">
			Spring Boot &#43; Redis 实现分布式限流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常见限流算法 1、固定窗口限流算法 首先维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数。
当次数少于限流阀值，就允许访问，并且计数器+1当次数大于限流阀值，就拒绝访问。当前的时间窗口过去之后，计数器清零。 2、滑动窗口限流算法 滑动窗口也是维护单位时间内的请求次数，其与固定窗口限流算法的区别是，滑动窗口的粒度更细，将一个大的时间窗口划分为若干个小的时间窗口，分别记录每个小周期内接口的访问次数，通过滑动时间删除小的时间窗口，以此来解决固定窗口临界值的问题
3、漏桶限流算法 原理很简单，可以认为就是注水漏水的过程。往漏桶中以任意速率流入水，以固定的速率流出水。当水超过桶的容量时，会被溢出，也就是被丢弃。因为桶容量是不变的，保证了整体的速率。
4、令牌桶算法 令牌桶算法每隔一段时间就将一定量的令牌放入桶中，获取到令牌的请求直接访问后段的服务，没有获取到令牌的请求会被拒绝。同时令牌桶有一定的容量，当桶中的令牌数达到最大值后，不再放入令牌。
二、常见分布式限流实现方案 限流又分为单机限流和分布式限流，常见的分布式限流方案如下
● 可以基于redis，做分布式限流
● 可以基于nginx做分布式限流
● 可以使用阿里开源的 sentinel 中间件
三、设计思路 1、希望单个接口限流的数量可以实时控制，引入Nacos用于配置接口限流数
2、根据自身项目需求，使用用户id与接口名作为key，使redisTemplate.opsForValue().increment方法作为vaule，从而实现次数的递增，然后设置缓存过期时间来实现固定时间窗口
3、希望对业务没有耦合，使用拦截器拦截固定请求，限流算法实现写在拦截器中
固定窗口限流算法实现：
在Redis中根据该用户id和接口名创建一个键，并设置这个键的过期时间，当用户请求到来的时候，先去redis中根据用户ip获取这个用户当前分钟请求了多少次，如果获取不到，则说明这个用户当前分钟第一次访问，就创建这个健，并+1，如果获取到了就判断当前有没有超过我们限制的次数，如果到了我们限制的次数则禁止访问。
四、代码实现 1、添加自定义拦截器 @Configuration public class WebMvcConfig extends WebMvcConfigurerAdapter { @Autowired private LimitInterceptor limitInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // addPathPatterns 用于添加拦截规则，/**表示拦截所有请求 // excludePathPatterns 用户排除拦截 registry.addInterceptor(limitInterceptor).addPathPatterns("/**"); } @Bean public LimitInterceptor initLimitInterceptorBean() { return new LimitInterceptor(); } } 2、实现自定义拦截器 @Slf4j public class LimitInterceptor implements HandlerInterceptor { @Autowired(required = false) private LimitService limitService; @Autowired private ApplicationContext applicationContext; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (limitService == null) { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4e6d02f400c289a036880a3a859072d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c109a0dbf7180d33cf46ce8a9c6ffb8a/" rel="bookmark">
			关于使用selenium&#43;python简单获取前程无忧数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.设置好编辑环境 使用selenium时配置好浏览器插件确保在同一目录下并且与浏览器是同一版本，以谷歌为例子，下载好对应浏览器的版本。其次使用pycharm进行代码编辑。
安装驱动(windows系统)
写得挺详细就不写了。
二.上实例 1.对网站第一页进行观察 我爬取数据使用的地址
你会发现所有第一页的数据在同一class：j_joblist中，然后继续观察
你会再次发现网页数据都在同一标签中，那么获取数据就相当容易了，也不用去抓包等等。
2.然后对第二页及n页进行观察 会发现
每一页只有一个的div数字不一样，使用遍历，想要多少页就获取多少页
2.进行代码编写 def parse_data(): divs=driver.find_elements_by_xpath('.//div[@class="j_joblist"]/div') for div in divs: for i in range(1,51): title = div.find_element_by_xpath('/html/body/div[2]/div[3]/div/div[2]/div[4]/div[1]/div['+str(i)+']/a/p[1]/span[1]').text # 标题` price = div.find_element_by_xpath('/html/body/div[2]/div[3]/div/div[2]/div[4]/div[1]/div['+str(i)+']/a/p[2]/span[1]').text # 价格 business = div.find_element_by_xpath('/html/body/div[2]/div[3]/div/div[2]/div[4]/div[1]/div['+str(i)+']/div[2]/a').text # 店名 location = div.find_element_by_xpath('/html/body/div[2]/div[3]/div/div[2]/div[4]/div[1]/div['+str(i)+']/a/p[2]/span[2]').text # 地名 detail_url=div.find_element_by_xpath('/html/body/div[2]/div[3]/div/div[2]/div[4]/div[1]/div['+str(i)+']/div[2]/a').get_attribute('href')#网址 print(title,price,business,location,detail_url) dit = { '标题': title, '价格':price, '店名': business, '地名': location, '网址': detail_url, } csv_writer.writerow(dit) print(title,price,business,location,detail_url) 执行就可以获取到固定的数据
当然前面的导入包等等没去载图出来，还要模拟人工操作浏览器滑动，不然容易报错
for x in range(1, 30, 4): # 1 3 5 7 9 在你不断的下拉过程中, 页面高度也会变的 time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c109a0dbf7180d33cf46ce8a9c6ffb8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f588b57421030cbbd7582717e651713a/" rel="bookmark">
			tf.Variable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 tf.Variable - 云+社区 - 腾讯云
目录
__init__
__abs__
__add__
__getitem__
__gt__
__invert__
__iter__
__le__
__lt__
__matmul__
__mod__
__mul__
__ne__
__neg__
__or__
__pow__
__radd__
__rand__
__rdiv__
__rfloordiv__
__rmatmul__
__rmod__
__rmul__
__ror__
__rpow__
__rsub__
__rtruediv__
__rxor__
assign
assign_add
assign_sub
batch_scatter_update
count_up_to
eval
experimental_ref
from_proto
gather_nd
get_shape
initialized_value
load
read_value
scatter_add
scatter_div
scatter_max
scatter_min
scatter_mul
scatter_nd_add
scatter_nd_sub
scatter_nd_update
scatter_sub
scatter_update
set_shape
sparse_read
to_proto
value
变量跨run()调用在图中维护状态。通过构造类变量的实例，可以向图中添加一个变量。Variable()构造函数需要变量的初值，它可以是任何类型和形状的张量。初值定义变量的类型和形状。构造完成后，变量的类型和形状是固定的。可以使用指定方法之一更改值。如果稍后要更改变量的形状，必须使用带有validate_shape=False的赋值Op。与任何张量一样，使用Variable()创建的变量可以用作图中其他Ops的输入。此外，张量类的所有重载运算符都被传递到变量上，因此您也可以通过对变量进行算术将节点添加到图中。
import tensorflow as tf # Create a variable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f588b57421030cbbd7582717e651713a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632139fbe0db1ab8748527efc25e7ed7/" rel="bookmark">
			Linux基本操作命令、Vim编辑器、Jenkins、Maven
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux基本命令 &amp; Vim基本操作：clickJenkins click 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50bc64c359cdc6a98e49b4f0a88e405f/" rel="bookmark">
			自动化JS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369d8c06f098cd743fdbe5007801b3ec/" rel="bookmark">
			jmeter获取时间，beanshell断言和脚本，浏览器时间转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a589a7d3b9df9fb3653ec30c440dd0/" rel="bookmark">
			socket编程之connect()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5 connect() connect（） 系统调用将文件描述符 sockfd 引用的套接字连接到 addr 指定的地址。
2.1 包含头文件 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; 2.2 函数主体 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 参数解释：
int sockfd ​ socket()函数返回的未被使用的文件描述符
const struct sockaddr *addr ​ 该地址为所要连接的socket的地址，connect（） 系统调用将文件描述符 sockfd 引用的套接字连接到 addr 指定的地址。
​ 如果套接字 sockfd 的类型为 SOCK_DGRAM，则 addr 是默认情况下数据报发送到的地址，也是接收数据报的唯一地址。如果套接字的类型为 SOCK_STREAM 或 SOCK_SEQPACKET，则此调用将尝试与绑定到 addr 指定的地址的套接字建立连接。通常，基于连接的协议套接字可能只成功连接（）一次;无连接协议（例如UDP数据报）套接字可以多次使用 connect（） 来更改其关联。
socklen_t addrlen ​ addrlen 参数指定 addr 的大小。
2.3 返回值 如果连接成功，则返回0；出错时，返回-1，错误类型如下：
错误类型解释EACCES, EPERM用户尝试连接到广播地址，但未启用套接字广播标志，或者由于本地防火墙规则，连接请求失败。EACCES（本地套接字）对套接字文件的写入权限被拒绝，或者对路径前缀中的某个目录的搜索权限被拒绝。EADDRINUSE本地地址已在使用中。EAFNOSUPPORT传递的地址其sa_family字段中不正确。EAGAIN路由缓存中的条目不足。EALREADY套接字为非阻塞套接字，且上一次尝试连接还未完成。EBADFsockfd不是有效的文件描述符。ECONNREFUSED流套接字上的 connect（） 发现没有在监听的远程地址。EFAULT套接字结构地址位于用户的地址空间之外。EINTR本次系统调用被捕获的信号中断。EISCONN套接字已连接。ENETUNREACH网络无法访问。EPROTOTYPE套接字类型不支持请求的通信协议。例如，尝试将 UNIX 域数据报套接字连接到流套接字时，可能会发生此错误。ETIMEDOUT尝试连接时超时。 服务器可能太忙，无法接受新连接。 对于 IP 套接字，在服务器上启用 syncookie 时，超时可能很长。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a589a7d3b9df9fb3653ec30c440dd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6f5a828f2a690a72c37d98b382a4da/" rel="bookmark">
			【算法】模拟退火
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.模拟退火介绍1.1模拟退火的可行性1.2退火模型 2.详解退火2.1退火过程2.2各变量说明2.2.1关于接收概率 3.退火模拟求根号n的值4.洛谷POJ-2420 1.模拟退火介绍 ​ 模拟退火是模拟物理上退火方法，通过N次迭代（退火），逼近函数的上的一个最值（最大或者最小值）。比如在下面函数去逼近最大值C点
1.1模拟退火的可行性 ​ 模拟退火算法得益于材料统计力学的研究成果。
​ 鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。
​ 如果用粒子的能量定义材料的状态，退火算法用一个简单的数学模型描述了退火的过程。假设材料在状态i下的能量为E(i),那么材料在温度T时从状态i进入状态j就应该遵从以下规律：
（1）如果E(j)&lt;=E(i)，那么级接收该状态。
（2）如果E(j)&gt;E(i),那么就以一定的概率进入该状态：exp{(E(i)-E(j))/KT}
K为物理学中的玻尔兹曼常数，T为材料的温度
1.2退火模型 退火算法是一种循环算法需要先设定一个初始的问题T【需要一个高温，模拟粒子从高温向低温退火】每次循环进行一次退火然后降低的温度，我们通过让和一个“降温系数”（一个接近1的小数，比如0.999)相乘，达到慢慢降低温度的效果，直到接近于0（我们用来代表一个接近0的数(比如0.00001)。 代码架构
double T=2000;	//表示初始的温度为0.99 double dt=0.999;	//表示降温系数 double eps=1e-14;	//相对于1的负14次方，就是最后退出循环的温度 while(T&lt;eps) { //------------------ //进行一次退火操作 //------------------ T*=dt;	//降低温度 } 2.详解退火 ​ 我们要求的目标无法是两个：自变量x和对应的目标函数最值f(x)
2.1退火过程 先随机找一点x0,这也是初始粒子。【注意要随机】 找到对应的目标函数值 进行退火操作 ​ 刚才我们说了x0相当于是一个粒子，所以我们会进行一个无序运动，也就是向左或者向右随机移动：移动的幅度和当前的温度T有关。
​ 温度T越大，移动的幅度越大。温度T越小，移动的幅度就越小。这是在模拟粒子无序运动的状态。
接收更好的状态 ​ 假设我们移动到了x1处，那么这个点对应的f(x1)很明显答案是优于（大于）当前的f(x0)。
因此我们将答案进行更新。也就是将初始值进行替换：x0=x1,f(x0)=f(x1)。这是一种贪心的思想。
以一定概率接受(Accept)更差的状态
为什么需要按照一定的概率接受更差的状态。因为可能在一个较差的状态旁边会出现一个更加高的山峰
如果我们鼠目寸光，只盯着右半区，很容易随着温度的下降、左右跳转幅度的减小而迷失自己，最后困死在小山丘中。
而我们如果找到了左边山峰的低点，以一定的概率接受了它（概率大小和温度以及当前的值的关键程度有关），会在跳转幅度减少之前，尽可能找到最优点。
那么我们以多少的概率去接受它呢？我们用一个公式表示：exp{ Δf / KT }
注意
- 如果随机后的函数值如果结果更好，我们一定选择它(即x0=x1,f(x0)=f(x1)); - 随机后的函数值如果结果更差，我们以exp{ Δf / KT }的概率接受它 - e是自然对数，约等于2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e6f5a828f2a690a72c37d98b382a4da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25557e4f13389bd519729bdef32d088e/" rel="bookmark">
			Failed to read the ‘handle‘ property from ‘MediaSource‘: MediaSourceHandle creation is currently sup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Failed to read the ‘handle’ property from ‘MediaSource’: MediaSourceHandle creation is currently supported only in a dedicated worker. 原因 Chrome更新到105后出现这个报错，是由于105做了这个改动相关链接1，相关链接2
解决 1，降级chrome或者使用其他浏览器
2，更换播放器，或者可能你使用的播放器直接或间接的使用了videojs，把videojs更新至最新版本即可相关链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c457732a9f874acda1632ff140e3d017/" rel="bookmark">
			selenium 下载webdriver浏览器驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动化测试要自动调用浏览器时需要用到selenium模块
官网上的定义为：
Selenium 通过使用 WebDriver 支持市场上所有主流浏览器的自动化。 Webdriver 是一个 API
和协议，它定义了一个语言中立的接口，用于控制 web 浏览器的行为。 每个浏览器都有一个特定的 WebDriver 实现，称为驱动程序。
驱动程序是负责委派给浏览器的组件，并处理与 Selenium 和浏览器之间的通信。
1.安装Selenium类库
pip install selenium
2.配置浏览器驱动 用以驱动你的浏览器
不同浏览器有不同的内核，此时需要不同的webdriver驱动。
webdriver
下载地址可见：
https://www.selenium.dev/zh-cn/documentation/webdriver/getting_started/install_drivers/
以我的电脑为例
我的Edge浏览器版本为 105.0.1343.27 (正式版本) (64 位)
在官网找到自己对应版本的资源包，点击下载：
下载完成后，解压保存在已知的路径中以供调用：
from selenium import webdriver driver = webdriver.Edge() # Edge浏览器 # driver = webdriver.Edge("驱动路径") driver = webdriver.Chrome() # Chrome浏览器 driver = webdriver.Ie() # Internet Explorer浏览器 driver = webdriver.Firefox() # Firefox浏览器 driver = webdriver.Opera() # Opera浏览器 driver = webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c457732a9f874acda1632ff140e3d017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca53efc902fb55271ee3498cf1ef237/" rel="bookmark">
			AOP是什么？如何使用AOP？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AOP****基本概念是什么？
什么是AOP？
AOP****就是面向切面编程，或者叫面向方面编程，或者开玩笑的说叫面向方便面编程
在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
用我的话讲，比如一个方法，他只能计算加法，而不能计算乘法，但是又不想改源码！这时候可以在外面创建一个类，在这个类中通过AOP的技术给这个方法进行添加功能的操作，这就是AOP。
AOP****的作用（特点）是什么？ AOP****代表的是一个横向的关 系，将“对象”比作一个空心的圆柱体，其中封装的是对象的属性和行为；则面向方面编程的方法，就是将这个圆柱体以切面形式剖开，选择性的提供业务逻辑。而 剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹，但完成了效果。
实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。
AOP****的底层原理是什么？ AOP****底层使用了动态代理
有两种情况
（1、）有接口的情况：
使用了JDK的动态代理
这里有个错误啊，代理类不用继承接口，不用不用继承，懒得改了，写几个字把。
（2、）没有接口的情况：
使用了CGLTB动态代理
AOP****动态代理的实现！
为什么要用动态代理？
在不改变原来的代码上进行 修改代码，有点层次感
如何使用动态代理？ （这里是有接口的情况下）
使用JDK的动态代理，使用Proxy类里面的方法创建代理对象
每个方法方法参数的作用？ 调用newProxyInstance(1:ClassLoder,2:类&lt;？&gt;[] interfances,3:InvocationHand)
**1:**类的加载器
2**：增强方法所在类，，这个类实现的接口，支持多个接口，所以已数组的形式展出**
3**：实现这个接口InvocationHand，创建代理的对象，写增强的方法。**
每个方法的作用？ Proxy.newProxyInstance：将方法调用到处理程序，具有指定的代理类，调用处理程序的代理实例，该代理类，由指定的类加载器定义
并实现指定的接口
method.invoke：调用method类代表的方法，其中obj是对象名，args是传入method方法的参数
步骤 这里已继承接口的栗子举例
这里先创建一个接口
然后创建一个类继承这个接口
接下来所有的话都在这张图中：
结果就是：
以上就是AOP的基础操作。
AOP****的基础操作术语有哪些？
连接点：
连接点是在应用执行过程中能够插入切面（Aspect）的一个点。这些点可以是调用方法时、甚至修改一个字段时**。**
就是可以被增强的方法，就称为连接点
切入点： 实际被增强的方法，就是切入点，比如说有俩方法，一个方法被增强了一个没被增强，则被增强的方法叫做切入点，没被增强的方法就不能叫做切入点
切入点表达式:
execution (public * com.ljb.service.impl…*.*(…))
execution**（权限修饰符，返回值类型，类全路径，方法名称，参数列表）**
1.execution**：指示符，execution是最常用的指示符，用于匹配方法执行的连接点。**
2.public**：访问修饰符，该参数可选。**
**3.**第一个*号：返回值类型，*号表示所有的类型，即通配符。
**4.**包名：需要拦截的包名，后面的两个点表示当前包和当前包的所有子包，即例子中的com. ljb.service.impl包和该包的子孙包下所有类。
**5.**第二个*号：类名，*号表示所有的类。
***(…)😗*方法名，*号表示所有方法，括号里面表示方法的参数，两个点表示任何参数，可有可无。
通知（增强） 真正被增强的逻辑部分称为通知（增强）
通知有五种类型：
1**、前通知：方法执行之前，method：增强执行的方法**
2**、后通知：方法执行之后，又称最终通知，无论如何都执行**
3**、返回后通知：成功返回后，有异常时不执行**
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ca53efc902fb55271ee3498cf1ef237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fdc19e5128376780b11376e3d009942/" rel="bookmark">
			深度学习目标检测——AP以及MAP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AP计算概述 知道了AP 的定义，下一步就是理解AP计算的实现，理论上可以通过积分来计算AP，公式如下：
A P = ∫ 0 1 P ( r ) d r AP=\int_0^1 P(r) dr AP=∫01​P(r)dr
但通常情况下都是使用近似或者插值的方法来计算 AP。
近似计算AP A P = ∑ k = 1 N P ( k ) Δ r ( k ) AP = \sum_{k=1}^{N}P(k)\Delta r(k) AP=k=1∑N​P(k)Δr(k)
近似计算 AP(approximated average precision)，这种计算方式是 approximated 形式的；很显然位于一条竖直线上的点对计算AP没有贡献；这里 N 为数据总量，k 为每个样本点的索引， Δ r ( k ) = r ( k ) − r ( k − 1 ) Δr(k)=r(k)−r(k−1) Δr(k)=r(k)−r(k−1)。 近似计算AP和绘制PR曲线代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fdc19e5128376780b11376e3d009942/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e15b680feffab594ea544afd44376e/" rel="bookmark">
			socket编程之accept()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4 accept() 用于接收监听套接字中保存的套接字连接。它提取监听套接字 sockfd 的挂起连接队列上的第一个连接请求，创建一个新的已连接套接字，并返回引用该套接字的新文件描述符。accept()执行的系统调用并不会对原始的监听套接字产生任何其他影响。
4.1 包含头文件 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; 4.2 函数主体 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags); 参数解释：
int sockfd ​ 参数sockfd必须是指向执行listen()调用以后的监听套接字
struct sockaddr *addr ​ 参数 addr 是指向 sockaddr 结构的指针。 此结构用已知的对等套接字的地址填充。返回地址 addr 的确切格式由套接字的地址系列决定（在socket()函数中指定的）。需要注意的是，该地址返回的是客户端的外网IP，而客户端使用的IP一般均为内网IP，所以我们根据这个地址返回的IP是访问不到客户端主机的。如果addr设置为NULL时，表示不关心客户端的地址，addrlen也应该设置为NULL。
socklen_t *addrlen ​ addrlen类一个特殊的参数，传入参数为调用者提供的缓存区，而传出参数为客户端地址结构体的实际长度，因此，每次调用accept()之前都应该为该参数赋初值。如果提供的缓冲区太小，则返回的地址将被截断;在这种情况下，addrlen 将返回一个大于提供给调用的值。
int flags ​ 这个参数时accept4()所特有的，当flags = 0时，accept()和accept4()是完全相同的。但该参数还可以传递以下两个参数，以实现对socket()的进一步控制：SOCK_NONBLOCK、SOCK_CLOEXECS，这两个参数的含义在第1小节socket()中已经说明，此处不再赘述。
对accept()作进一步补充：
accept()为阻塞型函数，如果队列上不存在挂起的连接，并且套接字未标记为非阻塞，则 accept（） 将阻塞调用进程，直到存在连接为止。 如果套接字标记为非阻塞，并且队列上不存在挂起的连接，则 accept（） 将失败，并显示错误 EAGAIN 或 EWOULDBLOCK。如果不想设置套接字为非阻塞但又需要在调用accept()时避免对进程造成阻塞，则可以选择使用 select()、poll() 或 epoll()，这些函数会有新连接传入是通知调用者有可读事件，然后就可以调用accept()函数了。对于select()、poll() 或 epoll()函数会在IO复用专栏进行说明。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65e15b680feffab594ea544afd44376e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/747490b9bb586d091bfb9eee19b37236/" rel="bookmark">
			JavaScript 中常用事件有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们首先来了解下在JavaScript中什么是事件？ JavaScript 使我们有能力创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发JavaScript函数的事件。比方说，我们可以在用户点击某按钮时产生一个 onClick 事件来触发某个函数。事件在 HTML 页面中定义。
基本原理 当我们在某个元素上添加一个事件时，根据事件执行的前后可以把它当成一个事件流，例如在DOM事件中规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，然后是实际的目标接收到事件，最后是冒泡阶段，可以在这个阶段对事件做出响应。 首先我们来了解下
1.窗口事件 当鼠标打开页面后，再点击其他文件窗口是就会触发焦点事件
onblur :失去焦点 onfocus:获得焦点 /* 当窗口失去焦点时 */ window.onblur = function () { console.log('窗口失去了焦点！'); } /* 当窗口获得焦点时 */ window.onfocus = function () { console.log('窗口获得了焦点！'); onload:窗口加载事件 onresize:窗口大小缩放事件 /* 窗口加载完成后*/ window.onload =function () { console.log("窗口加载完成！") } /* 窗口大小改变时 事件 */ window.onresize = function () { console.log("窗口大小正在发送生改变"); } 表单事件 onchange： 内容改变事件 oninput ：当文本框内容改变时 ，立即将改变内容 输出在控制台 /* onchange 内容改变事件 */ userCode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/747490b9bb586d091bfb9eee19b37236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9f0c8dffcebbf60550fc489d116d73/" rel="bookmark">
			MySQL的count(*) ,count(1),count(id)的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库查询相信很多人都不陌生，所有经常有人调侃程序员就是CRUD专员，这所谓的CRUD指的就是数据库的增删改查。
在数据库的增删改查操作中，使用最频繁的就是查询操作。而在所有查询操作中，统计数量操作更是经常被用到。
关于数据库中行数统计，无论是MySQL还是Oracle，都有一个函数可以使用，那就是COUNT。
但是，就是这个常用的COUNT函数，却暗藏着很多玄机，尤其是在面试的时候，一不小心就会被虐。不信的话请尝试回答下以下问题：
COUNT有几种用法？
COUNT(字段名)和COUNT(*)的查询结果有什么不同？
COUNT(1)和COUNT(*)之间有什么不同？
COUNT(1)和COUNT(*)之间的效率哪个更高？
为什么《阿里巴巴Java开发手册》建议使用COUNT(*)
MySQL的MyISAM引擎对COUNT(*)做了哪些优化？
MySQL的InnoDB引擎对COUNT(*)做了哪些优化？
上面提到的MySQL对COUNT(*)做的优化，有一个关键的前提是什么？
SELECT COUNT(*) 的时候，加不加where条件有差别吗？
COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？
以上10道题，如果您可以全部准确无误的回答的话，那说明你真的很了解COUNT函数了，如果有哪些知识点是不了解的，那么本文正好可以帮你答疑解惑。
认识COUNT 关于COUNT函数，在MySQL官网中有详细介绍：
简单翻译一下：
1、COUNT(expr) ，返回SELECT语句检索的行中expr的值不为NULL的数量。结果是一个BIGINT值。
2、如果查询结果没有命中任何记录，则返回0
3、但是，值得注意的是，COUNT(*) 的统计结果中，会包含值为NULL的行数。
即以下表记录示例：
create table #bla(id int,id2 int)
insert #bla values(null,null)
insert #bla values(1,null)
insert #bla values(null,1)
insert #bla values(1,null)
insert #bla values(null,1)
insert #bla values(1,null)
insert #bla values(null,null)
使用语句count(*),count(id),count(id2)查询结果如下：
select count(*),count(id),count(id2)
from #bla
结果依次是：　７　３　２
除了COUNT(id)和COUNT(*)以外，还可以使用COUNT(常量)（如COUNT(1)）来统计行数，那么这三条SQL语句有什么区别呢？到底哪种效率更高呢？为什么《阿里巴巴Java开发手册》中强制要求不让使用 COUNT(列名)或 COUNT(常量)来替代 COUNT(*)呢？
COUNT(列名)、COUNT(常量)和COUNT(*)之间的区别
前面我们提到过COUNT(expr)用于做行数统计，统计的是expr不为NULL的行数，那么COUNT(列名)、 COUNT(常量) 和 COUNT(*)这三种语法中，expr分别是列名、 常量 和 *。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c9f0c8dffcebbf60550fc489d116d73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc0b997e44af396d88edd8c72fc567a/" rel="bookmark">
			Could not resolve hostname 。。。。。。: Name or service not known(学习笔记，不作教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Could not resolve hostname 。。。。。。: Name or service not known 究其原因就是域名找不到对应的映射IP
所以直接
sudo vi /etc/hosts
然后把ip 域名映射加进去
域名ip可以在服务器用ifconfig查询
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f752db5d69f53738f699353c569de6ee/" rel="bookmark">
			Linux 系统安装 Mysql 8.0.30
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、MySQL Community Downloads 下载地址：[https://dev.mysql.com/downloads/mysql/]
我选择的是 Linux - Generic 下面的 Linux - Generic (glibc 2.12) (x86, 64-bit), Compressed TAR Archive 版本（压缩TAR存档版本）
参考界面：
2、安装 需要准备工具：Xshell 7 、Xftp 7 或者其它工具 2.1、 压缩TAR存档版本的安装 2.1.1、新建安装程序文件所在的目标文件夹。 一般程序放在 /usr/local/mysql/ 目录，数据文件放在 /usr/local/mysql/data/。data 文件夹不用建立了，mysql8 在初始化会自己建立。
新建目标目录可以用命令 mkdir mysql 或者利用xftp 工具 右键新建文件夹实现 (1) 切换到 /usr/local/ 目录
cd /usr/local/ (2) 新建mysql文件夹
mkdir mysql 终端命令行实现：
2.1.2、新上传压缩TAR存档版本的文件并且解压文件 (1) 上传：我是利用Xftp 7工具上传。 (2) 解压缩文件 命令：tar -xvf 压缩文件名.tar.gz 这个文件不是gzip格式的，使用tar -xvf来解压就好了。 tar -xvf mysql8.tar.xz 我的安装文件名上传前已经重新命名“mysql8.tar.xz”. 参考运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f752db5d69f53738f699353c569de6ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbc7dac47a60a7181f74c70e883a714/" rel="bookmark">
			购物车——js小项目实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		购物车——js小项目实例 首先构思好整体样式 添加点击事件🍁事件委托🍁接下来就是各种函数的书写 最后附上完整js代码 短短几周，js阶段的学习已然结束，结课作业就是实现一个购物车功能 功能：
1、可以添加商品 2、全选按钮 3、合计 4、数量增减 以上。
先看看成品图
🍁自在飞花轻似梦，无边丝雨细如愁。 —— 浣溪沙·漠漠轻寒上小楼🍁
首先构思好整体样式 HTML
&lt;!-- 作业专用html框架 --&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;购物车&lt;/title&gt; &lt;link rel="stylesheet" href="./css/reset.css"&gt; &lt;link rel="stylesheet" href="./css/index.css"&gt; &lt;link rel="shortcut icon" href="/icon/icon.png" type="image/x-icon"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div class="framework"&gt; &lt;header&gt; &lt;nav&gt; &lt;ul class="headbar"&gt; &lt;li&gt;&lt;span&gt;/&lt;/span&gt;&lt;a href="#"&gt;我的购物车&lt;/a&gt;/&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;main&gt; &lt;div class="container"&gt; &lt;div class="title"&gt; &lt;span id="realname"&gt;商品名称：&lt;/span&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cbc7dac47a60a7181f74c70e883a714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48dc22e29816d7e03ddaa697b39e47c0/" rel="bookmark">
			STM32MP157 | 基于 Linux SPI 驱动M74HC595数码管显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、M74HC595简介 M74HC595器件是采用硅栅C2MOS技术制作的具有输出锁存器(3态)的高速CMOS 8位移寄存器。
该设备包含一个8位串行进、并行出移位寄存器，它提供一个8位d型存储寄存器。存储寄存器有8个3状态输出。为移位寄存器和存储寄存器都提供了单独的时钟。
移位寄存器有直接覆盖清除，串行输入和串行输出(标准)引脚级联。移位寄存器和存储寄存器都使用正边缘触发时钟。如果两个时钟连接在一起，移位寄存器状态将始终是存储寄存器前面的一个时钟脉冲。
特性：
高速:在Vcc = 6V时，fMAx = 59mhz(典型)低功耗:Icc = 4 μA (max)工作电压范围宽:Vcc (opr.) = 2 V至6 V 1.M74HC595设备操作原理图： 2. 开发板原理图 二、 添加设备树的节点 1.设置引脚 首先设置spi引脚的复用功能，找到 spi4_pins_b 节点：
vi stm32mp15-pinctrl.dtsi
2. 找出控制器的设备树 stm32mp151.dtsi
spi4: spi@44005000 { #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; compatible = "st,stm32h7-spi"; reg = &lt;0x44005000 0x400&gt;; interrupts = &lt;GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH&gt;; clocks = &lt;&amp;rcc SPI4_K&gt;; resets = &lt;&amp;rcc SPI4_R&gt;; dmas = &lt;&amp;dmamux1 83 0x400 0x01&gt;, &lt;&amp;dmamux1 84 0x400 0x01&gt;; dma-names = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48dc22e29816d7e03ddaa697b39e47c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d3d92b092dd434b8408357825b3755d/" rel="bookmark">
			【Java】数组求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【Java】数组求和 需求 键盘录入5个整数，存储到数组中，并对数组求和
代码 package com.cxl.demo24; /* 数组求和 需求：键盘录入5个整数，存储到数组中，并对数组求和 */ import java.util.Scanner; public class Demo24_1 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int sum = 0; int[] arr = new int[5]; System.out.println("请输入5个整数"); for (int i = 0; i &lt; arr.length; i++){ System.out.print("请输入第"+(i+1)+"个整数："); arr[i]= sc.nextInt(); sum += arr[i]; } System.out.println("和为"+sum); } } 运行效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3963c5b4b41c49e79fcea59fc63ca6/" rel="bookmark">
			vue引入element不显示样式以及一些别的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 vue2.0和vue3.0引入element不同vue2.0vue3.0 element使用错误在这里插入图片描述在这里插入图片描述 vue2.0和vue3.0引入element不同 跟着视频学习时，自己用的3.0版本，与视频不同，所以element引入后页面空白。
于是进入官网引用相应的版本，稍微总结一下。
vue2.0 [进入官网查看详细步骤]: Element - 网站快速成型工具
1.npm 安装
npm i element-ui -S 2.引入element
完整引入
在 main.js 中写入以下内容：
import Vue from 'vue'; import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; import App from './App.vue'; Vue.use(ElementUI); new Vue({ el: '#app', render: h =&gt; h(App) }); vue3.0 官网：https://element-plus.gitee.io/zh-CN/
vue3.0使用的element为element-plus，与vue2.0略有不同；
1.npm 安装
# NPM npm install element-plus --save 2.引入element-plus
完整引入
在 main.js 中写入以下内容：
import { createApp } from 'vue' import ElementPlus from 'element-plus' import 'element-plus/dist/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e3963c5b4b41c49e79fcea59fc63ca6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4bddcec5993f87e27601a1fe304d51/" rel="bookmark">
			关于二进制？？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 二进制二进制转化为十进制十进制转化成二进制无符号数和有符号数原码反码补码 二进制的计算规则 二进制 二进制转化为十进制 二进制是一套计数方法，每个数位有0、1两种可能，类比在日常生活中我们使用的十进制，每个数位有0-9十种可能；
关于十进制，从右到左，每一位的位权，也就是说固定位置的固定单位分别是：
10^0=110^1=1010^2=100…… 因此，105这个数的值就可看作1×10²+0×10¹+5×10⁰=105
同理得到：
2^0=12^1=22^2=42^3=82^4=162^5=322^6=64…… 二进制数101011B转换为十进制数就是1×2⁵+0× 2⁴+1× 2³+0× 2²+1× 2¹+1× 2⁰=43
任意进制的数转化为十进制，都是按照各位数码与位权相乘，再加到一起；
计算机中采用二进制计数，因此计算机中的数、字母、符号都是以特定的二进制数来表示，这就是二进制编码；
机器只能识别二进制数，因此，键盘上所有的数字、字母和符号都以特定的二进制编码表示，以便机器识别、存储、处理和传送；
为什么计算机要采用二进制实现呢？
1.在技术上容易实现，可以用任何一个具有两种不同稳定状态的物理器件（如信号的有无，电平的高低等）来表示数码“0”和“1”；
2.运算简单，r进制数共有r×（r-1）/2个求和与积的运算公式，对二进制而言，只有3个求和公式（0+0=0，0+1=1，1+1=10）三个求积公式（0×0=0，1×0=0，1×1=1）
3.逻辑判断方便；
4.状态稳定；
十进制转化成二进制 1.十进制整数转换为任意进制整数——除基取余法
以十进制数转换为二进制数为例，将十进制数连续除以基数2，直到商等于0为止，然后逆序排列每次得到的余数，就得到了与该十进制对应的二进制数；
2.十进制小数转换为任意进制小数——乘基取余法
以十进制小数转换为二进制数为例，将十进制小数连续乘以基数2，直到乘积的小数部分等于0为止，然后顺序排列每次得到的乘积的整数部分，就得到了该十进制小数对应的二进制小数；
无符号数和有符号数 所谓的无符号数，是全部的二进制位均表示数值的位，相当于数的绝对值；
对于有符号数，数据的最高位表示符号，而不再表示数值位。符号的正负要依据所采用的编码方式来确定；
有符号数分为原码、反码、补码和移码等多种表示形式；
原码 原码的最高位是符号位（“0”表示该数为正，“1”表示该数为负），数值部分不变；
利用原码进行乘除运算比较简单，但是加减运算规则复杂，首先要分析两数的符号位是否相同，然后比较两数绝对值的大小，以决定实际做加法还是减法，最后还要确定符号；
反码 正数的反码是其本身，负数的反码是在其原码的基础上，各个位取反；
补码 人们设置了补码克服复杂的加减法运算，补码使得符号位也能参与运算，并将减法转换为加法；
正数的补码是其本身，负数的补码，是它的反码+1；
二进制的计算规则 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a8d4b55e8bbd0482c096c7f91f0dfbf/" rel="bookmark">
			Endnote 导入参考文献的时候，格式错误太多了。et.al错误，国标GBT7714在endnote中的详细配置教程，适用于本科，硕士论文文献插入的模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一·、Endnote文献GBT7714下载0.起因与发展1.1进行chinese GBT7714 2015的下载 二、Endnote格式配置及参数的设置2.1 开始修改配置重要配置详细分解英文期刊中文期刊 三、实战插入文献管理中文文献的插入结尾 一·、Endnote文献GBT7714下载 0.起因与发展 此时博主是研二，需要开题，此时用到EndNote进行文献插入的时候，发现文献格式和直接应用的差距很大，具体来说有以下几方面1.中英文文献插入的格式不一样2.中文超过三个人应该有等这个词而不是et.al3.英文不应该作者全是大写，同时字体应该是Times new roman4.论文的期刊号不对，或者缺页码 如果你也遇到以上问题，并且需要一套完整的GBT设置请往下继续阅读，我会很快带你避开我花了一晚上踩过的坑
首先你应该是会插入文献的人了，如果不会请参考EndNote如何导入文献;5分钟既可以上手 1.1进行chinese GBT7714 2015的下载 链接如下：GBT7714-2015
下载好后，进入EndNote里面进行导入
随后，直接双击并在EndNote中打开，首先选择“File”→“Save As”。这里另存为是为了将我们修改后的引文格式文件保存在EndNote默认路径下
点击“Save”后，回到主界面。选择“Edit”→“Output Styles”，选择我们刚刚另存为的引文格式名称，现在如果我们在Word中添加引文文献，所用格式就是刚刚另存为的这个引文格式。
二、Endnote格式配置及参数的设置 2.1 开始修改配置 Edit-&gt;outputStyle-&gt;chinese std Gbt7714
界面如下
大家直接按我图片上的设置进行操作即可
1.指定文章的页面设置
2.期刊的全名与缩写设置
3.文章引用的脚注设置成[]这种类型
4.作者名字的设置如下
5.作者大小写设置，论文应该都是首字母大写哈
-6.接下来就是最重要的了
重要配置详细分解 英文期刊 1.英文期刊的设置
Journal Article Author. Title [J]|. Journal|, Year|, Volume|(Issue)|:Pages|. 2.字体选择上面的进行Time new roman
3.超过3个作者后的配置
中文期刊 首先需要新建一个Preference；点击Edit-Preferences
这里我是新建好了中文文献，那么我们需要选中下拉的unused2
2.这里自定义名字；我就取Chinese Jounal 将上述的配置完后，回到这个主界面3.进行中文作者超过3个的配置
4.文献引入格式设置
Secondary Author. Title [J]|. Journal|, Year|, Volume|(Number)|:Pages|. 5.退出界面保存即可，到此处已经完成了配置
三、实战插入文献管理 经过上述的配置我们可以来演示插入文献了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a8d4b55e8bbd0482c096c7f91f0dfbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41592c5d112605b8f1df112ea3529cfd/" rel="bookmark">
			ubuntu中命令行求csv文件的交集和差集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ubuntu中命令行求csv文件的交集和差集
sort 差集
sort -m &lt;(sort big.csv | uniq) &lt;(sort small.csv | uniq) &lt;(sort small.csv | uniq) | uniq -u &gt; different_set_bySort.csv grep 交集
功能：可以把文件2中存在文件1的行输出
grep -F -f big.csv small.csv &gt; intersection_byGrep.csv grep 差集
#注意，是 big - small 的结果 grep -F -v -f small.csv big.csv &gt; difference_set_byGrep.csv 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5fdbcd0425cf3d5fd76b8083e203ccc/" rel="bookmark">
			MySQL隐式转换，导致索引失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 MySQL索引失效的情况有很多，下面主要介绍数据隐式转换导致索引失效。
这一点在我们平常书写SQL语句的时候可能是最容易忽略的但是又是经常容易犯的错误。
开门见山，下面我们看一下官方文档描述。
官方文档描述 两个参数至少有一个是NULL时，比较的结果也是NULL，特殊的情况是使用&lt;=&gt;对两个NULL做比较时会返回1，这两种情况都不需要做类型转换两个参数都是字符串，会按照字符串来比较，不做类型转换两个参数都是整数，按照整数来比较，不做类型转换十六进制的值和非数字做比较时，会被当做二进制串有一个参数是TIMESTAMP或DATETIME，并且另外一个参数是常量，常量会被转换为timestamp有一个参数是decimal类型，如果另外一个参数是decimal或者整数，会将整数转换为decimal后进行比较，如果另外一个参数是浮点数，则会把decimal转换为浮点数进行比较所有其他情况下，两个参数都会被转换为浮点数再进行比较 准备数据 准备以下字段的表，并且为num1建立索引。
CREATE TABLE `type` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, `num1` varchar(255) DEFAULT NULL, `num2` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_num1` (`num1`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 复制代码 在数据库中插入以下数据
查询数据 方式一
SELECT * FROM type WHERE num1 = 1000 复制代码 注意：这是num1是varchar类型，而查询的时候给的where条件是1000的整形。
这时查询得到的数据时包含其他脏数据的。
explain分析查询语句，结果走了全表扫描。
方式二
在对num1字段的where语句拼接上单引号后查询的结果和我们预期一样。
SELECT * FROM type WHERE num1 = '1000' 复制代码 explain分析查询语句，结果走了索引，索引生效了。
那么这个字符串隐式转换的规则是什么呢？为什么num1='1000a'、'01000'和'1000'这三种情形都能匹配上呢？查阅相关资料发现规则如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5fdbcd0425cf3d5fd76b8083e203ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e610c8c8b3c3f2d5dff80a393e337e/" rel="bookmark">
			Windows VStudio 查看虚函数指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows VStudio 查看虚函数指针 打开VS下面的Developer Command Prompt for VS 2019
切换到当前项目文件下:
切换盘：cd \d C:
切换到当前文件夹下：cd C:\Users\xY\Desktop\test\Project1\
查看虚函数指针：
cl /d1 reportSingleClassLayoutSingingWaiter “1.cpp”
当没有虚继承时：
使用虚继承后：
完整代码： #include&lt;iostream&gt; using namespace std; // 人类 class Person { public: int m_Age;	// 年龄 }; // 歌手类 class Singer : virtual public Person { }; // 服务员类 class Waiter : virtual public Person { }; // 会唱歌的服务员类 class SingingWaiter : public Singer, public Waiter { }; // 虚继承的实现原理 int main() { SingingWaiter sw; sw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33e610c8c8b3c3f2d5dff80a393e337e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef7326927c057aa9be8eaa8a888144f/" rel="bookmark">
			Vue Router
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网址：Vue Router，vuerouter是vue全家桶（vue+vue router+vuex ）**之一。
此处建议创建一个带Router的vue项目。
1、介绍 Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：
嵌套的路由（套娃，父子路由）
模块化的、基于组件的路由配置
路由参数、查询、通配符
带有自动激活（默认选中效果）的 CSS class 的链接
HTML5 历史模式或 hash 模式
MVVM框架采用的路由都会在地址改变的时候页面不刷新，这种应用我们称之为SPA（Single Page Application）
2、路由模式切换 vue-router中默认使用的是hash模式的路由，也就是前面介绍的地址栏中URL带有“#”的形式，如果需要切换成history模式，则可以在创建路由实例时进行指定，指定的配置项为mode，可选值：
hash：默认，设置路由模式为hash路由
history：设置路由模式为history路由
3、导航方式 含义：从一个组件/地址去往另一个组件/地址的方式。
在页面中，导航实现有2种方式：
声明式导航：通过点击链接实现的导航方式，例如HTML中的“&lt;a&gt;”标签，Vue中的“&lt;router-link&gt;”所实现的。（其性质与a标签的性质类似）
编程式导航：通过调用JavaScript形式API实现的导航方式，例如location.href实现的跳转效果
3.1、声明式导航
它就是先在页面中定义好跳转的路由规则，vueRouter中通过router-link组件来完成
&lt;!-- 纯字符串 --&gt; &lt;router-link to="/home"&gt;Home&lt;/router-link&gt; ​ &lt;!-- 动态绑定路径 --&gt; &lt;router-link :to="'/home'"&gt;Home&lt;/router-link&gt; ​ &lt;!-- 对象形式 --&gt; &lt;router-link :to="{ path: '/home' }"&gt;Home&lt;/router-link&gt; ​ &lt;!-- 通过路由命名并且携带隐式参数 --&gt; &lt;router-link :to="{ name: 'user', params: { userId: '123' }}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ef7326927c057aa9be8eaa8a888144f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1eb2e17fbf42fc8a104e6fc841c4e1/" rel="bookmark">
			Ubuntu PX4无人机仿真环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、VM虚拟机安装ubuntu18.04
1、VMware安装
2、新建虚拟机
二、Ubuntu系统配置
1、更改软件安装源
2、安装中文输入法
三、PX4环境搭建
1、安装git
2、下载px4源码
3、安装ROS
4、安装MAVROS
5、安装QGC
6、仿真测试
四、其他工具安装
1、VScode安装
一、VM虚拟机安装ubuntu18.04 1、VMware安装 选择路径时建议不要安装在C盘
2、新建虚拟机 点击创建新的虚拟机
会出现安装向导
点击下一步
点击浏览
选择ubuntu-18.04.5，点下一步
自行设置全名、用户名（建议设置小写英文，全名和用户名一样就可以）和密码，密码需要大于等于6位(比如123456就可以)。设置完成后点下一步
设定虚拟机名称。注意安装位置不要选C盘，点击浏览，可以在其他盘（比如D盘）下面创建一个文件夹安装虚拟机。点击下一步
磁盘大小默认是20G，后续安装软件可能需要用更多空间，所以最好选40G。设定好后点击下一步。
点击自定义硬件
后续可能需要在虚拟机上跑仿真，所以更改内存为4GB
在显示器下，确定打开加速3D图形，也是为了之后使用图形软件需要。
设定好后点击关闭，在点击完成，虚拟机就创建完毕了。VM软件会自动开启虚拟机，第一次开启系统会自动安装一些软件，耐心等待安装完成就可以。
安装完成后你会看到之前设置的用户名，点击输入之前设置的密码就可以进入系统了。
二、Ubuntu系统配置 1、更改软件安装源 Linux默认的软件安装源是在国外，我们需要改成国内的源，不然下载速度会很慢。
界面右下角9个点点开，点击
点击Download from，选择Other…
选择阿里服务器
选择后需要输入一下密码
更换好之后close关闭，会跳出一个框，选reload，等待它更新一会儿（会等待比较久）。
2、安装中文输入法 点击设置，到Region&amp;Language页面
点击框框的位置，第一次点开系统会自动检测更新
点击install，安装完成后点击：
找到简体中文，勾选，点击Apply开始安装
完成后登出登入一下系统
回到之前的界面，点击加号
点击Chinese
选择拼音输入法，然后登出登入一下系统就OK了。
也可以把系统语言改成中文，点击Language
选择汉语
然后重新登入登出一下系统，就可以了。
三、PX4环境搭建 PX4官方文档：https://docs.px4.io/master/zh/
1、安装git 快捷键Ctrl+alt+T调出终端，输入下述指令后回车
sudo apt-get install git
输入你的密码，如果后续询问输入 y回车确定安装，就会开始安装程序了。
查看版本号 git --version
出现版本号说明安装成功
2、下载px4源码 git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb1eb2e17fbf42fc8a104e6fc841c4e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1278f2bef108a6af9382bfe0b511bbf5/" rel="bookmark">
			打造一台“苹果范儿”的 Linux 系统，桌面美化攻略来了~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注公众号，实用技术文章及时了解
目录
前言
参考文章
1.安装工具gnome-tweaks
2.修改窗口的按钮位置
3.安装gnome扩展并设置
4.美化桌面主题
5.美化图标
6.美化光标
7.美化桌面背景，锁屏和登陆页面
8.修改桌面工具栏位置
9.修改字体
10.修改终端样式
最终效果
前言 由于ubuntu18.04的桌面字体太小，想着把字体调整一下，于是上网查资料。结果，查着查着，最后不小心把整个桌面给美化了，hhhhh
之前的桌面长这样：
现在的桌面长这样：
是不是感觉跟苹果系统比较像，哈哈哈，其实就是按照苹果主题设置的hhh
参考文章 https://blog.csdn.net/qq_42527676/article/details/91356154
https://blog.csdn.net/huiyuanliyan/article/details/97109935
https://blog.csdn.net/qq_34626094/article/details/113113318
1.安装工具gnome-tweaks 1.1 安装gnome-tweaks和gnome-tweak-tool：
sudo apt-get update sudo apt-get install gnome-tweaks sudo apt-get install gnome-tweak-tool 1.2 打开gnome-tweaks：
gnome-tweaks 2.修改窗口的按钮位置 2.1 点击窗口选项，根据自己的习惯设置窗口：
3.安装gnome扩展并设置 3.1 Ctri+C 退出gnome-tweaks
3.2 安装gnome-shell-extensions：
sudo apt-get install gnome-shell-extensions 3.3 重启gnome：按Alt+F2进入命令窗口，输入r，并回车
3.4 重新打开gnome-tweaks：
gnome-tweaks 3.5 点击拓展选项，把User themes打开
到这里准备工作基本就完成了，接下来就该正式美化了
4.美化桌面主题 美化官网：https://www.opendesktop.org/.
4.1 选择桌面主题，我选择的是这个: McMojave
4.2 下载压缩包，并解压（我下载的是这个）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1278f2bef108a6af9382bfe0b511bbf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb037b989e3fef99244d5eacc55aea6f/" rel="bookmark">
			Spring的@Autowired注解原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. @Autowired的作用 @Autowired常用来作属性的注入，可以作用在构造方法、普通方法、字段、注解、参数上。
将构造函数、字段、设置方法或配置方法标记为由Spring 的依赖注入工具自动装配。
@Autowired注解做过开发的肯定都很常用了，具体作用和用法就不再多说了。Spring中AutowiredAnnotationBeanPostProcessor 处理器负责处理@Autowired注解相关注入。
二. 源码浅读 package org.springframework.beans.factory.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * Marks a constructor, field, setter method, or config method as to be autowired by * Spring's dependency injection facilities. This is an alternative to the JSR-330 * {@link javax.inject.Inject} annotation, adding required-vs-optional semantics. * * &lt;h3&gt;Autowired Constructors&lt;/h3&gt; * &lt;p&gt;Only one constructor of any given bean class may declare this annotation with the * {@link #required} attribute set to {@code true}, indicating &lt;i&gt;the&lt;/i&gt; constructor * to autowire when used as a Spring bean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb037b989e3fef99244d5eacc55aea6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f7747b014e6d0639573c2674694fad6/" rel="bookmark">
			docker使用入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 初级指导： Docker overview | Docker Documentation 名词解释 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。主机： 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。Docker Registry： Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用PGP： Pretty Good Privacy 是一套用于消息加密、验证的应用程序. PGP 本身是商业应用程序；对应的开源软件为 GPG（GnuPG）GPG: GNU Privacy Guard, 也是一种加密软件，它是 PGP 加密软件的开源替代程序. 在docker中主要用于容器的加密？volume: 卷Flask： 是一个Python编写的Web 微框架，让我们可以使用Python语言快速实现一个网站或Web服务bind mount： linux命令，将一个目录挂载到另一个CI / CD: Continuous Integrate, Continuous Deploy 持续集成和持续交付Dockerfile: 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。Compose: 您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。 比Dockerfile集成度更高。或者说前者用来启动程序，后者用来生成镜像overlay: 相当于创建一个虚拟网络，将主机，多个容器，甚至多个docker daemon均覆盖进来，彼此之间均可以通信CNM: Container Network Modelbridge: 早期的交换机雏形，交换机可以认为是多个bridge的集合。转发二层帧，起到信号放大的作用。网卡相当于是一个网桥/交换机，两者在一个网段内。arp和ping均可以通过automatic service discovery： 类似于DNS服务，使得 ping -c 2 alpine2 这样的操作可以实现kvm: Kernel-based Virtual Machine,是一种内建于linux中的开源虚拟化技术QEMU： 一种通用的开源计算机仿真器和虚拟器 安装 docker desktop 以下安装方法针对ubuntu
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f7747b014e6d0639573c2674694fad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9727be5c6fcba0f061ac5a6f5ca3e677/" rel="bookmark">
			电量计量芯片HLWＷ8110的前端电路设计与误差分析校正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8d06e5c7106ff6234a7cd0ad09fb82/" rel="bookmark">
			4【Android 12】【WCT的同步】BLASTSyncEngine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、BLASTSyncEngine定义 /** * Utility class for collecting WindowContainers that will merge transactions. * For example to use to synchronously resize all the children of a window container * 1. Open a new sync set, and pass the listener that will be invoked * int id startSyncSet(TransactionReadyListener) * the returned ID will be eventually passed to the TransactionReadyListener in combination * with a set of WindowContainers that are ready, meaning onTransactionReady was called for * those WindowContainers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e8d06e5c7106ff6234a7cd0ad09fb82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7cb3d58f2e061008b7c9d56acb63b0/" rel="bookmark">
			双色球双色球杀号公式,双色球杀号公式汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双色球定号杀号方法大全_27个杀红公式 双色球定号杀号方法大全27个杀红公式一，当期开奖号码大小顺序第一位与第六位的差，计算的结果在下一期有可能不出。1、当期开奖号码大小顺序第二位与第三位的差，计算的结果在下一期有可能不出。
2、当期开奖号码大小顺序第二位与第五位的差，计算的结果在下一期有可能不出。3、当期开奖号码大小顺序第一位乘4再减掉2，计算的结果在下一期有可能不出。
投注双色球投注区分为红色球号码区和蓝色球号码区，红色球号码区由1-33共三十三个号码组成，蓝色球号码区由1-16共十六个号码组成。
投注时选择6个红色球号码和1个蓝色球号码组成一注进行单式投注，每注金额人民币2元。购买者可选择机选号码投注、自选号码投注。
机选号码投注是指由投注机随机产生投注号码进行投注，自选号码投注是指将购买者选定的号码输入投注机进行投注。以上内容参考：百度百科-中国福利彩票双色球。
谷歌人工智能写作项目：小发猫
双色球定号杀号方法大全 27个杀红公式 深度神经网络是怎么学习的。
双色球定号杀号方法大全27个杀红公式是当期开奖号码大小顺序第一位与第六位的差一，当期双色球开奖号码大小顺序第一位与第六位的差，具体公式为二、当期双色球开奖号码大小顺序第二位与第三位的差，计算的结果在下一期有可能不出11。
三、当期双色球开奖号码大小顺序第二位与第五位的差，计算的结果在下一期有可能不出13。四、当期双色球开奖号码大小顺序第一位乘4再减掉2，计算的结果在下一期有可能不出06。
五、当期双色球开奖号码大小顺序第一位加当期开奖的兰号，计算的结果再乘3后，所得的号码在下一期有可能不出16。双色球的其他规定。
双色球投注区分为红色球号码区和蓝色球号码区，红色球号码区由1-33共三十三个号码组成，蓝色球号码区由1-16共十六个号码组成。
投注时选择6个红色球号码和1个蓝色球号码组成一注进行单式投注，每注金额人民币2元。购买者可在各省福彩机构设置的销售网点投注。投注号码经投注机打印出对奖凭证，交购买者保存，此对奖凭证即为双色球彩票。
双色球杀红球100%杀号公式是什么？ 双色球是一种比较大众化的福利彩票游戏，但是它的号码比较多，所以中奖难度相对比较大。但是如果换种思维，去思考哪些号码出现的机率比较小，也许会有出人意料的结果。
1、当期开奖号码大小顺序第一位与第六位的差，计算的结果在下一期有可能不出。2、当期开奖号码大小顺序第二位与第三位的差，计算的结果在下一期有可能不出。
3、当期开奖号码大小顺序第二位与第五位的差，计算的结果在下一期有可能不出。
一等奖：当奖池资金低于1亿元时，奖金总额为当期高奖级奖金的75%与奖池中累积的资金之和，单注奖金按注均分，单注最高限额封顶500万元。
当奖池资金高于1亿元（含）时，奖金总额包括两部分，一部分为当期高奖级奖金的55%与奖池中累积的资金之和，单注奖金按注均分，单注最高限额封顶500万元；另一部分为当期高奖级奖金的20%，单注奖金按注均分，单注最高限额封顶500万元。
双色球杀红球100%杀号公式 杀号没有公式，又不是解数学题有对应的公式，标准的答案。彩票全是看运气。双色球是中国福利彩票的一种玩法。
中国福利彩票“双色球”是一种由中国福利彩票发行管理中心统一组织发行，在全国销售联合发行的“乐透型”福利彩票。2003年2月16日起在全国联网销售。采用计算机网络系统发行销售，定期电视开奖。
参与“双色球”销售的省级福利彩票发行中心在中福彩中心的直接领导下，负责对本地区的“双色球”销售活动实施具体的组织和管理。红球一共6组，每组从1-33中抽取一个，六个互相不重复。
然后蓝球是从1-16中抽取一个数字，这整个组成的双色球。
双色球杀红公式是什么 没有公式，所谓的杀号只是根据走势去掉一些认为当前期开出概率较小的号码，比如上期刚刚出过的号码，最近10期出过多次的号码等等，杀号之后号码的总数就小了，但是副作用是杀得不准确就直接把开奖号码给杀掉了！
其实概率是一样的，无非是一种选号方式而已。
双色球有那些准确率到的杀红蓝公式，或者能大大提高中一等奖的方法 方法一：利用上期开奖红球号码每两个号码相减的绝对值作为下一期开奖号码杀号的选择。
例如061期开奖号码13、16、19、20、23、33，每两个号码相减的绝对值为16－13、19－13、20－13等共有15个差值，其中有相同的差值，那么062期的杀号选择为01、03、04、06、07、10、13、14、17、20，实际杀错了一个红球01。
此方法杀错号码个数一般在0－2个，但也有例外，059期杀错6个，所以此方法要灵活运用。2方法二：利用上二期顺序开奖号码一一对应相减的绝对值作为下一期的开奖号码杀号的选择。
例如060期和061期顺序开奖号码分别是27、24、28、11、03、05和16、23、19、13、33、20，那么其一一对应相减的差值是27－16、24－23等共有6个差值，差值结果是11、01、09、02、30、15，预测062期实际杀错了一个红球01。
此方法杀错号码个数一般在0－2个。3方法三：利用上期开奖号码减去本期蓝球（不包括"快乐星期天"的蓝球）的绝对值作为下一期的开奖号码杀号的选择。
例如061期开奖号码13、16、19、20、23、33，本期蓝球为09，其差值分别是13－9、16－9等共6个差值。其结果是04、07、10、11、14、24，预测062期全部杀对。
此方法杀错号码个数一般在0－2个。4方法四：利用上期开奖号码减去本期AC值的绝对值作为下一期的开奖号码杀号的选择。
例如061期开奖号码13、16、19、20、23、33，本期AC值是5，其差值分别是13－5、16－5等共6个差值，其结果是08、13、24、15、18、28，预测062期实际杀错了一个红球28。
注意如果差值相减为负数的话必须加上33。例如03－7＋33＝29。此方法杀错号码个数一般在0－3个。另外用本期AC值杀下一期尾数也是一种杀号选择。
例如061期AC值是5，选择杀5的尾数05、15、25，结果错一。5方法五：利用上期开奖号码减去本期和值的拆分合值作为下一期的开奖号码杀号的选择。
例如061期开奖号码13、16、19、20、23、33，当期合值为124，其拆分合值为1＋2＋4＝7。
其差值分别是13－7、16－7等共6个差值，其结果是06、09、12、13、16、26，预测062期实际杀错了一个红球12。注意如果差值相减为负数的话必须加上33。此方法杀错号码个数一般在0－2个。
6方法六：利用上期开奖号码减去当期尾数合值的拆分合值作为下一期的开奖号码杀号的选择。
例如061期开奖号码13、16、19、20、23、33，当期尾数和值为3＋6＋9＋0＋3＋3＝24，其拆分合值为2＋4＝6。
其差值分别是13－6、16－6等共6个差值，其结果是07、10、13、14、17、27，预测062期全部杀对。注意如果差值相减为负数的话必须加上33。此方法杀错号码个数一般在0－2个。
注意事项以上的方法都比较方便，笔者在这里提供一点经验，运用任一方法如果其差值的结果等于本期的开奖号码，这个号码基本上的绝杀的号。例如13－7＝6，而06是本期开奖号码，那么下一期选择绝杀06。
巧用减法减杀红球方法比较简单，在实际运用中难免杀错号码，这就需要大家从差值中选择一些心水码做为补号，避免杀错号码。另外这些方法也适用于22选5和32选7的玩法，有兴趣的朋友可以自己验证一下。
最后笔者希望大家能灵活掌握这六种方法，而且不断的开创新思路、新方法，在实际运用中达到最好的效果。补充说明方法一有时要反着用，用于选胆。
双色球公式杀蓝，余数杀蓝请教。 1、A+B绝杀法绝杀公式：L=A+BL=本期绝杀篮A=上上期实际开出的篮球B=上期实际开出的篮球绝杀原理：A+B的和为一个自然数时，直接杀该数A+B的和为两位数时，取个位也就是和尾绝杀。
A+B的和为0时，其绝杀数都实战结果：从05001到05103期，错1期为05073，正确概率99%2、A+16绝杀法绝杀公式：L=A+16L=本期绝杀篮球A=上期实际开出篮球号码绝杀原理：上期篮球+16的和均为两位数，取其个位也就尾数作为本期绝杀号。
尾数值为0的，其绝杀都为10实战概率：从05011到05100运用此方法，错了05032，05062，0507105087，05098共5期！
正确概率95%3、A+B+C绝杀法绝杀公式：L=A+B+CL=本期要绝杀的篮球A=上期实际开出篮球B=上2期实际开出篮球C=上3期实际开出篮球绝杀原理：A+B+C的和均为两位数，取其个位也就尾数作为本期绝杀号。
尾数值为0的，其绝杀都为10实战概率：从05001到05102期，没有1期错误！
正确概率100%4A+B+C+D绝杀法绝杀公式：L=A+B+C+DL=本期要绝杀的篮球A=上期实际开出篮球B=上2期实际开出篮球C=上3期实际开出篮球D=上4期实际开出篮球绝杀原理：A+B+C+D的和均为两位数，取其个位也就尾数作为本期绝杀号。
尾数值为0的，其绝杀都为10实战概率：从05001到05100期，有05051，05066共2期错误！
正确概率98%5、红球+篮球绝杀法绝杀公式：L=红球+篮球L=本期绝杀篮球红球=上期开出的6个红球篮球=上期开出的实际篮球[不含快乐球]绝杀原理：把上期的6个红球和1个篮球相加，取和值的尾数绝杀其尾数为0时，都绝杀10实战概率：从05001到05100期，有05102，05041，05058，05062共期出错！
正确概率96%6、上期篮球S+G绝杀法绝杀公式：L=S+GL=本期绝杀篮球S=上期篮球的十位数字G=上期篮球的个位数字绝杀原理：1）上期篮球大于10，十位和个位直接相加，取和绝杀2）上期篮球小于或等于10，先加16，如果相加后尾数为0时，再加16，后将得数的十位和个位相加，相加后的和为绝杀数。
绝杀整理：上期为：01本期绝杀：08020903100402050306040705080609071001110212031304140515061607实战概率：从05001到05109期，有0509005109仅2期出错！
正确98%7上期篮球S-G绝杀法绝杀公式：L=S-GL=本期绝杀篮球S=上期篮球十位数字G=上期篮球个位数字绝杀原理：上期篮球大于10时，十位数字和个位数字直接相减。
上期篮球小于或等于10时，先加16，如果相加后尾数为0，在加16，然后将得数的十位和个位相减。相减后不论正负数，取绝对值作为绝杀号。
相减后差为0，都绝杀10绝杀整理：上期篮球为：01本期绝杀06020703080403050106100701080209031004111012011302140315041605实战概率：从05001到05109，有05051050940510005105出错正确概率为96%8、上期篮球S*G绝杀法绝杀公式：L=S*GL=本期要绝杀的篮球S=上期篮球的十位数字G=上期篮球的个位数字绝杀原理：上期篮球大于10时，十位数字和个位数字直接相乘。
上期篮球等于10时，加16，将得数的十位和个位数字相乘，积为本期要杀的篮球号码。
上期篮球小于10时，直接乘以16积为16时，绝杀16，积大于16时，取个位即尾数进行绝杀绝杀整理：当上期为：01本期绝杀16020203080404051006060702080809041012110112021303140415051606实战概率：从05001到05109，有05012，05041，05043，05073，05084共5期错，正确概率95%9、上期篮球S/G绝杀法绝杀公式：L=S/GL=本期绝杀篮球S=上期篮球的十位数字G=上期篮球的个位数字绝杀原理：上期篮球大于10，十位数字直接除以个位数字。
上期篮球小于等于10，先加16，如果相加后尾数为0，在再加上16，然后将得数的十位数字直接除以个位数字。相除后第一次的余数作为下期篮球的绝杀数字。相除数字为0，其绝杀数为10。
绝杀整理：上期开：01本期绝杀：03020203010410051006100702081009101002111012101301140215101604实战概率：从05001到05109，运用次法，有05022，05045，05061，050714期出错！
正确96%10、上期篮球A/G绝杀法绝杀原理：L=A/GL=本期绝杀篮球A=上期开出实际篮球G=上期篮球的个位数字绝杀原理：上期篮球大于10，直接除以个位数字。
上期篮球小于等于10，先加16，如果相加后尾数为0，在再加上16，然后将得数直接除以个位数字。相除后取整数商作为下期篮球的绝杀号相除商数大于16，取其尾数进行绝杀。
绝杀整理：上期开：01本期绝杀：02020203020406050106110707080609051004111112061304140315031602绝杀概率：从05001到05109，有050170502605094共3期错！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df7cb3d58f2e061008b7c9d56acb63b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2bf5e66489c8b37f3afefb078a1b076/" rel="bookmark">
			Windows 远程桌面连接 Jetson Nx （Linux）Ubuntu 18.04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Windows打开远程桌面工具 采取Windows自带远程桌面工具，使用win+r输入打开mstsc
输入目标ip，以及用户名（在显示选项中打开输入用户名）
二、Linux配置 安装xrdp服务 sudo apt-get install xrdp 安装xfce4并配置相关文件 sudo apt-get install xfce4 echo xfce4-session &gt; ~/.xsession cd ~ touch .session sudo vim /etc/xrdp/startwm.sh # 在文件前面添加： xfce4-session 此时使用远程桌面连接可能会出现登录闪退 Jetson NX的Ubuntu系统只允许每个账户在一个设备上登录，无法同时在两个设备上登录。而
nano在插电开机时默认自动登录账户，因此需要取消自动登录，具体方法： vim /etc/gdm3/custom.conf # 找到AutomaticLoginEnable和Automatic Login行，注释掉 # AutomaticLoginEnable=true # Automatic Login=[user1] 重启xrdp，重启机器 # 重启服务 sudo service xrdp restart # 重启机器 sudo reboot 使用Windows远程连接，输入ip、用户名、密码，成功获得Linux桌面界面
看起来好像大功告成了，但是出现问题，无法在远程桌面上打开终端 Ubuntu 18.04服务器，由于禁用了xserver，导致右键open in terminal 失败。需要修改terminal指
向： sudo update-alternatives --config x-terminal-emulator 选择xterm所在的选项，这里为6，设置成功后，重新远程桌面连接，即可在远程桌面中打开终端：
成功！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2aa172269ecf5feb702561468fe57e/" rel="bookmark">
			vscode 执行 pnpm i 时，Error: EPERM: operation not permitted
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode 执行 pnpm i 时，Error: EPERM: operation not permitted 背景： windows 11 开发某个模块需要对文件进行操作，而 window 中 vscode 对文件操作，需要管理员授权。无法删除 解决方案： 对文件权限进行编辑，设置成完全控制，即可 操作如下： 找到对应的文件，右键点击属性，切换到 安全栏，点击 Users 栏，点击编辑
如下图：注意： 如果点击应用会提示某些文件不可操作，一直点继续即可，最后点击确认，重新打开编辑器，重新执行命令即可，如果不行再 终端管理员模式 下重新执行命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15cb71af063d275298d7dd97c4d9145/" rel="bookmark">
			Android事件传递(三)：你真的知道 UP 在Activity、View、ViewGroup中怎么传递的么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android事件传递(一)：Activity、View、ViewGroup及dispatchtouchEvent、onTouchEvent梳理
Android事件传递(二)：事件动作 DOWN 在Activity、View、ViewGroup传递
Android事件传递(四)：总结篇
下面源码基于Android11 API30
上一篇文章分析了DOWN事件以后布局中每个对象的状态：
UP动作也是和DOWN一样从Activty开始到ViewGroup的dispatchTouchEvent方法，我们就从这里开始看，我们就用例子中的布局控件进行分析，先看DecorView ：
DecorView extends ... extends ViewGroup: @Override public boolean dispatchTouchEvent(MotionEvent ev) { ...... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { ✍ 当前动作为ACTION_UP但是在DecorView中 mFirstTouchTarget不为null,所以会进此判断 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } ✍到这里我们没有使用onInterceptTouchEvent拦截事件所以intercepted = false } else { intercepted = true; } if (intercepted || mFirstTouchTarget !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b15cb71af063d275298d7dd97c4d9145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/746085851f858fe6ce9841705461da42/" rel="bookmark">
			实体类排序（根据实体类中的某个字段进行排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，（实现 Comparable接口回重写一个方法--方法体就是排序规则）
@Data public class ListNumberingDTO implements Comparable&lt;ListNumberingDTO&gt;{ private String position; private String productname; private String maxusedcount; private String lifeusedcount; private String usedcount; private String reworkcount; private String prreworkcount; }
2，
//倒序 7 6 5 4 3 2 1
@Override public int compareTo(ListNumberingDTO o) { int i =Integer.parseInt(o.getPosition())-Integer.parseInt(this.position); return i; } 正序 1 2 3 4 5 6 7------改方法体--前后参数换个位置
@Override public int compareTo(ListNumberingDTO o) { int i =Integer.parseInt(this.position) -Integer.parseInt(o.getPosition()); return i; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/746085851f858fe6ce9841705461da42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0969b49caf7740810c54a39228b15f98/" rel="bookmark">
			【Java】数值拆分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【Java】数值拆分 题目 输入一个三位数，分别输出其个位、十位、百位
代码 package com.cxl.demo1; import java.util.Scanner; //数值拆分 public class Demo1_2 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print("请输入一个三位数："); int n = sc.nextInt(); int u= n % 10; //个位 int d = n / 10 % 10; //十位 int h = n / 100; System.out.println("数"+n+"个位为："+u); System.out.println("数"+n+"十位为："+d); System.out.println("数"+n+"百位为："+h); } } 运行效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cdf6dbeb9359263f18efab84abb5c0d/" rel="bookmark">
			菜鸟教程基于jQuery实现粒子效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;html&gt; &lt;head&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style=""&gt; &lt;div id="jsi-particle-container" class="container"&gt;&lt;canvas width="452" height="383"&gt;&lt;/canvas&gt;&lt;/div&gt; &lt;style&gt; html,body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; } .container{ width: 100％; height: 100%; margin: 0; padding: 0; background-color: #000000; } &lt;/style&gt; &lt;script&gt; var RENDERER = { PARTICLE_COUNT : 1000, // 数量 PARTICLE_RADIUS : 1, // 粒子半径 MAX_ROTATION_ANGLE : Math.PI / 60, // 最大旋转角度 TRANSLATION_COUNT : 500, // 控制了时间 init : function(strategy){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cdf6dbeb9359263f18efab84abb5c0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8643eff5017fdf1eef15128ce3298d99/" rel="bookmark">
			安装mysql时的修改初始密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装mysql时记住初始密码
例如我的：
2016-12-23T19:53:06.375910Z 1 [Note] A temporary password is generated for root@localhost: dOsJ&gt;ZWj/0)X
If you lose this password, please consult the section How to Reset the Root Password in the MySQL reference manual.
Mac OS X 配置环境变量
/etc/profile；/etc/bashrc 是针对系统所有用户的全局变量，只有root用户才能修改这两个文件，对一般用户来说是他们是只读的。一般用户要想修改它们，可以在命令前加sudo，意思是以Root身份执行，比如：sudo vi /etc/profile ，然后按照提示输入密码即可。
因此，对于一般用户而言，通常我们建议去修改~/.bash_profile来设置环境变量，它是用户级的设置，只对当前用户有效。
操作步骤:1、打开Terminal（终端）
2、输入：vi ~/.bash_profile
3、设置PATH：export PATH=/usr/local/mysql/bin:$PATH
4、输入：:wq //保存并退出vi
5、修改立即生效：source ~/.bash_profile
6、查看环境变量的值：echo $PATH
注意：1、~/.bash_profile中有个点
2、如果是新增环境变量或者是修改环境变量的值，都需要source一下才能立即生效。如果是删除一个环境变量，必须输入exit以logout当前shell，然后再重新打开一个新的shell并login才能生效。
//mysql初始密码修改
(1).进入/usr/local/mysql/bin,查看此目录下是否有mysql，见pic6。
(2).执行vim ~/.bash_profile
在该文件中添加mysql/bin的目录，见pic7：
PATH=$PATH:/usr/local/mysql/bin
添加完成后，按esc，然后输入wq保存。
最后在命令行输入source ~/.bash_profile
现在你就可以通过mysql -uroot -p登录mysql了，会让你输入密码，就是pic3上的 dOsJ&gt;ZWj/0)X
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8643eff5017fdf1eef15128ce3298d99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4083e4b652f030a512f7d6ff765e3444/" rel="bookmark">
			vue 使用高德JSapi 实现轨迹回放和海量点效果（点击显示详情提示窗口） 采用AMapLoader 和 AMapUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 注册高德开发者平台账号 （个人选择个人账户） 地址见 https://lbs.amap.com/api
第二步 在控制台中申请Key（输入key，选择web端，提交即可）
第三步 通过JSApi Loader 获取高德Api 来结合Vue
按 NPM 方式安装使用 Loader ：
npm i @amap/amap-jsapi-loader --save ​
第四步 Vue项目中示例
轨迹回放（巡航器）实例：
巡航效果图：
&lt;div id="container"&gt;&lt;/div&gt; data() { return { map: null, }; }, mounted() { this.initMap(); }, ！！！注意：使用的是Loader 使用时需要引入
import AMapLoader from "@amap/amap-jsapi-loader";
initMap() { AMapLoader.load({ key: "xxxxxxx", // 申请好的Web端开发者Key，首次调用 load 时必填 version: "2.0", // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 plugins: [ "AMap.ToolBar", "AMap.Scale", "AMap.HawkEye", "AMap.MapType", "AMap.Geolocation", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4083e4b652f030a512f7d6ff765e3444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41571f58eddbb0e8afdcfb7d41d3029d/" rel="bookmark">
			AUTO_TUNE 配置参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 AUTO_TUNE 配置参数来启用或禁用所有自动调整配置参数，这些参数的值不出现在 onconfig 文件中。
onconfig.std 值
AUTO_TUNE 1
值
0 = 禁用
1 = 启用
生效
编辑 onconfig 文件并重启数据库服务器之后。
当您通过运行 onmode -wf 命令在 onconfig 文件中动态地重置该值时。
当您通过运行 onmode -wm 命令重置内存中的该值时。
用法
如果在当前 onconfig 文件中未设置单独的自动调整配置参数，则数据库服务器为那个配 置参数使用在 AUTO_TUNE 配置参数中指定的值。
自动调整配置参数是：
⚫ AUTO_AIOVPS
⚫ AUTO_CKPTS
⚫ AUTO_LRU_TUNING
⚫ AUTO_READAHEAD
⚫ AUTO_REPREPARE
⚫ AUTO_STAT_MODE
如果在当前 onconfig 文件里设置自动调整配置参数，则数据库服务器使用 onconfig 文 件中的值。AUTO_TUNE 配置参数不更改那个值。
onconfig 文件在 %GBS_DATA%\conf 或 $GBS_DATA%/conf 目录中。
示例
示例1：假定有些自动调整配置参数未设置，其他配置参数有值：
AUTO_LRU_TUNING （值未设置）
AUTO_STAT_MODE （值未设置）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41571f58eddbb0e8afdcfb7d41d3029d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/257bd3c5100d41c583f1950dcbd10b0b/" rel="bookmark">
			ZooKeeper如何保证事务原子性?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先解答疑惑，题主对ZAB理解是正确的。为了便于描述，本文将事务理解为具有ACID的一组操作，一个ZooKeeper请求（例如：create）称之为提案。
ZAB协议是共识算法的一种，共识算法仅能保证单个提案在集群中达成共识，如果是多个提案要保证事务的话，需要在上层再做一次封装。ZAB被称为原子广播协议，也是做了这一层封装，即：multi命令。
multi命令让多个提案，要么同时成功，要么同时失败，所以要知道ZooKeeper怎么处理事务的，只需要关注multi命令的实现即可。
ZooKeeper对提案的协商，是以责任链的形式处理，下图是协商提案的责任链路，大家可以参考。
不难发现，客户端的请求，先到达PrepRequestProcessor，那么在PrepRequestProcessor一定可以找到对multi命令的特殊操作。
以下代码为PrepRequestProcessor#pRequestHelper，我省略掉了try-catch和其他无关代码，在处理multi请求时，ZooKeeper会先遍历multiRequest，把每个元素当做一个单独的提案调用pRequest2Txn()方法来协商，当某个提案协商发生异常时，ZooKeeper会调用rollbackPendingChanges()回滚正在执行中的提案。
// PrepRequestProcessor private void pRequestHelper(Request request) throws RequestProcessorException { switch (request.type) { case OpCode.multi: MultiOperationRecord multiRequest = new MultiOperationRecord(); try { ByteBufferInputStream.byteBuffer2Record(request.request, multiRequest); } catch (IOException e) { request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(), Time.currentWallTime(), OpCode.multi)); throw e; } List&lt;Txn&gt; txns = new ArrayList&lt;Txn&gt;(); long zxid = zks.getNextZxid(); KeeperException ke = null; Map&lt;String, ChangeRecord&gt; pendingChanges = getPendingChanges(multiRequest); request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), request.type)); for (Op op : multiRequest) { Record subrequest = op.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/257bd3c5100d41c583f1950dcbd10b0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bf887d54de46bbbfd6de9a4e4c692f/" rel="bookmark">
			c语言入门级小游戏·飞机（1.0版）| 激发你的编程兴趣（50~100行代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
制作一个可移动的飞机
发射激光
设置一个可击中的障碍物
完整代码
声明：本游戏参考《c语言课程设计与游戏开发实践教程》。
先来放一个效果图
怎么样，真的是新手级别吧？
（效果视频c语言练习草稿_game1.2.5飞机-CSDN直播）
可以通过wasd四个键控制飞机的移动，按空格键可以发射激光击中前方的障碍物*，击中后障碍物消失。 下面来看看如何制作吧
制作一个可移动的飞机 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;conio.h&gt; int main() {int x=15; int y=5; int i,n; while(1) //意思是死循环 { system("cls"); //清屏函数 for(i=0;i&lt;y;i++) printf("\n"); //输出飞机上面的空行 for(n=0;n&lt;x;n++) printf(" "); //输出飞机左侧的空格 printf(" *\n"); //输出飞机头部 for(n=0;n&lt;x;n++) printf(" "); //输出飞机身体部分左侧的空格 printf("*---*\n"); //因为飞机头部输出后有回车，所以飞机身体已经在下一行 for(n=0;n&lt;x;n++) printf(" "); //输出飞机尾巴部分左侧的空格 printf(" +-+ \n"); ... ...未完待续 以上代码可以输出一个完整的飞机图案，但是飞机还不能自由移动。我们本来可以使用scanf函数输入来实现控制飞机移动：if按某个键，x或者y就会+1或者-1。但是，使用scanf还要按下回车键才能使飞机移动，这样玩自然很不爽。所以这里我们使用一个新的函数getch（）。getch函数：该函数来自 &lt;conio.h&gt;函数库，因此函数头文件需要加上#include &lt;conio.h&gt;。只接收单个字符，接受单个字符之后不需要回车键就可以返回值，能让飞机直接移动。我们把这个函数应用到后续代码中 ... ...续接上方代码 char move; move=getch(); //注意getch函数的使用 if(move=='a') //注意是==不是= x--; //就是x-1的意思，实现让飞机左移 if(move=='d') x++; if(move=='w') y--; if(move=='s') y++; } //这些代码都在while(1)内 } 现在这个飞机可以实现自由移动了！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51bf887d54de46bbbfd6de9a4e4c692f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d9435887b5cda3cb110ef1d713d1fd9/" rel="bookmark">
			通过VS下载的NuGet包，如何修改其下载存放路径？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 优质资源分享 🚀 学习路线指引（点击解锁）知识定位人群定位🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。💛Python量化交易实战💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统 一、了解NuGet包的默认存放路径 我们通过NuGet包管理器下载的引用包，默认是存放在C盘的，存储路径一般是：
C:\Users\{系统用户名}\.nuget\packages 二、为什么需要修改NuGet包的默认存放路径？ 最直接的答案便是——节省C盘存储资源，减缓C盘飚红速度。
我们都知道，C盘的存储资源是有限的，而随着我们开发的项目越来越多，所引用的NuGet包自然而然也是越来越多。如果我们不做清理，这些文件会一直占据C盘的存储空间，让本就不富裕的C盘雪上加霜，而我们定时清理的话，下一次打开项目时会出现引用丢失找不到的情况，或者VS又重新下载引用包文件，简直是费时费力不讨好。
这时就有小伙伴要问了，我们能不能把下载的NuGet包存放在C盘之外的其他盘中吗？答案是当然可以。
三、更改下载的NuGet包存储位置 1、根据下述文件路径，找到一个名为“NuGet.Config”的文件，或者通过搜索，直接查找该文件。
C:\Users\{系统用户名}\AppData\Roaming\NuGet 2、打开“NuGet.Config”这个文件，我们可以看到原始的文件内容如下所示：
xml version="1.0" encoding="utf-8"? &lt;configuration&gt; &lt;packageSources&gt; &lt;add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" /&gt; packageSources&gt; configuration&gt; 3、将其内容替换为以下内容并保存：
xml version="1.0" encoding="utf-8"? &lt;configuration&gt; &lt;packageSources&gt; &lt;add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" /&gt; packageSources&gt; &lt;config&gt; &lt;add key="globalPackagesFolder" value="你想要NuGet包存放的新路径" /&gt; &lt;add key="repositoryPath" value="你想要NuGet包存放的新路径" /&gt; config&gt; configuration&gt; 四、修改VS离线包引用地址 1、根据下述文件路径，找到一个名为“Microsoft.VisualStudio.Offline.config”的文件，或者通过搜索，直接查找该文件。
C:\Program Files (x86)\NuGet\Config 2、打开“Microsoft.VisualStudio.Offline.config”这个文件，我们可以看到原始的文件内容如下所示：
xml version="1.0" encoding="utf-8"? &lt;configuration&gt; &lt;packageSources&gt; &lt;add key="Microsoft Visual Studio Offline Packages"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d9435887b5cda3cb110ef1d713d1fd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f4f9630f1bf84d1a571b8ba8aaf64c/" rel="bookmark">
			使用sizeof()计算内存大小，所踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题出现场景
软件在运行过程中，发现底层回调上来的字符串数据，会被截断。
2.问题原因
底层回调数据，经调试数据是完整的。问题出现在客户端软件，并且大概率是字符串拷贝出现的问题。因此找到几处对回调数据拷贝的操作，发现有一处拷贝，使用了sizeof计算字符串长度。问题可能出现在这个计算上，于是，我单独使用demo确认这个计算的结果，结果发现，当我使用未赋值变量进行长度计算时，结果都是32，但是我将变量赋值后进行计算，结果为字符串长度。可以确实是这里的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494e09040524aa3daee9475a36842501/" rel="bookmark">
			YOLOv5训练时出现Corrupt JPEG data: 2 extraneous bytes before marker 0xd9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在colab使用yolov5训练数据集时，出现以下错误，但不影响训练结果
Corrupt JPEG data: 2 extraneous bytes before marker 0xd9 解决方法： 在utils/dateset.py文件中加入以下代码：
if im.format.lower() in ('jpg', 'jpeg'): with open(im_file, 'rb') as f: f.seek(-2, 2) assert f.read() == b'\xff\xd9', 'corrupted JPEG' 加入位置：在此代码段之后复制上述代码
def verify_image_label(args): # Verify one image-label pair im_file, lb_file, prefix = args nm, nf, ne, nc = 0, 0, 0, 0 # number missing, found, empty, corrupt try: # verify images im = Image.open(im_file) im.verify() # PIL verify shape = exif_size(im) # image size assert (shape[0] &gt; 9) &amp; (shape[1] &gt; 9), f'image size {shape} &lt;10 pixels' assert im.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/494e09040524aa3daee9475a36842501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e124396f0835ffe6c4413b4e50420417/" rel="bookmark">
			Java面向对象8——抽象类和抽象方法（知识点&#43;使用方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象类和抽象方法 一、前言二、抽象方法1.定义2.简单记忆方法3.代码格式4.使用说明 三、抽象类1.定义2.代码格式3.使用说明4.注意点 四、小练习1.题目2.分析3.代码实现1️⃣父类2️⃣Frog类3️⃣Dog类4️⃣Rabbit类5️⃣测试类 五、结语 一、前言 本文会梳理有关抽象类和抽象方法的知识点，这会运用在接口中，而接口是在实际开发中非常重要的，所以知识点非常重要
二、抽象方法 1.定义 抽象方法就是以abstract修饰的方法，这种方法只声明返回的数据类型、方法名称和所需的参数，没有方法体，也就是说抽象方法只需要声明而不需要实现
2.简单记忆方法 概念听起来很复杂难懂，那我们举例说明
比如有三个人A、B、C的职业都是程序员，到了返点都要吃饭，但是每个人吃的东西不一样，有人吃爱心便当，有人吃盒饭，有人吃快餐，那么他们都有共同的方法：吃，并且他们都可以同属于一个父类：程序员，那么我们可以把共同的方法吃抽取到父类（程序员）中，由于子类（ABC三个人）吃的东西不相同，即方法体不同，所以要把该方法定义为抽象方法
3.代码格式 修饰符 abstract 返回值类型 方法名 (参数列表)； 例如
public abstract void eat();] 4.使用说明 如果要继承父类中的抽象方法，则必须重写该方法，否则就让子类也变为抽象类
示例：
如果想要偷懒的话，点击 Alt+Enter来查看解决方法
我们在这里选择第二个，实现方法
一个是父类中的抽象方法，另一个一个是接口（这个下一篇文章中会讲到）我们只需要全选然后点击回车就会自动帮我们生成重写的方法了
此时我们只要改写方法体即可
三、抽象类 1.定义 当某一个类中存在抽象方法，那么这个类就要被定义为抽象类
2.代码格式 abstract class 类名 { } 例如：
abstract class Student { } 3.使用说明 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类
4.注意点 抽象类不能实例化
抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。
当我们在一个非抽象的类中写抽象方法时，会报错
但是在抽象类中写非抽象方法，又不会报错
抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。
四、小练习 1.题目 属性行为青蛙Frog名字、年龄（1）吃虫子、喝水狗Dog名字、年龄（2）吃骨头、喝水兔子名字、年龄（3）吃胡萝卜、喝水 2.分析 eat是抽象方法，吃的东西不同，而drink都是喝水，所以不用使得该方法变为抽象方法
3.代码实现 1️⃣父类 public abstract class Animal { private String name; private int age; public Animal(String name, int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e124396f0835ffe6c4413b4e50420417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86c0ee373b7e655b7d235f20b992149/" rel="bookmark">
			java当中的重写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.什么是重写二.重写的要求三.重写的作用 一.什么是重写 在子类中创建了一个与父类中名称相同、返回值类型相同、参数列表的方法相同，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写（override），又称为方法覆盖、方法复写。
二.重写的要求 1.重写是只能在继承当中用到的
2.要求父类与子类的方法名，形参列表相同
3.子类重写方法的权限修饰符要不小于父类的权限修饰符
class Person{ public void eat(){ System.out.println("吃饭！"); } } class Student extends Person{ protected void eat(){ System.out.println("吃好的！"); } } public class Test { public static void main(String[] args) { Student stu = new Student(); stu.eat(); } } 这里我重写父类方法eat()的时候，我将子类的修饰限定符调的比父类低了，然后造成了无法覆盖问题
4.子类不能重写父类中private的方法
lass Person{ public void walk(){ System.out.println("走路"); show(); } private void show(){ System.out.println("展示父类"); } } class Student extends Person{ public void show(){ System.out.println("展示子类"); } } public class Test { public static void main(String[] args){ Student stu = new Student(); stu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e86c0ee373b7e655b7d235f20b992149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40e491701bd6d42633045d5e5691115/" rel="bookmark">
			Spring Cache使用Redis自定义缓存key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Spring Cache 从spring 3.1版本开始，提供了一种透明的方式来为现有的spring 应用添加cache。在应用层面与后端存储之间，提供了一层抽象，这层抽象目的在于封装各种可插拔的后端存储( ehcache guava redis)，最小化因为缓存给现有业务代码带来的侵入。
核心抽象主要体现在两个接口上
org.springframework.cache.cache
org.springframework.cache.cachemanager
cache代表缓存本身，包含缓存的常用操作：增加、删除、读取等。
CacheManager 是 Spring 各种缓存的抽象接口。抽象的意义在于屏蔽实现细节的差异和提供扩展性，这一层cache的抽象解耦了缓存的使用和缓存的后端存储，这样后续可以方便的更换后端存储。
Spring 支持的常用 CacheManager 如下：
CacheManager描述SimpleCacheManager使用简单的 Collection 来存储缓存ConcurrentMapCacheManager使用 java.util.ConcurrentHashMap 来实现缓存NoOpCacheManager仅测试用，不会实际存储缓存EhCacheCacheManger使用EhCache作为缓存技术。EhCache 是一个纯 Java 的进程内缓存框架，特点快速、精干，是 Hibernate 中默认的 CacheProvider，也是 Java 领域应用最为广泛的缓存JCacheCacheManager支持JCache（JSR-107）标准的实现作为缓存技术CaffeineCacheManager使用 Caffeine 作为缓存技术。用于取代 Guava 缓存技术。RedisCacheManager使用Redis作为缓存技术HazelcastCacheManager使用Hazelcast作为缓存技术CompositeCacheManager用于组合 CacheManager，可以从多个 CacheManager 中轮询得到相应的缓存 二、核心注解 Spring Cache 提供了 @Cacheable 、@CachePut 、@CacheEvict 、@Caching 等注解
1、 @Cacheable 缓存数据或者获取缓存数据
属性值如下：
属性/方法名解释value缓存名，必填，它指定了你的缓存存放在哪块命名空间cacheNames与 value 差不多，二选一即可key可选属性，可以使用 SpEL 标签自定义缓存的keykeyGeneratorkey的生成器。key/keyGenerator二选一使用cacheManager指定缓存管理器cacheResolver指定获取解析器condition条件符合则缓存unless条件符合则不缓存sync是否使用异步模式，默认为false 2、@CachePut 修改缓存数据。
属性/方法名解释value缓存名，必填，它指定了你的缓存存放在哪块命名空间cacheNames与 value 差不多，二选一即可key可选属性，可以使用 SpEL 标签自定义缓存的keykeyGeneratorkey的生成器。key/keyGenerator二选一使用cacheManager指定缓存管理器cacheResolver指定获取解析器condition条件符合则缓存unless条件符合则不缓存 3、@EnableCaching 开启缓存功能，一般放在启动类上
4、@CacheEvict 清空缓存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c40e491701bd6d42633045d5e5691115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0bdadeafab38391ebd6f468a09be2bd/" rel="bookmark">
			用户信息管理系统项目测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 测试用例设计
2. 自动化测试
1. 测试用例设计 对系统的功能性、界面性、兼容性、易用性、安全性、性能进行测试。
2. 自动化测试 使用 Unittes 框架对系统中的登录、添加用户信息、删除用户信息、换页功能、查询功能进行测试，并生成测试报告。 测试报告链接：
测试报告http://localhost:63343/hwhw/usermanager/resultReport/2022-50-06-18%2050%2011-resultReport.html?_ijt=slr84vv528j0gd3j58hslddqal
WebDriver常用的API： from selenium import webdriver import unittest import time from selenium.common.exceptions import NoAlertPresentException import os class testCase1(unittest.TestCase): # 有setUp的部分，默认执行 def setUp(self): self.driver = webdriver.Chrome() self.url = "http://124.222.237.227:8085/login.html" self.driver.get(self.url) self.driver.maximize_window() time.sleep(3) # tearDown，在test_XXX方法执行完之后默认会调用 def tearDown(self): self.driver.quit() # 有test_XXX的部分，默认执行 # @unittest.skip("skipping") def test_baidu1(self): driver=self.driver # 用id来定位，登录 driver.find_element_by_id("loginname").send_keys("admin") driver.find_element_by_id("password").send_keys("admin") time.sleep(4) driver.find_element_by_id("submit").click() time.sleep(4) #@unittest.skip("skipping") def test_baidu2(self): driver=self.driver driver.find_element_by_id("loginname").send_keys("admin") driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0bdadeafab38391ebd6f468a09be2bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/479a0b9d037c388dc0c5574f82f9ad83/" rel="bookmark">
			#VirtualBox虚拟机磁盘扩容#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景，在linux安装运行docker容器的时候发现docker所在的安装目录硬盘已经满了，提示错误
硬盘不足
解决方法：扩容
步骤如下：
1：添加硬盘
主要需要先关闭虚拟机才能添加硬盘
2：启动虚拟机
3：输入命令：lsblk
看到我们刚刚创建的物理磁盘sdc
4:输入命令：df -h查看原本磁盘可用空间
5、输入命令：ls /dev/sd* 查看磁盘编号。
6、输入命令：pvcreate /dev/sdb 创建pv 7、把pv加入vg中，相当于扩充vg的大小
输入命令:vgs查看vg组
8、输入命令：vgextend centos /dev/sdb 扩展vg.
由于硬盘使用100%，添加逻辑券会有错误
Couldn’t create temporary archive name.
解决方法：
暂时删除无用文件，腾出一部分空间
9、输入命令：lvs.
虽然把vg扩展了，但是lv还没扩展。 10、输入命令：lvextend -L + 49.9G /dev/mapper/centos-root扩展lv
11、输入命令：xfs_growfs /dev/mapper/centos-root使系统重新读取大小。 12、输入命令：df -h重复查看磁盘空间。 扩展成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e08833f4e7306415d97c3bd9a17b53/" rel="bookmark">
			UE5的Lumen和传统光线追踪对比，哪个更好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Epic 的 Unreal Engine 4 是上一代最流行的游戏引擎之一。它被 EA、Ubisoft 和 Microsoft 等 AAA 巨头以及大量独立工作室广泛使用。凭借虚幻引擎 5 及其 Lumen 和 Nanite 技术，Epic 正在寻求扩大其在视频游戏行业的主导地位。
在这篇文章中，我们将介绍 Lumen，这是虚幻引擎 5 使用的全局照明解决方案，可在预算内为下一代游戏带来逼真的照明。我们将 Lumen 与传统的光线追踪进行比较，并分析两者在质量和性能方面的差异。
什么是全局照明？ 简而言之，全局照明是通过计算屏幕内外光源发出的光（通过近似或追踪其路径）来照亮或照亮场景的过程。通过光线和路径追踪，光线从这些光源投射，到达场景中的各种物体并照亮它们。根据遇到的对象的性质，光线的行为会有所不同。例如，有光泽（闪亮）的物体会反射光线，而不透明的物体会简单地阻挡它并将其重定向到其他地方。物体在不同方向上对光线的重定向称为间接或漫射照明，而重定向的光线称为漫射光线。
光线追踪全局照明 (RTGI) 然后这些间接或漫射光线充当新投射的光线，进一步撞击其他对象并在此过程中照亮它们，而对象将它们重定向基本上充当光源。当光线最终到达相机（你的眼睛）时，它收集的信息用于确定场景的照明。
在大多数情况下，光线的颜色由反射它的像素的颜色决定。为了节省性能，直接照射到屏幕（您的眼睛）的光线（颜色、强度等数据）使用复杂的算法进行计算，而其余的漫射光线则使用更简单、不太复杂的方程来计算。
所以，现在您可能想知道光线是如何在场景中投射的，以及如何确定每个场景的光线数。嗯，这是通过探针完成的，这些探针基本上是开发人员在运行前放置在场景中的光源。每个探头都充当点光源，投射光线并照亮场景。每个探头可以放射状地投射一条或多条射线。
什么是光线追踪以及它是如何工作的？NVIDIA 的 RTX GPU 值得吗？ 这些探测器投射的光线被追踪、着色，并且辐照度和几何距离等数据被存储并用于计算场景的最终照明。在最初的光线追踪游戏中，大多数开发人员使用一个（或两个）光探针来计算漫反射光照。在 Metro Exodus 中，这是太阳和天空的纹理。在增强版中，这扩展到了 256 个光源或探头。因此，总的来说，您有256 个光源，加上来自太阳和天空的光线都用于计算每个像素的光照。1080p 显示器有 200 万像素，1440p 有 400 万像素，4K 有 800 万像素！
为了确保现代硬件能够真正运行游戏，开发人员使用网格单元或集群来划分场景。然后类似于屏幕空间效果，范围内（网格中）的光探针用于计算场景的照明，主要区别在于在前者的情况下，屏幕空间被划分为多个部分（取决于它们在 Z 缓冲区中的位置），而在后者的情况下，游戏世界是分区的，避免了类似的覆盖问题。
另一项优化涉及累积来自先前帧的光线并将它们用于额外的漫反射光反弹，就像时间放大一样。这用于生成照明网格，然后可以在连续帧上重复使用，从而允许几乎无限的光线反弹。您实际上是在多个帧上临时投射漫射光线，以减少性能影响并使该方法更适合实时使用。由于漫射光线的影响是微妙的（但在光线不足的场景中很明显），它不会受到通常与时间渲染技术相关的问题的影响。
虚幻引擎 5：Lumen与光线追踪 Lumen 基于光线追踪，尽管它是一种更优化的混合形式，以允许在不同的图形架构中更广泛地采用，而无需拥有 1,000 美元的 GPU。
Lumen 是虚幻引擎 5 的全新全动态全局照明和反射系统，专为下一代游戏机而设计。Lumen 是虚幻引擎 5 中默认的全局照明和反射系统。它在从毫米到公里的大型详细环境中渲染具有无限反弹和间接镜面反射的漫反射。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e08833f4e7306415d97c3bd9a17b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d88871d4bf405f44f16d3bd78babc3f5/" rel="bookmark">
			pc网站和手机端h5网站开发接入微信支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关支付类开发，现在比以前要简单很多了，微信和支付宝两大支付巨头早已经给出了非常详细的接入文档，并且迭代了好多版本，但在实际开发中其实文档的可读性还是有些磕磕绊绊的，而且也有一些坑需要注意。以微信支付来说，其实大多数商户的接入方式，文档里还不是很直白，引导也有些混乱，我也是搞了一段时间才摸清楚里面的大致逻辑。
1. 准备工作 首先需要公司以商户身份在微信支付中开通账号，涉及到上传公司的一些营业执照，法人身份等信息，审核通过后即可开通。后台界面如下：
2. 功能介绍 交易中心是查看你的微信支付的订单信息的，你的系统接入微信支付后，你系统里的订单和微信支付的订单有个1对1的对应关系，你的应用用户以后凡是支付过的订单都可以在这里面查看，核对。
账户中心，在这里公司管理员可以给公司各种角色，比如开发人员，财务，客服等员工开通账号并配置权限，而且还有支付安全信息的配置，比如密钥，证书这些。
营销中心，可以给你的应用配置红包，满减，消费券等活动参数，小型应用可以不看。
产品中心，这个界面是员工的主要操作台，管理员给公司各个角色配置的功能，都在这里操作，比如我作为开发人员，财务，运营，在这里都能看到我可以操作的功能模块。
数据中心，主要用来排查错误异常的。
本文以开发者角度来科普微信支付怎么接入，技术栈为angularjs+nodejs+mongo
3. 开发接入 我开发的系统是pc网站和h5手机端接入微信支付，需求很简单：pc端用户选购完产品点击支付，弹出二维码并设置倒计时时间，用户扫码完成支付，类似12306pc网站那种。h5手机站需要在用户点击支付时候，唤起微信app进行支付操作。（网站只接入微信支付，不接入微信登录）
用户支付的钱先到我们公司的总账户，然后公司对公分润给供应商。
3.1 管理员开通权限
管理员需要在账户中心给开发人员开通：native支付，h5支付这三个功能。pc端网站生成二维码可以用native支付，手机端h5站就选择h5支付。
3.2 关键参数配置
要接入微信支付并调用api接口，以下几个关键参数要在开发前进行配置。
mchid和appid
mchid就是商户号，只要注册通过成为商户，登陆后右上角会自动显示你的商户号。
appid是你的应用id，怎么理解呢，就是你要接入微信支付这个功能前，必须注册一个微信生态里的应用，才能使用微信支付。这些应用可以是服务号，订阅号，小程序等等，具体解释可以看这里：https://kf.qq.com/faq/1801116VJfua1801113QVNVz.html
感觉appid这个逻辑还是有些强制性，微信强制开发者遵循他自身的生态闭环，比如我们要开发的这个平台，用的是我们公司之前的一个服务号，但是这个服务号跟系统其实没啥联系。
API证书和私钥, Apiv3密钥，serial_no 这三个概念容易搞混，我大白话解释一下，你想把你的系统接入微信支付，微信官方得给你一个授权的身份，你只有这个身份合法了，调用人家接口人家才认得你，不然都按非法请求。API证书和私钥就类似于你主动调用微信接口使用到的公私钥对，获取方式和概念解释如下：
https://kf.qq.com/faq/161222NneAJf161222U7fARv.html
私钥和证书-接口规则 | 微信支付商户平台文档中心
利用证书工具最终会生成apiclient_cert.pem，apiclient_key.pem这两个文件，可以简单理解这两个文件就是证书和私钥。调用时候需要在http请求头设置一个Authorization参数，微信端就是来通过解析Authorization的值判断你这个请求是否合法。
Authorization参数怎么生成，具体方法可以看签名生成-接口规则 | 微信支付商户平台文档中心，
上面解释了api证书和私钥，那另外的Apiv3密钥是什么，当微信端回调你的接口时候，发过来加密的请求，你要用的就是Apiv3密钥进行解密。再直白点说两者区别，当你调用微信接口时候用到的是api证书和私钥加签，当微信端回调你的接口时候，你用Apiv3密钥解签。微信生成订单接口支持回调的，就是说支付成功后微信可以回调我的一个接口修改这个订单状态，但是文档里说可能有延迟以及支付成功但始终无回调的情况发生，因此在我的开发中对于订单状态的修改，我是主动去查询微信端接口的，而不是依赖于微信回调，所以在我的系统中Apiv3密钥就没有用到。
serial_no是商户api证书序列号，发送请求时候放在header里的Wechatpay-Serial就行了。
4. 代码相关 微信支付api相关的接口调用文档在微信支付-开发者文档，注意微信目前文档里涉及到v2和v3两个版本，目前接入一般直接选择最新的v3版本，所以看文档要看v3版本的文档。我在实际开发中查看微信官方文档时，里面有些跳转混乱，会在v2和v3来回跳，记住看到的文档里url包含/v3就是最新文档，比如下面这个：
我后台用的是node，但微信api接口只有java，.net, python示例（为啥不支持node），我后来在社区里找到了两个支持node版本的npm包，wechatpay-node-v3和wxpay-v3，前者比较好用。项目git地址在GitHub - klover2/wechatpay-node-v3-ts: 微信支付v3
可以通过组装http调用，如下：
var WxPay = require('wechatpay-node-v3'); const pay = new WxPay({ appid: config.appid, mchid: config.mchid, publicKey: fs.readFileSync(__dirname + "/wxkey/" + 'apiclient_cert.pem'), // 公钥 privateKey: fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d88871d4bf405f44f16d3bd78babc3f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f52dacc19e5d475f765b6a39c02ec5c/" rel="bookmark">
			容器编排之战——kubernetes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、kubernetes简介
1、基本概念
1、传统的应用部署方式
2、新的应用部署方式（部署容器）
3、容器编排工具中的战斗机--------Kubernetes
2、Kubernetes核心概念
3、Kubernetes架构和组件
1、Master节点
2、Node节点
3、组件之间的通信
三、常用镜像仓库
四、Kubernetes集群部署方式
二进制方式部署k8s集群 1、部署Etcd集群
2、部署Flannel网络
3、在Master节点部署组件
4、在Node节点部署组件
kubeadm方式部署k8s集群
1、获取镜像
2、所有节点安装docker
3、禁用swap分区
4、所有节点安装kubeadm和kubelet
5、配置启动kubelet（所有节点）
6、配置master节点
7、所有node节点操作
8、配置使用网络插件
错误整理
五、部署Harbor仓库
六、集群基本操作--查看集群信息
查看node的详细信息
创建命名空间
七、发布第一个容器化应用
八、YAML文件语法解析
九、Pod API属性详解
1、Pod调度
1、指定node节点的名称（nodeName）
2、指定node标签（nodeSelector）
2、域名解析
3、进程共享
十、容器属性
1、Pod 里最重要的字段"Containers"：
2、k8s 对 Container 的定义，和 Docker 相比并没有什么太大区别。
3、ImagePullPolicy属性
4、Pod的生命周期
1、简介
2、生命周期
3、案例
4、扩展
十一、Projected Volume
1、什么是Projected Volume？
2、Secret详解
1、命令方式创建secret
2、yaml方式创建Secret：
3、使用secret
4、映射secret key到指定的路径
5、被挂载的secret内容自动更新
6、以环境变量的形式使用Secret
7、实验：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f52dacc19e5d475f765b6a39c02ec5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e7cbc2d9285a1e5239130cec163cbe/" rel="bookmark">
			【C语言练习】四个整数中找出最大的一个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《啊哈C语言》这本书上的练习题：
从键盘任意读入四个整数，让计算机从中找出最大的一个。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /* 从四个整数中找出最大的数 */ int main() { int a, b, c, d, e; printf("请输入四个整数：\n"); scanf("%d %d %d %d", &amp;a, &amp;b, &amp;c, &amp;d); if (a &gt; b) e = a; else e = b; if (c &gt; e) e = c; if (d &gt; e) e = d; printf("四个整数中最大的数是%d\n"); system("pause"); return 0; } 这种方法其实就是冒泡排序，临近的两个数先比大小，胜出的赋值给变量e；然后再和第三个数比较，较大的赋值给变量e；再和第四个数比较，较大的赋值给变量e；最后输出变量e的值。
但是这个方法有个问题，如果输入的整数有很大的值，比如十位以上的数字，那么输出结果就不对。
是数据类型的问题吗？换成long试试 是不是声明变量的时候给变量定义的是int类型呢？换成长整型long是不是可以呢？
​ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /* 从四个整数中找出最大的数 */ int main() { long a, b, c, d, e; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05e7cbc2d9285a1e5239130cec163cbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dbf6f0fb6dde3b1695591a1b92c8678/" rel="bookmark">
			【亿信BI】esensoft亿信BI使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		esensoft亿信BI使用总结 1. 百分比2. 避免除以0导致的∞符号3. 页面显示 &amp; 参数的value和txt4. 日期格式5. GRID分析区表格6. 维显示代码值7. 浮动列计算8. 拆分浮动列9. 全连接 &amp; 指标 2022/9/6 周二
记录使用亿信BI制作报表时，常用的一些函数、格式等Tips。
1. 百分比 小数值需要转为百分比，在“显示表达式”这儿加一个函数 round(self.value*100,2)+‘%’
效果：
2. 避免除以0导致的∞符号 有时候做除法运算，有除数为0的情况，会出现∞无穷符号：
效果： 如果想避免出现∞无穷符号，可以用if条件 if(B3&gt;0,A3/B3,NULL)，让除数为0时结果不去计算，显示为空：
效果：
3. 页面显示 &amp; 参数的value和txt (1) 需要在分校区表格之外的地方显示文本内容，格式为 &lt;#=xxx#&gt; ，如下图的&lt;#=12345#&gt;
(2) 如果需要显示参数内容，就是 &lt;#=@paramname#&gt; ，比如我有个@date的参数，就用 &lt;#=@date#&gt;
(3) 参数有 值value 和 显示文本txt ，就比如日期这个参数来说，值和显示文本是有区别的，&lt;#=@date.value#&gt; 显示20220906，而 &lt;#=@date.txt#&gt; 则是文本形式的2022年09月06日，如果只写&lt;#=@date#&gt;就默认是value
效果：
4. 日期格式 有时候日期只精确到了年月日，但报表显示出来了后边的00:00:00
要去掉这些0，就在日期单元格的“显示表达式”处加一个函数 datetostr(self.txt,‘yyyy-mm-dd’)
效果：
5. GRID分析区表格 附加，如果我还想在外面显示最大的一个日期（右图），可以用上边第2点说过的&lt;#=xxx#&gt;在分析区表格外添加内容，用max函数算出最大日期，再用第3点中的datetostr函数把日期2022-09-02显示为2022年09月02日：
&lt;#=datetostr(max(GRID1.D2$),‘yyyy年mm月dd日’)#&gt;
效果：
其中的GRID1是分析区表格的代号，点表格左上角的十字方块会出来：
6. 维显示代码值 关联了维表的字段，在报表里会默认显示名称（如下图I列显示的就是具体内容），如果想让它仍然显示原来的代码值，可以在“显示表达式”中加一个 @id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dbf6f0fb6dde3b1695591a1b92c8678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ccddb90dca9aa31e6aef45534e5b97d/" rel="bookmark">
			浏览器的默认样式及去除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、reset
二、normalize
总结
前言 通常情况，浏览器都会为元素设置一些默认样式，默认样式的存在会影响到页面的布局，通常情况下编写网页时必须要去除浏览器的默认样式（PC端的页面）。
一、reset reset.css
/* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } 二、normalize 可以在github上下载normalize.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ccddb90dca9aa31e6aef45534e5b97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01fdc2c6b3dec779d8e2f38e742778fe/" rel="bookmark">
			burp与FoxyProxy抓包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、FoxyProxy 火狐浏览器中的代理插件，在火狐的扩展中下载
添加扩展后，进入选项添加代理地址
添加，此处的ip与端口配置，要在burp当中抓包使用
需要抓包的时候启用就可以了
二、burp Suite配置 新增Add将配置的代理放入监听
这里可以停用或监听接口
如果遇到了https的网站无法访问，则需要下载证书
浏览器 =》127.0.0.1:1234（你配置的代理地址）
下载证书
浏览器设置=》查找证书
查看证书并导入刚刚下载的证书即可访问https网站
（要求有Java环境，没有的要自行配置jdk）
jdk官网地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07f71e6d3c089ea793b3bf8e52d4def/" rel="bookmark">
			Jackson 序列化时忽略 null 或空字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们通过 Jackson 将某个对象转换成 JSON 字符串时，如果对象属性有很多我们不需要的 null 值，全部转换会浪费很大的空间，例如：
{ "id": 77, "number": 1, "title": "枫霜尽", "type": 0, "name": null, "age": null, "address": null } 转换之后结果如下：
{ "id": 77, "number": 1, "title": "枫霜尽", "type": 0 } 如果我们不需要上面 name、age 和 address 属性的 null 值，可以有如下两种方式：
在使用 @JsonInclude(JsonInclude.Include.NON_NULL) 注解
将该注解放在属性上，如果该属性为 null 则不参与序列化；
如果放在类上边,那对这个类的全部属性起作用
参数：
​ Include.Include.ALWAYS 默认，全部序列化
​ Include.NON_DEFAULT 属性为默认值不序列化
​ Include.NON_EMPTY 属性为空（“”）或者为 NULL 都不序列化
​ Include.NON_NULL 属性为 NULL 不序列化
在代码上对 ObjectMapper 对象进行设置，通过该方法对 ObjectMapper 对象进行设置，所有序列化的对象都将按改规则进行序列化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b07f71e6d3c089ea793b3bf8e52d4def/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f5c0f8986dc1c002180e7f3bff38a7/" rel="bookmark">
			vue美化登录页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue组件的名称是：Login.vue
背景图片的地址是：assets/img/background.jpeg &lt;template&gt; &lt;!-- 整体背景 --&gt; &lt;div class="login-wrap"&gt; &lt;!--输入框--&gt; &lt;div class="form-wrapper"&gt; &lt;div class="header"&gt; music manage &lt;/div&gt; &lt;div class="input-wrapper"&gt; &lt;div class="border-wrapper"&gt; &lt;input type="text" name="username" placeholder="username" class="border-item" autocomplete="off" /&gt; &lt;/div&gt; &lt;div class="border-wrapper"&gt; &lt;input type="password" name="password" placeholder="password" class="border-item" autocomplete="off" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="action"&gt; &lt;div class="btn"&gt;login&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt; .login-wrap { height: 100%; font-family: JetBrains Mono Medium; display: flex; align-items: center; justify-content: center; /* background-color: #0e92b3; */ background: url('../assets/img/background.jpeg'); background-size: 100% 100%; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f5c0f8986dc1c002180e7f3bff38a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fa3e705e2c7fe574b9aa3e99f61dd86/" rel="bookmark">
			setoolkit克隆网站并抓取账号密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 setoolkit简介setoolkit克隆站点遇到的问题 setoolkit简介 社会工程师工具包（The Social-Engineer Toolkit）是一个为社会工程设计的开源渗透测试框架。SET有许多自定义攻击向量，允许您快速地进行可信的攻击。SET是TrustedSec有限责任公司的产品，该公司是一家位于俄亥俄州克利夫兰的信息安全咨询公司。
此工具包中除了setoolkit还有seautomate和seproxy
setoolkit默认会安装在kali中，直接使用即可
setoolkit克隆站点 切换到root权限启动setoolkit，非root权限是启动不了的
选择 1 Social-Engineering Attacks （社会工程学攻击）
选择 2 Website Attack Vectors （网站攻击）
选择 3 Credential Harvester Attack Method （凭证收集攻击方法）
在这里有三种模式，1是使用模板，默认会有java、google、twitter的三个登录框可以直接使用；2是克隆站点；3是自定义导入
这里选择2
设置IP或域名地址，这里默认为kali的IP地址，按回车默认执行，执行完毕后需要输入要克隆的网址
这里随机找到一个网址，复制进去进行克隆，按回车执行
打开ip地址，即可看到克隆的站点
尝试登陆，可在命令行窗口看到登陆的账号密码
遇到的问题 本来想克隆qq邮箱或者qq空间的登录页面，但是克隆之后，会由本地的ip地址重定向到真正的qq邮箱的站点，可能是做了防克隆，真正想实现qq钓鱼应该是需要自己导入qq邮箱登录的页面，并不能直接使用克隆功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dce37c3a12b9cfbec304542ecff3d14/" rel="bookmark">
			网络编程介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
软件开发架构
网络编程简介
OSI七层协议
各层特征
1.物理链接层
2.数据链路层
3.网络层
4.传输层
1. PORT协议
IP+PORT
网址URL: 统一资源定位符
2.TCP协议与UDP协议
5.应用层
专业名词解释
1. 交换机
2. 以太网通信[mac通信]
3.局域网
4.路由器
5.三次握手与四次挥手
TCP 协议比UDP协议更加可靠的原因
软件开发架构 软件开发架构即编写项目之前需要遵循的代码层面上的规范.
软件开发架构分为C/S架构(Client server) 和 B/S架构(Broswer Server)两种.
cs架构即客户端, 类似于微信,淘宝一样的手机/pc终端app, 需要用户下载后才能使用.但是其内容及需要可以高度定制化, 用户体验感很好. bs架构即浏览器端(网页端),它不需要下载就可以使用, 但是无法实现个性化定制服务.
不过随着时代和技术的发展, 现在的趋势是两者结合使用-----支付宝终端可以跳转到淘宝页面,微信小程序可以点餐买药等.
两者结合使用给人们的生活带来了更为便捷舒适的生活方式. 网络编程简介 网络编程是基于互联网编写代码,其本质就是为了解决计算机之间远程数据的交互.达到程序远程数据交互的目的, 网络编程的发展经历了几个早期阶段:
有线电话 &gt;&gt;&gt; 大屁股电脑 &gt;&gt;&gt; 笔记本电脑
[电话线 &gt;&gt;&gt; 网线 &gt;&gt;&gt; 网卡]
其共同点为: 必须有物理连接介质才可以达到数据(信息)远程交互的目的
OSI七层协议 OSI七层协议规定了计算机涉及到远程数据交互的时候必须要经过的流程/部件
所有的计算机在涉及到网络传输这块必须要有相同的零部件
OSI七层协议分别为: 应用层,表示层, 会话层,传输层,网络层,数据链路层和物理链接层[应表会传网数物],每一层都有各自的功能和规范
传输数据时, 发送信息数据时,OSI七层协议从上往下走, 接受数据信息的时候OSI七层协议从下往上走. 各层特征 1.物理链接层 保证物理连接介质的条件,传递电信号(主要研究插网线的情况)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dce37c3a12b9cfbec304542ecff3d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/990f0318401f762f1e43c8483c183d16/" rel="bookmark">
			法研杯(CAIL 2019)相似案例匹配任务问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		法研杯(CAIL 2019)相似案例匹配任务问题汇总 参考资料：https://github.com/padeoe/cail2019，在大佬的方案基础上，自己独自实现的过程中遇到的问题梳理如下：
docker: Error response from daemon: Unknown runtime specified nvidia.
See ‘docker run --help’. 首先确保安装nvidia-docker
yum install nvidia-docker2 或者 sudo apt install nvidia-docker2 然后/etc/docker/daemon.json修改如下：
{ "registry-mirrors": ["https://f1z25q5p.mirror.aliyuncs.com"], "runtimes": { "nvidia": { "path": "nvidia-container-runtime", "runtimeArgs": [] } } } 最后重启
sudo systemctl daemon-reload
sudo systemctl retstart docker
docker pull 拉取镜像 unauthorized: authentication required
解决方案：
docker login
同步时间
yum install ntp ntpdate pool.ntp.org Jupyter notebook 配置 Jupyter notebook配置
ModuleNotFoundError: No module named ‘transformers’ 这种情况出现的原因可能就是指定安装的transformers的版本太低，现在一般使用3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/990f0318401f762f1e43c8483c183d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0804f2951f7198b37ebc7de7b4eab195/" rel="bookmark">
			关于ABAP选择屏幕部分，定义框架与不定义框架两种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://dxldev.blog.csdn.net/article/details/121419141?spm=1001.2014.3001.5502
我们要实现的功能有：
1.单值选择
2.区间选择
3.复选框
4.单选框
第一种方法： 定义框架
SELECTION-SCREEN BEGIN OF BLOCK blc_001 WITH FRAME TITLE TEXT-001. parameters:	p_bukrs LIKE ekko-bukrs.	"单值输入，参照数据表字段 SELECT-OPTIONS s_ebeln for ekko-ebeln.	"区间输入 需要提前声明表TABLES：ekko. SELECTION-SCREEN END OF BLOCK blc_001. *	定义不用框架 SELECTION-SCREEN BEGIN OF BLOCK blc_002 WITH FRAME TITLE TEXT-002. PARAMETERS: p_flag as CHECKBOX DEFAULT 'X' .	"复选框 DEFAULT 'X' 默认勾选 SELECTION-SCREEN SKIP. PARAMETERS:	p_flag1 RA 选择屏幕开发 SAP的屏幕开发一般分为两种
一种是通过SAP ABAP语法创建屏幕元素，称之为选择屏幕（我们现在学习这种）
第二种是通过SAP的屏幕编辑器开发，同构屏幕编辑器可以实现多种展现模式。（暂时不学）
屏幕基本输入域对象的创建以及相关属性 SAP中可以通过ABAP来创建屏幕元素，共分为两种模式，一种是通过SELECT-OPTIONS语法来建议数据输入域，另一种则是通过PARAMETERS语法来创建数据输入域。
即一种是定义框架，另一种是不定义框架
屏幕元素创建的基本语法 SELECT-OPTIONS 与PARAMETERS 的属性有很多相似之处，但是SELECT-OPTIONS创建的是一个输入的区间，其定义时必须指定参考表及参考字段，SELECT-OPTIONS &lt;对象名&gt; FOR &lt;参考对象&gt; PARAMETERS 通常用于简历一个单一的屏幕输入对象，其参考对象比较灵活，可以参考数据表的字段，也可以参考具体的数据元素。 PARAMETERS&lt;对象名&gt; LIKE/TYPE&lt;参考对象&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0804f2951f7198b37ebc7de7b4eab195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0dba4564f0a86bf6f40525eeb94c854/" rel="bookmark">
			字符变量 多重循环】输出图形（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 输入整数n 输出字母三角形(是等腰三角形） 提示： 每一行都有空格，字符串，回车构成 //循环解决 字符串可以分解为两部分：字符A～ch 和ch-1～A //ch为输入的最大字符，此处可以用两个并列的循环解决 如 ABCDCBA的输出，可以用以下语句实现：
for(i=1;i&lt;=4;i++)
putchar(‘A’+i-1);
for(i=3;i&gt;=1;i--)
putchar(‘A’+i-1);
或者
for(ch='A';ch&lt;='D';ch++)
putchar(ch);
for(ch='C';ch&gt;='A';ch--)
putchar(ch);
#include&lt;stdio.h&gt;
int main()
{
int n,i,b,c,d;
char ch='A';
scanf("%d",&amp;n);
for(i=1;i&lt;=n;i++)//控制行数 {
ch='A';
for(b=0;b&lt;n-i;b++)
{//控制空格 putchar(' ');
}
for(c=0;c&lt;i;c++)//控制字母 {
printf("%c",ch++);//因为这里是ch++用ch再++ }
ch--;
for(d=0;d&lt;i-1;d++)
{
printf("%c",--ch);
}
printf("\n");
}
return 0;
} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7958a0787944f58631cd58ef4f29255/" rel="bookmark">
			网页上为何出现连接超时，怎么解决呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网页出现连接超时是因为本地网络不稳定或网页服务器堵塞等原因造成的。
定义：
网络连接超时就是在程序默认的等待时间内没有得到服务器的响应。
网络连接超
1. 网络断开，不过经常显示无法连接。
2. 网络阻塞，导致你不能在程序默认等待时间内得到回复数据包。
3. 网络不稳定，网络无法完整传送服务器信息。
4. 系统问题，系统资源过低，无法为程序提供足够的资源处理服务器信息。
5. 设备不稳定，如网线松动、接口没插好等等。
6. 网络注册时系统繁忙，无法回应。
7. 网速过慢，如 使用bt多线程下载，在线收看视频等大量占用带宽的软件 ，若使用共享带宽还要防范他人恶意占用带宽。
8. 计算机感染了恶意软件，计算机病毒，计算机木马等。
解决办法：
1. 检查网线 更换接口。
2. 在早上上网人数少的时候注册。
3. 使用加速软件，如果要下载东西尽量在没有网络使用需求情况下载。
4. 杀毒。
5. 如果使用网卡，可以更换一下网卡。
6. 提高网速。
文章来源：微点阅读 https://www.weidianyuedu.com/content/0520604320607.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e1867ca06bca27dd9b714863926b87/" rel="bookmark">
			并发编程面试题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并发编程三大特性 可见性： 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
原子性： 线程执行一个业务过程是不可中断的，要么都执行或者都不执行。
有序性： 为了提高程序运行效率可能会对代码进行重排优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
什么是内存模型 内存模型可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象描述（即描述了程序中各个变量（实例域、静态域和数组元素）之间的关系，以及将变量从内存中取出和写入的底层细节），不同架构下的物理机拥有不一样的内存模型，Java虚拟机是一个实现了跨平台的虚拟系统，因此它也有自己的内存模型，即Java内存模型（Java Memory Model, JMM）。
因此它不是对物理内存的规范，而是在虚拟机基础上进行的规范从而实现平台一致性，屏蔽了不同硬件平台和操作系统的内存访问差异，以达到Java程序能够“一次编写，到处运行”(即让Java程序在各种平台下都能达到一致的内存访问效果)。
JMM JMM（Java内存模型Java Memory Model，简称JMM）它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。
由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成
volatile 被volatile修饰的变量，编译后字节码中会多出一个 lock 前缀指令，即内存屏障，主要有两个作用：1）保证可见性：在对volatile修饰的变量进⾏修改后，会强制将新值刷新到主存，并通过底层的总线嗅探机制告知当前引用该变量的地址缓存失效，其他线程会重新从内存中读取变量，更新缓存的值。
2）禁止指令重排：保证内存屏障前后特定操作的执行顺序
volatile不能保证原子性
修改 volatile变量 分为四步：
1）读取volatile变量到local
2）修改变量值
3）local值写回
4）插入内存屏障 ，即lock指令，让其他线程可见
前三步都是不安全的，取值和写回之间，不能保证没有其他线程修改，原子性需要锁来保证。
Synchronized和Lock区别 A.synchronized属于JVM层面，是java的关键字
会在同步代码块前插入monitorenter指令，执行该指令时会尝试获取当前对象锁绑定的对象监视器，如果抢占成功，则能执行代码块，没有则进入等待对立等待Lock是一个具体的类（java.util.concurrent.locks.Lock），是api层面的锁 B.是否释放锁
synchronized：不需要用户去手动释放锁，当synchronized代码执行后或发生异常时，系统会自动让线程释放对锁的占用，不会发生死锁ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象 C.等待是否中断
同步方法或同步代码块的执行是不可中断，除非抛出异常或者正常运行完成ReentrantLock：可中断，可以设置超时方法，或用interrupt() D. synchronized是非公平锁，ReentrantLock可通过构造函数指定，默认是非公平锁。
E.Lock可以通过方法返回值判定是否成功获取锁，而synchronized无法办到。
F. synchronized属于重量级锁，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，直到获取锁的线程释放锁。 如果获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程一直等待。相比synchronized，lock则更灵活的控制锁的申请和释放。如果在并发读的环境下，lock性能优于synchnorized。
Synchronized加锁过程 在执行monitorenter指令或者获取到同步方法的标识ACC_SYNCHRONIZED时，首先从对象头中找到关联的监视器monitor对象，通过CAS尝试把monitor的_owner字段设置为当前线程，如果当前线程是第一次进入该monitor，设置recursions为1，_owner为当前线程，该线程成功获得锁并返回；
如果设置之前的_owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行recursions ++，记录重入的次数；
如果获取锁失败,则等待其他线程释放锁。
等待时当前线程被封装成ObjectWaiter对象，通过CAS把该节点push到_cxq等待队列中后，再次通过cas自旋尝试获取锁，如果还是没有获取到锁，则将当前线程挂起，等待被唤醒。
当该线程被唤醒时，会从挂起的点继续执行尝试获取锁。
执行到monitorexit指令时，或同步方法执行完，_recursions减1，当_recursions的值减为0时，说明线程释放锁。
然后又从cxq或EntryList中获取头节点，唤醒下一个线程执行。
Synchronized锁升级流程 因为将线程唤醒和挂起操作系统都需要从用户态切换到内核态工作影响性能，为了提高获取锁和释放锁的效率，锁会随着线程的竞争情况逐渐升级，偏向锁 =&gt; 轻量级锁 =&gt; 重量级锁 。
在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。
当线程第一次访问同步块并获取锁时，偏向锁处理流程如下:
1.虚拟机将会把对象头中的标志位设为"01"，即偏向模式。
2.同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word的Thread中，如果CAS操作成功，则获取锁成功。失败，则存在锁竞争。
持有偏向锁的线程以后每次进入这个锁相关的同步块时，只需要检查是否为偏向锁、锁标志位以及ThreadlD，不用别的操作，效率高。
一旦有多个线程来竞争，就要撤销偏向锁，升级为轻量级锁
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96e1867ca06bca27dd9b714863926b87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d63a270b0f5a7755b003d087e99e1e/" rel="bookmark">
			Vue中的角色权限管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue中的角色权限管理 一、实现思路： 1.后端判断用户拥有哪些权限，返回前端所需要的路由及导航数据
2.动态加载路由
3.动态显示导航
二、具体实现： 1.在路由钩子 beforeEach中发送请求获取需要的路由及导航数据
//伪代码 router.beforeEach((to,from,next)=&gt;{ if(缓存中没有有路由导航数据){ // 发送请求 获取路由 // 获取数据后，缓存 //store.dispatch('SETNAV','获取到的数据') next() }else{ next() } }) // }) 一般情况下路由和导航数据在同一个对象中，具体有哪些需要根据项目来定。
2. 动态添加路由
组装成路由需要的数据
router.addRouters(组装好的路由数据) 动态显示导航栏
按钮权限 通过后台返回的按钮权限 在页面通过 v-if 或 自定义指令
自定义指令实现按钮权限：
//页面代码 &lt;template&gt; &lt;div class="home"&gt; &lt;div&gt; &lt;h1&gt;vue中按钮权限控制&lt;/h1&gt; &lt;button v-has="'add'"&gt;添加&lt;/button&gt; &lt;button v-has="'edit'"&gt;编辑&lt;/button&gt; &lt;button v-has="'delete'"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import has from '@/directives/has' export default { name: 'HomeView', directives:{ has }, &lt;/script&gt; //has.js // const buttonPermission = { // add:true, // edit:true, // delete:true // } export default { inserted(el, binding, vnode){ let btnPermissionValue = binding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d63a270b0f5a7755b003d087e99e1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d63205ee2d70a12116b9956c0d60be/" rel="bookmark">
			Java日期格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01 引言02 日期格式的含义2.1 格式解析2.2 常用例子 03 文末 01 引言 在Java中我们经常使用日期进行转换，例如：
import java.text.SimpleDateFormat; import java.util.Date; public class Test { public static void main(String[] args) { Date currentDate = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:MM:ss"); System.out.println("current date -&gt; " + simpleDateFormat.format(currentDate)); } } 运行结果：
注意了，我们有去深入理解过日期格式：yyyy-MM-dd HH:MM:ss吗？相信很多人都没有去深入了解过，本文来讲讲。
02 日期格式的含义 一般，以上是标准的24小时的日期格式（yyyy-MM-dd HH:MM:ss）我们都是复制过来的，其实它的大小写会严重影响运行结果，例如，把它全部改为小写，代码如下：
public class Test { public static void main(String[] args) { Date currentDate = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11d63205ee2d70a12116b9956c0d60be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f383afc96c1ea44ec8fef6f20f47ca/" rel="bookmark">
			服务器中java项目调用Kettle转换脚本ktr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目背景 报表导出业务涉及了两个库，所以这就导致了要进行跨库进行查询，在原本的库设计层面，这两个库是完全物理隔绝的，是没办法进行跨表查询的，所以，我就想了个办法来进行数据的迁移，但是组内资金有限，又不可能在申请服务器，引发了我想用基本的 java 代码，写一个 job 定时任务来定时的调用 ktr 文件就可以了
实施过程 一、maven 本地安装 ktr 所需要的 jar 包 ktr 文件如果用编辑器打开的话，是可以看到就是 xml 的文件，所以，它只是个配置文件，其中需要用到好多 jar 包，那么我们需要下载哪些呢，这里我来详细的说明一下
我们在下载了 Kettle 整个项目的时候，我们可以看到它本地是有目录的，如下图所示，重点强调一下，这个 Kettle 是有 JDK 版本之分的，如果你用的是 1.7 的 JDK，你的服务器就要是 1.7 的 JDK，否则的话容易报数组越界，或者导出的数据会有乱码，简单一句话，你开发用的是 1.7 就用 1.7，你开发用的是 1.8 就用 1.8Kettle 下载地址我们把这三个基本的 jar 包通过 maven 的命令导入到我们的本地 maven 库中，我得做法是把这三个包放到一个文件夹目录下面，这样好些命令，然后通过 IDEA 的 maven 导入到本地导入的命令如下
mvn install:install-file -Dfile=D:\1\kettle-core-8.2.0.0-342.jar -DgroupId=pentaho-kettle -DartifactId=kettle-core -Dversion=8.2.0.0-342 -Dpackaging=jar mvn install:install-file -Dfile=D:\1\kettle-engine-8.2.0.0-342.jar -DgroupId=pentaho-kettle -DartifactId=kettle-engine -Dversion=8.2.0.0-342 -Dpackaging=jar mvn install:install-file -Dfile=D:\1\metastore-8.2.0.0-342.jar -DgroupId=pentaho-kettle -DartifactId=metastore -Dversion=8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f383afc96c1ea44ec8fef6f20f47ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/520a6ebf00aa73bb3726f32d6f0cb9f1/" rel="bookmark">
			VMware与CentOS8-stream的配置教程【2022-9-5】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、下载VMware和CentOS8-stream二、CentOS安装步骤（1）磁盘分配（2）CentOS的配置 一、下载VMware和CentOS8-stream 下载地址：vmware，参考链接指向的一篇博文
下载地址：CentOS，选择对应的版本，具体选择的方法
选择对应的版本，如果没有则选择other其他版本的
选择25或者更多，显示更多的镜像地址
找到一个自己觉得好用的云，这里以华为云为例，进入镜像
选择对应的版本，这里选择8-stream
逐层进入目录，选择这个.iso文件进行下载
二、CentOS安装步骤 （1）磁盘分配 1、首先选择典型（默认）：
2、再选择稍后安装操作系统，先完成磁盘的一些配置工作
3、选择需要安装的Linux系统
4、选择对应下载centos的版本，如果是7开头的版本则选择Red Hat Enterprise Linux 7 64位，这里安装的8开头的centos8.1，所以选择Red Hat Enterprise Linux 8 64位
5、给你的虚拟机命名，并且选择安装地址，建议一定自己选择安装地址，不要使用默认地址（路径不要存在中文）
6、给虚拟机分配磁盘空间，这里使用推荐的（20GB）就可以，因为磁盘空间在以后还能够重新分配，这里只要够用就行
7、开始自定义硬件设施，选择自定义硬件
内存的分配，按照推荐进行分配即可，默认是2GB
处理器的分配，首先要查找自己电脑上的CPU个数和内核个数，方法如下，打开任务管理器，进入资源监视器
进入资源监视器，可以看到笔者的电脑有2个CPU和16个内核。
笔者是这样进行分配的
其余的选项都采用默认的配置，点击关闭进入下一步
点击完成进入下一步
这时就出现了分配好磁盘空间的虚拟机，点击进入设置
选择默认的磁盘文件的位置，
挂载完成后点击确定进行下一步
（2）CentOS的配置 点击开启虚拟机
用回车键enter选择开始安装，这里没法截图，在网上找了张图片来进行参考
语言选择简体中文
日期和地区选择上海
进入软件选择
设置如下
接下来选择安装位置
配置分区如下
选择自定义
点击完成进行下一步
选择/boot，分配1G的空间
文件系统选择成ext4
继续添加swap分区
继续添加根分区
点击完成和接受更改
下一步进行网络连接
设置root密码
创建其他用户，使用该用户进行登录的
开始安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7ac8a6f6031b68b4d41e93d9bd04a5/" rel="bookmark">
			Window笔记本触摸板手势大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、单击操作
单指进行单击，相当于使用鼠标左键;双指进行单击，相当于使用鼠标右键。
2、滚动操作
将两个手指放在触摸板上，通过上下滑动可实现屏幕的上下滚动，方便浏览网页、文章时使用;左右滑动可进行图片前后顺序的切换，方便查看相册内的照片。
3、放大或缩小
将两个手指放在触摸板上，双指进行滑动拉伸或收缩的操作，可实现页面的放大或缩小。
4、查看打开的程序
将三根手指放在触摸板上，向上滑动可查看目前所有打开的程序及时间线记录。
5、最小化所有窗口，回到桌面
将三根手指放在触摸板上，向下滑动，即可让所有窗口最小化，瞬间回到桌面。
6、在打开的程序之间切换
将三根手指放在触摸板上，然后向右或向左轻扫，可在程序之间进行前后切换;进行左右或上下滑动，可自由选择打开的程序。
7、打开搜索框
三根手指同时单击触摸板，可打开搜索框。
8、打开通知中心
四根手指同时单击触摸板，可打开通知中心。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c73ada8f80fe74158b24e7f912171542/" rel="bookmark">
			Centos中nginx安装步骤（在线/离线）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在线安装 1、安装nginx前准备工作：
首先确认系统中是否安装了gcc、pcre-devel、zlib-devel、openssl-devel。
1、rpm包安装的，可以用 rpm -qa 看到，如果要查找某软件包是否安装，用 rpm -qa | grep "软件或者包的名字"
2、以deb包安装的，可以用 dpkg -l 看到。如果是查找指定软件包，用 dpkg -l | grep "软件或者包的名字"
3、yum方法安装的，可以用 yum list installed 查找，如果是查找指定包，用 yum list installed | grep "软件名或者包名"
举例：查看是否安装了gcc
yum list installed | grep "gcc"
这里可以确认我们没有安装gcc。
yum -y install gcc
再次执行查找命令
已安装。
没有安装的话可以使用命令：yum -y install gcc pcre-devel zlib-devel openssl openssl-devel
2、下载nginx安装包，这里使用nginx-1.9.9.tar.gz
2.1、将安装包放到 /usr/local下：
##解压：
tar -zxvf nginx-1.9.9.tar.gz
进入nginx-1.9.9目录下
##配置：
./configure --prefix=/usr/local/nginx
##进行编译及安装：
make &amp;&amp; make install
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c73ada8f80fe74158b24e7f912171542/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8305c8df411780c00b5d3a2735de445b/" rel="bookmark">
			kettle学习--基础--3.3--案例--将oracle的数据，导入到mysql中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kettle学习–基础–3.3–案例–将oracle的数据，导入到mysql中 1、案例背景 将oracle一张表的数据，导入到mysql中
2、准备工作 2.1、准备驱动 将依赖放到lib目录重启kettle 2.2、oracle数据库–准备数据 CREATE TABLE "TEST"."user" ( "userid" NUMBER ( 11, 0 ), "username" NVARCHAR2 ( 10 ), "usersex" NVARCHAR2 ( 1 ), "userposition" NVARCHAR2 ( 20 ), "userage" NUMBER ( 11, 0 ) ) INSERT INTO "TEST"."user" ("userid", "username", "usersex", "userposition", "userage")VALUES (1, '陈XX', '女', '学生', 20); INSERT INTO "TEST"."user" ("userid", "username", "usersex", "userposition", "userage")VALUES (2, '王XX', '男', '工程师', 30); INSERT INTO "TEST"."user" ("userid", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8305c8df411780c00b5d3a2735de445b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b072c5f756d1a3cb8273535601d32aa/" rel="bookmark">
			【QT】QT项目：自制Wireshark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目总览 二、运行结果 三、项目源码 1、shark.pro
QT += core gui greaterThan(QT_MAJOR_VERSION, 4): QT += widgets CONFIG += c++11 # The following define makes your compiler emit warnings if you use # any Qt feature that has been marked deprecated (the exact warnings # depend on your compiler). Please consult the documentation of the # deprecated API in order to know how to port your code away from it. DEFINES += QT_DEPRECATED_WARNINGS # You can also make your code fail to compile if it uses deprecated APIs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b072c5f756d1a3cb8273535601d32aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d969b163174109a6565633ba7a22dab6/" rel="bookmark">
			解决：PicGo插件安装失败，失败码为1（404）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、错误说明 在安装PicGo插件时，发现插件安装失败，失败的表现是：先显示“安装中”，随后又变为显示“安装”，而不是“已安装”。
查看PicGo的日志说明，发现报错如下
2022-09-05 13:57:28 [PicGo ERROR] 插件安装失败，失败码为1，错误日志为 [37;40mnpm[0m [0m[31;40mERR![0m [0m[35mcode[0m E404 [0m[37;40mnpm[0m [0m[31;40mERR![0m [0m[35m404[0m Not Found - GET https://cdn.npmmirror.com/binaries/electron/picgo-plugin-gitee-uploader [0m[37;40mnpm[0m [0m[31;40mERR![0m [0m[35m404[0m [0m[37;40mnpm[0m [0m[31;40mERR![0m [0m[35m404[0m 'picgo-plugin-gitee-uploader@*' is not in the npm registry. [0m[37;40mnpm[0m [0m[31;40mERR![0m [0m[35m404[0m You should bug the author to publish it (or use the name yourself!) [0m[37;40mnpm[0m [0m[31;40mERR![0m [0m[35m404[0m [0m[37;40mnpm[0m [0m[31;40mERR![0m [0m[35m404[0m Note that you can also install from a [0m[37;40mnpm[0m [0m[31;40mERR![0m [0m[35m404[0m tarball, folder, http url, or git url.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d969b163174109a6565633ba7a22dab6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/135/">«</a>
	<span class="pagination__item pagination__item--current">136/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/137/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>