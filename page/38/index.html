<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8432bf0f80bbfde72788c943120d4dbf/" rel="bookmark">
			[dayjs]时区转换常见场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时区转换 项目中几个常见的时区转换场景
1、UTC 0时区时间转为本地时间（常用） // 国际化用 // UTC格式化成本地时间 export function formatLocalTime(timeStr: string, formatter = 'YYYY-MM-DD HH:mm:ss') { if (!(timeStr &amp;&amp; dayjs(timeStr))) return '' return dayjs.utc(timeStr).local().format(formatter) } 2、获取本地时区 例如UTC+8则输出8 export function getLocalTimeZone() { const offsetInMinutes = new Date().getTimezoneOffset() return offsetInMinutes / -60 } 3、根据时间和时区偏移获取UTC+0时间 function getUTCWithOffset(dateString, offset) { const date = dayjs(dateString, "YYYY/MM/DD HH:mm:ss").utcOffset(offset); return date.utc().format('YYYY-MM-DD HH:mm:ss'); } 4、dayjs(dateStr).utc(true)和dayjs.utc(dateStr)的区别是什么 dayjs(dateStr).utc(true) 将给定的日期字符串解析为一个日期对象，然后将其转换为UTC时间。
dayjs.utc(dateStr) 则是将给定的日期字符串解析为一个UTC日期对象。
因此，两者的主要区别在于第一个方法是将本地时间转换为UTC时间，而第二个方法是直接创建一个UTC时间。
一些例子如下：
dayjs('2020/12/23 12:20:30').utc(true).local().format('YYYY-MM-DD HH:mm:ss') 输出：'2020-12-23 20:20:30' dayjs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8432bf0f80bbfde72788c943120d4dbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32a0a9cb36960cba063636f8a041c7b/" rel="bookmark">
			使用c语言来完成一个学生管理系统，主要功能有，姓名根据成绩排序，以及查找学生信息，计算总分、平均分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;string.h&gt; // 定义学生结构体 struct Student { char name[50]; int grade; int age; char gender[40]; float score; }; // 函数声明 void findStudent(struct Student students[], int numStudents, const char* searchName); float calculateTotalScore(struct Student student); float calculateAverageScore(struct Student student); float calculateSubjectTotal(struct Student students[], int numStudents); float calculateSubjectAverage(struct Student students[], int numStudents); int main() { // 动态输入学生人数 setbuf(stdout, NULL); int numStudents; printf("请输入学生人数: "); scanf_s("%d", &amp;numStudents); // 初始化学生数组 struct Student students[numStudents]; // 输入学生信息 for (int i = 0; i &lt; numStudents; ++i) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e32a0a9cb36960cba063636f8a041c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7261e0db174eb575eebaffc9b7e20e4d/" rel="bookmark">
			2023 年四川省职业院校技能大赛 移动应用设计与开发赛项规程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、赛项名称
二、竞赛目的
三、竞赛内容
模块 A：功能模块开发
模块 B：测试与交付
四、竞赛方式
五、竞赛流程
六、赛卷说明
七、竞赛规则
八、竞赛环境
九、技术规范
十、技术平台
十一、成绩评定
十二、奖项设定
十三、赛项安全
十四、竞赛须知
十五、申诉与仲裁
一、赛项名称 赛项名称：移动应用设计与开发
赛项组别：高职组
赛项归属：电子信息大类
二、竞赛目的 本赛项面向产业主流技术，对接国际标准， 旨在通过 融合世界技能大赛的技术标准和规则要求， 引领和促进教 学改革，提升职业教育的国际化水平。通过完成一个完整 的工作过程，使参赛选手、裁判、教师等相关人员，熟悉 并掌握世界技能大赛的技术规范和技术标准，检验教学质 量，达到“ 以赛促教、以赛促学、以赛促改、以赛促建 ”的目的。
本赛项重点考查参赛选手在移动应用开发实际工程项 目中的综合分析能力、架构设计能力、编码能力、文档编 写能力、创意创新能力、产品测试能力， 通过比赛展现移动应用开发专业学生的技能与风采，使教师和学生更全面地了解行业企业岗位对学生职业技能的最新要求，提升移 动应用开发专业人才培养质量和就业质量。 同时培养选手 的沟通与交流能力、抗压能力、6S 规范等职业素质；激发 学生的求知欲和爱岗敬业的工匠精神，带动广大青年学生钻研技术、苦练技能，走技能成才、技能报国之路。
通过大赛搭建校企合作平台，引导更多行业企业参与 校企合作，深化产教融合，提升人才培养质量，使职业院 校能更深入地了解产业的发展趋势以及产业对 IT 人才的需 求与标准，引领移动应用开发及相关专业改革与建设， 以 适应互联网+、移动互联、云计算、大数据、人工智能技术的发展，促进我国信息产业技术的改进与升级。
通过竞赛培养一批“ 实践能力强、教学水平高、敬业 精神佳 ”的双师型“种子教师 ”；通过竞赛成果转化，建 设一批高质量、立体化的项目教学资源等，在实训条件、 课程内容、专业建设、人才培养等方面为职业院校提供指导。
三、竞赛内容 “移动应用设计与开发 ”赛项基于高等职业学校移动应用开发专业标准 ， 融合世界技能大赛移动应用开发(Mobile Application Development)项目的技术要求，并结合 国内外行业企业实际需求组织命题，在规定的时间内完成 指定的移动应用软件项目开发任务。 比赛采用实际操作形 式现场编程，通过“功能模块开发 ” “测试与交付 ”等模 块，考查参赛选手实际工程项目的编码能力、综合分析能 力 、技术架构设计能力 、产品测试能力 。考核技术点包 括：UI 交互设计、四大组件（Activity 、Service 、Broadcast Receiver 和 Content Provider ）、Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7261e0db174eb575eebaffc9b7e20e4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2c5516b12887f2bdef5cc745e82289/" rel="bookmark">
			GoLong的学习之路，进阶，Viper（yaml等配置文件的管理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来有今天是继续接着上一章写微服务的。但是这几天有朋友说，再写Web框架的时候，遇到一个问题，就是很多的中间件（redis，微信，mysql，mq）的配置信息写的太杂了，很不好管理。希望我能写一篇有管理配置文件的。所以这篇就放到今天写吧。微服务就放到下一篇来说吧。今天介绍的主角：Viper
文章目录 Viper概念安装 使用VIper默认值使用-&gt;配置文件读取配置文件：写入配置文件监控并重新读取配置文件(运行时读取配置文件)从`io.Reader`读取配置注册和使用别名 环境变量命令行参数（flag）`key/value`存储(远程`Key/Value`存储支持)（微服务）etcdConsulFirestore 从Viper获取值访问嵌套的键提取子树 反序列化序列化成字符串使用多个viper实例 使用Viper示例直接使用viper管理配置使用结构体变量保存配置信息 Viper概念 Viper是适用于Go应用程序（包括Twelve-Factor App）的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。
它支持以下特性：
设置默认值从JSON、TOML、YAML、HCL、envfile和Java properties格式的配置文件读取配置信息实时监控和重新读取配置文件（可选）从环境变量中读取从远程配置系统（etcd或Consul）读取并监控配置变化从命令行参数读取配置从buffer(缓冲)读取配置显式配置值 在构建现代应用程序时，你无需担心配置文件格式。
Viper能够为你执行下列操作：
查找，加载，和反序列化JSON、TOML、YAML、HCL、INI、envfile和Java properties格式的配置文件。提供一种机制，为不同配置选项设置默认值。提供一种机制来通过命令行参数覆盖指定选项的值。提供别名系统，以便在不破坏现有代码的情况下轻松重命名参数。当用户提供了，与默认值相同的命令行或者配置文件时，可以很容易分辨出他们之间的不通。 Viper会按照下面的优先级，每个项目的优先级都高于它下面的项目:
显示调用Set设置值命令行参数（flag）环境变量配置文件key/value存储默认值 目前Viper配置的键（Key）是大小写不敏感的。目前正在讨论是否将这一选项设为可选。
Viper让需要重启服务器才能使配置生效的日子一去不复返！！！
这才是VIper最大的魅力。
Viper没有默认的基础配置，所以在使用的过程中我们初始化Viper实例的时候需要告诉Viper你的配置路径、配置格式、配置名称等等信息。
Viper虽然支持多配置同时使用，但是一个Viper实例只能寻一个配置路径。
安装 go get github.com/spf13/viper 使用VIper 默认值 Viper 支持使用 viper.SetDefault(key, value) 为 key 设置默认值 value
Viper配置的键（Key）是大小写不敏感的
viper.SetDefault("ContentDir", "content") viper.SetDefault("LayoutDir", "layouts") viper.SetDefault("Taxonomies", map[string]string{"tag": "tags", "category": "categories"}) 键不需要默认值，但如果没有通过配置文件、环境变量、远程配置或命令行标志（flag）设置键，则默认值非常有用。
package main import ( "fmt" "github.com/spf13/viper" ) func main() { // 设置默认配置 viper.SetDefault("username", "李四") viper.SetDefault("server", map[string]string{"ip": "127.0.0.1", "port": "8080"}) // 读取配置值 fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2c5516b12887f2bdef5cc745e82289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f6cfa4276f28bff3cbe9c7907e76de9/" rel="bookmark">
			探索异步交互：JavaScript AJAX 的全面指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​🌈个人主页：前端青山
🔥系列专栏：JavaScript篇
🔖人终将被年少不可得之物困其一生
依旧青山,本期给大家带来JavaScript篇专栏内容:JavaScript-AjAx
目录
AJAX
AJAX 的优势
AJAX 的使用
创建一个 ajax 对象
配置链接信息
发送请求
一个基本的 ajax 请求
ajax 状态码
readyStateChange
responseText
ajax的工作原理
使用 ajax 发送请求时携带参数
发送一个带有参数的 get 请求
发送一个带有参数的 post 请求
get与post的区别？
get
post
封装 AJAX
确定一下使用的方式
Promise
什么是Promise?
promise使用语法
Promise原型对象的方法
处理多个异步
Promise的静态方法
Promise中的三种状态
ASYNC/AWAIT
async 和 await 关键字
async 关键字的用法
await 关键字的用法
缺点
解决方案
AJAX ajax 全名 async javascript and XML
是前后台交互的能力
也就是我们客户端给服务端发送消息的工具，以及接受响应的工具
是一个 默认异步 执行机制的功能
XML与JSON：都是可以跨平台、跨语言的一种数据格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f6cfa4276f28bff3cbe9c7907e76de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae0195294fdab5a3d55773135f951f5/" rel="bookmark">
			Video组件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在手机、平板或是智慧屏这些终端设备上，媒体功能可以算作是我们最常用的场景之一。无论是实现音频的播放、录制、采集，还是视频的播放、切换、循环，亦或是相机的预览、拍照等功能，媒体组件都是必不可少的。以视频功能为例，在应用开发过程中，我们需要通过ArkUI提供的Video组件为应用增加基础的视频播放功能。借助Video组件，我们可以实现视频的播放功能并控制其播放状态。常见的视频播放场景包括观看网络上的较为流行的短视频，也包括查看我们存储在本地的视频内容。
本文将结合《简易视频播放器（ArkTS）》这个Codelab，对Video组件的参数、属性及事件进行介绍，然后通过组件的属性调用和事件回调阐明Video组件的基本使用方法，最后结合Video组件使用过程中的常见问题讲解自定义控制器的使用。
Video组件用法介绍 Video组件参数介绍 Video组件的接口表达形式为：
Video(value: {src?: string | Resource, currentProgressRate?: number | string |PlaybackSpeed, previewUri?: string |PixelMap | Resource, controller?: VideoController}) 其中包含四个可选参数，src、currentProgressRate、previewUri和controller。
src表示视频播放源的路径，可以支持本地视频路径和网络路径。使用网络地址时，如https，需要注意的是需要在module.json5文件中申请网络权限。在使用本地资源播放时，当使用本地视频地址我们可以使用媒体库管理模块medialibrary来查询公共媒体库中的视频文件，示例代码如下： import mediaLibrary from '@ohos.multimedia.mediaLibrary'; async queryMediaVideo() { let option = { // 根据媒体类型检索 selections: mediaLibrary.FileKey.MEDIA_TYPE + '=?', // 媒体类型为视频 selectionArgs: [mediaLibrary.MediaType.VIDEO.toString()] }; let media = mediaLibrary.getMediaLibrary(getContext(this)); // 获取资源文件 const fetchFileResult = await media.getFileAssets(option); // 以获取的第一个文件为例获取视频地址 let fileAsset = await fetchFileResult.getFirstObject(); this.source = fileAsset.uri } 为了方便功能演示，示例中媒体资源需存放在resources下的rawfile文件夹里。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ae0195294fdab5a3d55773135f951f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75c5bd971b27d5764e5990321e946f46/" rel="bookmark">
			Ubuntu KVM安装配置 ubuntu kvm日常管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装桌面 sudo apt install ubuntu-desktop
2、安装KVM sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager -y
启动
sudo systemctl start libvirtd sudo systemctl enable libvirtd
3、验证KVM安装情况 sudo systemctl is-active libvirtd
输出：active
#确定正确加载模块
lsmod |grep kvm
将当前用户加入到 libvirt 和 kvm 用户组
sudo usermod -aG libvirt ubuntu sudo usermod -aG kvm ubuntu
4、配置网桥 删除默认网口
sudo virsh net-destroy default sudo virsh net-undefine default
如果还有，则需要删除
sudo ip link delete virbr0 type brigde sudo ip link delete virbr0-nic
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75c5bd971b27d5764e5990321e946f46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b146fe3857a3fc2c8e8fe8ba00116887/" rel="bookmark">
			React中传入props.children后, 为什么会导致组件的重新渲染？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传入props.children后, 为什么会导致组件的重新渲染？ 问题描述 在 react 中, 我想要对组件的渲染进行优化, 遇到了一个非常意思的问题, 当我向一个组件中传入了 props.children 之后, 每次父组件重新渲染都会导致这个组件的重新渲染; 它看起来的表现就像是被memo包裹的组件, props和自身状态未发生变化, 组件却重新渲染了; 下面我写了一个demo, 一起来看看这个问题吧:
父组件App中引入了一个Home组件:
import Home from "./pages/Home"; import { useState } from "react"; function App() { const [count, setCount] = useState(0); console.log("App is render"); return ( &lt;div className="App"&gt; {count} &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;Home&gt;&lt;/Home&gt; &lt;/div&gt; ); } 使用 memo 包裹 Home 子组件, 同时 Home 组件可以接收一个 props.children 展示传入到 Home 中的组件, 如下:
import React, { memo } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b146fe3857a3fc2c8e8fe8ba00116887/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dabfce9e5499e4e7debb160c2d2a85d/" rel="bookmark">
			React中每次渲染都会传入一个新的props.children到子组件?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传入props.children后, 为什么会导致组件的重新渲染？ 问题描述 在 react 中, 我想要对组件的渲染进行优化, 遇到了一个非常意思的问题, 当我向一个组件中传入了 props.children 之后, 每次父组件重新渲染都会导致这个组件的重新渲染; 它看起来的表现就像是被memo包裹的组件, props和自身状态未发生变化, 组件却重新渲染了; 下面我写了一个demo, 一起来看看这个问题吧:
父组件App中引入了一个Home组件:
import Home from "./pages/Home"; import { useState } from "react"; function App() { const [count, setCount] = useState(0); console.log("App is render"); return ( &lt;div className="App"&gt; {count} &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;Home&gt;&lt;/Home&gt; &lt;/div&gt; ); } 使用 memo 包裹 Home 子组件, 同时 Home 组件可以接收一个 props.children 展示传入到 Home 中的组件, 如下:
import React, { memo } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dabfce9e5499e4e7debb160c2d2a85d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dcacd8861cb10e6f9c22e089ca9b698/" rel="bookmark">
			多线程并发Ping脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 最近需要ping地址，还是挺多的，就使用python搞一个ping脚本，记录一下，以免丢失了。
2. 脚本介绍 首先检查是否存在True.txt或False.txt文件，并在用户确认后进行删除，然后从IP.txt的文件中读取IP地址，然后使用多线程并发地对这些IP地址进行ping测试。根据测试结果，将可连接的IP地址写入True.txt文件，不可连接的IP地址写入False.txt文件。
IP.txt文件需要每一行为一个IP地址，不可放置网段，并且通信与不通信是暂存在列表中的，若中间结束ping，则数据会丢失，只有当全部运行完后，会一次性写入，之前也测试过一边测试一边写入，会出现频繁的读取文件和写入文件，总会出现IP丢失的情况。此次经过测试，无丢失情况。
测试环境：python3.10
测试结果：IP.txt中共计1.2011个IP地址，20线程，共计耗时32分钟。
2.1. 文件夹内容 文件夹中，False.txt和True.txt这两个文件是不需要创建的，程序会自动创建，而且IP.txt是需要创建的，并且放置~地址，每行一个，正常回车换行，或者在表格中弄好，直接复制过来。
每次执行只需要替换IP.txt中的IP地址就可以了。
2.2. 脚本源码 这里电脑性能好，而且想快的话，直接多上一些线程，一开始我测试的时候，线程没设定好，直接给我干了2400多线程，电脑直接卡死，预估100多线程应该都没问题。
import threading import subprocess import os from concurrent.futures import ThreadPoolExecutor """判断是否存在True.txt或False.txt文，由于如果之前存在可能会导致执行添加了，但是测试好像不会，不过添加一个也无妨。""" def check_confirmation(): if os.path.exists('True.txt') or os.path.exists('False.txt'): user_input = input("发现已存在的True.txt或False.txt文件，是否删除？(y/n): ") if user_input.lower() == 'y': if os.path.exists('True.txt'): os.remove('True.txt') if os.path.exists('False.txt'): os.remove('False.txt') elif user_input.lower() == 'n': exit() else: print("无效的输入。请输入 'y' 或 'n'。") check_confirmation() def ping_ip(ip, true_ips, false_ips): """如果IP地址能够ping通，则将其添加到true_ips列表中；否则添加到false_ips列表中。""" command = ['ping', '-n', '1', ip] result = subprocess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dcacd8861cb10e6f9c22e089ca9b698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d0f3b3821891081a969e849b136d57/" rel="bookmark">
			Python-Django的“日志功能-日志模块(logging模块)-日志输出”的功能详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提前说明：如果是简单的日志输出，看我的另一篇博客就够，链接如下：
提前说明：如果是简单的日志输出，看我的另一篇博客就够，链接如下：
https://blog.csdn.net/wenhao_ir/article/details/134872372
01-综述 可以使用Python内置的logging模块来实现Django项目的日志记录。
所以与其说这篇文章在讲Django的“日志功能-日志模块-日志输出”，不如说是在讲Pthon的“日志功能-日志模块-日志输出”，即Python的logging模块。
下面用一个实例来进行讲解。
02-实例代码及运行效果 现在我要在Django的视图函数index()中输出之前用print()输出的信息。
用logging模块改写前的视图函数index()的代码如下：
def index(request): year = 2023 month = 11 day = 22 day_of_week = 'Wednesday' print(f"Today's date is:{year}-{month}-{day}-{day_of_week}") return render(request, 'index.html') # 将渲染结果输出到index.html模板中 在上面的代码中，print()语句根据上面设置的相关变量值输出下面的字符串：
Today's date is:2023-11-22-Wednesday 接下来，我们就根据Python内置的logging模块的使用方法来将上面的这个字符串输出到日志文件 logfile666.log 中。
首先我把完整的代码给出来，然后再慢慢讲。
视图函数index()的完整代码如下：
from django.shortcuts import render # 默认导入的模块 import logging # 导入日志记录模块 # 创建一个名为'index_log'的日志记录器 logger01 = logging.getLogger('index_log') # Create your views here. def index(request): year = 2023 month = 11 day = 22 day_of_week = 'Wednesday' logger01.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d0f3b3821891081a969e849b136d57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b62185f9a863ed8dfbadd63e5b73c98/" rel="bookmark">
			HTTP响应状态码大全：从100到511，全面解析HTTP请求的各种情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言发现宝藏一、认识响应状态码1. 什么是HTTP响应状态码2. Http响应状态码的作用3. 优化和调试HTTP请求的建议 二、1xx 信息响应1. 认识http信息响应2. 常见的信息响应状态码 三、2xx 成功响应1. 认识HTTP成功响应2. 常见的成功响应状态码 四、3xx 重定向1. 认识http重定向2. 常见的重定向状态码 五、4xx 客户端响应1. 认识http客户端响应2. 常见的客户端响应状态码 六、5xx 服务端响应1. 认识HTTP服务端响应2. 常见的服务端响应状态码 总结 前言 为了巩固所学的知识，作者尝试着开始发布一些学习笔记类的博客，方便日后回顾。当然，如果能帮到一些萌新进行新技术的学习那也是极好的。作者菜菜一枚，文章中如果有记录错误，欢迎读者朋友们批评指正。
（博客的参考源码可以在我主页的资源里找到，如果在学习的过程中有什么疑问欢迎大家在评论区向我提出）
发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
一、认识响应状态码 1. 什么是HTTP响应状态码 HTTP状态码是由服务器在响应客户端请求时返回的三位数字代码。它们用于表示HTTP请求的处理状态和结果。每个状态码都具有特定的含义，用于向客户端传达有关请求处理情况的信息。 2. Http响应状态码的作用 提供请求处理结果信息：HTTP状态码告知客户端请求的处理情况，包括成功、重定向、客户端错误和服务器错误等。通过状态码，客户端可以了解请求是否成功处理，以及如何进一步处理响应数据。
识别请求错误原因：状态码可以帮助客户端定位请求出错的原因。例如，当客户端发送了无效的请求或请求的资源不存在时，服务器会返回相应的错误状态码，使客户端能够了解到具体的错误原因，从而采取适当的措施。
支持协议扩展和升级：HTTP状态码的范围留有一定的空间，以支持未来的协议扩展和升级。通过定义新的状态码，可以为新的协议功能或处理情况提供准确的表示。
用于调试和故障排除：状态码在调试和故障排除过程中起到重要的作用。通过查看状态码，开发人员可以追踪请求处理的过程并确定出现问题的具体环节，以便进行修复和改进。
帮助构建良好的用户体验：正确使用状态码有助于提供良好的用户体验。例如，合理使用重定向状态码可以引导用户到正确的页面，而准确的错误状态码可以向用户提供友好的错误提示，提高用户满意度。
3. 优化和调试HTTP请求的建议 使用适当的HTTP方法：选择正确的HTTP方法来匹配请求的目的。常见的方法包括GET、POST、PUT、DELETE等。确保使用最适合的方法来执行特定的操作，以提高效率和安全性。
减少请求次数：减少不必要的请求次数可以显著提高性能。考虑使用请求合并、缓存、批量操作等技术来减少请求的数量，尽量减少服务器和网络的负载。
最小化请求大小：减少请求的大小可以降低网络传输成本和请求处理时间。优化请求的体积，例如通过压缩、减少冗余数据、合并请求等方式来减小请求的大小。
使用HTTP缓存：利用HTTP缓存可以减少对服务器的请求。合理设置缓存头，包括Cache-Control、Expires等，以及验证缓存是否仍然有效的机制，如ETag和Last-Modified。
压缩响应数据：使用压缩算法（如Gzip）对响应数据进行压缩，以减小响应的大小。客户端可以通过设置Accept-Encoding头来指示对压缩响应的支持，服务器则可以通过设置Content-Encoding头来指示响应数据的压缩方式。
使用合适的数据格式：选择适合数据交换的格式，如JSON、XML等。根据需求和场景选择合适的数据格式，以提高数据传输的效率和易用性。
监控和日志记录：使用适当的工具和技术来监控和记录HTTP请求和响应的信息。通过记录日志和分析监控数据，可以帮助发现潜在的性能问题和错误，以及进行调试和优化。
使用合适的工具和库：使用优秀的HTTP请求库或框架，如cURL、HttpClient等，可以简化开发过程并提供更高效的请求处理和调试功能。
进行性能测试：对HTTP请求进行性能测试，可以评估系统的性能并找出瓶颈。使用工具如Apache JMeter、LoadRunner等进行负载测试和压力测试，以确定性能瓶颈并进行优化。
仔细分析错误信息：对于出现的错误，仔细分析错误信息和状态码，以了解问题的根本原因。结合日志和其他调试工具，追踪请求的处理过程，找出错误所在并采取相应的修复措施。
二、1xx 信息响应 1. 认识http信息响应 HTTP信息响应是指当客户端向服务器发送HTTP请求后，服务器返回给客户端的响应消息
2. 常见的信息响应状态码 100 Continue 这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它 101 Switching Protocol 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议 102 Processing（WebDAV） 此代码表示服务器已收到并正在处理该请求，但没有响应可用 103 Early Hints 此状态代码主要用于与 Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源 三、2xx 成功响应 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b62185f9a863ed8dfbadd63e5b73c98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db61c703862eb9caec6fca7674f2666/" rel="bookmark">
			【Vue】修改组件样式并动态添加样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目标修改样式动态添加/删除样式样式不生效 注意：类似效果el-step也可以实现，可以不用手动实现。这里只是练习。
目标 使用组件库中的组件，修改它的样式并动态添加/删除样式。
修改样式 组件中的一些类可能添加样式无法生效。如Element Plus中的Timeline 时间线 | Element Plus (element-plus.org)。
假设想修改两个圆之间的线的长度，由于组件没有暴露相关的类名，我们需要自己修改它。浏览器F12可知，它的类名为：.el-timeline-item__tail，直接写样式无法生效：
.el-timeline-item__tail{ } 用:deep进行样式穿透可以生效：注意，deep与后面的括号不能有空格
:deep(.el-timeline-item__tail){ } 动态添加/删除样式 动态添加/删除样式需要操作DOM，这里要使用ref。由于这里使用的是组合式API，没有this，获取ref的方法是：
&lt;div ref='timelineRef'&gt; &lt;el-timeline&gt; ... &lt;/el-timeline&gt; &lt;/div&gt; const timelineRef = ref() 结合timeline：
const timeline = timelineRef.value.children[0] const timelineItem = timeline.getElementsByClassName('el-timeline-item') 其中，每个li代表item，包含节点node（圆圈）+下面的竖线tail。最后一个节点下面的tail不显示。
设置样式在active是变为蓝色，如：
.active_node{ background-color:blue; } 那么在比如触发到这一步是就给此节点添加类active_node。
timelineItem[0].children[0].classList.add('active_node') 动态移除类：
timelineItem[0].children[0].classList.remove('active_node') 需要注意的是：
F12看样式源代码，节点node颜色是background-color，线tail颜色是border的颜色由上面截图可知，children[0]表示tail，children[1]为node 样式不生效 动态添加完类后发现样式不生效。可以确认类是已经添加了的。原因：vue 中 通过js插入的dom 无法生效css_vue通过方法里拼接的dom自定义组件无法识别-CSDN博客
这是因为vue文件中的style标签添加了scoped，而scoped的作用是为了保证css样式只对当前vue文件(组件)生效，但是由于其他vue文件(组件)中也有可能会出现相同的class名相同的css样式，于是vue就采用了添加随机后缀的方式防止class名重复的样式出现样式覆盖的情况。
解决方法：
&lt;style lang="scss"&gt; // 这里是动态添加的样式类 &lt;/style&gt; &lt;style scoped lang="scss"&gt; // 这里是其他样式类 &lt;/style&gt; 最终效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621cd20f4f47cd4f3d31a61a133af962/" rel="bookmark">
			Amazon修改服务器时区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备份 mv /etc/localtime /etc/localtime.bak
在此 /usr/share/zoneinfo 目录下对应的时区代表城市 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db07f4c3a84d15f5f1c60e08a5bd184f/" rel="bookmark">
			联通宽带&#43;老毛子Padavan固件 开启IP v6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		联通宽带开启IP v6 参考： 联通宽带开启 IPV6 的方法_联通ipv6怎么开通-CSDN博客
个人宽带如何开启IPv6网络访问 - 知乎 (zhihu.com)
首先，你要确定当前你所在的地区运营商已经开通了IPV6，可以使用手机流量 IP查询(ipw.cn) | IPv6测试 | IPv6在线Ping测试 | IPv6网站检测 | IPv6网站测速 | IPv6地址查询 | IP查询(ipw.cn) 查看是否有IPV6地址。确认有IPV6地址后就可以进行下一步操作了。
进入 http://192.168.1.1/CU.html 光猫超级管理员界面，CUAdmin CUAdmin
桥接方式 1.先将 2_INTERNET_R_VID_88 IPv4的使能WAN 关掉。（通过修改网页element,查看，记住账号和密码）
2.然后，新建一个。
然后在路由器里进行设定。（文章中推荐桥接，路由器进行拨号）
拨号模式 设置一样，路由器也可以正常获取IP v6，只有一个问题，IP v6内网无法在公网访问。所以，推荐桥接。
但是请注意，至少在目前来说，IPv6无法完全替代IPv4，因为想要访问IPv6端的服务器，有很多限制。至少必须同时满足以下两个条件，才能够顺利访问，缺一不可：
访问端和服务端必须同时支持IPv6。但是很遗憾，目前仅有手机蜂窝流量全面支持IPv6访问，而许多酒店，咖啡厅的公共wifi及公司网络，都仅支持IPv4。服务器端的主由器必须能够关掉IPv6防火墙。目前已知仅有小米/华硕/TP的部分主流中高端型号支持此功能。如果路由器不支持关闭IPv6防火墙，要么用软路由，要么换掉，别无他法。 IP v6 地址说明 IPv6地址中，240e开头是电信，2048开头是联通，2409开头是移动，FE80开头是内网地址。
老毛子Padavan固件设置和开启IPv6的方法 老毛子Padavan固件设置和开启IPv6的方法 - 爱刷机 (iqqoz.com)
华硕老毛子Padavan使用IPV6+Aliddns远程管理路由_padavan ipv6_Dream_27151的博客-CSDN博客
我的All in one，桥接光猫搞定全设备IPV6，路由积分翻5倍_路由器_什么值得买 (smzdm.com)
运营商不给公网IP，外网访问成奢望？IPv6了解一下！_NAS存储_什么值得买 (smzdm.com)
Note: 这里一定要注意，开启 napt66 服务，否则能获得ip v6地址，但是上网有问题。
参考图片：
如果还有问题，参考这个文章：
Padavan/Openwrt/LEDE下实现ipv6 nat/napt66 - 简书 (jianshu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db07f4c3a84d15f5f1c60e08a5bd184f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0128dd949c4d1368e3d316f816305d5/" rel="bookmark">
			在 windows 系统上 go build linux 系统的可执行文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置 GOOS 为 linux
go env -w GOOS=linux 设置完后 go env 查看更改成功
go build 执行完成后生成可执行文件，重新更改 GOOS 为 windows
go env -w GOOS=windows go env 查看更改回来
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12dab042632ea0e48e05988041eb341f/" rel="bookmark">
			数据结构实验—宿舍管理系统（C，Python，Java三种代码版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 实验课程
实验内容
数据结构类型定义
模块划分
（C语言）详细代码设计
（python）详细代码设计
（Java）详细代码设计
测试数据及结果
实验总结
实验课程 课程名称：数据结构
实验名称：宿舍管理查询系统
实验目的：掌握数据结构的两种基本技术：查找和排序，根据实际情况选择效率较高的算法解决应用问题。
实验条件：计算机一台，Visual C++6.0
实验内容 问题描述
为宿舍管理人员设计一个宿舍管理查询系统, 程序采用交互工作方式，完成下列功能：
(1)建立合适的数据结构作为查找表并输入数据；
数据分别按关键字姓名、学号、房号进行排序(所学排序算法任选一种效率较高的算法)；
(2)设计查询菜单，按指定关键字姓名、学号、房号进行查询并输出结果，要求查询采用效率较高的算法实现；
(3)可以连续查询；
数据结构类型定义 struct student{ char name[20]; //姓名 char num[20]; //学号 char room[20]; //宿舍号 }; struct RoomSystem{ struct student allStudentdata[60]; //存储学生信息的数组 int size; //系统中学生信息的数量 }; 模块划分 void addStudent(struct RoomSystem* system)；//添加学生信息，存进管理系统结构体
void quickSort(struct student student[],int low, int high,const char* key)；//快排
int binarySearch(struct student student[],int low, int high,const char* key,const char* value)；//二分查找
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12dab042632ea0e48e05988041eb341f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4d83f29a54926817ad7e714978ce620/" rel="bookmark">
			CPU密集型和IO密集型与CPU内核之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPU密集型和IO密集型与CPU内核之间的关系
CPU 密集型
CPU密集型（CPU-bound）是指在程序运行过程中，主要由计算和逻辑运算任务占用大部分时间，而不是等待外部IO（输入/输出）完成。这类任务主要依赖于 CPU 的计算能力，而不是等待外部数据的读取或写入。在CPU密集型任务中，CPU 的运算能力是系统性能的瓶颈。
特点和场景：
计算需求高： CPU密集型任务通常需要进行大量的计算操作，例如数学运算、算法执行、图像处理、科学计算等。
CPU利用率高： 在任务执行期间，CPU的利用率通常会非常高，接近或达到100%。
等待时间少： 与IO密集型不同，CPU密集型任务的主要时间花费在计算和逻辑运算上，而非等待外部IO完成。
多线程提高效率： 在多核CPU系统中，通过使用多线程或并行处理，可以充分利用多核心的计算能力，提高任务的执行效率。
IO密集型
IO密集型（I/O-bound）是指在程序运行过程中，主要由输入/输出操作占用大部分时间，而不是计算和逻辑运算。这类任务主要依赖于外部IO（输入/输出）操作，例如从磁盘读取文件、向网络发送请求、与数据库交互等。在IO密集型任务中，CPU 的计算能力通常不是系统性能的瓶颈，因为大部分时间都是在等待IO操作的完成。
特点和场景：
IO等待时间高： IO密集型任务的主要特点是大量时间花费在等待外部IO操作的完成上，而不是计算和逻辑运算。
CPU利用率相对较低： 由于任务主要等待IO，CPU的利用率相对较低，可能不会达到100%。
适合异步编程： 对于IO密集型任务，采用异步编程模型（如回调、异步IO）能够更好地利用等待IO的时间，提高整体效率。
多线程提高并发性： 使用多线程或异步操作可以提高并发性，使系统能够在等待IO的过程中同时处理其他任务。
线程数规划的公式
在《Java并发编程实战》一书中，提到了一个线程池的大小计算公式，该公式是为了在一定条件下估算线程池的最优大小，以提高应用程序的性能。这个公式是：
N t h r e a d s​= N c p u​× U c p u​× ( 1 + W / C ) N threads ​ =N cpu ​ ×U cpu ​ ×(1+W/C)
Nthreads​=Ncpu​×Ucpu​×(1+W/C)
其中：
N t h r e a d s​：线程池的大小。 N threads ​ ：线程池的大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4d83f29a54926817ad7e714978ce620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bb92a212bd06d367f15e7a2609ad8dc/" rel="bookmark">
			【/盲盒商城系统/】VUE源码/盲盒商城系统/盲盒H5小程序/盲盒抽奖源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE源码/盲盒商城系统/盲盒H5小程序/盲盒抽奖源码
源码是带VUE的版本
下图是测试结果，可以编程成小程序然后对接易支付
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075b2c5fd64026ef808896a75615ccb0/" rel="bookmark">
			【Flink系列二】如何计算Job并行度及slots数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上文的问题
并行的任务，需要占用多少slot ？一个流处理程序，需要包含多少个任务 首先明确一下概念
slot：TM上分配资源的最小单元，它代表的是资源（比如1G内存，而非线程的概念，好多人把slot类比成线程，是不恰当的）
任务（task）：线程调度的最小单元，和java中的类似。
---------------------------------------------------------------------------
为更好的去理解后面如何计算并行度及需要的slots数量，先介绍一下几个概念
并行度（Parallelism） 图1 一个特定算子的子任务（subtask）的个数被称之为并行度（parallelism）一般情况下，一个stream的并行度，可以认为就是其所有算子中最大的并行度。图中source算子的并行度=2，map算子的并行度=2，keyby算子的并行度=2，sink算子的并行度=1 ps：并行度的设置有3个地方，1=代码中指定，2=提交Job时指定-p参数，3=Flink配置文件conf中执行，其优先级1&gt;2&gt;3, 不详细展开，有问题可以评论区
由图1，我们可以算出stream的任务数=7（两个source + 两个map + 两个keyby + 一个sink）
TaskManager和Slots 图2 Flink中每个TaskManager都是一个JVM进程，它可能会在独立的线程上执行一个或多个任务为了控制一个TM（TaskManager缩写）能接受多少哥task，TM通过task slot来进行控制（一个TM至少有1个slot）建议TM中slot数量设置为cpu核心数，因为一个TM中slot内存的独享的，但是cpu是共享的，为避免不同slot执行任务时争抢cpu资源，建议slot数量设置和cpu核心数一致图中slot数量决定了TM上的最大线程并行能力，一个slot可以执行一个线程，也可以串行执行多个线程。 图2中我们看到
source和map算子合并到一块了，那为什么可以合并呢？合并后每个任务都占用一个slot，一共是占用了5个slot，现实真的是这样的吗？ 带着问题，再看一个例子
source和map算子及keyby算子的并行都调整为6，sink算子的并行度还是1，排列方式如图
图3 按照我们上面的理解，我们应该需要的slot数量=6+6+1=13，但是这样会造成slot资源的浪费（流处理任务第一个算子处理完了之后需要等后面的算子都执行完，再开始下一批次的任务处理），为此，Flink允许任务共享slot
默认情况下，Flink允许子任务共享slot（必须是前后执行的不同的任务），及时他们是不同任务的子任务。这样的结果是，一个slot可以保存作业的整个管道。Task slot是静态的概念，是指TM具有的并发的并行执行能力 所以，Flink优化后一共占用6个slot。
slot共享组 任务槽共享的好处: 1.Flink 集群所需的 task slot 和作业中使用的最大并行度恰好一样。无需计算程序总共包含多少个 task（具有不同并行度）。
2.资源 容易获得更好的资源利用。如果没有 slot 共享，非密集 subtask（source/map()）将阻塞和密集型 subtask（window）
一样多的资源
默认情况下会设置一个默认的共享组， slotSharingGroup("default")，这样所有的算子都可以共享slot；如果想让两个算子任务不共享slot，通过调整共享组来实现。 不同的共享组一定在不同的slot上
// 1. 创建执行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(conf); //设置并行度,所有算子都默认这个并行度 env.setParallelism(1); DataStreamSource&lt;String&gt; ds = env.socketTextStream("hadoop102", 8888); ds.flatmap(new WordCount.MyFlatMapper()).name("f1").setParallelism(2).slotSharingGroup("a") .keyBy(0) .sum(1).setParallelism(2).slotSharingGroup("c"); .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/075b2c5fd64026ef808896a75615ccb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d5f95cf1723cfcfb075597e4c697ee/" rel="bookmark">
			头歌：电商精准营销—数据预处理概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关 数据预处理-数据清洗
#coding:utf8 import pandas as pd # 导入pandas库 import numpy as np # 导入numpy库 def choose_data(data): #选择变量'user_id', 'time', 'model_id', 'type', 'cate', 'brand',选取time在2016-02-01及以后的数据（包含2016-02-01）且type=6，数据类型如下： # user_id sku_id time model_id type cate brand # 0 266079 138778 2016-01-31 23:59:02 NaN 1 8 403 # 1 266079 138778 2016-01-31 23:59:03 0.0 6 8 403 # 2 200719 61226 2016-01-31 23:59:07 NaN 1 8 30 # 3 200719 61226 2016-01-31 23:59:08 0.0 6 8 30 # 4 263587 72348 2016-01-31 23:59:08 NaN 1 5 159 ########## Begin ########## data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6d5f95cf1723cfcfb075597e4c697ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dafded505b8990de4d91cbf4b8d6ce36/" rel="bookmark">
			选择排序和堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.基本思想：
2.直接选择排序:
3.堆排序
1.基本思想： 每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完 。 2.直接选择排序: 在元素集合array[i]--array[n-1] 中选择关键码最大 ( 小 ) 的数据元素 若它不是这组元素中的最后一个( 第一个 ) 元素，则将它与这组元素中的最后一个（第一个）元素交换 在剩余的array[i]--array[n-2]（ array[i+1]--array[n-1] ）集合中，重复上述步骤，直到集合剩余 1 个元素 直接选择排序的特性总结： 1. 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用 2. 时间复杂度： O(N^2) 3. 空间复杂度： O(1) 4. 稳定性：不稳定 注意： 以下讲解全是建立在升序基础上。 直接选择排序的 核心思想是遍历数组将最小和最大的值分别储存到mini和maxi中，再将mini与begin交换，maxi与end交换，这只是单趟分析。 单趟代码： int mini = begin, maxi = begin; for (int i = begin + 1; i &lt;= end; ++i) { if (a[i] &lt; a[mini]) { mini = i; } if (a[i] &gt; a[maxi]) { maxi = i; } } Swap(&amp;a[begin], &amp;a[mini]); Swap(&amp;a[end], &amp;a[maxi]); 接着就是一步一步缩小需要便利的数组长度，知道begin不在小于end，排序就完成了。 int begin = 0, end = n - 1; while (begin &lt; end) { int mini = begin, maxi = begin; for (int i = begin + 1; i &lt;= end; ++i) { if (a[i] &lt; a[mini]) { mini = i; } if (a[i] &gt; a[maxi]) { maxi = i; } } Swap(&amp;a[begin], &amp;a[mini]); Swap(&amp;a[end], &amp;a[maxi]); ++begin; --end; } 注意： 在直接插入排序中有一个 大坑，就是当Swap完了begin和mini处的数据后， 若maxi数据位于begin处，则会导致下一步Swap end与maxi时，将begin处的最小数据放入到end中了，造成了不可逆的影响（因为end会减减），使得最小数据放到最后出永不能改变。 所以，我们 需要在Swapbegin和mini后做出判断： Swap(&amp;a[begin], &amp;a[mini]); if (maxi == begin) { maxi = mini; } Swap(&amp;a[end], &amp;a[maxi]); 这样就能避免上述大坑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dafded505b8990de4d91cbf4b8d6ce36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aae05d9157411c2c5bd1dfd41698550/" rel="bookmark">
			C&#43;&#43; 路漫漫其修远兮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础语法 什么是常量：不可以修改的量 有宏常量，和const常量
#include &lt;iostream&gt; //常量，不能改变的量 //有宏常量和const常量 #define Day 7 using namespace std; int main() { cout &lt;&lt; "一周有："&lt;&lt; Day &lt;&lt; "天" &lt;&lt; endl;//宏常量 const int Month = 12;	//const常量 cout &lt;&lt; "一年有：" &lt;&lt;Month &lt;&lt; "月" &lt;&lt; endl; return 0; } 整型 不同整型所占内存空间大小不同 #include &lt;iostream&gt; using namespace std; //不同整型之间的区别在与所在内存空间大小不同 int main() { //短整型 2字节 有符号的所以要占一位 2^15 -32768~~32767 short Num1 = 32767; //整型 四个字节 有符号 2^31 21亿 无符号的就是2^32 42亿 int Num2 = 32768; //长整型 四个字节 有符号 2^31 21亿 无符号的就是2^32 42亿 long Num3 = 10; //长长整型 八个字节 有符号 2^63 无符号的就是2^64 long long Num4 = 10; cout &lt;&lt; Num1 &lt;&lt; endl; cout &lt;&lt; Num2 &lt;&lt; endl; cout &lt;&lt; Num3 &lt;&lt; endl; cout &lt;&lt; Num4 &lt;&lt; endl; return 0; } #include &lt;iostream&gt; using namespace std; //大小关系 //short &lt; int &lt;= long &lt;=longlong int main() { //短整型 2字节 有符号的所以要占一位 2^15 -32768~~32767 short Num1 = 32767; //整型 四个字节 有符号 2^31 21亿 无符号的就是2^32 42亿 int Num2 = 32768; //长整型 四个字节 有符号 2^31 21亿 无符号的就是2^32 42亿 long Num3 = 10; //长长整型 八个字节 有符号 2^63 无符号的就是2^64 long long Num4 = 10; cout &lt;&lt; Num1 &lt;&lt; endl; cout &lt;&lt; Num2 &lt;&lt; endl; cout &lt;&lt; Num3 &lt;&lt; endl; cout &lt;&lt; Num4 &lt;&lt; endl; return 0; } 实型（浮点型）及科学计数法 #include &lt;iostream&gt; using namespace std; int main() { // 1、float 浮点型单精度 4字节 // 2、double 浮点型双精度 8字节 // 3、都显示6个 float f1 = 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aae05d9157411c2c5bd1dfd41698550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f1029dcd9b631de97f6430ca8ca5a0/" rel="bookmark">
			Kafka-Java四：Spring配置Kafka消费者提交Offset的策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Kafka消费者提交Offset的策略 Kafka消费者提交Offset的策略有
自动提交Offset： 消费者将消息拉取下来以后未被消费者消费前，直接自动提交offset。自动提交可能丢失数据，比如消息在被消费者消费前已经提交了offset，有可能消息拉取下来以后，消费者挂了手动提交Offset 消费者在消费消息时/后，再提交offset，在消费者中实现手动提交Offset分为：手动同步提交(commitSync)、手动异步提交(commitAsync)什么是Offset 参考文章：Linux：【Kafka三】组件介绍 二、自动提交策略 Kafka消费者默认是自动提交Offset的策略
可设置自动提交的时间间隔
package com.demo.lxb.kafka; import org.apache.kafka.clients.consumer.ConsumerConfig; import org.apache.kafka.clients.consumer.ConsumerRecord; import org.apache.kafka.clients.consumer.ConsumerRecords; import org.apache.kafka.clients.consumer.KafkaConsumer; import org.apache.kafka.common.serialization.StringSerializer; import java.time.Duration; import java.util.Arrays; import java.util.Properties; /** * @Description: kafka消费者消费消息,自动提交offset * @Author: lvxiaobu * @Date: 2023-10-24 16:26 **/ public class MyConsumerAutoSubmitOffset { private final static String CONSUMER_GROUP_NAME = "GROUP1"; private final static String TOPIC_NAME = "topic0921"; public static void main(String[] args) { Properties props = new Properties(); // 一、设置参数 // 配置kafka地址 // props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83f1029dcd9b631de97f6430ca8ca5a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f9aa3adeb384f122e90e23359419e0/" rel="bookmark">
			ifconfig &amp; ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ifconfig &amp; ip 1、ifconfig1.1、net-tools工具安装1.2、ifconfig安装1.3、ifconfig简单使用1.4、ifconfig显示说明 2、ip 1、ifconfig 1.1、net-tools工具安装 yum -y install upgrade yum -y install net-tools ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。
1.2、ifconfig安装 -bash: ipconfig: 未找到命令
yum install -y upgrade 查找相关的ifconfig的安装包（ifconfig是在其他工具包中的一个小命令） yum search ifconfig 安装相关的ifconfig的安装包 yum install -y net-tools 1.3、ifconfig简单使用 启动网卡eth0： ifconfig eth0 up 关闭网卡eth0： ifconfig eth0 down 为网卡eth0配置IPv6地址： ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0删除IPv6地址： ifconfig eth0 del 33ffe:3240:800:1005::2/64 用ifconfig修改MAC地址： ifconfig eth0 hw ether 00:AA:BB:CC:dd:EE 配置IP地址： ifconfig eth0 192.168.2.10 ifconfig eth0 192.168.2.10 netmask 255.255.255.0 ifconfig eth0 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3f9aa3adeb384f122e90e23359419e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d2ee18528b16c7a74050bcd22b8164/" rel="bookmark">
			解决Microsoft Visual C&#43;&#43; 14.0 or greater is required. Get it with “Microsoft C&#43;&#43; Build Tools“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装python的pycrypto包报错：Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools”找了很多文档才解决，做个记录
使用的python版本：3.7.2
这个报错主要是对Microsoft Visual C++ 14.0 有依赖，那么首先 下载 Visual Studio
一、安装 Visual Studio
我下载的是2017版本，地址：https://my.visualstudio.com/Downloads?q=Visual%20Studio%202017
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86c48b370ea3ff1731991c489b836d77/" rel="bookmark">
			【IC前端虚拟项目】数据搬运指令处理模块前端实现虚拟项目说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里是芯片前端专属的虚拟项目介绍，不小心点进来的同学可以看看。
上一个虚拟项目ICer萌新入职虚拟项目完成之后更了一段时间的脚本教程IC萌新的脚本培训教程又重新把那个700行RTL代码的risc处理器重新写了一遍，可以说是非常的忙碌啊（主要是还得上班呢嗷，工作才是第一生产力！）
然后闲着的时间就在想着做第二个虚拟项目了，为什么做第二个呢？因为感觉第一个项目其实设计的难度不太大（当然我写出来的bug也不少哈），验证环境搭建也比较简单，整个项目更加侧重于熟悉流程和设计验证的入门。而且包传输协议更多应用在网络芯片架构中，和现在比较火的处理器方向距离比较远。所以呢第二个虚拟项目就显得挺有必要了。
要说明下，这个数据搬运指令处理模块也是曾经做过的虚拟项目（当然并不涉及到关键技术和专利机密等问题），将其根据我的思路进行重新组织后，形成了完成完整的虚拟项目呈现给大家。和之前的虚拟项目一样，工程托管在gitee上：
ic_virtual_project: 芯片前端萌新培训虚拟项目
设计文档在《MVU芯片前端设计验证虚拟项目》路径下，建议在win环境下查看；代码在mvu_prj路径下，可以在win下查看，需要在linux环境下运行。整个虚拟项目的方案与验证文档、RTL代码、验证环境、lint与综合配置与环境和使用的工具均需要个人完成或进行配置，可以说是全方位的训练了。在完成这个虚拟项目的过程中，会涉及和熟悉七个方面的内容：
linux工作站使用与git/svn项目托管；模块方案设计与RTL代码实现；验证环境设计与环境实现；debug和覆盖率收敛；lint与综合流程熟悉；时序收敛和面积功耗优化；项目中的脚本使用与实现； 在开始这个虚拟项目之前，建议可以阅读一下之前写的一篇介绍芯片研发部门日常与项目管理的文章，熟悉一下常见的芯片开发流程：
入职芯片开发部门后，每天摸鱼之外的时间我们要做些什么呢
和上一个虚拟项目一样，本专栏仍旧为收费专栏。如果你已经对芯片前端的设计、验证、flow和脚本比较熟悉或者有比较深的了解，那么借助开源的项目工程是可以独立完成整个虚拟项目的。如果你需要更多的参考以及交流沟通，那么可以考虑购买本专栏来对作者进行支持哈。
本专栏的文章预计会包括以下四部分的内容：
linux工作站使用与git/svn项目托管git和svn项目托管平台的简单使用说明linux工作站下工程的配置和使用说明工程目录组织说明模块方案设计与RTL代码实现MVU模块方案熟悉与背景熟悉MVU FS文档编写与注意事项MVU子模块DS文档编写与注意事项MVU寄存器文档编写与RTL代码生成inst_rece子模块DS与RTL编码read_path子模块DS与RTL编码write_path子模块DS与RTL编码mvu顶层集成的原则与技巧lint与综合流程熟悉顶层编译环境生成与验证代码初版本交付spyglass lint环境组织与lint清理SDC文件编写与DC综合环境组织时序面积优化与综合代码出版本交付验证环境设计与环境实现验证环境方案思路和文档组织测试点思路和文档编写接口分析与agent组件生成axi ddr/sram验证组件思路与编写验证环境env与base_teat思路与编写ral model的生成与合入reference model编写与合入sanity_case的编写与通包测试用例的完善与补充功能测试点的编写与合入debug与覆盖率收敛 此外，工程中所设计的工具脚本和相关知识点说明我也会添加在本专栏中，不会出现重复购买的问题，请放心。而且我感觉以我现在的精神状态吼，写到后面给自己写急眼了我是一定会涨价的，我现在看这个数字就不太顺眼了！
整个虚拟项目的内容还是比较多的，持续时间可能也会比较长，如果感兴趣就一起动起来！
第二个IC前端虚拟项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe65fed9eb6e85340db4c89059a111e/" rel="bookmark">
			麻辣香锅病毒处置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 今天早上正忙着，上级领导通知，说态势感知发现2023-12-05 18:40:50 主机X.X.93.21遭受攻击，攻击者为X.X.0.7后迅速开展检查，核实确认。
2. 原因分析 这里我从态势感知上看是IP：X.X.93.21去攻击IP：X.X.0.7，这里我后来分析完下面才知道原因。
首先，我们内部是不对外开放的，也就是物理上隔离，同时内部策略都是我自己针对服务进行放通互相访问，基本上不存在外部能轻易的访问到内部，而这个地址是内到内，那就不经过想过的策略，而这里X.X.93.21去访问X.X.0.7是由于，X.X.0.7是之前做某个项目的时候设定的域服务，所以这个主机的DNS就是X.X.0.7，导致X.X.93.21去触发对外请求的时候，需要将流量中转到X.X.0.7，也就是这个原因导致出现攻击。
而且这个病毒查询了时间还是再若干年前，我干…至今没被触发，不知道前天是由于什么原因导致触发了，但确实通过态势感知查看，次数很少，只有两次，这事已经过去两天了，这两天期间并未再次出现。
3. 病毒处置过程 这里的处置过程，少了一张第一次使用杀毒软件直接查杀的结果，这个确实查到了麻辣香锅这个病毒了，结果被我手贱，直接点清除了，导致截图还没截。
病毒分析—火绒
3.1. 病毒分析过程 3.1.1. 域名分析 通过对域名进行分析，该域名指向的是一款为麻辣香锅病毒，而该病毒主要是用于篡改浏览器界面，实现广告宣传从中获取利益。
传播方式通过小马激活器、暴风激活器、KMS激活器等。
3.1.2. 浏览器影响范围 3.2. 病毒排查 3.2.1. 查看进程 这里通过进程发现存在一个为R的进程，通过匹配麻辣香锅病毒的特征，完全匹配，同时可以看到该进程下挂载一个名为JB52.exe的程序，这个程序名是随机的，但是我查了一下网上的资料好像多数都是J开头的。
这里查看创建时间21年，算了一下确实符合业主这边的电脑使用时间的范围，也就意味着这个病毒确实好长时间没有运行过了，有时候当初使用某个激活器激活后就删除了，可能连绑激活器，激活器不运行，这个程序可能也就不运行了吧。
3.2.2. 查看驱动模块 通过麻辣香锅病毒的其它特征在%localappdata%\Microsoft\WindowsApps下发现两个驱动模块，不过这里你们还可以去以下几个目录找找异常文件，这里面也会存在的：
恶意程序目录：C:\Users\admin\AppData\Local\Temp（有一个xiaoma.exe，还有一个R服 务对应的exe） 恶意驱动目录：C:\Windows\System32\drivers（四个随机名驱动） 恶意程序目录：C:\Users\admin\AppData\Local\Microsoft\Event Viewer(有四个exe需要删 除） 同时C:\Windows\System32\drivers下还发现两个异常模块，这两个模块我怎么看都不像，但是我发现我把R服务关闭后再删除，这两个也删除后，R服务虽然没启动，但是挂载的程序又出现，同时这两个时间也一直。
3.2.3. 执行模块 在麻辣香锅病毒的另外一个特征中发现4个执行模块，名为：wrme.exe、wdlogin.exe、wccenter.exe、wuhost.exe。
3.3. 病毒处理 这里最好进入电脑的安全模式来操作，因为在C:\Users\Administrator\AppData\Local\mlxg_km或者C:\Users\mlxg_km这两个文件夹中都是麻辣香锅的病毒，同时又是隐藏起来的，你关闭隐藏，依旧看不见，进入安全模式后直接删除这mlxg_km文件夹，由于我是远程，我就使用工具直接删除了，但是不保险呀！不过后面确实再次扫描，就没有扫描到这文件夹了。
3.3.1. 删除进程 将R进程删除，同时观察进程是否又自动重启，通过观察进程表，并未重启。
同时删除JB52.exe的程序。
3.3.2. 删除系统回调 3.3.2.1. 查看回调文件 使用pchunter查看系统回调，再去查看文件回调。
3.3.2.2. 删除回调文件 将这些回调文件都删除，同时删除回调文件的文件夹。
3.3.3. 删除异常筛选项 这里使用命令fltmc查看异常筛选项，再将这两个异常筛选项删除。
sc query R //搜索服务是否存在 sc stop R //停止服务 sc delete R //删除服务 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fe65fed9eb6e85340db4c89059a111e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1dce7ac39816c78754edb472717a42/" rel="bookmark">
			2023年全国职业院校技能大赛高职组“区块链技术应用”赛项赛卷（6卷）解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置节点搭建区块链
这边我们基于网络下配置
先下载脚本（因为是默认docker搭建在做题的时候要注意安装docker）
curl -#LO https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/FISCO-BCOS/FISCO-BCOS/releases/v2.9.1/build_chain.sh &amp;&amp; chmod u+x build_chain.sh 题目中给了具体的P2P起始端口、channel起始端口、JSONRPC地具体要求
bash build_chain.sh -d -l 127.0.0.1:4 -p 30500,20500,8945 这边用默认docker打开各个节点的时候会出现以下条码
我们用的是默认fiscoorg/fiscobcos：v2.9.1镜像所以在docker容器库会找到相应的镜像自动下载
这样就是节点成功打开了
用docker命令查看区块链系统状态
docker ps -a | egrep fiscobcos 查看连接中node0的链接状态
tail -f nodes/127.0.0.1/node0/log/log* | grep connected 因为我们是联网状态下需要获取控制台（下载）
curl -#LO https://gitee.com/FISCO-BCOS/console/raw/master-2.0/tools/download_console.sh &amp;&amp; bash download_console.sh 进入我们需要拷贝控制台配置文件
cp -n console/conf/config-example.toml console/conf/config.toml 拷贝控制台证书
cp -r nodes/127.0.0.1/sdk/* console/conf/ 启动控制台
bash ~/tools/console/start.sh 可能会出现的报错 是因为我们没有修改我们控制台里的peers端口号(两个文件修改的地方是一样的)
cd ~/toosl/ vim console/conf/config-example.toml vim console/conf/config.toml 修改完成后我们打开控制台
cd console &amp;&amp; ./start.sh getBlockNumber //查看区块链中区块高度 getBlockHeaderByNumber 0 查看创世区块的信息 getConsensusStatus //查看区块共识状态 我们先创建3个用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1dce7ac39816c78754edb472717a42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf3de1caf8209d7c4aa7857521b6c7d3/" rel="bookmark">
			【GO】项目import第三方的依赖包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、导入第三方包
1.执行命令
2.查看go环境变量参数
3.查看go.mod文件的变化情况
二、程序里如何import 1. import依赖包
2. 程序编写
本次学习go如果依赖第三方的包，并根据第三方的包提供的接口进行编程，这里需要使用go get命令。下面将go get命令描述如下：
首先将官网的Go 命令文档路径贴一下：
Command go - The Go Programming Language
1. go get 命令
命令用于从远程代码仓库（比如 Github ）上下载并安装代码包。注意，go get 命令会把当前的代码包下载到 $GOPATH 中的第一个工作区的 src 目录中，并安装。
go 1.17之后go get只下载源码，并将依赖添加到go.mod，并不会安装。安装油go install完成。
2. go run 命令
专门用来运行命令源码文件的命令，一般用来运行单个文件
3. go build命令
主要是用于测试编译。编译某个包或者项目，在当前目录下生成可执行文件
go build 用于编译导入的包，包括import导入的包，以及这些包所依赖的其他关系包，但是并不会将编译后的结果进行安装。
go build 所在包为main 包时
若go build 后跟好几个.go文件，编译时会认为这几个文件是在同一个包中，且已第一个.go 文件名为输出结果.(比如：go build ed.go rx.go 输出为ed 或 ed.exe)
如果go build 后跟一个目录比如：go build /unix/sam 编译结果输出为： sam或sam.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf3de1caf8209d7c4aa7857521b6c7d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9192e75f254cde4aeb9134439976cf3c/" rel="bookmark">
			IP v6改造——IIS添加IP v6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、进入绑定
二、添加绑定
三、验证绑定
一、进入绑定 打开IIS管理器，在已部署好的网站中找到绑定，点击进入。
二、添加绑定 点击添加，然后在添加网站绑定中类型选择http，IP地址选择本机配置的ipv6地址，端口号80，主机名可不填，然后确定即可。
三、验证绑定 点击浏览网站处ipv6地址的浏览进行验证。打开页面与ipv4打开页面一致即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a24691395262d7e8779fa48258283d58/" rel="bookmark">
			PyCharm 本地终端用不了报错can‘t open local...(已解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开pycharm ，发现终端用不了，一直显示 can't open local，具体报错情况如下：
Cannot open Local Failed to start [powershell.exe, -ExecutionPolicy, RemoteSigned, -NoExit, -File, C:/Project/RollPace_latest/venv/Scripts/activate.ps1] in C:\Project\RollPace_latest, [columns=180, rows=11], envs={IntelliJ IDEA=&gt;C:\software\IDEA\IntelliJ IDEA 2023.2.5\bin;, CommonProgramFiles=&gt;C:\Program Files\Common Files, ProgramData=&gt;C:\ProgramData, COMPUTERNAME=&gt;LAPTOP-HJKG4T7R, SystemDrive=&gt;C:, USERDOMAIN=&gt;LAPTOP-HJKG4T7R, OneDriveConsumer=&gt;C:\Users\lft_h\OneDrive, OneDrive=&gt;C:\Users\lft_h\OneDrive, CommonProgramFiles(x86)=&gt;C:\Program Files (x86)\Common Files, TEMP=&gt;C:\Users\lft_h\AppData\Local\Temp, TMP=&gt;C:\Users\lft_h\AppData\Local\Temp, ProgramFiles=&gt;C:\Program Files, USERDOMAIN_ROAMINGPROFILE=&gt;LAPTOP-HJKG4T7R, windir=&gt;C:\Windows, CLASSPATH=&gt;.;C:\Program Files\Java\jdk1.8.0_301\lib\dt.jar;C:\Program Files\Java\jdk1.8.0_301\lib\tools.jar;, PROCESSOR_LEVEL=&gt;6, JAVA_HOME=&gt;C:\Program Files\Java\jdk1.8.0_301, ComSpec=&gt;C:\Windows\system32\cmd.exe, NUMBER_OF_PROCESSORS=&gt;16, PROCESSOR_ARCHITECTURE=&gt;AMD64, OS=&gt;Windows_NT, M2_HOME=&gt;C:\software\eclipse\apache-maven-3.9.5, ProgramFiles(x86)=&gt;C:\Program Files (x86), PSModulePath=&gt;C:\Program Files\WindowsPowerShell\Modules;C:\Windows\system32\WindowsPowerShell\v1.0\Modules, PATHEXT=&gt;.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC, PROCESSOR_IDENTIFIER=&gt;Intel64 Family 6 Model 186 Stepping 2, GenuineIntel, APPDATA=&gt;C:\Users\lft_h\AppData\Roaming, LOCALAPPDATA=&gt;C:\Users\lft_h\AppData\Local, CATALINA_HOME=&gt;C:\software\Tomcat8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a24691395262d7e8779fa48258283d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c66ace3f3ee9717dd15522c530eb9ac/" rel="bookmark">
			[PTA]输出全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请编写程序输出前n个正整数的全排列（n&lt;10），并通过9个测试用例（即n从1到9）观察n逐步增大时程序的运行时间。
输入格式: 输入给出正整数n（&lt;10）。
输出格式: 输出1到n的全排列。每种排列占一行，数字间无空格。排列的输出顺序为字典序，即序列a1​,a2​,⋯,an​排在序列b1​,b2​,⋯,bn​之前，如果存在k使得a1​=b1​,⋯,ak​=bk​ 并且 ak+1​&lt;bk+1​。
输入样例： 输出样例： /*注：后面的两张图片是我代码中的递归思路，希望对你理解该递归具有一定的 帮助*/ #include&lt;stdio.h&gt; int A[2][10] = { 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0,0 }; /*A数组的逻辑排列是： 0 1 2 3 4 5 6 7 8 9 用来存储1~9的数据(0不会使用后面有解释) 0 0 0 0 0 0 0 0 0 0 用来标记已经使用的数字，1已经使用，0未使用 也可以直接输出i并用一维数组标（后面对i的意义会解释），这样做为方便大家理解*/ int b[10] = { 0 }; int n = 0;//n一定要定义在两个函数外面 void fun(int mun);//用于函数递归输出排列 int main() { scanf("%d", &amp;n); fun(1); return 0; } void fun(int num)//这里的num其实就是第几个数 //比如123456，num=2时就是指2 { if (num&lt;=n) { for (int i = 1; i &lt;= n; i++) /*请注意这里的i是从1开始也就是说A[][0]一直都没有使用所以要从A[1]开始 赋值1，然后依次递增*/ { if (A[1][i]==0)//如果没有被标记 { b[num] = A[0][i]; A[1][i] = 1;//标记用过的数字 fun(num + 1);//开始递归，并取下一个数 A[1][i] = 0; //进入下一次从第一个数开始的循环需要把所有数字重置到未被标记的状态 } } } else//每次找到的数字满n个就进行打印 { for (int i = 1; i &lt; n+1; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c66ace3f3ee9717dd15522c530eb9ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3943b2d258aa81f0592af84db3179d0/" rel="bookmark">
			Effective CPP(五): 设计接口的原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、设计接口的原则二、使用常量对象引用做参数，而不是使用值传递做参数三、减少能够访问类的私有变量的成员函数的数目四、运算符重载函数有的时候不应该作为类的成员函数五. 自定义 Swap 函数的艺术 一、设计接口的原则 在设计接口的时候，尽量要明确声明参数的类型，避免不必要的类型转换。
一个错误的接口设计是:
//不优雅的接口设计，参数类型相同，导致容易造成误用
Date(int month,int day, int year) {}
一个正确的接口设计是:
//优雅的接口设计，为每一个参数限定好类型，同时这也符号 struct 中的 explicit 关键字，同时这里使用了常引用传参数来代替传统的按值传参数，如果按值传参数，程序会调用在这里插入代码片对象的拷贝构造函数构建一个在函数内作用的局部对象，这个过程的开销会非常昂贵。
Date(const Month&amp; m, const Day&amp; d,const Year&amp; y): month(m.value), day(d.value), year(y.value) {
if(!isValidDate()) {
throw std::invalid_argument(“Invalid Date”);
}
}
二、使用常量对象引用做参数，而不是使用值传递做参数 使用常量对象引用做参数而不是使用值传递做参数有这么一些优点:
1.防止不必要的拷贝构造函数开销，传值做参数就会使用拷贝构造函数创造一个局部变量，而拷贝构造函数带来的开销是巨大的。
2.防止对象切片问题
结合第一点，这里给出一段实例代码:
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;stdexcept&gt; struct Month { explicit Month(int m) : value(m) {} int value; }; struct Day { explicit Day(int d) : value(d) {} int value; }; struct Year { explicit Year(int y) : value(y) {} int value; }; class Date { public: //不优雅的接口设计，参数类型相同，导致容易造成误用 Date(int month,int day, int year) {} //优雅的接口设计，为每一个参数限定好类型，同时这也符号 struct 中的 explicit 关键字，同时这里使用了常引用传参数来代替传统的按值传参数，如果按值传参数，程序会调用对象的拷贝构造函数构建一个在函数内作用的局部对象，这个过程的开销会非常昂贵。 Date(const Month&amp; m, const Day&amp; d,const Year&amp; y): month(m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3943b2d258aa81f0592af84db3179d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf1157e357b224f85a83bfcfb39c467/" rel="bookmark">
			使用宝塔部署WordPress（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用宝塔部署WordPress（超详细） 准备材料特别注意安装宝塔配置LAMP/LNMP环境（很简单）WordPress配置 大体流程是： 安装宝塔面板（方便我们一键部署WordPress所需的LAMP/LNMP环境）打开所给的外网面板地址链接，进去面板一键配置环境安装并配置WordPress 准备材料 一台服务器（这里以阿里云 CentOS8 为例）一个已经备案的域名（没有已备案域名暂时可以用公网IP代替）耐心 特别注意 请确保服务器是纯净的系统环境，并且没有在跑的业务网站等安装好宝塔面板后会显示默认的随机账号密码和登录链接，请您必须当场保存！！宝塔面板登录资料只会显示一次，不会记录，如果忘记了请重新输入服务器登录资料重新安装宝塔面板或者登录服务器执行bt命令查看。
安装宝塔 请确保是纯净的系统环境（出厂设置），先点击服务器的远程连接，登录进终端，这里使用的是阿里云网站自带的那个Workbench（别的SSH连接方式也可以）
在连接成功进入终端后，输入我们从官网复制过来的命令（不同系统环境记得选不一样的）
yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec 如图，在终端输入命令后，会询问你是否安装宝塔面板，我们需要输入y，需要安装，敲回车进行确认，这个过程会持续几分钟的时间（网速决定）
下面是安装完成后的界面，红框内的是重要内容，大家记得保存好！！！（图片内容是假的，因为没截下来，就从官网找了个图片，反正安装完成就这个样子），这里大家需要保存好这个用户名和密码，一会就要用！！
为宝塔面板开放32458端口（也可能是8888，具体看安装成功后给的需要放行的），依次点击防火墙（安全组）—&gt; 添加规则—&gt;端口写32458—&gt;确认添加。
接下来，使用最后所给的外网面板地址，复制到浏览器中，就可以登录服务器的宝塔面板，在其中进行服务器的环境配置
配置LAMP/LNMP环境（很简单） LAMP=Linux+Apache+MySQL+PHP
LNMP=Linux+NGINX+MySQL+PHP
打开所给的外网面板地址链接，首先需要我们填写账号密码（刚刚宝塔面板安装成功给的账号密码）。如果你不小心没记住（大声bb），可以从终端输入bt 5 和bt 6 命令修改密码和用户名，在文章开头的特别注意里有这张图，可以参考输入命令补救一下
登录成功—&gt;同意协议—&gt;绑定宝塔账号（要是有宝塔账号的直接登录就可以，没有的话就先去注册一个再进行登录
之后变回弹出弹窗让我们安装环境，首次使用宝塔面板推荐安装一组套件，对于刚接触Linux环境部署的薯薯们，推荐使用LNMP，采用极速安装、一键安装的方式 LNMP和LAMP环境主要的区别在于web服务器上面，LNMP使用的是Nginx服务器，而LAMP使用的是Apache服务器。Nginx 性能稳定、功能丰富、运维简单、处理静态文件速度快且消耗系统资源极少。 之后就要耐心等待他安装了。。可以趁机点差关掉消息盒子窗口，熟悉一下宝塔面板
4. 在安装完这几个环境之后，依次点击网站—&gt;添加站点（PHP项目）—&gt;一键部署
之后稍微等一下下就会安装完成，记得记住数据库账号密码马上就用！！
在安装成功后，我们就可以使用域名（IP地址也行）去登录我们刚刚部署的WordPress网站 WordPress配置 用浏览器打开域名连接，你可以看到如下内容：
点击现在就开始
输入刚刚部署WordPress时的数据库账号密码，主机填127.0.0.1或localhost都一样
提交连接上数据库后，点现在安装
最后就是配置用户信息了，这个是你登录wordpress用户后台的，要记住：
点安装WordPress后，在登录后就会出现这个主页面啦
到这里，网站部署已经全部完成，但是还差最后一步，也是使用 WordPress 最为核心的一步：让你的网站看起来更加专业，更加成熟。为此我们需要做两件事：安装主题—&gt;让网站变得好看;安装插件—&gt;丰富网站的功能
让我们一起加油！！！
大家遇见问题可以留言到评论区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b727cce375cf5482ab1a910127ccc3c/" rel="bookmark">
			elementUI&#43;vue实现商城分类导航弹出二级菜单悬浮展示（鼠标经过时显示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 二级菜单显示是用了elementUI的两个组件：el-tooltip + el-cascader-panel
vue代码 &lt;!-- 分类 --&gt; &lt;div class="category-box"&gt; &lt;span class="category-label"&gt;分类&lt;/span&gt; &lt;div class="flex-1"&gt; &lt;div class="category-list"&gt; &lt;el-tooltip effect="light" content="" placement="bottom" popper-class="category-two-menu-box" v-for="item in categoryList" :key="item.id" :open-delay="300"&gt; &lt;div slot="content" v-if="item.children.length &gt; 0"&gt; &lt;el-cascader-panel v-model="currentActiveTwo" :options="item.children" @change="handleChangeCategoryTwo($event, item.id)" :props="{ expandTrigger: 'hover' }"&gt;&lt;/el-cascader-panel&gt; &lt;/div&gt; &lt;span :class="[categoryActive == item.id ? 'category-item-active':'']" class="category-item" @click="handleChangeCategory(item.id)"&gt;{{item.label}}&lt;/span&gt; &lt;/el-tooltip&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; categoryList = [ { value: '', label: '全部', children:[]}, { value: '服饰内衣', label: '服饰内衣', children: [{value: '女装', label: '女装' },{value: '男装', label: '男装' },{value: '婴童装/亲子装', label: '婴童装/亲子装' },{value: '14', label: '内衣/袜子' },{value: '15', label: '家居服' },{value: '16', label: '其他' }] }, { value: '食品饮料', label: '食品饮料', children: [{value: '零食/坚果/特产', label: '零食/坚果/特产' },{value: '酒水/饮料', label: '酒水/饮料' },{value: '茶', label: '茶' },{value: '粮油米面/南北干货/调味品', label: '粮油米面/南北干货/调味品' },{value: '乳品/咖啡/冲调', label: '乳品/咖啡/冲调' },{value: '方便速食/速冻食品', label: '方便速食/速冻食品' },{value: '其他', label: '其他' }] }] categoryActive = '' // 当前选中的一级 currentActiveTwo = '' // 当前选中的二级 // 一级菜单点击事件 handleChangeCategory(e){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b727cce375cf5482ab1a910127ccc3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202622a107e08efc66f5a1a71167690e/" rel="bookmark">
			数据库的索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引的特点
1）加快查询的速度
2）索引自身是一种数据结构，也要占用存储空间
3）当我们需要进行增删改的时候，也要对索引进行更新（也需要额外的空间开销）
sql操作 查看索引 show index from 表名; 查看某个表是否有索引，以及有几个索引
⚠在没有约束的情况下，数据表的索引是无法显示出来的
MySQL的unique，primary key和foreign key都可以自动生成索引
一个表的索引可以有多个，每个索引都是根据某个具体的列来展开的
创建索引 create index 索引名 on 表名(列名); 这个操作要慎用，如果表本身就有很多数据，此时创建索引操作会触发大量的IO
删除索引 drop index 索引名 on 表名; 索引底层的数据结构 采用B+树作为数据结构，前身B树，也叫B-树
B树是一个N叉搜索树，在二叉搜索树上进行拓展，要求这里是有序的
一个节点上可能包含N个值，N个值划分出N+1个区间
同样的高度的树，能表示的元素比二叉搜索树就多很多了
当采用B树进行查询时，总的比较次数增加了，但是同一个结点的这些key都是一次硬盘IO就都出来了，也就相当于内存1万多次的比较了
B+树是在B树上进行了改进
B+树的特点
1. 同样是N叉搜索树，每个结点包含多个key，N个key划分出N个区间
2. 每个结点的N个key中，会存在一个最大值
3. 每个结点的key，都会在子树中重复出现
（重复出现的好处：所有的数据都包含在叶结点这一层中）
4. 把叶结点站之间采用链式结构进行相连
1）此时进行范围查询，id&gt;=4 and &lt;= 10
先根据4找到对应的位置，沿着链表往后遍历到10就找到了
如果没有这个链式结构，就可能需要反复的对树进行回溯，就会很麻烦
2）针对B+树的查询时间是稳定的
查询任何一个元素，都是需要从根节点查询到子节点的
过程中经过的硬盘IO次数是一样的
3）只需要在叶结点存储数据，其他非叶节点存储key就行（这个key占用的空间很小）
数据库的事务 很多时候进行多个sql的操作，我们是希望将它们打包在一起的
第一个解决办法：不让数据库挂
但是数据库真挂了，我们也要有一个应对措施，采用事务
事务可以保证上面两个sql语句要么都执行成功，要么都不执行
（都不执行其实是有执行的，只是数据库恢复的时候，把数据都还原回去了，这叫回滚）
那数据库咋知道之前的数据是多少？
数据库对于事务有特殊的机制（undo log + redo log），通过日志打印，写道文件里
数据库中间挂了，但是日志已经记录下来了，数据库重启之后会读取之前的日志，对于在执行一半的事务会进行操作回滚
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/202622a107e08efc66f5a1a71167690e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5791e542166b3bbcbe860b9c01f2626b/" rel="bookmark">
			python selenuim TypeError: WebDriver.__init__() got an unexpected keyword argument ‘chrome_options‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python selenuim TypeError: WebDriver.__init__() got an unexpected keyword argument 'chrome_options' 运行客户端：Pycharm 运行程序如下：
from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() wd = webdriver.Chrome(chrome_options=options, executable_path=r'c:\chromedriver\chromedriver.exe') Run之后出现的错误如下。
TypeError: WebDriver.__init__() got an unexpected keyword argument 'chrome_options'/'executable_path' 在Anaconda里面是可以运行成功的，所以由此我们查询了其selenium版本。 而此时在Pycharm中，selenium的版本是 4.15.2的新版本，包括urllib3的版本。
解决方案： 一、统一变成低版本 可直接运行代码的版本。 ​​​​​​参阅：Selenium ｜AttributeError: 'WebDriver' object has no attribute 'find_element_by_class_name' - 老表爱技术https://www.cnblogs.com/rychh/p/17146472.html
二、维持Pycharm中版本不变，改代码去适应新版本的需求。 import time,os,re from selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.webdriver.chrome.options import Options from selenium.webdriver.chrome.service import Service service = Service(executable_path=r'c:\chromedriver\chromedriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5791e542166b3bbcbe860b9c01f2626b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d962681d9409af9831363f9f77ffc275/" rel="bookmark">
			element必填校验 输入空格问题，修改正则表达式、请求拦截器，实现所有输入框去除首尾空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、element-ui,必填校验输入空格是可以通过校验的？二、解决方案?v-model.trim修饰符?三、采用pattern，手写正则的方式实现功能功能。四、请求拦截器过滤所有的请求参数，对应的参数首尾空格全部去掉。 一、element-ui,必填校验输入空格是可以通过校验的？ 我们可以看一下elemen-ui的源码，
我们可以看到其实element-ui对应el-form-item关于必填校验的部分是采用了rules,rules.length去进行的校验 我们需要知道的是其实空格也同样算是一个字符。同样的空格那么肯定是会通过校验的，那么我们如何去实现不让其首尾输入空格呢？
二、解决方案?v-model.trim修饰符? 当然我们第一个想法想到的肯定是trim这个修饰符，首先我们可以看一下官网
我们可以试一试，当input新增了trim后会出现怎样的效果?
如果采用trim修饰符的话，确实可以实现功能，但是这个时候首尾都不能输入空格就会导致一个问题，当我们从左到右输入文字的时候
例如
1111 2222 我如果想写完1111立刻再输入几个空格再输入2222，这个时候如果我们采用的是trim便会遇到不能输入的问题，我们只能11112222输入完成之后再去讲鼠标光标放置在11112222中间部分输入空格，这样肯定是不利于我们输入的。
三、采用pattern，手写正则的方式实现功能功能。 我们只需要在我们对应的rules数组对象校验中新增这样一个正则写法即可。
pattern: ‘[^ \x20]+’
完整写法
loginRules: { username: [{ required: true, pattern: '[^ \x20]+', trigger: 'blur', message: '用户名不能为空' }], password: [{ required: true, pattern: '[^ \x20]+', trigger: 'blur', message: '密码不能为空' }], code: [{ required: true, pattern: '[^ \x20]+', trigger: 'change', message: '验证码不能为空' }], }, 四、请求拦截器过滤所有的请求参数，对应的参数首尾空格全部去掉。 当然上方的功能保证的其实也只是校验项 在开头部分输入空格会触发校验，但是我们在末尾输入空格的时候，对应的校验则不会再触发，这个时候我们则需要在进行搭配，写一个请求递归，实现所有请求参数的首尾去空格。
编写递归函数放置到我们请求拦截器当中
/** * @description: 2021-05-14 请求参数首尾去空格 * @param {*} data * @return {*} */ function isTrim(data) { // 首先需要判断当前的config中是否存在data值 if (data &amp;&amp; data instanceof Object) { for (const key in data) { if (Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d962681d9409af9831363f9f77ffc275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10da445341aa65193db9302787b772f6/" rel="bookmark">
			苹果微信小程序 从右往左滑动白屏问题记录：page-container标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微信小程序页面，从右往左滑动时，页面内容消失，变成白屏，通过调试助手发现show=true变成了show=false。具体是什么原因不太清楚，估计和小程序左滑到浮窗功能有关系。
&lt;page-container show="{{connected}}" position="center"&gt; &lt;/page-container&gt; 解决办法：
改成view标签后就没有问题了
&lt;view wx:if="{{connected}}" position="center"&gt; &lt;/view&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a779e3fb5caa360c6dde73653eba98a/" rel="bookmark">
			kafka详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、kafka 使用场景 1、异步 2、解耦 3、消峰 二、基本概念 kafka基础架构 1、Broker 消息中间件处理节点，一个 Kafka 节点就是一个 Broker，一个或者多个 Broker 可以组成一个 Kafka 集群。
2、Topic Kafka 的消息通过 Topic 主题来分类，Topic类似于关系型数据库中的表，每个 Topic 包含一个或多（Partition）分区。
3、Partition 多个分区会分布在Kafka集群的不同服务节点上，消息以追加的方式写入一个或多个分区中。
4、LogSegment 每个分区又被划分为多个日志分段 LogSegment 组成，日志段是 Kafka 日志对象分片的最小单位。LogSegment 算是一个逻辑概念，对应一个具体的日志文件（”.log” 的数据文件）和两个索引文件（”.index” 和 “.timeindex”，分别表示偏移量索引文件和消息时间戳索引文件）组成。
5、Offset： 每个分区中都由一系列有序的、不可变的消息组成，这些消息被顺序地追加到 Partition 中，每个消息都有一个连续的序列号称之为 Offset 偏移量，用于在 Partition 内唯一标识消息。
6、Message： 消息是 Kafka 中存储的最小最基本的单位，即为一个 commit log，由一个固定长度的消息头和一个可变长度的消息体组成。
7、Producer： 消息的生产者，负责发布消息到 Kafka Broker，生产者在默认情况下把消息均衡地分布到主题的所有分区上，用户也可以自定义分区器来实现消息的分区路由。
8、Consumer： 消息的消费者，从 Kafka Broker 读取消息的客户端，消费者把每个分区最后读取的消息的 Offset 偏移量保存在 Zookeeper 或 Kafka 上，如果消费者关闭或重启，它的读取状态不会丢失。
9、Consumer Group： 每个 Consumer 属于一个特定的 Consumer Group（若不指定 Group Name则属于默认的 group），一个或多个 Consumer 组成的群组可以共同消费一个 Topic 中的消息，但每个分区只能被群组中的一个消费者操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a779e3fb5caa360c6dde73653eba98a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5578a30e6bdfa207296df2464be9464d/" rel="bookmark">
			陀螺仪传感器-它们是如何工作的，未来会发生什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		陀螺传感器 陀螺传感器，又称角速率传感器或角速度传感器，是一种检测角速度的装置。
角速度
简单来说，角速度就是单位时间内旋转角度的变化量。
角速度通常用度/秒(度/秒)表示。
爱普生陀螺产品陀螺汽车陀螺标准视频:什么是陀螺?视频:物体的运动和加速度计的差异视频:爱普生陀螺仪传感器抗冲击视频:用于RVC, AGV的XV7000系列
陀螺传感器类型 陀螺仪传感器有多种类型。在这里，不同的类型是根据大小和性能绘制的。
近年来，振动陀螺仪传感器已被应用于小型摄像机和静止摄像机的摄像机震动检测系统、视频游戏的运动传感系统以及车辆电子稳定控制(防滑)系统等领域。
展望未来，在车辆驾驶员安全和支持系统以及机器人运动控制等领域，对振动陀螺仪的需求预计将增长。
爱普生陀螺仪产品为汽车陀螺仪标准
振动陀螺传感器 振动陀螺传感器通过施加在振动元件上的科里奥利力来感应角速度。由于这个原因，测量角速度的精度根据元件材料和结构的不同而有很大的不同。在这里，我们简要地描述了用于振动陀螺传感器的主要类型的元件。
振动陀螺仪传感器中使用的元件类型 振动陀螺仪传感器制造商正在使用各种材料和结构，努力设计紧凑、高精度的陀螺仪传感器，这些传感器具有良好的特性，包括:比例系数、温度频率系数、紧凑尺寸、抗震性、稳定性和噪声特性
爱普生陀螺仪产品为汽车陀螺仪标准
角速度传感如何工作(在振动陀螺传感器中) 振动陀螺仪传感器从施加在振动物体上的科里奥利力中感知角速度。
在这里，我们以爱普生的双t结构晶体元件为例，解释其工作原理。
爱普生陀螺仪产品为汽车陀螺仪标准
陀螺传感器应用 陀螺仪传感器主要有三种应用。
角速度传感感受产生的角速度。
用于测量运动本身的量。
例)检查运动员的动作角传感感知由传感器自身运动产生的角速度。角度是通过CPU的积分运算来检测的。
移动的角度被馈送到应用程序中并反映在应用程序中。
汽车导航系统
游戏控制器
细胞控制机制感知外部因素产生的振动，并将振动数据以电信号的形式传输给CPU。
用于校正物体的方向或平衡。
例)相机抖动校正
车辆控制
有趣的事实角速度在应用中的例子:•汽车导航系统:~10度/秒•车辆控制:~30度/秒•摄像机震动校正:~100度/秒•游戏控制器:~300度/秒•感知高尔夫顶级球员的挥杆:~ 3000度/秒
爱普生陀螺仪产品为汽车陀螺仪标准
示例应用程序 陀螺仪传感器在我们周围的产品中都有使用。
爱普生陀螺产品陀螺汽车陀螺标准视频:什么是陀螺?视频:XV7000系列，用于RVC, AGV
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68673d524c9afd45a7542daad92f4175/" rel="bookmark">
			机器人控制器，人形机器人行动之脑，全球本体厂商必争之地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天分享的机器人行业系列深度研究报告：《机器人控制器，人形机器人行动之脑，全球本体厂商必争之地》。
（报告出品方：申万宏源研究）
报告共计：45页
1.控制器 : 人形机器人之“大脑&amp;小脑 1.1 控制器 : 人形机器人核心基础
人形机器人控制器框架通常包括感知、语音交互、运动控制等层面。
1)视觉感知层由硬件传感器，算法软件组成，实现识别、3D建模、定位导航等功能;2)运动控制层由触觉传感器、运动控制器等硬件及复杂的运动控制算法组成，对机器人的步态和操作行为进行实时控制;3)交互算法层:包括语音识别、情感识别、自然语言和文本输出等。
以UCLA的人形机器人平台ARTEMIS为例，其控制架构包括硬件接口、仿真界面、控制器接口、安全接口，由中央处理器(CPU)来共享和存储数据和信息。由于目前人形机器人技术方案尚未定型，技术快速迭代，控制器适合采用模块化结构，从而便于更换组件，简化创建不同控制器组合的过程。①硬件接口:包括执行器、惯导(IMU)、传感器等，反馈关节位置、速度、扭矩等数据信息;②仿真界面:模仿硬件接口的功能从而进行仿真环境的模拟测试;③控制器接口:读取到内外部环境信息后，对运动控制器等发送指令;④安全接口:在检测到任何错误行为时关闭机器。
运动控制器是人形机器人控制架构中最重要且复杂的模块之一。对于人类而言，人类可以结合使用不同的感官，如视觉、触觉和听觉等来应对环境中的不确定性，经过长时间的走路训练，运动控制早已内化为“下意识”动作，对于机器人而言，如果机器人在不平坦地面和不确定的外部环境中进行动态运动，运动控制器需要实时调整其计划和轨迹，并协调双足和全身肢体的状态。
1.2 技术攻关关键环节，国家政策重点支持
“大脑”和“小脑”是人形机器人产业化落地的关键所在，也是技术难点所在，不仅是各家人形机器人厂商竞争的关键点，也是目前政策层面重点支持的环节。在今年两大工信部发布的人形机器人重磅政策中，“运动控制”均放在关键位置。
1.3 横向对比成熟产业，底层原理殊途同归
1.3.1 工业机器人 vs 人形:控制精度和工艺理解要求更高
工业机器人控制器作为机器人的“大脑”，具有控制机械臂的工作状态、运动轨迹空间位置、操作顺序等功能。工业机器人对控制器的基本要求包括:@控制工业机器人的位置、速度、加速度等，对连续轨迹运动的机器人还要有轨迹规划和插补运算功能;@人机交互:工作人员使用示教器、操作面板，对机器人进行编程等;@外部感知:部分场景需要工业机器人对视觉、力觉、触觉等有关信息进行测量感知，有时需要与其他设备交换信息和协调工作。
工业机器人控制器通常是PC-Based 控制，由硬件和软件组成:
①硬件:硬件由工控计算机和示教器(示教编程使用)/电脑面板(离线编程使用)组成。其中，工控计算机由 PCB 电路板(将电子元器件与电气连接)、IC芯片(晶体管电阻、电容等微电子元器件形成的集成电路)、晶体管(基于输入电压控制输出电流、电阻电容(阻碍电流，在电路中起分压、分流、限流等作用)组成。工控计算机另外包含操作面板、通信接口、网络接口、传感器接口和驱动器接口等。②软件:软件由控制算法和二次开发(客户定制化开发)，部分工业机器人采用示教编程，工作人员通过示教器控制工控计算机;部分工业机器人需要工作人员进行离线编程，生成机器人的运行轨迹。
机器人控制器架构分为集中控制、主从控制、分布控制三种类型
1)集中控制是由一台机器人实现全部控制功能，结构简单，成本低;但实时性差，难以拓展，可靠性低，是早期机器人的常用结构;
2)主从控制是采用主、从两级处理器实现系统的控制功能，主CPU实现管理、坐标变换、轨迹生成和系统自诊断等，从CPU 实现所有关节的动作控制，实时性好，适用于高精度、高速场景;但系统扩展性较差，维修困难;
3)分布控制采用“分散控制，集中管理”思路，系统对总体目标和任务进行综合协调和分配，子系统协调来完成控制任务;其特点为灵活性好，可靠性提高，有利于系统功能的并行执行，提高效率，易于拓展，可实现智能控制，缺点为当自由度数量和算法变得复杂时，控制性能会恶化。
1.3.2 扫地机器人 VS 人形: 简的移动型机器人框架
扫地机器人系统可以分为以下几个子系统:传感器、控制器、驱动电机、电池及电源管理等部分。首先，扫地机器人通过激光雷达、摄像机以及多种传感器构建的"感知层”将环境的信息传递给扫地机器人的"大脑”导航系统利用这些传感器提供的数据利用SLAM算法，通过软件的方式进行路径规划，确保机器人在空间中准确定位自己的位置并构建环境地图地图建立完成后导航系统将其传递给MCU芯片MCU芯片主要负责运动控制根据地图信息和路径规划，精确地指导扫地机器人进行清洁工作。
人形机器人的控制原理与扫地机器人相似:
1)扫地机器人控制器主要用来规划路径避障，以及人机交互。例如:人类设定打扫范围，以及语音指导扫地机器人进行打扫，由数字信号处理器和微控制器对执行层(电机)进行控制和回馈外部信息。小米及 TCL 等扫地机器人采用意法半导体的 M3 微控制芯片作为路径规划的控制芯片。
2)人形机器人控制器涵盖运动规划和人机交互，运动控制器接收当前广义坐标、力矩和接触状态，并计算所需的前馈力矩和关节反馈，进而控制执行器的状态。
区别在于:人形机器人控制器所需的算法实时性要求高，控制器处理能力远高于扫地机器人。人形机器人的执行器和传感器数量更多，并且要求在尽可能短的时间内完成感知.决策规划和运动控制以及反馈，对软硬件的响应程度和配合要求较高。另外，基于软件算法的研发及模型化执行和操作对算力要求也很高。
1.3.3 汽车控制器 VS 人形:涉及环节更复杂，车规级要求
从HW2.0起，特斯拉开始采用自研智驾域控制器，FSD(完全自动驾驶)是特斯拉推出旨在实现全无人驾驶的智驾产品。其由多颗英伟达芯片构成的算力平台，8颗1.2MP的摄像头接入到域控当中，并与毫末波雷达信息进行融合。当前大规模部署的 HW3.0特斯拉对域控算力进行了大升级从英伟达的算力平台改为自研的FSD芯片和NPUGPU算力提升了12倍，每秒可以处理的视频数也提升了将近21倍。
基于功能集中分区，智能驾驶汽车电子控制系统分为动力域、底盘域、座舱域、自动驾驶域和车身域五域。其中，自动驾驶域是现阶段承载整车个性化智能体验的关键所在也是目前车企的竞争焦点和布局重点。在现阶其功能开发和实现需要涉及大量AI运算因此对芯片所提供算力、操作系统底层算法要求很高;而其他域控制器涉及整车安全的部件较多，因此对功能安全等级要求更高，对芯片算力要求和功能智能化程度相对较低。
自动驾驶汽车域控制器和人形机器人的控制器的结构和控制原理类似。
1)自动驾驶域能够使车辆具备多传感器融合、定位、路径规划、决策控制、图像识别高速通讯、数据处理的能力。自动驾驶域通常需要外接多个摄像头、毫米波雷达、激光雷达等等车载传感器来感知周围环境，通过传感器数据处理及多传感器信息融合，以及适当的工作模型制定相应的策略，进行决策与规划。域控制器的输入为各项传感器的数据，所进行的算法处理涵盖了感知、决策、控制三个层面，最终将输出传送至执行机构，进行车辆的横纵向控制。
2)机器人运动控制器充当着大脑和小脑的作用，用来控制机器人的肢体行为。比如机器人行走这一动作,需要根据感知的环境规划出目标路径经由运动规划( LocomotionPlanner)生成参照投影，产生步伐运动行走方案，再由运动控制器转化为机器人身上各个执行器的扭矩、速度输出，呈现为机器人按照运动规划的步伐方案前进。
1.3.4 Tesla FSD vs Optimus
2023年11月25日特斯拉已经向员工推出全自动驾驶(FSD)V12 版本这一版本将实现全新的“端到端自动驾驶”技术，首次采用神经网络进行车辆控制，包括转向加速和制动，摒弃了之前超过30万行的代码，更加依赖神经网络，减少了对硬编码编程的依赖。FSDV12通过将摄像头获取的图像数据输入神经网络，使网络能够直接输出车辆控制指令，如转向、加速、制动等。这种方法更类似于人类大脑的工作方式，其中99%的决策都由神经网络完成，不再需要高精度地图或激光雷达。仅凭借车身摄像头的视觉输入系统能够进行分析和思考，输出相应的控制策略。
2.工控领域: 控制器发展成熟，国产替代潜力巨大 2.1 控制器经上百年发展，多种技术路线共进
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68673d524c9afd45a7542daad92f4175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c23e0b116e867893f4a0b5dcd270476/" rel="bookmark">
			组合数学历年真题-西北工业大学-持续更新中~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合数学历年考题使用说明 本文档设立的初衷是帮学弟学妹们获得一份免费且纯净的组合数学习题，把注意力和时间花在知识本身而不要浪费在筛选垃圾资料上。截止本文档创立时，学校并未提供官方习题内容，所有内容均为学长手动整理且部分为回忆版本，难免有错误、遗漏，请大家见谅。
本文档开源地址为https://gitee.com/Cheney822/nwpu-comb，转载请附原地址。欢迎广大校友积极在本仓库提交新的内容，或者修正错误。
组合数学参考资料 这里给出一些学习组合数学的参考资料：
课本：《组合数学》-第五版-清华大学出版社-卢华明
习题册：《组合数学习题解答》-第四版-清华大学出版社-卢华明
推荐刷题之前做做这本书上的题，题目范围覆盖很广，可以作为课后习题练习。
刷历年考题时遇到不会的也可以参考这本书上同类型的题。
PPT：（不太推荐）老师给的PPT比较老，格式和内容都有不少错误。建议听课的时候在课本上标记重难点。
网课：推荐清华大学马昱春老师的组合数学网课（学堂在线平台可以免费学习）
真题示例 部分真题 2016.1 一、以下七个小题，每小题10分，考生可任选其中六题作答，共60分 在字典序法生成1-5这五个数的全排列，25431的下一个排列是什么？ 若规定12345是第0号排列，54321是第 5 ! − 1 = 119 5!-1=119 5!−1=119号排列，则25431是字典序法中的第几号排列？从1至20这20个数中任选互不相邻的三个数，共有多少种选法？有多少个由奇数个0和奇数个3偶数个2，而1、4的个数任意的n位5进制数？求不大于120素数的有多少个。求从任意多个a，3个b，5个c，7个d 可重复地任取10个的方案数。在一个8X8方格的国际象棋棋盘上放置一个红色、四个白色、三个黑色的八个车，保证它们不能互相攻击，问有多少种放置方法。证明： ( n 2 ) ! ( n ! ) n + 1 \frac{(n^2)!}{(n!)^{n+1}} (n!)n+1(n2)!​是一个整数。 二、（8分） 已知一数列满足条件： A 1 = 1 , A 2 = 2 , A n − 4 A n − 1 − 5 A n − 2 = 0 ( n = 3 , 4 , … … ) A_1=1,A_2=2,A_n-4A_{n-1}-5A_{n-2}=0 \quad(n=3,4,……) A1​=1,A2​=2,An​−4An−1​−5An−2​=0(n=3,4,……)，试给出 A n A_n An​通项公式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c23e0b116e867893f4a0b5dcd270476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36237595dbfaa848aba32c6906b9c97c/" rel="bookmark">
			基于VUE3的任意缩放与拖拽组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		V3DragZoom 一个基于 vue3 开发的轻量、高效缩放拖拽组件，方便开发者快速实现缩放拖拽功能。
在线演示和使用手册(DEMO) GIT地址 https://gitee.com/ericfang/v3-drag-zoom
安装 使用以下命令安装 v3-drag-zoom：
npm install v3-drag-zoom # 或 yarn add v3-drag-zoom 导入组件 全局导入 在 main.js 中全局引入 v3-drag-zoom：
import {createApp} from "vue"; import App from "./App.vue"; // v3-drag-zoom 组件 import V3DragZoom from "v3-drag-zoom"; // v3-drag-zoom 全局样式（必须导入，否则无法正常使用） import "v3-drag-zoom/dist/style.css"; createApp(App).use(V3DragZoom).mount("#app"); 按需导入 在需要的组件中导入 v3-drag-zoom：
&lt;script setup lang="ts"&gt; import {V3DragZoomContainer} from "v3-drag-zoom"; &lt;/script&gt; &lt;template&gt; &lt;v3-drag-zoom-container&gt; &lt;div&gt;需要缩放与拖拽的元素&lt;/div&gt; &lt;/v3-drag-zoom-container&gt; &lt;/template&gt; API参数 v3-drag-zoom-container Props 参数名类型默认值说明alignStringcontain内容对齐方式，可选值有 auto、 contain、coverautoResizeBooleantrue是否自动重置尺寸，当容器尺寸为百分比的时候，会根据父容器变化而自动变化followPointerBooleantrue缩放时是否跟随鼠标maxZoomFloat100最大缩放倍数minZoomFloat0.01最小缩放倍数zoomFactorFloat0.1鼠标滚轮一次的缩放比例loadingBooleanfalse是否加载中animateDurationNumber200缩放时候的过度动画时长，单位 ms Slots Slot说明default直接填写需要放置的内容 Exposed 参数名类型说明zoom(zoom:Float) =&gt; void手动缩放 zoom: 为缩放倍数reset() =&gt; void重置缩放 v3-drag-zoom-item Props 参数名类型默认值是否必须说明offsetArray&lt;Integer&gt;[-50,-50]否偏移量，默认值代表横向和纵向均偏移 -50%，也就是对齐中心点位置，偏移量单位为 %, 不支持 pxfixedSizeBooleanfalse否是否固定大小， true代表在缩放过程中该item内容尺寸不变rotateFloat0否旋转角度单位 deg (360度）draggableBooleanfalse否是否可以拖拽移动position(v-model)CurPosition无是该 item 在内容中的位置（百分比位置） Slots Slot说明default直接填写需要放置的内容 Events 事件名参数说明onMove( pos :Position)=&gt; void每移动一点距离触发，返回当前位置onMoveFinished( pos :Position)=&gt; void移动结束（鼠标抬起或超出范围）触发， 返回当前位置 CurPosition 参数名类型默认值是否必须说明xFloat无是横向位置 %yFloat无是纵向位置 % Position extend CurPosition 参数名类型默认值是否必须说明xFloat无是横向位置 %yFloat无是纵向位置 %sub(pos:Position)=&gt;Position无否计算当前 Position 与 pos 之间的差值 new Position(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36237595dbfaa848aba32c6906b9c97c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca991d3e4a43cb3dce57cb72de27ea95/" rel="bookmark">
			Effective C&#43;&#43;(四): 资源管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、智能指针驱动的RAII二、shared_ptr 和 weak_ptr三、如何复制 RAII 对象四、在资源管理类中应该提供对原始资源的访问函数 为了防止忘记调用 delete 造成的内存泄露，我们应该尽可能让对象管理资源，并且采用 RAII 机制(Resource Acquisition is Initialize)机制，让析构函数负责资源的释放。
一、智能指针驱动的RAII 在cpp11中，可以使用unique_ptr 或者 shared_ptr两种智能指针来管理内存。其中 unique_ptr 通过专一所有权来管理 RAII 的对象，而shared_ptr通过引用计数来管理。
std::unique_ptr pUniqueInv1(CreateInvestment());
std::unique_ptr pUniqueInv2(std::move(pUniqueInv1));
std::shared_ptr pSharedInv1(CreateInvestment());
std::shared_ptr pSharedInv2(pSharedInv1); /
std::shared_ptr pSharedInv2(std::move(pSharedInv1))
std::move(pSharedInv1)返回的是pSharedInv1的右值引用，也就是一个std::shared_ptr&amp;&amp;类型，在执行完这句之后，pSharedInv1就变成了一个空指针 nullptr，而pSharedInv2现在拥有原本属于pSharedInv1 的对象。 请注意在调用std::shared_ptr 的移动构造函数的时候，shared_ptr的引用技术不变。
智能指针默认会自动 delete 所持有的对象，我们也可以为智能指针指定所管理对象的释放方式（删除器deleter):
// void GetRidOfInvestment(Investment*) {}
std::unique_ptr&lt;Investment, decltype(GetRidOfInvestment)*&gt; pUniqueInv(CreateInvestment(), GetRidOfInvestment);
std::shared_ptr pSharedInv(CreateInvestment(), GetRidOfInvestment);
在这里decltype的作用是:
二、shared_ptr 和 weak_ptr 一个很常见的面试问题是能否使用 weak_ptr来实现 RAII ？ 答案显然是否定的。 首先介绍一下weak_ptr, weak_ptr是一种用于解决 shared_ptr的循环计数死锁的智能指针。一个例子如下：
#include &lt;memory&gt; #include &lt;vector&gt; class Child; class Parent { public: std::vector&lt;std::shared_ptr&lt;Child&gt;&gt; children; void addChild(const std::shared_ptr&lt;Child&gt;&amp; child) { children.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca991d3e4a43cb3dce57cb72de27ea95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb5b8699716aa3b7f3c2783fd0cbf23/" rel="bookmark">
			最简单粗暴方式更新kubeadm安装1.15.1版本证书有效期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 延迟一年有效期 ###在 Kubernetes 1.15.1 版本中，kubeadm 不提供直接修改证书有效期的功能。默认情况下，Kubernetes 的证书有效期为一年。
如果您希望修改证书的有效期，需要通过以下步骤重新生成证书： cd /etc/kubernetes/pki 首先备份现有的证书和密钥文件。这些文件通常位于 /etc/kubernetes/pki/ 目录下。 tar -czvf certificates_backup.tar.gz /etc/kubernetes/pki/* 查看证书使用年限 openssl x509 -in apiserver.crt -text -noout 使用 kubeadm alpha certs renew 命令来生成新的证书和密钥文件： kubeadm alpha certs renew all 重新启动 kubelet: systemctl restart kubelet 此时，kubelet 应该使用新生成的证书。
请注意，Kubernetes的证书管理是一个复杂的过程，并且可能会影响集群的稳定性。在进行任何更改之前，请确保您完全理解操作的风险，并确保已经创建了合适的备份。强烈建议在生产环境之外的测试集群上进行这些操作，并在生产环境之前仔细测试。
验证证书使用年限 openssl x509 -in apiserver.crt -text -noout 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0963310c737aa7a5c47c06e4644f27/" rel="bookmark">
			安卓发布小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多个版本 apk多版本共存
如果是git多个分支，可只修改build.gradle里的applicationId。
SDK升级后缩包 Android M 的 NDK 行为变更对 APK 包体积的影响
安卓车载 Android车载开发与设备调试学习手册
tobecontinue…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e46d35632d71272e4464b8bd8c0480/" rel="bookmark">
			Linux 启动流程 -- BIOS/UEFI &amp; bootloader &amp; kernel &amp; initramfs &amp; systemd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 启动流程 -- BIOS/UEFI &amp; bootloader &amp; kernel &amp; initramfs &amp; systemd 0. 概述1. BIOS/UEFI 启动阶段2. 内核引导阶段2.1 分区类型2.1.1 MS-DOS2.1.2 GPT 2.2 引导方式2.2.1 legacy + mbr/ms-dos + grub22.2.2 uefi + grub2 3. 内核启动阶段4. systemd 启动阶段4.1 sysinit.target4.2 basic.target4.3 initrd.target4.4 switch-root4.5 multi-user.target 参考文档 最近重新整理了整个启动流程，可以参考 OpenCloudOS Stream 操作系统启动流程分析
0. 概述 从加电到出现登录界面，整个流程大致如下（基于 CentOS Linux release 8.2.2004 (Core)）：
BIOS/UEFI ==&gt; bootloader ==&gt; kernel ==&gt; initramfs ==&gt; systemd(initramfs) ==&gt; switch-root ==&gt; systemd(real rootfs)
可以将上述过程粗略的划分为四个阶段：
BIOS/UEFI 启动阶段内核引导阶段内核启动阶段服务启动阶段 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77e46d35632d71272e4464b8bd8c0480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d517953451868869b3688a84a7b545de/" rel="bookmark">
			常用命令行-脑子不好使备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker
1.提交 docker commit -a "runoob.com" -m "my apache" a404c6c174a2 mymysql:v1 -a :提交的镜像作者； -m :提交时的说明文字； 2.保存tar docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3 3.run docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS说明： -i: 以交互模式运行容器，通常与 -t 同时使用； -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； -d: 后台运行容器，并返回容器ID； --name="nginx-lb": 为容器指定一个名称； -h "mars": 指定容器的hostname； -m :设置容器使用内存最大值； --volume , -v: 绑定一个卷 docker run -it --gpus all --ipc=host --name yolov8_envs -v /home1/nfj/:/home yolov8:v1 /bin/bash 4.attach 和 exec 二者区别：attach 直接进入容器启动命令的终端，不会启动新的进程，exec 是在容器中打开新的终端，并且可以启动新的进程 attach 进入的终端，使用命令exit退出会使容器停止，exec 不会。所以使用attach 进入终端必须使用组合按键【ctrl+p+q】退出终端。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91591cd836cba0bd8da65d08a7c3800e/" rel="bookmark">
			什么是http加密协议，实现步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP加密协议指的是通过加密方式对HTTP通信进行保护的协议，也被称为HTTPS。它使用了安全套接字层（SSL）或传输层安全（TLS）协议来加密和保护HTTP通信的内容。
实现HTTP加密协议的步骤如下：
1. 证书申请：首先，服务器需要获取一个数字证书来验证其身份。这可以通过向数字证书颁发机构（CA）提交证书申请完成。证书包含了服务器的公钥和相关信息。
2. 证书验证：CA会对服务器的身份进行验证，并签发数字证书。服务器收到数字证书后，会验证证书的有效性和CA的可信任性。
3. 配置服务器：服务器需要安装和配置SSL/TLS证书。这涉及将证书和私钥配置到服务器软件（如Apache或Nginx）中。
4. 握手过程：当客户端发送HTTPS请求时，服务器会返回一个数字证书给客户端。客户端会验证证书的合法性和可信任性。如果验证通过，客户端会生成一个随机的对称密钥，然后使用服务器的公钥来加密该密钥，并发送回服务器。
5. 加密通信：服务器收到客户端发送的加密密钥后，使用私钥解密得到对称密钥。然后，服务器和客户端都使用该对称密钥进行加密和解密HTTP通信内容。
通过以上步骤，HTTP加密协议可以确保通信内容的机密性和完整性，防止信息被窃听或篡改。这对于敏感数据（如登录信息、银行交易等）的传输非常重要。
实现HTTPS的代码步骤可以分为以下几个主要部分：
1. 证书生成和配置：
- 生成服务器私钥和证书签名请求（CSR）。
- 将CSR发送给证书颁发机构（CA）进行签名，或者自签名证书。
- 配置服务器软件以使用生成的私钥和证书。
2. 设置服务器：
- 安装和配置Web服务器软件（如Apache或Nginx）。
- 配置服务器以监听HTTPS请求的端口（通常是443）。
- 配置服务器以使用正确的证书和私钥。
3. 加密通信：
- 客户端发送HTTPS请求时，通过使用HTTP库（如Python中的requests库）将请求发送到HTTPS URL。
- 服务器收到请求后，通过解析URL和请求头等信息获取所需的数据。
- 服务器通过SSL/TLS进行加密和解密数据，以确保通信的安全性。
以下是一个简单的Python示例程序，使用requests库发送HTTPS请求：
```python
import requests
# 设置HTTPS URL
url = "https://example.com"
# 发送HTTPS GET请求
response = requests.get(url)
# 打印响应内容
print(response.text)
```
请注意，上述示例仅涉及客户端发送HTTPS请求的部分。在实际应用中，还需要根据具体的服务器软件和编程语言来配置和处理HTTPS请求。并且，为了确保安全性，请务必使用真实有效的证书，而不是自签名证书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3902fc2aea631182f6bde707714dcb60/" rel="bookmark">
			Scala 从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scala 从入门到精通 数据类型 pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.lihaozhe&lt;/groupId&gt; &lt;artifactId&gt;scala-code&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;name&gt;${project.artifactId}&lt;/name&gt; &lt;properties&gt; &lt;jdk.version&gt;21&lt;/jdk.version&gt; &lt;!-- 公共配置 --&gt; &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;21&lt;/maven.compiler.compilerVersion&gt; &lt;maven.compiler.encoding&gt;utf-8&lt;/maven.compiler.encoding&gt; &lt;project.build.sourceEncoding&gt;utf-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.test.failure.ignore&gt;true&lt;/maven.test.failure.ignore&gt; &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt; &lt;commons-dbutils.version&gt;1.8.1&lt;/commons-dbutils.version&gt; &lt;commons-io.version&gt;2.14.0&lt;/commons-io.version&gt; &lt;commons-lang3.version&gt;3.13.0&lt;/commons-lang3.version&gt; &lt;druid.version&gt;1.2.20&lt;/druid.version&gt; &lt;fastjson.version&gt;2.0.41&lt;/fastjson.version&gt; &lt;gson.version&gt;2.10.1&lt;/gson.version&gt; &lt;hutool.version&gt;5.8.22&lt;/hutool.version&gt; &lt;jackson.version&gt;2.15.3&lt;/jackson.version&gt; &lt;junit.version&gt;5.10.0&lt;/junit.version&gt; &lt;lombok.version&gt;1.18.30&lt;/lombok.version&gt; &lt;mysql.version&gt;8.2.0&lt;/mysql.version&gt; &lt;scala.version&gt;2.13.12&lt;/scala.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-tools.testing&lt;/groupId&gt; &lt;artifactId&gt;specs_2.10&lt;/artifactId&gt; &lt;version&gt;1.6.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.scalatest&lt;/groupId&gt; &lt;artifactId&gt;scalatest_2.13&lt;/artifactId&gt; &lt;version&gt;3.2.15&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;!-- 作用域 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3902fc2aea631182f6bde707714dcb60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d6c97cd59348584e9830032d79a6857/" rel="bookmark">
			【2023TUCTF&amp;NBCTF】Crypto&amp;Web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: 2023TUCTF&amp;NBCTF-Crypto&amp;Web
tags: ctf-contest
categories: ctf-contest
博客传送门
文章目录 2023 TUCTF &amp; NBCTFTUCTF-CryptoCustom ECB Cipher | SOLVED题面：题目：考点：ECB 异或移位算法的逆向解题： Keyboard Cipher | SOVLED题面：题目：考点：基础编码转换 键盘密码解题： Table Encryption | SOLVED题面：题目：考点： 文件解密解题： Bludgeon the Booty | SOLVED题面：考点：连接服务器暴力破解解题： NBCTFcrypto/Rivest Shamir forgot Adleman | SOLVED题面：考点：异或题目：解题： crypto/32+32=64 | SOLVED题面：考点：base64题目：解题： crypto/SBG-ABW's Insanity | SOLVED题面：题目：考点：gcd 整数分解 AES ECB解题： crypto/Too Little Information | SOLVED题面：题目：考点：移位 CopperSmith解题： web/Inspector Gadget题面：题目：考点：信息收集 web/walter's crystal shop题面：题目：考点：代码审计 SQL注入解题： web/secret tunnel题面：题目：考点：SSRF解题： web/Galleria题面：题目：考点：代码审查解题： 2023 TUCTF &amp; NBCTF TUCTF-Crypto 网址：https://ctfd.tuctf.com/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d6c97cd59348584e9830032d79a6857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814906bb17fb8c801f0393058ef3d024/" rel="bookmark">
			[React]基于Antd的FormModal的组件封装以及useFormModal的hooks封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[React]基于Antd的FormModal的组件封装以及useFormModal的hooks封装 场景 很常见，打开弹窗输入表单等…
封装后，弹窗自行挂载到body上，只需关注表达逻辑和打开关闭逻辑，其它的已经帮你管理好了
源码 import React, { useRef, useMemo, memo, forwardRef, useCallback, useState, useImperativeHandle, useEffect } from 'react'; import { Modal, Form } from 'antd'; import type { ModalProps } from 'antd'; import { createPortal, render, unmountComponentAtNode } from 'react-dom'; export const MyModal = memo(forwardRef((props: any, ref) =&gt; { useEffect(() =&gt; { console.log('modal had mounted') }, []) const [form] = Form.useForm(); const [modalChildren, setModalChildren] = useState&lt;React.ReactElement | null&gt;(null); const [modalProps, setModalProps] = useState&lt;ModalProps&gt;({ visible: false, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/814906bb17fb8c801f0393058ef3d024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5c2d7aeaade0fd1530326a1d8bc878/" rel="bookmark">
			【NLP】如何管理大型语言模型 (LLM)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是LLM编排？ LLM 编排是管理和控制大型语言模型 (LLM)的过程，以优化其性能和有效性。这包括以下任务：
提示LLM：生成有效的提示，为LLMs提供适当的背景和信息以产生所需的输出。链接LLM： 结合多个LLM的输出以获得更复杂或更细致的结果。管理LLM资源： 有效分配和管理LLM资源以满足应用程序的需求。监控LLM绩效： 跟踪指标以识别和解决问题。 随着 LLM 被用于更广泛的应用（例如自然语言生成、机器翻译和问答），LLM 编排变得越来越重要。通过有效编排LLM，开发人员可以构建更强大、更可靠的应用程序。
有几种不同的 LLM 编排框架可用，每种框架都有优点和缺点。一些流行的框架包括：
LangChain： 一个提供与 LLM 交互的高级 API 的框架。LlamaIndex： 一个允许开发人员使用 LLM 查询其私有数据的框架。 LLM编排框架的选择将取决于应用程序的具体需求。开发人员应考虑诸如所使用的 LLM 类型、应用程序的复杂性以及对编排过程的所需控制级别等因素。
LLM编排有什么好处？ LLM 编排提供了许多好处，可以显着增强基于 LLM 的应用程序的开发和部署。这些好处包括：
1. 提高开发人员生产力： LLM 编排框架通过提供高级 API 并自动执行许多底层任务（例如提示生成、资源管理和性能监控），简化了与 LLM 的合作。这种抽象使开发人员能够专注于其应用程序的核心功能，而不是陷入 LLM 管理的复杂性中。
2. 提高应用程序性能： LLM编排框架优化了LLM资源的利用率，确保LLM得到有效利用，以满足应用程序的需求。此优化可提高应用程序性能、减少延迟并增强响应能力。
3. 降低开发成本： LLM编排框架可以通过简化和提高应用程序性能来显着降低开发成本。开发人员可以花更少的时间解决 LLM 相关问题，而将更多时间用于创建创新功能。
4. 提高可扩展性和可靠性： LLM 编排框架可以跨多个节点或机器无缝扩展基于 LLM 的应用程序。这种可扩展性确保应用程序可以处理不断增长的工作负载，并在需求繁重的情况下保持一致的性能。此外，LLM 编排框架提供强大的监控和错误处理机制，增强了基于 LLM 的应用程序的整体可靠性。
LLM 编排对于释放大型语言模型的全部潜力至关重要。通过为 LLM 管理提供结构化且高效的方法，LLM 编排使开发人员能够构建更强大、可扩展且可靠的应用程序，利用这种尖端技术的变革力量。
什么是 LLM 编排框架？ LLM 编排框架提供了用于管理和控制大型语言模型 (LLM) 的高级接口。它们抽象化了提示生成、资源管理和性能监控的复杂性，使开发人员能够轻松地与LLM进行交互。LLM编排框架可以通过简化开发流程来显着提高开发人员的工作效率和应用程序性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d5c2d7aeaade0fd1530326a1d8bc878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a7ca34702ca710043009ec89d6035b/" rel="bookmark">
			阿里云生态离线数仓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 大数据开发治理平台 DataWorks 功能齐全：10多年大数据建设沉淀完整的平台，覆盖数据开发治理的全生命周期
简单易用：全图形化界面，SQL为主的数据开发方式
安全稳定：双11日千万级任务稳定调度，金融级数据安全保障
开放兼容： 支持多种大数据引擎绑定，开放OpenAPI定制化对接能力
2. 大数据计算服务 MaxCompute 2.1 云原生，极致弹性，总体拥有成本低 云原生设计，无服务器架构，支持秒级弹性伸缩，快速实现大规模弹性负载需求
按作业计费，不使用不收费，相比自建 IDC 综合成本只需1/5
2.2 简单易用的多功能计算服务 预置多种计算模型和数据通道能力，开通即用
通过联合计算平台，支持多套引擎
联邦计算支持 Hadoop 数据源的融合计算
2.3 领先的智能化计算服务 智能化数据冷存，实现自动数据存储分级
智能计算优化，大幅降低人工调优成本
2.4 完善的企业级平台服务 承诺99.9%可用性 SLA
支持开放生态，提供企业级安全管理能力。与阿里云众多大数据服务无缝集成
3. 基于阿里云DataWorks&amp;MaxCompute搭建数据仓库（离线） 阿里云产品简介类比开源框架DataWorks大数据开发治理平台，存储DataX/Cana//DolphinScheduler
AirFlow/Azkaban/Atlas/GriffinRDS关系型数据库，采集MySqlQuickBl可视化数据展示工具，展示Tableau、Echarts、KibanaMaxCompute云原生大数据计算服务Hadoop+Hive+调度器 4. 数据仓库 数据仓库定义 (Data Warehouse)是为企业所有决策制定过程，提供所有系统数据支持的战略集合。
数据仓库VS传统数据库存储三大优势:
(1) 体量大，效率高
(2) 历史追查，时光回溯
(3) 数据可用性强
5. 系统数据流程设计 事实表：介绍业务流程本身，一个动作 -&gt; 明细数据层
维度表：时间地点人物，表述业务流程的环境 -&gt; 公共维度层
7. DataWorks和MaxCompute DataWorks基于阿里云MaxCompute/Hologres/EMR/CDP等大数据引擎，为数据仓库/数据湖/湖仓一体等解决方案提供统一的全链路大数据开发治理平台。作为阿里巴巴数据中台的建设者，DataWorks从2009年起不断沉淀阿里巴巴大数据建设方法论，同时与数万名政务/金融/零售/互联网/能源/制造等客户携手，助力产业数字化升级。
MaxCompute是面向分析的企业级 SaaS 模式云数据仓库，以 Serverless 架构提供快速、全托管的在线数据仓库服务，消除了传统数据平台在资源扩展性和弹性方面的限制，最小化用户运维投入，使您可以经济并高效的分析处理海量数据。数以万计的企业正基于 MaxCompute 进行数据计算与分析，将数据高效转换为业务洞察。
盘古：相当于Hadoop中的HDFS
伏羲：相当于Hadoop中的YARN
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38a7ca34702ca710043009ec89d6035b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853f0f5204ee8304cdc88c375a4e4cda/" rel="bookmark">
			泛型引入 入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑两个类：
class Dog{ private String name; private int age; public Dog(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } class Cat{ private String name; private int age; public Cat(String name, int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/853f0f5204ee8304cdc88c375a4e4cda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7798a43dc971817cfa8a27a89cdc4f3/" rel="bookmark">
			从能量守恒推导角动量守恒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一根绳子拉着一个小球，小球在一个光滑（摩擦力为0）平面上做匀速圆周运动。
设小球的质量为m，小球运动的初始半径为 r 0 r_{0} r0​，此时小球运动的线速度为 v 0 v_{0} v0​，可以计算出小球受到的初始拉力 F 0 = m v 0 2 / r 0 F_{0}=mv_{0}^{2}/r_{0} F0​=mv02​/r0​。
随着绳子慢慢收紧，小球的运动半径减小，小球的运动速度在增加（因为绳子拉力对小球做功，这部分功全部转换为了小球动能，动能增加速度增加），小球受到的绳子的拉力也在增加。
在绳子收紧的整个过程中，小球每一时刻的运动都可以看做是匀速圆周运动，而匀速圆周运动的拉力和速度关系是固定的。这样我们就可以通过每一刻的速度来求出每一刻的拉力。我们有了每一时刻的拉力，就能利用积分求出整个过程绳子对小球做的功，这些功就等于小球动能的增加。
再利用能量守恒定律，小球在速度为 v v v，半径为 r r r时候的动能，减去绳子对小球做的功，等于小球的初始动能，也就是小球速度为 v 0 v_{0} v0​，半径为 r 0 r_{0} r0​时的动能。
这两个方程联立，可否推导出小球在半径为 r r r时候和它的速度 v v v的关系呢？
整个过程要求不使用动量守恒公式，因为我的目的是通过这个过程验证在能量守恒的前提下，能否推导出角动量守恒（即 r m v rmv rmv为常数）。
要推导出小球在半径为 r r r 时的速度 v v v 和它的关系，我们需要使用能量守恒定律和绳子对小球做的功的计算。
首先，根据能量守恒定律，我们可以得出：
初始动能 + 绳子对小球做的功 = 最终动能 \text{初始动能} + \text{绳子对小球做的功} = \text{最终动能} 初始动能+绳子对小球做的功=最终动能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7798a43dc971817cfa8a27a89cdc4f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c1229c09d0f0244df9897c6fa0443b/" rel="bookmark">
			【Quasar】暗黑主题随系统切换部分组件无法随系统切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 Quasar部分组件无法随系统切换主题 。
假如系统、Quasar主题为白天模式。Quasar设置主题随系统切换，当系统切换暗黑模式时，Quasar导航栏无法正常切换为暗黑模式，此时背景还是白天模式，如图
正常切换参考图 正常暗黑主题
随系统切换主题失败参考图 如下图，设置主题随系统切换↓
网页顶部没有成功切换为暗黑模式
解决问题 pinia定义主题状态watch监听quarsar是否为暗黑模式 码 src/stores/themeStore.js src/stores/themeStore.js
import { defineStore } from 'pinia' import { setCssVar, Dark } from 'quasar' import { watch } from 'vue' const theme = defineStore('theme', { state: () =&gt; ({ dark: false,// 暗黑主题 activeDark: false,//当前为暗色主题 themeAutoSys: false,// 随系统主题 }), getters: { // 导航栏色 toolBarColor(state) { return state.activeDark === true ? "bg-dark" : "bg-grey-11 text-black" } }, actions: { // 设置暗黑主题 setDark() { Dark.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c1229c09d0f0244df9897c6fa0443b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b44ae7a19490360fd7dac99359fb2e99/" rel="bookmark">
			记录 Windows11安装支持CUDA12.3的Pytorch版本，验证PyTorch是否安装成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#工作记录#
由于强迫症追新安装了CUDA12.3和对应的cuDNN后，发现Pytorch不能使用GPU了。
折腾了几天，自己编译反复失败后，从官网链接找到一条命令，抱着死马当成活马医的想法试了试：
直达链接：PYTORCH以前的 PyTorch 版本 |Py火炬
以下是图片： 以前的 PyTorch 版本 |Py火炬
在终端或环境终端中输入如下命令：
# CUDA 12.1 conda install pytorch==2.1.0 torchvision==0.16.0 torchaudio==2.1.0 pytorch-cuda=12.1 -c pytorch -c nvidia 这条命令安装之后，验证安装如下：
​​​​​
验证PyTorch是否安装成功，我们可以通过以下几种方法：
### 方法1：检查版本信息
在Python环境中运行以下代码来打印出已安装的PyTorch版本：
# python import torch print(torch.__version__) 如果正确安装了PyTorch，它将输出一个类似于“2.1.0”这样的版本号。
### 方法2：执行简单计算
使用PyTorch进行一些基本的操作，如创建张量（tensor）并执行加法操作。这可以确保库的基本功能可用：
#python import torch x = torch.rand(5, 3) y = torch.rand(5, 3) z = x + y print(z) 如果没有报错，并且能够正常输出结果，则说明PyTorch已经正确安装并且能够正常使用。
### 方法3：测试GPU支持（如果有）
如果你的系统配置有NVIDIA GPU并安装了CUDA以利用GPU加速，那么可以测试PyTorch是否能识别到GPU。运行以下代码：
#python import torch device = torch.device("cuda:0" if torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b44ae7a19490360fd7dac99359fb2e99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ce6e46a0cc51d58f723f7612371574/" rel="bookmark">
			深入理解MySQL事务隔离级别与锁机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表锁： 行锁： InnoDB和MyISAM最大的不同有两点：
InnoDB支持事务（TRANSACTION）InnoDB支持行锁 MyISAM在执行查询SELECT前，会自动给涉及的所有表加读锁，在执行update、insert、delete操作会自动给涉及的表加写锁。
InnoDB在执行查询语句SELECT时（非串行隔离级别），不会加锁。但是update、insert、delete操作会加行锁。
读锁只会堵塞写，不会堵塞读，但是写锁会堵塞读和写
幻读例子：
客户端A查询后，客户段B插入一条数据Q，客户段A想插入Q却报主键冲突，但是查询不出来数据Q；但是可以对Q进行更新。
串行化 把所有读到的数据加锁。
效率很低，很少用。
间隙锁 一个值落到一个范围，这个范围的所有数据都会被加锁
如图：间隙就有id为（3,10）、（10,20）、（20，正无穷）
update account set name = ‘zhuge’ where id &gt;8 and id &lt;18
则其他事务没法在这个范围所包含的所有行记录（包括间隙记录）以及行记录所在的间隙里插入或修改任何数据。即id在（3,20]区间都无法修改数据，20也包含在内。
间隙锁是在可重复度隔离级别下才会生效
临键锁（Next-key-Locks） 临键锁是行锁和间隙锁的组合，想上面的例子中（3，20]的整个区间可以叫临键锁。
无索引行会升级为表锁 InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级到表锁
锁主要是加在索引上，如果对非索引字段更新，行锁可能会变成表锁。
优化建议 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁；合理设计表索引，尽量缩小锁的范围尽可能减少检索条件范围，避免间隙锁尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的SQL尽量放在事务最后执行；尽可能低级别事务隔离 https://note.youdao.com/ynoteshare/index.html?id=354ae85f3519bac0581919a458278a59&amp;type=note&amp;_time=1701862479906
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89044115fb0ef8de7136427978ab7669/" rel="bookmark">
			ThreadLocal&#43;TaskDecorator实现父子线程 参数传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 我自定义注解，在切面中实现动态数据源切换，但是目标方法中新开线程使用异步的方式执行，导致在切面中主线程切换数据源参数，无法在异步的目标方法中使用。
二、实现方式 1、创建UserUtils类。
public class UserUtils { private static final ThreadLocal&lt;String&gt; userLocal=new ThreadLocal&lt;&gt;(); public static String getUserId(){ return userLocal.get(); } public static void setUserId(String userId){ userLocal.set(userId); } public static void clear(){ userLocal.remove(); } } 2、自定义TaskDecorator类型的类
public class CustomTaskDecorator implements TaskDecorator { @Override public Runnable decorate(Runnable runnable) { // 获取主线程中的请求信息（我们的用户信息也放在里面） String robotId = UserUtils.getUserId(); return () -&gt; { try { // 将主线程的请求信息，设置到子线程中 UserUtils.setUserId(robotId); // 执行子线程，这一步不要忘了 runnable.run(); } finally { // 线程结束，清空这些信息，否则可能造成内存泄漏 UserUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89044115fb0ef8de7136427978ab7669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4edc2a1ec17eab39596c551617d5540a/" rel="bookmark">
			SpringBoot 使用策略模式动态调用 Service
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 项目目录 2. pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;/dependency&gt; 3. 创建测试类 TestController package com.cnbai.controller; import com.cnbai.service.ServiceContext; import com.cnbai.service.TaskService; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController public class TestController { @Resource private ServiceContext serviceContext; @GetMapping("/test") public void test(@RequestParam("type") String type) { TaskService taskService = serviceContext.getTaskService(type); taskService.task(); } } 4. 创建 Service TaskService package com.cnbai.service; import org.springframework.stereotype.Service; /** * 动态调用 service 父接口 */ @Service public interface TaskService { void task(); } ServiceContext package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4edc2a1ec17eab39596c551617d5540a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a2e9d8b7c45832378a79a43ccef4194/" rel="bookmark">
			centos7/centos6.8单用户模式修改密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 centos7 开机出现此页面按e 键盘控制往下翻找到 ro 改为 rw init=sysroot/bin/sh； 按 Ctrl+x 执行进入如下界面后输入chroot /sysroot回车 输入passwd根据提示输入两次新密码回车确认 完成后输入 touch /.autorelabel 更新系统信息退出 exit 然后输入reboot命令重启用root账户和刚才设置的密码登录即可； centos6.8 与上面centos7相似，开机出现系统选项时按e在以下界面找到rhgb quiet在其后写入1或则single 回车确认按b进入单用户模式然后输入passwd root回车确认输入密码然后输入reboot命令重启用root账户和刚才设置的密码登录即可； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5675dff3c62f1b4234ae839059103e/" rel="bookmark">
			UnicodeDecodeError: ‘gbk‘ codec can‘t decode byte 0x8c in position 28: illegal multibyte sequence
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题是在尝试读取文件时遇到的，特别是当文件的编码格式不是 ‘gbk’ 时。Python 默认使用 ‘gbk’ 编码来解码文件，如果文件包含 ‘gbk’ 无法解码的字节，就会抛出这个错误。
解决这个问题的方法是显式指定文件的编码格式。通常，我们会使用 ‘utf-8’ 编码，因为它可以处理大多数文本文件。你可以在 open() 函数中使用 encoding 参数来指定编码。
下面是一个示例代码：
with open('your_file.txt', 'r', encoding='utf-8') as f: content = f.read() 这段代码会以 ‘utf-8’ 编码打开文件，并读取它的内容。如果文件是以其他编码格式保存的，你需要用相应的编码来替换 ‘utf-8’。如果你不确定文件的编码，你可以尝试使用 ‘utf-8’ 或 ‘latin1’，并查看是否仍然抛出错误。
需要注意的是，Python 的 open() 函数默认使用系统编码打开文件。如果你在一个使用不同默认编码的系统上运行代码（例如在 Linux 上使用 ‘utf-8’，而在 Windows 上使用 ‘gbk’），这可能会导致问题。在这种情况下，显式指定编码是一个好的做法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1477b7499c88875a954691df3e1669/" rel="bookmark">
			androidstudio设置内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		androidstudio一直 scanning files to index，需要去设置内存：
操作如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f25fd0091c74dc1c8ef6a4b4dffa8de/" rel="bookmark">
			优化的 MCM-GPU 比具有相同 SM 总数和 DRAM 带宽的同等配备的多 GPU 系统快 26.8%。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MCM-GPU: Multi-chip-module GPUs for Continued Performance Scalability
抽象： 从历史上看，基于 GPU 的高性能计算的改进与晶体管缩放紧密相连。随着摩尔定律的减慢，每个芯片的晶体管数量不再以历史速度增长，单个单片GPU的性能曲线最终将趋于稳定。然而，许多领域对更高性能 GPU 的需求仍然存在。为了满足这一需求，在本文中，我们证明了多个 GPU 模块的封装级集成以构建更大的逻辑 GPU 可以实现超越摩尔定律的持续性能扩展。具体来说，我们建议将 GPU 划分为易于制造的基本 GPU 模块 （GPM），并使用高带宽和高能效信号技术将它们集成到封装上。我们列出了基本多芯片模块GPU（MCM-GPU）设计的细节并评估了可行性。然后，我们提出了三种架构优化，可显著提高GPM数据局部性，并最大限度地降低GPM间带宽的灵敏度。我们的评估表明，与基本的 MCM-GPU 架构相比，优化后的 MCM-GPU 实现了 22.8% 的加速和 5 倍的 GPM 间带宽降低。最重要的是，优化的 MCM-GPU 设计比最大的可实现单片 GPU 快 45.5%，性能在假设（且不可构建）单片 GPU 的 10% 以内。最后，我们展示了我们优化的 MCM-GPU 比具有相同 SM 总数和 DRAM 带宽的同等配备的多 GPU 系统快 26.8%。
介绍 基于GPU的计算加速是推动高性能计算（HPC）系统[12]–[29]、大规模云安装中的机器学习和数据分析应用以及个人计算设备[15]–[47]性能的主要工具。在此类设备中，每个计算节点或计算设备通常由具有一个或多个 GPU 加速器的 CPU 组成。这些领域的前进道路，无论是在HPC中实现百万兆次级性能，还是使用深度卷积神经网络实现人类水平的人工智能，都依赖于持续扩展GPU性能的能力[29]，[47]。因此，在这样的系统中，每个GPU在最先进的技术节点上都具有最大可能的晶体管数量，并使用最先进的内存技术[17]。直到最近，晶体管缩放通过增加 GPU 代之间的流式多处理器 （SM） 数量来提高单个 GPU 性能。然而，晶体管的缩放速度已经大大放缓，预计最终会结束[7]，[8]。此外，光学和制造限制限制了光罩尺寸，而光罩尺寸又限制了最大芯片尺寸（例如 ~800毫米2[18]， [48]）。此外，由于大量无法修复的制造故障，非常大的模具具有极低的良率[31]。这会将大型单片 GPU 的成本提高到不理想的水平。因此，这些趋势限制了未来单GPU性能的扩展，并可能使其停滞不前。
在不超过最大芯片尺寸的情况下扩展性能的另一种方法依赖于 PCB 上连接的多个 GPU，例如 Tesla K10 和 K80 [10]。然而，正如我们在本文中所展示的，在这种“多 GPU”系统上扩展 GPU 工作负载是很困难的，即使它们在单个 GPU 上扩展得非常好。这是由于在慢速车载互连网络中与工作分区、负载均衡和数据共享相关的多个未解决的挑战[20]–[36]。然而，由于封装[30]和信令技术[45]的最新进展，封装级集成提供了一个很有前途的集成层，位于现有的片上和板载集成技术之间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f25fd0091c74dc1c8ef6a4b4dffa8de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e9ad18d75607eec9c9cf51d94dd1c49/" rel="bookmark">
			vue-socket.io以及原生websocket的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3使用socket.io 1、安装 npm install vue-socket.io 2、创建socket.js文件
export const registerSockets = (sockets, proxy) =&gt; { sockets &amp;&amp; Object.keys(sockets).forEach((t) =&gt; { // console.log(t); // "subscribe" !== t &amp;&amp; // "unsubscribe" !== t &amp;&amp; proxy.$socket.emitter.addListener(t, sockets[t], proxy); }); }; export const destroySockets = (sockets, proxy) =&gt; { sockets &amp;&amp; Object.keys(sockets).forEach((t) =&gt; { proxy.$socket.emitter.removeListener(t, proxy); }); }; 3、 main.js使用
import VueSocketIO from 'vue-socket.io'; import { registerSockets, destroySockets } from './service/utils/sockets'; const scUrl = import.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e9ad18d75607eec9c9cf51d94dd1c49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/351d37bc878fa499d6e958c7ea39d507/" rel="bookmark">
			uni-app - 日期 · 时间选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.基本介绍
2.案例介绍
①注意事项：
②效果展示
3.代码展示
①view部分
②js部分
③css样式
1.基本介绍 从底部弹起的滚动选择器。支持五种选择器，通过mode来区分，分别是普通选择器，多列选择器，时间选择器，日期选择器，省市区选择器，默认是普通选择器。
2.案例介绍 ①注意事项： 当选择时间和日期的时候会默认直接展示当前的时间和当天的日期
②效果展示 3.代码展示 ①view部分 &lt;!--日期选择--&gt;
&lt;view class="SelectDate"&gt;
&lt;view class="DateLabel"&gt;
面试日期
&lt;/view&gt;
&lt;view class="DateText"&gt;
&lt;picker mode="date" @change="onDateChange" :value="DateValue"&gt;
&lt;view class="date-picker"&gt;{{DateValue}}&lt;/view&gt;
&lt;/picker&gt;
&lt;/view&gt;
&lt;/view&gt;
&lt;view class="SelectTime"&gt;
&lt;view class="TimeLabel"&gt;
面试时间
&lt;/view&gt;
&lt;view class="TimeText"&gt;
&lt;picker mode="time" @change="onTimeChange" :value="TimeValue"&gt;
&lt;view class="Time-picker"&gt;{{TimeValue}}&lt;/view&gt;
&lt;/picker&gt;
&lt;/view&gt;
&lt;/view&gt;
②js部分 &lt;script&gt;
export default {
data() {
return {
DateValue: "请选择日期",
TimeValue: "请选择时间",
}
},
methods: {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/351d37bc878fa499d6e958c7ea39d507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbbec70c72675946a6935334c7a42467/" rel="bookmark">
			json json json json json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo ./driver_ctller 120 3.0 0.6 3.6 0.0 1.0 2.4
{ "comment": " ######### move_all ######### ", "loopTimesAll": 1, "LOOP_1": { "comment": " ######### move_1 ######### ", "loopTimesSub": 2, "position_1": { "speed": 20, "acceleration": 50, "targetPosition": [ 40, 0, 0 ] }, "position_2": { "speed": 20, "acceleration": 50, "targetPosition": [ -40, 0, 0 ] } }, "LOOP_2": { "comment": " ######### move_1 ######### ", "loopTimesSub": 2, "position_1": { "speed": 20, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbbec70c72675946a6935334c7a42467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7020d4fa81f2c46bfa594fefcfbba53f/" rel="bookmark">
			我一人全干！之vue3后台管理中的大屏展示。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用大屏展示的时候有很多种场景，众多场景都是为了实现大屏自适应。
大屏，顾名思义，就是放在一个固定的屏幕上看的，即使你不做自适应，放在一个固定的屏幕上看也没啥问题，但是很多做大屏的是为了在PC端看，PC端屏幕又是参差不齐的，所以需要做自适应。
方案一：
使用transform的大小缩放来实现，我们先写一个缩放容器AutoScalContainer.vue，代码如下：
&lt;template&gt; &lt;div class="auto-scal-container" ref="AutoScalContainerRef"&gt; &lt;div ref="DomRef" class="auto-scal-container-inner"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; /** * 自动缩放容器 * 使用transform进行缩放 * */ import { defineComponent,ref,getCurrentInstance,reactive,toRef, computed,onMounted,onActivated,watch, onBeforeUnmount, } from "vue"; export default defineComponent({ props:{ width:{ type:Number, default:1920, }, height:{ type:Number, default:1080, }, /** 内部容器的宽高比例 */ ratio:{ type:Number, default:1920 / 1080, }, /** * fit，原理同img的object-fit * contain : 被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。 * cover : 被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框。 * */ fit:{ type:String, default:'contain', }, }, emits:['onResizeScreen'], setup(props,{emit}){ const DomRef = ref(null); //组件实例 const AutoScalContainerRef = ref(null); //组件实例 const dataContainer = reactive({ height:toRef(props,'height'), width:toRef(props,'width'), ratio:toRef(props,'ratio'), fit:toRef(props,'fit'), }); /** 是否是文档上 */ function isActive(){ if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7020d4fa81f2c46bfa594fefcfbba53f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/819bcac7a571d4fc9446274543b2be25/" rel="bookmark">
			获取exe或dll所在的路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;direct.h&gt; #include &lt;Windows.h&gt; #include &lt;boost/filesystem.hpp&gt; #include &lt;stdio.h&gt; //获取exe或dll所在的路径 wchar_t defaultPath[MAX_PATH]; GetModuleFileName(NULL, defaultPath, MAX_PATH); std::wcout &lt;&lt; defaultPath &lt;&lt; std::endl; boost::filesystem::path programPath(defaultPath); std::string dir=programPath.parent_path().string(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5da5b41422e0c52fd48433d025cf4ca/" rel="bookmark">
			HbuilderX 配置内置终端为 gitBash，修改终端主题，亲测好用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HbuilderX内置终端使用的是 PowerShell 或者 Cmd，修改为 gitBash 修改前： 修改后： 方法： // 直接替换下面代码 if (isWin) { shell = "C:/Program Files/Git/bin/bash.exe"; // 你的gitBash安装目录 var osRelease = os.release(); var dotIndex = osRelease.indexOf("."); // if (dotIndex &gt; 0) { // var fv = osRelease.substring(0, dotIndex); // if (fv &gt; 6) { // shell = "powershell.exe"; // } else { // shell = "cmd.exe"; // var ov = osRelease.substring(dotIndex); // dotIndex = ov.indexOf("."); // if (dotIndex &gt; 0) { // var sv = ov.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5da5b41422e0c52fd48433d025cf4ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff988232b02ac72792f9bef8d75d1c8/" rel="bookmark">
			淘宝权益玩法平台的Serverless化实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过对权益玩法平台现有业务应用的Serverless化改造，权益团队在双十一期间完美地支撑了业务需求，在研发效率、运维保障等方面都体现出了很高的价值和收益。
项目背景
淘宝权益平台是负责淘宝权益营销的核心团队，团队除了负责拉菲权益平台外，也越来越多地承接营销IP和轻互动营销等需求，这类需求除了内容上非常多样外、交付上也是又多又急，对技术的挑战性非常大。有别于平台型应用，营销IP类需求对业务模型和架构的要求相对不高，但是对开发产研的效率要求非常高，所以我们急需一套可靠的产研体系去支撑营销IP和轻互动的需求。
权益玩法平台就是在这样的背景下诞生的，其设计目标是通过对营销和玩法通用能力的沉淀和复用，构建出一整套营销玩法能力体系，来降低业务需求的开发成本，提升业务的交付效率。
基于Ring容器化的尝试
为了实现既定的设计目标，权益玩法平台一开始设计了基于Ring容器化能力的方案，Ring是由我们团队自研开发的JVM容器化框架，支持对业务能力进行动态加载，其核心特点是JVM热部署和机器按需部署。Ring框架由一个宿主应用和多个业务容器组成，宿主应用提供整体的基础能力和共享能力，不同业务扩展由各自的容器(farjar载体)实现，通过控制不同的宿主应用分组挂载不同的业务jar包实现业务的隔离效果。借助Ring框架的热部署能力，可以实现秒级部署能力，效率上有极大的优势。
基于机器分组的业务隔离能力：
基于基座应用和容器应用的产研隔离和热部署机制：
平台开发同学负责基座应用基础服务和共享服务的开发和运维
业务开发同学专注于业务逻辑开发，基于热加载能力部署到基座应用
▐ 权益玩法平台基于Ring的业务形态 权益玩法平台在Ring的支持下，在同一应用内，实现了对核心业务的独立部署和对非核心业务混部方案，既满足了核心业务的稳定性要求，又节省了整体业务的维护成本和资源成本。
▐ Ring架构的优点 效率高：
由平台提供中间件和通用服务支持，降低了业务开发成本；
支持热部署发布，开发和交付效率高；
隔离性好：
基于机器分组的强隔离能力保障业务和流量隔离；
▐ Ring架构的不足 Ring框架本身是为业务扩展设计的，但权益玩法平台多个业务间并非扩展关系，所以来说Ring并不是最佳的使用场景，使用上也存在系统权限、产研角色等一定的局限性；
为支持热部署，Ring框架在应用底层框架上做了很多的改造和定制，除了潜在的内存泄漏等风险外，这些需要业务开发时进行感知的特殊逻辑，也无形中提高了开发和运维的门槛和成本；
▐ 小结 基于Ring架构的权益玩法平台应用已经能很好的支持业务发展，但同时也存在一些的不足和问题。为更好的支持业务发展，我们也在不断探索更好的架构和产研模式。也在这个过程中，刚好遇到Serverless的大范围推广，在经过调研和比较之后，我们决定拥抱Serverless重构我们的产研体系。
初识Serverless
Serverless是个相对比较广义的概念，从不同的角度可以有不同的解释。从我的粗浅的理解来说，Serverless可以简单认为是一种将应用与基础设施进行分离的架构理念，通过指导软件架构和职责分工，使开发者更聚焦在业务逻辑，从而减少对基础设施的关注，其核心要素是架构分层和产研分工：
从计算机发展的角度看，分层一直是永恒的话题，操作系统分层、网络分层、文件系统分层，分层让更多的底层实现得以屏蔽，让上层使用者只需要通过简单的API即可使用计算机复杂的能力，在这一过程中，分层变得越来越多、分工也变得越来越细，除了操作系统层面的分层，我们也看到了云服务提供了计算资源的分层，中间件提供了基础服务的分层，Serverless更进一步提供了业务运行时的分层。有了Serverless，业务开发者不用再关心中间件、机器资源、jvm容器，只需要把业务代码写好，剩下的都交给Serverless。
Serverless的设计目标
免运维：应用的运维工作将由Serverless的服务提供方负责，普通业务开发人员不用再关注机器部署、扩缩容等运维的事情；
更低成本：借助弹性能力，Serverless会根据应用负载动态进行扩缩容以满足业务的实际需求，避免了资源的浪费情况；
快速交付：从普通应用发布要重启整个jvm容器、中间件相比，Serverless发布粒度可以控制在单纯业务代码维度（业务函数），可以获得极致的发布效率体验；
统一架构：所有的基础能力都由Serverless基座负责，所以JDK的升级、中间件升级、通用二方包版本维护等不再需要推动每个业务去升级，只需要由专人通过Serverless基座即可完成业务无感升级；
Serverless应用解构
相较于传统应用，Serverless应用对于我们认知中的研发体系挑战还是比较大的，Serverless的整个设计和运作体系都和传统应用发生了很大的变化，这对于技术研发同学来说，了解这其中的原理和思路是必不可少的。所以我试图从一个传统应用出发，通过逐步解构整个过程，粗浅的介绍下Serverless是怎么实现和运作的：
第一层. 普通应用： 我们一般的普通应用都由Pandora容器(隔离容器)加载，其中包括了中间件和业务自己的spring容器
第二层. 业务逻辑拆解 我们日常开发的代码中，除了业务本身的代码，肯定也包括很多通用的代码逻辑，比如对商品、人群等服务的封装和调用，这些大多数应用都会用到的逻辑，我们却一直在多个应用间不断地重复编写这些代码。
第三层. 业务容器分层 通过区分业务代码和通用代码，我们可以进一步对业务的Spring容器进行拆分，区分成通用Spring容器和业务Spring容器，进而就分别控制不同业务容器的加载和销毁。
第四层. Serverless化 通过将业务能力和通用能力分层之后，就可以进一步形成以基座应用和业务应用为概念的独立产品和部署体系，从功能、产研和运维体系上进行了彻底的隔离和分工。
Serverless的产研和交付形式
Serverless对于业务最大的影响就是对原有产研体系的革命，一方面出现了专门的分工人员专职负责Serverless基座的开发和运维角色，另一方面，普通的业务开发不再需要关注机器容器、jvm和中间件等服务，更专注于业务需求实现和交付：
传统应用交付形式：研发负责整个Docker容器内的所有东西
Serverless的全新产研分工：职责分工，专业的人做自己最专业的事情
Serverless的全新应用交付形式：分层独立交付
Serverless全新部署体验
除了能力分层和产研分工，Serverless带来的还有一个重点特性就是飞一般的部署速度。以往可能需要五~十分钟才能完成的部署，Serverless缩短到了一分钟以内，真正让日常的开发体验朝着所写即所得更进一步。
要了解Serverless部署快在哪里，我们要从普通的应用部署流程说起，看看我们平时的部署都慢在哪里：
上面是我们一个普通应用第一次新部署和更新部署的核心节点，镜像构建、中间件及基础服务启动都是耗费了大量时间，而且为了保障服务不中断，我们还要考虑分批部署，将原本已经很长的部署时长Double了一下。
为了解决部署耗时的问题，Serverless设计了一套更高效和敏捷的部署体系，其中通过多种机制加速了我们的整个部署流程：
免业务镜像构建：
在Serverless体系下，每次业务交付的只剩下业务代码，已无感知Docker容器，自然也就没了镜像构建的必要，镜像的管理统一交由Serverless基座负责，而且基座内也只会包含中间件和通用业务功能等不频繁更新的内容，业务的变更内容将通过独立的fatjar形式动态加载到运行容器中。
缓存服务容器：
在镜像标准化的前提下，镜像的加载和启动就不用再依赖于业务本身的变更发布，在业务发布使用之前，机器就可以提前把Docker、JVM、中间件、Spring容器、通用服务等加载和启动起来，并统一缓存到容器缓存池中，业务真正使用的时候只需要拉取已初始完成的容器加载业务代码，并完成流量切换就可以提供服务。
滚动发布：
在普通情况下，为了保证服务不中断，我们至少需要提供两台服务机器，发布的时候还需要分两批平滑发布，除了部署很耗时，测试和调试也是很麻烦。有了Serverless，在预发环境等测试环境我们就可以只部署一台机器，发布的时候，Serverless会从缓存容器中拉起一台新的容器进行加载，在完成快速启动后，进行流量切换就完成了平滑部署，真正让部署起飞。
通过总结以上几个核心的机制，Serverless让一个环境的新部署和更新部署变更非常简单和高效：
Serverless插件-通用能力下沉的利器
在Serverless基座中，除了中间件等基础能力外，更重要的是要承载业务通用能力下沉的重任。一方面，每个业务应用基本都会涉及到需要去对接商品、账号、人群等二方服务，其中有些服务会存在文档不全面、依赖臃肿、协议不规范等问题，极大影响了业务开发的质量和效率；另一方面，业务自身也有很多需要复用的业务逻辑，如何快速共享和接入、统一升级和维护也是大家一直来苦恼的问题。对于业务来说，非常需要那么一个解决方案，既能简单可靠成本低，又能满足以下所有的能力复用诉求：
类隔离机制：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ff988232b02ac72792f9bef8d75d1c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc5f5b55d36b1f93c86b72f3ee1d5b11/" rel="bookmark">
			解决elementuiplus的button组件点击之后仍然是hover的问题以及修改主题颜色之后button的颜色问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到了elementui的button组件的问题，到目前位置官网也是这样的。自己摸索着修复这个问题。
1、解决hover的问题 1、在文件见中定义一个scss文件（css文件好像不行，必须是sacc），在里面写以下内容。
.el-button.el-button--primary:not(.is-disabled):focus { background-color: var(--el-color-primary); } .el-button.is-link:not(.is-disabled):focus { color: var(--el-button-text-color) !important; background-color: none !important; } .el-button.el-button--small:not(.is-disabled, .el-button--primary):focus { background-color: none !important; } 2、在main.ts引入它就行了
3、效果
4、存在的问题：只要点击一次之后 就不会有hover效果了。但是点击其他区域之后又有了。由于项目中对hover效果不是很敏感 所有就没有深入了。
2、解决修改主题之后颜色没有正确的问题 问题复现：
修改问题：
在您的修改主题色的地方加上以上代码就行了
import { useChangeColor } from '@/utils/theme' const { getLightColor, getDarkColor } = useChangeColor() /** * 切换主题颜色 * @param color 选择的主题颜色 */ function changeThemeColor(color: string) { document.documentElement.style.setProperty("--el-color-primary", color); document.documentElement.style.setProperty('--el-color-primary-dark-2', `${getDarkColor(color, 0.1)}`) for (let i = 1; i &lt;= 9; i++) { document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc5f5b55d36b1f93c86b72f3ee1d5b11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496aca305bcfb2e5e47c51f3567d45c1/" rel="bookmark">
			C&#43;&#43;[面向对象的程序设计]_基础入门（上）(万字总结)（建议收藏！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. C++基础入门
1.1 变量 1.2 常量
1.3 关键字
1.4 标识符命名规则
1.5 数据类型
1.5.1 整型
1.5.2 sizeof 关键字
1.5.3 实型（浮点型）
1.5.4 字符型
1.5.5 转义字符
1.5.6 字符串类型
1.5.7 布尔类型
1.5.8 数据的输入
1.6 运算符
1.6.1 算术运算符 - 加减乘除运算
1.6.2 算术运算符 - 取模运算
1.6.3 算术运算符 - 递增递减
1.6.4 赋值运算符
1.6.5 比较运算符
1.6.6 逻辑运算符 - 非
1.6.7 逻辑运算符 - 与
1.6.8 逻辑运算符 - 或
1.7 程序流程结构
1.7.1 选择结构_单行if语句
1.7.2 选择结构_多行if语句
1.7.3 选择结构_多条件if语句
1.7.4 选择结构_嵌套if语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496aca305bcfb2e5e47c51f3567d45c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b170fcf26f7759306700dd863ab20c/" rel="bookmark">
			用服务器的卡来运行python文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用服务器的卡来运行python文件 在终端输入
CUDA_VISIBLE_DEVICES=0 python t5.py
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56d8907642e536fca7ef23baec0b1fe/" rel="bookmark">
			mybatis------处理多对一映射关系的两种方式、多对一处理映射关系的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		员工类： package com.gothic.sunset.pojo; public class Emp { private Integer empId;//员工号 private String empName;//员工姓名 private Integer age;//员工年龄 private String gender;//员工性别 private Dept dept;//部门 public Emp() { } public Emp(Integer empId, String empName, Integer age, String gender) { this.empId = empId; this.empName = empName; this.age = age; this.gender = gender; } public Integer getEmpId() { return empId; } public void setEmpId(Integer empId) { this.empId = empId; } public String getEmpName() { return empName; } public void setEmpName(String empName) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b56d8907642e536fca7ef23baec0b1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f64dc9d8eecbde667fb420e99f18a35/" rel="bookmark">
			javascript 访问器属性创建的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出自 javascript高级程序设计-第六章6.1节 javascript 访问器属性创建的三种方式： 以下year字段都是访问器属性，_year、 edition是数据属性。
var book1 = { _year: 2000, edition: 1 }; Object.defineProperty(book1, "year", { get: function(){ return this._year; }, set: function(newValue){ if (newValue &gt; 2000) { this._year = newValue; this.edition += newValue - 2000; } } }); book1.year = 3000; console.log(book1.year); // 3000 console.log(book1.edition); // 1001 var book2 = { _year: 2000, edition: 1 }; //定义访问器的旧有方法 book2.__defineGetter__("year", function(){ return this._year; }); book2.__defineSetter__("year", function(newValue){ if (newValue &gt; 2000) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f64dc9d8eecbde667fb420e99f18a35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d1f50207d2ffa05ebc0301ffaf63f6/" rel="bookmark">
			【uview】省市二级联动地区选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uniapp插件地址
亲测 兼容微信小程序
使用 注意： 下载安装配置uview组件库，该插件基于uview的upicker组件
下载插件并导入到项目页面中直接引入标签 import barrypicker from '@/uni_modules/barry-picker/components/barry-picker/barry-picker.vue' components: { barrypicker }, 标签使用 &lt;barry-picker ref="dialog" @get-address="getAddress"&gt;&lt;/barry-picker&gt; 方法使用 // 打开地址弹框 open() { this.$refs.dialog.show = true }, // 获取地址 getAddress(e) { console.log('选择的地址是', e); this.location = e } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81f5e7c69c7e3ee663f49f90b8e8dd5a/" rel="bookmark">
			【Gradle】mac环境安装Gradle及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网安装说明：Gradle | Installation
由于Gradle运行依赖jvm，所以事先需要安装jdk，并确认你的jdk版本和gradle版本要求的对应关系，这个官网上有说明，但是我试了一下不太准确，供参考，链接如下：
gradle不同版本要求的jdk版本：Compatibility Matrix
Table 1. Java Compatibility Java versionSupport for compiling/testing/…​Support for running Gradle 8
N/A
2.0
9
N/A
4.3
10
N/A
4.7
11
N/A
5.0
12
N/A
5.4
13
N/A
6.0
14
N/A
6.3
15
6.7
6.7
16
7.0
7.0
17
7.3
7.3
18
7.5
7.5
19
7.6
7.6
20
8.1
8.3
你也可以选择对应的版本查看具体安装要求
安装方式有三种，命令行安装和手动安装，程序编译安装
一、命令行安装 brew install gradle 二、手动安装 本次我采用手动安装，可以下载可执行的安装包，也可以下载源码手动编译安装，本次直接下载可执行的安装包gradle-8.3-bin.zip
1.查看是否安装jdk
$ java --version java 21.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81f5e7c69c7e3ee663f49f90b8e8dd5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0daa2d2bd9fff13b69d6a8c3888724d7/" rel="bookmark">
			Flutter 基于getX搭建通用项目架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 网络封装 网络主要使用的是dio 和 retrofit来实现的,关于dio的封装,思路基本上和网上的教程大同小异.大致思路就是创建options对象,设置超时时间,域名,responseType,超时时间等等.然后在创建dio单例对象,给dio对象添加拦截器,我基本上添加三个拦截器分别为
* MiddleInterceptor (获取请求路径,请求参数,打印日志)
* ErrorInterceptor (获取错误原因,打印日志)
* ApiResultInterceptor(获取后端返回结果,处理逻辑,数据返回,比如多设备登录同一账号异常处理等等)
在这里代码就不贴出来了,有兴趣的可以下载demo查看.
为什么要使用retrofit?
retrofit是一个非常好用强大的代码生成器,支持POST GET PATCH PUT等请求.定义好请求方法,返回类型执行一行命令就会自动生成代码,在Controller中直接使用自己使用好的model即可.
常用命令:
* flutter packages pub run build_runner build
* flutter pub run build_runner build --delete-conflicting-outputs
代码定义如下所示
/// 列表接口 @GET("searchV5") Future&lt;Result&lt;InfoWorkModel&gt;&gt; getInfoListData( @Query('pn') int page, @Query('ps') int pageSize, @Query('q') String name, @Query('t') String t, ); /// 详情接口 @GET("pc/items/info") Future&lt;Result&lt;InfoWorkModel&gt;&gt; getInfoDetailData( @Query('entityId') int entityId, ); /// 点赞接口 @POST("thumbsUpOrDown") Future&lt;Result&lt;InfoWorkModel&gt;&gt; likeThumbsUpOrDown( @Body() Map&lt;String, String&gt; param); Result 类里面就是返回的最外层数据包括 code,msg,data其中data是一个 泛型T可以接受任何类型,然后再定义data里面对象,也就是InfoWorkModel,这样层层定义保障每个对象都转化成modle即可.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0daa2d2bd9fff13b69d6a8c3888724d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6d02a2d676f7a1acf5bb7664e551a7a/" rel="bookmark">
			TG2016SKA/TG2016SLA TCXO适用于车载GNSS和V2X
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爱普生推出两款新型汽车用TCXO：TG2016SKA和TG2016SLA，适用于汽车GNSS，V2X(TCU, DSRC) * GNSS:全球导航卫星系统* V2X:车辆到一切* TCU:远程信息处理控制单元* DSRC:专用短程通信
TG2016SKA和TG2016SLA是符合汽车级AEC-Q100的温度补偿晶体振荡器，可支持高达105C的高温，但是这两者还是有一些区别的，具体规格书，以供大家选型参考：
TG2016SKA TCXO TG2016SLA TCXO 如上图所示TG2016SKA和TG2016SLA这两款汽车级温补晶振除了最高温度，其他参数大致相同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83228cd79f59466d645ed1658590845f/" rel="bookmark">
			深入理解MVCC与BufferPool缓存机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://note.youdao.com/noteshare?id=b36b975188fadf7bfbfd75c0d2d6b834&amp;sub=5A7459FE4B464EC896F9DD9A4 E
MySQL在读已提交和可重复度隔离级别下都实现了MVCC机制
begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作InnoDB表语句，事务才真正启动，才会向MySQL申请事务id，MySQL内部是严格按照事务的启动顺序来分配事务id的。
undo日志版本链与read view机制 undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链
在可重复读隔离级别，当事务开启，执行任何查询sql时会生成当前事务的一致性视图read-view，该视图在事务结束之前都不会变化；
如果是读已提交隔离级别在每次执行查询sql时都会重新生成。
这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。
版本链比对规则： 如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的；如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若 row 的 trx_id 就是当前自己的事务是可见的）；如果 row 的 trx_id 落在黄色部分(min_id &lt;=trx_id&lt;= max_id)，那就包括两种情况
a. 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自己的事务是可见的)；
b. 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。 对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数据。
MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。
Innodb引擎SQL执行的BufferPool缓存机制 为什么Mysql不能直接更新磁盘上的数据而且设置这么一套复杂的机制来执行SQL了？ 因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据性能可能相当差。
因为磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。
Mysql这套机制看起来复杂，但它可以保证每个更新请求都是更新内存BufferPool，然后顺序写日志文件，同时还能保证各种异常情况下的数据一致性。
更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是非常高的，要远高于随机读写磁盘文件。
正是通过这套机制，才能让我们的MySQL数据库在较高配置的机器上每秒可以抗下几干甚至上万的读写请求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b0ab110e6db52ed16754fee9a9ad95/" rel="bookmark">
			simulink MATLABFunction模块中实时函数调用函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		样例
function Predyy = matlabceshi(input, Time_s)
input1 = input;
Time_s1 = Time_s;
Predyy = ee(input1) + mm(Time_s1);
end
上面是主要部分，下面是被调用部分
function A = ee(input1)
A = input1 * 100;
end
function B = mm(Time_s1)
B = Time_s1 * 100;
end
模型中函数功能调用时需要修改成matlabceshi(u(1),u(2))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f793ec70c8e544a1e2739e64abed4f4d/" rel="bookmark">
			linux快速安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 Nginx 在 Linux 实例上相对简单。你可以按照以下步骤进行：
步骤一：更新系统
在开始安装 Nginx 之前，确保系统已更新到最新状态：
sudo yum update 步骤二：安装 Nginx
使用 yum 包管理器安装 Nginx：
sudo yum install nginx 步骤三：启动 Nginx 服务
安装完成后，启动 Nginx 服务：
sudo systemctl start nginx 步骤四：设置开机启动
如果你希望在系统启动时自动启动 Nginx，运行以下命令：
sudo systemctl enable nginx 步骤五：检查 Nginx 状态
确认 Nginx 是否正在运行：
sudo systemctl status nginx 步骤六：配置防火墙（可选）
如果有防火墙，确保已打开 HTTP（80 端口）以允许 Nginx 的流量：
sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --reload 步骤七：访问 Nginx 默认页面
在浏览器中输入你的服务器 IP 地址或域名，检查是否可以访问 Nginx 默认页面。默认情况下，Nginx 的默认页面位于。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f793ec70c8e544a1e2739e64abed4f4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47c1b31200d6e8751f07acd5f92dfb9/" rel="bookmark">
			treeselect有值去除校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0 效果 1 代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5b2b0c54f3db68fd2e3796800961333/" rel="bookmark">
			Feign实现全局自定义异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：开发中，A服务使用Feign调用B服务时，B服务中参数校验未通过抛出了自定义异常，错误码是自定义错误码，错误消息是“XXXXX不能为空”，返回到A服务时，A服务的feign异常拦截无法获取到自定义错误码。OpenFeign的FeignException返回的异常信息默认status为500。导致自定义错误码丢失。。Feig默认异常信息：
{
“timestamp”: 1698304783339,
“status”: 500,
“error”: “Internal Server Error”,
“path”: “/xx/get”
}
因此，我们返回自定义的异常。大概步骤如下：
1.定义一个自定义的异常 package com.test.ft.common.exception; import cn.hutool.http.HttpStatus; import lombok.Data; /** * @author aaa * @description 自定义异常 */ @EqualsAndHashCode(callSuper = true) @Data public class CommonException extends RuntimeException { private static final long serialVersionUID = 91805175818790920L; private int code; private String msg; public CommonException(String msg) { super(msg); this.code = HttpStatus.HTTP_INTERNAL_ERROR; this.msg = msg; } public CommonException(int code, String msg) { super(msg); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5b2b0c54f3db68fd2e3796800961333/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b0e140af4663515c78a3c3ce91819e/" rel="bookmark">
			vue3还用this吗？getCurrentInstance获取当前组件实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Vue 2 中，this 关键字代表当前组件实例。在组件的选项对象中，this 可以用于访问组件实例的属性、方法以及 Vue 实例的一些特定方法。
在Vue3中，我们发现this是undefined，那我们真的没法使用this了吗？vu3给我们提供了一个getCurrentInstance函数： 用于获取当前组件实例。身上有个ctx属性有点类似this,通过代码可以看到如何使用。
组件实例身上还有个proxy属性也基本相同，proxy.xxx = xxxx修改数据后-是动态修改的（数据页面都更新）
建议：vue3中已经不想让大家使用this了，直接通过变量名取值也是很方便的，
当然有喜欢用this的也可以使用这种方式，不过目前看来取到的值是只读的。
&lt;template&gt; &lt;div style="font-size: 14px"&gt; &lt;div&gt;{{myName1}}&lt;/div&gt; &lt;div&gt;{{myName2}}&lt;/div&gt; &lt;div&gt;{{myName3}}&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="ts"&gt; // vue3.0版本语法 import { defineComponent, getCurrentInstance, ref } from "vue"; export default defineComponent({ name: "组件名", setup() { // console.log(this);// undefined // getCurrentInstance()获取当前组件实例, ctx是 vue3给我们提供的变量名 // const { ctx } = getCurrentInstance() console.log('实例getCurrentInstance:',getCurrentInstance()); // 我们利用改变对象名字的写法将改成_this const { ctx: _this } = getCurrentInstance() // 首先看看_this是什么 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2b0e140af4663515c78a3c3ce91819e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f099e37897b54e6512fd4309505b48/" rel="bookmark">
			H5: div与textarea输入框的交互（聚焦、失去焦点、键盘收起）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本文是基于 VUE3+TS 的代码说明。
记录自己遇到的 div 与 textarea 输入框交互的聚焦、失去焦点、键盘收起、表情插入不失去焦点的需求实现。
需求分析 1.固定在页面底部；
2.默认显示纯文字与发送图标按钮，文字超出的省略显示；
3.点击文字后，显示文本输入框、表情、半透明遮罩层，自动聚焦；
4.有输入内容时，文本输入框右侧显示发送按钮；
5.点击表情，将表情加入到输入框最后，并且输入法键盘不收起；
6.输入框失去焦点、点击键盘上的收起或完成时，隐藏文本输入框和表情，显示默认的纯文字样式。
注意 ------以下代码是伪代码------
1.输入框聚焦后，可能存在输入框位置不正确的问题 如输入框被遮挡、输入框没有挨着键盘等类似的问题。
这些问题在网上的解决方案较多，可自行查阅。
我的处理思路如下：
// html &lt;Teleport to="#inputPosition"&gt; &lt;div v-show="isTextareaFocus" class="textarea-box"&gt; &lt;!-- 输入框与发送按钮 --&gt; &lt;div&gt; &lt;textarea ref="textareaRef" /&gt; &lt;button&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;!-- 表情 --&gt; &lt;div&gt; &lt;div v-for="(emoji, index) in emojiList" :key="index"&gt;{{ emoji }}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Teleport&gt; 点击文本div时，显示文本输入框，并且自动聚焦
&lt;script setup lang="ts"&gt; import { ref, nextTick } from 'vue' const isTextareaFocus = ref(false) // 文本输入框是否聚焦（即显示） const textareaRef = ref() // 输入框对应的DOM const emojiList = ['👍', '😀', '😮', '🥰', '😡', '🤣', '😤', '🙏'] // '🫡', '🫰🏻' /** 方法：输入框文本-是否聚焦、显示 */ const displayTextarea = (display = false) =&gt; { isTextareaFocus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1f099e37897b54e6512fd4309505b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10de9ed91e6ca9daa2c7dc468e4fae9f/" rel="bookmark">
			C语言二叉树建立与遍历—实验报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 二叉树建立与遍历实验报告
源码 二叉树建立与遍历实验报告 系别
计算机学院
班级
学号
姓名
课程名称
数据结构
实验日期
实验名称
二叉树的建立与遍历算法应用
成绩
实验目的：
熟悉掌握二叉链表存储结构及基本算法，并能应用二叉树的基本算法解决与之有关的简单问题，训练和提高结构化程序设计能力及程序调试能力。
实验条件：
计算机一台，Visual C++6.0或DEV C++
实验内容：
问题描述判断一棵二叉树是否为满二叉树。要求二叉树用二叉链表存储,用先序、中序、后序递归遍历算法的任意两种输出二叉树中所有结点，编写程序判断该树是否为满二叉树。
数据结构类型定义typedef struct node {
int val; // 结点的值
struct node *left; // 左子树指针
struct node *right; // 右子树指针
} TreeNode, *Tree;
模块划分
建立二叉树：void createTree(Tree *t)判断一棵二叉树是否为满二叉树：int isFullTree(Tree t)中序遍历：void inOrder(Tree t)后序遍历：void postOrder(Tree t)二叉树高度：int height(Tree t)主函数：int main()
详细设计#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// 定义二叉树的结点结构
typedef struct node {
int val; // 结点的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10de9ed91e6ca9daa2c7dc468e4fae9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db75d8812d43efe0dbc3025bf548b1c/" rel="bookmark">
			tg - 3541 cea (TCXO)简单封装晶体振荡器（KHZ范围）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爱普生TG-3541CE (TCXO)晶体振荡器的输出频率为32.768kHz和内置的32.768kHz DTCXO。3.2×2.5×1.0mm模块供电电压为1.5V ~ 5.5V，输出波形:互补金属氧化物半导体，允许输出(OE)的功能，AEC-Q100兼容。
频率公差：XA：:±1.9 × 106/ 0℃~ +50℃
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;:±3.4 × 106/ -40℃~ +85℃
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;:±8.0 × 106/ +85℃~ +105℃ &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;XB：:±3.8 × 106/ 0℃~ +50℃
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;:±5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5db75d8812d43efe0dbc3025bf548b1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ad58c9c5e9ba626fb3788df801bad0/" rel="bookmark">
			PY32F002A的LL库GPIO中断配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置B1口
/** * @brief EXTI配置函数 * @param 无 * @retval 无 */ static void APP_ConfigureEXTI(void) { /* 使能GPIOB */ LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB); /* 配置PB1输入模式 */ LL_GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.Pin = LL_GPIO_PIN_1; GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT; GPIO_InitStruct.Pull = LL_GPIO_PULL_UP; LL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); /* 配置EXTI为中断、下降沿触发 */ LL_EXTI_InitTypeDef EXTI_InitStruct; EXTI_InitStruct.Line = LL_EXTI_LINE_1; EXTI_InitStruct.LineCommand = ENABLE; EXTI_InitStruct.Mode = LL_EXTI_MODE_IT; EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_FALLING; LL_EXTI_Init(&amp;EXTI_InitStruct); /*EXTI2选择PB1触发*/ LL_EXTI_SetEXTISource(LL_EXTI_CONFIG_PORTB,LL_EXTI_CONFIG_LINE1); /* 使能中断 */ NVIC_SetPriority(EXTI0_1_IRQn, 0); NVIC_EnableIRQ(EXTI0_1_IRQn); } /** * @brief 中断入口函数，每产生一次下降沿,LED翻转一次 * @param 无 * @retval 无 */ void EXTI0_1_IRQHandler(void) { /* 处理EXTI中断请求 */ if(LL_EXTI_IsActiveFlag(LL_EXTI_LINE_1)) { //LL_GPIO_TogglePin(GPIOA,LL_GPIO_PIN_6); //反转 LL_EXTI_ClearFlag(LL_EXTI_LINE_1); } } 配置A7口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ad58c9c5e9ba626fb3788df801bad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5ce268ed8674112b961240746f46f4/" rel="bookmark">
			Apollo新版本Beta技术沙龙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有幸参加Apollo开发者社区于12月2日举办的Apollo新版本(8.0)的技术沙龙会，地址在首钢园百度Apollo Park。由于去的比较早，先参观了一下这面的一些产品，还有专门的讲解，主要讲了一下百度无人驾驶的发展历程和历代产品。我对下面几个产品印象颇深： 首先是无人驾驶已经可以打车了，通过萝卜快跑小程序就可以，已经在很多城市普及了，未来如果全方面普及的话可以大大方便人们的出行效率，并且还可以减低出行成本，这次去正好碰到滑雪比赛，不能体验无人驾驶，有机会要打车试一下。
一个是未来驾舱，从外部来看，很简洁的设计，科技感十足，从内部来看，取消了方向盘那些操控，使内部空间变得很大，很舒适。以后如果有这样一款车，应该很不错。
还有一个产品是5G云代驾，第一次听说过这个，本来以为无人驾驶已经很超前了，通过云代驾，可以远程控车，一旦无人驾驶时候出现异常，可以接管驾驶权，驾驶员通过这个方向盘可以实现自己的操作，左右显示屏能看到周围画面，并且还是5G，这样延时率很低。除此之外还可以用再一些危险作业，比如说矿车那些，有这样的远程控车，可以大大减少安全隐患。
接下来让我们进入正题，参观完之后就开始今天的技术沙龙会了。
首先整体介绍了Apollo新版本的一些功能，相比于旧版本有很大提升，不仅简化了之前的一些操作流程，还变的更有条理，8.0版本推出的包管理，降低了模块之间的耦合性，可以实现高效复用。然后主要介绍了三个方面：工具、算法、工程。
工具方面：支持本地Pnc仿真调试，还有云实验平台，大大减少开发者搭建环境的周期，只需要输入一条指令开启环境，然后运行dreamview就可以。
然后就可以选择你想仿真的模块（PNC、感知等），然后去配置你想设置的环境，运行就可以。
算法方面：主要是从三个方面进行了升级优化：采用了新的CenterPoin模型、提供了增量训练、新增支持4D毫米波。
增量训练可以在原有检测能力下，显著提升特殊目标和特殊场景的检测能力，从而达到用低成本轻松提升定制场景的检测效果。
在演讲过程中，王老师举了一个挂车的例子，没有增量训练前，将挂车识别为两个物体
进行增量训练后，新模型监测效果，可以正常监测到这种特殊挂车。
4D毫米波主要是提高雨雪雾等特殊天气下的安全性。
最后就是一个开放性的交流会，大家畅所欲言，去找自己感兴趣模块的老师，整个环境也是很融洽，我这面也是听王老师去逐一讲解大家提出的问题，受益匪浅。
非常难得的一次线下交流会，学到了很多，使我对于无人驾驶的开发提起了兴趣，平常会去社区学习一下，开发出属于自己的无人驾驶。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce1256c1a8d211e7f11fd6b8f6d37c8a/" rel="bookmark">
			微信小程序如何跳转到网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序可以使用wx.navigateToMiniProgram方法实现跳转到其他小程序，但是跳转到网页需要使用wx.navigateTo方法，并将所跳转的地址写在URL参数中。
例如，跳转到百度的网页可以使用以下代码：
wx.navigateTo({ url: 'https://www.baidu.com' }) 其中，URL参数后面可以带上查询参数，如：
wx.navigateTo({ url: 'https://www.baidu.com/s?wd=小程序' }) 这样就可以在百度上搜索“小程序”。
也可以通过web-view组件将H5页面嵌入小程序中展示。具体操作如下：
在小程序页面的json文件中引入web-view组件 { "usingComponents": { "web-view": "/path/to/web-view/component" } } 在小程序页面WXML文件中添加web-view组件 &lt;web-view src="https://www.example.com"&gt;&lt;/web-view&gt; 其中src属性指定要嵌入的H5页面的链接。
注意：小程序中的web-view组件有一定的限制，例如无法访问本地文件，同时需要注意H5页面的适配性和性能问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050c90386049a5c778a85ea31fea1fac/" rel="bookmark">
			不同角度范围下四元数转欧拉角的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在标定过程中求出的欧拉角与预设真值差距太大，检查中发现求出的角度与真值角度都可以将车辆坐标系变换到相机坐标系。后通过查阅文献，发现四元数对应的欧拉角并不唯一，在不同的条件下可求出不同的欧拉角，实际应用中需根据实际设定的角度范围选择对应的欧拉角。
[1] 夏喜旺,杜涵,刘汉兵.关于大角度范围内四元数与欧拉角转换的思考[J].导弹与航天运载技术,2012,(05):47-53.
四元数与欧拉角 使用欧拉角描述空间旋转时， θ \theta θ与 2 π + θ 2\pi+\theta 2π+θ可表示相同的姿态，即使在 ( − π , π ) (-\pi,\pi) (−π,π)范围内，也有 ( ψ , θ , γ ) (\psi,\theta,\gamma) (ψ,θ,γ)与 ( ψ − s g n ( ψ ) π , s g n ( θ ) π − θ , γ − s g n ( γ ) π ) (\psi-sgn(\psi)\pi,sgn(\theta)\pi-\theta,\gamma-sgn(\gamma)\pi) (ψ−sgn(ψ)π,sgn(θ)π−θ,γ−sgn(γ)π)表示相同的姿态。
四元数描述姿态 设 ( ψ , θ , γ ) (\psi,\theta,\gamma) (ψ,θ,γ)为z-y-x旋转顺序下的欧拉角，则当前旋转对应的欧拉角为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/050c90386049a5c778a85ea31fea1fac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f4443d33cb2a7d7d2c3cbb45f163c7/" rel="bookmark">
			centos7安装minio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的安装步骤;
1.新建路径及文件
mkdir /mysofewares 在根目录建了一个文件夹存放我的软件
mkdir minio新机minio文件路径
mkdir data bucket存放位置
下载minio 如果没有wget，yum install wget安装
wget https://dl.min.io/server/minio/release/linux-amd64/minio
现在文件
启动方式：
1. ./minio server data
启动成功
2.
给start.sh授权 chmod +x startup.sh
编辑 startup.sh vim startup.sh
在startup.sh中插入
nohup ./minio server /mysofewares/minio/data &gt; /mysofewares/minio/minio.log &amp;
启动 sh startup.sh
这个界面启动成功
去浏览器验证一下
结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50aa7f85503e28b314faf5423f12ab4d/" rel="bookmark">
			用第三方拖拽库快速撸一个可视化搭建平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直在研究可视化和零代码搭建相关产品和技术, 最近逛 github 的时候发现一个比较有意思的拖拽开源组件, 就用 vue3 简单撸了一个拖拽搭建的小demo, 供大家参考学习.
可视化拖拽demo项目介绍 空闲时间简单设计了几个功能, 如下:
支持设置拖拽单位(阈值)
支持撤销重做
支持导入和导出 json
支持组件全选 / 组合
技提供了常用的四个基础组件(文本, 图片, 音频, 视频)
因为之前我的技术栈主要是react, 为了让更多小伙伴低成本的上手, 这里项目采用大家比较熟悉的vue3 + vite.
项目采用的拖拽开源库 es-drager, 当然为了更好的显示代码, 也使用了 monaco-editor, 如下是它的代码展示效果:
image.png 整体来说展示效果还是不错的, 为开源作者们点赞.
完整项目仓库地址: https://github.com/MrXujiang/vue3-drag-demo
线上演示地址: drag_demo 可视化拖拽
一些技术实现的介绍 我之前在社区和公众号也写了很多低代码的技术上实现原理, 如
前端图形学实战: 从零实现编辑器的图层管理面板和实时缩略图(vue3 + vite版)
Dooring无代码搭建平台技术演进之路
上面的demo主要实现思路拆解如下:
实现组件从左侧面板拖拽到画布
组件在画布中的移动, 操作(全选, 拉伸, 旋转, 参考线等)
组件属性的配置
可视化的相关操作(导入, 导出, 撤销, 重做等)
1.实现组件从左侧面板拖拽到画布 这里实现也很简单, 我们采用H5的原生api: drag &amp; drop 来实现. 也就是说从左侧面板拖拽到画布, 本质上是数据的移动.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50aa7f85503e28b314faf5423f12ab4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33c9836bac1642b30d5cf89a851676c/" rel="bookmark">
			[PTA]验证“哥德巴赫猜想”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学领域著名的“哥德巴赫猜想”的大致意思是：任何一个大于2的偶数总能表示为两个素数之和。比如：24=5+19，其中5和19都是素数。本实验的任务是设计一个程序，验证20亿以内的偶数都可以分解成两个素数之和。
输入格式： 输入在一行中给出一个(2, 2 000 000 000]范围内的偶数N。
输出格式： 在一行中按照格式“N = p + q”输出N的素数分解，其中p ≤ q均为素数。又因为这样的分解不唯一（例如24还可以分解为7+17），要求必须输出所有解中p最小的解。
输入样例： 输出样例： /*注：我的思路就是用三个函数分别做三大功能，主要就是函数之间的返回相对来说 不太好理解，总之就是用一个函数不同情况的返回值来判断是否为素数，应该思路还 是比较简单*/ #include&lt;stdio.h&gt; int function(int m);//功能函数1：对输入的n值进行拆分 int Pan(int a);//功能函数2：判断拆分的两个数字是否为素数 int main() { int n; scanf("%d", &amp;n); function(n); return 0; } //主函数：为n赋上要求的值 int function(int m) { int count = 2; for (int i = 0; i &lt; m/2; i++) { int panduan = Pan(count); if (panduan==1)//判断依次递增的数是否为素数 { int yu_count = m - count; int panduan_ = Pan(yu_count); //下面判断拆分的另一个数是否为素数 if (panduan_==1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a33c9836bac1642b30d5cf89a851676c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a812179791a99efd6d86a92d6ae0d92b/" rel="bookmark">
			MySQL中的 增 删 查 改（CRUD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
新增
insert into 表名 value(数据，数据),.......；
insert into 表名（列1，列2.....） value(数据，数据),.......；
datatime 类型的数据如何插入？
查询
select * from 表名；
select 列1,列2...... from 表名；
查询字段为表达式
为查询结果的列 取别名
去重：DISTINCT
排序：ORDER BY
条件查询
比较运算符
逻辑运算符
注：select 条件查询的执行顺序
分页查询：LIMIT
删除
delete from 表名 ;
delete from 表名 where 条件;
修改
update 表名 set (列名=值),(列名=值).... where 条件；
先创建一个名为： title 表：下文的所有操作都基于此表
注：因为MySQL对大小写不敏感所以大写小写都可以。
新增 insert into 表名 values/value(数据，数据),.......； 可以单行，多行插入。
insert into 表名（列1，列2.....） value(数据，数据),.......； 指定列插入，可以单行，多行插入。
datatime 类型的数据如何插入？ 可以用一个固定格式的字符串来表示日期
还可以利用 now() 函数获取当前时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a812179791a99efd6d86a92d6ae0d92b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/37/">«</a>
	<span class="pagination__item pagination__item--current">38/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/39/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>