<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e95ad81e60c8c857993fdd93c2eff3a/" rel="bookmark">
			削峰填谷与应用间解耦：分布式消息中间件在分布式环境下并发流量控制的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是《百图解码支付系统设计与实现》专栏系列文章中的第（18）篇，也是流量控制系列的第（4）篇。点击上方关注，深入了解支付系统的方方面面。
本篇重点讲清楚分布式消息中间件的特点，常见消息中间件的简单对比，在支付系统的应用场景，比如削峰填谷，系统应用间的解耦，事务消息等。
内容偏入门介绍，已经使用过消息中间件的同学可以不用往下看了。
1. 前言 在流量控制系列文章中的前四篇，分别介绍了固定时间窗口算法、滑动时间窗口算法、漏桶原理、令牌桶原理，应用场景和java版本的核心代码。
我们做个简单回顾：
固定窗口：算法简单，对突然流量响应不够灵活。超过流量的会直接拒绝，通常用于限流。
滑动窗口： 算法简单，对突然流量响应比固定窗口灵活。超过流量的会直接拒绝，通常用于限流。
漏桶算法：在固定窗口的基础之上，使用队列缓冲流量。提供了稳定的流量输出，适用于对流量平滑性有严格要求的场景。
令牌桶算法：在滑动窗口的基础之上，使用队列缓冲流量。提供了稳定的流量输出，且能应对突发流量。
今天讲的分布式消息中间件在支付场景的削峰填谷用得比较多，且对精度没有那么苛刻的场景，比如集群低到1TPS，就无法做到。
2. 削峰填谷原理 削峰：在流量高峰期，通过消息中间件暂存大量的请求，减少对后端系统的直接压力。
填谷：在低峰期，逐渐处理这些积累的请求。
这种方法能有效平衡系统负载，防止在高峰时段系统崩溃。
我们一般使用消息中间件实现削峰填谷。下面是一个支付引擎自产生消的示例图。收到支付请求后，先扔到消息中间件，然后启用新的监听线程去消费。通过控制消费线程数来控制流量。
比如一下来了1000个请求，一共10台机器，每台机器消费线程只开5个，每个请求处理500ms，那么每秒就处理100个请求，共耗时10秒处理完。
消息中间件还有一个作用，就是应用间的解耦。比如支付成功后，渠道网关通过消息中间件返回给支付引擎。
3. 常见的分布式消息中间件介绍 消息中间件有很多，这里简单对比 RocketMQ、RabbitMQ 和 Kafka在性能、可靠性、易用性、功能特性、适用场景等方面的不同。如下：
性能
RocketMQ: 提供非常高的性能和吞吐量，特别适合大规模的消息传输和处理场景。RabbitMQ: 性能优秀，尤其在小型消息的传递上非常高效。但在处理非常大量的消息时，性能可能不如 Kafka 和 RocketMQ。Kafka: 专为高吞吐量设计，特别适合需要处理大数据流的场景。它在持久化和分布式处理方面的性能表现尤其出色。 可靠性
RocketMQ: 提供高可靠性保证，支持分布式事务。RabbitMQ: 通过消息持久化、交付确认等机制提供可靠的消息服务。Kafka: 数据持久化和高容错能力，确保了高可靠性。 易用性和管理
RocketMQ: 相对复杂，需要一定的学习曲线，但提供丰富的特性和灵活性。RabbitMQ: 用户友好，易于安装和配置，拥有直观的管理界面。Kafka: 配置和管理相对复杂，但社区支持强大，提供了丰富的文档资源。 功能特性
RocketMQ: 支持广泛的消息模式，包括顺序消息、定时/延时消息和事务消息。RabbitMQ: 提供多种消息路由模式，支持灵活的消息模型和多种协议。Kafka: 专注于高吞吐量的消息队列和流处理，支持实时数据处理。 适用场景
RocketMQ: 适用于大规模分布式系统中的消息处理，如电商平台和金融系统。RabbitMQ: 适合需要复杂路由、多种消息协议和高效小消息处理的场景，如企业应用集成。Kafka: 非常适合于需要高吞吐量、大数据处理和实时流处理的应用，如日志聚合和实时监控系统。 结论
在支付系统，我个人更推荐RocketMQ，原因有两个：第一，经过阿里电商+支付各种非常高并发的大促洗礼，RocketMQ 在大型分布式系统中表现出色。第二，支持事务消息，这个在支付领域还是很有用的。 另外，我也只是简单介绍，大家实际应用的时候，根据实际情况去选型，建议是做多方了解后，部署验证后才规模使用。不过话说回来，这几款分布式消息中间件的技术非常成熟了，除了几个顶流的互联网公司外，基本可以随便用，哪个手熟就使用哪个。
4. 使用注意事项 脑裂问题
曾经在生产环境碰到过RabbitMQ脑裂问题，交易全部中断。在分布式环境中完全避免也不现实，建议加强监控。
消费线程数问题
消费线程要合理设置，太多，可能达不到削峰填谷的效果，太少，消息有可能会积累，影响处理时效。
比如支付是有时效，积压太久就会导致用户放弃支付。
消息积压应对
提前做好预估，以及监控。一旦把中间件压爆，可能整个交易系统。
持久化与恢复
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e95ad81e60c8c857993fdd93c2eff3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/646649781f3248d7213c8dd7b8fe6130/" rel="bookmark">
			基于网络爬虫的天气数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、网络爬虫设计 网络爬虫原理 网络爬虫是一种自动化程序，用于从互联网上获取数据。其工作原理可以分为以下几个步骤：
定义起始点：网络爬虫首先需要定义一个或多个起始点（URL），从这些起始点开始抓取数据。
发送HTTP请求：爬虫使用HTTP协议向目标网站发送请求，获取网页内容。通常使用GET请求来获取页面的HTML代码。
获取网页内容：当网站接收到请求后，会返回相应的网页内容。爬虫将接收到的响应解析为字符串形式，以便进一步处理。
解析网页：爬虫使用解析库（如BeautifulSoup、lxml等）对网页进行解析，提取所需的数据。解析过程涉及HTML结构分析、XPath或CSS选择器的使用，以定位和提取目标数据。
处理数据：爬虫对提取的数据进行清洗、去除噪声、转换格式等处理操作，以确保数据的质量和一致性。
存储数据：根据需求，爬虫可以将处理后的数据存储到数据库、文本文件、Excel表格或其他数据存储介质中。
跟踪链接：爬虫会根据预设规则或算法，从当前页面中提取其他链接，并将这些链接加入待抓取队列。这样，爬虫可以深入遍历网站的各个页面。
网络爬虫的程序架构及整体执行流程 1、网络爬虫程序框架 基于Python的网络爬虫的天气数据分析项目，以下是网络爬虫程序框架：
导入所需的模块和库：导入了requests、csv和BeautifulSoup等库，以便进行HTTP请求、CSV文件操作和HTML解析。
设置请求头信息：定义了headers字典，包含了User-Agent信息，用于伪装浏览器发送请求。
定义城市列表和日期范围：给定了一个城市列表list1，其中每个元素包含了城市名称和对应的区域ID。同时，通过循环遍历1到12的范围，获取每个月的数据。
发送HTTP请求并解析响应：通过构建URL，发送HTTP GET请求获取天气数据的JSON响应。然后使用json()方法将响应内容解析为Python对象。
解析网页内容：使用BeautifulSoup库将响应内容转换为BeautifulSoup对象，以便提取数据。通过使用HTML标签和属性进行定位，使用find_all()方法获取每一行（tr标签）的数据。
提取数据并写入CSV文件：在每一行中，使用find_all('td')方法获取每列的数据，并提取日期、最高温度、最低温度、天气、风力风向和空气质量指数。然后将这些数据存储在列表list0中。
异常处理：使用try-except语句捕获可能出现的异常，并跳过处理。网络爬虫程序架构如图1所示。
2、网络爬虫的整体流程 获取初始URL；发送请求并获取响应；解析HTML页面； 数据处理和存储；分析是否满足停止条件，并进入下一个循环。 网络爬虫的整体流程图如图2所示。
图2 网络爬虫的整体流程图
网络爬虫相关技术 数据爬取 使用requests库发送HTTP请求，并使用headers伪装浏览器标识。程序遍历城市列表和月份范围，构建URL并发送请求获取天气数据的JSON响应。然后，使用BeautifulSoup库解析响应内容，并使用HTML标签和属性定位数据。爬虫提取日期、最高温度、最低温度、天气、风力风向和空气质量指数等数据。最后，通过将数据写入CSV文件，实现数据的存储和持久化。这个爬虫程序使用了多个库和模块，通过编写合适的代码逻辑，实现了从目标网站上爬取天气数据的功能。
数据解析 数据解析部分使用了BeautifulSoup库对爬取到的网页内容进行解析。首先，将响应内容传递给BeautifulSoup构造函数，并指定解析器为'lxml'。然后，通过调用find_all()方法定位目标数据的HTML元素，使用索引和属性获取具体的数据值。在这个程序中，使用find_all('td')获取每一行的所有列数据，并通过索引提取日期、最高温度、最低温度、天气、风力风向和空气质量指数等信息。解析得到的数据存储在相应的变量中，然后可以进一步处理或写入CSV文件。通过使用BeautifulSoup库的强大功能，程序能够有效地从HTML页面中提取出所需的数据，并进行后续的处理和分析。
数据存储 文本文件：将数据以文本文件的形式进行存储，例如使用CSV（逗号分隔值）或JSON（JavaScript对象表示）格式。这种方法简单直接，适合存储结构化的数据。
反爬虫 User-Agent检测：网站可能会检查HTTP请求中的User-Agent字段，如果发现与普通浏览器的User-Agent不匹配，则可能被视为爬虫并拒绝访问。所以想要设User-Agent模拟浏览器。
请求频率限制：网站可以设置对于同一IP地址或同一用户的请求频率进行限制，如果超过限制，则可能被视为爬虫并暂时禁止访问。需要设置睡眠时间，降低采集频率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924659a8a8e1503085d8bb5f8913a900/" rel="bookmark">
			27岁遇到迷茫期，想转行学技术，有什么推荐吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 从最新Python招聘岗位需求来看，Python工程师的岗位需求量巨大，并且岗位需求量还在呈现上涨的趋势。
Python人才需求逐年增加，从市场整体需求来看，Python在招聘市场上的流行程度也是在逐步上升的，工资水平也是水涨船高。据统计Python平均薪资水平在12K，随着经验的提升，薪资也是逐年增长。
学习python编程，不仅可以找到一份高薪工作，而且不打算转化或者是在校学生的话，也能为你的日常生活提高一些帮助，比如：自动化办公 爬取一些数据信息之类的…另外闲暇时间也可以在网上接点小单，增加些收入 至少不用为生活费发愁
Python作为一门编程语言，一门技术，就一定能够为我们所用，至少赚个外快是绝对没有问题的。
渠道一：淘宝搜python程序
可以到淘宝上搜，Python程序，到相应的店里找客服，就说你想做程序开发，给个联系方式。后面加的群多了，你做的单多了，做的好，会不断的有人拉你进群，可选择性会大大增加。
我今年写了大概20单，总共收入是接近3000块钱，Python，c，java的都接。都是没有商用的项目，感觉开始做的时候技术有些提升，后来，接的多了，自己之前写的就可以做为模板，快速开发，但是技术提升没以前显著。
看到感兴趣的再接，有时候见到钱就很难收手，要学会克制。
渠道二：游戏外挂
主要开发工具为按键精灵，赚的不多，但是属于持续性收入，基本上可以覆盖整个游戏的生命周期，但随着监管力度增大，风险越来越高，本人已经退出这个行业。
做外挂其实是有一定难度的，不是你会一点简单的python语法，写过几个小项目就能够做出来的！一般来说做游戏外挂也就是一些小一点的外挂，技术性不是特别强的！如果想用python来做一些大型的游戏外挂，还是算了！太危险了！
渠道三：编程老师
Python纳入小学生课程不是什么新闻了，过几年信息技术将那入高考，有需求就有市场，现在各大教育公司招聘python少儿编程老师，有全职有兼职，时薪80-200不等，远高于大部分普通课程啦~
当然你自己也得学完一套课程，能带学生作出一些小游戏项目，在教学的过程中同时又在不断打磨自己的基本功。
网络教学：现在网络直播已经是非常的火爆了，直播不仅仅是游戏唱歌等等，还可以进行网络授课，每周都可以利用业余时间，进行网络授课，python目前的授课费用还是非常可观的。
渠道四：抓取数据
Python的必修课之一就是web开发和爬虫。但是这两项想要赚钱的话，就必须知道开发什么爬什么数据才能赚钱。
举例：帮一些证券大佬抓取一些财经新闻或者是舆情相关的数据，开发玩了之后每个月要保证爬虫不挂的话基本上可以收入3-5k。自己买个云主机的话，一个月要两三百的成本，自己还能做别的事情。
但是一定不要做违反相关法律的事！！切忌因小失大！
渠道五：网站接单
比如很多学编程的都开始发展自媒体：
微信公众号，广告接单；
知乎，赞赏获利；
b站，1000播放量3块钱；
当然了，自媒体需要积累，如果能够忍受前期0收入0阅读阶段，不断坚持运营，后期的收入还是很客观。
当然这些只是说明用python来业余时间赚钱的方法，如果学的好找一份python相关的工作，月入1w+也完全不成问题！
就像潘老说的，这个时代最需要我们学习，最需要占据我们大脑的，python应当在其中。
而且很多接单网上面的案例都比较简单，可能只需要你十几分钟就能搞定的小案例，都可以获得几百元的金额。
那些几百的小单子对于很多人而言是非常简单的，十几分钟就能搞定，你试想一下十几分钟写完一个单子就是几百块，难道这样还不足以让你有学习Python的动力？
最后提醒一下，作为一个IT人员，不进则退，所以一定不要忘记提升自己。一定要多注意最新的编程动向，紧跟时代的步伐，不要让时代遗忘。
让Python开启你的无限可能 这里帮大家总结了更多可以用到Python的岗位或人群，欢迎对号入座，参照找到Python能帮自己解决问题的方向：
在校学生
用Python爬取资料，写论文搜集素材不发愁；让能力和职场需求无缝衔接，为求职简历加分。
科研岗位
可以用Python全网爬取前沿科技成果和资料，为研究项目提供强大支持。
行政专业
用Python完成公司资产盘点、考勤统计、薪资计算等，轻松实现办公自动化。
财务专业
用Python完成庞大的税务数据统计，做公司整体财务分析报表、次年支出预测。
销售行业
通过Python可以生成销售业绩报表，进行分析拆解；抓取竞对情况进行统计和分析，做到知己知彼。
设计岗位
通过Python全网抓取最流行的趋势、最精美的图片、最新的创意，让甲方爸爸点头不是梦。
文案岗位
全网爆文海量爬取、学习和拆解，用最高效的方法掌握规律，分分钟打造属于自己的10w+。
营销岗位
通过Python抓取统计用户数据，绘制用户画像，精准投放，让营销有的放矢，节约营销成本，提升转化效率。
学生、运营、设计、策划、销售、HR、财务、金融从业者、电商从业者、创业者…
一切在学习和工作中需要面对大量信息资料，分析海量数据的人，都有必要让Python为自己赋能。
读者福利：如果你对Python感兴趣，小编便准备了这套python学习资料
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括：Python安装包+激活码、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习等学习教程。带你从零基础系统性的学好Python！
零基础Python学习资源介绍 👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/924659a8a8e1503085d8bb5f8913a900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b554939f847e48c54909588a7cf488cb/" rel="bookmark">
			翻译: Streamlit从入门到精通七 缓存Cache控制缓存大小和持续时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Streamlit从入门到精通 系列：
翻译: Streamlit从入门到精通 基础控件 一翻译: Streamlit从入门到精通 显示图表Graphs 地图Map 主题Themes 二翻译: Streamlit从入门到精通 构建一个机器学习应用程序 三翻译: Streamlit从入门到精通 部署一个机器学习应用程序 四翻译: Streamlit从入门到精通 高级用法缓存Cache和Session 五翻译: Streamlit从入门到精通六 实战缓存Cache请求数据
1. 控制Cache缓存大小和持续时间 如果您的应用运行时间较长，并且不断缓存函数，您可能会遇到两个问题：
由于缓存太大，应用内存不足。缓存中的对象会变得陈旧，例如，因为您缓存了数据库中的旧数据。 您可以使用 ttl 和 max_entries 参数来解决这些问题，这两个参数都可用于缓存装饰器。
1.1 ttl （time-to-live） 参数 ttl 设置缓存函数的生存时间。如果该时间已到，并且再次调用该函数，则应用将丢弃任何旧的缓存值，并且将重新运行该函数。然后，新计算的值将存储在缓存中。此行为对于防止过时的数据（问题 2）和缓存增长过大（问题 1）非常有用。特别是在从数据库或 API 中提取数据时，您应该始终设置 ttl，这样您就不会使用旧数据。下面是一个示例：
@st.cache_data(ttl=3600) # 👈 Cache data for 1 hour (=3600 seconds) def get_api_data(): data = api.get('https://jsonplaceholder.typicode.com/posts/1') return data Tip提示 您还可以使用 timedelta 设置 ttl 值，例如 ttl=datetime.timedelta(hours=1)
1.2 max_entries参数 max_entries设置缓存中的最大条目数。缓存条目数的上限对于限制内存（问题 1）很有用，尤其是在缓存大型对象时。将新条目添加到完整缓存时，将删除最旧的条目。下面是一个示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b554939f847e48c54909588a7cf488cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53258e7fc68071509a56eab06c5bcf1e/" rel="bookmark">
			Python应该怎么学，如何系统地学习Python？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Python是一种常用的编程语言，具有简单易学、实用高效、开源免费等优点，近年来受到了越来越多开发者的青睐。那么，怎么学习Python呢？
一、基础入门 学好任何一门编程语言，首先需要掌握的是其基本语法、数据类型和流程控制语句。对于Python来说，这一部分并不难。Python的语法非常简单，而且可以通过在线编译器或者安装Python解释器轻松入手。
推荐初学者使用Visual Studio Code或Pycharm等集成开发环境，这些软件提供了友好的图形化操作界面，同时还带有代码自动提示和错误提示等功能，可以大大提升学习效率。
学习Python的过程中，我们需要掌握的其中一个重点就是函数。函数是Python的重要特性，通过定义函数，我们可以将程序代码分割成若干个独立的部分，从而简化代码结构。初学者可以从定义简单的函数开始练习，逐渐提升难度，增强对函数的理解和掌握。
二、开发实战 除了理论的学习，实践经验也非常重要。Python的应用领域非常广泛，可以用于Web开发、人工智能、数据分析及可视化等多个方面。因此，我们可以通过开发实战项目来锻炼实际操作能力，丰富自己的技能。
Python找出重复的文件是一个很好的入门项目，这个项目利用OS库进行文件处理，操作起来非常简单，但能够锻炼基础操作能力。同时，这个项目也提供了代码优化的可能，学无止境。
还可以尝试开发一个基于Python的Web应用程序。Flask是一种轻量级的Web框架，非常适合初学者快速开发Web应用。我们可以用Flask开发自己的博客或信息化管理系统，以此提升Python web开发能力。
三、学习社区 在Python的学习过程中，社区和论坛是非常有用的资源。Python社区拥有众多的开发者和爱好者，他们会在社区发布教程、资源、项目等内容，并持续地讨论和分享Python相关的经验和知识。因此，我们可以加入Python社区，参与讨论、提问和解答问题，从中学习到更多的优秀资源和经验。
GitHub是另一个重要的资源库，Python的开源项目都可以在GitHub上找到相应的仓库。通过阅读他人的代码，我们不仅可以学习Python常用的库和框架，也可以了解其他开发者的编程思路。
英文好的朋友可以去PyCoder’sWeekly，有最新的Python相关的消息，还有一些含金量比较高的教材，喜欢的小伙伴可以参照学习。
总结 学习Python是一个非常良好的投资，它可以为我们提供技能、工作机会，并大大拓宽我们的思路和视野。在学习Python的过程中，我们应该重视基础和实践，坚持不断地学习和尝试，一个长期的学习计划是非常有必要的。
当然，学习需要费时间和精力，未来会有艰难困苦，但是我们最终会走向成功。学习Python并不是一条平坦的路，但是那些坚定不移向前的人，一定会最终得到属于自己的成功。
读者福利：如果你对Python感兴趣，小编便准备了这套python学习资料
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括：Python安装包+激活码、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习等学习教程。带你从零基础系统性的学好Python！
零基础Python学习资源介绍 👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉Python基础👈 👉Python自动化办公教程👈 👉python爬虫 👈 👉python机器学习 👈 👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 这份完整版的Python全套学习资料已经上传网盘，朋友们如果需要可以点击下方微信卡片免费领取 ↓↓↓【保证100%免费】 或者
【点此链接】领取
好文推荐 了解python的前景：https://blog.csdn.net/xiangxue888/article/details/129726286
了解python的副业：https://blog.csdn.net/xiangxue888/article/details/129726009
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35bb839683a8733319d8f81f2852da6f/" rel="bookmark">
			apache-commons-lang3 的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.12.0&lt;/version&gt; &lt;/dependency&gt; StringUtils.isAnyBlank(userAccount, userPassword, checkPassword) 更多用法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5199adf84920fbb14bf6666d4eb0763/" rel="bookmark">
			Python是编程语言里最好的语言？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Python是编程语言里最好的语言？今天小编和大家聊聊!
我不会说Python是最好的编程语言，因为不存在这样的东西。有很多人诋毁 Python，Python也有自己的问题。
Python与其他动态语言一样的是它提供了一种自由。你可以定制对象生命周期的几乎每个方面。一旦对象被创建，可以以任何方式改变它们，例如加载一个新版本的类的实例，移动所有的数据并拥有一个新版本的实例。有些东西不容易被改变？没问题，通常有其他方法可以做到这一点。
Python有许多专家组成多元的社区。
Python还有一个非常丰富的第三方库集。你几乎可以找到所需的任何内容，而不必自己编写。
Python的应用范围相当广泛。它不仅仅是用来创建有趣的、带有Django的初创网络应用，ML的流行对Python有很大的好处。
那么有什么问题呢？
性能，特别是CPU约束的任务并没有让Python大放异彩。
动态性质的成本很高，我不会把动态类型称为缺点。这只是一个功能。尽管如此，它还是一种强类型语言，不会出现愚蠢的错误。
Python的知名度是它的友好性，容易学习。语法简洁，易于阅读。
当涉及到Python编程时，很少有仪式感。没有模板，没有对数据类型的乱七八糟的操作，Python是动态类型的。
由此，关于Python的其他所有优点都会显现出来
Python被数据科学家，机器语言研究人员，科学家和工程师，财务分析师等广泛使用。
由于它的广泛使用，有一个巨大的库、框架和工具的生态系统。这使得Python成了通用语言。
Python具有庞大的用户社区，可以轻松聘请程序员并获得支持。有大量的Python学习资源。
有很多Python程序员的工作。根据各大招聘软件，Python的招聘信息数量位居第二(Java是最多的)。
但是，如果不知道如何扩展Python的动态类型，那么它也可能是一个缺点。关键是要使用正确的方法来编写非常大的Python应用程序。
Python的缩进语法使人发疯，最轻微的错位都会造成大灾难。
Python的GIL（或全局解释器锁）会严重影响性能。
Python并不适合并发。在多核处理器的时代，这一点变得越来越重要。这就是为什么Go语言起飞了。
Python的OOP实现是从Smalltalk那里借来的，它根本没有Smalltalk的好。但是，世界上没有任何一种OOP语言可以与Smalltalk的优雅和纯洁相提并论。
Python完全不适合系统编程，例如写操作系统和设备驱动程序。
Python无法编写高性能的图形程序。
没错，Python是一种很好的语言，但是我们不要要求太多。
总而言之，我认为任何一种语言都不应该被称为最佳语言。一切都取决于项目。Python在网络上效果特别好。这也很容易学习。
每个程序员都应该至少知道一种动态编程语言
读者福利：如果你对Python感兴趣，小编便准备了这套python学习资料
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括：Python安装包+激活码、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习等学习教程。带你从零基础系统性的学好Python！
零基础Python学习资源介绍 👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉Python基础👈 👉Python自动化办公教程👈 👉python爬虫 👈 👉python机器学习 👈 👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 上述这份完整版的Python全套学习资料已经上传网盘，朋友们如果需要可以微信扫描下方二维码输入“领取资料” 即可自动领取 或者
【点此链接】领取
好文推荐 了解python的前景：https://blog.csdn.net/xiangxue888/article/details/129726286
了解python的副业：https://blog.csdn.net/xiangxue888/article/details/129726009
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c82b187589695196ffe4436ef1474b/" rel="bookmark">
			蓝桥杯练习题（十）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📑前言 本文主要是【算法】——蓝桥杯练习题（十）的文章，如果有什么需要改进的地方还请大佬指出⛺️
🎬作者简介：大家好，我是听风与他🥇
☁️博客首页：CSDN主页听风与他
🌄每日一句：狠狠沉淀，顶峰相见
目录 📑前言1181.数的幂次120.最大比例1276.小明的彩灯差分 17162.小明的衣服📑文章末尾 1181.数的幂次 package 蓝桥杯第十一次; import java.util.Scanner; public class 数的幂次 { public static void main(String[] args) { // TODO Auto-generated method stub Scanner sc = new Scanner(System.in); int n = sc.nextInt(); while(n--&gt;0) { System.out.println(f(sc.nextLong(),sc.nextLong(),sc.nextLong())); } } public static long f(long a,long b,long p) { long ans = 1; while(b&gt;0) { if((b&amp;1)!=0) ans=ans*a%p; a=a*a%p; b=b&gt;&gt;1; } return ans; } } 120.最大比例 import java.util.Arrays; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c82b187589695196ffe4436ef1474b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceb7a3e2382825cd93d319513fe5dafd/" rel="bookmark">
			Python脚本实现数据自动获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 背景介绍
自动化运维在当前IT行业中变得越来越重要，特别是在大型企业中，由于服务器数量的增加和复杂性的提高，手动运维已经变得非常困难，甚至是不可行的。自动化运维脚本可以显著降低运维的复杂性和成本，并提高系统的稳定性和可靠性。
在现实应用中，自动化运维脚本通常用于完成系统的配置、部署、监控、维护和更新等任务。以Python为例，这种脚本可以使用各种Python库和工具进行开发，例如Fabric、Ansible和Saltstack等。
一个典型的自动化运维脚本可以自动化完成一系列任务，例如：自动更新操作系统、安装和配置软件、自动备份数据、自动化监控系统等等。此外，自动化运维脚本还可以根据不同的需求和情况，自动化调整和优化系统资源，例如：自动化调整服务器的内存、CPU和网络带宽等。
【----帮助Python学习，以下所有学习资料文末免费领！----】
自动化运维脚本的应用场景非常广泛，特别是在大型企业和互联网公司中，他们需要维护大量的服务器和网络设备。使用自动化运维脚本可以极大地提高运维效率，减少人为错误，提高系统的稳定性和可靠性。
此外，自动化运维脚本还可以帮助企业节省大量的运维成本，特别是在人力和时间方面。企业可以利用这些成本节省来进一步提高其业务的竞争力和市场份额。
项目分析
假设我们有一个简单的网站应用程序，它需要每天从一个外部API获取数据，并将数据存储在本地MySQL数据库中。我们可以编写一个自动化的Python脚本来完成这些任务。
代码如下。
import requests import pymysql from datetime import datetime, timedelta # 配置参数 API_ENDPOINT = "https://api.example.com/data" DB_HOST = "localhost" DB_USER = "root" DB_PASS = "password" DB_NAME = "myapp" TABLE_NAME = "data" # 获取当前时间 now = datetime.now() # 计算昨天日期 yesterday = now - timedelta(days=1) yesterday_str = yesterday.strftime('%Y-%m-%d') # 发送请求获取数据 response = requests.get(API_ENDPOINT, params={"date": yesterday_str}) data = response.json() # 连接数据库 conn = pymysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceb7a3e2382825cd93d319513fe5dafd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc8401cca98bf2780416625b51561d04/" rel="bookmark">
			花了一周时间，终于把python爬虫入门必学知识整理出来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Python是近几年最火热的编程语言，大家既然看到了爬虫的知识，想必也了解到python。
很多都说python与爬虫就是一对相恋多年的恋人，二者如胶似漆 ，形影不离，你中有我、我中有你，有python的地方绝对离不开爬虫，有爬虫的地方，话题永远都绕不开python。
因为小编也正在学习python编程，所以花了一周时间，将关于python爬虫入门知识整理出来了，这些知识个人觉得是非常重要的，所以希望大家可以收藏起来，不要弄丢哦，毕竟辛苦了这么久。
【----帮助Python学习，以下所有学习资料文末免费领！----】
什么是爬虫 爬虫是一个程序，这个程序的目的就是为了抓取万维网信息资源，比如你日常使用的谷歌等搜索引擎，搜索结果就全都依赖爬虫来定时获取。
简单来说，无论你想获得哪些数据，有了爬虫都可以搞定，不论是文字、图片、视频，任何结构化非结构化的都能解决。
爬虫模块 re模块——正则表达式模块：
是用于快速从一大堆字符中快速找出想要的子字符串的一种表达方式，这个模块是初学者必须要弄清楚的，当你刚开始用的时候会觉得有难度，一旦上手了，你就会爱上它，逻辑性是非常强的。
os模块：
对文件文本的操作，可以创建文件夹，访问文件夹内容等，它会自适应于不同的操作系统平台，根据不同的平台进行相应的操作。
比如说我们常见的os.name，“name”顾名思义就是“名字”，这里的名字是指操作系统的名字，主要作用是判断目前正在使用的平台，也要注意到该命令不带括号。
csv模块：
爬取出来的数据可以以csv的格式保存，可以用office办公软件中的Excel表格软件打开，所以一般都是用于读文件、写文件、定义格式。
基础的抓取操作 Urllib：
是python内置的HTTP请求库，简单的例子：
import urllib.request
response = urllib.request.urlopen(‘https://blog.csdn.net/weixin_43499626’)
print(response.read().decode(‘utf-8’))
Requests：
requests库是一个非常实用的HTPP客户端库，是抓取操作最常用的一个库。
各种请求方式：常用requests.get()和requests.post()
import requests
r = requests.get(‘https://api.github.com/events’)
r1 = requests.get(‘http://httpbin.org/post’,data={‘key’:‘value’})
Requests它会比urllib更加方便，可以节约我们大量的工作。
需要登录的接口 post请求：
直接上代码，就能看懂的解释
import requests
url = “http://test”
data = {“key”:“value”}
res = requests.post(url=url,data=data)print(res.text)
get请求：
@classmethod
def send_get(cls, url, params, headers):
response = cls.SessionRequest.get(url=url, params=params, headers=headers)
return response.json()
常见的反爬有哪些
从功能上来讲，爬虫一般分为数据采集，处理，储存三个部分。这里我们只讨论数据采集部分。
通过Headers：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc8401cca98bf2780416625b51561d04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79eff35d977253ea830a94a6d59dfd48/" rel="bookmark">
			一次Rust重写基础软件的实践（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
受到2022年“谷歌使用Rust重写Android系统且所有Rust代码的内存安全漏洞为零” [1] 的启发，最近笔者怀着浓厚的兴趣也顺应Rust 的潮流，尝试着将一款C语言开发的基础软件转化为 Rust 语言。本文的主要目的是通过记录此次转化过程中遇到的比较常见且有意思的问题以及解决此问题的方法与大家一起做相关的技术交流和讨论。
问题描述
在项目转化过程中我遇到了一个与 CAS (Compare and Swap) [2] 操作实现相关的问题，在计算机科学中CAS 是多线程/协程中用于实现同步的原子指令。该软件针对不同的芯片平台，通过在C语言中根据芯片平台的类别进行宏定义并嵌入相应的汇编代码来实现CAS操作。我知道不同芯片平台对应的 CAS 操作的汇编代码是不一样的 [3]，例如：
x86-64 (Intel/AMD) 需要类似如下汇编代码块：
lock cmpxchgq [destination], rdx ARM 需要类似如下汇编代码块：
ldrex r1, [destination] cmp r1, r2 strexeq r1, r2, [destination] PowerPC 需要类似如下汇编代码块：
lwarx r0, 0, destination cmpw r0, r1 bne retry ; branch if not equal stwcx. r2, 0, destination bne retry ; branch if store failed 然而如下面的代码片段所示，即使该软件使用相同的Intel x86芯片平台，但是在不同的操作系统平台上其实现的汇编指令也有可能是不一样的。
C头文件中 cas_operation.h 的部分代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79eff35d977253ea830a94a6d59dfd48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e990461ec92e3c3478dab1b6a44b130d/" rel="bookmark">
			【Copula】最可能场景详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Copula联合分布的最可能场景详解 最可能场景（The most-likely scenario）实例探讨参考 最可能场景（The most-likely scenario） 相应英文介绍原理介绍如下：（出自论文J2020-Drought hazard transferability from meteorological to hydrological propagation）
最可能组合点（the most-likely combination(MLE) point (d*,s*)）绘制如下：（出自论文-J2021-Responses of Precipitation and Runoff to Climate Warming and Implications for Future Drought Changes in China）
实例探讨 根据我的算例，我的实现结果如下：
相应MATLAB绘图代码如下：
figure(1) subplot(2,2,1) hold on; box on; contour(Yseries,Xseries,M',[2 2],'w'); DSS = GetContourMatrix(c,2); h(2)=line( [ min(DSS{1,1}(2,:)) min(DSS{1,1}(2,:)) ],[ 50 200] ,'linestyle','--', 'Color',[0.4118 0.4118 0.4118], 'LineWidth', 1); h(3)=line( [ 0.5 1.8] ,[ min(DSS{1,1}(1,:)) min(DSS{1,1}(1,:)) ] ,'linestyle','--', 'Color',[0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e990461ec92e3c3478dab1b6a44b130d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48b43b5445cad4b65ebb63cbcd2d5c5/" rel="bookmark">
			Resnet结构的有效性解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Resnet结构的有效性解释 先看一看Resnet网络的块结构：
根据上图，设有函数
z ( l ) = x ( l − 1 ) + F ( x ) ( l − 1 ) (1) \mathbf{z}^{(l)}=\mathbf{x}^{(l-1)}+\mathcal{F}(\mathbf{x})^{(l-1)}\tag{1} z(l)=x(l−1)+F(x)(l−1)(1)
考虑由式 ( 1 ) (1) (1)组成的前馈神经网络，假设残差块不使用激活函数，那么整个式子仍然是线性变换，可得：
x ( l ) = z ( l ) (2) \mathbf{x}^{(l)}=\mathbf{z}^{(l)}\tag{2} x(l)=z(l)(2)
考虑任意两个层数 l 2 &gt; l 1 l_2&gt;l_1 l2​&gt;l1​,联合 ( 1 ) (1) (1)式和 ( 2 ) (2) (2)式，将 x \mathbf{x} x进行递归展开
x ( l 2 ) = x ( l 2 − 1 ) + F ( ( x ( l 2 − 1 ) ) = ( x ( l 2 − 2 ) + F ( ( x ( l 2 − 2 ) ) ) + F ( ( x ( l 2 − 1 ) ) = x l 1 + ∑ l = l 1 l 2 − 1 F ( x ( l ) ) \begin{align*} \mathbf{x}^{(l_2)}&amp;=\mathbf{x}^{(l_2-1)}+\mathcal{F}\left((\mathbf{x}^{(l_2-1)}\right)\\ &amp;=\left(\mathbf{x}^{(l_2-2)}+\mathcal{F}\left((\mathbf{x}^{(l_2-2)}\right)\right)+\mathcal{F}\left((\mathbf{x}^{(l_2-1)}\right)\\ &amp;=\mathbf{x}^{l_1}+\sum_{l=l_1}^{l_2-1}{\mathcal{F}(\mathbf{x}^{(l)})}\tag{3} \end{align*} x(l2​)​=x(l2​−1)+F((x(l2​−1))=(x(l2​−2)+F((x(l2​−2)))+F((x(l2​−1))=xl1​+l=l1​∑l2​−1​F(x(l))​(3)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b48b43b5445cad4b65ebb63cbcd2d5c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f6b848d9edef2a27de8fec949bf2794/" rel="bookmark">
			Docker之nacos集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Nacos 是一个开源的注册中心和配置中心，用于实现微服务架构中的服务发现、服务治理和动态配置管理。在 Docker 中使用 Nacos，你可以通过拉取官方提供的 Docker 镜像并运行容器的方式来快速部署 一.Nacos镜像拉取及独立模式 镜像拉取命令详解：
当前命令为创建Nacos容器（没有Nacos镜像会自动拉取Nacos镜像）
docker run: 运行一个 Docker 容器的命令。
-itd: 这是参数的一部分，其中：
-i: 保持标准输入（stdin）打开。
-t: 为容器分配一个伪终端（pseudo-TTY）。
-d: 在后台运行容器，并返回容器 ID。
-e PREFER_HOST_MODE=ip: 设置环境变量 PREFER_HOST_MODE 的值为 ip，表示使用 IP 模式。
-e MODE=standalone: 设置环境变量 MODE 的值为 standalone，表示以独立模式运行 Nacos。
-e SPRING_DATASOURCE_PLATFORM=mysql: 设置环境变量 SPRING_DATASOURCE_PLATFORM 的值为 mysql，指定 Nacos 使用 MySQL 数据库作为存储后端。
-e MYSQL_SERVICE_HOST=172.17.0.2: 设置环境变量 MYSQL_SERVICE_HOST 的值为 MySQL 服务的主机 IP 地址。
-e MYSQL_SERVICE_PORT=3306: 设置环境变量 MYSQL_SERVICE_PORT 的值为 MySQL 服务的端口号。
-e MYSQL_SERVICE_DB_NAME=nacos: 设置环境变量 MYSQL_SERVICE_DB_NAME 的值为 MySQL 数据库的名称，这里为 nacos。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f6b848d9edef2a27de8fec949bf2794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56568d8f51cbdb6363182258ea3ddba8/" rel="bookmark">
			R语言中的Wilcoxon符号秩检验与配对学生t检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近我们被要求撰写关于Wilcoxon的研究报告，包括一些图形和统计输出。
在这篇文章中，我们将探索比较两组依赖（即配对）定量数据的检验：Wilcoxon符号秩检验和配对学生t检验。这些检验之间的关键区别在于Wilcoxon的检验是非参数检验，而t检验是参数检验。在下文中，我们将探讨这种差异的后果。
睡眠数据集 我们来考虑睡眠数据集。数据集通过提供服用药物后睡眠时间与基线相比的变化来对比两种催眠药物（即安眠药）的效果：
extra表示与基线测量相比睡眠中的增加/减少（正/负值），组表示药物，ID表示患者ID。为了更清楚，我将组重命名为药物：
## extra group ID ## 1 0.7 1 1 ## 2 -1.6 1 2 ## 3 -0.2 1 3 ## 4 -1.2 1 4 ## 5 -0.1 1 5 ## 6 3.4 1 6 ## 7 3.7 1 7 ## 8 0.8 1 8 ## 9 0.0 1 9 ## 10 2.0 1 10 ## 11 1.9 2 1 ## 12 0.8 2 2 ## 13 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56568d8f51cbdb6363182258ea3ddba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eadf5e468e620c6e934a8e7d44094dd3/" rel="bookmark">
			R语言Rstan概率编程规划MCMC采样的贝叶斯模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近我们被要求撰写关于Rstan的研究报告，包括一些图形和统计输出。 概率编程使我们能够实现统计模型，而无需担心技术细节。它对基于MCMC采样的贝叶斯模型特别有用。
视频：R语言中RStan贝叶斯层次模型分析示例
stan简介 Stan是用于贝叶斯推理的C ++库。它基于No-U-Turn采样器（NUTS），该采样器用于根据用户指定的模型和数据估计后验分布。使用Stan执行分析涉及以下步骤：
使用Stan建模语言指定统计模型。通过专用的.stan 文件完成此操作 。准备要提供给模型的数据。使用该stan 函数从后验分布中采样 。分析结果。 在本文中，我将通过两个层次模型展示Stan的用法。我将使用第一个模型讨论Stan的基本功能，并使用第二个示例演示更高级的应用。
学校数据集 我们要使用的第一个数据集是 学校的数据集 。该数据集衡量了教练计划对大学入学考试（在美国使用的学业能力测验（SAT））的影响。 数据集如下所示：
正如我们所看到的：对于八所学校中的大多数，短期教练计划的确提高了SAT分数 。对于此数据集，我们有兴趣估算与每所学校相关的真实教练计划效果大小。我们考虑两种替代方法。首先，我们可以假设所有学校彼此独立。但是，这将难以解释，因为学校的后验区间由于高标准差而在很大程度上重叠。第二，假设所有学校的真实效果都相同，则可以汇总所有学校的数据。但是，这也是不合理的，因为该计划有针对学校的不同效果（例如，不同的老师和学生应该有不同的计划）。
因此，需要另一个模型。分层模型的优点是可以合并来自所有八所学校的信息，而无需假定它们具有共同的真实效果。我们可以通过以下方式指定层次贝叶斯模型：
根据该模型，教练的效果遵循正态分布，其均值是真实效果θj，其标准偏差为σj（从数据中得知）。真正的影响θj遵循参数μ和τ的正态分布。
定义Stan模型文件 在指定了要使用的模型之后，我们现在可以讨论如何在Stan中指定此模型。在为上述模型定义Stan程序之前，让我们看一下Stan建模语言的结构。
变量 在Stan中，可以通过以下方式定义变量：
int&lt;lower=0&gt; n; # 下界是0 int&lt;upper=5&gt; n; # 上限是5 int&lt;lower=0,upper=5&gt; n; # n 的范围是 [0,5] 注意，如果先验已知变量，则应指定变量的上下边界。
多维数据可以通过方括号指定：
vector[n] numbers; // 长度为n的向量 real[n] numbers; // 长度为n的浮点数组 matrix[n,n] matrix; // n乘n矩阵 程序 Stan中使用以下程序 ：
data：用于指定以贝叶斯规则为条件的数据转换后的数据：用于预处理数据参数 （必填）：用于指定模型的参数转换后的参数：用于计算后验之前的参数处理模型 （必填）：用于指定模型生成数量：用于对结果进行后处理 对于 模型 程序块，可以两种等效方式指定分布。第一个，使用以下统计符号：
y ~ normal(mu, sigma); # y 服从正态分布 第二种方法使用基于对数概率密度函数（lpdf）的程序化表示法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eadf5e468e620c6e934a8e7d44094dd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0fa2bb6c87138fa4078a263614ce0d6/" rel="bookmark">
			外包干了2个月，技术退步明显了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说一下自己的情况，大专生，19年通过校招进入湖南某软件公司，干了接近4年的功能测试，今年8月份，感觉自己不能够在这样下去了，长时间呆在一个舒适的环境会让一个人堕落!而我已经在一个企业干了四年的功能测试，已经让我变得不思进取，谈了2年的女朋友也因为我的心态和工资和我分手了。于是，我决定要改变现状，冲击下大厂。
刚开始准备时，自己都蒙了，四年的功能测试让我的技术没有一丝的进步，提升的只有我的年龄…
没办法，我找到了我在腾讯的老哥，作为他的小老表，在他了解了我的情况后(几乎就是Python基础开始)，直接甩给我一个网盘，说到：“去吧，这里有你需要的所有东西，不要来找我了，我都嫌丢人!”。
网盘里头是一整套软件测试面试必备文档PDF，看完之后直接给我老哥给跪了…这下面试稳了。
内容涵盖：包括测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、管理工具、Python基础、Selenium相关、性能测试、LordRunner相关等… 质量非常高，需要的可自行领取！！
全网首发-涵盖16个技术栈
第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础
软件测试的步骤是什么?
如何录制测试脚本?
应该考虑进行如何测试的测试方法
怎样估计测试工作量?
测试设计的问题
当测试过程发生错误时，有哪几种解决办法?
测试执行的问题
测试评估的目标
如何提高测试?
C/S模式的优点和缺点
B/S模式的优点和缺点
…
Linux
grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
…
Python
统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0fa2bb6c87138fa4078a263614ce0d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b43c337d89af97da7d5141910879d43/" rel="bookmark">
			R语言实现 Copula 算法建模相依性案例分析报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近我们被要求撰写关于Copula 的研究报告，包括一些图形和统计输出。 copula是将多变量分布函数与其边缘分布函数耦合的函数，通常称为边缘。Copula是建模和模拟相关随机变量的绝佳工具。Copula的主要吸引力在于，通过使用它们，你可以分别对相关结构和边缘（即每个随机变量的分布）进行建模。 相关视频：Copula算法原理和R语言股市收益率相依性可视化分析 Copula算法原理和R语言股市收益率相依性可视化分析
，时长16:34
copulas如何工作 首先，让我们了解copula的工作方式。 set.seed（100） m &lt; - 3 n &lt; - 2000 z &lt; - mvrnorm（n，mu = rep（0，m），Sigma = sigma，empirical = T） 我们使用cor()和散点图矩阵检查样本相关性。 pairs.panels（Z） [，1] [，2] [，3] [1，] 1.0000000 0.3812244 0.1937548 [2，] 0.3812244 1.0000000 -0.7890814 [3，] 0.1937548 -0.7890814 1.0000000 pairs.panels（U） 这是包含新随机变量的散点图矩阵u。 我们可以绘制矢量的3D图表示u。 现在，作为最后一步，我们只需要选择边缘并应用它。我选择了边缘为Gamma，Beta和Student，并使用下面指定的参数。
x1 &lt; - qgamma（u [，1]，shape = 2，scale = 1） x2 &lt; - qbeta（u [，2]，2,2） x3 &lt; - qt（u [，3]，df = 5） 下面是我们模拟数据的3D图。 df &lt; - cbind（x1，x2，x3） pairs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b43c337d89af97da7d5141910879d43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8683519f4ed52def43e2f204e420eb6c/" rel="bookmark">
			查看pip及Python版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python环境正确安装之后，按“Win+R”组合键打开“运行”对话框，输入“cmd”，如下图
打开命令提示符窗口后，输入以下命令查看Python及pip的版本。
pip -V 如果命令提示符窗口能够正确显示pip及Python版本，则说明Python和pip安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dfa3499c1909f505fb3d88806bec9e2/" rel="bookmark">
			在PyCharm中创建Flask项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 PyCharm 中创建 Flask 项目的步骤如下：
打开 PyCharm，并选择 "Create New Project"（新建项目）。在弹出的窗口中，选择左侧的 "Python" 选项，然后选择右侧的 "Flask" 项目模板。在 "Location"（位置）字段中，选择项目存储的路径，并输入项目的名称。确保 "New Environment"（新环境）选项被选中，然后选择所需的 Python 解释器版本。点击 "Create"（创建）按钮来创建项目。 PyCharm 将会自动创建一个基本的 Flask 项目结构，包括 app.py 和 templates 文件夹。
app.py 是 Flask 应用的主要入口点，可以在这个文件中编写 Flask 应用代码。
templates 文件夹用于存放 HTML 模板文件。
创建之后的自带示例代码：
运行之后：
单击上图所示的链接“http://127.0.0.1:5000/”，即可打开浏览器访问项目，如下图所示。
测试一下：
from flask import Flask, render_template app = Flask(__name__) @app.route('/') def index(): return 'Hello, Flask!' @app.route('/hello/&lt;name&gt;') def hello(name): return render_template('hello.html', name=name) if __name__ == '__main__': app.run() 在项目的根目录下创建一个 templates 文件夹，并在其中创建一个 hello.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dfa3499c1909f505fb3d88806bec9e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47828ba193a4b7fc6148375ac56c82a2/" rel="bookmark">
			R语言使用K-Means聚类可视化WiFi访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近我们被要求撰写关于K-Means聚类的研究报告，包括一些图形和统计输出。 【视频】KMEANS均值聚类和层次聚类：R语言分析生活幸福质量系数可视化实例 KMEANS均值聚类和层次聚类：R语言分析生活幸福质量系数可视化实例
，时长06:05
可视化已成为数据科学在电信行业中的关键应用。具体而言，电信分析高度依赖于地理空间数据的使用。
这是因为电信网络本身在地理上是分散的，并且对这种分散的分析可以产生关于网络结构，消费者需求和可用性的有价值的见解。
数据 为了说明这一点，使用k均值聚类算法来分析免费公共WiFi的地理数据。 具体地，k均值聚类算法用于基于与特定提供商相关联的纬度和经度数据来形成WiFi使用的集群。
从数据集本身，使用R提取纬度和经度数据：
＃1 newyorkdf &lt;-data.frame（纽约$ LAT，纽约$ LON） 这是一个数据片段：
确定群集的数量 现在，需要使用scree图确定簇的数量。
＃2。确定群集的数量 从上面可以看出，曲线在大约11个星团处平稳。因此，这是将在k-means模型中使用的聚类数。
K均值分析 K-Means分析本身是：
ggplot（newyorkdf，aes（x = newyork.LON，y = newyork.LAT，color = newyorkdf $ fit.cluster））+ geom_point（） 在数据框newyorkdf中，显示纬度和经度数据以及群集标签：
&gt; newyorkdf newyork.LAT newyork.LON fit.cluster 1 40.75573 -73.94458 1 2 40.75533 -73.94413 1 3 40.75575 -73.94517 1 4 40.75575 -73.94517 1 5 40.75575 -73.94517 1 6 40.75575 -73.94517 1 ..... 80 40.84832 -73.82075 11 81 40.84923 -73.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47828ba193a4b7fc6148375ac56c82a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/445f4bae6e4f2bd7c74e8798e3b20b9f/" rel="bookmark">
			R语言： GARCH模型股票交易量的研究道琼斯股票市场指数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近我们被要求撰写关于GARCH的研究报告，包括一些图形和统计输出。 相关视频：时间序列分析：ARIMA GARCH模型分析股票价格数据 时间序列分析模型 ARIMA-ARCH GARCH模型分析股票价格数据
我将建立道琼斯工业平均指数（DJIA）日交易量对数比的ARMA-GARCH模型。 获取数据 load(file='DowEnvironment.RData') 日交易量 每日交易量内发生的 变化。 plot(dj_vol) 首先，我们验证具有常数均值的线性回归在统计上是显着的。 在休息时间= 6时达到最小BIC。
以下是道琼斯日均交易量与水平变化（红线） 。
summary(bp_dj_vol) ## ## Optimal (m+1)-segment partition: ## ## Call: ## breakpoints.formula(formula = dj_vol ~ 1, h = 0.1) ## ## Breakpoints at observation number: ## ## m = 1 2499 ## m = 2 896 2499 ## m = 3 626 1254 2499 ## m = 4 342 644 1254 2499 ## m = 5 342 644 1219 1649 2499 ## m = 6 320 622 924 1251 1649 2499 ## m = 7 320 622 924 1251 1692 2172 2499 ## m = 8 320 622 924 1251 1561 1863 2172 2499 ## ## Corresponding to breakdates: ## ## m = 1 ## m = 2 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/445f4bae6e4f2bd7c74e8798e3b20b9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269c3b23879b10a429e979e1c029d9bc/" rel="bookmark">
			详解IP安全：IPSec协议簇 | AH协议 | ESP协议 | IKE协议_ipsec esp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
IP安全概述
IPSec协议簇
IPSec的实现方式
AH（Authentication Header，认证头）
ESP（Encapsulating Security Payload，封装安全载荷）
IKE（Internet Key Exchange，因特网密钥交换）
IKE的两个阶段
IP安全概述 大型网络系统内运行多种网络协议（TCP/IP、IPX/SPX和NETBEUA等），这些网络协议并非为安全通信设计。而其IP协议维系着整个TCP/IP协议的体系结构，除了数据链路层外，TCP/IP的所有协议的数据都是以IP数据报的形式传输的。
TCP/IP协议族有两种IP版本：版本4（IPv4）和版本6（IPv6），IPv6是IPv4的后续版本，IPv6简化了IP头，其数据报更加灵活，同时IPv6还增加了对安全性的考虑。
目前占统治地位的是IPv4，IPv4在设计之初没有考虑安全性，IP数据包本身并不具备任何安全特性，导致在网络上传输的数据很容易受到各式各样的攻击：比如伪造IP包地址、修改其内容、重播以前的包以及在传输途中拦截并查看包的内容等。因此，通信双方不能保证收到IP数据报的真实性。
IPSec协议簇 为了加强因特网的安全性，从1995年开始，IETF着手制定了一套用于保护IP通信的IP安全协议（IP Security,IPSec）。IPSec是IPv6的一个组成部分，是IPv4的一个可选扩展协议。IPSec弥补了IPv4在协议设计时缺乏安全性考虑的不足。
IPSec定义了一种标准的、健壮的以及包容广泛的机制，可用它为IP以及上层协议（比如TCP或者UDP）提供安全保证。IPSec的目标是为IPv4和IPv6提供具有较强的互操作能力、高质量和基于密码的安全功能，在IP层实现多种安全服务，包括访问控制、数据完整性、机密性等。 IPSec通过支持一系列加密算法如DES、三重DES、IDEA和AES等确保通信双方的机密性。
IPSec协议簇中主要包括三个协议：IKE/AH/ESP
IKE（Internet Key Exchange，因特网密钥交换）：IKE协议是一种基于UDP的应用层协议，它主要用于SA协商和密钥管理。
AH协议（Authentication Header，验证头）：可以证明数据的 起源地、保障数据的完整性以及防止相同数据包在因特网重播。
ESP协议（Encapsulating Security Payload，封装安全载荷）：具有所有AH的功能，还可以利用加密技术保障数据机密性。
AH虽然可以保护通信免受窜改, 但并不对数据进行变形转换, 数据对于黑客而言仍然是清晰的。为了有效地保证数据传输安全, ESP进一步提供数据保密性并防止窜改。也就是说，AH提供数据的可靠性和完整性，但机密性由ESP保护。虽然AH和ESP都可以提供身份认证，但它们有2点区别： ESP要求使用高强度的加密算法，会受到许多限制。 多数情况下，使用AH的认证服务已能满足要求，相对来说，ESP开销较大。 同时有两套不同的安全协议意味着可以对IPSec网络进行更细粒度的控制，选择安全方案可以有更大的灵活度。
IPSec的实现方式 IPSec的实现方式有两种：传输模式和隧道模式，都可用于保护通信。
传输模式用于两台主机之间，保护传输层协议头，实现端到端的安全性。 当数据包从传输层传送给网络层时，AH和ESP会进行拦截，在IP头与上层协议之间需插入一个IPSec头。当同时应用AH和ESP到传输模式时，应该先应用ESP，再应用AH。
传输模式的封包如下所示
隧道模式用于主机与服务器，或者服务器与服务器之间，保护整个IP数据包，将整个IP数据包进行封装（称为内部IP头），然后增加一个IP头（称为外部IP头），并在内部与外部IP头之间插入一个IPSec头。
隧道模式的封包如下所示
IPSec可在终端主机、网关/路由器或者两者中同时进行实施和配置。至于IPSec在网络什么地方配置，则由用户对安全保密的要求来决定。 在需要确保端到端的通信安全时，在主机实施显得尤为有用。 然而，在需要确保网络一部分的通信安全时，在路由器中实施IPSec就显得非常重要。
AH（Authentication Header，认证头） AH为IP报文提高能够数据完整性校验和身份验证，还具备可选择的重放攻击保护，但不提供数据加密保护。 AH不对受保护的IP数据报的任何部分进行加密，除此之外，AH具有ESP的所有其他功能。 AH和ESP同时保护数据，在顺序上，AH在ESP之后，AH格式如图：
头部（8位）表示AH后的载荷类型，传输模式下是6（TCP）或17（UDP），隧道模式下是5 （TCP）或41（UDP）。 载荷长度（8位）是整个AH的长度减2，长度以32为单位。保留（16）位是保留字段，全为0。 安全参数索引（32位）与外部IP头的目的地址一起对报文进行身份验证和完整性校验，序列号（32位）是一个单向递增的计数器，提供抗重播能力。验证数据的长度由具体的验证算法决定。
对AH的处理分成2部分：
对发送的数据包添加AH头对收到的含有AH的数据包进行还原 ESP（Encapsulating Security Payload，封装安全载荷） ESP为IP报文提供数据完整性校验、身份验证、数据加密以及重放攻击保护等。 除了AH提供的所有服务外，还提供机密性服务。 ESP可在传输模式以及隧道模式下使用。ESP头可以位于IP头与上层协议之间，或者用它封装整个IP数据报。ESP头的格式 ：
安全参数索引（32位）用于标识处理数据包的安全关联。 序列号（32位）与AH类似，提供抗重放攻击。 填充项（0~255位），长度由具体加密算法决定。 填充长度（8位）：接收端可以恢复的数据载荷的真实长度。 下一头部（8位）：表示受ESP保护的载荷的类型。 在传输模式下可能是6（TCP）或17（UDP），在隧道模式下可能是5（IPv4）或41（IPV6）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/269c3b23879b10a429e979e1c029d9bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b773738ebb243bb726be50e4ca50dc7d/" rel="bookmark">
			NS3_3.38 AODV网络协议代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* * Copyright (c) 2009 IITP RAS * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License version 2 as * published by the Free Software Foundation; * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b773738ebb243bb726be50e4ca50dc7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64f8f91022fe5ddce20b13e43aba1d1/" rel="bookmark">
			Docker 安装 CentOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 安装 CentOS CentOS（Community Enterprise Operating System）是 Linux 发行版之一，它是来自于 Red Hat Enterprise Linux(RHEL) 依照开放源代码规定发布的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以 CentOS 替代商业版的 Red Hat Enterprise Linux 使用。
1、查看可用的 CentOS 版本 访问 CentOS 镜像库地址：https://hub.docker.com/_/centos?tab=tags&amp;page=1。
可以通过 Sort by 查看其他版本的 CentOS 。默认是最新版本 centos:latest 。
你也可以在下拉列表中找到其他你想要的版本：
2、拉取指定版本的 CentOS 镜像，这里我们安装指定版本为例(centos7): $ docker pull centos:centos7 3、查看本地镜像 使用以下命令来查看是否已安装了 centos7：
$ docker images 4、运行容器，并且可以通过 exec 命令进入 CentOS 容器。 $ docker run -itd --name centos-test centos:centos7 5、安装成功 最后我们可以通过 docker ps 命令查看容器的运行信息：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc10173393a9dda4cf2611e76eb1103/" rel="bookmark">
			鸿蒙生态千帆启航！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年1月18日，华为举行的鸿蒙生态千帆启航仪式，会上宣布HarmonyOS NEXT鸿蒙星河版系统开发者预览版开放申请。据介绍，鸿蒙星河版将实现原生精致、原生应用、原生流畅、原生安全、原生智能、原生互联六大极致原生体验。HarmonyOS NEXT 开发者预览版将不再兼容安卓开源应用，仅支持鸿蒙内核和系统的应用，因此被称为“纯血鸿蒙”。本次会上，余承东表示鸿蒙内核超越传统内核，更适应全场景设备多样化。鸿蒙系统是真正的操作系统，从编程语言到编译器都是全栈自研。截至当日，有超过200个鸿蒙原生应用正加速开发。合作伙伴开放垂域创新能力，三方SDK鸿蒙化，共同为开发者提供高效的全链路开发工具、能力。这意味着HarmonyOS NEXT生态版图已基本成型，正式揭开鸿蒙进阶新篇章。
学习鸿蒙正当时！以下是一些学习资料，可以作为参考：
《跟老卫学 HarmonyOS 开发》 开源免费教程：https://github.com/waylau/harmonyos-tutorial
《鸿蒙 HarmonyOS 手机应用开发实战》（清华大学出版社）：713页鸿蒙巨作！《鸿蒙HarmonyOS手机应用开发实战》简介 | 老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化 | waylau.com
《鸿蒙 HarmonyOS 应用开发从入门到精通战》（北京大学出版社）：https://github.com/waylau/harmonyos-tutorial
“鸿蒙系统实战短视频 App 从 0 到 1 掌握 HarmonyOS” ：鸿蒙系统实战短视频App 从0到1掌握HarmonyOS_实战课程_慕课网
《鸿蒙HarmonyOS应用开发入门》（清华大学出版社）：轻松掌握ArkTS！鸿蒙新作《鸿蒙HarmonyOS应用开发入门》简介 | 老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化 | waylau.com
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dacb812936a96a8ca69669fddf850ef/" rel="bookmark">
			【MATLAB基础绘图第19棒】绘制小提琴图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB绘制小提琴图 小提琴图（Violin Plot）案例1：基础绘制参考 小提琴图（Violin Plot） 小提琴图（Violin Plot）可用于展示多组数据的分布状态和概率密度。
出自论文-J2020-Drought hazard transferability from meteorological to hydrological propagation
案例1：基础绘制 成图如下：
MATLAB代码如下：
clc close all clear %% 函数说明-绘制小提琴图 pathFigure= '.\Figures\' ; figureUnits = 'centimeters'; figureWidth = 20; figureHeight = 10; X1=[1:2:7,13]; Y1=randn(100,5)+sin(X1); X2=2:2:10; Y2=randn(100,5)+cos(X2); figure(1) set(gcf, 'Units', figureUnits, 'Position', [0 0 figureWidth figureHeight]); hold on;box on;grid off; Hdl1 = violinChart(gca,X1,Y1,[59 125 183]/255); Hdl2 = violinChart(gca,X2,Y2,[126,15,4]/255); % 设置其余坐标区属性 set(gca,'FontName','Times New Roman','FontSize',14,'FontWeight','bold',... 'Layer','top','LineWidth',1); xlabel('Column' ,'Fontname', 'Times New Roman','Fontsize',16) ylabel('Value' ,'Fontname', 'Times New Roman','Fontsize',16) set(gca,'XLim',[0 14],'XTick', [ 2 :2: 15],'XTickLabel',[ 2 :2: 15],.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dacb812936a96a8ca69669fddf850ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca2bc7504e83ca47c6403b2e0b19bbb/" rel="bookmark">
			Qt固件映像 Raspberry Pi 嵌入式C&#43;&#43;(Qt)编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt C++创建突围游戏应用示例 在我们的游戏中，我们有一个桨、一个球和三十块砖。 计时器用于创建游戏周期。 我们不处理角度，我们只是改变方向：上、下、左、右。
Qt5 库是为创建计算机应用程序而开发的。尽管如此，它也可以用来创建游戏。开发计算机游戏是了解有关 Qt5 的更多信息的好方法。
#include &lt;QImage&gt; #include &lt;QRect&gt; class Pdle { public: Pdle(); ~Pdle(); public: void resetState(); void move(); void setDx(int); QRect getRect(); QImage &amp; getImage(); private: QImage image; QRect rect; int dx; static const int INITIAL_X = 200; static const int INITIAL_Y = 360; }; 这是对象的头文件。 INITIAL_X 和 INITIAL_Y 是常量，表示桨对象的初始坐标。
#include &lt;iostream&gt; #include "pdle.h" Pdle::Pdle() { dx = 0; image.load("paddle.png"); rect = image.rect(); resetState(); } Pdle::~Pdle() { std::cout &lt;&lt; ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ca2bc7504e83ca47c6403b2e0b19bbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff7d6ca9993bab822accd876d523a5b7/" rel="bookmark">
			C#根据 App.config 文件中的配置信息去查找并加载指定目录下的 DLL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#根据 App.config 文件中的配置信息去查找并加载指定目录下的 DLL
System.IO.FileNotFoundException:“未能加载文件或程序集“AliNPOIExcel, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null”或它的某一个依赖项。系统找不到指定的文件。”
如何让程序识别不同目录下的dll? 方法一：配置App.config文件的privatePath——【推荐】
这是最简单的方法，当然也有一定的局限性，就是没法对dll做控制，另外，无法解决第三方DllImprt中引入的程序集不在根目录下的问题，不过无论怎么说，这个都基本解决了问题。
配置如下,多个目录用;分隔
&lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8.1" /&gt; &lt;/startup&gt; &lt;!-- 添加以下内容 --&gt; &lt;runtime&gt; &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt; &lt;probing privatePath="ext;lib;lib\include\NPOI"/&gt; &lt;/assemblyBinding&gt; &lt;/runtime&gt; &lt;/configuration&gt; 注意，ext和lib和lib\include\NPO 都是你希望程序查找 DLL 的目录路径。多个目录之间可以使用分号 ";" 分隔。
当程序运行时，它将根据 App.config 文件中的配置信息去查找并加载指定目录下的 DLL。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5571e6c06bda0adc2d5116b60c27253f/" rel="bookmark">
			如何使用Docker Compose搭建StackEdit编辑器并实现远程办公
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. docker部署Stackedit2. 本地访问3. Linux 安装cpolar4. 配置Stackedit公网访问地址5. 公网远程访问Stackedit6. 固定Stackedit公网地址 StackEdit是一个受欢迎的Markdown编辑器，在GitHub上拥有20.7k Star！，它支持将Markdown笔记保存到多个仓库，包括Gitee、GitHub和Gitea。此在线笔记工具还提供了一些便捷功能，如拖拽或粘贴上传图片、文件搜索功能，以及可切换为炫酷的暗黑主题，这些功能特别适合那些喜欢使用Markdown来记录笔记的用户。同时,StackEdit 是开源的,个人可以本地部署自己的Markdown编辑器,并且通过浏览器即可快速访问.当然,本地访问局限性太大,结合cpolar 内网穿透工具,即可实现远程,随时随地,任意浏览器访问我们部署在本地的Markdown编辑器,提高生产效率!!
下面介绍如何在Linux 以 docker-compose方式快速部署运行 StackEdit,并结合cpolar 内网穿透实现远程访问,由于是docker 部署运行,设备需要提前安装docker 和docker compose!
1. docker部署Stackedit 在Linux 任意目录下,创建一个docker-compose.yml 文件,按 i 编辑
vim docker-compose.yml 然后复制下面内容到文件中,复制完成保存,下面ports挂载端口可以自行修改,如不会修改,可以默认8080端口,本例默认!
services: stackedit: image: mafgwo/stackedit:5.15.20-8 container_name: stackedit environment: - LISTENING_PORT=8080 - ROOT_URL=/ - USER_BUCKET_NAME=root ports: - 8080:8080/tcp network_mode: bridge restart: always 保存文件后,执行下面命令一键启动
docker-compose up -d 执行后,等待安装完成,完成后输入docker ps 即可看到运行的Stackedit
2. 本地访问 上面以docker方式成功部署和启动运行了属于个人的Markdown编辑器,现在打开浏览器,局域网访问容器挂载的8080端口,然后点击界面顶部开始写作,即可看到我们的Markdown编辑器界面,下面我们安装cpolar 内网穿透工具,实现远程访问
3. Linux 安装cpolar 上面我们成功安装了Stackedit,并局域网访问ok,下面我们在Linux安装cpolar内网穿透工具,通过cpolar 转发本地端口映射的http公网地址,我们可以很容易实现远程访问,而无需自己注册域名购买云服务器.下面是安装cpolar步骤
cpolar官网地址: https://www.cpolar.com
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5571e6c06bda0adc2d5116b60c27253f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f359b4c6bb373713615448780a34b5f8/" rel="bookmark">
			翻译: Streamlit从入门到精通六 实战缓存Cache请求数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Streamlit从入门到精通 系列：
翻译: Streamlit从入门到精通 基础控件 一翻译: Streamlit从入门到精通 显示图表Graphs 地图Map 主题Themes 二翻译: Streamlit从入门到精通 构建一个机器学习应用程序 三翻译: Streamlit从入门到精通 部署一个机器学习应用程序 四翻译: Streamlit从入门到精通 高级用法缓存Cache和Session 五
1. 两个缓存装饰器： st.cache_data 是缓存返回数据的计算的推荐方法：从 CSV 加载 DataFrame、转换 NumPy 数组、查询 API 或任何其他返回可序列化数据对象的函数（str、int、float、DataFrame、array、list 等）。它会在每次函数调用时创建一个新的数据副本，使其免受突变和竞争条件的影响。st.cache_data的行为是您想要的——所以如果您不确定，请从st.cache_data开始，看看它是否有效！st.cache_resource 是缓存全局资源（如 ML 模型或数据库连接）的推荐方法，这些资源是您不想多次加载的不可序列化对象。使用它，您可以在应用程序的所有重新运行和会话之间共享这些资源，而无需复制或复制。请注意，对缓存返回值的任何突变都会直接改变缓存中的对象（更多详细信息见下文）。 2. 基本用法 st.cache_data 是所有返回数据的函数的首选命令，无论是 DataFrames、NumPy 数组、str、int、float 还是其他可序列化类型。对于几乎所有用例来说，这都是正确的命令！
让我们看一个使用 st.cache_data 的例子。假设您的应用将优步拼车数据集（一个 50 MB 的 CSV 文件）从互联网加载到 DataFrame 中：
import streamlit as st import time import pandas as pd def load_data(url): df = pd.read_csv(url) return df df = load_data("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f359b4c6bb373713615448780a34b5f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a880cbf035514fc6735bb46b8dac6e9c/" rel="bookmark">
			K8s调试积累
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、K8S 集群服务访问失败？二、K8S 集群服务访问失败？三、K8S 集群服务暴露失败？四、外网无法访问 K8S 集群提供的服务？五、pod 状态为 ErrImagePull？六、探测存活 pod 状态为 CrashLoopBackOff？七、POD 创建失败？八、POD 的 ready 状态未进入？九、pod 创建失败？十、kube-flannel-ds-amd64-ndsf7 插件 pod 的 status为 Init:0/1？十一、K8S 创建服务 status 为 ErrImagePull？十二、不能进入指定容器内部？十三、创建 PV 失败？十四、pod 使用 PV 后，无法访问其内容？十五、查看节点状态失败？十六、pod 一直处于 pending状态？十七、helm 安装组件失败？ 一、K8S 集群服务访问失败？ 问题：
原因分析：证书不能被识别，其原因为：自定义证书，过期等。解决方法：更新证书即可。 二、K8S 集群服务访问失败？ 问题：
curl: (7) Failed connect to 10.103.22.158:3000; Connection refused原因分析：端口映射错误，服务正常工作，但不能提供服务。解决方法：删除 svc，重新映射端口即可。kubectl delete svc nginx-deployment 三、K8S 集群服务暴露失败？ 问题：
Error from server (AlreadyExists): services “nginx-deployment” already exists原因分析：该容器已暴露服务了。解决方法：删除 svc，重新映射端口即可。 四、外网无法访问 K8S 集群提供的服务？ 原因分析：K8S 集群的 type 为 ClusterIP，未将服务暴露至外网。解决方法：修改 K8S 集群的 type 为 NodePort 即可，于是可通过所有 K8S 集群节点访问服务。修改命令kubectl edit svc nginx-deployment 五、pod 状态为 ErrImagePull？ 问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a880cbf035514fc6735bb46b8dac6e9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b75b4edc689c5bb70d9cd64f53fd78f0/" rel="bookmark">
			java设置可供下载的excel模板文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		controller @GetMapping("/download/excel") @Operation(summary = "下载技术引入Excel模板") public void downloadTemplateExcel(HttpServletResponse response) { technologyService.getTechnologyExcelModel(response); } service public void getTechnologyExcelModel(HttpServletResponse response) { List&lt;TechnologyImportExcelDto&gt; technologyImportExcelDtoList = getTechnologyImportExcelVOList(); File file; try { //使用临时文件 file = File.createTempFile("开源技术导入模板", ".xlsx"); FileOutputStream fileOutputStream = new FileOutputStream(file); ExportParams params = new ExportParams("表格标题", "Sheet1", ExcelType.XSSF); String tipsMessage = "开源技术导入需遵循以下规则：xxx"; params.setTitle(tipsMessage); Workbook workbook = ExcelExportUtil.exportExcel(params, TechnologyImportExcelDto.class, technologyImportExcelDtoList); // 获取Sheet对象 Sheet sheet = workbook.getSheetAt(0); // 只有一个Sheet // 设置标题行样式 Row titleRow = sheet.getRow(0); // 标题在第一行 CellStyle titleStyle = workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b75b4edc689c5bb70d9cd64f53fd78f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08eaeed2d7eebaf46382db384f523485/" rel="bookmark">
			分享 GitHub 上的敏感词汇工具类：sensitive-word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😄 19年之后由于某些原因断更了三年，23年重新扬帆起航，推出更多优质博文，希望大家多多支持～
🌷 古之立大事者，不惟有超世之才，亦必有坚忍不拔之志
🎐 个人CSND主页——Micro麦可乐的博客
🐥《Docker实操教程》专栏以最新的Centos版本为基础进行Docker实操教程，入门到实战
🌺《RabbitMQ》本专栏主要介绍使用JAVA开发RabbitMQ的系列教程，从基础知识到项目实战
🌸《设计模式》专栏以实际的生活场景为案例进行讲解，让大家对设计模式有一个更清晰的理解
如果文章能够给大家带来一定的帮助！欢迎关注、评论互动～
分享 GitHub 上的敏感词汇工具类：sensitive-word 前言介绍sensitive-wordSpringBoot使用sensitive-word敏感词工具类的优缺点总结结语 前言 在网络世界中，对于敏感词汇的过滤是保障用户体验和维护网络环境的一项基础工作。常见的比如社交平台、论坛、聊天应用等场景，涉及到用户言论都需要考虑内容的敏感性处理，本文将为大家介绍一款GitHub上开源好用的好用敏感词工具sensitive-word
目前已经有1.4KStar，项目地址 ： https://github.com/houbb/sensitive-word
介绍sensitive-word sensitive-word 是基于 DFA 算法实现的高性能敏感词工具。目前敏感词库内容收录 6W+且不断优化更新。
特性
6W+ 词库，且不断优化更新
基于 fluent-api 实现，使用优雅简洁
基于 DFA 算法，性能为 7W+ QPS，应用无感
支持敏感词的判断、返回、脱敏等常见操作
支持常见的格式转换
全角半角互换、英文大小写互换、数字常见形式的互换、中文繁简体互换、英文常见形式的互换、忽略重复词等
支持敏感词检测、邮箱检测、数字检测、网址检测等
支持自定义替换策略
支持用户自定义敏感词和白名单
支持数据的数据动态更新（用户自定义），实时生效
支持敏感词的标签接口
支持跳过一些特殊字符，让匹配更灵活
SpringBoot使用sensitive-word 在开发java项目中，想使用sensitive-word其实非常简单，只需要maven引入依赖就可以当作一个工具类调用其方法即可使用
maven引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.github.houbb&lt;/groupId&gt; &lt;artifactId&gt;sensitive-word&lt;/artifactId&gt; &lt;version&gt;0.12.0&lt;/version&gt; &lt;/dependency&gt; SensitiveWordHelper 作为敏感词的工具类，核心方法如下：
接下来我们编写相关测试类，来测试对应方法
public class Test { public static void main(String[] args) { //是否有敏感词存在 String text = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08eaeed2d7eebaf46382db384f523485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1f9ff5580ce975b9b4e8fab296cc3d/" rel="bookmark">
			华为系统底层是用Java写的吗？和安卓的区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HarmonyOS（鸿蒙操作系统）是华为自主开发的分布式操作系统。下面是对HarmonyOS底层的详细介绍：
微内核架构：HarmonyOS采用了微内核架构，将核心服务和功能放在微内核中，而将其他应用服务放在用户空间中。这种架构有助于实现模块化开发和系统的高度可扩展性。
分布式能力：HarmonyOS的底层设计注重分布式能力，可以实现设备之间的协同工作和资源共享。通过分布式数据管理、分布式任务调度和分布式安全等机制，实现了设备之间的高效通信和协作。
鸿蒙内核：HarmonyOS的内核是基于LiteOS演化而来的，鸿蒙内核具有高性能、低功耗、快速启动和实时响应的特点。它采用了基于事件驱动的机制，能够更好地管理系统资源和处理任务。
开放源代码：作为一个开放的操作系统，HarmonyOS的底层也是开放源代码的。这使得开发者可以深入了解和定制底层的实现，以满足特定需求和开发新的应用。
HarmonyOS的底层主要是使用C语言进行开发的。
华为系统的底层不仅仅使用了C语言，还使用了其他编程语言如C++ 和Java。
在华为系统中，C语言通常用于底层开发和系统级编程，因为它具有高效性和可移植性的特点。C++ 语言则更多地用于开发底层库和框架，以提供更丰富的功能和更好的性能。
而Java语言在华为系统中可能用于应用层开发，以实现用户界面、应用程序逻辑和其他高级功能。Java语言具有跨平台特性，可以在不同的硬件设备上运行。
因此，华为系统的底层开发往往会涉及多种编程语言，包括C、C++ 和Java。这些语言的使用取决于具体的开发需求和系统架构。
C语言是一种高级编程语言，具有高效性和可移植性，常用于系统级编程和底层开发。华为选择使用C语言作为HarmonyOS的底层开发语言，可以更好地控制系统资源、优化性能，并实现与硬件设备的交互。
分布式架构：华为系统注重分布式能力，可以实现设备之间的协同工作和资源共享。这使得华为系统更具扩展性和灵活性，能够应对多设备、多场景的复杂需求。
微内核架构：华为系统采用了微内核架构，将核心服务和功能放在微内核中，而将其他应用服务放在用户空间中。这种架构有助于实现模块化开发、系统的高度可扩展性和更好的性能。
生态系统：与安卓相比，华为系统的生态系统尚在发展中。尽管华为系统可以运行一些安卓应用程序，但由于生态系统的不同，一些特定的安卓应用可能需要适配或无法在华为系统上运行。
华为系统的底层开发并不是开源的，因此具体的底层实现无法直接获取和修改。不过，华为对开发者提供了开发工具和开放的API，以便他们能够基于华为系统进行应用程序开发。对于编辑器的选择，开发者可以根据个人偏好和项目需求来选择适合自己的编辑器。以下是三个常用的编辑器供您参考：
Visual Studio Code：这是一款免费、跨平台的开源代码编辑器，具有丰富的插件生态系统和强大的代码编辑功能，适合多种编程语言的开发。
Android Studio：如果您计划开发基于华为系统的应用程序，Android Studio是一个不错的选择。它是专为Android应用程序开发而设计的集成开发环境（IDE），提供了丰富的工具和功能，支持Java和Kotlin语言。
Eclipse：Eclipse是一款受欢迎的Java开发工具，也可以用于其他编程语言的开发。它具有强大的插件系统和调试功能，适合开发者进行底层和应用层的开发工作。
这些是一些常见的编辑器，开发者也可以根据自己的喜好和需求选择其他编辑器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5cc2a5a244d96fe4d4817982c777c7c/" rel="bookmark">
			.xml是什么文件 html的区别是什么 ？xml用什么编辑器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XML 在许多领域中都有广泛的应用。以下是一些常见的用途：
数据交换：XML 可以用作数据交换的标准格式。许多应用程序和系统使用 XML 来传输和共享数据，因为 XML 的结构化特性和可读性使得数据解析和处理更加方便。
配置文件：许多软件和系统使用 XML 文件来存储配置信息。通过使用自定义的 XML 标签和结构，可以轻松地定义和修改配置选项，从而实现更灵活的配置管理。
Web 服务：XML 也被广泛用于 Web 服务的数据交换。通过使用 XML，不同的应用程序和平台可以轻松地共享数据和信息，实现跨平台和跨语言的互操作性。
文档描述：XML 可以用于描述文档的结构和内容。例如，使用 XML 可以定义电子书的章节、段落和样式，从而实现更好的文档管理和组织。
这只是 XML 的一些常见应用场景，实际上 XML 还可以用于许多其他领域，如配置管理、数据存储、数据传输等。由于 XML 的通用性和灵活性，它在各种应用中都有着重要的作用。
XML 本身并不是前端技术，而是一种用于存储和传输数据的标记语言。XML 可以用于前端开发，但它不是专门用于前端的技术。
在前端开发中，HTML 和 CSS 是最常用的技术。HTML 用于定义页面的结构和内容，CSS 用于控制页面的样式和布局。而 XML 通常用于存储和传输数据，例如在前后端数据交互、配置文件等方面。
如果您想制作 App 的前端，通常会使用特定的技术和框架，如 React Native、Flutter 或者原生开发（如使用 Java 或 Swift）。这些技术和框架可以帮助您构建跨平台或原生的移动应用程序前端。
XML 文件可以使用各种文本编辑器来进行编辑。以下是三个常见的编辑器供您选择：
文本编辑器：任何基本的文本编辑器都可以用于编辑 XML 文件，例如记事本（Windows）、TextEdit（Mac）或者GNU Emacs（跨平台）。这些编辑器没有特定的 XML 功能，但是可以用于编辑 XML 文件的纯文本内容。
XML 编辑器：有一些专门的 XML 编辑器提供了更多的功能和工具，使得编辑 XML 文件更加方便。例如，XMLSpy、Oxygen XML Editor、Notepad++ 等都是常用的 XML 编辑器，它们提供了语法高亮、自动补全、验证、格式化等功能，以及可视化的 XML 编辑界面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5cc2a5a244d96fe4d4817982c777c7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513ac5ae3a5e56edbbb29f07a66e4707/" rel="bookmark">
			【已解决】error LNK2001: 无法解析的外部符号 WinMainCRTStartup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博文源于自己之前出现的错误，如果读者也出现这种错误，请务必按照下列步骤尝试一下是否解决：
第一步：观察自己是否有main.cpp 第二部：观察自己main.cpp是否加入到项目当中 不管你是否添加当中，都按照这个格式走一遍
选中“Source Files” 添加现有项，将main.cpp加载进去 总结 观察自己的main.cpp是否添加到项目当中，报错的本质就是看不见你的main.cpp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f9f1d59d989b0ab30cc12e33cadc11b/" rel="bookmark">
			python：使用函数int()将用户的数值输入转换为整数的数值表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将数值输入用于计算和比较前，要将其转换为数值表示。
例如，下面的示例中，用户输入了10，然后将用户的输入通过int()函数转换成了整数，最后将转换后得到整数和10相比较：
如果不转换，在进行比较的时候出错，如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8c40dbb70f027089c2a07c6e431bc4/" rel="bookmark">
			Spring Boot整合Druid(druid 和 druid-spring-boot-starter)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在现代的Web应用开发中，高性能的数据库连接池是确保应用稳定性和响应性的关键因素之一。Druid是一个开源的高性能数据库连接池，具有强大的监控和统计功能，能够在Spring Boot应用中提供出色的数据库连接管理。本文将研究在Spring Boot中集成Druid连接池的步骤，以及如何通过其丰富的特性优化应用的数据库性能。
数据库连接池 数据库连接池是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态的对池中的连接进行申请、使用、释放。
为什么需要使用数据库连接池 数据库连接是一件费时的操作，连接池可以使多个操作共享一个链接：数据库连接池的基本思想就是为数据库连接建立一个缓冲池，与现在缓冲池中放入一定数量
的连接，当需要建立数据库连接时，只需从缓冲池中取出一个，使用完毕后再放回去：使用数据库连接池可以提高对数据库连接资源的管理，数据库连接池负责分
配、管理和释放数据库连接，允许程序重复使用一个现有的数据库连接，而不是重新建立一个；可以通过设定连接池最大连接数来防止系统无尽的与数据库连接
常见的连接池种类 JDBCP连接池：采用标准的Java EE JDBC AP来实现，同时支持NDl,非常灵活；但是版本比较老了，而且在高并发场景下性能可能存在问题c3p0连接池：功能齐全，能够自动维护连接池，支持JDBC3规范和JDBC2的标准扩展，性能较好：但是配置过于复杂，容易造成资源浪费HikariCPi连接池：专为高并发场景设计，性能优越，具有最快的初始化速度和最小的延迟，支持JDBC4 API;但是由于需要更多的VM资源，可能会造成资源消耗问题druid连接池：支持DBC和Dracle驱动程序，全面的性能监测，对等分布式，具有强大的扩展功能和高度定制化配置 Druid介绍 Druid是一个阿里巴巴结合了c3p0、DBCP等DB池的优点开源的数据库连接池和SQL查询优化工具，用于提高应用程序对数据库的性能和可扩展性。主要提供的功能：数据库连接池、数据库连接池监控、SQL查询优化、数据源管理、防御SQL注入、统计和监控。
注意：SpringBoot2.0默认是用com.zaxxer.hikari.HikariDataSource作为数据源。
Druid功能 数据源监控： 显示数据源的基本信息、活跃连接数、连接等待数量等。
SQL监控： 统计SQL执行的次数、执行时间、错误次数等，帮助优化SQL性能。
日志监控： 展示Druid内部日志，帮助定位问题。
防火墙监控： 配置SQL防火墙规则，提高数据库安全性。
查看当前数据源的测试代码 @SpringBootTest public class DruidTest { @Autowired private DataSource dataSource; @Test void test(){ System.out.println(dataSource.getClass()); } } druid 和 druid-spring-boot-starter区别 druid-spring-boot-starter 是在 druid 基础上进行了封装，专用于集成 spring-boot 项目，无需编写配置类文件。个性化的配置。为专用格式。按照SpringBoot整合其他技术的通用规则来，导入对应的starter，进行相应的配置即可。druid 需要自己手动编写一个配置类文件。为通用格式，不管你换什么数据源都可以用这种形式进行配置。 druid传统的配置 引入Druid依赖 在Spring Boot项目的pom.xml文件中，引入Druid和数据库驱动的相关依赖：
&lt;!-- MyBatis-Plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL Connector 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8c40dbb70f027089c2a07c6e431bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74308aa463960f8250c1613ebbcc6d76/" rel="bookmark">
			JVM内存区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM内存区域 JVM的内存区域主要分为以下几个部分：
1. 程序计数器（Program Counter Register） 用于指示当前线程执行的字节码指令位置 2. Java虚拟机栈（Java Virtual Machine Stacks） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息 3. 本地方法栈（Native Method Stacks） 与Java虚拟机栈类似，用于支持Native方法的执行 4. 堆（Heap） 用于存储对象实例和数组，是Java程序运行时动态分配内存的区域 5. 方法区（Method Area） 存储类的结构信息、常量、静态变量、即时编译器编译后的代码等数据 6. 运行时常量池（Runtime Constant Pool） 存放编译期生成的各种字面量和符号引用 7. 直接内存（Direct Memory） 由操作系统分配的内存，通过NIO的ByteBuffer进行操作 这些内存区域主要用于支持Java程序的运行和管理对象、方法等数据。不同的内存区域有不同的作用和管理方式，对于Java程序的性能和内存管理起着重要的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36cef16c7432bae32183b3116414de4d/" rel="bookmark">
			python：用input()函数接受用户输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，python将其赋值给一个变量，以方便使用。
函数input()接受一个参数，这个参数是给用户的提示，让用户知道如何输入。
示例：
message = input("请输入：") print(message) 一次运行：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5115be265a3e0526fe5332dc18c10c2e/" rel="bookmark">
			Linux权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好呀，这篇博客主要记录Linux权限相关知识，欢迎大家一起交流！
目录
shell命令及其原理
Linux权限的概念
什么是权限？
权限的本质
Linux中的用户
Linux中文件的权限
修改权限的做法
对比权限有无的表现
修改权限的第二套做法
文件类型
如何理解x
目录权限
shell命令及其原理 Linux严格意义上说的是一个操作系统，我们称之为“核心（kernel）“ ，但我们一般用户，不能直接使用kernel。 而是通过kernel的“外壳”程序，也就是所谓的shell，来与kernel沟通。如何理解？为什么不能直接使用kernel？
从技术角度，Shell的最简单定义：介于用户和操作系统之间的命令行解释器，主要包含：
1）将使用者的命令翻译给核心（kernel）处理。
2）同时，将核心的处理结果翻译给使用者。
对比windows GUI，我们操作windows 不是直接操作windows内核，而是通过图形接口，点击，从而完成我们的 操作（比如进入D盘的操作，我们通常是双击D盘盘符.或者运行起来一个应用程序）。
shell 对于Linux，有相同的作用，主要是对我们的指令进行解析，解析指令给Linux内核。反馈结果在通过内核运 行出结果，通过shell解析给用户。
可能这样不是很好理解，那么下面讲一个有趣的故事：
如果说你是一个闷骚且害羞的程序员，那shell就像媒婆，操作系统内核就是你们村头漂亮的 且有让你心动的如花。你看上了如花，但是有不好意思直接表白，那就让你你家人找媒婆帮你提亲，所有的事情你都直接跟媒婆沟通，由媒婆转达你的意思给小花，而我们找到媒婆姓王，所以我们叫它王婆，它对应我们常使用的bash。
那么，为什么会存在外壳程序（shell程序）呢？主要原因有两点：
1.用户不善于和操作系统OS之间交互
2.shell外壳的存在，可以对请求进行合法性检查，变相的保护操作系统OS
那么，如果用户输入非法命令怎么办？
bash基本都会给我们创建一个子进程，这个子进程帮用户进行命令行解释，及时出错了也不影响操作系统，因为没有影响到bash。
那shell和bash有什么区别？还是以上面的媒婆故事举例，如果shell是媒婆，bash就是王婆，sh就是李婆。
Linux权限的概念 什么是权限？ 权限，就是通过一定的条件，拦住一部分人，给另一部分人权利，来访问某种资源。（可以类比为vip或门禁）
权限的本质 权限和人有关，也和事物的属性有关。
Linux中的用户 Linux下有两种用户：超级用户（root）、普通用户。
超级用户：可以再linux系统下做任何事情，不受权限约束
普通用户：在linux下做有限的事情
超级用户的命令提示符是“#”，普通用户的命令提示符是“$”
那么，如何在超级管理员和普通用户之间互相身份切换？
普通用户变成root：
su：只是切换身份，并不会改变目录。（推荐）
su -：切换身份，会改变目录。
root变成普通用户：
su 用户名：从root变成普通用户。
sudo：指令提权，不想变成root，只是想以root的身份执行下一个工作。
Linux中有三种“人”：拥有者、所属组、other。Linux中具有组的概念，主要是在多人协作的时候更好的进行权限管理！
Linux中文件的权限 在新创建的文件中，我们打印出其详细信息，后面的文件信息我们都很容易理解，那么现在我们要了解一下蓝框中的信息代表什么。
第一位：表示文件的类型。-：普通文件 d:目录文件
剩下的一共是9个字符，为什么是9个呢？
文件的属性权限一般有三种：
1.r，读；2.w，写；3.x，可执行权限。
所以上面9个字符分别表示：拥有者有什么权限，所属组有什么权限，other有什么权限。三三为一组，分别对应拥有者，所属组，other。
那么，我们以拥有者权限的前三个字符为例，来详细看一下这三位具体代表什么。
第一个字符：是否具有读权限，如果是，就是r，否则，就是-
第二个字符：是否具有读权限，如果是，就是w，否则，就是-
第三个字符：是否具有可执行权限，如果是，就是x，否则，就是-
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5115be265a3e0526fe5332dc18c10c2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9196f7567b6dfa80f1a9bf643f30ca5e/" rel="bookmark">
			【音视频】基于NGINX如何播放rtmp视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 现阶段直播越来越流行，直播技术发展也越来越快。Webrtc、rtmp、rtsp是比较火热的技术，而且应用也比较广泛。本文通过实践来展开介绍关于rtmp如何播放。
概要 本文重点介绍基于NGINX如何播放rtmp视频流
正文 1、构造rtsp视频流 可以参考上一篇博文:【音视频】基于webrtc协议浏览器播放rtsp
https://blog.csdn.net/HWTwilight/article/details/135653755?spm=1001.2014.3001.5501
那篇分享里面有如何推送出来rtsp视频
2、运行rtmp流媒体服务器 nginx-rtmp-win32-dev 作为rtmp服务器
1）安装目录：
2）配置文件：
worker_processes 1; error_log logs/error.log info; events { worker_connections 1024; } rtmp { server { listen 1935; application live { live on; } application hls { live on; hls on; hls_path temp/hls; hls_fragment 8s; } } } http { server { listen 8080; location / { root html; } location /stat { rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location /stat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9196f7567b6dfa80f1a9bf643f30ca5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a41e4e87db946cc2d5b6f6aa088153/" rel="bookmark">
			输入框为空不能查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 if(!that.addObj.researcherCode){ this.$store.commit('showErrorInfo', {type: 'fail', msg: '请选择研究员'}); return false } if(!this.startTime){ console.log('222'); this.$Message.error({ content: "请选择开始时间！", duration: 5 }); return false } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eef9570ffeade92c1470be98d31be90/" rel="bookmark">
			使用Spring管理Caffeine缓存（CacheManager&#43;Caffeine）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 依赖 使用Spring管理Caffeine缓存的主要pom依赖如下所示。
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt; &lt;artifactId&gt;caffeine&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 2 配置类 CacheManager配置类如下所示。
@Configuration @EnableCaching public class CacheManagerConfig { /** * 创建基于Caffeine的CacheManager */ @Bean @Primary public CacheManager caffeineCacheManager() { SimpleCacheManager cacheManager = new SimpleCacheManager(); List&lt;CaffeineCache&gt; caches = Lists.newArrayList(); for (LocalCacheEnum c : LocalCacheEnum.values()) { caches.add(new CaffeineCache(c.getCacheName(),Caffeine.newBuilder().recordStats() .expireAfterWrite(c.getTtl(), TimeUnit.SECONDS).maximumSize(c.getMaxSize()).build())); } cacheManager.setCaches(caches); return cacheManager; } } @Getter public enum LocalCacheEnum { TestOne(5, 1000, LocalCacheEnum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eef9570ffeade92c1470be98d31be90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15b9bfe4238aa7018c5a7704e77e270c/" rel="bookmark">
			Qt打包程序，debug版运行正常，release版异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下一个很坑的问题：qt编译程序，打包了debug版和release版。然后在自己电脑上运行功能都是正常跑，但是呢，丢到另一台电脑，同样的某个功能发现debug版正常运行，而release版该功能异常崩溃。
检查多次，比如可能影响的原因：少带了文件，相关库文件版本不同，或者是不同电脑环境变量不同。结果发现都不是造成该问题的原因。
有人说可能是release版和debug版，对于一些指针未初始化的容忍程度不同。可能一个指针变量没初始化，在debug环境能够正常过，但在release下就不行。但是因为改动的代码距离上个版本相差太多，本人也不确定是否是这个原因，并且也没有其他好的方法去定位问题出在何处。一时间不知道该咋办。
后面想着先检查其他功能是否有相同的情况，就在界面上各功能处点来点去，结果点回之前异常的功能，发现又正常了。这会就意识到可能是前面点的某个功能给此异常功能带来了影响。然后通过检查代码，果真是有个指针没初始化，就在异常的功能里面使用了，而另一个功能则有对该指针使用new对其进行初始化，所以之后再到异常那边去就正常了。 果然对于一些牵扯到关系的地方，指针还真是得及时进行初始化，不然不初始化，野指针，在别的地方就是使用前进行是否为nullptr判断也不管用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6622fdd5d71089cb40f4eba3091afdc/" rel="bookmark">
			spring boot整合各个中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/qq_29860591/category_9633693.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ccbc4c18a87311b830f1817181037f/" rel="bookmark">
			iView 中DatePicker日期选择器 v-model不生效的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景 公司项目前段使用的是iview样式库，在开发的过程中，需要使用到时间选择器
使用后发现，输出的时间格式有问题，查看了需要使用到format来设置输出内容，发现不生效
百度… 1、百度后了解到v-model和format使用，不会生效，需要用到：@on-change 与 values绑定使用才可以
&lt;Col span="6"&gt; &lt;label for="" class="func-wrapper_label"&gt;&amp;nbsp;开始时间:&amp;nbsp;&lt;/label&gt; &lt;DatePicker type="date" v-model="startTime" :editable="false" placeholder="开始时间" format="yyyy-MM-dd" class="formInput" size="small" @on-change="startTime=$event"&gt;&lt;/DatePicker&gt; &lt;/Col&gt; &lt;Col span="6"&gt; &lt;label for="" class="func-wrapper_label"&gt;&amp;nbsp;结束时间:&amp;nbsp;&lt;/label&gt; &lt;DatePicker type="date" v-model="endTime" :editable="false" placeholder="结束时间" format="yyyy-MM-dd" class="formInput" size="small" @on-change="endTime=$event"&gt;&lt;/DatePicker&gt; &lt;/Col&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d0d4ebbe6b48b4e552336055e0ed6e7/" rel="bookmark">
			【数据结构与算法】排序算法：冒泡排序，冒泡排序优化，选择排序、选择排序优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、冒泡排序
1、冒泡排序思想
2、冒泡排序算法的性能分析
代码实现：
二、选择排序
1、选择排序思想
2、选择排序算法的性能分析 代码实现：
一、冒泡排序 1、冒泡排序思想 冒泡排序的基本思想是通过相邻元素之间的比较和交换来逐步将最大（或最小）的元素移到右边（或左边）。具体来说，冒泡排序的步骤如下：
从数组的第一个元素开始，依次比较相邻的两个元素。如果前面的元素大于后面的元素，则交换它们的位置，以使较大的元素向右移动。继续向数组的下一个相邻元素进行比较和交换，直到最后一个元素，此时最大的元素已经移到了数组的最右侧。重复以上步骤，但这次只需要比较和交换前 n-1 个元素，因为最大的元素已经在正确的位置上。重复进行 n-1 轮比较和交换，直到所有元素都按照从小到大（或从大到小）的顺序排列。 2、冒泡排序算法的性能分析 最好的情况下，当输入数组已经是有序的，冒泡排序只需进行一轮比较，时间复杂度为 O(n)。最坏的情况下，当输入数组是逆序的，冒泡排序需要进行 n-1 轮比较和交换，时间复杂度为 O(n^2)。平均情况下，冒泡排序的时间复杂度为 O(n^2)。冒泡排序是一种稳定排序算法，不会改变相等元素的相对顺序。冒泡排序是一种原地排序算法，不需要额外的空间。 代码实现： 1、普通版本：
// 定义一个交换函数，用于交换两个整数的值 void swap(int* a, int* b) { int temp; temp = *a; *a = *b; *b = temp; } // 冒泡排序函数，对数组进行排序 void BubbleSort(int* a, int n) { int i, j; // 外层循环控制排序的轮数 for (i = 0; i &lt; n - 1; i++) { // 内层循环进行相邻元素的比较和交换 for (j = 0; j &lt; n - i - 1; j++) { // 如果前一个元素大于后一个元素，则交换它们的位置 if (a[j] &gt; a[j + 1]) { swap(&amp;a[j], &amp;a[j + 1]); } } } } 2、优化版本 ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d0d4ebbe6b48b4e552336055e0ed6e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907882449f6b5566f8f4bba56301e441/" rel="bookmark">
			《AI智能化办公：ChatGPT使用方法与技巧从入门到精通》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一本书开启AI高效办公时代，成为AI时代的先行者
零基础上手，让你快速精通
ChatGPT注册/登录→基本操作→提示词训练→
文章生成→图片生成→视频生成→
编写程序→高效办公→设计应用
图书特色 （1）零基础上手：本书的内容从零开始，力求浅显易懂，不需要额外的背景知识即可学习。
（2）前沿知识：本书力争将前沿的知识点和应用操作介绍给读者，帮助读者掌握新资讯和应用技能。
（3）形式丰富：本书内容除了文字描述，还有图片、表格、代码等多种表达形式，帮助读者更好地理解和掌握内容。
（4）案例丰富：本书通过丰富、翔实的案例和操作，引导读者轻松、快速地完成每项应用的操作。
（5）温馨提示：除了基础内容，每章附带的温馨提示提供了对当前讲解内容的补充和拓展，为读者答疑解惑，让学习者少走弯路。
内容简介 本书以人工智能领域最新翘楚“ChatGPT”为例，全面系统地讲解了ChatGPT的相关操作与热门领域的实战应用。
全书共10章，第1章介绍了ChatGPT是什么；第2章介绍了ChatGPT的注册与登录；第3章介绍了ChatGPT的基本操作与提问技巧；第4章介绍了用ChatGPT生成文章；第5章介绍了用ChatGPT生成图片；第6章介绍了用ChatGPT生成视频；第7章介绍了用ChatGPT编写程序；第8章介绍了ChatGPT的办公应用；第9章介绍了ChatGPT的设计应用；第10章介绍了ChatGPT的更多场景应用。
本书面向没有计算机专业背景又希望迅速上手ChatGPT操作应用的用户，也适合有一定的人工智能知识基础且希望快速掌握ChatGPT落地实操应用的读者学习。本书内容系统，案例丰富，浅显易懂，既适合ChatGPT入门的读者学习，也适合作为广大中职、高职、本科院校等相关专业的教材参考用书。
作者简介 李婕：计算机硕士，高级工程师，高校教师，教育信息化专家，出版专著1本，获得计算机软件著作权两项，发布多篇学术论文，完成多项科研项目，深耕教育信息化多年，主研数据治理和人工智能前沿技术。
高博：正高级工程师，IT专家。主要研究方向为云计算与大数据、数据可视化等，熟悉.Net、PHP、Python、DevOps、常见DBMS等技术栈。近年来主持和参与各类纵向、横向项目和课题13项，撰写并发表研究论文11篇，编著出版专业书籍6部，获批软件著作权5项。
袁瑗：AI爱好者，景观设计从业者，熟练运用Rhino、Grasshopper、Lumion等专业软件，主要研究方向为专类花境设计及展园设计，曾参与“北京世界园艺博览会（重庆室外展园）”设计施工、 “第九届中国花卉博览会（重庆园）”设计施工。
当当链接
京东链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b98c146632647c27a312c67412824fa3/" rel="bookmark">
			Apache安全及优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置第一台虚拟机 VM1网卡 yum仓库 挂载磁盘 上传3个软件包到/目录 到/目录下进行解压缩 tar xf apr-1.6.2.tar.gz
tar xf apr-util-1.6.0.tar.gz
tar -xjf httpd-2.4.29.tar.bz2
mv apr-1.6.2 httpd-2.4.29/srclib/apr
mv apr-util-1.6.0 httpd-2.4.29/srclib/apr-util
安装服务 yum -y install \
gcc \
gcc-c++ \
make \
pcre-devel \
expat-devel \
perl \
zlib-devel \
zlib
切换目录 cd httpd-2.4.29
安装服务 ./configure \
--prefix=/usr/local/httpd \
--enable-so \
--enable-rewrite \
--enable-charset-lite \
--enable-cgi
make &amp;&amp; make install
cp /usr/local/httpd/bin/apachectl /etc/init.d/httpd
vi /etc/init.d/httpd
# chkconfig: 35 85 21 //35级别自动运行 第85个启动 第21个关闭
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b98c146632647c27a312c67412824fa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb32b44f1772f8ab7710cb4aed755915/" rel="bookmark">
			Apache-iotdb物联网数据库的安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 &gt;Apache IoTDB (Database for Internet of Things) is an IoT native database with high performance for data management and analysis, deployable on the edge and the cloud. Due to its light-weight architecture, high performance and rich feature set together with its deep integration with Apache Hadoop, Spark and Flink, Apache IoTDB can meet the requirements of massive data storage, high-speed data ingestion and complex data analysis in the IoT industrial fields.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb32b44f1772f8ab7710cb4aed755915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965ed6b70ab5a6c6179d171a00cf55a3/" rel="bookmark">
			shell编程-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式 正则表达式1.什么是正则表达式2.明确一个知识点: shell的解析流程3.通配符4.grep5.正则表达式的普通内容6.一些问题怎么找出特殊字符怎么知道字符串的长度判断用户的密码里是否有特殊字符判断用户密码是否符合复杂性要求 7.作业1.查找 var/log/messages 这个文件里单词的长度在16-18之间的单词显示出来2.进入/lianxi目录，复制/etc/passwd到当前目录下，然后对passwd进行操作3、查找出当前passwd文件中以ftp或者mail开头的行，在屏幕上输出。4、查找出当前passwd文件中首行不是以r、m、f开头的行，在屏幕上输出。5、查找出当前passwd文件中以bash结尾的行。6、查找出/etc/login.defs文件中的有效行（不显示空行和注释行）。7、查找出/var/log/messages文档中有16个字母的单词？8、查找出来/etc/passwd文件里用户名包含liu同时使用bash的用户9、查找/etc/ssh/sshd_config 里的有效行10、查找出/etc/ssh/sshd_config 文件里的包含连续2个数字的行11、查找出包含特殊字符的行12、查找出不包含数字的行13、查找出/var/log/secure里的ip地址出来14、写一个表示下面网址的正则表达式出来。15、写一个表示下面网址的正则表达式出来。16、写一个表示邮箱的正则17、C类ip地址的正则表达式 section1:范围在192-223之间 section2和section3和section4范围：0-255之间18.用简单的正则匹配 netstat -antplu 的ip地址，去重19.用shell生成 16位的密码20.使用ps命令查看进程(pid=2345)的启动时间 正则表达式 一个重要的命令: grep----&gt;过滤文本
1.什么是正则表达式 正则表达式: regular expression 本质上是:一种思想，方法。
理解为一套方法或者工艺
别的命令采用这套方法，去查找内容
按照某种正确的规则，将字母，数字，特殊符号组合成一个公式，用来表达某个意思
作用: 一些查找类的命令，喜欢使用正则表达式去搜索符合条件的内容
写正则表达式 就是根据某个特点，使用规则表示出来，然后grep可以根据这个规律去查找
2.明确一个知识点: shell的解析流程 **在输入一条命令的时候 会将命令分割成 tokens 比方说 mkdir -p gao{1…20} **
先查看mkdir检查是不是关键字
检查第一个token是不是别名
然后看看有没有波浪符号
再看有没有变量替换
再看有没有命令替换(优先级高)
看有没有算数表达式
再看展开的文本进行单词的分割
展开通配符
命令查找
执行命令
eval会再执行一下
**eval命令将会首先扫描命令行进行所有的替换，然后再执行命令。该命令使用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。这些需要进行两次扫描的变量有时候被称为复杂变量 **
两次扫描 test.txt内容：hello shell world! myfile="cat test.txt" (1)echo $myfile　#result:cat test.txt (2)eval $myfile　#result:hello shell world! 从（2）可以知道第一次扫描进行了变量替换，第二次扫描执行了该字符串中所包含的命令 3.通配符 [0-9] 取0到9之间的任意一个字符[^0-9] 不是0到9的字符[abc] 取a或者b或者c[a-z] 取字母a-z之间的字符[A-Z] 取字母A-Z之间的字符 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965ed6b70ab5a6c6179d171a00cf55a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e10acb0770cf7bcdbffb9fbfea72400/" rel="bookmark">
			人大金仓数据库KingbaseES 中的自治事务、子事务和长事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键字： KingbaseES、自治事务、长事务、子事务、人大金仓
事务 事务在数据库中是最小的操作执行单位，一个事务提交后，要么全部执行(commit)，要么全部都不执行(rollback)；KingbaseES数据库中，事务是默认自动开启的，即在执行单条sql语句时，会进入一个默认的事务环境中，sql语句执行成功后，事务也就完成； KingbaseES也可以手动开启和关闭事务，可以使用begin;命令或start transaction命令开启事务，使用end;或rollback命令关闭事务。 2. 自治事务自治事务的定义 自治事务，顾名思义，自己管理自己的事务，它能够独立于其父事务提交或回滚。利用自治事务，可以挂起当前执行的事务，开启一个新事务，完成一些工作，然后提交或回滚，所有这些操作都不影响当前执行事务的状态。
只要开始执行，一个自治事务就完全独立于调用它的主事务。它看不到主事务的任何未提交的改变、不和主事务共享任何锁和资源。自治事务产生的改变在自身的提交之后就可以让其他事务看到。
自治事务的实现 语法：
只需要在PL/SQL的声明部分加上PRAGMA AUTONOMOUS_TRANSACTION即可：
如图所示，在程序块中声明自治事务后，程序块中的commit和rollback操作并不会影响到主事务，只会影响到该程序块中本身的事务；并且程序块中的子事务之间相互也不会有任何影响。
3. 子事务
子事务的概念 在KingbaseES中，事务是默认工作在自动提交模式下，这种模式只支持单语句的执行，在多语句的情况下，就需要显示的调用begin或者start transaction来开启一个事务，进行手动提交，最后使用end或者rollback命令来结束该事务。
在普通事务下，如果在执行多语句操作，某一步骤的sql语句出现了错误，那么只能使用rollback整个事务，然后从头开始整个事务；而子事务的出现可以解决这种问题，子事务允许用户回滚部分想要回滚的事务，也就是将一个完整的事务分割为多个子事务，当操作过程中出错或者不想执行某操作时，对事务中的子事务进行回滚操作即可，不需要对整个事务都进行回滚。
子事务的实现 在子事务中，不能直接对子事务进行提交，子事务也是通过事务的提交而提交，通过savepoint p1 在事务中打上保存点标记，将事务分割为多个子事务。
子事务在SQL语句中的使用：
SAVEPOINT savepoint_name
ROLLBACK [ WORK | TRANSACTION] TO [ SAVEPOINT ] savepoint_name
RELEASE [ SAVEPOINT ] savepoint_name
注意：
Savepoints语句必须在事务块中；Savepoint执行保存点；rollback回滚到指定的保存点；release擦除保存点，不会回滚子事务数据；Cursor不会被savepoint事务影响 子事务示例：
4. 长事务
长事务是相对于短事务而言的，短事务一般执行的时间较短，但是在实际应用中，有些事务可能涉及到大量的数据和复杂的业务逻辑，执行的时间较长，这就是长事务。
短事务执行时间短，对数据库系统的性能影响较小，而长事务可能导致数据库锁定资源时间过长，从而影响系统的并发性能和响应速度。
长事务的定义依据是事务的执行时间超过一定的阈值，一般情况下可以根据数据库操作的复杂性和执行时间的长短来确定，比如，可以将超过5秒钟的事务定义为长事务。
构造大量数据，如：
对表test_001插入500W条数据，大量的数据插入会使得该事务的执行时间较长，因此，该事务可以被称为长事务；
除此之外，还可以手动构建长事务，比如，开启事务后，长时间内不对事务做commit或者rollback操作，会导致事务一直处于活跃状态中，这也能被称为长事务：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54e4b76a8ed384324518239c19c8b8de/" rel="bookmark">
			【01】mapbox js api加载arcgis切片服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： 第三方的mapbox js api加载arcgis切片服务，同时叠加在天地图上，天地图坐标系web墨卡托。
效果图： 形如这种地址去加载http://zjq2022.gis.com:8080/demo/loadmapboxtdt.html
思路： 需要制作一个和天地图比例尺级别以及切片大小等一样的切片方案，可以通过arcmap或者arcgispro制作。如图：
具体的切片信息参数参考链接：
arcgis javascript api4.x加载天地图web墨卡托（wkid：3857）坐标系_acrgis 加载墨卡托地图-CSDN博客
制作出的切片方案见链接：
链接：https://pan.baidu.com/s/1fezUPJnp-G0g6cpcbsOuEw 提取码：gfwm 使用该切片方案去切片。
切片之后的效果：
mapbox加载arcgis切片服务示例代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;mapbox 添加arcgis rest切片地图服务&lt;/title&gt; &lt;meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"&gt;&lt;/script&gt; &lt;link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" /&gt; &lt;script src="https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.js"&gt;&lt;/script&gt; &lt;style&gt; body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="map"&gt;&lt;/div&gt; &lt;script&gt; const vecUrl = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54e4b76a8ed384324518239c19c8b8de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc59ededb15387db2c4fe942b104680/" rel="bookmark">
			小白水平理解面试经典题目LeetCode 88 Merge Sorted Array【Java实现】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		88. 合并排序数组 你好，今天做的是leetcode 88题，是一道数组类题目，它也是总被问道的一个类型。
题目描述 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 都为空，且 nums1 的长度为 m + n。
将 nums1 和 nums2 合并到按非降序排序的单个数组中。
最终排序的数组不应由函数返回，而应存储在数组 nums1 内。为了适应这种情况， nums1 的长度为 m + n ，其中第一个 m 元素表示应合并的元素，最后的值如果设置为0，应被忽略。 nums2 的长度为 n 。
例子 这里我个人小白理解分析： 思考1：如果只需一次考虑两个元素而不是两个数组，则可以轻松解决此问题。
我们都知道每个单独的数组都是有序的。我们不知道的是它们将如何交织在一起。我们能否做出局部决策并得出最佳解决方案？
猛一看，这类题好像是一个常规合并，返回一个结果数组即可。暴力解法走起，只要把nums2 数组中的元素先遍历的放入nums1数组中，完事儿后，并进行一个从小到大的升序排列。内心露出一抹喜色，怎么样，终于把隔壁班女生联系方式要到了。
解题环节 上来咱就是主打一个快，别让面试官久等了。
public static int[] merge1(int[] nums1, int m, int[] nums2, int n) { // 将两个数组合并到一个数组中 for (int i = 0; i &lt; n; i++) { nums1[m + i] = nums2[i]; } // 对合并后的数组进行排序 Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc59ededb15387db2c4fe942b104680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a90b201133decaccb4793b3d952bcbb/" rel="bookmark">
			快速监控 Oracle 数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle 数据库在行业内应用广泛，通常存放的非常重要的数据，监控是必不可少的，本文使用 Cprobe 采集 Oracle 监控数据，极致简单，分享给大家。
安装配置 Oracle 简单起见，我使用 Docker 启动 Oracle，命令如下：
docker run -d --name oracle -p 1022:22 -p 18080:8080 -p 1521:1521 wnameless/oracle-xe-11g-r2 如上命令启动之后，Oracle 的监听端口是 1521，用户名/密码是 system/oracle，数据库 SID 是 xe，要监控 Oracle，首先得有账号连上去执行 SQL，所以这些连接信息得记住喽，待会要用。
如果是对既有的 Oracle 做监控，需要创建账号并分派权限，比如：
-- Create the monitoring user "cprobe" CREATE USER cprobe IDENTIFIED BY &lt;YOUR-PASSWORD&gt;; -- Grant the "cprobe" user the required permissions GRANT CONNECT TO cprobe; GRANT SELECT ON SYS.GV_$RESOURCE_LIMIT to cprobe; GRANT SELECT ON SYS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a90b201133decaccb4793b3d952bcbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b738c664c4c6f2e0a265790fd338a42e/" rel="bookmark">
			2023年河北省职业院校技能大赛 网络系统管理赛项 模块C：Linux部署 样题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、初始化环境
1.默认账号及默认密码
2.操作系统配置
二、项目任务描述
1.拓扑图
2.网络地址规划
三、项目任务清单
服务器IspSrv工作任务
服务器RouterSrv上的工作任务
服务器AppSrv上的工作任务
服务器StorageSrv上的工作任务
客户端OutsideCli和InsideCli工作任务
一、初始化环境 1.默认账号及默认密码 Username: root
Password: ChinaSkill23!
Username: skills
Password: ChinaSkill23!
注：若非特别指定，所有账号的密码均为 ChinaSkill23!
2.操作系统配置 所处区域：CST + 8
系统环境语言：English US (UTF-8)
键盘：English US
注意：当任务是配置TLS，请把根证书或者自签名证书添加到受信任区。
控制台登陆后不管是网络登录还是本地登录 ，都按下方欢迎信息内容显示
*********************************
ChinaSkills 2023–CSK
Module C Linux
&gt;&gt;hostname&lt;&lt;
&gt;&gt;System Version&lt;&lt;
&gt;&gt; TIME &lt;&lt;
*********************************
二、项目任务描述 你作为一个Linux的技术工程师，被指派去构建一个公司的内部网络，要为员工提供便捷、安全稳定内外网络服务。你必须在规定的时间内完成要求的任务，并进行充分的测试，确保设备和应用正常运行。任务所有规划都基于Linux操作系统，请根据网络拓扑、基本配置信息和服务需求完成网络服务安装与测试，网络拓扑图和基本配置信息如下：
1.拓扑图 2.网络地址规划 服务器和客户端基本配置如下表，各虚拟机已预装系统。
ISPSRV（UOS）
完全限定域名：ispsrv普通用户/登录密码：skills/ChinaSkill23超级管理员/登录密码：root/ChinaSkill23网络地址/掩码/网关：81.6.63.100/24/无 AppSrv(Centos)
完全限定域名：appsrv.chinaskills.cn普通用户/登录密码：skills/ChinaSkill23超级管理员/登录密码：root/ChinaSkill23网络地址/掩码/网关：192.168.100.100/24/192.168.100.254 STORAGESRV(Centos)
完全限定域名：storagesrv.chinaskills.cn普通用户/登录密码：skills/ChinaSkill23超级管理员/登录密码：root/ChinaSkill23网络地址/掩码/网关：192.168.100.200/24/192.168.100.254 ROUTERSRV(Centos)
完全限定域名：routersrv.chinaskills.cn普通用户/登录密码：skills/ChinaSkill23超级管理员/登录密码：root/ChinaSkill23网络地址/掩码/网关： 192.168.100.254/24/无、192.168.0.254/24/无、81.6.63.254/24/无 INSIDECLI(Centos)
完全限定域名：insidecli.chinaskills.cn普通用户/登录密码：skills/ChinaSkill23超级管理员/登录密码：root/ChinaSkill23网络地址/掩码/网关：DHCP From AppSrv OUTSIDECLI（UOS）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b738c664c4c6f2e0a265790fd338a42e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e71e1e9cb979a1e58b1abc663487073/" rel="bookmark">
			2023年河北省职业院校技能大赛 网络系统管理赛项 模块B：Windows部署 样题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、初始化环境
1.默认账号及默认密码
二、项目任务描述
1.拓扑图
2.网络地址规划
三、项目任务清单
（一）服务器IspSrv上的工作任务
（二）服务器RouterSrv1上的工作任务
（三）服务器AppSrv上的工作任务
（四）服务器DCSERVER&amp;SDCSERVER上的工作任务
（五）客户端InsideCli上的工作任务
（六）客户端OutsideCli上的工作任务
一、初始化环境 1.默认账号及默认密码 Username: Administrator
Password: ChinaSkill23!
Username: demo
Password: ChinaSkill23!
注：若非特别指定，所有账号的密码均为ChinaSkill23!
二、项目任务描述 你作为一个技术工程师，被指派去构建一个公司的内部网络，要为员工提供便捷、安全稳定内外网络服务。你必须在规定的时间内完成要求的任务，并进行充分的测试，确保设备和应用正常运行。任务所有规划都基于Windows操作系统，请根据网络拓扑、基本配置信息和服务需求完成网络服务安装与测试，网络拓扑图和基本配置信息如下：
1.拓扑图 2.网络地址规划 服务器和客户端基本配置如下表，各虚拟机已预装系统。
DCServer
chinaskills.com
192.168.100.100/24
127.0.0.1
192.168.100.254
SDCSserver
chinaskills.com
192.168.100.200/24
127.0.0.1
192.168.100.254
AppSrv
chinaskills.com
192.168.200.100/24
192.168.100.100
192.168.100.200
192.168.200.254
RouterSrv1
chinaskills.com
192.168.100.254/24
192.168.0.254/24
192.168.200.254/24
100.100.100.251/24
192.168.100.100
100.100.100.254
IspSrv
保持工作组状态
100.100.100.100/24
127.0.0.1
无
InsideCli
chinaskills.com
192.168.0.0/24(dhcp)
192.168.100.100
192.168.100.200
192.168.0.254
OutsideCli
保持工作组状态
100.100.100.10/24
100.100.100.100
100.100.100.254
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e71e1e9cb979a1e58b1abc663487073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c014eb8a8f8657e6019e6d54faa5fab0/" rel="bookmark">
			JNA调用C&#43;&#43;动态库，返回二维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JNA/JNI封装，C++开发交流, showcode1024
1.下载eclipse创建一个项目，jdk选择1.8的版本，更高的需要配置下
package mydemo; import com.sun.jna.Library; import com.sun.jna.Native; import com.sun.jna.ptr.IntByReference; import com.sun.jna.ptr.LongByReference; import com.sun.jna.ptr.PointerByReference; import com.sun.jna.Pointer; import com.sun.jna.Memory; public class Hello { public interface LgetLib extends Library { // 调用linux下面的so文件,注意，这里只要写test就可以了，不要写libtest，也不要加后缀 LgetLib INSTANCE = (LgetLib) Native.loadLibrary("EasyLog", LgetLib.class); public int test(Pointer arr, int row, int col); public int get2Darr(Pointer pppFloatOut, IntByReference pLine, IntByReference pColumn); //public void free2Dppt(int line, int column, Pointer ppFloat); } public int test(){ // 传入二维数组 // Pointer pointers = new Memory(24); // int pointer_size = 8; // int int_size = 4; // int row = 3; // int col = 5; // int n = 0; // for (int i = 0; i &lt; row; i++) { // //分配20字节的内存空间，并且该指针指向这个内存空间的首地址 // Pointer pointer = new Memory(20); // for (int j = 0; j &lt; col; j++) { // pointer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c014eb8a8f8657e6019e6d54faa5fab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1979cfd2929117efab9e0e665891d7e/" rel="bookmark">
			TCP高并发服务器简介（select、poll、epoll实现与区别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select、poll、epoll三者的实现： select实现TCP高并发服务器的流程： 一、创建套接字（socket函数）：二、填充服务器的网络信息结构体：三、套接字和服务器的网络信息结构体进行绑定（bind函数）：四、套接字设置成被动监听（listen函数）：五、创建要监听的文件描述符集合：使用select函数后，会将没有就绪的文件描述符在集合中去除，所以需要创建两个文件描述符集合，一个是母本read_fds，类似于常量，保持不变，而另一个作为副本read_fds_t，类似于变量，可以改变； fd_set read_fds; FD_ZERO(&amp;read_fds); fd_set read_fds_t; FD_ZERO(&amp;read_fds_t); 六、把创建的套接字添加到要监视的集合中： FD_SET(sockfd,&amp;read_fds); int fd_max = 0; fd_max = fd_max &gt; sockfd ? fd_max : sockfd; 七、设置系统时间结构体变量，用来指定超时的时间： struct timeval tm_out; 八、等待文件描述符中的事件是否就绪，成功则返回就绪的文件描述符的个数（select函数）：select函数： #include &lt;sys/select.h&gt; int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); /* 参数： nfds：	要监视的最大文件描述符+1 readfds：	要监视的读文件描述符集合 不关心可以传NULL writefds：	要监视的写文件描述符集合 不关心可以传NULL exceptfds：	要监视的异常文件描述符集合 不关心可以传NULL timeout：	超时时间 如果设置成NULL 会一直阻塞 直到有文件描述符就绪 返回值： 成功 就绪的文件描述符的个数 超时 0 失败 -1 重置错误码 */ //struct timeval 可以指定超时时间 //如果结构体的两个成员都为0 表示非阻塞 struct timeval { long tv_sec; //秒 long tv_usec; //微秒 }; void FD_CLR(int fd, fd_set *set);	//将文件描述符在集合中删除 int FD_ISSET(int fd, fd_set *set);	//判断文件描述符是否还在集合中 // 返回0 表示不在了 非0 表示在 void FD_SET(int fd, fd_set *set);	//向集合中添加一个文件描述符 void FD_ZERO(fd_set *set);	//清空集合 if(-1 == (ret = select(fd_max + 1,&amp;read_fds_t,NULL,NULL,&amp;tm_out))) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1979cfd2929117efab9e0e665891d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ffb28d356d391f08ad6cb78fa61cac/" rel="bookmark">
			什么是车载信息娱乐系统和集成驾驶舱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是车载信息娱乐系统(IVI)? “车载信息娱乐(IVI)”通过向驾驶员和乘客提供信息和娱乐，为驾驶提供便利和舒适。为了理解这个概念，有必要知道“信息娱乐”的含义。“信息娱乐”是这个市场中使用的一个词，它结合了“信息”和“娱乐”两个词。“车载信息娱乐”在需要的时候提供了这些东西。驾驶员和乘客需要哪些类型的信息是支持驾驶的典型信息，例如导航和道路交通信息。除此之外，娱乐，内容播放，如音乐和电影也是如此。在未来，当汽车普遍连接到高速互联网时，我们将能够看到更多。例如，阅读新闻，检索存储在云中的文件，下载电影，下载音乐，以及使用语音识别操作我们的汽车，我们现在用电脑和智能手机做的这些事情更加舒适和无缝。
什么是车载信息娱乐系统? 术语“车载信息娱乐系统”是指使车载信息娱乐成为可能的各种机制。更具体地说，它是一个通过开关、触摸面板、语音接收用户操作并处理必要信息，然后输出到扬声器或显示器的系统。它是基于各种硬件和软件。在这些部件中，显示各种类型信息的显示器起着重要的作用。
*“车载信息娱乐”一般指“导航等+音频/视觉”，但在这里的描述中包括“仪表/仪表集群显示”。
什么是中心信息显示(CID)? “中央信息显示器”是位于驾驶舱中心的大型显示器。它显示导航和娱乐信息，是实现车载信息娱乐的关键。它将随着更高的分辨率尺寸和更多的显示器数量而变得更大。
什么是仪表/仪表集群显示? “仪表/仪表组合显示屏”是位于方向盘后面的显示屏。在某些情况下，它被称为仪表集群显示。它显示驾驶速度，电池电量，发动机/电机转速，燃油消耗和各种提示/警示灯。这些信息大部分与驾驶安全有关，因此需要确保正确显示。
什么是平视显示器(HUD)? “抬头显示器”是一种通过投射在挡风玻璃上显示信息的显示器。如果你把它想象成挡风玻璃上的显示屏，可能会更容易理解。平视显示器通常显示驾驶信息，如速度和汽油/电池电量，以及来自导航的简化信息。因此，司机可以不低头继续驾驶。近年来，随着增强现实(AR)技术的兴起，平视显示器得到了长足的发展。例如，与简单地投射导航信息不同，增强现实显示器可以显示箭头，指示与挡风玻璃外的实际道路一致的行驶方向，使识别更加直观。这种下一代平视显示器有望成为未来的主流。
“车载信息娱乐”汽车的未来愿景 通过车载信息娱乐系统和高级驾驶辅助系统(ADAS)之间的联系，其中一些已经实现。物体检测，如行人或其他车辆，就是一个例子。该系统利用安装在汽车上的传感器和高精度GPS来探测危险。该系统不仅在显示器上显示信息，而且还辅助制动。此外，系统对驾驶员进行监控，实现安全驾驶支持。安装在汽车座椅和其他部件上的图像传感器和心率传感器实时监测驾驶员的状况。如果系统确定驾驶员昏昏欲睡或注意力不集中，它会通过警告声音和座椅振动提醒驾驶员避免危险。
娱乐业也已经意识到了一些事情。例如，从智能手机上下载高质量的音乐。通过连接高规格扬声器的汽车音响系统播放音乐，您可以像在音乐厅一样享受车内的音乐。
随着未来车载信息娱乐的进一步发展，也会有更多新的可能性出现。这只是一个例子，但汽车可能会识别驾驶员智能手机上注册的时间表，并自动设置导航系统。或者播放司机选择的音乐。与自动驾驶技术相结合，司机将能够像在家里或办公室一样吃饭、聊天、玩游戏和工作。
随着车载信息娱乐的发展，过去花在交通上的时间现在可以自由支配了。
什么是集成驾驶舱? 集成座舱是指综合管理各种信息的显示器，包括仪表/仪表盘显示的信息，以及中央信息显示器和平视显示器显示的信息。此外，最近还包括先进驾驶辅助系统(ADAS)、驾驶监视系统(DMS)等信息的综合管理，预计将得到普及。到目前为止，仪表/仪表盘和信息娱乐系统一直是一个独立的单元，但在“集成驾驶舱”中，一切都由一个ECU控制。这将使在必要的时间在最合适的显示器上显示必要的信息成为可能，有助于提高驾驶员和乘客的安全性和便利性。
车载信息娱乐系统中显示的挑战 随着车载信息娱乐的发展，显示区域也面临着挑战。
*一般来说，“车载信息娱乐”是指“导航等+音频/视觉”，但这里包括“仪表/仪表集群显示”。
更大、更高分辨率的显示器 首先，显示器的尺寸越来越大，分辨率也越来越高。在过去，汽车显示器被用来显示有限的信息，如时间、导航系统和歌曲标题。随着后视镜上的图像、电机剩余电量、驾驶员操作趋势等显示内容的增加，显示器的尺寸也越来越大，分辨率也越来越高。
为了在更大的显示器上显示如此多的信息，整个系统必须达到更高的规格。因此，挑战在于如何应对显示器尺寸和分辨率的增加。
多显示(multi-display) 多显示器是另一个挑战。除了中央信息显示器和仪表/仪表组显示，汽车现在有更多的显示器，包括平视显示器。当然，显示更多信息的便利性大大增加了。然而，在某些方面，很难知道哪些信息显示在哪个显示器上。
此外，多个显示器正在被组合成一个大显示器。例如，一个中心信息显示通常是一个单独的显示，然而，随着信息的增加，几个显示被组合成一个单独的显示。用户的便利性增加了，但必须解决将单个视频信号分配到多个显示器的技术问题。
数字仪表/仪表组的安全措施 仪表/仪表集群显示用于显示速度，发动机转速等模拟方式。如今，部分或全部放置在仪表上的LCD屏幕上的数字显示正在成为主流。
重要的是要注意与安全有关的信息，如提示/警示灯、汽油、电池电量、安全带、半门和侧刹车。如果显示器继续显示错误信息，驾驶员和乘客的安全可能会受到严重威胁。为了防止这种情况发生，整个系统必须有一个机制来检测何时显示故障。
爱普生车载显示控制器的特点 爱普生提供一系列具有多种功能的车载显示控制器，有助于实现车载信息娱乐和集成驾驶舱。一个关键的特点是适应各种显示需求的能力。
显示器上的图像通过从SoC(片上系统)向显示器输出视频信号来显示。然而，随着车载信息娱乐的发展，从SoC到显示器的信号之间出现了不一致。爱普生车载显示控制器置于SoC和显示器之间解决了这些问题。
阵容 汽车集成电路的安全功能 爱普生的汽车集成电路具有多种安全功能。其中一个功能是监视。当IC检测到来自主机的流图像中的信号异常时，它通知主机并执行显示处理，如必要时覆盖信号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a894653a39b78455ff1cefa881daa49d/" rel="bookmark">
			【Ant Design of Vue】Modal.confirm无法关闭的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 在使用 Ant Design Vue 的 Modal.confirm 确认框时，出现了点击取消和确定后 Modal.confirm 确认框无法关闭的问题
二、代码 代码完全是 copy 的官网的代码，但是 copy 到本地后就会出现上述问题
&lt;template&gt; &lt;a-button @click="showConfirm"&gt;Confirm&lt;/a-button&gt; &lt;/template&gt; &lt;script lang="ts"&gt; import { ExclamationCircleOutlined } from '@ant-design/icons-vue'; import { createVNode, defineComponent } from 'vue'; import { Modal } from 'ant-design-vue'; export default defineComponent({ setup() { const showConfirm = () =&gt; { Modal.confirm({ title: 'Do you Want to delete these items?', icon: createVNode(ExclamationCircleOutlined), content: createVNode('div', { style: 'color:red;' }, 'Some descriptions'), onOk() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a894653a39b78455ff1cefa881daa49d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d4ab315c3da4f1b1436c6e2efe0ba3/" rel="bookmark">
			企业为什么需要选择软件测试外包公司?有哪些查找途径?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件测试外包公司是专门为软件企业提供软件测试服务的机构。这些公司拥有一支经验丰富、专业化的软件测试团队，能够帮助企业进行软件产品的测试、评估和质量保证。
一、企业为什么需要选择软件测试外包公司?
1.专业的测试团队：外包公司拥有经验丰富的测试团队，能够提供全面、专业的软件测试服务，确保产品质量。
2.降低成本：外包公司通常拥有先进的测试设备和高效的测试流程，可以提高测试效率，节约企业的时间和人力成本。
3.灵活的人力资源：通过选择外包公司，企业可以根据项目需求灵活调整测试人力资源，避免了过剩或不足的情况。
4.风险分担：外包公司与客户签订合同，明确各方责任，降低了软件测试过程中的风险。
二、企业选择软件测试外包公司的查找途径
1.参考口碑：可以向同行企业、合作伙伴或专业社区咨询，了解他们对某家外包公司的评价和推荐。
2.网上搜索：通过搜索引擎输入相关关键词可以得到大量的相关信息，从而进行筛选。
3.咨询专业机构：可以咨询软件测试资质认证机构或行业协会，了解推荐的外包公司。
总结：选择软件测试外包公司可以帮助企业降低成本、提高效率、分担风险，而寻找合适的外包公司可以通过参考口碑、网上搜索以及咨询专业机构来进行。小编推荐卓码软件测评，具备CMA、CNAS双重认证资质的专业软件测试外包公司，拥有一支专业化的测试团队，致力于提供高质量的软件测试服务。
文章来源：企业为什么需要选择软件测试外包公司?有哪些查找途径?—卓码软件测评
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de29a12cdc26cb7b4132f9eb6b7a78d/" rel="bookmark">
			别错过！春节前再赚一笔！就用这3个AI工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		年关将近！很多人已经搓手等待春节放假啦！但是有一批人，正在筹备趁着春节的热度，大赚一波！
很多人都还不知道，做红包封面也能赚钱！还有博主利用AI做头像、壁纸，经营自己的小红书账号，1个月涨粉破五千，单条广告报价破千！轻松实现副业月入过万！
今天大设就给大家带来一组非常适合在小红书做账号搞副业的工作流，按照大设一贯的理念：
“无需学习，开箱即用！”
1
用大设AI工作流
售卖红包封面搞钱
精美的红包封面一图难求，一个红包封面平均售价3~15元，访问BigBigAi.com，点击“大设工作流”，点击“海报背景”，马上就可以开始创作你的红包封面！
热门的春节元素红包封面工作流均已上线，快开始你的创作吧！
将在大设AI生成的图片，下载保存，同时将AI生成图片信息界面截图保存，可以帮助你通过微信官方的原创审核噢！
我们还贴心地准备了一套微信红包上传过审详细教程，感兴趣的朋友，可以在文末加客服微信备注“红包封面过审”领取过审秘籍。
2
用大设AI工作流
定制姓氏头像搞钱
使用大设AI的“姓氏头像工作流”，可以生成任意姓氏的动漫头像，一个姓氏头像9.9元，但使用AI生成几乎不花任何成本，靠这个信息差赚钱，真是太容易了！
访问BigBigAi.com, 点击“大设工作流”–“头像创作”，即可开始创作，10秒钟即可生成你需要的姓氏头像！
还有更多风格头像生成工作流，对于不同风格头像需求都能满足，帮助您在账号运营中节省时间！
3
用大设AI工作流
创作壁纸做号接单
画面精美、创意十足的壁纸，一直是小红书大热的账号类别，借助大设AI设计工作流，你可以轻松运营多个风格独特的壁纸账号。
（左滑查看更多大设AI创意壁纸）
访问BigBigAi.com， 点击“大设工作流”–“原创壁纸”，可以看到不同风格的手机壁纸模板，你只需要替换关键词，即可批量产出上百张壁纸，再也不用满世界去找素材。
如果您需要重复进行某一个AI绘图操作，我们推荐您在生成图片的界面鼠标悬浮到图片右上角，点击“保存为我的工作流”，这样您常用的提示词和参数都将被保存，下次可以通过“我的创作”–“我的工作流”快速访问，开箱即用，省时省力！
此外，我们还向您推荐如下实用工作流，可以让您在日常运营工作中如虎添翼！
在可预见的未来，随着AI大范围在职场推广，使用门槛降低，部分还在做重复工作的打工人会不可避免地被取代。
这也是为什么身边越来越多人都在学AI。
负责任地说，这是AI离普通人超近的一次。它——
很简单： 只要你有一个浏览器，登录一个网页，会打字、会聊微信就能够直接使用。
很实用： 任何上班族，无论你的工作涉及文字、图片、数字，或是办公软件全家桶，它都能成为你的高效助理。
很聪明： AI如同一个六边形战士，当你有个绝妙点子，它能随时点亮技能树，用编程、写作、绘画技能把你的想法落地。
随着人工智能的推广，具备AI技能的人将更容易适应未来岗位需求，成为早期吃到红利的稀缺人才。
早点开启AI学习，给自己的人生来个翻天覆地的变化吧！
如果你也对AI技术感兴趣感兴趣，可以下方扫码免费领取一份AI技术入门资料包wx扫描二v码免费领取【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045adfb32c85d9ec004996eabcbf3665/" rel="bookmark">
			迈进Galaxy AI新时代 三星Galaxy S24系列正式发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1月18日，三星电子正式推出新一代高端旗舰系列产品三星Galaxy S24 Ultra、Galaxy S24+和Galaxy S24。通过创新的Galaxy AI ，新一代三星Galaxy S系列将重新定义移动设备为用户赋能的方式，开创移动体验的新时代。从利用智能文本和通话翻译实现无障碍交流，到采用Galaxy超视觉影像自由释放创意，再到以全新搜索方式助力Galaxy用户探索世界，三星Galaxy S24系列将发挥人工智能的优势，全方位提升用户体验。
三星电子移动通信部门总裁卢泰文表示：“三星Galaxy S24系列革新了我们与世界的连接方式，为未来十年移动设备的创新指明了方向。Galaxy AI继承三星的创新传统，基于用户使用习惯的深刻洞察打造。我们期待通过Galaxy AI帮助世界各地的三星用户发现更多可能性，点亮他们的生活。”
【三星Galaxy S24系列】
日常体验，从此不凡
Galaxy AI旨在让方方面面的体验都更加智能便捷，首先是手机最基本的沟通功能。三星Galaxy S24系列的原生通话应用程序内置通话实时翻译 ，提供实时双向语音和文字翻译，无需第三方应用，让用户轻松跨越语言障碍，流畅地与外国学生或同事交流，顺利地预定国外旅行。在此过程当中，基于设备端的人工智能将确保用户的对话隐私。
在短信和其他应用程序当中，写作助手可以协助用户在沟通时选择得体的语言风格，例如以礼貌的措辞回复同事的信息，或者发布网络推文时，生成简洁而引人注目的标题 。此外，三星键盘模块内置的AI翻译功能支持实时处理13种语言 ，能够为用户翻译短信、邮件等文本。
三星笔记的笔记助手功能支持智能生成笔记摘要和创建模板，可以通过预制格式简化笔记流程，还可通过生成封面让笔记更容易查找，让工作更有条理。在录制语音时，即使在多人发言的场景下，转录助手也能通过AI和语音转文本技术转录、总结，甚至翻译录音内容。
三星Galaxy S24系列对手机基础功用的创新不止于沟通层面，还包括在线搜索这一近乎改变人们生活方式的功能。三星Galaxy S24系列首创即圈即搜功能，以简单的手势操作开启搜索方式新篇章，提供直观的、基于手势的全新搜索体验，为在线搜索带来历史性的变革。通过全新搜索工具，用户只需长按Home按钮，然后圈选、突出显示、涂画或轻触三星Galaxy S24屏幕上的任何图片、视频或文本，即可立即获得精准优质的搜索结果。无论是朋友帖文当中令人神往的旅行目的地，还是短视频当中让人惊讶的趣闻，都可以快速获取更多信息，且无需离开当前应用。此外，在某些搜索场景下，人工智能还会基于用户所在的位置，对网络上的有用信息和相关背景进行整合，并自动生成概述，甚至还可以基于此提出更加细致的问题。即圈即搜让一切如此简单，又如此非凡。
【即圈即搜功能】
释放无穷创造力，解锁探索世界新方式
三星Galaxy S24系列搭载超视觉影像 ，这是三星全新的AI影像工具套件，将以革命性的拍摄体验赋能影像创作的每一个阶段，让用户从准备拍摄到社交分享，尽享无与伦比的创作自由。三星Galaxy S24 Ultra的四长焦系统搭载全新5倍光学变焦镜头，结合5000万自适应像素传感器，可实现从2倍、3倍、5倍到10倍 光学品质的变焦表现。此外，增强型数码变焦可保证图像在放大100倍时依旧清晰锐利。
三星Galaxy S24系列的超视觉夜拍功能也迎来升级，即便是在长焦端，也能捕捉到精彩的夜拍照片和视频。三星Galaxy S24 Ultra的像素尺寸达到1.4μm，与前代机型相比提升了60% ，能够在昏暗环境下捕捉到更多光线。三星Galaxy S24 Ultra支持更宽的OIS光学防抖角度和增强的手部抖动补偿，可进一步减少画面模糊。视频拍摄方面，三星Galaxy S24前后摄像头均配备专用于降噪的图像信号处理模块，能够有效去除画面噪点，此外，还能通过分析陀螺仪信息，对拍摄者和拍摄对象的运动进行区分，即使在暗光环境中远距离拍摄，也可以获得清晰的视频画质。
【超视觉夜拍成像】
拍下精彩的照片之后，创新的Galaxy AI编辑工具可对照片进行清除、重新构图和重录等编辑。借助Galaxy AI，智能修图建议功能可以针对每一张照片给出最适合的调整建议，快捷、高效地美化照片。如果想要发挥创意，以更自由的方式对照片进行调整，基于生成式AI的生成式编辑功能，可以在调整过程当中对照片背景内容进行填充，例如在调整倾斜的画面时，AI可以智能填充画面边缘产生的空白；想要将画面中的某个对象移动至更理想的位置，AI也可在调整之后补全原位产生的空白，生成自然且协调的画面背景。在使用生成式AI技术扩展照片时，Galaxy AI编辑工具会在图片上和元数据中添加水印。如果想要对一段充满动感的视频进行慢动作回放，全新的实时慢动作功能可以根据动作进行补帧，通过平滑的慢动作播放，呈现视频中的更多画面细节。
【智能修图建议】
三星Galaxy S24系列支持Super HDR，在按下快门之前，即可提供真实自然的预览，确保在影像创作的每一个阶段都能获得始终如一的惊艳画面观感。作为手机的重要功能之一，照片拍摄为我们记录美好时光，而与世界分享这些美好片段同样意义非凡。在浏览相册当中的照片时，也可通过分析图片的高光区域，并以Super HDR效果显示，呈现更加真实自然的亮度、色彩范围和对比度。
以强劲性能成就Galaxy智能体验
随着人工智能在日常生活中扮演的角色日益重要，人们对手机性能的要求也在不断提升。三星Galaxy S24系列对芯片组 和显示屏等部件进行了全新升级，无论是畅玩游戏、录制和编辑大型视频，还是规划旅行时跳转于五个应用程序之间，都能获得流畅的使用体验。三星Galaxy S24 Ultra搭载第三代骁龙8移动平台（for Galaxy） ，提供Galaxy用户专属的优化体验。该芯片组可显著提升NPU性能，实现卓越、高效的AI处理能力。此外，三款Galaxy S24机型均支持1-120Hz自适应刷新率，可进一步提升能效表现。
为了提供更为强劲的游戏性能，三星Galaxy S24系列对软件和硬件进行了全面升级。三星Galaxy S24 Ultra采用了优化的散热控制系统，VC均热板 大到1.9倍，在游戏过程中可有效降低设备表面温度，提供更为持久的高性能输出。光线追踪技术可以让游戏中的阴影和反射等照明效果更加逼真，营造出栩栩如生的视觉体验。通过与业界领先的游戏厂商合作，三星Galaxy S24系列还将为全球热门手游提供更进一步的体验优化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/045adfb32c85d9ec004996eabcbf3665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56723da4c8f9323c6ce3e155358404ce/" rel="bookmark">
			重新定义智能汽车：比亚迪发布整车智能战略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伴随着生成式AI与大模型等新兴人工智能技术的飞速发展，智能汽车也开启了新一轮的重大变革。
1月16日，2024比亚迪梦想日正式举办。比亚迪在梦想日上重磅发布了新能源汽车智能化发展全新战略——整车智能，向外界充分展现了比亚迪的智能化实力及未来战略布局，同时也为全球汽车工业的智能化变革注入了新的动力，引领了汽车行业智能化发展新方向。
比亚迪整车智能战略战略的核心，是推出了行业首个智电融合的智能化架构——璇玑架构。通过璇玑智能化架构，比亚迪不但实现了电动化与智能化的高效融合，而且打破了不同系统间的壁垒，用整车智能让驾乘变得更安全、更高效、更个性，从而大幅提升用户的安全性和舒适性。璇玑架构的发布，标志着比亚迪在智能汽车领域又一次实现了重大技术突破。
据介绍，璇玑架构由“一脑、两端、三网、四链”组成，构建了一个全面感知、集中思考、精准控制和协同执行的智能化系统。璇玑架构的重要价值和意义，就在于赋予了汽车智能化的“大脑”和“神经网络”，从而使得智能汽车能够像高智慧的生命体一样智能地感知周围环境、集中思考、精准控制和协同执行。可以说璇玑架构的诞生，重新定义了真正的智能汽车。
“一脑”指的是智能化的大脑，即中央计算平台。它集成了车辆控制、智能驾驶、智能座舱等多个功能模块，实现了各系统的深度整合和高效协同。
“两端”指的是智能化的感知端和执行端，通过先进的传感器、执行器和底盘控制系统等，实现对车辆自身状态和周围环境的全面感知和精准控制。
“三网”指的是智能化的能源网、交通网和信息网。能源网通过智能充电、智能储能等方式，实现了对能源的高效管理和利用；交通网通过智能导航、自动驾驶等技术，提升了交通效率和安全性；信息网则通过车联网、云计算等技术，实现了信息的实时交互和共享。
“四链”指的是智能化的供应链、生产链、服务链和回收链。通过智能化管理和运营，实现了全链条的高效协同和优化。
与此同时，比亚迪还推出了行业首创的双循环多模态AI——璇玑AI大模型，首次将人工智能应用到车辆全领域。作为国内首个针对整车智能化的AI大模型，它不但拥有业界最庞大的数据底座、行业领先的样本量和高算力，覆盖了整车三百多个场景，而且能够根据不同场景和需求自动学习和适应，不断优化和提升车辆的智能化性能，赋予了整车智能持续进化的能力。毋庸置疑的是，这一创新技术将为比亚迪的智能汽车带来更高效、更安全、更便捷的驾乘体验。
“整车智能，才是真智能。”在2024比亚迪梦想日现场，比亚迪集团董事长兼总裁王传福表示，“随着智能化时代的到来，汽车不再仅仅是一种出行工具，而是一种智能化的生活平台。我们相信，璇玑架构的发布将为全球消费者带来更先进、更智能的汽车产品和服务。我们也将不断探索和创新，为全球汽车工业的智能化变革贡献力量。”
值得一提的是，比亚迪还在梦想日上宣布，将投入50亿建设全球首批全地形专业赛车场，构建新能源时代的汽车文化，推动中国汽车文化蓬勃发展，走向世界。
此外在2024梦想日期间，比亚迪还举办了涵盖整车智能、智能驾驶、智能泊车、智能座舱等多个领域的大型智能化体验展，包括易四方概念车、易四方泊车、手掌钥匙、车载无人机、“天神之眼”高阶智能驾驶辅助系统、全场景车载卫星通信等多项展示，都让众多观众目不暇接，叹为观止。
放眼未来，随着5G通信、人工智能等技术的不断发展，智能汽车也将成为人们出行的主要选择之一。作为国内领先的电动汽车制造商，比亚迪一直致力于推动汽车工业的智能化变革。通过持续的研发投入和技术创新，比亚迪已经拥有了完整的电动汽车产业链和强大的自主研发能力。而璇玑架构的发布，将为智能汽车的研发和应用提供强大的技术支持，同时也将进一步增强比亚迪在智能汽车领域的竞争力。我们有理由相信，在不久的将来，智能汽车将会成为道路出行的主流，为广大用户带来更安全、更舒适、更便捷的出行体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/383e08748fa33737048ee19ccd0b8715/" rel="bookmark">
			三星Galaxy S24 系列了发布会预热新品：Galaxy Ring 智能戒指亮相
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在三星 Galaxy S24 系列发布会上，他们不仅带来了新款手机，还意外地推出了一款智能指环 ——Galaxy Ring！没错，就是戴在手指上的那种智能设备！
在发布会的尾声，三星放出了一段简短的预告片，让我们对 Galaxy Ring 有了一些了解。这款智能指环不仅具备健康追踪功能，还采用了人工智能技术。它的外观就像一个戒指，内侧还装载了许多传感器，非常酷炫！不过具体的售价和上市日期还没有透露。
其实，早在 2023 年，三星就注册了 Galaxy Ring 商标，最近在他们的一款应用中也发现了有关这款设备的信息，所以我们可以确定它将在 2024 年上市。
通过今天的预告，我们可以期待在今年晚些时候，也许是夏季新款折叠手机发布时，会听到更多有关 Galaxy Ring 的消息。非常期待这款智能指环的到来！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02d4d6de2f5e7480a964424899b352c/" rel="bookmark">
			flutter学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter万物皆组件，dart万物皆对象
Flutter 工程目录结构 https://blog.csdn.net/u013491829/article/details/108624331
flutter介绍: 1.跨平台移动UI框架
2.与现有的代码一起工作(可以直接嵌入到原生代码中或直接把原生代码嵌入到自己的代码中运行)
3. 完全免费、开源
flutter优缺点 优点: 1.Flutter在Debug使用JIT编译，支持热重载，能够提高我们的开发效率，而Release中利用AOT直接编译成机器码，能够达到更好的性能,即时编译 (JIT) 或提前编译 (AOT)
2.跨多种平台，减少开发成本；支持插件，可以访问原生系统的调用。
3.有自己的engine引擎,渲染引擎skia和dartVM虚拟机
4.UI一致性 美观：可对 UI 实现像素级的控制，且内置 UI 库 ( Material、Cupertino )
快速：硬件加速图形引擎、代码被编译成机器码
高效：保持应用状态的热重载 ( hot reload )
开放：完全开源的项目 ( BSD 开源协议 )
Flutter之所以渲染效率高，是因为Flutter采用的是增量渲染的机制，判断一个Widget应该被更新重新渲染，是调用的 static bool canUpdate(Widget oldWidget, Widget newWidget) { return oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key; } 缺点： 1.脱离不开原生，开发人员需要具备原生（Android、iOS）基础开发能力；
2.适配问题，开发工具版本升级后，修改量大；
3.原生集成第三方SDK后，兼容性适配是个令人头痛的问题；
4.代码可读性较差，对代码质量和管理要求较高；
5.打包后，apk/ipa要大很多;
6.Flutter packages和Dart packages上第三方sdk繁杂，适配性差，不可乱用；
7.目前几乎没有第三方开发者平台开发Flutter能力的SDK，需要原生去集成；
8.Widget的类型难以选择，糟糕的UI控件API
下列业务场景下，Flutter 明显不占据优势 1.如果你的业务场景是多框架混合开发，那 Flutter 明显不占据优势；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02d4d6de2f5e7480a964424899b352c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b45e942a715af961d225a7848f83a412/" rel="bookmark">
			安全狗荣获“厦门市专精特新中小企业”称号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，厦门市工业和信息化局发布《关于厦门市2023年专精特新中小企业认定和复核企业（第二批）名单的公示》。
作为国内云原生安全领导厂商，安全狗经过申报、初审、复核等严格程序的遴选，通过了“2023厦门市专精特新中小企业”认定。
厦门服云信息科技有限公司（品牌名：安全狗）创办于2013年，是国内领先的云安全服务和解决方案提供商。自成立以来，安全狗致力于提供云安全、（云）数据安全领域相关产品、服务及解决方案。作为国内云工作负载安全（CWPP）领域开拓者、云主机安全SaaS产品的开创者，安全狗依托云工作负载安全、云原生安全（CNAPP）、数据安全治理等技术理念，打造了云安全、安全大数据、数据安全等多条产品线，覆盖了网络安全行业的多个前沿领域，满足不同用户的多种安全需求。
2023年，安全狗正式加入中国网络安全软件领域领跑者亚信安全科技股份有限公司(股票代码: 688225) ，成为其控股子公司。双方的深度融合，实现了云安全技术能力的全面覆盖，形成引领业界发展的云安全体系，打造了国内云安全市场领导品牌。
据悉，“专精特新”是指具备专业化、精细化、特色化和创新型特征的中小企业。“专精特新”中小企业以专注铸专长、以配套强产业，以创新赢市场，是中小企业群体中的优秀代表。在此次的认定中，通过对安全狗的经营条件、专业化程度、创新制造能力等多个维度的考察与筛选，最终认可安全狗的自主创新、研发技术等方面的突出能力与水平。
随着我国5G、AI等新兴技术成为社会和各行业发展的重要推动力，网络安全也成为护航各项新兴技术与产业安全融合、必不可少的安全基座。
专注于云安全赛道
Cloud Security
作为国内较早进入云安全赛道的安全厂商，安全狗一直专注在云安全赛道的发展上。依托多年的安全技术积累和敏锐的市场把握，安全狗先后打造了云安全、（云）安全数据等多条产品线，在符合网络安全发展趋势的基础上，为包括国家部委、地方政府、央企、国企、世界500强、独角兽企业等在内的上百家大型客户以及数千家中小企业客户，涵盖了能源、金融、教育、医疗、互联网、电信运营商等多个行业提供了满足安全需求的系列安全产品、解决方案与服务，为众多用户数字经济转型提供重要的安全支撑。
重视技术创新发展
Technological Innovation
除了专注在安全赛道上的发展外，安全狗也十分重视技术创新能力的提升。从云工作负载到云原生安全防护能力打造，安全狗在提供全面的云安全防护基础上，也从用户的角度出发，不断降低安全产品对用户业务系统的资源占用率，以“N合1”安全大基座保障用户的业务安全且稳定地运行。随着云原生技术的发展，安全产品堆叠使用的趋势越发明显，安全狗适时地提出云原生安全2.X的理念，通过打造一体化全栈云原生安全方案，让用户安全运维工作事半功倍，更加安全地拥抱云原生技术。
值得关注的是，在此前安全狗也相继获得“国家级高新技术企业”、“福建省科技小巨人领军企业”、“福建省数字经济领域未来‘独角兽’创新企业”等称号，整体综合实力备受国家肯定。
未来，安全狗将依托自身多年的安全技术基础，持续整合&amp;优化自身的安全能力与水平，不断打磨产品，提升服务水平，为用户提供更加优质、更加全面的云安全、（云）数据安全等多个领域的安全产品与服务，积极发挥云安全生态影响力，为广大用户数字经济转型持续护航，为我国的网络强国发展做贡献。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a5b8e9c20b6651b305b3bc3c3476a9/" rel="bookmark">
			Android Studi安卓读写NDEF智能海报源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本示例使用的发卡器：https://item.taobao.com/item.htm?id=615391857885&amp;spm=a1z10.5-c.w4002-21818769070.11.1f60789ey1EsPH
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="3dp" tools:context=".NdefURLActivity"&gt; &lt;androidx.appcompat.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="30dp" android:background="?attr/colorPrimary" app:navigationIcon="@drawable/baseline_arrow_back_ios_24" app:titleTextColor="@color/white" tools:ignore="MissingConstraints" tools:layout_editor_absoluteY="0dp"&gt; &lt;TextView android:id="@+id/TextViewlabelDispleft" android:layout_width="wrap_content" android:layout_height="match_parent" android:text="返回" android:textColor="@color/white" android:textSize="16sp" android:gravity="center" android:onClick="retmain" /&gt; &lt;TextView android:id="@+id/TextViewlabelDisp" android:layout_width="match_parent" android:layout_height="match_parent" android:text="NDEF_URL " android:textColor="@color/white" android:textSize="16sp" android:gravity="center_horizontal|right|center" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="@+id/TextViewlabelDispleft" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;/androidx.appcompat.widget.Toolbar&gt; &lt;TextView android:id="@+id/sample_text" android:layout_width="fill_parent" android:layout_height="150dp" android:padding="3dp" android:text="操作结果" android:textSize="12sp" android:background="@drawable/shape4border" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintBottom_toBottomOf="parent" /&gt; &lt;ScrollView android:id="@+id/scrollViewIC" android:layout_width="fill_parent" android:layout_height="0dp" android:layout_marginBottom="5dp" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintTop_toBottomOf="@+id/toolbar" app:layout_constraintBottom_toTopOf="@+id/sample_text" android:scrollbars="horizontal" &gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width="match_parent" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1a5b8e9c20b6651b305b3bc3c3476a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88507189b4ddf2df2edafd028de7b15/" rel="bookmark">
			软件测评中心▏正式验收测试和非正式验收的优缺点简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件正式验收测试需要非常严格的管理，是对系统测试的延续，这种验收测试的测试用例应是系统测试的子集。非正式验收测试不像正式验收测试那么严格，不需要执行指定的测试用例，可以由测试人员自主决定，但制定测试用例时必须根据项目的实际情况约束需要测试的主要功能。
正式验收测试和非正式验收测试各有优缺点。
1、正式验收测试的优缺点：
优点：具有较高的正式性和规范性，测试过程更有条理、更能掌握整体进度。由独立的测试团队或第三方机构进行，具有较高的客观性和中立性。能够深入评估软件的性能、安全性等重要指标，确保软件的质量达到用户的需求。
缺点：通常需要投入较多的人力、时间和资源。往往是软件开发过程中的最后一道防线，一旦发现问题，可能需要回到开发阶段进行修改，增加了项目进度和成本的风险。
2、非正式验收测试的优缺点：
优点：有助于在软件开发早期发现和解决一些基本问题，提前提高软件的质量。能够加强软件开发团队的沟通和协作，提升工作效率。
缺点：相对较为灵活，可能存在测试结果的不一致性和主观性。不能深入评估软件的性能、安全性等指标，可能无法发现一些潜在的问题。
综上所述，正式验收测试和非正式验收测试各有特点，可以根据项目的需求和进度选择适合的测试方法。对于重要的软件项目，建议进行正式验收测试以确保软件的质量和可靠性;对于一些快速迭代的小型项目，非正式验收测试可以更好地满足需求，并提高开发效率。有测试需求的朋友可以咨询卓码软件测评，具备CMA、CNAS双重认证资质，各种类型全国范围内皆可服务。
文章来源：软件测评中心▏正式验收测试和非正式验收的优缺点简析—卓码软件测评
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c19bf41daf8a9706ec4b6f723a4a8b8/" rel="bookmark">
			ChatGPT Plus续费充值，到账延迟，如何申诉？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT Plus充值总是到账延迟比较严重，一般多是通过充值链接代充值遇到，如果是账号登陆充值，是即时到账。但是有的客户不愿意提供账号密码，遇到延迟到账的情况如何解决呢？客户可按下面操作申诉，可快速到账。
手机进入openai官网，chat.openai.com，登陆个人ChatGPT账号，找到当前账户Your plan，选择“I need help with a billing issue”。
选择“Why is my Plus subscription not appearing”
向下拉，到这一步红圈这里有个消息图标，点它后看到底部3个按钮，这里点中间的图标，是一个机器人自动回复窗口。
此时点“Billing”，等它回复后再点 “I paid for ChatGPTPlus but can’ t access the service”。
到这里就已经申诉成功，接下来等他们人工审核就行了。一般2，3个小时就可以到账号。
注意：必须使用手机操作，电脑端没有机器人回复窗口。
&gt;&gt;&gt; 更多ChatGPT常见问题：常见问题 – Ving 博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80c50e66d5dcdd74578c9c47b5656084/" rel="bookmark">
			自然语言处理的发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然语言处理的发展 自然语言处理（NLP）是人工智能领域中一门研究如何使计算机理解和生成人类语言的学科。近年来，随着深度学习和大数据技术的突破，NLP 取得了显著的进步，为许多领域带来了革命性的变革。
一、技术进步
在NLP的发展中，关键技术的突破起到了至关重要的作用。其中，词嵌入、循环神经网络（RNN）、Transformer和注意力机制等是近年来NLP领域的明星技术。
词嵌入是一种将词汇映射到固定维度的向量空间中的技术，它使得计算机能够理解和比较词汇间的语义关系。RNN和Transformer是两种深度学习架构，它们能够处理序列数据并捕捉时序依赖性，从而在诸如机器翻译和文本生成等任务中取得了显著效果。而注意力机制则让模型能够聚焦于输入序列中与当前处理步骤最相关的部分，进一步提高了模型的性能。
二、应用场景
随着NLP技术的不断进步，其应用场景也日益广泛。智能客服、语音助手、机器翻译、情感分析、智能写作等都是NLP技术的重要应用领域。这些应用不仅改变了人们的生活和工作方式，还为企业和机构提供了更高效、智能的解决方案。
三、挑战与前景
然而，NLP技术仍面临诸多挑战，如数据稀疏性、语义歧义性、语言特异性和可解释性等。未来的发展趋势和前景包括多模态融合（结合多种媒体数据）、预训练语言模型（如GPT系列）、知识图谱（构建结构化的知识库）等。这些技术的发展将进一步推动NLP领域的进步，使得机器能够更好地理解人类语言。
四、伦理和社会影响
随着NLP技术的广泛应用，也引发了一系列伦理和社会问题，如隐私保护、信息泄露、机器人权利和人工智能的社会责任等。为了应对这些挑战，需要采取相应的策略和措施，如加强数据隐私保护、制定相关法律法规和伦理规范等。同时，应积极开展公众教育和讨论，让更多人了解并参与到这一议题中来。
五、实践经验
在实际应用NLP技术时，开发者需要掌握一些实践经验。例如，模型调参、特征选择、数据清洗等都是影响模型性能的关键因素。此外，如何评估模型的性能和效果也是一项重要任务。常用的评估指标包括准确率、召回率和F1分数等。同时，为了提高模型的泛化能力，可以使用交叉验证等技术。在部署模型时，还需要考虑模型的可扩展性和可解释性等问题。
总之，自然语言处理的发展是一个充满挑战和机遇的领域。通过不断的技术创新和应用探索，我们有望实现更为智能、高效的人类语言处理系统，为人类社会带来更多便利和价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/273900a362bc70d448750b12ab75576e/" rel="bookmark">
			java long date相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 日期转成long类型
import java.util.Date; public class DateToLong { public static void main(String[] args) { // 创建一个Date对象 Date date = new Date(); // 将日期转换为长整型 long longValue = date.getTime(); // 输出结果 System.out.println("Date to long: " + longValue); } } java.time包中的LocalDate类来创建一个默认日期
import java.time.LocalDate; public class DefaultDate { public static void main(String[] args) { // 创建一个默认日期 LocalDate defaultDate = LocalDate.now(); // 输出默认日期 System.out.println("Default date: " + defaultDate); // 设置默认日期为2023年6月24日 LocalDate defaultDate = LocalDate.of(2023, 6, 24); // 输出默认日期 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/273900a362bc70d448750b12ab75576e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4eaacb4a5264d733c8ba3c2bd7976c0/" rel="bookmark">
			【Python3】【力扣题】392. 判断子序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【力扣题】题目描述： 【Python3】代码： 1、解题思路：遍历字符串s，使用一个列表依次记录在字符串t中的位置，若没有该字母则返回False，若索引号小于上一个字母的索引号，返回False。否则返回True。
知识点：[ ]：创建新列表。相当于 list()。
字符串.find(...)：在字符串中查找某元素，返回索引号，没有返回-1。
列表[-1]：获取列表中最后一个元素。
列表.append(...)：往列表尾部添加一个元素。
class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: alist = [] i = -1 for x in s: i = t.find(x,i+1) if i == -1: return False if alist and i &lt;= alist[-1]: return False alist.append(i) return True 也可以用两个队列分别记录字符串s和t，遍历字符串s，依次从t的队列队头移除一个元素，若与s的字母相同，s的队列队头移除该元素，最终s的队列没有元素，则返回True，否则返回False。
知识点：collections.deque(...)：双端队列。左端进，右端出。也可以右端进，左端出。
队列.popleft()：从队列的队头（左端）移除一个元素，并返回该元素。
class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: from collections import deque sdeque, tdeque = deque(s), deque(t) for x in s: while tdeque: if x == tdeque.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4eaacb4a5264d733c8ba3c2bd7976c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58be75961027148d68eb2dfc947032ce/" rel="bookmark">
			机器学习：holdout法（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import pandas as pd import numpy as np from sklearn.preprocessing import LabelEncoder, StandardScaler # 类别标签编码，标准化处理 from sklearn.decomposition import PCA # 主成分分析 import matplotlib.pyplot as plt from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.metrics import classification_report, accuracy_score # 分类报告，正确率 wdbc = pd.read_csv("breast+cancer+wisconsin+diagnostic/wdbc.data", header=None) X, y = wdbc.loc[:, 2:].values, wdbc.loc[:, 1] # 提取特征数据和样本标签集 X = StandardScaler().fit_transform(X) # 对样本特征数据进行标准化 lab_en = LabelEncoder() # 对目标值进行编码，创建对象 y = lab_en.fit_transform(y) # 拟合和转换 lab_en.classes_, lab_en.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58be75961027148d68eb2dfc947032ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c5b8246fabcec4eb12895d962b4816/" rel="bookmark">
			k8s的对外服务ingress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、service的作用体现在两个方面 （1）集群内部：不断跟踪pod的变化，更新deployment中的pod对象，基于pod的ip地址不断变化的一种服务发现机制 （2）集群外部：类似于负载均衡器，把流量ip+端口，不涉及转发url（http/https），把请求转发到pod当中 2、service nodeport
容器端口——service端口——nodeport
设定了nodeport，每个节点都会有一个端口被打开（30000-32767）
ip+端口：节点ip+30000-32767，实现负载均衡
loadbalancer
云平台上的一种service服务，云平台提供负载均衡ip地址
extrenal
域名映射
3、ingress：基于域名进行映射，把url（http/https）请求转发到service，再由service把请求转发到每个pod ①ingress：只要一个或者少量的公网ip/LB，可以把多个http请求暴露到外网，七层反向代理 ②ingress：是service的service，是一组基于域名和url路径，把一个或者多个请求转发到service的规则 ④先是七层代理（ingress）——再是四层代理（server）——pod（nginx） 4、ingress的组成 （1）ingress是一个api对象，通过yaml文件来进行配置
（2）ingress的作用：定义请求如何转发到service的规则，配置模版
（3）ingress通过http和https暴露集群内部的service，给service提供一个外部的url、负载均衡、ssl/tls（https）的能力，实现基于域名的负载均衡
ingress-controller
①具体的实现反向代理和负载均衡的程序，对ingress定义的规则进行解析，根据ingress的配置规则进行请求的转发
②ingress-controller不是k8s自带的组件功能，ingress-controller是一个统称
③ingress-controller：nginx ingress controller、traefik（开源）
④ingress-controller的运行方式：pod形式运行在节点上
5、ingress资源的定义项 （1）定义外部流量的路由规则 （2）定义服务的暴露方式：主机名、访问的路径（url）和其他的选项 （3）负载均衡（ingress-controller实现） 6、下载nginx ingress controller wget https://gitee.com/mirrors/ingress-nginx/raw/nginx-0.30.0/deploy/static/mandatory.yaml 7、ingress暴露服务的方式 （1）deployment+LoadBalance模式，ingress部署在公有云 ①ingress的配置文件里面会有一个type，type键值对形式type:LoadBalance ②公有云平台会为LoadBalance的service创建一个负载均衡器，绑定一个公网地址，通过域名指向这个公网地址，就可以实现集群对外暴露 （2）daemonSet+hostnetwork+nodeselector（七层代理upstream） ①daemonset：在每个节点都会创建一个pod ②hostnetwork：pod共享节点主机的网络命名空间，pod中的容器直接使用节点主机的ip+端口，pod中的容器可以直接访问主机上的网络资源 ③nodeselector：根据标签选择部署的节点，nginx-ingress-controller部署的节点 缺点：直接利用节点主机的网络和端口，一个node只能部署一个ingress-controller的pod，适合大并发的生产环境
优点：性能最好
（3）deployment+NodePort（七层+四层） 8、部署daemonSet+hostnetwork+nodeselector （1）修改配置文件mandatory.yaml （2）每个节点上传控制器的镜像 tar -xf ingree.contro-0.30.0.tar.gz docker load -i ingree.contro-0.30.0.tar （3）节点设置标签 kubectl label nodes node2 ingress=true netstat -antp | grep nginx 8181端口：nginx-controller默认配置的一个bachend，反向代理的端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2c5b8246fabcec4eb12895d962b4816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a31ee0105c2a355dd7d30cb197aae68/" rel="bookmark">
			AI嵌入式K210项目（14）-TF卡读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、TF卡介绍二、K210的SPI接口实验过程总结 前言 本章介绍一些读取TF卡的方法，本章内容和前面的项目非常类似，都是采用了SPI接口AI嵌入式K210项目（11）-SPI Flash读写
一、TF卡介绍 TF有4个数据传输端，DAT0，DAT1，DAT2，DAT3。还有一个CMD脚，是用来读取卡内信息的。
TF卡主要管脚的功能：
CLK：时钟信号，每个时钟周期传输一个命令或数据位，频率可在0～25MHz之间变化，TF卡的总线管理器可以不受任何限制的自由产生0～25MHz 的频率；
CMD：双向命令和回复线，命令是主机到从卡操作的开始，命令可以是从主机到单卡寻址，也可以是到所有卡；回复是对之前命令的回答，回复可以来自单 卡或所有卡；
DAT0～3：数据线，数据可以从TF卡传向主机也可以从主机传向TF卡。
TF卡传输数据一般有两种模式，SD模式和SPI模式，这里我们以SPI模式的方式传输数据。SPI模式引脚如下：1：CS，2：DI，3：VSS，4：VDD，5：SCLK，6：VSS2，7：DO，8：RSV，9：RSV。
二、K210的SPI接口 对应的头文件 spi.h
SPI是一种高速、高效率的串行接口技术。通常由一个主模块和一个或多个从模块组成，主模块选择一个从模块进行同步通信，从而完成数据的交换。SPI是一个环形结构，通信时需要至少4根线（事实上在单向传输时3根线也可以），它们是MISO（主设备数据输入）、MOSI（主设备数据输出）、SCLK（时钟）、CS（片选）。
（1）MISO– Master Input Slave Output,主设备数据输入，从设备数据输出；
（2）MOSI– Master Output Slave Input，主设备数据输出，从设备数据输入；
（3）SCLK – Serial Clock，时钟信号，由主设备产生；
（4）CS – Chip Select，从设备使能信号，由主设备控制。当有多个从设备的时候，因为每个从设备上都有一个片选引脚接入到主设备机中，当我们的主设备和某个从设备通信时将需要将从设备对应的片选引脚电平拉低或者是拉高。
为用户提供以下接口：
• spi_init：设置SPI工作模式、多线模式和位宽。
• spi_init_non_standard：多线模式下设置指令长度、地址长度、等待时钟数、指令地址传输模式。
• spi_send_data_standard：SPI标准模式传输数据。
• spi_send_data_standard_dma：SPI标准模式下使用DMA传输数据。
• spi_receive_data_standard：标准模式下接收数据。
• spi_receive_data_standard_dma：标准模式下通过DMA接收数据。
• spi_send_data_multiple：多线模式发送数据。
• spi_send_data_multiple_dma：多线模式使用DMA发送数据。
• spi_receive_data_multiple：多线模式接收数据。
• spi_receive_data_multiple_dma：多线模式通过DMA 接收。
• spi_fill_data_dma：通过DMA 始终发送同一个数据，可以用于刷新数据。
• spi_send_data_normal_dma：通过DMA 发送数据。不用设置指令地址。
• spi_set_clk_rate：设置SPI的时钟频率。
• spi_handle_data_dma：SPI 通过DMA 传输数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a31ee0105c2a355dd7d30cb197aae68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d01805dfcc83afdc4ed4b54704f736/" rel="bookmark">
			el-table实现搜索高亮展示并滚动到元素位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果展示： 代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;style&gt; *{padding: 0;margin: 0;} #app{padding: 30px;} .searchBox{ width: 100%; display: flex; align-items: center; margin: 20px 0; position: fixed; z-index: 9; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div class="searchBox"&gt; &lt;el-input v-model="searchText" style="width:200px;" placeholder="请输入关键字" prefix-icon="el-icon-search" clearable @clear="search" size="small" @keyup.enter.native="search" &gt; &lt;/el-input&gt; &lt;el-button type="primary" size="small" icon="el-icon-search" @click="search" &gt;&lt;/el-button&gt; &lt;/div&gt; &lt;el-table :data="tableData" style="width: 100%;margin-top: 70px;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7d01805dfcc83afdc4ed4b54704f736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc675e0071aa6a4b96f5c43ca8f2428/" rel="bookmark">
			Python实现员工管理系统（Django页面版 ) 八
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello 大家新年好。今天这篇博客是用来填补之前的登录系统的不足所遗留下来的坑点，你们知道的，我有坑是必补啊。
首先我留的第一个坑点不知道大家有没有注意到，当我们没并没有登录的时候，但是如果我们事先知道一些内部测试的网站路由的话，我们可以跳过登录直接进入到里面。
我们可以发现，明明我并没有进行登录，但是如果有人知道我的路由，它就可以直接进来，这肯定是不允许的，因此我要引用一个新的内容-------session与cookie
Cookie是由服务器发送给浏览器的小型文本文件，存储在用户的计算机上。它包含有关用户的信息，如用户ID、首选项和购物车内容。当用户访问网站时，浏览器会将Cookie发送回服务器，以便服务器可以根据存储在Cookie中的信息来识别用户并提供个性化的服务。
Session是服务器上存储用户会话数据的一种机制。当用户访问网站时，服务器会为每个会话创建一个唯一的ID，并将该ID存储在Cookie中或通过URL参数传递给浏览器。然后，服务器使用该ID来跟踪用户的会话数据，如登录状态、购物车内容等。与Cookie不同，Session数据保存在服务器上，而不是用户的计算机上。
一般来讲，网站都是通过记录你的session和cookie来判断你是否登录过，如果网站记录过你存在的session和cookie记录，那么网站会让你直接进入而不需要再次登录，我们可以利用这个特点来进行判断当前是否存在该用户，如果没有则让其返回登录界面。
login.py
def login(request): if request.method == 'GET': form = LoginForm() return render(request,'login.html',{'form':form}) form = LoginForm(data=request.POST) if form.is_valid(): # 验证码验证 user_input_code = form.cleaned_data.pop('code') # 没有值设置为空 code = request.session.get('image_code','') # 对于验证码不区分大小写 if user_input_code.upper() != code.upper(): form.add_error('code','验证码错误') return render(request,'login.html',{'form':form}) # 账号密码验证，数据库校验 admin_object = models.Admin.objects.filter(**form.cleaned_data).first() if not admin_object: # print(form.cleaned_data) form.add_error('password','用户名或者密码错误') return render(request,'login.html',{'form':form}) # 生成字符串存储到cookie和session当中去 info = { 'id':admin_object.id, 'name':admin_object.username, 'role':admin_object.role } request.session['info'] = info # 时效性 ------ 一个点 request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc675e0071aa6a4b96f5c43ca8f2428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e0c965d4ad7ff88beb5605e24ddd39/" rel="bookmark">
			CentOS 7 迁移到 阿里Anolis OS 7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7 迁移到 阿里Anolis OS 7 #下载yum wget https://mirrors.openanolis.cn/anolis/migration/anolis-migration.repo -O /etc/yum.repos.d/anolis-migration.repo #安装迁移工具centos2anolis yum -y install centos2anolis #迁移系统 centos2anolis.py #重启系统 sync init 6 #查看版本 cat /etc/os-release 官网文档地址:https://openanolis.cn/sig/migration/doc/774227117744169523
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c55142097b7ab8ff8a60c384c4fc46e/" rel="bookmark">
			「AI搞钱术大揭秘！」2024年了！AI多干一点自己多赚一点！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在AI时代下，各个产业都正在发生着巨大的变化，这些变化给我们带来了很多机会和挑战。例如，AI技术正在改变金融行业的运营模式，风险控制和交易决策方面，银行和投资公司正在使用AI算法来提高效率和准确性；AI技术正在改变零售业务中的销售和推广方式，许多企业正在使用AI算法来预测消费者需求和购买行为，并根据这些数据制定营销策略；AI技术正在帮助制造业实现自动化生产和智能化管理，许多工厂正在通过AI技术来监测生产流程，优化设备维护和节约成本；AI技术正在改变医疗保健行业中的医疗服务和疾病诊断方式，医院正在使用AI技术来分析医学图像和识别疾病。AI技术正在改变农业生产和管理方式，农民可以利用AI技术来监测土壤和作物状态，以及制定最佳的农业管理策略；一个拥有AI技术的电商平台，可以通过精准推荐和个性化服务吸引更多的消费者，从而增加销售额和盈利能力。
在这个时代里，利用AI帮我们赚钱变得愈发重要。AI技术正在帮助企业更好地理解市场需求、提高生产效率、优化资源分配、改善用户体验等等。通过利用AI技术，我们能够更加精确地抓住商机、提供更优质的产品和服务，从而在竞争激烈的市场中获得更多的商业成功和利润。**总之，AI不仅是一种技术，也是一种财富的创造力！**下面我们来看看最近爆火的AI变现方式！
GPTs
GPTs是OpenAI于2023年11月发布的新版本，可以看作是ChatGPT的个性化定制版本。它允许用户根据特定任务或主题自定义指令、知识和功能。而GPT Store是一个平台，用户可以发布和访问GPTs，被称为大型模型领域的"应用商店"。在官方GPT Store推出之前，已经有很多民间网站在进行类似的工作，如GPTs Hunter、All GPTs等。它们的工作是集中收集现有的GPTs，并让用户在网站内进行搜索。
GPTs是一个在线内容交易平台，它让创作者能够出售使用GPTS生成的各种文本内容，为其提供更好的报酬机会。购买者则可以在平台上浏览并购买优质的内容。 这个去中心化的市场为创作者和购买者提供了更好的体验，同时为GPTS生成的内容创造了新的销售渠道。GPT技术的迅猛发展确实令人惊叹，各种应用层出不穷！有的可以助你绘图，有的能够为你提供写作支持，还有一些可用于学术研究。这犹如科技界的"大航海时代"一般！
更为惊人的是，只要你富有创意和想法，制作一个GPT应用就如同在超市购物一样简单。无需编程技术，你就能轻松实现各种创意！现在，每个人都有可能成为GPT应用的创作者，这不仅是一次风口，更是普通人在科技潮流中分享红利的机会。我们终于有机会在科技的巨浪中找到属于自己的位置！这真是让人兴奋不已！
比如我想做个生成公众号文章封面配图的应用。我就写我的需求，比如说用户发一个公众号的主题及需在图片中呈现的内容，该应用就能按照用户的要求生成一张公众号文章封面图。然后，就像发微信那样，一点“发送”给GPTs，结果呢，不到一分钟，这个小应用就活灵活现的出现在我面前了！
AI克隆人
2024年初，国内AI领域迎来了一则令人瞩目的重大消息！小冰公司在1月4日宣布，他们成功获得了国内备案的“小冰大模型”。这一消息标志着国内大模型发展进入全新阶段。这一消息无疑将对整个行业产生深远影响，小冰公司有望成为行业中的重要角色。
值得一提的是，小冰公司于2023年5月启动了GPT克隆人计划，计划推出一系列测试产品并正式发布，包括小冰克隆人、歌手克隆人分支以及小冰数字员工等。此外，小冰X Eva APP已经吸引了超过80万名创作者克隆自己，并向他们的粉丝私域发布内容。据统计，在这些创作者中，有超过1000人是全网50万粉丝以上的大V和网红，创作者本人的全网粉丝总量甚至超过了7亿人。小冰X Eva APP已成为全球最大的AI C2C私域平台之一。
通过克隆人平台，一些头****部大V和网红的月收入已突破十万元以上，这意味着他们在实现个人百万年收入的道路上迈出了成功的一步，商业化验证初见成果！ X Eva APP里面已经内置了许多知名网络红人的克隆人，如半藏森林、美芽、Maymay 等。点进半藏森林的克隆人页面，有作为半藏森林的 AI 自己生成并发送的图文朋友圈，朋友圈的风格与半藏森林微博的图文风格和内容基本一致，内容非常生活化，不仅口语化表达还有符合场景且符合半藏森林个性的配图。
想要变成明星红人吗？现在，你的愿望就能实现！小冰公司最新推出的“克隆人计划”让一切成为可能！只需三分钟，采集你的数据，即可创造一个真实的你的AI克隆人——性格、技能、声音、外貌，无所不包！
无论你是专家学者或是日常百姓，你的克隆人都能成为你的分身，帮你开辟新的收入渠道！在小冰提供的专属平台上，你可以选择将你的AI克隆人分享给粉丝，提供咨询、娱乐或教育内容，无论有偿或无偿，这都是21世纪的全新经济模式！
想象一下，当你忙于其他事务时，你的AI克隆人依旧可以代表你与粉丝互动，分享专业知识，甚至在虚拟世界中增强你的个人品牌！这是创新科技给予我们的超级能力，让每个人都有机会成为影响力领袖！
抓住这个前所未有的机遇，小冰公司的克隆人计划让你的影响力和财富势不可挡！
AI绘画变现
你不会相信！零基础也能成为艺术家？现在只需要一句话，MJ工具带你穿梭在光影之间，描绘出只属于你的独特艺术品！赶快体验赚钱的乐趣！ 无需专业知识，也不需要PS，只需动动手指，输入你的创意，MJ工具就能帮你获得额外收入！
下图就是用AI工具：Midjourney制作的！只需要输入一句话：
一个女孩的脸部特写，她的眼睛反映出一个流星的形象。这种风格模仿了波琳娜·华盛顿的风格，利用光线和阴影创造了一个梦幻般的场景。以8K渲染以获得精细细节–ar 3:4-s 750–v 5.2。
那么AI绘图能如何赚钱呢？现在有很多：壁纸变现小程序，只需要将AI绘制的图片，上传上去，你就可以躺赚了！
不仅如此，还有很多关于AI绘画赚钱的方法的创意想法！如果你有更好的创意，快快行动！
1.网店店主：Midjourney AI设计师可以在网络平台上开设自己的店铺，提供基于AI设计的产品，吸引更多客户。
2.广告设计：Midjourney AI设计师可以利用自身的快速设计优势，为企业设计广告图片和宣传画面，赚取设计费用。
3.利用AI绘画技术创作数字艺术作品，并在数字艺术市场上进行销售和推广，从中获取利润。
4.开设AI绘画课程，向有兴趣的人传授技能，从中赚取收益。
5.利用AI绘画技术制作个性化的贺卡、明信片或纪念品，并销售给有需要的人。
6.利用AI绘画技术创作与自然风景、城市建筑等相关的艺术作品，并在旅游景点销售。
7.利用AI绘画技术创作个性化的头像、头像框等，为社交媒体用户提供服务。
8.利用AI绘画技术创作可印制在服装、包包等上的图案，并销售给有需要的人。
9.将AI绘画技术应用于建筑和城市规划，创作城市景观设计、建筑外观设计等，为城市规划和建筑公司提供服务。
10.利用AI绘画技术为公司和品牌创建独特的视觉形象和标识，从而提升品牌形象和市场竞争力。
11.利用AI绘画技术制作定制的插图或漫画，出售给出版社或个人。
12.利用AI绘画技术为个人客户进行定制绘画服务，例如为客户的家居、办公室或婚礼创作个性化的艺术作品。
13.利用AI绘画技术为艺术家和设计师提供创作工具和平台，使他们能够更快速、高效地进行创作。
14.利用AI绘画技术为教育机构和培训机构提供教学资源和课程，帮助学生和职业人士学习和应用AI绘画技术。
15.利用AI绘画技术制作独特的产品包装设计，吸引消费者的注意。
总之，AI设计师可以通过与珠宝企业合作、在网络平台上开设店铺、提供广告设计服务、以及为珠宝制造商提供3D打印模型等方式，快速赚取收益。这些创意想法可以激励人们发挥创造力，并利用AI绘画技术为自己和他人创造价值。同时，AI绘画技术也为艺术家、设计师和创意人士提供了一种新的创作方式，为他们提供了更多的创作可能性和商业机会。无论是在艺术领域、设计领域还是商业领域，AI绘画技术都将成为未来的重要趋势，带来无限的创新和发展机会。
看到这里，你心动了吗？！AI已经成为了一个不可逆转的趋势，它将改变我们的生活和工作，也将带来无限的可能性。AI技术已经成为了各行各业不可或缺的一部分，我们更要积极拥抱并利用它来创造更多的商业价值！快快行动起来～
资料分享 如果你对AI技术搞钱、AI绘画变现，chatGPT搞钱，AI写文案 剪视频 做副业、抖音无人直播带货、小红书引流、自媒体运营感兴趣感兴趣，可以下方扫码免费领取一份AI技术入门资料包wx扫描二v码免费领取【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec56c4905b75994082c82580bbeea71d/" rel="bookmark">
			SpringBoot缓存相关注解的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@CacheConfig：主要用于配置该类中会用到的一些共用的缓存配置
@Cacheable：主要方法的返回值将被加入缓存。在查询时，会先从缓存中获取，若不存在才再发起对数据库的访问
@CachePut：主要用于数据新增和修改操作
@CacheEvict：配置于函数上，通常用在删除方法上，用来从缓存中移除相应数据 这些注解通常用于 Spring Framework 中对方法的缓存配置。以下是这些注解的简单使用案例：
@CacheConfig：配置类的缓存公共设置 @CacheConfig(cacheNames = "myCache") public class MyService { // ... } 这里配置了类中方法默认使用名为 "myCache" 的缓存。
@Cacheable：查询方法的返回值将被加入缓存
@Cacheable public String findById(Long id) { // 查询数据库的操作 return "result"; } 查询方法 findById 的返回值将被加入缓存，下次调用该方法时，如果传入的 id 已经在缓存中存在，则直接从缓存中获取，而不是执行方法体。
@CachePut：新增和修改操作
@CachePut public String updateData(Long id, String newData) { // 更新数据库的操作 return newData; } 新增或修改方法 updateData 的返回值将被加入缓存。与 @Cacheable 不同的是，@CachePut 注解会每次都执行方法体，并将结果加入缓存。
@CacheEvict：删除操作
@CacheEvict public void deleteById(Long id) { // 删除数据库中对应 id 的数据 } 删除方法 deleteById 被调用时，会从缓存中移除对应 id 的缓存项。 这些注解可以与缓存管理器一起使用，例如结合 EhCache 或 Redis 等实现具体的缓存操作。在使用这些注解时，通常需要在 Spring 配置文件中配置相应的缓存管理器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d53374ac8094bb55641173ba74c2ced/" rel="bookmark">
			k8s节点node下线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 node节点下线操作流程如下：
1，node节点配置pod不可调度到该节点上。
2，node节点上的服务驱逐。
3，node节点下线。
k8s机器node节点下线 # 配置节点不可调度 kubectl cordon &lt;NODE_NAME&gt; kubectl drain --ignore-daemonsets &lt;NODE_NAME&gt; ## --ignore-daemonsets 选项为忽略DaemonSet类型的pod # 获取node节点上所有的pod名称 kubectl get pod -A -o wide | grep &lt;NODE_NAME&gt; # 删除pod资源，重新调度到其他节点 kubectl delete pod -n &lt;NAMESPACE&gt; &lt;POD_NAME&gt; # 停止node节点的docker,kubelet systemctl stop docker &amp;&amp; systemctl stop kubelet # 删除下线节点 kubectl delete node &lt;NODE_NAME&gt; # 验证已无该node资源 kubectl get node | grep &lt;NODE_NAME&gt; # 验证该node上无pod资源 kubectl get pod -A -o wide | grep &lt;NODE_NAME&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadfc90f57d54c863c291c7ddbafc3cc/" rel="bookmark">
			spring注解参数如何传多个值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以用数组接受值，默认值可以赋值{}
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface TenantCode { UserRole[] skipRoles() default {}; } 使用的时候
// 单个的 @TenantCode(skipRoles = UserRole.warehouse) // 多个的 @TenantCode(skipRoles = {UserRole.warehouse, UserRole.customs}) 切面获取的时候
@Before("tenantCodePointCut()") public void doBefore(JoinPoint point) { MethodSignature signature = (MethodSignature) point.getSignature(); Method method = signature.getMethod(); TenantCode annotation = method.getAnnotation(TenantCode.class); UserRole[] skipRoles = annotation.skipRoles(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cf25f88a049733fa698c62c67c4b06d/" rel="bookmark">
			高光谱分类论文解读分享之Grid Network: 基于各向异性视角下特征提取的高光谱影像分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IEEE GRSL 2023：Grid Network: 基于各向异性视角下特征提取的高光谱影像分类 题目 Grid Network: Feature Extraction in Anisotropic Perspective for Hyperspectral Image Classification
作者 Zhonghao Chen , Student Member, IEEE, Danfeng Hong , Senior Member, IEEE, and Hongmin Gao , Member, IEEE
关键词 Anisotropic, feature fusion, hyperspectral (HS) images, semantic gap, spectral–spatial feature.
研究动机 考虑高光谱影像内部空间和光谱特征各向异性的特性，探索一种区别于现有其他空-谱特征提取方法的新思路
模型 高光谱（HS）图像中嵌入了丰富的光谱特征和空间特征，能够精细地识别土地覆盖，吸引了对特征提取（FE）和特征利用的大量研究。然而，HS立方体中具有高代表性的光谱和空间特征分布不均匀，这是目前许多方法都没有考虑到的。为了克服这一缺点，我们从各向异性的角度重新考虑了HS图像的有限元问题，提出了一种新的网格网络（GNet）的HS图像分类模型（HSIC）模型。除了用三种经典范式（同时、层次和分别）表示光谱空间特征外，GNet还能够在两个新的过程中学习它们：多阶段和多路径。这样，就可以充分和平衡地探索光谱和空间特征。更重要的是，为了充分利用低、高两级特征，避免现有的语义差距，我们设计了一个光谱-空间交叉级特征融合（S2CLF2）模块来建模它们之间的关系。在三个HS数据集上进行的大量实验表明，所提出的GNet非常有效。
亮点 首次从各向异性的角度研究了HS图像特征提取，使得光谱和空间特征可以在多个过程中进行探索，从而使模型能够更自由地提取平衡表示进行分类。在相关信息的指导下融合低级和高级特征，减轻了语义差距的影响。 论文以及代码 论文链接: link
代码链接: link
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2be3b1cf73d0d819aaaaf3d794aeba9/" rel="bookmark">
			2023，用Python送给大家今年的第一场雪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，大家好，我是程序员小八~
2023，已经快要结束了，北方很早就已经下了第一场雪，但是南方却几乎没有下，所以我今天就来分享，如何利用python制作今年的第一场雪
这里我用 pygame 来实现，Python 版本用的是 3.8。下面介绍下实现方法。
首先，执行下面命令安装 pygame
pip install pygame 然后创建一个 Python 源文件，编写以下代码做一些初始化工作
import sys import random import pygame pygame.init() clock = pygame.time.Clock() bg_size = width, height = 1200, 750 screen = pygame.display.set_mode(bg_size) bg = pygame.image.load('bg.jpg') clock 后面会用来设置帧率，bg_size是应用窗口尺寸（宽度和高度），screen是创建的屏幕（应用窗口），可以向其中添加元素。bg是加载的一张图片用来作为窗口的背景图。
要想做一个下雪的效果，其实分两步，第一步是定义雪花，第二步是让雪花动。
1、定义雪花 定义雪花比较简单，我们就用大大小小的圆来代替即可。定义一个圆就需要有圆心、半径，同时在这一步我们也会把移动的距离也定义出来。
编写一个函数用来批量生成圆
def get_snows_circle(pic_num): """ 生成一个数组，返回一些雪花，其中包含雪花在屏幕的位置、半径以及移动的x坐标和y坐标 :param pic_num: 初始化多少片雪花 :return: 包含雪花属性的数组 """ snows = [] for i in range(pic_num): x_pos = random.randint(0, width) # 雪花在屏幕x坐标 y_pos = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2be3b1cf73d0d819aaaaf3d794aeba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7b48e76d7045b04231386d40787fb7/" rel="bookmark">
			在分类任务中准确率（accuracy）、精确率（precision）、召回率（recall）和 F1 分数是常用的性能指标，如何在python中使用呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在机器学习和数据科学中，准确率（accuracy）、精确率（precision）、召回率（recall）和 F1 分数是常用的性能指标，用于评估分类模型的性能。
1. 准确率（Accuracy）： 准确率是模型预测正确的样本数占总样本数的比例。
from sklearn.metrics import accuracy_score y_true = [0, 1, 1, 0, 1, 1] y_pred = [0, 1, 0, 0, 0, 1] accuracy = accuracy_score(y_true, y_pred) print(f"Accuracy: {accuracy}") 2. 精确率（Precision）： 精确率是指在预测为正的样本中，实际为正的比例。它关注的是预测为正的样本中真正为正的比例。
from sklearn.metrics import precision_score precision = precision_score(y_true, y_pred) print(f"Precision: {precision}") 3. 召回率（Recall）： 召回率是指在所有实际为正的样本中，被预测为正的比例。它关注的是实际为正的样本中被正确预测为正的比例。
from sklearn.metrics import recall_score recall = recall_score(y_true, y_pred) print(f"Recall: {recall}") 4. F1 分数： F1 分数是精确率和召回率的调和平均数，它综合了精确率和召回率的信息。
from sklearn.metrics import f1_score f1 = f1_score(y_true, y_pred) print(f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf7b48e76d7045b04231386d40787fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5249dd0fb8a8e1cd88135423d6cb7003/" rel="bookmark">
			Python是垃圾？千万不要再学Python了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“人生苦短，快学Python”这句话，相信大家都有看到过，但是有细心留意过，就会发现Python其实在网上的评价褒贬不一，有好评，也有差评。这就会给那些不懂Python却想要学Python的一些人造成困惑，我到底该不该入门Python。
对于那些在网上不断抨击Python语言，说它是垃圾语言的，对此我也只能说凡事不能看表面，眼见不一定为实，只有深入了解之后，才知道它到底是不是适合你自己。正如世界上不没有完美的人一样，任何编程语言都有它们各自的优势和不足。
关于Python，今天一起来唠一唠，仅供参考。首先咱来简单聊聊Python到底是什么？有什么优势？才会有如此多的争议。
Python是个啥？有什么优势？ 其实Python就是一种计算机编程语言。
对于“编程”，你可能或多或少听说过Java/C语言/C++ /PHP等语言，Python作为近几年特别火的一门编程语言，相较前面几种语言，更注重可读性和效率。
因此，Python对于注重开发效率的程序员来说是大受欢迎的，他们给Python的定位是“优雅”、“明确”、“简单”。
除此之外，Python还具有以下优势，获得人们的青睐：
Python 易于学习——Python程序简单易懂，初学者只要识字、会简单的算术、看懂英文单词就能入门学习。因此很多小学生从小就开始通过学习python来培养编程思维。
少量的代码就能构建出很多功能—— 在Python中，几乎每个想法都可以通过20-30行代码快速验证。
Python 拥有最成熟的程序包资源库之一——Python有满足不同需求的库，无论实现什么功能，都有现成的类库可以使用。
Python 是人工智能/现代数据科学中最常使用的语言——Python应用领域广泛（如图），尤其是人工智能/大数据时代不可或缺的技能。
为什么要学Python？ 互联网的快速发展，使数据成为了当今社会重要的战略资源。掌握了数据，就可以提前做好预判，可以说现在就是数据为王的时代。
而数据都是有时效性的，想要快速收集各种一手数据，就需要动用各种渠道和资源，非常耗时耗力。而Python恰好就能解决这个问题，在数据收集处理上，python绝对是一个好的工具。
就连房地产大佬都曾公开表示，他在学Python。甚至认为 Python 是计算机语言里「进化最好的一种」。
既然Python这么好，那怎么样才能学好Python？
下面来给一些老生常谈的建议，虽然看起来老掉牙，但每一个都是真理吧！！！不然为什么老是有人在反复强调。
怎么样学好Python？ 1、明确学习目的
学Python之前要先想好，你学编程的目的是什么！
如果你是出于好奇，或者只是想拓展下技能，学个乐，比如做个2048小游戏把两个王冰冰合成一个王冰冰，把excel的数据画成好看的图，做个爬虫爬一下公司附近租房子哪里便宜，那你可以快乐入局。
2、安装Python
现在看起来到了专业领域，不要怕！你的操作非常简单！
点开Python官网，直接下载就行。So easy，妈妈再也不担心我学习了！
3、还是不会的就查
学习初期难免遇到很多问题。书上的代码白纸黑字，一抄过来却满屏飘红。一串异常码新手又根本看不懂，非常头大。
但是，计算机科学是一门有传承的科学！你新手入门遇到的问题，前人基本都遇到过。这时只要把你的问题打到Google、Stackoverflow，你会发现早就有人提过这个问题，并且早就有大神将其解决了。
如果你幸运地遇到了前人未曾遇过的问题，那说明你已经走在学科前沿了，发paper的时候记得给我署个致谢…
4、要不耻上问
想要解决Python学习中的问题，除了上网搜索，你还可以求助大佬，大佬能让你少走很多弯路。比如之前我的Python死活连不上服务器，断点调试、改config配置全都没用，只能求助大佬。
大佬一眼就看出了问题的症结所在：学校昨晚停电了，服务器关机了，当然连不上。这就是有个大佬朋友的重要性啊！
5、注意规范性
良好的编程习惯要从头抓起。规范的码子大方优美，人人看了都说清爽，关键是方便大佬给你改bug！
新手尤其要注意变量命名。比如一个温度的转换，可以用驼峰命名法将温度变量定为TempConvert；也可以加下划线变成temp_convert。但你整个拼音首字母WD，转头就忘了是温度还是完蛋
6、心态要稳定
不要畏难。很多人看到英文页面就头大，但其实Python一共就33个保留字，无非是and/if/in啥的，所有程序都利用这33个词构建，比初中单词表还简单！英语不好也能学！
7、实践出真知
不管学习什么，具体项目实践都是进步最快的方法。不要只是看书看视频，而要保持动手写代码的状态，尝试用已有知识解决问题，你才能更快地熟悉这门语言。
比如帮室友扒一次图，你的爬虫就精通了；帮老板做个项目，你的数据处理就精通了；给对象写一个大头贴2048，你的游戏就精通了。没有对象的就别做游戏了…
关于Python的技术储备 如果你是准备学习Python或者正在学习，下面这些你应该能用得上：
① Python所有方向的学习路线图，清楚各个方向要学什么东西
② 100多节Python课程视频，涵盖必备基础、爬虫和数据分析
③ 100多个Python实战案例，学习不再是只会理论
④ 华为出品独家Python漫画教程，手机也能学习
⑤历年互联网企业Python面试真题,复习时非常方便
文末有领取方式哦
一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python课程视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
三、Python实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
四、Python漫画教程 用通俗易懂的漫画，来教你学习Python，让你更容易记住，并且不会枯燥乏味。
五、互联网企业面试真题 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5249dd0fb8a8e1cd88135423d6cb7003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e97035ea303e9933edde4720b2cd2e2/" rel="bookmark">
			月入不过万上班族不能错过的搞钱AI神器，文案、动画、设计全都有！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用AI搞钱真的太香啦，不管是文案、动画、漫画还是设计、卡通等AI啥都能搞，关键还有个巨巨省钱神器被我发现了，不仅能搞钱还省钱，每月多攒八千、1w真的一点都不是问题，我不允许还有人不知道这几个个神器！
iThinkScene
一句话生成图文带货
一个综合性AI平台网站，可以一句话生成视频脚本、口播文案，不满意也可润色重写。拥有专门的“小红书运营”模块，不仅能自动生成文案、标题、简介，还可以生成图文、自动排版，检测违规词等。这个工具几乎可以承包小红书运营的所有工作且操作简单，有许多专为小红书量身定制的写作场景，无需自己训练模型真的非常省心，包含了AI工具导航站、AI聊天助手自动写作等功能，对于想要通过小红书赚钱的小伙伴来说只用这一个工具就足够了。
Kaiber
文字、图片生成动画视频
为艺术家提供灵感，为创作者提供内容，为爱好者提供乐趣，让任何人都能轻松表达自己的愿景并释放他们的想象力。它拥有丰富多样的动画模板和强大的编辑功能，可以根据提示词、图片、原始视频生成超级酷炫的视频内容，在几分钟内就能创建出令人惊叹的动画作品，画面质量不错且风格选择多样，无论是宣传视频、漫画配音还是产品展示动画都能满足你对创意表达方式的所有需求，主要针对音乐人和短视频创作者。
Comic Factory
自动生成漫画
很多人从小有个梦想想要当漫画家，只可惜没有好好学画画，现在你不仅可以成为漫画家，还能靠自己的漫画来赚钱了。动动小手用你常用的翻译软件翻译出你想要创作的故事，输入简洁的故事内容会自动按照情节和角色生成漫画，可以调整风格设置、画布布局、字幕等，对于不满意的部分也能重新生成和再次编辑，适用于发布到漫画网站或制作成短视频，人人都可以做漫画。
Figma
绝绝子的设计师
高保真原型输出的不二选择，存储文件不占内存，网页就可以打开，不论你是Mac还是Windows都可以使用它！和团队里的成员分享文件只需要一个链接就可以，而且可以实时协作，有问题直接在设计稿标注，设计稿忘记保存只需查看历史版本就可以恢复。组件修改非常方便没有那么多层级，组件颜色、字体，效果等样式更加细致，只要修改一个整个文件都会同步修改，自适应布局的同时修改模块间距速度很快，最重要的是好用的插件真的超级多，后期会展开分享！
adobe firefly
一键修改视频内容工具
输入指令就能修改视频内容，比如输入将背景改为春天，然后点击生成视频里的秋天就变成了春天，真的非常好用。还能根据文字描述生成图片并对图片的风格、颜色、用光等进行调节，也可以对图片进行扩充或者对图片缺失的元素进行补充修复，支持轻轻拖拽对面部表情进行细微调整优化。如果你是从事电商相关的工作也能根据文字描述生成海报等模版，并且可以对模版中的图片、文字作替换，也能将多张图片融合成一张图片产生新的作品。
Adobe Express
AI一键制作卡通视频
制作卡通视频的强大工具，月入六位数不是梦！全程可通过AI自动制作，不需要费脑思考，不管是帮别人做动画还是做自媒体内容都非常好用。仅提供文字描述便可立即生成出色的文字效果和图片，并支持 100 多种语言的文本提示，提供近 2 亿素材资产，包括视频和设计模板、免版税的 Adobe Stock 图像、视频和音频资产、近 22,000 种字体以及更多图标、背景和形状。还能轻松快捷地制作 Instagram Reels 和 TikTok 视频，以及传单、简历、横幅、徽标等，支持合并视频片段、图片、动画和音乐，只需拖放即可轻松制作视频，“从音频动画化”功能让观看角色随着录制的对话同步唇部和手势活跃起来。
Collov
房屋装修设计
是一款适用于装修设计的AI工具，也是一款室内设计AI网站，不管客户的房间有多奇葩或要求多高，只需上传房间照片，根据房间照片选择客户喜欢的风格后AI会自动生成装修效果图，上传房间照片后AI也会自动帮你摆放家具。你可以选择全部重新生成或是部分生成，网站就会自动生成多种设计让你选择，各种风格都有且每一张都很精致，而且生成的结果当中还能够看到搭配的家具品牌及价格。适合有想法却没设计经验、不想花大价钱请设计师却又有追求、对已入住环境不满意想改造的朋友们，即使是软装小白也容易上手，真实的花小钱办大事。
拯救者R9000p
如果仅仅是想尝试一下AI绘图的即文生图、图生图的话对电脑是没啥要求，只不过电脑配置低了会卡死、速度慢、黑屏而已，想用插件的话推荐内存至少8g、显卡至少10系，不然1分钟崩溃两次不如不玩。如果是需要做AI训练的话显卡的显存至少12g，这和大多数渲染软件的要求差不多，都是吃显存内存但是不怎么吃cpu，这里比较推荐联想拯救者R9000p笔记本电脑。
R9000P采用了16:10比例的2.5K 165Hz屏幕，下边框进一步收窄使得屏占比提升到了91.7%，不管是用来做设计还是动画生成都能呈现出更多的细节。搭载的AMD锐龙 7 6800H处理器主频达3.2GHz，并且采用了满血版的NVIDIA RTX 3060显卡，无论是在游戏还是生产力场景下都能够保证强劲的输出性能。此外，在存储方面采用了DDR4双通道高频内存以及PCIe硬盘，使得在游戏载入、视频生成、地图载入等方面更加顺畅，丰富的接口也能满足日常的使用需求。
AI这波风口请一定要抓住，只要开始都不晚，冲！
资料分享 小编整理了一份AIGC技术的入门资料包，包括SD和Midjourney的安装包、chatGPT国内直接使用方法，AI搞钱方法教程，AI写文案 剪视频 做账号等等，wx扫描二v码免费领取 【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddef9e503913bb57260aa7350f303a3e/" rel="bookmark">
			MySQL8主从复制之一主一从实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL8主从复制之一主一从实战 实战环境，Windows Server 2008R2+MySQL8.0.27
操作系统MySQL版本主/从库IP同步用户同步用户密码Windows Server 2008R2+mysql-8.0.27-winx64.zipmaster192.168.3.246synchadminsynchadminWindows Server 2008R2+mysql-8.0.27-winx64.zipslave192.168.3.247–– 1. 下载与环境变量配置 截至到2021-11-29最新版本为Mysql-8.0.27
官网下载：https://dev.mysql.com/downloads/安装文件：mysql-8.0.27-winx64.zip解压到D下：如：D:\MySqlServer\mysql-8.0.27-winx64环境变量配置 在系统变量中新增下面配置 变量名：MYSQL_HOME 变量值：D:\MySqlServer\mysql-8.0.27-winx64 在系统变量的path变量值后面新增下面代码 xxxx；%MYSQL_HOME%\bin 2. 主库安装与配置 在D:\MySqlServer\mysql-8.0.27-winx64下新建my.ini，内容如下 [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=D:\\MySqlServer\\mysql-8.0.27-winx64 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 # datadir=D:\\MySqlServer\\mysql-8.0.27-winx64 #8.0以下版本需要配置数据目录 # 允许最大连接数 max_connections=20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证解决客户端无法连接的问题 default_authentication_plugin=mysql_native_password #主从-主库配置 #1.主服务器id唯一【必须】 server-id=1 #2.启用二进制日志【必须】 log-bin=mysql-bin #3.主从，都可读可写 #read-only=0 #4.设置不要复制的数据库【可选】 binlog-ignore-db=mysql #5.设置需要复制的数据库【可选】 #binlog-do-db=要复制的数据库名字 进入D:\MySqlServer\mysql-8.0.27-winx64\bin目录下，以管理员身份打开cmd窗口，执行下面命令,产生root密码,牢记此密码 mysqld --initialize --console cmd窗口中的内容如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddef9e503913bb57260aa7350f303a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83a294c12bf70d2f01cd56e7a8f41dc/" rel="bookmark">
			排序链表（LeetCode 148）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.问题描述2.难度等级3.热门指数4.解题思路参考文献 1.问题描述 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
示例 1：
输入：head = [4,2,1,3] 输出：[1,2,3,4] 示例 2：
输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5] 示例 3：
输入：head = [] 输出：[] 2.难度等级 Medium。
3.热门指数 ★★★★☆
4.解题思路 可参考归并排序中的归并排序思想，主要有三个步骤。
找到链表的中间结点。 寻找链表的中点可以使用快慢指针的做法，快指针每次移动 222 步，慢指针每次移动 111 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。
递归对左半部分和右半部分排序。
将两个排序后的子链表合并，得到完整的排序后的链表。
可以使用「21. 合并两个有序链表」的做法，将两个有序的子链表进行合并。
时间复杂度： O(nlogn)。
空间复杂度： 递归栈空间复杂度为 O(logn)，不考虑的话为 O(1)。
下面以 Golang 为例给出实现。
func merge(head1, head2 *ListNode) *ListNode { dummyHead := &amp;ListNode{} temp, temp1, temp2 := dummyHead, head1, head2 for temp1 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d83a294c12bf70d2f01cd56e7a8f41dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f61c384f5d45d00f075b39df2df61c/" rel="bookmark">
			linux 驱动开发中原子操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd75c32d0013d51d38c32bb1aee34d8f/" rel="bookmark">
			VScode中运行python时，使用matplotlib的plt.imshow()不显示图像 的参考解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 自己的测试环境 Ubuntu20.04
一、问题描述 自己使用VScode中运行python程序时，python程序中调用matplotlib的 plt.imshow() 不能显示图像的情况。
二、解决方法 出现这种情况的解决方法很简单，在最后一个plt.imshow(image) 的后面增加一个 plt.show()即可解决问题。
plt.imshow(image) plt.show() 其他解决方法 [1] 灵犀智库. code9：VScode的python使用matplotlib的plt.show()不显示图形 [EB/OL]. https://zhuanlan.zhihu.com/p/362582958, 2021-04-16/2024-01-18.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e46a58f6492b37e763d5a6f0276f5978/" rel="bookmark">
			NPOI实现解析与导出EXCEL文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NPOI实现上传与下载文件 准备工作解析1. 创建接口2.excel 表3.通过NPOI实现插入城市sql拼接 导出创建文件数据Dto类2.控制器接口3.创建序列化方法类NpoiData4.生成文件方法 准备工作 下载Nuget包
NPOI
解析 1. 创建接口 [HttpPost] [Route("UpLoad")] public string UpLoadCityLabel(IFormFile file) { using (var stream = new MemoryStream()) { file.CopyTo(stream); stream.Position = 0; IWorkbook workbook = new XSSFWorkbook(stream); //读取excel第一个sheet ISheet sheet = workbook.GetSheetAt(0); //设置城市排序 int provinceIndex = 1; List&lt;string&gt; listFirst = new List&lt;string&gt;(); StringBuilder stringBuilder = new StringBuilder(); for (int rowFirstIndex = 1; rowFirstIndex &lt;= sheet.LastRowNum; rowFirstIndex++) { // 获取弟excel第几行 IRow row = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e46a58f6492b37e763d5a6f0276f5978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa31ce12e88f2a8b1d2bd4721b04b00/" rel="bookmark">
			软件自动化测试较于手工测试有什么优势?软件测试外包公司推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件自动化测试是指利用专门的软件工具来执行测试用例，从而提高测试效率和准确性的一种测试方法。相对于传统的手工测试，自动化测试具有更快的执行速度、更好的测试覆盖率、更高的测试准确性和可重复性等优势。
1、高效的执行速度。相比手工测试需要人工逐一执行测试用例，自动化测试可以通过脚本实现快速的批量执行，大大节省了时间成本。测试人员只需要编写测试脚本一次，就可以反复执行，而且可以在夜间或无人值守时段进行测试，提高了测试的效率。
2、良好的测试覆盖率。在手工测试中，由于时间和人力的限制，往往只能对核心功能进行测试，无法覆盖全部的功能和各种边界情况。而自动化测试可以通过编写全面的测试脚本，对所有功能进行验证，包括各种正常和异常情况，提高了测试的覆盖率。
3、较高的测试准确性和可重复性。测试人员编写的测试脚本是按照严格的步骤和预期结果进行编写的，不会出现疏漏或主观判断的问题，大大提高了测试的准确性。而且测试脚本可以随时被重复执行，不会因为人为疲劳或注意力不集中而出现问题，保证了测试的可重复性。
4、提高开发流程的整体效率。自动化测试可以在开发人员提交代码之后，自动执行测试，及时发现和修复问题，减少了测试和开发的沟通成本，加快了软件开发的进程。自动化测试可以将测试结果自动化地记录和分析，提供给开发人员进行问题定位和修复，节省了调试时间。
可以说，自动化测试具有很多优势，但是否能替代手工测试也需要根据具体的情况来决定。自动化测试适用于稳定的、重复性较高的功能测试和回归测试，但对于一些需要人工主观判断、需求频繁变化或UI交互较多的测试场景，手工测试仍然是必要的。
卓码软件测评，具备CMA、CNAS双重资质的软件测试外包公司，拥有丰富的测试经验和专业的测试团队，可以提供优质的各种测试类型服务，服务范围覆盖全国各地，出具的第三方软件测试报告具备法律效力。
文章来源:软件自动化测试较于手工测试有什么优势?软件测试外包公司推荐—卓码软件测评
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/950a503fc814509928201ab3fb1b79a2/" rel="bookmark">
			css-动画效果学习示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阴影
x-轴 y-轴 模糊度 颜色 (正负值可以表示角度问题)
可以加多个阴影
内置阴影
transition 可以添加动画延迟效果
向z轴缩进，开启透视respective
触发旋转效果
学习来源 ：动画属性_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b7e1ebab9d73d637c0efa09fe930dd2/" rel="bookmark">
			JS给DOM添加元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js向DOM添加元素的代码，做个记录
// 获取要操作的目标元素 document.getElementById('1').innerHTML = '新的内容'; // // 创建新的DOM元素 var newElement = document.createElement('div'); // 这里以创建&lt;div&gt;为例 newElement.innerHTML = '新的内容'; // 设置新元素的HTML内容 // 将新元素添加到目标元素之前或之后（根据需求选择） targetElement.parentNode.appendChild(newElement, targetElement); // 在目标元素之前插入新元素 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c97e528208612b2970fb0c97722f6ff6/" rel="bookmark">
			【vue中文件及文件夹命名规范详细介绍】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue中文件及文件夹命名规范详细介绍 1. 介绍2. 命名规范3. 文件夹名4. 路由和子文件夹5. 单文件组件的大写字母6. 测试文件7. 约定性书写 1. 介绍 在 Vue 项目中，合理的文件和文件夹命名对于代码维护和团队协作非常重要，没有官方的强制性规范，但社区有一些通用的最佳实践：
2. 命名规范 Vue 组件的命名规范通常遵循以下几种风格：
1. 命名法
1.1 驼峰式命名法(camelCase)
1.2 短横线命名(kebab-case)全小写
1.3 帕斯卡命名法(PascalCase)
2. 文件夹命名
2.1 kebab-case
2.2 尽量使用名词，尽量使用一个单词
3. *.js文件命名规范
3.1 所有模块的主文件index.js全小写
3.2 属于组件的.js文件，使用PascalBase风格
3.3 其他类型的.js文件，使用kebab-case风格
4. *.vue文件命名规范
4.1 除index.vue之外，其他.vue文件统一用PascalBase风格
5. *.less文件命名规范
统一使用kebab-case命名风格
前三点比较重要，需要记住
附录一：.less为后缀的文件是什么
1、less是什么：LESS 为 Web 开发者带来了福音，它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。
2、为什么有less：CSS 是一门非程序式语言，CSS 需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用
3、less最最最简单实例：使用@符号来定义变量
3. 文件夹名 文件夹名称通常遵循如下几种风格：
全小写并使用连字符分隔: 对于存放组件的文件夹，常见的是使用 kebab-case，如 user-profile 文件夹内部可能包含 UserProfile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c97e528208612b2970fb0c97722f6ff6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/14/">«</a>
	<span class="pagination__item pagination__item--current">15/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/16/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>