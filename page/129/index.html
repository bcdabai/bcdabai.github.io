<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07af83c7e50def6a899e94769c2d4d12/" rel="bookmark">
			使用Houdini快速将图片转换成文字模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Trace选择黑底白字图片，Extrude挤压文字，ROP Geometry节点输出fbx文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f7b01cd5318c3c7957ef5c35fb88c7/" rel="bookmark">
			C语言之浮点数(小数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浮点型顾名思义就是小数点后还有数的，小数点数还有数的是什么?是小数，那么，小数在c语言中怎么定义，输出和输入
浮点型的关键字有:double和float。
首先他是这样定义的:关键字 + 变量名 = 一个值.如下:
float a = 12.12;//关键字为float double b = 18.18;//关键字为double 他们怎么输出? 像整形有"%d"输出，无符号的整形有"%u"输出。那么double和float又是怎么输出? float使用格式输出"%f" double就使用"%lf". 千万别写错了，要不然会报错。
float a = 12.12f;//浮点型1.关键字float double b = 15.15;//浮点型2.关键字double printf("float:%f,double:%lf",a,b);//使用printf输出，输出使用格式输出"%f"和"%lf" 有的同学就会问了:"老湿老湿，说了这么多，我到底用哪个啊！！！"。现在，我们就讲他们的异同点，和使用哪个。
float:他的内存大小为4字节，和int一样，我们使用sizeof(变量名/变量类型)得到他的大小。他能表示的范围分整数和负数。整数为:1.17549e-038 ~ 3.40282e+038.负数为：-3.40282e+038 ~ -1.17549e-038 。他的有效数位为7，什么意思呢？就是他能表示小数的范围为小数学后7位。他和double有一个区别，就是赋值的时候要在赋值的值上加上"F/f"以辨认是double还是float，当然double就不用。
double:他的内存大小为8字节，比int大了一圈。我们使用sizeof(变量名/变量类型)得到他的大小。他可以表示的有效范围也分为整数和负数:整数为 +2.2250738585072014e-308 ~ +1.7976931348623158ee+308。负数为-1.79769e+308 ~ -2.22507e-308 ，几乎说是用无限大了。他的有效精度为16位，意思说他能表示的范围为小数点后16位。
然后我们看输入输出:
使用printf，格式输出%f,和%lf.
double a = 12.12; float b = 12.23; printf("%f,%lf",a,b); 如果你想要只打印小数点后一位，那么就这样:像double"%+要显示小数点后面的几个个数"。如:你想输出小数点后面的一位:(就在%后面lf前面加要显示的个数)
double a = 12.23456; printf("%1lf",a); 输入:
使用scanf_s/scanf函数
double a = 12; scanf_s("%lf",&amp;a); 使用格式输入%lf/%f输入，然后变量需要取地址。
总结scanf/scanf_s:要输入的变量一定要取地址"&amp;"，格式输入一定要对应上。 其他就没什么说了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f1a0c9ca467a70474dd2af5d87196ee/" rel="bookmark">
			Eclipse配置lombok，今天有人问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要准备 1.lombok.jar https://projectlombok.org/download
2.eclipse 工具 步骤：
一、把下载好的 lombok.jar 放在自己的 jar 包和工具类的文件夹里
二、把这个 lombok.jar 的包复制一下，放入 eclipse 安装目录下，和 eclipse.exe 同级的目录下。
三、打开 lombok.jar
点这里，打开本地的 eclipse.exe（默认是自动寻找，如果没有自动寻找则按照此方法加载 eclipse.exe）
然后点击 Install/Update 就 OK 了。
安装完成，我们测试一下
创建一个实体类一下
import lombok.Data; @Data // lombok 中的 data 注解，使用此注解可以省略 get 和 set 方法 public class User { private int id; private String name; private String sex; } 测试结果如下：
我们成功省略了 get 和 set 方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981a541efd3ce4b0be798f22b3d210a8/" rel="bookmark">
			idea创建spring项目报错汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、idea创建spring项目报错 1、保存数据至数据库为何部分字段为null @RequestBody部分属性为null的问题
Controller方法中使用@RequestBody接收到的值为空？
关于Springboot | @RequestBody 接收到的参数对象属性为空的问题
2、spring项目中，sql映射类型不一致，异常报错 解决异常报错java.sql.SQLException: Value '0000-00-00 00:00:00' can not be represented as java.sql.Timestamp
除了这种，还有别的类型，都可以归类为一种，就是处理myql字段，通常这种异常报错，copy相应的sql代码并不会出现什么问题，基本可以成功在直接数据库的操作中得到一个结果集，但是，系统会异常，因为字段类型和项目中返回数据集中某个字段类型不一致；
诸如这里是因为时间，存在时间类型的字段，为0000-00-00这个值没有意义，在正式库中不会出现，测试库中会有这个报错导致整个功能不能成功进行排查测试；按照上面的链接进行处理，目前，不成功；
但是因为是测试库数据不合理，所以我直接修改测试库数据内容即解决，解决方案治标不治本；
另一个问题是同样在测试过程中，数据查询一直报错，原因排查到是因为，数据库中a 字段为varchar字符串类型，但是实体类中为Integer类型，a数值通常为1,2,3,5这几个表示状态的数值，而且实体类是一个共用的返回类型，不能轻易更改类型，这里原系统有考虑到这个问题，直接在service中写了一个方法，先把a保存为另一个名称的字段，然后把这个字段用java代码使用数据字典这种类型的数据，进行获取具体的Integer类型字段，然后再对a字段赋值，保存，就没有问题了；
结论：
这种情况通常会是数据库操作没有问题，但是系统没办法成功运行，代码会报错；隐藏性比较高，容易找不到具体缘由；因此在此记录，避免浪费时间；
3、idea使用Easycode新建UserService无法正常生成； 3.1 报错内容 3.2 报错原因 因为不知名原因，把UserService设置成一个模板类型，个人解决方案不同于参考链接，但性质一致；
如下图，最后在相应位置发现有UserService，这就是唯一创建UserService这个文件的原因了；
已解决；
3.3 解决方案 Unable to parse template "Class" Error message: Selected class file name 'ProductServlet.java' mappe
二、EasyCode类型的配置 1、使用default_srm一系列配置生成代码结构 1.1 首先是dao层代码未添加@Mapper 注解导致项目无法正常启动； 1.2 default_srm系列配置中文乱码 设置成XX.vm的文件格式，然后记得apply，重新设置成中文不乱码模式，然后导出配置；
关于EasyCode模板配置以及一些问题的处理：
easycode使用碰到的问题以及自定义的模板
改模板仅供参考其中的中文内容部分，对照EasyCode中Default_SRM配置乱码部分；目前EasyCode配置已备份至20220331；可以成功生成mp结构，但是，配置本身的中文乱码，参照价值为零；
三、项目启动型错误 1、项目启动失败 原因为端口被占用 触发条件： 通常为当前项目启动同时有页面在运行，占用端口造成的（猜测）
解决方案： 解决 Disconnected from the target VM, address: ‘127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/981a541efd3ce4b0be798f22b3d210a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16935f6c3cbe4a296cecee58008d3191/" rel="bookmark">
			Windows Server 2012 R2 安装补丁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网上很多案例都是需要去官网下载，但是官网访问真的是太慢了，这里准备了Windows Server 2012 R2 补丁包下载地址，直接访问，下载速度很快。
执行顺序 01-需要重启-Windows8.1-KB2919442-x64.msu02-管理员运行-clearcompressionflag.exe03-需要重启-windows8.1-kb2919355-x64.msu04-需要重启-windows8.1-kb2932046-x64.msu05-需要重启-Windows8.1-KB2934018-x64.msu06-windows8.1-kb2937592-x64.msu07-需要重启-windows8.1-kb2938439-x64.msu08-需要重启-Windows8.1-KB2959977-x64.msu clearcompressionflag.exe https://download.microsoft.com/download/D/B/1/DB1F29FC-316D-481E-B435-1654BA185DCF/clearcompressionflag.exe KB2919442 1、http://download.windowsupdate.com/c/msdownload/update/software/crup/2014/02/windows8.1-kb2919442-x64_f97d8290d9d75d96f163095c4cb05e1b9f6986e0.msu 2、https://download.microsoft.com/download/D/6/0/D60ED3E0-93A5-4505-8F6A-8D0A5DA16C8A/Windows8.1-KB2919442-x64.msu KB2919355 http://download.windowsupdate.com/d/msdownload/update/software/crup/2014/02/windows8.1-kb2919355-x64_e6f4da4d33564419065a7370865faacf9b40ff72.msu KB2932046 http://download.windowsupdate.com/d/msdownload/update/software/crup/2014/02/windows8.1-kb2932046-x64_6aee5fda6e2a6729d1fbae6eac08693acd70d985.msu KB2959977 https://download.microsoft.com/download/9/C/7/9C7A638F-D1E3-40F4-A755-64899A18B411/Windows8.1-KB2959977-x64.msu KB2937592 http://download.windowsupdate.com/c/msdownload/update/software/crup/2014/02/windows8.1-kb2937592-x64_4abc0a39c9e500c0fbe9c41282169c92315cafc2.msu KB2938439 http://download.windowsupdate.com/c/msdownload/update/software/crup/2014/03/windows8.1-kb2938439-x64_3ed1574369e36b11f37af41aa3a875a115a3eac1.msu KB2934018 https://download.microsoft.com/download/D/B/1/DB1F29FC-316D-481E-B435-1654BA185DCF/Windows8.1-KB2934018-x64.msu dotnet-hosting-6.0.1-win.exe https://download.visualstudio.microsoft.com/download/pr/b69fc347-c3c8-49bc-b452-dc89a1efdf7b/ebac64c8271dab3b9b1e87c72ef47374/dotnet-hosting-6.0.1-win.exe 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de91228b03bfef35f3f4b18222b87322/" rel="bookmark">
			Modbus简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 官方文档： Modbus_Application_Protocol_V1_1b.pdfwiki： Modbus - Wikipedia (jinzhao.wiki)RTU与ASCII比较： Modbus RTU (ozeki.hu)详细说明： Modicon Modbus Protocol Reference Guidemodbus TCP： Modbus_Messaging_Implementation_Guide_V1_0b_tcp.pdf 名词解释 ADU： Application Data Unit 应用数据单元PDU： Protocol Data Unit 协议数据单元RTU： Remote Terminal UnitCRC： Cyclic Redundancy Check 循环冗余校验LRC： Longitudinal Redundancy Check 纵向冗余校验离散变量： 指其数值只能用自然数或整数单位计算的则为离散变量 协议简介 由Modicon （现在的施耐德电气）在1979年发布，用于PLC通信，已经成为事实上的工业领域通信协议的业界标准。
特点： 简单，应用广泛，请求/应答，功能码支持。
modbus支持多种通信栈传输
TCP/IP over Ethernet， 端口为502Asynchronous serial 传输 over EIA/TIA-232-E 或 EIA/TIA-485 或 fiber, radio 等MODBUS PLUS， 一种高速令牌传输网络其他 其中串口通讯最为常见。
总体结构 modbus是由 modbus ADU 构成，不同的通讯协议会对它做一定的封装，ADU的结构如下
Additinal addressModbus PDUError Check地址域协议数据单元差错校验 PDU的结构如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de91228b03bfef35f3f4b18222b87322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb26d14013ebffb0a55624c1c211d536/" rel="bookmark">
			git push 报错：refusing to merge unrelated histories
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		翻译：refusing to merge unrelated histories：拒绝合并不相关的历史
原因：
本地仓库和远程仓库实际上是独立的两个仓库。假如以直接clone的方式在本地建立起远程github仓库的克隆本地仓库，就不会有这问题了。
解决：
在pull命令后紧接着使用 $ git pull origin master --allow-unrelated-histories 选项来解决问题（该选项可以合并两个独立启动仓库的历史）
参考此连接https://blog.csdn.net/u012145252/article/details/80628451
以下是我自己的报错及操作流程：
1、本地项目文件夹内执行命令
$ git init 2、执行命令
$ git remote add origin https://你的仓库地址 3、执行命令
$ git pull origin master 4、执行命令
git add . git commit -m "备注信息" 5、此步骤报错，多次提示需要重新down下代码，但是每次执行完都提示已经是最新的代码了。
报错的具体原因可以参考这篇文章,描述的很详细。
git push origin master 6、解决办法：
$ git pull origin master --allow-unrelated-histories 发现冲突，然后本地解决冲突后重新提交。
7、正常提交
成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5814beb63442955533c2cfc775f436c/" rel="bookmark">
			go语言找多个数的最大公因数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 func gcd(a,b int) int { if b == 0 { return a } return gcd(b, a % b) } func GetGcd(n []int) int { // 先取得Slice中的第一个数, 并假设第一个数为最大公约数 g := n[0] // 依次与Slice中的每个数字求最大公约数 // 这里i=1, 因为第0个数字已经取出并假设为最大公约数 for i:=1; i&lt;len(n)-1; i++ { oldGcd := g // 使用两个数字比较的最大公约数函数进行计算, 得出当前两个数字的最大公约数 // 循环开始后, 依次将当前最大公约数与后面的数字一一进行运算, 求最大公约数 g = gcd(g, n[i]) fmt.Printf("第%d次运算, 当前最大公约数为%d, 与%d运算得出的新最大公约数为: %d \n", i, oldGcd, n[i], g) } return g } 更相减损术 更相减损术，举例说明方法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5814beb63442955533c2cfc775f436c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb920b868bd5c3a21d13ae6fdbc0f7c3/" rel="bookmark">
			输出显示xxx.exe(进程xxx)已退出，代码为0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当输出显示
这是因为我们VS工具设置-选项-调试-常规里默认未勾选下张图片的选项
勾选之后就不会显示了，但是记得代码添加system("pause");让程序运行成功后暂停，否则程序运行成功后会直接关闭。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e6b06c21235969a683c9e3d2fcdae8/" rel="bookmark">
			Fluttter关于第三方插件版本冲突问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 项目需要指定第三方插件的版本，不然拉取库会自动改变版本，可能会引入一些莫名其妙的bug，造成不好的影响。
在指定版本时遇到一下问题：
Because pretty_dio_logger &gt;=1.0.9 &lt;1.2.0-beta depends on dio &gt;=2.1.9 &lt;=3.1.0 and ushangxie_flutter_app depends on dio 4.0.6, pretty_dio_logger &gt;=1.0.9 &lt;1.2.0-beta is forbidden. So, because ushangxie_flutter_app depends on pretty_dio_logger 1.1.1, version solving failed. pub get failed (1; So, because ushangxie_flutter_app depends on pretty_dio_logger 1.1.1, version solving failed.) 解决：把pretty_dio_logger设置为1.2.0-beta版本即可 问题：
Because file_picker 5.2.0+1 depends on win32 ^3.0.0 and device_info_plus_windows &gt;=3.0.0 &lt;4.1.0 depends on win32 ^2.7.0, file_picker 5.2.0+1 is incompatible with device_info_plus_windows &gt;=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7e6b06c21235969a683c9e3d2fcdae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/570ee7eea5bbe9ef9ef29554181ef0ce/" rel="bookmark">
			【ubantu20.04安装教程】新手安装&#43;基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 （一）下载安装VMware 16（二）下载安装ubantu20.04（三）初始配置1.语言、输入法2.查看ubantu版本3.第一次进入root模式需要配置4.最常用快捷键 （一）下载安装VMware 16 官网下载：https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html
安装过程一路next
破解秘钥：ZF71R-DMX85-08DQY-8YMNC-PPHV8
（二）下载安装ubantu20.04 推荐清华镜像：https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/20.04.5/
一定下载iso文件。
放入磁盘：
打开VMware，点击创建：
选择典型-&gt;下一步：
找到安装好的iso文件-&gt;下一步：
设置好信息：
选择安装位置：
可以根据自己的需要调整分配磁盘大小，也可以默认-&gt;下一步：
可以按照默认硬件，也可以自定义-&gt;完成
接下来是漫长的等待。。。
（三）初始配置 1.语言、输入法 输入密码进入后，一路skip就行。
打开firefox会发现只能输入英文，接下来配置中文输入：
下载好之后，把汉语移到首位：
重启一下ubantu就会看到变成中文界面了。
接下来设置输入法：
OK。
如果不喜欢中文界面还可以再切回英文（刚才的输入法还是在的）：
重启一下即可。
2.查看ubantu版本 Ctrl+Alt+T:打开终端
输入uname -v
可以设置禁止自动更新（根据需求）：
3.第一次进入root模式需要配置 因为输入su root之后，提示输入password，但是ubantu自身bug，即便输入了，但它不显示，可以忽略这个问题，默认它读到了输入密码。。。但结果是提示认证失败：
所以需要配置一下：
输入：sudo passwd root
提示输入登陆密码，按照提示输入三遍就提示成功了。
再次su root，就进入了root模式：
$ 符号代表此时处于 Linux 的shell 交互下，需要使用 Linux 命令
＃ 这个符号表示的是现在处于 Linux 的 root 权限下
4.最常用快捷键 打开终端：Ctrl+Alt+T
复制：Ctrl+Shift+C
粘贴：Ctrl+Shift+V
开始ubantu之旅~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e5c5e3df9b53f4682d2e4228d7fdbd/" rel="bookmark">
			python学习记录：浅谈python变量与C语言变量的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在python中不需要事先声明变量名及其类型，直接赋值即可创建各种类型的变量，虽然不需要在使
用之前显式地声明变量及其类型，但是python仍属于强类型编程语言。
在说python变量与C语言变量的区别之前我们先来看个例子
1、python中
i=t=2048 print(i,id(i)) print(t,id(t)) i=251 print(i,id(i)) # print(t,id(type)) print(t,id(t)) 结果如下：
之前有误，改正后：
大家可以先思考一下为什么i和t明明是不同的变量，却共用同一个地址，为什么当i的值改变了，i的地址也跟着变了。
2、C语言中
#include&lt;stdio.h&gt; int main() { int i,t; int *g,*h; i=t=10; g=&amp;i; h=&amp;t; printf("%d %d\n",*g,g); printf("%d %d\n",*h,h); i=12; printf("%d %d",*g,g); printf("%d %d",*h,h); } 结果如下：
大家可以很容易的发现，在C语言中i和t的地址是不同的，并且变量的地址并不会随着值的改变而改变。
之所以会有这些区别主要是python关于变量方面的处理和C语言、C++和很大不同。
1、按照C语言和C++的对变量的处理方式都是先声明后定义，要先声明变量的类型，才能根据类型给变量分配地址。
2、而python采用的是基于值的内存管理方式，可以把他当成是C语言的指针去理解，变量相当于一个指针，当被赋值了之后变量就会指向该数据所在的内存地址。而当值改变了之后，指针的指向也发生改变。
所以我们解释一下上面的例子，在python中，变量i和t被赋上相同的值，这个值在内存中只有一份，多个变量指向同一块内存地址。python中修改变量值的操作，并不是修改了变量的值，而是修改了变量指向的内存地址。而在C语言中，变量在使用之前就分配好了地址不会更改。
python具有自动内存管理功能，会跟踪所有的值，并自动删除不再有变量指向的值。
所以三引号可以被当作注释的原因就是因为python的自动内存管理和三引号的换行属性，三引号本身不是注释符，在一开始还是会为它分配一个地址存放值，但是当没有变量指向它时，python就会自动删除这个值，因此不占内存，不影响程序，可以当成注释。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1939a2292c74e961b9b8ccdc93272c1/" rel="bookmark">
			Vcenter证书过期--Vcenter无法登录,密码错误,签名无效,503
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 故障现象 登录时一直提示用户名密码错误,但确认密码和用户名没有问题.之前1个月其实已经通过控制台重置过证书日期,并看到证书日期是2年后的了.于是怀疑是不是证书过期了.
当时急着排除故障就没有截图了.引用官网的2张图
2. 排除过程 2.1 确认故障原因 2.2.1 登录vcenter命令行 2.2.2 查看证书日期 果然,证书日期是今天凌晨过期的
root@pana-vc [ ~ ]# for i in $(/usr/lib/vmware-vmafd/bin/vecs-cli store list);do echo STORE $i;sudo /usr/lib/vmware-vmafd/bin/vecs-cli entry list --store $i --text|egrep "Alias|Not After"; done STORE MACHINE_SSL_CERT Alias :	__MACHINE_CERT Not After : Sep 16 05:18:40 2024 GMT STORE TRUSTED_ROOTS Alias :	79f3d5a2a7ee50b15c6698c7c796b104ff2dc855 Not After : Oct 4 08:49:45 2028 GMT Alias :	f7083e9abad114d69d3bb1eb0657bb0f904c4a59 Not After : Oct 15 04:35:10 2030 GMT STORE TRUSTED_ROOT_CRLS Alias :	8900883067e989a792fdd6aad2182d8ab965e7bc Alias :	be6990d6d91b1ec33f0b1a1d16acc1e4bcb71a14 STORE machine Alias :	machine Not After : Oct 15 04:35:10 2030 GMT STORE vsphere-webclient Alias :	vsphere-webclient Not After : Oct 15 04:35:10 2030 GMT STORE vpxd Alias :	vpxd Not After : Sep 16 05:19:07 2024 GMT STORE vpxd-extension Alias :	vpxd-extension Not After : Oct 15 04:35:10 2030 GMT STORE SMS Alias :	sms_self_signed Not After : Oct 10 08:54:35 2028 GMT STORE BACKUP_STORE Alias :	bkp___MACHINE_CERT Not After : Oct 9 20:49:45 2020 GMT Alias :	bkp_machine Not After : Oct 9 08:40:35 2020 GMT Alias :	bkp_vsphere-webclient Not After : Oct 9 08:40:35 2020 GMT Alias :	bkp_vpxd Not After : Oct 9 08:40:35 2020 GMT Alias :	bkp_vpxd-extension Not After : Oct 9 08:40:36 2020 GMT Alias :	bkp__MACHINE_CERT Not After : Oct 20 04:25:11 2022 GMT STORE BACKUP_STORE_H5C Alias :	bkpmachine Not After : Oct 20 04:26:33 2022 GMT Alias :	bkpvsphere-webclient Not After : Oct 20 04:26:33 2022 GMT Alias :	bkpvpxd-extension Not After : Oct 20 04:26:34 2022 GMT Alias :	bkpvpxd Not After : Oct 20 04:26:34 2022 GMT 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1939a2292c74e961b9b8ccdc93272c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499040b46dd0df6fd8d8b624bcac2e35/" rel="bookmark">
			ucharts 图表接口数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、ucharts的数据格式二、使用步骤 1、数据处理总结 前言 将接口返回的数据做一下简单处理，处理成组件要求的格式即可
一、处理前的代码 &lt;template&gt; &lt;view class="charts-box"&gt; &lt;qiun-data-charts type="column" :opts="opts" :chartData="chartData" /&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { chartData: {}, //这里的 opts 是图表类型 type="column" 的全部配置参数，您可以将此配置复制到 config-ucharts.js 文件中下标为 ['column'] 的节点中来覆盖全局默认参数。实际应用过程中 opts 只需传入与全局默认参数中不一致的【某一个属性】即可实现同类型的图表显示不同的样式，达到页面简洁的需求。 opts: { timing: "easeOut", duration: 1000, rotate: false, rotateLock: false, color: ["#1890FF","#91CB74","#FAC858","#EE6666","#73C0DE","#3CA272","#FC8452","#9A60B4","#ea7ccc"], padding: [15,15,0,5], fontSize: 13, fontColor: "#666666", dataLabel: true, dataPointShape: true, dataPointShapeType: "solid", touchMoveLimit: 60, enableScroll: false, enableMarkLine: false, legend: { show: true, position: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/499040b46dd0df6fd8d8b624bcac2e35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94fd729e52f1b079454b04ab195d69f3/" rel="bookmark">
			Linux GPIO驱动部分函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设备树—API
①of_find_compatible_node 函数
②of_get_named_gpio 函数
③irq_of_parse_and_map 函数
二、GPIO—API
①gpio_request 函数
②gpio_free 函数
③gpio_direction_input 函数
④gpio_direction_output 函数
⑤gpio_is_valid 函数
⑥gpio_get_value 函数
⑦gpio_set_value 函数
三、中断—API
①request_irq 函数
②free_irq 函数
③enable_irq()与disable_irq()函数
四、Pinctrl—API ①devm_pinctrl_get 函数
②devm_pinctrl_put 函数
③pinctrl_lookup_state 函数
④pinctrl_select_state函数
inux驱动开发，首先从使用驱动的API开始，先会使用API，然后才能更深入的分析，本篇所列的都是驱动开发中非常常用的API，之所以从设备树API开始，是本人觉得驱动开发的源头在设备树，并且大部分驱动都跟设备树相关。
一、设备树—API ①of_find_compatible_node 函数 of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点， 函数原型如下： struct device_node *of_find_compatible_node(struct device_node,*from, const char *type,
const char *compatible) 函数参数和返回值含义如下： from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。 type：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示忽略掉 device_type 属性。 compatible：要查找的节点所对应的 compatible 属性列表。 返回值：找到的节点，如果为 NULL 表示查找失败 ②of_get_named_gpio 函数 此函数获取 GPIO 编号，因为 Linux 内核中关于 GPIO 的 API 函数都要使用 GPIO 编号，此函数会将设备树中类似&lt;&amp;gpio5 7 GPIO_ACTIVE_LOW&gt;的属性信息转换为对应的 GPIO 编号，此函数在驱动中使用很频繁！函数原型如下： int of_get_named_gpio(struct device_node *np, const char *propname, int index) 函数参数和返回值含义如下： np：设备节点。 propname：包含要获取 GPIO 信息的属性名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94fd729e52f1b079454b04ab195d69f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4d8edac412d6ded3c1cb112f5cdc34/" rel="bookmark">
			【算法】放货物
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 小明是一名快递员，他现在手上一共有N个快件需要运送。但是货车有限，所以我们希望用最少的货车来进行工作。现在已知，一辆车的限定额度为最多放置K件货物。此外，小明很不喜欢13这个数字，所以他不希望任何一辆货车中的货物数量为13。 现在小明想要知道，最少使用多少辆货车能够将这N个快件都放置到货车上。
输入描述： 题目包含多组输入，每一组输入一行两个数，分别表示N 和 K 1&lt;=N&lt;=1000 1&lt;=K&lt;=1000
输出描述： 输出一行一个数字，表示最优结果。
示例 输入 13 13
5 2
输出 2
3
分析 从题可知，要想让使用的货车数量最少，则应尽量将货车装满。由于货车不能装13件货物，但可以装大于或者小于13件货物，所以可以将输入的K(货车最大放置货物数)分为三种情况：
1、K &lt; 13：无需考虑货物装13件货物的情况，即货车的最大满载量就是K，此时使用最少货车数量应该是：货物总量 / 货车最大满载量，且如果货物总量 / 货车最大满载量有余数则还需要再加一辆货车，如果没有余数则不需要再加货车。
2、K == 13：需要考虑货物装13件货物的情况，此时货车的最大满载量应该是12，则使用最少货车数量应该是：货物总量 / 12，且如果货物总量 / 12有余数则还需要再加一辆货车，如果没有余数则不需要再加货车。
3、K &gt; 13：需要考虑货物装13件货物的情况，此时货车的最大满载量就是K，则使用最少货车数量应该是：货物总量 / 货车最大满载量，且如果货物总量 / 货车最大满载量有余数则还需要再加一辆货车，如果没有余数则不需要再加货车，如果该余数刚好是13，则还需要再加一辆车，即将这最后余下的分到两辆车。
参考代码 C语言实现
#include &lt;stdio.h&gt; int solution(int N, int K) { int result; // TODO: 请在此编写代码 if (K &lt; 13) { result = N / K + (N % K &gt; 0); } else if (K == 13) { result = N / 12 + (N % 12 &gt; 0); } else if (K &gt; 13) { result = N / K; if (N % K &gt; 0) { result += 1; if (N % K == 13) { result += 1; } } } return result; } int main() { int n, k; while (scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d4d8edac412d6ded3c1cb112f5cdc34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12d5b41b668343c4a8e035be608cdf91/" rel="bookmark">
			vue组件传参 &#43; vuex介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vue组件传参 1.父子传参 父传子：子组件通过props接收
props: { 参数名: { type: Object, default: function () { return {}; }, }, }, 子传父
子组件通过
@click="$emit('事件名', 参数)" 2.$parent传参 3. 跨层级访问数据呢（非父子关系） ，想要跨层级实现访问数据，就需要通过创建bus来进行
第一步、创建bus.js文件
//导入Vue import Vue from "vue" //创建Vue实例 var bus = new Vue(); //导出bus export default bus 第二步、在要发送数据的组件中导入bus import bus from "@/utils/bus.js"; 1 第三步、在有接受数据的组件中导入bus并使用bus.$on（注意this） created() { console.log(this.$children); bus.$on("msgchange", ($event) =&gt; { this.msg = $event; }); }, 3.2bus常用的三个方法 bus. o n （ e v e n t n a m e , c a l l b a c k ）监听事件 b u s .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12d5b41b668343c4a8e035be608cdf91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c702941df09ccae3d43eaa49d8d09e/" rel="bookmark">
			LeetCode——51. N-Queens（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode——51. N-Queens（C++）
The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.
Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space, respectively.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4c702941df09ccae3d43eaa49d8d09e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ba016866db4b989f16f8269302510b/" rel="bookmark">
			AXI3和AXI4协议详细说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本文详细介绍了AXI3和AXI4协议的读写过程，对比了它们之间的区别，列出了和协议相关的所有信号并加以说明。
关键词：AXI3；AXI4；读通道；写通道；握手机制
前言 本文基于ARM官方文档《AMBA AXI and ACE Protocol Specification》
因为AXI3和AXI4协议大部分相同，小部分不同，在官方文档中也是一起介绍的，所以本文将一起说明AXI3和AXI4，在两个协议不同的地方，会突出显示。
AMBA AXI 协议支持高性能高频率系统间主从元件间的通讯。AXI协议特征如下：
适合高带宽、低时延设计无用复杂即可提供高频操作&lt;可满足多种组件的接口要求适用于初始访问时延较高的内存控制器提供了实施互连架构的灵活性向后兼容AHB和APB接口 AXI协议的主要特征如下：
地址/控制阶段 与 数据阶段分离使用字节选通脉冲支持未对齐的数据传输使用基于突发的事务，仅发布起始地址独立的读写数据通道，可提供低成本的直接存储器访问(DMA)支持发布多个未完成的地址支持无序事务完成允许轻松添加寄存器级，以提供定时关闭 一. AXI架构 AXI有五个独立的通道：
写地址通道 Write address AW写数据通道 Write data W写响应通道 Write response B读地址通道 Read address AR读数据通道 Read data R 写/读地址通道包含控制信息。
写操作过程：
主机发送写地址/控制信号主机发送要写入的数据丛机发送写响应信号 读操作过程：
主机发送读地址/控制丛机发送读数据 二. 各通道信号 2.1 全局信号 信号源描述ACLK时钟源全局时钟信号，所有输入信号均在ACLK上升沿采样，所有输出信号的更改只能在ACLK上升沿之后。主从接口上的所有输入和输出信号间不允许有组合路径ARESETn复位源全局复位信号，为异步复位同步置位信号，即ARESETn在任意时刻变为低电平可立刻生效，但置位为1时只能在ACLK的下一个上升沿生效 协议规定，在ARESETn低电平有效时
主机必须驱动ARVALID，AWVALID 和 WVALID为低电平丛机必须驱动RVALID 和 RVALID为低电平其它信号能被驱动为任意值 ARESETn置位为1后，VALID最快能在ARESETn置位后的下一个ACLK时钟上升沿置高，如下图:
2.2 写地址通道信号 信号源必需/可选位宽默认值描述AWID主可选可变，协议未定义位宽， Xilinx使用0, 1, 2, … 32，一般为4全0写地址识别IDAWADDR主必需可变，协议未定义位宽， Xilinx使用12, 13, … 64，一般为32/64-要写入数据的内存地址AWLEN主可选8(AXI4是8位)
4(AXI3是4位)8’h00
4’h0数据是按份传输的，此信号表示接下来要写入的数据份数即数据量，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95ba016866db4b989f16f8269302510b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47907ac0b8fc01317e07b0c326390b5f/" rel="bookmark">
			洛谷P1001 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		洛谷P1001 题解 传送门
题意 输出两数之和
分析 本题数据范围是 − 1 0 9 ≤ a , b ≤ 1 0 9 -10^9 \le a,b \le 10^9 −109≤a,b≤109
用int绰绰有余
代码 #include &lt;bits/stdc++.h&gt; //万能头 using namespace std; //标准命名空间 int main() { int a,b; //定义变量 cin &gt;&gt; a &gt;&gt; b; //输入数据 cout &lt;&lt; a+b; //输出和 return 0; //别忘了返回0 } 注意事项 输出时直接使用+，不用另外定义变量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a697c80f928d379b06588bb130b0af7/" rel="bookmark">
			RISC-V学习基础（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RISC-V汇编语言 C程序翻译成为可以在计算机上执行的机器语言程序的四个经典步骤。
函数调用规范（Calling convention） 函数调用过程通常分为6个阶段：
将参数存储到函数能够访问的位置。跳转到函数开始位置（使用RV32I的jal指令jump and link）。获取函数需要的局部存储资源，按需保存寄存器。执行函数中的指令。将返回值存储到调用者能够访问到的位置，恢复寄存器，释放局部资源。返回调用函数的位置（使用ret指令）。 为了获得良好的性能，变量应该尽量存放在寄存器中，而不是内存中，但同时也要注意避免频繁地保持和恢复寄存器，因为它们同样会访问内存。
RISC-V有足够多的寄存器来达到两全其美的结果：既能将操作数存放在寄存器中，同时也能减少保存和恢复寄存器的次数。
其中关键点在于，在函数调用的过程中不保留部分寄存器存储的值（临时寄存器的值/另一些寄存器则对应称为保存寄存器）。不再调用其它函数的函数称为叶函数，当一个叶函数只有少量的参数和局部变量时，它们可以都被存储在寄存器中，而不会溢出spilling到内存中。如果函数参数和局部变量很多，程序还是需要把寄存器的值保存在内存中，但这种情况不多见。
函数调用中的寄存器：
当做保存寄存器来使用，在函数调用前后值不变。当做临时寄存器来使用，函数调用中不保留。函数会更改用来保存返回值的寄存器，因此它们和临时寄存器类似。用来给函数传递参数的寄存器也不需要保留，它们也类似于临时寄存器。用于存储返回地址的寄存器和存储栈指针的寄存器，要保证函数调用前后保持不变。图3.2列出了寄存器的RISC-V应用程序二进制接口(ABI)名称和它们在函数调用中是否保留的规定。
根据ABI规范，标准的RV32I函数入口： entry_label: addi sp,sp,-framesize # 调整栈指针(sp寄存器)分配栈帧 sw ra,framesize-4(sp) # 保存返回地址 # 按需保持其它寄存器 # 函数体 如果参数和局部变量太多，在寄存器中存不下，函数的开头会在栈中为函数帧分配空间来存放。当一个函数的功能完成后，它的结尾会释放栈帧并返回调用点。
# 按需恢复其它寄存器 lw ra,framesize-4(sp) # 恢复返回地址 addi sp,sp,framesize #释放栈帧空间 ret # 返回调用点 汇编器 汇编器的作用不仅仅是产生处理器能够理解的目标代码，还可以翻译一些扩展指令，这些指令对汇编程序员或者编译器的编写者来说通常很有用。这类指令在巧妙配置常规指令的基础上实现，称为伪指令。
图3.3和3.4列出了RISC-V伪指令，前者中要求x0寄存器始终为0，后者没有此要求。
之前提到的ret实际上是一个伪指令，汇编器会用jalr x0,x1,0来替换它。大多数RISC-V伪指令依赖于x0。
因此，把一个寄存器硬编码为0便于将许多常用指令——如跳转(jump)、返回(return)、等于0时转移(branch one equal to zero)——作为伪指令，从而简化RISC-V指令集。
图3.5为经典的C程序Hello World，编译器产生的汇编指令如图3.6，其中使用了图3.2的调用规范和图3.3、3.4的伪指令。
汇编程序的开头是一些汇编指示符(assemble directives)，它们是汇编器的命令，具有告诉汇编器代码和数据的位置、指定程序中使用的特定代码和数据常量等作用。
图3.6用到的指示符有：
.text：进入代码段。.align 2：后续代码按22字节对齐。.global main：声明全局符号“main”。.section .rodata：进入只读数据段.balign 4：数据按4字节对齐。.string “Hello,%s!\n”：创建空字符结尾的字符串。.string “world”：创建空字符结尾的字符串。 汇编器产生如图3.7的目标文件，格式为标准的可执行可链接文件（ELF格式）。
链接器 链接器允许各个文件独立地进行编译和汇编，这样在改动部分文件时，不需要重新编译全部源代码。
链接器把新的目标代码和已经存在的机器语言模块（如库函数）等拼接起来。
链接器这个名字原于它的功能之一，即编辑所有对象文件的跳转并链接。
图3.10展示了一个典型的RISC-V程序分配给代码和数据的内存区域，链接器需要调整对象文件的指令中程序和数据的地址，使之与图中地址相符合。如果输入文件中的是与位置无关的代码(PIC)，链接器的工作量会有所降低。PIC中所有的指令转移和文件内的数据访问都不受代码位置的影响。RV32I的相对转移(PC-relative branch)特性使得程序更易于实现PIC。除了指令，每个目标文件还包含一个符号表，存储了程序中标签，由链接过程确定地址。其中包含了数据标签和代码标签，图3.6中有两个数据标签(string1和string2)和两个代码标签(main和printf)需要确定。由于在单个32位指令中很难指定一个32的地址，RV32I的链接器通常腰围每个标签调整两条指令。如图3.6所示：数据标签需要调整lui(load upper immediate)和addi(add immediate)，代码标签需要调整auipc（add upper immediate to pc）和jalr(jump and link register).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a697c80f928d379b06588bb130b0af7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c243149d7edf7c619540013b28ecbfa4/" rel="bookmark">
			组件传参&#43;Vuex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE中的几种组件传参方式 对于vue来说常见的就是兄弟传值，父子传值
1.父传子 在父组件中定义数据，子组件通过props接收父组件传递的数据加以使用
父组件
&lt;div class="box"&gt; &lt;p&gt;这是父组件&lt;/p&gt; &lt;son :list="list"&gt;&lt;/son&gt; &lt;/div&gt; 子组件
props:['list'], //接收到父组件数据 2.子传父 子组件向父组件传递参数
3.兄弟组件传值 非父子组件之间传值，需要定义个公共的公共实例文件bus.js，作为中间仓库来传值，不然路由组件之间达不到传值的效果。
bus.js
//导入vue import Vue from "vue"; //导出vue创建的空实例 var bus = new Vue(); export default bus; &lt;template&gt; &lt;div class="nav" :style="{backgroundColor:bg_color,color:text_color}"&gt; &lt;div class="left" @click="$emit('left-click',$event)"&gt; &lt;slot name="icon_left"&gt;&lt;/slot&gt;{{left_text}} &lt;/div&gt; &lt;div class="title"&gt; &lt;slot name="title"&gt;&lt;/slot&gt;{{title}} &lt;/div&gt; &lt;div class="right" @click="$emit('right-click',$event)"&gt; {{right_text}} &lt;slot name="icon_right"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;p :style="{'backgroundColor':myColor}" @click="$parent.outNum++"&gt;访问父组件outNum:{{$parent.outNum}}&lt;/p&gt; &lt;p&gt;来自APP组件:{{myMsg}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;style lang="scss" scoped&gt; .nav { height: .88rem; line-height: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c243149d7edf7c619540013b28ecbfa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a8829ccd68ad502794c57bc90789b93/" rel="bookmark">
			OpenJudge小组NOI / 1.1编程基础之输入输出08:字符三角形（C&#43;&#43;&amp;C语言&amp;Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenJudge - 08:字符三角形 http://noi.openjudge.cn/ch0101/08/
总时间限制: 1000ms
内存限制: 65536kB
描述
给定一个字符，用它构造一个底边长5个字符，高3个字符的等腰字符三角形。
输入
输入只有一行， 包含一个字符。
输出
该字符构成的等腰三角形，底边长5个字符，高3个字符。
样例输入
* 样例输出
* *** ***** 状态: Accepted
源代码（C++） #include&lt;iostream&gt; #include&lt;cstdlib&gt; using namespace std; int main() { char a; cin&gt;&gt;a; cout&lt;&lt;" "&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;" "&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;endl; system("pause"); return 0; } 结果截图 基本信息 #:
11273386
题目:
08
提交人:
友利奈绪qwq
内存:
200kB
时间:
0ms
语言:
G++
提交时间:
2017-11-05 10:34:42
状态: Accepted
源代码（C语言） #include&lt;stdio.h&gt; int main() { char u; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a8829ccd68ad502794c57bc90789b93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d32879428f2ac483c98ca7a00e985ae/" rel="bookmark">
			解决办法：jupyter notebook 无法导入自己安装的包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 在使用jupyter notebook跑代码时，
明明在虚拟环境（虚拟环境名字就是pytorch）中安装了pytorch，但是在导包的时候却报错，找不到对应的安装包
jupyter notebook中输入运行如下代码，看看虚拟环境中的python库目录，发现里边根本没有包含我的虚拟环境所在路径 (我的虚拟环境路径是：C:\others\my_software\anaconda\envs\pytorch\Lib\site-packages )。
import sys sys.path 解决办法： 添加环境变量PYTHONPATH和site-packages安装包的路径
再次查看虚拟环境中的python库目录，发现里包含我的虚拟环境所在路径 (我的虚拟环境路径是：C:\others\my_software\anaconda\envs\pytorch\Lib\site-packages )。
import sys sys.path 此时就可以正常导包了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63c0a3fa6a16cd68d1790f844dc9274/" rel="bookmark">
			5G网络架构与组网部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解5G网络整体架构、熟悉5G核心网与接入网的网络部署。
一、5G网络架构及演进概述 Rel:工作规划
冻结时间：工作规划结束时间
5G网络概述 4G/5G的核心网：EPC/5GC
4G/5G的接入网：E-UTRAN/NG-RAN
5G核心网三大主要功能:AMF、UPF、SMF
5G接入网：gNB(5G基站)、 ng-eNB(接入5G核心网的4G基站)、 en-gNB(接入4G核心网的5G基站)、eNB(4G基站)
接口：NG接口（5G核心网与基站之间）、S1链路（4G核心网与基站之间）、 Xn接口(5G的基站之间) 、X2接口（4G基站之间）
NG-C/NG-U：基站通过该接口连接到AMF/UPF
E1：连接CU-C和CU-U
F1-C/F1-U：连接DU和CU-C/CU-U
5G网路架构整体部署 趋势:
中心处理虚拟化（上层）（SDN软件定义网络/NFV网络功能虚拟化）：把网元功能软件化，使其实现在通用服务器上。用户可以在边缘云获得服务，而不用跑到核心云。
多种接入架构并存（下层）：前向兼容，还需要在不同场景采用不同的接入架构。
不同接入架构其实是对协议的不同划分：
传统BBU+RRU 、picoRRU=RRU+天线、 Smallcell=BBU+RRU+天线（室内）
CU+DU+AAU：对BBU、RRU的功能进行了重构
一体化DU=DU+AAU
RAN网络架构变迁 3层-&gt;2层-&gt;3层，为了场景化需求和集中控制（集中调度、超密集组网、CRAN、MEC），牺牲时延最大限度利用好资源，因为可以把集中单元CU放在一个地方，让一个CU连很多个DU。
4G到5G的演进 MEC：从5GC剥离出来，小核心网，放在集中的部分（靠近和远离核心网，降低时延，提升用户访问内容效率体验，减少上层网络的流量压力，资源池化实现负载均衡，使5G网络部署灵活更好去面对时延和带宽的不确定性）
CU：BBU中非实时的部分
DU:BBU中实时部分+BBU剩下的物理层
AAU：BBU物理层+RRU+天线
5G接入网架构 控制面（虚线）锚点：负责控制
数据面（实线）分流点：负责数据分流
由于option3x的核心网是4G的，因此对5G新业务支持困难。option4已经具备了5G的基站和核心网，还存在4G的基站增加网络复杂度。option7的4G基站需要升级才能接入5G的核心网，4G迟早会退网，因此升级是没有必要的，升级后可能也无法跟随5G发展。
5G接入网演进路线 二、5G核心网架构与部署 5G核心网发展演进 4G~5G核心网架构的演进 基于服务的5G网络架构，网络功能服务既能提供也能使用服务，与其他服务无需使用固定通道，优化通信路径。
互联网化、开放的设计理念 核心网关键技术 CUPS（控制与用户面分离） 当控制面与用户面未分离且业务量增大时，对用户面进行扩容时，控制面也会跟着扩容。当增加新功能要对网元进行升级时也会遇到这种情况，无法单独部署，造成资源的浪费。
计算与存储分离 SBA(基于服务的网络架构) “云原生”：设计软件时就考虑如何在云上运行。
由服务提供者或者是NRF去确定服务使用者是否有调用权限。
网络切片 每个切片部署和需要的的网络功能服务是不一样的，我们是按需求去进行网络切片的。
除此之外还有切片的安全性和保密性。
5G核心网功能演进 5G网元功能 三、5G接入网架构与部署 5G接入网架构 选项3的数据分流点和控制面锚点均在增强LTEeNB。选项3a的数据分流点在EPC，增加了核心网的压力的同时减缓了增强LTEeNB的压力。选项3x的数据分流点在gNB，能最大限度地利用5G基站资源。
MCG：主承载
Split：辅承载/SCG(选项3a)
选项3a在核心网处进行分流，不能基于无线环境分流，无法根据无线环境进行及时调整。选项3x能基于无线环境进行调整，性能最好。
CU/DU分离及部署 左边的部分给CU，右边的部分给DU。
不同场景的部署
AAU=RRU+天线（对于MIMO技术提出的，节省馈线等资源）
如果DU和RRU连起来，对于fronthaul的时延要求小于5ms,不连接要求则低一些。
将所有的基带资源放在基带池中，各个小区之间能够协同管理、资源共享、集中调度，将大量的基带资源给最繁忙的RRU。
多一层架构时延会增加，要减少中间流程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a63c0a3fa6a16cd68d1790f844dc9274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33853ff7833f3f2dc058134ed05c1dde/" rel="bookmark">
			Apollo官方课程算法解读笔记——激光雷达感知模块、基于PointPillars的激光雷达点云检测算法、PointPillars模型的部署和优化模型的部署和优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		共勉 一、 Apollo 6.0激光雷达感知模块1.1 激光雷达简介1.2 激光雷达感知模块1.3 3D障碍物检测流程 二 、基于PointPillars的激光雷达点云检测算法2.1 基于Voxel的3D目标检测2.2 PointPillars模型原理讲解2.3 PointPillars的改进2.3.1 损失函数2.3.2. Pillar特征编码2.3.3 Multi-anchor&amp;multi-head 三 、PointPillars模型的部署和优化3.1 PointPillars模型的部署3.2 实时inference的加速优化 一、 Apollo 6.0激光雷达感知模块 1.1 激光雷达简介 感知模块检测效果：
左边为摄像头拍摄图像，激光雷达感知不依赖左边CAMERA，而是点云数据对应的效果图（黄色上方数字为Tracking ID）
主车红灯时的激光点云检测效果图
1.2 激光雷达感知模块 车道线给CAMERA提供一个标定参考，使得camera检测出来的障碍物从2维转化为3维的信息，因为此标定的参考，转化将更为精确；最后才做camera的目标跟踪。
首先从LIDER拿到点云数据，进行预处理，比如：去掉一些异常值的点（空值点，异常大的值或者截取一定范围内的点云数据）；接着对点云做目标检测（输出障碍物，带有位置信息的障碍物）；再对障碍物做目标跟踪，结合前几帧的信息根据Tracking ID判断障碍物的速度和朝向；最后再融合其它传感器，障碍物信息结果进行输出。
感知特点：全新算法，检测精准（PointPillars）
毫秒感知，实时可靠（10hz输出）
1.3 3D障碍物检测流程 左边为一个点云图，对其编码后转化为算法更容易理解更抽象的特征；再由网络/模型对左边提取出关键特征，再解码为我们需要的障碍物2维框，右图里绿色的框（框包围住了障碍物）。
二 、基于PointPillars的激光雷达点云检测算法 2.1 基于Voxel的3D目标检测 先前方法将点云数据转化为BEV（BirdsEyeView）再进行处理，实质是压缩后进行处理(有损压缩，并非原始数据处理)，那么为了提升效果就需要结合多传感器共同提高效果；而Voxel则不需要，点云分割为小格子，直接对点云数据做处理，通过LIDAR的数据结合神经网络层提取特征图。
但是Voxel需要进行三维卷积，耗时，占内存。
较之VoxelNet，去掉了3维卷积，简化为2维卷积，精度速度都更高效。
最大区别：点云转化为BEV的过程，PointPillars并非分割为小格子，而是按照xy平面网格划分为竖立的柱子，
2.2 PointPillars模型原理讲解 PFE是对VFE的一种简化。VFE得到global特征后会再复制一份与原始数据进行拼接。
2.3 PointPillars的改进 2.3.1 损失函数 Focal loss提出是为了缓解分类任务正负样本比例不均衡，α和γ为两个超参数，需要预先设定来调整损失函数的效果；但是用加权softmax函数后泛化性更好，检测效果也有所改善（其实就是对不同的类别加不同的权重）
2.3.2. Pillar特征编码 即PFE。此处改进在拿到点特征的时候，这个点云包含改点xy坐标和激光雷达反射率，也可以包含其他特征；先对xy做一个radius替换，初步变换，再进行下续操作；
为何用radius替换点特征呢
原点即为激光雷达传感器，x为车正前方，y为车正左方。
降了一维。
RPN是把点云转化为BEV特征图后的一个网络，用来输出最后的检测框和类别。
通过预先在网格点上设定好初始检测框，然后对应到特征图（通过卷积层得到的特征图）上面，通过后续处理得到候选框包含目标的概率分布值和候选框包含目标其目标对应的类别的概率分数，最后从候选框中选出模型要输出的目标。
Proposals 候选框：anchor, 2维检测里边，同一个目标在不同拍摄角度在图像里的尺寸不一（近则大，远则小），所以设定不同的anchor来进行匹配。
对点云做检测，右侧为检测后的图，
点云里边同一种目标经常是大小，甚至长宽高比例相似，比如图例的小轿车大小接近，就可以设定初始大小值为anchor初始值，
点云直接的距离是真实物理大小，和图像有区别，不需要考虑multi-direction（图像是因为有不同的像素尺寸）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33853ff7833f3f2dc058134ed05c1dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/390ea2866ead43644c2fa5188f196c77/" rel="bookmark">
			MySql8.0的my.cof文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[client] #针对客户端的设置
default-character-set = utf8 #指定字符集(mariadb默认是拉丁文)
port = 3306 #指定端口
socket = /data/mydata/mysql.sock #指定socket
[mysqld] #设置mysql-server相关信息
#指定运行用户为mysql(默认是以mysql用户运行的),经过试验,可以用非mysql之外的用户运行的
user = mysql default-storage-engine = InnoDB #指定默认引擎为innodb,(反正跟系统默认指定的没有冲突)
socket = /data/mydata/mysql.sock #略过
pid-file = /data/mydata/mysql.pid #略过
#禁止域名解析(优化)
skip-name-resolve #禁用DNS查询
skip-host-cache #禁止缓存主机名
#--skip-networking #禁用TCP/IP连接
https://blog.csdn.net/u010584271/article/details/80835378 这篇博客比较详细描述了这个问题
#跳过外部锁定(优化)
skip-external-locking #主要用于多进程条件下对Myisam表进行锁定,在锁定的过程中,每个进程若要访问数据需等之前的进程完成操作并解除锁定后才能访问数据表,大大提升安全性，同时也造成了性能的消耗,怎么用看大家把。
#连接优化
max_connections = 2000 #最大连接数(怎么设置等我有时间琢磨先)
max_allowed_packet = 64M #设置server接受数据包大小,数据包大于此值,将不会接收
table_open_cache = 2048 #主要设置table高速缓存数量(默认情况mysql服务器为2G内存设置256-512,4G内存则为2048,当然内存越大,你也可以设置更大)
#其他优化
explicit_defaults_for_timestamp = 1 #主要针对timetamp列进行优化,为1时允许默认为null值
lower_case_table_names = 0 #区分大小写
默认有3个值
0 表名进行存储或者比较(查询,检索)的时候都区分大小写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/390ea2866ead43644c2fa5188f196c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6750f374ef7122b28b2ff8c8943a076b/" rel="bookmark">
			RabbitMQ--基础--01--介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ–基础–01–介绍 1、介绍 是一套开源(MPL)的消息队列服务软件是由 LShift 提供的一个 Advanced Message Queuing Protocol (AMQP) 的开源实现由以高性能、健壮以及可伸缩性出名的 Erlang 写成。官网：https://www.rabbitmq.com/ 2、AMQP 是什么？ 高级消息队列协议，它使得遵从该规范的客户端应用和消息中间件服务器的全功能互操作成为可能客户端应用可以通过这个协议与消息代理和它实现的 AMQP 模型进行交互通信 2.1、实现原理图 3、MQ 是什么？ 全称 Message Queue ， 即消息队列是一种跨进程、异步的通信机制用于上下游传递消息，由消息系统来确保消息的可靠传递。开源、性能优秀，稳定性保障提供可靠性消息投递模式、返回模式与Spring AMQP完美整合，API丰富集群模式丰富，表达式配置，HA模式，镜像队列模型保证数据不丢失的前提做到高可靠性、可用性 3.1、优点 3.1.1、异步通信 将以前不必要的同步操作，优化成异步操作，提高性能
3.1.1.1、举例 如图所示。一个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是800ms。如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。
如图所示。这其实是MQ一个很重要的应用。假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃。
3.1.2、系统解耦 将原有A模块直接调用B模块的接口，优化成，A模块的请求给到MQ，A模块的事情就做完了MQ会主动推给B模块，或者B模块自己来拉 3.1.2.1、举例 如图所示。假设有系统B、C、D都需要系统A的数据，于是系统A调用三个方法发送数据到B、C、D。这时，系统D不需要了，那就需要在系统A把相关的代码删掉。假设这时有个新的系统E需要数据，这时系统A又要增加调用系统E的代码。为了降低这种强耦合，就可以使用MQ，系统A只需要把数据发送到MQ，其他系统如果需要数据，则从MQ中获取即可。
3.1.3、流量削峰 当某一时间大量的流量打到服务器上，服务器一时间无法承受，会宕机
这个时候，若请求都是从MQ队列里面出来，则能够保证这种大流量的情况下，服务器仍然能够有序的稳定的处理请求
3.1.4、日志处理 3.2、缺点 系统可用性降低，对外部有依赖了需要考虑 MQ 消息丢失，重复消费的问题需要花费精力保证消息的顺序性，一致性 3.3、MQ 如何避免消息堆积 提高消费速率(集群的方式)消费者批量获取消息进行消费 3.4、MQ 如何避免消费者重复消费(幂等性问题) 全局ID(增加标志位) + 保证业务一致性 3.5、MQ 如何保证消息不丢失 消息确认机制持久化消息 ACK 3.6、MQ 如何保证消息顺序一致性 绑定同一个消费者和队列
3.7、MQ 推与拉取架构模型是怎么样的？ MQ服务器与消费者建立长连接后，MQ服务器会主动推数据给到消费者当消费者第一次启动的时候，会去找MQ服务器拉数据 3.9、MQ 有哪些消费模式 3.9.1、推模式 注册一个消费者后，RabbitMQ会在消息可用时，自动将消息进行推送给消费者。这种方式效率最高最及时。
3.9.2、拉模式 属于一种轮询模型，发送一次get请求，获得一个消息。如果此时RabbitMQ中没有消息，会获得一个表示空的回复。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6750f374ef7122b28b2ff8c8943a076b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c50ed2f1ff5ed09fa873efe8d1dddac/" rel="bookmark">
			chnl_pkg——MCDF验证环境（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对mcdf这个验证项目，从顶层环境来看一共有：
第一个子模块是channel=node+fifo，按我自己的理解是接收apb总线从端写入过来的数据。
这里的问题是，mcdf的输入端数据的来源是？ 要写chnl_pkg，整体的结构是怎么样的？ 子模块的顶层环境是agent，agent包含了driver，sequencer，monitor，driver和seqr之间的通信通过两个组件自带的tlm端口实现。通过这个sequencer的item是chnl_trans，在sequence中产生。
其中，chnl_trans需要传递的包，包含的成员变量包括：数据本身，通道的id（有4个node），发包的间隔，数据之间的间隔，包与包之间的间隔，最后是发送完毕的单比特标志位rsp。
正文开始，按照自己的理解敲出来代码，然后再修正。
chnl_pkg 第一版本如下，一个class写完就订正吧。
//要写的是chnl_pkg，所以先写大标题 package chnl_pkg; //需要用到uvm，两句话少不了 import uvm_pkg::*; `includ "uvm_macro.svh" //正片开始,从小写到大，从item开始写 //chnl_trans继承于uvm_sequence_item类 class chnl_trans extends uvm_sequence_item; //声明随机变量，也就是包的成员变量，按照刚才说的 rand int [31:0] data[];//数据个数不确定，用动态数组，数据是32位的 rand int [ 1:0] chnl_id;//一共4个通道 rand int data_idle;//间隔的位数要用多少？怎么确定？ rand int pkg_idle;//同理 bit rsp;//标志位不用随机变量 //做约束，也就是初始化 constraint trans_cnst { //data的随机化按chnl_id左移8位+id先 soft data[i]=chnl_id&lt;&lt;8 + chnl_id; soft chnl_id=2'd0; soft data_idle inside {0:4}; soft pkg_idle inside {0:10}; } //然后做注册和域的自动化 `uvm_utils_begin(chnl_trans) `uvm_field_array_int(data[i], UVM_ALL_ON) `uvm_field_int(chnl_id, UVM_ALL_ON) `uvm_field_int(data_idle, UVM_ALL_ON) `uvm_field_int(pkg_idle, UVM_ALL_ON) `uvm_utils_end(chnl_trans) //然后是每个类都需要的new函数，item继承于trans事务类，又继承于object类 function void new (string "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c50ed2f1ff5ed09fa873efe8d1dddac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb94244813df0e7f89ad990df3627fbc/" rel="bookmark">
			Vue实战篇三十五：实现滑动拼图验证登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Vue基础篇一：编写第一个Vue程序
Vue基础篇二：Vue组件的核心概念
Vue基础篇三：Vue的计算属性与侦听器
Vue基础篇四：Vue的生命周期（秒杀案例实战）
Vue基础篇五：Vue的指令
Vue基础篇六：Vue使用JSX进行动态渲染
Vue提高篇一：使用Vuex进行状态管理
Vue提高篇二：使用vue-router实现静态路由
Vue提高篇三：使用vue-router实现动态路由
Vue提高篇四：使用Element UI组件库
Vue提高篇五：使用Jest进行单元测试
Vue提高篇六： 使用Vetur+ESLint+Prettier插件提升开发效率
Vue实战篇一： 使用Vue搭建注册登录界面
Vue实战篇二： 实现邮件验证码发送
Vue实战篇三：实现用户注册
Vue实战篇四：创建多步骤表单
Vue实战篇五：实现文件上传
Vue实战篇六：表格渲染动态数据
Vue实战篇七：表单校验
Vue实战篇八：实现弹出对话框进行交互
Vue实战篇九：使用省市区级联选择插件
Vue实战篇十：响应式布局
Vue实战篇十一：父组件获取子组件数据的常规方法
Vue实战篇十二：多项选择器的实际运用
Vue实战篇十三：实战分页组件
Vue实战篇十四：前端excel组件实现数据导入
Vue实战篇十五：表格数据多选在实际项目中的技巧
Vue实战篇十六：导航菜单
Vue实战篇十七：用树型组件实现一个知识目录
Vue实战篇十八：搭建一个知识库框架
Vue实战篇十九：使用printjs打印表单
Vue实战篇二十：自定义表格合计
Vue实战篇二十一：实战Prop的双向绑定
Vue实战篇二十二：生成二维码
Vue实战篇二十三：卡片风格与列表风格的切换
Vue实战篇二十四：分页显示
Vue实战篇二十五：使用ECharts绘制疫情折线图
Vue实战篇二十六：创建动态仪表盘
Vue实战篇二十七：实现走马灯效果的商品轮播图
Vue实战篇二十八：实现一个手机版的购物车
Vue实战篇二十九：模拟一个简易留言板
Vue项目实战篇一：实现一个完整的留言板（带前后端源码下载）
Vue实战篇三十：实现一个简易版的头条新闻
Vue实战篇三十一：实现一个改进版的头条新闻
Vue实战篇三十二：实现新闻的无限加载
Vue实战篇三十三：实现新闻的浏览历史
Vue实战篇三十四：给新闻WebApp加入模拟注册登录功能
Vue项目实战篇二：实现一个完整的新闻WebApp客户端（带前端源码下载）
文章目录 系列文章目录一、背景二、引入滑动拼图验证组件三、修改登录页面四、效果演示五、源码地址 一、背景 在前面的文章中，我们编写过登录页面。用户在登录时需要输入账号与密码，再点击登录按钮进行登录。
这次，我们将设置滑块拼图进行登录验证，以防止恶意的机器人登录。
二、引入滑动拼图验证组件 我们将引入vue-monoplasty-slide-verify组件，实现滑动拼图验证。GitHub网址演示网址
安装组件 npm install --save vue-monoplasty-slide-verify 在main.js文件中导入组件 import Vue from 'vue' .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb94244813df0e7f89ad990df3627fbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/196dc180b20a710630d267c1238f61be/" rel="bookmark">
			vscode解决cuda头文件与普通c&#43;&#43;头文件不能同时跳转的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、语言设置为cuda-cpp
2、configuration Provide取消关联cmake文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/763a6f1c11cf0bb69bec79defca95cfc/" rel="bookmark">
			自定义注解实现RBAC权限校验，不要再说你不会了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、实现思路
3、编码实战
3.1、准备
3.2、数据库表准备
3.3、自定义注解
3.4、拦截器
3.5、接口使用
3.6、测试
3.7、结论
4、结束语
1、前言 学过Spring Security的小伙伴都知道，SpringBoot项目可以集成Spring Security做权限校验框架，然后在Controller接口上直接使用@PreAuthorize注解来校验权限，但是如果我不想引入像Security、Shiro等第三方框架，也要实现权限校验的效果，该怎么做呢？
接下来就给大家介绍一种方案：拦截器+自定义注解做基于RBAC模型的权限校验
2、实现思路 首先数据库需要有基于RBAC模型的表，我们这里用最简单的5张表做示例：用户表、角色表、权限表、用户角色关联表、角色权限关联表
用户每次登录成功后，都需要联表查询该用户拥有的权限集合字符串，加密到token串中（此处可以使用JWT），返回给前端，前端存储到浏览器中，以后每次请求后台接口时，都将此token取出，放到请求头信息中，带到后台
然后新建自定义注解，该注解用于接口上面，表示该接口需要校验访问者的权限
新建拦截器，对所有请求方法的请求进行拦截，然后判断是否有自定义注解，如果有的话，取出权限字符串，和请求头中token的权限字符串集合进行比对，如果包含其中，则说明有权限访问该方法，如果不包含其中，就说明该用户没有权限访问该方法
3、编码实战 3.1、准备 这里我准备了一个SpringBoot基础环境代码，我会在此基础上进行集成，代码我已上传，地址如下：
SpringBootBase: SpringBoot基础项目框架
基础薄弱的同学，可以下载下来，跟我下面的步骤一步一步走，就可以出来效果了，再集成到你自己的项目中
3.2、数据库表准备 5张表准备：
用户表：
CREATE TABLE `sys_user` ( `user_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户ID', `dept_id` bigint(20) DEFAULT NULL COMMENT '部门ID', `position_id` varchar(5) DEFAULT NULL COMMENT '职位ID', `class_id` bigint(20) DEFAULT NULL COMMENT '班级ID', `user_name` varchar(30) NOT NULL COMMENT '用户账号', `nick_name` varchar(30) NOT NULL COMMENT '用户昵称', `user_type` varchar(2) DEFAULT '00' COMMENT '用户类型（00系统用户）', `email` varchar(50) DEFAULT '' COMMENT '用户邮箱', `phonenumber` varchar(11) DEFAULT '' COMMENT '手机号码', `sex` char(1) DEFAULT '0' COMMENT '用户性别（0男 1女 2未知）', `avatar` varchar(300) DEFAULT '' COMMENT '头像地址', `password` varchar(100) DEFAULT '' COMMENT '密码', `status` char(1) DEFAULT '0' COMMENT '帐号状态（0正常 1停用）', `del_flag` char(1) DEFAULT '0' COMMENT '删除标志（0代表存在 2代表删除）', `login_ip` varchar(128) DEFAULT '' COMMENT '最后登录IP', `login_date` datetime DEFAULT NULL COMMENT '最后登录时间', `create_by` varchar(64) DEFAULT '' COMMENT '创建者', `create_time` datetime DEFAULT NULL COMMENT '创建时间', `update_by` varchar(64) DEFAULT '' COMMENT '更新者', `update_time` datetime DEFAULT NULL COMMENT '更新时间', `remark` varchar(500) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`user_id`), UNIQUE KEY `un_user_name` (`user_name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户信息表'; 角色表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/763a6f1c11cf0bb69bec79defca95cfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b2c0c77c2372614940f307246a31ad/" rel="bookmark">
			easyconnect mac版下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址如下：
x​​​​​​​http://download.sangfor.com.cn/download/product/sslvpn/pkg/mac_ec_sp/EasyConnect.dmg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed42992cae6dc8ba0a5383881d5d56b/" rel="bookmark">
			STA系列 - 如何看懂时序报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【ASIC】时序分析实例之如何看懂时序报告
文章目录 背景正文 背景 本篇文章，是对b站UP主的视频讲解笔记，非常感谢这位UP。
正文 如图所示，其中PVT 代表的是 工艺、电压、温度，如图是slow模型，1.8v电压，125°的高温。
wire load model是用来估算线延迟，而这个mode为top，指的是估计线延迟的时候，是根据design的整个面积大小去估算的，比较保守。此外还有enclosed模式，以及延时最小的segmented模式。（具体可以查PT userguide）
如上图所示，其中r代表rise，f代表falling，因为对于数据而言rising和falling的耗时是不一样的。
如上图所示，因为电路存在不确定性，所以对于require time来说需要有uncertainty time这一项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ded48ba8e69ef2b0668064b6e964185/" rel="bookmark">
			Linux安装jdk过程中报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E325: ATTENTION
Found a swap file by the name “/etc/.profile.swp”
owned by: root dated: Wed Oct 19 22:03:58 2022
file name: /etc/profile
modified: no
user name: root host name: wy
process ID: 17649 (still running)
While opening file “/etc/profile”
dated: Sat Nov 7 16:43:48 2020
(1) Another program may be editing the same file. If this is the case,
be careful not to end up with two different instances of the same
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ded48ba8e69ef2b0668064b6e964185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d239d0c55e9acabef023942175acaebc/" rel="bookmark">
			GAN-生成对抗网络(Pytorch)合集(2)--pixtopix-CycleGAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pixtopix(像素到像素) 原文连接：https://arxiv.org/pdf/1611.07004.pdf
输入一个域的图片转换为另一个域的图片（白天照片转成黑夜）
如下图，输入标记图片，输出真实图片缺点就是训练集两个域的图片要一一对应，所以叫pixtopix，
网络结构有点复杂，用到了语义分割的UNET网络结构
数据集：
地址忘了，也是官方的，想起来补
代码：这里是建筑物labels to facade的例子
import torch import torch.nn as nn import torch.nn.functional as F from torch.utils import data import torchvision from torchvision import transforms import numpy as np import matplotlib.pyplot as plt import os import glob from PIL import Image # jpg是原始图片 images_path = glob.glob(r'base\*.jpg') annos_path = glob.glob(r'base\*.png') # png是分割的图片 transform = transforms.Compose([ transforms.ToTensor(), transforms.Resize((256, 256)), transforms.Normalize(0.5, 0.5) ]) class CMP_dataset(data.Dataset): def __init__(self, imgs_path, annos_path): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d239d0c55e9acabef023942175acaebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67f0d972bd6f3de2e8247d95ea6078be/" rel="bookmark">
			路由器连接光猫用桥接模式好还是用路由模式好？路由器桥接模式vs路由模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多家庭网络中的上网设备即有光猫又有路由器，那么光猫和路由器在家庭网络中各起什么作用呢？一般如何搭配使用可以满足资源利用最大化呢？怎么样搭配能让网络利用效率最高呢？
下面来解答以上问题，首先说说光猫和路由器各自的作用。
光猫和路由器 光猫 光猫是一个中文名称，猫是英文音译过来的，光猫的全称是光调制解调器，以前最基础的光猫设备是不带其他功能的，只是单纯的将光信号转换成RJ45端口的基于TCP/IP协议的电信号，而现在的光猫已经集成了完整的路由器功能，特别是比较好的光猫，都已经带usb口可以当媒体服务器使用了。
但是光猫为了兼容电信运营商的自己的网络架构，一般是在安装宽带时直接由运营商提供，还有就是光猫设备的激活和系统运行配置都需要电信运营商的工作人员来操作，用户能设置的参数比较少。
路由器 路由器是商业设备，它是提供网络数据转发功能的设备，与网络信号无关，输入和输出都是RJ45端口的电信号，都是基于TCP/IP协议，用户可以对路由器的配置和功能随意更改，与电信运营商没有关系。
区别 光猫和路由器最主要的区别是光猫是电信运营商提供的网络服务的一部分，提供基于TCP/IP协议的光电转换功能，而路由器则属于个人设备，用于基于TCP/IP协议转发网络数据包。
但目前的电信运营商有些宽带服务产品所提供的光猫里面已经集成了路由器功能，有的甚至还包括无线WIFI功能和媒体服务器功能等。
不过由于电信运营商提供的光猫产品的定位等方面的问题，导致单独使用光猫上网的方式在一些对网络功能需求多的场景完全不适用，这样就出现了光猫和路由器搭配使用的情况。
路由器上网模式 要更好的让光猫和路由器搭配使用，首先得了解路由器的三种主要的网络连接方式，拨号上网、桥接模式、路由模式
拨号上网 拨号上网是电信运营商采用的一种网络服务认证的网络连接方式，目前电信运营商提供的宽带服务基本都是采用拨号的方式来实现上网认证的，所以拨号的过程在上网当中必不可少，拨号上网需要一个拨号程序，目前的光猫、路由器、电脑等设备中都有集成这个拨号程序，而且拨号的动作需要占用光猫或者路由器等设备的硬件资源。
桥接模式 路由器的桥接模式相当于交换机，即主要起端口扩充和流量汇聚的作用，占用很少的硬件资源，如需更多了解，可以查看我的另一篇文章，上面有更详细的说明。
路由模式 路由模式就是路由器的主要功能，即管理和转发数据包，需要占用比较多的硬件资源，如需更多了解，可以查看我的另一篇关于路由器和交换机对比的文章，上面有更详细的说明。
总结 从以上分析可以得出结论，光猫的光电转换功能是无法被路由器替代的，另外当前大部分的网络服务商提供的光猫都带有路由器功能，也就是说光猫和路由器的功能是冗余的。
那么光猫和路由器搭配使用时，可以依据各自的性能进行搭配使用，如果光猫性能非常差，路由器性能非常好，建议直接使用路由器拨号和提供路由功能，如果两性能均衡，可以考虑光猫拨号，路由器提供路由功能，此种情况光猫的路由功能也是开启的，不过光猫只给下级路由器一个设备提供数据转发服务而已，如果光猫性能远超路由器，建议路由器直接使用桥接模式。
以上就是今天要分享的内容，感谢大家的关注，我们下次分享再见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c38ed21e03f1e47822b1271761a5ca5/" rel="bookmark">
			Kubernetes(k8s)基础之五：yaml文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s之yaml文件详解 文章目录 k8s之yaml文件详解1. k8s支持的文件格式2. YAML语言格式3. 查看api资源版本标签4. 编写nginx-test.yaml资源配置清单4.1 编写资源配置清单4.2 创建资源对象4.3 查看创建的pod资源 5. 创建service服务对外提供访问并测试5.1 编写nginx-svc-test.yaml5.2 创建资源对象5.3 查看创建的service5.4 访问测试 6. 详解k8s中的port7. 试运行生成yaml模板后创建实例7.1 --dry-run：试运行7.2 查看生成yaml格式7.3 查看生成json格式7.4 yaml和json的主要区别7.5 使用yaml格式导出生成模板7.6 删除一些不必要的参数7.7 使用yaml模板创建实例 8. 将现有资源生成yaml模板导出并保存为文件8.1 --expose：查看现有资源的yaml配置清单8.2 保存到文件中 9. explain：查看字段帮助信息10. 获取资源配置清单的总结 1. k8s支持的文件格式 Kubernetes支持YAML和JSON格式管理资源对象
JSON格式：主要用于api接口之间消息的传递
YAML格式：用于配置和管理，YAML是一种简洁的非标记性语言，内容格式人性化，较易读
2. YAML语言格式 ● 大小写敏感
● 使用缩进表示层级关系
● 不支持Tab键制表符缩进，只使用空格缩进
● 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可，通常开头缩进两个空格
● 符号字符后缩进一个空格，如冒号，逗号，短横杠（-）等
● “—”表示YAML格式，一个文件的开始，用于分隔文件
● “#”表示注释
3. 查看api资源版本标签 kubectl api-versions
[root@master ~]# kubectl api-versions admissionregistration.k8s.io/v1beta1 apiextensions.k8s.io/v1beta1 apiregistration.k8s.io/v1 apiregistration.k8s.io/v1beta1 apps/v1 apps/v1beta1 apps/v1beta2 authentication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c38ed21e03f1e47822b1271761a5ca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08e70c385364c7d5ed9c1015c1210a3/" rel="bookmark">
			RT-Thread学习笔记（二）之STM32
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RT-Thread内核框架及功能
1.1 内核框架
在上一讲中，我们对RT-Thread进行了介绍以及如何创建一个RTT的标准工程，接下来我们对RT-Thread的内核进行介绍。
内核是操作系统最基础也是最重要的部分。下图为 RT-Thread 内核架构图，内核处于硬件层之上，内核部分包括内核库、实时内核实现。
内核库是为了保证内核能够独立运行的一套小型的类似C库的函数实现子集。这部分根据编译器的不同自带C库的情况也会有些不同，当使用GNUGCC编译器时,会携带更多的标准C库实现。
实时内核的实现包括:
（1）对象管理。
（2）线程管理及调度器。
（3）线程间通信管理。
（4）时钟管理。
（5）内存管理。
（6）设备管理。
内核最小的资源占用情况是3KB ROM，1.2KB RAMe
1.2 内核功能
1.2.1 线程调度
线程是RT-Thread操作系统中最小的调度单位，线程调度算法是基于优先级的全抢占式多线程调度算法，即在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的，包括线程调度器自身。支持256个线程优先级（也可通过配置文件更改为最大支持32个或8个线程优先级，针对STM32默认配置是32个线程优先级)，0优先级代表最高优先级，最低优先级留给空闲线程使用;同时它也支持创建多个具有相同优先级的线程，相同优先级的线程间采用时间片的轮转调度算法进行调度，使每个线程运行相应时间;另外调度器在寻找那些处于就绪状态的具有最高优先级的线程时，所经历的时间是恒定的，系统也不限制线程数量的多少，线程数目只和硬件平台的具体内存相关。
1.2.2 时钟管理
RT-Thread的时钟管理以时钟节拍为基础，时钟节拍是 RT-Thread操作系统中最小的时钟单位。RT-Thread的定时器提供两类定时器机制:第一类是单次触发定时器，这类定时器在启动后只会触发一次定时器事件，然后定时器自动停止。第二类是周期触发定时器，这类定时器会周期性的触发定时器事件，直到用户手动的停止定时器否则将永远持续执行下去。
另外，根据超时函数执行时所处的上下文环境，RT-Thread的定时器可以设置为HARD_TIMER模式（硬件定时器）或者SOFT_TIMER模式（软件定时器）。
通常使用定时器定时回调函数（即超时函数)，完成定时服务。用户根据自己对定时处理的实时性要求选择合适类型的定时器。
1.2.3 线程间同步
RT-Thread采用信号量、互斥量与事件集实现线程间同步。线程通过对信号量、互斥量的获取与释放进行同步;互斥量采用优先级继承的方式解决了实时系统常见的优先级翻转问题。线程同步机制支持线程按优先级等待或按先进先出方式获取信号量或互斥量。线程通过对事件的发送与接收进行同步;事件集支持多事件的“或触发”和“与触发"，适合于线程等待多个事件的情况。
1.2.4 线程间通信
RT-Thread支持邮箱和消息队列等通信机制。邮箱中一封邮件的长度固定为4字节大小;消息队列能够接收不固定长度的消息，并把消息缓存在自己的内存空间中。邮箱效率较消息队列更为高效。邮箱和消息队列的发送动作可安全用于中断服务例程中。通信机制支持线程按优先级等待或按先进先出方式获取。
1.2.5 内存管理
RT-Thread支持静态内存池管理及动态内存堆管理。当静态内存池具有可用内存时，系统对内存块分配的时间将是恒定的;当静态内存池为空时，系统将申请内存块的线程挂起或阻塞掉(即线程等待一段时间后仍未获得内存块就放弃申请并返回，或者立刻返回。等待的时间取决于申请内存块时设置的等待时间参数)，当其他线程释放内存块到内存池时，如果有挂起的待分配内存块的线程存在的话，则系统会将这个线程唤醒。
动态内存堆管理模块在系统资源不同的情况下，分别提供了面向小内存系统的内存管理算法及面向大内存系统的 SLAB内存管理算法。
还有一种动态内存堆管理叫做memheap，适用于系统含有多个地址可不连续的内存堆。使用memheap可以将多个内存堆“粘贴”在一起，让用户操作起来像是在操作一个内存堆。
1.2.6 I/O设备管理
RT-Thread将 GPIO、I2C、SPl、USB、UART等作为外设设备，统一通过设备注册完成。实现了按名称访问的设备管理子系统，可按照统一的API界面访问硬件设备。在设备驱动接口上，根据嵌入式系统的特点，对不同的设备可以挂接相应的事件。当设备事件触发时，由驱动程序通知给上层的应用程序。
二、RTT内核启动流程
RT-Thread支持多种平台和多种编译器，而rtthread_startup()函数是RT-Thread
规定的统一启动入口。一般执行顺序是:系统先从启动文件开始运行，然后进入RT-
Thread 的启动rtthread_startup0，最后进入用户入口main)，如下图所示:
上述就是我们RT-Thread的启动过程，最后也还是会进入到我们的main()函数里面。
下面我们从工程代码里面来详细了解一下
之后跳转到rtthread_startup()函数就能看到我们上述所说的函数啦
最后，再跟大家介绍一下我们的开发中用到最多的用户线程初始化函数rt-application_init(),这个函数最终会调用到我们的main()函数里面。
函数中使用RT_USING_HEAP宏去决定我们是使用动态创建main线程还是使用静态创建线程。
rt_thread_create()函数代表的是使用动态创建的方法；
其中第一个参数“main”代表的是线程的名字，第二个参数main_thread_entry表示的是线程回调函数，第三个参数是线程回调函数的传入参数，这里没有传入参数，所以写的是RT_NULL；第四个参数RT_MAIN_THREAD_STACK_SIZE为线程栈的大小，第五个参数RT_MAIN_THREAD_PRIORITY是线程的优先级，第六个参数20为线程的时钟节拍。
从上面的宏我们可以看出“main”线程的栈大小为2048，优先级为10（数字越小，优先级越高）。
创建完线程之后就可以通过rt_thread_startup()函数去启动线程。
最后我们给大家看一下“main”的回调函数 main_thread_entry(),最后还是回到了我们的主函数main（）去运行程序。
这一章就先讲到这里，下一章我会详细介绍一下线程控制的一些知识以及如何使用动态创建线程和静态创建线程。
最后感谢一下千锋物联网。
04-RTT内核启动流程之C阶段_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b9b6872841d4fa9faefede3af10291/" rel="bookmark">
			lucene 分词源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lucene 分词源码分析 流程分析 借助于 ES 分词DSL 看一下 analyzer的组成：
# 可以看出一个 analyzer 由 char_filter(任意个) + tokenier(固定一个) + filter(任意个) # char_filter ：对原文中的char 进行中转换 # tokenier ： 将接收到的 text 切分出一系列的 token # filter ：对tokenier 切分出来的结果的增加、删除、更改 操作。 POST _analyze { "char_filter": [ { "type": "mapping", "mappings": [ "٠ =&gt; 0", "١ =&gt; 1", "٢ =&gt; 2", "٣ =&gt; 3", "٤ =&gt; 4", "٥ =&gt; 5" ] }, { "type": "pattern_replace", "pattern": """(\d+)-(?=\d)""", "replacement": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b9b6872841d4fa9faefede3af10291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bbc6ab4b17e9144bfb409152cba0609/" rel="bookmark">
			用django写端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近用django写了一个接口，完全从零接触，首先感谢师兄及同门的帮助，如果没有他们的帮助，我估计半个月都写不出来。我感触很深的事情是，把困难的事情分步做。第一天我直接在大工程里写代码调试，遇到各种问题，感谢师兄给我的问题集锦，我把相应的包都下载完了。第二天早上我看了一个同门推荐很有用的视频，但实际上我用不到数据库，只能另想他法。
1. 首先是下载django，直接pip install django就好了。
2. 由于我的pycharm是免费版，只能从终端打开django，参考链接(16条消息) Mac pycharm的newproject左侧没有出现项目选项的情况下，创建Django项目的解决方法./社区版pycharm创建django项目的方法_bcyichen的博客-CSDN博客_pycharm创建新项目左边没东西
3. 初次使用终端的编译器不是我的虚拟环境pytorch_cpu，参考过的方法有：
让Pycharm的Terminal进入创建好的虚拟环境 - 知乎 (zhihu.com)
这个链接提到了2种方法，第一种不行可以改第二种。第二种方法我的输入是这样的：
明天接着写：
关于A星的起点和终点路径画的时候是倒着的
关于拼接列表，拼接字典，字典转json
报错的原因是步长选取不合适
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac2f41370d4d38cd35cdcd81311a8f0/" rel="bookmark">
			Clbalt Strike安装及使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Clbalt Strike安装及使用详解 1 Clbalt Strike的特点2 Clbalt Strike 安装与环境配置（kali）2.1 其他linux系统安装jdk1 升级APT2 使用 APT 安装 OpenJDK 11：3 将 OpenJDK 11 设置为默认 Java 程序： 2.2 开始安装3 Clbalt Strike 安装与环境配置（Windows）3.1 下载Windows x64 OpenJDK：https://jdk.java.net/archive/3.2 环境变量配置 4 Cobalt Strike下载地址5 Cobalt Strike团队服务器启动6 Cobalt Strike客户端连接到团队服务（Linux）7 Cobalt Strike客户端连接团队服务（Windows）8 Cobalt Strik功能介绍9 创建一个监控**9.1 监控器链接方式简介****9.2 Beacon分类**9.2.1 DNS Beacon 9.2.2 HTTP 和 HTTPS Beacon9.2.3 SMB Beacon9.2.3 TCP Beacon 10 Cobalt Strik 目标主机信息收集11 Cobalt Strik 克隆网页并挂马1 配置网站克隆 2 挂马12 Cobalt Strik 邮件钓鱼12 将MSF会话注入Cobalt Strik监控1 环境准备：2 配置MSF创建监听3 使用CS进行监控 1 Clbalt Strike的特点 Clbalt Strike简称CS 用于团队作战使用，由一个服务端和多个客户端组成，能让多个攻击者这在一个团队服务器上共享目标资源和信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac2f41370d4d38cd35cdcd81311a8f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab627628d5a9212e60e5983ae522872/" rel="bookmark">
			MSF使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MSF使用详解 01 MSF发展史02 Linux安装MS03 kali更新msf04 Windows安装MSF课件05 MSF图形界面Viper06 MSF目录结构07Metasploit的核心模块08-09msfvenom常用参数（更新）10-11 msfconsole漏洞利用流程12 meterpreter介绍13 PHP后门反弹连接演示文档14 后渗透之访问文件系统15 后渗透之上传下载文件16 后渗透之屏幕截图17 后渗透之键盘记录18 后渗透之创建账户（Windows）19 后渗透之调用音频设备录音20 后渗透之提权21 后渗透之获取登录密码（Windows）22 后渗透之远程监控（Windows）23 后渗透之调用摄像头 01 MSF发展史 1 Metasploit-发展史
Metasploit框架使Metasploit具有良好的可扩展性，它的控制接口负责发现漏洞、攻击漏洞，提交漏洞，然后通过一些接口加入攻击后处理工具和报表工具。Metasploit框架可以从一个漏洞扫描程序导入数据，使用关于有漏洞主机的详细信息来发现可攻击漏洞，然后使用有效载荷对系统发起攻击，有效载荷就是在发现漏洞之后开发一种可行的攻击方法。其用于提取本地系统密码、安装其他软件或控制硬件等的模块，这些功能很像以前BO2K等工具所具备的功能。
2004年
2004年8月，在拉斯维加斯开了一次世界黑客交流会–叫黑帽简报（Black Hat Briefings). 在这个会议上，一款叫Metasploit 的攻击和渗透工具备受众黑客关注，出尽了风头。 Metasploit 是同 HD Moore 和 Spoonm等4名年轻人开发的，这款免费软件可以帮助黑客攻击和控制计算机，安全人员也可以利用 Metasploit 来加强系统对此类工具的攻击。Metasploit 的演示吸引了来自“美国国防部”和“国家安全局”等政府机构的众多安全顾问和个人，正如 Spoonm 在演讲中所说的, Metasploit 很简单，只需要求“找到目标，单击和控制”即可。 2004年 Metasploit 的发布在安全界引发了强烈的“地震”。
2005年
2005年6月，西雅图效区的微软公司总部园区内的管理情报中心，开了一次“蓝帽”会议。几百名微软公司的工程师和众多外界专家及黑客都被邀请进入微软帝国的中心。在会议中的黑客攻击演示中，当 Moore 向系统程序员们说明使用 Metasploit 测试系统对抗入侵的可靠程度时，Metasploit 让微软公司的开发人员再次感到不安。在程序员们看来，Metasploit 将会使系统安全面临严重的考验。 Metasploit (MSF) 在2003年以开放源码方式发布，是可以自由获取的开发框架。它是一个强大的开源平台，提供开发，测试和使用恶意代码，这个环境为渗透测试，为shellcode 编写和漏洞研究提供了一个可靠平台。 Metasploit框架直到2006年发布的2.7版本都用Perl脚本语言编写，由于Perl的一些缺陷，开发者于2007年底使用Ruby语言重写了该框架。到2007年年底，Spoonm和马特·米勒已经离开了项目。从2008年发布的3.2版本开始，该项目采用新的3段式BSD许可证。
2009年
2009年10月21号，漏洞管理解决公司Rapid7收购Metasploit项目。Rapid7承诺成立专职开发团队，仍然将源代码置于3段式BSD许可证下。
2 BSD许可证
相较于GPL许可证和MPL许可证的严格性，BSD许可证就宽松许多了，一样是只需要附上许可证的原文，不过比较有趣的是，它还要求所有进一步开发者将自己的版权资料放上去，所以拿到以BSD许可证发行的软件可能会遇到一个小状况，就是这些版权资料许可证占的空间比程序还大。
3 Metasploit发展前景
02 Linux安装MS 1 乌班图安装MSF
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ab627628d5a9212e60e5983ae522872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6113fbb5652982df68ca25e70cc69ec/" rel="bookmark">
			uniapp 获取手机号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. wxml &lt;u-button slot="right" customStyle="background: #21C9A0;border-radius: 0rpx 8rpx 8rpx 0rpx;color: #fff;" class="u-button-phone" type="info" open-type="getPhoneNumber" @getphonenumber="getPhoneNumber"&gt;获取手机号&lt;/u-button&gt; &lt;u-input type="number" v-model="formData.phone" clearable placeholder="请输入手机号" border="none"&gt;&lt;/u-input&gt; 2.js import { getPhone } from '@/api/index' methods:{ getPhoneNumber (e) { console.log(e.detail.code) getPhone({code:e.detail.code}).then(res =&gt;{ // 手机号 this.formData.phone = res.data.data.phoneInfo.purePhoneNumber; }).catch(err=&gt;{ uni.$u.toast('获取失败，请重试'); }) }, } 本人一向的宗旨：代码能说的清楚的尽量少bb。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7104eda14ed6205ec3391d1c695cb0d0/" rel="bookmark">
			Ajax异步请求阻塞情况的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况：同事在写Webform页面程序发现这样一个现象：在做导出功能时，由于导出数据的处理时间比较长，就在客户端加一个定时器通过ajax不间断查询导出进度。然后发现了一个情况，这个请求一直是阻塞的状态，直到导出事件处理完成之后。才去执行这个请求，也就是说如果响应时间长的请求还在进行中，短的请求却被挂起了。
连续用了两个异步请求去获取资源为什么反而加载更慢了呢？
原来是在进行异步请求时访问了session，为了安全考虑（避免单个用户并发请求导致的session数据错乱），.net中session实现了Reader/Writer的锁机制,当session具有读写功能时，采用排它锁来互斥的访问session数据，也就是说开启了session后，单个用户只能串行的访问这个站点，直到这个访问结束前，其他的请求都会进入等待状态，从而进入线程的顺序执行。
SessionReader/Writer的锁机制原理：当页面对Session具有可写功能（即页面有&lt;%@Page EnableSessionState="True" %&gt;标记），此时直到请求完成该页面的Session持有一个写锁定。
当页面对Session具有只读功能（即页面有&lt;%@Page EnableSessionState="ReadOnly" %&gt;标记），此时知道请求完成该页面的Session持有一个读锁定。
读锁定将阻塞一个写锁定；读锁定不会阻塞读锁定；写锁定将阻塞所有的读写锁定。这就是为什么两个框架中的同一个页面都去写同一个Session时，其中一个要等待另一个（稍快的那个）完成后，才开始写。
解决方案： “写锁定将阻塞所有的读写锁定”，也就是说页面在EnableSessionState="True"的情况下没返回输出时，一直持着Session写操作，其他页面对Session的读操作必须等待，而asp.net的aspx页面默认是EnableSessionState="True"，每个页面从请求开始至返回一直持着Session写操作，需验证页面必须读取Session值判断，这就是为什么需验证的页面请求被阻塞的原因。只要耗时页面（A页面）没有Session的写操作，也就不会阻塞其他页面的请求，于是修改A页面的EnableSessionState="ReadOnly"，例如：
&lt;%@ Page Language="C#" AutoEventWireup="true"CodeFile="TBS_Monitor_List.aspx.cs"EnableSessionState="ReadOnly" Inherits="TBS_Monitor_List" %&gt; ，问题解决。
结论：也就是说，在无需对session进行写操作的页面，在Page指令加上EnableSessionState="ReadOnly"属性，就不会造成Request阻塞的情况了。同样的，访问其他实现了锁机制的资源时也要注意锁造成的Request阻塞的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef1ae5ed4145ee959530590de83bfecf/" rel="bookmark">
			对象（object) 与数组（array)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对象（object) 与数组（array) 创建对象的几种方式 //方式1： 字面量 var obj = {a:1,b:2};//这个就是对象obj 中有两个属性 a, 和b,每个属性对应的值分别为1， 2 // 方式二： 构造函数 let tmp = {b:1} let obj2 = new Object(tmp) //传递有值的内容，返回该对象 // 如果tmp 值为null 或不传递值，则默认为空对象 // 方式三： 定制化创建对象。 // let obj3 = Object.create(null); // null 或 undefined 会返回一个新的 空对象 // Object.create(对象,{ 属性名:属性描述器对象}) let obj4 = Object.create({},{ // 定制化属性 ，属性描述，其中包括，myAge这个属性对应的值，以及属性对应的属性 myAge:{ //writable 默认为false,此时value不可修改 value:35, // 不能和get/set同用 writable:false, // 不能和get/set同用 } }); console.log('obj4:',obj4) var age = 1; let obj5 = Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef1ae5ed4145ee959530590de83bfecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/735bd366f74ac61dd07dbfcf976787b4/" rel="bookmark">
			eclipse 错误: 找不到或无法加载主类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看bin目录为空，无class文件
查看problems报错信息，发现项目build path中，引入了三个非jar文件。
remove非jar文件后恢复正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0cba65c7327608f74783f28e24793c1/" rel="bookmark">
			C语言实现通用链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一下在项目中使用的C语言实现的双向通用链表，代码如下：
/************************* * File node_link_list.h **************************/ #ifndef _NODE_LINK_LIST_H #define _NODE_LINK_LIST_H #ifdef __cplusplus extern "C" { #endif #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #include &lt;string.h&gt; #include &lt;stdarg.h&gt; #include &lt;stdlib.h&gt; // 节点,外部创建结构体将其挂在data成员上即可 typedef struct link_list_data_node { void * data; struct link_list_data_node * next; }link_list_data_node_t; // 链表 typedef struct node_link_list { link_list_data_node_t * head; // 头部 link_list_data_node_t * tail; // 尾部 unsigned int count; // 节点数 int (*equal)(void * data1, void * data2); }node_link_list_t; //迭代器 typedef struct node_link_list_iterator { link_list_data_node_t * node; unsigned int count; unsigned int all_size; } node_link_list_iterator_t; //创建链表 node_link_list_t * create_node_link_list(); //创建链表，带有相等参数，用于查找 node_link_list_t* create_search_link_list(int(*equal)(void * a, void * b)); //释放链表 void destroy_node_link_list(node_link_list_t * list); //释放链表的同时销毁数据节点，主要用于每个节点单独从分配内存后插入链表数据节点的情况 void destroy_node_link_list2(node_link_list_t * list, bool data_release); void destroy_node_link_list3(node_link_list_t * list, bool data_release, void (*data_node_release)(void *data)); //插入在头部 void node_link_list_insert_at_head(node_link_list_t * list, void* data); //插入在尾部 void node_link_list_insert_at_tail(node_link_list_t * list, void* data); //指定位置插入 void node_link_list_insert_at_index(node_link_list_t * list, void * data, unsigned int index); //删除头部 void* node_link_list_remove_at_head(node_link_list_t * list); //删除尾部 void* node_link_list_remove_at_tail(node_link_list_t * list); //删除指定位置的节点 void* node_link_list_remove_at_index(node_link_list_t * list, unsigned int index); //获取链表长度 unsigned int node_link_list_get_size(node_link_list_t * list); //打印 void node_link_list_print(node_link_list_t * list, void(*print)(void * data)); // 链表判空 int node_link_list_is_empty(node_link_list_t * list); //取得第一个数据 void* node_link_list_get_data_at_head(node_link_list_t * list); //取得最后一个数据 void* node_link_list_get_data_at_tail(node_link_list_t * list); //获取指定位置数据 void* node_link_list_get_data_at_index(node_link_list_t * list, unsigned int index); //获取指定位置数据 void * node_link_list_get_data_at_index2(node_link_list_t * list, unsigned int index); /* 查找某个数据的位置,如果equal方法为空，比较地址，否则调用equal方法 如果不存在返回-1，如果存在，返回出现的第一个位置 */ int node_link_list_find_data_index(node_link_list_t * list, void * data); //创建迭代器 node_link_list_iterator_t * create_node_link_list_iterator(node_link_list_t * list); //释放迭代器 void destroy_node_link_list_iterator(node_link_list_iterator_t * iterator); //迭代器是否有下一个元素, 0：表示无下一个元素 int node_link_list_iterator_has_next(node_link_list_iterator_t * iterator); //返回迭代器的下一个元素 void* node_link_list_iterator_next(node_link_list_iterator_t * iterator); //删除对象,返回是否删除成功 int node_link_list_remove_data_object(node_link_list_t * list, void * data); #ifdef __cplusplus } /* extern "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0cba65c7327608f74783f28e24793c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eefcb09c6583a7678b8a78704aea08a6/" rel="bookmark">
			js用户须知同意按钮倒计时案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;textarea name="" id="" cols="30" rows="10"&gt; 用户注册协议 欢迎注册成为京东用户！在您注册过程中，您需要完成我们的注册流程并通过点击同意的形式在线签署以下协议，请您务必仔细阅读、充分理解协议中的条款内容后再点击同意（尤其是以粗体或下划线标识的条款，因为这些条款可能会明确您应履行的义务或对您的权利有所限制）。 【请您注意】如果您不同意以下协议全部或任何条款约定，请您停止注册。您停止注册后将仅可以浏览我们的商品信息但无法享受我们的产品或服务。如您按照注册流程提示填写信息，阅读并点击同意上述协议且完成全部注册流程后，即表示您已充分阅读、理解并接受协议的全部内容，并表明您同意我们可以依据协议内容来处理您的个人信息，并同意我们将您的订单信息共享给为完成此订单所必须的第三方合作方（详情查看 &lt;/textarea&gt; &lt;br&gt; &lt;button class="btn" disabled&gt;我已经阅读用户协议(5)&lt;/button&gt; &lt;script&gt; //获取元素 const btn = document.querySelector('.btn') //设置按钮文字 let i = 5 const timer = setInterval(function(){ i-- btn.innerHTML = `我已经阅读用户协议${i}` if(i === 0){ clearInterval(timer) btn.innerHTML = '同意' btn.disabled = false } },1000) &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658739597efaa2b2b092fb7f10cf4a51/" rel="bookmark">
			使用Cmake封装API接口成Package方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是个人探究API封装成Package以让他人像使用OpeCV，PCL等第三方库那样方便时所总结的经验。
一、CmakeLists.txt的编写 1、基本工程实现 cmake_minimum_required(VERSION x.x) #最小Cmake版本要求
projiect() #工程名称
find_package() #引入第三方库
add_library() #编译代码为库文件，SHARED标志可以指定为动态库
2、特殊实现 target_include_directories(ImagePreprocess PUBLIC
$&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;
$&lt;INSTALL_INTERFACE:include&gt;)
设置目标库要链接的头文件路径，无论是API本身还是引用API的消费者都需要使用该目录下的头文件，所以使用PUBLIC标志；避免被使用时API的头文件路径不受编译路径影响，所以要分别设置BUILD_INTERFACE与INSTALL_INTERFACE。
target_link_libraries(ImagePreprocess PRIVATE vpi PUBLIC opencv_core)
设置API需要链接的库，其中vpi只由API自身使用，消费者不会直接使用vpi的相关函数或者变量，所以vpi使用PRIVATE标志；其中opencv_core被API使用，并且API的消费者也会使用其中的变量类型，所以采用PUBLIC标志。
install(TARGETS ImagePreprocess
DESTINATION ImagePreprocess/lib
EXPORT ImagePreprocessTargets)
安装库文件，较平时不同的是要加入EXPORT
install(FILES include/ImagePreprocess.h
DESTINATION ImagePreprocess/include)
安装头文件
install(EXPORT ImagePreprocessTargets
FILE ImagePreprocessTargets.cmake
DESTINATION ImagePreprocess/lib/cmake/ImagePreprocess)
生成ImagePreprocessTargets.cmake文件，并且安装在指定目录
include(CMakePackageConfigHelpers)
一个用于生成重定位配置文件的工具
configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in
ImagePreprocessConfig.cmake
INSTALL_DESTINATION "ImagePreprocess/lib/cmake/ImagePreprocess"
NO_SET_AND_CHECK_MACRO
NO_CHECK_REQUIRED_COMPONENTS_MACRO)
生成一个可以重定向的ImagePreprocessConfig.cmake，生成的ImagePreprocessConfig.cmake在build目录下
install(FILES
${CMAKE_CURRENT_BINARY_DIR}/ImagePreprocessConfig.cmake
DESTINATION ImagePreprocess/lib/cmake/ImagePreprocess
)
安装ImagePreprocessConfig.cmake到指定目录
二、Config.cmake.in编写 @PACKAGE_INIT@
默认写法
include(CMakeFindDependencyMacro)
find_dependency(OpenCV)
API消费者也需要使用的库的依赖传递
include("${CMAKE_CURRENT_LIST_DIR}/ImagePreprocessTargets.cmake")
常规写法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d773855918b9bd489416828c820d5e37/" rel="bookmark">
			CMake中find_library的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMake中的命令find_library用于库的查找，其格式如下：
find_library( &lt;VAR&gt; name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS [path | ENV var]... ] [PATHS [path | ENV var]... ] [REGISTRY_VIEW (64|32|64_32|32_64|HOST|TARGET|BOTH)] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC "cache documentation string"] [NO_CACHE] [REQUIRED] [NO_DEFAULT_PATH] [NO_PACKAGE_ROOT_PATH] [NO_CMAKE_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [NO_CMAKE_INSTALL_PREFIX] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) 将创建一个由&lt;VAR&gt;命名的缓存条目即cache变量，将&lt;VAR&gt;的值存入CMakeCache.txt中);或如果指定了NO_CACHE，由&lt;VAR&gt;命名的普通变量来存储此命令的结果。如果找到库，则结果(绝对路径+库全名)将存储在&lt;VAR&gt;中，除非清除&lt;VAR&gt;，否则不会重复搜索。如果没找到库，结果将为&lt;VAR&gt;-NOTFOUND。示例代码段如下：
unset(var CACHE) # 清除变量,带有CACHE也从缓存文件CMakeCache.txt中清除,若不带CACHE则缓存文件CMakeCache.txt中仍然存在var的值 find_library(var NAMES opencv_core) # 查找默认路径,默认查找动态库?在/usr/lib/x86_64-linux-gnu/目录下既有libopencv_core.so也有libopencv_core.a message("var: ${var}") # var: /usr/lib/x86_64-linux-gnu/libopencv_core.so # 如果找到库，则结果将存储在变量中，除非清除变量，否则不会重复搜索 find_library(var NAMES opencv_highgui) # 注意:未清除变量，不会重复搜索，最终结果是不对的，并没有查找opencv_highgui message("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d773855918b9bd489416828c820d5e37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cfd7fca2e2ec0cbe6d6b109c0fef1be/" rel="bookmark">
			【Web实战-Tomcat-Servlet-Thymeleaf -JDBC-MySQL】浏览器页面显示数据库数据（水果库存系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥇作者 .29. 的✔博客主页✔
🥇记录JavaWeb学习的专栏：Web专栏
🥇拼搏起来吧，未来会给你开出一个无法拒绝的条件…
您的点赞，收藏以及关注是对作者最大的鼓励喔 ~~
客户端展示库存数据 前言一、Thymeleaf - 视图模板技术1.导入 jar 包2.创建Servlet类，设置相关属性与方法。3.添加web.xml文件配置4.使用Thymeleaf技术相关的HTML标签属性 二、浏览器页面实现1.获取数据库数据2.使用Servlet组件渲染页面①`Servlet组件`②`HTML页面` 三、效果总结 前言 在JDBC专栏中，我们完成了水果库存系统功能的设计，实现以及优化，但总得来看，整个项目都是后端的代码，系统的页面也不过是通过控制台模拟而来的，而非真正的前端页面。
而在这篇文章开始，我们会对水果库存系统的客户端页面功能进行设计与实现，让库存系统可以在网页中使用。
项目中我们主要依赖Tomcat部署，使用Servlet组件，过程中通过JDBC连接MySQL数据库获取数据，将数据在浏览器页面中展现出来。
一、Thymeleaf - 视图模板技术 在开始，我们需要先了解一下Thymeleaf - 视图模板技术的使用，这是我们在使用Servlet时需要用到的技术。
接下来，我们通过 Thymeleaf 的使用来了解视图模板技术到底是什么。
1.导入 jar 包 需要使用Thymeleaf - 视图模板技术，第一步就是导入相关的 jar 包了，具体的步骤大家应该都了解，不了解的可以按照这篇文章的思路来尝试导入jar包：druid数据库连接池的使用。
Thymeleaf - 视图模板技术 jar包资源：
链接：https://pan.baidu.com/s/1NOucl2A8nEAIzg-rT4GqGg
提取码：leaf
2.创建Servlet类，设置相关属性与方法。 我们需要创建一个Servlet类，我将这个类命名为ViewBaseServlet，说其是Servlet类是因为它需要继承HttpServlet类。
ViewBaseServlet类中设置的是与使用Thymeleaf 技术相关的属性以及方法，我们可以通过代码来了解其功能：
import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.WebContext; import org.thymeleaf.templatemode.TemplateMode; import org.thymeleaf.templateresolver.ServletContextTemplateResolver; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class ViewBaseServlet extends HttpServlet { private TemplateEngine templateEngine; @Override public void init() throws ServletException { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cfd7fca2e2ec0cbe6d6b109c0fef1be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757f1d7886568d70e274b5f2c78a7b5b/" rel="bookmark">
			最近公共祖先（tarjan-塔杨算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		O（m+n）——离线算法
如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。
输入格式 第一行包含三个正整数 N,M,S，分别表示树的结点个数、询问的个数和树根结点的序号。
接下来 N−1 行每行包含两个正整数 x,y，表示 x 结点和 y 结点之间有一条直接连接的边（数据保证可以构成树）。
接下来 M 行每行包含两个正整数 a,b，表示询问 a 结点和 b 结点的最近公共祖先。
输出格式 输出包含 M 行，每行包含一个正整数，依次为每一个询问的结果。
样例输入 #1 5 5 4 3 1 2 4 5 1 1 4 2 4 3 2 3 5 1 2 4 5 样例输出 #1 4 4 1 4 4 数据范围 对于 30% 的数据，N≤10，M≤10。
对于 70% 的数据，N≤10000，M≤10000。
对于 100% 的数据，N≤500000，M≤500000。
样例解释 第一次询问：2,4 的最近公共祖先，故为 4。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/757f1d7886568d70e274b5f2c78a7b5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a707b329a7c964537b400631bad0a451/" rel="bookmark">
			【keil 5】进阶玩法：逻辑分析仪的使用（软件仿真）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备材料
二、Debug设置
三、使用逻辑分析仪
1、监听GPIO口
2、监听全局变量
四、缺点
在日常编写程序的时候，难免会遇到想要查看GPIO等外设的波形图，keil5就提供了一个非常方便的软件仿真的逻辑分析仪功能，能够基本满足我们的需求。
注意：keil 5的逻辑分析仪所监听的变量都要为全局变量才行，不然监听不了。
一、准备材料 野火-指南针开发板（STM32F103VET6）（无需使用仿真器，只是要提供对应的型号即可）
keil 5.36
二、Debug设置 1、将 Debug 设置设置为软件仿真。下面的两个框框如果不填写的话在仿真的时候会报 “error 65: access violation at 0x40021000 : no 'read' permission” 错误。一个是 DARMSTM.DLL ，一个是 TARMSTM.DLL。
三、使用逻辑分析仪 点击菜单栏上面的“Debug”按钮。
点开逻辑分析仪的窗口。（两个途径）
熟悉逻辑分析仪窗口。
开启实时显示波形功能。（不然的话只能让程序全速运行一会再让它停止才会有波形的出现）
1、监听GPIO口 ​​​​​
2、监听全局变量 如果添加失败，试试退出仿真模式，将 static 关键字删除后重新编译，再次进入仿真模式试试。
四、缺点 1、无法显示输入的波形。
2、可能精度没有专门的逻辑分析仪好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/243d0fb4f5a05434b509a62ee28a20ee/" rel="bookmark">
			C语言—阶乘的计算1！&#43;2！&#43;...&#43;10！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算1！+2！+…+10！ 第一种 #include&lt;stdio.h&gt;
int main()
{
int i = 0;
int n = 0;
int ret = 1;
int sum = 0;
for (n = 1; n &lt;= 10; n++)
{
ret = 1;
for (i = 1; i &lt;= n; i++)
{
ret = ret * i; //n的阶乘
}
sum = sum + ret;
}
printf(“ret = %d\n”, sum);
return 0;
}
第二种 #include&lt;stdio.h&gt;
int main()
{
int i = 0;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/243d0fb4f5a05434b509a62ee28a20ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97b88658641d379705c74cf4c9dcb5d/" rel="bookmark">
			mysql详细学习教程(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 数据库基本概念什么是数据库？什么是数据库管理系统？什么是SQL？它们之间的关系？ 安装MySQL数据库管理系统及需要注意的事项端口号字符编码方式服务名称选择配置环境变量path MySQL数据库的完美卸载！找MySQL的服务在哪里？在windows操作系统当中，怎么使用命令来启动和关闭mysql服务呢？mysql安装了，服务启动了，怎么使用客户端登录mysql数据库呢？MySQL常用命令：怎么选择使用某个数据库呢？怎么创建数据库呢？查看某个数据库下有哪些表？查看当前使用的是哪个数据库？ 数据库当中最基本的单元是表：table什么是表table？为什么用表来存储数据呢？ 关于SQL语句的分类？怎么将sql文件中的数据导入呢？导入的几张表查看表结构 简单查询查询一个字段查询部门名字查询两个字段，或者多个字段查询所有字段给查询的列起别名计算员工年薪 条件查询什么是条件查询？都有那些条件？ 排序查询所有员工薪资排序降序两个字段排序、多个字段排序了解：根据字段的位置也可以排序 综合案例练习数据处理函数数据处理函数又被称为单行处理函数常见的单行处理函数 分组函数（多行处理函数）分组查询（非常重要：五颗星*****）什么是分组查询？将之前的关键字全部组合在一起，来看一下他们的执行顺序？找出每个工作岗位的工资和？找出每个部门的最高薪资找出“每个部门，不同工作岗位”的最高薪资使用having可以对分完组之后的数据进一步过滤大总结（单表的查询学完了） 数据库基本概念 什么是数据库？ 数据库：英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。
顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。
什么是数据库管理系统？ 数据库管理系统：
DataBaseManagement，简称DBMS。
数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以
对数据库当中的数据进行增删改查。
常见的数据库管理系统：
MySQL、Oracle、MS SqlServer、DB2、sybase等…
什么是SQL？ SQL：结构化查询语言
程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL
语句，最终来完成数据库中数据的增删改查操作。
SQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，
同时在Oracle中也可以使用，在DB2中也可以使用。
它们之间的关系？ DBMS–执行–&gt; SQL --操作–&gt; DB
先安装数据库管理系统MySQL，然后学习SQL语句怎么写，编写SQL语句之后，DBMS
对SQL语句进行执行，最终来完成数据库的数据管理
安装MySQL数据库管理系统及需要注意的事项 第一步：先安装，选择“经典版”
第二步：需要进行MySQL数据库实例配置。
注意：一路下一步就行了！！！！！
mysql超级管理员用户名不能改，一定是：root
你需要设置mysql数据库超级管理员的密码。
我们设置为123456
设置密码的同时，可以激活root账户远程访问。
激活：表示root账号可以在外地登录。
不激活：表示root账号只能在本机上使用。
我这里选择激活了！
端口号 端口号port是任何一个软件/应用都会有的，端口号是应用的唯一代表。
端口号通常和IP地址在一块，IP地址用来定位计算机的，端口号port
是用来定位计算机上某个服务的/某个应用的！
在同一台计算机上，端口号不能重复。具有唯一性。
mysql数据库启动的时候，这个服务占有的默认端口号是3306
这是大家都知道的事儿。记住。
字符编码方式 设置mysql数据库的字符编码方式为 UTF8
一定要注意：先选中第3个单选按钮，然后再选择utf8字符集。
服务名称 默认是：MySQL
不用改。
选择配置环境变量path 如果没有选择怎么办？你可以手动配置
path=其它路径;C:\Program Files (x86)\MySQL\MySQL Server 5.5\bin
MySQL数据库的完美卸载！ 第一步：双击安装包进行卸载删除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d97b88658641d379705c74cf4c9dcb5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95b3803bc9074cfc10827526ec568a4d/" rel="bookmark">
			Linux常用命令之配置及硬件检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 使用Linux系统，很有必要熟悉一些常用的命令。本文收集整理一些常用的用于检测服务器的配置和硬件信息的命令，需要时可查阅。包括：操作系统、CPU、内存、硬盘分区、系统时间、负载、网络相关、进程、用户、开关机、启动等方面，适用于主流Linux操作系统比如centos、ubuntu、debian等
操作系统版本 $ uname -a # 查看系统，主机名，内核版本，系统架构等命令 $ top # 总览系统全面信息命令，Ctrl + C 退出界面 $ hostname # 查看服务器主机名命令 $ cat /etc/issue # 查看 Ubuntu Debian 系发行版版本命令 $ cat /etc/redhat-release # 查看 CentOS RedHat 系发行版版本命令 $ cat /etc/os-release # 查看通用 Linux 发行版版本命令 复制
CPU相关命令 $ cat /proc/cpuinfo # 查看 CPU 核心数，架构，名字，频率，缓存，指令集等命令 $ grep name /proc/cpuinfo # 查看 CPU 名字命令 $ grep cores /proc/cpuinfo # 查看 CPU 核心数命令 $ grep MHz /proc/cpuinfo # 查看 CPU 频率命令 复制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95b3803bc9074cfc10827526ec568a4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75d2f3d6622cce3e9e3e31c934af51e/" rel="bookmark">
			【CTF】【winhex】超详细jpg图片结构分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言段结构字节高位在前段标识段类型文件头文件尾帧开始（标准JPEG)标志08y轴分辨率x轴分辨率组件数量03 定义Huffman表（霍夫曼表） 段长度段数据 参考资料 前言 本文排版有些乱，例子镶嵌在每个知识点里，但整体实例都是按照顺序讲解的，而对于讲过的知识点不再赘述。
本文也将持续更新。
段结构 JPG文件由一个个段构成
JPG图片所有数据都是高位在前
字节 这个红色框框里的两个数表示一个字节
高位在前 什么是高位在前？
例如现实生活中1234，高位在前则表示12 34
而winhex的都是低位在前，在后面会讲到段长度，如00 10，低位在前则表示10 00
段结构包括： 段标识|段类型|段长度|端数据
段标识 1字节，固定为FFH，H表示16进制
段类型 1字节
文件头 名称 SOI 标记码 D8
如图，D8表示本jpg文件的文件头，前面的FF表示段标识
文件尾 名称 EOI 标记码 D9
拉到最后，FF D9表示文件尾
帧开始（标准JPEG) 名称 SOF0 标记码 C0名称 SOF1 标记码 C1
C0与C1在一个文件里只会存在一种，下面以C0为例，C1同样操作 我们查找 FF C0
后面两个字节00 11表示段长度，将十六进制转为十进制，可以知道后面有15个字节的数据（段长度占了2字节，并且不包括段标识和段类型）
那么我们可以看到后面的数据
标志08 1个字节
这个标志固定是08
y轴分辨率 2字节
计算一下，
与实际的分辨率（高度）一样
x轴分辨率 2字节
这两字节表示x轴分辨率，计算一下
与实际上文件的属性是一样的
组件数量03 这1个字节固定为03
从03之后的9个字节，都为组件数据，且每个组件数据为3个字节。
组件大小和数量都为固定的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c75d2f3d6622cce3e9e3e31c934af51e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72dfa7b0b397982c78ea6b98c44a627e/" rel="bookmark">
			leetcode 38. Count and Say（计数和读）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Example 1:
Input: n = 1
Output: “1”
Explanation: This is the base case.
Example 2:
Input: n = 4
Output: “1211”
Explanation:
countAndSay(1) = “1”
countAndSay(2) = say “1” = one 1 = “11”
countAndSay(3) = say “11” = two 1’s = “21”
countAndSay(4) = say “21” = one 2 + one 1 = “12” + “11” = “1211”
Constraints:
1 &lt;= n &lt;= 30
这是一个类似于归纳法的问题，
countAndSay(1) = “1”,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72dfa7b0b397982c78ea6b98c44a627e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20992ed642409570dfc67ddc6d5d1095/" rel="bookmark">
			【Java 基础】Java Validation API分组，顺序校验，以及自定以校验注解的优雅写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 我们后端需要对前端或者其它地方传过来的参数需要进行校验，其中JSR303定义了一些标准，接下来我们看看是如何实现分组校验和顺序校验的。
前置工作 如下是一个基础测试实体类，和一个测试controller
@Data public class TestValiated { /** * 品牌id */ private Long brandId; /** * 品牌名 */ private String name; /** * 检索首字母 */ private String firstLetter; } @RequestMapping("/testValidated") public String testValidated(@Validated @RequestBody TestValiated brand){ return "success"; } /** * 集中处理所有异常，拦截异常处理类 */ @Slf4j @RestControllerAdvice public class GulimallExceptionControllerAdvice { @ExceptionHandler(value = MethodArgumentNotValidException.class) public R handleVaildException(MethodArgumentNotValidException e) { log.error("数据校验出现问题{}，异常类型：{}", e.getMessage(), e.getClass()); BindingResult bindingResult = e.getBindingResult(); Map&lt;String, String&gt; errorMap = new HashMap&lt;&gt;(); bindingResult.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20992ed642409570dfc67ddc6d5d1095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67994426471ace7d63b000a69786d800/" rel="bookmark">
			计算机系统漫游(1.1-1.4)笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 信息上下文就是 位 1：大部分机器存储的文本都是以ASCII标准表示字符按照整数值按照(0,1)组成的字节序列存储在文件中。
1.2编译过程 hello.c 被预处理器 修改成 hello.i 然后被编译器修改成 hello.s 然后被汇编器编译成hello.o 再被链接器打包成可执行文件
预处理器
处理头文件引用，比如#include&lt;stdio.h&gt;，就会把stdio.h的文本内容直接插入到文件中
编译器
把代码翻译成汇编语言
汇编器​​​​​​
翻译成机器指令
链接器
合并指令
1.3益处 理解链接时的错误，避免安全漏洞。
1.4系统的硬件组成 总线
io设备
主存
处理器
运行hello world 过程
shell程序接收键盘输入字符，并把它读入寄存器，然后写到内存
等键盘输入回车，会执行一系列命令从磁盘中把hello文本加载到内存中，然后处理器就开始执行mian函数的机器语言指令，这些指令会把hello world 字符串从主存复制到寄存器，再从寄存器复制到显示设备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83aab24d25a5d3b72333c5c75bfa9911/" rel="bookmark">
			Go：Json转结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决实际需求，案例分享。
请求Zabbix API，通过itemid获取到AppName（应用集名称） package main import ( "encoding/json" "fmt" "io/ioutil" "log" "net/http" "strings" ) func PostRequest(payload string, url string) { method := "POST" pl := strings.NewReader(payload) client := &amp;http.Client{} req, err := http.NewRequest(method, url, pl) if err != nil { fmt.Println(err) return } req.Header.Add("Content-Type", "application/json") res, err := client.Do(req) if err != nil { fmt.Println(err) return } defer res.Body.Close() body, err := ioutil.ReadAll(res.Body) if err != nil { log.Println(err) return } fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83aab24d25a5d3b72333c5c75bfa9911/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48e65320b372f7279c4828067e28ba2/" rel="bookmark">
			list.h库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*********************************************************************************** Copy right:	Coffee Tech. Author:	jiaoyue Version:	V1.0 Date:	2018-12 Description:	从linux内核抽出来链表，可以做通用链表使用，可保留 ***********************************************************************************/ #ifndef _LIST_H #define _LIST_H //定义核心链表结构 struct list_head { struct list_head *next, *prev; }; //链表初始化 static inline void INIT_LIST_HEAD(struct list_head *list) { list-&gt;next = list; list-&gt;prev = list; } //插入结点 static inline void __list_add(struct list_head *new_list, struct list_head *prev, struct list_head *next) { next-&gt;prev = new_list; new_list-&gt;next = next; new_list-&gt;prev = prev; prev-&gt;next = new_list; } //在链表头部插入 static inline void list_add(struct list_head *new_list, struct list_head *head) { __list_add(new_list, head, head-&gt;next); } //尾部插入结点 static inline void list_add_tail(struct list_head *new_list, struct list_head *head) { __list_add(new_list, head-&gt;prev, head); } static inline void __list_del(struct list_head *prev, struct list_head *next) { next-&gt;prev = prev; prev-&gt;next = next; } //删除任意结点 static inline void list_del(struct list_head *entry) { __list_del(entry-&gt;prev, entry-&gt;next); } //是否为空 static inline int list_empty(const struct list_head *head) { return head-&gt;next == head; } //得到第一个结点 static inline struct list_head *get_first(const struct list_head *head) { return head-&gt;next; } //得到最后一个结点 static inline struct list_head *get_last(const struct list_head *head) { return head-&gt;prev; } static inline void __list_splice(const struct list_head *list, struct list_head *prev, struct list_head *next) { struct list_head *first = list-&gt;next; struct list_head *last = list-&gt;prev; first-&gt;prev = prev; prev-&gt;next = first; last-&gt;next = next; next-&gt;prev = last; } /** * list_splice - join two lists, this is designed for stacks * @list: the new list to add.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b48e65320b372f7279c4828067e28ba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f308dc5bc78879363f2adf99f877889/" rel="bookmark">
			“ZAP GUI is not supported on a headless environment”的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 在centos环境下安装zap后，通过./zap.sh或java -jar zap-2.10.0.jar运行服务失败，提示ZAP GUI is not supported on a headless environment。
通过ps -ef |grep java查看无新增运行中程序。
二、解决方法 使用daemon mode运行，问题解决，不再报“ZAP GUI is not supported on a headless environment”
（命令：./zap.sh -daemon）
验证运行成功与否方法：通过ps -ef |grep java查看zap-2.10.0.jar运行成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c361cb4ff99a7c74af24dbc3f1e6bbb/" rel="bookmark">
			Intel RealSense实感深度摄像头自校准（Self-Calibration）步骤详细，D400系列适用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		喜提国庆8天工作乐，改代码真的很帅，才华皆一切，这篇博客的由来是因为我做实验了，然后摄像头的有效距离贼差，打了技术人员的电话说他们的有效距离4m，然后边缘相差为百分之2，简直离谱，我的设备有效距离大约1m，中间有时候都不准，别说边缘了，所以calibration一下看看。
1. 下载Viewer工具 官网下载地址：Intel RealSense SDK 2.0 – Intel RealSense Depth and Tracking cameras
我的百度网盘：链接：https://pan.baidu.com/s/1QXYS3UPEQCtUkuH_6G60PA 提取码：s1h1
2. 打开Intel RealSense Viewer，连接设备（例：D435i） 3. 首先点击“More”-“Install Recommended Firmware” ,安装推荐的固件版本，等待固件刷入 4. Self-Calibration的场景一般可分为三种 4.1 大白墙 找寻一面平整的大白墙，固定相机，点击“More”-“On-Chip Calibration” ，右侧出现的弹窗中，在Speed速度中选择：fast，然后就选内参（Intrinsic）和外参（Extrinsic），挨个调就行。
右侧出现的弹窗中，能够看到两项数值Health-Check和FL Health-Check
当HC&lt;0.25,FL HC&lt;0.15，保留原有校准数据，点击“Dismiss”忽略。
当HC&gt;0.25,FL HC&gt;0.15，改善原有校准数据，即点击“Apply New”应用新的校准数据，并且再运行一次On-Chip Calibration ，继续观察两项数值，直至它们分别低于0.25和0.15，
若HC或FL HC&gt;0.75，原有校准数据必须要进行改善，并且建议直接使用动态校准或OEM校准
4.2 任意环境下（注意有效深度覆盖50%以上） 重复上述操作，在Speed速度选择上，如Depth质量下降明显时，建议选择“Slow”，如做Depth常规改善，可以选择“Fast”，调到两个参数都在Good范围内就行。
4.3 理想场景：一个带纹理的平面目标 打印校准纹理目标纸，将目标纸固定于墙上，对准，重复操作，在Speed速度选择中，如深度质量下降明显时，建议选择“Slow”，如做深度（质量）常规改善，可以选择“Fast”。
5. 完结撒花 完成之后就再做一遍实验，看有没有改善，我觉得2m最多了，那个技术人员说4m，说边缘误差百分之2，我觉得是胡扯，我的设备的是D435和D435i，超过1500mm狂跳，如果有谁的设备真的这么给力，麻烦后台私信我，让我开开眼界！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/744a2ced2f5a02b97cd5f2e47d0381da/" rel="bookmark">
			运行zap提示This application requires a Java Runtime Environment 1.8.0的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 通过桌面的快捷方式运行zap提示This application requires a Java Runtime Environment 1.8.0
根据提示排查方法：检查Java环境，结果版本符合要求
二、解决方法 最终解决方法：更换运行方式
进入OWASP ZAP 2.9.0安装目录，找到对应.jar文件，运行zap-2.9.0.jar，具体操作见下图：
附：zap安装后文件目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19cbb16dace9b549878cce1bfe589741/" rel="bookmark">
			vim学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是 vim？输入模式（Insert mode）底线命令模式切换到命令模式（Command mode）保存并退出退出删除光标所在行撤销（类似与Ctrl +Z）多次撤销重做（类似与Ctrl +Y）全选全选并删除选中文字复制选中部分内容复制一行查找 设置 vim 可配色vim练习游戏系统剪贴板从系统剪贴板粘贴到vimvim复制到系统剪贴板设置vim默认使用系统剪贴板官方帮助文档安装中文帮助文档macOS安装支持Python 3的Vim光标定位技巧键表删除单词删除""或()中的所有文字删除""或()中的所有文字并进入插件模式改变光标所在位置的单词显示隐藏行号(简写)改变 vim插入模式光标为一条｜tab页面切换vim中打开一个终端vim 编辑远程文件tab键占4个空格拆分窗口设置背景透明vim文件跳转f重复搜索自动保存文件vim 退格键（backspace）不能用`&lt;silent&gt;`vim切换文件vi阅读gbk文档y复制的文本，粘贴到命令之中的？禁止vim生成临时文件，vim 禁止生成swap文件参考文档 # 前言 vim不难，只是使用习惯跟我们日常鼠标键盘操作差异大。掌握下面使用方法，日常运维基本就够用啦。 什么是 vim？ Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。
简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。
连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。
输入模式（Insert mode） 按i键进入insert模式，这里就可以用方向键移动光标到要修改文字的地方了。掌握这个就可以做简单的修改了。
底线命令模式 : 切换到底线命令模式，以在最底一行输入命令。
带:开头的都是在这个模式下执行的。
切换到命令模式（Command mode） 按ESC键,下面的命令中不带:开头的都在这个模式下运行的。
保存并退出 :wq
退出 :q
删除光标所在行 dd
撤销（类似与Ctrl +Z） u
多次撤销 例如需要退回到2次修改以前2u，以此类推 。
3u、4u、5u
重做（类似与Ctrl +Y） 对应上面的撤销，如果撤销多了，后悔了就操作这个哈。
:red 或者:redo
或者快捷键 Ctrl + R Mac下是 ⌃ + R
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19cbb16dace9b549878cce1bfe589741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e537ace7a0d544041aac6ac31b1133/" rel="bookmark">
			老鸟必修代码精简技能：Lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“猿芯”，选择“设为星标”
后台回复"1024"，有份惊喜送给面试的你
Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。
1.1 语法组成 操作符为" -&gt; " ，被称为 Lambda 操作符或箭头操作符;
将 Lambda 分为两个部分：
左侧:指定了 Lambda 表达式需要的参数列表；
右侧:指定了 Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能。
1.2 基本用法 1.2.1 未使用和使用Lambda表达式的区别 @Slf4j public class TestLambda { //未使用和使用lambda表达式，对比 static void testRunLambdaContrast(){ // 不使用lambda表达式，创建一个线程 Runnable runnable1 = new Runnable() { @Override public void run() { log.info("------ 不使用lambda表达式，创建一个线程 ------"); } }; // 启动线程 new Thread(runnable1).start(); // 使用lambda表达式，创建一个线程 Runnable runnable2 = () -&gt; log.info("------ 使用lambda表达式，创建一个线程 ------"); // 启动线程2 new Thread(runnable2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9e537ace7a0d544041aac6ac31b1133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f31b21ff0e8080172dbc540537ccc3f9/" rel="bookmark">
			Rockchip RK3588 User Guide DP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef0e36bcc0804d4f1682dad81477825/" rel="bookmark">
			kafka-offset手动提交和自动提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
首先回顾之前的知识点
自动提交offset
手动提交
消费者poll消息的细节
完整代码：
按照新方法进行消费消息
1.指定时间进行消息的消费
2.指定分区开始从头消费+指定分区的偏移量开始消费
新消费组的消费offset规则
首先回顾之前的知识点 消费者消费消息，每消费offset+1，然后提交offset给到我们kafka中topic中的cousumer_offsets，该消费者宕机后，另外的消费者就会读取consumer_offsets读取我们的offset消费后面的消息
我们kafka消费者是自动拉取消息的，mq是队列push给消费者
自动提交：消息poll下来后（还没有消费）直接提交offset，速度很快，可能出现消费失败
手动提交：在消息消费时/消费后再提交offset
自动提交offset 缺点：可能会丢消息，比如消费者poll了topic中partition的消息后，然后提交offset，可能消费者没有消费成功
提交的内容offset——&gt;消费组+topic+offset
自动提交的配置
/** * 1.1设置是否自动提交offset并设置offset的间隔时间 */ properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"true"); properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000"); 一poll就提交offset了 手动提交 分为手动同步提交+手动异步提交
手动同步提交：在消息消费完后调用同步提交的方法，当集群返回ack前一直阻塞，返回ack后表示成功
consumer.commitAsync(); 手动异步提交：不需要等集群返回ack，直接执行后序的逻辑即可，我们可以设置一个回调方法
消费者poll消息的细节 定义：消费者会根据设置的消费时间来决定消费多少消息
properties.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG,500)//拉取0.5s消息 默认消费者一次性poll500条信息（长轮询时间为1s），如果时间内poll了500条就结束for循环
//长轮询拉取时间，1s：消费者拉取1s时间不管拉了多少条消息（除非时间内拉取完了zk维护的topic分区中所有消息） ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(1000)); 完整代码： while(true){ //长轮询拉取时间，1s：消费者拉取1s时间不管拉了多少条消息（除非时间内拉取完了zk维护的topic分区中所有消息） ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(1000)); for (ConsumerRecord&lt;String, String&gt; record : records) { System.out.printf("收到的消息：partition= %d,offset= %d,key= %s,value=%s %n",record.partition(), record.offset(),record.key(),record.value()); } /** * 4.1手动提交：所有消息消费完再提交offset给broker中_consumer_offsets */ if(records.count()&gt;0){ //同步：阻塞，提交成功，等待broker的返回ack consumer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ef0e36bcc0804d4f1682dad81477825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb863db3c9515d013086acaa9036bea/" rel="bookmark">
			商城项目中的缓存使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们聊一聊商城项目的业务中关于缓存的使用。在前面的内容中，我们已经介绍过商城业务中的核心接口，创建订单，https://www.inbai.net/article/141.html，在这篇文章里，我们详细介绍了创建订单的流程，不过我们更多的讨论的是业务分析，而没有深入去研究创建订单的性能。那么，今天我们就关于商城项目的性能方面，展开我们的话题，也就是在合适的地方使用上合适的缓存机制。
如果今天你是去面试，而你的简历中正好有商城项目，我想就商城项目的性能优化这一点，就够面试官问一上午了。下面，我们来盘点一下，商城当中，使用缓存的场景有哪些，又该如何恰当使用这些缓存。
场景一： 查询商品信息。
商城中，前端需要调用的几个商品信息查询的接口，一个是商品列表，另一个是商品详情。对于这两个接口，我们要设计合理的缓存。一种方法是，直接在接口上加Spring的缓存注解，但是这会有一个问题，哪个值作为商品的key？如果是商品详情，我们当然可以把商品的spuId或者skuId作为key，那商品列表呢？商品列表还会包括一些需要控制的部分，如筛选条件，如商品的价格区间，商品的名称，商品的分类，商品的库存数，商品的销量等等。还有一点是，商品列表会有分页，用户可能是从第二页开始查10个，也可能从第三页开始查30个。基于这两点看来，商品列表似乎不是一个简单的缓存列表就可以解决问题的。
我在这里提供一种方案，因为我们的商品列表数据都会用ES来做索引，单独查询ES的速度还是很快的。在查ES之前，我们加缓存，不是说有筛选条件，有分页就不能做缓存，当然是可以的，大不了就把入参都缓存到key里面。而且效率也是会很高，但是要设置好过期时间，不然如果有人恶意调接口的话，没几下缓存就满了。
另一种方案是，可以单独缓存查询条件和商品的id，具体的信息，通过商品id再查商品信息的缓存，这样一来，缓存的大小可以得到控制。
那这些查询商品详情的缓存，在哪些地方使用呢？首先是商品列表，然后通过商品列表进入商品详情页面，用户在实际下单时，查询商品详情，购物车列表中，展示商品详情。
场景二：查商品分类。
商品分类是肯定要做缓存的，因为这个基本属于不怎么变化的东西。
场景三：支付配置信息。
其实做了商城的话，一定会涉及到支付。那么，当我们支付的时候，有一堆支付配置信息需要获取，用这些信息组成client，发起支付。那这些支付配置，一方面是不怎么变化，另一方面是使用非常频繁，所以理当是缓存。
主要的场景是上面这些，下面再来说明一下，缓存中，哪些地方不是缓存？
比如一个这样的场景，用户下完订单之后，查订单需要展示商品详情，比如商品价格，商品名称，商品图片等等。这里的商品信息，能否通过商品详情的缓存来获取呢？答案是不能的。订单里的商品详情，是下单那一刻存进去的商品信息快照，对外展示时，不能调商品详情缓存展示，不然会出现价格不一致。
以上是关于商城项目业务分析中，使用缓存的一部分内容。
商城项目业务分析——使用缓存-尹白
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2521db11f8bd17dc35a88f8b368146f/" rel="bookmark">
			CBOW和Skip-Gram模型介绍及Python编程实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言
一、CBOW模型
1. CBOW模型介绍
2. CBOW模型实现
二、Skip-Gram模型
1. Skip-Gram模型介绍
2. Skip-Gram模型实现
总结
前言 本文实现了CBOW和Skip-Gram模型的文本词汇预测。下图为两种模型结构图：
一、CBOW模型 1. CBOW模型介绍 CBOW模型功能：通过给出目标词语前后位置上的x个词语可以实现对中间词语的预测（x是前后词语个数，x可变。代码中我实现的是利用前后各2个词语，来预测中间位置词语是什么）。
CBOW模型考虑了上下文(t - 1，t + 1)，CBOW模型的全称为Continuous Bag-of-Word Model。该模型的作用是根据给定的词，预测目标词出现的概率。如下图所示，Input layer表示给定的词，${h_1,...,h_N}$是这个给定词的词向量（又称输入词向量），Output layer是这个神经网络的输出层，为了得出在这个输入词下另一个词出现的可能概率，需要对Output layer求softmax。
2. CBOW模型实现 第一步：随便找一段英文文本，进行分词并汇总为集合word，并形成顺序字典word_to_ix、ix_to_word。
import torch import torch.nn as nn text = """People who truly loved once are far more likely to love again. Difficult circumstances serve as a textbook of life for people. The best preparation for tomorrow is doing your best today.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2521db11f8bd17dc35a88f8b368146f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cce727250ac2921b9208aa2919b6158/" rel="bookmark">
			shared memory 优化 gpu 的 归并排序 merge sort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cuda归并排序的shared memory 优化 在之前的 gpu 归并排序的程序中，没有使用shared memory 进行优化。
后来仔细分析之后发现，前面的好几步合并需要多次读取局部内存，如果加载到shared memory中说不定可以实现一定程度的优化。
整个合并过程可以分为两个阶段（如下图所示）：
第一个阶段：小规模数组的合并 在block内部进行，block中用到的数据加载到共享内存，多线程的 thread需在 steps 间同步各个 step 的并行度逐步下降，因为需要合并的数组段数越来越少，空闲线程越来越多。 第二个阶段：大规模数组的合并，使用 block 间的并行。同样，efficiency 会逐步降低，因为随着合并的进行，数组的段数越来越少，能同时发挥作用的进程数也越来越小。 感觉归并排序的合并过程，与 reduce 规约操作有相似之处，reduce 是从多个数到一个数，而归并排序是从多段数组到一段数组。
基于上述的操作步骤，代码如下：
#include "cuda_runtime.h" #include "device_launch_parameters.h" #include &lt;time.h&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;vector&gt; #include &lt;memory&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define BIG (1e7) // #define DEBUG using namespace std; template&lt;typename theIterator&gt; void print(theIterator begin, theIterator end); template&lt;typename T&gt; __device__ void mergeVec_half_device(T *A, T *tmp, const int64_t vSize) { /* splict the vector A into two halfs * merge these two half together * * tmp is a temporary vector to * receive the merge result */ int64_t left = 0; int64_t right = left + vSize - 1; int64_t mid = (left + right) / 2; int64_t i = left, j = mid + 1, k = left; // index of left half, right half, and the mergeVec while ((i &lt;= mid) &amp;&amp; (j &lt;= right)) { if (A[i] &lt;= A[j]) { tmp[k] = A[i]; ++i; ++k; } else { tmp[k] = A[j]; ++j; ++k; } } if (i &gt; mid) { for (; j &lt;= right; ++j, ++k) { tmp[k] = A[j]; } } else { for (; i &lt;= mid; ++i, ++k) { tmp[k] = A[i]; } } /// copy tmp to A for (k = left; k &lt;= right; ++k) { A[k] = tmp[k]; } } template&lt;typename T&gt; __global__ void mergeVec_half_global(T *A, T *tmp, const int64_t vSize) { /* splict the vector A into two halfs * merge these two half together * * tmp is a temporary vector to * receive the merge result */ int64_t left = blockIdx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cce727250ac2921b9208aa2919b6158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8966be0606c06613b1f2ffbd7d50b78d/" rel="bookmark">
			从多变形面积到多面体体积：鞋带公式的3D版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎样根据多边形顶点坐标计算多边形面积，以及3D情况下怎样根据多面体的顶点坐标计算多面体的体积？ 多边形的面积计算方法中，有一条像变戏法一样的计算方式：鞋带定理，可以直接根据多边形的各个顶点坐标得到多变形的面积。本文将会介绍鞋带公式的原理，以及从2D扩展到3D的方式，即使用鞋带公式计算3D多面体的体积。
2D情况下的鞋带公式可以写作：（其中 i 是关于多边形的各个顶点求和） A = ∑ i v e r t e x e s 1 2 ( x i y i + 1 − x i + 1 y i ) = ∑ i v e r t e x e s 1 2 ∣ x i x i + 1 y i y i + 1 ∣ = ∑ i v e r t e x e s 1 2 d e t ( x i ⃗ , x i + 1 ⃗ ) A = \sum_{i}^{vertexes}{\frac{1}{2}(x_{i}y_{i+1}-x_{i+1}y_{i})} = \sum_{i}^{vertexes}{ \frac{1}{2}\left| \begin{matrix}x_{i} &amp; x_{i+1}\\y_{i} &amp; y_{i+1} \end{matrix} \right| } = \sum_{i}^{vertexes}{\frac{1}{2} det(\vec{x_{i}},\ \vec{x_{i+1}})} A=i∑vertexes​21​(xi​yi+1​−xi+1​yi​)=i∑vertexes​21​∣ ∣​xi​yi​​xi+1​yi+1​​∣ ∣​=i∑vertexes​21​det(xi​ ​, xi+1​ ​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8966be0606c06613b1f2ffbd7d50b78d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27cf0a4d6f9973937c426ee48007c0dd/" rel="bookmark">
			git branch 分支 按照时间排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git branch 分支 按照时间排序 当 git 分支越搞越多的时候，我们往往只想关注最近修改过的分支，所以一个很大的需求是根据最近修改 (commit) 的时间来排序和显示分支branch
目前找到的最符合需求的简便方法如下（其中用了sort排序）。
按修改时间排序显示分支的方法：
git for-each-ref --sort=-committerdate 如果要把日期也显示出来，可以这样
git for-each-ref --sort='-committerdate' --format='*** %(refname)%09%(committerdate)' | sed -e 's-refs/heads/--' 另外，如果加上 `refs/heads/` ，可以只显示本地分支 git for-each-ref --sort=-committerdate refs/heads/ git for-each-ref --sort='-committerdate' --format='*** %(refname)%09%(committerdate)' refs/heads | sed -e 's-refs/heads/--' 其它笔记：
查看当前分支是从那一个分支拉出来的（类似于查看父分支，虽然实际上没有父分支的概念）
git reflog show currentBranchName 参考资料 https://www.codeleading.com/article/68934407419/
https://davidwalsh.name/sort-git-branches
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a4c78be107e40cb488aab7edb5a9021/" rel="bookmark">
			网线8芯线各自作用是什么？几种常用的网线定义行业标准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多朋友都遇到过网线装宽带时选择网线类型的问题，以及家里装修时需要铺设网线如何选择的问题等。那么网线到底是选择8芯的还是4芯的呢？8芯网线的每个芯都用到了吗？每芯的作用又是什么呢？
接下来在这里分享8芯网线的各芯线的作用及几种常见的行业标准。
线序定义 网线的标准线序定义主要有两种，T568A标准和T568B标准，我们在实际应用中基本使用T568B标准。
T568A标准连线顺序从左到右依次为:1-绿白、2-绿、3-橙白、4-蓝、5-蓝白、6-橙、7-棕白、8-棕。
T568B标准连线顺序从左到右依次为:1-橙白、2-橙、3-绿白、4-蓝、5-蓝白、6-绿、7-棕白、8-棕。
网线不同的行业定义 当前行业网线线序及线芯的具体定义，主要分为三种类型，百兆普通网线、千兆普通网线和POE网线。
百兆网线 百兆及以下带宽，一般使用1、2、3、6四根线。按标准是橙色、绿色共四根线。其中1、3一组，2、6一组 4、5为备用线 7、8则为电话线。
百兆网线数据定义
1输出数据(+)
2输出数据(-)
3输入数据(+)
4保留网络传输
5保留网络传输
6输入数据(-)
7保留网络传输
8保留网络传输
千兆(万兆)网线 1G(10G)网卡数据传输是双向的，两对收数据，另外两对发数据，需要使用四对线，即8根芯线都需要使用。在千兆(万兆)网络传输中，8根网线都要使用，1、2、3、6芯发送数据，4、5、7、8芯接收数据。
另外千兆网线由于传输速度高，外层一般都需要屏蔽层，另外双绞线4组之间需要用十字架隔开固定，以避免信号的相互干扰。
POE网线 PoE电力传输模式
PoE 通常使用三种模式通过以太网线传送直流电力，分别为模式B，模式A，4PPoE。其他更深入的POE相关介绍这里不再探讨，可以自行查找相关资料了解
参考资料 百兆POE供电时需要选择8芯网线，其中用4芯作数据传输，4芯进行供电，百兆POE供电的线序一般有三种：
1、网线中的4、5芯为正，7、8芯为负；这时数据传输的4芯和供电的4芯岔开。
2、网线中的1、2芯为负，3、6芯为正；这时数据传输的4芯和供电的4芯共用。
3、网线中的1、2芯为正，3、6芯为负。这时数据传输的4芯和供电的4芯共用。
这里面1是一个大类，2、3是另一个大类。常用的为1、2、3、6芯作网络数据传输，4、5、7、8芯进行供电，网线通常选择是0.5mm线径的无氧铜，传输距离不能超过100m，保证信号传输稳定流畅。
以上就是网线8芯各自的作用及常见定义的行业标准，感谢大家的关注，我们下次分享再见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a37146095949fc20ee4067e8e9fb78d9/" rel="bookmark">
			c&#43;&#43;类和对象（中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、类的默认成员函数二、构造函数1.概念2.特性 三、析构函数1、概念2、特性 四、拷贝构造函数1、概念2、特性 五、赋值运算符重载1、运算符重载2、赋值运算符 六、日期类的实现七、输入流和输出流总结 前言 提示：这里可以添加本文要记录的大概内容：
接着学习c++的类和对象
提示：以下是本篇文章正文内容，下面案例可供参考
一、类的默认成员函数 如果对于一个类，我们不予任何函数和变量，那么它里面真的就什么都没有吗。
其实并不是，对于空类，编译器会自动生成下面几个默认成员变量
其中，前四个是比较重要的，需要重点讲解的
二、构造函数 1.概念 对于这样一个类，在创建一个对象之后，还需要用init函数为其初识化，那么有没有一种方法在对象创建的同时为其初始化呢？这就是构造函数的作用。
构造函数是一种特殊的成员函数，函数名和类名相同，在编译时自动调用，使每一个对象都有一个合适的初始值。
#include&lt;iostream&gt; using namespace std; class Date { public: //void Init(int year, int month, int day) //{ //	_year = year; //	_month = month; //	_day = day; //} Date(int year, int month, int day) { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a37146095949fc20ee4067e8e9fb78d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aac3cd8046fcf923d2e046f0289eb36/" rel="bookmark">
			socket.io-client 实时通讯，用socket.io-client的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说在前面： 由于项目需要，前端所渲染的数据，要从后端(PHP)实时主动推送到前端（前端也可以实时主动推送到后端，以前的做法是在前端用定时任务，隔多少时间后就请求一下后端API），所以就不像平时用Ajax、Fetch、Axios等来调用后端的API接口了，这次采用的是WebSocket方式（什么是WebSocket），现在的WebAPI中本身就支持WebSocket的，所有可以前端可以直接调，但是使用WebSocket还要搭建后端服务等，
由于这次项目比较急，所以就接用了第三方封好的框架：Workerman，
workerman是一个高性能的PHP socket 服务器框架，workerman基于PHP多进程以及libevent事件轮询库，PHP开发者只要实现一两个接口，便可以开发出自己的网络应用，例如Rpc服务、聊天室服务器、手机游戏服务器等。
workerman的目标是让PHP开发者更容易的开发出基于socket的高性能的应用服务，而不用去了解PHP socket以及PHP多进程细节。 workerman本身是一个PHP多进程服务器框架，具有PHP进程管理以及socket通信的模块，所以不依赖php-fpm、nginx或者apache等这些容器便可以独立运行。
Workerman：下载地址：https://www.workerman.net/download
Workerman：官方文档：http://doc.workerman.net
提示，我遇到坑的地方 或 要注意的地方，我都用红色字体标注了。
聊天室效果： http://www.muguilin.com/chathttp://www.muguilin.com
依赖安装： 后端PHP：
后端在使用Workerman时还需要安装phpsocket.io才可以哦！
phpsocket.io下载地址：
PHPSocket.io (workerman.net) 前端React：
这次前端是用React-cli v16 + socket.io-client来做的，所以直接npm 或 yarn 就可以直接安装在项目中了！！！
npm install socket.io-client 或 yarn add socket.io-client 注：安装完成后一定要重新启动一下React服务(npm run start 或 yarn start) 不然在 引入时 import io from 'socket.io-client'; 会有报错！！！ 使用方法： import React, { Component } from "react"; import io from 'socket.io-client'; export default class Main extends Component { constructor(props) { super(props); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aac3cd8046fcf923d2e046f0289eb36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9fc31c810dd5c2ba67bce9c5b9957b/" rel="bookmark">
			bug记录：oss大文件上传后设备端获取文件url地址下载无响应或出现闪退
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 之前搞得阿里oss文件上传功能，最近出问题了，客户反应经常出现设备端下载莫名闪退问题。因为在生产环境，所以急忙回退到旧版本，自己排雷。
根据设备端日志显示，无法申请足够的内存而导致程序gc，所以出现闪退。
但是旧版本普通上传是没有这种问题的，所以问题还在服务端文件上传功能。
查遍资料找到一处，上传时设置的：headers 请求头。
出问题的代码里是这样写的：
'Content-Type': "application/x-www-form-ulencoded" 然后自己在阿里oss关于设置Content-Type里找居然没找到这个value ！！！
然后看了文档说，如果不设置类型，oss sdk会在上传后自动根据文件后缀填充 content-type。
解决 于是注释掉这条设置，然后上传以后，设备端果然可以正常下载，没有出现一次闪退现象。究其原因，代码里设置的话，固定死了文件的类型，然而如果文件是其他类型，比如 zip类型，设备端下载就会出现不匹配的问题，导致gc。（里面具体细节不甚清楚，或许涉及到文件类型转换，要申请较大空间吧）
自己坑了自己一把…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02fd3c98816cbbc6465c0cadcffb45d/" rel="bookmark">
			VS2022打开项目之后提示：找不到 .NETFramework,Version=v4.0 的引用程序集。要解决此问题，请为此框架版本安装开发人员工具包(SDK/目标包)或者重新定向应用程序。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题： 使用 vs2022打开带有.net4.0的项目会报错
严重性	代码	说明	项目	文件	行	列	禁止显示状态 错误	MSB3644	找不到 .NETFramework,Version=v4.0 的引用程序集。要解决此问题，请为此框架版本安装开发人员工具包(SDK/目标包)或者重新定向应用程序。可在 https://aka.ms/msbuild/developerpacks 处下载 .NET Framework 开发人员工具包	Fleck	D:\VSIDE_2022\MSBuild\Current\Bin\amd64\Microsoft.Common.CurrentVersion.targets	1217	5	虽然安装了.net4.0依旧会报错的。
手动下载 下载 直接到nuget上下载对应版本
链接：https://www.nuget.org/packages/Microsoft.NETFramework.ReferenceAssemblies/
打开对应版的页面之后直接下载即可。
解压 文件下载完之后，修改后缀名为zip然后直接解压。
复制 解压完成之后，复制源路径下的文件夹，到目标路径下。提示：需要显示隐藏项目（.开头的文件或目录名称，系统默认为隐藏）。
源路径：microsoft.netframework.referenceassemblies.net40.1.0.2\build\.NETFramework
目标路径：C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework
官方文档 更新了，VS2022不在支持.net4.x之前的了，要使用vs2019之前的版本。
官网文档链接
https://docs.microsoft.com/zh-cn/dotnet/framework/install/guide-for-developers vs2017下载链接 https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/ 感谢 不愿意透露姓名的同事 不懂私信评论Ejoy 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c8c936d53be8cd5b1acfdea98e4c5b/" rel="bookmark">
			stm32f4xx-ADC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、定义二、模数转换过程三、ADC1.精度的理解2.原理图：3.存储对齐方式：4.ADC采集时间5.stm32通道组6.ADC1的通道5（PA5)进行单次转化 四、test 一、定义 ADC，Analog-to-Digital Converter的缩写，指模/数转换器或者模数转换器。是指将连续变化的模拟信号转换为离散的数字信号的器件。真实世界的模拟信号，例如温度、压力、声音或者图像等，需要转换成更容易储存、处理和发射的数字形式。模/数转换器可以实现这个功能，在各种不同的产品中都可以找到它的身影。
模拟信号，数值上变化很多，数值是连续的
数字信号，以二进制为代表，数值是离散的，不连续
参考：模拟信号和数字信号的区别和特点-与非网 (eefocus.com)
二、模数转换过程 三、ADC 1.精度的理解 精度越高，数据越是准确。
12位精度：3300mv/4096=0.8mv，也就是说只要电压值有±0.8mv的变化，adc就能分辨出来。
10位精度：3300mv/1024=3.22mv，也就是说只要电压值有±3.22mv的变化，adc就能分辨出来。
8位精度：3300mv/256=12mv，也就是说只要电压值有±12mv的变化，adc就能分辨出来。
6位精度：3300mv/64=51.5625mv，也就是说只要电压值有±51.5625mv的变化，adc就能分辨出来。
2.原理图： 3.存储对齐方式： 4.ADC采集时间 最小采样时间0.42us(ADC时钟=36MHz，采样周期为3周期下得到）
5.stm32通道组 STM32F4的ADC的各通道可以单次，连续，扫描或者间断模式执行
6.ADC1的通道5（PA5)进行单次转化 四、test void ADC1_CH5_init(void)//可变电阻 { GPIO_InitTypeDef GPIO_InitStructure; ADC_CommonInitTypeDef ADC_CommonInitStructure; ADC_InitTypeDef ADC_InitStructure; //打开GPIOA硬件时钟 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);//GPIOA的时钟使能 //打开ADC的硬件时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); //配置PA5引脚为复用模拟信号引脚 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //ADC常规初始化 ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;	//独立工作模式，只使用一个ADC ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;	//ADC硬件时钟=84Mhz/2=42Mhz t = 1/42Mhz ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;	//不需要映射数据，直接读取寄存器就可以得到结果值 ADC_CommonInitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c8c936d53be8cd5b1acfdea98e4c5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68e354a0d19b904ce6f94e58b91ff6d/" rel="bookmark">
			在 NOVALIDATE 方式下创建外键约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ALTER TABLE ADD CONSTRAINT 语句可以创建或过滤 NOVALIDATE 方式的外键约束。
NOVALIDATE 约束方式防止数据库服务器在创建引用约束时，验证每一行的外键值是否符合被引
用表中的主键值。
使用此语法创建启用或过滤 NOVALIDATE 方式的外键约束：
ALTER TABLE ADD CONSTRAINT
用法
该语法忽略 DISABLED 关键字。因为禁用的约束不会进行违例检查，在这种情况下，
NOVALIDATE 关键字不重要。
如果没有列或列表立即跟随在 REFERENCES 关键字之后，则缺省列（或列组）是 pk_tab 表的主
键。如果 pk_tab 和 table 或 synonym 指定同一表，则约束自我引用，并没有缺省的主键列。
如果您没有声明约束的名称，则数据库服务器为此新约束生成一个标识符，它注册在
sysconstraints 和 sysobjstate 系统目录表中。
ALTER TABLE ADD CONSTRAINT 语句支持引用约束的 NOVALIDATE 方式作为创建或过滤引
用约束时绕过数据完整性检查的机制。
NOVALIDATE 方式可以提高性能的情况
尽管引用约束保护数据完整性，在某些情况下您正要移动到新数据库服务器实例的数据库表是已知
的自由参照完整性违规。对于大表上的外键约束，验证约束所需的时间要十分充分。如果有数百万
行的表正从 OLTP 环境移动至数据仓库环境，则验证目标环境中的外键可能增加数量级迁移所需
的时间。
例如，您可以删除大表上的外键约束，然后在该表迁移到目标表环境之前，立即重新创建
ENABLED NOVALIDATE 方式或 FILTERING NOVALIDATE 方式的约束。重建外键约束的
ALTER TABLE ADD CONSTRAINT 操作的花销几乎很小，因为它绕过了对每一行引用约束的验
证。因为 NOVALIDATE 方式不会持续超过创建该约束的 ALTER TABLE 操作，抵达数据仓库环
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f68e354a0d19b904ce6f94e58b91ff6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb02e1e47915b5ae45816aea96bae49/" rel="bookmark">
			DROP CONSTRAINT 子句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 DROP CONSTRAINT 子句删除指定的约束。
ALTER TABLE 语句的 DROP CONSTRAINT 子句具有此语法：
DROP CONSTRAINT 子句
用法
要删除现有约束，请指定 DROP CONSTRAINT 关键字和此约束的名称。要删除同一表上的多个约束，则约束名称列表必须逗号分隔并由括号分隔。
您要删除的约束可具有 ENABLED 、DISABLED 或 FILTERING 方式。
这里是一个删除约束的示例：
ALTER TABLE manufact DROP CONSTRAINT con_name;
以下示例删除了定义在 orders 表中的引用约束和检查约束：
ALTER TABLE orders DROP CONSTRAINT (con_ref, con_check);
GBase 8s 的 SQL 执行包含非 DROP CONSTRAINT 语句。然而，如果该语句存在，则 ALTER
TABLE 语句的此子句提供一个 DROP CONSTRAINT 语句除外的功能。
当 DROP TABLE 语句删除该表时，会默示地删除该指定表上所有的约束。
获取约束名称
DROP CONSTRAINT 子句需要约束的名称。如果创建约束时没有声明名称，则数据库服务器生成
新的约束的名称。您可以查询 sysconstraints 系统目录表以获得约束的名称的所有者。例如，要查
找位于 items 表上约束的名称，您可以发出以下语句：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cb02e1e47915b5ae45816aea96bae49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5026305c5f457b3fad5173454585b40/" rel="bookmark">
			mysql新建用户并赋权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #新增用户 #create user '用户名'@'可以访问数据库的ip' identified by '密码'; create user 'frbb'@'%' identified by '密码'; #查看用户权限 show grants for frbb; #为用户赋权 select、insert、update等 #grant usage on 库名.表名 to 'frbb'@'%'; usage表示没有任何权限 grant select on 库名.表名 to 'frbb'@'%'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2640b984dba398ba96f7bfdb48eed0/" rel="bookmark">
			kafka日志清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka日志清理 以下参数是配置在**./config/server.properties**下进行配置的参数。
在进行配置以下清理方式之前 需要进行的配置：
log.retention.check.interval.ms The interval at which log segments are checked to see if they can be deleted according to the retention policies.
检查日志段的时间间隔，以确定它们是否可以根据保留策略被删除。
使用形式是：
log.retention.check.interval.ms=10000
单位是毫秒
log.segment.bytes The maximum size of a log segment file. When this size is reached a new log segment will be created.
日志段文件的最大大小。当达到这个大小时，将创建一个新的日志段。
因为kafka是将一个一个的日志文件按照日志段进行存储的，所以在进行日志删除时，会将日志段时间进行比较，将超过时间的进行删除。
使用的形式是：
log.segment.bytes=100000
单位是B
换算是1KB=1024B 1MB=1024KB 1GB=1024MB，即1G=1024* 1024* 1024=1073741824
log.cleanup.policy delete 清理策略，这种策略就是我们默认看到的数据保留特点，超过特定的数据量或者时间，日志就会被删除。
compact 清理策略要求每个record都要有key，kafka是根据key来进行去重合并的，那种需要留存一份全量数据的需求比较有用。举个例子，计算了所有用户的粉丝数，而且每5分钟更新一次，结果都存储到kafka当中。数据会无限膨胀，而且，很多数据是无意义的，所以只需要总数就可以了。
为了兼容kafka 0.9.0之前的版本需要添加。
log.cleaner.enable Kafka Broker 的日志清理功能在配置 log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e2640b984dba398ba96f7bfdb48eed0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a19e6543e5f57dc3293bdfd7e8614b7/" rel="bookmark">
			MODIFY 子句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 MODIFY 子句更改列的数据类型、长度或缺省值，添加或删除列的安全标签，允许或不允许
列中有 NULL 值或者重置 SERIAL 、SERIAL8 或 BIGSERIAL 列的序列号。
您不能将列的数据类型更改为 COLLECTION 或 ROW 类型。
受保护表的 IDSSECURITYLABEL 列不能被不同的数据类型修改，现有的列也不能被更改为
IDSSECURITYLABEL 类型。
当修改列时, 所有 先前与该列相关联的属性（即，缺省值、单列检查约束或引用约束）被删除。当
希望保留列的某些属性，例如 PRIMARY KEY ，您必须在同一 MODIFY 子句中重新指定那些属
性。
例如，如果您将现有列 quantity 的数据类型更改为 SMALLINT ，但希望保留其缺省值（在这种情
况中，为 1）和 NOT NULL 列属性，可以发出以下语句：
ALTER TABLE items MODIFY (quantity SMALLINT DEFAULT 1 NOT NULL);
注： 在 MODIFY 子句中两个属性都再次被指定。
当在 MODIFY 子句中指定 PRIMARY KEY 约束，数据库服务器也会默示地在同一列创建 NOT
NULL 约束或将同一组列更改为主键。
当更改列的数据类型时，数据库服务器不会在适当的位置执行修改。下个示例将 VARCHAR(15)
列更改为 LVARCHAR(3072) 列：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a19e6543e5f57dc3293bdfd7e8614b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c628e791e2c94dad4b6f4c5e95464eef/" rel="bookmark">
			【Python】pyqt6入门到入土系列，非常详细...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 最近真的是运气不好，国庆前一天，隔壁小区有人中招了，结果国庆出不了门，好不容易国庆结束了，准备上班，结果小区又有个叼毛中招了，搞得我直接国庆放了半个月，还只能在家过，没事干只能这里写写，那里弄弄，于是今天就把存货分享给大家了~
兄弟们学习python，有时候不知道怎么学，从哪里开始学。掌握了基本的一些语法或者做了两个案例后，不知道下一步怎么走，不知道如何去学习更加高深的知识。
那么对于这些大兄弟们，我准备了大量的免费视频教程，PDF电子书籍，以及源代码！
大家文末名片自取即可~
一、什么是PyQt6? 简单介绍一下PyQt6 1、基础简介 PyQt6 Digia 公司的 Qt 程序的 Python 中间件。Qt库是最强大的GUI库之一。PyQt6的官网：www.riverbankcomputing.co.uk/news。PyQt6是由Riverbank Computing公司开发的
PyQt6 是基于 Python 的一系列模块。它是一个多平台的工具包，可以在包括Unix、Windows和Mac OS在内的大部分主要操作系统上运行。PyQt6 有两个许可证，开发人员可以在 GPL 和商业许可之间进行选择。
2、安装 PyQt6 pip install PyQt6
3、PyQt6 模块 PyQt6 类是由一系列模块组成的，包括如下的模块：
QtCoreQtGuiQtWidgetsQtDBusQtNetworkQtHelpQtXmlQtSvgQtSqlQtTest 1)、 界面框架部分
主类
QLayout
继承类
QGridLayout （网格布局）
QBoxLayout（简单的上下布局）
QStackedLayout （可切换widget的布局）
FlowLayout
2)、 界面组件部分（其实也是Widget类）
button
label
等等
3)、 界面样式部分
color
size
font
Icon
4)、界面交互部分
action
event
signal
slot
connect
5)、概念之间关系
QWidget 作为页面的主体，挂载layout(框架)，框架添加页面的组件，通过 action(动作，类似于点击)，event(事件)，signal(信号)，slot（信号槽），connect（动作绑定）产生交互
通过样式类，类似于 Icon(图标)，大小，颜色，字体等，修改界面的细节
widget 上需要有layout，layout可以继续添加widget，可以一直加下去
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c628e791e2c94dad4b6f4c5e95464eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c60b87a5d9ae6eea7d72b9a1a0ecd30e/" rel="bookmark">
			习题9-5 通讯录排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入n个朋友的信息，包括姓名、生日、电话号码，本题要求编写程序，按照年龄从大到小的顺序依次输出通讯录。题目保证所有人的生日均不相同。
输入格式： 输入第一行给出正整数n（&lt;10）。随后n行，每行按照“姓名 生日 电话号码”的格式给出一位朋友的信息，其中“姓名”是长度不超过10的英文字母组成的字符串，“生日”是yyyymmdd格式的日期，“电话号码”是不超过17位的数字及+、-组成的字符串。
输出格式： 按照年龄从大到小输出朋友的信息，格式同输出。
输入样例： 3 zhang 19850403 13912345678 wang 19821020 +86-0571-88018448 qian 19840619 13609876543 输出样例： wang 19821020 +86-0571-88018448 qian 19840619 13609876543 zhang 19850403 13912345678 这道题是个很经典的结构题，通过struct构造结构从而进行一些列的计算
结构我想，应该是解决一系列的字符串的问题
字符串的输入与输出都是 scanf（“%s”）；
代码如下：
```dart #include&lt;stdio.h&gt; struct friend{ //结构struct + 结构名{} char name[50]; int age; char phone[50]; }; int main(){ int n; struct friend a[20],temp; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++){ //字符串的输入 %s，且以数组的形式a[i].name scanf("%s %d %s",&amp;a[i].name,&amp;a[i].age,&amp;a[i].phone); } for(int i=1;i&lt;n;i++){ //这个循环是为啦以第一个数字依次遍历后续的数字的比较大小， for(int j=0;j&lt;n-i;j++){//从而保证第一个永远是最大的，最后一个永远是最小的 if(a[j].age&gt;a[j+1].age){ temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } for(int i=0;i&lt;n;i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c60b87a5d9ae6eea7d72b9a1a0ecd30e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a499a1181972dd25a1cbfc7c7fbaadbf/" rel="bookmark">
			Arcgis模型构建器——初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、构建器简介​​​​​​​
三、模型构建器的优势
一、前言 相信不少小伙伴都对Arcgis软件中的模型构建器或多或少，或者也在不少博客文章看到过相关介绍，是否在想为什么他们可以运用的这么流畅并且确实还是挺节省时间和精力。什么时候自己也可以成为那么一个人，苦于寻找相关学习资料，总是还欠缺点火候。
那么模型构建器到底是什么？可以起到什么作用？如何构建？
相信很多小伙伴都是被以上三个问题所困扰，那么今天根据问题来找答案，从入门开始，一步一个脚印，带领大家了解广义的模型构建器、具体模型构建器、制作简单的模型、制作复杂模型等。本文先介绍一下广义的模型构建器是什么？
二、构建器简介 广义上的模型构建器介绍可以查看Arcgis软件中帮助的文档中对模型构建器介绍，模型构建器是一个用来创建、编辑和管理模型的应用程序，模型是将一系列地理处理工具串联在一起的工作流，它将其中一个工具的输出作为另一个工具的输入，也可以将模型构建器看成是用于构建工作流程可视化编程语言。 模型构建器除了有助于构造和执行简单工作流外，还能通过创建模型并将其共享为工具来提供扩展 ArcGIS 功能的高级方法。
模型构建器甚至还可用于将 ArcGIS 与其他应用程序进行集成。以下提供了一个示例：
上述模型由某市用来向距离建筑许可证申请提出位置 1 米以内的所有地址发送电子邮件通知。该模型以包含多个许可证申请点位置的要素类开始。此要素类会传送到迭代器内，迭代器在各个独立点之间循环并将相应点传送给“按位置选择图层”工具，该工具会选择距相应点 1 米范围内的所有地址（宗地）。这些地址随后传递到自定义脚本工具（由您或您的同事创建）Generate Mailing List，该工具会执行 Python 代码并以 HTML 格式输出邮件列表。最后，邮件列表传送到另一个自定义脚本工具 Send Email Notifications，该工具将运行用于发送电子邮件通知并生成成功代码的可执行自定义文件。
三、模型构建器的优势 （1）模型构建器是一个简单易用的应用程序，用于创建和运行包含一系列工具的工作流。
（2）可以使用模型构建器创建自己的工具。使用模型构建器创建的工具可在 Python 脚本和其他模型中使用。
（3）结合使用模型构建器和脚本可将 ArcGIS 与其他应用程序进行集成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a930d49960d75bfa7d9c5c233a853848/" rel="bookmark">
			mysql 创建一个新用户权限只能查指定库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建用户 MySQL 8.0 以上版本使用下面的命令授权会报错：
mysql&gt; grant all privileges on *.* to root@'%' identified by 'myslag123!@#'; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘identified by ‘myslag123!@#’’ at line 1 因为新版的的mysql版本已经将创建用户和赋予权限的操作分开了，需要分两步操作：
.1 创建用户
mysql&gt; create user 'root'@'%' identified by 'MySlag123!@#'; Query OK, 0 rows affected (0.01 sec) 赋予权限 mysql&gt; grant all privileges on *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a930d49960d75bfa7d9c5c233a853848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d894a56b10de6e24ea5cef97d8b844/" rel="bookmark">
			吐槽各大竞赛题库的优劣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		No.1：洛谷 洛谷是一个很不错的网站，洛谷原创的题有的出的还是很好的。题很多，还支持各大题库的提交，就是有的洛谷原创的题太毒瘤。同样，也是一个不错的社交平台。就是洛谷管理员封号太疯狂了。数据部分公开，每月都有月赛。
No.2：CodeForces 比赛很多，题目质量也非常好，但是外国网站需要强大的英语功底或者是阅读理解能力（毕竟机翻的语病太多了）。而且 C o d e F o r c e s CodeForces CodeForces也有许多娱乐性的比赛，十分有乐趣。数据公开，但是有的大数据给不全，要一些技巧。
No.3：POJ 北大的网站，题目不错，但是是英文的。这上面的题在各大 O J OJ OJ还是都能找到翻译的。数据不公开。
No.4：AtCoder 也是一个以比赛为主的题库，题目质量非常好，但是数据不公开，而且提交题目也很不方便。
No.5：牛客网 这个是牛客网刷题的页面，要登录后进入。牛客网本来是博客的性质，但是题库的题很全，比赛也挺多的，算是一个好网站。但是数据不公开。
No.6：LOJ L O J LOJ LOJ的界面很清晰，很多 O J OJ OJ都是用的 L O J LOJ LOJ的板子。这上面题不是很全，但是这个题库数据完全公开，很适合在上面调试。
No.7：LeetCode 这个网站按理来说应该排在很前面，但是我们放在这里。为什么我说它应该放在很前面呢？因为这个网站比赛非常多，而且题目由简单到难，覆盖了很多题型，也不毒瘤。但是这个题库都是交互题，而且难度普遍不高，主要面向面试的人，不适合信息学奥赛。
No.8：COJ 不是很热门的一个网站，但是题目出得很好，值得一看。
No.9：VJ 这个也不是很热门，包含了很多个题库的题，因为外国网站要翻墙而放弃使用的可以来用这个。这个题库直接是在原 O J OJ OJ上评测并返回来，而且不需要你注册一个原 O J OJ OJ的账号。这个完全就是一个题库，没有比赛和题解，要搞这两个自己上原 O J OJ OJ。
No.10：XJOI 学军的题目很不错，但是排版有点难受，一般大 O J OJ OJ上会有它的题。
No.11：AcWing 这个是一个叫闫学灿的大佬建立的团队搭建的小平台。这种小平台应该不值一提，但是我发现，这个网站很有特色：这更像一个云端的桌面。其实觉得有的地方做得比大平台还好，大家自己康康就知道了。
upd：现在AcWing老火了，排名差不多能到前三。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69db9200fe90bb6f69014e8472962880/" rel="bookmark">
			该虚拟机似乎正在使用中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该虚拟机似乎正在使用中 问题解决 按照以下步骤解决虚拟机异常关机无法打开问题
1，在用VMware虚拟机的时候，有时会发现打开虚拟机时提示“该虚拟机似乎正在使用中。如果该虚拟机未在使用，请按“获取所有权(T)”按钮获取它的所有权。否则，请按“取消©”按钮以防损坏。配置文件: D:\win10x64\Windows 10 x64.vmx。”这是由于虚拟机未正常关闭引起的，下面看看解决办法。
2，我们首先点击“获取所有权(T)”按钮，会发现弹出一个窗口，显示“
无法打开虚拟机: D:\win10x64\Windows 10 x64.vmx获取该虚拟机的所有权失败。主机上的某个应用程序正在使用该虚拟机。配置文件: D:\win10x64\Windows 10 x64.vmx。”等信息。这说明获取所有权失败了。
3，当点击“取消©”按钮是直接退出窗口，什么也不弹出。这时发现不管点那个按钮都不能解决问题。
4，点击“开始”菜单，选择“文件资源管理器”。
5，打开“文件资源管理器”后，进入到存放此台Vmware虚拟机虚拟磁盘文件及配置文件存放的位置（也就是弹出提示窗口上的路径），在这里是D:\win10x64这个目录下，找到后缀为.lck文件夹。
6，然后，将后缀为.lck的文件夹删除，或者或避免删错可以移动到备份文件夹中，也可以直接重命名此文件夹，在这里我将文件夹Windows 10 x64.vmx.lck改为Windows 10 x64.vmx.lck.backup。
7，然后重新打开虚拟机，发现此虚拟机可以正常打开了，这样就成功的解决了“该虚拟机似乎正在使用中”问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd1b7c15aa5378ca0949db1929fab75/" rel="bookmark">
			【SLAM】基于rrt_explore的移动机器人自主建图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 ·【SLAM】基于explore_lite的移动机器人自主建图
·【SLAM】基于rrt_explore的移动机器人自主建图
·【问题解决】rrt_exploration功能包使用过程中报错处理
文章目录 目录
目录
系列文章目录
文章目录
前言
一、原理
二、安装
三、使用说明
1.global_rrt_frontier_detector
2.local_rrt_frontier_detector
3.frontier_opencv_detector
4.filter
5.Assigner
四、仿真实验
前言 前面我们尝试了基于explore_lite的自主建图，本篇文章我们对基于rrt的自主建图算法进行探索尝试，并对其原理进行简述，然后进行在ubuntu16.04和ubuntu20.04虚拟机上都进行仿真实验，指出需要进行修改的地方以便于我们仿真通过。
一、原理 这个功能包是基于2D的，通常采用图像算法的边缘检测来检测已知区域与未知区域的边界。基于Rapidly-exploring Random Trees（快速搜索随机树RRT）的探索策略。由于RRT基本上是朝向未知区域的（unexplored and unvisited），并且RRT可以扩展到更高维区域。同时采用local tree与global tree来检查边缘点，使得机器人的exploration更加高效。
一旦检测到边缘后，就会取其中心为目标点，然后让机器人去探索该点。而为了检测边缘点，需要对整张地图进行处理，而这个操作通常是耗时的，为此大量的研究人员花费精力在检测frontier edges的效率上。
本包中，RRT树只是用于search边缘点，而检测到的边缘点经过滤波就会依次安排给机器人。当机器人接收到point时，就会运动到对应的点。在此期间，机器人上的传感器将会扫描建图。
而通过多个独立的RRT树来加速边缘点的检测，则是本包的创新点。
如下图所示，这个功能包主要分为三个模块。
基于RRT的边界检测模块（负责检测边界点，分为全局检测节点和局部检测节点以及基于opencv的边界检测器节点）滤波模块（存储边界点，并通过mean shift算法来聚类，检测出无效以及旧的边界点）以及task allocator模块（接收到滤波模块传来的边界点后，分配到机器人） 而本包还需要与SLAM及path planning模块(move_base)相结合来使用。
关于global detect与local detector节点，当检测到一个边界点时，local detector会重置，并且会基于机器人当前的位置重新生长。这带来两个好处：
检测边界点更快。因为机器人总是会向着边界点移动，而如果RRT树从机器人当前的位置开始，那么它到达未知区域的概率更高。机器人可能会miss掉一些地图上边角的小的边界点，而为了解决这个问题，就通过global detector，global detect会检测机器人附近的边界点用来弥补global detect的不足。 但随着地图的变大，global detector会越来越慢（或者说，随着树的变大，exploration会变慢），为此需要local detector进行加速。
frontier_opencv_detector节点是另一个边界检测器，但它不是基于 RRT。该节点使用 OpenCV 工具来检测边界点。它旨在单独运行，并且在多机器人配置中只应运行一个实例（运行此节点的其他实例没有任何区别，也就是说opencv是选装，不装照样能跑功能包）。
最初，这个节点是为了与基于 RRT 的边界检测器进行比较而实现的。在 RRT 检测器（本地和全局）旁边运行此节点可以提高 frotiner 点检测的速度。
注意：您可以运行任何类型和任意数量的检测器，所有检测器都将发布在过滤器节点订阅的同一主题上。
过滤器节点从所有检测器接收检测到的边界点，过滤这些点，并将它们传递给分配器节点以指挥机器人。过滤包括旧点和无效点的剔除，也包括多余点的剔除。
分配节点接收目标并探索目标，即过滤节点发布的过滤边界点，并据此指挥机器人向过滤后的边界点移动。分配者节点通过 move_base_node 命令机器人。
二、安装 进入到你的工作空间的src目录中，运行以下代码：
git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dd1b7c15aa5378ca0949db1929fab75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a794ce31ef8642c14bfc1570d793248e/" rel="bookmark">
			【问题解决】rrt_exploration功能包使用过程中报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 ·【SLAM】基于explore_lite的移动机器人自主建图
·【SLAM】基于rrt_explore的移动机器人自主建图
·【问题解决】rrt_exploration功能包使用过程中报错处理
文章目录 目录
系列文章
文章目录
前言
一、虚拟机仿真
二、真实机器人
总结
前言 上一篇文章介绍了RRT自主建图算法的原理、使用步骤、仿真实验，但是在从ROSWIKI上下载下拉RRT包和例程后，直接编译会产生很多错误，而且这个包官方给出的原话是在Indigo和Kinecit上编译通过，像博主这种系统是ubuntu20.04的noetic系统，一编译就报了很多错。
这篇文章，就用来总结一下报错以及处理方法，让更多小伙伴可以将这个包使用到自己的仿真环境以及真实机器人上。
一、虚拟机仿真 虚拟机环境：ubuntu20.04
1.安装依赖时
在安装RRT的依赖时，需要安装sklearn机器学习库以及numpy，官方给出的安装方式是：
sudo apt-get install python-scikits-learn sudo apt-get install python-numpy 但是在ubuntu20.04上numpy可以正确安装，而scikits-learn无法正常安装，报错如下：
E: 无法定位软件包 python-scikits-learn
可以使用这行代码，中间可能会显示scipy无法安装，但不影响功能包使用：
pip install scikits-learn 也可以使用python3安装，但是这样会附加安装很多库：
sudo apt-get install python3-scikits-learn 2.TF_REPEATED_DATA ignoring data with redundant timestamp for frame left_wheel at time
开启gazebo并启动rviz时，rviz终端会一直产生一个警告：TF_REPEATED_DATA ignoring data with redundant timestamp for frame left_wheel at time 140.726000 according to authority unknown_publisher
这时可以使用roswtf查看tf坐标变换的错误：
报错提示/robot_state_publisher发布了左右轮到base_link的tf变换，但是/gazebo又发布了左右轮到base_footprint的tf变换，导致了二者的冲突。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a794ce31ef8642c14bfc1570d793248e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dce66a3cf5efb87494b0748f893669d/" rel="bookmark">
			naiveui ssr错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cannot destructure property ‘styles’ of ‘ssrContext’ as it is undefined. 我使用的框架是nuxt3，集成naiveui build一直错误，结果是naiveUI不支持ssr，需要特殊处理 处理办法：
1、Install naive-ui and @css-render/vue3-ssr.
2、Add the following config in your nuxt.config.ts.
import { defineNuxtConfig } from 'nuxt' // https://v3.nuxtjs.org/api/configuration/nuxt.config export default defineNuxtConfig({ build: { transpile: process.env.NODE_ENV === 'production' ? [ 'naive-ui', 'vueuc', '@css-render/vue3-ssr', '@juggle/resize-observer' ] : ['@juggle/resize-observer'] }, vite: { optimizeDeps: { include: process.env.NODE_ENV === 'development' ? ['naive-ui', 'vueuc', 'date-fns-tz/esm/formatInTimeZone'] : [] } } }) 3、增加插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dce66a3cf5efb87494b0748f893669d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc4bf0db50bd4b6fd3e2e0df5609097/" rel="bookmark">
			安装npm和cnpm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介
npm是nodejs的包管理工具，用于node插件管理。cnpm是淘宝在中国做的nodejs镜像，避免访问国外的nodejs网站出现异常。
二、安装nodejs
1、安装
有两种选择一种是安装文件安装，一种是免安装的zip包。这里我选择的是.zip文件，下载完成后解压到想要放置的目录，这里我解压的目录是D:\Program Files\node-v9.11.2-win-x64。
通过cmd打开命令提示符窗口，进入安装目录D:\Program Files\node-v9.11.2-win-x64，输入npm –v，检测是否安装成功，如果安装成功会显示版本号，如果在非安装目录输入npm –v会提示没有这个命令。这是由于环境变量没配置的原因：
2、配置环境变量
在系统环境变量PATH中添加：D:\Program Files\node-v9.11.2-win-x64;
验证环境变量配置是否成功，需要打开新的命令提示符窗口操作，否则无法验证。
3、配置全局模块和cache模块路径
在命令行窗口输入：
npm config set prefix "D:\Program Files\node-v9.11.2-win-x64\node_global" npm config set cache "D:\Program Files\node-v9.11.2-win-x64\node_cache" 完成后可以在安装路径下看到新增两个文件夹node_global和node_cache：
如果想要修改设置的node_global和node_cache的名称，可以通过重新输入命令的方式修改，或者进入C:\Users\Administrator目录，找到.npmrc文件打开，修改或删除键值对：
有些安装说需要新增变量NODE_PATH，值是：D:\Program Files\node-v9.11.2-win-x64\node_global。这个可以不配置。
三、安装cnpm
1、安装
在命令提示符窗口输入
npm install -g cnpm --registry=https://registry.npm.taobao.org 安装cnpm。
安装完成后，输入cnpm –v验证是否安装成功：
这里报错是因为还需要配置环境变量。
2、配置环境变量
在系统变量PATH或用户变量PATH中添加：D:\Program Files\node-v9.11.2-win-x64\node_global。然后打开命令提示符窗口输入cnpm –v验证： 3、常用命令
1）安装依赖包：cnpm install
现在就表示安装成功了。如果项目需要安装依赖包，只要进入项目的目录，输入cnpm install就可以安装了。
2）启动项目：cnpm start
在命令提示符窗口进入项目目录，输入cnpm start就可以启动项目。
3）设置浏览器跨域属性
找到chrome.exe的路径，在命令提示符窗口输入：
"C:\Users\Administrator\AppData\Local\Google\Chrome\Application\ chrome.exe" --disable-web-security --user-data-dir=C:\chromeData 4）编译代码至dist目录：npm run build（本地编译）
在命令提示符窗口进入项目目录，输入npm run build/cnpm run build
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fc4bf0db50bd4b6fd3e2e0df5609097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/317bd4cb762eec7df4bfdb114f0c4d22/" rel="bookmark">
			【小程序】把微信小程序转换h5代码的几个关键字替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件名和内容更换 1、把.wxml扩展名改成.html
2、把wxss扩展名改成.css
3、增加body等长用项。
4、增加.css文件的链接
&lt;link rel="stylesheet" href="css/index.css"&gt;
二、css文件中替换 1、page{} 替换成 body{}
2、image 替换成 img 3、text 替换成 span
4、view 替换成 div
5、click 替换成 @click
三、html文件中替换 1、&lt;text&gt; 替换成 &lt;span&gt;
2、&lt;image&gt; 替换成 &lt;img&gt; &lt;/image&gt;
3、&lt;/image&gt; 替换成 &lt;/img&gt;
4、&lt;view&gt; 替换成 &lt;div&gt;
5、&lt;/view&gt; 替换成 &lt;/div&gt;
四、其他 &lt;span space="ensp"&gt;作者 2022-12-03 14:18:06&lt;/span&gt;
把空格换一换
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6276b5f4d6df4d2b670346aaa7669fa7/" rel="bookmark">
			【Java】求一元二次方程根
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Java】求一元二次方程根 效果 代码 package com.cxl.demo19_Exception; //求一元二次方程根 import java.util.Arrays; import java.util.Scanner; public class Demo19_01_Calculate { public static void main(String[] args){ Scanner sc = new Scanner(System.in); System.out.print("请输入一元二次方程的3个系数（用空格隔开）："); String str = sc.nextLine(); int[] arr = strToInt(str); //转整存储方法 //计算 calculate(arr[0],arr[1],arr[2]); } //String转int型 public static int[] strToInt(String str){ String[] s = str.split(" "); int[] arr = new int[s.length]; for (int i = 0; i &lt; s.length; i++) { arr[i] = Integer.parseInt(s[i]); } return arr; } //计算方程式 public static void calculate(int a, int b, int c){ String equation = a+"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6276b5f4d6df4d2b670346aaa7669fa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1086d3f61498b03a8004a10c97f1c784/" rel="bookmark">
			RockyLinux9.0系统在VMware虚拟机上【保姆级】安装步骤，并修改网络配置，使用固定IP进行SSH连接【47张过程图】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ⅰ、下载 1、镜像文件官方网站下载地址：https://rockylinux.org/download 2、下载好的iso文件放到指定的路径下，路径不要忘，后期还会用到 Ⅱ、VMware阶段安装步骤 1、在VMware种点击创建新的虚拟机 2、选择自定义（高级）–&gt;下一步 3、虚拟机硬件兼容性（默认）下一步 4、安装客户机操作系统，选择稍后安装操作系统 5、选择客户机操作系统，选择Linux(L)–&gt;版本选择Red Hat Enterprise Linux 8 64位 6、虚拟机名称自己随便起，位置自己随便选 7、处理器配置，这里最低建议给到1个处理器，2个内核，不过给高点也可以 8、内存，建议4GB起步，上不封顶，看个人电脑配置 9、网络连接，选择NAT 10、I/O控制器，选择推荐的 11、虚拟磁盘，选择推荐的 12、磁盘，选择创建新虚拟磁盘 13、磁盘容量，建议不低于20GB，下面建议选择单文件，切记不要选择立即分配所有磁盘空间 14、磁盘文件，默认，下一步 15、完成创建虚拟机 16、单击上面的完成会跳回主页面，然后，单击编辑虚拟机位置 17、单击显示器，可以在右边调分辨率（也可以不管他，让他自动检测） 18、将打印机移除，没什么用途 19、CD/DVD（SATA）这里必须选择使用ISO映像文件，然后通过浏览去找到开头下载好的iso镜像文件 20、虚拟机设置处大概动了3处，没问题点击确定 21、然后跳转至主页，点击开启此虚拟机 Ⅲ、系统阶段安装步骤 1、从这里就进入系统阶段安装了，选择第一个，然后回车。第二个是检查比较耗时间 2、等待系统自动安装。。。。。。 3、等待完了，这里先选择语言，英语好的选择English，我这里选择中文–&gt;继续 4、在安装信息界面，我们主要是用户设置和安装目的地 4.1、我们看一下时间，是不是亚洲/上海，不是的话要鼠标点一下中国区域 4.2、软件选择，这里个人使用就选择第一个带图形化界面的吧 4.3、KDUMP这个默认是打开的，建议关闭掉（开着也无所谓） 4.4、ROOT密码，这个自行设置，注意：把下面允许SSH登录勾选上 4.5、创建用户，就是创建一个普通用户，记得不要勾选设为管理员 4.6、安装目的地，这个就是给各个磁盘分配多少容量，这里可以选择默认。（后期补图） 5、上述六点没什么问题，就可以点击下面的开始安装 6、又是等待安装的过程，时间在15分钟左右 7、安装完毕后，点击重启系统 8、第一次重启有点慢，耐心等待，然后重启后，就会看到我们刚刚创建的用户了 9、点击上面的用户，输入自己在【4.5】设置密码，然后回车 10、进来后是欢迎页面，自行选择是否需要看，我这里就不看了 11、恭喜！！至此为止，系统就已经成功安装了！！！ Ⅳ、系统配置阶段步骤 1、点击下面的终端 2、输入ip addr，看一下IP地址和网卡 3、切换成ROOT用户，输入【4.4】设置的密码（密码无显示，盲输完回车即可） 4、输入下面命令查看网络信息 # 输入下面命令查看网络信息 # 第一次查看网络信息，IPV4部分，应该是method=auto cat /etc/NetworkManager/system-connections/ens160.nmconnection # 输入下面的命令对IPV4部分更改 vim /etc/NetworkManager/system-connections/ens160.nmconnection # 替换下面的代码（注意：输入自己的，在第2步输入ip addr看到的) address1=192.168.***.129/24,192.168.***.2 dns=114.114.114.114;233.5.5.5 may-fail=false method=manual 5、修改完，保存后 # 重新加载配置文件 nmcli connection load /etc/NetworkManager/system-connections/ens160.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1086d3f61498b03a8004a10c97f1c784/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3544de46a169968ac2b840566719ad71/" rel="bookmark">
			vs2017控制台应用程序调用DLL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上这类帖子乱而杂，废话不多说，直接上干货。
1、创建一个c++控制台应用程序，这块不清楚的小伙伴，可以查一下其它的帖子。
2、复制dll、lib、.h等你所需要的文件到项目根目录下
3、右键点击项目名，选择属性 ---》VC++目录，配置“包含目录”，将.h文件所在的路径添加进去，如下图：
4、与步骤3同一个页面，配置“库目录”，将lib文件所在路径添加进去。具体如下如：
5、连接器 ---》输入 中配置 “附加依赖项”，将用到的lib文件添加进去，注意，这块添加的是带lib后缀的文件名。如下图：
配置完以上属性后，点确定就好了
6、最后，不要忘了，在vs工程目录，把头文件引入。如下图，右键点击头文件，选择 添加现有项，找到你的.h文件添加就好了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/128/">«</a>
	<span class="pagination__item pagination__item--current">129/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/130/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>