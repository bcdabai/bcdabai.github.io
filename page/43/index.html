<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e8eba5e1f1bf8b1da0274d154cd4185/" rel="bookmark">
			vivado调试核ILA使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ILA（Integrated Logic Analyzer）IP Core 是 vivado 的调试核，具体如何创建、调用就不详说了。这里主要记录一个 ILA 的使用技巧，可以大大提高调试效率。
在 Program Device 后，如果添加了 ILA 核，则会出现以下的调试界面
在界面右下方的 Trigger 界面，可以设置触发点，‘+’、‘-’ 分别可以增加、删除触发信号，当满足触发条件时，ILA 会将触发点前后一段的数据抓取并显示。
默认情况下，对于深度为 Length 的 ILA 核，触发点会在 Length/2 处，前后分别抓取 Length/2 个数据，这对于大部分的时序分析已经足够了。
然而对于一些变化缓慢的信号，Quartus 中的 Signal Tap 可以使用对应的缓慢时钟取抓取，但在 vivado 中 ILA 时钟必须是自由时钟（即外接晶振的时钟）或者由 PLL IP 输出的时钟（PLL 最低可以输出 5M），而不能使用用户计数分频产生的衍生时钟。这样一来，如何抓取缓变信号（例如以 UART 传输的数据报的内容），就成为一个问题。
所以重点来了（敲黑板），在 ILA 调试界面的左下 Settings 窗口中，如下图
可以看到几个设置项，Number of windows 项是设置采样窗口的数量（比如这里设为 10 个窗口），Window data depth 设置每个采样窗口的长度（我这里设为了 512），Trigger position in window 是设置在每个窗口中触发点的位置（比如我这里设为 255，对应第 256 个采样点（这个值是从 0 开始的）），则在运行一次 ILA 抓取后，可以看到生成了 10 个黑灰相间的窗口，每个窗口长 512，每个窗口中的触发点（T 红色竖线）都位于当前窗口的第 256 个采样点处。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e8eba5e1f1bf8b1da0274d154cd4185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70573820fd730267333df95c66a0f07d/" rel="bookmark">
			SolidWorks的各种疑难杂症和小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个目录0.0 疑难杂症SolidWorks2020每次新建零件图时提示默认模板无效的解决办法Solidworks2020中零件图的材质无法正常显示的问题（只有在选中零件时材质才能正常显示）Solid Works 2020打开后显示无法获得下列许可SOLIDWORKS Standard 无法连接到服务器（-15，10，10061）的解决办法Solidworks零件图存放位置更改后装配图识别不出来的解决办法各种设置的打开方式自动正视于草图中的转折线的打开方式 小技巧工程图修改标注字体单独修改一个标注的字体修改所有标注的字体 修改注释字体如何添加材料明细表材料明细表怎么调整顺序从下往上显示材料明细表太长怎么变为两栏显示或多栏显示材料明细表如何增加一列添加中心线和中心符号线的办法 疑难杂症 SolidWorks2020每次新建零件图时提示默认模板无效的解决办法 这个问题出现的原因是因为SolidWorks2020找不到模板，因此在新建的时候会使用一个空模板来新建零件图，而我们可以将默认模板的设置修改为自己需要的设置，这样在每次新建零件图时，用我们自己设置的模板打开，就能使用我们之前设置过的规则。下面记录一下修改的办法：
点击下图所示的设置按钮： 2. 可以看到零件处的目录并不是SolidWorks的安装目录，笔者安装在了D盘，点击左侧的默认模板，再点击右侧零件处的…：
在打开的界面点击确定按钮： 4. 可以看到零件的目录已经正确变为SolidWorks安装目录了，然后点击确定，重启SolidWorks：
5. 再次新建零件图，可以看到已经没有之前的提示了，如果新建装配体和工程图的时候也出现了类似的情况，也可以按照上述步骤解决：
Solidworks2020中零件图的材质无法正常显示的问题（只有在选中零件时材质才能正常显示） 在更改零件的材质后无法正常显示，只有在选中零件时材质才能正常显示，问题的表现如下图所示：
这是未选中零件时显示的样子，笔者这里将它设置为了轻木。
这是选中零件某一个面后显示的样子，可以很明显的看出在未选中时显示不够完全。这是因为SolidWorks2020中的RealView图形未能正常开启的原因，如下图所示：
解决办法：
按快捷键Win+R打开运行，输入regedit：
在打开的注册表编辑器中，依次展开至下列目录：计算机\HKEY_CURRENT_USER\SOFTWARE\SolidWorks\Solidworks 2020\Performance\Graphics\Hardware\Current，如下图所示：
在上图中圈出来的地方可以看出你现在使用的显卡的名字，双击Renderer，在打开的窗口中复制你的显卡的名字：
点击确定后在展开目录至：计算机\HKEY_CURRENT_USER\SOFTWARE\SolidWorks\Solidworks 2020\Performance\Graphics\Hardware\Gl2Shaders在左侧的列表中展开R420（笔者这里是AMD的显卡，如果是英伟达的显卡，就展开NV40目录，如果是Intel的核显，就展开Other目录），然后在R420处右键单击，选择新建项，并重命名为第三步中复制的显卡的名字：
在刚刚新建的以显卡命名的项那里点击右键，再次新建一个DWORD（32位）值：
将新建的32位值命名为Workarounds，双击命名后的Workarounds，将数值数据改为30008：
可以看到这次并没有选中零件，但材质显示仍然正常，且视图-&gt;显示那里的RealView图形已经变为了成功打开的模式，说明问题解决了：
Solid Works 2020打开后显示无法获得下列许可SOLIDWORKS Standard 无法连接到服务器（-15，10，10061）的解决办法 刚安装上的Solid Works在第一次使用时是完全正常的，等到重启电脑之后再次运行时，就弹出了下图所示的报警信息：
出现这个问题的一般原因是因为图下如下图所示的Solid Works Licensing Service服务没有正常启动运行，打开任务管理器，切换到服务选项卡，往下翻到这个服务，可以看到圈圈处显示已停止运行。
该服务已停止运行的原因一般是在安装Solid Works时没有在软件根目录下复制如图所示的这个名为Solid Works_Flexnet_Server的文件夹，且没有运行该文件夹里的名为server_install的注册表文件
将该文件夹复制到Solid Works软件安装的根目录文件SOLIDWORKS Corp下，如图所示：
（如果你没有这个文件夹了，可以去这里下载）
打开SolidWorks_Flexnet_Server文件夹，右键以管理员身份运行server_install.bat文件，运行结果如图所示：
可以看到任务管理器服务选项卡里的Solid Works Licensing Service已经开始运行，接着运行Solid Works软件，就可以正常打开了：
但是此时还需要将服务启动失败时的操作设置为重新启动，防止在某些极端情况下该服务仍然启动不了，导致SolidWorks无法运行。首先在此电脑处右键单击，打开管理：
服务和应用程序下的服务选项，在右侧窗口中找到“SolidWorks Flexnet Server”服务，双击打开：
在弹出的页面中选择“常规”选项卡，将划线部分设置为“自动”
切换到“恢复”选项卡，按照下图所示进行设置：
之后重启计算机即可完成设置
Solidworks零件图存放位置更改后装配图识别不出来的解决办法 例如原本的装配体如下所示：
在移动了其中的零件图之后，如下图所示：
这是因为SolidWorks找不到该零件图，所以把该零件在装配图中显示的时候压缩了，手动取消压缩，给软件制定该零件图的目录即可：
鼠标在缺失的零件上右键单击，选择下图所示的解除压缩命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70573820fd730267333df95c66a0f07d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea5a5b169526c6ca2028608fbf5d141/" rel="bookmark">
			C# ReadOnly&amp;&amp;Ref Out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# ReadOnly ReadOnly先看两种情况1.值类型2.引用类型 结论 Ref Out ReadOnly官方文档 ReadOnly 先看两种情况 1.值类型 当数据是值类型时，标记为Readonly时，如果再次设置值，会提示报错，无法分配到只读字段
public class A { private readonly int x; public A(int x) { this.x = x; //在构造函数里，可以多次赋值，但是出了构造函数，值类型就无法变更了。 this.x = x*2; } public void TryToUpdateInt() { //报错，无法分配到只读字段 x = 4; } } 2.引用类型 这里成功给引用类型赋值
public class RefOut { private readonly Dictionary&lt;string, int&gt; myDictionary = new Dictionary&lt;string, int&gt;(); public RefOut() { // 添加键值对 myDictionary.Add("One", 1); myDictionary.Add("Two", 2); } public void TryToAddKeyValuePair() { //这里没有报错，运行程序 myDictionary.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea5a5b169526c6ca2028608fbf5d141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba3c793a52e5618b9e8b4909a6ef24d/" rel="bookmark">
			如何开发干洗店用的小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		洗护行业现在都开始往线上的方向发展了，越来越多的干洗店都推出了上门取送服务，那么就需要开发一个干洗店专用的小程序去作为用户和商家的桥梁，这样的小程序该如何开发呢？
一、功能设计：根据干洗店的业务需求和小程序的特点，设计小程序的功能，包括但不限于衣物登记、洗衣流程逻辑、订单管理、水洗唛打印、会员管理、衣物上挂、多门店多网点管理等功能。
二、界面设计：设计小程序的界面风格和布局，以简洁明了、操作便捷为主，让用户能够快速了解和使用。
三、后端开发：开发后端服务器，处理用户的下单支付、订单管理等功能，同时提供API接口与小程序进行交互。
四、数据库设计：设计数据库结构，存储用户信息、订单信息、衣物信息等数据。
五、支付功能：集成第三方支付平台，实现用户的在线支付功能。
六、会员管理：提供会员管理功能，包括会员注册、登录、积分管理、等级管理等功能。
七、衣物登记：提供衣物登记功能，方便用户对衣物进行登记和管理。
八、洗衣流程：提供洗衣流程展示功能，让用户能够了解洗衣的整个流程。并且在流程的必要节点用户可以收到通知，知道自己的衣物到哪一步了。
九、订单管理：提供订单管理功能，包括订单查询、订单状态管理等功能。
十、测试和优化：对小程序进行测试和优化，包括功能测试、性能测试、兼容性测试等，确保小程序的质量和稳定性。
十一、上线推广：上线小程序，并通过社交媒体、广告投放等方式进行推广，吸引更多的用户使用小程序。
以上就是开发一个干洗店用的小程序需要的功能和步骤，您觉得还需要有哪些功能呢，可以和闪站侠讨论一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64da7e1aba5e3c1890d22d31015e845a/" rel="bookmark">
			开发上门送桶装水小程序要考虑哪些业务场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上门送水业务已经有很长一段时间了，但是最开始都是给用户发名片、贴小广告，然后客户电话订水，水站工作人员再上门去送，这种人工记单和派单效率并不高，并且电话沟通中也比较容易出现偏差，那么根据这个情况就可以开发一款上门送水小程序，这样的小程序需要根据业务场景都需要开发哪些功能呢，一起来了解一下吧。
一、用户注册登录：提供注册和登录功能，收集用户信息，建立用户账户，方便用户管理和查询订单。
二、水源选择：提供多种水源选择，包括天然矿泉水、纯净水等，用户可以根据自己的需求选择所需的水源类型。
三、送水时间选择：提供送水时间选择功能，用户可以根据自己的时间安排选择合适的送水时间。
四、送水地点选择：提供送水地点选择功能，用户可以输入送水地址，以便将水送到指定位置。
五、订单管理：提供订单管理功能，包括订单状态、送水时间、送水地点等信息的查询和管理。
六、支付功能：提供支付功能，包括在线支付和线下支付两种方式，用户可以根据自己的需求选择支付方式。
七、优惠活动：提供优惠活动功能，例如折扣、赠品等，以吸引更多用户下单。
八、客户服务：提供客户服务功能，包括在线咨询、投诉建议等，以便用户更好地了解和使用服务。
九、水源介绍：提供水源介绍和相关资讯功能，帮助用户更好地了解和使用不同类型的水源。
十、桶押金：系统需要根据用户的用桶量自动对应不同的押金，用户退桶管理员可以直接线上退去押金，方便快捷。
十一、用户评价：提供用户评价功能，以便其他用户了解水源的质量和服务质量。
您觉得送水小程序还需要有哪些功能呢，一起讨论一下吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141e9f6fbde9497591254f66a1cab704/" rel="bookmark">
			LeetCode_Boyer-Moore 投票算法_简单_169.多数元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.题目2.思路3.代码实现（Java） 1.题目 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1：
输入：[3,2,3]
输出：3
示例 2：
输入：[2,2,1,1,1,2,2]
输出：2
n == nums.length
1 &lt;= n &lt;= 5 * 104
-109 &lt;= nums[i] &lt;= 109
进阶：
尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/majority-element
2.思路 （1）排序
将数组 nums 中的所有元素排序后（无论是升序还是降序），那么下标为⌊ n/2 ⌋的元素一定是众数。
（2）哈希表
使用哈希表来存储每个元素以及出现的次数，其中键为元素，值为该元素出现的次数；遍历数组 nums 并将数组中的每个元素加入哈希表中；遍历哈希映射中的所有键值对，返回值最大的键即可。 （3）Boyer-Moore投票算法
思路参考本题官方题解。
3.代码实现（Java） //思路1————排序 class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length / 2]; } } //思路2————哈希表 class Solution { public int majorityElement(int[] nums) { Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/141e9f6fbde9497591254f66a1cab704/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec3294554a67c8e75e3bdb9932f131b4/" rel="bookmark">
			Skywalking的安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Skywalking搭建部署
1、下载skywalking 服务，下载地址：Index of /dist/skywalking
2、解压后的目录说明
3、修改ui服务端口：
4、启动skywalking服务
5、spingcloud微服务客户端配置skywalking
-javaagent:D:\apache-skywalking-apm-bin-es7\agent\skywalking-agent.jar
-DSW_AGENT_NAME=api-gateway（自行命名，一般用nacos中的服务名）
-DSW_AGENT_COLLECTOR_BACKEND_SERVICES=127.0.0.1:11800
注意：如果是使用springcloud的gateway组件，需要根据以下步骤才能在skywalking中展示
（1）需要把optional-plugins目录下的这两个文件移动到plugins中去
linux系统skywalking接入微服务
6、修改skywalking持久化配置
（1）修改配置文件D:\apache-skywalking-apm-bin-es7\config\application.yml中的storage配置项，使用数据库存储需要先创建好数据库
（2）目录D:\apache-skywalking-apm-bin-es7\oap-libs下需要放入mysql连接jar包
7、自定义链路追踪
（1）项目pom.xml引入skywalking工具类
&lt;dependency&gt; &lt;groupId&gt;org.apache.skywalking&lt;/groupId&gt; &lt;artifactId&gt;apm-toolkit-trace&lt;/artifactId&gt; &lt;version&gt;8.5.0&lt;/version&gt; &lt;/dependency&gt; 2）需要记录链路追踪的业务方法上添加@Trace标签
（3）记录标记追踪方法的参数和返回值
8、性能剖析
新建任务
9、spring日志中加入skywalking的追踪id
（1）项目新建logback-spring.xml日志配置文件，在日志数据格式中加入[%tid]
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;configuration&gt; &lt;!-- 引入springboot默认的logback xml配置--&gt; &lt;include resource="org/springframework/boot/logging/logback/defaults.xml" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"&gt; &lt;layout class="org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout"&gt; &lt;Pattern&gt;-%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} [%tid] %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&lt;/Pattern&gt; &lt;/layout&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="console" /&gt; &lt;/root&gt; &lt;/configuration&gt; 2）重启项目后，请求接口控制台输入tid的日志信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec3294554a67c8e75e3bdb9932f131b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ea5b87d1ae7f791e324929eb12c55f/" rel="bookmark">
			Docker 一键安装Confluence（已支持最新版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 一键安装Confluence（已支持最新版本） 本文用于Confluence在Docker的安装，仅用于记录安装方式Jira 也可以参考这种方式安装，只有细微差别转载请注明来源Linux安装可参考链接Windows安装可查考链接条件允许时，请优先选择CentOS7 原生安装 一、查找想要的版本 跟着文档走，不想换版本的，请跳过此部分 1. 登录DockerHub 传送门 https://hub.docker.com/ 2. 筛选你需要的版本 登录后通过打开链接或搜索到达下方页面传送门 https://hub.docker.com/r/atlassian/confluence-server/tags 二、本文搞的就是一键搞定 说是一键，实际上是执行一个脚本，脚本如下： # 下载agent文件 wget https://www.xujian.tech/raw/atlassian-agent.jar -O atlassian-agent.jar # 用mysql的人比较多，咱们把驱动也提前准备好 # MySQL 5.7 驱动地址 wget http://file.xujian.tech/mysql-connector-java-5.1.49.jar -O mysql-connector-java-5.1.49.jar # MySQL 8+ 驱动地址 wget http://file.xujian.tech/mysql-connector-java-8.0.26.jar -O mysql-connector-java-8.0.26.jar # confluence版本，需要官方有的才行 tag=8.5.0-jdk17 # 拉取镜像，可以去官方查找你想要的版本 docker pull atlassian/confluence-server:${tag} # 如果已经有confluence了，那么先关闭并删除 docker stop confluence docker rm confluence # 注意正确填写您的数据位置 docker run -v /data/confluence:/var/atlassian/application-data/confluence --name="confluence" -d -p 8090:8090 -p 8091:8091 atlassian/confluence-server:${tag} # 上一步如果要修改了容器名，这里也请修改。拷贝文件进容器 docker cp atlassian-agent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6ea5b87d1ae7f791e324929eb12c55f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f28217819302f788e89e00871d10cf6/" rel="bookmark">
			【免费不限量】API数据接口：城市树、adcode、行政区划、省市区查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【免费不限量】API数据接口：城市树、adcode、行政区划、省市区查询 本文提供一个IP定位查询接口：城市树、adcode、行政区划、省市区查询已在本数据库建立中国省市区数据库，并定期更新，提供接口，以降低各位的开发成本，如果未来能形成标准，那就更好了接口是免费、不限量的请求必要的code可以通过搜索小程序“数字续坚”，在首页签到后取得接口内容不包含敏感信息，如有侵权，请联系作者删除。 1 接口功能 根据名称、adcode查询行政区划信息返回城市树 2 接口用法 2.1 重要参数 入参 序号项目值说明1接口地址https://www.xujian.tech/atlapi/data/m/city/tree2请求方式GET3请求参数1code用来识别用的code，在微信小程序“数字续坚”首页签到取得，不会变化4请求参数2adCode通过adCode查询城市信息，adCode、name中至少有一个需要填写5请求参数3name通过城市名称模糊匹配查询城市信息，adCode、name中至少有一个需要填写6请求参数4full非必填，传1时把匹配到的结果的下一级也查出来补充在树中。 - 重要说明：code不可变更，请注意保密
出参标准格式 序号项目值说明1返回值格式JSONObject含code、data、msg2返回值1code200为成功，其他表示失败3返回值2msg成功(succeed.)、失败的文字描述4返回值3data一个含基本信息（如name、adcode、cityCode、parentCode、children）的树结构，子节点存储在children中 2.2 返回值 序号参数名类型说明1nameString省份（或直辖市）名称2adcodeStringadcode: 中国行政区划代码3cityCodeString城市区号，比如重庆0234parentCodeString父级adCode5childrenJSONArray子节点数据，所有节点对象都属性都是一样的 2.3 请求示例 # 下方地址中的code请到“数字续坚”小程序首页签到获取，不会变化，注意保密 curl https://www.xujian.tech/atlapi/data/m/city/tree?full=1&amp;adCode=370100&amp;name=&amp;code= 2.4 返回示例 { "code": 200, "msg": "succeed.", "data": { "adCode": "100000", "name": "中华人民共和国", "cityCode": null, "parentCode": null, "children": [ { "adCode": "370000", "name": "山东省", "cityCode": null, "parentCode": "100000", "children": [ { "adCode": "370100", "name": "济南市", "cityCode": "0531", "parentCode": "370000", "children": [ { "adCode": "370101", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f28217819302f788e89e00871d10cf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a46453ab99a35461fa5ccd56b1fbb07/" rel="bookmark">
			K8S运维中可能会遇到哪些问题呢？以及如何解决呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们说几个常见的一些问题，以及大概的解决方法。
1.拉取镜像失败:
这可能是由于网络问题或镜像源服务器问题导致的。解决方法是检查网络连接是否正常，或者尝试更换其他镜像源。
2.Pod无法创建或启动:
这可能是由于YAML文件配置错误、资源限制问题或者网络问题导致的。解决方法是检查YAML文件配置是否正确，确认资源限制是否满足，或者检查网络设置是否正确。
3.服务创建失败:
这可能是由于Kubernetes API服务器的问题或资源限制问题导致的。解决方法是检查API服务器是否正常运行，或者尝试降低资源限制。
4.节点无法加入集群：
这可能是由于网络问题、证书问题或配置问题导致的。解决方法是检查网络连接是否正常，证书是否正确，或者重新进行节点配置。
5.资源不足:
这可能是由于集群资源不足或者应用程序资源需求过高导致的。解决方法是增加集群节点数量或者优化应用程序资源使用。
6.容器间通信问题:
这可能是由于网络设置错误或者服务发现机制问题导致的。解决方法是检查网络设置是否正确，或者重新配置服务发现机制。
7.容器存储问题:
这可能是由于存储卷挂载失败或者存储卷数据持久化问题导致的。解决方法是检查存储卷设置是否正确，或者重新配置存储卷的数据持久化。
8.安全策略问题:
这可能是由于安全策略设置错误或者RBAC权限问题导致的。解决方法是检查安全策略设置是否正确或者重新配置RBAC权限。
9.不能进入指定容器内部:
这可能是由于yml文件comtainers字段重复，导致该pod没有该容器。解决方法是删除错误的
pod，并重新拉取镜像。
具体情况还是具体分析并给予相对应的解决措施。
还是要多花时间学习，深入理解底层原理和架构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736a4413bb662baa6a62a05edc99680d/" rel="bookmark">
			微信小程序之上拉加载和下拉刷新 ： 微信小程序教程系列18
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序上实现下拉刷新、上拉加载的效果
使用系统提供的onPullDownRefresh、onReachBottom这2个事件，
前提需要在app.json或page.json配置文件中设置，才能使用。
app.json是全应用的页面都可以使用该事件，page.json则只是对应的页面才可以使用。
示例：
app.json：
在app.json文件里设置window属性
{ "window":{ "enablePullDownRefresh": true } } page.json：
在page.json文件里直接设置属性
{ "enablePullDownRefresh": true } 示例：
可以结合导航栏loading显示正在加载的效果
Page({ data: { pageNum: 1, // 设置加载的第几次，默认是第一次 isFirstLoad: true, // 用于判断List数组是不是空数组，默认true，空的数组 hasMore: false, // “加载更多” }, // 下拉刷新 onPullDownRefresh: function () { // 显示导航栏loading wx.showNavigationBarLoading(); // 调用接口加载数据 this.loadData(); // 隐藏导航栏loading wx.hideNavigationBarLoading(); // 当处理完数据刷新后，wx.stopPullDownRefresh可以停止当前页面的下拉刷新 wx.stopPullDownRefresh(); }, // 上拉加载 onReachBottom(e) { let that = this; if (that.data.hasMore) { that.setData({ pageNum: that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/736a4413bb662baa6a62a05edc99680d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d394ba7bfcdf64ee5fd80fca424340/" rel="bookmark">
			IDEA控制台中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在IDEA中，如果控制台输出的中文字符显示为乱码，可能是因为控制台的编码设置不正确。你可以尝试以下方法来解决此问题：
方法1：更改IDEA控制台编码
打开IDEA的设置：File -&gt; Settings（Windows/Linux）或IntelliJ IDEA -&gt; Preferences（macOS）。在左侧面板中，找到"Editor" -&gt; "Console"选项。在右侧面板的"Console encoding"下拉框中选择合适的编码，如UTF-8。点击"Apply"或"OK"按钮以保存更改。 这样设置后，控制台应该能够正确显示中文字符。
方法2：使用Java代码指定控制台编码
如果方法1无效，你可以尝试在代码中显式地设置控制台编码。在你的程序入口处，即main方法的开头，添加以下代码：
System.out.println("控制台编码：" + System.getProperty("console.encoding")); System.setProperty("console.encoding", "UTF-8"); 或者
import java.io.PrintStream; import java.io.UnsupportedEncodingException; public class DBConnection { public static void main(String[] args) { try { System.setOut(new PrintStream(System.out, true, "UTF-8")); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } // 其他代码... } } 这段代码会打印出当前控制台编码，并将其设置为UTF-8。请确保将其放置在其他控制台输出语句之前。
重新运行代码，控制台应该能够正确显示中文字符。
希望这些方法能够帮助你解决控制台输出乱码的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ad1ec7001b906e0245b7f94af8df0d/" rel="bookmark">
			onclick、onserverclick、onclientclick
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		onclick、onserverclick、onclientclick三者的区别 - Pumpkin_L - 博客园 (cnblogs.com)
onclientclick和onclick区别 - 盛开的雨季 - 博客园 (cnblogs.com)
ASP.NET的OnClientClick与OnClick事件 - 杜龙飞 - 博客园 (cnblogs.com)
ASP.NET中OnClientClick与OnClick的区别-CSDN博客
第一部分:onclick、onserverclick HTML控件，如input还有a标签，只有onclick ( 客户端）和onserverclick（服务端）事件，而没有onclientclick事件。
(一).onclick（客户端）事件 （注意不加runat="server"）
&lt;input type="button" value="按钮" onclick="Myonclick()" /&gt; 然后js调用
&lt;script&gt; function Myonclick() { alert("触发了onclick事件！"); } &lt;/script&gt; (二).onserverclick（服务端）事件 （注意这里要加上 runat="server" ）
&lt;input type="button" value="按钮" id="btn" onserverclick="btn_ClickServer" runat="server"/&gt; .cs代码
public void btn_ClickServer(object sender, EventArgs e) { string str = "&lt;script&gt;alert('你触发了onclickServer事件');&lt;/script&gt;"; Response.Write(str); Response.End(); } 上述两种事件，Onclick先于OnserverClick执行；
第二部分:onclientclick，onclick （一）onclientclick，onclick二者的区别与联系 WEB控件，如&lt;asp:button&gt;等，只有onclientclick( 客户端）和onclick （服务端）事件，而没有onserverclick事件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ad1ec7001b906e0245b7f94af8df0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c91bfd1145016800db3f704ee50c93/" rel="bookmark">
			Linux主机名与免密登录实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux主机名与免密登录实操 1、配置设备主机名2、A主机 -&gt; B主机 可免密码登录实操2.1，修改主机的hostname2.2，在A192.168.168.101主机生成密钥对2.3，A主机发送公钥到B主机2.4，从A主机免密登录B主机测试2.5，A主机发送命令到B主机执行 1、配置设备主机名 1.直接修改配置文件
vim /etc/hostname systemctl restart systemd-hostnamed.service 注意：修改完配置需要重启hostnamed服务
2.使用nmtui修改主机名（图形化界面）
systemctl restart systemd-hostnamed.service 3.hostnamectl修改主机名 永久修改主机名
hostnamectl set-hostname 123 将当前主机名修改为123 注意：该方法需要与hostname相区分
hostname命令是临时修改 hostnamectl是永久修改主机名
4.nmcli命令修改主机名
nmcli general hostname server1 systemctl restart systemd-hostnamed.service 2、A主机 -&gt; B主机 可免密码登录实操 2.1，修改主机的hostname A主机 192.168.168.101 [root@www ~]# hostname www B主机 192.168.168.102 [root@mail ~]# hostname mail 2.2，在A192.168.168.101主机生成密钥对 [root@www .ssh]# ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97c91bfd1145016800db3f704ee50c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85ca299182cdfd5842527856ece2de2/" rel="bookmark">
			Nginx采集日志的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：微点阅读 https://www.weidianyuedu.com
由于nginx功能强大，性能突出，越来越多的web应用采用nginx作为http和反向代理的web服务器。而nginx的访问日志不管是做用户行为分析还是安全分析都是非常重要的数据源之一。
如何有效便捷的采集nginx的日志进行有效的分析成为大家关注的问题。本文通过几个实例来介绍如何通过filebeat、logstash、rsyslog采集nginx的访问日志和错误日志。大家都知道ELK技术栈是采集、分析日志的利器。所以这里介绍的是从nginx采集日志到ES。当然至于日志采集以后存到看大家的需要。
通过logstash可以方便的配置日志输出存储的方式。一般来说nginx默认安装后，日志文件在 /usr/local/nginx/logs 目录下。分别有 access.log和error.log 访问日志和错误日志。这次示例Elasitcsearch是三个节点组成的集群172.28.65.22、172.28.65.23、172.28.65.24，172.28.65.30 是kibana的地址，172.28.65.32是数据采集服务器，上面装有logstash、nginx、 filebeat。一般来说采集服务器上有logstash，而nginx、 filebeat应该是装在采集目标上。
一、直接通过filebeat采集日志到ES 在filebeat的安装目录找到filebeat.yml 配置获取日志文件的路径及输出到ES的配置。具体：
- type: log # Change to true to enable this input configuration. enabled: true # Paths that should be crawled and fetched. Glob based paths. paths: #- /var/log/*.log - /usr/local/nginx/logs/*.log #- c:\program&gt; 如果需要在kibana中友好显示的化，可进行kibana配置
输出到es中，在hosts中配置好你的ES服务地址。如果单机只有一个节点，就可以只配一个ip和端口。
启动filebeat 进行日志数据采集
./filebeat -e -c filebeat.yml -d "publish" 通过elasticsearch-head插件查看es索引中的日志信息
可以看到nginx中的access.log和error.log的日志都已经上来了。在kibana中通过filebeat-*过滤看filebeat的索引，可以看到通过filebeat采过来的数据。
这种直接通过filebeat直接对接ES采日志的方式简单直接，但是无法对采集的日志进行预处理和其他一些操作，也不够灵活。可以在filebeat 和 ES之间加一层Logstash，可以将filebeat于ES解耦，通过Logstash可以做一些预处理，也可以通过Logstash采集到除ES以外的其他数据存储上。
二、通过filebeat采集日志到logstash再送到ES 首先得安装 logstash ，安装完后在logstash的安装目录下新建vi filebeat-pipeline.conffilebeat-pipeline.conf的具体配置如下：
input { beats { port =&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d85ca299182cdfd5842527856ece2de2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9303a623449a5f93af2faa717c92bc17/" rel="bookmark">
			InfoNCE Loss公式及源码理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		InfoNCE Loss公式及源码理解–从交叉熵损失谈起 当谈论到信息论中的损失函数时，InfoNCE（Noise Contrastive Estimation）和交叉熵损失都是两个关键的概念。它们不仅在衡量概率分布之间的差异方面发挥着重要作用，而且在深度学习的自监督学习领域扮演着重要角色。虽然它们的形式和应用环境有所不同，但是我们可以发现它们之间存在着微妙的联系。
交叉熵损失作为衡量两个概率分布之间距离的指标，在分类任务和神经网络训练中广泛使用。而InfoNCE Loss，则是针对自监督学习任务中特征学习的一种损失函数。它通过比较正样本和负样本的相似性来学习模型参数，从而提高特征的区分度。
在这篇博客中，我们将深入探讨交叉熵损失和InfoNCE之间的联系，探究它们在信息论和深度学习中的联系与异同。我们将分析两者的数学形式、应用领域以及它们之间可能的内在关系，以期对这两个重要概念有更深入的理解。
InfoNCE InfoNCE Loss（Noise Contrastive Estimation Loss）是一种用于自监督学习的损失函数，通常用于学习特征表示或者表征学习。它基于信息论的思想，通过对比正样本和负样本的相似性来学习模型参数。
公式介绍 InfoNCE Loss的公式如下：
InfoNCE Loss = − 1 N ∑ i = 1 N log ⁡ ( exp ⁡ ( q i ⋅ k i + τ ) ∑ j = 1 N exp ⁡ ( q i ⋅ k j − τ ) ) \text{InfoNCE Loss} = -\frac{1}{N} \sum_{i=1}^{N} \log \left( \frac{\exp \left( \frac{q_i \cdot k_{i^+}}{\tau} \right)}{\sum_{j=1}^{N} \exp \left( \frac{q_i \cdot k_{j^-}}{\tau} \right)} \right) InfoNCE Loss=−N1​i=1∑N​log ​∑j=1N​exp(τqi​⋅kj−​​)exp(τqi​⋅ki+​​)​ ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9303a623449a5f93af2faa717c92bc17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f70b9d292c8031dc2d0cd339759150e/" rel="bookmark">
			百川2-大模型-论文笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0.资料预览1.模型特点速览2.模型效果对比2.1 对比BaiChuan 12.2 对比其它开源模型2.2.1 通用基准测试-整体对比2.2.2 垂直领域测试2.2.2.1 法律2.2.2.2 数学、编码2.2.2.3 多语言领域 3. 预训练数据3.0 数据分布3.1数据源3.2 数据处理3.2.1 预训练数据处理流程 4. 模型结构&amp;预训练4.0 基础结构4.1 输入4.1.1 词表4.1.2 字符编码4.1.3 位置编码 4.2 中间结构4.2.1 激活函数4.2.2 注意力层4.2.3 归一化层4.2.3.1 层归一化4.2.3.2 归一化头 NormHead 4.3 预训练4.3.0 损失4.3.1 优化器4.3.2 数据精度4.3.3 预训练损失变化 4.4 通过缩放得到大模型 5. 后续训练：SFT &amp; RLHF5.1 SFT: 监督微调5.2 RLHF: 从人类反馈中强化学习5.2.1 RLHF过程示意图5.2.2 奖励模型 (Reward Model, RM)5.2.3 PPO5.2.4 RLHF 训练细节 6. 数据毒性6.1 预训练阶段6.2 SFT &amp; RLHF 阶段6.3 评估6.3.1 Toxigen（Hartvigsen等人，2022）数据集6.3.2 百川无害评价数据集(BHED) 7. ckpt8. 设备 0.资料预览 论文位置：https://cdn.baichuan-ai.com/paper/Baichuan2-technical-report.pdfgithub： https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f70b9d292c8031dc2d0cd339759150e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e084940aac10d357081706656df960/" rel="bookmark">
			git常常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章中，一些简单的，大家都知道的git 命令我就不再赘述，我只写出来最近在项目中常用到的一些命令。这些命令可以帮助我更好的开发。
git stash 请大家设想下面的场景，你的本地有两个分支，develop,fix分支，你正在develop分支上写一些需求，但是还没有写好，突然来了一个很紧急的bug，这个bug需要你切换到fix分支进行修改。此时你会怎样？是把未开发完毕的需求commit吗？还是直接变更分支？直接commit会导致本地的提交非常的乱。直接变更分支，那你未开发完毕的代码可就离你而去了……
你有更好的选择。git stash 可以帮助你先将没开发完毕的需求放到暂存区中，允许你切换到其他分支修改完毕后，切回原先的分支并恢复。这样你就可以重新开发了。
使用：
1.git stash 保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行git status命令，就会发现当前是一个干净的工作区，没有任何改动。使用git stash save 'message...'可以添加一些注释
2.git stash list 显示保存进度的列表。也就意味着，git stash命令可以多次执行。
3.git stash pop [–index] [stash] git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。
git stash pop --index 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区）
git stash pop stash@{1}恢复指定的进度到工作区。stash_id是通过git stash list命令得到的
通过git stash pop命令恢复进度后，会删除当前进度。
4.git stash apply [-index] [stash_id] 通过git stash apply命令恢复进度后，不会删除当前进度，其余和git stash pop 一样
5.git stash drop [stash_id] 删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。
6.git stash clear 清除所有存储的进度
commit后再撤销commit 当你commit修改了一些代码后，提交到本地了。后来又发现有更好的解决办法，但是此时本地已经有一版commit了，为了保证工作树的清晰，尽量不要commit两次。那么此时如何撤回之前的commit
git reset --soft HEAD^ 这样就成功撤销了commit，如果想要连着add也撤销的话，–soft改为–hard（删除工作空间的改动代码）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e084940aac10d357081706656df960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b236acd05276b992ba6e3ef21e8ad14/" rel="bookmark">
			仪表盘：pyecharts绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、仪表盘 在数据分析中，仪表盘图（dashboard）的作用是以一种简洁、图表化的方式呈现数据的关键指标和核心信息，以帮助用户快速理解数据的情况，并从中提取关键见解。
仪表盘图通常由多个图表、指标和指示器组成，可以根据用户需求定制，用来监控和分析关键业务指标、数据趋势、关联关系等。
二、实现代码 from pyecharts import options as opts from pyecharts.charts import Gauge from pyecharts.render import make_snapshot from snapshot_selenium import snapshot import os gauge = ( Gauge() .add("", [("电量", 90)], split_number=5) .set_global_opts( title_opts=opts.TitleOpts(title="电池电量仪表图", subtitle="示例"), legend_opts=opts.LegendOpts(is_show=False), ) .set_series_opts( axisline_opts=opts.AxisLineOpts( linestyle_opts=opts.LineStyleOpts( color=[[0.2, "#c23531"], [0.8, "#63869e"], [1, "#91c7ae"]], width=30, ) ), splitline_opts=opts.SplitLineOpts( is_show=True, linestyle_opts=opts.LineStyleOpts(width=3, color="auto"), ), ) ) #gauge.render("customized_gauge.html") # 渲染图形为HTML文件 make_snapshot(snapshot, gauge.render(), "仪表盘.png") # 判断文件是否存在，并打印文件路径 if os.path.isfile("仪表盘.png"): print("图像保存成功，文件路径为：" + os.path.abspath("仪表盘.png")) else: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b236acd05276b992ba6e3ef21e8ad14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a7db0a9ab230d4b6b2bfe97b68f454/" rel="bookmark">
			强化学习中On-policy与off-policy的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Off-policy方法——将收集数据当做一个单独的任务 off-policy的方法将收集数据作为RL算法中单独的一个任务，它准备两个策略：行为策略(behavior policy)与目标策略(target policy)。行为策略是专门负责学习数据的获取，具有一定的随机性，总是有一定的概率选出潜在的最优动作。而目标策略借助行为策略收集到的样本以及策略提升方法提升自身性能，并最终成为最优策略。Off-policy是一种灵活的方式，如果能找到一个“聪明的”行为策略，总是能为算法提供最合适的样本，那么算法的效率将会得到提升。
On-policy——行为策略与目标策略相同 on-policy里面只有一种策略，它既为目标策略又为行为策略。SARSA算法即为典型的on-policy的算法。
需要注意的问题： 1.为什么有时候off-policy需要与重要性采样配合使用？
重要性采样是用一个概率分布的样本来估计某个随机变量关于另一个概率分布的期望。
假设已知随机策略π(a|s)，现在需要估计策略对应的状态值Vπ，但是只能用另一个策略π'(a|s)获取样本。对于这种需要用另外一个策略的数据(off-policy)来精确估计状态值的任务，需要用到重要性采样的方法，具体做法是在对应的样本估计量上乘上一个权重(π与π'的相对概率)，称为重要性采样率。
参考链接：
强化学习中的奇怪概念(一)——On-policy与off-policy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792ac0e35c7fea862ea34e76854d7369/" rel="bookmark">
			shell脚本字典创建遍历打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解释：
代码块中包含了每个用法的详细解释
#!/bin/bash # 接收用户输入的两个数 echo "请输入第一个数：" read num1 echo "请输入第二个数：" read num2 # 创建一个关联数组 declare -A dict1 declare -A dict2 # 定义键和值的数组 key1=(1 3 5 7 9 2 4 6 8 10) key2=(10 8 6 4 2 9 7 5 3 1) value1=(1 2 3 4 5 6 7 8 9 10) # 循环遍历数组，将键和值对应起来 for ((i=0; i&lt;${#key1[@]}; i++)); do dict1[${key1[i]}]=${value1[i]} done for ((i=0; i&lt;${#key2[@]}; i++)); do dict2[${key2[i]}]=${value1[i]} done #打印(echo用 -e \t组合使得输出显示空格) echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/792ac0e35c7fea862ea34e76854d7369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6339ed3fe04bc415bcd98cd59a1b0eee/" rel="bookmark">
			心脏病数据集Spark-Scala分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Sprak是什么？
二、Scala介绍与安装
1.Scala介绍
2.Windows安装Scala
1.将scala-2.11.12.zip解压到某个路径
2.配置SCALA_HOME和path环境变量
三.IDEA创建普通的scala项目
1.安装scala插件
四.准备数据集
1.数据来源
2.数据指标
五.编写统计分析代码
1.建一个包便于观察
2.导入需要的包
3.编写统计代码，分析数据相关性
1.Age_agg
2.AgeMax_thalach
3. Agg_chol
4.Max_chol
5.cp_chance
6.Max_trestbps
总结
前言 随着心脏病患者的逐年增加，我们运用有效的知识来分析统计心脏病与各数据指标的关系，来减少患有心脏病的风险
提示：以下是本篇文章正文内容，下面案例可供参考
一、Sprak是什么？ spark官网Apache Spark™ - Unified Engine for large-scale data analytics
Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。目前，Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、SparkStreaming、GraphX、MLlib等子项目，Spark是基于内存计算的大数据并行计算框架。Spark基于内存计算，提高了在大数据环境下数据处理的实时性，同时保证了高容错性和高可伸缩性，允许用户将Spark部署在大量廉价硬件之上，形成集群。Spark得到了众多大数据公司的支持，这些公司包括Hortonworks、IBM、Intel、Cloudera、MapR、Pivotal、百度、阿里、腾讯、京东、携程、优酷土豆。当前百度的Spark已应用于凤巢、大搜索、直达号、百度大数据等业务；阿里利用GraphX构建了大规模的图计算和图挖掘系统，实现了很多生产系统的推荐算法；腾讯Spark集群达到8000台的规模，是当前已知的世界上最大的Spark集群。
————————————
二、Scala介绍与安装 1.Scala介绍 Scala是一门多范式的、纯粹的面向对象、函数式编程语言。由于Scala文件（.scala）可被编译成Java字节码，所以scala程序可以由JVM加载并运行。
由于Scala编译后得到Java字节码，所以Scala和Java本质上是一个东西，Scala和Java类可以相互调用。
import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import warnings warnings.filterwarnings('ignore') import ssl ssl._create_default_https_context = ssl._create_unverified_context 2.Windows安装Scala 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6339ed3fe04bc415bcd98cd59a1b0eee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/721883ea185b5644a60350a42d990c83/" rel="bookmark">
			ORA-00821_ Specified value of sga_target 1280M is too small, needs to be at least 1744M
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述：oracle数据库启动出现错误： idle 25-JUL-23&gt; startup ORA-00821: Specified value of sga_target 1280M is too small, needs to be at least 1744M 2.问题分析 sga_max_size 就是指定Oracle最大能够使用的内存,是个静态参数。
Oracle启动时，如果SGA各个组件的内存大小之和大于sga_max_size，则sga_max_size会设置为SGA各组件的大小之和。
错误提示中显示设置的之不能小于 1744M，这个需要修改pfile文件
3.解决方案1，推荐 1、首先登录sqlplus客户端，生成pfile文件
$ sqlplus / as sysdba SQL&gt; create pfile from spfile; 会在$ORACLE_HOME/dbs下生成一个pfile文件。
2、修改生成的pfie文件
我修改为1755MB大小，找一个在线字节转换器转换为1840250880
cd "/u01/app/oracle/product/11.2.0/db/dbs" [root@hrbqcdatanew:/u01/app/oracle/product/11.2.0/db/dbs]$ ls -l total 32 ... -rw-r--r-- 1 oracle oinstall 2071 Jul 25 17:48 inittopicisnew.ora ... [root@hrbqcdatanew:/u01/app/oracle/product/11.2.0/db/dbs]$ vi inittopicisnew.ora ... *.sga_target=1840250880 ... 3、然后启动
$ sqlplus / as sysdba SQL&gt; startup pfile='/u01/app/oracle/product/11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/721883ea185b5644a60350a42d990c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2255a59a5a4822fb0b41adfb9508a5b6/" rel="bookmark">
			【Vue甜点】vue使用缓存机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、cookie 1、安装vue-cookies npm install vue-cookies --save 2、 引入 打开项目的main.js文件
// ==== cookie缓存 ==== import VueCookies from 'vue-cookies' const app = createApp(App) app.use(VueCookies) 3、设置cookie 使用set(key, value, age)添加cookis。其中：
【key】为缓存的键名
【value】为缓存的具体值
【age】为缓存的有效期，单位秒
this.$cookies.set('cookie', '一个测试', 60*5); 4、获取cookie值 this.$cookies.get('cookie'); 5、删除cookie this.$cookies.remove('cookie'); 6、判断cookie是否存在 若存在返回true，反之则返回false
this.$cookies.isKey('token'); 7、获取cookie的所有key 以数组形式返回所有的cookie键名
this.$cookies.keys() 8、设置cookie过期时间 有效期可用字符串
Unitfull nameyyearmmonthddayhhourminminutessecond 大小写不敏感
默认为秒
8.1、设置全局有效期 // 10天后过期 this.$cookies.config('10d') // 设置截至有效日期 this.$cookies.config(new Date(2019,03,13).toUTCString()) // 默认设置秒数过期时间 this.$cookies.config(60 * 60 * 24 * 30,''); 8.2、对单独cookie设置有效期 //不写age，默认为1天过期 this.$cookies.set("cookie1","默认有效期") // 以秒为单位，设置1天过去 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2255a59a5a4822fb0b41adfb9508a5b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96a16ab4f3f248366f8186eb6f79a88e/" rel="bookmark">
			Django3框架-（2）-[使用websocket]：使用channels实现websocket，配置和项目实际使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本配置 依赖包：
Django==3.2 django-cors-headers==3.5.0 redis==4.6.0 #操作redis数据库的 channels==3.0.0 #websocket channels-redis==4.1.0 #通道层需要，依赖redis包 项目目录结构：
study_websocket
--study_websocket
--__init__.py
--settings.py
--asgi.py
--wsgi.py
--urls.py
--chat
--routings.py
--consumers.py
--update.py
--urls.py
--views.py
1.1、settings.py配置 1、注册跨域、channels、chat应用
INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'corsheaders', #前后端跨域 'chat.apps.ChatConfig',#注册chat应用，将所有websocket相关都放到这里 'channels', #django通过其实现websocket ] 2、跨域配置
##### cors资源跨域共享配置 CORS_ORIGIN_ALLOW_ALL = True CORS_ALLOW_METHODS = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'VIEW', ) CORS_ALLOW_HEADERS = ( 'XMLHttpRequest', 'X_FILENAME', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with', 'Pragma', 'token' #请求头允许自定义的字符串 ) 3、channels需要的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96a16ab4f3f248366f8186eb6f79a88e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cedf5e6b394fa74b157a14863e8511a/" rel="bookmark">
			HI_NAS linux 记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dev/root 100% 占用解决记录 通过下面的命令查看各文件夹 大小
sudo du --max-depth=1 -h # 统计当前文件夹下各个文件夹的大小显示为M 最终发现Var/log 占用很大空间
发现下面两个 log 占用空间很大，直接 rm-rf 即可
HI NAS python3 记录 # 安装pip3 sudo apt update sudo apt install python3-pip pip3 --version whereis python3 python3 -version pip install *.whl 开机自动挂载硬盘 https://www.cnblogs.com/fieldtianye/p/9295986.html
sudo blkid mount命令重启后会失效，将分区信息写入 /etc/fstab 文件启动自动挂载： sudo vim /etc/fstab 在文件内插入下面代码 UUID=6ec1ccd7-38da-412b-a65e-4c136666e292 /home ext4 defaults 0 1 sudo mount -a 标记的是要开机挂载的 内存卡 开机自动运行程序 Linux中没有rc.local文件的解决方法_linux 没有rc.local_七天啊的博客-CSDN博客
上面的方式有时候不管用
自己写一个shell脚本 将写好的脚本（.sh文件）放到目录 /etc/profile.d/ 下，系统启动后就会自动执行该目录下的所有shell脚本。 查看当前系统中的端口使用情况 # 查看TCP UDP Listen 显示所有已打开的端口 sudo netstat -tuln #查看TCP Listen sudo netstat -tln #查看UDP Listen sudo netstat -uln 查看运行的服务 // 查看所有服务 $ sudo systemctl list-units --type=service nginx配置 nginx 用来将端口 绑定到指定地址(或者页面，比如说我通过ip+8080 默认访问nginx默认页， 在server 中编辑了location，在location 使用了代理，那么最终ip+8080 访问的就是你代理的地址) server { listen 8080 default_server; listen [::]:8080 default_server; server_name localhost; location / { #proxy_pass http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cedf5e6b394fa74b157a14863e8511a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ede4532f14f0a9c8b07b82fcc5d9290/" rel="bookmark">
			java获取shp文件坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.geotools&lt;/groupId&gt; &lt;artifactId&gt;gt-referencing&lt;/artifactId&gt; &lt;version&gt;24.0&lt;/version&gt; &lt;/dependency&gt; 2，单元测试 import org.geotools.data.shapefile.ShapefileDataStore; import org.geotools.data.shapefile.ShapefileDataStoreFactory; import org.geotools.referencing.CRS; import org.junit.Test; import org.opengis.referencing.FactoryException; import org.opengis.referencing.crs.CoordinateReferenceSystem; import java.io.File; import java.io.IOException; import java.net.MalformedURLException; import java.nio.charset.Charset; public class ShpUtils { /** * 获取Shape文件的坐标系信息。 * * @param shpFilePath shp文件路径 * @return 坐标系的WKT形式 */ public static Integer getCoordinateSystemWKT(String shpFilePath) throws FactoryException { ShapefileDataStore dataStore = buildDataStore(shpFilePath); try { CoordinateReferenceSystem srs = dataStore.getSchema().getCoordinateReferenceSystem(); System.out.println(srs.toWKT()); Integer epsg = CRS.lookupEpsgCode(srs, true); return epsg; } catch (UnsupportedOperationException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ede4532f14f0a9c8b07b82fcc5d9290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04a7d220654b103a072925d00084b992/" rel="bookmark">
			Vscode GDB 查看内存的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VSCode的GDB图形界面中，你可以使用"调试控制台(Debug Console)"来查看malloc返回的地址里的值。以下是具体的步骤：
首先，你需要在你的代码中设置一个断点，这个断点应该在malloc函数调用之后，这样你可以获取到malloc返回的地址。然后，开始调试你的程序，当程序运行到你设置的断点时，它会暂停。此时，打开"调试控制台(Debug Console)"，你可以在这里输入GDB命令。假设malloc返回的地址存储在变量ptr中，你可以使用以下GDB命令来查看这个地址里的值： -exec x/1xb ptr 这个命令会显示从地址ptr开始的一个字节的值，并以16进制的形式显示。
请注意，你需要根据你想查看的内存的类型和长度，来调整x命令的参数。例如，如果你想查看一个整数，你可能需要使用x/1dw来查看4个字节，并以十进制的形式显示。
malloc_usable_size函数是一个在Linux系统中的库函数，它返回一个指向由malloc或相关函数分配的内存块的指针所指向的可用字节数。这个函数的主要用途是用于调试和自省。
关于malloc后的值都是0xbe的问题，这可能是因为在你的系统中，malloc函数在分配内存时，会将新分配的内存初始化为0xbe。这是一种常见的调试技术，用于帮助开发者识别未初始化的内存。这样，如果你在程序中看到0xbe，那么你就知道这块内存是由malloc分配的，但还没有被初始化。请注意，这种行为可能因系统和malloc的实现而异，不是所有系统或malloc的实现都会这样做。在一些系统或malloc的实现中，malloc可能会将新分配的内存初始化为其他值，或者根本不进行初始化。
在 GDB 中，-exec 是一个用于执行 GDB 命令的前缀。例如，如果你想在 GDB 中运行 continue 命令，你可以在 GDB 终端中输入 -exec continue。这将会继续执行你正在调试的程序，直到遇到下一个断点或程序结束。这种方式在你通过其他工具（如 IDE）使用 GDB 时特别有用，因为这些工具可能需要以一种结构化的方式来获取 GDB 的输出。请注意，-exec 前缀并不总是必需的，特别是当你直接在终端中使用 GDB 时。在这种情况下，你可以直接输入 continue 或其他 GDB 命令。
在 GDB 中，-exec 前缀主要在以下情况下使用：
通过其他工具使用 GDB：当你通过其他工具（如 IDE）使用 GDB 时，这些工具可能需要以一种结构化的方式来获取 GDB 的输出。在这种情况下，你可能需要使用 -exec 前缀来执行 GDB 命令。使用 MI（Machine Interface）模式：GDB 提供了一种名为 MI 的接口，它是为了让其他程序（如前端界面或 IDE）能够更好地与 GDB 交互而设计的。在 MI 模式下，你需要使用 -exec 前缀来执行 GDB 命令。 当你直接在终端中使用 GDB 时，通常不需要使用 -exec 前缀。你可以直接输入 continue 或其他 GDB 命令来执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04a7d220654b103a072925d00084b992/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d293a06ecc3020e24733d748df2080e/" rel="bookmark">
			华为防火墙——通过IPv4 PPPoE接入互联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、认识PPPoE：
PPPoE提供了在以太网上建立PPPoE会话以及封装PPP数据包的方法。PPPoE要求在通信双方之间建立的是点到点关系，而不是在以太网和其他多路访问环境中所出现的多点关系。它利用以太网将多个主机组成网络，通过一个远端接入设备接入因特网，并对接入的每个主机实现控制、计费功能。极高的性价比使PPPoE被广泛应用于包括小区组网等一系列应用中。
二、PPPoE的目的：
当多个用户同时通过接入服务器获取服务时：
用户希望接入成本低，不要或者很少改变配置即可接入成功。以太网无疑是最好的组网方式。
服务提供商希望通过同一个接入服务器连接到远程站点上的多个主机，同时要求服务器能提供与使用PPP拨号上网类似的访问控制功能和支付功能。
PPP（Point-to-Point）应用虽然很广泛，但是不能应用于以太网，因此提出了PPPoE技术。PPPoE是对PPP的扩展，它可以使PPP协议应用于以太网。
PPPoE提供通过简单桥接的接入服务器把一个网络的多个主机连接到远程接入服务器的功能。
三、PPPoE的原理：
PPPoE协议采用客户端-服务器（Client/Server）方式，它将PPP报文封装在以太网帧之内，在以太网上提供点对点的连接。
以IPv4 PPPoE为例，PPPoE建立连接的过程如图1所示。
Discovery阶段 当主机开始通过PPPoE接入服务器时，它必须先识别接入端的以太网MAC地址，建立PPPoE的Session_ID。这就是Discovery阶段的目的。
Discovery阶段由四个过程组成。完成之后通信双方都会知道PPPoE的Session_ID以及对方以太网地址，它们共同确定了唯一的PPPoE会话。
Discovery阶段的四个过程如下：
主机在本以太网内广播一个PADI（PPPoE Active Discovery Initial）报文，在此报文中包含主机想要得到的服务类型信息。
以太网内的服务器收到这个PADI报文后，将其中请求的服务与自己能提供的服务进行比较，可以提供此服务的服务器发回PADO（PPPoE Active Discovery Offer）报文。
主机收到服务器的PADO报文，向它发回一个会话请求报文PADR（PPPoE Active Discovery Request）。
服务器产生一个唯一的会话标识，标识和主机的这段PPPoE会话。并把此会话标识通过会话确认报文PADS（PPPoE Active Discovery Session-confirmation）发回给主机，如果没有错误，双方进入PPPoE Session阶段。
接入服务器发送确认数据包后，它就可以进入到PPPoE会话阶段。当主机接收到该确认数据包后，它就可以进入PPPoE会话阶段。
Session阶段 当PPPoE进入Session阶段后，PPP报文就可以作为PPPoE帧的净荷封装在以太网帧发送到对端，Session_ID必须是Discovery阶段确定的ID，MAC地址必须是对端的MAC地址，PPP报文从Protocol ID开始。这时所有的以太网数据包都是单播的。
在Session阶段，主机或服务器任何一方都可以发送PADT（PPPoE Active Discovery Terminate）报文通知对方结束本Session。
注意事项：
如果在PPPoE的服务器端配置service-name，client将发送Discovery阶段的PADI报文给服务器端请求建立连接。如果该PADI报文中包含有不为空的service-name时，服务器端将用配置的service-name和该报文中的service-name进行完全匹配性检测。如果两者完全相同，服务器端提供后续服务，否则，服务器端不提供服务。以上是两者的service-name都不为空时的情况。但如果两者中有一个service-name为空，就不进行此项检测。 四、实验: 4.1 实验拓扑：
4.2 实验配置：
配置接口GigabitEthernet 1/0/3的IP地址。 &lt;FW&gt; system-view [FW] interface GigabitEthernet 1/0/3 [FW-GigabitEthernet1/0/3] ip address 10.3.0.1 255.255.255.0 [FW-GigabitEthernet1/0/3] quit 将各个接口加入对应安全区域。 [FW] firewall zone untrust [FW-zone-untrust] add interface GigabitEthernet 1/0/1 [FW-zone-untrust] quit [FW] firewall zone trust [FW-zone-trust] add interface GigabitEthernet 1/0/3 [FW-zone-trust] quit 配置设备作为DHCP Server，为局域网内部PC分配IP地址。 # 开启DHCP功能。 [FW] dhcp enable # 创建接口地址池，为内网PC配置网关地址并指定DNS Server。 [FW] interface GigabitEthernet 1/0/3 [FW-GigabitEthernet1/0/3] dhcp select interface [FW-GigabitEthernet1/0/3] dhcp server ip-range 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d293a06ecc3020e24733d748df2080e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05acbf29f0ea295ba4afa6704e79a610/" rel="bookmark">
			requests 307 临时重定向响应下的 Cookie 丢失问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在处理HTTP请求时，出现了一个问题，即当用户发起一个请求时，服务器返回一个307临时重定向响应和一个cookie。然而，当用户重复这个请求时，发现cookie并没有被正确添加。为了更好地理解这个问题，我们可以通过添加请求日志来进行调试。 解决方案: 问题出现在对重定向的处理上。根据HTTP/1.1规范，307临时重定向状态码明确指出，客户端应当使用GET方法进行重定向，并且重定向后的URL不能包含任何查询参数。这个规范要求对于重定向的处理有一定的严格性，但有时浏览器或网络库可能无法正确处理重定向，从而导致cookie丢失。 为了解决这个问题，我们可以考虑以下几种方法： 1. 修改请求方法为POST: 一种解决方案是将原始请求的方法从GET修改为POST。这样做可以确保在重定向后，请求的方法仍然是POST，不会违反HTTP规范。但需要注意，这可能会影响到用户体验，因为请求的语义会发生改变，而不仅仅是解决cookie丢失的问题。 2. 将查询参数添加到URL中: 另一种解决方案是将查询参数添加到重定向后的URL中。虽然HTTP规范要求重定向后的URL不包含查询参数，但有些服务器可能会容忍这样的行为。这个方法可以确保重定向后的请求依然是GET请求，但需要确认服务器是否支持这种行为。 3. 服务器端处理逻辑: 如果以上两种方法都不适用，可以考虑在服务器端添加额外的处理逻辑，来确保cookie的正确传递。这可能需要定制化的解决方案，根据具体的应用和服务器来实现。 总结: 在处理307临时重定向响应时，需要注意客户端应当使用GET方法，且重定向后的URL不能包含任何查询参数，以符合HTTP规范。如果需要使用GET方法，可以考虑上述解决方案中的一种或结合多种方法来确保cookie的正确传递。解决这个问题需要根据具体情况来决定最合适的方法，以保证用户体验和符合标准的HTTP请求。希望这些解决方案能够帮助您解决cookie丢失的问题。如果您有任何进一步的问题或需要更详细的指导，请随时提出。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcf724b766b1810604b86910b9ff005d/" rel="bookmark">
			（五）Redis集群（主从复制、哨兵模式、集群）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、主从复制（一）、互联网“三高”架构1、你的“Redis”是否高可用2、多台服务器连接方案 （二）、主从复制简介1、简介2、高可用集群3、主从复制的作用 二、主从复制工作流程（一）、总述（主从复制过程的3个阶段）1、阶段一：建立连接阶段1.1 建立连接阶段工作流程1.2 搭建主从结构1.2.1 主从连接（slave连接master）1.2.2 主从断开连接 1.3 授权访问 2、阶段二：数据同步阶段工作流程2.1 数据同步阶段master说明2.2 数据同步阶段slave说明 3、 阶段三：命令传播阶段3.1命令传播阶段可能出现的问题3.1.1 服务器运行ID（runid）3.1.2 复制缓冲区3.1.3 复制缓冲区内部工作原理3.1.4 复制缓冲区总结3.1.5主从服务器复制偏移量（offset）3.1.6数据同步+命令传播阶段工作流程3.1.7 心跳机制3.1.8 心跳阶段注意事项3.1.9 主从复制工作流程（完整） 三、主从复制常见问题（一）频繁的全量复制（1）（二） 频繁的全量复制（2）（三）频繁的网络中断（1）（四）频繁的网络中断（2）（五）数据不一致 四、哨兵模式（一）哨兵简介主机“宕机”哨兵概念哨兵的作用 （二）启用哨兵模式1、配置哨兵 （三）哨兵工作原理1、哨兵在进行主从切换过程中经历三个阶段阶段一：监控阶段具体的工作顺序 阶段二：通知阶段阶段三：故障转移阶段主从切换的整个过程 五、集群（一）集群简介1、现状问题2、集群架构3、集群作用 （二）Redis集群结构设计1、数据存储设计2、集群内部通讯设计 （三）cluster集群结构搭建1、搭建方式2、Cluster配置（redis-xxxx.conf文件）3、Cluster节点操作命令4、redis-trib命令 一、主从复制 （一）、互联网“三高”架构  高并发：必须支持大量的用户同时访问
 高性能：性能比较高，速度比较快
 高可用：全年时间减去服务器宕机时间除以全年时间*100%
1、你的“Redis”是否高可用 单机redis的风险与问题
 问题1.机器故障
 现象：硬盘故障、系统崩溃
 本质：数据丢失，很可能对业务造成灾难性打击
 结论：基本上会放弃使用redis.
 问题2.容量瓶颈
 现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存
 本质：穷，硬件条件跟不上
 结论：放弃使用redis
 结论：
为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。
2、多台服务器连接方案 提供数据方：master
主服务器，主节点，主库
主客户端
接收数据方：slave
从服务器，从节点，从库
从客户端
需要解决的问题：
数据同步
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcf724b766b1810604b86910b9ff005d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384ffbeb8e12fc9a12b6eb91d4cae2fc/" rel="bookmark">
			Oauth2认证及Spring Security Oauth2授权码模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oauth2认证 Oauth2简介 简介
第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间要遵循一定的接口协议。
OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。
Oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。
参考：https://baike.baidu.com/item/oAuth/7153134?fr=aladdin
Oauth 协议：https://tools.ietf.org/html/rfc6749
下边分析一个Oauth2认证的例子，网站使用微信认证的过程：
用户进入网站的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。
点击“微信”出现一个二维码，此时用户扫描二维码，开始给网站授权。
资源拥有者同意给客户端授权
资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权网站访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到网站。
客户端获取到授权码，请求认证服务器申请令牌
此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。
认证服务器向客户端响应令牌
认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在网站看到已经登录成功。
客户端请求资源服务器的资源
客户端携带令牌访问资源服务器的资源。网站携带令牌请求访问微信服务器获取用户的基本信息。
资源服务器返回受保护资源
资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。
注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。
Oauth2.0认证流程如下：
引自Oauth2.0协议rfc6749 https://tools.ietf.org/html/rfc6749
角色 客户端
本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。
资源拥有者
通常为用户，也可以是应用程序，即该资源的拥有者。
授权服务器（也称认证服务器）
用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。
资源服务器
存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相册信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。
常用术语
客户凭证(client Credentials)：客户端的clientId和密码用于认证客户令牌(tokens)：授权服务器在接收到客户请求后，颁发的访问令牌作用域(scopes)：客户请求访问令牌时，由资源拥有者额外指定的细分权限(permission) 令牌类型
授权码：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌访问令牌：用于代表一个用户或服务直接去访问受保护的资源刷新令牌：用于去授权服务器获取一个刷新访问令牌BearerToken：不管谁拿到Token都可以访问资源，类似现金Proof of Possession(PoP) Token：可以校验client是否对Token有明确的拥有权 特点
优点：
更安全，客户端不接触用户密码，服务器端更易集中保护 广泛传播并被持续采用 短寿命和封装的token 资源服务器和授权服务器解耦 集中式授权，简化客户端 HTTP/JSON友好，易于请求和传递token 考虑多种客户端架构场景 客户可以具有不同的信任级别 缺点：
协议框架太宽泛，造成各种实现的兼容性和互操作性差 不是一个认证协议，本身并不能告诉你任何用户信息。 Spring Security Oauth2授权码模式 创建项目导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/384ffbeb8e12fc9a12b6eb91d4cae2fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da847a948789c7e4566516828023076/" rel="bookmark">
			linux CentOS7 安装git 配置秘钥公钥克隆代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：安装git
yum -y install git #查看版本
git --version
第二步：配置git信息
git config --global user.name "username"
git config --global user.email "XXX@XX.com"
第三步：生成密钥和公钥， 后续只需要按回车即可
ssh-keygen -t rsa -C "XXX@XX.com"
第四步：根据上图提示，切换到生成密钥目录
cd /root/.ssh/
第五步：查看公钥内容，配置到码云、gitlab或github等
cat ~/.ssh/id_rsa.pub 第六步：克隆远程代码到本地
git clone git@xxxxxxxxx:xxx.git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4f5bc5b3cb088567223836126235f4/" rel="bookmark">
			（超详细）Python柱状图的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.通过Bar来构建基础柱状图：（如以下代码）
from pyecharts.charts import Bar from pyecharts.options import * # 构建柱状图对象 bar = Bar() # 添加x轴数据 bar.add_xaxis(["中国", "美国", "英国"]) # 添加y轴数据 bar.add_yaxis(["GDP",[30, 20, 10]]) # 绘图 bar.render("基础柱状图.html") 运行结果：
从以上代码中可得出要构建一个基础的柱状图首先要导入pyecharts中的bar模块，接着是构建柱状图的对象，然后再分别给x和y轴添加上数据，最后再绘图即可。使用bar.reversal_axis()就可以实现x和y轴的反转了，因为我们这个柱状图不是从下往上去看的，而是从左往右去看的。然后反转之后可以通过使用labelOpts模块去把数据（10，20，30）放到最右边。
2.基础的时间配置动态图表：
（1）Time line()-时间线：时间线就是创建一个x轴，轴上每一个点就是一个图表对象。如下面的图所示：
它是由点1变动到点2的，并以此来实现动态的图表。
from pyecharts.charts import Bar, Timeline from pyecharts.options import LabelOpts # 构建柱状图对象 bar1 = Bar() # 添加x轴数据 bar1.add_xaxis(["中国", "美国", "英国"]) # 添加y轴数据 bar1.add_yaxis("GDP", [10, 20, 10], label_opts=LabelOpts(position="right")) # 反转x和y的轴 bar1.reversal_axis() bar2 = Bar() bar2.add_xaxis(["中国", "美国", "英国"]) bar2.add_yaxis("GDP", [30, 20, 10], label_opts=LabelOpts(position="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4f5bc5b3cb088567223836126235f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ded9aad03db4204f89edb1becfcb6e7d/" rel="bookmark">
			Cocos Creator游戏开发基础入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Cocos Creator游戏开发中，有几个非常重要的基础知识大家必须掌握，就是场景、场景树、节点Node、组件Component。
一、 什么是场景和场景树
一个游戏中可以有多个场景（例如登录场景、修改密码场景、游戏主场景等等），在游戏中通过代码逻辑来控制场景跳转。几乎所有的场景的根节点都是Canvas节点，Canvas节点上面可以挂载各种各样的组件，例如cc.Canvas组件，用于设计游戏的设计分辨率和适配策略。
根节点下面又可以有多个子节点，子节点下面又可以挂载子节点，如上图所示，如此，构成的树形结构我们称之为场景树。每个节点上面都可以挂载各种各样的组件。cocos creator学习交流小组
cc.Node就是场景树中的节点对象。每个节点只要在场景里面，所以任何一个节点都是一个cc.Node。
二、 cc.Node常用属性及方法
1. 常用属性
1: name: 获取节点的名字
2: active: 设置节点的可见性;
3: position: 相对坐标，参照物是父亲节点;
4: rotation: 旋转，顺时针为正, 数学逆时针为正;
5: scale: 缩放;
6: anchor: 锚点, 左下角(0, 0), 右上角(1, 1) 可以超过这个范围
7: Size: 大小
8: Color: 环境颜色;
9: Opacity: 透明度；
10: Skew: 扭曲;
11: Group: 分组;
12: parent: 父亲节点的cc.Node;
13: children/childrenCount: 孩子节点的数组;
14: tag : 节点标签;
2. 常用方法及操作
1: 代码中创建一个节点new cc.Node();
然后调用addChild; 加一个子节点
2: removeFromParent/ removeAllChildren;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ded9aad03db4204f89edb1becfcb6e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a80e27edf2ccc2ec7a7c3e3d4a2dca5/" rel="bookmark">
			Git——分布式版本控制工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 1.开发中的实际场景 备份代码还原协同开发追溯问题代码的编写人和编写时间 2.版本控制器的方式 集中式版本控制工具
集中式版本控制工具，版本库是集中存放在中央服务器的，team里每个人work时从中央服务器下载代码，是必须联网才能工作，局域网或互联网。个人修改后然后提交到中央版本库。
举例：SVN和CVS分布式版本控制工具
分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候，无需要联网了，因为版本库就在你自己的电脑上。多人协作只需要各自的修改推送给对方，就能互相看到对方的修改了。
举例：Git 3.SVN 4.Git Git是分布式的,Git不需要有中心服务器，我们每台电脑拥有的东西都是一样的。我们使用Git并且有个中心服务器，仅仅是为了方便交换大家的修改，但是这个服务器的地位和我们每个人的PC是一样的。我们可以把它当做一个开发者的pc就可以就是为了大家代码容易交流不关机用的。没有它大家一样可以工作，只不过"交换"修改不方便而已。
git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git是LinusTorva1ds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。
同生活中的许多伟大事物一样，Git诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者。绝大多数的Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002年间）。到 2002年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper来管理和维护代码。
到了2005年，开发 BitKeeper的商业公司同 Linux内核开源社区的合作关系结束，他们收回了Linux内核社区免费使用BitKeeper的权力。这就迫使Linux开源社区（特别是Linux 的缔造者Linus Torva7ds）基于使用BitKeeper 时的经验教训，开发出自己的版本系统。他们对新的系统制订了若干目标:
速度简单的设计对非线性开发模式的强力支持（允许成千上万个并行开发的分支&gt;完全分布式有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量) 5.Git工作流程图 命令如下：
clone（克隆）：从远程仓库中克隆代码到本地仓库checkout（检出）：从本地仓库中检出一个仓库分支然后进行修订add（添加）：在提交前先将代码提交到暂存区commit（提交）：提交到本地仓库。本地仓库中保存修改的各个历史版本fetch （抓取）：从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。pull（拉取）：从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+mergepush（推送）：修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库 二、Git安装与常用命令 可能会用到一些基本的linux命令，在此为大家提前列举：
ls/ll 查看当前目录cat 查看文件内容touch 创建文件vi vi编辑器（使用vi编辑器是为了方便展示效果，也可以使用记事本、editPlus、notPad++等其它编辑器） 1.下载与安装 下载地址：https://git-scm.com/
下载完成后可以得到如下安装文件：
双击下载的安装文件来安装Git。全部默认，安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看到如下两个菜单则说明Git安装成功。
备注:
TGit Gul：Git提供的图形界面工具Git Bash：Git提供的命令行工具 当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息
2.基本配置 打开Git Bash设置用户信息 git config --global user.name "你自己的名字" git config --global user.email "随便写个邮箱" 查看配置信息
git config --global user.name git config --global user.email 3.为常用指令配置别名(可选) 有些常用的指令参数非常多，每次都要输入好多参数，我们可以使用别名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a80e27edf2ccc2ec7a7c3e3d4a2dca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf3c02ade9c0711704e222de9d0e602/" rel="bookmark">
			生成rdma-core deb文件在ubuntu22.04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apt install python-docutils -y
apt install libsystemd-dev
apt install pandoc -y
apt-get install build-essential cmake gcc libudev-dev libnl-3-dev libnl-route-3-dev ninja-build pkg-config valgrind python3-dev cython3
apt install dh-python
wget https://github.com/linux-rdma/rdma-core/releases/download/v27.0/rdma-core-27.0.tar.gz
# Apply patch libirdma-27.0.patch to rdma-core
cd $CUR &amp;&amp; tar -xzvf rdma-core-27.0.tar.gz
cd $CUR/rdma-core-27.0 &amp;&amp; patch -p2 &lt; $CUR/libirdma-27.0.patch
# Build rdma-core
cd $CUR/rdma-core-27.0 &amp;&amp; dh clean --with python3,systemd --builddirectory=build-deb
cd $CUR/rdma-core-27.0 &amp;&amp; dh build --with systemd --builddirectory=build-deb
cd $CUR/rdma-core-27.0 &amp;&amp; dh binary --with python3,systemd --builddirectory=build-deb
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf3c02ade9c0711704e222de9d0e602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c87bdfb7c28af83fd352ff9fc60678e/" rel="bookmark">
			uniapp写微信小程序程序太大需要分包怎么实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言，我写小程序越写越大最后提示不能超过2M好烦我就研究怎么分包，其实分简单直接上干货
1、在原来的pages的同级下新建一个目录：package1 （名字自己随便起。想分几个包就建几个新目录。比如package2、package3……）
结构是并列的：
2、把想要放进分包里去的模块都剪切在新目录里面去。 （就是以前全都放在pages里面的模块。现在把次要的模块剪切到新目录里去。我这里还建了一个pages目录。也可以不建这个目录。而且里面的结构也可以多层次。结构变了，访问的路径也要变。自己要考虑好。）
3、 修改manifest.json文件。 增加一个参数
"optimization": { "subPackages": true } 4、修改pages.json文件 然后把刚复制的那些粘贴到package1的pages里面
（分包的参数结构也和原来的pages里面是一样的。）
5.这样就分包成功了，你如果想访问分包的页面其实和平时写的一样举个例子
uni.navigateTo({ url: '/package1/pages/workForm/index' }) 6,最后就是上传代码就ok
大家如果有啥不懂的或者有问题的，可以随时扣我，或者留言。如果又帮助就点个红心感谢各位大佬！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15767b24a5aa92380db4a2a3f817669b/" rel="bookmark">
			泸州血战麻将结算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是个人玩了一段时间得出的结论，可能会有很多错误的地方
不过我还是那句话：规则是公平的，某个牌型别人计多计少，你胡到也是这么多 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/941d574ce80af98c48ef80a65e642ca3/" rel="bookmark">
			RESTful API 设计指南——为什么要用（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在上一篇中：RESTful API 设计指南——开篇词
我们介绍了几个十分有争议的案例：
所有的接口都使用Post请求不管成功还是失败，HTTP状态码都返回200API命名千奇百怪 本章我们来深入分析一下，为什么不要像案例中所说的那样干？
RESTful 规范能解决这些问题吗？
问题浅析 为什么不要所有的接口都使用POST 我们首先来看一下 GET 和 POST 的区别（来源文章）：
GET 请求有长度限制（数据放在URL中），而 POST 没有GET 数据都放在 url 中，复制到浏览器可以直接打开（各种分享功能），而 POST 数据放在 body 中，无法分享GET 可以被缓存（CDN），能减少服务器压力，而 POST 请求永远不会被缓存GET 请求会被保存到浏览历史记录中，POST 不可以GET 请求可以使用回退/刷新功能，而 POST 通常不可以GET 请求可以被保存为书签，POST 不行GET 请求不应该包含有敏感数据，因为它可以在地址栏、书签和浏览历史中看到GET 请求仅用于查询数据，而不是修改 通过上面的对比，我们看到 GET 和 POST 都有各自的使用场景，假设你要做一个分享功能，或者一个博客，那么可以被添加为书签或者能直接在浏览器地址粘贴打开是必须的，否则将会丢失很多从收藏夹过来的阅读量。
所以，在早期的 MVC 时代（前后端在一起），肯定不能所有的请求都是 POST，否则有一些功能将会无法实现。
那么在当下前后端分离的时代呢？后端接口通常是提供给前端使用的，用户不会直接接触到这些后端接口，可以都使用 POST 请求吗？
在前后端分离架构下，团队分工发生了变化：由 Java 干所有事情，变成了前端开发 + 后端开发的组合，这意味分工的精细化，前端除了功能实现，还会关注界面美观和用户体验；后端会关注性能、并发和可用性等一些非功能需求。从这个角度而言 GET 能使用 CDN 缓存，限制 GET 只用来查询，POST用来修改，从而可以通过读写分离机制提升整体服务的性能和可用性就很关键了。
所以，在前后端分离和微服务架构的时代的今天，功能只是整个后端开发中的一部分，有时甚至非功能需求的工作量远远大于功能性需求，所以，不太可能出现所有接口都使用 POST 请求这种情况。
另外，伴随着云计算时代的到来， K8S 和 Docker 容器化部署几乎成为了后端的必备技能之一，而 K8S 其中的一个机制：健康检查就要求服务提供一个 HTTP GET 接口，返回200 OK 代表服务已准备就绪，K8S 才会开放流量给该进程。所以，也不可能只提供 POST 接口的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/941d574ce80af98c48ef80a65e642ca3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8777fb9d986a1f737f5ccfab59bc53cc/" rel="bookmark">
			洛谷函数与结构体入门级刷题笔记【自用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：自用刷题笔记记录，洛谷函数与结构体题单入门级刷题
文章目录 1.距离函数2.质数筛3.闰年展示4.歌唱比赛5. 计算阶乘6.赦免战俘7.最厉害的学生8.旗鼓相关的对手，加强版9.评等级10.质因数分解11.哥德巴赫猜想12.回文质数13.集合求和 结束语 1.距离函数 #include&lt;math.h&gt; double dis(double x1,doubley1,double x2,double y2){ return sqrt((x2-x1)*(x2-x1)-(y2-y1)*(y2-y1)); } 2.质数筛 去掉输入的数组中不是质数的数，然后输出剩下的质数
int prim(int num){ if(num&lt;=1)return -1; int i; for(i=2;i*i&lt;=num;i++){ if(num%i==0)return -1; } return 1;} 3.闰年展示 输入区间的开始和结束，输出这个区间有多少个闰年个数，并分别输出闰年
int judge(int num){ if((num%4==0&amp;&amp;num%100!=0)||num%400==0)return 1; return -1; } 4.歌唱比赛 每个同学得分是评委去掉最高分最低分后的平均分，输出得分最高的同学分数
ps：可以一边输入一边就进行平均分的计算、最高分的记录
double judge(double a[],int num){//计算去掉最高分最低分的平均分 double max=-1,min=999; double sum=0; int i; for(i=0;i&lt;num;i++){ if(max&lt;a[i])max=a[i]; if(min&gt;a[i])min=a[i]; sum+=a[i]; } sum-=max; sum-=min; return sum/(double)(num-2); } int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; double a[m]={0}; int i,j; double max=-1; for(i=0;i&lt;n;i++){//几个人 for(j=0;j&lt;m;j++){//评分 cin&gt;&gt;a[j]; } if(max&lt;judge(a,m))max=judge(a,m);//直接记录最高分 } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8777fb9d986a1f737f5ccfab59bc53cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87bddd8e1c4ce287138a7cc97b205419/" rel="bookmark">
			RESTful API 设计指南——开篇词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 十年后的今天，我终于学会了RESTful API。
以上，就是我最近一个月的心路历程。入职新公司不到2周，自己都还没完全理解RESTful API就要求给校招应届生培训，着实压力山大。培训结束后也感觉收获颇丰，遂总结分享出来，希望对你有所帮助。
网上的文章比较零散，大多数讲 RESTful API 都是浅尝辄止，看完后我的印象只停留在 HTTP方法代表操作（如GET表示查询）、HTTP状态码代表结果（如200代表成功）等很浅的层面。
经过这些年的发展，特别是自 2015年 Swagger 规范更名为 Open API 后，一直到 OpenAPI 3.0.0 第一个正式版本的推出，陆陆续续类似 VS Code 和 PostMan 等工具开始涌现支持其语法的各种插件，到目前落地 RESTful API 变得越来越简单。
于是，我决定写一个系列文章，来记录和分享 RESTful API 设计的相关心得，也算是给自己一个交代：到现在才初步学会 RESTful API，这么些年，我都在干什么啊？
REST 和 Web 2000年，HTTP规范的主要作者之一，菲尔丁发表了博士论文《基于网络的软件体系结构风格与设计》，首次提出了名为“表现层状态转移”（REST）的互联网体系架构：
但是直到2008年，《RESTful Web Services》一书的推出，才系统性的讲述了如何设计REST式API风格：
在本书中，作者将其称之为面向资源的架构（Resources-Oriented-Architecture，简称ROA），这也是本书的最大亮点，补齐了我在 RESTful 理论知识方面的不足：
ROA（面向资源的架构） 和 OOP（面向对象编程）的思想有点类似（一切都是资源 vs 万物皆对象），主要强调如何利用 HTTP 应用层协议来操作这些资源，实现资源的增删改查。
不过到真正流行起来，成为 HTTP API 的事实上的标准风格规范，应该是从 Github 和 Google 开放的 API 使用 RESTful 风格开始（大概在2012年以后），才纷纷引得其他各大国内外互联网公司深入研究和使用。
但很奇怪的是，至今为止，我去看了 高德地图WebAPI、企业微信API 和 阿里云部分API，实际使用 RESTful 风格的互联网公司可能并没有那么多，这可能是为什么面试中很少会有面试官问 RESTful 和 API 设计的相关问题（可能他们也不懂）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87bddd8e1c4ce287138a7cc97b205419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2861792ce9844c1fa0a3a49605f71cac/" rel="bookmark">
			c语言---数据类型 · 浮点型（很全很基础 ＞O＜）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是浮点型嘞？
赋值和计算过程中的细节
float和double的区别
怎样才能想保留几位小数就保留几位小数？
什么是浮点型嘞？ c语言基本数据类型主要有整型、浮点型、字符型，而浮点型是基本数据类型之一，用于定义实数（小数）变量。主要有float（单精度浮点数）和double（双精度浮点数）两种。
float：
单精度浮点数，占4字节。
输出结果保留小数点后6位小数，多余的按照四舍五入去掉，若不满六位用0补齐。
格式说明（即占位符，由%和占位字符组成）：输出/入都是%f。
double：
双精度浮点数，8字节。
输出结果同样保留小数点后6位，多余的按照四舍五入去掉，若不满六位用0补齐。
格式说明（占位符）：输入为%lf，输出为%f。
赋值和计算过程中的细节 赋值时，如果给浮点型赋值整数，系统会自动为整数补上小数点（相反的，如果给整数型变量赋值了小数，系统会直接将小数舍去变为整数，注意这里是舍去而不是四舍五入）。
标识符：自定义的变量名不可以数字开头，不能是汉字，只能含数字、字母和下划线。（反面教材：float 5a；float 哈；）
运算细节 ①在有乘除的运算中，只要有一个数是浮点数，系统会自动把其他整数转换成浮点数。
②给浮点数赋值的时候，如果赋值号右边是计算式要注意了，要把右边的运算结果变成小数才行，举个栗子🌰
原理是酱紫的：大家都知道赋值从右往左进行，如果以a为例，在a赋值时先计算右边的10/3，除号左右都是整数，所以10/3的计算结果就是整数，3.333...的小数部分被舍去，结果为3，再把计算结果3赋值给a。但a又是浮点数呀，所以系统就把3变成了浮点数3.000000。
（当浮点数要被强制转换为整数时，小数部分直接被去掉而不是四舍五入；当浮点数的小数部分结果超出6位时，第七位被四舍五入）
float和double的区别 运行中输出浮点数时，float可以输出8位准确有效数字，double可以输出16位准确有效数字。
如果输出数字超出8/16位，超出的数字就会变得你不认识。给大家举个栗子🌰🌰
🌰上图第一组中，我给a赋值了十个1，输出结果中第9、10个1变得乱七八糟了
🌰上图第二组中，我给b赋值了18个1，输出结果第17、18个1变得跟原来不一样了
怎样才能想保留几位小数就保留几位小数？ 秘诀是输出占位符：%-m.nf
（这里还夹带了一点点别的知识点，不过是配套使用的，很好理解哦😜）
m代表整数部分，n代表小数部分位数，-可以让输出结果靠左侧对齐。让我们来分别具体探索一下它们各自的作用吧🌰🌰🌰
🌰如上图第一组变量a。m的作用：我们已经知道float保留8位精度，如果m&lt;=8，那输出结果就向左靠齐；如果m&gt;8,那么输出的数字前端会有m-8个空格。
🌰如上图第二组变量b。-的作用就是让输出数字向左靠齐啦
🌰如上图第三组变量c。n就是你想保留小数的位数，当然不可以超过6位哦
就酱，拜拜~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940a955e7806e1858df4deeb52c37647/" rel="bookmark">
			c&#43;&#43;计算日期到天数转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 打印日期描述c++代码如下：C语言代码如下： 打印日期 描述 给出年分m和一年中的第n天，算出第n天是几月几号。
输入描述：
输入包括两个整数y(1&lt;=y&lt;=3000)，n(1&lt;=n&lt;=366)。
输出描述：
可能有多组测试数据，对于每组数据， 按 yyyy-mm-dd的格式将输入中对应的日期打印出来。
c++代码如下： #include &lt;iostream&gt; using namespace std; int main() { int mouth[12] = {31,28,31,30,31,30,31,31,30,31,30,31}; int year,month,day; while(cin&gt;&gt;year&gt;&gt;month&gt;&gt;day) { int sum =0; for(int i=0;i&lt;month-1;i++) { sum+=mouth[i]; } if((year%400==0||(year%4==0&amp;&amp;year%100!=0))&amp;&amp;month&gt;2) sum+=1+day; else sum+=day; cout&lt;&lt;sum&lt;&lt;endl; } return 0; } C语言代码如下： #include &lt;stdio.h&gt; int is_trueyear(int year) { if (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0 ) { return 1; } return 0; } int main() { int month_day[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; int year, month, day; while (~scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/940a955e7806e1858df4deeb52c37647/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc15513067ec2eb8e84a2c276a0b48c8/" rel="bookmark">
			2023.9月更新大麦autojs代码，实现app端自动抢票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码中首先进行改造，基于autojs实现安卓端自动抢购，简单来说就是在代码中填写好场次、票价、观影人等信息后，停留在抢购页面，出现立即抢购按︾便会执行自动化点击，直到处于待付款状态才停止。
可以自动检测最新滑块，并滑动。
增加捡漏代码实现自动5捡漏抢回流票。密码:cm3rhttps://wwr.lanzouh.com/b04wh3i4j
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c6dea36a2a54bbc3c3627ef59e6e5d/" rel="bookmark">
			数电实验-----实现74LS153芯片扩展为8选1数据选择器以及应用（Quartus II ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、74LS153芯片介绍
管脚图
功能表
二、4选1选择器扩展为8选1选择器
1.扩展原理
2.电路图连接（Quartus II ）
3.仿真结果
三、8选1选择器的应用
1.三变量表决器
2.奇偶校验电路
一、74LS153芯片介绍 74ls153芯片是属于四选一选择器的芯片。
74LS153是双4选1数据选择器，有选择输入端B和A，能有四种状态，选中输入4个数据中的其中一个数据，选择输入中L，H分别代表为L为低电平，H为高电平。选通输入可称为使能端，选通输入为高电平时，输出端Y为L低电平，选通为低电平时，输出Y为选择的数据输出。
管脚图 1G、2G是表示控制开关
A,B是表示地址选择器
1C0~1C3和2C0~2C3是输出口
内部结构： 功能表 真值表：
S是控制开关，当S为高电平的时候，表示不工作，反之就正常工作，A1和A0是地址选择器，选择相对应的地址输出。
二、4选1选择器扩展为8选1选择器 1.扩展原理 8选1选择器真值表：
74ls153芯片有三个输入口，其中一个是选通开关S，其他两个是地址输出选择器A1 A0，这里我们就可以去通过这三个输入口作为8选1选择器的三个输入口。所以我们要用到两个4选1选择器来去实现8选1选择器的功能，通过两个4选1选择器交替工作实现输出的位选，我们让其中一个4选1选择器为高位选择器，另一个低位选择器，低位的选通开关取反接入到高位的开关，开关就作为A2。然后剩下的就是地址选择输出。下面看个示例：
比如，选通开关S、地址选择器A1、A0分别输入1 0 1，那么我们要输出就应该是高位的第2个，也就是输出D5即2D2这一条数据结果。那此时低位4选1选择器就不工作，所以输出的是0，也就只有高位的选择器在工作。
2.电路图连接（Quartus II ） 下面我们打开Quartus II，然后创建一个block文件，按照以下的图示连接，以下就是4选1选择器扩展为8选1选择器的电路图。
（注意，这里我的1C0~1C3和2C0到2C3输出口都是接高电平，这个可以根据实际情况去接高电平或者低电平。）
3.仿真结果 由于数据选择器是选择1C0~1C3和2C0到2C3这8个输出口输出的，我这里都是接高电平，那么输出结果要么是高位(OUT2)为1，要么是低位(OUT1)的为1。仿真结果无误。
三、8选1选择器的应用 1.三变量表决器 项目一 ： 用指定芯片设计一个三变量表决器（即三个人对于某件事情进行表决，两个和两个以上同意则表决结果为通过，否则为不通过）。也就是说，输入端ABC,只要其中有两个或以上的输入1，那么结果就是通过，输出1。
真值表：
如下图，我们可以看到74ls153芯片，在不同的输入现在地址下的输出。要想实现三变量表决器的话，我们就需要根据上图的三变量表决器的真值表来去设置1C0~1C3和2C0到2C3这8个输出口输出的电平接口，很显然1C0,1C1,1C2,2C0这四个是接到低电平的，也就是直接接地，而剩下的四个就是接高电平的，直接接电源VCC。
电路连接图： 仿真结果如下所示：
仿真无误，实验成功。
实际电路连接图：
2.奇偶校验电路 项目二 ： 用指定芯片设计一个三位输入一位输出的奇偶校验电路（奇校验电路，当输入有奇数个 1 时， 输出为 1；偶校验电路当输入有偶数个 1 时，输出为 1。这里以奇校验电路为示例：
真值表：
表达式：Y=m1+m2+m4+m7
同样的我们根据表达式，去对C0~1C3和2C0到2C3这8个输出口输出的电平接口设置，很显然，1C0,1C3,2C1,2C3这4个是接低电平的，直接接地，而另外四个就是接高电平。
电路连接图如下：
仿真结果：
这里我们可以看到，当A2,A1,A0其中一个输出一个高电平的时候，输出结果就是1，表示奇数，当三个都输入1的时候输出结果也是1，其他情况为0，那就说明仿真无误。
实验连接图忘记拍照了，不好意思哈！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22c6dea36a2a54bbc3c3627ef59e6e5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3218237a767567d028a7d8c63dcc216b/" rel="bookmark">
			c&#43;&#43;模式之单例模式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++模式之单例模式详解 1.概念2.懒汉模式示例（缺点）3.懒汉模式线程安全4.饿汉式创建单例5.饿汉模式线程示例 1.概念 单例模式是指在整个系统生命周期内，保证一个类只能产生一个实例，确保该类的唯一性.
使用单例两个原因：
1.节省资源。一个类只有一个实例，不存在多份实例，节省资源。
2.方便控制。在一些操作公共资源的场景时，避免了多个对象引起的复杂操作
单例类的特点
构造函数和析构函数为私有类型，目的是禁止外部构造和析构。拷贝构造函数和赋值构造函数是私有类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。类中有一个获取实例的静态方法，可以全局访问。 2.懒汉模式示例（缺点） getInstance函数使用了懒汉式单例模式的实现方式。它首先检查静态成员变量instance是否为空，如果为空则创建一个新的实例，否则直接返回已有的实例。这种实现方式在单线程环境下是有效的，但在多线程环境下可能会导致线程安全问题。
在多线程环境下，多个线程可能会同时检查到instance为空，然后同时创建多个实例，违背了单例模式的初衷。为了解决这个问题，我们需要在创建实例时添加同步机制，以确保只有一个线程能够创建实例。
#include &lt;iostream&gt; #include &lt;mutex&gt; #include &lt;ctime&gt; #include &lt;vector&gt; using namespace std; void sleep(int time) { clock_t head = clock(); while (clock() - head &lt;= time) {} } class Singleton { private: static Singleton* instance; // 静态成员变量，用于保存单例实例 Singleton() {} // 私有构造函数，防止外部实例化 public: static Singleton* getInstance() { if (instance == nullptr) { instance = new Singleton(); } return instance; } void someFunction() { // 单例的其他成员函数 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3218237a767567d028a7d8c63dcc216b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ec6c5c2b4a5710e5f2f0cb22dfbd66/" rel="bookmark">
			从72%到11%‼️专科生要不要写毕业论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天来聊聊专科生要不要写毕业论文，希望能给大家提供一点参考。
以下是针对论文重复率高的情况，借助工具修改，提供一些修改建议和技巧：
小发猫智能伪原创生成软件 http://cat.kuaimalunwen.com/
小发猫伪原创是一款非常实用的在线工具，它利用了最先进的自然语言处理技术，能够快速、高效地生成高质量的伪原创文章。这款软件的设计初衷是为了帮助网站管理员解决内容更新问题，提高网站的内容质量和排名。
小发猫伪原创的独特之处在于，它能够智能地识别和替换文章中的重复内容，从而确保文章的原创性和流畅性。这不仅使得伪原创文章更具有吸引力，而且有助于提高搜索引擎的排名。此外，小发猫伪原创还提供了一系列便捷的功能，如一键发布、定时发布等，让用户能够更轻松地管理他们的网站。
好的，以下是一篇关于“专科生要不要写毕业论文”的百科：
专科生是否需要写毕业论文，是一个有争议的话题快码论文。然而，根据不同的专业和学校的要求，专科生是否需要写毕业论文可能会有所不同。
首先，我们需要明确一点，毕业论文是高等教育院校毕业生最后一门课程，是考核学生综合能力及素质的一篇论文，其质量是衡量毕业生论文水平的重要标准。对于一些专业性较强的学科，如医学、法律等，毕业论文是必不可少的环节。这些专业的毕业生需要通过撰写毕业论文，对所学的专业知识和技能进行全面的梳理和总结，以提升自己的专业素养和综合能力。
然而，对于一些实践性较强的专科专业，如数控技术、汽车维修等，毕业论文可能并不是必需的环节。这些专业的毕业生通常需要在实际操作中掌握技能，通过实习、实验、实训等环节来提高自己的实践能力。因此，这些专业的毕业要求可能更加注重实践操作技能的提升，而不是撰写毕业论文。
另外，一些专科学校也可能为学生提供其他形式的毕业设计或毕业项目作为替代毕业论文的选项。这些形式可能包括实习报告、作品集、项目经验总结等。这些替代形式的设计或项目可以帮助学生展示自己在所学专业领域中的技能和应用能力。
综上所述，专科生是否需要写毕业论文，需要视具体情况而定。一般来说，对于一些专业性较强的学科，如医学、法律等，毕业论文是必不可少的环节。而对于一些实践性较强的专科专业，如数控技术、汽车维修等，毕业论文可能并不是必需的环节。学生应该根据所学专业的培养计划和学校的要求，认真了解毕业论文的撰写要求和标准，并按照要求认真完成毕业论文的撰写工作。同时，学生也应该注重提高自己的专业素养和综合能力，为将来的职业发展打下坚实的基础。
专科生要不要写毕业论文相关文章：
从61%到7%‼️网上论文降重违法吗
从60%到6%‼️在线同义句转换
从59%到6%‼️一键生成文案的软件
从54%到6%‼️试验方法如何降重
从69%到7%‼️wps的论文降重怎么样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e594d9230ff6b959f243286ba770a34b/" rel="bookmark">
			如何禁止网站中网页打开,怎么禁止网站使用cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小编为大家解答禁止网站运行javascript会怎样的问题。很多人还不知道如何阻止网页多余的js加载，现在让我们一起来看看吧！
前奏：
当你想访问一个页面，因为不符合访问条件，而被JS阻拦；或者你打开的页面特效太多，干扰视线；亦或者JS的某个功能禁止了你的某些行为；
是不是很难受，
好办，咱给他禁了不就好啦，大胆地屏蔽它，不管对方的java脚本写的有多么出神入化，只需要一个按钮就可以“置对方于死地”。
不过这是建立在你是合法访问，以及后台没有做限制的基础上，禁JS才能达到你的预期效果python for语句用法。
话不多说，咱们开始吧。
步骤：
1.打开谷歌浏览器右 上角的“自定义及控制”按钮，选择“设置选项”
2.“高级”-&gt;“隐私设置和安全性”-&gt;“网站设置”
3.在“网站设置”选择“JavaScript”
4.点击滑动按钮，即可全网禁止JS
5.当然，你可以只禁止一个网站的JS，或者只允许一个网址加载JS，看你需要可自行设置，我就不一一赘述啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de35aaa15cd3214898ad6f82be2c739/" rel="bookmark">
			Lab-3-P1-递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一关：欧几里得算法 任务描述 本关任务：python实现欧几里德辗转相除法。
编程要求 参考上述实验指导编写python程序，实现输入任意正整数M和N，使用欧几里德算法正确计算二者的最大公约数。
测试说明 平台会对你编写的代码进行测试：
测试输入： 2 4 预期输出： 2和4的最大公约数为2。
测试输入： 999 991 预期输出： 999与991互质。
# #输入M和N M = int(input()) N = int(input()) # ##请继续你的代码： i = None if M &gt;= N: for i in range(N, 0, -1): # 这里是从大到小来获取i的值 if N % i == 0 and M % i == 0 and i != 1: # 判断公约数 print(f"{M}和{N}的最大公约数为{i}。") break elif i == 1: print(f"{M}与{N}互质。") elif M &lt; N: for i in range(M, 0, -1): if N % i == 0 and M % i == 0 and i !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3de35aaa15cd3214898ad6f82be2c739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cccaa45558a0c40519f80219db0bf2/" rel="bookmark">
			【Linux 内核分析课程作业 1】mmap 实现一个 key-valueMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作业一 功能要求利用 mmap(虚拟内存映射文件) 机制实现一个带持久化能力的 key-valueMap 系统，至少支持单机单进程访问。(可能用到的 linux API: mmap、msync、mremap、munmap、ftruncate、fallocate 等)
电子版提交方式：
2023 年 11 月 20 日 18:00 前通过西电智课平台提交
提交内容
(1) 源代码，包含必要的注释;(2) 简单的说明文件，说明程序如何运行。
邮件主题、附件命名方式：主题：小作业 1-学号 - 姓名 (英文半角，非下划线).
附件：学号 - 姓名.rar，请严格按照命名规范提交!。
联系邮件：xxxxxxx
请勿抄袭，如有雷同，都将以零分计。
代码说明 运行测试结果
$gcc mmapMap.c &amp;&amp; ./a.out 强制同步比 0.00 &gt; 0.078 秒 强制同步比 0.10 &gt; 0.276 秒 强制同步比 0.20 &gt; 0.384 秒 强制同步比 0.30 &gt; 0.513 秒 强制同步比 0.40 &gt; 0.663 秒 强制同步比 0.50 &gt; 0.602 秒 强制同步比 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3cccaa45558a0c40519f80219db0bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2948fcba5a05257534e9eaf1a81367/" rel="bookmark">
			SAF第三方第四方免签约聚合易支付系统源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 SAF易支付系统是一个可以第三方/第四方免签约聚合支付系统，基于彩虹易支付二次开发而来，增加了大量实用功能，适合支付类企业使用。
安装 进行安装：域名/install
后台地址：域名/admin
账号admin
密码123456
预览 地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c627e77ffafcf7979091cc3afa70c5a/" rel="bookmark">
			彩虹DS6.6免授权版本带后台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 自助下单彩虹云商城系统
安装 宝塔上传源码，导入sql文件，修改config文件为你的数据库，进入【域名/install】安装好后进后台【用户：admin,密码：123456】
易支付接口修改下other/epay/epay.config.php文件里面的修改你的商户ID和密匙
预览 地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6e1464b7bb0e7fcee7643c2927f5713/" rel="bookmark">
			浅尝 FreeRTOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
RTOS通识
什么是RTOS
如何下载：以下官网下载链接
nullhttps://freertos.org/zh-cn-cmn-s/
FreeRTOS 实现多任务的原理
移植 FreeRTOS 到上官二号平台 ​编辑 freertos选项卡​编辑
任务的创建与删除
任务创建与删除相关函数 任务动态创建与静态创建的区别：
任务调度
FreeRTOS的任务调度规则是怎样的？
任务的状态 创建四个线程（任务）---- 代码段及API
消息队列
写队列​编辑
读队列 消息队列发送接收 ---- 代码段
信号量
二值信号量 ---- 代码段
计数型信号量 ---- 相比二值信号量可以存放更多，更多锁
互斥量 使用Mutex互斥量替换二值信号量
事件标志组
任务通知
任务通知 ---- 信号量
任务通知 ---- 代码段二值信号量
任务通知 ---- 代码段计数型信号量
任务通知 ---- 代码段事件组标志位组​编辑
软件定时器
软件定时器相关配置
相关API​编辑
中断管理
RTOS通识 什么是RTOS Free 即免费的， RTOS 的全称是 Real time operating system ，中文就是实时操作系统。 注意： RTOS不是指某一个确定的系统，而是指一类操作系统 。比如： uc/OS ， FreeRTOS ， RTX ， RT-Thread等这些都是 RTOS 类操作系统。 FreeRTOS 是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管 理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满 足较小系统的需要。 由于RTOS 需占用一定的系统资源 ( 尤其是 RAM 资源 ) ，只有 μC/OS-II 、 embOS、 salvo 、 FreeRTOS 等少数实时操作系统能在小 RAM 单片机上运行。相 μC/OS-II 、 embOS等商业操作系统， FreeRTOS 操作系统是完全免费的操作系统，具有源码公开、可移 植、可裁减、调度策略灵活的特点，可以方便地移植到各种单片机上运行，其最新版本为 如何下载：以下官网下载链接 nullhttps://freertos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6e1464b7bb0e7fcee7643c2927f5713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2afdd5283871e935e0448a0dcfa95e91/" rel="bookmark">
			【深度学习】使用GPU（CUDA）跑通YOLOv5源码，包含搭建环境&#43;训练数据集&#43;预测（整套流程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tips：本人是因为在CPU上训练数据太慢才选择使用GPU的，其实CPU和GPU和代码上只有一丝丝的区别。如果在搭建环境和跑通YOLOv5源码有遇到一些BUG可以参考我的上一篇文章： 【深度学习】浅浅记录卸载旧版本anaconda+安装pytorch环境+跑通YOLOv5源代码所遇到的一系列问题
文章目录 1.安装软件1.1 anaconda安装1.2 pycharm安装 2.搭建环境2.1 搭建anaconda环境2.2 查询CUDA版本号2.3 导入GPU版本的pytorch 3.跑通YOLOv5项目3.1 下载源码与权重参数3.2 在pycharm里面添加配置好的环境3.3 下载安装依赖3.4 运行detect.py 4.训练自己的数据4.1 数据集准备4.2 运行train.py 5.预测结束后可以在yolov5-master\runs\detect\exp文件夹里查看结果 ![在这里插入图片描述](https://img-blog.csdnimg.cn/0c84cd82ad4f4f01b273969becfbfda3.png) 结束语 1.安装软件 因为我是在全新的电脑上进行安装的，故需要自己进行pycharm和anaconda的安装。
1.1 anaconda安装 anaconda的安装可以参考我上一篇文章【深度学习】浅浅记录卸载旧版本anaconda+安装pytorch环境+跑通YOLOv5源代码所遇到的一系列问题里面的第二点，就是anaconda的安装教程。
简述步骤就是：①在清华源下载Anaconda3-2020.11-Windows-x86_64版本。②安装anaconda。③配置环境变量。④检查环境是否配置完成。
1.2 pycharm安装 此处我安装的是社区版，直接进入官网链接进行安装即可。
此处贴一个安装教程：程序员小麦的文章2023最新PyCharm安装+界面配置，给你一个舒适的开发环境
跟着此教程进行安装和汉化即可。
2.搭建环境 2.1 搭建anaconda环境 使用命令进行pytorch的虚拟环境安装，并进入创建好的ptyorch_GPU虚拟环境
conda create -n pytorch_GPU python=3.8 conda activate pytorch 2.2 查询CUDA版本号 CMD进入NVIDIA Corporation，再使用命令进行查看。
可以看到cudaversion可以兼容12.2及以下，也可以看到本机上显卡的编号是0（后面要用）
nvidia-smi 2.3 导入GPU版本的pytorch 去pytorch官网：https://pytorch.org/，选择相应的GPU版本。
因为兼容12.2及以下，就选择CUDA12.1即可。
复制最后一行的命令行，到上面创建好的虚拟环境pytorch_GPU中执行即可。
然后就是等待安装即可。
安装完成：
检查是否安装成功：
3.跑通YOLOv5项目 3.1 下载源码与权重参数 去GitHub下载YOLOv5源码压缩包和相关的权重文件，我下载的是预训练好的yolov5s.pt文件。
将yolov5s.pt放于yolov5根目录下。
用pycharm打开yolov5项目。
3.2 在pycharm里面添加配置好的环境 不过添加的时候，我这边有个bug是没有搭建好的python.exe，后来查询得知：先点击conda.bat，然后在下拉列表中选择已经搭建好的环境。
3.3 下载安装依赖 在pycharm终端输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2afdd5283871e935e0448a0dcfa95e91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf43b849dbfd3b465b25d2488462085c/" rel="bookmark">
			让人才成为网络安全的“守护者”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 演讲主题演讲嘉宾让人才成为网络安全的“守护者”网络安全形势及趋势人才需求现状人才养成记 攻防团队介绍 演讲主题 2023年11月11日下午15时，在上海杉达学院，我们伴随着微风吹拂，落叶片片飘落，来到了赖老师的课堂，主题为《让人才成为网络安全的“守护者”》。
演讲嘉宾 赖杨健
WIS-HUNTER资深安全架构师，18年以上安全行业工作经验，白帽黑客；曾供职于启明星辰、爱立信、阿朗、上汽国内大型企业；多次承担过某行业金融企业HVV攻防演习负责人；多次参加过国家级HVV,省级HVV红蓝对抗实战，担任红队队长。
让人才成为网络安全的“守护者” 这个季节有着深邃的魅力，让人感受到生命的轮回和变化的美妙。在这个丰收的季节里，我们可以收获属于自己的果实，感受到自然的慷慨和给予。
在这样的季节里，用一颗平静的心去领略自然的美，感悟生命中美好的事物，或许是一种极好的享受。接下来带着求知的迫切感走进主题。
网络安全形势及趋势 当前的网络安全形势仍然面临着许多威胁和挑战。随着信息技术的不断发展，网络攻击的数量和种类不断增加。
黑客和网络犯罪分子利用各种技术手段窃取数据、破坏系统，对企业和个人造成了很大的威胁。随着智能手机和平板电脑等移动设备的普及，移动设备上的信息也变得越来越重要。然而，移动设备的安全性常常被忽视，造成安全风险增加。
人才需求现状 通过赖老师的讲座我们了解到了网络安全人才应具备的专业技能，首先我们必须了解政策法规及标准，然后才能谈专业技能，例如：Windows/Linux/Unix操作系统主机安全防护，主机恶意代码防护；大数据、物联网、云计算安全；DOS及DOOS类攻击的安全防护安全设备与工具；网络层攻击的安全防护、网络单元信息的收集等。
人才养成记 网络安全岗位的薪资待遇也是我们同学最为感兴趣的，同样想成为一位网络安全人才也是不简单的。我们出必须具备扎实的专业技能之外，还要有控制自己感情的能力，并靠理性去行动，以顾客为第一位，具有永不厌倦的好奇心和进取心，严格遵循自己的价值观。
我们必须从此刻改变自己
赖老师说到：
一辆从不休息的车
并不比常保养的车走的更远。
攻防团队介绍 团队成立于2016年，WIS-HUNTER（中文全称智慧网络病毒猎手），拥有最全的信息安全服务内容；具备强大的安全研究团队，公司下辖多个实验室，其中杀手锏攻防实验室拥有大批漏洞发掘和分析人员，是独立发掘CVE和CNVD漏洞数量的团队；拥有覆盖8*N人的专业安全服务团队。
团队理念：
【理念】
以小博大，技术是杀手锏。
【文化】
1.明白人：知其然，知其所以然！不要迷惑于表象而要洞察事务的本质，要有文盲学习知识的心态，有时我们的学历，是我们学习过程中 最大的障碍。
2.出品人：本人出品，必属上品！有自我荣誉意识、追求卓越意识。乔布斯：人这辈子没法做太多事情，所以每一件都要做到精彩绝伦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1310250cdfdd0d3da972d8d3207399/" rel="bookmark">
			网络的七层概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网络的七层概念 网络的七层是指OSI（Open Systems Interconnection）模型，它是一个用于理解和描述计算机网络功能的框架，将网络通信划分为七个不同的层次。每个层次都有其特定的功能和责任。这个模型帮助网络设计者和工程师理解网络协议的工作原理，从而更容易实现和维护复杂的网络系统。
概念图：
网络七层分成物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
层数模型介绍第一层物理层主要关注传输比特流，即通过物理介质（例如电缆、光纤）传输数据的方式。定义了硬件设备之间的物理连接和电气规范。第二层数据链路层负责将物理层提供的比特流组织成帧（Frame）。 提供了错误检测和纠正，以确保数据的可靠传输。 控制对物理介质的访问，以协调设备之间的数据流。第三层网络层主要关注数据包的路由和转发，决定数据包如何从源地址传输到目标地址。 提供了逻辑地址（IP地址）的定义和管理。 处理不同网络之间的通信。第四层传输层负责端到端的通信，确保数据的可靠传输。 提供了流量控制和错误恢复的机制。 基于端口号识别应用程序，为应用层提供数据的分段和重组。第五层会话层管理和协调两个设备之间的通信会话。 提供了会话的建立、维护和结束功能。 处理数据的同步和检测错误。第六层表示层负责数据的格式转换、加密和压缩，以确保不同系统之间的数据交换是无缝的。 处理数据的编码和解码。第七层应用层提供网络服务和应用程序之间的接口。 包括用户接口、电子邮件、文件传输等各种网络服务。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d8ce5e17728a87d9f4c2e6f216c8b9/" rel="bookmark">
			Linux下Centos7 gcc/g&#43;&#43;、动态库/静态库（动态/静态链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.gcc/g++ gcc是对c语言代码进行编译链接，而g++是对c++代码进行编译链接，接下来我们只对gcc进行讲解，g++的使用方法跟gcc是一样的。
编译链接的四个步骤:
1:预处理
2:编译
3:汇编
4:链接
注：这些在后面都会着重讲解
1.1gcc -o 我们先在Date.c 源文件里面写一些c语言代码，我们知道，c语言代码需要编译链接翻译为计算机能识别的二进制指令才能执行。而gcc就是Linux环境下用来对c语言代码编译链接的指令.
gcc 源文件 -o 生成指定的文件名
gcc Date.c -o date.aout
注：这里会一步到位，直接会生成一个可执行程序，接下来我们再一步一步分析具体细节
1.2gcc -E （预处理）(.i) 预处理：头文件展开、去注释、宏替换、条件编译
-E:当程序进行翻译时，预处理阶段执行完就停下来
gcc Date.c -o date.aout -E
头文件展开：#include&lt;stdio.h&gt;这个文件里面有很多函数的声明和typedef的内容，头文展开会将stdio.h这个文件中所有的内容复制一份到我们的date.i文件中。
去注释：会将我们注释的内容替换为空格。
1.3gcc -S (编译)(.s) 编译：将c语言写的内容翻译为汇编语言
-S:当程序进行翻译时，编译阶段执行完就停下来
gcc Date.c -o date.s -S
1.4gcc -c （汇编）(.o) 汇编：将汇编语言翻译为二进制语言。
-c:当程序进行翻译时，编译阶段执行完就停下来
gcc Date.c -o date.o -c
1.5gcc -o (链接) 当我们不带-E、-S、-c这些选项时，直接-o，gcc就会一步到位从预处理阶段到编译，再到汇编，最后到链接！！！
在我们上面写的c语言代码中，我们并没有写printf函数的具体实现，而在&lt;stdio.h&gt;这个文件中也只有printf函数的声明而没有其具体实现的定义，那么我们再使用printf这个函数的时候怎么去调用这个函数呢？
在Linux Centos7 环境下，系统把这些函数的具体实现都放在了一个名为libc.so.6的库文件中了，路径为/usr/lib/libc.so.6，当我们调用printf函数时，会去libc.so.6库文件中去寻找printf实现的实现方法，最终成功调用。
我们可以使用ldd + 可执行程序 来查看该可执行程序依赖了那些库文件
2.动态库/静态库 2.1.再谈链接 链接的时候，我们是怎么去库文件中寻找函数具体实现的方法的呢？
有两种情况，一种是我们得到函数的地址，在生成可执行程序时根据地址去调用这个函数，另一种则是我们得到这个函数的整体实现过程，在生成可执行程序时将函数实现的代码加载进来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77d8ce5e17728a87d9f4c2e6f216c8b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a9a9a98242040aa4047e646d5ee374/" rel="bookmark">
			深信服技术认证“SCSA-S”划重点：渗透测试工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为帮助大家更加系统化的学习网络安全知识，尽快通过深信服安全服务认证工程师认证，深信服推出“SCSA-S认证备考秘笈”共十期内容，“考试重点”内容框架，帮助大家快速get重点知识~
划重点来啦
深信服安全服务认证工程师（SCSA-S），定位于普适性的安全服务技术，适合在校生、应届毕业生或具备0-3年工作经验的网络安全工程师。该认证包含网络安全法律法规、操作系统基础、计算机网络基础、渗透测试基础、漏洞扫描、信息收集、WEB漏洞挖掘、安全事件处置等课程内容，侧重考核网络安全服务相关知识，评估网络安全实战型人才。
学习并获得SCSA-S认证后，可以具备识别网络威胁和安全事件、收集、整理、管理威胁信息、漏洞扫描与验证，漏洞分类分级、针对WEB系统进行脆弱性测试和渗透性测试等能力。
深信服技术认证SCSA-S样证
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3c6a6f37d874a6ea8b8cdb738900c5/" rel="bookmark">
			北京讯为电子RK3568开发板Android11系统移植笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以进程的视角来看Android系统
Android源码获取途径 从谷歌网站获取Android源码
从芯片原厂获取Android源码
从方案厂商获取
优势：
从谷歌网站获取Android源码可以第一时间研究最新的技术，但是移植到具体的芯片上很难
从芯片原厂获取Android源码可以很容易得运行在某一个硬件上，但是更新较慢
AOSP下载 AOSP：Android Open-Source Project，中文为安卓开源项目。
repo工具下载 谷歌利用repo对所有git仓库进行管理，并且让用户通过repo工具批量下载Android源码，所以我们下载Android源码之前必须先安装repo工具。
Android官网repo介绍和安装方法
电脑硬件要求 内存：不少于16GB
存储：不少于300GB
Ubuntu版本：Ubuntu18.04
安装git 执行以下命令
sudo apt-get install git 设置git 执行如下命令，填写名字和邮箱。
git config --global user.name “” git config --global user.email “” git config --list 下载repo git clone https://gerrit-googlesource.lug.ustc.edu.cn/git-repo 注意这里有可能会因为网络问题下载不成功，如果不能访问，可以换中科大的下载源。也会给大家提供一个下载好的。
配置repo mkdir .repo //创建的是一个隐藏文件夹，我们使用命令“ll”查看。 mv git-repo .repo/repo //将git-repo移动到刚刚创建的.repo文件中，并将名称改为repo cp .repo/repo/repo ./ //将repo复制到当前目录。 chmod u+x repo //修改repo操作权限。 下载源代码 官方下载教程
确定需要的安装版本的名称
用的是Android11，对应的版本标记可以在Android官网上找到
https://source.android.google.cn/docs/setup/about/build-numbers?hl=zh-cn%3F
这里我们选择android-security-11.0.0_r54,并记下这个标记会在下载的时候使用到。
AOSP源码可以清华和中科大的源中去下载：
中科大
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3c6a6f37d874a6ea8b8cdb738900c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cdeb319def865faeacf0a5f6c29ead5/" rel="bookmark">
			jwt单点登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在我们日常开发中登录是每个系统都要做的，对于单点登录是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。
开一下传统登录：
单点登录：
通俗讲：用户登录一次，就可已访问系统里的其他子系统。 二、JWT是什么 1.JWT的概况 通俗讲：就是一种生存字符串的规则叫JWT。JWT是JSON WEB TOKEN的缩写，它是基于 RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。
Token（令牌）属于无状态，因每个人制定的规则不同，生成的结果也不同。目前，多数人采用JWT为统一令牌标准，之后我也采用JWT作为token生成标准。
2.JWT的组成 jwt实例可以在该网站上获得解析结果：JSON Web Tokens - jwt.io
组成： 该对象为一个很长的字符串，字符之间通过"."分隔符分为三个子串。
每一个子串表示了一个功能块，总共有以下三个部分：JWT头、有效载荷和签名
JWT头:
JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。
{ "alg": "HS256", "typ": "JWT" } 在上面的代码中，
alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；
typ属性表示令牌的类型，JWT令牌统一写为JWT。
最后，使用Base64 URL算法将上述JSON对象转换为字符串保存。
有效载荷【用户信息】:
(通俗的讲就是用户信息)有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择
iss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID用于标识该JWT 上默认字段外，我们还可以自定义私有字段，如下例：
{ "userId": "1234567890", "name": "zhangsan", "admin": true } 请注意，默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。
JSON对象也使用Base64 URL算法转换为字符串保存。
签名哈希【防伪标志】:
签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。
首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名。
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(claims), secret) Base64URL算法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cdeb319def865faeacf0a5f6c29ead5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e8acea24ff8401fccf2679dca9008d3/" rel="bookmark">
			QProcess：在QT中调用外部程序（也是QT写的程序）（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT调用外部程序有三种大的方法：
（1）通过调用系统函数，system阻塞调用，WinExec非阻塞调用： 1、system("notepad.exe"); // 阻塞式调用
system函数可以调用外部程序，要以.exe为结尾，也就是完整的可执行文件名。调用时，它先调用cmd.exe，再由cmd中调用notepad.exe。所以执行这条语句时，可以看到cmd的窗口，然后再看到notepad（记事本）打开。同时原有进程被阻塞，只有关闭notepad后，才可以关闭调用的主进程。另外需要说明的是，调用的可执行路径的名称中不能有空格，否则cmd解释时会报错。如下面的网易云音乐执行时就会报错。
“C://Program Files (x86)//Netease//CloudMusic//cloudmusic.exe” 还有一点，就是路径中的"\\"。但这可能是我的错误习惯造成的，一定要用"//"。正确写法如下：“C://Netease//CloudMusic//cloudmusic.exe”
2、WinExec("mydirectory\\myApp.exe",SW_SHOW); // 非阻塞式调用
首先，调用此函数时，要包括头文件#include &lt;Windows.h&gt;。
第二，WinExec主要运行EXE文件，不能运行其他类型的文件。不用引用特别单元。
UINT WinExec(exePath,ShowCmd)；
第一个参数exePath是命令行参数。注意，可能要用pChar转化一下。第二个参数ShowCmd的用法如下：
----SW_HIDE 隐藏 ----SW_MAXIMIZE 最大化 ----SW_MINIMIZE 最小化，并把Z order顺序在此窗口之后（即窗口下一层）的窗口激活 ----SW_RESTORE 激活窗口并还原为初始化大小 SW_SHOW 以当前大小和状态激活窗口 ----SW_SHOW 用当前的大小和位置显示一个窗口，同时令其进入活动状态 ----SW_SHOWDEFAULT 以默认方式运行
----SW_SHOWMAXIMIZED 激活窗口并最大化 ----SW_SHOWMINIMIZED 激活窗口并最小化 ----SW_SHOWMINNOACTIVE 最小化但不改变当前激活的窗口 ----SW_SHOWNA 以当前状态显示窗口但不改变当前激活的窗口 ----SW_SHOWNOACTIVATE 以初始化大小显示窗口但不改变当前激活的窗口 ----SW_SHOWNORMAL 激活并显示窗口，如果是最大(小)化，窗口将会还原。
WinExec("运行程序的路径/文件名.exe --有需要可以加启动命令",SW_SHOW);
第三，WinExec执行时非阻塞式调用。可以关闭调用的主进程，而被调用的进程依然运行。据参考的博客说这种调用方法兼容性不好。考虑进程之间的参数传递，我不打算用这类系统函数调用的方式，所以不进一步研究了。
关于系统函数的调用还有两个函数，参考这篇博客：
参考这篇博客qt中ShellExecute、ShellExecuteEx和WinExec的用法和区别_qt shellexecute_东方忘忧的博客-CSDN博客
（2）通过QProcess,阻塞调用 1、QProcess::execute("c:\\mydirectory\\myApp.exe"); //绝对路径和相对路径都可以
windows下要带exe后缀，系统应用如记事本notepad可直接输入打开。
但这个函数如同system的系统调用，完全阻塞，子进程一旦运行，不可操作主进程。直到子进程退出。
2、QProcess::startDetached() 启动一个进程，然后使其和当前进程脱离进程的父子关系。
这是个不完全阻塞的调用方式。子进程调用运行后，主进程没有被阻塞操作，可以关闭主进程，而且关闭主进程后，子进程可以继续运行。应该是一种分离式的运行。
（3）通过QProcess,非阻塞调用 QProcess *pro = new QProcess; pro-&gt;start("c:\\mydirectory\\myApp.exe");
上面用QProcess的start()函数，运行后是一个非阻塞调用。子进程运行时，主进程可以关闭。并且主进程关闭时，子进程也被关闭。
但如果加上下面的语句，QProcess的start()函数，也能够变成阻塞式调用。也就是子进程运行时，主进程不可操作，不能退出，必须等待子进程结束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e8acea24ff8401fccf2679dca9008d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f7f15f33a5930a7cb9601367b91f756/" rel="bookmark">
			【深度学习】浅浅记录卸载旧版本anaconda&#43;安装pytorch环境&#43;跑通YOLOv5源代码所遇到的一系列问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、卸载旧版本anaconda遇到的问题1.1问题描述1.2解决方法 2、重新安装anaconda2.1下载anaconda2.2配置系统环境变量2.3检查是否安装成功 3、安装pytorch虚拟环境3.1利用anaconda构建名为pytorch的虚拟环境3.2下载pytorch 4、YOLOv5安装4.1报错gbk4.2解决方法：4.3再次运行安装依赖报错4.4运行detect.py报错ModuleNotFoundError: No module named ‘ultralytics‘+ 5、labelImg工具的安装6、批量图片重命名结束语 前言 很久之前安装了anaconda（蛮旧的版本）和python3.10。然后在使用anaconda建立虚拟环境的时候遇到了一系列的问题：
①刚开始使用anaconda建立的环境是3.7，然后安装import cv的时候不知道是不是我系统的环境变量设置的python3.10，终端pip老是安装到python3.10的文件夹下面，压根就不pip到anaconda建立的虚拟环境，而且旧版本的anaconda也蛮多bug的。
②在上一个问题的基础上，东搞西搞好不容易跑通了YOLOv5，安装labelImg的时候显示python3.10不！支！持！PyQt5！
好好好，我直接把python3.10和anaconda旧版本直接全都卸载了，搜罗了很多知识，原来安装了anaconda就不用安装python了，故打算重新安装anaconda
ps：python的卸载很方便，网上很多教程可以参考，由于卸载python很顺利丝滑，此处就不进行记录。
1、卸载旧版本anaconda遇到的问题 1.1问题描述 按照网上的教程说的是安装自带的卸载工具
conda install anaconda-clean 然后，给我报错了·汗颜
报错：Solving environment：failed InvalidVersionSpecError：Invalid spec：=2.7
搜罗了很多方法，说更新anaconda版本，因为版本太旧，使用update相关指令更新anaconda版本仍然报相同的错误。继续搜罗了很久，终于解决了：
1.2解决方法 此方法转载自麦芽907的文章：Anaconda安装clean卸载工具失败
报错和此文一致
我还将anaconda旧版本所在文件夹都删除了以及环境变量与anaconda相关的都删除干净。
此处出自YuPersist的文章：Anaconda的卸载及安装（图文详解）
至此，anaconda卸载完成。
2、重新安装anaconda 我重新安装的是Anaconda3-2020.11-Windows-x86_64版本，参考的是zk小帅哥的这篇文章 → \to →anaconda+pytorch+yolov5保姆级攻略，个人比较强推的，我后面跟着一步步配置，最后跑通了。
2.1下载anaconda 在清华源：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/，下载的Anaconda3-2020.11-Windows-x86_64版本。
下载好以后一路next安装即可，安装路径不要有中文。
2.2配置系统环境变量 2.3检查是否安装成功 3、安装pytorch虚拟环境 3.1利用anaconda构建名为pytorch的虚拟环境 使用命令进行pytorch的虚拟环境安装
conda create -n pytorch python=3.8 遇到的问题：某个下载网速太慢导致未下载成功，可以换个时间段进行下载。
进入创建好的ptyorch虚拟环境
conda activate pytorch 3.2下载pytorch 进入官网https://pytorch.org/，选择相应的版本复制命令进行安装。
import torch后下一行显示&gt;&gt;&gt;则证明pytorch虚拟环境搭建完成
然后测试cuda
因为我安装的是cpu
故显示false为正确的
4、YOLOv5安装 去GitHub下载YOLOv5源码压缩包和相关的权重文件，我下载的是预训练好的yolov5s.pt文件。
使用pycharm打开解压后的文件夹，然后点击右下角选择已经安装好pytorch的虚拟环境。
然后在下方选择终端，输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f7f15f33a5930a7cb9601367b91f756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c7360204b5b12904bf102c8ada07e4/" rel="bookmark">
			【数据结构】平衡树之红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AVL树解决了二叉搜索树退化为单支树而引发的效率问题，是一种绝对平衡的二叉搜索树，其性质（每个节点的左右子树高度差绝对值都不超过1）使其在对数据进行搜索时始终能保持高效（详见【数据结构】平衡树之AVL树）。但是，当涉及一些结构上的修改场景（例如增删），因为要频繁通过旋转来维护其绝对平衡的结构特性，代价较高，使得其在这样的场景中性能十分低下。
为了继续优化效率问题，后来又不断有大佬提出新的解决方案。1972年，Rudolf Bayer发明了最初红黑树（当时被称为平衡二叉B树）。而后在1978年， Leo J. Guibas 和 Robert Sedgewick 将其修改成了如今的红黑树。 红黑树（RBTree）是一种特殊的二叉平衡搜索树，通过一种特殊的“手法”来控制着二叉搜索树的平衡，使其效率与AVL树相当，且在应用和维护等方面整体优于AVL树。
对于平衡的控制，红黑树放弃了AVL树中调整平衡因子的方式（任一节点的左右子树高度差的绝对值不大于1），而是在树的每个节点上增加了一个用于表示节点的颜色（可以是Red或Black）的存储位，通过对任意一条从根到某个叶子节点的路径上，各个节点着色方式的限制，确保最长路径不超过最短路径的2倍，以此来使一整棵树接近平衡。
红黑树的应用十分的广泛，例如Java的集合框架 (HashMap、TreeMap、TreeSet)、C++ 的 STL（map/set、mutil_map/mutil_set）、linux内核等等，都将红黑树作为底层结构来使用过。
本篇博客将通过，对红黑树性质的梳理和主要功能的模拟实现，来帮助读者更加全面地了解红黑树。
目录
一、红黑树的性质 二、红黑树的模拟实现
1 - 树的构建
2 - 插入
3 - 完整代码
补、一些迷思
1.控制节点的红和黑，怎么就做到了“最长路径不超过最短路径的2倍”？
2.由红黑树与AVL树的性能比较，来说明为什么放弃绝对平衡
3.为什么新创建的节点/新插入的节点默认为红色？
4.对两种需控制平衡的情景的更多说明
5.插入构建红黑树的过程图解
一、红黑树的性质 红黑树是因其维护平衡的手段而得名的，通过对树节点颜色的控制，来实现“最长路径不超过最短路径的2倍”的近似平衡。它主要具备以下性质（或者说是它的平衡规则），且这些性质与维护平衡息息相关：
任意一个树节点的颜色非红即黑；根节点的颜色必为黑； 任意一个颜色为红的树节点，其孩子节点均为黑，双亲节点为黑（这意味着任意路径上没有连续的红色节点）； 对于任意一条从（不为空的叶节点下的）空节点通往根节点的路径，每条路径上黑色节点数量均相同； 每个空节点默认为黑色。 （ps：NIL节点指的是空节点 ）
二、红黑树的模拟实现 1 - 树的构建 //用枚举体来标识节点的颜色 enum Colour { RED, //0 BLACK, //1 }; //创建一个树节点（三叉链结构） template&lt;class K, class V&gt; struct RBTreeNode { RBTreeNode&lt;K, V&gt;* _left; //左孩子 RBTreeNode&lt;K, V&gt;* _right; //右孩子 RBTreeNode&lt;K, V&gt;* _parent; //双亲 pair&lt;K, V&gt; _kv; //节点的值 Colour _col; //放弃了AVL树的平衡因子，改用颜色标识来控制平衡 //一个树节点的构造函数 RBTreeNode(const pair&lt;K, V&gt;&amp;kv) : _left(nullptr) , _right(nullptr) , _parent(nullptr) , _kv(kv) , _col(RED) //默认一个新节点为红色 {} }; //创建一棵红黑树 template&lt;class K, class V&gt; class RBTree { typedef RBTreeNode&lt;K, V&gt;Node; private: //根节点 Node*_root = nullptr; }; 2 - 插入 红黑树可以看作是引入了颜色标识的二叉搜索树，与AVL树类似（详见【数据结构】平衡树之AVL树），它插入过程也大致分为两步：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33c7360204b5b12904bf102c8ada07e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76e63c9232313eb258aa9605bb1d9e49/" rel="bookmark">
			Dev C&#43;&#43;使用简明教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dev C++使用简明教程 Dev C++的使用 使用高级语言编程时，我们通常使用一个集成开发环境IDE（Integrated Developing Enviroment，简称IDE）来进行编辑、编译、运行和调试工作。
Dev-C++是一个Windows环境下C/C++的集成开发环境(IDE)，它是一款自由软件，遵守GPL（General Public License，通用性公开许可证）。是一个免费软件，最早是由 BloodShed 公司开发的，然后由 Orwell 接手进行维护，陆续开发了几个版本， 已停止更新，也就是说Dev-C++的国外作者最终版本是2016年发布的v5.11，已经多年未更新了，现在的更新开发，都是一些爱好者基于4.9.9.2.Dev-C++ 最新版本5.11进行的。
Dev-C++开发环境下载官网：
https://sourceforge.net/projects/orwelldevcpp/
下载之后开始安装。安装过程很简单，按照对话框的操作提示执行即可，在此略过不叙。可以参考：C++基础知识与开发环境
https://blog.csdn.net/cnds123/article/details/108832790
在Windows中安装完毕之后，在桌面上会出现如下图所示的图标：
双击 Windows 桌面上的 Dev-C++ 图标，可以启动Dev-C++。
启动后显示如下：
如果不想用英文界面，想改为中文界面，可单击菜单栏中“Tools"的"Environment Options"命令项，参见下图操作：
Dev C++ 支持单个源文件的编译，如果你的程序只有一个源文件（初学者基本都是在单个源文件下编写代码），那么不用创建项目，如果有多个源文件，才需要创建项目。
新建源文件
打开 Dev C++，在上方菜单栏中选择“文件 --&gt; 新建 --&gt; 源代码”：
或者，按下Ctrl+N组合键，都会新建一个空白的源文件，如下图所示：
在空白文件中输入如下代码：
#include &lt;iostream&gt;
using namespace std;
int main()
{
cout &lt;&lt; "Hello，这是我的第一个C++程序！"&lt;&lt; endl;
return 0;
}
参见下图：
注意： 除了中文的字符串，代码必须在英文输入环境下编辑程序，即为了输入程序，你必须切换到英文输入环境下。
请及时保存源码文件
在上方菜单栏中选择“文件 --&gt; 保存”，或者按下Ctrl+S组合键，都可以保存源文件。参见下图：
提示：C++是在C语言的基础上进行的扩展，C++已经包含了C语言的全部内容，Dev C++和大部分 IDE 一样，默认创建的是C++文件，若不加扩展名（.cpp）则自动添加之。
Dev C++界面上依次显示有菜单栏和两行工具栏。其中第一行工具栏是平时使用最多的，其各个按钮的功能如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76e63c9232313eb258aa9605bb1d9e49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89136b475c82dd6d2c5f7f0b688bf87d/" rel="bookmark">
			x86 Kylin V10系统安装kvm并创建虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#内核版本和系统版本 [root@xa-radb-02 ~]# uname -a Linux xa-radb-02 4.19.90-24.4.v2101.ky10.x86_64 #1 SMP Mon May 24 12:14:55 CST 2021 x86_64 x86_64 x86_64 GNU/Linux [root@xa-radb-02 ~]# cat /etc/kylin-release Kylin Linux Advanced Server release V10 (Sword) #查看是否支持虚拟化，值大于0表示支持 [root@xa-radb-02 ~]# egrep -c '(vmx|svm)' /proc/cpuinfo 128 #确保BIOS里开启虚拟化功能，即查看是否加载KVM模块 [root@xa-radb-02 ~]# lsmod | grep kvm kvm_amd 106496 100 ccp 102400 1 kvm_amd kvm 753664 1 kvm_amd irqbypass 16384 43 kvm #如果没有加载，运行以下命令： [root@localhost ~]# modprobe kvm [root@localhost ~]# lsmod | grep kvm # 桥接网络，kylin V10没有network.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89136b475c82dd6d2c5f7f0b688bf87d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4abd3305d339c2f06c8f674df6db4a6f/" rel="bookmark">
			搭建centos代理服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目的 搭建centos代理服务，为其他服务器提供IP代理
squid安装与使用
本文章思路及图片来源：centos代理服务器squid安装与使用以及windows代理服务器CCproxy安装使用_squid windows-CSDN博客
其中我实践了centos sqluid的安装和使用，发现了博主在auth_param basic program上的路径错误，所以自己写了一篇
1、安装 yum install squid -y yum install httpd-tools -y
2、配置squid.conf文件 vi /etc/squid/squid.conf
service squid restart
3、用户名密码访问代理 1、首先使用htpasswd创建用户名和密码 htpasswd -c /etc/squid/passwd test123
2、 查看添加的用户，密码是加密显示的 cat /etc/squid/passwd 3、在squid.conf文件里添加如下内容，并将允许所有ip访问注释掉 auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/passwd
auth_param basic realm proxy
acl authenticated proxy_auth REQUIRED
http_access allow authenticated
4、重启服务生效即可 service squid restart
5、验证代理是否生效，如果没有报错证明配置无问题 curl -x http://test123:123456@127.0.0.1:3128 www.baidu.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b76655ca4e766164658c79c02facda/" rel="bookmark">
			GIT排除target或指定目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
在idea-2020.1.4版本下讲解idea怎么显示或隐藏target目录。
需要知道:如果不是maven工程,是没有target目录的,其次编译后才会生成target目录.
普通项目会生成out目录
二、idea隐藏target目录
2.1、idea隐藏target目录
在idea工具project旁边的空白处右键，取消勾选Show Excluded Files即可隐藏target目录
2.2、git提交时隐藏target目录
在File—&gt;settings–&gt;Editor–&gt;File Type–&gt;.gitignore中添加target
注意：在这里配置后，git提交时会隐藏target目录，idea项目下也会隐藏target目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8678911443280bdf6392d07655686656/" rel="bookmark">
			Swift-day 2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、数据绑定，改变标题 @State private var zoomed: Bool = false 属性包装器包装的变量 self.title 单向绑定 self.$textInput 双向绑定 传的是数据结构 self.title= self.textInput 赋值是String self._title=title //绑定类型加下划线 2、数据绑定，传递结构 Binding 3、取得系统数据 @Environment 可以取到系统key的写法：developer.apple.com/documentation/swiftui/environmentvalues
4、观察者数据绑定 - ObservableObject, Published, ObservedObject 5、客户端编码框架MVVM模式 - Model-View-ViewModel 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0228a088782b103f3671c2e8003403/" rel="bookmark">
			Excel数据可视化—波士顿矩阵图【四象限图】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EXCEL系列文章目录 Excel系列文章是本人亲身经历职场之后萌发的想法，为什么Excel覆盖如此之广，几乎每个公司、学校、家庭都在使用，但是它深藏的宝藏功能却很少被人使用，PQ、BI这些功能同样适用于数据分析；并且在一些需要简单及时的数据分析项目前，Excel是完胜python、R、SPSS这些科学专业的软件的。因此决心开启Excel篇章。
数据分析为什么要学Excel
Excel图表美化—表格美化
Excel函数公式大全—IF函数
Excel函数公式大全—IF家族函数
Excel函数公式大全—VLOOKUP函数
Excel函数公式大全—MATCH函数
Excel函数公式大全—INDEX函数
Excel函数公式大全—HLOOKUP函数
Excel函数公式大全—LOOKUP函数
Excel函数公式大全—SUMIF/SUMIFS函数
Excel函数公式大全—函数真经
Excel数据可视化—波士顿矩阵图 EXCEL系列文章目录效果图原理实现过程数据准备绘图 图表解读总结：准备数据—绘画散点图—调整XY坐标轴—修改数据标签 效果图 啥也别说，咱们先看效果图【波士顿矩阵图】又有人称【四象限图】名字不重要，我们先解析一下图所要展示的意思：
坐标轴没有展示名字，此处展示各省份的评价得分（Y轴）与销售额（X轴）的关系；横纵坐标交于图像中间将图片分割为四个象限因此的名【四象限图】根据两项得分可分为：高得分低销售、高得分高销售、低得分低销售、低得分低销售区域针对不同区域制定不一样的政策方针，实行不一样的管理制度，具体根据实际业务实施 图表是数据的具象化，图是数据的直观展示，表是数据的高度汇总。本系列文章没有对图和表的推荐偏好引导，各位可以根据实际所需进行取舍。💯
原理 波士顿矩阵（Matrix: Boston Consulting Group）简称BCG，又称市场增长率-相对市场份额矩阵、四象限分析法、产品系列结构管理法等。波士顿矩阵由美国著名的管理学家、波士顿咨询公司创始人布鲁斯·亨德森于1970年创作。
波士顿矩阵认为一般决定产品结构的基本因素有两个：即市场引力与企业实力。市场引力包括整个市场的销售量（额）增长率、竞争对手强弱及利润高低等。其中最主要的是反映市场引力的综合指标——销售增长率，这是决定企业产品结构是否合理的外在因素。
以上原理来源百度，可见波士顿矩阵分析最开始是在做产品策略；随着广泛应用，结合多业务场景，也就范化为了四象限图。凡是根据两个指标去对产品、营业员、区域等进行分类时，就能高频的看见这个图表。话不多说，我们开始教学💪…
实现过程 数据准备 数据随机挑选了几个城市，构造两个指标；
值得注意的是在实际应用中，两个指标应相互独立最佳，避免相互影响。
绘图 因为EXCEL没有可以直接绘画波士顿矩阵的选项，需要通过散点图实现。 本人使用的是excel2019版本，如果后续更新出这个功能那就更简单了。
注： 选取数据时只选取两列指标值，插入散点图的时候选取最基础的散点图。
此时得到最基本的散点图，需要我们进行美化加工；
首先去掉标题和网格线，你就能得到下图：
接着我们需要对坐标轴进行调整，首先看下Y轴的调整：
单击Y轴，然后设置坐标轴格式，按照上图的框选进行调节，改变坐标轴的范围，交点及标签位置，你就能得到下图：
同理我们对X轴的调整：
注： 关于坐标轴的调整范围及交点没有统一的标准；坐标轴范围尽可能的贴近数据的最大最小值；坐标轴交点则可以根据实际的业务场景；如中值、平均值、达标值等都是优先选择的数据；
到这一步你已经得到了一个近乎完美的图了：
接下来的操作是excel可视化技巧中最常用的改变标签值：
首先调成标签值；然后设置数据标签格式，标签包含单元格中的值：
得到这样得图之后，先按上图得步骤去数据标记填充。
去数据标记后，我们需要把我们想要显示的城市显示在原来数据点的位置，就按上图去设置标签格式。
看到这儿就得恭喜你已经懂了excel一个波士顿矩阵的绘制技巧了，如果你是跟着操作到这儿，那你可太厉害了，算是掌握了绘画技巧，可以在工作中大秀一下了。
目前可以先放松放松，点赞+收藏，我们接着往下美化一下。
选中整个图表，我们就可以在菜单栏对字体、颜色、填充、阴影等效果进行调节。这部分因人而异，各自审美不同，品牌主题色也不同。
图表解读 此处说明一下，该图选取的指标是各城市的销售额与经营得分之前的关系坐标轴交点为平均销售额 2400 与经营得分达标值 60分；各数据点与坐标轴的距离就是与平均值的差距值。
从X轴来看，左边是低于平均水平，右边是高于平均水平。从Y轴来看，下边是低于及格60分，上边是高于及格60分。 简单分析一下：
黑龙江与山西：销售额与经营得分均高于平均水平，是可以作为推广，标杆式城市的经营方式。吉林、广西、陕西：销售额虽然高于平均水平，但是经营得分不达标，可能存在卫生、服务、售后等差的地方。重庆、江西、新疆：经营得分高，但是销售额低；可以深入探究一下该城市的市场是否还有很大空间，或仅做了经营得分的事项，对于增加销售额的活动政策等没有推广。海南、安徽等城市：需要重点关注的地方，双双不达标，必定是经营出现问题。 总结：准备数据—绘画散点图—调整XY坐标轴—修改数据标签 今天的分享就到这里啦；商务报表类的报表根据使用的对象不一样，大家可以根据不同的需求，在不脱离核心的范围内调整均可。最终以简单明了，突出重点为主，在阅读消化完上面的知识后；小伙伴们根据上面的案例自己动手试一下吧。
如果你觉得还有用的话就收藏吧、点赞+关注 | 咱们下期再会！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d234f8973a47d93316b0748b563ce0c/" rel="bookmark">
			map和vector的区别是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		map和vector的区别是什么这里写自定义目录标题 map 和 vector 是 C++ STL（标准模板库）中不同的容器，它们有着不同的特点和用途。Vector：Map：区别总结： map 和 vector 是 C++ STL（标准模板库）中不同的容器，它们有着不同的特点和用途。 Vector： 1.顺序容器： vector 是一种动态数组，它提供了动态大小的数组功能，元素在内存中是连续存储的。
2.随机访问： 具有常数时间复杂度的随机访问，这意味着可以通过索引直接访问任何元素。
3.自动内存管理： vector 负责管理其内部的内存分配和释放，当元素数量超出容量时会自动扩展内存。
4.元素存储： 以连续的内存块存储元素，适合需要快速随机访问的场景。
5.用途： 适合需要动态大小且能够快速随机访问元素的情况，例如需要动态增长的数组或者堆栈。
Map： 6.关联容器： map 是一种关联容器，它提供了键-值对的存储方式，将键映射到值。
7.基于键的访问： 使用键进行元素访问，具有对数时间复杂度，即使在非常大的数据集上也能快速查找元素。
8.自动排序： map 内部的元素是根据键进行排序的，它是有序的容器。
9.不连续存储： map 内部实现通常是基于树结构（通常是红黑树），不像 vector 那样连续存储。
10.用途： 适合需要键值对存储和检索，并且需要保持元素有序的情况，例如字典、映射等场景。
区别总结： 11.vector 是一个动态数组，适合需要随机访问、连续内存存储的场景，不适合大规模的插入和删除操作。
12.map 是一个键值对的关联容器，适合需要按键进行查找、有序存储的场景，不适合频繁改变键值对结构的操作。
在实际使用中，要根据具体的需求来选择合适的容器。如果需要随机访问元素，或者需要动态数组功能，可以选择 vector；如果需要按键快速查找元素，并且保持元素有序，可以选择 map。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6649aee3e84cec2032fe2f1a05f8a8d7/" rel="bookmark">
			基于.net MVC的学生网上请假系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 基于.netMVC的学生网上请假系统
摘要：随着信息化的发展，互联网基于多元化的服务，网络在线系统逐渐占据我们日常生活中的一部分，网络系统的需求将会越来越大，互联网给我们提供了个良好的竞争平台，虚拟交易也变得真实。
这个系统主要实现了学生管理、教室管理等的信息化和网络化，提高了办公管理效率。同时将学生请假、老师对学生请假的审批等这两个网页前台模块和请假信息管理、学校校园信息管理模块结合起来。经过参考网上对信息模块管理模式，全面的功能测试，系统也实现了很多丰富又实用的学生各类信息设置、方便了老师及学生的生活效率等。
这个系统相对现阶段外面类似的网上管理信息系统，代码修改性和拓展性好，操作步骤简洁，系统的加密及安全度相对来说也高，运行相对稳定。
关键词：网站，学生请假系统，ASP.NET ，SQL server 2008
The Design and Implementation of Student
Online Leave System
Abstract: With the development of informatization, the Internet is based on diversified services, and online online systems gradually occupy a part of our daily lives. The demand for network systems will become greater and greater. The Internet provides us with a good competitive platform. Virtual trading has also become real.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6649aee3e84cec2032fe2f1a05f8a8d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bebfe2f4e828788b9161afbd544534fd/" rel="bookmark">
			2022年广东省职业院校技能大赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年广东省职业院校技能大赛
网络搭建与应用竞赛
赛卷（B）
（总分1000分）
网络搭建与应用赛项专家组
2022 年 1 月 一、竞赛内容分布
“网络搭建与应用”竞赛共分三个部分，其中：
第一部分：网络搭建及安全部署项目 （500分）
第二部分：服务器配置及应用项目 （480分）
第三部分：职业规范与素养 （ 20分）
二、竞赛注意事项
禁止携带和使用移动存储设备、计算器、通信工具及参考资料。请根据大赛所提供的比赛环境，检查所列的硬件设备、软件清单、材料清单是否齐全，计算机设备是否能正常使用。请选手仔细阅读比赛试卷，按照试卷要求完成各项操作。操作过程中，需要及时保存设备配置。比赛结束后，所有设备保持运行状态，评判以最后的硬件连接和配置为最终结果。比赛完成后，比赛设备、软件和赛题请保留在座位上，禁止将比赛所用的所有物品（包括试卷和草纸）带离赛场。禁止在纸质资料、比赛设备、上填写任何与竞赛无关的标记，如违反规定，可视为0分。与比赛相关的工具软件放置在每台主机的D:\soft文件夹中。 项目简介: 集团设有行政、法务、营销、售后、财务 5个部门，分别分部在集团广东DC1、广东DC2、广东DC3、广西办事处；统一进行IP及业务资源的规划和分配，全网采用OSPF路由协议、BGP路由协议等进行组网，详细网络拓扑结构见“表1拓扑结构图”。
其中三台虚拟化三层交换机编号为SW-1、SW-2和SW-3作为集团的核心交换机；一台防火墙编号为FW-1作为集团广东DC3的出口网关；一台防火墙编号为FW-2作为广西办事处的出口网关；一台路由器编号为RT-1作为集团冗余的核心路由器；一台路由器编号为RT-2作为集团出口路由器；一台无线控制器编号为AC作为集团广东的无线WIFI控制器；一台企业级AP配合实现集团广东DC2的无线覆盖。
结合网络环境和网络拓扑要求，合理规划网络和IP地址，保证网络搭建及安全部署项目和服务器配置及应用项目顺利实施。
请注意：在此典型互联网应用网络架构中，作为IT网络系统管理及运维人员，请根据拓扑构建完整的系统环境，使整体网络架构具有良好的稳定性、安全性、可扩展性。请完成所有服务配置后，从客户端进行测试，确保能正常访问到相应
图1：拓扑结构图
表1：网络设备连接表
A设备连接至B设备
设备名称
接口
设备名称
接口
AC
E1/0/1
PC1
NIC
AC
E1/0/2
PC2
NIC
AC
E1/0/21
云平台
ETH1管理口
AC
E1/0/22
云平台
ETH2业务口
AC
E1/0/11
SW-1
E1/0/11
AC
E1/0/12
SW-1
E1/0/12
SW-1
E1/0/13
SW-2
E1/0/13
SW-1
E1/0/14
SW-2
E1/0/14
SW-1
E1/0/15
FW-1
E0/1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bebfe2f4e828788b9161afbd544534fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571dc086c2ec3934c112cca4d6fcca6c/" rel="bookmark">
			Form表单Input中按enter键自动提交的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		From表单中只有一个input时，按回车键后表单自动提交(form表单的一个小坑) 按钮绑定回车事件后按回车表单执行js方法后表单自动提交刷新，先执行了js的方法后自动提交表单，使它相当于没有执行js方法，查阅资料得知在一个form表单中，若只有一个input，按回车键表单会自动提交，但是当表单中存在多个input时，按回车键不会执行任何操作，这是form表单的一个特性。
&lt;form method="post" action="http:www.baidu.com"&gt; &lt;input&gt; &lt;textarea name="text" cols="20" rows="5" /&gt; &lt;/form&gt; 解决方案
第一种方法，把表单去掉，这是最管用，但也是最傻的方法，直接添加onclick事件，不用表单提交，这种方法就不赘述了。第二种方法，很多人估计都想到过，就是既然一个input会自动提交，多个input就没问题，那么我给它多加一个input不就行了，有些人试过发现不行，那是为什么呢？
因为他是这么写的&lt;input type="hidden"&gt;，这样当然不行，一个隐藏域，type并不是text，所以不行。
但是，&lt;input type="text" style="display:none;"&gt;，使用这种方法就可以了，因为它是用样式隐藏输入框的，实质上还是一个type为text的input。第三种方法，这种方法很好用，直接对form进行操作，个人推荐这种方式。直接在form上加上onsubmit="return false;"这段话，它会阻止表单的回车键进行提交。
例：&lt;form action="" method="post" onsubmit="return false;"&gt;第四种方法，这种方法是直接对input进行操作，强行将回车键操作去掉，这种方式也不错，在input上加一个onkeydown事件，
onkeydown="if(event.keyCode==13){return false;}"，阻止回车键的操作。
例：&lt;input type="text" onkeydown="if(event.keyCode==13){return false;}"&gt;vue方案 @submit.native.prevent
.native 表示对一个组件绑定系统原生事件
.prevent 表示提交以后不刷新页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d3f2fffaa8da72612f4d3e04262074/" rel="bookmark">
			Windows系统更新导致蓝牙无法启动或者USB硬件设备驱动出现黄色感叹号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题原因处理方法 问题原因 通过用串行总线（USB）控制器前面显示一个感叹号的错误提示是，由于其配置信息(注册表中的)不完整或已损坏，Windows 无法启动这个硬件设备。
造成这种现象的原因，是因为量产工具自带的驱动造成的，并且一般量产工具也都提供驱动卸载的功能。所以在量产完成后，执行驱动卸载工具，把量产工具自带的驱动卸载掉，即不会发生此现象。
处理方法 1.win+R打开运行窗口
2.输入命令：regedit，打开系统注册表；
3.、然后依次展开下面的注册表项：
HKEY_LOCAL_MACHINE &gt; SYSTEM &gt; CurrentControlSet &gt; Control &gt; Class &gt; {36FC9E60-C465-11CF-8056-444553540000}；
4.在右面窗口找到【upperfilter】项或【lowerfilter】项，并删除；
5.卸载该目录下的带有黄色感叹号的驱动
![在这里插入图片描述](https://img-blog.csdnimg.cn/c86c70c66a514904b444f3e60
6.点击【操作】，选择【扫描检测硬件改动】，让系统自动重装一下驱动即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b461b9f953f65113158807653e72651e/" rel="bookmark">
			MATLAB R2023b安装包下载链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB2023b下载链接：
链接：https://pan.baidu.com/s/15VgPf8GnxlZHcbh2grJrDQ?pwd=luob 提取码：luob
链接：https://pan.baidu.com/s/1ZSTAB54vNxnGWFvccCyFDQ?pwd=8np8 提取码：8np8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba535d787ce36ad4edd80fd084a748b1/" rel="bookmark">
			git merge指定的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你只想在合并时包含特定类型的文件（例如，只合并.java文件），可以使用git checkout命令和git merge命令的组合来实现。以下是一个可能的步骤：
确保在目标分支上：
在执行合并之前，请确保你已经切换到目标分支。例如，如果你想将pro分支上的.java文件合并到dev分支中，首先切换到dev分支：
bash
git checkout dev 使用git checkout检出pro分支上的.java文件：
bash
git checkout pro -- "*.java" 这将从pro分支检出所有.java文件到你当前的dev分支。
提交更改：
bash
git add "*.java" git commit -m "Merge .java files from pro branch" 这将提交所有.java文件的更改到dev分支。
这样，你就只合并了.java文件，而不是整个分支。请注意，上述命令使用了通配符*.java，确保只有.java文件被包含在合并中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8efb4dce5f2a3f69847c7c4cc3f9482/" rel="bookmark">
			java高并发系列-第3天:有关并行的两个重要定律
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关为什么要使用并行程序的问题前面已经进行了简单的探讨。总的来说，最重要的应该是处于两个目的。
第一，为了获得更好的性能；
第二，由于业务模型的需要，确实需要多个执行实体。
在这里，我将更加关注第一种情况，也就是有关性能的问题。将串行程序改造为并发程序，一般来说可以提高程序的整体性能，但是究竟能提高多少，甚至说究竟是否真的可以提高，还是一个需要研究的问题。目前，主要有两个定律对这个问题进行解答，一个是Amdahl定律，另外一个是Gustafson定律。
Amdahl(阿姆达尔)定律 Amdahl定律是计算机科学中非常重要的定律。它定义了串行系统并行化后的加速比的计算公式和理论上线。
加速比定义：加速比 = 优化前系统耗时 / 优化后系统耗时
所谓加速比就是优化前耗时与优化后耗时的比值。加速比越高，表明优化效果越明显。图1.8显示了Amdahl公式的推到过程，其中n表示处理器个数，T表示时间，T1表示优化前耗时(也就是只有1个处理器时的耗时)，Tn表示使用n个处理器优化后的耗时。F是程序中只能串行执行的比例。
根据这个公式，如果CPU处理器数量趋于无穷，那么加速比与系统的串行化比例成反比，如果系统中必须有50%的代码串行执行，那么系统的最大加速比为2。
假设有一个程序分为以下步骤执行，每个执行步骤花费100个单位时间。其中，只有步骤2和步骤5可以并行，步骤1、3、4必须串行，如图1.9所示。在全串行的情况下，系统合计耗时为500个单位时间。
若步骤2和步骤5并行化，假设在双核处理器上，则有如图1.10所示的处理流程。在这种情况下，步骤2和步骤5的耗时将为50个单位时间。故系统整体耗时为400个单位时间。根据加速比的定义有：
加速比 = 优化前系统耗时 / 优化后系统耗时 = 500/400 = 1.25
由于5个步骤中，3个步骤必须串行，因此其串行化比例为3/5=0.6，即 F = 0.6，且双核处理器的处理器个数N为2。代入加速比公式得：
加速比 = 1/(0.6+(1-0.6)/2)=1.25
在极端情况下，假设并行处理器个数为无穷大，则有如图1.11所示的处理过程。步骤2和步骤5的处理时间趋于0。即使这样，系统整体耗时依然大于300个单位时间。使用加速比计算公式，N趋于无穷大，有加速比 = 1/F，且F=0.6，故有加速比=1.67。即加速比的极限为500/300=1.67。
由此可见，为了提高系统的速度，仅增加CPU处理的数量并不一定能起到有效的作用。需要从根本上修改程序的串行行为，提高系统内可并行化的模块比重，在此基础上，合理增加并行处理器数量，才能以最小的投入，得到最大的加速比。
注意：根据Amdahl定律，使用多核CPU对系统进行优化，优化的效果取决于CPU的数量，以及系统中串行化程序的比例。CPU数量越多，串行化比例越低，则优化效果越好。仅提高CPU数量而不降低程序的串行化比例，也无法提高系统的性能。
阿姆达尔定律图示
为了更好地理解阿姆达尔定律，我会尝试演示这个定定律是如何诞生的。
首先，一个程序可以被分割为两部分，一部分为不可并行部分B，一部分为可并行部分1 – B。如下图：
在顶部被带有分割线的那条直线代表总时间 T(1)。
下面你可以看到在并行因子为2的情况下的执行时间：
并行因子为3的情况：
举个例子
一个业务会串行调用2个方法，m1，m2，m1耗时100ms，m2耗时400ms，m2内部串行执行了4个无依赖的任务，每个任务100ms，如下图：
m2内部的4个任务无依赖的，即可以并行进行处理，4个任务同时并行，当cpu数量大于等于4的时候，可以让4个任务同时进行，此时m2耗时最小，即100ms，cpu为2个的时候，同时只能够执行2个任务，其他2个任务处于等待cpu分配时间片状态，此时m2耗时200ms；当cpu超过4个的时候，或者趋于无限大的时候，m2耗时还是100ms，此时cpu数量再怎么增加对性能也没有提升了，此时需要提升的是任务可以并行的数量。
从阿姆达尔定律可以看出，程序的可并行化部分可以通过使用更多的硬件（更多的线程或CPU）运行更快。对于不可并行化的部分，只能通过优化代码来达到提速的目的。因此，你可以通过优化不可并行化部分来提高你的程序的运行速度和并行能力。你可以对不可并行化在算法上做一点改动，如果有可能，你也可以把一些移到可并行化放的部分。
Gustafson定律 Gustafson定律也试图说明处理器个数、串行化比例和加速比之间的关系，如图1.12所示，但是Gustafson定律和Amdahl定律的角度不同。同样，加速比都被定义为优化前的系统耗时除以优化后的系统耗时。
根据Gustafson定律，我们可以更容易地发现，如果串行化比例很小，并行化比例很大，那么加速比就是处理器的个数。只要不断地累加处理器，就能获得更快的速度。
Amdahl定律和Gustafson定律结论有所不同，并不是说其中有个是错误的，只是二者从不同的角度去看待问题的结果，他们的侧重点有所不同。
Amdahl强调：当串行换比例一定时，加速比是有上限的，不管你堆叠多少个CPU参与计算，都不能突破这个上限。 Gustafson定律关系的是：如果可被并行化的代码所占比例足够大，那么加速比就能随着CPU的数量线性增长。
总的来说，提升性能的方法：想办法提升系统并行的比例，同时增加CPU数量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6442dbae9c4c9e5759adb0fa1a13a6f9/" rel="bookmark">
			如何配置pip源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.配置私有pip源 1.首先进入 root 目录 cd /root mkdir .pip cd .pip vim pip.conf 在pip.conf中写入私有源即可 yum install python2-pip -y 安装pip 是装python2还是python3根据自己的python版本定 python --version 2.配置公有pip源
国内比较好的镜像源 中国科学技术大学 https://mirrors.ustc.edu.cn/pypi/web/simple 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple 华中科技大学 http://pypi.hustunique.com/simple 中国科学院 https://pypi.mirrors.opencas.cn/simple 阿里云 https://mirrors.aliyun.com/pypi/simple 豆瓣 https://pypi.douban.com/simple 3.更换pip源
1.临时更换pip源 加上 -i 参数即可 pip install 软件包名 -i https://pypi.tuna.tsinghua.edu.cn/simple 2.永久配置 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 3.安装指定版本的包，可以通过==，&gt;=,&lt;=,&lt;,&gt; 来指定一个版本号 pip install 'package&lt;2.0' pip install 'package&gt;2.0,&lt;2.0.3' 4.卸载已经安装的库 pip uninsatll package 5.列出已经安装的库 pip list 6.将已经安装的库保存到文档中 pip2 freeze &gt; requirement2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6442dbae9c4c9e5759adb0fa1a13a6f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64f729b65e7c4a73552e77cc459697e/" rel="bookmark">
			Java实训：掌握利用API编程的方法，尽量使用类库&amp;利用类库编写程序，可以输出当月的日历（包括周） 超高完成度！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实训目的 掌握利用API编程的方法，尽量使用类库。
实训要求 利用类库编写程序，可以输出当月的日历（包括周）
一、 思路梳理 看到实验要求后，很快有了思路：
使用Date类（java.util.Date而非java.sql.Date;）的无参构造方法获取当前日期，然后使用SimpleDateFormat类自定义日期格式，即可格式化输出当前日期。
使用Calendar对象，通过Calendar.getInstance()，获取当前日期和时间。
然后，设置日期设置为当月的第一天，获取这一天是星期几以及当月的总天数
仿照常见日历，输出日历的表头。根据第一天是星期几，预处理出合适的空格数
最后循环输出每一天的日期，注意在适当的时候回车。
二、 简简单单写个小程序 1. 思路理顺后，很简单就写出来了下面这段代码 import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class version0 { public static void main(String[] args) { // 获取当前日期 Date date = new Date(); // 设置日期格式 DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); //输出当前日期 System.out.println("当前日期：" + dateFormat.format(date)); // 使用Calendar类获取当前月份 Calendar calendar = Calendar.getInstance(); // 设置Calendar对象的日期为当月的第一天 calendar.set(Calendar.DAY_OF_MONTH, 1); // 获取当月第一天是星期几 int firstDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK); // 获取当月的天数 int daysInMonth = calendar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d64f729b65e7c4a73552e77cc459697e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc954e4a17a6208f3dc42a9c1cf33c48/" rel="bookmark">
			发币成功，记录一下～
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		N年前就听说了这样一种说法——“一个熟练的区块链工程师，10分钟就可以发出一个新的币”
以前仅仅是有这么一个认识，但当时并不特别关注这个领域。
最近系统性学习中，今天尝试发币成功啦，记录一下～
发在 Sepolia Testnet
代币符号是K
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f14f697049ecd3ff3cbd1ddad4a97cd/" rel="bookmark">
			windows pgsql 数据库 数据目录更改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.先停止postgres服务 cmd命令
services.msc 找到服务停止
二.修改注册表 cmd命令
regedit 找到路径
\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\postgresql-x64-13
将“－D”后的目录名修改为新的数据目录位置即可，如果目录路径中含有空格，需要用引号引起。
三.数据迁移 将原来数据目录拷贝新的数据目录
ps:
需要注意必须检查用户权限是否可于访问新的数据目录。
四.开启服务 cmd命令
services.msc 找到服务开始
五. 结果 修改完毕后，可以用psql命令“show data_directory”查看当前数据目录
show data_directory 参考资料
Windows如何设置或更改PostgreSQL数据目录位置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e377602ccc4a7a6fde6e362c4f75ce24/" rel="bookmark">
			arcgis属性表十进制度转换成度分秒格式--转换坐标注记法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、有一组点数据，如下：
2、为其添加XY坐标，如下：
打开属性表，可得到对应点的XY的十进制度坐标，如下：
3、将十进制度转换成度分秒格式，如下，使用转换坐标注记法工具：
也可以转换成度十进制分格式，转换结果如下：
将表格导出为文本文件格式即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d76d9a3c3bba12afcfe548b9b9445d85/" rel="bookmark">
			java中@RequestParam的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@RequestParam 是 Spring 框架中用于获取 HTTP 请求参数的注解，常用于控制器方法的参数列表中。它可以将 HTTP 请求中的参数绑定到方法中的参数上，以便在控制器方法中使用。
@RequestMapping 注解中的 value 属性指定了映射的请求地址，例如：
@RequestMapping(value = "/user") public String getUser(@RequestParam("id") int id, Model model) { // ...业务逻辑... return "user"; } 该方法映射的请求路径是 /user，并且使用了一个 @RequestParam 注解，用于获取 HTTP 请求中名为 id 的参数，并将其绑定到方法中的 id 参数上。如果在请求路径中没有指定 id 参数或者参数的值无法转换为 int 类型，会抛出异常。
除了 value，@RequestParam 还支持其他的属性，例如：
required：是否必须存在该参数，默认为 true。defaultValue：参数的默认值，当没有该参数时使用。 在Spring中，如果请求参数是一个集合类型（如List、Set等），Spring默认是不会将请求参数值直接赋给集合对象的。相反，Spring会尝试将请求参数值封装到一个新的对象中，然后将该对象作为方法的参数传递。
对于集合类型，必须使用@RequestParam注解显式指定请求参数名，不使用@RequestParam的情况下，List&lt;Integer&gt; ids会直接报错，ArrayList&lt;Integer&gt; ids不会报错，但是没有值： 当你尝试用List&lt;Integer&gt; ids去接收请求参数并且没有使用@RequestParam注解时，Spring框架会出现错误。这是因为List是一个接口，不是一个具体的类，它没有默认的构造器，不能被直接实例化。
当Spring反射机制试图实例化一个List&lt;Integer&gt;对象以便将请求参数绑定到它时，由于是接口并无法实例化，所以就会抛出一个错误。
而对于ArrayList&lt;Integer&gt; ids，Spring反射可以调用ArrayList的默认无参构造函数创建一个的新实例，所以它不会报错。
要解决这个问题，你应该使用@RequestParam注解来明确请求参数的名称，如下所示：
@GetMapping("/example") public void example(@RequestParam("ids") List&lt;String&gt; idStrings) { List&lt;Integer&gt; ids = idStrings.stream() .map(Integer::parseInt) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d76d9a3c3bba12afcfe548b9b9445d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df162ceee7db9c94386605d79cdba948/" rel="bookmark">
			【LLM】基于LLM的agent应用（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		note 在未来，Agent 还会具备更多的可扩展的空间。 就 Observation 而言，Agent 可以从通过文本输入来观察来理解世界到听觉和视觉的集成；就 Action 而言，Agent 在具身智能的应用场景下，对各种器械进行驱动和操作。 Agent 是以核心智能模型来驱动的，一个可以具备能力从思考开始，最终做到完整输出的智能性结构。Agent 的发展很符合第一性原理，从最先的 Prompt，后面有人在写完的 Prompt 后面加通用的规划器。 文章目录 note零、相关概念介绍一、人类与AI协同的三种模式二、Generative Agents三、一篇agent综述四、微软的AutoGen 框架五、agent和function call六、chatglm3-6b的agent应用1. chatglm3的特点2. ChatGLM3 对话格式（1）规定整体结构对话头 （2）样例场景多轮对话工具调用代码执行 附：体系Reference 零、相关概念介绍 【狭义】openai定义的agent：Lilian Weng研究员指出agent应具有技能调用（Tool use）、记忆（Memory）和规划（Planning）能力 推荐阅读：Marvin Minsky 的两本著作：《心智社会》和《情感机器》。Lilian Weng 文章：https://lilianweng.github.io/posts/2023-06-23-agent 【广义】agent：以下几种能力：Agent 的基础能力，包括常识推理、逻辑性等，来源于大模型提供的基础智能。所以我们对 Agent 这一层能力的设计，本质上都是对模型的优化。如果要改进 Agent 在这一方面的能力，通常需要更换或优化底层模型。Agent 的角色扮演、情感理解和身份相关能力，与其记忆和拟人化角色设定的 Prompt 工程紧密相关。这部分称为“角色管理”，涉及到如何让 Agent 理解并扮演特定的角色或身份。Agent 的技能调用能力，如编程、查询、绘图等，依赖于 Agent 之上的插件。OpenAI 的“Function calling”机制是一个经典的实现方 式，允许 Agent 调用外部的功能和资源。Agent 的复杂思维能力，在基础智能之上，大模型通过人们构建的思维链、思维树等方式，学会更高层的思维方式。这种方法教会模型特定的模式或思维方式，从而提高其处理复杂问题的能力。 COT（Chain of Thoughts）：思维链，一种模拟人类逻辑和推理过程的推理框架，能够帮助大语言模型解决复杂的算术、常识及字符推理等任务。TOT（Tree of Thoughts）：思维树，一种模拟人类逻辑和推理过程的推理框架，允许语言模型通过考虑多种不同的推理路径和自我评估选择来进行深思熟虑的决策，以及在必要时向前看或回溯以做出全局选择。Autonomy Agent：理想状态下能够在没有外部干预的情况下自主作出决策和执行任务的AI系统。Multi-Agent：多个AI代理共同工作，相互协作或竞争以完成复杂任务的系统。RAG：检索增强生成（Retrieval Augmented Generation），通过在生成响应之前从知识源检索相关信息来增强LLM的能力，适合需要查询数据库、文档或其他结构化/非结构化数据存储库的应用程序。 一、人类与AI协同的三种模式 二、Generative Agents 《Generative Agents: Interactive Simulacra of Human Behavior》
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df162ceee7db9c94386605d79cdba948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e31d54ca4d73c9fde32c6c8c09abb041/" rel="bookmark">
			LangChain 3使用Agent访问Wikipedia和llm-math计算狗的平均年龄
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接着前两节的Langchain，继续实现Langchain中的Agent
LangChain 实现给动物取名字，LangChain 2模块化prompt template并用streamlit生成网站 实现给动物取名字 代码实现
# 从langchain库中导入模块 from langchain.llms import OpenAI # 从langchain.llms导入OpenAI模块 from langchain.prompts import PromptTemplate # 从langchain.prompts导入PromptTemplate模块 from langchain.chains import LLMChain # 从langchain.chains导入LLMChain模块 from dotenv import load_dotenv # 从dotenv导入load_dotenv，用于加载环境变量 from langchain.agents import load_tools # 从langchain.agents导入load_tools函数 from langchain.agents import initialize_agent # 从langchain.agents导入initialize_agent函数 from langchain.agents import AgentType # 从langchain.agents导入AgentType枚举类 from langchain.tools import WikipediaQueryRun # 从langchain.tools导入WikipediaQueryRun from langchain.utilities import WikipediaAPIWrapper # 从langchain.utilities导入WikipediaAPIWrapper load_dotenv() # 加载.env文件中的环境变量 def langchain_agent(): llm = OpenAI(temperature=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e31d54ca4d73c9fde32c6c8c09abb041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eaa800b25285bbceb7b1b5566348217/" rel="bookmark">
			mysql数据库cpu异常排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行这些排查过程时，最好是逐步进行，从整体到细节，从常见问题到特殊情况。结合具体的业务场景和数据库配置，找到可能引起 CPU 异常的原因。
监控系统： 使用监控系统（如Prometheus、Grafana、Nagios等）观察 CPU 使用率的波动。检查是否有明显的峰值或异常。
数据库状态： 使用 MySQL 自带的性能工具或其他数据库监控工具，查看数据库的整体状态，包括连接数、查询数、慢查询等。
慢查询分析： 使用 MySQL 的慢查询日志（slow query log）来查看是否有执行时间较长的 SQL 查询。通过慢查询日志可以定位具体的慢查询语句，从而优化它们。
索引优化： 检查数据库表的索引是否合理。缺少或者不恰当的索引可能导致全表扫描，增加 CPU 开销。使用 EXPLAIN 语句来分析查询执行计划。
EXPLAIN SELECT * FROM your_table WHERE your_condition; 缓存命中率： 检查数据库的缓存命中率，包括查询缓存（如果启用了）、InnoDB Buffer Pool（如果使用了 InnoDB 存储引擎）等。低缓存命中率可能导致频繁的磁盘 I/O，增加 CPU 负载。
IO 状态： 检查磁盘 IO 的状态，包括读写速度、IOPS 等。磁盘IO异常可能会导致 CPU 过高。
数据库连接池： 检查数据库连接池的状态。过多的数据库连接可能导致 CPU 资源被消耗。合理配置连接池参数，防止连接泄漏。
MySQL 锁： 检查是否有锁导致 CPU 高。长时间的锁等待可能阻塞其他查询，导致 CPU 使用率上升。
查询日志： 在数据库中查看是否有异常的错误日志，特别是与 CPU 相关的错误。MySQL 的错误日志通常位于 MySQL 的日志文件中。
版本升级： 检查 MySQL 数据库的版本，是否存在已知的性能问题。有时候升级到最新版本或合适的稳定版本可以解决一些问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eaa800b25285bbceb7b1b5566348217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8ddac4d5bbd1f79b9b9e805368d03a/" rel="bookmark">
			python中列表的基础解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表：
一种可以存放多种类型数据的数据结构
列表的创建：
1.用【】创建列表
#创建一个空列表 list1=[] #创建一个非空列表 list2 = ['zhang','li','ying',1,2,3] #输出内容及类型 print(list1,type(list1)) print(list2,type(list2)) 结果：
2.使用list（）函数创建
#使用list（）函数创建列表 a=list((1,2,3,4,'num')) print(a,type(a)) 运行结果：
注：在python中我们可以使用list（）函数将字符串，元组，字典和集合等其他类似对象转换为列表。
访问列表：
1.索引访问：
可以通过print（list1【0】）来访问第一个元素，依次类推
如果索引为-1则代表访问的是最后一个元素。
2.切片访问：
使用切片访问的列表格式：
list【star：end：step】
star表示开始索引，end表示结束索引，step表示步长（默认值为1）。
更改列表值：
可以通过索引直接更改。如list【0】=XXX
列表的连接/复制：
1.连接：有两个列表list1和list2可以直接print（list1+list2）直接将两列表相加。
2.复制：list1=【‘hello’】可以直接print（list1*5）输出复制有五个hello的列表
检查项目是否存在：
print（‘app’in list1）可查询列表中是否存在元素‘app’如果有则返回True
当然列表中也有很多其他的操作和内置函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d3ec3487b398d4f73862a158e4d1c7/" rel="bookmark">
			【S029】FPGA动态重配置ICAPE2以及双引导功能实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UG470配置接口类型 Master-Serial configuration mode Slave-Serial configuration mode
Master SelectMAP (parallel) configuration mode (x8 and x16)
Slave SelectMAP (parallel) configuration mode (x8, x16, and x32)
JTAG/boundary-scan configuration mode
Master Serial Peripheral Interface (SPI) flash configuration mode (x1, x2, x4)
Master Byte Peripheral Interface (BPI) flash configuration mode (x8 and x16) using parallel NOR flash
串行主|从的配置时序图 FPGA主 SPI配置时序 Configuration Mode M[2:0] Bus Width CCLK Direction
Master Serial 000 x1 Output
Master SPI 001 x1, x2, x4 Output
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58d3ec3487b398d4f73862a158e4d1c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b8817863e2bff2babb21657c7d5723/" rel="bookmark">
			新版mmdetection3d将3D bbox绘制到图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境信息 使用 python mmdet3d/utils/collect_env.py收集环境信息
sys.platform: linux Python: 3.7.12 | packaged by conda-forge | (default, Oct 26 2021, 06:08:21) [GCC 9.4.0] CUDA available: True numpy_random_seed: 2147483648 GPU 0,1: NVIDIA GeForce RTX 3090 CUDA_HOME: /usr/local/cuda NVCC: Cuda compilation tools, release 11.3, V11.3.109 GCC: gcc (Ubuntu 7.5.0-6ubuntu2) 7.5.0 PyTorch: 1.8.1+cu111 PyTorch compiling details: PyTorch built with: - GCC 7.3 - C++ Version: 201402 - Intel(R) Math Kernel Library Version 2020.0.0 Product Build 20191122 for Intel(R) 64 architecture applications - Intel(R) MKL-DNN v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b8817863e2bff2babb21657c7d5723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae28844b5fa4d279ae411d06a287d34/" rel="bookmark">
			Linux——定时清空日志内容和删除日志文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在做性能压测试，会生成大量的日志，导致后续越压越慢，最终磁盘空间占满之类的问题。老是要手动删除日志文件，为避免此类问题发生，编写一个Linux日志定时清理的脚本，一劳永逸。
1、shell脚本 创建脚本并赋权 touch /home/mppay/auto-truncate-log.sh chmod u+x auto-truncate-log.sh 编辑脚本 vi auto-truncate-log.sh 【清空日志文件内容】脚本如下：
#!/bin/sh #可填写多个路径 workdir=("/home/mppay/apache-tomcat-7.0.73/logs" "/home/mppay/logs") for wdir in ${workdir[@]}; do echo -e "filepath is ${wdir}" # .log 文件和包含 log 标记的 .txt文件，以及 catalina.out 文件 find $wdir -regex "^.*\(\.log\|log.*\.txt\|catalina.out\)$" -type f -print -exec truncate -s 0 {} \; if [ $? -eq 0 ]; then echo -e `date`" truncate logs successfully! \n" else echo -e `date`" truncate logs failed! \n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ae28844b5fa4d279ae411d06a287d34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1d3e23570a8e6cec03301ca2ef4195/" rel="bookmark">
			小美的排列构造
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 美团2024届秋招笔试第一场编程真题
贪心问题，得到所有n全排列中相邻两数的和，这些和差距要尽可能小。
显然如果1和2排一起，或者让n和n-1相邻都是错误的。最好的方式是让相邻两数的和接近（n+1）/2。
比如:n 1 n-1 2............. (n+1)/2
#include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; int main() { ios::sync_with_stdio(0),cin.tie(0); int i,j,n; cin&gt;&gt;n; int a=n,b=1; for(i=1;i&lt;=n/2;i++) cout&lt;&lt;a--&lt;&lt;' '&lt;&lt;b++&lt;&lt;' '; if(n%2==1) cout&lt;&lt;a; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d80750355f4dda8c4a8c7dbd22d6442e/" rel="bookmark">
			小美的树上染色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		美团2024届秋招笔试第一场编程真题
先提一个小知识：题目中凡是提到树结构都要使用图的存储方式，只有二叉树例外。
分析：在树结构中，孩子和父节点是相邻节点，而父节点可能有多个孩子节点。在染色的过程中，本质是父子节点满足条件就染成红色。具体染色策略以下图为例
图中节点权值均为1，也就是任意相邻节点都可以满足染色条件，显然我们不能先将a和b染色，那样就只有2个点能被染色，而是应该先染色&lt;f,b&gt;或 &lt;e,b&gt;，然后再&lt;a,c&gt; 或&lt;a,d&gt;，这样可以染4个点。下图又该先考虑染色那些节点呢？
这样总结出贪心策略：先处理叶子结点的染色，然后处理内部节点。比如上图，先处理&lt;g,f&gt;。如果能染色，哪么将g,f标记红色，同时&lt;f,b&gt;就不可能染色了如果不能染色，未来还可以继续试探&lt;f,b&gt;。
实现方法：先处理最外层节点（叶子），外层处理完了，这些叶子就可以不要了，往内层推进。
使用拓扑排序的思想。当然不是入度0节点入队，这可不是有向图。而是度为1（叶子）节点入队，从树叶向树根进行拓扑处理。
图问题的复杂度正常都是遍历所有的结点，也就是访问所有的点和边，此图n-1条边，复杂度为O(n)。
#include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; ll n,a[100005],d[100005],red[100005],v[100005],ans=0; vector &lt;int&gt; e[100005]; bool isP(ll x)/**&lt; 平方数判定 */ { ll y=(int)sqrt(x); return y*y==x; } int main() { ios::sync_with_stdio(0),cin.tie(0); int i,j,x,y; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(i=1;i&lt;n;i++) { cin&gt;&gt;x&gt;&gt;y; e[x].push_back(y),e[y].push_back(x); d[x]++,d[y]++;/**&lt; d数组统计度 */ } queue&lt;int&gt;q; for(i=1;i&lt;=n;i++) if(d[i]==1)/**&lt; 度为1的入队*/ q.push(i); while(q.size())/**&lt; 模拟拓扑排序处理方法 */ { x=q.front(); v[x]=1;/**&lt; 标记这个节点，避免重新被入队处理 */ q.pop(); for(i=0;i&lt;e[x].size();i++)/**&lt; 找到x所有邻接点 */ { y=e[x][i]; if(v[y]) /**&lt; y已经访问过，其实y一定是x的子节点 */ continue; if(red[x]==0&amp;&amp;red[y]==0&amp;&amp;isP(a[x]*a[y]))/**&lt; x和它父节点y满足条件 */ red[x]=red[y]=1,ans+=2;/**&lt; 标记颜色，计数器+2 */ d[y]--; if(d[y]==1)/**&lt; 度为1说明y子节点都处理完了，此时可以入队 */ q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d80750355f4dda8c4a8c7dbd22d6442e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8804510ae36f62f5f85e29f67de2ba1/" rel="bookmark">
			如何使用websocket&#43;node.js实现pc后台与小程序端实时通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何使用websocket+node.js实现pc后台与小程序端实时通信 一、使用node.js创建一个服务器二、pc后台连接ws三、小程序端连接ws四、实现效果 实现功能:实现pc后台与小程序端互发通信能够实时检测到
一、使用node.js创建一个服务器 1.安装ws依赖 npm i ws 2.创建index.js const WebSocket = require('ws') const wss = new WebSocket.Server({ port: 8888 }) const wsList = {} console.log('服务器启动') wss.on('connection', (ws) =&gt; { ws.on('message', (message) =&gt; { const result = JSON.parse(message) console.log('接收到的结果', result) // 页面初始化的时候，使用wsList将ws进行缓存 if (result.message === 'init') { wsList[result.name] = ws } else { // 根据name的值来给指定的客户端发送信息 const ws = wsList[result.name] ws.send(result.message) } }) ws.on('close', () =&gt; { Object.keys(wsList).forEach((item) =&gt; { // 当websoket关闭的时候，要清空对应的ws if (wsList[item].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8804510ae36f62f5f85e29f67de2ba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547c64084f7249a62e9da98ab53c583e/" rel="bookmark">
			前端-relation-graph实现关系数据展示（关系图/流程图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言：
1. relation-graph
2. relation-graph数据关系组件---官方地址relation-graph - A Relationship Graph Componenthttps://www.relation-graph.com/
3. 选择relation-graph的理由
4. 项目中引用relation-graph
4.1 下载命令
4.2 在Vue 2 中使用
4.3 在Vue 3 中使用
4.4 在React中使用
5. 简单的实例代码
6. 参考文献
前言： 今天公司同事的项目新需求需要实现数据关系展示，我在CSDN上找的了答案，并分享给大家。具体在哪位大佬分享，我会在文章末尾引用标注给出链接。
话不多说，接下来介绍这个为我们开发人员提供的关系数据组件。
1. relation-graph relation-graph官方是这么介绍它的：relation-graph是支持Vue2、Vue3、React的关系数据展示组件，支持通过【插槽】让使用者使用"普通HTML元素、Vue组件、React组件"来完全自定义图形元素，并提供实用的API接口让使用者轻松构建可交互的图形应用。 2. relation-graph数据关系组件---官方地址 relation-graph - A Relationship Graph Componenthttps://www.relation-graph.com/
3. 选择relation-graph的理由 主要是免费、免费、免费支持Vue2、Vue3、React完全自定义，可随意定制样式和ECharts图表同样用的json、对象的格式来自定义配置 4. 项目中引用relation-graph 4.1 下载命令 ## npm 下载
npm install --save relation-graph
## yarn 下载
yarn add relation-graph
4.2 在Vue 2 中使用 relation-graph也支持在main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/547c64084f7249a62e9da98ab53c583e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dffc7d4405d9ffb503ec18fc3dd4483b/" rel="bookmark">
			SpringBoot实现图片识别文字的四种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot实现图片识别文字 文末含有案例地址哦！！！
SpringBoot 整合 Tess4J 实现 Tesseract是一个开源的光学字符识别（OCR）引擎，它可以将图像中的文字转换为计算机可读的文本。支持多种语言和书面语言，并且可以在命令行中执行。它是一个流行的开源OCR工具，可以在许多不同的操作系统上运行。
Tess4J是一个基于Tesseract OCR引擎的Java接口，可以用来识别图像中的文本，说白了，就是封装了它的API，让Java可以直接调用。
1、引入tess4j依赖 &lt;!-- tess4j --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.tess4j&lt;/groupId&gt; &lt;artifactId&gt;tess4j&lt;/artifactId&gt; &lt;version&gt;4.5.4&lt;/version&gt; &lt;/dependency&gt; 2、yml配置 把训练数据的目录路径配置在yml里，后续可以扩展到配置中心。
server: port: 8888 # 训练数据文件夹的路径 tess4j: datapath: E:/gitee/OCR/tess4j_data Tesseract OCR库通过训练数据来学习不同语言和字体的特征，以便更好地识别图片中的文字。
在安装Tesseract OCR库时，通常会生成一个包含多个子文件夹的训练数据文件夹，其中每个子文件夹都包含了特定语言或字体的训练数据。
比如我这里是下载后放到了D盘的tessdata目录下，如图所示，其实就是一个.traineddata为后缀的文件，大小约2M多。
训练数据，官方下载地址：https://digi.bib.uni-mannheim.de/tesseract/
GitHub官网地址：https://github.com/tesseract-o
3、编写配置类 @Configuration public class TesseractOcrConfig { @Value("${tess4j.dataPath}") private String dataPath; @Bean public Tesseract tesseract() { Tesseract tesseract = new Tesseract(); // 设置训练数据文件夹路径 tesseract.setDatapath(dataPath); // 设置为中文简体 tesseract.setLanguage("chi_sim"); return tesseract; } } 4、编写业务实现类 @Service public class OcrServiceImpl implements OcrService { private final Tesseract tesseract; public OcrServiceImpl(Tesseract tesseract) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dffc7d4405d9ffb503ec18fc3dd4483b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb1264af90c8fbddff2b05e06ae9d7b/" rel="bookmark">
			VSCode安装，配置，编译运行C&#43;&#43;（详细整理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 配置 C++ 编译器
首先需要安装 C++ 编译器。在 Windows 上，可以安装 MinGW 或者 Visual Studio；在 MacOS 上，可以安装 Clang 或者 Xcode；在 Linux 上，可以安装 GCC。
作者将以 Windows 的 MinGW 为例：
1.1 下载 MinGW
官方下载：https://www.mingw-w64.org/downloads/
sourceforge下载：https://sourceforge.net/projects/mingw-w64/files/
（1）进入 sourceforge 网页，点击 x86_64-win32-seh 进行下载：
注意：
如果因网速等原因下载较慢，可点击链接并输入密码直接获取：https://luguoliang.lanzouk.com/iN7OB0yrr12h 密码:liang
（2）解压该压缩包（x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z），解压之后会出现一个 mingw64 文件夹：
1.2 添加环境变量
win + i 调出系统设置，在查找设置中输入环境变量，点击编辑账户的环境变量，将 mingw64 下的 bin 路径（作者为 D:\Software\mingw64\bin）添加至用户变量：
注意： 添加完环境变量后，务必重启电脑。
1.3 测试
win + R 输入 cmd 打开 CMD 命令窗口，输入以下指令即可验证 MinGW 是否配置成功：
gcc -v
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb1264af90c8fbddff2b05e06ae9d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35b36ca966ae00d2e5b4fb961dac8ef/" rel="bookmark">
			腾讯云轻量应用服务器流量用完还能用吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云轻量服务器作为一种灵活且高性能的云服务器，备受业界赞誉。与传统的云服务器相比，轻量服务器不仅能够提供完善的功能，还具备出色的性价比。其中，最为引人注目的特点之一就是其流量包的使用方式。在本文中，我们将带您深入了解腾讯云轻量服务器的流量包使用规则和超出流量的计费方式。
腾讯云双十一领9999代金券 https://1111.mian100.cn
腾讯云新用户领2860代金券 https://xinke.mian100.cn
腾讯云3年时长、5年时长优惠服务器尽享新用户优惠 https://5nian.mian100.cn
什么是流量包？ 在了解流量包的使用规则之前，让我们先来了解一下什么是流量包。简单来说，流量包是腾讯云轻量服务器专门为用户提供的一种优惠服务。购买流量包后，用户将获得一定额度的流量，用于轻量服务器的互联网流量消耗。
流量包的使用规则 腾讯云轻量服务器的流量包使用规则非常简单易懂。用户购买流量包后，可以在一定时间范围内使用其中的流量。在正常情况下，用户使用轻量服务器的流量包往往足够，并且不会用完。这是因为腾讯云轻量服务器的流量包额度相对较大，能够满足大多数用户的需求。
超出流量包的计费方式 然而，如果用户在流量包用完后仍继续使用轻量服务器并产生额外的流量消耗，腾讯云将根据超出的流量量进行额外计费。这种计费方式能够保证用户在用完流量包后仍然能够持续使用轻量服务器，并且只需支付实际超出流量部分的费用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb34c80ee12e9b17750e320fb97da0eb/" rel="bookmark">
			腾讯云服务器怎么买便宜？腾讯云服务器购买优惠活动入口汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优惠政策的利用 想要购买最划算的腾讯云服务器，第一步就是关注腾讯云的官方网站和社交媒体账号。腾讯云经常发布最新的优惠政策，比如打折活动、限时优惠等，及时了解这些信息能够帮助我们以更低的价格购买到服务器。
腾讯云双十一领9999代金券 https://1111.mian100.cn
腾讯云新用户领2860代金券 https://xinke.mian100.cn
腾讯云3年时长、5年时长优惠服务器尽享新用户优惠 https://5nian.mian100.cn
选择合适的配置 在购买服务器时，我们需要根据实际需求选择合适的配置。腾讯云提供了多种服务器类型，包括通用型、存储型、GPU型等，我们需要根据自己的业务需求来选择。同时，还需要考虑网络带宽和存储容量，权衡价格和性能，选择最适合自己需求的配置。
腾讯云88元/年服务器配置查看 https://tengxun.mian100.cn
参加官方活动 腾讯云经常举办各种活动和竞赛，我们可以积极参与这些活动，有可能获得免费服务器时长、折扣券等福利，从而节省购买费用。除了官方活动，我们也可以关注各种社区、论坛，了解更多的福利和优惠信息。
比较不同产品 在购买前，我们应该对不同的产品进行比较。腾讯云提供了多种类型的服务器，每种产品有不同的配置、性能和价格。我们可以通过对比不同产品的优缺点，找到最适合自己需求的服务器产品。此外，我们还可以和其他云计算服务提供商的产品进行比较，选择最优的方案。
合理使用资源 购买服务器之后，我们需要合理使用资源，以充分发挥服务器的性能和效率。首先，根据业务需求合理分配CPU、内存和存储等资源，避免资源的浪费。其次，我们可以通过优化系统、安装必要的软件和插件，提高服务器的性能和效率。合理使用资源不仅能够提升服务器的运行效果，还能够有效降低成本。
通过以上几个方面的考虑和操作，我们可以购买到最划算的腾讯云服务器。利用优惠政策、选择合适的配置、参加官方活动、比较不同产品并合理使用资源，都是购买服务器时需要注意的要点。希望这些经验能够帮助到大家，在购买腾讯云服务器时做出明智的决策。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a9303396e6f7b1d6dec87c0a8d593f/" rel="bookmark">
			腾讯云服务器怎么买便宜一点？腾讯云服务器优惠购买流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年的双十一将再次席卷互联网，腾讯云也将推出一系列大促活动。如果你正考虑购买云服务器，那么这次的双十一活动将是一个绝佳的机会。在活动中，购买云服务器更划算的方式有很多，我们来一一解析。
腾讯云双十一领9999代金券 https://1111.mian100.cn
腾讯云新用户领2860代金券 https://xinke.mian100.cn
腾讯云3年时长、5年时长优惠服务器尽享新用户优惠 https://5nian.mian100.cn
领取代金券，降低购买成本 腾讯云在双十一大促活动中提供了代金券，可以在购买云服务器时使用，抵扣订单金额，降低购买成本。领取代金券非常简单，只需要参考腾讯云官网的活动页面或代金券发放渠道的相关说明，按需领取即可。
选择3年、5年的服务器配置，充分享受多年优惠 在购买云服务器时，根据自己的需求选择合适的服务器配置是非常重要的。腾讯云为新用户提供了多种优惠套餐，比如购买3年的腾讯云2核2G3M云服务器（540元/3年）或腾讯云2核4G5M云服务器（756元/3年），以享受新人优惠。对于需要满足大部分线上应用需求并且不希望续费费用过高的用户，可以选择购买5年的腾讯云4核8G云服务器（6490.44元/5年），以获得长期性价比更高的优势。
关注活动页面和社交媒体，获取更多优惠 最后，要及时关注腾讯云双十一活动页面和腾讯云的社交媒体账号，获取更多优惠信息和优惠券领取方式。在活动期间，腾讯云会不定期发布各种优惠活动和限时优惠，通过关注官方渠道，你可以第一时间获取到这些信息，以便做出更明智的购买决策。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/42/">«</a>
	<span class="pagination__item pagination__item--current">43/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/44/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>