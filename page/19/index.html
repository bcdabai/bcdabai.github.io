<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3486696f3d291b826d1a300c8515d599/" rel="bookmark">
			云计算任务调度仿真04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次分享一篇更加高级的云计算任务调度的文章和代码，
基于A3C学习和残差回归神经网络的随机边缘云计算环境动态调度 网络结构
结果
代码示例
这是基于pytorch实现的，所以复现起来没有什么难度，但是可以看到这有六层网络，而且使用了卷积神经网络和LSTM处理，数据量也较大，所以需要使用GPU来学习，看我这个在笔记本上已经学了几个小时了，还是在学习中没有结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b25e9b5f3edf575dffa52c053c846b1/" rel="bookmark">
			一篇自我介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是一名新手程序员，热爱编程和技术探索。目前就读于哈尔滨工业大学，机械工程方向，我对计算机科学和软件开发充满了浓厚的兴趣，决心通过不断学习和实践来提升自己。
我的编程目标是成为一名全栈开发者，能够熟练掌握多种编程语言和技术栈。我希望能够参与并贡献于有意义的项目，不断提升自己的编程能力，并在技术领域取得更多的成就。
我打算通过多种途径学习编程，包括阅读经典的编程书籍、参与在线课程、观看教学视频以及实际项目的实践。我计划构建自己的学习计划，并利用在线社区和论坛与其他程序员进行交流，从他们的经验中学到更多。
我计划每周至少投入20H的学习时间，以确保足够的学习和实践。这将包括阅读相关文献、完成编程练习、参与在线课程以及实际项目的开发。
目前，我最向往的IT公司是腾讯。我被他们在创新和技术领域的卓越表现所吸引，希望能够在这样一个充满活力和机会的环境中不断挑战自己，取得职业上的成功。我计划通过不断学习和积累经验，为将来能够成为这家公司的一员而努力奋斗。
该文为查老师帮忙写的作业，仅代表查老师的个人意见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f7fecff0cdeadb74c218c0f97f4cf2f/" rel="bookmark">
			一键完成爬虫之Cookie获取：利用浏览器模拟一个cookie出来、面对反爬虫、加密的cookie的应对方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一键完成爬虫之Cookie获取：利用浏览器模拟一个cookie出来、面对反爬虫、加密的cookie的应对方法 本文提供一个快速取得cookie的办法，用来应对一些网站的的反爬虫和cookie失效等情况本接口是收费的（1分钱1次调用，不愿付费自行折腾的跳转链接查看，也可联系微信xujian_cq考虑包年包月使用）考虑到服务器资源成本，此简单版本需要付费，还请理解请求必要的code可以通过搜索小程序“数字续坚”，在首页签到后取得接口内容不包含敏感信息，如有侵权，请联系作者删除。 1 接口功能 提交一个网站地址（或验证码地址），程序在浏览器中打开并提取cookie给你 2 接口用法 2.1 重要参数 入参 序号项目值说明1接口地址https://www.xujian.tech/atlapi/data/m/cookie/build2请求方式POST3请求参数1code用来识别用的code，在微信小程序“数字续坚”首页签到取得，不会变化4请求参数2url需要获取的网站的地址 - 重要说明：code不可变更，请注意保密
出参标准格式 序号项目值说明1返回值格式JSONObject含code、data、msg2返回值1code200为成功，其他表示失败3返回值2msg成功(succeed.)、失败的文字描述4返回值3dataJSONObject结果，包含cookie 2.2 返回值 序号参数名类型说明1cookieString即cookie 2.3 请求示例 # 下方地址中的code请到数字续坚小程序首页签到获取，不会变化，注意保密 post https://www.xujian.tech/atlapi/data/m/cookie/build?code=${YourCodeForm数字续坚小程序} 如下图
2.4 返回示例 { "code": 200, "msg": "succeed.", "data": { "cookie": "BIDUPSID=E662A52EADCD066FE4AD81F630A7EF69;BA_HECTOR=2t8ha08g0laha1c0248k250kagre9t1iqclio1t;BAIDUID_BFESS=E662A52EADCD066F5E7CCA4F9346C70C:FG=1;PSTM=1705399895;ZFY=Ak07fDZhOq25gJjmG:AcFspd4i2znS6h1gGIEEeAexv0:C;BD_UPN=12314753;BAIDUID=E662A52EADCD066F5E7CCA4F9346C70C:FG=1;" } } 3 收费方式 收费，1分钱1次考虑到服务器资源成本，此简单版本需要付费，还请理解本接口是收费的（1分钱1次调用，不愿付费自行折腾的跳转链接查看，也可联系微信xujian_cq考虑包年包月使用） 4 消费查询 完全免费，无需查询打开网站，登录后在“API服务-爬虫cookie”中可查看调用情况也可以在上方网站发现更多有趣的事情 // 地址 https://www.xujian.tech/monitor 更多API服务正在更新 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593162dba8a426a2ab2121da0be1bb46/" rel="bookmark">
			IP定位API接口：省、市、城市的adcode编码、所在城市矩形区域范围（VIP版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IP定位API接口：省、市、城市的名称和adcode编码、所在城市矩形区域范围 本文提供一个IP定位查询接口：省、市、城市的名称adcode编码，并返回一个参考坐标本接口是收费的（1分钱1次调用，免费的跳转链接查看，也可联系微信xujian_cq考虑包年包月使用）请求必要的code可以通过搜索小程序“数字续坚”，在首页签到后取得接口内容不包含敏感信息，如有侵权，请联系作者删除。 1 接口功能 根据提交的IP，返回省、市、城市的名称adcode编码，并返回一个参考坐标。 2 接口用法 2.1 重要参数 入参 序号项目值说明1接口地址https://www.xujian.tech/atlapi/data/m/query/ipLocation/vip2请求方式GET3请求参数1code用来识别用的code，在微信小程序“数字续坚”首页签到取得，不会变化4请求参数2ip即需要查询位置的ipv4 地址ipv4 - 重要说明：code不可变更，请注意保密
出参标准格式 序号项目值说明1返回值格式JSONObject含code、data、msg2返回值1code200为成功，其他表示失败3返回值2msg成功(succeed.)、失败的文字描述4返回值3dataJSONObject结果，包含定位信息内容 2.2 返回值 序号参数名类型说明1adInfo.provinceString省份（或直辖市）名称2adInfo.cityString城市名称名称3adInfo.cityString城市名称名称4adInfo.districtString区/县名称5location.latDouble纬度6location.lngDouble经度 2.3 请求示例 # 下方地址中的code请到数字续坚小程序首页签到获取，不会变化，注意保密 curl https://www.xujian.tech/atlapi/data/m/query/ipLocation/vip?ip=219.152.38.5&amp;code=${YourCodeForm数字续坚小程序} 2.4 返回示例 { "code": 200, "msg": "succeed.", "data": { "location": { "lat": 23.12901, "lng": 113.2668 }, "adInfo": { "nation": "中国", "province": "广东省", "city": "广州市", "district": "越秀区", "adcode": 440104, "nation_code": 156 } } } 3 收费方式 收费，1分钱1次本接口是收费的（1分钱1次调用，免费的跳转链接查看，也可联系微信xujian_cq考虑包年包月使用） 4 消费查询 完全免费，无需查询打开网站，登录后在“API服务-IP定位（VIP）”中可查看调用情况也可以在上方网站发现更多有趣的事情 // 地址 https://www.xujian.tech/monitor 更多API服务正在更新 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6bf85d874c5183172e40f8d902e392/" rel="bookmark">
			npm install的时候报错ERROR: Failed to set up Chromium r901912! Set “PUPPETEER_SKIP_DOWNLOAD“ env variabl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因是npm安装puppeteer的时候,默认会下载Chromium浏览器。但是由于某些原因,这个下载失败了。
有几种解决方法:
使用现成的Chromium浏览器，这将使用你系统已安装的浏览器,而不再下载Chromium npm install puppeteer --unsafe-perm=true --allow-root 设置环境变量跳过Chromium下载 // 方式一：在npm命令前面加上这个环境变量 PUPPETEER_SKIP_DOWNLOAD=true npm install // 方式二：先设置环境变量（直接终端里运行），再npm install # Windows set PUPPETEER_SKIP_DOWNLOAD='true' #Mac export PUPPETEER_SKIP_DOWNLOAD='true' npm install puppeteer 设置 --ignore-scripts （我没试过） npm install --ignore-scripts puppeteer 更换npm源
有时候是因为npm源的问题,网络不太稳定,可以试试切换到其他源。
用yarn代替npm
科学上网
如果由于网络原因,可以考虑使用科学上网工具,提高下载成功率。
手动下载
从Github上下载Chromium放到特定目录,然后设置环境变量指定这个目录,跳过在线下载。
主要是网络原因导致Chromium下载失败。以上方法可以尝试解决这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe2ffb6ad35cc29c8f867e09105254d/" rel="bookmark">
			C&#43;&#43; 类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 静态类型转换 static_cast 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
1
2
动态类型转换 dynamic_cast 主要用于层次间的上行转换和下行转换
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全；
1
2
常量转换 const_cast 常量指针被转化成非常量指针，并且仍然指向原来的对象；
常量引用被转换成非常量引用，并且仍然指向原来的对象；
//常量指针转换成非常量指针 void test01(){ const int* p = NULL; int* np = const_cast&lt;int*&gt;(p); int* pp = NULL; const int* npp = const_cast&lt;const int*&gt;(pp); const int a = 10; //不能对非指针或非引用进行转换 //int b = const_cast&lt;int&gt;(a); } //常量引用转换成非常量引用 void test02(){ int num = 10; int &amp; refNum = num; const int&amp; refNum2 = const_cast&lt;const int&amp;&gt;(refNum); } 重新解释转换 reinterpret_cast 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ccb7d9698b45776566691bc8efedcb6/" rel="bookmark">
			安全狗连续3年获得中国网络空间安全协会感谢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在2024年的新年伊始，安全狗依托在2023年期间协助中国网络空间安全协会完成《网络安全态势感知研判分析报告》并支持相关网络安全态势研判工作而获得感谢信。
厦门服云信息科技有限公司（品牌名：安全狗）创办于2013年，是国内领先的云安全服务和解决方案提供商。自成立以来，安全狗致力于提供云安全、（云）数据安全领域相关产品、服务及解决方案。作为国内云工作负载安全（CWPP）领域开拓者、云主机安全SaaS产品的开创者，安全狗依托云工作负载安全、云原生安全（CNAPP）、数据安全治理等技术理念，打造了云安全、安全大数据、数据安全等多条产品线，覆盖了网络安全行业的多个前沿领域，满足不同用户的多种安全需求。
2023年，安全狗正式加入中国网络安全软件领域领跑者亚信安全科技股份有限公司(股票代码: 688225) ，成为其控股子公司。双方的深度融合，实现了云安全技术能力的全面覆盖，形成引领业界发展的云安全体系，打造了国内云安全市场领导品牌。
在日益激烈的攻防对抗实战中，围绕敏感数据、核心资产展开的网络攻击与入侵事件数不胜数，用户也面临着数据泄露&amp;勒索、业务系统稳定性被破坏、经济损失加大等威胁。网络安全态势研判的开展，则有助于用户及时识别各类新增和变更的资产，扫除安全盲区，掌握当前可能存在的网络安全威胁与风险，通过实时的安全分析与管控，及时采取必要的防范与应对措施，提高应急响应速度，更好地保护重要的资产以及核心敏感数据，降低网络攻击的风险。
安全狗基于获取到的互联网攻防对抗威胁情报和企事业单位数据中心内部的安全态势要素数据，充分利用企事业单位公司现有的安全系统、安全设备，逐步演进为“安全数据集中存储、安全威胁分析与预警场景不断扩充、分析能力与数据对外开放”的高价值安全信息存储及、分析、预警和联动处置的啸天·安全大数据平台，可帮助用户有效预测风险、精准感知威胁、提升响应效率。
在成熟且稳定的态势感知平台基础上，安全狗安全专家们结合云原生安全、AI安全、威胁狩猎等安全技术为各主管部门、地方网信部门持续提供安全支撑，助力中国网络空间安全协会多项工作顺利开展。
除了在中国网络空间安全协会工作中的技术能力输出，在国家网络与信息安全通报中心、国家互联网应急中心、国家信息安全漏洞库、国家信息安全漏洞共享平台等多个国家级安全部门的相关技术支持工作上，安全狗均积极参与，并获得优秀网络安全技术支撑单位等赞誉。
此次感谢信的获得，不仅是中国网络空间安全协会对安全狗态势研判技术支持实力的认可，更是对安全狗未来工作的持续激励。未来，安全狗将不忘“守护数字世界 助力网络强国”的使命，不断强化自身的安全产品能力、提高安全服务水平，继续向重要安全部门和协会等输出稳定的安全能力，配合其工作的顺利开展，为我国数字经济发展打好安全底座基础，为我国网络安全事业发展持续赋能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cce0dd459767859d9117f576102bf63a/" rel="bookmark">
			【数据库8.0备份还原】之Percona XtraBackup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Percona XtraBackup备份数据库1、Percona XtraBackup的介绍2、Percona XtraBackup安装3、Percona XtraBackup8.0的使用1.全库备份和还原2.增量备份和还原3.差异备份和还原4.差异备份和增量备份的区别5.压缩备份和还原 Percona XtraBackup备份数据库 yum源安装：网站： https://repo.percona.com/yum/
Percona XtraBackup 下载网站：https://repo.percona.com/yum/
https://www.percona.com/downloads
官方下载太慢
1、Percona XtraBackup的介绍 无论是 24x7 高负载服务器还是低事务量服务器 环境中，Percona XtraBackup 旨在实现无缝备份 过程，而不会中断生产中服务器的性能 环境。Percona XtraBackup （PXB） 是一个 100% 开源备份解决方案，为希望从 MySQL 的全面、响应迅速且经济灵活的数据库支持中受益的组织提供商业支持。
Percona XtraBackup 是世界上唯一的开源免费 MySQL 热备份 为 InnoDB 和 XtraDB 执行非阻塞备份的软件 数据库。使用 Percona XtraBackup，您可以获得以下优势：
快速可靠地完成备份 备份期间不间断的事务处理 节省磁盘空间和网络带宽 自动备份验证 由于恢复时间更快，正常运行时间更长 xtrabakackup有3个工具，分别是
xtrabakup、
innobakupex、
xbstream 通过流数据功能，可将备份内容打包并传给管道后的压缩工具进行压缩
xtrabackup 支持InnoDB，XtraDB
innobakupex 支持Myisam,InnoDB、XtraaDB
xbstream：以专有格式压缩 xtrabackup 输出的信息
支持的存储引擎：
Percona XtraBackup 可以备份 MySQL 8.0 服务器以及 Percona Server for MySQL with XtraDB、Percona Server for MySQL 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cce0dd459767859d9117f576102bf63a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c8fa48059850eddc722a8b86363b43c/" rel="bookmark">
			STM32 IAP远程程序升级（基于HTTP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于HAL库的STM32F407IGT6的IAP远程程序升级方法 文章目录 前言一、IAP基本原理二、CubeMx配置三、代码功能实现总结 前言 在嵌入式产品层出不穷的今天，功能迭代升级需求不可或缺。已经封装好的产品很难拆下来烧录程序，IAP是In Application Programming的首字母缩写，IAP是用户自己的程序在运行过程中对User Flash的部分区域进行烧写，目的是为了在产品发布后可以方便地通过预留的通信口对产品中的固件程序进行更新升级。常见的IAP远程升级方法有：串口和HTTP，本文主要分享HTTP方法。
一、IAP基本原理 应用编程IAP(In-Application Programming)是应用在Flash程序存储器的一种编程模式。它可以在应用程序正常运行的情况下，通过调用特定的IAP程序对另外一段程序Flash空间进行读/写操作，甚至可以控制对某段、某页甚至某个字节的读/写操作，这为数据存储和固件的现场升级带来了更大的灵活性。通常在用户需要实现IAP功能时，即用户程序运行中作自身的更新操作，需要在设计固件程序时编写两个项目代码，第一个项目程序不执行正常的功能操作，而只是通过某种通信管道(如USB、USART)接收程序或数据，执行对第二部分代码的更新；第二个项目代码才是真正的功能代码。这两部分项目代码都同时烧录在User Flash中，当芯片上电后，首先是第一个项目代码开始运行，它作如下操作：
1. 检查是否需要对第二部分代码进行更新;
2. 如果不需要更新则转到4;
3. 执行更新操作;
4. 跳转到第二部分代码执行。
第一部分代码必须通过其它手段，如JTAG或ISP烧入；第二部分代码可以使用第一部分代码IAP功能烧入，也可以和第一部分代码共同烧入，需要程序更新时再通过第一部分IAP代码更新。我们将第一个项目代码称为Bootloader程序，第二个项目代码称为APP程序，他们存放在STM32F407 FLASH的不同地址范围，一般从最低地址区开始存放Bootloader，其次就是APP程序，这样我们就是要实现2个程序：Bootloader和APP。我们先来看看STM32F4正常的程序运行流程（为了方便说明IAP过程，我们先仅考虑代码全部存放在内部FLASH的情况），如下图所示。
图1 STM32F4程序运行流程
STM32F407 的内部闪存（FLASH）地址起始于 0X0800 0000， 一般情况下，程序文件就从此地址开始写入。此外 STM32F407 是基于 Cortex-M4 内核的微控制器，其内部通过一张“中断向量表”来响应中断，程序启动后，将首先从“中断向量表”取出复位中断向量执行复位中断程序完成启动， 而这张“中断向量表”的起始地址是 0x08000004，当中断来临， STM32F407的内部硬件机制亦会自动将 PC 指针定位到“中断向量表”处，并根据中断源取出对应的中断向量执行中断服务程序。在上图中， STM32F407在复位后，先从 0X08000004 地址取出复位中断向量的地址，并跳转到复位中断服务程序，如图标号①所示；在复位中断服务程序执行完之后，会跳转到我们的 main 函数，如图标号②所示；而我们的 main 函数一般都是一个死循环，在 main 函数执行过程中，如果收到中断请求（发生了中断），此时 STM32F407强制将 PC 指针指回中断向量表处，如图标号③所示；然后，根据中断源进入相应的中断服务程序，如图标号④所示；在执行完中断服务程序以后，程序再次返回 main 函数执行，如图标号⑤所示。
当加入 IAP 程序之后，程序运行流程如下图所示：
图2 STM32F4加入IAP后的程序运行流程
在上图所示流程中， STM32F407 复位后，还是从 0X08000004 地址取出复位中断向量的地址，并跳转到复位中断服务程序，在运行完复位中断服务程序之后跳转到 IAP 的 main 函数，如图标号①所示，此部分同正常的程序运行流程图一样；在执行完 IAP 以后（即将新的 APP 代码写入STM32F407 的 FLASH，灰底部分。新程序的复位中断向量起始地址为 0X08000004+N+M），跳转至新写入程序的复位向量表，取出新程序的复位中断向量的地址，并跳转执行新程序的复位中断服务程序，随后跳转至新程序的 main 函数， 如图标号②和③所示，同样 main 函数为一个死循环，并且注意到此时 STM32F407 的 FLASH，在不同位置上，共有两个中断向量表。在 main 函数执行过程中，如果 CPU 得到一个中断请求， PC 指针仍然会强制跳转到地址0X08000004 中断向量表处，而不是新程序的中断向量表，如图标号④所示；程序再根据我们设置的中断向量表偏移量，跳转到对应中断源新的中断服务程序中，如图标号⑤所示；在执行完中断服务程序后，程序返回 main 函数继续运行，如图标号⑥所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c8fa48059850eddc722a8b86363b43c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1f6ad9c06014671e4366316d2c9d44/" rel="bookmark">
			Linux Mii management/mdio子系统分析之六 fixed-mii_bus分析（mac2mac分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（转载）原文链接：[https://blog.csdn.net/u014044624/article/details/130674908]
(https://blog.csdn.net/u014044624/article/details/130674908)
前面几章我们介绍了MDIO模块的大部分内容，针对mii_bus、mdio_bus、phy_device、phy_driver相关的注册、注销均进行了介绍。基本上把mdio模块的内容介绍完了，而本篇介绍的内容，主要是针对虚拟mii_bus实现，并将虚拟phy_device注册至该mii_bus上。（本次分析内容基于LINUX3.10的内核）
那fixed-mii_bus起到什么作用呢？其应用场景如下（示意图如下）：
两个cpu间的mac通过rgmii/sgmii等直接相连（不需要phy device），这两块核心板存在于一块单板上，无须使用phy芯片。cpu与fpga间的mac通过rgmii/sgmii等直接相连（不需要phy device），这两块核心板存在于一块单板上，无须使用phy芯片。 针对这两种应用场景，均没有使用phy芯片，但mac的驱动程序为保持通用性还是需要进行mii_bus注册以及net-device与phy-device的connect。因此mdio模块设计了一个虚拟的mii_bus（命名为fixed-mii_bus），用于mac芯片无需连接phy芯片的情况。针对上述情况而言，因两个mac间直接通过数据总线（rgmii/sgmii/qsgmii等）相连，因此需要手动配置mac芯片的模式（全双工）、速率（千兆/百兆/万兆等）。
fixed_mii_bus相关的数据结构说明 主要定义了struct fixed_mdio_bus、struct fixed_phy两个结构体。其中struct fixed_mdio_bus中包含了
struct mii_bus类型的成员；而struct fixed_phy包含了struct phydev类型的成员。
struct fixed_mdio_bus 该结构体表征一个虚拟mii_bus，并包含了fixed相关的信息，其中：
链表头phys用于将所有注册至fixed_mii_bus上的逻辑phy device链接在一起；irqs表示每一个虚拟phy对应的中断（基本上很少有使用该变量的，在mii_bus介绍章节中也说了，该中断可实现对phy devic link up/down的中断触发。在此处基本用不到） struct fixed_mdio_bus {
int irqs[PHY_MAX_ADDR];
struct mii_bus *mii_bus;
struct list_head phys;
};
struct fixed_phy 该结构体表征一个虚拟phy设备，其中:
id表示phy的addr,范围[0-31];regs表示该虚拟phy设备的寄存器值（因是一个虚拟phy，因此该虚拟phy的寄存器值由fxied_phy_status中的值决定）status中定义了该虚拟phy设备的各状态值，主要包括link状态、speed、duplex、pause、asym_pause等，而regs中的值即根据该变量中的内容进行设置；link_update接口用于更新虚拟phy的link状态。该接口类似于struct phydev中的adjust_link。它们之间的区别是： adjust_link接口根据phy device的link状态，对net_device的link状态进行更新；link_update接口则是根据net_device的link状态，对虚拟phy设备的link 状态进行更新。 针对该接口指针，基本上不需要使用，若需要使用，则在创建虚拟phy设备时，赋值即可。
node主要用于将该结构体链接至fixed_mdio_bus的的phys链表上。 struct fixed_phy {
int id;
u16 regs[MII_REGS_NUM];
struct phy_device *phydev;
struct fixed_phy_status status;
int (*link_update)(struct net_device *, struct fixed_phy_status *);
struct list_head node;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac1f6ad9c06014671e4366316d2c9d44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595cb28247d0b8194d7f70a23b58b6b6/" rel="bookmark">
			详解SpringCloud微服务技术栈：Nacos配置管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓作者简介：一位大四、研0学生，正在努力准备大四暑假的实习
🌌上期文章：详解SpringCloud微服务技术栈：Nacos服务搭建及服务分级存储模型
📚订阅专栏：微服务技术全家桶
希望文章对你们有所帮助
上一节讲了Nacos做服务搭建的方法，并与Eureka做了比较，Nacos除了可以做服务的搭建，比起Eureka还有更多的功能，即配置管理。
Nacos的集群搭建，感觉太复杂了，就一台电脑要弄很久去模拟，所以不做展示了。
Nacos配置管理 统一配置管理微服务配置拉取配置热更新多环境配置共享 统一配置管理 在实际生产环境中会有很多的服务，服务之间又有互相调用的关系，每次重新配置，都可能使得其他服务也要修改一些配置，同时服务都得重启，在实际生产环境中的影响有时候还是很大的。因此需要将配置的文件进行统一的管理，同时这些配置的更改无须重启，直接热更新。
设置配置管理服务，当配置要做修改的时候，无须自己做改动，而是去配置服务管理中把需要配置的地方做修改。
而Nacos就拥有配置管理服务。
这里可以新建配置管理，这里的配置放着的是有热更新需求的配置：
微服务配置拉取 接下来，微服务需要得到这些统一配置。
假设没有Nacos的统一配置，其获取配置的步骤为：
1、启动项目
2、读取本地配置文件application.yml
3、创建Spring容器
4、加载bean
当加入了Nacos中的配置文件以后，服务启动之后，就需要先读Nacos中的配置文件，再将Nacos中的配置文件与本地的配置文件做一个合并。
需要考虑一些问题：从哪里读取Nacos地址，读取什么内容。
在此之前，要先获得Nacos的地址，就需要使用bootstrap.yml，优先级比application高。
步骤：
1、引入Nacos的配置管理客户端依赖：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; 2、在userservice中的resource中添加bootstrap.yml文件，这是引导文件，优先级高于application.yml：
spring: application: name: userservice profiles: active: dev # 环境 cloud: nacos: server-addr: localhost:8848 # Nacos地址 config: file-extension: yaml # 文件后缀名 3、删除application.yml中的重复配置。
这样就可以拉取到配置了，可以在UserController中验证：
@NacosValue("${pattern.dateformat}") private String dateformat; @GetMapping("now") public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)); } 访问localhost:8081/user/now：
这说明微服务已经成功获取了Nacos中的配置信息。
将配置交给Nacos管理的步骤总结：
1、在Nacos中添加配置文件
2、在微服务中引入Naocs的config依赖
3、在微服务中添加bootstrap.yml，配置Nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时去Nacos读取哪个文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/595cb28247d0b8194d7f70a23b58b6b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b18b0b50ae7ac1f76b3c024330efe29/" rel="bookmark">
			yolov5s.yaml 文件解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# YOLOv5 🚀 by Ultralytics, AGPL-3.0 license # Parameters nc: 81 # number of classes depth_multiple: 0.33 # model depth multiple width_multiple: 0.50 # layer channel multiple anchors: - [10,13, 16,30, 33,23] # P3/8 - [30,61, 62,45, 59,119] # P4/16 - [116,90, 156,198, 373,326] # P5/32 nc: 81 - 表示模型被训练来识别的类别数量为81。
depth_multiple: 0.33 - 模型深度的倍数。这个参数用于调整模型中层的深度。值为0.33意味着每个层的深度为原始设计深度的33%，通常用于减小模型大小和计算需求，但可能会牺牲精度。
width_multiple: 0.50 - 表示层通道的倍数。这个参数用于调整网络层中通道的数量。值为0.50意味着每个层的通道数为原始设计的50%。类似于深度倍数，也可用于减小模型的大小和计算需求。
anchors - 参数定义了一组锚点框（anchor boxes），这些框用于检测不同尺寸的物体。在YOLO模型中，锚点框是预定义的不同大小和比例的矩形，模型在这些矩形基础上调整以更好地适应实际检测到的物体。这里定义了三组不同尺寸的锚点框，每组用于不同层级的特征图（如P3/8, P4/16, P5/32），这些特征图代表不同的空间分辨率。
锚点框（Anchor Boxes）是一种在目标检测领域常用的技术，用于模型在图像中识别和定位对象。
基本概念 预定义的矩形框：锚点框是一组预定义的矩形框，这些框有不同的尺寸和长宽比。它们被设计为覆盖可能在图像中出现的各种对象的形状和大小。
特征图上的位置：在目标检测过程中，模型生成一个或多个特征图（feature maps），这些特征图在不同的空间分辨率上表示图像的特征。锚点框被放置在这些特征图的每个位置上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b18b0b50ae7ac1f76b3c024330efe29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f3ff9730827664175de80a0347e5932/" rel="bookmark">
			2023 IoTDB 用户大会：天谋科技 Christofer Dutz《如何用Apache PLC4X构建极简工业数据采集》...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12 月 3 日，2023 IoTDB 用户大会在北京成功举行，收获强烈反响。本次峰会汇集了超 20 位大咖嘉宾带来工业互联网行业、技术、应用方向的精彩议题，多位学术泰斗、企业代表、开发者，深度分享了工业物联网时序数据库 IoTDB 的技术创新、应用效果，与各行业标杆用户的落地实践、解决方案，并共同探讨时序数据管理领域的行业趋势。
我们邀请到天谋科技欧洲研发负责人、ASF 董事会成员 Christofer Dutz 参加此次大会，并做主题报告——《纳其源：如何用 Apache PLC4X 构建极简工业数据采集》。以下为英文内容和中文翻译全文。
目录
Current State of OT Communication
OT （运营技术）通信现状
Introducing Apache PLC4X
Apache PLC4X 介绍
My Vision of PLC4X and IoTDB
PLC4X 与 IoTDB 集成愿景
很遗憾我不能亲自来到现场与大家见面，只能远程做这个报告，但我将尽力和大家分享最近令我十分感兴趣并且全力投入的事情。
我将探讨如何使用 Apache PLC4X 从工业硬件进行通用数据采集，那么这与 IoTDB 有什么关系呢？毕竟我们是在 IoTDB 用户大会。我想说的是，如果你能把数据存储下来，这当然很好，而如果你还能把数据读取出来，那就更好了。我认为如何读取数据仍然是工业自动化领域中最大、最主要的未解决问题之一。我们现在知道如何存储和处理大量数据，但获取它们仍然是一个严峻的问题。
那么我将讲些什么呢？首先，我将为你们简要介绍工业运营技术领域通信的现状。之后，我将介绍 Apache PLC4X。也许你们中的一些人已经听说过它，但为了确保每个人都了解，并且都像我一样喜欢它，我还是要稍微聊聊 Apache PLC4X。最后，我还将分享我对如何将 PLC4X 和 IoTDB 结合起来，以解决真实工业问题的愿景。
I'm a bit sad that I'm not able to be with you right now, so I have to do this remotely, but I'll do my best to still get you on board with what currently really excites me.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f3ff9730827664175de80a0347e5932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83782a32de55ccc085ad891fee29064/" rel="bookmark">
			Docker-Compose详解与部署示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
docker compose组成
Docker Compose 概述
三层结构
配置文件
使用场景
实现原理
Docker Compose 环境安装
YAML文件格式
编写注意事项：
数据结构：
示例：
Docker Compose配置常用字段
Docker Compose 常用命令
Docker-Compose文件结构
示例：搭建基于Nginx的Docker容器
准备依赖文件:
编写脚本 run.sh:
编写Dockerfile:
创建测试网页:
编写docker-compose.yml:
启动Docker容器:
Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。它允许你使用YAML文件配置应用程序的服务、网络和卷，并通过一个简单的命令集启动和管理整个应用程序的容器。通过使用Docker Compose，可以轻松地将多个Docker容器协同工作，构建和管理复杂的应用程序环境。
在容器化应用的过程中，一个 Dockerfile 模板文件可以定义一个单独的应用容器。然而，如果需要定义多个容器并协同工作，就需要使用服务编排。服务编排有多种技术方案，下面将介绍 Docker 官方产品 Docker Compose。
docker compose组成 Docker Compose是用于定义和运行多容器Docker应用程序的工具。它使用YAML文件来配置应用程序的服务、网络和卷等。以下是Docker Compose的主要组成部分：
YAML文件： Docker Compose使用YAML文件来定义应用程序的服务、网络、卷等配置。这个文件通常称为docker-compose.yml。在这个文件中，可以指定应用程序的各个服务、它们之间的关系、容器的映像、端口映射、环境变量等。
Service（服务）： 服务是应用程序的组件，可以是一个容器或一组相关的容器。在Docker Compose中，每个服务都由一个或多个容器组成，这些容器一起提供应用程序的特定功能。
Container（容器）： 容器是Docker化的应用程序运行的实例。每个服务在Docker Compose中都会映射到一个或多个容器。
Networks（网络）： Docker Compose允许定义应用程序中的网络。可以指定容器之间的网络连接方式，以实现服务之间的通信。
Volumes（卷）： 卷是用于在容器之间共享数据的机制。在Docker Compose中，可以定义卷以在服务之间传递数据。
Environment Variables（环境变量）： 可以在Docker Compose文件中设置环境变量，这些变量将传递给容器，以影响它们的行为。
Build（构建）： 如果需要构建自定义镜像，可以使用Docker Compose文件中的build指令，指定构建上下文和Dockerfile的位置。
Ports（端口）： 可以在Docker Compose文件中定义端口映射，将容器内部的端口映射到主机上的端口，以允许外部访问服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f83782a32de55ccc085ad891fee29064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca2db851dfa4106d948afbb1660d439/" rel="bookmark">
			cesiumlab切片通过arcgisjs加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cesiumlab切片通过arcgisjs加载 需要注意2个地方，一个是tileInfo，一个是getTileUrl，
在tileInfo中定义好cesiumlab切片的相关信息。
getTileUrl 格式化url的格式。
注意设置编辑，避免超出范围报404。
&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;title&gt;WebTileLayer&lt;/title&gt; &lt;style&gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } &lt;/style&gt; &lt;link rel="stylesheet" href="http://localhost:8093/arcgis/4.28/esri/themes/light/main.css" /&gt; &lt;script src="http://localhost:8093/arcgis/4.28/init.js"&gt;&lt;/script&gt; &lt;script&gt; var bashUrl = "http://localhost:8093/cesiumKlmy" var url = "/{z}/{x}/{y}.png"; require(["esri/Map", "esri/views/SceneView", "esri/layers/WebTileLayer", "esri/geometry/SpatialReference", 'esri/layers/support/TileInfo'], (Map, SceneView, WebTileLayer, SpatialReference, TileInfo) =&gt; { const tileInfo = new TileInfo({ dpi: 90.71428571428571, format: "image/png", spatialReference: new SpatialReference({ wkid: 4326, }), origin: { x: -180, y: 90 }, lods: [{ level: 0, levelValue: 1, resolution: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cca2db851dfa4106d948afbb1660d439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1359c840cb16cb3e47ecac612d079715/" rel="bookmark">
			解决BigDecimal序列化科学计数法前端展示问题(大坑)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决BigDecimal序列化科学计数法前端展示问题(大坑) 前言：在生产中出现一个问题，就是BigDecimal类型的字段在前端页面展示变成科学计数法，通过排查，发现里面的坑还是挺多的，所以特意记录下处理过程。Json序列化，不同项目中配置的都不一样，有些项目是使用springboot里面自带的jackson的，有些是使用fastjson处理，不同的序列化的处理方式也不一样。
1、fastJson对BigDecimal序列化和反序列化 字段返回完整的数字，避免科学计数法
我们看下JSON.toJSONString()的方法，我们可以看到，可以传进SerializerFeature的枚举
public static String toJSONString(Object object, SerializerFeature... features) { return toJSONString(object, DEFAULT_GENERATE_FEATURE, features); } 所以，我们这边传进WriteBigDecimalAsPlain枚举，就可以将数字完整返回
private static final SerializerFeature[] features = { SerializerFeature.WriteBigDecimalAsPlain}; public static String toString(Object data) { return JSON.toJSONString(data, features); } PS: 大坑，我们可以发现这时候后端返回给前端是完整的数字，但是由于字段是数字类型，所以前端JS会把数字变成科学计数法展示，如下图展示，左边的数据是浏览器响应的数据，右边的数据是postman调用返回的数据，可以看到后端返回是没问题，但是由于前端JS的问题导致展示出现科学计数法。这时候，我们就需要考虑是不是返回给前端序列化成字符串类型返回。
1.1 fastJson对BigDecimal转成字符串类型返回（全局处理，推荐） 自定义序列化类实现ObjectSerializer接口重写里面write方法，并且把自定义序列化类放到fastJson序列化配置中
public class BigDecimalConfig implements ObjectSerializer { public static final BigDecimalConfig instance = new BigDecimalConfig(); @Override public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException { SerializeWriter out = serializer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1359c840cb16cb3e47ecac612d079715/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/710d965620910493fabfff4a91b4b31f/" rel="bookmark">
			Android Text View 去掉默认的padding的实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看下最终实现效果，满意您在往下看：
TextView 绘制的时候自带一定的Padding值，要想实现去掉默认的padding值，xml文件可以设置一个属性值 ：
android:includeFontPadding="false" 然后运行起来就会发现，并没有什么卵用，也不能说完全没有，但效果差点意思。我就不运行了，在编译器上也能大概看到效果，如下图，我们可以看到依然有着无法删除的padding值。
我们先来看一下绘制TextView时的几条基准线：
top：在给定文本大小下，字体中最高字形高于基线的最大距离，即能绘制的最高点ascent：单倍行距文本的基线以上建议距离，即推荐的文字绘制上边缘线base：文字绘制基准线，也就是坐标轴，X轴就是Baselinedecent：单间距文本低于基线的建议距离，即推荐的文字绘制下边缘线bottom：能绘制的最低点 Textview绘制文字会在 ascent 和 decent 之间，外面的距离我们可以理解为 类似 padding一样的间隔，但又并不是我们设置的paddingTop，paddingBottom。
要解决这个这个问题，首先我们要知道textview的内容文字绘制的真实区域：
红色的区域就是内容的真实高度，蓝色的部分就是textview绘制的多余的部分，现在我们要去掉这一部分，首先可以通过 getTextBounds 来获取绘制的真实区域
textView.getPaint().getTextBounds(text, 0, text.length(), textRect); 获取到真实区域后，那么再来看textview绘制的几条基准线，你想到了什么，是的，我们只需要稍微移动一下这几条线把高度压缩到文字的展示绘制区域即可，实现用 SpannableString 来实现，SpannableString 是 android 里面专门用来实现设置 textview 文字样式的类，这个不清楚的自行查询一下，这里不赘述了，具体我们用的是 LineHeightSpan ，可以通过修改 textview 的行高来实现我们的目的。具体看下代码：
spannableString.setSpan(new LineHeightSpan() { @Override public void chooseHeight(CharSequence text, int start, int end, int spanstartv, int lineHeight, Paint.FontMetricsInt fm) { Rect textRect = new Rect(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) { textView.getPaint().getTextBounds(text, 0, text.length(), textRect); } else { textView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/710d965620910493fabfff4a91b4b31f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/450c929b73a4aabe210e4941ac4023c8/" rel="bookmark">
			SDL2 连续帧图像显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT使用SDL多窗口显示视频（linux，ubuntu）_linux qt sdl-CSDN博客
QT使用SDL播放YUV视频 - C++ - QT
SDL调用OPENGL渲染图像 - C++ - 心得
C++ 使用SDL显示RGB图像数据_c++ sdl-CSDN博客
SDL库入门：掌握跨平台游戏开发和多媒体编程_sdl开发-CSDN博客
SDL教程零基础入门 简单操作 day1-CSDN博客
摘抄： 连续帧：
知识补充：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e30a008fb5b76045a69efd4389c115a/" rel="bookmark">
			C# wpf 实现任意控件（包括窗口）更多调整大小功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF拖动改变大小系列 第一节 Grid内控件拖动调整大小
第二节 Canvas内控件拖动调整大小
第三节 窗口拖动调整大小
第四节 附加属性实现拖动调整大小
第五章 拓展更多调整大小功能（本章）
文章目录 WPF拖动改变大小系列前言一、添加的功能1、任意控件DragResize2、边界限制3、交叉拖动4、拖动点模板5、拖动点容器模板6、整体模板7、窗口平滑拖动8、拖动事件9、其他功能（1）适应MinWidth、MinHeight（2）适应MaxWidth、MaxHeight（3）适配任意dpi 二、完整代码三、使用示例0、基础功能（1）、引用命名空间（2）、使用附加属性（3）、窗口注意事项 1、DragResize2、边界限制3、交叉拖动4、拖动点布局模板（1）自定义圆点（2）4个顶点（3）单独定制每个点 5、拖动点容器模板（1）无Margin（2）设置Margin 6、整体模板7、窗口平滑拖动8、拖动事件9、其他功能（1）适应MinWidth、MinHeight（2）适应MaxWidth、MaxHeight 总结 前言 上一章我们已经实现了任意控件统一的拖动调整功能，能够方便的给任意控件设置拖动调整大小。开发过程中发现还是有些功能可以继续拓展的，比如cs代码触发拖动、自定义模板、交叉拖动、限制拖动范围等功能。有功能实现起来不算太容易，却很有实用价值。
一、添加的功能 在第四章基础上添加了如下功能。
1、任意控件DragResize 我们知道wpf的Window有DragMove功能，在鼠标左键按下事件中调用此方法就能实现拖动功能很方便。对于调整大小也可以实现类似的DragResize功能， 实际效果和点击画板拖出一个形状差不多。
代码示例如下：
/// &lt;summary&gt; /// 手动触发拖动改变大小，与Window.DragMove类似,只能在鼠标左键按下时调用。 /// 实际效果和点击画板拖出一个形状差不多。 /// 此方法为拓展方法，FrameworkElement的子类控件（即有宽高属性的控件）都可以调用此方法。 /// &lt;/summary&gt; /// &lt;param name="elememt"&gt;&lt;/param&gt; /// &lt;returns&gt;返回Task，await等待拖动完成&lt;/returns&gt; /// &lt;exception cref="InvalidOperationException"&gt;&lt;/exception&gt; public static async Task DragResize(this FrameworkElement elememt) { if (Mouse.LeftButton != MouseButtonState.Pressed) { throw new InvalidOperationException("Left button down to call this method"); } if (elememt.Parent == null &amp;&amp; elememt is not Window) { throw new InvalidOperationException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e30a008fb5b76045a69efd4389c115a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e53ca18f88ab10e24e6c16f8cee6cf/" rel="bookmark">
			Arya碎碎念 | 2023年编程之旅，2024年代码人生展望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 回顾过去这一年， 2023年编程之旅，2024年代码人生展望
目录 前言回望2023写博客的缘起写博客的成就参加的创作活动产出的优质博客文章 展望2024代码开发方面博客规划方面 另外另外我有了一直喵 总结 回望2023 写博客的缘起 3年前，注册了csdn账号，3年后的2023年我也成为了一名创作者，机缘巧合下从今年的4月份开始正式写博客文章，写文章的初衷是为了保留下自己学习的笔记，方便后面忘记了相关知识点的时候，能够快速找到参考。
在写博客，自己写总结的过程中，对于代码开放也渐渐有了深入的认识，持续学习过程中，也接触到了更多的编程语言，各种语言都有适合于自己的领域。同样，每个人也有自己的价值。
写博客的成就 从4月份开始写博客，到现在年末的时候，阅读量突破20w，粉丝数量800+，博客之星城市赛道Top10，这对于一个2020年就有博客账号的人来说，落后了很多；但对于一个2023年开始成为博主的人来讲，也算是小有成就。
在写博客的过程中，也见到了需要优秀的博客，博客文章逻辑清晰，内容优质，给了我很多的帮助。这些优秀的博主都是我学习的榜样。希望我早日也能写出优秀的博客文章，让更多人受益。
参加的创作活动 在写博客的过程中，也关注了一些博客创作的活动，比如最早的端午节创作活动，那次活动我成功入围，获得了csdn发的粽子，一个野餐垫，一个收纳箱，一个咚咚杯；还是非常开心的，第一次作为创作者身份获得鼓励。
在1024程序员节的创作活动中，成功获得二等奖，喜提两个小包，其实当时我还挺想要那个水杯的，我比较习惯使用背包，所以这两个包就在家里柜子里躺着了，水杯的话，我出去徒步还能带着。
要说最有成就感的（钱）的创作活动还要数，华为云的有奖征文活动，只要文章入围，每篇奖励200块，当时自己正好接触Linux系统，就花了3分钱开通了一个账号，开始写相关的测评文章，最终成功入围了15篇文章，虽然截止目前为止还未收到奖励。。。。
ps: 20240116未收到
产出的优质博客文章 在持续的创作中，逐渐形成了一些系列文章，个人认为这些文章的质量还是不错的，列举如下，希望对你有帮助。
展望2024 代码开发方面 以积极开放的心态看待编程语言，以拥抱的姿态接触开源项目，保持一颗对于技术的好奇心。
目前自己的规划主要有以下几点：
1.Java作为互联网开发时代应用最广的开发语言，持续深入学习，不能只满足于增删改查，要了解和学习并发相关的编程；
2.Python作为生态强大的脚本语言，几行代码就能解决其他编程语言很难解决的问题，可以用来做一些小的工具；
3.C系列的语言需要更多的学习，因为目前工作可能会更多偏向于这个方向；
博客规划方面 目前专栏划分得比较细，随着文章的增加可能会越来越多，找起文章来也会比较麻烦，后面需要进行优化专栏的划分，看看能不能更合理地划分专栏文章。
另外另外 我有了一直喵 Arya本丫——我有了一只小猫咪
总结 回顾过去这一年， 2023年编程之旅，2024年代码人生展望
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2daf6215962b570a47fe399e77949278/" rel="bookmark">
			前端背景收集之下雪花狗礼物背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🐒个人主页🏅Vue项目常用组件模板仓库📖前言：🎀源码如下： 🐒个人主页 🏅Vue项目常用组件模板仓库 📖前言： 本篇博客主要提供前端背景收集之下雪花狗礼物背景组件源码，，（下雪花的表情❄，可以替换为🐕 🪂 🎀 🎇 等一系列表情，下面是表情官网，也可以是文字内容）可以修改背景颜色，插入背景图片均可，看自己想象力发挥，需要的朋友请自取
🐒表情Emoji官网入口
🎀源码如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; body { background-color: #000000;/* 背景 */ } .snowflake { position: absolute; font-size: 25px;/* 文字大小 */ color: #FFFFFF;/* 物体颜色 */ text-shadow: 1px 1px 1px #000000; /* 物体阴影，立体感*/ user-select: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function random(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } function Snowflake() { this.characters = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2daf6215962b570a47fe399e77949278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68734e859439a05bfcaacef72d600e93/" rel="bookmark">
			【Chrome】ERR_SSL_PROTOCOL_ERROR问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、下载二、使用步骤总结 前言 Edge升级最新版后，有的https访问不了，报如下错误
发现新版Chrome以及Chromium内核访问nginx ssl时报错，顺着这个思路接着查看到大佬的结论：服务器nginx使用的openssl版本过低，验证过后开始升级
一、下载 其它的都能在官网下载到，这里就不挨个贴了，贴一个我整合好的压缩包，觉得挨个下麻烦的可以拿走用。
点我去下载新版
旧版
nginx：1.0.9
openssl：1.0.1h
pcre：8.37
zlib：1.2.8
module：nginx_upstream_check_module-master新版
nginx：1.25.3
openssl：1.1.1w
pcre：8.45
zlib：1.3
module：nginx_upstream_check_module（0.0.4） 二、使用步骤 将上述包放到同一个文件夹分别解压，解压命令
tar -zxvf nginx-1.25.3.tar.gz tar -zxvf openssl-1.1.1w.tar.gz tar -zxvf pcre-8.45.tar.gz tar -zxvf zlib-1.3.tar.gz tar -zxvf nginx_upstream_check_module-0.4.0.tar.gz 之后进入nginx文件夹
cd nginx-1.25.3 开始编译、安装
./configure --prefix=/usr/local/nginx-1.25.3 \ --with-openssl=../openssl-1.1.1w \ --with-pcre=../pcre-8.45 \ --with-zlib=../zlib-1.3 \ --with-http_ssl_module \ --without-http_memcached_module \ --with-http_stub_status_module \ --with-http_gzip_static_module \ --add-module=../nginx_upstream_check_module-0.4.0/ make sudo make install 步骤里没有将nginx加到系统环境中全局使用，需要自行添加，使用时需要对应目录或者绝对路径使用
cd /usr/local/nginx-1.25.3 cd /sbin # 启动 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68734e859439a05bfcaacef72d600e93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc5d5ddf055eb50f7530670d9e1466a/" rel="bookmark">
			ES的常用查询以及其他操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 数据准备 1.1 创建索引和新增数据 先新增一条数据，新增数据时会自动创建索引 test_standard_analyzer。
PUT /test_standard_analyzer/_doc/1 { "remark": "This is a test doc" } PUT /test_standard_analyzer/_doc/2 { "remark": "This is an apple" } 然后查询一下。
GET test_standard_analyzer/_search { "query": { "match_all": {} } } 查询结果如下所示。
"hits" : [ { "_index" : "test_standard_analyzer", "_type" : "_doc", "_id" : "1", "_score" : 1.0, "_source" : { "remark" : "This is a test doc" } }, { "_index" : "test_standard_analyzer", "_type" : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fc5d5ddf055eb50f7530670d9e1466a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdfc951ff1234e5f8dee648ca6a7fe9/" rel="bookmark">
			【加强版】小学数学出题，加减乘除混合运算，支持自定义数字，一键打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线预览：在线HTML代码预览和运行工具 - UU在线工具 复制下面代码后到该地址预览即可
注意：在线预览不能打印。如需打印，在电脑本地上新建文本文档，粘贴代码后保存，然后把文件后缀改为.html运行，出题点击打印就可以了
新增功能：
1、支持加减乘除运算混合多选
2、支持自定义数字运算个数
3、支持自定义出题数量
4、支持一键打印成pdf
5、小学数学没有负数，保证结果不出现负数
6、出题分列展示、新增答案下划线
7、界面美化
&lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;小学生数学题生成器&lt;/title&gt; &lt;style&gt; body { font-family: Arial, sans-serif; background-color: #f4f4f4; margin: 0; display: block; flex-direction: column; align-items: center; justify-content: center; } #options { display: block; margin: 20px auto; background-color: #fff; border-radius: 5px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); padding: 20px; box-sizing: border-box; width: 500px; line-height: 35px; } label { margin-right: 10px; margin-bottom: 10px; font-size: 16px; } button { padding: 5px; background-color: #4caf50; color: #fff; border: none; border-radius: 5px; cursor: pointer; } #questions { display: flex; flex-wrap: wrap; justify-content: space-between; margin-top: 20px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbdfc951ff1234e5f8dee648ca6a7fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/338777dfb24ffd0fe02323e4b9d90a4f/" rel="bookmark">
			Android 理解Context
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Android 理解ContextContext是什么Activity能直接new吗？ Context结构和源码一个程序有几个ContextContext的作用Context作用域获取ContextgetApplication()和getApplicationContext()区别Context引起的内存泄露错误的单例模式View持有Activity应用正确使用Context Android 理解Context Context是什么 Context可以理解为“上下文”或”环境“，它提供了访问系统服务及系统资源的功能，Context 参与加载资源、启动Activity、启动Service、获取系统服务/应用资源、创建View、数据库等操作。
通俗来讲：一个Android应用程序可以理解为一个部电影，Activity、Service、BroadcastReceiver、ContentProvider四大组件可以理解为电影中的四个主演。他们是由剧组（Android系统）一开始就制定好的，整部戏都是围绕这四位主演的，所以这四位主演不能随便在街上拉个人（new一个对象）就能演的，有了演员就需要摄像机拍摄，他们通过镜头（Context）将戏传递给观众，也就是说四大组件必须要在Context环境下运行，而其他的如Button、TextView、LinearLayout这些控件可以理解为配角，没有那么重要（可以new一个对象），
Activity能直接new吗？ 不能，Android的应用模型是基于组件的应用设计模式，组件的运行必须要一个完整的Android工程环境，只有在这个环境下，Activity、Service等系统组件才能正常运行。
Context结构和源码 Context源码：
public abstract class Context { // 作用1：获取应用相关信息 public abstract ApplicationInfo getApplicationInfo(); public abstract String getPackageName(); public abstract Looper getMainLooper(); public abstract int checkPermission(@NonNull String permission, int pid, int uid); // 作用2：获取系统/应用资源 // 如 AssetManager、PackageManager、Resources、System Service 以及 color、string、drawable 等 public abstract AssetManager getAssets(); public abstract Resources getResources(); public abstract PackageManager getPackageManager(); public abstract Context getApplicationContext(); public abstract ClassLoader getClassLoader(); public final @Nullable &lt;T&gt; T getSystemService(@NonNull Class&lt;T&gt; serviceClass) { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/338777dfb24ffd0fe02323e4b9d90a4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e67193964f98242a62afd7ca6df82466/" rel="bookmark">
			Android Context在四大组件及Application中的表现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Android Context在四大组件及Application中的表现Context是什么Context源码Activity流程分析Service流程分析BroadcastReceiver流程分析ContentProvider流程分析Application流程分析 Android Context在四大组件及Application中的表现 Context是什么 Context可以理解为“上下文”或”环境“，它提供了访问系统服务及系统资源的功能，Context 参与加载资源、启动Activity、启动Service、获取系统服务/应用资源、创建View、数据库等操作。
Context有两个实现子类：ContextImpl类和ContextWrapper类。
ContextWrapper类，如其名所言，是一个包装类，内部必须包含一个真正的Context引用（mBase），调用ContextWrapper的方法都会被指向真正的Context对。
ContextThemeWrapper类，如起名所言，内部包含了与Theme（主题）相关的信息，这里的Theme就是定义在Androidmanifest.xml中主题，只有Activity才能定义主题，Servier是不需要主题的，所以Service直接继承自ContextWrapper，Application也同理。
ContextImpl类是真正实现了Context中的所有方法，应用程序中所调用的各种Context类方法都来自该类。
Context源码 public abstract class Context { // 作用1：获取应用相关信息 public abstract ApplicationInfo getApplicationInfo(); public abstract String getPackageName(); public abstract Looper getMainLooper(); public abstract int checkPermission(@NonNull String permission, int pid, int uid); // 作用2：获取系统/应用资源 // 如 AssetManager、PackageManager、Resources、System Service 以及 color、string、drawable 等 public abstract AssetManager getAssets(); public abstract Resources getResources(); public abstract PackageManager getPackageManager(); public abstract Context getApplicationContext(); public abstract ClassLoader getClassLoader(); public final @Nullable &lt;T&gt; T getSystemService(@NonNull Class&lt;T&gt; serviceClass) { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e67193964f98242a62afd7ca6df82466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9eaf1300215f061bc0d966799eb5522/" rel="bookmark">
			messages,CentOS 7不收集日志或不存在 /var/log/messages
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/var/log/message, /var/log/secure等都不记录了，并且都是空文件。
重启机器：reboot 无效
重启日志： systemctl start rsyslog 无效
怀疑空间不足，删除/var/log/messages，重新运行rsyslog 无效
重装下rsyslog,于是yum reinstall rsyslog，重新运行rsyslog 无效
找到配置文件 /etc/rsyslog.conf
修改如下：
解注释：#$ModLoad imklog # reads kernel messages (the same are read from journald)
修改为：$ModLoad imklog # reads kernel messages (the same are read from journald)
增加注释：$OmitLocalLogging on
修改为：#$OmitLocalLogging on
增加注释：$IMJournalStateFile imjournal.state
修改为：#$IMJournalStateFile imjournal.state
重启日志：systemctl restart rsyslog
tai日志：tail -f /var/log/messages 可以了
注意默认centos7是注释掉#$ModLoad imklog # reads kernel messages (the same are read from journald)这段的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e68878adc3e4b0a31235778d5a7d61/" rel="bookmark">
			MySQL优化: CPU高 处理脚本 pt-kill脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 生产环境中，经常会遇见 CPU 跑满的情况，一般是由慢 SQL 或业务逻辑导致的。为了避免程序无法访问，使用脚本监控 CPU，当达到阈值时，使用 pt-kill 杀死匹配的 sql，确保线上环境的正常运行。追加到脚本中的 SQL，可以给开发人员，作为处理故障的切入点。
使用时请根据自身情况修改脚本，本脚本仅供参考。
功能
CPU 达到 60% 时，通知到微信
CPU 达到 80% 时，通知到微信，kill 掉大于 20 秒的查询。
CPU 达到 90% 时，通知到微信，kill 掉大于 60 秒的更新和大于 20 秒的查询。
微信通知间隔（默认 30 分钟）
流程图 以下为大致流程
CPU 监控脚本 vim /root/cpu_mon.sh #!/bin/bash # CPU 使用率大于 60 通知到微信，大于 80 通知并 kill 大于 20s 的查询，大于 90 kill 大于 20s 的查询及大于 60s 的更新 mysql_host=10.10.8.11 mysql_port=3306 mysql_user=test mysql_pwd="test123" # 企业微信脚本路径 script_dir="/root/wechat.py" # pt工具日志路径 pt_tool_log='/tmp/pt_kill.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22e68878adc3e4b0a31235778d5a7d61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ae54ac4d6c8730145c10141b2221b3/" rel="bookmark">
			CentOS安装maxwell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOs安装maxwell 一、简介二、准备工作三、安装1、下载安装包2、解压3、编写配置文件4、启动maxwell5、验证6、停止maxwell 四、说明1、更新数据2、插入数据3、删除数据 五、遇到问题 一、简介 maxwell是由美国Zendesk公司开源，它通过读取mysql的binlog日志，将数据变更以JSON的方式发送给Kafka, Kinesis等流数据处理平台。
This is Maxwell’s daemon, a change data capture application that reads MySQL binlogs and writes data changes as JSON to Kafka, Kinesis, and other streaming platforms.
官网地址
源码地址
二、准备工作 本次实现mysql数据同步给kafka，所以mysql与kafka需要提前准备好。
mysql表结构如下：
CREATE TABLE `user_info` ( `id` int NOT NULL AUTO_INCREMENT, `user_id` int NOT NULL, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `phone_number` varchar(30) DEFAULT NULL, `status` enum('active','inactive') DEFAULT 'active', `score` int unsigned DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=35464335 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci 特别注意：需要启用mysql的binlog
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ae54ac4d6c8730145c10141b2221b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c9a163056d77a4f424e4302d1d0308/" rel="bookmark">
			使用pyqt从主界面选择3个次界面中的一个跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QWidget, QVBoxLayout, QDialog class MainWindow(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setWindowTitle('主界面') self.setGeometry(100, 100, 300, 200) # 按钮布局 layout = QVBoxLayout() # 创建按钮并添加到布局中 self.button1 = QPushButton('打开界面1', self) self.button1.clicked.connect(self.openWindow1) layout.addWidget(self.button1) self.button2 = QPushButton('打开界面2', self) self.button2.clicked.connect(self.openWindow2) layout.addWidget(self.button2) self.button3 = QPushButton('打开界面3', self) self.button3.clicked.connect(self.openWindow3) layout.addWidget(self.button3) # 设置中心窗口 centralWidget = QWidget() centralWidget.setLayout(layout) self.setCentralWidget(centralWidget) def openWindow1(self): self.window1 = SubWindow1(self) self.window1.show() def openWindow2(self): self.window2 = SubWindow2(self) self.window2.show() def openWindow3(self): self.window3 = SubWindow3(self) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c9a163056d77a4f424e4302d1d0308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40eb79e307b466aaa8871630801fe1a/" rel="bookmark">
			MATLAB Fundamentals＞＞＞Creating Datetimes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Creating datetime Arrays 提示1：If you want to specify the time, use the optional fourth through sixth input arguments in the datetime function. They represent the hour, minute, and second in that order.
t = datetime(2014,5,25,8,11,0) t = 25-May-2014 08:11:00 Note that there are either three or six input values for datetime.) 任务1：
Use numeric inputs to create a datetime named d with a value of “February 29th, 2016 17:00”.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a40eb79e307b466aaa8871630801fe1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38998f4ae1dcdb6358af7efc340641ff/" rel="bookmark">
			arm-none-linux-gnueabi交叉工具链执行后显示: no such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 检查环境变量PATH是否配置好,如果都配置好了,安装这两个库:
sudo apt-get install lib32ncurses5 lib32z1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df723d664a9fe14a516732e1a3cdbadc/" rel="bookmark">
			Kotlin GlobalScope 和 CoroutineScope
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.tiger.mykotlinapp.scope import kotlinx.coroutines.GlobalScope import kotlinx.coroutines.cancel import kotlinx.coroutines.delay import kotlinx.coroutines.launch fun main() { val globalScope = GlobalScope globalScope.launch { delay(3000) println("hello") } globalScope.launch { delay(3000) println("hello") } //因为globalScope是整个应用程序的生命周期，不能在此手动取消它，调用抛异常 java.lang.IllegalStateException: Scope cannot be cancelled because it does not have a job globalScope.cancel()//不能手动取消它 while (true); } package com.tiger.mykotlinapp.scope import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.GlobalScope import kotlinx.coroutines.cancel import kotlinx.coroutines.delay import kotlinx.coroutines.launch fun main() { val coroutineScope = CoroutineScope(Dispatchers.Default) coroutineScope.launch { delay(3000) println("hello") } coroutineScope.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df723d664a9fe14a516732e1a3cdbadc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c01cfe4a1d03cb3fdeabb6a203e4449/" rel="bookmark">
			贴近速度的选择：为什么美国快速VPS值得您投资
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的普及，速度已经成为了一个至关重要的因素。无论您是个人用户还是企业所有者，快速的互联网连接都能够提高您的在线体验和生产力。在这个背景下，美国快速VPS变得越来越受欢迎。本文将探讨为什么选择美国快速VPS是一个明智的决策，并提供有关如何选择最适合您需求的VPS服务的建议。
为什么选择美国快速VPS?
1. 网络速度
美国以其高速的互联网连接而闻名。选择美国快速VPS意味着您可以享受到接近光纤速度的网络连接。这对于需要大量上传和下载数据的企业来说尤为重要。快速的网络连接可以提高网站的加载速度，提升用户体验，并有助于吸引更多的访问者。
2. 稳定性和可靠性
美国的互联网基础设施非常稳定和可靠。VPS主机提供商通常会在数据中心中部署多个冗余系统，以确保即使在不可预测的情况下，您的网站也能保持在线状态。这种可靠性对于在线业务至关重要，因为它可以减少停机时间和数据丢失的风险。Hostease的美国VPS服务器具有出色的稳定性和可靠性。他们在高度安全的数据中心中部署服务器，确保您的网站始终在线并运行顺畅。无论您是运营个人博客还是大型企业网站，Hostease都能提供卓越的可靠性。
3. 技术支持
美国的VPS服务提供商通常提供卓越的技术支持。无论您是初学者还是有经验的用户，都可以从他们的专业知识和支持中受益。当您面临技术问题或需要帮助时，可以放心地依赖他们的团队来解决问题。
如何选择适合您的美国快速VPS?
1. 了解您的需求
首先，确定您的在线需求是什么。您是否需要更多的带宽?您是否需要更多的存储空间?了解您的需求可以帮助您选择适合您的VPS计划。
2. 比较不同的服务提供商
市场上有许多提供美国快速VPS的服务提供商。在选择之前，比较不同提供商的定价、性能和客户反馈。这将帮助您找到最适合您需求的服务。
3. 查看技术支持
确保您选择的服务提供商提供全天候的技术支持。这可以确保在面临问题时有人可以帮助您解决。
4. 考虑成本
最后，考虑您的预算。美国快速VPS的价格因提供商和计划而异。选择一个适合您预算的选项，并确保它提供您所需的性能。
结论
在数字时代，快速的互联网连接对于成功至关重要。选择美国快速VPS可以为您提供快速、稳定和可靠的网络连接，满足您的在线需求。通过了解您的需求、比较不同的服务提供商和考虑成本，您可以找到最适合您的VPS解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3ae93e68343e0d05c2e63d2aa28b73/" rel="bookmark">
			linux-挂载Samba共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux-挂载Samba共享 1、linux服务器启动Samba共享服务
2、客户端电脑安装cifs-utils
dnf install cifs-utils # 或 yum install cifs-utils 3、挂载共享目录
# 创建挂目录 mkdir /share # 使用mount命令挂在共享目录，-t协议类型 -o用户名密码 共享目录访问地址 挂载目录 mount -t cifs -o username=samba1,password=1234 //192.168.40.133/share /share 4、通过df命令查看
# 查看磁盘情况 df -h # 显示的挂载情况 //192.168.40.133/share 17G 5.3G 12G 31% /share 5、永久挂载（开机自动挂载）
5.1创建认证文件auth.smb文件
# 依次写入用户名、密码、共享域 vim /root/auth.smb username=samba1 password=1234 domain=SAMBA 5.2修改auth.smb的权限
# 只有root用户才能查看和修改 chmod 600 auth.smb 5.3、编辑/etc/fstab
# 共享目录挂载信息 //192.168.40.133/share /share cifs credentials=/root/auth.smb 0 0 #执行命令进行挂载
mount -a
小尾巴~~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd3ae93e68343e0d05c2e63d2aa28b73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c47239d9ebe2e18fd3126e8370d3ee9/" rel="bookmark">
			P3952 [NOIP2017 提高组] 时间复杂度————C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 [NOIP2017 提高组] 时间复杂度题目背景题目描述输入格式输出格式样例 #1样例输入 #1样例输出 #1 提示 解题思路Code运行结果 [NOIP2017 提高组] 时间复杂度 题目背景 NOIP2017 提高组 D1T2
题目描述 小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。
A++语言的循环结构如下：
F i x y 循环体 E 其中F i x y表示新建变量 i i i（变量 i i i 不可与未被销毁的变量重名）并初始化为 x x x， 然后判断 i i i 和 y y y 的大小关系，若 i i i 小于等于 y y y 则进入循环，否则不进入。每次循环结束后 i i i 都会被修改成 i + 1 i +1 i+1，一旦 i i i 大于 y y y 终止循环。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c47239d9ebe2e18fd3126e8370d3ee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb81e3644248a82c0e054b7c91354ab/" rel="bookmark">
			Linux中的定时任务（案例：定时备份和清空）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Linux中的定时任务（案例：定时备份和清空）
crontab 命令 Linux crontab 是用来定期执行程序的命令, 当安装完成操作系统之后，默认便会启动此任务调度命令。crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。 使用语法 crontab -e：打开文字编辑器来设定时程表crontab -l：查看时程表crontab -r：删除时程表crontab -u [指定用户] -[附加上面命令]：对指定用户进行操作 编辑（创建任务）: # 不加 -u 表示编辑当前用户的时程表 $ crontab -e # 编辑wang这个用户的时程表 $ crontab -u wang -e 图例：
输入 -e 编辑命令
回车进入 vi 编辑窗口
默认是空，此处编写你的定时任务，规则在下方描述
查看（查看时程表） # 不加 -u 表示查看当前用户的时程表 $ crontab -l # 查看wang这个用户的时程表 $ crontab -u wang -l 图例：
查看当前用户时程表
查看指定用户时程表
删除（删除时程表） # 不加 -u 表示删除当前用户的时程表 $ crontab -r # 对wang这个用户进行删除操作 $ crontab -u wang -r 图例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb81e3644248a82c0e054b7c91354ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f403b3005f98b0b7316ea5ec43967a3f/" rel="bookmark">
			Git远程仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git远程仓库 gitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名gitHub。
码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快。
GitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作 为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。
配置SSH公钥 生成SSH公钥 ssh-keygen -t rsa 不断回车，如果公钥已经存在，则自动覆盖
获取公钥 cat ~/.ssh/id_rsa.pub 验证是否配置成功 ssh -T git@gitee.com 操作远程仓库 添加远程仓库 此操作是先初始化本地库，然后与已创建的远程库进行对接。
git remote add &lt;远端名称&gt; &lt;仓库路径&gt; # 远端名称，默认是origin，取决于远端服务器设置 # 仓库路径，从远端服务器获取此URL # 例如: git remote add origin git@gitee.com:czbk_zhang_meng/git_test.git 查看远程仓库 git remote 推送到远程仓库 git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ] # 如果远程分支名和本地分支名称相同，则可以只写本地分支 # git push origin master # -f 表示强制覆盖 # --set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。 # git push --set-upstream origin master # 如果当前分支已经和远端分支关联，则可以省略分支名和远端名。 # git push 将master分支推送到已关联的远端分支。 本地分支与远程分支的关联关系 git branch -vv 从远程仓库克隆 如果已经有一个远端仓库，可以直接clone到本地。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f403b3005f98b0b7316ea5ec43967a3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4312d4a9291e69bee0381390d92b4b47/" rel="bookmark">
			同步服务器时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.先安装ntp
yum install -y ntpdate 2.同步时间
方法一：
[root@master1 ~]# ntpdate ntp.aliyun.com 方法二：
[root@master1 ~]# ntpdate 203.107.6.88 注意：直接ntpdate后面接ip要比域名快些。
ntp.aliyun.com (203.107.6.88) cn.pool.ntp.org (139.199.214.202) asia.pool.ntp.org (152.70.69.232) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ba6b038e415683c467bce40b675079/" rel="bookmark">
			通过IDE和jar包运行时加载json配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序中使用了json配置文件，位置在$rootPath/src/main/resources/config.json,
调试时使用IDE，但运行时使用Jar包，加载config.json配置文件的代码如下：
public ConfigParser(String configFileName) throws IOException { try{ InputStream configStream = this.getClass().getResourceAsStream("/"+configFileName); this.jsonConfig = this.objectMapper.readValue(configStream, JsonNode.class); }catch (FileNotFoundException e){ logger.info("configFile: {} is not existed",configFileName); e.printStackTrace(); } } 无论是IDE启动还是打成jar包后用 java -jar启动均成功，仅供参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df78dd3fc6c60d4a93f7242821405e58/" rel="bookmark">
			上门按摩系统：科技与传统融合的新体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在快节奏的现代生活中，人们越来越重视身心健康。传统的按摩方式虽然深受喜爱，却常因时间、地点的限制而无法满足需求。此时，上门按摩系统应运而生，将科技与传统的按摩技艺完美结合，为用户提供更便捷、个性化的服务。
上门按摩系统采用了先进的互联网技术，用户只需通过手机APP预约，即可享受专业的按摩师上门服务。系统通过大数据分析，为用户推荐合适的按摩师和套餐，满足各种需求。同时，为了确保服务质量，系统还引入了评价与反馈机制，让用户可以真实地了解到每位按摩师的专业技能和服务态度。
与传统按摩店相比，上门按摩系统不仅节省了用户的时间和交通成本，还能提供更私密、舒适的环境。而通过技术手段，如在线支付、服务评价等，使得整个服务流程更加便捷、透明。
科技的发展让生活变得更加美好。上门按摩系统正是这一理念的体现，它不仅为消费者带来了全新的体验，也为按摩行业注入了新的活力。随着技术的不断创新和完善，相信上门按摩系统将会在未来的市场中发挥更大的作用，成为人们追求身心健康的新选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014b8a3891cea661da69323de2c3a8d4/" rel="bookmark">
			PHP节假日、PHP实现传入日期和工作日天数，返回工作日天数后的日期，按照假日办公布节假日及周六日补班
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php // 定义常量 define('SATURDAY', 6); // 星期六对应的数字 define('SUNDAY', 7); // 星期日对应的数字 // 假期数组，包含需要排除的日期 $holidays = [ '2024-01-01', // 元旦 // '2024-02-10', // 春节 // '2024-02-11', '2024-02-12', '2024-02-13', '2024-02-14', '2024-02-15', '2024-02-16', // '2024-02-17', '2024-04-04', // 清明节 '2024-04-05', // '2024-04-06', '2024-05-01', // 劳动节 '2024-05-02', '2024-05-03', // '2024-05-04', // '2024-05-05', // '2024-06-08', // 端午节 // '2024-06-09', '2024-06-10', // '2024-09-15', // 中秋节 '2024-09-16', '2024-09-17', '2024-10-01', // 国庆节 '2024-10-02', '2024-10-03', '2024-10-04', // '2024-10-05', // '2024-10-06', '2024-10-07', // 其他节日或假期 ]; // 周六补班日期数组 $weekendWorkdays = [ '2024-05-11', // 补班劳动节 '2024-09-14', // 补班中秋节 '2024-10-12', // 补班国庆节 // 其他周六补班日期 ]; // 周日补班日期数组 $sundayWorkdays = [ '2024-02-04', // 补班春节 '2024-02-18', // 补班春节 '2024-04-07', // 补班清明节 '2024-04-28', // 补班劳动节 '2024-09-29', // 补班国庆节 // 其他周日补班日期 ]; // 时间间隔 $dateInterval = DateInterval::createFromDateString('1 day'); /** * 计算指定日期之后的工作日日期 * * @param string $startDate 起始日期，格式为 YYYY-MM-DD * @param int $daysToAdd 需要添加的工作日天数 * @param array $holidays 假期数组，包含需要排除的日期 * @param array $weekendWorkdays 周六补班日期数组 * @param array $sundayWorkdays 周日补班日期数组 * @return string 最终的工作日日期，格式为 YYYY-MM-DD */ function addWorkingDays($startDate, $daysToAdd, $holidays, $weekendWorkdays, $sundayWorkdays) { // 将起始日期转换为时间戳 $startTimestamp = strtotime($startDate); // 初始工作日天数为 0 $workingDays = 0; while ($daysToAdd &gt; 0) { // 将时间戳转换为日期字符串 $dateString = date('Y-m-d', $startTimestamp); // 获取星期几 $dayOfWeek = date('N', $startTimestamp); if ($dayOfWeek &gt;= SATURDAY) { // 周六和周日 // 检查是否为周六补班日期 if (isset($weekendWorkdays[$dateString])) { $workingDays++; } // 检查是否为周日补班日期 elseif (isset($sundayWorkdays[$dateString])) { $workingDays++; } } elseif (isset($holidays[$dateString])) { // 假期 // do nothing } else { $workingDays++; $daysToAdd--; } // 时间戳加上一天 $startTimestamp += 86400; } // 将时间戳转换为日期字符串 return date('Y-m-d', $startTimestamp - 86400); } // 示例用法 $startDate = '2024-01-01'; $daysToAdd = 10; $resultDate = addWorkingDays($startDate, $daysToAdd, array_flip($holidays), array_flip($weekendWorkdays), array_flip($sundayWorkdays)); echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/014b8a3891cea661da69323de2c3a8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b958c68876b275fae3317734eaac250/" rel="bookmark">
			sentinel-熔断策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sentinel-熔断策略 熔断策略
熔断降级支持慢调用比例、异常比例、异常数三种熔断策略
熔断状态 open：熔断开户，拒绝所有请求half_open：探测恢复状态，如果接下来的一个请求顺利通过则结束熔断，否则继续熔断closed: 熔断关闭 举例一种熔断策略
异常比例
执行逻辑
熔断（OPEN）：当请求数大于最小请求并且异常比例大于设置的阈值时触发熔断，熔断时长由用户设置
探测（HALFOPEN）：当超过熔断时长时，由熔断（OPEN）转为探测（HALFOPEN）
如果接下来的一个请求未发生错误，说明应用恢复，结束熔断，状态由探测（HALF_OPEN）变更为关闭（CLOSED）
如果接下来的一个请求继续发生错误，说明应用未恢复，继续熔断，熔断时长保持一致
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c59e8ad3faa9520abf0ac762e69975/" rel="bookmark">
			突破技术极限：软件测试的挑战与压力！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是吴彦祖，前两天说了测试人员做得好的和不好的地方。《软件测试人员那些不能做的事》 以及《软件测试人员值得赞赏的行为》。今天来为叨叨几句测试中一些困难和阻塞点。 软件测试过程中可能会遇到很多挑战，比如：
1. 需求不明确或不稳定。如果需求文档不完整、不清晰或不一致，或者需求在开发过程中频繁变更，那么测试人员就很难设计和执行有效的测试用例，也很难判断测试结果是否符合预期。
例如，如果需求文档没有明确地定义用户界面的布局和颜色，那么测试人员就无法判断界面是否美观和易用。
​2.缺陷管理不规范或不及时。如果缺陷的报告、跟踪、分配、修复和验证没有一个统一的流程和工具，或者缺陷的处理速度太慢，那么测试人员就会面临很多问题，比如缺陷的重复、遗漏、误报或漏报，以及缺陷的修复引入新的缺陷。
例如，如果缺陷报告没有明确地描述缺陷的重现步骤和影响范围，那么开发人员就很难定位和解决缺陷。
3.测试环境不一致或不可控。如果测试环境和生产环境有很大的差异，或者测试环境经常出现故障或变更，那么测试人员就很难保证测试的有效性和可靠性，也很难复现和排除缺陷。
例如，如果测试环境的网络速度和生产环境的网络速度不一致，那么测试人员就无法准确地评估软件的性能和响应时间。
4. 测试资源不充足或不合适。如果测试人员的数量、技能或经验不足，或者测试工具的功能或兼容性不够，那么测试人员就很难完成测试任务的质量和进度要求，也很难应对测试过程中的各种问题。
例如，如果测试人员没有足够的自动化测试的知识和技能，那么测试人员就无法有效地利用自动化测试来提高测试效率和覆盖率。
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：691998057【暗号：csdn999】 5. 测试范围和优先级不明确或不合理。如果测试人员没有清楚地了解软件的功能、需求和风险，或者测试计划没有合理地分配测试资源和时间，那么测试人员就很难确定测试的范围和优先级，也很难保证测试的完整性和有效性。
例如，如果测试人员没有充分地考虑软件的安全性和可用性，那么测试人员就可能忽略一些重要的测试场景和测试点。
6. 测试数据和测试结果不准确或不一致。如果测试数据的生成、管理和使用没有一个规范的方法和工具，或者测试结果的记录、分析和报告没有一个统一的格式和标准，那么测试人员就很难保证测试数据和测试结果的准确性和一致性，也很难评估测试的质量和效果。
例如，如果测试数据的来源、内容和有效期不清楚，那么测试人员就可能使用错误或过期的测试数据，导致测试结果的失真或误导。
7. 测试沟通和协作不顺畅或不及时。如果测试人员和其他相关人员（如需求分析人员、开发人员、项目经理等）之间没有建立一个良好的沟通和协作机制，或者测试人员和其他相关人员之间的信息交流和反馈不及时或不充分，那么测试人员就很难获取和理解软件的相关信息，也很难解决测试过程中的各种问题。
例如，如果测试人员和开发人员之间没有定期的沟通和同步，那么测试人员就可能错过一些软件的变更或更新，导致测试用例的失效或不匹配。
以上软件测试过程中常见的挑战，明天讲解如何化解这些挑战和压力。
下面是配套资料，对于做【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！
最后： 可以在公众号：程序员小濠 ！ 免费领取一份216页软件测试工程师面试宝典文档资料。以及相对应的视频学习教程免费分享！，其中包括了有基础知识、Linux必备、Shell、互联网程序原理、Mysql数据库、抓包工具专题、接口测试工具、测试进阶-Python编程、Web自动化测试、APP自动化测试、接口自动化测试、测试高级持续集成、测试架构开发测试框架、性能测试、安全测试等。
如果我的博客对你有帮助、如果你喜欢我的博客内容，请 “点赞” “评论” “收藏” 一键三连哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a36e064c6b793243cd7d94be76cb11/" rel="bookmark">
			第89讲：MySQL数据库迁移方面需要考虑的因素以及XBK企业级备份参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MySQL数据库迁移方面需要考虑的因素1.MySQL数据库迁移方面要考虑的因素2.MySQL5.6升级到5.7版本的方法3.MySQL迁移到其他数据库的方法4.为什么要从XBK备份中还原某张表的数据5.从XBK备份中还原某张表的数据6.XtrBackup企业级备份参数 MySQL数据库迁移方面需要考虑的因素 1.MySQL数据库迁移方面要考虑的因素 数据库迁移在企业中也算是比较常见的工作，主要体现在以下几点：
需要从线上环境同步数据到预发布环境。业务上云，在阿里云环境部署了新的MySQL实例，需要将数据迁移到阿里云的MySQL数据库。新老服务器切换，淘汰一批MySQL服务器，新购买了性能很强的MySQL服务器，需要迁移数据。MySQL版本升级需要迁移数据。平台架构中引入了新的技术，例如ES，将MySQL的数据迁移到ES中。 综上所述都是企业中常见的数据迁移工作。
在迁移中需要考虑选择什么工具进行迁移：
数据库与数据库之间的迁移，通常都是使用XBK、mysqldump进行数据迁移，迁移当天先还原全量数据，然后晚上停服，通过Binlog恢复当天产生的新数据，完成迁移idc数据库服务器迁移到阿里云环境，这时使用mysqldump或者是XBK性能都很低，因为要通过互联网传输，可以采用阿里云的DTS迁移工具，快速的进行数据迁移。数据量很大的情况下，可以使用XBK进行备份还原，直接scp数据文件到目标数据。数据迁移也可以使用主从复制的方案。 在迁移过程中还有很多非技术性问题需要考虑：
由于要做数据迁移，迁移过程中是不允许数据写入的，肯定是要发布停服通告，首先要确定此次迁移要花费的时间，然后综合性的评估，最后张贴停服公告。如果迁移有问题，那么回退方案是什么？都要提前考虑好。 任何运维的工作，都分为技术性和非技术性，做好任何一项技术时，都要考虑一切困难发生的因素，减少失败的可能性，技术对于运维都不是难题，非技术性问题一定要好好琢磨。
2.MySQL5.6升级到5.7版本的方法 建议使用mysqldump备份低版本的数据，排除掉所有的系统库，然后将备份在高版本的数据库中还原，最后升级数据字典即可。
只能使用逻辑备份，因为多版本之间的系统结构不同。
3.MySQL迁移到其他数据库的方法 Oracle—&gt;OGG—&gt;MySQL
MySQL—&gt;CSV—&gt;MongoDB
MySQL—&gt;JSON—&gt;MongoDB
4.为什么要从XBK备份中还原某张表的数据 当人员误删除操作时，误删除库的可能性比较小，但是误删除某张表的概率是非常大的，如果误删了某张表，我们也用全备数据去还原，那么是得不偿失的，此时就建议我们从XBK备份中找到某张表，然后只针对这张表进行数据还原。
我们都知道XBK备份的就是数据文件，那么只需要将该表对应的数据文件从备份中找到，然后cp到数据目录即可完成还原。
5.从XBK备份中还原某张表的数据 1）模拟xscjb误删除
[root@mysql ~]# rm -rf /data/mysql/db_1/monday.* 或者 mysql&gt; alter table monday discard tablespace; 2）从备份中找到xscjb的备份文件
[root@mysql ~]# ll /data/dbbackup/all_db_bak/all_bak_2022-07-04/db_1/monday.* -rw-r----- 1 root root 8720 7月 4 11:44 /data/dbbackup/all_db_bak/all_bak_2022-07-04/db_1/xscjb.frm -rw-r----- 1 root root 98304 7月 4 11:34 /data/dbbackup/all_db_bak/all_bak_2022-07-04/db_1/xscjb.ibd 3）将xscjb的备份文件还原到数据目录中
[root@mysql ~]# \cp /data/dbbackup/all_db_bak/all_bak_2022-07-04/db_1/monday.* /data/mysql/db_1/ [root@mysql ~]# chown -R mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5a36e064c6b793243cd7d94be76cb11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9dee9d5d3dc2e5acccc038c674e6b2d/" rel="bookmark">
			如何使用ActiveMQ详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ActiveMQ 是一款流行的消息中间件，支持多种通信协议和消息模式，包括点对点、发布/订阅、事务处理等。下面是使用 ActiveMQ 的基本步骤： 1. 下载和安装 ActiveMQ： • 前往 ActiveMQ 的官方网站（http://activemq.apache.org/download.html）下载适用于你的操作系统的二进制文件。 • 解压下载的文件到一个目录中。 2. 启动 ActiveMQ 服务器： • 进入 ActiveMQ 解压后的文件夹，在终端或命令提示符中进入 bin 目录。 • 执行以下命令启动 ActiveMQ 服务器： •Windows：activemq.bat start •Unix/Linux/Mac：./activemq start 3. 访问 ActiveMQ 的 Web 控制台： • 在浏览器中输入 http://localhost:8161，访问 ActiveMQ 的 Web 控制台。 • 输入默认的用户名和密码：admin/admin。 4. 创建队列或主题： • 在 Web 控制台中，点击 "Queues" 或 "Topics" 页面。 • 点击 "Add a new Queue" 或 "Add a new Topic" 按钮。 • 输入要创建的队列或主题的名称，并点击 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9dee9d5d3dc2e5acccc038c674e6b2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db97b3016e4b94197670bc77291a96d/" rel="bookmark">
			PeerStream全新GUI配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84f3ceb26af8a2b6747ca7afaa2a65dd/" rel="bookmark">
			IDEA入门（四） IntelliJ Idea 常用快捷键 超实用!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 自动补充代码
2. 查询相关快捷键
3.其他快捷键
4.svn快捷键
5.调试快捷键
1. 自动补充代码 fori/sout/psvm+Tab -&gt; 循环、System.out、main方法等boilerplate样板代码 user.for+Tab -&gt; for(User user : users)
user.getBirthday().var+Tab -&gt; Date birthday = user.getBirthday();
Ctrl+Alt+O ------- 优化导入的类和包 Alt+Insert ------- 生成代码(如get,set方法,构造函数等) 或者右键（Generate） Ctrl+Alt+T ------- 生成 if、if/else、while、do/while、for、try/catch、try/finally、try/catch/finally、synchronized、Runnable、{}等，如果不生效，可以尝试使用Ctrl+Win+Alt+T
Ctrl + O 重写方法 Ctrl + I 实现方法 Ctr+shift+U 大小写转化 ALT+回车 导入包,自动修正 Ctrl+空格 代码提示 CTRL+J 自动代码 Ctrl+Shift+J，整合两行为一行 CTRL+空格 代码提示 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 ALT+INSERT 生成代码(如GET,SET方法,构造函数等) CTRL+E 最近更改的代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+Q，可以看到当前方法的声明 Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84f3ceb26af8a2b6747ca7afaa2a65dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d3b772437479e1c9b5a02c4395da20d/" rel="bookmark">
			k8s helm ingress-nginx Error: template: ingress-nginx/templates/controller-role “update-status“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： k8s，使用helm包管理器安装ingress-nginx时，安装文件出错
helm 版本：Version:“v3.2.3”k8s 版本：Kubernetes v1.23.6ingress-nginx chart version：4.9.0app version：1.9.5 问题描述 前面都按网上的教程做，没有什么大问题
最后一步执行安装命令
helm install ingress-nginx ./ingress-nginx -n ingress-nginx 命令执行失败，报错
Error: template: ingress-nginx/templates/controller-role.yaml:48:9: executing "ingress-nginx/templates/controller-role.yaml" at &lt;ne (index .Values.controller.extraArgs "update-status") "false"&gt;: error calling ne: invalid type for comparison 原因分析： 问题可能出现在对.Values.controller.extraArgs[“update-status”] 的比较上，其中 .Values.controller.extraArgs 是一个值的集合，而 “update-status” 则是要比较的键。而比较的目的是将其与字符串 “false” 进行比较。
简单地说，就是value.yaml文件中有一个值缺少或者设置不对，.Values.controller.extraArgs[“update-status”] ，就是这个
解决方案： 前言：我在网上貌似找不到相应的解答，所以我也就硬着头皮改value.yaml，下面是我尝试的方法，而且ingress-nginx确实成功运行起来了，但我不确定我的修改到底会造成什么后果，我暂时没搞懂背后的具体原理，仅作为参考
首先找到value.yaml文件，value.yaml就在 ingress-nginx 的包中
编辑value.yaml，根据报错信息（Values.controller.extraArgs[“update-status”]）与yaml文件的结构找到位置 ，即value文件 controller下的extraArgs的位置 小技巧，先使用编辑器查找功能找到 controller，再使用查找功能找到 extraArgs
# 如果事先没有修改value.yaml文件 extraArgs: {} 我尝试将其修改为如下，详情看上图 extraArgs： update-status: "true" # 有兴趣的也可以改成false试一下，我就没再实验的 至于为什么这样修改，我的想法是，报错信息说这里的 update-status 与某个值比较失败（invalid type for comparison），但文件里面又没有这个值，我又找不到别的解决方法，我干脆就直接在这里加上一个值 update-status: “true”，再次执行安装指令 helm install ingress-nginx .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d3b772437479e1c9b5a02c4395da20d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e142ab68d9b83913f0f5faef367170f/" rel="bookmark">
			C/C&#43;&#43;实验机位预约登记信息管理系统[2024-01-15]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++实验机位预约登记信息管理系统[2024-01-15] 实验机位预约登记信息管理系统
(1)任务描述
编写程序，模拟计算机实验室中实验机位的预约登记信息管理。
(2)功能要求
1.假设实验室有30台机器供学生预约上机使用。可以预约的时间段是早8:00到晚20:00之间，每个预约时间段为2小时。每周一到六实验室开放，每次至少提前一小时或最多一周预约或取消预约。
2.每次预约前，显示当前时间和日期。
3.根据选择进行预约登记或取消预约登记。
4.如果是预约，则等待输入预约的日期，列出预约日可用机位信息。等待预约，成功，预约信息保留，给出提示信息；不预约退出，则提醒没有预约。
5.如果是取消预约，则等待输入上次预约留下的预约身份编号，列出该编号已有的预约，等待取消处理，成功，删除预约信息，提示正确取消；不取消预约退出，则直接退出。
6.程序可以查看全部已有的预约信息，或查看指定时间段的预约信息，信息列出时按预约日期先后排序，或按预约人身份编号排序，或按机位编号大小排序。
7.管理的信息中已经过去的时间段，继续保留着，无需管理。
(3)设计提示
机位预约登记信息管理至少需要管理的信息格式是:关键字预约人身份编号、预约时间(按年月日时分记录)、预约机位、预约要用的时间段、取消标志。
源码联系UP主 -&gt; https://space.bilibili.com/329101171
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc767a42cf229070f47f58698be624fd/" rel="bookmark">
			Ansys Zemax | 如何使用光学制造全息图修正像差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		附件下载 联系工作人员获取附件
本文介绍了利用光学全息图降低单透镜像差的方法。在描述了表示全息图构造光束的两个 ZMX 文件之后，本文演示了如何在重现文件中设置 OFH。然后解释了如何轻松地从重现文件中访问任何结构造光束变量，以实现衍射受限单透镜的设计。
简介 光学全息图 (OFH) 是OpticStudio中最通用的全息图模型。这个模型需要使用两个ZMX文件作为构造光，一个ZMX文件表示全息图重现文件。本示例所需的三个文件可以在本文的附件中找到。
初始系统 本文所考虑的系统(StartingLens.zmx)由一个简单的双凸透镜组成，工作波长为0.633 nm，像平面位于其近轴焦点处。
从 OPD 光扇图可以看出，球差是主要的像差：
通过在单透镜的前表面放置光学全息图 (OFH)，可将其性能优化至衍射极限。OFH 需要使用三个 ZMX 文件：
放置 OFH 的重现文件
光线 1 的构造文件
光线 2 的构造文件
在这个例子中，重现文件是“ StartingLens.zmx ”，包含放置 OFH 的单透镜。全息图构造文件名称为“ OFHSphericalCorrector_1.zmx ”和“ OFHSphericalCorrector_2.zmx ”。这些 ZMX 文件满足 OFH 构造文件所需的命名规则（它们的文件名前缀相同，但在末尾附加了“ _1 ”和“ _2 ”的后缀）。
构造文件 “ OFHSphericalCorrector_1.zmx ”是构造文件 1，只包含一个准直光束入射透镜。“ OFHSphericalCorrector_2.zmx ”是构造文件 2，它类似于构造文件 1，但另外包含一个位于透镜前表面前的相位板。该相位板使用 Zernike Fringe 相位表面 (Zernike Fringe Phase surface) 建模，该表面的所有项最初都被设为零。将分别表示离焦和三阶球差的第 4 项和第 9 项设为变量，以便以后进行适当的优化。
上图是两个构造文件只绘制到镜头的前表面的布局图，这也是每个文件中的系统光阑。光阑代表假定的两个构造光相互干涉的表面，只有在构造文件中光阑位置处的光线交互位置的向量才能决定全息图的属性。从 OFH 的角度来看，构造文件中所有在光阑后的表面都将被忽略，所以光阑后的表面在布局图中为了清晰显示都被隐藏了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc767a42cf229070f47f58698be624fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc166b7c5e3f5d1a90a057ed7132941/" rel="bookmark">
			Linux上常用网络操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主机名配置 hostname 查看主机名
hostname xxx 修改主机名 重启后无效
如果想要永久生效，可以修改/etc/sysconfig/network文件
IP地址配置 ifconfig 查看(修改)ip地址(重启后无效)
ifconfig eth0 192.168.12.22 修改ip地址
如果想要永久生效,修改 /etc/sysconfig/network-scripts/ifcfg-eth0文件,文件内容如下：
DEVICE=eth0 #网卡名称 BOOTPROTO=static #获取ip的方式(static/dhcp/bootp/none) HWADDR=00:0C:29:B5:B2:69 #MAC地址 IPADDR=12.168.177.129 #IP地址 NETMASK=255.255.255.0 #子网掩码 NETWORK=192.168.177.0 #网络地址 BROADCAST=192.168.0.255 #广播地址 NBOOT=yes # 系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。 ​​​​​​​域名映射 /etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用,相当于windows系统的C:\Windows\System32\drivers\etc\hosts文件的功能。
/etc/hosts文件内容如下：
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 192.168.19.123 oesoft ​​​​​​​网络服务管理 service network status 查看指定服务的状态
service network stop 停止指定服务
service network start 启动指定服务
service network restart 重启指定服务
service --status–all 查看系统中所有后台服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fc166b7c5e3f5d1a90a057ed7132941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19fb177975d98f105d5e3b9ba958a8a4/" rel="bookmark">
			KT148A语音芯片智能锁扩展语音地址以及如何支持大量小文件的打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、语音芯片应用于智能锁的需求 智能锁的语音播放需求中，有很多需要多国语言合并在一起的需求
其中语音文件数多，并且每个语音文件小的特点
如果使用OTP的语音芯片，就很麻烦，因为用户不可烧录，调试也很繁琐
同时大容量的又很贵，所以使用KT148A-sop8的flash型语音芯片就是最优的解决方案
解决KT148A语音芯片应用于智能锁的两个潜在的需求
1、语音文件数量，超过手册给的233的语音地址，假如需要扩展地址，增加到500以上怎么办？
2、客户的语音很多，但是都很小，按照原有的打包方式，非常的占空间，导致空间不够
解决方案 2.1 地址超过233的解决方案 ==》新增F4指令，详见手册“KT148A语音芯片使用手册_V5.pdf”
F4指令存在的意义，是语音超223的数量之后没有地址可用的问题，所以新增此指令。举例说明：
1、如果指定播放291地址的语音，就发送F4 01 23 【01=0x01 高字节】【23=0x23低字节】
==》其中F4为识别码，01 23 组成位0x123 = 291 ，代表第291条语音播放
2、如果指定播放291个语音，就发送F4 04 98 ==》发送F4 04 98，其中04 98 组成位0x498 = 1176 ，代表第1176条语音播放
3、这个F4指令的长度，只能是三个字节【不能多也不能少】，收满F4 01 23之后，立刻开始执行播放
4、收到F4指令之后，会自动等待100ms，如果在这个100ms之内收到0x01这样的语音命令，还会继续再等待100ms ，
==》如果收第2个地址数据0x23，就代表收满了= 0x0123，立刻执行播放291地址语音
==》超过100ms还没有收到地址数据，则认为这一次通讯失败，因为只收到0x11
语音地址，不超过233，则不需要使用这条扩展指令。询问客户，这种操作逻辑，客户可以接受
2.2 更换打包bin文件的方式--工具端 这个步骤的处理，需要联系我们来修改，其实也不复杂，也支持批量烧录
第1步，先把目标文件压缩，将压缩之后的文件发f1a格式，全部拷贝至“audio”文件夹里面
第2步，打开“pRFiles.exe”导入文件，生成“AUDIO.lst”
第3步：双击批处理，生成“dir_story”，注意是没有后缀的
总结 缺点就是不再支持串口下载语音文件。语音的总空间，如上图，看这里就知道了
所以，客户前期的测试，包含语音播放的效果，通讯功能等等
都可以先用默认的版本，去调试
最后确认得差不多了，可以联系我们换一种方式，提供样品给您做最后的确认和测试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b437d6ea0ab16f1f900801642239e6e/" rel="bookmark">
			Mybatis使用IN语句查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介
在SQL语法中如果我们想使用in的话直接可以像如下一样使用:
select * from HealthCoupon where useType in ( '4' , '3' ) 但是如果在MyBatis中的使用in的话,像如下去做的话,肯定会报错:
Map&lt;String, Object&gt; selectByUserId(@Param("useType") String useType) &lt;select id="selectByUserId" resultMap="BaseResultMap" parameterType="java.lang.String"&gt; select * from HealthCoupon where useType in (#{useType,jdbcType=VARCHAR}) &lt;/select&gt; 其中useType="2,3";这样的写法,看似很简单,但是MyBatis不支持这样操作，可以用$进行替换，如下方式即可运行
Map&lt;String, Object&gt; selectByUserId(@Param("useType") String useType) &lt;select id="selectByUserId" resultMap="BaseResultMap" parameterType="java.lang.String"&gt; select * from HealthCoupon where useType in (${useType,jdbcType=VARCHAR}) &lt;/select&gt; #方式能够很大程度防止sql注入，$方式无法防止sql注入，所以还是推荐使用#方式，参考以下三种方式。
MyBatis中提供了foreach语句实现IN查询,foreach语法如下:
foreach语句中， collection属性的参数类型可以使：List、数组、map集合
​ collection： 必须跟mapper.java中@Param标签指定的元素名一样
​ item： 表示在迭代过程中每一个元素的别名，可以随便起名，但是必须跟元素中的#{}里面的名称一样。
index：表示在迭代过程中每次迭代到的位置(下标)
open：前缀， sql语句中集合都必须用小括号()括起来
​ close：后缀
separator：分隔符，表示迭代时每个元素之间以什么分隔
正确的写法有以下几种写法:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b437d6ea0ab16f1f900801642239e6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3e928e8c3e0c51691a0945b333bc01/" rel="bookmark">
			鸿蒙开发工具DevEco Studio的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙开发工具的安装与使用 1、下载 根据自己的电脑下载对应版本的IED：官网：HUAWEI DevEco Studio和SDK下载和升级 | HarmonyOS开发者
下载后进行安装安装路径不要有中文，空格，特殊符号
下载之后得到的是一个压缩文件，进行解压，点击exe文件进行安装。安装的时候可能会用到Node.js，需要安装较新的版本，不兼容低版本，安装的时候也可以更具提示来安装。
步骤：
直接next。 选择安装路径。
勾选选项。
点击install安装开发软件。
安装完成之后，打开DevEco Studio软件，选择File-&gt;setting-&gt;SDK，如下图所示，安装最新版的SDK，点击Apply进行下载：
然后点击Create Project看看那些环境还没用设置，如图，点击Set up now来将需要安装的环境进行逐个安装。
现在就安装完成了，就可以新建项目了。
安装一些组件的时候有点漫长，所以请耐心等待。
2、Hello World 新建一个项目，项目名必须是无中文的目录，然后等待加载完毕即可
点击next
选择Finish
创建完成之后的软件结构：
点击右侧导航栏的Preview按钮，即可Hello World。
3、安装虚拟鸿蒙系统手机 我们可以预览，但是发现不可以运行，就需要安装虚拟手机
点击Device Mannagr 安装虚拟设备（以手机为例） 选择默认即可，点击new Emulator进行如下操作 点击启动设备即可（绿色三角） 现在就可以点击运行项目在虚拟手机上了。
模拟设备上运行：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87e50eca8904c4aae9dc86d0c667150/" rel="bookmark">
			得力 电子温湿度计 LE503-WH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eaaf38b04c1f65e75bc1cd385bee827/" rel="bookmark">
			硅谷2024年裁员已超7500人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天早上醒来，看到这么一条新闻：硅谷打工人迎最惨开年。
2024 年刚过去两周，美国硅谷裁减的员工人数就已经达到 7500 人。科技巨头谷歌、亚马逊都在上周宣布大规模裁员，影响到众多部门。此外，社交平台 Discord 表示将裁员 17%，游戏服务商 Unity Software 宣布将裁员 25%。
据 Layoffs.fyi 数据，2024 年，美国科技业已有超 7500 名员工失业，而在 2023 年，科技行业共裁员 262582 人，2022 年的裁员人数则为 164969 人。裁员的同时，硅谷还在不断加大对人工智能的投入。
在撤销数百个岗位前几个月，谷歌和亚马逊分别向 AI 初创公司 Anthropic 投资了数十亿美元。
Layoffs.fyi 公司创始人 Roger Lee 指出，科技业裁员与多重因素有关，包括疫情期间的过度招聘、高利率环境、科技业低迷等。不过，人工智能确实在裁员潮中扮演着越来越重要的角色。
看到这个数据确实挺吓人的，比如：2023 年美国科技行业公裁员 262582 人，26 万多，但是，也有硅谷的人说光看裁员数意义不大，得看裁员之后，再就业的情况怎么样？硅谷看似裁员这么多，按道理房价应该下跌才对啊？好像硅谷的房价并没有下降，这说明，硅谷的打工人受裁员影响不大。
我不在硅谷，我不知道具体情况，不过，我在想：人工智能在裁员当中扮演的角色到底有多重要呢？这个有具体数据吗？
不可否认的是：现在全球大环境都不咋地， IT 行业的打工人肯定过剩了。
AI 技术让程序平民化，靠记忆力和逻辑推导的技术逐渐消失，AI 让我们看到，记忆力和逻辑推导，人类是那么弱小。
有人说：AI 从技术逐渐升华为工具，更加推动工业革命 4.0 时代的到来。
我不是一个悲观主义者，我一直认为既然是技术革命，一些行业或者岗位会消失的同时，新的技术也会诞生很多新的岗位。所以，好像也不用那么悲观。
但是，仔细思考一下，有时候，我也恍惚，可能 AI 革命和以往的互联网革命、移动互联网革命有所不同。
互联网、移动互联网革命它的诞生不仅仅是效率工具，更是一个大的平台，也就是它们本身的诞生并不是以代替人为目的的。就以实体店和电商的关系为例，看似互联网电商让实体店变得萧条，但是，它并没有真正的消失，而是换了一种形态而已，搬到了互联网上。
但是，AI 好像并不是，AI 从研究到诞生，以及发展好像就是要代替人的。虽然新的技术会诞生很多新的岗位，但是，消失的岗位会不会更多呢？
这是我的一个疑问，大家怎么看？
点击下方公众号卡片，关注我
在公众号对话框，回复关键字 “1024”
有惊喜
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760671b01e33024595de250605b4d733/" rel="bookmark">
			【Vue3】如何封装一个超级好用的 Hook ！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将通过介绍什么是 Hook、如何在 Vue 使用 Hook，以及在实践场景中如何封装自己的 Vue Hook，带你走进 Hook 的世界，写出更优雅的代码。如果你觉得这篇文章写的不错，可以点赞支持一下，如果文章中存在不足（代码量多，难免出现 bug，咳咳），欢迎在评论区指出！
什么是 Hook Vue3 官方文档是这样定义组合式函数的。A "composable" is a function that leverages Vue's Composition API to encapsulate and reuse stateful logic.，一个利用 Vue 的组合式 API 来封装和复用具有状态逻辑的函数。
这个概念借鉴自 React 的 Hook。在 16.8 的版本中，React 引入了 React Hook。这是一项特别强大的技术，通过封装有状态的函数，极大提高了组件的编写效率和维护性。在下文中也是使用 Hook 来替代“组合式函数”进行叙述。
在开发中，我们经常会发现一些可以重复利用的代码段，于是我们将其封装成函数以供调用。这类函数包括工具函数，但是又不止工具函数，因为我们可能也会封装一些重复的业务逻辑。以往，在前端原生开发中，我们封装的这些函数都是“无状态”的。为了建立数据与视图之间的联系，基于 MVC 架构的 React 框架和基于 MVVM 的 Vue 框架都引入了“状态”这一概念，状态是特殊的 JavaScript 变量，它的变化会引起视图的变化。在这类框架中，如果一个变量的变化不会引起视图的变化，那么它就是普通变量，如果一个变量已经被框架注册为状态，那么这个变量的变化就会引发视图的变化，我们称之为响应式变量。如果一个函数包含了状态（响应式变量），那么它就是一个 Hook 函数。
在具备“状态”的框架的基础上，才有 Hook 这一说。Hook 函数与普通函数的本质区别在于是否具备“状态”。
比如，在一个 Vue 项目中，我们可能同时引入了 lodash 库和 VueUse 库，这两个库都是提供一些方便的工具函数。工具函数库只引入一个不行吗，不会重复吗？或许不行，因为 lodash 的函数是无状态的，用来处理普通变量或者响应式变量中的数据部分，而 VueUse 提供的 api 都是 Hook。如果你的项目中既有普通变量又有响应式变量，你或许就会在同一个项目中同时接触到这两个库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/760671b01e33024595de250605b4d733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78eeebf0899e5a25f4ed18cb489721e0/" rel="bookmark">
			QT联合Halcon第一个项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT联合Halcon第一个项目 1、创建新项目firstqthalcon
2、命名firstqthalcon
3、选择make
4、Mainwindow和dialog都可以
5、关键，要选择MSVC
6、工程配置文件添加如下代码
INCLUDEPATH += $$PWD/include INCLUDEPATH += $$PWD/include/halconcpp LIBS += $$PWD/lib/x64-win64/halconcpp.lib LIBS += $$PWD/lib/x64-win64/halcon.lib 7、添加头文件和命名空间
#include "halconcpp/HalconCpp.h" #include "Halcon.h" #include &lt;HDevThread.h&gt; using namespace HalconCpp; 8、将Halcon安装路径下的lib和include拷贝到当前项目目录下
9、头文件添加变量
HObject ho_Image; HTuple hv_Width,hv_Height,hv_WindowHandle; 9、添加Pushbutton，转到槽
10、槽函数
void MainWindow::on_pushButton_clicked() { HObject hImage; ReadImage(&amp;hImage , "D:\\image\\1.png"); HalconCpp::OpenWindow(0,0,640,640 ,0, "visible" , "black",&amp;hv_WindowHandle); DispImage(hImage , hv_WindowHandle); } 运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e32973c1a48c0f186d60727620f964a/" rel="bookmark">
			ArcGIS JSAPI 学习教程 - 初识 ArcGIS Maps SDK for JavaScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cesium 实战 - 自定义视频标签展示视频 JSAPI 介绍JSAPI HelloworldJSAPI 优势劣势在线示例 近期由于工作需要，开始接触 ArcGIS Maps SDK for JavaScript（以下简称 JSAPI），为了更好的系统的学习，准备开设专栏，作为学习记录。
本文作为第一篇，首先介绍一下 JSAPI 的概览、官方示例以及官方 API。
然后完成 JSAPI 的 helloworld 以及注意事项。
最后简述一下 JSAPI 的优势劣势。
JSAPI 介绍 1. JSAPI 概览
ArcGIS Maps SDK for JavaScript 是 ESRI 公司开发的 Web 端地图库，目前最新版本为 4.28，下文简称 JSAPI。
JSAPI 包含二维和三维部分，其中二维跟 Openlayers 相当，三维跟 Cesium 相当。
不同的是，JSAPI 是闭源的，但是可以免费使用！
JSAPI 为了方便大家使用，提供了一系列教程，其中 API 和 示例代码最常用，下边分别介绍。
2. 官方示例
官方示例：Sample Code
3. 官方 API
官方 API：API Reference
4. 官方资源地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e32973c1a48c0f186d60727620f964a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba0165f086a8edc7d0951f3a1a760ac/" rel="bookmark">
			一款一键渗透全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明
由于传播、利用本文章所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，文章及作者不为此承担任何责任，一旦造成后果请自行承担！如有侵权烦请告知，我们会立即删除并致歉。谢谢！
项目简介
Osmedeus 是一个用于进攻性安全的工作流引擎，允许您在各种目标（包括域、URL、CIDR 和 GitHub 存储库）上构建和运行侦察系统。它的设计目的是建立坚实的基础，并具有自动适应和运行的能力，以执行侦察任务
集成工具
子域名收集工具Amass
子域名收集工具subfinder
POC扫描工具nuclei
http工具集，网站基本信息获取
快速提取网段内网站证书信息
网页爬虫httpx
tlsxkatana
DNS枚举工具dnsx
扩展子域名构建alterx
从第三方获取网站相关接囗gau
网站fuzz工具ffuf
网页爬虫工具gospider
自动化测试漏洞jaeles
OSINT 工具metabigor
快速获取接口的基本信息goverview
网站截图工具aquatone
网站截图工具gowitness
从 github寻找凭据trufflehog
查询 git 目录泄漏问题 gitleaks
子域名收集findomain
多个二进制小工具，比如 massdns、rustscan
安装
请注意，您需要一些基本工具，例如以 root 身份登录才能开始curl, wget, git, zip
bash &lt;(curl -fsSL https://raw.githubusercontent.com/osmedeus/osmedeus-base/master/install.sh) 安装完成后，通过命令
osmedeus health 查看是否安装成功，以及其默认工作流：
还有内置的工作模块：
从源代码构建引擎
确保您已安装golang &gt;= v1.17
go install -v github.com/j3ssie/osmedeus@latest Osmedeus的主要特点
显著加快您的侦察过程
整理扫描结果
高效定制和优化您的侦察流程
与新的公共和私有工具无缝集成
易于跨大量目标进行扩展
易于在多个位置同步结果
用法
# Example Scan Commands: ## Start a simple scan with default 'general' flow osmedeus scan -t sample.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fba0165f086a8edc7d0951f3a1a760ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e346eb34ee0414066391b4d68d24c8a/" rel="bookmark">
			Tomcat教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Tomcat教程 tomcat简介windows安装tomcatlinux安装tomcattomcat目录结构在IDEA下面配置tomcat在tomcat中部署一个web项目使用IDEA创建一个web项目部署到tomcattomcat端口配置tomcat虚拟主机配置tomcat用户管理tomcat日志tomcat主配置文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7e65eb291f62074effee2407fe92e9/" rel="bookmark">
			mathtype2024版本下载与安装（mac版本也包含在内）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装包补丁主要是mathtype的安装包，与它的补丁。
详细安装过程：
step1：
使用方法是下载完成后先安装MathType-win-zh.exe文件，跟着步骤走直接安装就行。
step2：
关闭之后，以管理员身份运行MathType7PJ.exe文件，就可以成功安装mathtype公式编辑软件了。
step3：
将mathtype插入到word的加载项中，使用起来更带劲~
MathType2024 Win-安装包下载如下:
https://wm.makeding.com/iclk/?zoneid=55026
MathType2024Mac-安装包下载如下:
https://wm.makeding.com/iclk/?zoneid=55027
这一步主要需要复制两个文件到word的信任位置中——先找到信任位置，打开word，点击选项，按着下面步骤操作！
复制粘贴这个位置，win+e键，打开一个新的文件窗口，粘贴到如下位置，enter键就可以到指定的位置（后面我们只需要将mathtype需要的文件放在这里就可以啦）
小编这里已经把文件放到这个位置了，下面来看看这两个文件在哪，从哪儿移到这里！
找到安装mathtype的安装路径，我是安装在C盘，因为占用小，安装在C盘的效果更好。
分别在这两个文件里面，因为我的word是64位的，所以将64文件路径下的文件复制到上述文件夹中！
最后打开word，就发现mathtype在里面了
可能会出现word里面不在，小编遇到这种情况，就是禁用了mathtype的加载项。 进入“选项”，可以看到加载项，选择“word”加载项 ，并点击“转到”
最后勾选mathtype commands 2016.dotm，点击确定就可以嘞！
mathtype使用技巧
常用快捷键
ctrl+alt+Q 内联（指的是输入的公式在段落中）
alt+Q显示（指的是公式居中）
alt+shift+Q右编号（指的是公式居中，并右编号）这个操作很有用，就不用使用word制表位了（制表位操作没有这个简单易操作）
如下图，如何利用右编号，首先插入一个分节符
再使用右编号，输入公式，就会是下面的效果！
假设在下一节，需要从2.1开始，于是在下面在插入一个分节符，输入公式会是下面的效果!
如果你不想1.1、1.2、2.1这样显示，你可以更改样式!
如下图，根据你的需要，观察预览，选择你需要的样式!
更改之后的效果!
这样使用右编号还有一种好处是，可以自动编号，从中间插入公式，不用担心编号顺序的问题。
在mathtype里面的快捷键 ALT+F4 关闭mathtype窗口
ctrl+L 下标
ctrl+H 上标
ctrl+J 上下标
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b1165ebab7c83add6daaa33706f634/" rel="bookmark">
			128线激光用做4D毫米波分类真值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		128线激光推理的结果作为4D毫米波雷达的真值，但不同类别的尺寸存在重叠，存在分类错误可能。
1.小车，类别0
点数0～70
长度2m～7m
宽度1.6m～2.7m
2.大车，类别1
点数0～120
长度4.5m～14m
宽度1.9m～3.3m
3.两轮车，类别4
点数0～24
长度1.4m～2.4m
宽度0.55m～1.1m
4.行人，类别5
点数0～14
长度0.5m～1.5m
宽度0.55m～0.9m
总体来看，128线激光标注的真值可靠性较高，但仍存在一些小问题，会对4D雷达分类结果造成一定影响，如果要求更高的标注准确度和精度，则需要提升128线激光i雷达目标检测的性能，或者人工辅助标注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d89cadc7bc351609b61d31349253e3a/" rel="bookmark">
			微信商家转账到零钱如何开通？场景说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		商家转账到零钱是什么？
通过商家转账到零钱这个功能，如果我们系统需要对用户支付费用，比如发放佣金、提成、退款之类的，可以直接转账到用户的微信零钱。
【商家转账到零钱】是【企业付款到零钱】的升级版，2022年5月18号之前名称为【企业付款到零钱】，之后升级为【商家转账到零钱】。商家转账到零钱功能的作用有方便快捷、资金直接转入到用户的零钱中、减少了银行转账的繁琐流程。同时，对于用户来说，也可以方便地管理和使用收到的资金，不需要提供银行信息之类的。
商家转账到零钱的使用场景有哪些？
主要是用于小程序商城的分销功能，小程序里的用户帮助把产品推广出去，需要给别人用户，有这个功能以上，用户在小程序里申请提现，管理员可以把佣金在小程序管理后台直接发给用户，不用手动转账，非常方便。
商家转账到零钱的申请条件
1.申请商家转账到零钱必须为 企业主体。
2.一般申请场景为 分销返佣或者现金营销。单次提现最大额度是500元。
3.审核周期一般三到七个工作日，只需要扫码操作即可
商家转账到零钱怎么开通？
商家转账到零钱的审核时长
一般一次过的话是3个工作日左右，如果被驳回第二次提交，做到一个月的准备，亲身经历（也是第二次提交），12-02提交的，到12-28号下来的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603586360b152a4f467321d66e84f189/" rel="bookmark">
			Rust-泄漏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++中，如果引用计数智能指针出现了循环引用，就会导致内存泄漏。而Rust中也一样存在引用计数智能指针Rc,那么Rust中是否可能制造出内存泄漏呢?
内存泄漏 首先，我们设计一个Node类型，它里面包含一个指针，可以指向其他的Node实例：
接下来我们尝试一下创建两个实例，将它们首尾相连：
到这里写不下去了，Rust中要求，Box指针必须被合理初始化，而初始化Box的时候又必须先传入一个Node实例，这个Node的实例又要求创建一个Box指针。这成了“鸡生蛋蛋生鸡”的无限循环。
要打破这个循环，我们需要使用“可空的指针”。在初始化Node的时候，指针应该是“空”状态，后面再把它们连接起来。我们把代码改进，为了能修改node的值，还需要使用mut:
编译，发生错误：“error:use of moved value:node2”。
从编译信息中可以看到，在node1.next =Some(node2);这条语句中发生了move语义，从此句往后，node2变量的生命周期已经结束了。
因此后面一句中使用node2的时候发生了错误。
那我们需要继续改进，不使用node2,换而使用node1.next,代码改成下面这样：
编译又发生了错误，错误信息为：“error:use of partially moved value:node1”。
这是因为在match语句中，我们把node1.next的所有权转移到了局部变量n中，这个n实际上就是node2的实例，在执行赋值操作n.next =Some(node1)的过程中，编译器认为此时node1的一部分已经被转移出去了，它不能再被用于赋值号的右边。
看来，这是因为我们选择使用的指针类型不对，Box类型的指针对所管理的内存拥有所有权，只使用Box指针没有办法构造一个循环引用的结构出来。于是，我们想到使用Rc指针。同时，我们还用了Drop trait来验证这个对象是否真正被释放了：
编译依然没有通过，错误信息为：“error:partial reinitialization of uninitialized structure’node2`”,还是没有达到目的。继续改进，我们将原来“栈”上分配内存改为在“堆”上分配内存：
编译再次不通过，错误信息为：“error:cannot assign to immutable field”。
通过这个错误信息，我们现在应该能想到，Rc类型包含的数据是不可变的，通过Rc指针访问内部数据并做修改是不可行的，必须用RefCell把它们包裹起来才可以。
继续修改：
因为我们使用了RefCell,对Node内部数据的修改不再需要mut关键字。编译通过，执行，这一次屏幕上没有打印任何输出，说明了析构函数确实没有被调用。
至此，终于实现了使用Rc指针构造循环引用，制造了内存泄漏。
虽然构造循环引用非常复杂，但是可能性还是存在的，Rust无法从根本上避免内存泄漏。
通过循环引用构造内存泄漏，需要同时满足三个条件：
使用引用计数指针；存在内部可变性；指针所指向的内容本身不是’static的。 当然，这个示例也说明，通过构造循环引用来制造内存泄漏是比较复杂的，不是轻而易举就能做到的。
构造循环引用的复杂性可能也刚好符合我们的期望，毕竟从设计原则上来说：鼓励使用的功能应该设计得越易用越好；不鼓励使用的功能，应该设计得越难用越好。
Easy to Use,Easy to Abuse.
对于上面这个例子，要想避免内存泄漏，需要程序员手动把内部某个地方的Rc指针替换为std::rc::Weak弱引用来打破循环。这是编译器无法帮我们静态检查出来的。
内存泄漏属于内存安全 在编程语言设计这个层面，“内存泄漏”是一个基本上无法在编译阶段彻底解决的问题。在许多场景下，什么是“内存泄漏”、什么不是“内存泄漏”,本身就没有一个完全客观的评判标准。
它实质上跟程序员的“意图”有关。程序很难自动判定出哪些变量是以后还会继续用的，哪些是不再被使用的。
即便是在使用GC做内存管理的环境下，程序员也有可能不小心将不应该被使用的变量错误引用，造成无法自动回收的问题。
因为GC判定一个对象是否可回收的标准是，这个对象有没有被“根”对象直接或者间接引用。
假如一个对象本来是应该被释放的，可是因为逻辑问题，没有把指向它的有效引用全部释放，那么GC依旧把它判定为不可回收。
我们可能在不经意的情况下，造成了不再需要继续使用的对象被生命周期更长的对象所引用。
面对这样的情况，GC也会显得无能为力。比如，在android编程领域，我们可能会在注册回调函数的时候把一个较大的activity引用传递过去，结果activity应该被销毁的时候，由于还有其他变量继续持有指向它的引用，从而导致该activity变量无法正常被释放，这种现象被称为“Context泄漏”。
解决这个问题的办法只能是，在必要的地方使用“弱引用”(WeakReference),避免“强引用”对变量生命周期的影响。
解决引用计数的循环引用的办法与此类似，也是一样用“弱引用”来打破循环，避免“强引用”对生命周期的影响。
再比如在javascript中注册一个定时器，而定时器不小心引用了许多大对象，这些对象会随着闭包加入到主事件循环队列中，也会造成类似的结果。
在绝大部分情况下，GC给我们带来了方便。但是，程序员也千万不能因为有GC的辅助，而忽略对变量的生命周期的设计考量。
在C++和Rust中是一样的，如果出现了循环引用，那么只能通过手动打破循环的方式来解决内存泄漏的问题。编译器无法通过静态检查来保证你不会犯这个错误。
内存泄漏显然是一种bug。但它跟“内存不安全”这种bug的性质不一样。“内存泄漏”是对“正常数据”的“应该执行但是没有执行”的操作，“内存不安全”是对“不正常数据”的“不应该执行但是执行了”的操作。
“内存不安全”导致的后果比“内存泄漏”要严重得多。
语言的设计者当然是希望能彻底解决内存泄，但是很可惜，这个问题恐怕不是在语言层面能彻底解决的问题。
所谓“彻底解决”的意思是，用户无论使用何种技巧，永远无法构造出内存泄漏的情况。
Rust语言无法给出这样的保证。
内存泄漏当然是不好的事情，作为开发者，我们应该尽可能避免内存泄漏现象的发生。
然而，需要强调的是，内存泄漏不属于内存安全的范畴，Rust也不会在语言设计层面给出一个“免除内存泄漏”的承诺。
析构函数泄漏 上面的例子展现了如何在Rust中不使用unsafe代码制造内存泄漏。在Rust中，在不经意间不小心制造内存泄漏的可能性是很低的。但是这个可能性还是存在的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603586360b152a4f467321d66e84f189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e2c42faf2592a83b14ba9596377c28/" rel="bookmark">
			Java和人工智能哪个好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java和人工智能哪个好？
Java和人工智能开发的工资高低主要取决于具体的工作岗位、行业、经验和技能水平等因素，很难一概而论。一般来说，这两个领域的工资都比较不错，尤其是在大城市和知名公司工作的薪资更高。
在Java开发方向，像Java后端开发、大数据开发、微服务架构师、云计算架构师等高级岗位，收入会相对较高。而在人工智能领域，像机器学习工程师、深度学习工程师、自然语言处理工程师、数据科学家等方向的工作也都是高薪职位。
选择学习Java开发还是人工智能取决于你的兴趣和职业规划。如果你对软件开发、web开发、移动应用程序开发等方面感兴趣，那么Java开发可能更适合你。而如果你对机器学习、数据分析、自然语言处理等领域感兴趣，那么人工智能可能更合适。
就就业市场来说，Java开发是比较稳定和广泛应用的领域，涉及的职位也比较多，如Java开发工程师、Java架构师、Java程序员等等，而人工智能目前在很多领域也有着广泛应用，所以人工智能相关职位也逐渐增多，如机器学习工程师、数据科学家、自然语言处理工程师等等。
至于工资，具体收入与职位、工作经验、公司规模、所在城市等因素都有关联，无法简单比较。
总的来说，Java和人工智能开发都是很有前途的领域，未来的就业市场都很广阔，选择哪个方向主要取决于个人的兴趣、职业规划和学习能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3050716e04543084a83786fa8aef0c44/" rel="bookmark">
			Android 系统启动过程纪要（基于Android 10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 看过源码的都知道，Launcher系统启动都会经过这三个进程 init -&gt;zygote -&gt; system_server。今天我们就来讲解一下这三个进程以及Launcher系统启动。
init进程 准备Android虚拟机环境：创建和挂载系统文件目录；初始化属性服务；设置子进程信号处理函数（防止init的子进程出现僵尸进程，在子进程暂停和结束是接受信号并进行处理）； 僵尸进程：父进程使用fork创建子进程，如果子进程终止，但父进程并不知道已经终止。虽然此时子进程已经退出，但是还是保留了他的信息（进程号。退出状态。运行时间等）。这样，系统进程表就会被无端耗用如果耗尽之后，系统可能就无法再创建新的进程。
启动属性服务，并为其分配内存用来存储属性：使用一个键值对（注册表）记录用户\软件的一些使用信息（确保系统或者软件重启之后能根据注册表中的信息进行初始化的工作）解析init.rc配置文件。 解析init.zygote脚本文件，启动zygote进程 总的来说做了三件事：
创建和挂在系统启动所需要的文件目录；初始化和启动属性服务；解析init.rc配置文件并启动zygote进程。 zygote进程 init通过调用app_main.cpp的main函数中的start方法来启动zygote进程。
DVM，ART，应用程序进程以及SystemServer进程都是有zygote创建。通过fork自身（从zygote进程）来创建新的应用进程。因此，zygote进程和它的子进程都会运行main函数。main函数里会通过标记查看main函数是运行在zygote进程还是子进程。如果实在zygote进程里，那么就会调用AppRuntime的start函数。在start函数里，会创建Java虚拟机以及做一些其他的准备工作。最后通过JNI调用ZygoteInit.java里的mian方法，进入Java框架层。
main方法主要做下面几件事情：
创建一个Server端的Socket，用来等待AMS请求创建新的应用进程；预加载类和资源；启动SystemServer进程；等待AMS请求创建新的应用程序进程（通过无限循环while(true)等待AMS的请求）。 SystemServer（zygote第一个启动的进程） SystemServer主要用来创建系统服务，例如AMS，WMS都是有他创建的。Zygote进程通过forkSystemServetr方法复制Zygote进程的地址空间，并关闭SystemServer不需要的Socket进程。然后通过handleSystemServerProcess方法启动进程。
//ZygoteInit.java private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) { String[] args = { "--setuid=1000", "--setgid=1000", "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023," + "1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011,3012", "--capabilities=" + capabilities + "," + capabilities, "--nice-name=system_server", "--runtime-args", "--target-sdk-version=" + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT, "com.android.server.SystemServer", }; ZygoteArguments parsedArgs; try { ZygoteCommandBuffer commandBuffer = new ZygoteCommandBuffer(args); try { parsedArgs = ZygoteArguments.getInstance(commandBuffer); } catch (EOFException e) { throw new AssertionError("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3050716e04543084a83786fa8aef0c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6eca8595e8ec551da980790b0cba5b/" rel="bookmark">
			ROS操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、初识ROS 1. 什么是ROS操作系统，它跟linux有什么关系？ ROS全称叫机器人操作系统（Robot Operating System, ROS），虽然它叫操作系统，但实际上和我们认识的linux、mac、windows不一样，它是基于ubuntu(linux)上运行的一套框架，我们编写的ROS程序都基于这套框架上运行。对于ROS系统，有一个重要的概念叫 “节点”，其实每个节点就是单独的一个程序，比如处理摄像头、雷达、电机等，都可以由不同的开发人员独自写一个程序运行并关联(通信)，他们也都有一个属于自己的二进制文件。因为这套框架可以实现对各个进程的组织、通信、文件系统等功能，所以可以称它为一个操作系统，实际上就是一个运行在linux上的模拟操作系统。
2. ROS的文件系统(ROS架构) 源文件空间src ：所有的包都存放在src文件夹中build ：由catkin_make命令自动生成，用来存储工作空间编译过程中产生的缓存信息和中间文件。devel ：由catkin_make命令自动生成，用来放置编译生成的可执行文件。package ：存放我们的各个功能包，每个功能包都可以对应一些功能，比如一个功能包里是为电机驱动写的，我们可以在一个功能包中写多个电机驱动的代码，最后生成多个节点(多个二进制程序)，当然也可以一个功能包对应一个节点，具体看个人设计实现cmakelists：功能包层面的一般不用动，功能包中的需要我们自己写一下，比如二进制怎么生成，需要什么库等等，cmakelists教程不会的可以搜一下package.xml ：这个文件catkin_make会自动生成，里面存放了功能包清单，可得到该package的名称、版本号、信息描述、作者信息和许可信息等。更重要的，&lt;build_depend&gt; … &lt;/build_depend&gt;标签定义了代码编译所依赖的其它功能包，&lt;exec_depend&gt; … &lt;/exec_depend&gt;标签定义了可执行程序运行时所依赖的其它功能包。package.xml文件是功能包被ROS系统识别的前提。include ：存放c++编写所需要的头文件msg：存放自定义消息类型，由于ROS各个节点之间存在通信，通信有数据类型，除了ROS自带的数据类型，我们也可以自定义srv ：自定义服务类型scripts：可以直接运行的脚本，如python、shell等launch ：存放快速启动的 .launch文件，为xml格式，有这个文件后就可以通过roslaunch来快速启动一个或多个节点包中src ：存放实际cpp代码 二、ROS安装 环境搭建以及测试demo可以见链接
1.ROS安装及测试 三、ROS命令以及使用 以下提到的一级目录、二级目录等为ROS文件系统图中的目录位置，例如工作空间为一级目录
1. catkin_create_pkg 功能：创建一个新的功能包
使用方法：catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]
示例：catkin_create_pkg ros_server std_msgs rospy roscpp
备注：示例中创建了一个新包，名为 ros_server，后面跟着的为这个包所需的依赖，可以暂时理解为我们在用c或c++编写多线程代码时，在编译阶段需要加-lpthread一样，这些依赖中包含了我们后续写代码用到的环境。std_msgs 为消息类型，创建节点通信时需要使用到，比如std_msgs::String，代表消息类型为string，剩下两个为c++和python所需要的依赖
2. catkin_make 功能：自动构建并编译代码
使用方法：catin_make
示例：catin_make
备注：注意，这个命令需要在二级目录下使用，使用后会自动去寻找cmakelists文件并根据其中的规则构建
3. roscore 功能：启动ROS主节点
使用方法：roscore
示例：roscore
备注：要启动ROS节点，必须先启动主节点，否则会运行失败
4. rosrun 功能：运行节点
使用方法：rosrun [–prefix cmd] [–debug] pkg_name node_name [ARGS]
示例：rosrun ros_server ros_server_node
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c6eca8595e8ec551da980790b0cba5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5faf78a285e74784ab1f0ec22efb8b/" rel="bookmark">
			网络安全中的人工智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全中的人工智能 ​ 来自网络的安全威胁是每个组织正在面对的关键问题之一，而AI被认为是在网络安全行业具有广阔前景的一种前沿技术。如今的网络安全威胁几乎没有留下犯错的余地。为了持续地、先发制人地应对那些高智商且具有破坏性的在线攻击者，企业的网络安全策略必须包含一系列不断发展的技术手段和技术规程。互联网安全服务（Internet Security Service）提供了包括防范病毒、间谍软件和其他威胁在内的一整套保护措施。
​ 几十年来，传统的防病毒技术都是使用“检测—响应”机制来运行的。然而，AI可以准确找出网络中的不怀好意者，防止恶意软件和其他威胁，并保护组织免受一系列攻击。此外，由于AI不需要执行增量存储、机器扫描和机器重构等操作，因而能够使网络安全策略等实施和运行成为一个无缝、平稳的过程。AI可以帮助系统使用少量的资源（1%～2%的CPU使用率和40～50MB的内存），以极快的速度（毫秒级）应对攻击，并实现大于99%的有效率，而过时的、基于签名的传统防病毒技术的有效率仅为50%～60%。因此，AI技术是稳健且灵活的，可以扩展安全部署，并支持构建更好的防御系统，以应对越来越多的新兴网络威胁。
恶意程序 恶意程序常被入侵者用来攻击系统安全。恶意程序分为以下两种。
（1）病毒程序：一个程序片段，通常附着在另一个程序（宿主程序）中，当宿主程序运行时，它就会秘密运行。一旦病毒程序开始运行，它就可以执行任何功能，比如清除文件。
（2）蠕虫程序：一个独立的程序，它在运行时可能会在当前系统或关联系统中生成更多的副本，这些副本会在特定时刻被激活。
病毒程序生命周期的不同阶段 一个病毒程序在它的生命周期中， 通常会经历以下4个阶段。
（1）休眠阶段：病毒程序最初处于休眠状态，直至因某个事件（如到了某个日期、出现了某个文件或磁盘容量超过某个限制）而被激活。有的病毒程序也可能没有休眠阶段。
（2）传播阶段：病毒程序将自身的一个副本放入宿主程序或磁盘上的某些系统区域。这样每个被感染的程序都将包含病毒程序的一个副本，后者会再次进入传播阶段，从而实现指数级繁殖。
（3）触发阶段：触发病毒程序，使其执行预期的功能。触发可能是由某个事件引起的，如病毒程序的副本达到一定数量等等。
（4）执行阶段：执行预期功能。
病毒程序的种类 寄生病毒：这类病毒能够附着在可执行文件上，并在受感染的宿主程序运行时进行复制。驻留内存病毒：这类病毒将自身作为驻留系统程序的一部分驻留在内存中，这样它就能感染每一个运行在内存中的程序。引导扇区病毒：这类病毒能够感染主引导扇区或引导扇区，然后当系统从受感染的磁盘引导时进行传播。隐形病毒：这是一类被设计用来躲避杀毒软件的病毒。多态病毒：每次感染都会发生变异（经历变化），使其特征码难以检测的病毒。宏病毒：这类病毒会利用Office应用程序（如Word或Excel）的宏功能。宏指的是嵌入字处理文档中的用于执行重复任务的可执行代码段。利用宏功能，宏病毒能自动重复执行而无须任何用户输入。这是最常见的一类病毒。电子邮件病毒：这类病毒会利用嵌入式电子邮件附件中的Word宏。当收件人打开附件时，它就会被激活，然后基于用户地址目录，将自己发送到邮件列表中的每个人。这类病毒有可能造成本地破坏。 反病毒扫描 防病毒的最好办法是阻止病毒从互联网进入局域网，但要完全阻隔所有病毒是不现实的。一种实用的方法是对病毒进行“检测、识别和删除”，这就需要在系统中安装反病毒扫描程序来对系统进行保护。
反病毒扫描程序的不同版本 第1代反病毒扫描程序：通过病毒特征码识别病毒。第1代反病毒扫描程序只能处理已知病毒。第2代反病毒扫描程序：使用启发式规则搜索可能的病毒感染，旨在尝试识别与病毒相关的代码片段，或者执行完整性检查，例如对校验和进行验证。第3代反病毒扫描程序：驻留在内存中，通过识别病毒的操作（如大量删除文件）来识别病毒。第4代反病毒扫描程序：集成了各种反病毒技术的软件包。 蠕虫程序 蠕虫程序能快速地、迭式地感染联网的机器，每台被感染的机器都是对其他机器进行攻击的自动发射台。网络蠕虫具有病毒的特征。为了复制自己，网络蠕虫会使用某种网络传输方式。
电子邮件蠕虫：通过电子邮件将自己的副本发送给其他系统。远程执行能力：在另一个系统中远程执行自身的副本程序。远程登录能力：登录到远端系统，然后通过命令将自己远程复制到远端系统。因为电子邮件病毒会从一个系统传播到另一个系统，所以它具有蠕虫程序的一些特征。活门（Trap Door）：进入程序的一个秘密入口，它允许某人绕过所有的安全检查进入程序。在程序开发过程中，活后门通常用于调试程序。而当活门被入侵者利用时，它就能无视操作系统的安全控制，成为严重的威胁。逻辑炸弹：嵌入合法程序中的代码，被设置为在满足特定条件时触发。一旦被触发，它可能就会修改或删除文件。特洛伊木马（Trojan Horse）：一个看起来很有用的程序，它包含一些隐藏的代码，当被调用时，它会执行一些不希望的操作。僵尸程序：这类程序能秘密地控制联网的计算机，然后利用所控制的计算机发起安全攻击，所以很难追踪到僵尸程序的制造者。僵尸程序通常被用于进行拒绝服务攻击。 防火墙 防火墙是一种机制，它能够保护本地系统或局域网免受外部网络的安全威胁，同时允许通过网络访问外部世界。
防火墙的特点 防火墙的特点如下：
（1）所有流入和流出局域网的数据都必须经过防火墙。
（2）只有经过本地安全策略授权的数据流才允许进入局域网。
（3）防火墙必须使用可信系统（Trusted System）及安全操作系统（Secure Operating System），以达到阻止非期望数据流渗透的效果。
防火墙控制访问的方式 防火墙控制访问的方式如下：
（1）服务控制：这种方式可以设定允许在互联网上访问的服务类型。它可以根据IP地址和TCP端口号对数据流进行过滤，并且可以使用代理软件来解释每个服务请求。
（2）方向控制：这种方式可以设定某服务请求从哪里发起，以及允许该服务请求通过防火墙的方向。
（3）用户控制：这种方式可以设定本地（局域网内）的某些用户只能访问互联网上的一些特定服务。它也可以用来控制外部用户对本地服务的访问。
（4）行为控制：控制特定服务的使用方式，例如对电子邮件进行过滤以消除垃圾邮件。
防火墙的类型 防火墙的类型如下：
（1）包过滤路由器：对每个流入的IP数据包应用同一组规则，并决定是否转发或丢弃它。过滤规则通常基于报文中包含的信息，如源IP地址、目的IP地址、源端口号、目的端口号、IP字段、路由器端口号等。
（2）全状态检测防火墙：通过创建流出方向TCP连接的目录，对TCP数据流规则进行加强控制。同时，基于目的端口号，对流入数据进行过滤。
（3）应用级网关：又称为代理服务器。经过配置，它可以只支持应用程序的某些功能，而拒绝所有其他功能。
（4）链路级网关：它既可以是一个独立运行的系统，也可以是应用级网关的一项具体功能。它不允许端到端的TCP连接，而是把端到端的TCP连接分成两部分—分别连接网关和内部TCP用户，以及网关和外部TCP用户。安全功能将决定哪些连接被允许，而哪些连接会被拒绝。
（5）堡垒主机：为应用级网关或链路级网关提供服务的平台。
可信系统 ​ 可信系统是指这样的系统：通过在其上实施指定的安全策略，系统在特定范围内是可信赖的。可信系统的失败可能会被破坏它所实施的指定策略。根据美国国防部遵循的概念，可信系统可实现一个能负责所有的访问控制决策的参考监视器（reference monitor）。
​ 可信系统最重要的设计目标是最小化可信计算模块（Trusted Computing Base, TCB）的规模。TCB是硬件、软件和固件的组合，用于执行所需的系统安全策略。由于TCB的失效会破坏植入的安全策略，因此较小的TCB的可以提供更好的保障。
​ 客体（数据）上会附加安全标签，以表示它们的敏感度水平。主体（用户）上也会附加标签，以表示不同用户的可信度。主体使用两天安全规则对客体进行访问：简单安全规则和约束规则。
简单安全规则：只有当主体的可信度超过客体的敏感度时，主体才能获得客体的读取权限，又称为“不可向上读取（No Read Up）“规则。通俗地说，这意味着不允许具有较低可信度的用户访问敏感度较高的信息。
约束规则：只有当客体的敏感度超过主体的可信度时，主体才能获得客体的写入权限，又称为简单规则或”不可向下写入（No Write Down）“规则。这意味着信息应该向上流动，而非向下流动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e5faf78a285e74784ab1f0ec22efb8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdaaf6a3398ea3ba756d7ed3140053ab/" rel="bookmark">
			【教3妹学编程-算法题】3008. 找出数组中的美丽下标 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3妹：呜呜，烦死了， 脸上长了一个痘
2哥 : 不要在意这些细节嘛，不用管它，过两天自然不就好了。
3妹：切，你不懂，影响这两天的心情哇。
2哥 : 我看你是不急着找工作了啊， 工作那么辛苦，哪还有时间想这些啊。
3妹：说到找工作，我又要去刷题了。
2哥：我给你出一道关于美丽的题吧，让你的心情美丽美丽~
题目： 给你一个下标从 0 开始的字符串 s 、字符串 a 、字符串 b 和一个整数 k 。
如果下标 i 满足以下条件，则认为它是一个 美丽下标 ：
0 &lt;= i &lt;= s.length - a.length
s[i…(i + a.length - 1)] == a
存在下标 j 使得：
0 &lt;= j &lt;= s.length - b.length
s[j…(j + b.length - 1)] == b
|j - i| &lt;= k
以数组形式按 从小到大排序 返回美丽下标。
示例 1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdaaf6a3398ea3ba756d7ed3140053ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae920f5d7ef1c11dc89f484c57a7e884/" rel="bookmark">
			【教3妹学编程-算法题】3006. 找出数组中的美丽下标 I
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3妹：呜呜，烦死了， 脸上长了一个痘
2哥 : 不要在意这些细节嘛，不用管它，过两天自然不就好了。
3妹：切，你不懂，影响这两天的心情哇。
2哥 : 我看你是不急着找工作了啊， 工作那么辛苦，哪还有时间想这些啊。
3妹：说到找工作，我又要去刷题了。
2哥：我给你出一道关于美丽的题吧，让你的心情美丽美丽~
题目： 给你一个下标从 0 开始的字符串 s 、字符串 a 、字符串 b 和一个整数 k 。
如果下标 i 满足以下条件，则认为它是一个 美丽下标：
0 &lt;= i &lt;= s.length - a.length
s[i…(i + a.length - 1)] == a
存在下标 j 使得：
0 &lt;= j &lt;= s.length - b.length
s[j…(j + b.length - 1)] == b
|j - i| &lt;= k
以数组形式按 从小到大排序 返回美丽下标。
示例 1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae920f5d7ef1c11dc89f484c57a7e884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5e569fb049b8fe624731222a187cd6/" rel="bookmark">
			U-Boot学习(3)：.config、defconfig文件对比及图形化配置Kconfig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一节中，我们介绍了U-Boot编译和.config配置文件生成分析，我们可以通过make xxx__defconfig来进行一些配置，其中xxx__defconfig对应config目录下的基于不同开发板的一些配置，指令执行完后会根据对应的配置在根目录下生成一个.config配置文件。而这个配置文件也可以通过图形化配置页面来生成，这一节就来介绍一下。
文章目录 1 xxx_defconfig和.config文件1.1 文件对比1.2 总结 2 图形化配置之Kconfig2.1 介绍2.1 U-Boot的图形配置 3 .config中的配置是如何使用的 1 xxx_defconfig和.config文件 1.1 文件对比 1、imx6ul_isiot_emmc_defconfig及其对应.config对比
我们对比一下两个文件，左边是imx6ul_isiot_emmc_defconfig文件，右边是make imx6ul_isiot_emmc_defconfig生成的.config文件，可以看到配置文件里有的，.config文件里都有，除此之外.config文件里还有一些其它的配置。
文件中#开头的为注释 2、imx6ul_isiot_emmc_defconfig和imx6ul_isiot_nand_defconfig对比
这里找一个与imx6ul_isiot_emmc_defconfig类似的配置imx6ul_isiot_nand_defconfig，来看一下区别：
可以看到，如果要使能NAND的话，需要多定义几个宏定义。
3、nand的.config和emmc的.config对比
左边是nand的.config，右边是emmc的.config：
可以看出，比如nand的一行CONFIG_MTD_RAW_NAND=y，生成出来后可能对应了多个与此相关的配置。
1.2 总结 1、xxx_defconfig
在U-Boot的defconfig文件中，配置项之间存在依赖关系。当你在defconfig文件中启用或禁用某个配置项时，可能会触发相关的配置项引申或取消。
直接依赖关系： 在defconfig文件中，一些配置项可能有直接的依赖关系。这意味着启用或禁用一个配置项可能会导致与之直接相关的其他配置项的状态发生变化。这通常是通过配置项的名称来指定的。间接依赖关系： 有些配置项可能存在间接的依赖关系。这意味着启用或禁用一个配置项可能会触发一系列的配置项状态变化，这些变化可能是由于其他配置项的依赖关系而产生的。 所以在生成的.config文件中，xxx_defconfig的一项配置可能有与之相关的多个配置。
2、.config
.config文件是一个文本文件，包含了一系列的宏定义，用于指定U-Boot的构建选项。这些宏定义决定了编译过程中使用的各种配置，如开启或关闭某个功能、指定交叉编译工具链的路径等。例如，在C代码中可以使用类似以下的方式来检查某个配置是否被定义：
#ifdef CONFIG_MY_FEATURE // 这段代码只有在 CONFIG_MY_FEATURE 被定义时才会被编译 #endif 2 图形化配置之Kconfig 2.1 介绍 Kconfig(Kernel Configuration)是Linux内核中用于配置构建选项的工具之一。它允许开发者通过一个文本界面或图形界面来选择、配置和调整内核的各种功能和模块。Kconfig文件包含了内核的配置信息，这些信息指定了内核编译时的各种选项，如支持的硬件、文件系统、网络协议等。
以下是Kconfig的一些主要特点和用法：
配置系统的基本原理： Kconfig采用了一种树状结构的配置系统。用户可以通过选择配置项，打开或关闭功能、模块或驱动，以满足特定需求。配置文件： Kconfig的配置信息存储在内核源代码树中的Kconfig文件中。每个子目录都可以包含一个Kconfig文件，用于配置该目录下的源代码。菜单配置界面： Kconfig提供了一个文本界面，也可以通过图形界面工具(如menuconfig、nconfig、xconfig等)进行配置。这些工具允许用户在配置过程中浏览选项，选择开启或关闭功能，并设置相应的参数。依赖关系： Kconfig支持配置项之间的依赖关系。某些功能可能依赖于其他功能的开启或关闭，Kconfig会确保用户不能选择不合理的配置。自动生成配置： Kconfig支持自动检测系统硬件和软件环境，从而生成适用于当前系统的默认配置。这有助于简化配置过程。配置文件生成： 在用户完成配置后，Kconfig会生成一个.config文件，其中包含了用户选择的所有配置信息。这个文件将用于实际的内核编译过程。make命令： 用户可以使用make menuconfig、make nconfig等命令来启动配置工具。在配置完成后，使用make命令即可开始内核的编译过程。 make menuconfig是Linux内核编译中使用的一个命令，它打开一个文本菜单界面，允许用户配置内核的各种选项。在执行make menuconfig之前，相关的文件主要包括：
Kconfig文件： Kconfig文件包含了内核的配置信息，以树状结构的形式组织。每个功能、模块或驱动都有对应的Kconfig条目。这些文件通常位于内核源代码树的各个目录中，例如，arch/目录、drivers/目录等。make menuconfig通过这些文件构建菜单界面。Makefile： 内核源代码中的Makefile包含了编译内核的相关规则和指令。make menuconfig命令会使用Makefile中的规则来创建配置菜单并执行相应的操作。.config文件： 在用户使用make menuconfig过程中，配置的结果会保存在一个名为.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa5e569fb049b8fe624731222a187cd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94bdbd9c50d9ceb3e37ccd93fa029d3a/" rel="bookmark">
			java如何修改windows计算机本地日期和时间？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文教程，主要介绍，在java中如何修改windows计算机本地日期和时间。
目录
一、程序代码
二、运行结果
一、程序代码 package com; import java.io.IOException; /** * * Roc-xb */ public class ChangeSystemDate { public static void main(String[] args) { try { // 构建命令行 String[] cmd = {"cmd", "/c", "date", "2022-03-01", "&amp;", "time", "12:34:56"}; // 执行命令行 ProcessBuilder pb = new ProcessBuilder(cmd); Process process = pb.start(); // 等待命令行执行完成 int exitCode = process.waitFor(); // 检查命令行执行结果 if (exitCode == 0) { System.out.println("系统时间修改成功！"); } else { System.out.println("系统时间修改失败！"); } } catch (IOException | InterruptedException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94bdbd9c50d9ceb3e37ccd93fa029d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/727cfe1791a22de960f4bb780cd1e2a6/" rel="bookmark">
			应用层网络协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tags: [“计算机网络”]
descripution: “学习应用层的一些常用协议”
网络协议：约定的信息传输的格式，如几个字节是消息头、消息头记录什么信息之类的；c/s架构：不一定是两台计算机，而是两个应用、两个端口工具：实际使用中不用手动封装协议再发消息，而是直接使用封装的软件、库等实现功能。如SSH工具OpenSSH 命令行常用 一些协议名和命令名一样（或相似）的协议。结合应用来学习。
还有不以协议为名的网络工具，放附录介绍
SSL&amp;&amp;TLS SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。
为Netscape所研发。
SSL协议位于TCP/IP协议]与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：
SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 功能：
1）认证用户和服务器，确保数据发送到正确的客户机和服务器；
2）加密数据以防止数据中途被窃取；
3）维护数据的完整性，确保数据在传输过程中不被改变。
流程图之类的在计网书中有吗 OpneSSL ca-bundle.crt-安装git时可选
9、查看路径
which openssl 查看版本
openssl version https://www.cnblogs.com/xiangyuecn/p/8365634.html
https的ssl证书必须绑定域名，所以 https://{ip} 这种是绝对会显示不安全的。
那么一个简单有效的办法就是同样在所有电脑上写 hosts。
https://segmentfault.com/q/1010000019527504
首先，虚构一个CA认证机构出来
注：这个1024不是密码，是 1024 bit long modulus！！直接1024就行，太长了会cpu跑满！
# 生成CA认证机构的证书密钥key # 需要设置密码，输入两次 openssl genrsa -des3 -out ca.key 1024 # 去除密钥里的密码(可选) # 这里需要再输入一次原来设的密码 openssl rsa -in ca.key -out ca.key # 用私钥ca.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/727cfe1791a22de960f4bb780cd1e2a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206e3718af092fd1d12f80cae771ccac/" rel="bookmark">
			MongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SQL到MongoDB的映射图 SQLMongoDB数据库(database)数据库(database)表(table)集合(collection)行row文档(document)列(column)字段(field)索引(index)索引(index)主键(primary key)_id(字段)视图 (view)视图 (view)表连接(table joins)聚合操作 ($lookup) 2、适合使用MongoDB的场景 应用不需要复杂/长事务及 join 支持新应用，需求会变，数据模型无法确定，想快速迭代开发应用需要2000-3000以上的读写QPS (更高也可以)应用需要TB甚至 PB 级别数据存储应用发展迅速，需要能快速水平扩展应用要求存储的数据不丢失应用需要99.999%高可用应用需要大量的地理位置查询、文本查询 3、Linux安装 https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.4.26.tgz
命令1
进入bin目录，输入./mongo --help查看帮助信息
命令2
指定data和log路径
启动mongoDB
bin/mongod --port=27017 --dbpath=/app/mongodb-linux-x86_64-rhel70-4.4.26/data --logpath=/app/mongodb-linux-x86_64-rhel70-4.4.26/log/mongodb.log --bind_ip=0.0.0.0 --fork 进入bin目录打开mongoDB命令控制台
4、基础命令 查看所有数据库 show dbs 2. 创建(切换)db
在控制台关闭mongoDB服务 db.shutdownServer() 菜鸟教程更多
https://www.runoob.com/mongodb/mongodb-tutorial.html
5、配置文件启动mongoDB 5.1、编辑编制文件 systemLog: destination: file path: /app/mongodb-linux-x86_64-rhel70-4.4.26/log/mongodb.log #指定日志输入文件夹(绝对路径) logAppend: true storage: dbPath: /app/mongodb-linux-x86_64-rhel70-4.4.26/data #指定数据输入文件夹(绝对路径) engine: wiredTiger #存储引擎 journal: enabled: true #是否启动journal日志 net: bindIp: 0.0.0.0 port: 27017 processManagement: fork: true 5.2、启动MongoDB mongod -f /app/mongodb-linux-x86_64-rhel70-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/206e3718af092fd1d12f80cae771ccac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6bfe2264c650dfec4d2b964c1430678/" rel="bookmark">
			微信小程序-----wxss模版样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、WXSS
1. 什么是 WXSS
2. WXSS 和 CSS 的关系
二、rpx
1. 什么是 rpx 尺寸单位
2. rpx 的实现原理
3. rpx 与 px 之间的单位换算
三、样式导入
1. 什么是样式导入
2. @import 的语法格式
四、全局样式和局部样式
1. 全局样式
2. 局部样式
前言 上一期我们学习了wxml的模版语法，那么这一期我们开始学习新的知识点，wxss的模版样式，在此之前我们学习过了css，有了css的基础，那wxss就会很容易理解了，下面就开始本期的学习吧。
一、WXSS 1. 什么是 WXSS WXSS (WeiXin Style Sheets)是一套样式语言，用于美化 WXML 的组件样式，类似于网页开发中的 CSS。
2. WXSS 和 CSS 的关系 WXSS 具有 CSS 大部分特性，同时，WXSS 还对 CSS 进行了扩充以及修改，以适应微信小程序的开发。
与 CSS 相比，WXSS 扩展的特性有：
rpx 尺寸单位 @import 样式导入 二、rpx 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6bfe2264c650dfec4d2b964c1430678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c4861e566eb540883f0d281d8bec75/" rel="bookmark">
			搜索旋转排序数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 33. 搜索旋转排序数组 - 力扣（LeetCode）
二分法
class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left &lt;= right) { int mid = (left + right) / 2; if (nums[mid] == target) { return mid; } if (nums[left] &lt;= nums[mid]) { // 左半部分有序 if (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) { right = mid - 1; } else { left = mid + 1; } } else { // 右半部分有序 if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) { left = mid + 1; } else { right = mid - 1; } } } return -1; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77baebf60a5e3d7547d9f24560cd33f/" rel="bookmark">
			react之unpkg.com前端资源加载慢、加载不出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 react之unpkg.com前端资源加载慢什么是unpkg.com加载慢原因解决方案替换国内cdn在 package.json 中打包进来 react之unpkg.com前端资源加载慢 什么是unpkg.com unpkg 是一个内容源自 npm 的全球快速 CDN。
作为前端开发者，我们对 unpkg 都不陌生，它是一个基于 npm registry 的静态资源 CDN 服务。
它提供了一种快捷的静态资源访问能力，只需要遵循约定的 URL 进行访问，即可在页面中加载任意 npm 包里面的文件内容。虽然前端的开发模式已经不像当年那么的轻量的，往往需要用 webpack 等构建后进行部署。但在很多轻量的场景下，往往希望直接引入公共的 npm 包
加载慢原因 unpkg有时候会被墙了，unpkg上的相关资源都不能访问，才导致项目资源加载不出。
解决方案 替换国内cdn 在react项目 config/config.ts 中找到相关配置，关键字： unpkg.com
export default defineConfig({ // 前端配置了 publicPath 为 /static/，那么前端应用程序在生产环境下应该通过 /static/ 路径来访问静态资源 publicPath: process.env.NODE_ENV === 'production' ? '/static/' : '/', hash: true, antd: {}, dva: { hmr: true, }, // for Ant Design Charts https://pro.ant.design/zh-CN/docs/graph scripts: [ 'https://unpkg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b77baebf60a5e3d7547d9f24560cd33f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99c3ff59d52cc8acb0c974d3398e5dcd/" rel="bookmark">
			pycharm 非局域网下 远程连接服务器docker中的conda环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提条件：有外网ip。
可以买个阿里云域名（一般实验室配置）
用蒲公英（参考我的这篇文章，一般是个人使用，免费三个用户）
https://blog.csdn.net/weixin_75205835/article/details/135159099?spm=1001.2014.3001.5502
这一篇我们可以在局域网内直接通过ssh就能够连接到docker容器，但这有个非常大的局限性，就是只能在局域网内。但是一般来说服务器都放在小黑屋里，你不可能一直就一直在小黑屋里待着，肯定处于局域网外了。这就矛盾了！那怎么连接呢！
方法有二：
第一个：也是我们本文所探讨的。-v文件映射法
第二个：如果是买了类似于阿里云的域名，能够固定域名进行端口映射的也可以哦。就可以像ssh连接那样进行端口映射啦。
1.构建docker镜像 这一部分在这里已经说的很明白了。但是这一步没有太明白就导致我两周都在寻求答案。
只要是docker容器更改的，这两个-v文件都会同步做出更改。
-v既然可以做数据集和代码的文件映射，当然也可以放conda环境啦。这样我们就可以连接啦。
docker run --name test4 -it -v /home/xxfs/project/test/anaconda3:/root/anaconda3 -v /home/xxfs/project/test/yolov5:/yolov5 -p 10022:22 --gpus all --ipc=host e1ff5e8cfa9f 一般来说别直接将代码文件放在home文件夹下，会没有权限写入，导致传不上去文件。这不就纯纯鸡肋嘛。（图忘记截了，最后给的/home文件夹放权）
建议直接在根目录下创建/project/yolov5直接对project放权就好了，不会对系统造成很大的影响。
docker run --name test4 -it -v /home/xxfs/project/test/anaconda3:/root/anaconda3 -v project/yolov5:/yolov5 -p 10022:22 --gpus all --ipc=host e1ff5e8cfa9f 然后像上一篇文章一样进行pycharm配置就好了。
2.怎么下载conda包 根据上一篇文章来，就可以啦，但是这个需要进入到docker容器里面做更改了。像这样
一般我们使用的是docker的root登录，他会提示你这个权限太大了，最好选择一般用户。大家按需索取。
第二种方法讲个思路：
当我们将服务器本地的端口（任意空闲端口）映射到docker容器的22端口后，即上面的-p选项，通过ssh root@服务器本地ip -p 端口连接。然后我们可以将这个端口，root，docker密码都映射到外网的ip端口上。具体我没有操作，理论上可以实现。
欢迎大家订阅本专栏。期待你的关注哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b5a42675a820917594b5738f8257bd/" rel="bookmark">
			【Python基础】Python 中的数据结构（列表、元组、集合和字典）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 引言2 列表（List）2.1 特性2.2 示例 3 元组（Tuple）3.1 特性3.2 示例 4 集合（Set）4.1 特性4.2 示例 5 字典（Dictionary）5.1 特性5.2 示例 6 实例演示结论 TIPS 1 引言 Python 是一种动态的、面向对象的编程语言，它提供了丰富的内置数据结构，包括列表（List）、元组（Tuple）、集合（Set）和字典（Dictionary）。这些数据结构是 Python 编程中不可或缺的部分，用于存储和组织数据。本文将深入探讨这些数据结构的特性、用法以及应用场景。
2 列表（List） 列表是 Python 中最基本的数据结构之一。它是一个有序的元素集合，可以包含不同类型的数据，并且支持元素的增加、删除和修改。
2.1 特性 有序性：列表中的元素有固定的顺序。可变性：列表中的元素可以被修改。动态性：列表可以动态地增加或减少元素。 2.2 示例 # 创建列表 my_list = [1, 2, 3, 'Python', 3.14] # 添加元素 my_list.append('new element') # 访问元素 print(my_list[3]) # 输出 'Python' # 列表切片 print(my_list[1:4]) # 输出 [2, 3, 'Python'] 3 元组（Tuple） 元组与列表类似，但它是不可变的。一旦创建，元组中的元素就不能被修改。
3.1 特性 有序性：元组中的元素有固定的顺序。不可变性：元组一经创建，其中的元素不能被修改。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b5a42675a820917594b5738f8257bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/474ff8a637e7c4581ca74fee161bef23/" rel="bookmark">
			Java学习——Junit单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​ Junit：事实上的标准单元测试框架 使用Junit：只需要使用 TestCase 和 Assert http://t.csdnimg.cn/hgMFJ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4239e6e7dfdf32294a84e901f927ba2a/" rel="bookmark">
			电阻表示方法和电路应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电阻 电阻的表示方法 直标法
直标法是将电阻器的类别及主要技术参数的数值直接标注在电阻器表面上
通常用3位阿拉伯数字来标注片状电阻的阻值，其中第1位数代表阻值的第1位有效数；第2位数代表阻值的第二位有效数字；第3位数代表阻值倍率，即阻值第1、2位有效数之后0的个数。
203代表20后的3个0，即20000Ω=20kΩ。471表示47后面加1个0，即470Ω。105表示1MΩ。272表示2.7kΩ。
对于带小数的欧姆级片状电阻或10Ω之内的整数值片状电阻，也用R来代表Ω，与上述特殊标注法相同。例如：1R2表示1.2Ω；4R7表示4.7Ω；R33表示0.33Ω。值得注意的是：不少初学者往往将片状电阻末位标注为0的电阻识别错，如将100误认为100Ω，将620误认为620Ω等，其实末位为0表示第1、2有效数之后的0的个数为零，即没有0，这样，100应理解为10Ω，620应为62Ω，依此类推。
少数片状电阻亦有用4位数字标注阻值的，如在美国GE空调器遥控电路中就有标注为6801的片状电阻，其实际阻值为6.8kΩ。由此可见，4位数标注与3位数标注的差别只是多了一位有效数，其余与3位数标注法相同，这里不再赘述。下图示出了数种片状电阻标注值与实际数值之间的对应关系，供识别时参考。
注意： 有些贴片电阻上标着01A，01B这些标记的，虽然不常见，但也要知道，意思是：
01A代表电阻值应为100ⅹ1=100Ω；01B代表电阻值应为100x10=1000Ω(即1KΩ)；01C代表电阻值应为100X100=10000Ω(即10KΩ)。
这是贴片电阻上的字母表示方法。01代码经查表得知为100、代码字母A经查表得知为10零次方(即为1)。
电阻的单位需要注意：
mΩ：毫欧，1Ω = 1000mΩ
MΩ：兆Ω，1MΩ = 1000Ω
（小写为毫欧，大写为兆欧）
色标法
“色标法”是将电阻器类别及主要技术参数的数值用颜色（色环或色点）标注在它的表面上，如下图所示。
电阻测量方法 万用表
万用表测量电阻并读数：https://blog.csdn.net/weixin_46251230/article/details/127352180
伏安特性 电阻元件的伏安特性就是该电阻两端电压（伏特）与流过的电流（安培）之间的函数关系。
线性电阻元件伏安特性：
R=U/I 也就是欧姆定律
非线性电阻（压敏电阻、热敏电阻）：
伏安特性曲线：绘制在直角坐标系中，就是一条直线（线性电阻）或者一条曲线（非线性电阻），横坐标是电流、纵坐标是电压；反过来也可以。
电阻就是伏安特性曲线的斜率
电阻的额定功率 P = I2R = UI = U2/R
允许误差 括号中的字母就代表了对应的误差值，例如在电阻的直标法中标记了电阻误差为D，则说明该电阻误差为正负百分之0.5
电阻串并联 电阻R1和电阻R2串联后，等效为：R串=R1+R2
电阻R1和电阻R2并联后，等效为：(1/R并)=(1/R1)+(1/R2) ，或R并=(R1*R2)/(R1+R2)
电阻的功能 1、分压 分压公式：
所谓分压公式，就是计算串联的各个电阻如何去分总电压，以及分到多少电压的公式。
分电压多少这样计算：占总电阻的百分比，就是分电压的百分比。公式是：U =（R/R总）× U源
如5欧和10欧电阻串联在10V电路中间，5欧占了总电阻5＋10＝15欧的1/3，所以它分的电压也为1/3，也就是10/3伏。
通俗地来讲，两个电阻串联，电阻大的那个分的电压就大，电阻小的分得的电压就小，是按其中一个电阻和总电阻的比例来确定分压值的大小的。
输入电路由信号源Ui、电阻R1和电阻R2构成。分压电路输出电压U0算公式为
从公式可以看出，由于分母R1+R2大于R2，所以输出电压小于入电压。也就是说分压电路是一个对输入信号进行衰减的电路。我们可以通过改变R1或R2的大小来改变输入电压U0的大小。
2、限流 电路右边接负载，组成一个回路，R1电阻起到限流的作用，Vsam是电压检测点
3、测温 热敏电阻
4、防浪涌 当左边输入的交流电压过大时，容易对右边的电路造成影响，所以并联一个压敏电阻R1，当电压非常大时，压敏电阻的阻值会非常小，则F1-R1-F2的线路相当于短路，对后面的电路没有影响，因此R1起到了防浪涌的作用
下面电路哪里设计不合理 首先查找型号为SDNT2012X103F3950FTF电阻是什么电阻，得知是一个NTC的热敏电阻，因此可推断该电路是一个单片机ADC测温电路
不合理地方有：
1、测温电路，为了提高温度测量精度，电阻R11应该使用1%精度的
2、降低成本，电阻R12应该使用5%精度的，R12起限流电阻的作用，右边一般接单片机的ADC引脚
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4239e6e7dfdf32294a84e901f927ba2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbbe017b48926d8dccbe7a61595744f9/" rel="bookmark">
			5.1 内容管理模块 - 课程预览、提交审核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容管理模块 - 课程预览、提交审核 文章目录 内容管理模块 - 课程预览、提交审核一、课程预览1.1 需求分析1.2 freemarker 模板引擎1.2.1 Maven 坐标1.2.2 freemaker 相关配置信息1.2.3 添加模板 1.3 测试静态页面1.3.1 部署Nginx1.3.2 解决端口问题被占用问题1.3.3 配置host文件1.3.4 文件服务器1.3.5 视频播放页面 1.4 课程预览 主页1.4.1 CoursePublishController1.4.2 Nginx 配置反向代理1.4.3 CoursePublishServiceImpl1.4.4 编写模板1.4.5 测试 1.5 课程预览 视频1.5.1 配置Nginx1.5.2 CourseOpenController1.5.3 MediaOpenController1.5.4 测试 二、提交课程审核2.1 需求分析2.2 数据模型2.2.1 课程预发布表 course_publish_pre 2.3 CoursePublishController2.4 CoursePublishServiceImpl2.5 测试 一、课程预览 课程预览就是把课程的相关信息进行整合，在课程预览界面进行展示，课程预览界面与课程发布的课程详情界面一致
1.1 需求分析 客户可以通过课程预览页面查看信息是否存在问题
如下课程预览的数据来源
下图显示了整个课程预览的流程图
也就是说现在怎么给前端返回一个页面呢？
最最最原始的JSP可以，一些模板引擎技术也可以
前端请求内容管理服务后，后台服务系统要返回一个页面
最终要返回的页面如下图所示（预览页面，如果客户成功确认发布后，发布后的页面和预览时的页面相同）
说明如下：
1、点击课程预览，通过Nginx、后台服务网关请求内容管理服务进行课程预览。
2、内容管理服务查询课程相关信息进行整合，并通过模板引擎技术在服务端渲染生成页面，返回给浏览器。
3、通过课程预览页面点击”马上学习“打开视频播放页面。
4、视频播放页面通过Nginx请求后台服务网关，查询课程信息展示课程计划目录，请求媒资服务查询课程计划绑定的视频文件地址，在线浏览播放视频。
在这里我们用到了两个技术，一个Nginx，一个freemarker
freemarker可以在服务端生成网页然后返回给浏览器
Nginx是一个代理服务器，所有的请求都请求到Nginx上，由Nginx进行代理，然后再由Nginx发送到后台服务上
1.2 freemarker 模板引擎 freemarker提供很多指令用于解析各种类型的数据模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbbe017b48926d8dccbe7a61595744f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8d8ea73571adcbd7123255c0186b616/" rel="bookmark">
			翻译: Streamlit从入门到精通 部署一个机器学习应用程序 四
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Streamlit从入门到精通 系列：
翻译: Streamlit从入门到精通 基础控件 一翻译: Streamlit从入门到精通 显示图表Graphs 地图Map 主题Themes 二翻译: Streamlit从入门到精通 构建一个机器学习应用程序 三
1. 5. 如何部署一个Streamlit应用 部署是将应用程序从开发者传递给用户的机制。
部署一个应用程序是将特定的应用程序复制、配置并启用到特定的基础URL的过程。一旦部署过程完成，应用程序就可以在基础URL上公开访问。服务器通过首先对应用程序进行分阶段处理，然后在成功分阶段处理后激活它来执行这个两步过程。
让我们学习如何部署一个Streamlit应用！
在你尝试部署你的应用之前，你需要在GitHub上创建一个新的仓库，你需要在其中放置你的应用代码和依赖项。
https://github.com/zgpeace/Streamlit_app
创建存储库并上传文件后，您需要创建一个名为requirements的新文件，在其中放置应用中使用的库。
首先，点击创建新文件。
现在你即将部署你的应用程序，你需要做的就是访问这个链接。
然后按照以下步骤操作：
点击“部署”，稍等片刻！
浏览器中会自动打开一个页面！这个页面是用 Streamlit 实现的你的项目应用。
恭喜你，你的应用已成功部署！点击此处查看已部署的应用。
想要获取更多文档，请访问此链接：docs.streamlit.io
代码 https://github.com/zgpeace/Streamlit_app
参考 https://www.datacamp.com/tutorial/streamlit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed0de81b334ebdb780bbc0ae5b9cedc/" rel="bookmark">
			华为认证云计算专家（HCIE-Cloud Computing）--练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为认证云计算专家（HCIE-Cloud Computing）–练习题 1.(判断题)华为云stack支持鲲鹏架构，业务可从X86过渡到鲲鹏。
正确答案：正确
2.(判断题)业务上云以后，安全方面由云服务商负责，客户自己不需要做任何防护
A 对
B 错
正确答案：B
3.( 多选题 ) 某企业有一个购物系统部署在HCS，可以选择哪些服务做安全保障?
A WAF
B HSS
C DBAS
D BHD
正确答案：ABCD
4.(判断题 ) 申请了主机安全服务之后，即可以自动对主机进行安全防护
A 对
B 错
正确答案：B
5.(多选题) 主机安全服务HSS的功能包括哪些?
A 资产管理
B 负载管理R
C 入侵检测
D 容器镜像安全
正确答案：ABCD
6.(判断题)云防火墙CFW不可以跟安全组共存，两者只能选择其中一个使用。
A 对
B 错
正确答案：B
7.(多选题 ) 以下哪些服务不依赖专门的硬件即可实现?
A 安全组
B Network ACL
C EdgeFW
D CFW
正确答案：ABCD
8.(单选题)华为云堡垒机的多因子认证登录功能，不支持下列哪种认证方式
A 手机令牌
B 邮件
C 手机短信
D 动态令牌
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eed0de81b334ebdb780bbc0ae5b9cedc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e2845c91d2cedcc97f3985d1142c22/" rel="bookmark">
			01背包问题简单思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 给你一个体积为5的背包，要求将下列物品中的一个或多个装入背包，使背包能有最大价值（每个物品有且仅有一个）。 物品1:体积1，价值2 物品2:体积2，价值4 物品3:体积3，价值4 物品4:体积4，价值5 文章目录 代码 物品编号为0表示该物品大小为0，价值为0，用来辅助的。 物品编号\背包体积01234501a23b4 表格中的a表示：当背包体积为1时，且只有两个物品供选择时（物品0和物品1），背包的最大价值
表格中的b表示：当背包体积为4时，且只有四个物品供选择时（物品0、物品1、物品2、物品3），背包的最大价值
知道这个表格的意义之后我们就逐个来填写。首先，
第一行全为0：因为不管背包体积有多大，只有物品0可供选择
第一列全为0：因为不管有多少个物品可以选择，背包的体积始终为0
物品编号\背包体积012345000000010203040 然后就按顺序从左到右，从上到下的顺序填写。
填写的过程中需要考虑两种情况（与当前所能选择最大编号物品有关）：
情况1：若最大编号物品的体积大于当前背包体积 最大编号物品肯定是放不进背包的，于是我们就要去找，同体积背包下，排除最大编号物品，背包的最大价值。 情况2：若最大编号物品的体积小于等于当前背包体积 如果是这种情况，我们又要将其细分为两种情况： - 不装入最大编号物品 如果不装入，那么跟情况1一样，同体积背包下，排除最大编号物品，背包的最大价值 - 装入最大编号物品 如果装入，那么就去找减去该物品体积后，背包剩余体积的最大价值。（找背包剩余体积最大价值时，一定要排除最大编号物品，因为它已经装入背包了）。然后将该物品价值与背包剩余体积的最大价值相加。 - 然后将装入与不装入的背包价值相比较，取较大者 下面来逐步填写
物品编号\背包体积012345000000010203040 当背包体积为1，最大编号物品为1时，物品体积&lt;=背包体积：
noInputValue：不装入物品1，找同背包体积下，排除物品1，背包的最大价值，那么对应着表格中的（0,1），于是noInputValue=0InputValue：装入物品1，减去它的体积，背包剩余体积为0，排除物品1，背包剩余体积最大价值的位置就在（0,0），InputValue=物品价值+背包剩余体积最大价值=2+0=2noInputValue &lt; InputValue：将大的值填入（1,1）
物品编号\背包体积0123450000000102203040 当背包体积为2，最大编号物品为1时，物品体积&lt;=背包体积：
noInputValue：不装入物品1，找同背包体积下，排除物品1，背包的最大价值，那么对应着表格中的（0,2），于是noInputValue=0InputValue：装入物品1，减去它的体积，背包剩余体积为1，排除物品1，背包剩余体积最大价值的位置就在（0,1），InputValue=物品价值+背包剩余体积最大价值=2+0=2noInputValue &lt; InputValue：将大的值填入（1,2） 然后按照此规则，将这一行填完：
物品编号\背包体积01234500000001022222203040 当背包体积为1，最大编号物品为2时，物品体积&gt;背包体积：
Value：不装入物品2，找同背包体积下，排除物品2，背包的最大价值，那么对应着表格中的（1,1），于是Value=2，将2填入（2,1）
物品编号\背包体积012345000000010222222023040 当背包体积为2，最大编号物品为2时，物品体积&lt;=背包体积：
noInputValue：不装入物品2，找同背包体积下，排除物品2，背包的最大价值，那么对应着表格中的（1,2），于是noInputValue=2InputValue：装入物品2，减去它的体积，背包剩余体积为0，排除物品2，背包剩余体积最大价值的位置就在（1,0），InputValue=物品价值+背包剩余体积最大价值=4+0=4noInputValue &lt; InputValue：将大的值填入（2,2）
物品编号\背包体积0123450000000102222220243040 当背包体积为3，最大编号物品为2时，物品体积&lt;=背包体积：
noInputValue：不装入物品2，找同背包体积下，排除物品2，背包的最大价值，那么对应着表格中的（1,3），于是noInputValue=2InputValue：装入物品2，减去它的体积，背包剩余体积为1，排除物品2，背包剩余体积最大价值的位置就在（1,1），InputValue=物品价值+背包剩余体积最大价值=4+2=6noInputValue &lt; InputValue：将大的值填入（2,3）
物品编号\背包体积01234500000001022222202463040 然后按照此规则，将这一行填完：
物品编号\背包体积0123450000000102222220246663040 当背包体积为1，最大编号物品为3时，物品体积&gt;背包体积：
Value：不装入物品3，找同背包体积下，排除物品3，背包的最大价值，那么对应着表格中的（2,1），于是Value=2，将2填入（3,1）
物品编号\背包体积01234500000001022222202466630240 当背包体积为2，最大编号物品为3时，物品体积&gt;背包体积：
Value：不装入物品3，找同背包体积下，排除物品3，背包的最大价值，那么对应着表格中的（2,2），于是Value=4，将4填入（3,2）
物品编号\背包体积012345000000010222222024666302440 当背包体积为3，最大编号物品为3时，物品体积&lt;=背包体积：
noInputValue：不装入物品3，找同背包体积下，排除物品3，背包的最大价值，那么对应着表格中的（2,3），于是noInputValue=6InputValue：装入物品3，减去它的体积，背包剩余体积为0，排除物品3，背包剩余体积最大价值的位置就在（2,0），InputValue=物品价值+背包剩余体积最大价值=4+0=4noInputValue &gt; InputValue：将大的值填入（3,3）
物品编号\背包体积0123450000000102222220246663024640 当背包体积为4，最大编号物品为3时，物品体积&lt;=背包体积：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e2845c91d2cedcc97f3985d1142c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0599b92c48bf0757770db15238822d0a/" rel="bookmark">
			【毕业设计选题】深度学习技术驱动的智能闯红灯识别系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
设计思路
一、课题背景与意义
二、算法理论原理
2.1 YOLOv5算法
2.2 DeepSort算法
三、闯红灯检测的实现
实现效果图样例
最后
前言 📅大四是整个大学期间最忙碌的时光,一边要忙着备考或实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。近几年各个学校要求的毕设项目越来越难,有不少课题是研究生级别难度的,对本科同学来说是充满挑战。为帮助大家顺利通过和节省时间与精力投入到更重要的就业和考试中去,学长分享优质的选题经验和毕设项目与技术思路。
🚀对毕设有任何疑问都可以问学长哦!
选题指导:
最新最全计算机专业毕设选题精选推荐汇总
设计思路 一、课题背景与意义 以图像或视频为研究对象，通过图像处理技术识别出道路情况，不仅要检测出汽车、行人等目标，还要判断出交通信号。而根据这项技术，通过提醒行人和车辆不要违反交通规则可以解决交通安全全世界死亡率排名前列的问题。
二、算法理论原理 2.1 YOLOv5算法 YOLO算法用回归方法对目标进行检测，有着快速检测的能力。YOLOv5分为四个部分，分别为input端，backbone端，neck端，prediction端四个部分。
YOLOv5在目标检测方面有着优秀的性能，其主要原因如下：
(1) Input端包括Mosaic数据增强，新增了图片尺寸处理、自适应锚框计算三部分，增强小目标检测性能，加快图片处理速率。
(2) Backbone新增了Focus结构并且改进了CSP结构，Focus结构减少了冗余信。CSP1用于特征提取部分，CSP2用于特征融合部分。
(3) Neck包括FPN+PAN的结构，加强网络特征融合的能力。
(4) Output端包括GIOU_Loss作为损失函数，新增了GIOU_NMS非极大值抑制。最小化预测框和目标框之间的归一化距离，增强了遮挡重叠的目标的识别率。
2.2 DeepSort算法 DeepSort是由sort升级而来。当物体发生遮挡的时候，使用sort算法容易丢失自己的ID，而新增的Deep Association Metric把轨迹分为确认态和不确认态，新产生的轨迹是不确认态的，不确认态的轨迹必须要和目标连续匹配多次（默认3次）才可以转化成确认态。确认态的轨迹必须和目标连续不匹配多次（默认30次），才可剔除ID。
相关代码示例：
import torch import torch.nn as nn class YOLO(nn.Module): def __init__(self, num_classes, num_anchors): super(YOLO, self).__init__() self.num_classes = num_classes self.num_anchors = num_anchors # Define your network architecture here self.conv = nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0599b92c48bf0757770db15238822d0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0861095ca1565183975151c5b2a14071/" rel="bookmark">
			springmvc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三层架构和mvc设计模式 三层架构
表现层: 接收请求响应用户 servlet – springMVC
业务层：处理业务,事务 自己写业务层 – spring 管理业务层
持久层: 对数据库进行增删改查操作 jdbc – dbutils --jdbcTemplate – mybatis – spring data
MVC设计模式
M:model 模型：封装数据 广义：业务模型层 = dao + service + domain
V:view 视图：展示数据 广义：能展示数据都是视图:jsp, html ,pdf ,freemarker
controller: 控制层：接收请求响应用户
mvc框架要做哪些事情 回顾servlet &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0861095ca1565183975151c5b2a14071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d30339721a84bc544fad9e5527056a03/" rel="bookmark">
			Rust-NLL(Non-Lexical-Lifetime)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust防范“内存不安全”代码的原则极其清晰明了。
如果你对同一块内存存在多个引用，就不要试图对这块内存做修改；如果你需要对一块内存做修改，就不要同时保留多个引用。
只要保证了这个原则，我们就可以保证内存安全。
它在实践中发挥了强大的作用，可以帮助我们尽早发现问题。这个原则是Rust的立身之本、生命之基、活力之源。
这个原则是没问题的，但是，初始的实现版本有一个主要问题，那就是它让借用指针的生命周期规则与普通对象的生命周期规则一样，是按作用域来确定的。
所有的变量、借用的生命周期就是从它的声明开始，到当前整个语句块结束。
这个设计被称为Lexical Lifetime,因为生命周期是严格和词法中的作用域范围绑定的。
这个策略实现起来非常简单，但它可能过于保守了，某些情况下借用的范围被过度拉长了，以至于某些实质上是安全的代码也被阻止了。
在某些场景下，限制了程序员的发挥。
因此，Rust核心组又决定引入Non Lexical Lifetime,用更精细的手段调节借用真正起作用的范围。
这就是NLL。
NLL希望解决的问题 首先，我们来看几个简单的示例。
这段代码是没有问题的。我们的关注点是foo()这个函数，它在调用capitalize函数的时候，创建了一个临时的&amp;mut型引用，在它的调用结束后，这个临时的借用就终止了，因此，后面我们就可以再用data去修改数据。
注意，这个临时的&amp;mut引用存在的时间很短，函数调用结束，它的生命周期就结束了。
但是，如果我们把这段代码稍作修改，问题就出现了：
在这段代码中，我们创建了一个临时变量slice,保存了一个指向data的smut型引用，然后再调用capitalize函数，就出问题了。编译器提示为：
error[E0499]:cannot borrow `data’as mutable more than once at a time
这是因为，Rust规定“共享不可变，可变不共享”,同时出现两个&amp;mut型借用是违反规则的。
在编译器报错的地方，编译器认为slice依然存在，然而又使用data去调用fnpush(&amp;mut self,value:T)方法，必然又会产生一个&amp;mut型借用，这违反了Rust的原则。
在目前这个版本中，如果我们要修复这个问题，只能这样做：
我们手动创建了一个代码块，让slice在这个子代码块中创建，后面就不会产生生命周期冲突问题了。
这是因为，在早期的编译器内部实现里面，所有的变量，包括引用，它们的生命周期都是从声明的地方开始，到当前语句块结束(不考虑所有权转移的情况)。
这样的实现方式意味着每个引用的生命周期都是跟代码块(scope)相关联的，它总是从声明的时候被创建，在退出这个代码块的时候被销毁，因此可以称为Lexical lifetime。
而所说的Non-Lexical lifetime,意思就是取消这个关联性，引用的生命周期，我们用另外的、更智能的方式分析。
有了这个功能，上例中手动加入的代码块就不需要了，编译器应该能自动分析出来，slice这个引用在capitalize函数调用后就再没有被使用过了，它的生命周期完全可以就此终止，不会对程序的正确性有任何影响，后面再调用push方法修改数据，其实跟前面的slice并没有什么冲突关系。
看了上面这个例子，可能有人还会觉得，显式的用一个代码块来规定局部变量的生命周期是个更好的选择，Non-Lexical-Lifetime的意义似乎并不大。
那我们再继续看看更复杂的例子。我们可以发现，Non-Lexical-Lifetime可以打开更多的可能性，让用户有机会用更直观的方式写代码。比如下面这样的一个分支结构的程序：
这段代码从一个HashMap中查询某个key是否存在。
如果存在，就继续处理，如果不存在，就插入一个新的值。
目前这段代码是编译不过的，因为编译器会认为在调用getmut(&amp;key)的时候，产生了一个指向map的amut型引用，而且它的返回值也包含了一个引用，返回值的生命周期是和参数的生命周期一致的。
这个方法的返回值会一直存在于整个match语句块中，所以编译器判定，针对map的引用也是一直存在于整个match语句块中的。
于是后面调用insert方法会发生冲突。
当然，如果我们从逻辑上来理解这段代码，就会知道，这段代码其实是安全的。
因为在None分支，意味着map中没有找到这个key,在这条路径上自然也没有指向map的引用存在。
但是可惜，在老版本的编译器上，如果我们希望让这段代码编译通过，只能绕一下。我们试一下做如下的修复：
实际上这个改动依然会编译失败。
原因就在于return语句，get_mut时候对map的借用传递给了Some(value),在Some这个分支内存在一个引用，指向map的某个部分，而我们又把value返回了，这意味着编译器认为，这个借用从match开始一直到退出这个函数都存在。因此后面的insert调用依然发生了冲突。
接下来我们再做一次修复：
这次的区别在于，get_mut发生在一个子语句块中。
在这种情况下，编译器会认为这个借用跟if外面的代码没什么关系。
通过这种方式，我们终于绕过了borrow checker。
但是，为了绕过编译器的限制，我们付出了一些代价。
这段代码，我们需要执行两次hash查找，一次在contains方法，一次在get_mut方法，因此它有额外的性能开销。
这也是为什么标准库中的HashMap设计了一个叫作entry的api,如果用entry来写这段逻辑，可以这么做：
这个设计既清晰简洁，也没有额外的性能开销，而且不需要Non-Lexical-Lifetime的支持。
这说明，虽然老版本的生命周期检查确实有点过于严格，但至少在某些场景下，我们其实还是有办法绕过去的，不一定要在“良好的抽象”和“安全性”之间做选择。
但是它付出了其他的代价，那就是设计难度更高，更不容易被掌握。
标准库中的entry API也是很多高手经过很长时间才最终设计出来的产物。
对于普通用户而言，如果在其他场景下出现了类似的冲突，恐怕大部分人都没有能力想到一个最佳方案，可以既避过编译器限制，又不损失性能。
所以在实践中的很多场景下，普通用户做不到“零开销抽象”。
让编译器能更准确地分析借用指针的生命周期，不要简单地与scope相绑定，不论对普通用户还是高阶用户都是一个更合理、更有用的功能。如果编译器能有这么聪明，那么它应该能理解下面这段代码其实是安全的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d30339721a84bc544fad9e5527056a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c5b98e6d1fa22888b251ec138136794/" rel="bookmark">
			微信小程序------WXML模板语法之条件渲染和列表渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、条件渲染
1.wx:if
2. 结合 使用 wx:if
3. hidden
4. wx:if 与 hidden 的对比
二、列表渲染
1. wx:for
2. 手动指定索引和当前项的变量名*
3. wx:key 的使用
前言 上一期我们讲解wxml模版语法中的数据绑定和事件绑定（上一期链接：微信小程序-----WXML模板语法之数据绑定与事件绑定-CSDN博客），那么本期我们继续wxml语法的学习，本期的主要内容是条件渲染和列表渲染，下面就开始本期的学习吧！
一、条件渲染 1.wx:if 在小程序中，使用 wx:if="{{ condition }}" 来判断是否需要渲染该代码块： &lt;view wx:if="{{condition}}"&gt;show me&lt;/view&gt; 也可以用 wx:elif 和 wx:else 来添加 else 判断： &lt;!-- 条件渲染 --&gt; &lt;view wx:if="{{type==1}}"&gt;男&lt;/view&gt; &lt;view wx:elif="{{type==2}}"&gt;女&lt;/view&gt; &lt;view wx:else&gt;其他&lt;/view&gt; 然后我们在js文件中去定义变量参数type：
Page({ /** * 页面的初始数据 */ data: { type:1 }, }) 2. 结合 &lt;block&gt; 使用 wx:if 如果要 一次性控制多个组件的展示与隐藏 ，可以使用一个 &lt;block&gt;&lt;/block&gt; 标签将多个组件包装起来，并在 &lt;block&gt; 标签上使用 wx:if 控制属性，示例如下： &lt;block wx:if="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c5b98e6d1fa22888b251ec138136794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514d163084a3fd26a7b7661089922c4e/" rel="bookmark">
			MyBatisPlus学习笔记二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上：MyBatisPlus学习笔记一：
MyBatisPlus学习笔记一-CSDN博客
1、条件构造器 MyBatisPlus支持各种复杂的where条件，可以满足日常开发的所有需求。
1.1、集成体系 1.2、实例 查询 lambda查询 更新 1.3、总结 2、自定义sql 我们可以利用MyBatisPlus的Wrapper来构建复杂的Where条件，然后自己定义SQL语句中剩下的部分。
2.1、基于Wrapper构建where条件 2.2、在mapper方法参数中用Param注解声明wrapper变量名称，必须是ew 2.3、自定义sql，并使用Wrapper条件 2.4、总结 3、Service接口 3.1、service接口 3.2、解释图 3.3、实例-service 3.4、实例-serviceImpl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe770d0f733565296fb48092a6dd52e/" rel="bookmark">
			B端产品经理学习-B端产品的项目管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目管理的作用 指导Roadmap落地 每个节点的项目时间需要按照时间点落地，才不会影响后面的项目事件
为了明确需求，明确研发的工作 避免产研部门因为需求扯皮、研发部门抱怨需求文档不够清晰、在开发过程中增加很多细节需求、增加了研发的工作量、初次排期不准导致延期上线等问题。
满足业务方按时按质交付的需求 确保项目高效开展、高质量交付、按时完成，不至于延期上线，保障运营能按时进行线上运营
控制风险 面向复杂的业务和爆发增长的需求时，更要严格按照项目管理制度来规范管理、控制风险。
项目管理的特点 用户故事：
产品经理学习-用户故事上-CSDN博客
PRD文档：
产品经理学习-怎么写PRD文档-CSDN博客
什么时候使用项目管理 产研部门：
新产品概念测试新产品可行性研究产品线战略规划、迭代规划等研发项目 运营销售部门：
客户满意度调查新产品试运营活动筛选采购供应商的任务，如招采任务一次短期活动，如促销活动 产品经理的项目管理工作 产品经理在各阶段的工作 市场调研和需求挖掘阶段：
用户大故事和立项规划、协调业务方、合作方等资源资源准备：立项报告、调研内容和必要可行性分析通过立项会宣讲项目内容和价值等，由专家评审团评估是否能过立项，立项通过才能准备研发实施 在产品设计阶段：
产品需求归纳转化、需求池管理和优先级排序协调研发资源组织需求评审和回顾需求池组织产品设计环节 在研发阶段的工作
组织研发资源、排期和研发工作量的评估组织研发阶段的评审监督进度、风险预报就在研发偏差，协助敏捷开发按周汇报、月汇报、进度风险提醒甘特图等软件辅助研发测试质量的监督、研发代码规范和测试规范等组织业务方验收、确保版本顺利上线上线后安排研发人员维护系统等工作 项目管理工作组成比例： 沟通协调
跨部门沟通协作，与业务方、产品、研发等团队协调组织开会评审等工作研发站会发邮件汇报 风险管理
遇到问题，及时解决通知风险到各部门及时调整排期 项目规范管理
从项目战略规划考虑整体的收益和成本，申请立项和合适的研发资源研发责任到人，排期合理，确保按计划上线交付质量监督检验：需求文档、研发文档、研发代码规范，测试文档及规范等明确规范项目管理软件辅助管理动态调整排期中的人员或工作量 项目管理的工具——甘特图 提出者是亨利·劳伦斯·甘特，甘特图又称横道图、条状图。可以通过条状图来显示项目、进度和其他时间相关的系统进展的内在关系。随着时间进展，在现代的项目管理中，被广泛应用。
甘特图的作用： 各产品线的研发、测试团队等根据图中的任务开始时间来开始各自的工作，按工作量来规划工作管理人员能够查看某一项工程或产品是否落后于预定的计划，然后会采取行动加以纠正，以便工程能够赶上计划执行人可以直观地知道某些任务在某些时间短要做，提供更精准的时间段数据，还能直接更新任务进程。研发leader、测试leader和产品经理都能计算出每个项目的工时量，便于统筹整体工作和计算成本。可根据其中项目的临时变动，调整其他依赖项目的规划 绘制步骤： 明确B端产品涉及到的各项主项目。每个主项目包含项目名称、开始时间、结束时间、工作量等通过execl可绘制甘特图草图，将所有的项目按照开始时间、工期标注到甘特图上，按照依赖关系把项目首尾连接起来。中间可以留几天的余地。将团队拉进来，把各个主项目责任人安排好，让责任人确认具体排期。各责任人把项目拆分子项目，安排任务类型，确认开始时间和结束时间以及执行人等评估和调整各子项目活动任务的工时量评估和调整每个主项目的工时量和总工时量 项目管理常遇到的问题和解决方法
常见问题
解决方法
产生跨端、跨产品线现象，中台的崛起，各业务线都与其交叉连接，都依赖中台的排期，可能会出现不确定的风险
申请公司的战略项目能够获得领导的重视，给予更多的研发资源和关注度，为项目快速顺利完成提供保障决策层的激励机制，每个产品线或中台都能获得其他项目带来的收益贡献与跨线的产品负责人等领导明确项目价值，达成共识 开发人员未及时更新项目管理软件，线上管理和线下脱节
每日站会汇报，更新排期表定期检查甘特图的更新情况，做到线上线下保持一致研发经理或组长负责人，及时通报延期风险 跨部门协作的人员过多，无法及时获得最新进度和风险
跨线产品负责人及时通报排期调整的风险协同定时日报、周报、汇报等 解决项目管理中的问题
善于总结记录项目管理过程中的问题及解决方法老开发承担重要功能的开发，以及肩负带领新开发的责任，协助新开发熟悉原有系统功能等及时复盘分析 周报示范：
本周概述
对本周情况做一个整体的概述，进度百分比，当前进度状态
主要事件
如完成xx功能的开发以及xxx功能的测试
项目进度
按照甘特图的方式，列出本周完成的工作在整体项目中的位置。与项目计划相比是提前还是滞后，与上一周相比的前进量。
当前问题风险及解决方法
描述当前在研发过程存在的问题或者风险，给出切实可行的行动方案，如还未有方案，则写明预计解决时间。如需要各部门哪些配合、需要领导层哪些协助的，则写明所需支持部分
下周计划
依照甘特图规划的下周任务计划进行上报，包括具体的任务工作内容、时间节点、责任人等
周报包含的内容：项目名称、项目基本信息、项目状态、项目进展、风险问题、所需支持帮助、项目成员、其他备注
产品经理的能力提升 在管理扁平、层级少的情况下，产品可以通过积极游说的方式推动项目
找到关键人物，并积极游说获得支持，最好是产品线的负责人保持强的推动力和执行力，自己定好过程和进度，通过推动产生良好的结果全力投入，耐心有技巧，这是锻炼个人综合能力的好机会。面对复杂的工作内容，首先要理清脉络，制定计划。列出行动步骤、短期计划，明确每个细节事项的执行人，用时和联调时间定期开例会，要核心人员准时出席。Check每人的进展，问询遇到的问题和下一次会议之前的工作计划，汇日要每周定期进行，根据不同阶段调整节奏。形成日报、周报发送给项目有关人员。通报进度、进展情况、警示风险、让相关人员直销并推动解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3699356b5886183e721b7131b104267/" rel="bookmark">
			fetch、axios 和 XMLHttpRequest的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 fetch、axios和 XMLHttpRequest的区别XMLHttpRequest (XHR)XMLHttpRequest 和 fetch区别axios 和 fetch区别 fetch、axios和 XMLHttpRequest的区别 XMLHttpRequest (XHR) 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest
XMLHttpRequest (XHR) 是一种在客户端和服务器之间进行异步数据交换的技术，它允许浏览器向服务器发送HTTP请求，获取数据并更新部分网页内容，而无需刷新整个页面。XHR 是现代Web开发中常用的一种技术，用于实现AJAX（Asynchronous JavaScript and XML）请求和数据交互。
XHR的优势在于它可以在不刷新整个页面的情况下获取服务器数据并更新页面，从而实现更加流畅的用户体验。它在Web开发中广泛用于实现动态内容加载、表单提交、数据交互等功能。但也需要注意，由于XHR可以跨域请求数据，可能会涉及到安全性问题，因此在使用XHR时需要谨慎处理跨域请求和防止XSS攻击。
现代Web开发中更常使用fetch或axios等工具库来进行网络请求，因此XMLHttpRequest已逐渐被废弃。
XMLHttpRequest 和 fetch区别 XMLHttpRequest 是较早的浏览器提供的 API，使用起来相对复杂。它需要手动创建、配置和发送请求，并监听事件来处理响应。
fetch 是较新的浏览器提供的 API，使用起来更加简洁和易用。它返回一个 Promise 对象，可以使用链式调用来处理请求和响应。
XMLHttpRequest 可以通过设置 onreadystatechange 事件监听器或使用 addEventListener 方法来处理异步请求的状态变化。
fetch 返回的 Promise 对象可以使用 then 和 catch 方法来处理请求的成功和失败。
XMLHttpRequest 兼容性非常好，可以在大多数现代浏览器中使用。
fetch 是较新的标准，相对于 XMLHttpRequest，它在一些旧版本的浏览器中可能不被支持。为了兼容旧版本浏览器，可能需要使用 fetch 的 polyfill 或使用其他库（如 Axios）进行网络请求。
axios 和 fetch区别 xios 和 fetch 都是用于发起网络请求的工具，它们有一些区别和特点。
以下是 axios 和 fetch 的一些区别：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3699356b5886183e721b7131b104267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/387992af3749219907a136dfc7cefb48/" rel="bookmark">
			宣布推出适用于 .NET 的 Azure Migrate 应用程序和代码评估工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Olia Gavrysh - Senior Product Manager, .NET
排版：Alan Wang
我们很高兴地宣布我们将发布一项新工具，它可以帮助您将本地 .NET 应用程序迁移到 Azure。
Azure Migrate 应用程序和 .NET代码评估工具（简称 AppCAT）让您能够评估应用程序的 .NET 源代码、配置和二进制文件，识别将应用程序迁移到 Azure 的过程中可能潜在的问题和概率。它有助于发现应用程序在移植到 Azure 时可能遇到的问题，并通过推荐现代的云原生解决方案来提高性能、可扩展性和安全性。
运行分析后，该工具将向您显示一份报告，报告会列举您可能需要检查或更改的所有事项，以确保您的应用程序从本地迁移到 Azure 后能够正常工作。
AppCAT 通过对代码及其依赖项进行静态代码分析来发现应用程序技术的使用情况。它还允许您直接跳转到需要您注意的代码行，从而解决问题并将其标记为已修复，最后这个工具会保存问题的当前状态和报告，这样您或您的同事可以准确地从您上次修改过的地方重新开始。该工具可以帮您估算修复每个问题所需的工作量并且它还能对应用程序和整个项目的组件进行评估。它将提供有关如何解决问题的详细指导，并链接到 Microsoft 文档。
AppCAT 有两种“风格”——作为 Visual Studio 扩展和作为 .NET CLI 工具。
安装 Visual Studio 扩展 先决条件 Windows 操作系统Visual Studio 2022 版本 17.1 或更高版本 安装步骤 请参照以下步骤从 Visual Studio 下载并安装它。或者，您也可以从 Visual Studio Marketplace 下载并安装扩展。
打开 Visual Studio 后，按 Extensions &gt; Manage Extensions 菜单项，打开 Manage Extensions 窗口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/387992af3749219907a136dfc7cefb48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/397ba532529c793cafee9f596f918309/" rel="bookmark">
			操作系统概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 文章目录 概述定义功能特征并发共享并发与共享的关系虚拟异步 发展与分类手工操作阶段批处理阶段分时操作系统实时操作系统网络操作系统分布式操作系统个人计算机操作系统 运行机制程序是如何运行的？内核程序应用程序特权指令非特权指令内核态用户态内核态与用户态的切换中断类型内中断(异常)外中断 中断机制的基本原理系统调用与库函数的区别按功能分类过程 体系结构大内核 vs 微内核分层结构优点缺点 模块化外核**优点****缺点** 引导虚拟机 定义 操作系统(Operating System，OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配;以提供给用户和其他软件方便的接口和环境。它是计算机系统中最基本的系统软件。
上面三个箭头的含义为：
① 操作系统是系统资源的管理者。
② 操作系统可以向上层提供方便易用的服务：操作系统利用了封装思想，把一些较为晦涩的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。
操作系统向上层提供的常用的服务：
GUI(图形化接口)：用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。联机命令接口(用户输入一条命令，操作系统执行一条命令)：指的是计算机系统中的一种用户界面，它允许用户通过输入文本命令与计算机进行交互。这种界面是通过命令行来实现的，用户可以在命令提示符下键入命令，然后计算机会根据命令执行相应的操作。脱机命令接口(用户输入多条命令，操作系统按顺序执行多条命令)：通常使用批处理脚本或命令文件(如Windows中的*.bat文件)来定义一系列要在脱机模式下执行的操作。这些脚本包含了一系列命令和指令，可以按照预定的顺序自动执行。程序接口：在计算机编程中，用于不同组件、模块或程序之间进行通信和互操作的方式和规范。它定义了如何调用和使用特定组件或服务的方法、参数和约定。可以在程序中进行系统调用来使用的接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。 命令接口(联机、脱机命令接口)与程序接口统称为用户接口。
③ 操作系统是最接近硬件的一层软件。
功能 操作系统执行以下主要功能：
资源管理： 操作系统负责管理计算机硬件资源，包括中央处理器（CPU）、内存、磁盘存储、输入/输出设备等。它分配这些资源，确保不同的程序和任务能够共享它们，同时避免冲突和资源争用。进程管理： 操作系统控制和协调各个进程（也称为任务或程序），以便多个程序可以同时运行。它分配CPU时间片，管理进程之间的切换，以及处理进程的创建、终止和通信。内存管理： 操作系统管理计算机的物理内存，为不同的程序提供内存空间，同时负责内存的分配和回收。它还处理虚拟内存，将数据从硬盘上移到内存中，以扩展可用内存。文件系统管理： 操作系统负责管理计算机上的文件和目录结构，以及文件的创建、读写和删除。它提供了一种组织数据的方式，以便用户和应用程序可以轻松地存储和检索信息。设备管理： 操作系统与计算机的硬件设备进行通信，以便应用程序可以与输入设备（如键盘和鼠标）和输出设备（如显示器和打印机）进行交互。用户界面： 操作系统通常提供用户界面，用户可以通过命令行界面或图形用户界面（GUI）与计算机进行交互。安全性和权限管理： 操作系统确保系统的安全性，包括用户身份验证、访问控制和数据保护。它管理用户和应用程序的权限，以防止未经授权的访问。错误处理和故障恢复： 操作系统能够检测并处理硬件和软件错误，以确保系统的稳定性和可靠性。它还提供了故障恢复机制，以便在发生错误时恢复系统的正常运行。 特征 操作系统总共有四大主要特征：并发、共享、虚拟、异步。
其中并发与共享是两个最基本的特征，二者互为其存在的条件。
并发 并发：是指操作系统能够同时管理多个任务（进程或线程），这些任务可以并行执行。操作系统通过调度算法来分配CPU时间片，使不同的任务交替执行，从而实现了并发性。这使得多个程序可以在计算机上同时运行，提高了计算机系统的效率和资源利用率。并发性对于多用户系统、多任务处理和多核处理器等情况非常重要。
其中，最容易与并发搞混的概念是并行：同时执行多个任务或操作的能力。通常涉及到同时处理多个计算任务，以加速计算或提高系统的性能。并行计算可以在多个处理器、多核处理器、分布式计算环境或GPU等硬件设备上实现。
简单来说，就是并发指的是两个或者多个事件在同一时间间隔内发生。这些时间宏观上是同时发生的，但是在微观上是交替发生的。并行则是指两个或者多个事件在同一时刻发生。
注意：单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行(默认情况下)。
多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地运行。
共享 共享是指多个用户或程序可以共享计算机的资源，包括CPU、内存、磁盘存储、输入/输出设备等。共享性允许多个任务访问相同的资源，但同时也需要操作系统确保资源的安全共享，以避免资源冲突和数据损坏。共享性有助于最大程度地利用计算机资源，提高了系统的效率。
资源共享分为了两种方式：互斥共享与同时共享
这两种方式有不同的特点和适用场景：
互斥共享方式（Mutual Exclusion Sharing）： 互斥共享方式指的是资源在某一时刻只能被一个任务或进程占用，其他任务必须等待资源释放后才能访问它。这种方式通过互斥锁（Mutex）或信号量等机制来实现资源的互斥访问，以防止多个任务同时访问和修改资源，从而避免资源冲突和数据不一致。
优点：
确保资源的互斥访问，避免了资源冲突。简单且容易实现，有助于避免竞态条件（Race Condition）。 缺点：
可能会导致资源的低效利用，因为其他任务必须等待资源释放。不能充分利用多核处理器或多处理器系统的并行性。 互斥共享方式通常用于需要保护共享资源完整性和避免竞态条件的情况，如访问文件、数据库记录或共享内存区域。
同时共享方式（Concurrent Sharing）： 同时共享方式允许多个任务或进程同时访问和使用同一资源，而不需要互斥访问。这种方式通常需要使用同步机制（如信号量、互斥锁或条件变量）来确保资源的安全访问和数据的一致性。
优点：
提高了资源的利用率，充分利用了系统的并行性。增加了系统的吞吐量，多个任务可以并行执行。 缺点：
需要谨慎管理共享资源，以避免数据访问冲突和竞态条件。实现更复杂，需要考虑同步和并发控制问题。 同时共享方式通常用于可以被多个任务或进程同时安全共享的资源，如内存、网络连接或某些数据结构。
并发与共享的关系 并发性是指计算机系统中同时存在着多个运行着的程序。
共享性是指计算机系统中的资源可供内存多个并发执行的进程共同使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/397ba532529c793cafee9f596f918309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c26f61d33a907089df46c14ffcd509a2/" rel="bookmark">
			全链路压力测试：现代软件工程中的重要性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全链路压力测试不仅可以确保系统在高负载下的性能和稳定性，还能帮助企业进行有效的风险管理和性能优化。在快速发展的互联网时代，全链路压力测试已成为确保软件产品质量的关键步骤。
1、测试环境搭建
测试应在与生产环境尽可能相似的环境中进行，以确保测试结果的准确性。
2、测试工具选择
选择适合的压力测试工具是重要的一步，常见的工具有JMeter、LoadRunner、掌动智能等。
3、测试用例设计
设计全面的测试用例，包括各种正常和极端的使用场景。
4、持续监控与分析
在测试过程中，持续监控系统表现并及时分析数据，以便快速定位问题。
以上就是掌动智能为大家整理的文章内容，希望对您有所帮助。如想咨询其它问题，请登入官网与在线客服一对一沟通。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19fed566783a8dcce10d9870b0b58bc/" rel="bookmark">
			分布式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式事务 文章目录 分布式事务分布式事务CAP定理一致性可用性分区容错产生的矛盾 BASE理论如何解决分布式事务产生的问题 SeataSeata架构部署TC服务微服务集成Seata引入依赖修改配置文件模拟异地TC集群将事务组映射配置到nacos微服务读取nacos配置 Seata事务模式XA模式Seata的XA模型实现XA模式 AT模式Seata的AT模型脏写问题优缺点实现AT模式 TCC模式Seata的TCC模式优缺点空回滚与事务悬挂实现TCC模式 SAGA模式原理优缺点 四种模式对比 事务一般分为两种，一种是传统的 单机事务，也就是本地事务，在传统数据库事务中，都必须满足 ACID四个原则： 分布式事务 分布式事务，就是指不是在单个服务或单个数据库架构下，产生的事务，例如：
跨数据源的分布式事务跨服务的分布式事务综合情况 在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。例如电商行业中比较常见的下单付款案例，包括下面几个行为：
创建新订单扣减商品库存从用户账户余额扣除金额 完成上面的操作需要访问三个不同的微服务和三个不同的数据库。
订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。
但是当把三件事情看做一个"业务"，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是分布式系统下的事务了。
此时ACID难以满足，这是分布式事务要解决的问题。
例如，当传统的库存服务与账户服务分离成独立的微服务之后，当库存不足时，用户发起购买，此时余额已经扣减，并不会回滚，就出现了最常见的分布式事务问题。
要想解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导。
CAP定理 1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。
Consistency（一致性）Availability（可用性）Partition tolerance （分区容错性） 它们的第一个字母分别是 C、A、P。
Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。
一致性 Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。
比如现在包含两个节点，其中的初始数据是一致的：
当修改其中一个节点的数据时，两者的数据产生了差异：
要想保住一致性，就必须实现node01 到 node02的数据 同步：
可用性 Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。
如图，有三个节点的集群，访问任何一个都可以及时得到响应：
当有部分节点因为网络故障或其它原因无法访问时，代表节点不可用：
分区容错 Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。
Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务。
产生的矛盾 在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免。
当节点接收到新的数据变更时，就会出现问题了：
如果此时要保证一致性，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。
如果此时要保证可用性，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致。
也就是说，在P一定会出现的情况下，A和C之间只能实现一个。
BASE理论 BASE理论是对CAP的一种解决思路，包含三个思想：
Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。**Soft State（软状态）：**在一定时间内，允许出现中间状态，比如临时的不一致状态。Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。 如何解决分布式事务产生的问题 分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a19fed566783a8dcce10d9870b0b58bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a2b8d289bf094ec370f30b71aa3857/" rel="bookmark">
			AI嵌入式K210项目（3）-GPIO控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、背景知识二、背景知识二、开始你的表演代码实现 总结 前言 前面介绍了开发板和环境搭建的基本情况，接下来我们开始学习使用C进行裸板开发，本节课先来学习下K210最基础的功能，引脚映射和点灯。
在开始具体学习之前，我介绍下通用的学习和使用方法：大致了解芯片-&gt;了解进行编程的类型（GPIO/I2C/UART/SPI）-&gt;查看硬件原理图-&gt;查看编程手册-&gt;进行编程。让我们以一个IO控制开始吧！
一、背景知识 对LED/RGB灯编程其实本质是一样的，RGB可以看作三个LED灯，都是对io的控制，LED发光二极管是一种能够将电能转化为可见光的固态的半导体器件，它可以直接把电转化为光。LED的内部是一个半导体晶片，晶片的一端附在一个支架上，一端是负极，另一端连接电源的正极，使整个晶片被环氧树脂封装起来。只需要给正极输入正极电压，负极接地，形成回路就可以点亮LED。
半导体晶片由两部分组成，一部分是P型半导体，在它里面空穴占主导地位，另一端是N型半导体，在这边主要是电子。但这两种半导体连接起来的时候，它们之间就形成一个P-N结。当电流通过导线作用于这个晶片的时候，电子就会被推向P区，在P区里电子跟空穴复合，然后就会以光子的形式发出能量，这就是LED灯发光的原理。而光的波长也就是光的颜色，是由形成P-N结的材料决定的。
在编程之前我们还需要进一步了解该款芯片，K210芯片使用BGA144封装，144个引脚，正方形，每一边有12个引脚。芯片宽度为8mm，长度为8mm，高度为0.953mm
引脚描述如下：
二、背景知识 可以看到，开发板板载了一颗可编程RGB灯，对其进行编程控制，需要了解其所连接的IO引脚；
接下来我们查看下原理图，可以看到他们分别连接到了IO12-IO14上，不同的IO控制不同颜色的灯，设置IO为输出模式，当IO设置为高电平时，对应的灯熄灭，当IO设置为低电平时，对应的灯点亮；
二、开始你的表演 这篇文章内容会涉及到FPIOA的使用，FPIOA的介绍可以参考我的 AI嵌入式K210项目（4）-FPIOA
新建一个gpio的文件夹，在里面新建main.c，以后也都是这样，我们每一个实验放一个文件夹
代码实现 为了方便大家看，我就不搞什么代码规范之类的了，直接放在一个文件里，方便大家查看
#include "sleep.h" #include "gpio.h" #include "fpioa.h" /*****************************HARDWARE-PIN*********************************/ // 硬件IO口，与原理图对应 #define PIN_RGB_R (12) #define PIN_RGB_G (13) #define PIN_RGB_B (14) /*****************************SOFTWARE-GPIO********************************/ // 软件GPIO口，与程序对应 #define RGB_R_GPIONUM (0) #define RGB_G_GPIONUM (1) #define RGB_B_GPIONUM (2) /*****************************FUNC-GPIO************************************/ // GPIO口的功能，绑定到硬件IO口 #define FUNC_RGB_R (FUNC_GPIO0 + RGB_R_GPIONUM) #define FUNC_RGB_G (FUNC_GPIO0 + RGB_G_GPIONUM) #define FUNC_RGB_B (FUNC_GPIO0 + RGB_B_GPIONUM) /** * Function hardware_init * @brief 硬件初始化，绑定GPIO口 * @param[in] void * @param[out] void * @retval void * @par History 无 */ void hardware_init(void) { // fpioa映射 fpioa_set_function(PIN_RGB_R, FUNC_RGB_R); fpioa_set_function(PIN_RGB_G, FUNC_RGB_G); fpioa_set_function(PIN_RGB_B, FUNC_RGB_B); } /** * Function hardware_init * @brief RGB灯灭 * @param[in] void * @param[out] void * @retval void * @par History 无 */ void rgb_all_off(void) { gpio_set_pin(RGB_R_GPIONUM, GPIO_PV_HIGH); gpio_set_pin(RGB_G_GPIONUM, GPIO_PV_HIGH); gpio_set_pin(RGB_B_GPIONUM, GPIO_PV_HIGH); } /** * Function init_rgb * @brief 初始化RGB灯 * @param[in] void * @param[out] void * @retval void * @par History 无 */ void init_rgb(void) { // 设置RGB灯的GPIO模式为输出 gpio_set_drive_mode(RGB_R_GPIONUM, GPIO_DM_OUTPUT); gpio_set_drive_mode(RGB_G_GPIONUM, GPIO_DM_OUTPUT); gpio_set_drive_mode(RGB_B_GPIONUM, GPIO_DM_OUTPUT); // 关闭RGB灯 rgb_all_off(); } /** * Function main * @brief 主函数，程序的入口 * @param[in] void * @param[out] void * @retval 0 * @par History 无 */ int main(void) { // RGB灯状态，0=红灯亮，1=绿灯亮，2=蓝灯亮 int state = 0; // 硬件引脚初始化 hardware_init(); // 初始化RGB灯 init_rgb(); while (1) { rgb_all_off(); // 先关闭RGB灯 // 根据state的值点亮不同颜色的灯 gpio_set_pin(state, GPIO_PV_LOW); msleep(500); state++; state = state % 3; } return 0; } 代码写好后，我们开始编译，注意：如果你编译过程中出现错误，可以先make clean掉之前生成的过程文件，重新生成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a2b8d289bf094ec370f30b71aa3857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1cc6dbc601786c5ccde87b59277840c/" rel="bookmark">
			分布式搜索——Elasticsearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch 文章目录 Elasticsearch简介ELK技术栈Elasticsearch和Lucene 倒排索引正向索引倒排索引正向和倒排 ES概念文档和字段索引和映射Mysql与Elasticsearch 安装ES、Kibana安装单点ES创建网络拉取镜像运行 部署kibana拉取镜像部署 安装Ik插件扩展词词典停用词词典 索引库操作ping映射属性索引库的CRUD 文档操作新增文档查询文档删除文档修改文档 RestAPImapping映射分析初始化RestClient创建索引表删除索引库判断索引库是否存在总结 RestClient操作文档查询文档删除文档修改文档批量导入文档 DSL查询文档DSL查询分类全文检索查询基本语法 精准查询term查询range查询 地理坐标查询矩形范围查询附近查询 复合查询相关性算分算分函数查询布尔查询 搜索结果处理排序分页 高亮原理实现 RestClient查询文档查询请求解析响应match查询精确查询布尔查询排序与分页 3.6.高亮3.6.1.高亮请求构建3.6.2.高亮结果解析 数据聚合聚合的种类DSL实现聚合Bucket聚合语法聚合结果排序限定聚合范围Metric聚合语法 RestAPI实现聚合API语法 自动补全拼音分词器自定义分词器自动补全查询自动补全查询的JavaAPI 数据同步同步调用异步通知监听binlog ES集群搭建集群创建索引库集群节点角色集群的脑裂问题分布式存储分布式查询集群故障转移 简介 Elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助用户从海量数据中快速找到需要的内容。例如：在GitHub搜索代码、在百度搜索问题的答案、在打车软件搜索附近的车。
ELK技术栈 elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域：
而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。
Elasticsearch和Lucene elasticsearch底层是基于lucene来实现的。
Lucene是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。是Apache的开源搜索引擎类库，提供了搜索引擎的核心API。
官网地址：https://lucene.apache.org/
elasticsearch的发展历史：
2004年Shay Banon基于Lucene开发了Compass2010年Shay Banon 重写了Compass，取名为Elasticsearch。 官网地址: https://www.elastic.co/cn/
倒排索引 倒排索引的概念是基于MySQL这样的正向索引而言的。
正向索引 那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引：
如果是根据id查询，那么直接走索引，查询速度非常快。
但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：
1）用户搜索数据，条件是title符合"%手机%"。
2）逐行获取数据，比如id为1的数据。
3）判断数据中的title是否符合用户搜索条件。
4）如果符合则放入结果集，不符合则丢弃。回到步骤1。
逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。
倒排索引 倒排索引中有两个非常重要的概念：
文档（Document）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条 创建倒排索引是对正向索引的一种特殊处理，流程如下：
将每一个文档的数据利用算法分词，得到一个个词条创建表，每行数据包括词条、词条所在文档id、位置等信息因为词条唯一性，可以给词条创建索引，例如hash表结构索引 倒排索引的搜索流程如下（以搜索"华为手机"为例）：
1）用户输入条件"华为手机"进行搜索。
2）对用户输入内容分词，得到词条：华为、手机。
3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。
4）拿着文档id到正向索引中查找具体文档。
虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。
正向和倒排 那么为什么一个叫做正向索引，一个叫做倒排索引呢？
正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是根据文档找词条的过程。
而倒排索引则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是根据词条找文档的过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1cc6dbc601786c5ccde87b59277840c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/18/">«</a>
	<span class="pagination__item pagination__item--current">19/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/20/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>