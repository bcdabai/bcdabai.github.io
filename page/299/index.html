<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a341511bcb6f703b74fda729f37a98e8/" rel="bookmark">
			MATLAB遗传算法工具箱的函数简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文简单介绍谢菲尔德大学开发的遗传算法工具箱的用法。 工具箱名字gatbx，即GA Toolbox。用help gatbx即可看到其所有函数。函数的功能分几大类：创建种群、适应度计算、选择、变异、交叉。
创建种群 crtbase 创建基向量 由图可知，产生了3个5，和4个6，5和6表示的是个体向量的范围。
crtbp 创建初始种群 Create an initial population 第一个参数表示生成的种群大小，3排5列，3表示有3个个体，5表示每个个体有5位。第二个参数表示这5位分别的范围，即基向量BaseV，比如6表示0~5, 3表示0~2，该参数可由crtbase生成。 返回值Lind表示每个个体的位数。
crtrp 创建实值种群 CReaTe an initial (Real-value) Population FieldDR表示范围，第一排表示最大值，第二排表示最小值。4表示产生的种群的个体数量。
适应度计算 ranking 基于排序的适应度分配。可以观察出，ObjV中最大的数在FitnV中最小，即反序排列。
scaling 线性适应度计算。 选择 select SelCh = select(SEL_F,Chrom,FitnV) SEL_F是字符串，表示选择的方法，有轮盘法rws，随机遍历抽样法sus。Chrom是多个个体组成的种群，FitnV是适应度 适应度值越大，被选中概率越大。select函数还可以加个参数表示输出个体的个数，比如1.5表示输出种群中个体的个数为原来个数的1.5倍。 reins 重插入子代到种群，插入位置是随机的，SelCh意为selected chrom被选中的个体，即子代
Chrom = reins(Chrom,SelCh) 变异 mutate NewChrom = mutate (MUT_F,OldChrom,FieldDR,MutOpt) MUT_F是字符串，表示变异算法，可选项mutbga或mut。mut是离散变异，mutbga是实值变异。FieldDR表示变异范围，MutOpt是变异概率。 交叉 交叉算子函数有：recdis，recint，reclin，recmut，recombin，xovdp，xovdprs，xovmp，xovsh，xovshrs，xovsp，xovsprs。 交叉是通过给定的概率重组一对个体产生后代。单点交叉、两点交叉和洗牌交叉是由xovsp、xovdp、xovsh函数分别完成的。缩小代理交叉函数分别是：xovdprs、xovshrs和xovsprs。通用的多点交叉函数是xovmp，它提供均匀交换的支持。为支持染色体实值表示，离散的、中间的和线性重组分别由函数recdis、recint、reclin完成。函数recmut提供具有突变特征的线性重组。
函数recombin是一高级入口函数，对所有交叉操作提供多子群支持入口。
recombin NewChrom = recombin(REC_F,Chrom,RecOpt) REC_F是字符串，表示交叉算法，RecOpt表示交叉概率。 变异发生在奇数行和偶数行之间，recdis是离散重组，一位一位地变异。此外还有中间重组，线性重组等。 以上是单点交叉，也就是奇偶两行逐点交换元素，有的交换，有的不交换，按概率。
“遗传算法工具箱文档翻译”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/174397aeeae17e5c9dcbc4389d4ffbab/" rel="bookmark">
			apt-get clean和remove相关命令解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apt-get autoclean
硬盘空间不大的话，可定期运行，将已经删除了的软件包的.deb安装文件从硬盘中删除掉。
apt-get clean
把已安装的软件包的安装包也删除掉。
apt-get clean
类似上面的命令，但它删除包缓存中的所有包。
apt-get autoremove
删除为了满足其他软件包的依赖而安装的，但现在不再需要的软件包。
apt-get remove 软件包名
删除已安装的软件包（保留配置文件）
apt-get --purge remove 软件包名称
删除已安装包（不保留配置文件)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958e7ba66cbb8554122fbf9c39e0ed1f/" rel="bookmark">
			固定高度的div在屏幕中居中方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何将一个固定高度的div居中在屏幕中间呢？ 先来看个例子，定义一个div并设置其高度为600px; html代码：
&lt;div class='a'&gt;&lt;/div&gt; css样式代码：
.a{ height:600px; background-color:#333; } 让div一直待在屏幕中间其实很简单，只需要在css代码中加上短短几句
.a{ height:600px; background-color:#333; position:absolute; top:50%; margin-top:-300px; } 注意：-300px不是巧合，是该div的高度的一半
有没有觉得很神奇，其实也很好理解。将div关于屏幕最上方下降50%，也就是该div的最上方刚好在屏幕的中间，然后将div向上移动自身高度的一半，当然就居中啦。
欢迎大家加入QQ群一起交流讨论， 「吟游」程序人生——YinyouPoet 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de44923e1ea0b57cd6388d2bf3f5915/" rel="bookmark">
			滚动条样式优化(CSS3自定义滚动条样式 -webkit-scrollbar)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候觉得浏览器自带的原始滚动条不是很美观，那webkit浏览器是如何自定义滚动条的呢？
Webkit支持拥有overflow属性的区域，列表框，下拉菜单，textarea的滚动条自定义样式。当然，兼容所有浏览器的滚动条样式目前是不存在的。
::-webkit-scrollbar 滚动条整体部分 ::-webkit-scrollbar-thumb 滚动条里面的小方块，能上下左右移动(取决于是垂直还是水平) ::-webkit-scrollbar-track 滚动条的轨道(里面装有thumb) ::-webkit-scrollbar-button 滚动条轨道两端的按钮，允许通过点击微调小方块的位置 ::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分(除去) ::-webkit-scrollbar-corner 边角，及两个滚动条的交汇处 ::-webkit-resizer 两个滚动条的交汇处上用于拖动调整元素大小的小控件 &lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;scrollbar&lt;/title&gt;
&lt;/head&gt;
&lt;style type="text/css"&gt;
.scrollbar1{
margin:20px auto;
width:200px;
height:100px;
overflow: auto;
}
.scrollbar2{
margin:20px auto;
width:200px;
height:100px;
overflow: auto;
}
/*定义滚动条宽高及背景,宽高分别对应横竖滚动条的尺寸*/
.scrollbar1::-webkit-scrollbar{
width:16px;
height:16px;
background-color:#f5f5f5;
}
/*定义滚动条的轨道,内阴影及圆角*/
.scrollbar1::-webkit-scrollbar-track{
-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);
border-radius:10px;
background-color:#f5f5f5;
}
/*定义滑块,内阴影及圆角*/
.scrollbar1::-webkit-scrollbar-thumb{
height:20px;
border-radius:10px;
-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de44923e1ea0b57cd6388d2bf3f5915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b443be3e6a5c79d4810929fbe5712b1/" rel="bookmark">
			检测自己的浏览器是否支持WebGL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在浏览器地址栏输入
https://get.webgl.org
如果得出下面图形，就说明浏览器是支持WebGLS的，经过尝试，发现Chome浏览器，微软Edge以及搜狗浏览器都能很好的支持WebGL。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a61f63b0428d64f425491d1c20408252/" rel="bookmark">
			This project references NuGet package(s) that are missing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		This project references NuGet package(s) that are missing on this computer .Enable NuGet Package Restore to download them. When getting this error, Visual Studio indicates that a NuGet package is missing from your project references. If you take a look at the project-&gt;references node, you will probably see that there are some missing libraries that have been added to the project via a NuGet package installation, and your system does not have the package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a61f63b0428d64f425491d1c20408252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00668cc868cd5bd9386857f23c47341/" rel="bookmark">
			NOIP 2006 普及组 复赛 happy 开心的金明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NOIP 2006 普及组 复赛 happy 开心的金明
1.读完题目，模拟样例，一直很纳闷3900是怎么算出的，同种物品能买多件吗？
2.同种物体只能买一件，从题目中怎么读出该题意？反复读题，题中透着此意，但不明确。
3.模拟样例：400*5+300*5+200*2=3900
4.识别出该题是01背包问题，但发现目前所掌握的动态规划，还不足以解决该问题。
5.搜索了一通，一下两篇文章值得学习：
http://blog.csdn.net/mu399/article/details/7722810
https://wenku.baidu.com/view/b7b9c83f9b89680203d825fd.html
6.弄懂了01背包。还不急着处理本题，先将http://blog.csdn.net/mu399/article/details/7722810例子编编。编着编着，突然发现，同样是处理01背包问题，程序编起来，循环的差异却非常大，看来要好好研究。
7.附上http://blog.csdn.net/mu399/article/details/7722810例子的输入输出：
输入：
10 5
4 6
5 4
6 5
2 3
2 6
输出：
15
代码：
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int fun(int a,int b){//返回最大值 if(a&gt;b)
return a;
else
return b;
}
int main(){
int w[10],v[10],n,m,i,j,f[20][20];
scanf("%d%d",&amp;n,&amp;m);
for(i=1;i&lt;=m;i++)
scanf("%d%d",&amp;w[i],&amp;v[i]);
for(i=0;i&lt;=m;i++)
f[i][0]=0;//空间为0 for(i=0;i&lt;=n;i++)
f[0][i]=0;//选中个数为0 for(j=0;j&lt;=n;j++)
for(i=1;i&lt;=m;i++)
if(j&lt;w[i])
f[i][j]=f[i-1][j];
else
f[i][j]=fun(f[i-1][j],f[i-1][j-w[i]]+v[i]);
printf("%d\n",f[m][n]);
}
8.回到本题，看了N（&lt;30000）表示总钱数，m（&lt;25）范围，N*m不会超时。
9.按01背包思路，进行编写，样例通过，提交AC，就是耗时56ms多了些，要找书来学习《挑战程序设计竞赛》。
附上AC代码，编译环境Dev-C++4.9.9.2
#include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e00668cc868cd5bd9386857f23c47341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2bc7143c52133e9ec56751cf281fe5/" rel="bookmark">
			如果你的App发生闪退,一般是什么原因造成的?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个面试题,是一道考验你实际开发经验的面试题.
一般App闪退是由于以下几个原因造成的.
1.缓存垃圾过多
由于安卓系统的特性,如果长时间不清理垃圾文件.会导致越来越卡.也会出现闪退情况.
2. 运行的程序过多,导致内存不足
3.应用版本兼容问题
如果应用版本太低，会导致不兼容，造成闪退。此外，有些新版本在调试中，也会造成应用闪退。
解决方法：如果是版本太旧，更新为新版本即可；如果是新版本闪退，可能是应用在改版调试，可卸载后安装旧版。
4.. 检查APP中访问网络的地方，组件中的ImageView是否可以正常的下载并显示到app 页面上。 5.检查APP的sdk和手机的系统是否兼容。
6.在一些特定情况下的闪退,比如播放视频,在Android5.0 升级到Android6.0的时候,有些系统API老版本有,新版本没有,到时回去对象的时候失败,报空,系统就会出现闪退问题.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39697b7f93950798e8ddc31cb1b90df0/" rel="bookmark">
			林子雨—大数据技术原理与应用—上机实验四
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：NoSQL和关系数据库的操作比较实验环境：
操作系统：ubuntu16.04
hadoop版本:1.2.1
JDK版本:1.8
Eclipse 3.8
Redis版本: 3.0.6
MongoDB版本: 2.6.0实验内容：
1.Redis数据库操作
1. 根据上面给出的键值对，用Redis的哈希结构设计出上述表格;(键值可以用student.zhangsan,student.lisi来表示两个键值属于同一个表格)。
a) 设计完之后,用hgetall命令分别输出zhangsan和lisi的成绩信息,并截图;
b) 用hget命令查询zhangsan 的Computer成绩,给出截图；
c) 修改lisi的Math成绩，改为95,给出截图；
2. 根据上面已经设计出的student表格,用Redis的JAVA客户端编程(jedis)。
d) 添加数据：English:45 Math:89 Computer:100；
效果图：
e) 获取scofield的English成绩信息；
效果图：
2.MongoDB数据库操作
1. 根据上面给出的文档,用Mongo shell设计出student集合。
a) 设计完后,用find()方法输出两个学生的信息,给出截图;
b) 用find函数查询zhangsan 的所有成绩(只显示score列),给出截图；
c) 修改lisi的Math成绩，改为95,给出截图；
2. 根据上面已经设计出的student集合,用MongoDB的JAVA客户端编程。
d) 添加数据:English:45 Math:89 Computer:100；
效果图：
e) 获取scofield的所有成绩成绩信息(只显示score列)；
效果图：
解决方案（列出遇到的问题和解决办法，列出没有解决的问题）：
1.Redis中value值存储中文字符后，再读取后发现出现乱码。
解决方法：用redis-cli打开客户端时，加上—raw参数。
没有解决的问题：
Mongo中像
这种数据，如果要修改里面某一项的成绩，利用$set命令需要把全部成绩都要写一遍。十分不方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd21fb4825558ae6773a47ee8e0b3406/" rel="bookmark">
			Unity测量工具——可视化直尺测量两点距离，并显示实时测量数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Unity进行虚拟现实开发中，遇到了一个需求：如何做出一种测量工具，可以测量出虚拟空间中鼠标点下到鼠标拖动过程中两定点间的距离，并且实时显示数据。这个需求并不难，直接上代码：
运行效果图如下：
Pai大星微信——2463954659，再见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9df17429c6e04c8d68863dbef3d5fb/" rel="bookmark">
			Hadoop网盘小项目实现（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上一篇的Hadoop为分布式环境的搭建，这里是我对Hadoop网盘小项目的一些实现过程。 该简易网盘实现了文件的上传下载删除功能，包括用户的注册于登录，比较基础，对于文件的操作主要调用HDFS对文件操作的API。 可以先看一下项目运行的截图： 登录界面: 登录之后的业务界面： 如图实现了上传下载删除等基础功能 上传： 实现上传文件到hadoop hdfs 删除下载： 之后会详述该项目是如何实现的。
Hadoop网盘小项目实现（二）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08282795c993784232319690c93abacc/" rel="bookmark">
			常用数字滤波算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在单片机进行数据采集时，会遇到数据的随机误差，随机误差是由随机干扰引起的，其特点是在相同条件下测量同一量时，其大小和符号会现无规则的变化而无法预测，但多次测量的结果符合统计规律。为克服随机干扰引起的误差，硬件上可采用滤波技术，软件上可采用软件算法实现数字滤波。滤波算法往往是系统测控算法的一个重要组成部分，实时性很强。
采用数字滤波算法克服随机干扰的误差具有以下优点：
1、数字滤波无需其他的硬件成本，只用一个计算过程，可靠性高，不存在阻抗匹配问题。尤其是数字滤波可以对频率很低的信号进行滤波，这是模拟滤波器做不到的。
2、数字滤波使用软件算法实现，多输入通道可共用一个滤波程序，降低系统开支。
3、只要适当改变滤波器的滤波程序或运算，就能方便地改变其滤波特性，这对于滤除低频干扰和随机信号会有较大的效果。
4、在单片机系统中常用的滤波算法有限幅滤波法、中值滤波法、算术平均滤波法、加权平均滤波法、滑动平均滤波等。
(1)限幅滤波算法
该运算的过程中将两次相邻的采样相减，求出其增量，然后将增量的绝对值，与两次采样允许的最大差值A进行比较。A的大小由被测对象的具体情况而定，如果小于或等于允许的最大差值，则本次采样有效;否则取上次采样值作为本次数据的样本。
算法的程序代码如下：
#defineA //允许的最大差值
chardata; //上一次的数据
char filter()
{
chardatanew; //新数据变量
datanew=get_data(); //获得新数据变量
if((datanew-data)&gt;A||(data-datanew&gt;A))
return data;
else
returndatanew;
}
说明：限幅滤波法主要用于处理变化较为缓慢的数据，如温度、物体的位置等。使用时，关键要选取合适的门限制A。通常这可由经验数据获得，必要时可通过实验得到。
(2)中值滤波算法
该运算的过程是对某一参数连续采样N次(N一般为奇数)，然后把N次采样的值按从小到大排列，再取中间值作为本次采样值，整个过程实际上是一个序列排序的过程。
算法的程序代码如下：
#define N11 //定义获得的数据个数
char filter()
{
charvalue_buff[N]; //定义存储数据的数组
char count,i,j,temp;
for(count=0;count
{
value_buf[count]=get_data();
delay(); //如果采集数据比较慢，那么就需要延时或中断
}
for(j=0;j
{
for(value_buff[i]&gt;value_buff[i+1]
{
temp=value_buff[i];
value_buff[i]=value_buff[i+1];
value_buff[i+1]=temp;
}
}
returnvalue_buff[(N-1)/2];
}
说明：中值滤波比较适用于去掉由偶然因素引起的波动和采样器不稳定而引起的脉动干扰。若被测量值变化比较慢，采用中值滤波法效果会比较好，但如果数据变化比较快，则不宜采用此方法。
(3)算术平均滤波算法
该算法的基本原理很简单，就是连续取N次采样值后进行算术平均。
算法的程序代码如下：
char filter()
{
int sum=0;
for(count=0;count
{
sum+=get_data();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08282795c993784232319690c93abacc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2078ffded4834bed9a396dd1fdb0c3ad/" rel="bookmark">
			local dns
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		local dns (local name server)是客户端网络设置的一部分，要么是手工配置，要么从DHCP得到。一般local dns 在从网络上靠近客户端。
主要的域，比如.com .net .org 等，都由Internet管理方进行管理维护，负责这些域的服务器也叫"根服务器", 根服务器里面有 foo.com 之类的子域，每个子域有一个或者多个服务器，这就是子域的权威服务器（授权DNS服务器）。
授权DNS服务器存储对于管理一个域名的重要信息，同时一个域名可以分为多个Zone，个Zone可以有各自的授权DNS,称为Zone of Authority(ZOA). 比如a.foo.com b.foo.com 可以有各自的ZOA
可以有一个或者多个授权DNS服务器，但是只有一个 primary authoritative DNS 负责分发域名name space的信息。
迭代查询和递归查询： 迭代查询：服务器可以回答确切答案，或者告知查询者其他可能知道答案的服务器。
递归查询：服务器必须回答确切答案，假如自己不知道，就要通过查询其他服务器得到答案。
客户端的DNS解析器一般无法处理迭代的回答，所以查询localDNS一般使用递归方式。服务器DNS解析器可以回答迭代或者递归查询，也可以发出递归或者迭代查询。
典型DNS查询流程: 1. 客户端向local dns查询 www.foo.com，注意这是递归查询
2.3. local dns 向 root name servers 查询 .com 的name server. 这里采用迭代方式。
4.5. local dns 向 .com 的 name server 查询 foo.com 的授权dns
6.7. local dns 向 foo.com 的授权dns得到 www.foo.com 的ip list
8. local dns 将 www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2078ffded4834bed9a396dd1fdb0c3ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86955a385658d2bcf757d30ae526260/" rel="bookmark">
			Java 文件上传，使用FileItem解析时，出现乱码的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 乱码的问题都是由编码引起的。解决此问题的方法是：
只需在接到字符后重新编码即可，具体实例代码如下：
在使用FileItem处，转换编码方式。
FileItem item=(FileItem)itr.next(); String tName=item.getString(); String str = new String(tName.getBytes("ISO8859_1),"utf-8"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99fd8a5f5e3f2a5ed7636d796e31b474/" rel="bookmark">
			Java源码心中有数系列 BlockingQueue / BlockingDeque
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 BlockingQueue 适用场景 生产者线程在一端生产 消费者线程在另一端消费
可以安全的实现 生产者消费者问题（多个生产者 多个消费者）
BlockingDeque Deque double ended queue 双端阻塞队列 线程安全 适用场景 该线程既是生产者 又是消费者 生产者线程需要在两端生产 消费者线程需要在两端消费 三类方法 插入 删除 检查 可能出现的操作结果 抛出一个异常 返回特殊的值 无限期阻塞当前线程 直至能够执行 给定时间内阻塞 超时之后返回特定值 内存一致性效果 将对象放入BlockingDeque之前的线程中的动作发生在 另一个线程中从BlockDeque访问或删除该元素的操作之前 ArrayBlockQueue 实现BlockingQueue 的有界阻塞队列 DelayQueue 实现BlockBlockQueue的 延时无限阻塞队列 LinkedBlockingQueue 实现BlockQueue接口的基于节点的阻塞队列 LinkedTransferQueue 基于节点的无界 TransferQueue 生产者可能会等待消费者接收元素 LinkedBlockingDeque 实现BlockDeque接口的基于节点的阻塞deque PriorityBlockingQueue 提供阻塞检测操作 SynchronousQueue 一个阻塞队列 每一个插入操作都必须等待另一个线程的删除操作 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1c05b920b13385f383d3d306f6c2ca/" rel="bookmark">
			MAC 下  defaults  命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		defaults:该命令 访问和修改Mac 上一些系统的默认设置（access the Mac OS X user defaults system） 1 隐藏DashBoard 1 2 defaults write com.apple.dashboard mcx-disabled -boolean YES killall Dock DashBoard里面有很多小工具，可惜并不是对每个人有用，通过上述命令即可隐藏，若需恢复，将YES替换为NO即可。
2 显示隐藏文件 1 2 defaults write com.apple.finder AppleShowAllFiles true killall Finder 还原的时候将true换成false即可。
3显示Safari调试菜单 1 2 defaults write com.apple.safari IncludeDebugMenu -bool YES killall Safari 4 显示Xcode 每一次build的所用时间 1 2 default write com.apple.dt.Xcode ShowBuildOperationDuration YES
显示 5 查看所有执行过的Defaults命令包括 defaults write, defaults read, defaults delete history |grep "defaults" 复制代码 分类查看也可以，只查看执行过的defaults write命令： history |grep "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1c05b920b13385f383d3d306f6c2ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3301c3246026501cd838b8885ff55973/" rel="bookmark">
			c语言宏定义详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文并不是完全转载，增加了部分自己的理解 &lt;script type="text/javascript"&gt; document.body.oncopy = function () { if (window.clipboardData) { setTimeout(function () { var text = clipboardData.getData("text"); if (text &amp;&amp; text.length &gt; 300) { text = text + "\r\n\n本文来自CSDN博客，转载请标明出处：" + location.href; clipboardData.setData("text", text); } }, 100); } } &lt;/script&gt; &lt;script type="text/javascript"&gt; function StorePage() { d = document; t = d.selection ? (d.selection.type != 'None' ? d.selection.createRange().text : '') : (d.getSelection ? d.getSelection() : ''); void (keyit = window.open('http://www.365key.com/storeit.aspx?t=' + escape(d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3301c3246026501cd838b8885ff55973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac8ead2ae69c1fff67ba6a6b116f8c7/" rel="bookmark">
			一道面试 数字转大写 java版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在android客户端H5化，搞得焦头烂额的时候，非常好的一哥们正在面试，就问我了这道题，银行一长串数字转成大写文字的问题，不是我吹，这道题应该在java面试宝典中出现过。上班的时候，真是没心情对他说，毕竟我自己也比较忙，就随便说了个思路，让他自己去想，今晚想想还有时间，就花点时间写了出来，主要原因如下：
1.虽说自己是搞java和android，但是个人感觉自己算法蛮差劲的，有机会练练，着玩意是编程之本； 2.当初思路不是很清晰，因为只是随便想想了，自己也不知道行不行，现在有机会自己试一下吧。
基本效果如下：
目测暂时没什么错误，如果有什么错误，你也不可能打我是吧。借此献给面试失败的哥们，因为我也很菜啊。
那么先说一下当时的思路吧，如图： 基本上天朝的算术，大家都清楚，都是有规律的，如果我们把字符串都切成四个字母的短的字符串A1,A2,A3,A4,….，然后将A1…An先转化成 ”三千二百四十九” 这种字符串，然后加上A1…An分别对应的单位兆，亿，万，个 这种单位就行了。
自己偷懒，也懒得找繁体字，就找了个大写字表示表示得了。
自己定义包含短串的字符对象：
public class FourNumbers { // 中文数字 private static final String[] DEFAULT_NUMBER = { "零", "一", "二", "三", "四", "五", "六", "七", "八", "九" }; // 单位 private static final String[] DEFALUT_UNIT = { "", "十", "百", "千" }; // 千 private int number1; // 百 private int number2; // 十 private int number3; // 个 private int number4; // 是否是最左边 private boolean isLeft; // 前面的一个数字是否为0 private boolean aheadIsZero; public FourNumbers(String number, boolean isLeft) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac8ead2ae69c1fff67ba6a6b116f8c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9097c344eb4dddbc2cf46a604586435/" rel="bookmark">
			numpy中的数组条件筛选功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在程序设计中，时常会遇到数据的唯一化、相同、相异信息的提取等工作，在格式化的向量存储矩阵中南，numpy能够提供比较不错的快速处理功能。 1，唯一化的实现： In [63]: data = np.array(['int','float','int','boolean','double','boolean']) In [64]: data Out[64]: array(['int', 'float', 'int', 'boolean', 'double', 'boolean'], dtype='|S7') In [65]: np.unique(data) Out[65]: array(['boolean', 'double', 'float', 'int'], dtype='|S7') In [66]: data = np.array([1,5,3,6,2,4,1,3,5,7,9]) In [67]: data Out[67]: array([1, 5, 3, 6, 2, 4, 1, 3, 5, 7, 9]) In [68]: np.unique(data) Out[68]: array([1, 2, 3, 4, 5, 6, 7, 9]) 通过unique可以实现数组的唯一化，并且，唯一化后的返回值会进行排序。 2，交集的实现 In [69]: data1 = np.arange(10) In [70]: data1 Out[70]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) In [71]: data2 = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9097c344eb4dddbc2cf46a604586435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c2331190ef052220a8895c44966de35/" rel="bookmark">
			输出数字金字塔(数字1-9)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt; //输出数字金字塔(数字1-9) int main() { int n,i,j,k; scanf("%d",&amp;n); for (i=1;i&lt;=n;i++) { for (j=1;j&lt;=n-i;j++) printf(" "); for (k=1;k&lt;=i;k++) { if (k==i) { printf("%d",i); }else{ printf("%d ",i); } } printf("\n"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f5c83d031956bc59394d7361afd058/" rel="bookmark">
			Cannot resolve symbol &#39;SpringApplication&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cannot resolve symbol ‘SpringApplication’ 解决方法：在Intellij idea下 file—&gt;Invalidate Caches/Restart 清除缓存重启即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f894ff82fe5227e79579e019a66422e/" rel="bookmark">
			条码扫描器接口编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前的条形码扫描器有点类似外接键盘（其实从消息传送上它就相当于一个键盘），把输入焦点定位到可输入的控件上，一扫描相应的条形码信息就输入到文本框中去了，但是如果没有输入焦点，或另一个不相干的程序获得输入焦点，那就有点乱套了。我想实现的是，不管什么情况，只要扫描器一工作，我的程序就能自动激活，并能获得当前输入的条形码信息。实现思路：我用的USB口的条形码扫描器，仔细分析了一下，扫描成功后，以键盘按键消息的形式把条形码输入信息通知给系统。这样通过键盘钩子就可以方便的获得该信息了。但是，怎样区分信息是键盘还是条形码输入的哪？很简单，条形码扫描器在很短的时间内输入了至少3个字符以上信息，并且以“回车”作为结束字符，在这种思想指引下，很完美的实现了预定功能。 窗体相关代码：
view plaincopy to clipboardprint? ·········10········20········30········40········50········60········70········80········90········100·······110·······120·······130·······140·······150 using System; usingSystem.Collections.Generic; usingSystem.ComponentModel; using System.Data; using System.Drawing; using System.Text; usingSystem.Windows.Forms; namespace ReadBadCode { publicpartial class frmTest :Form { BarCodeHook BarCode = newBarCodeHook(); public frmTest() { InitializeComponent(); BarCode.BarCodeEvent += newBarCodeHook.BarCodeDelegate(BarCode_BarCodeEvent); } private delegate void ShowInfoDelegate(BarCodeHook.BarCodesbarCode); private void ShowInfo(BarCodeHook.BarCodesbarCode) { if (this.InvokeRequired) { this.BeginInvoke(new ShowInfoDelegate(ShowInfo), new object[] {barCode }); } else { textBox1.Text =barCode.KeyName; textBox2.Text =barCode.VirtKey.ToString(); textBox3.Text =barCode.ScanCode.ToString(); textBox4.Text =barCode.AscII.ToString(); textBox5.Text =barCode.Chr.ToString(); textBox6.Text = barCode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f894ff82fe5227e79579e019a66422e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/767e76ae684bc5206c619149283dcdef/" rel="bookmark">
			最全面的RecyclerView源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多人用RecyclerView已经很久了，但还是不得不感叹 RecyclerView的强大，性能、扩展性等方面都很强大。网上看了很多源码方面对RecyclerView，觉得还不够全面，而且自己不走一遍源码总感觉会很容易忘记。
打开RecyclerView类，发现有11090行代码，千万不要震惊，慢慢看。
整体看了下RecyclerView的架构，你会惊奇于这个优雅的设计，高度解耦，灵活性很强，给开发者一种插拔式的体验，使用者只要通过设置不同的LayoutManager, ItemDecoration, ItemAnimator就可以实现各种各样的效果了。
##Recycler
打开RecyclerView的结构，复杂，我们就从上往下说好了。首先来分析Recycler这个内部类，Recycler是整个RecyclerView的精髓所在，那么Recycler到底是什么呢：
Recycler的职责是管理那些已经废弃了的或者从RecyclerView中分离的item view用于复用。
废弃的View是指那些仍然依附于RecyclerView但是已经被标记为可以被移除或者复用的View。
Recycler典型的用法就是当LayoutManager去获取Adapter中的某一项View的时候，如果这个View失效了，则需要重新绑定View，当复用的View是有效的话，View就会被直接被复用。有效的View如果不主动调用requestLayout，那么该View不需要重新测量就可以被复用。
说了一大堆，还是边看代码边解释更加清晰一点，首先来看Recycler几个成员变量：
final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;(); private ArrayList&lt;ViewHolder&gt; mChangedScrap = null; final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;(); private final List&lt;ViewHolder&gt; mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap); private int mViewCacheMax = DEFAULT_CACHE_SIZE; private RecycledViewPool mRecyclerPool; private ViewCacheExtension mViewCacheExtension; 先来看RecycledViewPool和ViewCacheExtension这两个类：
RecycledViewPool让开发者可以在多个RecyclerView之间共享View。
如果你想要垮RecyclerView复用View，创建一个RecycledViewPool实例，然后调用setRecycledViewPool(RecycledViewPool)方法就可以了。
RecyclerView会自动创建一个RecycledViewPool的实例。
有了RecycledViewPool的存在，就能很大程度上减少View的创建，提高性能。
先看下面这两个方法：
private SparseArray&lt;ArrayList&lt;ViewHolder&gt;&gt; mScrap = new SparseArray&lt;ArrayList&lt;ViewHolder&gt;&gt;(); private SparseIntArray mMaxScrap = new SparseIntArray(); //此处省略部分代码 //…… public void setMaxRecycledViews(int viewType, int max) { mMaxScrap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/767e76ae684bc5206c619149283dcdef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7291c63d8de6658c636e5dd7c8a4d04/" rel="bookmark">
			java.net.URLEncoder 与 java.net.URLDecoder.decode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.net.URLEncoder URLEncoder是用来对HTML表单编码，该类包含用于将字符串转换为application/x-www-form-urlencoded 格式的静态方法。 (application/x-www-form-urlencoded： 数据被编码为名/值对)
当发出get请求时，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1=value1&amp;name2=value2…），然后把这个字串以请求参数形式附加到url后面。当发出post请求时，浏览器把form数据封装到http body中，然后发送到server。
URLEncoder编码时遵循的规则
a-z,A-Z,0-9保持原样。特殊字符.,-,*与_保持原样。空格被转换为+号。其它字符转换为%xy的形式，xy由16进制数来表示。 import java.io.UnsupportedEncodingException; import java.net.URLEncoder; public class Main { public static void main(String[] args) throws InterruptedException, ExecutionException { try { String string = "The string ü@foo-bar"; String encodedString = URLEncoder.encode(string, "UTF-8"); System.out.println("Encoded String: " + encodedString); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } 上述代码[1]使用UTF-8编码。The string ü@foo-bar被转换为The+string+%C3%BC%40foo-bar因为UTF-8，ü被编码为两字节C3(16进制),BC(16进制),@被编码为一字节40(16进制)。
java.net.URLDecoder URLDecoder用来解码，解格式为application/x-www-form-urlencoded的编码。
public class Main { public static void main(String[] args) throws UnsupportedEncodingException { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7291c63d8de6658c636e5dd7c8a4d04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/393591e201dfbd2d08ad744fc4c74b3f/" rel="bookmark">
			The package needs to be reinstalled,but I can&#39;t find an archive for it
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转自：http://cache.baiducontent.com/c?m=9d78d513d99456ae28fa950d1a16a620430397634d9583442687c61f84642a1d1031b5fa302261428ed27c1651f85e5c9bb061296b4266e4c596df1ccabbe33f2ff93035004cc10705d368f4dc46549073cc4de9de5ff0ba8166c8f284c4df25009644050bd3b0da005b509d78f06565bee68e48640456adec4072ff2e636edf7d4fec01bfa2256f749ceb981909d42aa73a4bc4eb62e37c43a213d34e467b59a04eb20b4c2532fd1b7cb5533d72c1b701ba61221c76a148c5ff9be1fc48fa9eb960c1a99ef8389516ba92bdaf30557024bc78a9abcbe26a734574999d854a8574efa4b2ed1afe14a1401bfc4a765930d96be2d3dc0bb4755a82b333a27f35265e5983a4748926303e6bf37a4fa61fb621ecce614baab1db9f9f6312efd9983360fedbe41ea06d787db77b055cdbf720284ec54a6d9ca5e939902042e4d4&amp;p=8278da0c86cc42af58bbc7710f0dcc&amp;newp=913dc01286cc42af58b2882d0214bb231610db2151d4d2176b82c825d7331b001c3bbfb423231b0fd4ce7e6c00af4c56edf431793c0127a3dda5c91d9fb4c57479d73b&amp;user=baidu&amp;fm=sc&amp;query=E%3A+The+package++needs+to+be+reinstalled%2C+but+I+can%27t+find+an+archive+for+it.&amp;qid=e68780ef00025ae4&amp;p1=3
（因为当时打不开网站，只能用百度快照看了）
这是我在ubuntu电脑安装东西时出现的错误，记得当时安装很慢，取消安装也没什么反应，就关了software center,把安装包给删了，然后重下。结果是software center打开后直接闪退。
sudo gedit /var/lib/dpkg/status 用以上命令打开，然后查找到那个需要被重装的软件，然后把相关信息删除，记得当时上面显示软件的状态是安装了一半。删除后保存关掉，打开software center发现它能用了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a50bb51a25599861469b36b6d15e0f/" rel="bookmark">
			c程序多次调用python脚本的正确打开模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：c程序中需要多次调用python脚步； 初始做法：每次调用python脚本时，开始初始化python环境(Py_Initialize)，调用完之后结束python环境(Py_Finalize();)
问题：程序偶然会出现崩溃的现象；
c程序多次调用python脚本的正确打开模式如下：
1. 在主线程中这样处理
// 初始化 Py_Initialize(); if ( !Py_IsInitialized() ) return // 初始化线程支持	PyEval_InitThreads(); // 启动子线程前执行，为了释放PyEval_InitThreads获得的全局锁，否则子线程可能无法获取到全局锁。 PyEval_ReleaseThread(PyThreadState_Get()); // 其他的处理，如启动子线程等 ...... // 保证子线程调用都结束后 PyGILState_Ensure(); Py_Finalize(); // 之后不能再调用任何python的API2. 在主线程，或者子线程中，调用python本身函数采用如下处理 PyGILState_STATE state; state = PyGILState_Ensure(); ... // 调用python的API函数处理 ... PyGILState_Release(state);注： 两个和全局锁有关的宏，Py_BEGIN_ALLOW_THREADS 和 Py_END_ALLOW_THREADS。这两个宏是为了在较长时间的C函数调用前，临时释放全局锁，完成后重新获取全局锁，以避免阻塞其他python的线程继续运行。这两个宏的用法如下： PyGILState_STATE state; state = PyGILState_Ensure(); // 调用python的API函数处理 ...... Py_BEGIN_ALLOW_THREADS // 调用需要长时间的C函数 ...... Py_END_ALLOW_THREADS // 调用python的API函数处理 ...... PyGILState_Release(state);参考资料： http://blog.csdn.net/liguangyi/article/details/1659697
http://blog.csdn.net/cedricporter/article/details/6810665
http://www.cppblog.com/API/archive/2013/12/06/204618.aspx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85170d336af1d32c6a13a1c5f8e0ace7/" rel="bookmark">
			python中numpy使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np#导入numpy data=[[1,2,3],[4,5,6]]#创建元组 arr=np.array(data)#转化为数组 arr.ndim#数组空间维数 arr.shape#数据行列数 arr.dtype#数据类型""int32"" np.zeros(10)#指定长度 np.zeros((3,6))#创建3行6列的0数组 np.ones(5)#array([ 1., 1., 1., 1., 1.]) np.ones((3,4))#3行4列的全1矩阵 ar1=np.arange(10)#结果:array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) np.eye(3)#3维单位矩阵 np.identity(3)#3维单位矩阵 np.ones_like(arr)#创建与arr相同行、列的全1矩阵 np.zeros_like(arr)#创建与arr相同行、列的全0矩阵 arr_f=arr.astype(np.float64)#将arr中的数据类型转换为float64格式 Nstring=np.array(['1.2','3','4'],dtype=np.string_)#创建数组师可以自行定义字符串 N_float=Nstring.astype(np.float)#将string数据转换为float格式，等价于float64 ######数组的标量运算 arr*arr#每个元素平方 arr*5#每个元素乘以5 '''索引和切片''' ar1_s=ar1[5:8] ar1[5:8]=12 ##ar1变化后，ar1_s的值也随之变化 ar1_s[:]=100#ar1_s变化后，ar1也随之变化 ar1_s1=ar1[5:8].copy()#完全拷贝，值变化不影响ar1 aro=np.array([[1,2,3],[4,5,6],[7,8,9]])#3维数组 aro[2]#第三组（行）数组 aro[0][2]#数组第0行第二列“3”或aro[0,2] arr3d=np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])#3维数组 '''布尔型索引''' names=np.array(['bob','joe','will','bob','will','joe','joe']) data=np.random.randn(7,4) names=='bob' data[names='bob']#选取True的行,布尔型数组的长度必须跟被索引的轴长度一致。 data[names=='bob',2:]#选取从第二列开始的数据 data[names=='bob',3]#选取第三列的数据 data[names=='bob'][1,:]#选取第一行（从0行开始算） names!='bob'#名字不是‘bob’的逻辑数据 -(names=='bob')#意思与names!='bob一致 mask=(names=='bob')|(names=='will')#逻辑或，&amp;( 和),python中不能用and和or data[data&lt;0]=0#将data中所有小于0的数据设置为0 data[names!='joe']=7#将不是joe的行赋值为7 '''花式索引''' arr0=np.empty((8,4))#创建新数组，只分配内存空间，不填充任何值 for i in range(8): arr0[i]=i#数组的i值就是指i行 arr0[[2,3]]#选取数字的子集，第2行，第3行 arr0[[-7,-5]]#全负数将会从末尾开始选取子集 arr0[[-1,2]]#有正数，负数选取子集 arr1=np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85170d336af1d32c6a13a1c5f8e0ace7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42f81168031a1a71d64d995aabc387a2/" rel="bookmark">
			mac使用ngrok将本地Web服务映射到外网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.为什么使用 web开发中，难免会遇到在某些情况下，我们必须借助外网才能调用某个API，然而，如果我们按照下面的方式来做，显得就很繁琐：
a.在一个具有外网可访问的服务器上搭建一个web环境 b.上传代码，调试接口 c.发现问题，本地修改 d.再次上传，周而复始，直至bug修复，然后发布到正式测试环境 这里所说的也就是可能为了一个小功能而做的事情，比如我们最常用的公众号开发.。
2.下载使用 2.1 下载 下载地址 下载之后解压，然后打开ngrok解压目录(有的人说需要注册ngrok得到your auth token，后面的自定义域名必须要有这个token，因为我暂时不需要自定义域名，所以就省略了这一步)， 帮助命令： ./ngrok help
COMMANDS: authtoken save authtoken to configuration file credits prints author and licensing information http start an HTTP tunnel start start tunnels by name from the configuration file tcp start a TCP tunnel tls start a TLS tunnel update update ngrok to the latest version version print the version string help Shows a list of commands or help for one command 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42f81168031a1a71d64d995aabc387a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1393b9f5253cb92a2da5e569dbc6b621/" rel="bookmark">
			maven系列(3) 快速搭建项目骨架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven项目的项目骨架是指 maven项目的基本目录结构和POM.xml 文件内容。上一篇为了更好的了解maven的，手动的搭建了 helloworld的项目骨架。刚开始这样可以起到加深对maven的认识，但是等我们已经熟悉maven构建原理了，还这么搭建maven项目骨架就有点傻了。怎么快速搭建项目骨架，请往下看。
新建一个文件夹 E:\testformaven cmd切换到这个目录下执行 mvn archetype:generate
会有很多参考骨架供选择，根据需求选一个
根据提示输入信息
直接回车
再到刚才的文件夹下就能看到hello-world的项目骨架了
项目骨架是可以用了，但是选择1貌似目录结构不是很好，还有几个不知道怎么样，不过要想搞个符合自己喜好的骨架还是得根据项目类型自定义，这个以后再研究吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb7baf9b66bd0cb0d5c59f044ce6597/" rel="bookmark">
			maven系列(2) 测试项目HelloWorld
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇文章介绍了Maven的安装及简单的配置。本篇博客主要是对Maven配置做的补充，及通过 helloworld 程序带你体验maven构建生命周期。话不多说，进入正题。
一、配置中央仓库：maven默认中央仓库是外服，做练习时下载插件或者依赖真的不是一般的慢，为此先来改变下我们的中央厂库。
1.从maven home 的conf目录下拷贝 settings.xml 文件到 C:\Users\Administrator\.m2目录下。
2.修改 settings.xml 内容，找到&lt;mirrors&gt;节点，添加&lt;mirror&gt;子节点，内容如下
&lt;mirror&gt; &lt;id&gt;central &lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 二、实现helloworld，并用mvn 构建
maven项目是基于约定的，不同的文件都要遵循一定的规约
项目代码在 src\main\java 目录下；测试代码在src\test\java 目录下；项目资源文件在src\main\resources目录下；测试资源文件在src\test\resources；pom文件放在项目根目录等等。
1.在 src\main\java目录下新建 john\mvndemo 目录 然后新建HelloWorld.java文件，内容为
package john.mvndemo.helloworld; public class HelloWorld{ public static String sayHello(){ return "Hello World!"; } public static void main(String[] args){ System.out.println(sayHello()); } } 文件路劲：
2..在 src\test\java目录下新建 john\mvndemo 目录 然后新建HelloWorldTest.java文件用于单元测试，内容为
package john.mvndemo.helloworld; import static org.junit.Assert.assertEquals; import org.junit.Test; public class HelloWorldTest{ @Test public void testSayHello(){ HelloWorld helloWorld = new HelloWorld(); String result = helloWorld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eb7baf9b66bd0cb0d5c59f044ce6597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86db4ef054ad7322ea1b1a7c125d4933/" rel="bookmark">
			docker容器iptables&amp;nbsp;failed:&amp;amp;…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天tomcat的docker容器挂了，只要是带命令-p 映射端口就起不来并且报错： Error response from daemon: Cannot start container eb9d501f56bc142d9bf75ddfc7ad88383b7388ca6a5959309af2165f1fff6292: iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 8081 -j DNAT --to-destination 172.17.0.164:8080 ! -i docker0: iptables: No chain/target/match by that name. (exit status 1) 网上查找发现，可能是网络问题造成 首先先验证docker容器内部网络是否能ping通宿主机 如果能ping通，即可通过重建docker0网络恢复 先停掉宿主机上运行的docker容器，然后执行以下命令 在宿主机执行： pkill docker iptables -t nat -F ifconfig docker0 down brctl delbr docker0 docker -d systmctl restart docker 重启docker服务 问题即可解决。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931a8b3bb08a0c7915431768aecc6e36/" rel="bookmark">
			【转】ELF 加密文件解码初探（思路很好）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hackme: Deconstructing an ELF File 转自：http://www.manoharvanga.com/hackme/
文章思路很好，更多请看原文。
A friend recently asked me to find the password for a little hard-to-hack program he had written and I agreed to it. The short journey of a few hours that led me to its password were extremely interesting and this article describes the process as well as some of the new techniques learnt along the way.
Few minutes after accepting his challenge, I received a binary called "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/931a8b3bb08a0c7915431768aecc6e36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c5c321cf24e1293ad9d5a139cb265c/" rel="bookmark">
			有意思的博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以后就用它来记录工作的点点滴滴 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbf5816f4b978b19432565794ee9b6d2/" rel="bookmark">
			adb input 命令输入文本功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近帮同事做一个播放器的播放验证功能。就是输入播放地址，点击播放看是否能正常播放、seek等。他给我一个apk，打开后界面是这样的:
一个文本框（需要收到输入播放地址），一个播放按钮。
看着是没有啥问题，不过我是运行到电视或者机顶盒上。头疼了，文本框？我每次要用遥控器输入播放地址，并且地址还很长，输错了还要重新输入，挺麻烦的呀。旁边的大师看到了，过来说：你可以用input命令，输入文本。这样，就不用遥控器输入了。
于是，我从网上找来input的用法，测试后果真很方便。再长的播放地址也不怕啦。所以，小小的功能有时候确实发挥很大的作用。下面我就讲下怎么使用该命令吧。以下，都是参考：http://blog.csdn.net/soslinken/article/details/49587497得来的。
1.功能
input命令是用来向设备发送模拟操作的命令的，包括输入文本、发送按键。
2.使用
input text &lt;string&gt; //输入文本 input keyevent &lt;key code number or name&gt; //发送按键
input tap &lt;x&gt; &lt;y&gt;
input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt;
将目标对象获取焦点，比如将遥控器移动到文本框中。此时在pc电脑打开adb，连接设备。输入命令：
adb shell input text "hello,world"
此时，目标对象就会展示你输入的文本。如果多次输入，文本展示是叠加效果：
hello,worldhello,worldhello,worldhello,world
如果，想删除目标文本的内容，没有快捷的方法。要么遥控器删除，如果遥控器没有删除按键，也调不了系统的输入法，可以模拟发送按键方式：
adb shell input keyevent 67 每次只能删除一个字符。所以，要执行多次才能将文本框的字符删除完。
另外， input tap 和 input swipe 还没有使用过，其是对屏幕位置发送命令。先不做研究了，网上也很多说明，要用的时候在研究下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d8bf7b831a85b6c9144839b496555c/" rel="bookmark">
			为/tmp添加nodev/nosuid/noexec挂载选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了增加Linux系统安全性，建议将/tmp目录单独的挂载于一个独立的系统分区之上。但是仅仅挂载还不够，需要在挂载时为该分区指定nodev/nosuid/noexec选项，才能提高tmp文件目录的安全性。
背景 临时存储目录，如 /tmp，/var/tmp和/dev/shm等，往往是恶意程序袭击的目标。***们在执行***的时候，往往将可执行程序放置于该目录之下。恶意用户一般也利用这些临时存储目录执行自己的恶意程序，从而发起对线上系统的破解和***。
由于/tmp目录时系统运行必备的目录，那么怎么增强该目录的安全性，尽可能减少系统潜在危险呢？
我们可以通过以下的方法进行设置
配置过程 1.挂载时为/tmp分区添加nodev/nosuid/noexec选项
编辑/etc/fstab文件
Shell
vi /etc/fstab
1
vi /etc/fstab
找到/tmp挂载目录的相关配置
例如chris hill当前系统的配置如下
UUID=9abc328b9-3d22-4224-acd6-c48d7b4d3aa4 /tmp ext4 defaults 1 2
将nodev,nosuid,noexec选项增加到第四列defaults参数的后面
UUID=9abc328b9-3d22-4224-acd6-c48d7b4d3aa4 /tmp ext4 defaults,nodev,nosuid,noexec 1 2
2.挂载时为/dev/shm文件系统添加nodev/nosuid/noexec选项
与第1步的/tmp类似，编辑/etc/fstab
tmpfs /dev/shm tmpfs defaults,nodev,nosuid,noexec 0 0
3.有关/var/tmp设置
有些系统需要使用到/var/tmp目录。
建议设置/var/tmp和/tmp目录同步。
编辑/etc/fatab文件
/tmp /var/tmp none rw,noexec,nosuid,nodev,bind 0 0
4.无需重启系统，使配置生效
设置 /var/tmp 映射到 /tmp 目
mount -o rw,noexec,nosuid,nodev,bind /tmp/ /var/tmp/
1
mount -o rw,noexec,nosuid,nodev,bind /tmp/ /var/tmp/
重新挂载/tmp目录
mount -o remount,noexec,nosuid,nodev /tmp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7d8bf7b831a85b6c9144839b496555c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176b7690ada2b4246dfe886608a4a002/" rel="bookmark">
			windows764位旗舰版iso镜像文件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://pan.baidu.com/s/1bPv1IA 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cf923f3eaa7e98ad96aa694744a0143/" rel="bookmark">
			关于错误 openssl/ssl.h：没有那个文件或目录的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先得安装openssl：sudo apt-get install openssl 当 #include&lt;openssl/ssl.h&gt;后编译报错：openssl/ssl.h：没有那个文件或目录的解决办法 解决办法为： sudo apt-get install libssl-dev build-essential zlibczlib-bin libidn11-dev libidn11 安装上边的依赖就好了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1073f922c2da327c6f561da715960e/" rel="bookmark">
			微信公众号二次开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php /*echo $_GET['echostr']; exit;*/ //接收xml数据 $postStr = $GLOBALS['HTTP_RAW_POST_DATA']; //把xml数据转化成对象 $postObj = simplexml_load_string($postStr); $fromuserName = $postObj-&gt;FromUserName; $touserName = $postObj-&gt;ToUserName; $time = time(); $msgType = $postObj-&gt;MsgType; $keywords = $postObj-&gt;Content; $textTpl = "&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; &lt;/xml&gt;"; $musicTpl = "&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;Music&gt; &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt; &lt;MusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/MusicUrl&gt; &lt;HQMusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/HQMusicUrl&gt; &lt;/Music&gt; &lt;/xml&gt;"; $newsTpl = "&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;ArticleCount&gt;1&lt;/ArticleCount&gt; &lt;Articles&gt; &lt;item&gt; &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt; &lt;PicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/PicUrl&gt; &lt;Url&gt;&lt;![CDATA[%s]]&gt;&lt;/Url&gt; &lt;/item&gt; &lt;/Articles&gt; &lt;/xml&gt;"; //关注事件回复 if($postObj-&gt;MsgType == 'event'){ if($postObj-&gt;Event == 'subscribe'){ $msgType = 'news'; $title = '三月三!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a1073f922c2da327c6f561da715960e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4a5a747461bb06ba5380a0b886c9df/" rel="bookmark">
			OBS桌面视频直播软件/推流工具使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OBS 操作指南 什么是OBS？ Open Broadcaster Software 是一款好用的互联网流媒体直播内容输入作软件。
OBS使用是否收费？ 不收费，这个程序和它的源代码都是免费的。
OBS都支持哪些操作系统？ 支持 OS X，Windows，Linux操作系统。适用于多种直播场景。满足大部分直播行为的操作需求。
OBS推流工具下载 请到OBS官网下载最新软件 OBS官方下载
OBS通用设置 1. 设置。
如有直播录制需求，因直播时网络环境较复杂，建议进行直播时本地进行录制备份。
2. 串流设置
实际 Mac版OBS的流密钥与Windows版播放路径/串码流（如果存在）中的内容不会显示明文即：
以上面的推流地址为例，参数设置为：
EasyDSS URL / URL： rtmp://www.easydss.com/hls
播放路径/串码流（如果存在）/ 流秘钥，这个ID是由自己生成的唯一流标识，由自己维护: {建议用每次直播都生成一个全局唯一的ID}
如您开启了鉴权，则鉴权参数也一并放在 Mac版OBS的流密钥与Windows版播放路径/串码流（如果存在）中。
3. 分辨率设置
输出分辨率就是你想让观众看到的画面分辨率，分辨率决定着画面的清晰成都，越高画面越清晰。
FPS是视频帧率，它控制视频观看视频流畅，普通视频帧率有24-30帧，低于16帧画面看起来有卡顿感。而游戏对帧率要求比较高，一般小于30帧游戏会显得不连贯。
常见视频分辨率与比例对照表
比例分辨率比例分辨率比例分辨率4:032048x1536 1600x1200 1400x1050 1152×864 1024x768 800x600 640x48016:9
1920x1080 1600×900 280x72016:10
2560x1600 1920x1200 1680x1050 1440x900 1280x800 1366x768 960x600 800x480 4. 输出设置
5. 减少直播延迟设置
OBS常见操作设置介绍 直播来源设置介绍 OBS工具支持简单的内容快速编辑，剪辑，场景、来源素材快速切换的操作，可以对直播活动进行快速简单的内容编辑。
1. 图像：适用于单张图像直播
2. 图像幻灯片放映：可循环或者顺序多张播放图片，适用于会议 ，教育类课件直播.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d4a5a747461bb06ba5380a0b886c9df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be51060a043a318d8818bde5610a890b/" rel="bookmark">
			如何将小视频制作成动态图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		制作动态图片：
1.首先我们要先准备一个视频，并记住视频的总时长。
2.打开 http://ezgif.com/ 如图所示：
3.点击 Video to GIF，进入如下页面：
4.点击浏览，并选择视频的路径，然后点击Upload
5.对图片进行编辑，编辑完点击 Convert to GIF!保存图片 。如图所示：
6.最后在本页面的最上方的save对图片进行下载。
这样我们的动态图就做完了。
^～^
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5714ac2eff8e34813aac2d7497118df2/" rel="bookmark">
			java杂文系列(1) poi导出excel文件（包含图片）大的奇葩事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近负责的项目出现了个奇葩的问题，两个方法几乎同样的逻辑，模板也差不多，导出内容也差不多，但是导出的文件却相差10几兆，用户不能忍，我也不能忍，但是反复对比代码，反复推敲逻辑，硬是找不到个所以然。在百般摸索下最后发现了解决方案，但是根源还不是很清楚，知道的人还望不吝赐教。下面对解决的过程记录下，已备后续警示自己。
刚开始我是把文件中的图片复制到QQ里，然后再复制到桌面，然后看图片大小，发现图片都差不多，于是乎就排除里图片的可能。但是在同事的帮助下，我意识到这个思路有严重的问题，通过上述操作，我活生生的把12兆多的图片变成了60多K。于是乎顿然发现原来问题在图片上，于是采取正确的方式，先在导出的excel里把图片还原，然后将图片另存到另一个空的excel里，看图片的大小。（还原后再复制到QQ--》桌面 然后看大小也靠谱点）
确定是图片的问题了，分别调试两个方法发现下载图片的路径是一样的。下面是导出较大的excel的图片生成代码。其实通过调试图片后缀就是 .png 但是换种写法差距就是10几兆啊。
ImageIO.write(image, "png" , byteArray); 这句是关键只要把"png"改成suffix 就可以将导出文件从17兆降到1.4兆。问题是解决了，但是疑问还在，逻辑上想不通Why? protected void toImage(Cell cell, String uri, ClientAnchor anchor) { if (uri == null) { return; } //新代码 String suffix = FileUtils.getFileSuffix(uri).substring(1); int ptype = 0; if("png".equalsIgnoreCase(suffix)){ ptype = Workbook.PICTURE_TYPE_PNG; }else if("jpg".equalsIgnoreCase(suffix) || "jpeg".equalsIgnoreCase(suffix)){ ptype = Workbook.PICTURE_TYPE_JPEG; }else if("emf".equalsIgnoreCase(suffix)){ ptype = Workbook.PICTURE_TYPE_EMF; }else{ ptype = -1; } //新代码结束 Drawing drawing = sheet.createDrawingPatriarch(); try { ByteArrayOutputStream byteArray = new ByteArrayOutputStream(); BufferedImage image = ImageIO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5714ac2eff8e34813aac2d7497118df2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b6692d9bdc070d42df0f4b564f5a69/" rel="bookmark">
			Spring&#43;SpringMVC&#43;MyBatis&#43;easyUI整合优化篇（一）Java语言中System.out.print与Log的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：13
GitHub：https://github.com/ZHENFENG13
版权声明：本文为原创文章，未经允许不得转载。
前言 距离上一次更新博客有一段时间了，主要是因为最近有开发任务，另外，这段时间也在学习docker的相关知识，所以博客就没有继续写了，推荐一本书《Docker技术入门与实战》(第二版)，想体验一下docker的朋友可以看一下。
按照计划，第二阶段主要是讲一下项目优化上的一些东西，相关的工具已经在基础篇介绍了一些，所以在本阶段更多的是侧重于代码上，虽然做了一份粗略的计划，但是第一篇该写什么又犯了纠结，刚好有一次编写代码时看到一个方法中含有System.out.print()打印语句，这个方法大家都不陌生，第一份代码应该都是"世界，你好"，所以本篇就讲一下System.out.print与Log吧。
原因简述 提到代码优化呢，其实需要注意的有很多个地方，因为一个系统涉及到很多技术，针对每个技术也需要对应的优化方案，因此，这是一件时间跨度长且复杂的工程，所以优化篇的开始呢，就先从最开始的地方讲起，打印语句，可能我们每个人都会在日常编码过程中都存在的一个问题，就是对于程序中的一些输出信息，喜欢使用System.out.print打印到控制台上，而不采用日志记录的方式输出到对应的日志文件。
为什么要讲这个事情呢？因为这个问题其实我也想了挺久的，就是System.out.print和log的区别在哪，区别到底有多大，刚好看到代码里有一些System.out.print代码，所以今天就写了这篇文章。
System.out.print与Log比较 System.out.print的优点：直观、方便。
Log的优点：异步、解耦、灵活、策略多。
提到System.out.print，除了感觉到方便之外，还会想到其他的优点吗？似乎也就这个优点，syso快捷键瞬间就是一条打印语句，很顺手的一件事，除了这个感觉外，似乎也没有其他特别的感受了。
System.out.print和java运行程序运行在同一线程，也就是说，业务程序会等待System.out的动作，导致资源被占用，log4j、logback等日志工具进行调试信息的打印，这类工具是异步线程的，不会使程序处于等待状态。
System.out.print是在控制台输出，只能输出到控制台，功能上线后，总不能一直盯着控制台吧，而且日志文件需要保留，以供日后分析，是需要一套管理规范的，即便使用tomcat服务器，System.out会输出到catalina.out文件，catalina.out文件也不会一直存在，需要定期清空，如果不清空，大文件的读写也是挺影响性能的。说到这里，System.out.print写入的文件只有一个，对于一个文件的读写，这个io肯定会排队写，且System.out.print在当前线程，肯定对性能会有稍微的影响。
程序中充斥着大量的System.out.print打印代码是相当不规范的。
补充说明 当然，说到影响服务器性能，必须是代码中存在大量的System.out.print才会明显的影响，而这个量需要有多大呢？考虑到系统体量、服务器版本、服务器配置这些因素，很难给一个固定的值，而且肯定也有很多人认为小量的不规范代码不会使人察觉的，我也支持这个观点，不过我们也要记得一句话，千里之堤溃于蚁穴，不能因为一件事是小事就选择性忽略掉，对自己要求高一点，写的代码也一定要整洁且正确。
项目由小项目慢慢成长为大项目，对于系统的日志要求肯定也越来越苛刻，后期肯定也要搭建日志系统的，日志信息的采集和分析也肯定是用对应的Log框架及相关的技术去做，比如ELK技术栈，这个时候，再问自己一个问题，在控制台上打印是怎样的一种感受呢？
针对于日志的灵活性，根据一些日志框架的特点，也可以定制自己的日志规范，日志输出策略、日志存储策略、日志维护策略，想怎么输出怎么输出，想怎么存储怎么存储，非常的灵活。不同团队根据自己团队的特点制定出自己的日志策略，而不是一味的System.out.print打印到控制台上，与此相比，程序中充斥大量的System.out.print语句明显黯然失色。
以上为个人观点。
总结 今天讲这个事情，主要的原因，是因为有一次在查找System.out.print和log的区别时，发现网上并没有介绍这个问题的文章，所以就自己整理了一下。另外一个方面，是觉得代码规范这个事情还是很重要的，希望大家日常编码工作中注意，并没有其他的意思，因为其实写顺手了，System.out.print确实不好改掉。
这里引用代码整洁之道中的一句话：
“进度可以重订，需求可以修改，团队动态可以修正，但糟糕的代码只是一直腐败发酵，无情的拖着团队的后腿。”
这里所讲的糟糕的代码，不只是不规范的输出语句，也包括了很多其他方面不规范和不整洁的代码，改掉不良习惯，养成良好的编程习惯，共勉。
转载于:https://www.cnblogs.com/han-1034683568/p/6637914.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8956f21caa74741e665929ec4a33096d/" rel="bookmark">
			Java 阻塞线程用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CountDownLatch
首先先说明CountDownLatch辅助类
CountDownLatch，一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 主要方法 public CountDownLatch(int count);//构造方法参数指定了计数的次数 public void countDown();//当前线程调用此方法，则计数减一1 public void await() throws InterruptedException//调用此方法会一直阻塞当前线程，直到计时器的值为0 列子：
public class CountDownLatchDemo { final static SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); public static void main(String[] args) throws InterruptedException { CountDownLatch latch=new CountDownLatch(2);//两个工人的协作 Worker worker1=new Worker("zhang san", 5000, latch); Worker worker2=new Worker("li si", 8000, latch); worker1.start();// worker2.start();// latch.await();//等待所有工人完成工作 System.out.println("all work done at "+sdf.format(new Date())); } static class Worker extends Thread{ String workerName; int workTime; CountDownLatch latch; public Worker(String workerName ,int workTime ,CountDownLatch latch){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8956f21caa74741e665929ec4a33096d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c38df4cf2c1488007062ccf5245eee/" rel="bookmark">
			android HierarchyViewer查看视图层级关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看到一篇文章，讲的是UI过度绘制，里面有提到很多方法，比较不错。想想确实有时候我们在做开发时候，发现UI性能怎么那边差，也没有做什么复杂的操作。那为什么会性能很差呢。也找不到好的办法来分析。但是Android提供了一个工具：HierarchyViewer可视化调试工具，它帮助我们分析View的计算和绘制时间。
1. 打开Idea开发工具：Tools--&gt;Android--&gt;Android device Monitor
2.打开adb，连接上模拟器。
天天模拟器连接地址：adb connect 127.0.0.1:6555
3.模拟器启动应用程序，进入到应用页面。
4.切换到电脑Android device Monitor，点击菜单window--&gt;openperspective，选中hierarchy View；就会出来Tree view,该视图可以展示选中avtivity的所有控件层级。 5.再点击左侧要调试的activity等，此时Tree view就会展示出所有的控件。如下: 看 到层级关系，可能会想到：出现性能慢是否和层级太多，布局耗费太多时间？对，所以第一步要检查下布局问题。
那怎么知道每个控件耗费时间？
选中视图树里面的控件，点击，就会展示每个控件的详细信息。
但是这样看比较麻烦，每个控件都要点击看一下。有一个快捷的方式可以把所有控件使用时间一下展示出，步骤就是点击右上角的下图中红框的按钮
点击或，Tree view里面的所有布局会展示3个点如上图有显示，依次表示：
计算时间、布局时间、绘制时间。红色就是要关注的了。一张图很好的说明了参数含义：
有3个颜色：绿色，黄色，红色，红色代表着耗时最长，也就意味着我们需要优化，我们可以不断点击，查看 测量布局以及绘制所需要的时间，从而优化。
如果发现出现红色，就需要对该控件进行优化了。
参考：http://www.open-open.com/lib/view/open1421656495031.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/220f5e99e90b5c9b0e8faf1684450fbe/" rel="bookmark">
			@RequestParam，@PathParam，@PathVariable等注解区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充
@RequestParam 看下面一段代码：
http://localhost:8080/springmvc/hello/101?param1=10&amp;param2=20
根据上面的这个URL，你可以用这样的方式来进行获取
public String getDetails( @RequestParam(value="param1", required=true) String param1, @RequestParam(value="param2", required=false) String param2){ ... } @RequestParam 支持下面四种参数
defaultValue 如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值name 绑定本次参数的名称，要跟URL上面的一样required 这个参数是不是必须的value 跟name一样的作用，是name属性的一个别名 @PathVariable 这个注解能够识别URL里面的一个模板，我们看下面的一个URL
http://localhost:8080/springmvc/hello/101?param1=10&amp;param2=20 上面的一个url你可以这样写：
@RequestMapping("/hello/{id}") public String getDetails(@PathVariable(value="id") String id, @RequestParam(value="param1", required=true) String param1, @RequestParam(value="param2", required=false) String param2){ ....... } 区别很明显了
@PathParam 这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包
@QueryParam @QueryParam 是 JAX-RS 本来就提供的，和Spring的RequestParam作用一致
@ResponseBody responseBody表示服务器返回的时候以一种什么样的方式进行返回， 将内容或对象作为 HTTP 响应正文返回，值有很多，一般设定为json
@RequestBody 一般是post请求的时候才会使用这个请求，把参数丢在requestbody里面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee2a7f069748cc4ebc1ea76d7c93da2/" rel="bookmark">
			lambda实体属性去重，对实体的某个属性进行去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面我将介绍一下如何为一个List&lt;People&gt; 这样的List里面的某个属性进行去重。顺便介绍一下两个实体之间如何用lambda进行复制 OK，我们先来写一个Person实体
package com.dzy.test.lambda; /** * Created by itar */ public class Person { private int age; private String name; private String country; private String address; private String phone; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCountry() { return country; } public void setCountry(String country) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee2a7f069748cc4ebc1ea76d7c93da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffefc4addc79afd7af0593c26d521de7/" rel="bookmark">
			北方大学 ACM 多校训练赛 第四场 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. 恶魔包毁灭世界 已知一张二分图，问哪些边是二分图的可行边？ 先跑最小流，再把残余网络建图，几个重要结论是： ·最小割的可行边（满流&amp;&amp;2点不在一个SCC中） ·最小割的必行边（可行边&amp;&amp;2点分别与源点和汇点在同一SCC中） ·二分图的可行边（两点在一个SCC中）
#include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;functional&gt; #include &lt;cstdlib&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; #define For(i,n) for(int i=1;i&lt;=n;i++) #define Fork(i,k,n) for(int i=k;i&lt;=n;i++) #define Rep(i,n) for(int i=0;i&lt;n;i++) #define ForD(i,n) for(int i=n;i;i--) #define ForkD(i,k,n) for(int i=n;i&gt;=k;i--) #define RepD(i,n) for(int i=n;i&gt;=0;i--) #define Forp(x) for(int p=Pre[x];p;p=Next[p]) #define Forpiter(x) for(int &amp;p=iter[x];p;p=Next[p]) #define Lson (o&lt;&lt;1) #define Rson ((o&lt;&lt;1)+1) #define MEM(a) memset(a,0,sizeof(a)); #define MEMI(a) memset(a,127,sizeof(a)); #define MEMi(a) memset(a,128,sizeof(a)); #define INF (2139062143) #define F (100000007) #define pb push_back #define mp make_pair #define fi first #define se second #define vi vector&lt;int&gt; #define pi pair&lt;int,int&gt; #define SI(a) ((a).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffefc4addc79afd7af0593c26d521de7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a544016bf96fdc828891b5754ba12c/" rel="bookmark">
			Zookeeper（十一）服务端处理，客户端回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务端处理Watcher 上面主要讲解了客户端注册Watcher的过程，并且已经了解了最终客户端并不会将Watcher对象真正传递到服务端。那么服务端究竟是如何完成客户端的Watcher注册，又是如何来处理这个Watcher的呢？后面我们围绕这两个问题讲解。
ServerCnxn存储 我们首先看下服务端接收Watcher并将其存储起来的过程，如图7-9所示是ZooKeeper服务端处理Watcher的序列图。 图7-9 服务端处理Watcher的时序图 从图7-9我们可以看出，服务端收到来自客户端的请求后，在FinalRequestProcessor.processRequest()中会判断当前请求是否需要注册Watcher： case OpCode.getData:{ ... byte b[] = zks.getZKDatabase().getData(getDataRequest.getPath(), stat, getDataRequest.getWatch()?cnxn:null); rsp = new GetDataResponse(b,stat); break; }从getData请求的处理逻辑中，我们可以看到，当getDataRequest.getWatch()为true的时候，ZooKeeper就认为当前客户端请求需要进行Watcher注册，于是就会将当前的ServerCnxn对象和数据节点路径传入getData方法中去。那么为什么要传入ServerCnxn呢？ServerCnxn是一个ZooKeeper客户端和服务器之间的连接接口，代表了一个客户端和服务器的连接。ServerCnxn接口的默认实现是NIOServerCnxn，同时从3.4.0版本开始，引入了基于Netty的实现：NettyServerCnxn。无论采用哪种实现方式，都实现了Watcher的process接口，因此我们可以把ServerCnxn看作是一个Watcher对象。数据节点的节点路径和ServerCnxn最终会被存储在WatcherManager的watchTable和watch2Paths中。 WatchManager是ZooKeeper服务端Watcher的管理者，其内部管理的watchTable和watch2Pashs两个存储结构，分别从两个维度对Watcher进行存储。watchTable是从数据节点路径的粒度来托管Watcherwatch2Paths是从Watcher的粒度来控制事件触发需要触发的数据节点。 同时，WatchManager还负责Watcher事件的触发，并移除那些已经被触发的Watcher。注意，WatchManager只是一个统称，在服务端，DataTree中会托管两个WatchManager，分别是dataWatches和childWatches，分别对应数据变更Watcher和子节点变更Watcher。在本例中，因为是getData接口，因此会被存储在dataWatches中。 Watcher触发 在上面的讲解中，我们了解了对于标记了Watcher注册的请求，ZooKeeper会将其对应的ServerCnxn存储到WatchManager中，下面我们来看看服务端是如何触发Watcher的。 NodeDataChanged事件的触发条件是“Watcher监听的对应数据节点的数据内容发生变更”，其具体实现如下： public Stat setData（String path， byte data[] ,int version,long zxid,long time）throws KeeperException.NoNodeException{ Stat s = new Stat(); DataNode n = nodes.get(path); if(n == null){ throw new KeeperException.NoNodeException(); } byte lastdata[] = null; synchronized(n){ lastdata = n.data; n.data = data; n.stat.setMtime(time); n.stat.setMzxid(zxid); n.stat.setVersion(version); n.copyStat(s); } //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41a544016bf96fdc828891b5754ba12c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc0487e0fceefe5ea7c28b25b5fb515/" rel="bookmark">
			二叉树的前序、中序、后序遍历及互相求法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要内容转自http://blog.csdn.net/fansongy，例子转自https://www.zybang.com/question/eacbb6b83a26339e9af3287a7266a76e.html，所有权力归原作者所有。
一、基本概念
每个结点最多有两棵子树，左子树和右子树，次序不可以颠倒。
性质：
1、非空二叉树的第n层上至多有2^(n-1)个元素。
2、深度为h的二叉树至多有2^h-1个结点。
满二叉树：所有终端都在同一层次，且非终端结点的度数为2。
在满二叉树中若其深度为h，则其所包含的结点数必为2^h-1。
完全二叉树：除了最大的层次即成为一颗满二叉树且层次最大那层所有的结点均向左靠齐，即集中在左面的位置上，不能有空位置。
对于完全二叉树，设一个结点为i则其父节点为i/2，2i为左子节点，2i+1为右子节点。
二、存储结构
顺序存储：
将数据结构存在一块固定的数组中。
[cpp] view plain copy print ? #define LENGTH 100 typedef char datatype; typedef struct node{ datatype data; int lchild,rchild; int parent; }Node; Node tree[LENGTH]; int length; int root; 虽然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。
链式存储：
[cpp] view plain copy print ? typedef char datatype; typedef struct BinNode{ datatype data; struct BinNode* lchild; struct BinNode* rchild; }BinNode; typedef BinNode* bintree; //bintree本身是个指向结点的指针 三、二叉树的遍历
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc0487e0fceefe5ea7c28b25b5fb515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f587e4990712c8a85283d1883839b3d/" rel="bookmark">
			URL解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统一资源定位符（URL）： 负责标识万维网上的各种文档，使每一文档在整个万维网的范围内有唯一的标识符URL。
URL的一般形式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt;
常见的&lt;协议&gt;有http、https、ftp等&lt;主机&gt;可以是主机域名或IP地址。（域名可通过域名解析得到主机IP）&lt;端口&gt;用于标识主机的应用进程&lt;路径&gt;应用进程通过&lt;路径&gt;找到需要访问的资源位置&lt;参数&gt;给该进程传递参数对资源进行相应的处理 域名解析：主机将所有请求的域名发送给本地域名服务器，由其解析出相应的IP返回给主机。由此主机可通过该IP将信息发送到网络上。
端口：端口号只具有本地意义，标志本计算机应用层中的各进程。
服务器端使用的端口号分为：熟知端口号（0~1023）和登记端口号（1024~49151） 熟知端口号： 应用程序FTPTELNETSMTPDNSHTTPSNMP熟知端口号2123255380161 客户端使用的端口号（临时端口号49152~65535）:这类端口号仅在客户进程运行时系统自动分配，等通信结束则回收该端口号，可供其它客户进程使用。 套接字： IP地址+端口号，唯一的标识网络中一个主机和其上的一个进程
下面以京东的一个URL为例，解析&lt;路径&gt;和&lt;参数&gt; 如连接：https://search.jd.com/Search?keyword=%E7%AC%94&amp;enc=utf-8&amp;psort=3&amp;page=3 这里我截取了部分参数。 这个链接用到的是https协议，域名为search.jd.com，端口默认为80端口号，定位到服务器的进程后，该进程找到Search文档，并对相应的参数做处理返回最终的页面。其中
Keyword：表示搜索的关键字，这里的值是“笔”的转码。enc：表示编码格式psort:确定以综合、销量、价格…中的一种排列展示page:确定返回的页码。 读者可以试着修改相关参数的值看看效果 当然有些网站可以通过 &lt;协议&gt;://&lt;域名&gt;:&lt;端口号&gt;/&lt;路径&gt;/&lt;参数值&gt;/&lt;参数值&gt;/…/&lt;参数值&gt;/ 这样的形式获得一些参数。 实现逻辑是，通过URL，服务器进程将能拿到端口号之后的内容构成一个字符串，然后对该字符串进行正则表达式的匹配。相关内容可以了解正则表达式的规则。 这里举个例子： 假设URL为：http://127.0.0.1:8000/article/2017/03/25/ 那么服务器进程将可通过r’^articles/(?&lt; year&gt;[0-9]{4})/(?&lt; month&gt;[0-9]{2})/(?&lt; day&gt;[0-9]{2})/$’这样的正则表达式捕获年月日。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9648deeed12f55caa3f0fe473a5d8c3a/" rel="bookmark">
			利用PLUPLOAD上传大文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用PLUPLOAD上传大文件 大容量文件上传早已不是什么新鲜问题，在.net 2.0时代，HTML5也还没有问世，要实现这样的功能，要么是改web.config，要么是用flash，要么是用一些第三方控件，然而这些解决问题的方法要么很麻烦，比如改配置，要么不稳定，比如文件上G以后，上传要么死掉，要么卡住，通过设置web.config并不能很好的解决这些问题。
这是一个Html5统治浏览器的时代，在这个新的时代，这种问题已被简化并解决，我们可以利用Html5分片上传的技术，那么Plupload则是一个对此技术进行封装的前端脚本库，这个库的好处是可以自动检测浏览器是否支持html5技术，不支持再检测是否支持flash技术，甚至是sliverlight技术，如果支持，就使用检测到的技术。
那么这个库到哪里下载，怎么搭建呢，比较懒的童鞋还是用Install-Package Plupload搞定吧，一个命令搞定所有事
下面给出一个例子，使用自已定义的控件来使用Plupload (Plupload也有自己的界面可以用)，如下
Plupload支持的功能这里就不细说了，什么批量上传，这里我没有用到，主要是感觉它支持的事件非常丰富，文件选取后的事件，文件上传中的事件(可获得文件的上传进度)，文件上传成功的事件，文件上传失败的事件，等等
我的例子主要是上传一个单个文件，并显示上传的进度条(使用jQuery的一个进度条插件)
下面的例子主要是为文件上传交给 UploadCoursePackage.ashx 来处理
/******************************************************ProgressBar********************************************************/ var progressBar = $("#loading").progressbar({ width: '500px', color: '#B3240E', border: '1px solid #000000' }); /******************************************************Plupload***********************************************************/ //实例化一个plupload上传对象 var uploader = new plupload.Uploader({ browse_button: 'browse', //触发文件选择对话框的按钮，为那个元素id runtimes: 'html5,flash,silverlight,html4',//兼容的上传方式 url: "Handlers/UploadCoursePackage.ashx", //后端交互处理地址 max_retries: 3, //允许重试次数 chunk_size: '10mb', //分块大小 rename: true, //重命名 dragdrop: false, //允许拖拽文件进行上传 unique_names: true, //文件名称唯一性 filters: { //过滤器 max_file_size: '999999999mb', //文件最大尺寸 mime_types: [ //允许上传的文件类型 { title: "Zip", extensions: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9648deeed12f55caa3f0fe473a5d8c3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495984a9ad30c41a58ef3e2d3259b4db/" rel="bookmark">
			AudioEffect构造流程跟踪 &amp; 音效库实现（native侧）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AudioEffect构造流程跟踪 为了编写新的音效实现，需要了解Android底层在AudioEffect的底层实现： 在Java层new Equalizer();后，通过JNI进入底层C/C++的实现过程。在底层，通过层层调用，由音控中枢AudioFlinger.cpp负责音效的管理，在线程中使用音效工厂EffectFactory.c读取.conf配置文件完成音效实例的创建。
AudioEffect构造流程图 详细代码跟踪参考： 安卓音效AudioEffect源码剖析1——构造流程 根据上文，我做了张图帮助理解，其中将涉及到的类、头文件的关系列出，并标明了代码路径方便查找。当然，图中只列出了构造流程的关键代码。
音效工厂EffectsFactory.c中的EffectCreate方法中的三个调用：
// 从配置文件读取平台支持的音效信息 ret = init(); // 在支持的音效中查找是否有指定的音效type/uuid ret = findEffect(NULL, uuid, &amp;l, &amp;d); // 若有，则创建音效实例 ret = l-&gt;desc-&gt;create_effect(uuid, sessionId, ioId, &amp;itfe); 配置文件路径 init()读取运行环境的音效配置文件，如果vendor/etc/audio_effects.conf存在则使用该配置，若不存在则使用系统的system/etc/audio_effects.conf。
配置文件的路径定义在 /system/media/audio_effects/include/audio_effects/audio_effects_conf.h，有以下值：
常量值顺序AUDIO_EFFECT_VENDOR_CONFIG_FILEvendor/etc/audio_effects.conf优先AUDIO_EFFECT_DEFAULT_CONFIG_FILEsystem/etc/audio_effects.conf其次 配置文件audio_effects.conf audio_effects.conf配置文件内声明了平台所支持的音效库，新增音效库时需对该文件进行修改。 AOSP路径：/frameworks/av/media/libeffects/data/audio_effects.conf
配置内容如下：
#audio_effects.conf libraries { ... bundle { path /system/lib/soundfx/libbundlewrapper.so } ... } effects { ... bassboost { library bundle uuid 8631f300-72e2-11df-b57e-0002a5d5c51b } equalizer { library bundle uuid ce772f20-847d-11df-bb17-0002a5d5c51b } ... } libraries指出了音效库.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495984a9ad30c41a58ef3e2d3259b4db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c64c6dfb2bd5836997721efc34d9a0/" rel="bookmark">
			Excel实现数据项校验的功能---VBA的编写以及数据有效性的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习VBA的网址 VBA比较运算符 - VBA教程™ VBA在Excel中的应用（一)：改变符合条件单元格的背景颜色 vba判断不是空_百度知道
测试文件 链接：http://pan.baidu.com/s/1o7QsCJo 密码：eni7
1.启用宏，编写VBA，使单元格输入的内容自动转变为大写
代码1
Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address &lt;&gt; "$D$1" Then End Target = UCase(Target.Value) End Sub 代码2
Private Sub Worksheet_Change(ByVal Target As Range) If Target.count&gt;1 then exit sub If Target.Address &lt;&gt; "$D$1" Then exit sub Target = UCase(Target.Value) End Sub 解决方案来自：Excel D1单元格内不管输入大写还是小写字母都自动转换成大写子字母-ExcelVBA程序开发-ExcelHome技术论坛
2.使用数据有效性检查输入的是否大写
公式： =NOT(ISERROR(SUM(FIND(MID(A1,ROW(INDIRECT("1:"&amp;LEN(A1))),1),"ABCDEFGHIJKLMNOPQRSTUVWXYZ"))&lt;LEN(A1))) 解决方案来自： Excel 有什么办法设置单元格只能输入英文大写字母-Excel函数与公式-ExcelHome技术论坛
3.下拉框 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d4a9b53e7c67c5d9d2a9cd6b98f19f/" rel="bookmark">
			Boost库的编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Boost的编译
一. 编译环境 Win7 sp1 64位旗舰版 + VS2008 sp1 + boost 1.63
二. 下载boost http://www.boost.org/users/history/version_1_63_0.html
https://sourceforge.net/projects/boost/files/boost/1.63.0/boost_1_63_0.7z
三. 生成boost的编译工具b2.exe和bjam.exe 3.1 解压boost_1_63_0.7z到C:\boost_1_63_0 (路径可任意选择,最好不要包含中文和空格);
3.2 使用VC2008的命令行工具并cd到C:\boost_1_63_0
3.3 输入bootstrap.bat
即可生成b2.exe和bjam.exe
四. 编译boost 4.1. 编译命令 我这里是全编译:
// 编译Debug版
b2.exe install --toolset=msvc-9.0 --prefix="vc9" link=static runtime-link=shared threading=multi debug
// 编译Release版
b2.exe install--toolset=msvc-9.0 --prefix="vc9" link=static runtime-link=shared threading=multi release
// Debug版和Release版都编译
b2.exe install--toolset=msvc-9.0 --prefix="vc9" link=static runtime-link=shared threading=multi debug release
4.2. b2.exe/bjam.exe的命令参数解析 1). stage/install stage :表示只生成库(dll/lib);
install : 除了生成库((dll/lib)),还会拷贝boost的头文件到指定的include目录;(我试过了,要拷贝一万多个头文件,很慢)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13d4a9b53e7c67c5d9d2a9cd6b98f19f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd750d33d273109f0c3c54e3bbb3d166/" rel="bookmark">
			TestFlight 新项目创建新的testflight record，查看和删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建新的testflight record 首先必须以admin权限身份来登陆itunes connect在itunes connect主页选择my apps进入后选择＋来添加新的app然后填写一些信息，sku只是标示app的名字，不会出现在app store中，一般以项目的拼音来设置然后填写完成后创建完成 查看testflight record 进入主页选择my app进入后查看具体的某一个app即可查看信息 删除一个testflight record（app） 如果app是game center group，或者是应用程序包或者在商店中正在被显示，就无法通过如下的方式删除掉，需要查看其它方式删除。
app当前的状态允许被删除
保证你的app至少有一个被审核通过的版本并且目前正处于以下的状态：
Prepare for Submission
Invalid Binary
Developer Rejected
Rejected
Metadata Rejected
Developer Removed From Sale
Removed from Sale
如果处于一个不同的状态，可以通过reject build或者从sale中移除app来达到目的。
选择app store 模块下的app information， 会在底部发现delete app，这样就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38416cc7e0cdebdb5b18131a56daddbb/" rel="bookmark">
			RK fb源码分析之SCREEN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学习，学而时习之。在工作中，利用闲暇时光简单分析下RK平台下fb源码部分，本人才疏学浅，很多地方理解的也不到位，只是简单的分析下代码流程，搞明白驱动调试过程中需要注意的地方。现将自己的一些理解与建议总结下来，如有错误之处，还望指正。
RK的LCD这块，亮点也就在于双屏异显，才开始搞驱动时，感觉这就是个高大上的东西，一脸懵逼，不知所措。随着后来慢慢深入才发现，原理和单屏也是差不多的。
分析之前，我将RK LCD这块首先分为四大块：fb、lcdc、screen、screen_type.这四部分相互依赖，首先从我们最容易入手的地方开始:rk_screen.c 一、函数调用关系 rk_screen.c函数调用关系如下： 二、probe()分析
毫无疑问，驱动的重点就是probe()函数，驱动在匹配到compatible = “rockchip,screen”后进入probe()函数，rk_screen_probe()： 在probe函数中获取”screen_prop”、”native-mode”等属性，在这里有个重要的结构体：prmry_screen会被初始化，prmry_screen 定义如下： static struct rk_screen *prmry_screen 还有一个结构体：struct rk_screen *rk_screen，rk_screen贯串上下文，并将prmry_screen指向rk_screen，prmry_screen之所以重要,是因为之后screen_type(例如LVDS，EDP,MIPI等)需要获取screen参数，就是获取prmry_screen的值，而这里prmry_screen就是rk_screen。 进入probe函数有两个函数比较重要：rk_fb_prase_timing_dt()和rk_disp_pwr_ctr_parse_dt。 首先会根据device_node中”screen_prop”的值，来决定rk_screen的”归属”： 代码中，dts的”screen_prop”的值决定了屏参文件传递进来后赋值给了谁：prmry_screen或者extend_screen.(NOTE:只有在DUAL_LCD时，screen节点下才会有”screen_prop”属性，单屏，由LCDC部分判断”screen_prop”) rk_fb_prase_timing_dt() 通过of_get_display_timings(np)解析device_node中的所有display_timing条目，然后调用 display_timings_get()从结构体display_timing中得到入口地址，最后调用了rk_fb_video_mode_from_timing(dt, screen)从display_timing中获取screen的详细信息，并将其赋值给rk_screen结构体(即prmry_screen).
rk_disp_pwr_ctr_parse_dt() 该函数主要是从dts中解析power control节点。其中，又引出来一个比较重要的结构体：struct rk_disp_pwr_ctr_list *pwr_ctr;该结构体也是一个双向链表。然后，初始化了一个双向链表rk_screen-&gt;pwrlist_head，最终会将pwr_ctr挂到rk_screen-&gt;pwrlist_head链表下： list_add_tail(&amp;pwr_ctr-&gt;list, rk_screen-&gt;pwrlist_head); for_each_child_of_node(root, child)循环解析每个子节点,例如： 首先为每个子节点(如lcd_en,lcd_cs,lcd_rst等)kmalloc一段空间, 解析dts中”rockchip,power_type”的值，rockchip,power_type = GPIO，分别获取其GPIO存至各自的pwr_ctr-&gt;pwr_ctr.gpio中，然后申请GPIO。这里，还有一个值：rockchip,delay，可以控制上电时序的延时操作，这个值在后面用到时再讲。 2. rk_fb_video_mode_from_timing() 该函数获取dts中display_timing各个子节点的值，其中有我们熟悉的VBP,VFP,HBP,HFP等可变参数，最终将获取到的值写入变量screen中，这样screen就被初始化完。 至此，screen部分probe()函数完结，现在总结下： Screen的probe()函数主要干了两件事： 解析dts中的display_timing，获取屏幕信息 解析dts中的power control，获取LCD的使能脚、片选脚、复位脚 最终，这些信息都存在了struct rk_screen *rk_screen这个结构体中，也就是prmry_screen这个结构体。那么，prmry_screen这个结构体在什么地方会用到呢？答案也是在rk_screen.c中： 调用rk_fb_get_screen()这个函数来取得screen的信息。该函数在哪被调用，后续会碰到，暂且不讨论。
以上部分，是双屏时screen部分的流程，事实上，单屏的代码更为简单。就是在probe()直接调用rk_fb_prase_timing_dt(np, rk_screen)来获取LCD屏信息，获取screen： 区别在于display_timings_get()的第二形参不同
但是，有些人又有疑问了？那双屏时会去获取power control节点的信息，单屏时为什么不用获取呢？其实也不是没有获取，只不过处理的地方不一样。双屏时，在screen部分获取power control，因为有两个LCD屏，有各自的使能脚、背光脚等等，所以引入链表保存至rk_screen结构体中，待将来使用。而单屏只有一组控制脚，只要在需要的地方获取使用就可以了。后续，只分析单屏的，理清思路即可。
最后，我们再来总结下probe()的功能： 1.如果是双屏，解析dts中screen节点下的power_ctl节点,单屏的power_ctl节点在别的地方(后续讲述)处理 2.从dts中获取LCD各个参数(VFP,VBP,HBP,HFP,W,H,CLOCK等等) 3.单屏保存至全局静态变量rk_screen，双屏时分别保存至prmry_screen和extend_screen以区别主副屏
SCREEN部分是整个fb调试过程中，需要更改参数最多的，通常LCD调试只需要调整screen的dts各个参数即可。LCD调试部分请参考另外一篇博文【Rk平台LCD调试说明】
三、struct rk_screen
struct rk_screen { #ifdef CONFIG_DUAL_LCD struct device *dev; int prop; struct list_head *pwrlist_head; //power ctl链表，保存power ctl gpio int native_mode; #endif u16 type; u16 lvds_format; //LVDS数据格式 u16 face; //display out face,18bit,24bit u16 color_mode; u8 lcdc_id; //dual lcd时用于区分LCD u8 screen_id; struct fb_videomode mode; //important u32 post_dsp_stx; u32 post_dsp_sty; u32 post_xsize; u32 post_ysize; u16 x_mirror; u16 y_mirror; int interlace; int pixelrepeat; //For 480i/576i format, pixel is repeated twice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38416cc7e0cdebdb5b18131a56daddbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6029ca4a79cff0da0abd562becb247c1/" rel="bookmark">
			彻底搞懂CoordinatorLayout
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于： http://mp.weixin.qq.com/s?__biz=MzIzMjE1Njg4Mw==&amp;mid=2650117781&amp;idx=1&amp;sn=187bcdbbbfa0610e131c03a0e8a0fbf5&amp;chksm=f0980d29c7ef843f8e5614cb2907277913022f0376363310fe206b1bf413ffec025f593866af&amp;scene=21#wechat_redirect
本系列文章会从官方文档出发，从基本使用姿势到工作原理，试图把CoordinatorLayout、AppBarLayout等一系列Material Desgin风格控件彻底讲明白。本篇文章主要介绍CoordinatorLayout的基本概念，是后续篇章的基础。
从是什么开始 首先我们先来看看CoordinatorLayout究竟是个什么东东，它究竟是用来做什么的。官方文档对CoordinatorLayout是这样描述的：
CoordinatorLayout是一个“加强版”FrameLayout，它主要有两个用途：
用作应用的顶层布局管理器，也就是作为用户界面中所有UI控件的容器
用作相互之间具有特定交互行为的UI控件的容器
通过为CoordinatorLayout的子View指定Behavior，就可以实现它们之间的交互行为。 Behavior可以用来实现一系列的交互行为和布局变化，比如说侧滑菜单、可滑动删除的UI元素，以及跟随着其他UI控件移动的按钮等。
上面的描述可能有些抽象，现在我们只需要知道CoordinatorLayout是一个布局管理器，主要用来实现它的子View间的交互行为。那么什么是交互行为呢？我们来看一个简单的例子：
在上图中，我们拖动按钮，可以看到，一个TextView会跟着按钮一起移动。这就是交互行为的一个简单地例子。也就是说首先需要Button的位置发生变化，然后TextView对Button的位置变化做出响应，这个例子中，TextView做出响应的方式就是跟随着Button一起移动。那么这个交互行为时如何实现的呢？我们接着往下看。
如何实现交互行为 上面我们看到了一个简单的交互行为的例子，下面我们通过分析这个例子来介绍一下实现交互行为的一般性步骤。
上面的例子实现的是Button和TextView的交互行为：Button发生变化时，TextView要对这个变化做出响应。那么首先我们要让TextView知道Button产生了变化，还要指明TextView对Button的变化做出什么反应。
这里实际上是一个观察者模式的运用：TextView是观察者，Button是被观察者。TextView需要向系统注册一个回调，告知系统在Button发生变化时通知它，这样当Button发生变化时，TextView会得到关于这个变化的通知，而后就可以对这个变化做出响应。如此一来我们便实现了TextView和Button的交互行为。下面我们来介绍如何通过给TextView设置一个Behavior来实现上面的交互行为。
XML布局文件 首先我们先来看一下用户界面的布局文件：
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent" xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;TextView app:layout_behavior=".FollowBehavior" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="观察者" /&gt; &lt;Button android:id="@+id/btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:text="被观察者" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 我们为TextView指定了一个layout_behavior属性，这样就给它设置了一个Behavior。我们可以看到layout_behavior属性的值为".FollowBehavior"，指的是当前Module中一个名为FollowBehavior的类，它实际上是CoordinatorLayout.Behavior类的子类，我们来看一下FollowBehavior类的实现。
自定义交互行为类 FollowBehavior类的代码如下：
public class FollowBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; { public FollowBehavior(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean layoutDependsOn(CoordinatorLayout parent, TextView child, View dependency) { return dependency instanceof Button; } @Override public boolean onDependentViewChanged(CoordinatorLayout parent, TextView child, View dependency) { child.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6029ca4a79cff0da0abd562becb247c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c155488c12517d17ef6b80cda083bc7/" rel="bookmark">
			常见的移动端H5页面开发遇到的坑和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转过来，平时看看。虽然还有很多问题至今无解。比如：华为麒麟950的P8和meta打开我们的应用首页经常偶发白屏。！！
1、安卓浏览器看背景图片，有些设备会模糊。
用同等比例的图片在PC机上很清楚，但是手机上很模糊，原因是什么呢？
经过研究，是devicePixelRatio作怪，因为手机分辨率太小，如果按照分辨率来显示网页，这样字会非常小，所以苹果当初就把iPhone 4的960640分辨率，在网页里只显示了480320，这样devicePixelRatio＝2。现在android比较乱，有1.5的，有2的也有3的。
想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况都是用2倍）。例如一个div的宽高是100100，背景图必须得200200，然后background-size:contain;，这样显示出来的图片就比较清晰了。
代码如下：
background:url(../images/icon/all.png) no-repeat center center;
-webkit-background-size:50px 50px;
background-size: 50px 50px;display:inline-block; width:100%; height:50px;
或者指定 background-size:contain;都可以，大家试试！
2、图片加载
若您遇到图片加载很慢的问题，对这种情况，手机开发一般用canvas方法加载：
具体的canvas API 参见：http://javascript.ruanyifeng.com/htmlapi/canvas.html
下面举例说明一个canvas的例子：
&lt;li&gt;&lt;canvas&gt;&lt;/canvas&gt;&lt;/li&gt;
js动态加载图片和li 总共举例17张图片！
var total=17;
var zWin=$(window);
var render=function(){
var padding=2;
var winWidth=zWin.width();
var picWidth=Math.floor((winWidth-padding*3)/4);
var tmpl ='';
for (var i=1;i&lt;=totla;i++){
var p=padding;
var imgSrc='img/'+i+'.jpg';
if(i%4==1){
p=0;
}
tmpl +='&lt;li style="width:'+picWidth+'px;height:'+picWidth+'px;padding-left:'+p+'px;padding-top:'+padding+'px;"&gt;&lt;canvas id="cvs_'+i+'"&gt;&lt;/canvas&gt;&lt;/li&gt;';
var imageObj = new Image();
imageObj.index = i;
imageObj.onload = function(){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c155488c12517d17ef6b80cda083bc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c21f71cba6e7cd3aa474df33b78474/" rel="bookmark">
			iframe中父子窗口的调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、iframe标签详解 &lt;iframe src="1.html" frameborder="0" id="child"&gt;&lt;/iframe&gt; (1)操作子窗口：frames[‘child’].contentDocument || frames[‘child’].document
1.首先获取iframe节点：
var myIframe = document.getElementById('child'); 或 var myIframe = frames['child']; 或 var myIframe = window.frames['child']; 或 var myIframe = child; window对象的frames属性返回一个类似数组的对象，成员是所有子窗口的window对象。比如，frames[0]返回第一个子窗口。如果iframe设置了id或name，那么属性值会自动成为全局变量，并且可以通过window.frames属性引用，返回子窗口的window对象。
window.frames['child'] === frames['child'] === child === document.getElementById('child'); 2.然后获取iframe包含的document对象:
IE浏览器：
var childDocument = myIframe.document; 其他浏览器：
var childDocument = myIframe.contentWindow.document; 或 var childDocument = myIframe.contentDocument; contentWindow属性获得iframe节点包含的window对象， contentDocument属性获得包含的document对象，等价于contentWindow.document 注意：iframe元素遵守同源政策，只有当父页面与框架页面来自同一个域名，两者之间才可以用脚本通信，否则只有使用window.postMessage方法。
(2)操作父窗口：iframe.parent iframe窗口内部，使用window.parent引用父窗口。如果当前页面没有父窗口，则window.parent属性返回自身。因此，可以通过window.parent是否等于window.self，判断当前窗口是否为iframe窗口。
if (window.parent !== window.self) { //当前窗口是子窗口 var parentDocument = window.parent.document; } 二、iframe中父子窗口操作实例 父页面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c21f71cba6e7cd3aa474df33b78474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2022a973cd5cabe7d201fc5e09a701fd/" rel="bookmark">
			记一次阿里C/C&#43;&#43;研发岗电话面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 明明投的是阿里硬件相关的，但是一个搜索引擎的来面我也是醉醉的。 大致是四个方面：linux基础，C++，操作系统，数据结构。 linux基础： 列举熟悉的linux命令？关于系统状态的命令？怎么查看一个目录下文件的总大小？怎么将一个文件中某一字符串替换成另一个？还有linux网络编程的，socket服务端客服端通信过程以及服务端如何处理多个客服端访问。 C++： 说说多态是什么？重载和重写区别？一个类的成员能否是引用类型？stl的包括哪些模板？gdb的基本命令？你知道的设计模式？ 操作系统： 进程和线程区别？什么时候适合用多线程什么时候适合用多进程？一个消费者线程一个生产者线程如果不加锁访问同一缓冲区该怎么编程？ 数据结构： 100G大小的数据文件只有1G内存怎么排序（外部排序）？100G大小的文件找出TOP10最大的？100万条网络访问记录找出访问频率最高的前10条？判断一个单向链表是否有环？输出单向链表倒数第K个节点？如果写一个监控程序去监控日志文件（日志文件在不断更新），当出现error时进行报警，怎么写？ 大致只记得这些。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1012d45e2f583fa14aa9dede9faa478a/" rel="bookmark">
			100道Java经典面试题及答案解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用域public,private,protected,以及不写时的区别 答：区别如下： 作用域 当前类 同一package 子孙类 其他package public √ √ √ √ protected √ √ √ × friendly √ √ × × private √ × × × 不写时默认为friendly
String是最基本的数据类型吗? java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类
int 和 Integer 有什么区别 Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。 原始类型封装类 booleanBoolean charCharacter byteByte shortShort intInteger longLong floatFloat doubleDouble 引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数 据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。
String 和StringBuffer的区别 JAVA 平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改 变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可 以使用StringBuffers来动态构造字符数据。
运行时异常与一般异常有何异同？ 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。
说出Servlet的生命周期，并说出Servlet和CGI的区别。 Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。 与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。
说出ArrayList,Vector, LinkedList的存储性能和特性 ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元 素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差， 而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
EJB是基于哪些技术实现的？并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。 EJB包括Session Bean、Entity Bean、Message Driven Bean，基于JNDI、RMI、JAT等技术实现。 SessionBean在J2EE应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他EJB组件。EntityBean被用来代表应用系统中用到的数据。 对于客户机，SessionBean是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。 对于客户机，EntityBean是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。 Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的 Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个 Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1012d45e2f583fa14aa9dede9faa478a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2006b9be4dcdcce9e92b11dbfa3f003/" rel="bookmark">
			浅析js中2个等号与3个等号的区别(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，== equality 等同，=== identity 恒等。
==， 两边值类型不同的时候，要先进行类型转换，再比较。
===，不做类型转换，类型不同的一定不等。
下面分别说明：
先说 ===，这个比较简单。下面的规则用来判断两个值是否===相等：
1、如果类型不同，就[不相等]
2、如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断）
3、如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。
4、如果两个值都是true，或者都是false，那么[相等]。
5、如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。
6、如果两个值都是null，或者都是undefined，那么[相等]。
再说 ==，根据以下规则：
1、如果两个值类型相同，进行 === 比较。
2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：
a、如果一个是null、一个是undefined，那么[相等]。
b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。
c、如果任一值是 true
您可能感兴趣的文章: javascript中的=等号个数问题两个跟三个有什么区别JavaScript中三个等号和两个等号的区别(== 和 ===)浅析JavaScript知识点总结(五)之Javascript中两个等于号(==)和三个等于号(===)的区别细数JavaScript 一个等号,两个等号,三个等号的区别 转载于:https://www.cnblogs.com/kingxiaozi/p/6591951.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2596cec8bc0f7e1787c006eaa8cea53d/" rel="bookmark">
			认识registerActivityLifecycleCallbacks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天无意中看到了Application提供了一个 方法，可以监控app内所有activity的生命周期，虽然现在没有用到，但是记录起来，不一定以后有什么用呢。
在Android4.0以后， registerActivityLifecycleCallbacks是Application的一个接口，注册之后应用里的所有activity的生命周期都会被监控起来，我们可以在此接口方法里实现一些特殊的需求。比如统计用户对每个Activity使用情况，我们可以定义一个BaseActivity，在onStart()和onStop()人工插入统计方法。比如从桌面进应用的时候，检测某些状态，就可以在onActivityResumed方法里检测.
参考：http://www.ithao123.cn/content-42542.html
this.registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() { @Override public void onActivityCreated(Activity activity, Bundle bundle) { } @Override public void onActivityStarted(Activity activity) { } @Override public void onActivityResumed(Activity activity) { } @Override public void onActivityPaused(Activity activity) { } @Override public void onActivityStopped(Activity activity) { } @Override public void onActivitySaveInstanceState(Activity activity, Bundle bundle) { } @Override public void onActivityDestroyed(Activity activity) { } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a152ad5950b36bdc10ee830d7f9f1c0a/" rel="bookmark">
			中心极限定理的一个例子：大小医院的新生儿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个问题 在复习概率论与数理统计的时候，发现一个有趣的例子： 两家医院，大医院每天新生儿45个，小医院新生儿15个，问一年内哪家医院男新生儿比例超过60%的天数多的可能性大？
乍眼一看，直觉告诉我新生儿的自然男女比例应该固定在50%左右的某个值，两家医院的男女概率应该都是这个值，所以两家医院的可能性相同。 答案明显没那么简单。
这里想引入两个定律：
伯努利大数定律 设 μn 是n重伯努利试验中事件A发生的次数，已知在每次试验中A发生的概率为 p(0&lt;p&lt;1) ，则对任意 ϵ&gt;0 ，有 limn→∞P{|μnn−p|&gt;ϵ}=0 即 μnn→p 或 P−limn→∞μnn=p 大数定律的意思是如果一个事件A的概率为p，那么大量重复试验中事件A发生的概率将逐渐稳定到概率p。
但大数定律并没有告诉我们，当n充分大时， P{|μnn−p|&gt;ϵ} 的概率到底有多大。此时引入中心极限定理。
中心极限定理 （林德伯格-列维）设 ξ1,ξ2,…,ξn,… 是一列独立同分布的随机变量，且 Eξi=μ ， D(ξi)=σ2&gt;0 ， i=1,2,… ，则有 limn→∞{∑ni=1ξi−nμn√σ≤x}=12π−−√∫x−∞e−t22dt 即 ∑ni=1ξi−nμn√σ∼N(0,1) 大数定律没有告诉我们 P{|μnn−p|&gt;ϵ} 的概率到底有多大，但中心极限定理告诉了我们： 1n∑i=1nξi−μ∼N(0,1nσ2) 这个分布告诉我们，当n越大时， 1n∑ni=1ξi−μ 服从的正态分布的方差越小， 1n∑ni=1ξi 靠近 μ 的概率就越大。
解答 回到新生儿问题，大医院一天的样本量比小医院的样本量要多，所以大医院 1n∑ni=1ξi−μ 服从的正态分布的方差要比小医院的小，所以大医院在x=0.1(60%-50%)的概率要比小医院的小，即大医院一天男新生儿多于60%的可能性比小医院的要小。
所以正确答案是小医院的可能性大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2c6be4d80a838bdb10c229bba9d40c/" rel="bookmark">
			Java线程唤醒与阻塞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。
1. sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间 内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后 重新测试，直到条件满足为止。 2. suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会 自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个 线程产生了结果后，调用 resume() 使其恢复。 3. yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于 可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足 够的时间从而转到另一个线程。 4. wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式 ，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或 者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。 初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区 别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则 相反。
上述的核心区别导致了一系列的细节上的区别。
首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说， 所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞 时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象 上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随 机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f2c6be4d80a838bdb10c229bba9d40c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c3362083bc3452c9b03c5e7b59f9ea/" rel="bookmark">
			C&#43;&#43;实现上传下载文件，支持windows及iOS、Android
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用方法：
SendAndGet("abc.com", 80, "/index.php", "", "");//GET SendAndGet("abc.com", 80, "/index.php", "user=abc&amp;pass=123qwe", "");//POST SendAndGet("abc.com", 80, "/download.php", "", "/download/1.jpg");//GET下载 SendAndGet("abc.com", 80, "/index.php", chr(1)."/record/1,mp3", "");//上传文件并获得服务器返回， chr(1)表示等于1的char。直接用sendFile更简单 .h文件
#pragma once #include "cocos2d.h" #ifdef WIN32 //#include &lt;windows.h&gt; //#include &lt;WinSock.h&gt; #include &lt;direct.h&gt; #include &lt;io.h&gt; #else #include &lt;sys/socket.h&gt; #include &lt;fcntl.h&gt; #include &lt;errno.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;netdb.h&gt; #define SOCKET int #define SOCKET_ERROR -1 #define INVALID_SOCKET -1 #include &lt;stdarg.h&gt; #include &lt;sys/stat.h&gt; #endif #ifdef WIN32 #define ACCESS _access #define MKDIR(a) _mkdir((a)) #else #define ACCESS access #define MKDIR(a) mkdir((a),0755) #endif USING_NS_CC; class httpDownSimple : public cocos2d::CCObject { public: int type; std::string url; const char* serverName; int nServerPort; const char* _url; void go(void *obj); std::string savePath; //By Lein，SendAndGet 实现了上传和下载，GET、POST灵活使用 static std::string SendAndGet(const char* server_name, int nServerPort, const char* url, char* data, const char* filePath); //SendFile 调用的是SendAndGet static std::string SendFile(const char* server_name, int nServerPort, const char* url, const char* filePath); }; #pragma once .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c3362083bc3452c9b03c5e7b59f9ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4cff397c9e05a2bba77462a4ae5694c/" rel="bookmark">
			dom03节点的插入移除克隆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		节点的插入移除克隆 插入： appendChild();追加子节点 把一个节点放到父节点内部的最后。 如果是页面上原有的节点 会被从原来的位置上揪下来 放到新的位置。
insertBefore(要插入的新的子节点,参考节点); 插入到前面 把一个节点放到父节点内部 参考节点的前面。
克隆： cloneNode(true)；true是全部克隆，一般都传true。 var clone=demo.cloneNode(true);克隆之后需要追加进去才会显示在页面。 father.addpendChild(clone);//克隆出来的节点，和原来的节点互不影响。
移除： removeChild();
&lt;script&gt; //克隆 var zIndex=0; var tip=document.getElementById('cc'); var content=document.getElementById('content'); //批量克隆 for (var i = 0; i &lt; 10; i++) { var cloneTip=tip.cloneNode(true); cloneTip.id="cc"+i; content.appendChild(cloneTip); //产生随机位置：（水平方向，垂直方向） //Math.random()设置的取值范围是[0,1); //屏幕的大致范围为400-800;[0,1)*400+400=[400,800); //垂直方向0-400 var x=parseInt(Math.random()*400+400); var y=parseInt(Math.random()*400); //控制克隆的元素位置 cloneTip.style.left=x+"px"; cloneTip.style.top=y+"px"; //设置每一个便签的层级关系zIndex，设置之前先用一个变量接收zIndex。 //再绑定点击事件 cloneTip.onclick=function(){ zIndex++; this.style.zIndex= zIndex; } ; //双击头部关闭纸条 双击ondblcilck; var header=document.getElementById('content').getElementsByTagName('tip_h'); //获取元素 firstElementChild 第一个子元素 // var header=cloneTip.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4cff397c9e05a2bba77462a4ae5694c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9007af52c5238e85cae6eec286687d58/" rel="bookmark">
			ImportError: DLL load failed:找不到指定的模块 解决方案（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先检查numpy、scipy、matplotlib、scikit-learn的版本是否更新到最新且符合当前Python版本： 如果出现不是最新的版本，先卸载该版本：（windows+".\"）pip uninstall numpy 再去 http://www.lfd.uci.edu/~gohlke/pythonlibs/ 安装最新版本： （windows+".\"）pip install numpy 优先更新numpy，通常更新完numpy即可解决问题！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06d19c0b13b9f62f1033288414a502b/" rel="bookmark">
			解决python错误提示“non-default argument follows default argument”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个风趣幽默的人工智能学习网站，通俗易懂，忍不住分享一下给大家。点击跳转到教程 今天在训练模型的时候无意间遇到了一个错误，这个可能是自己之前没有多去了解过python的参数相关的知识，这个错误还是第一次遇到。所以查了一下资料，在网上找到几个可以参考的链接明白了怎么回事：
参考：
http://stackoverflow.com/questions/17893820/python-default-argument-syntax-error
http://stackoverflow.com/questions/16932825/why-non-default-arguments-cant-follows-default-argument
http://stackoverflow.com/questions/24719368/syntaxerror-non-default-argument-follows-default-argument
终于明白了为什么报错：就是说我把含有默认值的参数放在了不含默认值的参数的前面，这样问题就好解决了，调换一下参数的位置就好了
我原始的函数为：
def random_predict(model_file='model/svm_model.pkl', X_train, y_train, X_test, y_test) clf = joblib.load("model/svm_model.pkl") result = [] for i in range(10): lin = random.randint(0, 150) prediction_train = clf.predict(X_train[lin]) prediction_test = clf.predict(X_test[lin]) print prediction_train print '----------------------------------------------------------------' print prediction_test for i in prediction_train: result.append(i) for j in prediction_test: result.append(j) print result 修改为：
def random_predict(X_train, y_train, X_test, y_test, model_file='model/svm_model.pkl'): model = joblib.load(model_file) clf = joblib.load("model/svm_model.pkl") result = [] for i in range(10): lin = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f06d19c0b13b9f62f1033288414a502b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af3a6d4c4885f74c4d95c5fb5d676f1/" rel="bookmark">
			100道经典Hadoop常见面试/笔试题及答案解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		100道常见Hadoop面试/笔试题，都是带有答案解析的哦，各类题型都有，单选题、多选题、判断题和简单题，这是第一版，下周推出第二版，将会加入更多面试/笔试题。 1 单选题 1.1 下面哪个程序负责 HDFS 数据存储。 a)NameNode b)Jobtracker c)Datanode d)secondaryNameNode e)tasktracker 答案C datanode 1.2 HDfS 中的 block 默认保存几份？ a)3 份 b)2 份 c)1 份 d)不确定 答案A默认3份
1.3 下列哪个程序通常与 NameNode 在一个节点启动？ a)SecondaryNameNode b)DataNode c)TaskTracker d)Jobtracker 答案D，此题分析： hadoop的集群是基于master/slave模式，namenode和jobtracker属于master，datanode和tasktracker属于slave，master只有一个，而slave有多个SecondaryNameNode内存需求和NameNode在一个数量级上，所以通常secondary NameNode（运行在单独的物理机器上）和NameNode运行在不同的机器上。 JobTracker和TaskTracker JobTracker 对应于 NameNode TaskTracker 对应于 DataNode DataNode 和NameNode 是针对数据存放来而言的 JobTracker和TaskTracker是对于MapReduce执行而言的 mapreduce中几个主要概念，mapreduce整体上可以分为这么几条执行线索：obclient，JobTracker与TaskTracker。 1、JobClient会在用户端通过JobClient类将应用已经配置参数打包成jar文件存储到hdfs，并把路径提交到Jobtracker,然后由JobTracker创建每一个Task（即MapTask和ReduceTask）并将它们分发到各个TaskTracker服务中去执行。 2、JobTracker是一个master服务，软件启动之后JobTracker接收Job，负责调度Job的每一个子任务task运行于TaskTracker上，并监控它们，如果发现有失败的task就重新运行它。一般情况应该把JobTracker部署在单独的机器上。 3、TaskTracker是运行在多个节点上的slaver服务。TaskTracker主动与JobTracker通信，接收作业，并负责直接执行每一个任务。TaskTracker都需要运行在HDFS的DataNode上。 1.4 Hadoop 作者 a)Martin Fowler b)Kent Beck c)Doug cutting 答案C Doug cutting
1.5 HDFS 默认 Block Size a)32MB b)64MB c)128MB 答案：B (因为版本更换较快，这里答案只供参考)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4af3a6d4c4885f74c4d95c5fb5d676f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca844ac9d3c886f87db7640ac62ddf05/" rel="bookmark">
			c# uint[]和int[]  转 byte[]的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uint[] UintArray
byte[] ByteArray
1.for循环转
for(int i = 0;i&lt;UintArray.lenth;i++){
ByteArray[i] = (byte)UintArray[i]
}
2.方式
ByteArray = Array.ConvertAll(UintArray, new Converter&lt;uint, byte&gt;(PointFToPoint));
public static byte PointFToPoint(uint UintArray)
{
return (byte)UintArray;
}
3.方式
ByteArray = UintArray.SelectMany(BitConverter.GetBytes).ToArray();
4.int[] 转byte[]
public static byte[] IntArrToByteArr(int[] intArr)
{
int intSize = sizeof(int) * intArr.Length;
byte[] bytArr = new byte[intSize];
//申请一块非托管内存 IntPtr ptr = Marshal.AllocHGlobal(intSize);
//复制int数组到该内存块 Marshal.Copy(intArr, 0, ptr, intArr.Length);
//复制回byte数组 Marshal.Copy(ptr, bytArr, 0, bytArr.Length);
//释放申请的非托管内存 Marshal.FreeHGlobal(ptr);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca844ac9d3c886f87db7640ac62ddf05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2de7649fc7b9fc71bcaa4ea1a28ca26/" rel="bookmark">
			Winserver 2008事件日志-事件ID详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在研究服务器的安全性，发现有未知登录，然后开始研究，当然第一步是需要读懂事件日志的，winserver上的事件是按照事件ID来标示的。 审计目录服务访问 4934 - Active Directory 对象的属性被复制 4935 -复制失败开始 4936 -复制失败结束 5136 -目录服务对象已修改 5137 -目录服务对象已创建 5138 -目录服务对象已删除 5139 -目录服务对象已经移动 5141 -目录服务对象已删除 4932 -命名上下文的AD的副本同步已经开始 4933 -命名上下文的AD的副本同步已经结束 审计登录事件 4634 - 帐户被注销 4647 - 用户发起注销 4624 - 帐户已成功登录 4625 - 帐户登录失败 4648 - 试图使用明确的凭证登录 4675 - SID被过滤 4649 - 发现重放攻击 4778 -会话被重新连接到Window Station 4779 -会话断开连接到Window Station 4800 – 工作站被锁定 4801 - 工作站被解锁 4802 - 屏幕保护程序启用 4803 -屏幕保护程序被禁用 5378 所要求的凭证代表是政策所不允许的 5632 要求对无线网络进行验证 5633 要求对有线网络进行验证 审计对象访问 5140 - 网络共享对象被访问 4664 - 试图创建一个硬链接 4985 - 交易状态已经改变 5051 - 文件已被虚拟化 5031 - Windows防火墙服务阻止一个应用程序接收网络中的入站连接 4698 -计划任务已创建 4699 -计划任务已删除 4700 -计划任务已启用 4701 -计划任务已停用 4702 -计划任务已更新 4657 -注册表值被修改 5039 -注册表项被虚拟化 4660 -对象已删除 4663 -试图访问一个对象 审计政策变化 4715 - 对象上的审计政策(SACL)已经更改 4719 - 系统审计政策已经更改 4902 - Per-user审核政策表已经创建 4906 - CrashOnAuditFail值已经变化 4907 - 对象的审计设置已经更改 4706 - 创建到域的新信任 4707 - 到域的信任已经删除 4713 - Kerberos政策已更改 4716 - 信任域信息已经修改 4717 - 系统安全访问授予帐户 4718 - 系统安全访问从帐户移除 4864 - 名字空间碰撞被删除 4865 - 信任森林信息条目已添加 4866 - 信任森林信息条目已删除 4867 - 信任森林信息条目已取消 4704 - 用户权限已分配 4705 - 用户权限已移除 4714 - 加密数据复原政策已取消 4944 - 当开启Windows Firewall时下列政策启用 4945 - 当开启Windows Firewall时列入一个规则 4946 - 对Windows防火墙例外列表进行了修改，添加规则 4947 - 对Windows防火墙例外列表进行了修改，规则已修改 4948 - 对Windows防火墙例外列表进行了修改，规则已删除 4949 - Windows防火墙设置已恢复到默认值 4950 - Windows防火墙设置已更改 4951 - 因为主要版本号码不被Windows防火墙承认，规则已被忽视 4952 - 因为主要版本号码不被Windows防火墙承认，部分规则已被忽视，将执行规则的其余部分 4953 - 因为Windows防火墙不能解析规则，规则被忽略 4954 - Windows防火墙组政策设置已经更改，将使用新设置 4956 - Windows防火墙已经更改主动资料 4957 - Windows防火墙不适用于以下规则 4958 - 因为该规则涉及的条目没有被配置，Windows防火墙将不适用以下规则： 6144 - 组策略对象中的安全政策已经成功运用 6145 - 当处理组策略对象中的安全政策时发生一个或者多个错误 4670 - 对象的权限已更改 审计特权使用 4672 - 给新登录分配特权 4673 - 要求特权服务 4674 - 试图对特权对象尝试操作 审计系统事件 5024 - Windows防火墙服务已成功启动 5025 - Windows防火墙服务已经被停止 5027 - Windows防火墙服务无法从本地存储检索安全政策，该服务将继续执行目前的政策 5028 - Windows防火墙服务无法解析的新的安全政策，这项服务将继续执行目前的政策 5029 - Windows防火墙服务无法初始化的驱动程序，这项服务将继续执行目前的政策 5030 - Windows防火墙服务无法启动 5032 - Windows防火墙无法通知用户它阻止了接收入站连接的应用程序 5033 - Windows防火墙驱动程序已成功启动 5034 - Windows防火墙驱动程序已经停止 5035 - Windows防火墙驱动程序未能启动 5037 - Windows防火墙驱动程序检测到关键运行错误，终止。 4608 -Windows正在启动 4609 - Windows正在关机 4616 - 系统时间被改变 4621 - 管理员从CrashOnAuditFail回收系统，非管理员的用户现在可以登录，有些审计活动可能没有被记录 4697 - 系统中安装服务器 4618 - 监测安全事件样式已经发生 想查看所有事件的完整列表，请访问微软网站：http://support.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2de7649fc7b9fc71bcaa4ea1a28ca26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa1a14788135af957731f8dac95e703d/" rel="bookmark">
			return返回值用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中
public static int add(int x, int y）{ z = x + y return z; } 返回值是必须有的，作用就是把固定不变的、常用的代码封装起来写在类里，每次用到的时候就调用就行了。如果需要这个功能返回一个值，甚至一个对象，就需要用返回值了即用return来把值返回给调用者。
在Python中
def add(a, b): c = a + b return c return直接返回c，若不需要也可以不要return
若在return下再加一句
def add(a, b): c = a + b return c print(c) 这时的print(c)将不会被执行，return之后直接跳出函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3137ad02540a53d7cb510b2d36862d1d/" rel="bookmark">
			年近30------职业回顾与思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是一名普通的二本院校毕业的学生，专业是电子信息工程，毕业时间是2012年。得益于大学时代对电子信息技术的极大兴趣，外加自己足够的付出，大学期间获得了全国大学生电子设计大赛一等奖，飞思卡尔的全国二等奖，当时有同学告诉我有这个奖项将来工作就不愁了，可那时心里从来没有把得奖与工作建立起关系。
学校：
回顾大学的时光，主要被3样事情占据，谈恋爱、打游戏、泡实验室。谈恋爱是大一开始的，现在很庆幸大一就开始恋爱了，恋爱让我的人生走在了一条普通而可预见的轨迹，大学恋爱，毕业后两年结婚，一年后生子。我想如果没有这段持久的恋爱经历，我的人生可变性将会无法预测。打游戏是大学的基本日常，大学时代玩的war3对战已经逐渐退出了时代，埋藏在80后的记忆中了。最后是实验室，恋爱让我的人生变得趋向稳定，而实验室的经历则与职业生涯息息相关，很庆幸，我对自己所学习的专业是热爱的，甚至有时是狂热。大二开始，我在学校的创新实验室度过了大学大部分时光，只要没有课我都会在实验室，一直待到学校寝室关门，甚至是通宵。参与培训、参加比赛、打破学校历史记录、成为实验室的负责人、组织队伍、给学弟们办理培训、带队参赛、再次打破学校的记录构成了实验室经历完整的时间节点。
中科院：2012-2014
毕业后面试了中国科学院**研究所，当然面试的时候，中科院的副所长加几个研究员面试的我，而站在旁边旁听的则是博士后，对一个刚毕业的本科生而言顿时感觉自己来到了科研的天堂，而得知自己面试通过时，只能用心花怒放来形容，虽然每个月的工资只有3500（包吃住）。科研这条路自己是有尝试过的，并且认认真真的利用4个月的时间复习，并报考所在的研究所的研究生，可惜没有考上，中科院的研究生难度相对是比较难的，特别是他的专业课。中科院工作两年让我学到的很多东西，受益最大的是对科研体系的认知，对科研方法论的认知，从心理上安慰自己在中科院工作的两年是自己在中科院读了两年的研究生，虽然我没有被授予学历。在中科院另外一件重要的事情，就是工作方向的转变，面试中科院主要的工作是做嵌入式开发。但是当项目组没有FPGA工程师时，我主动提出做FPGA方向，其实当时的想法很简单，学习一门新的技能，并且我对学习新的东西抱有极大的兴趣，越是有挑战越想学。另外有一个重要的原因，FPGA是项目的核心，而我一直比较享受当核心成员的感觉，无论多累或者难度多大，我都乐于享受这种感觉。正是因为享受这种感觉，也让我无论是在学生时代，还是工作中，经历过的所有团队我都是核心成员。
离开中科院是迫于无奈，每个月4000块的工资（第二年涨了500）在北京只能够自己生存，但是我意识到我要结婚了，按照现有薪资标准，我可能连筹备婚礼的钱都没有，2014年我准备离职，中科院的工作让我还处于一个学生状态，与社会基本没有交集，对社会的认知与毕业生无二，换工作前夕我在夜里躺在床上想过，如果换工作工资能够涨到8000，我将知足了！
面试：
投简历的过程中，在FPGA的QQ技术交流群的空间里贴上了自己的简历，QQ技术交流群算是当时与外界接触的极少数通道了，群中我认识一个叫999T的人，我后来叫他9哥，他工作经历丰富个性高调，但对我来说，他是我职业生涯的导师。
他告诉我说：“小伙子你很优秀”。
他继续告诉我说：“小伙子，你在市场上不只值8000块的价”。
一个有经验的职场老鸟给你的鼓励是巨大的，他能让你知道自己在职场的估值，这个非常重要，不知道这个信息，我将会在面试过程中，怯生生的对HR说“我期望的月薪是8000”，更重要的是，当你面试时，面试官跟你说：“据我所知，你这个能力和经验还不值这个价”，你会怀疑自己，特别是有一帮人这么说你时，但是9哥的话能让你觉得面试官的话不一定是对的。
最终面试下来的证明，9哥是对的，我一共拿了6个offer，每个offer的薪资都是12K（当时我填写的所有期望薪资都是13K，如果我是一个职场老鸟的话，第一个offer12k后，后面应该逐步往上加，但是当时没有），拿到第一个offer时，我都不敢相信自己一个月可以拿到这么多的薪水（大学生活费一个月才500）。虽然后来我知道14年同期的985毕业生的批发价差不多是10k，但是对自己来说已经大大的超出了预期，而且从offer的数量来说，当时自己足够自信，应该能拿到14-15k的offer。
京微雅格：2014-2016
Offer的选择上，最终选择了京微雅格--国产FPGA芯片的设计与供应商，选择的主要原因是京微雅格能够提供FPGA足够专业的技术平台，有优秀和资深的技术团队，自己能有更大的提升空间。同时还有一点小细节，offer发的快，上午面试下午发offer，让你能够感觉到这家公司对人才的渴求。
公司由美国成立后来迁移到中国，VP都是有长时间海外经历的华人，而我们研发小组5个人，除了我之外其他都是985硕士，组长清华硕士，以至于CTO年终谈话和我说“你是一个招聘的特例”，感觉这和我大学和中科院的工作经历的分不开的，这些奖项与经历让我获得应聘的门票。当然我在两年工作中考核都是A，对于企业来说我的性价比应该是比较高的，这也让我在第二年的加薪中，薪资增加了20%（公司的平均加薪基数为8%），由12K加到15k 。在京微雅格工作两年，技术进步是必然的，但是对个人来说，觉得以下东西更重要：正规的企业汇报制度、大规模项目的合作开发制度、FPGA芯片非常底层的技术常识。
很不幸的是公司在16年资金链断裂，欠薪两个月，被动离职了。如果公司没有倒闭，我将会一直朝着FPGA技术方向走下去，做一个FPGA领域的专业技术人员，但是事与愿违，FPGA这种长投资周期，技术被美国垄断的行业，做成功的难度与CPU是基本一致的。
思考：
离开京微雅格后，我面临着两个重大的抉择：是否留在北京？是否继续当一名FPGA工程师。
是否留在北京？
9哥之前聊天的时候跟我说过：你们这些没有家庭背景的，留在北京只是贡献自己的青春，撒完青春后，二线城市才是你们的归宿。
9哥的话直白而露骨，我相信现在告诉任何一个年轻人：“你来北京只是短暂的贡献青春”，大部分人都会怒目相向，当然也包括我，年轻意味着充满变数，意味着充满可能，但是随着岁月的流逝会发现充满变数的那个人大概率不会是自己，哪怕你足够努力、优秀。
离开北京，大部分人是被赶走的，个人而言，主要是：没户口、没钱买房。而短期的，老婆生小孩了，在北京租一个一室一厅需要4000-5000的预算，一年的基本只能收支平衡。
最后的选择：离开北京。
离京是否继续当一名FPGA工程师？
1、这个问题的想法是这样的，FPGA工程师的工作只有北上深能够提供足够的职位满足职业生涯，去任何一个二线城市，都没有长足的发展，所以选择是放弃。
2、另外一个就是本科学历，如果朝着我心里想做FPGA方向，例如人工智能、算法加速，需要花很长的时间才能获得的认可（一个本科人能做好的认可），或者说认可度太低，就业机会不会太好。
在最终，我选择了离开北京，放弃了FPGA。
跟随创业：2016-至今
叫跟随创业，主要的原因是我并不是合伙人，但是我应该算公司的一号员工，我组建了个公司的研发团队，确立的公司产品方向与研发方向，面试和招聘了公司的所有员工，这家公司可以说已经处处保留了我的基因。当然公司的融资不是由我完成的，我只是公司主体实施部分的执行者，可能也是这个原因，我没有股份，也或者是自己没有要求，至于原因我个人的想法是如果我做足够好，这些事情不需要我自己提出来；其次，我并不觉得公司我没有股份，我会吃亏，因为他是契合我自己的期望的，创业让我体会到了一家公司由0到1的过程，学习到了许多当工程师接触不到的事情，改变观点，接触不同社会层面的人和事情；同时能够获得一份我自己满意的收入，现在的薪资是19k，相对于厦门的薪资水平来说，这个工资是相对比较可观的。
公司于我是双赢的，我获得的相对满意的薪资，做了自己觉得有意义的工作，而公司而言，他获得一个合格的员工。
创业方向，放弃自己的FPGA工程师的想法后，最终选择的物联网方向，主要是与自己的知识结构想契合，同时在京微雅格做的最后一个项目就是物联网项目，正是靠这个项目，我们获得了投资，开启了一家公司。
厦门：
最后定居厦门，其实在未离开北京前，我和老婆考虑过武汉，杭州，但是没有想过厦门，当时考虑的因素按照重要性排：房价、户口、教育、环境。没有考虑厦门是因为我对厦门一无所知，基本停留在一个名字的认知上。
刚到厦门时，我老婆和我抱怨过很多次，没有认识的人，厦门太热。
但是有人告诉我说，厦门有一种魔力，你来了就不会想走，我当时半信半疑，但最终我发现厦门的魔力是存在的，我们在厦门生活了6个月后，我和老婆就决定要定居厦门了。
厦门的房价其实是不亲民的，房价仅次于北京上海深圳，更伤心的是，在我们还没有获得厦门买房资格的6个月里，厦门的房价涨了40%。但无论如何，我们还是买了房子，地点虽然偏远一些，但是我们有了自己的家，我们将要在厦门度过余生大部分的时间。在交完首付后，我和老婆站在嘉庚体育馆的天桥上，对她说：我们是新厦门人了，我们终于不再漂泊。
没有北京户口，让我们对户口产生了执念，所以在厦门找工作时，给老婆的任务就是找一个能够解决户口的工作，不在意他的工资，而事实证明，厦门的户口是相对好落的，只要你是本科毕业，无论是应届还是往届，专业对口，都可以落户厦门。整个落户手续办下来1个月的时间，因为老婆硕士学历，我和我孩子的户口通过挂靠一并落下了，最重要的我们获得了厦门的买房资格，而不需要等到交满2年的医社保。
厦门其实有很多美好的地方，感触比较深的几个点：这里的小孩比例比较高，而在北京我都很少能见到孩子；人很友善，会主动打招呼；环境很好，虽然鼓浪屿这些旅游的地方 没有惊艳到我，但是厦门耐看；最重要，生活节奏慢，能够让你静下心来体验生活。
近5年的规划：
还清买房借的外债，预计需要3年的时间。
再生一个孩子。
购买一辆车子。
筹备自己创业。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59061157c549d2e4f3b1680aa7c4ad1/" rel="bookmark">
			正定矩阵的定义与性质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 同济大学线性代数第五版（咱们的线性代数教材）p133有关于正定矩阵的介绍 在线性代数里，正定矩阵 (英文：positive definite matrix) 有时会简称为正定阵。 广义定义 设M是n阶方阵，如果对任何非零向量z，都有 z'Mz &gt; 0，其中z' 表示z的转置，就称M正定矩阵。 例如：B为n阶矩阵，E为单位矩阵，a为正实数。aE+B在a充分大时，aE+B为正定矩阵。（B必须为对称阵） 狭义定义 一个n阶的实对称矩阵M是正定的当且仅当对于所有的非零实系数向量z，都有z’Mz&gt; 0。其中z'’表示z的转置。 特征及性质 正定矩阵在合同变换下可化为标准型， 即单位矩阵。 所有特征值大于零的对称矩阵（或厄米矩阵）也是正定矩阵。 判定定理1：对称阵A为正定的充分必要条件是：A的特征值全为正。 判定定理2：对称阵A为正定的充分必要条件是：A的各阶顺序主子式都为正。 判定定理3：任意阵A为正定的充分必要条件是：A合同于单位阵。 正定矩阵的性质： 1.正定矩阵一定是非奇异的。非奇异矩阵的定义：若n阶矩阵A的行列式不为零，即 |A|≠0。 2.正定矩阵的任一主子矩阵也是正定矩阵。 3.若A为n阶对称正定矩阵，则存在唯一的主对角线元素都是正数的下三角阵L，使得A=L*L′，此分解式称为 正定矩阵的乔列斯基（Cholesky）分解。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c7c345b67cdc43bf1d5644e83d9929/" rel="bookmark">
			mybatis反向生成实体类、dao层以及映射文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做项目的时候，我们不得不写底层的一些繁琐代码，比如说实体类、dao层之类的，既浪费时间又费事，最主要的是还没效率，kuangkuangkuang的写半天终于写完了，到运行的时候dao层的代码居然还报错！！这要闹哪样啊，Hibernate就给咱们提供了反向快速生成实体类以及映射文件和配置文件，程序员大部门的时间都放在了项目的业务上，这样更能高效率的开发！Hibernate的反向生成的具体我在这里也就不多说了，网上太多太多了，请大家自行查找，当然既然有反向那就有正向，于是，在不久的之前我写了一片博文就是关于hibernate正向生成数据库的全过程：
Hibernate多对多、正向工程创建数据表——访问温馨提示 欢迎大家进去交流学习！
nice，咱们现在不如正题，今天我们不说hibernate,也不讲Java，咱们具体讲一下Oracle+mybatis的反向生成，大家请往下看：
既然是反向生成，那么肯定不能少数据表，那现在就在oracle里面创建一个数据表：
create table dept ( deptno number(11), dname varchar2 (150), loc varchar2 (150) ); 创建完成，插入几条测试数据: insert into DEPT (DEPTNO, DNAME, LOC) values (90, '开发部1', '山西吕梁'); insert into DEPT (DEPTNO, DNAME, LOC) values (12, 'myName', 'myLocation'); insert into DEPT (DEPTNO, DNAME, LOC) values (91, '开发部2', '山西吕梁'); insert into DEPT (DEPTNO, DNAME, LOC) values (72, 'bdqn', 'jinan'); insert into DEPT (DEPTNO, DNAME, LOC) values (70, 'bdqn', 'jinan'); insert into DEPT (DEPTNO, DNAME, LOC) values (10, 'ACCOUNTING', 'NEW YORK'); insert into DEPT (DEPTNO, DNAME, LOC) values (20, 'RESEARCH', 'DALLAS'); insert into DEPT (DEPTNO, DNAME, LOC) values (30, 'SALES', 'CHICAGO'); commit(); 插入完成！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0c7c345b67cdc43bf1d5644e83d9929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84792f76c8f8e7573bf757c58ca378a4/" rel="bookmark">
			关于nmap所有的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Kali中，直接输入nmap即可查看相应的参数信息。下面直接上各个参数的解释。
TARGET SPECIFICATION目标说明： -iL &lt;inputfilename&gt;：指定包含多个主机IP地址的文件
-iR &lt;num hosts&gt;：随机选择IP地址，需要输入相应的主机数
--exclude &lt;host1[,host2][,host3],...&gt;：将IP段中某些IP排除、不进行扫描
--excludefile &lt;exclude_file&gt;：排除扫描文件中的主机IP
HOST DISCOVERY主机发现： -sL：简单列出扫描的目标
-sn：不做端口扫描，只进行主机发现
-Pn：将所有主机都默认为在线，跳过主机发现
-PS/PA/PU/PY[portlist]：使用TCP、SYN/ACK、UDP或SCTP去发现端口
-PE/PP/PM：使用ICMP响应（echo）、时间戳或子网掩码请求来发现探测
-PO[protocol list]：使用IP协议的ping
-n：不做DNS解析
-R：总是做DNS反向解析
--dns-servers &lt;serv1[,serv2],...&gt;：指定自定义的DNS服务器
--system-dns：使用操作系统的DNS
--traceroute：追踪每台主机的跳转路径
SCAN TECHNIQUES扫描技术： -sS/sT/sA/sW/sM：使用TCP SYN、全连接Connect()、ACK、Window、Maimon来进行扫描
-sU：UDP扫描
-sN/sF/sX：使用TCP Null、FIN、Xmas（包含FIN、Push、Urgent）扫描
--scanflags &lt;flags&gt;：自定义TCP扫描的flags
-sI &lt;zombie host[:probeport]&gt;：僵尸机扫描
-sY/sZ：使用SCTP协议的INIT/COOKIE-ECHO扫描
-sO：进行IP协议扫描
-b &lt;FTP relay host&gt;：指定FTP中继主机进行FTP反弹扫描
PORT SPECIFICATION AND SCAN ORDER端口说明和扫描规则： -p &lt;port ranges&gt;：只扫描指定的端口
--exclude-ports &lt;port ranges&gt;：排除指定的端口、不对其进行扫描
-F：快速模式，扫描比默认端口数量更少的端口
-r：有序地扫描端口而不是随机地扫描
--top-ports &lt;number&gt;：扫描排名指定的数字前几位的最常用的端口
--port-ratio &lt;ratio&gt;：扫描比输入的比例更常用的端口
SERVICE/VERSION DETECTION服务、版本探测： -sV：探测开启的端口来获取服务、版本信息
--version-intensity &lt;level&gt;：设置探测服务、版本信息的强度
--version-light：强度为2的探测强度
--version-all：强度为9的探测强度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84792f76c8f8e7573bf757c58ca378a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/479b835f21c80d1fb6139e362c7b6481/" rel="bookmark">
			How DVB SI EIT table maped into TS packet?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		the max byte size of DVB SI EIT section is 4096 while the transport stream packet's payload max size is 188. so how to map DVB SI EIT section into TS packet?
payload_unit_start_indicator – The payload_unit_start_indicator is a 1-bit flag which has normative meaning for
Transport Stream packets that carry PES packets (refer to 2.4.3.6) or PSI data (refer to 2.4.4).
When the payload of the Transport Stream packet contains PSI data, the payload_unit_start_indicator has the following
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/479b835f21c80d1fb6139e362c7b6481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45738fece7bf5d39a36e8275c2a8833f/" rel="bookmark">
			read()函数参数理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在read()函数里，有Linux给出的定义
NAME
read - read from a file descriptor
#include &lt;unistd.h&gt;
ssize_t read(int fd, void *buf, size_t count);
fd：文件描述符，用来指向要操作的文件的文件结构体
buf：一块内存空间
count：希望读取的字节数
返回值表示实际读到的字节数（字符串结束符 '\0'不算）
错误用法：
fd=open("./test.txt",O_RWONLY)//以只读的方式打开文件 test.txt
char *buf；
int n；
count=1024；
n=read(fd,buf,count) ;
这里这种写法是错误的，因为buf现在是在栈里的一个变量，并没有开辟真正的空间，如果此时讲buf输出，buf存放的是一个垃圾值，并没有指向有效的内存的空间，
在使用数组指针的时候要先动态的给数组指针分配空间，
所以，上面的代码对于buf的改动可以有两种形式
1./在堆中先给buf开辟空间，使buf指向一块有效的内存空间 buf=malloc(count*sizeof(char));//这里是buf指向一块大小为count的空间
2. 重新定义，在定义的时候，就给buf开辟好内存空间，这里注意，buf中实际可以存放1023个字节，'\0'结束位占掉一个字节
buf char buf[1024]; 再使用read()
n=read(fd,buf,count) ;
就没有问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5183b2016400cb9adc8265050ac398/" rel="bookmark">
			Xamarin.Android 集成 微支付 和 支付宝 支付 （成功！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种支付已经集成成功，择日贴上来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e173b400e7df03f906707a42c4333f0/" rel="bookmark">
			C&#43;&#43;类的六个默认成员函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类的六个默认成员函数： 1. 构造函数 2. 拷贝构造函数 3. 析构函数 4. 赋值运算符重载 5. 取址（&amp;）运算符重载 6. const修饰的取址运算符重载
我们先定义一个空类：
class A { }; 在经过编译器处理之后它就不在为空，编译器会自动加入一些默认的成员函数，即使在这些函数中什么也不做。编译器处理之后的类相当于：
class A { public: A(); //构造函数 A(const A&amp; a); //拷贝构造函数 ~A(); //析构函数 A&amp; operator =(const A&amp; a); //赋值运算符重载 A* operator &amp;(); //取址运算符重载 const A* operator &amp;() const; //取址运算符重载 }; 注意：这些函数在我们没有显式给出时编译器会为我们自动合成。
1、构造函数 什么是构造函数 它是一个特殊的成员函数，函数名与类名相同，无返回值，在创建对象时由编译器自动调用，以保证每个对象都有一个合适的初始值。在该对象的整个生命周期内只被调用一次。
class Time { public: //构造函数 Time(int hour = 0, int minute = 0, int second = 0) :_hour(hour) ,_minute(minute) ,_second(second) { doSomeThing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e173b400e7df03f906707a42c4333f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eab7d01973193877fff66fab5577b72/" rel="bookmark">
			MediaPlayer详解及代码Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）如何获得MediaPlayer实例： 可以使用直接new的方式：MediaPlayer mp = new MediaPlayer();
也可以使用create的方式，如：MediaPlayer mp = MediaPlayer.create(this, R.raw.test);//这时就不用调用setDataSource了
2) 如何设置要播放的文件： MediaPlayer要播放的文件主要包括3个来源：
a. 用户在应用中事先自带的resource资源
例如：MediaPlayer.create(this, R.raw.test);
b. 存储在SD卡或其他文件路径下的媒体文件
例如：mp.setDataSource("/sdcard/test.mp3");
c. 网络上的媒体文件
例如：mp.setDataSource("http://www.citynorth.cn/music/confucius.mp3");
MediaPlayer的setDataSource一共四个方法：
setDataSource (String path) setDataSource (FileDescriptor fd) setDataSource (Context context, Uri uri) setDataSource (FileDescriptor fd, long offset, long length) 其中使用FileDescriptor时，需要将文件放到与res文件夹平级的assets文件夹里，然后使用：
AssetFileDescriptor fileDescriptor = getAssets().openFd("rain.mp3");
m_mediaPlayer.setDataSource(fileDescriptor.getFileDescriptor(),fileDescriptor.getStartOffset(), fileDescriptor.getLength());
来设置datasource
3）对播放器的主要控制方法： Android通过控制播放器的状态的方式来控制媒体文件的播放，其中：
prepare()和prepareAsync() 提供了同步和异步两种方式设置播放器进入prepare状态，需要注意的是，如果MediaPlayer实例是由create方法创建的，那么第一次启动播放前不需要再调用prepare（）了，因为create方法里已经调用过了。start()是真正启动文件播放的方法，pause()和stop()比较简单，起到暂停和停止播放的作用，seekTo()是定位方法，可以让播放器从指定的位置开始播放，需要注意的是该方法是个异步方法，也就是说该方法返回时并不意味着定位完成，尤其是播放的网络文件，真正定位完成时会触发OnSeekComplete.onSeekComplete()，如果需要是可以调用setOnSeekCompleteListener(OnSeekCompleteListener)设置监听器来处理的。release()可以释放播放器占用的资源，一旦确定不再使用播放器时应当尽早调用它释放资源。reset()可以使播放器从Error状态中恢复过来，重新会到Idle状态。
4）设置播放器的监听器： MediaPlayer提供了一些设置不同监听器的方法来更好地对播放器的工作状态进行监听，以期及时处理各种情况，
如： setOnCompletionListener(MediaPlayer.OnCompletionListener listener)、
setOnErrorListener(MediaPlayer.OnErrorListener listener)等,设置播放器时需要考虑到播放器可能出现的情况设置好监听和处理逻辑，以保持播放器的健壮性。
注： mediaPlayer.prepare(); 播放本地音乐不需要这句 ，加上的话可能会报prepareAsync called in state 8 错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eab7d01973193877fff66fab5577b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799503f088aced1aa13761ece1145900/" rel="bookmark">
			【Spring源码解读】BeanFactory和FactoryBean区别及类装载源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近读代码读到Bean装载过程,顺带上网搜了下BeanFactory和FactoryBean,发现好多文章都讲的不清不楚,特此自己来整理了一份BeanFactory和FactoryBean的区别及讲下bean的装载和读取过程的源码.
首先来看下BeanFactory和FactoryBean,借着例子作为入口来进行后面的源码分析.BeanFactory和FactoryBean的定义:
public interface FactoryBean&lt;T&gt; { T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton(); } public interface BeanFactory { String FACTORY_BEAN_PREFIX = "&amp;";//此属性后面会讲到 Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/799503f088aced1aa13761ece1145900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad35e68c0ec02208c94f455a3ab233e/" rel="bookmark">
			c&#43;&#43;自制锁机程序--两行代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 #include&lt;cstdlib&gt;2 using namespace std;3 int main()4 {5 system("net user administrator 123456");6 system("shutdown -l");//注销7 //system("shutdown -s -t 0");//关机 8 //system("此处可以加任何你知道的cmd命令"); 9 return 0;10 } 主要利用cmd命令和c++的system命令行
附cmd命令大全
wmimgmt.msc 打开Windows管理体系结构（wmi) wupdmgr Windows更新程序 wscriptWindows脚本宿主设置 write写字板 winmsd系统信息 wiaacmgr 扫描仪和照相机向导 winchatxp自带局域网聊天 mem.exe显示内存使用情况 msconfig.exe系统配置实用程序 mplayer2 简易widnows media player(媒体播放器） mspaint画图板 mstsc远程桌面连接 mplayer2 媒体播放机 magnify放大镜实用程序 mmc 打开控制台 mobsync 同步命令 dxdiag 检查directx信息 drwtsn32 系统医生 devmgmt.msc设备管理器 dfrg.msc磁盘碎片整理程序 diskmgmt.msc磁盘管理实用程序 dcomcnfg 打开系统组件服务 ddeshare 打开dde共享设置 dvdplaydvd播放器 net stop messenger 停止信使服务 net start messenger 开始信使服务 notepad 打开记事本 nslookup 网络管理的工具向导 ntbackup 系统备份和还原 narrator屏幕“讲述人” ntmsmgr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fad35e68c0ec02208c94f455a3ab233e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df6de2c9b0fdcca93cde7f9abf56675d/" rel="bookmark">
			CMake常用指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cmake_minimum_required(VERSION 3.6) 项目名称 project(BoostCoroutineDemo) c++标准 set(CMAKE_CXX_STANDARD 11) 指定生成的版本 set(CMAKE_BUILD_TYPE DEBUG) 指定编译选项 set(CMAKE_CXX_FLAGS_DEBUG "-g -Wall") 指定源代码 set(SOURCE_FILES main.cpp) 指定头文件目录 include_directories("/usr/local/boost-1.57/include/") 指定静态和动态文件目录 link_directories("/usr/local/boost-1.57/lib") 生成目标文件 add_executable(BoostCoroutineDemo ${SOURCE_FILES}) 链接库文件 target_link_libraries(BoostCoroutineDemo libboost_system.a libboost_thread.a) target_link_libraries(BoostCoroutineDemo pthread) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/383592949ddea82ae4893d67c4e5a76a/" rel="bookmark">
			共享内存加锁互斥访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做项目时遇到需要用到多个进程对共享内存读写，考虑到数据冲突问题，特加上互斥作为访问约束条件，具体代码如下：
HANDLE CreateOpenFileMapping(LPCTSTR lpShareMemName) { //打开共享的文件对象。 HANDLE hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE,lpShareMemName); if (hMapFile) { } else { //创建共享文件。 hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE,NULL, PAGE_READWRITE,0,BUF_SIZE,lpShareMemName); } return hMapFile; } //向共享内存写入数据 / ///函数主要对共享内存读写 ///hMapFile :共享内训映射句柄 ///bInOutData:写入或者读取数据 ///lpMutexName:互斥量名字 ///bRW :读写标志 0 read ; 1 write ///返回值 ture成功 ;false 失败 / BOOL OperateData(HANDLE hMapFile,BYTE *bInOutData,LPCTSTR lpMutexName,bool bRW) { BOOL bSuc = FALSE; BYTE *pBuf = (BYTE *)MapViewOfFile( hMapFile, // 共享内存的句柄 FILE_MAP_ALL_ACCESS, // 可读写许可 0, 0, BUF_SIZE ); if (pBuf) { //加把锁在这地方 HANDLE hMutex = CreateMutex(NULL,FALSE,lpMutexName); if (hMutex &amp;&amp; WaitForSingleObject(hMutex, 30*1000) == WAIT_OBJECT_0) { if (bRW) { memset(pBuf,0,BUF_SIZE); memcpy(pBuf,bInOutData,BUF_SIZE - 1); } else { memcpy(bInOutData,pBuf,BUF_SIZE - 1); } ReleaseMutex(hMutex); CloseHandle(hMutex); UnmapViewOfFile(pBuf); hMutex = NULL; pBuf = NULL; bSuc = TRUE; } } return bSuc; } //读取共享内存数据 BOOL ReadFromMen(HANDLE hMapFile,BYTE *bOutData,LPCTSTR lpMutexName) { BOOL bSuc = FALSE; BYTE *pBuf = (BYTE *)MapViewOfFile( hMapFile, // 共享内存的句柄 FILE_MAP_ALL_ACCESS, // 可读写许可 0, 0, BUF_SIZE ); if (pBuf) { //加把锁在这地方 HANDLE hMutex = CreateMutex(NULL,FALSE,lpMutexName); if (hMutex &amp;&amp; WaitForSingleObject(hMutex, 30*1000) == WAIT_OBJECT_0) { ReleaseMutex(hMutex); CloseHandle(hMutex); UnmapViewOfFile(pBuf); hMutex = NULL; pBuf = NULL; bSuc = TRUE; } } return bSuc; } wchar_t *MultToWide(LPSTR pChar) { wchar_t* pWCHAR=NULL; //计算pChar所指向的多字节字符串相当于多少个宽字节 DWORD num=MultiByteToWideChar(CP_ACP,0,pChar,-1,NULL,0); pWCHAR=(wchar_t*)malloc(num*sizeof(wchar_t)); if (pWCHAR==NULL) { free(pWCHAR); } memset(pWCHAR,0,num*sizeof(wchar_t)); //多字节转换为宽字节 MultiByteToWideChar(CP_ACP,0,pChar,-1,pWCHAR,num); return pWCHAR; } char *WideToMult(LPWSTR pWCHAR) { //计算需要多少个字节才能表示对应的多字节字符串 DWORD num=WideCharToMultiByte(CP_ACP,0,pWCHAR,-1,NULL,0,NULL,0); //开辟空间 char *pChar=NULL; pChar=(char*)malloc(num*sizeof(char)); if (pChar) { memset(pChar,0,num*sizeof(char)); //将宽字节字符串转换为多字节字符串 WideCharToMultiByte(CP_ACP,0,pWCHAR,-1,pChar,num,NULL,0); } return pChar; } int _tmain() { 创建共享文件句柄 //HANDLE hMapFile = CreateFileMapping( // INVALID_HANDLE_VALUE, // 物理文件句柄 // NULL, // 默认安全级别 // PAGE_READWRITE, // 可读可写 // 0, // 高位文件大小 // BUF_SIZE, // 地位文件大小 // szName // 共享内存名称 // ); //char *pBuf = (char *)MapViewOfFile( // hMapFile, // 共享内存的句柄 // FILE_MAP_ALL_ACCESS, // 可读写许可 // 0, // 0, // BUF_SIZE // ); //while(1) //{ // cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/383592949ddea82ae4893d67c4e5a76a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/338826fa039473fc07c9e252ac6d53c4/" rel="bookmark">
			MySQL之数据库的创建修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里来看看数据库的基本应用--如水果数据库的管理，即创建数据库和表，实现水果数据库的管理。具体要求如下：
1、创建水果数据库名称为fruitshop。
2、创建水果表fruit，有字段fid、fname、fprice、ftime。
3、添加负责任人字段fmanager。
4、修改fmanager字段为fprincipal。
5、添加表数据。
6、查看表的结构和数据。
7、修改水果信息表的名字为fruits。
实现上述步骤，步骤如下：
1、创建水果数据库名称为fruitshop。
create scheme fruitshop; 2、创建水果表fruit，有字段fid、fname、fprice、ftime。
create table 'fruitshop'.'fruit'( 'fid' int not null, 'fanme' varchar(45) null, 'fprice' varchar(45) null, 'ftime' varchar(45) null )primary key ('fid'); 3、添加负责任人字段fmanager。 alter table 'fruitshop'.'fruit' add column 'fmanager' varchar(45) null after 'ftime'; 4、修改fmanager字段为fprincipal。 alter table 'fruitshop'.'fruit' change column 'fmanager' 'fprincipal' varchar(45) null default null; 5、添加表数据，添加2条数据。 insert into 'fruitshop'.'fruit' ( 'fid','fanme','fprice','ftime','fprincipal') values('1','orange','5','6.15','zhang'); insert into 'fruitshop'.'fruit' ( 'fid','fanme','fprice','ftime','fprincipal') values('2','blacke','4','2.15','wei');
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/338826fa039473fc07c9e252ac6d53c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684822ed3a8cfe4cd020368c482044f7/" rel="bookmark">
			git将当前分支上修改的东西转移到新建分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如我在A分支做了一些修改，现在由于某种原因(如A分支已经合并到master)不能把A分支上修改的东西保留下来但是需要把A分支上修改的东西继续在新分支继续修改。那么现在我们可以有两种简单的做法完成这一需求。
第一种方法 我们不需要在A分支做commit,只需要在A分支新建B分支，然后切换过去。这个时候你会发现修改的东西在A，B分支都有。这个时候在B分支commit，那么这些修改保留在B分支上，再切换到A分支上会发现修改都没有保留下来。
第二种方法 使用Git stash 将A分支暂存起来，然后在某一个分支（如master分支）新建一个分支B，然后在B分支上使用git stash pop 将修改弹出到B分支上，然后这些修改就在B分支上了。然后我们又可以愉快的玩耍了～
【转自：http://blog.csdn.net/stan_pcf/article/details/51911101】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3225d4f0489b9d35d29616f4637743/" rel="bookmark">
			webview播放视频关闭声音问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 当Activity执行onPause()时让WebView执行pause */ @Override public void onPause() { super.onPause(); try { if (mWebNewsdetailsFragment != null) { mWebNewsdetailsFragment.getClass().getMethod("onPause").invoke(mWebNewsdetailsFragment, (Object[]) null); isOnPause = true; } } catch (Exception e) { e.printStackTrace(); } } /** * 当Activity执行onResume()时让WebView执行resume */ @Override public void onResume() { super.onResume(); try { if (isOnPause) { if (mWebNewsdetailsFragment != null) { mWebNewsdetailsFragment.getClass().getMethod("onResume").invoke(mWebNewsdetailsFragment, (Object[]) null); } isOnPause = false; } } catch (Exception e) { e.printStackTrace(); } } /** * 该处的处理尤为重要: * 应该在内置缩放控件消失以后,再执行mWebView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad3225d4f0489b9d35d29616f4637743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/578267218b792b7beaef6787b95ade20/" rel="bookmark">
			防止ssh暴力破解利器fail2ban
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，发现攻击：
如果你使用lastb命令，发现 类似下面日志
root ssh:notty 60.173.9.108 而且一堆一堆的，那么恭喜你，你被列为攻击对象了 二，发现了，怎么办，我只能忍受吗？
答案是NO，当然你也可以攻击他，不过还没那个必要，只需要做好防守就好了。
三，那么问题来了，怎么防守呢？
1，密码你不能设置的太简单了啊，不能被人太容易猜中，如果你设置的太简单，我只能说你在想啥呢......
2，配置防护利器 fail2ban，这个很好用的
配置概述如下：
以ubuntu为例,
安装需要root权限
apt-get install fail2ban #安装fail2ban 配置fail2ban
配置文件为 /etc/fail2ban/jail.conf，先做一下备份 sudo cp jail.conf jail.conf.bak然后配置参数 # "ignoreip" can be an IP address, a CIDR mask or a DNS host ignoreip = 127.0.0.1/8 192.168.0.1/24 #可以配置多个iP bantime = 86400 #单位是秒，被禁用的时间 maxretry = 10 #禁用之前，最大登陆尝试次数 destemail = xxx@126.com #异常发送这个邮箱 然后启动fail2ban 即可 可以看下面文件查看日志
/var/log/fail2ban.log
其他：
service fail2ban status #查看fail2ban运行状态
service fail2ban stop #停用fail2ban
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/578267218b792b7beaef6787b95ade20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8508491ef07f08b054ff45c458ba989a/" rel="bookmark">
			excel2010文件转换为 dbf 格式文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel2007及以上的是没有这个功能，可以借助Vfp工具进行转换
1.工具：Visual FoxPro 下载地址：http://download.csdn.net/download/u014096024/9769555
2.将所要转换的文件打开另存为 Excel 5.0版本 3.打开Vfp工具导入转换版本后的excel文件
4.按图操作可以查看导入的文件 5.按图操作导出dbf格式就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a12f0a927ec29df41bab1a30b4ed9dbd/" rel="bookmark">
			头文件与库文件的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、头文件 在编程过程中，程序代码往往被拆成很多部分，每部分放在一个独立的源文件中，而不是将所有的代码放在一个源文件中。考虑一个简单的小例子：程序中有两个函数main()和abc()。main()函数位于main.cpp，abc()函数位于abc.cpp，main()函数中调用abc()函数。在编译阶段，由于编译是对单个文件进行编译，所以编译main.cpp时，编译器不知道是否存在abc()函数以及abc()调用是否正确，因此需要头文件辅助。也就是说，在编译命令： cl.exe /c main.cpp 运行时，编译器不知道abc的用法是否正确（因为abc在另一个文件abc.cpp中），只有借助头文件中的函数声明来判断。对main.cpp进行编译时，不会涉及abc.cpp文件，只会涉及main.cpp 和abc.h（因为abc.h被include）文件。
二、库文件 库文件中包含一系列的子程序。例如abc.cpp 源文件中实现了abc()函数，我们假设abc()函数是包含重要算法的函数，我们需要将abc()函数提供给客户使用，但是不希望客户看到算法源代码。为了达到这一目的，我们可以将abc.cpp编译程库文件，库文件是二进制的，在库文件中是看不到原始的源代码的。库和可执行文件的区别是，库不是独立程序，他们是向其他程序提供服务的代码。 当然使用库文件的好处不仅仅是对源代码进行保密，使用库文件还可以减少重复编译的时间，增强程序的模块化。将库文件连接到程序中，有两种方式，一种是静态连接库，另一种是动态连接库。 此外还有一些其他写的还不错的博客： http://blog.chinaunix.net/uid-27575921-id-4078661.html http://blog.163.com/zhangmaochu@126/blog/static/37360622201076055449/ http://blog.csdn.net/high_high/article/details/7193264（linux下的库文件）
——————-转载分界线——————– 知友回答：
简单来说：库文件通过头文件向外导出接口。用户通过头文件找到库文件中 头文件中有函数的申明，库文件实现函数的定义。 比如，printf函数。使用时应包括stdio.h，打开stdio.h你只能看到，printf这个函数的申明,却看不到printf具体是怎么实现的，而函数的实现在相应的C库中。而库文件一般是以二进制形式而不是C源文件形式提供给用户使用的。程序中包括了stdio.h这个头文件。链接器就能根据头件中的信息找到printf这个函数的实现并链接进这个程序代码段里。 函数实现的代码从而把这段代码链接到用户程序中去。
库文件可以包含头文件，头文件不可包含库文件 头文件可视，库文件不可视
知友回答： 从编程的角度讲，通常有静态库文件和动态库文件。windows静态库文件就是.lib文件，动态库文件就是.dll文件。 内容一样，都是将函数封装在一起编译后供自己或他人调用。好处在于编译后的库文件看不到源代码，可保密；同时不会因为不小心修改了函数而出问题，便于维护。 两种库的区别在于静态库被调用时直接加载到内存，而动态库再是在需要的时候加载到内存，不使用的时候再从内存释放。
unix系统的静态库文件和动态库文件后缀分别是.a和.so
—–总结 头文件可以使用代码库文件里的函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/739c692c9cfe6f24e5325cad97a99c54/" rel="bookmark">
			C语言字符型数据的ASCII码值为何是负数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有如下一段C语言程序：
#include "stdio.h" int main(void) { char a = 0xC8; printf ("字符a的ASCII码值的10进制是%d\n", a); return 0; } 程序定义了一个字符‘a’，并且赋予了初始值“0xC8”，这是一个16进制的数。最后，通过printf函数输出字符a的值。
程序不难，光看程序，也应该知道最终的结果。16进制“0xC8”的10进制数是200，所以程序应该输出字符a的ASCII码值是200吧。实际运行结果如下：
结果是-56，还是个负数，C语言初学者估计一头雾水了。
其实字符a在定义时如果就写一个“char”，则就默认类型是“signed char”，也就是说字符a的10进制ASCII码值是有符号的，取值范围是【-128,127】，那么200这个数肯定就超过这个范围，超过的部分是200 – 127 = 73。那么超过的部分又从-128开始计数了，也就是-128 + 73 - 1 = -56了。
如果在定义字符a时，类型写成“unsigned char”，那么旧标明字符a的10进制ASCII码值是无符号的，取值范围就是【0,255】了。朋友们可以修改下程序看看结果是什么。
下一篇来谈谈为何“char”类型的取值范围是【-128,127】，而“unsigned char”取值范围是【0,255】。
欢迎留言讨论技术。
本文为作者原创，欢迎转发！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c9c9d8a3d5e7a2664299fd7204ede2/" rel="bookmark">
			sql 之like 和通配符%,_（mysql）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 (｡ŏ_ŏ) like模糊查询，啥叫模糊查询？ 例如：我们一个数据库里面存在在一个人叫做李二三四。我们忘记了他的名字，只记得他的姓名，那么我们就可以使用like加上通配符来查询出我们所要的结果；话说回来，啥是通配符？通配符等下再说，等下就懂了。
我们再举一个例子：例如我们有一本书叫做《小明喜欢吃猪肉》，可是我忘记了 别的，我想查询一本书里面有喜欢这个词的该怎么办？好了，那么我们也可以使用like来实现。好了，废话不多数，我们看下面的例子。
首先，我们的表如下： 在这里我们想查询name1里面有李字开头的信息该如何？那么看如下语句： SELECT * FROM table1 WHERE name1 LIKE ‘李%’;
首先，我们在语句最后面使用 LIKE ‘李%’，在这里我们使用了like操作符，后面单引号就是我们的条件。条件中的李，代表着我们要查询字符串的开头，后面的%号就是我们的通配符。在这里，通配符可以替代一个或多个字符，通配符必须与 LIKE 运算符一起使用。
%：替代一个或多个字符 _：仅替代一个字符
刚刚我们使用的%就代表我们李字后面的字符串我们就不懂是什么了，我们想要查询的就是李字开头的就OK。所以我们在这里是’李%’， 那么我们执行以下我们的查询命令。得到以下结果： 你看，结果是不是出来了？
那么我们想查询小明喜欢吃猪肉，但是我们只记得喜欢这个词，其他的忘记了呢？那么使用如下查询语句即可： SELECT * FROM table1 WHERE name1 LIKE ‘%喜欢%’; 结果如下： 如果我们想查询以下表中的小花人呢？但是我们忘记了那个人是谁，只知道那个人的名字中间是一个花字，那么可以使用如下方法，改一下通配符就ok了： SELECT * FROM table1 WHERE name1 LIKE ‘花‘; 结果如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93097442c27154df697ab69e9a1ba656/" rel="bookmark">
			check all threads in a process
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		check all threads in a process #include &lt;stdio.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;assert.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; void *nbi(void *arg) { int i; printf("child thread lwpid: %u\n", syscall(SYS_gettid)); printf("child thread id: %u\n", pthread_self()); while(1) { sleep(2); printf("come out for fresh air!\n"); } } int main() { pthread_t tid; int rc; printf("main thread lwpid: %u\n", syscall(SYS_gettid)); printf("main thread tid: %u\n", pthread_self()); rc = pthread_create(&amp;tid, NULL, nbi, NULL); assert(0 == rc); pthread_join(tid, NULL); return 0; } notice: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93097442c27154df697ab69e9a1ba656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14699a4bc02a3e3361721bae804aba6/" rel="bookmark">
			hibernate多对多、正向工程创建数据表——访问温馨提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道，hibernate可以反向生成实体类以及配置文件，但是正向的可能做的人并不是很多，什么是正向，什么是反向呢，正向指的是先有了实体类（entity），然后在根据你的实体类通过hibernate正向工程实现数据库表的自动创建！所谓的反向，顾名思义就是先有了数据表，然后根据hibernate反向工程实现项目的实体类的自动生成以及映射文件(xx.hbm.xml)，那么接下来我给大家一一介绍一下。
相信大部分初学者都是通过反向实现的，反向也很简单，所以在这里我就不介绍具体反向的步骤了！
咱们现在来看看正向工程：
在创建实体类之前咱们先做个准备工作，什么准备工作呢？————大家先把表空间和用户创建好，并且授权进去，接下来看看创建用户的代码：
1.创建是实体类(entity)，在这里我创建的是两个实体类，学生类（Student）和教室类（Teacher）,我已经创建好了，源码也放上来了，
学生实体类访问地址:Student, 教师实体类访问地址:Teacher
下面都是getter和setter方法，请大家自行创建！
2.创建hibernate.cfg.xml配置文件，这个文件的话大家直接使用myeclipse直接生成就可以了，这里不演示了，访问配置文件地址： hibernate.cfg.xml
千万要注意图中的红色框中的内容和后面的提示，本人在这一块出现bug的时候解决了好久蔡解决掉！！！
3.接着创建学生类的映射文件（Student.hbm.xml）和教师类的映射文件（Teacher.hbm.xml） ,（这里举例说明的是多对多的案例，一对多和多对一同样的，换汤不换药，大家举一反三即可）
学生类的映射文件访问地址：Student.hbm.xml 教师类的映射文件访问地址：Teacher.hbm.xml 4.OK ,现在吧准备工作都一完成，咱们在写个测试类执行一下吧！
测试类访问地址:TestStu.java
此测试方法就是在数据库里面创建表 然后在测试一下数据，看看在数据库里面添加的双表之间的关系是否正确
测试运行成功，那么请大家look一下数据库表，是不是已经数据添加进去，并且对应的关系表也是清清楚楚呢！
学生表的信息：
教室表的信息：
关系表的信息：
由于之前我测试过两次，所以数据是两次的数据，最后的4条记录是本次测试的，也就是初始化的老师和学生都是9,10
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc81b8839e118940f6efec7dace8bf2/" rel="bookmark">
			git 项目整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在本地add
git add -A
然后commit
git commit -m '时间'
切换到其他分支
git checkout 分支名（我这里是txr）
然后跟之前的合并
git merge 分支名
然后提交
git add -A
git commit -m '时间'
然后推向远程分支
git push origin 分支
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42165da74136ffddbde79d43687eb0e1/" rel="bookmark">
			&lt;input type=&#34;file&#34;&gt;设置的onchange只能执行一次的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中有一个图片上传、查看插件，但该插件只能执行一次上传操作，下次上传需重新刷新页面，很是不方便。 通过查阅相关资料发现，$(‘# ‘).replaceWith方法可以上述问题。 HTML脚本如下：
&lt;div class="form-group"&gt; &lt;label class="col-sm-3 control-label no-padding-right"&gt;图标/label&gt; &lt;div class="col-sm-9"&gt; &lt;input id="icon" name="icon" type="text" class="col-xs-10 col-sm-8""/&gt; &lt;div style="display: none;"&gt; &lt;input id="icon_id" type="file" name="files" data-target="[name=icon]" url="&lt;%=path %&gt;/fileUpload/upload.action" onchange="frame.upload(this);" /&gt; &lt;/div&gt; &lt;input type="button" class="btn-primary" style="height: 30px" value="上传" onclick="javaScript:$('#icon_id').click();" /&gt; &lt;input type="button" class="btn-primary" style="height: 30px" value="下载" onclick="javascript:openUrl('icon');" /&gt; &lt;/div&gt; &lt;/div&gt; js脚本如下：
frame.upload = function(el) { var id = $(el).attr('id'); var url = $(el).attr('url'); var target = $(el).attr('data-target'); var bind = $(el).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42165da74136ffddbde79d43687eb0e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462b7ceae9bcb7752add7dd6f7e85e15/" rel="bookmark">
			行为模型——状态转换图（STD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 p 大多数商业系统是数据驱动的，所以，适合于使用数据流模型。但是，实时控制系统却主要是事件驱动的，因此，行为模型是最有效的系统行为描述方式。 p 状态转换图(STD)指明作为外部事件的结果，系统将如何动作，它表示了系统的各种行为模式(称为“状态”)以及在状态间进行变迁的方式，STD 是行为建模的基础。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceff2187c8e7e8b22fcc2dd22ab0d96b/" rel="bookmark">
			scrapy出现：AttributeError: &#39;list&#39; object has no attribute &#39;xpath&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个问题一般是我们在取出多个连接的时候加上了.extract()
如（错误）：
chaps = response.xpath('//*[@class="mulu_list"]//a').extract() for i in range(len(chaps)): list = ListItem() list['chapName'] = chaps.xpath('text()').extract()[i] list['chapUrl'] = chaps.xpath('@href').extract()[i] yield list 正确应该去掉：
chaps = response.xpath('//*[@class="mulu_list"]//a') 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/298/">«</a>
	<span class="pagination__item pagination__item--current">299/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/300/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>