<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6978c4d59a3555e21b2a0fb8ab5ddd36/" rel="bookmark">
			flutter Android编译打包全过程解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 settings.gradle根目录build.gradleapp/build.gradleFlutterPlugin 本篇主要讲解一个flutter工程是如何编译打包成一个apk的。
注意：这里我们是一个空的flutter项目，然后引入了一个webview-flutter的plugin来模拟一个plugin是如何一起打进去的。
flutter版本：2.4.0-5.0.pre.145
settings.gradle 因为最终产物是apk，所以其实总体上走的还是安卓编译，所以我们先来看settings.gradle文件：
这里我们可以看到，先读取了本地local.properties文件，里面包含了flutter sdk安装目录和android sdk安装目录等。根据flutter sdk安装目录，来到目录下的app_plugin_loader.gradle文件。
这里我们可以看到针对flutter-plugins-dependencies文件进行json解析，我们可以看下flutter-plugins-dependencies文件里的内容，包括了项目中各个平台引入的包的情况，我们项目中只引入了webview_flutter plugin。
ok，读取到了以后进行json解析，然后进行include和project对应处理，经过这一步以后settings.gradle就变成了
include ":webview_flutter" project(":webview_flutter").projectDir = new File("xxxxxxx")//上面对应的path 没错，这么看的话其实变成了普通的一个android项目的settings.gradle结构了。
根目录build.gradle ok打包的话接下来我们来看build.gradle文件，先来看根目录下的build.gradle文件。
这里我们可以看到指定build产物目录为flutter项目目录的build文件下，以及build下的app目录下。以及首先我们会运行app依赖。ok接下去我们再来看app下的build.gradle文件。
app/build.gradle 首先读取了loacl.properties文件，读取了flutter sdk相关的参数以后，加载了flutter.gradle文件。我们来看看这个flutter sdk里的flutter.gradle文件具体做了些啥。
这里我们看到又apply了一个自定义的plugin FlutterPlugin，ok我就来看这个FlutterPlugin都做了些啥。
FlutterPlugin class FlutterPlugin implements Plugin&lt;Project&gt; { //省略部分代码，主要是声明了一些变量和环境参数。 //具体实现 @Override void apply(Project project) { this.project = project def rootProject = project.rootProject rootProject.tasks.register('generateLockfiles') { rootProject.subprojects.each { subproject -&gt; def gradlew = (OperatingSystem.current().isWindows()) ? "${rootProject.projectDir}/gradlew.bat" : "${rootProject.projectDir}/gradlew" rootProject.exec { workingDir rootProject.projectDir executable gradlew args "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6978c4d59a3555e21b2a0fb8ab5ddd36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f7d7406aa9ad3ccae09c091b30fab24/" rel="bookmark">
			AD绘制原理图库时报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 内容如右图：Details Duplicate pins in component Pin ×× and Pin ×× 主要原因是因为：右击-原理图的properties中的Designator名称定义重复，需全部改为不同，并且把隐藏的勾去除即可。
2.绘制原理图点击时会跳到空白处，这是因为封装没有切换到原点，当你拖动或者移动该元器件时，软件默认以该元件原点为中心，所以就出现元器件消失或者跳到其他位置的情况：Edit-Set Reference-Center 3.Class Document Source Message Time Date No.[Error] ESP32-PicoDK.SCHLIB Compiler USB-Type-C-TOP: == Could not find port ‘B13’ on model ‘Type-C-TOP’ for pin ‘B13’== 11:02:48 2022/3/16 18 目前办法需要去除原理图相对应的引脚标号，重新编译即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c48c445d1eebb7ade830519c1b2d7a/" rel="bookmark">
			图的深度优先遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用栈实现。
从源点开始按照深度把节点放入栈中，然后再弹出。
每弹出一个节点，把该节点一个没有进入栈中的节点放入栈中，并把该节点也放入栈中，方便回溯。
直到栈变空。
public static void dfs(Node node) { if(node == null) { return; } Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); HashSet&lt;Node&gt; set = new HashSet&lt;Node&gt;(); stack.push(node); set.add(node); System.out.println(node.value); while(!stack.isEmpty()) { Node cur = stack.pop(); for(Node next:cur.nexts) { if(!set.contains(next)) { stack.push(cur);//把当前元素也压入栈中是为了可以回溯。 //如果不压入栈中，等一条路走不通的时候，无法往后回溯去其他路。 stack.push(next); set.add(next); System.out.println(next.value); break; } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a2b04f6916e336e575a6de830e7029/" rel="bookmark">
			JavaScript基础——常见的输入输出语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入和输出也可以理解为任何计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示给用户，这便是一次输入和输出的过程
输出语法
document.write('内容');
向body输出内容，如果输出的内容写的是标签，那么其也会被解析成网页元素
alert(‘内容’);
页面弹出警告对话框
console.log(‘内容’;)
控制台输出语法，程序员调试使用
输入语法
prompt('内容');
显示一个对话框，包含一条文字信息，用来提示用户输入文字
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3965a856d68a5a8a1d3be547c45e8977/" rel="bookmark">
			Redis集群（一）快速搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 快速搭建集群2. 手动搭建集群 1. 快速搭建集群 1. 进入源码文件夹
2. 执行./create-cluster start命令
3. 执行/create-cluster create命令并选择yes
加粗样式加粗样式4. 创建完的结构
5. 测试
该键所属的槽6257并不是由节点30001负责处理，而是由节点30002负责处理，所以节点30001将向客户端返回一个转向提示，而收到提示的客户端将向节点30002重新发送命令请求
6. 关闭集群
2. 手动搭建集群 1. 创建10个节点对应的文件夹
2. 创建10个redis.conf文件，内容如下，port分别为30001-30010， 将这10个redis.conf文件分别放到对应的node文件夹下
redis.conf内容
cluster-enabled yes # 开启集群配置 port 30002 # 修改端口号 cluster-config-file nodes-30002.conf # 开启集群配置文件 daemonize yes # 启动后台 protected-mode no # 关闭保护模式 3. 依次启动10个集群节点
4. 关闭集群节点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f478a1b803e6e47a0012c30a587db486/" rel="bookmark">
			SOLOV2源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 train部分 1.1 总体框架（主要介绍detectron2框架） 执行train_net.py--&gt;
args = default_argument_parser().parse_args()加载参数--&gt;
launch函数判断是否为多gpu训练，从launch末尾进入train_net的main函数--&gt;
main函数主要是读取参数，同时判断是否先进入test（不进入）。之后根据从trainer = Trainer(cfg)进入Trainer类,同样是理解读取参数，具体操作包括加载数据集，模型，优化器等，
之后回到main函数--&gt;
根据return trainer.train()函数进入Trainer类里的train函数--&gt;
从self.train函数进入train_net.py的self.train_loop函数（开始训练）--&gt;
训练分为三部分，如下：
self.before_step()
self.run_step()
self.after_step()
其中，hook函数只放在before和after中，而run函数专门负责训练，即执行如下语句
self._trainer.run_step() #位于defaults.py第495行 值得一提的是，根据公约，计算比较复杂的操作一般放在after_step（）函数中，而不放在before_step中。
1.2 参数读取 训练所需参数读取自/AdelaiDet/configs/SOLOv2/R50_3x.yaml文件，同时这个文件还继承自/AdelaiDet/configs/SOLOv2/Base-SOLOv2.yaml文件。后者中与前者相同的信息会被前者覆盖。但是实际训练用到的参数远多于这些，这些没有在上文提及的参数取自文件/AdelaiDet/adet/config/defaults.py。
1.3 Trainer(cfg)部分 trainer=Trainer(cfg)是将定义在train_net.py的Trainer类实例化的过程。这个类是继承自DefaultTrainer类，又继承自TrainerBase类（这两个被集成的类都有__init__方法而Trainer类没有）。因此会先执行他们的__init__方法。
在DefaultTrainer（&amp;TrainerBase）类的__init__方法会进行一些必要的操作，包括上文提到的，根据cfg加载数据集，模型，优化器，保存权重轮数，钩子等。如下：
def __init__(self, cfg): """ Args: cfg (CfgNode): """ super().__init__() logger = logging.getLogger("detectron2") if not logger.isEnabledFor(logging.INFO): # setup_logger is not called for d2 setup_logger() cfg = DefaultTrainer.auto_scale_workers(cfg, comm.get_world_size()) # Assume these objects must be constructed in this order. model = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f478a1b803e6e47a0012c30a587db486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c552160cc8cb7c8b7d24c1ef08926249/" rel="bookmark">
			springcloud----feign使用之熔断添加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.添加依赖
&lt;dependency&gt;
&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
2.创建配置类实现feign接口
3.在feign上配置熔断
4.在配置文件开启feign
feign: sentinel: enabled: true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f051f50c8fc0e7154aa9abdd3a2581/" rel="bookmark">
			Sentinel 控制台 不显示实时监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.sentinel-dashboard-1.8.0.jar一开始在linux中运行能查到下面三个，就是实时监控不显示
2.也试了网上说的配置文件多添加一个--也无效
clientIp: 192.168.188.129 3.---解决文件把sentinel-dashboard-1.8.0.jar在本地运行(在文件所在的搜索中cmd进入控制台窗口启动就可以l)
idea消费者配置文件修改为本地localhost：端口号重启成功（不用127.0.0.1不识别）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9592614fa613de5f48e87b6622c4e7c7/" rel="bookmark">
			Android Studio启动AVD报错，The emulator process for AVD Pixel_5_API_30 has terminated.解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在C:\用户\86151\AppData\Local\Google\AndroidStudio2021.1\log目录下，点开 idea.txt 2.会找到这行错误 3.修改配置文件 4. 修改 在虚拟设备文件夹下的config文件，将hw.gpu.mode 改为off 5.这样运行虚拟设备就成功了，网上的教程，又是添加系统环境变量，又是复制.android文件夹到默认的SDK文件夹，最终还是启动不了浪费时间。 参考文章：http://t.csdn.cn/C8BiG
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa5a427c86b12a24dda3da02c4c3d6e/" rel="bookmark">
			学生如何免费申请使用idea
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写java程序，现在主流的工具无非有2种，一是免费的eclipe工具，相信不少java程序员在学习或者开发中都使用过它，另外一种就是业界公认最好的java开发工具–IntelliJ IDEA，因为这款工具实在是太强大了，代码助手、代码自动提示、重构等等，具体我就不再叙述了。但是这款工具旗舰版是收费的，那么今天我们就来聊一下学生如何免费使用。
jetBrains开发工具免费提供学生和教师使用，取得授权之后登陆jetBrains账号，即可使用它家的相关产品。
申请步骤 1.登陆JetBrains官网的注册界面 https://account.jetbrains.com/login 用自己的邮箱创建一个账号 点击sign up后，官方会发一封确认验证邮件到你注册的邮箱上（有可能需要好几分钟的时间邮件才会发送到达邮箱，所以请耐心等待吧~）
2.通过验证邮件设置好密码后，跳转或登录到jetbrains官网。 3.再跳转到 https://www.jetbrains.com/shop/eform/students 页面，开始填写资料 如上图，选择红色圈圈的选项，因为这个方法是最好的，只要你有学生证就行。
4.Name写真实的中文名字，如果你不是外国人的话。first name写自己的姓，last name写自己的名。 5.Email address写你用来注册账号的邮箱。 6.Country/Region选China。 7.Academic institution写自己学校的全名。 8.My education institution is accredited and takes 2 or more yearsof full-time study to complet这个选项最好勾上，虽然好像并没有什么用。 9.这一步才是重点。ADD DOCUMENT(S)这里上传一张自己的学生证照片，不要拍学生证封面或其他无关紧要的页面，拍包含一寸照、姓名、学号、院系、专业等重要信息的那一页，而且一定要拍得清晰一点，确保文字清晰可读就行。 10.协议那一栏打钩，最后提交。提交成功后，官方会在一个星期之内发一封授权邮件到你邮箱（小编当时只等了一个下午）至此申请成功。 13.可以开始下载自己想使用的软件产品了。假如下载并安装好了PyCharm,初次打开时在检查License那个页面输入自己在jetbrains官网注册的账号和密码并点击确认，这样就可以免费使用了！
参考文章：https://blog.csdn.net/weixin_41461967/article/details/79593943
参考文章：https://blog.csdn.net/glc11223344/article/details/104819488
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f11fbd13a247ae24aaec468ea50e718/" rel="bookmark">
			[国家集训队] Crash的数字表格/JZPTAB(莫比乌斯反演)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[国家集训队] Crash的数字表格/JZPTAB Statement 计算: A n s = ∑ i = 1 N ∑ j = 1 M lcm ( i , j ) Ans=\sum_{i=1}^N\sum_{j=1}^M\text{lcm}(i,j) Ans=∑i=1N​∑j=1M​lcm(i,j).
Solution ∑ i = 1 N ∑ j = 1 M lcm ( i , j ) = ∑ i = 1 N ∑ j = 1 M i ⋅ j gcd ⁡ ( i , j ) \sum_{i=1}^N\sum_{j=1}^M\text{lcm}(i,j)=\sum_{i=1}^N\sum_{j=1}^M\frac{i\cdot j}{\gcd(i,j)} ∑i=1N​∑j=1M​lcm(i,j)=∑i=1N​∑j=1M​gcd(i,j)i⋅j​.
A n s = ∑ d = 1 m i n ( N , M ) 1 d ∑ i = 1 N ∑ j = 1 M i ⋅ j [ gcd ⁡ ( i , j ) = d ] Ans=\sum_{d=1}^{min(N,M)}\frac{1}{d}\sum_{i=1}^N\sum_{j=1}^Mi\cdot j[\gcd(i,j)=d] Ans=∑d=1min(N,M)​d1​∑i=1N​∑j=1M​i⋅j[gcd(i,j)=d] 设 f ( d ) = ∑ i = 1 N ∑ j = 1 M i ⋅ j [ gcd ⁡ ( i , j ) = d ] f(d)=\sum_{i=1}^N\sum_{j=1}^Mi\cdot j[\gcd(i,j)=d] f(d)=∑i=1N​∑j=1M​i⋅j[gcd(i,j)=d].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f11fbd13a247ae24aaec468ea50e718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f3d1388b452d26cea64eca8328c8bcc/" rel="bookmark">
			Dialog布局中拥有EditText时监听软键盘的弹出和收起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做项目的时候，遇到了一个需求：点击按钮在屏幕中间弹出一个弹窗，弹窗上面有一个输入框。对于这个需求我采用Dialog+EditText来实现，功能并不难实现。但是UI老师要求在没有进行输入的时候，弹窗位置在屏幕中间。当进行输入的时候，弹窗位置在上面。
现在的情况是，当输入框调起软键盘时，软键盘会将弹窗中输入框以上的布局进行上移，但是弹窗位置本身不会变化。也就是说，软键盘会遮盖弹窗中输入框下方的布局，而将其上方的布局进行挤压。
在网上看调整软键盘的输入模式后，虽然不会对布局产生挤压，但是却直接盖在了弹窗上面，显然不符合期望。
因此需要调整思路，弹窗的位置随着键盘的收起显示而变化，这意味着我们可以监听软键盘的弹出与收起。但是网上大多监听键盘的解决方案是在Activity或者Fragment中，通过监听整个View树布局的高度变化来判断键盘是否被调起。但是这里采用的是Dialog实现，当Dialog弹出时，整个View树高度就已经发生变化，因此不可行。
在多次尝试之后，找到在Dialog中去监听键盘高度的办法。那就是，首先将Dialog调整成全屏的，如果不是全屏的使用一个占位View。这样也方便我们做后面的移动。将Dialog设置为全屏之后，然后对Dialog的根视图的高度变化来判断是否产生了键盘调起。代码如下
viewTreeListener = object : ViewTreeObserver.OnGlobalLayoutListener { override fun onGlobalLayout() { //获取当前根视图在屏幕上显示的大小 val r = Rect() view.getWindowVisibleDisplayFrame(r) val visibleHeight = r.height() // 初始化时，根视图按设置大小显示 if (rootViewLastVisibleHeight == 0) { rootViewLastVisibleHeight = visibleHeight return } //根视图显示高度没有变化，可以看作是软键盘显示／隐藏状态没有改变 if (rootViewLastVisibleHeight == visibleHeight) { return } //上次显示比目前显示的高度大，可以看作软键盘显示了，200 为键盘的高度 if (rootViewLastVisibleHeight - visibleHeight &gt; 200) { rootViewLastVisibleHeight = visibleHeight val objectAnimator: ObjectAnimator = ObjectAnimator.ofFloat( binding.submitToEmail, "translationY", 0.0f, -420.0f ) //沿着Y轴平移 objectAnimator.duration = 0 objectAnimator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f3d1388b452d26cea64eca8328c8bcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcd19ee86967097c8c0ea5d355b195bd/" rel="bookmark">
			超详细Klipper 上位机与下位机配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(适用多数Mega2560芯片打印机主板，本文使用香橙派ZERO2作为上位机)
上位机:ZERO2
下位机:打印机主板
下载镜像系统 首先，去Armbian官网下载Buster系统镜像:Armbian官网
准备一张8G以上SD卡推荐用闪迪，使用balena Etcher工具将镜像写入SD卡
将SD卡插入Zero2 给Zero供电(建议5V1A以上，否则可能供电不足不开机)去路由器后台查看香橙派IP地址，使用SSH工具:MobaXterm
配置ZERO2 连接ZERO2 用户名：root 默认密码：1234
登陆后提示设置新的密码
之后选择代码风格 bash或者zsh
再然后会新建pi用户并创建密码
更新系统库
sudo apt-get update 替换下载源
cd /etc/apt vim sourecs.list 切换到PI用户，使用git命令下载kiauh脚本
su pi cd ~ git clone https://gitee.com/zm112/kiauh.git 运行kiauh脚本
./kiauh/kiauh.sh 安装Klipper 输入1 进入安装
输入 1 安装Klipper
输入 2 安装 Moonraker
输入 4 安装 Fluidd
(整理了年前的配置过程，大体是这样的，安装klipper不成功就是网络问题，多装几次。)
下位机配置： 下载Xloader：阿里云盘
PC连接打印机主板，选择固件路径 选择芯片型号，选择端口号，选择115200 烧写固件！
配置打印机主板，SSH远程登录ZERO2进入普通用户PI，进入klipper目录(默认根目录)
su pi cd /klipper 进入打印机主板设置
make menuconfig 下位机和上位机用数据线连接，网页访问上位机IP进入可视化页面，进入配置-配置文件下。修改printer.cfg文件，查找对应型号主板cfg文件代码，覆盖到printer.cfg文件中
修改muc 查询串口号：
ls /dev/serial/by-id/* 将查询到的串口号复制到printer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcd19ee86967097c8c0ea5d355b195bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/340b7bcbeffa0a232f8087a6c6806b9c/" rel="bookmark">
			2021CCPC桂林站 F-Illuminations II(计算几何)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021CCPC桂林站 F-Illuminations II Problem Statement 你得到两个凸包, 外凸包有 n n n个点, 内凸包有 m m m个点. 保证内凸包严格在外凸包内. 现在我们在外凸包边界放一个光源, 求照亮内凸包边界的期望长度.
Solution 由于期望的线性性: 我们考虑求内凸包每一条边的贡献.
下面:我们不妨设用两个点来表示一条边: 例如 ( u i , v i ) (u_i,v_i) (ui​,vi​)表示起点为 u i u_i ui​终点为 v i v_i vi​的边, 这里表述和点坐标不同. 计算几何中也常用两个点来表示一个直线. 下面我们就用这种表示法来表述. 设内凸包(逆时针顺序记录点)上一个边 ( u i , v i ) (u_i,v_i) (ui​,vi​), 外凸包的周长为 Sum \text{Sum} Sum, ( u i , v i ) (u_i,v_i) (ui​,vi​)与外凸包的交点为 ( a i , b i ) (a_i,b_i) (ai​,bi​), 那么外凸包 ( a i , b i ) (a_i,b_i) (ai​,bi​)之间且在 ( u i , v i ) (u_i,v_i) (ui​,vi​)右侧的折线距离设为 L e n ( a i , b i ) Len_{(a_i,b_i)} Len(ai​,bi​)​.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/340b7bcbeffa0a232f8087a6c6806b9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e74a69b1d7842a2772ac48ba28c2bf/" rel="bookmark">
			Vbox 桥接无线网卡自动获取 IP 地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能性 可能性一：maybe无线AP有密码，而虚拟机桥接无法输入密码,所以连接不上，无 AP
但 DHCP 是路由器充当的,它不用密码,可以自由获取
但虚拟机只有连接上无线AP,才能与网络通信,所以就出现了这种情况
无线路由密码关闭
解决方案 https://www.jianshu.com/p/d3f4891a154a
另一个博客解决方案过程讲解：
https://blog.csdn.net/weixin_36423916/article/details/117503947
原因：无线网卡不支持混杂模式，所以直接桥接到无线网卡上不行。
virtualbox桥接无线网卡实现上网的思路
1、在电脑上建立一个虚拟的网卡，将虚拟机的IP配置成与虚拟网卡同一网段，网关默认。
2、将可以上网的网卡共享给虚拟网卡。
virtualbox桥接无线网卡实现上网的过程
1、在电脑上添加虚拟网卡：在设备管理器里面添加过时设备，选择网络适配器，选择微软的虚拟网卡，最后选择Microsoft Loopback Adapter
2、将能上网的无线网卡共享上网给Microsoft Loopback Adapter
3、进入虚拟机，修改虚拟机的IP地址同Microsoft Loopback Adapter在一个网段，网关一般是192.168.137.1，DNS为路由器地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6d6b8fbf81ec3dcfb38b812c3c98ca/" rel="bookmark">
			javaSE基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本语法 Java修饰符 像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：
访问控制修饰符 : default, public , protected, private非访问控制修饰符 : final, abstract, static, synchronized 在后面的章节中我们会深入讨论 Java 修饰符。
非访问修饰符 为了实现一些其他的功能，Java 也提供了许多非访问修饰符。
static 修饰符，用来修饰类方法和类变量。
final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
abstract 修饰符，用来创建抽象类和抽象方法。
synchronized 和 volatile 修饰符，主要用于线程的编程。
static 静态变量：
static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。
静态方法：
static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。
对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。
实例
Test.java
package 面向对象.StaticTest; /* static 修饰变量，变量随着类加载而加载 可以使用 类.变量 调用变量 ，例如Person.naive static 修饰方法 ，方法随着类加载，可以使用 类.方法调用方法 1.类可以调用静态方法，但是不能直接调用非静态方法和非静态变量 2. 对象可以调用静态和非静态 3. 静态方法只能调用静态变量，非静态变量可以调用静态变量和非静态变量 4. 静态方法中不能使用this和super 关键字 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6d6b8fbf81ec3dcfb38b812c3c98ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc4f8ca0300592d62f30406f4fc3c9b/" rel="bookmark">
			Object源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0、写在正文前1、带着问题看源码2、Object中有哪些方法？3、hashCode方法是不是本地方法？4、equals比较的是什么？怎么比较的？5、clone方法的作用？6、讲一下toString方法?7、讲一下wait方法8、讲一下notify、notifyAll方法 0、写在正文前 用了几年Java，你是否去看过Object中的源码，是否知道其中方法各自的实现过程及用途呢，今天就一起来学习Object的源码吧~~~
1、带着问题看源码 Object中有哪些方法？hashCode方法是不是本地方法？equals比较的是什么？怎么比较的？clone方法的作用？讲一下toString方法？讲一下wait方法?讲一下notify、notifyAll方法? 2、Object中有哪些方法？ hachCodeequalsclonetoStringnotifynotifyAllwaitfinalize 3、hashCode方法是不是本地方法？ 看过源码的应该都知道是native方法
public native int hashCode(); 4、equals比较的是什么？怎么比较的？ 指示其他某个对象是否与此对象“相等”。
源码如下：
public boolean equals(Object obj) { return (this == obj); } 5、clone方法的作用？ 源码：
protected native Object clone() throws CloneNotSupportedException; 作用：
clone方法是用来复制一个对象。不同于“=”。
对于值类型的数据是可以通过“=”来实现复制的。但是对于引用类型的对象，“=”只能复制其内存地址，使对象的引用指向同一个对象，而不会创建新的对象。clone则可以创建与原来对象相同的对象。
看源码可知clone是一个native方法并且用protected修饰，所以我们不能直接调用object类的clone方法
使用方式：
实体类实现Cloneable接口重写clone方法 例子：
TestClone obj = new TestClone(); //使用 clone 复制 Object objClone = obj.clone(); System.out.println(obj.toString()); System.out.println(objClone.toString()); System.out.println(obj == objClone); //使用 = 复制 TestClone objObj = obj; System.out.println(obj.toString()); System.out.println(objObj.toString()); System.out.println(obj == objObj); 测试结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc4f8ca0300592d62f30406f4fc3c9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d8c8a7a879fc1f8a978891eeb2b02b/" rel="bookmark">
			Cron常用表达式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cron简介 Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：
（1） Seconds Minutes Hours DayofMonth Month DayofWeek Year
（2）Seconds Minutes Hours DayofMonth Month DayofWeek
Cron结构
（1）cron从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份
每个字段的允许值 （0）字段 允许值 允许的特殊字符
（1）秒 0-59 , - * /
（2）分 0-59 , - * /
（3）小时 0-23 , - * /
（4）日期 1-31 , - * ? / L W C
（5）月份 1-12 或者 JAN-DEC , - * /
（6）星期 1-7 或者 SUN-SAT , - * ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42d8c8a7a879fc1f8a978891eeb2b02b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a12138bf484882f3a5f2f2a6506672/" rel="bookmark">
			Unity3D 在代码中动态改变GameObject大小和锚点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接对sizeDelta属性进行赋值，其中X和Y可以对应理解成width和height
直接对anchoredPosition3D属性进行赋值，其中X、Y、Z可以对应理解成pos X、pos Y、pos Z
代码
public class ChartsScript : MonoBehaviour { public GameObject LeftGameObject; public Text LeftText; private Vector2 _sizeDelta; private Vector3 _anchoredPosition3D; // Start is called before the first frame update void Start() { _sizeDelta = LeftGameObject.GetComponent&lt;RectTransform&gt;().sizeDelta; _anchoredPosition3D = LeftGameObject.GetComponent&lt;RectTransform&gt;().anchoredPosition3D; } public void FullLeftChart() { if (LeftText.text.Equals("全屏")) { var width = UnityEngine.Screen.width; var height = UnityEngine.Screen.height; var rt = LeftGameObject.GetComponent&lt;RectTransform&gt;(); rt.sizeDelta = new Vector2(width, height); rt.anchoredPosition3D = new Vector3(0, 0, 0); LeftText.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69a12138bf484882f3a5f2f2a6506672/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d482b1134e74fca17e050144f2973e18/" rel="bookmark">
			charles抓包配置及解决抓包没有网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装
2、配置
证书安装：Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate，mac需要配置证书
注意点击安装证书–&gt;下一步后，选择（将所有证书放入下列存储），确定选择（受信任的根证书办法机构），确定后点击下一步–&gt;（用户选定的证书存储）点击完成； 移动端安装证书：
浏览器中输入 chls.pro/ssl 来安装证书，若手机是iphone，需要设置：设置-&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置，打开相应证书信任
https抓包配置：
Proxy -&gt; SSL Proxying Setting -&gt; 勾选上-&gt;Enable SSL Proxying， 然后填写具体需要抓包的域名。可直接填写*和*
在Proxy -&gt; Proxy settings... -&gt; Proxies中开启https配置：
还可以配置受信任得ip地址：在Proxy -&gt;Access Control Settings，点击add添加即可
手机打开代理：
打开如下路径查看需要代理得ip和端口号，手机代理按照此处配置
以上都配置完手机端还是没有网，要关闭电脑端的防火墙，再试
注意：手机抓包需要移动端与charles所在电脑在同一个局域网下
若只想抓手机包，不想抓电脑包，可设置Proxy --&gt; 不勾选Windows Proxy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada6dde77489764fce0dee9888f132fb/" rel="bookmark">
			macos ssh remote linux的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在macos中，由于cuda的n卡目前对mac系统存在着限制问题，故在DL的时候，可以利用远程服务器进行计算。在windows系统中，可以通过finalshell，xshell等图形化界面软件来进行服务器的连接，而在mac中，我们可以直接通过ssh 来进行远程的连接。
ssh 通过username与psw 直连：
ssh username@ip -p 端口 ssh 通过密钥连接：
ssh -i ~/.ssh/密钥 username@ip -p 端口 这里需要注意的是： 密钥最好放在.ssh文件夹下，并且由于安全性的问题，如果是任何人都可以读写的话，系统会判定为不安全的密钥从而还是不允许通过，需要在下载到密钥之后对其修改权限：
首先查看一下权限是否开启任何人读写
ls -al 对指定密钥文件进行权限修改
chmod 600 filename 还有一种更为简便的方式，就是新建远程连接，以后只用打开就行了。
目前，linux自带的python是2.x的，如果需要3.x的则需要自行安装。
参考博文如下：
Linux 搭建 Python 开发环境 — Miopas
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c8590af1649590a95f0358c55088e12/" rel="bookmark">
			序列化和反序列化的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们来了解为什么需要序列化 卖个关子，大家玩游戏的时候，相信都知道【存档】的功能吧，每次我们重新进入游戏的时候，直接载入存档就可以了，不用重新在重头开始，这样我们的游戏也不会丢失从面向对象的思维考虑，万事万物皆对象，我们游戏中的角色，怪兽，装备等等都可以看做是对象我们再从计算机思维考虑，创建的对象其实都是保存在内存中的，想必大家都知道内存中存储的数据只是暂时性的，断电之后是会消失的，但是游戏如果你手动存档之后就算你几天之后在开机，再次读取存档就可以了，这就很奇怪了，为什么断电之后我得装备和人物信息还都存在，还可以继续玩，这是为什么呢？其实我们只要稍加思考之后知道，我们手动存档之后是将内存中的数据存储在硬盘上的，硬盘的数据在关机之后，是不会消失的，其实这个过程就是对象的持久化，也就是我们今天理解的序列化，从我们的磁盘上读取出来的数据其实就是对象的反序列化 什么是序列化 上面引入游戏的概念是为了让大家了解为什么需要序列化和反序列化，简单的总结一下
序列化是指将我们对象实例的状态存储到媒体的过程反序列化是我们从媒体中将我们的对象状态转换成对象的过程 抽象点理解
序列化是将对象转成字节序列的过程
反序列化是将我们的字节序列转成对象的过程
序列化的目的 序列化的最终目的是为了实现对象可以跨平台存储和进行网络传输，而我们的跨平台存储和网络传输使用的是IO，IO支持的格式就是字节数组（byte[]）现在存在的问题， 我们如何将对象转成成字节数组呢？其实我们单纯的将对象转成字节数组还是不可行的，因为没有规则的字节数组我们是没办法还原成对象原本面目的，所以我们必须在对象转成字节数组的时候制就定一种规则（序列化），那我们从IO流里面读取数据的时候可以再根据这种规则把对象还原回来（反序列化） 序列化的几种方式 序列化只是定义了拆解对象的具体规则，那这种规则肯定也是多种多样的，比如现在常见的序列化方式有：JDK 原生、JSON、ProtoBuf、Hessian、Kryo等。
1.JDK（原生）
作为一个成熟的语言，JDK自带序列化方法。只要实现了Serializable接口，通过ObjectOutputStream类将对象变成byte[]字节数组
JDK 序列化会把对象类的描述信息和所有的属性以及继承的元数据都序列化为字节流，所以会导致生成的字节流相对比较大。
简单总结一下：JDK 原生的序列化方式生成的字节流比较大，也不支持跨语言，因此在实际项目和框架中用的都比较少。
2.ProtoBuf
谷歌推出的，是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于通信协议、数据存储等。序列化后体积小，一般用于对传输性能有较高要求的系统。
3.Hessian
Hessian 是一个轻量级的二进制 web service 协议，主要用于传输二进制数据。
在传输数据前 Hessian 支持将对象序列化成二进制流，相对于 JDK 原生序列化，Hessian序列化之后体积更小，性能更优。
4.Kryo
Kryo 是一个 Java 序列化框架，号称 Java 最快的序列化框架。Kryo 在序列化速度上很有优势，底层依赖于字节码生成机制。
由于只能限定在 JVM 语言上，所以 Kryo 不支持跨语言使用。
5.JSON
JSON 序列化方式生成的是一串有规则的字符串，在可读性上要优于上面几种方式，但是在体积上就没什么优势了。
另外 JSON 是有规则的字符串，不跟任何编程语言绑定，天然上就具备了跨平台。
总结一下：JSON 可读性强，支持跨平台，体积稍微逊色。
JSON 序列化常见的框架有：fastJSON、Jackson、Gson 等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/374719bf0c2da9186e9eb7aa2460174d/" rel="bookmark">
			LVGL V8学习之colorwheel色轮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一篇来研究下LVGL V8下colorwheel色轮的使用，这个色轮是HSV样式的，下面的代码通过创建色轮对象，然后添加对象事件处理，移动旋钮，显示对应的颜色和RGB值
还是通过codeblock来模拟代码的运行，代码如下：
// 事件回调函数 static void colorwheel_event_callback(lv_event_t * event) { if (event == NULL) { printf("[%s:%d] event is NULL\n", __FUNCTION__, __LINE__); return ; } lv_event_code_t code = lv_event_get_code(event); if (code == LV_EVENT_VALUE_CHANGED) { lv_obj_t *obj_colorwheel = lv_event_get_current_target(event); lv_obj_t *obj_label = lv_event_get_user_data(event); if (obj_label != NULL &amp;&amp; obj_colorwheel != NULL) { lv_color_t color = lv_colorwheel_get_rgb(obj_colorwheel); lv_label_set_text_fmt(obj_label, "Red:%d\n\nGreen:%d\n\nBlue:%d", color.ch.red, color.ch.green, color.ch.blue); } } } /* 创建一个HSV色轮colorwheel对象，沿色轮移动按钮显示对应的RGB值 */ void lv_colorwheel_test() { lv_obj_t *obj_color_label = lv_label_create(lv_scr_act()); if (obj_color_label == NULL) { return ; } //lv_label_set_text(obj_color_label, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/374719bf0c2da9186e9eb7aa2460174d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c3f3ddc54d5329395d8dd7f8ecd0309/" rel="bookmark">
			IDEA中右侧的maven窗口怎么调出来，和解决导不进maven包的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Idea中右边的maven projects窗口找不到了如何调出来？
具体的idea版本我不太清楚，我用的是2019版，其他版本应该也是一样的。
首先idea自带了maven控件，不像Eclipse还需要下载控件，如果你以前有maven在右边，出于某种原因，消失找不到 了，你可以试试我写的方法。
方法1.你点击一下你idea界面最左下角的那个小框，maven应该从里面找到
方法2.点击菜单栏View-&gt;Tool Windows-&gt;Maven projects
方法3.点击菜单栏Help-&gt;Find Action(Ctrl+Shift+A),输入Maven projects，下面第一个Add Maven Projects，然后选择pom文件
这里我不说Ctrl+Shift+A的快捷键，是因为有很多东西有快捷键，有可能会出现快捷键冲突。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdc1bb379bd7aa6c3648e47ab9514f81/" rel="bookmark">
			Thymeleaf简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thymeleaf简介 Thymeleaf是一个流行的模板引擎，该模板引擎采用Java语言开发，模板引擎是一个技术名词，是跨领域跨平台的概念，在Java语言体系下有模板引擎除了thymeleaf之外还有Velocity、FreeMarker等模板引擎，功能类似。
结合Spring Boot 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 修改spring boot配置文件 # 开发阶段，建议关闭thymeleaf的缓存 spring.thymeleaf.cache=false #使用遗留的html5以去掉对html标签的校验 spring.thymeleaf.mode=LEGACYHTML5 thymeleaf会对html中的标签进行严格校验，如果html标签缺少结束标签的话，thymeleaf会报错，我们可以通过下面方式去除thymeleaf的校验，添加依赖:
&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt; &lt;/dependency&gt; 第一个thymeleaf程序 编写html页面：在resources/templates里面创建一个index.html，填写下面内容，注意添加这个xmlns:th=“http://www.thymeleaf.org”：
&lt;!DOCTYPE html&gt; &lt;html xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;thymeleaf&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 th:text="${name}"&gt;Spring boot集成 Thymeleaf&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 编写controller控制器：
@Controller public class ThymeleafCtrl { @GetMapping("/") public String hello(Model model){ model.addAttribute("name","jack"); return "index"; } } 注意：这里的return使用的默认前缀和后缀，使用thymeleaf模板，默认前缀是resources下的templates目录，后缀是html；其他情况前缀是resources下的static目录，后缀是html。maven构建工具的就是webapp，jsp了。
== Springboot使用thymeleaf作为视图展示的时候，我们将模板文件放置在resource/templates目录下，静态资源放置在resource/static目录下。==
thymeleaf表达式 标准变量表达式${}，th:text用来获取controller中返回的数据。 //定义接口 @GetMapping("/thymeleaf/one") public String one(Model model){ User user=new User(); user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdc1bb379bd7aa6c3648e47ab9514f81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a1bb6e3cf2dbaa92227db877efa58c1/" rel="bookmark">
			僵尸进程与孤儿进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是僵尸进程 一个进程已经终止了，但是它的父进程还没有获取到其状态，那么这个进程就叫做僵尸进程。僵尸进程只保留最小的概要信息——一些基本内核数据结构，只消耗非常少的系统资源。保留这些概要信息主要是为了在父进程查询子进程的状态时可以提供相应的信息，僵尸进程等待父进程来查询自己的状态（这个过程称为在僵尸进程上等待）。一旦父进程得到了想要的信息，内核就会清除这些信息，僵尸进程就不存在了。
用 C 语言创建一个僵尸进程 [root@node01 tmp]# vi zombie.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main(int argc, char *argv[]) { pid_t pid; pid = fork();	// 创建进程 if(pid &lt; 0){ // 出错 perror("fork"); } if(0 == pid){ // 子进程 printf("i am son\n");	exit(0); // 子进程退出 }else if(pid &gt; 0){ // 父进程 printf("i am father\n"); sleep(100); //父进程睡100秒后退出 exit(0); } return 0; } [root@node01 tmp]# gcc zombie.c -o zombie [root@node01 tmp]# .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a1bb6e3cf2dbaa92227db877efa58c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68747b3d6f96e6e3aa2c74406505c3a4/" rel="bookmark">
			Ubuntu操作-07 GNOME-TWEAKS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 gnome-tweaks1.1 安装1.2 扩展安装1.3 手工安装扩展插件 2 更换主题3 将工作区修改为Mac样式4 其他一些有用的插件4.1 system-monitor：系统资源显示4.2 Applications menu4.3 No title bar4.4 Topicons4.5 Netspeed4.6 Sound input &amp; output device chooser4.7 Coverflow Alt-Tab4.8 ~~indicator-sysmonitorr~~4.9 lunar-calendar4.10 Harddisk LED4.11 Load Average4.12 Uptime Indicator4.13 Sound Input &amp; Output Device Chooser4.14 Drop Down Terminal4.15 Todo.txt4.16 Removable Drive Menu4.17 Vitals4.18 Activities Configurator4.18 Extensions4.19 Backslide4.20 Lock keys 如果你像拥有类似Mac的操作界面，或者需要将当前正常使用的软件图标缩放在右上角。等等一些扩展功能就需要了解GNOME的优化器。
1 gnome-tweaks GNOME Tweaks Tool（GNOME优化工具），也被称为GNOME调整或简单的调整。GNOME Tweaks 是可以调整 GNOME 的高级选项，帮助你设置GNOME。
1.1 安装 (base) pang@pang-HP:/opt/deepinwine/tools$ sudo apt install gnome-tweaks 正在读取软件包列表.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68747b3d6f96e6e3aa2c74406505c3a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a2426dc4c661743184bc70c54d5cabb/" rel="bookmark">
			学习Java初期常见错误整理（更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码编译无错误，代码运行时打印出生僻字。 如下图 解决方案：修改编码。
具体步骤：
点击记事本左上角的“文件”；点击“另存为”；将编码“UTF-8”改为“ANSL”；点击“保存”； 再次进入命令窗口进行编译运行
显示正常：
非法字符’\ufflb’ 在编译过程中，可能会显示以下内容
原因：代码中含有中文符号。解决方案：改为英文字符（此图中中文字符是“；”）。 缺少方法主体，或声明抽象 显示结果
原因：图中"public static void main(String[] args);{"的“;”是多余的。解决方案：删去“;”。 NumberFormatException异常（数字格式异常） 原因：在使用包装类将字符串转换为基本数据类型（整型，浮点型，逻辑型（如boolean）以及字符型）时，若字符串格式不正确，便会出现该异常。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97013786f6cace150b0e99dd03dab3cd/" rel="bookmark">
			操作系统复习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统实验导航 实验一：银行家算法 https://blog.csdn.net/weixin_46291251/article/details/115384510
实验二：多级队列调度和多级反馈队列调度算法 https://blog.csdn.net/weixin_46291251/article/details/115530582
实验三：动态分区式内存管理 https://blog.csdn.net/weixin_46291251/article/details/115772341
实验四：Linux下多进程通信 https://blog.csdn.net/weixin_46291251/article/details/116274665
实验五：进程通信的三种方式 https://blog.csdn.net/weixin_46291251/article/details/116301250
实验六：Linux文件系统实验 https://blog.csdn.net/weixin_46291251/article/details/116423798
实验七：自制简单U盘引导程序 https://blog.csdn.net/weixin_46291251/article/details/116427629
实验八：磁盘调度算法 https://blog.csdn.net/weixin_46291251/article/details/116431907
实验九：请求分页系统中的置换算法 https://blog.csdn.net/weixin_46291251/article/details/116443021
学习笔记：操作系统复习笔记 https://blog.csdn.net/weixin_46291251/article/details/117086851
文章是在有道云上面写的，搬过还没来得及改格式，原文链接
_by Cheney
一：绪论
二：操作系统的结构和硬件支持
►处理机状态：
►中断：
三：操作系统的用户接口
►作业：
►系统调用：
四：进程及进程管理：★★★
►并发处理：
►进程:
► 线程
►进程互斥和同步
互斥:
同步
锁和上锁、开锁操作
►典型问题：★★
►进程通信
五：资源分配与调度
►资源管理概述
►死锁：
六：处理机调度
►作业调度
►进程调度
七：主存管理：★★★
►分区存储管理
►页式管理概述
►段式及段页式存储管理（了解）
八：输入∕输出管理
►设备管理：
►缓冲技术
►设备分配
SPOOLING系统
►I/O控制
九：文件系统：
►文件组织的结构:
►磁盘调度算法
十：一些题目
►虚拟存储技术不能与（ 分区管理 ）配合使用原因
►进程有不同的定义，比较典型的定义有：
►简述程序与进程
►简述进程与线程
►中断处理的流程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97013786f6cace150b0e99dd03dab3cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b5aad28ccdfc7ba90289807ce617f11/" rel="bookmark">
			请求分页系统中的置换算法(FIFO、LRU、Optimal)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统实验导航 实验一：银行家算法 https://blog.csdn.net/weixin_46291251/article/details/115384510
实验二：多级队列调度和多级反馈队列调度算法 https://blog.csdn.net/weixin_46291251/article/details/115530582
实验三：动态分区式内存管理 https://blog.csdn.net/weixin_46291251/article/details/115772341
实验四：Linux下多进程通信 https://blog.csdn.net/weixin_46291251/article/details/116274665
实验五：进程通信的三种方式 https://blog.csdn.net/weixin_46291251/article/details/116301250
实验六：Linux文件系统实验 https://blog.csdn.net/weixin_46291251/article/details/116423798
实验七：自制简单U盘引导程序 https://blog.csdn.net/weixin_46291251/article/details/116427629
实验八：磁盘调度算法 https://blog.csdn.net/weixin_46291251/article/details/116431907
实验九：请求分页系统中的置换算法 https://blog.csdn.net/weixin_46291251/article/details/116443021
学习笔记：操作系统复习笔记 https://blog.csdn.net/weixin_46291251/article/details/117086851
背景 先进先出（FIFO）页面置换算法
该算法总是淘汰最新进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。最近最久未使用（LRU）页面置换算法
最近最久未使用（LRU）页面置换算法，是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似， 因此，LRU 置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当需淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最久未使用的页面予以淘汰。最佳（Optimal）页面置换算法
该算法选择的被淘汰页面，将是以后永远不使用的，或许是在最长（未来）时间内不再被访问的页面。采用该算法，通常可保证获得最低的缺页率。但由于人们目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的，但可以利用该算法去评价其他算法。 题目描述：请求分页系统中的置换算法 1.通过如下方法产生一指令序列，共 320 条指令。 A. 在[1，32k-2]的指令地址之间随机选取一起点M,访问 M；B. 顺序访问M+1；C. 在[0，M-1]中随机选取M1，访问 M1；D. 顺序访问M1+1；E. 在[M1+2，32k-2]中随机选取M2，访问 M2；F. 顺序访问M2+1；G. 重复 A—F，直到执行 320 次指令。H.指令序列变换成页地址流设：（1）页面大小为 1K；（2）用户虚存容量为 32K。 2. 计算并输出下述各种算法在不同内存页块(页块个数范围:8-32)下的命中率。 A. 先进先出（FIFO）页面置换算法B. 最近最久未使用（LRU）页面置换算法C. 最佳（Optimal）页面置换算法 提示： A.命中率=1-页面失效次数/页地址流长度B.本实验中，页地址流长度为 320，页面失效次数为每次访问相应指令时，该指令所对应的页不在内存的次数。 算法设计 整体设计 设置全局变量保存指令的个数和指令数组，在make_instruct()函数中生成随机数填充这个数组。
内存这里用链表来组织，表示如下：
struct node { int instruct = 0; int time = 0; node* next = NULL; }; instruct表示指令号，time在不同算法中有具体含义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b5aad28ccdfc7ba90289807ce617f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50173652412259b54c82baf814b365a/" rel="bookmark">
			磁盘调度算法（先来先服务、最短寻道优先以及电梯调度算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统实验导航 实验一：银行家算法 https://blog.csdn.net/weixin_46291251/article/details/115384510
实验二：多级队列调度和多级反馈队列调度算法 https://blog.csdn.net/weixin_46291251/article/details/115530582
实验三：动态分区式内存管理 https://blog.csdn.net/weixin_46291251/article/details/115772341
实验四：Linux下多进程通信 https://blog.csdn.net/weixin_46291251/article/details/116274665
实验五：进程通信的三种方式 https://blog.csdn.net/weixin_46291251/article/details/116301250
实验六：Linux文件系统实验 https://blog.csdn.net/weixin_46291251/article/details/116423798
实验七：自制简单U盘引导程序 https://blog.csdn.net/weixin_46291251/article/details/116427629
实验八：磁盘调度算法 https://blog.csdn.net/weixin_46291251/article/details/116431907
实验九：请求分页系统中的置换算法 https://blog.csdn.net/weixin_46291251/article/details/116443021
学习笔记：操作系统复习笔记 https://blog.csdn.net/weixin_46291251/article/details/117086851
背景：磁盘调度 题目描述 1、对于如下给定的一组磁盘访问进行调度：
请求服务到达 A B C D E F G H I J K L M N
访问的磁道号 30 50 100 180 20 90 150 70 80 10 160 120 40 110 请求服务到达ABCDEFGHIJKLMN访问的磁道号3050100180209015070801016012040110 2、要求分别采用先来先服务、最短寻道优先以及电梯调度算法进行调度。3、要求给出每种算法中磁盘访问的顺序，计算出平均移动道数。4、假定当前读写头在90号，电梯调度算法向磁道号增加的方向移动。 算法设计 先来先服务算法（FCFS）: 按访问请求到达的先后次序服务。
最短寻道时间优先算法（SSTF）: 优先选择距当前磁头最近的访问请求进行服务
扫描算法（电梯算法）（SCAN）: 当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。
代码实现 感谢支持 #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; int request[]{30,50,100,180,20,90,150,70,80,10,160,120,40,110}; const int n = 14; queue&lt;int&gt; FCFS_order, SSTF_order, SCAN_order; //queue&lt;int&gt; FCFS_move, SSTF_move, SCAN_move; int FCFS_num = 0, SSTF_num = 0, SCAN_num = 0; int beg_loc = 90;//前读写头在90号 char beg_direct = '+';//电梯调度算法向磁道号增加的方向移动。 void C_FCFS() { int loc = beg_loc; for (int i = 0; i &lt; n; i++) { int tem = request[i]; FCFS_order.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50173652412259b54c82baf814b365a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76eae8ac386bba96b7d5e1af379f5abb/" rel="bookmark">
			动态分区式内存管理（完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统实验导航 实验一：银行家算法 https://blog.csdn.net/weixin_46291251/article/details/115384510
实验二：多级队列调度和多级反馈队列调度算法 https://blog.csdn.net/weixin_46291251/article/details/115530582
实验三：动态分区式内存管理 https://blog.csdn.net/weixin_46291251/article/details/115772341
实验四：Linux下多进程通信 https://blog.csdn.net/weixin_46291251/article/details/116274665
实验五：进程通信的三种方式 https://blog.csdn.net/weixin_46291251/article/details/116301250
实验六：Linux文件系统实验 https://blog.csdn.net/weixin_46291251/article/details/116423798
实验七：自制简单U盘引导程序 https://blog.csdn.net/weixin_46291251/article/details/116427629
实验八：磁盘调度算法 https://blog.csdn.net/weixin_46291251/article/details/116431907
实验九：请求分页系统中的置换算法 https://blog.csdn.net/weixin_46291251/article/details/116443021
学习笔记：操作系统复习笔记 https://blog.csdn.net/weixin_46291251/article/details/117086851
背景知识： 关于内存管理的几种方式： 固定分区： 原理：又称定长分区或静态分区模式，是满足多道程序设计需要的最简单的存储管理技术。基本思想：给进入主存的用户作业划分一块连续存储区域，把作业装入该连续存储区域，若有多个作业装入主存，则它们可并发执行。
使用大小相等的固定分区有两个难点：程序可能太大而不能放到一个分区中，内存的，利用率很低。由于被装入的数据块小于分区大小，从而导致分区内部有浪费现象，成为“内部碎片”。对与大小不等的分区策略，最简单的方法就是把每个进程分配到能够容纳它的最小分区中。
目前已经基本上没有什么场合使用固定分区。
优势：实现简单，只需要极少的操作系统开销
缺点：有内部碎片，对内存的使用不充分，活动进程的最大数目是固定的。
可变分区： 可变分区存储管理不是预先把内存中的用户区域划分成若干固定分区，而是在作业要求装入内存时，根据用户作业的大小和当时内存空间使用情况决定是否为该作业分配一个分区。因此分区大小不是预先固定的，而是按作业需求量来划分的；分区的个数和位置也不是预先确定的。它有效地克服了固定分区方式中，由于分区内部剩余内存空置造成浪费的问题。
可变分区方式常用的内存分配算法有以下几种：
1、 最先适应分配算法
每次分配总是顺序查找空闲区表，找到能满足长度要求的空闲区就分配。优点是实现简单，缺点是可能将大的空闲区分割成许多小的空闲区，形成许多不连续的“碎片”。碎片长度可能不能满足作业要求，降低了内存利用率。
改进方法，可把空闲区按地址顺序从小到大登记在空闲区表中，有利于大作业。问题是归还空区时须按地址插入表中适当位置。
2、最优适应分配算法
按作业要求从所有空闲区中挑选一个能满足要求的最小空闲区，这样保证不去分割一个更大的区域，使装入大作业时比较容易得到满足。实现办法：将空闲区按长度以递增次序登记在表中，分配时按空闲区表顺序查找即可。缺点是可能碎片更小而无法使用。回收时也要按长度扦入。
3、最坏适应分配算法
这种算法总是挑选一个最大的空闲区分割一部分给作业使用，使剩下部分不致太小，仍可供分配使用。实现办法：空闲区表中的登记项按空闲区长度递减顺序排列，按序查找分配。
题目描述：动态分区式存贮区管理 设计一个动态分区式存贮区管理程序，要求支持不同的放置策略。如首次、最佳、最坏。 说明： （1）分区描述器rd如下: flagsizenext 要求空闲区队列按链表组织。 主存大小假设为maxsize（单位为节=rd的大小）。 （2）主程序结构如下： 输入放置策略 申请一块内存作为主存 循环处理用户的请求（包括申请、释放） 需设计两个函数处理用户请求：
申请函数 Addr=Request(size)释放函数 Release(addr） （3）数据实例：maxsize=512 J1申请162，J2申请64，J3申请120，J4申请86，J1完成， J3完成，J5申请72，J6申请100，J2完成，J7申请36， J8申请60，J4完成， J9申请110，J10申请42。 备注：
（a）所有大小其单位为节（1节=rd的大小）（b）作业申请n节,实际分配的分区大小应为n+1节。 其中一节作为分区描述器，其他n节提供给作业。（c）已分配区放在高地址处。（d）合并时应考虑四种情况： 假设回收区为r,上邻为f1（f1需搜索自由主存队列）,下邻为f2（f2可直接计算）
A)f1空闲，f2已分配；
B)f1已分配，f2空闲；
C)f1空闲，f2空闲；
D)f1已分配，f2已分配； 设计思路： 向系统申请内存：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76eae8ac386bba96b7d5e1af379f5abb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c5b716a9511f586991f52693d688f8/" rel="bookmark">
			Hadoop单机配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hadoop单机配置记录
1、配置环境
1)VMware虚拟机，centos7最小化安装
2、centos最小化安装默认不开启网络
1)开启网络
命令：vi /etc/sysconfig/network-scripts/ifcfg-ens33 #版本不同最后文件名略有不同
修改最后一行ONBOOT=yes
2)重启网络服务
命令：service network restart
3)查看ip
命令：ip add
3、开启ssh服务
命令：sudo service sshd start
1)注：如果没有ssh请安装
yum list installed | grep openssh-server
参考：https://www.cnblogs.com/kinwing/p/11134179.html
4、配置免密
1)ssh-keygen -t dsa -P ''
2)cat ./.ssh/id_dsa.pub &gt;&gt; ./.ssh/authorized_keys
4、关闭防火墙
1)查看防火墙状态：systemctl status firewalld.service
2)关闭防火墙：systemctl stop firewalld.service
3)设置开机不启动：systemctl disable firewalld.service
5、安装JDK配置环境变量
1)解压java包 tar -zxvf ./OpenJDK11U-jdk_x64_linux_openj9_linuxXL_11.0.10_9_openj9-0.24.0.tar.gz
2)vi /etc/profile
3)JAVA_HOME JRE_HOME CLASSPATH PATH 的配置
export JAVA_HOME=/usr/jdk-11.0.10+9
export JRE_HOME=/usr/jdk-11.0.10+9
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9c5b716a9511f586991f52693d688f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e84663887cac409dc104bf8b1c50b3/" rel="bookmark">
			分别用 mpi 和 cuda 实现圆周率 pi 的 Lebniz级数计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分别用 mpi 和 cuda 实现圆周率 pi 的 Lebniz级数计算 突然发现今天是3月14日，3.14，圆周率日，所以准备搞搞新花样，用并行的方式计算一串长长的级数求和。时间所限，所以暂时先搞一个粗糙的版本。这里分别尝试用 mpi 和 cuda 来计算 pi 的 级数求和公式，求和项数越多，结果越精确。因为求和的项与项之间没有前后依赖，所以可以并行实现，每个核承担一部分的求和任务。
最简单的方式是用莱布尼兹求和公式 pi / 4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + …, 这是计算 pi 的最简单的公式（arctan(1.) 的泰勒展开式），但也是收敛速度最慢的，时间所限先将就用着，后面有时间再去用更高级的公式以及用数组实现任意长整数来计算pi的更多位数。
莱布尼兹求和公式每计算 n 项，与精确值之间的误差可以缩小到大概 1/ 2n, 比如如果要计算 128 G （≈ 0.1T ≈ 10^11）项之和，则大概可以使结果精确到第小数点后第11位，我们试试计算 128 G 的项数，看看需要多长时间。
首先是 mpi, 用多个 cpu 并行计算，代码如下： #include "mpi.h" #include &lt;time.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;iostream&gt; #define ll long long using namespace std; int main(int argc, char** argv) { ll N = 128 * (ll)1 &lt;&lt; 30; // items for summation int proc_id, proc_num; double local = 0, total = 0, recv; MPI_Status status; clock_t begT, endT; begT = clock(); MPI_Init(&amp;argc, &amp;argv); // initialize of MPI MPI_Comm_size(MPI_COMM_WORLD, &amp;proc_num); // number of processors MPI_Comm_rank(MPI_COMM_WORLD, &amp;proc_id); // id of this processor local = 0; /// compute PI by summation of array ll batch_size = N / proc_num; ll base = proc_id * batch_size; for (ll id = batch_size - 1; id &gt; -1; --id) { // for (ll i = proc_id; i &lt; N; i += proc_num) { ll i = base + id; local += ((i &amp; (ll)1)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92e84663887cac409dc104bf8b1c50b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7597c4ed7a2d43d9912cfbd4837d0621/" rel="bookmark">
			react对特定的错误请求进行处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在有些需要我们对错误信息的错误码errorCode进行判断，对特定的错误进行不同的处理，这时候需要怎么做呢？
1 借助ahooks里的useRequest
利用 useRequest里的onError可以轻松获取到请求失败时 拿到的错误信息
同时对错误信息进行处理
2 借助 try catch
在 catch 参数 error 中拿到错误信息 进行判断 同时除了特定的错误外，我们需要对其他错误进行抛出
当然办法还有很多 在此仅仅记录一下 比较实用的俩个方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a6d838dad8aa67742d8c4fd55ebf45d/" rel="bookmark">
			mac版本mysql8.0&#43;面板无法启动解决方法（安装&#43;卸载干净&#43;无法启动问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
多次尝试用Start按钮多次，仍无法变绿启动，无论是重启电脑还是重装
1.安装：
这是最新下载版本：https://dev.mysql.com/downloads/ 进去选择MySQL Community Server 大概 就一步到底即可，中间有一次选择，选第一个密码方式就行 然后要输入一次root数据库密码，输入八位记住，例如：12345678 之后链接数据库要用到（选择默认路径安装） 2.解决无法启动
原因是由于mysql版本跟mac系统版本兼容性问题，解决方法：用vim命令，打开终端，一行代码即可打开，输入一次主机密码，如下：
sudo /usr/local/mysql/support-files/mysql.server start （关闭是stop） 其实就是进入目录，启动了这个服务 目录在控制面板这里，点击目录即可进入 3.卸载
面板卸载无效的话
终端：cd /user/local sudo rm -rf mysql* 两句搞定，或者手动目录删除，查找所有mysql相关，简单粗暴
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1924a7de68e7f9b509331934f760be84/" rel="bookmark">
			c#报错 ：System . Invalid Operation Exception:“线程间操作无效: 从不是创建控件的线程访问它
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题来源
跨线程操作时会报错：System.InvalidOperationException:“线程间操作无效: 从不是创建控件的线程访问它。
二、问题代码
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; using System.Threading.Tasks; using System.Windows.Forms; //using MSExcel = Microsoft.Office.Interop.Excel; using System.Reflection; using System.IO; namespace WindowsFormsApp1 { public partial class Form1 : Form { List&lt;string&gt; savedData; public string stra = null; public string strs = null; public string stra1 = null; public string stra2 = null; String[] recevedData; string path; public string filename; Thread th; Thread thWriteExcel; Socket socketSend; bool isCollecting = false; string datadirection = null; int numData; //收到的数据个数； public Form1() { InitializeComponent(); numData = 0; savedData = new List&lt;string&gt;(); } private void label6_Click(object sender, EventArgs e) { Form3 form = new Form3(); form.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1924a7de68e7f9b509331934f760be84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf780593807dbd600f9285a3982c9c3/" rel="bookmark">
			redis升级（离线）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从此地址下载最新安装包http://download.redis.io/releases/----redis安装包下载路径
查看当前版本命令
查看redis的版本有两种方式：
redis-server --version 和 redis-server -v redis-cli --version 和 redis-cli -v
此处使用版本3.2.11与3.2.13演示，从步骤一下载3.2.13上传到服务器（使用xftp）
查看redis进程，命令为：ps -ef|grep redis
杀死redis进程
使用命令：kill -9 进程号
解压安装包3.2.13，命令为：tar -zxvf redis-3.2.13.tar.gz
解压后如下图所示
进入新上传解压后的最新版本文件夹内；cd redis-3.2.13/
执行编译命令：make，
make介绍：make 是一个命令工具，它解释 Makefile 中的指令（应该说是规则）。在 Makefile文件中描述了整个工程所有文件的编译顺序、编译规则
执行命令安装，make install
执行命令redis-server --version；可以看到版本已经升级成功
redis介绍
Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。
Redis 与其他 key - value 缓存产品有以下三个特点：
Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。
Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。
丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cf780593807dbd600f9285a3982c9c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d153f240aa51276f0343b14f0263381d/" rel="bookmark">
			Error creating document instance. Cause: org.xml.sax.SAXParseException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因 因为语句中有一个小于号“&lt;”,在XML中，会被当成一个页面元素来解析，不会处理为mysql的SQL语句的组成部分，&lt;不会被xml解析而不是Mybatis不支持&lt;（不要理解错了哦）
想要知道问题的答案可以点击下方连接呦 解决方案，点我了解呦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8661c5ed1eb44dc026b574c842423087/" rel="bookmark">
			Mybatis xml中SQL处理小于号与大于号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目编译过程中，会出现如下错误 Caused by: org.apache.ibatis.builder.BuilderException: Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 693; columnNumber: 27; The content of elements must consist of well-formed character data or markup. at org.apache.ibatis.parsing.XPathParser.createDocument(XPathParser.java:263) at org.apache.ibatis.parsing.XPathParser.&lt;init&gt;(XPathParser.java:127) at org.apache.ibatis.builder.xml.XMLMapperBuilder.&lt;init&gt;(XMLMapperBuilder.java:81) at com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean.buildSqlSessionFactory(MybatisSqlSessionFactoryBean.java:592) ... 75 common frames omitted 根据错误提示信息（创建文档实例时出错。原因：xml异常），然后找到xml查看
&lt;select id="findYesterdayOrderByGroupBatchId" resultType="com.touchealth.physical.bo.order.OrderBo"&gt; select * from trd_order where order_state in (1, 2) and checkup_type = 2 and created_time &gt;= #{startTime} and created_time &lt;= #{endTime} and deleted_flag = 0 and group_batch_id in &lt;foreach collection="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8661c5ed1eb44dc026b574c842423087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3575e0e34b8b9b9bd0b77e8d1f67aca/" rel="bookmark">
			SpringBoot实现发送邮件、发送微信公众号推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot实现发送邮件、发送微信公众号推送 文章目录 SpringBoot实现发送邮件、发送微信公众号推送SpringBoot实现发送邮件pom.xmlapplication.yml代码实现 SpringBoot实现发送微信公众号推送pom.xml代码实现 SpringBoot实现发送邮件 JavaMailSender是Spring封装的邮件发送封装类，支持普通文本、附件、html等格式。
pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; application.yml 我们这里用QQ邮箱发送邮件作为例子，首先需要在QQ邮箱中开启POP3/SMTP，获得授权码。
需在application.yml中加入的配置如下：
spring: mail: host: smtp.qq.com username: xxxxxxxx@qq.com # 这个不是QQ密码，而是自己邮箱-账户-开启POP3/SMTP时的客户端授权码 password: xxxxxxxxx default-encoding: utf-8 protocol: smtp properties: mail: smtp: auth: starttls: # 需要TLS认证 保证发送邮件安全验证 enable: true required: true 代码实现 带附件的格式发送邮件需要借助JavaMailSender对象的createMimeMessage()方法创建的实例MimeMessage作为发送对象，而设置邮件参数通过MimeMessageHelper对象完成。
我们创建EmailUtil工具类，在其中定义sendMail方法进行邮件发送，EmailUtil完整代码如下：
@Component public class EmailUtil { @Value("${spring.mail.username}") private String from; @Resource private JavaMailSender javaMailSender; public boolean sendMail(String email, String subject, String text) { MimeMessage mimeMessage = javaMailSender.createMimeMessage(); try { MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); // 设置发件人 mimeMessageHelper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3575e0e34b8b9b9bd0b77e8d1f67aca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d549b12fc5594e8ee89da6bd93238cf5/" rel="bookmark">
			centos安装配置hadoop超详细过程（含故障排除）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、集群部署介绍
1.1 Hadoop简介
Hadoop是Apache软件基金会旗下的一个开源分布式计算平台。以Hadoop分布式文件系统（HDFS，Hadoop Distributed Filesystem）和MapReduce（Google MapReduce的开源实现）为核心的Hadoop为用户提供了系统底层细节透明的分布式基础架构。
对于Hadoop的集群来讲，可以分成两大类角色：Master和Salve。一个HDFS集群是由一个NameNode和若干个DataNode组成的。其中NameNode作为主服务器，管理文件系统的命名空间和客户端对文件系统的访问操作；集群中的DataNode管理存储的数据。MapReduce框架是由一个单独运行在主节点上的JobTracker和运行在每个集群从节点的TaskTracker共同组成的。主节点负责调度构成一个作业的所有任务，这些任务分布在不同的从节点上。主节点监控它们的执行情况，并且重新执行之前的失败任务；从节点仅负责由主节点指派的任务。当一个Job被提交时，JobTracker接收到提交作业和配置信息之后，就会将配置信息等分发给从节点，同时调度任务并监控TaskTracker的执行。
从上面的介绍可以看出，HDFS和MapReduce共同组成了Hadoop分布式系统体系结构的核心。HDFS在集群上实现分布式文件系统，MapReduce在集群上实现了分布式计算和任务处理。HDFS在MapReduce任务处理过程中提供了文件操作和存储等支持，MapReduce在HDFS的基础上实现了任务的分发、跟踪、执行等工作，并收集结果，二者相互作用，完成了Hadoop分布式集群的主要任务。
1.2 环境说明
集群中包括4个节点：1个Master，3个Salve，节点之间局域网连接，可以相互ping通，具体集群信息可以查看"Hadoop集群（第2期）"。节点IP地址分布如下：
机器名称
IP地址
Master.Hadoop
192.168.1.2
Salve1.Hadoop
192.168.1.3
Salve2.Hadoop
192.168.1.4
Salve3.Hadoop
192.168.1.5
四个节点上均是CentOS6.0系统，并且有一个相同的用户hadoop。Master机器主要配置NameNode和JobTracker的角色，负责总管分布式数据和分解任务的执行；3个Salve机器配置DataNode和TaskTracker的角色，负责分布式数据存储以及任务的执行。其实应该还应该有1个Master机器，用来作为备用，以防止Master服务器宕机，还有一个备用马上启用。后续经验积累一定阶段后补上一台备用Master机器。
1.3 网络配置
Hadoop集群要按照1.2小节表格所示进行配置，我们在"Hadoop集群（第1期）"的CentOS6.0安装过程就按照提前规划好的主机名进行安装和配置。如果实验室后来人在安装系统时，没有配置好，不要紧，没有必要重新安装，在安装完系统之后仍然可以根据后来的规划对机器的主机名进行修改。
下面的例子我们将以Master机器为例，即主机名为"Master.Hadoop"，IP为"192.168.1.2"进行一些主机名配置的相关操作。其他的Slave机器以此为依据进行修改。
1）查看当前机器名称
用下面命令进行显示机器名称，如果跟规划的不一致，要按照下面进行修改。
hostname
上图中，用"hostname"查"Master"机器的名字为"Master.Hadoop"，与我们预先规划的一致。
2）修改当前机器名称
假定我们发现我们的机器的主机名不是我们想要的，通过对"/etc/sysconfig/network"文件修改其中"HOSTNAME"后面的值，改成我们规划的名称。
这个"/etc/sysconfig/network"文件是定义hostname和是否利用网络的不接触网络设备的对系统全体定义的文件。
设定形式：设定值=值
"/etc/sysconfig/network"的设定项目如下：
NETWORKING 是否利用网络
GATEWAY 默认网关
IPGATEWAYDEV 默认网关的接口名
HOSTNAME 主机名
DOMAIN 域名
用下面命令进行修改当前机器的主机名（备注：修改系统文件一般用root用户）
vim /etc/sysconfig/network
通过上面的命令我们从"/etc/sysconfig/network"中找到"HOSTNAME"进行修改，查看内容如下：
3）修改当前机器IP
假定我们的机器连IP在当时安装机器时都没有配置好，那此时我们需要对"ifcfg-eth0"文件进行配置，该文件位于"/etc/sysconfig/network-scripts"文件夹下。
在这个目录下面，存放的是网络接口（网卡）的制御脚本文件（控制文件），ifcfg- eth0是默认的第一个网络接口，如果机器中有多个网络接口，那么名字就将依此类推ifcfg-eth1，ifcfg-eth2，ifcfg- eth3，……。
这里面的文件是相当重要的，涉及到网络能否正常工作。
设定形式：设定值=值
设定项目项目如下：
DEVICE 接口名（设备,网卡）
BOOTPROTO IP的配置方法（static:固定IP， dhcpHCP， none:手动）
HWADDR MAC地址
ONBOOT 系统启动的时候网络接口是否有效（yes/no）
TYPE 网络类型（通常是Ethemet）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d549b12fc5594e8ee89da6bd93238cf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cabe27ec4d44ad7684ca497d8bbb5bad/" rel="bookmark">
			UE4中实现PBKDF2加密验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UE4中Crypto++库加密解密 第三节：UE4中实现PBKDF2加密验证
文章目录 UE4中Crypto++库加密解密前言代码1. C++代码2. 蓝图 测试结果参考 前言 通过哈希算法进行加密。因为哈希算法是单向的，可以将任何大小的数据转化为定长的“指纹”，而且无法被反向计算。另外，即使数据源只改动了一丁点，哈希的结果也会完全不同。这样的特性使得它非常适合用于保存密码，因为我们需要加密后的密码无法被解密，同时也能保证正确校验每个用户的密码。但是哈希加密可以通过字典攻击和暴力攻击破解。
密码加盐。盐是一个添加到用户的密码哈希过程中的一段随机序列。这个机制能够防止通过预先计算结果的彩虹表破解。每个用户都有自己的盐，这样的结果就是即使用户的密码相同，通过加盐后哈希值也将不同。为了校验密码是否正确，我们需要储存盐值。通常和密码哈希值一起存放在账户数据库中，或者直接存为哈希字符串的一部分。
提示：以下是本篇文章正文内容，下面案例可供参考
代码 首先要生成一个盐值salt，再把原始密码和salt加密得到密文。验证的时候，把用户输入的密码和同样的盐值salt使用相同的加密算法得到一个密文，将这个密文和原密文相比较，相同则验证通过，反之则不通过。
以下为实现逻辑：
1. C++代码 MyPBKDF2.h
#pragma once #include "CoreMinimal.h" #include "../ThirdParty/crypto/include/Win64/config_int.h" #include "../ThirdParty/crypto/include/Win64/pwdbased.h" #include "../ThirdParty/crypto/include/Win64/sha.h" #include "../ThirdParty/crypto/include/Win64/hex.h" #include "../ThirdParty/crypto/include/Win64/cryptlib.h" #include "../ThirdParty/crypto/include/Win64/blake2.h" #include "../ThirdParty/crypto/include/Win64/files.h" #include "../ThirdParty/crypto/include/Win64/aes.h" #include "../ThirdParty/crypto/include/Win64/modes.h" #include "../ThirdParty/crypto/include/Win64/pubkey.h" using namespace CryptoPP; #include "Kismet/BlueprintFunctionLibrary.h" #include "MyPBKDF2.generated.h" /** * */ UCLASS() class TEST_API UMyPBKDF2 : public UBlueprintFunctionLibrary { GENERATED_BODY() public: //PBKDF2算法 //验证密码 UFUNCTION(BlueprintCallable, meta = (DisplayName = "authenticate", Keywords = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cabe27ec4d44ad7684ca497d8bbb5bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e27b476ea43e62f0197be49d67a77dc2/" rel="bookmark">
			python 多线程请求带参数的多个接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 多线程请求带参数的多个接口 对于进程/线程/携程/异步的内容 有时间准备写写了 真的一直用for去循环慢到怀疑人生 需要运用的场景也会很多 所以分开一点点总结一下 先上代码看一下内容，多线程请求接口
imoprt threading # 首先运用到threading模块 class BrushGifts: # 以下是两个相同的接口 send_gift_room_one()是送礼的接口 # 也就是说我想完成的状态是A送B B送A 两个用户同时想对方赠送礼物 def giftt(self, uid, recvUid, giftId): """ 送礼接口 :param uid: 送礼用户 :param recvUid: 收礼用户 :param giftId: 礼物道具id :return: """ VoiceRoom().send_gift_room_one(uid, recvUid, giftId) def giftt_a(self, uid, recvUid, giftId): # 与上面的接口相同 不多做叙述 # 没什么区别 就是写着好理解俩接口的概念 VoiceRoom().send_gift_room_one(recvUid, uid, giftId) if __name__ == '__main__': # 因为我的账号是储存在yaml文件内 所以需要先倒出需要用户的uid列表 # 送礼人与收礼人分别倒出 uid_list = YamlHandler(YamlThePath().voice_room_cpNew).get_uid_list(10) rUid_list = YamlHandler(YamlThePath().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e27b476ea43e62f0197be49d67a77dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a7b3e50e89ce87d3ef205f1eb2dbbf2/" rel="bookmark">
			CSS 设置鼠标的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的几种 1、crosshair光标呈现为十字线。
1、pointer 光标呈现为指示链接的指针(一只手)
3、move 此光标指示某对象可被移动。
4、e-resize 此光标指示矩形框的边缘可被向右(东)移动。
5、text 此光标指示文本。
6、wait 此光标指示程序正忙(通常是一只表或沙漏)。
&lt;style&gt; .default:hover{ cursor: default; /* 默认光标（通常是一个箭头) */ } .auto:hover{ cursor: auto; /*默认。浏览器设置的光标*/ } .crosshair:hover{ cursor: crosshair; /*光标成十字线*/ } .pointer:hover{ cursor:pointer; /*光标呈现为指示链接的指针（一只手）*/ } .move:hover{ cursor: move; /*此光标指示某对象可被移动。*/ } .e-resize:hover{ cursor: e-resize; /*此光标指示矩形框的边缘可被向右（东）移动。*/ } .text:hover{ cursor: text; /* 此光标指文本 */ } .wait:hover{ cursor: wait; /*此光标指示程序正忙（通常是一只表或沙漏）*/ } .help:hover{ cursor: help; /*此光标指示可用的帮助(通常是一个问号或一个气球)。*/ } &lt;/style&gt; 详细 参见菜鸟教程：CSS cursor 属性 | 菜鸟教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7b6d0c9535e792b9881f01331ffe24/" rel="bookmark">
			环计数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环计数问题 Statement 假设 n n n个元组成一个环, 每个元都是 1 , … , r 1,\dots,r 1,…,r中的一个数, 两个环是不同的当且仅当它们不能通过旋转使得两个环对应的每个元素都相等.
Solution 如果我们现在先考虑链的情况, 那么一个长度为 n n n的链, 每个元素是 1 , … , r 1,\dots,r 1,…,r中的一个数的方案数为 r n r^n rn.
我们设 f x f_x fx​表示最小循环节为 x x x的环的方案数. 则我们可以得到如下性质.
性质1: r n = ∑ d ∣ n d f ( d ) r^n=\sum\limits_{d|n}df(d) rn=d∣n∑​df(d). 上式的组合意义就是, 我不妨考虑 n n n元环是存在循环节的, 那循环节长度必然得是 n n n的因子. 也就是 a 1 , a 2 , … , a d , a d + 1 , … , n a_1,a_2,\dots,a_d,a_{d+1},\dots,n a1​,a2​,…,ad​,ad+1​,…,n循环节长度为 d d d则有 a 1 = a d + 1 , a 2 = a d + 2 , … a_1=a_{d+1},a_2=a_{d+2},\dots a1​=ad+1​,a2​=ad+2​,….
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c7b6d0c9535e792b9881f01331ffe24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc5fef38104960e4cb63cd6d962d5f3/" rel="bookmark">
			2.多线程并发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.说说你知道的创建线程的方式 1、继承Thread类，重写run方法。2、实现Runnable接口，重写run方法。3、实现Callable接口，重写call方法。4、通过线程池创建线程。
https://blog.csdn.net/u013541140/article/details/95225769
CachedThreadPool:可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。 SecudleThreadPool:周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。
SingleThreadPool:只有一条线程来执行任务，适用于有顺序的任务的应用场景。
FixedThreadPool:定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程
我们在用阿里巴巴代码检测工具检测时 “线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：线程池中的线程数量；
maximumPoolSize：线程池中的最大线程数量；
keepAliveTime：当线程池线程数量超过corePoolSize时，多余的空闲线程会在多长时间内被销毁；
unit：keepAliveTime的时间单位；
workQueue：任务队列，被提交但是尚未被执行的任务；
threadFactory：线程工厂，用于创建线程，一般情况下使用默认的，即Executors类的静态方法defaultThreadFactory()；handler：拒绝策略。当任务太多来不及处理时，如何拒绝任务
https://blog.csdn.net/bojikeqian/article/details/120946609
2.说说Callable Callable的call方法提供返回值，所以当你需要知道任务执行的结果时，Callable是个不错的选择。
Callable任务通过线程池的submit方法提交
class IntegerCallableTask implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i &lt; 520; i++) { sum += i; } return sum; } } Callable任务通过线程池的submit方法提交。且submit方法返回Future对象，通过Future的get方法可以获得具体的计算结果。而且get是个阻塞的方法，如果任务未执行完，则一直等待。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc5fef38104960e4cb63cd6d962d5f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a6a876de929e8aa8ce6982ac7f0769/" rel="bookmark">
			低代码和无代码的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间以来，低代码和无代码开发平台一直都是IT界的热门话题。相关领域的专家正在推测低代码和无代码将会以何种方式改变这一行业的未来。有预测称，随着低代码和无代码产品持续刷新解决方案开发的新途径，传统的IT将会逐渐衰落。不过，在讨论低代码和无代码的后续发展之前，我们需要先知道这些术语的真正含义。
什么是低代码/无代码？ 低代码和无代码工具能促进软件扩展和最大化软件的交付。下图列出了低代码工具和无代码工具的相关解释、定义和区别。
需要注意的是，不能把两个概念混为一谈，因为它们针对的业务目标不同，面向的受众也不同。为了更好地了解这些技术的发展，需要了解这些类型工具的注意事项以及它们的演变过程。
低代码和编程语言的演变 从历史角度评估低代码框架的持续发展和未来是最好的理解。简化和自动化这两项艰巨的任务从信息技术行业发展之初就已经开始了。首先是从数字机器代码到汇编符号的改变，这一改变成倍地提高了程序员的生产力。下一次飞跃紧随其后，第一个高级语言 (HLL) 短代码（或短命令代码）在一年后诞生。再快进到60年之后的今天，HLL 和无数有用的框架层出不穷，所有这些都是为了尽可能地简化或自动化开发任务。
因此，在这个时候，许多情况下再去编写自定义 HLL 解决方案无异于多此一举，改用现有的云服务或是现有的工具要有效得多。虽然仍然可以通过“脚本任务”使用传统编码进行自定义，但开发人员可以更多地依赖预定义函数，使用更为方便的图形界面提高工作速度。这种自动生成代码的同时，还能根据需要引入较低级别自定义的能力，是低代码和无代码之间的主要区别。
无代码注意事项和问题 随着无代码平台在业界中使用率的不断提高，充分了解无代码可提供的优势以及其过程中应注意的事项变得尤为重要：
依赖性 就像其他任何由第三方提供的服务一样，公司的无代码平台最终可能会从“合作关系” 演变成一种硬性的 “依赖关系”。尽可能保持“供应商中立”方法，避免依赖某一单一供应商。
安全性 需要知道平台对于公司数据的保护程度，以及有无有供应商披露公司数据。不过，有的时候，数据安全的最大威胁来自内部员工对平台设置的不熟悉，从而导致信息的意外泄露。
可扩展性 一个能够随着业务需求增长的平台，需得支持大量数据，容纳更多客户，有着更强的处理能力和执行能力。
价格 选择与当前处理量相符合的订阅级别或付款计划，同时还需得考虑到公司的未来发展。不要为了增加资源而被迫承担高昂的费用。
预定义功能 无代码方案有意限制了自定义功能，为的是拉平学习曲线，减少开发时间和成本。因此，如果无代码平台行使的功能超出其预定范围，很可能会导致应用程序不稳定或无法支持。
类似产品 很多公司正在探索快上市、低成本，不需要大量人力资源支出的方案。这种相同的追求目标会使得同一平台的产品有着相似的外观。
总结 虽然IT行业内对此问题一直有争议，但是大家都认为，在中短期内，低代码仍将保持其在“自动化”解决方案市场的主导地位。无代码平台还不够成熟，产品开发的简易性和功能的复杂性无法同时实现。另一方面，有充分证据表明，一些IT公司和专业人士开始将关注点从传统的 HLL 开发转到低代码框架。如果这种趋势继续发展下去，我们可能很快就会见证软件开发的另一次飞跃，类似于从机器代码到汇编代码的转变。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a2df92b814b96e846db610fb7b054f/" rel="bookmark">
			紫薇盘反推出生年月时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		紫薇反推 紫薇盘反推出生年月时肯定有的 紫薇盘反推出生年月时 最近在学习紫薇，但是有些盘隐去了出生时间，这样就很难分析，有办法反推吗？我在网上找了半天没找到。
肯定有的 我看了一些资料，用算法实现了。比较粗糙，但也能用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64dc959f87ae1e061ddba85c9629405/" rel="bookmark">
			mybatis plus的springboot配置方式和mvc配置方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
mybatis plus的springboot配置方式和mvc配置方式
1、MybatisPlus的springboot的配置方式
1.1、配置application.properties
1.2、MybatisPlusConfig配置
2、mvc配置
2.1、配置properties
2.2、MybatisPlusConfig配置
2.3、SqlLogInterceptor
2.4、TransactionalConfig
1、MybatisPlus的springboot的配置方式 1.1、配置application.properties #mybatis-plus mybatis-plus.type-aliases-package=com.xx.archive.* mybatis-plus.mapper-locations=classpath:dao/*.xml mybatis-plus.global-config.db-config.table-underline=true #mybatis-plus.global-config.db-config.column-underline=true mybatis-plus.global-config.db-config.id-type=auto #下面这句打开的时候是可以进行 打印sql到控制台 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 1.2、MybatisPlusConfig配置 @Configuration public class MybatisPlusConfig { /* * 分页插件，自动识别数据库类型 * 多租户，请参考官网【插件扩展】 */ @Bean public PaginationInterceptor paginationInterceptor() { PaginationInterceptor page = new PaginationInterceptor(); page.setDialectType("mysql"); return page; } /** * SQL执行效率插件(打印sql) */ @Bean public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); return performanceInterceptor; } } 2、mvc配置 2.1、配置properties #mybatis-plus config mybatis-plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d64dc959f87ae1e061ddba85c9629405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439cfad63e7939a8715cf9517651f55c/" rel="bookmark">
			习题2.8 输出全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 请编写程序输出前n个正整数的全排列（n&lt;10），并通过9个测试用例（即n从1到9）观察n逐步增大时程序的运行时间。
思路 回溯算法，回溯算法主要就是适用于暴力破解，在时间足够的情况下运用递归穷举。
代码 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define N 10 void BackTracking(int start,int index); void Print(); int n; int pr[N],visit[N]; void main(){ int i; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) visit[i]=0; BackTracking(1,0); system("pause"); } void BackTracking(int start,int index){ int i; if(index==n){ Print(); return ; } for(i=start;i&lt;=n;i++){ if(!visit[i]){ pr[index]=i; visit[i]=1; BackTracking(1,index+1); visit[i]=0; } } } void Print(){ int i; for(i=0;i&lt;n;i++){ printf("%d",pr[i]); } printf("\n"); } 总结 学会运用回溯算法真的可以解决很多题目，例如组合，排列，求子集问题等都是明显的回溯算法的应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec72814e1f32feb7aa83f6b9b38c7f4/" rel="bookmark">
			Matlab机器人仿真（五）：利用DH法建立六轴机器人（复现，整合，记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DH法包括两种：一种为标准DH法，另一种为改进型DH法，如图所示（图片转载来自https://blog.csdn.net/qq_26565435/article/details/91460988）：
例子：建立一个常见的简单3轴机器人：
在建立一个常见的六轴机器人：
例子如图所示：
case1:
case 2:
case 3:
在matlab中建立机械臂模型
MATLAB代码：
%%利用标准D-H法建立多轴机器人 clear; clc; L1 = Link('d', 5, 'a', 5, 'alpha', -pi/2,'offset',0); %Link 类函数;offset建立初始的偏转角 L2 = Link('d', 0, 'a', 20, 'alpha', 0, 'offset',0); L3 = Link('d', 0, 'a', 5, 'alpha', -pi/2,'offset',0); L4 = Link('d', 20, 'a', 0, 'alpha', pi/2,'offset',0); L5 = Link('d', 0, 'a', 0, 'alpha', -pi/2,'offset',0); L6 = Link('d', 10, 'a', 0, 'alpha', 0, 'offset',0); L1.qlim = [-pi/2,pi];%利用qlim设置每个关节的旋转角度范围 robot=SerialLink([L1,L2,L3,L4,L5,L6],'name','S725'); %SerialLink 类函数 %% 普通机器人的示教展示 robot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec72814e1f32feb7aa83f6b9b38c7f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19a422211c0542ac1774b494851c84bc/" rel="bookmark">
			ubuntu更换内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu更新之后发现内核版本升级了，如果想用回原来的内核：
sudo vim /etc/default/grub
修改：
GRUB_DEFAULT="1&gt;2" #GRUB_TIMEOUT_STYLE=hidden GRUB_TIMEOUT=10 sudo update-grub
重启之后可默认进入原来的内核版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c70acc513e13b10ac67ea1a7cab1331d/" rel="bookmark">
			mail发送邮件配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		邮件服务都会需要密码，以及邮件服务器等信息，修改配置文件，添加相关信息。
修改配置文件 vim /etc/mail.rc
smtp服务器认证的用户名 set from=test@qq.com
smtp服务器的地址 set smtp=smtp.exmail.qq.com
邮件认证的方式 set smtp-auth=login
smtp服务器认证的用户名 set smtp-auth-user=QQ号
smtp服务器认证的用户密码(授权码) set smtp-auth-password=test_password
忽略验证 set ssl-verify=ignore
set nss-config-dir=/etc/maildbs/
发送邮件 echo “邮件内容” | mail -s “邮件主题” -a 附件 收件地址
授权码获取方式 QQ邮箱
设置-账户-生成授权码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c2c0835a6fcde3c463d3f3e5c95a7c/" rel="bookmark">
			linux中zookeeper升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.官网下载最新稳定版 Zookeeper官网：https://zookeeper.apache.org/
2.将软件上传到zookeeper所在服务器 使用rz命令或使用连接工具
3.解压缩 tar -zxvf zookeeper-3.7.0.tar.gz
4.原配置文件，id文件，创建数据目录 cp zookeeper/conf/zoo.cfg zookeeper-3.7.0/conf/
mkdir zookeeper-3.7.0/data
cp zookeeper/data/myid zookeeper-3.7.0/data/
备注：可直接将原来zookeeper版本中的配置文件拷贝到新版目录下，id文件也需拷贝
5.修改zoo.cfg配置文件中的dataDir、dataLogDir配置 vi zoo.cfg
dataDir=zookeeper-3.7.0/data
备注：修改为新版本的data目录
6.关闭旧版本，启动新版本，查看状态 zookeeper/bin/zkServer.sh stop
zookeeper-3.7.0/bin/zkServer.sh start
zookeeper-3.7.0/bin/zkServer.sh status
升级辅助命令 查看zookeeper版本命令：echo stat|nc 127.0.0.1 2181 。
如有报错：stat is not executed because it is not in the whitelist.
需开启四字命令，在zoo.cfg末尾添加：4lw.commands.whitelist=*
重启zookeeper
查看2181端口： netstat -nltp | grep 2181
Mode: standalone ，即单机模式启动。
需要在zoo.cfg中添加集群服务对应服务节点及端口
修改hosts文件，以便可以通过域名访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a9b7c543a28da300e23df233fb910c/" rel="bookmark">
			linux服务器openSSH升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修复流程
下载安装包 &gt; 备份旧版 ssh 配置 &gt; 安装依赖包 &gt; 其他准备工作 &gt; 编译安装 &gt; 创建软连接等文件 &gt; 修改配置允许 root 登录 &gt; 配置开机启动 &gt; 检查是否安装成功 &gt; 完成
风险概述
此方案升级过程不会关闭旧版 ssh 服务，无需担心安装失败无法导致远程连接。如果服务器在外地机房且无人值守，请谨慎操作。
修复依据 根据漏洞原理修复
操作前提 无
查看版本：openssh -V
具体操作步骤如下：
步骤 1 1）下载最新版源码包
下载地址： https://www.openssh.com/releasenotes.html
2）上传包至服务器
cd home ,rz本地传送（若未找到命令yum install -y lrzsz）
步骤 2 备份旧版 SSH
mv /usr/sbin/sshd /usr/sbin/sshd.old
mv /usr/bin/ssh /usr/bin/ssh.old
如果旧版本是源码安装的 OpenSSH，建议备份整个 openssh 目录：
mv /usr/local/openssh /usr/local/openssh.old
步骤 3 安装依赖
yum -y install zlib-devel openssl-devel gcc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61a9b7c543a28da300e23df233fb910c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d295c5d0c608d123ee2a26421155a41f/" rel="bookmark">
			Python笔记-SQLAlchemy Model转dict（主流方法，一行解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来是没有这篇笔记的，因为功能比较简单，感觉应该很多人都写过，但是百度后发现某园、某SDN都复杂得一逼。
而且抄来抄去，个人感觉不应该是这样，这个应该几行代码就搞定了。查了下外网，发现国外的大神还是牛逼，在此记录下，方便以后进行查阅
我的是这样的。
def getFundModel(self): retList = [] for ret in FundModel.query.all(): retList.append(ret.__dict__) pass return retList list中保存的已经是dict了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704a8adfcefa96bc5de9896c009290eb/" rel="bookmark">
			交换机初始配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：Packet Tracer
CLI命令行的几种模式 Switch&gt; #用户模式 Switch&gt;enable Switch# #特权模式 Switch#configure terminal Switch(config)# #全局模式 Switch(config)#int vlan 1 Switch(config-if)# #接口配置 Switch(config)#line vty 0 4 Switch(config-line)# #线路模式 基础配置 1、给交换机进行初始配置
Switch&gt;enable Switch#setup ... 前面有两个“yes”， Enter host name [Switch]: aaa #配置交换机的主机名 Enter enable password: zbzr0823 #设置交换机密码 Enter virtual terminal password: zbzr0823 #确认密码 Configure SNMP Network Management? [no]:no #不设置SNMP协议 management network from the above interface summary: vlan1 #选择要设置的接口 Configuring interface Vlan1: Configure IP on this interface? [yes]: yes #是否给交换机设置IP IP address for this interface: 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704a8adfcefa96bc5de9896c009290eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c4b2fcf4350e5b2bff757813a58749/" rel="bookmark">
			什么是广域网和局域网？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天遇到一个只是盲点: “什么是广域网？”
广域网 广域网，英语名字为Wide Area Network，缩写为 WAN，又称广域网、外网、公网。指的是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。一般所指的互联网是属于一种公共型的广域网。
局域网 局域网，英文名字Local Area Network，缩写为LAN。是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。
广域网和局域网的区别: 局域网（LAN）主要是指在小范围内的计算机互联网络，其范围要比广域网（WAN）小得多。
广域网上的每一台电脑都有一个或多个广域网IP地址，广域网IP地址一般要到ISP处交费之后才能申请到，广域网IP地址不能重复；局域网上的每一台电脑都有一个或多个局域网IP地址，局域网IP地址是局域网内部分配的，不同局域网的IP地址可以重复，不会相互影响。
扩展资料 局域网的特点： 覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。使用专门铺设的传输介质进行联网，数据传输速率高。通信延迟时间短，可靠性较高。局域网可以支持多种传输介质。 常见的局域网拓朴结构： 星形 这种结构的网络是各工作站以星形方式连接起来的，网中的每一个节点设备都以中防节为中心，通过连接线与中心 节点相连，如果一个工作站需要传输数据，它首先必须通过中心节点。
树形 树形结构网络是天然的分级结构，又被称为分级的集中式网络。其特点是网络成本低，结构比较简单。
总线形 总线形结构网络是将各个节点设备和一根总线相连。网络中所有的节点工作站都是通过总线进行信息传输的。作为总线的通信连线可以是同轴电缆、双绞线，也可以是扁平电缆。在总线结构中，作为数据通信必经的总线的负载能量是有限度的，这是由通信媒体本身的物理性能决定的。
环形 前言 今天遇到一个只是盲点: “什么是广域网？”
广域网 广域网，英语名字为Wide Area Network，缩写为 WAN，又称广域网、外网、公网。指的是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。一般所指的互联网是属于一种公共型的广域网。
局域网 局域网，英文名字Local Area Network，缩写为LAN。是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。
广域网和局域网的区别: 局域网（LAN）主要是指在小范围内的计算机互联网络，其范围要比广域网（WAN）小得多。
广域网上的每一台电脑都有一个或多个广域网IP地址，广域网IP地址一般要到ISP处交费之后才能申请到，广域网IP地址不能重复；局域网上的每一台电脑都有一个或多个局域网IP地址，局域网IP地址是局域网内部分配的，不同局域网的IP地址可以重复，不会相互影响。
扩展资料 局域网的特点： 覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。使用专门铺设的传输介质进行联网，数据传输速率高。通信延迟时间短，可靠性较高。局域网可以支持多种传输介质。 常见的局域网拓朴结构： 星形 这种结构的网络是各工作站以星形方式连接起来的，网中的每一个节点设备都以中防节为中心，通过连接线与中心 节点相连，如果一个工作站需要传输数据，它首先必须通过中心节点。
树形 树形结构网络是天然的分级结构，又被称为分级的集中式网络。其特点是网络成本低，结构比较简单。
总线形 总线形结构网络是将各个节点设备和一根总线相连。网络中所有的节点工作站都是通过总线进行信息传输的。作为总线的通信连线可以是同轴电缆、双绞线，也可以是扁平电缆。在总线结构中，作为数据通信必经的总线的负载能量是有限度的，这是由通信媒体本身的物理性能决定的。
环形 环形结构是网络中各节点通过一条首尾相连的通信链路连接起来的一个闭合环形结构网。环形结构网络的结构也比较简单，系统中各工作站地位相等。
环形结构是网络中各节点通过一条首尾相连的通信链路连接起来的一个闭合环形结构网。环形结构网络的结构也比较简单，系统中各工作站地位相等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe8812aed8188b23c55d7800f2eda21/" rel="bookmark">
			【指纹识别】基于模板匹配算法实现指纹录入打卡系统附matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 简介
指纹识别技术是生物识别技术的一种，正因为指纹具备唯一性和不变性等特征使得指纹识别技术已经被广泛的应用于身份鉴证等多种领域。一般而言，一个指纹数字图像识别系统通常由指纹数字图像预处理、特征提取、保存指纹数字图像及指纹数字图像匹配等四部分过程构成。　本文对指纹数字图像识别系统的原理和基本过程进行了较为深入的分析与研究。首先对指纹数字图像的分类、基本特征与识别原理进行了详细的论述。其次，在指纹数字图像预处理部分，本文主要对预处理的各个步骤：数字图像分割、数字图像增强、二值化、图像细化等含义及过程进行了详细的分析，并设计了一种合适的指纹数字图像预处理方案。然后详细的论述了指纹数字图像的特征提取与匹配过程，其中指纹数字图像的特征提取是从细化后的指纹数字图像图中提取出端点和分叉点，即细节特征点，此特征点会包含大量的伪特征，这样会非常耗时并且降低匹配的精度，而采用边缘去伪和距离去伪的方法能使伪特征点减少近1/3，然后再提取可靠特征点信息，从而实现指纹数字图像匹配，本文采用了基于MATLAB实现的指纹数字图像细节特征提取方式。在指纹数字图像匹配部分，本文采用基于细节点的指纹数字图像匹配算法，并进行了深入研究。最后，通过对指纹数字图像识别系统算法的详细研究，本文利用MATLAB工具设计并实现了一个指纹数字图像识别系统，完成了对指纹数字图像的处理、特征提取，保存和匹配等功能，利用编码对指纹数字图像进行入库、匹配等操作，从而完成图像的识别来判断是否同一指纹，其比对结果令人满意。
2 部分代码 function varargout = func_preproc(varargin)​A = varargin{1};​% A=imread('a.bmp');A=rgb2gray(A);j=medfilt2(A);% figure,imshow(j);B=imadjust(A,[0.2 0.8]);% figure;% subplot(2,2,1);imshow(A);% subplot(2,2,2);imhist(A);% subplot(2,2,3);imshow(B);% subplot(2,2,4);imhist(B);[x,y]=size(B);m=double(B);N=sqrt(100)*randn(x,y);I=m+N;for i=1:x for j=1:y if (I(i,j)&gt;255) I(i,j)=255; end if (I(i,j)&lt;0) I(i,j)=0; end endendz0=max(max(I));z1=min(min(I));T=(z0+z1)/2;TT=0;s0=0;n0=0;s1=0;n1=0;allow=0.5;d=abs(T-TT);count=0;while(d&gt;=allow) count=count+1; for i=1:x for j=1:y if(I(i,j)&gt;=T) s0=s0+I(i,j); n0=n0+1; end if(I(i,j)&lt;T) s1=s1+I(i,j); n1=n1+1; end end end T0=s0/n0; T1=s1/n1; TT=(T0-T1)/2; d=abs(T-TT); T=TT;endseg=zeros(x,y);for i=1:x for j=1:y if(I(i,j)&gt;=T) seg(i,j)=1; end endend% figure;% imshow(seg);BW1=bwmorph(seg,'spur');BW2=bwmorph(BW1,'fill');BW3=bwmorph(BW2,'clean');% figure;% imshow(BW3);​varargout{1} = BW3;​ 3 仿真结果 4 参考文献 [1]孙玉明,王紫婷.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbe8812aed8188b23c55d7800f2eda21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a34fe0ecd01348bab5ad97c65eaf99/" rel="bookmark">
			win10系统 笔记本 插入耳机有声音，外放无声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记本电脑有段时间未用，拿出后外放无声音，但插入耳机有声音。网上搜索后，确认硬件没问题，于是试了更新驱动，重装系统等方法都不行，并且也未找到Realtek。突然灵光一现,想到是不是喇叭坏了，拆开电脑一看，排线未接。
所以笔记本电脑外放没声音应首先排除硬件问题，耳机能使只能说明声卡没问题，但一定记得还有喇叭！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b19b0eda149c7b334358307d452789/" rel="bookmark">
			VS2019 创建类时报错：未注册类——解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 保存一下当前整个项目，关闭VS，重新打开VS就可以了，反正我的是这样的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4dcc4c0803a2c5e7de97f466034edb/" rel="bookmark">
			NPM配置阿里下载源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置阿里下载源 # 配置 npm config set registry https://registry.npm.taobao.org # 验证 npm config get registry 效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371349fc3d0583bd8818e33fd0f8e30c/" rel="bookmark">
			[案例2-2]小明可以买什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.任务描述
编写一个智能购物计算小程序，在一家商店有书本、铅笔、橡皮、可乐、零食五种商品，商品价格如下表所示。
商品名称
价格
书本
12元
铅笔
1元
橡皮
2元
可乐
3元
零食
5元
假如你带了
假如只带了20元，且必须购买一本书，剩余的钱还可以购买哪种商品，可以购买几件，购买完后又能剩余多少钱？
代码如下:
import java.util.Scanner; /** * 2022/1/24 */ public class anli2 { public static void main(String[] args) { Scanner in = new Scanner(System.in); int pencil=1; //铅笔价格 int rubber=2; //橡皮价格 int cola=3; //可乐价格 int book=12; //书本价格 int snacks=5; //零食价格 System.out.println("书本价格为" + book + "元,你一共有20元"); System.out.println("1,铅笔价格" + pencil + "元"); System.out.println("2,橡皮价格" + rubber + "元"); System.out.println("3,可乐价格" + cola + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/371349fc3d0583bd8818e33fd0f8e30c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa95af631e0a6c7946369041ee056678/" rel="bookmark">
			Linux驱动_spi驱动(ICM20608)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考： Linux SPI 驱动分析（1）— 结构框架_StephenZhou-CSDN博客_linux spi驱动
Linux SPI 驱动分析（2）— 框架层源码分析_StephenZhou-CSDN博客_spi_message_init
SPI驱动的框架和源码分析，可以在参考博客中查看。
驱动编写测试 ： 原理图如下所示：
LINUX下的SPI主机驱动已经由SOC厂商编写好了，比如I.MX6ULL的SPI主机驱动由NXP官方编写好了，我们编写设备驱动的时候主需要调用相应的api函数。 一、修改设备树 1、添加电气属性 使用芯片的spi控制器，肯定得配置相应的管脚复用，因此在 iomuxc 节点中添加一个新的子节点来描述 ICM20608 所使用的 SPI 引脚，子节点名字为 pinctrl_ecspi3，节点内容如下所示：
pinctrl_ecspi3: ecspi3grp { fsl,pins = &lt; MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 0x10B0	/*将管脚复用为GPIO模式，设置spi电气属性为0X10B0*/ MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK 0x10B1 MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI 0x10B1 MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO 0x10B1&gt;; }; #GPIO1_IO20为片选管脚，其余3个功能不用多说。
2、添加icm20608设备信息 &amp;ecspi3 { fsl,spi-num-chipselects = &lt;1&gt;;	/*一个片选信号*/ cs-gpios = &lt;&amp;gpio1 20 GPIO_ACTIVE_LOW&gt;;	/*软件片选引脚,低电平有效*/ pinctrl-names = "default"; pinctrl-0 = &lt;&amp;pinctrl_ecspi3&gt;; status = "okay"; /*对应的spi子节点*/ spidev0: icm20608@0 {	/*@后面的0表示spi芯片接到哪个硬件片选上,本实验硬件上接到了0，但使用的是软件片选*/ reg = &lt;0&gt;;	/*required*/ compatible = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa95af631e0a6c7946369041ee056678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c763b47a1bd60e8090d447c58fab1e/" rel="bookmark">
			Seata下载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。
版本说明 下载Seata 根据springcloud alibaba版本说明下载对应的Seata版本，否则可能会出现各种版本不兼容的问题。
下载地址：https://github.com/seata/seata/releases
安装Seata 资源包下载地址：https://github.com/seata/seata/tree/develop/script
以下步骤按照DB存储为例。
解压Seata安装包如果使用DB存储，需要在数据库中创建表。（执行资源包中的sql文件script -&gt; server -&gt; db -&gt; mysql.sql）
打开配置文件（seata -&gt; conf -&gt; file.conf）修改store.mode=“db”修改数据库连接配置url、username、password
到这里就完成了Seata的基本配置，执行seata/bin/seata-server.bat启动Seata，默认使用本地的配置。 Seata配置Nacos配置中心、注册中心 打开配置文件（seata -&gt; conf -&gt; registry.conf）修改registry.type=“nacos”修改注册中心nacos连接配置
修改config.type=“nacos”修改配置中心nacos连接配置
将资源包script放在seata安装目录下打开配置文件（seata -&gt; script -&gt; config-center -&gt; config.txt）修改store.mode=“db”修改数据库连接配置url、username、password
运行脚本就可以将配合同步至nacos在（seata -&gt; script -&gt; config-center -&gt; nacos）目录下运行命令 # 如果nacos不在本地，可以通过参数指定nacos服务的IP、端口、groupId、命名空间 liunx: ./nacos-config.sh -h localhost -p 8848 -g SEATA_GROUP -t 命名空间 # python脚本中分组是固定写死的，自定义需要修改脚本 python: nacos-config.py localhost:8848 命名空间 执行seata/bin/seata-server.bat再次启动Seata使用就是nacos中的配置了。
Seata在liunx中启动参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c763b47a1bd60e8090d447c58fab1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c965ce1bb70258a9532f9db6e4338851/" rel="bookmark">
			计算机系统概论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机系统概论 重点内容
（一）计算机系统层次结构 计算机系统的基本组成计算机硬件的基本组成计算机软件和硬件的关系计算机系统的工作原理 （二）计算机性能指标 吞吐量、响应时间、CPU时钟周期、主频、CPI、CPU执行时间MIPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS 计算机系统层次结构 ​ 硬件系统和软件系统共同构成了一个完整的计算机系统。硬件是指有形的物理设备，是计算机系统中实际物理装置的总称。软件是指在硬件上运行的程序和相关的数据及文档。
计算机硬件 冯·诺依曼机的特点 ​ 冯·诺依曼在研究EDVAC机（离散变量自动电子计算机）时提出了“存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯·诺依曼机。
"存储程序"的基本思想是：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，就无须操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束。
​ 其特点如下：
采用“存储程序”的工作方式。计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部分组成。指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。指令和数据均用二进制代码表示。指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序。机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成。 计算机的功能部件 运算器 ​ 用来完成算数运算和逻辑运算，并将运算的中间结果暂存在运算器内。
​ 运算器是计算机的执行部件，用于进行算术运算和逻辑运算。算术运算是按算术运算规则进行的运算，如加减乘除；逻辑运算包括与、或、非、异或、比较、移位等运算。
​ 运算器的核心是算术逻辑单元（ALU）。运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等。（现代计算机内部往往设有通用寄存器组）
​ 运算器最少包括3个寄存器（ACC、MQ、X）和一个 ALU 。
​ 运算器内还有程序状态寄存器（PSW），也称标志寄存器，存放 ALU 运算得到的一些标志信息或处理机的状态信息，如结果溢出，结果是否为负等。
存储器 ​ 用来存放数据和程序。
​ 存储器分为主存储器（又称内存储器）和辅助存储器（又称外存储器）。CPU能够直接访问的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存后，才能为CPU所访问。
​ 主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式。
​ 主存储器的最基本组成如图所示。存储体存放二进制信息，**地址寄存器（MAR）**存放访存地址，经过地址译码找到所选的存储单元。数据寄存器（MDR）用于暂存要从存储器中读或写的信息，时序控制逻辑用于产生存储器操作所需的各种时序信号。
​ 存储体由许多存储单元组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进制代码。因此存储单元可以存储一串二进制代码，称这串代码为存储字，称这串代码的位数为存储字长，存储字长可以是1B或是字节的偶数倍。
​ MAR 的位数对应着存储单元的个数。 MDR 的位数和存储字长相等。
注意：MAR 与 MDR 虽是存储器的一部分，但在现代计算机中却是存在于CPU中的。
控制器 ​ 用来控制、指挥程序和数据的输入、运行以及处理运算结果。
1.解释指令 2.保证指令按序进行
​ 控制器是计算机的神经中枢，由其指挥各部件自动协调地工作。控制器由程序计数器（PC）、指令寄存器（IR）和控制单元（CU）组成。
​ PC 用来存放即将执行指令的地址，可以自动加一形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路。
​ IR 用来存放当前的指令，其内容来自主存的 MDR 。指令中的操作码 OP（IR）送至 CU ，用以分析指令并发出各种微操作命令序列；而地址码 Ad（IR）送往 MAR ，用以取操作数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c965ce1bb70258a9532f9db6e4338851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2e807e349da55a9ccc062ac55c5143/" rel="bookmark">
			单调栈讲解 &#43; AcWing 830. 单调栈（双指针优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单调栈 常见模型：给定一个序列，求 序列当中的每一个元素左侧 离它最近，且比它小/大 的元素 或 右侧 离它最近，且比它小/大 的元素
举个例子，比如给定一个序列：3、4、2、7、5
我们要找到每一个元素左侧，且最近的比它小的数是什么，如果不存在返回 -1
第一个元素 3 左侧没有比它小的数，返回 -1，第二个元素 4 左侧比它小的数且最近的数是 3，因此返回 3，后面的元素以此类推，如下图，第一行是原序列，第二行是返回的答案。
单调栈思考方式和双指针类似：先想想暴力做法是什么，之后挖掘出一些性质，将目光集中在比较少的状态中，从而起到将时间复杂度降低的效果。
暴力做法 时间复杂度为 O(n^2)，当数据达到1e5显然会超时
for(int i=0; i&lt;n; ++i) //枚举原序列中的每一个数 for(int j=i-1; j&gt;=0; --j) //从a[i]左侧第一个数a[i-1]开始往左枚举 if(a[i]&gt;a[j]) //知道找到a[i]左侧第一个比a[i]小的数a[j]为止 { printf("%d ", a[j]); //答案 break; } 看看暴力做法中有什么可以挖掘的性质，
对于暴力做法，随着第一重循环 i 往右枚举，我们可以用一个栈存储 i 左侧所有元素，初始时栈为空，i 指针每往右移动一个位置就会往栈中新添一个元素，因此当枚举到 a[i] 时，其左侧所有元素：a[0]、a[1]、...、a[i-1] 都会被加入栈中，当我们要找答案的时候，我们从栈顶开始往下查找，找到第一个比 a[i] 小的数则 break
若要进行优化，我们显然应该将重点放在栈上，分析一下 栈中是否有些元素一定不会被作为答案输出，
举个例子，假设在栈中有 a[3] ≥ a[5]，那么 a[3] 一定不会在后续中作为答案输出，
因为：a[5] 在 a[3] 的右侧，且 a[5] ≤ a[3]，当我们找答案时，如果 a[3] 是目标值，则意味着 a[3] &lt; a[i]，又由于 a[5] ≤ a[3]，因此 a[5] 也小于 a[i]，我们显然要查找离 a[i] 最近且比 a[i] 小的元素，则 a[3] 一定不会被用作答案输出，那么我们一定可以换成 a[5] 作为更优的答案
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af2e807e349da55a9ccc062ac55c5143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db84e22da867b0f47633ac9e1986184f/" rel="bookmark">
			STM32CubeIDE使用技巧（FreeRTOS点亮一盏灯)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32CubeIDE使用技巧（FreeRTOS点亮一盏灯 1 概述1.1 资源概述1.2 芯片简介 2 软件实现,使用STM32CubeIDE2.1 STM32CubeIDE 生成代码2.2.1 修改Task代码2.2.2 STM32CubeIDE自动补全2.2.3 STM32CubeIDE使用VIM编辑器2.3 编译下载程序2.4 下载问题解决2.4.1 问题1解决2.4.2 问题2解决2.4.3 问题3解决 2.5 调试2.6 cubeIDE工程无法导入无法编译问题解决 3 使用STM32CubeIDE在电脑端输出hello world.3.1建立工程3.2 写入代码3.3 工程编译3.4 编译后运行3.5注意事项3.6 windows中运行 1 概述 1.1 资源概述 开发板：STM32F103C8T6最小系统板
开发环境：Ubuntu+STM32CubeIDE
主控芯片型号：STM32F103C8T6
左侧为STLINK烧录器（ST的Nucleo板），右侧为目标板
1.2 芯片简介 C8T6只有64K ROM和20K Ram，比较小，但是可以实现FreeRtos的移植。选择用IDE工具比较香，不用自己写makefile文件，对于菜鸟来说还是实用很多。通过CubeIDE可以实现程序生成编译下载调试等一条龙工作。
2 软件实现,使用STM32CubeIDE 2.1 STM32CubeIDE 生成代码 在Ubuntu下安装STM32CubeIDE，STM32CubeIDE内嵌的程序编辑器其实是Eclipse。免费的无需破解，更佳的是ST 提供了windows，linux版本以及MACOS版本，也就是可以在不同平台无缝切换。打开程序，使用内置的CubeMx配置工具配置芯片，勾选FreeRTOS，由于只有一个任务，因此保持默认配置即可。
FreeRTOS配置
2.2.1 修改Task代码 在生成的Task里边增加LED的相关代码
void StartDefaultTask(void const * argument) { for(;;) { HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);//翻转LED0灯 osDelay(300); } } main函数如下
int main(void) { HAL_Init(); SystemClock_Config(); MX_GPIO_Init(); osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);//默认一个任务 defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);//创建任务 osKernelStart();//启动任务 while(1) {} } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db84e22da867b0f47633ac9e1986184f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22754c61cae59ae45cdd1d71e30c48c6/" rel="bookmark">
			机器学习方法——举例分析决策树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 机器学习——决策树决策树的工作原理构造剪枝造成过拟合的原因：泛化能力：剪枝的方法： 如何判断要不要去打篮球？纯度信息熵1. ID3 算法：2. C4.5 算法：1）采用信息增益率：2）采用悲观剪枝：3）离散化处理连续属性：4）处理缺失值： 3. 比较总结： 机器学习——决策树 在现实生活中，我们会遇到各种选择，不论是选择男女朋友，还是挑选水果，都是基于以往的经验来做判断。如果把判断背后的逻辑整理成一个结构图，你会发现它实际上是一个树状图，这就是我们今天要讲的决策树。
决策树的工作原理 决策树基本上就是把我们以前的经验总结出来。如果我们要出门打篮球，一般会根据“天气”、“温度”、“湿度”、“刮风”这几个条件来判断，最后得到结果：去打篮球？还是不去？
上面这个图就是一棵典型的决策树。我们在做决策树的时候，会经历两个阶段：构造和剪枝。
构造 构造就是生成一棵完整的决策树。简单来说，构造的过程就是选择什么属性作为节点的过程，那么在构造过程中，会存在三种节点：
根节点：就是树的最顶端，最开始的那个节点。在上图中，“天气”就是一个根节点；内部节点：就是树中间的那些节点，比如说“温度”、“湿度”、“刮风”；叶子节点：就是树最底部的节点，也就是决策结果。 节点之间存在父子关系。比如根节点会有子节点，子节点会有子子节点，但是到了叶子节点就停止了，叶子节点不存在子节点。那么在构造过程中，你要解决三个重要的问题：
选择哪个属性作为根节点；选择哪些属性作为子节点；什么时候停止并得到目标状态，即叶子节点。 剪枝 剪枝就是给决策树瘦身，这一步想实现的目标就是，不需要太多的判断，同样可以得到不错的结果。之所以这么做，是为了防止“过拟合”（Overfitting）现象的发生。
欠拟合正常过拟合指的是模型的训练结果不理想指的是模型训练结果较合适指的是模型的训练结果“太好了”，以至于在实际应用的过程中，会存在“死板”的情况，导致分类错误 造成过拟合的原因： 一是因为训练集中样本量较小。如果决策树选择的属性过多，构造出来的决策树一定能够“完美”地把训练集中的样本分类，但是这样就会把训练集中一些数据的特点当成所有数据的特点，但这个特点不一定是全部数据的特点，这就使得这个决策树在真实的数据分类中出现错误，也就是模型的“泛化能力”差。
泛化能力： 指的分类器是通过训练集抽象出来的分类能力，你也可以理解是举一反三的能力。如果我们太依赖于训练集的数据，那么得到的决策树容错率就会比较低，泛化能力差。因为训练集只是全部数据的抽样，并不能体现全部数据的特点。
剪枝的方法： 预剪枝：在决策树构造时就进行剪枝。方法是，在构造的过程中对节点进行评估，如果对某个节点进行划分，在验证集中不能带来准确性的提升，那么对这个节点进行划分就没有意义，这时就会把当前节点作为叶节点，不对其进行划分。后剪枝：在生成决策树之后再进行剪枝。通常会从决策树的叶节点开始，逐层向上对每个节点进行评估。如果剪掉这个节点子树，与保留该节点子树在分类准确性上差别不大；或者剪掉该节点子树，能在验证集中带来准确性的提升，那么就可以把该节点子树进行剪枝。方法是：用这个节点子树的叶子节点来替代该节点，类标记为这个节点子树中最频繁的那个类。 如何判断要不要去打篮球？ 我们该如何构造一个判断是否去打篮球的决策树呢？再回顾一下决策树的构造原理，在决策过程中有三个重要的问题：将哪个属性作为根节点？选择哪些属性作为后继节点？什么时候停止并得到目标值？
显然将哪个属性（天气、温度、湿度、刮风）作为根节点是个关键问题，在这里我们先介绍两个指标：纯度和信息熵。
纯度 你可以把决策树的构造过程理解成为寻找纯净划分的过程。数学上，我们可以用纯度来表示，纯度换一种方式来解释就是让目标变量的分歧最小。
举个例子，假设有 3 个集合：
集合 1：6 次都去打篮球；集合 2：4 次去打篮球，2 次不去打篮球；集合 3：3 次去打篮球，3 次不去打篮球。 按照纯度指标来说，集合 1&gt; 集合 2&gt; 集合 3。因为集合1 的分歧最小，集合 3 的分歧最大。
信息熵 表示信息的不确定度。
在信息论中，随机离散事件出现的概率存在着不确定性。为了衡量这种信息的不确定性，信息学之父香农引入了信息熵的概念，并给出了计算信息熵的数学公式： E n t r o p y ( t ) = − Σ p ( i ∣ t ) l o g 2 p ( i ∣ t ) Entropy(t)=-\Sigma p(i|t)log_2p(i|t) Entropy(t)=−Σp(i∣t)log2​p(i∣t)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22754c61cae59ae45cdd1d71e30c48c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa231926ca7c094cb7d828a2bf2a87a4/" rel="bookmark">
			通俗理解聚集索引和非聚集索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库的索引，听起来挺神秘的，仔细想想。这些索引，其实就是平时咱们查东西时候常用的两种手段。无非就是为了提高我们找东西的效率而已。那么我们平时又是怎么查东西呢？
聚集索引：
聚集索引，来源于生活尝试。这中索引可以说是按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对这堆记录 进行 堆划分。即主要描述的是物理上的存储。
举个例子：
比如图书馆新进了一批书。那么这些书需要放到图书馆内。书如何放呢？一般都有一个规则，杂志类的放到101房间，文学类的放到102房间，理工类的放到103房间等等。这些存储的规则决定了每本书应该放到哪里。而这个例子中聚集索引为书的类别。
正式因为这种存储规则，才导致 聚集索引的唯一性。
误区：
有的人认为，聚集索引的字段是唯一的。这是因为sql server 中添加主键的时候，自动给主键所在的字段生成一个聚集索引。所以人们会认为聚集索引所加的字段是唯一的。
思考一下上面这个问题。杂志类的书放到101房间。那么如果杂志类的书太多，一个101房间存放不下。那么可能101，201两个房间来存放杂志类的书籍。如果这样分析的话，那么一个杂志类对应多个房间。放到表存储的话，那么这个类别字段 就不是唯一的了。
非聚集索引：
非聚集索引，也可以从生活中找到映射。非聚集索引强调的是逻辑分类。可以说是定义了一套存储规则，而需要有一块控件来维护这个规则，这个被称之为索引表。
继续使用上述提到的例子：
同学如果想去图书馆找一本书，而不知道这本书在哪里？那么这个同学首先应该找的就是 检索室吧。对于要查找一本书来说，在检索室查是一个非常快捷的的途径了吧。但是，在检索室中你查到了该书在XX室XX书架的信息。你的查询结束了吗？没有吧。你仅仅找到了目的书的位置信息，你还要去该位置去取书。
对于这种方式来说，你需要两个步骤：
1、查询该记录所在的位置。
2、通过该位置去取要找的记录。
区别：
聚集索引：可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了。
非聚集索引：把一个很大的范围，转换成一个小的地图。你需要在这个小地图中找你要寻找的信息的位置。然后通过这个位置，再去找你所需要的记录。
索引与主键的区别
主键：主键是唯一的，用于快速定位一条记录。
聚集索引：聚集索引也是唯一的。（因为聚集索引的划分依据是物理存储）。而聚集索引的主要是为了快速的缩小查找范围，即记录数目未定。
主键和索引没有关系。他们的用途相近。如果聚集索引加上唯一性约束之后，他们的作用就一样了。
使用场景
基于上述的两种规则，那么在什么时候适合聚集索引，什么时候适合非聚集索引？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c030a731044817fd29f55d133cefee53/" rel="bookmark">
			Python爬虫案例：批量下载超清画质手机壁纸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言开发环境模块使用 基本流程:一. 数据来源分析二. 代码实现步骤: 完整代码1. 发送请求2. 获取数据3. 解析数据4. 保存数据效果演示 前言 开发环境 Python 3.8Pycharm 模块使用 requests &gt;&gt;&gt; pip install requests 数据请求parsel &gt;&gt;&gt; pip install parsel 解析模块 (提取数据) 基本流程: 一. 数据来源分析 爬取网站是什么，想要获取网站什么样数据内容比如爬取图片，从一张图片去分析
通过开发者工具进行抓包分析, 对比我们想要图片url地址一些参数
二. 代码实现步骤: 发送请求, 对于分析得到url地址发送请求
请求网址
请求方式
请求头参数 &gt;&gt;&gt; 伪装 可以把python代码伪装成浏览器(客户端)发送请求
如果不进行伪装会有什么后果 &gt;&gt;&gt; 不会给你返回你想要数据获取数据, 获取response服务器返回响应数据解析数据, 提取我们想要数据内容 图片url地址 以及 图片标题保存数据, 把图片数据保存到本地 完整代码 1. 发送请求 headers 请求头参数, 可以开发者工具里面直接进行复制, 其次headers字典数据类型, 键值对
user-agent: 用户代理 表示浏览器基本身份标识
cookie: 用户信息, 检测用户是否有登陆账号
for page in range(2, 11): url = f'https://sj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c030a731044817fd29f55d133cefee53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d49e46e0ec90dc587110c33c6c7492/" rel="bookmark">
			Easyexcel导出带下拉框选项excel模板（解决下拉框超50个的问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为了避免excel下拉框选项过多会导致内容不显示（或者生成的时候报错：String literals in formulas can't be bigger than 255 characters ASCII easyexcel），将下拉框的内容都存储在另一个新建的固定的sheet页，再通过引用公式关联单元格的下拉框内容，从而形成能够存储多数值的下拉框。
2、导出代码（这里演示的是一次性导出多个模板，采用压缩包的形式下载，并且表头是动态的）：
/** * 导出模板 * @param response * @param businessViewId */ @Override public void exportTemplate(HttpServletResponse response, String businessViewId) throws IOException { String[] split = businessViewId.split(","); String zipName = "模板.zip"; response.setCharacterEncoding("utf-8"); response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE); response.setHeader("Content-Disposition", "attachment;filename*=UTF-8''" + URLEncoder.encode(zipName, "UTF-8")); ServletOutputStream out = response.getOutputStream(); ZipOutputStream zipOutputStream = new ZipOutputStream(out); for (String viewid : split) { List&lt;BusinessField&gt; field = baseMapper.findBusinessFieldByViewId(viewid); //根据表id查询父表id String parentId = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d49e46e0ec90dc587110c33c6c7492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1260c2c58c788dcb5f89616c5164f6b/" rel="bookmark">
			JavaScript游戏购物车项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑软件:HBuilderX
项目展示
登陆界面
注册界面
主界面
文件链接
项目展示 登陆界面 登陆界面html和js
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;登陆界面&lt;/title&gt; &lt;link rel="stylesheet" href="./login.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;section&gt; &lt;p class="text"&gt; 时间不是你的敌人，永恒才是。——《异界镇魂曲》 &lt;/p&gt; &lt;/section&gt; &lt;h2 class="h2" id="h2"&gt; &lt;span&gt;I&lt;/span&gt;M&lt;span&gt;POSSIBLE&lt;/span&gt; &lt;/h2&gt; &lt;div id="dd"&gt; &lt;h4 id="tt" class="h2" style="font-size: 40px;text-align: center;"&gt; &lt;span style="margin:20px 0px 0px 35px ;"&gt;欢迎登陆&lt;/span&gt; &lt;/h4&gt; &lt;form id="myForm"&gt; &lt;p&gt; &lt;input placeholder="输入用户名" id="uname" type="text" onkeyup="checkLable(this,/^[a-zA-Z]{3,6}$/)"/&gt; &lt;span class="xx"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;input placeholder="输入密码" id="upwd" type="password" onkeyup="checkLable(this,/^\w{6,10}$/,)"/&gt; &lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1260c2c58c788dcb5f89616c5164f6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/620aa4876ece46fc1f73eefb3cfac5d0/" rel="bookmark">
			数据结构基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是数据结构？ 答：数据结构研究的是数据以及数据之间的关系和运算，即数据结构就是指数据以及数据之间的关系和运算。（计算机的操作对象就是数据）
2、算法是什么？ 答：算法是对计算机上执行的计算过程的具体描述。
3、算法和数据结构的关系？
答：算法依赖于具体的数据结构，数据结构直接关系到算法的选择和效率。
4、数据结构产生的原因？
由于应用问题的复杂程度不断增加、信息量剧增与信息范围的拓宽，导致程序规模越来越大，程序结构更加复杂，为了解决这些问题必须研究数据之间的关系，数据结构由此而生。
数据结构的基本术语 数据：数据结构中的数据是指可以输入到计算机中并可以被计算机识别、存储和加工处理的符号，是计算机处理的信息的符号化表现形式，例如声音、图像、文本、视频、整数、实数等都可以用数据来表示。
数据元素：数据元素是数据的基本单位，也是数据结构中讨论的基本单位，简称元素。一个数据元素可以包含一个简单的数据项，如一个实数，也可以包含多个不同类型或者相同类型的数据项，如一名教师、一本图书、一件商品信息等都包含多个数据项，数据元素可以是具体的，也可以是抽象的，如一次旅游、一次会议、一次考试等，一个客观存在的事件都可以是数据元素。
数据项：数据项是数据的不可分割的最小单位，又称数据域，数据项也是数据结构讨论的最小单位，数据元素是数据项的集合。例如一名教师信息包括年龄、身高、体重、教师编号、性别等，教师信息是数据元素，年龄等信息是数据项，教师信息这个数据元素有年龄等数据项组成。
数据对象：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如：整数数据对象={0，±1，±2，...},数据对象可以是有穷集，也可以是无穷集。
数据结构：结构是把成员组织在一起的方式，数据结构就是以数据为成员的结构，数据结构就是把数据元素组织在一起的方式，是带结构的数据元素的集合，数据元素之间存在着一种或多种特定的关系。例如：在银行办业务的队列中，每个顾客不仅有个人信息，还有相互之间的先后顺序关系，地图上每个城市除了有城市名称等数据信息外还有相互之间的位置关系。
结点：数据结构中的数据元素称为结点，在研究实际问题时，一个结点可以是用高级语言的基本数据类型表示的信息，例如一个字符、一个整数，还可以是由基本数据类型的某种组成方式构成的复杂信息，如：学生的基本信息等。数据结构将结点看成一个整体，重点讨论结点之间的关系。
数据处理：数据处理是指对数据元素处理的方式，包括对数据的增、删、改、查、排序等基本操作，也包括对数据元素的分析操作。
数据结构研究学习的三个方面：
数据的逻辑结构：在数据集合中，各种数据元素之间固有的逻辑关系。
数据的存储结构：在对数据进行存储时，各数据元素在计算机中的存储关系。
数据结构的操作：各种数据结构要进行的操作，以及基于计算机中的存储方式如何实现这些操作，简单来说就是说各种数据结构都有哪些操作以及如何实现这些操作。
数据元素之间的关系：具有相同特征的数据元素集合中，通常数据元素之间固有的关系用前驱和后继关系描述；一般来说，数据元素之间的任何关系都可以用前驱和后继关系来描述。
数据的逻辑结构 数据的逻辑结构定义了数据结构中数据元素之间的逻辑关系。
逻辑结构包含两方面信息：1、数据元素的信息；2、各数据元素之间的关系。
将数据的逻辑结构定义：一个数据结构是一个二元组：Date_Structures=(D,R); 其中D是数据元素的有限集，R是D上关系的有限集。
一般以二元组的形式表示D中各数据元素之间的关系；例如：a与b是D中两个数据元素；a与b之间的关系用&lt;a,b&gt;,表示a是b的前驱，b是a的后继，每两个相邻元素之间的关系都可以用这种形式表示。
数据结构还可以用图形表示：每一个数据元素用中间标有元素值的方框和圆表示，数据元素之间的前驱后继关系用一条从前驱指向后继的又向线段表示。
根据数据结构中各数据元素之间的前驱和后继关系的复杂程度，将逻辑结构分为线性结构和非线性结构。
线性结构 线性结构的特征是数据元素之间存在“一对一”的线性关系。
满足这三个条件的数据结构就是线性结构：
1、有且仅有一个没有前驱的结点，通常将该节点称为根节点。
2、除了根节点没有前驱、最后一个结点没有后继之外，其他结点都是一个前驱一个后继。
3、线性结构在删除或插入任何一个结点后还是线性结构。
线性结构的图形表示方式：
非线性结构 非线性结构的特征是一个结点可能有多个前驱和后继。
树状结构 树状结构指数据元素之间存在“一对多”关系的数据结构。在树状结构中，除了根节点没有前驱，其余每个结点有且只有一个前驱，除了叶子结点没有后继，其余每个结点的后继结点数可以是一个也可以是多个。
树状结构图形表示方式：
网状结构 网状结构中，数据元素间的关系可以是任意的，任意两个数据元素之间都可以关联，一个结点可以有一个或多个前驱结点，也可以有一个或多个后继结点。
图形表示方式：
集合结构 集合结构中，数据元素之间除了同属一个集合外，相互之间没有任何关系，结点之间没有任何前驱和后继的关系。
图形表示方式：
数据的存储结构 数据的存储结构也叫数据的物理结构，是指数据的逻辑结构在计算机存储空间中的存放形式，包含结点的数据和结点间关系的存储表示。数据的存储结构依赖于具体的计算机程序，只在高级语言的层面讨论数据的存储结构。
顺序存储结构 把逻辑上相邻的数据元素，存储在物理位置也相邻的存储单元里，通过存储单元的邻近关系来体现数据元素之间的逻辑关系，这样的结构称为顺序存储结构，主要应用于线性的数据结构。
顺序存储结构只存储结点的数据，不存储结点之间相互关系信息。一般称为紧凑存储结构。
链式存储结构 各个数据元素存储位置随意，不要求逻辑上相邻的数据元素在物理位置上相邻，结点间的逻辑关系用附加的指针域来表示，这种存储方式称为链式存储结构。
适用于线性结构和非线性结构。
适合表示因经常进行插入、删除等操作而频繁发生动态变化的数据结构。
索引存储结构 索引存储结构是顺序存储结构的一种推广，用于大小不等的结点的顺序存储。所有数据元素按照顺序存储方式存储，此外增设一个索引表，表中的索引项一般形式是：（关键字，地址），关键字唯一标识一个结点的数据项，地址是该结点的存储位置。这样的存储结构称为索引存储结构。
散列存储结构 存储方式借助一个hash函数，
散列存储结构的基本思想是根据结点的关键字通过散列函数直接计算出该结点的存储地址。各数据元素均匀分布在存储区里，用散列函数指示各数据元素的存储位置。
数据的操作 数据结构与施加于数据结构上的操作密切相关。每种逻辑结构都有一个操作的集合。数据的操作是定义在数据的逻辑结构上的，操作的具体实现则要在存储结构上进行。
常用的操作有：
创建：建立一个数据结构；
清除：清除一个数据结构；
插入：在数据结构中增加新的结点；
删除：把指定的结点从数据结构中删除；
访问：对数据结构中结点进行访问；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/620aa4876ece46fc1f73eefb3cfac5d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/234590a30434959cce71deffe8915688/" rel="bookmark">
			游戏 AI 设计之 FSM 有限状态机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FSM 有限状态机 一、概述 有限状态机（finite-state machine，缩写：FSM）又称有限状态自动机（finite-state automaton，缩写：FSA），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。
从历史上来说，有限状态机是一个被数学家用来解决问题的严格形式化的设备。在人工智能变成中，我们可以建 FSM 理解为：
一个有限状态机是一个设备，或是一个设备模型，具有有限数量的状态，它可以在任何给定的时间根据输入进行操作，使得从一个状态变换到另一个状态，或者是促使一个输出或者一种行为的发生。一个有限状态机在任何瞬间只能处在一种状态。
二、分析 有限状态机，一般称作 FSM。常作为游戏 AI 设计的首选，尽管更专业的智能体结构越来越普及，但 FSM架构依然流行的原因如下
编程快速简单
有很多方法编码一个有限状态机，并且几乎乎所有的有限状态机实现都相当的简单。易于调试
因为一个游戏智能体的行为被分解成简单的易于管理的块，如果一个智能体开始变得行动怪异，会通过对每一个状态增加跟踪代码来调试它。用这种方法，人工智能程序员可以很容易跟踪错误行为出现前的事件序列，并且采取相应的行动。计算开销小
有限状态机几乎不占用珍贵的处理器时间，因为它们本质上遵守硬件编码的规则。除了 if-this-then-that 类型的思考处理之外，是不存在真正的“思考”的。直觉性
人们总是自然地把事物思考为处在一种或另一种状态。并且我们也常常提到我们自己处在这样那样的状态中。有多少次你“使自己进入一种状态”或者发现自己处于“头脑的正确状态”。当然人类并不是像有限状态机一样工作，但是有时候我们发现在这种方式下考虑我们的行为是有用的，比如你处于口渴状态，你就会想去喝水。相似地，将一个游戏智能体的行为分解成一系列状态并且创建需要的规则来操作它们是相当容易的。出于同样的原因，有限状态机能够使你很容易地与非程序员（例如与游戏制作人和关卡设计师）来讨论你的人工智能的设计，能够更好地进行设计概念的沟通和交流。灵活性
一个游戏智能体的有限状态机可以很容易地由程序员进行调整，来达到游戏设计者所要求的行为。同样通过增添新的状态和规则也很容易扩展智能体的行为的范围。此外，当你的人工智能技术提高了，你会发现有限状态机提供了一个坚固的支柱，使你可以用它来组合其他的技术，例如模糊逻辑和神经网络。 三、代码实现 下面我们实现一个简易的游戏状态机
Hero 在没有攻击目标的时候是 Idle（待机） 状态在发现怪物时会切换到 Attack（攻击） 状态没有攻击目标 切回 Idle 状态发现 Boss 或 自身血量低于 10 的时候 切换到 Escape （逃跑）状态
状态转换示意图 1、StateMachine _curState：当前状态，用于表示当前 Entity 所处的状态
_preState：保存 Entity 的上一个状态，方便回溯
_globalState ：这是一个特殊的状态，可与 _curState 共存，引进全局状态的原因是为了解决一种优先级高的状态，可以保证在任意时刻切换到指定状态。比如模拟人生的游戏里面，有个人正在工作，突然想要上厕所，那么需要打断当前的状态（使用 _preState 记录）并切换到上厕所状态。在上完厕所后，又继续恢复工作（恢复上一个状态）。
public class StateMachine { private Entity _entity = null; private State _globalState = null; // 全局状态 private State _preState = null; // 上一个状态 private State _curState = null; // 当前状态 public State CurState { get =&gt; _curState; } private Dictionary&lt;StateType, State&gt; _dicState = null; public void Init(Entity entity, List&lt;string&gt; listStateName) { _entity = entity; _dicState = new Dictionary&lt;StateType, State&gt;(); if (null !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/234590a30434959cce71deffe8915688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/010ca8b1438158344705628021898336/" rel="bookmark">
			CSS3的 transition属性、transform属性，怎么才能让他同时执行多个不同的过渡、动画（变换属性）效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、如果要给一个Dom(html标签)元素，同时设置多个不同的CSS过渡(transition)属性值时， 在各个属性值之间用逗号(英文,) 隔开即可！！ 2、如果要给一个Dom(html标签)元素，同时设置多个不同的CSS变换(transform)属性值时， 在各个属性值之间用空格 隔开即可！！ 具体实例代码： div{ width: 100px; height: 100px; color: green; background: blue; &lt;!--这里是设置所有属性过渡时间--&gt; transition: all 1s; &lt;!--这里是分别指定设置：width、color、transform 三个样式属性的过渡！--&gt; transition: width 1.5s ease, color 0.8s, transform 1s 0.5s ease-in-out; } div:hover{ &lt;!--这里是同时分别设置了：旋转 缩放 扭曲 三个变换属性！--&gt; transform: rotate(360deg) scale(2, 2) skew(10deg, 5deg); } 注意1：在设置transition的属性值时，只能设置可以连续变化(如：widht, height, color, opacity, font-size等)属性！ 如果设置(display, position等)这种指定的，不能连续变化的属性时，在transition中没有过渡效果的哦！！ 注意2：当给dom元素同时设置多个变换transform属性时它们的执行顺序！ 顺序：是从后向前执行的哦！！ 例如：
transform: rotate(360deg) scale(2,2) skew(10deg,5deg); 在上面变换属性中会先执行skew(10deg,5deg) 再执行 scale(2,2) 最后再执行 rotate(360deg)
所以：顺序不同变换效果也会不同！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ce084e9222f350fd1022f66807e847/" rel="bookmark">
			apache-dolphinscheduler的使用问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（本文不定期更新） 目录
一、租户问题
二、指定虚拟python环境的python类型任务的执行时环境变量问题
三、资源中心创建目录或者文件失败
四、由zookeeper同步引起的shutdown问题
一、租户问题 本人使用环境是大家分别使用自己账户登录跳板机，然后共同使用同一个服务器linux账户进行工作，所以不涉及多个linux用户的切换问题（即dolphinscheduler的多租户）。但是共用账户本身没有root权限，需要找运维申请，但是权限时间有限。故在部署的时候就不使用root权限账户，而直接使用共用账户部署。然后下载源码后，将涉及“sudo -u”相关的命令注释掉或者改写，从而实现正常使用。
二、指定虚拟python环境的python类型任务的执行时环境变量问题 因为某些特殊任务需要使用虚拟python环境，独立进行worker分组，并指定该环境为dolphinscheduler-env.sh的PYTHON_HOME。但是在执行的时候，出现了报错：
找不到JAVA_HOME，这个是使用pyflink的时候，由pyflink在创建执行环境的时候报的错：
s_env = StreamExecutionEnvironment.get_execution_environment() 将该代码注释掉，加入代码：
import os
print('os的环境变量有：',os.system('env')) 查看到该次执行的JAVA_HOME为空：
但是dolphinscheduler-env.sh命名设置了JAVA_HOME，重启worker-server也不生效。
最终解决：设置该用户的环境变量（修改全局环境变量有风险，只修改该用户的即可）
vim ~/.bashrc
export JAVA_HOME=/usr
export PATH=$JAVA_HOME/bin:$PATH
因为使用which java是能够在/usr/bin目录找到可执行java的，所以只设置为/usr即可。
三、资源中心创建目录或者文件失败 api-server报的错，查看日志：
### The error occurred while setting parameters
### SQL: INSERT INTO t_ds_resources ( file_name, size, create_time, description, full_name, alias, update_time, pid, type, user_id, is_directory ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4ce084e9222f350fd1022f66807e847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb3944065297c573f6927ba75c852a51/" rel="bookmark">
			智能优化算法：麻雀搜索算法-附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020智能优化算法：麻雀搜索算法 文章目录 2020智能优化算法：麻雀搜索算法1.算法原理2.算法结果3.参考文献4.Matlab代码5.Python代码 摘要：麻雀搜索算法(Sparrow Search Algorithm, SSA)是于2020年提出的。SSA 主要是受麻雀的觅食行为和反捕食行为的启发而提出的。该算法比较新颖，具有寻优能力强，收敛速度快的优点 1.算法原理 建立麻雀搜索算法的数学模型，主要规则如下所述：
发现者通常拥有较高的能源储备并且在整个种群中负责搜索到具有丰富食物的区域，为所有的加入者提供觅食的区域和方向。在模型建立中能量储备的高低取决于麻雀个体所对应的适应度值(Fitness Value)的好坏。一旦麻雀发现了捕食者，个体开始发出鸣叫作为报警信号。当报警值大于安全值时，发现者会将加入者带到其它安全区域进行觅食。发现者和加入者的身份是动态变化的。只要能够寻找到更好的食物来源，每只麻雀都可以成为发现者，但是发现者和加入者所占整个种群数量的比重是不变的。也就是说，有一只麻雀变成发现者必然有另一只麻雀变成加入者。加入者的能量越低，它们在整个种群中所处的觅食位置就越差。一些饥肠辘辘的加入者更有可能飞往其它地方觅食，以获得更多的能量。在觅食过程中，加入者总是能够搜索到提供最好食物的发现者，然后从最好的食物中获取食物或者在该发现者周围觅食。与此同时，一些加入者为了增加自己的捕食率可能会不断地监控发现者进而去争夺食物资源。当意识到危险时，群体边缘的麻雀会迅速向安全区域移动，以获得更好的位置，位于种群中间的麻雀则会随机走动，以靠近其它麻雀。 在模拟实验中，我们需要使用虚拟麻雀进行食物的寻找，由n只麻雀组成的种群可表示为如下形式：
X = [ x 1 1 x 1 2 . . . x 1 d x 2 1 x 2 2 . . . x 2 d . . . . . . . . . . . . x n 1 x n 2 . . . x n d ] (1) X=\left[\begin{matrix} x_1^1&amp;x_1^2&amp;...&amp;x_1^d\\ x_2^1&amp;x_2^2&amp;...&amp;x_2^d\\ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb3944065297c573f6927ba75c852a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b663f89fe58106cac756c51d03165a30/" rel="bookmark">
			智能优化算法改进算法 -附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能优化算法改进算法 摘要：为了方便大家对智能优化算法进行改进，复现多种智能优化改进算法供大家参考。所有代码均根据已经发表的文章，来复现方便大家参考别人的原理，代码会不定时更新。
1.文献复现：基于变因子加权学习与邻代维度交叉策略的改进乌鸦算法Matlab代码
[1]赵世杰,高雷阜,于冬梅,徒君.基于变因子加权学习与邻代维度交叉策略的改进CSA算法[J].电子学报,2019,47(01)**:40-48.
2.文献复现：自适应t 分布变异的缎蓝园丁鸟优化算法 Matlab代码
[1] 韩斐斐,刘升.基于自适应t分布变异的缎蓝园丁鸟优化算法[J].微电子学与计算机,2018,35(08)**:117-121
3.文献复现：混沌麻雀搜索优化算法 matlab 代码
[1]吕鑫,慕晓冬,张钧,王震.混沌麻雀搜索优化算法[J/OL].北京航空航天大学学报:1-10[2020-11-16].https://doi.org/10.13700/j.bh.1001-5965.2020.0298.
4.文献复现：非均匀变异的互利自适应缎蓝园丁鸟优化算法Matlab代码
[1]王依柔,张达敏,樊英.非均匀变异的互利自适应缎蓝园丁鸟优化算法[J/OL].计算机工程与科学:1-10[2020-11-23].http://kns.cnki.net/kcms/detail/43.1258.TP.20200803.1202.004.html
5.文献复现：基于自适应权重的缎蓝园丁鸟优化算法 Matlab代码
[1]鲁晓艺,刘升,韩斐斐,于建芳.基于自适应权重的缎蓝园丁鸟优化算法[J].智能计算机与应用,2018,8(06)**:94-100
6.文献复现：多段扰动共享型乌鸦算法 matlab代码
辛梓芸,张达敏,陈忠云,张绘娟,闫威.多段扰动的共享型乌鸦算法[J].计算机工程与应用,2020,56(02)**:55-61
7.文献复现：正弦余弦指引的乌鸦搜索算法 Matlab 代码
[1]肖子雅,刘升,韩斐斐,于建芳.正弦余弦指引的乌鸦搜索算法研究[J].计算机工程与应用,2019,55(21)**:52-59.
8.文献复现：多子群的共生非均匀高斯变异樽海鞘群算法Matlab代码
[1]陈忠云,张达敏,辛梓芸.多子群的共生非均匀高斯变异樽海鞘群算法[J/OL].自动化学报:1-9[2020-11-25].https://doi.org/10.16383/j.aas.c190684.
9.文献复现：疯狂自适应的樽海鞘算法 Matlab代码
[1]张达敏,陈忠云,辛梓芸,张绘娟,闫威.基于疯狂自适应的樽海鞘群算法[J].控制与决策,2020,35(09)**:2112-2120.
10.文献复现：正余弦算法的樽海鞘算法 Matlab代码
[1]陈忠云,张达敏,辛梓芸.正弦余弦算法的樽海鞘群算法[J].计算机应用与软件,2020,37(09)**:209-214.
11. 文献复现：自学习策略和Ｌevy飞行的正弦余弦优化算法 Matlab代码
[1]李银通,韩统,赵辉,王骁飞.自学习策略和Lévy飞行的正弦余弦优化算法[J].重庆大学学报,2019,42(09)**:56-66.
12.文献复现：融合柯西变异和反向学习的改进麻雀算法 Matlab代码
[1]毛清华,张强.融合柯西变异和反向学习的改进麻雀算法[J/OL].计算机科学与探索:1-12[2020-12-16].http://kns.cnki.net/kcms/detail/11.5602.tp.20201203.1601.006.html
13.文献复现：扇区搜索机制的果蝇优化算法 Matlab代码
[1]曹珍贯,李智威,余俊峰.扇区搜索机制的果蝇优化算法 [J].计算机工程与设计,2019,40(06)**:1590-1594.
14.文献复现：一种基于Levy飞行的改进蝗虫优化算法 Matlab代码
[1]赵然,郭志川,朱小勇.一种基于Levy飞行的改进蝗虫优化算法[J].计算机与现代化,2020(01)**:104-110.
15.文献复现：基于曲线自适应和模拟退火的蝗虫优化算法 Matlab代码
[1]李洋州,顾磊.基于曲线自适应和模拟退火的蝗虫优化算法[J].计算机应用研究,2019,36(12)**:3637-3643.
16.文献复现：混合柯西变异和均匀分布的蝗虫优化算法 Matlab代码
[1]何庆,林杰,徐航.混合柯西变异和均匀分布的蝗虫优化算法[J/OL].控制与决策:1-10[2021-01-08].https://doi.org/10.13195/j.kzyjc.2019.1609.
17.文献复现：基于模拟退火的改进鸡群优化算法(SAICSO) Matlab代码**
[1]李振璧,王康,姜媛媛.基于模拟退火的改进鸡群优化算法[J].微电子学与计算机,2017,34(02)**:30-33+38.
18.文献复现：一种改进的鸡群算法(ICSO) Matlab代码**
[1]孔飞,吴定会.一种改进的鸡群算法[J].江南大学学报(自然科学版),2015,14(06):681-688.
19.文献复现:全局优化的改进鸡群算法（ECSO) Matlab代码**
[1]韩斐斐,赵齐辉,杜兆宏,刘升.全局优化的改进鸡群算法[J].计算机应用研究,2019,36(08)**:2317-2319+2327.
20.文献复现:混沌精英哈里斯鹰优化算法(CEHHO) Matlab代码**
[1]汤安迪,韩统,徐登武,谢磊.混沌精英哈里斯鹰优化算法[J/OL].计算机应用:1-10[2021-01-29].http://kns.cnki.net/kcms/detail/51.1307.TP.20210114.0947.032.html.
21.文献复现：基于翻筋斗觅食策略的灰狼优化算法（DSFGWO）Matlab代码
[1]王正通,程凤芹,尤文,李双.基于翻筋斗觅食策略的灰狼优化算法[J/OL].计算机应用研究:1-5[2021-02-01].https://doi.org/10.19734/j.issn.1001-3695.2020.04.0102.
22.文献复现：基于透镜成像学习策略的灰狼优化算法（LIS-GWO）Matlab代码
[1]龙文,伍铁斌,唐明珠,徐明,蔡绍洪.基于透镜成像学习策略的灰狼优化算法[J].自动化学报,2020,46(10)**:2148-2164.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b663f89fe58106cac756c51d03165a30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797c7931a966b21b2cf4d3e3770d2b70/" rel="bookmark">
			Python批量处理经纬度数据并生成位置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 这次的内容是无意之间想到要做的，因为本人在自学Python，学习到pandas模块的时候就想着怎么样可以将学习获得的知识应用起来，于是就有了今天这个实战内容。
准备： ①Python 3.x及以上的运行环境
②导入pandas模块
③导入geopy模块，可以直接pip install geopy获得
④导入warnings模块，用于过滤无用的警告信息
其中geopy作为一个地理位置相关的库，提供了一系列方便的调用其他地图api的方法，其中就包括了：1、通过地名（如建筑物）获取详细地理位置；2、通过给定的经纬度获取详细的地址这两种实用方法。具体请参考官方文档，地址：欢迎使用Geopy文档！ — GeoPy 2.2.0 文档
读取处理数据： 由于使用的是pandas模块，所以按照以往的经验，我选择使用csv文件保存经纬度数据，通过python程序生成指定数目和范围的随机数用来模拟实际中的经纬度数据，效果如下（注：这里只生成了东经0-180°的，实际上应该还包括西经0-180°）：
然后通过pandas的read_csv()方法得到一个DataFrame对象。到这里思路就很清晰了，即通过某种方式我们可以方便地获取每一行的经度和纬度信息并进行处理，这种方式就是行/列切片。
生成位置信息： geopy提供了一系列方便的调用其他地图api的方法，考虑到某些api的调用需要用户注册并生成密钥才可以使用，我选择无需注册的Nominatim的api，官网：Nominatim
结合上一步，将每次切片得到的经纬度数据分别填充，调用reverse()函数后得到较为准确的位置信息。关键部分如下——
data="{}, {}".format(str(longtitude),str(latitude))
geolocator = Nominatim(user_agent=username)
location = geolocator.reverse(data,zoom=18)
tips： location输出一个对应经纬度的大致地理位置，比如说精确到街道location.address输出一个对应经纬度的详细地理位置，包括是什么建筑物location.raw输出一个对应经纬度的原始信息，貌似默认是json格式 最终效果： 其中的none是因为经纬度坐标在水系或者无人区中，无法确定地理位置。
完整代码： from geopy.geocoders import Nominatim import warnings as bill_warn import pandas as pd1 def locate_address(urlname,username): bill_warn.filterwarnings(action="ignore",message="whatever") geo_frame=pd1.DataFrame(pd1.read_csv(urlname)) for i in range(0,len(geo_frame)): longtitude = geo_frame.iloc[i,1] latitude = geo_frame.iloc[i,2] data="{}, {}".format(str(longtitude),str(latitude)) geolocator = Nominatim(user_agent=username) location = geolocator.reverse(data,zoom=18) print("The information to this set of data:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/797c7931a966b21b2cf4d3e3770d2b70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b49fa0090c7d1766433fd57c4c7dc30/" rel="bookmark">
			go语言学习：type详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：微点阅读 https://www.weidianyuedu.com
在go语言中，type用于类型定义(type definition)与类型别名(type alias)。这两者的差别从名字上已经可以初见端倪。
类型定义即定义新类型，是一个全新的类型，但可能与被定义类型存在一些关系，如类型转换，方法继承等。类型定义在各语言中有不同的体现，如Java是用class, interface等关键字作类型定义，在python中也是使用class关键字。只不过go为了简洁的原则，可以省些关键字，因而与类型别名重用了type关键字。
类型别名则是对被定义类型的别称，与其是相同的类型，只不过取了另外一个名字而已。类型别名是本文讨论的重点。这里有几个问题，一是为何go要引入类型别名，其有什么好处？为什么Java或者其他语言没有类型别名？
在go语言中，type有5种作用，罗列如下。但在本文中，只讲述类型定义与类型别名。
定义接口定义结构体类型定义类型别名类型查询 类型定义
package main
import "fmt"
func main() {
h := House{height: 1.0, width: 2.0}
fmt.Println(h.Height())
wh := WhiteHouse{height: 1.0, width: 2.0}
fmt.Println(wh.Area())
w := House(wh) //类型转换
fmt.Println(w.Width())
f1 := Factory{height: 1.0, width: 2.0}
f2 := Factory2{name: "test"}
fw := House(f1)
fmt.Println(fw)
fw2 := House(f2) //运行时这里会报类型转换错误
fmt.Println(fw2)
}
type House struct {
height float32
width float32
}
func (h *House) Height() float32 {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b49fa0090c7d1766433fd57c4c7dc30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40815c5418cd86dcfe563e5af10462de/" rel="bookmark">
			C语言实现贪吃蛇游戏（Linux下实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、ncurse图形库二、思路步骤1.准备工作2.考虑如何输出图形界面3.考虑蛇是如何移动的4.实现页面刷新5.判断键盘输入6.Liunx线程解决键入值和界面刷新并行问题 三、完整代码四、总结 一、ncurse图形库 ncurses(new curses)是一套编程库，它提供了一系列的函数以便使用者调用它们去生成基于文本的用户界面。贪吃蛇游戏就选用这种简单的图形库来显示。
以下使贪吃蛇项目中用到的一些ncurses库中的函数（代码如下）：
#include&lt;curses.h&gt; // Linux下图形界面库头文件 noecho(); // 不回显用户输入的内容 initscr(); // 初始化屏幕 keypad(); // 允许用户终端的键盘，允许getch()函数获取功能键 printw(); // 打印 二、思路步骤 1.准备工作 在创建一个贪吃蛇项目之前：
在编写程序前需要添加一些ncurse界面的初始函数，这里我们将这些函数封装：
//函数封装初始化Ncurse界面 void InitNcurse() { noecho(); //大多数的交互式应用程序在初始化时会调用noecho()函数，用于在进行控制操作时不显示输入的控制字符。 initscr(); //ncurse界面的初始化函数 keypad(stdscr,1); //从标准stdscr中接受功能键，1代表是否接收 } 创建蛇身结点的结构体和食物的结构体,并且定义全局变量Key,Dir保存值:
//定义贪吃蛇结点结构体 struct Snack { int hang; int lie; struct Snack *next; }; struct Snack Food; //定义食物结构体 struct Snack *head=NULL; //定义一个蛇头指针 struct Snack *tail=NULL; //定义一个蛇尾指针 int key; //记录键入的值 ChangeDir()函数中使用到 int Dir; //记录方向的值 AddNode()函数中使用到 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40815c5418cd86dcfe563e5af10462de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cad6bbab0624d7a7d1bc4c90fdc0e17/" rel="bookmark">
			（一）轨迹规划：贝塞尔曲线的python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么要使用贝塞尔曲线？ 在参数方程中，参数不都是有明显几何意义的。
参数方程可以表示空间中的曲线，也可以表示空间中的曲面。如半径长为r、圆心在(a,b)的平面圆，其参数方程为：
{ x = a + r cos ⁡ θ y = b + r sin ⁡ θ (1.1) \left\{ \begin{aligned} &amp;x = a + r\cos\theta\\ &amp;y = b + r\sin\theta \end{aligned} \right. \tag{1.1} {​x=a+rcosθy=b+rsinθ​(1.1)
其中： θ ∈ [ 0 , 2 π ) \theta\in[0,2\pi) θ∈[0,2π)。 θ \theta θ则为直观的角度, θ \theta θ从0变化到 2 π 2\pi 2π，直线顺时针变化。
又如球面，球心在坐标原点，半径为R的球面。参数方程：
{ x = R s i n ϕ cos ⁡ θ y = R s i n ϕ sin ⁡ θ z = R c o s ϕ (1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cad6bbab0624d7a7d1bc4c90fdc0e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83736eabf480f7e307b79d5360812e47/" rel="bookmark">
			MacOS系统通过命令行启动Chrome浏览器并添加启动参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天需要chrome浏览器的导入密码功能，网上查了下说有一个启动参数 "--enable-features=PasswordImport" 可以启用，但是都是Windows系统上的方法。
又查了一下MacOS系统通过命令行启动的方法，都没有找到合适用的。在StackOverFlow上找到了非常快速便捷的方案。
打开terminal终端，输入下面这一行bash代码，即可启动一个具备导入密码功能的chrome浏览器。（功能在 关闭 按钮下的三个点 -&gt; 设置 -&gt; 自动填充 -&gt; 密码 -&gt; 已保存的密码 右侧三个点 图标）
open /Applications/Google\ Chrome.app --args --enable-features=PasswordImport 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d4fb1fb1c9f323ebf0497c7399e268/" rel="bookmark">
			Java线程安全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 自增运算不是安全的2. 临界资源与临界区代码3. synchronized同步方法4. synchronized同步块 1. 自增运算不是安全的 package threadpool; public class PlusTest { private static int count=0; static void increse() { count++; } public static void main(String[] args) throws InterruptedException { Runnable task=new Runnable() { @Override public void run() { for(int i=0;i&lt;1000;i++)//每个线程执行10次自增操作 increse(); } }; for(int i=0;i&lt;10;i++)//创建10个线程 new Thread(task).start();; Thread.sleep(3000);//等待线程执行完成 System.out.println("预期结果："+10000); System.out.println("实际结果："+count); } } 上面的代码创建了10个线程，每个线程进行1000次自增操作，理论上结果应该是10000，但是实际结果小于10000，运行两次结果如下：
原因分析：
一个自增运算符是一个复合操作，至少包括三个JVM指令：“内存取值”“寄存器增加1”和“存值到内存”。这三个指令在JVM内部是独立进行的，中间完全可能会出现多个线程并发进
假设当count=1时右3个线程同时内存取值，得到count的值为1，然后各自进行自增操作后再将值放入内存，结果是count=2而不是4
2. 临界资源与临界区代码 临界区资源表示一种可以被多个线程使用的公共资源或共享数据，但是每一次只能有一个线程使用它。一旦临界区资源被占用，想使用该资源的其他线程则必须等待
临界区资源是受保护的对象。临界区代码段（Critical Section）是每个线程中访问临界资源的那段代码
在上面的自增代码例子中，count是临界资源，执行count++的代码是临界区代码
3. synchronized同步方法 使用synchronized关键字修饰一个方法的时候，该方法被声明为同步方法
修改上面的自增代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62d4fb1fb1c9f323ebf0497c7399e268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3dc030bb754d87a965bd67e02aa6115/" rel="bookmark">
			CDH6.3.2环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 参考文章配置hostname，映射文件hosts关闭防火墙，并禁止开机自启设置yum源设置无密钥登陆时间同步安装JDK 1.8安装mysql5.7 linux的通用版本 generic配置CM为CM配置数据库启动CM部署CDH 参考文章 cm和cdh的关系
http://www.fblinux.com/?p=1492
hadoop发行版本介绍
https://www.jianshu.com/p/fc3010c02391
配置hostname，映射文件hosts 为每台服务器配置名称
vim /etc/hostname 添加名称 将所有服务器的名称和ip地址映射写入hosts文件
vim /etc/hosts ip地址 服务器名称 .... .... 关闭防火墙，并禁止开机自启 systemctl stop firewalld systemctl disable firewalld # 查看状态 systemctl status firewalld 修改SELinux配置文件/etc/selinux/config，设置SELINUX=disabled。修改完毕后进行重启。
vim /etc/selinux/config 设置yum源 本地yum源：对应的配置文件 /etc/yum.repo/CentOS-Media.repo
网络yum源：对应的配置文件 /etc/yum.repo/CentOS-Base.repo
先走网络源，再走本地源，不想走网络源，就禁止就行
enable : 1 表示开启yum源 0表示禁用这个yum源
gpgcheck=1 表示对rpm进行校验
baseurl 表示源地址，可以是网络http://ftp.sjtu.edu.cn/centos/ r e l e a s e v e r / c o n t r i b / releasever/contrib/ releasever/contrib/basearch/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3dc030bb754d87a965bd67e02aa6115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f9a3433948c2ad4df12a5ac7feb1424/" rel="bookmark">
			Python编程从入门到实践（第2版）第五章 if 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章 if语句 5.1 一个简单示例5.2 条件测试5.2.1 检查是否相等5.2.2 检查是否相等时忽略大小写5.2.3 检查是否不相等5.2.4 数值比较5.2.5 检查多个条件 5.3 if语句5.3.1 简单的if语句5.3.2 if-else 语句5.3.3 if-elif-else结构5.3.4 使用多个elif代码块5.3.5 省略else代码块 5.1 一个简单示例 输入：
cars = ['audi','bmw','subaru','toyota'] for car in cars: if car == 'bmw': print(car.upper()) # 若是，首字母大写方式打印 else: print(car.title()) # 若不是，全大写方式打印 输出：
Audi BMW Subaru Toyota 5.2 条件测试 5.2.1 检查是否相等 5.2.2 检查是否相等时忽略大小写 # 检查是否相等 car = 'bmw' # 赋值 car == 'bmw' # 相等运算符，检查是否相等 True car = 'audi' # 赋值 car == 'bmw' # 相等运算符，检查是否相等 False #检查是否相等时忽略大小写 car = 'Audi' #区分大小写 car == 'audi' False car = 'Audi' #转换为小写后再进行比较 car.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f9a3433948c2ad4df12a5ac7feb1424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a5c04811dc06c2c094090008c11255/" rel="bookmark">
			Windows 10 远程桌面开启和关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 10 远程桌面开启 1、将下面的代码复制到新建文本文档中，将文本文档的后缀名修改为.bat格式，运行此文件即可关闭远程桌面；
@echo off ::获取管理员权限 %1 mshta vbscript:CreateObject("Shell.Application").ShellExecute("cmd.exe","/c %~s0 ::","","runas",1)(window.close)&amp;&amp;exit ::启用远程桌面 reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f ::关闭防火墙 ::netsh firewall set opmode mode=disable netsh advfirewall set currentprofile state off ::禁用不允许空密码远程访问 reg add "HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Lsa" /v LimitBlankPasswordUse /t reg_dword /d 0 /f echo 执行完毕,任意键退出 pause &gt;nul exit Windows 10 远程桌面关闭 1、将下面的代码复制到新建文本文档中，将文本文档的后缀名修改为.bat格式，运行此文件即可关闭远程桌面；
@echo off ::获取管理员权限 %1 mshta vbscript:CreateObject("Shell.Application").ShellExecute("cmd.exe","/c %~s0 ::","","runas",1)(window.close)&amp;&amp;exit cd /d "%~dp0" ::关闭远程桌面 reg add "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5a5c04811dc06c2c094090008c11255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7525690bfa638ef912ec91a9081de701/" rel="bookmark">
			Urp相机堆栈关于后处理抗锯齿设置的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题起源和影响 1.1 Base相机切换导致切换场景时候闪烁 问题是这样的，项目之前一直用场景相机作为Base相机，UI相机作为Overlay相机。渲染顺序是先渲染场景Base相机，然后渲染UI相机。不过，最近打包发现，在部分机器上，一切换场景时候，比如loading界面打开时候，屏幕会出现明显的闪烁，甚至还会花屏。
1.2 固定Base相机解决切换场景闪烁 尝试解决：并没有上FrameDebug或者RenderDoc去抓帧分析，比较麻烦。首先，尝试在切换场景之前就隐藏场景相机，发现花屏现象消失了，闪烁问题也大幅度减弱。猜测，是场景切换时候场景相机销毁， 导致必须切换Base相机导致整个相机堆栈都要重建的原因。
解决办法：固定一个空的Base相机，不渲染任何层，场景相机作为Overlay相机挂在Base相机上，然后是UI相机。
结果：原先loading界面闪烁的几个机器都不再闪烁。
1.3 尝试强制清除颜色缓冲解决花屏和闪烁 参考网上的文章，比如（二）unity shader在实际项目中出现的问题————低档机（如小米4）切换游戏场景时花屏问题，猜测这篇文章的应用场景是在固定管线下。在切换场景时候强制多次清除颜色缓冲，同时Base相机设置为SolidColor清除，场景相机本来就有天空盒，以尝试解决部分机型花屏和闪烁问题，结果还是失败。故放弃治疗。沿着固定Base相机的思路继续下去。
1.4 固定Base相机开启SMAA掉帧严重 由于MSAA会成倍增加RT的带宽和内存，带宽又是性能非常敏感的因素，所以放弃了。刚好Unity的Urp渲染管线支持SMAA和FXAA后处理抗锯齿，因此选择了后处理抗锯齿。
由于为了解决切换场景闪烁问题，固定空的Base相机，然后Base相机开启后处理抗锯齿，结果发现我的红米K30 Ultra掉帧非常严重，之前可以稳定30fps，改完之后在主场景只能跑到15fps左右。一开始还怀疑是场景没有合并网格，导致批次过高，编辑器内发现视线较远甚至到800Batches，远超100-200Batches的要求。后面想想，不可能突然掉帧这么严重，结果一FrameDebug，发现SMAA跑了2次。如下图所示：
Base相机一次，场景Overlay相机一次，UI相机不开后处理所以没有。而一次SMAA实际上是三个全屏Pass，性能可想而知。
实际上，我们只想让场景相机有抗锯齿，和之前场景相机作为Base相机的情况保持一致。那么，我们就尝试只给场景相机开启后处理抗锯齿，结果发现完全没有效果。
二、Urp的相机堆栈 可以参考Unity中国官方发在知乎上的这篇文章：
URP 系列教程 | 多相机玩法攻略
简而言之，相机堆栈的意思是一系列的相机叠加在一起，Base相机作为基础设置，Base之上可以有任意的Overlay。按照叠加顺序从Base相机开始，一个个渲染，直到渲染完最后的相机，最终再把渲染结果的RT（注意，一个相机堆栈重用一个RT） Blit到屏幕上。
三、SMAA无法在Overlay相机单独生效的原因 Urp渲染管线默认使用的是前向渲染器ForwardRenderer，ForwardRenderer里面有两个PostProcessPass，一个是m_PostProcessPass，另一个是m_FinalPostProcessPass，后处理就是在这2个Pass里面实现的。注意，Urp定义的这种Pass只是逻辑上的，实际上可能对应多个渲染Pass。
PostProcessPass的Execute会判断是IsFinalPass来执行RenderFinalPass还是正常的Render。正常的Render主要对应的是UberPost相关的后处理，RenderFinalPass对应的FinalPost相关的后处理。更详细的细节不在此列，看源码吧。
问题在于，Render函数中如下图所示的判断，
cameraData是传递给每个Pass的RenderingData的成员，这些都是在渲染相机时候初始化好的。因此，怀疑对于Overlay相机这个标志无法传递到PostProcess。
回到UniversalRenderPipeline的RenderCameraStack函数，如下图所示，
从这部分代码可以看到传递给overlay相机的overlayCameraData是通过baseCameraData初始化的，然后再通过InitializeAdditionalCameraData设置一些额外的参数。然后再去查看InitializeAdditionalCameraData的源码，发现没有设置抗锯齿模式的地方。再去查看InitializeStackedCameraData函数源码，如下所示，
最终确定抗锯齿模式是通过base相机设置，而overlay的抗锯齿模式不会生效，。这也就解释了为什么只设置base相机的smaa会导致overlay相机也执行了smaa，单独设置overlay相机的smaa反而无法生效。
那么如何解决了？很简单，在InitializeAdditionalCameraData函数中增加一行代码，将overlay相机的抗锯齿设置传递到overlayCameraData即可。
四、FXAA只能在最后一个相机生效（通常是UI相机） SMAA的问题解决了。结果发现FXAA也无法生效，那只能继续查源码咯。
如上截图所示，发现前向渲染器是根据标志applyFinalPostProcessing，来判断是否应用FinalPostProcessPass。而这个标志要求三个条件，相机堆栈开启了后处理、当前是最后一个相机、Base相机开启了FXAA，如果做了三的源码修改（Overlay的抗锯齿设置生效），那么需要是UI相机开启了FXAA。
FrameDebug的结果如下所示：
问题：开启了FXAA，UI界面肉眼可见的变模糊了，编辑器中都能体现出来。最终打算放弃FXAA，低端机选择不开抗锯齿，中高端机器开启SMAA。由于前述只对场景相机开启抗锯齿，因此不修改urp源码的情况下，FXAA是不会被激活的。
五、固定空Base相机引入的新问题 对比如下2个截图：
第一个有额外空的Base相机，第二个直接使用场景相机作为Base相机。对比发现，Base相机无论如何会有Clear操作；然后还有一个渲染天空盒的操作。
如果我们把Base相机的天空盒模式改成颜色或者未初始化，就不会渲染天空盒。但是，对比第二张截图，天空盒是在渲染场景不透明物体后渲染的。因此，引入一个固定的Base相机会造成天空盒渲染顺序不对，导致效果出现问题，以及性能也会出现问题（一开始渲染天空盒导致Early-Z无法生效，OverDraw大幅度增加）。
5.1 解决天空盒渲染问题 根据上述代码截图，发现Urp的前向渲染强制只有Base相机才能激活天空盒渲染。我们直接去掉这个非isOverlayCamera判断即可。不过，需要Base相机设置为SolidColor清除方式；如果场景中还有额外的相机也需要注意不要设置天空盒，同样UI相机也是。
5.2 解决额外的Clear操作 我们对自定义的角色、场景、特效Pass加了对Base相机的限制，可以去除额外的2个Clear操作。最终Base相机就只有一个创建RT时候的Clear操作。这样Base相机的额外销毁可以降到最低。
FrameDebug场景渲染结果如下：
六、最终结论 6.1 固定空的Base相机避免切换场景闪烁 为了修复部分机型切换场景闪烁问题，固定一个空的base相机，并且ui相机固定为最后一个overlay相机。如此可以避免切换场景时候，Base相机会切换，从而避免闪烁问题。
为了兼容overlay相机支持SMAA和渲染天空盒，需要修改Urp的源码，如上所述。
6.2 中高端机器开启SMAA 为了兼容固定Base相机的情况下，单独设置场景相机的抗锯齿，需要修改urp源码支持overlay相机单独设置抗锯齿，从而只对场景overlay相机开启SMAA，Base相机不跑没必要的抗锯齿。同时UI相机不开抗锯齿，以避免UI模糊以及性能压力。
6.3 低端机不开启抗锯齿 低端机不开启抗锯齿。根据上述讨论，在不修改urp源码的前提下，低端机的场景相机无法开启FXAA。UI相机开启FXAA会导致UI肉眼可见模糊。所以最终选择低端机不开启任何抗锯齿。
6.4 优化结果 之前切换场景闪烁的机器都不再有花屏和闪烁现象；开启场景相机抗锯齿的情况下，红米k30 ultra从15fps左右恢复到稳定30fps。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7525690bfa638ef912ec91a9081de701/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5df94a295577d056662cae9c7c606be/" rel="bookmark">
			Pytorch：基于转置卷积解码的卷积自编码网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch: 图像自编码器-卷积自编码网络(转置卷积解码)和图像去噪 Copyright: Jingmin Wei, Pattern Recognition and Intelligent System, School of Artificial and Intelligence, Huazhong University of Science and Technology
Pytorch教程专栏链接
文章目录 Pytorch: 图像自编码器-卷积自编码网络(转置卷积解码)和图像去噪Reference介绍数据预处理数据集构建基于转置卷积编码的网络构建网络训练和预测评价去噪效果 本教程不商用，仅供学习和参考交流使用，如需转载，请联系本人。
Reference Sparse Auto-Encoders
Convolutional Auto-Encoders
Stacked Auto-Encoders(Denoising)
介绍 利用卷积自编码网络去噪，利用其进行图像的编码和解码，是因为卷积操作在提取图像的信息上有较好的效果，而且可以对图像中隐藏的空间信息等内容进行较好的提取。该网络可以用于去噪，分割等。
在网络的输入图像带有噪声，而输出图像则为原始的去噪图像。在编码器阶段，会经过多个卷积、池化、激活和 BN 层操作，逐渐降低每个特征映射尺寸，如此降低至 24 × 24 24\times24 24×24 ，即图像缩小为原来的 1 16 \frac{1}{16} 161​ 。而解码器阶段，则通过多个转置卷积，激活和 BN 层操作，逐渐将其解码为原始图像大小并且包含 3 3 3 通道，即 3 × 96 × 96 3\times96\times96 3×96×96 的图像。
import numpy as np import pandas as pd import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5df94a295577d056662cae9c7c606be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ebdbef2947c01848a12cc515c94c59/" rel="bookmark">
			el-cascader 最后一级id及回显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		:props="{emitPath:false}" 加上这行就可以，只存最后一级id，且以最后一级id完整回显。
&lt;el-cascader expand-trigger="click" placeholder="请输入" :props="{emitPath:false}"
:options="xxList"
v-model="xxValue"
@change="getCasValue"&gt;
&lt;/el-cascader&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fd7da698ce1d8e5a06945a9534e71d/" rel="bookmark">
			DPDK 全面分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高性能网络技术# 随着云计算产业的异军突起，网络技术的不断创新，越来越多的网络设备基础架构逐步向基于通用处理器平台的架构方向融合，从传统的物理网络到虚拟网络，从扁平化的网络结构到基于 SDN 分层的网络结构，无不体现出这种创新与融合。
这在使得网络变得更加可控制和成本更低的同时，也能够支持大规模用户或应用程序的性能需求，以及海量数据的处理。究其原因，其实是高性能网络编程技术随着网络架构的演进不断突破的一种必然结果。
C10K 到 C10M 问题的演进# 如今，关注的更多是 C10M 问题（即单机 1 千万个并发连接问题）。很多计算机领域的大佬们从硬件上和软件上都提出了多种解决方案。从硬件上，比如说，现在的类似很多 40Gpbs、32-cores、256G RAM 这样配置的 X86 服务器完全可以处理 1 千万个以上的并发连接。
但是从硬件上解决问题就没多大意思了，首先它成本高，其次不通用，最后也没什么挑战，无非就是堆砌硬件而已。所以，抛开硬件不谈，我们看看从软件上该如何解决这个世界难题呢？
这里不得不提一个人，就是 Errata Security 公司的 CEO Robert Graham，他在 Shmoocon 2013 大会上很巧妙地解释了这个问题。有兴趣可以查看其 YouTube 的演进视频： C10M Defending The Internet At Scale。
他提到了 UNIX 的设计初衷其实为电话网络的控制系统而设计的，而不是一般的服务器操作系统，所以，它仅仅是一个数据负责数据传送的系统，没有所谓的控制层面和数据层面的说法，不适合处理大规模的网络数据包。最后他得出的结论是：
OS 的内核不是解决 C10M 问题的办法，恰恰相反 OS 的内核正式导致 C10M 问题的关键所在。
为什么这么说？基于 OS 内核的数据传输有什么弊端？# 1、中断处理。当网络中大量数据包到来时，会产生频繁的硬件中断请求，这些硬件中断可以打断之前较低优先级的软中断或者系统调用的执行过程，如果这种打断频繁的话，将会产生较高的性能开销。
2、内存拷贝。正常情况下，一个网络数据包从网卡到应用程序需要经过如下的过程：数据从网卡通过 DMA 等方式传到内核开辟的缓冲区，然后从内核空间拷贝到用户态空间，在 Linux 内核协议栈中，这个耗时操作甚至占到了数据包整个处理流程的 57.1%。
3、上下文切换。频繁到达的硬件中断和软中断都可能随时抢占系统调用的运行，这会产生大量的上下文切换开销。另外，在基于多线程的服务器设计框架中，线程间的调度也会产生频繁的上下文切换开销，同样，锁竞争的耗能也是一个非常严重的问题。
4、局部性失效。如今主流的处理器都是多个核心的，这意味着一个数据包的处理可能跨多个 CPU 核心，比如一个数据包可能中断在 cpu0，内核态处理在 cpu1，用户态处理在 cpu2，这样跨多个核心，容易造成 CPU 缓存失效，造成局部性失效。如果是 NUMA 架构，更会造成跨 NUMA 访问内存，性能受到很大影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fd7da698ce1d8e5a06945a9534e71d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da6b296cf3cd9650a5a218884194be4/" rel="bookmark">
			信息收集 ——C段扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普及C段扫描原因以及方法
扫描原因
收集C段内部属于目标的IP地址
内部服务只限IP访问，没有映射域名
更多的探测主机目标资产
方法
Nmap
快速扫描大型网络
可以获得主机运行的端口，服务，系统指纹
提供上百个扩展脚本
1.nmap 扫描
Nmap -sn -PE -n 192.168.1.1/24-oX out.xml Nmap-扫描C段主机存活
-sn 不扫描端口
-PE ICMP扫描
-n 不进行dns解析
Nmap -sS -Pn -p 3389 ip 定向
-SS 半开放扫描
-Pn 不进行主机存活探测
Nmap -sS -Pn -p 1 -65535 -n ip 半开放扫描
更多：
nmap在kali的使用方法和常见命令（入门）
2.masscan扫描
Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网，每秒传输1000万个数据包，允许任意地址范围和端口范围
安装Masscan
sudo apt-get install git gcc make libpcap-dev(安装必备环境,kali已经默认安装完成)
git clone https://github.com/robertdavidgraham/masscan
cd masscan
make(编译)
使用Masscan
C段探测 masscan -p 80 ip/24--rate 10000 -oL output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2da6b296cf3cd9650a5a218884194be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95b5430ce6f5b7b09fadb1aa8b0a8e3b/" rel="bookmark">
			spring如何解决循环依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、什么是循环依赖？2、怎么检测循环依赖3、Spring怎么解决循环依赖4、循环依赖的N种场景3.1、单例的setter注入3.2、多例的setter注入3.3、构造器注入3.4、单例的代理对象setter注入3.5、DependsOn循环依赖 5、出现循环依赖如何解决？5.1、生成代理对象产生的循环依赖5.2、DependsOn循环依赖5.3、多例循环依赖5.3、构造器循环依赖 这里我们主要分析Spring bean的循环依赖，以及Spring的解决方式。 通过这种解决方式，我们可以应用在我们实际开发项目中。
1、什么是循环依赖？
2、怎么检测循环依赖
3、循环依赖的N种场景
3、Spring怎么解决循环依赖
4、Spring对于循环依赖无法解决的场景
5、Spring解决循环依赖的方式我们能够学到什么？
以下基于spring5.0.x版本源码进行分析
1、什么是循环依赖？ 循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：
注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。
Spring中循环依赖场景主要有以下两种：
（1）field属性的循环依赖
（2）构造器的循环依赖
（3）DependsOn循环依赖
2、怎么检测循环依赖 检测循环依赖相对比较容易，Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。
3、Spring怎么解决循环依赖 Spring解决循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。
Spring的单例对象的初始化主要分为三步：
实例化：其实也就是调用对象的构造方法实例化对象注入：填充属性，这一步主要是对bean的依赖属性进行填充初始化：属性注入后，执行自定义初始化 从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。
那么我们要解决循环引用也应该从bean初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。
首先我们看源码，三级缓存主要指：
/** Cache of singleton objects: bean name --&gt; bean instance */ private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256); /** Cache of singleton factories: bean name --&gt; ObjectFactory */ private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16); /** Cache of early singleton objects: bean name --&gt; bean instance */ private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16); 这三级缓存分别指：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95b5430ce6f5b7b09fadb1aa8b0a8e3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547e3c78ec8d977a9297ea74032d10e2/" rel="bookmark">
			《深入浅出强化学习：原理入门》学习笔记（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2. 马尔可夫决策过程 2.1 马尔可夫决策过程理论讲解 1.马尔可夫性：
所谓马尔科夫性是指系统的下一个状态st+1 仅与当前状态st 有关，而与以前的状态无关。
定义：状态st 是马尔科夫的，当且仅当P[st+1 |st ]=P[st+1 |s1 ，…，st ]。
定义中可以看到，当前状态st 其实是蕴含了所有相关的历史信息s1 ，…，st ，一旦当前状态已知，历史信息将会被抛弃。马尔科夫性描述的是每个状态的性质，但真正有用的是如何描述一个状态序列。数学中用来描述随机变量序列的学科叫随机过程。所谓随机过程就是指随机变量序列。若随机变量序列中的每个状态都是马尔科夫的，则称此随机过程为马尔科夫随机过程。
2. 马尔可夫过程：
马尔科夫过程的定义：马尔科夫过程是一个二元组（S，P），且满足：S是有限状态集合，P是状态转移概率。状态转移概率矩阵为：
P = [ P 11 ⋯ P 1 n ⋮ ⋮ ⋮ P n 1 ⋯ P n n ] P=\begin{bmatrix} P_{11}&amp; \cdots &amp; P_{1n} \\ \vdots&amp; \vdots &amp; \vdots \\ P_{n1} &amp; \cdots &amp; P_{nn}\\ \end{bmatrix} P=⎣⎢⎡​P11​⋮Pn1​​⋯⋮⋯​P1n​⋮Pnn​​⎦⎥⎤​ 3. 马尔可夫决策过程：
马尔科夫决策过程由元组（S，A，P，R，γ）描述，其中：
S 为有限的状态集；A 为有限的动作集；P 为状态转移概率；R 为回报函数；γ 为折扣因子，用来计算累积回报。注意，跟马尔科夫过程不同的是，马尔科夫决策过程的状态转移概率是包含动作的，即：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/547e3c78ec8d977a9297ea74032d10e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81f2bae3ae420f3bee2384599842399c/" rel="bookmark">
			B树和B&#43;树的查找方式及原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
先把结论放上
大致定义
B树支持随机查找
B+树支持随机查找和顺序查找
先把结论放上 B树仅支持随机查找
B+树支持随机查找和顺序查找
大致定义 至于B树和B+树的定义我就不展开了，随便找了两张图大家能有个大致的印象就行了
学习的时候对于这两个支持的查找有点疑惑，但是也没找到专门解释的，于是准备写一下自己的理解
B树支持随机查找 起初我想的是这明明是一个树形结构，随机查找又是通过下标来查找的，为啥能支持随机查找呢？后来大概有些明白了
单看树的每一个节点，一个节点里有多个关键字，所以我认为应该是在单个节点内部支持随机查找，而在节点之间就没有了
B+树支持随机查找和顺序查找 它支持随机查找的原因应与B树相同，但其还支持顺序查找，这个解释就比较简单了
对于B+树，其所有的关键字都会出现在叶节点，即其非叶节点上的关键字仅起索引作用，所以即使在非叶节点上出现了，在叶结点上还会再出现一次
所以对于B+树而言可以只查找叶子节点，故其在叶子节点那一层（根据B+树的性质可知其所有的叶子节点都在同一层）的最小元素上加了一个指针（即第二张图里的10）
这样就可以通过这个指针逐个访问叶子节点了，也就是顺序查找
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ab7a8156aa90eaeddb38e2b4f039a9/" rel="bookmark">
			mongodb 批量获取集合字段并更新：从一个集合获取字段并更新到另一集合中的某个字段，mongodb批量删除字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mongodb 批量获取集合字段并更新：从一个集合获取字段并更新到另一集合中的某个字段
这里是将mongdb数据库中的集合1中所有字段名1对应的值，复制给了集合2中所有字段名2对应的值。
“item”不需要改动，有一个前提，就是这两个集合的_id.ObjectId是相同的。
db = db.getSiblingDB("数据库名"); db.getCollection("集合1").find({}).forEach( function(item){ db.getCollection("集合1").update({"_id":item._id},{$set:{"字段名1":db.getCollection("集合2").find({"_id":item._id})[0].字段名2}}); } ) 如果想要删除集合1中所有文档下的字段名数据，包括字段一并删除，js脚本如下:
db = db.getSiblingDB("数据库"); db.getCollection("集合1").find({}}).forEach( function(item){ if(判断条件){ db.getCollection("集合1").update({"_id":item._id},{$unset:{"字段名":""}}); } } ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd598b026080886defd33b17b87670f6/" rel="bookmark">
			V4l2框架分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Table of Contents
1.V4L2框架概述
1.1 v4l2设备应用层流程
1.2 内核V4L2模块
1.2.1 video_device
1.2.2 v4l2_subdev
1.2.3 videobuf2
2. video_device结构体
2.1 图像处理模块
2.2 video_device处理流程
2.2.1 video_device 结构体成员介绍:
3. video_buf2
3.1 与video device的关系 3.2 Buffer 类型
3.2.1 vmalloc
3.2.2 Physically contiguous dma
3.2.3 Physically scattered
3.2.4 如何区分
3.3 vb2_ops
3.3.1 vb2_ops 结构体
3.3.2 videobuf2-core回调vb2_ops
3.4 mmap
4. subdev
4.1 概念
4.2 subdev注册流程
4.2.1 v4l2_subdev结构体
4.2.2 v4l2_subdev注册函数调用
4.3 应用层操作subdev
5. media framework
5.1 概念
6. v4l2设备节点组织流程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd598b026080886defd33b17b87670f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1637363a4d3ef2f3bf0a71bdb2b9f8ff/" rel="bookmark">
			关于我在华清远见上海中心参加嵌入式培训这件事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我来上海华清培训是因为在大学学习成绩平平，而且我的专业物联网感觉专业知识太过于分散，并没有针对性的学习过一个方向，临近毕业了感觉自己并没有一项专业性的知识来支撑我的就业能力，于是选择了到华清远见上海中心培训，试图掌握一门专业的深入性知识，于是就选择了上海华清的嵌入式开发课程。
到目前为止在华清远见的22021班级接受培训了三周左右的时间，学完了C语言的相关知识，和Linux系统命令的一些简单的用法，shell脚本命令的编写等基础知识。
首先对于C语言来说我不算陌生，大学里也学过比较基础的C语言知识，但是同样的知识，华清的教学更为仔细，前期凭靠大学残留在脑海中的知识还算过得去，到后期就越来越吃力了，还有很多新的知识从来没有接触过，需要耗费更多的时间和精力去预习和复习。而shell语言完全是一门未知的课程，希望自己将来能赶得上进度。学习过程中如果遇到理解不来的问题，可以向敬爱的董老师进行提问，无论是多刁钻的问题董老师都会一一细心讲解，直到把所有人的疑难杂症全部解决。不过靠老师始终是不行的，还得自己好好努力，争取获得更好的成绩。
希望将来在华清的培训能越来越好，取得令自己满意的成绩，将来得到一份满意的工作。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/165/">«</a>
	<span class="pagination__item pagination__item--current">166/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/167/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>