<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2033deb0f0fff6b64af1ce234462424c/" rel="bookmark">
			计算机网络——网络时延
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、计算机网络
2、网络时延
3、网络延迟标准和程度的定义
参考文献
1、计算机网络 计算机网络（谢希仁第七版）视频https://www.bilibili.com/video/BV1yE411G7Ma/?spm_id_from=autoNext计算机网络考研知识点与案例https://space.bilibili.com/360996402?spm_id_from=333.788.b_765f7570696e666f.1 计算机网络拓扑结构（星型、环形、总线型、网状、混合）
https://blog.csdn.net/xingyangs/article/details/84888057 2、网络时延 时延：指一个报文或分组从网络的一端传送到另一端所耗费的时间。时延=节点发送/传输时延+节点处理时延+传播时延+排队时延。
图1 网络时延示意图[1] 表1 各种网络时延定义、计算与数量级大小[2] 定义计算影响因素数量级大小发送/传输时延 主机或路由器发送数据帧所需要的时间，即：从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间
传输/发送时延 = L/R = 数据帧长度(b) / 信道带宽(b/s)
L：数据帧/分组长度 L （bit）
R：从路由器A到路由器B的链路传输速率/信道带宽(bps) 数据帧/分组长度、链路传输速率/信道带宽实际的发送时延通常在毫秒到微秒级处理时延 主机或路由器在收到分组后要花费一定的时间进行处理，比如分析首部，提取数据，差错检验，路由选择等
路由器A检查该分组的头部，以确定把它导向哪个链路所需的时间
节点处理延迟还可能包含其他因素，如在该分组的数据位从上游节点往路由器A的传送过程中，路由器A 可能在同步检查其中是否有位错发生，这种检查位错所造成的延迟 一般高速路由器的处理时延通常是微秒或更低的数量级传播时延 电磁波或光信号在信道（链路）中传播一定的距离需要花费的时间
传播时延 = D/S = 信道长度(m) / 电磁波/光信号在信道上的传播速率(m/s)
D：两台路由器之间的距离
S：电磁波或光信号在链路上的传播速率
距离实际传播时延在毫秒级排队时延 分组在所排队列中等待被发送到出链路的时间，某个特定分组的排队延迟取决于等待通过同一个出链路转发出去的分组的数目
分组的排队延迟取决于相应队列的分组到达强度和分布特性；
排队延迟是分组交换网中的主要延迟，它指的是PDU（协议数据单元） 在传输路径上每交换一次所引起的缓冲延迟的集合。若分组交换临时过载， 每一个 PDU 的目的输出端口上可能有许多分组排队
一个特定分组的排队时延取决于先期到达的、正在排队等待向链路传输分组的数量实际的排队时延通常在毫秒到微秒级 3、网络延迟标准和程度的定义 表2 网络延迟标准和程度定义[3] 程度具体阐述1~30ms极快几乎察觉不出有延迟，玩任何游戏速度都特别顺畅31~50ms良好没有明显的延迟情况，可以正常游戏51~100ms普通稍有停顿，对抗类游戏能感觉出明显延迟100~200ms较差访问网页有明显卡顿，偶尔出现丢包、掉线现象，无法正常游玩对抗类游戏200~500ms很差访问网页有明显的延迟和卡顿，经常出现丢包或无法访问&gt;500ms极差难以接受的延迟和丢包，甚至无法访问网页&gt;1000ms 基本无法访问 参考文献 [1] 网络时延的几个概念. https://blog.csdn.net/raysync/article/details/100705358.
[2] 百度百科 - 排队延迟.
[3] 百度百科--网络时延.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582f6905122acb01dc0ce7d1e96a4005/" rel="bookmark">
			[数据结构]模式匹配算法--KMP算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 模式匹配二. 模式匹配算法1. 朴素模式匹配算法2. KMP算法1). KMP算法的优势2). KMP算法的原理3). next数组的构造4). 利用next数组匹配的过程 二. KMP算法的代码实现1. 生成next[]数组2. KMP查找过程代码 一. 模式匹配 当有两个字符串Str = "abdabcde;和 modStr = "abcd";时，如果要在Str中查找与modelStr相等的子串，则称Str为主串，modelStr为模式串。在查找过程中，从Str中的第一个字符进行比较，如果找到与modelStr相同的子串，函数返回modelStr字符串第一次出现的位置，否则返回-1。以上过程就称为模式匹配.
二. 模式匹配算法 模式匹配算法，最广为人知的有两种算法，一种为简单且暴力的BF算法，一种为效率极高的KMP算法。下文将会对两种方法进行详解。
1. 朴素模式匹配算法 BF算法为朴素模式匹配算法的经典，该算法的主要思想，从主串的第一个字符与模式串中的第一个字符进行比较，若相等则继续比较，若不相等则从主串中不相等的位置与模式串中的第一个字符进行比较。
指针i指向主串，j指向模式串，当匹配失败时，i移动的位置为i = i - j + 1。
当所有字符串匹配成功后，指针j指向了模式串末尾的下一个，在进行匹配的过程中，不难发现，当每次匹配失败后，i指针都进行了不必要的回溯，这个回溯过程造成了时间的大量浪费。
2. KMP算法 1). KMP算法的优势 上文讲述了BF算法的实现，也阐述了BF算法的效率低下之处，KMP算法就是针对BF算法的改良，当进行模式匹配时，出现字符比较不等的情况，不用回溯i指针，而是利用已经匹配过后的结果，向右尽可能滑动的稍远一些，再继续进行比较。
2). KMP算法的原理 以字符串Str = "acabaabaabcacaabc";和 modStr = "abaabcac";为例，进行说明：
当i=8, j=6时，发现匹配失败: 如果按照BF算法， i指针会回溯至4的位置重新开始比较。但是这种i的回溯是有必要的吗？显然duck不必。
观察一下，j1=j4, j2=j5且i3=j1,i4=j2，所以回溯i指针到4的位置完全没有必要，根据上述等式关系，我们只需要将j指针的位置移动到j4的位置重新开始匹配。
再看一个例子: str=“aabababcaad” modStr=“babc”，当i=6, j=4时发生失配，但j1=j3,所以直接将j指针移动到j4的位置，开始匹配。
再看最后一个例子，str=“aacabcd”, modStr=“abcd,当发生失配时，怎么操作。
在发生失配时，将i指针向后移动一位，继续进行比较。
综合上述例子，不难看出模式串中存在着字符相同的元素，在模式串的子串中构成了前缀与后缀。并且在失配之后对于`i指针的移动存在一定的规律，从而引出了next数组的概念，next数组用于存放模式匹配失配时，模式串的滑动距离。
3). next数组的构造 通过上述的例子，已经得知next[]数组存放的内容为，模式串与目标串匹配失败时用于寻找模式串回溯位置的数组。
如何计算next数组呢？其中最重要的概念就是最大前缀与最大后缀。
公式是这样表示最大前缀与最大后缀的，但是实际中如何求解呢。str="abaabcac"以这个字符串为例，表示出它的前缀与后缀。
对于这个字符串它的前缀与后缀是这样的，所以它的最大前缀=最大后缀的字符串是a;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/582f6905122acb01dc0ce7d1e96a4005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171dcc047ecbdc5a48603ef504129537/" rel="bookmark">
			Labview状态机的介绍与程序示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、状态机简介 状态机是在工程应用中使用最多的设计模型。使用状态机，我们可以很容易的实现程序流程图中的判断、分支。
Labview状态机是由一个While循环、一个条件结构和一个移位寄存器组成的。其中while循环用来保证程序可以连续的运行；条件结构的各种分支中的代码用来描述状态机的各种状态，以及下一状态的选择；移位寄存器用来将之前状态所作出的选择传递到下一次循环的选择端子。
二、状态机的基本框架 在程序框图中创建一个while循环，并在while循环上添加移位寄存器，然后再while循环内创建一个条件结构，条件结构的选择端是一个枚举常量。
三、例程 3.1 运行效果 按下开始按钮后，LED开始以输入的时间间隔闪烁，按下停止按钮，程序停止运行。
3.2 程序框图 程序框图如下：
枚举类型的分支情况如下：
设置三项分别为：“开始”、“亮”、灭。然后在条件结构的分支处，右键-为每个值添加分支
其中左侧初始值与”开始“分支内的都是同一个枚举常量（即通过复制粘贴得到的）。
3.3 程序逻辑 初始条件的输入值为“开始”，进入“开始”的条件分支进行判断。
如果按钮按下，输出“亮”，并作为下一次条件的输入；如果按钮未按下，输出“开始”，并作为下一次条件的输入，即保持原状态。 如果条件的输入为“亮”，此时条件输出“灭”，并作为下一次的输入。
如果条件的输入为“灭”，此时条件输出“亮”，并作为下一次的输入。
在“开始”和“灭”分支进行期间，为LED赋值False；在“亮”分支期间，为LED赋值True。
这样就实现了：启动程序后，程序一直循环执行“开始”分支，LED灯灭。按下按钮后，程序在“亮”分支和”灭“分支交替执行，实现LED灯的亮灭变化。
可以通过为while循环添加等待延时调整LED闪烁时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e33a16d72e5e823a2e62aac6dd1310/" rel="bookmark">
			spring--aop--02--纯注解实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现aop的三步： 创建目标类与切面类，加入到Spring容器中，并指明切面类在切面类方法上标注通知注解开启注解版aop模式 二、配置类实现AOP代码 （1）配置类
package com.fuping3.aopconfig; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.EnableAspectJAutoProxy; @Configuration @ComponentScan(basePackages = {"com.fuping3.aopconfig"}) /** * @EnableAspectJAutoProxy 表示开启注解版aop的注解 * 备注： * 1、proxyTargetClass默认为false--表示使用jdk代理 * 2、proxyTargetClass = true表示使用cglib代理，当jdk代理不可用时仍使用cglib代理 */ // //@EnableAspectJAutoProxy @EnableAspectJAutoProxy(proxyTargetClass = true) public class MyAopConfig { } （2）Java代码
package com.fuping3.aopconfig; public interface IUser { int div(int i, int j); } package com.fuping3.aopconfig; import org.springframework.stereotype.Component; @Component public class User implements IUser{ public int div(int i,int j){ System.out.println("目标方法执行..."); return i/j; } } package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07e33a16d72e5e823a2e62aac6dd1310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81e1734968f04a73d15400fc28fe026/" rel="bookmark">
			论文阅读笔记（8）: 图卷积半监督分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
参考：链接
pytorch git hub: 链接
# -*- coding: utf-8 -*- # time : 2021/4/19 19:52 # task: gcn 代码解读 import torch import numpy as np import scipy.sparse as sp import sys from sklearn.preprocessing import OneHotEncoder import sklearn import pandas as pd ''' 先将所有由字符串表示的标签数组用set保存，set的重要特征就是元素没有重复， 因此表示成set后可以直接得到所有标签的总数，随后为每个标签分配一个编号，创建一个单位矩阵， 单位矩阵的每一行对应一个one-hot向量，也就是np.identity(len(classes))[i, :]， 再将每个数据对应的标签表示成的one-hot向量，类型为numpy数组 ''' def encode_onehot(labels): classes = set(labels) # set() 函数创建一个无序不重复元素集 classes_dict = {c: np.identity(len(classes))[i, :] for i, c in # identity创建方矩阵 enumerate(classes)} # 字典 key为label的值，value为矩阵的每一行 # enumerate函数用于将一个可遍历的数据对象组合为一个索引序列 labels_onehot = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81e1734968f04a73d15400fc28fe026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676fed4bfeaca4a63c71df8be82ad3f3/" rel="bookmark">
			笔记-微信订阅号开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 笔记-微信订阅号开发流程创建菜单网页授权：js-sdk 笔记-微信订阅号开发流程 创建菜单 先进入：https://mp.weixin.qq.com/
创建一个小程序订阅号： 订阅号和服务号的区别：
订阅号相当于一个群里面的一个用户，他发的消息需要打开订阅号助手里面才能查看，个人就能申请。
服务号相当于一个好友，可以“单独”发消息给你，但是需要企业认证才能申请 。
所以我们这里做的是订阅号开发
订阅号有可视化操作界面，怎么设置看微信文档就行了，我们这里讲一些程序员怎么用代码来写订阅号：
首先进入微信公众号文档的 开发 选项的 开发者工具 里面的 公众平台测试号，登录
首先 给测试号加一个菜单，先使用我们的appid 和 appsecret(密码) 获取 access_token；
获取到access_token后，就可以用access_token来创建我们的菜单了：
其中body填你的菜单,具体怎么创建可以查看微信公众号文档：
//这是我随便建的的菜单 { "button": [ { "type": "view", "name": "小米商城系统", "url": "http://47.117.121.44:3000/dist/index.html#/" }, { "type": "click", "name": "按钮", "key": "图书管理系统" }, { "name": "大菜单", "sub_button": [ { "type": "view", "name": "小米商城后台", "url": "http://47.117.121.44:3000/object_admin/index.html" }, { "type": "click", "name": "图书管理系统", "key": "图书管理系统" } ] } ] } 网页授权： 访问地址:(转二维码扫码。或者放到菜单中点击)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/676fed4bfeaca4a63c71df8be82ad3f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c0b730b8a242d4a78a8f2ed577c054/" rel="bookmark">
			Metaspace内存溢出排查思路、定位、工具与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Metaspace内存溢出排查思路、定位、工具与解决
背景：线上项目，每天约50w笔交易请求，每隔两周需要重启一次，发生过几次cpu飙升，无响应的情况。
故障分析：
1.首先排查cpu飙升的原因，根据cat定位cpu飙升开始阶段存在大量gc情况（每分钟7w次），初步定位内存泄露。
2.排查应用日志里oom 类似日志，发现爆 metaspace 溢出。
3.因故障后第一时间进行了重启，并未dump日志，第一时间无法分析
4.事后第三天使用dump内存（/app/jdk1.8.0_121/bin/jmap -dump:format=b,file=1.dump 54），并使用jvisualvm工具对内存对象进行排查。排查思路：寻找数量很多但没有实例的class。
发现存在大量：com.xxx.yyy.credit.biz.common.Item$JaxbAccessorM_getValue_setValue_java_lang_String 而且实例数为0
根据代码定位为工具类引起，如下红色部分代码，每次调用都生成新的instance。
public static String convertToXml(Object obj, String encoding) { String result = null; try { JAXBContext context = JAXBContext.newInstance(obj.getClass()); Marshaller marshaller = context.createMarshaller(); marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); marshaller.setProperty(Marshaller.JAXB_ENCODING, encoding); StringWriter writer = new StringWriter(); marshaller.marshal(obj, writer); result = writer.toString(); } catch (Exception e) { log.error("转换为xml异常", e); } return result; } 5.修复验证，修复并做压测，观察metaspace持续无增涨。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c41a2a3ae640390eba3877b4c86d585/" rel="bookmark">
			leetcode 028.实现strStr()，即查找重复字符串（KMP算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本题是经典的字符串单模匹配的模型，因此可以使用字符串匹配算法解决，常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等，本文 ## 前言
本题是经典的字符串单模匹配的模型，因此可以使用字符串匹配算法解决，常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等，本文将讲解朴素解法（暴力匹配）和KMP算法
因为哈希方法可能出现哈希值相等但是字符串不相等的情况，而 strStr 函数要求匹配结果必定正确，因此本文不介绍哈希方法，有兴趣的读者可以自行了解滚动哈希的实现（如 Rabin-Karp 算法）。
方法一：暴力匹配 思路及算法 我们可以让字符串 needle 与字符串haystack 的所有长度为 mm 的子串均匹配一次。
为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 −1。
代码 class Solution { public int strStr(String haystack, String needle) { int n = haystack.length(), m = needle.length(); for (int i = 0; i + m &lt;= n; i++) { boolean flag = true; for (int j = 0; j &lt; m; j++) { if (haystack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c41a2a3ae640390eba3877b4c86d585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/175e92f0e61743856974dc5b7f3be3ab/" rel="bookmark">
			GB9706.1-2007名词解释：电压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电压：
1、 高电压：任何超过 1000V 交流或 1500V 直流或 1500V 峰值的电压。
2、 网电源电压：多相供电网中两相线之间的电压，或单相供电网中相线与中性线之间的电压。
3、 安全特低电压：在用安全特低电压变压器或等效隔离程度的装置与供电网隔离，当变压器或变换器由额定供电电压
供电时，在不接地的回路中，导体间交流电压不超过 25V 或直流电压不超过 60V 名义电压。
漏电流：
1、 对地漏电流：由网电源部分穿过或跨过绝缘流入保护接地导线的电流。
2、 外壳漏电流：在正常使用时，从操作者或患者可触及的外壳或外壳部件(应用部分除外)，经外部导电连接而不是保护接地导线流入大地或外壳其他部分的电流。
3、 患者漏电流：从应用部分经患者流入地的电流，或是由于在患者身上出现一个来自外部电源的非预期电压而从患
者经 F 型应用部分流入地的电流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7446208fbb67b4fcea0a12760e802538/" rel="bookmark">
			Qt 通过UDP广播搜索设备(模拟设备回应并修改IP实现过程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UDP搜索设备 UDP广播搜索设备用途通过广播发送搜索指令设备收到后进行响应同一个端口绑定多个IP为什么有多个IP，呐，就这么多 程序效果程序介绍设备端客户端 UDP广播搜索设备 用途 在不知晓设备IP的情况下，快速找到设备IP并进行修改！（常规操作）！
通过广播发送搜索指令 设备收到后进行响应 回复内容：包含设备的IP、MAC地址等信息（根据需要进行实现）
同一个端口绑定多个IP 同一个端口绑定多个IP
foreach (QHostAddress address, getIpAddrs()) { QUdpSocket *socket = new QUdpSocket(this); bool bindOK = socket-&gt;bind(address, LOCAL_PORT, QUdpSocket::ShareAddress); connect(socket,SIGNAL(readyRead()),this,SLOT(processPengingDatagram())); qDebug()&lt;&lt;QString("socket bind port:%1 to addr:%2 %3.").arg(LOCAL_PORT).arg(address.toString().toLocal8Bit().data()).arg(bindOK?"ok":"fail"); udpSocketList-&gt;append(socket); } //获取IP QList&lt;QHostAddress&gt; getIpAddrs() { QList&lt;QHostAddress&gt; listaddr; //使用allAddresses命令获得所有的ip地址 QList&lt;QHostAddress&gt; list=QNetworkInterface::allAddresses(); QString str = ""; foreach (QHostAddress address,list) { if(address.protocol()==QAbstractSocket::IPv4Protocol &amp;&amp; address != QHostAddress::LocalHost) { listaddr.append(address); } } return listaddr; } 为什么有多个IP，呐，就这么多 原因：因为计算机可能存在多个网卡，如果你的设备连接的是其中一个，如果不全部绑定，那么设备就有可能收不到我们的搜索报文
PS：如果不全部绑定，在虚拟机中尝试的时候能收到，返回返回的数据Client收不到。
程序效果 设备端是通过模拟程序来实现的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7446208fbb67b4fcea0a12760e802538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931dbb9799726b7583357cb7858bd472/" rel="bookmark">
			C语言练习题：快递费用计算！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 题目编写任务编程要求 解题思路Code运行结果 题目 编写任务 上海市的某快递公司根据投送目的地距离公司的远近，将全国划分成5个区域：
快递费按邮件重量计算，由起重费用、续重费用两部分构成：
（1） 起重（首重）1公斤按起重资费计算（不足1公斤，按1公斤计算），超过首重的重量，按公斤（不足1公斤，按1公斤计算）收取续重费；
（2） 同城起重资费10元，续重3元/公斤；
（3） 寄往1区（江浙两省）的邮件，起重资费10元，续重4元；
（4） 寄往其他地区的邮件，起重资费统一为15元。而续重部分，不同区域价格不同：2区的续重5元/公斤，3区的续重6.5元/公斤，4区的续重10元/公斤。
编程要求 编写程序，从键盘输入邮件的目的区域编码和重量，计算并输出运费，计算结果保留2位小数。
提示 续重部分不足一公斤，按1公斤计算。因此，如包裹重量2.3公斤：1公斤算起重，剩余的1.3公斤算续重，不足1公斤按1公斤计算，1.3公斤折合续重为2公斤。如果重量应大于0、区域编号不能超出0-4的范围。 输入 用逗号分隔的两个数字，第一个表示区域、第二个是重量：”%d,%f” 输出 价格的输出格式："Price: %.2f\n" 区域错误的提示信息："Error in Area\n" 解题思路 就是直接按照题目要求来写代码就可以了，用到了if，else的判断结构。 Code #include&lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { /*********Begin*********/ int area = 0; float weight,start_weight,extra_weight,price = 0; int area_start_money[5] = {10,10,15,15,15}; // 每个区域的起重费用 float area_extra_money[5] = {3,4,5,6.5,10}; // 每个区域的续重费用 // printf("please input area number and weight(eg:0,10.5):\n"); scanf("%d,%f",&amp;area,&amp;weight); //输入合法性检查 if(area&lt;0 || area&gt;4){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/931dbb9799726b7583357cb7858bd472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49a8a43ed117fa76651c8f6996452972/" rel="bookmark">
			jenkins分环境部署vue/react项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue/react部署请参考上一篇文章：https://blog.csdn.net/bocongbo/article/details/115909427
项目开发正常都需要开发环境、测试环境、生产环境，每个环境部署都比较麻烦，可以使用jenkins自动化部署
1、安装自定义参数化插件 Extended Choice Parameter Plug-In
2、配置自定义参数
3、配置shell脚本
shell脚本内容
#!/bin/bash // 判断环境 if [ $env == "dev" ]; then url="devhtml" echo "开发环境" elif [ $env == "test" ]; then url="testhtml" echo "测试环境" else url="html" echo "生产环境" fi npm install rm -rf ./dist/* npm run build // 根据环境的url，修改需要替换的环境目录 rm -rf /usr/share/nginx/$url/vue-demo/* cp -rf ./dist/* /usr/share/nginx/$url/vue-demo/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb2c099fc4ec56aa166a35512af9db1/" rel="bookmark">
			A/B Testing实践指南01: AB实验入门简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 在线控制实验专业术语2 为什么做实验？相关性、因果性和可信度3 控制实验所需的因素4 控制实验的三个原则5 滴水穿石6 几个有趣的在线控制实验案例7 延伸阅读8 延伸链接 本文主要是基于《Trustworthy Online Controlled Experiments —— A Practical Guide to A/B Testing》的读书分享及实践思考 0 前言 基于在每家公司每年进行超过20,000次控制实验的实践经验，作者总结了一些多年来遇到的问题、教训和陷阱。分享了如何通过在线控制实验(online control experiment) 来支持以数据驱动决策的企业文化，而不是依靠HiPPO（Highest Paid Person’s Opinion，即“老大说了算”）。提出对学生和刚开始做实验的行业专业人士的建议，并针对希望以数据驱动为决策的从业者深入探讨了一些高级话题。
本书内容既适用于大、小型互联网公司，也适用于团队和公司内部的组织。其核心问题是评估实验结果的可信度。作者相信特维曼定律（Twyman’s Law）所暗示的怀疑主义：任何看起来有趣或者与众不同的数字通常都是错误的。鼓励读者仔细检查结果并进行有效性测试，尤其是突破性的积极结果。获得数据很容易，但是获得正确的数据很难。
通过本书可收获以下学习内容：
科学方法：使用科学的方法，通过对照实验来评估假设。定义标准：定义关键的度量标准和理想的总体评估标准（OEC, Overall Evaluation Criterion）。可信结果：测试结果的可信度，并提醒实验者是否违反假设。搭建平台：构建一个可扩展的平台，将实验的边际成本降低到接近零。避坑指南：避免陷阱，如结转效应（Carryover Effects）和特维曼定律（Twyman’s Law），了解统计问题如何在实践中发挥作用。 【全书框架】
第一部分：任何人都可以阅读，无背景知识要求，主要包括以下四章：
第一章：概述在线控制实验的优势，并简要介绍实验相关的专业术语；
第二章：通过案例概述一个完整的实验操作过程；
第三章：描述常见的陷阱，并说明如何构建实验的可信度；
第四章：概述如何构建一个实验平台，并扩展在线实验。第二部分：包括五个基础性的章节，比如组织度量等，推荐每个人阅读，尤其是领导和高管。第三部分：包含两章， 补充了在线控制实验的技术。建议阅读人群包括：领导者，数据科学家，工程师，分析师，产品经理。 本部分内容有助于指导他们对如何有效的为项目投入时间与资源。第四部分：专注于建立实验平台，主要针对工程师。第五部分：深入探讨高级分析主题，主要针对数据科学家。 【作者简介】
Ron Kohavi是Airbnb的副总裁和技术人员。之前是微软的技术研究员和公司副总裁。在加入微软之前，是亚马逊的数据挖掘和个性化总监。拥有斯坦福大学计算机科学博士学位，其论文被引用超过40000次，其中有三篇在计算机科学被引用论文Top 1000。Diane Tang是Google研究员，擅长大规模数据分析和基础设施、在线控制实验和广告系统。拥有哈佛大学的文学学士学位和斯坦福大学的硕、博学位，并在移动网络、信息可视化、实验方法、数据基础设施和数据挖掘/大数据方面拥有专利和出版物。Ya Xu是LinkedIn数据科学和实验担任负责人。她在A/B测试领域使领英成为最受尊敬的公司之一。在领英之前，她在微软工作，并获得了斯坦福大学的统计学博士学位。她被广泛认为是实验领域中最重要的科学家、实践者和思想领袖之一，拥有多项专利和出版物，经常在全国各地的顶级会议、大学和公司发表演讲。 【部分荐序】
“精益方法论（Lean Methodology）的核心是科学方法：创建假设、进行实验、收集数据、提取见解、验证或修改假设。A/B测试是创建可验证和可重复实验的黄金标准，这本书是它的决定性文本”。——史蒂夫•布兰克(Steve Blank)斯坦福大学兼职教授，现代创业之父，《创业者手册》(The Startup Owner’s Manual)和《顿悟的四个步骤》(The Four Steps to The Epiphany)的作者。“一本既严谨又通俗易懂的伟大著作。读者将学习如何将可信的控制实验带给他们的组织，这些实验已经彻底改变了互联网产品开发”。——Adam D’Angelo, Quora联合创始人兼首席执行官，Facebook前CTO。“‘哪个在线选择更好?’我们经常需要做出这样的选择，而且经常犯错。为了确定哪种方法更有效，我们需要严格的控制实验，也就是A/B测试。这本由来自微软、谷歌和LinkedIn的专家编写的优秀而生动的书介绍了A/B测试的理论和最佳实践。这是互联网人的必读之书!”——Gregory Piatetsky-Shapiro博士，KDnuggets总裁，SIGKDD联合创始人，LinkedIn在数据科学与分析方面的顶级专家。 One accurate measurement is worth more than a thousand expert opinions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fb2c099fc4ec56aa166a35512af9db1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91bd732a02536b60d89c40966880fdc2/" rel="bookmark">
			【前端学习】网络知识基础（持更中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考文章：
前端需要掌握的网络知识（1）
前端需要掌握的网络知识（2）
计算机网络的七层协议
主机：
（1）应用层：访问网络服务的接口（DNS等）
（2）表示层：提供数据格式转换服务
（3）会话层：建立端连接并提供访问验证和会话管理（SESSION）
（4）传输层：（Segment）提供应用进程之间的逻辑通信（进程、端口socket等）
网络：
（5）网络层：（Packet）为数据在结点之间传输创建逻辑链路，并分组转发数据（路由器、多层交换机、防火墙等）
（6）链路层：（Frame）在通信的实体间建立数据链路连接（网卡、网桥、二层交换机等）
（7）物理层：（Bit）为数据端设备提供原始比特流的传输的通路应用层
（1）HTTP：超文本传输协议
（2）工作原理：客户端向服务器发送请求报文（包含请求的方法、URL、协议版本、请求头部和请求数据）；服务器以一个状态行作为响应（内容包括协议版本、成功/错误版本、服务器信息、响应头部和响应数据）。
（3）HTTP请求/响应的步骤：
①客户端连接到Web服务器
②发送HTTP请求
③服务器接受请求并返回HTTP响应
④释放连接TCP连接
⑤客户端浏览器解析HTML内容
（4）常见HTTP状态码：
200 400 401 402 403 404 500 503 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e7366c027a2d130908f1e67a53256d/" rel="bookmark">
			MTK开发之—开机永不灭屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤一：修改配置文件 文件路径：/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
说明一下：def_screen_off_timeout这个参数是默认上电后关闭屏幕时间，单位是ms，600000就是10分钟，对应的就是10 minutes， 改为0就是不休眠，在packages/apps/Settings/res/values/arrays.xml文件中有一一对应的关系
&lt;integer name="def_screen_off_timeout"&gt;600000&lt;/integer&gt;修改为： &lt;integer name="def_screen_off_timeout"&gt;0&lt;/integer&gt; 步骤二：检查配置选项 文件路径：/packages/apps/Settings/res/values/arrays.xml
如下所示，当我们将步骤一中的def_screen_off_timeout设置为0时，对应的是screen_timeout_values下的值，最后对应的就是screen_timeout_entries下的never，意思就是永不休眠
&lt;!-- Display settings. The delay in inactivity before the screen is turned off. These are shown in a list dialog. --&gt; &lt;string-array name="screen_timeout_entries"&gt; &lt;item&gt;15 seconds&lt;/item&gt; &lt;item&gt;30 seconds&lt;/item&gt; &lt;item&gt;1 minute&lt;/item&gt; &lt;item&gt;2 minutes&lt;/item&gt; &lt;item&gt;5 minutes&lt;/item&gt; &lt;item&gt;10 minutes&lt;/item&gt; &lt;item&gt;30 minutes&lt;/item&gt; &lt;item&gt;never&lt;/item&gt; &lt;/string-array&gt; &lt;!-- Do not translate. --&gt; &lt;string-array name="screen_timeout_values" translatable="false"&gt; &lt;!-- Do not translate. --&gt; &lt;item&gt;15000&lt;/item&gt; &lt;!-- Do not translate. --&gt; &lt;item&gt;30000&lt;/item&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2e7366c027a2d130908f1e67a53256d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14d5ee060f1af83f2c1591a3b2d7499/" rel="bookmark">
			Linux 查看mysql安装运行路径 my.cnf位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找my.cnf位置 mysql --help | grep my.cnf 或 find / -name my.cnf 查看mysql安装运行路径 ps -ef | grep mysql [root@bogon /]# ps -ef | grep mysql root 1246 1 0 4月13 ? 00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/bogon.pid mysql 1472 1246 0 4月13 ? 00:23:57 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=bogon.err --pid-file=/data/mysql/bogon.pid --socket=/tmp/mysql.sock /usr/local/mysql/lib：运行路径
/usr/local/mysql/ ：安装路径
/data/mysql ：数据库文件的存放路径
或 -- MySQL 的安装路径 show variables like '%basedir%'; -- 数据库文件存放位置 show variables like '%datadir%'; -- 或 show global variables like "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c14d5ee060f1af83f2c1591a3b2d7499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3ea6ffe661183bf46ad2ccfa8039e1/" rel="bookmark">
			C# 学习笔记 19.文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件操作的核心类 .net framerwork提供的文件操作基本都在 system.io命名空间下。 C#学了之后感觉比c++用起来方便很多。c++如果融入更多好的工具包多好。
2.File类 FILE 的方法都是静态的效率高。相对Fileinfo
class Program { static void Main(string[] args) { FileStream fs = null; StreamWriter writer = null; string path = "D:\\test.txt"; if(!File.Exists(path)) { fs = File.Create(path); Console.WriteLine("新建一个文件：{0}", path); } else { fs = File.Open(path, FileMode.Open); Console.WriteLine("文件存在，直接打开！"); } writer = new StreamWriter(fs); writer.WriteLine("测试文本"); Console.WriteLine("向测试文件写入数据"); writer.Flush(); writer.Close(); Console.WriteLine("关闭数据流！"); Console.ReadKey(); } } 3.Directory 和DirctoryInfo类 2个类包含了创建，移动，删除，枚举目录和子目录成员。
class Program { static void Main(string[] args) { string dir_path = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da3ea6ffe661183bf46ad2ccfa8039e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a339f777189a1bc6ecc3b1fa590b036/" rel="bookmark">
			浅谈JS中的递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、递归 递归（英语：Recursion）
在数学与计算机科学中，是指在函数的定义中使用函数自身的方法
在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数
其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解
一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回
下面实现一个函数 pow(x, n)，它可以计算 x 的 n 次方
使用迭代的方式，如下：
function pow(x, n) { let result = 1; // 再循环中，用 x 乘以 result n 次 for (let i = 0; i &lt; n; i++) { result *= x; } return result; } 使用递归的方式，如下：
function pow(x, n) { if (n == 1) { return x; } else { return x * pow(x, n - 1); } } pow(x, n) 被调用时，执行分为两个分支：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a339f777189a1bc6ecc3b1fa590b036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad7f04bba96661d69afc469e070e714/" rel="bookmark">
			一道工作中遇到的异步获取数据问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述解决问题问题升级结语 问题描述 先看下面一段代码：
function main(n) { for (let i = 1; i &lt;= n; i++) { request(`第${i}个请求`, getRandomTime(500, 2000)); } } function getRandomTime(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; } function request(text, time) { new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(text) }, time); }).then(res =&gt; { console.log(res); }) } main(5); 这段代码的意思为，同时发送多个请求，每个请求都需要0.5s-2s的等待时间才能返回结果。
运行上述代码，结果如下：
由于每个请求需要等待的时间是不确定的，进而如果我们想得到最后一次发送请求的数据，此时应该如何处理呢？（类似于实际应用中同一时间向后端请求多次，但是我们只需要得到最后一次请求的结果即可）
解决问题 解决思路：由于请求的等待时间是不确定的，所以我们无法直接得知最后一次请求将会是第几次返回。如果此时我们为每组请求都赋予一个请求id，等到它的数据返回时，那么我们就可以直接通过其请求id来判断它是第几个请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad7f04bba96661d69afc469e070e714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17915ef5753f942a5786b520f2c472f/" rel="bookmark">
			WHEA_INTERNAL_ERROR 一个关于戴尔电脑G3 G5 G7 所有系列的一个近期硬件BUG异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于我开10次机有9次蓝屏一次正常开机的玄学问题
正题：
拔掉外设，开机玄学，不敢关机，每次都是睡眠……
这个问题真的是一波三折，网上查阅各种能查的资料，尝试了N种方法，最终在淘宝上花了几十块钱请大佬解决了。所谓解决，其实就是Update了一下Windows……不得不说这几十块花的我肉疼，我以为还得改什么高难度设置呢。
更新到最新版的Windows就好啦！
我试了几次拔掉外设不拔掉外设的开关机，蓝屏拜拜~
**
弯路走了一堆，依旧蓝屏反笑脸 **
官方的修复更新
作者：Hookin丶
链接：https://www.zhihu.com/question/428866145/answer/1781565592
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
关于近期戴尔G系列笔记本蓝屏的问题，官方已经在 supportAssist 中提供了修复更新。下面分享我的操作步骤:暂时断开电源并开机（蓝屏问题跟电源有关），此时你可以正常进入系统在开始菜单中找到 supportAssist 并运行3. 在弹出的窗口中点击全部运行稍后会提示你更新驱动4. 点击进入更新，你会看到它提示你更新时要连接电源。你连接好电源，点击安装后就等下它，稍后它会要你重启，重启后的你就不用理它了，它会自动安装:重启进入系统，一切恢复正常。
然而这个方式我就没有用，可能因为我的Windows不是正规途径到手的。
另一个官方修复support assist os recovery
这个我也是，直接无法修复。
但是在安全模式下的Windows还原，的确可以使用，还原到上一个保存的还原点，卸载Windows最近的更新。但是过了一个月之后，我的蓝屏问题又出现了，而且这次，还原系统也没有用了。
去专卖店，竟然直接要我重做系统！！！！我在学期正中间，N个项目，而且我是学软件工程的，现在让我做系统简直是要我命！！！！算了吧！！！！就算我一直开机不关到这学期结束我也不会重做系统的！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37dedfdfb4ea95ae083388874e23aa6c/" rel="bookmark">
			「react进阶」 react全部api解读&#43;基础实践大全(夯实基础)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多同学用react开发的时候，真正用到的React的api少之又少，基本停留在Component,React.memo等层面,实际react源码中，暴露出来的方法并不少，只是我们平时很少用。但是React暴露出这么多api并非没有用，想要玩转react,就要明白这些API究竟是干什么的，应用场景是什么，今天就让我们从react 到 react-dom,一次性把react生产环境的暴露api复习个遍(涵盖90%+)。
我们把react,API，分为组件类，工具类，hooks，再加上 react-dom ，一共四大方向，分别加以探讨。
为了能让屏幕前的你，更理解api,我是绞尽脑汁,本文的每一个api基本都会出一个demo演示效果,弥补一下天书般的react文档😂😂😂，还有就是我对api基本概念的理解。创作不易，希望屏幕前的你能给笔者赏个赞，以此鼓励我继续创作前端硬文。
老规矩，我们带着疑问开始今天的阅读(自测掌握程度)？
1 react暴露的api有哪些，该如何使用？2 react提供了哪些自测性能的手段？3 ref既然不能用在函数组件中，那么父组件如何控制函数子组件内的state和方法？4 createElement和cloneElement有什么区别，应用场景是什么？5 react内置的children遍历方法，和数组方法,有什么区别？6 react怎么将子元素渲染到指定父元素之外的指定容器中？… 我相信读完这篇文章，这些问题全都会迎刃而解？
组件类 组件类，详细分的话有三种类，第一类说白了就是我平时用于继承的基类组件Component,PureComponent,还有就是react提供的内置的组件，比如Fragment,StrictMode,另一部分就是高阶组件forwardRef,memo等。
Component Component是class组件的根基。类组件一切始于Component。对于React.Component使用，我们没有什么好讲的。我们这里重点研究一下react对Component做了些什么。
react/src/ReactBaseClasses.js
function Component(props, context, updater) { this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; } 这就是Component函数，其中updater对象上保存着更新组件的方法。
我们声明的类组件是什么时候以何种形式被实例化的呢？
react-reconciler/src/ReactFiberClassComponent.js
constructClassInstance
function constructClassInstance( workInProgress, ctor, props ){ const instance = new ctor(props, context); instance.updater = { isMounted, enqueueSetState(){ /* setState 触发这里面的逻辑 */ }, enqueueReplaceState(){}, enqueueForceUpdate(){ /* forceUpdate 触发这里的逻辑 */ } } } 对于Component， react 处理逻辑还是很简单的，实例化我们类组件，然后赋值updater对象，负责组件的更新。然后在组件各个阶段，执行类组件的render函数，和对应的生命周期函数就可以了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37dedfdfb4ea95ae083388874e23aa6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918f4997e0c03706317e74a6727fed13/" rel="bookmark">
			Python实现子线程代码“同时”执行完毕后，再执行后续函数模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在python中用多线程完成任务时，在后面添加了一个提醒函数，结果发现线程开启后提醒函数就触发了。
解决方法：将多线程join()起来，就会跑完所有多线程任务再执行后续的函数模块。
join()的使用方法：
import threading import time def run(): time.sleep(2) print('当前线程的名字是： ', threading.current_thread().name) time.sleep(2) if __name__ == '__main__': start_time = time.time() print('这是主线程：', threading.current_thread().name) thread_list = [] for i in range(5): t = threading.Thread(target=run) thread_list.append(t) for t in thread_list: t.setDaemon(True) t.start() for t in thread_list: t.join() print('主线程结束了！' , threading.current_thread().name) print('一共用时：', time.time()-start_time) 上述代码引用自https://www.cnblogs.com/cnkai/p/7504980.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05624adbddf00b047f7d8da9efebebbd/" rel="bookmark">
			cocos2dx 手游luac 解密 文件的key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ida 动态调试app
找到cocos2dx 引擎文件
解密函数
这个是秘钥计算
根据上面源码可以看出 v5 是源码中的 key2
v5 = ((int (__fastcall *)(int, unsigned int))unk_D0E8E9D4)(a3, a4);
秘钥位数
CD0998A0 地址的8位数就是key秘钥
这就是秘钥
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011033911415576ee65b1d6f476164e5/" rel="bookmark">
			项目实训（树莓派）（七）树莓派4B下的ubuntu系统下命令行的使用-磁盘管理部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言实验目的实验内容实验环境实验步骤1.df命令2.fdisk命令-磁盘分区3.hdparm命令-显示与设定硬盘参数4.lsblk命令-查看系统的磁盘5.vgextend命令-扩展卷组 前言 通过前面的实验，我们已经将关于Ubuntu系统的文件管理和文件编辑和系统管理部分的命令行做完了，接下来我们将进行关于linux磁盘管理部分的linux命令行实验。
实验目的 1.掌握Ubuntu系统下文件系统中磁盘管理部分命令行的原理及使用
实验内容 本次实验主要是掌握Linux系统下的磁盘管理部分的使用，主要包括以下内容：
第四部分（系统管理部分）：
1.df命令-显示磁盘空间使用情况
2.fdisk命令-磁盘分区
3. hdparm命令-显示与设定硬盘参数
4. lsblk命令-查看系统的磁盘
5. vgextend命令-扩展卷组
实验环境 树莓派4B，系统为Ubuntu 20.10系统 。实验的编程环境为Terminal终端程序
实验步骤 1.df命令 （1）命令格式
df[参数][指定文件]
（2）命令功能
df命令的英文全称即“Disk Free”，顾名思义功能是用于显示系统上可使用的磁盘空间。默认显示单位为KB，建议使用“df -h”的参数组合，根据磁盘容量自动变换合适的单位，更利于阅读。日常普遍用该命令可以查看磁盘被占用了多少空间、还剩多少空间等信息。
（3）命令参数
参数功能说明-a显示所有系统文件-B&lt;块大小&gt;指定显示时的块大小-h以容易阅读的方式显示-H以1000字节为换算单位来显示-i显示索引字节信息-k指定块大小为1KB-l只显示本地文件系统-t&lt;文件系统类型&gt;只显示指定类型的文件系统-T输出时显示文件系统类型– -sync在取得磁盘使用信息前，先执行sync命令 （4）使用范例
例一：显示磁盘分区使用情况
命令：
df 输出：
例二：以容易阅读的方式显示磁盘分区使用情况
命令：
df -h 输出：
例三：显示指定文件所在分区的磁盘使用情况
命令：
df /etc/dhcp 输出：
例四：显示文件类型为ext4的磁盘使用情况
命令：
df -t ext4 输出：
2.fdisk命令-磁盘分区 （1）命令格式
fdisk[参数]
（2）命令功能
fdisk命令的英文全称是“Partition table manipulator for Linux”，即作为磁盘的分区工具。进行硬盘分区从实质上说就是对硬盘的一种格式化， 用一个形象的比喻，分区就好比在一张白纸上画一个大方框，而格式化好比在方框里打上格子。
（3）命令参数
参数功能说明-b指定每个分区的大小-l列出指定的外围设备的分区表状况-s将指定的分区大小输出到标准输出上，单位为区块-u搭配”-l”参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址-v显示版本信息 （4）使用范例
例一：查看所有分区情况
命令：
fdisk -l 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/011033911415576ee65b1d6f476164e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c7d87525fdd35dced5762af0f1e946/" rel="bookmark">
			无名杀武将设计流分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 还记得在高中的时候，在熟悉的寝室门楼间，听到了三两陌生的声音：
“杀！”
“闪！”
凑近一瞧，竟有同学拿着图案新颖的扑克牌在床板上玩耍，从此三国杀就步入了我的眼帘，细细算来，十年有余。
那时就在想，自己能否也设计一个武将出来，跟大家一起玩耍。
偶然间，认识到了无名杀，恰好代码可以用JavaScript编写，就尝试写了写技能。
当完成好一个技能后，觉得使用后甚是空洞，觉得索然无味，这是什么原因呢？
想了很久才想通，对于我来说，缺的是熟悉感，是熟知，是认识。
武将重要三要素 最重要的三要素：插画，语音，技能
1.插画：武将应该有一张能够一眼就能认识，并且分辨率高图像清晰。
我一般采用游戏原画、同人图，我使用的搜索引擎：http://soutushenqi.com/
当获得图片后，应该裁剪到350x464的尺寸，我使用的裁剪工具：https://ps.gaoding.com/#/
2.语音：武将发动技能时，一定要有语音，最好和技能有关，数量不够可以硬凑，推荐一个技能对应的语音个数：2-5个
我一般在游戏里录音，或者网上下载语音文件，或者录制视频里的语音，我使用的录音工具：Moo0 录音专家 1.43
一般录好语音，应该对其进行剪辑，我使用的语音剪辑工具是：https://mp3cut.net/cn/
3.技能：武将应该有能体现自身特色的技能，这个需要先设计
我认为技能强度不能太强，也不能太弱，必须要设计者觉得这武将在自己使用时是合理的，并且在敌人使用时也是合理的
我一般是先设计武将技能，再去采集语音，然后去弄插画，最后去编写技能，测试
拓展包分享 棠棠大乱斗，已经原创30个角色，分别包含不同IP：地下城与勇士，原神，英雄联盟，明日方舟，阴阳师
技能一览： https://h5.qzone.qq.com/ugc/share/?sharetag=4B135526C048A7AB4A514AB6FEBAFBC0&amp;clientuin=512475424&amp;clientkey=91D78D084EA1BF934F655BD30242F397E827B4095944168BC3CA63F5E72A5621&amp;subtype=3&amp;ciphertext=&amp;sk=&amp;blog_photo=&amp;g=&amp;res_uin=512475424&amp;cellid=V50zhVjH1dIIJr1Qen524VMeOS2XNrwV&amp;subid=&amp;bp1=&amp;bp2=&amp;bp7=&amp;appid=4&amp;g_f=2000000103
如果打不开，请查看qq512475424的空间下的相册：棠棠大乱斗
拓展包下载： 链接：https://pan.baidu.com/s/1DNCFIv1AiHn2NGOWuKPuMQ 提取码：bilf 复制这段内容后打开百度网盘手机App，操作更方便哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526770c5827e9808c22e466b2c4600ac/" rel="bookmark">
			AndroidSudio&amp;Gradle相爱想杀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考链接：
1：https://developer.android.google.cn/studio/releases/gradle-plugin
1：概念简介 1：android sudio介绍 Android Studio 是谷歌推出的一个Android集成开发工具，基于IntelliJ IDEA. 类似 Eclipse ADT，Android Studio 提供了集成的 Android 开发工具用于开发和调试
2：gradle介绍 Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置
2：相爱相杀的经历 1：网络冲突相爱想杀 android studio负责的网络为android sdk下载和android studio插件库下载，如下图所示
这里主要说明下Http Proxy是android studio的代理，代表着android studio是否需要设置代理，正常情况下为 no Proxy
gradle负责的网络为下载第三方插件库，如下图所（APP中的build.gradle）
gradle主要依赖项目配置表中的中央仓库文件，如下图所示（项目中的build.gradle）
gradle也有自己的proxy机制，主要查找方式如下：
1：打开“此电脑”，在文件夹地址栏中输入%userprofile%
2：在文件夹目录下找到.gradle文件夹
3：进入.gradle文件夹，找到gradle.properties
4：打开gradle.properties文件中，查看proxy信息，如下为参考信息
systemProp.http.proxyHost=proxy.server.com systemProp.http.proxyPort=8080 systemProp.http.nonProxyHosts=*.company.com|10.*|100.* systemProp.http.proxyUser=userId systemProp.http.proxyPassword=password systemProp.https.proxyHost=proxy.server.com systemProp.https.proxyPort=8080 systemProp.https.nonProxyHosts=*.company.com|10.*|100.* systemProp.https.proxyUser=userId systemProp.https.proxyPassword=password 这里有一个瓜：如果你的安装了VPN全局配置软件，有可能会把该Proxy信息修改掉，然后，无论如何系统一直下载不了三方库文件，这个时候，无论你怎么修改除gradle.properties文件，也无法下载，出现这样的问题的解决方案是把gradle.properties中的proxy信息注释掉即可
需要注意的是：这个gradle.properties文件是全局文件，所有的gradle构建系统共享的配置，和你创建的项目中的gradle.properties文件是两个不同的文件
2：处理网络相爱相杀的过程 当出现网络下载不了三方库或者无法下载sdk的时候，需要分析是哪种情况，在确定是哪种资源无法下载后，就可以根据具体情况，确定配置android studio的Proxy还是gradle的proxy了
3：studio&amp;gradle依赖的相爱想杀 android studio需要依赖gradle构建项目，但是gradle是命令行工具，那android studio通过什么来把gradle的命令行映射为android studio可以的指令呢？gradle-tool工具就是这个作用，具体地址如下（项目的build.gradle）：
这里的瓜在于gradle-tool有支持的版本要求，比如高版本的gradle-tool需要高版本的gradle，如果你用了gradle-tool是4.0.0版本，那么你的gradle版本应不低于5.1.1版本，否则，编译器会识别不了gradle而报错。
查看gradle的版本信息为：
4：gradle-tool支持的gradle版本信息 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef74881984affb69a4c01376f515c67b/" rel="bookmark">
			Logstash 篇之入门与运行机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Logstash是一个数据收集引擎，相当于是ETL工具。截图来源慕课，尊重版本从你我做起。
Logstash分为三个阶段，第一个阶段Input是数据采集、第二个阶段是Filter数据解析和转换，第三个阶段是Output数据输出。
2、Logstash中的Pipeline概念。
1）、Pipeline是指Input-filter-output的三个阶段处理流程。
2）、队列管理。
3）、插件生命周期管理。
3、Logstash中的Logstash Event概念。
1）、内部流转的数据表现形式，原始数据从Input进入之后，在内部流转的时候不是原始的数据，而是Logstash Event数据。Logstash Event就是一个Java Object，对外暴漏去修改或者获取内部字段的api
2）、原始数据在input被转换为Event，在output event被转换为目标格式数据。
3）、在配置文件中可以对Event中的属性进行增删改查。
关于数据流转，数据由Input进入之后，从Output输出。Codec(Code、Decode)将原始数据Data转换为Logstash Event，当数据输出的时候，Codec将Logstash Event转换为目标数据源需要的类型Data。
4、Logstash的安装，将包上传到服务器进行解压缩即可，如下所示：
1 tar -zxvf logstash-6.7.1.tar.gz -C /usr/local/soft/ Logstash的简单案例，如下所示：
1 # 输入，stdin是标准输入，按照每一行切分数据 2 input { 3 stdin { 4 codec =&gt; line 5 } 6 } 7 8 # 过滤为空 9 filter {} 10 11 # 输出，stdout标准输出，将输出转换为json格式 12 output { 13 stdout { 14 codec =&gt; json 15 } 16 } 以每行进行切分数据，不过滤，然后输出为json格式的输入（Codec- Input Decoding）转换流程，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef74881984affb69a4c01376f515c67b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b399a91b0eaabc311016b72e417263/" rel="bookmark">
			Java IllegalArgumentException:Invalid character found in the request target问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： java.lang.IllegalArgumentException: Invalid character found in the request target [/file/downloadFile?fileName=$5F{YM{P7XLGOQ)AQ]2@G~0-20210418160057.png]. The valid characters are defined in RFC 7230 and RFC 3986
问题分析： 1、前端传过来的url里面有RFC3986文档支持的特殊字符，需要将转换为URL编码。
（1）空格：Url在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。
（2）引号以及&lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔Url的作用。
（3）#：通常用于表示书签或者锚点。
（4）%：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码。
（5）{}|\^[]`~：某一些网关或者传输代理会篡改这些字符。
解决办法：
特殊字符需要转换为对应的URL编码请查看以下博客。
Java 特殊字符转URL编码对应表（不符合RFC3986文档时需要）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2447a77476e53ba81d682f50cefc3ea1/" rel="bookmark">
			MVP模式学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文档：
1：https://www.jianshu.com/p/fee58fe60a2d
1：MVP详解 1：简介 MVP全称是Model View Presenter。
M：业务模型；
V：用户界面；
P：主持者，Model和View之间的桥梁。
2：MVP核心思想 把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成Presenter接口，Model类还是原来的Model类。
3：MVP的作用 1：分离视图逻辑和业务逻辑，降低耦合；
2：Activity只处理生命周期的任务，代码简洁；
3：视图逻辑和业务逻辑抽象到了View和Presenter中，提高阅读性；
4：Presenter被抽象成接口，可以有多种具体的实现；
5：业务逻辑在Presenter中，避免后台线程引用Activity导致内存泄漏；
2：MVP实现实例 1：添加契约&amp;协议 public interface DownloaderContract { interface Model { //p层告诉M层，需要做什么事情 void requestDownloader(ImageBean imageBean) throws Exception; } interface PresenterView { //View层告诉Presenter层做什么事情 void requestDownloader(ImageBean imageBean); //Presenter层从Model层的结果返回，在通知View层 void responseDownloaderReult(boolean isSuccess, ImageBean imageBean); } } 2：定义数据model public class ImageBean { //图片请求地址 private String requestPath; //结果返回图片 private Bitmap bitmap; public String getRequestPath() { return requestPath; } public void setRequestPath(String requestPath) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2447a77476e53ba81d682f50cefc3ea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a046b9c2a96b9d02e5e6944b817e17/" rel="bookmark">
			RK fb源码分析（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RK fb源码分析（转）
转载地址：https://blog.csdn.net/u014770862/article/details/65442066?fps=1&amp;locationNum=6
前言
学习，学而时习之。在工作中，利用闲暇时光简单分析下RK平台下fb源码部分，本人才疏学浅，很多地方理解的也不到位，只是简单的分析下代码流程，搞明白驱动调试过程中需要注意的地方。现将自己的一些理解与建议总结下来，如有错误之处，还望指正。
RK的LCD这块，亮点也就在于双屏异显，才开始搞驱动时，感觉这就是个高大上的东西，一脸懵逼，不知所措。随着后来慢慢深入才发现，原理和单屏也是差不多的。
分析之前，我将RK LCD这块首先分为四大块：fb、lcdc、screen、screen_type.这四部分相互依赖，首先从我们最容易入手的地方开始:rk_screen.c 1 一、函数调用关系 rk_screen.c函数调用关系如下： 二、probe()分析
毫无疑问，驱动的重点就是probe()函数，驱动在匹配到compatible = “rockchip,screen”后进入probe()函数，rk_screen_probe()： 在probe函数中获取”screen_prop”、”native-mode”等属性，在这里有个重要的结构体：prmry_screen会被初始化，prmry_screen 定义如下： static struct rk_screen *prmry_screen 还有一个结构体：struct rk_screen *rk_screen，rk_screen贯串上下文，并将prmry_screen指向rk_screen，prmry_screen之所以重要,是因为之后screen_type(例如LVDS，EDP,MIPI等)需要获取screen参数，就是获取prmry_screen的值，而这里prmry_screen就是rk_screen。 进入probe函数有两个函数比较重要：rk_fb_prase_timing_dt()和rk_disp_pwr_ctr_parse_dt。 首先会根据device_node中”screen_prop”的值，来决定rk_screen的”归属”： 代码中，dts的”screen_prop”的值决定了屏参文件传递进来后赋值给了谁：prmry_screen或者extend_screen.(NOTE:只有在DUAL_LCD时，screen节点下才会有”screen_prop”属性，单屏，由LCDC部分判断”screen_prop”) rk_fb_prase_timing_dt() 通过of_get_display_timings(np)解析device_node中的所有display_timing条目，然后调用 display_timings_get()从结构体display_timing中得到入口地址，最后调用了rk_fb_video_mode_from_timing(dt, screen)从display_timing中获取screen的详细信息，并将其赋值给rk_screen结构体(即prmry_screen).
rk_disp_pwr_ctr_parse_dt() 该函数主要是从dts中解析power control节点。其中，又引出来一个比较重要的结构体：struct rk_disp_pwr_ctr_list *pwr_ctr;该结构体也是一个双向链表。然后，初始化了一个双向链表rk_screen-&gt;pwrlist_head，最终会将pwr_ctr挂到rk_screen-&gt;pwrlist_head链表下： list_add_tail(&amp;pwr_ctr-&gt;list, rk_screen-&gt;pwrlist_head); for_each_child_of_node(root, child)循环解析每个子节点,例如： 首先为每个子节点(如lcd_en,lcd_cs,lcd_rst等)kmalloc一段空间, 解析dts中”rockchip,power_type”的值，rockchip,power_type = GPIO，分别获取其GPIO存至各自的pwr_ctr-&gt;pwr_ctr.gpio中，然后申请GPIO。这里，还有一个值：rockchip,delay，可以控制上电时序的延时操作，这个值在后面用到时再讲。 2. rk_fb_video_mode_from_timing() 该函数获取dts中display_timing各个子节点的值，其中有我们熟悉的VBP,VFP,HBP,HFP等可变参数，最终将获取到的值写入变量screen中，这样screen就被初始化完。 至此，screen部分probe()函数完结，现在总结下： Screen的probe()函数主要干了两件事： 解析dts中的display_timing，获取屏幕信息 解析dts中的power control，获取LCD的使能脚、片选脚、复位脚 最终，这些信息都存在了struct rk_screen *rk_screen这个结构体中，也就是prmry_screen这个结构体。那么，prmry_screen这个结构体在什么地方会用到呢？答案也是在rk_screen.c中： 调用rk_fb_get_screen()这个函数来取得screen的信息。该函数在哪被调用，后续会碰到，暂且不讨论。
以上部分，是双屏时screen部分的流程，事实上，单屏的代码更为简单。就是在probe()直接调用rk_fb_prase_timing_dt(np, rk_screen)来获取LCD屏信息，获取screen： 区别在于display_timings_get()的第二形参不同
但是，有些人又有疑问了？那双屏时会去获取power control节点的信息，单屏时为什么不用获取呢？其实也不是没有获取，只不过处理的地方不一样。双屏时，在screen部分获取power control，因为有两个LCD屏，有各自的使能脚、背光脚等等，所以引入链表保存至rk_screen结构体中，待将来使用。而单屏只有一组控制脚，只要在需要的地方获取使用就可以了。后续，只分析单屏的，理清思路即可。
最后，我们再来总结下probe()的功能： 1.如果是双屏，解析dts中screen节点下的power_ctl节点,单屏的power_ctl节点在别的地方(后续讲述)处理 2.从dts中获取LCD各个参数(VFP,VBP,HBP,HFP,W,H,CLOCK等等) 3.单屏保存至全局静态变量rk_screen，双屏时分别保存至prmry_screen和extend_screen以区别主副屏
SCREEN部分是整个fb调试过程中，需要更改参数最多的，通常LCD调试只需要调整screen的dts各个参数即可。LCD调试部分请参考另外一篇博文【Rk平台LCD调试说明】
三、struct rk_screen struct rk_screen {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7a046b9c2a96b9d02e5e6944b817e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844f8df35ba9cd6c2539247e04ea90a5/" rel="bookmark">
			图片与资源的在线链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图床网站 sm.ms
imgur
拖拽自动上传到选定图床的工具 PicGo
资源：蓝奏云 （不限速，单文件不超过100M）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32145d13720a335046d627554b8a2ae2/" rel="bookmark">
			【数据库复习】数据库设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库设计 写在前面的话 本文是本学渣因为考试需要写的一篇总结，只总结了需要考察的考点，所以可能有的内容引申的不多，请见谅。
一、本节考点 三种层次结构对于简单树的建模方式，只考对于单一节点简单树的(多副节点的复杂树不考)，邻接模型、物化路径模型以及嵌套结构模型(嵌套基本不考)在某种查询过程中的分析过程上面两种模型，在建模方面两种建模的 表结构设计是什么样的自顶向下和自底向上查询大概是什么样的，效率是什么样，影响效率的因素是什么： 如邻接模型要做一次迭代，效率影响较大，却又因为是数值比较，其速度反而是最快的物化路径模型虽然比较简单，但是其需要拆分字符串并重新寻找深度等，字符串运算会导致压力比较大 二、两种层次结构模型的建模 在数据库中定义满足下面两个条件的记录以及它们之间关联的集合为层次模型：
有且只有一个节点无父节点，称之为根节点除根节点外别的节点都有且只有一个父节点 在层次模型中，每个节点代表一个记录，记录描述了的是实体，其包含的字段描述的是实体的属性。
(例如，在部门员工表中，每个节点是一行，包含多个字段即多列)
2.1 邻接模型 用id和parent_id来表明层次结构
表的结构如下
(重点是前两个，后两个是属性)
特性：
插入、移动、删除节点快捷只支持单父节点，不支持多父节点删除子树较难三种模型中性能最高，每秒返回的查询记录数最多 2.2 物化路径模型 使用层次式的路径明确地标识出来层次结构，路径一半保存为字符串格式， PathID(1，1.1，1.2，1.1.1，1.2.1，…)。
每一个节点都存储了其在树中的位置信息，并且这种模式还可以体现同级节点的顺序（因为路径的标识有顺序，而邻接模型就不可以），比如家族族谱
表结构设计如下：
(重点是第一个pathid作为唯一性索引(但是不应该作为key，因为主键不要经常更新)，后两个是属性，其实还可以加一个id作为索引)
特性：
查询编写不困难计算层次不方便。查询复杂度主要在路径字符串的处理树的的深度要自己写函数计算，可以计算“.”的数目或者去掉“.”后字符串的长度子节点有顺序，但不应该暗示任何兄弟节点的排序会产生重复记录的问题物化路径path不应该该是KEY，即使他们有唯一性所选择的编码方式不需要完全中立三种模型中性能中等 三、自顶向下与自底向上两种查询 3.1 自顶向下查询 查询某个节点的所有后代节点(比如某个团下面有哪些各级的部队)
邻接模型：
只能使用数据库提供的递归查询函数，如：
Oracle: connect by/start withDB2: with+as
而Mysql没有这种函数，因此很麻烦，要像下图一样手动数深度，多次union： 物化路径模型：
只需要查找所有起始部分相同的 ID(ID 是字符串格式)
3.2 自底向上查询 查询某个节点的所有祖先节点(但是课件中的难点在于要先找到这些子节点)
邻接模型：
依旧使用数据库的递归查询函数connect by，只需要把id和pid的位置换一下，很容易实现
物化路径模型：
只需逐渐去除 ID 的尾部层次即可
四、查询效率分析 邻接模型的两种查询效率差不多，因为都是使用了数据库的递归查询函数，connect by函数的实现不是基于关系，而是基于过程，是提取所有相关记录再处理物化路径自底向上的性能降低很多，因为自顶向下只从一个节点出发，而自底向上需要从先通过字符串处理找到多个符合的子代节点，再分别求其祖先节点 虽然邻接模型要做一次迭代，效率影响较大，却又因为是数值比较，其速度反而是最快的物化路径模型虽然比较简单，但是其需要拆分字符串并重新寻找深度等，字符串运算会导致压力比较大 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e8cd44329ada5e7377fbbb25f5f02d/" rel="bookmark">
			【数据库复习】SQL的逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL 写在前面的话 本文是本学渣因为考试需要写的一篇总结，只总结了需要考察的考点，所以可能有的内容引申的不多，请见谅。
一、本节考点 从之前的线上考试中抽一组题考sql基本逻辑：查询优化器是怎么工作的，其中的步骤
包括基于成本的优化器，基于规则的优化器的整个优化过程，比如：
先是怎么做语义的检查，软解析硬解析等内容，最后形成一个二进制plan代码，整个过程中谁花的功夫最多 二、查询优化器的相关概念 优化器是sql分析和执行的优化工具，它负责制订sql的最高效的执行计划，基于关系理论给予用户无损原始查询的等效变换。
优化：在数据处理的真正被执行的时候发生
不同查询表达式在不同环境，经过查询优化器的优化后下效率千差万别
三、基于规则的优化器RBO **概念：**就是在优化器里面嵌入若干种规则，执行的sql语句符合哪种规则，则按照哪种规则制订出相应的执行计划。
例如：表上有个索引，如果谓词上有索引列的存在，根据规则一定会选择走索引，否则选择走全表扫描。
四、基于成本的优化器CBO CBO优化器会计算使用不同的执行计划的成本，并选择成本最低的一个，以获得最大的吞吐量或最快的初始响应时间。
五、SQL的执行顺序 SQL语言的执行顺序如下：
语义语法检查：然后进入查询的缓存解析 ：对每一次表达式进行变换，生成各种解析树并评估，选择最优路径形成执行计划，最消耗资源的过程执行计划：形成一个二进制的plan代码，抛入执行引擎中执行引擎存储引擎数据库：执行引擎利用存储引擎在数据库中查询相关内容并返回 六、相关注意事项 需要注意的两点：
不同sql写法会对查询优化器最终选择结果产生影响查询优化器不知道一些只有程序员才知道的影响效率的信息，如： sql写错了，如想查A结果写的是查B关系理论只管最终表达式的正确性，但是中间结果需要大开销，这个部分查询优化器很难判断sql包含太多关系操作，无法优化掉 查询优化器基于两个条件：程序员写的sql(优化的前提)和关系代数的等价变换(优化的基础)。也会有权衡和判断的失误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9cbee4d95404d5833ee16511697f57/" rel="bookmark">
			关于全排列的极限优化 思考及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家觉得写还可以，可以点赞、收藏、关注一下吧！
也可以到我的个人博客参观一下，估计近几年都会一直更新！和我做个朋友吧！https://motongxue.cn
文章目录 关于Java全排列的极限优化运行结果 关于Java全排列的极限优化 我要吹爆发现这个算法的人！之前有一次比赛，递归算法没想出来，后来实在觉得是这种排列思路，但数据量太大了，普通全排列硬算都得跑很久。就想起了这个算法，没想到再加上人工判断，算对了！总之这种排列优化很不错！
适用场景： 包含很多重复元素，有需要进行全排列的类型！
/* * @Author: motongxue * @Date: 2020-10-16 23:05:17 * @LastEditors: motongxue * @LastEditTime: 2020-10-16 23:49:58 * @Blog: https://motongxue.cn * @Description: file content */ import java.util.Arrays; public class Main{ static int[] a = { 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 }; static int[] a1 = { 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 }; static boolean[] vis = new boolean[12]; static int[] path = new int[12]; static int cnt = 0; static int cnt1 = 0; public static void main(String[] args) { long startTime = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a9cbee4d95404d5833ee16511697f57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a69c38964399933ef9c670860220bed/" rel="bookmark">
			VUE 中== 与 ===的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue.js中
== 用来比较或者判断两者是否相等，比较时可以自动转换数据类型
=== 用来较为严格的比较，除判断数据2这是否相等 ，还会判断两者数据类型是否相同 如不相同也不会转换数据类型 。返回（false）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d024dfc5e5fabda78cb825f38d408ab/" rel="bookmark">
			处理浮点型变量值交换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 处理浮点型变量值交换 #include&lt;iostream&gt; using namespace std; int main(){ double a=123.456;double b=456.789; int*ap,*bp; ap=(int*)(&amp;a);//把a的地址（double*）型转化成int*型，将int*的这个值赋值给ap这个int*型指针 bp=(int*)(&amp;b); cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;"b="&lt;&lt;b&lt;&lt;endl; *ap=(*ap)^(*bp); *bp=(*ap)^(*bp); *ap=(*ap)^(*bp);//这三行是将a和b的值交换（用异或）注意此刻apbp指向前四个字节，交换前四个字节的数据 ap++;bp++;//让ap和bp指向的地址前进sizeof（int）个字节，访问一个未知的地方，此时指向后四个字节交换后四个字节的数据 *ap=(*ap)^(*bp); *bp=(*ap)^(*bp); *ap=(*ap)^(*bp); cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;"b="&lt;&lt;b&lt;&lt;endl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef99417b16e988d8f55b3c9dcd5964bb/" rel="bookmark">
			Unity C# 字节数组byte[]转字符串string中文乱码（utf8无效）的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 在字节数组转字符串过程中，发现中文字符一直是乱码状态，因为是接入SDK的方式，所以不知道后端是怎么发的。SDK提供的转换如下：
System.Text.Encoding.Default.GetString(str); 转换后的是各种乱码：???之类的。
网上查询并尝试了各种方式，都得不到正确的中文，只不过输出的乱码改变了，尝试了如下方式：
System.Text.Encoding.UTF8.GetString(str); System.Text.Encoding.ASCII.GetString(str); System.Text.Encoding.Unicode.GetString(str); 解决方法 采用了GB2312编码实现，只不过实现方式如下：
System.Text.Encoding gb2312; gb2312 = System.Text.Encoding.GetEncoding("gb2312"); string CnStr = gb2312.GetString(bytes); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238f0947d374d67020580298a7a808aa/" rel="bookmark">
			java子类调用父类的构造方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class FatherClass{ public FatherClass(){ System.out.println("父类 无参 构造函数"); } public FatherClass(int i){ System.out.println("父类 一个参数构造函数super = "+i); } public FatherClass(int i,String j){ System.out.println("父类 一个参数构造函数superi = "+i+",superj = "+j); } }
class SonClass extends FatherClass{
public SonClass(){
// super(22);//line 1
System.out.println(“子类 无参 构造函数”);
}
public SonClass(int a){
super(33,“Hello”);//line 2
System.out.println("子类一个参数构造函数sub = "+a);
}
public void fun(int a){//子类中定义一个实例函数
//super(33,“Hello”);//构造函数调用必须声明在构造函数中,这行代码不注释的话会报错
System.out.println("子类一个参数构造函数sub = "+a);
}
}
public class ConstructorExtend {//测试子类继承父类的构造函数
public static void main(String args[]){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238f0947d374d67020580298a7a808aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71bb85c2351294d1b6e54a83a958a53b/" rel="bookmark">
			解决win10服务主机：网络服务占用网络宽带的方法（自测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决win10服务主机：网络服务占用网络宽带的方法 使用电脑时常常因为各种原因要使用手机移动数据所支持的个人热点，尤其是笔者这样的学生党。。。而电脑经常因为后台的服务主机：网络服务原因抽风占用数据流量，经常7、8mb/s的走。。。都是钱。。。
解决方案（自测有效）：
1、设置——更新和安全——传递优化——允许从其他电脑下载——关
2、右下角WiFi图标——选择你连接的无线网络或者手机热点——属性——按流量计费的连接——设为按流量计费的连接——开
https://blog.csdn.net/qq_30229209/article/details/75009068
https://blog.csdn.net/weixin_45260385/article/details/114294620?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49131eb1aa0377e4c0515542041d4780/" rel="bookmark">
			EA-可执行状态机-延迟事件模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
因为最近在做EA的模型搭建，查阅资料的时候，发现这篇示例说明比较实用，但是英文版理解起来比较慢，中文版在火龙果网站有，但是机翻增加了理解难度，因此，我打算整理一下中文版的翻译，作为学习记录。
火龙果网站中的EA软件参考文档【中文】
———————————————————————————
Enterprise Architect支持延迟事件模式。
在状态中创建延迟事件：
为状态（state）创建自我过渡(self transition)。将过渡的种类更改为“内部过渡”。指定触发器（Trigger）成为你需要延迟的事件。在“效果”(Effect)字段中，键入“ defer（）;”。 进行模拟：
打开"模拟窗口":选择“模拟&gt;动态模拟&gt;模拟器&gt;打开模拟窗口”。
打开"模拟事件窗口":选择“模拟&gt;动态模拟&gt;事件”。 模拟器事件窗口（Simulation Event Window）可帮助您触发事件；双击“等待触发器”列中的触发器。
Simulation窗口以文本形式显示执行。您可以在Simulator命令行中键入“ dump”，以显示队列中延迟了多少个事件。
输出可能类似于以下内容： 24850060]事件池：[NEW，NEW，NEW，NEW，NEW，]
延迟事件示例 本示例显示了使用“延迟事件”的模型，“模拟事件”窗口显示了所有可用事件。
我们首先建立上下文(context)（包含状态机的类中元素），在简单的上下文中模拟它们，并从外部引发事件；然后在使用Send事件机制的客户端-服务器（client-server）上下文中进行仿真。
创建上下文和状态机 创建服务器上下文
创建一个类图：
一个类元素：TransactionServer ，向其中添加一个状态机，名为ServerStateMachine一个类元素TestClient ，向其中添加一个状态机，名为ClientStateMachine从TestClient到TransactionServer的关联(association)，目标角色名为server。 为 ServerStateMachine 建模
向状态机图中添加一个初始化结点，名为Initial ，然后过渡到状态idle转换（事件NEW_REQUEST作为触发器）到状态busy过渡（使用事件QUIT作为触发）到最终状态Final转换（事件AUTHORIZED作为触发器）到idle转换为繁忙状态 （事件NEW_REQUEST作为触发器，defer（）；作为效果（effect）） ClientStateMachine的 建模
在状态机图中添加一个初始化结点initial，转换到状态State0转换（以事件RUN_TEST作为触发器）到状态State1 。过渡到状态State2 （转移中的效果effect为：％SEND_EVENT（“ NEW_REQUEST”，CONTEXT_REF（服务器））％;） 。过渡到状态State3 （转移中的效果effect为：％SEND_EVENT（“ NEW_REQUEST”，CONTEXT_REF（server））％;）。过渡到状态State4 （转移中的效果effect为：“％BROADCAST_EVENT（“ NEW_REQUEST”）％;）。过渡到状态State5（转移中的效果effect为：％SEND_EVENT（ “AUTHORIZED”，CONTEXT_REF（server））％）。过渡到最终状态Final。 在简单环境中进行仿真 创建仿真工件
创建名称为Simulation with Deferred Event的可执行状态机工件，并将”语言“（“ Language”）字段设置为JavaScript。【此处的语言设置也可以是java、C++、C】将其放大，然后按住Ctrl键并将TransactionServer元素拖动到工件上，并将其粘贴为可执行状态机的一个属性，命名为server。 运行模拟
选择工件，然后选择“模拟&gt;可执行状态&gt;状态机&gt;生成，构建和运行”选项，并为您的代码指定目录（注意：目录中的所有文件将在模拟开始前被删除）。单击生成按钮。（Generate）
-选择“模拟&gt;动态模拟&gt;事件”选项，以打开“模拟事件”窗口。
当模拟开始时， idle状态将变为活动状态。
在“模拟事件”窗口中双击NEW_REQUEST，将其作为触发器执行；退出idle状态并激活busy状态 。
在“模拟事件”窗口中双击NEW_REQUEST，再次将其作为触发器执行； busy状态保持激活状态，同时，一个NEW_REQUEST的实被例添加入事件池。在“模拟事件”窗口中双击NEW_REQUEST，第三次将其作为触发器执行；busy状态保持激活状态，同时，一个NEW_REQUEST的实被例添加入事件池。在“模拟”窗口的命令行中键入dump ；请注意，此时事件池具有两个NEW_REQUEST实例。
在“模拟事件”窗口中双击AUTHORIZED，将其作为触发器执行；如下动作将会发生： 从busy状态退出，idle状态被激活，成为活跃状态；一个NEW_REQUEST事件从事件池中被检索出来，busy状态退出，busy状态被激活，成为活跃状态; 在“模拟”窗口命令行中键入dump ；现在，事件池中只剩余一个NEW_REQUEST实例。
通过发送/广播事件进行交互式模拟 创建仿真工件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49131eb1aa0377e4c0515542041d4780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7952e8088f6f4daa844d65bb3f16cfb5/" rel="bookmark">
			mooc python 程序设计 2-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题要求编写程序，计算序列 1 + 1/3 + 1/5 + … 的前N项近似和（提示：用ceil函数）。 输入格式:
输入在一行中给出一个正整数N。
输出格式:
在一行中按照“sum ≈ S”的格式输出近似和S。S是大于序列和的最小整数
输入样例:
在这里给出一组输入。例如：
23
输出样例:
在这里给出相应的输出。例如：
sum ≈ 3
import math n=int(input()) sum=0 for i in range(1,n+1): sum=sum+1/(2*i-1) s=math.ceil(sum) print("sum≈{}".format(s)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb8015a67c3ea0f375e89deab3b3ad89/" rel="bookmark">
			mooc python 程序设计 2-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入一个正整数m(20&lt;=m&lt;=100)，计算 11+12+13+…+m 的值。 输入一个正整数m(20&lt;=m&lt;=100)，计算 11+12+13+…+m 的值。
输入格式:
在一行输入一个正整数m。
输出格式:
在一行中按照格式“sum = S”输出对应的和S.
输入样例:
在这里给出一组输入。例如：
90
输出样例:
在这里给出相应的输出。例如：
sum = 4040
m=int(input()) sum=0 for i in range(11,m+1): sum=sum+i print("sum = {}".format(sum)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3071ac0e144f8cdd2ca079c32c919817/" rel="bookmark">
			在同一行依次输入三个值a,b,c，用空格分开，输出 b*b-4*a*c的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在同一行依次输入三个值a,b,c，用空格分开，输出 bb-4a*c的值 在同一行依次输入三个值a,b,c，用空格分开，输出 bb-4a*c的值
输入格式:
在一行中输入三个数。
输出格式:
在一行中输出公式值。
输入样例:
在这里给出一组输入。例如：
3 4 5
输出样例:
在这里给出相应的输出。例如：
-44
a,b,c=map(int,input().split()) print(b*b-4*a*c) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d87bb536e9135714a9b6f2b3c3107bc9/" rel="bookmark">
			js获取汉字拼音首字母
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pinyin-pro这个npm包
github: https://github.com/zh-lx/pinyin-pro
特色功能 支持汉字、词语、句子多种格式输入获取获取拼音获取声母获取韵母获取拼音首字母获取音调获取多音字的多种拼音支持字符串和数组两种输出形式 版本更新 当前版本： 3.0.7 -&gt; 3.1.0
增加获取拼音首字母功能修复 readme 中音调形式参数 toneType 错写成了 tone 的错误 点击查看 版本更新文档
安装 npm 安装
npm install pinyin-pro yarn 安装
yarn add pinyin-pro 引入 ES6 引入：
import { pinyin } from 'pinyin-pro'; commonjs 引入：
const { pinyin } = require('pinyin-pro'); 参数 pinyin(word, options) 接收两个参数
word：必填。String 类型，需要转化为拼音的中文options：可选。Object 类型，用于配置各种输出形式，options 的键值配置如下： 参数说明类型可选值默认值pattern输出的结果的信息（拼音 / 声母 / 韵母 / 音调 / 首字母）stringpinyin / initial / final / num / firstpinyintoneType音调输出形式(拼音符号 / 数字 / 不加音调)stringsymbol / num / nonesymboltype输出结果类型（字符串/数组）stringstring / arraystringmultiple输出多音字全部拼音（仅在 word 为长度为 1 的汉字字符串时生效）booleantrue / falsefalse 使用示例 获取拼音 // 获取带音调拼音 pinyin('汉语拼音'); // 'hàn yǔ pīn yīn' // 获取不带声调的拼音 pinyin('汉语拼音', { toneType: 'none' }); // 'han yu pin yin' // 获取声调转换为数字后缀的拼音 pinyin('汉语拼音', { toneType: 'num' }); // 'han4 yu3 pin1 yin1' // 获取数组形式带音调拼音 pinyin('汉语拼音', { type: 'array' }); // ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d87bb536e9135714a9b6f2b3c3107bc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e3bd63a162c8b75eb3766241b358ea/" rel="bookmark">
			MyBatis-Plus的简单使用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis-Plus的简单使用案例 gradle
dependencies { implementation ('org.springframework.boot:spring-boot-starter-web') runtimeOnly 'mysql:mysql-connector-java' testImplementation('org.springframework.boot:spring-boot-starter-test') { exclude group: 'org.junit.vintage', module: 'junit-vintage-engine' } compile 'com.baomidou:mybatis-plus-boot-starter:3.4.1' } 配置
server.port=8081 spring.datasource.password=xxxxxx spring.datasource.url=jdbc:mysql://ip:3306/mybatis_demo?useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.username=root logging.level.com.study.mybatisplusdemo.user.mapper=debug 配置启动项
@SpringBootApplication @MapperScan("com.study.mybatisplusdemo") public class MybatisPlusDemoApplication { public static void main(String[] args) { SpringApplication.run(MybatisPlusDemoApplication.class, args); } @Bean//分页插件 public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler; import java.util.Arrays; @TableName("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78e3bd63a162c8b75eb3766241b358ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45970aee5032eeb167d4870b8cfa7d69/" rel="bookmark">
			吴恩达机器学习（一）—— 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习(Machine Learning)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科，专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能的核心，是使计算机具有智能的根本途径。
例如，让机器人整齐有序的打扫房子，怎样去实现？我们要做的是让机器人观察我们完成任务的过程，从而从中学习。
人工智能、机器学习、深度学习、神经网络之间的关系： 人工智能(Artificial Intelligence)是研究使计算机来模拟人的某些思维过程和智能行为（如学习、推理、思考、规划等）的学科。
机器学习(Machine Learning)是一门人工智能的科学，该领域的主要研究对象是人工智能，特别是如何在经验学习中改善具体算法的性能。
深度学习(Deep Learning)是机器学习领域中一个新的研究方向，它被引入机器学习使其更接近最初的目标——人工智能。
神经网络(Neural Network)是一种模拟人脑的神经网络以期望能够实现类人的人工智能机器学习技术，它是深度学习的基础。
机器学习定义: Arthur Samuel(1959): Field of study that gives computers the ability to learn without being explicitly programmed. 在没有明确设置的情况下，使计算机具有学习能力的研究领域。
Tom Mitchell(1998): Well-posed Learning Problem:A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E. 计算机程序从经验E中学习解决某一任务T，进行某一性能度量P，通过P测定在T上的表现因经验E而提高。例如，在人机玩跳棋游戏中，经验E是程序与自己下几万次跳棋；任务T是玩跳棋；性能度量P是与新对手玩跳棋时赢的概率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45970aee5032eeb167d4870b8cfa7d69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f976c8aafa3fd18b36a52c9b16a06d58/" rel="bookmark">
			错误-The server encountered an unexpected condition that prevented it from fulfilling the request
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误展示 错误分析 1.dao层错误 当dao层的连接重复，且没有关闭时，会出现这个错误；
解决方法
在finally代码块中关闭连接；但要注意判断参数是否为空，可能会报NullPointException异常；
2.前端jsp错误 当jsp页面错误时，会导致无法编译jsp，也会出现这样的错误，这个情况是非常狗的，因为jsp错误不会直接显示(烦)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/232c389f82b3ffdcef8e82415799bfc7/" rel="bookmark">
			Java求一元二次方程的根（实验三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java求一元二次方程的根（实验三） Package和import语句的使用 编写Java应用程序求方程的根。使用package语句将方程的属性即计算根的方法封装在一个有包名的类中，包名是tom.jiafei，类的名字是SquareEquation。编写一个SunRise主类，该主类使用import语句引入tom.jiafei包中的SquareEquation类，并使用其计算方程的根。
SunRise主类 import tom.jiafei.SquareEquation;//调用另一包中的某个类 //如要调用另一个包中的所有类：import tom.jiafei.*; public class SunRise { public static void main(String args[]){ SquareEquation gen=new SquareEquation(); gen.Getgen();//调用方法 //	System.out.println(gen.Getgen()); } } SquareEquation类 package tom.jiafei;//SquareEquation类在tom.jiafei包中 import java.util.Scanner; public class SquareEquation { Scanner sc=new Scanner(System.in); double a=sc.nextDouble(); double b=sc.nextDouble(); double c=sc.nextDouble(); double x1,x2,result; public Double[] Getgen(){//返回值为一维数组（多个值） double t=(b*b)-(4*a*c);//赋值要在方法里 if(a==0&amp;&amp;b==0&amp;&amp;c==0) System.out.println("有无穷个解"); else if(a==0&amp;&amp;b==0&amp;&amp;c!=0) System.out.println("方程没有解"); else if(a==0&amp;&amp;b!=0&amp;&amp;c!=0) { x1 =-c/b; System.out.printf("方程有一个实数解：\n"); System.out.printf("x1 = %.4f",x1); } else if(t&gt;0) { x1=(-b+Math.sqrt(t))/(2*a); x2=(-b-Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/232c389f82b3ffdcef8e82415799bfc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980e5201527a0fc02837896b0c7cc141/" rel="bookmark">
			黑马RabbitMQ高级学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ高级内容介绍 RabbitMQ高级特性 消息可靠性投递Consumer ACK消费端限流TTL死信队列延迟队列日志与监控消息可靠性分析与追踪管理 RabbitMQ应用问题 消息可靠请保障消息幂等性处理 RabbitMQ集群搭建 RabbitMQ高可用集群 1、RabbitMQ高级特性 1.1、消息的可靠投递 1、定义 在使用RabbitMQ的时候，作为消息发送方希望杜绝任何消息丢失或投递失败场景。RabbitMQ为我们提供了两种方式用来控制消息的投递可靠性模式。
confirm 确认模式return退回模式 rabbitMQ整个消息投递的路径为：
pruducer —&gt;rabbitMQ broker ----&gt;exchange------&gt;queue ----&gt; consumer
消息从producer到exchange则会返回一个confirmCallback。消息从exchange–&gt;queue投递失败则会返回一个returnCallback。
我们将利用这两个callback控制消息的可靠性投递。 2、生产者端代码实现 1）新建spring工程rabbitmq-producer-spring 2） 配置pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq-producer-spring&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/980e5201527a0fc02837896b0c7cc141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc94a81862b25243146239b8e90e4576/" rel="bookmark">
			搭建基于 Docker 的 CI/CD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 Docker 安装这里就不在赘述，详情可以看下面这条链接。
docker 基础和安装：https://blog.csdn.net/qq_39253370/article/details/115430300
CI/CD 概念 持续集成（Continuous Integration，CI）：代码合并、构建、部署、测试都在一起，不断地执行这个过程，并对结果反馈。持续部署（Continuous Deployment，CD）：部署到测试环境、预生产环境、生产环境。持续交付（Continuous Delivery，CD）：将最终产品发布到生产环境，给用户使用。 安装Harbor Harbor是由VMWare公司开源的容器镜像仓库。事实上，Harbor是在Docker Registry上进行了相应的企业级扩展，从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访问控制 ，AD/LDAP集成以及审计日志等，足以满足基本企业需求。
为什么使用 harbor？
当有多个镜像需要部署到多个节点服务器上面时，如果没有一个统一管理镜像的地方，那么就需要再每台上面写 dockerfile 构建镜像，任务量大的时候这很浪费效率，harbor 就是一个镜像管理仓库，构建好的镜像 push 到 harbor 上面，那么其他节点部署的时候直接从 harbor 仓库中 pull 下来运行就可以了，所以harbor是作为一个中心节点来集中管理镜像。
安装步骤：
安装 docker
安装 工具包： yum install -y yum-utils device-mapper-persistent-data lvm2 安装工具包 安装docker软件包源： yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo //这里使用阿里云的源，官方的再国外，比较慢 安装 docker-ce版本： yum install -y docker-ce 启动docker: systemctl start docker 设置开机自动启动: systemctl enable docker 镜像加速: curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc94a81862b25243146239b8e90e4576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00877afad6d5321bb689574691432524/" rel="bookmark">
			ElasticSearch 控制台日志乱码问题已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 乱码： 在config文件里修改 jvm.options-Dfile.encoding = GBK中国境内的电脑默认是GBK的编码格式 修改后重新启动后复现： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e396b708fe5d032aff374af9d313753a/" rel="bookmark">
			前端笔记-常用插件工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端笔记 前端常用插件 前端常用插件 css插件:bootsrrap
使用bootstrap步骤：
访问 https://www.bootcss.com/点击 bootstrap3 中文文档选择 起步下载 bootstrap 核心 css 文件在我们的html文件中引入该文件查看 全局css样式 文档 js插件:jquery
jquery 属性: 属性: attr(name|pro|key,val|fn) 查找，修改，添加元素的属性值 removeAttr(name) 删除元素的某个属性 css类： addClass(class|fn) 添加类名 removeClass([class|fn]) 删除类名 toggleClass(class|fn[,sw]) 类名切换 类名如果存在就删除 类名如果不存在添加这个类名。 HTML代码\文本\值 html([val|fn]) 修改查询HTML 类似js对象的 .innerTHML 取得第一个匹配元素的html内容 text([val|fn]) 类似js对象的 .innerText 取得所有匹配元素的内容。 结果是由所有匹配元素包含的文本内容组合起来的文本。这个方法对HTML和XML文档都有效。 val([val|fn|arr]) 类似js中的 .value 适用对象为input 获得匹配元素的当前值 CSS css(name|pro|[,val|fn]) 批量修改元素的样式。 eg: $("xxx").css({"user-select", "none"}) 位置 offset([coordinates]) 获取匹配元素在当前视口的相对偏移。 position() 获取匹配元素相对父元素的偏移。 文档处理 内部插入： append(content|fn) 向每个匹配的元素内部追加内容。 A.append(B) 即为 B加到A中内容的后面 appendTo(content) 反向添加 A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e396b708fe5d032aff374af9d313753a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6eaf6b6fdfa9813957d3b0706763b8/" rel="bookmark">
			前端笔记-js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端笔记 html-jsjs基础数据类型变量的定义和使用运算符逻辑运算函数的使用new关键字判断数据类型:计时器json字符串DOM [document object model]操作DOM中的节点DOM中的特殊节点获取元素中的节点获取界面上的DOM元素获取输入框中的内容给元素绑定监听事件修改元素的样式元素的尺寸元素的scrollHeight 滚动尺寸: 脚本(js)与界面之间的关系ajax网络请求typeof面试题本地存储(浏览器缓存)ES6补充学习 html-js 上次笔记记录了css的基本内容，下面的笔记是记录js的基础内容。
js在我理解就是实现功能的（当然，他什么都能干），当我们用css画出了我们想要的界面以后，就要用js来完善我们的功能，一个没有功能的网页是没有灵魂的。(因为是笔记，所以顺序是乱的，大家可以跳着看)
js基础 数据类型 js中有六种数据类型,包括五种基本数据类型和一种复杂数据类型。
基本数据类型:
数字型（js中不分整数和小数）：number
字符串：string 字符串的3种表示方法: “” , ‘’ , ``
备注: 单引号 和 双引号 一样,只能写一行,不能分行写 , `` 可以分行写
Boolean类型：只有true and false
Undefined类型:只有一个值 Undefined
Null类型: null类型被看做空对象指针，前文说到null类型也是空的对象引用。
复杂数据类型:
Object类型:我们看到的大多数类型值都是Object类型的实例，创建Object实例的方式有两种。
第一种是使用new操作符后跟Object构造函数，如下所示
var ren= new Object(); ren.name = "Micheal"; ren.age = 24; 第二种方式是使用对象字面量表示法，如下所示
var ren= { name : "Micheal", age : 24}; 可以给任意对象增加任意新的属性值
ren. score = 90 console.log(ren.score) //90 Array类型
数组的每一项可以用来保存任何类型的数据，也就是说，可以用数组的第一个位置来保存字符串，第二个位置保存数值，第三个位置保存对象…另外，数组的大小是可以动态调整的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e6eaf6b6fdfa9813957d3b0706763b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2590a45bceb27fd4a184e2d672687cab/" rel="bookmark">
			前端笔记-css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端笔记 html-css盒模型:缩骨功:三种定位方法:圆角边框颜色的三种表示方式变形 transform字体设置:渐变背景背景图片背景尺寸背景重复背景位置坐标动画w和h单位阴影的用法overflow按照显示display方式选择器优先级问题: (行内样式&gt;id&gt;class&gt;标签名&gt;继承)标签样式的写法居中css的第三种引入方式选择器文本常见样式z-index过渡鼠标样式轮廓超出的文字隐藏样式前缀, 不同浏览器内核处理问题 html-css 一个网页主要就三部分内容，样式，标签，功能（自己的理解），样式对应css，标签对应界面元素，功能对应js语法。这里就是前端开始的地方-css。
在我的理解中，网页是什么？就是一个个元素放在一个空白的文档上面，构成了我们所看到的网页，就相当于拼图是由一个个小卡片拼装而成的，一个小卡片可能看不出什么东西，但是许多小卡片拼装在一起就构成了一副美丽的图画。window就相当于拼图的底板，元素就相当于卡片。
这里我主要介绍卡片（元素）的样式简单写法规则。
盒模型: 一个元素分为，
外边框 边框 填充 内容 四个部分 分别对应
margin dorder padding content
//盒子大小 即 背景范围 等于后三者之和
边框:
实线:solid
虚线:dashed
点状线:dotted
eg: border: 1px solid red;
填充:
padding: % 和 width % 是一个参照物
padding: 10px 20px; 上下10px填充 左右20px填充
外边框(边距):
二个标签：
水平方向标签会相加
竖直方向标签会融合
其中竖直方向,子元素有上边框时,会把没有边框的父元素带着往下移动
内容:开始标签和结束标签里面的内容
缩骨功: 开启:box-sizing:border-box;
没有开启缩骨功的元素:
width + border =元素所占据的大小
开启缩骨功的元素:
width =元素所占据的大小
box-sizing 即从什么地方开始机算盒子的的尺寸
正常盒模型:box-sizing:conetent-box; 默认 width=内容
怪异盒模型:box-sizing:border-box; width=边框+填充+内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2590a45bceb27fd4a184e2d672687cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8248db4c863c77667d4fe75dfeff826/" rel="bookmark">
			视觉SLAM：雅可比矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.两个相机之间的非线性优化 观测相机方程关于相机位姿与特征点的雅可比矩阵：
1.1 位姿：
1.2 3D特征点 fx,fy,fz为相机内参X',Y',Z'为3D点在相机坐标系下的坐标该误差是观测值减去预测值，反过来，预测值减观测值时，去掉或加上负号即可姿态定义为先平移后旋转，如果定义为先旋转后平移，将该矩阵的前3列与后3列对调即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25540939c59afb32097c04c6f340e529/" rel="bookmark">
			Mac系统中配置JAVA环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac系统中配置JAVA环境变量 首先查看，电脑上是否装了jdk。在终端输入java --version, 如果没有安装过jdk会提示需要安装jdk。
安装地址
可选择SE 8或者SE 11，我下载的是SE 11。按照以下下载即可，下载完成以后直接安装，在终端输入java —version，如果出现版本信息，则说明安装成功。
配置JAVA开发环境
首先获取JAVA_HOME的路径，在终端输入/usr/libexec/java_home可获取到。
Eg:
开始配置环境变量。
在终端输入sudo vim /etc/profile，提示需要输入密码则需要输入密码，密码输入成功以后则进入可编辑页面。
首次进入并没有我圈出来的这一部分，那么此刻按i键进入编辑，输入以下代码：
export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk-11.0.10.jdk/Contents/Home" CLASS_PATH="$JAVA_HOME/lib" PATH=".$PATH:$JAVA_HOME/bin" 注意⚠️，此刻JAVA_HOME后面的内容应为上一步中通过/usr/libexec/java_home获取到的JAVA_HOME的路径。
然后按esc键退出编辑，按：wq!保存编辑并退出编辑（⚠️如果出现E325警告。输入E，edit anyway，回车）。
配置完成。输入source /etc/profile立即生效。
检查环境。输入echo $JAVA_HOME出现以下情况则配置完毕。
修改.bash_profile文件
输入vi .bash_profile命令，进入编辑页。
首次进入什么都没有，则需输入以下代码：
#!bin/bash export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk-11.0.10.jdk/Contents/Home" export PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar 同样的注意⚠️，此刻JAVA_HOME后面的内容应为上一步中通过/usr/libexec/java_home获取到的JAVA_HOME的路径。
通过source .bash_profile命令立即生效。配置完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaedef7158a7c8bd953a5388bbe80967/" rel="bookmark">
			linux解压文件到/usr/local/bin下，结果显示没权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对usr文件夹进行操作需要有超级管理员的权限才行，你可以切换为超级管理员进行操作，或者在命令前面加 sudo；
命令前面加“sudo” 如
sudo cd - 或
sudo ln -s test.text test 或者
su
到
root
再解压
/usr/local/bin
写入的话需要root权限，个人文件夹不需要，你也可以不提权写到自己的文件夹，加一个环境变量也能用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6bc535ffb4dda8ab50facbc623dd2b/" rel="bookmark">
			基于深度学习的烟火检测——yolov5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于深度学习的烟火检测——yolov5 今天先写到这里，明天再写背景介绍数据集介绍训练结果测试效果 今天先写到这里，明天再写 写在最前面：分享记录自己在目标检测的爬坑之路，一起探讨学习
数据集：10k图片，基础网络：yolov5，现阶段改进模型最高map=0.896，想寻求进一步改进思路
背景介绍 对烟雾、火灾进行检测，达到实时高精度的要求，主要针对城市应用场景，暂未在森林场景中检测实际应用效果。
数据集介绍 数据集共计有：10202张图片；
烟雾火焰图片：5867张，包括：自建数据集+互联网下载图片+已公开数据（Bilkent 大学视频库、NIST 数据集、仁荷大学计算机视觉实验室建立的数据集等）
负样本共计：4335张，负样本包括：天空、阳光、路灯、车灯、街道、室内、室外、森林等
**说明：**已公开数据中多数是关于森林火灾、烟雾数据，需要进行一点的筛选，自己也是在众多数据中进行筛选，选择部分作为自己的数据集，
训练结果 说明：
batchsize=64，epoch：100，gpu：V100（16G）基础网络：yolov5s，网络改进部分暂时不公布（等项目结束后会更新），
测试效果 正在B站上传视频，今天先写到这里
基于深度学习的烟火检测——yolov5
小目标火焰检测：
基于深度学习的烟火检测——yolov5系列针对小目标检测效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a700936acd2b5914f08f6f4e0ea76b18/" rel="bookmark">
			Windows下使用python realsense2获取点云全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、获取realsense2内参二、Bonus：align与not_align的区别三、点云生成与可视化点云生成点云滤波需要注意的地方 总结 前言 本文是在windows下安装ros成功，继续装realsense-ros失败后的办法，使用pyrealsense2，直接使用python生成和可视化点云。
其实realsense2官方给了一些基础的python例程，如获取深度图、彩色图，对齐深度图与彩色图，Opencv可视化点云，Pyglet可视化点云等，但这些例子代码加上可视化后比较复杂，这里记录一下自己的代码得到点云的过程。贴官网链接。
一、获取realsense2内参 内参是相机求取三维坐标的一个重要参数，其构成了相机模型，这里不赘述原理，简单理解，通过针孔相机模型，其构成了相机坐标系到像素坐标系之间的转换，至于相机坐标系到世界坐标系，就是外参（平移、旋转）的事了。
除此之外，对于RGB-D相机，除了彩色相机有内参外，深度相机也有，那我们应该用哪个呢？答案是彩色相机。因为在获取点云之前，通常需要将深度图与彩色图配准，即将深度相机坐标系转换到彩色相机坐标系下，那么转换之后就使用的是彩色相机下的针孔模型了。话不多说贴代码：
import pyrealsense2 as rs import numpy as np import cv2 # Configure depth and color streams pipeline = rs.pipeline() config = rs.config() # Start streaming pipeline.start(config) # 创建对齐对象（深度对齐颜色） align = rs.align(rs.stream.color) try: while True: # # Wait for a coherent pair of frames: depth and color frames = pipeline.wait_for_frames() # 对齐后再获取 aligned_frames = align.process(frames) aligned_depth_frame = aligned_frames.get_depth_frame() color_frame = aligned_frames.get_color_frame() # 获取颜色帧内参 color_profile = color_frame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a700936acd2b5914f08f6f4e0ea76b18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7138d10c81c1a63e7406af54d8133d3/" rel="bookmark">
			Rocketmq启动把我给整哭了，就因为我用了Docker吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上期是基于解压压缩文件启动rocketmq,启动需要执行好几次命令，操作起来不是那么方便这次我们来试下基于docker来快速启动rocketmq，感觉操作起来没那么复杂，而且还很方便。
往期文章 如果还没有了解docker，可以先看下往期文章
使用脚本安装docker使用docker拉取镜像并启动docker-compose一键拉取并启动 开头 docker拉取镜像需要看对应的版本，可以在docker.hub中找自己想要的版本，包括启动安装等其他问题。
版本 docker-rocketmq 镜像 4.7.0 及以后 版本镜像 将 不在根据base镜像生成 server，broker 镜像，统一使用 base 镜像，两者区别只是调用的 启动文件不同
栗子 4.8.0版本 rocketmq地址：https://github.com/foxiswho/docker-rocketmq/tree/master/rmq
git clone https://github.com/foxiswho/docker-rocketmq.git cd docker-rocketmq cd rmq chmod +x start.sh ./start.sh 访问浏览器 localhost:8180 注意 如果你的微服务或者项目在开发的时候没有放入docker中或者与rocketmq容器不能直接用IP访问， 那么请把broker.conf中的 #brokerIP1=192.168.75.129 前面#号去掉，并且把后面的IP地址改成你的rocketmq容器宿主机IP地址, 否则报 com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to 172.0.0.120:10909 failed 配置文件 在 rmq/rmq/brokerconf 目录下
4.6.1版本 添加镜像 放在/use/local目录下
vi docker-compose.yml复制下面一段
version: '3.5' services: rmqnamesrv: image: foxiswho/rocketmq:server-4.6.1 container_name: rmqnamesrv ports: - 9876:9876 volumes: - .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7138d10c81c1a63e7406af54d8133d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b260f045126b992f7ec7be463285366/" rel="bookmark">
			【网络】inux流量控制器TC（Traffic Control）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实施
实施步骤概览
实施步骤
原理
经验之谈：
实施 原文：https://blog.csdn.net/tycoon1988/article/details/40832325
实施步骤概览 在Linux操作系统中流量控制器(TC)主要是在输出端口处建立一个队列进行流量控制，控制的方式是基于路由，亦即基于目的IP地址或目的子网的网络号的流量控制。
流量控制器TC，其基本的功能模块为队列、分类和过滤器。
Linux内核中支持的队列有，Class Based Queue ，Token Bucket Flow ，CSZ ，First In First Out ，Priority ，TEQL ，SFQ ，ATM ，RED。
这里我们讨论的队列与分类都是基于CBQ(Class Based Queue)的，而过滤器是基于路由(Route)的。
配置和使用流量控制器TC，主要分以下几个方面：分别为建立队列、建立分类、建立过滤器和建立路由，另外还需要对现有的队列、分类、过滤器和路由进行监视。 其基本使用步骤为：
1) 针对网络物理设备(如以太网卡eth0)绑定一个CBQ队列；
2) 在该队列上建立分类；
3) 为每一分类建立一个基于路由的过滤器；
4) 最后与过滤器相配合，建立特定的路由表。
先假设一个简单的环境，如下所示：
流量控制器上的以太网卡(eth0) 的IP地址为192.168.1.66，在其上建立一个CBQ队列。假设包的平均大小为1000字节，包间隔发送单元的大小为8字节，可接收冲突的发送最长包数目为20字节。
假如有三种类型的流量需要控制:
1) 是发往主机1的，其IP地址为192.168.1.24。其流量带宽控制在8Mbit，优先级为2；
2) 是发往主机2的，其IP地址为192.168.1.26。其流量带宽控制在1Mbit，优先级为1；
3) 是发往子网1的，其子网号为192.168.1.0，子网掩码为255.255.255.0。流量带宽控制在1Mbit，优先级为6。
实施步骤 1. 建立队列 一般情况下，针对一个网卡只需建立一个队列。
将一个cbq队列绑定到网络物理设备eth0上，其编号为1:0；网络物理设备eth0的实际带宽为10 Mbit，包的平均大小为1000字节；包间隔发送单元的大小为8字节，最小传输包大小为64字节。
tc qdisc add dev eth0 root handle 1: cbq bandwidth 10Mbit avpkt 1000 cell 8 mpu 64
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b260f045126b992f7ec7be463285366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f412a5d9fe924412c1cbe3720a7e3a3c/" rel="bookmark">
			elementUI的upload组件上传.rar文件时before-upload返回的file.type为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以看到，上传.zip压缩文件时候是没问题的
但是，上传.rar文件的时候type这个字段却会返回空
这时候在before-upload的钩子里面通过file.type来校验文件类型就行不通了，这时候可以采用正则的方法把扩展名截出来，然后进行校验，例如
beforeAvatarUpload(file){ var FileExt = file.name.replace(/.+\./, ""); if (['zip', 'rar','gz',".apk"].indexOf(FileExt.toLowerCase()) === -1){ this.$message.error("文件格式有误，请重新上传!") return false; } this.$message("上传中,请稍等") }, 这样就能解决文件类型问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dddecb6abde25f28cb0517aedee79d7/" rel="bookmark">
			python机器学习常用包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Numpy
2、Pandas
3、Scikit-learn
4、Hyperopt
5、LightGBM
6、XGBoost
7、Gensim
8、NLTK
9、Pytorch
10、Tensorflow
11、Keras
1、Numpy 使用Python进行科学计算的基本软件包， 是scikit-learn和 SciPy等机器学习库的基础。
链接：https://numpy.org/
安装方式：
pip
pip install numpy conda
conda install numpy 2、Pandas 快速，强大，灵活且易于使用的开源数据分析和处理工具。
链接：https://pandas.pydata.org/
安装方式：
pip
pip install pandas conda
conda install pandas 3、Scikit-learn 基于NumPy，SciPy和matplotlib构建，包含了大部分的机器学习算法
链接：https://scikit-learn.org/stable/
安装方式：
pip
pip install scikit-learn conda
conda install scikit-learn 4、Hyperopt 通用的优化框架，用于调参
链接：https://github.com/hyperopt/hyperopt
安装方式：
pip
pip install hyperopt 5、LightGBM 基于决策树算法的快速，分布式，高性能梯度提升（GBT，GBDT，GBRT，GBM或MART）框架
链接：https://github.com/Microsoft/LightGBM
安装方式：
pip
pip install lightgbm conda
conda install lightgbm 6、XGBoost XGBoost是经过优化的高效，灵活且可移植的分布式梯度提升库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dddecb6abde25f28cb0517aedee79d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af0414107c532045f4a108183f6f8007/" rel="bookmark">
			ArcGIS与EXCEL结合，对度分秒进行转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 Arcgis可以提取矢量面的中心点坐标
打开ArcMap软件，添加面矢量数据，先为面统计面积，转换成点后该字段会保留，点文件不再能统计面积
在工具栏中选择“ArcToolbox”按钮，打开ArcToolbox工具箱，在其中选择“数据管理工具”——“要素”——“要素转点”， 选择输入要素，设置输出要素
“内部”为可选选项，勾选时转点一定在面内，不勾选则可能出现在面外
转换结果如图所示
二 统计点的经纬度信息
3. 为点图层添加X 和Y两个字段，分别计算经纬度
4. 右击X-计算几何-点的X坐标-使用数据源的坐标系，选择单位为十进制度
三 对表里点要素自动编号
目的：后期删除某个点时可以一一对应，不错删
添加一个编号字段进行字段计算（可以选中部分来计算）
代码块1
可以更改间隔值来跳着编号 rec=0 def autoIncrement(): global rec pStart = 1 #初始值 pInterval = 1 #间隔值 if (rec == 0): rec = pStart else: rec = rec + pInterval return rec 代码块2
实现常规编号
autoIncrement() 实现给定长度编号，5为长度是5，如00001
(str(autoIncrement())).zfill(5) 实现从某个数字开始编号，下为从1000开始编号
autoIncrement()+1000 四 将十进制度转换为度分秒
将点要素的属性表导出为文本文件，加载至EXCEL输入公式
=TEXT(C2/24,"[h]°mm’ss″")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04195ed876c5489ec18c2990a11f4648/" rel="bookmark">
			php订阅号怎么借服务号权限,微信订阅号已经认证能否有网页授权功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信订阅号已经经过认证了，能否有网页授权获取用户信息的权限，应该怎么做网页授权的功能？
各位高人给个指点
本人微信开发的菜鸟呀，很多都不懂~
解决方案
10
1、设置域名
2、自定义菜单链接特殊处理(两种授权方式，弹窗或不弹窗授权)
3、跳转页面获取CODE参数
4、获取access token
5、调用接口
10
1.先到公众平台网站的本人的服务页中配置授权回调域名。(请注意，这里填写的域名不要加http://)
2.让用户进入制定URL(https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect)
参数说明：
APPID ： 公众号的唯一标识
REDIRECT_URI ：授权后重定向的回调链接地址，请使用urlencode对链接进行处理
SCOPE ： 1.snsapi_base (不弹出授权页面，直接跳转，只能获取用户openid)
2.snsapi_userinfo (弹出授权页面，可通过openid拿到昵称、性别、所在地。并且，即使在未关注的情况下，只要用户授权，也能获取其信息)
STATE ：重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值
3.在回调页面里通过code换取网页授权access_token
4.根据access_token获取用户信息
10
还有本人记得订阅号好像是没有网页授权获取用户信息权限的
10
引用:
Quote: 引用:
1、设置域名
2、自定义菜单链接特殊处理(两种授权方式，弹窗或不弹窗授权)
3、跳转页面获取CODE参数
4、获取access token
5、调用接口
这是设置网页授权的办法吗？
你用了网页授权功能，你就知道这个步骤对不对了
CodeBye 版权所有丨如未注明 , 均为原创丨本网站采用BY-NC-SA协议进行授权 , 转载请注明微信订阅号已经认证能否有网页授权功能！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e5385bb986848751c6e8e665572176c/" rel="bookmark">
			白话一致性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一致性算法WAROQuorum机制 一致性算法 强一致性：写数据时，必须保证所有的副本都写完成后，才能返回给用户。弱一致性：当写入数据时，只需要保证半数以上的数据为最新的，即可返回给用户，写完成。剩余的副本可以通过后台写完成同步，同步完成后所有的数据一致。 WARO WARO （Write All Read one）是一种强一致性的协议，当应用程序写数据时，所有的副本都写入后，本次写才视为完成，不然就返回错误。如此，读的时候去任意一个数据块上读取都是最新数据。缺点WARO的写性能下降，因为必须要等待所有副本写成功才可以返回给用户。
Quorum机制 Quorum是弱一致性的策略，即并不需要保证所有的副本都是最新数据，只需要保证半数以上的数据块为最新数据即可。
Quorum 的定义如下：假设有 N 个副本，更新操作 wi 在 W 个副本中更新成功之后，则认为此次更新操作 wi 成功，把这次成功提交的更新操作对应的数据叫做：“成功提交的数据”。对于读操作而言，至少需要读 R 个副本，其中，W+R&gt;N ，即 W 和 R 有重叠，一般，W+R=N+1。
N = 存储数据副本的数量W = 更新成功所需的副本R = 一次数据对象读取要访问的副本的数量
白话定义：
Quorum的定义：
如果有N个副本，写操作只需要写入N/2+1个副本就可以返回给用户，表示写成功。
读数据的时候只需要随机读取N/2+1个副本，找出数据最新的副本即可放回给用户，表示读成功
举个例子：
假设我有5个副本，原本是A，更新B操作成功写入了3个，另外2个副本仍是旧数据，此时在读取的时候，只要确保读取副本的数量大于2，那么肯定就会读到最新的数据。至于如何确定哪份数据是最新的，我们可以通过引入数据版本号的方式判断（Quorum 机制的使用需要配合一个获取最新成功提交的版本号的 metadata 服务，这样可以确定最新已经成功提交的版本号，然后从已经读到的数据中就可以确认最新写入的数据。） 还有一种解决方案：
我们在元数据管理中设置位图，记录那些数据块的数据是最新的，读取的时候直接通过获取位图即可找到对应的数据块，拿到最新数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dcc5483a42deaef8502528e5b9b30db/" rel="bookmark">
			NVDLA compiler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NVDLA简介 nvdia深度学习加速器(NVDLA)是一种免费开放式架构，具有可扩展性，高度可配置性，旨在简化集成和可移植性。NVDLA软件生态系统包括一个设备上的软件堆栈（开源版本的一部分），一个完整的培训基础架构，用于构建包含深度学习的新模型，以及将现有模型转换为可在设备上使用的形式的解析器软件。可以提供其自己的硬件平台以及软件内核：
NVDLA可以加速神经网络推理工作，可分两步完成
针对DLA硬件优化训练有素的神经网络，并将图形转换为DLA HW指令。转换后的图形将保存到称为可加载的平面缓冲区文件中。使用NVDLA编译器可以实现此目的，并且可以在主机系统上脱机执行。使用步骤1中的可加载程序在DLA上运行推理作业。这是使用NVDLA运行时实现的，并在目标系统上执行 NVDLA Compiler NVDLA编译器用于为DLA HW体系结构优化神经网络，并创建HW指令列表以在DLA上运行推理。NVDLA编译器可以从源代码构建，也可以直接使用预编译的二进制文件
root@6b9d78f7dd:# ./nvdla_compiler -h
Usage: ./nvdla_compiler [-options] --prototxt &lt;prototxt_file&gt; --caffemodel &lt;caffemodel_file&gt;
where options include:
-h print this help message
-o &lt;outputpath&gt; outputs wisdom files in 'outputpath' directory
--profile &lt;basic|default|performance|fast-math&gt; computation profile (default: fast-math)
--cprecision &lt;fp16|int8&gt; compute precision (default: fp16)
--configtarget &lt;opendla-full|opendla-large|opendla-small&gt; target platform (default: nv_full)
--calibtable &lt;int8 calib file&gt; calibration table for INT8 networks (default: 0.00787)
--quantizationMode &lt;per-kernel|per-filter&gt; quantization mode for INT8 (default: per-kernel)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dcc5483a42deaef8502528e5b9b30db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6311fb6f95bb62c877e384dace92b9dc/" rel="bookmark">
			DataWhale集成学习Task7--投票法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 投票法思路投票法的原理分析投票法实战案例分析补充知识KNN箱型图 投票法思路 投票法（voting）是集成学习里面针对分类问题的一种结合策略。基本思想是选择所有机器学习算法当中输出最多的那个类。
对于回归模型来说，投票法最终的预测结果是多个其他回归模型预测结果的平均值。
对于分类模型，硬投票法的预测结果是多个模型预测结果中出现次数最多的类别，软投票对各类预测结果的概率进行求和，最终选取概率之和最大的类标签。
投票法的原理分析 投票法是一种遵循少数服从多数原则的集成学习模型，通过多个模型的集成降低方差，从而提高模型的鲁棒性。在理想情况下，投票法的预测效果应当优于任何一个基模型的预测效果。
投票法在回归模型与分类模型上均可使用：
回归投票法：预测结果是所有模型预测结果的平均值。分类投票法：预测结果是所有模型种出现最多的预测结果。 分类投票法又可以被划分为硬投票与软投票：
硬投票：预测结果是所有投票结果最多出现的类。软投票：预测结果是所有投票结果中概率加和最大的类。 下面我们使用一个例子说明硬投票：
对于某个样本：
模型 1 的预测结果是 类别 A
模型 2 的预测结果是 类别 B
模型 3 的预测结果是 类别 B
有2/3的模型预测结果是B，因此硬投票法的预测结果是B
同样的例子说明软投票：
对于某个样本：
模型 1 的预测结果是 类别 A 的概率为 99%
模型 2 的预测结果是 类别 A 的概率为 49%
模型 3 的预测结果是 类别 A 的概率为 49%
最终对于类别A的预测概率的平均是 (99 + 49 + 49) / 3 = 65.67%，因此软投票法的预测结果是A。
从这个例子我们可以看出，软投票法与硬投票法可以得出完全不同的结论。相对于硬投票，软投票法考虑到了预测概率这一额外的信息，因此可以得出比硬投票法更加准确的预测结果。
在投票法中，我们还需要考虑到不同的基模型可能产生的影响。理论上，基模型可以是任何已被训练好的模型。但在实际应用上，想要投票法产生较好的结果，需要满足两个条件：
基模型之间的效果不能差别过大。当某个基模型相对于其他基模型效果过差时，该模型很可能成为噪声。基模型之间应该有较小的同质性。例如在基模型预测效果近似的情况下，基于树模型与线性模型的投票，往往优于两个树模型或两个线性模型。 当投票合集中使用的模型能预测出清晰的类别标签时，适合使用硬投票。当投票集合中使用的模型能预测类别的概率时，适合使用软投票。软投票同样可以用于那些本身并不预测类成员概率的模型，只要他们可以输出类似于概率的预测分数值（例如支持向量机、k-最近邻和决策树）。
投票法的局限性在于，它对所有模型的处理是一样的，这意味着所有模型对预测的贡献是一样的。如果一些模型在某些情况下很好，而在其他情况下很差，这是使用投票法时需要考虑到的一个问题。
投票法实战案例分析 首先我们创建一个1000个样本，20个特征的随机数据集：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6311fb6f95bb62c877e384dace92b9dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd9c246e6491d1be0e79a22948a9f4b/" rel="bookmark">
			Keynote教程 – 将演示文稿发布到WordPress博客中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您可以将演示文稿发布到 Medium 或 WordPress，使读者可以使用博客中的播放器点按浏览演示文稿（不包括动画效果和交互式元素）。您在 Keynote 讲演中对演示文稿所做的任何更改都将自动反映到内嵌版本。
若要查看演示文稿的完整版本，读者可以在 Keynote 讲演中打开它；如果您将共享权限设定为允许编辑（而非仅查看），则读者还可以在 Keynote 讲演中对其进行编辑。这种情况下，观看者所做的任何更改也将反映到内嵌的演示文稿中。
若要将交互式演示文稿包括在博客帖中，您需要共享演示文稿，然后在博客中添加演示文稿的链接。将演示文稿发布到博客中
若要发布演示文稿，您必须在电脑上使用 Apple ID 登录且 Keynote 讲演必须已设置为使用 iCloud 云盘。
1.在 Keynote 讲演中打开演示文稿后，点按工具栏中的 。如果此演示文稿已被共享，则“协作”按钮处显示勾号或数字，而非加号。
2.点按“共享选项”旁边的显示三角形，然后选取选项：
▪有权访问的用户：点按第一个弹出式菜单，然后选取“任何拥有链接的用户”。
▪权限：点按第二个弹出式菜单，如果不希望共享对象能够更改演示文稿，则选取“仅查看”；否则，选取“可更改”。
▪【注】不要添加密码；如果添加，则嵌入的链接将不可用。3.执行以下一项操作：
▪如果演示文稿还未共享：点按“拷贝链接”，然后点按“共享”按钮。当“正在开始协作”信息关闭时，演示文稿的链接即被拷贝到您的剪贴板。
▪如果演示文稿已经共享：点按“发送链接”，点按“拷贝链接”，然后点按“继续”。演示文稿的链接即被拷贝到您的剪贴板。
4.博客帖打开时，点按以将插入点放在新一行中（您想要链接出现的位置），按下 Command-V 以将链接粘贴到帖子中，然后按下 Return 键。发布后，播放器出现在帖子中。查看者可以在博客中点按或轻点浏览演示文稿，或使用“在 Keynote 讲演中打开”按钮来打开演示文稿的完整交互式版本。
如需要Keynote模板，可以使用一下模板软件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b061bc26623d53a6de65223c57a7fe97/" rel="bookmark">
			oracle12c ora 28579,关于执行ST_Geometry的st_centroid函数时报ORA-28579错误的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境
SDE版本：10./10.2/10.2.1/10.2.2
Oracle版本：11g R2 11.2.0.1
Windows版本：Windows Server 2008 R2
问题描述及原因
以全球的边界数据为样例数据，执行语句：
select sde.st_astext(sde.st_centroid(shape)) from sde.world;
报网络错误，错误编码ORA-28579：
由于该错误编码在之前也遇到过，但执行的是st_astext函数，如下图所示：
经测试发现st_astext函数可以正常运行，没有错误。另外，执行常用的测试语句
select st_point(0,0,0) from dual;
也正常运行。
在解决的过程中，参考了support网站上的关于错误编码ORA-28579的解释，链接如下：
当时涉及的版本是SDE 9.3.1和10，指出该问题是Oracle 的一个bug。由于该类问题在其他环境下所执行不同的函数时都会报此错误，初步判断是由于不稳定造成，应该是Oracle的一个Bug。
解决方法
从优先选择解决问题的角度出发，以Oracle 11g r2 11.2.0.3版本为蓝本进行测试。在更换了底层数据库后，执行st_point、st_centroid和st_astext等函数都可以正常运行。
所以建议使用11.2.0.3及以上版本即可解决该问题。
动态加载JS文件，并根据JS文件的加载状态来执行自己的回调函数
动态加载JS文件,并根据JS文件的加载状态来执行自己的回调函数, 在很多场景下,我们需要在动态加载JS文件的时候,根据加载的状态来进行后续的操作,需要在JS加载成功后,执行另一方法,这个方法是依托在加 ...
PDOstament对象执行execute()函数，只要是sql语句正确都是返回true
[PDO对象操作数据库] PDOstament对象执行execute()函数,只要是sql语句正确都是返回true. 问题: 想要PDO对象实现更改一条记录, 并修改是否成功要返回信息给用户. 上我的 ...
db2的select语句在db2 client上执行正确，JDBC连接数据库时报错
db2的select语句在db2 client上执行正确,JDBC连接数据库时报错. sql语句是:select ...from QUALIFIER.tableName fetch first 21 ...
JS定义一个立即执行的可重用函数
我定义了一个函数表达式 testFun var testFun = (function() { ... //函数内容})(); 测试结果:虽然 testFun 函数有如愿在页面加载后立即被执行,但再次 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b061bc26623d53a6de65223c57a7fe97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b536cdf6d88cd6304dde4a9ecb24ef/" rel="bookmark">
			华为数通HCIE面试项目题——网关是放在接入还是汇聚？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先网关应该放在接入还是汇聚需要根据网络场景选择，各有各的利弊。具体可以从以下几点进行分析：
1.成本分析。 如果网关放在汇聚设备上，那么对于接入设备要的要求就比较低，可以使用二层交换机就可以，从而可以节约成本。
如果网关放在接入设备上，那么对于接入设备就要求得是三层交换机，三层交换机的价格是远远高于二层交换机的。
所以如果预算不够充足建议首选网关放汇聚设备。
2.可以节约ip地址。 网关放在接入设备，接入设备和汇聚设备互联也需要规划IP地址，而网关放在汇聚就不需要在做IP地址规划。
3.管理方便。 如果网关放在汇聚层，那么不同办公网络互联只要通过汇聚做三层交换转发，但是如果放在接入层，那么汇聚和接入设备就需要用三层路由协议让网络互通，增加三层的控制，增多汇聚设备的邻居，对于管理而言，工程师需要管理多个三层设备，没有将网关放在汇聚简单、方便。
4.扩展性。 将网关放在汇聚，如果今后有办公网络的搬迁，那么不需要重新规划IP，如果新增办公网络，那么也只需要汇聚上新增三层网关的控制，DHCP等但是如果将网关放在接入，如果遇到搬迁，ip就要重新规划，如果新增办公网络，那么也要再去在接入设备上启用路由协议让网络互通。
5.冗余性。 一般企业里面，汇聚设备有多台，一般遇到2台，那么如果网关放在汇聚上，可以启用三层网关冗余协议，让网关有备份，比如使用vrrp协议，但是如果网关在接入设备上，冗余性比较差。
6.安全性方面。 其实网关的设置，主要可以限制广播域的范围，如果局域网中，主机数量过多，那么先要限制广播流量，避免如果有主机中毒，攻击范围过广，那么可以将网关设置在接入设备上。
综上考虑，我举两个用户场景：
园区网：规划网络的着重点在维护简单，易于操作，管理方便如果规模不是很大，那么建议网关放在汇聚上。比如校园网络。可以做策略可以限制每个教室的上网时间等都是直接在汇聚上，统一管理。数据中心：规划网络的着重点在安全、高效，稳定。
如：按业务逻辑划分的数据中心，可以将网关落入在每一个业务物理环境的接入交换机上，防止大量的广播泛洪。 能够有效隔离广插域,避免广播泛洪的攻击，造成大面积的影响。 路由控制和选路将网关放在接入设备上，那么网络规划会更加丰富，使用三层的路由协议让网络互联，能够有更好的路由控制和选路，操控流量转发的路径。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b76f917ac4015d6d9afa7299489078/" rel="bookmark">
			《Python 程序设计》题目集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python刷题 题目：第3章-19 找最长的字符串 (15 分)一、代码二、总结题目：第3章-20 逆序的三位数 (10 分)一、代码二、总结题目：第3章-21 判断回文字符串 (15 分)一、代码二、心得题目：第3章-22 输出大写英文字母 (15 分)一、代码二、心得题目：第4章-1 生成3的乘方表 (15 分)一、代码二、心得题目：第4章-2 统计素数并求和 (20 分)一、代码二、心得题目：第4章-3 猴子吃桃问题 (15 分)一、代码二、心得题目：第4章-4 验证“哥德巴赫猜想” (20 分)一、代码二、心得 题目：第3章-19 找最长的字符串 (15 分) 本题要求编写程序，针对输入的N个字符串，输出其中最长的字符串。
输入格式：
输入第一行给出正整数N；随后N行，每行给出一个长度小于80的非空字符串，其中不会出现换行符，空格，制表符。
输出格式：
在一行中用以下格式输出最长的字符串：
The longest is: 最长的字符串
如果字符串的长度相同，则输出先输入的字符串。
输入样例：
5
li
wang
zhang
jin
xiang
输出样例
The longest is: zhang
一、代码 N=int(input()) Maxstr="" for i in range(0,N): str=input() if len(str)&gt;len(Maxstr): Maxstr=str print("The longest is: {}".format(Maxstr)) 二、总结 按N个数输入可以通过for循环。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b76f917ac4015d6d9afa7299489078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/488027d245b17fe00fc15f8dae51c94c/" rel="bookmark">
			Spring Cloud Fegin  和 Eurake 简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud Fegin 和 Eurake 简单使用 Eurake注册中心 gradle中的依赖
dependencies { implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server' testImplementation('org.springframework.boot:spring-boot-starter-test') { exclude group: 'org.junit.vintage', module: 'junit-vintage-engine' } } 启动类
@SpringBootApplication @EnableEurekaServer//配置服务注册中心 //@EnableDiscoveryClient//开启客户端注册 public class SpringCloudEurekaStudyApplication { public static void main(String[] args) { SpringApplication.run(SpringCloudEurekaStudyApplication.class, args); } } 相关的配置
#续约任务调用间隔时间 eureka.instance.lease-renewal-interval-in-seconds=30 #失效时间 eureka.instance.lease-expiration-duration-in-seconds=90 #单机开发情况下容易触发保护机制导致，维护的注册列表不是实时准备 #默认开着，生产环境开着（产生原因一般是网络原因），会将当前的实例保存下来 #让其尽可能不过期，但是容易使消费端拿到不正确的注册列表，所以客户端一般要 #有容错的机制：断路器或者请求重试之类的 eureka.server.enable-self-preservation=false #注册的实例名 默认：IdUtils.getDefaultInstanceId eureka.instance.instance-id=${spring.application.name}:${server.port} #region 分组 设置分组优先在分组内进行服务调用，可以根据地域网络之类的进行分组 eureka.client.region=guangzhou #zone 分组 eureka.client.availability-zones.guangzhou=study #注册中心 server.port=9000 eureka.instance.hostname=localhost #是否向注册中心注册，如果是没有集群的话，没有必要 eureka.client.register-with-eureka=false #是否检索注册的服务列表，如果是没有集群的话，没有必要 eureka.client.fetch-registry=false #注册中心的地址，如果是没有集群的话，没有必要，如果有集群写其他的注册中心的地址，相应的eureka.client.register-with-eureka，eureka.client.fetch-registry 需要配置成true eureka.client.service-url.defaultZone=http://ip:port/eureka/ Fegin provide service 其实就相当于一个 Web 应用整合 Eurake
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/488027d245b17fe00fc15f8dae51c94c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c04fbff7c1e19563dfd5f5b1cba8ec8/" rel="bookmark">
			关于jvm中的gc fullgc的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是垃圾回收机制 任何语言在运行过程中都会创建对象，也就意味着需要在内存中为这些对象在内存中分配空间，在这些对象失去使用的意义的时候，需要释放掉这些内容，保证内存能够提供给新的对象使用。对于对象内存的释放就是垃圾回收机制，也叫做gc。
java的垃圾回收机制是自动化的，但是可控性很差，甚至有时会出现内存溢出的情况， 内存溢出也就是jvm分配的内存中对象过多，超出了最大可分配内存的大小。 什么是STW Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。
GC时的Stop the World(STW)是大家最大的敌人
内存的区域 新生代：新生代的目标就是尽可能快速的手机掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。
老年代：老年代存放的都是一些生命周期比较长的对象，就像上面所叙述的那样，在新生代中经历了n次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多（比例大概是1：2），当老年代满时就会触发major GC（full GC），老年代对象存货时间比较长，因此full GC发生的频率比较低。
注意: 在jdk8的时候java废弃了永久代，但是并不意味着我们以上的结论失效，因为java提供了与永久代类似的叫做“元空间”的技术。 废弃永久代的原因：由于永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryErroy。元空间的本质和永久代类似。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。也就是不局限与jvm可以使用系统的内存。理论上取决于32位/64位系统可虚拟的内存大小。 解读GC日志 以其中一行为例来解读下日志信息：
[GC (Allocation Failure) [ParNew: 367523K-&gt;1293K(410432K), 0.0023988 secs] 522739K-&gt;156516K(1322496K), 0.0025301 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]
GC：
表明进行了一次垃圾回收，前面没有Full修饰，表明这是一次Minor GC ,注意它不表示只GC新生代，并且现有的不管是新生代还是老年代都会STW。（Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。）
Allocation Failure：
表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。
ParNew：
表明本次GC发生在年轻代并且使用的是ParNew垃圾收集器。ParNew是一个Serial收集器的多线程版本，会使用多个CPU和线程完成垃圾收集工作（默认使用的线程数和CPU数相同，可以使用-XX：ParallelGCThreads参数限制）。该收集器采用复制算法回收内存，期间会停止其他工作线程，即Stop The World。
367523K-&gt;1293K(410432K)：单位是KB
三个参数分别为：GC前该内存区域(这里是年轻代)使用容量，GC后该内存区域使用容量，该内存区域总容量。
0.0023988 secs：
该内存区域GC耗时，单位是秒
522739K-&gt;156516K(1322496K)：
三个参数分别为：堆区垃圾回收前的大小，堆区垃圾回收后的大小，堆区总大小。
0.0025301 secs：
该内存区域GC耗时，单位是秒
[Times: user=0.04 sys=0.00, real=0.01 secs]：
分别表示用户态耗时，内核态耗时和总耗时
分析下可以得出结论：
该次GC新生代减少了367523-1293=366239K
Heap区总共减少了522739-156516=366223K
366239 – 366223 =16K，说明该次共有16K内存从年轻代移到了老年代，可以看出来数量并不多，说明都是生命周期短的对象，只是这种对象有很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c04fbff7c1e19563dfd5f5b1cba8ec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a6394f403165ff5f5d63457b49154b/" rel="bookmark">
			linux服务器nvidia驱动的安装与卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.卸载
有两种方式：
（1）sudo apt-get install autoremove --purge nvidia*
有的时候这个命令会不好用，本人暂不知道原因，可以采用方式二
（2）sudo /usr/bin/nvidia-uninstall
采用 nvidia-smi命令，发现command not found，就说明成功卸载
二.安装
nvidia驱动下载：https://www.nvidia.cn/Download/index.aspx?lang=cn
安装步骤：https://blog.csdn.net/qq_30163461/article/details/80314630
遇到的问题：
ERROR: Failed to run `/usr/sbin/dkms build -m nvidia -v 418.181.07 -k 4.4.0-151-generic`: Kernel preparation unnecessary for this kernel. Skipping... Building module: cleaning build area.... 'make' -j4 NV_EXCLUDE_BUILD_MODULES='' KERNEL_UNAME=4.15.0-50-generic IGNORE_CC_MISMATCH='' modules....(bad exit status: 2) ERROR (dkms apport): binary package for nvidia: 418.181.07 not found Error! Bad return status for module build on kernel: 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34a6394f403165ff5f5d63457b49154b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/611f8b00dc921e901de00f235b723786/" rel="bookmark">
			Android studio 编译错误：CreateProcess error=206, 文件名或扩展名太长。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android studio 编译错误：CreateProcess error=206, 文件名或扩展名太长。
原因为 bin 文件的路径层级太多
解决方法：
1. Android Studio -&gt; Run -&gt; Edit Configurations -&gt; Templates -&gt; Application
-&gt; shorten command line: 选择 JAR manifest -java -cp classpath.jar classname [args]
(默认为user-local default:none -java [options] classname [args] ) 2. 然后 Build -&gt;Clean project -&gt; 再重新Build
3. 如果是在 junit test 报的错，上面 Application 改为选择 Android JUnit ， 同样做Shorten command line的修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d317166a0abd7bcdf235eecf19661740/" rel="bookmark">
			#pragma pack详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据对齐 程序中变量的存储可以直接影响到程序的运行速度。计算机中都是以字节划分内存空间，通常编译器会为我们选择适合目标平台的对齐策略，但是有时候也带了一些麻烦，要自定义变量的对齐策略我们就需要用到#pragma pack。
应用场景 百度百科里提到一个典型的应用场景：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该int数据。
说白了，一个正确的字节对齐方式，就是为了让CPU在最短的时间内读取完变量，同时还让整体的结构存储空间最小。
字节对齐方式的使用 四个概念 数据类型自身的对齐值：基本数据类型的自身对齐值。结构体或者类的自身对齐值：其数据成员中自身对齐值最大的那个值。指定对齐值：系统默认的或者我们通过#pragma pack(value)指定对齐值value。数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。 想要巧妙设定字节对齐的字节数，必须要知道上面四个数值之间的关系：数据成员、结构体和类的有效对齐值，是最终存储时的数据、结构体和类决定数据存放地址方式的值。分为数据有效对齐值，结构体和类有效对齐值两个。同时整体的要满足这四条规则。
数据有效对齐值 = min(数据类型的自身对齐值，指定对齐值value)。结构体，联合体和类有效对齐值 = min(结构体、联合体和类自身对齐值，指定对齐值value)保证每一个数据满足：不同类型数据都满足：当前数据存储的首地址 % 数据有效对齐值 = 0；补齐末尾的空间，保证长度对齐，即总长度 % 实际对齐长度 = 0； 选择最好的对齐字节数值 最好的value的值，就是和变量自身对齐值为整数数关系下，使得总体数据结构占用空间最小的值。
//默认字节对齐方式为4字节对齐 struct C { char b; //自身对齐值为1，有效对齐值为min(1,4) int a; //自身对齐值为4，有效对齐值为min(4,4) short c; //自身对齐值为2，有效对齐值为min(2,4) }; //由上述第2条：C的有效对齐值为4。 数据结构大小计算：
我们认为第一个元素的起始地址为0x0000,所以,第一个char b的有效对齐值为1，0x0000%1=0，符合。第二个元素int a,有效对齐值为4，初始位置为0x0001,0x0001%4=1,不符合，往后面移动一位，0x0002%4=2,不符合，到0x0004,0x0004%4=0,符合，所以int a的起始地址为0x0004。第三个元素short c，有效对齐值为2，起始地址为0x0008,0x0008%2=0,符合，所以short c起始地址为0x0008所以结构体C的整体存储空间大小为：4+4+2=10,10%4=2，所以要满足上面的第四条，则0x0010和0x0011也是C的空间，这样C一共就占了12个字节。 但是明显这个不是最优的字节对齐方式，看看下面这个：
//改变字节对齐方式为2字节对齐 struct C { char b; //自身对齐值为1，有效对齐值为min(1,2) int a; //自身对齐值为4，有效对齐值为min(4,2) short c; //自身对齐值为2，有效对齐值为min(2,2) }; //由上述第2条：C的有效对齐值为2。 数据结构大小计算：
第一个元素的起始地址为0x0000,char b的有效对齐值为1，0x0000%1=0，符合。第二个元素int a,有效对齐值为2，初始位置为0x0001,0x0001%2=1,不符合，往后面移动一位，0x0002%2=0,符合，所以int a的起始地址为0x0002。第三个元素short c，有效对齐值为2，起始地址为0x0006,0x0006%2=0,符合，所以short c起始地址为0x0006。所以结构体C的整体存储空间大小为：2+4+2=8,8%2=0，所以满足上面的第四条，这样C一共就占了8个字节。 所以，设置不同的字节对齐方式对于数据的存储空间来说有不同的影响，在和变量自身对齐值为整数数关系下，选择变量有效对齐值中位数附近的数值效果最好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d317166a0abd7bcdf235eecf19661740/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f09f1b6fb377a171c792f086226e88a/" rel="bookmark">
			信息处理技术员软考笔记（第三章：信息、数据处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、信息处理1、信息处理的一般过程2、信息处理有关的规章制度3、信息收集4、信息加工5、信息传递和存储6、信息处理有关的规章制度7、信息处理实务 二、数据收集1、数据收集原则2、数据分类3、数据编码、校验4、 数据清洗5、数据存储和检索 一、信息处理 1、信息处理的一般过程 2、信息处理有关的规章制度 信息系统日常运行管理制度:机房管理与设备维护制度、突发事件处理制度、 信息备份、存档、整理和初始化制度。信息系统文档管理制度:系统开发以文档描述为依据，实体运行和维护用文 档来支持。信息系统运行安全和保密制度:防止系统被破坏，防止有意窃取信息资源。 3、信息收集 信息收集:是信息利用的第一步，且是关键的一步。信息收集工作的好坏, 直接关系到整个信息管理工作的质量。
信息分成原始信息和加工信息。
信息收集过程:制定信息收集计划-―设计收集提纲和表格（包括调查问卷）—―明确数据源、信息收集方式和方法—―实施信息收集工作（原始数据和二手数据）——形成信息收集成果。
信息的数据表示:米用一定的基本符号，使用一定的组合规则来表示信息。 计算机中采用的是二进制编码,其基本符号是0和1.
4、信息加工 信息加工:按照一定的顺序和方法进行分类、编码、存储、处理和传送，是
对收集来的信息进行去伪存真、去粗取精、由表及里、由此及彼的加工过程。主要内容:
(1）信息的清洗和整理（纠正可识别的错误、检查数据一致性、删除重复数 据、处理无效值和缺失值、进一步审查异常数据等。
(2）信息的筛选和判别（筛选和判别假消息。
(3）信息的分类和排序（信息分类和排序，以达到存储、检索、传递和使 用）
(4）信息的分析和研究（信息分析、概括及研究计算）。
(5）信息的编制（整理,增加编目和索引）。 5、信息传递和存储 信息传递:将信息从信息源传输给用户 的过程,信源、信宿、信道构成信 息传递的三要素。信息存储:加工后的信息按照一定的格式和顺序存储在特定的载体中的一种信息活动。存储介质有纸质存储和电子存储等。 6、信息处理有关的规章制度 信息系统日常运行管理制度:机房管理与设备维护制度、突发事件处理制度、 信息备份、存档、整理和初始化制度。信息系统文档管理制度:系统开发以文档描述为依据，实体运行和维护用文 档来支持。信息系统运行安全和保密制度:防止系统被破坏，防止有意窃取信息资源。 7、信息处理实务 企业信息处理内容:
(1）企业内部信息:企业产品信息，企业管理信息，设备、厂房和运力信 息,人员、知识和资产信息。
(2）企业外部信息:市场环境信息、技术经济信息,企业合作信息。企业信息工作管理:
(1）企业信息资料管理:扩大信息收集的范围和种类、加强信息资料的加 工和报道,做好信息资料的研究和决策支持工作。
(2）企业信息用户管理:了解用户的信息需求,提高信息服务的质量。
(3）企业信息工作管理:信息管理规章制度的建立，信息人员的配备和管
理,信息装备的配置,工作计划的制定。 二、数据收集 1、数据收集原则 数据收集原则:全面性原则（广泛、完整和全面）;准确性原则（数据真实、可
靠、最基本的要求);时效性原则（及时、迅速提供给使用者）;尊重提供者原则(尊重调查者对象及尊重信息提供方权益）等。
收集方式:
(1）从文献获取信息（二手数据;
(2）调查（普查和抽样调查，包括观察法访谈法、问卷调查法、实验法等）
抽样调查法:一种非全面调查。
普查:全面调查。
观察法:通过感官或仪器设备观察事物的情况。
访谈法/面谈:口头交谈,访谈者和被调查人员相互影响。
问卷法:标准化程度比较高。
实验法:控制条件观察某些因素对其他因素的影响。
(3）建立情报网和感知网（RFID自动识别、传感器网络和互联网等）。 2、数据分类 数据分类:把具有某种共同属性或特征的数据归并在一起，通过其类别的属性或特征 来对数据进行区别。数据分类原则:稳定性(最稳定的本质特征);系统性（按内在规律系统化排列）;可扩充性（留有余地，方便扩充）;综合实用性（实际需求，总体最优）;兼容性(国家、国际、行业标准）。 3、数据编码、校验 数据编码:为了实现计算机进行信息处理和数据库管理的目标，在数据分类 的基础上要进行数据编码。包括:
(1）数值型数据的编码:根据该类数据的参照标准对变量赋予数值，如年 龄。
(2）非数值数据的编码:确定编码规则后根据规则对变量赋予数值，如性 别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f09f1b6fb377a171c792f086226e88a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1b636b2d5b6ef54a7ab458cc2ab2e2/" rel="bookmark">
			ABAP-选择屏幕（二） SELECT-OPTIONS元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 语法及应用： 本篇重点是使用select-options替代parameters
语法
该语句会生成一个名为selcrit选择条件内表，具体请参数OPEN SQL章节中的 RANG条件内表
TABLES: mard. "声明一个表mard同名的工作区，便于选择屏幕定义屏幕字段。 SELECT-OPTIONS s_matnr FOR mard-matnr OBLIGATORY "必输 "NO-DISPLAY "不显示 VISIBLE LENGTH 20 "显示长度 NO-EXTENSION "限制选择表为单行，元素输入后面不会出现多行输入按钮 NO INTERVALS "只会出现low值输入框 DEFAULT '80010001' TO '80019999' SIGN I OPTION BT "参考range . 应用
输入ABAP程序默认值时，需要加上“=” 如果输入框中输入的值恰为ABAP程序中相应字段所对应的初始值时（如字符类型为空串，时间与数字类型为“0”串时），需要在第一个框前面选择操作符，否则程序将会忽略这个值的输入，即查询所有的
使用SELECT-OPTIONS替代PARAMETERS 使用SELECT-OPTIONS替代PARAMETERS好处是，当不输入值时，sql语句会查询所有的。如果是parameters,值为空就是查询为空（或0）的条目。这回导致我们取数时漏数。笔者以前都是通过拼接where条件的动态语句去分情况查询。而通过使用NO INTERVALS和NO-EXTENSION则可以使用SELECT-OPTIONS完美替代，外表看上去与PARAMETERS一样。
TABLES: marc. SELECT-OPTIONS: s_werks FOR marc-werks NO INTERVALS NO-EXTENSION. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a84a9dda3ee009d2a59f3a89b5b8b6c/" rel="bookmark">
			Idea开发Java项目常用友好插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常用的插件 语言插件：chinese Language pack阿里代码规范提示插件：Alibaba Java Coding GuidelinesMyBatisPlugin生成mapper.xml文件及快速跳转插件：Free MyBatis pluginIdea无限试用插件：IDE Eval Reset注解工具：Lombok 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3bcc0892e7f173a8f2886d979ca8ba/" rel="bookmark">
			Hive中的replace
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在其他的普通关系型数据库中，replace是一个替换函数，也可以做删除追加操作，但Hive其自身是不支持普通关系型数据库的replace操作的，当然除非你用的是sparksql操作hive数据，因为sparksql是支持的
如果你用的只是Hive那么你可以使用Hive提供的其他两个函数，达到同样的效果
translate(原字段，原有数据，替换数据) 这个方法在Hive0.10之后才可以使用的，之前一直使用的是如下函数
regexp_replace(原字段，原有数据，替换数据) 而在在hive中replace被用作修改表结构操作，用于弥补hive删除字段的操作需求
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfae648dbc1f52458e3c709fa169fb87/" rel="bookmark">
			H264（9）---------h264面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要有YUV这种数据出来？（YUV相比RGB来说的优点）
1、yuv除了yuv444外，其他格式比如yuv422 yuv420 yuv411都要比rgb格式占的空间下。
Yuv444 和rgb占的空间一样大。
Yuv422 = y + u+ v = y + y/2 + y/2 = 2y,比rgb小1/3
Yuv420 = y + u + v = y + y/2/2 + y /2/2 = 1.5y ,比rgb 小1/2
Yuv411 = y + u + v = y + 1/4y + 1/4y = 1.5y ,比rgb 小1/2
2、YUV（也称YCbCr）:Y标识明亮度，UV的作用是描述影像色彩及饱和度
Y是灰白
U绿色分量
V 红色分量
老的黑白电视机的数据只有一个Y分量，等到彩色电视剧出现的时候加入U和V分量。
H264/H265有什么区别？
宏块个数爆发式增加，宏块内容复杂度降低，运动失量大幅度增加。所以就诞生了H265.
H264宏块是16x16的，H265宏块会根据宏块的变化幅度来进行宏块划分。而H265的编码单位可以选择从最小的8x8到最大的64x64。
H265压缩率相对于H264压缩率理论上要少百分之50；
平常电视的帧率一般多少？30帧？高清一般需要60帧？
平常电视、动画是25帧/s,游戏是30帧/s。高清是清晰度，超过720p就是高清了。帧率和平滑度有关。
SPS有什么作用？
1、通过profile 我们知道视频的压缩级别，支持的特性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfae648dbc1f52458e3c709fa169fb87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ec4f3ab55c6742c3d35a66351680682/" rel="bookmark">
			Vue学习_使用vuecli创建项目（git bsah的使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue create vue-learn 创建项目
or vue ui 使用图形界面创建
创建过程会让选择配置选项，上下箭头选择不能使用时有以下两种选择：
（1）如果你在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作。你必须通过 winpty vue.cmd create hello-world 启动这个命令。不过，如果你仍想使用 vue create hello-world，则可以通过在 ~/.bashrc 文件中添加以下行来为命令添加别名。 alias vue=‘winpty vue.cmd’ 你需要重新启动 Git Bash 终端会话以使更新后的 bashrc 文件生效。之后即可使用上下键选择
（2）输入数字代替选择。。。
vue create vue-learn vue ui 控制台使用 vue ui打开界面
21/6/19更新：Linter/Formatter 不建议勾选，
不保存预设
##### 启动项目
项目文件结构 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff7012a0bdf81234dde4883eeb957707/" rel="bookmark">
			linux系统安装mysql后，查看root默认的登录密码。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入以下命令行：
grep "password" /var/log/mysqld.log（查找mysqld.log日志下的password句子） 然后登录就行了。
mysql -uroot -p 修改密码，使用以下语句：
ALTER USER 'root'@'localhost' IDENTIFIED BY 'NewPassWord1.'; 注意密码安全程度报错。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9c5019efc79df897f29331013d4142d/" rel="bookmark">
			chisel环境安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		step 0: 把java装好 chisel依赖于java的。所以第一步你要装个java.
去oracle官网去下载，下面网站。
Java SE Development Kit 8 - 下载​www.oracle.com
如果你恰好家境贫寒，就下上面个版本。找到这个，免费。不过上面网站需要注册，所以直接百度搜一个jdk-8u251-windows-x64装了好了。
也是，一路下一步的点。
step 1: 装个IDE 第一个步显然是要装个IDE。对于新手来说没必要搞各种复杂的东西，直接先上个IDE玩起来。就比如Visual Studio一样。一般的IDE选在JET BRAINS家的IntelliJIDEA就阔以。去下面网站下载去。
IntelliJ IDEA: The Capable &amp; Ergonomic Java IDE by JetBrains​www.jetbrains.com
点这个download
家境贫寒者一定要下载一个叫社区版的东西（手动狗头）
右面那个灰的。。。
下载好后一路下一步，到这个地方。按照下面的方法选。
然后一路下一步，等待安装完成，bingo~
打开刚才装好的IDE，然后先安装个scala插件。
至此，IDEA安装完毕。
step 2: 新建一个工程 如下。选择scala, sbt。
然后在这个设置界面，scala version这个地方，盛传2.12版本有BUG。所以选2.11.12。需要等下面下载一些依赖。
这个过程有待漫长。我这而一个多小时Orz
安装chisel
如下图所示，在build.sbt里添加一行依赖
libraryDependencies += "edu.berkeley.cs" %% "chisel3" % "3.1.2"
跑不通使用
scalaVersion := "2.11.12" libraryDependencies += "edu.berkeley.cs" %% "chisel3" % "3.1.2" libraryDependencies += "edu.berkeley.cs" %% "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9c5019efc79df897f29331013d4142d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79a869304cbb9e0d501e92b02183fae/" rel="bookmark">
			【pip】解决ERROR: Could not build wheels for pycuda which use PEP 517 and cannot be installed directly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：https://stackoverflow.com/questions/64038673/could-not-build-wheels-for-which-use-pep-517-and-cannot-be-installed-directly
1.环境 ubuntu16.04 2.问题 安装pycuda：
ERROR: Could not build wheels for pycuda which use PEP 517 and cannot be installed directly 3.解决 参考：https://stackoverflow.com/questions/64038673/could-not-build-wheels-for-which-use-pep-517-and-cannot-be-installed-directly
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pycuda --no-binary :all: 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/117520cffef31d7fed4a452790111e92/" rel="bookmark">
			数据中心流行的布线方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TOR
EOR
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131b0dd7dee684e517b4e6408624a0cc/" rel="bookmark">
			logstash 7.10安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 系统初始化2 下载安装包3 安装logstash4 调试命令 1 系统初始化 系统版本 ： CentOS 7.6
sed -i 's/enforcing/disabled/g' /etc/selinux/config setenforce 0 sed -i 's/#UseDNS yes/UseDNS no/g' /etc/ssh/sshd_config systemctl restart sshd grep DNS /etc/ssh/sshd_config grep SELINUX=disabled /etc/selinux/config systemctl disable firewalld NetworkManager systemctl stop firewalld NetworkManager 2 下载安装包 wget https://artifacts.elastic.co/downloads/logstash/logstash-7.10.0-x86_64.rpm -P /opt/ 3 安装logstash yum -y install /opt/logstash-7.10.0-x86_64.rpm 4 调试命令 /usr/share/logstash/bin/logstash -e 'input{stdin{}}output{stdout{codec=&gt;rubydebug}}' 文件输入
/usr/share/logstash/bin/logstash -e 'input{file{path =&gt; ["/var/log/boot.log","/var/log/message"]}}output{stdout{codec=&gt;rubydebug}}' 文件开始处输入 方便调试
/usr/share/logstash/bin/logstash -e 'input{file{path =&gt; ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131b0dd7dee684e517b4e6408624a0cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c63599688d502a0a73fe5f72f20d3f/" rel="bookmark">
			论文阅读笔记（6）: GNN-快速局部光谱滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验：
代码论文中有，这里只是解读部分代码： # -*- coding: utf-8 -*- # author: cuihu # time : 2021/4/10 15:07 # task: 本文图神经网络网的使用，详细请看论文 # 《Convolutional Neural Networks on Graphs with Fast Localized Spectral Filtering》 import sys sys.path.append("./lib") from lib import models, graph, coarsening, utils import numpy as np import matplotlib.pyplot as plt import sklearn.metrics import sklearn.neighbors import matplotlib.pyplot as plt import scipy.sparse import scipy.sparse.linalg import scipy.spatial.distance import numpy as np # step 1 step 1 step 1 step 1 step 1 step 1 step 1 step 1 step 1 step 1 # :建立数据。 d = 100 # Dimensionality.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88c63599688d502a0a73fe5f72f20d3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7354abc07fce91ae29910dd5b55ee88d/" rel="bookmark">
			hive与sqoop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive：基于Hadoop的关系数据库离线同步到数仓的工具，将结构化数据映射成一张数据库表，实现数据的提取、转换、加载。
Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。
Hive是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。
Hive 没有专门的数据格式。 Hive 可以很好的工作在 Thrift 之上，控制分隔符，也允许用户指定数据格式。
二.架构
1.用户接口主要有三个：CLI，Client 和 WUI。其中最常用的是CLI，Cli启动的时候，会同时启动一个Hive副本。Client是Hive的客户端，用户连接至Hive Server。在启动 Client模式的时候，需要指出Hive Server所在节点，并且在该节点启动Hive Server。 WUI是通过浏览器访问Hive。
2.Hive将元数据存储在数据库中，如mysql、derby。Hive中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。
3.解释器、编译器、优化器完成HQL查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在HDFS中，并在随后有MapReduce调用执行。 4.Hive的数据存储在HDFS中，大部分的查询、计算由MapReduce完成（包含*的及类似的查询除外，比如select * from tbl不会生成MapRedcue任务）。
sqoop导入有两种方式：
1）直接导入到hdfs，然后再load到hive表中
2）直接导入到hive中
一般生产情况导业务库数据，都是指定导入，不能全部导入，对业务库压力大。
1）需要已知的参数
mysql 的jdbc连接参数：jdbc链接、用户名、密码
mysql同步表的信息：列、表名
hive链接参数 ：是否有链接限制
hive目标表的信息：表名、分隔符、是否分区
2）具体参数
两种方式：1）指定mysql列导入 2）写相应的mysql的query sql语句导入
1）制定mysql表的某列、某表
#（必须参数）sqoop 导入，-D 指定参数，当前参数是集群使用队列名称
sqoop import -D mapred.job.queue.name=q #（必须参数）链接mysql jdbs参数 xxxx路径/yy库?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7354abc07fce91ae29910dd5b55ee88d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/080f22ec5ece5038561296aa144a23de/" rel="bookmark">
			java实现头像上传功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java模拟头像上传功能
File &amp;&amp; Reader
package File; import java.io.*; import java.util.Scanner; /* * 模拟上传头像 * */ /* 1.定义一个方法获取文件路径 2.定义方法判断用户头像在指定文件中是否存在 3.图片存在,重新上传 图片不存在，开始上传 */ public class UpLoadFile { public static void main(String[] args) throws IOException { // 获取 File fg = getPath(); // 判断段存在否 Boolean flag = isExist(fg.getName()); // 若是存在 提示 if (flag) { System.out.println("头像已存在，上传失败"); }else{ System.out.println("马上上传"); uploadFile(fg); } } // 1.定义一个方法获取文件路径 public static File getPath() { while (true) { // 1.接收路径 Scanner sc = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/080f22ec5ece5038561296aa144a23de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a315f88a2cb312cbbb944918f997a1d/" rel="bookmark">
			使用IntelliJ IDEA 配置安卓(Android)开发环境的教程详解(新手必看)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用IntelliJ IDEA 配置安卓(Android)开发环境的教程详解(新手必看)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eaa7cf2d66234a443461ec603e649d9/" rel="bookmark">
			初学Springboot(七)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Springboot缓存管理的作用二、基础环境的搭建1.创建环境2.数据库创建两张表(t_article和t_comment)，并创建对应的实体类3.在IDEA中创建实体类domain4.创建实体类的接口5.service(业务操作类)在该类中编写数据的查询、修改和删除操作6.创建控制类7.编写全局配置文件连接数据库8.测试9.开启缓存测试结果Spring Boot缓存注解介绍1.@EnableCaching注解2.@Cacheable注解3.@CachePut注解4.@CacheEvict注解5.@Caching注解6.@CacheConfig注解 基于注解的Redis缓存实现**Spring Boot**支持的缓存组件操作例子 基于API的Redis缓存实现**①** **使用Redis API **进行业务数据缓存管理② 编写Web访问层Controller文件ApiCommentController③基于API的Redis缓存实现的相关配置 前言 本次我们来一起学习Springboot的缓存，主要是默认缓存的体验以及Redis的使用
提示：以下是本篇文章正文内容，下面案例可供参考
一、Springboot缓存管理的作用 缓存是分布式系统中的重要组件，主要解决数据库数据的高并发访问。在实际开发中，尤其是用户访问量较大的网站，用户对高频热点数据的访问非常频繁，为了提高服务器访问性能、减少数据库的压力、提高用户体验，使用缓存显得尤为重要。
二、基础环境的搭建 1.创建环境 分别引入JPA，Web，MySQL以及待会会用到的Redis()先别导入，先试用一下默认的缓存组件 依赖启动器。
2.数据库创建两张表(t_article和t_comment)，并创建对应的实体类 在数据库中创建对应的库(这里我用的是之前的库Springboottest1)，并生成两张表。
3.在IDEA中创建实体类domain //该实体类与哪张表互相映射 @Entity(name = "t_comment") public class Comment { @Id//表示映射对应的主键 //表示主键生成策略(自动增长) @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String content; private String author; //指定映射的表字段名(表中的名字就是注解的name) @Column(name = "a_id") private Integer aId; (getset方法略) 4.创建实体类的接口 repository(接口)对JPA语句进行拓展修改(导包别导错)
import com.gdcp.domain.Comment; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import javax.transaction.Transactional; public interface CommentRepository extends JpaRepository&lt;Comment,Integer&gt; { //根据评论id修改评论作者评论作者author @Transactional//进行数控 @Modifying//对数据库进行变更必须加 @Query("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eaa7cf2d66234a443461ec603e649d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81559680a43512bdbcd186f53ffa396/" rel="bookmark">
			使用postman的Pre-request Script和zuul网关实现请求体RSA加密后转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用zuul网关实现请求体RSA加密后转发 前言方式1：postman的Pre-request Script对请求数据的RSA加密方式2： zuul网关对请求体加密后转发总结 前言 项目的服务端和app端的通信，是先在app端使用rsa的公钥加密后发送到服务端后使用rsa的私钥解密，这样在用postman调试接口的时候，就比较麻烦，需要对请求报文进行rsa加密后发送，不便于调试。刚开始想到是使用postman的Pre-request Script来先对请求体进行加密，也进行实现并且成功了，但是这种方式对请求报文可读性产生很大影响。于是就想到使用网关，请求到网关服务，在网关中对请求报文加密，再把加密后的报文转发到app服务端，这样在postman中就可以直接使用原始数据进行请求，可读性和易用性都得到了满足！！
方式1：postman的Pre-request Script对请求数据的RSA加密 环境变量-globals
环境变量-environment
Pre-request Script的代码如下
// 从环境变量中获取token参数 var tokenId = pm.environment.get("tokenId") ; var t_token = pm.environment.get("t_token") ; // 构建要发送的请求数据的json,并放到环境变量param中 pm.environment.set("param",'{"tokenId":"'+tokenId+'","t_token":"'+t_token+'"}'); // 从环境变量中加载rsa加密脚本，该脚本的下载地址为： // https://raw.githubusercontent.com/loveiset/RSAForPostman/master/forge.js var forgeJS = pm.globals.get("forgeJS"); eval(forgeJS); // 从环境变量中获取公钥 var rsa_public_key = '-----BEGIN PUBLIC KEY-----\n' + pm.globals.get("rsa_public_key") + '\n' + '-----END PUBLIC KEY-----'; // 开始构造公钥并对请求体param进行加密 var publicKey = forge.pki.publicKeyFromPem(rsa_public_key); var param = pm.environment.get("param") ; var buffer = forge.util.createBuffer(param, 'utf8'); var bytes = buffer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81559680a43512bdbcd186f53ffa396/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11bf3309d4521ba3c2787e41e674dbd3/" rel="bookmark">
			php-ps模块,ps文件格式模块不能解析该文件怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ps文件格式模块不能解析该文件怎么办？
我们PS打开文件时有时候会遇到【无法完成请求，文件格式模块不能解析该文件】而我们又很需要对该文件进行处理，那我们该怎么处理呢？
首先说明一下这种情况是由于文件扩展名不对导致的，相当于PS识别的图片打开方式与原图片应有的打开方式不一致导致的，所以在这里我们应该对图片的文件扩展名进行修改。
所以在这里我们选中文件点击鼠标右键进行重命名即可，可是有时候我们会发现，并不能修改扩展名，因为扩展名压根就没显示。
那么在这里我简单介绍一下显示被隐藏的已知文件的文件扩展名吧。怎么打开文件的扩展名显示呢？首先打开【我的电脑】，然后点击【工具】，在下拉菜单中点击【文件夹选项】，然后点击【查看】，并将鼠标向下滑，看大一个【隐藏已知文件的文件扩展名】的选项，将前面那个小钩钩去掉，点击确定即可。
现在我们再次选中文件点击鼠标右键进行重命名即可，但是在这里我们应该知道常用的图片格式有jpg，png，gif等等，我们只要在这之间尝试即可。
修改完后再次打开就行啦！大功告成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfed5df156470ca8b0ac31da9751e69d/" rel="bookmark">
			在rk芯片上调试rgb显示驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在rk芯片上调试rgb显示驱动
1.看芯片手册
2.看原理图
3.分析rk显示框架
可在网上找到一篇博客详见介绍screen相关内容，
博客地址：https://blog.csdn.net/u014770862/article/details/65442066?fps=1&amp;locationNum=6
根据以上内容写出了dts内容：
1.单独用一个dtsi文件存放
/ {
disp_timings: display-timings {
native-mode = &lt;&amp;timing0&gt;;
compatible = “rockchip,display-timings”;
timing0: timing0 {
screen-type = &lt;SCREEN_RGB&gt;;
out-face = &lt;OUT_P666&gt;;
clock-frequency = &lt;25000000&gt;;
screen-width = &lt;800&gt;;
screen-hight = &lt;480&gt;;
hactive = &lt;800&gt;;
vactive = &lt;480&gt;;
hsync-len = &lt;4&gt;;
hback-porch = &lt;8&gt;;
hfront-porch = &lt;8&gt;;
vsync-len = &lt;4&gt;;
vback-porch = &lt;8&gt;;
vfront-porch = &lt;8&gt;;
hsync-active = &lt;0&gt;;
vsync-active = &lt;0&gt;;
de-active = &lt;0&gt;;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfed5df156470ca8b0ac31da9751e69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a670197627f95fea2c5b6d50b6d110/" rel="bookmark">
			PID参数调节经验整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PID的介绍
在所有的调节控制器中，PID调节是最为经典的一种。其问世至今已有70年之久，以其结构简单、稳定性好、工作可靠、调整方便等优势，依然应用广泛。近来，着手进行一个关于精度补偿控制器的调节，所用的控制器为PID控制器，作为一个新着手的新人，特把网上的调试方法记录了一下，主要是感性的试凑法。
PID的基本控制原理入下图所示，主要是用于闭环控制：
通过理论输入与实际输出的反馈得出理论与实际的偏差，通过PID控制器的调节作用，使得实际逐渐趋近于理论，达到补偿的效果。
PID中的三个参数分别代表比例系数，积分时间常数和微分时间常数。P代表的比利控制是最简单的一种控制方式，其输出与输入误差成比例关系，但当仅有比例控制时，容易出现超调及稳态误差。I代表积分控制，其主要作用是消除稳态误差和减少系统趋近稳定是的振荡。D代表的微分控制，实际上类似于求导的过程，能够预知误差的变化趋势，能够避免严重的超调。
二、PID调节方法
PID调节的具体过程一般有理论计算整定法和工程整定法。对于复杂的、非线性的系统通常用工程整定法，即根据工程经验试凑出合理的参数。PID参数的设置步骤一般如下：
（1）首先选择一个合适的并且尽量短的采样时间让系统工作；
（2）首先加入比例环节，调节比例系数，直到系统的输出出现临界振荡；
（3）若单独的比例环节不能满足设计要求，则此时加入积分环节，调整好的比例系数缩小为原来的0.8，然后调节积分时间参数，使得系统能保持较小的稳态误差和较小的振荡时间，此时可以同时调整比例系数和积分时间常数，知道得到较为满意的结果；
（4）如若还不是特别满意，可以增加微分环节，从小到大逐渐增加微分时间常数，同时相应的更改比例系数和积分时间，试凑出合适参数。
三、PID调节口诀
参数整定找最佳，从小到大顺序查
先是比例后积分，最后再把微分加
曲线振荡很频繁，比例度盘要放大
曲线漂浮绕大湾，比例度盘往小扳
曲线偏离回复慢，积分时间往下降
曲线波动周期长，积分时间再加长
曲线振荡频率快，先把微分降下来
动差大来波动慢。微分时间应加长
理想曲线两个波，前高后低 4 比 1
一看二调多分析，调节质量不会低
四、网上看到的一个小故事
小明接到这样一个任务：有一个水缸点漏水（而且漏水的速度还不一定固定不变），要求水面高度维持在某个位置，一旦发现水面高度低于要求位置，就要往水缸里加水。
小明接到任务后就一直守在水缸旁边，时间长就觉得无聊，就跑到房里看小说了，每30分钟来检查一次水面高度。水漏得太快，每次小明来检查时，水都快漏完了，离要求的高度相差很远，小明改为每3分钟来检查一次，结果每次来水都没怎么漏，不需要加水，来得太频繁做的是无用功。几次试验后，确定每10分钟来检查一次。这个检查时间就称为采样周期。
开始小明用瓢加水，水龙头离水缸有十几米的距离，经常要跑好几趟才加够水，于是小明又改为用桶加，一加就是一桶，跑的次数少了，加水的速度也快了，但好几次将缸给加溢出了，不小心弄湿了几次鞋，小明又动脑筋，我不用瓢也不用桶，老子用盆，几次下来，发现刚刚好，不用跑太多次，也不会让水溢出。这个加水工具的大小就称为比例系数。
小明又发现水虽然不会加过量溢出了，有时会高过要求位置比较多，还是有打湿鞋的危险。他又想了个办法，在水缸上装一个漏斗，每次加水不直接倒进水缸，而是倒进漏斗让它慢慢加。这样溢出的问题解决了，但加水的速度又慢了，有时还赶不上漏水的速度。于是他试着变换不同大小口径的漏斗来控制加水的速度，最后终于找到了满意的漏斗。漏斗的时间就称为积分时间。
小明终于喘了一口，但任务的要求突然严了，水位控制的及时性要求大大提高，一旦水位过低，必须立即将水加到要求位置，而且不能高出太多，否则不给工钱。小明又为难了！于是他又开努脑筋，终于让它想到一个办法，常放一盆备用水在旁边，一发现水位低了，不经过漏斗就是一盆水下去，这样及时性是保证了，但水位有时会高多了。他又在要求水面位置上面一点将水凿一孔，再接一根管子到下面的备用桶里这样多出的水会从上面的孔里漏出来。这个水漏出的快慢就称为微分时间。
引自：https://www.diangon.com/wenku/plc/201608/00033770.html《PID控制原理，看完这三个故事你就明白了》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922e2e9ae74e8fcc004f466cecd5880d/" rel="bookmark">
			php使用keras模型,浅谈keras 模型用于预测时的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么训练误差比测试误差高很多？
一个Keras的模型有两个模式：训练模式和测试模式。一些正则机制，如Dropout，L1/L2正则项在测试模式下将不被启用。
另外，训练误差是训练数据每个batch的误差的平均。在训练过程中，每个epoch起始时的batch的误差要大一些，而后面的batch的误差要小一些。另一方面，每个epoch结束时计算的测试误差是由模型在epoch结束时的状态决定的，这时候的网络将产生较小的误差。
【Tips】可以通过定义回调函数将每个epoch的训练误差和测试误差并作图，如果训练误差曲线和测试误差曲线之间有很大的空隙，说明你的模型可能有过拟合的问题。当然，这个问题与Keras无关。
在keras中文文档中指出了这一误区，笔者认为产生这一问题的原因在于网络实现的机制。即dropout层有前向实现和反向实现两种方式，这就决定了概率p是在训练时候设置还是测试的时候进行设置
利用预训练的权值进行Fine tune时的注意事项：
不能把自己添加的层进行将随机初始化后直接连接到前面预训练后的网络层
in order to perform fine-tuning, all layers should start with properly trained weights: for instance you should not slap a randomly initialized fully-connected network on top of a pre-trained convolutional base. This is because the large gradient updates triggered by the randomly initialized weights would wreck the learned weights in the convolutional base. In our case this is why we first train the top-level classifier, and only then start fine-tuning convolutional weights alongside it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/922e2e9ae74e8fcc004f466cecd5880d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a981cce68bfd5d7a8b85afa7f110d3d9/" rel="bookmark">
			一文带你彻底理解高性能无锁队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一文带你彻底理解高性能无锁队列 目前，大部分软件设计都在追求高性能，快速处理，耗时低，仿佛已经是行业中必不可少的一部分。作为互联网从业人员，我们也必须适应时代的潮流，彻底掌握这种高性能编程。
问题引入：
一个生产者，多个消费者的队列，如果是你，你回怎么设计？ 想必拿到这个问题，更多的人脑海中已经浮现了一把锁；我也是的，那我们就从浅入深的来看看高性能的无锁队列是怎么一步一步的演化开来的。
1、低效的实现队列 编写多线程的时候，往往会发生资源竞争的现象，导致我们不得不加锁去保护变量，但在这个的同时也对性能造成了一定的损耗。
设计方案：（C++）
如图所示：
这种设计方式的话，我们是不可避免加锁操作的，因为其本身就不是线程安全的。
流程：
生产者放入队列中时，加锁，数据输入后完成加锁操作；然后剩余线程进行争锁操作，进行取队列数据操作；
简单实现：
template&lt;class T&gt; class SimpleQueue { public: SimpleQueue() { } ~SimpleQueue() { } void Push(T val) { _mutex.lock(); _q.push(move(val)); _mutex.unlock(); } T Get() { _mutex.lock(); if (_q.empty()) { _mutex.unlock(); return 0; } T val = _q.front(); _q.pop(); _mutex.unlock(); return val; } private: mutex _mutex; queue&lt;T&gt;_q; }; 这个就是比较简单，同事性能较差的一种方案；
既然我们提到了高性能，那么这种操作是不不符合我们需求的，那还有什么更好的方案提供跟高的性能吗？
很显然的一个操作：去锁化-----也就是常说的无锁队列
2、无锁队列 其实有锁和无锁就是我们平时所说的乐观锁和悲观锁：
加锁是一种悲观的策略，它总是认为每次访问共享资源的时候，总会发生冲突，所以宁愿牺牲性能（时间）来保证数据安全。 无锁是一种乐观的策略，它假设线程访问共享资源不会发生冲突，所以不需要加锁，因此线程将不断执行，不需要停止。一旦碰到冲突，就重试当前操作直到没有冲突为止。 无锁的策略使用一种叫做比较交换的技术（CAS Compare And Swap）来鉴别线程冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a981cce68bfd5d7a8b85afa7f110d3d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4784932b5d1ea7a4690ad46a0a8a6a8a/" rel="bookmark">
			leetcode 264. 丑数 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 264. 丑数 II
class Solution { public: int nthUglyNumber(int n) { vector&lt;int&gt; ugly(n, 0); int ind2 = 0, ind3 = 0, ind5 = 0; ugly[0] = 1; for(int ind = 1; ind &lt; n; ind++) { ugly[ind] = min(min(ugly[ind2] * 2, ugly[ind3] * 3), ugly[ind5] * 5); if(ugly[ind] == ugly[ind2] * 2) ind2++; if(ugly[ind] == ugly[ind3] * 3) ind3++; if(ugly[ind] == ugly[ind5] * 5) ind5++; } return ugly[n-1]; } }; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/208/">«</a>
	<span class="pagination__item pagination__item--current">209/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/210/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>