<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a520e846d301c3c0438cfc6aa060275b/" rel="bookmark">
			Docker项目部署（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建文件夹tools
mkdir tools
配置阿里云 Docker Yum 源 : yum install - y yum - utils device - mapper - persistent - data lvm2 yum - config - manager -- add - repo http://mirrors.aliyun.com/docker- ce/linux/centos/docker - ce.repo 更新 yum 缓存 yum makecache fast 安装 docker-CE yum - y install docker - ce 启动docker服务
systemctl start docker
下拉镜像
docker pull nginx
docker pull openjdk
docker pull mysql/mysql-server:5.7
创建自定义网络(报错33改成20，在报错就改成21)
docker network create --subnet=172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a520e846d301c3c0438cfc6aa060275b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58be9377504de17846f0e9ef0a4dcfd1/" rel="bookmark">
			Maven（五）如何只打包项目某个模块及其依赖模块？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、背景二、解决方案三、补充3.1 提出疑问3.2 解答 一、背景 在 SpringCloud 微服务框架下，会存在多个模块。当我们需要对其中某一个服务打包的时候，需要将该服务依赖的模块一起打包更新，如果项目比较小的话我们可以直接将项目中的所有模块进行 clean install 即可。
但是当项目运行一段时间后，项目中的代码量会变得很多，每个模块的打包时间也会越来越长，将所有模块进行打包的方法已经不再可取，那么 如何才能在打包的时候只将所需的模块及其依赖的模块进行打包呢？
二、解决方案 我们使用 mvn 命令搭配 -pl 和 -am 这两个参数即可解决上面的问题：
-pl 参数：或 --projects，指定了要构建的模块列表，Maven 将仅对这些指定的模块进行构建（多个用英文逗号分隔）；-am 参数：或 --also-make，表示如果目标模块依赖于其他模块，那么在构建目标模块之前，Maven 会先构建所有直接依赖于目标模块的子模块。 注意： -am 并不会递归地构建所有简介依赖的模块，之构建直接依赖于目标模块的子模块。
命令示例：
mvn clean package -am -pl com.demo:springboot-demo 三、补充 3.1 提出疑问 看完上面这种方式，可能会有这样一个疑问：Maven 打包的时候不应该是先从本地仓库拉取么？我这里使用 mvn package 而不是 mvn install，通过 -am 打包好的直接依赖会打到新的目标模块包中吗？
3.2 解答 通过 -am 打包好的直接依赖会自动打到新的目标模块包中的。
因为，当所有的直接依赖模块都成功构建完成后，Maven 会对目标模块执行打包操作（如 jar、war 等），并 将直接依赖模块的输出结果作为当前模块的依赖库进行引用和打包。
整理完毕，完结撒花~ 🌻
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df9339f7c4f77b8df65b43f8b060e14b/" rel="bookmark">
			深度学习记录--mini-batch gradient descent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		batch vs mini-batch gradient descent batch：段，块
与传统的batch梯度下降不同，mini-batch gradient descent将数据分成多个子集，分别进行处理，在数据量非常巨大的情况下，这样处理可以及时进行梯度下降，大大加快训练速度
mini-batch gradient descent的原理 两种方法的梯度下降图如下图所示
batch gradient descent是一条正常的递减的曲线
mini-batch gradient descent是一条噪声很大的曲线，分成许多小段时，每个小段是一条batch gradient descent曲线，总体看这条曲线还是递减的趋势
为什么会有区别呢？
mini-batch gradient descent中的,可能容易计算，也可能很难计算，这就导致cost时高时低，出现摆动，其实主要是mini-batch的大小的原因
mini-batch size 当size=m，mini-batch gradient descent变为batch gradient descent
梯度下降的噪声更小，步长更大，最终会收敛于最小值(如下图蓝色曲线)
弊端：如果数据量很大时，单次迭代时间过长
当size=1，变为随机梯度下降(stochastic gradient descent),每个样本都是独立的
每个样本都是随机的，可能靠近最小值，也可能远离最小值，噪声很大，无法收敛，最终在最小值附近波动(如下图紫色曲线)
弊端：由于每次只处理一个训练样本，失去了向量化的加速效果，训练效率过低
合适的size--&gt;between1 and m
既可以获得向量化的加速效果，又可以及时进行后续操作(减少单次迭代时间)
梯度下降图如下图绿色曲线(噪声相对随机梯度下降较小，最终不会收敛，在最小值附近波动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c83208f4847fb37ea38f3b7afc42d0f/" rel="bookmark">
			RK3566环境搭建和烧写方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入rk3568这款芯片的烧录模式共有3种方式：
一，软硬件环境
1、配套sdk版本的驱动DriverAssitant_vx.x.x和RKDevTool_Release_vx.x，版本不对应可能无法烧录，建议直接在sdk压缩包里获取；
2、如果正确安装DriverAssitant_vx.x.x且usb硬件连接完好，电脑端会有主线驱动识别ok的提示，比如我用的win10系统，设备管理器会新增Rockusb Device。未识别的情况应检查驱动和接线；
3、烧录的镜像如uboot、updateimg等也需要版本对应，另外注意有的开发板厂家在uboot层面配置了keys（加密），比如ZLG，这个时候需要第三方的sdk编译镜像；
二，加载模式分类
RK的CPU通常启动后有三种模式：normal模式、 loader模式、maskrom模式。 1、normal模式：正常的启动模式，这个模式无法刷固件，一般板子通电就是这个模式；
2、loader模式：刷固件模式，这个模式可以刷各种image； 进入该模式目前尝试过2种方式。第一种，按住recover按键再通电，通过管脚电平量触发以及RKDevTool_Release_vx通信，PC机可以检测到进入该模式；第二种，加载运行小系统后，命令行输入reboot loader命令也可以看到工具端提示“发现一个loader设备”；
3、maskrom模式：这种模式用于拯救砖头机器，比如bootloader/uboot 无法启动，无法进入loader模式正常下载。 该模式下可以整体烧录updateimg，也可以部分烧录其他img。
进入该模式目前也尝试过2种方式。第一种，需要通过在板子上找对应的emmc_clko、gnd焊点，短接后通电，这种方式可以真正解决变砖；第二种，进入uboot或小系统之后，有对应的命令行rbrom或reboot loader，工具端检测到loader模式后，从loader模式切入maskrom模式。
三，常见错误
在自研单板调试过程种，遇到如下几个问题：
1)usb线缆（otg的，常用的type-C就是）异常导致无法找到设备，usb的串阻最好尽可能标准；
2)不要同时运行多个工具端tools;
3)烧录前检测设备，虚拟机主动优先检测到usb接口设备；
四，debian或linux环境搭建
环境：vmware16，ubuntu 18.04
安装依赖库：
sudo apt-get install repo git ssh make gcc libssl-dev liblz4-tool expect g++ patchelf chrpath gawk texinfo chrpath diffstat binfmt-support qemu-user-static live-build bison flex fakeroot cmake unzip device-tree-compiler python-pip ncurses-dev python-pyelftools 获取SDK前需要安装
sudo apt update sudo apt install -y repo git python 下载完成后先验证一下MD5码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c83208f4847fb37ea38f3b7afc42d0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48756cedbb53d50348d5d4c5035d0668/" rel="bookmark">
			路由器结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由器是连接互联网的设备，本文主要描述路由器的结构组成。
如上所示，OSI（Open System Interconnect）开放系统互联参考模型是互联网架构的标准协议栈，由ISO标准组织制定。自底向上，互联网架构分为7层，操作系统或者网络设备的网络架构实现都是参考该模型，每一层在互联网的世界中担负着不同的角色与职责，每一层都向上层提供服务支撑，其中，7层网络架构中的应用层、表示层以及会话层可以合并成应用层，如a图中的5层网络架构。应用层主要是提供应用软件、组件、服务，表示层主要是提供应用层数据格式或者规则的定义，会话层主要是提供应用层端到端连接上下文服务，运输层主要是提供TCP或者UPD数据报的封装拆装服务，网络层主要是提供IP地址数据报封装拆装寻址服务，链路层主要是提供MAC地址数据帧封装拆装寻址服务，物理层主要是提供有线无线物理介质的通讯传输服务
如上所示，互联网包括有线互联以及无线互联，互联网中每个地区的网络是由路由器连接、路由器是工作在IP地址网络层、每个局域网的网络是由交换机连接、交换机是工作在MAC地址链路层
如上所示，本地路由器在控制面中使用路由选择算法计算IP地址数据报的分发路径、在数据面执行数据报转发
如上所示，SDN软件定义网络架构的路由器中，控制面与数据面分别对应北向与南向，每个路由器的控制面在远程数据中心中使用北向接口进行集中管理、远程为每个路由器的数据面计算转发路径、每个路由器的数据面在本地执行数据报转发
如上所示，路由器的内部结构分为控制面与数据面，其中，控制面包括路由选择处理器模块，数据面包括输入端口模块、交换结构模块、输出端口模块
如上所示，输入端口模块的数据处理流程，根据OSI网络架构自底向上包括物理层处理、链路层处理、网络层处理、交换结构模块处理
如上所示，路由器中的路由表是由控制面管理模块生成、路由表中提供路由器的端口号与IP地址范围的映射对应关系、匹配IP地址时使用前缀匹配、存在多个匹配记录时使用最长匹配原则
如上所示，交换结构模块使用三种模式的数据包运输与转发，内存模式是使用操作系统从内存中读写数据的方式、纵横模式是使用多链路运载的方式、总线模式是使用中心化负载的方式
如上所示，根据OSI网络架构，输出端口模块的数据处理流程是交换结构模块处理、网络层处理、链路层处理、物理层处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb9f0500c459fbdf38d41819d8de25e/" rel="bookmark">
			Js-WebAPIs-事件流（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 • 事件流与两个阶段说明 事件流指的是事件完整执行过程中的流动路径
说明：假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段
简单来说：捕获阶段是 从父到子 冒泡阶段是从子到父
实际工作都是使用冒泡事件为主（默认的） • 事件捕获 事件捕获概念： 从DOM的根元素开始去执行对应的事件 (从外到里)
事件捕获需要写对应代码才能看到效果 • 事件冒泡 事件冒泡概念: 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡
• 阻止冒泡 阻止事件流动 问题：因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素
需求：若想把事件就限制在当前元素内，就需要阻止事件冒泡
前提：阻止事件冒泡需要拿到事件对象
阻止默认行为 （常用） 我们某些情况下需要阻止默认行为的发生，比如 阻止 链接的跳转，表单域跳转
• 解绑事件 注意：匿名函数无法被解绑
鼠标经过事件的区别 鼠标经过事件：
mouseover 和 mouseout 会有冒泡效果mouseenter 和 mouseleave 没有冒泡效果 (推荐) 两种注册事件的区别 传统on注册（L0）
Ø 同一个对象,后面注册的事件会覆盖前面注册(同一个事件)Ø 直接使用null覆盖偶就可以实现事件的解绑Ø 都是冒泡阶段执行的 事件监听注册（L2）
Ø 语法: addEventListener(事件类型, 事件处理函数, 是否使用捕获)Ø 后面注册的事件不会覆盖前面注册的事件(同一个事件)Ø 可以通过第三个参数去确定是在冒泡或者捕获阶段执行Ø 必须使用removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段)Ø 匿名函数无法被解绑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceda4716add066883eb960b20fe3be5f/" rel="bookmark">
			使用 Kali Linux Hydra 工具进行攻击测试和警报生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Hydra 工具和 Kali Linux 简介 在网络安全领域中，渗透测试是评估系统密码强度的重要组成部分。Hydra 是一款由黑客组织“The Hacker's Choice”开发的开源登录破解工具，支持50多种协议。本教程将探索如何将 Hydra 与 Kali Linux 结合使用，Kali Linux 是一款专为渗透测试和道德黑客攻击而设计的操作系统。
使用 Kali Linux 进行 Web 渗透测试Kali Linux 是一款用于渗透测试和安全审核的强大工具。它包含了许多用于发现和利用系统漏洞的工具。使用 Kali Linux，您可以访问目标 PC，并获取有关其安全状态的宝贵信息。https://fostmar.online/archives/183/Hydra 工具和 Kali Linux 的简介
Hydra 是一款强大且灵活的暴力破解工具，用于渗透测试和道德黑客攻击。它支持各种网络服务的密码破解，包括 telnet、FTP、HTTP、HTTPS、SMB 和数据库等。Kali Linux 则是一款基于 Debian 的操作系统，预装了多种渗透测试工具，其中包括 Hydra。
二、Hydra 和 Kali Linux 的安装 1. 安装 Kali Linux Kali Linux 的安装相对简单，只需从官方网站下载 ISO 镜像，创建可启动的 USB 或 DVD，并按照屏幕上的说明进行安装。安装完成后，您将拥有一个功能齐全的 Kali Linux 系统，可用于渗透测试。2024 年排名前八的 Kali Linux 工具渗透测试工具是网络安全领域的不可或缺之物，它们可用于评估网络安全，检测漏洞并加强组织的安全性。Kali Linux提供了一系列专业渗透测试工具，包括Fluxion、John the Ripper、Lynis、Metasploit Framework、Nikto、Nmap、Skipfish和Social Engineering Toolkit。这些工具用于测试Wi-Fi网络、密码强度、系统审计、Web服务器安全性、网络映射以及社会工程攻击，有助于保护组织的网络免受潜在威胁。https://fostmar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceda4716add066883eb960b20fe3be5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b610b96fa51f37d8a194d43d868259/" rel="bookmark">
			第四章 信息收集 - 《骇客修成秘籍》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章 信息收集 作者：Julian Paul Assange
简介 攻击的重要阶段之一就是信息收集。为了能够实施攻击，我们需要收集关于目标的基本信息。我们获得的信息越多，攻击成功的概率就越高。
我也强调这一阶段的一个重要方面，它就是记录。在编写这本书的时候，最新的Kali发行版包含了一组工具用于帮助我们核对和组织来自目标的数据，以便我们更好地侦查目标。类似Maltego CaseFile和 KeepNote的工具就是一个例子。
4.1 服务枚举 在这个秘籍中，我们将会展示一些服务枚举的小技巧。枚举是我们从网络收集信息的过程。我们将要研究DNS枚举和SNMP枚举技术。DNS枚举是定位某个组织的所有DNS服务器和DNS条目的过程。DNS枚举允许我们收集有关该组织的重要信息，例如用户名、计算机名称、IP地址以及其它。为了完成这些任务我们会使用DNSenum。对于SNMP枚举，我们会使用叫做SnmpEnum的工具，它是一个强大的SNMP枚举工具，允许我们分析网络上的SNMP流量。
操作步骤 让我们以DNS枚举作为开始：
我们使用DNSenum进行DNS枚举。为了开始DNS枚举，打开Gnome终端，并且输入以下命令：
cd /usr/bin./dnsenum --enum adomainnameontheinternet.com 请不要在不属于你的公共网站或者不是你自己的服务器上运行这个工具。这里我们将adomainnameontheinternet.com作为一个例子，你应该替换掉这个目标。要当心！
我们需要获取信息输出，例如主机、名称服务器、邮件服务器，如果幸运的话还可以得到区域转换：
我们可以使用一些额外的选项来运行DNSenum，它们包括这些东西：
-- threads [number]允许你设置一次所运行的线程数量。-r允许你开启递归查找。-d允许你设置在WHOIS请求之间的时间延迟，单位为秒。-o允许我们制定输出位置。-w允许我们开启WHOIS查询。 更多WHOIS上的例子，请见WHOIS的维基百科。
我们可以使用另一个命令snmpwalk来检测Windows主机。Snmpwalk是一个使用SNMP GETNEXT请求在网络实体中查询信息树的SNMP应用。在命令行中键入下列命令：
snmpwalk -c public 192.168.10.200 -v 2c 我们也可以枚举安装的软件：
snmpwalk -c public 192.168.10.200 -v 1 | grep hrSWInstalledNameHOST-RESOURCES-MIB::hrSWInstalledName.1 = STRING: "VMware Tools"HOST-RESOURCES-MIB::hrSWInstalledName.2 = STRING: "WebFldrs" 以及使用相同工具枚举开放的TCP端口：
snmpwalk -c public 192.168.10.200 -v 1 | grep tcpConnState | cut -d"." -f6 | sort –nu212580443 另一个通过SNMP收集信息的工具叫做snmpcheck：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4b610b96fa51f37d8a194d43d868259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5310eb0e98e5c5ce2a607e9466c8159/" rel="bookmark">
			【java常用接口】Comparator学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 常见的应用场景2. 基本使用3. 常见用法4. 高级用法5. 示例代码及解析 Comparator 是 Java 中的一个接口，用于定义对象之间的排序规则。它可以用于对集合中的对象进行排序，或者用于自定义排序算法。 1. 常见的应用场景 对集合中的对象进行排序。自定义排序算法。结合 Stream流 实现更便捷的排序操作。 2. 基本使用 实现 Comparator 接口：创建一个类，实现 Comparator 接口，并重写其 compare 方法。在 compare 方法中定义排序规则。匿名内部类：使用匿名内部类的方式创建 Comparator 对象，并在其中实现 compare 方法。Lambda 表达式：使用 Lambda 表达式简化 Comparator 的创建。 3. 常见用法 使用 Comparator.comparing 方法：Comparator 提供了 comparing 方法，可以根据对象的某个属性进行比较。使用 Comparator.comparingInt、comparingLong、comparingDouble 方法：对于基本类型的属性，可以使用相应的方法进行比较。 4. 高级用法 逆序排序：通过调用 Comparator 的 reversed 方法可以实现逆序排序。多级排序：可以通过链式调用多个 Comparator 对象来实现多级排序。自定义比较逻辑：在 compare 方法中可以根据自己的需求定义排序逻辑。 5. 示例代码及解析 public class Student { private String name; private int score; public Student(String name, int score) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5310eb0e98e5c5ce2a607e9466c8159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/874431a25af72c8c93c24c2c8901fa93/" rel="bookmark">
			【jQuery入门】DOM对象和jQuery对象，以及互相转换，选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、jQuery与DOM对象二、jQuery与DOM对象的相互转换三、选择器3.1基础选择器3.2 隐式迭代3.3 筛选选择器3.4 筛选方法 总结 前言 jQuery是一款流行的JavaScript库，它在前端开发中简化了DOM操作。本文将介绍jQuery中的两个重要概念：DOM对象和jQuery对象，以及它们之间的互相转换。理解这些概念对于有效利用jQuery的功能至关重要。
一、jQuery与DOM对象 1.用原生JS获取来的对象就是DOM对象
2.jQuery方法获取的元素就是jQuery对象
3.jQuery对象本质是:利用$对DOM对象包装后产生的对象(伪数组形式存储)
获取jQuery对象使用下面这种方式：
$('选择器') 这个选择器我们后面会有，可以先简单的理解为css的选择器一样
注意：jQuery对象只能使用jQuery方法，DOM对象只能使用Javascript方法和属性。
二、jQuery与DOM对象的相互转换 DOM对象与jQuery 对象之间是可以相互转换的。
因为原生js 比jQuery 更大，原生的一些属性和方法Query没有给我们封装.要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。
DOM对象转换成jQuery对象：$(DOM对象)
&lt;script&gt; $(function(){ var div = document.querySelector("div") var jdiv = $(div) var jdiv2 = $('div') }) &lt;/script&gt; 可以使用上面这两种格式，一种是以及获取了的，一种是选择器方法
jQuery对象转换成DOM对象：$(‘jQuery对象’)[index]、$(‘jQuery对象’).get(index)，因为jQuery对象是伪数组，所以需要指定下标
&lt;script&gt; $(function(){ var div = document.querySelector("div") var jdiv = $(div) var ddiv = $('jdiv')[0] var ddiv2 = $('jdiv').get(0) }) &lt;/script&gt; 三、选择器 3.1基础选择器 $("选择器")里面的选择器直接写CSS选择器即可，要加引号！
&lt;!DOCTYPE html&gt; &lt;html lang="ch"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/874431a25af72c8c93c24c2c8901fa93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dee00565f030041b4ffa5b404fdf9697/" rel="bookmark">
			一文读懂I2C总线 (超详细配42张高清图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一文读懂I2C总线 (超详细配42张高清图) I2C（Inter-Integrated Circuit）通信总线，作为嵌入式系统设计中的一个关键组成部分，其灵活性和高效率使其在高级应用中备受青睐。本文旨在提供关于I2C通信总线的深度解析，包括其基本概念、特点、通信协议，以及在不同场景下的高级应用和最佳实践。I2C接口只有2根信号线，总线上可以连接多个设备，硬件实现简单，可扩展性强。I2C通信协议可以用普通GPIO引脚进行软件模拟。I2C接口主要用于通讯速率要求不高，以及多个器件之间通信的应用场景。
1. I2C总线历史 I2C（Inter-Integrated Circuit）总线是一种重要的串行通信协议，它的历史可以追溯到上世纪80年代初期。以下是对I2C总线历史的详细介绍：
起源： I2C总线技术由荷兰的飞利浦半导体（现在的恩智浦半导体）在1982年开发。最初，这项技术是为了在电视机内部实现简单、高效、低成本的通信而设计的。 设计目标： 设计I2C的初衷是减少电视机等复杂电子系统内部的布线数量，同时也降低制造成本。通过使用只有两根线的通信总线，它有效地减少了器件间连接的复杂性。 技术发展： 随着技术的成熟和普及，I2C协议得到了广泛的应用和扩展。从最初的标准模式（100kHz），发展到快速模式（400kHz）和高速模式（3.4MHz）。 标准化和开放： 虽然最初由飞利浦半导体开发，但I2C协议后来被标准化并广泛应用于多种设备中。飞利浦半导体放弃了对这项技术的专利权，使其成为开放标准。 广泛应用： I2C技术由于其简单性和有效性，已成为嵌入式系统设计中不可或缺的一部分。 2. I2C通信总线基本概念 I2C是一种多主机、两线制、低速串行通信总线，广泛用于微控制器和各种外围设备之间的通信。它使用两条线路：串行数据线（SDA）和串行时钟线（SCL）进行双向传输。
特点 两线制总线：I2C仅使用两条线——串行数据线（SDA）和串行时钟线（SCL）进行通信，有效降低了连接复杂性。
多主多从设备支持：I2C支持多个主设备和多个从设备连接到同一总线上。每个设备都有唯一的地址。
可变的时钟速率：I2C总线支持不同的速率模式，如标准模式（100kbps）、快速模式（400kbps）和高速模式（3.4Mbps）。
同步通信：I2C是一种同步通信协议，数据传输由时钟信号（SCL）来控制。
简单的连接：I2C通信对硬件的要求比较低，很容易在微控制器和外围设备间实现连接。
地址分配：每个I2C设备都通过一个7位或10位的地址来识别，这使得总线上可以连接多个设备。
阻塞传输：I2C支持阻塞传输机制，即主设备可以在传输过程中控制总线，防止其他设备发送数据。
应用广泛：由于其简单和灵活性，I2C被广泛应用于各种电子产品中，如传感器、LCD显示器、EEPROM等。
总线仲裁和冲突检测：在多主模式下，I2C能够处理多个主设备同时尝试控制总线的情况。
低功耗：I2C总线的设计使其成为低功耗的通信方式，适用于电池供电的设备。
基本特征 总线结构： 两线制：使用两条线进行通信，分别是串行数据线（SDA）和串行时钟线（SCL）。多主多从结构：支持多个主设备和多个从设备连接到同一总线上。 通信方式： 同步串行：数据传输同步于时钟信号。字节格式：每个字节由8位数据构成，加上开始和停止条件以及可选的应答位。 时钟速率： 支持多种速率，包括标准模式（100kbps）、快速模式（400kbps）和高速模式（3.4Mbps）。 工作原理 总线控制： 开始和停止条件：通信由主设备通过在SDA线上生成特定的信号模式来开始和结束。地址帧：每次通信开始时，主设备发送一个地址帧来指定与之通信的从设备。 数据传输： 主从通信：主设备控制时钟信号，向从设备发送或接收数据。应答位：每个字节后，接收方 发送一个应答位（ACK）或非应答位（NACK），以告知发送方数据是否被成功接收。
地址和仲裁 设备地址： 7位或10位地址：每个I2C设备都有一个唯一的地址，允许在同一总线上连接多个设备。 总线仲裁： 在多主模式下，当两个主设备同时尝试控制总线时，I2C协议包含仲裁机制以决定哪个设备获得控制权。 3. I2C数据传输流程 数据信号以8位的序列传输。所以在特殊的开始条件发生后，就会出现第一个8位序列，它指示了数据被发送到哪个从设备的地址。每个8位序列之后都会跟随一个称为确认的位。
在大多数情况下，第一个确认位之后会跟着另一个寻址序列，但这次是针对从设备的内部寄存器。在寻址序列之后是数据序列，直到数据完全传输完毕，并以一个特殊的停止条件结束。
开始条件发生在数据线在时钟线仍然高电平的时候变低。之后，时钟开始，并且在每个时钟脉冲期间传输每一位数据。设备寻址序列从最重要的位开始，以最不重要的位结束，实际上是由7位组成的，因为第8位用于指示主设备是向从设备写入（逻辑低）还是从中读取（逻辑高）。
下一个确认位由从设备用来指示它是否成功接收了前一个位序列。所以这次主设备将SDA线的控制权交给从设备，如果从设备成功接收了前一个序列，它将把SDA线拉低到所谓的确认状态。
如果从设备没有把SDA线拉低，这种状态被称为不确认，意味着它没有成功接收前一个序列，这可能由多种原因造成。例如，从设备可能正忙，可能不理解接收到的数据，或者不能再接收任何数据等等。 在这种情况下，主设备决定如何继续操作。
接下来是内部寄存器的寻址。内部寄存器是从设备内存中包含各种信息或数据的位置。
例如，ADXL345加速度计有一个独特的设备地址和额外的内部寄存器地址，用于X、Y和Z轴。 因此，如果我们首先想读取x轴的数据，我们需要发送设备地址，然后发送x轴的特定内部寄存器地址。这些地址可以从传感器的数据手册中找到。
在寻址之后，数据传输序列开始，要么来自主设备，要么来自从设备，这取决于在读/写位选择的模式。
在数据完全发送之后，传输将以停止条件结束，当SDA线在SCL线高电平时从低变高。这就是I2C通信协议的工作原理。
上述内容出现了很多特定概念，我们下面来分别解释他们：
1. SDA和SCL信号 SDA和SCL都是双向线路，通过电流源或上拉电阻连接到正电源电压(见图3)。 当总线空闲时，两条线路都是HIGH。连接到总线的设备的输出级必须具有开漏极或开集电极来执行有线与功能。I2C总线上的数据可以在标准模式下以高达100 kbit/s的速度传输，在快速模式下可达400 kbit/s，在快速模式+中可达1 Mbit/s，或在高速模式下可达3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dee00565f030041b4ffa5b404fdf9697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf88a2ab111e2bfec19e2d2e868a77b/" rel="bookmark">
			关于STM32中的引脚重映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重映射功能 外设引脚重映射的概念，即一个外设的引脚除了具有默认的端口外，还可以通过设置重映射寄存器的方式，把这个外设的引脚映射到其它的端口。
简单的讲就是把管脚的外设功能映射到另一个管脚，但不是可以随便映射的。
部分重映射 &amp; 完全重映射 部分重映射： 功能外设的部分引脚重新映射，还有一部分引脚是原来的默认引脚。完全重映射：功能外设的所有引脚都重新映射。
引脚重映射配置（串口1为例）： ① 使能 GPIO 时钟（重映射后的IO）；
② 使能功能外设时钟（例如串口1）；
③ 使能 AFIO 时钟。重映射必须使能 AFIO 时钟：
RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE)
④ 开启重映射。
GPIO_PinRemapConfig(GPIO_Remap_USART1, ENABLE)
根据第一个参数，来确定是部分重映射还是全部重映射
哪些情况需要开启 AFIO 辅助功能时钟？ 对寄存器AFIO_MAPR，AFIO_EXTICRX 和 AFIO_EVCR 进行读写操作前，应当首先打开 AFIO 时钟。
AFIO_MAPR: 配置复用功能重映射AFIO_EXTICRX: 配置外部中断线映射AFIO_EVCR:配置EVENTOUT 事件输出 个人尝试 本人在尝试过程中发现，即便不开启重映射功能，也可以成功启用重映射引脚，使外设功能正常。但当重映射引脚和默认引脚都使能之后，外设会优先启用默认引脚。当开启重映射功能后，外设则会优先启用重映射引脚。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76484da791aadcd0ee33d5cb7ce51d0b/" rel="bookmark">
			用LED数码显示器循环显示数字0~9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;reg51.h&gt; // 包含51单片机寄存器定义的头文件
/**************************************************
函数功能：延时函数，延时一段时间
***************************************************/
void delay(void) {
unsigned char i,j;
for(i=0;i&lt;255;i++)
for(j=0;j&lt;255;j++)
;
}
/**************************************************
函数功能：主函数
***************************************************/
void main(void)
{
unsigned char i;
unsigned char code Tab[10]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90}; //数码管显示0～9的段码表，程序运行中当数组值不发生变化时，
//前面加关键字code ，可以大大节约单片机的存储空间 P2=0xfe; //P2.0引脚输出低电平，数码显示器DS0接通电源工作
while(1) //无限循环
{
for(i=0;i&lt;10;i++)
{
P0=Tab[i]; //让P0口输出数字的段码92H
delay(); //调用延时函数
}
} }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba3934c50785c23767338d311fc3d2bb/" rel="bookmark">
			x86 和 x64 arm的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		x86和x64是基于英特尔x86架构的复杂指令集架构（ISA），而ARM是一种精简指令集架构。
什么是指令集架构 假设我们现在要开发一个cpu，就好比说我们去修建一栋楼，开发商会先将图纸设计好。设计好之后由施工单位按照设计图去建造。在建造的这个过程中，施工方是要按照国家一定的规范来设计的，比如每层楼的高度，窗户的大小，排水管大小以及消防通道的设置等，这个设计规范对于这栋楼（CPU）来说就是指令集架构。
指令集架构就是机器的语言，包含了各种各样的指令，像我们常见的x86个arm就是两个不同的指令集架构。
像是Intel(英特尔)和amd都是采用x86指令级架构，而手机平板等才用的大多就是ARM指令集架构
X86与X64 x86架构最早可以追溯到1978年，当时英特尔推出了8086处理器。随后，英特尔发布了多个后续版本的处理器，如80286、80386、80486等，也被称为x86家族。在这些处理器中，后缀数字表示处理器的不同版本和功能。
位数：x86是32位的处理器架构，而x64是64位的处理器架构。这意味着x64可以处理更大的数据块和内存地址空间，从而可以更高效地处理大型应用程序、多任务处理和大量数据。
寄存器数量：x86处理器有8个通用寄存器，而x64处理器有16个通用寄存器。这意味着x64能够更高效地管理和处理数据，并且可以提供更好的性能和吞吐量。
内存支持：x86处理器最多只能支持4GB的内存，而x64处理器可以支持更大的内存容量，最多能够支持16EB（exabyte）的内存。
软件兼容性：x64处理器可以运行原本为x86编写的大多数软件，但反之则不一定成立。因为x86软件是为32位处理器编写的，而x64处理器是64位的，所以一些旧的x86软件可能无法在x64处理器上正常运行。
区别 架构：x86和x64架构主要用于个人电脑和服务器，而ARM架构主要用于移动设备（如智能手机、平板电脑）和嵌入式系统（如物联网设备）。
指令集：x86和x64使用复杂指令集计算机（CISC）指令集，其中包含大量的指令和寄存器。而ARM使用精简指令集计算机（RISC）指令集，指令数量较少但执行效率高。
性能和功耗：x86架构在处理器性能方面通常比ARM架构更强大，因为它们具有更多的指令和寄存器。然而，ARM架构在功耗效率方面表现更好，适合于低功耗设备。
软件兼容性：由于x86架构在个人电脑上的广泛使用，许多软件和操作系统都是针对x86架构进行优化的。而ARM架构则需要专门编译和优化软件，以确保与其兼容。
扩展性：x64架构支持更大的内存地址空间和更多的寄存器，可以处理更大规模的数据。ARM架构的扩展性较弱，但它在功耗和成本方面更具优势。
需要注意的是，x86和x64是基于英特尔的x86架构发展而来的，而ARM则是基于ARM架构发展而来的。不同的处理器和芯片制造商可能会在x86和ARM架构上进行定制和优化，因此具体的性能和特性可能会有所不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bfc63558cd6666da23d5b5d80220fd2/" rel="bookmark">
			015-信息打点-主机架构&amp;蜜罐识别&amp;WAF识别&amp;端口扫描&amp;协议识别&amp;服务安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		015-信息打点-主机架构&amp;蜜罐识别&amp;WAF识别&amp;端口扫描&amp;协议识别&amp;服务安全 #知识点： 1、端口扫描-应用&amp;协议
2、WAF识别-分类&amp;识别
3、蜜罐识别-分类&amp;识别
解决：
1、Web服务器&amp;应用服务器差异性
2、WAF防火墙&amp;安全防护&amp;识别技术
3、蜜罐平台&amp;安全防护&amp;识别技术
#补充： 开发语言：PHP、JAVA、Ruby、Python、C#，JS等
Web服务器：Apache、Nginx、IIS、lighttpd等
应用服务器：Tomcat、Jboss、Weblogic、Websphere等
数据库类型：Mysql、SqlServer、Oracle、Redis、MongoDB等
操作系统信息：Linux、windows等
应用服务信息：FTP、SSH、RDP、SMB、SMTP、LDAP、Rsync等
CDN信息：帝联、Cloudflare、网宿、七牛云、阿里云等
WAF信息：创宇盾、宝塔、ModSecurity、玄武盾、OpenRASP等。
蜜罐信息：HFish、TeaPot、T-Pot、Glastopf等
其他组件信息：fastjson、shiro、log4j、OA办公等
端口服务渗透用途tcp 20,21FTP允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4)tcp 22SSH可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输等等tcp 23Telnet爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令tcp 25SMTP邮件伪造,vrfy/expn查询邮件用户信息,可使用smtp-user-enum工具来自动跑tcp/udp 53DNS允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控tcp/udp 69TFTP尝试下载目标及其的各类重要配置文件tcp 80-89,443,8440-8450,8080-8089各种常用的Web服务端口可尝试经典的topn,vpn,owa,webmail,目标oa,各类Java控制台,各类服务器Web管理面板,各类Web中间件漏洞利用,各类Web框架漏洞利用等等……tcp 110POP3可尝试爆破,嗅探tcp 111,2049NFS权限配置不当tcp 137,139,445Samba可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等……tcp 143IMAP可尝试爆破udp 161SNMP爆破默认团队字符串,搜集目标内网信息tcp 389LDAPldap注入,允许匿名访问,弱口令tcp 512,513,514Linux rexec可爆破,rlogin登陆tcp 873Rsync匿名访问,文件上传tcp 1194OpenVPN想办法钓VPN账号,进内网tcp 1352Lotus弱口令,信息泄漏,爆破tcp 1433SQL Server注入,提权,sa弱口令,爆破tcp 1521Oracletns爆破,注入,弹shell…tcp 1500ISPmanager弱口令tcp 1723PPTP爆破,想办法钓VPN账号,进内网tcp 2082,2083cPanel弱口令tcp 2181ZooKeeper未授权访问tcp 2601,2604Zebra默认密码zerbratcp 3128Squid弱口令tcp 3312,3311kangle弱口令tcp 3306MySQL注入,提权,爆破tcp 3389Windows rdpshift后门[需要03以下的系统],爆破,ms12-020tcp 3690SVNsvn泄露,未授权访问tcp 4848GlassFish弱口令tcp 5000Sybase/DB2爆破,注入tcp 5432PostgreSQL爆破,注入,弱口令tcp 5900,5901,5902VNC弱口令爆破tcp 5984CouchDB未授权导致的任意指令执行tcp 6379Redis可尝试未授权访问,弱口令爆破tcp 7001,7002WebLogicJava反序列化,弱口令tcp 7778Kloxo主机面板登录tcp 8000Ajenti弱口令tcp 8009tomcat AjpTomcat-Ajp协议漏洞tcp 8443Plesk弱口令tcp 8069Zabbix远程执行,SQL注入tcp 8080-8089Jenkins,JBoss反序列化,控制台弱口令tcp 9080-9081,9090WebSphereJava反序列化/弱口令tcp 9200,9300ElasticSearch远程执行tcp 11211Memcached未授权访问tcp 27017,27018MongoDB爆破,未授权访问tcp 50070,50030Hadoop默认端口未授权访问 蜜罐Quake系统搜索语法STRUTSHONEYPOTapp:“StrutsHoneypot”CONPOT HTTP 蜜罐app:“Conpot Http 蜜罐”CONPOT MODBUS 蜜罐app:“Conpot modbus 蜜罐”CONPOT S7 蜜罐app:“Conpot s7 蜜罐”KIPPO 蜜罐app:“kippo 蜜罐”HONEYPY HTTP 蜜罐app:“Honeypy Http 蜜罐”HONEYPY ES蜜罐app:“Honeypy ES蜜罐”AMUN IMAP 蜜罐app:“amun imap 蜜罐”AMUN HTTP蜜罐app:“amun http蜜罐”NEPENTHES NETBIOS蜜罐app:“Nepenthes netbios蜜罐”NEPENTHES FTP 蜜罐app:“Nepenthes FTP 蜜罐”SSHESAME SSH 蜜罐app:“sshesame ssh 蜜罐”OPENCANARY蜜罐管理后台app:“opencanary蜜罐管理后台”DIONAEA SIPD 蜜罐app:“Dionaea sipd 蜜罐”DIONAEA SMBD 蜜罐app:“Dionaea smbd 蜜罐”DIONAEA HTTP 蜜罐app:“Dionaea Http 蜜罐”DIONAEA MSSQL 蜜罐app:“Dionaea MSSQL 蜜罐”DIONAEA FTP 蜜罐app:“Dionaea ftp 蜜罐”DIONAEA MEMCACHED 蜜罐app:“Dionaea Memcached 蜜罐”KOJONEY SSH 蜜罐app:“Kojoney SSH 蜜罐”WEBLOGIC蜜罐app:“weblogic蜜罐”MYSQL蜜罐app:“MySQL蜜罐”HFISH蜜罐app:“HFish蜜罐”HFISH蜜罐管理后台app:“HFish蜜罐管理后台”HONEYTHING物联网蜜罐app:“honeything物联网蜜罐”ELASTICSEARCH蜜罐app:“elasticsearch蜜罐”HOSTUS蜜罐app:“HostUS蜜罐”WHOISSCANME蜜罐app:“whoisscanme蜜罐”未知蜜罐app:“未知蜜罐”COWRIE TELNETD蜜罐app:“Cowrie telnetd蜜罐”GLASTOPF蜜罐app:“glastopf蜜罐” 演示案例： ➢识别-Web服务器-请求返回包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bfc63558cd6666da23d5b5d80220fd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ccad47b245698963d4344bfa4bdcf0/" rel="bookmark">
			vue3中reactive和ref函数及对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Vue 3中，reactive和ref都是用于创建响应式数据的方法。
ref函数接收一个参数，返回一个包装过的响应式对象。它可以将基本类型数据（如数字、字符串等）转换为响应式对象，以及将对象字面量转换为响应式对象。
import { ref } from 'vue' const count = ref(0) console.log(count.value) // 输出：0 count.value++ console.log(count.value) // 输出：1 reactive函数接收一个参数，返回一个响应式代理对象。它可以将普通对象转换为响应式对象，并且可以对对象的所有属性进行响应式处理。
import { reactive } from 'vue' const state = reactive({ count: 0 }) console.log(state.count) // 输出：0 state.count++ console.log(state.count) // 输出：1 在使用上的区别：
ref返回的是一个具有value属性的对象，需要通过.value来访问和修改值。而reactive返回的是一个普通对象，可以直接访问和修改对象的属性。ref适合用于包装基本类型数据和对象字面量，而reactive适合用于包装普通对象。reactive可以对对象的所有属性进行响应式处理，而ref只能对自身的值进行响应式处理。 在使用上的选择：
如果需要包装基本类型数据或对象字面量，或者只需要包装一个简单的值，可以使用ref。如果需要包装一个普通对象，或者需要对对象的属性进行响应式处理，可以使用reactive。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bded7344fd510e2effad24cfd500a74/" rel="bookmark">
			synchronized的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.synchronized的介绍和作用 synchronized是Java编程语言中的一个关键字，用于实现线程同步。在多线程编程中，多个线程可能同时访问共享资源，而这可能导致数据不一致或其他问题。为了避免这些问题，可以使用 synchronized 关键字来确保在任何时候只有一个线程可以访问共享资源。
使用synchronized就是为了保证线程的三个特性，及原子性、可见性、有序性。原子性：一个或多个操作时，保证要么全部执行成功，要么都不执行。可见性：一个线程操作时，另外的线程可以看见，里面的数据变化情况能看见。有序性：线程安装顺序进行操作。使用锁就是为了保证线程的安全。
2.synchronized的使用 public synchronized void lock(){ //方法 } ​ public void lock() { // 一些非关键代码 ​ synchronized (lockObject) { // 需要同步的代码块 } ​ // 一些非关键代码 } synchronized可以修饰静态方法、成员函数，同时还可以直接定义代码块。
3.synchronized的底层实现 在Java虚拟机（JVM）中，对象的内存结构主要分为三部分：对象头、实例数据、对齐填充。
对象头：
存储对象自身的运行时数据，比如哈希码、垃圾回收信息、同步锁等。
不同的虚拟机实现会在对象头中存储不同的信息，例如，在HotSpot虚拟机中，对象头占用的空间大小是与平台相关的。
实例数据：
存储对象的实际数据，即类的字段内容。
对于数组类型的对象，还包括数组长度等信息。
实例数据的大小取决于对象所属的类的字段定义。
对齐填充：
由于虚拟机的内存分配规则，对象的大小通常要求是8字节的整数倍。
对齐填充用于填充对象的实例数据，以满足对齐要求，使得对象的起始地址是8字节的整数倍。
对齐填充不包含实际的数据，仅仅是为了对齐。
对象头中Mark Word是重点
监视器（Monitor）图：借图
这个是获取Monitor和释放Monitor的流程。
在jdk1.6之前synchronized被称为重量级锁，在jdk1.6之后，进行了优化，引入了偏向锁和轻量锁。
4.synchronized的优化 4.1偏向锁 原理：
当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的MarkWord之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。 好处：
偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以提高带有同步但无竞争的程序性能。 4.2轻量级锁 原理：
将对象的Mark Word复制到栈帧中的Lock Recod中。Mark Word更新为指向Lock Record的指针。 好处：
在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。 4.3自旋锁和自适应自旋锁 轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。 ​ 自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。 ​ 自适应自旋锁：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。 参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bded7344fd510e2effad24cfd500a74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5754919a42f17f46336dfa7590c93016/" rel="bookmark">
			198. 打家劫舍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		198. 打家劫舍 原题链接：完成情况：参考代码：_198打家劫舍_198打家劫舍_滚动优化_198打家劫舍_滚动数组 错误经验吸取 原题链接： 198. 打家劫舍
https://leetcode.cn/problems/house-robber/description/
完成情况： 参考代码： _198打家劫舍 package 代码随想录.动态规划; public class _198打家劫舍 { /** * * @param nums * @return */ public int rob(int[] nums) { // TODO 每次偷窃后，必须至少冷却一天，问多大头去数量数多少 if(nums == null || nums.length == 0){ return 0; } if (nums.length == 1) { return nums[0]; } //有多个时，才需要使用到dp int [] dp = new int[nums.length]; //模拟出取每一个长度位置时的最大累计和 dp[0] = nums[0]; dp[1] = Math.max(dp[0],nums[1]); for (int i=2;i&lt; nums.length;i++){ dp[i] = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5754919a42f17f46336dfa7590c93016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b23bfbaa846e099c1f706fd2e0bbc76c/" rel="bookmark">
			rabbitmq的介绍、使用、案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 rabbitmq简单来说就是个消息中间件，可以让不同的应用程序之间进行异步的通信，通过消息传递来实现解耦和分布式处理。
消息队列：允许将消息发到队列，然后进行取出、处理等操作，使得生产者和消费者之间能够解耦，异步地进行通信。
持久性，可靠性的消息传递机制。
2.安装rabbitmq 2.1新建文件夹 [root@localhost local]# mkdir rabbitmq [root@localhost rabbitmq]# mkdir data 新建一个rabbitmq的文件夹，然后在rabbitmq文件夹下新建一个data的文件夹。data文件夹用来挂载rabbitmq内部文件，然后用来存储数据。
2.2查看rabbitmq的镜像 [root@localhost rabbitmq]# docker search rabbitmq 然后就可以下载官方的rabbitmq了。
2.3下载rabbitmq镜像 [root@localhost rabbitmq]# docker pull rabbitmq 下载镜像 [root@localhost rabbitmq]# docker images 查看镜像 下载好之后就可以查看下镜像，这样最新的rabbitmq就已经下载成功了，下一步就是创建容器了。
2.4创建rabbitmq容器 docker run -it \ --name rabbitmq \ --network wn_docker_net \ --ip 172.18.12.20 \ -v /etc/localtime:/etc/localtime \ -v /usr/local/software/rabbitmq/data:/var/lib/rabbitmq \ -e RABBITMQ_DEFAULT_USER=admin \ -e RABBITMQ_DEFAULT_PASS=123 \ -p 15672:15672 \ -p 5672:5672 \ -d rabbitmq --network,--ip自己设置的网络ip。可以查看下自己的ip是多少。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b23bfbaa846e099c1f706fd2e0bbc76c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de2f9a27884872e531a4da9ba74ed37/" rel="bookmark">
			【已解决】namespace “Ui“没有成员 xxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说笔者遇到的问题，我创建一个QWidget ui文件，然后编辑的七七八八后，想要用.h与.cpp调用其，编译通过，结果报了这个错误，本方法不是普适性，但是确实解决了这个鸟问题。
问题来源 搭建ui后，出现了namespace “UI” 没有成员 xxx
问题解决方案 先搜索工程文件是否有ui_xxxx文件，很重要看自己的UI里的QWidget是否叫xxx，这个要与下面同名 总结 就是这样，图片上一定要与调用同名，不然不通过。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/347fcb53b80cae75f278dec0b38ed47b/" rel="bookmark">
			基于SpringBoot实现策略模式提供系统接口扩展能力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信我们对策略模式都有耳闻，但是可能不知道它在项目中具体能有什么作用，我们需要在什么场景下才能去尽可能得去使用策略模式。
这里我简单的列出一个我之前在公司做的一个需求：跟第三方oa系统对接接口，对方需要回调我们当前系统，但是是不同的业务接口回调，我们系统可以根据一个字段来区分需要走哪个业务分支，可能初级程序员刚接触这个需求的时候想法是，多个接口回调，那就写多个接口罢了，强调接口隔离；或者直接一个接口也行，if...else if 也很不错，这里呢，为了彰显我们开发人员的逼格，我们可以基于一个接口外加设计模式之策略模式+简单工厂模式。 下面是一个简单的实现demo：
首先是我们定义一个接口即起路由作用，我们具体的不同业务实现类来实现这个接口就可以；
public interface CalculationStrategy { * 策略接口 */ int operate(int num1, int num2); } @Component("add") class AddCalculationStrategyImpl implements CalculationStrategy { @Override public int operate(int num1, int num2) { return num1 + num2; } } @Component("Division") class DivisionStrategyImpl implements CalculationStrategy { @Override public int operate(int num1, int num2) { return num1 / num2; } } @Component("multiple") class MultiplicationStrategyImpl implements CalculationStrategy { @Override public int operate(int num1, int num2) { return num1 * num2; } } @Component("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/347fcb53b80cae75f278dec0b38ed47b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8075fa6234bc412bd6428b9821a5e9f4/" rel="bookmark">
			freeswitch on centos dockerfile模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 freeswitch是一款简单好用的VOIP开源软交换平台。
centos7 docker上编译安装fs的流程记录，本文使用dockerfile模式。
环境 docker engine：Version 24.0.6
centos docker：7
freeswitch：v1.6.20
dockerfile 创建空目录，创建dockerfile文件。
github访问经常失败，先下载好源码包，并将fs.1.6.20源码文件夹拷贝到目录下。
mkdir centos.7-fs.1.6.20
cd centos.7-fs.1.6.20
ls
dockerfile freeswitch-1.6.20
dockerfile文件内容如下。
vi dockerfile
FROM centos:7
WORKDIR /root
ADD ./freeswitch-1.6.20 /root/freeswitch
RUN cd /root/ \
&amp;&amp; yum -y update \
&amp;&amp; echo "signalwireusername" &gt; /etc/yum/vars/signalwireusername \
&amp;&amp; echo "pat_signalwiretoken" &gt; /etc/yum/vars/signalwiretoken \
&amp;&amp; yum install -y https://$(&lt; /etc/yum/vars/signalwireusername):$(&lt; /etc/yum/vars/signalwiretoken)@freeswitch.signalwire.com/repo/yum/centos-release/freeswitch-release-repo-0-1.noarch.rpm \
&amp;&amp; yum install -y epel-release \
&amp;&amp; yum install -y autoconf automake libtool gcc-c++ ncurses-devel make zlib-devel libjpeg-devel yasm nasm libevent libevent-devel \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8075fa6234bc412bd6428b9821a5e9f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a4a1a130cef42fbfe45aa6181b6fd1/" rel="bookmark">
			K8s知识点总结_part1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes 是什么 为用户提供一个具有普遍意义的容器编排工具。
它着重解决的问题是：大规模集群中的各种运行任务之间的关系处理，这些关系的处理，是作业编排和管理系统最困难的地方。
其能力有：
• 基于容器的应用部署、维护和滚动升级
• 负载均衡和服务发现
• 跨机器和跨地区的集群调度
• 自动伸缩
• 无状态服务和有状态服务
• 插件机制保证扩展性
K8S设计思想 从一开始，Kubernetes 项目就没有像同时期的各种“容器云”项目那样，把 Docker 作为整个架构的核心，而仅仅把它作为最底层的一个容器运行时实现。
它真正的价值，在于提供了一套基于容器构建分布式系统的基础依赖。这也是k8s能长久发展的一个原因。
可以从这四个方面了解一下：
可扩展性：
• 基于微服务部署应用
• 横向扩容缩容
• 自动扩容缩容
高可用：
• 基于replicaset，statefulset 的应用高可用
• Kubernetes 组件本身高可用
可移植性：
• 多种 host Os 选择
• 多种基础架构的选择
• 基于集群联邦建立混合云
安全：
• 基于 TLS 提供服务
• Serviceaccount 和 user
• 基于 namespace 的隔离
• secret
• Taints，psp，networkpolicy
K8S的优势 优势特点，主要是这8个层面：
资源利用：高效率/高密度
低耦合：松散耦合、分布式、弹性、解放的微服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a4a1a130cef42fbfe45aa6181b6fd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd37b460e0e90fe5cdbe775a343f67c/" rel="bookmark">
			时间格式 yyyyMMdd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 转换时间格式 yyyyMMdd export function dateFn(date) { var time=new Date(date); var year= time.getFullYear() //年 var month = ("0" + (time.getMonth() + 1)).slice(-2); //月 var day = ("0" + time.getDate()).slice(-2); //日 var mydate = year + month + day; return mydate } import {dateFn} from "../util/base.js"; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab24e868d07de7598c8ccd6e5ec6709/" rel="bookmark">
			12- OpenCV：算子(Sobel和Laplance) 和Canny边缘检测 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Sobel算子
1、卷积应用-图像边缘提取
2、Sobel算子（索贝尔算子）
3、相关的API（代码例子）
二、Laplance算子
1、理论
2、API使用（代码例子）
三、Canny边缘检测
1、Canny算法介绍
2、API使用（代码例子）
一、Sobel算子 1、卷积应用-图像边缘提取 在这个红点变化最大，变化率很高的，梯度也是最陡。变化率做成一根曲线，所以变化率最大的就在顶点。
（1）边缘是什么 ：是像素值发生跃迁的地方，是图像的显著特征之一，在图像特征提取、对象检测、模式识别等方面都有重要的作用。
（2）如何捕捉/提取边缘 – 对图像求它的一阶导数 delta = f(x) – f(x-1), delta越大，说明像素在X方向变化越大，边缘信号越强，
（3）用Sobel算子就好！卷积操作！
2、Sobel算子（索贝尔算子） （1）是离散微分算子（discrete differentiation operator），用来计算图像灰度的近似梯度；
（2）Soble算子功能集合高斯平滑和微分求导；
（3）又被称为一阶微分算子，求导算子，在水平和垂直两个方向上求导，得到图像X方法与Y方向梯度图像；
（4）求取导数的近似值，kernel=3时不是很准确，OpenCV使用改进版本Scharr函数，算子如下：放大了权重，差异性更加大了，不过也更加准确些。
3、相关的API（代码例子） （1）cv_Sobel函数原型
cv::Sobel (
InputArray Src // 输入图像
OutputArray dst// 输出图像，大小与输入图像一致
int depth // 输出图像深度.
int dx. // X方向，几阶导数
int dy // Y方向，几阶导数.
int ksize, SOBEL算子kernel大小，必须是奇数，1、3、5、7，一般是3
double scale = 1
double delta = 0
int borderType = BORDER_DEFAULT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab24e868d07de7598c8ccd6e5ec6709/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5525fc4107219c6a56edd5036c2c2d05/" rel="bookmark">
			Android_Error_AS启动失败_UI initialization failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
com.intellij.ide.plugins.StartupAbortedException: UI initialization failed 原因：找不到jre（我也不知道它和UI初始化有啥关系，如果你知道，可以评论区告诉我一下）
解决：
找到该AS对应的studio64.exe.jdk文件
目录：~\AppData\Roaming\Google{AndroidStudio}
打开该文件（我用记事本打开的），将jdk路径修改为该AS路径下的jre路径
原路径：
修改为： 红线画出的是该AS的安装路径，图中是默认的安装路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/156f6c1cf1545a4103db6e3f935a13ab/" rel="bookmark">
			3D视觉专用名词概念解释，深度图、点云图、IR图、RGB图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌞欢迎来到深度学习的世界 🌈博客主页：卿云阁
💌欢迎关注🎉点赞👍收藏⭐️留言📝
🌟本文由卿云阁原创！
🙏作者水平很有限，如果发现错误，请留言轰炸哦！万分感谢！
1. 深度图 深度图中的单个像素值是空间中物体的某个点到垂直于左红外镜头光轴并通过镜头光心（深度相机光学零点）平面的垂直距离。
深度图是深度相机视野内所有点的深度数据构成的矩阵。深度图是一个16bit位深的单通道矩阵，单位为毫米。没有深度信息的点值为0。为直观的体现不同距离数值，在SDK提供的sample程序中，输出的深度图均被映射到了RGB色彩空间，所以显示出来的结果为RGB三通道8bit位深的位图，深度数据无外参，无畸变，只能提供用于转换点云数据的内参。
2.点云图
通过深度相机得到的物体外观表面的点数据集合是点云。使用深度相机得到的点云信息为三维坐标（X，Y，Z）。点云图是深度相机捕捉到的所有点的点云信息构成的数据矩阵。每点为3个float类型x,y,z值。没有三维空间信息的点为（0，0，0）。
点云图数据格式。
3. IR图 IR图像为红外图像传感器输出的红外图像。在输出深度图的时候，部分型号的相机输出的IR图像是被系统处理过的图像，如果需要看原始的IR图像，需要关闭深度图像输出。关闭深度图像输出后，激光投射器也会自动关闭。如果需要打开激光器，需主动调用SDK API关闭激光器的自动控制功能，并且设置激光机强度，才能看到正常的红外图像传感器图像。IR图像分为左IR图和右IR图，二者均包含内参和畸变参数，但是因为左IR和深度图是同一个空间坐标系，所以左IR图像无外参。
4. RGB图像 不同型号的Percipio相机会输出不同数据类型的RGB图像。其中一类RGB图像传感器含有硬件ISP模块，输出机为正常的YUV422/JPG图像，经OPENCV处理即可显示为RGB图像。另一类RGB图像传感器没有硬件ISP模块，输出的raw bayer图像数据显示为图像时，画面颜色”偏绿”，经过SDK的软件ISP处理（如白平衡），才可以显示为正常色彩空间的RGB图像; 没有硬件ISP模块的RGB图像传感器可以确保输出的图像数据与IR图像数据同步。RGB图像传感器组件提供了内参，外参数，畸变参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69220d7c80c8da31c1b2eb97a4d31705/" rel="bookmark">
			Android_工具_隐私合规检测_camille
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前期准备使用步骤常见问题 基于frida的 Android App 隐私合规检测工具 前期准备 安装python3环境
安装frida
git仓库：GitHub - frida/frida: Clone this repo to build Frida
因为上一步已经安装了python3，所以可以通过pip之间安装
# 安装frida pip install frida # 安装frida-tools pip install frida-tools # 查看版本，已检验自己是否成功安装 frida --version 从Release Frida 16.1.4 · frida/frida · GitHub下载符合设备cpu和自己安装的frida版本的frida-server
安装camille
git仓库：GitHub - zhengjim/camille: 基于Frida的Android App隐私合规检测辅助工具
# 下载git仓库 git clone https://github.com/zhengjim/camille.git # 切换到根目录 cd camille # 使用pip命令安装 pip install -r requirements.txt 使用步骤 将待测app安装到设备
设备打开root权限，虚拟机一般都可以
必须打开root权限，后续才能启动frida服务
# 切换root adb shell su 将 frida-server 推送到设备，并启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69220d7c80c8da31c1b2eb97a4d31705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2d15413e00981399fd4c93cbac1f89/" rel="bookmark">
			多模态融合的基础问题及算法研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌞欢迎来到深度学习的世界 🌈博客主页：卿云阁
💌欢迎关注🎉点赞👍收藏⭐️留言📝
🌟本文由卿云阁原创！
🙏作者水平很有限，如果发现错误，请留言轰炸哦！万分感谢！
Illuminating the dark spaces of healthcare with ambient intelligence (nature.com)
上面的论文是李飞飞，发表的nature上的一篇文章。
数据维度越来越高，数据种类越来越多 ，上图一共展示了5种传感器，如果只根据一个图像，比如第一个图像，很难分析出其中又多少个人，如果我们用第三幅的话，第三幅是热感图像，就可比较容易的看出有哪些人，还有一些其它的传感器，比如深度传感器，声音传感器，运用多元传感器就可以更好的感知。
下图是其设想的一个图，我们有了多维的数据之后就可以多模态融合，就可以进行一些下游的任务，最简单的比如分类任务，可以分析当前病房是在护理还是在进行其它活动。
多视图机器学习是多源信息融合的关键技术基础，其研究水平直接关系到人工智能在众多重要领域的应用效果。常见的多模态数据集
多模态医学图像数据集_跨模态医学图像数据集-CSDN博客
多模态融合的主要目标：利用多源信息有效发现潜在模式，多视图往往可以为数据分析任务提供更为充分的信息进行模式识别，分类，聚类本质上，得到真正的数据，我们得到的数据分布方法是不同视图的。
多模态数据融合策略，首先就是一致性，互补性，兼容性。
互补性 主动增强 兼容性
每一列代表一个样本，每一行代表一个模态，黑色代表丢掉一个模态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3c278a1c451405558e1b09859984db/" rel="bookmark">
			flutter使用扫码枪扫码输入时候有英文字符导致联想输入结果出错的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用flutter获取扫码内容的时候，如果二维码内容包含字母或者汉字就会导致系统键盘联想输入法，导致获取到的结果并不是二维码里面包含的内容，理论上禁止掉系统键盘的联想输入就可以了，但是flutter的 TextField组件没有这个能力，即便你使用密码输入框的形式，还是会勾起搜狗输入法的联想输入，这个无解，如果在前端页面上使用input密码框就可以解决，但是在flutter上很难，看了源代码也无解。
&lt;input type="password" id="myInput" /&gt; 在github上看了issue的问题：https://github.com/flutter/flutter/issues/129113
里面说的2023年6月提的一个issue，现在还没有解决，所以没办法了，只能使用别的解决方案了。
即便是使用了scan_gun这个库，也会出现这个问题，即便你将keyboardType: TextInputType.visiblePassword也不行，你可以看作者的这篇文章：flutter：扫码枪获取数据源（方案多平台适用） - 掘金
解决方案思路 1.二维码内容只使用纯数字
二维码内容设置为只包含纯数字的内容，然后再使用扫描仪扫描，这样的话就不回有问题了：
2.使用c++封装一个库
使用c++或者c或者别的语言封装一个工具库，然后在flutter中调用。
3.设置系统键盘为纯英文
通过一种方式将系统键盘设置为纯英文，你手动设置或者通过程序设置也行，只要设置会纯英文，就可以。
4.引入html和js的密码框
html和js获取二维码内容的方式大概有三种方式可用：无侵入式，隐藏输入框，还能触发输入监听事件的方式。隐藏输入框的方式：聊聊 CSS 隐藏元素的 10 种实用方法 - 知乎
然后使用flutter引入这个html，最后再使用flutter和js通讯:
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myInput { /* opacity 会在页面中占位 */ /* opacity: 0; */ /* 将元素移出dom页面 */ /* transform: translate(-9999px); */ /* 将元素设置为0 */ height: 0; width: 0; padding: 0; margin: 0; border: none; overflow: hidden; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f3c278a1c451405558e1b09859984db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3b206a648556d8ba525ce5307f0d6f7/" rel="bookmark">
			提速40%！江波龙推出XP2200系列M.2 2280规格SSD：疾速7100MB/s
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		江波龙FORESEE XP2200系列PCIe SSD推出M.2 2280规格。 产品搭载主流232层3D TLC闪存颗粒，并采用基于12nm工艺的4通道高性能主控芯片，支持HMB主机高速缓冲技术，能够提供高达2400MT/s的I/O速率，进一步释放产品潜能。
产品所用的主控芯片减少了一半的读写通道数量，从而显著降低25%的功耗并减少发热量，让该产品的整体功耗低至4W，能够有效延长智能终端的续航时间。
凭借先进的颗粒与制程工艺，XP2200系列产品容量可达2TB(即将推出4TB)，读写速度最高可达7100MB/s和6700MB/s，接近PCIe Gen4×4通道的饱和性能。相较于上一代XP2100系列旗舰级SSD，XP2200读写性能提升了近40%。
FORESEE XP2200 PCIe SSD(M.2 2280)主要应用于2 in 1电脑、超薄笔记本、电竞游戏主机、PS5主机扩展盘等设备，其出色的传输性能和能效比将成为智能终端的理想选择。
其采用江波龙自研固件，支持以下功能：
智能温控功能
在SSD运行过程中，随着温度的升高，性能表现会大打折扣。为避免这种情况，FORESEE XP2200 PCIe SSD(M.2 2280)采用了先进的散热设计和材料，并配备智能温控功能(Thermal Throttling)，该功能可根据设备温度自动调节工作负载，以保持稳定的读写速度和可靠性。
RAID保护功能
产品还支持定制强大的RAID功能，让用户可根据实际需求调整SSD的配置方式。一方面，RAID功能可以显著提高读写速度和数据传输速率，满足高强度的工作负载需求；另一方面，该功能可以增加数据的冗余性，确保数据的完整性和可靠性。
安全擦除功能
产品还可提供安全擦除功能(Secure Erase)，这种高级数据删除技术可以彻底清除SSD上的所有数据，包括所有存储在设备中的数据和元数据。该功能保障用户在执行安全擦除操作时，数据不会被任何未经授权的人员访问或恢复，配合高强度的密钥管理SM4加密算法，能够确保用户数据安全并符合不同国家及地区的相关法规要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2202272a87019a6e401013a9992f503/" rel="bookmark">
			记录一次完整的微信小程序&#43;反编译&#43;AES加、解密爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工具 1、反编译工具：wecgatMiniAppReverse.zip（链接：微信小程序-反编译工具 (0积分下载)）
ps:(编译不成功，可以使用此工具：unveril2.0反编译工具（0积分下载）)
2、安装 nodejs并配置全局变量
3、微信小程序开发者工具（链接：微信开发者工具链接）
找稳定版下载（我的环境是 win10）：
二、解密小程序 1、登录PC端微信，找到目标小程序打开后可关闭，目的是为了小程序源码包下载缓存至本地：
2、点击打开文件夹：
3、点击进来后，有对应的小程序缓存，类似于 “wxd418ee346d79d382”就是打开过的小程序的id。按照路径找到加密过的文件 "__APP__.wxapkg"：
4、解密该文件
4.1、首先 cmd 命令进入解密工具文件夹
4.2、为了方便，把需要解密的文件复制到同一目录下 “wxd418ee346d79d382”
4.3、输入命令格式：pc_wxapkg_decrypt.exe -wxid 微信小程序id -in 要解密的wxapkg路径
本示例命令：pc_wxapkg_decrypt.exe -wxid wxd418ee346d79d382 -in wxd418ee346d79d382\450\__APP__.wxapkg
4.4、提示解密成功，得到 “”dec.wxapkg“”
注意：路径中不要带空格，比如 “Program File”
三、反编译小程序 1、cmd命令进入 “”wxappUnpacker-master“”路径
2、执行命令，反编译解密的文件 “dec.wxapkg”：node wuWxapkg.js ..\decrypt\dec.wxapkg
3、 命令结束后，会在 “”../decrypt “” 目录下生成一个 “dec” 文件夹，里面就是反编译小程序的源码。ps：（复杂的小程序，不会100%完全编译出来）
4、反编译结果如下，用微信开发者工具打开。
点击确定，就可以愉（苦）快（逼）的逆向了。
四、开始逆向分析 1、Fiddler抓包分析 2、关键词查找 1、根据接口的特征搜索，比如 headers、post body 等等。
2、可以直接一套组合拳：“AES（decrypt\encrypt）、MD5、Base64”等等 查看此处
3、若是对小程序开发流程很熟悉的人，可以根据代码入口查看。
检索结果，非常熟悉的加、解密方法。
3、AES加密、解密转换成python代码 1、首先需要找到 秘钥（u）、偏移量（l）。按住ctrl键，找到定义位置。
注意：是用pkcs7方式补齐数据的。
import json from Crypto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2202272a87019a6e401013a9992f503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862e910635a22f2439b6847203ea2a2f/" rel="bookmark">
			央国企数字化转型的“压舱石”与“新方略”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、央国企数字化转型背景 根据国资委公布的数据，2022年中央企业在主要行业和关键领域的经营数据表现亮眼。全年累计实现营业收入39.4万亿元，同比增长8.3%；实现利润总额2.55万亿元、净利润1.9万亿元，同比分别增长5.5%和5%。研发投入持续增长，同比增速为9.8%，研发经费投入强度同比提升。
作为国民经济的支柱和中坚力量，央国企在关系国家安全和国民经济命脉的主要行业和关键领域占据主导地位。然而，随着国内外经营环境的变化，央国企正面临着诸多挑战与机遇。
一方面，我国GDP增长趋于温和，逐步驶入存量经济时代。同时，中美贸易摩擦和新冠疫情的影响使得国际宏观环境不确定性保持高位。另一方面，科学技术发展日新月异，数字技术在我国发展迅速，以5G、云计算、大数据、物联网、低代码、人工智能和区块链为代表的新ICT技术引发了经济、生活的巨大变化。
在这样的背景下，央国企作为国民经济的“压舱石”，肩负着更多的使命责任，在百年未有的大变局中担当科技创新的主力军，承接国家十四五战略规划，响应国家新要求、新方略，将数字化转型融入企业发展的各个方面，不断对标具有前瞻性、先进性的国际一流企业，成为推动数字化转型的排头兵。
二、央国企数字化转型难点 在数字经济时代，央国企面临着前所未有的压力，仅从经营管理方面就存在诸多亟待解决的痛点。
1、前瞻性战略管理理念不足
央国企在制定战略业务规划等重大决策时，主观性强，缺乏全面、及时和准确的一线数据支持，难以准确研判竞争态势、准确定位目标市场。这导致战略实施脱节，影响战略业务布局和市场拓展目标的实现。在业务流程管理方面，缺乏对流程效率、节点效率和流程运营总览的科学分析，战略管理未能形成有效闭环，战略评估和绩效考核缺乏数据支撑。
2、缺乏有效集团管控抓手
在技术快速发展的背景下，央国企受集团管控弱、决策链条长、参与主体多等限制，决策用时较长，过程中存在较大的不确定性。这使得央国企的决策效率明显偏低，容易错失新兴产业发展的窗口机遇期。除了响应国资委的“压减”号召，央国企还需结合自身特点加强集团管控、优化决策流程，探索更适合数字经济的管控和决策机制。
3、人才培养和激励机制的不足
在人力资源管理方面，较多央国企仍沿用传统模式，人才更新和激励机制不科学不完善。这加剧了内部员工责任心不强、创新性不足的氛围，制约了企业的长远发展。此外，企业缺乏对人力资源管理制度执行、评估和优化的系统性记录和数据分析，以及针对员工职业生涯全周期的数字化管理和绩效考核平台。
4、数据壁垒高筑
央国企内部存在大量数据孤岛，缺乏数据共享平台和统一的数据标准。这导致数据资源的价值无法充分发挥，未能转变成最有价值的资产。同时，由于数字化基础薄弱，央国企缺乏基于数据的决策平台，运用数据优化决策效率、管理效率和生产效率的能力有限。
5、风控与业务脱节
央国企在经营过程中面临复杂多变的市场环境，常伴随着各种风险。目前的风险管理、内控、合规和廉政体系各自独立，与业务脱节。这导致风控工作重复和漏点多、协同能力弱等问题，直接影响风控管理工作的成效。因此，央国企的风控建设需充分利用数字技术，强化顶层设计和统一规划部署，将风险管理和合规管理要求嵌入业务流程，加强统一的风控体系建设。通过数字技术手段固化内控体系管控措施，发挥数字管控的刚性约束和监督制衡作用。
三、央国企数字化转型“低代码”解决方案 针对央国企在数字化转型中面临的挑战，织信低代码平台提供了一套全面的解决方案，旨在帮助企业快速实现数字化转型，提升战略意识与领导决策力，加强人力资源数字化转型，打通内外供应链协同，构建合规的智能风控管理体系。
1、提升战略意识与领导决策力
针对战略管理意识不强、投资决策不科学、主责主业不突出、国际化经营水平不高等问题，央国企除了要进一步强化自身的战略管理意识。还要深度加强信息化管理，提升系统集成能力，实现企业内部业务数据互联互通，促进以数字化为支撑的管理变革。
而在企业信息化建设方面，织信低代码拥有快速构建企业级系统的能力，提供自定义API无缝对接各类系统、软硬件设备、第三方平台，贯通企业内部业务数据。同时，还可以帮助企业快速搭建数据决策分析平台，促进对标提升行动开展。并通过数据决策分析平台进行调研分析，得出量化的行业趋势研究、市场/客户研究、竞争态势分析、核心能力分析和差距挑战分析，梳理出愿景、产品规划、竞争力解码、增长策略和组织能力将企业战略重点进行描述。
另外，央国企还可以通过织信低代码构建统一的数据服务平台，实现对数据查询、分析的统一管理，基于企业核心业务场景设计分析指标，全景展示企业财务、运营、产权等综合数据，实现千人千面的自定义分析预测及业务多维分析，为企业提供全面、及时、准确的决策依据，降低管理成本，深入分析运营问题，智能化分析预警，科学高效战略决策，强化战略管控效率与质量。
2、建设人力资源数字化转型
此前，六部门早已联合发文，提出要推进新时代人力资源服务业高质量发展，大力提升人力资源服务水平。人力资源服务和研究的对象是人和组织，央国企要通过激活组织和激活员工，实现人力资源价值经营。人力资源既是企业最宝贵的资产，也是企业管理的核心价值领域，人力资源数字化将成为企业数字化转型升级最关键的抓手。
央国企人力资源数字化转型基于场景化、数字化和智能化，聚焦战略、组织、成本、任务和服务五类场景活动。在这些场景中，央国企可以通过织信低代码快速构建人力资源数字化转型业务框架及数据治理体系相关的应用系统，通过信息化系统全面推进与实现人和服务的智能交互、人和成本的动态核算、人和组织的最优匹配、人和任务的智慧协同、人和战略的价值共生。
3、打通内外供应链协同
针对央国企供应链管理难点，织信低代码从企业管理数字化转型战略出发，提出新一代数字化供应链管理设计方案，从战略定位到体制机制变革再到数字化平台落地，为企业向现代数智化供应链转型指明方向，统一思想，统一建设思路，统一工作步骤，提供技术支撑。
采用一致的技术路线和一体化的织信低代码技术平台，将有效促进产业链上下游的融合互动性，提升供给侧与需求侧的信息对称性，以及产品和服务的适配性，帮助制造端企业实现降本增效、以需定产、有效资源配置，加快实施数字化转型。并全面覆盖需求管理、战略寻源、供应商管理、采购执行、物流管理、仓储管理等供应链运营链条。
此外，还能通过在织信平台中设立统一的需求统筹提报机制的应用系统，以确认、整合、协调分散的业务需求，为更好地支撑采购策略制定、促进供需平衡，降低临时需求或资源不足带来的供应风险。基于系统的全面实时联动的需求端数据，采用科学的预测模型，提升需求预测精准性。
4、构建合规的智能风控管理体系
早在2019年国资委就曾发布《关于加强央国企内部控制体系建设与监督工作的实施意见》，为央国企风控管理提出新的要求。2020 年7月，国际内部审计师协会（IIA）组织更新三道防线模型，明确了组织治理结构与风险管理三道防线的相辅相成、相互影响关系，为建立完善风控组织提供了指导依据。
在构建合规的智能风控管理体系方面，织信低代码可根据央国企实际需要构建风险测算模型，针对合规风险构建评价规则，采集国内外行业、经营等数据，从投资合理性、可行性、经济性等开展风险评估，制定应对方案，形成风险报告，实时推送给主责部门的相关负责人。
此外，基于织信低代码的灵活性和可拓展性，企业还可以快速构建一套风险监控系统，该系统可以汇聚风险评估、风险监测、风险治理、内控评价、风险体系调用情况等数据，测算企业风险防控成熟度和健康指数，分类形成风险防控报表、看板，从多维度、多视角进行风险画像，支撑各级单位经营决策风险分析工作。
四、央国企数字化转型成功案例 1、客户背景
中交第二航务工程局有限公司，简称二航局，创立于1950年，是中国交通建设股份有限公司的全资子公司。经过70多年的发展，二航局已成为一家集设计、施工、科研、资本运作于一体的工程建设企业，以路桥、港航、铁路、城市轨道交通、市政工程施工为主业，并在多元化经营方面取得了显著成绩。市场遍布全国29个省（市、自治区）以及全球13个国家。
2、客户需求
中交二航局技术中心在科研项目管理方面，之前一直采用传统的纸质办公方式。围绕科研项目管理的一系列工作，如任务分配、科研成果管理、项目资料整理、项目周报提交、工时分配、绩效管理以及财务管理等，都需要大量的人力进行数据收集和整理，导致工作效率低下且正确率难以保证。此外，针对科技研发人员的考核体系也亟待完善，需要构建一个更加高效、科学的科研项目管理平台来支撑整个考核体系。
3、解决方案
织信低代码为中交二航局技术中心量身定制了一套科研项目管理解决方案。通过数字化和信息化的方式，实现了从传统的纸质记录到高效的项目管理转变，显著提升了项目管理的效率。这一解决方案不仅为项目管理带来了便利，更为未来的科研管理体系与人才评价体系构建了坚实的信息化基础。
4、方案效果
（1）管理可视化，提升效率
通过织信低代码平台，让中交二航局在科研项目管理、考勤管理、绩效考核、预算及工时等业务方面实现了全面的线上化管理。项目数据的可视化使得员工能够更加方便地进行线上协同办公，并为绩效考核提供了数据依据，有效提升了管理效率和决策的科学性。
（2）系统信息化，降低成本
基于织信低代码快速构建而成的信息化系统，让管理人员和业务人员在管理和时间成本上都有大幅度降低。实时数据提供的功能使得决策时间缩短，从而提高了决策效率和科学性。在2021年正式投入使用后，平台每年为二航局节省了24人月的管理成本。
织信低代码作为国内领先的数字化服务商之一，现已累计为20多个行业，30000+企业用户提供低代码技术支持。在不同的行业，提出深度场景解决方案，致力于成为企业数字化转型首选方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1105369c8d1de17112e2f155e696d5/" rel="bookmark">
			【Linux常用命令——文件基本属性即权限操作】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux文件基本属性 显示文件属性 ls命令 Linux ls（英文全拼：list files）命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。
语法：
ls [参数] 参数：
-a 显示所有文件及目录 (. 开头的隐藏文件也会列出)-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 文件与目录操作 Linux可以支持长达256个字符的文件名称，且文件名是区分大小写的，“abc” 与 "ABC"所代表的是不同文件。
Linux文件类型 Linux文件类型
普通文件(-)：存放数据，程序等信息的文件，一般为文本文件和二进制文件。目录文件(d)：文件系统中一个目录所包含的目录文件，包括文件名和子目录名。链接文件(l)：可以在不同的文件系统之间建立链接关系来实现对文件的访问。设备文件©：把IO设备映射为一个设备文件。管道文件§：主要用于在进程间传递数据。 文件权限
所谓的文件权限，是指对文件访问权限，包括对文件的读、写、删除、执行操作。Linux是一个多用户操作系统，它运行多个用户同时登陆和工作，因此Linux将一个文件或者目录与一个用户和组联系起来。
Linux系统中，文件有三种访问权限：
读（r）- 允许读取文件写（w）- 允许写、修改和删除某个文件执行（x）- 允许执行某个文件 例如，我们以 root 的身份登陆 Linux，并执行如下指令：
[root@localhost ~]# ls -al total 156 drwxr-x---. 4 root root 4096 Sep 8 14:06 . drwxr-xr-x. 23 root root 4096 Sep 8 14:21 .. 解析：
文件设定不同用户的读、写和执行权限，仅涉及到 9 位字符 Linux权限字与权限操作 chgrp： 改变文件所属群组；chown：改变文件所有人；chmod：改变文件的属性； 改变所属群组chgrp 改变一个文件的群组很简单，直接用chgrp命令，这个命令是change group的缩写。
语法：
chgrp [-R] 属组名 文件名 参数选项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b1105369c8d1de17112e2f155e696d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf4a8853c56c9d76c6edf323e8377d5/" rel="bookmark">
			消除Intellij IDEA的Not annotated parameter overrides @NonNullApi parameter警告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个Spring的转换器，在重写Converter的convert()方法时，idea给这个方法增加了警告提示
Not annotated parameter overrides @NonNullApi parameter package cn.edu.sgu.www.mhxysy.converter; import com.alibaba.fastjson.JSON; import org.springframework.core.convert.converter.Converter; import org.springframework.lang.NonNull; import org.springframework.stereotype.Component; import java.util.List; /** * String ==&gt; List&lt;String&gt;的转换器 * @author heyunlin * @version 1.0 */ @Component public class StringToListOfStringConverter implements Converter&lt;String, List&lt;String&gt;&gt; { @Override public List&lt;String&gt; convert(@NonNull String source) { return JSON.parseArray(source, String.class); } } 强迫症看了直呼受不了，那么怎么样消除这个警告呢？
只需要在convert()方法的参数上添加@NonNull注解即可（注意：是org.springframework.lang.NonNull，不要导入错了）
package cn.edu.sgu.www.mhxysy.converter; import com.alibaba.fastjson.JSON; import org.springframework.core.convert.converter.Converter; import org.springframework.lang.NonNull; import org.springframework.stereotype.Component; import java.util.List; /** * String ==&gt; List&lt;String&gt;的转换器 * @author heyunlin * @version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf4a8853c56c9d76c6edf323e8377d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d22bd7104d095b9b6576a3e6788b25/" rel="bookmark">
			ASP.NET Core 高级之使用Redis缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文你的收获 了解Redis基本作用及其使用场景学会安装Redis服务端和客户端及简单的命令行操作学习在ASP.NET Core WebAPI项目中如何操作Redis缓存 一、Redis介绍 Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。
Redis支持丰富的数据类型，常用的如下： string（字符串） // 是 redis 最基本的类型， string 可以包含任何数据，一个键最大能存储 512MBhash（哈希） // hash 特别适合用于存储对象list（列表） // 列表是简单的字符串列表，按照插入顺序排序。可以用作队列。set（集合） //集合内元素的唯一性zset (sorted set：有序集合) Redis的性能极高 – Redis能读的速度是110000次/s，写的速度是81000次/s 。
Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用
Redis支持数据的高并发、高可用，如主从模式、哨兵模式、cluster集群模式
使用场景 字符串（String）: 最基本的数据类型，可以存储字符串、整数或浮点数。场景：缓存Session会话，计数器，流水号等。哈希/散列/字典（Hash）:键值对的集合，可以在一个哈希数据结构中存储多个字段和值。场景：存电商的购物车信息列表（List）:按照插入顺序存储一组有序的值，可以在列表的两端执行插入、删除和访问操作。场景：用作简单的消息队列。集合（Set）:无序的唯一值集合。场景：实现抽奖，文章的点赞、评论。有序集合（Sorted Set）:可以根据分数对成员进行排序，同时保持唯一性。场景：实现体育赛事排行榜，游戏积分榜，热销商品排行榜。 二、安装Redis服务端 将 安装包 Redis-x64-3.2.100.zip ，解压到C盘或D盘根目录下，就完成了安装。安装包下载
将以上安装目录添加到环境变量Path中，如下图：
设置Redis服务器的密码，打开安装目录下的redis.windows.conf配置文件，找到“requirepass”，设置为自己的密码。
启动Redis服务器。打开一个 命令行控制台窗口（小黑窗），cd命令切换到安装目录 ，输入以下命令启动
redis-server.exe redis.windows.conf 如下图：
把Redis服务加入到Windows 服务中，让它开机自启动 在Redis的安装目录，打开cmd，然后输入以下命令：
安装服务的命令: redis-server.exe --service-install redis.windows.conf --loglevel verbose 卸载服务的命令： redis-server --service-uninstall 以上步骤结束之后，在任务管理器的“服务”中，启动Redis服务
三、Redis 客户端 3.1 redis-cli命令行 打开CMD或者PowerShell，命令提示符里，打开Redis的客户端，输入以下指令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8d22bd7104d095b9b6576a3e6788b25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba23a9451f98fc4d8495cf6c9d5e3b4/" rel="bookmark">
			数据结构-＞双端队列（c/c&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; //#define MAXSIZE 5 typedef int date_t; typedef struct listqueue {//节点结构体 date_t name_id; listqueue* next; }listqueue,*list; typedef struct queue {//队列结构体 listqueue* front; listqueue* rear; int size; }queue; void initqueue(queue* node) { listqueue* head=new listqueue; node-&gt;front = node-&gt;rear = head; head-&gt;next = nullptr; node-&gt;size = 0; } bool empty(queue* qulist) { return qulist-&gt;size == 0; } void pushtop(date_t name,queue*qulist) { listqueue* newqu = new listqueue; newqu-&gt;name_id = name; if (qulist-&gt;size == 0) { qulist-&gt;rear = newqu; } newqu-&gt;next = qulist-&gt;front-&gt;next; qulist-&gt;front-&gt;next = newqu; qulist-&gt;size++; } void pushback(date_t name, queue* qulist) { listqueue* newqu = new listqueue; newqu-&gt;name_id = name; newqu-&gt;next = nullptr; if (qulist-&gt;size == 0) { qulist-&gt;front-&gt;next = newqu; } qulist-&gt;rear-&gt;next = newqu; qulist-&gt;rear = newqu; qulist-&gt;size++; } int toppop(queue*qulist) { if (empty(qulist)) return -1; date_t temp = qulist-&gt;front-&gt;next-&gt;name_id; listqueue* ptemp = qulist-&gt;front-&gt;next; qulist-&gt;front-&gt;next = qulist-&gt;front-&gt;next-&gt;next; delete ptemp; qulist-&gt;size--; return temp; } int backpop(queue*qulist) { if (empty(qulist)) return -1; date_t temp = qulist-&gt;rear-&gt;name_id; listqueue* ptem = qulist-&gt;front-&gt;next; if (qulist-&gt;front-&gt;next == qulist-&gt;rear) { qulist-&gt;size--; qulist-&gt;front-&gt;next = nullptr; delete ptem; qulist-&gt;rear = nullptr; } else { while (ptem !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ba23a9451f98fc4d8495cf6c9d5e3b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef5ecaa0a5055a28e9deeaa6c52f33df/" rel="bookmark">
			docker screen 常用基础命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.docker基础命令 1.1开启docker systemctl start docker #开启docker service docker restart #重启docker systemctl stop docker #关闭docker 1.2查看命令 docker images #查看docker镜像 docker ps #查看正在运行的镜像或者容器 docker ps -a #查看所有容器 1.3运行命令 docker run -it image_name #运行镜像 有几个选项需要说一下：
--gpus all ：使用主机的显卡驱动。 也可以 device=0 选择固定显卡（多快显卡情况下）
-p 服务器port：docker_port：端口映射。使外界能访问到docker内部。如使用ssh
-v 服务器文件夹：docker文件夹：文件映射。使不打开docker的情况下，访问docker文件夹
-it ：以交互模式运行容器
docker start contain_id #打开容器 docker exec -it contain_id bash #运行容器 docker port contain_id #查看容器端口 如果不先打开容器，会报这个容器没没有running 的错误。如下图
这个没有那么多选项，如果之前运行过带有显卡--gpus的版本，进去直接默认带显卡。
1.4打包为镜像 使容器成为镜像
docker commit newname contain_id 1.5拉取镜像 docker pull pull_content 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef5ecaa0a5055a28e9deeaa6c52f33df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895929f67e7a624111055768c26ff5b8/" rel="bookmark">
			postman导入https证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入setting配置中Certificates配置项
点击“Add Certificate”,然后配置相关信息
以上配置完毕，如果测试出现“SSL Error:Self signed certificate”
则将“SSL certificate verification”取消勾选
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8c6e4156cd166df3faab802c7e81e9/" rel="bookmark">
			C语言——程序的版式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 版式虽然不会影响程序的功能，但会影响可读性。程序的版式追求清晰、美观，是程序风格的重要构成因素。可以把程序的版式比喻为“书法”。好的“书法”可让人对程序一目了然，看得兴致勃勃。差的程序“书法”如螃蟹爬行，让人看得索然无味，更令维护者烦恼有加。请程序员们学习程序的“书法”，弥补大学计算机教育的漏洞，实在很有必要。接下来让我开始学习吧！ 1. 空行 空行起着分隔程序段落的作用。空行得体（不过多也不过少）将使程序的布局更加清晰。空行不会浪费内存，虽然打印含有空行的程序是会多消耗一些纸张，但是值得。所以不要舍不得用空行。 规则1-1： 在每个类声明之后、每个函数定义结束之后都要加空行。参见示例2-1（a） 规则1-2： 在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应加空行分隔。参见示例 2-1（b ） 2. 代码行 规则2-1： 一行代码只做一件事情，如只定义一个变量，或只写一条语句。这样的代码容易阅读，并且方便于写注释。 规则2-2： if、for、while、do 等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加{}。这样可以防止书写失误。 建议2-1： 尽可能在定义变量的同时初始化该变量（就近原则）因为如果变量的引用处和其定义处相隔比较远，变量的初始化很容易被忘记。如果引用了未被初始化的变量，可能会导致程序错误。本建议可以减少隐患。例如 int width = 10; // 定义并初绐化 width int height = 10; // 定义并初绐化 height int depth = 10; // 定义并初绐化 depth int arr[10] = { 0 };//定义并初始化数组arr int arr[n];//这里的变长数组是特例 变长数组的概念可以参考这个——C99变长数组 3. 代码行内的空格 规则3-1: 关键字之后要留空格。像 const、virtual、inline、case 等关键字之后至少要留一个空格，否则无法辨析关键字。像 if、for、while 等关键字之后应留一个空格再跟左括号‘（’，以突出关键字。 规则3-2： 函数名之后不要留空格，紧跟左括号‘（ ’，以与关键字区别。 规则3-3： ‘（ ’向后紧跟，‘ ）’、‘ ，’、‘ ; ’向前紧跟，紧跟处不留空格。 规则3-4： ‘ ，’之后要留空格，如 Function(x, y, z)。如果‘;’不是一行的结束符号，其后要留空格，如 for (initialization; condition; update)。 规则3-5： 赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，如“ = ”、“ += ” “ &gt;= ”、“ &lt;= ”、“ + ”、“ * ”、“ % ”、“ &amp;&amp; ”、“ || ”、“ &lt;&lt; ”,“ ^ ”等二元操作符的前后应当加空格。 规则3-6： 一元操作符如“ !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d8c6e4156cd166df3faab802c7e81e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bdc0e886069a828c68a6a64de5233b7/" rel="bookmark">
			【Unity】URP报错Object reference not set to an instance of an object
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用URP之后，Unity报错：显示不正常
NullReferenceException: Object reference not set to an instance of an object
UnityEngine.Rendering.Universal.UniversalAdditionalCameraData.get_cameraStack () (at Library/PackageCache/com.unity.render-pipelines.universal@10.6.0/Runtime/UniversalAdditionalCameraData.cs:236)
URPCameraSetter.Start () (at Assets/Scripts/Eyeah/GameSystem/URPCameraSetter.cs:16)
解决：
设置这个URP的Asset丢了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea0341c2bea5f5babf4c7bdffd28e6c/" rel="bookmark">
			PyTorch中torch.cat函数和torch.stack函数说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 torch.cat 定义： torch.cat(tensors, dim=0, out=None) → Tensor
参数：
tensors (Sequence of Tensors)：要连接的张量序列。dim (int, 可选)：沿着此维连接张量序列。当 dim=0 时，torch.cat() 会按行连接多个张量，也就是在第一个维度上进行连接。这将导致张量在垂直方向上叠加。当 dim=1 时，torch.cat() 会按列连接多个张量，也就是在第二个维度上进行连接。这将导致张量在水平方向上叠加。out (Tensor, 可选)：输出张量。 返回值：
一个新的张量，它是输入张量在指定维度上的连接。 用途：
torch.cat 用于将给定维度上的一系列张量连接在一起。张量在除连接维以外的所有维度上必须具有相同的形状。 torch.stack 定义： torch.stack(tensors, dim=0, out=None) → Tensor
参数：
tensors (Sequence of Tensors)：要堆叠的张量序列，所有张量都应有相同的形状。dim (int, 可选)：插入新维度的索引。out (Tensor, 可选)：输出张量。 返回值：
一个新的张量，它沿着新维度对输入张量序列进行堆叠。 用途：
torch.stack 用于创建一个新的维度，并在该维度上堆叠一系列张量。与torch.cat不同，torch.stack会增加一个新的维度，所以输出张量的维度会比输入张量多一个。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec06551008b60f8055e1a5f6ca4bab6d/" rel="bookmark">
			java项目性能优化（MyBatis中开启查询缓存及flushCache与useCache的使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java项目中，如果需要大量的DB查询，导致缓存过多，项目运行缓慢，可以设置在select查询时，添加二级缓存的清空。
如果没有去配置flushCache、useCache，那么默认是启用缓存的。
1，flushCache默认为false，表示任何时候语句被调用，都不会去清空本地缓存和二级缓存。
2，useCache默认为true，表示会将本条语句的结果进行二级缓存。
在insert、update、delete语句时： flushCache默认为true，表示任何时候语句被调用，都会导致本地缓存和二级缓存被清空。 useCache属性在该情况下没有。update 的时候如果 flushCache=“false”，则当你更新后，查询的数据数据还是老的数据。
在Mapper的具体方法下设置对二级缓存的访问意愿：
&lt;select id="save" parameterType="XX" flushCache="true" useCache="false"&gt; &lt;/select&gt; 同时设置 flushCache=“true” useCache=“false”
那么就是，第一次查询后，清空二级缓存，并且以后都不会在缓存中保存数据。
参考资料：
[mybatis]缓存_缓存有关的设置以及属性
MyBatis中开启查询缓存及flushCache与useCache的使用
mybatis复习与总结（八）——缓存
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a488ede651bb5645eabfd8f6bd71fe7b/" rel="bookmark">
			Java集合（二）List、ArrayList、LinkedList
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 List一、List简介二、遍历List2.1 不同遍历方式的使用2.2 不同遍历方式的适用场合 三、常见List实现类比较3.1 ArrayList和LinkedList3.2 ArrayList和Vector ArrayList一、ArrayList介绍1.1 ArrayList的特点1.2 ArrayList的使用 二、从源码理解ArrayList2.1 创建ArrayList对象2.2 往ArrayList中添加元素2.3 从ArrayList中删除元素2.4 获取指定位置的元素2.5 替换指定位置的元素2.6 查找指定元素所在位置2.7 自动扩容机制 三、ArrayList相关问题3.1 Array和ArrayList的区别3.2 多线程场景下如何使用ArrayList3.3 System.arraycopy和Arrays.copyOf3.4 ArrayList的扩容因子为什么是1.5 LinkedList一、LinkedList介绍1.1 LinkedList特点1.2 LinkedList的使用 二、从源码理解LinkedList2.1创建LinkedList对象2.2 往链表里添加节点2.3 从链表中删除节点2.4 获取链表中的节点2.5 更新元素2.6 查找某个元素在链表中的位置 本系列文章：
Java集合（一）集合框架概述
Java集合（二）List、ArrayList、LinkedList
Java集合（三）CopyOnWriteArrayList、Vector、Stack
Java集合（四）Map、HashMap
Java集合（五）LinkedHashMap、TreeMap
Java集合（六）Hashtable、ConcurrentHashMap
Java集合（七）Set、HashSet、LinkedHashSet、TreeSet
Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue
List 一、List简介 List是有序集合，使用List可以控制列表中每个元素的插入位置，可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。
List通常允许重复的元素。
使用List存储的特点：元素有序、可重复。
List最常见的实现方式是ArrayList和LinkedList。以下是List接口常见实现类的对比：
具体实现优点缺点ArrayList底层数据结构是数组，查询快，效率高增删慢；
线程不安全LinkedList底层数据结构是链表，增删快，效率高查询慢；
线程不安全Vector底层数据结构是数组，查询快；
线程安全增删慢，效率低CopyOnWriteArrayList底层数据结构是数组，读写分离，效率高；
线程安全，内存消耗较大；
只能保证数据的最终一致性，不能保证数据的实时一致性 ArrayList是一个动态数组，随着容器中的元素不断增加，容器的大小也会随着增加。同时由于ArrayList底层是数组实现，所以可以随机访问元素。
Vector与ArrayList类似，不过是同步的，因此Vector是线程安全的动态数组。
Stack继承自Vector，实现一个后进先出的堆栈。
LinkedList是一个双向链表，LinkedList不能随机访问，增删元素比较方便。
CopyOnWriteArrayList是一个线程安全、并且在读操作时无锁的 ArrayList。当需要修改容器中的元素时，会首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。
数据元素在内存中，主要有2种存储方式：顺序存储和链式存储。
1、顺序存储
这种方式，相邻的数据元素存放于相邻的内存地址中，整块内存地址是连续的。可以根据元素的位置直接计算出内存地址，直接进行读取。读取一个特定位置元素的平均时间复杂度为O(1)。正常来说，只有基于数组实现的集合，才有这种特性。
在List的实现类中，顺序存储以ArrayList为代表。2、链式存储
这种方式，每一个数据元素，在内存中都不要求处于相邻的位置，每个数据元素包含它下一个元素的内存地址。不可以根据元素的位置直接计算出内存地址，只能按顺序读取元素。读取一个特定位置元素的平均时间复杂度为O(n)。主要以链表为代表。
在List的实现类中，链式存储以LinkedList为代表。 二、遍历List 对于List集合的实现类，常见的遍历方式是：for循环、for each遍历和迭代器遍历。
2.1 不同遍历方式的使用 1、for循环遍历
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a488ede651bb5645eabfd8f6bd71fe7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eec5aa175a4ed0087d293c123e692f8/" rel="bookmark">
			Linux环境下部署Tomcat(详细图文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、下载地址
1.服务器不能联网情况下载
2.服务器能够联网
二、安装
1. Tomcat解压
2. Tomcat目录说明：
3. 重命名解压后的文件名
4. 配置环境变量
5. 修改配置文件
6.启动Tomcat
7.访问Tomcat
8. 停止Tomcat
一、下载地址 1.服务器不能联网情况下载 官网地址：Apache Tomcat® - Welcome!
比如，我想下载Tomcat8的版本，具体是8最新版-8.5.98。按照如下操作：
找到8版本最新的，在最下面
tar和zip看自己喜欢，一般我选择tar.gz压缩包
2.服务器能联网下载 可以直接在服务上，通过wget命令下载对应Tomcat的版本。默认下载到当前目录
wget https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.98/bin/apache-tomcat-8.5.98.tar.gz 二、安装 Tomcat解压即用，稍微配置一下环境变量，执行启动即可。
1. Tomcat解压 tar -zxvf apache-tomcat-8.5.98.tar.gz 2. Tomcat目录说明： bin:该文件夹包含了 Tomcat 的可执行脚本文件，如 startup.sh（用于启动 Tomcat）和 shutdown.sh（用于停止 Tomcat）。此外，还包含其他一些辅助脚本和可执行文件。
conf:该文件夹包含了 Tomcat 的配置文件。其中最重要的是 server.xml，它定义了 Tomcat 服务器的整体配置，包括端口号、连接器、虚拟主机等。
lib:该文件夹包含了 Tomcat 的库文件，包括 Java 类库和 Tomcat 的核心组件。其中最重要的是 catalina.jar，它包含了 Tomcat 的核心类和功能。
logs:该文件夹包含了 Tomcat 的日志文件。其中最常见的是 catalina.out（或 catalina.log），它记录了 Tomcat 启动和运行时的日志信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eec5aa175a4ed0087d293c123e692f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c3a66aa93cf75668c89e6135d0b703/" rel="bookmark">
			用java以数组为底层数据结构创建自己的栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java以数组为底层数据结构创建自己的栈 栈可以解决什么问题呢：
1.括号匹配问题
2.递归
3.表达式求值问题
首先明确栈的功能： 1.入栈：给底层数组的尾部插入元素相当于入栈
2.出栈：把底层数组的最后一个元素提出来相当于出栈
3.获取栈长度：获取size
4.判断栈是否为空：底层数组size==0则为空
5.获取栈顶:返回底层数组的最后一个元素
由于底层结构是数组，我们也可以用别的结构来创建这个栈，但是栈的方法总归是这么些个，所以我们需要把这些方法写在接口里，然后用数组栈来实现这个接口的功能
接口：
public interface selfstack &lt;T&gt; { //入栈 void push(T e); //出栈 T pop(); //查看栈顶元素 T peak(); //判断是否为空 boolean IsEmpty(); //获取栈中元素的个数 int geiSize(); } ArrStack：
public class ArrStack&lt;T&gt; implements selfstack&lt;T&gt; { //底层用上一篇我们自己写的数组 private MyArrary&lt;T&gt; data; //容器 private int size; //默认构造方法为创建一个100大小的自己数组 public ArrStack(){ this.data=new MyArrary&lt;T&gt;(100); this.size=0; } public void push(T e) { //调用自己数组的向尾部添加元素，这样子效率较高，如果向头部添加元素还需要往后推移 this.data.adddata(e); this.size++; } //出栈 public T pop() { T e=this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2c3a66aa93cf75668c89e6135d0b703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c945df86e83413fb4b3f8af45dff468a/" rel="bookmark">
			phpstudy搭建：勾股OA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作为一名打杂工人，我有幸接触过php的一些项目部署。因为不常使用php和apache，所以为了图方便而且当前仅是产品调研阶段，使用了phpstudy对项目进行部署，这里我主要讲讲使用phpstudy搭建勾股OA的一些操作。
勾股OA是一款基于ThinkPHP6 + Layui + MySQL打造的实用的开源的企业办公系统，开箱即用，使用勾股OA可以简单快速地建立企业级的办公自动化系统。 办公自动化系统是员工及管理者使用频率最高的应用系统，可以极大提高公司的办公效率，我们立志为中小企业提供开源好用的办公自动化系统，帮助企业节省数字化、信息化办公的成本。
这是它的开源地址：https://gitee.com/gouguopen/office
phpstudy安装就不多赘述了，windows更简单，直接按官网提示装就好了：
https://www.xp.cn/download.html
夹带私货： Linux/centos安装python、java、php等编译环境_centos php编译环境吗-CSDN博客
下载 由于勾股OA对gitee开源，所以直接根据开源地址（上面提到了）先下载下来：
phpstudy部署 1、基础设施安装 环境就装下图里的，具体版本根据开源页面下的环境配置来，别安装过高版本php！
2、设置composer环境变量 你可能需要设置一下composer环境变量，让官方的安装教程顺利进行下去，这里我将composer塞到php目录里一起配置了
① 打开composer文件目录，复制composer.bat 、composer.phar 这两个文件到php目录里，这里是最终的放置：
② 加入php目录到环境变量里
这样，你就同时拥有php，composer两个环境变量了
3、项目配置和安装 php配置更改 标红的部分是需要打开的（取消前面的【;】号），其他版本不知道，具体一定要看官方的环境要求 你可能仍需要注意下这个扩展指向，如果已有，则不必理会，根据你的实际目录来填
下载PHP依赖包 如官方文档所述，你需要前往项目目录安装它的依赖包
前往解压的项目目录，我这里已经将其解压到phpstudy的网站目录了，这里的office-master就是它的项目目录：
【D:\phpstudy_pro\WWW\office-master】
CMD进该目录执行
composer install 中间可能会出现问题，大多可能原因是php.ini的配置没设好，根据提示去解决即可，如果遇到网络问题，例如让你加github证书的，可以不理它，重新执行即可
4、项目部署 上面都执行好了后，开始用phpstudy Apache部署项目
绑定项目根目录 记得要绑在这个项目的public目录上！
配置伪静态 这个是根据安装文档要求来的
&lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php?/$1 [QSA,PT,L] &lt;/IfModule&gt; 确认部署 配置好后点击确认即可
访问该系统地址，进行下一步操作：http://localhost:52007/install/index
系统配置 我已经装了，所以截图没有，但是如果你配置失败（也就是进度条不动），这是一些安装的日志文件目录：D:\phpstudy_pro\WWW\office-master\runtime\install\log\xxx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c945df86e83413fb4b3f8af45dff468a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bb9b8b9b00a99ffb555efeac39dfd00/" rel="bookmark">
			鉴源实验室｜自动驾驶仿真测试技术分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01
引言
随着科技的不断发展，自动驾驶技术逐渐成为汽车行业的热门话题。然而，要将自动驾驶车辆投放到真实道路上之前，必须进行广泛的测试，以确保其在各种情况下都能安全可靠地运行。自动驾驶车辆的测试是一个复杂而昂贵的过程。在真实道路上进行测试存在许多挑战，包括安全性、成本和时间。为了克服这些问题，仿真测试技术不失为一种有效的解决方法。
自动驾驶仿真测试是通过虚拟环境来模拟各种驾驶场景，以评估自动驾驶系统的性能。自动驾驶汽车的仿真测试的核心技术点主要可以分为虚拟场景仿真、感知系统仿真、车辆动力学仿真以及云加速仿真[1]。
02
虚拟场景仿真
自动驾驶汽车的仿真测试，首先需要模拟构建出一个逼真的虚拟场景，而场景的构建可以分为静态场景构建和动态场景构建两个层面[2]。
2.1 静态场景构建
静态场景主要用于模拟出与车辆行驶相关的静态元素，其中包含的静态元素有道路、建筑、交通标志等。构建静态场景的方法可以采用基于高精度地图及三维重建技术[3]。基于高精度地图及三维重建技术来构建场景，首先需要采集点云、全景图、测绘矢量等非结构化的测绘数据，并将测绘数据结构化，构建厘米级的高精度地图，其中包含路面、道路标线、交通标识等信息，之后以此为基础，使用三维建模软件建立基础设施与周边环境的可视化数字模型。
图1 静态场景（来源于Carsim的demo）
2.2 动态场景构建
动态场景包括天气变化（雨、雪、雾等天气状况）、时间变化（不同时间和季节的光照条件等）、交通流（交通参与者的行为，例如机动车行为、非机动车行为、行人行为）等动态要素。动态场景的构建是在静态场景的基础上，还原出场景中的动态元素，并且使得这些元素的动作及其产生的影响严格遵循现实世界的物理规律以及行为逻辑。动态场景的构建，可以借助物理引擎、AI Agent 等来实现。
物理引擎可以模拟出物体在真实世界中的物理规律，赋予真实的物理属性的方式来计算运动和碰撞行为等。物理引擎可以模拟刚体（硬物体）和软体（如布料、液体等）的运动和变形，从而更全面地模拟多样化的物体行为。
AI Agent （人工智能体）是一种能够感知环境、进行决策和执行动作的智能实体。在虚拟场景中，AI Agent 可以做出决策，选择合适的行为，并规划最优路径以实现目标；可以模拟对环境的感知能力，例如通过传感器获取周围物体的信息，以便做出合适的决策；可以模拟智能体之间的协作行为，例如避让、跟随、协同工作等。此外，Agent AI还具备学习能力，能够根据经验调整其行为。
03
感知系统仿真
自动驾驶车辆依赖于各种传感器，如摄像头、雷达和激光雷达等。仿真测试技术需要能够准确模拟这些传感器的输入，以确保自动驾驶系统在虚拟环境中能够正确地感知和理解周围的环境。传感器仿真指的是数学模型和计算机算法来模拟和重现真实世界中传感器所能感知的物理现象的过程[4]。它可以在虚拟环境中重现传感器的工作情况，从而在没有实际硬件的情况下评估和测试传感器的性能。
3.1 摄像头仿真
摄像头仿真的一般方法是基于环境物体的几何空间信息构建对象的三维模型。根据物体的真实材质与纹理，并通过计算机图形学对三维模型添加颜色与光学属性等，来模拟实现图像合成。摄像头仿真通过坐标系转换的方法，将三维空间中的点通过透视关系变换为图像上的点。
3.2 毫米波雷达仿真
雷达（无线电探测与测距）仿真是一种模拟雷达系统操作的过程，它可以重现雷达波的传播、目标的检测和回波的分析。雷达仿真一般会根据配置的视场角和分辨率信息，向不同方向发射一系列虚拟连续调频毫米波，并接收目标的反射信号。不同车辆的雷达回波强度可使用微表面模型能量辐射计算方式，由车辆模型以及车辆朝向、材质等计算。
3.3 激光雷达仿真
激光雷达（或LiDAR，Light Detection and Ranging）仿真则是模拟使用激光扫描来构建物体或环境的三维图像的过程。激光雷达传感器仿真，需要准确模拟出发射激光束并测量其反射，生成点云数据。生成模拟的激光雷达点云数据，其中包含了周围环境中的物体位置和形状信息。
04
车辆动力学仿真
自动驾驶汽车在仿真测试中，需要借助车辆动力学模型来模拟车辆的横向和纵向运动控制，还原出车辆在真实道路上各种物理条件下的行为[5]。复杂的车辆动力学模型，可以保证车辆有良好的仿真精度，使仿真车辆的行驶反应更贴近真实行为。因此，车辆动力学仿真，可以逼真地模拟出车辆的运动、碰撞检测和处理，以及不同路面条件对车辆行驶的影响等等。
车辆动力学模型包含了车体、悬架系统、转向系统、制动系统、动力系统、 传动系统等多个部分的模型，通过将车辆动力学模型实例参数化之后，就可以实现对仿真车辆模型的转向、加速、制动等行为的模拟和控制。
借助专业的车辆动力学仿真软件可以模拟出高精度的车辆动力学模型，同时，一些强大的车辆动力学仿真软件还可以提供车辆可视化和驾驶场景搭建功能。目前，专业的车辆动力学仿真软件，有 CarSim、Prescan、CarMaker、VI-Grade、VeDYNA 和 PanoSim 等，仿真平台可以接入这些成熟的车辆动力学模型，以获得比较逼真的行驶控制仿真效果。
图2 车辆动力学模型（来源于Carsim的demo）
05
云加速仿真
自动驾驶仿真测试系统在进行仿真任务时需要访问大量采集或者生成的数据，并根据生成的数据利用 CPU 和 GPU 资源对数据进行再处理并还原，或者对已经结构化的数据进行 GPU 渲染再现。这些仿真任务都需要依赖强大的计算和存储能力，而借助云加速仿真的技术，可以高效执行大规模的仿真任务。
云加速仿真是指利用云计算平台的强大计算和存储能力，通过将仿真任务迁移到云端来加速仿真过程。这种方法可以显著提高仿真效率，减少仿真时间，同时降低了对本地硬件资源的依赖。同时，云加速仿真可以通过并行化和分布式计算来加速任务的执行。云平台提供了强大的计算资源，可以同时处理多个任务或者将一个大任务分解成多个子任务并行执行，从而提高仿真效率。
06
小结
自动驾驶仿真测试技术在推动自动驾驶技术的发展中发挥着重要作用。通过在虚拟环境中模拟各种复杂情景，该技术降低了测试成本、提高了安全性，并加速了自动驾驶系统的迭代和创新。然而，仍然有一些挑战需要克服，如提升虚拟场景的逼真度、提高传感器模拟精度等。未来，随着技术的不断发展，自动驾驶仿真测试技术将继续演进，为自动驾驶技术的商业化和普及做出更大的贡献。
参考文献：
[1]中国电动汽车百人会. 中国自动驾驶仿真蓝皮书 [R]. (2020) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bb9b8b9b00a99ffb555efeac39dfd00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/029a46a64ce040b032721ce313627572/" rel="bookmark">
			rotary-encoder旋钮编码器驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旋钮按键驱动 旋钮原理驱动架构设备树调试过程 旋钮原理 _____ _____ _____ | | | | | | Channel A __| |_____| |_____| |____ _____ _____ _____ | | | | | | Channel B _____| |_____| |_____| |__ 如果顺时针是这样的波形的话，逆时针就是它反过来从左到右看波形。
这样就出现了以下规则：
顺时针的时候：channelA电平变化：1–&gt;1–&gt;0–&gt;0
channelB电平变化：0–&gt;1–&gt;1–&gt;0
逆时针的时候：channelA电平变化：0–&gt;1–&gt;1–&gt;0
channelB电平变化：1–&gt;1–&gt;0–&gt;0
可以从上述规律中得出：只有第一、三阶段有不一样，第二、四阶段都是一样的电平。
我们可以以第二阶段作为起始点,第四阶段作为结束点，那么第三阶段就是判断是否顺时针还是逆时针了。按照这个思路，得出了下面encoder_interrupt_handler中断处理函数。
驱动架构 创建一个自己的platform_driver 结构体
static struct platform_driver encoder_driver = { .probe = encoder_probe, .remove = encoder_remove, .driver = { .name = DEV_NAME, .owner = THIS_MODULE, .of_match_table = of_match_ptr(encoder_match), } }; module_platform_driver(encoder_driver); 新建一个设备驱动程序中的设备匹配表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/029a46a64ce040b032721ce313627572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112a8d580b89b1a75db9c6f2a7ec563c/" rel="bookmark">
			【数据结构与算法】排序算法：直接插入排序，希尔排序详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、直接插入排序
1、直接插入排序思想
2、直接插入排序算法的性能分析
​编辑
代码实现：
二、希尔排序
1、希尔排序思想
2、希尔排序算法的性能分析
代码实现： 一、直接插入排序 1、直接插入排序思想 直接插入排序是一种简单直观的排序算法，其思想是通过构建已排序部分和未排序部分，将待排序元素按照大小逐个插入到已排序部分的正确位置中，完成排序。
具体步骤如下：
将待排序序列的第一个元素看作已排序部分。从待排序序列中依次取出元素，从已排序部分的末尾开始，向前比较。如果当前取出的元素大于已排序部分的某个元素，则将该元素插入到该位置后面，即将该位置以及其后面的元素都向后移动一位。如果当前取出的元素小于或等于已排序部分的某个元素，则将该元素插入到该位置前面的位置。重复步骤2-4，直到待排序部分中的所有元素都被插入到已排序部分中 2、直接插入排序算法的性能分析 时空复杂度:
时间复杂度：直接插入排序的平均时间复杂度为O(n^2)，最好情况下的时间复杂度为O(n)，最坏情况下的时间复杂度为O(n^2)。空间复杂度：直接插入排序的空间复杂度为O(1)，它是一种原地排序算法，不需要额外的空间。 稳定性：
直接插入排序是稳定的，即相等元素的相对次序在排序前后保持不变。当比较相等元素时，由于只有当前元素小于等于已排序部分的某个元素时才插入，因此相等元素的相对次序不会发生改变。
需要注意的是，尽管直接插入排序在最坏情况下的时间复杂度较高，但对于小规模或基本有序的序列，直接插入排序的性能较为优秀。
代码实现： void InsertSort(int* a, int n) { int i, j, temp; for (i = 0; i &lt; n - 1; i++) { temp = a[i + 1]; // 将当前待插入的元素暂存到变量temp中 j = i; // j用于记录已排序部分的最后一个元素的索引 while (j &gt;= 0) { if (temp &lt; a[j]) { a[j + 1] = a[j]; // 如果temp比已排序部分的元素小，将该元素后移一位 } else { break; // 如果temp不小于已排序部分的元素，跳出循环 } j--; // 继续向前比较 } a[j + 1] = temp; // 将暂存的元素插入到正确位置 } } 二、希尔排序 1、希尔排序思想 希尔排序是基于插入排序的一种改进算法，也称为缩小增量排序。它通过将待排序序列按照一定间隔分成多个子序列，并对每个子序列进行插入排序的方式来逐步减小间隔，最终使整个序列有序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/112a8d580b89b1a75db9c6f2a7ec563c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a279ce6be1393c63490305c4ee89d0d5/" rel="bookmark">
			Excel表格的快速动态扩展与删除行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例需求：工作表中的表格（ListObject）名称为Table1，表格列数不确定，需要实现如下功能：
当用户完成最后一行最后一列输入之后（如果该单元格为空，则视为输入未完成），表格自动扩展一行扩展行中，第一列填充自动序号，其他列填充NA如果用户双击表格中最后一行的任意单元格，那么删除该行，并相应调整表格单元格范围 效果如下所示。
示例代码如下。
Private Sub Worksheet_Change(ByVal Target As Range) Dim oTab As ListObject, oListRow As ListRow Const TAB_NAME As String = "Table1" If Target.CountLarge = 1 And Len(Target.Cells(1).Value) &gt; 0 Then Set oTab = Me.ListObjects(TAB_NAME) With oTab If Not Application.Intersect(.Range.Columns(.ListColumns.Count), Target) Is Nothing Then If Target.Offset(1).ListObject Is Nothing Then Set oListRow = .ListRows.Add Application.EnableEvents = False mRow.Range.Value = "NA" oListRow.Range(1) = .ListRows.Count Application.EnableEvents = True End If End If End With End If End Sub Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Dim oTab As ListObject Const TAB_NAME As String = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a279ce6be1393c63490305c4ee89d0d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ec03dc70d7f3c137f927ef7dd3a9cc/" rel="bookmark">
			ARCGIS PRO SDK 图层定义查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ​ SetDefinitionQuery：设置活动定义查询的 where 子句。 必须在 MCT 上调用此方法。使用 QueuedTask.Run。
如果 whereClause 为 null 或空字符串，则将移除活动查询定义，并且图层不再具有活动定义查询。如果存在活动定义查询，则此函数使用传入的 whereClause 更新定义查询的 where 子句。如果 whereClause 为非 null，并且没有活动定义查询，则将创建具有指定 where 子句的新定义查询，并成为活动定义查询。将分配自动生成的名称。所有其他未处于活动状态的定义查询保持不变。使用 SetActiveDefinitionQuery 可以激活或停用任何现有定义查询。
vb
Dim layerParamsQueryDefn As FeatureLayer = pFeaturelayer layerParamsQueryDefn.SetDefinitionQuery("所属图='1'") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7db7825722bdfafc3e66cf201eeee1/" rel="bookmark">
			深入理解Rust基本类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述二、数值类型2.1、整数类型2.2、浮点类型2.3、数字运算2.4、位运算2.5、序列（Range）2.6、有理数和复数 三、字符、布尔、单元类型3.1、字符类型3.2、布尔类型（bool）3.3、单元类型 团队博客: 汽车电子社区
一、概述 Rust基本类型有如下几种：
1、数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数。
2、字符串：字符串字面量和字符串切片 &amp;str。
3、布尔类型： true和false。
4、字符类型: 表示单个 Unicode 字符，存储为 4 个字节。
5、单元类型: 即 () ，其唯一的值也是 ()。
二、数值类型 2.1、整数类型 整数是没有小数部分的数字。之前使用过的 i32 类型，表示有符号的 32 位整数（ i 是英文单词 integer 的首字母，与之相反的是 u，代表无符号 unsigned 类型）。下表显示了 Rust 中的内置的整数类型：
isize 和 usize 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e7db7825722bdfafc3e66cf201eeee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ceea57fd4f71195a24563fae619cde/" rel="bookmark">
			apt-get install 报错：E: Error, pkgProblemResolver::Resolve generated breaks, this may
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用Linux系统使用命令行安装某软件包时：
sudo apt-get install &lt;packagename&gt; E: Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages
E: 错误，pkgProblemResolver::Resolve 发生故障，这可能是有软件包被要求保持现状的缘故。 E: 无法更正依赖关系
（举例子）
下列软件包有未满足的依赖关系：
mentohust:i386 : 依赖: libpcap0.8:i386 但是它将不会被安装 或
libpcap0.9:i386 但无法安装它 或
libpcap1.0:i386 但无法安装它 或
libpcap1:i386 但无法安装它
wps-office : 依赖: libc6:i386 (&gt;= 2.12) 但是它将不会被安装
依赖: libstdc++6:i386 (&gt;= 4.5) 但是它将不会被安装
依赖: libfreetype6:i386 (&gt;= 2.4) 但是它将不会被安装
依赖: libglu1-mesa:i386 但是它将不会被安装
依赖: libcups2:i386 但是它将不会被安装
依赖: libglib2.0-0:i386 但是它将不会被安装
依赖: libsm6:i386 但是它将不会被安装
依赖: libxrender1:i386 但是它将不会被安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ceea57fd4f71195a24563fae619cde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1695c0bda357d6e435d8b6a6cbeee1a1/" rel="bookmark">
			autodl运行ollama报错Failed to connect to bus: Host i&amp;Error, pkgProblemResolver::Resolve generated breaks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行systemctl start ollama报错：
System has not been booted with systemd as init system (PID 1). Can’t
operate. Failed to connect to bus: Host is down
其实是未安装systemctl；
那么安装systemctl：
apt-get install systemctl 又报错：
E: Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages
发生故障，这可能是有软件包被要求保持现状的缘故。 E: 无法更正依赖关系
解决办法：
sudo aptitude install &lt;packagename&gt; 系统给出解决方案：
是否接受该解决方案？[Y/n/q?] 输入 Y，等待！
如果显示没有"aptitude"这个命令，安装它
sudo apt-get install aptitude 再次安装，问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676f3d853263f740017bdcba4da9f62a/" rel="bookmark">
			测试的基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是需求？ 在企业中主要分为两类：用户需求和软件需求
用户需求：甲方的需求，或者终端用户使用产品时必须要完成的任务（比较简略）。
软件需求：或者叫功能需求，该需求会详细描述开发人员必须实现的软件功能。
注：开发人员和测试人员的直接工作依据就是软件需求。
用户需求通过 技术、市场、成本 等转变成软件需求。
2、什么是测试用例？ 测试用例是为了实施测试而向被测试的系统提供的一组集合，这组集合包含：测试环境、操作步骤、测试数据、预期结果。
3、Bug Bug的概念：当且仅当规格说明是存在的并且正确，程序与规格说明之间的不匹配才是错误的。当程序没有实现其最终用户合理预期的功能要求时，就是软件错误。 4.软件生命周期和测试生命周期 软件开发的生命周期 注：从产品的角度分析，测试是在开发之后，；从测试的角度分析，测试又是贯穿于产品的整个生命周期。
软件测试的生命周期：
5、 如果线上出现了问题，测试人员该怎么做？ 尝试复现（普遍都存在的问题还是个别问题，个别问题优先级低一些）复现成功之后通知项目组内所有成员进行问题定位。尝试定位问题出现的原因，帮助开发人员尽快定位问题并解决问题反思问题（为什么会出现问题、如何解决、后续如何避免），如果问题比较严重或者比较典型的话：通常需要写一个文档。 6、开发模型 6.1 瀑布模型 特点：
线性结构，每个阶段只执行一次是其他模型的基础框架 缺点：
测试后置 前面各阶段遗留的风险推迟到测试阶段才被发现，导致项目大面积返工，失去了及早修复的机会。必须留有足够的时间给测试活动，否则到时测试不充分，将缺陷暴露给用户（产品质量差）。 周期太长，产品很迟才能被看到和使用，可能导致需求功能过时 使用场景：需求固定的小项目
6.2 螺旋模型 特点：螺旋模型中增加了风险分析和原型
缺点：
项目中可能存在的风险与风险管理人员的技能水平有直接关系需要人员、资金、时间的增加和投入，可能会导致项目的成本太高 使用场景：规模庞大、复杂度高、风险大的项目尤其合适
6.3 增量模型和迭代模型 增量模型：把大的需求划分成一个个可以独立开发上线的功能。
迭代模型：先开发基础版本，然后再基础版本上不断进行功能的完善。
6.4 敏捷模型 敏捷宣言：
考核标准：可交付的软件
特点：轻流程、轻文档、重目标、重产出。
scrum模型（三个角色和五个重要会议）： 三个角色:产品经理、项目经理、研发团队
五个重要会议：发布计划会议、迭代计划会议、每日会议、演示会议、回顾会议。
7、测试模型 7.1 V模型 特点：
测试过程中存在不同类型的测试测试阶段的参考标准以前面对应阶段为准 缺点：测试后置
前面各阶段遗留的风险推迟到测试阶段才被发现，导致项目大面积返工，失去了及早修复的机会。必须留有足够的时间给测试活动，否则到时测试不充分，将缺陷暴露给用户（产品质量差）。 单元测试：对程序最小单元进行测试，最小单元可能是一个类、一个方法、一个接口
7.2 W模型 特点：
测试的对象不仅是程序，需求、设计等同样要测试，测试与开发是同步进行的 有利于尽早地全面的发现问题。 缺点：W模型重流程，不能够迎接变化，不适用于敏捷模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1cf5023d9d6bfc6c3b497e7752695f8/" rel="bookmark">
			C&#43;&#43; 之路如逆水行舟 不进则退
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 核心编程 内存分区模型 C++ 程序在执行时，将内存大方向划分为 4 个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放 , 存放函数的参数值 , 局部变量等 堆区：由程序员分配和释放 , 若程序员不释放 , 程序结束时由操作系统回收 内存四区意义：灵活，执行效率快，方便管理 不同区域存放的数据，赋予不同的生命周期 , 给我们更大的灵活编程 1.1 程序运行前 在程序编译后，生成了 exe 可执行程序， 未执行该程序前 分为两个区域 代码区：共享，app多次可以大概，只读，不能修改内容 存放 CPU 执行的机器指令 代码区是 共享 的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是 只读 的，使其只读的原因是防止程序意外地修改了它的指令 全局区： 全局变量和静态变量存放在此 . 全局区还包含了常量区 , 字符串常量和其他常量也存放在此 . == 该区域的数据在程序结束后由操作系统释放 ==. 总结： C++ 中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const 修饰的全局常量 和 字符串常量 #include &lt;iostream&gt; using namespace std; // 1.3全局变量global全球 int g_a = 10; int g_b = 10; // const 修饰全局变量 const int g_c = 10; int main() { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1cf5023d9d6bfc6c3b497e7752695f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb7e3944d80ce02d32b37b81fc2942b/" rel="bookmark">
			uniapp写小程序实现清除缓存（存储/获取/移除/清空）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在uni-app中，可以使用uni.setStorageSync和uni.getStorageSync来进行数据的存储和获取。而移除缓存数据可以使用uni.removeStorageSync，清空缓存数据可以使用uni.clearStorageSync。
以下是使用示例：
存储数据：
uni.setStorageSync('key', 'value'); 获取数据：
var value = uni.getStorageSync('key'); 移除数据：
uni.removeStorageSync('key'); 清空缓存数据：
uni.clearStorageSync(); 注意：以上方法都是同步方法，如果需要异步操作，可以使用uni.setStorage和uni.getStorage方法。
存储数据示例：
uni.setStorage({ key: 'key', data: 'value', success: function () { console.log('存储成功'); } }); 获取数据示例：
uni.getStorage({ key: 'key', success: function (res) { var value = res.data; console.log('获取成功：' + value); } }); 移除数据示例：
uni.removeStorage({ key: 'key', success: function () { console.log('移除成功'); } }); 清空缓存数据示例：
uni.clearStorage({ success: function () { console.log('清空成功'); } }); 以上就是在uni-app中进行数据缓存的常用方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3fe430bf9e50e5d23e112ee061cfc67/" rel="bookmark">
			使用 FFmpeg 轻松调整视频的大小/缩放/更改分辨率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在此 FFmpeg 教程中，我们学习使用 FFmpeg 的命令行工具更改视频的分辨率（或调整视频的大小/缩放）。
更改视频的分辨率（也称为调整大小或缩放）是视频编辑、处理和压缩中非常常见的操作。对于 ABR 视频流尤其如此，其中将单个视频作为源并压缩为多个不同的比特率分辨率组合。例如，输入视频的分辨率可以是1920x1080，ABR 比特流可以是1280x720,640x480等。
因此，作为第一步，让我们找出输入视频的分辨率是多少。使用FFmpeg 版本附带的工具ffprobe，让我们确定输入视频的分辨率。这是使用ffprobe.
ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 input.mp4 此命令的输出应该与您的控制台上显示的1920x1080。太好了——您现在知道视频的分辨率并且现在可以缩放或更改分辨率。
注意：您必须注意，向上/向下缩放的行为是一个有损过程，会导致视频质量有所下降。
如何使用 FFmpeg 调整/缩放/更改视频的分辨率？ 使用 FFmpeg 缩放或更改视频的分辨率是由FFmpeg 中的过滤器scale完成的。要使用scale过滤器，请使用以下命令 –
ffmpeg -i input.mp4 -vf scale=$w:$h &lt;encoding-parameters&gt; output.mp4 其中，$w和$h表示目标视频所需的宽度和高度。例如，您可以使用-vf scale=640:480将视频大小调整为480p.
而已！使用这个简单的命令，您可以使用 FFmpeg 更改视频的分辨率。
并且，在 FFmpeg 更改视频的分辨率后，它将以该分辨率重新编码。在上面的命令行中，您可以向 FFmpeg 提供编码参数，并使用这些参数对缩放后的视频进行编码。例如，您可以告诉 FFmpeg 使用 crf=18 进行编码，以获得高质量的 H.264/AVC 编码，或者选择其他编码方式！
好的，让我们来解决下一个主题，即更改视频的分辨率但保留/保持其纵横比。
如何使用 FFmpeg 在保持高质量的同时调整视频大小 调整大小后，您可能会注意到输出视频的质量很差或达不到您的预期。通过告诉 FFmpeg 您希望在调整大小过程后使用的视频编码参数，可以轻松解决此问题。
这是一个例子——
ffmpeg -i input.mp4 -vf scale=1280:720 -preset slow -crf 18 output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3fe430bf9e50e5d23e112ee061cfc67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68368e06aa4e482c7285d3b14aaac141/" rel="bookmark">
			基于 Flink 的实时数仓在曹操出行运营中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文整理自曹操出行基础研发部负责人史何富，在 Flink Forward Asia 2023 主会场的分享。本次分享将为大家介绍实时数仓在曹操出行（互联网网约车出行企业）的实时数仓应用场景，以及通过离线场景向实时场景下加速升级而获得的业务价值。内容主要分为以下六部分：
业务简介实时数仓解决业务痛点曹操出行实时数仓运营落地及收益未来规划用户对话环节 一、业务简介 曹操出行创立于 2015 年 5 月 21 日，是吉利控股集团布局「新能源汽车共享生态」的战略性投资业务，以「科技重塑绿色共享出行」为使命，将全球领先的互联网、车联网、自动驾驶技术以及新能源科技创新应用于共享出行领域，以「用心服务国民出行」为品牌主张，致力于打造服务口碑最好的出行品牌。
曹操出行目前为止已经在全国 62 个城市落地运营，投放了超过 10 万辆新能源纯电车，累计注册司机超过 350 万，服务乘客超过 1.5 亿。另外一块非常重要的业务是企业用户，目前为止服务企业用户超过 1500 万家。
二、实时数仓解决业务痛点 介绍三类主要的实时数据相关需求。
首先是管理层， 管理者需要随时随地看到公司运营状况，从概念性数据到每个城市不同维度的实时数据，需要一个方便使用的掌上工具随时发现运营中的问题，能够快速定位到什么环节出现了问题，同时也可以发现一些潜在的业务机会。
第二是一线运营，团队在每个城市或者总部的运营官需要一个能够聚焦自己负责范围的工具。
第三是算法团队，互联网的出行业务与过去不同，它不是一个放养的简单模式，把车放在路上去跑，乘客打车，就实时把乘客和司机按照最短距离进行匹配。现在团队有自己的交易引擎和调度引擎，这些都是依赖于实时数据的，数据越新鲜算法效果越好。
三、曹操出行实时数仓 团队设计的实时数仓层次主要讲三点，对应三类需求。通过 Flink 一整套实时计算引擎产生团队指标体系，OLAP 引擎将数据做实时分析给运营人员，把实时数据反馈给算法模型从而更好地进行决策。数据来自不同数据源，手机端 APP 包括乘客端和车机端，车机的数据会实时流到团队后台 Flink，业务日志通过消息队列到 Flink 的集群，最后生成数据到 OLAP 引擎、数据库等。
四、运营落地及收益 介绍一些基于实时数据开发的数据产品。
观星台：
团队开发了一个叫做观星台的掌上工具，基本上包含了全公司实时和历史的各维度运营数据，包括目前乘客的需求、毛利达成情况、补贴发放、甚至哪个区域的需求比较多等。
天机镜：
针对运营类团队做的一个基于时空可视化的运营工具。团队人员及城市负责人可以随时随地查看当前负责城市任何区域的运营状况。把一个城市在 H3 网格分割成很多角度，每个 H3 网格都有自己的运营状态，包括目前里面有多少车或是未来 10 分钟、20 分钟后会有多少车。甚至也做了一些预测的功能衡量需求是否溢出，可以回放整个需求和运力供需关系的变化。因为有时候不可能一天 24 小时每时每刻都盯着盘，工具可以设定一些告警的策略以便团队的使用。这些策略都可以主动感知异常，然后通过各种方式，比如钉钉短信甚至电话通知到用户，目前他所负责的区域或城市有哪些需要关注的变化。
实时看板：
CBD看板， C 指的是团队的乘客，B 指的是司机，D 指的是城市区域。包括给到团队一线运营人员的数据产品和工具，以便更好地做出人工决策，采取干预措施。
算法：
实时数据很好地反哺了团队的算法模块，因为目前整个交易引擎和调度引擎不再像以前那么简单直接，已经全部算法化。比如从一个学校出发，可能分配直线距离最近的一辆空闲车辆。这种派单模式效率非常低，已经不能适应现在网约车的业务状态。当前，团队需要用算法的角色，比如需要根据乘客的对车型的需求和目的地；以及司机的荣耀分，是否疲劳，是否开启回家模式；出发地和目的地的供需状况等多重特征，纳入算法决策的考量。团队需要非常新鲜的数据给到算法团队，才能使整个交易的收益，包括平台和司机，达到最优。通过实时的基于 Flink 一整套流计算，再产生各类指标、实时特征给到团队算法引擎。网约车行业不可能再像过去一样不考虑运营成本给乘客、司机大量发补贴。团队需要想尽办法提升运营的效率，做到不伤害任何一方，当然也能够保证平台健康运营。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68368e06aa4e482c7285d3b14aaac141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae7779206d2adade95ea8e528b11128/" rel="bookmark">
			mysql-ReadView规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql-ReadView规则 都知道ReadView和Undo log用来实现MVCC机制
ReadView作用 ReadView解决了行的可见性问题ReadView适用的隔离级别：READ COMMITTED读已提交 和 REPEATABLE READ可重复读。核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题 ReadView组成 creator_trx_id：创建这个ReadView的事务id。 说明:只有在对表中的记录做改动时（执行INSERT、DFLETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0 trx_ids：表示在某个事务生成ReadView时当前系统中活跃的读写事务的事务id列表up_limit_id：活跃的事务中最小的事务idlow_limit_id：表示生成ReadView时系统中应该分配给下一个事务的id值。low_limit_id是系统最大的事务id值，这里要注意是系统中的事务id，不是正在活跃的事务id列表中的事务id 注意: low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4 ReadView规则 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。如果被访问版本的trx_id属性值小于ReadView中的up_limit_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。如果被访问版本的trx_id属性值大于或等于ReadView中的low_limit_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。如果被访问版本的trx_id属性值在ReadView的up_limit_id和low_limit_id之间，那就需要判断一下trx_id属性值是不是在trx_ids列表中。 如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问 good luck!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d226fa7a1c265513e232d096bfe611/" rel="bookmark">
			mysql-RR级别存在幻读问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql-RR级别存在幻读问题 结论：RR级别下存在幻读，但也可以避免
快照读和当前读 快照读 读取版本链上最新可见的数据 当前读 select * from table for updateselect * from table in share mode 准备 mysql&gt; select * from t_user; +----+-------------------+--------+ | id | user_name | age | +----+-------------------+--------+ | 1 | test2dsd | 121 | | 2 | sdfsd23323 | 123234 | | 3 | sdseerer | 32 | | 4 | sdfsdfdsfsd | 33 | | 5 | tomw232232-2 | 323 | | 6 | sadfsadsdf-cdsfsd | 12 | RR幻读模拟 步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37d226fa7a1c265513e232d096bfe611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83755e8838b05856fa318aaa508d01e3/" rel="bookmark">
			Prometheus 监控容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		容器监控：cAdvisor Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux/Windows/Mac机器上。容器镜像正成为一个新的标准化软件交付方式。
例如，可以通过以下命令快速在本地启动一个Nginx服务：
docker run -itd nginx 为了能够获取到Docker容器的运行状态，用户可以通过Docker的stats命令获取到当前主机上运行容器的统计信息，可以查看容器的CPU利用率、内存使用量、网络IO总量以及磁盘IO总量等信息。
$ docker stats CONTAINER CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 9a1648bec3b2 0.30% 196KiB / 3.855GiB 0.00% 828B / 0B 827kB / 0B 1 除了使用命令以外，用户还可以通过Docker提供的HTTP API查看容器详细的监控统计信息。
使用CAdvisor CAdvisor是Google开源的一款用于展示和分析容器运行状态的可视化工具。通过在主机上运行CAdvisor用户可以轻松的获取到当前主机上容器的运行统计信息，并以图表的形式向用户展示。
在本地运行CAdvisor也非常简单，直接运行一下命令即可：
docker run \ --volume=/:/rootfs:ro \ --volume=/var/run:/var/run:rw \ --volume=/sys:/sys:ro \ --volume=/var/lib/docker/:/var/lib/docker:ro \ --publish=8080:8080 \ --detach=true \ --name=cadvisor \ google/cadvisor:latest 通过访问http://localhost:8080可以查看，当前主机上容器的运行状态，如下所示：
CAdvisor可视化：CPU总量
CAdvisor是一个简单易用的工具，相比于使用Docker命令行工具，用户不用再登录到服务器中即可以可视化图表的形式查看主机上所有容器的运行状态。
而在多主机的情况下，在所有节点上运行一个CAdvisor再通过各自的UI查看监控信息显然不太方便，同时CAdvisor默认只保存2分钟的监控数据。好消息是CAdvisor已经内置了对Prometheus的支持。访问http://localhost:8080/metrics即可获取到标准的Prometheus监控样本输出:
# HELP cadvisor_version_info A metric with a constant '1' value labeled by kernel version, OS version, docker version, cadvisor version &amp; cadvisor revision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83755e8838b05856fa318aaa508d01e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48dd29ea8ea26362cd5f24cf17c0b4e/" rel="bookmark">
			Prometheus告警处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prometheus告警简介 告警能力在Prometheus的架构中被划分成两个独立的部分。如下所示，通过在Prometheus中定义AlertRule（告警规则），Prometheus会周期性的对告警规则进行计算，如果满足告警触发条件就会向Alertmanager发送告警信息。
Prometheus告警处理
在Prometheus中一条告警规则主要由以下几部分组成：
告警名称：用户需要为告警规则命名，当然对于命名而言，需要能够直接表达出该告警的主要内容告警规则：告警规则实际上主要由PromQL进行定义，其实际意义是当表达式（PromQL）查询结果持续多长时间（During）后出发告警 在Prometheus中，还可以通过Group（告警组）对一组相关的告警进行统一定义。当然这些定义都是通过YAML文件来统一管理的。
Alertmanager作为一个独立的组件，负责接收并处理来自Prometheus Server(也可以是其它的客户端程序)的告警信息。Alertmanager可以对这些告警信息进行进一步的处理，比如当接收到大量重复告警时能够消除重复的告警信息，同时对告警信息进行分组并且路由到正确的通知方，Prometheus内置了对邮件，Slack等多种通知方式的支持，同时还支持与Webhook的集成，以支持更多定制化的场景。例如，目前Alertmanager还不支持钉钉，那用户完全可以通过Webhook与钉钉机器人进行集成，从而通过钉钉接收告警信息。同时AlertManager还提供了静默和告警抑制机制来对告警通知行为进行优化。
Alertmanager特性 Alertmanager除了提供基本的告警通知能力以外，还主要提供了如：分组、抑制以及静默等告警特性：
Alertmanager特性
分组 分组机制可以将详细的告警信息合并成一个通知。在某些情况下，比如由于系统宕机导致大量的告警被同时触发，在这种情况下分组机制可以将这些被触发的告警合并为一个告警通知，避免一次性接受大量的告警通知，而无法对问题进行快速定位。
例如，当集群中有数百个正在运行的服务实例，并且为每一个实例设置了告警规则。假如此时发生了网络故障，可能导致大量的服务实例无法连接到数据库，结果就会有数百个告警被发送到Alertmanager。
而作为用户，可能只希望能够在一个通知中中就能查看哪些服务实例收到影响。这时可以按照服务所在集群或者告警名称对告警进行分组，而将这些告警内聚在一起成为一个通知。
告警分组，告警时间，以及告警的接受方式可以通过Alertmanager的配置文件进行配置。
抑制 抑制是指当某一告警发出后，可以停止重复发送由此告警引发的其它告警的机制。
例如，当集群不可访问时触发了一次告警，通过配置Alertmanager可以忽略与该集群有关的其它所有告警。这样可以避免接收到大量与实际问题无关的告警通知。
抑制机制同样通过Alertmanager的配置文件进行设置。
静默 静默提供了一个简单的机制可以快速根据标签对告警进行静默处理。如果接收到的告警符合静默的配置，Alertmanager则不会发送告警通知。
静默设置需要在Alertmanager的Werb页面上进行设置。
自定义Prometheus告警规则 Prometheus中的告警规则允许你基于PromQL表达式定义告警触发条件，Prometheus后端对这些触发规则进行周期性计算，当满足触发条件后则会触发告警通知。默认情况下，用户可以通过Prometheus的Web界面查看这些告警规则以及告警的触发状态。当Promthues与Alertmanager关联之后，可以将告警发送到外部服务如Alertmanager中并通过Alertmanager可以对这些告警进行进一步的处理。
定义告警规则 一条典型的告警规则如下所示：
groups: - name: example rules: - alert: HighErrorRate expr: job:request_latency_seconds:mean5m{job="myjob"} &gt; 0.5 for: 10m labels: severity: page annotations: summary: High request latency description: description info 在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：
alert：告警规则的名称。expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。 为了能够让Prometheus能够启用定义的告警规则，我们需要在Prometheus全局配置文件中通过rule_files指定一组告警规则文件的访问路径，Prometheus启动后会自动扫描这些路径下规则文件中定义的内容，并且根据这些规则计算是否向外部发送通知：
rule_files: [ - &lt;filepath_glob&gt; ... ] 默认情况下Prometheus会每分钟对这些告警规则进行计算，如果用户想定义自己的告警计算周期，则可以通过evaluation_interval来覆盖默认的计算周期：
global: [ evaluation_interval: &lt;duration&gt; | default = 1m ] 模板化 一般来说，在告警规则文件的annotations中使用summary描述告警的概要信息，description用于描述告警的详细信息。同时Alertmanager的UI也会根据这两个标签值，显示告警信息。为了让告警信息具有更好的可读性，Prometheus支持模板化label和annotations的中标签的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c48dd29ea8ea26362cd5f24cf17c0b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c6a2374bb329952de6097b1cfbf412/" rel="bookmark">
			P2717 寒假作业 CDQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寒假作业 传送门 题目背景 zzs 和 zzy 正在被寒假作业折磨，然而他们有答案可以抄啊。
题目描述 他们共有 n n n 项寒假作业。zzy 给每项寒假作业都定义了一个疲劳值 a i a_i ai​，表示抄这个作业所要花的精力。
zzs 现在想要知道，有多少组连续的寒假作业的疲劳值的平均值不小于 k k k？
简单地说，给定一个长度为 n n n 的正整数序列 { a i } \{a_i\} {ai​}，求出有多少个连续子序列的平均值不小于 k k k。
输入格式 第一行是两个整数，分别表示序列长度 n n n 和给定的参数 k k k。
第二行有 n n n 个整数，第 i i i 个整数表示序列的第 i i i 个数字 a i a_i ai​。
输出格式 输出一行一个整数表示答案。
样例 #1 样例输入 #1 3 2 1 2 3 样例输出 #1 4 提示 样例 1 解释 共有 6 6 6 个连续的子序列，分别是 ( 1 ) (1) (1)、 ( 2 ) (2) (2)、 ( 3 ) (3) (3)、 ( 1 , 2 ) (1,2) (1,2)、 ( 2 , 3 ) (2,3) (2,3)、 ( 1 , 2 , 3 ) (1,2,3) (1,2,3)，平均值分别为 1 1 1、 2 2 2、 3 3 3、 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c6a2374bb329952de6097b1cfbf412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ab1d4ceb5aba42c7f3602f6968931d/" rel="bookmark">
			Python数据分析案例37——基于分位数神经网络(QRNN)的汇率预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例背景 我导师的研究方向是少有的做"分位数回归"方向，作为研究机器学习深度学习方向的我自然就继承了这个特色，改进出了很多特殊结合方法，我会结合各种机器学习方法和各种分位数回归的方法。
之前写过分位数随机森林，分位数XGboost，分位数Lightgbm的文章：
Xgboost和Lightgbm结合分位数回归(机器学习与传统统计学结合)
本次带来一个小案例，分位数神经网络，神经网络是最简单的MLP架构，也就是很多外行论文里面所说的BP神经网络，结合分位数回归，就变成了'QRNN'。
数据介绍 本次做的是汇率的预测，即使用这样一个数据集：“汇率 外汇储备 M2 美国CPI 国债利率 贸易顺差”。用后面五个变量预测汇率。
需要本次案例演示的数据和全部代码的同学可以参考：汇率数据
方法流程 一般我不会写这个版块的，一般都是跟着代码走，但是由于这次做的模型较为复杂，不仅是QRNN模型，更是涉及到分位数的参数，不同的分位水平，然后进行不同条件分布下的X对y的参数估计，形成了一个分布，然后再根据这个数据分布，进行包含留一交叉验证选择的带宽，再根据这个最优带宽进行核密度估计。然后再将核密度估计转化为不同情况下的（众数，中位数，均值）点估计。然后再去和真实值做对比，计算误差评价指标。(区间估计就不弄了，没必要....)
这个流程对于一般的同学来说复杂了，虽然对我来说只是一个研究之余随便搞点代码写的小案例....但很多不了解这些技术和方法的同学肯定看不懂。因为一般的同学做预测都是点估计，机器学习估计出来的都是一个点，一个具体数值，他们不懂啥是概率密度估计。我不打算介绍我这些东西的原理，因为大部分做这个方面的论文里面都有，我自己都是看论文学的(当然都是SCI论文)，真的想研究的同学应该是明白我在做什么的，可以借鉴我这个小案例，然后推广到更多的数据和方法上。
简而言之就是基于QRNN模型做的概率密度估计。
并且我还会使用线性回归，线性分位数回归，普通神经网络，分位数神经网络去做一个预测误差的对比。
代码实现 开始写代码！导入包：
import os ,io import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns plt.rcParams['font.sans-serif']=['SimHei'] plt.rcParams['axes.unicode_minus']=False import tensorflow as tf import keras from keras.models import Model, Sequential from keras.models import Sequential from keras.layers import LSTM, Dense,Flatten from keras.callbacks import EarlyStopping from sklearn.preprocessing import MinMaxScaler from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40ab1d4ceb5aba42c7f3602f6968931d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a06ce60907f7d5de69892c750abc6d/" rel="bookmark">
			微服务不死 — 共享变量在策略引擎项目的落地详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01
背景 1、共享变量的提出 前段时间，来自亚马逊 Prime Video 团队的一个案例研究在开发者社区中掀起了轩然大波。大体是这样一件事，作为一个流媒体平台，Prime Video每天都会向客户提供成千上万的直播流。为了确保客户无缝接收内容，Prime Video需要构建一个监控工具来识别客户所查看的每个流中的质量问题，这提出了极高的可扩展性要求。
对此，Prime Video团队优先考虑了微服务架构。由于微服务能够将单体应用分解为多个模块，这不仅能解决工具独立开发和部署的问题，还能为应用提供更高的可用性、可靠性以及技术多样性。最终，Prime Video的服务由三个部分组成，媒体转换器将音视频流发送到检测器的音视频缓冲区；缺陷检测器执行算法，并在发现缺陷时发送实时通知；第三个组件则提供控制服务流程的编排。
当更多流加入到服务中时，成本过高问题开始逐渐显现。由于AWS Step按照函数状态转换向用户收费，当需要处理大量流的时候，大规模运行基础设施的开销会变得非常昂贵，所有构建模块的总成本过高，导致Prime Video团队无法大规模接受最初的解决方案。最终，Prime Video团队重构了基础设施，从微服务迁移到了单体架构，据他们的数据，基础设施成本降低90%。
这件事情也让我们更加的注意到，分布式架构相比单体服务架构同样存在缺点。比如Prime Video 团队遇到问题：分布式架构无法像单体架构那样共享变量，从而导致底层服务处理更多相同的请求进而产生成本飙升的问题。这样的困境在爱奇艺海外架构中同样存在，特别明显的是在策略引擎的调用关系上。
2、爱奇艺海外策略引擎调用关系 2.1 策略引擎调用关系介绍 其中，card是页面内的每个栏目的细分模块，通常如电视剧，电影等专栏是一个card。每个card内的数据源都不同，比如有从营销获取营销类数据，有从推荐获取的内容，还有从奇普获取节目内容等。其中这里面有存在关联关系，比如页面关联在导航下面，而card关联在页面下，card内的具体业务数据关联在card下面。
策略引擎是识别人群的匹配服务，如目前配置一条人群策略，里面内容是日本黄金会员，男性，会员到期天数小于7天，偏爱日本动漫。策略引擎服务可以识别某用户是否属于以上人群策略。
在“一切皆可策略”的技术改造之后，已经实现了导航、页面、card、card内数据的用户画像维度定制的能力。大体的实现方式如下：当客户端发起一个请求时，首先请求导航API。在导航数据配置后台，运营同学配置了不同的导航数据，每条导航数据关联了一个策略。导航API内部获取全部导航数据，然后将导航关联的策略与该用户uid和设备id作为入参请求策略引擎，策略引擎进行匹配将满足匹配的策略返回，导航API内部将满足要求的策略关联的导航数据返回，这样实现了不同用户画像看到了不同的导航数据的能力。页面、card、card内数据实现方式大体相同。
从以上的内容可以总结，在策略引擎的调用链路上存在以下特点：
（1）用户打开页面的一次操作会串联调用多次策略引擎服务。
（2）策略引擎接口性能直接影响用户体验：关联很多页面业务服务的请求。
（3）策略引擎数据要求强实时性 ：用户购买会员后应该立刻关联到会员相关策略。
2.2 遇到的困境 从上节调用关系可知，策略引擎作为底层服务，承接了较多业务方的流量，而策略引擎判断人群策略是否匹配需要获取用户画像数据，这又强依赖了DMP(Data Management Platforms)服务。为了减少对DMP服务的流量，我们思考了本地缓存的方案。
但是这存在的问题很明显，即无法满足数据实时性要求。当用户购买了会员，DMP服务返回的画像数据变更时，因为本地缓存的延迟而导致用户无法看到最新的策略关联数据，这显然是无法忍受的。
同样我们思考了分布式缓存方案。如果使用用户id为key，其痛点和本地缓存一样，无法满足实时性要求。
因此，如何在满足数据实时性要求的情况下，优化对DMP服务的流量是整个策略引擎项目优化的挑战点。
02
共享变量的曙光 1、概述 困境问题的关键在于，分布式服务无法共享变量。用户的一次页面打开行为伴随着多个后端请求，而这些多个后端请求关联的用户画像数据其实是一个，即从DMP服务获取的画像数据一定是相同的。下面我们对策略引擎的调用链路进行抽象分析，看看有哪些特性。
2、策略引擎调用链路分析 策略引擎的调用关系 在1.2.1 策略引擎调用关系介绍章节当中已经介绍，本次主要对其调用链路进行抽象分类。
2.1 串行调用场景 从上图可以看到，一个用户发起一个请求，经过多个节点服务，而节点服务间是串行关系，而每个节点都依赖了策略引擎服务，策略引擎服务都需要获取该用户的画像数据，而很显然，T1到Tn的请求都是同一个用户，DMP服务获取的数据一定是相同的，那么，如果使用共享变量的思路，可以将T1 ～ Tn次对DMP服务的请求优化为1个请求。我们把这里从DMP服务获取到的画像数据命名为分布式共享变量。
2.2 并行调用场景 与上面串行调用链不同，串行调用T1到Tn是有时间先后顺序，T1调用一定在T2调用前面。而并行调用没有先后时间顺序，即可能同一个用户发起一次请求，在聚合层业务同时对依赖服务发起请求，依赖服务又依赖了策略引擎，所以，对于同一个用户发起的一次请求，就会同时对策略引擎发起多次请求。那么如果将多次请求放置于一个队列，其中第一个请求去实际的请求DMP服务，其余请求在队列中等待第一个请求的数据，n个请求就可以优化为1个请求。我们把这里从DMP服务获取到的画像数据称为本地共享变量。
03
分布式共享变量介绍 1、原理概述 到用户打开页面的时候，客户端会请求导航，然后依次获取特点页面，特定card和特点的card内数据。每个环节都会涉及到策略引擎服务。正常情况下，一次客户端请求将会引发多次策略引擎的调用，从而引起多次对DMP服务的调用。但是很显然，这都是同一个用户的一次请求，这几次对DMP服务的请求获取的用户画像数据一定是相同的。
基于以上分析，分布式共享变量的原理简单描述就是，当【导航】第一次获取到画像数据后，将其内容放在请求链路中，类似于全链路的TraceId一样向下传递。这样下游如【页面】再请求策略引擎时，则可以直接获取链路上下文TraceContext中的链路数据使用，而无需再请求DMP服务。对于CARD，和页面业务同样如此。
值得一提的是，TraceContext只能通过request向下传递。这样在存放链路数据的时候只能是在【导航】获取到策略引擎数据后，将画像数据放置到链路上下文TraceContext中。
如果导航没有关联策略数据，无需请求策略引擎，但是后面的页面、CARD等又关联了策略引擎，那该怎么处理呢？我们参考了TraceId的处理方式，在每个调用策略引擎服务的节点(不同业务如页面、CARD等)进行判断是否有链路数据，如果没有，则获取策略引擎数据后放置进去，如果有则忽略。这样就保证最前置的节点拿到画像数据后，进行向后传递，减少后续节点对于DMP服务的流量。很明显，这些逻辑有一些业务侵入性，所以我们将调用策略引擎的方式优化为SDK调用，在SDK内部做了一些统一的逻辑处理，让业务调用方无感知。
2、全链路追踪 — 基于SkyWalking skywalking 是分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器化技术（docker、K8s、Mesos）架构而设计，它是一款优秀的 APM（Application Performance Management）工具。skywalking 是观察性分析平台和应用性能管理系统。提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。对于为什么选择skywalking，除去skywalking本身的优势以外，业务上的理由是爱奇艺海外项目目前已经接入SkyWalking，开发成本最低，维护更加便利。所以，使用skywalking传递分布式共享变量只需要引入一个Maven依赖，调用其特有的方法，就可以将数据进行链路传递。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a06ce60907f7d5de69892c750abc6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dfd1b70ee371a8d1be121f8ab490d99/" rel="bookmark">
			人大金仓数据库SQL之KES获取用户组成员信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键字： SQL、用户组成员信息、人大金仓、KingbaseES
前言 KES中用户组成员的oid以数组的形式存储在视图sys_usergroup中、成员的详细信息存储于系统表sys_ authid中。
现需求如下：执行一次查询，获取指定用户组的成员的详细信息。
分析：可以通过sys_usergroup视图获取指定用户组的成员oid，再根据获取到的成员oid到系统表sys_ authid中获取成员的详细信息。
难点：用户组成员的oid以数组的形式存储在视图sys_usergroup中，联立查询时如何处理成员oid数组？
解决：通过函数UNNEST和函数ANY解决
UNNEST（） UNSEST函数用于在SQL中将数组解包为一行行的元素。通常情况下，一个数组是作为单个值存储在数据库中的。但是，当需要对数组中的单个元素进行查询时，就需要使用UNNEST函数将其解包后再进行查询操作；
UNNEST函数简单使用示例如下：
SELECT UNNEST('{1,2,3,4,5,6,7}'::INT[]);
执行上述SQL可得到结果如下：
KES中用户组成员的oid以数组的形式存储在视图sys_usergroup中，执行SQL：SELECT * FROM sys_usergroup结果如字段group_members：
使用UNNEST函数查询用户组oid为18482的字段group_memebers，执行SQL：SELECT UNNEST(group_members) FROM sys_usergroup WHERE group_oid =18482结果如下：
可以看到成员OID数组被展开为行数据了。
ANY（） ANY函数是在SQL语言中用于判断值与集合的关系的函数。它通常用于子查询中，用来判断一个值是否在一个集合中。
其用法如下：value operator ANY(subquery)
value是要进行判断的值，operator是比较操作符（=、&lt;、&gt;等），subquery是一个子查询，用来返回一个值的集合
获取用户组成员详细信息 综上所述可以得到SQL：
SELECT * FROM sys_authid a WHERE a.oid = any (SELECT UNNEST(group_members) FROM sys_usergroup WHERE group_oid =18482)
执行结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c551afc867cff383e8e38fd68cdc4c/" rel="bookmark">
			人大金仓数据库--实例、数据库、模式、表空间之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键字： KingbaseES、实例、数据库、模式、表空间、人大金仓
概述 数据库从字面理解就是存放数据的仓库，我们平时说的KingabseES数据库实际上是指数据库管理系统(DBMS, DataBase Management System)，是一种操纵和管理数据库的软件，用于建立、使用和维护数据库。本文简单介绍了KingBaseES数据库中的实例、数据库、模式、表空间的概念与它们之间的关联以及在数据库系统中的组成部分。
2. KingbaseES数据库体系
在数据库中，一个实例对应一个数据库用户，在一个实例下，包含了多个数据库，用户可以根据自身的需求，建立不同的数据库，将数据分开存放；一个数据库中又包含了多个对象，而这些对象也就是我们所说的数据本身，可以理解为数据文件；从逻辑上理解，表空间就是用于存放数据，每个数据文件存放在一个指定的表空间中，而一个表空间可以存放多个数据文件甚至是不同模式、不同数据库中的数据文件。
2.1 数据库实例
数据库实例可以理解为一个程序，是位于用户和操作系统之间的一层数据管理软件，是访问数据库的通道；用户对数据库中的数据做任何的操作，包括数据定义、数据查询、数据维护、数据库运行控制等操作都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。
在KingbaseES数据库中，不同用户通过不同的实例与数据库服务器建立连接，不同实例可以兼容不同模式的数据库，我们可以通俗的理解为一个实例即为一个数据库用户。
2.2 数据库(Database)
数据库在这里实际上是一个逻辑上的概念，对应的实体是数据库管理软件存储在硬盘上的数据库；一个实例下可以包含多个数据库，用户可以根据自身的需求才存放不同的数据。以下是对数据库的相关操作：
查看数据库信息：\l 创建数据库：create database 数据库名 owner 属主名 修改数据库：对数据库改名：alter database 数据库名 rename to 新名称; 更改数据库属主：alter database 数据库名 owner to 属主名; 删除数据库：drop database 数据库名; 2.3 模式(Mode) 模式是数据库中的一个概念，可以将其理解为一个命名空间或者目录，不同的模式下面可以有相同名称的表、函数等数据库对象。提出模式的概念是为了方便管理，只要有权限，各个模式之间也能相互调用。可以理解为模式是对数据库的逻辑分隔，用户可以根据需求不同，将数据库划分为不同的模式，在不同的模式下存放不同类型的数据。
一个数据库可以包含多个模式，模式中又包含了表、函数等其他数据库对象。以下是一些对于数据库模式的常见操作：
查看数据库中的模式列表：\dn+ 其中，public模式为创建数据库时会默认创建的模式，用于存放对象的默认模式；sysaudit模式会存储会话对象的审计日志记录、对象审计日志记录；xlog_revord_reda模式用于保存xlog事务日志相关的信息。创建模式：create schema 模式名 authorization 属主用户名; 修改模式:1)alter schema 模式名 owner to u1;(修改模式的属主) 2)alter schmea 模式名 rename to 新模式名;(修改模式名) 删除模式:drop schema 模式名; 查看模式中的对象信息:\d+ 模式名.* 2.4 表空间(Tablespace) KingbaseES中的表空间也是一个逻辑概念，它在物理上与磁盘上的数据文件相对应（一个表空间由一个或多个数据文件组成，但是一个数据文件只能属于一个表空间）；从物理上理解，数据库的数据被存放在数据文件中，从逻辑上理解，数据时存放在表空间中的。
下面是一些关于表空间的基本操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c551afc867cff383e8e38fd68cdc4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e446ec10ece6fac0195d6a0dd93c0f/" rel="bookmark">
			MySQL的下载、安装、配置、登录，配置（图&#43;文）（超级详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 软件的下载 1. 下载地址 官网： https://www.mysql.com 2. 打开官网，点击 DOWNLOADS 然后，点击 MySQL Community(GPL) Downloads 3. 点击 MySQL Community Server 4. 在 General Availability(GA) Releases 中选择适合的版本 Windows 平台下提供两种安装文件： MySQL 二进制分发版（ .msi 安装文件）和免安装版（ .zip 压缩文 件）。一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版 使用起来要简单，不再需要其他工具启动就可以运行 MySQL 。 这里在Windows 系统下推荐下载 MSI 安装程序 ；点击 Go to Download Page 进行下载即可 Windows 下的 MySQL8.0 安装有两种安装程序 mysql - installer - web - community - 8.0.26.0.msi 下载程序大小： 2.4M ；安装时需要联网安 装组件。 mysql - installer - community - 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e446ec10ece6fac0195d6a0dd93c0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f07a1aa852bc59285ca27281e23d6004/" rel="bookmark">
			重温MySQL的ACID实现原理：深入探索底层设计与机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们谈论关系型数据库时，ACID属性是不可避免的核心话题。这四个字母——原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）——代表了数据库事务处理的关键原则。在本文中，我们将深入探讨MySQL数据库如何实现这些原则，以及这些实现背后的底层设计和机制。
一、原子性（Atomicity）的实现 原子性是数据库事务的核心特性之一，它要求事务中的所有操作要么全部完成，要么全部不完成。这种“全或无”的特性确保了数据库在事务处理过程中的一致性。在MySQL中，原子性的实现主要依赖于事务日志，特别是redo log（重做日志）和undo log（撤销日志）。
Redo Log（重做日志）
Redo log是MySQL InnoDB存储引擎的一种日志类型，用于确保事务的持久性。当事务发生时，所有的修改操作并不会直接写入数据文件，而是先写入redo log，并适时地刷新到磁盘上。这样做的好处是，即使在事务提交前系统突然崩溃，重启后也可以通过重做redo log中的操作来达到事务提交的状态，从而保证了事务的原子性。
Redo log采用循环写入的方式，当日志文件写满后，会从头开始覆盖之前的日志。为了保证日志的持久性，MySQL还提供了多种刷新策略，如每秒刷新、事务提交时刷新等。
Undo Log（撤销日志）
Undo log是另一种重要的日志类型，用于支持事务的回滚操作。在事务执行过程中，所有的修改操作都会被记录在undo log中。如果事务因为某种原因需要回滚，系统可以利用undo log中的信息撤销已经执行的操作，将数据库恢复到事务开始前的状态。
Undo log不仅用于事务回滚，还用于MVCC（多版本并发控制）机制。通过undo log，MySQL可以为每个事务提供一个独立的、一致的数据视图，从而实现多个事务的并发执行。
为了保证原子性，MySQL在事务执行过程中会维护一个事务状态。如果事务中的所有操作都成功执行，那么事务状态将被标记为“提交”，此时所有的redo log都会被刷新到磁盘上，并且相应的undo log会被标记为可删除。如果事务中的任何一个操作失败，那么事务状态将被标记为“回滚”，此时系统将利用undo log中的信息撤销已经执行的操作，并将数据库恢复到事务开始前的状态。
总之，MySQL通过redo log和undo log的协作来确保事务的原子性。Redo log保证了事务的持久性，使得在系统崩溃后能够恢复事务的状态；而undo log则提供了事务回滚的能力，确保了事务的“全或无”特性。这两种日志类型的结合使用为MySQL提供了强大而可靠的事务处理能力。
二、一致性（Consistency）的实现 一致性，作为ACID（原子性、一致性、隔离性、持久性）模型的一部分，要求数据库事务必须保证数据库从一个一致的状态转变到另一个一致的状态。换句话说，无论并发执行的事务有多少，数据库的完整性约束必须始终保持满足，且事务的执行结果必须是正确的。MySQL通过约束、触发器和MVCC等机制来维护一致性。
约束：
数据库表定义时可以设置各种约束，如主键约束、外键约束和唯一性约束等。这些约束在数据插入、更新和删除时进行检查，以确保数据的一致性。
触发器：
触发器是与表事件相关的特殊类型的存储过程。当INSERT、UPDATE或DELETE等事件发生时，触发器会自动执行，以维护数据的一致性。
MVCC：
当谈到数据库的一致性与MVCC（多版本并发控制，Multi-Version Concurrency Control）时，这两者之间存在着紧密的联系。MVCC是数据库管理系统（DBMS）中用于实现事务并发控制的一种技术，特别是在像MySQL这样的关系型数据库管理系统中。它允许多个事务在不互相干扰的情况下同时访问数据库，从而提高了数据库的并发性能。
MVCC通过以下方式帮助实现一致性：
版本控制：MVCC为每个事务提供数据的“快照”。当事务开始时，它看到的是数据的一个版本。在事务执行期间，即使其他事务修改了数据，该事务仍然看到的是它开始时的数据版本。这确保了事务内部的一致性，因为它不会看到其他事务的中间状态。读不加锁：在传统的锁定机制中，读取数据可能会加锁，从而阻塞其他事务。但MVCC允许事务在不加锁的情况下读取数据，从而提高了并发性。这种非阻塞的读取操作有助于保持数据的一致性，因为事务不会因等待锁而被阻塞，进而避免了可能的死锁情况。行级锁定：虽然MVCC减少了锁的需求，但在某些情况下仍然需要锁定。MVCC通常与行级锁定结合使用，这意味着只有被修改的行才会被锁定，而不是整个表。这降低了锁争用的可能性，有助于维护数据的一致性，因为事务可以更细粒度地控制它们对数据的访问。隔离级别：MVCC与事务的隔离级别紧密相关。不同的隔离级别（如读已提交、可重复读）定义了事务可以看到的其他事务的修改。例如，在“可重复读”隔离级别下，事务在整个过程中看到的是一致的快照，即使其他事务在此期间进行了修改。这有助于确保事务在并发环境中的一致性。 总的来说，MVCC通过提供多版本的数据视图、非阻塞读取、行级锁定以及与隔离级别的配合，有效地支持了高并发环境下的事务一致性。这些机制共同作用，使得数据库能够在处理多个并发事务时保持数据的一致性和完整性。
三、隔离性（Isolation）的实现 隔离性要求并发执行的事务不会互相干扰。MySQL通过锁机制和MVCC（多版本并发控制）来实现隔离性。
1. 锁机制：
MySQL提供了多种类型的锁，如行锁、表锁和元数据锁等。这些锁可以防止多个事务同时修改同一数据项，从而确保事务之间的隔离性。从锁的性质分，主要的锁类型包括共享锁（读锁）和排他锁（写锁）。
共享锁（Shared Lock）： 允许多个事务同时读取同一资源，但阻止其他事务对该资源进行写操作。这保证了在读取数据时，数据不会被其他事务修改，从而实现了读操作的隔离。
排他锁（Exclusive Lock）： 当一个事务需要对资源进行修改（写操作）时，它会获得该资源的排他锁，阻止其他事务对该资源进行读或写操作。这确保了在修改数据时，数据不会被其他事务同时读取或修改，从而实现了写操作的隔离。
通过锁机制，MySQL能够控制并发事务对数据的访问，避免了数据的不一致性和脏读、不可重复读等问题。
2. MVCC（多版本并发控制）：
MVCC是MySQL中实现事务隔离性的另一种重要机制。它通过保存数据在某个时间点的快照，使得每个事务都能够看到一个一致性的数据库视图，从而实现了非阻塞的读操作和写操作的隔离。每个事务只能看到自己开始时的数据状态，而无法看到其他事务的中间状态。
版本链：MVCC通过为每个数据项维护一个版本链来实现多版本控制。每个数据项都有一个版本号，当数据被修改时，旧版本的数据不会被立即删除，而是保留在版本链中。这样，每个事务都可以根据其开始时的系统版本号，读取到相应版本的数据。
读操作：在读操作中，事务不需要获取锁就可以读取数据。它通过读取版本链中对应版本的数据来获取一致性的视图。由于读操作不需要加锁，因此多个事务可以同时进行读操作，而不会互相阻塞。
写操作：在写操作中，事务会获取相应数据的排他锁，并创建一个新版本的数据项。写操作会修改数据的最新版本，并将旧版本保留在版本链中供其他事务读取。这样，写操作只会影响当前事务和之后开始的事务，对之前已经开始的事务不会产生影响。
通过MVCC机制，MySQL实现了非阻塞的读操作和写操作的隔离，提高了数据库的并发性能。同时，它也避免了脏读和不可重复读等问题，保证了事务的隔离性。
需要注意的是，MVCC主要在MySQL的InnoDB存储引擎中使用，并且主要在“可重复读”隔离级别下工作。在其他隔离级别下，MySQL可能会使用不同的机制来实现隔离性。
综上所述，MySQL通过锁机制和MVCC机制相结合，实现了事务的隔离性。锁机制用于控制对共享资源的并发访问，而MVCC机制通过多版本控制实现了非阻塞的读写操作隔离。这两种机制共同作用，保证了事务在并发环境中的正确性和一致性。
MySQL提供了不同的事务隔离级别，以进一步控制事务之间的隔离程度。隔离级别越高，事务之间的隔离性越强，但并发性能可能越低。
事务的隔离级别：
读未提交（Read Uncommitted）：最低级别的隔离，事务可以读取尚未提交的其他事务的修改。这种级别下，事务之间几乎没有任何隔离，可能导致脏读、不可重复读和幻读等问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f07a1aa852bc59285ca27281e23d6004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8a16130cc583e563855e4554cf4f62/" rel="bookmark">
			(vue)键值对结构数据展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 (vue)键值对结构数据展示 效果：
数据结构：
this.formInline.algorithmText = [ { algorithmParameters: { 参数名1: "111", 参数名2: "121,122", }, algorithmName: "算法1", algorithmId: 9, }, { algorithmParameters: { 参数名1: "211", 参数名2: "221,222", }, algorithmName: "算法2", algorithmId: 11, }, ]; 展示：
&lt;div v-for="(ele,index) of formInline.algorithmText" :key="index"&gt; &lt;div&gt; &lt;el-form-item :label="'设置'+ele.algorithmName+'参数：'"&gt;&lt;/el-form-item&gt; &lt;/div&gt; &lt;el-form-item v-for="(item,index) in Object.keys(ele.algorithmParameters)" //重点 :key="index" :label="item" class="descInput" &gt; &lt;el-input v-model="ele.algorithmParameters[item]" //重点 placeholder="请输入" @change="paramsChange" /&gt; &lt;/el-form-item&gt; &lt;/div&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70018759a75e416139b12c1ec0abbb81/" rel="bookmark">
			JS 判断null 判断undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 判断null： typeof类型判断：返回是一个object
3个等号判断：===
let a = null console.log(typeof a === 'object' &amp;&amp; a===null) //判断null true console.log(a === null) //true 判断undefined console.log(typeof b=='undefined') 同时判断null 与undefined 判断是否为null 或者为undefined, 且不等于0, 可以用来判断数字型字段是否没有赋值
let a=null let b let c=0 console.log(a==null,b==null,c==null) // true, true,false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f642a0e4c8ce7bdc6f35fb17696026b7/" rel="bookmark">
			Java中创建List接口、ArrayList类和LinkedList类的常用方法（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List接口 要了解List接口，就不得不说起Java的集合框架。
（该图来自菜鸟教程）
Collection接口和Map接口 Java 集合框架主要包括两种类型的容器，集合Collection和图Map。
Collection接口代表了单列集合，它包含了一组Object元素，每个元素都有一个值。
（这里有个“泛型擦除”的概念，在此不提及有兴趣可自行了解）Map接口代表了双列集合，它包含了一组键值对，每个键值对包含两个值，一个是键，一个是对应的值。 List Collection 接口又有 3 种子类型，List、Set 和 Queue。
List 接口存储一组不唯一，有序（插入顺序）的对象。 不唯一：允许存储重复的元素。有序：可以精准控制元素添加的位置，因此可以根据索引访问元素。&lt;实现类有ArrayList,LinkedList,Vector&gt; 。 Set 接口存储一组唯一，无序的对象。 唯一：元素不允许重复。无序：没有定义顺序，元素的存储顺序可能与添加顺序不同。 Queue接口：一个先进先出（FIFO）的集合，通常用于模拟队列数据结构。 静态数组 概念 是一种线性数据结构。将相同类型的元素存储在连续的内存空间中。 初始化 java中两种创建静态数组的形式如下，
int[] array = new int[5]; // { 0, 0, 0, 0, 0 } int[] iarray = { 1, 2, 3, 5, 4 }; 第一行代码创建了一个名叫array的数组，长度大小为5，并且数组的长度大小不能改变。注释的意思是，java会自动给数组内的元素赋值为默认值，即int型的默认值0。 第二行代码创建了一个名叫iarray的数组，长度大小为5，并且长度大小也无法改变，且编写者主动赋值为一到五的数字。 ArrayList类 概念和性质 ArrayList 继承了 AbstractList类 ，并实现了 List 接口。
(AbstractList是List接口的抽象实现类，它继承自AbstractCollection类，并实现了List接口中的方法。)ArrayList基于动态数组实现，内部使用一个数组来存储元素，当数组容量不足时，会进行扩容操作，通常创建一个新的更大的数组，并将原数组的元素复制到新数组中。插入删除性能： 倘若在末尾进行插入和删除操作的性能较好但若在中间或开头进行插入删除操作时，需要移动后续元素，性能较差。 随机访问性能：支持通过索引进行快速的随机访问，效率较快。 使用 初始化 ArrayList初始化的基本格式如下，
import java.util.ArrayList; // 引入 ArrayList 类 ArrayList&lt;ElemType&gt; objectName =new ArrayList&lt;&gt;();　// 初始化 ElemType是数组中对象（元素）的引用类型数据，objectName是数组名字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f642a0e4c8ce7bdc6f35fb17696026b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ccb6992de812b5d579ad6630b69d2f6/" rel="bookmark">
			跨域原理和解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置知识 什么是跨域 主要是由于浏览器的同源策略引起的，同源策略是浏览器的安全机制，当 协议，域名，端口 三者有一个不同，浏览器就禁止访问资源。
比如：http://www.company.com:80
http://www.company.com:80/dir/page.html ----成功http://www.child.a.com/test/index.html ----失败，域名不同https://www.a.com/test/index.html ----失败，协议不同http://www.a.com:8080/test/index.html ----失败，端口号不同 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取DOM和JS对象无法获得AJAX 请求不能发送 不受同源策略限制的有： 页面上的链接，比如 a 链接。重定向。表单提交。跨域资源的引入，比如：script, img, link, iframe 这里又有一个问题为什么表单提交不受同源策略限制？
所谓的同源策略，是一个域名在没有得到允许，不能够读取其他域名的内容。但浏览器不阻止你像其他域名发出请求。那么form发送请求能够跨域就可以理解，他只是发出请求，并没有得到响应。
首先，表单的提交方式有两种，一种是直接指定表单的action，一种是ajax接手控制请求。
直接使用action的时候，是直接把请求交给了action里面的域，本身页面不会去管他的请求结果，后面的步骤交给了action里面的域。好比：
&lt;from action="baidu.com"&gt; // you form filed &lt;/from&gt; 上面这个表单提交后，剩余的操作就交给了action里面的域baidu.com，本页面的逻辑和这个表单没啥关系，由于不关系请求的响应，所以浏览器认为是安全的。因为表单提交是一个提交数据的过程，表单提交后就会跳转，表单所在的页面是没办法获取结果的。抽象一点说，form提交和点击a标签跳转差不多，没必要对这个做限制。
而使用ajax来控制form的请求的时候，页面js会需要知道请求的返回值，这个时候，浏览器发出跨域请求，需要获得授权才可以成功请求，否则是会拒绝的。如果Ajax表单跨域提交想得到响应结果，目标服务器应该设置Access-Control-Allow-Origin。
9种跨域解决方法 例子中可运行源码
1，JSONP跨域 jsonp的原理就是利用
jsonp有点： JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题 。
jsonp缺点： 仅支持get方法具有局限性,不安全可能会遭受XSS攻击。
1）原生JS实现：
&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'; document.head.appendChild(script); // 回调执行函数，后端返回的时候会被执行到 function handleCallback(res) { alert(JSON.stringify(res)); } &lt;/script&gt; 服务端返回如下（返回时即执行全局函数）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ccb6992de812b5d579ad6630b69d2f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f393de20f8f382e7cb5a56f63e57115/" rel="bookmark">
			R语言【utils】——write.table()，write.csv()，write.csv2()：将数据写入文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Package utils version 4.2.0
Usage write.table(x, file = "", append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA", dec = ".", row.names = TRUE, col.names = TRUE, qmethod = c("escape", "double"), fileEncoding = "") write.csv(...) write.csv2(...) Arguments 参数【x】：要写入的对象，最好是矩阵或数据帧。如果不是，则尝试将其强制转换为数据帧。
参数【file】：命名文件的字符串或打开用于写入的连接。“”表示向控制台输出。
参数【append】：逻辑值。只有当参数【file】是一个字符串时才相关。如果为TRUE，则输出被追加到文件中。如果为FALSE，则覆盖该名称的任何现有文件。
参数【quote】：逻辑值(TRUE或FALSE)或数字向量。如果为TRUE，任何字符或因子列都将被双引号包围。如果是数字向量，则将其元素作为要引用的列的索引。在这两种情况下，如果书写行和列名，则将它们加引号。如果为FALSE，则不引用任何内容。
参数【sep】：字段分隔字符串。参数【x】的每行中的值由这个字符串分隔。
参数【eol】：在每行(行)末尾打印的字符。例如，eol = "\r\n"将在类unix操作系统上生成Windows的行尾，eol = "\r"将生成Excel:mac 2004所期望的文件。
参数【na】：用于数据中缺失值的字符串。
参数【dec】：用于数字列或复杂列中的小数点的字符串必须是单个字符。
参数【row.names】：要么是指示参数【x】的行名是否与参数【x】一起写入的逻辑值，要么是要写入的行名的字符向量。
参数【col.names】：指示参数【x】的列名是否要与参数【x】一起写入的逻辑值，或者要写入的列名的字符向量。
参数【qmethod】：一个字符串，指定在引用字符串时如何处理嵌入的双引号字符。必须是"escape" (write.table的默认值)之一，在这种情况下，引号字符将以C风格通过反斜杠转义，或者"double" (write.csv和write.csv2的默认值)之一，在这种情况下，它将被加倍。您可以只指定首字母。
参数【fileEncoding】：字符串:if non-empty声明要在文件(而不是连接)上使用的编码，以便字符数据可以在写入时重新编码。
参数【...】：要写的参数。Table: append, col.names, sep, dec和qmethod不能更改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f393de20f8f382e7cb5a56f63e57115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf057b8101a36510f18937e3e260a0c/" rel="bookmark">
			科大讯飞笔试记录（2023-08-13）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 最大优美排列 #include &lt;iostream&gt; using namespace std; int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; n - i &lt;&lt; " "; } } // 64 位输出请用 printf("%lld") 2. 小红走字符串 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { int n; long k; cin &gt;&gt; n &gt;&gt; k; string str; cin &gt;&gt; str; for (int i = 1; i &lt; str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bf057b8101a36510f18937e3e260a0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024bc64c2613ac19e9b712bfb79cecc2/" rel="bookmark">
			攻防_.git泄露_GitHack使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ctf小白刚下载这个，不知道怎么用。现在会用啦就记录一下~
下载地址：https://github.com/lijiejie/GitHack
下载下来后，通过cmd使用，如下图所示：
总结（命令）：
GitHack.py http://XXXXXXXXXXX/.git/ 运行结束后，得到文件，如图：
接下来就可以自行愉快玩耍啦~~~~
当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。
GitHack是一个.git泄露利用测试脚本，通过泄露的文件，还原重建工程源代码。
Git信息泄露的危害很大，渗透测试人员、攻击者，可直接从源码获取敏感配置信息（如：邮箱，数据库），也可以进一步审计代码，挖掘文件上传、SQL注射等安全漏洞。FreeBuf之前也有相关报道，点我围观。
工作原理
1、解析.git/index文件，找到工程中所有的： ( 文件名，文件sha1 ) 2、去.git/objects/ 文件夹下下载对应的文件 3、zlib解压文件，按原始的目录结构写入源代码 优点
速度快，默认20个工作线程 尽量还原所有的源代码，缺失的文件不影响脚本工作 脚本不需要执行额外的git命令，all you need is python 脚本无需浏览目录 可能的改进
存在文件被gc打包到git\objects\pack的情况，稍后可测试下看能否直接获取并解压这个文件，还原源代码
用法示例
GitHack.py http://www.openssl.org/.git/ 执行中截图：
执行结果：
获取代码：https://github.com/lijiejie/GitHack
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/902a684c29e7ed04a378be7c37d51bf2/" rel="bookmark">
			音乐人声分离工具：极简的人声和背景音乐分离工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个极简的人声和背景音乐分离工具，本地化网页操作，无需连接外网，使用 2stems/4stems/5stems 模型。
将一首歌曲或者含有背景音乐的音视频文件，拖拽到本地网页中，即可将其中的人声和音乐声分离为单独的音频wav文件，可选单独分离“钢琴声”、“贝斯声”、“鼓声”等
自动调用本地浏览器打开本地网页，模型已内置，无需连接外网下载。
支持视频(mp4/mov/mkv/avi/mpeg)和音频(mp3/wav)格式
只需点两下鼠标，一选择音视频文件，二启动处理。
预编译Win版使用方法/Linux和Mac源码部署 点击此处打开Releases页面下载预编译文件；
下载后解压到某处，比如 E:/vocal-separate；
双击 start.exe ，等待自动打开浏览器窗口即可；
点击页面中的上传区域，在弹窗中找到想分离的音视频文件，或直接拖拽音频文件到上传区域，然后点击“立即分离”，稍等片刻，底部会显示每个分离文件以及播放控件，点击播放；
如果机器拥有英伟达GPU，并正确配置了CUDA环境，将自动使用CUDA加速。
源码部署(Linux/Mac/Window) 要求 python 3.9-&gt;3.11
创建空目录，比如 E:/vocal-separate, 在这个目录下打开 cmd 窗口，方法是地址栏中输入 cmd, 然后回车。
使用git拉取源码到当前目录 git clone git@github.com:jianchang512/vocal-separate.git .
创建虚拟环境 python -m venv venv
激活环境，win下命令 %cd%/venv/scripts/activate，linux和Mac下命令 source ./venv/bin/activate
安装依赖: pip install -r requirements.txt
win下解压 ffmpeg.7z，将其中的ffmpeg.exe和ffprobe.exe放在项目目录下, linux和mac 到 ffmpeg官网下载对应版本ffmpeg，解压其中的ffmpeg和ffprobe二进制程序放到项目根目录下
下载模型压缩包，在项目根目录下的 pretrained_models 文件夹中解压，解压后，pretrained_models中将有3个文件夹，分别是2stems/3stems/5stems
执行 python start.py ，等待自动打开本地浏览器窗口。
API 接口地址: http://127.0.0.1:9999/api
请求方法: POST
请求参数:
file: 要分离的音视频文件 model: 模型名称 2stems,4stems,5stems 返回响应: json code:int, 0 处理成功完成，&gt;0 出错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/902a684c29e7ed04a378be7c37d51bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8032d90d16dcf124d82852c7dca9716e/" rel="bookmark">
			背包问题（贪心）&amp; 二维01背包问题 Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背包问题（贪心） 最优装载问题 题目描述 有n件物品和一个最大承重为w 的背包。第i件物品的重量是weight[i]，每件只能用一次，求装入背包的最多物品数量。
题目分析 因为我们只要求装入物品的数量，所以装重的显然没有装轻的划算。因此将数组weight[i]按从小到大排序，依次选择每个物品，直到装不下为止，就可以得到装入背包的最多物品数量。 代码 public static int stone(int n, int w, int[] weight) { Arrays.sort(weight); //将weight数组从小到大排序 int max = 0; int num = 0; for(int i = 0; i &lt; n; i++) { if(max + weight[i] &lt;= w){ max += weight[i]; num += 1; } } return num; } 01背包问题 与上面的贪心背包问题而言，贪心背包问题中物品的价值就是它的重量。
先前题主做的拿金币问题，也可以说是一道背包问题，不过其中背包的容量是无限的，物品就是金币。
题目描述 有n件物品和一个最大承重为bagweight 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
卡码网第46题
题目分析 显然也是一道动态规划题，也就是说背包问题是动态规划问题的子集，当然这不重要。
我们先观察一下背包的属性：
当前装入物品的个数当前装入物品的总重量（容量）当前装入物品的总价值关键在当前重量的基础上使得价值最高 注：下文基本转述于代码随想录的网站，只加了部分自己的理解 可转到代码随想录的网站去更深刻地理解01背包知识
代码随想录的链接：戳这里进入
老规矩动归五部曲 定义dp数组 定义一个二维数组dp[i][j]，将i定义为当前放入了多少个物品，表示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8032d90d16dcf124d82852c7dca9716e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee64abca4f062a3e3eb5eaab928b348e/" rel="bookmark">
			零基础小白怎样学习web前端开发才能在面试时脱颖而出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个零基础的小白，想要学习web前端开发并在面试时脱颖而出可能看起来像是一座高山。然而，只要有正确的学习方法和坚定的决心，就能够征服这座高山，实现自己的目标。在本文中，我将为你详细介绍学习web前端开发的方法与步骤，帮助你在这条道路上走得更加扎实和自信。无论你是正在准备面试，还是对web前端开发充满好奇，本文都将为你提供有益的建议和指导。
1. 学习HTML和CSS
HTML是网页的基础语言，可以通过W3School等网站学习HTML的基本语法和标签。
CSS用于网页的样式设计，学习CSS可以让网页看起来更加美观和专业。
2. 掌握JavaScript
JavaScript是web前端开发中不可或缺的一部分，可以通过MDN等网站学习JavaScript的基本语法和应用。
3. 学习框架和库
掌握常用的前端框架和库，如React、Vue等，可以大大提升开发效率和网页性能。
4. 学习响应式布局
学习响应式布局可以让网页在不同设备上都能够良好地显示，可以通过Flexbox、Grid等技术来实现。
5. 学习调试工具
掌握Chrome开发者工具等调试工具，可以帮助你更好地调试和优化网页。
6. 练习项目
在学习过程中，不断练习实战项目，可以通过模仿网站、参与开源项目等方式来提升自己的实战能力。
7. 参与社区和论坛
参与前端开发的社区和论坛，可以结识更多的前端开发者，学习他们的经验和技巧。
8. 持续学习和更新
前端开发是一个不断更新和发展的领域，要保持学习的热情和持续更新自己的知识。
总的来说，学习web前端开发需要不断地实践和积累经验，同时也要保持对新技术的敏感度和学习能力。只有不断地学习和提升自己，才能在面试时脱颖而出，成为一名优秀的web前端开发工程师。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06873b7e7123b1f5c24b1440e9e05c6e/" rel="bookmark">
			Python对Excel文件中不在指定区间内的数据加以去除的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍基于Python语言，读取Excel表格文件，基于我们给定的规则，对其中的数据加以筛选，将不在指定数据范围内的数据剔除，保留符合我们需要的数据的方法。
首先，我们来明确一下本文的具体需求。现有一个Excel表格文件（在本文中我们就以.csv格式的文件为例），如下图所示。
其中，Excel表格文件具有大量的数据，每一列表示某一种属性，每一行表示某一个样本；我们需要做的，就是对于其中的部分属性加以数据筛选——例如，我们希望对上图中第一列的数据进行筛选，将其中大于2或小于-1的部分选出来，并将每一个所选出的单元格对应的行直接删除；同时，我们还希望对其他的属性同样加以筛选，不同属性筛选的条件也各不相同，但都是需要将不符合条件的单元格所在的整行都删除。最终，我们保留下来的数据，就是符合我们需要的数据，此时我们需要将其保存为一个新的Excel表格文件。
明白了需求，我们即可开始代码的撰写；本文用到的具体代码如下所示。
# -*- coding: utf-8 -*- """ Created on Wed Jun 7 15:40:50 2023 @author: fkxxgis """ import pandas as pd original_file = "E:/01_Reflectivity/99_Model_Training/00_Data/02_Extract_Data/23_Train_model_NoH/Train_Model_1_NoH.csv" result_file = "E:/01_Reflectivity/99_Model_Training/00_Data/02_Extract_Data/23_Train_model_NoH/Train_Model_1_NoH_New.csv" df = pd.read_csv(original_file) df = df[(df["inf"] &gt;= -0.2) &amp; (df["inf"] &lt;= 18)] df = df[(df["NDVI"] &gt;= -1) &amp; (df["NDVI"] &lt;= 1)] df = df[(df["inf_dif"] &gt;= -0.2) &amp; (df["inf_dif"] &lt;= 18)] df = df[(df["NDVI_dif"] &gt;= -2) &amp; (df["NDVI_dif"] &lt;= 2)] df = df[(df["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06873b7e7123b1f5c24b1440e9e05c6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d22b088eea047fac68bfc182db10ae/" rel="bookmark">
			想当程序员：应该先学Python还是Java？看完就有数了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备学习编程前，你一定会打开电脑搜索一下“先学[Python]还是先学[Java]？”扑面而来的是海量回答。
如果你问一名[Java]程序员，肯定会建议你先学[Java]，因为他们认为Python像个乳臭未干的黄毛小子。但如果你问Python程序员，可能会得到一个完全相反的答案，他们认为Java是刻板啰嗦的老大爷，而人生苦短，我用[Python]。
但别担心，今天我们将会从
语言特色学习曲线职业方向市场需求 等多个方面为你解答**“选择[Python]还是Java的人生难题”**
最新全套【Python入门到进阶资料 &amp; 实战源码 &amp;安装工具】（安全链接，放心点击）
语言历史
Python：生而为简 Python是一门拥有简洁语法的高级编程语言。一个名为Guido van Rossum的荷兰大佬在1991年设计了它。Rossum设计这门语言的初衷，就是为了让代码读起来更轻松，并且让程序员们比起用其他语言，可以写更少的代码，事半功倍。
Java：出生就想当老大 而Jame Gosling在1995年设计了Java。 Java是一门以Class为单位，高度面向对象的高级编程语言。Java的设计初衷是“写一次代码，在哪里都可以用。” Java可以完成任何规模的任务，所以它也是很多公司在做商业级项目的时候的普遍选择。
语言本身
Python: 语法简洁，容易上手Java：语法稍微复杂 从语言本身来说，Python是出了名的简洁，容易上手。一个Python的粉丝曾经写过一首名为 The Zen of Python （Python之禅）的诗来赞颂这门语言的优雅。以下这首诗的节选翻译。
优美胜于丑陋（Python 以编写优美的代码为目标）
明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）
简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）
复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）
扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）
间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）
可读性很重要（优美的代码是可读的）
即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）
国外著名科普暴漫xckd也有这样一张形容Python之酸爽的著名漫画。
漫画中提到了学习一门编程语言，如烧香拜佛般必做的一件事：让屏幕输出Hello World! 这句话。 在Python中，做这件事只需要写一行代码：print “Hello World!”。 但是相比之下，Java实现这句话就要繁琐得多，需要至少4行代码（不小心就diss了一下Java）。总之，用Python编程，比起其他语言，更像是直接在和电脑对话。
public class HelloWorld {
public static void main(String[] args) {
System.out.println(“Hello, World”);
}
}
如此对比，Python的简洁明了和上手的容易程度就一目了然了。当然，这还只是一个例子，很多时候Python一两行代码就能搞定的事情，Java却需要多达10行，甚至20行。Python省去了像Java一样死记硬背语法和结构的时间。只需要基本的学习，你就可以读懂很多代码了。正是因为如此简单平缓的学习曲线，通过Python的学习，你可以很清晰地了解程序员的思维，更专注地学习编程通用的基本概念。在领悟透彻了这些知识以后，学习任何语言都是小菜一碟。许多国外知名大学，如MIT和哈佛，也渐渐地将计算机导论课程语言的选择，从Java转变成Python。Python甚至还因此进入了小学计算机教材中。
实际运用
Python
通过丰富的Web开发框架，如Django和TurboGears，Python可以用来快速完成一个网站的开发和Web服务。典型如国内的豆瓣、果壳网等
自动化系统网络的运行维护中，大量重复性工作的地方，并需要做管理系统、监控系统、发布系统等。
人工智能和数据分析
Java
安卓app开发
大型网站的后端
大型的企业级应用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05d22b088eea047fac68bfc182db10ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa14891514ec9703379ccc81bfdc451/" rel="bookmark">
			【软件测试】学习笔记-基于模型的测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以说，软件测试是一款软件产品质量的最后一道防线，是产品上线前必不可少、最重要的一个环节。每一款高质量的软件产品背后，都蕴含了大量的测试工作。而且，这些测试工作很可能是整个软件开发过程中最昂贵、劳动最密集的工作。
虽说从最简单的功能性黑盒测试，到涉及定理证明的复杂测试，已经有很多种方法可以帮助我们提高测试的可靠性和有效性。但是，在设计测试用例的过程中，总还是存在着这样那样的问题，使得软件测试的结果没那么理想。
为此，我们新引入了基于模型的测试，即Model-Based-Testing，简称MBT。
MBT，是自动化测试的一个分支。它是将测试用例的设计依托于被测系统的模型，并基于该模型自动生成测试用例的技术。其中，这个被测系统的模型表示了被测系统行为的预期，也可以说是代表了我们对被测系统的预期。
从质量保证的角度来看，我们可以制定测试内容，但却无法保证测试会覆盖所有可能的组合。而MBT则允许软件开发人员和测试人员，只关注建立系统的正确性以及模型的规范性，再通过专门的MBT工具根据不同的测试用例设计策略从系统模型生成可靠的测试用例。
那么，MBT的原理是什么，而什么样的应用又适合进行MBT呢？
MBT的基本原理 MBT的基本原理是通过建立被测系统的设计模型，然后结合不同的算法和策略来遍历该模型，以此生成测试用例的设计。
用下面的一张图片，为你描述了MBT的过程：
图1 MBT的一般过程
如图1所示，开发者首先根据产品需求或者说明来构建模型，然后结合测试对象生成测试用例，测试用例针对测试对象执行完之后，生成测试报告比对测试结果。
接下来，我以简单的登录系统为例，和你说明如何建模。
当用户访问网站时，网站需要识别用户是否已经登录：
如果已经是登录状态，则让用户进入，结束这一分支；如果用户还没有登录，那么页面需要返回登录框给用户。用户在登录框输入用户名和密码后，由后台服务验证用户名和密码是否正确，如果通过验证，则用户登录成功，结束分支；否则，返回错误信息，并再次返回登录框供用户登录。 根据这个逻辑，我们可以建模如下：
图2 网站登录系统建模
至此，我们就完成对这个登录系统的建模工作了。然后，我们通过具象化被测产品的需求行为，再通过工具来遍历模型中的各个路径，就可以得到我们需要的测试用例了。
所以，执行MBT的过程就好比你把软件系统的设计画为了一张由节点和边构成的数据结构意义上的“图”，然后通过一定的算法（比如，深度遍历或者广度遍历）来尽可能完整覆盖图中全部的可能路径的过程。
而根据被测系统的特点，我们可以创建不同类型的模型完成MBT。接下来，我们就一起看看有哪些常用的MBT模型吧。
常用模型简介 根据被测系统本身的特点，我们常用的模型主要有限状态机、状态图，以及UML三种。其中，有限状态机和状态图比较适合于用状态或者事件驱动的系统，而UML比较适合于靠业务流程驱动的系统。
第一，有限状态机。
有限状态机可以帮助测试人员根据选中的输入来评估输出，不同的输入组合对应着不同的系统状态。
在登录系统这个例子中，员工在未登录时的状态是“未登录”，一旦登录成功状态就会变为“已登录”。在已登录的状态下，员工可以访问各类资源，使用系统内的工具。
第二，状态图。
状态图是有限状态机的延伸，用于描述系统的各种行为，尤其适用于复杂且实时的系统。
状态图有一定数量的状态，系统的行为可以以事件的方式来驱动状态的变化。比如，缺陷管理工具中出现了缺陷，其初始状态为“new”；缺陷被开发人员修复后，就必须将其改为“Fixed”；但是，如果此时测试人员发现缺陷并未修复或者只是部分修复时，则需将状态更改为“Reopen”（重新打开）。
状态图的设计方式，要求为每个不同的状态创建一个事件。
第三，UML。
UML即统一建模语言，是一种标准化的通用建模语言。UML有自己定义的图形库，里面包含了丰富的图形用以描述系统、流程等。
UML可以通过创建可视化模型，来描述非常复杂的系统行为。
当我们完成被测系统的建模工作后，接下来就要将模型转化为可执行的测试用例了。这个转换过程，需要借助工具来完成。
因为不同领域的产品风格迥异，其使用的自动化框架和编程语言也各不相同，所以我们需要花费一些精力去寻找与自己产品匹配的MBT工具。其实，在很多情况下，我们还需要根据产品特点，去自行开发和定制工具。
MBT工具简介
这里，我为你罗列了一些常见的MBT工具，包括：BPM-X、fMBT、GraphWalker。在这里，我为你简单介绍这些工具的目的是，让你可以对MBT工具本身有个感性的认识，让你知道此类工具的应用场景和上下文。至于说如何来选择使用这些工具，这在很大程度上取决于被测系统的特点。
第一，BPM-X
BPM-X根据不同的标准（比如，语句、分支、路径、条件）从业务流程模型创建测试用例。
它还可以从多个建模工具导入模型，并可以将测试用例导出到Excel、HP Quality Center等。这个工具，适用于业务流程比较清晰直观的场景。
第二，fMBT
fMBT是一组免费的、用于全自动测试生成和执行的工具，也是一组支持高水平测试自动化的实用程序和库，主要被应用在GUI测试中。
fMBT包括用于多平台GUI测试的Python库，用于编辑、调试、运行和记录GUI测试脚本的工具，以及用于编辑和可视化分析测试模型和生成的测试工具。
第三，GraphWalker
GraphWalker以有向图的形式读取模型，主要支持FSM、EFSM模型。它读取这些模型，然后生成测试路径。GraphWalker除了适用于GUI测试外，更适合于多状态以及基于事件驱动的状态转换的后台系统。
另外，GraphWalker还支持从有限状态机中生成测试用例。
除此之外，市面上还有很多MBT测试工具，比如GSL、JSXM、MaTeLo、MBT Suite等。这里就不再一一介绍了，你可以自行百度了解它们的特点和适用场景，从而选取合适自己的工具。
MBT的优势 其实，MBT并不能算是一种新颖的测试技术，早在七八年前就已经被提了出来并且试图应用于软件产品的测试工作中。但是，MBT在很长一段时间内，却一直停留在概念阶段，主要原因是一直没有普适的工具支持，所以很少有成功实施的实际案例。同时，业界一直以来都缺乏高效的测试用例设计生成策略，所以虽然大家都能看到MBT的优势，但能在实际项目中应用执行的却是寥寥无几。
与传统测试相比，MBT的优点如下：
测试用例的维护更轻松。由于测试用例是基于被测系统的模型生成的，因此我们只需维护好模型即可，而无需关注测试用例的细节。软件缺陷发现得更早。由于我们在构建被测系统模型的过程中，已经对被测系统有了比较全面的理解，加之要根据系统需求/说明完成建模过程，所以我们可以在早期建模时发现被测系统可能存在的明显缺陷，而不用等到执行了大量的测试用例以后才发现这些缺陷。测试自动化的水平更高。由于MBT只需建好模型便可以自动生成测试用例，所以不再需要人工编写测试文档。而更高级的应用，甚至可以直接生成可以直接执行的自动化测试脚本。测试覆盖率变得更高，使得彻底的测试（即：穷尽测试）成为了可能。由于我们需要做的只是正确、详尽地用模型描述被测系统，而生成测试用例完全由MBT工具实现，所以这就避免了人工设计测试用例时的思维局限性，能够有效地提高测试覆盖率，让彻底的测试变为可能。- 当然，是否有必要开展彻底的测试还是要由风险决定。这里的风险指的是，由于漏测导致产品问题对业务的影响程度。MBT只是从技术上提供了可能性。基于模型间接维护测试用例的方式更高效。在传统测试中，如果被测系统的流程或者功能发生了变化，我们需要耗费大量的人力和时间成本，去重新设计与之匹配的测试用例。而在MBT中，我们只需要更新被测系统的模型即可，剩下的测试用例生成工作可以由MBT工具自动完成。 MBT的劣势 虽然MBT相对于传统测试有很多优点，但它也不是完美的测试方案。在实际开展MBT时，我们往往需要应对很多挑战，并克服很多困难。所以，到现在为止，MBT并没有被广泛使用于软件测试领域。
在这里，我总结了开展MBT的三大难点：
学习成本较高。MBT要求开发人员和测试人员都精通建模，这就需要一定的培训成本，需要让开发人员去学习测试的技能，让测试人员去学习建模概念。这其中还牵涉到建模工具的选择，以及学习等成本。使用MBT的初期投资较大。在很多情况下，我们并不能找到适合自己产品的建模工具，而需要自行创建MBT工具。- 在自行定制MBT工具时，我们要考虑到这个工具必须是可扩展的，并且能够处理复杂的测试逻辑，提供足够高的测试覆盖率，因此刚开始的工具建设就需要花费大量时间和精力。- 更糟糕的情况是，当工具建好后，我们却发现它并不能满足所有的建模需求，因此还要在建模的同时对工具进行微调。而，这种微调工作的难度，也比较大。早期根据模型生成测试用例的技术并不是非常成熟。很多时候只是根据图论的算法来遍历模型，这就会导致生成的很多测试用例在业务上根本没有任何实际意义，也因此阻碍了MBT在实际项目中的落地。- 不过好在近一两年来，基于人工智能（AI）生成测试用例的概念不断成熟，所以将基于AI的测试用例生成和MBT相结合，将会是接下来的一个发展方向。 总的来说，MBT和传统测试各有优劣。所以，测试的方法多种多样，MBT只是其中的一种。
如果一个应用的任何组件都可以通过模型来模拟、通过驱动程序来驱动，并可以通过测试结果来比较的话，那么这个应用就是MBT的最佳候选者。
如果我们的产品特征符合开展MBT的要求，并且团队各方面的条件都支持使用MBT时，我们便可以尝试用这种方法来改革我们的测试方式。尤其是将MBT结合基于AI的测试用例生成技术，将可以大大加速MBT产业应用的步伐。
但是，不管是否采用MBT，开发人员或测试人员在接触到一款软件产品时，首先都会有一个心理建模的过程，自己先去理解并在脑中勾勒出系统的功能结构和流程。其实，这些内容很容易就可以转换成实际的模型，也就为MBT创造了条件。
总结 这篇文章介绍了MBT的基本概念和方法。MBT是一种基于被测系统的模型，由工具自动生成测试用例的软件测试技术。所以，这也就决定了MBT相对于传统测试技术可以在测试用例维护、软件缺陷发现时机、测试自动化水平，以及测试覆盖率等方面有其独到的优势。
但同时，这也使得MBT相对于传统软件测试，在初期阶段投入较大，学习应用的成本较高。也正因为如此，MBT概念虽然已经提出了七八年的时间，但却并没有被广泛应用于软件测试领域。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa14891514ec9703379ccc81bfdc451/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7fe420974c02527e57ffa83d979397/" rel="bookmark">
			2024 最新Python趋势！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新全套【Python入门到进阶资料 &amp; 实战源码 &amp;安装工具】（安全链接，放心点击）
Python 于 2023 年庆祝其诞生 31 周年。它将成功地完成其在竞技场上的三十年，并成功地与许多其他重要的编程语言进行激烈的竞争。因此很明显，2023 年 Python 对于软件开发人员来说非常重要。
Python 是一种通用、高级、解释性编程语言。如今，它是增长最快的编程语言之一，并在科技行业的各个领域中使用。Python 正在快速成为世界上最流行的编程语言。Uber、Instagram、Facebook 和亚马逊等市场巨头都使用 Python 来开发他们的移动和桌面应用程序。Python 在 Facebook、Uber 等全球公司中的受欢迎程度证明了它的实用性。由于 Python 随着新的发展而不断进步，应用程序、软件和数字解决方案的开发方式也有了显著的改进。出于多种原因，使用 Python 是有益的。Python 作为一种编程语言，既是过程性的又是面向对象的。
2023-2024年 Python 开发趋势列表 商业应用
Python 是一种高级、多用途编程语言，是跨桌面和在线平台构思和执行业务应用程序的强大工具。Python 的存储库拥有专为图像识别、数据科学和无数其他领域量身定制的卓越开源包。在深入研究 2023年 Python 趋势时，业务应用程序和常规应用程序(例如电子商务和 ERP)之间的区别变得至关重要。前者要求应用程序具有可读性、可扩展性和可扩展性，Python 可以轻松提供这些品质。
游戏开发
开始游戏开发时，编程语言的选择是一个关键决定。由于其用户友好的特性和强大的开发生态系统，Python 在这个领域大放异彩，尤其是在原型设计方面。Python 的简单性使游戏开发人员能够将注意力集中在核心游戏编程上，而不是纠结于错综复杂的语言问题。Python 的适应性使其在游戏开发的未来格局中占据着令人感兴趣的位置，并有望与 AI、VR、AR 等领域集成。《坦克世界》、《模拟人生》和《战地》等备受推崇的游戏充分利用了内置库 pygame 等工具，证明了Python 的强大能力。
数据可视化
数据可视化作为一门变革性学科，将数据转化为视觉表示，即使有视觉倾向的人也能产生共鸣。这种方法揭示了原本可能隐藏的模式、趋势和联系。Python 结合了 Plotly、Matplotlib 和 Seaborn 等库，构成了数据可视化的强大工具，可以满足交互性、实时更新或定制等不同需求。
机器学习
Python 标志性的适应性、清晰性和强大的工具集使其成为当代软件开发中无与伦比的选择，特别是在机器学习领域。Python 在机器学习项目中的优势植根于其动态、高级的性质，并由灵活性、平台独立性、卓越的库和框架以及充满活力的社区等因素支撑。Python 在机器学习方面的潜力源于其根据特定模式识别事件的天生能力，并通过一系列专用库增强了这一能力。
Web 开发
对于 Web 应用程序的快速开发来说，Python 是一个令人难以置信的选择。使用 Flask、Pyramid 和 Django 等各种框架，能够以令人难以置信的速度构建不同的 Web 应用程序。它几乎用在 Web 开发的服务器端，Python 还可以用于与数据库交互以及构建其余的 API 服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b7fe420974c02527e57ffa83d979397/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8c7043f8b79ae2749892f8fa8e65d5e/" rel="bookmark">
			深入理解Rust变量绑定与解构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、变量命名规则二、变量可变性三、使用下划线开头忽略未使用的变量四、变量解构五、解构式赋值六、变量跟常量的差异七、变量遮蔽 团队博客: 汽车电子社区
一、变量命名规则 对于驼峰命名法，复合词的缩略形式我们认为是一个单独的词语，所以只对首字母进行大写：使用 Uuid 而不是 UUID，Usize 而不是 USize，Stdin 而不是 StdIn。
对于蛇形命名法，缩略词用全小写：is_xid_start。
对于蛇形命名法（包括全大写的 SCREAMING_SNAKE_CASE），除了最后一部分，其它部分的词语都不能由单个字母组成： btree_map 而不是 b_tree_map，PI_2 而不是 PI2.
包名不应该使用 -rs 或者 -rust 作为后缀，因为每一个包都是 Rust 写的，因此这种多余的注释其实没有任何意义。
二、变量可变性 Rust 的变量在默认情况下是不可变的。可以通过 mut 关键字让变量变为可变的。
fn main() { let mut x = 5; println!("The value of x is: {}", x); x = 6; println!("The value of x is: {}", x); } 三、使用下划线开头忽略未使用的变量 fn main() { let _x = 5; //cargo run运行时不会警告 let y = 10; //cargo run运行时发出警告 } 四、变量解构 let 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8c7043f8b79ae2749892f8fa8e65d5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd46fc597f7aaf4ac465677f4d3d2e85/" rel="bookmark">
			jackson按照自定义注解序列化和反序列化属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在springboot-web项目中，绝大多时候都是使用json格式来传输数据，springboot默认使用jackson来转换，一般情况下，默认的转化设置已经可以满足要求。特殊一点的使用Jackson相关的注解辅助也能完成。
但是在一次开发过程中，要求对某些字段进行加解密，但是由于是spring微服务的项目，所以只在其中一个服务中需要加密，所以没有办法使用@JsonSerialize 和 @JsonDeserialize着两种jackson的注解。
解决思路 一开始想的是，jackson既然实现了自己的注解，那它为了满足用户的需求，肯定做了兼容让用户根据自己的需要做数据的转换。经过查询资料和源码，发现OjectMapper有一个注入内省注解处理器的方法：
public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) { _serializationConfig = _serializationConfig.with(ai); _deserializationConfig = _deserializationConfig.with(ai); return this; } public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) { _serializationConfig = _serializationConfig.with(serializerAI); _deserializationConfig = _deserializationConfig.with(deserializerAI); return this; } 序列化 ObjectMapper在对象序列化时，会使用到 _serializationConfig这个配置。
protected final void _configAndWriteValue(JsonGenerator g, Object value) throws IOException { SerializationConfig cfg = getSerializationConfig(); //这个方法会返回 包含了 自定义注解解释类的的 _serializationConfig cfg.initialize(g); // since 2.5 if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) &amp;&amp; (value instanceof Closeable)) { _configAndWriteCloseable(g, value, cfg); return; } try { // _serializerProvider(cfg) 会构建一个默认的 DefaultSerializerProvider序列化对象 _serializerProvider(cfg).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd46fc597f7aaf4ac465677f4d3d2e85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f758fdcab12b1ad5aaaca0b17dd0a792/" rel="bookmark">
			es查询单字段去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 环境 es 7.10
2 去重方式 2.1 使用collapse功能 注意：使用此方式去重时，不会去除掉不存在去重字段的数据。
去重字段只能是数字类型或keyword。
对text字段进行去重将报错，报错如下。
"unknown type for collapse field `xxx`,only keywords and numbers are accepted" 去重举例如下：
（1）根据approval查询，且根据standardId去重
GET test/_search { "query": { "term": { "approval":"苏械注准20172091712" } }, "collapse": { "field": "standardId" } } 其中standardId的mappings信息如下： "standardId" : { "type" : "long" } （2）根据approval查询，且根据dosageName去重
GET test/_search { "query": { "term": { "approval":"苏械注准20172091712" } }, "collapse": { "field": "dosageName.keyword" } } 其中dosageName的mappings信息如下： "dosageName" : { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f758fdcab12b1ad5aaaca0b17dd0a792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8648757251bb51f57e396f5fe7a3be1/" rel="bookmark">
			波卡 2023 Q4 进展一览，去中心化未来计划已经启动！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：https://polkadot.network/blog/polkadot_q4_update_data
编译：OneBlock
2023 年的最后一个季度，Polkadot 呈现了持续的有机增长，包括在 12 月下旬交易数据出现明显增长。尽管网络达到了创纪录的日活跃度，费率仍然保持稳定。
这一不断进步的可扩展性为企业采用提供了更加便利的条件，与此同时，像 MeWe 和 Mythical Games 这样的项目正在吸引大量用户加入波卡生态。
随着即将到来的一些突破性技术升级，包括无信任桥、异步支持和按需平行链，这些功能确保新的初创企业更容易地加入生态中。
随着 OpenGov 和 XCM 等功能已经得以确立，以及 Agile Coretime 即将改善平行链与波卡网络连接的方式，一个比以往更为强大的基础框架已经准备就绪。
铭文热潮刷新交易量记录 根据 Subscan 的数据，2023 年前三个季度，Polkadot 中继链上的交易从每月近 230,000 个 DOT 交易的平均水平上升到 10 月的 378,868 笔 和 11 月的 339,865 笔，然后在 12 月飙升至 17,391,296 个，打破了所有先前的记录。
针对 12 月的交易量激增，Polkadot 创始人 Robert Habermeier 于 12 月 21 日在 X 上发帖说：「今天 Polkadot 中继链上有 100 万笔交易。这是 Polkadot 历史上活动最为频繁的一天，超过了 2021 年 5 月 5 日的 94.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8648757251bb51f57e396f5fe7a3be1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168212aa1a1e808434266241c66f0e3f/" rel="bookmark">
			LLM评估（一）| 大模型评估的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一年多前，随着Stable Diffusion和ChatGPT的发布，生成式人工智能成为主流，发展速度快得令人难以置信。几乎每周都会有新的模型发布，并声称可以超越目前SOTA模型。但我们怎么知道它们是否真的好呢？在缺乏基本事实的情况下，我们如何比较和排序生成模型，即“正确”的解决方案？最后，如果LLM通过检索增强生成或RAG系统使用外部数据，我们如何判断它是否正确使用了这些数据？
在本文中，我们将探讨生成人工智能的评估方法，包括文本生成和大型语言模型。
一、评估生成的内容 首先让我们了解一下生成模型和判别模型之间的区别：生成模型生成新的数据样本（无论是文本、图像、音频、视频、潜在表示，还是表格数据）都与模型的训练数据相似。然而，判别模型通过训练数据学习决策边界，使我们能够解决分类、回归和其他任务。
二、GenAI评估挑战 由于生成模型的任务性质，评估生成模型本质上比判别模型更具挑战性。判别模型的性能相对简单，可以使用适合任务的指标来测量，例如分类任务的精度、回归任务的均方误差或对象检测任务的交集。
相比之下，生成模型旨在产生新的、以前看不见的内容，评估这些生成样本的质量、一致性、多样性和有用性更为复杂。例如，文本生成模型可能会生成语法正确的句子，但它可能缺乏多样性，并重复生成类似的句子。相反，它可能会产生不符合逻辑或上下文意义的不同输出。
此外，语言模型可能会生成语法和上下文都正确的文本，但对用户没有帮助（或者，在最坏的情况下，是冒犯性的或有害的），这样的模型不应该被认为是高质量的。
最后，检索增强生成或RAG系统可能会生成结构良好的内容，这些内容听起来合理，对用户有帮助，但不是基于模型应该检索的外部数据。因此，用户可能会收到幻觉般的答案，而不是基于数据的答案。
三、LLM评估方法 那么我们该如何评估大型语言模型呢？大多数方法可分为以下四种：
🎯 特定任务指标（Task-Specific Metrics）
🔬 研究机构发布的基准（Research Benchmarks）
🤖 LLM自我评估（LLM Self-Evaluation）
👤 人工评估（Human Evaluation）
每种方法都有其优点和缺点，它们在实施难度和相关成本方面也有所不同。而且，也不存在“一刀切”的评估协议。然而，了解这些对评估语言模型有很大帮助。
3.1 🎯 任务特定指标 自然语言处理是一个比今天的LLM古老得多的领域。过去，已经提出了许多解决方案来解决常见的文本处理任务，例如文本摘要或从一种语言到另一种语言的机器翻译。为了评估这些解决方案，设计了特定的指标，如今，这些指标仍然可以用于评估LLM。
a）摘要
评估文本摘要的一个主流的评估指标是ROUGE（Recall-Oriented Understudy for Gisting Evaluation），ROUGE将模型生成的文本摘要与人工编写的“groundtruth”参考摘要进行比较。让我们看看它在实践中是如何工作的。先看一下下面这段简短的对话：
Anna: Hey, have you seen my copy of “The Silent Stars”? I can’t seem to find it anywhere.
Ben: “The Silent Stars”? Isn’t that the one with the blue and gold cover? Anna: Yes, that’s the one!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/168212aa1a1e808434266241c66f0e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014bd5a796c2cb73466ff084c6507dcc/" rel="bookmark">
			11- OpenCV：自定义线性滤波（卷积，卷积边缘）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、卷积
1、卷积概念
2、卷积如何工作
3、常见算子（卷积核 Kenel）
4、自定义卷积模糊
5、代码演示
二、卷积边缘
1、卷积边缘问题
2、处理边缘
3、相关的API说明
4、代码演示
一、卷积 1、卷积概念 （1）在OpenCV中，卷积是一种常用的图像处理操作，用于图像滤波、特征提取等任务。它基于滑动窗口的概念，通过将一个小的核Kenel（也称为滤波器）与图像进行逐像素的乘法和求和运算来实现。
— 卷积是图像处理中一个操作，是kernel在图像的每个像素上的操作。
— Kernel本质上一个固定大小的矩阵数组，其中心点称为锚点(anchor point)
（2）卷积操作可以理解为在图像上滑动一个小的核，并将核的每个元素与对应位置的图像像素值相乘，然后将所有乘积结果相加得到输出图像的对应像素值。这个过程可以简单地表示为：
output(x, y) = sum(kernel(i, j) * input(x+i, y+j))
其中，output(x, y)是输出图像的像素值，kernel(i, j)是核的元素值，input(x+i, y+j)是输入图像的像素值。
（3）卷积操作在图像处理中有多种应用，其中最常见的是图像滤波。通过选择不同的核，可以实现不同的滤波效果，例如平滑滤波、边缘检测等。卷积操作还可以用于图像特征提取，例如使用卷积神经网络（CNN）进行图像分类、目标检测等任务。
在OpenCV中，可以使用cv::filter2D函数来进行卷积操作。该函数接受输入图像、核以及输出图像作为参数，并将卷积结果存储在输出图像中。
2、卷积如何工作 把kernel放到像素数组之上，求锚点周围覆盖的像素乘积之和（包括锚点），用来替换锚点覆盖下像素点值称为卷积处理。数学表达如下
公式讲解：
K(i,j)：卷积核的大小
I里面的参数就是窗口的半径
两个方向X、Y方向上的求和
例子：从左到右，从上到下进行计算
Sum = 8x1+6x1+6x1+2x1+8x1+6x1+2x1+2x1+8x1
New pixel = sum / (m*n)
3、常见算子（卷积核 Kenel） （1）Robert算子：又称“梯度算子”
（2）Sobel算子：中间2*2，更大，比Robert算子的差异更大，效果可能更明显了
（3）拉普拉斯算子
4、自定义卷积模糊 （1）filter2D方法
filter2D (
Mat src, //输入图像
Mat dst, // 模糊图像
int depth, // 图像深度32/8，不知道的就默认-1，系统也默认和src的深度一样
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/014bd5a796c2cb73466ff084c6507dcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12076ff0de184b0c02367e948a0fc96b/" rel="bookmark">
			请后端人拿下软考，现在！立刻！马上！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉分享一个知乎知学堂发起的软考学习交流群（IT人必备！！）
群里有：
✅ 2天名师直播课，梳理核心考点；
✅ 7天1V1备考指导，扫清备考难题；
✅ 赠送2024最新备考资料包+题库；
重点是不需要集赞、转发、分享，扫码就能免费加入!
但是为了保证服务和学习质量，免费名额仅限定前100人！
软考也叫软件水平考试，软考证书是国央企、IT 圈、大厂公认的高含金量证书！
加上政策福利好、市场需求变大，直接火爆 IT 圈。
如果你是想通过证书实现技能提升/升职加薪/突破职场瓶颈的程序员、有北上广落户需求的人、想轻松评上中高级职称的人、系统集成型企业需要申报项目经理资质的专业技术人员、想考取证书增加就业竞争力的计算机专业大学生……
以及想通过证书获取福利的所有人，请你立即行动起来！！
学习群已为本号粉丝开通免费领取通道，扫码抢占入群名额，预计24小时后关闭通道！速进！
官方唯一指定入口
【软考备考通关技巧交流群】
基础入门｜备考规划｜科目选择｜答题技巧
扫描下方二维码
*扫码-添加老师-报名学习
(名额真的有限，不要轻易分享)
⭐️ 软考证书的8大福利
1.以考代评，通过人员无需在单位进行职称资格评定，拿证即获得对应级别的职称。
2.积分落户，软考证书符合北上广深等多地积分落户加分条件。
3.升职加薪，持有证书在越来越多的企业拥有更多职业发展机会。
4.技能补贴，软考是职业资格目录下的指定考试，可领取对应级别技能补贴。
5.加入专家库，具有高级职称或同等专业水平并满足其他条件可入选评标专家库。
6.助力投标，根据行业要求，软考证书是企业招投标资质的必备条件。
7.个税抵扣，取得证书的当年可申报3600元的个税补贴。
8.涨退休金，每月可多领退休金。
⭐️ 学习群的贴心服务
1.行业大佬直播软考通关技巧：
软考全方面分析及趋势解读
考点分布+真题解析+应用技巧分享
破解论文大招，带你抓住论文命题思路拿高分
科学的备考指导
2.群内配备专业强的助教老师，随时在线答疑：
遇到不懂的问题都可以随时问或者交流讨论，大家的问题可得到快速解答。
⭐️ 科目与适合人群
软考可考专业多：
中级推荐：软件设计师
高级推荐：系统架构设计师
适合人群：
架构师/软件设计师/软件开发/程序员/工程师/互联网从业者/计算机专业大学生/国央企/事业单位工作人员……
⭐️直播老师——赵宏伟老师
［2天直播课内容简介］👇
Day1：超全上岸攻略，带你快速入门软考
Day2：答题套路技巧，案例及论文破解大法
🔥 门槛低、起薪高、就业广
🔥 落户加分、领补贴、晋升涨薪
🔥 有证书终身受益...
【软考备考通关技巧学习群】
基础入门｜备考规划｜科目选择｜答题技巧
扫描下方二维码
*扫码-添加老师-报名学习
(名额真的有限，不要轻易分享)
立即扫码，还有机会获得，超丰富备考资料
（以系统架构设计师为例）
⬇️点击“阅读原文”，立即免费领课~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48edeaf0b1aaee0e9aeff1fb97a4e52c/" rel="bookmark">
			使用Apache Spark处理Excel文件的简易指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在日常的工作中，表格内的工具是非常方便的x，但是当表格变得非常多的时候，就需要一些特定的处理。Excel作为功能强大的数据处理软件，广泛应用于各行各业，从企业管理到数据分析，可谓无处不在。然而，面对大型且复杂的数据，Excel的处理能力可能力不从心。
对此，我们可借助Apache Spark这一分布式计算框架，凭借其强大的计算与数据处理能力，快速有效地处理Excel数据。这些数据进行一个分析，整理，筛选，排序。分析整理有用的内容。
操作 创建一个spark项目，在IntelliJ IDEA中创建Spark项目时，默认的目录结构如下：
project-root/ │ ├── src/ │ ├── main/ │ │ ├── java/ │ │ │ └── (Java source files) │ │ └── scala/ │ │ └── (Scala source files) │ └── test/ │ ├── java/ │ │ └── (Test Java source files) │ └── scala/ │ └── (Test Scala source files) ├── resources/ │ └── (Resource files) └── target/ └── (Compiled output and build artifacts) 导入包 在build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48edeaf0b1aaee0e9aeff1fb97a4e52c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb09c7ab24b9723620516796ffd02d73/" rel="bookmark">
			肺癌相关文献4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 只写一些觉得有帮助的部分，碰到有意思的再逐篇解读，还是要看看哪里的立意好。
第八篇 Deciphering a cell death-associated signature for predicting prognosis and response to immunotherapy in lung squamous cell carcinoma
IF:5.8中科院分区:2区 医学WOS分区:Q1
亮点：常规的生信分析，然后细胞死亡的基因集是纳入了KEGG及GO的凋亡、自噬和坏死。找出的基因集经算法减少数量后做打分，也是做标志。而而后看高低风险的分组区别。这篇发表于2023年的文章，并没有用到单细胞数据。
第九篇 Machine learning-identified stemness features and constructed stemness-related subtype with prognosis, chemotherapy, and immunotherapy responses for non-small cell lung cancer patients
IF:7.5 中科院分区:2区 医学
亮点： 摘要： 癌症干细胞是肿瘤组织中极少数的肿瘤细胞，具有无限增殖、自我更新和多向分化等生物学特性，可以在该肿瘤中形成一系列异质的细胞群[6,7]。 研究发现，癌症干细胞表面表达多种ABC转运蛋白[8]，可有效将化疗药物转运至细胞外，从而减少化疗药物对细胞的损伤;此外，癌症干细胞强大的修复能力可以最大程度地修复损伤[9]。因此，肺癌干细胞的存在是肺癌患者存活率低、对常规放化疗抵抗力强、手术或放疗后易复发的主要原因之一[10]。对NSCLC细胞干性的深入研究可为肺癌发生、耐药和转移的研究提供新的思路，也为肺癌的临床治疗带来新的希望。
免疫微环境是癌症干细胞所依赖的特定微环境，其中的免疫浸润细胞在NSCLC的发生发展中起着重要作用[11,12]。 据报道，在肺癌的免疫微环境中，B细胞表面共刺激分子CD40和CD154（CD40L）分子的相互作用导致活化的B淋巴细胞向CTL细胞呈递抗原的能力增强，导致CTL细胞分泌的IFN-γ和IL-2水平显着升高，增强CTL对肺癌干细胞的杀伤作用[13].随着免疫浸润细胞与癌症干细胞之间的调控关系逐渐被阐明，改善肿瘤免疫微环境，破坏肿瘤微环境对癌症干细胞的“保护”作用已成为肺癌治疗的新策略[14\u201216]。此外，针对免疫抑制信号的肺癌免疫疗法和免疫检查点也在研究中，大量研究表明，以PD-1/L1和CTLA-4为代表的免疫检查点抑制剂可以恢复抗肿瘤免疫应答，并起到杀伤肿瘤的作用。
方法： 1.ConsensusClusterPlus（无监督聚类）
2.OCLR（one-class logistic regression）
第十篇 Epiregulin increases stemness-associated genes expression and promotes chemoresistance of non-small cell lung cancer via ERK signaling
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb09c7ab24b9723620516796ffd02d73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e020bbbc6400fe2ebd8e3457aa0e594a/" rel="bookmark">
			CAS实现SSO单点登录之服务搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAS单点登录 文章目录 CAS单点登录1. What is CAS?1. 官网及文档2. 关于CASCAS provides enterprise single sign-on service for the Web:CAS为Web提供企业单一登录服务：3. CAS-Java-Client-Downlaod 2. Docker安装3. Tomcat中搭建HTTPS请求的支持1. 生成密钥库2. 从密钥库导出证书3. 将证书导入到JDK证书库中4.Tomcat中的Server.xml配置https协议的支持5. 下载CAS Server端部署到Tomcat中6. CAS配置数据源1.application.properties中配置数据源2. 加入连接数据源的驱动到lib中 4. 常见问题处理：1. 未认证授权的服务 1. What is CAS? 1. 官网及文档 CAS官网：https://www.apereo.org/projects/cas
CAS Server GitHub下载地址： https://github.com/apereo/cas
文档地址：https://apereo.github.io/cas/5.3.x/
https://github.com/apereo/cas-overlay-template
https://repo1.maven.org./maven2/cas/
2. 关于CAS Central Authentication Service (CAS),中央认证服务，是一个企业多语言单点登录解决方案。
Enterprise Single Sign-On - CAS provides a friendly open source community that actively supports and contributes to the project. While the project is rooted in higher-ed open source, it has grown to an international audience spanning Fortune 500 companies and small special-purpose installations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e020bbbc6400fe2ebd8e3457aa0e594a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b5e5a6900e9963148aa00af6243bc5/" rel="bookmark">
			Linux之Shell脚本编程入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux之Shell脚本编程入门 文章目录 Linux之Shell脚本编程入门Shell脚本编程入门1. 脚本格式2. 第一个Shell脚本：hello World3.第二个 shell脚本：duo命令处理4. shell中变量4.1 常用系统变量4.2 自定义变量4.3 特殊字符: $n4.4 特殊变量: $#4.5 特殊变量: ∗ 与 *与 ∗与@4.6 特殊变量: $? 5. 运算符5.1 基本语法5.2 实操案例 6. 条件判断6.1 基本语法6.2 常用判断条件6.3 实操案例 7.流程控制7.1 if 判断7.2 case 语句7.3 for循环7.4 while 循环7.5 read读取控制台输入 What is Shell？
Shell是一个命令行解释器，它接收应用程序/用户命令，然后调用系统操作内核。
Shell还是一个功能相当强大的编程语言，易编写、易调试、灵活性强。
Shell脚本编程入门 查看Linux系统已提供的shell解释器 cat /etc/shells 查看当前系统使用的默认shell解释器 echo $SHELL 1. 脚本格式 脚本一**#！/bin/bash**开头(指定解析器)
2. 第一个Shell脚本：hello World # 1. touch hello.sh # 2.vim hello.sh # 3.输入下面内容 #！/bin/bash echo "Hello World!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b5e5a6900e9963148aa00af6243bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe236feb19b772e06b0b8363e2b7126/" rel="bookmark">
			一键操控，随时随地，轻松管理你的设备！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个科技日新月异的时代，我们的生活被各种手机软件所包围。几乎每个人都有一个甚至多个手机，你是否也有遇到过需要远程操作自己某一台手机的场景呢？今天，我要向大家推荐一款神奇的手机远程操作神器，让你可以随时随地的管理你的设备！
手机远程控制APP 远程控制APP是一款可以让你通过手机远程操控其他手机设备的应用程序。它可以帮助你实现手机的远程控制和管理，让你的生活更加便捷。目前该软件完全免费使用，赶紧下载试试吧！
远程控制APP的功能有哪些？ 远程控制：无论你身在何处，只要有网络，就可以随时随地查看和操作你自己的手机设备，轻松处理工作和学习中的问题，例如：远程打卡等。目前远程控制分为两种场景，可以远程操作自己的手机设备，也可以根据邀请码远程操作其他朋友的手机。 远程自己的不同手机：
通过邀请码远程其他人的手机：
远程摄像头监控：通过手机远程控制APP，你可以实时查看远程手机的摄像头画面。 远程控制APP的优势有哪些？ 方便快捷：只需在手机上安装手机远程控制APP，就可以实现对其他设备的远程操控，省去了携带数据线的麻烦。
安全可靠：手机远程控制APP采用先进的加密技术，确保数据传输的安全性，让你无后顾之忧。
完全免费：远程控制APP不收取任何费用，只需要简单的注册，就可以完全免费试用。
总结 远程控制APP是一款功能强大、操作简便的应用程序，它可以让你随时随地掌控你的设备，让你的生活更加便捷。快来下载体验吧！
获取安装文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82cbc01ac752ef41df04652e24c11a5/" rel="bookmark">
			《绝地求生大逃杀》画面声音设置与单排技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《绝地求生大逃杀》游戏中想要吃鸡并不容易，除了过硬的枪法之外，画面、声音设置与战术打法也是很重要的，今天闲游盒带来“ab630305434”分享的《绝地求生大逃杀》画面声音设置与单排技巧，供新手玩家参考。
画面设置
纹理看个人喜好和电脑配置，调高调低不影响正常使用。
声音设置
音频均衡器的设置，虽然脚步声会变大，但是雨声和飞机的声音也会很吵。
鼠标设置
dpi600
吃鸡技巧
单排吃鸡可以落地找车去一个离航线十万八千里的地方磕满能量条顶着毒搜件（在下波安全区直径7个小白格左右进圈，这波毒是蹭蹭蹭掉血的那种），开车进圈后你会发现只剩20个人了。这么玩虽然很容易吃鸡但是太苟了，会少很多乐趣。
我最习惯的吃鸡方式是开局刚中间找个厕所最后再杀几个，一局也能杀十来个。
吃鸡难度组排＞单排＞双排。经常双排开局血祭小姐姐一个人吃鸡。
最重要的一点，没掩体不要开枪。
开车过坡提前减速。
被打后停车反击一定要刹好车，之前打两个没停好车的萌新，车一直在往下溜，两个人就趴着跑两步趴下跑两步，自行想象画面。
最近不要开车去顶其他任何车，要么你们一起爆炸要么飞天摔个半残。切身体验飞天小汽车。
在抽搐的摩托车记得远离，说不定就被砸死。
闲游盒最常用的武器组合4/8倍98k+红点m4/16，没有狙就用步枪+ump9（冲锋补偿优于消音）。
巷战喷子或者乌兹，没有其他武器能打过。
跳伞的时候多用alt观察附近人的位置，有了基本装后吃了他再慢慢搜。
大城到安全区中间这段范围人是最多的，想杀人或者跑路都可以注意下。
进房子前蹲下静步听一会再进，有枪没子弹说明有人来过。
单排随手关门是个好习惯。
alt是个好东西，希望你能常用。
钢枪用补偿器，消音还是留给LYB吧。
万不得已开车冲水里的时候，在车里可以吃药回血的。
用过7.1声道耳机，后面的声音贼小，又热又夹耳朵。看个人喜好吧，现在用的20的前后分不太清楚，多转两下鼠标就好了。
这个游戏开车的时候可以切座位，满脑子骚操作。
有车尽量开进安全区中心吧，等一个天命圈。毕竟路上跑贼鸡儿容易死。
类似于谷仓二楼的窗户都是可以空格c一起拍跳出去的，逃命反杀超好用。
打一个没发现你的敌人时，尽量第一枪瞄脑袋，随便补两下就带走了。
最后的圈尽量这么走，一路清过去吃鸡的机会大一点。
空投里面的东西除了15倍vss汤姆逊都还是不错的。
b51扫车谁用谁知道。
舔包一定要快，能有多快舔多块。无数次打死舔包的或者死于舔包。
pageup可以调密位，虽然我习惯抬枪。
丢烟雾弹的时候可以按鼠标右键，有惊喜。
组排可以打开地图滑鼠标滚轮放大标敌人位置的，尤其是城里。有默契另说。
捡到冲锋枪第一时间按b切全自动，灵活用b不吃亏。
卡视野的时候尽量qe打，闪出去跟没掩体又有什么区别。碰到狙还是打个烟走吧。
二蹦150迈，三蹦子130迈，小汽车110迈，四蹦子吉普90迈。
m16连射比冲锋枪都快。
tab是个好东西，拖子弹拖配件拖护具不会捡东西的动作，贼快有。
后面的圈一定要注意时间，提前进安全区。
水下卡视角看毒边很美的，也能清楚的看清附近水下有没有人。
不要站到队友与与敌人中间，更新后可以移动f捡东西了，一两件物品可以不用tab拖了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1650b6f4660ee8f0a1ab86b6b7b5a11d/" rel="bookmark">
			NineAi 新版AI系统网站源码 ChatGPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nine AI.ChatGPT是基于ChatGPT开发的一个人工智能技术驱动的自然语言处理工具，它能够通过学习和理解人类的语言来进行对话，还能根据聊天的上下文进行互动，真正像人类一样来聊天交流，甚至能完成撰写邮件、视频脚本、文案、翻译、代码，写论文等任务。
必要环境
nodejs version &gt; 16
pnpm version &gt; 6
mysql version &gt;= 5.7
redis
目录结构
chat 用户端代码
admin 管理端代码
service 服务端代码
本地开发
三端统一命令
pnpm install 安装依赖
pnpm dev 启动项目
pnpm build 打包项目
启动项目
分别安装依赖 pnpm i
首先启动服务端进入service 创建.env文件 在其中修改 测试数据库信息和redis 配置完成后 pnpm dev
数据库通过orm映射 启动项目会自动创建数据库
启动完成后可以打开chat admin pnpm dev启动
关于授权
授权模块在 src/modules/globalConfig/globalConfig.service.ts 文件下
对函数 nineAiCheckAuth 移除其中内容就并且移除onModuleInit的nineAiCheckAuth就可以移除授权
对应的 src/modules/task/task.service.ts中的定时任务也可以移除掉 checkauth 定时任务
打包路径问题
service
后端服务直接 pnpm build 即可 .env为环境变量文件 需要后续自己挂载或者创建 项目有 示例文件.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1650b6f4660ee8f0a1ab86b6b7b5a11d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc228ceb4e53ae48864c5a58d79e5b3/" rel="bookmark">
			微信小程序-----网络数据请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、 小程序中网络数据请求的限制
二、配置 request 合法域名
三、发起 GET 请求
四、发起 POST 请求
五、在页面刚加载时请求数据
六、跳过 request 合法域名校验
七、关于跨域和 Ajax 的说明
前言 本期我们学习微信小程序中如何发起网络数据请求，通过网络数据请求我们可以将本地的数据通过网络协议上传到网络当中去，让其他人可以获取得到。废话不多说，下面就开始看正文吧！
一、 小程序中网络数据请求的限制 出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下两个限制：
① 只能请求 HTTPS 类型的接口 ② 必须将 接口的域名 添加到 信任列表 中 二、配置 request 合法域名 需求描述：假设在自己的微信小程序中，希望请求 https://www.escook.cn/ 域名下的接口
配置步骤：登录微信小程序管理后台 -&gt; 开发 -&gt; 开发设置 -&gt; 服务器域名 -&gt; 修改 request 合法域名
下面我一步一步演示给你们看：
搜索微信小程序官网微信公众平台 (qq.com)https://mp.weixin.qq.com/
然后点开开发管理，去配置request域名，我这里的合法域名是
注意事项：
①域名只支持 https 协议 ②域名不能使用 IP 地址或 localhost ③域名必须经过 ICP 备案 ④服务器域名一个月内最多可申请 5 次修改 三、发起 GET 请求 调用微信小程序提供的 wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dc228ceb4e53ae48864c5a58d79e5b3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/13/">«</a>
	<span class="pagination__item pagination__item--current">14/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/15/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>