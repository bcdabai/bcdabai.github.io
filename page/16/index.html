<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9febdd7dcfe490c9aa04af1f4436c37/" rel="bookmark">
			IO、NIO、IO多路复用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO是什么？
IO分为两类，它们之间是有区别的，而且有很大的区别； 1. 文件系统的IO 也叫本地io，就是和磁盘或者外围存储设备进行读写操作，外围设备有USB、移动硬盘等等； 2. 网络的IO 将数据发送给对方 和 读取对方的数据就称为网络IO； 网络IO是如何连接的？
网络IO就是本机的应用程序对着内核的缓冲区读写的过程，发送数据时应用程序会将数据复制到内核态的写队列中，再由内核将数据复制到网卡，然后进行发送；读取数据则反过来，网卡接受到数据后将数据复制到内核态的读队列中，在通知应用程序来获取数据； 下面是一次网络读取内容的I/O示意图，数据先从外设（网卡）到内核空间，再到用户空间（JVM），最后到应用程序的一个过程。
上述一次I/O读取，所谓的阻塞和非阻塞体现在哪里呢？
Java最早期的版本的I/O就是这样实现的。当程序调用到读取I/O的时候，同步阻塞住程序，直到数据从网卡写入内核空间，在写入用户空间才返回数据，程序才可以继续进行。
BIO
BIO为同步阻塞IO，blocking queue的简写，也就是说多线程情况下只有一个线程操作内核的queue，当前线程操作完queue后，才能给下一个线程操作；
如图1所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。
用户线程使用同步阻塞IO模型的伪代码描述为：
{ read(socket, buffer); process(buffer); } 即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。
在BIO下，一个连接就对应一个线程，如果连接特别多的情况下，就会有特别多的线程，很费线程；在早期的时候，世界上的计算机还很少，网站也少，会上网的人更是寥寥无几，并发最高的时候也就几十上百个，所以当并发量不高的情况下，BIO也够用了；
NIO （流程图）
Non-blocking IO的简写，同步非阻塞IO，内核发生了变化，app访问内核的缓冲区时不会阻塞，但是返回值需要用户自己判断；如果连接数特别多的i情况下，就需要应用程序不停遍历，一个个进行状态的判断，询问是否有数据到达；
如图2所示，由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。
用户线程使用同步非阻塞IO模型的伪代码描述为：
{ while(read(socket, buffer) != SUCCESS); process(buffer); } 即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。
IO 多路复用
多路是指网络连接，复用指的是同一个线程 为什么有IO多路复用机制?
没有IO多路复用机制时，有BIO、NIO两种实现方式，但有一些问题 IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。
如图3所示，用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。
从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。
用户线程使用select函数的伪代码描述为：
{ select(socket); while(1) { sockets = select(); for(socket in sockets) { if(can_read(socket)) { read(socket, buffer); process(buffer); } } } } 其中while循环前将socket添加到select监视中，然后在while内一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9febdd7dcfe490c9aa04af1f4436c37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ccc18b658c3ee750c28453b8ad54cff/" rel="bookmark">
			Redis--Geo指令的语法和使用场景举例（附近的人功能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Geo介绍Geo指令使用使用场景：附近的人参考文献 前言 Redis除了常见的五种数据类型之外，其实还有一些少见的数据结构，如Geo，HyperLogLog等。虽然它们少见，但是作用却不容小觑。本文将介绍Geo指令的语法和使用场景。 Geo介绍 Geo是"geolocation"的缩写，即地理定位器，顾名思义就是记录地理位置信息，用来进行地址位置排序的数据结构。所以它场景的应用场景便是寻找附近的人，最佳路线推荐等等。说到地址位置排序，不得不提地理位置距离排序算法GeoHash算法，Redis也使用了这个算法。简单来说，这个算法就是将某地点的经度和纬度进行编码之后，成为的一维整数，整数越接近，两个地点也就越接近。通过整数可以还原出经纬度坐标，整数越长，还原出来的坐标损失程度就越小。GeoHash算法会继续对这个整数做一次base32编码，使其变成字符串。于是在使用Geo数据结构时，可以简单地理解为，它只是一个zset，score是元素地址经过GeoHash算法得到的52位整数（在Redis里面，经纬度使用52位的整数进行编码），value存放该元素。 Geo指令使用 向Geo中添加地理空间信息：geoadd key 经度 纬度 具体元素
geoadd restaurant 95 20 "沙县小吃" geoadd restaurant 96 19 "肯德基" 120 27 "麦当劳" 返回指定两个元素的距离：geodist key 元素1 元素2 距离单位
geodist restaurant "沙县小吃" "肯德基" km 获取元素坐标：geopos key 元素1 … 元素n
geopos restaurant "麦当劳" geopos restaurant "沙县小吃" "肯德基" 获取指定元素坐标的hash字符串：geohash key 元素1
geohash restaurant "沙县小吃" 获取到的hash值可以到 http://geohash.org/${hash} 上进行定位，得到经纬度坐标 指定圆心半径，找到该圆范围内的所有元素，并按与圆心距离排序后返回：georadius key 经度 纬度 半径 单位 withdist/withcoord/withhash count n des/asc
georadius restaurant 95 21 100 km withdist count 3 asc # 查找经度95 纬度21的地点半径100公里以内的餐馆，正序输出三个餐馆 withdist: 同时返回该元素与圆心的距离，距离单位为georadius指令指定的单位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ccc18b658c3ee750c28453b8ad54cff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceb4ea87ea0a482efc899ce210de8a6f/" rel="bookmark">
			2024年美赛数学建模思路 - 案例：异常检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 赛题思路一、简介 -- 关于异常检测异常检测监督学习 二、异常检测算法2. 箱线图分析3. 基于距离/密度4. 基于划分思想 建模资料 赛题思路 （赛题出来以后第一时间在CSDN分享）
https://blog.csdn.net/dc_sinor?type=blog
一、简介 – 关于异常检测 异常检测（outlier detection）在以下场景：
数据预处理病毒木马检测工业制造产品检测网络流量检测 等等，有着重要的作用。由于在以上场景中，异常的数据量都是很少的一部分，因此诸如：SVM、逻辑回归等分类算法，都不适用，因为：
监督学习算法适用于有大量的正向样本，也有大量的负向样本，有足够的样本让算法去学习其特征，且未来新出现的样本与训练样本分布一致。
以下是异常检测和监督学习相关算法的适用范围：
异常检测 信用卡诈骗制造业产品异常检数据中心机器异常检入侵检测 监督学习 垃圾邮件识别新闻分类 二、异常检测算法 import tushare from matplotlib import pyplot as plt df = tushare.get_hist_data("600680") v = df[-90: ].volume v.plot("kde") plt.show() 近三个月，成交量大于200000就可以认为发生了异常（天量，嗯，要注意风险了……）
2. 箱线图分析 import tushare from matplotlib import pyplot as plt df = tushare.get_hist_data("600680") v = df[-90: ].volume v.plot("kde") plt.show() 大体可以知道，该股票在成交量少于20000，或者成交量大于80000，就应该提高警惕啦！
3. 基于距离/密度 典型的算法是：“局部异常因子算法-Local Outlier Factor”，该算法通过引入“k-distance，第k距离”、“k-distance neighborhood，第k距离邻域”、“reach-distance，可达距离”、以及“local reachability density，局部可达密度 ”和“local outlier factor，局部离群因子”，来发现异常点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceb4ea87ea0a482efc899ce210de8a6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4fc53743a6d1d433962f86c6633f51f/" rel="bookmark">
			Mac中安装JDK1.8和JDK11双版本并任意切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先区官网下载JDK8和JDK11安装包，安装后打开bash $ cd /Library/Java/JavaVirtualMachines $ ls -al 可以看到两个版本安装成功 然后编辑环境变量 现在在bash中输入jdk8或者jdk11就会切换版本了，输入java -version即可查看，成功！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35bb51a5c80a0a56c31db61016e8e465/" rel="bookmark">
			解决js计算精度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 浮点数，常用的办法是四舍五入保留2位小数来解决。但是在向上、向下保留小数的时候，比如：0.1+0.2=0.30000000000000004，向上保留2位小数就变成了0.31。
大整数，在超出Number的最大安全整数时，计算也会存在精度问题。
原因 二进制最大尾数是52位，超出长度的部分计算就会丢失精度
解决办法 浮点数使用 js-big-decimal 计算浮点数 npm官网：js-big-decimal - npm
安装
npm i js-big-decimal -S 封装方法 /utils/big-decimal.js
import bigDecimal from "js-big-decimal"; export default { // 声明 state(number) { return new bigDecimal(number); }, // 加 add(number1, number2) { return bigDecimal.add(number1, number2); }, // 减 subtract(number1, number2) { return bigDecimal.subtract(number1, number2); }, // 乘 multiply(number1, number2) { return bigDecimal.multiply(number1, number2); }, // 除 // precision: 精确度，默认最多保留8位小数 divide(number1, number2, precision = 8) { // 添加number，移除小数末尾多余0 return Number(bigDecimal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35bb51a5c80a0a56c31db61016e8e465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f37b038fee5f3ebaa4c849a53b58ae2/" rel="bookmark">
			nginx安装与使用教程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、简介配置文件介绍 二、安装1. 复制脚本2. 增加执行权限3. 执行脚本 三、nginx命令1. nginx管理命令1.1 启动nginx服务1.2 配置nginx服务自启动1.3 查看nginx状态1.4 停止nginx服务1.5 重启nginx服务 2. nginx常用命令2.1 用法2.2 命令选项2.3 命令示例2.3.1 显示帮助信息2.3.2 显示版本信息2.3.3 显示版本信息和配置选项信息2.3.4 测试配置文件2.3.5 测试配置文件并显示nginx配置文件信息2.3.6 检查配置文件的语法2.3.7 优雅的停止服务2.3.8 停止服务2.3.9 重新加载配置文件2.3.10 重新打开日志文件 四、nginx反向代理1. 介绍2. 示例 五、http负载均衡1. 介绍2. 示例2.1 轮询示例2.2 IP哈希示例2.3 最少连接示例2.4 加权轮询示例2.5 加权最小连接数示例2.6 备份服务器示例 六、TCP和UDP负载均衡1. TCP/UDP 代理2. 负载均衡2.1 TCP负载均衡示例2.2 UDP负载均衡示例 3. SSL/TLS 支持 七、配置代理协议1. 记录原始 IP 地址2. 用于与上游的 TCP 连接的 PROXY 协议 八、设置 HTTPS 服务器1. 客户端证书的 OCSP 验证2. 使用 HTTP 基本身份验证限制访问2.1 创建密码文件2.2 Nginx 配置2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f37b038fee5f3ebaa4c849a53b58ae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1fb61d940dd2c22f5613c1448f4423/" rel="bookmark">
			shell编程-uname命令详解（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、介绍二、语法格式三、常见选项四、示例用法1. 输出所有信息2. 查看内核名称3. 查看主机名4. 查看内核发行号5. 查看内核版本6. 查看硬件架构名称7. 查看处理器类型8. 查看硬件平台9. 查看操作系统名称10. 查看版本信息 总结 前言 在本文中，我们将介绍Linux和Unix系统中的uname命令及其常见选项。该命令用于显示操作系统的相关信息，包括内核版本、主机名、硬件架构等。
一、介绍 在Linux和Unix系统中，uname命令用于显示操作系统的相关信息。它是"UNIX name"的缩写，可以获取关于内核版本、主机名、硬件架构等信息。本文将详细解释uname命令及其常见选项。
二、语法格式 uname [选项] 三、常见选项 -a, --all 以如下次序输出所有信息。其中若-p 和 -i 的探测结果不可知则被省略。-s, --kernel-name 输出内核名称-n, --nodename 输出网络节点上的主机名-r, --kernel-release 输出内核发行号-v, --kernel-version 输出内核版本-m, --machine 输出主机的硬件架构名称-p, --processor 输出处理器类型或"unknown"-i, --hardware-platform 输出硬件平台或"unknown"-o, --operating-system 输出操作系统名称 --help 显示此帮助信息并退出 --version 显示版本信息并退出 四、示例用法 1. 输出所有信息 uname -a 2. 查看内核名称 uname -s 3. 查看主机名 uname -n 4. 查看内核发行号 uname -n 5. 查看内核版本 uname -v 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d1fb61d940dd2c22f5613c1448f4423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269cf584f605350fb6139b662ce004f1/" rel="bookmark">
			2.【Linux】（进程的状态||深入理解fork||底层剖析||task_struct||进程优先级||并行和并发||详解环境变量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.进程 1.进程调度 Linux把所有进程通过双向链表的方式连接起来组成任务队列，操作系统和cpu通过选择一个task_struct执行其代码来调度进程。
2.进程的状态 1.运行态：pcb结构体在运行或在运行队列中排队。
2.阻塞态：等待非cpu资源就绪（硬盘，网卡等资源）
3.挂起态：一个进程对应的代码和数据被操作系统因为资源不足而导致操作系统将该进程的代码和数据临时地置换到磁盘当中，进程的pcb还在内存中。
3.linux下进程的状态 R:对应上面的运行态
S：（可中断睡眠），对应上面的阻塞状态
D:深度睡眠，不可被中断。深度睡眠的状态进程，只能通过 “一觉睡到自然醒” 自己醒来，OS 无权唤醒或杀死之。
T：暂停状态（调试）
X：dead终止，瞬时性非常强
Z:僵尸状态
二.深入理解fork 1.介绍fork fork通过复制一份当前进程（父进程）来创建一份全新的进程（子进程），父进程创建成功返回子进程的pid，失败返回-1,子进程创建成功返回0，失败返回-1。
2.为何会有两个返回值？ fork可以分为以上三步：1.操作系统先将用户态转为内核态通过系统调用create创建一个空进程。2.调用clone将父进程的代码和数据（数据段，堆栈等）完全拷贝给子进程。3.return 返回。
当父进程通过前两步创建出子进程并把代码数据复制完成后，父进程便return返回子进程的pid。子进程有了父进程的所有数据（堆栈信息，pcb），由于pcb中记录了父进程代码执行到的位置，因此子进程会接着执行后续return语句，失败返回-1，成功返回0.
3.fork底层剖析 三个调用的区别在于传入的参数不同
具体细节参考
资料1
资料2
资料3
1.fork() 和 vfork() 参数是写死的，而 clone() 是可选的，它可以选择当前创建的进程哪些部分是共享的，哪些部分是独立的；
2. vfork() 是历史的产物，当调用 fork() 的时候，需要将父进程的线性区和页表都拷贝一份，而调用 exec()执行新程序后，又要把所有页表删除重置新的页表，建立映射关系，效率很低；
3.所以要有 vfork()，vfork() 的 clone_flags 位置了 CLONE_VM ，表示共享父进程的地址空间，vfork()中创建的进程没有分配自己的地址空间，而是通过一个 mm_struct 指针指向父进程的地址空间，这个进程是为了在之后调用 exec() 执行新的程序； 而在有了 Copy-on-write 技术后，fork()出的子进程只创建了自己的地址空间，然后用父进程的地址空间初始化，每个页表的项置为父进程的页表项，共享父进程的物理页面，并将所有 私有/可写页面改为只读；
4.当我们改变父子进程的数据后，cpu 在运行过程中会发生一个缺页错误，cpu 转交控制权给操作系统，操作系统查找 VMA。发现该页权限为只读，但所在段又是可写的，产生一个矛盾，这就是识别 Copy-on-write 的方法，接着 OS给子进程分配一个新的物理页，并将页表该页的地址修改成新的物理页地址；这样 fork() 后再调用 exec() 就不用那么麻烦了，可以直接将新的物理页与子进程的虚拟空间建立映射。
三.linux中的pcb实体task_struct 参考资料4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/269cf584f605350fb6139b662ce004f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f457f87dc0097fe40367ef418ccb49/" rel="bookmark">
			python并发任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程是执行用的，队列是存放结果用的
目录
1 多线程 threading
1.1 基本用法
1.2 循环使用
2 队列 queue
2.1 先进先出 queue.Queue()
2.2 后进先出 queue.LifoQueue()
2.3 优先级队列
3 线程池
1 多线程 threading 1.1 基本用法 使用的库为threading，threading是python内置的库
我们每运行一个python文件相当于开启了一个进程，一个进程中有多个线程，如果使用了多线程我们可以在一段py代码中并行运行程序
我下面做个简单的例子
我们发现第一个任务运行的时候，第二个任务并没有等待第一个任务结束后再开始运行，而是开启了任务一后，直接开启任务二
1.2 循环使用 开始的时候会根据start()的顺序开始，结束的时候，线程各自执行不会等待其他的线程
2 队列 queue 队列常用于处理多线程产生的结果
2.1 先进先出 queue.Queue() 依次放入1,2,3三个值，然后取三次，发现可以成功的按顺序取出1,2,3
如果队列空了之后再取，就会无限等待 2.2 后进先出 queue.LifoQueue() 依次放入1,2,3三个值，然后取三次，发现可以成功的按顺序取出3,2,1
如果队列空了之后再取，就会无限等待
2.3 优先级队列 依次放入(2, 'B') ,(1, 'A') ,(3, 'C') 。元组的第一个值是优先级，数字越小优先级越高
如果队列空了之后再取，就会无限等待
3 线程池 我们现在搞一个4线程的线程池，然后搞五个任务
Pool()中间的值是线程的个数，pool.map的第一个参数是要执行什么函数，第二个参数是函数的参数。pool.join()是等待线程池中的所有线程结束再执行下面的代码。pool.close()是关闭线程池。
我们通过上面的结果可以看出，一开始执行了4个任务，等一个任务完成后自动开始执行第五个任务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f5079d38d9c71975df1f13d73171bc9/" rel="bookmark">
			LLM之Agent（八）| 使用CrewAi、Solor/Hermes、Langchain和Ollama构建超级Agent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着大模型技术的发展，AI Agent正在成为大模型游戏规则的改变者，它可以帮助用户分解任务、规划任务和执行任务，这就是CrewAI的独特之处。CrewAI是AutoGEN的顶级替代品，为您提供轻松组建人工智能Agent团队执行自动化任务的能力。
在本文中，将介绍什么是CrewAi，架构设计，Autogen、ChatDev和Crew Ai之间的差异，以及如何使用Crew Ai、Langchain和Ollama的Solar或Hermes Power来构建超级Ai Agent。
一、什么是CrewAI？ Crew AI是一个优秀的框架，旨在协调角色扮演、自主的AI代理，使这些代理能够高效地协作和解决复杂任务。
CrewAi的主要特点包括：
基于角色的代理设计：CrewAi允许您自定义具有特定角色、目标和工具的人工智能AI代理；
自主代理间委托：代理可以自主委托任务并相互协商，提高解决问题的效率；
灵活的任务管理：用户可以使用自定义工具定义任务，并将其动态分配给代理；
本地模型集成：CrewAI可以通过Ollama等工具与本地模型集成，用于特殊任务或数据隐私考虑；
基于流程的操作：目前支持按顺序执行操作，并计划在未来支持更复杂的流程，如共识和分层流程。
二、Crew AI Vs AutoGen Vs ChatDev AutoGen：
虽然Autogen擅长创建会话代理，但它缺乏固有的流程概念。在Autogen中，协调代理的交互需要额外的编程，随着任务规模的增长，编程可能会变得复杂和繁琐。
ChatDev：
ChatDev将过程的概念引入了人工智能代理领域，但其实现相当僵化。ChatDev中的定制是有限的，不适合生产环境，这可能会阻碍实际场景应用程序的可扩展性和灵活性。
CrewAI：
CrewAI在构建时就考虑到了生产环境，它既具有Autogen对话代理的灵活性，也具有ChatDev的体系化过程方法。CrewAI是柔性的，流程设计是动态的且强大，能够无缝适应开发和生产工作流程。
三、CrewAI的实现 3.1 安装Ollama 我们首先下载Ollama.ai，下载链接：https://ollama.ai/。
选择合适的操作系统Ollama版本
您可以下载适用于Mac和Linux的Ollama。Windows版本即将推出
将Ollama移动到应用程序
将Ollama拖放到Applications文件夹中，此步骤仅适用于Mac用户。完成此步骤后，Ollama将完全安装在您的设备上。单击“下一步”按钮。
3.2 安装和部署Openhermes/solar或其他LLM 现在我们需要安装要在本地使用的LLM，命令如下：
Ollama run Solar Ollama现在将下载Solar，这可能需要几分钟的时间，具体取决于您的网速。一旦安装好，你就可以开始与它交谈了。
创建文件夹
让我们创建一个名为crewai的文件夹并导航到它。
3.3 安装Crewai和依赖项 我们用“python2.11-m venv crew”创建了一个虚拟环境，并用“source crew/bin/activate”激活它，然后安装“pip-install crewai”
3.4 安装必要的库 在开始之前，让我们安装所需的库。创建一个名为requirements.txt的文件，并在下面写入依赖项。
unstructuredlangchainJinja2&gt;=3.1.2click&gt;=7.0duckduckgo-search 之后，只需在VS Code中打开终端或者在打开Mac终端，并运行以下命令：
pip install -r requirements.txt 3.5 导入库 我们将从crewai导入Agent、Task、Crew和Process，然后从langchain.tools导入DuckDuckGoSearchRun来收集web信息。
DuckDuckGoSearchRun被创建并存储在变量search_tool中
我们从langchain.lms导入ollama来加载一个模型，这里使用Solar和Openhermes进行实验
from crewai import Agent, Task, Crew, Processimport os​from langchain.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f5079d38d9c71975df1f13d73171bc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03c451f222b48fe9e2fae51ec39779f/" rel="bookmark">
			docker报错 missing signature key 无法拉去镜像，yum install docker-ce没有可用软件包 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误场景描述 今天项目需要用到minio，我打算在虚拟机中使用docker装一个，可是发现当我docker pull minio/minio的时候，报错了missing signature key
这个报错提示的让人很蒙，翻译过来的意思是 “缺少签名密钥” ？？？
我原本以为，是不是docker发生了什么变动，需要登录之类的，可是当我在虚拟机中登录了我的docker之后，还是一样的报错
解决过程 我首先尝试了拉去其他的镜像，发现其他镜像是可以被拉去的，而Docker只是一个容器化工具，说明这个和签名什么的压根没关系
1. 卸载Docker yum erase docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine \ docker-ce 2. 重新安装docker-ce yum install docker-ce -y 然后我这里出现了新的报错
没有可用软件包 docker-ce。 没有可用软件包 docker-ce-cli。 没有可用软件包 containerd.io。 3. 更新yum yum update 换源
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 4. 再次尝试 yum install docker-ce -y 已加载插件：fastestmirror, langpacks adding repo from: http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c03c451f222b48fe9e2fae51ec39779f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74859d2d6124c9722fa21aa47ae31447/" rel="bookmark">
			vue&#43;elementUI el-select 中 没有加clearable出现一个或者多个×清除图标问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、现象：下方截图多×清除图标了
2、在全局common.scss文件中加一个下方的全局样式noClear
3、在多×清除图标的组件上层div加noClear样式
4、×清除图标去除成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31144dd74ccb34accc5db3902969ae6c/" rel="bookmark">
			Docker容器命令案例：Nginx容器修改，Redis容器持久化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓作者简介：一位大四、研0学生，正在努力准备大四暑假的实习
🌌上期文章：一文快速学会Docker软件部署
📚订阅专栏：Docker
希望文章对你们有所帮助
这里算是Docker的一次实践，创建并运行Nginx容器。
Docker容器命令案例：创建、运行与修改Nginx容器 创建并运行Nginx容器进入Nginx容器，修改HTML内容创建并运行Redis容器，实现持久化 创建并运行Nginx容器 去docker hub上可以查看到Nginx的容器运行命令。主要的形式：
docker run --name containerName -p 80:80 -d nginx 命令解读：
docker run：出啊精简并运行一个容器
–name：给容器起一个名字
-p：将宿主机端口与容器的端口映射，冒号左侧是宿主机端口，右侧是容器端口
-d：后台运行容器
nginx：镜像名称，这里没有指定版本就说明是最新版的
在Linux终端中运行：
docker run --name mn -p 80:80 -d nginx 查看是否正常运行：
docker ps 访问网页：192.168.177.130:80
在这里既然已经访问了，理论上应该会有相应的记录，我们需要查看容器的日志：
docker logs mn 进入Nginx容器，修改HTML内容 在这里，讲会进入Nginx容器，并修改HTML的文件内容，添加“NUAA欢迎您”。
步骤如下：
1、进入容器，进入刚刚创建的nginx容器的命令：
docker exec -it mn bash 命令解读
docker exec：进入容器内部，执行一个命令
-it：给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互
mn：要进入的容器的名称
bash：进入容器后执行的命令，bash是一个Linux终端交互命令
容易知道，目前进入的环境就差不多是Linux终端的环境了，但是里面所拥有的函数只是必备的函数，如果还要别的函数需要自己在这个环境下下载。
2、找到nginx的运行目录，这部分需要去docker hub的官方中查看，其具体的位置在**/usr/share/nginx/html**：
3、修改index.html：
这里的环境只有必备的函数，并没有vim函数，因此不能进入修改，可以用下面的语句对其进行修改：
sed -i 's#Welcome to nginx#NUAA欢迎您#g' index.html sed -i 's#&lt;head&gt;#&lt;head&gt;&lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31144dd74ccb34accc5db3902969ae6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ad522f79cb0059d708858a6ce1f09b3/" rel="bookmark">
			【软件测试常见Bug清单】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件测试中，bug的类型有很多种，比如：代码错误、界面优化、设计缺陷、需求补充和用户体验等；
一般情况下，需求补充和设计缺陷比较好区分，但是代码错误、界面优化和用户体验区分不是很明显；
下面我们就来说说这三者，顺带整理一些常见的这些类型的bug实例。
代码错误 代码错误通俗易懂，简单的来说，就是程序员在设计作品的时候，创作和写出来的编程代码是错误的，比如说方法、函数等等，实现不了需要的功能或者是实现了错误的功能。
实例如下：
1、操作或使用某一功能时，导致程序异常退出，或其余功能无法使用，或造成经常性死机和重启；
2、内存泄漏；
3、用户数据丢失或破坏；
4、系统崩溃、死机、冻结；
5、程序或模块无法正常启动或异常退出；
6、 严重的数值计算错误；
7、功能设计与需求严重不符；
8、导致其它功能无法使用的错误；
9、按键操作错误或失灵；
10、功能未实现；
11、功能错误；
12、系统刷新错误；
13、语音或数据通讯错误；
14、提示信息错误等。
界面优化 界面优化顾名思义就是操作界面的优化。
用户界面的功能模块的布局是否合理、整体风格是否一致、各个控件的放置位置是否符合客户使用习惯，界面操作便捷性、导航是否简单易懂；设计的风格和展现效果是否符合设计图等等。
常见实例有：
1、设计风格和展现效果与设计图不符；
2、字符串显示不统一；
3、拼写、对齐类的错误、UI图标、文字性错误；
4、界面显示不美观；
5、信息被遮挡，位置有错误；
6、图片错位，文字排列不整齐等问题。
用户体验 用户体验是一种纯主观在用户使用产品过程中建立起来的感受。但是对于一个界定明确的用户群体来讲，其用户体验的共性是能够经由良好设计实验来认识到的。
简单的来说，就是产品和用户之间的人机交互情况，是否友好，是否合理等；
实例有：
1、辅助说明描述不清楚；
2、操作时未给用户提示；
3、可输入区域和只读区域没有明显的区分标志；
4、个别不影响产品理解的错别字；
5、文字排列不整齐等一些小问题；
6、用户界面不太友好；
7、使用不习惯；
8、操作按钮可控区域大小的调节；
9、好的操作建议等。
最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65494e696b437bb6bb1af1f391b9138f/" rel="bookmark">
			IDEA 2023.3.2 安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载2023.3.2版本IDEA 链接：https://pan.baidu.com/s/1RkXBLz6qxsd8VxXuvXCEMA?pwd=5im6 提取码：5im6
2.安装 3.解压文件，进入，选择方式3 4.将下面文件夹复制到任意位置（不要有中文路径） 5.进入下面文件夹 6.双击下面文件 7.直到出现Done才行，大概1-2分钟，一定要等 8.复制该文件的路径 9.去idea安装目录，bin目录下，找到下面文件，用记事本打开 10.加入下面几行，注意是刚才复制的路径，注意格式，“/”不要反了，ctrl+s保存 -javaagent:C:/ja-netfilter/ja-netfilter.jar //刚才复制的路径 --add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 11、打开idea，复制下面文件的内容，粘贴到指定位置 注：显示2025年8月1日过期，但是实际上是99年的
本文章仅供学习交流使用，如有侵权，联系删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677d9699cd0d34aad83f14807917739a/" rel="bookmark">
			[二]rtmp服务器搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[二]rtmp服务器搭建 一.测试二.使用Nginx搭建自己的rtmp服务器1.nginx是什么？2.环境准备 三、搭建过程1.安装编译 nginx 所需要的库2.下载 nginx-1.21.6.tar.gz3.下载 nginx-rtmp-module 4.解压5.编译6.启动nginx，检测nginx是否能成功运行7.配置nginx使用RTMP, /usr/local/nginx/conf/nginx.conf8.重启nginx服务器 一.测试 SRS服务器地址：http://10.161.9.80:8066
下载ffmpeg.exe推流：
链接: https://pan.baidu.com/s/1WBtuubfj_ZpcTNneoAKv8Q?pwd=csck 提取码: csck 复制这段内容后打开百度网盘手机App，操作更方便哦 .\ffmpeg.exe -re -i 视频名称.mp4 -vcodec libx264 -acodec aac -f flv
rtmp://10.161.9.80/live/livestream
拉流测试:http://10.161.9.80:8066/live/livestream.flv
二.使用Nginx搭建自己的rtmp服务器 1.nginx是什么？ nginx是一款优秀的反向代理工具，通过nginx可以实现搭建高可用的轻量级web服务器，除此之外，通过Nginx自带的rtmp模块，也可以实现rtmp服务器的搭建。
2.环境准备 1.系统版本
Ubuntu 18.04.4
2.nginx版本
nginx/1.21.6
三、搭建过程 1.安装编译 nginx 所需要的库 sudo apt-get install build-essential libpcre3 libpcre3-dev libssl-dev
2.下载 nginx-1.21.6.tar.gz wget http://nginx.org/download/nginx-1.21.6.tar.gz
3.下载 nginx-rtmp-module wget https://github.com/arut/nginx-rtmp-module/archive/master.zip
4.解压 1）解压nginx文件
tar -zxvf nginx-1.21.6.tar.gz
2）解压rtmp模块
unzip master.zip
5.编译 1）进入解压后的nginx路径
cd nginx-1.21.6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/677d9699cd0d34aad83f14807917739a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0761fc08294ec5d22a8b59f7d9e76b3b/" rel="bookmark">
			LLM之LangChain（四）| 介绍LangChain 0.1在可观察性、可组合性、流媒体、工具、RAG和代理方面的改进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LangChain是大模型应用中非常火的一个框架，最近发布了LangChain 0.1版本，在以下方面带来显著改进：
ObservabilityComposabilityStreamingTool UsageRAGAgents 在本文中，我们将使用一些代码示例来分别介绍一下这些改进的使用方法。
一、LangChain 0.1概述 在0.1发布之前，LangChain团队与100名开发人员进行了深入交流，从而为LangChain的升级提供了宝贵建议。
为了增强基础功能，他们将框架分为3个包：
langchain-core：构成主干，包括主要的抽象、接口和核心功能，包括langchain表达式语言（LCEL）。
langchain-community：旨在更好地管理依赖关系，该包包括第三方集成，增强langchain的健壮性和可扩展性，并改善整体开发者体验。
langchain：专注于更高级别的应用程序，比如Chain、Agent和检索算法的特定用例。
LangChain 0.1还引入了清晰的版本控制策略，以保持向后兼容性：
小版本更新（第二位数字）表示将提供一个突破性变更的公共API；补丁版本（第三位数字）将表示错误修复或新增功能。 二、可观测性（Observability） 为了深入了解LangChain应用程序的内部工作，可以使用set_verbose和set_debug来了解引擎执行的细节。
from langchain.globals import set_debug​set_verbose(False)set_debug(True)​prompt = hub.pull("hwchase17/openai-functions-agent")llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0)search = TavilySearchResults()tools = [search]agent = create_openai_functions_agent(llm, tools, prompt)agent_executor = AgentExecutor(agent=agent, tools=tools)​agent_executor.invoke({"input": "what is the weather in sf?"}) [chain/start] [1:chain:AgentExecutor] Entering Chain run with input:{ "input": "what is the weather in sf?"}[chain/start] [1:chain:AgentExecutor &gt; 2:chain:RunnableSequence] Entering Chain run with input:{ "input": "what is the weather in sf?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0761fc08294ec5d22a8b59f7d9e76b3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbb88aa12c286f4971f4d7fff8af35c/" rel="bookmark">
			CGAL最小生成树、可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CGAL 5.4.5 - Surface Mesh: User Manual
1、Kruskal计算最小生成树 #include &lt;CGAL/Simple_cartesian.h&gt; #include &lt;CGAL/Surface_mesh.h&gt; #include &lt;boost/graph/kruskal_min_spanning_tree.hpp&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;list&gt; typedef CGAL::Simple_cartesian&lt;double&gt; Kernel; typedef Kernel::Point_3 Point; typedef CGAL::Surface_mesh&lt;Point&gt; Mesh; typedef boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor; typedef boost::graph_traits&lt;Mesh&gt;::vertex_iterator vertex_iterator; typedef boost::graph_traits&lt;Mesh&gt;::edge_descriptor edge_descriptor; /* Surface_mesh 提供了四个嵌套类，分别代表半边数据结构的基本元素： Surface_mesh::Vertex_index曲面网格::顶点索引 Surface_mesh::Halfedge_index曲面网格::半边索引 Surface_mesh::Face_index曲面网格::面索引 Surface_mesh::Edge_index曲面网格::边索引 */ void kruskal(const Mesh&amp; sm) { // 默认权重=边的平方长 存储Surace_mesh 的边信息 std::list&lt;edge_descriptor&gt; mst; //9600-&gt;3199 边 boost::kruskal_minimum_spanning_tree(sm, std::back_inserter(mst)); std::cout &lt;&lt; "#VRML V2.0 utf8\n" "Shape {\n" " appearance Appearance {\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fbb88aa12c286f4971f4d7fff8af35c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b9297fc32c69c07552d5b4bc10ca4c9/" rel="bookmark">
			Redis三种缓存读写策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. Cache Aside Pattern 旁路缓存模式 1.1 读 1.2 写 1.3 为什么要先更新db再删除cache? 缓存的写入速度是比数据库的写入速度快很多,因此相比于先删除cache后更新db带来数据不一致性问题的概率更小。
1.4 特点 平时使用比较多的一个缓存读写模式同时维系db 和 cache，以db结果为准首次请求数据一定不在cache 2. Read/Write Through Pattern 读写穿透 2.1 读 2.2 写 2.3 特点 在 Cache-Aside Pattern 之上进行了封装，cache 服务自己来写入缓存，对客户端是透明的首次请求数据一定不在cache把 cache 视为主要数据存储同步更新 cache 和 db 3. Write Behind Pattern 异步缓存写入 3.1 特点 只更新缓存，不直接更新 db采用异步批量的方式来更新 db写性能非常高，适合数据经常变化但对数据一致性要求不高的场景 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65aef3f5e4742daed7b29e7dbae68615/" rel="bookmark">
			flutter 环境搭建异常记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter 环境搭建异常记录
1.执行flutter doctor自检报错
排查Android studio里配置的sdk是哪个
SDK Platforms选中 8.0
SDkTools也只勾选8.0
2.bash_profile 文件配置
没有的话 在根目录新建
export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn export PATH=~/development/flutter/bin:$PATH
export PATH=~/development/flutter/bin/cache/dart-sdk/bin:$PATH
export ANDROID_HOME=~/Library/Android/sdk
export PATH=${PATH}:${ANDROID_HOME}/emulator
export PATH=${PATH}:${ANDROID_HOME}/tools
export PATH=${PATH}:${ANDROID_HOME}/platform-tools
3.全局命令行配置及生效
source ~/.bash_profile
source ~/.zshrc
open ~/.bash_profile
open ~/.zshrc
4.安卓本地的gradle版本存放位置
/Users/zhaoguangliang/.gradle/wrapper/dists
若自动下载太慢 可以使用迅雷手动下载之后放在这里
5.配置 firebase的时候 提示找不到成员变量 需在添加的firebase_core之外 在yaml文件里新增加一个依赖
firebase_core_platform_interface: 4.5.1
然后在android的工程中进行编译 就可以通过了
6.在新电脑上配置Android studio jdk路径位置
/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home
从Mac 复制jdk文件夹到对应的文件夹下
7.在安卓项目出现gradle sync faile的时候 在android sdk 里 第一个列表里的sdk都拉下来，在第二个列表里的commond Line里将第一个最新的编译工具也拉下来
8.报错 Cannot operate on packages inside the cache.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65aef3f5e4742daed7b29e7dbae68615/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0ab5935abe408873078727bf99695d/" rel="bookmark">
			《数据结构》第七章：树和森林
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在客观世界中，存在着诸多如行政机构、磁盘目录和族谱的组织结构，与动物分类类似，是一种层次化结构，可采用树形结构表示。譬如磁盘目录，一个目录的子目录通常不止两个，无法用二叉树表示，需要采用多叉树的形式，即每个结点可以有不同数目的子结点。
7.1树的定义 树是含有n个结点的有限集合。在任意一棵非空树中：
有且仅有一个特定的称为根的结点当n＞1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1，T2，…，Tm，其中每一个集合本身也是一棵树。并且T1，T2，…，Tm称为根的子树。 树中的相关概念，如结点的度、孩子结点和双亲结点等，定义与二叉树中的相同。
森林是m（m≥0）棵互不相交的树的集合，可记为F=（T1，T2，…，Tm）。对树中的每个结点而言，其子树的结合即为子树森林。
7.2树的存储结构 树的存储结构有多种，可以应用于不同场合。但无论采用哪种存储结构，都要求其不仅能存储各结点本身的信息，还能表示树中各结点之间存在的关系。
7.2.1双亲表示法 在树中，除根结点没有双亲（即父结点）外，其他结点的双亲是唯一确定的。根据这个特性，可用数组存储树中结点及其关系。数组中的每个分量含有两个域：元素值data和该结点的双亲位置parent。树的这种表示方法称为双亲表示法。
树的双亲存储结构类型定义如下：
typedef struct PTNode{ TElemType data;//数据域 int parent;//双亲位置，根结点的parent值为-1 }PTNode;//双亲结点类型 typedef struct{ PTNode *nodes;//由初始化分配的结点数组 int r,nodeNum;//根结点和结点数 }PTree;//树的双亲存储结构类型 显然，这种存储结构可由parent直接找到双亲，并可容易地找到所有祖先。但如果需要查找结点的孩子及其子孙，则需要遍历整个结构。
7.2.2双亲孩子表示法 双亲孩子表示法是对双亲表示法的扩展，为各结点构造孩子单链表，以便访问结点的孩子及其子孙。在结点数组元素增加firstChild域作为结点的孩子链表头指针。在孩子链表中，每个结点包含孩子在结点数组的位置child Index和指向下一个孩子结点的指针nextChild。
树的双亲孩子存储结构的类型定义如下：
typedef struct ChildNode{ int ChildIndex;//孩子在结点数组的位置 struct ChildNode *nextChild;//下一个孩子 }ChildNode;//孩子链表中的结点类型 typedef struct{ TElemType data;//元素值 int parent;//双亲位置 struct ChildNode *firstChild;//孩子链表头指针 }PCTreeNode;//双亲孩子结点类型 typedef struct{ PCTreeNode *nodes;//结点数组4 int nodeNum,r;//结点元素个数、根位置 }PCTree;//树的双亲孩子存储结构类型 双亲孩子表示法存储了孩子结点的信息，便于实现涉及孩子或双亲的操作。若不涉及双亲操作，则可以去掉parent域，简化为孩子链表存储结构。
7.2.3孩子兄弟表示法 在树中，结点的最左孩子（第一个孩子）和右兄弟（下一个孩子）如果存在则都是唯一的。因此，孩子兄弟表示法采用二叉链式存储结构，每个结点包含三个域：元素值域data、最左孩子指针firstChild和右兄弟指针nextSibling。
树的孩子兄弟链表的类型定义如下：
typedef struct CSTNode{ TElemType data;//数据域 struct CSTNode*firstChild,*nextSibling;//最左孩子指针、右兄弟指针 }CSTNode,*CSTree,*CSForest;//孩子兄弟链表 以下是基于孩子兄弟表示法的树接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a0ab5935abe408873078727bf99695d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/532348755b6f5c5a3ac9ede1e430228e/" rel="bookmark">
			mybatis不想使用 $ 符号来动态传递列参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以考虑使用 MyBatis 的 &lt;choose&gt;、&lt;when&gt; 和 &lt;otherwise&gt; 标签来实现类似的功能。
&lt;select id="selectUsers" parameterType="map" resultType="com.example.model.User"&gt; SELECT &lt;choose&gt; &lt;when test="columns != null and columns.contains('id')"&gt; id, &lt;/when&gt; &lt;when test="columns != null and columns.contains('name')"&gt; name, &lt;/when&gt; &lt;when test="columns != null and columns.contains('age')"&gt; age, &lt;/when&gt; &lt;otherwise&gt; * &lt;/otherwise&gt; &lt;/choose&gt; FROM user &lt;if test="conditions != null"&gt; WHERE ${conditions} &lt;/if&gt; &lt;/select&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0976b475c834c2898895530457d74199/" rel="bookmark">
			LNTON人形检测、行人检测工具，支持图片、RTSP实时流、mp4文件中的行人或者人形检测，实用工具，亲测可用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 LNTON_PID 是一个行人检测工具，能够对图像、视频、文件夹中的多个文件或RTSP实时流进行行人检测，并支
持自定义输出结果和行人区域位置的保存。该工具提供了灵活的参数配置选项以适应各种应用场景。
快速开始 - 命令行参数格式（Linux/Unix环境） ./pid_tools_gensamples INPUT_PATH OUT_RESULT_DIR[DEFAULT:results]
OUT_PATCH_DIR[DEFAULT:patchs] SHOW[T|F]
INPUT_PATH: 指定输入资源路径，可以是单个图像文件、视频文件、包含多个图像或视频的目录路径，
或者是RTSP流地址。OUT_RESULT_DIR: 设定输出行人检测结果的目录，默认为results。程序会将带有行人框标记的结果图
像或视频片段保存到此目录下。OUT_PATCH_DIR: 设定用于保存检测到的行人区域图片的目录，默认为patchs。每个检测到的行人都会
被裁剪并单独存储在这个目录中。SHOW[T|F]: 控制是否在屏幕上实时显示处理过程及结果。T表示开启显示，F表示关闭显示，默认开启。
若要关闭显示，请指定 F。 示例用法 以下是在Linux/Unix环境下直接运行命令行工具的例子：
./pid_tools_gensamples /path/to/input_image.jpg /path/to/output_results
./pid_tools_gensamples /path/to/input_video.mp4 /path/to/output_results
/path/to/output_patches T
./pid_tools_gensamples /path/to/input_folder /path/to/output_results
/path/to/output_patches F
./pid_tools_gensamples rtsp://your/stream/address /path/to/output_results
/path/to/output_patches
快速开始 - 命令行参数格式（Windows环境） 在Windows环境下，由于命令行语法和Linux环境有所不同，但基本的参数传递方式是类似的。假设
pid_tools_gensamples.exe在Windows系统下也能正常运行，并且参数格式保持一致，那么在命令提示符窗
口中使用LNTON_PID工具的方式如下：
REM Windows命令行示例：
pid_tools_gensamples.exe INPUT_PATH OUT_RESULT_DIR[DEFAULT:results]
OUT_PATCH_DIR[DEFAULT:patchs] SHOW[T|F]
REM 示例用法：
.\pid_tools_gensamples.exe “C:\path\to\input_image.jpg”
“C:\path\to\output_results”
.\pid_tools_gensamples.exe “C:\path\to\input_video.mp4”
“C:\path\to\output_results” “C:\path\to\output_patches” T
.\pid_tools_gensamples.exe “C:\path\to\input_folder” “C:\path\to\output_results”
“C:\path\to\output_patches” F
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0976b475c834c2898895530457d74199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255392c3a99390010dc3a65d078576e7/" rel="bookmark">
			MySQL运维实战(4.5) SQL_MODE之NO_ZERO_DATE和NO_ZERO_IN_DATE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：俊达
引言 NO_ZERO_DATE 和 NO_ZERO_IN_DATE这两个SQL MODE，主要用于确保日期字段不包含非法的零值，以提高数据的完整性和准确性。
1、**NO_ZERO_DATE 模式：**日期中不允许使用 ‘0000-00-00’ 这样的零值。如果启用了该模式，MySQL将拒绝插入或更新包含这种零值的日期数据。
2、**NO_ZERO_IN_DATE 模式：**日期中年、月或日不允许为0，如不允许’2021-00-01’, ‘2021-01-00’，启用此模式后，MySQL会阻止插入或更新包含这种零值的日期数据。
date, datetime, timestamp都会受这两个SQL MODE的影响，而且它们需要跟 STRICT MODE 一起使用。启用 STRICT MODE 将在遇到数据不符合规范的情况下引发错误，防止非法数据被写入数据库。如果不开启 STRICT MODE，MySQL 在遇到异常数据时可能会尝试进行隐式转换或使用默认值，从而允许非法数据进入数据库。
NO_ZERO_DATE 只设置NO_ZERO_DATE, 异常数据会产生Warning，但是数据能写入
mysql&gt; create table t_date( a date); Query OK, 0 rows affected (0.01 sec) -- 只设置NO_ZERO_DATE, 异常数据会产生Warning，但是数据能写入 mysql&gt; set sql_mode='NO_ZERO_DATE'; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&gt; insert into t_date values(0); Query OK, 1 row affected, 1 warning (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255392c3a99390010dc3a65d078576e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438da86e8a8199d5e4a05f67911690dd/" rel="bookmark">
			MySQL驱动扯后腿？Spring Boot用虚拟线程可能比用物理线程还差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前已经分享过多篇关于Spring Boot中使用 Java 21新特性虚拟线程 的性能测试案例：
Spring Boot 3.2虚拟线程搭建静态文件服务器有多快？
Spring Boot 虚拟线程与Webflux的性能比较
早上看到群友问到一个关于虚拟线程遇到MySQL连接不兼容导致的性能问题：
这个问题确实之前就有看到过相关的评测，顺着个这个问题，重新把相关评测找出来，给大家分享一下。
以下内容主要参考文章：https://medium.com/deno-the-complete-reference/springboot-physical-vs-virtual-threads-vs-webflux-performance-comparison-for-jwt-verify-and-mysql-23d773b41ffd
评测案例 评测采用现实场景中的处理流程，具体如下：
从HTTP授权标头（authorization header）中提取 JWT
验证 JWT 并从中提取用户的电子邮件
使用提取到的电子邮件执行 MySQL 查询用户
返回用户记录
这个场景其实是 Spring Boot 虚拟线程与Webflux的性能比较 测试的后续。前文主要对比了虚拟线程和WebFlux的，但没有对比虚拟线程与物理线程的区别。所以，接下来的内容就是本文关心的重点：在物理线程和虚拟线程下，MySQL驱动是否有性能优化。
测试环境 Java 20（使用预览模式，开启虚拟线程）
Spring Boot 3.1.3
依赖的第三方库：jjwt、mysql-connector-java
测试工具：Bombardier
采用了开源负载测试工具：Bombardier。在测试场景中预先创建 100,000 个 JWT 列表。
在测试期间，Bombardier 从该池中随机选择了JWT，并将它们包含在HTTP请求的Authorization标头中。
MySQL表结构与数据准备
User表结构如下：
mysql&gt; desc users; +--------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+--------------+------+-----+---------+-------+ | email | varchar(255) | NO | PRI | NULL | | | first | varchar(255) | YES | | NULL | | | last | varchar(255) | YES | | NULL | | | city | varchar(255) | YES | | NULL | | | county | varchar(255) | YES | | NULL | | | age | int | YES | | NULL | | +--------+--------------+------+-----+---------+-------+ 6 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/438da86e8a8199d5e4a05f67911690dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/390de99e0d93998508affbe094d32186/" rel="bookmark">
			羡慕同学进了大厂核心部门，看懂这本书你也能行！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末赠书
Part.1
做推荐算法在大厂有多吃香？
小异最近听说一位做推荐算法的同学通过面试，顺利入职某大厂核心盈利部门，真是太羡慕他了。为什么会推荐算法就能在大厂这么吃香？
因为大厂要依靠推荐系统来变现。例如，电商企业要向用户推荐最需要的商品；视频流媒体平台要向用户推送最喜欢的内容；社交新闻媒体平台要让用户看到最感兴趣的信息……
因此，推荐系统和企业的收入直接相关，推荐算法做得好，企业就可以更好地理解用户需求，从而精准地推荐商品，增加销售额，提高用户忠诚度。
那对于技术人来说，做好推荐系统都有哪些挑战？
推荐算法是一项综合性很强的技术，它需要运用多种技术手段去解决实际问题，包括机器学习、数据挖掘、自然语言处理等。技术人可能会困惑，这么多知识要学习，要学到什么程度？怎样才能学好推荐算法？
有一位在大厂做推荐算法的资深技术人专门写了一本书来解答上面的疑问，这本书就是《互联网大厂推荐算法实战》。从书名就可以看出来，这本书讲的都是大厂的实战经验，想学推荐算法，看这本书就对了。
▼点击下方，即可购书
我们先来了解一下推荐算法的工作原理。
Part.2
推荐系统是怎么工作的
推荐系统的主要原理是通过对用户的历史行为数据（如点击、购买、评分、评论等）进行分析和挖掘，提取用户的兴趣和喜好，并将其映射到物品空间中，从而预测用户对未来物品的偏好程度，最终生成个性化推荐结果。
在推荐系统中有两个最基本的角色：一个是用户（User），推荐系统要服务的对象，同时也是推荐系统的重要贡献者；另一个是物料（Item），统称为被推荐的信息和内容，例如具体商品、视频、音乐、新闻等。
推荐系统会执行四个步骤，从数百万量级的物料中挑选出最优的几十个物料，最终呈现在用户面前。下面按顺序介绍这四个步骤。
· 召回：主要依赖“离线计算+在线缓存”模式，从百万规模候选集中快速筛选。这一步可以牺牲一部分精度，换取时间。
· 粗排：召回会以数量来弥补质量的不足，在送往下一步之前，粗排要进行一次筛选，保留最具潜力的 10% 物料。
· 精排：精排模型会让用户信息与物料信息充分交叉，从而精选出最符合用户品味的几十个物料。
· 重排：调整精排结果的顺序，将相似内容打散，使得用户可以看到丰富多样的推荐结果。
推荐系统的四个步骤
为我们揭秘大厂推荐算法的那位资深技术人，是毕业于清华大学电气工程专业的赵传霖博士，他目前在快手担任算法专家，拥有 10 多年互联网算法从业经验，主要研究方向为推荐系统、计算广告、个性化搜索。
赵博士还是知乎“机器学习”话题优秀答主，曾经 4 次获得知乎创作排行榜“知势榜·影响力榜”（科技互联网领域）第一名。
有感于市面上讲推荐算法的图书要么内容老旧，要么只讲算法理论，脱离实际太远，于是赵博士决定创作《互联网大厂推荐算法实战》，分享一线实战经验，帮助大家理解推荐算法并灵活组合应用，从“术”上升到“道”的层面。
现在我们就跟着赵博士深入到大厂一线来学习推荐算法吧。
Part.3
推荐算法这样学就对了
推荐算法应该怎么学？
是不管三七二十一狠钻现在最流行的算法，然后就指望一年知识用十年？这显然是不现实的，因为新算法和新模型在未来会层出不穷，不可能每个算法都要靠大力出奇迹的方式去学习。
所以赵传霖博士在书中明确反对孤立、机械地学习算法，而是提倡“透过现象看本质”，要充分理解算法的思想。要想在实际工作中灵活运用，就要悟透算法之道。
本书将重心放在了帮助读者梳理算法的发展脉络，指导读者由“术”入“道”，达到“举一反三”的目的。全书内容可分为三个部分，我们来了解一下各部分的内容。
首先是基础知识部分。介绍了推荐系统的基础知识、推荐系统中的特征工程、推荐系统中的 Embedding 技术。
然后介绍推荐系统的各组成模块所使用的算法技术，包括召回、粗排、精排、重排四个模块。还对推荐算法实践中经常遇到的难题给出了应对之道。
这部分内容极具价值，因为书中对多任务推荐、多场景推荐、新用户冷启动、新物料冷启动、评估模型效果等实际应用场景进行细致的分析，定位并解决问题，是作者对大厂经验的直接分享。
最后一部分是写给推荐算法工程师的，涵盖工作中的注意事项、学习方法，以及一些面试求职方面的宝贵建议。毕竟赵博士面试过许多求职者，可谓“阅人无数”，有他为读者把关，进大厂的希望那是相当大的。
通过以上三个部分的学习，读者可以对推荐算法知识融汇贯通，对各种实践场景了然于胸，工作时能做到举重若轻，各种难题纷纷迎刃而解。
Part.4
结语
赵博士的理念是“授人以鱼，不如授人以渔”，他希望通过自己的分享，能让读者透彻理解推荐算法，并且在工作中灵活运用解决实际问题，少走弯路。
本书最大的特点是“实战”，书中讲述的都是互联网大厂主流的推荐算法。对于“经典但过时”的协调过滤、矩阵分解算法则干脆不讲，因为大厂都不玩这些了，而且也不是面试时考察的重点，所以没有去浪费笔墨。
本书兼顾理论与实践，除了讲解最基本的算法原理，还聚集于算法工程师的工作实际，关注他们日常遇到的实际难题。例如下面所列问题。
· 新用户与新物料怎么冷启动？
· 如何打开模型的黑盒，以排查问题或找到下一步升级改进的方向？
· 线下 AUC 涨了，但是线上 AB 实验的指标却不涨！这到底是什么原因造成的？
学习技术不仅要“talk”，也要有“code”。赵博士认为算法工程师也属于广义上的程序员，源代码是最清晰直接的说明文档。所以书中针对核心算法都给出了相应的源码。
书中对于核心代码还给出了说明注释，帮助读者彻底理解算法的重要细节。至此，大厂是怎么玩推荐系统的，可说是一目了然，读者诸君切莫辜负了赵博士，定要多加学习思考，勤于练习。
还在羡慕做推荐算法的同学拿到大厂的 offer 吗？与其临渊羡鱼，不如退而结网，有《互联网大厂推荐算法实战》的加持，也许你很快也能进大厂和同学做同事。
▼点击下方，即可购书
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/390de99e0d93998508affbe094d32186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c785ccea9a40d1d92d87a9d1abdfe4e/" rel="bookmark">
			如何搭建Z-blog网站并结合内网穿透实现无公网ip访问本地站点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. Z-blog网站搭建2.1 XAMPP环境设置2.2 Z-blog安装2.3 Z-blog网页测试2.4 Cpolar安装和注册 3. 本地网页发布3.1. Cpolar云端设置3.2 Cpolar本地设置 4. 公网访问测试5. 结语 1. 前言 想要成为一个合格的技术宅或程序员，自己搭建网站制作网页是绕不开的项目。就以笔者自己的经历来说，就被自制网页网站卡过很久。不过随着电脑技术的发展，已经出现了很多便捷快速建站的工具软件。今天，笔者就为大家展示，如何快速上手Z-blog，建立自己的个人博客网站，并通过cpolar建立的内网穿透数据隧道，将这个个人博客软件发布到公互联网上。
2. Z-blog网站搭建 Z-blog是一款基于Asp和PHP平台的开源程序，其功能与Wordpress类似，也支持多种模板和插件，而且也能支持双数据库；如果使用者再会一点HTML+CSS+JS，就可以轻松的制作出自己的模板。当然，这些并不是我们今天的主题。今天我们要做的，就是向大家展示，如何使用cpolar将Z-blog网站发布到公共互联网上。
2.1 XAMPP环境设置 与其他的网站建设工具一样，要在本地安装Z-blog，也需要搭建起必要的网站运行环境，这里我们采用XAMPP搭建网站运行环境。我们可以在XAMPP的官网（www.apachefriends.org）上找到对应操作系统的版本。
笔者是在Windows操作系统上安装Z-blog，因此选择Windows版本的XAMPP。
安装程序下载完成后，直接双击就能开始安装
安装完成后，我们打开XAMPP的主程序，打开Apache和MySQL。
2.2 Z-blog安装 打开Z-blog所需的运行环境后，我们到Z-blog的官网上（https://www.zblogcn.com/）下载Z-blog的安装包。
接着将安装包解压，并将其中的文件都粘贴到xampp安装目录下的htdocs文件夹中
需要注意的是，通常htdocs文件夹里会有一些xampp的网页显示文件，要将这些文件删除，才能正确显示Z-blog的安装页面。
2.3 Z-blog网页测试 由于Z-blog是网页程序，因此我们打开浏览器，并在地址栏输入本地地址的XAMPP网页输出端口，也就是Apache的输出端口（通常Apache的输出端口号为80，但由于笔者的80端口已经被占用，因此将apache输出端口更改为82）。
只要之前的设置正确，就能看到Z-blog网页的安装界面。首先勾选页面下方的同一协议框，并点击旁边的下一步，进入网页安装环境检查。
只有各项自检都通过，才能继续网页安装程序。
接下来就是设置数据库、网站管理员等信息，设置完毕后就能点击右下方的“下一步”，完成Z-blog网站的安装。
2.4 Cpolar安装和注册 完成Z-blog网站搭建后，就可以安装[cpolar内网穿透](cpolar - 安全的内网穿透工具)，cpolar的安装注册同样很简单，直接在cpolar的官网页面（https://www.cpolar.com/）找到下载按钮。
笔者是在Windows平台上搭建的Z-blog网站，因此选择Windows版本进行下载。
Cpolar下载完成后，将下载的文件解压，双击解压后的.msi文件，即可自动执行安装程序。接着只要一路Next就能完成安装。
cpolar会为每个用户创建独立的数据隧道，辅以用户密码和token码，保证每个用户的数据安全，因此我们在使用cpolar之前，需要进行用户注册。注册过程非常简单，只要在cpolar主页右上角点击用户注册，在注册页面填入必要信息，就能完成注册。
3. 本地网页发布 完成了Z-blog网站搭建和cpolar内网穿透软件的安装，接下来我们就可以使用cpolar内网穿透，建立起一条内网穿透数据隧道，将本地电脑上的Z-blog网站发布到公共互联网上。由于Z-blog网站会长期存在，cpolar免费版的数据隧道每24小时重置一次。笔者并不想每天重新设置Z-blog的网址，因此将cpolar升级至vip版，以获得能长期稳定存在的内网穿透数据隧道。
3.1. Cpolar云端设置 要想建立一条长期稳定的数据隧道，我们需要先拥有一个能稳定存续的公共互联网地址，并且这个互联网地址要与本地网页（软件）的输出端口相连，才能形成一条完整且稳定的数据隧道。因此我们需要先点击进入cpolar的数据隧道预留页面。在这里生成一个公共互联网地址（也可以看做数据隧道的入口），由于此时这个地址没有连接本地的软件输出端口，因此也可以看做是一条空白的数据隧道。
在预留页面，我们可以看到Cpolar支持保留很多种协议的数据隧道，这里我们选择保留二级子域名栏位。
在“保留二级子域名”栏位，我们要输入几项简单信息，为cpolar保留的数据隧道进行设置，这几项信息为：
地区：服务器所在区域，就近选择即可二级域名：会最终出现在生成的公共互联网地址中，作为网络地址的标识之一描述：可以看做这条数据隧道的描述，能够与其他隧道区分开即可 完成这几项设置后，就可以点击右侧的保留按钮，将这条数据隧道保留下来。
当然，如果这条数据隧道不打算再使用，还可以点击右侧的x将其轻松删除，节约宝贵的隧道名额。
3.2 Cpolar本地设置 完成cpolar云端的设置，并保留了空白数据隧道后，我们回到本地的cpolar客户端，将云端生成的空白数据隧道与本地的Z-blog页面连接起来。
在本地打开并登录cpolar客户端（可以在浏览器中输入localhost:9200直接访问，也可以在开始菜单中点击cpolar客户端的快捷方式），点击客户端主界面左侧隧道管理——创建隧道按钮，进入本地隧道创建页面（如果要创建没24小时重置地址的临时数据隧道，可直接在此进行设置，不必再cpolar官网设置空白数据隧道）。
在这个页面，同样需要进行几项信息设置，这些信息设置包括：
1. 隧道名称 ：可以看做cpolar本地的隧道信息注释，只要方便我们分辨即可；
2. 协议 – 由于支付宝的测试页面是网页，因此选择http协议；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c785ccea9a40d1d92d87a9d1abdfe4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159772e73733612bc95c62fb01710871/" rel="bookmark">
			java中为什么不允许变量名是数字开头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、标识符 Java中变量、方法、类等要素命名时使用的字符序列，称为标识符。
技巧：凡是自己可以起名字的地方都叫标识符。
二、java中标识符的命名规则（必须遵守的硬性规定）： &gt; 由26个英文字母大小写，0-9 ，_或 $ 组成 &gt; 数字不可以开头。
&gt; 不可以使用关键字和保留字，但能包含关键字和保留字。
&gt; Java中严格区分大小写，长度无限制。
&gt; 标识符不能包含空格。
三、java中为什么不允许变量名是数字开头 在java中long类型的数据类型在定义的时候必须在最后加上“l”或者“L”
int 123L = 12;//将123L作为标识符 long l6 = 123L;//long类型的数据类型定义的时候需要在后面加“l”或“L”，所以就会产生冲突 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93aa8b50572ab97af48459ae344ec7f/" rel="bookmark">
			查找国外文献的技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、方法二、配置参考 一、方法 xrelay（1年） 其他手段：
手段1手段2 需要自己去看怎么配置
二、配置 google浏览器走代理的配置：
配置步骤：
方法1：https://steemit.com/cn/@causenet/7-switchyomega方法2：https://github.com/entr0pia/SwitchyOmega-Whitelist 看不懂的话，直接使用方法1进行配置即可
免费的chatGpt国内收费chatgptp 参考 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf9fd8549156e7c56cd659cde876a79/" rel="bookmark">
			Windows安装WSL2精简版教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装WSL二、更改WSL的存放路径/备份WSL三、安装WSL Terminall四、WSL界面：xlaunch五、WSL1升级WSL2六、WSL2与VMware兼容问题七、更改手动导入的wsl的默认登录用户参考 一、安装WSL 步骤1 - 启用适用于 Linux 的 Windows 子系统：
需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。以管理员身份打开 PowerShell 并运行： dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 步骤2 - 启用虚拟机功能：
安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。
以管理员身份打开 PowerShell 并运行： dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 步骤3 - 将 WSL 2 设置为默认版本：
打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本： wsl --set-default-version 2 步骤4 - 安装所选的 Linux 分发版：
打开 Microsoft Store，并选择你偏好的 Linux 分发版。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edf9fd8549156e7c56cd659cde876a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298ccf85533d7c0554e8ff5978bbd6c2/" rel="bookmark">
			python文件移动的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以下是Python中移动文件到指定目录的几种实现方法：
方法一：使用shutil模块的move函数
import shutil import os def move_file(source_path, destination_path): shutil.move(source_path, destination_path) 方法二：使用os模块的rename函数
import os def move_file(source_path, destination_path): os.rename(source_path, destination_path) 方法三：逐字节拷贝文件并删除源文件
import os def move_file(source_path, destination_path): with open(source_path, 'rb') as source_file: with open(destination_path, 'wb') as destination_file: destination_file.write(source_file.read()) os.remove(source_path) 方法四：使用subprocess模块执行操作系统的移动命令，即采用命令行的方式，
import subprocess def move_file(source_path, destination_path): subprocess.run(['mv', source_path, destination_path]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d7f69b5e2bdb8f406f014fe77d4d9aa/" rel="bookmark">
			redis cluster搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备服务器和端口号 IP 地址端口号路径192.168.0.2016001/app/redis-5.0.14/redis-6001192.168.0.2016002/app/redis-5.0.14/redis-6002192.168.0.2026001/app/redis-5.0.14/redis-6001192.168.0.2036002/app/redis-5.0.14/redis-6002192.168.0.2036001/app/redis-5.0.14/redis-6001192.168.0.2036002/app/redis-5.0.14/redis-6002 所有节点操作：准备工作下载一些用到的工具: yum -y install wget gcc 所有节点操作：下载 redis 的版本 下载用到的 redis 的源码包 wget https://download.redis.io/releases/redis-5.0.14.tar.gz tar redis-5.0.14.tar.gz cd redis-5.0.14 进行编译源码包会生成几个二进制文件： mkdir -p /app/redis-5.0.14/redis-service # 这个的编译后二进制存放的路径 make PREFIX="/app/redis-5.0.14/redis-service" install # 编译没有问题之后会在/app/redis-5.0.14/redis-service/bin下面生成一个文件 # redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-sentinel redis-server 开始进行配置配置文件 192.168.0.201 配置 2 个redis 第一个redis 的6001 端口的操作 进行配置配置文件 cd /app/redis-5.0.14 mkdir -p redis-6001/redis-log mkdir redis-6001/redis-conf mkdir redis-6001/redis-data # 开始进行配置配置文件： cat &lt;&lt; EOF &gt;&gt; /app/redis-5.0.14/redis-6001/redis-conf/redis.conf protected-mode yes tcp-backlog 511 timeout 600 tcp-keepalive 300 daemonize yes supervised no loglevel notice syslog-enabled yes syslog-ident "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d7f69b5e2bdb8f406f014fe77d4d9aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d61dd4e748d8037b0ddaf72400011e/" rel="bookmark">
			提取微信聊天记录详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果展示 导出内容：文字、图片、撤回消息、表情包、拍一拍、回复
导出格式：txt，docx，PDF
一、下载模拟器导入聊天记录到模拟器里 这里以夜神模拟器（支持root的模拟器都行）为例
在模拟器里安装微信并登录，然后在电脑上登录微信。
选择恢复聊天记录到手机，选择你导出的联系人到模拟器里，确保模拟器里的微信可以查看到聊天记录
完成之后打开夜神模拟器，找到Amaze
选择根目录，找到./data/data/com.tencent.mm/MicroMsg
将这个文件夹复制到共享文件夹中
共享文件夹在上面可以看到，按照图片操作进行复制粘贴
然后再将下面这个文件（auth_info_key_prefs.xml）复制到共享文件夹中（文件目录：//data/data/com.tencent.mm/shared_prefs）
复制完成之后到电脑的文件管理器查看共享文件夹
提取成功，第一步搞定
二、破译密码 文件夹里面会有一个以很长一串数字或者一些字母组成命名的文件夹（也可能有多个。不同的文件夹名代表不同的qq，如果你用不同的qq登陆过微信,每个qq会产生一个新乱码文件夹，保险起见，可以都备份上）把此文件夹备份出来，文件夹里还有个systeminfo.cfg文件可以不用备份
在这个名字很长的文件夹下将这三个文件提取出来，avatar(存储了用户的头像数据)，image2（存储了聊天的图片数据）EnMicroMsg.db(存储了所有的聊天记录)
微信数据库EnMicroMsg.db的加密方式，把IMEI和auth_uin组合得到一起md5加密，取加密后的前7位（小写）
IMEI提取：打开夜神模拟器，右上角找到设置，进入手机设置，查看IMEI值
auth_uin提取方式，用记事本打开上面得到的xml文件，&lt;int name=“_auth_uin” value="-15641**** " value后面的值就是uin（负号保留）
被加密字符串就是： 351564524987328-15641****
在线加密网站：MD5在线加密/解密/破解—MD5在线 (sojson.com)
经过MD5加密后输出的字符串取前7位（小写）
将EnMicroMsg.db用sqlcipher.exe打开输入密码试试能不能打开
不能的话 用 IMEI = ‘1234567890ABCDEF’ 再试试
打开之后显示这个界面，点击Browse Data可以查看每个数据表的信息
微信所有聊天记录都在message表里，所有联系人都在rcontact表里，userinfo里存储个人信息，把这三个表导出为csv文件，分别命名为message.csv和rcontact.csv，userinfo.csv
将导出的所有表都放在db_tables文件夹里（自己新建）
直接导出的csv文件在python读写会出现异常，所以先在Excel里打开csv文件再另存为xlsx文件（或者用记事本更改编码方式为utf-8）放到db_tables文件夹里
三、解析数据 0、模块安装（不会安装的话自行百度） pandas库，安装失败自行百度，网上很多教程
pip install pandas -i https://pypi.tuna.tsinghua.edu.cn/simple docx库
pip install python-docx -i https://pypi.tuna.tsinghua.edu.cn/simple requests库
pip install requests -i https://pypi.tuna.tsinghua.edu.cn/simple docxcompose库
pip install docxcompose -i https://pypi.tuna.tsinghua.edu.cn/simple 1、把三个xlsx文件解析成新的csv文件（rcontact.py和message.py） rcontant.py
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03d61dd4e748d8037b0ddaf72400011e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f60e9f06148692bfd59f8b68df26ea5/" rel="bookmark">
			mongodb 的常用数据操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要： 主要记录一些常见 的mongodb 的操作，方便以后查阅。
1.增 基本格式：
db.test_doc.insert({}) 或 db.test_doc.save({}) 样例：
db.test_doc.insert({ "name":"w", "age":25, "pretty":true }) db.test_doc.save({ "name":"ww", "age":255, "pretty":false }) 插入的文档是一个 json 格式的 object，支持嵌套。
2.查 基本格式：
db.test_doc.find({}) .projection({}) .sort({}) .skip() .limit() find：查询条件 projection：返回的文档中包含或排除哪些字段 sort：排序 skip：跳过数据量，与limit连用可以达到翻页的效果 limit：返回数量限制 findOne 是查询一条数据。
样例：
db.test_doc.find({"name":'s'}) .projection({}) .sort({_id:-1}) .limit(100) 查询 name=s 数据，按照 _id 字段倒序排序，只返回前 100 条数据。
1）AND条件 条件并列即可，没有特殊的操作字符。
样例：
db.test_doc.find({"name":'s',"age":18}) 2）OR条件 or 里面需要是个数组，数组里面是个object。
样例：
db.test_doc.find({$or:[{"age":25},{"name":"w"}]}) 查询 age=25 或者 name=w 的数据。
3）其他条件语句： 条件操作符中文$gt大于$gte大于等于$lt小于$lte小于等于$ne不等于//包含 db.test_doc.find({"age":{$lt:90,$gt:18},"name":/ww/}) 查询 25&lt;age&lt;90 且 name 包含 ww 的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f60e9f06148692bfd59f8b68df26ea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/360535a02302ba7c68d6fe61503eafd1/" rel="bookmark">
			sonarqube的多分支检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sonarqube的多分支检查 参考文档:
Sonarqube(社区版)支持扫描多分支配置
SonarQute安装与多分支扫描分析插件安装
持续集成交付CICD：Sonarqube多分支代码扫描
1.手动安装插件 插件地址 : https://github.com/mc1arke/sonarqube-community-branch-plugin
需要注意的是，不同的SonarQube版本使用的插件版本也不一样，在上面我们安装的SonarQube为9.9.x，所以下载的插件版本应该是1.14.0
1.下载插件到/opt/sonarqube/extensions/plugins/  ~/Downloads/ wget https://github.com/mc1arke/sonarqube-community-branch-plugin/releases/download/1.14.0/sonarqube-community-branch-plugin-1.14.0.jar  ~/data/sonar/sonarqube/extensions/plugins/ cp ~/Downloads/sonarqube-community-branch-plugin-1.14.0.jar ./  ~/data/sonar/sonarqube/extensions/plugins/ ll total 24944 -rw-r--r--@ 1 admin staff 69K 1 17 15:22 sonar-l10n-zh-plugin-9.9.jar -rw-r--r--@ 1 admin staff 12M 1 18 14:09 sonarqube-community-branch-plugin-1.14.0.jar  ~/data/sonar/sonarqube/extensions/plugins/  ~/data/sonar/sonarqube/extensions/plugins/ 2.配置sonarqube配置文件：/opt/sonarqube/conf/sonar.properties 添加以下内容： sonar.web.javaAdditionalOpts=-javaagent:./extensions/plugins/sonarqube-community-branch-plugin-1.14.0.jar=web sonar.ce.javaAdditionalOpts=-javaagent:./extensions/plugins/sonarqube-community-branch-plugin-1.14.0.jar=ce  ~/data/sonar/sonarqube/data/ docker exec -u root -it 3f7b95a39582 bash root@3f7b95a39582:/opt/sonarqube# root@3f7b95a39582:/opt/sonarqube# id uid=0(root) gid=0(root) groups=0(root) root@3f7b95a39582:/opt/sonarqube# cd conf/ root@3f7b95a39582:/opt/sonarqube/conf# ls -lth total 24K -r-xr-xr-x 1 root root 21K Nov 10 16:24 sonar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/360535a02302ba7c68d6fe61503eafd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2631025d66995e6664db3f434ad406ba/" rel="bookmark">
			微信公众号短链实时获取阅读量、点赞数爬虫方案（不会Hook可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，微信分享的公众号分享出的一般都是短链，在这个短链下使用浏览器打开并不能获取微信公众的阅读量点赞数等这些信息,如图1所示。
但是实际拥有详细信息的则是这个链接下面，提取链接所需要提交的信息包括经过本人筛选有以下参数，并且携带Cookie，如图2所示：
其中_biz、mid、sn会根据不同的文章发生变动，其余的都是固定值，但都可以从原始链接中取得，且原始链接可以通过F12在谷歌浏览器前端获取，如图3所示：
所以我们现在就应当编写获取真是链接代码：
private String GetRealAddress(String url) throws IOException { CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet(url); /// 解析html字符串 HttpResponse response = httpClient.execute(httpGet); String html = EntityUtils.toString(response.getEntity()); Document doc = Jsoup.parse(html); /// 获取GET参数 String realUrl = doc.select("meta[property='og:url']").attr("content"); //获取真实链接 httpClient.close(); return new URL(realUrl).getQuery(); } 根据Fiddler软件抓包可以知道，阅读数等详细信息是在 https://mp.weixin.qq.com/mp/getappmsgext/...下，而要携带参数我们已经可以从真实长链中获取。别看图2的请求链接好像很长，但是实质上如果只是为了获取阅读量、点赞数等一些有用信息，只需要带上appmsg_token即可，如图4所示：
既然请求链接和请求参数我们都知道，那么就可以书写代码了：
public AjaxResponse getNumberNewWay(String url) throws IOException { String realUrl = this.GetRealAddress(url); if (StringUtils.hasText(realUrl)) { // 使用分隔符 "&amp;" 将参数字符串分割成参数对 String[] parameterPairs = realUrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2631025d66995e6664db3f434ad406ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e08e1c3b3e7fb156d5cf0c4d1600b63/" rel="bookmark">
			Spring Boot多环境配置及Logback日志记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标 Spring Boot多环境配置logback日志记录器 1.Spring Boot多环境配置 Spring Boot的针对不同的环境创建不同的配置文件，
语法结构：application-{profile}.properties
profile:代表的就是一套环境
1.1.需求 application-dev.yml 开发环境 端口8090
application-test.yml 测试环境 端口8091
application-prod.yml 生产环境 端口8092
1.2.运行项目： 在application.yml 中激活指定的配置文件：
#激活指定的配置文件 spring.profiles.active=dev 1.3.单个yml方式 yml支持多文档块的方式：
spring: profiles.active: dev # 开发环境配置 spring: profiles: dev server: port: 8080 # 测试环境配置 spring: profiles: test server: port: 8091 # 生产环境配置 spring: profiles: prod server: port: 8092 2.logback日志记录器 2.1.logback介绍 logback是log4j团队创建的开源日志组件，与log4j类似但是比log4j更强大，是log4j的改良版本。主要优势在于：
a) 更快的实现，logback内核重写过，是的性能有了很大的提升，内存占用也更小。
b) logback-classic对slf4j进行了更好的集成
c) 自动重新加载配置文件，当配置文件修改后，logback-classic能自动重新加载配置文件
d) 配置文件能够处理不同的情况，开发人员在不同的环境下（开发，测试，生产）切换的时候，不需要创建多个
​ 文件，可以通过标签来实现
e) 自动压缩已经打出来的日志文件：RollingFileAppender在产生新文件的时候，会自动压缩已经打印出来的日志
​ 文件。而且这个压缩的过程是一个异步的过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e08e1c3b3e7fb156d5cf0c4d1600b63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb161194e11cc2d4279e6bf31114b0cc/" rel="bookmark">
			新手指南：VPS怎么用?一文解答你的所有疑问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的蓬勃发展，越来越多的人开始关注VPS，以满足他们的各种在线需求。如果你是一位新手，对VPS一无所知，那么你来对地方了!本文将为你提供一份详细的新手指南，解答关于VPS的所有疑问。无论你是想创建一个网站、搭建一个游戏服务器，还是进行其他在线活动，VPS都能为你提供所需的强大性能和自由度。
什么是VPS?
VPS代表虚拟专用服务器，它是一种虚拟化的服务器环境，可以为用户提供独立的资源和操作系统。与虚拟主机相比，VPS为用户提供了更高的性能和控制权。它是一个完美的中间选项，适用于那些需要更多自由度的用户，但又不想承担完整服务器的成本和管理责任。
为什么选择VPS?
性能优越： VPS为你提供了独立的资源，确保你的应用程序在高负载时也能保持良好的性能。
自由度： 你可以根据自己的需求自定义VPS，安装所需的软件和操作系统。
安全性： 由于资源隔离，VPS通常比虚拟主机更安全。
成本效益： 相对于独立服务器，VPS提供了更经济的解决方案。
如何选择合适的VPS计划?
选择适合你的VPS计划是至关重要的。首先，你需要考虑以下因素：
资源需求： 确定你的应用程序需要多少CPU、内存和存储空间。
操作系统： 选择适合你的应用程序的操作系统，如Linux或Windows。
托管位置： 考虑你的目标受众所在的地理位置，选择一个接近他们的数据中心。
成本： 根据你的预算选择合适的计划。
注册一个VPS账户
现在，让我们开始注册一个VPS账户。以下是一些简单的步骤：
访问VPS托管提供商的网站。Hostease的VPS提供出色的性能，确保你的应用程序在高负载时也能保持流畅运行。不管是托管网站、应用程序还是数据库，都能得到快速的响应时间。
创建一个账户并登录。
选择一个VPS计划，根据你的需求选择CPU、内存和存储空间。
选择数据中心位置。
添加支付方式并完成订单。
连接到你的VPS
一旦你完成了注册过程，你需要连接到你的VPS。你可以使用SSH客户端来进行连接。以下是连接的基本步骤：
打开终端窗口。
使用SSH命令连接到你的VPS，命令示例：ssh username@your_vps_ip。
输入你的密码或SSH密钥以完成连接。
安装操作系统
连接到VPS后，你需要安装操作系统。大多数VPS提供商都提供了一个简单的安装向导，你只需要按照提示操作即可。
配置基本安全性
为了保护你的VPS免受潜在的威胁，你应该采取一些基本的安全性措施，例如：
更新操作系统和软件包。
配置防火墙规则。
禁用不必要的服务。
安装和配置安全性工具，如Fail2Ban。
安装Web服务器
如果你计划托管网站，你需要安装Web服务器。最常见的选择是Apache和Nginx。选择一个适合你的服务器软件，并配置虚拟主机来托管你的网站。
创建和管理网站
现在，你可以开始创建和管理你的网站。你可以使用各种CMS(内容管理系统)如WordPress，或者自己编写网站代码。
配置电子邮件服务器
如果你需要配置电子邮件服务器，你可以选择邮件服务器软件如Postfix和Dovecot，并按照相应的文档进行配置。
设置游戏服务器
如果你是一位游戏爱好者，你还可以使用VPS来设置游戏服务器。选择适合你游戏的服务器软件，并邀请朋友一起玩吧!
使用VPS进行数据备份
定期备份是非常重要的，以防止数据丢失。你可以使用各种备份工具来自动备份你的VPS上的数据。
监控和维护你的VPS
不要忘记监控你的VPS的性能和安全性。使用监控工具来及时发现问题并采取措施解决它们。
VPS的成本和资源管理
最后，要注意VPS的成本管理。确保你的资源使用合理，并根据需要升级或降级你的计划。
结论
希望这份新手指南能够帮助你了解如何使用VPS。无论你是想托管网站、创建游戏服务器，还是进行其他在线活动，VPS都是一个强大的工具，可以满足你的需求。记住，VPS需要一些技术知识，但一旦你掌握了它，你将能够轻松地运行你的在线项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba59632a949e55c41982afe98fe905a/" rel="bookmark">
			Vue 3 hooks的基本使用及疑问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 vue3也用过一段时间了，hooks听说过，但是一直没有用过。公司的前端项目里也没有相应的应用，因此打算系统的学习一下。
hooks与普通函数的区别 以实现一个加法功能为例。
普通函数未抽离
&lt;template&gt; &lt;div class="box"&gt; &lt;div&gt;sum的值是：{{ sum }}&lt;/div&gt; &lt;el-button type="primary" @click="add"&gt;加1&lt;/el-button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { ref } from "vue"; const sum = ref(0); const add = () =&gt; { sum.value++; }; &lt;/script&gt; 普通函数抽离
&lt;template&gt; &lt;div class="box"&gt; &lt;div&gt;sum的值是：{{ sum }}&lt;/div&gt; &lt;el-button type="primary" @click="add"&gt;加1&lt;/el-button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { ref } from "vue"; import { addFn } from "./add.js"; const sum = ref(0); const add = () =&gt; { sum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cba59632a949e55c41982afe98fe905a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29fff5a41a389353bde35df1a6aed1c0/" rel="bookmark">
			FlinkAPI开发之容错机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在Flink中，有一套完整的容错机制来保证故障后的恢复，其中最重要的就是检查点。
检查点（Checkpoint） 检查点的保存 周期性的触发保存 “随时存档”确实恢复起来方便，可是需要我们不停地做存档操作。如果每处理一条数据就进行检查点的保存，当大量数据同时到来时，就会耗费很多资源来频繁做检查点，数据处理的速度就会受到影响。所以在Flink中，检查点的保存是周期性触发的，间隔时间可以进行设置。
保存的时间点 我们应该在所有任务（算子）都恰好处理完一个相同的输入数据的时候，将它们的状态保存下来。
这样做可以实现一个数据被所有任务（算子）完整地处理完，状态得到了保存。
如果出现故障，我们恢复到之前保存的状态，故障时正在处理的所有数据都需要重新处理；我们只需要让源（source）任务向数据源重新提交偏移量、请求重放数据就可以了。当然这需要源任务可以把偏移量作为算子状态保存下来，而且外部数据源能够重置偏移量；kafka就是满足这些要求的一个最好的例子。
保存的具体流程 检查点的保存，最关键的就是要等所有任务将“同一个数据”处理完毕。下面我们通过一个具体的例子，来详细描述一下检查点具体的保存过程。
回忆一下我们最初实现的统计词频的程序——word count。这里为了方便，我们直接从数据源读入已经分开的一个个单词，例如这里输入的是：
“hello”，“world”，“hello”，“flink”，“hello”，“world”，“hello”，“flink”… 我们所需要的就是每个任务都处理完“hello”之后保存自己的状态。
从检查点恢复状态 检查点算法 在Flink中，采用了基于Chandy-Lamport算法的分布式快照，可以在不暂停整体流处理的前提下，将状态备份保存到检查点。
检查点分界线（Barrier） 借鉴水位线的设计，在数据流中插入一个特殊的数据结构，专门用来表示触发检查点保存的时间点。收到保存检查点的指令后，Source任务可以在当前数据流中插入这个结构；之后的所有任务只要遇到它就开始对状态做持久化快照保存。由于数据流是保持顺序依次处理的，因此遇到这个标识就代表之前的数据都处理完了，可以保存一个检查点；而在它之后的数据，引起的状态改变就不会体现在这个检查点中，而需要保存到下一个检查点。
这种特殊的数据形式，把一条流上的数据按照不同的检查点分隔开，所以就叫做检查点的“分界线”（Checkpoint Barrier）。
分布式快照算法（Barrier对齐的精准一次） watermark指示的是“之前的数据全部到齐了”，而barrier指示的是“之前所有数据的状态更改保存入当前检查点”：它们都是一个“截止时间”的标志。所以在处理多个分区的传递时，也要以是否还会有数据到来作为一个判断标准。
具体实现上，Flink使用了Chandy-Lamport算法的一种变体，被称为“异步分界线快照”算法。算法的核心就是两个原则：
当上游任务向多个并行下游任务发送barrier时，需要广播出去；
而当多个上游任务向同一个下游任务传递分界线时，需要在下游任务执行“分界线对齐”操作，也就是需要等到所有并行分区的barrier都到齐，才可以开始状态的保存。
场景说明
检查点保存算法具体过程为：
（1）触发检查点：JobManager向Source发送Barrier；
（2）Barrier发送：向下游广播发送；
（3）Barrier对齐：下游需要收到上游所有并行度传递过来的Barrier才做自身状态的保存；
（4）状态保存：有状态的算子将状态保存至持久化。
（5）先处理缓存数据，然后正常继续处理
完成检查点保存之后，任务就可以继续正常处理数据了。这时如果有等待分界线对齐时缓存的数据，需要先做处理；然后再按照顺序依次处理新到的数据。当JobManager收到所有任务成功保存状态的信息，就可以确认当前检查点成功保存。之后遇到故障就可以从这里恢复了。
（补充）由于分界线对齐要求先到达的分区做缓存等待，一定程度上会影响处理的速度；当出现背压时，下游任务会堆积大量的缓冲数据，检查点可能需要很久才可以保存完毕。
为了应对这种场景，Barrier对齐中提供了至少一次语义以及Flink 1.11之后提供了不对齐的检查点保存方式，可以将未处理的缓冲数据也保存进检查点。这样，当我们遇到一个分区barrier时就不需等待对齐，而是可以直接启动状态的保存了。
分布式快照算法（Barrier对齐的至少一次） 分布式快照算法（非Barrier对齐的精准一次） 检查点配置 检查点的作用是为了故障恢复，我们不能因为保存检查点占据了大量时间、导致数据处理性能明显降低。为了兼顾容错性和处理性能，我们可以在代码中对检查点进行各种配置。
启用检查点 默认情况下，Flink程序是禁用检查点的。如果想要为Flink应用开启自动保存快照的功能，需要在代码中显式地调用执行环境的.enableCheckpointing()方法：
StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // 每隔1秒启动一次检查点保存 env.enableCheckpointing(1000); 这里需要传入一个长整型的毫秒数，表示周期性保存检查点的间隔时间。如果不传参数直接启用检查点，默认的间隔周期为500毫秒，这种方式已经被弃用。
检查点的间隔时间是对处理性能和故障恢复速度的一个权衡。如果我们希望对性能的影响更小，可以调大间隔时间；而如果希望故障重启后迅速赶上实时的数据处理，就需要将间隔时间设小一些。
检查点存储 检查点具体的持久化存储位置，取决于“检查点存储”的设置。默认情况下，检查点存储在JobManager的堆内存中。而对于大状态的持久化保存，Flink也提供了在其他存储位置进行保存的接口。
具体可以通过调用检查点配置的.setCheckpointStorage()来配置，需要传入一个CheckpointStorage的实现类。Flink主要提供了两种CheckpointStorage：作业管理器的堆内存和文件系统。
// 配置存储检查点到JobManager堆内存 env.getCheckpointConfig().setCheckpointStorage(new JobManagerCheckpointStorage()); // 配置存储检查点到文件系统 env.getCheckpointConfig().setCheckpointStorage(new FileSystemCheckpointStorage("hdfs://namenode:40010/flink/checkpoints")); 对于实际生产应用，我们一般会将CheckpointStorage配置为高可用的分布式文件系统（HDFS，S3等）。
其它高级配置 检查点还有很多可以配置的选项，可以通过获取检查点配置（CheckpointConfig）来进行设置。
CheckpointConfig checkpointConfig = env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29fff5a41a389353bde35df1a6aed1c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2a08af5a42fc7160b20cdcba3ef128/" rel="bookmark">
			8.代理请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1 不使用代理请求
2 使用代理请求
3 代理IP的匿名度
有时爬着爬着人家把我们的IP给封了，这个时候我们可以使用代理IP再次进行请求
不用代理的时候就是A直接请求B，B给A响应
使用代理是A去请求C，C携带你的参数请求B。之后B给C响应，然后再由C把B的响应给A
这样A和B就没有直接关系，B禁用A的IP，但没有禁用C的IP。如果C的IP也被禁用了，那就换一个代理D
梯子工具使用的就是代理技术 和验证码一样，代理也有第三方的公司做，比如 快代理 快代理 - 企业级HTTP代理IP云服务
百度上搜代理就有了 1 不使用代理请求 这里有一个查询ip地址的http协议的网站 显示查询自己的IP地址 直接访问可以获得我们当前的IP
https协议的代理相对于http协议的代理要难获取一些 我们用代码请求一下
发现可以请求到，并且IP与我们与浏览器访问的IP一致
2 使用代理请求 快代理目前(2024.1.17)每小时会更新几个免费的，有时间限制的代理，我们再学习或购买之前可以用一下试试，我们现在就用这个IP试一下
在requests.get中加入参数proxies
proxies本身是键值对，键是协议名称，值是代理的IP+端口，如果你想再添加一个https的代理，那么可以这样写
page_text = requests.get(url=url,headers=headers,proxies={'http':'36.134.91.82:8888','https':'36.134.91.82:1234'}).text
当你使用http协议请求的时候会自动走http的代理，如果你没添加http的代理就会使用本机IP进行访问
请求后发现我们可以成功使用代理的IP
3 代理IP的匿名度 大致分如下3个等级
透明：服务器知道该次请求使用了代理，也知道请求的真实IP。可以讲透明的代理意义不大匿名：服务器知道使用了代理，不知道真实的IP高匿名：服务器不知道使用了代理，也不知道真实的IP 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045704ca5262fc5ca6161293ac6801dd/" rel="bookmark">
			sonarqube扫描代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sonarqube扫描代码 前面的博客讲了sonarqube的安装和api，这个博客讲一下扫描代码检查代码问题。以java项目为例。 由于安装是9.9版本的sonarqube，这家伙好像已经是java 11的jdk了。于是又安装了很长时间的jdk 11。网上找了好多文章，似乎。。。。都是错了，这里找了一个依然是错的，但是有价值的博文。主要有两个方法，方法1是手动配置文件，手动改。方案二是用jenv。由于没有用过jenv，又不想去弄jenv，所以就选择的手动配置文件。
注意：maven好像只需要JAVA_HOME的环境变量就可以了
jenv的一个博文
sonarqube页面的步骤 新增项目 手工配置 选择“本地” 创建令牌，分析项目 maven本地项目扫描 复制上面的命令到项目的目录下执行
mvn clean verify sonar:sonar \ -Dsonar.projectKey=tes \ -Dsonar.host.url=http://localhost:9000 \ -Dsonar.login=sqp_e6d932b73bc0e5e7e08617397398ee1605084d8c 注意这里的sonar插件的版本，其实我一直没搞懂版本这个东西，sonarqube的版本，sonar插件的版本，jdk的版本，项目编译的java版本
页面显示 注意在开始我们设置的项目标识不是这里显示的test-root，而是项目信息里面的项目标识
还有的问题 只有master分支，没有多多分支覆盖率怎么显示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6fe46768793fa5a9a5bb649d8daef7b/" rel="bookmark">
			7.图像验证码与cookie操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有很多第三方的公司可以解决图像验证码问题，但是人家都需要费用，比如 云码 验证码识别价格_验证码识别费用多少钱-云码 超级鹰 超级鹰验证码识别-专业的验证码云端识别服务,让验证码识别更快速、更准确、更强大
如果不需要搞定太专业的验证码，我们可以自己搞定一下比如 paddleocr的基本使用-CSDN博客
我们后面都是通过这个服务来识别验证码
验证码可能与很多的因素相关，比如请求验证码的时候发送查询字符串或是与cookie、session相关或是与时间戳相关，都有可能
我们下面做个古诗文网的例子
参考 实现古诗文网站的模拟登录_古诗文网模拟登录-CSDN博客 古诗文网 登录古诗文网
目录
1 验证码
2 登录请求
3 处理cookie
3.1 手动添加cookie
3.2 寻找cookie来源
3.3 requests.Session()
1 验证码 首先看一下这个验证码的图像地址，可以看出这个验证码的url是拼接出来的，直接请求url就行
能拿到图像之后我们可以使用paddleocr搞定验证码，可以参考 paddleocr的基本使用-CSDN博客
验证码在发起登录请求之前请求就行，浏览器其实也是这么做的，浏览器先请求页面，请求页面就相当于请求页面中的资源，资源中包含验证码
之后等用户点击按钮之后，相当于发起第二次请求，这时候你再用代码模拟第二次请求就行了
我们目前的代码是这样的
运行后可以解决验证码问题(存在识别不准确的情况)
2 登录请求 为了拿到登录按钮的请求，我们先登录一次
这样我们拿到了登录的请求地址以及需要携带的参数
再代码中加入如下内容
运行后会得到webpage.html
打开之后是这样的，网站说我们的验证码有问题，但我们查看之后发现验证码是正确的
写前后端的时候我们经常使用cookie判断用户之前是否登录过，所以登录出现这种问题的时候，我们可以考虑cookie的问题。
3 处理cookie cookie在请求头中，我们先看一眼正常的请求头内容
我们可以给这些请求头直接携带上，比如
3.1 手动添加cookie 这种方法叫手动添加cookie，一般我们不用这种方法，一是比较麻烦，二是cookie有可能是动态变化的，这么写不一定对。在我们的例子中发起请求后依然出现没加cookie的结果，也就是说手动添加cookie的方法走不通
3.2 寻找cookie来源 cookie的来源一般为提交登录的时候相应的内容，我们通过抓登录成功的包看这里的cookie，发现有请求cookie与相应cookie，说明这个cookie确实是在变化的
也可以从response Headers中到Set-Cookie这个键
3.3 requests.Session() requests.Session()可以自动存储cookie的内容，你可以拿requests.Session()当作一个增强版的requests
我们对代码做如下修改
当验证码识别正确后，我们进行请求就可以请求到登录成功的页面了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a84cda535aed25a11733fbb91da8239/" rel="bookmark">
			通用导出模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		protected Result&lt;?&gt; importExcel(HttpServletRequest request, HttpServletResponse response, Class&lt;T&gt; clazz) { MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request; Map&lt;String, MultipartFile&gt; fileMap = multipartRequest.getFileMap(); for (Map.Entry&lt;String, MultipartFile&gt; entity : fileMap.entrySet()) { // 获取上传文件对象 MultipartFile file = entity.getValue(); ImportParams params = new ImportParams(); params.setTitleRows(2); params.setHeadRows(1); params.setNeedSave(true); try { List&lt;T&gt; list = ExcelImportUtil.importExcel(file.getInputStream(), clazz, params); //update-begin-author:taoyan date:20190528 for:批量插入数据 long start = System.currentTimeMillis(); service.saveBatch(list); //400条 saveBatch消耗时间1592毫秒 循环插入消耗时间1947毫秒 //1200条 saveBatch消耗时间3687毫秒 循环插入消耗时间5212毫秒 log.info("消耗时间" + (System.currentTimeMillis() - start) + "毫秒"); //update-end-author:taoyan date:20190528 for:批量插入数据 return Result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a84cda535aed25a11733fbb91da8239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c60ad5d9c0d530cccea27a5131b930f2/" rel="bookmark">
			提示词工程： 大语言模型的Embedding(嵌入和Fine-tuning（微调）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是针对这篇文章（https://www.promptengineering.org/master-prompt-engineering-llm-embedding-and-fine-tuning/）的中文翻译，用以详细介绍Embedding（语义嵌入）和Fine Tuning（微调）的概念和比较。
LLM（GPT-3/3.5/4）已经成为一个热门的讨论话题，因为人们寻求利用这种先进的语言模型来实现各种应用，如问答（QA）和信息检索。虽然语义嵌入和微调都是用来适应特定任务的LLM技术，但它们有不同的目的和优势。我们将一起探讨这两个概念，因为它们是相关的，而且经常有关于何时使用哪种技术的困惑。
语义嵌入：表示和应用
语义嵌入是文本的数值向量表示，能够捕捉单词或短语的语义含义。通过比较和分析这些向量，可以辨别文本元素之间的相似性和差异性。利用语义嵌入进行搜索可以快速有效地检索相关信息，特别是在大型数据集中。语义搜索相比微调有几个优势，如更快的搜索速度、降低计算成本以及防止杜撰或事实捏造。由于这些优势，当目标是访问模型中的特定知识时，语义搜索通常是首选。嵌入在各个领域都有应用，包括推荐引擎、搜索功能和文本分类。例如，在为一个流媒体平台设计一个电影推荐引擎时，嵌入可以根据它们的文本描述来识别具有相似主题或类型的电影。通过将这些描述表示为向量，引擎可以计算它们之间的距离，并推荐向量空间中距离较近的电影，确保更准确和相关的用户体验。
微调：提高模型响应
微调是一种用来改善预训练模型性能的技术，如聊天机器人。通过提供示例并调整模型参数，微调使模型能够为特定任务生成更准确和上下文相关的响应。这些任务可以从聊天机器人对话和代码生成到问题形成等不同范围，确保与期望输出更好地对齐。这个过程类似于神经网络在训练过程中调整其权重。例如，在客服聊天机器人中，微调可以提高聊天机器人对行业特定术语或行话的理解，从而更准确和恰当地回答客户询问。作为一种迁移学习形式，微调使预训练模型能够执行新任务，而无需进行大量的重新训练。
LLM嵌入和向量搜索的概述：
嵌入过程是大型语言模型（LLM）如GPT-3/Gpt-3.5/GPT-4的一个重要组成部分，因为它允许以数值格式对文本进行语义理解和表示。以下是LLM嵌入过程的逐步概述的内容：
首先，LLM接收一个文本输入，如一个单词或一个句子，并将其分割成一系列的标记（tokens）。标记是文本的最小单位，通常是单个字符或子词。例如，单词“prompt”可以被分割成两个标记：“prom”和“pt”。
然后，LLM将每个标记映射到一个嵌入矩阵中的一个向量。嵌入矩阵是一个包含数千个向量的大型表格，每个向量代表一个标记。这些向量的维度通常为768或1024，取决于LLM的大小。例如，“prom”和“pt”的向量可能分别为[0.2, -0.1, 0.3, …]和[-0.4, 0.5, -0.2, …]。
接下来，LLM将这些向量相加，得到一个表示整个文本输入的单个向量。这个向量被称为语义嵌入（semantic embedding），因为它捕捉了文本的语义信息。例如，“prompt”的嵌入可能是[0.2, -0.1, 0.3, …] + [-0.4, 0.5, -0.2, …] = [-0.2, 0.4, 0.1, …]。
最后，LLM使用这个嵌入向量作为输入，通过一系列的神经网络层来生成输出。输出可以是文本、图像或其他类型的数据，取决于LLM的目标。例如，如果LLM的目标是生成一个与“prompt”相关的句子，它可能会输出“Prompt engineering is a skill that involves crafting text-based prompts for AI systems.”。
使用向量搜索进行语义检索：
当我们想要从LLM中检索特定的知识时，我们可以利用向量搜索（vector search）技术。向量搜索是一种基于语义嵌入进行信息检索的方法，它可以在大型数据集中快速找到最相关的结果。以下是使用向量搜索进行语义检索的步骤：
首先，我们需要准备一个包含我们想要检索的知识的数据集。数据集可以是任何类型的文本数据，如文章、书籍、百科全书等。例如，如果我们想要从维基百科中检索关于太阳系行星的知识，我们可以使用维基百科文章作为数据集。
然后，我们需要对数据集中的每个文本元素（如标题、段落或句子）进行嵌入，并将它们存储在一个索引中。索引是一个包含所有嵌入向量及其对应文本元素的数据库。例如，如果我们对维基百科文章中的每个标题进行嵌入，并将它们存储在一个索引中，我们可能会得到类似于以下内容的结果：
嵌入向量标题[0.1, -0.2, 0.3, …]太阳[-0.4, 0.5, -0.1, …]地球[0.2, -0.3, 0.4, …]火星…… 接下来，我们需要提供一个查询（query），即我们想要检索的知识的描述。查询可以是一个单词、一个短语或一个问题。例如，如果我们想要知道太阳系中哪个行星最大，我们可以提供以下查询：“太阳系中最大的行星是什么？”
然后，我们需要对查询进行嵌入，并将其与索引中的嵌入向量进行比较。我们可以使用不同的度量来比较向量之间的相似性，如余弦相似度（cosine similarity）或欧几里得距离（Euclidean distance）。一般来说，相似度越高或距离越小，表示向量之间的语义关系越强。例如，如果我们对查询“太阳系中最大的行星是什么？”进行嵌入，并将其与索引中的嵌入向量进行比较，我们可能会得到类似于以下内容的结果：
嵌入向量标题相似度[0.1, -0.2, 0.3, …]太阳0.4[-0.4, 0.5, -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c60ad5d9c0d530cccea27a5131b930f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36f12a822f59f41240aa81bb37410f2/" rel="bookmark">
			用WPSAI一键洞察分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用WPSAI一键洞察分析 这个功能需要在WPS AI申请内测才会出现
主页地址：https://ai.wps.cn/
操作步骤 打开示例数据集
点击菜单栏WPS AI按钮
显示如下菜单
点击洞察分析程序会自动获取洞察分析结论
点数据详情
点查看详情就会出来一份很详细的报告
分析探索的相关数据
在洞察分析对话框重，输入#AI洞察结论可以获取AI洞察结论
根据给出的数据情况，以下是三个管理层最应该深入关注的问题或机会： 1. **销售额和利润的波动**: * **问题或机会描述**: 从数据中可以看到，销售额和利润的平均值、中位数、最大值和总和都相对较高，但标准差也很大，意味着数据波动较大。这可能意味着业务在某些时期表现优秀，而在其他时期可能面临挑战。 * **业务视角原因**: 销售额和利润的波动可能由多种因素引起，如市场需求的变化、竞争对手的策略调整、产品线更新等。了解这些波动背后的原因可以帮助管理层更好地预测未来的业务趋势，并制定相应的策略。 * **深入分析建议**: 进一步分析市场趋势、竞争对手动态和产品线销售数据，以了解波动背后的具体原因。 2. **折扣策略**: * **问题或机会描述**: 折扣的平均值和中位数都很低，但最大值达到了0.8，说明在某些情况下，公司可能提供了较高的折扣。这可能影响到利润水平。 * **业务视角原因**: 高折扣可能意味着某些产品或服务的需求疲软，或者销售团队为了达成目标而采取的策略。但长期的高折扣可能导致利润下降或客户期望提高。 * **深入分析建议**: 分析提供高折扣的具体情境，了解背后的原因。同时，研究高折扣对客户满意度和忠诚度的影响，以及它如何影响公司的长期利润。 3. **客户和产品多样性**: * **问题或机会描述**: 从数据中可以看出，无论是客户还是产品的数量都较为集中。这可能意味着业务在某些客户或产品上过于依赖。 * **业务视角原因**: 客户和产品的集中性可能带来风险。如果某一关键客户或产品出现问题，可能会对整个业务产生重大影响。 * **深入分析建议**: 进一步分析客户和产品的集中度，了解具体依赖的情况。同时，研究如何通过多元化客户和产品来降低业务风险。 以上三个问题或机会点是基于给定数据的初步解读。为了更深入地了解业务情况，建议管理层与相关的业务部门合作，获取更多关于市场、产品和客户的详细信息，并进行更深入的分析。 至此用WPSAI一键洞察分析的操作就算完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325249c07f914a8595049e78f4ced407/" rel="bookmark">
			ffmpeg命令整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		裁剪
ffmpeg -ss 00:00:20 -t 00:00:10 -i D:/MyVideo.mpg -vcodec copy -acopy copy D:/Split.mpg
这个命令就是从20秒开始裁剪到20+10=30秒结束，总共10秒的视频。这个命令执行很快，因为只是原始数据的拷贝，中间没有什么编码和解码的过程。
竖向拼接
ffmpeg -i out1.mp4 -i out2.mp4 -filter_complex "[0:v]pad=iw:ih*2[a];[a][1:v]overlay=0:h" out.mp4
横向拼接
ffmpeg \
-i left.avi \
-i right.avi \
-filter_complex hstack \
output.avi
合并
ffmpeg.exe -f concat -safe 0 -i merge.txt -c copy -y o1.mp4
-f concat是指合并
-safe 为了避免权限报错
-c copy 一定要指定，不然会重新封装，数据文件就会变大。
merge.txt
file 'dj268.mp4'
file 'dj269.mp4'
改变分辨率
ffmpeg -i input.mp4 -vf scale=$w:$h &lt;encoding-parameters&gt; output.mp4
更改视频帧率，不改变时长：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/325249c07f914a8595049e78f4ced407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05856b6738ae473a12bbd77d2138f604/" rel="bookmark">
			【转载】Spring Cloud Ribbon中的7种负载均衡策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		负载均衡通器常有两种实现手段，一种是服务端负载均衡器，另一种是客户端负载均衡器，而我们今天的主角 Ribbon 就属于后者——客户端负载均衡器。
服务端负载均衡器的问题是，它提供了更强的流量控制权，但无法满足不同的消费者希望使用不同负载均衡策略的需求，而使用不同负载均衡策略的场景确实是存在的，所以客户端负载均衡就提供了这种灵活性。 然而客户端负载均衡也有其缺点，如果配置不当，可能会导致服务提供者出现热点，或者压根就拿不到任何服务的情况，所以我们本文就来了解一下这 7 种内置负载均衡策略的具体规则。
Ribbon 介绍 Ribbon 是 Spring Cloud 技术栈中非常重要的基础框架，它为 Spring Cloud 提供了负载均衡的能力，比如 Fegin 和 OpenFegin 都是基于 Ribbon 实现的，就连 Nacos 中的负载均衡也使用了 Ribbon 框架。
Ribbon 框架的强大之处在于，它不仅内置了 7 种负载均衡策略，同时还支持用户自定义负载均衡策略，所以其开放性和便利性也是它得以流行的主要原因。
服务端负载均衡器和客户端负载均衡器的区别如下图所示：
客户端负载均衡器的实现原理是通过注册中心，如 Eureka/Nacos，将可用的服务列表拉取到本地（客户端），再通过客户端负载均衡器（设置的负载均衡策略）获取到某个服务器的具体 ip 和端口，然后再通过 Http 框架请求服务并得到结果，其执行流程如下图所示：
负载均衡设置 以 Nacos 中的 Ribbon 负载均衡设置为例，在配置文件 application.yml 中设置如下配置即可：
springcloud-nacos-provider: # nacos中的服务id ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #设置负载均衡策略 因为 Nacos 中已经内置了 Ribbon，所以在实际项目开发中无需再添加 Ribbon 依赖了，这一点我们在 Nacos 的依赖树中就可以看到，如下图所示：
Ribbon 默认的负载均衡策略是轮询模式，我们配置 3 个服务提供者的执行结果如下图所示：
然后，我们再将 Ribbon 负载均衡策略设置为随机模式，配置内容如下：
springcloud-nacos-provider: # nacos中的服务id ribbon: NFLoadBalancerRuleClassName: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05856b6738ae473a12bbd77d2138f604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5137fe3cb08011fed4460c469bed916/" rel="bookmark">
			从零学算法78
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		78.给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：
输入：nums = [0]
输出：[[],[0]]
如果将该题想象成一棵 n 叉树，进行 dfs，那么其实遍历时走过的每个路径都是子集。比如例子 1 1 2	3 3 为了防止重复组合，所以在构建新的子集时，比如 [1,3] 我们继续构建时，不会往前取数字（取末尾的 3 前面的数字）构建成新的子集，比如得到 [1,3,2]，这也就是为什么上面那棵树是这样的。所以比如 [1,2,3] ，我们得到 [1,2,3] 后不可能回溯成 [1,3] 然后得到 [1,3,2]，所以每次的下一层递归，从当前层递归的数组的下标 +1 开始，具体看代码 public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list; } private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, int start) { //走过的所有路径都是子集的一部分，所以都要加入到集合中 list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5137fe3cb08011fed4460c469bed916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c5c123c8071037fae49ec7498090bb/" rel="bookmark">
			服务器——Vscode选择虚拟环境编译器后，无法跳转至对应的python路径的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、现象 输入 which python，显示 /bin/python，而不是对应的python路径。
二、原因分析 该用户账户下的.bashrc文件手动指定了python路径。
三、解决办法 将手动指定的python路径代码注释，这样就跟随编译器，自动选择python路径了。
注释完后，输入 source ~/.bashrc，更新配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5caa2950563702e888cfed8fd5c0267/" rel="bookmark">
			详解MySQL原生Online DDL:从历史演进到原理及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 中的在线DDL（OnLine DDL）功能是一种强大的工具，可以在不中断表或数据库的情况下进行数据定义语言（DDL）操作。通过在线DDL，使得在对表进行结构变更时，仍然能够进行读写操作，避免了整个表的锁定和阻塞。
MySQL Online DDL 功能从 5.6 版本开始正式引入，发展到现在的 8.0 版本，经历了多次的调整和完善。本文主要就 Online DDL 的发展过程，以及各版本的区别进行总结。其实早在 MySQL 5.5 版本中就加入了 INPLACE DDL 方式，但是因为实现的问题，依然会阻塞 INSERT、UPDATE、DELETE 操作，这也是 MySQL 早期版本长期被吐槽的原因之一。
在 MySQL 5.6 中，官方开始支持更多的 ALTER TABLE 类型操作来避免数据拷贝，同时支持了在线上 DDL 的过程中不阻塞 DML 操作，真正意义上的实现了 Online DDL。然而并不是所有的 DDL 操作都支持在线操作，后面会附上 MySQL 官方文档对于 DDL 操作的总结。到了 MySQL 5.7，在 5.6 的基础上又增加了一些新的特性，比如：增加了重命名索引支持，支持了数值类型长度的增大和减小，支持了 VARCHAR 类型的在线增大等。但是基本的实现逻辑和限制条件相比 5.6 并没有大的变化。MySQL 8.0 对 DDL 的实现重新进行了设计，其中一个最大的改进是 DDL 操作支持了原子特性。另外，Online DDL 的 ALGORITHM 参数增加了一个新的选项：INSTANT，只需修改数据字典中的元数据，无需拷贝数据也无需重建表，同样也无需加排他 MDL 锁，原表数据也不受影响。整个 DDL 过程几乎是瞬间完成的，也不会阻塞 DML。
了解 Online DDL 先了解一下之前 DDL 的 2 种算法 copy 和 inplace。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5caa2950563702e888cfed8fd5c0267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c781bcafa9be16f628800c421d55e9d/" rel="bookmark">
			爬虫案例—根据四大名著书名抓取并存储为文本文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫案例—根据四大名著书名抓取并存储为文本文件 诗词名句网：https://www.shicimingju.com
目标：输入四大名著的书名，抓取名著的全部内容，包括书名，作者，年代及各章节内容
诗词名句网主页如下图：
今天的案例是抓取古籍板块下的四大名著，如下图：
案例源码如下：
import time import requests from bs4 import BeautifulSoup import random headers = { 'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36', } # 获取响应页面,并返回实例化soup def get_soup(html_url): res = requests.get(html_url, headers=headers) res.encoding = res.apparent_encoding html = res.content.decode() soup = BeautifulSoup(html, 'lxml') return soup # 返回名著的书名及对应的网址字典 def get_book_url(page_url): book_url_dic = {} soup = get_soup(page_url) div_tag = soup.find(class_="card booknark_card") title_lst = div_tag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c781bcafa9be16f628800c421d55e9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/752236c5c143ac722308d2e8dbc0e1eb/" rel="bookmark">
			Vue3Ts中如何实现父组件传递给子组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最开始我写vue3项目的时候父子组件传递数据，我直接按钮scope.row传递，子组件接收的时候为init接收，但是这种情况出现了一个情况就是当你点击弹窗的时候，明明数据已经给你传送接收了，断点查数据也没有问题，就是出现一个渲染有时候停留在上一个页面的bug。为此我改了数据传递的方法。下边是我最后改的，为此我整理了一下vue3Ts中如何实现父组件传递给子组件的方法，希望对大家有用！
1.父传子 父组件
&lt;template&gt; &lt;h1&gt;父组件&lt;/h1&gt; &lt;A :name="name" :age="age" &gt;&lt;/A&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { ref ,reactive} from 'vue' import A from '@/components/A.vue' const name = ref&lt;string&gt;('chaochao') const age = ref&lt;number&gt;(22) &lt;/script&gt; 子组件
1.使用defineProps接收
2.使用withDefaults可使传递的值有默认值。
2.子传父 子组件
1.定义defineEmits
2.发送自定义事件名，给父组件
&lt;template&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { ref ,reactive} from 'vue' const props = withDefaults( defineProps&lt;{ name:string, age:number }&gt;(),{ name:'没名字', age:18 } ) // const props = defineProps&lt;{ // name:string, // age:number // }&gt;() console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/752236c5c143ac722308d2e8dbc0e1eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41c02565648dd87882ab1c461278b882/" rel="bookmark">
			rust获取本地外网ip地址的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，我是get_local_info作者带剑书生，这里用一篇文章讲解get_local_info的使用。
get_local_info是什么？
get_local_info是一个获取linux系统信息的rust三方库，并提供一些常用功能，目前版本0.2.4。详细介绍地址：[我的Rust库更新]get_local_info 0.2.3-CSDN博客
首先在你的工程添加它
cargo add get_local_info 然后引入它: extern crate get_local_info; 然后调用它：
let uri = "https://api.ipify.org/?format=text"; println!("wai wang ip:{}", get_local_info::network::get_ww_ipv4(uri)); 看到输出的外网IP地址为111.60.247.119
​
通过在线工具看到，你的外网IP地址111.60.247.119
到这里，你已经获取到了本地的外网地址了，有什么疑问请联系我吧。哈哈 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00305a0cc986ac20ebc8189de6f0567/" rel="bookmark">
			微信小程序安卓系统下Input输入内容上移错位问题的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在较长的表单中，页面可能需要滑动， 在这种情况下，在苹果手机上使用Input显示正常，但是在安卓手机上就会出现输入内容上移错位的问题,严重影响使用 需要设置一个状态控制scroll-view是否允许滑动，当Input获取焦点是，将滑动禁止，当Input失去焦点时，允许滑动
&lt;scroll-view scroll-y="{{isScroll}}" style="height: 100vh;"&gt; &lt;input type="digit" @focus="bindfocus" @blur="closeblur" /&gt; &lt;/scroll-view&gt; // 获取焦点事件 bindfocus(){ this.isScroll = false }, // 失去焦点事件 closeblur() { this.isScroll = true } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f260c826a91e6f7747e7a340a3a9eda/" rel="bookmark">
			Java实现大学计算机课程管理平台 JAVA&#43;Vue&#43;SpringBoot&#43;MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 实验课程档案模块2.2 实验资源模块2.3 学生实验模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 实验课程档案表3.2.2 实验资源表3.2.3 学生实验表 四、系统展示五、核心代码5.1 一键生成实验5.2 提交实验5.3 批阅实验5.4 新增实验资源5.5 查询实验课程 六、免责说明 一、摘要 1.1 项目介绍 大学计算机课程管理平台包含实验课程模块、实验资源模块、学生实验模块，前端采用Vue.js，采用View UI组件库美化界面，后端采用SpringBoot框架。在操作系统、开发语言、服务器，数据库、连接技术方面，对应使用Window操作系统、Java语言、Tomcat服务器、MySql数据库以及MyBatis技术完成系统搭建，大学计算机课程管理平台基于B/S架构，采用前后端分离架构，用户可以在系统上查询计算机实验课程、下载实验资源。
随着计算机技术日渐成熟，它已进入人类社会的各个领域并发挥着越来越重要的作用。作为计算机应用的一部分，使用计算机对学校的课程信息进行管理，与手工维护课程相比，有巨大的的优势。越来越多的高校开始采用大学计算机课程管理平台，将学生选择的课程和课程资源通过网络进行管理，为学生、教师和教务管理人员提供便利。
大学计算机课程管理平台使用Idea开发工具完成了编码实现。前端采用Vue.js，采用View UI组件库美化界面，后端采用SpringBoot框架。在操作系统、开发语言、服务器，数据库、连接技术方面，对应使用Window操作系统、Java语言、Tomcat服务器、MySql数据库以及MyBatis技术完成系统搭建。该系统基于B/S架构，采用前后端分离架构，用户可以在系统上查询计算机实验课程、下载实验资源。
1.2 项目录屏 二、功能模块 2.1 实验课程档案模块 实验课程档案模块是高校实验教育中用于记录和管理实验课程信息的模块，实验课程档案模块可以记录和管理实验教学的过程和结果，帮助教师更好地评估学生的知识获取水平和实验操作技能，确保实验教学质量，实验课程档案模块可以记录实验教学的详细过程和结果，使教师能够在后续的实验教学中更有效地管理教学，安排教育资源，提高实验教学的效率，实验课程档案模块提供了丰富的实验数据和结果，使教师能够轻松评估和改进自己的实验课程，并为未来的实验教育提供有力支持，实验课程档案模块记录了实验教学的基本信息、过程和结果，可以为实验教学的研究和考核提供基础数据和资料，实验课程档案模块对高校实验教学是非常必要的，通过实验课程档案模块，可以保证实验教育的质量，提高实验教育的效率，方便课堂评估，加强实验教育和研究，为实验教育的标准化、标准化和信息化提供有力支撑。
2.2 实验资源模块 实验资源模块是用于管理教育机构中与科学实验相关的资源的模块，实验资源模块可以统一管理各类实验设备、设备、文献等资源，并进行分类、编号、记录等操作，使实验资源更加规范、规范、便捷，编写、提供参考资料和教材，促进学生的实验自主性、创新性和探索性，提高实验教育效果，实验资源模块可以提供智能辅助服务，使实验资源的使用更加高效、经济和安全，如网上购物、预订使用和维护，实验资源模块不仅可以支持实验教育，还可以为科学研究提供必要的技术支持和数据分析，促进学术研究的发展。实验资源模块对于教育和研究机构来说是非常必要的，该模块可以统一实验资源的管理，提高实验教育的有效性，节省成本和时间，支持科学研究，同时，实验资源模块可以促进和帮助教育科研机构的数字化转型和智能化升级。
2.3 学生实验模块 学生实验模块是一种用于管理和组织学生实验的教育软件模块，学生实验模块使学生对教学内容和理论知识有更直观的理解，并通过实际操作提高实践能力，学生实验模块允许学生自己操作设备和工具，并具有移动双手和创新的能力。学生实验模块帮助学生加深对课程内容的理解，加深对课程的理解，学生实验模块可以为教师提供全面的实验计划、操作指导和评估系统，并通过实验数据进行分析和反馈，以提高教育质量和效果。通过学生实验模块，可以提高学生的实践能力和动手能力，加深他们对教学的理解和理解，并提供更全面的教育支持和反馈，以提高教学质量和效果。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 实验课程档案表 3.2.2 实验资源表 3.2.3 学生实验表 四、系统展示 五、核心代码 5.1 一键生成实验 @RequestMapping(value = "/oneCreateExp", method = RequestMethod.GET) @ApiOperation(value = "一键生成实验") public Result&lt;Object&gt; oneCreateExp(@RequestParam String id){ ExperimentCurriculum curriculum = iExperimentCurriculumService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f260c826a91e6f7747e7a340a3a9eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5cdfcbc223105be90fcc9ef143cd728/" rel="bookmark">
			Q_DECL_IMPORT和Q_DECL_EXPORT的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q_DECL_IMPORT 和 Q_DECL_EXPORT 是 Qt 框架中用于处理导入和导出符号的宏。
QDECL_IMPORT:
在类或函数的声明中使用 Q_DECL_IMPORT，这个宏告诉编译器该类或函数是在另一个动态链接库中定义的，因此该类或函数是从外部库导入的，编译器应该生成适当的代码来处理导入。通常在头文件中的类和函数声明中使用，以便在使用该类或函数的代码中正确处理导入。
class Q_DECL_IMPORT MyClass { // class definition }; QDECL_EXPORT:
在类或函数的定义中使用 Q_DECL_EXPORT，表示该类或函数是在当前动态链接库中定义的，需要导出给外部模块使用，编译器应该生成适当的代码来处理导出。通常在类和函数的声明文件中使用。
class Q_DECL_EXPORT MyClass { // class definition }; 下面这段代码片段是一个典型的用于处理动态链接库导出和导入的宏定义块，通常在使用 Qt 的项目中会见到。让我解释一下这段代码的作用：
#ifndef BUILD_STATIC//如果没有定义 BUILD_STATIC，则表示当前项目不是以静态链接库的方式构建的，而是动态链接库 # if defined(PIXELCONVERSIONLIBRARY_LIB)//如果定义了 PIXELCONVERSIONLIBRARY_LIB，则表示当前项目是以动态链接库的方式构建的，其中的类或函数是在当前动态链接库中定义的，声明了PIXELCONVERSIONLIBRARY_EXPORT的类需要导出给外部模块使用 # define PIXELCONVERSIONLIBRARY_EXPORT Q_DECL_EXPORT// PIXELCONVERSIONLIBRARY_EXPORT 被定义为 Q_DECL_EXPORT，这表示当前类或函数是在动态链接库中定义的，需要被导出，以便其他模块可以使用它。 # else # define PIXELCONVERSIONLIBRARY_EXPORT Q_DECL_IMPORT// PIXELCONVERSIONLIBRARY_LIB 没有被定义，那么 PIXELCONVERSIONLIBRARY_EXPORT 被定义为 Q_DECL_IMPORT，这表示当前类或函数是在其他动态链接库中定义的，需要被导入，以便当前模块可以使用它。 # endif #else # define PIXELCONVERSIONLIBRARY_EXPORT//如果 BUILD_STATIC 被定义，表示当前项目是以静态链接库的方式构建的，因此 PIXELCONVERSIONLIBRARY_EXPORT 被定义为空，因为静态库不需要导入和导出符号。 #endif 这样的宏定义结构使得在不同构建方式下（静态库或动态库）能够正确处理导出和导入符号，以确保在使用动态链接库的情况下，符号能够正确地被导入和导出。这是为了解决在使用动态链接库时可能涉及的符号可见性和链接问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033ee66ba02ab22ee658f8cc5019858c/" rel="bookmark">
			Java Web编程Servlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java Web编程Servlet Servlet简介第一个Servlet应用基于xml配置的ServletServlet规范相关接口基于注解的ServletServlet HttpServletRequest接口Servlet HttpServletResponse接口Servlet Get请求Servlet Post请求Servlet Form表单处理Servlet生命周期Servlet处理http请求头Servlet处理响应头Servlet请求转发Servlet请求重定向Servlet请求中共享的变量作用域Servlet初始化参数ServletContextServlet cookieServlet sessionServlet过滤器Servlet监听器Servlet实现在线人数统计Servlet访问数据库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2b4c9d6452ecf16ee87a7a87564a2d/" rel="bookmark">
			何时应该使用forEach,何时应该使用map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在JavaScript编程中，循环是不可或缺的工具，它们允许我们有效地处理和操作数组中的元素。然而，JavaScript提供了多种不同类型的循环方法，其中包括forEach和map。这两者可能看起来很相似，但它们在使用和用途上存在显著差异。
你是否曾经在编程中感到困惑，不确定何时应该使用forEach，何时应该使用map？本文将解开这个迷题，帮助你更好地理解这两种循环的区别，并提供实际的示例，以便你在日常编程中能够明智地选择合适的循环方法。让我们深入研究forEach和map，探讨它们的语法、用法，以及最佳实践。
问题的答案 为了理解两者的区别，我们看看它们分别是做什么的。
forEach
遍历数组中的元素。为每个元素执行回调。无返回值。 const a = [1, 2, 3]; const doubled = a.forEach((num, index) =&gt; { // 执行与 num、index 相关的代码 }); // doubled = undefined map
遍历数组中的元素通过对每个元素调用函数，将每个元素“映射（map）”到一个新元素，从而创建一个新数组。 const a = [1, 2, 3]; const doubled = a.map((num) =&gt; { return num * 2; }); // doubled = [2, 4, 6] .forEach和.map()的主要区别在于.map()返回一个新的数组。如果你想得到一个结果，但不想改变原始数组，用.map()。如果你只需要在数组上做迭代修改，用forEach。
1.forEach 循环的解析 1.1 语法和用法 解释 forEach 循环的基本语法。强调如何使用它来遍历数组并执行回调函数。 forEach 循环是 JavaScript 中的一种数组迭代方法，其语法如下： array.forEach(callback(element, index, array)); callback 是在数组的每个元素上执行的函数。element 代表当前数组元素。index 代表当前元素的索引。array 是调用 forEach 的数组本身。 forEach 循环对数组中的每个元素应用回调函数，但它不会创建一个新数组或改变原始数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f2b4c9d6452ecf16ee87a7a87564a2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1cafd8661298485171147f51c0432b9/" rel="bookmark">
			【Vue3】源码解析-编绎模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 系列文章computed.specparse.speccompile.spec来源 系列文章 【Vue3】源码解析-前置
【Vue3】源码解析-响应式原理
【Vue3】源码解析-虚拟DOM
【前端】Typescript入门
【Vue3】源码解析-编绎模块
computed.spec computed 一般有两种常见的用法:
一：传入一个对象，内部有 set 和 get 方法，属于ComputedOptions形式。在内部会有getter / setter两个变量来进行保存.
const age = ref(18); const myAge = computed({ get() {}, set() {}, }); 二：传入一个 function，在内部会有getter来进行保存.
const age = ref(18); const myAge = computed(() =&gt; { return age.value + 10; }); 计算属性的源码大部分是依赖 effect 的实现。基于上一篇文章对 effect 源码的理解，effect 可以传递一个函数和一个对象 options。
而计算属性的本质就是一个 effect，在之前 effect 的源码中预先声明了 lazy和scheduler 属性，就是用于计算属性，因为计算属性默认不会被执行，lazy 表示 effect 不会立即被执行，scheduler 会在 trigger 中判断是否传入了 scheduler，传入就执行 scheduler 方法。scheduler 中，判断当前的_dirty 是否为 false，会把_dirty 置为 true，且执行 trigger 触发响应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1cafd8661298485171147f51c0432b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54fd52f33a56e40049711ec820c62921/" rel="bookmark">
			uni-app小程序 uni.showToast字数超过两行自动省略显示不全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际开发过程中如果用户提交某些文件时，如果缺少某些条件我们要提醒用户缺少那些条件才能提交，但是如果我们用uni.showToast提醒的次数超过7个字的时候就会导致文字显示不全，达不到提醒的效果，这种时候我们就需要使用uni.showModa显示态弹窗
主要使用的参数是：
uni.showModal({ title: '提示',//标题 content: '至少填写拒绝理由或者上传图片其中一种',//提示内容 showCancel: false//不显示取消按钮 }) 运行效果:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2667b05c29b1a376fffcce9033acfe/" rel="bookmark">
			第90讲：MySQL数据库主从复制集群原理概念以及搭建流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.MySQL主从复制集群的核心概念1.1.什么是主从复制集群1.2.主从复制集群中的专业术语1.3.主从复制集群工作原理1.4.主从复制中的小细节1.5.搭建主从复制集群的前提条件1.6.MySQL主从复制集群的架构信息 2.搭建MySQL多实例环境2.1.在mysql-1中搭建身为主库的MySQL实例2.2.在mysql-2中搭建MySQL多实例2.2.1.安装数据库软件2.2.1.搭建第一个3306从库的MySQL实例2.2.2.搭建第二个3307从库的MySQL实例 2.3.MySQL多个节点搭建完毕 3.配置MySQL主从复制集群3.1.在主库开启Binlog二进制日志3.2.在主库上创建主从复制的用户3.3.将主库数据备份并在从库中进行还原3.4.配置从库连接主库的复制信息3.5.启动主从复制线程 4.查看主从复制集群状态 1.MySQL主从复制集群的核心概念 1.1.什么是主从复制集群 主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。
MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。
MySQL 复制的优点主要包含以下三个方面：
主库出现问题，可以快速切换到从库提供服务。实现读写分离，降低主库的访问压力。可以在从库中执行备份，以避免备份期间影响主库服务。 1.2.主从复制集群中的专业术语 在MySQL主从复制集群中，主要分为两大部分：文件、线程。
文件：
主库 Binlog：二进制日志。 从库 relay-log：中继日志，主库推送过来的Binlog日志都存放在中继日志中。master.info：从库复制主库的信息文件，记录着主库的地址、用户、Binlog等信息。relay-log.info：中继日志的信息文件，该文件记录了上次执行relay-log的位置等信息。 线程：
主库 binlog_dump_thread：二进制日志投递线程，主要将二进制日志发送给从库的线程。 从库 IO_Thread：从库的IO线程，用于请求和接收主库的Binlog二进制日志。SQL_Thread：从库的SQL线程，用于将主库发来的二进制日志在数据库中进行数据复制。 1.3.主从复制集群工作原理 MySQL主从复制集群的工作原理主要围绕前面提到的文件和线程。
MySQL主从复制集群的原理：
1）首先从库执行change master to将连接主库的配置信息记录到master.info文件中，此时从库上会开启两个线程：I/O线程和SQL线程。
2）从库上的I/O线程会从master.info文件中读取主库的连接信息。
3）从库I/O线程获取到主库的信息后，会与主库进行身份认证，然后建立连接。
4）当从库I/O线程成功连接到主库后，主库会立即给从库分配一个binlog_dump_thread线程，用于推送Binlog日志到从库。
5）从库I/O线程会根据master.info中记录的Binlog信息（Binlog日志文件、标识位号）与主库的binlog_dump_thread线程请求最新的Binlog日志。
6）这时主库的binlog_dump_thread线程就会去查询是否产生了新的Binlog日志，如果产生了新的Binlog日志，会截取最新的Binlog日志然后推送给从库的I/O线程。
7）从库的I/O线程接收到主库推送的Binlog日志后，会现将其存放在内存的TCP/IP缓存中，然后告知主库的binlog_dump_thread线程，Binlog日志已收到。
8）此时从库的I/O线程会去更新master.info文件中的Binlog位置点信息，记录最新的Binlog标识号。
9）然后从库的I/O线程会将主库推送的Binlog日志写入到磁盘上的relay-log文件中。
10）最后由从库的SQL线程读取relay-log.ifno文件，获取relay-log最新的位置点，然后根据的位置点去relay-log中执行最新的Binlog日志，执行完成后会再次更新relay-log.info文件中记录的relay-log位置点。
这就是完整的主从复制工作原理。
简单来说MySQL主从复制的原理就是，从库的I/O线程读取连接主库的配置信息，然后去连接主库开始主从同步，当I/O线程连接上主库后，主库会立即给I/O线程分配一个Dump线程，用于推送Binlog日志到从库，此时I/O线程会根据master.info文件中记录的Binlog信息，向主库的Dump线程请求最新的BInlog，Dump线程查询到有最新的Binlog产生，会将最新的Binlog截取，然后推送给从库的I/O线程，I/O线程收到Binlog日志后，将其存放在内存的TCP/IP缓存中，然后更新master.info文件中最新的Binlog信息，紧接着将Binlog日志写入到relay-log中，最后由从库的SQL线程从relay-log.info中读取relay-log的位置号，然后执行relay-log中最新的Binlog日志，执行完成后，再次更新relay-log.info中的relay-log位置号，以便于下次再relay-log中读取最新的Binlog日志。
relay-log日志会通过MySQL中的其他线程定期清理。
1.4.主从复制中的小细节 从上面说的主从复制原理来看，好像每次都是从库向主库去请求新数据，那么什么时候从库才应该向主库请求呢？请求的频率如何？
其实是这样的：当主库上产生了新的事务，更新到Binlog日之后，会给binlog_dump_thread线程发送一个“信号”，binlog_dump_thread线程会与从库的I/O线程一直建立连接，binlog_dump_thread线程就会通知从库的I/O线程有新数据产生了，这时从库的I/O线程就带着master.info中记录的最新Binlog标识位号，向binlog_dump_thread线程请求最新的Binlog，然后完成数据同步。
MySQL主从复制第一次复制时，是按照上面说到的10步完成的，第二次复制时，只需要等待主库的binlog_dump_thread线程向从库的I/O线程发送信号，然后I/O线程去请求最新的Binlog，最后由SQL线程复制数据即可。
1.5.搭建主从复制集群的前提条件 搭建MySQL主从复制集群的前提条件如下：
首先需要准备多个MySQL实例，最少两个MySQL实例，能够实现一主一从的架构，可以在多个服务器中分布部署独立的MySQL节点，也可以在一台服务器中部署多个MySQL实例。每个MySQL实例都需要由单独的sever_id。身为主库角色的MySQL实例需要开启二进制日志，从库在特定场景下需要开启。主库需要授权一个专门的用户作为主从复制的用户。如果主库是一个运行很多年的数据库，突然要升级为主从复制集群，最好先将主库的数据同步一份到从库中。开启专用的复制线程。 1.6.MySQL主从复制集群的架构信息 本次主从复制的架构是一主两从的结构。
IP主机名端口角色server_id192.168.20.11mysql-13306主库1192.168.20.12mysql-23306从库2192.168.20.12mysql-23307从库3 2.搭建MySQL多实例环境 再搭建MySQL主从复制集群之前，首先搭建出多个MySQL实例，由于服务器有限，因此通过两台机器模拟出一主两从的环境。
主从复制集群中有一个节点开启了gtid，所有的节点都需要开启gtid，否则主从将不能同步。
2.1.在mysql-1中搭建身为主库的MySQL实例 mysql-1服务器中的3306端口的MySQL实例再前面已经搭建完成了，就是我们一直在使用的数据库实例，里面有数据，更加方便演示主从集群，下面只是提供一下搭建过程的步骤。
注意每个MySQL节点的server_id都要设置成不同的，如果你的一主两从都是单独在不同服务器中部署的，那么直接参考本小结的数据库实例安装即可，不用再看多实例的步骤了。
1.解压MySQL [root@mysql-1 ~]# tar xf mysql-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e2667b05c29b1a376fffcce9033acfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730fdbb5a7e07687995ad386377696cf/" rel="bookmark">
			95%数据格式都支持？3D模型格式转换引擎HOOPS Exchange真绝了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、HOOPS Exchange概述 HOOPS Exchange是一款用于读写专有和开放CAD数据格式的通用工具包，专为开发3D工程应用程序而设计，通过单一界面，即可读取和写入30多种CAD文件格式，无需依赖任何CAD系统。HOOPS Exchange可以无缝集成到CAD、CAE/分析、CAM、机械制造、CMM、PLM、数字工厂、建筑等领域的各种应用程序中。它可以满足不同领域的不同需求和工作流程，包括可视化、设计、分析、文档管理、协作、设计审核、报价、3D 打印、制造、AR/VR等。
HOOPS Exchange具备在不同平台上使用的可定制的API，不管您是否使用建模内容，都支持无缝集成到您的应用程序中。它提供了一组几何函数，用于查询模型并调整几何形状以满足您的要求。该API可以生成各种类型的曲面细分、修复、缝合、修复不一致的几何形状，调整 Brep 定义和曲面以供不同建模者重复使用。
此外，HOOPS Exchange还可以投影表面上的点、计算物理属性，并可以与几何内核（Parasolid、ACIS、OpenCascade）或网格修复 API (Polygonica) 等第三方库配合使用，以增强您的市场需求和工作流程。
HOOPS Exchange允许您将内存中的3D 模型导出为最常见的标准格式，包括 STEP、JT、3D PDF、STL、glTF 等。
二、HOOPS Exchange典型用例 为了帮助您识别最适合您需求的用例，并进一步帮助理解HOOPS Exchange概念。本文考虑了四个典型的用例：
模型数据可视化
三维建模
数据存档
3D PDF发布
数据的标记与视图
☆注意：下面的应用场景不是针对特定市场，也不是HOOPS Exchange的全部用例，这些应用场景着重于对特定用例最有用的数据和工作流的类型，了解详情，请点击此处与我们联系。
HOOPS中文网http://techsoft3d.evget.com/
01 模型数据可视化
可视化数据的典型用途包括产品目录，工作指令创建，重新网格化以进行有限元分析和计算流体动力学，以及包含在大型装配体中以进行设计审查和碰撞检测，例如建筑、船舶和工厂模型。
尽管许多系统可以对镶嵌数据进行建模操作，但大部分可视化需求的用户对镶嵌数据更感兴趣。
标准精确镶嵌
通过网格对齐点插入进行精确的细分
02 三维建模
建模包括曲面和实体建模器，以及混合曲面和实体建模器。在这种情况下，B-rep拓扑和准确的表面信息非常重要。我们慧都具有将HOOPS Exchange与常用的实体建模内核（西门子的Parasolid和达索系统的ACIS）集成的丰富经验，并可以为此提供咨询服务。如果您有兴趣将HOOPS Exchange与这些内核之一集成，请联系我们。
HOOPS Exchange用于建模的典型用户包括机械设计下游的许多制造应用程序，例如计算机辅助制造/加工（CAM），计算机辅助工程（CAE/CFD/FEA）和坐标测量机（CMM）规划软件。
HOOPS Exchange与Parasolid集成
03 数据存档
数据归档代表了根据准确的3D模型数据来保存和保护组织知识产权的要求。HOOPS Exchange提供了独特的功能：以开放格式存储特定于模型的原始表面数据，旨在获得ISO认证。这使大型制造公司和PLM系统供应商可以确保数字资产得到长期保护，并且可以以原始精度提供给未来的用户。
同样，B-rep拓扑和准确的表面信息也很重要，尽管许多此类系统将主要以棋盘形式使用此信息进行显示。
B-rep模型切片
04 3D PDF发布
HOOPS Exchange包含导出为PRC文件格式的功能。此格式是Adobe PDF文件中用于3D数据的主要容器格式。HOOPS Exchange扩展了此功能，可以将CAD数据直接转换为这些容器，以用于PDF发布。
PLM系统供应商可以将HOOPS Exchange用作创建智能3D PDF文档的策略的一部分，该文档可用于在公司防火墙之外设置和管理基于文档的高级工作流。
CAD系统以及下游制造和分析系统的供应商可以利用HOOPS Exchange通过在PDF文件中包含安全的3D数据来增强报告生成选项。
CATIA V5发布的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/730fdbb5a7e07687995ad386377696cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e44c13fc4686d840ac2e0aeef512704b/" rel="bookmark">
			告别枯燥，247个Python经典实战案例集合（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为大家推荐一个Python从入门到进阶的实战案例合集，共计247个案例，185页内容。从此告别枯燥，60秒学会⼀个⼩例⼦，系统学习Python，从⼊门到⼤师。
所有均含有实例代码，可直接运行！！！
感受python之美 用最短的代码实现。
02 Python基础
主要总结Python常⽤内置函数；Python独有的语法特性、关键词 nonlocal, global等；内置数据结构包括：列表(list), 字典(dict), 集合(set), 元组(tuple) 以及相关的⾼级模块 collections中的 Counter, namedtuple, defaultdict， heapq模块。共有 90个⼩例⼦。
03 字符串和正则
字符串⽆所不在，字符串的处理也是最常见的操作。本章节将总结和字符串处理相关的⼀切操作。主要包括基本的字符串操作；⾼级字符串操作之正则。共有 25个⼩例⼦。
04 文件、日期、多线程
Python⽂件IO操作涉及⽂件读写操作，获取⽂件 后缀名 ，修改后缀名，获取⽂件修改时间， 压缩 ⽂件， 加密 ⽂件等操作。
Python⽇期章节，由表⽰⼤⽇期的 calendar, date模块，逐渐过渡到表⽰时间刻度更⼩的模块：datetime, time模块，按照此逻辑展开。
Python 多线程 希望透过5个⼩例⼦，帮助你对多线程模型编程本质有些更清晰的认识。
⼀共总结最常⽤的 26个关于⽂件和时间处理模块的例⼦。
05 三大利器
Python中的三⼤利器包括：迭代器 ，⽣成器 ， 装饰器 ，利⽤好它们才能开发出最⾼性能的Python程序，涉及到的内置模块 itertools提供迭代器相关的操作。此部分收录有意思的例⼦共计15例。
06 Python绘图
Python常⽤的绘图⼯具包括：matplotlib, seaborn, plotly等，以及⼀些其他专⽤于绘制某类图如词云图等的包，描绘绘图轨迹的 turtle包等。本章节将会使⽤⼀些例⼦由易到难的阐述绘图的经典⼩例⼦，⽬前共收录 27个。
07 Python之坑
Python编程中常见的坑。
08 第三方包
实用的第三方工具包。
09 必知算法
包括排序、统计、深度学习等基础算法知识。
10 项目实战
包括环境搭建、GUI编程等等。
11 Pandas数据分析案例实战
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e44c13fc4686d840ac2e0aeef512704b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7bdfc8125eb5aecfdf6af761e1e956/" rel="bookmark">
			NLP论文阅读记录 - 2022 | WOS 02 使用 BERT 模型进行抽取式文本摘要的性能研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言0、论文摘要一、Introduction1.1目标问题1.2相关的尝试1.3本文贡献 二.文献综述2.1 总结方法 三.本文方法3.1 总结为两阶段学习3.1.1 基础系统 3.2 重构文本摘要 四 实验效果4.1数据集4.2 对比模型4.3实施细节4.4评估指标4.5 实验结果4.6 细粒度分析 五 总结思考 前言 Performance Study on Extractive Text Summarization Using BERT Models（22） 0、论文摘要 概括任务可以分为两种方法：抽取式和抽象式。提取摘要从原始文档中选择显着句子形成摘要，而抽象摘要解释原始文档并用自己的语言生成摘要。
文献中已经用不同的方法研究了生成摘要的任务，无论是提取的还是抽象的，包括基于统计、图形和深度学习的方法。与经典方法相比，深度学习已经取得了令人鼓舞的性能，并且随着注意力网络（通常称为变压器）等不同神经架构的进步，摘要任务存在潜在的改进领域。
Transformer 架构及其编码器模型“BERT”的引入提高了 NLP 下游任务的性能。 BERT 是来自建模为编码器堆栈的转换器的双向编码器表示。 BERT 有不同的大小，例如具有 12 个编码器的 BERT-base 和具有 24 个编码器的 BERT-larger，但出于本研究的目的，我们重点关注 BERT-base。
本文的目的是通过一系列实验对基于 BERT 的模型变体在文本摘要方面的性能进行研究，并提出“SqueezeBERTSum”，这是一种使用 SqueezeBERT 编码器变体进行微调的训练摘要模型，该模型实现了有竞争力的 ROUGE 分数将 BERTum 基线模型性能保留了 98%，可训练参数减少了 49%。
一、Introduction 1.1目标问题 自动文本摘要是一个活跃的研究领域，可以定义为提取大型文档的重要句子或片段并将它们组合成文档的简短版本的过程。总结文本既省时又经济。就时间效率而言，通过阅读掌握文档要点的摘要版本，人类读者可以花费更少的时间来阅读文档。新闻组可以在多个文档上使用文档摘要工具来收集以较短版本讨论同一主题的每个文档的重要信息。就成本效率而言，摘要可用于压缩从一个设备传输到另一个设备的文本数据量。对于用户来说，在决定下载整个文档或文章进行阅读之前选择阅读文档或文章的摘要版本将是有益的。以目前的数据增长速度，很快就会有一种工具可以生成较短版本的文本数据作为人类读者的服务。
1.2相关的尝试 自动文本摘要的任务主要由三个阶段组成：数据预处理阶段、算法处理阶段和后处理阶段。
1.1.数据预处理阶段 这是在汇总之前清理原始源文档并将其转换为更兼容的数据格式的过程。数据预处理技术的例子有： (1) 去除文档中的噪声数据； (2) 句子和单词标记化； (3) 标点符号的去除； (4) 去除停用词，去除频繁出现的词，如(a)、(an)、(the)等； (5) 词干提取，即去除后缀和前缀； （6）单词词形还原，即将单词转化为其基本结构，例如将单词“play”转化为“play”； (7)词性标注。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f7bdfc8125eb5aecfdf6af761e1e956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d2623c60ccdcdef83084feccb4fdc8/" rel="bookmark">
			鸿蒙开发语言ArkTS--入门Hello World
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙开发语言ArkTS–入门Hello World 首先安装软件，并且新建项目，可以参考文章：鸿蒙开发工DevEco Studio的安装与使用
本篇博客主要是解析ArkTS的index的页面来简单了解这个语言的语法，至于后面的详细细节，我会逐渐更新。
@Entry ：相当于页面入口的标志，否则无法进入该页面@Component ：创建一个名为Index的组件(声明组件)@State message: string = ‘Hello World’ // 创建一个名为message的状态变量，初始值为’Hello World’，如果仅仅是定义变量，则并不需要@State ，加上这个就可以实现数据的双向绑定。build：构建一个页面，可以理解为一个容器，并且可以理解为html中的divRow() ：创建一个行组件Column()： 在行组件中创建一个列组件。 注：行组件和列组件也是一个容器，往这两个容器中添加内容如：input，button等，其会自动按照行（Row），列（Column）来排列，如图（以Column为例）：
7. fontSize(50) 、fontWeight(FontWeight.Bold) 等属性就是设置文本框，输入框等样式，里面的属性与CSS中的含义和用法差别不是很大。
8. width(‘100%’) ：设置列组件的宽度为100%
9. height(‘100%’)： 设置行组件的高度为100%
width和height都是 设置相应的盒子（Row和Column等容器类）的大小，以达到对页面的调整和修饰。
源码和代码解释如下：
@Entry //相当于页面入口的标志，否则无法进入该页面 @Component // 创建一个名为Index的组件(声明组件) struct Index { @State message: string = 'Hello World' // 创建一个名为message的状态变量，初始值为'Hello World' build() { // 创建一个名为build的方法 Row() { // 创建一个行组件 Column() { // 在行组件中创建一个列组件 Text(this.message) // 在列组件中创建一个文本组件，并显示message变量的值 .fontSize(50) // 设置文本字体大小为50 .fontWeight(FontWeight.Bold) // 设置文本字重为粗体 } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71d2623c60ccdcdef83084feccb4fdc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e99d71ba6f92a1d563824172ac42e12/" rel="bookmark">
			OBS 使用OBSQTDisplay渲染捕捉源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现一个简单的录制软件：支持录制桌面与窗口_win32 指定窗口录屏-CSDN博客
在这上面接着开发， 上面的工程中我们可以录制捕获源，但是无法在Ui层像obs一样预览：
OBS 预览画布 QT 自定义渲染与OBS中的实现-CSDN博客
obs中源的预览使用的是OBSQTDisplay类，该类会创建一个native的窗口，然后将材质渲染在该窗口中，因此性能很高，详细可参见上面的文章。
obs的UI层逻辑很复杂，我们可以使用obs的c库，自定义UI层，将捕捉源渲染在UI上。
使用到的obs中的文件有qt-display.hpp qt-display.cpp display-helpers.hpp 在编译过程中有些报错，因此删除了不必要的功能。
#pragma once #include &lt;QWidget&gt; #include &lt;obs.hpp&gt; #define GREY_COLOR_BACKGROUND 0xFF4C4C4C class OBSQTDisplay : public QWidget { Q_OBJECT Q_PROPERTY(QColor displayBackgroundColor MEMBER backgroundColor READ GetDisplayBackgroundColor WRITE SetDisplayBackgroundColor) OBSDisplay display; void resizeEvent(QResizeEvent* event) override; void paintEvent(QPaintEvent* event) override; signals: void DisplayCreated(OBSQTDisplay* window); void DisplayResized(); public: OBSQTDisplay(QWidget* parent = nullptr, Qt::WindowFlags flags = Qt::WindowFlags()); ~OBSQTDisplay() { display = nullptr; } virtual QPaintEngine* paintEngine() const override; inline obs_display_t* GetDisplay() const { return display; } uint32_t backgroundColor = GREY_COLOR_BACKGROUND; QColor GetDisplayBackgroundColor() const; void SetDisplayBackgroundColor(const QColor&amp; color); void UpdateDisplayBackgroundColor(); void CreateDisplay(bool force = false); }; #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e99d71ba6f92a1d563824172ac42e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeefcb83184c6724470ff0f51edff052/" rel="bookmark">
			Apache Common 工具介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Apache Common包含的工具库众多，主要为Java开发者提供各种实用的功能和组件。其中包括数据结构处理、IO操作、网络编程、数学运算、字符串处理等等多种功能模块。这些工具库的使用可以显著提高开发效率，使得程序员可以将更多的精力集中在业务逻辑的实现上，而不需要从头开始编写这些基础功能。
一、Commons BeanUtils 说明：针对Bean的一个工具集。由于Bean往往是有一堆get和set组成，所以BeanUtils也是在此基础上进行一些包装。
二、Commons CLI 说明：这是一个处理命令的工具。比如main方法输入的string[]需要解析。你可以预先定义好参数的规则，然后就可以调用CLI来解析。
三、Commons Codec 说明：这个工具是用来编码和解码的，包括Base64，URL，Soundx等等。用这个工具的人应该很清楚这些，我就不多介绍了。
四、Commons Collections 说明：你可以把这个工具看成是java.util的扩展。
五、Commons Configuration 说明：这个工具是用来帮助处理配置文件的，支持很多种存储方式
六、Commons DBCP 说明：Database Connection pool, Tomcat就是用的这个，不用我多说了吧，要用的自己去网站上看说明。
七、Commons DbUtils 说明：我以前在写数据库程序的时候，往往把数据库操作单独做一个包。DbUtils就是这样一个工具，以后开发不用再重复这样的工作了。值得一体的是，这个工具并不是现在流行的OR-Mapping工具（比如Hibernate），只是简化数据库操作
八、Commons HttpClient 说明：这个工具可以方便通过编程的方式去访问网站。
九、Commons IO 说明：可以看成是java.io的扩展，我觉得用起来非常方便。
十、Commons JXPath 说明：Xpath你知道吧，那么JXpath就是基于Java对象的Xpath，也就是用Xpath对Java对象进行查询。这个东西还是很有想像力的。
十一、Commons Lang 说明：这个工具包可以看成是对java.lang的扩展。提供了诸如StringUtils, StringEscapeUtils, RandomStringUtils, Tokenizer, WordUtils等工具类。
十二、Commons Logging 说明：你知道Log4j吗
十三、Commons Math 说明：看名字你就应该知道这个包是用来干嘛的了吧。这个包提供的功能有些和Commons Lang重复了，但是这个包更专注于做数学工具，功能更强大。
十四、Commons Net 说明：这个包还是很实用的，封装了很多网络协议。
FTPNNTPSMTPPOP3TelnetTFTPFingerWhoisrexec/rcmd/rloginTime (rdate) and DaytimeEchoDiscardNTP/SNTP 十五、Commons Validator 说明：用来帮助进行验证的工具。比如验证Email字符串，日期字符串等是否合法。
十六、Commons Virtual File System （） 说明：提供对各种资源的访问接口。支持的资源类型包括
CIFSFTPLocal FilesHTTP and HTTPSSFTPTemporary FilesWebDAVZip, Jar and Tar (uncompressed, tgz or tbz2)gzip and bzip2resram
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeefcb83184c6724470ff0f51edff052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c0115060d9e9576a12cba8d51b7389c/" rel="bookmark">
			解决报错：Not implemented: HTMLCanvasElement.prototype.getContext (xxx installing the canvas npm pack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是在js逆向中使用jsdom模拟浏览器环境，结果还是报错了： 网上很多说法是安装canvas: npm install canvas，其实并不正确 解决办法：加入以下代码：
window.HTMLCanvasElement.prototype.getContext = () =&gt; {
// return whatever getContext has to return
};
问题解决：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f5e1cb400b23c8076188cc25ca033d/" rel="bookmark">
			独家分享！10个设计师必知的无版权素材网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有朋友留言说找不到免费素材网站，今天为大家整理10个免费素材网站。以后很容易找到设计中使用的材料。
毫无疑问，图片材料现在变得越来越重要，无论是设计还是视频制作，图片都非常重要。
虽然国内有很多图片网站，但大多数都是收费或没有版权描述，所以要么不能使用，要么不知道这些图片是否可以免费使用。所以这次分享主要是外国网站！
01即时设计 即时设计资源广场是一个内置的在线协作设计工具即时设计社区，包括大量的设计资源，包括UI组件集、界面集、图标、设计系统、移动设计、网页设计、插图、线框图等平面设计图片。即时设计是一种基于矢量编辑的工具，它的矢量网格图形、笔和蒙版工具可以帮助您有效地完成设计和创建。在即时设计资源广场上，您只需注册即时设计帐户，即可在线编辑、下载和导出平面设计图片材料。除了大量的平面设计图纸材料外，还为创作者提供了开源和高效的设计插件。即时设计插件广场结合创作者的工作需要，不断更新图片编辑、背景删除、Pexels、色板等。帮助创作者在一个工具中在线完成平面设计，从工具来回切换的工作流中解放创作者，拓宽创作者的能力和便利性。
免费的无版权素材网站即时设计是一款支持在线协作的专业级 UI 设计工具，支持 Sketch、Figma、XD 格式导入，海量优质设计资源即拿即用。支持创建交互原型、获取设计标注，为产设研团队提供一站式协同办公体验。https://js.design/?source=csdn&amp;plan=bttcsdn01181
02Pexels Pexels是一个提供大量共享图片资料的网站，每周定量更新，照片由专人在众多图片中精心挑选。
Pexels可以说是图片素材界的超级网红，到处都有。
然而，最重要的是提供强大的筛选功能，你可以根据搜索热度或颜色来筛选图片。
可以下载各种分辨率，包括原图尺寸。
03Pixelmob pixelmob是一个支持中文搜索的免费商用图库。
里面有很多不同类型的照片，你可以通过Pixabay找到你想要的照片，这可以完美地解决各种场合的分辨率要求。
04Colorhub ColorHub是一个图片资源库，提供免费的高清晰度和无版权。
现在已经收录了91726张高清图片，质量很高，而且每天都在不断更新。
除了可以直接输入中文关键字进行搜索外，ColorHub还可以根据颜色进行搜索，可以说是十分方便
05Unsplash Unsplash是一个拥有大量免费高质量照片的网站。
每天更新一张高质量的图片，清新的生活氛围图片可以应用到各种需要的环境中，非常值得收藏。
06VisualHunt 如果你正在寻找一个易用且图片丰富的免费图库，VisualHunt将包含大量的免费图片，声称超过3亿张！
而且它可以通过颜色找到图片，无需注册、登录，即可在线下载图片。
如果您想找到特定颜色的图片，请在上面的VisualHunt主页搜索框下点击相应的色条！
选择后，会出来相同颜色的图片材料供您使用，上面也可以选择授权类型。
07FindA.Photo FindA.Photo也是一个可以根据图片颜色和图片标签进行搜索的网站，
拥有CC0授权的图片资源超过几千张，无版权限制，随意使用。
使用方法也是如此，点击相应的色条即可！无需注册、登录，直接下载图片，而且是高清大图，也可以编辑。
08StockSnap StockSnap是一个素材库，可以自由下载和使用高清摄影图片，
提供的资源相当实用，网站由多位摄影师组成，提供丰富的免费照片，
不需要授权随意使用。
09Picjumbo Picjumbo网站上的图像资源非常好，而且使用起来非常简单方便。类似地，
该网站上的图像资源没有版权限制，可以免费供个人和商业使用。
不但有图片，还有各种插图，矢量画。照片质量很好，很适合界面设计或者其他项目。
10Pngimg 这主要用作材料，有2万多张不同类型的无背景材料图片！可直接免费使用。
请注意，它都是无背景图片，非常适合那些需要png透明底配图的人。
而且分类也很细致，找起来很方便。
即时设计 - 可实时协作的专业 UI 设计工具即时设计是一款支持在线协作的专业级 UI 设计工具，支持 Sketch、Figma、XD 格式导入，海量优质设计资源即拿即用。支持创建交互原型、获取设计标注，为产设研团队提供一站式协同办公体验。https://js.design/?source=csdn&amp;plan=bttcsdn01181
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec550b15ba96aaac77586fce35908c37/" rel="bookmark">
			数据结构之dict类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dict类 dict 是字典类。什么是字典（Dictionary）呢？就是一个可以通过索引找到对象的数据类型。在Python 的dict类里，索引就是“键”，对象也叫“值”，二者合起来就叫“键值对”。每个“键值对”之间用逗号（，）隔开，每个“键”和“值”之间用冒号（：）隔开，“键”与“值”之间一 一对应。
dict的賦値 输出结果 注意 “键”是不可变的，因此其类型只能是 int 型、str 型、tuple 型和bool 型等；而“值”是可以随意改变的，也就意味着它可以是任意的数据类型。
2. Python中dict的知识点 dict 绝对算是 Python 中最常用的数据类型了，从检索的逻辑到方法，从元素添加到修改，无不体现出了暴力美学。
输出结果 小知识 字典还有fromkeys()、update()等很多十分实用的内置方法，字典还有一个好的特性,就是检索字典的效率非常快,像列表、元组根本不能和它相比，因为字典是一对一检索的，也就是时间复杂度为O(1)。相比之下，列表的时间复杂度则更复杂一些，如下表所示。
操作操作说明时间复杂度注 释index(value)查询索引O(1)append(value)队尾添加O(1)pop()删除并返回最后的元素O(1)pop(index)根据索引删除某个元素O(n)后面的元素需要前移insert(index,value)根据索引插入某个元素O(n)reverse列表反转O(n)sort列表排序O(n log n) 注意 字典的copy()和 iteration()的时间复杂度为O(n)。
这就又涉及时间复杂度和空间复杂度的计算问题了，你可还记得算法量度？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0cf817b6f8f6ed1ce35fa22c427f3e5/" rel="bookmark">
			QT 自定义渲染与OBS中的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QPaintEngine *QWidget::paintEngine 的实现：
/*! \fn QPaintEngine *QWidget::paintEngine() const Returns the widget's paint engine. Note that this function should not be called explicitly by the user, since it's meant for reimplementation purposes only. The function is called by Qt internally, and the default implementation may not always return a valid pointer. */ QPaintEngine *QWidget::paintEngine() const { qWarning("QWidget::paintEngine: Should no longer be called"); #ifdef Q_OS_WIN // We set this bit which is checked in setAttribute for // Qt::WA_PaintOnScreen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0cf817b6f8f6ed1ce35fa22c427f3e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f98909cdd23a543888c25af1064dd6/" rel="bookmark">
			echarts X轴数据过多导致重叠展示不全问题（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 x轴数据过多导致坐标轴数据重叠
修改后 List item interval为0代表每个标签都显示，即间隔为0！
将其设置为我们想要的数值即可。
xAxis: { type: "time", splitLine: { show: false, }, axisLine: { show: false, lineStyle: { color: "#ffffff", }, }, axisLabel: { interval: 20,//20个点显示一个 rotate: 35 //旋转角度 } }, 这样，效果就好点了，如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad864a628172a1f5b97ba0ab4fbd8a26/" rel="bookmark">
			python222网站实战(SpringBoot&#43;SpringSecurity&#43;MybatisPlus&#43;thymeleaf&#43;layui)-主页设计Menu动态菜单模块实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		锋哥原创的Springboot+Layui python222网站实战：
python222网站实战课程视频教程（SpringBoot+Python爬虫实战） ( 火爆连载更新中... )_哔哩哔哩_bilibilipython222网站实战课程视频教程（SpringBoot+Python爬虫实战） ( 火爆连载更新中... )共计23条视频，包括：python222网站实战课程视频教程（SpringBoot+Python爬虫实战） ( 火爆连载更新中... )、第2讲 架构搭建实现、第3讲 页面系统属性动态化设计实现等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV1yX4y1a7qM/新建t_menu表
CREATE TABLE `t_menu` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT NULL, `url` VARCHAR(500) DEFAULT NULL, `color` VARCHAR(20) DEFAULT NULL, `strong` BIT(1) DEFAULT b'0', `sort` INT(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8; /*Data for the table `t_menu` */ INSERT INTO `t_menu`(`id`,`name`,`url`,`color`,`strong`,`sort`) VALUES (1,'首页','/','black','\0',1),(2,'课程','/course/list','black','\0',2),(3,'Java全栈学习路线图','/article/1','black','',3),(6,'关于锋哥','/article/14','#e11717','',6),(9,'java1234门徒服务','/article/5','#000000','',5),(11,'VIP活动特价','http://www.java1234.com/vip.html','#f50606','',4); 通过MybatisX插件生成代码
缓存里获取menuList
common下面新建menu.html
&lt;meta charset="UTF-8"&gt; &lt;div id="m"&gt; &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad864a628172a1f5b97ba0ab4fbd8a26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577707994d484b92e58f5cd4db2e3f9c/" rel="bookmark">
			发现一款提高工作效率的利器——ONLYOFFICE办公软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 📌 一、前言🔎 二、ONLYOFFICE介绍❓ 三、ONLYOFFICE的优势？3.1 开源免费3.2 安全第一3.3 可自定义3.4 集成简单，可嵌入网页端3.4.1 编辑DOCX体验3.4.2 编辑XLSX体验3.4.3 编辑PPTX体验3.4.4 编辑PDF体验 3.5 支持多平台使用3.6 支持多文件类型3.7 支持多种插件3.8 支持多人协同办公3.8.1 灵活的文档权限3.8.2 不同的编辑模式3.8.3 跟踪变更3.8.4 版本历史记录3.8.5 文档比较3.8.6 高效沟通 🚀四、ONLYOFFICE AI插件快速体验4.1 登录注册4.2 新建房间4.3 文档AI助手体验4.3.1 新建文档4.3.2 安装AI插件4.3.3 创作体验 💯五、总结 📌 一、前言 随着各个公司降本增效的提倡，企业员工只有不断地学习技能，努力提升自己的能力，学会利用高效的工具提升自己的工作效率，以适应企业发展的需要。博主我作为 摸鱼高手（狗头）发掘高效的办公软件当然是拿手绝活，今天带大家一起使用ONLYOFFICE工具，体验高效办公的乐趣，废话少数速度上号：ONLYOFFICE官网（点击免费使用）
🔎 二、ONLYOFFICE介绍 ONLYOFFICE一款免费、开源的云端在线办公编辑软件平台，可以理解为升级版、功能更加强大的office 套装，支持在线编辑各种文档的工具。
官网地址：https://www.onlyoffice.com/zh/
GitHub地址：https://github.com/ONLYOFFICE
❓ 三、ONLYOFFICE的优势？ 谈起Office办公软件，我想大家肯定第一时间肯定想到Microsoft Office（微软）和WPS（金山），但是这两款软件的缺点明显。前者是付费软件，个人用户和小公司很难支付这笔费用；后者虽然是免费软件但是部分实用功能却还需要购买会员并且广告弹窗太多，总的来说这两款办公软件给我的体验都不是很好。
而今天要分享的ONLYOFFICE办公套件既拥有这两款软件的优点，而且又补足了它们的缺点，下面让我来一一介绍。
3.1 开源免费 ONLYOFFICE工具源代码已经在GitHub开源了，开源免费的意义在于促进软件的发展和普及，使得更多的人可以享受到软件带来的便利和创新。对于我们这些普通用户来说，不仅可以免费使用，还可以进行二次开发，俗话说得好：只有最合适自己的才是最好的！！！
3.2 安全第一 从GitHub上拷贝源代码部署在自己的服务器上，从而保证数据的安全。并且ONLYOFFICE支持三级加密（静态加密、传输中加密、端到端加密）、安全访问和监测工具和额外的文件权限进一步为数据的安全性保驾护航。
3.3 可自定义 ONLYOFFICE提供白标产品，支持更改 品牌LOGO，自定义编辑界面，选择显示或隐藏额外的按钮，为用户提供更好的品牌体验。
3.4 集成简单，可嵌入网页端 在官网 API 文档中，包含了详细的.Net、Java、Node.js、PHP、Python、Ruby等各种语言的接口示例教程，使用起来非常简单：
只需要几行代码就，就可以将 ONLYOFFICE 强大的文档编辑器嵌入到个人网站、应用程序或服务中去：
作为嵌入式在网页端使用效果如下所示：
3.4.1 编辑DOCX体验 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/577707994d484b92e58f5cd4db2e3f9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc811ccf9d57938ffcda6e64a267f2c/" rel="bookmark">
			【机器学习300问】11、多元线性回归模型和一元线性回归有什么不同？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的文章中，我们已经学习了一元线性回归模型，其中最关键的参数是w和b。机器学习的目的就是去得到合适w和b后能准确预测未知数据。但现实世界是复杂的，一个事情的发生绝大多数时候不会是一个原因导致。
因此多元线性回归模型区别与一元线性回归主要的不同就在变量不再是w和b两个，而可以是,,...,,多个变量。特征量变多了，很多之前学过的东西也就变复杂了，下面我来一个个讲解。
一、多元线性回归模型 （1）多维特征 多元线性回归模型在定义上与一元线性回归模型不同，还是拿房价预测为例，我们假设房价预测有如下几个特征量。如图中所示有“房屋面积”、“房间数量”、“楼层数量”、“房屋年限”这四个特征量，在加上b偏置的话，一共是五个元。
（2）向量化表示 多元线性回归模型在表示上与一元线性回归模型不同，上面提到的四个特征量，可以写成(,,,)，这明显是一个向量呀，所以可以用来表示。这些特征量对应的权重也可以同样方式写成。于是我们得到了多元线性回归模型的公式：
模型公式一元线性回归多元线性回归多元线性回归向量表示 其中的n是指特征量的个数。向量化后，一方面看上去简洁，另一方面通过使用numpy库，可以进行快速的矩阵运算。
二、多元线性回归的梯度下降算法 多元线性回归模型在梯度下降处理上与一元线性回归模型不同，在某一点处维多变多了，梯度就变成这一点的所有偏导组成的向量，因此对于MSE均方误差函数而言每一个w都要求一次偏导。
特征量 时，梯度下降算法就变成了，一次梯度更新就要
从
到
共更新n个w的加上更新b
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e4dca5665750108454897eab203902/" rel="bookmark">
			黑豹程序员-MyBatisPlus封装SQL的where条件的对象 QueryWrapper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 说明 我们使用MybatisPlus时，我们可以不直接通过SQL操作数据库，而使用面向对象的方式。
其中遇到一个问题，就是如何用面向对象的方式实现 SQL中的where条件拼接。
MybatisPlus很体贴，它提供了一个QueryWrapper，查询包装对象，来做这事。
方法 queryWrapper.lt（）——小于 queryWrapper.le（）——小于等于 queryWrapper.gt（）——大于 queryWrapper.ge（）——大于等于 queryWrapper.eq（）——等于 queryWrapper.ne（）——不等于 queryWrapper.betweeen（“age”,10,20）——age在值10到20之间 queryWrapper.notBetweeen（“age”,10,20）——age不在值10到20之间 queryWrapper.like（“属性”,“值”）——模糊查询匹配值‘%值%’ queryWrapper.notLike（“属性”,“值”）——模糊查询不匹配值‘%值%’ queryWrapper.likeLeft（“属性”,“值”）——模糊查询匹配最后一位值‘%值’ queryWrapper.likeRight（“属性”,“值”）——模糊查询匹配第一位值‘值%’ queryWrapper.isNull（）——值为空或null queryWrapper.isNotNull（）——值不为空或null queryWrapper.in（“属性”，条件，条件 ）——符合多个条件的值 queryWrapper.notIn(“属性”，条件，条件 )——不符合多个条件的值 queryWrapper.or（）——或者 queryWrapper.and（）——和 queryWrapper.orderByAsc(“属性”)——根据属性升序排序 queryWrapper.orderByDesc(“属性”)——根据属性降序排序 queryWrapper.inSql(“sql语句”)——符合sql语句的值 queryWrapper.notSql(“sql语句”)——不符合SQL语句的值 queryWrapper.esists（“SQL语句”）——查询符合SQL语句的值 queryWrapper.notEsists（“SQL语句”）——查询不符合SQL语句的值 QueryWrapper非常易用，好用。
代码案例 public R grouplist(){ QueryWrapper qw = new QueryWrapper(); qw.ne("parent_id", 0); //where parent_id != 0 去除一级节点（中心） qw.orderByAsc("sort"); //排序 return R.success(centerService.list(qw)); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76ccd38ad60c45e5dbbc3de70f8e471/" rel="bookmark">
			LINUX终端登录时提示 Login incorrect（想到了密码不正确，没想到用户名不正确……呵呵）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. LINUX终端登录时提示 Login incorrect
问题：（1）通过 VMware虚拟机软件安装的 CentOS 操作系统，在通过选择图形界面窗口 GNOME（建议选择经典模式） 进入：
此处选择经典模式是因为可以通过鼠标右键单击直接在图形窗口下进入命令终端（进入后命令终端可以很直接的看到当前登录用户）；而用户名此处也应注意下，实际有可能并不是你在安装LINUX时注册的用户名，它只是个用户详细信息。后面会详细展示区别。
（2）登录后我们通过组合键 CTRL+ALT+F2~F6(分别对应六个终端操作界面）进入命令行终端界面：
经典GNOME模式下图形窗口
CTRL+ALT+F2 进入tty2终端命令窗口
此时，看到登录不正确的提示，兄弟们一般情况下会以为是密码错了重新输入什么的，或者网上提示的说是数字键位没开什么的，有可能会有这种情况，但这种情况其实与我遇到的问题可能不一样，我是100分确认我的密码及数字键位正确（因为我专门改了密码又试，照常不对……）
处理方法：（1）GNOME经典模式下右键 选择 终端进入(从tty2返回图形窗口快捷键CTRL+ALT+F1即可：
可以看到当前终端当前登录用户的信息：
请注意看，目前登录用户名为：federer。 实际上，这个才是我们实际创建用户时的用户名，而在刚开始要求登录的界面显示的名称其实只是 用户信息，具体对应用户的用户名称而已，你可以尝试在用户设置信息中更改这个对应信息，其实也直接改的是此 federer 用户的用户描述信息而已，再注销登录后就会发现登录页面用户信息已经改变了：
实际调整是仍是此时登录用户的描述信息而已
调整后的登录页面描述信息已对应改变
(2)综上所述，实际上我们通过命令行终端登录时实际是用户名不对应，因此我们可以在图形页面的终端窗口通过命令：
cat /etc/passwd 具体查看你所注册的用户信息：
可以很清楚的看到，实际上的注册用户名，在登录时与密码匹配的，其实是第一个字段，而后面的 ROGER_FEDERER 实际只是其描述信息而已……至此，我们可再次尝试通过ttr2终端窗口进入，再次登录 ，可以看到，密码相同，只要用户名也正常，即可成功登录哦：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514bab6f20ed2cbc4ec9f15d14c059c9/" rel="bookmark">
			IDEA SpEL如何提示出方法参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想写个Spring的第三方库,想做个AOP拦截, 但是IDEA不支持SpEL表达式提示, 即便是用了@Language注解, 也不支持方法参数提示怎么办?
别慌, 现在可以使用SpEL Assistant插件来完成这个功能啦
SpEL Assistant插件支持方法参数提示, 函数返回值提示, 自定义字段, root字段配置等等功能
支持java和kotlin
来看看怎么用吧
安装插件 IDEA应用商店直接下载安装, 某些版本安装后需要重启IDEA
使用 在resources目录下新建spel-extension.json配置文件
将注解类名和注解方法名用@符号连接起来(有提示的哦)
配置自己需要的字段, 以及该注解支持的内容
然后就支持代码提示啦
附: 问题反馈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdbd1e250fbbbccb05e5b377dcc89413/" rel="bookmark">
			【音视频】如何播放rtsp视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 现阶段直播越来越流行，直播技术发展也越来越快。Webrtc和rtsp是比较火热的技术，而且应用也比较广泛。本文通过实践来展开介绍关于rtsp、webrtc的使用过程。
概要 本文重点介绍如何播放rtsp视频流，通过ffplay方式以及VLC media player的方式来播放
正文 1、构造rtsp视频流 可以参考上一篇博文:【音视频】基于webrtc协议浏览器播放rtsp
https://blog.csdn.net/HWTwilight/article/details/135653755?spm=1001.2014.3001.5501
那篇分享里面有如何推送出来rtsp视频
2、播放rtsp视频流 1）方式1：使用ffplay方式 运行命令：
ffplay -rtsp_transport tcp rtsp://localhost/test 或者ffplay rtsp://localhost/test 运行效果：
当执行完上面命令，会单独弹出一个对话框出来进行播放
2）方式2：使用VLC media player方式 打开媒体菜单：
渲染打开网络流串：
3）方式3：使用webrtc方式 可以参考上一篇博文:【音视频】基于webrtc协议浏览器播放rtsp
https://blog.csdn.net/HWTwilight/article/details/135653755?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33728b1c663f7e2027c4b3070d3eb7d5/" rel="bookmark">
			【React】脚手架创建项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 创建React项目目录结构分析了解PWA脚手架中的webpack 创建React项目 ◼ 创建React项目的命令如下：
​  注意：项目名称不能包含大写字母
​  另外还有更多创建项目的方式，可以参考GitHub的readme
命令：
create-react-app 你的项目名称
◼ 创建完成后，进入对应的目录，就可以将项目跑起来：
yarn start
目录结构分析 ◼ 我们可以通过VSCode打开项目：
test-react ├─ README.md // readme说明文档 ├─ package.json // 对整个应用程序的描述：包括应用名称、版本号、一些依赖包、以及项目的启动、打包等等（node管理项目必备文件） ├─ public │ ├─ favicon.ico // 应用程序顶部的icon图标 │ ├─ index.html // 应用的index.html入口文件 │ ├─ logo192.png // 被在manifest.json中使用 │ ├─ logo512.png // 被在manifest.json中使用 │ ├─ manifest.json // 和Web app配置相关 │ └─ robots.txt // 指定搜索引擎可以或者无法爬取哪些文件 ├─ src │ ├─ App.css // App组件相关的样式 │ ├─ App.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33728b1c663f7e2027c4b3070d3eb7d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e64a2c3f3df159467fa93034d2adba50/" rel="bookmark">
			c/c&#43;&#43;的指针函数与函数指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数 定义：
函数是数学中的一个概念，它是定义在某个数集上的一个特殊的映射关系。函数将输入值（或自变量）映射到输出值（或因变量）。函数的输入和输出可以是任何类型的数据，如数字、字符串、数组等。
函数的组成：
定义域： 函数的输入值的集合。
值域： 函数的输出值的集合。
对应关系： 输入值与输出值之间的映射关系。
函数的表示方法有多种，常用的有解析法、表格法和图象法。解析法是用数学表达式表示函数，表格法是用表格列出函数的输入值和对应的输出值，图象法则是在坐标系中画出函数的图像。
函数的应用：
函数的应用非常广泛，它可以用于描述各种自然现象和工程问题，如物理、化学、生物学、经济学等领域。在计算机科学中，函数也广泛应用于编程语言和算法设计中。
计算机领域里的函数定义：
在计算机领域，函数的概念通常指的是一种将输入转换为输出的计算方法或操作。它可以是一段代码的执行，可以接收输入并产生输出。这种计算过程可以根据输入的参数或条件进行变化，并产生不同的结果。
计算机领域中的函数通常可以分为两类：系统函数和用户自定义函数。系统函数是由操作系统或编程语言提供的标准函数，用于执行一些常见的操作，如数学运算、字符串处理、文件操作等。用户自定义函数则是由程序员根据特定需求编写的函数，用于实现特定的逻辑或算法。
在编程语言中，函数通常被定义为一个独立的代码块，可以重复使用和调用。函数的定义包括函数的名称、输入参数、返回值和函数体。函数体是实现特定功能的代码块，可以包含逻辑判断、循环、条件语句等。
函数在计算机科学中具有重要的作用，它们可以使代码更加模块化、可重用和可维护。通过将复杂的程序分解为一系列的函数，可以使程序的结构更加清晰，易于理解和维护。同时，函数还可以提高程序的效率和可靠性，因为相同的函数可以在不同的程序中重复使用，避免了重复编写代码和可能出现的错误。
——文心一言
指针 指针定义：
指针是计算机编程中一种特殊类型的变量，它存储了另一个变量的内存地址。通过使用指针，可以直接访问和修改变量的内存地址，从而实现更加灵活和高效的数据处理。
指针的声明和初始化通常需要使用星号（*）操作符。例如，如果有一个整数变量x，可以声明一个指向x的指针变量p，并将其初始化为x的地址，如下所示：
int x = 10; int *p = &amp;x; 在这个例子中，变量p是一个指向整数类型的指针，它存储了变量x的内存地址。通过指针p，可以直接访问和修改变量x的值。例如，*p表示指针p所指向的变量的值，而p++则表示将指针p向后移动一个整数大小的内存地址。
指针的应用：
指针在计算机科学中具有广泛的应用，尤其是在底层编程、数据结构、算法等领域。通过使用指针，可以实现动态内存分配、函数参数传递、数据结构操作等复杂的数据处理任务。然而，也需要注意指针使用的安全性和正确性，以避免出现内存泄漏、野指针等问题。
——文心一言
指针函数 定义：
指针函数是指带指针的函数，本质上是一个函数；函数的返回类型是某一类型的指针。
作用：
指针函数可以用来操作内存地址，对数组内数据进行操作。
一般形式：
类型描述通用&lt;数据类型&gt; *&lt;函数名&gt;(&lt;函数参数列表&gt;)写法1int *pfun(int, int);写法2int * func(int, int);写法3int* func(int, int); #比较常用 取值运算符*的优先级低于圆括号，所以pfun首先和后面圆括号结合。
举例：
#include &lt;iostream&gt; using namespace std; int* find_max(int arr[], int size) { int* max_ptr = &amp;arr[0]; // 假设数组的第一个元素是最大的 for (int i = 1; i &lt; size; i++) { // 如果当前元素比最大值还大 if (*max_ptr &lt; arr[i]) { max_ptr = &amp;arr[i]; // 更新最大值的指针 } } return max_ptr; // 返回最大值的指针 } int main() { int arr[] = { 3, 7, 2, 8, 1, 9, 5, 6, 4 }; int size = sizeof(arr) / sizeof(arr[0]); // 计算数组的长度 int* max_value_ptr = find_max(arr, size); // 调用指针函数 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e64a2c3f3df159467fa93034d2adba50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6bfa886de66aef6bed209dcefa7abc8/" rel="bookmark">
			微信小程序的springboot高校新生报道管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考虑到实际生活中在毕业论文选题管理方面的需要以及对该系统认真的分析,将小程序权限按管理员和用户这两类涉及用户划分。
(a) 管理员；管理员使用本系统涉到的功能主要有系统首页、个人中心、学生管理、指导教师管理、课题信息管理、选题信息管理、论文信息管理、疑问留言管理、疑惑解答管理、学生成绩管理、指导记录管理、答辩名单管理、系统管理等功能。管理员用例图如图3-1所示。
图3-1　管理员用例图
(b) 用户；用户进入小程序可以实现首页、课题信息、答辩名单、我的等，在我的页面可以对专家预约、我的收藏管理等功能进行操作。用户用例图如图3-2所示。
语言：java+python+nodejs+php+nodejs均支持
运行软件:idea/eclipse/vscode/pycharm/wamp
框架支持:springboot/Ssm/vue/django/thinkphp都有
毕业论文选题管理方面的任务繁琐,以至于每年都在毕业论文选题管理这方面投入较多的精力却效果甚微,毕业论文选题管理的目标就是为了能够缓解毕业论文选题管理面临的压力,让毕业论文选题管理方面的工作变得更加高效准确。
本项目在开发和设计过程中涉及到原理和技术有: B/S、java技术、ssm框架、MySQL数据库等等；
第一章 绪论；剖析项目背景,说明研究的内容。
第二章 开发技。系统主要使用了java技术，ssm框架、b/s模式和myspl数据库，并对此做了介绍。
第三章 系统分析；包罗了系统总体结构、对系统的性能、功能、流程图进行了分析。
第四章 系统设计；对软件功能模块和数据库进行详细设计。
第五章 系统总体设计；对毕业论文选题管理员和用户的功能进行描述，
第六章 对系统进行测试，
第七章 总结心得；在论文最后结束章节总结了开发这个系统和撰写论文时候自己的总结、感想,包括致谢。
目录
1绪论 4
1.1项目研究的背景 4
1.2开发意义 4
1.3项目研究内容与结构 4
2开发技术介绍 5
2.1B/S架构 5
2.2 Android平台 5
2.3 Java语言简介 5
2.4 MySQL 介绍 6
2.5 MySQL环境配置 8
2.6 SSM框架 8
3系统分析 9
3.1可行性分析 9
3.1.1技术可行性 9
3.1.2经济可行性 9
3.1.3操作可行性 9
3.2 小程序性能需求分析 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6bfa886de66aef6bed209dcefa7abc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb86a68e625cf031ccac4f0db1aed13a/" rel="bookmark">
			Qt/QML编程之路：QWidget和QOBJECT的不同之处(37)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始使用Qt的工程师，要有个思想准备，标准的Application或者说Windows窗口类的工程和QML是不同的，很多控件在QML里面是不支持的。要了解QObject、QWidget、QMainWindow几个的不同。为何我会遇到这个问题呢？因为在做OpenGL想实现3D效果的时候，发现OpenGL的示例是基于QWidget的，而想在QML下实现遇到了困难，其基于QGLWidget类都是继承自QWidget。
几个基本概念：
QObject是Qt中最基本的类，所有Qt中的对象都从该基类派生而来。有个标记，就是每次写带信号槽的类必须带。它是最顶级的，关键也是Qt元对象系统的重要概念，或者说很多QML中的类继承自它，继承了它就可以利用Qt信号槽、事件处理机制和属性等功能。
QWidget是Qt中所有用户界面类的基类，注意是基类，它提供了空白窗口基本部件如菜单栏、工具栏、状态栏等。提供基本的窗口功能函数和信号，包括绘制、布局、尺寸调整、事件处理等。所以3D绘制是在窗口上绘制的，继承于它，而它属于Windows应用，不能用在QML中。
进一步就涉及到非QUI的Application:
QCoreApplication用于non-GUI的应用程序（不依赖QtGui库）
QApplication用于包含GUI的应用程序（用到QtGui库）。
继承关系：
QApplication-&gt;QGuiApplication-&gt;QCoreApplication-&gt;QObject。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a850b7263bdcd89bd4d8174eee67ba57/" rel="bookmark">
			mall整合Redis实现缓存功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mall整合Redis实现缓存功能 本文主要讲解mall整合Redis的过程，以短信验证码的存储验证为例。
Redis的安装和启动 Redis是用C语言开发的一个高性能键值对数据库，可用于数据缓存，主要用于处理大量数据的高访问负载。
下载Redis,下载地址：github.com/MicrosoftAr… 下载完后解压到指定目录 在当前地址栏输入cmd后，执行redis的启动命令：redis-server.exe redis.windows.conf 整合Redis 添加项目依赖 在pom.xml中新增Redis相关依赖
复制代码&lt;!--redis依赖配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 修改SpringBoot配置文件 在application.yml中添加Redis的配置及Redis中自定义key的配置。
在spring节点下添加Redis的配置 复制代码 redis: host: localhost # Redis服务器地址 database: 0 # Redis数据库索引（默认为0） port: 6379 # Redis服务器连接端口 password: # Redis服务器连接密码（默认为空） jedis: pool: max-active: 8 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 8 # 连接池中的最大空闲连接 min-idle: 0 # 连接池中的最小空闲连接 timeout: 3000ms # 连接超时时间（毫秒） 在根节点下添加Redis自定义key的配置 复制代码# 自定义redis key redis: key: prefix: authCode: "portal:authCode:" expire: authCode: 120 # 验证码超期时间 添加RedisService接口用于定义一些常用Redis操作 复制代码package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a850b7263bdcd89bd4d8174eee67ba57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e965b0470aa8ce279ddc469068ec9b1/" rel="bookmark">
			把前端传来的数据导入到excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传来的数据 [ {"nameFirst": "test1", "nameSecond": "test1", "nameThird": "test1"}, {"nameFirst": "test2", "nameSecond": "test2", "nameThird": "test2"}]
代码 controller @GetMapping("/excel/fail") @Operation(summary = "把失败数据打印成excel导出") public void exportFailedData(@RequestParam String jsonData, HttpServletResponse response) throws IOException { ObjectMapper objectMapper = new ObjectMapper(); List&lt;Map&lt;String, String&gt;&gt; list = objectMapper.readValue(jsonData, new TypeReference&lt;List&lt;Map&lt;String, String&gt;&gt;&gt;() {}); technologyCategoryService.exportFailedData(list, response); } service public void exportFailedData(List&lt;Map&lt;String, String&gt;&gt; list, HttpServletResponse response) throws IOException { Workbook workbook = new XSSFWorkbook(); // 获取Sheet对象 Sheet sheet = workbook.createSheet("失败数据"); // 只有一个Sheet // 设置标题行样式 Row headerRow = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e965b0470aa8ce279ddc469068ec9b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4790c12f965346da1b15fb4ebb4fc551/" rel="bookmark">
			Elastic 8.12：AI Assistant for Observability 正式发布，更新至 Apache Lucene 9.9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：来自 Elastic Brian Bergholm
今天，我们很高兴地宣布 Elastic® 8.12 全面上市。
有哪些新的功能？ 8.12 版本的两个最重要的组成部分包括 Elastic AI Assistant for Observability 的 正式发布版 和 Apache Lucene 9.9 的更新（有史以来最快的版本），其中 Elastic 为服务客户用例而贡献了关键创新。 解决方案的其他亮点包括以下内容。
Elastic Search 帮助开发人员实现现代搜索和发现体验。
了解 8.12 如何利用 Apache Lucene 9.9、新的机器学习功能、连接器的正式发布（例如 Azure Blob 存储、Google 云存储、Amazon S3 等）、简化的开发人员体验以及 Elastic Search 亮点博客或 在 8.12 发行说明中。 Elastic Observability 将指标、日志和跟踪转化为可操作的 IT 见解，以统一整个数字生态系统的可观察性。
在 Elastic Observability 亮点博客或 8.12 发行说明中了解有关 Elastic AI Assistant for Observability 的正式发布，服务级别目标 (SLO) 的正式发布、基于 OpenTelemetry 的移动 APM 支持等更多信息。 Elastic Security 统一了 SIEM、端点安全和云安全，以检测、调查和响应云规模的威胁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4790c12f965346da1b15fb4ebb4fc551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa70e67c5368465656205ae8553869b/" rel="bookmark">
			mall数据库表结构概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mall数据库表结构概览 SpringBoot实战电商项目mall（18k+star）地址：github.com/macrozheng/…
简介 mall是一套电商系统，后台系统主要包括商品管理、订单管理、营销管理（运营管理+促销管理）、内容管理、用户管理等模块，本文主要对这些模块的数据库表结构及功能做大概的介绍。
商品管理 数据库表结构 功能结构 订单管理 数据库表结构 功能结构 营销管理 数据库表结构 功能结构 内容管理 数据库表结构 功能结构 用户管理 数据库表结构 功能结构 注意：部分功能暂未实现，只是对表结构进行了设计，商品管理、订单管理、营销管理大部分功能均已实现。
相关资料 PowerDesigner数据库设计文件 商品管理：github.com/macrozheng/…订单管理：github.com/macrozheng/…营销管理：github.com/macrozheng/…内容管理：github.com/macrozheng/…用户管理：github.com/macrozheng/… MindMaster功能思维导图 商品管理：github.com/macrozheng/…订单管理：github.com/macrozheng/…营销管理：github.com/macrozheng/…内容管理：github.com/macrozheng/…用户管理：github.com/macrozheng/… 使用到的工具 PowerDesigner:powerdesigner.de/MindMaster:www.edrawsoft.cn/mindmaster 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51cb9ec29a4d55ad3b6465a1bf7da2d4/" rel="bookmark">
			开发安全之：Path Manipulation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Overview
攻击者可以控制 file_get_contents() 文件系统路径参数，借此访问或修改原本受保护的文件。
Details
当满足以下两个条件时，就会产生 path manipulation 错误：
1.攻击者能够指定某一文件系统操作中所使用的路径。
2. 攻击者可以通过指定特定资源来获取某种权限，而这种权限在一般情况下是不可能获得的。 例如，在某一程序中，攻击者可以获得特定的权限，以重写指定的文件或是在其控制的配置环境下运行程序。 在这种情况下，攻击者可以指定通过 mysql_query() 进入程序的值，这一数值用于通过 file_get_contents() 访问文件系统资源。
例 1： 下面的代码使用来自于 HTTP 请求的输入来创建一个文件名。程序员没有考虑到攻击者可能使用像 "../../tomcat/conf/server.xml" 一样的文件名，从而导致应用程序删除它自己的配置文件。 $rName = $_GET['reportName'];
$rFile = fopen("/usr/local/apfr/reports/" . rName,"a+");
unlink($rFile);
示例 2：以下代码使用来自于配置文件的输入来决定打开哪个文件，并返回给用户。如果程序以足够的权限运行，且恶意用户能够篡改配置文件，那么他们可以通过程序读取系统中以扩展名 .txt 结尾的任何文件。
$filename = $CONFIG_TXT['sub'] . ".txt";
$handle = fopen($filename,"r");
$amt = fread($handle, filesize($filename));
echo $amt; ...
Recommendations
防止 Path Manipulation 的最佳方法是采用一些间接手段：创建一个必须由用户选择的合法值的列表。通过这种方法，就不能直接使用用户提供的输入来指定资源名称。 但在某些情况下，这种方法并不可行，因为这样一份合法资源名的列表过于庞大，维护难度过大。因此，在这种情况下，程序员通常会采用执行拒绝列表的办法。在输入之前，拒绝列表会有选择地拒绝或避免潜在的危险字符。但是，任何这样一个列表都不可能是完整的，而且将随着时间的推移而过时。更好的方法是创建一个字符列表，允许其中的字符出现在资源名称中，且只接受完全由这些被认可的字符组成的输入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8539990480d09278a129a26896bf293b/" rel="bookmark">
			冒泡排序-BubbleSort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基本思路 从数组的左边开始，比较两个元素的大小，当左边大于右边时，更换左右元素位置，否则不改变；接着向右移动一步，比较第二个元素和第三个元素的大小，重复上述操作，直到最后一个元素，此时，最大的元素就已经移动到了最右边；然后进行下一轮比较，但是下一轮比较时，不需要比较最后一个元素了。
2、代码实现 public class BubbleSort { public static void main(String[] args) { int[] arr = new int[]{33, 24, 4, 28, 95, 63, 86, 77}; bubbleSort(arr); for (int i = 0; i &lt; arr.length; i++){ System.out.print(arr[i] + " "); } } /** * 冒泡排序 * * @param arr 需要排序的整数数组 */ public static void bubbleSort(int[] arr) { int length = arr.length; for (int i = length -1; i &gt; 0; i-- ){ for (int j = 0; j &lt; i; j++){ if (arr[j] &gt; arr[j+1]){ swap(j,j+1,arr); } } } } private static void swap(int i, int i1, int[] arr) { int temp = arr[i]; arr[i] = arr[i1]; arr[i1] = temp; } } 双层循环，时间复杂度为O(N^2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8539990480d09278a129a26896bf293b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67de8bcf835a261f43668ed9d592241c/" rel="bookmark">
			鸿蒙开发语言ArkTS--Ability中的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙开发语言ArkTS–Ability中的生命周期 在ArkTS语言中，这是一个在ArkTS中定义Ability生命周期的示例。
Ability的生命周期：
onCreate(want, launchParam)：在UI创建后执行的函数。在这个阶段，您可以执行初始化操作，设置初始状态，并且可以注册监听器等。
onDestroy()：在UI销毁后执行的函数。在这个阶段，您可以执行一些清理操作，释放资源等。
onWindowStageCreate(windowStage: window.WindowStage)：在主窗口创建后执行的函数。在这个阶段，您可以设置主页面，并且可以进行一些UI相关的操作。
onWindowStageDestroy()：在主窗口销毁后执行的函数。在这个阶段，您可以释放与UI相关的资源。
onForeground()：在Ability进入前台后执行的函数。在这个阶段，您可以执行一些与前台显示相关的操作。
onBackground()：在Ability切换到后台后执行的函数。在这个阶段，您可以执行一些与后台运行相关的操作。
总的来说，这些函数定义了Ability的整个生命周期，从创建到销毁，以及前台和后台运行时的状态变化。我们开发人员可以在这些函数中编写相应的逻辑，以实现对应生命周期阶段的操作。
整体EntryAbility.ets的代码如下：
/** * Ability的生命周期 */ export default class EntryAbility extends UIAbility { /** * UI创建后执行 * @param want * @param launchParam */ onCreate(want, launchParam) { hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate'); } /** * UI销毁后执行 */ onDestroy() { hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy'); } /** * 主窗口创建执行 * @param windowStage */ onWindowStageCreate(windowStage: window.WindowStage) { // Main window is created, set main page for this ability hilog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67de8bcf835a261f43668ed9d592241c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f57a8311b700fe13e70d3de258119c45/" rel="bookmark">
			docker 操作所有容器的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 列出所有的容器 ID docker ps -aq 停止所有的容器 docker stop $(docker ps -aq) 删除所有的容器 docker stop $(docker ps -aq) 删除所有的镜像 docker image prune --force --all 或者
docker image prune -f -a 删除所有停止的容器 docker container prune -f 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b153966de8492ad50728bbf6138be2dd/" rel="bookmark">
			el-table固定列偶发拖拽出现边框消失的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-table固定列偶发拖拽出现边框消失的问题 问题复现 解决方法 // 自行把::v-deep 改成自己语言类型 ::v-deep .el-table__fixed-right { top: 0px; left: auto; right: 0px; border-left: 1px solid #ebeef5; box-sizing: content-box; } 如果有用，请给我点赞收藏，我会很开心，谢谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f790e8ea048f21d97f4cb4a0ce9c571b/" rel="bookmark">
			爬虫案例—爬取ChinaUnix.net论坛板块标题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫案例—爬取ChinaUnix.net论坛板块标题 ChinaUnix.net论坛网址：http://bbs.chinaunix.net
目标：抓取各个板块的标题和内容的标题
网站截图：
利用requests和xpath实现目标。源码如下：
import requests from lxml import etree headers = { 'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',} url = 'http://bbs.chinaunix.net' res = requests.get(url, headers=headers) html = res.text tree = etree.HTML(html) div_lst = tree.xpath('//div[@class="mn"]/div/table') for div in div_lst[:6]: print('板块名称：', div.xpath('./tbody[1]/tr/td//h2/a/text()')[0]) for tr in div.xpath('./tbody[2]/tr'): for td in tr.xpath('./td'): # if td.xpath('./table'): # print(td.xpath('./table/tr/td[2]/a/text()')) table_lst = td.xpath('./table') if table_lst: print(td.xpath('./table/tr/td[2]/a/text()')[0],end='\t') print('') print('=' * 50) 运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f790e8ea048f21d97f4cb4a0ce9c571b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b3e1cdfd6947302206b8df91416be6/" rel="bookmark">
			【教3妹学编程-算法题】检查按位或是否存在尾随零
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3妹：呜呜，烦死了， 脸上长了一个痘
2哥 : 不要在意这些细节嘛，不用管它，过两天自然不就好了。
3妹：切，你不懂，影响这两天的心情哇。
2哥 : 我看你是不急着找工作了啊， 工作那么辛苦，哪还有时间想这些啊。
3妹：说到找工作，我又要去刷题了。
2哥：我给你出一道关于美丽的题吧，让你的心情美丽美丽~
题目： 给你一个 正整数 数组 nums 。
你需要检查是否可以从数组中选出 两个或更多 元素，满足这些元素的按位或运算（ OR）结果的二进制表示中 至少 存在一个尾随零。
例如，数字 5 的二进制表示是 “101”，不存在尾随零，而数字 4 的二进制表示是 “100”，存在两个尾随零。
如果可以选择两个或更多元素，其按位或运算结果存在尾随零，返回 true；否则，返回 false 。
示例 1：
输入：nums = [1,2,3,4,5]
输出：true
解释：如果选择元素 2 和 4，按位或运算结果是 6，二进制表示为 “110” ，存在一个尾随零。
示例 2：
输入：nums = [2,4,8,16]
输出：true
解释：如果选择元素 2 和 4，按位或运算结果是 6，二进制表示为 “110”，存在一个尾随零。
其他按位或运算结果存在尾随零的可能选择方案包括：(2, 8), (2, 16), (4, 8), (4, 16), (8, 16), (2, 4, 8), (2, 4, 16), (2, 8, 16), (4, 8, 16), 以及 (2, 4, 8, 16) 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93b3e1cdfd6947302206b8df91416be6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6067ff02f0c7acab0a791f5373f6d782/" rel="bookmark">
			通知：2024年度公开招募高考志愿规划师，零基础可学，报名费全免！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024高考报考指导师报名公告 高报师[2024]
据智联招聘发布数据，54.6%的受访人认为自己高考志愿填报不成功，绝大多数考生和家长，都是毫无方向，瞎填乱填。
瞎填乱报导致的高分低就、同分不同命、毕业即失业、就业难等问题，引起广大考生和家长关注，高考报考指导成为“刚需”。
2024年高考报名人数突破1353万，而目前我国专业高考报考指导师，缺口达30万人，人才需求急剧升高！
为了补充高考报考指导行业人才缺口，现参照《高考改革实施方案》的指导意见，面向社会公开招募，免费开展『高考报考指导师培训』。获得证书后利于转岗、职场提升、个人发展、提高就业率，促进地方经济复苏。
2024年高考报考指导师
↓ 指 定 报 名 通 道↓
👆长按扫码免费报名 报满即止👆
前100名免费送海量学习资料+免费咨询各地政策
高考报考指导师培训说明
1.项目情况
报名项目：高考报考指导师
适合人群：30-60岁
学历要求：本次培训不限专业及学历
培训方式：线上直播公开课，在家就能学
教学内容：高考报考理论知识+鲜活实操案例
学习时间：共3天（每晚7：15），3天费用全免
就业方向：培训讲师、教育系统、社区单位、开设个人报考咨询室等。
待遇参考：一对一高考方案定制、长期服务均可，收入可观（以当地市场为准）
2024年高考报考指导师
↓ 指 定 报 名 通 道↓
👆长按扫码免费报名 报满即止👆
前100名免费送海量学习资料+免费咨询各地政策
2.报考优势
1.政策推广初期，特批降低考试难度。
本批考取证书只需参加1门考试，题型仅为单选题和多选题，通过率达90%以上。后续批次逐渐调整为要求本科学历，拿证需参与线上答辩。
2.一站式服务，通过考核后，平台颁发聘书，有机会分配咨询服务，线上就可完成，平台全程支持。
3.证书终身有效，取证后有机会直接聘用成为平台咨询师，并且有机会免费入驻志愿填报平台。
证书没有个人报考通道，需要报名培训后完成学习考核，颁发《高考报考指导师证书》
（注：以上为证书样式，最终以实际为准）
证书可作为上岗就业、用人单位招收录用人员的重要参考凭证（无经验者提供一个入门的基础指引，可作为主业或拓展第二职业）
2024年高考报考指导师
↓ 指 定 报 名 通 道↓
👆长按扫码免费报名 报满即止👆
前100名免费送海量学习资料+免费咨询各地政策
高考报考指导师行业前景
1.什么是高考报考指导师？
UAP 高考报考指导师(University Application Planner)是国内首个“高考报考指导师”培训体系，旨在为国家培养理论扎实、操作能力强的高考志愿填报咨询专业人才。
新高考背景下，渴望付费咨询的考生家长逐年增加，高考报考指导师已经成为炙手可热的人才。
2.国家政策扶持
高考是人生的重要分水岭，志愿填报是一生的关键抉择。
“新高考”形势下，《国家高考改革实施方案》明确提出：“重视高考志愿填报咨询服务工作的政策，扶持行业人才发展。”
教育部门在《2023年高考志愿填报十问十答》也指出，鼓励考生向有关院校和机构进行志愿填报咨询。进而也增加了院校机构对高考报考指导师的用人需求。
3.收入不错，就业也相对广
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6067ff02f0c7acab0a791f5373f6d782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0dc61d59fa686c1ef279a13e0d1dcd6/" rel="bookmark">
			绝地求生：周三不停机维护: 修复BUG，“红面具”天使与恶魔套装上线!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨，我是闲游盒~
本周三没有停机维护，10点退出游戏重新获取一下热更新即可直接进入游戏游玩啦~
*本周不停机维护修复几个问题 *
维护包括以下修复:
修复了与血猎人套装相关的问题修复了烟雾弹的烟雾高度比以前更高的问题修复了在某些游戏模式下，很多人从同一个起点开始的问题 (怪不得素质广场人明显变多) 此外，在UTC 00:00将有Vivox维护，维护时间最长可达1小时，在此期间，游戏内语音聊天可能会出现问题。
*除了修复BUG，新的皮肤套装也即将上线
天使与恶魔套装，将在1月17日上午10点上线 (红面具可别捆绑销售啊)
这是新年版本前最后一次皮肤更新了，27.2版本也是个小更新 (皮肤方面)
销售时间
北京时间: 2024年1月17日上午10点-2024年10月10日上午10点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce178793c1112c78c83c9966b2fa244/" rel="bookmark">
			Pytorch 对比TensorFlow 学习：Day 17-18: 循环神经网络（RNN）和LSTM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Day 17-18: 循环神经网络（RNN）和LSTM
在这两天的学习中，我专注于理解循环神经网络（RNN）和长短期记忆网络（LSTM）的基本概念，并学习了它们在处理序列数据时的应用。
1.RNN和LSTM基础：
RNN：了解了RNN是如何处理序列数据的，特别是它的循环结构可以用于处理时间序列或连续数据。
LSTM：学习了LSTM作为RNN的一种改进，它通过引入遗忘门、输入门和输出门解决了RNN的长期依赖问题。
2.实践应用：
使用这些概念来处理一个简单的序列数据任务，例如时间序列预测或文本数据处理。
构建一个包含RNN或LSTM层的神经网络模型。
3.PyTorch和TensorFlow实现：
在PyTorch中，使用nn.RNN或nn.LSTM来实现这些网络。
在TensorFlow中，使用Keras的SimpleRNN或LSTM层。
PyTorch代码示例：
import torch
import torch.nn as nn
import torch.optim as optim
class SimpleLSTM(nn.Module):#定义一个简单的LSTM模型
def init(self, input_size, hidden_size, num_classes):
super(SimpleLSTM, self).init()
self.lstm = nn.LSTM(input_size, hidden_size, batch_first=True)
self.fc = nn.Linear(hidden_size, num_classes)
def forward(self, x):
# 初始隐藏状态和细胞状态
h0 = torch.zeros(1, x.size(0), hidden_size)
c0 = torch.zeros(1, x.size(0), hidden_size)
# 前向传播
out, _ = self.lstm(x, (h0, c0))
out = out[:, -1, :]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ce178793c1112c78c83c9966b2fa244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5531a8f6040a9cc7bdf9c2d151463cab/" rel="bookmark">
			Golang通过Gorm操作Mysql时遇到的datetime时区问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情景描述 golang使用Gorm操作MySQL，MySQL中数据类型是datetime，Golang中用的是time.now。
但是会导致存储的时间与北京时间有8h误差， 显然是没有初始化时区导致。
问题修复 初始化设置时区 参考我自己之前写过的一篇总结——Mysql中多种日期类型——DATETIME、TIMESTAMP、TIME、YEAR、DATE的区分
datetime是给什么就存什么，timestamp则是转换为UTC+8才存。
所以我认为应该是在Golang中写一个时区初始化即可。
于是我在main函数开头加上了
time.LoadLocation("Asia/Shanghai") bug依然没有解决。
我在我的存储部分，进行输出测试。
func (l *Like) LikeOne(ctx context.Context, uid, bid int) (repo.LikeInformation, error) { likeRes := repo.LikeInformation{ CreatedAt: time.Now(), BlogID: bid, UserID: uid, } fmt.Println(time.Now()) fmt.Println(likeRes.CreatedAt) err := l.db.Table(define.TableLike).Create(&amp;likeRes).Error if err != nil { return repo.LikeInformation{}, err } return likeRes, nil } 发现添加时区是生效的。
问题解决 通过参阅：
https://www.jianshu.com/p/030b880ecc5e
发现问题可能是出现在我的db连接时。
我仅仅是初始化了本地的时区，但是云服务器的数据库建立连接时，并没有设置时区。因此导致问题。
const dsn = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;loc=Local" func NewDbClient() (*gorm.DB, error) { db, err := gorm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5531a8f6040a9cc7bdf9c2d151463cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78e9e4eff07e47898b0a400c53ff055/" rel="bookmark">
			013-Vue-尚硅谷2022：前端框架概述，准备环境、绑定文本 、单项/双向/按条件绑定属性 、遍历、点击事件：字符串反转 鼠标移动、监听属性、练习、生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端框架概述 1、常见的js框架 说明：js框架底层封装的都是js。
2、常见的ui框架 概述：
ui是用户界面的英文简称，那么ui框架又是什么呢?框架又可以理解为模板，ui框架也就是ui模板。这和编程里的封装有些类似，就是说一些ui设计的常用效果已经被别人封装成了ui框架，你想实现哪个效果只要直接调用就行，不需要太纠结于底层实现。
第一节 Vue.js简介 1、框架 任何编程语言在最初的时候都是没有框架的，后来随着在实际开发过程中不断总结『经验』，积累『最佳实践』，慢慢的人们发现很多『特定场景』下的『特定问题』总是可以『套用固定解决方案』。
于是有人把成熟的『固定解决方案』收集起来，整合在一起，就成了『框架』。
在使用框架的过程中，我们往往只需要告诉框架『做什么（声明）』，而不需要关心框架『怎么做（编程）』。
对于Java程序来说，我们使用框架就是导入那些封装了『固定解决方案』的jar包，然后通过『配置文件』告诉框架做什么，就能够大大简化编码，提高开发效率。我们使用过的junit其实就是一款单元测试框架。
而对于JavaScript程序来说，我们使用框架就是导入那些封装了『固定解决方案』的『js文件』，然后在框架的基础上编码。
用洗衣服来类比框架：
典型应用场景：洗衣服
输入数据：衣服、洗衣液、水
不使用框架：手洗
使用框架：使用洗衣机，对人来说，只需要按键，具体操作是洗衣机完成的。人只是告诉洗衣机做什么，具体的操作是洗衣机完成的。
实际开发中使用框架时，我们也主要是告诉框架要做什么，具体操作是框架完成的。
2、Vue.js 2.1、Vue.js的作者 在为AngularJS工作之后，Vue的作者尤雨溪开发了Vue.js。他声称自己的思路是提取Angular中自己喜欢的部分，构建出一款相当轻量的框架。
Vue最早发布于2014年2月。作者在Hacker News、Echo JS与 Reddit的JavaScript版块发布了最早的版本。一天之内，Vue 就登上了这三个网站的首页。
Vue是Github上最受欢迎的开源项目之一。同时，在JavaScript框架/函数库中， Vue所获得的星标数已超过React，并高于Backbone.js、Angular 2、jQuery等项目。
2.2、Vue.js的官网介绍 Vue.js官网网址：https://cn.vuejs.org/
Vue (读音 /vjuː/，类似于view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链 以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。（当前2023最新版本是3.0，市面上用的最多的还是2.xx，所以此处学习以2.xx为例）
总结：
Vue是一套前端框架，免除原生JavaScript（js）中的DOM操作，简化书写。基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上。单向展示：只能把模型中的数据取出来放到视图中单向展示 缺点1：只能单方向的把数据从模型中取出放到视图层展示缺点2：只能实现展示而不是绑定（之前使用js或jquery需要先获取Dom对象，在通过对象获取属性值来展示数据，一旦模型数据发生改变那么js代码也会发生变化。现在使用Vue可以实现绑定，将来模型数据发生变化视图中的数据也会跟着变化，不需要修改任何代码） 双向绑定：通过View提供的一个对象(ViewModel)将View(html元素)和Model(数据)实现双向绑定，对象(ViewModel)是框架提供的功能不需要我们自己实现。 即：模型变了视图跟着变，视图变了模型跟着变。而且这些变化都是自动完成的。 第二节 准备Vue.js环境 1、开发中的最佳实践 『最佳实践』是实际开发中，针对特定问题提炼出来的最好的解决方案。把『最佳实践』抽取出来，封装到各自编程语言的程序包中，就是框架的基础。
Java语言的程序包：jar包JavaScript语言的程序包：外部js文件 对于Java程序来说，框架=jar包+配置文件。对于Vue来说，导入Vue的外部js文件就能够使用Vue框架了。
2、Vue框架的js文件获取 官网提供的下载地:1：https://cdn.jsdelivr.net/npm/vue/dist/vue.js
说明：这种方式直接打开的是vue.js里面的内容，可以先创建一个vue.js文件，之后把内容复制到这个创建的文件中。
官网提供的下载地址2：https://v2.cn.vuejs.org/v2/guide/installation.html
分别点击下载：
3、本地创建vue.js文件 说明1：使用HBuilderX编写vue.js
第一步：在HBuilderX中创建工程
第二步：在工程目录下创建script目录用来存放vue.js文件
第三步：创建空vue.js文件
第四步：将官网提供的vue.js文件的内容复制粘贴到本地vue.js文件中
说明2：使用idea编写vue.js
第一步：在idea中创建java-web工程
第二步：在web目录下创建script目录用来存放vue.js文件第三步：将官网提供的vue.js文件复制粘贴到本地的script目录中
4、创建HTML文档并引入vue.js &lt;!DOCTYPE html&gt; &lt;html lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78e9e4eff07e47898b0a400c53ff055/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/15/">«</a>
	<span class="pagination__item pagination__item--current">16/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/17/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>