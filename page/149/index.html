<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c4b7e0a3361d3f910e97a1fce95fa85/" rel="bookmark">
			postgrepsql 安装失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows环境 postgrepsql 安装失败“Failed to load sQL modules into the database cluster.” 注：这个错误会导致数据库无法创建，所以不能忽略，我忽略安装过几次发现数据库都无法创建。查看服务列表 找不到 postgresql的进程。 然后卸载时也报错了(大体意思没有这个服务卸载失败)
尝试过换个普通文件作为安装目录也是不行；
然后以管理员身份运行也不行
最终用以下方法解决：
解决方案: 1.创建windows用户保证与pg库的超级管理员用户名一致 ”postgres“并且授予管理员权限
在这里插入图片描述
输入账号密码即可完成创建，创建后更改为 管理员权限 （默认为普通管理员）
2.给创建的用户设置 postgresql安装目录权限
在安装目录文件夹 右击 -》属性-》安全-》编辑-》添加-》输入对象名称来选择的输入框中 输入”postgres“ -》检查名称 -》确定 完成权限添加
3.重启电脑 以管理员身份运行 安装postgresql 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06c11d5b4cd9bb8cfdbbf41541b5215/" rel="bookmark">
			新手入坑：strapi官网教程的简单示例学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于strapi 前端仔，来，看这里，用strapi，定制你的api。一个字，香。
安装 npm i strapi@beta -g strapi new str-project 可能会比较慢
开始 npm run develop 运行完会新打开一个登录页，填入信息即可。
开局一个工作台
简单实现自己的api demo 还是官网的demo简单直接，下面是个人翻译
步骤1安装，步骤2的创建管理员账户都已经实现，下面从步骤3开始
3：创建一个叫 restaurant 的内容类型
点击左侧边栏额外功能-内容类型新建页，新建一个内容类型
点击新建内容类型输入 restaurant，点击继续选择文本字段在名称输入框里输入 name点击右侧的进阶设置，勾选 必填 和 值唯一点击新增另一个字段选择 富文本 字段在名称输入框里输入 description点击完成右上角点保存 4：创建一个叫 Category 的内容类型
还是在左侧边栏额外功能-内容类型新建页，新建一个内容类型
点击新建内容类型输入 category ，点击继续选择文本字段在名称输入框里输入 name点击右侧的进阶设置，勾选 必填 和 值唯一点击新增另一个字段选择 关联 字段
在右侧的 Category 下拉框勾选 Restaurant，关联起来在中间的icon里，选择 多对多（不用我多解释吧？）
点击完成右上角点保存 5：在 Restaurant 内容类型中新建一个 餐馆 数据
在左侧边栏集合-类型，选择 Restaurant，新建一篇文章
点击新建按钮，在 name 字段中输入 “肯德基”，在 Description 字段中输入"肯德基KFC坚持“立足中国、融入生活”,打造新快餐,提供早餐,午餐,下午茶,晚餐,夜宵和甜品站等丰富选择”点击右上角的保存 如果你返回到了 Restaurant 列表页面，你会发现多了一行数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b06c11d5b4cd9bb8cfdbbf41541b5215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7a5e73b305686b301c9da907221ea95/" rel="bookmark">
			10-3 递归实现指数函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题要求实现一个计算x n(n≥1）的函数。
函数接口定义： double calc_pow( double x, int n ); 函数calc_pow应返回x的n次幂的值。建议用递归实现。题目保证结果在双精度范围内。
裁判测试程序样例： #include &lt;stdio.h&gt; double calc_pow( double x, int n ); int main() { double x; int n; scanf("%lf %d", &amp;x, &amp;n); printf("%.0f\n", calc_pow(x, n)); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： 2 3 输出样例： 8 这道题就是一个求指数幂的题目，不必多加赘述
double calc_pow( double x, int n ){ int sum; sum=pow(x,n); //一个数学函数公式pow（）求指数幂 return sum; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ec99c8f3b1c15849a37ec69eeeaadc/" rel="bookmark">
			Gif动画怎么在线制作？快试试这款gif在线制作工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gif动画图片怎么制作呢？使用【GIF中文网】的gif动画制作（https://www.gif.cn/）功能。上传jpg、png以及gif格式的图片，一键就可以在线合成gif图片，简单方便容易操作。还支持视频转gif、gif压缩、gif拼图等gif在线编辑的功能。
使用方法以及入口链接
链接：https://www.gif.cn/
打开网站，点击“gif合成”按钮，上传图片。
设置生成GIF动图的尺寸宽高、播放速度以及图片质量的参数，点击开始生成。
生成后，点击“下载图片”即可。
推荐理由
1、支持视频转gif、gif压缩、gif拼图等gif在线编辑的功能。
2、支持上传jpg、png、gif格式的图片生成gif动图。
3、支持超清导出，无损画质。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37eebfb2c2e387b402f5d4f76f7856e2/" rel="bookmark">
			ART堆大小设置及动态调整过程分析（Android 8.1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ART虚拟机中，堆（Heap）空间负责进行对象内存的分配。堆的大小也决定了一个应用可使用的内存大小。当应用内存量超过了Android系统给定的最大堆内存限制时，就会产生OOM。
我们接下来逐步分析，决定堆内存大小的因素；以及伴随GC过程中的堆大小的状态变化。
堆的初始设定 手机出厂时，会设置堆内存相关的几个系统参数（每个厂商和机型的设定可能不同）：
# Provides overrides to configure the Dalvik heap for a 2G phone # 192m of RAM gives enough space for 5 8 megapixel camera bitmaps in RAM. PRODUCT_PROPERTY_OVERRIDES += \ dalvik.vm.heapstartsize=8m \ //表示进程启动后，堆得初始内存大小，它影响初始启动的流畅度。 dalvik.vm.heapgrowthlimit=192m \ //单个进程的最大可用的堆的内存。（不包含netive堆） dalvik.vm.heapsize=512m \ //单个进程理论上可使用的内存的最大值。 dalvik.vm.heaptargetutilization=0.75 \ //内存利用率 dalvik.vm.heapminfree=512k \ //堆最小空闲内存heapminfree dalvik.vm.heapmaxfree=8m //堆最大空闲内存heapmaxfree 这几个参数决定了Android中，堆内存的大小及堆变化的控制。
dalvik.vm.heapstartsize
Android在每个应用启动时，都会给每个应用一个初始的可用内存空间，也就是设定一个初始的堆大小。这是因为如果应用刚启动，就给这个应用直接分配最大可用内存空间，那么一部手机也就运行不了几个应用就会消耗掉所有的内存空间了。Android为了，提高用户体验，让系统在有限的内存资源中，启动更多的应用，在应用启动时，都会给予应用一个很小的内存空间，随着应用内存需求的增加，系统会逐步增加该应用的可用内存空间（也就是堆空间的大小）。初始堆大小是通过系统参数dalvik.vm.heapstartsize设定的。
dalvik.vm.heapgrowthlimit
dalvik.vm.heapgrowthlimit表示堆得最大可用内存值。也就是说，应用启动后，随着堆空间的增加，占用的系统内存量也会逐步增加，但是增长是有限制的，堆得空间不可能无限增长。dalvik.vm.heapgrowthlimit就代表了Java堆内存的增长上限值。
dalvik.vm.heapsize
dalvik.vm.heapsize表示应用最大可用的堆内存空间。当我们在应用程序Manifest中配置android:largeHeap="true"时，我们的最大堆内存大小就可以使用dalvik.vm.heapsize的值了。它代表了“大堆”空间，目的是给有特殊需求的，内存使用量非常大的应用使用的。
dalvik.vm.heaptargetutilization
dalvik.vm.heaptargetutilization代表了内存的利用率。每次GC之后会评估当前堆内存的大小是否是适合的。dalvik.vm.heaptargetutilization = 已使用内存良/堆大小。过大或者过小都会影响GC的频繁程度及效率，它通常被设置为0.75。
dalvik.vm.heapminfree
dalvik.vm.heapminfree可允许的堆的最大空闲内存量。
dalvik.vm.heapmaxfree
dalvik.vm.heapmaxfree可允许的堆的最小空闲内存量。
查看手机中堆相关系统参数
我们可以通过adb命令查看测试手机的相关参数 方法一：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37eebfb2c2e387b402f5d4f76f7856e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6adfd064f2ab12e36f8179fc290c41/" rel="bookmark">
			微信gif表情包在线编辑怎么做？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gif表情包在线编辑怎么做？gif制作表情包的方法有哪些？怎么将图片做成微信GIF表情包呢？下面gif中文网就来介绍一下动态gif表情包制作方法吧。　入口：一键合成高清gif动图-在线gif制作工具-gif.cn_GIF中文网　首先，点击【gif合成】，把要做成微信gif表情包的图片上传
调整图片参数，开始生成gif
下载图片，完成
以上就是gif表情包在线编辑方法，GIF中文网提供多种GIF在线制作功能，包括GIF合成，GIF裁剪，GIF压缩，视频转GIF，宣传动图等多种功能，打开网站即可使用，在线制作无需下载软件，赶紧尝试一下吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a338638f8b785830918eba9f4d22af/" rel="bookmark">
			antdv select 样式改变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue版ant design select 样式调整 布局 &lt;div class="select-wrap"&gt; &lt;a-select&gt; &lt;a-select-option&gt;&lt;/a-select-option&gt; &lt;/a-select&gt; &lt;/div&gt; 外部的选择框和展示框 # 局部样式 .select-wrap /deep/ .ant-select { width: 100%; color: #06B0FE; font-size: 22px; font-weight: 400; } .select-wrap /deep/ .ant-select-selection--single { background: rgba(4, 3, 36, .5); border: 1px solid #06B0FE; width: 100%; height: 100%; } .select-wrap /deep/ .ant-select-selection__rendered{ line-height: 36px; } .select-wrap /deep/ .ant-select-arrow { color: #06B0FE; font-size: 14px; font-weight: 600; } option面板 option面板是一个全局的组件，他在body标签下，与#app同级
/* 全局修改下拉框的样式 */ .ant-select-dropdown { /* color: rgba(255, 255, 255, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51a338638f8b785830918eba9f4d22af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec97841c8d262e7e1014a15a1428c02/" rel="bookmark">
			记一次PageHelper分页未生效问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 最近在项目中使用PageHelper分页工具+Mybatis实现分页查询逻辑，但是发现分页逻辑并没有生效，代码片段如下：
public PageDTO&lt;ChargeMetaDO&gt; pageByParams(SearchChargeReq searchChargeRequest, int pageNo, int pageSize) { PageHelper.startPage(pageNo, pageSize); ChargePOExample example = buildExample(searchChargeRequest); long total = chargeMapper.countByExample(example); List&lt;ChargeMetaDO&gt; chargeMetaDoList = selectByExample(example); return new PageDTO&lt;&gt;(total, chargeMetaDoList); } 这段代码中传入了查询参数和分页信息，并返回总页数和当前页号的数据。但是实际执行的时候返回了全部的数据。
修复方式 排查的时候发现，count代码通过mybatis生成的sql语句中包含了分页参数，但是select语句却没有，因此将查询数据列表的请求放在计算总数据行数前面即可解决这个问题。
public PageDTO&lt;ChargeMetaDO&gt; pageByParams(SearchChargeReq searchChargeRequest, int pageNo, int pageSize) { PageHelper.startPage(pageNo, pageSize); ChargePOExample example = buildExample(searchChargeRequest); // 需要先执行分页查询，再查询总数 List&lt;ChargeMetaDO&gt; chargeMetaDoList = selectByExample(example); long total = chargeMapper.countByExample(example); return new PageDTO&lt;&gt;(total, chargeMetaDoList); } 原因分析 这里阅读了一下PageHepler，简单介绍一下PageHelper是如何将分页信息塞入当查询请求中的。
在调用PageHelper.startPage方法后最终会进入这段逻辑：
protected static final ThreadLocal&lt;Page&gt; LOCAL_PAGE = new ThreadLocal(); public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero) { Page&lt;E&gt; page = new Page(pageNum, pageSize, count); page.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec97841c8d262e7e1014a15a1428c02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d172fa4ddbd9fdc985b451b1029bb6/" rel="bookmark">
			基于Java Web的图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.系统简要概述
2.系统主要用到的数据库表
3.主要功能
管理员：
用户：
3.1管理员功能
3.11登录
3.12添加学生
3.13查看学生
3.14删除学生
3.15添加书籍
3.16查看书籍
3.2用户端功能
3.2.1登录
3.2.2注册 3.2.3查询图书
3.2.4借阅书籍
3.2.5借阅信息查询
3.2.6还书
3.2.7我的基本信息
4.代码部分
4.1 dao类
adminDao
BookDao
BorrowDao
studentDao
4.2 Servlet类
userlojinServlet
adminlojinServlet
managebookservlet
managestudentservlet
4.3javaBean类
admin
student
book
4.4filter（过滤器类）
loginfilter
characterfilter
1.系统简要概述 所用的思想是在MVC模式下进行开发，主要涉及到的内容有：JSP、javaBean、Servlet、JDBC、以及前端css、js，从具体实施来看主要涉及到的知识有：对jsp主要内置对象的熟练使用。例如，request请求、response响应、session会话、以及利用cookie来进行免登录，EL表达式，JSTL标签,Filter过滤器，Listener监视器，前端的灵活使用等。
2.系统主要用到的数据库表 admins(管理员)表 管理员相关信息
Books(图书)表 记录图书相关信息
Students（学生）表 记录学生相关信息
Borrows(借书)表 记录借阅相关信息
3.主要功能 此次系统分为两个板块，管理员和用户。管理员主要进行用户和图书的增删改查，用户则进行借还操作。
下面简述两者主要功能及实现方法，具体可见后文详解。
管理员： 增加学生、删除学生、查看学生、添加图书、修改图书、删除图书、查看图书
对学生的增删查，主要是在ManageStudent.Servlet里面进行。另外有专门处理学生的数据库类Student.Dao,首先增加和查看功能，直接利用前端提交的post请求，通过method字段在servlet里执行相对应的方法，将结果最终呈现在jsp页面中。至于删除的功能则是利用前端提交的get请求，将学生信息绑定在服务器前台,在后端通过request获取到相应数据，执行删除的方法。
对图书的增删改查类似以上机制，主要是在ManageBook.Servlet里面进行。同理也有Book.Dao,增删基本同添加学生一致。查看这里涉及到分页查看的机制，分页查看利用limit限制条件，对每次浏览的记录分条处理。通过后端每次传输的页值，将结果存储到session会话中，在jsp页面里，通过获取存储的对象输出到浏览器中。至于修改同查看一样，只不过这里，要将原先数据存到文本框内，需要通过get请求，将绑定的数据存储到会话中，然后重定向要修改的页面，中间借用EL表达式比较简洁。
用户： 查看图书、借书、借阅信息查看、还书、查看个人信息
当用户登录成功后，在左边功能框可查看所有图书信息，也可以查看具体类别的图书，这里主要是在userchoise.Servlet里面执行，当用户点击具体某类图书时，会将图书类别传输到服务器端，在servlet里面通过request获取类别，然后调用Book.Dao里面的方法将结果进行封装，在show.jsp页面里通过获取图书对象进行显示。每条图书信息后面附有借书操作功能，主要在Borrow.servlet里面进行，通过get机制将用户信息和图书信息上传到服务器，在servlet里面获取，然后利用Bean来声名对象，对借阅书籍进行更改，同时通过调用borrow.Dao，对图书信息数量进一步修改。
借阅信息的查看可直接在相应jsp里面，根据用户信息调用相应的Dao方法，来获取借阅书籍信息显示当浏览器上。在借阅信息里面可对图书进行归还操作，主要使用return.Servlet，在前端通过get机制，将学生信息和书籍信息上传到服务器端。在后端通过request获取，然后借用borrow.Dao，里面的方法对书籍数量进一步修改。查看个人信息比较见到，直接通过session会话，将事先绑定好的用户信息，直接读取，显示在相应页面中。
3.1管理员功能 管理员主要管理学生和图书，在其项目里面有managestudent.servlet和managebook.servlet两个主要的servlet类。通过前端提供不同的请求来响应对应servlet里面的方法。
3.11登录 首先是管理员需要登录验证，判断数据库中是否有管理员账号相关信息。此次开发中，管理员账号为事先在数据库中录入，不支持注册和记住密码。管理员登录，需要请求adminlogin.servlet处理登录信息，如下（账号：admin 密码：admin）：
图1- 1 管理员登录页面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d172fa4ddbd9fdc985b451b1029bb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24fb11662eccd241546f0c672c21277/" rel="bookmark">
			离线安装httpd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		httpd及依赖包下载:离线安装httpd.tar-其它文档类资源-CSDN下载 一、安装httpd 1、创建临时文件夹，上传httpd.tar至文件夹下并解压
[root@localhost ~]# sudo mkdir -p /home/httpd &amp;&amp; cd /home/httpd
[root@localhost httpd]# sudo tar -xvf httpd.tar
2、按以下顺序安装httpd依赖包
[root@localhost httpd]# sudo rpm -ivh apr-1.4.8-7.el7.x86_64.rpm
[root@localhost httpd]# sudo rpm -ivh apr-util-1.5.2-6.el7.x86_64.rpm
[root@localhost httpd]# sudo rpm -ivh apr-util-ldap-1.5.2-6.el7.x86_64.rpm
[root@localhost httpd]# sudo rpm -ivh postgresql-libs-9.2.24-4.el7_8.x86_64.rpm
[root@localhost httpd]# sudo rpm -ivh mailcap-2.1.41-2.el7.noarch.rpm
[root@localhost httpd]# sudo rpm -ivh httpd-tools-2.4.6-95.el7.centos.x86_64.rpm
[root@localhost httpd]# sudo rpm -ivh httpd-2.4.6-95.el7.centos.x86_64.rpm
[root@localhost httpd]# sudo rpm -ivh httpd-manual-2.4.6-95.el7.centos.noarch.rpm
3、启动 (注意80端口不能被占用)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c24fb11662eccd241546f0c672c21277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab903bc20141f389b5adaf93f431cee2/" rel="bookmark">
			Strapi日志功能：保存日志为文件到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 将每次前端请求过来的api请求都保存为日志，并按日期储存为本地文件。
日志工具 simple-node-logger （日志库，你换其他也可以）
实现步骤 引入日志库 在根目录下创建helpers文件夹，并创建logger.js文件
// helpers/logger.js const simpleLogger = require('simple-node-logger'); const logger = simpleLogger.createRollingFileLogger({ logDirectory: 'logs/', fileNamePattern: 'strapi_log_&lt;DATE&gt;.log', dateFormat: 'YYYY.MM.DD', }); module.exports = logger; 在根目录下创建logs文件夹，用来放日志文件
在根目录config文件夹下创建policies文件夹，并创建log.js文件
// config/policies/log.js const logger = require('../../helpers/logger'); module.exports = async (ctx, next) =&gt; { let message = ctx.request.url; if (ctx.request.header.name) { message += ' '; // 前端 encodeURIComponent 参数； message += decodeURIComponent(ctx.request.header.name) } logger.info(message); return await next(); } Policies 策略是能够在每个请求到达控制器的操作之前对其执行特定逻辑的函数。它们主要用于简单地保护业务逻辑。项目的每个路由都可以关联到一组策略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab903bc20141f389b5adaf93f431cee2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c2a97bc10660ee6d342e5695ebd27b/" rel="bookmark">
			UVM验证平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：《UVM实战》 张强 著 文章目录 UVM 框架DUTtestbench topinterfacemy_case0base_testenvagenttarnsactionsequencesequencerdrivermonitor reference_modelscoreboard UVM 框架 DUT 1 module dut(clk, 2 rst_n, 3 rxd, 4 rx_dv, 5 txd, 6 tx_en); 7 input clk; 8 input rst_n; 9 input[7:0] rxd; 10 input rx_dv; 11 output [7:0] txd; 12 output tx_en; 13 14 reg[7:0] txd; 15 reg tx_en; 16 17 always @(posedge clk) begin 18 if(!rst_n) begin 19 txd &lt;= 8'b0; 20 tx_en &lt;= 1'b0; 21	end 22 else begin 23 txd &lt;= rxd; 24 tx_en &lt;= rx_dv; 25 end 26 end 27 endmodule testbench top 1 `timescale 1ns/1ps 2 `include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36c2a97bc10660ee6d342e5695ebd27b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c9828bd4714109a7a7fdab4d0c0ccb/" rel="bookmark">
			C语言 pivot_root的Invalid argument错误解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mount(2) — Linux manual page man手册：
SYNOPSIS top
#include &lt;sys/mount.h&gt; int mount(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags, const void *data); 解决PivotRoot系统调用失败 当我们fork新的进程，子进程会使用父进程的文件系统。
但如果我们想要把子进程的 / 文件系统修改成 /opt/busybox 怎么办呢？
这时候就要使用 pivot_root 了
int pivot_root(const char *new_root, const char *put_old);
它的作用是将进程的 / 更改为 new_root,原 / 存放到 put_old 文件夹下。
遇到的问题 我想使用 PivotRoot 来修改容器进程的根文件系统路径。
但每次进行pivot_root系统调用，总会出 Invalid arguments 错误
出错原因如下：
Not withstanding the fact that the default propagation type for new
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c9828bd4714109a7a7fdab4d0c0ccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f370c1efcfb3ea88cf2f0209bb224583/" rel="bookmark">
			Spring MVC总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结：
Spring MVC 概念Spring MVC 架构Spring MVC 环境设置Spring MVC 架构：运行流程基础 Spring MVC - Hello World示例配置文件 web.xmlspringmvc.xml 视图定位：为了安全，一般将jsp文件放在WEB-INF目录下，放在此目录下的文件不能直接访问，需要由核心处理器进行跳转，才能访问，如http://localhost:8080/ssm/WEB-INF/jsp/login.jsp就不能访问，
如http://localhost:8080/ssm/login.jsp就能直接访问。
struts2中也是将jsp文件放在WEB-INF目录下。配置拦截器控制器 接受表单数据：参数绑定客户端跳转注解实现session上传文件关于静态资源拦截、访问以及拦截的几个符号说明，需要如下注意： web.xml中/、/*、*.action、*.do的区别
/ 表示拦截所有请求 （包括html，但是不拦截.jsp) 建议使用此种方式 （拦截 html.js.css .png等等静态资源) (需要在web.xml中配置放行才能访问）
/* 拦截所有请求（包括.jsp，但是不拦截.html) 此种方式不建议使用
*.do *.action 拦截以.do结尾的请求 (不拦截 jsppngjpg .js .css)spring mvc为什么不能访问静态资源：因为/拦截所有的请求，但是不拦截jsp，所有可以访问index.jsp,而不能访问index.html
&lt;!-- 配置springmvc的servlet的时候，使用的路径是"/"，导致静态资源在默认情况下不能访问，如果想要访问，所以要加上这一段，允许访问jpg。 并且必须加在springmvc的servlet之前，如下--&gt;怎么访问静态资源
可以在servelt中配置放行的静态资源，也可以在springmvc-servlet.xml中配置，如下
图片、js包、css等都属于静态页面servlet。struts。springmvc 为什么能使用index.jsp能设置为默认首页，而index.html不能作为首页
如果有index.jsp，没有index.html的情况，启动项目的时候，默认会访问index.jsp；
如果有index.jsp，又有index.html的情况，启动项目的时候，会访问index.html，但是index.html属于静态资源，会被拦截，
报错，需要在web.xml中配置放行才能访问，如下：
如果在web.xml中配置了&lt;welcome-file-list&gt;&lt;/welcome-file-list&gt;的话，可以选择项目启动默认访问的页面。 &lt;!-- 配置springmvc的servlet的时候，使用的路径是"/"， 导致静态资源在默认情况下不能访问，所以要加上这一段，允许访问jpg。 并且必须加在springmvc的servlet之前 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpeg&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 拦截器 Interceptor过滤器Filter：中文问题SpringMVC中使用REST风格的urlSpringMVC与前台json数据交互，并应用ajaxspringmvc设计模式 知识点：
Spring MVC 概念 Spring MVC是一个基于MVC架构的用来简化web应用程序开发的应用开发框架，它是Spring的一部分，它和Struts2一样都属于表现层的框架。MVC（Model模型 View 视图 Controller 控制器）：这是一种软件架构思想，是一种开发模式，将软件划分为三种不同类型的模块，分别是模型，视图，和控制器。 模型：用于封装业务逻辑处理（java类）；视图：用于数据展现和操作界面（Servlet）；控制器：用于协调视图和模型（jsp）；处理流程：视图将请求发送给控制器，由控制器选择对应的模型来处理；模型将处理结果交给控制器，控制器选择合适的视图来展现处理结果；优点（和struts2相比） 和Spring 其他框架无缝集成，是其它Web框架所不具备的；RESTful风格的支持和struts2相同 分工明确：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f370c1efcfb3ea88cf2f0209bb224583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/068e1c1036cd2e75e3475a310eabe093/" rel="bookmark">
			10-2 递归求阶乘和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求实现一个计算非负整数阶乘的简单函数，并利用该函数求 1!+2!+3!+…+n! 的值。
函数接口定义： double fact( int n ); double factsum( int n ); 函数fact应返回n的阶乘，建议用递归实现。函数factsum应返回 1!+2!+…+n! 的值。题目保证输入输出在双精度范围内。
裁判测试程序样例： #include &lt;stdio.h&gt; double fact( int n ); double factsum( int n ); int main() { int n; scanf("%d",&amp;n); printf("fact(%d) = %.0f\n", n, fact(n)); printf("sum = %.0f\n", factsum(n)); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： 10 输出样例： fact(10) = 3628800 sum = 4037913 输入样例： 0 输出样例： fact(0) = 1 sum = 0 这个题，第一个函数体，求一个数的阶乘
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/068e1c1036cd2e75e3475a310eabe093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29eeaaa4ea255597d764d86b9da49c67/" rel="bookmark">
			LeetCode 498. 对角线遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。
示例：
输入：mat = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,4,7,5,3,6,8,9] 思路：
一个矩阵，假设共有n行，m列，则其对角线（指的是/这种方向的对角线，而不是\）一共有n + m - 1条。假设对角线编号从0开始，则所有对角线的编号范围则是[0,n + m - 2]，并且容易得到一个性质，编号为i的对角线上的点，其横纵坐标之和等于i。
观察数据样例可知：编号i为偶数的对角线，遍历方向是从左下到右上；编号i为奇数的对角线，遍历方向是从右上到左下。
从左下到右上，点的坐标的变化是，行数减1，列数加1。即x--，y++
从右上到左下，点的坐标的变化是，行数加1，列数减1,。即x++，y--
当一条对角线遍历完成后，我们需要找到下一个点作为起点，并翻转遍历方向。
找到下一个点作为起点，可以分情况讨论。
设当前遍历的对角线的编号为i
当方向是从左下到右上时 当i &lt; m - 1时，下一个起点的列，一定是i + 1，即 y = i + 1，而行，可以直接根据根据对角线上所有点的横纵坐标是个常数，来算出来，即x = (i + 1) - y当i &gt;= m - 1时，下一个起点的列，只能到最后一列，即y = m - 1，而x = (i + 1) - y 当方向是从右上到左下时 当i &lt; n - 1时，下一个起点的行，一定是i + 1，即x = i + 1，而y = (i + 1) - x当i &gt;= n - 1时，下一个起点的行，只到最后一行，即x = n - 1，而y = (i + 1) - x class Solution { // 重要性质: 同一条对角线上的点, 其[x,y]坐标的和是固定的 // 对角线条数, 总共 m + n - 1 条 // 第 i 条对角线上的坐标的和为 i // 和为偶数, 向右上角走 (x--, y++) // 和为奇数, 向左下角走 (x++, y--) public int[] findDiagonalOrder(int[][] mat) { int n = mat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29eeaaa4ea255597d764d86b9da49c67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0d3674e530973630b0aea9e5aab886/" rel="bookmark">
			Java初学之标识符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是标识符
二、标识符的命名规则
三、标识符的命名规范
一、什么是标识符 标识符（identifier）是指用来标识某个实体的一个符号，在不同的应用环境下有不同的含义。在java源程序中，凡是程序员有权利自己命名的单词都是标识符
标识符可以标识类名、方法名、变量名、接口名、常量名等等
二、标识符的命名规则 1.一个合法的java标识符只能由数字、字母、下划线和美元符号组成，不能含有其他符号
2.java标识符不能以数字开头
3.java标识符严格区分大小写 student和STUDENT是不同的标识符
4.Java关键字不能做标识符
5.java标识符理论上没有长度限制
三、标识符的命名规范 命名规范只是一种规范，不属于语法规则，不遵守命名规范编译器不会报错
1.java标识符最好见名知意
2.java标识符最好遵循驼峰命名方式:
1)类名、接口名：每一个单字的首字母都采用大写字母
eg：FirstName、JavaTest
2）变量名、方法名： 第一个单字以小写字母开始,第二个单字的首字母大写
eg：firstName、javaTest
3）包名：所有字母都小写
4）常量名：所有字母都大写
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78eac392eabc3e567951824fcfd6f442/" rel="bookmark">
			【pytorch笔记】（五）自定义损失函数、学习率衰减、模型微调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录： 1. 自定义损失函数2. 动态调整学习率3. 模型微调-torchvision3.1 使用已有模型3.2 训练特定层 1. 自定义损失函数 虽然pytorch提供了许多常用的损失函数，但很多时候我们需要自定义一些新的损失函数来满足某些特定任务的需求，这时就需要我们自己写损失函数了。
pytorch 自定义损失函数主要有两种方式：
自定义函数：这种方法比较简单，写个函数即可。但需要注意的是输入输出的变量都得是torch.tensor类型的数据，且尽量采用torch自带的函数计算loss，否则可能会无法求导。 import torch def my_loss(x, y): loss = torch.mean((x - y)**2) return loss 自定义类：这种方式虽然需要提前实例化类，但更为常用，显得专业。自定义类继承于nn.Module，相当于定义了一个网络层，可以维护状态和存储参数信息。自定义类有两个关键要点，一是定义初始化方法（init），二是定义前向计算方式（forward）。
以下给出一个我自己写的分位数回归损失函数——pinball loss： import torch.nn as nn import torch class PinballLoss(nn.Module): """ Pinball loss at all confidence levels. """ def __init__(self, quantiles): """ Initialize Parameters ---------- quantiles : the list of quantiels, [1, n], list or ndarray. For example, quantiles = [0.025 0.05 0.075 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78eac392eabc3e567951824fcfd6f442/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec7cec001688df5b12a5e079f7a1d27/" rel="bookmark">
			AcWing：第56场周赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AcWing：第56场周赛 4482. 分组 - AcWing题库 给定一个长度为 n 的数组 a1,a2,…,an。
请你将这 n 个元素重新分组，要求每个组内的元素两两不等，且分组数量应尽可能少。
请你计算最少所需的分组数量。
例如，给定一个数组 a=[1,2,4,3,3,2]，我们至少需要将所有元素分为两组，一种可行分组方案为：[1,2,3] 和 [2,3,4]。
输入格式 第一行包含一个整数 n。
第二行包含 n 个整数 a1,a2,…,an。
输出格式 一个整数，表示最少所需的分组数量。
数据范围 前三个测试点满足 1≤n≤10。
所有测试点满足 1≤n≤100，1≤ai≤100。
输入样例1： 6 1 2 4 3 3 2 输出样例1： 2 问题解析 想象一下，我们要把n个相同的东西分开放，那么显然是需要n个盒子，这样才能保证一个盒子里只有一个相同的东西。
这题直接统计出现最多的那个数的次数就行，次数为多少，就要分多少组。
AC代码 #include&lt;iostream&gt; using namespace std; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;math.h&gt; #include&lt;set&gt; #include&lt;numeric&gt; #include&lt;string&gt; #include&lt;string.h&gt; #include&lt;iterator&gt; #include&lt;map&gt; #include&lt;unordered_map&gt; #include&lt;stack&gt; #include&lt;list&gt; #include&lt;queue&gt; #include&lt;iomanip&gt; #define endl '\n' #define int ll typedef long long ll; typedef unsigned long long ull; typedef pair&lt;ll, ll&gt;PII; const int N = 2e5 + 50; signed main() { ios_base::sync_with_stdio(false); cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dec7cec001688df5b12a5e079f7a1d27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496dffb6a5ca926058c8dc065e7bc6f6/" rel="bookmark">
			java实现调用Http请求常用的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接: https://blog.csdn.net/riemann_/article/details/90539829.
参考链接: 使用HttpURlConnection 发送POST请求上传文件（带参数）.
使用这些http客户端时注意tcp链接数的问题 参考链接: 高并发下对接第三方请求时http请求的问题及处理方式.
通过Java.net.HttpURLConnection实现 import java.io.*; import java.net.HttpURLConnection; import java.net.URL; import java.util.HashMap; import java.util.Map; import java.util.UUID; public class MyHttpUtil { private static final int TIME_OUT = 5 * 1000; //超时时间 private static final String GET = "GET"; //GET请求 private static final String POST = "POST"; //GET请求 private static final String CHARSET = "UTF-8"; //编码格式 private static final String PREFIX = "--"; //前缀 private static final String LINE_END = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496dffb6a5ca926058c8dc065e7bc6f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b97a38d2beb395e937947071e7eddd3d/" rel="bookmark">
			docker 开启 tcp 端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认安装的Docker服务是不支持远程连接的，开启TCP端口后可以进行远程连接Docker
1、操作系统环境
[root@localhost home]# uname -r
3.10.0-1160.66.1.el7.x86_64
2、编辑 docker 服务
注释原有 ExecStart 参数，新增 ExecStart 参数，见加红色字体。
[root@localhost home]# vi /lib/systemd/system/docker.service
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target
[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker
# ExecStart=/usr/bin/dockerd
ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b97a38d2beb395e937947071e7eddd3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038b8605778b631dbf587543f268dba3/" rel="bookmark">
			基于pyecharts的中医药知识图谱可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于pyecharts的中医药知识图谱可视化 关键词： pyecharts；可视化；中医药知识图谱
摘要： 数据可视化是一种直观展示数据结果和变化情况的方法，可视化有助于知识发现与应用。Neo4j数据库对于知识图谱的展示形式过于单调。因此，本文基于pyecharts对当前处理的中药知识图谱数据进行分析与可视化。以利用图形传递和表达更清晰的中药知识图谱信息，发掘有潜在价值的内容。
本文目录 基于pyecharts的中医药知识图谱可视化1、数据准备2、基于pyecharts的知识图谱可视化2.1 pyecharts简介2.2 中药材知识图谱可视化2.3 中药材知识图谱分析结果可视化2.4 中药术语知识图谱可视化 3、其他可视化工具4、总结 1、数据准备 本文数据分析将基于前期准备的中药材知识图谱数据。特别的，本次在中药材知识图谱中增加了“归经”关系，数据已经更新在github中。
开源数据地址：
https://github.com/fengxi177/Knowlegde_Graph_TCM https://gitee.com/fengxi177/Knowlegde_Graph_TCM
2、基于pyecharts的知识图谱可视化 本文将基于pyecharts框架，对中药材知识图谱进行“力导图”和“环形分布”可视化，同时，对中药材地理分布、来源和别名关系进行分析与可视化。
2.1 pyecharts简介 Apache ECharts 是一个由百度开源的数据可视化工具，有很多常见图表设计的api，操作简洁方便，如关系图、地图、折线图、散点图等可视化api。
api详细可访问：
https://github.com/pyecharts/pyecharts。
2.2 中药材知识图谱可视化 前文自顶向下构建中药知识图谱初探已经介绍了中药材知识图谱的构建和neo4j可视化过程，接下来将对该图谱数据利用pyecharts进行可视化。
pyecharts关系图api和具体参数配置可参考示例文档：
https://gallery.pyecharts.org/#/Graph/README。
说明： 本文所有数据分析结果仅限于所收集数据情况。
少量数据的中药知识图谱-环形图
少量数据的中药知识图谱-环形图（部分节点展示图1）
少量数据的中药知识图谱-环形图（部分节点展示图2）
少量数据的中药知识图谱-力导图
较多数据的知识图谱可视化效果
2.3 中药材知识图谱分析结果可视化 （1）中药材分布情况可视化
（2）中药材来源数据可视化
（3）中药材别名数据可视化
经数据分析发现：有别名的中药材占比:0.7591，没有别名的中药材占比:0.2409。
中药材别名数量与对应中药材数量关系图如下。
别名最多的中药是“地锦草”，有57个别名，其关系图如下。
2.4 中药术语知识图谱可视化 中医术语知识为层次结构，其树形图展示如下。
环形树图（部分节点展开）
自底向上的树图（部分节点展开）
3、其他可视化工具 对于知识图谱数据可视化，还可利用D3.js创建更复杂场景的可视化结果。同时，可利用共现网络分析工具cytoscape、gephi等探索更多的数据价值。
4、总结 本文基于pyecharts对已有知识图谱进行了数据分析与可视化展示。
欢迎关注公众号：实用自然语言处理 主要参考文献：
[1] https://github.com/pyecharts/pyecharts
原文首发于微信公众号：实用自然语言处理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb5738c9a3ef38ae00c23e63de04be17/" rel="bookmark">
			共阳极数码管真值表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 亲测可用的
unsigned char Tab[] = {0xc0,0xF9,0xa4,0xb0,0x99,0x92,0x82, 0xf8,0x80, 0x90, 0x88,0x83,0xc6,0xa1,0x86,0x8e,0x8c,0xc1,0x91,0x7c,0xff,0x7f,0x00};//0 1 2 3 4 5 6 7 8 9 A B C D F P U Y L 灭 . 亮// 共阳数码管 unsigned char Tab2[] = {0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10,0x08,0x03,0x46,0x21,0x06,0x0e}; //带小数点0~F //共阳数码管 2. 几个链接
共阳极、共阴极数码管编码表（0~9、A~P……全亮）_零碎@流年絮语的博客-CSDN博客_共阴极数码管编码表
共阳极数码管七段码表（详实）_赛科帕斯的博客-CSDN博客_共阳极七段数码管真值表
共阴/共阳数码管 ----- 学习笔记_旭日初扬的博客-CSDN博客_共阴极真值表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd2b929a84bb5f1a3169d990f35a98ca/" rel="bookmark">
			学生成绩管理系统——JAVA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生成绩管理系统 1.简介 本学生成绩管理系统具有录入学生成绩、查询学生成绩、输出学 生按成绩的排名、输出学科的分数四个功能，其中后两个功能在“输出成绩”这一目录下。 此系统可以实现学生成绩管理的一些基本操作。
1.1各模块功能简介 录入成绩
输入若干同学的学号、姓名以及四个科目的成绩（应用数学、大学英语、Java 程序设计、计算机应用基础），并将其保存在建立好的数据库中。
查询成绩
进入该模块后，输入想要查询成绩的学生姓名，即可在数据库中检索该学生 的成绩信息并输出其各科成绩。
输出成绩
该模块主要分为两部分，包括学生排名和各科目平均成绩及各科的最高分和 最低分。
（1）能够计算出平均成绩，以平均成绩降序输出成绩表。
（2）输出全组各科平均分，最高分和最低分。
2.程序设计 数据库表的设计
本系统将数据存储在一张表中，这张表名称为：students，能够保存学生的基本信息，包括学生的姓名、学号、应用数学成绩、大学英语成绩、Java 程序 设计成绩、计算机应用基础成绩、总成绩、平均成绩。
该表中 name 和 num 栏指 定的类型为 varchar 型，各科成绩的输入数据类型为 float 型。
建表时命令行输入为：
mysql&gt; create table students(
-&gt; name varchar(50) primary key,
-&gt; num varchar(20),
-&gt; math float(5,2),
-&gt; English float(5,2),
-&gt; Java float(5,2),
-&gt; computer float(5,2),
-&gt; score float(5,2),
-&gt; average float(5,2)
-&gt; );
3.源代码 package kechengsheji; import kechengsheji.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd2b929a84bb5f1a3169d990f35a98ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6976ffa59200b4160a23ba67dfd224cc/" rel="bookmark">
			hadoop103: Warning: Permanently added the ECDSA host key for IP address ‘192.168.6.103‘ to the list
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： hadoop103: Warning: Permanently added the ECDSA host key for IP address ‘192.168.6.103’ to the list of known hosts.
其实这问题是ssh访问时可能秘钥信息丢失，可以从源头解决问题
在根目录下 ls -al 查看.ssh 目录，删除掉 .ssh 下的所有文件，如果是多个机器，同理也删掉重新生成公钥。
（2）生成公钥和私钥： 在每个机器上都要生成
[atguigu@hadoop102 .ssh]$ ssh-keygen -t rsa 然后敲（三个回车），就会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）
（3）将公钥拷贝到要免密登录的目标机器上 （每个机器上都要拷贝其他的公钥）
[atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop102 [atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop103 [atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop104 在这里插入图片描述
Goodlucky to you ! 有用的话就点个赞吧，哈哈哈，一起学习，一起成长！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a31414cc8b66934dae809ef27b988b/" rel="bookmark">
			MyBatis总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis总结 一、mybatis单表操作 1.1 基于映射文件的操作 1.1.1 搭建mybatis环境 1，引入mybatis的依赖
&lt;dependencies&gt; &lt;!-- mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2, 编写mybatis的核心配置文件 sqlMapConfig.xml
主要包含： 引入数据库环境的配置 配置mapper映射文件（db.properties,log4j.properties:显示日志）
「log4j.properties」等文件 https://www.aliyundrive.com/s/iJbbwHMkqzb
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!--加载外部properties配置文件--&gt; &lt;properties resource="db.properties"&gt;&lt;/properties&gt; &lt;settings&gt; &lt;!-- 延迟加载--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- mybatis版本再3.4.1以上可以不用配置--&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;/settings&gt; &lt;!-- 开启批处理--&gt; &lt;!-- &lt;settings&gt;--&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13a31414cc8b66934dae809ef27b988b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b69af755c85d119a9b386c0f855bab21/" rel="bookmark">
			一次可编程的非易失性存储器（OTP NVM）工作原理、eFuse模块解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于eFuse模块解析、一次可编程的非易失性存储器（OTP NVM）解析 1 基本概况及介绍1.1 相关简介1.2 关于eFuse工作原理 2 应用功能总结3 关于eFuse解析3.1 基本介绍3.2 相关信号3.3 eFuse操作模式3.3.1 编程模式（Program Mode）3.3.2 读取模式（Read Mode）3.3.3 非活动模式（Inactivate Mode） Author： Nirvana Of Phoenixl
Proverbs for you：There is no doubt that good things will always come, and when it comes late, it can be a surprise. 本文主要用于通过分析eFuse工作原理及其模式 1 基本概况及介绍 不同于大多数FPGA使用的SRAM阵列，eFuse一次只有一根熔丝能够被编程，这是该方法的配置能力存在限制范围的原因。但当与日益成熟的内置自测试(BIST)引擎组合使用时，这些熔丝就变成了强大的工具，能减少测试和自修复的成本，而这正是复杂芯片设计所面临的重大挑战。
eFuse就好像在硅片上建立了无数个交通岗哨，控制信号的传输或停止，据悉这将把芯片中的电路运行效率提高上千倍。比如您购买了一个新的控制器，最开始的时候控制器的功能是空的，不过在把它带回家后，它重新识别了您家中的所有系统，电视、音响、DVD，并且自动对自身进行改造，来控制这些电器。
1.1 相关简介 （1）非易失性存储器（NVM，Non-Volatile Memory）
所谓非易失性存储器NVM 的特点是存储的数据不会因为电源关闭而消失。比如Mask ROM、PROM、EPROM、EEPROM、NAND / NOR 闪存 (Flash Memory) 等传统 NVM，以及目前许多正在研发的新型态存储器，如磁性存储器 (MRAM)、阻变存储器 (RRAM)、相变存储器 (PRAM)、铁电存储器 (FeRAM) 等等都属于 NVM。因此，非易失性存储器NVM的概念设计的范围很广。 &lt;font color= &gt; 从可编程次数来看，NVM可以分为3类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b69af755c85d119a9b386c0f855bab21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148afe7ef16f25e7b59a056bdf668f0f/" rel="bookmark">
			Gif动图如何裁剪？收下这个图片在线裁剪工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【GIF中文网】是一款简单专业的**gif裁剪**（https://www.gif.cn/）工具，上传gif动图一键即可在线裁剪照片，支持自定义尺寸裁剪。同时还支持图片合成gif、视频转gif、gif压缩、gif拼图的功能，方便快捷，新手小白也能轻松上手。（第一页第十位）
使用方法以及入口链接
链接：https://www.gif.cn/
打开网站，直接拖拽或是点击上传图片。
图片上传后，可以通过输入需要裁剪的宽高数据也可以通过拖动灰色裁剪框来裁剪gif动图。
点击裁剪，下载到电脑即可。
上述内容就是gif裁剪的操作方法了，仅需三步即可快速完成，简单实用容易操作。感兴趣的小伙伴快来动手体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dba90575cfc2dac3812ecc9f99fff54/" rel="bookmark">
			运行vue报错npm ERR! A complete log of this run can be found in解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里我们需要清除npm的缓存: （1）在cmd命令行窗口中输入：npm cache clean --force
（2）然后再运行我们需要安装模块的命令，输入npm install。
有时是网络问题，依赖包加载不完整，删掉node_modules文件后，重新执行npm install即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd1f89c2d2195d91c5a76788e180394/" rel="bookmark">
			执行 npm install 报错 npm ERR! code E407
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息如下：
D:\allWelinkDownload\IO\Anew\node-red-contrib-postgresql-main&gt;npm install --production npm ERR! code E407 npm ERR! 407 Proxy Authentication Required - GET https://registry.npm.taobao.org/split2/-/split2-4.1.0.tgz npm ERR! A complete log of this run can be found in: npm ERR! D:\Program Files\nodejs\node_cache\_logs\2022-06-21T07_43_29_861Z-debug-0.log 原因说明： 配置镜像代理时用户名密码出错或者后期修改了用户名密码，但是配置没有更新用户名密码；此时重新配置一遍新的用户名密码即可解决报错。
yarn 或者 npm 在配置镜像代理的时候要输入用户名和密码验证,命令如下：
yarn config set https-proxy http://用户名:密码@代理服务器:端口号 yarn config set proxy http://用户名:密码@xxx.com:8080 npm config set https-proxy http://用户名:密码@xxx.com:8080 npm config set proxy http://用户名:密码@xxx.com:8080 //yarn config set registry https://registry.yarnpkg.com //npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ //npm config set phantomjs_cdnurl=https://npm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cd1f89c2d2195d91c5a76788e180394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d75a1cb0bf11c36934a1525856cbe51/" rel="bookmark">
			代理服务器之正向代理与反向代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://cloud.tencent.com/developer/article/1418457https://cloud.tencent.com/developer/article/1418457 正向代理和反向代理的区别：
虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。
1、正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。
2、正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。
3、正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。
4、正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096f7aa1a8b28a5b5d79658798a11d3f/" rel="bookmark">
			升级OpenssL和Openssh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载Openssl软件包 # wget https://ftp.openssl.org/source/openssl-1.1.1m.tar.gz 提前安装所需要的依赖包 # yum install -y gcc gcc-c++ glibc make autoconf openssl openssl-devel pcre-devel pam-devel pam* zlib* 备份原生系统的Openssl # mv /usr/bin/openssl /usr/bin/openssl.bak 解压缩，编译OpenssL # tar xf openssl-1.1.1m.tar.gz # cd ./openssl-1.1.1m # ./config --prefix=/usr/local/openssl &amp;&amp; make &amp;&amp; make install # ln -sf /usr/local/openssl/bin/openssl /usr/bin/openssl # echo "/usr/local/openssl/lib" &gt;&gt; /etc/ld.so.conf # ldconfig -v ##设置生效 # openssl version ##查看版本是否生效 OpenSSL 1.1.1m 14 Dec 2021 下载Openssh软件包 #下载升级包 wget http://ftp.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-8.6p1.tar.gz chown -R root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096f7aa1a8b28a5b5d79658798a11d3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6db75724e2b68852f8acf6f64351aa/" rel="bookmark">
			关于bootstrap.properties读取不到nacos配置中心的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pom配置: springboot:2.2.1.RELEASE.
springcloud:Hoxton.SR9.
出现错误: bootstrap.properties读取不到nacos配置中心的内容,@value注入不了数据.
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'couponController': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'coupon.user.name' in value "${coupon.user.name}" 解决步骤: 首先添加了bootstrap的相关依赖,但还是不起作用.
&lt;!--解决spring boot不加载bootstrap.properties文件的问题--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; 其次查看alibaba版本文档,链接如下:
​
版本说明 · alibaba/spring-cloud-alibaba Wiki · GitHub 发现springboot版本和springcloud版本对应不上,后把Hoxton.SR9改成了Hoxton.RELEASE,再次启动就可以读取配置中心的文件了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/398c62e2cd43eb43fe8d3697cc6135f8/" rel="bookmark">
			Windows下配置yolov5并且实现cpu以及安装CUDA和cudnn实现gpu运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、准备工作1.准备好anaconda作为python库管理软件2.部署源码3.安装依赖库 二、切换GPU和CPU1.CPU2.GPU 总结 前言 一个简单的yolo部署教程，顺便记录一下本人的操作过程
提示：以下是本篇文章正文内容，下面案例可供参考
一、准备工作 1.准备好anaconda作为python库管理软件 这里自行百度搜索Anaconda，并且下载最新的安装文件。如果遇到下载慢的问题，这里提供我的百度网盘下载地址：
链接：https://pan.baidu.com/s/1b4wNuhJCRmGD-fnrpnHVnw?pwd=ov3m 提取码：ov3m 根据ultralytics大神在github上的说明，yolov5最好使用python&gt;=3.8版本，所以我才用python3.9版本。在anaconda中首先安装对应的python。
conda install python3.9 #根据终端中的提示安装好python3.9 conda create -n yolov5 python3.9 #创建一个名为yolov5的虚拟环境，指定python版本为3.9 2.部署源码 最好能够科学上网，因为git到github可能会时不时出现问题。或者实在没有办法科学上网的，可以在凌晨试试登录github直接下载zip文件然后解压缩到电脑。
这里提供两个下载地址，一个是deepsort项目，另一个是ultralytics大神的源项目
git clone https://github.com/ultralytics/yolov5 # clone #或者 git clone --recurse-submodules https://github.com/mikel-brostrom/Yolov5_DeepSort_OSNet.git #这里提供两个项目单纯是因为本人想要顺便记录一下我的历程 3.安装依赖库 将源码部署到本地电脑后，进入到yolo文件夹下
cd /{你的部署路径}/Yolov5_DeepSort_OSNet/yolov5 #这个是deepsort项目版本 #或者 cd /{你的部署路径}/yolov5 如下图所示：(我创建的虚拟环境名为deepsort，根据你们自己的虚拟环境来)
在资源管理器中可以看到这个requirements.txt文件，里面就包含了所需要安装的库文件。
#安装依赖库 pip install -r ./requirements.txt #漫长的等待过程，可能会有一些库安装失败，先不要着急，后面再手动安装 #对于失败的库，打开requirement.txt文件，查看必须要安装的依赖库。 #比如安装matplotlib失败了，那就pip install matplotlib或者conda install matplotlib 二、切换GPU和CPU 1.CPU 在完成上述步骤后，默认启动的就是CPU版本。输入以下命令以启动yolo检测程序。
#首先cd到存放yolov5的目录下，并且激活之前安装的虚拟环境 conda activate yolov5 python ./detect.py --source 0 等待一会后就会打开摄像头进行检测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/398c62e2cd43eb43fe8d3697cc6135f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdbe6b1ec7e659f4b7cbfecafbb4ff4a/" rel="bookmark">
			vue-video-player使用及修改样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先下载并引入(main.js引入)：
import VideoPlayer from 'vue-video-player'; require('video.js/dist/video-js.css'); require('vue-video-player/src/custom-theme.css'); const hls = require('videojs-contrib-hls') Vue.use(VideoPlayer) Vue.use(hls) 使用:
&lt;div class="my_play"&gt; &lt;video-player class="video-player vjs-custom-skin" id="my_video" ref="videoPlayer" :playsinline="true" :options="playerOptions" @play="onplayFn($event)" @pause="onpauseFn($event)" @ended="onendedFn($event)" &gt;&lt;/video-player&gt; &lt;/div&gt; js部分:
data() { return { isText: false, isCollection: false, isInput: false, active: 1, discussText: "", voteNums: 322, //票数 playerOptions: { playbackRates: [0.7, 1.0, 1.5, 2.0], //播放速度 autoplay: true, //如果true,浏览器准备好时开始回放。 muted: false, // 默认情况下将会消除任何音频。 loop: false, // 导致视频一结束就重新开始。 preload: "auto", // 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持） language: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdbe6b1ec7e659f4b7cbfecafbb4ff4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8edc9acf99ab582b634afef6db5d2c8/" rel="bookmark">
			网络编程笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网络编程1.1概述1.2 网络通信的要素1.3 IP地址1.4 端口1.5 通讯协议==**TCP和UDP的区别**==**==TCP三次握手==**1.“三次握手”的通俗理解2.为什么要进行第三次握手 ==TCP的四次挥手==“四次挥手”的通俗理解 为什么“握手”是三次，“挥手”却要四次？ 1.6 TCP协议1.TCP实现聊天2.TCP文件上传实现初识Tomcat 1.7 UDP1.UDP消息发送2.UDP聊天实现（循环发送，循环接收） 1.8 URL下载文件 网络编程 1.1概述 计算机网络：
计算机网络是指将==地理位置==不同的计算机及其外部部件，通过通信线路连接起来，在网络编程协议下，实现不同计算机之间的信息共享以及信息交流的计算机系统。
网络编程的目的：
传播交流信息（无线电台）：数据交换，通信。
想要达到这些效果需要做什么：
如何准确地定位网络上的一台主机 192.168.16.124：端口，定位到这个计算机上的某个资源找到了这个主机，如何传输数据呢？ javaweb：网页编程 B/S
网络编程：TCP/IP C/S
1.2 网络通信的要素 TCP/IP参考模型：
网络编程针对传输层 TCP，UDP
小结：
网络编程两个主要问题 如何准确定位到网络上的一台或多台主机找到主机之后如何进行通信 网络编程中的要素 IP和端口号网络通信协议：TCP,UDP 万物皆对象 1.3 IP地址 ip地址：InterAddress
唯一定位一台网络上的计算机
127.0.0.1：本机，localhost（C:\Windows\System32\drivers\etc\hosts 可以更改名称）
ip地址分类
IPv4 / IPv6
==IPV4：==127.0.0.1，四个字节组成。0 ~ 255， 42亿~；30亿都在北美，亚洲4亿。2001年就用尽了；
==IPV6：==fe80::755f:fc6c:2ebc:b6e6%18，128位。8个无符号整数！可以给地球上每粒沙子分配；
2001:0bb2:aaaa:0015:0000:0000:1aaa:1312 公网（互联网） / 私网（局域网）
ABCD类地址192.168.xx.xx，专门给组织内部使用 域名：记忆IP问题 IP：www.vip.com 练习：InetAddress类的常用方法
package com.sw.lesson01; import java.net.InetAddress; import java.net.UnknownHostException; //测试IP public class Test01 { public static void main(String[] args) { try { //查询本机地址 InetAddress inetAddress1 = InetAddress.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8edc9acf99ab582b634afef6db5d2c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac27e32347b2002e886e46473edd499/" rel="bookmark">
			SpringCloud Gateway 全局异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在全局过滤器中可以处理网络异常请求，但是当设置Gateway请求超时时间，超时后的异常全局过滤器中处理不了。
定义CustomWebExceptionHandler类 import com.alibaba.csp.sentinel.slots.block.BlockException; import com.tigerkin.util.ApiResult; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.web.reactive.error.ErrorWebExceptionHandler; import org.springframework.http.HttpStatus; import org.springframework.http.MediaType; import org.springframework.http.codec.HttpMessageReader; import org.springframework.http.codec.HttpMessageWriter; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.stereotype.Component; import org.springframework.util.Assert; import org.springframework.web.reactive.function.BodyInserters; import org.springframework.web.reactive.function.server.RequestPredicates; import org.springframework.web.reactive.function.server.RouterFunctions; import org.springframework.web.reactive.function.server.ServerRequest; import org.springframework.web.reactive.function.server.ServerResponse; import org.springframework.web.reactive.result.view.ViewResolver; import org.springframework.web.server.ResponseStatusException; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; import java.util.Collections; import java.util.List; /** * @ClassName CustomWebExceptionHandler * @Description 自定义异常处理 * @Author tigerkin * @Date 2022/3/15 14:10 */ @Component public class CustomWebExceptionHandler implements ErrorWebExceptionHandler { private static final Logger log = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aac27e32347b2002e886e46473edd499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc75f3350d160ffe715d658ff2edb327/" rel="bookmark">
			几步搞懂cobalt strike启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人问Cobalt strike怎么启动，总结几句
1.cmd管理员身份运2.切换到CS所在目录3.输入ipconf找到自己ip地址4.输入teamserver 自己ip 密码 回车即可5.打开start.bat文件再点击确定即可打开即可使用cobalt strike
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd193e4dca2b003f2358c422f447ac1/" rel="bookmark">
			Centos7如何固定ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#Centos7如何固定ip地址
一、查看虚拟网络编辑器信息 1.1 查看子网IP(记住)和子网掩码 1.2 查看Centos7的IP范围 1.3 查看默认网关 ##二、设置虚拟网卡
打开网络适配器
子网掩码最好也要保持一致
三、更改配置文件 etc—&gt;sysconfig–&gt;network-scripts–&gt;ifcfg-ens33
BOOTPROTO=static IPADDR=192.168.187.137 NETMASK=255.255.255.0 DNS1=192.168.187.2 DNS2=8.8.8.8 GATEWAY=192.168.187.2 保存这些设置之后，重启网络服务。
systemctl restart network 查看是否生效 ifconfig指令查看IP
ping www.baidu.com 指令 ：看是否有网络
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d06c3b15ac0c5a3edefc65b877eb301a/" rel="bookmark">
			业内同行盆友来稿：对libc.so下毒手引发的惨痛血案，围观大型翻车现场...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在开篇 为了在线上安装环境依赖，给glibc库升级，由于线上环境libc.so版本低，不支持安装，所以手贱把动态库中的libc.so.6给移走了，直接导致Linux系统崩溃，系统瘫痪，所有用户均被强制退出。
意识到缺少对libc.so的认识，以为跟普通的lib包类似，直接把新版的so软连过去就可以满足安装和升级，现在哦豁… 软链不软链已经不重要了，反正腿是软趴趴的。
1、什么是libc.so libc.so.6 是很基础的库(glibc)，是软连接到在Linux系统中基本的命令，有很多可执行文件都会依赖这个共享库。当不小心把这个库改名字或者移走了，都会导致不同程度的异常，可以借助LD_PRELOAD变量和"ldconfig"命令来恢复这个共享库。前提是终端没有断开的情况下操作。
libc.so.6是一个类似于WINDOWS下的一个快捷指向型的文件，而 linux有两种库，分别为：glibc、libc
说明 libc 是Linux下的ANSI C 函数库；glibc 是Linux下的GUN C 函数库： 2、操作流程 作系统版本是：Red Hat Enterprise Linux Server release 6.8 1、问题出现 因为笔者这里是直接在生产环境上操作，当时是做软连接没成功，报错：文件已存在，软连接失败。于是我们就想着把它给移走。还没来得及做新软链就直接导致报错。
基本上非系统命令都有这一条 libc.so.6 =&gt; /lib64/libc.so.6 ,因此libc.so.6至关重要，绝对不能删，不能改名，不能移走，能不能覆盖就不知道了，想作死的可以试试 [root@IDC-Redhat 6.8]# ln -s /home/david/libc-2.17.so /lib64/libc.so.6 ln: creating symbolic link `/lib64/libc.so.6': File exists [root@IDC-Redhat 6.8]# mv /lib64/libc.so.6 . who: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory awk: error while loading shared libraries: libc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d06c3b15ac0c5a3edefc65b877eb301a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f70430502dbefaced1e97e8011e524/" rel="bookmark">
			Pycharm及VScode 安装Copilot 踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在官网申请copilot使用权限，经过一段时间等待，就会给你授权。接下来就是针对本地的IDE集成插件对于VSCode，直接按照官网教学（VScode插件安装）即可，没有什么坑，直接安装就能使用对于pycharm，就是踩了坑。本人pycharm更新至最新版本，2022.1，然后按照官网教学（Pycharm插件安装），安装了最新的copilot插件。全部安装完毕以后，准备开始试用，连接到GitHub账号时就出现了如下的错误： Failed to initiate the GitHub login process. Please try again.
显示没办法连接，只能上网搜罗办法。
尝试了添加代理，修改DNS，都没有成功。
后面尝试把copilot版本降级，下载到1.1.20.1417版本，然后一切安装完毕后，pycharm右下角提示该版本与pycharm版本不兼容，copilot无法正常使用，请尽快更新。这不是逗我呢吗？
最后，功夫不负有心人，找到了最佳解决方案（原答案链接）
首先，pycharm最新版本（我的是2022.1），copilot安装最新版本，关闭pycharm
然后，下载copilot 1.1.20.1417版本文件（地址），并解压，找到github-copilot-intellij-1.1.20.1417\github-copilot-intellij\lib 路径下的core-1.1.20.jar 文件，同时复制它
接下来很关键，找到下面的路径，其中XXX是电脑的用户名
C:\Users\XXX\AppData\Roaming\JetBrains\IdeaIC2022.1\plugins\github-copilot-intellij\lib
将该路径中的core.jar文件，替换成 core-1.1.20.jar
最后，打开pycharm，至此就可以发现能够正常使用Copilot了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94daa2842645660565cdadcb304ed6f7/" rel="bookmark">
			Android studio实现财务记账系统软件android studio开发课程设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android 开发一个记账系统 Android 开发一个理财记账系统软件(app)的详细实验步骤，内附有源码，小白也能轻松上手自己的软件开发项目学生可当课程设计学习使用。
文章目录 android 开发一个记账系统一、app功能预览介绍二、app 制作实验步骤报告实验一、数据库的创建1、实验名称2．实验目的3．实验内容3.1、程序清单3.2 程序思想3.3 程序代码3.4 实验截图4、问题及解决方法 实验二、实体类的创建1、实验名称2、实验目的3、实验工具4、实验内容4.2、程序思想4.3、实验图示4.4、程序代码 5、问题及解决方法 实验三、操作类的创建1、实验名称2、实验目的3、实验工具4、实验内容4.1、程序清单4.2、程序思想4.3、实验图示4.4、实验代码 5、问题及解决方法、实验总结 实验四、登录活动页1、实验名称2、实验目的3、实验工具4、实验内容4.1、程序清单4.2、程序思想4.3、实验效果4.4、实验代码 5、问题及解决方法 实验五、修改密码活动页1、实验名称2、实验目的3、实验工具4、实验内容4.1、程序清单4.2、程序思想4.3、实验效果 4.4、实验代码5、问题及解决方法 实验六、主活动页1、实验名称2、实验目的3、实验工具4、实验内容4.1、程序清单4.2、程序思想4.3、实验效果4.4、实验代码 5、问题及解决办法 实验七、新增收入活动页1、实验名称2、实验目的3、实验工具4、实验内容4.1、程序清单4.2、程序思想4.3、实验效果4.4、实验代码 5、问题及解决办法 实验八、显示收入活动页1、实验名称2、实验目的3、实验工具4、实验内容4.1、程序清单4.2、程序思想4.3、实验效果4.4、实验代码 5、问题及解决办法 实验九、修改与删除活动页1、实验名称2、实验目的3、实验工具4、实验内容4.1、程序清单4.2、程序思想4.3、实验效果4.4、实验代码 5、问题及解决方法 实验十、ListView主页面1、实验名称2、实验目的3、实验工具4、实验内容4.1、程序清单4.2、程序思想4.3、实验效果4.4、实验代码 一、app功能预览介绍 系统登录/退出
设置/修改密码
主活动页面设计
增加收入记录页面
查看收入记录页面
修改和删除记录页面
二、app 制作实验步骤报告 实验一、数据库的创建 1、实验名称 数据库的创建
2．实验目的 学习创建android 项目文件的方法，并且掌握Android的文档结构，熟悉Android的语法规则。
3．实验内容 本次实验旨在Windows环境下Idea开发环境中，新建APP空项目。构建DBOpenHelper类。DBOpenHelper类是SQLiteOpenHelper的父类。在该类中构建数据库User.db，且创建表pwd_tb和user_tb。表结构如下表1与表2所示。在表中增加数据行。Tb_pwd表只有一条记录，是进入系统的唯一密码。Tb_User表中有多条记录。用Navicat软件打开下载的SqLite数据库进行查看。
3.1、程序清单 （1）MyDbProject项目
（2）DbContent.java
（3）Navicat软件
3.2 程序思想 构建DbContent类继承SQLiteOpenHelper类，重写它的2个抽象方法onCreate和onUpgrade()。根据表1，得到创建tb_pwd的表SQL句：create table pwd_tb (pwd varchar(20) primary key)")；根据表2，得到创建user_tb表的SQL语句：create table user_tb(id integer primary key autoincrement, money decimal, time varchar(10),type varchar(10),payer varchar(100),note varchar(200)。在onCreate方法中创建两个表。在onUpgrade()方法中删除两个表后，再构建两个表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94daa2842645660565cdadcb304ed6f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247a4421db26440279f4649dfca48999/" rel="bookmark">
			maven Java错误: 找不到或无法加载主类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 今天在接手一个项目的时候，运行main类报了这个错错误: 找不到或无法加载主类 XXX经过好一番查证才找出了问题所在，原因是maven项目的&lt;scope&gt;provided&lt;/scope&gt;导致的，现在记录一下。
二、测试代码 import org.apache.flink.table.functions.ScalarFunction; public class Test extends ScalarFunction { public static void main(String[] args) { System.out.println("test"); } } 该类继承了flink的ScalarFunction，但是maven的pom.xml文件是这么写的依赖；
&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner_2.11&lt;/artifactId&gt; &lt;version&gt;1.8.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 问题就出在了&lt;scope&gt;provided&lt;/scope&gt;上，经查找官网得知，具有此范围的依赖项会添加到用于编译和测试的类路径中，但不会添加到运行时类路径中，交由JDK 或容器在运行时提供依赖项。因此本地运行的时候就报了找不到或无法加载主类，而放在服务器，因为容器在运行时提供依赖项，所以运行没问题。
官网地址：https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#
三、总结 遇到问题要逐步分析，分解问题，锁定问题根源；另外要多看官网文档！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0d483dfbca4689b66c4e6474451dc5/" rel="bookmark">
			springboot或者springsecurity跨域问题 ---简单有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
springboot后端配置解决跨域
为什么会出现跨域问题？ 首先一个定义一定要了解，就是浏览器的同源策略
什么是浏览器的同源策略， 简单来说就是浏览器发送请求的协议、域名和端口要和服务器接收请求的协议、域名以及端口一致。这样才能完成交互，但是很显然这样是不可能的，尤其在对于在同一台电脑上开发前后端分离的项目的时候，一定是会使用两个端口的。那么这样就形成了跨域问题。 其中有俩种方法解决，一种是在前端配置跨域代理，第二种是后端新建一个配置类
在这里只介绍第一种，因为最为简便
springboot后端配置解决跨域 springboot框架的后端想要解决跨域问题，只需要添加一个类叫CorsConfig，并且让它实现WebMvcConfigurer接口，就完事了
package com.example.springboot_test.config; import org.springframework.context.annotation.Configuration; import org.thymeleaf.util.StringUtils; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * 跨域过滤器 * @author owen * @since 2022/5/1 20:53 */ @Configuration public class CorsConfig implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; HttpServletRequest request = (HttpServletRequest) req; // 不使用*，自动适配跨域域名，避免携带Cookie时失效 String origin = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b0d483dfbca4689b66c4e6474451dc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0caefd48e4a8ac01530994f4637d5fb4/" rel="bookmark">
			Java详细讲解OOP面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。
对于Java，简单来说oop就是将某种现实生活中的东西用编程语言来描述(即变成类)。
对象：现实生活中客观存在的，万物皆可为对象，是类对应的实体，不同的对象有不同或者相同的运动规律和内部属性，对象之间存在交互和复杂的关系
类：是将现实中的对象抽象成java代码世界中的类(建模)，用来封装对象的相关数据和处理这些数据的方法，当java中的一个类被创建/实例化(类--&gt;对象)后就会加载进入内存
类是抽象的，而对象是具体的，换言而之，类相当于狗，类相当于哈士奇，哈士奇是狗类。
变量 变量类似于高中数学课上定义的x或者y这样的未知数，他们的值由自己定义
类变量：static修饰的变量成员变量，可以通过类型/类名访问
实例变量：没有static修饰的成员变量，必须通过实例对象访问
成员变量：java中，成员变量是指在类体的变量部分中定义的变量，也称为属性。成员变量声明在类中，方法体之外，在创建对象时实例化；成员变量可被类中的方法、构造方法以及特定类的语句块访问。如果声明成员变量时没对其初始化，则系统会使用默认值初始化成员
全局变量：定义在类中，作用于整个类，要考虑线程安全
局部变量：定义在方法中，只作用于某一块
类中的static代码块的特点：
在类加载完成，进行初始化时执行，且整个生命周期只被执行一次，一般的可用于资源初始化，使用过数据库的一定知道DBHelper这个类，它是数据库连接类，在这个类中的第一步就是加载数据库驱动资源，其代码就写在static代码块中： 修饰符 访问修饰符 public、protected、friendly(默认)、private
作用域当前类同一包中的类子类其他包中的类public√√√√protected√√√×friendly√√××private√××× 为提高安全性，在开发过程中尽量选择较小的修饰符
abstract： 抽象修饰服，当类添加abstract修饰符不能实例化对象，是对类的建模，常用于定义公共的属性让其子类们继承。抽象类中可以写抽象方法(在方法前加入abstract)，当方法添加抽象修饰符，该方法不再具有方法体，用来规范继承该类的方法（动物都需要跑的方法，狗用四条腿跑，鸡用两条腿跑），抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类
final：最终类，不能有子类，在java中的游戏工具类会用final修饰符修饰，其目的就是为了让使用者只能直接实例化使用，不能修改和继承，常用于定义常量
封装 封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别
继承 概念：继承的英文是extends，继承在java中存在的原因是因为在现实世界中存在着事物的分类，比如“花”是一个大类，而不同品种的花就是不同的小类，小类中即有大类的相关特征又具备自己的特征
这种分类的现象中代码中被形容成了继承，即父类和子类的关系，子类可以继承父类，具备父类的方法，也可以添加自己的方法，或者重写父类的方法，方法就是现实生活中事物的各种动作、行为
作用：其重要作用就是实现多态(下面会讲)，除此之外还可以复用父类的代码，提高代码利用率
多态 概念 多态是同一个行为具有多个不同表现形式或形态的能力。
同样的类型(如动物类和狮子类，老虎类...)，因为不同的实例产生不同的行为
类之间的关系也是一种多态的体现：类的对象对同一消息作出不同的响应，这些不同类要么是继承了相同的父类，要么是实现了相同的接口
作用 解耦，各种设计模式的基础
条件 有继承或实现关系子类重写父类的方法实现同一接口使用父类或接口类型来引用子类或接口的实现类(里氏替换)，即一个父类可以继承的子类是多个的，比如人这个父类就可以继承男人，女人，按国家分就有更多了 特殊情况
static方法，因为被static修饰的方法是属于类的，而不是属于实例的，static方法可以通过类直接访问或获得final修饰的方法，不能被子类不重写private修饰的方法，对子类不可见，更不能被重写protected修饰的方法，虽然子类可见也能重写，但不能再外部引用 方法的概念 方法在现实生活中是事物的各种动作、行为，在java的世界中方法是类的行为(或者叫功能)
方法可以类比为是遥控器上的按钮，不同的按钮触发不同的控制效果
方法不能嵌套定义，即方法中不能再写方法
不能在方法体外直接写逻辑代码（static块除外）
重载（Overload） 一个类里面，方法名字相同，而参数不同，最常用的地方就是构造器的重载的好处：传入不同的方法参数，具有不同的行为。（静态多态或叫编译时多态）
重载的规则：
必须改变参数列表(参数个数或类型不一样)可以改变返回类型可以改变访问修饰符可以声明新的或更广的检查异常方法能够在同一个类中或者在一个子类中被重载无法以返回值类型作为重载函数的区分标准 重写（Override） 是子类对父类的允许访问的方法的实现过程进行重新编写，但返回值和形参都不能改变 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。（运行时多态或叫动态多态 ，继承类，实现接口也是动态多态 ）
重写的规则：
参数列表必须完全与被重写方法的相同返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（说明：java5 及更早版本返回类型要一样，java7 及更高版本可以不同）访问权限不能比父类中被重写的方法的访问权限更低，例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected父类的成员方法只能被它的子类重写声明为 final 的方法不能被重写（最终方法，不能被重写）声明为 static 的方法不能被重写，但是能够被再次声明子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法构造方法不能被重写重写的方法能够抛出任何【非强制异常】，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的【强制性异常】，或者比被重写方法声明的更广泛的【强制性异常】，反之则可以 接口 接口中所有方法均为抽象方法（jdk8之后不太合适）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0caefd48e4a8ac01530994f4637d5fb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7f4de8a8cfc9e4909d667c59fd91f9/" rel="bookmark">
			2022年T电梯修理考试题库及在线模拟考试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
2022年T电梯修理考题为T电梯修理考试100题的新全考试题型！2022年T电梯修理考试题库及在线模拟考试依据T电梯修理考试大纲。T电梯修理考试真题随时根据安全生产模拟考试一点通错题强化。
1、【多选题】TSG5002-2017《电梯维护保养规则》规定：电梯维修保养，应做的记录。一般包括电梯基本参数、使用单位、地点、编号，还有（）。（ ABCD ）
A、维保内容
B、维保单位
C、维保人员
D、维保日期
2、【多选题】万用表，主要用来测量（）。（ ABD ）
A、交、直流电压
B、交、直流电流
C、绝缘电阻
D、电阻阻值
3、【多选题】断路器，的主要作用有（）。（ ABCD ）
A、接通电路
B、断开电路
C、短路保护
D、过载保护
4、【多选题】曳引电梯，实现上行超速保护的措施，可以作用在（）上。（ ABCD ）
A、对重
B、曳引绳
C、轿厢
D、曳引轮
5、【多选题】消防返回基站的功能，一般包含有（）。（ ABCD ）
A、消除内外指令登记
B、上行时就近停站后不开门返回基站
C、下行时直接返回基站
D、正在开门走人中立即关门返回基站
6、【多选题】自动扶梯的停止方式，有（）。（ AB ）
A、手动停车
B、自动停车
C、强制停车
D、遥控停车
7、【多选题】（）检验和（）检验，是对电梯生产和使用单位的查证性检验。（ AB ）
A、监督
B、定期
C、短期
D、长期
8、【单选题】《电梯使用管理与维护保养规则》规定：电梯维保单位应制定应急措施和救援预案，每（）至少针对本单位维保的不同类别电梯进行一次应急演练。（ B ）
A、三个月
B、半年
C、九个月
D、一年
9、【单选题】三相交流电源的相电压是指（）与（）之间的电压。（ B ）
A、火线；火线
B、火线；中性线
C、零线；中性线
D、中性线；零线
10、【单选题】几个不等值的电阻并联，每个电阻上的电压的相互关系是（）。（ C ）
A、阻值大的电压大
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e7f4de8a8cfc9e4909d667c59fd91f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991337deb4ed5b1c0f6414d431ba5f60/" rel="bookmark">
			计算机中的单位换算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 基本单位 信息存储量是度量存储器存放程序和数据的数量。
位（Bit）：计算机当中最小的信息单位 存放一个二进制位数，即 0 或 1字节（Byte）：计算机中的基本信息单位 常用的单位字（Word）：有字节组成 字长：字的位数字长越长，计算机性能越好千字节（KB） 容量单位： 位（bit）-&gt; 字节 B -&gt; 千字节 KB -&gt; 兆字节 MB -&gt; 吉字节 GB -&gt; TB -&gt; PB -&gt; EB、ZB、YB 、NB、DB等 2 单位换算 1字节(Byte) = 8位(bit) 2^3方
1KB( K，千字节) = 1024B 2^10方
1MB( M，兆字节) = 1024KB
1GB( G，吉字节，千兆) = 1024MB
1TB( T，万亿字节，太字节) = 1024GB
1PB( P，千万亿字节，拍字节) = 1024TB
1EB( E，百亿亿字节，艾字节) = 1024PB
单位之间：2的n次方关系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8affff6f004a428caade95ca4c0c0d/" rel="bookmark">
			深大操作系统实验-简易文件系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题描述
设计思路
文件逻辑设计
用到的常量及数据结构
一些基础功能接口（从小到大）
对位图进行操作（位运算）
对数据块进行操作（释放，申请，调用上面的位图控制函数实现）
文件创建与删除
文件的读取和修改
文件夹的创建和删除
cd和ls指令
其他辅助功能函数
进程同步
总结
问题描述 1.创建一个100M的文件或者创建一个100M的共享内存
2.尝试自行设计一个C语言小程序，使用步骤1分配的100M空间（共享内存或mmap），然后假设这100M空间为一个空白磁盘，设计一个简单的文件系统管理这个空白磁盘，给出文件和目录管理的基本数据结构，并画出文件系统基本结构图，以及基本操作接口。
3.在步骤1的基础上实现部分文件操作接口操作，创建目录mkdir，删除目录rmdir，修改名称，创建文件open，修改文件，删除文件rm，查看文件系统目录结构ls。
4.参考进程同步的相关章节，通过信号量机制实现多个终端对上述文件系统的互斥访问，系统中的一个文件允许多个进程读，不允许写操作；或者只允许一个写操作，不允许读。
设计思路 模拟FAT文件系统（软硬链接没做出来，数据结构也不支持，寄）
首先100MB中拿出4MB作为文件管理系统的核心（存放位图，inode数组等等），100MB大小空间安排如下：
对于后面的96MB，以4KB一页为单位，共24576页，对每一页使用1bit表示是否被占用，这个位图也存放在用于文件系统管理的4MB中。由于文件分页存储，用FAT表显式表达文件占用的数据页的跳转情况。
每个文件和文件夹都占用一个inode，inode内记录当前文件类型（目录还是可读写文件），父节点、左右兄弟节点（这个下面解释）、子结点的inode编号以及对应的FCB编号。
FCB用于记录文件名，一开始的设想是包含软、硬链接的功能，因此FCB的设定数量上限为inode的两倍，但实际实现起来过于复杂，FCB与inode一一对应。
4MB管理核心结构：
文件逻辑设计 如果区分一个inode是目录还是文件，对应不同类型的FCB，管理起来十分混乱，并且如果设置文件FCB和目录FCB，两种FCB储存的信息大小不一致，也不方便读取，因此采用所有文件都包含子结点inode编号的方式。（反正没有软硬链接要求，怎么方便怎么来）
由于这种结构下的文件目录是一棵多叉树，不确定一个目录下有多少个子结点，因此采用“孩子兄弟表示法”，图示：
用到的常量及数据结构 常量声明：
// 一个数据块大小 #define BLOCK_SIZE 4096 // 96MB对应24576个数据块 #define BLOCK_NUM 24576 // 每块对应1bit, 需要3072bytes表示 #define BLOCK_MAP_LENGTH 3072 // inode最多每块一个, 共24576个 #define INODE_MAP_LENGTH 3072 // FCB考虑后续可能有硬链接、软链接等, 开多一倍 #define FCB_MAP_LENGTH 6144 // 硬盘管理核心占4MB(剩余96MB) #define CORE_SIZE (1 &lt;&lt; 22) 下面是用到的数据结构：
// 32 bytes struct Inode { int file_type; // 文件类型, 0是文件夹, 1是可读写文件 int iblock; // 文件数据块起始下标(在FAT表中进行跳转) int size; // 文件大小, 可在touch创建文件时指定, 可大于内容长度 int parent_inode_number; // 父节点(当前所处文件夹)inode下标 int child_inode_number; // 第一个子节点下标 int brother_inode_number_left; // 左兄弟节点inode下标 int brother_inode_number_right; // 右兄弟inode下标 int FCB_number; // 该文件对应FCB下标 }; // 16 bytes struct FCB { int inode; // 该FCB对应inode下标 char FileName[12]; // 文件名 }; // 4KB union BlockMap { char block_map[BLOCK_MAP_LENGTH]; char temp[BLOCK_SIZE]; // 撑开一个数据块 }; // 789504 bytes struct InodeArray { char inode_map[INODE_MAP_LENGTH]; struct Inode inode_array[BLOCK_NUM]; }; // 792576 bytes struct FCBArray { char FCB_map[FCB_MAP_LENGTH]; struct FCB FCB_array[BLOCK_NUM &lt;&lt; 1]; }; // 790528 bytes -&gt; 772KB -&gt; 193 * 4KB union InodeArrayBlock { struct InodeArray inode_array; char temp[790528]; }; // 194 * 4KB union FCBArrayBlock { struct FCBArray fcb_array; char temp[794624]; }; // 1648 KB + 8 bytes struct SystemCore { int block_used; // 已使用的数据块, int block_rest; // 剩余空闲的数据块, union BlockMap bit_map; // 4KB union InodeArrayBlock inode_array; // 193 * 4KB union FCBArrayBlock FCB_array; // 194 * 4KB int FAT[24576]; // 96KB }; // 4MB union SystemCore_union { struct SystemCore core; char temp[1 &lt;&lt; 22]; }; // 管理信号量的数据结构 union semun { int val; struct semid_ds *buf; unsigned short *arry; }; （ps：好几个地方用了union为了撑开一页，实际上没必要，后面写接口调用起来也麻烦。本来打算再包多一层，把100MB都放在一个结构体内，懒了）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c8affff6f004a428caade95ca4c0c0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dee2836959de8c8af3e6c933d7898a3/" rel="bookmark">
			FileZilla上传文件出现数据丢失问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： 做好的原型图需要通过ftp文件上传到公司内部的文档中，问了同事说用FileZilla，于是去官网下载了FileZilla，但在上传完成后，发现原型图中的文字等内容和自己的原型图并不一致，出现语句不通顺，漏字，顺序错误等问题。
如下图：
本来的文字：
上传后的文字：
解决方案： 经尝试，发现是传输问题导致的。FileZilla有两种传输方式，ASCII与二进制。之前默认的自动。我将传输方式修改成ASCII后问题解决。（传输-&gt;传输类型-&gt;ASCII）
总结分析： 用HTML和文本编写的文件必须用ASCII模式上传，用二进制模式上传会破坏文件，导致文件执行出错。二进制模式用来传送可执行文件（.exe），压缩文件，图片文件。如果用ASCII模式上传，会显示一堆乱码。我的原型图是通过发布成HTML上传的，故应该采用ASCII模式上传。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe4fb3d0006fcf06383c47d1f2af7fe/" rel="bookmark">
			银河麒麟服务器操作系统扩容swap分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，创建10G大小的swap分区
fallocate -l 10G /usr/swapfile
2，修改swapfile文件的权限：
chmod 600 /usr/swapfile
3，将swapfile 初始化为交换文件：
mkswap /usr/swapfile
4，然后开启swap.
swapon /usr/swapfile
5，查看是否配置成功：
free -g
6，将swap分区挂在信息写入 /etc/fstab 文件内
[root@local ~]# vim /etc/fstab
/usr/swapfile swap swap defaults 0 0 添加这行进去
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edadbd5ca77dfe88f71e54e5cde036d7/" rel="bookmark">
			Tomcat服务器下载、安装、配置环境变量教程(超详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		未经我的允许，请不要转载我的文章，在此郑重声明！！！ 我以 博客专家 和 高访问量 担保，本篇文章可以解决你的问题，若未解决，加Q群，远程操作：564989410
请先配置安装好Java的环境，若没有安装，请参照我博客上的步骤进行安装！
若不知道Java环境是否已经安装配置环境完成，cmd窗口输入 java 回车，之后再打开环境变量，参考 安装Java环境教程 打开，看看有没有JAVA_HOME。如果已经配置过，请忽略！
目录 Tomcat下载教程
JDK、Tomcat安装视频教程 Tomcat安装教程
Tomcat配置环境变量教程 Tomcat启动和验证配置环境变量是否成功
Tomcat部署项目
常见问题
问题一·正常运行却访问不了
问题二·出现乱码
问题三·出现Access Error:404 -- Not Found
问题四·经过一系列修改后还是启动闪退
Tomcat下载教程 请不要跳着看，仔细看，直到文章末尾
首先确定你Windows系统是64位，还是32位(现在大部分是64位)
查看操作系统位数步骤:(WindowsXP,Windows7,Windows8,Windows10查看步骤大同小异，举例Windows10)
请先确认你的JDK版本
请先确认你的JDK版本
请先确认你的JDK版本
Tomcat在 JDK1.8 环境下能够正常运行，请确认JDK版本（在cmd窗口输入 java -version），如果是在12.0版本，1.7版本，Tomcat不能够正常启动！其他JDK版本不清楚，没有具体测试运行！
1.8版本JDK下载 Windows配置Java环境变量(下载、安装、配置环境)_第三女神程忆难的博客-CSDN博客_配置java环境变量
Windows键+E 组合键打开页面
JDK、Tomcat安装视频教程 视频源：JDK以及Tomcat安装教程_哔哩哔哩_bilibili
JDK以及Tomcat安装教程（自备JDK1.8和Tomcat9.0）
确定好后进入官网下载Tomcat，官网地址-点击进入 Apache Tomcat® - Welcome!
选择左侧的Tomcat版本，本篇文章举例Tomcat9，其它的版本安装都一样
点击Tomcat9
进入Tomcat9下载页面
对应着操作系统位数进行下载，下载后会是一个zip压缩包
Tomcat安装教程 解压压缩包，放在想要放在的盘符(D盘、E盘...无所谓，记着路径就可以，但最好不要是C盘，可能会出现拒绝访问)
就比如安装在D盘，那就解压出来放在D盘下就行，里面的文件名不要改动，或者放在D盘某一文件夹下，路径不要包含中文和特殊字符！
这一句话说的太苛刻了，你若熟悉安装，可以不用按我说的来
放到这里即可
Tomcat配置环境变量教程 环境变量配置就如上述的 下载教程 ，进入如下页面
点击高级系统设置
选中高级，点击环境变量
在系统变量栏中选择新建
之后出现如下图，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edadbd5ca77dfe88f71e54e5cde036d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad23103e2ca2220f61d0734ee82d6bac/" rel="bookmark">
			银河麒麟服务器虚拟化出现主机无法激活问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		银河麒麟服务器虚拟化系统不仅能够提供扩展性好、运行稳定的虚拟化服务器平台，还能提供统一、高效的虚拟化资源管理、配置和监控平台，更能提供实施高效的实体机与虚拟机之间资源迁移解决方案，它将帮助广大中小企业快速建立易用、高效的虚拟化实施平台。
虚拟化平台物理机无法激活，显示non operational
查看事件报错
首先根据上述报错信息，判断可能是电源管理问题，进行删除电源管理操作，取消勾选“启用电源管理”
重新激活主机还是不行。
再次查看ovirt-engine日志，通过tail -f engine.log的日志可看出vl1000的网络设备报错
再次进入ovirt管理平台，查看主机网络，发现vlan1000网卡设备掉了
重新绑定网卡，再次激活，顺利解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e87bc32828d07c393ae03912e9341f/" rel="bookmark">
			Java中int和long类型的取值范围及int类型最小值为什么是-2147483648而不是-2147483647
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int型变量的取值范围 java中int数据类型占4个字节，32位
取值范围是-2^31 (-2147483648)~ 2^31-1(2147483647)
long型变量的取值范围 java中long数据类型占8个字节，64位
取值范围是-2^64 (-9223372036854775808)~ 2^64-1(9223372036854775807)
int类型最小值为什么是-2147483648而不是-2147483647 在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。而在补码中0是唯一的
正负0的补码是唯一的：00000000 00000000 00000000 00000000
最大值：01111111 11111111 11111111 11111111
最小值：10000000 00000000 00000000 00000000
在计算机中int类型如果溢出了怎么办？计算机中是不溢出符号位的即符号位进位不补位，正溢出则变负最小，负溢出变正最大，形成一个环。
首先看最大值加1的效果：01111111 11111111 11111111 11111111 + 1 = 10000000 00000000 00000000 00000000
再看最小值减1的效果：10000000 00000000 00000000 00000000 - 1 = 01111111 11111111 11111111 11111111
我们再看一下-2147483647的补码：由原码11111111 11111111 11111111 11111111取反得10000000 00000000 00000000 00000000在加1得补码10000000 00000000 00000000 00000001也是最小值加1得到的值
因为正负0的补码是唯一的，所以在-2147483647到2147483647之间没有一个数的补码是10000000 00000000 00000000 00000000，同时为了形成一个环，所以用10000000 00000000 00000000 00000000来表示最小值-2147483648
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/badfa2b27698b3ab6c26eb68c61de703/" rel="bookmark">
			SpringMVC的简单介绍及其使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC 1 概念 1.1 SpringMVC是？ SpringMVC框架作用在servlet层。
Spring MVC是基于Spring的一个模块，专门做web开发，可以理解为是Servlet的升级
1.2 MVC架构 M----model(模型)
一般情况下用于封装数据
如分页模型(Pagebean)封装了分页所需要的数据
V----view(视图)
通常视图是依据模型数据创建的
C------controller(控制器)
通常用于处理业务逻辑
2 SpringMVC环境搭建 引入依赖
&lt;properties&gt; &lt;spring.verion&gt;5.0.2.RELEASE&lt;/spring.verion&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.verion}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.verion}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.verion}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置springMVC.xml文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置创建 spring 容器要扫描的包 --&gt; &lt;context:component-scan base-package="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/badfa2b27698b3ab6c26eb68c61de703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52cec6fa9d8b3cbd39ce1b40564eb333/" rel="bookmark">
			各大图床对比（对象存储）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写本文的初衷是因为 Gitee 图床挂了，导致很多人的个人博客或者笔记的图片都无法显示了。越想越气，这就是所谓开源中国。
前言 目前我使用过的免费图床
GiteeGitHub Gitee 于2022年3月25日开启了防盗链，博客笔记中引用的图片无法显示，所以用不了（Issues中一片哀嚎）。
GitHub 因为服务器是在国外，国内可以通过修改 host 来访问 ，其实实际体验效果都不好，只能通过翻墙才是最优解。
其他的图床，比如 SM.MS，网上评论说也有失效情况，本人没有使用过，不多说了。
经过 Gitee 这次的惨痛教训，本人打算使用付费的对象存储服务。
对象存储 需求：
个人用户
各大平台产品选择标准存储，其他类型产品不推荐（不同产品的区别可以参照官网，各大平台差不多）。
以下信息，于2022年3月26日统计，都是从各自官网查询得到，绝对真实
七牛云Kodo 官方介绍：对象存储 Kodo_云存储_海量安全高可靠云存储_oss - 七牛云 (qiniu.com)
计费案例 以下案例单价来自 2022 年 3 月 15 日七牛云官网公布的详细价格信息。单价的变动请以七牛云官网发布的数据为准。
标准存储月费用计算 赵先生在七牛云(华南区域)存储了 500GB 标准存储类型文件，每天的PUT/DELETE请求数均值为 10000 次，GET 请求次数为 50000 次，每天通过七牛 CDN 回源流出的流量约为 3 GB，则赵先生当月需支付费用约 61.21 元。
存储费用=(500GB-10GB) * 0.099元/GB/月=48.51 元
标准存储有10GB的免费空间额度PUT/DELETE请求费用=(10000次/天 * 30天-100000次) * 0.01元/10000次=0.2 元
标准存储有10万次的 PUT/DELETE 请求免费额度GET 请求费用=(50000次/天 * 30天-1000000次) * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52cec6fa9d8b3cbd39ce1b40564eb333/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c352b6e914f4265b9552deadefb9a8c/" rel="bookmark">
			MySql安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：该过程在较理想状态下实现，安装过程中可能会遇到问题；下面案例仅供参考。
可能遇到的问题：
由于找不到vcruntime140_1.dll,无法继续执行代码
解决方法: 这是缺少了动态链接库(.ddl文件), 跟mysql无关, 下载这个ddl文件即可。
网盘链接：https://pan.baidu.com/s/1R1uh9HfyFi34LS380lokbw?pwd=hi8s
提取码：hi8s
下载完成 解压后将vcruntime140_1.dll复制到C:\Windows\System32即可。
很多问题通过网络搜索是可以得到很好的解决方案的，希望友友安装顺利！！
一、下载MySQL 下载网址：https://dev.mysql.com/downloads/
下载完成后解压到某一个文件夹（记住该文件夹路径）
二、配置初始化文件my.ini 找到安装目录 在该文件夹下新建 my.ini 文件（先新建文本文档 然后更改后缀名为 .ini ）将下面的代码写入（以下代码除安装目录和数据的存放目录需修改，其余不用修改）
[mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 -----**这里是你的文件路径**----- basedir=D:\mysql\mysql-8.0.28-winx64\mysql-8.0.28-winx64 # mysql数据库的数据的存放目录 （data文件夹之后会自动生成） datadir=D:\mysql\mysql-8.0.28-winx64\mysql-8.0.28-winx64\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。 max_connect_errors=10 # 服务端使用的字符集默认为utf8mb4 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 #mysql_native_password default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8mb4 三.设置环境变量 三.初始化MySQL环境 右击电脑左下方"开始"点击Windows Powershell(管理员）进入界面
键入下面代码：
（路径需要按照自己的修改）
mysqld --defaults-file=D:\mysql\mysql-8.0.28-winx64\mysql-8.0.28-winx64\my.ini --initialize --console 框中为mysql初始密码（之后用来进入MySQL服务）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c352b6e914f4265b9552deadefb9a8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbb8d665eebe892e043cde028f8816f/" rel="bookmark">
			前端八股文(Vue部分) -不断更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是单向绑定?什么是双向绑定? 单向绑定:修改data中初始化的数据,则Vue管理的页面的模板中的数据随之发生改动,这就叫单向绑定,也被称之为数据实现了可响应式,大虎子表达式和指令语法中的指令都支持单向绑定(数据可响应式)双向绑定:修改Vue管理的模板中的数据,则data初始化的值随之发生改动,这就叫双向绑定,v-model天生支持双向绑定,其它数据如果想支持双向绑定则必须使用计算属性 2. 什么MVVM思想 MVVM主打口号: 数据驱动视图！
根据技术的特点将其分为三层M:model(模型层):就是指data中封装的各种数据V:view(视图层):就是指页面的模板VM:viewmodel(视图模型):就是指我们创建的Vue实例Vue提供了一种MVVM绑定思想,当我们修改M层中的数据时,通过VM层可以同时修改绑定在V层上的数据(单向绑定,数据的可响应式),当我们修改V层中的数据时,则通过VM层可以同时修改M层中的数据(双向绑定)如下图:
3. 在Vue2中函数 计算属性 侦听器的不同,使用场合? 函数 多绑定激发事件,也可以绑定v-model直接调用,或者调用在大胡子表达式中,只有单向绑定功能无法实现双向绑定,函数没有缓存机制,只要被调用不管数据是否发生更改都会执行,注意平时我们如果绑定事件,没有参数,则函数没有括号 @click=“demo” 计算属性 依赖现有的属性(初始化的值)通过计算返回一个新的属性,这个属性是最终计算得来的也会被看做一个属性初始化在Vue实例根属性中,只要依赖的属性发生了更改,则计算属性重新执行,计算属性存在缓存机制,只要依赖属性没有发生变化,则不会再次执行,仅仅读取缓存中已经计算出的值,在页面中如果存在多个相同的计算属性,则效率大大高于多个相同的函数,计算属性可以同时支持单双向绑定功能,getter函数代表单向,setter函数代表双向功能 侦听器 一般不考虑单双向绑定问题,用来侦听某个值的变换,只要这个值发生更改,则侦听器执行,如果设置了immediate属性,则可以立即执行侦听器,侦听器默认只能侦听基本数据类型,如果要侦听复杂类型,则必须添加 deep:true 开启深度侦听功能 计算属性能做的事,侦听器都能做,侦听器能做的事,计算属性不一定能做,由于计算属性在书写单向绑定时必须书写return,所以无法书写异步代码 4. Vue如何进行样式渲染? :class=“test1” :class=“初始化的值”:class=“{box2:flag2,box3:flag3}” :class=“{类名:初始化的值,类名:初始化的值…}”:class=“[‘box4’,‘box5’]” :class=“[类名1,类名2]”:style=“{backgroundColor:val1,color:val2}” 行内式 :style=“{样式名:绑定的值,样式名:绑定的值}” 5. Vue条件渲染中 v-if与v-show的区别 v-if:如果后面绑定的值是真值,则元素显示,如果是假值,则底层不渲染,页面不显示可以取反,由于切换时会导致元素底层的切换,所以一般适用于切换不频繁的场合,因为切换时消耗较大,另外v-if还可以搭配v-else-if 与 v-else使用,通过template标签可以实现复杂逻辑的流程控制v-show:如果后面绑定的值是真值,则元素显示,如果是假值,则底层依然渲染,页面不显示,只不过是添加了一个行内式 display:none; 来隐藏元素,可以取反,初始载入消耗较大,之后切换消耗较少,适用于切换频繁的场合,不能与 v-else-if v-else连用 6. Vue2中事件原型如何使用,如何获取元素节点 无值的情况下=&gt; @click=‘方法’ | methods:{方法(event){…}}有值的情况下=&gt; @click=‘方法(name,$event)’ | methods:{方法(name,event){…}}event.target.value 取元素对象的值 7. 请列举Vue2中的常用事件修饰符 @click.stop=“dothis” 防止事件冒泡 @click套@click会一起执行@click.prevent=“mySub” 去掉元素原本属性 src href action 链接跳转等@click.once=“count++” 点击执行一次 8. Vue2中如何实现对象的可响应式,数组的可响应式 对象: 增 this.$set(this.person,‘location’,‘璃月’)删 this.$delete(this.person,‘name’) 数组 增 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fbb8d665eebe892e043cde028f8816f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbecbe99c26fbbe81afb32de88579c6b/" rel="bookmark">
			GPIO工作模式详解（含Arduino实例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. GPIO介绍 从最基础的51单片机，Arduino，到STM32，树莓派等等，这些上面都会有GPIO口这么一个概念，如果你点开了我这个博客，说明你大概率开始学习单片机，那么你应该了解的就是这些口可以输出高低电平，或者是读取引脚上的输入电平。
GPIO的总述功能如下：
GPIO(general porpose intput output):通用输入输出端口的简称。可以通过软件控制其输出和输入。GPIO引脚与外部设备连接起来，从而实现与外部通信，控制以及数据采集的功能。
下面以STM32内部GPIO口为例的内部原理图，先有一个这个图的概念，下面就是开始讲怎么理解GPIO口。
2. 基础知识介绍 先来一点最基础的知识
上拉和下拉：
当我们闭合上拉电阻的开关，断开下拉电阻的开关的时候，也就是此时为上拉通路导通。根据我们最基础的电路知识，如果I/O口断开不接外设，或者接了外设但是电路也断开，此时整条回路是断路的时候，电阻相当于不存在，此时O点的电位，也就被钳制在了VDD(供电电压正极)，于是O点就处于高电平。
同理，闭合上拉电阻的开关，断开下拉电阻的开关，那么在电路断开的时候，根据电路知识，电阻相当于不存在，O点的电压就就被钳制在了VSS(GND)，也就是O点处于低电平。
数字信号和模拟信号
数字信号：就是根据一些规则，将一个范围内的电压规定为1，一个范围内的电压规定为0，也就是一连串的0,1信号
模拟信号：就是连续的读取到的电压值。
关于图上的TTL施密特触发器和P-MOS和N-MOS，后面讲到对应部分的时候会讲到。
电源符号含义
VDD：D=device 表示芯片内部工作电源（一般VDD&lt;VCC）。端口引脚电路中的VDD表示能够容忍3.3V电压（最大3.6V），如果是VDD_FT则表示能够忍5V。
VSS：S=series 表示公共连接，通常指电路公共接地端电压。
TTL肖特基触发器：即为用肖特基管构成的施密特触发器，施密特触发器利用门阀电压将引脚模拟信号变成矩形信号，进行转化为0/1数字信号存入输入数据寄存器。
什么是推挽结构和推挽电路
推挽结构一般是指两个参数相同的三极管或MOS管分别受两互补信号的控制，总是在一个三极管或MOS管导通的时候另一个截止。高低电平由输出电平决定。
推挽电路是两个参数相同的三极管或MOSFET，以推挽方式存在于电路中，各负责正负半周的波形放大任务。电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出级既提高电路的负载能力，又提高开关速度。
开漏输出和推挽输出的区别
开漏输出：只可以输出强低电平，高电平得靠外部电阻拉高。输出端相当于三极管的集电极。适合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)；
推挽输出:可以输出强高、低电平，连接数字器件。
关于推挽输出和开漏输出，最后用一幅最简单的图形来概括：
该图中左边的便是推挽输出模式，其中比较器输出高电平时下面的PNP三极管截止，而上面NPN三极管导通，输出电平VS+；当比较器输出低电平时则恰恰相反，PNP三极管导通，输出和地相连，为低电平。右边的则可以理解为开漏输出形式，需要接上拉。
3. GPIO八种工作模式 3.1 浮空输入模式 浮空输入模式：数据通道中仅接入TTL触发器（作用是将相对缓慢变化的模拟信号变成矩形信号）整形，随后输入输入数据寄存器，该种工作模式未接入任何上拉/下拉电阻。 模式特点：在该引脚悬空（无信号输入）的情况下，读取该端口的电平是不确定的。 适用场合：外部按键输入/USART RX引脚。
3.2 上拉输入模式 上拉输入模式：与浮空输入模式相比，仅仅是在数据通道前端接入了一个上拉电阻，其余无变化。 模式特点：在无信号输入时端口电位受上拉电阻钳制，I/O端口输入电平始终保持为高电平；而当端口输入电平为低电平时，I/O端口输入电平为低电平。 适用场合：需要IO内部上拉电阻输入时，器件的外部中断（IRQ）引脚触发中断条件为下降沿触发/低电平触发，这样在无信号输入时始终保持高电平，如果有事件触发中断IRQ可以输出一个低电平，进而可产生（下降沿/低电平）中断。例如单片无线收发器芯片NRF24L01的IRQ引脚的工作模式即为上拉输入模式。
3.3 下拉输入模式 下拉输入模式：与浮空输入模式相比，仅仅是在数据通道前端接入了一个下拉电阻，其余无变化。 模式特点：在无信号输入时端口电位受下拉电阻钳制，I/O端口输入电平始终保持为低电平；而当端口输入电平为高电平时，I/O端口输入电平为高电平。 适用场合：需要IO内部下拉电阻输入时，器件的外部中断（IRQ）引脚触发中断条件为上升沿触发/高电平触发时，该端口可以选择下拉输入模式。
对于为什么要加上拉或下拉电阻：
1.当作单片机作为输入时，假设我们直接在IO端口接一个按键到地（或电源）。因为按键按与不按管脚都是悬空的。单片机就很难检测按键是否按下。所以人为的接一个上拉（或下拉）。以确定未按下的时候IO输入电平的状态。
2.可以提高芯片的抗干扰能
3.当单片机的IO口作输出时，如果不接上拉电阻只能提供灌电流。无法输出电流驱动外接设备。这时也需要考虑上拉电阻。这样才可以使IO输出高电平
3.4 模拟输入模式 模拟输入模式：数据通道不接入任何处理单元（TTL触发器/钳制电阻），直接输入MCU内部的处理单元。模拟输入模式下，I/O端口的模拟信号（电压信号，而非电平信号）直接模拟输入到片上外设模块，比如ADC模块等。模拟信号一般：3.3v 5v 9v。
模式特点：相较于其他输入模式只能读取到逻辑高/低电平（数字量），该模式能读取到细微变化的值（模拟量）。 适用场合：ADC模拟输入/低功耗下省电。
3.5 开漏输出模式 开漏输出：适合做电流型的驱动，其吸收电流能力较强。当CPU输出逻辑’0’时，I/O端口输出低电平，而当CPU输出逻辑’1’时，该引脚处于开漏，也就是浮空状态（高阻态），如果想输出高电平则必须接入上拉电阻。同时IO口可以由外部电路改变为低电平或不变，即可读IO输入电平变化，实现了I/O端口的双向功能；此外，可以将多路开漏输出的引脚连接到一条线上，通过一个上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系，这也是I2C，SMBus，等总线判断总线占用状态的原理。
可以输出0和1，适用于电平不匹配场合，要得到高电平需要上拉电阻才行。
开漏输出模式下（上拉电阻+N-MOS管），通过设置位设置/清除寄存器或者输出数据寄存器的值，途经N-MOS管，最终输出到I/O端口。这里要注意N-MOS管，当设置输出的值为高电平的时候，N-MOS管处于关闭状态，此时I/O端口的电平就不会由输出的高低电平决定，而是由I/O端口外部的上拉或者下拉决定；当设置输出的值为低电平的时候，N-MOS管处于开启状态，此时I/O端口的电平就是低电平。同时，I/O端口的电平也可以通过输入电路进行读取；注意，I/O端口的电平不一定是输出的电平。
3.6 开漏复用输出模式 复用开漏输出：与开漏输出特性一致，只不过引脚选择了复用功能，输出的高低电平的来源，不是让CPU直接写输出数据寄存器，取而代之利用片上外设模块的复用功能输出来决定的。适用场合：常见片内外设（I2C/SMBus等等）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbecbe99c26fbbe81afb32de88579c6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a46d58cbfbb488b49316a96d6546ed9/" rel="bookmark">
			SQLite3介绍及SQL语句详解（SQLite一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、SQLite3介绍1.数据库存储数据2.数据库数据类型3.window下qtcreator上编译sqlite3数据 二、SQL语句1.创建数据表格2.插入数据3.查询数据（1）查询（2）条件查询（3）两个条件必须同时成立（与）-and（4）两个条件只要成立一个（或）-or 4. 更新数据5. 删除数据6.查询创建表命令7.alter添加字段8.pragma 查询表结构信息9.创建带约束数据表（1）创建数据表（2）插入数据 10.删除表 一、SQLite3介绍 1.数据库存储数据 数据结构 数据仓库：
2.数据库数据类型 名称数据长度类型int-2^31(-2,147,483,648) 到 2^31(2,147,483,647)整型数字float-1.79E+308到1.79E+308可变精度的数字real-3.04E+38到3.04E+38可变精度的数字char最大长度为8000定长非Unicode的字符型数据varchar最大长度为8000变长非Unicode的字符型数据text最大长度为2^31-1(2G)变长非Unicode的字符型数据 3.window下qtcreator上编译sqlite3数据 在qt creator上创建c语言工程，并且在工程中添加数据代码
把数据代码拷贝到工程目录下在添加–把工程中的main.c里面的主函数名修改下main_test 避免冲突
如果是linux系统要在工程文件中添加 LIBS += -lpthread -ldl
二、SQL语句 数据通用语句 命令行语句结束要加;(分号)
以此为例：
varchar(256)varchar(256)textchar(32)number(编号)name(姓名)address(地址)QQ20200101张三广州91168383020200102李四广州911683831 1.创建数据表格 create table 表名( 字段名 数据类型 ， 字段名 数据类型， 字段名 数据类型， 字段名 数据类型)； 例：
create table student(number varchar(256), name varchar(256), address text, QQ char(32)); 2.插入数据 insert into 表名 values('字段数据'，'字段数据'，'字段数据'，'字段数据' ); 例：
insert into student values('20200101', '张三', '广州','911683830'); insert into student values('20200102', '李四', '广州','911683831'); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a46d58cbfbb488b49316a96d6546ed9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f77ab26be3de8587b8debd91b338edd/" rel="bookmark">
			springboot的基本增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot增删改查 1、根据表中的字段创建实体类UserInfo.java2、编写MybatisController.java3、在postman中访问接口（先启动项目）3-1、增3-2、删3-3、改3-4、查 参考：
springboot搭建
springboot集成mysql
springboot集成mybatis【使用generatorConfig.xml配置自动生成代码】
在集成mysql和mybatis后，对数据进行简单的增删改查操作
参考springboot集成mybatis中的代码继续下面的步骤（springboot集成mybatis【使用generatorConfig.xml配置自动生成代码】）
1、根据表中的字段创建实体类UserInfo.java package com.study.mybatis.entity; import lombok.Data; /** * @Author: JING * @Created: 2022/2/9 15:56 * @Description: * @Version: 1.0.0 * @Since JDK 1.8 */ @Data public class UserInfo { private Integer id; private String userName; private String userId; private String address; } 2、编写MybatisController.java package com.study.mybatis.controller; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.study.mybatis.dao.MybatisUserMapper; import com.study.mybatis.entity.MybatisUser; import com.study.mybatis.entity.MybatisUserImpl; import com.study.mybatis.entity.UserInfo; import org.apache.ibatis.annotations.Param; import org.springframework.beans.factory.annotation.Autowired; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f77ab26be3de8587b8debd91b338edd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b0f5324e018d721bd12516213a6c2c/" rel="bookmark">
			数据表格去重复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发工具与关键技术： VisualStudio2019 C#
作者：可乐沙司
撰写时间：2022.06.18
对于这种表格是怎么实现的，很多同学都不知道怎么把它实现。
今天分享一个很好用的方法：Distinct()
Distinct()：通过使用的默认相等比较器对值进行比较从序列返回非重复元素。
怎么用？
在你联表查询在后面使用，没有加之前，查询出来的这个列表有15条相同的数据，如果加了之后它会只剩下一条数据。
案例：
去重复ID
查询全部数据
将他们的金额相加
效果：
部分代码不完整，有什么问题可以私聊我，谢谢(^_−)☆
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4667637367643e372ffb020bd51b4890/" rel="bookmark">
			2022年氧化工艺考试练习题模拟考试平台操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
2022氧化工艺考试题库为氧化工艺考试题目的多种练习模式！2022年氧化工艺考试练习题模拟考试平台操作根据氧化工艺考试教材。氧化工艺考试100题随时根据安全生产模拟考试一点通上练习全部题库。
1、【单选题】 1等于()桶(bbl)。（ A ）
A、6.29
B、5.32
C、1.69
2、【单选题】 带控制点的工艺流程图中,表示浓度的参量是()。（ C ）
A、T
B、P
C、C
3、【单选题】 ()演练针对应急预案中某项应急响应功能开展的演练活动。（ A ）
A、单项
B、综合
C、现场
4、【单选题】 下列选项中,不属于安全电压等级的是()V。（ C ）
A、12
B、24
C、48
5、【单选题】 不能用水灭火的是()。（ B ）
A、棉花
B、汽油
C、木材
6、【单选题】 人体摄入生产性毒物的最主要、最危险途径是通过()。（ C ）
A、皮肤
B、消化道
C、呼吸道
7、【单选题】 便服室、工作服室可按照同室分柜存放的原则设计,以避免工作服污染便服的车间卫生特征等级为()级。（ B ）
A、1
B、2
C、3
8、【单选题】 含铜、铅、锌、铬等的废物为()废物。（ A ）
A、危险
B、一般
C、固体
9、【单选题】 在建筑厂房时,应留够防火间距、构筑防火墙和隔热层;往裸露的金属构件表面涂上防火涂料,以及正确安设通风管道等。目的主要是防止建筑燃烧时的()。（ B ）
A、热传导
B、热辐射
C、热对流
10、【单选题】 小型离心泵输送常温液体,正常运行时,泵的轴承温度应为()℃以下。（ A ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4667637367643e372ffb020bd51b4890/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f629d8b4c03e9a30415897f3ab6c20/" rel="bookmark">
			CICFlowMeter源码分析以及为满足需求而进行的修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CICFlowMeter CICFlowMeter是一个流量数据处理程序，能够捕获网卡流量或者对pcap流量数据包进行分析。具体将流量数据处理成什么样子请自行百度，下面主要写一下这几天对该程序代码的解析。从网上下载好代码其结构如下图所示
其中App和Cmd分别是窗口界面和命令行模式的入口函数。 思路是通过App一步一步找到需要改动的地方进行改动 找到调用的方法的类就是ctrl+鼠标左键，不再赘述。调用流程如下A—&gt;B表示A调用了B,或类A中使用了类BApp—&gt;MainFrame—&gt;FlowOfflinePane，该调用流程对应窗口模式如下图所示：
在FlowOfflinePane类中找到“OK”关键字，可以看到该按钮绑定了startReadPcap()函数。在startReadPcap()函数中可以找到worker.execute()语句，而worker是一个ReadPcapFileWorker对象。并且为worker对象绑定了addPropertyChangeListener监听器。其中该监听器中最后一个else if语句如下图所示：
图中红色框就是利用子线程进行文件的写操作，即将分析后的数据写入到文件中，由于使用子线程写会导致流量数据乱序，我的需求要求顺序不能乱，所以没有使用该子线程。如果对顺序没有要求可以对其中的代码进行修改以输出你所期望的数据。 在ReadPcapFileWorker类中有一个doInBackground()的重载函数，根据方法名可以知道该方法会在后台自动调用，可能就是在执行了execute()函数会自动调用吧 在doInBackground方法中会执行readPcapDir()方法或readPcapFile()方法，而readPcapDir()方法内部也会调用readPcapFile()方法，所以如果要修改只需修改readPcapFile()方法即可。主要说readPcapFile()方法
在readPcapFile方法中可以找到上图中红框内的语句，FlowGenerator对象就是一个Flow生成器，给他一个监听器就可以调用到刚刚所说的存储数据子线程了。下面还会有介绍
上图是readPcapFile方法中的主逻辑循环，红框是不断读取输入数据包中的一条流量数据并提取信息给basicPcaket对象。绿框中就是对该数据包的处理。黄色框中的代码是我自己添加的代码以防止flowGen对象中finishedFlow字典过多导致内存爆炸。。至于finishedFlow是啥之后会有介绍先看nextPacket()方法，该方法在BasicPacketInfo类中，其代码如下：
可以看到绿色框框是提取数据包信息的主要方法，可在其中进行修改以提取自己想要的信息。不再赘述flowGen.addPacket(basicPacket);该方法是数据包处理的主要方法，其中主要对flowGen对象中的两个个成员：currentFlows，finishedFlows进行了修改，有三个判断可以自己看，人家也有注释，finishedFlows是临时用来存储处理好的Flow的。currentFlows是存储尚未结束的对话Flow的。其中调用了flow.addPacket(packet);用来更新Flow。mListener.onFlowGenerated(flow);用来通知上面说的子线程进行数据存储。 回到readPcapFile方法，在主逻辑代码之后是如下所示的代码 上述代码中绿框内是源代码自己调用的，我给注释了，自己写了红框中的方法代码进行数据存储。
至于给Flow打标签是在BasicFlow中进行的，在进行存储时会调用该类的dumpFlowBasedFeaturesEx（）方法，该方法就是将数据进行进行整合成为一个String类型，方便写入文本，当然包括写入标签。可以在该类中写一个子方法用来判断属于哪个标签，当然也可以写死。。
说的比较笼统，要想改造改代码符合自己的要求还要仔细读源码，本文只是在一些关键的点上能够给你以帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e571d7b9241d13b7df61eb9f7e3b995/" rel="bookmark">
			BEVFusion: A Simple and Robust LiDAR-CameraFusion Framework 细读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BEVFusion这个名字是有撞车的
两个自动驾驶相关的文章都是这个简称
BEVFusion: Multi-Task Multi-Sensor Fusion with Uniﬁed Bird’s-Eye View Representation mit-han-lab/bevfusion: BEVFusion: Multi-Task Multi-Sensor Fusion with Unified Bird's-Eye View Representation (github.com)
主要是从模型加速的方向去进行优化的，暂时还没有细读，主要解读第二篇。BEVFusion: A Simple and Robust LiDAR-Camera Fusion Framework ADLab-AutoDrive/BEVFusion: Offical PyTorch implementation of "BEVFusion: A Simple and Robust LiDAR-Camera Fusion Framework" (github.com) 这篇文章主要从工业落地的角度出发，提出解决鲁棒性问题。
另一个有意思的是，这两个工作，从github粗看，应该都是用到了mmdet3d的框架
在右侧的A Simple and Robust LiDAR-Camera Fusion Framework中，似乎2d的检测也是使用的mmdet的框架。感觉这两个的代码阅读应该都会相对于友好一些（希望是这样.....）
一些背景：
感知模块（如3D BBox检测，3D语义分割）一直是自动驾驶系统里最重要的环节之一，为了达到足够的安全冗余，车辆上一般会集成多种传感器，如激光雷达，摄像头，毫米波雷达等，这些传感器特性不同，能够起到很好的互补作用。在面向L4的自动驾驶系统里，激光雷达（后面简称雷达）和摄像头（通常也称为视觉）起到的作用会更加重大，所以无论是学术上还是工业上，这二者的融合算法一直都是一个非常热门的研究领域。
通常，雷达和视觉的融合策略分为三种类型：决策层融合（通常我们称为后融合），决策+特征融合（中间层融合），特征融合（前融合），后融合就是将基于雷达的模型输出的最终结果，比如3D BBox, 和视觉检测器输出的结果，如2D BBox, 通过滤波算法进行融合；中间层融合是将某一个模态输出的最终结果，投影到另一种模态的深度学习特征层上，然后再利用一个后续的融合网络进行信息融合；前融合则是直接在两种模态的Raw Data或者深度模型的特征层上进行融合，然后利用神经网络直接输出最终的结果。这里有篇文章做了比较详细的介绍；
这几种融合策略当然各有优劣，但是在工业界普遍使用的是后融合，因为这种方案比较灵活，鲁棒性也更好，不同模态的输出的结果通过人工设计的算法和规则进行整合，不同模态在不同情况下会有不同的使用优先级，因此能够更好的处理单一传感器失效时对系统的影响。但是后融合缺点也很多，一是信息的利用不是很充分，二是把系统链路变得更加复杂，链路越长，越容易出问题，三是当规则越堆叠越多之后维护代价会很高。学术界目前比较推崇的是前融合方案，能够更好的利用神经网络端到端的特性。但是前融合的方案少有能够直接上车的，原因我们认为是目前的前融合方案鲁棒性达不到实际要求, 尤其是当雷达信号出现问题时，目前的前融合方案几乎都无法处理。
在实际环境下会面临以下几种问题：
1）雷达和相机的外参不准 由于校准问题或车辆运行时颠簸抖动，会造成外参不准，导致点云和图像直接的投影会出现偏差
2）相机噪声 比如镜头脏污遮挡，卡帧，甚至是某个相机损坏等, 导致点云投影到图像上找不到对应的特征或得到错误的特征
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e571d7b9241d13b7df61eb9f7e3b995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b253dbb884715a4d3405e35961d0ba71/" rel="bookmark">
			MySQL最全讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础篇 通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）DML: 数据操作语言，用来对数据库表中的数据进行增删改DQL: 数据查询语言，用来查询数据库中表的记录DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 DDL（数据定义语言） 数据定义语言
数据库操作 查询所有数据库：
SHOW DATABASES;
查询当前数据库：
SELECT DATABASE();
创建数据库：
CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];
删除数据库：
DROP DATABASE [ IF EXISTS ] 数据库名;
使用数据库：
USE 数据库名;
注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 表操作 查询当前数据库所有表：
SHOW TABLES;
查询表结构：
DESC 表名;
查询指定表的建表语句：
SHOW CREATE TABLE 表名;
创建表：
CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b253dbb884715a4d3405e35961d0ba71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db8de27f08d4ed2de8e0dd1ed8d5fe54/" rel="bookmark">
			vue3.x中eslint-disable禁用检查设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在vue.config.js中：lintOnSave:设置false即可，新建项目默认是true。
const { defineConfig } = require('@vue/cli-service') module.exports = defineConfig({ lintOnSave: false }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99749f703cd3dbc34c5e8b3a0c916b77/" rel="bookmark">
			代码生成器-mybatis-plus-generator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们平时在开发的过程中，对于新建的一张表难免会有对其进行增删改查的操作，而且还要写Controller、service、Mapper、Mapper.xml、PO、VO等等。如果每次都要去写这些跟业务毫不相干但是却又耗时耗力的重复代码这不仅是让开发人员不能专注于业务逻辑甚至可能由于不注意导致字段大小写或者某个字母写错而出现bug。所以我们可以利用代码生成器来生成这些固有的代码，这样不仅正确性高，毕竟代码是不会骗人的。而且还节省了时间。
代码生成器有很多，大多数都是基于模板引擎freemarker或者velocity来实现的。git上有许多特别好用和功能强大的代码生成器，比如fast-generator，这也是通过freemarker模板引擎来生成模板代码的，并且提供了可视化界面。由于我的项目中之前使用的是mybatis-plus-generator，所以我决定使用mybatis-plus-generator来生成代码。这样最主要的工作就是去了解一下mybatis-plus-generator。
我们需要通过代码生成器来实现如下需求：
1. 数据库层Entity、Mapper、Xml，DTO层查询参数类、返回封装结果类；
2. 逻辑层Service类，包含对Entity的增删改查（条件查询）方法，查询方法包含分页、不分页2套；
3. Service,Xml联合实现批量insert、批量delete、乐观锁update;
4. 接口层 Controller类，包含基于DTO的增删改查方法；
5. 基于MybatisPlus，对生成的Entity类开启字段自动填充，选择开启逻辑删除、乐观锁；
首先我们打开mybatis-plus的官网，选择代码生成器mybatis-plus官网，看一下官网给出的例子即CodeGenerator类。修改里面的数据库配置和生成代码的位置就可以运行了，如果没有什么特殊的需求直接运行程序就会生成controller、service、mapper、entity这些代码。我们可以看mybatis-plus-generator自带的模板都在templates目录下
并且可以打开文件可以看到模板其实过于简单，里面并没有任何方法只是生成了一个空类，所以并不能满足我们的需求。所以我们需要改造 CodeGenerator类的main方法以及模板来满足我们的需求。先来分析一下官网给出的方法。
1、设置GlobalConfig：这里配置了自动生成文件的位置以及作者信息。我们可以打开配置列表，看看GlobalConfig还有哪些信息可以进行配置基本配置。可以看到这里还可以配置是否开启resultMap以及设置Controller、Service、Mapper等生成的名字，都是通过%s+自己想定义的后缀。%s是一个占位符，最后生成的时候会将Entity的名字填充到这里。名字可以通过这里设置当然也可以直接通过模板里面设定的方式来设置。
2、配置数据库信息：这里只要将它修改成自己的数据库地址以及账号密码即可，我们也可以打开基本配置来看有哪些我们需要的属性。
3、PackageConfig包配置：这里是配置更下一层的目录，最后的代码会生成在GlobalConfig的outputDir+PackageConfig设置的parent+PackageConfig设置的各个类目录。
比如我这里设置的就会生成在src.main.java的com.wjf.codegen的目录下面，并且这里分别设置了entity、service等的目录。
4、InjectionConfig：这个配置可以让我们实现一些自定义的配置
看一下这些配置，主要的是设置自定义的参数initMap以及自定义的输出文件。由于mybatis-plus的模板配置信息TemplateConfig中只能设置controller、service、mapper、mapper.xml、entity、serviceImpl。PackageConfig的配置也只能配置这些类的输出文件的位置，这就没有办法满足我们上面的需求。比如我们需要生成VO对象或者Vo和Entity转换的类Covert对象。这里我们就必须通过InjectionConfig来进行设置了。fileOutConfigList就是帮助我们定义一些其它的模板输出的位置，这里以VO对象为例
这里我自定义了一个VO对象并且定义了它输出的位置。
5、TemplateConfig：这类我们可以设置我们自己的模板的位置，如果设置了就会以我么自己配置的模板来生成代码，否则会以mybatis-plus-generator默认的模板来生成代码。
既然我们以及可以通过自己的配置以及自己模模板生成我们需要的类，那么这已经满足了我们的一些要求了，接下来是需要满足逻辑删除以及乐观锁更新以及自动填充。通过了解逻辑删除需要我们在逻辑删除字段上面添加@TableLogic注解，然后调用delete方法即可实现，所以我们在Entity的模板中给删除字段添加@TableLogic注解即可。乐观锁更新也是同样的道理，在乐观锁字段上添加@Version注解即可实现。可以看到这些实现都跟我们定义的模板有关，接下来我们就看看如何定义模板。
这是我定义的一个freemark的ftl模板，里面连个方法，一个是更新方法一个是分页查询方法，这里只是用来说明问题，乐观锁更新我们可以使用do{}while()的语法进行。 可以看到我们的模板方法里面可以同${}然后通过变量名来获取变量，这里的变量都有哪些呢？其实这些变量就是我们上面通过12345点GlobalConfig、PackageConfig等信息里面进行配置的。只要配置只会我们都可以在这里获取到他的值。注意红色自定义的字，当我们自己定义Vo或者其它类的时候由于配置里面是没有的，我们怎么去获取呢？
官网上有一个特别说明，我们进入到这个类中看一下。
有这么多的参数，所以我们在写模板的时候就可以对着这里看看有哪些可以使用的参数。我们如何增加自己定义的参数呢。
通过InjectionConfig的initMap方法，最后一定要调用setMap方法以及AutoGenerator#setCfg(cfg)然后在模板中就可以通过${cfg.key}来获取变量了。我这里定义了一个voDir所以在模板中我可以通过${cfg.voDir}来获取我定义的vo生成的目录。最后一点我们来看一下如何实现自动填充，这其实也是在模板里面，将需要自动填充的字段上的@TableField注解中加入属性fill = FieldFill.INSERT(这表示在添加时自动填充)。
模板中这么写，并且增加自动填充字段的配置
这样生成的类上需要自动填充的字段就可以自动填充了。最后我们需要配置自动填充的值。
这样就实现了自动填充。
代码生成器以及全部满足我们的需求，现在需要做的只是调整模板。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc34cd95770d2b11f043d5839d3f545/" rel="bookmark">
			ANSI Common Lisp Chapter 2 习题参考答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、描述下列表达式求值后的结果
(a) (+ (- 5 1) (+ 3 7))
14
(b) (list 1 (+ 2 3))
(1 5)
© (if (listp 1) (+ 1 2) (+ 3 4))
7
(d) (list (and (listp 3) t) (+ 1 2))
(nil 3)
2、给出3种不同表示(a b c)的cons 表达式。
(cons 'a '(b c))
(cons 'a (cons 'b '©))
(cons 'a (cons 'b (cons 'c)))
3、使用 car 与 cdr ，定义一个函数，它返回一个列表的第四个元素。
(defun four-ele (mylist) (car (cdr (cdr (cdr mylist))))) 4、定义一个函数，接受两个参数，返回两者当中较大的那个。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc34cd95770d2b11f043d5839d3f545/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e433115184706d883209c693310e33c8/" rel="bookmark">
			TensorRT安装及验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主的一些基本环境配置可见之前博客非虚拟机环境下Ubuntu配置_jiugeshao的专栏-CSDN博客
TensorRT的介绍见之前博客，TensorRT的安装、TensorRT如何加速Pytorch、Tensorflow、Caffe等框架模型的资料还不是很多,建议还是先多看看官网提供的手册，原汁原味。
Developer Guide :: NVIDIA Deep Learning TensorRT Documentationhttps://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html整了那么多东西之后发现，掌握了多少东西并不重要，快速获取知识的能力才是重要的，要善于从一些官网手册中获取最原始的资料。（博主工作中也经常需要这种探索，无人告知，只能自己去琢磨探索，无形之中适应了这种节奏）
这里安装Anaconda是为了在其python环境里去验证下cuda和cudnn是否配置成功了，同时后面系列博客的python环境也是在通过此Anaconda版本配置
第一步: 准备安装Anaconda
Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source MirrorIndex of /anaconda/archive/ | 清华大学开源软件镜像站，致力于为国内和校内用户提供高质量的开源软件镜像、Linux 镜像源服务，帮助用户更方便地获取开源软件。本镜像站由清华大学 TUNA 协会负责运行维护。https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/下载3.5.2版本，完毕后，cd到文件所在目录下，输入如下命令进行安装
bash Anaconda3-5.2.0-Linux-x86_64.sh 按照提示操作即可，到如下信息提示的时候，输入no,完成安装。
重启终端后，输入python,看到如下信息：
第二步：安装显卡驱动
先增加如下的源
sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt update 如下命令检查可以安装的驱动版本
ubuntu-drivers devices 出现如下信息：
博主这里选择推荐的那一个驱动版本，如下命令进行安装
sudo apt install nvidia-driver-470 安装前输入nvidia-smi，会出现如下信息：
安装完毕后，输入nvidia-smi
第三步：安装cuda
CUDA Toolkit Archive | NVIDIA Developerhttps://developer.nvidia.com/cuda-toolkit-archive网页上下载cuda11.0
选择配置后，按照提示执行两条命令语句进行下载安装
wget http://developer.download.nvidia.com/compute/cuda/11.0.2/local_installers/cuda_11.0.2_450.51.05_linux.run sh cuda_11.0.2_450.51.05_linux.run 安装就按照指引来就行了，注意到如下时，去掉驱动安装的选择，因为前面显卡驱动已经安装好了，在每个选项前面enter下即可以选择安装还是不安装
安装完毕后，配置下环境变量
sudo gedit ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e433115184706d883209c693310e33c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b752f06031bf281d2f401d93bf1513/" rel="bookmark">
			《数据结构：c语言版》（严蔚敏）知识点整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 自述第一章绪论 基本概念算法的时间空间复杂度： 线性表： 线性表的顺序存储结构 顺序存储结构定义：1.初始化：2.插入： 线性表的链式存储结构： 定义：1.初始化2.单链表的插入 双向链表线性表的应用： 1.线性表的合并（LB合并到LA中）： 2.有序表的合并(LA,LB合并到LC)：3.一元多项式的表示及相加： 栈： 顺序栈的存储结构定义： 1.初始化2.进栈3.出栈 链栈： 存储结构定义： 栈的应用： 1.数制转换：2.括号匹配检验：3.表达式求值： 栈与递归： 队列： 顺序队列 假溢出：2.入队3.出队 队列的应用： 打印二项式系数表 数组： 数组的定义：数组取地址：特殊矩阵的压缩： 对称矩阵：上三角矩阵存储：下三角矩阵： 稀疏矩阵： 三元组表法：伪地址表示法： 稀疏矩阵的转置： 1按三元组表的列转置：2快速转置:2.十字链表： 树： 1.树的基本概念2二叉树 二叉树的存储结构：二叉树的遍历方法和实现： 二叉树遍历的应用，究其本质使用了递归算法： 建立二叉链表：复制二叉树： 树的存储结构：森林，树，二叉树的转换 树转化成二叉树：将二叉树还原成树就表示成：二叉树还原成森林：树的遍历：森林的遍历： 哈夫曼树： 基本概念：哈夫曼树的构造：哈夫曼编码： 图： 基本概念：图的存储结构： 1.邻接矩阵表示法又称数组表示法：邻接表表示法： 结构特点： 图的遍历： 1深度优先遍历：广度优先遍历： 最小生成树一些性质：最小生成树的构造方法： 1prim方法：克鲁斯卡尔算法： 拓扑排序： 拓扑排序过程：拓扑排序算法实现： 最短路径问题： 迪杰斯特拉算法：弗洛伊德算法： 查找： 基本概念：静态查找表： 顺序查找：折半查找：折半查找的判定树：索引表查找： 动态查找表： 二叉排序树:二叉排序树的删除： 哈希表： 哈希函数的构造： 1数字分析法：2平方取中法：3折叠法：4除留余数法： 哈希表的冲突： 1开放地址法： 线性探测法：二次探测法：伪随机法： 2再哈希法 3链地址法： 排序： 排序算法的评价标准： 插入排序： 直接插入排序；r[i]跟前面排好的i-1个元素进行比较后插入折半插入排序：希尔排序： 交换排序： 冒泡排序：快速排序： 选择排序 简单选择排序：堆排序： 筛选： 2-路归并排序基数排序： 自述 数据结构是相互之间存在一种或多种特定关系的数据元素的集合，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0b752f06031bf281d2f401d93bf1513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe2488a3793e278200436c7a3dda00b/" rel="bookmark">
			Poi导出word的一些工具方法（添加图片，合并单元格，设置表格边框，添加分页符）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入的maven依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; 图片传入
// 图片写入表格的cell（单元格），传入的参数：需要传入图片的cell，图片宽度，图片高度,图片链接地址 public static void handlePhoto(XWPFTableCell cell,int width,int height,String picPath){ XWPFParagraph p = cell.getParagraphArray(0); if (p == null) { p = cell.addParagraph(); } p.setAlignment(ParagraphAlignment.CENTER); p.setVerticalAlignment(TextAlignment.CENTER); XWPFRun photos = p.createRun(); try { // 图片地址为参数的picPath // 测试用图 picPath = "https://img-blog.csdnimg.cn/img_convert/b26750936b8d00e60053e7dda335f9aa.png"; // 截取图片后缀名 String houzhui = picPath.substring(picPath.length()-3,picPath.length()); if (picPath.equals("无"))cell.setText("无"); // 调用下面网络图片流到本地字符获取的方法(1) byte[] byteArray = ImgFile(picPath); // 如果链接也找不到文件(404) 显示找不到文件 if (byteArray == null) cell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fe2488a3793e278200436c7a3dda00b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39f7a440ecf6529a811e6aa2763f4fe7/" rel="bookmark">
			C&#43;&#43;入门基础总结（最详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Ⅰ.命名
关键字与命名空间
1.命名空间里的内容
2.命名空间的嵌套
3.多种使用方式
4.多文件工程重名处理
Ⅱ.缺省参数
1.缺省参数概念
2.缺省参数分类
Ⅲ.函数重载
1.函数重载的概念
注意：下列情况不能重载！！
Ⅳ. 内联函数（Inline）
1.内联函数的概念
2.内联函数的特性与用法
Ⅴ. auto关键字(C++11)
1.auto的使用细则
2.auto的注意事项
3.基于范围的for循环(C++11)
4.范围 for 的使用注意事项
Ⅵ.指针空值 nullptr
引入 nullptr 的原因
Ⅶ.引用
1.引用概念
2.引用特性
3.引用的应用
4.常引用
权限的放大
权限的缩小
保持权限的一致
5.引用与指针的区别
Ⅰ.命名 关键字与命名空间 C++关键字：
众所周知，给变量或者函数命名时不能用关键字，但是如果非要用怎么办呢？
为了很好地解决这种冲突的问题，C++ 就加入了命名空间的特性！在 C++ 里，我们就可以利用 "命名空间" 来解决这个问题，所以 C++ 提出了一个新语法 —— 命名空间 namespace！
在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作 用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。
1.命名空间里的内容 命名空间里的内容，不仅仅可以存放变量，还可以在里面放函数，结构体，甚至是 类
#include &lt;stdio.h&gt; namespace N1 { int a = 10; int b = 20; int Add(int x, int y) { return x + y; } } namespace N2 { int c = 0; struct Node { struct Node* next; int val; }; } int main(void) { int res = N1::Add(N1::a, N1::b); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39f7a440ecf6529a811e6aa2763f4fe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/540b1f9d1e077b0d2b2e048870037db5/" rel="bookmark">
			9.6.c语言编写程序，能够输入100个学生的学号和姓名，并将学生按照学号由小到大排序。当输入一个学号时能用(二分查找)折半查找法找出该学生的姓名。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//有个bug,学号个位数，不输出姓名。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define NUM 3 int find_num(int num[], int target) { int left = 0; int right = NUM-1;//最后一个元素的索引 while (left &lt;= right)//左闭右闭区间 -&gt;[left,right] { int mid = left + (right - left) / 2;//为了防止溢出,(right + left ) / 2可能会溢出 if (num[mid] == target) { return mid;//找到指定数就立即返回 } else if (num[mid] &gt; target) right = mid - 1; else if (num[mid] &lt; target) left = mid + 1; } return -1; } int main() { int i, j, tmp3,target; char name[NUM][10];//姓名 int num[NUM];//学号 float score[NUM][3];//三门课成绩 float sum[NUM];//总成绩 float tmp, tmp0, tmp1, tmp2; char stmp[10]; int find_num(int num, int target); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/540b1f9d1e077b0d2b2e048870037db5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d89ac10adc8fd8623931950b2f46124/" rel="bookmark">
			Minimum supported Gradle version is 6.1.1. Current version is 5.6.4.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio 导入项目，Gradle 同步时，提示以下错误：
Minimum supported Gradle version is 6.1.1. Current version is 5.6.4. Please fix the project's Gradle settings. Fix Gradle wrapper and re-import project Open Gradle wrapper properties Gradle settings 一 、原因：其实就是你导入的项目使用的Android gradle 插件， 与当前你的Android studio 的Android gradle 版本不对应，
导致Gradle 版本对应不上.
查看两个版本号的方式：
1. Android studio 的Android gradle 版本：
Help -&gt; About -&gt; Android Studio 3.5.2 (其实就是当前studio版本)
2. 项目的Android gradle依赖
// Top-level build file where you can add configuration options common to all sub-projects/modules.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d89ac10adc8fd8623931950b2f46124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57ad91864f3f7dc689e457229888b7a/" rel="bookmark">
			Django DRF 视图基类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 引子2. 视图基类2.1 APIView2.1.1 APIView 与 View 的不同之处2.1.2 支持定义的类属性2.1.3 CBV 源码分析2.1.4 APIView 执行流程分析2.1.5 Request 对象2.1.5 Request 对象源码分析2.1.6 自定义 data2.1.7 Response 对象2.1.8 使用 APIView 编写 5 个接口 2.2 GenericAPIView2.2.1 serializer_class2.2.2 queryset2.2.3 使用 GenericAPIView 编写 5 个接口 1. 引子 Django REST framwork 提供了众多的通用视图基类与扩展类，以简化视图的编写。
REST framework 提供的视图的主要作用有：
控制序列化器的执行（检验、保存、转换数据）控制数据库查询的执行 在此之前需要注意的是，DRF 是一个 app，也需要在配置文件中注册。
INSTALLED_APPS = [ 'django.contrib.admin',	# 后台管理，系统自带后台管理 admin 'django.contrib.auth',	# 权限管理会生成6张表 'django.contrib.contenttypes',	# 可以对所有 app 的表进行记录 'django.contrib.sessions',	# session功能，也就是 django_session表 'django.contrib.messages',	# django消息框架 flask的闪现 'django.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a57ad91864f3f7dc689e457229888b7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783fa70659973d244a07319819ed0aa0/" rel="bookmark">
			机器学习：交叉验证，网络搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标 目标 知道交叉验证、网格搜索的概念会使用交叉验证、网格搜索优化训练模型 1 什么是交叉验证(cross validation) 交叉验证：将拿到的训练数据，分为训练和验证集。以下图为例：将数据分成4份，其中一份作为验证集。然后经过4次(组)的测试，每次都更换不同的验证集。即得到4组模型的结果，取平均值作为最终结果。又称4折交叉验证。
1.1 分析 我们之前知道数据分为训练集和测试集，但是为了让从训练得到模型结果更加准确。做以下处理
训练集：训练集+验证集测试集：测试集 1.2 为什么需要交叉验证 交叉验证目的：为了让被评估的模型更加准确可信
问题：这个只是让被评估的模型更加准确可信，那么怎么选择或者调优参数呢？
2 什么是网格搜索(Grid Search) 通常情况下，有很多参数是需要手动指定的（如k-近邻算法中的K值），这种叫超参数。但是手动过程繁杂，所以需要对模型预设几种超参数组合。每组超参数都采用交叉验证来进行评估。最后选出最优参数组合建立模型。
3 交叉验证，网格搜索（模型选择与调优）API： sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None) 对估计器的指定参数值进行详尽搜索estimator：估计器对象param_grid：估计器参数(dict){“n_neighbors”:[1,3,5]}cv：指定几折交叉验证fit：输入训练数据score：准确率结果分析： bestscore__:在交叉验证中验证的最好结果bestestimator：最好的参数模型cvresults:每次交叉验证后的验证集准确率结果和训练集准确率结果 4 鸢尾花案例增加K值调优 使用GridSearchCV构建估计器 # 1、获取数据集 iris = load_iris() # 2、数据基本处理 -- 划分数据集 x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=22) # 3、特征工程：标准化 # 实例化一个转换器类 transfer = StandardScaler() # 调用fit_transform x_train = transfer.fit_transform(x_train) x_test = transfer.transform(x_test) # 4、KNN预估器流程 # 4.1 实例化预估器类 estimator = KNeighborsClassifier() # 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783fa70659973d244a07319819ed0aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb5b77734e51cf42710b29ee024d1aa4/" rel="bookmark">
			Dart 、Flutter环境安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Dart环境配置
1.下载dart sdk
dart官网已经被墙,直接从一个链接可以下载,
https://gekorm.com/dart-windows/
2. 系统环境变量
变量名：DART_SDK 变量值：你的dart sdk安装目录 二. flutter环境配置
1.git上下载flutter环境sdk
cmd命令行到你想要安装的目录下 输入git命令行
git clone -b stable https://github.com/flutter/flutter.git 2.配置环境变量
1)系统变量中添加变量
变量名：FLUTTER_HOME 变量值：你的flutter sdk安装目录 2)系统环境变量中找到Path
变量值：%FLUTTER_HOME%\bin 变量值：%FLUTTER_HOME%\bin\cache\dart-sdk 3)用户环境变量
1) 变量名：PUB_HOSTED_URL 变量值：https://pub.flutter-io.cn 2) 变量名：FLUTTER_STORAGE_BASE_URL 变量值：https://storage.flutter-io.cn 准备就绪,打开cmd 运行
flutter doctor 三. 踩坑记录
1.git 报错
error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054
首先执行:
git config http.sslVerify "false" 再继续执行:
git init git clone 等 问题解决.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f4c3ca6475d55f05acf3070a1fa12f6/" rel="bookmark">
			Python的isnull识别缺失值nan
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取的csv文件，nan后面不能出现空格，有空格识别不到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9695618bb4b64e8d709c166e3161d4/" rel="bookmark">
			【数据库】sql语句的基本书写规范，数据库基本书写方法和注意事项（基于mysql）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql语句的基本语法 序幕sql语句的大小写问题 开篇 sql基础查询语句 select打印字符多列查询：筛选条件 whereDISTICT关键字防重复 插入语句insert into更新语句update删除语句 操作符比较运算符逻辑运算符 and or not特殊符号（in、not in、between...and..、is NULL 、LIKE）排序 order by和 限制输出 limit 函数算术函数（1）（avg、max、min、sum）算术函数 （2） （ROUND、NULL、COUNT）时间函数 （1） （NOW、CURDATE、CURTIME、DATE、TIME、EXTRACT、DATE_FORMAT）时间函数2 （2）（DATE_ADD、DATE_SUB、DATEDIFF、TIMESTAMPDIFF） 约束与连结约束(not null、UNIQUE、PRIMARY KEY、CHECK、DEFAULT)连结内连接 INNER JOIN外连接 OUTER JOIN交叉连接 CROSS JOIN 以下为知识进阶（工作需掌握）查询进阶（分组查询（group by，having），子查询）分组查询 group byHAVING 子句简单子查询子查询进阶内联视图子查询IN操作符的多行子查询ANY操作符的多行子查询ALL 操作符的多行子查询多列子查询having子句中的子查询 小结练习： MySQL事务（transaction）锁锁的认识InnoDB锁的种类之自增锁InnoDB锁的种类之共享锁和排他锁InnoDB锁的种类之意向锁、记录锁和间隙锁 如何上锁如何加行锁 序幕 简单范例： select * from courses where name = “李明”;
上面这句sql的作用就是查询courses表中姓名为李明的人的所有信息（未关联表的情况下的信息）
注意所有的sql语句以分号;结束
注意下面的
sql语句的大小写问题 这个我查询的文档：原文链接：http://c.biancheng.net/view/7178.html
简单总结就是：
我们常用的sql的关键字，函数名，表的列名 不区分大小写 至于另外的视图名，数据库名，表名要根据使用的系统来进行具体的情况划分，详情点开上面的链接
下面这些语句都是等价的：
SELECT name FROM student ; SELECT NAME FROM student ; SELECT nAmE FROM student ; select name from student ; 开篇 sql基础 查询语句 select 关于select查询语句中的反引号的疑问：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac9695618bb4b64e8d709c166e3161d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9ea12afae959235a0661deae6b4c59f/" rel="bookmark">
			编写函数，通过指针求字符串的长度。**输入格式要求：“%s“ 提示信息：“Enter string:“**输出格式要求：“string length=%d\n“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;
#define N 20
int len(char *p)
{
int i=0;
for(;*p!='\0';p++)
{
i++;
}
return i;
}
int main()
{
int length;
char str[N];
printf("Enter string:");
gets(str);
length=len(str);
printf("string length=%d\n",length);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce7d8d9733f26da9cb3888115c5d3537/" rel="bookmark">
			mybatis-plus in查询条件超过1000条报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis-plus in查询条件超过1000条报错 说明mybatis-plus in条件超过1000条时报错解决方案： 说明 数据库中 IN 可以包含的选项数如下：
mysql数据库：in语句中参数个数是不限制的。不过对整段sql语句的长度有了限制， 8.0之前的版本默认4M，最大可设置为1G; 8.0版本之后默认64M，最大可设置1G （设置max_allowed_packet修改默认大小）。 Oracle数据库：9i(最多256条)、10g(最多1000条)、 11g(最多1000条) mybatis-plus in条件超过1000条时报错解决方案： 我们采取的是 截取in条件的方案，例如　select＊from　test where name in () or name in ()，具体如下：
1.新建参数截取的工具类
package com.spsolution.hera.parent.jdbc.util; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper; import com.baomidou.mybatisplus.core.toolkit.support.SFunction; import com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper; import com.baomidou.mybatisplus.extension.conditions.update.LambdaUpdateChainWrapper; import org.apache.commons.lang3.ObjectUtils; import java.util.ArrayList; import java.util.List; /** * @author xhb 2022-01-07 **/ public class MybatisParameterUtils { public static &lt;T, F&gt; void cutInParameter(LambdaQueryWrapper&lt;T&gt; wrapper, SFunction&lt;T, ?&gt; column, List&lt;F&gt; coll) throws Exception { List&lt;List&lt;F&gt;&gt; newList = splitList(coll, 900); if (ObjectUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce7d8d9733f26da9cb3888115c5d3537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e540d3bd0b3e81c4fcd39dc09b87288/" rel="bookmark">
			Android 录屏相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android录屏声音相关 Android 10及以下的录屏Android 11总结 首先要做的是设置属性REMOTE_SUBMIX
mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.REMOTE_SUBMIX); Android 10及以下的录屏 目标 frameworks\av\services\audiopolicy\enginedefault\src\Engine.cpp if(mAvailableOutputDevices.getDevice(AUDIO_DEVICE_OUT_REMOTE_SUBMIX, String8("0")) != 0) { device2 = availableOutputDeviceTypes &amp; AUDIO_DEVICE_OUT_REMOTE_SUBMIX; } 修改为
if (mAvailableOutputDevices.getDevice(AUDIO_DEVICE_OUT_REMOTE_SUBMIX, String8("0")) != 0) { device2 = availableOutputDeviceTypes &amp; AUDIO_DEVICE_OUT_REMOTE_SUBMIX; device2 |= (availableOutputDeviceTypes &amp; AUDIO_DEVICE_OUT_WIRED_HEADPHONE); device2 |= (availableOutputDeviceTypes &amp; AUDIO_DEVICE_OUT_SPEAKER); } Android 11 目标frameworks\av\services\audiopolicy\enginedefault\src\Engine.cpp if ((remoteSubmix = availableOutputDevices.getDevice( AUDIO_DEVICE_OUT_REMOTE_SUBMIX, String8("0"), AUDIO_FORMAT_DEFAULT)) != nullptr) { devices2.add(remoteSubmix); } 修改为
if ((remoteSubmix = availableOutputDevices.getDevice( AUDIO_DEVICE_OUT_REMOTE_SUBMIX, String8("0"), AUDIO_FORMAT_DEFAULT)) != nullptr) { devices2 = availableOutputDevices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e540d3bd0b3e81c4fcd39dc09b87288/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04a72a87f8c98d4cba71f4d655cf084f/" rel="bookmark">
			查看局域网出口ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游览器输入这个地址，看到的ip就是你出去的ip
linux查看出口ip
telnet 210.74.42.114 10000
查看目标服务端口是否开了，是否能连上
telnet 210.74.42.33 9443
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b383b4bb8e370ad8dd28920c5e8ab9a8/" rel="bookmark">
			淘宝/天猫获取sku详细信息API接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、淘宝/天猫获取sku详细信息API接口参数如下：
1.公共参数：
名称类型必须描述keyString是调用key（必须以GET方式拼接在URL中）secretString是调用密钥 （点击获取key和secret)api_nameString是API接口名称（包括在请求地址中）[item_search,item_get,item_search_shop等]cacheString否[yes,no]默认yes，将调用缓存的数据，速度比较快result_typeString否[json,jsonu,xml,serialize,var_export]返回数据格式，默认为json，jsonu输出的内容中文可以直接阅读langString否[cn,en,ru]翻译语言，默认cn简体中文versionString否API版本 2. 请求参数：
请求参数：num_iid=572050066584&amp;sku_id=3880971359554&amp;is_promotion=0
参数说明：sku_id:SKU ID num_iid:商品ID is_promotion:是否获取取促销价
3.响应示例：
名称类型必须示例值描述 num_iid
Bigint0572050066584宝贝ID name
String0尺码:S;颜色分类:白色衬衫规格名称 img
String0//gd2.alicdn.com/imgextra/i2/3542320334/TB2gPaOyYSYBuNjSspiXXXNzpXa_!!3542320334.jpg规格图片 price
Float083.7优惠价 orginal_price
Float0135.00原价 express_fee
Float06.00快递费用 title
String0雪纺白色衬衫女长袖面试职业正装2018秋新款OL防走光工作服打底衣宝贝标题 detail_link
String0http://item.taobao.com/item.htm?id=572050066584宝贝链接 pic_url
String0//gd3.alicdn.com/imgextra/i2/3542320334/TB2zGWny4SYBuNjSsphXXbGvVXa_!!3542320334.jpg宝贝图片 quantity
Int0257库存 properties
String020509:28314;1627207:3714507属性id组合 sku_id
String03880971359554规格ID 4. 请求示例（CURL、PHP 、PHPsdk 、Java 、C# 、Python…)： # coding:utf-8 """ Compatible for python2.x and python3.x requirement: pip install requests """ from __future__ import print_function import requests # 请求示例 url 默认请求参数已经做URL编码 url = "https://wx19970108018/taobao/item_sku/?key=&lt;您自己的apiKey&gt;&amp;secret=&lt;您自己的apiSecret&gt;&amp;num_iid=572050066584&amp;sku_id=3880971359554&amp;is_promotion=0" headers = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b383b4bb8e370ad8dd28920c5e8ab9a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5fd4934a130afd9fb24a021064f3ad2/" rel="bookmark">
			java.lang.NoSuchMethodError: org.springframework.boot.builder.SpringApplicationBuilder.＜init＞([Ljava
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个报错是由于springboot和springcloud版本兼容问题，用上对应的版本就好了：
SpringCloud
SpringBoot
Angel版本
1.2.X
Brixton版本
1.3.X
Camden版本
1.4.X
Dalston版本、Edgware版本
1.5.X
Finchley版本
2.0.X
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa46b8bb2c248476376f72cd03f7bdf/" rel="bookmark">
			深入JVM源码篇-2-探索同步器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 目标
2. 关键类
3. 数据模型说明
3.1. markWord
3.2. ObjectWaiter
3.3. ObjectMonitor
3.4. ObjectSynchronizer
4. 关键行为
4.1. ObjectSynchronizer#enter
4.2. ObjectMonitor#enter
4.3. ObjectMonitor::EnterI
5. 总结
1. 目标 我探索同步器的JVM源码，采取的步骤为：先找到同步器类，然后从数据模型入手，了解涉及到的关键模型，接着重点看关键行为的逻辑。
希望达到的目标：了解同步器的JVM实现，何为偏向、轻量级、重量级。
2. 关键类 markWord
ObjectWaiter
ObjectMonitor
ObjectSynchronizer
3. 数据模型说明 3.1. markWord ​​​描述了一个object的header,与偏向锁有关。依据markword来判断是否偏向锁和轻量级锁。
// markWord 描述了一个object的header。header分为32位或64位。依据markword来判断是否偏向锁和轻量级锁。 // 偏向锁模式 表示锁偏向一个给定线程或匿名偏向。 // 若偏向一个给定线程，则该线程可不通过原子操作即可加锁或释放锁。 // 低3位用于配置偏向模式。 // [JavaThread* | epoch | age | 1 | 01] lock is biased toward given thread // [0 | epoch | age | 1 | 01] lock is anonymously biased // 低2位可描述3中情况：已加锁、已释放锁、监视器 // [ptr | 00] locked ptr points to real header on stack // [header | 0 | 01] unlocked regular object header // [ptr | 10] monitor inflated lock (header is wapped out) // [ptr | 11] marked used to mark an object // [0 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa46b8bb2c248476376f72cd03f7bdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84571f5c6764dbcab8f361a8d46fb02b/" rel="bookmark">
			准确率、召回率、F-1值、ROC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 混淆矩阵 如果我们用的是一个二分类模型，那么把预测情况和实际情况的所有结果进行两两组合，就会出现如下的混淆矩阵。
其中的核心概念如下，1代表正类、0代表负类：
TP：若一个实例是正类，但是被预测成为正类，即为真正类(True Postive)TN：若一个实例是负类，但是被预测成为负类，即为真负类(True Negative)FP：若一个实例是负类，但是被预测成为正类，即为假正类(False Postive)FN：若一个实例是正类，但是被预测成为负类，即为假负类(False Negative） 2 准确率 预测正确的结果占总样本的百分比，其公式如下：(TP+TN)/(TP+TN+FP+FN)。
虽然准确率可以判断总的正确率，但是在样本不平衡的情况下，并不能作为很好的指标来衡量结果。举个简单的例子，比如在一个总样本中，正样本占90%，负样本占10%，样本是严重不平衡的。对于这种情况，我们只需要将全部样本预测为正样本即可得到90%的高准确率，但实际上我们并没有很用心的分类，只是随便无脑一分而已。这就说明了：由于样本不平衡的问题，导致了得到的高准确率结果含有很大的水分。即如果样本不平衡，准确率就会失效。
正因为如此，也就衍生出了其它两种指标：精准率和召回率。
3 精准率 精准率（Precision）又叫查准率，它是针对预测结果而言的，它的含义是在所有被预测为正的样本中实际为正的样本的概率，意思就是在预测为正样本的结果中，我们有多少把握可以预测正确，其公式如下：TP/(TP+FP)
4 召回率 召回率（Recall）又叫查全率，它是针对原样本而言的，它的含义是在实际为正的样本中被预测为正样本的概率，其公式如下：TP/(TP+FN)
召回率的应用场景：比如拿网贷违约率为例，相对好用户，我们更关心坏用户，不能错放过任何一个坏用户。因为如果我们过多的将坏用户当成好用户，这样后续可能发生的违约金额会远超过好用户偿还的借贷利息金额，造成严重偿失。召回率越高，代表实际坏用户被预测出来的概率越高，它的含义类似：宁可错杀一千，绝不放过一个。
5 F1值 通过上面的公式，我们发现：精准率和召回率的分子是相同，都是TP，但分母是不同的，一个是（TP+FP），一个是（TP+FN）。两者的关系可以用一个P-R图来展示：
如何理解P-R（查准率-查全率）这条曲线？
有的朋友疑惑：这条曲线是根据什么变化的？为什么是这个形状的曲线？其实这要从排序型模型说起。拿逻辑回归举例，逻辑回归的输出是一个0到1之间的概率数字，因此，如果我们想要根据这个概率判断用户好坏的话，我们就必须定义一个阈值。通常来讲，逻辑回归的概率越大说明越接近1，也就可以说他是坏用户的可能性更大。比如，我们定义了阈值为0.5，即概率小于0.5的我们都认为是好用户，而大于0.5都认为是坏用户。因此，对于阈值为0.5的情况下，我们可以得到相应的一对查准率和查全率。
但问题是：这个阈值是我们随便定义的，我们并不知道这个阈值是否符合我们的要求。因此，为了找到一个最合适的阈值满足我们的要求，我们就必须遍历0到1之间所有的阈值，而每个阈值下都对应着一对查准率和查全率，从而我们就得到了这条曲线。
有的朋友又问了：如何找到最好的阈值点呢？首先，需要说明的是我们对于这两个指标的要求：我们希望查准率和查全率同时都非常高。但实际上这两个指标是一对矛盾体，无法做到双高。图中明显看到，如果其中一个非常高，另一个肯定会非常低。选取合适的阈值点要根据实际需求，比如我们想要高的查全率，那么我们就会牺牲一些查准率，在保证查全率最高的情况下，查准率也不那么低。
但通常，如果想要找到二者之间的一个平衡点，我们就需要一个新的指标：F1分数。**F1分数同时考虑了查准率和查全率，让二者同时达到最高，取一个平衡。**F1分数的公式为 = 2查准率查全率 / (查准率 + 查全率)。我们在图中看到的平衡点就是F1分数得来的结果。
参考链接：https://zhuanlan.zhihu.com/p/46714763
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeee396f394cc2bb9922a3b265198b55/" rel="bookmark">
			【vue】vue中axios的使用及vue生命周期详解_07
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. axios请求
二. 生命周期
💥 扩展：this判断—8种指向
⬛ 总结：知识点提炼
【前文回顾】👉 vue自定义指令、计算属性、过滤器_06
​
一. axios请求 1. 问题: 首先, ajax 4步非常繁琐；其次jquery中虽然提供了$.ajax()函数，但是仅限于jquery中使用！那么到了vue中，如何一句话发送ajax请求?
2. 解决: 今后只要在vue中发送ajax请求，几乎都用axios
3. 什么是axios: 第三方开发的专门发送ajax请求的基于Promise的函数库。
4. 如何: (0). 下载并引入: &lt;script src="js/axios.js"&gt;
(1). 准备: 配置axios统一的基础路径:
axios.defaults.baseURL="http://服务器端所有接口的基础地址"
(2). 发送get请求:
axios.get("服务器端接口地址的相对路径",{
params:{ //发送到服务器端的参数值列表
参数名: 参数值,
... : ...
}
}).then(result=&gt;{//坑1: 必须用箭头函数！ 只有result一个参数，则省略()
//坑2: result不是直接的返回结果
result.data才是真正的返回结果
})
(3). post请求:
axios.post(
"服务器端接口地址的相对路径",
"参数1=值1&amp;参数2=值2&amp;..."
).then(result=&gt;{
console.log(result.data)
})
5. 示例: 使用axios发送ajax请求
6_axios.html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeee396f394cc2bb9922a3b265198b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d8e9abd7e27aba9514d523fb0074f2/" rel="bookmark">
			金融风控建模全流程(Python，收藏)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、信贷风控简介 信贷风控是数据挖掘算法最成功的应用之一，这在于金融信贷行业的数据量很充足，需求场景清晰及丰富。
信贷风控简单来说就是判断一个人借了钱后面（如下个月的还款日）会不会按期还钱。更专业来说，信贷风控是还款能力及还款意愿的综合考量，根据这预先的判断为信任依据进行放贷，以此大大提高了金融业务效率。
与其他机器学习的工业场景不同，金融是极其厌恶风险的领域，其特殊性在于非常侧重模型的解释性及稳定性。业界通常的做法是基于挖掘多维度的特征建立一套可解释及效果稳定的规则及风控模型对每笔订单/用户/行为做出判断决策。
其中，对于（贷前）申请前的风控模型，也称为申请评分卡–A卡。A卡是风控的关键模型，业界共识是申请评分卡可以覆盖80%的信用风险。此外还有贷中行为评分卡B卡、催收评分卡C卡，以及反欺诈模型等等。
A卡（Application score card）。目的在于预测申请时（申请信用卡、申请贷款）对申请人进行量化评估。B卡（Behavior score card）。目的在于预测使用时点（获得贷款、信用卡的使用期间）未来一定时间内逾期的概率。C卡（Collection score card）。目的在于预测已经逾期并进入催收阶段后未来一定时间内还款的概率。
一个好的特征，对于模型和规则都是至关重要的。像申请评分卡–A卡，主要可以归到以下3方面特征：
1、信贷历史类：信贷交易次数及额度、收入负债比、查询征信次数、信贷历史长度、新开信贷账户数、额度使用率、逾期次数及额度、信贷产品类型、被追偿信息。（信贷交易类的特征重要程度往往是最高的，少了这部分历史还款能力及意愿的信息，风控模型通常直接就废了。）
2、基本资料及交易记录类：年龄、婚姻状况、学历、工作类型及年薪、工资收入、存款AUM、资产情况、公积金及缴税、非信贷交易流水等记录（这类主要是从还款能力上面综合考量的。还可以结合多方核验资料的真伪以及共用像手机号、身份证号等团伙欺诈信息，用来鉴别欺诈风险。需要注意的，像性别、肤色、地域、种族、宗教信仰等类型特征使用要谨慎，可能模型会有效果，但也会导致算法歧视问题。）
3、公共负面记录类：如破产负债、民事判决、行政处罚、法院强制执行、涉赌涉诈黑名单等（这类特征不一定能拿得到数据，且通常缺失度比较高，对模型贡献一般，更多的是从还款意愿/欺诈维度的考虑）
二、申请评分卡（A卡）全流程 实战部分我们以经典的申请评分卡为例，使用的中原银行个人贷款违约预测比赛的数据集，使用信用评分python库–toad、树模型Lightgbm及逻辑回归LR做申请评分模型。（注：文中所涉及的一些金融术语，由于篇幅就不展开解释了，疑问之处 可以谷歌了解下哈。）
2.1 模型定义 申请评分模型定义主要是通过一系列的数据分析确定建模的样本及标签。
首先，补几个金融风控的术语的说明。概念模糊的话，可以回查再理解下：
逾期期数(M) ：指实际还款日与应还款日之间的逾期天数，并按区间划分后的逾期状态。M取自Month on Book的第一个单词。（注：不同机构所定义的区间划分可能存在差异） M0：当前未逾期（或用C表示，取自Current） M1：逾期1-30日 M2：逾期31-60日 M3：逾期61-90日 M4：逾期91-120日 M5：逾期121-150日 M6：逾期151-180日 M7+：逾期180日以上
观察点：样本层面的时间窗口。 用于构建样本集的时间点（如2010年10月申请贷款的用户），不同环节定义不同，比较抽象，这里举例说明：如果是申请模型，观察点定义为用户申贷时间，取19年1-12月所有的申贷订单作为构建样本集；如果是贷中行为模型，观察点定义为某个具体日期，如取19年6月15日在贷、没有发生逾期的申贷订单构建样本集。
观察期：特征层面的时间窗口。构造特征的相对时间窗口，例如用户申请贷款订前12个月内（2009年10月截至到2010年10月申请贷款前的数据都可以用， 可以有用户平均消费金额、次数、贷款次数等数据特征）。设定观察期是为了每个样本的特征对齐，长度一般根据数据决定。一个需要注意的点是，只能用此次_申请前_的特征数据，不然就会数据泄露（时间穿越，用未来预测过去的现象）。
表现期：标签层面的时间窗口。定义好坏标签Y的时间窗口，信贷风险具有天然的滞后性，因为用户借款后一个月（第一期）才开始还钱，有得可能还了好几期才发生逾期。
对于现成的比赛数据，数据特征的时间跨度（观察期）、数据样本、标签定义都是已经提前分析确定下来的。但对于实际的业务来说，数据样本及模型定义其实也是申请评分卡的关键之处。毕竟实际场景里面可能没有人扔给你现成的数据及标签（好坏定义，有些公司的业务会提前分析好给建模人员），然后只是跑个分类模型那么简单。
确定建模的样本量及标签，也就是模型从多少的数据样本中学习如何分辨其中的好、坏标签样本。如果样本量稀少、标签定义有问题，那学习的结果可想而知也会是差的。
对于建模样本量的确定，经验上肯定是满足建模条件的样本越多越好，一个类别最好有几千以上的样本数。但对于标签的定义，可能我们直观感觉是比较简单，比如“好用户就是没有逾期的用户， 坏用户就是在逾期的用户”，但具体做量化起来会发现并不简单，有两个方面的主要因素需要考量：
【坏的定义】逾期多少天算是坏客户。比如：只逾期2天算是建模的坏客户？ 根据巴塞尔协议的指导，一般逾期超过90天（M4+）的客户，即定义为坏客户。更为通用的，可以使用“滚动率”分析方法（Roll Rate Analysis）确定多少天算是“坏”，基本方法是统计分析出逾期M期的客户多大概率会逾期M+1期（同样的，我们不太可能等着所有客户都逾期一年才最终确定他就是坏客户。一来时间成本太高，二来这数据样本会少的可怜）。如下示例，我们通过滚动率分析各期逾期的变坏概率。当前未逾期（M0）下个月保持未逾期的概率99.71%；当前逾期M1，下个月继续逾期概率为54.34%；当前M2下个月继续逾期概率就高达*90.04%*。我们可以看出M2是个比较明显的变坏拐点，可以以M2+作为坏样本的定义。
【表现期】借贷申请的时间点（即：观察点）之后要在多久的时间暴露表现下，才能比较彻底的确定客户是否逾期。比如：借贷后观察了一个客户借贷后60天的那几个分期的表现都是按时还款，就可以判断他是好/坏客户？ 这也就是确定表现期，常用的分析方法是Vintage分析（Vintage在信贷领域不仅可以用它来评估客户好坏充分暴露所需的时间，即成熟期，还可以用它分析不同时期风控策略的差异等），通过分析历史累计坏用户暴露增加的趋势，来确定至少要多少期可以比较全面的暴露出大部分的坏客户。如下示例的坏定义是M4+，我们可以看出各期的M4+坏客户经过9或者10个月左右的表现，基本上可以都暴露出来，后面坏客户的总量就比较平稳了。这里我们就可以将表现期定位9或者10个月~
确定了坏的定义以及需要的表现期，我们就可以确定样本的标签，最终划定的建模样本：
好用户：表现期（如9个月）内无逾期的用户样本。
坏用户：表现期（如9个月）内逾期（如M2+）的用户样本。
灰用户：表现期内有过逾期行为，但不到坏定义（如M2+）的样本。注：实践中经常会把只逾期3天内的用户也归为好用户。
比如现在的时间是2022-10月底，表现期9个月的话，就可以取2022-01月份及之前申请的样本（这也称为 观察点），打上好坏标签，建模。
通过上面信用评分的介绍，很明显的好用户通常远大于坏用户的，这是一个类别极不均衡的典型场景，不均衡处理方法下文会谈到。
)
2.2 读取数据及预处理 本数据集的数据字典文档、比赛介绍及本文代码，可以到https://github.com/aialgorithm/Blog项目相应的代码目录下载
该数据集为中原银行的个人贷款违约预测数据集，个别字段有做了脱敏（金融的数据大都涉及机密）。主要的特征字段有个人基本信息、经济能力、贷款历史信息等等
数据有10000条样本，38维原始特征，其中isDefault为标签，是否逾期违约。
importpandasaspd pd.set_option("display.max_columns",50) train_bank=pd.read_csv('./train_public.csv') print(train_bank.shape) train_bank.head()
数据预处理主要是对日期信息、噪音数据做下处理，并划分下类别、数值类型的特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27d8e9abd7e27aba9514d523fb0074f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbecf34cd1c09aa9915d010af5a81b1/" rel="bookmark">
			JavaScript基础语法_JavaScript内置对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript内置对象 JavaScript中的对象分为3种:自定义对象,内置对象,浏览器对象前两种对象是JS基础内容,属于ECMAScript;第三个浏览器对象属于js独有内置对象就是指JS语言自带的一些对象,这些对象供开发者使用,并提供了一些常用的或是最基本而必要的功能(属性和方法)内置对象最大的优点就是帮助我们快速开发JavaScript提供了多个内置对象;Math,Date,Array,String等 Number Object 在 JavaScript 中可以使用十进制、十六进制或八进制表示法来表示整数或浮点数。与其它编程语言不同，JavaScript 中的数字并不区分整数和浮点数，统一使用 IEEE754 标准（二进制浮点数算术标准）的 64 位浮点格式表示数字，能表示的最大值（Number.MAX_VALUE）为 ±1.7976931348623157e+308，最小值（Number.MIN_VALUE）为 ±5e-324。
示例：
var x = 123; // 整数 var y = 3.14; // 浮点数 var z = 0xff; // 十六进制数：255 对于比较大的数字可以使用指数表示法来表示，例如 6.02e+23 等于 6.02 x 10²³，
示例：
//JavaScript 中能够表示的最大的整数是 2⁵³ - 1，即 9007199254740991，能够表示的最小整数是 -(2⁵³ - 1)，即 -9007199254740991。 var x = 1.57e4; // 等于 15700 var y = 4.25e+6; // 等于 4250000 var z = 4.25e-6; // 等于 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cbecf34cd1c09aa9915d010af5a81b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1523fde5b53fe4bda83cce1b8f0c22/" rel="bookmark">
			04 -- 数组中第K个最大元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组中第K个最大元素 Github算法刷题一千零一夜，欢迎star
top – K 问题，思路一般就是建堆求最大，就建大顶堆求最小，就建小顶堆求第K个，就删除堆顶元素（k-1）次答案就是删除（k-1）次后，堆顶元素的值 &gt; 需要会自己建堆操作，上溢操作，下溢操作关键点： 1）父节点和子节点的计算方法，这个需要自己推导，死记硬背没用的
2）下溢操作的时候，父节点需要和左右分别进行比较，比较完后再决定是否交换值 import Foundation /** 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 */ /** 用 let resArr = nums.sorted(by: &gt;) return resArr[k-1] 这种也是可以的,但是这个不是考点 考点: 建堆, 上溢, 下溢 求第k个最大,就是把顶部元素,删除k-1次,每删除一次后,重新调整堆 */ class xiapi_04 { func findKthLargest(_ nums: [Int], _ k: Int) -&gt; Int { let heap = Heap(k, nums) heap.createHeap() for _ in 0..&lt;k-1 { heap.removeTop() } return heap.heapArr[0] } } class Heap { var k: Int var arr = [Int]() var heapArr = [Int]() init(_ k: Int, _ arr: [Int]) { self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b1523fde5b53fe4bda83cce1b8f0c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6e41a8d0ea054f4a1d3ca5696db9fc/" rel="bookmark">
			按如下函数原型编程计算并输出n×n阶矩阵的转置矩阵。其中，n由用户从键盘输入。已知n值不超过10。void Transpose(int (*a)[N], int n)；void Swap(int
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#define N 10
void Transpose(int(*a)[N], int n);
void Swap(int* x, int* y);
void InputMatrix(int(*a)[N], int n);
void PrintMatrix(int(*a)[N], int n);
int main()
{
int num[N][N];
printf("Input n:");
int n = 0;
scanf("%d", &amp;n);
InputMatrix(num, n);
Transpose(num, n);
printf("The transposed matrix is:\n");
PrintMatrix(num, n);
return 0;
}
/*读入矩阵*/
void InputMatrix(int(*a)[N], int n)
{
int i, j;
printf("Input %d*%d matrix:\n", n, n);
for (i = 0; i &lt; n; i++)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6e41a8d0ea054f4a1d3ca5696db9fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208eef649c31aad02128f0881161bfb4/" rel="bookmark">
			SpringBoot基础使用讲解文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础入门 1.1 初上手SpringBoot的感受
更多注解，简化代码；所有的配置都集中在resources中，并且不用像MVC那样繁琐，极度简化配置；可以配置多环境配置文件，然后通过主配置文件的server.servlet.context-path来选择使用哪个配置文件；简化部署，maven直接提供spring-boot-maven-plugin插件，无需别的配置即可打包； 1.2 SpringBoot特点
1、依赖管理
(1)父项目做依赖管理及版本自动仲裁
spring-boot-starter-parent的父项目的父项目中几乎声明了所有开发中常用的依赖的版本号，自动版本仲裁机制，其可以在pom.xml中的&lt;properties&gt;标签中增加&lt;***.version&gt;修改依赖版本。自动版本仲裁机制可以使引入依赖时不写版本号，只有当引入非版本仲裁的jar或改变版本号时，才要写版本号。
(2)导入starter场景启动器
spring-boot-starter是所有场景启动器最底层的依赖。SpringBoot所有支持的场景包括：Developing with Spring Boot
2、自动配置
(1)自动配置好了Tomcat、SpringMVC、Web常见功能(如字符编码等)
(2)指定默认包结构并支持调整
默认扫描规则：主程序MainApplication.java所在包及其下面的所有子包里面的组件都会被默认扫描进来。如果想要改变扫描路径，可以通过@SpringBootApplication(scanBasePackages="com.atguigu")或者@ComponentScan 指定扫描路径。即日常使用的@SpringBootApplication==等同于==@SpringBootConfiguration+@EnableAutoConfiguration+@ComponentScan("com.atguigu.boot")
(3)各种配置有默认值
注意：所有默认值都可以在application.properties中再修改且配置文件的值最终会绑定每个类上，这个类会在容器中创建对象
(4)按需加载所有自动配置项
注意：所有默认值都可以在application.properties中再修改且配置文件的值最终会绑定每个类上，这个类会在容器中创建对象
1.2.1 自动配置原理：
(1) SpringBoot先加载所有的自动配置类 xxxxxAutoConfiguration——&gt;@Configuration(proxyBeanMethods =)表明该类为配置类
(2) 每个自动配置类按照条件进行生效，不是全部生效——&gt;通过@Conditional设定生效条件
(3) 配置类会绑定配置文件指定的值——&gt; 通过@EnableConfigurationProperties开启绑定功能并注入容器中，@ConfigurationProperties和配置文件的某一项进行绑定
(4) 配置类中@Bean注入组件的部分值从xxxxProperties里面拿，xxxProperties和配置文件进行了绑定
(5) 生效的配置类就会给容器中装配很多组件，只要容器中有这些组件，相当于这些功能就有了——&gt;对配置类中的组件使用@ConditionalOnMissingBean如果用户没有配置好某些组件，SpringBoot会自动加载配置的默认组件，如果用户配置了优先用用户自己配置的
(6)(承接4) 组件定制化配置
○ 用户直接自己@Bean替换底层的组件(不常用)
○ 用户去看这个组件是获取的配置文件什么值就去修改(常用)——&gt;组件当中可能会通过this.properties等绑定配置文件的值，修改配置文件即可修改组件
1.3 容器功能
1.3.1 类组件(bean)添加
在早期使用Spring时，添加bean都是在xml中使用bean标签添加类组件。而对于现在的SpringBoot，可以使用一些注解完成既定功能。首先是Spring中就存在的注解：
Bean注入：
@Component(代表组件)@Controller(代表控制器)@Service(代表业务逻辑组件)@Repository(代表数据库组件) 指定包扫描路径等规则的注解：
@ComponentScan("com.")： 其他注解：
@Configuration：告知SpringBoot，这是一个配置类，其有多种模式： Full模式：proxyBeanMethods = true时触发，表示外部调用方法每次都是去容器中找组件，对配置类组件进行获取，得到的是CGLIB代理对象，SpringBoot总会检查这个组件是否在容器中存在，如果有就会保证组件单实例；Lite模式：proxyBeanMethods = false时触发，表示容器中不会保存代理对象，对配置类组件进行获取，得到的不是代理对象，调用Bean注册方法得到的对象就会新建，不是单实例；使用场景总结：如果只是单单注册组件，无需依赖，则一般均用Lite模式；只有当组件在别的场景会被依赖，则使用Full模式； @Bean：给容器中添加组件，以方法名作为组件id(可以在@Bean后自定义组件名)，返回类型为组件类型 注意：如果@Bean标注的方法传入了对象参数，这个参数的值就会直接从容器中找特性： (a)配置类中@Bean注册的组件默认是单实例的，不论在IOC容器中获取多少次，都是同一个组件；(b)配置类本身也是组件，即实际注册的组件包括@Configuration注册的配置类以及@Bean注册的方法；(c)无论外部对配置类中@Bean注册的方法调用多少次，获取的都是之前注册到容器中的单实例对象； @Import：参数为一个Class数组，给容器中自动创建出该数组中类型的组件，默认组件的名字就是全类名@Conditional：条件装配，满足Conditional指定的条件，则进行组件注入 1.3.2 原生配置文件引入
@ImportResource：将已经存在的xml配置进行导入 1.3.3 配置绑定：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208eef649c31aad02128f0881161bfb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/883459213baea8242b12a74d4cc57d5a/" rel="bookmark">
			虚拟机中的经典垃圾收集器及常用参数解析（Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：这里说的经典垃圾收集器，并不是说这些垃圾收集器多么的优秀，因为随着JDK版本的不断更新，新的垃圾收集器越来越多，这些在JDK9及之前使用的垃圾收集器自然就成为了相对经典的版本。说到垃圾收集器，就必须说垃圾收集算法 点击查看垃圾收集算法详解 ，因为垃圾收集算法是收集收集器的方法论，正是因为有了垃圾收集算法，才有了各种各样的垃圾收集器，下面认识下这些经典的垃圾收集器吧。
先附上一张各个垃圾收集器之间的关系图，之间有连线表示可以配合使用，中间有JDK 9标志的表示JDK9开始已经不支持这种搭配（CMS 与 Serial Old配合使用另有原因后面会说明）：
一.新生代收集（Minor GC） Serial 收集器
特性：
Serial 采用“标记-复制算法”实现，是最基础、也是历史最悠久的垃圾收集器，曾经是新生代的唯一解决方案，Serial 是单线程运行的，不仅是单线程垃圾回收，而且在进行垃圾回收时会暂停其他所有的所有线程，暂停其他所有线程的这种行为又被称为Stop The World,简称STW，这个名词会在后面的垃圾收集器中经常看到。
使用场景：
Serial 虽然问世十分的早，但依然是一款活跃的垃圾收集器，到目前为止，它依然是客户端虚拟机上新生代默认的垃圾收集器（客户端默认参数：-XX:+UseSerialGC,含义是使用Serial+Serial Old），与其他垃圾收集器相比，Serial具有简单、高效的特点，对于内存资源受限的环境，它是所有收集器额外内存消耗最小的，所以很实用客户端的虚拟机。
与老年代收集器的搭配：
①. Serial 可与 Serial Old配合使用,这是客户端虚拟机默认的垃圾收集组合。虚拟机参数设置：-XX:UseSerialGC。②.Serial 可与 CMS 配合使用，JDK9中取消了该种组合的使用，可见该种组合性能并不是多好。
与该垃圾收集器相关的虚拟机配置参数：
-Xss256k,设置虚拟机栈和本地方法栈大小
-Xmx10m,设置堆最大内存
-Xms10m,设置堆最小内存
-Xmn5m,设置新生代大小
-XX:+UseSerialGC,使用Serial + Serial Old的垃圾收集器组合
-XX:SurvivorRatio=8,新生代中Eden占10份中的比例，默认就是8。
-XX:+PrintGCDetails,告诉虚拟机在发生GC时，打印回收日志（JDK9之前有效）
-XX:MaxTenuringThreshold=15,对象年龄大于该值就会进入老年代，Parallel Scavenge中默认值为15，CMS中默认值为6，G1中默认值为15
-XX:PretenureSizeThreshold=3145728,晋升老年代的对象的大小，大于该值直接进入老年代，这里是3M，该值只能写成以字节为单位的形式。
附上一张在IDEA中设置虚拟机参数截图：
该配置下运行main（main里面就一行无关代码，这里不展示了）方法的结果，如下：
F:\java\bin\java.exe... Heap def new generation total 9216K, used 2794K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 34% used [0x00000000fec00000, 0x00000000feebaa78, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000) Metaspace used 3207K, capacity 4496K, committed 4864K, reserved 1056768K class space used 356K, capacity 388K, committed 512K, reserved 1048576K Process finished with exit code 0 从上面的输出可以看出eden space 8192K，这是8M和我们配置一样，【tenured generation total 10240K】老年代10M也和我们配置一样，没有问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/883459213baea8242b12a74d4cc57d5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed4ca857a3ab18cc34c8bded25e3f2e/" rel="bookmark">
			C语言用指针连接两个字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
void Fun(char* s1, char* s2)
{
int i=0,j=0;
while (*s1 != '\0')
{
s1++;
}
while (*s2 != '\0') {
*s1 = *s2;
s1++;
s2++;
}
*s1 = '\0';
}
int main()
{
char s1[4];
char s2[4];
scanf("%s", s1);
scanf("%s", s2);
Fun(s1,s2);
char *str1=s1;
printf("%s", str1);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3536f42b9df0f79212f75a4c7622b5bc/" rel="bookmark">
			【NPM】淘宝NPM镜像站切换新域名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用CNPM/淘宝源的开发者们请注意：淘宝NPM 镜像站喊你切换新域名啦。
Web 站点： https://npmmirror.com
Registry Endpoint： https://registry.npmmirror.com
随着新的域名已经正式启用，老 http://npm.taobao.org 和 http://registry.npm.taobao.org 域名将于 2022 年 05 月 31 日零时起停止服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4970b1724202db98b18fd062b98103d/" rel="bookmark">
			java笔试常见判断题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．在Java的方法中定义一个常量要用const关键字。
错，在java中定义常量用final。
2．抽象方法必须在抽象类中，所以抽象类中的方法都必须是抽象方法。
错，抽象类中必须要有抽象方法，但是同时也可以有非抽象方法。
3．用final修饰的变量叫常量。
对
4．描述对象的两个要素是属性和方法。
对
5．接口是特殊的类，所以接口也可以继承，子接口将继承父接口的所有常量和抽象方法。
对
6、Java支持多重继承。
错，是单继承。一个类最多只能够有一个基类，用extends实现。
7、final修饰的类能派生子类。
错，Final是最终类，不能再派生。
8、覆盖的同名方法中，子类方法不能比父类方法的访问权限低。
对
9、抽象类中能创建对象。
错误
10、一个类可以实现多接口。
对
11、Unicode码与ASCII码相同。
错
12、Java语言是编译解释型语言。
正确
13、Java语言支持类的继承,但只支持类的单继承。
对
14、抽象方法没有方法体。
错，可以有方法体。
15、方法的重载是指子类和父类具有相同的名字、相同的参数表，但返回类型可以不相同。
错，不是子类和父类之间吧。
16、在Java中声明变量时必须指定一个类型。
对
17、Java中，一个类可以有多个直接父类。
错，不可以，是单继承。
18、package语句必须放在程序的第一句。
对
19、一个Java类可以有一个直接父类，并可以实现多个接口。
对
20、接口中可以包含非静态成员变量。
错
21、不论是否捕捉到异常try{}catch ){} finaly{}语句中finally块中的代码总要被执行。
对
22、一个类实现一个接口，则该类必须实现接口中的所有方法。
对
23、final类中的属性和方法都必须是final的。
错，只是为了说明他不可派生。
24、在方法定义中，可能发生的异常都必须用try{} catch ){}捕捉。
错
25、Java 程序一般应当含有 main 方法，因为它是所有 Java 程序执行的入口。
错误。Java程序也可以是applet程序，如果是applet，不用main方法。。。由init初始化，start启用。
26、Java 语言的标识符是区分大小写的。
对
27、有时候为了避免引起混淆，构造方法的方法名可以不与所属类名同名。
错
28、在java继承机制中，父类中的私有 private）成员不能被子类继承。
错，可以被继承，但是不能被访问。
29、Java的类不允许多重继承，但接口支持多重继承。
对
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4970b1724202db98b18fd062b98103d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2dfbbfb1b6e86a7a7f23dbb5bf55359/" rel="bookmark">
			计算机网络学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、HTTP学习1.1 HTTP 简介1.1.1 HTTP 工作原理1.1.2 HTTP 注意事项 1.2 HTTP 消息结构1.2.1 客户端请求消息1.2.1.1 请求行1.2.1.2 请求头1.2.1.3 请求数据 1.2.2 服务器响应消息 1.3 HTTP 请求方法1.3.1 POST 与 GET 的区别 1.3 HTTP 状态码 二、TCP/IP学习2.1 TCP/IP 简介2.2 TCP/IP 协议2.2.1 TCP - 传输控制协议2.2.2 IP - 网际协议（Internet Protocol）2.2.3 HTTP - 超文本传输协议(Hyper Text Transfer Protocol)2.2.4 HTTPS - 超文本传输安全协议（HTTP Secure）2.2.5 SSL - 安全套接字层（Secure Sockets Layer）2.2.6 SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）2.2.7 MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）2.2.8 IMAP - 因特网消息访问协议（Internet Message Access Protocol）2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2dfbbfb1b6e86a7a7f23dbb5bf55359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9aca52b27ccb2d0b1f4e906524b1c24/" rel="bookmark">
			Python求最大公约数与最小公倍数的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最大公约数：
对于最大公约数求解，个人最喜欢辗转相除法和辗转相减法
1，辗转相除法：想对传入的两个数进行排序，大的数对小的数取余，什么时候取余为0，什么时候返回小的那个数即可。具体写法如下：
def biggest_common_divisor(x: int, y: int) -&gt; int: '''Compute the greatest common divisor of two numbers''' m,n = sorted([x,y],reverse=True) # m是大的，n是小的。辗转相除法 while m % n: r = m % n m = n n = r return n print(reduce(biggest_common_divisor,[6,12,32,80])) # 可判断一组内元素的最大公约数 2，辗转相减法：在两个数不相等的前提下，循环比较两个数的大小，使用大的数减去小的数并赋值给大的，直到两个数相等。
def biggest_common_divisor2(x: int, y: int) -&gt; int: '''Compute the greatest common divisor of two numbers''' while x != y: if x &gt; y: x -= y else: y -= x return x # return x也一样 最小公倍数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9aca52b27ccb2d0b1f4e906524b1c24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb65f2d03b5aceed7e3fc9d1379310a1/" rel="bookmark">
			gif怎么裁剪尺寸？一键gif裁剪工具推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们遇到一张gif图片尺寸不符合使用条件时，如何实现gif裁剪呢？今天给大家推荐一款动图gif编辑器–GIF中文网，这是一款支持手机、电脑双端操作的在线编辑gif（https://www.gif.cn/tools/cut）的软件，操作简单，只需三步就可以轻松裁剪gif图片，一起来看看吧！
入口：GIF中文网
打开首页选择gif工具中的GIF裁剪功能
上传gif图片，设置图片尺寸或者自行调整，然后裁剪
预览gif后下载就好了
按照以上步骤就可以顺利裁剪gif图片了，除此以外还支持gif合成、视频转gif、gif压缩等，想要了解更多gif编辑功能就快来一下吧。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/148/">«</a>
	<span class="pagination__item pagination__item--current">149/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/150/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>