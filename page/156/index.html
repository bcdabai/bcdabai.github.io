<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7bfdea4ec609acbf31144378bdd2b2/" rel="bookmark">
			【基于MATLAB的数字图像处理】第四章·图像增强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章 ·【基于MATLAB的数字图像处理】第一章·绪论
·【基于MATLAB的数字图像处理】第二章·视觉系统与图像处理系统
·【基于MATLAB的数字图像处理】第三章·基本图像变换
·【基于MATLAB的数字图像处理】第四章·图像增强
·【基于MATLAB的数字图像处理】第五章·图像编码
·【基于MATLAB的数字图像处理】第六章·形态学图像处理
·【基于MATLAB的数字图像处理】大作业·综合图像处理平台​​​​​​​
目录
一、空域图像增强技术
1.灰度直方图
2.直方图修正技术
a.直方图均衡化
b.直方图规定化
3.图像灰度映射
a.线性灰度映射
b.分段线性灰度映射
c.非线性灰度映射
d.灰度切分
4.图像间的运算
a.加法运算
b.减法运算
c.乘法运算
d.除法运算
5.图像平滑处理
a.线性平滑滤波器
b.非线性平滑滤波器
6.图像锐化处理
a.水平垂直算子
b.Roberts算子
c.Priwitt算子
d.Sobel算子
二、频域图像增强技术
1.低通滤波器
a.理想低通滤波器
b.巴特沃斯低通滤波器
3.其他低通滤波器
2.高通滤波器
a.理想高通滤波
b.巴特沃斯高通滤波器
c.高频增强滤波器
3.带通带阻滤波器
4.同态滤波器
三、频域增强技术与空域增强技术
图像增强是指采用一系列技术，对原图像进行处理、加工，使其更适合具体的应用要求，改善图像的视觉效果，将图像转换成一种更加适合于人和机器进行分析处理的形式。
图像增强不是以图像保真为原则，而是以需要为原则，增强图像中需要的信息，去除或削弱一些不需要的信息，分为空域增强和变换域增强，变换域增强主要是频域增强。
空域增强：直接对图像的像素灰度值进行操作。包括图像的灰度变换、直方图修正、图像空域平滑和锐化处理等。频域增强：在图像的变换域中，对图像的变换值进行操作，然后经逆变换获得所需的增强结果，常用的方法包括低通滤波、高通滤波以及同态滤波等。 一、空域图像增强技术 空域增强的通式是：
代表增强操作
点操作： 定义在每个(x,y)点上，输出图像的每个像素的灰度值仅由相应输入像素决定，如灰度映射方法。
模板操作：定义在点的邻域上，通常是使用一个模板滑过整幅图像产生新的像素，输出像素的灰度值由对应输入像素的一个邻域内的几个像素的灰度值共同决定，如图像平滑和图像锐化。
1.灰度直方图 灰度直方图：灰度直方图是灰度级的函数，描述的是图像中具有该灰度级的像素的个数：其横坐标是灰度级，纵坐标是该灰度出现的频率（像素的个数，或个数与总数之比）
直方图的性质：
不表示图像的空间信息：直方图只反应图像灰度分布的特性，和灰度所在的位置无关，将同一副图像中的像素位置改变时，图像的视觉效果会改变，但是灰度直方图并不会发生变化直方图反映了图像整体灰度分布的情况：较暗的图像，直方图的组成主要集中在灰度级低的一边；较亮的图像，直方图倾向于灰度级高的一侧。直方图有叠加性：如果一图像由两个不连接的区域组成，并且每个区域的直方图已知，则整幅图像的直方图是该两个区域的直方图之和 直方图的用途：
判断量化是否恰当：一幅高质量的数字图像应该利用全部或几乎全部可能的灰度级判断图像明暗：通过直方图的性质2可以判断图像整体效果的明暗判断图像对比度：在直方图中强对比度的图像灰度分布比较分散，而弱对比度的图像分布比较集中边界阈值选择：对于双峰直方图（一幅图背景是浅色的，其中有一个深色的物体），可以将阈值选定在两峰之间的谷处，用来提取前景物体的边界 例程：
%% 显示Lena女士灰度图的直方图 clear;clc; I=imread("Lena.tif"); I=im2double(I); subplot(121);imshow(I); subplot(122);imhist(I); 效果：
2.直方图修正技术 a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b7bfdea4ec609acbf31144378bdd2b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2157dd0f82079d74015bf3cb4a89b305/" rel="bookmark">
			三种质数筛（朴素、埃氏、欧拉）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种质数筛（朴素、埃氏、欧拉） 目的： ​ 将 1 ~ N 中的质数都筛选出来。
方一、普通质数筛 思路分析： 从2到n进行遍历，对于遍历到的数如果没有被筛掉，就说明该数是素数。然后每次把遍历到的数i的倍数都筛去。为什么说这个方案可以筛出质数可行呢？因为对于一个数p，它如果没有被筛掉，就说明其不是前面2p-1的倍数，也就是说2p-1不存在p的约数，这不就是素数的定义！
时间复杂度分析：O（nlogn）
对于 i = 2，需要删除n / 2个数；
对于 i = 3， 需要删除 n / 3个数
……
可以推出公式：
n 2 + n 3 + … … n n = n ∗ （ 1 2 + 1 3 + … … 1 n ） \frac{n}{2}+\frac{n}{3}+……\frac{n}{n}=n*（\frac{1}{2}+\frac{1}{3}+……\frac{1}{n}） 2n​+3n​+……nn​=n∗（21​+31​+……n1​）
其公式满足一个调和级数，当n接近正无穷时，其值等于：
l n n + c = l o g e n + c ln{n}+c=log_en+c lnn+c=loge​n+c
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2157dd0f82079d74015bf3cb4a89b305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8757b6542f671b8d6752c90568f8ccdf/" rel="bookmark">
			22岁-时光如河，浮生为鱼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时光如河，浮生为🐟。
​ 还没有学会告别，四年就这样悄悄过去了。如往年今日一样，依旧写些懒懒散散的文字致敬这一年的时光。
​ 💕22岁生日快乐。💕
全文约4200字，阅读大约需要10分钟。 ​ 22岁是大学四年的结束，也是新的一个开始。本来想了很多内容想去记录下来，但思绪像断掉的珍珠项链，却怎么也连不起来。既然如此，那就随便写写这四年吧。
​ 生活往往对你特别有意思。有时你想彻底放弃，但是总会有一只手要准备捞你一下。你呢？也很乖巧，也愿意顺着这根稻草想要爬一下，即使稻草断了也甘心。没错，我的高三就是这样。我记得当时我的成绩往往甚至可以说一直在本科线附近徘徊，如果非要换一句话说那就是成绩一直稳定在本科线以下。那时候，我其实是有点慌的，因为不知道未来的路该怎么走，当时想着高考完就再来一年吧。就这样高考完了，很多人问我考得怎么样，然后我基本地较为官方地回答是我已经找好复读一年的学校了。出成绩的前一天，我冒着很大的勇气且兴高采烈地给班主任打了一个电话，想问一下老师推荐的复读学校。那时候我心里是狂喜的，心里想：我的成绩是和本科无望了。那就实现和很多人吹过的牛吧，确定一下复读学校，下次别人问我，我就可以和别人郑重其事地说我的复读学校是啥了，甚至还可以推荐一下他的儿子或者女儿要不要来这个学校复读啊。
​ 第二天早上八点（记忆深刻是下午出的成绩，这里致敬某个up的特殊嗓音），成绩出来了，479分。一开始觉得还挺低的，认为也就在线上一点点吧。后来才知道了我在线上50多分的样子。当时高考买了一个报志愿的卡。可以根据位次查对应的学校（后来渐渐知道这可能是个智商税），山东农业大学不错，报名！刚刚好可以去他的中德合作的项目，一看学费4万。当时还是有点吃惊的，比较没见过这种名场面，认为学费8000就差不多了（当然，现在知道了我们校区现在的5万5的学费也是可以接受的，无diss，不争吵，争吵都是你对）。经过与父母双方的激烈争吵（其实没有，因为要学德语。。。我一门英语都没学好呢？？直接放弃），最后修改了山东农业大学的志愿。改成第一志愿是山东财经大学的与浪潮合作的金融分析专业。第二志愿是山东科技大学的与中兴合作的计算机科学与技术专业，第三是青岛农业大学的人工智能专业（青农在17年的时候就开了人工智能专业，有前瞻性，但是是第一期的小白鼠），第四第五后面的都忘记了。。。最终，被山科录取（那年的山科济南计算机的分数线就是479，我抓着山科分数线的尾巴进来了，也非常庆幸能来山科济南学习）。
​ 开学啦！我那天是买的中午的火车票（也有可能是下午，要不怎么会那么惨，报道的时候老师都收摊了）。到了济南站，手机突然没网了。。。打了半个小时的车。。。终于坐上了去学校的车。司机师傅亲切地问候我："你去的那个学校是堤口庄的那个科技大学吧？？"我心想：“我之前查到是学校是在市区啊，怎么去到庄里去了。。。”我回应师傅说：“师傅，先去吧。我也是第一次来。”过了15分钟左右，师傅提醒我到站了。我到一看。。。确实是堤口庄里面，学校的大门的西边的一个不起眼的角落里写着“山东科技大学”。（难怪当时某班有个同学来看了一眼就回家准备复读去了呢？当然，前天我走的时候学校的大门已经要装修了，nice!）。进去碰到了正在收摊的心健联的王学长。非常感谢王学长带我完成了开学的几乎所有的流程，带我参观了五分钟可以走完全程的学校（现在非常喜欢这个小学校，学习、吃饭非常方便）。
​ 现在已经凌晨一点了。白天坐了四个小时的车有点困了（手动@丁同学）。
​ 在大学里的时光基本就是学习、工作和比赛。其实学习给我的感觉并不是你考了多少多少分，而是喜欢那种被新的东西进入脑海的感觉。只要自己觉得有新的东西学到了，才觉得这一节课的时间自己是没有虚度的（当然，后来觉得躺着追剧，也是可以有新的剧情进入脑海的）。学习是没有什么技巧的，也没有捷径可言，也不需要有什么捷径，就是踏实学吧。之前高中班主任给我们讲了一种方法是当你闭上眼睛，能回想起你学过的东西，然后这种过程就像放电影一样，一幕一幕在眼前流过。这里手动@周老师。后来我将这种方法用在学习编程语言上。怎么理解一段代码是不是会写了？给你需求，你能把代码写出来，这就是会了）。早上六点起床，七点到教室占位学习，中午睡半个小时左右，晚上11点半回到宿舍睡觉，这个习惯基本坚持了三年吧（最后一年，突然觉得床才是的我爱，能多睡会就多睡会，当然，也可以说在补前三年的没睡够的觉。。。）。学习就是上课认真听课，课下做做作业感觉就够了。后来也知道了学校有3%的保研名额。其实一开始我没有考虑过把保研当作最后的方案（也可以说是成绩也没那么好，也达不到保研的条件）。想出去闯闯，但是后来因为有些事情的变化，也开始进去卷了。正式做决定开始卷是大二下（放了一个成绩单）。所以很多想准备保研的学弟学妹们，现在就可以开始卷了。事情什么时候开始准备都不算晚，但是一定要开始准备，并投入战斗。下定决心的事情就一定要有较强的执行力去完成。也不要觉得任何事情都不可能完成，我可能勉强能够做这样一个例子吧。做事情不要存在幻想，一直想是很难有什么收获的，一定要迈出那最难的第一步。
​ 可能最后几周的复习是取得一个比较好的成绩的关键。高中的老师之前讲过一个例子，高考的知识的范围是有限的，就像最外面的一个大的圆圈一样。你的知识也是更为有限的，你的知识是大的圆圈里面的小圆圈。复习是你的知识范围不断去重叠高考知识的范围的过程。你需要做的是不断寻找自己不会的知识，然后将它掌握，进而不断扩大你的知识范围。遇到不会的东西要感到庆幸，因为这还没有在最终的考试上出现。一套题上肯定有不会的，有些确定无法搞定的，要敢于舍弃。有些肯定能够拿到分的题目要做到100%拿到分数。我个人感觉这种做法挺好的。在我看来，任何考试，都是一个博弈的过程，是出题人和做题人之间的博弈。你能看出出题人的想法，那么这个博弈的过程你就赢了。出题人也会在出题的时候特别设置一些博弈点或者难点，这些难点他们是非常自豪的，他们也非常欣赏能够挖出那些难点的考生。做题的最高境界是与出题人对话，做题人的目的是要看出出题人的想法，并为之解决。
​ 比赛是我大学中花费时间比较多去做的。这是我获得的部分的比赛证书和志愿者证书。
我觉得获不获奖真的没有那么重要。你参与了这个事情的整个过程，其中的经历和你获得的成长是更加重要的。比赛先要明白这个比赛是做什么的。需要怎么做。比赛最好的参考资料是往届的获奖的作品和往届的学长学姐的经历。多参考别人的获奖作品，先去模仿，模仿别人获奖作品的一些共同点。
​ 面试。在保研面试的准备过程中，接触到了中科院计算所的一个胖胖学长，在他的直播中学习到了很多东西。我觉得任何面试都是展现自己的一个过程。面试的人真的太多了，尤其是现在这么卷的当下。那么怎么才能从面试中脱颖而出真的挺重要的。面试就是将自己的特长发挥出来，你要让面试的老师感觉到你是不一样的，你在这方面还是ok的。比如，你的编程能力比较强，你可以展现或者介绍一下你的项目。如果你的文笔不错，你可以给老师看一下你写的论文。
​ 就业、考研之间的选择。之前有学弟问我在考研和就业之间的选择。这选择有时候真的很难做决定。考研现在真的很卷。但是就业不也是这样吗？在深度学习中，有一个优化方法是梯度下降法（不用理会，就是一个方法），这种方法也是在找一个全局最优解。但是往往容易陷入局部最优当中。我们每个人的人生何尝不是一个最优化的过程呢？我们每次也是在做一次选择，在漫漫时间长河中，可能我们每次做的选择都不一定是对的。但是难道不是我们只有做了这个选择之后才能知道这个选择是不是最优解嘛？或者说前面的其他人做了这个选择，你知道了以后也可以给你的方向提供选择。**我的想法是20岁左右的人有时间去试错，而一直安逸却不是一个较好的选择。**选择错了没问题，爬起来，保持方向，进行30岁前的下一次选择，只要我们选择的目的是好的是对的，那么最后是会殊途同归的。
时间挺晚了，越写到最后就越没有那么清醒了。无论之前获得了多少荣誉，这些都已经过去了。在新的起点，开始新的征程。大家顶峰相见，我继续造人工智障了。
2020年8月10日1点28分
​ 最后的最后，我们在暗流湍急中相会，总是命里该遇。就算那日不见，也终会路左相逢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0734d5e64e5d52034b304737f654c516/" rel="bookmark">
			Kaggle心脏病数据集为例学习机器学习的可解释性分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要安装的工具包 pip install numpy pandas matplotlib seaborn wheel pandas_profiling jupyter notebook -i https://pypi.tuna.tsinghua.edu.cn/simple pip install graphviz pydotplus -i https://pypi.tuna.tsinghua.edu.cn/simple 后面需要画出决策树，需要将将graphviz加入系统环境变量当中，以及将如下代码加入程序中。
import os os.environ["PATH"]+=os.pathsep+"G:/soft_exe/Graphviz/bin/" "G:/soft_exe/Graphviz/bin/"是你的graphviz的安装目录。
安装机器学习第三方工具包 pip install scikit-learn -i https://pypi.tuna.tsinghua.edu.cn/simple 安装机器学习可解释性第三方工具包 pip install pdpbox eli5 -i https://pypi.tuna.tsinghua.edu.cn/simple 安装机器学习可解释性分析工具shap pip install shap -i https://pypi.tuna.tsinghua.edu.cn/simple 在安装shap时候，可能会出现缺少MICROSOFT VISUAL C++ 14.0的问题：我尝试了几种方案，然后最后解决的是通过安装vs解决的，如下图那个选项一定要选。
数据简单探索 import pandas as pd df=pd.read_csv("heart.csv") df.head() 数据集的话，建议大家注册一个账号去kaggle上面下载就好了。
查看数据集大小
df.shape 查看各个列的名
df.columns df.info()#各列的数据个数 查看各个列是否有缺失值
df.isnull().sum() #查看各列缺失值数目 一行代码生成探索性分析EDA报告 import pandas_profiling profile=pandas_profiling.ProfileReport(df) profile 基本通过这个探索性报告就能详细了解这个数据集了。这个很强大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0734d5e64e5d52034b304737f654c516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb7a8891e818022a00d7560738d9ace/" rel="bookmark">
			3-13 字典应用--用户登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有字典如下：
dic = {'admin':'123456','administrator':'12345678','root':'password'}
实现用户输入用户名和密码，当用户名与密码和字典中的键值对匹配时，显示“登录成功”，否则显示“登录失败”，登录失败时允许重复输入三次。
输入格式: 在两行中分别输入用户名和密码
输出格式: "登录成功"或"登录失败"
输入样例: admin 12345678 admin 123456 输出样例: 登录失败 登录成功 dic = {'admin':'123456','administrator':'12345678','root':'password'} #题目已给出的对应的键：值（账号：密码） for i in range(0,3): #就输入一次账号密码，循环两次 x = input() #账号 y = input() #密码 if x in dic.keys(): #账号存在（键存在） if dic[x] == y: #密码正确（键对应的值正确） print('登录成功') break else: #密码错误 print('登录失败') else: #账号不存在 print('登录失败') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f0abf2dc6935a1f43b867f67583959/" rel="bookmark">
			TX2如何下载源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.首先下载sdk_manger烧写工具，执行一次烧写，这样环境就配置好了
1、先确认版本号
官网：L4T 32.7.1 is included as part of JetPack 4.6.1
cat /etc/nv_tegra_release#查看l4T版本 2、下载源码
执行同步代码命令：~/nvidia/nvidia_sdk/JetPack_4.6.1_Linux_JETSON_TX2_TARGETS/Linux_for_Tegra$ ./source_sync.sh
3.所有需要输入的地方输入以下版本号就行
tegra-l4t-r32.7.1 3.等待完成即可，sources文件夹里面就是源码。
【TX2】安装NVIDIA SDK Manager（JetPack 4.6）后，下载kernel和u-boot源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/710603a46f3594b3c8c4e6385e26d021/" rel="bookmark">
			python批量修改图片名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 在用python做一个蜘蛛纸牌时，需要添加多张纸牌的照片，而用tkinter.PhotoImage()仅支持gif等几种不常用的图片格式这就需要批量修该图片名，一个一个修改太麻烦，于是就网上搜了一下用python批量修改文件名的代码，自己稍作加工就可以了，我是把一个目录下的所有图片，直接命名为从1到图片的个数。
问题描述： #修改图片名 import os print("注：此程序会将该目录下所有图片从1开始重命名") h=input("你想要修改成的后缀名:") dir=input("请输入要修改的文件目录的地址:") imglist = os.listdir(dir)#返回该目录下所有文件名的列表 num_files = len(imglist) for x in range(0,num_files): print("--------------------------") old_file = os.path.join(dir, imglist[x])#旧文件名的全路径名 print(old_file) imglist[x]=str(x+1)#遍历文件名修改为：序号+1 注意这里要类型转换 print(imglist[x]) new_file = imglist[x] + h #为新文件名添加后缀名 print(new_file) #new_file = os.path.join(dir,new_file)# new_file = dir+'\\'+new_file os.rename(old_file, new_file) new_file = os.path.join(dir,new_file) new_file = dir+'\\'+new_file 这两条语句是等价的，一开始，我是直接这样写的：new_file = dir+new_file，没有加‘\\’(这里要加双斜杠‘\\’,一个不行)，结果导致的问题就是：例如我的图片目录是：D:\ege\百度图片-发现多彩世界 ，我直接加上文件名后，执行程序所有的图片移动到了ege目录下，且图片名字前面加上了‘百度图片-发现多彩世界 ’。
解决tkinter.PhotoImage()仅支持gif等几种不常用的图片格式问题
这个是在用cmd运行java程序时发现编码格式要为gbk所以就写了这个程序来批量修改指定目录下的所有文件编码格式，注意当文件内容很少时，识别的编码格式可能会不准确。utf-8，gbk都支持。
#修改文件格式 import os import chardet import codecs print("注意：如果文件内容太少可能识别不准确") h=input("你想要转化成什么编码格式？") print("注意此目录下的所有文件编码都将被修改") dir=input("请输入要修改的文件目录的地址:") imglist = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/710603a46f3594b3c8c4e6385e26d021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa03fabdacbbc8d4b5188b29373ef3c/" rel="bookmark">
			[计算机组成原理]第三章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第三章 数据的表示和转换 机器数表示定点补码加减法运算浮点数的加减法 数据范围关于ALU的讨论74181逻辑图IEEE754标准浮点数规格化对阶操作二进制乘法运算 定点数原码乘法 原码一位乘原码两位乘(不考)定点数补码乘法 定点数补码一位乘 校正法比较法定点数补码两位乘(不考)二进制除法运算 原码一位除 恢复余数法加减交替法补码一位除 加减法交替法Booth法(了解，不考)无符号阵列乘法器数据校验码 奇偶校验码海明校验码循环冗余校验码(CRC) 如何检错本章要点 第三章 声明：Ayaka师傅yyds
数据的表示和转换 计算机为什么使用二进制？
十进制数和数字串之间的关系？
机器数表示 https://www.cnblogs.com/xfcao/p/10375645.html
正数的反码是他本身，
负数的补码＝反码+1
机器数表示方式小数原码： 整数原码： 小数补码： 整数补码： 补码相对于原码来说，可以多表示一个数，即区间下限。 补码运算规则：两个补码的 和/差 等于 和/差 的 补码 定点补码加减法运算 原理框架 补码运算规则：两个补码的 和/差 等于 和/差 的 补码 溢出的判断
例子： 红色的1被舍弃掉了 采用双符号变形补码计算的 例子： 只有当两个符号位不相同的时候才发生溢出 浮点数的加减法 原理图 数据范围 关于ALU的讨论 1、ALU是组合电路，因为所见即所得
2、改变进位产生函数Gi，和进位传递函数Pi获得多重运算能力
3、根本区别：进位之间是否有关联，有关联的是算术运算，没有关联的是逻辑运算
74181逻辑图 IEEE754标准 https://blog.csdn.net/leader_song/article/details/121647097
浮点数规格化 阶码+尾数表示浮点数：
例子： 移动尾数，使尾数的有效数码尽可能地占满尾数的有位格对于基为2的浮点数，若满足1/2≤|m|&lt;1则称为规格化数
规格化方法为调整阶码和尾数满足下列关系：
尾数为原码时，无论正负应满足1/2≤|m |&lt;1，即小数点后的第一位数一定要为1
正数的尾数应为0.1xxxxx
负数的尾数应为1.1xxxxx
尾数为补码时，小数最高位应与符号位相反
正数应满足0.1xxxxx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efa03fabdacbbc8d4b5188b29373ef3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44d814c6bf981de34410ca67ceae739/" rel="bookmark">
			一、C&#43;&#43;简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C++简介
C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。高级语言：实现效率高，执行效率低，对硬件的可控性弱，目标代码大，可维护性好，可移植性好。低级语言：实现效率低，执行效率高，对硬件的可控性强，目标代码小，可维护性差，可移植性差。
二、C++特征
C++是面向对象程序设计语言，所以包含面向对象的四大特征：
1、封装：封装指的是将隐匿某一方法执行步骤，取而代之的是消息传递机制发送消息给它。
2、继承：一个类有子类，子类(派生类)对比父类(基类/超类)实现更加具体化。
3、多态：由继承产生的相关的不同的类，其对象对于同一方法做出不同的效应。
4、抽象：是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。
三、C++程序运行过程
C++语言程序从编写到运行要经过以下几个阶段：编写 =&gt; 预编译 =&gt; 编译 =&gt; 连接 =&gt; 运行
1、编写：在源文档中编写C++语言代码
2、预编译：执行预编译指令，生成中间代码
3、编译：编译预编译生成的中间代码，生成目标文件（.obj）
4、连接：将目标文件生成可执行文件( .exe)
5、运行：执行exe程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98b1bfda484f4ee2bb16c569da74e42/" rel="bookmark">
			js 金额千分位转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数字转千分位 ​ /* * 默认返回当前数字千分位格式 * 参数说明： * number：要格式化的数字 * decimals：保留几位小数 * dec_point：小数点符号 * thousands_sep：千分位符号 * roundtag:舍入参数，默认 "ceil" 向上取,"floor"向下取,"round" 四舍五入 * 默认为保留两位小数，以逗号隔开，四舍五入 * */ export function formatCurrency( number: string | number, decimals = 2, dec_point = '.', thousands_sep = ',', roundtag = 'round' ) { if (isEmpty(number)) { return null } else { number = (number + '').replace(/[^0-9+-Ee.]/g, '') roundtag = roundtag || 'ceil' // "ceil","floor","round" const n = !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a98b1bfda484f4ee2bb16c569da74e42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae0a632ff60e61c256166b189758e02/" rel="bookmark">
			lsyncd-实时同步（镜像）守护程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E-mail: 1226032602@qq.com
官方文档 https://axkibe.github.io/lsyncd/
https://github.com/axkibe/lsyncd
简介 Lsyncd使用文件系统事件接口（inotify或fsevents）来监视对本地文件和目录的更改。Lsyncd将这些事件整理几秒钟，然后生成一个或多个进程以将更改同步到远程文件系统。默认同步方法是rsync
Lsyncd是一种轻量级的实时镜像解决方案。Lsyncd相对容易安装，不需要新的文件系统或块设备。Lysncd不会妨碍本地文件系统性能
可以通过配置文件实现细粒度的自定义。自定义操作配置甚至可以从头开始编写，从shell脚本到用Lua语言编写的代码
版本要求 Lsyncd 2.2.1要求所有源和目标计算机上的rsync&gt; = 3.1
安装 lsyncd 在 epel源中
yum install lsyncd 配置 配置文件说明 /etc/lsyncd.conf
lsyncd配置文件使用lua语法编写
settings settings { logfile 日志文件 pidfile pid文件 nodaemon 表示不启用守护模式，默认 statusFile 运行状态文件 statusInterval 将lsyncd的状态写入上面的statusFile的间隔，默认10秒 inotifyMode 指定inotify监控的事件，默认是CloseWrite，还可以是Modify或CloseWrite or Modify maxProcesses 最大进程数 maxDelays 累计多少监控事件同步一次,即使delay时间未到也同步 } sync 三种模式 default.rsync sync { default.rsync, source = "/tmp/src", target = "172.29.88.223:/tmp/dest", maxDelays = 5, delay = 30, -- init = true, rsync = { binary = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae0a632ff60e61c256166b189758e02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d8cf27cc211258f892f27ca3e98634/" rel="bookmark">
			java多线程与动态代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图在结尾
java多线程增强 java多线程基本知识 进程介绍 不管是我们开发的应用程序，还是我们运行的其他的应用程序，都需要先把程序安装在本地的硬盘上。然后找到这个程序的启动文件，启动程序的时候，其实是电脑把当前的这个程序加载到内存中，在内存中需要给当前的程序分配一段独立的运行空间。这片空间就专门负责当前这个程序的运行。
不同的应用程序运行的过程中都需要在内存中分配自己独立的运行空间，彼此之间不会相互的影响。我们把每个独立应用程序在内存的独立空间称为当前应用程序运行的一个进程。
进程：它是内存中的一段独立的空间，可以负责当前应用程序的运行。当前这个进程负责调度当前程序中的所有运行细节。
线程介绍 启动的QQ聊天软件，需要和多个人进行聊天。这时多个人之间是不能相互影响，但是它们都位于当前QQ这个软件运行时所分配的内存的独立空间中。
在一个进程中，每个独立的功能都需要独立的去运行，这时又需要把当前这个进程划分成多个运行区域，每个独立的小区域（小单元）称为一个线程。
线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。
进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。一个进程中至少应该有一个线程。
多线程介绍 现在的操作系统基本都是多用户，多任务的操作系统。每个任务就是一个进程。而在这个进程中就会有线程。
真正可以完成程序运行和功能的实现靠的是进程中的线程。
多线程：在一个进程中，我们同时开启多个线程，让多个线程同时去完成某些任务（功能）。
(比如后台服务系统，就可以用多个线程同时响应多个客户的请求)
多线程的目的：提高程序的运行效率。
多线程运行的原理 cpu在线程中做时间片的切换。
其实真正电脑中的程序的运行不是同时在运行的。CPU负责程序的运行，而CPU在运行程序的过程中某个时刻点上，它其实只能运行一个程序。而不是多个程序。而CPU它可以在多个程序之间进行高速的切换。而切换频率和速度太快，导致人的肉眼看不到。
每个程序就是进程， 而每个进程中会有多个线程，而CPU是在这些线程之间进行切换。
了解了CPU对一个任务的执行过程，我们就必须知道，多线程可以提高程序的运行效率，但不能无限制的开线程。
实现线程的两种方式 1、继承Thread的方式
见代码MyThreadWithExtends
2、声明实现 Runnable 接口的方式
见代码MyThreadWithImpliment
java同步关键词解释 synchronized 加同步格式：
synchronized( 需要一个任意的对象（锁） ){
代码块中放操作共享数据的代码。
}
见代码MySynchronized
synchronized的缺陷 synchronized是java中的一个关键字，也就是说是Java语言内置的特性。
如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：
1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；
2）线程执行发生异常，此时JVM会让线程自动释放锁。
例子1：
如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。
因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。
例子2：
当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。
但是采用synchronized关键字来实现同步的话，就会导致一个问题：
如果多个线程都只是进行读操作，当一个线程在进行读操作时，其他线程只能等待无法进行读操作。
因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。
另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。
总的来说，也就是说Lock提供了比synchronized更多的功能。
2.2 lock lock和synchronized的区别 1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；
2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。
java.util.concurrent.locks包下常用的类 Lock 首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口：
public interface Lock {
void lock();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4d8cf27cc211258f892f27ca3e98634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ebc07cca151ab889107948940b0b8e9/" rel="bookmark">
			利用C语言输入二进制转化成十进制。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #define AS 20 void qw(char ps[],int v); int u = 0; int main(void) { int p = 0; char as[AS]; while (1) { printf("请输入二进制数："); gets_s(as, AS - 1); p = strlen(as); qw(as, p); } return 0; } void qw(char ps[],int v) { int h; int k = 0; int l = 0; int a = 0; for (h = v-1; h &gt;= 0; h--) { if (ps[h] == 49) { k = pow(2,a); l += (1 * k); } else if (ps[h] &gt; 49) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ebc07cca151ab889107948940b0b8e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca25f8214b8495f7daa5261e78536c2a/" rel="bookmark">
			Win系统设置虚拟内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win系统设置虚拟内存 前言虚拟内存设置方法 前言 虚拟内存可以让系统将硬盘上的部分空间当做内存使用，使计算机可以运行更多的应用程序，但若将其设置的过大，则会大量占用系统盘（C盘）空间，那么如何设置虚拟内存呢。方法见下文，以Win10系统为例，其它Windows系统类似。
虚拟内存 注意： 虚拟内存与备用内存不同，若想了解备用内存，详见我的另一篇博客：清理备用内存 。
虚拟内存是计算机系统内存管理的一种技术。当系统物理内存不够使用时，将硬盘上的部分空间当做内存（RAM）使用，使得计算机可以运行更多的应用程序。
虚拟内存是系统作为内存使用的一部分硬盘空间。Windows系统中，虚拟内存在硬盘上是为一个比较大的文件，文件大小即虚拟内存的大小，文件名是PageFile.Sys，在文件资源管理器中默认是隐藏的。必须关闭隐藏功能才能看到这个文件。这也是虚拟内存有时也被称为页面文件的原因。
设置方法 右键桌面此电脑，点击属性，点击高级系统设置，如下图：
（注意：若桌面没有此电脑快捷方式，可在Windows搜索中找到）
在系统属性弹窗中选择高级选项卡，点击性能模块中的设置按钮，如下图：
在性能选项弹窗中选择高级选项卡，点击虚拟内存模块中的更改按钮，如下图：
若不想手动设置虚拟内存的大小，可以选择自动管理，如下图：
若想停用虚拟内存，则需取消勾选自动管理，选择C盘驱动器，选择无分页文件，最后点击设置，如下图：
（注意：不推荐停用虚拟内存，因为有部分软件运行时会向虚拟内存中写入文件，若取消虚拟内存可能会出问题）
若想手动设置虚拟内存大小，则需取消勾选自动管理，选择C盘驱动器，选择自定义大小，设置初始大小和最大值，最后点击设置，如下图：
（注意：虚拟内存大小推荐设置2G到4G，新时代物理内存很充足，设多了也没用，还会占用系统盘空间）
最后，配置好虚拟内存后，系统可能会提示重启，此时可选择立即重启或稍后重启，根据自身情况选择即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/567095aca09a165b16c595a074820acb/" rel="bookmark">
			解决 “const char *“ 类型的实参与 “LPCWSTR“ 类型的形参不兼容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在“解决方案资源管理器里”右键单击我们的项目，弹出菜单后选择“属性”菜单项，依次找到“高级”----“高级属性”----“字符集”，从字符集的选项里选择“使用多字节字符集”
单击确定即可，再次编译就不会再出现此类错误提示了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e47317e83933f30b3f1c56a39470027f/" rel="bookmark">
			visual studio c&#43;&#43; 动态调用第三方DLL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先在vs里面附加头文件
在左侧“解决方案”的项目上右键单击，会弹出菜单，选择“属性”菜单项，选择 “c/c++” 下的 “常规” “附加包含目录” ，选择头文件所在的目录即可。
在源代码里引用头文件
使用LoadLibrary动态加载dll动态链接库
这个dll文件要放入项目所在目录，我这里放在了生成exe的目录（debug目录）所以需要修改调试的工作目录，如下图
一般头文件中会给出这个函数是什么样子的，比如下面这个声明定义了一个类型叫做AddScenarioFunc，它表明这个函数的返回值是int类型，接收一个字符串作为入参。
typedef int (*AddScenarioFunc)(const char* sceName); 使用GetProcAddress函数从dll中获取这个函数的地址，然后调用就可以了
AddScenarioFunc addScenario = (AddScenarioFunc)GetProcAddress(hDll, "AddScenario"); if (addScenario != NULL) { addScenario("./BGE/TYscenario/01子宫破裂（带状态跳转）.xml"); } 最后使用FreeLibrary函数释放掉资源 FreeLibrary(hDll); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4a76c6753bbaf6c7d9c56ec6050f94/" rel="bookmark">
			PHP clickhouse扩展与clickhouse单机性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统centos 7.7.1908,php 是yum安装的5.4。
扩展安装：
wget http://pecl.php.net/get/SeasClick-0.1.0.tgz
yum install -y php-devel.x86_64
phpize
./configure
make
cp ./.libs/SeasClick.so /usr/lib64/php/modules/SeasClick.so
cp ./.libs/SeasClick.lai /usr/lib64/php/modules/SeasClick.la
vi /etc/php.ini
增加 extension=SeasClick.so
[root@localhost SeasClick-0.1.0]# php -i |grep SeasClick
SeasClick
SeasClick support =&gt; enabled
PWD =&gt; /root/SeasClick-0.1.0
_SERVER["PWD"] =&gt; /root/SeasClick-0.1.0
特别注意 host 要改为 127.0.0.1，SeasClickreadme里面的host是SeasClick，会报错：
PHP Fatal error: Uncaught exception 'Exception' with message 'No such file or directory'
让人一头雾水。
&lt;?php $config = array( "host" =&gt; "127.0.0.1", "port" =&gt; 9000, "compression" =&gt; true ); echo class_exists('SeasClick')?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c4a76c6753bbaf6c7d9c56ec6050f94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1b02565b6808cb4f375bcc8724f178/" rel="bookmark">
			优麒麟系统中QtCreator无法输入中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优麒麟系统，发现在QtCreator中无法输入中文。网上有文章说是缺了动态库的支持。找到一个方法可行，记录如下：
进入以下路径：
Qt5.12.12/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts
右击，用终端打开：
输入指令：
cp /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so . chmod +x libfcitxplatforminputcontextplugin.so reboot 也就是复制.so文件 + 改权限 + 重启
重启之后，QtCreator可以输入中文了：
参考：关于Linux下qt-creator无法切换中文输入法并无法输入中文的问题_jeady小五的博客-CSDN博客_qt无法切换中文输入法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce5f1f471472391beb04010886a4f64/" rel="bookmark">
			C&#43;&#43; ifstream open 读取txt/json文件出现中文乱码的解决问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ ifstream open 读取txt/json文件出现中文乱码的解决方法 作者：虚坏叔叔
博客：https://xuhss.com
早餐店不会开到晚上，想吃的人早就来了！😄
在编程中，我们经常需要对txt/json文件进行读写操作，有时候由于编解码问题，txt读写会出现乱码问题。下面介绍一种基于ofstream和ifstream的txt文件读写方法，并介绍txt文件读写的乱码解决方案。
一、txt文件写入 #include &lt;fstream&gt; #include &lt;iostream&gt; using namespace std; int main() { ofstream outfile("1.txt",ios::ate); //打开文件，设置写入方式为覆盖写入 if(!outfile) { cout&lt;&lt;"txt文件打开失败!"&lt;&lt;endl; exit(0); } outfile&lt;&lt;"写入txt文件示例.\n"; outfile&lt;&lt;"成功写入.\n"; outfile.close(); } txt里面的写入内容如下：
成功写入。
二、txt文件读出 对上面读入内容的txt进行读出操作，代码如下：
#include &lt;fstream&gt; #include &lt;iostream&gt; using namespace std; int main() { char txt[100]; ifstream infile; infile.open("1.txt"); if(!infile.is_open()) { cout&lt;&lt;"txt文件打开失败"&lt;&lt;endl; exit(0); } while(!infile.eof()) { infile.getline(txt,100); cout&lt;&lt;txt&lt;&lt;endl; } infile.close(); getchar(); } 读出结果为：
读出结果正确。
三、 txt读写乱码问题 有时候由于txt文件编码问题的不同，会导致读写的时候出现乱码，通常的txt编码方式有：
上面默认的编码方式为ANSI，如果我们现在将它另存为1.txt，但编码格式变为UTF-8，那么读出结果会变成：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce5f1f471472391beb04010886a4f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3622085cecb12cc19d329d68d52e6056/" rel="bookmark">
			Echarts官方实例地图不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方显示是这个样子
下载后打开是这个样子
就一个标题，啥都没有
查了好多说的都很复杂，而且作为新手也看不懂
可以这么改
找到这个文件代码中的这一行
&lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts@5.3.2/dist/echarts.min.js"&gt; 给注释掉，把下面这些代码加上
&lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-gl/dist/echarts-gl.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-stat/dist/ecStat.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts/dist/extension/dataTool.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts/map/js/china.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts/map/js/world.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://api.map.baidu.com/api?v=2.0&amp;ak=0YcYchrztiOxuU3IGBu3Nvq0N106Whkn&amp;__ec_v__=20190126"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts/dist/extension/bmap.min.js"&gt;&lt;/script&gt; 这样就可以了
注意：运行后会提示没有百度地图的API，需要去申请并获得ak码（申请其实就是注册一下填一下信息）后从我让你们新加的代码里的倒数第二行的这个位置替换掉
申请ak码可以看这篇
百度地图申请API
就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84408924649bb879bcf633814ec5c76/" rel="bookmark">
			pandas的数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.pandas介绍
2.pandas的数据结构
2.1 Series
2.1 创建一个Series
2.1.1 创建一个具有标签索引的Series
2.1.2 使用python字典创建 Series
2.2 DataFrame
2. 2.1 根据多个字典序列创建dataframe
2.2.2 根据从文件、mysql中读取创建dataframe
1.pandas介绍 python数据分析三剑客：numpy、pandas、Matplotlib
NumPy(Numerical Python)：Python语言的一个扩展程序库，支持大量的维度数据与矩阵运算，针对数组提供大量的数学函数库 Pandas是一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能。 Matplotlib是一个python绘图包
pandas安装： 1、下载使用Python类库集成安装包：anaconda https://www.anaconda.com 当今最流行的Python数据分析发行版 已经安装了数据分析需要的几乎所有的类库
2、pip3 install pandas
本课程演示方式 使用jupyter Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 安装： pip3 install jupyter（需要python3.3或更高版本，或python2.7） 运行： jupyter notebook
########################################
2.pandas的数据结构 2.1 Series Series是一种类似于一维数组的对象，它由一组数据（不同数据类型）以及一组与之相关的数据标签（即索引）组成。Seriers的交互式显示的字符串表示形式是索引在左边，值在右边。 类似一个有序的字典。
########################################
2.1 创建一个Series &gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; s1 = pd.Series([1,'a',5.2,7]) &gt;&gt;&gt; s1 0 1 1 a 2 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c84408924649bb879bcf633814ec5c76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8185ed0a3de9a4d76797a89247ccc726/" rel="bookmark">
			贷前中后简单记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前中后 贷前贷中贷后是一个业务分类，是用户信贷生命周期的三个阶段。并不是一个业务架构或者技术架构。以下的贷前贷中贷后主要是互金领域的情况，传统银行也有贷前贷中贷后，但是做法不同。
贷前 1、准入/额度/利率
贷前的核心就是两个，准人和额度。
准入在信贷中基本采用预准入，即将用户的信息收集起来，提前算好，这个用户能否进来。这部分除了模型，就是黑名单和域外数据，模型负责计算这个用户违约的概率（信用评级/欺诈评级），黑名单是将各种黑灰产拦截掉（例如其他场景的，行业共享的各类黑名单数据）。
额度，有了用户的信用评级，那么可以从历史数据中得到每个用户可以使用的安全额度边界，每个评级的用户在应对不同额度的时候是有不同的违约率的，那么需要对不同资质的客群制定不同的额度。额度一般由几个核心变量控制：1，信用评级 2、资产情况（职业/收入/资产） 3、欺诈评级，这三个变量交叉使用，制定每个用户的额度。额度一般是由策略同学根据当前的风险情况手动测算出，这样的好处是灵活，可控。算法只产出评级排序。
2、用户成长体系
以上讲的准入额度，还伴随着一个核心：testlearn，low&amp;grow， 在用户的额度授予过程中，很多时候用户空白或者业务刚刚启动，是无法通过算法或者策略直接给出一个比较高的额度的（有风险且不可估），需要慢慢探测，一般都是在不同等级的用户给出一个不同的初始额度，然后通过客群表现，不断的调整额度，在积累用户数据的同时，提升模型，增加放款余额。这样你的风控系统，用户数据，用户额度都能得到安全的成长。这种思路贯穿整个风险管理。
信贷业务风控的成功 = 丰富的数据+科学的用户额度管理（策略体系）+模型体系。
算法做什么：
1、信用模型/欺诈模型构建用户评级
2、用户收入预测/职业/资产预测
3、用户成长过程中的ab测试，指标构建
其他
贷中 1、支用监控
支用监控，是指用户在准入和额度都通过的情况下，仍然会存在风险，这种风险一般在支用的环节中需要进行风控。
这种风险主要分三类：
1）安全类的风险（例如盗号，三方诈骗）
2）信用类风险（本人资质变化，偿还能力变化，更多数据进来）
3）合规类的风险（监管不允许的，例如赌博，套现）
2、实时的额度调整
贷中更像是用户支用行为中的管控，作为贷前的补充，减少损失。用户在支用首笔后，平台在获得更多的数据后（比如这个用户支用之后的购物情况消费情况等，比如从其他平台获取的补充信息），平台可以决定是否给这个用户进行管控，策略的提额/降额都可以在这个时候产生。
有些策略只能在贷中的时候进行实施，例如花呗的反套现，借呗反欺诈，在交易环节能拿到更多的数据，可以进行灵活的额度调整，例如用户在一个历史出现频繁套现的商家使用花呗支付苹果手机/黄金这些易变现商品，例如双11为了更好的用户体验和GMV增长，在某些品类上给用户更高的临时额度。
算法承担什么：
1、欺诈模型，特征，额度策略
贷后 互金的贷后就是催收，主要是互金的贷款产品期限都比较少，一般12个月，一个月还一次，基本坏用户1-3个月就暴露出来了。传统银行可能是几年，额度更大，贷后主要是线下进行用户调查。
催收的问题是如何提升催收的效率，在合法合规的情况下，管理催收人员，安排催收次序（催收人力是有限的）。
1、高效管理催收人员
2、合理安排催收的次序和频率
3、提供高效的产品帮助催收完成任务
算法需要去做什么：
1、预测哪些用户更容易催收成功，进行贷后的用户排序
2、不同类型的用户提供不同的催收话术和套路
3、合理安排催收的节奏，例如催收的频率，时间节奏
4、帮助找到逾期的人（很多人逾期会失联）
基本流程图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce33693afb0498d95fd9cc507572a535/" rel="bookmark">
			华为ensp---ACL实验2---三层交换机限制VLAN互访
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：三层交换机，多个VLAN
需求：ACL限制VLAN间的互访(192.168.50.0不能访问192.168.2.0)
关键词：高级ACL。根据源IP地址、目的地址、IP协议类型、TCP源/目的端口、UDP源/目的端口号、分片信息和生效时间段等信息来定义规则，对IPv4报文进行过滤。与基本ACL相比，高级ACL提供了更准确、丰富、灵活的规则定义方法。例如，当希望同时根据源IP地址和目的IP地址对报文进行过滤时，则需要配置高级ACL。
VLAN和VLANIF配置省略
PC3可以PING通PC4
由于流量从接口GE0/0/2进入Switch，所以在接口GE0/0/2的入方向应用流策略。 [Huawei] acl 3000
[Huawei-acl-adv-3000] rule 5 deny ip source 192.168.50.0 0.0.0.255 destination 192.168.2.0 0.0.0.255 //
[Huawei-acl-adv-3000] quit
[Huawei]traffic classifier tc1 //创建流分类
[Huawei-classifier-tc1]if-match acl 3000 //将ACL与流分类关联
[Huawei-classifier-tc1]q
[Huawei]traffic behavior tb1 //创建流行为
[Huawei-behavior-tb1]deny //配置流行为动作为拒绝报文通过
[Huawei-behavior-tb1]q
[Huawei]traffic policy tp1 //创建流策略
[Huawei-trafficpolicy-tp1]classifier tc1 behavior tb1//配置流行为动作为拒绝报文通过
[Huawei-trafficpolicy-tp1]int g0/0/2
[Huawei-GigabitEthernet0/0/2]traffic-policy tp1 inbound //流策略应用在接口入方向
[Huawei-GigabitEthernet0/0/2]dis acl 3000
设置ACL后，PC3无法PING通PC4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78f8abb34a63f4dfdee36bdbddcfbc4f/" rel="bookmark">
			Linux磁盘扩容【2T内(fdisk工具/MBR磁盘分区)】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因需要现将Vmware vSphere Client平台上的机器存储进行扩容，如下图所示原先盘及分区大小，以及模拟数据：一个测试文件。
文中使用fdisk分区命令（不支持超过2T,超过2T可以使用parted工具）和MBR磁盘分区（MBR单分区不支持超过2T，超过2T可以使用gpt磁盘分区）
先建立一个1T大小的磁盘，创建好分区并格式化为ext4文件系统，挂载好后并写入一个模拟数据
如图可以看到一个1T大小的磁盘，使用fdisk工具操作，输入m列出操作选项。
输入n创建一个分区（默认是MBR/dos磁盘分区），接下来回车默认是全选空间做第一个分区。
输入p打印出磁盘分区表信息，输入w保存退出。
执行mkfs.ext4 命令将格式化分区为ext4格式的文件系统。
上述操作执行完可以看到默认磁盘分区为MBR/dos类型，磁盘及分区大小正常，挂载也正常。
创建一个测试文件当做模拟数据后续验证使用。
将磁盘扩大至2T。
扩大完直接fdisk命令查看没有变化，执行umount取消挂载，再执行partprobe让内核重新读取分区信息后，执行fdisk命令查看磁盘大小信息正常。但通过lsblk查看分区大小还是原大小，需要扩大分区。执行e2fsck -f命令检查文件系统正确性。
执行growpart对磁盘分区进行扩容，再执行e2fsck命令检查系统正确性，执行resize2fs调整文件系统大小。操作完执行lsblk可以看出磁盘及分区大小正常，挂载正常，测试文件也读取正常。完工~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60dd347bc6dc952ff62d7248587bda3d/" rel="bookmark">
			hexo&#43;gitee搭建个人博客，手把手教学包括报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作
1.安装node.js
官网： https://nodejs.org/zh-cn/
一直默认安装就行
2.安装git
阿里淘宝镜像站下载最新的版本，速度较快：https://npm.taobao.org/mirrors/git-for-windows/
任意选版本进行对口的32 或者64 .exe安装就可以
3.检查npm -v node -v 安装完成没有，成功出现以下界面
4.找任意一个盘新建一个文件夹
然后进入这个文件夹，cmd命令跳转到这个窗口（最好是保证管理员身份打开）
5.安装 hexo
输入npm install hexo-cli -g 或者 cnpm install hexo-cli -g 来安装hexo ,出现下图证明安装成功
这里可以通过hexo -v来验证是否成功
6.初始化 hexo 模板
在命令窗口输入 hexo init 出现下图表示成功
初始化完成后，文件夹里面如下图
7.运行hexo
运行 hexo，注意是在 自己创建的文件夹运行。按如下顺序依次输入：
hexo clean # 清空已有hexo网站文件
hexo g(or generate) # 依据网页文本与新的CSS样式生成新网站文件
hexo s(or server) # 启动本地服务器，可以在localhost:4000查看网站修改效果
这时候访问http://localhost:4000/会出现默认页面
8.修改样式
通过快捷键 Ctrl + C 来停止本地服务器，就可以继续对网站内容进行修改
我使用的是git glone 下载 butterfly样式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60dd347bc6dc952ff62d7248587bda3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae0c994d421ed6d04b438b0d67853530/" rel="bookmark">
			C#泛型的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.为什么要使用泛型 1.比如我们又如下三个方法：
/// &lt;summary&gt; /// 打印个int值 /// &lt;/summary&gt; /// &lt;param name="parameter"&gt;&lt;/param&gt; public static void ShowInt(int parameter) { Console.WriteLine("This is {0},parameter={1},type={2}", typeof(CommonMethod).Name, parameter.GetType().Name, parameter); } /// &lt;summary&gt; /// 打印个string值 /// &lt;/summary&gt; /// &lt;param name="parameter"&gt;&lt;/param&gt; public static void ShowString(string parameter) { Console.WriteLine("This is {0},parameter={1},type={2}", typeof(CommonMethod).Name, parameter.GetType().Name, parameter); } /// &lt;summary&gt; /// 打印个DateTime值 /// &lt;/summary&gt; /// &lt;param name="parameter"&gt;&lt;/param&gt; public static void ShowDateTime(DateTime parameter) { Console.WriteLine("This is {0},parameter={1},type={2}", typeof(CommonMethod).Name, parameter.GetType().Name, parameter); } 调用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae0c994d421ed6d04b438b0d67853530/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10c46d431cafa6e48240221bb97a8560/" rel="bookmark">
			mysql5.7忘记root密码如何处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql5.7忘记root密码如何处理 首先关闭mysql服务修改my.ini配置文件mysql服务重启后，登录mysql，不需要密码验证mysql服务关闭，修改配置文件，重新登录mysql，密码登录 首先关闭mysql服务 如果mysql服务在运行，先关闭，如已关闭，请忽略这一步！
打开【任务管理器】，找到mysql服务，右键选择关闭
修改my.ini配置文件 在mysql安装目录下，找到my.ini配置文件，用记事本打开
在[mysqld]的下加上一句：
skip-grant-tables 保存文件，重新打开mysql服务
mysql服务重启后，登录mysql，不需要密码验证 键盘WIN+R键，输入：cmd，打开窗口，cd到mysql安装的bin目录下
use mysql update mysql.user set authentication_string=password('密码') where user='root'; mysql服务关闭，修改配置文件，重新登录mysql，密码登录 至此，密码修改成功，然后关闭mysql服务，再次打开my.ini配置文件，去掉skip-grant-tables ，保存，重新开启mysql服务，次数再登录mysql，就可以用新密码进行登录了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497b74a1f4e35bacb205d7eaedbb38e0/" rel="bookmark">
			Cron表达式详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.介绍 欢迎大家关注我的公众号，可以和大家一起交流，进步，收获知识与能力。
微信公众号：杨同学的编程生活
Id：Code-2048
正文： 当我们第一次使用cron时 ，比较难受，一看这个表达式感觉什么也都不会，今天您看到我的博客，可以让您轻松解决这个问题。 cron 表达式是一个字符串，该字符串由 6 个空格分为 7 个域，每一个域代表一个时间含义。通常定义 “年” 的部分可以省略，实际常用的由 前六部分组成 cron表达式格式：{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)} 通过了解每个位置的允许的值，以及一些案例，足以让你轻松使用cron表达式 一、corn表达式中运行的字段值 秒 0-59 - * / 分 0-59 - * / 时 0-23 - * / 日 1-31 - * / ? L C W 月 1-12 JAN-DEC - * / 星期 1-7 SUN-SAT - * / ? L C # 年（可选） 1970-2099 - * / 二、特殊表示 星期1代表星期日，7代表星期六 要不规定日期，要不规定星期，两者基本上不会同时规定的。 三、每个符号的意义： * 表示所有值，每个字段规定的值都可选。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/497b74a1f4e35bacb205d7eaedbb38e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e733c270aa23cdaf3b918a7b399609b/" rel="bookmark">
			运用ggalluvial包展示微生物优势菌群—冲击图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看了一篇微生物的文章，感觉他的图做的很好看！最终发现，ggalluvial包可以做这种冲击图。
Wei R, Ding Y, Gao F, Zhang L, Wang L, Li H, Wang H. Community succession of the grape epidermis microbes of cabernet sauvignon (Vitis vinifera L.) from different regions in China during fruit development. Int J Food Microbiol. 2022 Feb 2;362:109475. doi: 10.1016/j.ijfoodmicro.2021.109475. Epub 2021 Nov 13. PMID: 34798479. #安装包 install.packages("ggalluvial") install.packages("tastypie") library(ggalluvial) library(ggplot2) library(ggthemes) library(tidyverse) library(ggsci) library(cowplot) library(tastypie) #读入数据 df=read.csv('MCMPphylum.csv',header = T) head(df) #设置色盘 mycol&lt;-c(312,77,22,137,428) mycol&lt;-colors()[rep(mycol,5)] #在colors()里挑选5个颜色 #绘图 ggplot(df, aes(x = Group,y=BD,fill = OTU, #冲击图必备元素：stratum、alluvium stratum = OTU, alluvium = OTU))+ geom_col(width = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e733c270aa23cdaf3b918a7b399609b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65fc198d30dd815c5e56236703c9fa48/" rel="bookmark">
			Twaver-HTML5基础学习(10)嵌入Table
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入Table 工具JS const twaver = require('twaver'); // 设置每个图元name的颜色 twaver.Styles.setStyle('label.color', '#ec6c00'); // 设置每个图元name2的颜色 twaver.Styles.setStyle('label2.color', '#57ab9a'); twaver.Styles.setStyle('select.color', '#ef8200'); //TWaver内部预定义六中告警级别 twaver.AlarmSeverity.CRITICAL = twaver.AlarmSeverity.add(500, 'Critical', 'C', "#FF0000"); twaver.AlarmSeverity.MAJOR = twaver.AlarmSeverity.add(400, 'Major', 'M', "#FFA000"); twaver.AlarmSeverity.MINOR = twaver.AlarmSeverity.add(300, 'Minor', 'm', "#FFFF00"); twaver.AlarmSeverity.WARNING = twaver.AlarmSeverity.add(200, 'Warning', 'W', "#00FFFF"); twaver.AlarmSeverity.INDETERMINATE = twaver.AlarmSeverity.add(100, 'Indeterminate', 'N', "#C800FF"); twaver.AlarmSeverity.CLEARED = twaver.AlarmSeverity.add(0, 'Cleared', 'R', "#00FF00"); const { CRITICAL, MAJOR, WARNING, MINOR, INDETERMINATE, CLEARED } = twaver.AlarmSeverity export const ALARM1 = CLEARED export const ALARM2 = INDETERMINATE export const ALARM3 = MINOR export const ALARM4 = MAJOR export const ALARM5 = CRITICAL /** * 创建一个dataBox容器 * 容器中可以add图元 */ export const returnElementBoxFun = () =&gt; new twaver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65fc198d30dd815c5e56236703c9fa48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e727284ebe5b2dfa948a821ab71abd25/" rel="bookmark">
			入门级mybatis-plus-generator代码自动生成器，提高开发效率。值得收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们使用代码生成器的目的主要是提供开发效率，减少重复性的工作。在使用Springboot开发过程中，我们使用代码生成器把大概的模板生成出来，再根据自己的业务特征进行改动。这样就可以提高效率
引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--糊涂工具包--&gt; &lt;!-- https://mvnrepository.com/artifact/cn.hutool/hutool-core --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-core&lt;/artifactId&gt; &lt;version&gt;5.7.20&lt;/version&gt; &lt;/dependency&gt; MyBatisPlus提高高度封装好的代码生成器模块，只需要简单的几行代码就能实现。同时也可以根据自己的需求灵活的通过模板话的方式生成代码。下面我们分别通过这两种方式来了解一些。
简单的代码生成 package com.didiplus; import com.baomidou.mybatisplus.generator.FastAutoGenerator; import com.baomidou.mybatisplus.generator.config.OutputFile; import org.junit.jupiter.api.Test; import java.util.Collections; /** * Author: didiplus * Email: 972479352@qq.com * CreateTime: 2022/5/6 * Desc:快速生成 */ public class FastAutoGeneratorTest { @Test public void fastAutoGeneratorTest(){ String url="jdbc:mysql://127.0.0.1:3306/didiadmin?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8&amp;nullCatalogMeansCurrent=true"; FastAutoGenerator.create(url,"root","123456") .globalConfig(builder -&gt; { builder.author("didiplus") // 设置作者 .enableSwagger() //开启 swagger 模式 .outputDir("D://autocode");// 指定输出目录 }) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e727284ebe5b2dfa948a821ab71abd25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b030a7837fbba4745eee4a6a9713ba/" rel="bookmark">
			windows中的SC命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SC 是用来与服务控制管理器和服务进行通信的命令行程序。
C:\Users\john&gt;sc -help 错误: 未知命令 描述: SC 是用于与服务控制管理器和服务进行通信的命令行程序。 用法: sc &lt;server&gt; [command] [service name] &lt;option1&gt; &lt;option2&gt;... 选项 &lt;server&gt; 的格式为 "\\ServerName" 键入 "sc [command]" 可以获得有关命令的进一步帮助 命令: query-----------查询服务的状态， 或枚举服务类型的状态。 queryex---------查询服务的扩展状态， 或枚举服务类型的状态。 start-----------启动服务。 pause-----------向服务发送 PAUSE 控制请求。 interrogate-----向服务发送 INTERROGATE 控制请求。 continue--------向服务发送 CONTINUE 控制请求。 stop------------向服务发送 STOP 请求。 config----------更改服务的配置(永久)。 description-----更改服务的描述。 failure---------更改服务失败时执行的操作。 failureflag-----更改服务的失败操作标志。 sidtype---------更改服务的服务 SID 类型。 privs-----------更改服务的所需权限。 qc--------------查询服务的配置信息。 qdescription----查询服务的描述。 qfailure--------查询失败时服务执行的操作。 qfailureflag----查询服务的失败操作标志。 qsidtype--------查询服务的服务 SID 类型。 qprivs----------查询服务的所需权限。 qtriggerinfo----查询服务的触发器参数。 qpreferrednode--查询首选的服务 NUMA 节点。 delete----------(从注册表)删除服务。 create----------创建服务(将其添加到注册表)。 control---------向服务发送控制。 sdshow----------显示服务的安全描述符。 sdset-----------设置服务的安全描述符。 showsid---------显示相应于假定名称的 SID 字符串。 triggerinfo-----配置服务的触发器参数。 preferrednode---设置首选的服务 NUMA 节点。 GetDisplayName--获取服务的 DisplayName GetKeyName------获取服务的 ServiceKeyName。 EnumDepend------枚举服务的依存关系。 下列命令不要求服务名称: sc &lt;server&gt; &lt;command&gt; &lt;option&gt; boot------------(ok | bad) 指示是否将上一次启动保存为 最近一次已知的正确启动配置 Lock------------锁定服务数据库 QueryLock-------查询 SCManager 数据库的 LockStatus 示例: sc start MyService 是否想参阅 QUERY 和 QUERYEX 命令的帮助?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1b030a7837fbba4745eee4a6a9713ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20dae4240f8a2e9ba85c4fd1f398e078/" rel="bookmark">
			设计模式：建造者模式/生成器模式案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式：建造者模式/生成器模式案例 模式介绍和动机模式结构的角色1. 抽象建造者(Builder)2. 具体建造者(ConcreteBuilder)3. 产品(Product)4. 指挥者(Director)5. 客户类(Client) 建造者模式案例案例背景案例分析实现步骤代码实现(按编写顺序)文件结构或类图1. 产品类2. 抽象建造者类3. 具体建造者类(3个)4. 指挥者类5. 客户类6. 配置文件(config.xml)7. 读取配置文件，创对象(XMLUtil.java)输出结果 模式适用环境 模式介绍和动机 建造者模式也称生成器模式，它是最复杂的创建型模式，将一个复杂对象的构建(建造者-&gt;造产品各个组成部分) 与 它的表示(指挥者-&gt;组成顺序)分离，使得同样的构造过程可以创建不同的表示建造者模式关注该复杂对象是如何一步一步创建而成的，而对于客户端而言，无需知道复杂对象的内部组成部分与装配方式，只需要知道建造者的类型即可举个例子：
3.1 建造者模式可以用于描述炸鸡店如何创建套餐：套餐是一个复杂对象，它一般包含主食(如汉堡，鸡肉卷)和饮料(如果汁，可乐)等组成部分，不同套餐有不同的组成部分，而炸鸡店的服务员会根据顾客的要求，一步一步装配这些组成部分，构造一份完美的套餐，然后返回给顾客。
3.2 炸鸡店生产汉堡，鸡肉卷，果汁，可乐等，经过服务员的装配，形成多样的套餐，返回给顾客 模式结构的角色 1. 抽象建造者(Builder) 1.1 作用： 抽象建造者为 创建产品Product对象的各个部件指定抽象接口
1.2 内容：该接口 / 抽象类中一般声明两类方法：
①、buildPartX()：用于创建复杂对象的各个部件
②、getResult()：用于返回复杂对象
1.3 例子：该类中包含建造主食和饮料的方法 以及返回套餐的方法
/** * @author 王胖子 * @version 1.0 */ public abstract class MealBuilder { protected Meal meal = new Meal(); //建造产品组成部分 public abstract void buildFood(); public abstract void buildDrink(); //返回建造的产品 public Meal getMeal() { return meal; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20dae4240f8a2e9ba85c4fd1f398e078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a524eb838e7cf1e3da090102a611627/" rel="bookmark">
			flink 教程 Window
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Window KeyedStream → WindowedStream
可以在已分区的 KeyedStreams 上定义 Windows。Windows 根据某些特征（例如，最近 5 秒内到达的数据）对每个键中的数据进行分组。
import org.apache.flink.api.common.functions.FlatMapFunction; import org.apache.flink.api.java.tuple.Tuple2; import org.apache.flink.streaming.api.datastream.DataStream; import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment; import org.apache.flink.streaming.api.windowing.time.Time; import org.apache.flink.util.Collector; public class WindowExample { public static void main(String[] args) throws Exception { StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; dataStream = env .socketTextStream("localhost", 9999) .flatMap(new Splitter()) .keyBy(value -&gt; value.f0) .window(TumblingEventTimeWindows.of(Time.seconds(5))) .sum(1); dataStream.print(); env.execute("WindowExample"); } public static class Splitter implements FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt; { @Override public void flatMap(String sentence, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out) throws Exception { for (String word: sentence.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a524eb838e7cf1e3da090102a611627/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9266ee768ecf4ac76b2cccce35bdf23b/" rel="bookmark">
			JAVA中的多线程之定时器&amp;&amp;一些面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时器：
定时器是一种控制任务延时调用，或者周期调用的技术
作用：闹钟、定时邮件发送。
定时器的实现方式一：Timer Timer定时器的特点和存在的问题：
1、Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入
2、可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行 import java.util.Date; import java.util.Timer; import java.util.TimerTask; public class 多线程_6定时器 { public static void main(String[] args) { //创建Timer定时器 Timer timer=new Timer(); //调用方法，处理定时任务 timer.schedule(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()+"执行一次"+new Date()); } },3000,2000);//3秒后执行，隔2秒执行一次 // timer.schedule(new TimerTask() { // @Override // public void run() { // System.out.println(Thread.currentThread().getName()+"a执行"); // //如果其中一个任务处理时间过长，会导致后续任务无法执行,后续任务需要等这个任务完成才能执行 try { Thread.sleep(5000); } catch (Exception e) { e.printStackTrace(); } // //如果其中一个定时器出现bug崩掉，会导致所有定时器崩掉 // // System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9266ee768ecf4ac76b2cccce35bdf23b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3915d5c023bdec228a199faf845ad83e/" rel="bookmark">
			R语言：商业数据分析实例（2）【k-means, t-test】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用于初学者。内容包括k-mean和t-test的使用。
使用到的数据：链接：https://pan.baidu.com/s/1yhzQSdquizLayXamM0wygg 提取码：3b7i
前言：k-means实现 k-means算法，是一种最广泛使用的聚类算法。k-means以k作为参数，把数据分为k个组，通过迭代计算过程，将各个分组内的所有数据样本的均值作为该类的中心点，使得组内数据具有较高的相似度，而组间的相似度最低。（引用自：张丹(Conan)）
k-means工作原理：
初始化数据，选择k个对象作为中心点。遍历整个数据集，计算每个点与每个中心点的距离，将它分配给距离中心最近的组。重新计算每个组的平均值，作为新的聚类中心。上面2-3步，过程不断重复，直到函数收敛，不再新的分组情况出现。 案例简介 用到的数据共4张表（cvs格式），为2003-2019年美国纽约市房地产交易数据。
NYC_HISTORICAL包含：交易ID，社区ID，地址，建筑类型，时间，价格，面积等；
BOROUGH包含：BOROUGH_ID和BOROUG名称；
BUILDING_CLASS包含：建筑ID和建筑类型等；
NEIGHBORHOOD 包含：街道ID和BOROUGH_ID等；
本案例需要根据ID整合数据，从中提取目标信息。
本章目标 任务1：使用以下KPI执行k-means聚类。描述所选社区所属的聚类。
自2009年以来，住宅物业的价格中值自2009年以来，住宅物业的销售数量自2009年以来，住宅物业的价格标准差自2009年以来，住宅地产的每平方米价格 任务2：选择另一个社区（如 ID：31），并检验以下假设：从2009年开始，社区（ ID：29）的平均住宅物业价格大于所选的另外一个社区
开始：载入所需的包，并设置工作地址
library(lubridate) #year() library(tidyverse) #csv2 library(factoextra) library(cluster) setwd("C:/Users/10098/Desktop/AD571/571，A34") 读取所有csv文件。第四个NYC_HISTORICAL较大（150M），且用分号隔开，故用csv2读取
BOROUGH &lt;- read.csv("BOROUGH.csv", header=TRUE) BUILDING_CLASS &lt;- read.csv("BUILDING_CLASS.csv", header=TRUE) NEIGHBORHOOD &lt;- read.csv("NEIGHBORHOOD.csv", header=TRUE) NYC_HISTORICAL &lt;- read_csv2("NYC_HISTORICAL.csv") 将各表数据整合
NYC_HISTORICAL &lt;- mutate(NYC_HISTORICAL, Y = year(SALE_DATE)) NEIGHBORHOOD = left_join(NEIGHBORHOOD,BOROUGH, by = 'BOROUGH_ID') df &lt;- NYC_HISTORICAL %&gt;% left_join(BUILDING_CLASS, by = c('BUILDING_CLASS_FINAL_ROLL'='BUILDING_CODE_ID')) %&gt;% left_join(NEIGHBORHOOD, by = 'NEIGHBORHOOD_ID') %&gt;% select(NEIGHBORHOOD_ID, SALE_DATE,SALE_PRICE,GROSS_SQUARE_FEET,TYPE,SALE_ID,Y) %&gt;% filter(TYPE == 'RESIDENTIAL') %&gt;% group_by(NEIGHBORHOOD_ID) %&gt;% subset(Y&gt;=2009) %&gt;% subset(GROSS_SQUARE_FEET !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3915d5c023bdec228a199faf845ad83e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e587599022bfc12b530328b2325d845/" rel="bookmark">
			Argo workflow 入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Argo workflow 作为云原生的workflow 引擎被大量应用于CI/CD ， 基础设施自动化支持
一般来说按照argo workflow 提供的官方文档可以完成 入门体验，argo workflow依赖的部分镜像，有某些不可描述的原因无法正常访问到，本文记录了笔者在安装和入门过程中踩的坑，以便遇到同样问题的朋友可以快速解决问题。
1 前置条件
要安装argo workflow 前提条件是你要有一套k8s环境。可以是完整的k8s， 如果只本地练习，可以考虑安装一个minikube。
2 安装步骤
2.1 创建namespace
k8s中为了便于资源和服务管理，可以用namespace隔离资源和服务。我们把argo workflow相关的服务都部署到argo这个命名空间，方便后续的操作，查找和维护
kubectl create ns argo
2.2 创建argo workflow基础 服务
kubectl apply -n argo -f https://raw.githubusercontent.com/argoproj/argo-workflows/master/manifests/quick-start-postgres.yaml
下载yaml文件的时候可能会出现超时，我建议网络不好的墙内用户先把这个yaml文件下载下来保存到本地 命名为 quick-start-postgres.yaml
然后通过本地配置文件创建基础服务
kubectl apply -n argo -f quick-start-postgres.yaml
该命令实际上部署了三个主要的argo workflow的基础服务，
argo-server （argo workflow的主服务）
argo-controller （argo workflow接入的controller）
postgresql (argo workflow的元数据存储）
minio （argo workflow的artifactory）
墙内的用户启动会很慢，也可能失败。可以用以下命令查看argo workflow的基础服务状态。
[root@localhost ~]# kubectl get pods -n argo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e587599022bfc12b530328b2325d845/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac98e201a1690d4fd3a135a17cb08e7/" rel="bookmark">
			TypeScript面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeScript面向对象 1 面向对象原则2 TypeScript类2.1 类的定义2.2 创建实例对象 3 类的继承4 static关键字5 抽象类和抽象方法6 类属性权限修饰符6.1 public（公有的）6.2 protected（受保护的）6.3 private（受保护的）6.4 readonly（只读） 7 存取器 1 面向对象原则 单一原则：一个类只负责一个职责。里氏替换原则：子类可以在任何地方替换它的父类。依赖倒置原则：代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。接口隔离原则：提供尽可能小的单独接口，而不要提供大的总接口。暴露行为让后面的实现类知道的越少越好。迪米特法则：尽量降低类与类之间的耦合。开闭原则：面向扩展开放，面向修改关闭组合/聚合复用原则：尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。 2 TypeScript类 TypeScript 是面向对象的 JavaScript。类描述了所创建的对象共同的属性和方法。TypeScript 支持面向对象的所有特性。
2.1 类的定义 TypeScript使用class关键字定义类。
class 类名 { // 具体代码 } 类可以包含以下几个模块（类的数据成员）：
字段（属性）：字段是类里面声明的变量。字段表示对象的有关数据。构造函数：类实例化时调用，可以为类的对象分配内存。方法：方法为对象要执行的操作。 那么一个类的结构大致如下：
class 类名 { // 字段 属性名: 类型; // 构造函数 constructor(参数: 类型) { this.属性名 = 参数; } // 方法 方法名() { // 具体方法 } } 示例代码：创建一个Car类
class Car { // 字段 engine: string; // 构造函数 constructor(engine: string) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac98e201a1690d4fd3a135a17cb08e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d031732193475f545326148f3da594b7/" rel="bookmark">
			pom.xml 配置时出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Powered by:NEFU AB-IN
文章目录 pom.xml 配置时出错错误1错误方法1方法2 错误2错误方法 pom.xml 配置时出错 以下恢复完错误后，一定要 update maven
错误1 错误 This failure was cached in the local repository and resolution is not reattempted until the update interval of nexus-aliyun has elapsed or updates are forced.
方法1 一般是因为上次下载的库失败导致的（可能网不好）
去自己maven库的文件夹下，打开cmd，运行这样一条语句
for /r %i in (*.lastUpdated) do del %i 目的是，循环递归删除没下好的包
方法2 如果更新完maven还没好，可能说明库中有些版本不对，建议把库的所有包都删了，重新保存pom.xml，重新下包
错误2 错误 Could not initialize class org.apache.maven.plugin.war.util.WebappStructureSerializer
方法 POM中包含有maven-war-plugin插件，插件版本太低
在插件群的标签中，加入插件即可
&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/plugin&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fddcbde410d5bff911875ca6a693b0/" rel="bookmark">
			ConfigurationClassPostProcessor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文档翻译
SourceClass ConfigurationClass
作为BeanDefinitionRegistryPostProcessor的扩展回调
processConfigBeanDefinitions(BeanDefinitionRegistry registry)片段一 ：过滤出是配置类的beanName
processConfigBeanDefinitions(BeanDefinitionRegistry registry)片段二：使用ConfigurationClassParser解析候选的配置类
ConfigurationClassParser文档翻译
ConfigurationClassParser#doProcessConfigurationClass：文档翻译
ConfigurationClassParser#doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 片段一：优先处理内配置类
ConfigurationClassParser#doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 片段二：解析@ComponentScan并处理扫描出的潜在的配置类（包含Full模式和Lite模式的配置类）
ConfigurationClassParser#doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 片段三：处理@Import
ConfigurationClassParser#doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 片段四：处理@Bean方法
ConfigurationClassParser#doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) 片段五：处理接口上的@Bean
processConfigBeanDefinitions(BeanDefinitionRegistry registry)片段三：注册之前收集到ConfigurationClass中的@Bean,ImportBeanDefinitionRegistrar类型，@Import相关的BeanDefinition
processConfigBeanDefinitions(BeanDefinitionRegistry registry)片段四：解析可能被遗漏的潜在的配置类
作为BeanFactoryPostProcessor的扩展回调
文档翻译 用于对@Configuration类进行引导处理。此后处理器按优先级排序，因为在任何其他BeanFactoryPostProcessor执行之前， @Configuration类中声明的任何Bean方法都必须注册其对应的Bean定义，这一点很重要。
SourceClass 简单的包装器，允许以统一的方式处理带注释的源类，而不管它们是如何加载的。
ConfigurationClass 表示用户定义的@Configuration类。
以“扁平化”方式包含一组Bean方法，包括在类的祖先中定义的所有此类方法
作为BeanDefinitionRegistryPostProcessor的扩展回调 @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { ... processConfigBeanDefinitions(registry); } processConfigBeanDefinitions(BeanDefinitionRegistry registry) 处理配置类型的bean定义。分段解析如下：
processConfigBeanDefinitions(BeanDefinitionRegistry registry)片段一 ：过滤出是配置类的beanName List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;(); String[] candidateNames = registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69fddcbde410d5bff911875ca6a693b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e295d518034c827850173e7dc5769e60/" rel="bookmark">
			#SATA# 常用硬盘一览 之《协议、总线、接口》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现实生活中，硬盘的种类可谓是多种多样，有时候搞得头晕。今天，我们总结一下。并不会涉及很深的知识点，只是比较初浅的认识。
硬盘想要正常工作，离不开三个条件：数据协议做沟通、传输总线做媒介、物理接口来接入。
一 概览 1 协议 目前硬盘常用的协议有：IDE（淘汰）、AHCI、NVMe、SCSI。其中，前三者主要是民用场合，最后一种是服务器领域。
2 总线 目前硬盘常用的总线有：SATA、PCIe、SAS
3 接口 目前，常用的硬盘接口有如下接口：SATA、mSATA、SATA Express、M.2 （具体分为：B-key &amp; M-key）、PCIe、U.2、SAS接口。
二 总线速率 以下说明速率，均是理想运行速率。
2.1 SATA总线+AHCI 协议+多种接口 (1) SATA总线+AHCI 协议+SATA接口
SATA 总线分为 SATA1.0、SATA2.0、SATA3.0.三代总线相应的传输速率如下表格所示：
代表产品：3.5寸机械硬盘、2.5寸机械硬盘、2.5寸固态硬盘
(2) SATA总线+AHCI 协议+mSATA接口
mSATA固态硬盘
mSATA 接口硬盘的存在，主要目的是为SATA 接口的固态硬盘，减小体积。但是该接口也根本上没有提升SATA3.0 的速率。很快被遗弃，被M.2接口顶替。
(3) SATA总线+AHCI 协议+M.2 接口
2.2 PCIe总线+AHCI/NVMe 协议+多种接口 （1）PCIe总线+AHCI/NVMe 协议+SATA Express 接口（实质为 PCIex2）
SATA Express 接口相对于SATA3.0接口翻倍。但是提升的速率还是有限。而且接口体积过于庞大。所以，该接口出现仅仅两年，就被淘汰了。
（2）PCIe总线+AHCI/NVMe 协议+M.2 接口
M.2接口 （a）PCIe总线+AHCI 协议+M.2 接口
此种方式和普通SATA3.0 没有区别，速率同样限制在500+MB/s。 好处就是：体积比较小。速率由PCIe 的版本和link width 决定。
（b）PCIe总线+NVMe 协议+M.2 接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e295d518034c827850173e7dc5769e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414db0d738769f18faf4c39c11c2151c/" rel="bookmark">
			数字图像处理---直方图均衡化与规定化（MATLAB实现含源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直方图均衡化与规定化（MATLAB实现） 【实验目的】 掌握对图像进行操作，实现图像的直方图均衡算法。
1、掌握求灰度图像归一化直方图方法
2、掌握灰度图像的直方图均衡算法
3、掌握对彩色图像进行直方图均衡的算法
4、掌握直方图匹配算法
5、掌握MATLAB的基本操作，计算直方图，并显示
【实验原理】 直方图均衡化(Histogram Equalization)：
把一个已知灰度概率密度分布的图像经过一种变换，使之演变为一幅具有均匀灰度概率密度分布的新图像。如果一幅图像占有全部可能的灰度级，并且均匀分布，则该图像具有高对比度和多变的灰色色调，图像细节丰富，质量更高。
直方图匹配：
直方图匹配，又称直方图规定化，即变换原图的直方图为规定的某种形式的直方图，从而使两幅图像具有类似的色调和反差。直方图匹配属于非线性点运算。
直方图匹配的原理：对两个直方图都做均衡化，变成相同的归一化的均匀直方图，以此均匀直方图为媒介，再对参考图像做均衡化的逆运算。
【实验内容】 1、 计算灰度图像的归一化直方图，利用MATLAB对图像像素进行操作，计算归一化直方图，设计算法实现均衡化处理，并将均衡化前后的直方图以及原始图像和直方图均衡化后的图像在窗口中以两行两列图形的方式显示出来。
代码如下：
clc; g=imread('nj.jpg'); I=rgb2gray(g); I=uint8(I); I1=zeros(1,256); I2=zeros(1,256); new_I1=zeros(1,256); new_I2=zeros(1,256); [h,w]=size(I); new_I=zeros(h,w); %计算原图各灰度级的概率密度 for i=1:h for j=1:w I1(1,I(i,j))=I1(1,I(i,j))+1; end end I2=I1/sum(I1); subplot(221),imshow(I); title('原始图像'); subplot(222),plot(I2); xlabel('灰度级'); ylabel('各灰度级概率分布'); title('原始图像的直方图'); %计算原图的累计直方图 for i=2:256 I2(1,i)=I2(1,i)+I2(1,i-1); end for i=1:256 t(1,i)=floor(255*I2(1,i)+0.5); end for i=1:256 new_I1(1,t(1,i)+1)=new_I1(1,t(1,i)+1)+I1(1,i); end new_I2=new_I1/sum(new_I1); for x=1:h for y=1:w new_I(x,y)=t(1,I(x,y)); end end subplot(223),imshow(new_I,[]); title('直方图均衡化后的图像'); subplot(224),plot(new_I2); xlabel('灰度级'); ylabel('各灰度级概率分布'); 2、 用MATLAB自带函数histeq( )进行灰度图像直方图均衡化，将原始图像和均衡化后的图像以及二者直方图用两行两列图显示出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/414db0d738769f18faf4c39c11c2151c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a62527ab2a9cabbac1800af66cc6509/" rel="bookmark">
			VUE学习笔记：插槽详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚开始看Vue官方文档的时候对插槽不是很理解，其实通俗点来讲，插槽就是在自定义组件中预留一个位置，这个位置的内容可以由使用组件的人来定义，具有高度的灵活性。
1、使用场景
先来看看插槽的使用场景，否则可能连学习的欲望都没有了。插槽还是很重要的，即使不去定义，也要学会使用。
下面这个图中使用了Vant中的NavBar组件，该组件用于手机端标题展示，默认的组件展示的只有标题和返回按钮，但是在有些情况下，我们可能需要在标题栏中放一个增加或查询按钮，这个时候就需要利用插槽来让用户自己定义区域中的内容。该组件的封装者将该标题组件划分成三个区域，分别是“左、中、右”，每个位置都放了一个插槽，并且给出默认内容。这样一来，用户除了可以采用默认的方式使用该组件，也可以自己定义插槽区域的内容，极大的提高了组件的灵活性。
2、插槽的基本用法
定义组件时，在需要由用户自定义的区域使用&lt;slot&gt;&lt;/slot&gt;占位，使用组件时，在组件的标签之间通过&lt;template&gt;&lt;/template&gt;定义要往插槽中填充的内容。示例代码：
//定义一个组件Box &lt;template&gt; &lt;div&gt; &lt;div&gt;这是一个定义了插槽的组件&lt;/div&gt; &lt;slot&gt;&lt;/slot&gt; //通过slot定义了一个插槽 &lt;div&gt;组件其它内容&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; //使用上面的组件 &lt;Box&gt; &lt;template&gt; &lt;div&gt;插槽中展示的内容&lt;/div&gt; &lt;/template&gt; &lt;/Box&gt; ​
如果在定义组件时没有使用&lt;slot&gt;&lt;/slot&gt;点位，即使在使用组件时在组件标签之间定义了内容，也会被忽略。
3、后备内容
此处所说的后备内容是官方文档里面的叫法，实际上就是指插槽的默认值。在定义组件时，可以在&lt;slot&gt;&lt;slot&gt;之间给出插槽的默认内容，也就是说当使用插槽时如果没有在组件标签内定义插槽的内容，则默认内容生效，否则默认内容不生效。例如：
//定义一个组件Box &lt;template&gt; &lt;div&gt; &lt;div&gt;这是一个定义了插槽的组件&lt;/div&gt; &lt;slot&gt; &lt;div&gt;这是插槽的默认内容&lt;/div&gt; &lt;/slot&gt; //通过slot定义了一个插槽,并在插槽中给出了默认值 &lt;div&gt;组件其它内容&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 使用方式1：
&lt;Box&gt;
&lt;template&gt;
&lt;div&gt;插槽中展示的内容&lt;/div&gt;
&lt;/template&gt;
&lt;/Box&gt;
此时页面呈现的内容为：
使用方式2：
&lt;Box&gt;&lt;/Box&gt;
此时页面呈现的内容为：
4、具名插槽
每个插槽都有一个名字，当一个组件中只有一个插槽时，我们可以不用指定插槽的名称，此时插槽的名称为：default。如果一个组件中有多个插槽，我们必须为每个插槽制定名称，否则无法向插槽填充对应的内容。
在组件定义时为solt制定name标签，使用组件时，通过v-slot:‘组件名称’，制定插入到哪个插槽。v-slot必须使用在template标签，v-slot的简写形式为#。示例：
5、作用域插槽
定义插槽时可向&lt;slot&gt;&lt;/slot&gt;中添加属性，使用组件时可以接收到该属性值，示例：
//定义一个组件Box &lt;template&gt; &lt;div&gt; &lt;slot name='left' msg='消息内容'&gt; //为slot标签添加属性，属性名称可以自定义 &lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; //使用组件 &lt;Box&gt; &lt;template #left='obj'&gt; &lt;div&gt;插槽内容&lt;/div&gt; &lt;/template&gt; &lt;/Box&gt; 上面代码中，定义组件时为slot增加了name和msg属性，name为slot的名称，msg为自定义属性。使用组件时template标签中有一个指令：#left='obj'，其中#left是：v-slot:left的缩写，obj中包含了msg属性值，使用时可以通过obj.msg获取传过来的消息内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb187401125e8b8a70baead42f5987c5/" rel="bookmark">
			数据结构 第四章 广义表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
4.5 广义表
4.5.1广义表的定义
4.5.2 广义表的存储结构
1.头尾链表的存储结构
2.扩展线性链表的存储结构
4.5 广义表 4.5.1广义表的定义 广义表是线性表的推广，也称列表。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。
广义表一般记作，其中可以是单个元素，也可以是一个广义表。广义表的定义是一个递归的过程，相当于单个元素可以是广义表，这个广义表内的元素又可以有广义表......广义表中的单个元素我们成为原子，广义表中的广义表我们成为子表。习惯上用大写字母表示广义表的名称，用小写字母表示原子。
下面我们列举一些广义表的例子。
1）A=( )，A是一个空表，其长度为0。
2）B=(e)，B只有一个原子e，其长度为1。
3）C=(a,(b,c,d))，C的长度为2，两个元素分别为原子a和子表(b,c,d)。
4）D=(A,B,C)，D的长度为3，3个元素都是广义表。显然，将子表的元素带入后，有D=(( ),(e),(a,(b,c,d)))。
5）E=(a,(E))，这是一个递归的表，其长度为2。E相当于一个无限的广义表E=(a,(a,(a,...)))。
从上述定义和例子我们可以得出广义表的如下3个结论。
1）广义表的元素可以是子表，子表的元素还可以是子表.......由此，广义表是一个多层次的结构，可以用图像形象地表示。如下图表示的是广义表D，图中以圆圈表示广义表，以方块表示原子。
2）广义表可以为其他广义表所共享。例如在上述例子中，广义表A、B和C为D的子表，则在D中可以不必列出子表的值，而是通过子表的名称来引用。
3）广义表可以是一个递归的表，即广义表也可以是其本身的一个子表。
由于广义表的结构比较复杂，其各种运算的实现也不如线性表简单，其中，最重要的两个运算如下：
1.取表头GetHead(LS)：取出的表头为非空表的第一个元素，它可以是一个单原子，也可以是一个子表。
2.取表尾GetTail(LS)：取出的表尾为除去表头之外，由其余元素构成的表。即表尾一定是一个广义表。
例如：
GetHead(B)=e, GetTail(B)=( ), GetHead(D)=A, GetTail(D)=(B,C),
由于(B,C)为非空广义表，则可继续分解得到：
GetHead(B,C)=B, GetTail(B,C)=(C)，
值得注意的是，广义表( )和(( ))不同，前者为空表，长度为0；后者长度为1，可分解得到其表头、表尾均为空表( )。
4.5.2 广义表的存储结构 由于广义表中的数据可以有不同的结构（或是原子，或是列表），因此难以用顺序存储结构表示，通常采用链式存储结构。常用的链式存储结构有两种，头尾链表的存储结构和扩展线性链表的存储结构。
1.头尾链表的存储结构 由于广义表中的数据元素可能为原子或广义表，由此需要两种结构的结点：一种是表结点，用以表示广义表；一种是原子结点，用以表示原子。从上面得知：若广义表不为空，则可分解成表头和表尾，因此，一对确定的表头和表尾可唯一确定广义表。一个表结点可由3个域组成：标志域、指示表头的指针域和指示表尾的指针域。而原子结点只需两个域：标志域和值域。如下图所示，其中tag是标志域，值为1时表明结点是子表，值为0时表明结点是原子。
下面我们将设计表结构的代码 【代码分析】
上面我们说到原子结点和表结点都需要一个标志域用来判断，因此我们在这里可以用到c语言中的枚举类型。然后对于广义表的两种元素：原子和子表，因为是头尾链表的存储结构，它们在表结构中是共同占有一段内存，由此，在设计其结点代码时我们可以用到c语言中的共用体结构。相当于我们每定义一个表结构，这个表里含有一个原子和子表，而子表里又含有一个原子和子表。前面几节我们已经熟悉了“结点结构”的大致内容，下面我们给出其具体代码。
【代码实现】
typedef enum{ATOM,LIST} ElemTag; //ATOM=0:原子；LIST=1:子表 typedef struct GLNode { ElemTag tag; union { AtomType atom; //atom是原子结点的值域 struct { struct GLNode *hp; //指向表头的指针 struct GLNode *tp; //指向表尾的指针 }ptr; //ptr是表结点的指针域 }； } *GList; 由于比较难以理解，下面我们用上述用到的广义表图形表示来进一步说明广义表的头尾链表的存储结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb187401125e8b8a70baead42f5987c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e93fd7b510e75f9acbecf2fb36108b/" rel="bookmark">
			【DLT学习笔记2】-- 什么是DLT？(Diagnostic Log and Trace)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DLTGENIVI项目下的log软件工程
DLT包括：DLT daemon DTL viewer两个子工程。
DLT daemon运行在ECU上，DTLviewer运行在调试PC上。
github地址：dlt-viewer
一、DLT使用场景 1.1 DLT的通用场景 应用或SW-C产生日志消息日志消息发送到DLT模块DLT模块将日志消息发送到总线外部DLT客户端记录日志消息 1.2 VFB追踪(tracing of VFB) RTE调用由DLT提供的宏，该宏可以调用DLT应用接口产生追踪消息（trace message）DLT模块发送跟踪消息到DLT通讯模块（黄色模块）DLT通讯模块转发跟踪消息到网络外部客户端接收并存储跟踪消息 1.3 DLT运行配置 外部dlt客户端发送日志和跟踪等级变更到dlt模块dlt模块根据收到的变更消息改变自己的过滤器设置配置dlt模块通知应用新的日志等级 1.4 非冗余模式(non-verbose mode) 为了减少总线上的运输量，我们可以避免发送通讯总线上的变量元数据。相反，一个外部FIBEX文件保存如何解释有效负载的信息。外部Dlt客户机使用接收到的参数值合并和存储这些元数据。
dlt模块以非冗余模式来传送dlt消息dlt模块过滤和产生dlt消息dlt模块发送dlt消息到通讯总线外部dlt客户端获取外部FIBEX文件里的元信息外部dlt客户存储合并的消息 二、DLT协议介绍 DLT消息包含三个部分：标准头、扩展头、有效载荷。如下图
2.1 标准头 标准头有16个字节大小，分为6个部分。它们之间的名称和顺序如下图所示
Byte0：Header Type，这里用来配置DLT的可选项，比如带不带ECU ID、Session ID、时间戳等，DLT协议版本号、大端优先。具体如下图所示：
1为采用，0为不采用
如果使用冗余模式，则UEH位必须为1Byte1：Message Counter,从0开始最大255，可以在一定程度上识别丢失的消息。Byte2-3：Length，这个字段指示整个DLT消息的长度，包括标准头、扩展头、有效载荷Byte4-7：ECU ID，可选的ECU ID用于识别哪个ECU发送了Dlt消息。因此，强烈建议ECU ID在车辆内是唯一的。Byte8-11：Session ID，可选的Session ID用于标识ECU中的日志或跟踪消息的来源。Byte12-15：Timestamp，对产生的DLT消息添加时间信息。 2.2 扩展头 扩展头字段是紧跟在标准头后面的，如果标准头中‘UEH’位位1，则表示该DLT消息有扩展头。扩展图的结构如下图所示：
-Byte0:Message Info,该字节的字段非常重要，设计到dlt消息的类型分类，用来区分是日志消息、跟踪消息、网络消息、控制消息。字段结构如下图所示：
VERB为1时表示有效载荷必须按冗余模式传输
MSTP表示DLT的类型，一共分四种：日志消息、跟踪消息、网络消息、控制消息
MTIN表示不同类型DLT消息各自的下级分类
一图胜千言
Byte1：Number of Arguments:参数数量表示一条Dlt消息的有效负载段中连续参数的数量。在冗余模式有效，非冗余模式此字段因为0x00Byte2-5：Application ID，应用程序ID是应用程序的缩写，它生成Dlt消息。Byte6-9：Context ID，Context ID是用户定义的ID，用于(逻辑上)对应用程序生成的Dlt消息进行分组。 2.3 有效载荷 2.3.1 非冗余模式 非冗余模式下的的有效载荷就比较简单，只传输参数值(不需要任何关于它们的元信息)，以及其他属性(如参数名称或类型)，为了允许在接收到的Dlt消息中正确地分解所包含的参数值，将向有效负载添加专用的message ID。非冗余模式需要外部解析文件，用来解析Message ID通过消息ID和外部描述的组合，以下信息应该是可恢复的:
类型信息：Type Length、Data Type、String Coding 、Variable Info 、Fixed Point
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e93fd7b510e75f9acbecf2fb36108b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9ecb21088594d769ed9dffd5a649a43/" rel="bookmark">
			python 文件读写with open模式r,r&#43; w,w&#43; a,a&#43;区别详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 文件读写with open模式r,r+ w,w+ a,a+区别详解 python中的 with open主要要来进行文件读写的操作 在 Python 中使用文件的关键函数是 open() 函数。
打开/创建文件使用open（file，mode）函数，open() 函数有两个主要参数：文件名和模式，该函数的参数定义如下：
file:文件名，可以是包含路径的文件名
mode:文件打开模式
r:只读模式，文件不存在泽报错，默认模式(文件指针位于文件末尾)
r+:只读模式，文件不存在泽报错(文件指针位于文件开头)
w:写入模式，文件不存在则自动报错，每次打开会覆盖原文件内容,文件不关闭则可以进行多次写入（只会在打开文件时清空文件内容）
w+:写入模式，文件不存在则自动报错，每次打开会覆盖原文件内容，文件不关闭则可以进行多次写入（只会在打开文件时清空文件内容，指针位置在文件内容末尾）
a:追加模式，文件不存在则会自动创建，从末尾追加，不可读。
a+:追加且可读模式，刚打开时文件指针就在文件末尾。
打开文件/创建文件:
with open("test.txt","a") as f: 写入：
f.write("abc") 关闭文件：
f.closed 例子：
with open("xxx.txt","w",encoding="utf-8") as f: f.write("篮不住的十三") with open("xxx.txt",encoding="utf-8") as f: print(f.read()) 对应结果
生成文件
文件内容
为了更好的区分这几种模式，整理了一下表格，如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04309d79c39c7249b516351c5c1f45c8/" rel="bookmark">
			初识GPU编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初识GPU编程 基本概念 CPU和主存被称为主机（Host），GPU和显存（显卡内存）被称为设备（Device），CPU无法直接读显存，GPU无法直接读主存，通过Bus相互通信。
检查是否安装了CUDA
$conda install cudatoolkit 安装 Numba库
$ conda install numba 检查CUDA与Numba是否安装成功
from numba import cuda print(cuda.gpus) cuda会独占一张卡，默认0号，可以使用
CUDA_VISIBLE_DEVICES='5' python example.py 环境变量设置选择某张卡
GPU程序和CPU程序的区别 CPU程序是顺序执行的，一般需要：
初始化CPU计算得到计算结果 CUDA编程中，GPU流程：
初始化， 将必要数据拷贝到GPU设别的显存CPU调用GPU函数，启动GPU多核同时计算CPU和GPU异步计算将GPU计算结果拷贝回主机，得到计算结果 GPU程序示例
from numba import cuda def cpu_print(): print("print by cpu.") @cuda.jit def gpu_print(): # GPU核函数 print("print by gpu.") def main(): gpu_print[1, 2]() cuda.synchronize() cpu_print() if __name__ == "__main__": main() 不同于从传统的Python CPU代码
使用 from numba import cuda 引入cuda库在GPU函数上添加@cuda.jit装饰符，GPU函数又叫核函数主函数调用GPU核函数，添加[1, 2]，告诉GPU以多大的并行粒度同时计算。gpu_print[1, 2]()表示同时开启两个线程并行执行，函数回被执行2次。GPU启动异步：CPU不会等GPU执行完，必要时用cuda.synchronize()等待执行。 Thread层次结构 GPU需要定义执行配置。并行执行2次还是8次。需要明白CUDA的Thread层次结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04309d79c39c7249b516351c5c1f45c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6bd25463d68beeb5f2375ce680df023/" rel="bookmark">
			性能测试实战分享1---TPS上升后下降
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：30个并发，单台jmeter压测；客户端-Windows系统，服务端-linux系统；
问题：TPS上升后下降，且下降为高峰TPS的四分之一左右；
原因：压测机tcp连接端口占用过多超2万7千多，且大部分TCP连接都是time_wait状态，顾tcp连接端口不足；
解决方案：采用分布式压测，增加端口号；
分析思路：
*第一步：*分析客户端和服务端的性能，看是否有性能瓶颈（CPU，内存，磁盘，网络）
*第二步：*再分析客户端和服务端的端口是否用尽
*第三步：*最后分析客户端和服务端的Java堆栈日志，分析原因
本次测试的经验分享：
1、通过jemter-permon监控分析服务端的硬件性能，看是否有性能瓶颈（CPU，内存，磁盘，网络），结果：未发现硬件性能瓶颈；通过任务管理器查看客户端（Windows服务器），也未发现硬件性能瓶颈。
2、通过jstack分析服务端的Java堆栈信息，因为一直没有获取到对应服务Java的pid，所以也没有一直分析（后期分析有结果再和大家分享）；通过jstack分析客户端的Java堆栈信息，发现如下错误：
“java.lang.Thread.State: RUNNABLE at java.net.DualStackPlainSocketImpl.connect0(Native Method) at java.net.DualStackPlainSocketImpl.socketConnect(Unknown Source) at java.net.AbstractPlainSocketImpl.doConnect(Unknown Source) - locked &lt;0x0000000776a7fff8&gt; (a java.net.DualStackPlainSocketImpl) at java.net.AbstractPlainSocketImpl.connectToAddress(Unknown Source) at java.net.AbstractPlainSocketImpl.connect(Unknown Source) at java.net.PlainSocketImpl.connect(Unknown Source) at java.net.SocksSocketImpl.connect(Unknown Source) at java.net.Socket.connect(Unknown Source)” 初步定位可能跟端口号用尽有关；
3、通过netstat -ano|findstr 443|find /C “TCP”（window系统）分析客户端tcp端口的使用个数，通过netstat -ano|findstr 443|findstr TCP分析客户端tcp端口的使用情况。
结果：发现TCP端口使用2万7千多，且大部分都是time_wait状态。
4、以此判断tcp连接端口不足，采用分布式来压测，TCP曲线图基本正常。
5、为啥30个并发就把TCP端口占用这么多，需要进一步详细分析下。
问题监控现象图：
问题解决恢复监控图：
说明
欢迎对于测试志同道合的人加入，大家一起沟通交流！
QQ群：775460627
个人微信：wxid_ptea4d8gx4tx12；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3c2f4c522326743cf55e04d9c04a617/" rel="bookmark">
			ueditor插件下载和安装使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 UEditor 是由百度「FEX前端研发团队」开发的所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码。
下载 推荐直接在github上下载，release发布页地址：https://github.com/fex-team/ueditor/releases
下载文件说明，以v1.4.3.3举例：
ueditor1_4_3_3-gbk-asp.zip：包含asp示例并以gbk编码ueditor1_4_3_3-gbk-jsp.zip：包含jsp示例并以gbk编码ueditor1_4_3_3-gbk-net.zip：包含DotNet示例并以gbk编码ueditor1_4_3_3-gbk-php.zip：包含php示例并以gbk编码ueditor1_4_3_3-utf8-asp.zip：包含asp示例并以utf-8编码ueditor1_4_3_3-utf8-jsp.zip：包含jsp示例并以utf-8编码ueditor1_4_3_3-utf8-net.zip：包含DotNet示例并以utf-8编码ueditor1_4_3_3-utf8-php.zip：包含php示例并以utf-8编码 安装 本文以 ueditor1_4_3_3-utf8-net.zip 版本说明安装使用步骤
说明 官网每发布一个版本都提供了多种类型可供选择，asp，jsp，dotnet，php。无论选择哪一种版本，其实里面的前端js代码都是一样的，区别只是后端示例代码不同推荐使用utf-8版本，因为现在的软件工程基本都是utf-8的编码，很多的ide也都默认utf-8，如 VisualStudio 。DotNet 类型的对于传统DotNetFramework 和 DotNetCore都是适用的，其实等你下载下来查看里面的C# 代码会发现，官方仅提供了一个例子，真正项目中落地大概率需要改造这个例子。 示例 以 AspDotNetCore MVC 工程为例说明
先创建一个 AspDotNetCore MVC 的工程，创建完毕，工程目录结构如下： 以下目录结构为windows资源管理器视图，可能和VS中稍有差异
│ appsettings.Development.json │ appsettings.json │ Program.cs │ tree.txt │ WebApplication2.csproj │ WebApplication2.sln │ ├─Controllers │ HomeController.cs │ ├─Models │ ErrorViewModel.cs ├─Properties │ launchSettings.json │ ├─Views │ │ _ViewImports.cshtml │ │ _ViewStart.cshtml │ │ │ ├─Home │ │ Index.cshtml │ │ Privacy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3c2f4c522326743cf55e04d9c04a617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d12ae14d471d9866666a053b08278a4f/" rel="bookmark">
			YAML文件解析错误，ParserError: while parsing a block mapping in “./docker-compose.yml“, line 1, column 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误详情： ERROR: yaml.parser.ParserError: while parsing a block mapping in "./docker-compose.yml", line 1, column 1 expected &lt;block end&gt;, but found '&lt;block mapping start&gt;' in "./docker-compose.yml", line 243, column 2 原因：空格导致的未对齐（严格意义上的对齐）
解决方案，对应位置line 243, column 2添加或者删除空格，使得同一层的保持对齐。
YAML简介 YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言）。
YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。
YAML 的配置文件后缀为 .yml，如：docker-compse.yml 。
需详细了解YAML请参考：
菜鸟教程 YAML 入门教程
GITHUB YAML开源项目 YAML数据语言规范
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2905afa69b7c948641d99ed723be5bd9/" rel="bookmark">
			Java项目:精美风在线音乐系统(java&#43;JDBC&#43;C3P0&#43;servlet&#43;mysql&#43;JSP)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码获取：博客首页 "资源" 里下载！ 1.运行环境 环境配置：
Jdk1.8 + Tomcat8.5 + mysql + Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）
项目技术：
JSP + C3P0+ Servlert + html+ css + JavaScript + JQuery + Ajax + Fileupload等等
用户管理控制层： @Controller @RequestMapping("/user") public class UserController { @Autowired protected WebResponse webResponse; @Resource protected IUserService userService; @Resource protected IMyMusicService MyMusicService; @Autowired UserService userService2; String newName = null; // 登录功能 @RequestMapping(value = "/loginPage", method = RequestMethod.POST, produces = "application/json;charset=UTF-8") @ResponseBody public WebResponse loginCon(HttpServletRequest request, HttpSession session) { // 取参数的方法，对应登录表单中的用户名name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2905afa69b7c948641d99ed723be5bd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a8fbf0876d1e9aeaa8284e5cce2071/" rel="bookmark">
			Springboot&#43;Netty创建websocket客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址：http://t.csdn.cn/TQW0Y 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94175f130cfc4d1c83644d794ecbea4c/" rel="bookmark">
			一文捋清【reshape、view、rearrange、contiguous、transpose、squeeze、unsqueeze】——python &amp; torch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一文捋清【reshape、view、rearrange、contiguous、transpose、squeeze、unsqueeze】 1. reshape2. view3. rearrange4. transpose5. permute6. contiguous7. squeeze8. unsqueeze 1. reshape reshape() 函数： 用于在不更改数据的情况下为数组赋予新形状。
注意： 用于低维度转高维度
c = np.arange(6) print("** ", c) c1 = c.reshape(3, -1) print("** ", c1) c2 = c.reshape(-1, 6) print("** ", c2) ** [0 1 2 3 4 5] ** [[0 1] [2 3] [4 5]] ** [[0 1 2 3 4 5]] 2. view torch中，view() 的作用相当于numpy中的reshape，重新定义矩阵的形状。
v1 = torch.range(1, 16) v2 = v1.view(-1, 4) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94175f130cfc4d1c83644d794ecbea4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e2322dac4d974dd983582118cd9bc3/" rel="bookmark">
			Linux高级进程编程———在任意两个进程间传递文件描述符：使用 sendmsg 和 recvmsg 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程间传递打开的文件描述符，并不是传递文件描述符的值。那么在传递时究竟传递了什么？我们要先搞明白这个问题。
1、文件描述符 文件描述符的值与文件没有任何联系，只是该文件在进程中的一个标识，所以同一文件在不同进程中的文件描述符可能不一样，相同值 的文件描述符在不同进程中可能标识不同文件。
文件数据结构 Linux使用三种数据结构表示打开的文件：
— 文件描述符表 ：进程级的列表，内含若干项，每一项都存储了当前进程中一个文件描述符及其对应的文件表指针。
— 文件表 ：内核级的列表，内含若干文件表项，每一个文件表项对应文件描述符表中的一项，即，不同进程打开的同一文件对应内核中的不同文件表项，这样能够使每个进程都有它自己的对该文件的当前偏移量。
— v节点 ：内核级的列表，每个打开的文件都只有一个v节点，包含文件类型，对文件进行操作的函数指针，有的还包括 i 节点。
三者的对应关系如下图所示：
不难发现，在进程之间传递 “文件描述符” 并不只是传递一个int型的标识符，而是需要一套特殊的传递机制。本篇博客介绍的方法基于sendmsg 和 recvmsg这两个函数。
首先在两个进程之间建立 UNIX域 socket 作为消息传递的通道，然后发送进程调用 sendmsg 向通道发送特殊的消息，内核对该消息做特殊的处理，从而将打开的文件描述符传递到接收进程。且接收方和发送方的文件描述符指向内核中相同的文件表项。所以，进程间传递文件描述符也算是实现了进程间共享文件，如下图所示：
2、使用UNIX域 socket 实现传递文件描述符 创建UNIX域很简单，用socketpair函数即可，难的是如何使用sendmsg 和 recvmsg函数进行发送和接收。两个函数的定义如下：
#include&lt;sys/socket.h&gt; ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags); ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags); 参数sockfd的含义不必多说，msg可理解为被发送/接收的数据，在recvmsg中他的行为类似于传出参数，flags参数与recv/send的同名参数含义一样。成功时返回实际发送/接收的字节数，失败返回-1。
该函数最难理解的就是msg的类型 msghdr ，文件描述符就是通过msghdr结构体的msg_control成员发送的，而msg_control又是 cmsghdr 类型，下面将重点介绍他们。
msghdr 结构体 结构体定义如下：
struct msghdr { void* msg_name; socklen_t msg_namelen; struct iovec* msg_iov; int msg_iovlen; void* msg_control; socklen_t msg_conntrollen; int msg_flags; 最后这个参数不管 } 结构体成员两两一组分为3组，这样分析清晰很多：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e2322dac4d974dd983582118cd9bc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad15bcdff24a63eb860fa908ce97ed7/" rel="bookmark">
			poi使用整理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 POI简介
Apache POI是Apache软件基金会的开放源码函式库，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。
二、 HSSF概况
HSSF 是Horrible SpreadSheet Format的缩写，通过HSSF，你可以用纯Java代码来读取、写入、修改Excel文件。HSSF 为读取操作提供了两类API：usermodel和eventusermodel，即“用户模型”和“事件-用户模型”。
三、 POI EXCEL文档结构类
HSSFWorkbook excel文档对象
HSSFSheet excel的sheet HSSFRow excel的行
HSSFCell excel的单元格 HSSFFont excel字体
HSSFName 名称 HSSFDataFormat 日期格式
HSSFHeader sheet头
HSSFFooter sheet尾
HSSFCellStyle cell样式
HSSFDateUtil 日期
HSSFPrintSetup 打印
HSSFErrorConstants 错误信息表
四、 EXCEL常用操作方法
1、 得到Excel常用对象 [c-sharp] view plaincopy
POIFSFileSystem fs=newPOIFSFileSystem(new FileInputStream("d:/test.xls")); //得到Excel工作簿对象 HSSFWorkbook wb = new HSSFWorkbook(fs); //得到Excel工作表对象 HSSFSheet sheet = wb.getSheetAt(0); //得到Excel工作表的行 HSSFRow row = sheet.getRow(i); //得到Excel工作表指定行的单元格 HSSFCell cell = row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad15bcdff24a63eb860fa908ce97ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431481de05761223b7ab69255dd1b10f/" rel="bookmark">
			笔记：STM32——使用ADC通道采集端口电压数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、ADC的介绍 ADC就是模数转换，就是将芯片的端口模拟量转化位数字量显示出来能够看得到这个比例值。
转换类型分三种：
1、逐次逼近型就是类似于二分查找法，当给定一个值然后与这个比较，大于这个值那么就是在这个值得以上到边界值，那么下一次比较就是在大于这个值到边界值得中间那个比较，然后在与这两个中间值比较。依次比较，直到找到这个值，这个算法复杂度在log2n。
2、双积分型就是它先对输入采样电压和基准电压进行两次积分，以获得与采样电压平均值成正比的时间间隔，同时在这个时间间隔内，用计数器对标准时钟脉冲（CP）计数，计数器输出的计数结果就是对应的数字量。优点在于算出得值比较精准。
3、电压频率转换型就是将模拟电压量变换为脉冲信号，该输出脉冲信号的频率与输入电压的大小成正比。这样就可以算出实际得输出电压了。
STM32F103通常有ADC1、ADC2、ADC3三个，但是通到有18个外部可用通道有16个，内部通道有2个，意思就是可测IO口得通道有16个。不可测IO口得有2个，但是这两个是测量内部芯片得温度得，这个也是同模数转换来得出温度值得。
可以看到这个图PA0的IO口可以使用ADC1、ADC2、ADC3这三个其中一个都可以，但是呢通道到IN0就是16个通道里的第0个通道。
ADC通道表格 通道ADC1ADC2ADC3通道0PA0PA0PA0通道1PA1PA1PA1通道2PA2PA2PA2通道3PA3PA3PA3通道4PA4PA4PF6通道5PA5PA5PF7通道6PA6PA6PF8通道7PA7PA7PF9通道8PB0PB0PF10通道9PB1PB1通道10PC0PC0PC0通道11PC1PC1PC1通道12PC2PC2PC2通道13PC3PC3PC3通道14PC4PC4通道15PC5PC5通道16温度传感通道17内部参考电压 4、ADC的四种转换模式：分别位单次转换非扫描、连续转换非扫描、单次转换扫描、连续转换扫描这四种。还有一个是双重模式，这个只有双ADC的芯片才有的模式。这个模式的意思就是两个ADC分别对这个数据转换，意思就是轮流上。转换速度又快数据又精准。
这里有个结构图比较好理解。分别1就是ADC开始转换口分别为内部温度和外部IO口的开始。
2就是ADC选择ADC几和通道。3就是选择通道模式，分别注入组可以到达最多只能四个通道，注入组就是VIP通道可以最大16个通道，还有一个4没有截图那个就是一个触发控制位，5就是ADC
的分频器，等下讲到ADC规定的分频器不能超过多少，6就是通道模式的寄存器从，存放通到转换的数据，最后第7个全部选择完了，就到到了最后输出NVIC的ADC触发。然后输出结果。
5、转换模式介绍
单次转换非扫描模式：意思就是只有第一个开始选的通道数据有效，这个意思就是无论你选择哪一个通道，它只有第一个选的那个通道是有效的，其他的选了意思白选，而不是说通道1的意思，然后触发一次EOC，最后输出数据。
单次转换扫描模式：意思就是你只要告诉芯片我选了多少个通道，然后执行的时候，芯片就会一下子给你转换多少个通道，把这些转换通道一下子推到寄存器上面。这样就转换完了。每次转换的时候都需要触发一次EOC
连续转换非扫描模式：意思就是你每次只能给一个通道，但是这个不需要每转一次就触发一次EOC，而是会一直转换但是每次你只能给一个通道。
连续转换扫描模式：就是可以选很多个通道。一直启动扫描，不会停止。
6、ADC的数据位左对齐和有对齐，因为ADC的数据位是12，但是芯片的寄存器是16位所以要一个对齐方式，左对齐就是在高位这边对齐，但是这个对齐方式是原来的16倍因为二进制的4个位是2的4次方，而且这个对齐方式数据比较大，不会太精准。右对齐就是在低位开始对齐，就是低位的12个数据位。可以算一下2的12次方是4096。
大概介绍完，接下来就是开始写代码了。
照常开始每次初始化结构体。然后打开时钟，这个有个小毛病啊，用旧版本的keil如果结构体在时钟的后面是会报错的，新版本一点的就不会。这个是要注意的，不过只有把结构体初始化放在时钟的前面就一定不会报错。
void AD_Init(void) { GPIO_InitTypeDef GPIO_Initstruct; //IO口结构体 ADC_InitTypeDef ADC_Initstruct; //ADC结构体 RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE); //打开 ADC的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);//打开GPIOA的时钟 接下来是ADC的分频时钟了，上面说到ADC的分频是不可以超过14MHz的但是分频只有2、4、6、8这四个分频。如果八分频就是9Mhz6分频那么是12Mhz，4分频是18Mhz，所以只能选6和8这两个了，所以这里选的是6分频。当 ADC_CLK=14Mhz 的时候，并设置 1.5 个周期的采样时间，则 Tcovn=1.5+12.5=14 个周期=1us。通常经过 ADC 预分频器能分频到最大的时钟只能是 12M，采样周期设置为 1.5 个周期，算出最短的转换时间为 1.17us，这个才是最常用的。
RCC_ADCCLKConfig(RCC_PCLK2_Div6); //AD的分频因子确保不允许超过14Mhz 72/6=12 接下来是用到的IO口初始化，这里分别用到了三个，等下是要用三个模块来模拟一下这个IO口的电压的有可调电阻、光照传感器、热敏传感器是D0这个口的接IO口的。剩下的该接电接地，模式选择的模拟输入这个ADC专属的。
GPIO_Initstruct.GPIO_Mode= GPIO_Mode_AIN; //模拟输入 ADC专属模式 GPIO_Initstruct.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2; GPIO_Initstruct.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOA,&amp;GPIO_Initstruct);//初始化PA2 到ADC结构体参数。一些作用下面注释有
ADC_Initstruct.ADC_Mode=ADC_Mode_Independent; //模式选择，这里是独立就是不用ADC1和ADC2同时进行 ADC_Initstruct.ADC_DataAlign=ADC_DataAlign_Right; //寄存器数据对齐方式右 ADC_Initstruct.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None;//触发方式禁止外部，使用软件触发 ADC_Initstruct.ADC_ContinuousConvMode=DISABLE; //关闭连续转换所以是单次转换模式 ADC_Initstruct.ADC_ScanConvMode=DISABLE; //非多通道扫面模式 单通道模式 ADC_Initstruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431481de05761223b7ab69255dd1b10f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cddc858fe00cc25469af56fde453bb2/" rel="bookmark">
			ARMv7体系结构汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 .处理器工作模式2. 处理器工作状态3. ARM寄存器3.1 通用寄存器3.2 状态寄存器3.3 备份的程序状态寄存器SPSR3.4 Thumb寄存器 4. ARM指令系统4.1 指令和指令格式4.2 指令的可选后缀S后缀!后缀 4.3指令的条件执行4.4 ARM指令分类 5 . ARM指令的寻址方式5.1 立即数寻址5.2 寄存器寻址5.3 寄存器间接寻址5.4 寄存器移位寻址5.5 基址变址寻址5.6 多寄存器寻址5.7 相对寻址5.8 堆栈寻址 6. 数据处理指令6.1 数据传送指令MOV指令MVN指令 6.2 移位操作1．LSL逻辑左移2．LSR逻辑右移3．ASR算术右移4．ROR循环右移5．RRX带扩展的循环右移 6.3 算术指令1. ADD 加法指令2. ADC带进位加法指令3. SUB减法指令4. SBC 带借位减法指令5. RSB 逆向减法指令6. RSC带借位的逆向减法指令 6.4 逻辑运算指令1. AND 逻辑与指令2. ORR 逻辑或指令3. EOR 逻辑异或指令4. BIC 位清除指令 6.5 比较指令1. CMP比较指令2. CMN反值比较指令3. TST位测试指令4. TEQ相等测试指令 6.6 乘法指令1. MUL 32位乘法指令2. MLA 32位乘加指令3. SMULL　64位有符号数乘法指令4. SMLAL　64位有符号数乘加指令5. UMULL 64位无符号数乘法指令6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cddc858fe00cc25469af56fde453bb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78589586ca19030f0f7d135443bc9cb2/" rel="bookmark">
			snmp监控设备运行启动时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 监控网络设备运行时间
通过snmp oid监控
问题描述 snmp 通过sysUpTime 取时间最大是2^32
而且单位还是ms
类型是Timeticks
原因分析： sysUpTime 是一个 32 位计数器，将在 496 天后翻转。
snmpwalk结果如下
DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (456349) 1:16:03.49
snmpEngineTime (.1.3.6.1.6.3.10.2.1.3) 以秒为单位返回正常运行时间，并且不应翻转 135 年。
snmpwalk结果如下
SNMP-FRAMEWORK-MIB::snmpEngineTime.0 = INTEGER: 41580822 seconds
解决方案： 换用snmpEngineTime 取值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/624373083bab58c81880dab9032bf0bd/" rel="bookmark">
			批量文件（文件名）转移至指定文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目的： 1.拥有一些需要分类的乱序文件名
2.将相关文件名的文件从一个文件夹中取出存放至指定文件夹
（eg：手上有2530、9979等数字的word文档，需要把文件夹中含有2530、9979同类型的文件都取出来，有：2530.txt、2530_AV.hea、2530_AV.tsv、2530_MV.wav等等）
工具：Windows、txt、word 步骤： 一：在需要处理的文件夹根目录下创建一个txt文档，命名随机 二：打开txt文档在里面输入： DIR *.* /B &gt;list.txt 保存并关闭
三：修改文件后缀： （将txt修改为bat），双击bat文件后，会生成一个list.txt文件
（list文件中是当前文件夹中所有的文件名，可以复制备用，如果不需要批量获取，则可跳过）
四：打开word： 将需要移动的 文件 和 文件夹 对应
依照格式：move空格"文件路径+文件名"空格"文件路径+文件夹名" （一行一个转换格式）
为了清楚展示我将文件路径删减了，原路径：（move “D:\yanyixia\xinyin\the-circor-digiscope-phonocardiogram-dataset-1.0.2\training_data\43852_MV.tsv” “D:\yanyixia\xinyin\the-circor-digiscope-phonocardiogram-dataset-1.0.2\normal”）
（五：）如果是批量修改路径的话，建议使用word中-开始-查找-高级查找-替换 的工具进行批量操作：批量加前缀：^13（批量加前缀时需要空出第一行）；批量加后缀：^p。再点击全部替换就行了
六：在文件夹地址栏输入：cmd，回车弹出命令提示符 七：复制第四步word中准备的内容，粘贴至cmd窗口 （如没有找到对应所需移动的文件，会自动跳过执行下一个）结束！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8264d237d39cc5a4a0ccdc88532aa8c/" rel="bookmark">
			证件照尺寸像素规格，证件照尺寸怎么修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的证件照有红白蓝三种底色，尺寸有1寸、2寸，随着电脑软件的普及，大家都开始自制证件照。那么当需要不同尺寸的证件照时该怎么处理呢。下面就带大家一起来看看证件照尺寸像素怎么修改以及证件照尺寸像素对照表。
一、证件照尺寸像素怎么修改
证件照尺寸像素的修改方法其实很多，下面就介绍3种比较简单好用的方法：
1、稿定抠图调整证件照像素大小
稿定抠图可以在制作完证件照后选择裁剪，第一种是在证件中选择各种证件照尺寸，像素大小是自动的。
图片1：稿定抠图证件大小
当然也可以自定义像素大小，选择常规选项，在尺寸选项下方设置自己想要的像素大小即可。
图片2：稿定抠图自定义像素大小
2、美图秀秀调整证件照像素大小
在美图秀秀中证件照像素大小也很好调整，在证件照设计功能下，有图片尺寸选项，下方可以自定义证件照的像素大小。同样的也可以选择常见的证件照尺寸，如一寸二寸等。
图片3：美图秀秀修改证件照像素
3、证照之星调整证件照像素大小
证照之星比较常用的功能之一当然是调整证件照像素大小，比如我们常用的一寸和二寸就可以通过证照之星快速调整。下面就一起来看看证照之星怎么调整照片大小吧。
我们可以看到证照之星菜单栏上有一个照片裁切功能按钮，我们导入需要调整的照片，选择照片裁切，其中有自动裁切、手动裁切和自定义尺寸裁切。自动裁剪工具是按照照片的像素比例来的，虽然用起来比较方便，但其实它对照片的要求是比较高的。所以有时候就需要我们手动裁切。
图片4：证照之星自动裁切
手动裁切也很简单，打开之后我们可以看到照片上方出现了一个裁切框，我们只需要拖动裁切框至自己想要的位置和大小便完成了照片的大小调整。
图片5：证照之星手动裁切
自定义裁剪在调整照片大小方面更加精确，如下图所示，我们选择了自定义之后会出现一个设置像素大小的对话框，可以设置任意你想要的照片大小，可以保持原图宽高比例，也可以取消原图宽高比例，这个根据自己的需求来即可。
图片6：证照之星自定义设置尺寸
二、证件照尺寸像素对照表
为了方便大家调整修改证件照尺寸像素，下面整理了一份证件照尺寸像素对照表：
1、小1寸证件照（一般用于身份证大头照）：尺寸：22mmx32mm；像素：259x377
2、1寸证件照：25mmx35mm；像素：413x295
3、大1寸证件照(主要用于护照) ：33mmx48mm；像素：567x390
4、小2寸（用于除韩国、日本之外的大部分东南亚国家签证）：35mmx45mm
5、2寸证件照：35mmx49mm
6、5寸证件照：127mmx89mm
7、6寸证件照152mmx102mm
8、7寸 178mmx127mm
以上就是尺寸像素的修改方法介绍，还有常用的证件照尺寸像素对照表，大家以后在制作各类证件照时可以参照此数据标准来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d31da181a639095656716811bd4540f/" rel="bookmark">
			SSM项目中配置多数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文：近期SSM项目中需要对接其他系统，涉及到多个数据源的配置，在这里记录一下，方便以后自己查阅。
使用的数据库是sqlserver，步骤如下：
1、编写dbproperties #ams数据源 jdbc.driver=com.microsoft.sqlserver.jdbc.SQLServerDriver jdbc.url1=jdbc:sqlserver://ip:2566;DatabaseName=h-ams jdbc.username1 = xxx jdbc.password1 = xxx #oa8000数据源 jdbc.driver=com.microsoft.sqlserver.jdbc.SQLServerDriver jdbc.url2=jdbc:sqlserver://ip:2566;DatabaseName=oa8000 jdbc.username2 = xxx jdbc.password2 = xxx 2、编写spring.xml &lt;!--配置整合mybatis过程--&gt; &lt;!--1、配置数据库相关参数--&gt; &lt;context:property-placeholder location="classpath:jdbc.properties" ignore-unresolvable="true"/&gt; &lt;!--2、 数据源druid --&gt; &lt;!-- 数据源1 start --&gt; &lt;bean id="dataSource1" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt; &lt;property name="url" value="${jdbc.url1}"/&gt; &lt;property name="username" value="${jdbc.username1}"/&gt; &lt;property name="password" value="${jdbc.password1}"/&gt; &lt;!-- 设置初始大小、最小、最大 连接数--&gt; &lt;property name="initialSize" value="${druid.pool.size.init}"/&gt; &lt;property name="minIdle" value="${druid.pool.size.min}"/&gt; &lt;property name="maxActive" value="${druid.pool.size.max}"/&gt; &lt;!-- 配置监控统计拦截的filters，wall用于防止sql注入，stat用于统计分析 --&gt; &lt;property name="filters" value="wall,stat" /&gt; &lt;/bean&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d31da181a639095656716811bd4540f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04be9e1f1d4dc600c04f34ec63aa81d6/" rel="bookmark">
			DV算法——毒性逆转题目图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Consider Figure 5.7. Suppose there is another router w, connected to router y and z. The costs of all links are given as follows: c(x,y) = 4, c(x,z) = 50, c(y,w) = 1, c(z,w) = 1, c(y,z) = 3. Suppose that poisoned reverse is used in the distance-vector routing algorithm.
考虑图5.7。假设有另一个路由器w，连接到路由器y和z，所有链路的代价如下:c(x,y) = 4, c(x,z) = 50, c(y,w) = 1, c(z,w) = 1, c(y,z) = 3。假设在距离向量路由算法中使用了毒性逆转。
**a. When the distance vector routing is stabilized, router w, y, and z inform their distances to x to each other.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04be9e1f1d4dc600c04f34ec63aa81d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb98e6da825e937ad20f8ca31d6a004/" rel="bookmark">
			Linux系统级程序设计-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件操作函数 1.stat函数 用于获取文件属性，包括文件的文件名、文件大小、文件类型等等
#include &lt;sys/stat.h&gt; int stat(const char *path, struct stat *buf); 参数path为文件的路径（同目录下为文件名）；参数buf即接受文件所拥有的属性。
2.access() 用于测试文件的某些权限是否存在
#include &lt;unistd.h&gt; int access(const char *pathname, int mode); 参数pathname为文件名；
参数mode取值有4个分别为：R_OK, W_OK, X_OK, F_OK；前3个是测试文件是否具有读、写、执行权限，最后一个测试文件是否存在。
3.chmod() 修改文件的访问权限，与Linux中chmod差不多
#include &lt;sys/stat.h&gt; int chmod(const char *path, mode_t mode); 参数path为路径名；参数mode为需要修改的权限，权限值有以下几种：
4.truncate() 用于修改文件的大小，如果修改后文件大小比起始小了，文件的部分数据会被删除,其功能与lseek函数类似；
#include &lt;sys/stat.h&gt; int truncate(const char *path, off_t length); 参数说明：
path：路径名；
length：设置文件大小。
返回值说明：
成功：0；
不成功：-1并设置errno。
进程 父子进程的关系以及如何创建一个子进程？如何实现一个父进程创建多个子进程？父进程创建多个子进程时会遇到什么问题，该怎么解决？什么是孤儿进程，孤儿进程不处理会出现什么情况？
1.子进程创建函数:fork() 创建进程；函数执行后，系统会创建一个与原进程几乎相同的进程，之后父子进程都继续执行
#include &lt;unistd.h&gt; pid_t fork(void); 创建案例：
test_fork.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eb98e6da825e937ad20f8ca31d6a004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/805494c988a55672af1d12b2081635a4/" rel="bookmark">
			Flutter开发之——getX-国际化(08)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 国际化效果图 如下图所示，点击中文按钮显示中文；点击EN按钮显示英文，进行切换
国际化中文国际化英文 二 国际化步骤 2.1 项目结构图说明 本项目是在上文Flutter开发之——底部导航栏BottomNavigationBar的基础上进行修改，关于这方面的知识点，请查看上文，这里只对国际化的内容做如下说明：
Main：入口文件配置string：Messages各种语言键值对中的键，方便复用和显示时引用Messages：国际化语言配置，根据需要配置中文/英文/其他 2.2 项目代码 main void main() =&gt; runApp(GetMaterialApp( translations: Messages(), //显示继承Translations，配置显示国际化内容 locale: const Locale('zh', 'CN'),//默认展示本地语言 fallbackLocale: const Locale('zh', 'CN'),//语言选择无效时，备用语言 getPages: [ GetPage(name: '/', page: () =&gt; IndexWidget(), binding: IndexBinding()) ])); 说明：
在GetMaterialApp分别配置translations、locale、fallbackLocale三个选项translations：显示继承Translations，配置显示国际化内容locale：刚进入App时，默认显示语言fallbackLocale：语言选择无效时，备用语言 string(国际化键值对和显示内容) class I18nContent{ static const String title="title"; static const String BottomBarHome="home"; static const String BottomBarTree="tree"; static const String BottomBarNavi="navi"; static const String BottomBarMe="me"; } Messages class Messages extends Translations{ @override Map&lt;String, Map&lt;String, String&gt;&gt; get keys =&gt; { //1-配置中文简体 'zh_CN':{ I18nContent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/805494c988a55672af1d12b2081635a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6a0cd8dc7fbe04dae7982b10815c52/" rel="bookmark">
			Java项目:新闻发布系统(java&#43;SpringBoot&#43;JSP&#43;layui&#43;Maven&#43;mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码获取：博客首页 "资源" 里下载！ 一、项目运行
环境配置： Jdk1.8 + Tomcat8.5 + mysql + Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）
项目技术： JSP +SpringBoot + MyBatis + html+ css + JavaScript + JQuery + Ajax + layui+ maven等等。
新闻管理控制层： @Controller @RequestMapping("NewsServlet") public class NewsController { @Autowired private HttpServletRequest request; private NewsDao newsDao = new NewsDao(); private CategoryDao categoryDao = new CategoryDao(); private CommentsDao commentsDao = new CommentsDao(); @RequestMapping("/publish") public String publish(){ String title = request.getParameter("title"); String content = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e6a0cd8dc7fbe04dae7982b10815c52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7b5bf53768f0abfcc199fb7624cc20/" rel="bookmark">
			三大编程范式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编程范式有以下三种： 1、面向对象编程 2、面向过程编程 3、面向函数编程 区别： 面向对象编程最大的特点是：以类、对象作为组织代码的单元以及它的四大特性。 面向过程编程最大的特点是：以函数作为组织代码的单元，数据与方法相分离。 函数式编程跟面向过程编程一样，也是以函数作为组织代码的单元。 不过，它跟面向过程编程的区别在于，它的函数是无状态的。 何为无状态？ 简单点讲就是，函数内部涉及的变量都是局部变量， 不会像面向对象编程那样，共享类成员变量， 也不会像面向过程编程那样，共享全局变量。 函数的执行结果只与入参有关，跟其他任何外部变量无关。 同样的入参，不管怎么执行，得到的结果都是一样的。 这实际上就是数学函数或数学表达式的基本要求。 总结： 不同的编程范式之间并不是截然不同的，总是有一些相同的编程规则。 比如，不管是面向过程、面向对象还是函数式编程，它们都有变量、函数的概念， 最顶层都要有 main 函数执行入口，来组装编程单元（类、函数等）。 只不过，面向对象的编程单元是类或对象，面向过程的编程单元是函数，函数式编程的编程单元是无状态函数。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfcc9c94cc6fb3007fc6985b2e864bbf/" rel="bookmark">
			聚类--DBSCAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是DBSCN DBSCAN也是一个非常有用的聚类算法。
它的主要优点:它不需要用户先验地设置簇的个数，可以划分具有复杂形状的簇，还可以找出不属于任何簇的点。DBSCAN比凝聚聚类和k均值稍慢，但仍可以扩展到相对较大的数据集。 1.1算法原理 DBSCAN的原理是识别特征空间的“拥挤”区域中的点，在这些区域中许多数据点靠近在一起。这些区域被称为特征空间中的密集区域。
DBSCAN背后的思想：簇形成数据的密集区域，并由相对较空的区域分隔开。 在密集区域内的点被称为核心样本（或核心点），它们的定义如下。
DBSCAN有两个参数：min_samples和eps。 如果在距一个给定数据点eps的距离内至少有min_samples个数据点，那么这个数据点就是核心样本。DBSCAN将彼此距离小于eps的核心样本放到同一个簇中。 一共有三种类型的点：核心点，与核心点的距离在eps之内的点（叫做边界点）和噪声。
如果DBSCAN算法在特定数据集上多次运行，那么核心点的聚类始终相同，同样的点也始终被标记为噪声。 但边界点可能与不止一个簇的核心样本相邻。因此，边界点所属的簇依赖于数据点的访问顺序。一般来说只有很少的边界点，这种对访问顺序的轻度依赖并不重要。 2、应用于模拟数据make_blobs X, y = make_blobs(random_state=0,n_samples=12) dbscan = DBSCAN() clusters = dbscan.fit_predict(X) print("Cluster memberships:\n{}".format(clusters)) 输出：
Cluster memberships: [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1] 📣
因为eps和min_samples设置不当，所有的数据都被标记为噪声
可视化
mglearn.plots.plot_dbscan() 📣
在这张图中，属于簇的点是实心的，噪声点为空心。核心样本显示为较大的标记，边界点则显示为较小的标记。 增大eps，扩大核心点的领域，会让一个簇变得更大增大min_samples会让一个簇中包含更多的点，同时核心点变小，噪声变多 👍
eps更重要 它决定了点与点之间“接近的含义”。 eps过小，没有点是核心样本eps过大，所有点成单个簇 min_samples是为了判断稀疏区域内的点被标记为异常值还是形成自己的簇 决定了簇的尺寸 3、应用于模拟数据make_moons 虽然DBSCAN不需要显式地设置簇的个数，但设置eps可以隐式地控制找到的簇的个数。使用StandardScaler或MinMaxScaler对数据进行缩放之后，有时会更容易找到eps的较好取值，因为使用这些缩放技术将确保所有特征具有相似的范围.
from sklearn.datasets import make_moons from sklearn.preprocessing import StandardScaler from matplotlib import pyplot as plt X, y = make_moons(n_samples=200,noise=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfcc9c94cc6fb3007fc6985b2e864bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab1aee4a4be507ab7529a30f4cdeae1/" rel="bookmark">
			ubuntu20.04安装NVIDIA驱动后docker中rviz，pcl_viewer等涉及到访问宿主机界面的程序不可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，ubuntu20.04安装NVIDIA驱动后docker中rviz，pcl_viewer等涉及到访问宿主机界面的程序不可用，NVIDIA驱动选择如下：
选择后启动docker，然后安装galactic ros2，会报错如下：
[ERROR] [1651885440.540169712] [rviz2]: rviz::RenderSystem: error creating render window: RenderingAPIException: Unable to create a suitable GLXContext in GLXContext::GLXContext at /tmp/binarydeb/ros-galactic-rviz-ogre-vendor-8.5.0/obj-x86_64-linux-gnu/ogre-v1.12.1-prefix/src/ogre-v1.12.1/RenderSystems/GLSupport/src/GLX/OgreGLXContext.cpp (line 60)
[ERROR] [1651885440.540186404] [rviz2]: Unable to create the rendering window after 100 tries
terminate called after throwing an instance of 'std::runtime_error'
what(): Unable to create the rendering window after 100 tries
Aborted (core dumped)
启动ros1 melodic版本的rviz时，会报错如下：
rviz::RenderSystem: error creating render window: OGRE EXCEPTION(3:RenderingAPIException): Unable to create a suitable GLXContext in GLXContext::GLXContext at /build/ogre-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ab1aee4a4be507ab7529a30f4cdeae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d301fe69dfef1447e9f26157e760169/" rel="bookmark">
			AJAX的作用和JSON数据传输格式以及各种用法,以及Axios的maven坐标导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AJAX
概念:AJAX(Asynchronous javaScript And XML):异步的javaScript和Xml
AJAX作用:
1.与服务器进行数据交换:通过AJAX可以给服务器发送请求,并获取服务器响应的数据
使用了AJAX和服务器进行通信,就可以使用HTML+AJAX替换JSP页面了
2.异步交互:可以在不重新加载整个页面的情况下,与服务器交换数据并更新部分网页的技术,如:搜索联想,用户名是否可用校验.....
最原始的办法
1.获取核心对象
var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject("Microsoft.XMLHTTP"); } 2.向服务器发送请求
xhttp.open("GET", "url", true); xhttp.send(); 3.获取响应
var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { document.getElementById("demo").innerHTML = this.responseText; } }; 这是最原始的方法不建议使用
Axios请求方式别名
axios.get(url,[config])
axios.post(url,data,[config])
格式:axios.get("url").then(function (resp){
alert(resp.data)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d301fe69dfef1447e9f26157e760169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b8565ce2b7b3a5f02d4a8986be6bd8/" rel="bookmark">
			R9000P2021版拯救者 装ubuntu系统相关问题（WiFi、蓝牙、亮度调节，驱动安装）记录总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu版本选择： 21.04(10)及以上，目前（2022.05.06）最新版本为22.04。新版本的内核配置相对较高，21.04内核版本为5.13,22.04内核版本为5.15。装上这两个版本后不会出现网卡不能检测，蓝牙模块不能检测问题。
驱动安装：建议安装470版 安装步骤：启动软件和更新 ，在附加区驱动项内安装470，安装完后在终端输入nvidia-smi会出现，NVIDIA-SMI has failed because it couldn‘t communicate with the NVIDIA driver.即驱动实效。这时安装sudo apt install nvidia-cuda-toolkit即可解决问题。
亮度调节设置： 在显示应用程序里找到安装好的nvidia显卡驱动，在驱动力调节亮度保存就好，对应设置方式如下图，里面的参数可按需调节，但每次使用时需要把驱动打开。
其他问题：目前我主要遇到的是这些问题，后续出现其他问题再解决更新。。。。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/115ff93164a624f0ff279b683a8f5f64/" rel="bookmark">
			【java】浅谈双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双指针 思路及其实现 双指针就是在一个循环里有两个变量同时向前推进，循环结束条件可以是一个或多个（只要不是死循环就可）。一般模型为i（第一个指针，以下同），j（第二个指针，以下同）。第一种模型为一个数组（i从首位开始，j从末尾开始）第二种模型为二个数组（i从第一个数组首位开始，j从第二个数组尾部出发），第三钟为两个数组（i从第一个数组首位开始，j从第二个数组首位开始）
双指针一般都是两层循环优化而来，特别注意的是看我们不要的是否有用，才能确定是否使用双指针。
最长连续不重复子序列 给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。
输入格式 第一行包含整数 n。
第二行包含 n 个整数（均在 0∼105 范围内），表示整数序列。
输出格式 共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。
数据范围 1≤n≤105
输入样例： 5 1 2 2 3 5 输出样例： 3 //第一类模型 import java.io.*; public class Main { static int N = 100010; static int[] a = new int[N]; static int[] s = new int[N]; public static void main(String[] args) throws IOException { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/115ff93164a624f0ff279b683a8f5f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd090b930028137ed196afd981dd38b/" rel="bookmark">
			用MATLAB实现求椭球上任意两点的最短弧长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于法向矢量导向的求椭球上两点的最短弧长 问题分析 求椭球上任意两点间的最短弧长用数学来推算解析解的话十分复杂，因此考虑通过使用计算机来近似求解。问题的难点在于怎样让每一步都是处在最优的状态，以及怎样使每一步的方向都尽量处在该点能够选择的最优方向上。
求椭球上两点的最短路，很容易想到用传统的最短路算法如迪杰斯特拉算法或弗洛伊德算法求解，但是在椭球将步长离散化后，构造以及运用邻接矩阵十分复杂，在保证一定精度的条件下需要极大的运算量，所以最短路算法暂时没有太好的应用条件。
另一种考虑过的思路为采用经典优化算法，如粒子群算法或者蚁群算法等进行迭代求解。这种方法理论上是可行的，但是由于构造出椭球面的离散化极坐标坐标点相当多，以及这类算法本身有较大的运算量以及结果的随机性，暂时不予以考虑。
还曾考虑过用梯度下降算法来求解，就是将椭球旋转至使目标点的法向量为沿z轴负方向时构造出此时的椭球的函数表达式，即可使用梯度下降算法。这种方法是最为理想的方法，但是椭球的旋转涉及到仿射变换，构造变换矩阵非常复杂，所以暂时不予考虑。
根据梯度下降算法，可以很自然的想到既然椭球不转那我们能不能直接利用目标点的外法向量作为一个基准方向来进行导向。由次我们就想出了基于法向矢量导向的椭球上最短路求解。
模型假设 （1） 假设椭球上的网格足够小，运动点在椭球上的运动方向近似为椭球表面的切线方向
（2） 运动点到达距离终点的欧式距离小于一定范围时就视为到达终点
（3） 椭球上的运动点每次移动的欧式距离近似等于在表面移动时的弧长
（4） 椭球上的运动点的每次移动都会选择最优的方向
模型建立与算法设计 步骤操作1给定起点A和终点B的椭球极坐标，计算其直角坐标，并计算B的外法向量记为BW2计算A点在二维极坐标中以A为中心的一定宽度方格内的点Mi的极坐标3计算所有Mi的直角坐标，并且计算出向量AMi，并将其全部化为单位向量4计算BW*AMi的值，并找出使该值最小的Mi点作为下一个A点，重复步骤1 变量与符号说明 A……………………………………………….代指椭球表面的运动点的当前位置
B………………………………………………………………………………….终点
AM i _{i} i​……………………….椭球运动点在某次运动中可选择的单位方向向量集合
BW…………………………………………………椭球终点的垂直于表面的法向量
d i _{i} i​ ………………………………………………………每次运动点移动的欧式距离
ϵ \epsilon ϵ ………………………………………………………………………….终点判断值
D…………………………………………………………………………总路径的长度
模型建立与算法设计 当A要向B靠近时，求使AMi的单位方向向量与BW乘积最大的AMi作为从当前运动点指向下一个运动点的向量。对于共线的向量AMi的情况 ，取AMi长度较小的一方指向的点作为下一个A点，这样可以通过减小步长来适当降低误差。
注意注意，这里的A点周围的单位向量其实并不在一个平面内，因为我们找的是椭球上A相邻极坐标的点，所以只是椭球上从一个点出发到周围多个点的连线，我们只是用这些连线形成的向量来帮我们判断下一步的方向以及下一步所到的点。
1 给定起点和终点B的椭球极坐标，，A初始值设为起点坐标，计算其直角坐标，并计算B的外法向量记为BW
2 计算A点在二维极坐标中以A为中心的一定宽度方格内的点Mi的极坐标
3 计算所有Mi的直角坐标，并且计算出向量AMi，并将其全部化为单位向量
4 计算BW*AMi的值，并找出使该值最大的Mi点作为下一个A点
5 计算当前A点与B的欧式距离，若该距离小于 ϵ \epsilon ϵ ，则停止循环，输出D
6 计算下一个点A于当前点A之间的欧式距离d i _{i} i​，D=D+d i _{i} i​
代码实现 椭球坐标转化为直角坐标函数：
function [x,y,z]=elip2cart(theta,alpha) a=6000; b=5000; x=a.*sin(theta).*sin(alpha); y=a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbd090b930028137ed196afd981dd38b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbeb380f26b4e56e16d3de3f7a6f9840/" rel="bookmark">
			Transformer 优秀开源工作：timm 库 vision transformer 代码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		timm库（PyTorchImageModels，简称timm）是一个巨大的PyTorch代码集合，已经被官方使用了。
参考：timm 视觉库中的 create_model 函数详解
p r e t r a i n e d \color{red}{pretrained} pretrained
如果我们传入 pretrained=True，那么 timm 会从对应的 URL 下载模型权重参数并载入模型，只有当第一次（即本地还没有对应模型参数时）会去下载，之后会直接从本地加载模型权重参数。
model = timm.create_model('resnet34', pretrained=True) 输出：
Downloading: "https://github.com/rwightman/pytorch-image-models/releases/download/v0.1-weights/resnet34-43635321.pth" to /home/song/.cache/torch/hub/checkpoints/resnet34-43635321.pth 查 看 安 装 的 t i m m 库 中 可 以 使 用 哪 些 模 型 ： \color{red}{查看安装的timm库中可以使用哪些模型：} 查看安装的timm库中可以使用哪些模型：
参考：Pytorch视觉模型库–timm
找到swin transformer的模型：
'swin_base_patch4_window7_224', 'swin_base_patch4_window7_224_in22k', 'swin_base_patch4_window12_384', 'swin_base_patch4_window12_384_in22k', 'swin_large_patch4_window7_224', 'swin_large_patch4_window7_224_in22k', 'swin_large_patch4_window12_384', 'swin_large_patch4_window12_384_in22k', 'swin_small_patch4_window7_224', 'swin_tiny_patch4_window7_224', 一、修改num_classes提取分类前和后的特征 我们使用模型：vit_tiny_patch16_224
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbeb380f26b4e56e16d3de3f7a6f9840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924efc26d68c3982d2dbeb2426682330/" rel="bookmark">
			定义一个函数求n(阶乘）,再在主函数中通过调用该函数计算: 1（阶乘）&#43;3（阶乘）&#43;5（阶乘）&#43;...&#43;(2n-1)(阶乘）输入提示信息格式: “Input n:\n“输入数据格式要求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;
long Fact(int j);
int main()
{
int n,j,sum=0;
printf("Input n:\n");
scanf("%d",&amp;n);
for((j=2*n-1);j&gt;=1;j-=2)
{
sum+=Fact(j);
}
printf("sum=%ld\n",sum);
}
long Fact(int j)
{
int i,result=1;
for(i=1;i&lt;=j;i++)
{
result*=i;
}
return result;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c781a56e08a638ce63de684975470e/" rel="bookmark">
			从0到1的TypeScript 学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于前端人来说TypeScript应该不陌生，它的重要性不言而喻。其实本人也系统学习过TypeScript几次了，但是从来没有认真的记录过学习过程，正好因为疫情封闭在家，学习过程中正好记录下，从0到1，从简单到高级，咱们一步一步来
划重点 1. 关于any 任何类型(除了never外)跟any交集都是any本身 type A = 1 &amp; any // any type B = true &amp; any // any type C = '1' &amp; any // any 判断一个类型是any类型 type isAny&lt;T&gt; = 0 extends (1 &amp; T) ? true : false 2. 关于unknown 任何类型跟unknown交集都是其本身任何类型跟unknown并集都是unknown
- 类型unknown不能赋值给任意类型(自身以及any除外)unknown的keyof 是never =&gt; keyof unknown // never type a = 1 &amp; unknown // 1 type b = false &amp; unknown // false type c = any &amp; unknown // any type d = never &amp; unknown // never type e = string | unknown type f = boolean | unknown 如果判断一个类型是unknown类型 type isUnknown&lt;T&gt; = keyof T extends never ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c781a56e08a638ce63de684975470e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14334a1626b2bf23156c58e8e7f095a9/" rel="bookmark">
			String与byte[ ]之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下：
public class StartApplication { public static void main(String[] args) throws UnsupportedEncodingException { /* 编码：String-&gt;byte[] 调用String的getBytes() 解码：byte[]-&gt;String 调用String的构造方法 编码：字符串--&gt;字节 （看得懂的--&gt;看不懂的二进制数据） 解码：编码的逆过程 字节--&gt;字符串 (看不懂的二进制数据--&gt;看得懂) 说明：解码时，要求解码使用的字符集必须与编码时使用的字符集保持一致，否则会出现乱码 */ String str="abc123中国"; byte[] bytes=str.getBytes();//使用默认的字符集转换 System.out.println(Arrays.toString(bytes)); byte[]gbks=str.getBytes("gbk");//使用gbk字符集进行编码 System.out.println(Arrays.toString(gbks)); String str1 = new String(bytes); System.out.println(str1); String str2 = new String(gbks); System.out.println(str2);//出现乱码。原因：编码集和解码集不一致导致的 String str3 = new String(gbks,"gbk"); System.out.println(str3);//没有出现乱码。原因：编码集和解码集一致 } } 结果：
[97, 98, 99, 49, 50, 51, -28, -72, -83, -27, -101, -67]
[97, 98, 99, 49, 50, 51, -42, -48, -71, -6]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14334a1626b2bf23156c58e8e7f095a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/796c9fa833fe5dab738149be0d67f29c/" rel="bookmark">
			电脑如何调整照片尺寸大小？证件照尺寸大小怎么调？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何修改照片尺寸大小，才使它符合考试、入学等相应证件照要求呢？教大家一个在线照片尺寸修改的方法，使用压缩图图片改大小在线功能，即可在线编辑图片大小。
1、上传图片。
2、选择尺寸或自定义宽高，压缩等级输入参数。如果需要批量处理，具体操作请看：怎样把图片尺寸改小？如何批量修改图片尺寸？
3、保存图片，下载使用。
这就是照片尺寸修改的方法了，按照以上步骤就可以快速地将照片尺寸调整到合适尺寸了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434b3c44285e2ccec8e0a435584473cc/" rel="bookmark">
			Sychronized锁升级的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sychronized锁升级的过程 1、偏向锁为什么要引入偏向锁偏向锁的升级 2、轻量级锁为什么要引入轻量级锁？轻量级锁什么时候升级为重量级锁？ 回答：在JDK1.6后Java对Sychronized锁进行了升级过程，主要包含无锁状态、轻量级锁、重量级锁，主要是针对MarkWord的变化 1、偏向锁 为什么要引入偏向锁 因为经过HotSpot的作者的大量研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。
偏向锁的升级 当线程1访问同步代码块并获取锁对象时，会在Java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的thread ID），那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其他线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。
2、轻量级锁 为什么要引入轻量级锁？ 轻量级锁考虑的是竞争对象的线程不多，而且线程持有锁的时间也不长的情景。以为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放
轻量级锁什么时候升级为重量级锁？ 线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建用于存储锁记录的空间（称为DisplacedMarkWord），然后使用CAS把对象头替换为线程1存储的锁记录（DisplacedMarkWord）的地址；
如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。
但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555145bcff270661130f6510f10f21db/" rel="bookmark">
			Nginx服务管理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx服务管理与配置 前言： 我这里讲解nginx服务的安装以及配置和管理 nginx和httpd的区别是什么？ nginx不但跟httpd一样可以作为web服务，还有负载均衡的作用，处理请求上它是异步非堵塞型的，而httpd是堵塞型的。 相对httpd来说nginx是轻量级的，在高并发下 nginx 能保持低资源低消耗高性能，处理静态文件，性能比httpd高得多，它支持7层负载均衡，它还是个优秀的反向代理服务
文章目录 一、nginx安装源码安装yum/apt安装 二、nginx服务配置配置文件全局配置项目events块http块server块location块 多站点配置 三、nginx服务管理日志管理访问控制地址限制访问用户密码限制访问 nginx优化管理隐藏版本号连接超时和进程优化防盗链 一、nginx安装 nginx下载地址：http://nginx.org/download/
源码安装 1.安装依赖工具和包
#更新epel源和安装编译工具 yum install -y epel-release yum clean all &amp;&amp; yum makecache yum -y install gcc gcc-g++ make #安装依赖包 yum -y install openssl openssl-devel pcre-devel curl-devel freetype-devel 2.编译安装nginx
#添加apache用户和用户组 groupadd nginx &amp;&amp; useradd -M -s /sbin/nologin nginx -g nginx tar zxf nginx-1.21.6.tar.gz &amp;&amp; cd nginx-1.21.6 ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_stub_status_module make &amp;&amp; make install 启动服务：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/555145bcff270661130f6510f10f21db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b3303c54fba3b4fa09ffab0f7dbfdf/" rel="bookmark">
			Android 最简单实用的打开手机通知权限设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做离线的消息推送，发现oppo、vivo、小米等有些手机机型通知权限默认是关闭的，需要手动打开，网上有很多介绍怎么设置和打开的，但是发现都要适配各种版本和各大机型，太麻烦和繁琐，不是我想要的效果，于是自己整理了一个简单方便实用的方法，不多说，直接上代码：
1.封装的方法如下： /** * 打开通知权限 * * @param context */ public static void openNotificationSettingsForApp(Context context) { // Links to this app's notification settings. Intent intent = new Intent(); intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS"); intent.putExtra("app_package", context.getPackageName()); intent.putExtra("app_uid", context.getApplicationInfo().uid); // for Android 8 and above intent.putExtra("android.provider.extra.APP_PACKAGE", context.getPackageName()); context.startActivity(intent); } 2.在MainActivity使用:
NotificationManagerCompat notification = NotificationManagerCompat.from(mContext); boolean isEnabled = notification.areNotificationsEnabled(); if (!isEnabled) { toTipDialog(); } 3.完整的工具类代码如下： /** * @auth: njb * @date: 2021/7/28 10:54 * @desc: 手机通知设置工具类 */ public class NotifyManagerUtils { static long[] vibrate = {100, 200, 300, 400, 500, 400, 300, 200, 400}; /** * 打开通知权限 * * @param context */ public static void openNotificationSettingsForApp(Context context) { // Links to this app's notification settings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05b3303c54fba3b4fa09ffab0f7dbfdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537d8e9095e62c775464945fed705f14/" rel="bookmark">
			【研一小白论文精读】SwAV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unsupervised Learning of Visual Features by Contrasting Cluster Assignments The main contribution of this article is to provide an online algorithm for self-supervised learning. This method does not need to be trained on a large and complete data set, and data can be continuously added to improve its effect. In addtion, this paper also proproses a new image enhancement strategy called mult-crop. Muti-crop can intercept a small piece of the image as an enhanced samples while saving memory as much as possible.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/537d8e9095e62c775464945fed705f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabb66b6c48fd3f4c5d7e8621060eac9/" rel="bookmark">
			appium
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28df1fd3a3c440be4fff4e44a045bb36/" rel="bookmark">
			HttpMessageNotReadableException错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个比较常见的springboot小错误了，大概的意思就是前端传入的参数与后端controller接收的参数类型不匹配，json反序列化失败。
产生的原因有以下三种：
1.后端的实体类与前端的传入参数数据不一样，这时候我们可以通过检查前端传入的数据和后端接收的数据，进行比较，把他们改为相同即可。
2.我们使用@RequestBody注解，但是我们请求方式是get请求，这个时候我们要把get请求改为post请求，但是如果我们不想改动请求方式，坚持使用get请求的话，可以考虑使用@RequestParam和@PathVariable。
3.如果我们没有解决跨域问题的话，那么跨域问题也可能会导致该报错的产生，如果我们后端被@RequestBody修饰的参数实体类没有实现序列化接口，如果不序列化也会出错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23066c874e624a53bd24642d000bdb1e/" rel="bookmark">
			廖雪峰Python教程学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		廖雪峰Python教程学习笔记 Python基础数据类型和变量字符串和编码list和tuple条件判断循环dict/set字典和散列 函数用法调用函数定义函数函数参数递归函数 高级特性切片迭代列表生成式（本质：生成list）生成器（本质：生成tuple）迭代器 遗留问题 声明：
本文为学习廖雪峰Python教程时，所做个人笔记，仅供参考交流。
其他内容可见在线手册：菜鸟教程：Python基础。
Python基础 数据类型和变量 字符串，定义如 a = ‘ABC’，本质是拷贝的字符串指针给a；
a = 'ABC' b = a a = 'DEF' print(b) 输出结果：ABC
多行输入，不用\n的方法
采用'''配对的方法，示例如下：
&gt;&gt;&gt; print('''line1 ... line2 ... line3''') line1 line2 line3 默认不用\\,\t, \n等转义输出：
print(r'''I'm ok''') print('I\'m ok') f = open(r'D:\workspace\l2hc_debug\mdct.txt') 在’string’前，加个r可以强制不用转义，按字符串内容本身处理。
浮点/整数运算
整数除法： 10 // 3 =&gt; 3取余： 10 % 3 =&gt; 1其余正常都是按浮点运算进行如 3 / 2 =&gt; 1.5,结果是按浮点数运算 **的用法
放在变量前，表示多少次方，如 2.0 ** 3.0，结果为8；功能类似于C语言中的 ^符号放在参数前，表示入参为字典，如 dealit(x, **args)，第二个输入参数需为字典 小结：对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23066c874e624a53bd24642d000bdb1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49bc06aab425dd2a8e869ba248e5aa53/" rel="bookmark">
			接口自动化测试中的数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口自动化测试中的数据处理 配置文件数据的准备和记录与数据库交互进行数据替换Context环境管理方式正则 日志处理 配置文件 采用 yaml 作为配置文件，将一些重要的配置数据，如 数据库配置、host配置、相应权限的账号数据 放到 yaml文件中
conf.yaml
db_info: dbname: swiper host: 192.168.0.103 port: 3306 user: bobo pwd: hh123456 ApiHost: mockhost: http://127.0.0.1:4523/mock/894992 testhost: http://10.1.134.98:8787 prehost: http://10.1.100.10:8080 user: phonemun: 15911112223 pwd: bobo123456 封装读取配置文件
YamlHandler.py
import yaml # 读取yaml文件 class ReadYaml: def __init__(self, path, param=None): self.path = path # 文件路径 self.param = param # 不传默认获取所有数据 # 获取yaml文件中的数据 def get_data(self, encoding='utf-8'): with open(self.path, encoding=encoding) as f: data = yaml.load(f.read(), Loader=yaml.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49bc06aab425dd2a8e869ba248e5aa53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56cdaccf01f0ead11b17bbd415dd2a4/" rel="bookmark">
			有关于/,*/,**/的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		./ 当前目录。
../ 父级目录。
/ 根目录。
由于路径是相对的，所以必须有一个基准作为参照物来说明
/ 基准所在的最顶级目录即根目录，根目录是相对于其他子目录来说的
./ 基准所在的当前目录
../ 基准所在的当前目录的上一级目录（当前目录的父级目录）
具体就看(14条消息) / ./ ../相对路径详细解释_那个小白猿的博客-CSDN博客_相对路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/825749d3f5e0c8688e127425238a62a5/" rel="bookmark">
			一个python文件实现web框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现简单的web框架中接受请求和返回请求的功能, 可以用于学习网络通信
原文: HelloGitHub
githup: OneFile/web-server.py at main · 521xueweihan/OneFile · GitHub
处理连接 这里需要简单聊一下 socket 这个东西，在编程语言层面它就是一个类库，负责搞定连接建立网络通信。但本质上是系统级别提供通信的进程，而一台电脑可以建立多条通信线路，所以每一个端口号后面都是一个 socket 进程，它们相互独立、互不干涉，这也是为什么我们在启动服务的时候要指定端口号的原因。
最后，上面所说的服务器其实就是一台性能好一点、一直开着的电脑，而客户端就是浏览器、手机、电脑，它们都有 socket 这个东西（操作系统级别的一个进程）。
如果上面这段话没有看懂也不碍事，能看懂下面的图就行，得搞明白 socket 处理连接的步骤和流程，才能编写 Web 框架处理连接的部分。
下面分别展示基于 socket 编写的 server.py 和 client.py 代码。
# coding: utf-8 # 服务器端代码（server.py） import socket print('我是服务端！') HOST = '' PORT = 50007 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建 TCP socket 对象 s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 重启时释放端口 s.bind((HOST, PORT)) # 绑定地址 s.listen(1) # 监听TCP，1代表：操作系统可以挂起(未处理请求时等待状态)的最大连接数量。该值至少为1 print('监听端口：', PORT) while 1: conn, _ = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/825749d3f5e0c8688e127425238a62a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff0d612c2e783eed9e884f96e3783e7/" rel="bookmark">
			自顶向下构建中药知识图谱初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自顶向下构建中药知识图谱初探 摘要：当前，知识图谱已在金融、电商和医疗等领域开展了诸多实践性探索，并被广泛的应用在了智能问答、知识搜索、个性化推荐和辅助诊断等知识型驱动的任务中。本文从中药和知识图谱研究视角出发，对所收集中药相关数据进行预处理与实体关系抽取，自顶向下构建中药知识图谱。同时利用neo4j对部分数据进行了可视化分析。
本文目录 自顶向下构建中药知识图谱初探1、知识图谱简介2、定义中药知识图谱实体和关系3、构建中药知识图谱3.1 数据获取与预处理3.2 抽取中药实体关系三元组3.3 构建中药知识图谱 4、neo4j可视化4.1 中药知识图谱数据概述4.2 节点标签可视化4.3 关系类型可视化 5、总结 1、知识图谱简介 知识图谱最初是谷歌知识搜索功能的产品名称，现在是各类结构化知识库的统称，也是一种用图模型描述知识关联关系的技术方法。知识图谱由节点和关系组成，一般用三元组表示不同概念间的复杂关系。图1所示为“中药术语”知识图谱的部分节点关系。
图1 “中药术语”知识图谱示例 知识图谱构建主要包括自顶向下和自底向上两种方式。自顶向下构建是指在较高质量数据集中提取三元组信息并加入知识库中；而自底向上构建是指利用相关技术从一般数据集中提取可信度较高的三元组经人工审核后将其加入知识库中。知识图谱的构建过程如图2所示，包括数据获取、知识抽取、知识融合和知识加工等几方面，详细内容可参考文献[4]。
图2 知识图谱构建技术架构 2、定义中药知识图谱实体和关系 知识图谱的核心是“实体-关系-实体”三元组，为此，本文首先简要介绍一些相关的中药术语，定义需要构建中药知识图谱的主要概念，为后续中药知识图谱的构建做铺垫。
中药是以中国传统医药理论为指导，用于预防和治疗疾病的物质。中药学术语主要包括一般概念、中药采集、中药贮藏、中药鉴定、中药炮制、中药性能、中药功效、中药配伍、中药禁忌、和中药用法等10大类，每类又包含相关的多个子类层级，本文提供5级包含关系300+节点的术语图谱，其可视化效果如图3所示。
图3 “中药术语”知识图谱 该图谱svg格式获取地址：https://github.com/fengxi177/Knowlegde_Graph_TCM/tree/main/zhongyao/img_svg 从中药术语知识图谱可见，如要从中药角度深入挖掘知识是极其庞大的工程，当然其中也蕴含着诸多有价值的东西，有兴趣者可更深入探索。本文主要从中药性能和中药功效角度抽取相关信息，构建知识图谱。具体实体和关系描述如下：
实体定义：中药材（root节点）、中药名、来源、别名、分布、四气、五味、功能、主治。
关系定义：&lt;中药材, include， 中药名&gt;、&lt;中药名， from， 来源&gt;、&lt;中药名， another name， 别名&gt;、&lt;中药名, distribution area，分布&gt;、&lt;中药名, four properties，四气&gt;、&lt;中药名, five flavors，五味&gt;、&lt;中药名, functions，功能&gt;、&lt;中药名, attending，主治&gt;。
说明：该实体和关系的定义旨在学习知识图谱在中医药数据中的应用与处理，仅限自己初步研究，具体应用需根据实际情况调整。
3、构建中药知识图谱 3.1 数据获取与预处理 当前互联网资源丰富，各主题相关数据也比较多样，可根据实际需要利用相关技术爬取或人工收集。数据类型一般包括结构化、半结构化和非结构化三种数据类型。为减轻数据处理的工作量，本文通过爬虫收集中医药相关词条的半结构化数据，并对其进行清洗，获得基本实体关系的格式化数据集。
3.2 抽取中药实体关系三元组 实体抽取即命名实体识别，通常意义的命名实体识别是识别出待处理文本中三大类（实体类、时间类和数字类）、七小类（人名、机构名、地名、时间、日期、货币和百分比）命名实体。主要方法有基于规则和词典的方法、基于统计的机器学习方法（如：HMM、CRF）、基于深度学习的方法（BI-LSTM+CRF）等。
本文实体抽取属于特定领域的实体抽取任务，主要根据第2部分中实体定义，利用规则和词典获取中药实体。然后对不同来源的实体和关系进行知识融合与加工，得到最终的中药实体关系三元组。如：&lt;中药材, include， 三七&gt;。
3.3 构建中药知识图谱 对于处理的中药实体关系三元组数据，本文通过py2neo将数据存入neo4j数据库，并进行可视化展示。
demo片段如下：
创建节点
def generateGraph_Node(graph, label, name): """ 创建知识图谱节点 :param graph: Graph() :param label: 节点label :param name: 节点name :return: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ff0d612c2e783eed9e884f96e3783e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34ee5033adc2e068a3ea4f45dc744cef/" rel="bookmark">
			1.4 CentOS安装MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.4 CentOS安装MySQL
1.4.1 MySQL安装
对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了解一下什么rpm？
RPM：全称为 Red-Hat Package Manager，RPM软件包管理器，是红帽Linux用于管理和安装软件的工具。
我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下：
1). 检测当前系统是否安装过MySQL相关数据库
需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下：
rpm -qa 查询当前系统中安装的所有软件
rpm -qa | grep mysql 查询当前系统中安装的名称带mysql的软件
rpm -qa | grep mariadb 查询当前系统中安装的名称带mariadb的软件
通过rpm -qa 查询到系统通过rpm安装的所有软件，太多了，不方便查看，所以我们可以通过管道符 | 配合着grep进行过滤查询。
通过查询，我们发现在当前系统中存在mariadb数据库，是CentOS7中自带的，而这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。不卸载mariadb也没事。
2). 卸载现有的MySQL数据库【可以不做】
在rpm中，卸载软件的语法为：
rpm -e --nodeps 软件名称
那么，我们就可以通过指令，卸载 mariadb，具体指令为：
rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64
我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。
3). 将资料中提供的MySQL安装包上传到Linux并解压
A. 上传MySQL安装包
在课程资料中，提供的有MySQL的安装包 ，我们需要将该安装包上传到Linux系统的根目录 / 下面。
B. 解压到/usr/local/mysql
执行如下指令:
mkdir /usr/local/mysql
tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C /usr/local/mysql
cd /usr/local/mysql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34ee5033adc2e068a3ea4f45dc744cef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d177cfd42bb0a815a16149f7cb2272f0/" rel="bookmark">
			JavaScript 注释以及输入输出语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章地址：认识JavaScript到初体验
一、JavaScript注释 1.1 单行注释 为了提高代码的可读性，JS与CSS一样，也提供了注释功能。JS中的注释主要有两种，分别是单行注释和多行注释。
单行注释的注释方式如下：
// 我是一行文字，不想被 JS引擎 执行，所以 注释起来 // 用来注释单行文字（ 快捷键 ctrl + / ）
1.2 多行注释 多行注释的注释方式如下：
/* 获取用户年龄和姓名 并通过提示框显示出来 */ /* */ 用来注释多行文字（ 默认快捷键 alt + shift + a ）
快捷键修改为： ctrl + shift + /
vscode —&gt; 首选项按钮 —&gt; 键盘快捷方式 —&gt; 查找 原来的快捷键 —&gt; 修改为新的快捷键 —&gt; 回车确认
二、JavaScript 输入输出语句 为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：
注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。
三、总结 今天的内容就先到这里了，其他文章内容，欢迎你来学习，持续更新中。
HTML+CSS学习笔记如下（已完结）： HTML入门级
CSS入门总结CSS之emmet语法CSS的复合选择器CSS的显示模式CSS背景CSS三大特性CSS盒子模型及PS基础CSS之圆角CSS之浮动知识点汇总CSS前端基础了解PS切图CSS属性书写顺序（重点）CSS练手之学成在线页面制作CSS定位的4种分类CSS综合案例：学成在线模块添加HTML+CSS之定位（position）的应用HTML+CSS案例：淘宝轮播图CSS之元素的显示与隐藏HTML+CSS综合案例：土豆网鼠标经过显示遮罩【重点】CSS之精灵图CSS字体图标CSS三角以及京东三角案例CSS用户界面样式源码CSS之vertical-align 属性应用CSS：溢出的文字省略号显示CSS常见布局技巧+案例面试的时候你能说出几个HTML5的新特性？已完结 HTML+CSS项目《品优购》完整笔记+源码（万字版可复制）： 1HTML+CSS大项目1：品优购项目笔记+源码（万字收藏）2HTML+CSS大项目2：品优购项目笔记+源码（万字收藏） 移动开发笔记（更新中） 移动WEB开发之入门&amp;视口移动WEB开发之二倍图移动端web开发主流方案选择移动WEB开发之flex布局附携程网首页案例制作移动WEB开发之rem基础&amp;媒体查询移动WEB开发之less基础移动Web开发之rem实际开发适配方案更新中... .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d177cfd42bb0a815a16149f7cb2272f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28ceb3921977a6901070b35caa47a2c/" rel="bookmark">
			2021综述：计算机视觉中的注意力机制(续四）：分支注意力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.5 Branch Attention Branch attention 可以看成是一种动态的分支选择机制：要注意哪个，与多分支结构一起使用。
3.5.1 Highway networks 受长短期记忆网络的启发，Srivastava等人提出了高速公路网络，该网络采用自适应选通机制，使信息能够跨层流动，以解决训练非常深层网络的问题。
假设一个普通的神经网络由 L L L层组成， H l ( X ) H_{l}(X) Hl​(X)表示第 l l l层的非线性变换，高速公路网络可以表示为
Y l = H l ( X l ) T l ( X l ) + X l ( 1 − T l ( X l ) ) T l ( X ) = σ ( W l T X + b l ) \begin{aligned} Y_{l} &amp;=H_{l}\left(X_{l}\right) T_{l}\left(X_{l}\right)+X_{l}\left(1-T_{l}\left(X_{l}\right)\right) \\ T_{l}(X) &amp;=\sigma\left(W_{l}^{T} X+b_{l}\right) \end{aligned} Yl​Tl​(X)​=Hl​(Xl​)Tl​(Xl​)+Xl​(1−Tl​(Xl​))=σ(WlT​X+bl​)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d28ceb3921977a6901070b35caa47a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fbcd578247c026fd7c8bd01ac31f2a/" rel="bookmark">
			with root cause org.springframework.expression.spel.SpelEvaluationException* field ‘records‘ cannot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前端同一个html页面被后台不同的控制访问时，可能因为不同的控制器传的参数不同，导致报错，需要在可能没有传参数的参数上添加问号?
1、 前言 1.1 idae中spring boot项目使用thymeleaf模板，前端HTML页面获取后台Controller中的Model存放的数据
1.2 项目在登录后跳转到后台显示查询到数据库数据的页面（首先是还没有查询，需要进入页面后点击按钮才去查询并显示）
1.3 这里就直接报错误了，最开始我只能通过把查询到的数据显示到页面（就是刚刚登录成功，就跳转去查询数据）的方式解决错误，后面我发现一个好玩的方法，在这里介绍一下。
2、 错误信息 2.1主要错误
2021-11-20 20:40:36.536 ERROR 10352 — [nio-8082-exec-4] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: “class path resource [templates/main.html]”)] with root cause
org.springframework.expression.spel.SpelEvaluationException: EL1007E: Property or field ‘records’ cannot be found on null
at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:213) ~[spring-expression-5.3.12.jar:5.3.12]
2.2其他的小错误
The operator ‘SUBTRACT’ is not supported between objects of type ‘null’ and ‘java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69fbcd578247c026fd7c8bd01ac31f2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ec27585a507aa70c510b2fed5d05f96/" rel="bookmark">
			mybatis使用xml文件进行模糊查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要知道在原本的sql中语句是什么样子的
那么我们在书写语句是就往这个方向去制作。
在从网页接受到字符串后对其进行修改操作
修改完成之后就是正常的搜索操作即可
下面是dao层代码
下面是xml中的代码
这样就完成了可以当作一般的查询语句进行一系列操作了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afec91bbda1c355022d36f716d6e7d12/" rel="bookmark">
			初步认识一下BeanDefinitionRegistryPostProcessor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，咱们来看一下BeanDefinitionRegistryPostProcessor的源码，如下图所示。
从该接口的名字中，我们大概能知道个一二，说它是bean定义注册中心的后置处理器并不过分。而且，从该接口的源码中我们也可以看出，它是BeanFactoryPostProcessor旗下的一个子接口。
我们还能看到，它里面定义了一个方法，叫postProcessBeanDefinitionRegistry，那么问题来了，它是什么时候执行的呢？我们可以看一下它上面的详细描述，说的是啥呢，说的是在IOC容器标准初始化之后，允许我们来修改IOC容器里面的bean定义注册中心。此时，所有合法的bean定义将要被加载，但是这些bean还没有初始化完成。
说人话就是，postProcessBeanDefinitionRegistry方法的执行时机是在所有bean定义信息将要被加载，但是bean实例还未创建的时候。 这句话听起来，总感觉BeanDefinitionRegistryPostProcessor是在BeanFactoryPostProcessor前面执行的，真的是这样吗？确实是这样。为什么呢？BeanFactoryPostProcessor的执行时机是在所有的bean定义信息已经保存加载到BeanFactory中之后，而BeanDefinitionRegistryPostProcessor却是在所有的bean定义信息将要被加载的时候，所以，BeanDefinitionRegistryPostProcessor就应该要先来执行。接下来，我们就写一个实践案例来验证一番。
案例实践 首先，编写一个类，例如MyBeanDefinitionRegistryPostProcessor，它应要实现BeanDefinitionRegistryPostProcessor这个接口。
package com.baidu.bean; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.support.AbstractBeanDefinition; import org.springframework.beans.factory.support.BeanDefinitionBuilder; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor; import org.springframework.stereotype.Component; // 记住，我们这个组件写完之后，一定别忘了给它加在容器中 @Component public class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { // TODO Auto-generated method stub System.out.println("MyBeanDefinitionRegistryPostProcessor...bean的数量：" + beanFactory.getBeanDefinitionCount()); } /** * 这个BeanDefinitionRegistry就是Bean定义信息的保存中心，这个注册中心里面存储了所有的bean定义信息， * 以后，BeanFactory就是按照BeanDefinitionRegistry里面保存的每一个bean定义信息来创建bean实例的。 * * bean定义信息包括有哪些呢？有这些，这个bean是单例的还是多例的、bean的类型是什么以及bean的id是什么。 * 也就是说，这些信息都是存在BeanDefinitionRegistry里面的。 */ @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { // TODO Auto-generated method stub System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afec91bbda1c355022d36f716d6e7d12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf5496a476fb93560a1fd64b3f5770d6/" rel="bookmark">
			C&#43;&#43; 高效的遍历opencv Mat像素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、直接获取Mat对象的data数据的指针代码如下：耗时如下： 二、再看看行优先和列优先遍历的耗时行优先代码如下：耗时如下：列优先代码如下：耗时如下： 三、总结 前言 在文章https://blog.csdn.net/weixin_44901043/article/details/120047996?spm=1001.2014.3001.5502 中，从内存存储上，分析了行优先遍历和列优先遍历方式效率差别，得出行优先遍历的方式比列优先效率快的结论。在该文中，采用的是Mat对象提供的at()函数通过行列索引方式遍历每个像素值。当然还有更加快速的遍历方式。
一、直接获取Mat对象的data数据的指针 代码如下： //构造一个7000*7000大小的Mat cv::Mat matKernel = cv::Mat::zeros(7000, 7000, CV_32F); //循环10次 int nums = 10; while (nums) { double t = (double)cv::getTickCount(); for(int i = 0; i &lt; matKernel.rows; i++) { float *pt = (float*)matKernel.data + i * matKernel.step/4; for(int j = 0; j &lt; matKernel.cols; j++) { *(pt++) = 255; } } t = ((double)cv::getTickCount() - t) / cv::getTickFrequency()*1000; //获得时间，单位是毫秒 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf5496a476fb93560a1fd64b3f5770d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92b9bfeb24307a9f9bd5f1755db68ed/" rel="bookmark">
			微信开发者工具-project.config.json配置详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目配置文件 项目根目录中的 project.config.json 和 project.private.config.json 文件可以对项目进行配置，project.private.config.json 中的相同设置优先级高于 project.config.json可以在 project.config.json 文件中配置公共的配置，在 project.private.config.json 配置个人的配置，可以将 project.private.config.json 写到 .gitignore 避免版本管理的冲突。project.private.config.json 中有的字段，开发者工具内的设置修改会优先覆盖 project.private.config.json 的内容。如在 project.private.config.json 有 appid 字段，那么在 详情-基本信息 中修改了 appid，会写到 project.private.config.json 中，不会覆盖掉 project.config.json 的 appid 字段的内容开发阶段相关的设置修改优先同步到 project.private.config.json 中，与最终编译产物有关的设置无法在 project.private.config.json 中生效 一级字段 字段名类型说明miniprogramRootPath String指定小程序源码的目录(需为相对路径)qcloudRootPath String指定腾讯云项目的目录(需为相对路径)pluginRootPath String指定插件项目的目录(需为相对路径)cloudbaseRootPath String云开发代码根目录(需为相对路径)cloudfunctionRootPath String云函数代码根目录(需为相对路径)cloudfunctionTemplateRootPath String云函数本地调试请求模板的根目录(需为相对路径)cloudcontainerRootPath String云托管代码根目录(需为相对路径)compileTypeString编译类型settingObject项目设置libVersionString基础库版本appidString项目的 appid，只在新建项目时读取projectnameString项目名字，只在新建项目时读取packOptionsObject打包配置选项debugOptionsObject调试配置选项watchOptionsObject文件监听配置设置scriptsObject自定义预处理staticServerOptionsObject仅在小游戏项目中有效 compileType 编译类型作用于开发工具的以下设置
名字说明miniprogram当前为普通小程序项目plugin当前为小程序插件项目 setting 项目的编译设置，可以指定以下设置。部分设置无法在 project.private.config.json 中生效
以下字段可以开发者工具-详情-本地设置可以对应上
字段名类型允许私有设置[1]说明es6Boolean否是否启用 es6 转 es5[2]enhanceBoolean否是否打开增强编译[2]postcssBoolean否上传代码时样式是否自动补全minifiedBoolean否上传代码时是否自动压缩脚本文件minifyWXSSBoolean否上传代码时是否自动压缩样式文件minifyWXMLBoolean否上传代码时是否自动压缩 WXML 文件uglifyFileNameBoolean否上传时进行代码保护ignoreUploadUnusedFilesBoolean否上传时是否过滤无依赖文件autoAuditsBoolean是是否自动运行体验评分urlCheckBoolean是是否检查安全域名和 TLS 版本compileHotReLoadBoolean是是否开启文件保存后自动热重载preloadBackgroundDataBoolean是小程序加载时是否数据预拉取lazyloadPlaceholderEnableBoolean是是否启用懒注入占位组件调试[3]useStaticServerBoolean是仅在小游戏项目有效，是否开启静态资源服务器[4] 以下字段是开发者工具的隐式设置
字段名类型允许私有设置[1]说明babelSettingObject否增强编译下Babel的配置项useCompilerPluginsString[] 或 false否编译插件配置disableUseStrictBoolean否将 JS 编译成 ES5 时，是否禁用严格模式uploadWithSourceMapBoolean否上传时是否带上 sourcemap（默认为true）localPluginsBoolean否在小游戏插件项目中，是否启用 “以本地目录为插件资源来源”[5] 特性packNpmManuallyBoolean否是否手动配置构建 npm 的路径packNpmRelationListArray否仅 packNpmManually 为 true 时生效，详细参考构建 npm 文档coverViewBoolean是是否使用工具渲染 CoverViewignoreDevUnusedFilesBoolean是预览、真机调试和本地模拟器等开发阶段是否过滤无依赖文件（默认为true）checkInvalidKeyBoolean是是否展示 JSON 文件校验错误信息showShadowRootInWxmlPanelBoolean是是否开启调试器 WXML 面板展示 shadow-rootuseIsolateContextBoolean是是否开启小程序独立域调试特性[6]useMultiFrameRuntimeBoolean是是否开启模拟器预先载入小程序的某些资源[7]。此设定为 false 时会导致 useIsolateContext 失效useApiHookBoolean是是否启用 API Hook 功能[8]useApiHostProcessBoolean是是否在额外的进程处理一些小程序 API[9]useLanDebugBoolean是仅在小游戏有效，是否开启局域网调试服务器enableEngineNativeBoolean是是否在游戏引擎项目中开启支持引用 node 原生模块的底层加速特性showES6CompileOptionBoolean是是否在本地设置中展示传统的 ES6 转 ES5 开关（对应 es6），增强编译开关 （对应 enhance） 注 1: 开发阶段相关的设置修改优先同步到 project.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b92b9bfeb24307a9f9bd5f1755db68ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acfb61c6db9fa1962489f2589fccb793/" rel="bookmark">
			Gitea：私有部署Git托管服务(私有Git仓)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
git和Gitea简介
服务端部署
部署环境概览
创建操作系统用户
下载并解压
修改初始配置
git和Gitea简介 git 是一个开源的分布式版本控制系统，用途类使用SVN的版本控制和多人协同，但不同于SVN的是，git在设计之初即是分布式。
基于git版本控制技术，出现了github、gitlab等托管平台，不过这些托管平台是对公网服务。而Gitea 是一个可自己私有部署，自行托管的Git服务程序。他和GitHub, Bitbucket or Gitlab等比较类似。他是从 Gogs 发展而来。
本文通过Gitea在私有服务器环境搭建git的自有托管平台（私有化部署）
服务端部署 部署环境概览 Linux服务器
IP：20.200.54.51
已经安装git 1.8.3.1软件。
（若无则通过yum install git 安装）
gitea版本
gitea-1.16.6-linux-amd64
https://dl.gitea.io/gitea/1.16.6/gitea-1.16.6-linux-amd64
gitea运行用户
操作系统用户：gitea
为了规范和权限隔离，建立专门用户
gitea数据库
"postgres://gitea@20.200.54.51/giteadb"
数据库创建见后文
gitea仓存放目录
/app/gitea/data/gitea-repositories
服务端所有仓存放的基目录
gitea Web界面
http://20.200.54.51:3000
内部使用，不启用HTTPS
准备数据库（PostgreSQL）
Gitea需要使用数据库用于保存用户、权限、工程、评论、通知、任务等信息。
可以选择MySQL或PostgreSQL 其一即可。本节以PostgreSQL 10.5为例。
1、安装PostgreSQL服务端软件（过程略）
2、通过psql客户端登录，创建gitea专用的数据库连接用户
CREATE ROLE gitea WITH LOGIN PASSWORD 'gitea';
3、通过psql客户端登录，创建database和schema
CREATE DATABASE giteadb WITH OWNER gitea ENCODING UTF8 LC_COLLATE 'zh_CN.UTF-8' LC_CTYPE 'zh_CN.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acfb61c6db9fa1962489f2589fccb793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547cce5c656200517e2409df537c3fb1/" rel="bookmark">
			系统滚动条样式优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		::-webkit-scrollbar 滚动条整体部分 ::-webkit-scrollbar-thumb 滚动条里面的小方块，能上下左右移动(取决于是垂直还是水平) ::-webkit-scrollbar-track 滚动条的轨道(里面装有thumb) ::-webkit-scrollbar-button 滚动条轨道两端的按钮，允许通过点击微调小方块的位置 ::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分(除去) ::-webkit-scrollbar-corner 边角，及两个滚动条的交汇处 ::-webkit-resizer 两个滚动条的交汇处上用于拖动调整元素大小的小控件 样式一
::-webkit-scrollbar-track-piece { -webkit-border-radius: 0 } ::-webkit-scrollbar { width: 5px; height: 10px } ::-webkit-scrollbar-thumb { height: 50px; background-color: #b8b8b8; -webkit-border-radius: 6px; outline-offset: -2px; filter: alpha(opacity = 50); -moz-opacity: 0.5; -khtml-opacity: 0.5; opacity: 0.5 } ::-webkit-scrollbar-thumb:hover { height: 50px; background-color: #878987; -webkit-border-radius: 6px } 样式二
::-webkit-scrollbar{width: 1px;height: 1px;background-color: #d9d9d9;} /*定义滚动条轨道 内阴影+圆角*/ ::-webkit-scrollbar-track{-webkit-box-shadow: inset 0 0 1px rgba(0,0,0,0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/547cce5c656200517e2409df537c3fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e4d8f2013f09682b39136cf7f8d8bd7/" rel="bookmark">
			数电基础知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、逻辑门二、卡诺图化简1.引入库2.读入数据 总结 提示：以下是本篇文章正文内容，下面案例可供参考
一、逻辑门 二、卡诺图化简 1.引入库 代码如下（示例）：
import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import warnings warnings.filterwarnings('ignore') import ssl ssl._create_default_https_context = ssl._create_unverified_context 2.读入数据 代码如下（示例）：
data = pd.read_csv( 'https://labfile.oss.aliyuncs.com/courses/1283/adult.data.csv') print(data.head()) 该处使用的url网络请求的数据。
总结 提示：这里对文章进行总结：
例如：以上就是今天要讲的内容，本文仅仅简单介绍了pandas的使用，而pandas提供了大量能使我们快速便捷地处理数据的函数和方法。
改变字体颜色：
浅红色文字：浅红色文字：
深红色文字：深红色文字
浅绿色文字：浅绿色文字
深绿色文字：深绿色文字
改变字体大小：
size为1：size为1
size为2：size为2
size为10：size为10
改变字体背景：
highlight 2
背景色的设置是按照十六进制颜色值：#7FFFD4 背景色的设置是按照十六进制颜色值：#FF83FA 背景色的设置是按照十六进制颜色值：#D1EEEE 背景色的设置是按照十六进制颜色值：#C0FF3E 背景色的设置是按照十六进制颜色值：#54FF9F 改变字体：
我是黑体字
我是宋体字
我是微软雅黑字
我是fantasy字
我是Helvetica字
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bfe90f7ad1b395411dcb4112a6275ef/" rel="bookmark">
			Go语言-HTTP编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1、服务器配置
2、客户端配置
3、请求方法
4、panic宕机恢复
5、模板
6、MYSQL
前言 Go原生支持http，直接使用import("net/http")即可，http服务性能和nginx非常接近，都具备高并发支持的能力，代码实现起来比较简单。
1、服务器配置 package main import ( "fmt" "net/http" ) //HTTP服务端配置 //业务请求相应处理 func hello(res http.ResponseWriter, req *http.Request) { fmt.Println("hello") fmt.Fprintln(res, "&lt;h1&gt;welcome&lt;/h1&gt;") } func main() { //路由到指定站点位置跳转相关函数处理 http.HandleFunc("/", hello) err := http.ListenAndServe("127.0.0.1:8088", nil) if err != nil { fmt.Println("启动监听失败,err:", err) return } } 启动服务端
这时候用浏览器验证
2、客户端配置 package main import ( "fmt" "io/ioutil" "net/http" ) //http客户端配置 func main() { /* http.Get() 传入值为 url，是string类型 返回值有两个， 一个是请求，结构体类型，该结构体的Body字段是一个接口 第二个是err */ //在Get函数中，放入完整合格域名(FQDN) res, err := http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bfe90f7ad1b395411dcb4112a6275ef/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/155/">«</a>
	<span class="pagination__item pagination__item--current">156/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/157/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>