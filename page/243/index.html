<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92fa75c601492a91a56b0d35d8d08c71/" rel="bookmark">
			js之深拷贝与浅拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、拷贝是什么? 从生活中理解,拷贝就是用u盘中复制一份文件到电脑中,或者是将某个文件夹的快捷方式发到桌面上。
拷贝分为两种
浅拷贝深拷贝 二、产生浅拷贝与深拷贝的原因 浅拷贝就是类似于将一个文件夹的快捷方式发送到桌面上,无论是从桌面上打开还是从路径中打开都是对同一个文件夹的操作。
1)从js理解,因为js有基本类型和引用类型之分。
基本类型存放在栈内存中引用类型放在堆内存中
当我们调用一个变量时,实际上是在栈内存中查询该变量, 此时堆内存中的引用类型将地址放在栈内存中。如果我们调用该引用类型,是在栈内存中查找该地址,然后根据对应的地址去调用堆内存中的数据 2)正因为引用类型是放在堆内存中,地址放在栈内存中才有了深拷贝与浅拷贝。所以将一个引用类型直接赋值给另一个变量,只是将栈内存中的地址复制,对堆内存中的数据并未进行任何实质性的操作。
三、解决浅拷贝的办法 1、手动赋值
let obj = { username:'wz', age:'18', sex:'male' } //浅拷贝 let obj2 = obj //深拷贝 let obj2 = { username:obj.username, age:obj.age, sex:obj.sex } 2.递归算法
let arr = [] console.log(recurrence(obj)); function recurrence(data) { Object.keys(data).forEach(item =&gt; { if (typeof data[item] === "object") { return recurrence(data[item]) } arr.push(data[item]) }) return arr } 3、JSON转换
//该方法利用的是JSON.parse(JSON.stringify(obj)) //我对于该方法的理解是利用json格式对于字符串和对象实现灵活的转换 该方法是存在坑点的,我总结一下
obj有时间对象 =&gt; 转换后将还是字符串类型(很好理解,json只能实现字符串和对象转换)obj有函数 =&gt; 转换后函数将是undefined(理由同上) 以下的丢失我并不是太理解,但还是写下吧
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92fa75c601492a91a56b0d35d8d08c71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3b1ff8928e6042689eaa54f22b193cc/" rel="bookmark">
			课程设计心得_关于switch输入字母进入死循环问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做C语言课程设计时，采用了大量的switch，在后期找bug时，当输入字符类型时，如a，*，+之类的，程序进入了死循环，但又不想换成其他的（主要是懒，不想大量改动）
void menu_windows() { int n; system("cls"); fflush(stdin); printf("\n"); printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"); printf("***********************[图书管理系统]***********************\n"); printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"); printf("\n [1.管理员入口] \n"); printf("\n [2.读者入口] \n"); printf("\n [3.退出系统] \n\n"); printf("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"); printf("\n\t[请选择]\t·"); scanf("%d",&amp;n); switch(n) { case 1: login_windows(); break;//管理员登录窗口 case 2: reader_loginwindows(); break;//读者登录窗口 case 3: exit(0); break;//退出系统 default: printf("\t\t输入有误!\n"); Sleep(1000); menu_windows(); break; } } 所以上网查了一下，scanf函数是从缓冲区接受数值，而当我们输入字母或其他时，字符就一直留在缓冲区，再次循环，scanf再从缓冲区获取时还是字母，就相当跳过了scanf这一句，从而造成死循环。
经过测试后发现，只要把接受输入的变量定义在while循环里面，并给该变量赋值，在scanf之前清空缓冲区，这样程序就可以正常运行了。
即加入fflush(stdin); //清理缓冲区
void menu_windows() { int n; system("cls"); fflush(stdin);//清理缓冲区 fflush(stdin); printf("\n"); printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"); printf("***********************[图书管理系统]***********************\n"); printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"); printf("\n [1.管理员入口] \n"); printf("\n [2.读者入口] \n"); printf("\n [3.退出系统] \n\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3b1ff8928e6042689eaa54f22b193cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be46ba335dfeb43a2c0e7f9bc15cbcb/" rel="bookmark">
			springboot全局异常处理中的404的/error重复拦截问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：
GlobalExceptionHandler.java类中的@ControllerAdvice注解只处理经过Controller的不经过Controller的不进行处理 SpringBoot 默认提供了一个全局的 handler 来处理所有的 HTTP 错误, 并把它映射为 /error。当发生一个 HTTP 错误, 例如 404 错误时, SpringBoot 内部的机制会将页面重定向到 /error 中。 在springboot1.x与springboot2.x中，都可以直接使用@ControllerAdvice即可
对于404的请求：
在springboot1.5.10中，当存在请求没有controller匹配请求后404，同时会直接重定向/error，这个时候我们可以直接判断request中的uri是否包含/error，如果有抛出异常，再有@ControllerAdvice处理即可。
对于springboot2.0问题来了，当404时，不仅会请求/error，原始请求也会来一次!!!。这时候如果有拦截器，则会拦截两次，比如请求/api/test，会拦截一次，404后，重定向到/api/error，会再拦截一次
这时候不能直接简单的拦截/error来，这时候需要关闭工程中的资源文件建立映射
spring.resources.add-mappings=false 也可以
#出现错误时, 直接抛出异常 spring.mvc.throw-exception-if-no-handler-found=true #关闭工程中的资源文件建立映射 spring.resources.add-mappings=false 这时候，就会抛出异常，再在@ControllerAdvice中捕获NoHandlerFoundException异常即可
参考：
springboot2.0 https://blog.csdn.net/qq_42511800/article/details/85113235
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683e0952b56f40776deb330d619eced2/" rel="bookmark">
			find_library
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		find_library
#在指定目录下搜索一个库, 保存在变量MY_LIB中
find_library(MY_LIB libmylib.a ./)
#链接这个库
target_link_libraries(${PROJECT_NAME} ${MY_LIB})
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57e913e593cfadfde8ba9e6ea16d7a8c/" rel="bookmark">
			适合Python入门的5本基础书籍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 3标准库
对程序员而言，标准库与语言本身同样重要，它好比一个百宝箱，能为各种常见的任务提供完美的解决方案，所以本书是所有Python程序员都必备的工具书！全书以案例驱动的方式讲解了标准库中数百个模块的使用方法（如何工作）和工作原理（为什么要这样工作），比标准库的官方文档更容易理解，为Python程序员熟练掌握和使用这些模块提供了绝佳指导。
Effective Python：编写高质量Python代码的59个有效方法
以使用场景为主导的精练教学方式，汇聚了59条优秀的实践原则、开发技巧和便捷方案，并以实用的代码范例来解释它们。通过本书，你能够了解到解决关键编程任务所用的最佳方式，并学会编写易于理解、便于维护且利于改进的代码。
Python学习手册 第4版
《Python学习手册（第4版）》，Python入门必读之作，位列美亚软件编程畅销榜首，《Python编程》姊妹篇，详细讲解各种语言特性。本书全面、系统讲解Python语言核心知识，每个知识都会以知识点、思想、示例代码的方式详细展开，由浅入深，循序渐进。无论你从事哪个领域，本书都为你提供了未来全部Python工作的必备知识。
Python程序设计（原书第2版）
本书介绍Python的基础知识，旨在帮助学生首先掌握概念，之后通过步骤完备的实例培养学生的问题求解能力。这一版采用Python3，并对全书结构进行了优化，既可作为入门程序设计课的入门教材，也可供Python爱好者自学参考。
Python程序设计基础
本书旨在教会读者如何使用Python语言进行程序设计以及解决问题。书中配有大量浅显易懂的实例、伪代码、流程图，各章还附有学习案例，旨在通过逐步解析的方式帮助读者掌握解决问题的方法。
Python学习扣QUN：⑧⑤⑤-④零⑧-⑧⑨③从零基础开始到Python各领域的项目实战教程、开发工具与电子书籍。与你分享企业当下对于python人才需求及学好python的高效技巧，不停更新最新教程！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a846e46300f49bcf93ba37004b677cd/" rel="bookmark">
			Docker带ce和不带ce的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker带ce和不带ce的区别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd19cc1471c98d066a10c6c4a1b2a7c/" rel="bookmark">
			VUE使用el-ui关于el-form-item使用required的英文提示问题（VUE专题一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在vue的&lt;el-form&gt; 标签中，&lt;el-form-item &gt; required属性，会出现英文提示，这个时候需要自定义rules，写对应的需要校验的字段，
如果没有使用rules定义，会提示英文提示，这个时候只需要自己写校验，然后在&lt;el-form-item &gt;标签上的 prop属性去掉，则英文提示就
不在提示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb03b1c2243f208f8ec5468e1790798/" rel="bookmark">
			Java –生成范围内的随机整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，我们将向您展示三种生成范围内随机整数的方法。 java.util.Random.nextInt 数学随机 java.util.Random.ints（Java 8） 1. java.util.Random 此Random().nextInt(int bound)生成一个从0（含）到bound（ Random().nextInt(int bound)的随机整数。 1.1代码段。 对于getRandomNumberInRange(5, 10) ，这将生成一个介于5（含）和10（含）之间的随机整数。 private static int getRandomNumberInRange(int min, int max) { if (min &gt;= max) { throw new IllegalArgumentException("max must be greater than min"); } Random r = new Random(); return r.nextInt((max - min) + 1) + min; } 1.2什么是（max – min）+ 1）+ min？ 上面的公式将在min（含）和max（含）之间生成一个随机整数。 //Random().nextInt(int bound) = Random integer from 0 (inclusive) to bound (exclusive) //1. nextInt(range) = nextInt(max - min) new Random().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfb03b1c2243f208f8ec5468e1790798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d627dbca3e64d7fab93dd7371ed46021/" rel="bookmark">
			条件概率、联合概率和贝叶斯公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概率：
概率的本质是寻找随机性背后的规律，通常用公式：
P（A）=随机事件A所包含的单位事件的数量/随机变量空间所包含所有单位事件的数量
任何一个随机时间，随机事件A都是随机事件总集合里的一个子集。
如下图集合O代表所有单位事件的数量f(O)，A、B代表两个不同随机事件的单位事件数量f(A)、f(B)，则：
P（A）=f(A)/f(O)
P（B）=f(B)/f(O)
假设凤凰新闻网今天有100篇新闻，有50篇娱乐新闻，20篇体育新闻，30篇军事新闻，则今天军事新闻的概率是30/100=30%，体育新闻的概率则是20/100=20%。
二、条件概率：
条件概率是指限定在随机事件A的条件下，随机事件B发生的概率。假设随机事件A出现的次数为f(A)，限定在A事件条件下同时出现事件B的次数为f(C)，则条件概率为f(C)/f(A)。
用公式P(B|A)=f(A∩B)/f(A)表示。
注：P(B|A)=f(A∩B)/f(A)=f(C)/f(A)=P(C)/P(A)
假如凤凰新闻今天有100篇新闻，国际新闻有50篇，科技新闻有30篇，国际新闻中有科技新闻10篇，则在国际新闻中出现科技新闻的概率是10/50=20%，在科技新闻中出现国际新闻的概率是10/30=33.33%。
三、联合概率：
在随机事件集合O中，我们现在有随机事件A，随机事件B，如果事件C需要随机事件A与随机事件B同时发生（C⊆A∩B），则随机事件C发生的概率叫联合概率。
用公式P(B,A)= f(A∩B)/f(O)=P(C)表示。
假如凤凰新闻今天有100篇新闻，国际新闻有50篇，科技新闻有30篇，同时是国际新闻、科技新闻类别的新闻有10篇，则同属国际新闻、科技新闻的新闻概率是10/100=10%。
四、如何把联合概率公式、条件概率公式变成贝叶斯公式
A和B一同发生的概率的联合概率：
P(B,A)
= f(A∩B)/f(O)
= f(A∩B)/f(A) * f(A)/f(O)
=P(B|A) * P(A)
注：可以理解成A和B一同发生的概率，就是A发生的概率，乘以在A条件下B发生的概率。
因此同理我们可以推导出公式：
P(A,B)= P(A|B) * P(B)
在数学上条件和结果是可以互换的，如在新闻分类中，我们可以说国际新闻中的科技新闻有X篇，也可以说科技新闻中有国际新闻X篇，只要调换一下方向就可以了，也就是：
P(B,A)= P(A,B)=P(C)
推导重要公式：P(B|A) * P(A) = P(A|B) * P(B)
在这个公式中，如果我们知道了其中三个因子，就能求出第四个。通常来讲，两个条件概率P(A和P(B)是容易求的。另外两个条件概率，一个是A条件下B的概率，一个是B条件下A的概率，常常一个比较容易得到，另一个比较难得到。所以，我们常常从容易得到的条件概率，推导出难得到的概率。这就是著名的贝叶斯公式：
P(A|B) = P(B|A) * P(A) / P(B)
五、贝叶斯公式有什么用？
5.1、继续用我们前面新闻的例子：
假如我们现在知道凤凰新闻今天的国际新闻占比是50%，科技新闻的占比是30%，且国际新闻中有20%是科技新闻，那么请问科技新闻中国际新闻的占比是多少？
我们用贝叶斯公式来推导：
P(国际新闻|科技新闻)
=P(科技新闻|国际新闻) * P(国际新闻) / P(科技新闻)
=20% * 50% / 30%
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d627dbca3e64d7fab93dd7371ed46021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e8252a66d706f5bc7660af7239e47e/" rel="bookmark">
			为什么判断一个数是否为素数时只需开平方根就行了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为如果它不是质数，那么它一定可以表示成两个数（除了1和它本身）相乘，这两个数必然有一个小于等于它的平方根。只要找到小于或等于的那个就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ba98ee3c9c9edff2c0c801c5f210fa/" rel="bookmark">
			quill-editor的使用和自定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的项目中有很多地方要用到，所以我封装了一个组件
1.安装vue-quill-editor
npm install vue-quill-editor -S
2.安装vue-quill-editor
npm install quill -S
安装后在main.js中引入
import 'quill/dist/quill.core.css' import 'quill/dist/quill.snow.css' import 'quill/dist/quill.bubble.css' import VueQuillEditor from 'vue-quill-editor' Vue.use(VueQuillEditor) 3.安装vue-quill-editor-upload 因为我用到图片上传服务器，如果使用他的可以不用安装
vue-quill-editor-upload
安装后要引入组件、注册组件
import {quillRedefine} from 'vue-quill-editor-upload' components:{ quillRedefine }, 一下是封装好的quill-editor组件
&lt;template&gt; &lt;div class="edit_container"&gt; &lt;quill-editor v-model="content" ref="myQuillEditor" :options="editorOption" @blur="onEditorBlur($event)" @focus="onEditorFocus($event)" @change="onEditorChange($event)"&gt; &lt;/quill-editor&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; /*富文本编辑图片上传配置*/ const uploadConfig = { action: 'common.uploadfile.single', // 必填参数 图片上传地址 methods: 'POST', // 必填参数 图片上传方式 token: '', // 可选参数 如果需要token验证，假设你的token有存放在sessionStorage name: 'img', // 必填参数 文件的参数名 size: 1024, // 可选参数 图片大小，单位为Kb, 1M = 1024Kb accept: 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon' // 可选 可上传的图片格式 }; import {quillRedefine} from 'vue-quill-editor-upload' export default { components:{ quillRedefine }, name: 'App', props: { value: { type: String, default: '', } }, data(){ return { content: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54ba98ee3c9c9edff2c0c801c5f210fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26e7b666fbd346b073facdb086e4e23/" rel="bookmark">
			自建spring cloud遇到的问题（2）—— shut down of DiscoveryClient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Spring Cloud 下创建好eureka 注册中心及其客户端，当客户端进行启动时，启动失败，究其原因为缺少依赖，需要添加
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18514f87d9366c0f57af5efb4bc96e64/" rel="bookmark">
			FPGA设计-时序约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近都在做ARM的方面学习工作，感觉有必要记录下来之前FPGA的工作，好记性也不如烂笔头；说起FPGA，断断续续的也用过4，5年了，中间接触过DSP，就是因为没有记录文档资料，目前几乎快忘光了；FPGA方面的心得，将会由以下几个方面进行总结：
1. FPGA时序约束以及高速ADC约束实例
2. TDC进位延时链设计以及研究
3. TDC的精度以及自动校正算法的实现
STA：Static Timing Analysis STA（Static Timing Analysis，即静态时序分析）在实际FPGA设计过程中的重要性是不言而喻的，其作用是：
1. 帮助分析和验证一个FPGA设计的时序是否符合要求；
2. 指导fitter（布线综合器）布局布线出符合要求的结果；
简单地说，静态时序分析（STA）告诉我们电路的实际表现如何，而提供约束（SDC文件，即上面的要求）来告诉分析工具我们希望电路的表现应该是怎样。Quartus II自带的STA工具TimeQuest TA在整个FPGA设计过程中的使用流程如下图所示：
图 1 TimeQuest TA使用流程
简而言之，我们需要学会：
A． 正确理解时序，看背景知识介绍
B． 正确编写SDC文件，以及利用TimeQuest TA生成SDC约束命令，SDC介绍
C． 利用TimeQuest TA来查看和验证时序
一、 背景知识介绍： 1.1 启动沿（launch）和锁存沿（latch）： 图 2 启动沿和锁存沿
启动沿：数据被launch的时钟边沿；也就是说，每一个启动沿，一般都会产生一个新的数据！
锁存沿：数据被latch的时钟边沿；也就是说，每一个锁存沿，都会有一个新的数据被保存！
对于如上图所示的级联的寄存器电路而言（忽略上一级触发器输出到下一级触发器输入之间的逻辑关系），一般蓝色的上升沿作为第一个触发器的启动沿，而红色的上升沿（一般都是紧跟着启动沿后的有效边沿）。所以说：蓝色的启动沿之后由REG1输出有效数据，并在红色的边沿被锁存进REG2并输出到下级。
1.2 建立（setup）和保持（hold）时间 图 3 建立和保持时间
上述的锁存沿会将数据保存下来，但是必须要满足一定的条件：
建立时间Tsu：在时钟有效沿之前，数据必须保持稳定的最小时间；
保持时间Th：在时钟有效沿之后，数据必须保持稳定的最小时间；
这就相当于一个窗口时间，在有效边沿的窗口时间内，数据必须保持稳定；这里的时钟信号时序和数据信号时序，都是寄存器实际感受到的时序；什么事实际感受到的，下面会继续分析；
1.3 数据到达时间（DAT：data arrival time） 所有的信号在FPGA内部传播都会有延时，包括时钟信号、数据信号（实际上不该如此可以的区分这两种信号，在一定条件下，这两个信号可能可以相互转换，这个是题外话了），也就是说，从信号的发出点到信号的接收点，会存在一个延时，这个延时可能是因为FPGA内部空间分布所致，也有可能是因为组合逻辑造成，这里不再深究；
图 4 数据到达时间示意图
正如上图所示，在计算数据到达时间时，一般都会存在3个延时：
1. Tclk1:时钟信号从起点（一般是PLL输出或者时钟输入引脚）到达启动寄存器（或说启动触发器）的相应clk端口所耗的时间；假如CLK是由PLL发出的时钟信号（称之为源时钟），这个信号经过FPGA内部的“连线”最终来到了REG1（启动触发器）的clk端，所以此时在REG的clk1处也会有周期性的时钟信号REG1.CLK(如图所示)；可以看到，此时的CLK（源时钟）和REG1.CLK实际上有个（相位差）时间差，这个时间差就是Tclk1；
2. Tco：启动寄存器内部延时，是寄存器REG1感受到有效的上升沿后，到数据真正从从REG1的Q输出之间延时；请注意：上述所谓的有效的上升沿，就是REG1.CLK，而不是CLK；所以实际的有效数据输出的时序如上图的REG1.Q;
3. Tdata：数据从上级寄存器输出Q（经过所有其他组合逻辑以及FPGA内部走线）到下级寄存器的数据输入D之间的延时；如图所示，数据从从REG1的Q流向了REG2的D，所以REG2.D实际感受到的数据时序是REG2.D；
假如将上图中的launch Edge作为时间0点，将一些列的延时累加，所得结果称之为数据到达时间，DAT：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18514f87d9366c0f57af5efb4bc96e64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b79eba45a79c79ea6eae58f23f8c342/" rel="bookmark">
			EXCEL用今天日期减去之前的日期得到结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有计划日期、完工日期，要求延期天数=等于两个日期差值，如下表：
1、C2=B2-A2，得到即差值。
2、DAYS360函数：按照一年360天的算法（每个月以30天计，一年共计12个月），返回两日期间相差的天数。
DAYS360(start_date，end_date,method)
C3=DAYS360(A3,B3)
3、NETWORKDAYS：返回参数start_date和end_date之间完整的工作日数值。工作日不包括周末和专门指定的假期。
NETWORKDAYS(start_date，end_date,holidays)
C4=NETWORKDAYS(A4,B4)
综上，最简单的就是直接相减，问题是不能区分工作日和周末。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/962dee3fe5c458fb7a05561cc0537f61/" rel="bookmark">
			JDK8 集合排序  xxxList.stream.sorted(...)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到教程。 # 默认 list.stream().sorted() list.stream().sorted(Comparator.reverseOrder()) # 按字段排序 xxxList.stream().sorted(Comparator.comparing(XxxModel::getData_time)); # 倒序 xxList.stream().sorted(Comparator.comparing(XxxModel::getData_time).reversed()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffcdc1fbdafc927e57d4af04415be2b2/" rel="bookmark">
			js 自动点击HTML元素事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js 自动点击事件
js部分 $(function () { document.getElementById("HTML元素id").click(); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d985161dd4ee188b2fb0e2229060e279/" rel="bookmark">
			SQL操作时带数据库名与不带数据库名的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL操作时带数据库名与不带数据库名的区别 带数据库名代码不带数据库名代码 条件：连接到MySQL，未选择数据库时 带数据库名代码 select * from mybatis.user 结果：
不带数据库名代码 select * from user 结果：
结论:带数据库名的可以直接通过数据库名查询到表,进行跨库操作；不带数据库名的只能先选择数据库后再查询表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32d575fce16b4597f25c3084e0d066e/" rel="bookmark">
			手把手教你使用 CompletableFuture
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在jdk5中，我们通过使用Future和Callable，可以在任务执行完毕后得到任务执行结果。可以使用isDone检测计算是否完成，使用cancle停止执行任务，使用阻塞方法get阻塞住调用线程来获取返回结果，使用阻塞方式获取执行结果，有违异步编程的初衷，而且Future的异常只能自己内部处理。
jdk8中加入了实现类CompletableFuture&lt;T&gt;，用于异步编程。底层做任务使用的是ForkJoin, 顾名思义，是将任务的数据集分为多个子数据集，而每个子集，都可以由独立的子任务来处理，最后将每个子任务的结果汇集起来。它是ExecutorService接口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。 从api文档看，它实现了2个接口 CompletionStage&lt;T&gt;, Future&lt;T&gt;，CompletableFuture&lt;T&gt;拥有Future的所有特性。 CompletionStage支持lambda表达式，接口的方法的功能都是在某个阶段得到结果后要做的事情。 CompletableFuture内置lambda表达式，支持异步回调，结果转换等功能，它有以下Future实现不了的功能
合并两个相互独立的异步计算的结果。
等待异步任务的所有任务都完成。
等待异步任务的其中一个任务完成就返回结果。
任务完成后调用回调方法
任务完成的结果可以用于下一个任务。
任务完成时发出通知
提供原生的异常处理api
CompletableFuture的使用方法 首先说下获取结果方式 CompletableFuture获取结果的方式有如下4个方法：
1：get 阻塞获取结果，实现Future的get接口，显式抛出异常
2：getNow(T valueIfAbsent) 获取执行结果，如果当前任务未执行完成，则返回valueIfAbsent
3: join 执行完成后返回执行结果，或者抛出unchecked异常
4: T get(long timeout, TimeUnit unit) 在有限时间内获取数据
以下是CompletableFuture的创建对象以及api的使用
1: 创建CompletableFuture 对象 public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value) 静态方法，返回一个已经计算好的CompletableFuture 比如
@Testpublic void testStatic() { CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.completedFuture("test");	//判断cf是否 执行完毕 assertTrue(completableFuture.isDone());	//getNow获取结果，如果获取不到，返回默认值null assertEquals("test", completableFuture.getNow(null)); } completableFuture 还能主动结束运算，并显示处理异常，如下是异步执行的代码
@Test public void testActive() { CompletableFuture&lt;String&gt; completableFuture = new CompletableFuture();	new Thread(() -&gt; {	try { String string = null; string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f32d575fce16b4597f25c3084e0d066e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3df2f0b7b6f42c42cb1628121cd5ee0/" rel="bookmark">
			详细简单的win中P，V操作（司机、售票员）C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果还不知道创建子进程，参考：
win中创建进程
正文开始：
c语言windows环境下：：
1.&lt;windows.h&gt;中有信号量创建的函数和模拟PV操作的函数： 创建信号量 HANDLE CreateSemaphore( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, // 安全属性指针 LONG lInitialCount, // 初始计数 LONG lMaximumCount, // 最大计数 LPCTSTR lpName // 对象名指针 ); 参数lMaximumCount是一个有符号32位值，定义了允许的最大资源计数，最大取值不能超过4294967295。 lpName参数可以为创建的信号量定义一个名字，由于其创建的是一个内核对象，因此在其他进程中可以通过该名字而得到此信号量，这个名字非常重要，你在其他进程中可以直接通过这个名字找到这个信号量。 打开信号量 HANDLE OpenSemaphore( DWORD dwDesiredAccess, // 访问标志 BOOL bInheritHandle, // 继承标志 LPCTSTR lpName // 信号量名！！！！！！！！！ ); 这里就是在其他进程中通过信号量名字进行索引！！！！ 释放信号量 BOOL ReleaseSemaphore( HANDLE hSemaphore, // 信号量句柄 LONG lReleaseCount, // 计数递增数量 LPLONG lpPreviousCount // 先前计数 ); 等待信号量（相当于P操） WaitForSingleObject（）//等一个 WaitForMultipleObjects（）//等多个 主要用在试图进入共享资源的线程函数入口处，主要用来判断信号量的当前可用资源计数是否允许本线程的进入。 注意：实际上的P操作是在进程得到这个信号量的时候就完成的，并不是上面两个相当于P操作的函数完成的。 2.下面来模拟PV操作 P操作：WaitForSingleObject(信号量引用，等待时间)
V操作：ReleaseSemaphore(信号量引用，加的值，原始值)
例如现在有一个s1信号量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3df2f0b7b6f42c42cb1628121cd5ee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5901c44a474a342fdb304e8730708d23/" rel="bookmark">
			vue&#43;springboot 登录注册功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前端 1、搭建前端项目 需要用到node的npm，先下载安装node，官网https://nodejs.org/zh-cn/
在命令窗口输入命令：
npm -v
node -v
npm install webpack -g
npm install vue-cli -g
在本地新建一个项目文件夹，打开命令窗口cd到项目文件夹，然后按下图操作：（只有一个输入No，其他Yes）
完成后：
2、用VScode打开项目文件夹即可 3、安装element ui 在控制台输入命令：
npm i element-ui -S 4、在main.js中引入 import ElementUI from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(ElementUI); 5、目录结构 6、新建register.vue组件 &lt;template&gt; &lt;body id="paper"&gt; &lt;el-form :model="registerForm" :rules="rules" class="login-container" label-position="left" label-width="0px" v-loading="loading"&gt; &lt;h3 class="login_title"&gt;用户注册&lt;/h3&gt; &lt;el-form-item prop="username"&gt; &lt;el-input type="text" v-model="registerForm.username" auto-complete="off" placeholder="账号"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop="password"&gt; &lt;el-input type="password" v-model="registerForm.password" auto-complete="off" placeholder="密码"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop="passwordConfirm"&gt; &lt;el-input type="password" v-model="registerForm.passwordConfirm" auto-complete="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5901c44a474a342fdb304e8730708d23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11041087ceb96f1198f33d36f88a87a5/" rel="bookmark">
			Vim十大必备插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vim十大必备插件 Taglist taglist是一个用于显示定位程序中各种符号的插件，例如宏定义、变量名、结构名、函数名这些东西 我们将其称之为符号(symbols)，而在taglist中将其称之为tag。显然，要想将程序文件中的tag显示出来，需要事先了解全部tag的信 息，并将其保存在一个文件中，然后去解析对应的tag文件。taglist做的仅仅是将tag文件中的内容解析完后显示在Vim上而已。tag扫描以及数 据文件的生成则是由ctags(Exuberant Ctags)这一工具完成的，所以在使用taglist之前，你的电脑需要装有ctags。
NERDTree NERDTree是一个用于浏览文件系统的树形资源管理外挂,它可以让你像使用Windows档案总管一样在VIM中浏览文件系统并且打开文件或目录。
WinManager 我们上面介绍了用于文件浏览的nerdtree以及浏览程序符号的taglist，这两个插件都会以窗口的形式出现在Vim的窗口中，那么如何合理的安排它们，这就是winmanager的作用。
这里，我们利用winmanager将nerdtree和taglist放到同一个”侧边栏”中，nerdtree在上方，taglist在下方，效果如下图所示：
NerdCommenter 如果你是一个酷爱写注释的程序员的话，那么你一定要用一下nerdcommenter，即便你不热衷于写注释，你也应该关注下nerdcommenter这款插件。
nerdcommenter和Vim的Visual模式结合可以快速的注释/取消注释多行代码，同时在行尾追加注释并自动进入Insert模式可以方便的进行行内注释。
Neocomplete 用过了很多补全插件，最后还是选择了neocomplete。neocomplete.vim是来自shougo的作品，该插件维护了当前buffer的一个关键词列表，从而提供强大的关键词补全功能。
Molokai 配色使用的是我钟爱的monokai，但是换了深色配色，使用了一个molokai配色插件。之所以叫molokai，因为这个配色是monokai的修改版，将monokai的背景色改为了深色。我想要一个深色背景的molokai.正和我意啊。
Vim-airline 接下来介绍一下个人非常喜欢的一个插件vim-airline。这是一款状态栏增强插件，可以让你的Vim状态栏非常的美观，同时包括了buffer显示条扩展smart tab line以及集成了一些插件。
Ctrlp ctrlp是一款相当棒的插件，主要的功能是对文件进行模糊的查找，如果你的project目录结构复杂，或者你正在阅读一个较大的项目的话，那么ctrlp可以帮你快速的定位到你想要文件而不必在终端不断的cd、ls。
EasyGrep Vim是内置支持Grep的，Vim7.3更是更新了Grep的引擎，在Vim内Grep的速度更快了。但是Vim中的Grep一样不容易掌握，还好有很多简化Grep的插件可以用，包括grep的变种ack，这其中使用起来最方便的，最人性化的要数EasyGrep了。
Vundle 之前使用过tpope的pathogen， 使用git submodule和pathogen, 管理插件已经大大简化。而今天介绍的vundle, 更是把git操作整合进去，用户需要做的只是去Github上找到自己想要的插件的名字，安装，更新和卸载都可有vundle来完成了。虽然去发现一个好 的插件仍然是一个上下求索的过程，但是用户已经可以从安装配置的繁琐过程解脱了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78650d4daa7a0c4405e21e049d914805/" rel="bookmark">
			SpringCloud微服务启动脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务发布启动方式很多，大概有以下方式，使用脚本启动方便运维维护，更方便各种CI，CD等Devops操作，希望能帮助到目前正在开发微服务的同学们。
**
1，命令行方式启动微服务 **
java -jar package（服务包名，如abc.jar），这种方式比较简单直接，如果需要参数需要携带参数启动如：
java -Xms500m -Xmx500m -server -XX:+HeapDumpOnOutOfMemoryError -jar $JAR_PATH/abc.jar --spring.profiles.active=test
以上方式在命令行执行容易写错，另外每次手动执行也不合适。
**
2，通过脚本方式启动服务 **
根据服务的参数配置以及使用的具体环境，正常每个项目都有dev，test，prod三个环境，脚本执行需要几个关键参数，
port：服务启动的端口号，这个确保当前服务未必占用；
mainclass：入口类，也就是我们main方法所在的class类；
classpath：服务资源路径，包括配置文件，依赖的其他jar文件的lib库
下边是我针对微服务编写一套基于bashshell脚本，目前已经在各个环境（dev，test，prod）运行，由于是微服务需要依赖不同环境的配置文件，yml配置文件命名规则如下，也是按照springboot环境要求，具体配置内容开发者都雷同，不在赘述。
application-dev.yml（开发环境配置） application-test.yml（测试环境配置） application-prod.yml(商用环境配置) 当然最基础的配置文件必须得有，以SpringCloud Edgware.SR4版本为例
bootstrap.yml（spring.cloud.config相关配置,eureka相关配置，系统启动优先加载的参数必须配置在这里）
spring: cloud: bus: trace: enabled: true config: name: ${spring.application.name} #application profile: ${spring.profiles.active} #profile label: ${branch} fail-fast: true override-system-properties: true discovery: enabled: true # [new]开启config服务发现的支持 service-id: micro-config-server #[new] config-server-application-name stream: bindings: springCloudBusInput: destination: springCloudBus kafka: binder: brokers: ${kafka-brokers} zk-nodes: ${zk-nodes} configuration: auto: offset: #可以设置原生kafka属性，比如设置新的消费组从最新的offset开始消费 reset: latest security: user: name: admin password: admin123 eureka: instance: instance-id: ${spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78650d4daa7a0c4405e21e049d914805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8edd4d92d976d3fbbc713bf8f29f266b/" rel="bookmark">
			Jquery|小白学习各种动画特效(含各种小测试用例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博文源于jQuery，旨在学习jquery中动画的一些操作。
animate()方法的基本使用 程序中，我们调用了animate()函数，并传入两个参数：
第1个参数是一个JSON对象，用来设置盒子要变化为什么样式，称为“动画的终点样式”第2个参数是一个数字型值，用来设置动画的总时长，以毫秒为单位。 例子：将矩形变成圆形 $("#box").animate({ "left":800, "top":300, "width":100, "height":100, "border-radius":"50%" },2000); 测试效果 完整测试代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box { width: 100px; height: 100px; background-color: blue; position: relative; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box" id="box"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $("#box").animate({ "left":800, "top":300, "width":100, "height":100, "border-radius":"50%" },2000); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 哪些属性可以参与动画 基本上我们常用到的都可以，除了一些
背景的属性不能参与animate()动画.比如：代码带有background的。background-colorc3的transform属性，比如rotate()旋转,skew(斜切)等不能成为animate()的参数 不考虑兼容性那就需要用c3做动画，如果考虑兼容性那就直接jquery适合
动画的并发和排序 不同元素的animate()动画会同时进行相同元素的animate()动画会排队进行 学习这些，来个例子体会就行了
不同元素的animate()动画会同时进行 例子：5个红色盒子同时向右移动 $("#box1").animate({"left":1000},1000); $("#box2").animate({"left":1000},1000); $("#box3").animate({"left":1000},1000); $("#box4").animate({"left":1000},1000); $("#box5").animate({"left":1000},1000); 测试效果 测试代码 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8edd4d92d976d3fbbc713bf8f29f266b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a869331cfbc791aabfae598e332599a7/" rel="bookmark">
			使用Docker部署安装NextCloud私有云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Docker部署安装NextCloud私有云 0 环境配置1 安装NextCloud私有云2 开放8080端口3 使用80端口 0 环境配置 阿里学生云服务器一台操作系统 Centos7.6Docker 1.13.1
安装Docker 1 安装NextCloud私有云 NextCloud基于云技术的工程教育平台，利用云技术，提高工程教育过程中教学、实验与创新的效率与效果。
每一位nextcloud的使用者都可以以教师或学生身份登录， 从而使得每个人都可以传授知识也可以学习知识，真正做到Any time, any where!的工程教育全新愿景。百度
1.1 重启Docker
service docker restart 1.2 安装NextCloud
docker run -d -p 8080:80 nextcloud 安装成功
1.3 访问服务器IP + 端口8080
例如http://47.101.174.127:8080/
Error
不要慌，因为没有开放端口号哈！
2 开放8080端口 2.1 查看防火墙的状态
firewall-cmd --state 2.2 处于关闭状态，开启！
systemctl start firewalld.service 2.3 开启！
firewall-cmd --zone=public --add-port=8080/tcp --permanent –zone=public：表示作用域为公共的
–add-port=8080/tcp：添加tcp协议的端口8080
–permanent：永久生效，如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效
2.4 重启防火墙&amp;重新载入配置
systemctl restart firewalld.service firewall-cmd --reload 2.5 检查8080开放情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a869331cfbc791aabfae598e332599a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4f5fcfb054f98ab2b5d876fa89b774/" rel="bookmark">
			华为网络实验--access、trunk、hybrid接口配置实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为网络实验–access、trunk、hybrid接口配置实验 文章目录 华为网络实验--access、trunk、hybrid接口配置实验前言●实验目的●需求分析●实验步骤1.交换机SW1命令2.交换机SW2命令3.路由器R1命令4.路由器R2命令5.实验结果验证 ●实验总结 前言 Hybrid接口是华为设备特殊的二层接口模式，
可以类似于vlan和trunk接口，
可以对数据帧不打vlan标签和不打标签。
●实验目的 通过配置交换机SW1和SW2不同接口的access、trunk、hybrid属性，实现PC1能和PC2互通，PC2能和PC4互通，PC3能和PC4互通。
●需求分析 1.新建如下图所示拓扑图；
2.SW1中创建vlan、配置access、trunk和hybrid接口；
3.SW2中创建vlan、配置trunk和hybrid接口；
4.路由器R1和R2配置接口网关和直连路由的IP地址，静态路由。
●实验步骤 1.交换机SW1命令 vlan batch 10 20 ##创建vlan10 20 interface Ethernet0/0/1 port link-type access port default vlan 10 ##将e0/0/1接口划分到vlan10 interface Ethernet0/0/2 port link-type access port default vlan 20 ##将e0/0/2接口划分到vlan20 interface GigabitEthernet0/0/1 port link-type trunk port trunk allow-pass vlan 10 20 ##将g0/0/1接口设为trunk口 interface GigabitEthernet0/0/2 port hybrid pvid vlan 10 ##进g0/0/2接口贴上vlan10 port hybrid untagged vlan 10 20 ##出g0/0/2接口脱去vlan10或vlan20 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce4f5fcfb054f98ab2b5d876fa89b774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5efcb64db2bb601f8aef9c1f7663b1d0/" rel="bookmark">
			Javascript  vue  数组中的对象分离    获取对象属性名称   对象属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"productItemInfo":[ { "字面颜色":"蓝色系/深蓝色" }, { "字边颜色":"金属色/拉丝银" }, { "光源颜色":"正白灯（6000k-7000k）" }, { "是否淋雨":"是" }, { "固定方式":"外脚码安装" } ], let productItemArr=[] this.productItemInfo.forEach(n=&gt;{ productItemArr.push({ name:Object.keys(n)[0], namekey:n[Object.keys(n)[0]] }) }) console.log(productItemArr) 打印的效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/106653c26b8023be9b9c87a38b38f8dc/" rel="bookmark">
			WPS Excel做多级下拉菜单列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WPS Excel做多级下拉菜单列表 最近做表格数据需要做一个三级别关联下拉菜单，之前只知道一列下拉菜单是用数据有效性做，三级别的没做过，查了资料，记录一下。
1.一级下拉菜单 选中要添加下拉菜单的数据列，在数据中找到有效性中设置条件，允许条件中选序列，来源中选择需要设置的下拉选项数据（例G1-G3），确定就OK啦。
2.设置多级别跨表下拉菜单 1》首先是要用到的三个表格，想把表“二级菜单”和表“三级菜单”中的数据引用到sheet1表中给物品分类；首先做各表中的数据： 2》二级下拉菜单中的选项放到一级下拉菜单选项的下面 3》三级下拉菜单中的选项放到二级下拉菜单选项的下面 4》数据设置完成后，开始做关联啦 先在“二级标签”这个表中，选中所有数据（ctr+A），点击导航栏中的公式，找到指定功能，点击设置指定选项：因为我表中数据一级下拉菜单在二级下拉菜单的上面，所以选首行
5》“三级标签”表也按“二级标签”表设置 6》设置完成后就可以在公式–&gt;名称管理器中看到设置好的数据了 7》回到sheet1表格，在一级标签列，数据–&gt;数据有效性中做一级下拉菜单，来源选择“二级标签”表中的第一行中的数据 二级下拉菜单选中C2单元格，数据–&gt;有效性，来源中用输入公式=INDIRECT($B2)绝对引用B列数据，下面的列直接从C2下拉格式就OK。
三级下拉菜单同上设置。
八》下面为设置结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f780f2203561449f9fea5950f869cf/" rel="bookmark">
			关于上传.htaccess文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.有时候因为名单的原因，只能上传php文件，而且并没有其他的东西解析成php，只有先上传一个.htaccess文件解析php才能继续上传。
2.建立一个.htaccess文件。内容这些
&lt;FilesMatch “pino”&gt;
SetHandler application/x-httpd-php
这是原作大佬地址地址
3.使用
先将.htaccess文件上传，再建立一个pino文件，将一句话木马写入，连接的是pino文件地址，用菜刀或者蚁剑，就OK了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78e918c2ba0bb2f9f140753a2a55ff6/" rel="bookmark">
			制作.sens数据集跑通bundlefusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 主要参考这篇博客实现 https://blog.csdn.net/Wuzebiao2016/article/details/94426905
2. 首先就是将自己采集的RGBD图像的保存格式向Bundlefusion需要的格式对齐，如彩色图的命名格式是frame-000000.color.png，深度图的命名规则是frame-000000.depth.png.
3. 最重要的事情是如何将你准备的数据生成.sens文件
（1）将工程中原始的main函数注释掉，然后换成下面的main函数调用工程下的loadFromImages()和saveToFile()
int main()
{
ml::SensorData sd;
sd.loadFromImages("D:/Compressed/BundleFusionData", "frame-", "jpg");
sd.saveToFile("D:/Compressed/test.sens");
}
1. 主要参考这篇博客实现 https://blog.csdn.net/Wuzebiao2016/article/details/94426905
2. 首先就是将自己采集的RGBD图像的保存格式向Bundlefusion需要的格式对齐，如彩色图的命名格式是frame-000000.color.png，深度图的命名规则是frame-000000.depth.png.
上面这篇文章中也谈了很多关于压缩类型的问题，为了能让代码正常运行，生成可用的.sens文件，则需要对sensorData.h中的
#defineM_SENSOR_DATA_VERSION 4下面，将彩色图和深度图的压缩类型进行初始化，初始化制定类型。
m_colorCompressionType = TYPE_JPEG;// TYPE_PNG;
m_depthCompressionType = TYPE_ZLIB_USHORT;
虽然.sens中图像很多，但是重建的效果却很差，只有这一点点，也许跟我们的采集方式有关，我们是拿着kinect相机径直向前走的缘故，使用kinect采集图像数据的正确打开方式是，使相机朝着obstacles（墙面或者物体）扫描，因为Kinect相机的有效工作距离比较短一般在3-4米。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f71b5a0b998ab8ff1b07fcc1ab1f922/" rel="bookmark">
			【计算机网络 22】基础知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、TCP/IP协议概述 在TCP/IP协议栈，传输层有两个协议TCP和UDP
TCP（Transmission Control Protocol，传输控制协议）协议：负责将要传输的文件分段 进行传输，一般用于建立会话 ，其基本特性是可靠传输 、流量控制，所谓三握手、四挥手也是基于TCP协议的
UDP（User Data Protocol，用户数据报协议）协议：一个数据包就能够完成数据通信 ，数据包不分段 ，不需要建立会话 ，不需要流量控制 ，属于不可靠传输 ， 屏幕广播 、多播 、广播都是基于UDP协议
二、传输层协议的作用体现在应用层协议 TCP和UDP协议内指定不同的端口即可对应一个应用层的协议
端口代表主机服务的侦听"门牌号"，不管是TCP还是UDP，带上门牌号，它就能帮你找到主机上的对应服务
例如我们在浏览器访问某个网站地址，这个动作会被我们本机上的80端口侦听到，并处理你的网络请求
我们主机上常见的应用层协议端口：
HTTP默认使用TCP的80端口标识FTP默认使用TCP的21端口标识SMTP默认使用TCP的25端口标识POP3默认使用TCP的110端口HTTPS默认使用TCP的443端口DNS使用UDP的53端口 远程桌面协议（RDP）默认使用TCP的3389端口
telnet使用TCP的23端口Windows访问共享资源使用TCP的445端口
但是我们通过TCP/UDP封装的数据包，通过本机侦听服务发送到目标主机，目标主机是如何识别并处理的呢？
如上图，我们会在数据包中添加目标端口号，这样目标主机相关服务侦听到，就能处理我们的请求了
三、TCP/UDP传输层协议与网络层协议的区别 网络层实现如何把数据包从这个地址(服务器)发送到另一个地址(服务器)传输层实现如何让这个应用程序找到对应计算机的应用程序，即服务 四、UDP协议 1、主要特点： UDP 是面向无连接的，即发送数据之前不需要建立连接，如向DNS服务器申请域名解析服务UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求UDP 支持一对一、一对多、多对一和多对多的交互通信，这也是，应用场景如广播、组播UDP 的首部开销小，只有 8 个字节 2、基本描述 （1）UDP首部
首先得知道数据包在OSI模型中层层传输，自顶向下
用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段有 8 个字节，由 4 个字段组成，每个字段都是两个字节在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和，伪首部12个字节取自IP数据报的字段检验和实现UDP数据检验，通过验证检验和可以知道UDP数据包是否出现异常 五、TCP协议 1、基本特点 TCP 是面向连接的传输层协议，UDP面向无连接每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）TCP 提供可靠交付的服务（持续交付）TCP 提供全双工通信（信道双向传输）面向字节流(传送最小单位为字节，即八位) 上图可以看出TCP传输是如何面向字节流的，具体细节后面继续解析
2、TCP连接基于Socket TCP 把连接作为最基本的抽象，每一条 TCP 连接有两个端点TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是传输层的协议端口。TCP 连接的端点叫做套接字(socket)IP地址+服务端口构成了套接字 3、TCP协议确保可靠传输 TCP使用自动重传请求ARQ (Automatic Repeat reQuest)确保可靠传输
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f71b5a0b998ab8ff1b07fcc1ab1f922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6c8e9ede3da95793bbcd40586087cc1/" rel="bookmark">
			java：java8新特性（Lambda 表达式、方法引用、构造器引用、数组引用、Stream API）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		速度更快
对 HashMap 、ConcurrentHashMap低层的数据结构（数组+链表+二叉树）
低层的内存结构（将永久区更新为元空间，元空间使用的是物理内存）
代码更少（增加了新的语法 Lambda 表达式）
强大 Stream API
便于并行
最大化减少空指针异常 Optional
关于时间日期的 API
目录
一、Lambda 表达式
为什么使用 Lambda 表达式
Lambda 表达式的基础语法
函数式接口
Java8内置四大核心函数式接口
其他接口
二、方法引用、构造器引用、数组引用
方法引用
构造器引用
数组引用
三、Stream API
Stream 操作的三个步骤：
创建 Stream
中间操作
终止操作
一、Lambda 表达式 为什么使用 Lambda 表达式 //原来将匿名内部类作为参数进行传递 @Test public void test1(){ TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o1.compareTo(o2); } }); } //java8中的 Lambda 表达式 @Test public void test2(){ TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;((x, y) -&gt; x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6c8e9ede3da95793bbcd40586087cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c4aae18da9f547c938cbc8d473aa999/" rel="bookmark">
			json概念信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。
JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。
JSON建构于两种结构，一是“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。
二是值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）
扩展资料：
JSON简要历史
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。
JSON是Douglas Crockford在2001年开始推广使用的数据格式，在2005年-2006年正式成为主流的数据格式，雅虎和谷歌就在那时候开始广泛地使用JSON格式。
参考资62616964757a686964616fe78988e69d8331333431363563料来源：百度百科—json
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3237b803b4cf80f48ff27a198efc25a1/" rel="bookmark">
			dart:字符串replace相关的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js中字符串有replace方法，通过正则表达式的修饰符可以用一个replace方法结合正则表达式实现各种方式的替换。
不过dart中对各种替换方式做了细分。需要另外注意的是，dart中字符串是不可变的对象，所有replace相关的方法都不会修改原 字符串，而是返回一个新字符串。
1. replaceAll String replaceAll(pattern from,String replace)
replaceAll第一个参数是匹配符，可以是字符串也可以是正则表达式，第二个参数是要替换的字符串，返回值是一个新字符串。
var a = 'a1b2c3a'; var b = '123'; print(a.replaceAll('a', '123')); //1231b2c3123 print(b.replaceAll(RegExp(r'(\d)'), '111')); //111111111 2.replaceAllMapped String replaceAllMapped(
Pattern from,
String replace(Match match)
)
replaceAllMapped第一个参数是匹配符，可以是字符串也可以是正则，第二个参数是一个函数，函数的参数捕获到的字符串片段，其实就是对捕获的字符串片段的一个映射，看函数名的mapped就能看的出来。
var c = '123'; var d = 'this is an apple'; print(c.replaceAllMapped('2', (Match m) =&gt; '${m[0]}-${m[0]}-'));//12-2-3 print(d.replaceAllMapped(RegExp(r'apple'), (Match m) =&gt; 'orange'));//this is an orange 3.replaceFirst String replaceFirst(
Pattern from,
String to,
[int startIndex = 0]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3237b803b4cf80f48ff27a198efc25a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eeb668ee9750610e8438cba10ca0e78/" rel="bookmark">
			百钱买百鸡问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入 我国古代数学家张丘建在《算经》一书中曾提出过著名的“百钱买百鸡”问题，该问题叙述如下：鸡翁一，值钱五；鸡母一，值钱三；鸡雏三，值钱一；百钱买百鸡，则翁、母、雏各几何？
百钱买百鸡的问题算是一套非常经典的不定方程的问题，题目很简单：公鸡5文钱一只，母鸡3文钱一只，小鸡3只一文钱，
用100文钱买一百只鸡,其中公鸡，母鸡，小鸡都必须要有，问公鸡，母鸡，小鸡要买多少只刚好凑足100文钱。
都是一个题
分析 每种鸡至少一个，钱加一起等于100，鸡子数量加起来等于100
我们都知道，我们一般用穷值法，在for循环求多个符合条件的解，通常我考虑一些条件来减少循环的次数。
比如说每种鸡至少一个，那么我们自变量的初始值就是1
公鸡最多： 100/5=20只 母鸡最多： 100/3=33只
小鸡最多 100-公鸡-母鸡
这个最多是总价不超过100来算的，同时我们还可以考虑一方面每种鸡至少一个，加入可以变成
公鸡最多： （100-3-1/3)/5=19只
母鸡最多： （100-5-1/3)/3=31只
小鸡最多： 100-公鸡-母鸡
循环的次数是不是又变少了
代码 #include &lt;stdio.h&gt; int main(void) { //定义公鸡、母鸡、小鸡的数量变量 int x,y,z;	//定义数量变量和价格变量 int sump,sumc; int i,j,k; //公鸡最少1只，最多100/5=20只 for(i = 1; i &lt;= 19; i++){ //母鸡最少1只，最多100/3=33只 for(j = 1; j &lt;= 31; j++){ //小鸡最少1只，最多100-公鸡-母鸡 for(k = 1; k &lt;= 100-i-j; k++){ sump = k/3+j*3+5*i; sumc = i+j+k; if(sump == 100 &amp;&amp; sumc == 100){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eeb668ee9750610e8438cba10ca0e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47af62b21e179d88ffb35267d42a39e/" rel="bookmark">
			synchronized底层原理—Monitor监视器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入了解synchronized 文章目录 深入了解synchronized1. 作用2. 底层实现原理1. Monitor类2. 管程3. ObjectMonitor4. _WaitSet5. _EntryList6. ObjectWaiter 3. 对象头1. 轻量级锁2. 重量级锁 4. 总结参考 synchronized——java多线程锁的关键字 1. 作用 多线程情况下，同步代码的互斥访问有效的解决了共享变量的可见性问题解决了指令重排序的问题 2. 底层实现原理 小插曲：用idea插件jclasslib查看指令字节码
写一段代码，然后查看其指令字节码
public static void soDemo2(){ System.out.println("进入sDemo2"); synchronized (ThreadDemo.class){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("执行 static synchronized(Thread.class) sDemo2"); } } 0 getstatic #8 &lt;java/lang/System.out&gt; 3 ldc #15 &lt;进入sDemo2&gt; 5 invokevirtual #10 &lt;java/io/PrintStream.println&gt; 8 ldc #13 &lt;Thread/synchronizeddemo/ThreadDemo&gt; 10 dup 11 astore_0 12 monitorenter 13 ldc2_w #3 &lt;2000&gt; 16 invokestatic #5 &lt;java/lang/Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f47af62b21e179d88ffb35267d42a39e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e4f453ac69ea761839f8346a422862d/" rel="bookmark">
			深度学习中数据集处理（视频转图片）-图像篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hey，最近几天一直在做数据集处理的工作，过程很艰辛，今天先介绍一下数据集中图片的处理。标注文件的处理真的是太难了，我还没有搞定。标注文件的处理，下次介绍。
我要处理的数据集是之前提到的“ACM MM Grand Challenge on Large-scale Human-centric Video Analysis in Complex Events”数据集，
官方给出的是视频文件，和每个视频文件对应的标注文件。首先为了要训练这些图片，我需要利用python和opencv去把视频中的每一帧切出来，并且要按顺序把图片命名成指定格式的名字。
按照标注文件，需要把图片名称命名为6位的。从000000开始依次增加。
好的，首先对官方给出的视频文件进行处理，把每个视频都变成图片，代码如下：
import cv2
import os
def save_img():
video_path = '/Users/sqx/Downloads/HIE/HIE20/videos/train/'
videos = os.listdir(video_path)
for video_name in videos:
file_name = video_name.split('.')[0]
folder_name = video_path + file_name
os.makedirs(folder_name, exist_ok=True)
vc = cv2.VideoCapture(video_path + video_name) # 读入视频文件
c = 0
print(file_name)
rval = vc.isOpened()
while rval: # 循环读取视频帧
rval, frame = vc.read()
pic_path = folder_name + '/'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e4f453ac69ea761839f8346a422862d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1969c5b9035b622fb109eabfbd73035/" rel="bookmark">
			FPGA与单片机的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为最近在做电子技术课程设计，老师说，现在做课程设计不能用单片机，只能用模数电知识，可以用FPGA
我开始疑惑，单片机和FPGA有什么区别，看了一片文章觉得讲的很详细。
链接
http://www.elecfans.com/d/663737.html
fpga和单片机的区别
1、结构上的区别
单片机是一种微处理器，类似于电脑CPU的，它一般采用的是哈佛总线结构，或者冯诺依曼结构，对单片机的编程很大程度上要考虑到它的结构和各个寄存器的作用，单片机用途比较广，一般用在控制流水线上，还有日 常你看得到的东西上！
FPGA 它的结构是查找表结构，其程序不用去太考虑芯片的结构，要注意的是时序上问题，它的结构比较复杂，功能也很强大，一般应用在通信领域等比较高端的场合，目前在国内FPGA还算是一个新兴的行业，当然它的价格也要比单片机贵得多！
单片机是一个微控制器，通过加载模块软件来实现某种功能，单片机是成型的芯片;FPGA是用来设计芯片的芯片。
2、速度上的区别
FPGA由于是硬件电路，运行速度直接取决于晶振速度，系统稳定，特别适合高速接口电路。单片机由于是单线程，哪怕是常用的M3系列流水线也是单线程执行，程序语句需要等待单片机周期才能执行。
3、本质区别
FPGA和单片机的区别，本质上是软件和硬件的区别，FPGA更偏向于硬件电路，而单片机更偏于软件。
单片机设计属软件范畴;它的硬件（单片机芯片）是固定的，通过软件编程语言描述软件指令在硬件芯片上的执行;
FPGA设计属硬件范畴，它的硬件（FPGA）是可编程的，是一个通过硬件描述语言在FPGA芯片上自定义集成电路的过程;
4、应用上的区别
应用上，差别更大。MCU最终所有的指令在一个MCU中都是顺序执行的，而FPGA由于是逻辑单元，很容易做到并行执行。
5、入门难易程度
单片机比FPGA简单些，价格也低一些。要做PID算法控制的用单片机可以，STM32F4系列已经到300M+跑PID完全足够，如果是跑嵌入式的话可以上ARM芯片。涉及通信、图像等高速部分可以采用单FPGA模块。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2caf15d688c30b201113c5c96072bdeb/" rel="bookmark">
			爬虫&#43;可视化——链家杭州二手房房源信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		------------本篇文章旨在练习数据的爬取及可视化
简介 本项目分两个部分：
1.爬虫：共爬取到链家杭州二手房信息30806条
2.可视化：主要用pyecharts
一、获取数据 提取杭州各个行政区二手房信息将得到的数据保存为DataFrame 导入相关的包
#-*-coding:utf-8-*- from bs4 import BeautifulSoup import pandas as pd from tqdm import tqdm import math import requests import lxml import re import time area_dic = {'西湖区':'xihu', '钱塘新区':'qiantangxinqu', '下城区':'xiacheng', '江干区':'jianggan', '拱墅区':'gongshu', '上城区':'shangcheng', '滨江区':'binjiang', '余杭区':'yuhang', '萧山区':'xiaoshan', '淳安区':'chunan1', '富阳区':'fuyang', '临安区':'linan'} # 加个header以示尊敬 headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36', 'Referer': 'https://hz.lianjia.com/ershoufang/'} # 新建一个会话 sess = requests.session() sess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2caf15d688c30b201113c5c96072bdeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cca4c0580a7fd0dc9210f34e841ac64/" rel="bookmark">
			矩阵运算：读入 1 个正整数 n(1≤n≤6),再读入 n 阶方阵 a, 	计算该矩阵除副对角线、 最后一列和最后一行以外的所有元素之和。副对角线为从矩阵的右上角至左下角的连线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引入分析代码运行测试 引入 矩阵运算：读入 1 个正整数 n(1≤n≤6),再读入 n 阶方阵 a,
计算该矩阵除副对角线、 最后一列和最后一行以外的所有元素之和。副对角线为从矩阵的右上角至左下角的连线。
分析 看到矩阵运算懵了，什么东西，网上只找到答案看不懂，我有倒推一波，这里就涉及到二维数组了,这里写一个二维数组与矩阵的对应关系 二维数组可以看作一个坐标轴(方阵) int a[3][3]; 第一3代表矩阵的横坐标，就是3排，第二个3代表坐标轴，也就是3纵 1 2 3	1的坐标就是a[0][0] 2的是[1][0] 3可以看作[2][0] 2 1 3	2可以看作[0][1]... 3 1 2 题目要求我们输入n,这个n其实 就代表几排几纵 然后输入1个矩阵 计算矩阵，他说不要最后一列和最后一行及左下角到右上角对角线值 也就是说不要 横坐标等于n-1的那一排和纵坐标等于n-1的那一纵以及横坐标和纵坐标之和不等于n-1 上面为例那个矩阵的和就是5 扩展：主对角线就是横坐标与纵坐标相等、副对角线就是横坐标与纵坐标之和不等于n-1、外围元素要么行下标i == 0 或者 i == n-1
代码 #include&lt;stdio.h&gt; int main(void) { /** 矩阵运算：读入 1 个正整数 n(1≤n≤6),再读入 n 阶方阵 a, 计算该矩阵除副对角线、 最后一列和最后一行以外的所有元素之和。副对角线为从矩阵的右上角至左下角的连线。 */ /** 看到矩阵运算懵了，什么东西，网上只找到答案看不懂，我有倒推一波，这里就涉及到二维数组了,这里写一个二维数组与矩阵的对应关系 二维数组可以看作一个坐标轴 int a[3][3]; 第一3代表矩阵的横坐标，就是3排，第二个3代表坐标轴，也就是3纵 1 2 3	1的坐标就是a[0][0] 2的是[1][0] 3可以看作[2][0] 2 1 3	2可以看作[0][1].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cca4c0580a7fd0dc9210f34e841ac64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6d43f907f7efdec771c9518421cee4/" rel="bookmark">
			微信小程序——组件定义及属性（view组件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序定义了各种各样的组件，它们在WXML中起着各不同的作用。与HTML元素一样，一个组件是指从组件开始标签到结束标签的所有代码，由于组件可能会被转译为不同端对应的代码，所以在页面创建过程中，不能使用小程序组件标签以外的标签。
组件定义及属性 1）组件是视图层的基本组成单元
2）组件自带一些功能与微信风格的样式
3）一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内
按类型可以将组件划分为七大类：视图容器、基础内容、表单、导航、多媒体、地图、画布
一个完整的组件结构如下：
&lt;tagname property="value"&gt;contents&lt;/tagname&gt; 组件可以通过属性进行配置，属性只能用在开始标签或单个自闭合标签上，不能用于结束标签。一个组件可以对应多个属性，属性具有名称和值两部分，组件的属性名称都是小写，以连字符“-”连接。组件属性分为所有组件都有的共同属性和组件自定义的特殊属性。
1.组件的共同属性
id：组件的唯一表示，保持整个页面唯一。class：组件里的样式类，在对应的WXSS中定义的样式类。style：组件的内联样式，可以动态设置的内联样式。使用方式同HTML标签style属性。hidden：组件是否显示，所有组件默认显示。data-*：自定义属性，组件上触发事件时，会发送给事件处理函数。事件处理函数可以通过datascl获取。bind*/catch*：组件的事件，绑定逻辑层相关事件处理函数。bind为冒泡事件，catch为非冒泡事件。 除上述属性以外几乎所有组件都有自定义属性，可以对该组件的功能或样式进行修饰，具体参考各个组件的定义。
2.组件的属性类型
每个属性都有其对应的类型，使用时应给属性值传入对应的类型值，属性按类型可分为：
Boolean：布尔值，组件写上该属性，不管该属性等于什么，其值都为true，只有组件上没有写该属性时，属性值才为false。如果属性值为变量，变量的值会被转换为Boolean类型。Number：数字。String：字符串。Array：数组。Object：对象。EventHandler：事件处理函数名。Any：任意属性。 视图容器 有过前端经验的同学都了解，在前端项目中我们常使用DIV+CSS进行页面布局，其中&lt;div/&gt;没有任何语义和功能，仅作为容器元素存在，在小程序中，有一套类似&lt;div/&gt;的容器组件，那就是&lt;view/&gt;、&lt;scroll-view/&gt;和&lt;swiper/&gt;。在HTML中大部分标签内部能嵌套任何标签，如&lt;div/&gt;、&lt;span/&gt;、&lt;section/&gt;、&lt;p/&gt;等，但是在小程序中，大部分组件都有它自己特殊的功能和意义，标签都有特定的用法，内部也只能嵌套指定的组件，而容器组件内部能嵌套任何标签，容器组件是构建布局的基础组件。本小节主要介绍视图类容器。
View组件
&lt;view/&gt;是一个块级容器组件，没有特殊功能，主要用于布局展示，是布局中最基本的UI组件，任何一种复杂的布局都可以通过嵌套&lt;view/&gt;组件，设置相关WXSS实现。&lt;view/&gt;支持常用的CSS布局属性，如display、float、position甚至Flex布局等，熟悉DIV+CSS的人应该很容易上手
&lt;view/&gt;具备一套关于点击行为的属性：
hover:是否启动点击态，默认值为falsehover-class:指定按下去的样式，当hover-class="none"时，没有点击态效果，默认值为nonehover-start-time:按住多久出现点击态，单位毫秒，默认值为50hover-stay-time:手指松开后点击态保留时间，单位毫秒，默认值为400 1）水平3栏布局
示例代码如下：
&lt;view style="display:flex;"&gt; &lt;view style='background-color:red;flex-grow:1;height:180rpx;'&gt; &lt;/view&gt; &lt;view style='background-color:blue;flex-grow:1;height:180rpx;'&gt; &lt;/view&gt; &lt;view style='background-color:green;flex-grow:1;height:180rpx;'&gt; &lt;/view&gt; &lt;/view&gt; 执行结果如下：
2）左右混合布局
示例代码如下：
&lt;view style='display:flex;height:400rpx;'&gt; &lt;view style='background-color:red;width:250rpx;color:#fff;'&gt;1 &lt;/view&gt; &lt;view style='flex-grow:1;display:flex;flex-direction:column;'&gt; &lt;view style='flex-grow:1;background-color:blue;color:#fff;'&gt;2 &lt;/view&gt; &lt;view style='flex-grow:1;background-color:green;color:#fff'&gt;3 &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 执行结果如下：
3）上下混合布局
示例代码如下：
&lt;view style="display:flex;flex-direction:column;height:400rpx;"&gt; &lt;view style='background-color:red;height:150rpx;color:#fff;'&gt;1 &lt;/view&gt; &lt;view style='flex-grow:1;display:flex;'&gt; &lt;view style="flex-grow:1;background-color:blue;color:#fff;"&gt;2 &lt;/view&gt; &lt;view style='flex-grow:1;background-color:green;color:#fff'&gt;3 &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 执行结果为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6d43f907f7efdec771c9518421cee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02b59ceb26dbe1852cac562a3d351c2/" rel="bookmark">
			Java 8 Stream findFirst（）和findAny（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java 8 Stream中， findFirst()返回Stream中的第一个元素，而findAny()返回Stream中的任何元素。 1. findFirst（） 1.1从整数流中找到第一个元素。 Java8FindFirstExample1.java package com.mkyong.java8; import java.util.Arrays; import java.util.List; import java.util.Optional; public class Java8FindFirstExample1 { public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 2, 1); Optional&lt;Integer&gt; first = list.stream().findFirst(); if (first.isPresent()) { Integer result = first.get(); System.out.println(result); // 1 } else { System.out.println("no value?"); } Optional&lt;Integer&gt; first2 = list .stream() .filter(x -&gt; x &gt; 1).findFirst(); if (first2.isPresent()) { System.out.println(first2.get()); // 2 } else { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d02b59ceb26dbe1852cac562a3d351c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861f7420a4ad68de68e5003593996828/" rel="bookmark">
			STM32--DMA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
DMA简介
DMA框图
DMA 优先级仲裁 FIFO阈值和burst模式传输
CUBEMX配置DMA使用
DMA_MEMORY_TO_MEMORY
DMA_PERIPH_TO_MEMORY DMA_MEMORY_TO_PERIPH
DMA 中断 环境：STM32CUBEMX V5.5 (F4固件包 V1.24.2) + MDK + STM32F407ZGT6 DMA简介 DMA:Direct Memory Access 直接存储器访问
DMA传输将数据从一个地址空间复制到另一个地址空间，当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实现和完成的 ，其作用，就是为CPU减负的。
STM32F4最多有2个DMA控制器（DMA2仅存在大容量产品中），2个DMA控制器总共有16个数据流（每个控制器8个）。每个数据流总共有8个通道，每个通道都有一个仲裁器，用于处理DMA请求间的优先级
DMA框图 DMA 优先级仲裁 仲裁器为两个 AHB 主端口（存储器和外设端口）提供基于请求优先级的 8 个 DMA 数据流请求管理，并启动外设/存储器访问序列。
优先级管理分为两个阶段：
● 软件：每个数据流优先级都可以在 DMA_SxCR 寄存器中配置。分为四个级别：
— 非常高优先级
— 高优先级
— 中优先级
— 低优先级
● 硬件：如果两个请求具有相同的软件优先级，则编号低的数据流优先于编号高的数据流。例如，数据流 2 的优先级高于数据流 4。
注意：因为一个 stream 只能配置一个 channel 。所以，确定 stream 的优先级就等于控制了 channel 的优先级
FIFO阈值和burst模式传输 FIFO 用于在源数据传输到目标之前临时存储这些数据。每个 stream 都有一个独立的 4 字 FIFO，阈值级别可由软件配置为 1/4、1/2、3/4 或满。合理的配置这些阈值级别和后面会提到的 burst length可以使搬运数据的效率相较于 direct模式更高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/861f7420a4ad68de68e5003593996828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e88f495e39c43a10bc1ad8a51b354076/" rel="bookmark">
			把 Excel 表转换成 json 对象，竟然如此简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【公众号回复 “1024”，免费领取程序员赚钱实操经验】
大家好，我是章鱼猫。
今天给大家推荐的这个项目是「excel2json」，把 Excel 表转换成 json 对象，并保存到一个文本文件中。
在游戏项目中一般都需要由策划制作大量的游戏内容，其中很大一部分是使用 Excel 表来制作的。于是程序就需要把 Excel 文件转换成程序方便读取的格式。
之前项目使用的 Excel 表导入工具都是通过 Office Excel 组件来实现数据访问的，效率十分令人不满。一个端游项目一般要上百个表格，手游项目 20、30 个表格基本也是要的，于是表格导入程序的过程一般要几分钟，项目后期要接近半个小时。这里分享的这个小工具，在速度上有质的飞越，比上述方法实现的工具有接近 100 倍的速度提升。
主要功能：
支持读取 Excel 97-2003 的 .xls 格式和 2007 的 .xlsx 格式
支持多个表单导出
把 Excel 表单转换成 Json 对象，并保存到一个文本文件中。支持将表中内容转换成 Array，或者以第一列为 ID 的字典对象
命令行参数：
-e, –excel Required，输入的Excel文件路径
-j, –json 指定输出的json文件路径
-h, –header (Default: 3)表格中有几行是表头
-c, –encoding (Default: utf8-nobom) 指定编码的名称
-l, –lowcase (Default: false) 自动把字段名称转换成小写格式
-a 序列化成数组
-d, –date:指定日期格式化字符串，例如：dd / MM / yyy hh: mm:ss
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e88f495e39c43a10bc1ad8a51b354076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b628427c2a19e67e7b64530b05385dde/" rel="bookmark">
			Python –如何将String转换为int
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，我们可以使用int()将String转换为int。 # String num1 = "88" # &lt;class 'str'&gt; print(type(num1)) # int num2 = int(num1) # &lt;class 'int'&gt; print(type(num2)) 1.例子 一个将两个数字相加的Python示例。 1.1直接添加两个String。 num1 = "1" num2 = "2" num3 = num1 + num2 print(num3) 输出量 12 1.2使用int()再试一次 num1 = "1" num2 = "2" # convert string to int num3 = int(num1) + int(num2) print(num3) 输出量 3 参考文献 Python文档– int（） Python –如何检查变量的类型？ 标签： 转换 python 翻译自: https://mkyong.com/python/python-how-to-convert-string-to-int/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea5141a045a12dc0697603fe4def36e/" rel="bookmark">
			设字符型变量 x 的值是 064，表达式....的值是
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引入分析进制转换~按位非运算符&lt;&lt;是左移运算符&amp;按位与运算符^按位异或运算符、|按位或运算符 解答第一步先算~x第二步x&lt;&lt; 2第三步208&amp;x第四步-53^16 坑点 引入 设字符型变量 x 的值是 064，表达式“~x^x&lt;&lt; 2&amp;x”的值是: A
A．0333 B．333 C．0x333 D．020
分析 我看到这个题，感觉考的很细，把不常用进制转换、运算符、优先级都考到了 进制转换 首先064代表的是8进制转换为十进制	4*8^0+6*8^1=52 ~按位非运算符 ~按位非运算符，我这里就不细分析了，讲一讲规律如果是 正数n，~n=-(n+1) 负数n，~-n=|-n+1| 比如~64=-65、~65=64 ~运算符的优先级位2 &lt;&lt;是左移运算符 &lt;&lt;是左移运算符，规律是：左移运算符 高位溢出，低位补0 举个例子：8&lt;&lt;2 00000....1000 00000....100000 8&lt;&lt;2 = 32 优先级是5 &amp;按位与运算符 &amp;按位与运算符优先级是高于逻辑与运算符的，它有一个口诀，同为1为1，否则为0 举个例子8&amp;10 ...1000 ...1010 ...1000 8&amp;10 = 8 &amp;的优先级是8 ^按位异或运算符、|按位或运算符 ^按位异或运算符，口诀是同位相同为0，否则为1(注意不要理解为同为0为0了) |按位或运算符你，口诀是有1个以上为1，就为1，否则为0 以8^10为例 ...1000 ...1010 ...0010 8^10 = 2 ^优先级为9级 |优先级为10级 解答 优先级 ~大于&lt;&lt;大于&amp;大于^ 第一步先算~x x是正数，-(52+1) = -53 第二步x&lt;&lt; 2 52&lt;&lt;2，我们先要得到52的二进制，除k取余法 000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ea5141a045a12dc0697603fe4def36e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2376727d20c224496fd99c72a73ff174/" rel="bookmark">
			七、键盘控制无人机 ·总（PX4与ROS关系以及仿真控制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记来源于开源项目：基于PX4和ROS的无人机仿真平台
来源于开源项目：GAAS
目录
一、PX4与ROS关系
二、XTDrone源码下载
三、用键盘控制无人机飞行
四、代码解读
一、PX4与ROS关系 注意各端口（UPD port）
或者看下面的这个图的表示关系！我们一般在offboard模式下通过外部程序完成我们给无人机的任务
二、XTDrone源码下载 XTDrone是一个开源项目，目前支持多旋翼飞行器（multirotor）、固定翼飞行器（plane）、可垂直起降固定翼飞行器（vtol）以及车辆（rover）四个大类机型，multirotor下有iris、solo和typhoon_h480三个机型，vtol下有tailsitter、quadplane和tiltrotor三个机型，plane和rover没有下属机型。
git clone https://gitee.com/robin_shaun/XTDrone.git cd XTDrone cp sitl_config/init.d-posix/rcS ~/PX4_Firmware/ROMFS/px4fmu_common/init.d-posix/ cp sitl_config/worlds/* ~/PX4_Firmware/Tools/sitl_gazebo/worlds/ cp -r sitl_config/models/* ~/.gazebo/models/ cp sitl_config/launch/* ~/PX4_Firmware/launch/ #下面这一条是我自己加上去的，我认为是需要的（在后面的程序中） cp sitl_config/models/* ~/PX4_Firmware/Tools/sitl_gazebo/models/ 三、用键盘控制无人机飞行 one terminal：（启动gazebo，出现了场景和飞机）
cd ~/PX4_Firmware roslaunch px4 indoor1.launch second terminal：（启动通信脚本，iris代表子机型，0代表飞机的编号，与0号iris建立通信）
cd ~/XTDrone/communication/ python multirotor_communication.py iris 0 third terminal：（启动键盘控制脚本，iris代表机型，1代表飞机的个数，vel代表速度控制）
cd ~/XTDrone/control/ python multirotor_keyboard_control.py iris 1 vel 虽然多旋翼飞机提供了速度控制和加速度控制的两种键盘控制方式，但是速度的方便一点，加速度在后面的高级运动规划任务中比较有用。
注意注意，下面这个是键盘控制的方法，不然你可能不会调试飞机，飞起来不会动或者怎么样：
按 i，（多按几次） 把z方向的速度调试到0.3m/s以上（有没有记得前面有说到过那个pwm控制在0.5到1之间，不能从0开始，我感觉可能和这个有关系）按b，切换到offboard模式按t，解锁，飞机起飞飞机飞到合适的高度后，按s实现飞机的悬停w/x：控制前进的速度a/d：控制左右移动的速度i/，：控制上升下降的速度j / l：控制偏航的角度（旋转视角） 四、代码解读 这里打开了三个终端，分别打开了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2376727d20c224496fd99c72a73ff174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5468200ae2dc7b7ebf66ee5c7f0bf2a3/" rel="bookmark">
			tcp_keepalive的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
1.参数设置 **
查看相关的参数
sysctl -a|grep tcp_keepalive net.ipv4.tcp_keepalive_intvl = 30 net.ipv4.tcp_keepalive_probes = 2 net.ipv4.tcp_keepalive_time = 160 设置相关的参数
sysctl -w net.ipv4.tcp_keepalive_time = 7500 也可以直接打开/etc/sysctl.conf
加入net.ipv4.tcp_keepalive_time = 7500，然后保存退出
让参数生效
sysctl -p **
2.参数相关的说明 **
/proc/sys/net/ipv4/tcp_keepalive_time
当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时。
/proc/sys/net/ipv4/tcp_keepalive_intvl
当探测没有确认时，重新发送探测的频度。缺省是75秒。
/proc/sys/net/ipv4/tcp_keepalive_probes
在认定连接失效之前，发送多少个TCP的keepalive探测包。缺省值是9。这个值乘以tcp_keepalive_intvl之后决定了，一个连接发送了keepalive之后可以有多少时间没有回应
tcp_keepalive_time ：INTEGER
默认值是7200(2小时)
当keepalive打开的情况下，TCP发送keepalive消息的频率。(由于目前网络攻击等因素,造成了利用这个进行的攻击很频繁,曾经也有cu的朋友提到过,说如果2边建立了连接,然后不发送任何数据或者rst/fin消息,那么持续的时间是不是就是2小时,空连接攻击? tcp_keepalive_time就是预防此情形的.我个人在做nat服务的时候的修改值为1800秒)
tcp_keepalive_probes：INTEGER
默认值是9
TCP发送keepalive探测以确定该连接已经断开的次数。(注意:保持连接仅在SO_KEEPALIVE套接字选项被打开是才发送.次数默认不需要修改,当然根据情形也可以适当地缩短此值.设置为5比较合适)
tcp_keepalive_intvl：INTEGER
默认值为75
探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒，也就是没有活动的连接将在大约11分钟以后将被丢弃。(对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)
$ /proc/sys/net/ipv4/tcp_keepalive_time
$ /proc/sys/net/ipv4/tcp_keepalive_intvl
$ /proc/sys/net/ipv4/tcp_keepalive_probes
这3个参数与TCP KeepAlive有关.默认值是:
tcp_keepalive_time = 7200 seconds (2 hours) tcp_keepalive_probes = 9 tcp_keepalive_intvl = 75 seconds 意思是如果某个TCP连接在idle 2个小时后,内核才发起probe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5468200ae2dc7b7ebf66ee5c7f0bf2a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1c8f56b8909db06e58ea5250f91ccc/" rel="bookmark">
			Maya Python调用Maya窗口选择文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在脚本中如果需要调用一些外部文件或者导出文件，需要获取文件路径等，需要打开文件选择的窗口，这介绍如何调用Maya窗口来选择文件，并获取文件路径
相关文档 文档：http://help.autodesk.com/view/MAYAUL/2019/CHS/?guid=__CommandsPython_index_html，选择fileMode
官方例程 import maya.cmds as cmds basicFilter = "*.mb" cmds.fileDialog2(fileFilter=basicFilter, dialogStyle=2) singleFilter = "All Files (*.*)" cmds.fileDialog2(fileFilter=singleFilter, dialogStyle=2) multipleFilters = "Maya Files (*.ma *.mb);;Maya ASCII (*.ma);;Maya Binary (*.mb);;All Files (*.*)" cmds.fileDialog2(fileFilter=multipleFilters, dialogStyle=2) 我的使用 文档中两种，fileDialog和fileDialog2，此处使用fileDialog2
如下
import maya.cmds as cmds basicFilter = "*.txt" path = cmds.fileDialog2(fileFilter=basicFilter, dialogStyle=2, fileMode=0) print path https://blog.csdn.net/shaynerain/article/details/106426818
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c28e7d83cad9f9f3cd6648203eaa409/" rel="bookmark">
			Linux下CLOSE-WAIT过多分析与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看链接状态
netstat -ant|awk '/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}' 情景描述：系统产生大量“Too many open files”
原因分析：在服务器与客户端通信过程中，因服务器发生了socket未关导致的closed_wait发生，致使监听port打开的句柄数到了1024个，且均处于close_wait的状态，最终造成配置的port被占满出现“Too many open files”，无法再进行通信。
close_wait状态出现的原因是被动关闭方未关闭socket造成，如附件图所示：
解决办法：有两种措施可行
一、解决：
原因是因为调用ServerSocket类的accept()方法和Socket输入流的read()方法时会引起线程阻塞，所以应该用setSoTimeout()方法设置超时（缺省的设置是0，即超时永远不会发生）；超时的判断是累计式的，一次设置后，每次调用引起的阻塞时间都从该值中扣除，直至另一次超时设置或有超时异常抛出。
比如，某种服务需要三次调用read()，超时设置为1分钟，那么如果某次服务三次read()调用的总时间超过1分钟就会有异常抛出，如果要在同一个Socket上反复进行这种服务，就要在每次服务之前设置一次超时。
二、规避：
调整系统参数，包括句柄相关参数和TCP/IP的参数；
注意：
/proc/sys/fs/file-max 是整个系统可以打开的文件数的限制，由sysctl.conf控制；
ulimit修改的是当前shell和它的子进程可以打开的文件数的限制，由limits.conf控制；
lsof是列出系统所占用的资源,但是这些资源不一定会占用打开文件号的；比如：共享内存,信号量,消息队列,内存映射等,虽然占用了这些资源,但不占用打开文件号；
因此，需要调整的是当前用户的子进程打开的文件数的限制，即limits.conf文件的配置；
如果cat /proc/sys/fs/file-max值为65536或甚至更大，不需要修改该值；
若ulimit -a ；其open files参数的值小于4096（默认是1024), 则采用如下方法修改open files参数值为8192；方法如下：
1.使用root登陆，修改文件/etc/security/limits.conf
vi /etc/security/limits.conf 添加
xxx - nofile 8192
xxx 是一个用户，如果是想所有用户生效的话换成 * ，设置的数值与硬件配置有关，别设置太大了。
#&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt; * soft nofile 8192 * hard nofile 8192 #所有的用户每个进程可以使用8192个文件描述符。
2.使这些限制生效
确定文件/etc/pam.d/login 和/etc/pam.d/sshd包含如下行：
session required pam_limits.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c28e7d83cad9f9f3cd6648203eaa409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f083a9961de2afda2c2f3b5ac2985c/" rel="bookmark">
			Maya Python设置当前动画进度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置动画进度，即当前的播放位置，总的来说是设置的当前帧
文档：http://help.autodesk.com/view/MAYAUL/2019/CHS/?guid=__CommandsPython_index_html
如下，设置在第30帧位置
import maya.cmds as cmds cmds.currentTime(30) https://blog.csdn.net/shaynerain/article/details/106426502
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c26c9010834045f90e7b32b11f7960ca/" rel="bookmark">
			【计算机网络】网络层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络层 虚拟互联网络 IP协议使得复杂的实际网络变成一个虚拟的互连网络IP协议可以使得网络层屏蔽底层细节而专注网络层的数据转发IP协议解决了在虚拟网络中数据报传输路径的问题 IP数据报格式 对于IP协议的头部，前五行为固定部分，第六行可有可无，第七行为数据报，前五行每行都有32个比特，也就是四个字节，所以IP头部至少有20个字节长度。
版本 : 有 4（IPv4）和 6（IPv6）两个；首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节，也就是首部最大长度为60个字节。区分服务 : 用来获得更好的服务，一般情况下不使用。总长度 : 占16位，最大长度为65535，表示的IP数据报长度（包括首部长度和数据部分长度）。标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。TTL：占8位，表示IP数据报文在网络中的寿命，每经过一个设备，TTL减一，当 TTL 为 0 时就丢弃数据报。协议：占8位，表明IP数据具体所携带的协议（TCP,UDP等） 路由表简介 IP协议的转发流程 （1）从网络层看待转发过程
（2）从网络层和数据链路层来看待转发过程
数据帧每一跳MAC地址都在发生变化IP数据报每一跳的IP地址始终不变 ARP协议（了解） ARP 实现由 IP 地址得到 MAC 地址。
而它的实现有两种情况：
1.ARP缓存表有缓存IP地址和MAC地址的映射关系
则在上文中的转发过程中A可直接告诉E的MAC地址
2…ARP缓存表没有缓存IP地址和MAC地址的映射关系
IP地址的子网划分 一 分类的IP地址
（1）特殊的主机号
主机号全0，表示当前网络段，不可分配为特定主机主机号全为1，广播地址，向当前网络段所有主机发送消息 （2）特殊网络号
A类地址：网络号全0 ，表示特殊网络；网络号后7位全为1，表回环地址B类地址：网络号为128.1不可使用C类地址：网络号为192.0.0不可使用D类地址：1110…E类地址：1111… 二 子网划分
为什么要子网划分？
首先来看一个问题，
某公司有100名员工，每人配备一台计算机，请问该公司应该申请哪种网络段？
从表格来看，C类地址申请是最节约IP地址的，但是254个主机号只有100个被使用，这就造成了IP地址的空间浪费，所以提出了子网划分的概念。
如上图，对C类地址193.10.10.0进行子网划分，可以划分为两个子网，第25位是定义子网，主机号后七位是定义主机，子网号这么多，有没有什么办法可以快速判断某个IP地址的网络号（也就是子网号）
这里就引入子网掩码，默认初始值子网的子网掩码具备网络号位数个连续的1，一个 B 类地址的默认子网掩码为 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c26c9010834045f90e7b32b11f7960ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/423f3d0e3d211c3a922e7b619c4ba74b/" rel="bookmark">
			js数据处理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据处理方法 数组： 1、数值保留多少位
/** * 数值保留多少位 * @param {Number} num 数值 * @param {Number} pointLen 保留位数 */ export const toFixed = (num, pointLen) =&gt; { //num---要处理的值 pointLen----需要保留的小数位 if (!num) return num; if (num.toString().indexOf('.') &lt; 0) return parseFloat(num); // 是整数直接返回 return parseFloat(num).toFixed(pointLen); }; 2、js字符串与数字混合的字符串排序要求先字符后数字
var list = ['abc123', 'abc11', 'abc2'] var list2 = [] list2 = list.sort(function(a, b) { return a.localeCompare(b, 'zh-CN', { numeric: true }) }) console.log(list2) //["abc2", "abc11", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/423f3d0e3d211c3a922e7b619c4ba74b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0104ae7d677a670853af0de96cdf391/" rel="bookmark">
			nginx部署vue项目出现404查找不到js，css文件解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx部署vue项目出现查找不到js，css文件解决方法
1.先测试你的vue文件本地是否正常显示打开，正常再进行第二步，否则是你vue打包后的文件出现错误了
2.测试nginx是否正常，可以在ftp中查找你vue项目中的文件，浏览器打开nginx打开那个文件，能正常打开则进入第三部，否则就是你nginx配置问题，nginx无法映射此vue文件夹
3.重新配置一个新的nginx的conf文件，
# 前端vue转发 location / { root /data/frontend/dist; index index.html; #启动文件 try_files $uri $uri/ /index.html; #解决刷新404 expires 48h; access_log off; } 将你得vue生成的dist文件直接指向/目录，然后能正常访问的话，就是你之前nginx的 location的配置问题，请重新配置
4.最终如果无法理解nginx配置的话，一律将location 中/ 对应vue中dist文件，不要弄什么/static 对应vue的dist文件
以下为完整的参考文件
server { listen 8004; server_name 127.0.0.1; charset utf-8; access_log on; # 前端vue转发 location / { root /data/frontend/dist; index index.html; #启动文件 try_files $uri $uri/ /index.html; #解决刷新404 expires 48h; access_log off; } location ~* \.(gif|jpg|jpeg|png|css|js|ico|css|eot|svg|ttf|woff|mov)$ { root /data/frontend/dist; expires 48h; access_log off; } location /api { #uwsgi_pass manage; #uwsgi_send_timeout 600; #uwsgi_connect_timeout 600; #uwsgi_read_timeout 600; proxy_pass http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0104ae7d677a670853af0de96cdf391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ec4f548b67c9e9a1067e7ae8b21db9b/" rel="bookmark">
			MySQL binlog指定时间恢复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看最近的binlog日志
show master status\G; 查看所有的binlog日志
show master logs; 指定时间点恢复数据 -----&gt;导出为sql文件
/usr/local/mysql/bin/mysqlbinlog /usr/local/mysql/var/mysql-bin.000008 --start-datetime='2020-05-29 09:00:00' --stop-datetime='2020-05-29 11:00:00' -r ./a.sql 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28bb11ccee50f0988704e5fb5309a4c2/" rel="bookmark">
			基于spring-security-oauth2实现oauth2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码地址 基于springboot2.1.5，springcloud Greenwich版本实现,该系列分为两个部分：分为内存实现，数据库实现。其中数据库实现采用RBAC权限角色管理。
首先声明oauth2是一种协议规范，spring-security-oauth2是对他的一种实现。其次，还有shiro实现，自己根据规范编写代码的实现方式。主流的qq，微信等第三方授权登录方式都是基于oauth2实现的。
oauth2的认证方式有授权码，简单，账户密码，客户端等方式，具体请自行百度不做过多的阐述。 本文基于授权码方式实现
oauth生态设计的范围很大，可以说是一种解决方案，它有“第三方客户端（web服务，APP服务）”、“用户”、“认证服务器”、“资源服务器”等部分。认证流程如下图：
(A）用户打开客户端以后，客户端要求用户给予授权。
（B）用户同意给予客户端授权。
（C）客户端使用上一步获得的授权，向认证服务器申请令牌。
（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。
（E）客户端使用令牌，向资源服务器申请获取资源。
（F）资源服务器确认令牌无误，同意向客户端开放资源。
现在开始实现基于内存的认证服务编写：
（1）使用idea在nacos-test项目中创建authserver-memory模块。
目录如下图：
（2）创建好module之后，我们开始配置pom文件加载依赖。
注意：springcloud的版本1.x和2.x差别很大，有很多不兼容，例如jpa1.x的findOne方法在2.x版本中不能使用。因为我们需要先配置依赖管理
spring-cloud-Alibaba一起配置好了，现在添加oauth2的依赖，因为我们使用springcloud，并且springcloud-security为我们封装好了oauth2，
因次我们只添加这个依赖就可以
（3）依赖添加完成，下面我们开始写代码，创建config包，因为，我们认证之前需要先校验用户的账户密码是否正确，所以我们先配置WebSecurityConfig拦截：
在config方法里，我们在内存中，配置了两个用户，这里注意密码用了BCryptPasswordEncoder进行加密，在springboot2.x中不加密会报错的。
（4）到这里，用户验证已经完成，我们创建AuthConfig配置认证拦截处理：
需要添加 @EnableAuthorizationServer注解开启认证服务，注入加密用的BCryptPasswordEncoder实例。然后，配置需要认证的客户端，
这里需要细说一下，首先是client_id代表是哪个客户端也就是哪个APP或者web服务需要认证的，然后是客户端的secret秘钥需要加密，
authorizedGrantTypes授权方式指的是授权码，简单，客户端，账户密码等，这里使用的是授权码（authorization_code），然后是scopes范围，
redirectUris重定向地址，就是你的登录地址，授权后跳转的地址。
（5）配置application.properties文件：
启动应用:
成功，我们用这个地址进行授权访问：
http://localhost:9000/oauth/authorize?client_id=client&amp;response_type=code
成功后，跳转到登录页面：
输入账户：admin 密码： 123456 点登录
选择approve点击Authorize认证
这个code就是授权码
我们打开postman用post方式获取access_token
这个client就是配置的client_id,secret就是配置的secret，返回access_token
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8367b85aa59416cca0f18500c9234764/" rel="bookmark">
			ADC采样频率的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为又要做和毕设相关的内容，发现答辩时候老师特别喜欢问采样频率，那么ADC的采样频率是多少呢？
因为做的压力传感器阻值变化的ADC采集 再通过标定公式转换成压力值。
首先补充一下： ADC的中转换时间是 Tconv = 采样时间 + 12 个周期 当然也有说是+12.5个周期的 ，但是大概是这个数，我的资料上12 所以暂时用12个周期。
那个采样时间 根据库函数发现一般有：
/** @defgroup ADC_sampling_times * @{ */ #define ADC_SampleTime_3Cycles ((uint8_t)0x00) #define ADC_SampleTime_15Cycles ((uint8_t)0x01) #define ADC_SampleTime_28Cycles ((uint8_t)0x02) #define ADC_SampleTime_56Cycles ((uint8_t)0x03) #define ADC_SampleTime_84Cycles ((uint8_t)0x04) #define ADC_SampleTime_112Cycles ((uint8_t)0x05) #define ADC_SampleTime_144Cycles ((uint8_t)0x06) #define ADC_SampleTime_480Cycles ((uint8_t)0x07) #define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_3Cycles) || \ ((TIME) == ADC_SampleTime_15Cycles) || \ ((TIME) == ADC_SampleTime_28Cycles) || \ ((TIME) == ADC_SampleTime_56Cycles) || \ ((TIME) == ADC_SampleTime_84Cycles) || \ ((TIME) == ADC_SampleTime_112Cycles) || \ ((TIME) == ADC_SampleTime_144Cycles) || \ ((TIME) == ADC_SampleTime_480Cycles)) /** * @} */ 3个、15个、28个、56个、84个、112个、144个、480个。一般情况不单纯追求采样频率，采样周期越长，信息越真实，提高精确度。我发现之前的程序选的是480个采样周期 u16 Get_Adc2(u8 ch,u8 nb) { //设置指定ADC的规则组通道，一个序列，采样时间 ADC_RegularChannelConfig(ADC2, ch, 1, ADC_SampleTime_480Cycles );	//ADC1,ADC通道,480个周期,提高采样时间可以提高精确度	ADC_SoftwareStartConv(ADC2);	//使能指定的ADC1的软件转换启动功能	while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8367b85aa59416cca0f18500c9234764/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8310946f07fe37c571eb47b39986ef29/" rel="bookmark">
			输入一个大于3的整数，判断它是否为素数（prime，又称质数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main() { int n,i=2; printf("请输入一个数n:\n"); scanf("%d",&amp;n); for(i=2;i&lt;=n-1;i++) if(n%i==0) break; if(i&lt;n) printf("该数不是质数"); else printf("该数是质数"); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d2c0087979f4e691d8d88367492b7a/" rel="bookmark">
			shiro笔记之----SimpleAuthenticationInfo 验证password
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司项目中用的是shiro做安全认证框架，从代码中看到了判断验证码的，也看到了判断用户名是否存在的，就是没有发现判断密码是否正确的，后从网上文章以及查看源码才大概了解shiro对于密码验证的流程。
自定义的shiroRealm public class ShiroRealm extends AuthorizingRealm { @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { // 第一步从token中取出用户名 String userName = (String) token.getPrincipal(); // 第二步：根据用户输入的userName从数据库查询 User user = userService.findByUsername("userName");	if(user==null){ return null;//用户不存在 } //第三步 从数据库取该用户的passw String password = user.getPassword(); // 第四步 加盐 String salt = userCode; .......其他判断逻辑...... // 第五步 创建SimpleAuthenticationInfo SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(user,password,ByteSource.Util.bytes(salt), this.getName()); //第六步 返回 return simpleAuthenticationInfo;// return的过程完成 password的验证 } } 注意：最后的return simpleAuthenticationInfo 的时候就会触发password验证。
我们要知道一个继承关系
shiroRealm-----&gt;AuthorizingRealm----&gt;AuthenticatingRealm
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27d2c0087979f4e691d8d88367492b7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8249e68de6e9c8c32ad6fc3168978d6/" rel="bookmark">
			Delaunay三角剖分算法初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Delaunay三角网在空间邻近分析上是一种较好的支持模型, 广泛应用于空间聚类、多边形群的合并、人像关键点提取、形态分析中。
问题：一堆二维点中寻找一个与目标点最近(欧氏距离最小)的点。
1. 三角剖分与Delaunay剖分的定义 如何把一个散点集合剖分成不均匀的三角形网格，这就是散点集的三角剖分问题，散点集的三角剖分，对数值分析以及图形学来说，都是极为重要的一项预处理技术。该问题图示如下：
1.1. 三角剖分定义 【定义】三角剖分：假设V是二维实数域上的有限点集，边e是由点集中的点作为端点构成的封闭线段, E为e的集合。那么该点集V的一个三角剖分T=(V,E)是一个平面图G，该平面图满足条件：
除了端点，平面图中的边不包含点集中的任何点。没有相交边。平面图中所有的面都是三角面，且所有三角面的合集是散点集V的凸包。 1.2. Delaunay三角剖分的定义 在实际中运用的最多的三角剖分是Delaunay三角剖分，它是一种特殊的三角剖分。先从Delaunay边说起：
【定义】Delaunay边：假设E中的一条边e（两个端点为a,b），e若满足下列条件，则称之为Delaunay边：存在一个圆经过a,b两点，圆内(注意是圆内，圆上最多三点共圆)不含点集V中任何其他的点，这一特性又称空圆特性。
【定义】Delaunay三角剖分：如果点集V的一个三角剖分T只包含Delaunay边，那么该三角剖分称为Delaunay三角剖分。
1.3.Delaunay三角剖分的准则 要满足Delaunay三角剖分的定义，必须符合两个重要的准则：
空圆特性：Delaunay三角网是唯一的（任意四点不能共圆），在Delaunay三角形网中任一三角形的外接圆范围内不会有其它点存在。如下图所示：
最大化最小角特性：在散点集可能形成的三角剖分中，Delaunay三角剖分所形成的三角形的最小角最大。从这个意义上讲，Delaunay三角网是“最接近于规则化的“的三角网。具体的说是指在两个相邻的三角形构成凸四边形的对角线，在相互交换后，六个内角的最小角不再增大。如下图所示：
1.4.Delaunay三角剖分的特性 以下是Delaunay剖分所具备的优异特性：
最接近：以最近临的三点形成三角形，且各线段(三角形的边)皆不相交。唯一性：不论从区域何处开始构建，最终都将得到一致的结果。最优性：任意两个相邻三角形形成的凸四边形的对角线如果可以互换的话，那么两个三角形六个内角中最小的角度不会变大。最规则：如果将三角网中的每个三角形的最小角进行升序排列，则Delaunay三角网的排列得到的数值最大。区域性：新增、删除、移动某一个顶点时只会影响临近的三角形。具有凸多边形的外壳：三角网最外层的边界形成一个凸多边形的外壳。 1.5.局部最优化处理 理论上为了构造Delaunay三角网，Lawson提出的局部优化过程LOP(Local Optimization Procedure)，一般三角网经过LOP处理，即可确保成为Delaunay三角网，其基本做法如下所示：
将两个具有共同边的三角形合成一个多边形。以最大空圆准则作检查，看其第四个顶点是否在三角形的外接圆之内。如果在，修正对角线即将对角线对调，即完成局部优化过程的处理。
LOP处理过程如下图所示： 2.Delaunay剖分的算法 Delaunay剖分是一种三角剖分的标准，实现它有多种算法。
2.1.Lawson算法 逐点插入的Lawson算法是Lawson在1977年提出的，该算法思路简单，易于编程实现。基本原理为：首先建立一个大的三角形或多边形，把所有数据点包围起来，向其中插入一点，该点与包含它的三角形三个顶点相连，形成三个新的三角形，然后逐个对它们进行空外接圆检测，同时用Lawson设计的局部优化过程LOP进行优化，即通过交换对角线的方法来保证所形成的三角网为Delaunay三角网。
上述基于散点的构网算法理论严密、唯一性好，网格满足空圆特性，较为理想。由其逐点插入的构网过程可知，遇到非Delaunay边时，通过删除调整，可以构造形成新的Delaunay边。在完成构网后，增加新点时，无需对所有的点进行重新构网，只需对新点的影响三角形范围进行局部联网，且局部联网的方法简单易行。同样，点的删除、移动也可快速动态地进行。但在实际应用当中，这种构网算法当点集较大时构网速度也较慢，如果点集范围是非凸区域或者存在内环，则会产生非法三角形。
2.2.Bowyer-Watson算法 Lawson算法的基本步骤是：
1. 构造一个超级三角形，包含所有散点，放入三角形链表。
2. 将点集中的散点依次插入，在三角形链表中找出其外接圆包含插入点的三角形（称为该点的影响三角形），删除影响三角形的公共边，将插入点同影响三角形的全部顶点连接起来，从而完成一个点在Delaunay三角形链表中的插入。
3. 根据优化准则对局部新形成的三角形进行优化。将形成的三角形放入Delaunay三角形链表。
4. 循环执行上述第2步，直到所有散点插入完毕。
这一算法的关键的第2步图示如下：
Ref:
[图形算法]Delaunay三角剖分算法
https://zhuanlan.zhihu.com/p/42331420
scipy API - scipy.spatial.Delaunay
python示例： 用 Python 实现 Delaunay Triangulation。
how-to-set-a-maximum-distance-of-a-delaunay-triangle-side 最大边长
# # http://fangs.in/post/python/pythondelaunay/ # from scipy.spatial import Delaunay import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8249e68de6e9c8c32ad6fc3168978d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1946fd3069d3ef658b10fca2f88ffc2e/" rel="bookmark">
			R语言学习9-读取表格数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次课程，我们学习R中用于读取表格数据的reader包的一些基本功能。
有关readr的详细介绍，可以参考*《Mastering Software Development in R》*的1.3节。
读取 在本课程中，我们将使用美国邮政编码上的一个小型数据集。 该表包含有关美国人口普查局发布的城市邮政编码的百分比的信息。
首先，我们使用library()函数载入readr包。
&gt; library(readr) 我们将读入R的文件为urban.csv.gz。 这是用gzip压缩的，逗号分隔值(csv)文本文件。
urban.csv.gz数据文件所在的目录保存在一个名为datapath的R对象中。
让我们使用file.path()函数构造urban.csv.gz文件的完整路径，并将其存储在名为datafile的对象中。然后使用read_csv()函数读取文件，将结果保存到urban变量。
&gt; datafile &lt;- file.path(datapath, 'urban.csv.gz') &gt; urban &lt;- read_csv(datafile) Parsed with column specification: cols( state = col_character(), zcta5 = col_double(), County = col_character(), PctUrban = col_double(), FIPS = col_character() ) 现在我们可以用head()函数看urban数据的前几列。
&gt; head(urban) # A tibble: 6 x 5 state zcta5 County PctUrban FIPS &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; 1 01 35004 St. Clair AL 64 01115 2 01 35005 Jefferson AL 79.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1946fd3069d3ef658b10fca2f88ffc2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c949e93526bbc4addc6279cda1f67490/" rel="bookmark">
			关于AUC一些笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于AUC一些笔记 首先先理解一些其他概念真阳率，假阳率敏感度，特异度精度，召回率准确率ROC曲线 AUC值是怎么计算AUC的范围大小评估 首先先理解一些其他概念 其实真阳=召回率=敏感度
以下的分母中的非/患者表示实际的非/患者
真阳患者表示我们判断为患者实际也是患者
假阳表示我们判定为患者实际为非患者，即我个人认为这个真阳假阳中的阳为判定结果，而真或假为判定的正确性，即可推导出原先的实际状况
真阳率，假阳率 真阳率=真阳患者/患者
假阳率=假阳患者/非患者
敏感度，特异度 敏感度=真阳患者/患者
特异度=真阴患者/非患者=1-假阳率
精度，召回率 精度=真阳/判为患者人数
召回率=真阳患者/患者
准确率 （真阳+真阴）/（患者+非患者）
ROC曲线 ROC曲线就是横坐标为假阳性，纵坐标为真阳性的一个线，而AUC则是这条线与x轴围成的面积
注意ROC曲线不应用于权重不相等的分类器中
AUC值是怎么计算 具体可以参考：https://www.bioinfo-scrounger.com/archives/767/（非原作者，非常感谢这篇博客）是怎么说明的
大概思路有二种：
其一是：计算出每个样本的类别概率然后选定阈值，得出预测为正样本和负样本的标签，根据预测标签和真实标签就可以计算真阳率、假阳率等，然后将真实标签的正样本和负样本的类别概率两两组合，并计算正样本的类别概率大于负样本的类别概率的比例，即为AUC值
其二是：利用秩次关系
对score从到小排序，最大的score排序索引为n，最小的则为1；然后将正例的索引求和，减去正例-正例这种组合的个数M*(M+1)/2；最后除以M*N。
AUC的范围大小评估 这边参照这篇微信文章，取自截图https://mp.weixin.qq.com/s/S2yHZCrjaSxw386N6ziz5w
按个人理解而言，这边的AUC范围并不是固定的，因为跟数据有关，有的数据比较差的话，可能模型能达到的最优AUC也就0.8左右，所以此时强行按图观察的话可能会有误
以上均为个人理解，有误请指正，也不知道咋转载或是跟原博客说，侵删
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3bab0f9a6ec15b3d2d40557bfbbc2b/" rel="bookmark">
			google sheet  API php
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		google sheet API php 1 首先第一点 弄清楚
A 你是通过API 接口操作自己账号的google sheet
B 别人给你权限 你去操作别人的google sheet
两个方法获取的授权不同 A 你是通过API 接口操作自己账号的google sheet
官方链接 https://developers.google.com/sheets/api/quickstart/php
1 自己填写 然后会下载下一个 credentials.json 这个文件 放在的工作目录
2 可以直接去下载代码
链接 https://github.com/googleapis/google-api-php-client/releases
我下载的是2.4.1
3 复制此段代码 放到你的工作目录
注意这里
目前是只读权限 如果是你自己的 你可以更改为
$client-&gt;setScopes(Google_Service_Sheets::SPREADSHEETS);
这个是所有的权限
4 去命令行执行
运行 第三步的文件
这里是故障排查
必须是 ssl
运行完成后 会在工作目录生成一个 token.json 文件
目前位置 自己google sheet的授权操作 已完成
但是文件不能直接去浏览器运行 暂时无解
这里有操作的示例 自己看下 不做说明
B 别人给你权限 你去操作别人的google sheet
1 去上面的第二步 下载源文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a3bab0f9a6ec15b3d2d40557bfbbc2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f632d77b598c7c885cd8298d33edefc/" rel="bookmark">
			找出最小的值：输入一个正整数 n, 再输入 n 个整数，输出最小 值。试编写相应程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 引入 找出最小的值：输入一个正整数 n, 再输入 n 个整数，输出最小 值。试编写相应程序。
分析 思考：之前我们都是在循环输入正整数，但是这里需要比较前后两个数的大小，怎么办？
我们需要在循环之外先输入一个数设置为最小数，循环里面的&lt;=要改为&lt;,在与循环里面输入的数比较换值找出最小数
代码 #include &lt;stdio.h&gt; int main () { /** 找出最小的值：输入一个正整数 n, 再输入 n 个整数，输出最小 值。试编写相应程序。 */ //输入一个正整数 int n; scanf("%d",&amp;n); //思考:循环输入数的话，前一个数怎么与后一个数比较 //所以我们可以把第一个数在循环之外输入，循环的&lt;=改为&lt; int num,i,min; scanf("%d",&amp;num); min = num; for(i = 1; i &lt; n; i++){ scanf("%d",&amp;num); //换值操作 if(min &gt; num){ min = num; } } //打印n个数中最小的数 printf("min = %d\n",min); return 0; } 运行测试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f7710007040ced341b650b43eeb43a7/" rel="bookmark">
			（C语言，慕课）矩阵的转置运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目内容：
编写程序，将一个n×n（）的矩阵进行转置，即将行与列互换，转置后再按n×n矩阵形式输出。
输入格式:
输入整数n，从第2行开始依次输入n*n个整数，各数以一个空格分隔。
输出格式：
按n行n列的形式输出转置后的二维数组，每个元素占4列，采用右对齐（即在左补空格），行末无空格。
输入样例：
3
1 2 3 4 5 6 7 8 9
输出样例：
1 4 7
2 5 8
3 6 9
#include&lt;stdio.h&gt; int main() { int a,i,j,num[10][10]; scanf("%d",&amp;a); for(j=0;j&lt;a;j++) { for(i=0;i&lt;a;i++) { scanf("%d ",&amp;num[i][j]); } } for(i=0;i&lt;a;i++) { for(j=0;j&lt;a;j++) { printf("%4d",num[i][j]); } printf("\n"); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a532dcedb1e9e2d964c713c67f61232e/" rel="bookmark">
			【菜鸟进阶之路】P5461 赦免战俘 题解笔记（持更）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、这题和杨辉三角很像，可以找规律：每一个数字都是它上方数字加上右上方数字再模2。
（1）2的n次方可以用二进制数左移的方式；
C语言中1＜＜n是什么意思
（2）register声明的变量会被放到CPU的寄存器里，不用从内存取，用时更短；
register int的使用
（3）C++中的a^b为按位异或，异或根据计算位是否相同决定结果位，如果相同结果位为0，否则为1。
2、赦免的函数是对称的，f(i,j)=f(j,i)，可考虑用位运算，发现 i|j=111(7)，得出以下判断式：
f(i,j)=((i|j)!=((1&lt;&lt;n)-1)?0:1)。
3、本题基本思路是分治，代码可以通过递归来实现（好写但用时长），每次递归将左上方的正方形清零，并再次递归剩余的三个正方形，当正方形的边长为2时结束递归。
4、找规律，然后打表。
（1）C 库函数 double pow(double x, double y) 返回 x 的 y 次幂；
C 库函数 - pow()
5、核心思想（方法）：求下一个方阵的情况，逐行逐行的将当前方阵情况插入下方（在下面复制两次），最后再补0。
（1）头文件 #include &lt; string &gt; 里有一个本题特别重要的函数—— insert() 函数
C++中的insert()函数
（2）copy下洛谷 @渊源 大佬有趣的AC算法（转侵删）
a[0]="01"; //第一行情况 a[1]="11"; //第二行情况 for(long I=2;I&lt;=n;I++){ //现在是第几个方阵（即求输入I的输出结果）（**分治思想**） for(long i=A[I-1];i&lt;A[I];i++){ //新增行的行号（是第几行） a[i].insert(a[i].length(),a[i-A[I-1]]); //在新一行尾部插入 a[i].insert(a[i].length(),a[i-A[I-1]]); //**插入两次** } for(long i=0;i&lt;A[I-1];i++) //在头几行最前面插入A[I-1]个0（应该不需要解释了吧） for(long j=0;j&lt;A[I-1];j++) //字符串**存储时不带空格，输出才带空格** a[i].insert(0,"0"); } 原博客：题解 P5461 【赦免战俘】
6、找规律：
首先n要先变成2^n。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a532dcedb1e9e2d964c713c67f61232e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99aeb4834944c6f03a5935bbab97e345/" rel="bookmark">
			Arrays.sort()对String，int，double等数组进行排序的实际应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看到了一个非常有意思而且有用的问题：Arrays.sort()为什么可以对String，int，double等数组进行排序？
这个问题并不从Arrays.sort()的源码去解释为什么可以对数组进行排序，而是从排序对象的实现方式去解释，想一下自己平时工作中其实还用到挺多的，所以就记下来吧。
我们不看Arrays.sort()这个方法里面的源码，先看一下排序对象Integer，String，Double，Float等基本包装类型的源码：
可以看出这些类型都实现了一个接口：Comparable，这个接口里面只有一个方法：
那么是不是实现了Comparable，我们都可以使用Arrays.sort()对其进行排序呢？
我们新建两个实体类：User和Dept，其中User实现了Comparable接口，Dept没有实现
然后我们对User实体测试一下：
结果如下：
发现是可以排序的，然后对Dept测试一下：
发现报了类型转换的错误：
显然如果没有实现Comparable的接口，是不能使用Arrays.sort()进行排序的，使用Collections.sort()实际上也是使用Arrays.sort()对LIst里面的数组进行排序的，另外，如果需要倒叙，我们可以这样：
结果就变成以下这样了：
在实际开发中就遇到过需要对类似List&lt;User&gt;这样的数据进行排序，当然使用Collections.sort()也可以实现排序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a3900e70d2aafc20f09a344e89624e3/" rel="bookmark">
			JavaFX 控件 RadioButton&amp;CheckBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RadioButton&amp;CheckBox RadioButton RadioButton rb1 = new RadioButton("rb1"); RadioButton rb2 = new RadioButton("rb2"); RadioButton rb3 = new RadioButton("rb3"); RadioButton rb4 = new RadioButton("rb4"); ToggleGroup toggleGroup = new ToggleGroup(); toggleGroup.getToggles().addAll(rb1, rb2, rb3, rb4); //设置选中 rb2.setSelected(true); //通过ToggleGroup设置选中 toggleGroup.selectToggle(rb3); //RadioButton 监听改变 rb1.selectedProperty().addListener(new ChangeListener&lt;Boolean&gt;() { @Override public void changed(ObservableValue&lt;? extends Boolean&gt; observable, Boolean oldValue, Boolean newValue) { } }); //ToggleGroup 监听改变 toggleGroup.selectedToggleProperty().addListener(new ChangeListener&lt;Toggle&gt;() { @Override public void changed(ObservableValue&lt;? extends Toggle&gt; observable, Toggle oldValue, Toggle newValue) { } }); ObservableList&lt;Node&gt; children = root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a3900e70d2aafc20f09a344e89624e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc7cd5163c7492bdcf372b65e4188473/" rel="bookmark">
			windows抓屏排除指定窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：
BOOL SetWindowDisplayAffinity( HWND hWnd, DWORD dwAffinity ); hWnd:窗口句柄
dwAffinity:
#define WDA_NONE 0x00000000 #define WDA_MONITOR 0x00000001 #define WDA_EXCLUDEFROMCAPTURE 0x00000011 在beta版本下，才有WDA_EXCLUDEFROMCAPTURE
包含在：C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\WinUser.h
然鹅，经过测试，并没有用，被排除的窗口，只是显示成了黑框。失败！
方式二（从webrtc M81抠的）：
Windows放大镜Magnification API
MagSetWindowFilterList Sets the list of windows to be magnified or the list of windows to be excluded from magnification. BOOL MagSetWindowFilterList( HWND hwnd, DWORD dwFilterMode, int count, HWND *pHWND ); 接口MagSetWindowFilterList具有排除指定窗口的功能。
测试可行，只是稍显复杂：
//excludewindow.h #pragma once #include &lt;magnification.h&gt; #include &lt;wincodec.h&gt; #include &lt;windows.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc7cd5163c7492bdcf372b65e4188473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9a58aaa45d21fc2686936dcd1fba0b/" rel="bookmark">
			pytorch&#43;faster-rcnn 训练PASCAL VOC2007数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为初学者，这里不谈原理，只谈步骤
一、 下载faster-rcnn代码 代码路径： https://github.com/dongdonghy/Detection-PyTorch-Notebook.git
下载后，faster-rcnn代码路径在： Detection-PyTorch-Notebook/chapter4/faster-rcnn-pytorch
二、 安装pytorch和依赖包 1、 建议安装pytorch 0.4.0或0.4.1 版本(安装高版本的pytorch，训练时会报一堆错误)
2、 安装其它依赖包，见：Detection-PyTorch-Notebook/chapter4/faster-rcnn-pytorch/requirements.txt
三、 准备工作 1、下载PASCAL VOC2007数据集，2007数据集有三个tar包
http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtrainval_06-Nov-2007.tar
http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtest_06-Nov-2007.tar
http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCdevkit_08-Jun-2007.tar
将三个tar包放到任意一个目录下解压，如/home目录，解压后的目录结构如下：
----VOCdevkit
------VOC2007
------VOCcode
------其他一些文件和目录
说明： 我在使用VOC2012数据集的时候，训练报错，所以我这里直接使用的是VOC2007数据集
3、创建软链接,假设voc2007数据集在/home目录下
cd Detection-PyTorch-Notebook/chapter4/faster-rcnn-pytorch &amp;&amp; mkdir data
cd data
ln -sf /home/VOCdevkit VOCdevkit2007
4、下载预训练的网络模型，我使用的是vgg16
地址：https://filebox.ece.vt.edu/~jw2yang/faster-rcnn/pretrained-base-models/vgg16_caffe.pth
将下载的vgg16_caffe.pth拷贝到data/pretrained_model目录下
5、 根据自己的GPU型号，修改lib/make.sh文件中的CUDA_ARCH
6、 由于在NMS与RoI Pooling中使用了CUDA进行加速，因此还需要对此进行编译。
cd lib &amp;&amp; sh make.sh
需要注意的是：因为代码是windows格式的，编译有可能会报错，建议使用dos2unix将所有的文件格式转换一下
四、 开始训练 1、 修改faster-rcnn-pytorch/lib/datasets/pascal_voc.py 文件里的__init__方法，将下面两行注释掉，这里不需要指定路径，因为程序会自动解析路径的
self._devkit_path="/root/Detection-PyTorch-Notebook/chapter4/faster-rcnn-pytorch/data/VOC2012"
self._data_path = “/root/Detection-PyTorch-Notebook/chapter4/faster-rcnn-pytorch/data/VOC2012”
2、 训练模型
python trainval_net.py --dataset pascal_voc --net vgg16 --bs 24 --nw 4 --cuda --mGPUs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c9a58aaa45d21fc2686936dcd1fba0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8e0c9c72d34970eeb9aaec335f49ae8/" rel="bookmark">
			python不改变图片尺寸压缩到指定大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python不改变图片尺寸压缩到指定大小
import base64 import io import os from PIL import Image from PIL import ImageFile # 压缩图片文件 def compress_image(outfile, mb=190, quality=85, k=0.9): """不改变图片尺寸压缩到指定大小 :param outfile: 压缩文件保存地址 :param mb: 压缩目标，KB :param step: 每次调整的压缩比率 :param quality: 初始压缩比率 :return: 压缩文件地址，压缩文件大小 """ o_size = os.path.getsize(outfile) // 1024 print(o_size, mb) if o_size &lt;= mb: return outfile ImageFile.LOAD_TRUNCATED_IMAGES = True while o_size &gt; mb: im = Image.open(outfile) x, y = im.size out = im.resize((int(x*k), int(y*k)), Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8e0c9c72d34970eeb9aaec335f49ae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ea7a1ed1a0c7848897f866880a7342/" rel="bookmark">
			JavaEE框架学习—Spring
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Spring简介1.1 什么是Spring1.2 Spring的两个核心特性1.3 关键策略1.4 模块组成1.5 Spring 的优缺点1.6 Spring 框架涉及到的设计模式 二、IoC2.1 概念2.2 IoC的实现机制2.2 依赖注入(DI)2.3 依赖注入的实现1) setter 注入2) 构造方法注入3) 注解注入 2.4 控制反转(IoC)的作用2.5 控制反转(IoC)的优点2.6 IoC容器2.6.1 BeanFactory和ApplicationContext的区别1) 依赖关系2) 加载方式3) 创建方式4) 注册方式 2.6.2 BeanFactory和ApplicationContext的关系2.6.3 ApplicationContext 的实现 三、Spring Beans3.1 基本概念3.2 bean的作用域3.3 线程安全问题Spring框架中的单例bean是线程安全吗？Spring如何处理线程并发问题？ 3.4 bean的生命周期3.5 bean的装配3.5.1 bean的自动装配3.5.2 自动装配的方式3.5.3 使用@Autowired注解自动装配的过程3.5.4 自动装配的局限性 四、Spring注解4.1 基于Java的Spring注解配置4.2 @Component, @Controller, @Repository, @Service注解4.3 @Required 注解4.4 @Autowired 注解4.5 @Qualifier 注解4.6 @RequestMapping 注解 五、Spring数据访问5.1 对象/关系映射集成模块5.2 如何更有效地使用JDBC5.2.1 JDBC抽象和DAO模块 5.3 Spring访问Hibernate5.4 Spring事务5.4.1 Spring支持的事务管理类型（事务实现方式）5.4.2 Spring事务的实现方式和实现原理5.4.3 Spring的事务传播行为5.4.4 spring 的事务隔离5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2ea7a1ed1a0c7848897f866880a7342/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad14d11045cbf41f7aba24ab7c43eeb4/" rel="bookmark">
			SqlServer数据库设置指定用户访问指定表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的执行语句如下:
exec sp_addrole 'readOnly' //创建角色 GRANT SELECT ON RunningData TO readOnly//将RunningData 表权限赋给readOnly角色 exec sp_addlogin 'yhs','yh','DD_Test'//添加只允许访问指定视图的用户: exec sp_addlogin '登录名','密码','默认数据库名 exec sp_adduser 'yhs','read','readOnly'//添加只允许访问指定视图的用户到rCRM角色中: exec sp_adduser '登录名','用户名','角色' 但是实际的时候需要给当前用户赋予两个数据库中的部分表的权限,按照上述设置后只能实现一个数据库的操作权限,在进行如下操作:
以sa用户登录数据库,在点击安全性-登录名-yhs(上述新建的登录名),打开属性,在用户映射中选择需要访问的数据库,在选择该数据库后面的默认框架,
选择浏览-选择新建的readOnly角色-点击确认,
回到以下界面
就可以了
注意 有时在属性设置里面找不到新建的角色,需要重新刷新或者重新登录才能获取
在一个数据库中新建的角色,如果想要在另一个数据中可以选中这个角色,需要在新建一个角色,不然一味的刷新是获取不到的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4a3b238b1a2447395b62a4353209b5/" rel="bookmark">
			thinkphp where in
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. $filter['order_status']=['in',[20,21]]; 2. $query=$query-&gt;where('order_status','in',[20,21]); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46fbc888ff3058ef83a05e02790c3de1/" rel="bookmark">
			day05 - javascript函数（下）/事件/对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.作用域： 概念：变量或者函数可以起到作用的范围区域。
函数外边的变量叫做全局变量，可以在函数外面和函数里面使用。 var num = 1; function test(){ num++; console.log(num); } test(); // 2 console.log(num); // 2 函数内部的变量叫做局部变量，只能在函数内部使用。 function test(){ var num1 = 10; num1++; console.log(num1); } test(); // 11 console.log(num1); // 报错，num1未定义 有一种情况比较特殊，函数内部声名的变量也是全局变量。 function test(){ num1 = 10; num1++; console.log(num1); } test(); // 11 console.log(num1); // 11 1.访问规则(输出、拿变量运算)
当前作用域 →上级作用域（父作用域）→全局作用域
如果直到全局作用域都没有找到变量的定义，则报错
2.赋值规则
当前作用域 →上级作用域（父作用域）→全局作用域
如果有一个值，但是没有定义；而且直到全局作用域都没有找到变量的定义，则把值定义为全局变量
总结：
函数外边使用的变量是全局变量，要在全局内找，可以是函数外部声名的变量也可以是函数内部的隐式声名的变量。函数内部使用的变量是局部变量，先从局部找，如果局部没有，再从全局中找。 2.递归函数： 概念：递归函数就是在函数中调用自己。
// 求10的阶和，即：10+9+8+...+1 function facSum(num){ if(num == 1){ return 1; } return num + facSum(num-1); } var res = facSum(10); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46fbc888ff3058ef83a05e02790c3de1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1305726521d444d3c7c64f77bc6b38d9/" rel="bookmark">
			LaTeX新手半小时速成手册（不速成你打我
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		期末大作业LaTeX排版，一个学期没听课，学了b站半小时完成大作业。写此速成手册以作备忘。
b站链接：小风寒呐
1. primary 一篇论文最主要的构成，以中文为例
1.1 整体框架 1.1.1 声明类 相当于在说：“我想写一篇文章”
\documentclass[UTF8]{ctexart} 文章编码：UF8
文章类型：中文
1.1.2 导入包 相当于在说：“我要开始写文章”
\usepackage{mathtools,wallpaper} \usepackage{t1enc} \usepackage{pagecolor} 可以一次性导入全部宏，每个包之间用逗号分隔；也可以一行行导入，用到什么导什么。
1.1.3 环境 相当于在说：“我正在写文章”
\begin{document} 文章 \end{document} 文章的body，也是接下来介绍的
1.2 开始写文章 1.2.1 maketitle \title{标题\LaTeX} \author{xxx} \date{62-50-0202} \maketitle 运行效果
注意：
\maketitle一定要加上，不然显示不了
\date{62-50-0202}可以不加，会默认显示写作时间，如果不想显示，直接\date{}
1.2.2 章节 \section{\LaTeX 的使用} \subsection{\LaTeX 的基本知识} \subsubsection{\LaTeX 的结构} \LaTeX是属于LaTeX的一个特殊符号
分章节，一般都是无脑sub,但是注意，最多到\subsubsection，没有\subsubsubsection,如果你还想在\subsubsection以下分段的话，只能选择\paragraph：
比方说：
\section{Introduction} There is a theory which states that if ever anyone discovers exactly what the Universe is for and why it is here, it will instantly disappear and be replaced by something even more bizarre and inexplicable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1305726521d444d3c7c64f77bc6b38d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981dc6bb603e8106df0c67c6f6b4301b/" rel="bookmark">
			高并发-高可用-负载均衡LVS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的快速发展，越来越多的互联网服务面临着极其庞大的并发量，面对庞大的并发，现在的人们是如何解决的呢？本文是我了解到的处理高并发时使用负载均衡的一些知识，我将其写为一篇文章分享给大家，希望能够对大家学习负载均衡有点帮助。
几个基本概念 高并发：短时间内对服务器进行大量的请求。高可用：高并发场景下要求服务器具有高可用性负载均衡：在高并发的场景下，我们会有专门的负载均衡服务器来将大量的请求分发到对应的应用服务器上，实现分而治之。 负载均衡 四层负载均衡：在高并发场景下，通常在真正的应用服务器前会有一台或多台四层负载均衡服务器，它只有物理层、链路层、网络层和传输层，负载均衡服务器的传输层和客户端的传输层间并不会建立TCP连接，它传输层的作用是拿到客户端请求的端口号，看一眼是否访问的是需要做负载均衡的服务的端口号，如果是会去做负载均衡相关操作，如果不是可能进行其他操作，丢弃或者交给上层处理。负载均衡是数据包级别的转发，相对于路由器来说，它只是会在传输层判断下端口号，因此它可以做到快速的处理大量的请求。做负载均衡时，多台应用服务器应该是镜像的（即完全一样）。做负载均衡时，用户知道的应用服务器的地址其实是负载均衡服务器的，并不是真正的应用服务器地址，当请求到达负载均衡服务器时，负载均衡服务器会将请求转到真正的应用服务器。
不同的负载方式 D-NAT方式 基于4层的负载均衡。D-NAT的过程： 客户端请求-&gt;到达负载均衡服务器，通过D-NAT的方式将目标地址转换为真正的应用服务器地址-&gt;将请求给到真正的应用服务器，服务器处理-&gt; 将响应返回到负载均衡服务器，负载均衡服务器会将源地址替换为自己的IP地址返回给客户端-&gt; 客户端接收响应。这种方式需要将真正服务器的网关设置为负载均衡服务器，使得数据包能够返回负载均衡服务器。局限： 客户端的请求一般数据包比较小，而服务端的响应包数据量会比较大，请求和响应都经过负载均衡服务器，这将使得负载均衡服务器的带宽成为高并发的瓶颈。 DR方式 DR，翻译为中文为直接路由，通过Mac欺骗来完成；这种方式的负载均衡使得请求与响应成为一种环形，解决了D-NAT的带宽问题，相对于D-NAT，效率也有了一定的提升。这是一种基于2层的负载均衡。这种方式关键的两点就是 第一，在负载均衡服务器上的链路层，将数据包的目标Mac地址封装为真正的应用服务器的地址，使得数据包能到达真正的应用服务器；第二，对真正的应用服务器做处理，使得其持有负载均衡服务器的IP地址。局限： 对Mac地址做包装，充分的利用了Mac地址在节点间的作用，但这也使得负载均衡服务器和真正的服务器必须在同一局域网内。虽然真正的应用服务器持有负载均衡服务器的IP地址，但真正的应用服务器不会将负载均衡服务器的IP地址暴露在互联网上（需要在内核层面修改网络参数，做配置），客户端的所有请求只会到达负载均衡服务器。 TUN方式 TUN，翻译为中文为隧道，简单的理解这种方式即负载均衡服务器会在到来的请求数据包外再包一层IP地址（源IP为自己的分发IP，目标IP为真正的服务器IP），使得数据包可以跨网络传输到真正的应用服务器上，这种方式相当于给数据包又套了一层外包装使得其可以在不同网络间传输，我们给这种方式起了个名叫做隧道技术，VPN也是使用这种技术实现。这种方式的负载均衡服务器可以和真正的服务器跨网络。
总结 这三种实现负载均衡的方式不同点就是负载均衡服务器对数据包的处理，D-NAT修改IP地址；DR修改Mac地址；TUN做外包装。负载均衡服务器并不会与客户端建立连接，它只做数据包级别的转发，但它确可以监测到客户端和真正服务器的通信状态（偷窥数据包）。 网络小知识 上述方式中的后两种关键点就是我们需要在真正的应用服务器上做到IP地址的隐藏（对外隐藏，对内可见），这种技术是怎么实现的呢，我在这做个简单介绍。
我们的计算机中最少也会有两个网络接口，一个为真实的物理网络接口 eth0，另一个为内核的环回网络接口lo（loopback），真实的物理网络接口做向外网络通信，环回接口lo在计算机内部使用（我们在本机上测试部署在Tomcat上的程序时，IP地址通常会写localhost：port，其实这个过程就是使用了内核的环回接口，当请求到达内核时，内核发现IP是本机，则会走环回接口lo）。
我们也可以通过已有网络接口新建许多的子接口 例如，使用命令 ifconfig eth0:8 192.168.120.11 可以创建出一个新的网络接口etho:8。
我们可以更改内核的参数改变一些网络配置，修改当我们的计算机收到ARP请求时的响应级别和主动发送ARP请求时向外通告自己的地址信息级别，即当我们发送或收到ARP请求如何包装自己的IP地址信息（当本地配置有多个网络接口，也意味着有多个IP地址，此时我们向外公布哪一个）。
这两个参数的配置信息在/proc/sys/net/ipv4/conf/对应的网卡/arp_ignore（响应级别） 和arp_announce（主动请求级别）中。 arp_ignore： 0：做IP包装时，包装本地配置中的任意的一个IP（包括环回网卡IP） 1：哪个网络接口收到，包装哪个网口上的IP arp_announce: 0：使用本地配置中任意的一个IP包装 1：试图使用一个与源IP地址属于同一个网络的IP地址做包装 2：哪个网口发请求包就用哪个网口上的IP地址 通过上述内容的描述，我们可以这样解决隐藏IP的问题：我们可以创建一个环回子接口，给其配置负载均衡的IP地址，然后设置arp_ignore的级别为1，arp_announce的级别为2。
注：设置级别时，不能直接使用vim 来做，那样不会起作用，需要通过重定向来做，例如：echo 1 &gt; /proc/sys/net/ipv4/eth0/arp_ignore
LVS 提到了负载均衡，那就必须得知道LVS，因为它就是一个专门用来做负载均衡内核级的软件，全称为Linux virtual server，Linux虚拟服务器，其实我们上面提到的3种实现方式正是LVS实现负载均衡的3种不同模式。可以这么说上面3种是原理，LVS是对它们的应用，Linux系统的内核里有LVS的实现代码（ipvs模块），因此只要服务器上安装了Linux系统，那么我们就可以将其做成一个负载均衡服务器。
在虚拟机上搭建LVS node01做负载均衡服务器，node02、node03做真正的应用服务器。
步骤参考下图：
步骤一：配置网络
步骤二：在node02、node03中安装一个http的服务，做应用服务器
步骤三：为node01做LVS服务配置
步骤四：验证
注：
-A 部分配置的是进入负载均衡服务器的请求相关参数 -a 配置的是请求在负载均衡服务器的具体分发
LVS的具体实现在内核中，我们需要一个客户端的工具ipvsadm来操作内核中的ipvs模块
高可用Keepalive 上边我们用LVS做了负载均衡服务器，有了它我们就可以面对高并发的场景了，但其实还会有一些问题，第一，负载均衡服务器可能会挂掉；第二，真正的应用服务器也可能出故障；这样我们服务的可用性就没有了保证。要使得我们的服务具备高可用，那么我们就得解决上述两个问题；对于第一个其实关键点就是单点问题，我们的负载均衡服务器只有一个，解决它的办法其实也简单，我们可以用多台（常使用的方式有主备），第二个我们可以通过发送请求根据相应状态码判断它是否故障。主备模式：双方要能交流（备服务器要能拿到主服务器的状态 ）为了解决这个问题，Keepalive这个第三方应用软件应运而生，我们可以使用它来搭建出高可用的系统，它可以操作内核中的ipvs模块（可以做LVS相关的配置工作）、可以给备用服务器发送消息（自己是否还存活）、可以发送请求给真正的应用服务器（判断服务是否正常），它的整个工作都通过配置文件来完成（配置好了，启动软件即可） 在虚拟机上搭建高可用的LVS 在上面LVS的基础上进行试验：
第一步：清空node01的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/981dc6bb603e8106df0c67c6f6b4301b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a805e4fd8c8a15b7099ffbf372c0126e/" rel="bookmark">
			【博客260】RESTFUL API--REpresentational State Transfer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容： 记录一种API设计理论–RESTFUL
REST含义
REST是设计风格而不是标准。是指客户端和服务器的交互形式 RESTFUL API含义：
字面意义：RESTful API就是REST风格的API 实际概念：用http动作来操作URL资源 关键词：
Resource：资源，即数据。 Representational：某种表现形式，比如用JSON，XML，JPEG等； State Transfer：状态变化。通过HTTP动词实现。 调用关系：
RESTful API由后台也就是SERVER来提供前端来调用。前端调用API向后台发起HTTP请求，后台响应请求 将处理结果反馈给前端。也就是说RESTful 是典型的基于HTTP的协议。 设计原则与规范：
1、资源。首先是弄清楚资源的概念。资源就是网络上的一个实体，一段文本，一张图片或者一首歌曲。 资源总是要通过一种载体来反应它的内容。文本可以用TXT，也可以用HTML或者XML、图片可以用JPG 格式或者PNG格式，JSON是现在最常用的资源表现形式。 （注意：需要保证所有事物都可以被抽象为资源，且每一个资源都有唯一的资源标识，对资源的操作不会 改变这些标识。） （注意：RESTFUL API基于http，所以安全性不高） 2、统一接口。RESTful风格数据元操CRUD（create,read,update,delete）分别对应HTTP方法： GET用来获取资源； POST用来新建资源（也可以用于更新资源）； PUT用来更新资源； DELETE用来删除资源； 3、URI。可以用一个URI（统一资源定位符）指向资源，即每个URI都对应一个特定的资源。要获取此 资源访问它的URI就可以，因此URI就成了每一个资源的地址或识别符。一般的，每个资源至少有一个 URI与之对应，最典型的URI就是URL 4、无状态。所谓无状态即所有的资源都可以URI定位，而且这个定位与其他资源无关，也不会因为其它 资源的变化而变化。有状态和无状态的区别 举例： 个人查询驾照考试结果，那么是需要先输入账号密码登录，然后登录后再进入个人中心，找到成绩 查询按钮，按下查询。这里的每一步都依赖上一步，上一步执行失败则无法进入下一步。 5、最好将API的版本号放入URL 6、URL中只能有名词而不能有动词，操作的表达是使用HTTP的动词GET,POST,PUT,DELETEL。 URL只标识资源的地址，不包括操作 7、如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 比如： 查询可以捎带以下参数： 过滤条件：?type=1&amp;age=16	排序：?sort=age,desc	分页：?limit=10&amp;offset=3 ... 8、URL的层次设计最好不要嵌套太多层 9、常见开头：api和version 将api部署在专门的域名下，比如：http://api.example.com 将api放在主域名下，比如：http://www.example.com/api/ 将api的版本号放在url中，比如：http://www.example.com/api/v1.0 RESTFUL API举例：
查询驾照成绩：GET:http://www.xxx.com/grade/id 驾照成绩有误，工作人员进行修改：POST:http://www.xxx.com/grade/id 数据安全性和幂等性：
数据安全性：是否对服务器后台数据造成影响 幂等性：执行一次和执行N次对资源的修改效果是否一致 操作的数据安全和幂等性：
安全性	幂等性 GET	√ √ POST	×	× PUT	×	√ DELETE	×	√ 常见HTTP返回状态码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a805e4fd8c8a15b7099ffbf372c0126e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ec0f9f5a72368e9f16d953249a2344/" rel="bookmark">
			C&#43;&#43;知识点4——vector与string简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		string
使用string类必须包含头文件#include&lt;string&gt;
string对象的初始化
1.默认初始化
string s1; 2.拷贝初始化
string s4=s1; string s5="qwer"; 3.直接初始化
string s3("qwer"); string s5="qwer"; string s6(10,'c'); 上述代码的运行结果
void stringinit() { string s1; string s2(s1); string s3("qwer"); string s4=s1; string s5="qwer"; string s6(10,'c'); cout&lt;&lt;s1&lt;&lt;","&lt;&lt;s2&lt;&lt;"," &lt;&lt;s3&lt;&lt;","&lt;&lt;s4&lt;&lt;","&lt;&lt;s5 &lt;&lt;","&lt;&lt;s6&lt;&lt;endl; } 从上述结果可以看出，如果等号右边的值或者括号内的值相同，那么拷贝初始化和直接初始化是没有区别的
但实际上，二者调用的函数不同，拷贝初始化调用的是拷贝构造函数，而直接初始化调用的是对应的构造函数
string对象如果执行默认初始化（事实上调用的是无参构造函数），那么对象的默认值是空串
string size函数的返回值
string的size函数返回的是string::size_type，并不是int，string::size_type是一个无符号的数据类型，可以存储下任何大小的string对象
string对象与字符串字面值
string对象（如string tmp="qwer";）与字符串字面值（如"qwer"）看起来相似，但是类型完全不同。因为C++中的字符串字面值不存在加法运算，所以无法对两个字符串字面值进行相加操作（下面代码中第二个res5）
string类将operator+运算符函数定义为非成员函数，而该函数的参数的类型是const string &amp;，又因为const变量的引用可以绑定常量，也可以绑定string对象，所以 string对象可以与字符串字面值相加，也可以与string对象相加。
所以，下面代码中res1等价于operator+("abc", tmp)；res2等价于operator+(tmp，"abc")。res3等价于operator+(operator+(res1，","), res2)，res4同理
void stringandlitreal() {	string tmp="qwer"; string res1="abc"+tmp; string res2=tmp+"abc"; string res3=res1+", "+res2; string res4=res3+"qwer"+"abc"; string res5="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4ec0f9f5a72368e9f16d953249a2344/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e26f31818b3332df6cced1fc31cd5564/" rel="bookmark">
			vue使用原生canvas绘制海报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间，公司项目要求绘制商品的分享海报，当时尝试使用了html2canvas，但是后来发现，它只有在Safari浏览器上面效果比较理想，但是在Android手机上面，各种移位，总之就是不能生成完整的图。虽然后面有尝试过在绘制过程中加一个延时，但是效果还是不太好，最后还是决定使用原生canvas来制作了。过程虽然麻烦些，但是最终的效果还是不错的。
先上一张效果图
下面是我整理的绘制过程
前期准备 &lt;div class="hidden" style="display: none;"&gt; &lt;canvas id="mycanvas" :width="w" :height="h" /&gt; &lt;img class="goodsImg" src="" alt="" crossOrigin="*"&gt; &lt;/div&gt; &lt;img class="postImg" src alt&gt; 这里，canvas模块，我是用display: none 将其隐藏，因为只需要获取到canvas生成的base64格式的图片就可以了，而原始的canvas内容不展示也不影响。
之所以这样处理，canvas的宽度高度，要比生成的图片的宽高大一些，这样生成的图片会清晰很多。
data() { return { w: 650, h: 1200 } } .postImg { width: 570px; } 注意：canvas的宽高最好用 width 和 height 属性，以免变形。
写好布局，接下来还有比较重要的一步：
对于绘制图片的处理
这里分为两种情况： 一种是本地图片绘制，一种是网络图片绘制；
其实两种绘制差别上不是很大，只是网络图片需要解决图片跨域的问题。
解决方法也是有的，需要在 oss 上面去配置一下允许跨域。这个需要找公司负责这方面人员去帮你配置，当然如果你自己也可以配置的话，那也再好不过了，具体的配置方法网上有很多，可以自己去搜。
这里我用的是网络图片，所以 src 的属性是空的，后面会在获取到数据后填充上的。
如果是绘制本地图片，需要把上面的 html 代码稍作修改
&lt;div class="hidden" style="display: none;"&gt; &lt;canvas id="mycanvas" :width="w" :height="h" /&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e26f31818b3332df6cced1fc31cd5564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e403326aa7a4f3b39a1b5a3f8db982b/" rel="bookmark">
			Git/Shell：批量 git pull，一键更新同一目录下的多个仓库（快速拉取全部项目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年5月26日 version-2.0 git_pull_Batch.sh
#!/bin/bash function showGreen(){ echo -e "\033[32m $1 \033[0m"} function showBlue(){ echo -e "\033[36m $1 \033[0m"} function showYellow(){ echo -e "\033[33m $1 \033[0m"} function showWhite(){ echo -e "\033[37m $1 \033[0m"} function traversal_dir(){ for sub_dir in `ls $1` #通过 ls root_dir 遍历出子目录，装入子目录 sub_dir 中 do dir=$1"/"$sub_dir #将根目录 $1 与子目录 sub_dir 拼接成完整的目录 if [ -d $dir ] #判断：是目录的继续下一步 then cd $dir showBlue $dir showGreen 'git pull '$sub_dir git pull echo #打印空行 else showYellow $dir echo #打印空行 fi done } root_dir="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e403326aa7a4f3b39a1b5a3f8db982b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da0ff195ef4097b185ec842584bbd9a/" rel="bookmark">
			常用统计量及其常见分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 常用统计量(1)样本均值(2)样本方差(3)修正样本方差(4)样本k阶原点矩(5)样本k阶中心距 2. 统计量的常见分布(1)卡方分布(2)F——分布(3)t——分布(4)正态总体下的分布 1. 常用统计量 什么是统计量：不含未知参数的样本的函数T（ξ1ξ2…ξn）。
(1)样本均值 E(x拔) = E(x)
D(x拔) = D(x)/n
E(x拔2) = D(x)/n + E2(x)
(2)样本方差 E(Sn2) = D(x)
E(Sn2) = 可根据统计量的分布推导
(3)修正样本方差 (4)样本k阶原点矩 (5)样本k阶中心距 2. 统计量的常见分布 (1)卡方分布 (2)F——分布 (3)t——分布 (4)正态总体下的分布 前提：总体符合正态分布N（μ，σ2）。
注意，这是样本均值服从的正态分布，不是 ξi 服从的分布
可推导出D(Sn)
还有很多复杂的推论，等到需要时再补充。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464b6c90dfd2cb4c3d4b71899dc17a20/" rel="bookmark">
			mbedtls学习4.mbedtls_RAM/ROM优化指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MbedTLS RAM 和 ROM 资源占用优化指南 mbedtls 软件包采用了模块化的设计，可以使用 config.h 文件来进行功能模块的配置选择。
mbedtls 默认提供的 config.h 文件是一个通用的、全功能的配置，占用了非常大的 RAM 和 ROM 空间，但是保证了 SSL 握手和通讯的建立速度、稳定性、协议兼容性以及数据传输效率。但嵌入式设备受限于其有限的 RAM 和 ROM 空间，我们不得不牺牲速度来节省 RAM 空间，裁剪不需要的功能模块来降低 ROM 占用。
本优化指南，在保证 SSL/TLS 客户端能与服务器建立安全稳定连接的前提下，对 RAM 和 ROM 占用进行优化统计。
注意：
mbedtls 客户端的优化属于针对性优化，针对特定的 SSL/TLS 服务器进行的优化，不同的 SSL/TLS 服务器配置不同，优化所用到的配置参数也是不同的。
因此，开发者在进行 SSL/TLS 优化前，在 MCU 资源条件允许的情况下，请先使用默认的配置调通 SSL/TLS 握手连接和加密通讯，然后再根据 SSL/TLS 服务器具体的配置进行逐项优化。
当然，多数情况下您并不知道服务器的具体参数配置，因此也只能试探性优化，本文给出了各个配置的说明，来方便开发者进行针对性的优化。
优化说明 RAM 资源占用统计说明
首先保证 SSL 握手连接正常，加密数据通讯正常。
运行 tls_test 测试例程，进行 RAM 优化测试。测试例程在单独的线程中运行，通过对比 SSL 握手成功前后所占用的内存来确定在握手通讯过程所使用的 RAM 情况。该测试方法只能粗略估计 SSL 客户端成功进行握手连接所需要的 RAM 大小，该数据包含了保证握手通讯所需要的额外的 RAM 空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/464b6c90dfd2cb4c3d4b71899dc17a20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4927bdbf87f7c2a525779b6ff5b54fdb/" rel="bookmark">
			mbedtls学习2.mbedtls从0使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用指南 这里主要介绍 mbedtls 程序的基本使用流程，并针对使用过程中经常涉及到的结构体和重要 API 进行简要说明。
mbedtls 的基本工作流程如下所示：
初始化 SSL/TLS 上下文建立 SSL/TLS 握手发送、接收数据交互完成，关闭连接 menuconfig 配置说明 获取 mbedtls 软件包或者修改用户配置都需要使用 menuconfig。需要用户打开 ENV 工具，并将目录切换到您所用的 BSP 目录，使用 menuconfig 命令打开配置界面。
在 RT-Thread online packages → security packages 中选择 mbedtls 软件包，操作界面如下图所示：
详细的配置介绍如下所示：
RT-Thread online packages ---&gt; security packages ---&gt; Select Root Certificate ---&gt; # 选择证书文件 [*] mbedtls: An portable and flexible SSL/TLS library # 打开 mbedtls 软件包 [*] Store the AES tables in ROM # 将 AES 表存储在 ROM 中 (2) Maximum window size used # 用于点乘的最大“窗口”大小（2-7） (3584) Maxium fragment length in bytes # 配置数据帧大小 [*] Enable a mbedtls client example # 开启 mbedtls 测试例程 [ ] Enable Debug log output # 开启调试 log 输出 version (latest) ---&gt; # 选择软件包版本，默认为最新版本 Using all default CA 配置选项会将 certs/default 目录下的所有预置证书加入编译，将占用很大的内存Using user CA 配置选项允许用户将自己需要的证书文件加入编译，需要用户将证书文件拷贝到 certs 根目录 选择合适的配置项后，使用 pkgs --update 命令下载软件包并更新用户配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4927bdbf87f7c2a525779b6ff5b54fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de470dceb24ef489142597a635f9e19/" rel="bookmark">
			Newtonsoft.Json.JsonConvert.DeserializeObject首次转换太慢问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不论是.net还是xamarin工程里面转换json一直使用的都是Newtonsoft包，一直也没觉得有什么问题
直到最近安卓设备出现了很奇怪的事情，有个方法居然花费了1秒多，定位后发现是Newtonsoft.Json.JsonConvert.DeserializeObject花了1秒多，这我就傻眼了，这玩意怎么处理，要是都这样，之前的工程不可能没发现啊。
于是用.net弄了个单元测试，居然也要120多毫秒，这也太慢了吧。
定义类
public class testjson { public string aa { get; set; } public string bb { get; set; } public string cc { get; set; } } 测试：
string output = "{ \"aa\":\"1\",\"bb\":\"哈哈哈哈\",\"cc\":\"和hi黑欸\"} "; DateTime start = DateTime.Now; testjson res = new testjson(); object a = Newtonsoft.Json.JsonConvert.DeserializeObject(output, typeof(testjson)); DateTime end = DateTime.Now; TimeSpan bbbb = end - start; Console.WriteLine("第一次转换一次花费时间：" + bbbb.TotalMilliseconds); 去网上找了找，看到一些json转换的插件对比测试，Newtonsoft没有这么差啊。做个循环测试，跑个10000次，结果只要26毫秒。
DateTime start1 = DateTime.Now; for (int i = 0; i &lt; 10000; i++) { string output1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3de470dceb24ef489142597a635f9e19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e70cf7a992f878b94f2730ad263c7de/" rel="bookmark">
			Maven安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装包下载：地址
1、下载解压到指定目录：D:\install
2、环境变量配置：
a、变量：M2_HOME，变量值：D:\install\apache-maven-3.5.3 b、变量：Path，变量值：%M2_HOME%\bin
检查安装配置是否成功
打开CMD窗口，显示如下信息即安装配置成功。
3、修改本地仓库位置
文件位置：D:\install\apache-maven-3.5.3\conf\settings.xml 在标签对中加入以下内容
&lt;localRepository&gt;D:\install\repo&lt;/localRepository&gt; 4、配置阿里云的中央仓库
文件位置：D:\install\apache-maven-3.5.3\conf\settings.xml 在上述文件中的 标签对中加入以下内容
&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 5、修改IDE的maven配置（Myeclispe为例）
菜单栏 Windows —&gt; Preferences —&gt; Maven —&gt; User Settings 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2d4d84100100b372898b6d248a68cf/" rel="bookmark">
			第1课–使用R进行数据分析的简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本课程中，我们将首先了解R的功能和用法。 R是一个非常适合数据分析和图形处理的软件环境。 它最初由新西兰奥克兰大学的Ross Ihaka和Robert Gentleman于1993年创建。 他们创建了R作为一种语言，以帮助向学生教授入门统计学。 他们基于R语言，该语言基于1970年代贝尔实验室较早开发的S语言。 一段时间后，他们将R用作开源GNU项目。 现在，全世界都有非常活跃的R社区。 R被认为是一种领域特定语言，因为它主要用于数据分析。 R程序通常使用函数创建，并且程序由R解释器执行。 R不仅是一种编程语言，它还具有创建高质量数据可视化的本机支持。 R已在医疗，零售和金融服务等许多行业中使用。 R可用于分析结构化和非结构化数据集。 R可以帮助您探索新的数据集并进行描述性分析。 R在建立预测模型方面也很出色。 学习R有益的原因有很多。 作为数据分析师或数据科学家，与仅使用基于电子表格的工具相比，R可以用于更深入地研究数据。 作为软件开发人员，R可以毫不费力地实现数据分析计算和图形到新应用程序或现有应用程序中。 随着大数据的爆炸式增长，在许多新的场景中，使用R是满足用户需求的绝佳选择。 作为数据分析人员，R可用于执行经典的统计检验和预测模型。 R还具有处理时间序列数据集的本机支持。 分类和聚类模型可用于更好地检测模式。 作为开发人员，R是功能强大的函数式编程语言。 由于解释了R脚本，因此它鼓励采用交互式方法进行开发。 R脚本通常使用表达式和内置函数编写。 R为许多有用的数据结构类型提供了本机支持。 其中许多数据结构将在其他课程中进行探讨。 外部库可用于扩展R的功能。 随着R技能的提高，您可能会开始定义自己的功能和可能的新类，以满足用户的需求。 安装R非常简单。 只需导航至R Project页面，然后单击全面的R存档网络或CRAN链接。 CRAN是世界各地的一组服务器，它们存储R的相同，最新的代码和文档版本。 有适用于Windows，Linux和Mac OS平台的二进制安装程序。 可以从源代码构建R，但是如果可能的话，最好避免执行此步骤，以便您可以更快地开始使用R。 在Windows上安装R涉及下载MSI文件并执行。 有32位和64位安装选项。 我们将使用64位版本的课程，因为它对可使用的内存量有更高的限制。 Windows安装完成后，您可以通过启动R命令行环境或RGui工具来开始使用R。 除了R命令行环境外，RGui还为R用户提供了一些有用的生产力功能。 在Linux上安装R涉及：从CRAN网站下载适当的RPM文件，或使用Linux软件包管理器（如YUM），如图所示。 请注意，您必须以root用户身份登录或在Linux系统上具有sudo特权才能完成安装。 一旦安装在系统上，任何用户都可以使用R。 默认情况下，提供了R命令行和GUI，但是许多R用户更喜欢使用更全面的集成开发环境（IDE），例如RCmdr或Rstudio。 RStudio是R随附的RGui工具的绝佳替代品。RStudio在Linux，Mac OS X和Windows上可用。 在此配置中，我们从浏览器内部在Linux服务器上使用RStudio。 对于偶尔使用R的用户，此环境非常理想，因为他们不需要在自己的计算机上安装R即可使用它。 让我们检查一下此处显示的平铺窗口： •在左上角，我们可以查看2013_cars.csv数据文件和一个名为cars.R的R源文件。 •在左下角有R控制台。 •在右上角，我们可以访问当前R工作区中的对象以及最近使用过的R命令的历史记录。 •在右下角，我们具有数据的直方图以及对R帮助实用程序的访问。 在学习R的同时，值得花时间和精力来安装IDE（例如RStudio）。 先前我们说过R可以使用包来扩展。 CRAN中提供了4000多种不同的软件包，并且经常添加更多的软件包。 CRAN中发布的程序包根据其功能分类到“任务视图”中。 在本课程中，我们将主要使用内置或标准软件包集，但是您可能希望在此过程中探索一些其他软件包。 基本的R环境提供了一组重要的数据分析功能，但是R社区提供了许多出色的软件包。 可以使用install.packages（）函数添加新软件包。 将在CRAN中搜索该软件包，或者您提供的新软件包在CRAN中不可用。 只需使用相同的功能并将其定向到新软件包的压缩存档文件即可。 在这里，我们看到正在安装RJDBC软件包，以通过JDBC驱动程序实现与数据库服务器（如Informix或DB2）的连接。 如果您开发的R脚本使用的功能不是R基础的一部分，则您的脚本应在脚本的前几行中包含library（）或require（）函数，以便在运行时将程序包加载到内存中。 From: https://bytes.com/topic/apis/insights/958465-lesson-1-introduction-data-analysis-using-r
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2216ebbe0949a41f1157d8d3797897d3/" rel="bookmark">
			wps word 一点击就选中一大片区域（有阴影）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就这种一点击某一个地方，就选中了一大片区域
点击文件——工具——选项：
把域底纹 改成无即可！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d942b2c0c9d75baa68fb2ebb724a221/" rel="bookmark">
			Fofa的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为没氪金，没法深入研究，，，
文章目录 地址简介查询语法参考基本语法逻辑运算符 其他 地址 https://www.fofa.so/
简介 官网这样描述：FOFA是白帽汇推出的一款网络空间资产搜索引擎。它能够帮助用户迅速进行网络资产匹配、加快后续工作进程。例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等。
简单理解就是，一个本土加强版shodan，知道某产品在互联网的部署情况、获取一个根域名所有子域名网站、根据IP确认企业、根据一个子域名网站找到跟他在一个IP的其他网站、全网漏洞扫描、一个新的漏洞全网的影响范围。
查询语法参考 基本语法 title="abc" 从标题中搜索abc。例：标题中有北京的网站 在这里插入代码片
header="abc" 从http头中搜索abc。例：jboss服务器 header="jboss"
body="abc" 从html正文中搜索abc。例：正文包含Hacked by body="Hacked by"
domain=“qq.com” 搜索根域名带有qq.com的网站。例： 根域名是qq.com的网站
host=".gov.cn" 从url中搜索.gov.cn,注意搜索要用host作为名称。例： 政府网站, 教育网站
port=“443” 查找对应443端口的资产。例： 查找对应443端口的资产
ip=“1.1.1.1” 从ip中搜索包含1.1.1.1的网站,注意搜索要用ip作为名称。例： 查询IP为220.181.111.1的网站; 如果想要查询网段，可以是：ip=“220.181.111.1/24”，例如查询IP为220.181.111.1的C网段资产
protocol=“https” 搜索指定协议类型(在开启端口扫描的情况下有效)。例： 查询https协议资产
city=“Hangzhou” 搜索指定城市的资产。例： 搜索指定城市的资产
region=“Zhejiang” 搜索指定行政区的资产。例： 搜索指定行政区的资产
country=“CN” 搜索指定国家(编码)的资产。例： 搜索指定国家(编码)的资产
cert=“google” 搜索证书(https或者imaps等)中带有google的资产。例： 搜索证书(https或者imaps等)中带有google的资产
banner=users &amp;&amp; protocol=ftp 搜索FTP协议中带有users文本的资产。例： 搜索FTP协议中带有users文本的资产
type=service 搜索所有协议资产，支持subdomain和service两种。例： 搜索所有协议资产
os=windows 搜索Windows资产。例： 搜索Windows资产
server==“Microsoft-IIS/7.5” 搜索IIS 7.5服务器。例： 搜索IIS 7.5服务器
app=“海康威视-视频监控” 搜索海康威视设备，更多app规则。例： 搜索海康威视设备
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d942b2c0c9d75baa68fb2ebb724a221/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec97fdadf09fe9dcc50823f98903d004/" rel="bookmark">
			（PTA,C语言）在数组中查找指定元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求实现一个在数组中查找指定元素的简单函数。
函数接口定义：
int search( int list[], int n, int x );
其中list[]是用户传入的数组；n（≥0）是list[]中元素的个数；x是待查找的元素。如果找到
则函数search返回相应元素的最小下标（下标从0开始），否则返回−1。
裁判测试程序样例：
#include &lt;stdio.h&gt;
#define MAXN 10
int search( int list[], int n, int x );
int main()
{
int i, index, n, x;
int a[MAXN];
scanf("%d", &amp;n); for( i = 0; i &lt; n; i++ ) scanf("%d", &amp;a[i]); scanf("%d", &amp;x); index = search( a, n, x ); if( index != -1 ) printf("index = %d\n", index); else printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec97fdadf09fe9dcc50823f98903d004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db6e6573aeb46e94fdf271930679c112/" rel="bookmark">
			ioctl 获取相关地址及开启和关闭网卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，结构体
struct ifreq { #define IFHWADDRLEN 6 union { char ifrn_name[IFNAMSIZ]; } ifr_ifrn; union { struct sockaddr ifru_addr; struct sockaddr ifru_dstaddr; struct sockaddr ifru_broadaddr; struct sockaddr ifru_netmask; struct sockaddr ifru_hwaddr; short ifru_flags; int ifru_ivalue; int ifru_mtu; struct ifmap ifru_map; char ifru_slave[IFNAMSIZ]; char ifru_newname[IFNAMSIZ]; void __user * ifru_data; struct if_settings ifru_settings; } ifr_ifru; }; #define ifr_name ifr_ifrn.ifrn_name #define ifr_hwaddr ifr_ifru.ifru_hwaddr #define ifr_addr ifr_ifru.ifru_addr #define ifr_dstaddr ifr_ifru.ifru_dstaddr #define ifr_broadaddr ifr_ifru.ifru_broadaddr #define ifr_netmask ifr_ifru.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db6e6573aeb46e94fdf271930679c112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8d197952e08328c2bb99687225f67e/" rel="bookmark">
			解决github无法登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现问题 原因 GitHub的CDN域名遭到DNS污染，导致无法连接GitHub的加速分发服务器，使得国内访问速度很慢，甚至出现无法登录，请求超时
解决 通过修改hosts文件，将域名解析直接指向IP地址来绕过DNS解析
步骤（5步） 1. 打开hosts文件（C:\Windows\System32\drivers\etc\host），用记事本打开
2.在文件末尾加上域名映射
# Github 192.30.253.113 www.github.com 192.30.253.113 github.com 66.249.89.104 github.com 66.249.89.104 www.github.com 3.打开终端输入
ipconfig /flushdns 4.查看
ping github.com 5.重启浏览器
成功 参考 链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159e1450308e98b2c865cfbefe3622d1/" rel="bookmark">
			mysql 先排序再分组取时间最近的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql 先排序分组后取时间最近的数据 先直接上sql，解释后续有时间再写
SELECT * FROM ( SELECT v.* FROM people v INNER JOIN (SELECT MAX(add_time) 'max_add_time' FROM people GROUP BY name , age , sex ) c ON v.add_time = c.max_add_time WHERE v.`status` IN ( '1' , '2' , '3' , '4' ) ) AS temp GROUP BY name , age , sex ORDER BY add_time DESC LIMIT 0,10; 需要的自己先切换表明和字段名使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5483f2fb50a0d632f4a38ef1762c8731/" rel="bookmark">
			sparksql 读取Oracle一张表的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt; &lt;version&gt;10.2.0.4.0&lt;/version&gt; &lt;/dependency&gt; 记得添加oracle的驱动添加链接描述
import org.apache.spark.SparkConf import org.apache.spark.sql.{DataFrame, SparkSession} object Conn_Oracle { def main(args: Array[String]): Unit = { //Spark 连接Oracle数据库 //获取sparkConf val conf = new SparkConf() .setMaster("local[*]") .set("spark.serializer", "org.apache.spark.serializer.KryoSerializer") .setAppName(this.getClass.getName) //获取sparksesssion val session = SparkSession .builder() .config(conf) .getOrCreate() val sc = session.sparkContext // --------------------------------连接oracle数据库 ----------------------------------
val reader = session.read.format("jdbc") .option("url", "jdbc:oracle:thin:@10.10.1.253:1521:bidwdev") .option("driver", "oracle.jdbc.driver.OracleDriver") .option("user", "user") .option("password", "username") .option("dbtable", "table") val jdbcDf: DataFrame = reader.load() jdbcDf.show() } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6785c2aaa9713bdeedc3235bcec38505/" rel="bookmark">
			在什么情况下需要申请微信开放平台个人总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提到微信公众平台，大家并不陌生，立马就可以想到公众号和小程序。是的，我们平时使用的服务号/订阅号/小程序注册登录都是在微信公众平台管理的。对于开放平台可能不是第三方的开发技术同学，我们或许不会接触到开放平台这块。其实微信开放平台可以简单的理解为代替用户管理公众号和小程序的第三方平台的管理。
微信开放平主体为个人主体是无法认证的，所以个人主体是无法使用开放平台功能的。应用比较多的有两个功能：
一个是作为第三方平台，一个开放平台账号可以创建五个第三方平台。创建第三方平台后，我们就可以通过用户授权到该第三方平台，帮客户管理公众号和小程序功能了。关于开放平台如何接入，请参考微信官方文档https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Resource_Center_Homepage.html?action=dir_list&amp;t=resource%2Fres_list&amp;verify=1&amp;lang=zh_CN
另一个帮用户实现多端打通。比如同一个商家/企业，既有公众号，小程序，移动应用，网站应用等多端程序，想实现多端请求时，用户只要在一端注册过，同一个用户在其他端登录后，用户的信息，所得的赠品，积分等数据都是相同的。那公众号小程序为例，一个企业既有公众号，又有小程序，普通情况下，公众号和小程序同一个微信用户登录后，对于公众号和小程序来说是两个不用的用户，那么登录后的数据也是不一致的。因为openid不同，我们是无法区分是否是一个微信用户的。如何这时企业想要实现登录过公众号和登录小程序的这个微信用户在他的会员信息里面为一个会员的话，那么开放平台多端打通就可以实现这个需求了。只要将公众号和小程序添加的微信开放平台，我们接可以获的一个唯一的UnionId(用户唯一标识)。我们可以使用获取的UnionId，使公众号和小程序用户统一。
微信开放平台个人总结就到这里了。关于具体的调用方法大家可以去微信官方查看官方文档自行补脑哈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a963f4f92260d437b13b43b7faad197/" rel="bookmark">
			C语言，爬动的蠕虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目内容：
一条蠕虫长1寸，在一口深为N寸的井的底部。已知蠕虫每1分钟可以向上爬U寸，但必须休息1分钟才能接着往上爬。在休息的过程中，蠕虫又下滑了D寸。就这样，上爬和下滑重复进行。请问，蠕虫需要多长时间才能爬出井？
这里要求不足1分钟按1分钟计，并且假定只要在某次上爬过程中蠕虫的头部到达了井的顶部，那么蠕虫就完成任务了。初始时，蠕虫是趴在井底的（即高度为0）。
输入格式:
输入在一行中顺序给出3个正整数N、U、D，其中D&lt;U，N不超过100。
输出格式：
在一行中输出蠕虫爬出井的时间，以分钟为单位。
输入样例：
12 3 1
输出样例：
11
#include&lt;stdio.h&gt; int main() { int n,u,d,t=0,s=0; scanf("%d %d %d",&amp;n,&amp;u,&amp;d); while(1) { t++; s+=u; //向上爬 if(s&gt;=n) break; //判断是否到达井口 t++; s-=d; //向下掉 if(s&gt;=n) break; //判断是否到达井口 } printf("%d",t); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5cbed5b1bc6a102c6b732b372c36c5/" rel="bookmark">
			解决：连接不上 docker中的mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决：连接不上 docker中的mysql 在docker中安装了mysql后，用SQLyog去连接的时候出现如下错误。
2059 : Authentication plugin ‘caching_sha2_password’ cannot be loaded: 解决办法如下：
1、查看我们想要连接的mysql是否启动
#查看在运行的容器 docker ps -s 2、进入容器
#docker exec -it 容器号 /bin/bash docker exec -it b30062adc08c /bin/bash 3、运行mysql
mysql -u root -p #输入密码（跟之前在windows上运行mysql是一样的） 最后输入更新密码语句：
#我这里的密码是123456 ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; 4、重启mysql，再使用工具连接。
注意输入你自己服务器的ip。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28297e3bec7c5fef76b7e86fad0ccb6/" rel="bookmark">
			统计各位上数字和为5的数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目内容：
输出区间M,N之间所有各位数值之和为5的数，并统计输出满足条件的数的个数。
输入格式:
输入在一行中给出2个正整数M和N(100≤M≤N≤1000)，中间用空格间隔。
输出格式：
在第一行中输出满足条件的所有数，每个数后面一个空格。
在第二行按count = 总数的格式输出满足条件的数的个数。
**注意：**若没有满足条件的数，则第一行为空行
输入样例：
200 300
输出样例：
203 212 221 230
count = 4
#include&lt;stdio.h&gt; int main() { int a,b,i,j,count=0,num1,num2,num3; scanf("%d %d",&amp;a,&amp;b); for(i=a;i&lt;=b;i++) { num1=i/100; num2=i/10-num1*10; num3=i%10; if(num1+num2+num3==5) { count++; printf("%d ",i); } } printf("\n"); printf("count = %d",count); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c381157d535b641ba5607f7caf24800/" rel="bookmark">
			VMware Workstation 15 界面语言改成中文或其他语言的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从官网安装VMware 15.5Pro 之后 ，打开虚拟机一直是全英文版，如图示
查看资料后都说在找到你的VMware安装目录：我的是D:\VMware Workstation\messages
有ja、zh_CN两个语言包，
只需要把zh_CN文件夹重命名，或移动保存到其他盘符，再重启VMware，就是英文了，
如果要使用中文版则把zh_CN文件夹恢复回来即可
但是尝试几次之后还是显示英文。
最终找到了问题所在，原来是系统的时区选择的时意大利，在控制面板找到区域和语言，设置为 中国 即可 只需要改回中国 简体即可，点击应用，VMware启动 ，界面变成中文版
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/459fe7e92a9b68d433d3160b496776ec/" rel="bookmark">
			nacos-server配置中心连接数据库失败的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本地配置nacos时发现一直报数据库无法连接。错误信息类似这样：
org.springframework.jdbc.cannotgetjdbcconnectionexception: failed to obtain jdbc connection; nested exception is org.apache.commons.dbcp.sqlnestedexception: cannot create poolableconnectionfactory (could not create connection to database server. attempted reconnect 3 times. giving up.)
经过测试数据库连接是通的，但就是不行。经过验证有几个坑需要注意。
1.在nacos-server的conf目录下有个配置文件示例，application.properties.example，但是我们在用的时候需要将其改成bootstrap.properties才可以。
2.这个文件的配置内容为
spring.datasource.platform=mysql ### Count of DB: # db.num=1 ### Connect URL of DB: db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true db.user=root db.password=root 这里需要注意的是如果你直接修改了示例文件中的配置文件，需要将# 号后面的 空格去掉，否则就回阴沟里帆船了。
其他还看到过将mysql的连接jar复制到nacos下等，都不起作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/140809882232f9ca0b96f13b5caff043/" rel="bookmark">
			【菜鸟进阶之路】P3741 honoka的键盘 - 洛谷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目部分
题目描述
honoka 有一个只有两个键的键盘。一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有 VK 这个字符串的时候，honoka 就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串内 VK 出现的次数。给出原来的字符串，请计算她最多能使这个字符串内出现多少次 VK（只有当 V 和 K 正好相邻时，我们认为出现了 VK。）
输入格式
第一行给出一个数字 n，代表字符串的长度。
第二行给出一个字符串 s。
输出格式
第一行输出一个整数代表所求答案。
输入输出样例
二、解题过程
思路
（1）char数组存放输入的字符串，方便之后的判断和变更（数据长度更大的时候建议还是用回string）；
（2）改变字符前，先判断字符串里存在多少个“VK”，用cnt存储数量；
（3）开始改变字符，这里要特别注意改变字符的规则（只能改变一次），分两种情况，第一种，遇到字符‘V’时，如果前一个字符是‘V’且后一个字符不是‘K’时，可以变更为“VK”，cnt+1；第二种，遇到字符‘K’时，如果前一个字符不是‘V’且后一个字符是‘K’时，可以变更为“VK”，cnt+1。这一次字符变更结束后退出循环；
（4）输出cnt。
提交AC答案
#include&lt;bits/stdc++.h&gt; using namespace std; int n,cnt; char a[100]; int main() {	scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) if(a[i]=='V'&amp;&amp;a[i+1]=='K') cnt++; for(int i=0;i&lt;n;i++) { if(a[i]=='V') { if(a[i-1]=='V'&amp;&amp;a[i+1]!='K') { cnt++; break; } } else if(a[i]=='K') { if(a[i-1]!='V'&amp;&amp;a[i+1]=='K') { cnt++; break; }	}	}	cout&lt;&lt;cnt; return 0; } 亲测，过50个测试点的感觉是不一般的快乐~（虽然不是一次性AC）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/242/">«</a>
	<span class="pagination__item pagination__item--current">243/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/244/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>