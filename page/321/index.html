<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7570f8fe2d14b6dc8e35cfd616bf15dd/" rel="bookmark">
			把onmouseover事件写在css文件里面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般的写法是直接在页面无素的标签里面写以下这样的代码：
οnmοuseοver="this.style.backgroundColor='#FFFFFF'" οnmοuseοut="this.style.backgroundColor='#000000'"
如果想把 鼠标事件 写进 样式表当中：
.showCSS{
event:expression(
onmouseover = function()
{
this.style.backgroundColor='#f0f0f0'
},
onmouseout = function()
{
this.style.backgroundColor='#ffffff'
}
)
}
&lt;div class="showCSS&gt;把鼠标放上去,看看，可以了吧！：）&lt;/div&gt; 如果是想 再简单点 引用鼠标事件，那就：
在表中例如： &lt;td οnmοuseοver="this.className='a';" οnmοuseοut="this.classname='b';"&gt; 简单吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448df2bddc10202668dcd0a1875e9b1f/" rel="bookmark">
			如何在页面中使用Acegi权限集合和taglib控制页面元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在页面中使用Acegi权限集合和taglib控制页面元素
王保政
Email:baozhengw@netease.com
JSP页面中的页面元素,URL,按钮是否可见或变灰都可通过Acegi标签库来实现，使用Acegi标签库，可设置不同的权限ID允许点击的按钮,访问的URL,或隐藏无权限的功能菜单。
如何配置和使用标签库？
打开acegi-security-1.0.3.jar,在META-INF目录中有一个authz.tld文件，将此文件复制到你的web应用的WEB-INF/tld中，然后配置web.xml,增加:
&lt;taglib&gt; &lt;taglib-uri&gt;http://acegisecurity.sf.net/authz&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/authz.tld&lt;/taglib-location&gt; &lt;/taglib&gt;
然后JSP页面可以通过声明&lt;%@ taglib uri="http://acegisecurity.sf.net/authz" prefix="authz"%&gt;来引用标签库。
声明了标签以后，在页面中可以按下面的格式使用acegi标签(authz标签可以嵌套使用)：
&lt;!-- 使用权限标签的例子,标签可以嵌套 --&gt;
&lt;authz:authorize ifAnyGranted="AUTH_USER"&gt; &lt;td&gt; 一般用户权限
&lt;/td&gt; &lt;authz:authorize ifAnyGranted="AUTH_ADMIN"&gt; &lt;td&gt; 超级用户权限
&lt;/td&gt; &lt;/authz:authorize&gt;
&lt;/authz:authorize&gt;
&lt;authz:authorize ifAnyGranted="AUTH_SYS"&gt; &lt;td&gt; 系统维护权限
&lt;/td&gt; &lt;/authz:authorize&gt;
也可以在JavaScript中用document.write输出权限标签：
&lt;script language="JavaScript" type="text/javascript"&gt;
//订单中心
document.write('&lt;authz:authorize ifAnyGranted="AUTH_TAG_ORDER_CENTER"&gt; ');
new tree(TREE_ITEMS1, TREE_TPL);
document.write('&lt;/authz:authorize&gt;');
&lt;/script&gt;
在有javaScript脚本中有时不方便引用acegi标签，可以从SecurityContextHolder中获得权限集合，然后判断当前登录的用户，其权限集合中是否有某权限，根据判断结果来决定显示或隐藏哪些页面元素，见下面的JSP:
&lt;%@ page contentType="text/html; charset=GBK"%&gt;
&lt;%@ taglib uri="/WEB-INF/struts-html.tld" prefix="html" %&gt;
&lt;%@ taglib uri="/WEB-INF/struts-bean.tld" prefix="bean" %&gt;
&lt;%@ taglib uri="/WEB-INF/struts-logic.tld" prefix="logic"%&gt;
&lt;%@ taglib uri="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/448df2bddc10202668dcd0a1875e9b1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1871d410cb8c21189d994a2cdb40d2f7/" rel="bookmark">
			重修:拉格朗日恒等式(初等代数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目: 对于实数,证明拉格朗日恒等式
(数学分析,第二版, Tom M.Apostol著, 刑富冲等译) 分析:最重要的是知道这两个:
用归纳法证明,忽略
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5ce2938d5e91d67db55e6a8323ec8b/" rel="bookmark">
			Windows下的tail一二三：tail、BareTail、WinTail
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下的tail一二三：tail、BareTail、WinTail 在Windows下查看输了的日志log的文件，使用UE或Edit plus可以知道文件改变了，但是光标都会回到文件头部去，很不方便，用记事本就更不用说了。 如何才能在Windows下象在Linux使用tail一样方便地来查看日志呢？ 1、Windows Server 2003 Resource Kit Tools [url]http://www.microsoft.com/downloads/details.aspx?familyid=9d467a69-57ff-4ae7-96ee-b18c4790cffd&amp;displaylang=en[/url] [url]http://download.microsoft.com/download/8/e/c/8ec3a7d8-05b4-440a-a71e-ca3ee25fe057/rktools.exe[/url] 但是这个下载后的文件却是要求Windows XP系统之类的，我用的是Win2K，晕，当然有方法来绕过它了。 还是先下载文件，用WinRAR可以解开它，成三个文件：rktools.msi、rktools_p.cab和rktools_s.cab rktools.msi安装包是所有的工具集的安装文件，用7-Zip直接解压打开就可以看到里面的文件了，比如解压到C:\DOS目录下 rktools_p.cab和rktools_s.cab文件里包含一个rktools.chm的使用帮助文件，同样用7-Zip来打开，用WinRAR或者WinCAB也可以打开 使用： C:\DOS&gt;tail/? 一成不变的方法，/?来查看使用帮助 usage: TAIL [switches] [filename]* switches: [-?] display this message [-n] display last n lines of each file (default 10) [-f filename] keep checking filename for new lines 示例： tail xxx.log 查看文件，默认显示最后的10行 tail -100 xxx.log 显示最后的100行 tail -f xxx.log 一直查看文件的变化。 Kit Tools里还包含了很多有用的工具，其它的不进行介绍了，自已去挖掘：） 2、BareTail : A free real-time log file monitoring tool，有Free Version [url]http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc5ce2938d5e91d67db55e6a8323ec8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4849ca2f4004534510091b5e86d637/" rel="bookmark">
			虚拟机上安装linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载VMWare解压
根据提示正触安装VMWare到硬盘中 (1) 建立虚拟机 A.用鼠标左建双击桌面中的"VMware workstation"图标，运行虚拟机 B.建立一台虚拟机。点击“FILE(文件)”-“NEW(新建)”--“NewVirtual Machine( 新建虚拟机)”，弹出虚拟机创建菜单。 C.根据向导一步一步地创建虚拟机，首先选择安装方式是“TYPICAL(典型)”还是 “CUSTOM(自定义)”安装。 我这里选择典型。 D.因为这里是用于安装REDHAT，所以在Guest operating system(客户操作系统)“ 中选择”LINUX“，点击下一步。 E.在Virtual machine name(虚拟机名字)中输入你想建立的虚拟机的名字 F.在Location(位置)中选择虚拟机的安装位置。因为会在虚拟机中安装操作系统 和应用软件，所以建议将虚拟机安装在一个有较大空间的磁盘分区中 G.如果你的电脑连接在网络中，那么选择一个合适的网络环境。我这里选择 Use bridged net-working(使用路由网络) H.点击finish,返回VMWARE主界面，LINUX虚拟机就建好了。 2. 安装操作系统 A. 选中LINUX虚拟机，点击VMWARE工具栏中的Power ON按钮，启动LINUX虚拟机 B.然后插入REDHAT7.3光盘，虚拟系统根据你选择的安装方式开始安装。 3.从硬盘安装REDHAT7.3 如果你认为从光驱中安装比较费时间，又不方便，那你可以将光盘文件转换成ISO文件拷 贝在硬盘中，然后从硬盘安装。 A.点击Settings(设置)--Configuration Editor(编辑配置)进入设置界面对虚拟机进行 配置。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dee74d4217b33fb706a8691bd63df5ce/" rel="bookmark">
			web-app_2_4.xsd验证web.xml报j2ee_web_services_client_1_1.xsd找不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web-app_2_4.xsd验证web.xml时报j2ee_web_services_client_1_1.xsd找不到的问题 web.xml [code] &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app id="WebApp_ID" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;/web-app&gt; [/code] 要在网上读取验证文件 [url]http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd[/url] 来验证web.xml文件格式的正确性，导致速度变慢。 该验证在修改xml文件后，每次保存文件时都要进行执行的。 一、XMLSpy中的解决办法 1、下载以下所有的验证文件到本地，比如放：&lt;XMLSpy_HOME&gt;\Schemas\java目录下 [url]http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd[/url] [url]http://java.sun.com/xml/ns/j2ee/jsp_2_0.xsd[/url] [url]http://java.sun.com/xml/ns/j2ee/j2ee_1_4.xsd[/url] [url]http://java.sun.com/xml/ns/j2ee/j2ee_web_services_client_1_1.xsd[/url] 注意： j2ee_1_4.xsd 中却包含了 Web services schema ，即如下： [code] &lt;xsd:include schemaLocation="http://www.ibm.com/webservices/xsd/j2ee_web_services_client_1_1.xsd"/&gt; [/code] 但是要下载却下载不了，于是上Sun Java去。。。 在 [url]http://java.sun.com/xml/ns/j2ee/[/url] 中有，显示的仍是ibm的，但链接是sun的，可以直接下载下来的 于是索性在 j2ee_1_4.xsd 就更改掉它：） [code] &lt;!-- &lt;xsd:include schemaLocation="http://www.ibm.com/webservices/xsd/j2ee_web_services_client_1_1.xsd"/&gt; --&gt; &lt;xsd:include schemaLocation="j2ee_web_services_client_1_1.xsd"/&gt; [/code] 2、在 &lt;XMLSpy_HOME&gt;\MainCatalog.xml 文件中增加如下内容并保存 [code] &lt;!-- web-app 2.4 Section --&gt; &lt;uri name="http://java.sun.com/xml/ns/j2ee" uri="schemas/java/web-app_2_4.xsd"/&gt; [/code] 3、重启XMLSpy，打开web.xml，然后按F8吧，绿色的打色出现了吧。 二、Eclipse中的解决办法 1、同上下载所有的验证文件到本地。。。 2、Windows ==&gt; Preferences ==&gt; Web and XML ==&gt; XML Catalog，然后右边窗口点击 add 按钮，打开 Add XML Catalog Entry 窗口。URI选择框选择到 web-app_2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dee74d4217b33fb706a8691bd63df5ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c514d30982247ea3caefce4f495635a/" rel="bookmark">
			LINUX中清空输入缓冲区最简便的方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio_ext.h&gt; __fpurge(stdin); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533ba1cbead85ec1190ccff5fd596db0/" rel="bookmark">
			makefile详解 函数 字符串 文件名 二十一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		makefile详解 函数 字符串 文件名 二十一 在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。 一、函数的调用语法 函数调用，很像变量的使用，也是以“$”来标识的，其语法如下： $(&lt;function&gt;; &lt;arguments&gt;;) 或是 ${&lt;function&gt;; &lt;arguments&gt;;} 这里，&lt;function&gt;;就是函数名，make支持的函数不多。&lt;arguments&gt;;是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。 还是来看一个示例： comma:= , empty:= space:= $(empty) $(empty) foo:= a b c bar:= $(subst $(space),$(comma),$(foo)) 在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”。 二、字符串处理函数 $(subst &lt;from&gt;;,&lt;to&gt;;,&lt;text&gt;;) 名称：字符串替换函数——subst。 功能：把字串&lt;text&gt;;中的&lt;from&gt;;字符串替换成&lt;to&gt;;。 返回：函数返回被替换过后的字符串。 示例： $(subst ee,EE,feet on the street)， 把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。 $(patsubst &lt;pattern&gt;;,&lt;replacement&gt;;,&lt;text&gt;;) 名称：模式字符串替换函数——patsubst。 功能：查找&lt;text&gt;;中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式&lt;pattern&gt;;，如果匹配的话，则以&lt;replacement&gt;;替换。这里，&lt;pattern&gt;;可以包括通配符“%”，表示任意长度的字串。如果&lt;replacement&gt;;中也包含“%”，那么，&lt;replacement&gt;;中的这个“%”将是&lt;pattern&gt;;中的那个“%”所代表的字串。（可以用“/”来转义，以“/%”来表示真实含义的“%”字符） 返回：函数返回被替换过后的字符串。 示例： $(patsubst %.c,%.o,x.c.c bar.c) 把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o” 备注： 这和我们前面“变量章节”说过的相关知识有点相似。如： “$(var:&lt;pattern&gt;;=&lt;replacement&gt;;)” 相当于 “$(patsubst &lt;pattern&gt;;,&lt;replacement&gt;;,$(var))”， 而“$(var: &lt;suffix&gt;;=&lt;replacement&gt;;)” 则相当于 “$(patsubst %&lt;suffix&gt;;,%&lt;replacement&gt;;,$(var))”。 例如有：objects = foo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/533ba1cbead85ec1190ccff5fd596db0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a7714bf9368ee21830bd2d3b1ef968/" rel="bookmark">
			“菩提本无树，明镜亦非台，本来无一物，何处惹尘埃？”谁知此禅诗为何意？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 菩提本非树, 明镜亦非台, 本来无一物, 何处染尘埃. 少林六祖慧能偈语. 菩提树下是佛祖悟道的地方. 菩提树本来不是树,明镜台也不是台. 本来什么都没有,怎么能染上尘埃呢? 慧能写这个偈语之前北宗六祖神秀有偈语. 身是菩提... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6cf6dfa32b6ea4b480c0c3e1c0ff249/" rel="bookmark">
			Linux 2.6.21 之前关于usb网卡ZT6688驱动的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 买了块USB网卡 硬件标识是ZT6688的, 这个网卡的驱动在2.6.21.1的内核中已经提供位于/lib/modules/`uname -r`/kernel/drivers/usb/net/dm9601.ko 如果想在2.6.21之前的内核中使用ZT6688的usb网卡： 1, 下载dm9601的linux-2.6驱动http://www.davicom.com.tw/big5/download/Driver/dm9601/dm9601-2.6.tgz 2, tar -zxvf dm9601-2.6.tgz 3, cd dm9601-2.6 4, 修改dm9601.h 在#endif /* _DEV */前面加上下面语句: DM9601_DEV( "ZT6688 USB Ethernet", 0x0a46, 0x6688, DEFAULT_GPIO_RESET ) 5, make 6, cp dm9601.ko /lib/modules/`uname -r`/kernel/drviers/usb/net/ 7, depmod 8, modprobe dm9601 9, tail -100f /var/log/syslog 10, 可以看到已经成功找到了ZT6688网卡了 /sbin/ifconfig 看下 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b0892ed8f26d5d6fdafd1cabdd54297/" rel="bookmark">
			实现Comparable接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 要求修改实验三自定义的Employee类，使其实现Comparable接口；
定义ReportCard类，在其中定义一员工对象的集合，并按员工姓名的字母排序返回员工姓名和薪水的报表；
定义EmployeeTest类，通过在其中编写测试代码，验证员工集合中的员工按姓名字母排序输出； import java.util.*;
class Employee implements Comparable&lt;Employee&gt; {
private String name;
private float salary;
private int id;
private int nextId; Employee(String name,float salary,int id,int nextId){
this.name=name;
this.salary=salary;
this.id=id;
this.nextId=nextId;
}
String getName(){
return name;
}
float getSalary(){
return salary;
}
int getId(){
return id;
}
int getNextId(){
return nextId;
}
public int compareTo(Employee emp){
return this.getName().compareTo(emp.getName());
} }
class ReportCard {
ArrayList&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b0892ed8f26d5d6fdafd1cabdd54297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1be3070b4822bd32164d5fe7a22029d/" rel="bookmark">
			Java 实现后进先出(LIFO)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**/ /*
* Author: Eric Zhang
* Created: 20074る11ら と 01:09:25
* Modified: 20074る11ら と 01:09:25
* For LIFO
*/ import java.util. * ;
public class LinkedListStack ... {
private static class Node ...{
Object o;
Node next;
}
private Node top = null;
public boolean imEmpty() ...{
return top == null;
}
public Object peek() ...{
if (top == null)
throw new EmptyStackException();
return top.o;
}
public void push(Object o) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1be3070b4822bd32164d5fe7a22029d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9df2646966c4f6db0d618a83bfb1e4/" rel="bookmark">
			mediaplayer的控制参数 详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AllowChangeDisplaySize 返回或设置最终用户是否能设置显示尺寸(逻辑型)
AllowScan 返回或设置是否允许扫描(逻辑型)
AnimationAtStart 返回或设置控件开始播放之前是否先播放一个动画序列(逻辑型)
AudioStream 返回或设置音频流的编号(用于多音频流的剪辑，默认为-1)(长整型)
AutoRewind 返回或设置媒体文件播放完毕后是否自动回绕(逻辑型)
AutoSize 返回或设置是否自动调整控件大小来适应载入的媒体(逻辑型)
AutoStart 返回或设置在载入媒体文件之后是否自动开始播放(逻辑型)
Balance 返回或设置指定立体声媒体文件的播放声道(-10000为左声道，10000为右声道，0为立体声)(长整型)
Bandwidth 返回或设置当前文件的带宽(长整型)
BaseURL 返回基本的 HTTP URL(字符串)
BufferingCount 返回媒体文件回放时缓冲的总时间(长整型)
BufferingProgress 返回缓冲完成的百分比(长整型)
BufferingTime 返回缓冲的时间(双精度型)
CanPreview 返回或设置当前显示的剪辑是能否被预览(逻辑型)
CanScan 返回或设置当前文件是否支持快进或快退(逻辑型)
CanSeek 返回或设置当前文件是否能搜索并定位到某个时间(逻辑型)
CanSeekToMarkers 返回或设置文件是否支持搜索到标签(逻辑型)
CaptioningID 返回在标题中显示的帧或控件的名称(字符串)
ChannelDescription 返回电台的描述(字符串)
ChannelName 返回电台的名称(字符串)
ChannelURL 返回电台的元文件的位置(字符串)
ClickToPlay 返回或设置是否可以通过点击图像暂停或播放剪辑(逻辑型)
ClientID 返回客户端唯一的标识符(字符串)
CodecCount 返回文件使用的可安装的 codecs 的个数(长整型)
ContactAddress 返回电台的联系地址(字符串)
ContactEmail 返回电台的联系电子邮件地址(字符串)
ContactPhone 返回电台的联系电话(字符串)
CreationDate 返回剪辑的创建日期(日期型)
CurrentMarker 返回或设置当前书签号码(长整型)
CurrentPosition 返回或设置剪辑的当前位置(双精度型)
CursorType 返回或设置指针类型(长整型)
DefaultFrame 返回或设置控件的默认目标 Http 帧(字符串)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da9df2646966c4f6db0d618a83bfb1e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0955d74991bcee83c70907a770bd02d5/" rel="bookmark">
			常用软件密码破解完全指南[转]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般的密码破解不一定涉及复杂的技术手段。有人甚至这样形象地说过:“密码破解与找一张写有密码的贴纸一样简单，而这张纸就贴在显示器上或者藏在键盘底下。”根据不同情况运用不同的方法和一些小工具，密码就可以迎刃而解。 登录密码破解 VS Windows XP-2000-NT Key 破解工具:Windows XP-2000-NT Key 随着Windows系统版本的不断更新，安全性也得到了显著地提高，Windows 2000/XP登录时都要求用户输入密码以保证系统安全。要破解这类密码最好的办法非Windows XP-2000-NT Key莫属。它是一款专门针对Windows密码破解的工具软件。 打开该软件，可以看到最下方有一行提示:Please insert a blank floppy disk into drive A: and click NEXT when ready。这时，将准备好的软盘插入软驱，点Next，Windows XP-2000-NT Key 会自动将此盘制作为一张特殊的驱动盘。驱动盘做好后，接着用Windows 2000的安装盘启动待恢复密码的计算机，当提示 Press F6 if you need install party SCSI or RAID driver...时，按F6，等待加载过程结束后，看到提示:To specify addition al SCSI adapters, CD-ROM drivers or special disk controllers for use with Windows 2000,including those for which you have a device support disk from mass storage device manufacturer press S，立刻按S键，然后系统会接着提示:Please insert the disk labeled maufacturer-supplied hardwaresupport disk into driver A: * Press ENTER when ready。这时插入软盘加载上面做好的Windows XP-2000-NT Key驱动。稍等片刻，系统便会自动进入Windows XP-2000-NT Key环境。这时系统会提示:Set Administrator\Password to \12345\?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0955d74991bcee83c70907a770bd02d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0001d420836fec7a4faa20537907a9e/" rel="bookmark">
			C#中英文语音合成与中文语音识别技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在.net中,对英文语音有较好的支持，但是对中文语音的支持还没有加入进来，我们要想实现中文发音或中文语音识别，必需先安装微软的Speech Application SDK（SASDK），它的最新版本是 SAPI 5.1 他能够识别中、日、英三种语言，你可以在这里下载：http://www.microsoft.com/speech/download/sdk51/,需要安装这两个文件Speech SDK 5.1和5.1 Language Pack，其中5.1 Language Pack可以选择安装支持的语言。 安装好以后，我们就可以开始进行语音程序的开发了，当然，在这之前我们需要把SAPI.dll通过如下图所示添加到引用中 下面我们设计一个能够朗读中英文混合语言的类： 我们将用单例模式实现该类，类的代码如下，我们将详细解释： public class Speach { private static Speach _Instance = null ; private SpeechLib.SpVoiceClass voice =null; private Speach() { BuildSpeach() ; } public static Speach instance() { if (_Instance == null) _Instance = new Speach() ; return _Instance ; } private void SetChinaVoice() { voice.Voice = voice.GetVoices(string.Empty,string.Empty).Item(0) ; } private void SetEnglishVoice() { voice.Voice = voice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0001d420836fec7a4faa20537907a9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e3cc85727824dbdd26188f948580c91/" rel="bookmark">
			U盘无法双击打开的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 删除U盘下的autorun，此文件是隐藏文件，重启后即可双击打开 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6fc57df79a607390390d19e9dc4d78/" rel="bookmark">
			修复mysql的数据表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实验用脚本添加用户并更改权限的时候，不知何故提示mysql/user.MYI需要修复
/et/init.d/mysql restart 重启失败
cd /var/lib/mysql/mysql
myisamchk *.MYI
提示如下信息
MyISAM-table 'user.MYI' is corrupted
Fix it using switch "-r" or "-o"
myisamchk user.MYI -r -o - recovering (with keycache) MyISAM-table 'user.MYI'
Data records: 5
Data records: 4
修复后重启正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e2474e4b74e04583b49e92cc14e82e/" rel="bookmark">
			Hashtable(完整实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请支持原创作者, 转载请说明出处! #ifndef _HASHTABLE_H
#define _HASHTABLE_H
struct hashtable;
struct hashtable* hashtable_create(unsigned long size, unsigned long(*hash_func)(const void *key),
int(*test_func)(const void *key1, const void *key2));
struct hashtable* make_string_hashtable(unsigned long size);
int hashtable_put(struct hashtable *ht, const void *key, void *value);
void* hashtable_get(struct hashtable *ht, const void *key);
int hashtable_remove(struct hashtable *ht, const void *key);
int hashtable_contains(struct hashtable *ht, const void *key);
int hashtable_set(struct hashtable *ht, const void *key, void *newvalue);
unsigned long hashtable_count(struct hashtable *ht);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e2474e4b74e04583b49e92cc14e82e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf844805fd4b9123507be6a750fbd88b/" rel="bookmark">
			最经典的黑客技术入门知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最经典的黑客技术入门知识 &lt;转自&gt; “黑客”大体上应该分为“正”、“邪”两类，正派黑客依靠自己掌握的知识帮助系统管理员找出系统中的漏洞并加以完善，而邪派黑客则是通过各种黑客技能对系 统进行攻击、入侵或者做其他一些有害于网络的事情，因为邪派黑客所从事的事情违背了《黑客守则》，所以他们真正的名字叫“骇客”（Cracker）而非 “黑客”（Hacker），也就是我们平时经常听说的“黑客”（Cacker）和“红客”（Hacker）。 无论那类黑客，他们最初的学习内容都将是本部分所涉及的内容，而且掌握的基本技能也都是一样的。即便日后他们各自走上了不同的道路，但是所做的事情也差不多，只不过出发点和目的不一样而已。 很多人曾经问我：“做黑客平时都做什么？是不是非常刺激？”也有人对黑客的理解是“天天做无聊且重复的事情”。实际上这些又是一个错误的认识，黑客平时 需要用大量的时间学习，我不知道这个过程有没有终点，只知道“多多益善”。由于学习黑客完全出于个人爱好，所以无所谓“无聊”；重复是不可避免的，因为 “熟能生巧”，只有经过不断的联系、实践，才可能自己体会出一些只可意会、不可言传的心得。 在学习之余,黑客应该将自己所掌握的知识应用到实际当中,无论是哪种黑客做出来的事情,根本目的无非是在实际中掌握自己所学习的内容。黑客的行为主要有以下几种： 一、学习技术： 互联网上的新技术一旦出现，黑客就必须立刻学习，并用最短的时间掌握这项技术，这里所说的掌握并不是一般的了解，而是阅读有关的“协议”（rfc）、深入了解此技术的机理，否则一旦停止学习，那么依靠他以前掌握的内容，并不能维持他的“黑客身份”超过一年。 初级黑客要学习的知识是比较困难的，因为他们没有基础，所以学习起来要接触非常多的基本内容，然而今天的互联网给读者带来了很多的信息，这就需要初级学 习者进行选择：太深的内容可能会给学习带来困难；太“花哨”的内容又对学习黑客没有用处。所以初学者不能贪多，应该尽量寻找一本书和自己的完整教材、循序 渐进的进行学习。 二、伪装自己： 黑客的一举一动都会被服务器记录下来，所以黑客必须伪装自己使得对方无法辨别其真实身份，这需要有熟练的技巧，用来伪装自己的IP地址、使用跳板逃避跟踪、清理记录扰乱对方线索、巧妙躲开防火墙等。 伪装是需要非常过硬的基本功才能实现的，这对于初学者来说成的上“大成境界”了，也就是说初学者不可能用短时间学会伪装，所以我并不鼓励初学者利用自己学习的知识对网络进行攻击，否则一旦自己的行迹败露，最终害的害是自己。 如果有朝一日你成为了真正的黑客，我也同样不赞成你对网络进行攻击，毕竟黑客的成长是一种学习，而不是一种犯罪。 三、发现漏洞： 漏洞对黑客来说是最重要的信息，黑客要经常学习别人发现的漏洞，并努力自己寻找未知漏洞，并从海量的漏洞中寻找有价值的、可被利用的漏洞进行试验，当然他们最终的目的是通过漏洞进行破坏或着修补上这个漏洞。 黑客对寻找漏洞的执著是常人难以想象的，他们的口号说“打破权威”，从一次又一次的黑客实践中，黑客也用自己的实际行动向世人印证了这一点——世界上没有“不存在漏洞”的程序。在黑客眼中，所谓的“天衣无缝”不过是“没有找到”而已。 四、利用漏洞： 对于正派黑客来说，漏洞要被修补；对于邪派黑客来说，漏洞要用来搞破坏。而他们的基本前提是“利用漏洞”，黑客利用漏洞可以做下面的事情： 1、获得系统信息：有些漏洞可以泄漏系统信息，暴露敏感资料，从而进一步入侵系统； 2、入侵系统：通过漏洞进入系统内部，或取得服务器上的内部资料、或完全掌管服务器； 3、寻找下一个目标：一个胜利意味着下一个目标的出现，黑客应该充分利用自己已经掌管的服务器作为工具，寻找并入侵下一个系统； 4、做一些好事：正派黑客在完成上面的工作后，就会修复漏洞或者通知系统管理员，做出一些维护网络安全的事情； 5、做一些坏事：邪派黑客在完成上面的工作后，会判断服务器是否还有利用价值。如果有利用价值，他们会在服务器上植入木马或者后门，便于下一次来访；而对没有利用价值的服务器他们决不留情，系统崩溃会让他们感到无限的快感！ 第二节、黑客应掌握的基本技能 从这一节开始，我们就真正踏上学习黑客的道路了，首先要介绍的是作为一名初级黑客所必须掌握的基本技能，学习这可以通过这一节的阅读了解到黑客并不神 秘，而且学习起来很容易上手。为了保证初学者对黑客的兴趣，所以本书采取了循环式进度，也就是说每一章节的内容都是独立、全面的，学习者只有完整的学习过 一章的内容，才能够进而学习下一章的内容。 一、了解一定量的英文： 学习英文对于黑客来说非常重要，因为现在大多 数资料和教程都是英文版本，而且有关黑客的新闻也是从国外过来的，一个漏洞从发现到出现中文介绍，需要大约一个星期的时间，在这段时间内网络管理员就已经 有足够的时间修补漏洞了，所以当我们看到中文介绍的时候，这个漏洞可能早就已经不存在了。因此学习黑客从一开始就要尽量阅读英文资料、使用英文软件、并且 及时关注国外著名的网络安全网站。 二、学会基本软件的使用： 这里所说的基本软件是指两个内容：一个是我们日常使 用的各种电脑常用命令，例如ftp、ping、net等；另一方面还要学会有关黑客工具的使用，这主要包括端口扫描器、漏洞扫描器、信息截获工具和密码破 解工具等。因为这些软件品种多，功能各不相同，所以本书在后面将会介绍几款流行的软件使用方法，学习者在掌握其基本原理以后，既可以选择适合自己的，也可 以在“第二部分”中找到有关软件的开发指南，编写自己的黑客工具。 三、初步了解网络协议和工作原理： 所谓“初步了 解”就是“按照自己的理解方式”弄明白网络的工作原理，因为协议涉及的知识多且复杂，所以如果在一开始就进行深入研究，势必会大大挫伤学习积极性。在这里 我建议学习者初步了解有关tcp/ip协议，尤其是浏览网页的时候网络是如何传递信息、客户端浏览器如何申请“握手信息”、服务器端如何“应答握手信息” 并“接受请求”等内容，此部分内容将会在后面的章节中进行具体介绍。 四、熟悉几种流行的编程语言和脚本： 同上面 所述一样，这里也不要求学习者进行深入学习，只要能够看懂有关语言、知道程序执行结果就可以了。建议学习者初步学习C语言、asp和cgi脚本语言，另外 对于htm超文本语言和php、java等做基本了解，主要学习这些语言中的“变量”和“数组”部分，因为语言之间存在内在联系，所以只要熟练掌握其中一 们，其他语言也可以一脉相同，建议学习C语言和htm超文本语言。 五、熟悉网络应用程序： 网络应用程序包括各种 服务器软件后台程序，例如：wuftp、Apache等服务器后台；还有网上流行的各种论坛、电子社区。有条件的学习者最好将自己的电脑做成服务器，然后 安装并运行一些论坛代码，经过一番尝试之后，将会感性的弄清楚网络工作原理，这比依靠理论学习要容易许多，能够达到事半功倍的效果！ 第三节、网络安全术语解释 一、协议： 网络是一个信息交换的场所，所有接入网络的计算机都可以通过彼此之间的物理连设备行信息交换，这种物理设备包括最常见的电缆、光缆、无线WAP和微波 等，但是单纯拥有这些物理设备并不能实现信息的交换，这就好像人类的身体不能缺少大脑的支配一样，信息交换还要具备软件环境，这种“软件环境”是人类实现 规定好的一些规则，被称作“协议”，有了协议，不同的电脑可以遵照相同的协议使用物理设备，并且不会造成相互之间的“不理解”。 这种 协议很类似于“摩尔斯电码”，简单的一点一横，经过排列可以有万般变化，但是假如没有“对照表”，谁也无法理解一分杂乱无章的电码所表述的内容是什么。电 脑也是一样，它们通过各种预先规定的协议完成不同的使命，例如RFC1459协议可以实现IRC服务器与客户端电脑的通信。因此无论是黑客还是网络管理 员，都必须通过学习协议达到了解网络运作机理的目的。 每一个协议都是经过多年修改延续使用至今的，新产生的协议也大多是在基层协议基 础上建立的，因而协议相对来说具有较高的安全机制，黑客很难发现协议中存在的安全问题直接入手进行网络攻击。但是对于某些新型协议，因为出现时间短、考虑 欠周到，也可能会因安全问题而被黑客利用。 对于网络协议的讨论，更多人则认为：现今使用的基层协议在设计之初就存在安全隐患，因而无论网络进行什么样的改动，只要现今这种网络体系不进行根本变革，从根本上就无法杜绝网络黑客的出现。但是这种黑客机能已经超出了本书的范围，因而不在这里详细介绍。 二、服务器与客户端： 最简单的网络服务形式是：若干台电脑做为客户端，使用一台电脑当作服务器，每一个客户端都具有向服务器提出请求的能力，而后由服务器应答并完成请求的动 作，最后服务器会将执行结果返回给客户端电脑。这样的协议很多。例如我们平时接触的电子邮件服务器、网站服务器、聊天室服务器等都属于这种类型。另外还有 一种连接方式，它不需要服务器的支持，而是直接将两个客户端电脑进行连接，也就是说每一台电脑都既是服务器、又是客户端，它们之间具有相同的功能，对等的 完成连接和信息交换工作。例如DCC传输协议即属于此种类型。 从此看出，客户端和服务器分别是各种协议中规定的请求申请电脑和应答电 脑。作为一般的上网用户，都是操作着自己的电脑（客户端），别且向网络服务器发出常规请求完成诸如浏览网页、收发电子邮件等动作的，而对于黑客来说则是通 过自己的电脑（客户端）对其他电脑（有可能是客户端，也有可能是服务器）进行攻击，以达到入侵、破坏、窃取信息的目的。 三、系统与系统环境： 电脑要运作必须安装操作系统，如今流行的操作系统主要由UNIX、Linux、Mac、BSD、Windows2000、 Windows95/98/Me、Windows NT等，这些操作系统各自独立运行，它们有自己的文件管理、内存管理、进程管理等机制，在网络上，这些不同的操作系统既可以作为服务器、也可以作为客户端 被使用者操作，它们之间通过“协议”来完成信息的交换工作。 不同的操作系统配合不同的应用程序就构成了系统环境，例如Linux系统 配合Apache软件可以将电脑构设成一台网站服务器，其他使用客户端的电脑可以使用浏览器来获得网站服务器上供浏览者阅读的文本信息；再如 Windows2000配合Ftpd软件可以将电脑构设成一台文件服务器，通过远程ftp登陆可以获得系统上的各种文件资源等。 四、IP地址和端口： 我们上网，可能会同时浏览网页、收发电子邮件、进行语音聊天……如此多的网络服务项目，都是通过不同的协议完成的，然而网络如此之大，我们的电脑怎么能够找到服务项目所需要的电脑？如何在一台电脑上同时完成如此多的工作的呢？这里就要介绍到IP地址了。 每一台上网的电脑都具有独一无二的IP地址，这个地址类似于生活中人们的家庭地址，通过网络路由器等多种物理设备（无需初级学习者理解），网络可以完成 从一个电脑到另一个电脑之间的信息交换工作，因为他们的IP地址不同，所以不会出现找不到目标的混乱局面。但是黑客可以通过特殊的方法伪造自己电脑的IP 地址，这样当服务器接受到黑客电脑（伪IP地址）的请求后，服务器会将应答信息传送到伪IP地址上，从而造成网络的混乱。当然，黑客也可以根据IP地址轻 易的找到任何上网者或服务器，进而对他们进行攻击（想想现实中的入室抢劫），因而如今我们会看到很多关于《如何隐藏自己IP地址》的文章。 接下来我解释一下上面提到的第二个问题：一台电脑上为什么能同时使用多种网络服务。这好像北京城有八个城门一样，不同的协议体现在不同的网络服务上，而 不同的网络服务则会在客户端电脑上开辟不同的端口（城门）来完成它的信息传送工作。当然，如果一台网络服务器同时开放了多种网络服务，那么它也要开放多个 不同的端口（城门）来接纳不同的客户端请求。 网络上经常听到的“后门”就是这个意思，黑客通过特殊机能在服务器上开辟了一个网络服 务，这个服务可以用来专门完成黑客的目的，那么服务器上就会被打开一个新的端口来完成这种服务，因为这个端口是供黑客使用的，因而轻易不会被一般上网用户 和网络管理员发现，即“隐藏的端口”，故“后门”。 每一台电脑都可以打开65535个端口，因而理论上我们可以开发出至少65535 种不同的网络服务，然而实际上这个数字非常大，网络经常用到的服务协议不过几十个，例如浏览网页客户端和服务端都使用的是80号端口，进行IRC聊天则在 服务端使用6667端口、客户端使用1026端口等。 五、漏洞： 漏洞就是程序中没有考虑到的情况，例如最简单的 “弱口令”漏洞是指系统管理员忘记屏蔽某些网络应用程序中的账号；Perl程序漏洞则可能是由于程序员在设计程序的时候考虑情况不完善出现的“让程序执行 起来不知所措”的代码段，“溢出”漏洞则属于当初设计系统或者程序的时候，没有预先保留出足够的资源，而在日后使用程序是造成的资源不足；特殊IP包炸弹 实际上是程序在分析某些特殊数据的时候出现错误等…… 总而言之，漏洞就是程序设计上的人为疏忽，这在任何程序中都无法绝对避免，黑客 也正是利用种种漏洞对网络进行攻击的，本章开始的字眼儿“网络安全”实际就是“漏洞”的意思。黑客利用漏洞完成各种攻击是最终的结果，其实真正对黑客的定 义就是“寻找漏洞的人”，他们并不是以网络攻击为乐趣，而是天天沉迷在阅读他人的程序并力图找到其中的漏洞。应该说，从某种程度上讲，黑客都是“好人”， 他们为了追求完善、建立安全的互联网才投身此行的，只不过因为有的黑客或者干脆是伪黑客经常利用具有攻击性的漏洞，近些年人们才对黑客有了畏惧和敌视的心 理。 六、加密与解密： 在“协议”的讲解中，我提到了“由于网络设计的基层存在问题……”，简单的说这一问题是允许所 有上网者参与信息共享，因而对某些商业、个人隐私在网络上的传送，就会暴露在众目睽睽之下，我们的信用卡、个人电子邮件等都可以通过监听或者截获的方式被 他人的到，如何才能让这些信息安全呢？读者也许想到了“二战中”的间谍战：参战国家在使用电报的时候，都对代码进行了加密处理，只有知道了“密码薄”的接 收者，才可以进行译码工作。正是这种古老的加密方式，在现代化的网络上也依然存在它旺盛的生命力，通过加密处理的信息在网络上传送，无论谁拿到了这份文 件，只要没有“密码薄”仍然是白费力气的。 网络上最长使用的是设置个人密码、使用DES加密锁，这两种加密方式分别可以完成用户登陆 系统、网站、电子邮件信箱和保护信息包的工作，而黑客所要进行的工作，就是通过漏洞、暴力猜测、加密算法反向应用等方式获得加密档案的明文，有人把“魔高 一尺、道高一仗”用在这里，的确是在恰当不过了！网络上的加密方法和需要验证密码的系统层出不穷，黑客也在寻找破解这些系统的种种办法。 可以说，“漏洞”和“解密”是两个完全不同的黑客领域，对于不同的学习者对他们的偏好，将会直接影响到今后将会成为的黑客类型，因而在二者之间的选择，应根据个人喜好进行，本书将会侧重学习“漏洞”方面的知识。 七、特洛伊木马： 特洛伊木马是一个程序，这个程序可以做程序设计者有意设计的未出现过的事情。但是对于特洛伊木马所做的操作，不论是否用户了解，都是不被赞同的。根据某 些人的认识，病毒是特洛伊木马的一个特例，即：能够传播到其他的程序当中（也就是将这些程序也变成特洛伊木马）。根据另外的人的理解，不是有意造成任何损 坏的病毒不是特洛伊木马。最终，不论如何定义，许多人仅仅用“特洛伊木马”来形容不能复制的带有恶意的程序，以便将特洛伊木马与病毒区分开 第四节、常用黑客软件用途分类 一、防范： 这是从安全的角度出发涉及的一类软件，例如防火墙、查病毒软件、系统进程监视器、端口管理程序等都属于此类软件。这类软件可以在最大程度上保证电脑使用 者的安全和个人隐私，不被黑客破坏。网络服务器对于此类软件的需要也是十分重视的，如日志分析软件、系统入侵软件等可以帮助管理员维护服务器并对入侵系统 的黑客进行追踪。 二、信息搜集： 信息搜集软件种类比较多，包括端口扫描、漏洞扫描、弱口令扫描等扫描类软件；还 有监听、截获信息包等间谍类软件，其大多数属于亦正亦邪的软件，也就是说无论正派黑客、邪派黑客、系统管理员还是一般的电脑使用者，都可以使用者类软件完 成各自不同的目的。在大多数情况下，黑客使用者类软件的频率更高，因为他们需要依靠此类软件对服务器进行全方位的扫描，获得尽可能多的关于服务器的信息， 在对服务器有了充分的了解之后，才能进行黑客动作。 三、木马与蠕虫： 这是两种类型的软件，不过他们的工作原理大致相同，都具有病毒的隐藏性和破坏性，另外此类软件还可以由拥有控制权的人进行操作，或由事先精心设计的程序完成一定的工作。当然这类软件也可以被系统管理员利用，当作远程管理服务器的工具。 四、洪水： 所谓“洪水”即信息垃圾炸弹，通过大量的垃圾请求可以导致目标服务器负载超负荷而崩溃，近年来网络上又开始流行DOS分散式攻击，简单地说也可以将其归 入此类软件中。洪水软件还可以用作邮件炸弹或者聊天式炸弹，这些都是经过简化并由网络安全爱好者程序化的“傻瓜式”软件，也就是本书一开始指责的“伪黑 客”手中经常使用的软件。 五、密码破解： 网络安全得以保证的最实用方法是依靠各种加密算法的密码系统，黑客也许 可以很容易获得一份暗文密码文件，但是如果没有加密算法，它仍然无法获得真正的密码，因此使用密码破解类软件势在必行，利用电脑的高速计算能力，此类软件 可以用密码字典或者穷举等方式还原经过加密的暗文。 六、欺骗： 如果希望获得上面提到的明文密码，黑客需要对暗文进行加密算法还原，但如果是一个复杂的密码，破解起来就不是那么简单了。但如果让知道密码的人直接告诉黑客密码的原型，是不是更加方便？欺骗类软件就是为了完成这个目的而设计的。 七、伪装： 网络上进行的各种操作都会被ISP、服务器记录下来，如果没有经过很好的伪装就进行黑客动作，很容易就会被反跟踪技术追查到黑客的所在，所以伪装自己的 IP地址、身份是黑客非常重要的一节必修课，但是伪装技术需要高深的网络知识，一开始没有坚实的基础就要用到这一类软件了。 第五节、学习黑客的基本环境 一、操作系统的选择： 我们经常听说黑客酷爱Linux系统，这是因为Linux相对Windows提供了更加灵活的操作方式，更加强大的功能。例如对于IP地址的伪造工作， 利用Linux系统编写特殊的IP头信息可以轻松完成，然而在Windows系统下却几乎不可能做到。但是Linux也有它不足的一面，这个系统的命令庞 杂、操作复杂，并不适合初学者使用，而且对于个人学习者，并没有过多的人会放弃“舒适”的Windows、放弃精彩的电脑游戏和便捷的操作方式，去全心投 入黑客学习中。而且对于初学黑客的学习者来说，大多数网络知识都可以在Windows系统中学习，相对Linux系统，Windows平台下的黑客软件也 并不在少数，另外通过安装程序包，Windows系统中也可以调试一定量的程序，因此初步学习黑客没有必要从Linux入手。 本书使 用的平台WindowsME，因为对于个人用户来说，NT或者2000多少有些苛刻——系统配置要求太高；然而使用95或者98又缺少某些必要的功能—— NET、TELNET命令不完善。但是本书的大部分内容测试漏洞，从远程服务器出发，所以也不是非要WindowsME操作系统进行学习，对于少数系统版 本之间的差异，学习者可以和我联系获得相应系统的学习方法。 二、需要的常用软件： 如果你的系统是 WindowsME，那么告诉你一个好消息——你没有必要安装过多的额外软件，因为我们接触的黑客知识依靠系统提供给我们的命令和内置软件就足可以完成 了！除了基本的操作系统以外，学习者还需要安装各类扫描器，之后下载一个比较优秀的木马软件、一个监听类软件，除此以外别无它求。如果有必要，读者可以自 行安装本文上述软件，然后学习其用法，但是我要告诉你，对于各类炸弹、还有网络上各式各样的黑客软件，在学习完本书后，你都可以自己制作、自己开发，根本 没有必要使用他人编写的软件。 对于扫描器和监听软件，我给出以下建议，并且在本书的后面还会对这几个软件进行详细介绍： 扫描器：x-scanner 下载地址： http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf844805fd4b9123507be6a750fbd88b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93549ed492a446b098f22fdc356b1800/" rel="bookmark">
			小玩具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天说的小玩具今天来发布了：
Jmouse LCD Toy - 点击这里下载
运行后可以检测你的 LCD (液晶显示器) 是否有坏点。
操作：ESC 键退出，任意键继续。
(*) Jmouse PCInfo Monitor 构架延迟或取消
(**)以下是该小玩具的源代码，公布此代码后，该玩具不会再更新。
Option Explicit Dim dwStep As Integer Private Sub Form_KeyUp() Sub Form_KeyUp(KeyCode As Integer, Shift As Integer)
On Error GoTo CheckEnd
If KeyCode = 27 Then
End
Else
Select Case dwStep
Case 2
Me.BackColor = RGB(255, 255, 255)
Label1.ForeColor = RGB(0, 0, 0)
Label1.Caption = "2.请查看屏幕范围内是否有非白色点存在"
Case 3
Me.BackColor = RGB(255, 0, 0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93549ed492a446b098f22fdc356b1800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af9e01ce416879c838d43d373d370a4/" rel="bookmark">
			表空间的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORACLE中，表空间是数据管理的基本方法，所有用户的对象要存放在表空间中，也就是用户有空间的使用权，才能创建用户对象．否则是不充许创建对象，因为就是想创建对象,如表,索引等，也没有地方存放,Oracle会提示:没有存储配额．
因此，在创建对象之前，首先要分配存储空间． 分配存储，就要创建表空间： 创建表空间示例如下： CREATE TABLESPACE "SAMPLE" LOGGING DATAFILE 'D:/ORACLE/ORADATA/ORA92/LUNTAN.ora' SIZE 5M EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO 上面的语句分以下几部分： 第一 : CREATE TABLESPACE "SAMPLE" 创建一个名为 "SAMPLE" 的表空间 . 对表空间的命名 , 遵守 Oracle 的命名规范就可了 . ORACLE 可以创建的表空间有三种类型 : (1)TEMPORARY: 临时表空间 , 用于临时数据的存放 ; 创建临时表空间的语法如下 : CREATE TEMPORARY TABLESPACE "SAMPLE"...... (2)UNDO : 还原表空间 . 用于存入重做日志文件 . 创建还原表空间的语法如下 : CREATE UNDO TABLESPACE "SAMPLE"...... (3) 用户表空间 : 最重要 , 也是用于存放用户数据表空间 可以直接写成 : CREATE TABLESPACE "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1af9e01ce416879c838d43d373d370a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a13bd45f2a2275e858d1088b00fcb9/" rel="bookmark">
			SC介绍和教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写这个东西的目的在于让大家了解一下SC这个服务管理程序的使用，另一方面也是为了让大家更进一步的了解到NT，2000的服务的一些基础问题，如果有时 间，希望大家好好看看。再来结合起上一次如何打开termservice服务的那篇文章，在服务方面大家应该比较了解了。用这个东西就可以删除在别人机器 里留下的如ffsniffer, sksockerver这些东西，不用再担心，装上了删除不了。但是毕竟这个东西还是MS的产品，所以，如 eventlog这样的服务，是不可以用它关闭的。累呀累呀，写了我整整一个早上，就是不知道有没有人看！ 我们知道在MStools SDK，也就是在Resource Kit有一个很少有人知道的命令行软件，SC.exe，这个软件向所有的 Windows NT和Windows 2000要求控制他们的API函数。我们可以在命令行里通过对这些函数设定参数的方式来设定 他们(API)。SC.exe也可以显示服务的状态，同时也可以从状态结构区域里重新找到存储在里面的数值。它还可以 列出远程计算机的服务函数或者是服务状况结构。 SC.exe这个开发工具至少可以比服务控制面板程序和网络命令行界面(net.exe，这个东西可以告诉你一个服务是 在运行中，还是停止，还是暂停。）这两个东西提供更多的细节和准确的信息。虽然上述两个东西在正常工作的 情况下，对于完整的调试是非常好用的，但是如果有新的服务，或者新的代码被开发出来的时候，这两个工具提 供的信息可能造成误导。这也就是我们需要用到SC的原因。 下面举列说明，如果在开发阶段，你的服务在挂住在一个start-pending的时候，控制面板和net.exe同样报告服 务是在运行的。但它挂在一个stop-pending的时候，net.exe报告它运行，而控制面板着报告它停止，如果你试着 启动它，这是控制面板则会告诉你这个服务正在运行。难道这不是很困惑吗？呵呵！ SC.exe可以让你询问服务的状况和取出存储在状态结构区域内的数值，控制面板和net.exe不提供服务完整的状况 。但是无论如何，SC程序可以告诉你这个服务准确的情形，同样也可以给你看最后的checkpoint数和等待提示。 这个checkpoint，我叫它检查点(我觉得他就像一个程序调试时置的断点)，所以我们也可以把看作为一个调试工 具，因为它可以提供一个关于在程序停止时还要沿着初始化继续前进多久准确报告。 SC.exe也可以允许你调用很多的服务控制API函数，可以让你从命令行里改变大量的参数。这位服务开发者们提供 了很多的优势。例如，它提供了一个方便的方式来创建或者在注册表和服务控制管理数据库中配置服务信息。开 发者们不需要在手动的在注册表里单独的设置键值来配置服务，也不用重起机器来强迫服务控制管理数据库升级 。 作为一个命令很工具，SC.exe可以用来测试你自己的系统，你可以设置一个批处理文件来使用不同的参数调用 SC.exe来控制服务。这个很有用，如果你想看看你的服务不断的启动和停止，我没有试过哦！让一个服务一下子 打开，一下子关闭，听上去很不错的。如果你的服务进程里面有多个进程的话，你可以保持一个进程继续运行不 让它走开，然后让另一个不断的打开在关闭，还可以寻找一下内存缺乏导致不完全清楚的证据。 下面介绍SC，SC QC，and SC QUERY SC使用这样的语法： 1. SC [Servername] command Servicename [Optionname= Optionvalue] 2. SC [command] 这里使用第一种语法使用SC，使用第二种语法显示帮助。 下面介绍各种参数。 Servername 可选择：可以使用双斜线，如//myserver，也可以是//192.168.0.1来操作远程计算机。如果在本地计算机上操作 就不用添加任何参数。 Command 下面列出SC可以使用的命令。 config----改变一个服务的配置。（长久的） continue--对一个服务送出一个继续控制的要求。 control----对一个服务送出一个控制。 create----创建一个服务。（增加到注册表中） delete----删除一个服务。（从注册表中删除） EnumDepend--列举服务的从属关系。 GetDisplayName--获得一个服务的显示名称。 GetKeyName--获得一个服务的服务键名。 interrogate--对一个服务送出一个询问控制要求。 pause----对一个服务送出一个暂停控制要求。 qc----询问一个服务的配置。 query----询问一个服务的状态，也可以列举服务的状态类型。 start----启动一个服务。 stop----对一个服务送出一个停止的要求。 Servicename 在注册表中为service key制定的名称。注意这个名称是不同于显示名称的（这个名称可以用net start和服务控 制面板看到），而SC是使用服务键名来鉴别服务的。 Optionname 这个optionname和optionvalue参数允许你指定操作命令参数的名称和数值。注意，这一点很重要在操作名称和等 号之间是没有空格的。一开始我不知道，结果………………，比如，start= optionvalue，这个很重要。 optionvalue可以是0，1，或者是更多的操作参数名称和数值对。 如果你想要看每个命令的可以用的optionvalue，你可以使用sc command这样的格式。这会为你提供详细的帮助。 Optionvalue 为optionname的参数的名称指定它的数值。有效数值范围常常限制于哪一个参数的optionname。如果要列表请用 sc command来询问每个命令。 Comments 很多的命令需要管理员权限，所以我想说，在你操作这些东西的时候最好是管理员。呵呵！ 当你键入SC而不带任何参数时，SC.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a13bd45f2a2275e858d1088b00fcb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dccaabe342e0028ab82d2bd43005a59b/" rel="bookmark">
			基于SSE指令集的程序设计简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Alex Farber 出处： http://www.codeproject.com/cpp/sseintro.asp SSE技术简介
Intel公司的单指令多数据流式扩展（SSE，Streaming SIMD Extensions）技术能够有效增强CPU浮点运算的能力。Visual Studio .NET 2003提供了对SSE指令集的编程支持，从而允许用户在C++代码中不用编写汇编代码就可直接使用SSE指令的功能。MSDN中有关SSE技术的主题[1]有可能会使不熟悉使用SSE汇编指令编程的初学者感到困惑，但是在阅读MSDN有关文档的同时，参考一下Intel软件说明书（Intel Software manuals）[2]会使你更清楚地理解使用SSE指令编程的要点。 SIMD（single-instruction, multiple-data）是一种使用单道指令处理多道数据流的CPU执行模式，即在一个CPU指令执行周期内用一道指令完成处理多个数据的操作。考虑一下下面这个任务：计算一个很长的浮点型数组中每一个元素的平方根。实现这个任务的算法可以这样写：
for each f in array //对数组中的每一个元素
f = sqrt(f) //计算它的平方根
为了了解实现的细节，我们把上面的代码这样写：
for each f in array
{
把f从内存加载到浮点寄存器
计算平方根
再把计算结果从寄存器中取出放入内存
}
具有Intel SSE指令集支持的处理器有8个128位的寄存器，每一个寄存器可以存放4个（32位）单精度的浮点数。SSE同时提供了一个指令集，其中的指令可以允许把浮点数加载到这些128位的寄存器之中，这些数就可以在这些寄存器中进行算术逻辑运算，然后把结果放回内存。采用SSE技术后，算法可以写成下面的样子：
for each 4 members in array //对数组中的每4个元素
{
把数组中的这4个数加载到一个128位的SSE寄存器中
在一个CPU指令执行周期中完成计算这4个数的平方根的操作
把所得的4个结果取出写入内存
}
C++编程人员在使用SSE指令函数编程时不必关心这些128位的寄存器，你可以使用128位的数据类型“__m128”和一系列C++函数来实现这些算术和逻辑操作，而决定程序使用哪个SSE寄存器以及代码优化是C++编译器的任务。当需要对很长的浮点数数组中的元素进行处理的时候，SSE技术确实是一种很高效的方法。
SSE程序设计详细介绍
包含的头文件：
所有的SSE指令函数和__m128数据类型都在xmmintrin.h文件中定义：
#include &lt;xmmintrin.h&gt;
因为程序中用到的SSE处理器指令是由编译器决定，所以它并没有相关的.lib库文件。
数据分组（Data Alignment）
由SSE指令处理的每一个浮点数数组必须把其中需要处理的数每16个字节（128位二进制）分为一组。一个静态数组（static array）可由__declspec(align(16))关键字声明：
__declspec(align(16)) float m_fArray[ARRAY_SIZE];
动态数组（dynamic array）可由_aligned_malloc函数为其分配空间：
m_fArray = (float*) _aligned_malloc(ARRAY_SIZE * sizeof(float), 16);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dccaabe342e0028ab82d2bd43005a59b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6acc7743e92feb8d50780bf725b7a03/" rel="bookmark">
			SSE指令介绍及其C、C&#43;&#43;应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSE是英特尔提出的即MMX之后新一代（当然是几年前了）CPU指令集，最早应用在PIII系列CPU上。现在已经得到了Intel PIII、P4、Celeon、Xeon、AMD Athlon、duron等系列CPU的支持。而更新的SSE2指令集仅得到了P4系列CPU的支持，这也是为什么这篇文章是讲SSE而不是SSE2的原因之一。另一个原因就是SSE和SSE2的指令系统是非常相似的，SSE2比SSE多的仅是少量的额外浮点处理功能、64位浮点数运算支持和64位整数运算支持。 SSE为什么会比传统的浮点运算更快呢？因为它使用了128位的存储单元，这对于32位的浮点数来讲，是可以存下4个的，也就是说，SSE中的所有计算都是一次性针对4个浮点数来完成的，这种批处理当然就会带来效率的提升。我们再来回顾一下SSE的全称：Stream SIMD Extentions（流SIMD扩展）。SIMD就是single instruction multiple data，连起来就是“数据流单指令多数据扩展”，从名字我们就可以更好的理解SSE是如何工作的了。
虽然SSE从理论上来讲要比传统的浮点运算会快，但是他所受的限制也很多，首先，虽然他执行一次相当于四次，会比传统的浮点运算执行4次的速度要快，但是他执行一次的速度却并没有想象中的那么快，所以要体现SSE的速度，必须有Stream做前提，就是大量的流数据，这样才能发挥SIMD的强大作用。其次，SSE支持的数据类型是4个32位（共计128位）浮点数集合，就是C、C++语言中的float[4]，并且必须是以16位字节边界对齐的（稍后会以代码来进行阐释，关于边界对齐的概念，读者可以参考论坛上的其它文章，都会有很详细的解答，我这里就恕不赘述了）。因此这也给输入和输出带来了不少的麻烦，实际上主要影响SSE发挥性能的就是不停的对数据进行复制以适用应它的数据格式。
我是一个C++程序员，对汇编并不很熟，但我又想用SSE来优化我的程序，我该怎么做呢？幸好VC++.net为我们提供了很方便的指令C函数级的封装和C格式数据类型，我们只需像平时写C++代码一样定义变量、调用函数就可以很好的应用SSE指令了。
当然了，我们需要包含一个头文件，这里面包括了我们需要的数据类型和函数的声明：
#include &lt;xmmintrin.h&gt;
SSE运算的标准数据类型只有一个，就是：__m128，它是这样定义的：
typedef struct __declspec(intrin_type) __declspec(align(16)) __m128 {
float m128_f32[4];
} __m128;
简化一下，就是：
struct __m128
{
float m128_f32[4];
};
比如要定义一个__m128变量，并为它赋四个float整数，可以这样写：
__m128 S1 = { 1.0f, 2.0f, 3,0f, 4,0f };
要改变其中第2个（基数为0）元素时可以这样写：
S1.m128_f32[2] = 6.0f;
令外我们还会用到几个赋值的指令，它可以让我们更方便的使用这个数据结构：
S1 = _mm_set_ps1( 2.0f );
它会让S1.m128_f32中的四个元素全部赋予2.0f，这样会比你一个一个赋值要快的多。
S1 = _mm_setzero_ps();
这会让S1中的所有4个浮点数都置零。
还有一些其它的赋值指令，但执行起来还没有自己逐个赋值来的快，只做为一些特殊用途，如果你想了解更多的信息，可以参考MSDN -&gt; VisualC++参考 -&gt; C/C++Language -&gt; C++Language Reference -&gt; Compiler Intrinsics -&gt; MMX, SSE, and SSE2 Intrinsics -&gt; Stream SIMD Extensions(SSE)章节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6acc7743e92feb8d50780bf725b7a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68e79ec05d57d1878cc387a42b0861b/" rel="bookmark">
			orCAD10.3-capture
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果只需要画原理图的功能，安装完整版的orcad占硬盘数G，实在是太浪费，终于找到一个只有capture的orcad10.3，压缩包只有4M+。直接解压，不用安装。
解压后，增加一个环境变量：CDS_LIC_FILE 值等于解压后的license.dat文件的路径，例如：
"D:/orCAD10.3-capture/crack/license.dat"
直接运行capture.exe就可以了，启动速度还不错。可以手工修改文件后缀，把DSN文件直接关联到capture.exe，即可直接打开原理图文件了。
下载地址：orCAD10.3-capture免安裝精簡版下载SMT充电网论坛 需要注册，注册后即可下载
或直接google搜索 “orCAD10.3-capture免安裝精簡版”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/348141d7f5726d9d8e0d0a843fb9702b/" rel="bookmark">
			C&#43;&#43; Boost 库文档索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ Boost 库文档索引 1 按字母顺序库列表 2 按主题库列表 2.0 字符串和文本处理( String and text processing) 2.1 容器(Containers) 2.2 迭代器(Iterators) 2.3 算法( Algorithms ) 2.4 函数对象和高阶编程(Function objects and higher-order programming) 2.5 泛型编程(Generic Programming) 2.6 模板元编程(Template Metaprogramming ) 2.7 预处理元编程(Preprocessor Metaprogramming) 2.8 并发编程(Concurrent Programming) 2.9 数学和数值计算(Math and numerics) 2.10 纠错和测试( Correctness and testing) 2.11数据结构( Data structures) 2.12 输入/输出(Input/Output) 2.13 跨语言支持(Inter-language support) 2.14 内存(Memory) 2.15解析( Parsing ) 2.16杂项( Miscellaneous ) 2.17 Broken compiler workarounds 3 Boost中已废除的库 什么库用何种编译器请看 [[http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/348141d7f5726d9d8e0d0a843fb9702b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6cd9879f787ddc7f33864f09c306b89/" rel="bookmark">
			就算不偷盗，也让你看看计算机里常用的有那些软件--常用软件序列号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		www.diy567.com累了，去上面休息一下下,QQ空间，美文，非主流，网络日记，搞笑短信，祝福短信，热门短信，有意思啊
就算不偷盗，也让你看看计算机里常用的有那些软件--常用软件序列号
1.操作系统
Windows Longhorn中文版 序列号：C9RTB-HRXB8-DTMH7-GRJTG-D92JM
Windows Server 2003 Enterprise Edition 真正企业免激活版 SN: JB88F-WT2Q3-DPXTT-Y8GHG-7YYQY
Windows Server 2003 简体中文企业版(免激活版) SN: JB88F-WT2Q3-DPXTT-Y8GHG-7YYQY
Windows Server 2003 Standard Edition 简体中文标准版 SN: C4C24-QDY9P-GQJ4F-2DB6G-PFQ9W 破解一 破解二
Windows XP 简体中文零售专业版（神州版） SN: BX6HT-MDJKW-H2J4X-BX67W-TVVFG DG8FV-B9TKY-FRT9J-6CRCC-XPQ4G
Windows XP 简体中文正式零售专业版免激活版 SN: FCKGW-RHQQ2-YXRKT-8TG6W-2B7Q8 另一下载 解压码：www.crsky.com
Windows Xp 简体中文14in1光盘ISO版解压密码：www.sz1001.net SN: JQ4T4-8VM63-6WFBK-KTT29-V8966
Windows XP 简体中文联想 OEM 个人版
Microsoft Windows XP Professional VLK简体中文版 CD-KEY: DG8FV-B9TKY-FRT9J-6CRCC-XPQ4G
Microsoft Windows XP Professional VLK 英文版 SN: RFYPJ-BKXH2-26FWP-WB6MT-CYH2Y 7HPVP-8VHPV-G7CQ3-BTK2R-TDRF3 DG8FV-B9TKY-FRT9J-6CRCC-XPQ4G Windows XP PRO 英文版 SN：WF47Q-DGPDW-FMJBY-3RWY2-K3Y6D 或 QF6T3-T6BPB-VBR2Y-WGXQH-X3R6M
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6cd9879f787ddc7f33864f09c306b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6d9e7d589e04ed2928ba1a3baeb0ccc/" rel="bookmark">
			用c语言写的base64编码解码函数！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* *****************************************************************************
* Description : BASE64 encoding and decoding
* Date : 06-08-21 21:00 * Author : aishen944
* Copryright : ********************************************************************************/
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#define BASE64_PAD64 '='
char base64_alphabet[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',
'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a',
'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6d9e7d589e04ed2928ba1a3baeb0ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462a94a59066eb081f2ee6152d1fdb4b/" rel="bookmark">
			Java中的类反射机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者: 来源:http://www.cnxiyang.com/ 时间:2006-5-5 19:12:20 Java 中的类反射机制 一、反射的概念 ： 反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。其中LEAD/LEAD++ 、OpenC++ 、MetaXa和OpenJava等就是基于反射机制的语言。最近，反射机制也被应用到了视窗系统、操作系统和文件系统中。 反射本身并不是一个新概念，它可能会使我们联想到光学中的反射概念，尽管计算机科学赋予了反射概念新的含义，但是，从现象上来说，它们确实有某些相通之处，这些有助于我们的理解。在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。可以看出，同一般的反射概念相比，计算机科学领域的反射不单单指反射本身，还包括对反射结果所采取的措施。所有采用反射机制的系统（即反射系统）都希望使系统的实现更开放。可以说，实现了反射机制的系统都具有开放性，但具有开放性的系统并不一定采用了反射机制，开放性是反射系统的必要条件。一般来说，反射系统除了满足开放性条件外还必须满足原因连接（Causally-connected）。所谓原因连接是指对反射系统自描述的改变能够立即反映到系统底层的实际状态和行为上的情况，反之亦然。开放性和原因连接是反射系统的两大基本要素。13700863760 Java中，反射是一种强大的工具。它使您能够创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代表链接。反射允许我们在编写与执行时，使我们的程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活的应用的主要工具。但需注意的是：如果使用不当，反射的成本很高。 二、Java中的类反射： Reflection 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性。Java 的这一能力在实际应用中也许用得不是很多，但是在其它的java/j2me/code/' target='_blank'&gt;程序设计语言中根本就不存在这一特性。例如，Pascal、C 或者 C++ 中就没有办法在程序中获得函数定义相关的信息。 1 ．检测类： 1.1 reflection 的工作机制 考虑下面这个简单的例子，让我们看看 reflection 是如何工作的。 import java.lang.reflect.*; public class DumpMethods { public static void main(String args[]) { try { Class c = Class.forName(args[0]); Method m[] = c.getDeclaredMethods(); for (int i = 0; i &lt; m.length; i++) System.out.println(m[i].toString()); } catch (Throwable e) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/462a94a59066eb081f2ee6152d1fdb4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c60943e9710c5ff61fd7697be5797a1/" rel="bookmark">
			DXUT编程指南(三):通过DXUT使用程序窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过DXUT使用程序窗口 你的应用程序可以处理大多数的窗口管理任务，如果你使用较少的DXUT函数的话。
创建一个窗口 使用你自己的窗口 创建一个窗口
为Direct3D应用程序创建一个窗口包含以下几步：
1.定义一个响应适当的窗口消息(Defining a to respond to the proper window messages.)
2.建立(Setting up the.)
3.使用(Using .)
4.使用(Using .) //这几处有点奇怪哦^_^,原版就是这样
这些步骤不正确可能会导致Bugs。尽管对于Direct3D程序员来说这不是令人激动的，但它们是每个应用程序必须的。框架用DXUTCreateWindow函数简化了这个步骤：
HRESULT DXUTCreateWindow(
const WCHAR *strWindowTitle = L"Direct3D Window",
HINSTANCE hInstance = NULL,
HICON hIcon = NULL,
HMENU hMenu = NULL,
INT x = CW_USEDEFAULT,
INT y = CW_USEDEFAULT
);
所有的参数都是可选的：
strWindowTitle 就是窗口的标题，同时也显示在任务栏。他通常是项目的标题。
hInstance是应用程序实例的句柄。典型的，他被大多数程序置为NULL。
hIcon是应用程序图标的句柄。如果为NULL，嵌入应用程序可执行文件的第一个图标将被使用。所以NULL也能很好的工作。
hMenu是菜单的句柄，如果想要可以设置它。大多数游戏并不使用标准的菜单，而是创建它们自己的游戏界面。
最后两个参数描述了窗口的位置。如果是全屏模式，它们将被忽略。
最简单的一个例子，应用程序可以像这样调用DXUTCreateWindow函数：
DXUTCreateWindow(L"My New Game");
只传入第一个参数strWindowTitle来调用这个函数，框架会自动的创建窗口并处理窗口消息。窗口句柄可以通过调用DXUTGetHWND得到，如果你需要的话。
如果应用程序要响应窗口消息，它可以使用DXUTSetCallbackMsgProc来设置回调函数：
void DXUTSetCallbackMsgProc( LPDXUTCALLBACKMSGPROC pCallbackMsgProc, void* pUserContext = NULL );
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c60943e9710c5ff61fd7697be5797a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9cdcfa5a446a9e7be056683dd895bc7/" rel="bookmark">
			DXUT编程指南(一):DXUT概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DXUT编程指南 （译自DirectX SDK Document） DXUT是一个建立在Direct3D API之上的层，它在大多数的Direct3D指南和实例中被使用。它的目标是让Direct3D示例，样本，工具，乃至专业游戏更加健壮且更容易建立。它简化了Windows和Direct3D API的典型的用法。
DXUT概览
初始化DXUT
通过DXUT使用程序窗口 通过DXUT使用设备
通过DXUT使用主循环
通过DXUT处理错误
通过DXUT作更高级的设备选择
另外一些DXUT的函数 DXUT概览 本主题提供了对DXUT概览的一个高层次的介绍
概览 特征 局限性
开始一个新的项目
DirectX April 2005 SDK中DXUT的改进
来自DirectX Summer 2003 SDK中DXUT的变化 概览 设计这个框架结构是为了帮助程序员花更少的时间去操心怎样创建窗口，怎样创建设备，怎样处理窗口消息以及什么时候处理设备事件。
这儿是一个使用该框架的示例程序的main函数
INT WINAPI WinMain( HINSTANCE, HINSTANCE, LPSTR, INT )
{
// 设置回调函数。这些函数允许DXUT通知应用程序关于设备改变，用户输入，和窗口消息 。
//这些回调函数是可选的, 所以你只需要为你感兴趣的事件设置他们即可（函数的名字已经很好理解）
DXUTSetCallbackDeviceCreated( OnCreateDevice );
DXUTSetCallbackDeviceReset( OnResetDevice );
DXUTSetCallbackDeviceLost( OnLostDevice );
DXUTSetCallbackDeviceDestroyed( OnDestroyDevice );
DXUTSetCallbackFrameRender( OnFrameRender );
DXUTSetCallbackFrameMove( OnFrameMove );
// 初始化DXUT，为你的应用程序创建你所期望Win32窗口和D3D设备 // 调用这些函数也是可选的，但是它们允许你设置几个参数来控制框架的行为 DXUTInit( TRUE, TRUE, TRUE );
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9cdcfa5a446a9e7be056683dd895bc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91aaaf63e826865caeb6031d3e091dcb/" rel="bookmark">
			常用的一些javascript小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下信息来之于 蓝色理想的oror帖子 //事件源对象 event.srcElement.tagName event.srcElement.type //捕获释放 event.srcElement.setCapture(); event.srcElement.releaseCapture();
//事件按键 event.keyCode event.shiftKey event.altKey event.ctrlKey //事件返回值 event.returnValue //鼠标位置 event.x event.y //窗体活动元素 document.activeElement //绑定事件
document.captureEvents(Event.KEYDOWN); //访问窗体元素 document.all("txt").focus(); document.all("txt").select(); //窗体命令 document.execCommand //窗体COOKIE document.cookie //菜单事件 document.oncontextmenu //创建元素 document.createElement("SPAN"); //根据鼠标获得元素：
document.elementFromPoint(event.x,event.y).tagName=="TD document.elementFromPoint(event.x,event.y).appendChild(ms)
//窗体图片 document.images[索引] //窗体事件绑定 document.οnmοusedοwn=scrollwindow; //元素 document.窗体.elements[索引] //对象绑定事件 document.all.xxx.detachEvent('onclick',a); //插件数目 navigator.plugins //取变量类型
typeof($js_libpath) == "undefined" //下拉框 下拉框.options[索引] 下拉框.options.length //查找对象 document.getElementsByName("r1"); document.getElementById(id); //定时 timer=setInterval('scrollwindow()',delay); clearInterval(timer); //UNCODE编码 escape() ,unescape //父对象 obj.parentElement(dhtml) obj.parentNode(dom)
//交换表的行
TableID.moveRow(2,1) //替换CSS document.all.csss.href = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91aaaf63e826865caeb6031d3e091dcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083f856e38663e29f9c16baf15cc33d6/" rel="bookmark">
			非常弱弱地浅谈聊天机器人(人工智能)系统的数据库设计想法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 非常弱弱地浅谈聊天机器人(人工智能)系统的数据库设计想法
除了能够对已有表进行数据的增删改外。还会根据更正过去错误的知识或者根据获得的新知识，对数据库中的基本表的结构进行自动新增与修改或者自动新建一些基本表。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8060c5b7f1a52418717c600d9dbcd54a/" rel="bookmark">
			为什么说用PHP开发大型系统令人不爽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么说用PHP开发大型系统令人不爽
来自：太平洋电脑网
笔者在过去的四年里一直致力于PHP应用的开发。PHP确实十分容易编写。但是PHP也有一些十分严重的缺陷。 下面笔者会给出自己的理由，为什么PHP不适合于比小型业余网站更大的网站。
1. 对递归的不良支持
递归是一种函数调用自身的机制。这是一种强大的特性可以把某些复杂的东西变得很简单。有一个使用递归的例子是快速排序（quicksort）。不幸的是，PHP并不擅长递归。Zeev，一个PHP开发人员，说道：“PHP 4.0（Zend）对密集数据使用了栈方式，而不是使用堆方式。也就是说它能容忍的递归函数的数量限制和其他语言比起来明显少。”见bug 1901。这是一个很不好的借口。每一个编程语言都应该提供良好的递归支持。
2. 许多PHP模块都不是线程安全的
在几年前，Apache发布了Web服务器的2.0版。这个版本支持多线程模式，在这个模式下，软件一个一部分可以同时运行多个。PHP的发明者说PHP的核心是线程安全的，但是非核心模块不一定是。但是十次有九次，你想要在PHP脚本中使用这种模块，但这又使你的脚本不能合适Apache的多线程模式。这也是为什么PHP小组不推荐在Apache 2 的多线程模式下运行PHP。不良的多线程模式支持使PHP常被认为是Apache 2依然不流行的原因之一。
请阅读这篇讨论： Slashdot: Sites Rejecting Apache 2?.
3. PHP 由于商业原因而不健全
通过使用缓存，PHP的性能可以陡增500%[见基准测试]。那么为什么缓存没有被构建在PHP中呢？因为Zend——PHP的制造者，它在销售自己的Zend Accelerator，所以当然，他们不想抛弃自己的商业产品这块肥肉。
但是有另一个可选择的： APC. （Zend后来推出Zend Optimizer，免费的加速器——译者）
4. 没有命名空间
设想某个人制作了一个PHP模块用来阅读文件。模块中一个函数叫做read。然后另一个人的模块可以读取网页的，同样包含一个函数read。然后我们就无法同时使用这两个模块了，因为PHP不知道你要用哪个函数。
但是有一个很简单的解决方法，那就是命名空间。曾经有人建议PHP5加入这个特性，但不幸得是他没有这么做。现在，没有命名空间，每个函数都必须加上模块名作为前缀，来避免名称冲突。这导致了函数名恐怖得长，例如xsl_xsltprocessor_transform_to_xml让代码难于书写和理解。
5. 不标准的日期格式字符
很多程序员对 日期格式字符 都很熟悉，它是从UNIX和C语言中来的。其他一些编程语言采用了这个标准，但是很奇怪的，PHP有它自己的一套完全不兼容的日期格式字符。在C中，“%j”表示一年中的当天，在PHP中他表示一个月中的当天。然而使事情更混乱的是：Smarty （一个很流行的PHP模版引擎）的 strftime 函数和 date_format 函数，却使用了C/UNIX的格式化字符。
6. 混乱的许可证
你也许认为PHP是免费的，所有的在手册中提到的PHP模块也是免费的。错了！例如，如果你想在PHP中生成PDF文件，你会在手册中发现两个模块：PDF 和 ClibPDF。但是这两个都是有商业许可证的。所以，你所使用的每个模块，你都要确保你同意他的许可证。
7. 不一致的函数命名规则
有些函数名称是有多个单词组成的。一般有三种单词组合的习惯：
直接拼接：getnumberoffiles 用下划线分开：get_number_of_files 骆驼法则：getNumberOfFiles 大部分语言选择其中一中。但是PHP都用到了。
例如，你想要把一些特殊字符转换成HTML实体，你会使用函数htmlentities（直接拼接单词）。如果你要使用相反的功能，你要用到它的小弟弟html_entity_decode。由于某些特殊的原因，这个函数名是由下划线分隔单词。怎么能这样呢？你知道有一个函数叫strpad。或者他是str_pad？每次你都要查看一下到底这个符号是什么或者直接等他出现一个错误。函数是不分大小写的，所以对于PHP来说rawurldecode和RawUrlDecode之间没有什么区别。这也很糟糕，因为两个都使用到了同时他们看上去还不一样，混淆了阅读者。
8. 魔法引用的地狱
魔法引用（Magic quote）可以保护PHP脚本免受SQL注入攻击。这很好。但是出于某些原因，你可以在php.ini中关闭这个配置。所以你如果要写出一个有弹性的脚本，你总要检查魔法引用是开启还是关闭。这样一个“特性”应该让编程更简单，而事实上变得更复杂了。
9. 缺少标准框架
一个成长中的网站没有一个整体框架，最终会变成维护的噩梦。一个框架可以让很多工作变得简单。现在最流行的框架模型时MVC-模型，在其中表现层、业务逻辑和数据库访问都分离开了。
很多PHP网站不使用MVC-模型。他们甚至没有一个框架。甚至现在有一些PHP框架同时你都可以自己写一个，关于PHP的文章和手册没有提高框架的一个字。同时JSP-开发人员使用像Struts的框架、ASP开发人员使用.Net，看起来好像这些概念都广泛被PHP开发人员所了解。这就说明了PHP实际上到底是多专业。
总结
什么问题?
对于非常小的项目，它可以是一个十分符合人意的编程语言。但是对于较大的和更为复杂的项目，PHP就显出他的薄弱了。当你不断地摸索之后，你会发现笔者提到的某些问题的解决方案。所以，当解决方案已知之后，为什么不能修正他呢？另外为什么这些修补不在手册中提到呢？
一个开源的语言十分流行是一件好事。但不幸得是，它不是一个伟大的语言。笔者希望所有的问题能有一天得到解决（也许在PHP6？），然后我们就将拥有一个开源语言，他既开源，又好用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8060c5b7f1a52418717c600d9dbcd54a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54840d56f63bea389115ac7a49919c53/" rel="bookmark">
			判断机器IP是公网ip还是内网ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是恭喜开通blog
对于ip是否是公网ip，网上已经有很多文章进行了描述。但我每次都记不太住，总要查找一下才又清楚。因此决定在这里记录下来，方便以后查询：）
ip地址分为五类。E类为保留为今后使用，D类为组播地址。用于主机网络地址的就是A类、B类、C类了。
这五类IP地址的各自范围如下：
在tcp/ip协议中，专门保留了三个IP地址区域作为私有地址，其地址范围如下： 10.0.0.0/8：10.0.0.0～10.255.255.255
172.16.0.0/12：172.16.0.0～172.31.255.255 192.168.0.0/16：192.168.0.0～192.168.255.255 使用保留地址的网络只能在内部进行通信，而不能与其他网络互连。因为本网络中的保留地址同样也可能被其他网络使用，如果进行网络互连，那么寻找路由时就会因为地址的不唯一而出现问题。但是这些使用保留地址的网络可以通过将本网络内的保留地址翻译转换成公共地址的方式实现与外部网络的互连。这也是保证网络安全的重要方法之一。 但是有一些宽带运营商尽管也使用了非私有地址分配给用户使用，但是由于路由设置的原因，Internet上的其他用户并不能访问到这些ip。
我们将这两种情况下应用的ip称为内网IP。 如果自己机器上网络接口的ip地址落在上述保留地址的范围内，则可以肯定自己处于内网模式下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20936910a5e4b9ea0ca0139157406151/" rel="bookmark">
			转载：哈佛大学精神病测试题（笑话）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 哈佛大学精神病测试题
1、吃西红柿炒蛋时，你常烦恼该先吃西红柿还是先吃蛋吗？　是──→　前往2 否──→　前往4 2、你敢不惧他人的耻笑，牵着驼鸟去逛长安街吗？　是──→　前往3 否──→　前往6 3、你经常为了睡觉时，手要摆在哪里而失眠吗？　是──→　前往5 否──→　前往7　4、早上睡醒时，经常烦恼该先上厕所还是先刷牙吗？ 是──→　前往6 否──→　前往8　5、你胆敢在非常感伤的毕业典礼上疯狂地说笑话吗？ 是──→　前往9 否──→　前往10　6、别人说了一个很难笑的笑话，你胆敢不笑吗？ 是──→　前往7 否──→　前往10 7、你敢不惧他人讪骂，穿着海滩裤参加重要宴会吗？ 是──→　前往11 否──→　前往12　8、你讨厌的人要送你免冲水晶马桶，你会收下吗？　是──→　前往10 否──→　前往9　9、你很想要和流浪狗玩“主人亲狗”的游戏吗？　是──→　前往11 否──→　前往15　10、你叫了一碗牛肉面，老板却端来一盘鱼丸，你会吃下它吗？　是──→　前往13 否──→　前往11 11、你敢用发明的“马桶型冰温冷三段漱口机”吗？ 是──→　前往16 否──→　前往12 12、与你争辩中的朋友给你一个蛋塔，要你住口，你肯答应吗？　是──→　前往15 否──→　前往14 13、你很想念故事给动物园里的猴子听吗？　是──→　前往14 否──→　前往18 14、你会因为讨厌公司里的订书机，而辞去工作吗？　是──→　前往17 否──→　前往15 15、监考老师在你的座位附近走来走去，你会瞪他吗？　是──→　前往18 否──→　前往16 16、陌生人要请你吃好吃的火腿蛋炒饭，你会接受吗？　是──→　前往20 否──→　前往19 17、你嚼口香糖时，都用牙齿中固定的一边嚼吗？　是──→A 否──→　前往19 18、吃蚕豆时，你会连壳带肉吞下吗？ 是──→　C 否──→　D 19、说你是神经病，你会承认吗？ 是──→　B 否──→　A 20、说你以后可能会变成神经病，你相信吗？　是──→　B 否──→D 隐藏： 本部分内容已经隐藏，必须回复后，才能查看 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b2610ad97c481a528aa96fc93d65b6/" rel="bookmark">
			javascript实现繁体简体转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt; New Document &lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;html&gt; &lt;head&gt; &lt;META http-equiv=Content-Type content="text/html; charset=utf-8"&gt; &lt;title&gt;汉字简体繁体转换&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;input type=radio name=r1 value=0 οnclick="h1.value=0;convert()" checked&gt;简体 &lt;input type=radio name=r1 value=1 οnclick="h1.value=1;convert()"&gt;&lt;u&gt;&lt;b&gt;&lt;font color="#FF0000"&gt;繁体&lt;/font&gt;&lt;/b&gt;&lt;/u&gt; &lt;br&gt; &lt;textarea id=txt rows=80 cols=120 value=''&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type=hidden name=h1 value=0&gt; &lt;script&gt; //*************Copyright 2003***************** // This script is written by neweroica, 2003-1-6 //****************************************** function charPYStr(){ return '啊阿埃挨哎唉哀皑癌蔼矮艾碍爱隘鞍氨安俺按暗岸胺案肮昂盎凹敖熬翱袄傲奥懊澳芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸白柏百摆佰败
拜稗斑班搬扳般颁板版扮拌伴瓣半办绊邦帮梆榜膀绑棒磅蚌镑傍谤苞胞包褒剥薄雹保堡饱宝抱报暴豹鲍爆杯碑悲卑北辈背贝钡倍狈备惫焙被奔苯本
笨崩绷甭泵蹦迸逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必辟壁臂避陛鞭边编贬扁便变卞辨辩辫遍标彪膘表鳖憋别瘪彬斌濒滨宾摈兵冰柄丙秉饼炳
病并玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳捕卜哺补埠不布步簿部怖擦猜裁材才财睬踩采彩菜蔡餐参蚕残惭惨灿苍舱仓沧藏操糙槽曹草厕策侧
册测层蹭插叉茬茶查碴搽察岔差诧拆柴豺搀掺蝉馋谗缠铲产阐颤昌猖场尝常长偿肠厂敞畅唱倡超抄钞朝嘲潮巢吵炒车扯撤掣彻澈郴臣辰尘晨忱沉陈
趁衬撑称城橙成呈乘程惩澄诚承逞骋秤吃痴持匙池迟弛驰耻齿侈尺赤翅斥炽充冲虫崇宠抽酬畴踌稠愁筹仇绸瞅丑臭初出橱厨躇锄雏滁除楚础储矗搐
触处揣川穿椽传船喘串疮窗幢床闯创吹炊捶锤垂春椿醇唇淳纯蠢戳绰疵茨磁雌辞慈瓷词此刺赐次聪葱囱匆从丛凑粗醋簇促蹿篡窜摧崔催脆瘁粹淬翠
村存寸磋撮搓措挫错搭达答瘩打大呆歹傣戴带殆代贷袋待逮怠耽担丹单郸掸胆旦氮但惮淡诞弹蛋当挡党荡档刀捣蹈倒岛祷导到稻悼道盗德得的蹬灯
登等瞪凳邓堤低滴迪敌笛狄涤翟嫡抵底地蒂第帝弟递缔颠掂滇碘点典靛垫电佃甸店惦奠淀殿碉叼雕凋刁掉吊钓调跌爹碟蝶迭谍叠丁盯叮钉顶鼎锭定
订丢东冬董懂动栋侗恫冻洞兜抖斗陡豆逗痘都督毒犊独读堵睹赌杜镀肚度渡妒端短锻段断缎堆兑队对墩吨蹲敦顿囤钝盾遁掇哆多夺垛躲朵跺舵剁惰
堕蛾峨鹅俄额讹娥恶厄扼遏鄂饿恩而儿耳尔饵洱二贰发罚筏伐乏阀法珐藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛坊芳方肪房防妨仿访纺放菲非啡飞肥
匪诽吠肺废沸费芬酚吩氛分纷坟焚汾粉奋份忿愤粪丰封枫蜂峰锋风疯烽逢冯缝讽奉凤佛否夫敷肤孵扶拂辐幅氟符伏俘服浮涪福袱弗甫抚辅俯釜斧脯
腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐噶嘎该改概钙盖溉干甘杆柑竿肝赶感秆敢赣冈刚钢缸肛纲岗港杠篙皋高膏羔糕搞镐稿告哥歌搁戈鸽胳
疙割革葛格蛤阁隔铬个各给根跟耕更庚羹埂耿梗工攻功恭龚供躬公宫弓巩汞拱贡共钩勾沟苟狗垢构购够辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇刮
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b2610ad97c481a528aa96fc93d65b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b086800afc9bc2c6b5ba712d8a055e5a/" rel="bookmark">
			二维数组转变成一维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		program OneRowTomultilycol;
{$APPTYPE CONSOLE}
uses
SysUtils;
procedure OneRowTomultilycol(m,n:Integer);
var Arr2:Array of array of Integer;
arr1:array of Integer;
I,J,Row,Col:integer;
tmp:integer;
begin
setlength(arr2,m);
for i:=low(arr2) to high(arr2) do
setlength(arr2[i],n);
//Init arr2
writeln('The arr2 value:');
for i:=0 to high(arr2) do
begin
for j:=0 to high(arr2[i]) do
begin
arr2[i,j]:=i*n+j;//i is index of row ,j is index of col,n is length of col
write(arr2[i,j]);
write(' ');
end;
writeln;
end;
//set arr1 and output arr1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b086800afc9bc2c6b5ba712d8a055e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f57b9b26c3cd5cac2346dc986b4867/" rel="bookmark">
			Foxmail地址本syncML同步 数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：
1、以下数据为xml格式，可以保存为 abc.xml后直接用IE或其他浏览器打开查看
2、以下数据是第一次同步是完整的数据记录，上传了一个地址本
&lt;all&gt;
&lt;!-- from client package 1 --&gt; &lt;SyncML&gt;
&lt;SyncHdr&gt;
&lt;!-- 在SyncHdr（包头）元素中的要求如下：
A.VerDTD元素的值必须是‘1.1’。
B.必须VerProto元素来制定使用的协议和协议版本，其值必须为‘SyncML/1.1’
C. 必须制定同步的session ID
D. 必须使用Msgid清晰的表明消息属于一个同步session（sync session）
E、如果需要认证的，必须包含Cred元素。
--&gt; &lt;VerDTD&gt;1.0&lt;/VerDTD&gt; &lt;VerProto&gt;SyncML/1.0&lt;/VerProto&gt; &lt;SessionID&gt;WLC1&lt;/SessionID&gt; &lt;MsgID&gt;1&lt;/MsgID&gt; &lt;Target&gt;
&lt;LocURI&gt;http://www.xxx.com/t&lt;/LocURI&gt; &lt;/Target&gt;
&lt;Source&gt;
&lt;LocURI&gt;885B8928-7A2F-45BF-8998-76F977079757&lt;/LocURI&gt; &lt;/Source&gt;
&lt;!-- The Meta is now used to indicate the maximum SyncML message size, which
client can receive.
--&gt; &lt;Meta&gt;
&lt;MaxMsgSize xmlns="syncml:metinf"&gt;102400&lt;/MaxMsgSize&gt; &lt;/Meta&gt;
&lt;Cred&gt;
&lt;!-- Base64 formating for user “Bruce2”, password “OhBehave”, nonce “Nonce” --&gt; &lt;Meta&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66f57b9b26c3cd5cac2346dc986b4867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e5c5feea396e0047f1913b973efb67/" rel="bookmark">
			如何使用RC.exe生成VB中的RES文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		This article provides a short look at how to use the Resource Compiler (RC.EXE) to create resource files (.RES) for Visual Basic applications. Using RC.EXE directly is often better than using the wizards provided with VB5 and 6 as you have more control over including arbitrary data; in addition the wizard versions do not encode icons correctly. About the Resource Compiler The Resource Compiler compiles resource definition files (.RC files) and the actual resource to be included (binary files such as icon, bitmap, and cursor files) into a binary resource (.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e5c5feea396e0047f1913b973efb67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bbd5651a37a7722daf9b0a9c64709b2/" rel="bookmark">
			第五章 厂级负荷优化分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 综合分析比较了评价机组运行好坏的6种经济指标，选取供电煤耗率作为负荷优化分配的目标函数；通过历史库数据计算得到各工况下的供电煤耗率，采用最小二乘法，拟合出机组当前能耗特性曲线；并按照一定的规则，对曲线进行实时修正。
2. 以全厂供电煤耗率最低为目标函数，建立了机组负荷优化分配问题的数学模型，并给出了约束条件。
3. 基于分层模糊遗传算法对目标函数进行了求解。该算法采用浮点数编码方式对种群个体初始化﹑交叉和变异，建立分层控制规则对交叉概率和变异概率进行在线调整；同时，使用孤岛模式和临域搜索策略，通过几个相对独立的子群间相互竞争增加了演化的全局性。
4. 分层模糊遗传算法计算程序的计算时间在0.4～0.8s之间，能够保证较好的实时性。同时，分层模糊遗传算法的优化结果比二进制编码基本遗传算法﹑传统值长分配模式要好，特别是在全厂总负荷较低时，全厂供电煤耗率可以降低约2 g/kW﹒h。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2078c796f16a6a2f7aa0ae60e46b567/" rel="bookmark">
			SuspendLayout()方法的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SuspendLayout()是临时挂起控件的布局逻辑（msdn），它与ResumeLayout()配合使用。我的理解是使用SuspendLayout()让整个窗口停止，等到所有的东西都设置完毕了，然后用ResumeLayout()把所有的东西加到窗口。
例如，先调用SuspendLayout()，然后添加两个控件，再调用ResumeLayout()，把控件显示到窗口上，有点像BeginUpdate()和EndUpdate()。
我不知道我的理解对不对？看到的各位如果觉得我的不对，请留言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4602906572bb013bfdba425d408f2ed/" rel="bookmark">
			快速平方根（平方根倒数）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日前在书上看到一段使用多项式逼近计算平方根的代码，至今都没搞明白作者是怎样推算出那个公式的。但在尝试解决问题的过程中，学到了不少东西，于是便有了这篇心得，写出来和大家共享。其中有错漏的地方，还请大家多多指教。
的确，正如许多人所说的那样，现在有有FPU，有3DNow，有SIMD，讨论软件算法好像不合时宜。关于sqrt的话题其实早在2003年便已在 GameDev.net上得到了广泛的讨论（可见我实在非常火星了，当然不排除还有其他尚在冥王星的人，嘿嘿）。而尝试探究该话题则完全是出于本人的兴 趣和好奇心（换句话说就是无知）。
我只是个beginner，所以这种大是大非的问题我也说不清楚（在GameDev.net上也有很多类 似的争论）。但无论如何，Carmack在DOOM3中还是使用了软件算法，而多知道一点数学知识对3D编程来说也只有好处没坏处。3D图形编程其实就是 数学，数学，还是数学。
在3D图形编程中，经常要求平方根或平方根的倒数，例如：求向量的长度或将向量归一化。C数学函数库中的sqrt具有理想的精度，但对于3D游戏程式来说速度太慢。我们希望能够在保证足够的精度的同时，进一步提高速度。
Carmack在QUAKE3中使用了下面的算法，它第一次在公众场合出现的时候，几乎震住了所有的人。据说该算法其实并不是Carmack发明的，它真正的作者是Nvidia的Gary Tarolli（未经证实）。
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
//
// 计算参数x的平方根的倒数
//
float InvSqrt (float x)
{
float xhalf = 0.5f*x;
int i = *(int*)&amp;x;
i = 0x5f3759df - (i &gt;&gt; 1); // 计算第一个近似根
x = *(float*)&amp;i;
x = x*(1.5f - xhalf*x*x); // 牛顿迭代法
return x;
}
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
该 算法的本质其实就是牛顿迭代法（Newton-Raphson Method，简称NR），而NR的基础则是泰勒级数（Taylor Series）。 NR是一种求方程的近似根的方法。首先要估计一个与方程的根比较靠近的数值，然后根据公式推算下一个更加近似的数值，不断重复直到可以获得满意的精度。其 公式如下：
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
函数：y=f(x)
其一阶导数为：y'=f'(x)
则方程：f(x)=0 的第n+1个近似根为
x[n+1] = x[n] - f(x[n]) / f'(x[n])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4602906572bb013bfdba425d408f2ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58817a4f75316a6983e04392b31662df/" rel="bookmark">
			Oracle 分析函数使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析函数是oracle816引入的一个全新的概念,为我们分析数据提供了一种简单高效的处理方式.在分析
函数出现以前,我们必须使用自联查询,子查询或者内联视图,甚至复杂的存储过程实现的语句,现在只要一
条简单的sql语句就可以实现了,而且在执行效率方面也有相当大的提高.下面我将针对分析函数做一些具
体的说明.
今天我主要给大家介绍一下以下几个函数的使用方法
1. 自动汇总函数rollup,cube,
2. rank 函数, rank,dense_rank,row_number
3. lag,lead函数
4. sum,avg,的移动增加,移动平均数
5. ratio_to_report报表处理函数
6. first,last取基数的分析函数
基础数据
create table t(BILL_MONTH varchar2(6),AREA_CODE varchar2(4),NET_TYPE char(1),LOCAL_FARE number(12,2));
Insert into t
(BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)
Values
('200405', '5761', 'G', 7393344.04);
Insert into t
(BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)
Values
('200405', '5761', 'J', 5667089.85);
Insert into t
(BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)
Values
('200405', '5762', 'G', 6315075.96);
Insert into t
(BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58817a4f75316a6983e04392b31662df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8190f56fab8d8ab7876824235e64b4/" rel="bookmark">
			轻松为Windows配置多个网关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在比较复杂的网络环境中，用户需要通过不同的网关访问不同的网络服务器，比如笔记本电脑用户在家时使用ADSL，在单位使用局域网时就需要切换不同的网关。而使用Windows系统“控制面板”中的“网络”进行配置，虽然可以配置多个网关，但其实真正有效的只有一个网关，即默认网关，因此无法满足用户的需求。 怎样才能在Windows系统中配置多个网关呢？首先要在Windows的安装目录下编写路由程序“route.bat”文件，文件内容为： route add 目标1 mask 子网掩码 网关1 route add 目标2 mask 子网掩码 网关2 route add 0.0.0.0 mask 0.0.0.0 默认网关 其中的目标1为路由的第一个网络号，目标2为路由的第二个网络号。子网掩码分别为两个网络的子网掩码。 其次设置每次启动Windows时，自动执行路由程序“route.bat”，即将指向程序“route.bat”的快捷方式添加到菜单的“启动”栏中。具体设置步骤为：点击“开始→设置→任务栏和开始菜单”，自定义开始菜单程序。单击“添加”，输入“C:/Windows/route.bat”并按回车键。在此我们假定Windows的安装目录为“C:/Windows”。接着双击“启动”文件夹，输入该程序在“启动”菜单中的名称后单击“下一步”按钮，选择程序图标。最后修改指向程序“route.bat”快捷方式的属性，点击“开始→程序→启动”，鼠标右键点击“route.bat”，选择属性，选择“最小化”和“退出时关闭”即可。 通过以上的设置，就可以满足用户配置多个网关的需求。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bd0957efa25c091af821f1e49750d65/" rel="bookmark">
			笔试的一些题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int Strcmp(char *str1, char *str2)
{
int i=0;
int b=0;
while(str1[i]||str2[i])
{
if(str1[i]&gt;str2[i])
{
b=1;break;
}
else if(str1[i]&lt;str2[i])
{
b=-1;break;
}
i++;
}
return b;
}
***************************************************************************************************************
1.说出下面这个程序的运行结果，并简要叙述其理由：
char buf1[10]="hello";
char buf2[10]="hello";
if (buf1==buf2)
printf("equal!");
else printf("not equal!");
因为buf1,buf2分配了不同的内存块，而比较的是数组名，实际上是两个分别指向数组起始元素地址的指针。
2.指出下面这段程序中存在一些什么问题：
int loop,a[5];
int* p=a;
for (loop=0;loop&lt;5;loop++)
{ p++;
*p=loop;
}
数组a[5]在创建时没有初始化， 在for循环里也没有起到完全初始化数组的作用，而且对一块未知内存赋值。在最后一轮循环
结束时p指向了数组a[5]的最后一个元素的下一个地址。
string 系列
char * strcpy( char *strDest, const char *strSrc ) {
assert( (strDest != NULL) &amp;&amp; (strSrc !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bd0957efa25c091af821f1e49750d65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/828ba2e5c55e2a3f5e115f5d05b5d3b6/" rel="bookmark">
			银河麒麟服务器操作系统2.0 BEA Platform MySQL JDK Tomcat实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		银河麒麟服务器操作系统2.0 BEA Platform MySQL实战
KyLin 2.0 BEA Platform MySQL JDK 1.5.0 Tomcat 5.5.12 http://dev2dev.bea.com.cn/bbs/thread.jspa?forumID=81&amp;threadID=30118&amp;messageID=179957
前前后后一共用了好几个周末的时间，终于整理出文档来了：）
相关文档请到上面地址去下载！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224ef08c23aa76c48427523c40153bba/" rel="bookmark">
			用vc实现隐藏系统托盘图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天在做一个msn隐藏的工具时，想实现隐藏msn系统托盘的图标，在网上搜索了一下，发现有人用vb实现的代码，依样画葫芦弄到了vc里面，但是发现我的到的托盘图标的描述基本上是乱码。今天在看ATL的东西时突然想起会不会是字串格式的问题呢？查msdn后发现有一个String Conversion Macro的主题，在使用了OLE2T后(还需要一个USES_CONVERSION;不然会有编译错误)，终于得到了在vb中一样的字符串了。^O^　islq 2006-3-19
完整代码如下：
void CMyDlg::MoveTray(BOOL flag)
{
// TODO: Add your control notification handler code here
HWND hWnd,hWndTmp;
unsigned long lngPID;
long ret,lngButtons;
HANDLE hProcess;
LPVOID lngAddress;
long lngTextAdr,lngHwndAdr,lngHwnd,lngButtonID;
char strBuff[1024]={0};
char* str = NULL;
hWnd = ::FindWindow("Shell_TrayWnd", NULL);
hWnd = ::FindWindowEx(hWnd, 0, "TrayNotifyWnd", NULL);
hWndTmp = ::FindWindowEx(hWnd, 0, "SysPager", NULL);
if(!hWndTmp)
hWnd = ::FindWindowEx(hWnd, 0, "ToolbarWindow32", NULL);
else
hWnd = ::FindWindowEx(hWndTmp, 0, "ToolbarWindow32", NULL);
TRACE("/nhWnd=%x/n",hWnd);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/224ef08c23aa76c48427523c40153bba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e012ee2c05795b1fec9fde9ef9c0a6e8/" rel="bookmark">
			免费的在线电影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新开通的用户会送100点
100点相当于100分钟观看时间
你会想100分钟够看个鸟
请看下面
＋＋＋＋＋＋＋＋
因为该网站新开通 实行免费充电 你在用户专区点击冲值 输入卡号powervod 密码vod
就可以冲上200点了 无限冲 但每当充满1000点以上 就会提示你无法冲值 没关系 用完之后再冲就好了 （这是注册了N个ID后才发现的 郁闷死了…… 该死的首页上也不说著名）
http://www.powervod.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d945c75ff819ffebeb1d2557de259754/" rel="bookmark">
			磁盘碎片原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xumai 一、什么是磁盘碎片？ 其实磁盘碎片应该称为文件碎片，是因为文件被分散保存到整个磁盘的不同地方，而不是连续地保存在磁盘连续的簇中形成的。 当应用程序所需的物理内存不足时，一般操作系统会在硬盘中产生临时交换文件，用该文件所占用的硬盘空间虚拟成内存。虚拟内存管理程序会对硬盘频繁读写，产生大量的碎片，这是产生硬盘碎片的主要原因。 其他如IE浏览器浏览信息时生成的临时文件或临时文件目录的设置也会造成系统中形成大量的碎片。文件碎片一般不会在系统中引起问题，但文件碎片过多会使系统在读文件的时候来回寻找，引起系统性能下降，严重的还要缩短硬盘寿命。另外，过多的磁盘碎片还有可能导致存储文件的丢失。 二、磁盘碎片是怎么产生的？ 在磁盘分区中，文件会被分散保存到磁盘的不同地方，而不是连续地保存在磁盘连续的簇中。又因为在文件操作过程中，Windows系统可能会调用虚拟内存来同步管理程序，这样就会导致各个程序对硬盘频繁读写，从而产生磁盘碎片。 三、磁盘读写操作的原理 知道了磁盘碎片的产生原因之后，我们还有必要了解一下程序运行时磁盘的读写动作。一般运行一个程序时，磁盘驱动器的磁头所做的工作是先搜索该程序运行必需的文件，然后读取数据，最后做读后处理——将数据传送至磁盘高速缓存(Cache)和内存中。搜索时间在硬盘性能指标中被称为平均寻道时间（Average seek time），单位为毫秒（ms），目前主流硬盘的平均寻道时间小于9.5ms。如果能将应用程序的相关文件放在磁盘的连续空间内，磁头搜索的时间将会减少很多。读取时也是如此，磁盘读取位于磁头下方扇区的数据所需时间仅为将磁头移到另一地点再读取相同数据所需时间的五分之一。读盘时，系统先检查数据是否在高速缓存中，如果有则直接读取；如果没有则访问磁盘，也就是读盘。当需要多次读取同一份数据时，Cache的作用很大，但对于第一次读取某个文件，Cache就无能为力了。于是搜索时间和读取时间在很大程度上影响着程序执行的效率。 为何要整理磁盘 Windows系统并不能自动将每个文件按照最大程度减少磁头搜索时间的原则放到磁盘上最合适的位置。于是Microsoft在Windows中加入了“Disk Defragment”（磁盘碎片整理程序），并提供了“TaskMonitor”(任务监视器）来跟踪程序启动过程中的磁盘活动，以利于“Disk Defragment”能够更有效地工作。“TaskMonitor”是随Windows启动而自动运行的(当然要在“启动”中选中“TaskMonitor”)。当加载某个应用程序时，它通过监视磁盘的访问动作来了解该程序启动时搜索和调用的文件，对所需文件进行定位，并将监视结果储存在“C：\Windows\Applog”隐藏目录中。这个目录中的大多数文件以“.lgx”为扩展名，其中“lg”代表记录文件（Log File），“x”表示盘符，如D盘程序就以“.lgd”为扩展名；记录文件的文件名为TaskMonitor所监视的应用程序的文件名，如E盘上的WinZip程序记为“Winzip32.lge”。用户进行磁盘碎片整理时，该程序会根据Applog目录中的信息把应用程序的相关文件移动到磁盘上的连续空间内。 TaskMonitor仅在程序加载过程中对文件信息进行搜索，并且根据程序的加载频率调整优化的顺序，也就是说使用次数最多的软件可获得最多的关照。Applog目录中的APPLOG.ind文件就记录了应用程序运行的次数。用户需要将常用软件多次启动，接受TaskMonitor的监视和记录，再使用Disk Defragment进行整理，才能真正实现程序启动速度的提高。但如果用户中途改变了常用软件，比如以前常用WinZip，现在改用ZipMagic，那么在相当长的时间内Disk Defragment还是先把与WinZip相关的文件移到连续的空间内，而不是ZipMagic，除非ZipMagic的加载次数超过WinZip。要解决这个问题，用户可将“Winzip32.lgx”文件删除，记录文件不存在了，Disk Defragment也就不会去优化它了。 四、该不该定期整理硬盘？ 实际上，定期整理硬盘应该是毫无疑问的。如果说硬盘碎片整理真的会损害硬盘的话，那也将是在对硬盘进行近乎天文数字般次数的整理之后。 硬盘使用的时间长了，文件的存放位置就会变得支离破碎——文件内容将会散布在硬盘的不同位置上。这些“碎片文件”的存在会降低硬盘的工作效率，还会增加数据丢失和数据损坏的可能性。碎片整理程序把这些碎片收集在一起，并把它们作为一个连续的整体存放在硬盘上。Windows自带有这样的程序：磁盘碎片整理程序（DiskDefragmenter），但在工具软件NortonUtilities和Nuts&amp;Bolts中有更好的此类程序。 然而，碎片整理对硬盘里的运转部件来说的确是一项不小的工作。如果硬盘已经到了它生命的最后阶段，碎片整理的确有可能是一种自杀行为。但在这种情况下，即使您不进行碎片整理，硬盘也会很快崩溃的。 实际上在大多数情况下，定期的硬盘碎片整理减少了硬盘的磨损。不管怎么说，让硬盘的磁头从1处读取文件总比从8处读取要容易得多。因此，一个每两周或四周整理一次的硬盘的寿命应当比一个永远不整理的硬盘长。 五、整理前的准备工作 我们在整理硬盘前一般都要对它清理垃圾信息，检查有无错误，最后才能谈到碎片的整理和优化。因此，我们在整理硬盘前，应该首先做好这些工作： 1、应该把硬盘中的垃圾文件和垃圾信息清理干净。系统工作一段时间后，垃圾文件就会非常之多，有程序安装时产生的临时文件、上网时留下的缓冲文件、删除软件时剩下的DLL文件或强行关机时产生的错误文件等，建议“菜鸟”朋友还是使用微软的“磁盘清理程序”代劳，“老鸟”当然可以使用一些功能更强的软件或手工清理。 2、检查并修复硬盘中的错误。首选的仍然是微软的“磁盘扫描程序”，虽然它的速度实在不怎么样，但只要你有足够的耐心，经过这个程序对磁盘完整而详细的扫描后，相信系统中的绝大多数错误已经被修复了。当然你也可以尝试一下其他工具，如扁鹊神医“Norton WinDoctor”，它的速度可比Windows中的“磁盘扫描工具”快多了。 六、整理方法及注意 在Windows里，用户可以从“开始”菜单中选择“程序/附件/系统工具/磁盘碎片整理程序”，弹出选择驱动器窗口，选择要整理的分区，然后点击[确定]即可开始整理，但此方法碎片整理过程非常耗时，一般2GB左右的分区需要1个小时以上，所以建议读者: 1、整理磁盘碎片的时候，要关闭其他所有的应用程序，包括屏幕保护程序，最好将虚拟内存的大小设置为固定值。不要对磁盘进行读写操作，一旦Disk Defragment发现磁盘的文件有改变，它将重新开始整理。 2、整理磁盘碎片的频率要控制合适，过于频繁的整理也会缩短磁盘的寿命。一般经常读写的磁盘分区一周整理一次。 七、磁盘扫描程序的命令参数 命令参数在 DOS时代可以说是一项基本的技能，很多程序都要靠命令参数来启动，而到了图形化界面时代，已很难再见到其踪迹，但它却实实在在地存在着，而且发挥着不小的作用。如很多 Windows游戏的设置程序就是用 /Setup 参数来实现的。通常我们不会太留意某些程序的命令参数，但他们往往包含着某些隐秘的功能，如果运用适当对你很有帮助。 Windows 中的磁盘扫描程序就包含着许多命令参数，你可以在MS_DOS方式下或在“运行”对话框中实现，如果需要经常用命令参数，还可以建立一个快捷方式。 /SILENT 启动磁盘扫描程序不允许作任何选项设置和高级设置。 /A　检查所有的本地硬盘 /N　自动启动和退出磁盘扫描程序 /P　防止磁盘扫描程序修复所发现的错误 X:　X 表示指定要检查的驱动器号（不需要 / 的命令参数） 举例： 1）检查驱动器 E 并自动启动和退出磁盘扫描程序 SCANDSKW E: /N 2）检查所有的硬盘并防止磁盘扫描程序修复发现的任何错误 SCANDSKW /A /P 八、运行过其他文件整理程序怎么办 当运行了其他磁盘文件整理程序（如WinAlign）后，它可能扰乱了TaskMon记录的数据，若此时直接进行碎片整理，可能会得不偿失，达不到优化性能的目的。解决的办法是在进行碎片整理之前，多次运行Windows和自己最常用的程序，这样可以让TaskMon重新收集到正确的统计数据，指导进行磁盘优化。 最后，当启动Windows98的磁盘碎片整理程序时，可能会诧异界面中的Intel标志。为什么处理器的生产厂商会参与编写这个优化磁盘的软件呢？这是因为硬盘寻道时间的缓慢会导致系统整体性能的下降，这样会有损CPU超级计算能力的形象，让人误以为是CPU性能的低下。Microsoft的一个测试表明，在奔腾233的机器上启动Windows仅仅比奔腾150快3％，也就是说，快速的CPU并不能克服磁盘延迟的缺点。于是，在共同利益的驱动下，Intel和Microsoft联合开发了Windows98的磁盘碎片整理程序，用来消除硬盘寻道缓慢的瓶颈。 九、如何快速地整理磁盘碎片 每次需要整理磁盘碎片时都需要选择“开始”*“程序”*“附件”*“系统工具”*“磁盘碎片整理程序”，然后再指定驱动器，很麻烦。能否有简单的方法完成这一系列操作？ 在Windows资源管理器中，选择“查看”*“文件夹选项”(或“查看”*“选项”)，选择“文件类型”选项卡，并在“已注册的文件类型”列表中选择“驱动器”。单击“编辑”按钮，打开“编辑文件类型”对话框，选择“新建”，在“操作”栏中，键入“快速整理磁盘碎片”。在“用于执行操作的应用程序”栏中键入“C:\Windows\defrag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d945c75ff819ffebeb1d2557de259754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86576d5fa778c09d2f12285cb4fb9621/" rel="bookmark">
			SQL中EXISTS的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EXISTS 指定一个子查询，检测行的存在。 语法 EXISTS subquery 参数 subquery 是一个受限的 SELECT 语句 (不允许有 COMPUTE 子句和 INTO 关键字)。有关更多信息，请参见 SELECT 中有关子查询的讨论。 结果类型 Boolean 结果值 如果子查询包含行，则返回 TRUE。 示例 A. 在子查询中使用 NULL 仍然返回结果集 这个例子在子查询中指定 NULL，并返回结果集，通过使用 EXISTS 仍取值为 TRUE。 USE Northwind
GO
SELECT CategoryName
FROM Categories
WHERE EXISTS (SELECT NULL)
ORDER BY CategoryName ASC
GO
B. 比较使用 EXISTS 和 IN 的查询 这个例子比较了两个语义类似的查询。第一个查询使用 EXISTS 而第二个查询使用 IN。注意两个查询返回相同的信息。 USE pubs
GO
SELECT DISTINCT pub_name
FROM publishers
WHERE EXISTS
(SELECT *
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86576d5fa778c09d2f12285cb4fb9621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8253ba724455961cd3bc2fa7165a51a/" rel="bookmark">
			从SQL Server中读写大数据列。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*
Author:Wu Xiuxiang;
Email:imessage@126.com
*/
public static void Main()
{
//写入大对象到SqlServer
FileStream fs = new FileStream("C://test.bmp",FileMode.OPen,FileAccess.Read);
BinaryReader br = new BinaryReader(fs);
SqlConnection conn = new SqlConnection("server=localhost;uid=sa;pwd=sa;database=northwind");
string cmdText = "UPDATE EMPLOYEES" +
"SET Photo=@image where EmployeeId=1";
SqlCommand cmd = new SqlCommand(cmdText,conn);
cmd.Parameters.Add("@image",SqlDbType.Image);
cmd.Parameters["@image"].Value = br.ReadBytes((int)br.BaseStream.Length);
conn.Open();
int i=cmd.ExecuteNoQuery();
//从SQL Server中读取大对象
string cmdtext = "SELECT employeeid,photo" +
" from employees where employeeid = 1";
SqlCommand cmd2 = new SqlCommand(cmdtext,conn);
FileStream rfs;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8253ba724455961cd3bc2fa7165a51a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d632328e767fc2b91fc381a75c41160/" rel="bookmark">
			脱壳技术简谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我想大家应该先明白“壳”的概念。在自然界中，我想大家对壳这东西应该都不会陌生了，植物用它来保护种子，动物用它来保护身体等等。同样，在一些计算机软件里也有一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。就像动植物的壳一般都是在身体外面一样理所当然（但后来也出现了所谓的“壳中带籽”的壳）。由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，大家就把这样的程序称为“壳”了。就像计算机病毒和自然界的病毒一样，其实都是命名上的方法罢了。 一.壳的概念
作者编好软件后,编译成exe可执行文件
1.有一些版权信息需要保护起来,不想让别人
随便改动,如作者的姓名等
2.需要把程序搞的小一点,从而方便使用
于是,需要用到一些软件,他们能将exe可执行文件压缩,
实现上述两个功能,这些软件称为加壳软件或压缩软件.
它不同于一般的winzip,winrar等压缩软件.
它是压缩exe可执行文件的,压缩后的文件可以直接运行.
二.加壳软件
最常见的加壳软件ASPACK ,UPX,PEcompact
不常用的加壳软件WWPACK32；PE-PACK ；PETITE ；NEOLITE
三.侦测壳和软件所用编写语言的软件
侦测壳的软件fileinfo.exe 简称fi.exe(侦测壳的能力极强)
使用方法:
第一种：待侦测壳的软件(如aa.exe)和fi.exe位于同一目录下,执行
windows起始菜单的运行,键入
fi aa
第二种：
1.待侦测壳的软件(如aa.exe)和fi.exe位于同一目录下,将aa的图标拖到fi的图标上
2.侦测壳和软件所用编写语言的软件language.exe(两个功能
合为一体,很棒)　推荐language2000中文版,我的主页可下载
傻瓜式软件,运行后选取待侦测壳的软件即可(open)
3.软件常用编写语言Delphi,VisualBasic(VB)---最难破,VisualC(VC)
四.常用资源1.破解工具站点(以上工具从这里找)
www.exetools.com
www.pediy.com
http://www.programmerstools.com(guowai/
www.cracknow.com2.软件站点
www.newhua.com
www.hktk.com
http://www.esoftware.com.cn/ (强烈推荐,这里能找到软件的各个版本，尤其是旧版本。以后破解例子中所用软件一般在这儿都能找到）
www.shareware.net.cn
www.csdn.net
脱壳工具介绍（UNPACKERS） 一般某种压缩工具的壳，都会有相应的脱壳工具，因此只要找到较新版本的脱壳工具， 一般的壳都可轻易脱去。 常用脱壳工具（Windows Unpackers）列表： 名称 作者 主页 介绍 ASPack unpacker bane Homepage 脱ASPack的压缩PE文件。 UnPEPack M.o.D. 脱PEPack的壳 ProcDump32 十分优秀的“万能”脱壳工具，可惜不升级了，因此只能自动脱些老版本压缩工具的壳，但可通过脚本命令使其升级。也是一款优秀的PE修改工具。 侦测文件类型工具
名称 介绍 FileInfo 能检测多种文件格式，脱壳前用来判断是否加壳或何种壳，推荐使用！ GetTyp 功能同上 TYP 功能同上 要了解更多的压缩工具或脱壳工具可去下面站点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d632328e767fc2b91fc381a75c41160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd8e9cb097435d4d75848b47fd36833/" rel="bookmark">
			运行java.exe 出现Registry key &#39;Software/JavaSoft/Java Runtime Environment/CurrentVersion&#39;错误的解决 转贴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 运行java.exe 出现Registry key 'Software/JavaSoft/Java Runtime Environment/CurrentVersion'错误的解决。（原创）
前提：配置好了Path和ClassPath环境变量。
在控制台执行java.exe的时候多次出现如下错误：
Registry key 'Software/JavaSoft/Java Runtime Environment/CurrentVersion' has value '1.4', but '1.3' is required. Error: could not find java.dll Error: could not find Java 2 Runtime Environment. 尝试一、按照他的提示，查找注册表键，修改为1.3，未果；
尝试二、直接用全路径运行java.exe，奇怪；
尝试三、将Path中的java路径剪切到系统目录windows和system32后面作为第三个，依旧；
尝试四、将path中java路径放在第一位，OK；
尝试五、查找windows和system32目录，发现system32目录里有一个java.exe，估计是MS放进去的，Rename it，OK。
总结、原来是Path搜索顺序的问题，一开始就没往这里想，现在看来，思考还是很重要的，当然，尝试更重要。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec93f66f7814a480df2b82430e19391/" rel="bookmark">
			输出之前做些什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 引用: 1、简化EPS图象——如果要说最终原因的话，在PostSript文件里，过于复杂的路径是使文件不能正确打印的罪魁祸首。有过多节点的路径或者平滑设定太低，都会增加文件的复杂程度，引起激光打印机或照排机死机，导致致命的“Limitcheck”或“VMError”PostSript错误。特别是将文件发往高分辨率输出设备时，应该在Illustrator或Macromedia中，分割复杂路径和设定高平滑度，或者使用FreeHand中简化路径的指令。在使用Adobe Streamline描边时，利用路径简化来降低路径复杂程度。在Photoshop中使用高宽容读数值，以减少在选区变为剪砌路径时的节点数。不要将EPS图像套入其他EPS文件中。像这样：将几个EPS图像输入到Illustrator文件中，存储为EPS，置入到一个QuarkXPress页面中，将此页面存储为EPS，再置入到另一个QuarkXPress文件中。如果幸运的话，那个文件恰好能打印。但是，随着每层被置入到EPS，成功的机会会越来越少。如果必须将一个完整页面的QuarkXPress EPS转为可被Photoshop点阵话的文件。让Photoshop将文件变为点阵图像，然后存储为Photoshop的EPS或TIFF。这两种格式中的任何一种都不会为PostSript语言增加额外的层。 2、使渐变平滑——使用QuarkXPress和Illustrator所作的数学运算方式的渐变，在几英寸的短距离内效果很好，但是如果试图做成整页面细微的渐层，PostSript的限制就可能引带状效果，在Photoshop内将渐变做成点阵图像（使用Add Noise),然后输入到其他应用软件中。但是，不能使用Photoshop来处理在Illustrator内作的层。与直接在Photoshop调色板中产生的渐变相比，Photoshop所处理的Illustrator文件无法产生理想的中间渐层。 3、用好字体——许多输出中心都不希望看到TrueType字，PostSript已经成了一种标准。TrueType通常与对应的PostSript字拥用相同的字名，会引起冲突。TrueType必须手工下载到照排机的RIP里，这是很费时的事，事先同输出中心联系。不要使用字型命令来产生加粗或斜体效果，最好直接从应用软件字体菜单下选择想要的字体效果。如过字体没有想要的粗或斜效果，而又用了字型命令，MAC会为每个字伪造出加粗或斜体效果，但这只是屏幕上而已。如果是在打印机上输出，最后打印效果，看起来就象根本没有使用过一样。那么，使用加底线的效果又是怎样的呢？不要使用那些字体本身就没有的效果，而需要用字型命令的字体。如果，是使用有漂亮的衬线或细笔画的字体（Bodoni是一个很好的例字），而字的尺寸又设置的很小，就不要将字作分色处理。否则，即使印版上对准上细微的错位，都会引起最敏感部位的套印不准。 4、颜色转换——在把文件送去输出之前，要把RGB的色彩转换成CMYK。当然，RGB色彩在屏幕上看起来十分好看，而且许多专业人士更喜欢用RGB模式，但是，你知道吗？这些RGB模式的图像在被分色或印刷后，会是什么样子（以前许多排版软件甚至还不能将RGB图像分色）。在把图像置入到排版软件前或者送输出中心之前，先将他们转化为CMYK格式（在Photoshop或其他能作此转化的软件中）。要确定没有将一个专色指定为分色，或者反过来，将分色指定为专色。一个这样的错误，就可能毁掉一张胶片。如果，你的时间宝贵而且你自己花钱出胶片，这肯定你所不希望的。一定要确定你在排版软件中定义的颜色，与图像处理软件中用的是相同的名字。否者，排版软件会把在Illustrator和FreeHand中定义的分色处理成专色。现在，QuarkXPress和PageMaker可以识别这种颜色，并在颜色清单中付上任何置入其中的EPS文件所包含的颜色名。因此，这种危险就不太大了，不过在这里还是向各位提一下。 5、使用数字——现在每个排版软件中都提供两种方法确定页面元素的大小和位置。一种方法是点按拖拉鼠标的感性方法，另一种是从各种不同对话框和控制面板输入数字的客观方法。要确定准确确定一个框的宽度恰好是一个半英寸，唯一正确的方法是在宽度栏里输入1.5"，而不是用目或者对齐参考线和尺寸的方法。 6、将排版页面设定为实际的尺寸——在以前那段不太令人满意的日子，印前工作站和照排机不能记录超出页面范围的出血部分。如果，想得到正确的出血，就不得不在排版软件中改变页面尺寸来调整实际页面尺寸和出血。这必定要有更大的页面尺寸，以便人工画出并放置裁切线，这样做就容易出错。现在的印前设备不再受这些限制的阻碍（现在的照排机可以照排记录更大的幅面和使用更宽的胶片）。大多数的打印设备都建议将文件尺寸设定为页面实际尺寸，让应用软件自动产生正确定位的裁切线。 7、整理好文件——谈论这点对老手来说，可能是多余的，但对新手来说又不得不再强掉一下。除了要将文件中用到的所有图像文件带去，你还要将文件中用到的PostSript字的点阵字（屏幕显示）和轮廓字（打印机用）都带到输出中心。现在大多数排版软件都类似于QuarkXPress的收集输出文挡命令，可以得到有关文件的详尽报告并且会自动将文件拷贝至一个文件夹，软盘或SyQuest盘中。如果输出中心有较高的配置，他们一定会有Adobe字库，这样你就可以不用将字一起带去了。 8、检查文件——在第4和第7步中提到，哪些可以做，哪些不可以做，你是不是听得云里雾里了？其实就是很简单的检查。所检查应该包括：检查每一个被漏掉的页面元素，没有被正确定义的颜色和PostSript错误。检查工具简单的像为QuarkXPress准备的Lepton Technology's DocumentDoctor或为PageMaker准备的Adobe's CheckList,复杂的像Systems of Merritt's LaserCheck或Acquired Knowledge's Dowmload Mechanic。Panther Proof或Adobe PrePrint Pro，都可以执行低解析度输出的屏幕预视，这样你可以在输出之前，检查并解决普通的PostScript错误。“华妍打样”软件具有最终检查文档是否出错的强大功能。 9、打印文件——打样输出文件，要标明分色。如果身边找不到彩色打印机，那么过去用的色彩标注的方法就很有用。还要大每份分色，这样对挖空和套印就很有用了！ 10、打个电话与输出中心联系——不要在工作流程的最后——才与输出中心联系，要一开始就联系。通过与最后负责输出人员的联系，可以令许多输出问题可以避免。可不要认为在MAC屏幕看起来很好看的文件，一定符合输出中心的要求，到印刷出来后也怎么好。一定要搞清印刷时使用的解析度（每英寸的线数），油墨及纸张。然后在应用软件中设定相应的网线数。出负片时，应该和输出人员说明一下，不然输出人员会按常规给你出正片。 时间对每个出版人员是宝贵的，以上的10条印艺专家的秘诀是不是为你节省了一些时间呢？希望，通过以上10条的介绍能给各位带来一些启迪，原来输出并不可怕。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/709f7c5648eef7a9022dfafe5ccc0f94/" rel="bookmark">
			电子书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eclipse(www.eclipse.org)
是很好的java开发调试环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac6d441030eb0844ffb83ba4f100c94/" rel="bookmark">
			punctuation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ellipsis...或... ...
colon:
semicolon;
comma,
period.
exclamation mark!
question mark?quotation mark"..........."或'...........' 双的可以再加个double
dash或者en dash- 短破折号，hyphen是正规的，口语就dash
em dash－ 长破折号(因为长的用了两格像m用了两格，n只用一格)
solidus或slash /
reverse solidus或back slash 标点符号：punctuation (mark)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08c693a901b480f1e36f090101b0e5b/" rel="bookmark">
			启动过程出现configuring kernek parameters，然后挂起的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天，在更改了 /etc/X11/xorg.conf 文件，重启后，出现 configuring kernel parameters: 然后挂起不动的状况…… 没辙，只好把它给改回来了， 重启，在grub界面，按 ‘e'，进入grub编辑模式， 在kernel所在行按e，去掉其rhgb参数，并加上 runlevel=1 或 3，回车， 按 b 启动，启动完毕后，以root登陆，更改会原先的 xorg.conf， 问题解决。 另外，有些显卡如：nvida，如果带有rhgb参数，也会出现类似问题…… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ba107aa326a033f23132ea7a461fca/" rel="bookmark">
			ape &amp; cue plugin for xmms
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 here are their links: ape plugin: http://sourceforge.net/projects/mac-port/ both should be installed... mp3cue plugin: http://brianvictor.tripod.com/mp3cue.htm cueinfo plugin: http://www.student.lu.se/~nbi98oli/xmms-cueinfo.html either is ok... note: there is a small error of mac port, just delete the ";" at the end of line 9 in the file Assembly.h "your.path/mac-3.99-u4/src/MACLib/Assembly/Assembly.h" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba14289e2bb608cc5e816998308fc287/" rel="bookmark">
			ZZ: 从硬盘安装linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从硬盘安装RedHat Linux 9.0通常需要三个文件①shrike-i386-disc1.iso；②shrike-i386-disc2.iso；③ shrike-i386-disc3.iso。这代表了安装时需要的三张光盘。由于是映像文件，系统无法直接读取，所以需要先将ISO里的文件还原。
这里推荐大家使用Daemon Tool（http://www.linuxeden.com/download/winapps/daemon333.exe）这个Windows下的软件将ISO文件“解”到硬盘上。比方说shrike-i386-disc1.iso可以解压缩到C:盘的cd1目录，shrike-i386-disc2.iso解压缩到C:盘的cd2目录，shrike-i386-disc3.iso可以解压缩到C:盘的cd3目录待用。
接下来重新启动系统进入MS-DOS方式，进入我们刚才解压出来的C/cd1目录，里面有个dosutils目录，执行里面一个名为autoboot.bat的DOS批处理文件，系统就会再次重新启动，进入Linux的安装界面。这时安装程序就会提示你选择是用光盘安装还是从硬盘安装，选择从硬盘安装后，系统会提示输入安装文件所在的目录。
需要注意的是，我们刚解压缩的ISO文件是在Windows中操作的，如果直接输入c:/cd1，Linux安装程序是无法识别的，我们需要将c:/cd1对应到Linux安装程序能够识别的格式，因此这里应该输入的是/dev/hda1/cd1。
*********************************无软驱和光驱安装Redhat方法************************
无软驱和光驱安装Redhat方法 0. 软驱和光驱的硬件支持缺陷，只能靠软件来弥补，本文软件条件如下： (1) 系统中已经安装windowsxp，并以ntloader方式引导； (2) 拥有vfloppy和explore e2fs这两个软件(均是绿色/免费软件)； (3) Redhat Fedora Core 1的3个iso文件在c:/下，c盘为fat32格式。 1. 进入windows，建立如下文件(iso中没有的文件请用google.com搜索下载)： (1) c:/boot/rh10/loadlin.exe (即iso1中的/dosutils/loadlin.exe) (2) c:/boot/rh10/vmlinuz (即iso1中的/dosutils/autoboot/vmlinuz) (3) c:/boot/images/linux/bootdisk.img (即iso1中的/images/bootdisk.img) (4) c:/boot/images/dos/bootdisk.img (即vfloppy.exe带的那个img文件，或是win98启动盘的image文件) (5) c:/boot/vfloppy/vfloppy.exe (即vfloppy软件的主文件) (6) c:/boot/e2fs/explore2fs.exe (即explore e2fs软件的主文件) (7) c:/boot/e2fs/Diskio2.dll (即explore e2fs软件带的动态链接库) 2. 运行vfloppy，选择img时，选择1中的(3)，然后确定，可以生成 (1) c:/boot/BootDisk.bin (2) c:/boot/BootDisk.dsk (3) c:/boot/BootDisk.img 3. 重启机器，在ntloader的选择菜单中选择“由虚拟启动软盘启动”， 开始linux的安装 (1) 安装方式选择"从硬盘安装"，然后填入硬盘iso文件的位置； (2) 不创建单独的/boot分区； (3) 选择将grub装在"/"所在的分区，而非mbr分区； (4) 不创建启动软盘。 4. linux安装完毕后会重启，此次在ntloader的选择菜单中选择进入windows， 再次重复步骤2，只是选择img时选择1中的(4)，然后确定，可以重新生成 (1) c:/boot/BootDisk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba14289e2bb608cc5e816998308fc287/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b1eb678b58d9fa7ad65b6b9d822a5bf/" rel="bookmark">
			ZZ： grub管理器介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是启动管理器？ 启动管理器是存储在磁盘开始扇区中的一段程序，例如，硬盘的MBR(Master Boot Record)，在系统完成启动测试后，如果系统是从MBR启动，则BIOS(Basic Input/Output System)将控制传送给MBR。然后存储在MBR中的这段程序将运行。这段程序被称为启动管理器。它的任务就是将控制传送给操作系统，完成启动过程。 有许多可用的启动管理器，包括GNU GRUB (Grand Unified Boot Loader), Bootmanager, LILO (LInux LOader), NTLDR (boot loader for Windows NT systems)，等等。下面我将讨论GNU GRUB以及它的使用方法。 什么是GRUB? GRUB是一款功能强大的启动管理器，它能加载多种操作系统，例如Windows, DOS, Linux, GNU Hurd, *BSD,等等。 目前，LILO是最流行的启动管理器，被用来管理多个系统的引导。但是，如果使用了LILO，你必须记住，当你每次改变了它的配置或安装了新的内核，都要重新运行一下LILO。而且，LILO的灵活性也逊色于GRUB。 GRUB使用灵活。它的最新版本，0.5.96.1,支持的文件系统包括ext2(Linux使用的一种文件系统)，FFS(Fast File System used by *BSD UNIX)，ReiserFS(一种为Linux开发的新型日志文件系统，以被融入2.4.1内核中，minix(一种为MINIX系统开发的老式文件系统，在早期的Linux中也使用)。使用GRUB，你甚至不用引导操作系统，就能“看”到这些文件系统。例如，假如你想查看一下存放在文本文件中的日期和时间，而又不想引导整个操作系统，你可以使用GRUB shell（提示“grub&gt;”），键入如下命令： grub&gt; cat (partition number)/home/god/2003106110531.htm.txt. 你可以看到与文件有关的所有信息，包括日期和时间。 GRUB最好的应用是，你可以方便的引导不在列表中的任何分区上的任何内核。例如，如果你没有将新编译的内核加在启动列表中，而你又需要引导它，你可以将它先加在列表中，重新启动后使用。但是使用GRUB后，可以简单到只使用GRUB shell就可以加载所需要的内核映象。 现在我将解释使用GRUB的三个基本步骤：编译、安装和配置。 第一步：编译和安装GRUB 可以从ftp://alpha.gnu.org/pub/gnu/grub 下载GRUB的源代码。 可以用命令“tar -xvzf 2003106110531.htm.tar.gz”解开压缩文档。我得到的文件是grub-0.5.96.1.tar.gz，所以我这样做： # tar -xvzf grub-0.5.96.1.tar.gz 这个命令将解开的文件和目录放在一个名为grub-0.5.96.1的目录中。现在运行如下命令： [root@heaven ~/grub-0.5.96.1 ]# ./configure 如果你想定制GRUB，使之包含流行的文件系统和对网卡的支持，或者删除你不需要的网卡，可以运行如下命令： [root@heaven ~/grub-0.5.96.1 ]# ./configure --help 这个命令将输出所有的命令选项。现在可以使用―enable和―disable选项增加或删除对特定网卡的支持。（注意：GRUB支持网络启动） 为了开始编译过程，键入如下命令： [root@heaven ~/grub-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b1eb678b58d9fa7ad65b6b9d822a5bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22663496190e3e1065511c76582f31b3/" rel="bookmark">
			make xine play movie with Chinese subtitle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		get the "xine-lib" source code, untar the source pack, in directory misc, you can find xine-fontconv.c , compile it as follow: gcc xine-fontconv.c -o xine-fontconv `freetype-config --cflags --libs` -lz after then, we get xine-fontconv, so we can use it to generate our own fonts. the format as follow: ./xine-fontconv fonts.ttf fontsname [encoding [encoding] [encoding] ... ] for exampel: ./xine-fontconv /usr/share/fonts/zh_CN/TrueType/gbsn00lp.ttf gbsn cp936 gb2312 gbk big5 the above command will generate some font pack, just like gbsn-24.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22663496190e3e1065511c76582f31b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87249431db255a6acc0f78c4e94e113/" rel="bookmark">
			linux 下软件的安装和卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux 下软件的安装和卸载： RPM包： 1.如何安装rpm软件包 rmp软件包的安装可以使用程序rpm来完成。执行下面的命令 rpm -i your-package.rpm 其中your-package.rpm是你要安装的rpm包的文件名，一般置于当前目录下。 安装过程中可能出现下面的警告或者提示： ... conflict with ... 可能是要安装的包里有一些文件可能会覆盖现有 的文件，缺省时这样的情况下是无法正确安装的可以用 rpm --force -i 强制安装即可 ... is needed by ... ... is not installed ... 此包需要的一些软件你没有安装可以用 rpm --nodeps -i 来忽略此信息 也就是说，rpm -i --force --nodeps 可以忽略所有依赖关系和文件问题，什么包 都能安装上，但这种强制安装的软件包不能保证完全发挥功能 2.如何安装.src.rpm软件包 有些软件包是以.src.rpm结尾的，这类软件包是包含了源代码的rpm包，在安装时 需要进行编译。这类软件包有两种安装方法， 方法一： 1.执行rpm -i your-package.src.rpm 2. cd /usr/src/redhat/SPECS 3. rpmbuild -bp your-package.specs 一个和你的软件包同名的specs文件 4. cd /usr/src/redhat/BUILD/your-package/ 一个和你的软件包同名的目录 5. ./configure 这一步和编译普通的源码软件一样，可以加上参数 6. make 7. make install 方法二: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a87249431db255a6acc0f78c4e94e113/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75b2f1b187f03519256d2e3ef18edcaf/" rel="bookmark">
			中文输入法和字体添加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文输入法和字体添加： 输入法实现： 1. 用rpm -qa | grep 'inese'查看你的机器上是否安装了kde-i18n-Chinese和kde-i18n-Chinese-Big5两个语言包。没有的话，则从安装光盘那里找到后安装。 2. 安装一个输入法， SCIM 或者 fcitx 3. 配置~/.bashrc 或者 ~/.bash_profile 文件 添加下列语句,选用了那个输入法，就把哪个输入法前面的注释号去掉： # for input method fcitx #export XMODIFIERS="@im=fcitx" #export XIM=fcitx #export XIM_PROGRAM=fcitx #export GTK_IM_MODULE=Chinput #export QT_IM_MODULE=Chinput #fcitx&amp; #load fcitx # for input method Chinput #export XMODIFIERS="@im=Chinput" #export XIM=Chinput #export XIM_PROGRAM=Chinput #export GTK_IM_MODULE=Chinput #export QT_IM_MODULE=Chinput # for input method SCIM #export XMODIFIERS="@im=SCIM" #export XIM=scim #export XIM_PROGRAM=scim #export GTK_IM_MODULE=scim #export QT_IM_MODULE=scim #scim -d 字体添加： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75b2f1b187f03519256d2e3ef18edcaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/664c2b5228035ebacca1115c0b52bf07/" rel="bookmark">
			通过nfs挂装远程目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过NFS可以将远程主机的目录（ARP1：/ora1159）挂装（Mount）为本地主机的一个目录（ARP2：/home1），如同存取本机文件一样，存取远程主机的文件。具体设置包括远程主机和本地主机的设置：
1.远程主机
以root用户登陆ARP1。
确保portmap进程工作。运行命令
ps -aux|grep portmap
应显示portmap的进程信息。否则运行命令
/stc/rc.d/init.d/portmap start
修改/etc/exports文件，添加
/ora1159 ARP2(rw,root_squash) ARP3(rw,root_squash)
/ora1159为希望共享的目录名，ARP2和ARP3为希望挂装共享目录的主机名（或IP地址），选项rw表示挂装后该目录具有读写权限（也可设为ro，表示只读），选项root_squash表示挂装目录的机器root用户对该目录不具备写权限（否则为no_root_squash）。
启动或重启nfs守护进程。
/etc/rc.d/init.d/nfs start
或
/etc/rc.d/init.d/nfs stop
/etc/rc.d/init.d/nfs start
如果希望每次重启机器后都能保证远程主机目录都能挂装在本地主机上，应在远程主机上做两个符号链接。
ln -s /etc/rc.d/init.d/portmap /etc/rc.d/rc5.d/s18portmap
ln -s /etc/rc.d/init.d/nfs /etc/rc.d/rc5.d/s28nfs
2.本地主机
以root用户登陆（如RAP2或RAP3），启动portmap/etc/rc.d/init.d/portmap restart
创建一个远程主机目录的本地挂装点（即本地目录）。
mkdir /home1
修改/etc/fstab，添加如下一行
RAP1:/ora1159 /home1 nfs defaults 0 0
挂装远程目录，运行
mount -a
列出本地挂装点目录，查看是否远程目录。
ls /home1
注意
在本地主机上也可以通过autofs挂装远程目录。
nfs本身存在安全隐患，不要通过ssh对局域网以外的机器转发其通讯端口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba17010799e3d178759cd6cd7d0d57f3/" rel="bookmark">
			统计不固定栏目的工资年报的存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本存储过程成功实现行列转换统计
工资数据是竖表，即一个员工的工资对应多条工资栏目的记录
create or replace procedure prc_rs_gzndbb( p_table in varchar2) is
/*===================================================================================================
名称：prc_rs_gzndbb（procedure）
参数：传入：p_table varchar2
调用：PRC_YD_SHTZTJYH 返回：
功能：统计员工工资发放年度报表
返回：把统计结果插入p_table表中
作者：
编写时间：2005-2-21
修改人：
修改内容：
修改时间：
=====================================================================================================*/
v_lmmc varchar2(20);--栏目名称
v_sql varchar2(1000);
--定义取工资栏目的游标
cursor cur_lmmc is select distinct lmmc FROM tmp_gztjlsb; begin --定义动态SQL
v_sql:='select rydm,xm';
--遍历工资栏目并拼写成插入的SQL
for cur_lmmc_rec in cur_lmmc loop
v_lmmc:=cur_lmmc_rec.lmmc;
v_sql:=v_sql||','||'sum(decode(lmmc'||','''||v_lmmc||''',je))'||' '||v_lmmc; end loop; v_sql:=v_sql||' from tmp_gztjlsb group by rydm,xm';
execute immediate 'insert into '||p_table||' '||v_sql;
commit;
end prc_rs_gzndbb;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1ff09fdbac36fdef364d5159ec4eaa/" rel="bookmark">
			如何进行网站的压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何进行网站的压力测试 用 Microsoft Web Application Stress Tool 工具来解决这个问题。这是由微软网站测试人员所开发，专门用来进行网站压力测试的一套工具。安装后，使用少量的计算机就能仿真大量用户上线时，对网站服务造成的影响，这样就可以轻松找出系统潜在的问题，以便对系统做出进一步的调整。
下载地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fdce778ce8819548b48c257b8f89143/" rel="bookmark">
			Eclipse应用程序项目的打包与发行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当项目完成后接下来的就是打包发行了，应用程序（ Application ）项目和 Eclipse 插件项目（ plugin ）的打包是不同的，本章将分别介绍两者的打包方法，并给出实际的打包例子。 7.1 应用程序项目的打包与发行 7.1.1 简介 Java应用程序项目完成后是可以脱离Eclipse运行的，要运行程序先要打它打成一个JAR包，它打包的大部份方法和标准Java的AWT/SWING的打包方法一样，主要有以下几个要点
l MANIFEST.MF － 打包清单。它是打包的关键性文件，主要是设置执行入口类和支持库的路径，在运行Java应用程序时是要根据此文件中给出的信息来查找入口类和支持库。
l 支持包 －如果Java应用程序用到了一些Eclipse包，那么就必须将这些包也复制到程序运行目录，否则程序将无法运行。如swt组件支持包swt.jar，jface组件支持包jface.jar。这些包都要在MANIFEST.MF文件中设置好。
l 本地化文件 － 如果用到了SWT组件，则还需要将SWT的本地化文件swt-win32-3063.dll（3063是版本号）复制到程序运行目录，否则程序将无法运行。
7.1.2 打包的具体操作步骤 本节将用前几章开发的SWT/JFace项目“myswt”的打包为例，来介绍打包应用程序项目的方法。
1、编辑清单MANIFEST.MF （1）Eclipse提供了用于打包项目的“导出”向导，但本例运行此向导之前先需要创建一个MANIFEST.MF清单文件，其内容如下：
Manifest-Version: 1.0
Main-Class: book.chapter_4.wizard_dialog.WizardDialog1
Class-Path: ./lib/swt.jar ./lib/jface.jar ./lib/runtime.jar
说明：
l Manifest-Version － 指定清单文件的版本号
l Main-Class － 指定程序运行的入口类。本例设为运行4.5.2节开发的向导式对话框。注意：类名后不要加class扩展名
l Class-Path － 指定支持库的路径。“.”指程序运行目录，即导出的JAR包所在目录。程序运行时依据Class-Path项的设置路径来查找支持库。每一个支持库之间用空格隔开。在这里jface.jar需要用到runtime.jar包，所以runtime.jar包也要加入到Class-Path中。
l 除了入口类的包名和类名之外，其他设置项都不分大小写，比如：Class-Path写成class-path或CLASS-PATH也可以，swt.jar写成SWT.JAR也行。
（2）将清单文件保存下来，建议放在myswt项目的根目录下。它的文件名可以任意取，本例取名为manifes.txt，Eclipse向导在打包时会自动的将manifes.txt的内容复制到JAR包的META-INF目录下的MANIFEST.MF文件中。
2、使用Eclipse“导出”向导来打包项目
（1）右键单击myswt项目的项目名，在弹出菜单中选择“导出”。在弹出的如下图7.1所示的对话框中，选择“JAR文件”，单击“下一步”。
图7.1 导出对话框
（2）如下图7.2所示，将右边不需要的文件都取消勾选。在“选择导出目标”项文本框中设置JAR包的输出路径和包名（可以任意取名）为“D:/myswt_application/myswt.jar”。接受其他的默认设置不变，单击“下一步”。
附注：左边虽然选择了src目录，但源文件并不会导出到包中，除非勾选了“导出Java源代码文件和资源”项。
图7.2 选择导入文件
（3）如下图7.3所示，接受默认设置不变，单击“下一步”。
图7.3 导出类的选项
（4）这一步较关键。如下图7.4所示，选择“从工作空间中使用现有清单”项，将创建的清单文件输入，也可以通过旁边的“浏览”按钮来选择清单文件。输入清单文件后，单击“完成”，Eclipse开始将项目打包。
图7.4 清单文件设置
经过以上四步后，在“D:/myswt_application”路径下生成了一个名为“myswt.jar”的文件。myswt.jar是一个ZIP格式的压缩文件，可以用WinRAR或WinZip软件打开，也就是说用这两个软件也可以替代Eclipse向导来打包文件。如果用WinRAR来打包文件，则压缩格式要选择ZIP格式而非RAR格式，压缩率倒可以任意选。
用WinRAR打开myswt.jar文件后其内部的目录结构如下图7.5所示：
图7.5 myswt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fdce778ce8819548b48c257b8f89143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2831d5fa9da64f29111c4cce2b78567/" rel="bookmark">
			使用sqlldr装载数据的简单例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建测试表： create table DEMO ( DEPTNO NUMBER(2) not null, DNAME VARCHAR2(14), LOC VARCHAR2(13) );[@more@] 例子1：装载定界数据类型为csv(Comma-Separated Value)
C:sqlldr userid=scott/tiger control=load.ctl data=data.csv direct=y
load.ctl内容如下：
LOAD DATA INFILE * INTO TABLE DEMO TRUNCATE FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' (DEPTNO,
DNAME,
LOC
) 数据文件data.csv的内容如下：
"10","ACCOUNTING","NEW YORK"
"20","RESEARCH","DALLAS"
"30","SALES","""CHICAGO"""
"40","OPERATIONS","BOSTON"
"50","","Virginia"
"60",,"Virginia"
例子2：装载定界数据类型为tsv(制表符分隔)
C:sqlldr userid=scott/tiger control=load.ctl data=data.tsv direct=y
load.ctl内容如下：
LOAD DATA INFILE * INTO TABLE DEMO TRUNCATE FIELDS TERMINATED BY X'09'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2831d5fa9da64f29111c4cce2b78567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c09db3980d58e9e39cb2520dc20490e/" rel="bookmark">
			动动脑，大家轻松一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早上遇到一道趣味题，颇有意思，但未解决，一直搁到晚上，现在终于解决了。最近都没有动过脑子，一直机械的工作，人都老化了，现在拿出来轻松一下。
我把题目的大概意思描述一下：
某队有40人，其中骑马的30人，会摔跤的16人，会拳击的24人，会骑马和摔跤的14人，会摔跤和拳击的24人，会骑马和拳击的8人，问题这个队里会骑马、摔跤、拳击的人有多少(即三项全能)？
答案可能大家知道，但要写出推理过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aebfbd97147323779d490e3a5409a8e0/" rel="bookmark">
			SimpleDateFormat函数使用的例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class SimpleDateFormat extends DateFormat SimpleDateFormat 是一个以国别敏感的方式格式化和分析数据的具体类。 它允许格式化 (date -&gt; text)、语法分析 (text -&gt; date)和标准化。 SimpleDateFormat 允许以为日期-时间格式化选择任何用户指定的方式启动。 但是，希望用 DateFormat 中的 getTimeInstance、 getDateInstance 或 getDateTimeInstance 创建一个日期-时间格式化程序。 每个类方法返回一个以缺省格式化方式初始化的日期／时间格式化程序。 可以根据需要用 applyPattern 方法修改格式化方式。 SimpleDateFormat函数的继承关系：
java.lang.Object
|
+----java.text.Format
|
+----java.text.DateFormat
|
+----java.text.SimpleDateFormat
下面是个小例子：
import java.text.*;
import java.util.Date;
/**
SimpleDateFormat函数语法：
G 年代标志符
y 年
M 月
d 日
h 时 在上午或下午 (1~12)
H 时 在一天中 (0~23)
m 分
s 秒
S 毫秒
E 星期
D 一年中的第几天
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aebfbd97147323779d490e3a5409a8e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd85f4b56e8d6f4d7b9ee046c7fa228/" rel="bookmark">
			伪造IP包，禁止TCP连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家是否想过在局域网内如何禁止别人访问web server，pop3，ftp等。那么如何禁止呢？大家都知道TCP是面向连接的，连接时有三次握手，之后才能确认连接成功。那么我们就应该能在第一次握手之后伪造一个服务方的握手返回，从而达到TCP连接不成功，无法访问某端口。程序如下： void DeCodeIP(buf,iBufSize) //解析侦听到的IP数据包 { IPHEADER * pIPhdr; TCPHEADER * pTCPhdr; pIPhdr=(IPHEADER * )buf; //获得TCP header的起始位置 int iIphLen = sizeof(unsigned long) * (pIPhdr-&gt;h_lenver &amp; 0xf); pTCPhdr = (TCPHEADER* )(buf+iIphLen); //判断是否为第一次握手IP数据包，pIPhdr-&gt;th_flag=2 即("-s----") if (iBufSize==48) &amp;&amp; (pIPhdr-&gt;iProtocol==IPPROTO_TCP) &amp;&amp; (pIPhdr-&gt;th_flag==2) sendTCP_SYNACK(szDestIP,szSourceIP,pTCPhdr-&gt;destPort,pTCPhdr-&gt;srcPort,pTCPhdr-&gt;seq); } void sendTCP_SYNACK(char * szSrcIP, char * szDestIP,unsigned short srcPort,unsigned short destPort,unsigned int iAck) { int iErrorCode; SOCKET s; IP_HEADER ip_header; TCP_HEADER tcp_header; PSD_HEADER psd_header; struct sockaddr_in remote; char * ptr=NULL; //创建socket s=socket(AF_INET, SOCK_RAW, IPPROTO_IP); if (CheckSockError(s, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bd85f4b56e8d6f4d7b9ee046c7fa228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db841bcbec4e1a6af9fd0f232596e51/" rel="bookmark">
			获取数据库表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataSet ds=new DataSet();
System.Data.SqlClient.SqlConnection cnn=new System.Data.SqlClient.SqlConnection("server=(local);database=northwind;trusted_connection=yes") ;
cnn.Open();
System.Data.SqlClient.SqlCommand cmd=new System.Data.SqlClient.SqlCommand();
cmd.Connection=cnn;
cmd.CommandText="Select * from PersonDetails where 1&lt;&gt;1" ;
System.Data.SqlClient.SqlDataReader dr=cmd.ExecuteReader(System.Data.CommandBehavior.CloseConnection) ;
this.dataGrid1.DataSource=dr.GetSchemaTable();
cnn.Close();
dr.Close();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ccc6b823a85d81fcebf23aa1940484d/" rel="bookmark">
			用GDB调试程序（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看运行时数据
———————
在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：
print &lt;expr&gt;
print /&lt;f&gt; &lt;expr&gt;
&lt;expr&gt;是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），&lt;f&gt;是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。
一、表达式
print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函数等内容。可惜的是GDB不能使用你在程序中所定义的宏。
表达式的语法应该是当前所调试的语言的语法，由于C/C++是一种大众型的语言，所以，本文中的例子都是关于C/C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）
在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。
@
是一个和数组有关的操作符，在后面会有更详细的说明。
::
指定一个在文件或是一个函数中的变量。
{&lt;type&gt;} &lt;addr&gt;
表示一个指向内存地址&lt;addr&gt;的类型为type的一个对象。
二、程序变量
在GDB中，你可以随时查看以下三种变量的值：
1、全局变量（所有文件可见的）
2、静态全局变量（当前文件可见的）
3、局部变量（当前Scope可见的）
如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：
file::variable
function::variable
可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：
gdb) p 'f2.c'::x
当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::” 是否C++的操作符，所以你不必担心在调试C++程序时会出现异常。
另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU的C/C++编译器GCC，你可以使用“-gstabs”选项来解决这个问题。关于编译器的参数，还请查看编译器的使用说明文档。
三、数组
有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：
int *array = (int *) malloc (len * sizeof (int));
于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：
p *array@len
@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的：
(gdb) p *array@len
$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ccc6b823a85d81fcebf23aa1940484d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cabbdd4cd80a971f86b1082191b7a53/" rel="bookmark">
			Delphi中布尔类型辨析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Delphi中布尔类型辨析
苏涌(2000-09-29)
Delphi中预定义的布尔类型有四种：Boolean ，ByteBool，WordBool，LongBool。其中，Boolean 类型是首选布尔类型，其余三种是为其它编程语言和Windows 环境提供兼容性支持。这些布尔类型在使用上大同小异，但如果混淆使用将可能会有意外结果。 现做简单辨析供大家参考。 一、从资源占用的角度进行比较 一项Boolean 类型的数据占用 1字节的内存； 一项ByteBool类型的数据占用 1字节的内存； 一项WordBool类型的数据占用 2字节的内存； 一项LongBool类型的数据占用 4字节的内存。 如果开发者在进行程序设计时将构造一种含有布尔数据类型的结构类型，那么在资源占用方面将有所考虑。尽管这些数据类型之间是可以相互赋值的，但某些特殊情况下是有区别的。首先看下面的语句： type ByteBoolFile = file of ByteBool; LongBoolFile = file of LongBool; 这里，如果在这两中类型文件中存储相同数量的布尔值，其文件大小是不同的。而对同一物理文件按照这两种类型文件分别读取数据，其结果更是相去甚远。 下面是比较ByteBool和LongBool的一段程序，得到的文件 test1.bin和 test2.bin的文件尺寸分别为 4字节和16字节。 procedure CompareByteBoolWithLongBool; const FName1 = 'c: est1.bin'; FName2 = 'c: est2.bin'; type ByteBoolFile = file of ByteBool; LongBoolFile = file of LongBool; var BF: ByteBoolFile; LF: LongBoolFile; B: Boolean; begin B := False; AssignFile(BF, FName1); Rewrite(BF); Write(BF, B, B, B, B); CloseFile(BF); AssignFile(LF, FName2); Rewrite(LF); Write(LF, B, B, B, B); CloseFile(LF); end; 有兴趣的朋友可以在此基础上再比较一下读取数据的区别，你会有更奇特的发现。 二、从布尔值的操作角度进行比较 在Delphi中，布尔值只能被赋予预定义的常量True和 False之一。上述四种布尔数据类型有如下关系： Boolean ByteBool，WordBool，LongBool False &lt; True False &lt;&gt; True Ord(False) = 0 Ord(False) = 0 Ord(True) = 1 Ord(True) &lt;&gt; 0 Succ(False) = True Succ(False) = True Pred(True) = False Pred(False) = True 不难看出，Boolean 类型的有序的，而其它三种布尔数据类型是无序的。下面的程序给出了其中的部分区别： procedure CompareBooleanWithLongBool; var B: Boolean; LB: LongBool; begin B := False; LB := False; if Ord(B) = Ord(LB) then ShowMessage('Ord(B) = Ord(LB) [B = LB = False]') //将被执行 else ShowMessage('Ord(B) &lt;&gt; Ord(LB) [B = LB = False]'); B := True; LB := True; if Ord(B) = Ord(LB) then ShowMessage('Ord(B) = Ord(LB) [B = LB = True]') else ShowMessage('Ord(B) &lt;&gt; Ord(LB) [B = LB = True]'); //将被执行 ShowMessage('Ord(B) = ' + IntToStr(Ord(B)));　//一定是 1 ShowMessage('Ord(LB) = ' + IntToStr(Ord(LB)));　//可能是-1 end; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/320/">«</a>
	<span class="pagination__item pagination__item--current">321/321</span>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>