<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0ebddc46ad87efca8fe6c504630811/" rel="bookmark">
			如何使用ADB抓取pad上的日志并导出本地【windows】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：什么是ADB?
ADB是android sdk里的一个工具，用这个工具可以直接操作管理android模拟器或者真实的andriod设备(如G1手机).
2：ADB下载链接：
Windows版本：https://dl.google.com/android/repository/platform-tools-latest-windows.zip
Mac版本：https://dl.google.com/android/repository/platform-tools-latest-windows.zip
Linux版本：https://dl.google.com/android/repository/platform-tools-latest-linux.zip
3：环境变量配置，按键windows+r打开运行，输入sysdm.cpl，回车。
高级》环境变量》系统变量》path
将adb的存放路径添加进path中
4：两次确定之后在重新打开命令行进行校验是否安装成功，检查命令 adb 或者 adb --version
5：对应pad 操作
5:链接pad 输入命令adb devices 会显示当前链接设备名称
6：导出pad机器上的日志到电脑上
adb pull /sdcard/mtklog/file_tree.txt E:/rizhi
7：有限非中性的系统可能无法打开pad,可以使用当前命令直接打开系统设置页面
6:adb shell am start com.android.settings/com.android.settings.Settings 直接打开设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b76d6e3c829ff8ec88dd8ebaf192e33/" rel="bookmark">
			【已解决】Caused by: java.lang.ClassNotFoundException: org.springframework.boot.context.properties.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 最近小编在学习springcloud的项目知识，初出茅庐，跟着视频敲，发现不对劲。视频出的时间太早了，导致和现在的SpringBoot版本不一样，这是个头疼的问题，一个不小心就版本不兼容。击退你的学习信心的往往不是复杂的技术和业务，而是简简单单的环境版本问题。下面跟着小编一起解决问题吧！！
二、报错信息(省略部分) Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.cloud.context.properties.ConfigurationPropertiesBeans]: Factory method 'configurationPropertiesBeans' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/boot/context/properties/ConfigurationBeanFactoryMetadata at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) ~[spring-beans-5.3.10.jar:5.3.10] at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) ~[spring-beans-5.3.10.jar:5.3.10] ... 34 common frames omitted Caused by: java.lang.NoClassDefFoundError: org/springframework/boot/context/properties/ConfigurationBeanFactoryMetadata at org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration.configurationPropertiesBeans(ConfigurationPropertiesRebinderAutoConfiguration.java:56) ~[spring-cloud-context-2.1.3.RELEASE.jar:2.1.3.RELEASE] at org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$1b4f1aed.CGLIB$configurationPropertiesBeans$2(&lt;generated&gt;) ~[spring-cloud-context-2.1.3.RELEASE.jar:2.1.3.RELEASE] at org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$1b4f1aed$$FastClassBySpringCGLIB$$92bb4cd3.invoke(&lt;generated&gt;) ~[spring-cloud-context-2.1.3.RELEASE.jar:2.1.3.RELEASE] at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.3.10.jar:5.3.10] at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) ~[spring-context-5.3.10.jar:5.3.10] at org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$1b4f1aed.configurationPropertiesBeans(&lt;generated&gt;) ~[spring-cloud-context-2.1.3.RELEASE.jar:2.1.3.RELEASE] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_121] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_121] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_121] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_121] at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.3.10.jar:5.3.10] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b76d6e3c829ff8ec88dd8ebaf192e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdcd55c8530d11020a8f73ff6c4bf7c9/" rel="bookmark">
			腾讯云frp连接失败。login to server failed: dial tcp x:7000: connectex: A connection attempt failed because
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地址：https://github.com/fatedier/frp
简介：一个高效的反向代理：A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet.
最全面的官方教程文档：https://gofrp.org
自我记录： a、使用TCP代理，开启本地服务器的访问。 Linux服务器启动 frps
命令：nohup ./frps -c frps.ini（无挂起启动命令。可以自定义个shell脚本，避免每次切换目录，再启动）
配置：frps.init
[common] bind_port = 7000 token = 123456 Windows启动 frpc
CMD命令：frpc -c testzyh.ini
配置：testzyh.ini
C:\Users\Administrator\Desktop\frpjk&gt;frpc -c testzyh.ini
2022/01/25 14:18:15 [W] [service.go:86] login to server failed: dial tcp 124.223.72.221:7000: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdcd55c8530d11020a8f73ff6c4bf7c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd072ec244677ed36fbb51aad1ced86/" rel="bookmark">
			5.数据库完整性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
5.1实体完整性
5.1.1定义实体完整性
1.在列级定义主码
2.在表级定义主码
5.1.2实体完整性和违约处理
5.2参照完整性
5.2.1定义SC中的参照完整性：
5.2.2参照完整性检查和违约处理
5.3用户定义的完整性
5.3.1属性上的约束条件
1.属性上约束条件的定义
2.属性上约束条件的检查和违约处理
5.3.2元组上的约束条件
1.元组上约束条件的定义
2.元组上约束条件的检查和违约处理
5.4完整性约束命名子句
1.完整性约束命名子句
2.修改表中地完整性限制
5.5域中的完整性限制
5.6断言
1.创建断言的语句格式
2.删除断言的语句格式
5.7触发器
5.7.1定义触发器
5.7.2激活触发器
5.7.3删除触发器
数据库的完整性是指数据的正确性和相容性。数据的正确性是指数据是否符合现实世界语义、反映当前实际状况的；数据的相容性是指数据库同一对象在不同关系表中的数据是否符合逻辑。
数据的完整性是为了防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据。数据的安全性是保护数据库防止恶意破坏和非法存取。因此，完整性检查和控制的防范对象是不合语义的、不正确的数据，防止它们进入数据库。
为维护数据库的完整性，数据库管理系统必须能够实现如下功能。
1.提供定义完整性约束条件的机制
2.提供完整性检查的方法
数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。一般在INSERT、UPDATE、DELETE语句执行后开始检查，也可以在事务提交时检查。
3.进行违约处理
完整性定义和检查控制由关系数据库管理系统实现，不必由应用程序来完成，从而减轻了应用程序员的负担。
5.1实体完整性 5.1.1定义实体完整性 关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。对单属性构成的码由两种说明方法，一种是定义为列级约束条件，另一种是定义为表级约束条件。对多个属性构成的码只有一种说明方法，即定义为表级约束条件。
例如，将Student表中的Sno属性定义为码：
1.在列级定义主码 CREATE TABLE Student (Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) NOT NULL, Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20) ); 2.在表级定义主码 CREATE TABLE Student (Sno CHAR(9), Sname CHAR(20) NOT NULL, Ssex CHAR(2), Sage SMALLINT, Sdet CHAR(20), PRIMARY KEY(Sno)); 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbd072ec244677ed36fbb51aad1ced86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be09164b38b7712b60c3e1aed4d6ee33/" rel="bookmark">
			Postman安装(汉化Postman)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postman安装(汉化Postman) 一、下载Postman 下载地址：https://www.postman.com/downloads/
二、下载汉化包 下载地址：https://github.com/hlmd/Postman-cn/releases
注意：中文包的版本和postman的版本一定要一致，否则会出现汉化后打不开postman的情况
postman设置里能看到版本号：
汉化包下对应的就可以：
三、解压到对应目录 四、重启Postman、禁用自动更新 不禁用的话，后面中文汉化包会和postman版本对不上，出现问题。
后期试了这个自动更新按钮关闭了还是会自动更新，如果不想自动更新，windows直接删除安装目录的update.exe文件，这样会使你的电脑无法连接到postman下载服务器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b7ef3cd30480d9d535f6edb622be82/" rel="bookmark">
			vue项目打包后---TypeError: Cannot read properties of undefined (reading ‘echarts‘)问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 项目引入了echarts用来做中国地图，在本地cli跑的时候没有问题，但是build打包后会出现TypeError: Cannot read properties of undefined (reading 'echarts')。
原因 单独下载的echart中的china.js，项目中直接引用
import '../../assets/js/china.js' 打包后就会出现问题，不晓得是不是属于官方的bug
解决 用npm安装echarts
npm install echarts 然后引入echarts包中的china.js
import 'echarts/map/js/china.js' 再次打包，报错消失
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0a8cef9df8ee7e5478f4f4fe00d0d7/" rel="bookmark">
			如何远程访问办公室电脑（过年工作不打烊），亲测有效稳定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 让我们随时随地访问办公室的电脑，甚至只需要一部手机，办公不限制时间，地点，程序员也不用苦恼的去装环境，软件。
让我们高效率的远程协作开发。
我司电脑网络处于局域网中，有些公司路由器的wan端口是公网ip的话会更方便一点，那么，wan端口是公网ip如何访问？wan端口不是公网ip又如何解决？
一丶wan端口为公网ip step1丶登录路由管理界面
如何进入ip网关，查看路由器背面，写着有着管理地址或者网关的就是。
打开浏览器输入192.168.0.1(以自己路由器上的地址为准)。输入管理账号和密码就可以进入啦。
以tplink路由器为例，就可以看到下面的界面
这里可以看到我们wan端口的ip是192.168开头的，典型的局域网。那么如何判断自己是公网ip并且能使用呢？有个简单的办法，一般如何这个ip和你百度搜索关键词【ip】，如果和wan端口ip一致的话就可以去使用。
note:若不是公网ip直接看第二种方法
step2丶端口转发
点击左侧边栏【高级设置】-&gt;【地址转换】
这里可以看到我转换了两个地址，一个用于windows远程桌面访问，一个用于公司办公电脑搭建的http服务器。
点击新增就可以增加其他端口转换，我们来看一下如何添加，怎样填写
以windows远程桌面为例
预置设置：自定义
服务名称：rmtdp（可以自定义，在规则范围内就行）
外部端口：16531（填写一定要注意，不要填80或者443，一般这些都被占用或者禁用了）
内部端口：3389（windows远程桌面一般都为3389，如果你设置成其他端口了，修改为对应的端口就行了）
是否启用：启用
然后点击增加就行了！
这时就可以通过其他电脑，远程桌面连接，比如公网ip为 43.108.2.3，那么结合刚才设置外部端口**16531**，输入43.108.2.3:16531就可以了
note：注意注意注意！！！有些牌子的路由器管理界面，设置完毕了你会发现并没有生效，原因是你填写完毕之后一定要【保存和应用】,有些牌子可能显示的【启动】，那么点击相应的按钮就行了
二丶wan端口非公网ip 说明
外网访问内网，和刚刚的方式差不多，都需要一个中转站，现在比较流行的有某壳等等。但是呢，免费版的有流量限制和端口限制。
如果有钱的话就可以去购买他们的服务，作为一个苦逼的程序员，肯定还是要存着钱植发？？？
一般作为公司的话，要上线项目肯定是拥有服务器的，这时候我们就可以利用这台服务器搭建一个中转器服务器。
首先感谢ngrok的所有开发者和版权所有者，开源了1.x版本。
ngrok是什么？简单理解就是中转器，分为两端，服务端(server)和客户端(client)，服务端是要放在服务器上的，客户端放在公司电脑就行。
ngrok有免费版，下载就可以使用，但是呢，每次启动域名和端口都会变动，而且网速太慢，还有就是过段时间就会自动断掉，所以我们可以自己去搭建一个。
网速取决你云服务的带宽和公司的带宽。
官网地址：https://ngrok.com/
以阿里云的ecs，我这里装的Ubuntu18操作系统为例。
step1丶安装和运行中转器
打开电脑终端命令窗口
输入
ssh 用户名@阿里云ecs公网ip 回车，会提示输入密码。
step2丶然后安装必要的环境和库
1).安装go
ngrok基于go语言，所以要安装go环境
sudo apt install goalng 2).安装git
sudo apt install git 3).下载ngrok
git clone https://github.com/inconshreveable/ngrok.git 4).配置环境变量
cd cd ngrok export NGROK_DOMAIN="云服务器公网ip或者域名" note：ip或者域名主义不要加http或者https，使用域名的话要备案哦
5).生成自签名ssl证书
openssl genrsa -out rootCA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf0a8cef9df8ee7e5478f4f4fe00d0d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/503c0d332fd015d1bcb8718cb6fed176/" rel="bookmark">
			Windows搭建DHCP Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DHCP Server工具下载地址：下载|DHCP Server for Windows
此处以DHCP 服务器 V2.5.2为例在windows10上面配置DHCP Server，解压缩包，运行dhcpwiz.exe，进行安装配置，如下图所示：
点击“下一步”按钮，选择PC上要运行DHCP Server的网卡，如下图所示：
点击“下一步”按钮，可根据需要进行配置Http Server和DNS信息，如下图所示：
点击“下一步”按钮，如下图所示，可配置 IP 地址池，DHCP Server 动态分配给客户机地址的范围。选择DHCP Server的租约周期（30Minutes~1Year）。 如果需要配置 dhcp option 相关信息， 点击 DHCP Options ... 按钮， 如果不需要可以跳过；
点击 Advanced ... 按键配置子网掩码和网关等信息，配置完之后， 点击 OK 回到上一层配置界面；
点击“下一步”按钮，填写 INI 文件的保存路径， 如果之前配置过，勾选 Overwrite existing file 并点击 Write INI file 保存，
点击“下一步”按钮，勾选 Run DHCP server immediatly , 并点击 Admin... 按钮以管理员身份运行。
附：首次运行，需要先点击“Install”按钮
然后点击“start”按钮，运行DHCP Server。
然后将交换机连接PC和客户机，客户机即可根据DHCP协议动态获取到IP地址。
注： 配置完之后， 下次开机是默认自动运行的。 不想设置为自动运行的，右击“开始菜单”， 选择计算机管理 如下图。 在服务中查找 DHCP Server 改成 手动启动即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee146a6a04898ae1308e492503ef6ea/" rel="bookmark">
			基础opc协议介绍功能和使用测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Opc协议
很多客户再使用opc协议功能的时候说的很笼统，其实要具体使用起来还有一些细节需要确认。
1.1 OPC DA和OPC UA之分
首先，在具体的工程使用中有OPC DA和OPC UA之分。OPC DA协议出现较早，主要用在window操作系统上，需要在window系统上配置DCOM功能，使用起来非常繁琐，需要大量的参数配置，但是如果OPC的客户端和服务端在同一台电脑上，则不在需要配置DCOM，使用起来就方便了。但是很多场合，用户的电脑如果不允许在安装另外的OPC DA软件，则实现OPC DA的通信就非常麻烦了。
OPC UA是在DA的基础上进行了改进，不在局限在window平台上，可以跨系统通信，只要两边都是标准的OPC UA协议，则就可以正常通信。不需要在在电脑上安装软件。可以实现不同操作系统，不同设备之间的OPC UA通信。
1.2 服务器和客户端之分
OPC协议通信的两端一个是作为服务端，一边是客户端。服务端是等待客户端来连接，提供数据给客户端。客户端是主动连接服务端，获取服务端上的数据。因此首先要清楚对方是服务器还是客户端。
如果对方是服务端，则需要对方的IP地址，端口号，是否有数据加密，数据item等信息。
如果对方是客户端，我们就需要了解对方要获取什么数据，需要在什么网段，对服务端有什么要求。
2 协议测试
网上有很多OPC的测试小软件，用来对现有的OPC进行初步测试，以确认相关信息，确认系统是否可以连接和进行数据交换。先确认对方的opc是什么DA还是UA，是服务端，还是客户端。确认了，可以搜索opc clinet或者opc server查找相关的测试小软件。
3 协议的转换
OPC的协议用起来麻烦，在很多场合需要进行协议转换后进行设备的互联互通。比如把OPC UA转换modbus协议。或者把modbus协议的设备数据串口OPC 的系统。实现这些转换，可以使用协议转换网关来实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46646e0a1ec68693db7431d796d625ae/" rel="bookmark">
			Opc通信协议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Opc协议说明
OPC是一种利用微软的COM/DCOM技术来达成自动化控制的协定，
采用典型的C/S模式，
针对硬件设备的驱动程序由硬件厂商完成，提供统一OPC接口标准的Server程序，
软件厂商只需按照OPC标准接口编写Client程序就访问Server程序进行读写，即可实现与硬件设备的通信。
OPC协定包括：
DA(Data Access)规范：访问数据主要采用该规范
A&amp;E(Alarm and Event)规范：基于事件，提供Client端订阅，事件触发后Server端主动提交回数据的数据访问方式。
HDA(History data access)规范
OPC XML-DA规范
2 OPC UA
OPC UA(Unified Architecture)：OPC协定的新版，
不再拘束于COM/DCOM技术，意味着不再像传统的（Classic）OPC协定那样仅支持在Windows等平台上使用，具有跨平台性，同时OPC UA也使用了可靠的通信机制，接口简单一致。
比如：对传统的三种不同类型OPC服务器的访问 - 数据访问（DA）、报警和事件（AE）、历史数据访问（HDA），
要获得一个温度传感器的当前值、一个高温度事件和温度的历史平均值，要依次使用不同的命令执行；
而使用OPC UA，仅用一个组件就非常容易地完成了。配置和工程的时间也因此可以大大缩短。
3 OPC逻辑对象模型
包括３类对象：OPC server对象、OPC group对象、OPC item对象，每类对象都包括一系列接口。
OPC Server对象：
主要功能：
创建和管理OPC Group对象；
管理服务器内部的状态信息。
OPC Group对象：
主要功能：
管理OPC Group对象的内部状态信息；
创建和管理Items对象；
OPC服务器内部的实时数据存取服务（同步与异步方式）。
属性：
name：组的名字，由客户端自己定义。
active：组的激活状态，如果为false则组内全部Item将不再从数据源取数据，在客户端中的表现是读取不到数据，同时写数据也影响不到服务器端。
update rate：服务器向客户端提交变化数据的更新速率(这个数值应比服务器设定的最小值大)。
Percent Dead band：数据死区，即能引起数据变化的最小数值百分比。
OPC Item对象：
主要功能：
用来描述实时数据，代表了与服务器数据源的连接，而不是数据源。
一个项不能被OPC客户端访问，因此在OPC规范中没有对应于项的COM接口，所有对项的访问都需要通过OPC Group对象来实现。
属性：
name：项的名称，在服务器对应于Item ID。
active：项的激活状态。
value：项的数据值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46646e0a1ec68693db7431d796d625ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd7add821c44e87f607414e49143c19/" rel="bookmark">
			使用mysqladmin命令来修改mysql的root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般mysql的root默认密码为空，如果你之前并没有设置过root密码就使用mysqladmin命令，你可以使用如下mysqladmin命令来修改root密码
1
2
3
# mysqladmin -u root -p password 123456
Enter password : ******//输入新密码
# mysql -u root -p123456 //可以登录
如上所述使用mysqladmin第一次修改root的默认密码时，Enter password回车即可，然后使用mysql.exe命令输入root及其密码即可进入mysql命令行。
如果已设置了mysql的root密码了，现在需要修改密码并进入mysql命令行模式，则输入
1
2
# mysqladmin -u root -p123456 password root
# mysql Server 5.1\bin&gt;mysql -u root -proot
这里使用了到了mysql自带的两种命令mysqladmin和mysql，mysqladmin修改密码的命令格式如下
mysqladmin -u root -p[oldpass] password [newpass]
注意oldpass(老密码)可选，如果root默认密码为空，则不需要输入，如果需要更改老密码，请注意老密码与-p之间不要有空格，否则会报错，另外password和newpass(新密码)之间以空格分隔。
mysql命令与mysqladmin命令格式大同小异，主要用来输入正确的用户名和密码后进入mysql命令行模式，格式如下
1
mysql -u root -p[password]
如果不输入password，回车后会出现Enter password的提示。如果root密码为空，也不需要输入password，出现Enter password提示后回车即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac38026d50185c7b6505dc7a4945f5c3/" rel="bookmark">
			用最简单的方式来理解在单片机中的继电器的原理与接线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、电磁式继电器原理 1.电磁式继电器定义 单片机中用的比较多的是电磁式继电器，电磁式继电器一般由铁芯、线圈、衔铁、触点簧片等组成的。只要在线圈两端加上一定的电压，线圈中就会流过一定的电流，从而产生电磁效应，衔铁就会在电磁力吸引的作用下克服返回弹簧的拉力吸向铁芯，从而带动衔铁的动触点与静触点（常开触点）吸合。当线圈断电后，电磁的吸力也随之消失，衔铁就会在弹簧的反作用力返回原来的位置，使动触点与原来的静触点（常闭触点）释放。这样吸合、释放，从而达到了在电路中的导通、切断的目的。对于继电器的“常开、常闭”触点，可以这样来区分：继电器线圈未通电时处于断开状态的静触点，称为“常开触点”；处于接通状态的静触点称为“常闭触点”。 二、用最简单的方式理解继电器的原理与接线 如图所示，是我使用的的继电器的实物图，可以看到其产品规格，支持直流电也支持家用的220V的照明电。
输入端用DC+接的是直流电正极（交流电接火线），DC-接的是直流电负极（交流电接零线）。IN端为信号端，此继电器支持高低电平触发，利用跳线帽控制其为高电平触发或低电平触发。输出端COM为公共端，NO为常开触点，NC为常闭触点。
下图是我自己画的一个原理的简化图，画的比较简单粗暴，并没有结合原理图加以说明，只是讨论其最本质的原理。可以看到输入端连接电源控制线圈（由于此时线圈不吸引衔铁，图中没有画出IN信号端），在线圈没有磁力时，COM公共端与NC常闭触点相连。
当IN信号端发出信号触发电磁铁工作时（具体是高电平触发还是低电平触发根据实际情况），电磁铁工作，产生磁力，吸合衔铁，此时NO常开触点与COM公共端相连。
那么在实际使用中，我们应该如何接线呢？从以上内容可以看出，电磁铁的本质就是一个隔离开关，通过一个小信号来控制磁铁的吸合，达到控制开关开闭的目的。
假设我们要使用一个电子锁，通电上锁，断电解锁，接线方案如图所示：（假设我画的是个电子锁）
当IN信号没有触发线圈工作时，COM端与NC端相连，电子锁通电，正常工作（非上图情况）；当IN信号触发线圈工作时，COM端与NC端相连，电子锁断电，电子锁解锁（上图情况）。此时NC端与电子锁负极相连，处于悬空状态。
本文只是对单片机常用的电磁继电器的本质原理进行分析，没有与实际的原理图结合。另外，本人画功有限，请多包涵！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21081a1dfdb86794a03fed823ece093b/" rel="bookmark">
			6.STM32CubeMX学习笔记六：定时器与串口通信综合训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于sprintf(）函数的用法 sprintf()，指的是字符串格式化函数，把格式化的数据写入某个字符串中。
int sprintf(char *string, char *format [,argument,…]);
使用时需引入头文件 #include “stdio.h“
【例】：有一个表示温度的整型变量tmp，现在要将其格式化为字符串“温度是：XX摄氏度”，并将其通过串口1发送出去。
#include "stdio.h" uint8_t Str_buff[64]; //字符串缓存变量，用来放在第一个参数，接收新的格式化以后的字符 sprintf((char*)Str_buff, "温度是: %d摄氏度", tmp); HAL_UART_Transmit(&amp;huart1, Str_buff, sizeof(Str_buff), 0xFFFF); 练习：定时器与串口通信综合训练 在STM32F103ZET6开发板上，利用STM32CubeMX和Keil5协同开发，完成以下的功能：
【1】开机后，LED1与LED0依次点亮，然后熄灭，进行灯光检测，高电平点亮LED灯。
【2】系统通过串口1向上位机发送一个字符串“STM32F103欢迎你！”
【3】LED1作为一个秒闪灯，系统向上位机发送完字符串后，开始亮0.5
秒，灭0.5秒….循环闪烁，并启动系统运行时间的记录，其时分秒格式为 “XX：XX：XX”。
【4】上位机通过一个由3个字节组成的命令帧控制LED0灯的开关。
该命令帧的格式为 “0xBF 控制字 0xFB”。
0xBF为帧头，0xFB为帧尾，控制字的定义如下：
0xA1：打开LED0，返回信息 “XX:XX:XX LED0打开。”
0xA2：关闭LED0，返回信息 “XX:XX:XX LED0关闭。”
其他：返回信息 “XX:XX:XX 这个一个错误指令！”。
本练习为GPIO控制、定时器中断与串口通信的一个综合训练，第一部分可以直接通过GPIO控制，后两部分为串口通信和定时器的综合训练。
第一部分：STM32CubeMX的配置
本次练习利用的都是前期学过的知识配置方式与前面的GPIO控制，定时器和串口通信配置内容相同。
关于定时器中断和串口通信的原理，在前面的笔记有详细的理解，需要的请点击下面的链接：
4.STM32CubeMX学习笔记四：STM32的定时器开发基础
5.STM32CubeMX学习笔记五：STM32的串口通信基础
需要注意的几个地方：
【1】时钟树后面的时钟都是32MHz，这个频率关系到定时器参数的设置；按照32MHz，定时器的两个参数我们可以设置为499和31999，计数方式我们设置为向上计数。
【2】本次综合训练中定时器使用的是TIM2，串口使用的是USART1，串口的波特率设置为9600；
【3】定时器和串口处理好后一定要使能对应的NVIC通道。
第二部分：Keil5中代码的编写
【1】相关变量的定义
由于本次训练中，涉及到IO口电平控制，第一部分的流水灯可以直接通过翻转电平来实现，另外显示时间和串口传输的内容涉及到一些变量，以上操作每次都详细写出比较繁琐，先对此进行一下宏定义：
/* USER CODE BEGIN 0 */ #define LED1_ON() HAL_GPIO_WritePin(GPIOE,GPIO_PIN_5,GPIO_PIN_RESET) #define LED1_OFF() HAL_GPIO_WritePin(GPIOE,GPIO_PIN_5,GPIO_PIN_SET) #define LED0_ON() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,GPIO_PIN_RESET) #define LED0_OFF() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,GPIO_PIN_SET) #define LED1_TOG() HAL_GPIO_TogglePin(GPIOE,GPIO_PIN_5) #define LED0_TOG() HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_5) uint8_t str1[]="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21081a1dfdb86794a03fed823ece093b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9771703c65db5609e73b7119daf21fca/" rel="bookmark">
			最短路径问题——Floyd算法详解（所有顶点之间的最短路径）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任意两点间最短路径 与求单源最短路径不同，可以利用Floyd算法求任意两点之间的最短路径，这是源点就从单个确定的点变成了所有的点，即求每一个点到各个点之间的最短路径。
当然，我们也可以用dijkstra算法对每个顶点都循环一次，也可以求得任意两点间最短路。
弗洛伊德（Floyd）算法介绍： 设顶点vi 到顶点vk 的最短路径已知为D[i,k]，顶点vk 到vj 的最短路径已知为D[k,j]，顶点vi 到vj 的路径为D[i,j]，则vi 到vj 的最短路径为：min((D[i,k],D[k,j]),D[i,j])，vk 的取值为图中所有顶点，则可获得vi 到vj 的最短路径
至于vi 到vk 的最短路径D[i,k]或者vk 到vj 的最短路径D[k,j]，是以同样的方式获得
算法思想：
逐个顶点试探从Vi到Vj的所有可能存在的路径中选出一条长度最短的路径 求最短路径步骤：
第一步：初始时设置一个n阶方阵，令其对角线元素为0，若存在弧&lt;vi,vj&gt;,则对应元素为权值；否则为无穷大。
第二步：逐步尝试在原直达路径中增加中间顶点，若加入中间顶点后路径变短，则修改；否则，维持原值。所有顶点试探完毕，算法结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/795d2de09d62fe2d49e96f1a087dd705/" rel="bookmark">
			idea开发springboot项目时的自动编译和热部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.最好将idea的启动器设置一下，针对已有方法，增加方法参数，改变方法内容 2.开启自动编译 file &gt; settings &gt; Build,Execution,Deployment &gt; Compiler 勾选 Build project automatically 3.Crtl+Alt+Shift+/ 勾选 compiler.automake.allow.when.app.running
4、在dependencies 下添加 ，针对增加方法、添加类等情况：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;
5、在build &gt; plugins &gt; plugin 下添加 &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; 第四步有没有用我也没有试出来效果，添加第三步就会有效果了，但是这种设置会重启整个项目，可以放弃这种方式（和手动重启项目差不多）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dc47e40400e1b4daf5bcb56645655ba/" rel="bookmark">
			【Spring Cloud Alibaba】Nacos的简单介绍以及服务注册与发现功能的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos的简单介绍 Nacos（官网）致力于帮助您发现、配置和管理您的微服务。它提供了一组简单实用的功能，使您能够实现动态服务发现、服务配置管理以及服务和流量管理。
Nacos 让您构建更轻松、更快捷，您可以使用Nacos on Cloud或编译运行源代码来发布和管理微服务平台。它是支持采用微服务或云原生方法的以服务为中心的现代应用程序架构的基础设施。
Nacos 提供了四大功能 服务发现和服务健康检查: Nacos 使服务可以轻松注册自己并通过 DNS 或 HTTP 接口发现其他服务。Nacos 还提供服务的实时健康检查，以防止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。动态服务发现对以服务为中心的（例如微服务和云原生）应用架构方式非常关键。动态配置管理: 动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos消除了在配置更新时重新部署应用程序和服务的需要，这使得配置更改更加高效和敏捷。动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。Nacos 提供了一个简洁易用的UI (控制台样例 Demo) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。动态 DNS 服务: Nacos 支持加权路由，让您在数据中心内的生产环境中更轻松地实现中间层负载均衡、灵活的路由策略、流量控制和简单的 DNS 解析服务。它可以帮助您轻松实现基于 DNS 的服务发现，以消除耦合到厂商私有服务发现API上的风险。服务和元数据管理: Nacos 提供易于使用的可视化界面，帮助您管理服务元数据、配置、kubernetes DNS、服务健康和指标统计。Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。 Nacos 地图 （图片来自https://nacos.io/zh-cn/docs/what-is-nacos.html）
与Spring Cloud Alibaba的版本关系 Spring Cloud Alibaba版本关系：
本博客使用
Spring Boot 2.3.12
Spring Cloud Alibaba 2.2.7
nacos 2.0.3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dc47e40400e1b4daf5bcb56645655ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1810c0ab52454883b5c4d975e24fc531/" rel="bookmark">
			微服务之间调用方式@FeignClient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、微服务理解 个人理解：微服务的出现和流行并不是因为技术的原因，更多的是因为便于管理，将不同项目分作很多个服务，服务和服务之间再调用；
**原因:**在之前的项目都是大单体项目，项目用人多，修改模块自然也多，模块的部署时间等等要求也不同，所以拆分成不同的服务,每个团队各负责各的项目，就容易管理了。
就我所在团队使用的微服务，作为典型的一个SpringBoot微服务框架，从服务注册中心、服务配置中心、网关服务、以及服务集群中的服务，当然这里边的服务治理还包括，网关健康检查、负载均衡、容器云技术、熔断等的学习是有必要的。
二、微服务之间的最佳调用方式 服务和服务之间的沟通，相互调用就是一个重要的一环。
调用方式有俩中：RPC方式、事务驱动方式（消息发送方式包含事件通知、事件溯源）
**事件通知方式：**一个例子比如网购，我选购商品加入购物车，
动作1：商品进行结账(Checkout),生成一个结算动作的命令(Order Placed)发送
动作2：支付(Payment)动作收到消息后,接收用户信息(就是钱),服务完成后返回“支付收到”(Payment received)。
动作3：仓库的存货清单(Inventory)收到支付信息后，取货，并返回信息取货完成信息(Goods fetched)
动作4：接下来要运走货物，(shipment)得到取货成功信息后，发货，并返回信息给用户“商品已发货”(Goods shipped)。
RPC方式：搜罗其他博客找到的
三、总结 微服务之间的调用有两种方式，RPC和事件驱动,其中事件驱动分为事件通知和事件溯源。
事件驱动是更好的方式，因为它是松耦合的。
但如果业务逻辑是紧耦合的，RPC方式也是可行的（它的好处是代码更简单），而且你还可以通过选取合适的协议（Protobuf gRPC）来降低这种紧耦合带来的危害。
四、@FeignClient注解应用（RPC方式） 在开发微服务应用时，我们会在主程序入口添加 @EnableFeignClients 注解开启对 Feign Client 扫描加载处理。根据 Feign Client 的开发规范，定义接口并加 @FeignClients 注解。
当程序启动时，会进行包扫描，扫描所有 @FeignClients 的注解的类，并将这些信息注入 Spring IOC 容器中。当定义的 Feign 接口中的方法被调用时，通过JDK的代理的方式，来生成具体的 RequestTemplate。当生成代理时，Feign 会为每个接口方法创建一个 RequetTemplate 对象，该对象封装了 HTTP 请求需要的全部信息，如请求参数名、请求方法等信息都是在这个过程中确定的。
然后由 RequestTemplate 生成 Request，然后把 Request 交给 Client 去处理，这里指的 Client 可以是 JDK 原生的 URLConnection、Apache 的 Http Client 也可以是 Okhttp。最后 Client 被封装到 LoadBalanceclient 类，这个类结合 Ribbon 负载均衡发起服务之间的调用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0932926d090b96d6176125a337c832/" rel="bookmark">
			4.数据库安全性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
4.1数据库安全性概述
4.1.1数据库地不安全因素
4.1.2安全标准简介
4.2数据库安全性控制
4.2.1用户身份鉴别
1.静态口令鉴别
2.动态口令鉴别
3.生物特征鉴别
4.智能卡鉴别
4.2.2存取控制
1.定义用户权限，并将用户权限登记到数据字典中
2.合法权限检查
4.2.3自主存取控制方法
4.2.4授权：授予与收回
1.GRANT
2.REVOKE
3.创建数据库模式的权限
4.2.5数据库角色
1.角色的创建
2.给角色授权
3.将一个角色授予其他的角色或用户
4.角色权限的收回
4.2.6强制存取控制方法
4.3视图机制
4.4审计
1.审计事件
2.审计功能
3.AUDIT和NOAUDIT语句
4.5数据加密
1.存储加密
2.传输加密
4.6其它安全性保护
4.6.1推理控制
4.6.2隐蔽信道
4.6.3数据隐私
4.1数据库安全性概述 数据库地安全性时指保护数据库以防止不合法使用所造成地数据泄露、更改或破坏。
4.1.1数据库地不安全因素 1.非授权用户对数据库地恶意存取和破坏
2.数据库中重要或敏感地数据被泄露
为防止数据泄露，数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。此外，在安全性要求较高的部门提供审计功能，通过分析审计日志，可以对潜在的威胁提前采取措施加以防范，对非授权用户的入侵行为及信息破坏情况能够进行跟踪，防止对数据库安全责任的否认。
3.安全环境的脆弱性
4.1.2安全标准简介 计算机以及信息安全技术方面有一系列的安全标准，具有影响的当推TCSEC和CC这两个标准。
目前CC已经基本取代了TSCEC。
TCSEC又称桔皮书，分别从安全策略、责任、保证和文档4个方面来描述安全性级别划分的指标。
TCSEC/TDI将系统划分为4组7个等级
安全级别定义A1 验证涉及
B3安全域B2结构化保护B1标记安全保护C2受控的存取保护C1自主安全保护D最小保护 1）C1:该级只提供了非常初级的自主安全保护，能够实现对用户和数据的分离，进行自主存取控制（DAC），保护或限制用户权限的传播。
2）C2：该级实际上是安全产品的最低档，提供受控的存取保护，即将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离。
3）B1：标记安全保护。对系统的数据加以标记，并对标记的主体和客体实施强制存取控制MAC以及审计等安全机制。B1级别的产品才被认为是真正意义上的安全产品。
4）B2：结构化保护。建立形式化的安全策略模型，并对系统内的所有主体和课题实施DAC和MAC。
5）B3：安全域。该级的TCB（Trusted Computing Base）必须满足访问监控器的要求，审计跟踪能力更强，并提供系统回复过程。
6）A1：验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证，以确信各安全保护真正实现。
CC提出了目前国际上公认的表述信息技术性的结构，即把对信息产品的安全要求分为安全功能要求和安全保证要求。安全功能要求用以规范产品和系统的安全行为，安全保证要求解决如何正确有效地实施这些功能。安全功能要求和安全保证要求都以“类-子类-组件”地结构表述，组件是安全要求地最小构件块。
CC的文本由三部分组成：
1）简介和一般模型，介绍CC中的有关术语、基本概念和一般模型以及与评估有关的一些框架。
2）安全功能要求，列出了一系列类、子类和组件。由11大类、66个子类和135个组件构成。
3）安全保证要求，列出了一系列保证类、子类和组件。包括7大类、26个子类和135个组件构成。
CC评估保证级（EAL）的划分 评估保证级定义TCSEC安全级别（近似相当）EAL1功能测试EAL2结构测试C1EAL3系统地测试和检查C2EAL4系统地设计、测试和复查B1EAL5半形式化设计和测试B2EAL6半形式化验证的设计和测试B3EAL7形式化验证的设计和测试A1 4.2数据库安全性控制 数据库有关的安全性主要包括用户身份鉴别、多层存储控制、审计、视图和数据加密等技术。
4.2.1用户身份鉴别 用户身份鉴别是数据库管理系统提供的最外层安全保护措施。每个用户在系统中都有一个用户标识。每个用户标识由用户名和用户标识号（UID）两部分组成。UID在系统的整个生命周期内是唯一的。系统内部记录着所有合法用户的标识，系统鉴别是指由系统提供一定的方式让用户标识自己的名字或身份。每次用户进入系统时，由系统进行核对，通过鉴定后才提供使用数据库管理系统的权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe0932926d090b96d6176125a337c832/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/752833a8e3a3d1268c337a596d388a97/" rel="bookmark">
			RK3568-ANDROID11-4G-EC20-驱动篇（移远模块）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，要先获得技术支持
步骤一，先在USB模块上完成4G
步骤二，移植到PCIE座子上
磨刀不费砍材功，请先拿到技术文档支持，我的参考是：Quectel_Android_RIL_Driver_V3.3.62_master_beta(支持EC200A).tgz
主要文件：Quectel_Android_RIL_Driver_V3.3.62_master_beta(支持EC200A)\libquectel-ril\arm64-v8a\libreference-ril.so
主要文档：Quectel_Android_RIL_Driver_User_Guide_V2.0.pdf
//##//##//##//##//##//##//##//##//##//##//##//##//##//##//##//##//##//##//##//##//##
驱动部分：
1.增加4G控制驱动： A.用的驱动是kernel\drivers\net\lte\lte_rm310.c； B.\kernel\arch\arm64\configs\rockchip_defconfig; 本来就有的 CONFIG_LTE=y CONFIG_LTE_RM310=y C.device/rockchip/common/BoardConfig.mk #enable 3g dongle BOARD_HAVE_DONGLE ?= false ....... #for rk 4g modem -BOARD_HAS_RK_4G_MODEM ?= false +BOARD_HAS_RK_4G_MODEM ?= true #从false更改为true ifeq ($(strip $(BOARD_HAS_RK_4G_MODEM)),true) DEVICE_MANIFEST_FILE := device/rockchip/common/4g_modem/manifest.xml endif 2.增加驱动内容
\kernel\drivers\usb\serial\option.c static const struct usb_device_id option_ids[] = { #if 1 //Added by Quectel { USB_DEVICE(0x2C7C, 0x0125) }, /* Quectel EC20 R2.0/EC20 R2.1/EC25/EG25-G/EM05 */ { USB_DEVICE(0x2C7C, 0x0121) }, /* Quectel EC21/EG21-G */ { USB_DEVICE(0x2C7C, 0x0191) }, /* Quectel EG91 */ { USB_DEVICE(0x2C7C, 0x0195) }, /* Quectel EG95 */ { USB_DEVICE(0x2C7C, 0x0306) }, /* Quectel EG06/EP06/EM06 */ { USB_DEVICE(0x2C7C, 0x0512) }, /* Quectel EG12/EM12/EG18 */ { USB_DEVICE(0x2C7C, 0x0296) }, /* Quectel BG96 */ { USB_DEVICE(0x2C7C, 0x0700) }, /* Quectel BG95/BG77/BG600L-M3/BC69 */ { USB_DEVICE(0x2C7C, 0x0435) }, /* Quectel AG35 */ { USB_DEVICE(0x2C7C, 0x0415) }, /* Quectel AG15 */ { USB_DEVICE(0x2C7C, 0x0452) }, /* Quectel AG520R */ { USB_DEVICE(0x2C7C, 0x0455) }, /* Quectel AG550R */ { USB_DEVICE(0x2C7C, 0x0620) }, /* Quectel EG20 */ { USB_DEVICE(0x2C7C, 0x0800) }, /* Quectel RG500Q/RM500Q/RG510Q/RM510Q */	{ USB_DEVICE(0x1E0E,0x9001),//SIM8200EAM2 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/752833a8e3a3d1268c337a596d388a97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194e68f8bcc2e062d8ec72572815f871/" rel="bookmark">
			WPF如何获取已打开窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用Application.Current.Windows属性获取应用程序中实例化的窗口。
示例代码（获取窗体类名为MainWindow的已打开窗口）：
private void BtnTest_Click(object sender, RoutedEventArgs e) { foreach (Window window in Application.Current.Windows) { if (window.GetType() == typeof(MainWindow))//使用窗体类进行匹配查找 { //TODO } } } 记录一下供备忘，哈哈，好记性不如烂笔头！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50234692a9394b6616b8b1bb166cb386/" rel="bookmark">
			Qt学习之C&#43;&#43;基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 用了大概2个月的时间，学了Qt，然后开发一个小项目，总的来说，在主机GUI程序中，相比Java的Swing和JavaFX，个人感觉Qt的界面设计更加简便一点，灵活性更高一些，然后下边就主要简述一下Qt的基础知识。
学习一门语言，要学一下他的语法特色，Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。所以说他的本质语法还是C++。
Qt入门系列：
Qt学习之C++基础
Qt学习之Qt安装
Qt学习之Qt基础入门(上)
Qt学习之Qt基础入门(中)
Qt学习之Qt基础入门(下)
本文原创，创作不易，转载请注明！！！
本文链接
个人博客: https://ronglin.fun/archives/224
PDF链接：见博客网站
CSDN: https://blog.csdn.net/RongLin02/article/details/120594168
总述 首先先了解一下，C++的面向对象编程的基础语法。
参考资料：C++ 类 &amp; 对象
这里不过多的解释面向对象思想，而是主要说明C++的面向对象的编程语法，相较于Java的面向对象 的区别。
示例代码 首先C++面向对象一般会有两个文件，一个是.h文件，头文件用来存储一些定义声明之类的东西，一个是cpp文件，用来实现头文件的定义.用c++简单的创建一个Student类，开发工具用的是CodeBlocks，代码如下
Student.h #ifndef STUDENT_H #define STUDENT_H #define man 0 #define woman 1 #include &lt;string&gt; using namespace std; class Student { public: enum Degree { NoStudy=0,Primary = 1,Junior = 2,Senior = 3,University = 4 }; Student(); Student(string name,int age,int sex,Degree degree); virtual ~Student(); void setName(string name); void setAge(int age); void setSex(int sex); void setDegree(Degree degree); string getName(); int getAge(); int getSex(); Degree getDegree(); void printInfo(); protected: private: string name; int age = 0; int sex = man; Degree degree; }; #endif // STUDENT_H Student.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50234692a9394b6616b8b1bb166cb386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b7b06bc42c731c5265ef12ebe808e1d/" rel="bookmark">
			STM32 编码器驱动/旋转编码器旋钮encoder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已比较纯粹的方式介绍编码器和驱动的编写
编码器最少有两个输出信号，一种典型的结构如上图所示。AB是编码器的输出引脚。当触点和黄色的金属片接触的时候信号发生跳变沿，可以上上升沿也可以是下降沿，具体根据AB引脚默认的电平状态，和金属片电平状态。
当编码器转过一段角度后就会出现上图的波形。AB信号交替出现脉冲。上图所示的状态。B还在金属片上B是高电平,A已经不再金属片上恢复默认电平低。逆时针转动时，A触点比B触点先接触到金属片。所以A的高电平超前B的高电平。超前多少，根据金属片的长度和AB触点的间距决定。所以当顺时针转动的时候，B触点比A触点先接触到金属片。
根据这样的特点可以，从AB出现脉冲的先后可以判别出旋转的方向。脉冲的个数可以判断出转了多少角度。
实际波形
上通道为A，下通道为B
下图为正逆时针旋转
下图为顺时针旋转
对于数字输入输出的MCU来说，可以使用三种方式来实现编码器的驱动
1.GPIO抽样法 按照一定的时间间隔去采集AB触点的电平，根据电平的状态去判别脉冲计数。
上图所示，I:A出现低电平时，B是高电平。出现第一张图顺时针的状态。
II: B是低电平的时候，A是高电平，说明出现第二张图的状态。
抽样法关键在于测量到上述I，II的特征电平。抽样的时间需要根据旋转编码器的最快速度来进行设定，已保证能够采样到特征电平。
一般来说手工扭动的旋转编码器的采样间隔可以是1ms
代码如下，输入参数gpio1,gpio2为AB项的电平值。需要1ms为周期进行采样
encoder_poision_cnt 为脉冲计数器
encoder_dir 为方向
实验结果还不错，虽然看上去简单，但是其稳定性不错。
void task2_task(void *pvParameters) { while(1) { encoder_gpio_in = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10); encoder_gpio_in2 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11); encoder_dir = app_encoder_gpio_mes_test(encoder_gpio_in,encoder_gpio_in2); vTaskDelay(1); } } uint16_t app_encoder_gpio_mes_test(uint16_t gpio1,uint16_t gpio2) { static char lock=0; static uint16_t knob_dir =0; if((gpio1 == 0 &amp;&amp; gpio2 ==1)&amp;(!lock)) { lock =1; knob_dir= 1; encoder_poision_cnt++; } else if((gpio2 ==0 &amp;&amp; gpio1==1)&amp;(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b7b06bc42c731c5265ef12ebe808e1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d924aa54c4dca249747a68f0bd39ce87/" rel="bookmark">
			全面了解环保HJ212协议和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 环保HJ212协议介绍
环保HJ212协议是在环保行业中使用的数据传输协议。数据终端、采集终端、环保仪等终端设备把采集好的数据发送到环保平台使用这个协议。这个协议是环保行业的标准协议。所以实现了各种终端和平台之间的完美对接。只要符合协议标准的设备和平台，都可以互联互通。
协议定义：本标准适用于污染物在线监控（监测）系统、污染物排放过程（工况）自动监控系统与监控中心之间的数据传输，规定了传输的过程及参数命令、交互命令、数据命令和控制命令的格式，给出了代码定义，本标准允许扩展，但扩展内容时不得与本标准中所使用或保留的控制命令相冲突。本标准还规定了在线监控（监测）仪器仪表和数据采集传输仪之间的数据传输格式，同时给出了代码定义。
2 协议版本
212协议有两个版本，HJ 212-2005，HJ 212-2017。现在用的是HJ 212-2017。大部分设备和平台已经升级到最新版的协议。
3 系统架构
现场有一套或多套监控仪器仪表，监控仪器仪表具有数字输出接口，连接到独立的数据采集传输仪，上位机通过传输网络与数采仪进行通讯（包括发起、数据交换、应答等）
4 通讯协议的数据格式
HJ212协议是一种字符串协议，数据传输通讯包主要由包头、数据段长度、数据段、CRC校验、包尾组成，其中“数据段”内容包括请求编码、系统编码、命令编码、密码、设备唯一标识、总包数、包号、指令参数。请求编码为请求的时间戳，系统编码ST统一规定为22，命令编码CN为该数据包的时间类型，访问密码、设备唯一标识在对接时由平台提供，指令参数为数据内容。通讯协议的数据结构如图所示。
4.1 通讯包结构组成
4.2 数据段结构组成
5 数据样例
##0127QN=20210320163058511;ST=32;CN=2081;PW=123456;MN=81733553213013;Flag=4;CP=&amp;&amp;DataTime=20210320163058;RestartTime=20210320000006&amp;&amp;A781
##0457QN=20210320163101890;ST=32;CN=2011;PW=123456;MN=81733553213013;Flag=4;CP=&amp;&amp;DataTime=20210320013400;w00000-Rtd=181.682,w00000-Flag=N;w21001-SampleTime=20210320005400,w21001-Rtd=45.160,w21001-Flag=N;w21011-SampleTime=20210320013400,w21011-Rtd=1.970,w21011-Flag=N;w21003-SampleTime=20210320013400,w21003-Rtd=53.131,w21003-Flag=N;w01018-SampleTime=20210320013400,w01018-Rtd=194.200,w01018-Flag=N;w01001-SampleTime=20210320013406,w01001-Rtd=7.496,w01001-Flag=N&amp;&amp;6E80
##0596QN=20210320163106355;ST=32;CN=2051;PW=123456;MN=81733553213013;Flag=4;CP=&amp;&amp;DataTime=20210320155000;w00000-Cou=177.217,w00000-Min=292.286,w00000-Avg=295.361,w00000-Max=297.287,w00000-Flag=D;w21001-Cou=8.164,w21001-Min=46.070,w21001-Avg=46.070,w21001-Max=46.070,w21001-Flag=D;w21011-Cou=0.392,w21011-Min=2.214,w21011-Avg=2.214,w21011-Max=2.214,w21011-Flag=N;w21003-Cou=8.532,w21003-Min=48.145,w21003-Avg=48.144,w21003-Max=48.145,w21003-Flag=N;w01018-Cou=41.486,w01018-Min=234.100,w01018-Avg=234.100,w01018-Max=234.100,w01018-Flag=N;w01001-Min=7.551,w01001-Avg=7.556,w01001-Max=7.559,w01001-Flag=N&amp;&amp;42C0
##0457QN=20210320163113904;ST=32;CN=2011;PW=123456;MN=81733553213013;Flag=4;CP=&amp;&amp;DataTime=20210320013500;w00000-Rtd=181.682,w00000-Flag=N;w21001-SampleTime=20210320005400,w21001-Rtd=45.160,w21001-Flag=N;w21011-SampleTime=20210320013500,w21011-Rtd=1.970,w21011-Flag=N;w21003-SampleTime=20210320013500,w21003-Rtd=53.131,w21003-Flag=N;w01018-SampleTime=20210320013500,w01018-Rtd=194.200,w01018-Flag=N;w01001-SampleTime=20210320013506,w01001-Rtd=7.500,w01001-Flag=N&amp;&amp;8F81
6 上传数据分类
很多环境监控的应用的场合需要把各种终端的设备数据发送到环保局的平台，每种应用需要发送的数据是不同的。有的需要实时数据，有的需要分钟数据，小时数据，日数据等等。这个需要在数采仪上进行相应的配置。环保212协议的数传设备使用可配置以下参数。
7 深入学习
可参考HJ212-2017的协议文档。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/929c5aea1c446fae064ac374e44e4081/" rel="bookmark">
			typescript中的type关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		type定义： Type又叫类型别名（type alias）,作用是给一个类型起一个新名字，不仅支持interface定义的对象结构，还支持基本类型、联合类型、交叉类型、元组等任何你需要手写的类型。
type num = number; // 基本类型 type stringOrNum = string | number; // 联合类型 type person = {name: string}; // 对象类型 type user = person &amp; { age: number } // 交叉类型 type data = [string, number]; // 元组 type fun = () =&gt; void; // 函数类型 type和interface的异同： 相同点 1.都可以用来描述一个对象或者函数
interface
interface user {name: string; age:number}; // 对象 interface setUser {(name: string; age:number):void}; // 函数 type type user = {name: string; age:number}; // 对象 type setUser = (name: string; age:number):void;//函数 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/929c5aea1c446fae064ac374e44e4081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bfb3f152cabc99b5657d4f09d44e851/" rel="bookmark">
			杰卡德系数（Jaccard Index）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杰卡德系数（Jaccard Index） 杰卡德系数，又称为杰卡德相似系数，用于比较两个样本之间的差异性和相似性。杰卡德系数越高，则两个样本相似度越高。
定义 有两个集合A和B，那么这两个集合的杰卡德系数为A和B的交集除以A和B的并集。
当集合A，B都为空时，J(A,B)定义为1。
杰卡德距离是杰卡德系数的补集，用来描述两个集合的不相似度。杰卡德距离越大，两个样本相似度越低。
如有：
集合A={a,b,c,d,e}
集合B={a,b,f,g,h,i}
则：A∩B={a,b}，A∪B={a,b,c,d,e,f,g,h,i}。
杰卡德系数为2/9，杰卡德距离为1-2/9。
应用 比较两个集合是否相似，就是比较这两个集合共有元素的占比。因为集合具有互异性，集合中任意两个元素都是不同的对象，集合A中的任意一个元素在集合B中只有两种状态，即存在和不存在（或者可以理解为值是否相等，相等则存在），但无法衡量差异具体值的大小，只能获得“是否相同”这个结果，所以Jaccard系数只关心个体间共同具有的特征是否一致这个问题。因此，杰卡德系数可以用来计算非对称二元属性对象的相似性。
先了解几个基本概念：
数据集由数据对象组成。
一个数据对象代表一个实体。 数据库中行对应数据对象，列对应于属性。
二元属性：取值为0和1的属性，也称为布尔属性。
对称二元属性：属性两个状态值权重相同，比如性别的男和女。
非对称二元属性：属性两个状态值权重不同，比如HIV感染的阳性和阴性，阳性显然更重要些。
举个例子：
比较两部手机的差异，我们可以用一个n维向量来描述这部手机，比如手机有这些特征：1、是否国产 2、是否刘海屏 3、是否安卓系统 4、价格超过5000。我们用1来表示”是“，用0来表示”否“，那么：
手机A的向量为：{1,1,1,0}
手机B的向量为：{0,1,0,1}
这个向量的各个维度数据值可以当做一个集合，A和B的杰卡德系数为：J(A,B)=同维度且维度值相同的个数/总维度数=1/4。
还有一个很有意思的思路，把A和B的两个向量当做两个数组，那么每一列的最小值之和就是两个集合的交集，每一列的最大值之和就是两个集合的并集。
文本相似度
很多文章说杰卡德系数可以用来比较文本相似度，但是杰卡德系数只考虑文本所包含的词的比例，不能衡量词频的差异，所以文本的相似度计算还是余弦相似度更合适。
参考：
Jaccard Index
相似度计算之Jaccard系数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45ebda3310fad45836e2e09425d93b2/" rel="bookmark">
			Windows 运行 gpedit.msc进入本地组 没有权限问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows 运行 gpedit.msc进入本地组 没有权限问题 1. 管理员权限2. C盘隐藏文件夹显示3. 进入C:\Windows\System32目录下隐藏文件夹GroupPolicy4. 看该目录下 User 文件夹是否有东西，有的话，删除User 文件夹下的东西 ！！5. 管理员权限 win+R 打开，输入 cmd 打开命令行，在命令行输入 gpedit.msc计算机配置 --&gt; 管理模板 --&gt; 网络 --&gt; Lanman 工作站 --&gt; 启用不安全的来宾登录。 上述仅为本人PC的解决方案，不一定适用于所有计算机，仅提供一种方案。 转载链接： https://blog.csdn.net/weixin_42172619/article/details/106488367 1. 管理员权限 2. C盘隐藏文件夹显示 3. 进入C:\Windows\System32目录下隐藏文件夹GroupPolicy 4. 看该目录下 User 文件夹是否有东西，有的话，删除User 文件夹下的东西 ！！ 5. 管理员权限 win+R 打开，输入 cmd 打开命令行，在命令行输入 gpedit.msc 计算机配置 --&gt; 管理模板 --&gt; 网络 --&gt; Lanman 工作站 --&gt; 启用不安全的来宾登录。 上述仅为本人PC的解决方案，不一定适用于所有计算机，仅提供一种方案。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfae16110cacdf3285629e00d8d60405/" rel="bookmark">
			【计算机网络-自顶向下方法第7版】学习笔记分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#前言
这些都是笔主上课和复习时的手写笔记，笔主也只是一名大三的学生，做此纯属分享给有同等需要的人也作为自己学习的一个记录，如出现纰漏请联系qq1586725168
#
ps：如需要无水印pdf版本请私信笔主
#全部笔记就是这样，如果是电子科技大学的学生，那么这个可以直接当做考点来复习，笔记中的表达习惯和方式都是个人偏好，希望能帮助到大家，再见
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e0274eea24a54813b636d186551e31/" rel="bookmark">
			SIP协议-02 原理讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 SIP实现机制2 SIP网络元素2.1 用户代理2.2 代理服务器2.3 重定向服务器2.4 位置服务器2.5 注册服务器 3 SIP中的几个重要概念3.1 Messages(消息)3.2 Dialog(对话)3.3 Transaction(事务)3.4 Session(会话) 4 工作流程4.1 登记注册4.2 建立呼叫4.3 重定向呼叫 5 SIP超时机制5.1 INVITE客户端事务5.2 INVITE服务端事务5.3 非INVITE客户端事务5.4 非INVITE服务端事务 本节主要讲解下SIP协议的原理，以便更好的使用SIP的协议栈。
1 SIP实现机制 SIP是一个分层结构的协议，它的行为根据一组平等独立的处理阶段来描述，每个阶段之间是松耦合的关系。
SIP的最低层是其语法和编码。其编码使用扩充的背景 - 诺尔表单语法(BNF)指定。第二层是传输层。它定义了客户端如何发送请求和接收响应，以及服务器如何通过网络接收请求和发送响应。所有SIP元素都包含传输层。接下来是交易层。事务是由客户机事务(使用传输层)发送到服务器事务的请求，以及从服务器事务发送回客户机的对该请求的所有响应。用户代理客户端(UAC)完成的任何任务都使用一系列事务进行。无状态代理不包含事务层。交易层上方的图层称为交易使用者。除了无状态代理，每个SIP实体都是事务用户。 2 SIP网络元素 使用SIP建立通信网络，需要有一些实体的支持，本节主要介绍下这些实体都有哪些。在SIP中，每个网络元件由类似地址的 SIP URI (统一资源标识符)标识。
2.1 用户代理 用户代理（UA，User Agent）也称SIP终端，是指支持SIP协议的多媒体会话终端。一般使用支持SIP协议的路由器作为SIP UA。UA 包括用户代理客户端（UAC，User Agent Client）和用户代理服务器（UAS，User Agent Server）。一般说的 UA 均是指二者的总称，因为在一次呼叫中，一个 SIP 终端既要处理 SIP 请求，又要发起SIP请求。
用户代理客户端(UAC) 是指在 SIP 会话建立过程中主动发送会话请求的设备。例如，主叫SIP终端。当代理服务器向被叫终端发送会话请求时，它就成为用户代理客户端。
用户代理服务器(UAS) 是指在 SIP 会话建立过程中接收会话请求的设备。例如，被叫 SIP 终端。当代理服务器接收主叫终端发送会话请求时，也作为用户代理服务器。
例如：SIP基于客户端 - 服务器架构，其中呼叫者的电话充当发起呼叫的客户端，并且被叫者的电话充当响应呼叫的服务器。
2.2 代理服务器 代理服务器（Proxy Server）的作用就是传递主叫 UA 发送的会话请求到被叫 UA，然后将被叫 UA的响应传递回主叫 UA，它相当于主叫 UA 和被叫 UA 之间传递会话消息的路由。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8e0274eea24a54813b636d186551e31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b5ea011a04dc2babd84ccd44f53ae1/" rel="bookmark">
			Nginx报错404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用nginx作为后端统一路径的转发，未使用nginx代理的原先地址可以正常访问，使用nginx进行统一路径转发时，postman报了如下错误：
&lt;html&gt; &lt;head&gt; &lt;title&gt;404 Not Found&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;404 Not Found&lt;/h1&gt; &lt;/center&gt; &lt;hr&gt; &lt;center&gt;nginx/1.17.3&lt;/center&gt; &lt;/body&gt; &lt;/html&gt; 造成这种404路径找不到的原因是nginx默认端口是80，而我本机的80端口已被占用，在nginx.conf文件中，将nginx默认的80端口修改为未被使用的端口即可！
server { listen 81; //------------------------------我这里是将原本默认的80端口改为了81，问题完美解决！ server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0188d0632a1d2490b7aeaca9e875ce/" rel="bookmark">
			使用Spring Boot Admin实现运维监控平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 我们知道，使用Actuator可以收集应用系统的健康状态、内存、线程、堆栈、配置等信息，比较全面地监控了Spring Boot应用的整个生命周期。但是还有一个问题：如何呈现这些采集到的应用监控数据、性能数据呢？在这样的背景下，就诞生了另一个开源软件Spring Boot Admin。下面就来介绍什么是Spring Boot Admin以及如何使用Spring Boot Admin搭建完整的运维监控平台。 我们知道，使用Actuator可以收集应用系统的健康状态、内存、线程、堆栈、配置等信息，比较全面地监控了Spring Boot应用的整个生命周期。但是还有一个问题：如何呈现这些采集到的应用监控数据、性能数据呢？在这样的背景下，就诞生了另一个开源软件Spring Boot Admin。下面就来介绍什么是Spring Boot Admin以及如何使用Spring Boot Admin搭建完整的运维监控平台。
一、什么是Spring Boot Admin Spring Boot Admin是一个管理和监控Spring Boot应用程序的开源项目，在对单一应用服务监控的同时也提供了集群监控方案，支持通过eureka、consul、zookeeper等注册中心的方式实现多服务监控与管理。Spring Boot Admin UI部分使用Vue JS将数据展示在前端。
Spring Boot Admin分为服务端（spring-boot-admin-server）和客户端（spring-boot-admin-client）两个组件：
spring-boot-admin-server通过采集actuator端点数据显示在spring-boot-admin-ui上，已知的端点几乎都有进行采集。spring-boot-admin-client是对Actuator的封装，提供应用系统的性能监控数据。此外，还可以通过spring-boot-admin动态切换日志级别、导出日志、导出heapdump、监控各项性能指标等。 Spring Boot Admin服务器端负责收集各个客户的数据。各台客户端配置服务器地址，启动后注册到服务器。服务器不停地请求客户端的信息（通过Actuator接口）。具体架构如下图所示。
上图为Spring Boot Admin的整体架构，在每个Spring Boot应用程序上增加Spring Boot Admin Client组件。这样每个Spring Boot应用即Admin客户端，Admin服务端通过请求Admin客户端的接口收集所有的Spring Boot应用信息并进行数据呈现，从而实现Spring Boot应用监控。
二、使用Spring Boot Admin搭建运维监控平台 下面就通过示例，演示如何使用Spring Boot Admin 搭建运维监控平台。
1、创建服务器端 Spring Boot Admin服务器端主要负责收集各个客户的数据。建立一个Spring Boot Admin服务器端只需要简单的两步。下面通过示例演示创建Spring Boot Admin服务器端的过程。
1. 配置依赖
创建新的Spring Boot项目，在新建的项目中添加Spring Boot Admin服务器端的依赖JAR包：spring-boot-admin-starter-server。
&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf0188d0632a1d2490b7aeaca9e875ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283c0223e36d40f18ba916aeb2d1b326/" rel="bookmark">
			koa2中使用http-proxy-middleware和koa-bodyparser
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在研究 node.js 代理方面的内容，希望借助代理实现 mock 文件的自动生成，这个后面会写篇文章集中介绍，本篇先汇总下在 koa2 中使用 http-proxy-middleware ，至于为什么选择 http-proxy-middleware 作代理，因为 Vue CLI 就用的 http-proxy-middleware ，这样大家理解配置就更加方便了。
koa2 中使用 http-proxy-middleware 和 koa-bodyparser 首先引入 koa 和 http-proxy-middleware：
const Koa = require("koa"); const { createProxyMiddleware } = require("http-proxy-middleware"); const app = new Koa(); 接下来查看 http-proxy-middleware Express 示例，我把改成 koa 之后如下：
app.use( "/api", createProxyMiddleware({ target: "...", changeOrigin: true, }) ); 但程序运行之后会报错，提示 next is not a function 等之类的报错，Express 中没有 next，所以肯定会报，那要怎么解决？
这个时候我们借助另一个插件：koa-connect，或者查看 每天一个npm包：koa-connect，koa-connect作用就是在 Koa2 中可以使用 Express 社区的中间件，起到了一个中转或者适配的作用。修改之后代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283c0223e36d40f18ba916aeb2d1b326/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2868b3ea6c1b631f78a7bba5074fde84/" rel="bookmark">
			什么是闭包，闭包详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是闭包: 闭包是一个存在内部函数的引用关系。 该引用指向的是外部函数的局部变量对象(前提是内部函数使用了外部函数的局部变量) 闭包的作用： 延长外部函数变量对象的生命周期 使用闭包能够间接的从函数外部访问函数内部的私有变量 一、常见的闭包
function outer() { var a = 1 function inner() { console.log(a) //1 } inner() } outer() 二、实例详解
function createFunc() { var result = new Array() for (var i = 0; i &lt; 10; i++) { result[i] = function () { console.log(i) } } return result } var result = createFunc() result[0]() //10 result[1]() //10 result[2]() //10 result[3]() //10 result[4]() //10 result[5]() //10 result[6]() //10 result[7]() //10 首先在代码执行前，会先创建一个全局的对象，其中包含着全局的属性，并且将其放入全局上下文作用域链顶端，并且也将其放入每一个函数的作用域链顶端。以这个例子为例。如图所示 在初始化结束后，开始执行代码，此时就会创建一个新的对象，叫做Active Object,其中放入一些参数，并且将其压入createFunc函数的作用域链中。 因为在createFunc中仍然定义函数result[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2868b3ea6c1b631f78a7bba5074fde84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4beda1a522ccba79731089aa1900ca/" rel="bookmark">
			pytorch：.cuda() &amp; .cpu() &amp; .data &amp; .numpy()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch：.cuda() &amp; .cpu() &amp; .data &amp; .numpy()
GPU中的Variable变量： a.cuda().data.cpu().numpy()
GPU中的tensor变量： a.cuda().cpu().numpy()
CPU中的Variable变量：
a.data.numpy()
CPU中的tensor变量：
a.numpy()
总结：
.cuda()是读取GPU中的数据
.data是读取Variable中的tensor
.cpu是把数据转移到cpu上
.numpy()把tensor变成numpy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe42796030871cf3ec9228f2ecd246ae/" rel="bookmark">
			git SSH免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git系列文章目录 第八章 git SSH免密登录的使用 文章目录 git系列文章目录前言一、生成密钥二、使用步骤1.使用VSCODE打开.pub文件复制其中的内容2.打开github或者gitee进入设置选项设置密钥3.使用密钥 总结 前言 虽然Windows系统提供了凭据功能，但是介绍ssh提交，的免密操作 一、生成密钥 进入当前用户的目录
双击打开或者命令方式
Apple@DESKTOP-ECLNIU2 MINGW64 ~/Desktop $ cd ~ Apple@DESKTOP-ECLNIU2 MINGW64 ~ $ pwd /c/Users/Apple Apple@DESKTOP-ECLNIU2 MINGW64 ~ $ 然后在当前文件夹下创建SSH 密钥
Apple@DESKTOP-ECLNIU2 MINGW64 ~ $ ssh-keygen -t rsa -C 18261897435@139.com Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/Apple/.ssh/id_rsa): Created directory '/c/Users/Apple/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/Apple/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe42796030871cf3ec9228f2ecd246ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa57974ea854015ff645d12a1b19e7a/" rel="bookmark">
			搭建 IPv6 Web服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无线路由坏了，无奈先直连光猫凑合，无聊点了下测试网站 ，这下打开了IPv6 的大门。一直以来我还以为个人电信光纤不支持的 IPv6的，结果是垃圾路由限制了我的想象，感觉耽误很多年。
前提： a. 访问测试网站 test-ipv6.com 结果是 10/10， 网线直插光猫 的1口或4口是可以的，连接光猫的WiFi居然不行？
b. 基本的 IPv4 IPv6 常识了解一下，端口了解一下: 从Ping开始：( windows命令行里 ping -6 就是强制使用 ipv6，linux 是 ping6 )
Ping -6 www.sina.com 可怜新浪沦为测试站，因为百度Ping不通 可以看到 240e:d9:a003:400:3::3fd 就是新浪的 IPv6 地址 ，于是就可以试试
Ping -6 [240e:d9:a003:400:3::3fd] 这里中括号不是必需的，习惯加上吧，因为浏览器里需要。
然后把这个IPv6地址 贴到浏览器地址栏 ，试试？
可能网站没有进行相关设置，页面显示403不是404说明网络还是通的。
找了一个 B站视频，小哥讲得很接地气，无耻搬运下
。
实战： 强调一下，test-ipv6.com 结果是 10/10，页面能看到自己的 IPv6 地址
Windows下面搭建Web服务器 IIS 是首选，不过设置略麻烦。
装个 Python3.10， 然后一行命令就齐活： python -m http.server 赶紧找个朋友访问下自己的网站吧： 注意，中括号里需要替为是自己的地址，默认端口8000
[240e:d9:a003:400:3::3fd]:8000 什么。。。没有朋友？手机关掉 wifi 也是外网了，也可以试。
长期用还是 IIS 吧，这个Python简单是简单，经常无响应，重新跑一次又好了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fa57974ea854015ff645d12a1b19e7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fd09fe6db79000dd61682417a20dd93/" rel="bookmark">
			物联网MQTT简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物联网曾被认为是继计算机、互联网之后，信息技术行业的第三次浪潮。随着基础通讯设施的不断完善，尤其是 5G 的出现，进一步降低了万物互联的门槛和成本。物联网本身也是 AI 和区块链应用很好的落地场景之一，各大云服务商也在纷纷上架物联网平台和服务。
物联网通讯是物联网的一个核心内容，目前物联网的通讯协议并没有一个统一的标准，比较常见的有MQTT、CoAP、DDS、XMPP 等，在这其中，MQTT（消息队列遥测传输协议）应该是应用最广泛的标准之一。目前，MQTT 已逐渐成为 IoT 领域最热门的协议，也是国内外各大物联网平台最主流的传输协议，阿里云 IoT 物联网平台很多设备都是通过 MQTT 接入。
1、MQTT 简介 《MQTT 协议规范中文版》一书中对 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）进行了描述：
MQTT 是一种基于客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、 简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）。----MQTT 协议中文版
与 HTTP 协议一样，MQTT 协议也是应用层协议，工作在 TCP/IP 四层模型中的最上层（应用层），构建于 TCP/IP协议上。MQTT 最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。
如今，MQTT 成为了最受欢迎的物联网协议，已广泛应用于车联网、智能家居、即时聊天应用和工业互联网等领域。目前通过 MQTT 协议连接的设备已经过亿，这些都得益于 MQTT 协议为设备提供了稳定、可靠、易用的通信基础。
2、MQTT 的主要特性
MQTT 协议是为工作在低带宽、不可靠网络的远程传感器和控制设备之间的通讯而设计的协议，它具 有以下主要的几项特性：
①、使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。
②、基于 TCP/IP 提供网络连接。主流的 MQTT 是基于 TCP 连接进行数据推送的，但是同样也有基于 UDP 的版本，叫做 MQTT-SN。
③、支持 QoS 服务质量等级。根据消息的重要性不同设置不同的服务质量等级。
④、小型传输，开销很小，协议交换最小化，以降低网络流量。这就是为什么在介绍里说它非常适合"在物联网领域，传感器与服务器的通信，信息的收集"，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了，在手机移动应用方面，MQTT 是一种不错的 Android 消息推送方案。
⑤、使用 will 遗嘱机制来通知客户端异常断线。
⑥、基于主题发布/订阅消息，对负载内容屏蔽的消息传输。
⑦、支持心跳机制。
3、MQTT 历史
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fd09fe6db79000dd61682417a20dd93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbcd031175d5be2fd432c3470a7296da/" rel="bookmark">
			Windows Server Core 2022 （二）跑个 IIS 先
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ServerCore2022 跑起来了，那么先来个IIS简单练练手：（ 从实用讲，Core是可以安装 Python的，然后 http.server 就可以跑Web服务器了，不过微软全家桶也不是盖的，试试就试试呗）
AdminCenter 里安装更直观，看下图：（老路数是用带GUI的Server2022， RSAT连接并管理 “CORE2022” ，很愉快在右边找到 “IIS”，然后进入类似本地“IIS 管理器”这样的界面。Windows10/11 多一个步骤，后面说）
到这时 ，浏览器输入IP应该就可以看到 IIS 默认起始页了。注意因为要用IPv6，而ISP默认屏蔽80端口，所以一旦改端口要注意防火墙，不然呢那就是不通啊。为调试简单可以暂时关闭防火墙 ：
netsh advfirewall set allprofiles state off
------------------------------------------------------------------------------------------------------------
当然没这么简单，肯定有些障碍才符合身份。
因为是Core，本地管理IIS异常艰难（完全用命令行也不是不能，只是难受）。用“IIS 管理器” 远程管理IIS需要 Core2022上找到 Web Managment Service / WMSVC 服务，安装、启动并设置为自启。
Install-WindowsFeature Web-Mgmt-Service (非必须，启用IIS角色时已经安装了该服务)
Set-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\WebManagement\Server -Name EnableRemoteManagement -Value 1 （实测必须）
关于这个服务的设置，可以在 AdminCenter / RSAT 图形界面里操作。或命令行里设置：
单次启动 CMD: net start wmsvc
开机自动启动 CMD: sc config wmsvc start= auto (PS里会报错)
------------------------------------------------------------------------------------------------------------
大明江山高墙内。。。都是局域网。玩Web怎么能不知道番强和DDNS呢。
首先需要一个域名，有很多选择，dynv6.com 实测可以免费获得二级域名。（我其他文章有提到）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbcd031175d5be2fd432c3470a7296da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9771473d2cc5f9e97ec0bfee335699c/" rel="bookmark">
			记一次pip安装部分依赖报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WARNING: The script faker is installed in ‘/home/kali/.local/bin’ which is not on PATH.
Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
WARNING: The scripts poc-console and pocsuite are installed in ‘/home/kali/.local/bin’ which is not on PATH.
Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
在终端中输入：
export PATH=$PATH:/home/kali/.local/bin 点击回车，然后输入：
echo $PATH 这将打印出 PATH 变量，然后你应该会看到你的 /home/kali/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9771473d2cc5f9e97ec0bfee335699c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46bbfd2c8997958781fa28c101442fd/" rel="bookmark">
			算法基础——DFS与BFS模板总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、DFS1.数字排列2.n皇后问题 二、BFS1.走迷宫2. 八数码 总结 前言 今天，利用周末时间对先前算法基础课的学习进行回顾，在挑战模式中我还是卡住了，有的模板题感能写出来，有印象但就是不能完整的实现。自己惩罚自己每题敲十遍！
本篇文章是针对搜索与图论章节中的DFS与BFS模板题的再回顾与精简的总结！
一、DFS 注意搜索的顺序；当搜到叶子节点（递归结束）时就回溯，回退一步看一步
1.数字排列 【题目链接】842. 排列数字 - AcWing题库
经典全排列问题，搜索与回溯！
【核心代码如下】：
int a[N]; bool st[N]; void dfs(int u) { if(u &gt; n)//递归出口 { display(); return ; } for(int i = 1; i &lt;= n; i ++)//搜索顺序（枚举所有可能） { if(!st[i]) { a[u] = i; st[i] = true; dfs(u + 1); st[i] = false;//恢复现场 } } } dfs(1); 2.n皇后问题 【题目链接】845. 八数码 - AcWing题库
直线方程y=x+b由截距得出对角线：y-x+n防止负数出现，反对角线：y+x。从每一行开始搜索，看看哪一列上的位置合适。
【核心代码如下】：
char g[N][N]; bool col[N], ug[N], ung[N];// 列、对角线、反对角线 void dfs(int u) { if(u &gt; n)// 递归出口 { display(); return ; } for(int j = 1; j &lt;= n; j ++) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46bbfd2c8997958781fa28c101442fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7020aafe86c1e42e53b75f709a45e892/" rel="bookmark">
			Matlab的double函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将一个数用浮点数的形式表示。
比如在复数表示中，举例如下：
（1）
double((1 + i/2)/(i - 1/4)^(1/2)) 得到
ans = 0.9943 - 0.4733i （2）
double(cosh(1/2)/(sinh(1/2)*i + 1)) 得到
ans = 0.8868 - 0.4621i 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb97bfe9538cfde6674e970ac2c0d25/" rel="bookmark">
			matlab小波分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写之前，我也不知道能不能做的很理想，依照B站视频，分析温度数据，去噪。
但我有一个习惯，就是以前的文档，数据，都会保留起来，方便再次使用，寻找方法。
毕竟我提取一次数据，转换一次都是要费时间的。
怎么将Excel表格数据保存为matlab中的mat文件 比较实用
在matlab里面输入 num=xlsread('C:\Users\dell\Desktop\文件名.xlsx');
save 新的文件名
这样就OK啦！
这是原图，原始图像
导入一些常规数据，来一个plot函数把它画出来，纯练练手，看看小波去噪会让图像如何变化。
悲催了，我是matlab2016a，看来up主matlab有的功能我没有，常规操作如下
之后导入刚刚的plot图像，选择不同小波种类层次一键操作就OK了。看来，我的matlab版本小波处理只能另寻方法了。
不愁没办法，（我的matlab最近失灵刚刚重装，我不会卸了再安的）首先呢，我们要把数据转化成mat文件，这样，我们可以用wavemenu
来导入我们需要处理的信号 这样，我们就得到去噪之后的信号了。
下午一个半小时我在做我弟高一的数学试卷，终于有一天，轮到我弟弟给我讲数学题。没什么感想，就觉得很神奇，人生第一次。（做他卷子是为了证明我数学也不差，熟悉的题型和套路，做题惯用的技巧，做不出的大约还是那几题，选择最后压轴题靠猜，填空最后范围题放弃，大题倒数一二题的第二小问写了也没分，他现在还没有接触导数，还是比较少的题型和套路。）
所以这篇文章中间间断了，因为我去做数学试卷，手机被我弟收走了，离开高中多年了，发现会的依旧会，不会的地方依旧不会。也没有用到太新颖的方法去解题。卷子难度吧，还和我当年的差不多，好多年了，出卷子的人还是原来的习惯，他出的卷子一看便知道，还是老样子。我曾经的数学老师，一点都没变。沧海桑田。还是经常做梦，回到高中，再次准备高考。但是回不去了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b71716749901de76b730fc92c2862a/" rel="bookmark">
			Proteus 8找不到元件库的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装目录
权限
users
都挑勾
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0abdc38544999fd04602aaabbc4c706/" rel="bookmark">
			CSDN待不下去了，来博客园找我
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客园地址：https://www.cnblogs.com/loveandninenine/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cdc880ada595439f8a45118b45df2f2/" rel="bookmark">
			【UEditor富文本框】支持图片上传到文件服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上传图片到服务器
import API from "@utils/api"; import { MAX_SIZE } from '@utils/sheet/constant' import { message } from "antd"; export const requestUploadImg = (blob: any, width: number, pageHeight: number) =&gt; { let imgWidth: number; if (width) { imgWidth = width * (2 / 3); } if (!blob) { message.error("请选择上传文件"); return; } const formData = new FormData(); if (!/(.*)\.(jpg|jpeg|png|JPEG|PNG|JPEG)$/.test(blob.name)) { message.error("仅支持JPG、JPEG、PNG等图片格式"); return; } if (blob.size &gt; MAX_SIZE) { message.error("图片大小不能超过5M"); return; } formData.append("file", blob); formData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cdc880ada595439f8a45118b45df2f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38795838c028ad7eb81a0f5e99118bbe/" rel="bookmark">
			git reset命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		reset 命令：前进或者后退历史版本
创建一个test.txt分步骤输入几行并commit
演示：回退一步
回退后打开test.txt
再回退一步
返回到d行
说明：
1.reset三者是同步的
2、git reset --mixed[索引]
3、git reset --soft[索引]
总结，只有hard参数常用，其余的不怎么用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/782ef86fa8c7f2dfe906323cbd01ab60/" rel="bookmark">
			[二分查找] 二：二分查找的经典例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.何时应该会使用二分查找 当题目中出现有序数组时当时间复杂度要求为log(n)时搜索范围可以一次缩小一半时 2. 经典例题1 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
请必须使用时间复杂度为 O(log n) 的算法。
示例 1:
输入: nums = [1,3,5,6], target = 5
输出: 2
示例 2:
输入: nums = [1,3,5,6], target = 2
输出: 1
示例 3:
输入: nums = [1,3,5,6], target = 7
输出: 4
示例 4:
输入: nums = [1,3,5,6], target = 0
输出: 0
示例 5:
输入: nums = [1], target = 0
输出: 0
此题为最经典的二分查找
int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int left = 0, right = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/782ef86fa8c7f2dfe906323cbd01ab60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/574f51c1f514a98b3e394a16b3675dc0/" rel="bookmark">
			六-4:计时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计原理 Go语言的定时器经历过很多个版本迭代
Go 1.9版本之前，使用全局唯一的四叉堆维护Go 1.10-1.13，全局使用64个四叉堆，每个处理器（P）对应一个四叉堆Go 1.14版本之后，每个处理器P直接管理一个四叉堆，通过网络轮询器触发 1. 全局四叉堆 所有的计时器都会存储在如下结构中
var timers struct { lock mutex gp *g created bool sleeping bool rescheduling bool sleepUntil int64 waitnote note t []*timer } 这个结构中的t就是最小四叉堆，运行时所有的计时器都会加入其中。在以下事件发生时会唤醒计时器 四叉堆中有计时器到期四叉堆加入了触发时间更早的新计时器 缺点：全局互斥锁对性能影响大 2. 分片四叉堆 将全局四叉堆分割成了64个小的四叉堆。
const timersLen = 64 var timers [timersLen]struct { timersBucket } type timersBucket struct { lock mutex gp *g created bool sleeping bool rescheduling bool sleepUntil int64 waitnote note t []*timer } 如果机器处理器P超过64，就会有多个处理器的计时器在同一个bucket中。每个桶有一个协程处理缺点：分片降低了锁的粒度，但处理器和线程之间频繁的上下文切换影响性能 3. 网络轮询器 四叉堆直接存储在 runtime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/574f51c1f514a98b3e394a16b3675dc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a33352f4d3754d09d3171b4c056bb33/" rel="bookmark">
			解决 ImportError: C extension: No module named ‘pandas._libs.tslib‘ not built.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#yolo配置
报错:
nvidia@nx:~/yolov5-master$ python3 detect.py Traceback (most recent call last): File "/usr/lib/python3/dist-packages/pandas/__init__.py", line 26, in &lt;module&gt; from pandas._libs import (hashtable as _hashtable, File "/usr/lib/python3/dist-packages/pandas/_libs/__init__.py", line 4, in &lt;module&gt; from .tslib import iNaT, NaT, Timestamp, Timedelta, OutOfBoundsDatetime ModuleNotFoundError: No module named 'pandas._libs.tslib' During handling of the above exception, another exception occurred: Traceback (most recent call last): File "detect.py", line 42, in &lt;module&gt; from models.common import DetectMultiBackend File "/home/nvidia/yolov5-master/models/common.py", line 16, in &lt;module&gt; import pandas as pd File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a33352f4d3754d09d3171b4c056bb33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9a5c898b8b17ca174e367b87fa48fe/" rel="bookmark">
			数据可视化笔记 Task4 - Matplotlib文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matplotlib有广泛的文本支持，包括对数学表达的支持、对栅格和向量输出的truetype支持、对随意旋转的换行分隔文本的支持以及对Unicode支持。Matplotlib支持将字体直接嵌入输出文档。Matplotlib的matplotlib.font_manager实现了跨平台、W3C兼容的字体查找算法。用户可以通过设置rc文档实现文本属性的控制（文本属性有字号、加粗、位置、颜色等）。Matplotlib实现了许多Tex数学表达式和命令行，支持在图中任意位置展示数学表达式。
基本文本命令 下表为pyplot接口与OO接口用于创建文本的命令：
pyplot API
OO API
description
text
text
在Axes任意位置添加文本
annotate
annotate
在Axes任意位置添加注解及指向箭头
xlabel
set_xlabel
为Axes的x轴添加标签
ylabel
set_ylabel
为Axes的y轴添加标签
title
set_title
为Axes添加标题
figtext
text
为Figure的任意位置添加文本
suptitle
suptitle
为Figure添加标题
以上所有函数都创建并返回一个Text实例，该实例可配置各种字体以及其他属性。下面是给出一个例子：
import matplotlib import matplotlib.pyplot as plt fig = plt.figure() ax = fig.add_subplot() fig.subplots_adjust(top=0.85) # Set titles for the figure and the subplot respectively fig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold') ax.set_title('axes title') ax.set_xlabel('xlabel') ax.set_ylabel('ylabel') # Set both x- and y-axis limits to [0, 10] instead of default [0, 1] ax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a9a5c898b8b17ca174e367b87fa48fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d8abac6021b50afb7dd1f2307be088/" rel="bookmark">
			Lua闭包，Lua基础学习一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是Lua闭包 词法定界：当一个函数内嵌套另一个函数的时候，内函数可以访问外部函数的局部变量，这种特征叫做词法定界。
table.sort(names,functin (n1,n2) return grades[n1]&gt;grades[n2] end) //内部匿名函数可以访问外部函数的grades数组 第一类值: 是可以作为对象传递的，可以作为函数返回的值。
lua当中函数是一个值，他可以存在变量中，可以作为函数参数，可以作为返回值。
upvalue (外部局部变量)：
function test() local i=0 return function() i++ ... end end //函数作为返回值,这里的i也叫外部局部变量，就是lua中的upvalue 闭包：通过调用含有一个内部函数加上该外部函数持有的外部局部变量（upvalue）的外部函数（就是工厂）产生的一个实例函数
闭包组成：外部函数+外部函数创建的upvalue+内部函数（闭包函数）
function test() local i=0 return function()//尾调用 i+=1 return i end end c1=test() c2=test()//c1,c2是建立在同一个函数，同一个局部变量的不同实例上面的两个不同的闭包 //闭包中的upvalue各自独立，调用一次test（）就会产生一个新的闭包 print(c1()) --&gt;1 print(c1()) --&gt;2//重复调用时每一个调用都会记住上一次调用后的值，就是说i=1了已经 print(c2()) --&gt;1//闭包不同所以upvalue不同 print(c2()) --&gt;2 2.为什么要有Lua闭包 闭包是被总结的一种现象。
3.如何使用Lua闭包，使用Lua闭包的不同方案比较 3.1 闭包在迭代器中的运用 迭代器需要保留上一次调用的状态和下一次成功调用的状态，刚好可以使用闭包的机制来实现
创建迭代器：(一定要注意迭代器只是一个生成器，他自己本身不带循环)
function list_iter(t) local i=0 local n=table.getn(t) return function() i=i+1 if i&lt;=n then return t[i] end end end //这里的list_iter是一个工厂，每次调用都会产生一个新的闭包该闭包内部包括了upvalue(t,i,n) //因此每调用一次该函数产生的闭包那么该闭包就会根据记录上一次的状态，以及返回list的下一个 使用迭代器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0d8abac6021b50afb7dd1f2307be088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a9bd63a3989e40b7103d34359fca1f/" rel="bookmark">
			JavaDoc文档生成二种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javadoc生成： 方式一：类名前面加上如下注释：
/** * @author ahtoh * @version 1.0 * @since 1.8 */ 切换到当前类所在的路径，终端输入指令：
javadoc -encoding UTF-8 -charset UTF-8 JavaDoc.java 其中JavaDoc为所需生成文档的java类名。
方式二：Idea生成Java Doc文档
Idea版本：2020.1
Idea顶部Tools -&gt; Generate JavaDoc -&gt; 点击Output directory选择要生成文档位置
-&gt; 底部Locale配置语言和编码 -&gt; 点击确认生成JavaDoc文档。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db2142ecbd2c7c6ac7a7fb14e38334d3/" rel="bookmark">
			PyQt5将项目搬到一个新的虚拟环境中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置：
1). 新的虚拟环境 python3.7.1
2). 要用到的软件python3.7.1.exe, pycharm
目录
1. 下载 python
2. 安装python
3. 创建虚拟环境
4. 安装项目中需要的包
5. 遇到的问题
1. 下载 python www.python.org/getit/
点击“Download”，跳转到
www.python.org/downloads/release/python-371/
本机电脑是64位，选择64位下载，如果电脑是32位的，选择文件名中是 x86 的文件，不要选择 x86-64 的文件
2. 安装python 即使电脑中已经安装了python也没有关系，本文要重新安装一个python是为了项目中的包从无到有，这样可以避免项目打包时加入很多用不着的包
将下载的 python-3.7.1-amd64.exe 文件复制到数据盘的一个目录下，本文拷贝在 D:/soft/python371 下
如果电脑中已经安装有python, 最底下的 “Add Python 3.7 to PATH” 不要勾选，勾选的话后面执行python会变成是执行当前安装的这个python
建议修改路径，安装在数据盘，也便于后续找到
安装中，等待几分钟
安装完成后，python对应的文件夹
3. 创建虚拟环境 3.1 新建一个文件夹，将项目拷贝到新的文件夹下
本文新建的文件夹路径 D:\python371_64， 项目名为 example_proj 将项目整个拷贝到该目录下
将项目目录下的 “venv”、“.idea”、“_pycache_”三个文件夹删除
剩余的文件夹和文件都是项目代码，不重要，只要知道这个是项目代码，读者照着操作时，项目代码肯定是不一样的
3.2 在pycharm中创建虚拟环境
File-&gt;Open
找到刚刚新创建的目录，点击 “OK”
在新窗口中打开项目
配置Python
File-&gt;Settings...
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db2142ecbd2c7c6ac7a7fb14e38334d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee621eac873427d9e470fd5820751d8/" rel="bookmark">
			selenium-web滑块验证码-java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整套实现用到了selenium的jar包，chromedriver.exe驱动，opencv_java340-x64.dll图像处理文件。运行环境是windows，jdk1.8，项目是maven的~~因为属于半实验的项目，所以做的非常糙，后期大家自己继续改造吧~下面上代码一一说明吧~
1.入口程序加载需要的资源，定义必要的变量~
public static String basePath = "D:\\test\\"; public static String FULL_IMAGE_NAME = "full-image"; public static String BG_IMAGE_NAME = "bg-image"; public static int[][] moveArray = new int[52][2]; public static boolean moveArrayInit = false; public static String INDEX_URL = "https://1111.com"; public static WebDriver driver; public void run() throws InterruptedException { System.setProperty("webdriver.chrome.driver", "F:\\spring\\ESController\\src\\main\\java\\chromedriver.exe"); if (!System.getProperty("os.name").toLowerCase().contains("windows")){ System.setProperty("webdriver.chrome.driver", "/Users/wangyang/workspace/selenium/chromedriver_V2.30/chromedriver"); } driver = new ChromeDriver(); System.load("F:\\spring\\ESController\\opencv_java340-x64.dll"); String[] us = {"用户名集合"}; String[] ps = {"密码集合"}; for(int i = 0; i &lt; us.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee621eac873427d9e470fd5820751d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d745e3bacf110add3b153b81285862/" rel="bookmark">
			js 的input checked 自动选中通过点击事件选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 模拟input点击事件 //方法1 var evt = new MouseEvent("click", { bubbles: false, cancelable: true, view: window }); //input_checkbox.dispatchEvent(evt); //方法2 input_checkbox.click(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a420b193ed4fd96b974fc881f610f462/" rel="bookmark">
			RocketMQ发送延迟消息时报错，发送同步消息却正常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		延时消息代码如下： Message&lt;Mdds&gt; message = MessageBuilder.withPayload(mdds).build(); // 延迟第3级发送（延迟10秒） rocketMQTemplate.syncSend(MessageConstant.TOPIC_ORDER, message, 1000, 3); 能正确调用的方法如下：
rocketMQTemplate.convertAndSend(MessageConstant.TOPIC_ORDER, mdds); 错误详情如下：
org.springframework.messaging.MessagingException: sendDefaultImpl call timeout; nested exception is org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout 解决方法：
设置的超时时间为3s以上，问题解决，代码如下：
rocketMQTemplate.syncSend(MessageConstant.TOPIC_ORDER, message, 3000, 3); 注意：网上很多错误方法，如修改配置文件broker.conf，并在mqbroker运行命令时增加参数 -c ../conf/broker.conf，并在mqnamesrv运行命令时增加-n 127.0.0.1:9876，这些解决不了问题！如果是配置错误，不可能成功发送同步的消息
我建了一个私域流量运营的社群，欢迎朋友们进群一起交流，想进群关注并私信我吧、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5121754f98280b51beb3d118f73f044f/" rel="bookmark">
			容器技术之Docker&amp;K8S知识笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文带你快速了解Kubernetes与Docker 让你对容器与虚拟机的区别、Docker与K8S有一个快速的了解
目录
演变史容器与虚拟机的区别K8S与Docker概念DockerK8S参考文章 演变史 传统部署时代： 早期，将单一的应用服务运行在物理服务器上，无法给服务器的应用程序进行资源的限制，导致物理服务器之间的资源负载使用不均衡，就导致了服务器上的应用程序的性能下降，物理服务器的维护成本变得很高。
虚拟化部署时代： 作为解决方案，引入了虚拟化功能，它允许您在单个物理服务器的 CPU 上运行多个虚拟机VM。虚拟化功能允许应用程序在 VM 之间隔离，并提供安全级别，因为一个应用程序的信息不能被另一个应用程序自由地访问。
容器部署时代： 容器类似于 VM，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统OS。因此，容器被认为是目前最轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和 OS 分发进行移植。
容器与虚拟机的区别 容器技术为什么会这么火爆？说白了，就是因为它“轻”。
在容器技术之前，业界的网红是虚拟机。虚拟机技术的代表，是VMWare和OpenStack。
相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是相互隔离的，互不影响。而容器，它不需要虚拟出整个操作系统，只需要虚拟出一个小规模的环境。类似于“沙箱”。
容器是在linux上本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量。
虚拟机运行的是一个完成的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。
下表中列举了容器与虚拟机之间的区别：
K8S与Docker概念 Docker Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。一句话总结就是，从仓库中拉取镜像，利用镜像生成容器。
Docker技术的三大核心概念，分别是：镜像（Image）、容器（Container）、仓库（Repository）。相关概念解释如下：
宿主机，Host，运行Docker所在的物理机，是Docker运行的系统环境。镜像，Image，相当于一个程序模板，通过这个模板可以生成很多个相似的容器。可以理解为Java中的类，它本身不具备执行运行的能力，是一个对象抽象的模板。每个镜像可以有多个版本，用tag来区分。镜像可以通过Dockerfile来构建。容器，Container，Docker运行的最小单位对象。它是通过镜像实例化出来的一个可运行对象。容器的修改，可以提交反作用于镜像，更新这个容器的模板。仓库，Repository，用于存储管理镜像的仓库，类似于git管理代码的仓库一样，可以管理多版本的镜像。 镜像、容器和仓库三者的关系如下：
K8S 就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。
就在这个时候，K8S出现了。
K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。
一个K8S系统，通常称为一个K8S集群（Cluster）。这个集群主要包括两个部分：一个Master节点（主节点），一群Node节点（计算节点）。Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。
概括来说 K8s 架构就是一个 Master 对应一群 Node 节点。下面我们来逐一介绍 K8s 架构图中的 Master 和 Node。
Master 节点结构如下：apiserver 即 K8s 网关，所有的指令请求都必须要经过 apiserver。Scheduler 调度器，使用调度算法，把请求资源调度到某一个 Node 节点。Controller 控制器，维护 K8s 资源对象。etcd 存储资源对象。Node 节点结构如下：Kubelet 在每一个 Node 节点都存在一份，在 Node 节点上的资源操作指令由 Kubelet 来执行。Kube-proxy 代理服务，处理服务间负载均衡。Pod 是 K8s 管理的基本单元（最小单元），Pod 内部是容器，K8s 不是直接管理容器，而是管理 Pod。Docker 运行容器的基础环境，容器引擎。Fluentd 日志收集服务。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcaac530eb634d8065d93d4c871b707b/" rel="bookmark">
			modbus协议的常用测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中经常会遇到modbus的设备，而大部分是modbus rtu通信协议，接下来就说明modbus的设备可以怎么进行测试。
1，modbus poll软件
可以使用modbus poll软件采集采集设备的数据。把设备通过485或者232接到电脑上，在电脑上运行poll软件。在设置poll软件的时候注意波特率，设备地址，寄存器地址等参数的设置，设置好后就可以在poll软件上看到采集到的设备的数据了。
2、modbus slave软件
在没有实际的modbus设备用来测试的时候，可以使用slave软件模拟一个从站设备，给其他设备或者系统发送数据，用来测试其他系统的工作情况。
3、串口调试工具
各种测试软件其实就是给设备收发数据，这些数据都是按照modbus协议的标准协议进行传输的，因此在熟悉modbus协议的情况下，可以自己编写一帧modbus的请求或者应答数据，通过串口调试工具进行收发。编写数据的时候主要注意校验和的计算，在数据有改变的时候，需要重新计算校验和。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9655d3dfffb0788273cae4ae65ac2b/" rel="bookmark">
			RTC时间设置问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时任务设置的是每天20点移动文件至time目录下，并设置当时时间为文件名
发现文件名与生成时间相差8小时
猜测跟系统时间有关
终端输入：timedatectl查看系统时间与日期
Local time: 三 2021-08-25 01:10:16 UTC #本地时间
Universal time: 三 2021-08-25 01:10:16 UTC #协调世界时间
RTC time: n/a #硬件时间
Time zone: Etc/UTC (UTC, +0000) #时区
Network time on: yes #NTP时间同步是否开启，yes表示是
NTP synchronized: yes #如果和远程NTP服务器成功同步，显示为yes
RTC in local TZ: no #no表示硬件时钟设置为协调世界时（UTC），yes表示硬件时钟设置为本地时间
设置硬件时钟为本地时间，终端输入：timedatectl set-local-rtc yes，yes可写为no 发现时区不对，导致协调世界时间与本地时间一致，所以修改时区，终端输入：sudo timedatectl set-timezone 'Asia/Shanghai'
硬件时间处没写值，终端输入sudo hwclock -r查看硬件时间
将硬件时间同步本地时间，硬件终端输入sudo hwclock -w
查询硬件时间，发现没有改成功，查询资料发现是NTP时间同步跟timedatectl修改时间不能共用，所以关闭NTP时间同步（终端输入：timedatectl set-ntp no）
再次修改硬件时间同步本地时间，查询修改成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4201bc6c40b507d98dba0941ecabe54/" rel="bookmark">
			FOFA无法打开？原因是...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
2022年1月20日下午，FOFA突然无法访问，
ping也解析不出来ip
有很多网友说fofa.so改成fofa.info了
但也是无法访问
在查询中已经被列入了黑名单
fofa无法打开在整个安全圈内炸开了锅
脚本小子哭晕在厕所
有很多网友猜测被关闭的原因
有猜测造成无法办理任务的，动了蛋糕的等等
隔壁的ZoomEye钟馗之眼搜索引擎开始大降价
当然了，这都不是我们月薪1800考虑的问题
随后
在当天晚上， 北京白帽汇安全研究院负责人赵武发表微博称
创业就是要学会面对各种问题，要突破技术，要走通商务，要让自己更合规。我们积极面对，感谢身边支持我们的朋友们，大寒的天气内心也温暖。FOFA会变得更好，我们要让技术更美好！
FOFA官方微信公众号发表：
与其听信谣言，不如相信FOFA
加油！期待FOFA早日归来！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13937950537089f2ac06e68515fd827d/" rel="bookmark">
			【洛谷】B2004 对齐输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;cstdio&gt; using namespace std; int main() { int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); printf("%8d %8d %8d",a,b,c); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daf0f8833fc59b53d93e8feee8b64f59/" rel="bookmark">
			【洛谷】B2003 输出第二个整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ long long a; long long b; long long c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;b; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3183a097ef9d885a307f2f5ba327413/" rel="bookmark">
			vue中 基于echart地图功能 省级地图下钻和返回、发射线、水波涟漪等功能展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图展示-包含水波涟漪、发射线功能效果图
点击地市、区县下钻功能
vue项目中main.js import echarts from 'echarts' import anhui from '../static/commonJs/anHui.json' window.anhuiData = anhui echarts.registerMap('anhui',anhui) Vue.prototype.$echarts = echarts; 页面代码 &lt;template&gt; &lt;div class="orioc-chart-wraper"&gt; &lt;div class="chart" :id="id" ref="chartEle"&gt;&lt;/div&gt; &lt;div class="fanhui" @click="returnMenu" v-if="mapLevel === 2"&gt; 返回至省级地图 &lt;/div&gt; &lt;div class="fanhui" @click="returnMenu" v-if="mapLevel === 3"&gt; 返回至市级地图 &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import eventBus from '@/components/event/event-bus' import cityMapData from './anhuiMap' export default { name: 'index', props: { LableData: Array }, data() { return { mapJson: cityMapData.mapJson, // 获取市、区县数据 id: 'anhiMap', option: null, echartsObj: null, beginMap: 'anhui', defaultmapName: '安徽省', // 默认地图名 mapLevel: 1, // 地图所在层级水平 1为省级 2为市级 3为区县级 oldName: '', // 变更地图之前地图名 oldSeriesName: '安徽省', // 变更地图之前地图名 nowName: '', // 当前城市名 nowEName: '', // 当前城市名-拼音 nowCityJson: '', // 当前城市json nowSeriesName: '安徽省', // 当前地图名 colors: [ '#41E0E9', '#1259E5', '#FF6C70', '#FF2482', '#FFA506', '#FD8308' ], geoCoordMap: [], centerPoint: { name: '', // 合肥 value: [117.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3183a097ef9d885a307f2f5ba327413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6ecff3b8d2e66b2a3fe86c3b695569d/" rel="bookmark">
			maven之如何查看依赖树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：写在前面 在工作中，经常会有这样的场景，因为多个jar包间接引入了同一个jar包的多个不同版本，造成版本冲突，进而程序出现问题，此时就需要确定这些依赖到底是通过哪个jar被引入，而后通过配置exclude解决版本冲突问题，而定位的过程就需要依赖于查看maven的依赖树，接下来我们就一起看下吧！
2：查看依赖树 假设此时我们的pom如下：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 引入的依赖如下图：
假设spring-beans:5.0.6是我们希望剔除的依赖，此时就可以这么做，执行命令mvn dependency:tree:
xbdeMacBook-Air:test-idea-mvc xb$ mvn dependency:tree [INFO] Scanning for projects... ...... [INFO] org.example:test-idea-mvc:war:1.0-SNAPSHOT [INFO] +- org.springframework:spring-webmvc:jar:5.0.6.RELEASE:compile [INFO] | +- org.springframework:spring-aop:jar:5.0.6.RELEASE:compile [INFO] | +- org.springframework:spring-beans:jar:5.0.6.RELEASE:compile [INFO] | +- org.springframework:spring-context:jar:5.0.6.RELEASE:compile [INFO] | +- org.springframework:spring-core:jar:5.0.6.RELEASE:compile [INFO] | | \- org.springframework:spring-jcl:jar:5.0.6.RELEASE:compile [INFO] | +- org.springframework:spring-expression:jar:5.0.6.RELEASE:compile [INFO] | \- org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6ecff3b8d2e66b2a3fe86c3b695569d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40889bf6aabb26968db4f8cc3595a29b/" rel="bookmark">
			Python 经典模块可能都学过，10道题测试你会不会用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 作为 2021 年度最受欢迎的编程语言，备受众人瞩目，也很受新手小白喜爱。除此之外，它在很多领域都发挥其作用，比如大数据、无人驾驶、Web 开发等等。
【敲重点】
蓝桥云课即将在 2022 年 1 月 24 日下午 15:00 开启 2022 年度首次楼赛——Python 经典模块大比**Python 经典模块可能都学过，10道题测试你会不会用！**拼，欢迎来参加哦！
一、比赛介绍 比赛时间：2022 年 1 月 24 日下午 15:00
截止时间：2022 年 1 月 31 日晚上 24:00
比赛题目： 10道趣味应用题
二、比赛奖励 第 1-3 名：1 个训练营+ 1 个抱枕
第 4-10 名：鼠标垫+ 1 个月标准会员
第 11-20 名：1 个月标准会员
参与答题人员：20 元训练营优惠券
三、奖励发放 10 题趣味应用题，每个挑战有不同的分值，排行榜实时更新，并由社群进行发放；
结束后，奖励由站内信和小蓝进行发放，注意查收。
戳/即可参与:shiyanlou007
四、比赛规则 完成挑战点击【提交结果】，系统评估 PASS 可以获得题目分数，FAIL 不得分；
每道题目的前十位通过者获得附加分，第 1 - 3 名 3 分，第 4-6 名 2 分，第 7-10 名 1 分；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40889bf6aabb26968db4f8cc3595a29b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8d9ebf12412b9aab20652770609225/" rel="bookmark">
			面向对象1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 面向对象和面对过程
2. 类和对象
3. Java中定义类的格式
3.1 定义类完成属性描述
3.2 定义类完成行为描述
4. Java中创建对象和操作成员
4.1 创建对象
4.2 通过对象操作成员变量
4.3 通过对象操作成员方法
5. 类对象内存分析图
1. 面向对象和面对过程 吃烤羊排
【面向对象】：1. 驱车去往烤羊排店铺
2. 点一份烤羊排
3. 吃
4. 埋单
5. 返程 【面向过程】：1. 买羊排 2. 准备调料 3. 羊排整扇焯水，撇去浮沫
4. 料汁 5. 烤箱 预热 190 度 3分钟
6. 羊排刷料放入烤箱 上下火 200度 15分钟
10分钟 在撒上孜然粉
7. 吃
8. 洗锅，洗烤箱，收拾
面向对象：找合适的人，做合适的事
面向过程：自己亲力亲为
2. 类和对象 类对象人类马云、马化腾、周杰伦...狗类哮天犬...车类劳斯莱斯幻影、领克01... 类：一类事物的统称，具备对应事物的行为描述和属性描述
对象：类对应的具体的，唯一的，独立的个体 3. Java中定义类的格式 class 类名 {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8d9ebf12412b9aab20652770609225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37af918b3b0481b00a26c4b2d3737490/" rel="bookmark">
			HTML标签：CSS样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS全名Cascading Style Sheets用来HTML元素标签的样式。CSS嵌入HTML文档的方式有3种：
1）在标签中使用设置style属性；比较适合当特殊的样式需要应用到个别元素时。
2）在HTML文档头部 &lt;head&gt; 区域使用&lt;style&gt; 元素 来包含CSS；适合当单个文件需要特别样式时。
3）使用外部 CSS文件，比较适合当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。
&lt;!DOCType html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;CSS样式使用方式&lt;/title&gt; &lt;!--第3种：引用外部的CSS样式表文件--&gt; &lt;link rel = "stylesheet" type="text/css" href="mystyle.css"&gt; &lt;!--第2种：直接定义文档CSS样式--&gt; &lt;style type="text/css"&gt; body {background-color: gray;} p {color: red;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--第1种：在特定标签中设置style属性--&gt; &lt;h1 style="color: brown;"&gt;标题1&lt;/h1&gt; &lt;p&gt;段落&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;&gt; 运行结果如下
读者可以根据情况，选择如何使用设置CSS样式的方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5a75cab0c282ffc90f9d9b6e5a34cb/" rel="bookmark">
			npm发包以及问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 注册账号发包E403问题以及修改源 注册账号 npm
发包 在你需要上传的包的当前文件夹打开终端,准备登录你刚刚注册(已有)的账号
登录账号：npm adduser
然后根据提示输入账号、密码、邮箱；
输入完后会给你提示，你当前的源是在哪，有的可能装cnpm那么就会是在别的源，那么就需要切换到https://registry.npmjs.org源；在下边问题统一
发布：npm publish
E403问题以及修改源 源不正确的话，需要切换源
查看源：npm config get registry切换源方法一：npm config set registry https://registry.npmjs.org切换源方法二：nrm use npm 报如下错的话， 是没有验证邮箱
解决：重新去网页端，登录邮箱验证一下，就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0748850d2d947c3780e13ea0398af9/" rel="bookmark">
			文件夹的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑上的文件夹遍历函数os.walk(path)函数，是一切文件夹操作的基础。有了这个函数，全部文件夹与文件的操作就有了基础。本文要谈的是网盘上的文件夹遍历。考虑使用bypy工具搭建自己的网盘自动传输系统，需要对云文件夹进行遍历，如果建立同样的函数，将能为所有相关文件夹的文件的操作建立坚实的基础。
这个问题并不简单。因为文件夹具有循环特征。企图遍历完一个子文件夹再进入下一个子文件夹是困难的，因为遍历完子文件的操作就是遍历完全部文件夹的操作，它们在结构上是一致的。这引起了我对复杂程序结构分析的兴趣。
首先，要考虑突破这种陷阱。我考虑的是从第一层开始，到第二层，到第三层，一层一层遍历完文件夹，而非遍历完所有某个子文件夹的内容。
第二，构建循环体，这个循环体是对一个列表的操作，这个列表的文件夹进行操作，产生一系列的子文件夹，重新构成列表，把得到的新列表，赋给上一次被操作的那个列表用到的名字，就实现了循环。
第三，我们的操作基础是基于bypy本身提供的list函数，它会提供当前文件夹的子文件夹和文件信息，类似于os的listdir函数。不过它只能显示在shell中，所以要调用subprocess的runcmd函数，让运行结果写入文本文件，再通过文本文件的读写传递信息解决这个问题。
第四，对循环体的分析表明，需要在一个一般性变量的位置，即位于n的层级，不能指定具体的层级，只能是变量n，往上回溯到初始文件夹，获得路径才能调用list函数产生子文件夹列表。这就要求我们改造针对单层文件夹的 list函数，使在当前的n层级的操作获得n-1级的文件夹的信息，从而能够回溯到起点。
第五，循环体在初始位置很难与一般情况共用同样的程序代码组，我们可以修改在第一次循环时的处理就是了。循环熔断的条件，可以观察到产生的子文件夹列表为空时就可以break了。
下面是草图分析。在用草图进行分析完之后，整个代码的编写出奇顺利。因此正确的程序编写是要进行草图分析的，慢慢推断研究它各部分应该具备的特征和规律，并分析实现这些功能需要的信息和信息的传递。程序本质上是一台复杂的精密的机器。程序延展了数学的运算范围，并以其自身的逻辑使我们获得明确的输入输出的规律。有些结果是偏离甚至是不可知的诡异的，它指向某种神秘的精神灵性的层面。这些正是它的魅力所在。
这是listwj.py子程序 import bypy from bypy import ByPy bp = ByPy() # 1 读取传入的网盘文件夹名 TEa = [] with open(r'D:\pythonZD\xitong\wpwjj.txt','r',encoding = 'utf-8') as file: while True: line = file.readline() TEa.append(line) if line == '': break mg = TEa[0] bp.list(remotepath = mg) 如下的wp_walk(path)函数完全实现了如同电脑上操作的os.walk(path)函数一样的功能。
# -*- coding: utf-8 -*- import subprocess import os import MKwjcz from bypy import ByPy bp = ByPy() import win32com.client import pythoncom import math import shutil import time import re def runCmd(cmd) : res = subprocess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a0748850d2d947c3780e13ea0398af9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f298732f3cae063ab93bf4452ddcd0d4/" rel="bookmark">
			java 类的卸载总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
类的生命周期
引用关系
加载器和Class对象
类、类的Class对象、类的实例对象
类的卸载
具体例子
总结
类的生命周期 当Sample类被加载、连接和初始化后，它的生命周期就开始了。
当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。
由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。
引用关系 加载器和Class对象 在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。
另一方面，一个Class对象总是会引用它的类加载器。调用Class对象的getClassLoader()方法，就能获得它的类加载器。
由此可见，Class实例和加载它的加载器之间为双向关联关系。
类、类的Class对象、类的实例对象 一个类的实例总是引用代表这个类的Class对象。
在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。
此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。
类的卸载 由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。
前面介绍过，Java虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。
Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。
由用户自定义的类加载器加载的类是可以被卸载的。
具体例子 Class clazz=loader.loadClass("Sample"); Object obj=clazz.newInstance(); loader1变量和obj变量间接引用代表Sample类的Class对象，而objClass变量则直接引用它。
如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。
当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例(可以通过哈希码查看是否是同一个实例)。
总结 卸载类需要满足 3 个要求:
1 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2 该类没有在其他任何地方被引用
3 该类的类加载器的实例已被 GC
所以，在 JVM 生命周期内，由 jvm 自带的类加载器 BootstrapClassLoader, ExtClassLoader, AppClassLoader 加载的类是不会被卸载的，所以它们(类加载器的实例)肯定不会被回收。但是由我们自定义的类加载器加载的类是可能被卸载的。
(1) 启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)；
(2) 被系统类加载器和标准扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者标准扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。(当然，在虚拟机快退出的时候可以，因为不管ClassLoader实例或者Class(java.lang.Class)实例也都是在堆中存在，同样遵循垃圾收集的规则)；
(3) 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到.可以预想，稍微复杂点的应用场景中(尤其很多时候，用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)
综合以上三点， 一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下来实现系统中的特定功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ab87163d96bd8e7b2cc38fab39442cc/" rel="bookmark">
			微信小程序的逆向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在学校的时候，每次都要在晚上查寝的时候都要签到。而且是在一个特定的时间点。晚上10点开始。到11点半。其实也没啥。但是我这记性呀。就经常忘记就这样，我就在不知不觉中少签七八次。
我人傻了（派大星表情包）_大星_我人表情
就这样，我就想能不能写个程序自动签到。就不会忘签了。嘻嘻
人类正出于懒惰而掌握各种的技术 ————佚名 开始解密 1.寻找小程序 因为我们签到是用手机app来进行签到的，但是手机app抓包和反编译比较麻烦。那我们能不能转换一个方式。看看这个程序有没有网页版。或者小程序版。百度了一下。发现没有网页版。又到微信搜索了一下。嘻嘻。发现有小程序版本。Nice！
喜嘻嘻嘻嘻嘻嘻嘻嘻〡(喵星人表情包)_嘻嘻_喵星人表情
找到小程序了。但是还是有个问题。就是一天只能签到一次耶。我抓包的话，一天只能抓一次。要是他还有啥加密参数啥的（后面证实是我想多了。压根没有啥加密参数）。后面也不好调试。所以，我就想反编译这个小程序看看源码。
2.开始反编译 首先准备工具
主要有两个，一个叫UnpackMiniAPP.exe。这个是吾爱破解里面的大神提供的。还有一个就是githup上面的项目。通过这个wxappUnpacker来反编译源码。
反编译之后就是这样
可以获取到源码。然后在到微信开发者工具中打开。就可以愉快的调试代码了。
1
首先得明确目的，我们是来找签到接口的，找完就走，绝不拖延！
首先，我们签到都会弹出一个签到成功的弹窗。那我们就用万能的搜索大法。ctrl+f来搜索签到成功。找到一个可疑的文件夹——test
我点进去一找。（主要是代码都没混淆，很好找）。找到发送请求的地方。然后再看一下请求参数。是个post请求。发送的是json数据。其中调用了腾讯的api来获取你的定位。（也就是经纬度）。还有其他的一些参数。班级啥的。这里就不贴图了。嘻嘻！
年轻人,你的思想很危险啊!(熊猫头)_熊猫_年轻人_危险_思想表情
3.用python编写脚本 这个就很简单了。写好参数。发送一个post请求就完事。（定时的话，就挂在服务器上自动运行完事！）可能是这个软件比较冷门吧。都没做啥加密。找接口一气呵成！
另外一种方法 用fiddler来进行抓包。 我们可以在电脑的微信上打开这个小程序。然后用fiddler来抓取请求。可以达到一样的效果。但是有个缺点就是你一天只能抓取一个请求。如果你对那个发送的json参数不咋确定。就有点麻烦。（我是不会告诉你，我开始就是用的这种方法）
其实fiddler抓包，你模仿发送一次就行了。
今天就到这里了！对了，那些工具都放在交流群里了。群号：342096685
拜拜~(熊猫头拿手枪) - 「敷面膜」没有感情系列
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fb37e80fc628200b02470a631a8a18b/" rel="bookmark">
			利用JCommander解析Java程序的传入参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JCommander可以帮我们解析Java的命令行工具，主要利用@Parameter配置自己所需要的参数；
JCommander 案例 在一般应用场景，我们可能只需要设置@Parameter以下几个属性值：
* names 设置命令行参数，如-old
* required 设置此参数是否必须
* description 设置参数的描述
* order 设置帮助文档的顺序
* help 设置此参数是否为展示帮助文档或者辅助功能
public class CommandArgs { @Parameter(names = {"-s","--savepoint"}, help = true, required = false, description = "scheduler savepoint,default path /data/checkpoint") private String savePoint = null; public String getSavePoint() { return savePoint; } } public class CommandLineUtils { public static CommandLineArgs parseSchedulerArgs(String[] args) { CommandArgs commandArgs = new CommandArgs(); JCommander.newBuilder() .addObject(commandArgs) .build() .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fb37e80fc628200b02470a631a8a18b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d497599eb02f58dae911e20b6b907155/" rel="bookmark">
			es检索到的大量数据如何根据特定字段去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		借鉴：https://blog.csdn.net/wslyk606/article/details/84315862?spm=1001.2014.3001.5506
目录 1 引言2 Elasticsearch去重功能2.1 关系型数据库如何去重2.2 es如何去重2.3 es折叠去重 1 引言 项目中es库中存储了大量的文档信息，而且是分段存储。
需求：根据文档内容检索出当前的文档。
问题：检索出了大量的相同文档，如何去重呢？
大量相同文档伴生的问题：
es检索到10000条以上数据就会抛错
java Api中只能显示10条检索出来的数据
2 Elasticsearch去重功能 2.1 关系型数据库如何去重 关系型数据库中，比如MySQL，可以通过distinct进行去重，一般分为两种：
1 ) 统计去重后的数量
select distinct(count(1)) from test;
2 ) 获取去重后的结果
select distinct name,sex from person；
test，person为对应的表名。
2.2 es如何去重 1 ) es查询结果进行去重计数
es的去重计数工卡可以通过es的聚合功能+Cardinality聚合函数来实现
2 ) es查询结果去重后显示
去重显示有两种方式:
(1) 使用字段聚合+top_hits聚合方式
(2)使用collapse折叠功能(5.3后版本提供)
我这里使用的es是2.4的版本，JavaApi使用的是第一种方式，5.x，6.x的版本也可以使用
2.3 es折叠去重 这里介绍es的折叠去重，原因是简单，性能好。
注意：collapse的字段需要为keyword或者number类型。
POST your_index/_search { "query":{ "match_all":{ } }, "collapse":{ # 根据哪个字段去去重 uid "field":"uid" } } java代码 es6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d497599eb02f58dae911e20b6b907155/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5960bd4b493bb722dfd4cf8a801fff3e/" rel="bookmark">
			Cascader 级联选择器（三级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务场景 点击分组id=1修改，获得当前行的所有信息，其中所属分类id是用来控制*所属分类
这里是通过点击修改按钮获取此时的
一个分类可以有多个属性数组，一个属性分组可以有多个属性
*所属分类这里v-model绑定，调用后端接口得到数据如下
后端实现 controller层 @RequestMapping("/info/{attrGroupId}") public R info(@PathVariable("attrGroupId") Long attrGroupId){ System.out.println(attrGroupId); // 通过groudId找到attrGroup，这是mybatis内置方法 AttrGroupEntity attrGroup = attrGroupService.getById(attrGroupId); System.out.println(attrGroup); //	通过attrGroup主体找到对应的catelogId Long catelogId = attrGroup.getCatelogId(); System.out.println(catelogId); Long[] path = categoryService.findCatelogPath(catelogId); attrGroup.setCatelogPath(path); return R.ok().put("attrGroup", attrGroup); } service层 AttrGroupService
package com.atguigu.gulimall.product.service; import com.baomidou.mybatisplus.extension.service.IService; import com.atguigu.common.utils.PageUtils; import com.atguigu.gulimall.product.entity.AttrGroupEntity; import java.util.Map; /** * 属性分组 * * @author maplechen * @email 1146706468@qq.com * @date 2021-12-26 12:23:21 */ public interface AttrGroupService extends IService&lt;AttrGroupEntity&gt; { PageUtils queryPage(Map&lt;String, Object&gt; params); PageUtils queryPage(Map&lt;String,Object&gt; params,Long catelogId); } Bean层 AttrGroupEntity package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5960bd4b493bb722dfd4cf8a801fff3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73110e8466ef86921a0bf1f5525f9479/" rel="bookmark">
			Cron表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 表达式结构 corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份
可省略的字段：月份中的日期，星期中的日期 填写规则 Seconds Minutes Hours DayofMonth Month DayofWeek Year或
Seconds Minutes Hours DayofMonth Month DayofWeek
corn从后往前写的顺序：年星期月日时分秒 cron基本格式 cron表达式案列 0 59 23 * * ? 每天的23点59分0秒执行一次0 0 8,9,10 * * ? 每天上午8点，下午9点，10点 执行一次0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时执行一次0 15 14 20 * ? 每月20日上午14:15触发 注意事项 人无完人，包容乃大。自律自强，必能成长！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/515a7700b814dc81ac23c6441629785b/" rel="bookmark">
			windows下安装flink并启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要记录下bin目录找不到bat脚本的问题，详细流程看文末参考文档
1.直接下载scala版本为2.12的bin目录下自带bat脚本
2.官网scala版本2.11的bin目录下没有bat脚本，如果要使用scala2.11的直接把bat脚本copy的bin目录即可
start-cluster.bat脚本内容 ::############################################################################### :: Licensed to the Apache Software Foundation (ASF) under one :: or more contributor license agreements. See the NOTICE file :: distributed with this work for additional information :: regarding copyright ownership. The ASF licenses this file :: to you under the Apache License, Version 2.0 (the :: "License"); you may not use this file except in compliance :: with the License. You may obtain a copy of the License at :: :: http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/515a7700b814dc81ac23c6441629785b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7034642fce92d456b0c3335a9c3f412/" rel="bookmark">
			Java—接口与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口： 接口声明：interface 接口名字 接口体： 常量的声明 常量必是public， static，final型常量（可以省略public， static，final的书写） 抽象方法 方法必是public，abstract方法（可以省略public，abstract的书写） 实现接口： 1.由类来实现接口 ：关键字 implements class A implements B,C //A类实现B,C接口(可以实现多个接口) 2.如果一个非抽象类实现了某个接口，那么这个类必须重写这个接口中的所有方法。且一定要用public修饰（否则降低了方法的访问权限）
3.程序可以用接口名访问接口中的常量，但是如果一个类实现了接口，那么该类可以直接在类中使用该接口中的常量。 如果父类实现了某个接口，那么子类也就自然实现了该接口。
接口也可以被继承，由于接口中的常量和抽象方法都是public的，子接口将继承父接口中的全部方法和常量。
abstract类和接口的比较： 1. 相同 ：abstract类和接口都可以有abstract方法。 2. 不同 ：接口中只可以有常量，不能有变量；而abstract类中既可以有常量又可以有变量。 abstract类中也可以由非abstract方法，接口不可以（ 接口是100%抽象类 ）。 接口回调： 接口变量中可以存放实现该接口的类的实例的引用简记为接口变量存放对象的引用 interface A{```} class B implements A{} A a; a=new B();
接口定义的变量=（实现了改接口的）类创建的对象的引用（new） 接口与多态：将实现接口的类的实例对象的引用赋值给接口变量，那么接口变量可以回调该类重写的接口方法。那么由接 口产生的多态是指不同的类在实现同一个接口时可能具有不同的实现方式，那么接口变量在回调接口方法时就可 能具有多种形态。
接口参数：如果一个方法的参数是接口类型，那么可以将实现该接口的类的实例的引用传递给该接口参数，那么该参数就可以回调类实现的接口方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180d53cee2af3f808b493efd55d38e2a/" rel="bookmark">
			(java)输入一个正整数n(1≤n≤6)和n阶方阵A，交换方阵A中的最大值与最小值位置。假定方阵A中的最大值与最小值都唯一。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.qinyang.array; import java.util.Scanner; public class Demo02 { /*输入一个正整数n(1≤n≤6)和n阶方阵A，交换方阵A中的最大值与最小值位置。 假定方阵A中的最大值与最小值都唯一。*/ public static void main(String[] args) { Scanner s = new Scanner(System.in); int n = 0; int arr[][] = new int[10][10]; System.out.println("请输入n的值："); n = s.nextInt(); System.out.println("请输入"+n+"x"+n+"个元素："); putNum(n,arr);//输入数组元素 swap(n,arr);//交换最大值和最小值 outNum(n,arr);//输出数组元素 } public static void putNum(int n,int[][] arr) { Scanner s = new Scanner(System.in); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { arr[i][j] = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/180d53cee2af3f808b493efd55d38e2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76fd4e7848c24d7cbabcfda2a77dafa5/" rel="bookmark">
			linux安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一.安全技术和防火墙1 安全技术2.防火墙的分类 二.firewalld服务1.firewalld 介绍2.归入zone顺序3.命令行配置3.1.基础命令3.2.查看现有firewall设置3.3.设置查看默认区3.4.添加源地址（网段）及端口 及服务 三.iptables1.iptables的组成概述2.实际操作查看删除、清空规则 四.band1.命令过程2.脚本设置 五.S/DNAT策略与应用过程1.SNAT2.DNAT 六.tcpdump—Linux抓包 一.安全技术和防火墙 1 安全技术 -入侵检测系统（Intrusion Detection Systems）：特点是不阻断任何网络访问，量化、定位来自内外网络的威胁情况，主要以提供报警和事后监督为主，提供有针对性的指导措施和安全决策依据,类 似于监控系统一般采用旁路部署（默默的看着你）方式。
入侵防御系统（Intrusion Prevention System）：以透明模式工作，分析数据包的内容如：溢出攻击、拒绝服务攻击、木马、蠕虫、系统漏洞等进行准确的分析判断，在判定为攻击行为后立即予以 阻断，主动而有效的保护网络的安全，一般采用在线部署方式。（必经之路）防火墙（ FireWall ）：隔离功能，工作在网络或主机边缘，对进出网络或主机的数据包基于一定的规则检查，并在匹配某规则时由规则定义的行为进行处理的一组功能的组件，基本上的实现都是默 认情况下关闭所有的通过型访问，只开放允许访问的策略,会将希望外网访问的主机放在DMZ (demilitarized zone)网络中. 2.防火墙的分类 按保护范围划分：
主机防火墙：服务范围为当前一台主机网络防火墙：服务范围为防火墙一侧的局域网 按实现方式划分:
硬件防火墙：在专用硬件级别实现部分功能的防火墙；另一个部分功能基于软件实现，如：华为， 山石hillstone,天融信，启明星辰，绿盟，深信服, PaloAlto , fortinet, Cisco, Checkpoint， NetScreen(Juniper2004年40亿美元收购)等软件防火墙：运行于通用硬件平台之上的防火墙的应用软件，Windows 防火墙 ISA --&gt; Forefront TMG
按网络协议划分：
网络层防火墙：OSI模型下四层，又称为包过滤防火墙应用层防火墙/代理服务器：proxy 代理网关，OSI模型七层 二.firewalld服务 1.firewalld 介绍 firewalld是CentOS 7.0新推出的管理netfilter的用户空间软件工具,也被ubuntu18.04版以上所支持(apt install firewalld安装即可)
firewalld是配置和监控防火墙规则的系统守护进程。可以实iptables,ip6tables,ebtables的功能firewalld服务由firewalld包提供
2.归入zone顺序 先根据数据包中源地址，将其纳为某个zone纳为网络接口所属zone纳入默认zone，默认为public zone,管理员可以改为其它zone网卡默认属于public zone,lo网络接口属于trusted zone firewalld支持划分区域zone,每个zone可以设置独立的防火墙规则
已经存在了zone区域使用firewall，就是将特定的流量关联到某个zone中 通过源网段关联zone通过网卡关联zone区域如果两者都没有关联的数据报文，那就会去default zone
3.进入到zone以后，开始匹配zone内的规则
firewalld zone 分类 zone名称默认配置trusted允许所有流量home拒绝除和传出流量相关的，以及ssh,mdsn,ipp-client,samba-client,dhcpv6-client预 定义服务之外其它所有传入流量internal和home相同work拒绝除和传出流量相关的，以及ssh,ipp-client,dhcpv6-client预定义服务之外的其它所有传入流量public拒绝除和传出流量相关的，以及ssh,dhcpv6-client预定义服务之外的其它所有传入流 量，新加的网卡默认属于public zoneexternal拒绝除和传出流量相关的，以及ssh预定义服务之外的其它所有传入流量，属于external zone的传出ipv4流量的源地址将被伪装为传出网卡的地址。dmz拒绝除和传出流量相关的，以及ssh预定义服务之外的其它所有传入流量block拒绝除和传出流量相关的所有传入流量drop拒绝除和传出流量相关的所有传入流量（甚至不以ICMP错误进行回应） 预定义服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76fd4e7848c24d7cbabcfda2a77dafa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a47b1409f48751d7190f6bff2de85b9/" rel="bookmark">
			ERR_SSL_PROTOCOL_ERROR 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（JDD_KK原创）
问题：打开某链接，提示 ERR_SSL_PROTOCOL_ERROR
解决：
控制面板——internet选项——内容——清除SSL状态——刷新链接
PS：我是这种方法成功的，自测。若是此方法不成功，请百度尝试其他方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969b8e973704729ec8df2d3b694cd71e/" rel="bookmark">
			我真太卷了，抖音程序员用代码写圣诞树层出不穷，8年开发经验老码侬都整懵了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12月25号是圣诞节，一个西方节日，大家图个开心就完事了。粘粘节气，给自己的男女朋友送送圣诞礼物增进感情都能理解
送女朋友圣诞树代码是什么鬼
而且，做开发也有8年时间了，你说这画画、设计、构图这些玩意，不都是交给美工、设计师、小姐姐们做的事嘛？ 我们接触最多的无非就是二叉树、B树、红黑树，我寻思着我也不会画圣诞树啊！~~~
那最近湖南下雪了，是不是还要来一场画雪比赛...
真的太卷了！！！最近一打开抖音就能刷到各种：程序员画的圣诞树VS徒弟画的圣诞树....这种类似的，挺无语的。
代码：
from turtle import * import random import time n = 100.0 speed("fastest") screensize(bg='seashell') left(90) forward(3*n) color("orange", "yellow") begin_fill() left(126) for i in range(5): forward(n/5) right(144) forward(n/5) left(72) end_fill() right(126) color("dark green") backward(n*4.8) def tree(d, s): if d &lt;= 0: return forward(s) tree(d-1, s*.8) right(120) tree(d-3, s*.5) right(120) tree(d-3, s*.5) right(120) backward(s) tree(15, n) backward(n/2) for i in range(200): a = 200 - 400 * random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/969b8e973704729ec8df2d3b694cd71e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ecb2c5b9c7d90ec24be2778130ca14/" rel="bookmark">
			音频处理-2 WAV格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后续要将流量中的音频数据转为WAV格式文件，所以本节重点说下WAV格式。
WAV文件是在PC机平台上很常见的、最经典的多媒体音频文件,最早于1991年8月出现在Windows 3.1操作系统上,文件扩展名为WAV,是WaveFom的简写,也称为波形文件,可直接存储声音波形,还原的波形曲线十分逼真。WAV文件格式简称WAV格式是一种存储声音波形的数字音频格式,是由微软公司和IBM联合设计的,经过了多次修订,可用于Windows,Macintosh,Linix等多种操作系统,详述如下。
1 波形文件的存储过程 声源发出的声波通过话筒被转换成连续变化的电信号,经过放大、抗混叠滤波后,按固定的频率进行采样,每个样本是在一个采样周期内检测到的电信号幅度值;接下来将其由模拟电信号量化为由二进制数表示的积分值;最后编码并存储为音频流数据。有的应用为了节省存储空间,存储前,还要对采样数据先进行压缩。
2 WAV文件的编码 编码包括了两方面内容,一是按一定格式存储数据,二是采用一定的算法压缩数据。WAV格式对音频流的编码没有硬性规定,支持非压缩的PCM(Puls Code Modulation)脉冲编码调制格式,还支持压缩型的微软自适应分脉冲编码调制Microsoft ADPCM(Adaptive Differential Puls Code Modulation)、国际电报联盟(International Telegraph Union)制定的语音压缩标准ITUG.711 a-law、ITU G.711-law、IMA ADPCM、ITU G.723 ADPCM (Yamaha)、GSM 6.10、ITU G.721 ADPCM编码和其它压缩算法。MP3编码同样也可以运用在WAV中,只要安装相应的Decode,就可以播放WAV中的MP3音乐。
下面详细介绍一下 WAV 格式文件常见的10种压缩码形式 (Compression Code)。
2.1 PCM/uncompressed Pulse Code Modulation ，脉码调制信号。是模拟音频信号经模数转换（A/D 变换）直接形成的二进制序列，该文件没有附加的文件头和文件结束标志。 Windows的Convert工具可以把PCM音频格式的文件转换成 Microsoft 的 WAV 格式的文件。
PCM 脉码调制数字音频格式是 70 年代末发展起来的， 80年代初由飞利浦和索尼公司共同推出。 PCM 的音频格式也被 DVD-A 所采用，它支持立体声和 5.1 环绕声， 1999 年由DVD 讨论会发布和推出的。
PCM 的采样精度从14bit发展到16bit 、18bit 、20bit 直到 24bit ；采样频率从 44.1kHz发展到 192kHz 。到目前为止 PCM 这种单纯依赖提高采样规格的技术，其可改进的地方已经越来越来小。只是简单的增加 PCM 比特率和采样率，不能从底层改善它的根本问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ecb2c5b9c7d90ec24be2778130ca14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb9a3a08b14f1a38921b3a52b572b2d9/" rel="bookmark">
			102. 二叉树的层序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目代码运行结果总结 题目 ''' Description: 102. 二叉树的层序遍历 Autor: 365JHWZGo Date: 2022-01-19 23:49:10 LastEditors: 365JHWZGo LastEditTime: 2022-01-20 12:13:37 ''' 代码 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ res = [] if root == None: return res def traversal(root,depth): if not root: return [] if len(res) == depth: res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb9a3a08b14f1a38921b3a52b572b2d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f456cca1808f3d4f9f5c7df2787ed128/" rel="bookmark">
			iOS底层系列之＜24＞--Runtime（十一）runtime 方法的API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、方法替换class_replaceMethod - (void)viewDidLoad { [super viewDidLoad]; [self test7]; } void myRun() { NSLog(@"--myRun"); } - (void)test7 { Person *person = [[Person alloc] init]; class_replaceMethod([Person class], @selector(run), (IMP)myRun, "v@:"); [person run]; } 可以使用block
class_replaceMethod([Person class], @selector(run), imp_implementationWithBlock(^{ NSLog(@"block--imp"); }), "v@:"); 2、方法交换method_exchangeImplementations - (void)viewDidLoad { [super viewDidLoad]; [self test7]; } - (void)test7 { Person *person = [[Person alloc] init]; Method runMethod = class_getInstanceMethod([Person class], @selector(run)); Method testMethod = class_getInstanceMethod([Person class], @selector(test)); method_exchangeImplementations(runMethod, testMethod); [person run]; } 3、拦截按钮点击事件应用 #import "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f456cca1808f3d4f9f5c7df2787ed128/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ad38833cac44eae8af48b0c33aa71d/" rel="bookmark">
			moveit的环境感知功能&#43;realsense
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.panda_moveit_config
打开后出现
进入config，修改sensors_kinect_pointcloud.yaml文件
sensors: - sensor_plugin: occupancy_map_monitor/PointCloudOctomapUpdater point_cloud_topic: /camera/depth/color/points //此处修改为rs相机的pointclound话题名称 max_range: 5.0 point_subsample: 1 padding_offset: 0.1 padding_scale: 1.0 max_update_rate: 1.0 filtered_cloud_topic: filtered_cloud 2.通过案例测试
打开moveit_tutorials -&gt; doc -&gt; perception_pipeline -&gt;obstacle_avoidance_demo.launch
&lt;launch&gt; &lt;include file="$(find panda_moveit_config)/launch/demo.launch" /&gt; &lt;!-- Play the rosbag that contains the pointcloud data --&gt; &lt;!--node pkg="moveit_tutorials" type="bag_publisher_maintain_time" name="point_clouds" /&gt; --&gt; #此处使用rosbag播放，而我使用realsense测试，可以这句 &lt;!-- If needed, broadcast static tf for robot root --&gt; &lt;node pkg="tf2_ros" type="static_transform_publisher" name="to_panda" args="0 0 0 0 0 0 world panda_link0"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35ad38833cac44eae8af48b0c33aa71d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f759aa8322c92aa53b5705e6340347c0/" rel="bookmark">
			Http响应码及其含义《转载》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP状态列表
响应码由三位十进制数字组成，它们出现在由HTTP服务器发送的响应的第一行。
响应码分五种类型，由它们的第一位数字表示：
1xx：信息，请求收到，继续处理
2xx：成功，行为被成功地接受、理解和采纳
3xx：重定向，为了完成请求，必须进一步执行的动作
4xx：客户端错误，请求包含语法错误或者请求无法实现
5xx：服务器错误，服务器不能实现一种明显无效的请求
100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）
101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）
200 OK 一切正常，对GET和POST请求的应答文档跟在后面。
201 Created 服务器已经创建了文档，Location头给出了它的URL。
202 Accepted 已经接受请求，但处理尚未完成。
203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。
204 No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。
205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。
206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。
300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。
301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。
302 Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。
出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。
注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求http://host/~user（缺少了后面的斜杠），有的服务器返回301，有的则返回302。
严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。
303 See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。
304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f759aa8322c92aa53b5705e6340347c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4785871eb5426949cd733108b289e4f/" rel="bookmark">
			Spring中JdbcTemplate和JdbcDaoSupport简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【1】JdbcTemplate 为了使 JDBC 更加易于使用, Spring 在 JDBC API 上定义了一个抽象层, 以此建立一个 JDBC 存取框架。
作为 Spring JDBC 框架的核心, JDBC 模板的设计目的是为不同类型的 JDBC 操作提供模板方法. 每个模板方法都能控制整个过程, 并允许覆盖过程中的特定任务. 通过这种方式, 可以在尽可能保留灵活性的情况下, 将数据库存取的工作量降到最低.
① XML配置 &lt;!-- ********配置Spring的JdbcTemplate********* --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; ②使用实例 ① Update String sql = "update customers set name=?,address=? where id=? "; jdbcTemplate.update(sql, "Tom","北京",64); ② BatchUpdate String sql = "insert into customers(name,address,phone) values(?,?,?) "; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;Object[]&gt;(); batchArgs.add(new Object[]{"tom1","北京","1392356824"}); batchArgs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4785871eb5426949cd733108b289e4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc36f2a1a3dc90e176641d98d511dc7/" rel="bookmark">
			Visual Studio Code(VSC) Leetcode插件安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要下载Node.js
在node的官方网站下载，一致next即可
推荐下载大多数人下载的版本，而不是最新版本
https://nodejs.org/en/
然后默认会帮你完成环境变量的写入，不需要手动配
完成了Node.js的基础准备之后，我们就可以开始安装插件了
左侧第一个箭头指向的是vsc的拓展模块，点击进去输入leetcode搜索插件，有很多版本供我们选择，一开始我实验了一下v0.18.0，发现会出现
Error: Command “node “c:\Users.vscode\extensions\leetcode.vscode-leetcode-0.18.0\node_modules\vsc-leetcode-cli\bin\leetcode”,plugin,-i,company” failed with exit code “1”.
的报错，无论如何也进不了登录界面，于是我换了v0.18.1，发现可以正常登录。
下载成功后，左侧边栏会出现第二个箭头所指的leetcode图标，说明安装成功。
接着我们点击进去，有一个sign in图标，代表让你登录
这里有一个坑，leetcode插件默认连接的是海外官网，你输入cn的账号密码是不能登陆成功的，所以我们需要点击地球图标切换为leetcode-cn
于是就可以正常登陆啦
成功的页面如图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c7c9ae15c691a3bf2a172c1977b39d/" rel="bookmark">
			使用Ajax自动获取QQ头像昵称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Ajax自动获取QQ头像昵称 整个过程 QQ失去焦点 -&gt; 取 #QQd的值 -&gt;(url=“https://api.usuuu.com/qq/”+QQ,) 请求返回josn
-&gt;
$("#nickname").val(result["data"].name); $("[name='avatar']").val(result["data"].avatar); 源码： --------------------html------------------------------ &lt;input type="hidden" name="avatar" value="-1&gt; &lt;input id="QQ" type="text" name="qq" placeholder="输入qq号自动获取昵称头像"&gt; &lt;input id="nickname" type="text" name="nickname" placeholder="昵称(必填)"&gt; ----------------------js--------------------------- //#QQ失去焦点 取 #QQ值 请求返回josn -&gt; name=avatar #nickname // 失去焦点 $('#QQ').blur(function() { var QQ = $("#QQ").val(); $.ajax({ url : "https://api.usuuu.com/qq/"+QQ, type: "GET", dataType: "json", success : function(result) { console.log(result["data"].name,result["data"].avatar); $("#nickname").val(result["data"].name); $("[name='avatar']").val(result["data"].avatar); } }); }); 知识点: 1.JSON数据
JSON(JavaScript Object Notation, JS 对象简谱)
是一种轻量级的数据交换格式，比xml更轻巧（由于 JSON 所使用的字符要比 XML 少得多，可以大大得节约传输数据所占用的带宽）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05c7c9ae15c691a3bf2a172c1977b39d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3abb23709eed8c035567ee473661c3b2/" rel="bookmark">
			VMware Workstation 英文改中文界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在控制面板–时间和语言–语言&amp;区域中设置中文简体
感谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac39e473cf8ed5862dba9234dba25113/" rel="bookmark">
			bat 复制文件和文件夹（目录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		copy（只能复制文件） 源文件路径：一个文件、多个文件、一类文件(abc.*)、文件夹下文件（仅文件夹下所有文件，不包含子文件夹）。
目标位置：制定文件名（多文件时会被合并）、文件夹路径内
D:\工作项目文档\wamp&gt;copy /? 将一份或多份文件复制到另一个位置。 COPY [/D] [/V] [/N] [/Y | /-Y] [/Z] [/L] [/A | /B ] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination [/A | /B]] source 指定要复制的文件。 /A 表示一个 ASCII 文本文件。 /B 表示一个二进位文件。 /D 允许解密要创建的目标文件 destination 为新文件指定目录和/或文件名。 /V 验证新文件写入是否正确。 /N 复制带有非 8dot3 名称的文件时，尽可能使用短文件名。 /Y 不使用确认是否要覆盖现有目标文件的提示。 /-Y 使用确认是否要覆盖现有目标文件的提示。 /Z 用可重新启动模式复制已联网的文件。 /L 如果源是符号链接，请将链接复制到目标而不是源链接指向的实际文件。 命令行开关 /Y 可以在 COPYCMD 环境变量中预先设定。这可能会被命令行上的 /-Y 替代。除非 COPY命令是在一个批处理脚本中执行的，默认值应为在覆盖时进行提示。 要附加文件，请为目标指定一个文件，为源指定数个文件(用通配符或 file1+file2+file3 格式)。 例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac39e473cf8ed5862dba9234dba25113/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98ef5604a2c6e6c687630632650f819/" rel="bookmark">
			babel编译ES6报错Cannot find module ‘core-js/modules/web.dom-collections.iterator.js‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案： 降低core-js的版本即可 先删掉node_modules下的core-js文件夹，并删除package-lock.json文件，这文件会锁定版本，导致安装无效。并删掉package.json里core-js的版本（如果有的话）。
// 这个安装完，会装@2的最新版本 "core-js": "^2.6.12" npm install core-js@2 // 降版本之后package.json里core-js的版本是这个： "dependencies": { "core-js": "^2.6.12" }, 如果你的babel配置文件babel.config.json 配置了corejs版本，装完要改为package.json里的版本号，再重新编译你的代码: // babel.config.json 配置文件的内容是官网来的，详见：https://www.babeljs.cn/docs/usage { "presets": [ [ "@babel/env", { "targets": { "edge": "17", "firefox": "60", "chrome": "67", "safari": "11.1" }, "useBuiltIns": "usage", "corejs": "2.6.12" } ] ] } 我这报的这个错，是因为我编译了下面这段es6代码： // a.js function aa(){ console.log('aaaaaa') } const bb = 111; export const cc = 222; // 单个导出 ，导入的写法： import { cc } from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e98ef5604a2c6e6c687630632650f819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9920afa81822acfa3ec5cbf05c045a9/" rel="bookmark">
			Mybatis Log Plugin的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天发现大部分猿友关于查看执行sql语句的方法，只知道将其输出到控制台。然而还有更简便的方法，就是使用插件Mybatis log plugin。这里就简单介绍一下其使用方法。 1.在idea应用市场搜索Mybatis log plugin，进行下载 大部分都能在这里找到，如果没有可以到官网上下载
2.安装之后在工具栏中启动 这里点击之后就会启动，此时下方会有图标显示。
在配置文件中添加下句： mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
3.点击查看，如下图显示（表明启动成功） 4.启动项目，只要控制台有sql打印,我们的mybatis sql log 都会在该控制台将SQL自动拼装打印出来，还可以根据mapper文件中定义的sql_id进行搜索 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03964695af93cc1fd434d13593c4c74/" rel="bookmark">
			【洛谷】B2002 Hello,World（感叹号）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;"Hello,World!"; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cfd70036263a75b093d72d1cdd737de/" rel="bookmark">
			java日期和毫秒值的相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java日期和毫秒值的相互转化 1.日期转毫秒2.毫秒转日期3.日期的格式化方法一：（常用的）需要将日期转为yyyy-MM-dd格式的方法二：使用simpleDateFormat 4.Calendar类 （日期类） 1.日期转毫秒 使用getTime（）方法就可以轻松获取到date类型的毫秒值。注意该Date是util下的。
Date date = new Date(); long l = date.getTime(); 2.毫秒转日期 Date date = new Date(); date2.setTime(1548831395065l); //注意此处毫秒值应该加上l，表示long型数据，否则报错 //补充：获取当前系统时间的毫秒值： System.currentTimeMillis(); new Date.getTime(); 3.日期的格式化 方法一：（常用的）需要将日期转为yyyy-MM-dd格式的 使用DateFormat的format方法即可
DateFormat dateFormat = DateFormat.getDateInstance(); String format = dateFormat.format(date); 方法二：使用simpleDateFormat 一般自己写一个类DateUtil封装好一些格式化日期的方法，simpleDateFormat可以将日期格式化成任意格式的。
/** SimpleDateFormat函数语法： G 年代标志符 y 年 M 月 d 日 h 时 在上午或下午 (1~12) H 时 在一天中 (0~23) m 分 s 秒 S 毫秒 E 星期 D 一年中的第几天 F 一月中第几个星期几 w 一年中第几个星期 W 一月中第几个星期 a 上午 / 下午 标记符 k 时 在一天中 (1~24) K 时 在上午或下午 (0~11) z 时区 */ //第一步：创建simpleDateFormat对象，并指定格式 SimpleDateFormat myFormat=new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cfd70036263a75b093d72d1cdd737de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/220ee5fdf7545fcf3b035ca1bb4e4e00/" rel="bookmark">
			排序算法——冒泡排序系列及性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 初识冒泡排序优化思路思路一思路二 性能测试加餐（鸡尾酒排序） 初识冒泡排序 排序算法常常作为学习算法的入门实践，而冒泡排序又是其中最简单的一种，我们今天的主题就是冒泡排序。它的基本思想就像鱼吐泡泡一样简单。
想象有一条鱼在数组的最底端，每一轮，它就吐个泡泡，泡泡会从数组一端漂到另一端，在漂浮过程中，泡泡会捕获数组中待排序的部分中最大的元素，将其移动到最顶端，然后把这个元素从数组待排序部分中剔除。
下一轮又从剩余的待排序元素中选一个最大的，用泡泡再次将其上浮到最顶端。如此一来，经过n轮吐泡泡。从数组最顶端往下，依次就是最大的元素，第二大的元素，第三大的元素…整个数组就是有序的了，当然，若想要逆序的话，每一轮就挑最小的元素冒泡上去就好了。
一轮冒泡的过程，是通过对相邻两个元素不断地比较和交换，来找到该轮冒泡中最大的元素，并将其移动到顶端的。
具体过程是，想象一个指针，指针指向的元素称为当前元素。指针先指向第一个元素，比较当前元素和下一个元素之间的大小，若当前元素比下一个元素大，则交换当前元素和下一个元素。并把指针后移一个位置，继续和下一个元素比较，一直比到最后一个元素。这样，就完成了第一轮冒泡。第一轮冒泡完毕后，最右侧的元素就是最大的。第二轮冒泡，又从第一个元素开始，依次进行比较和交换，一直比到倒数第二个元素。第二轮结束，右侧倒数第二个元素就是第二大的…N轮冒泡后，整个数组就是从小到大有序的了
图解如下
假设准备对如下数组进行冒泡排序
第一轮冒泡
指针先指向第一个元素，比较当前元素与下一个元素，发现9比5大，那么交换二者
指针后移一位
继续比较当前元素和下一个元素的大小，发现9比7大，交换之
指针继续后移一位，继续比较与交换，最终9被冒泡到最右端，第一轮冒泡结束
第二轮冒泡开始，将指针放在第一个元素，开始重复第一轮的过程（注意第二轮只需要冒泡到倒数第二个位置即可，因为每一轮结束后，最右侧的有序序列的长度都会变长1位）
发现5比7小，则不交换。指针后移
发现7比3大，交换之
指针后移
发现7比1大，交换之…最后，8被冒泡到最右端
继续第三轮，7被冒泡到最右边
第四轮，6到了最右边
…
最后，整个数组有序
根据这个思路，写出代码如下
public void bubbleSort(int[] a) { for(int i = a.length - 1; i &gt;= 0; i--) { for(int j = 0; j &lt; i; j++) { if(a[j] &gt; a[j + 1]) swap(a, j, j + 1); } } } public static void swap(int[] a, int i, int j) { int t = a[i]; a[i] = a[j]; a[j] = t; } 外层循环从数组最后一个位置开始，表示的是每一轮的终结位置（第一轮冒泡到最后一个位置停止，第二轮冒泡到倒数第二个位置停止，以此类推）。内层循环是一轮冒泡的过程，每轮冒泡，从第一个位置开始，依次与后一个位置进行比较和交换，一直进行到该轮冒泡的停止位置。当然，上述代码，只写出了核心部分的实现，并不完善。比如bubbleSort方法内，应该先判断array变量是否为null，swap方法内应该判断array是否为null，并检测i和j是否越界。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/220ee5fdf7545fcf3b035ca1bb4e4e00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab889166175f2d1653cf8ae590fec4c6/" rel="bookmark">
			nginx修改http协议为2.0 &amp; docker添加端口到已运行容器中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx修改http协议为2.0 &amp; docker添加端口到已运行容器中 1、先查看nginx版本 2.0协议的参数为：–with-http_v2_module 如果查看的结果中没有这个参数则目前不支持2.0 后续编译后支持
#进入容器 docker exec -it webpro-nginx bash cd /usr/local/nginx #此命令可查看出nginx版本以及编译参数 ./sbin/nginx -V nginx version: nginx/1.15.2 #停止nginx ./sbin/nginx -s stop 2、编译新nginx 注意：这里 --prefix=这里还是nginx现在安装目录；执行make，不要执行make install
#上传相同版本的源码包到服务器后并解压 docker cp nginx-1.15.2.tar.gz webpro-nginx:/tmp/ docker exec -it webpro-nginx bash cd /tmp tar -zxf nginx-1.15.2.tar.gz cd nginx-1.15.2 #重新编译 ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_realip_module --with-http_gzip_static_module --with-http_v2_module #执行编译 make #在源码包现在目录下objs有个nginx可执行程序复制到nginx目录 cp objs/nginx /usr/local/nginx/sbin/ 3.如果没有正式证书可以生成自定义证书(可选) #创建秘钥目录 mkdir /usr/local/nginx/keys cd /usr/local/nginx/keys #生成一个key，会让输入一个密码，输入密码时候记住密码 openssl genrsa -des3 -out ssl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab889166175f2d1653cf8ae590fec4c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4baa137351a7edf0098349a8daf5f372/" rel="bookmark">
			vs2013调试nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx下载地址
一、新增http模块
1、 新建文件夹以及文件
2、 修改ngx_module.c文件，将新增的文件名加进去：
代码
#include &lt;ngx_config.h&gt; #include &lt;ngx_core.h&gt; #include &lt;ngx_http.h&gt; static ngx_int_t ngx_ext_sunx_handler(ngx_http_request_t *r); static char* ngx_ext_sunx(ngx_conf_t *cf, ngx_command_t *cmd, void *conf); static ngx_command_t ngx_ext_sunx_commands[] = { { ngx_string("hello_world"), NGX_HTTP_MAIN_CONF | NGX_HTTP_SRV_CONF | NGX_HTTP_LOC_CONF | NGX_HTTP_LMT_CONF | \ NGX_CONF_NOARGS, ngx_ext_sunx, NGX_HTTP_LOC_CONF_OFFSET, 0, NULL }, ngx_null_command }; static ngx_http_module_t ngx_ext_sunx_module_ctx = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }; ngx_module_t ngx_ext_sunx_module = { NGX_MODULE_V1, &amp;ngx_ext_sunx_module_ctx, ngx_ext_sunx_commands, NGX_HTTP_MODULE, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NGX_MODULE_V1_PADDING }; static void testList(ngx_pool_t *pool); static char *ngx_ext_sunx(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) { ngx_http_core_loc_conf_t *clcf; clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); clcf-&gt;handler = ngx_ext_sunx_handler; testList(cf-&gt;pool); return NGX_CONF_OK; } static ngx_int_t ngx_ext_sunx_handler(ngx_http_request_t *r) { ngx_int_t rc = ngx_http_discard_request_body(r); if (rc !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4baa137351a7edf0098349a8daf5f372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef7a3eae01da87153d8075883769f91/" rel="bookmark">
			蓝桥杯：激光样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：
简单dp，对于每一台激光器，能不能开取决于前一台激光器能不能开，记dp[i][j]，表示第i台激光器的状态，j=0时表示激光器关闭，j=1时表示激光器开启，dp[i][j]表示激光器在该状态下共有几种样式，很容易得出状态转移方程dp[i][0] = dp[i-1][0] + dp[i-1][1]; dp[i][1] = dp[i-1][0];
把最后一次dp的两种状态相加就能得到正确结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74554a42481b5ff580fd65f64db3dc6b/" rel="bookmark">
			GIS可视化数据库Echarts介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是ECharts？ ECharts，是一个使用 JavaScript 实现的开源可视化库，之前给大家介绍过GIS开发中常用的JavaScript库，没看过的可以点这里。
可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。
为什么要学ECharts？ 在GIS开发中，ECharts是不容忽视的一个重要工具，可以用于大屏地图可视化数据展示，比如疫情防控指挥、智慧交通、智慧城市等。
ECharts提供直观、交互丰富可高度个性化定制的数据可视化图标和常规的折线图、柱状图、散点图、饼图、K线图等，非常契合当前GIS平台对统计图功能的使用要求，实现统计功能的思路就是将ECharts开源包融合进GIS平台，并给统计功能使用者提供简单易用的调用接口。
​
ECharts下载地址： ECharts下载
ECharts API
ECharts示例
领取ECharts课程和资料https://www.wjx.cn/vj/wFr2wz0.aspx
ECharts需求大 很多Web前端开发相关的岗位都需要会使用ECharts，包括WebGIS开发岗位。
​
​
​
领取ECharts资料课程： 领取ECharts课程和资料https://www.wjx.cn/vj/wFr2wz0.aspx
​
​
31个惊艳的数据可视化案例 1.新冠疫情防控指挥系统 有整体视频动效，结合柱状图、饼状图、折线图及地图等
2.数据可视化演示系统 既有动效又有科技光感，结合柱状图、饼状图、折线图及地图等
​
​
3.数据可视化页面设计 动效精美，结合柱状图、水球图、折线图等主要图表
​
4.服务大数据可视化监管平台 由多个不同的图表组合而成，且图表带有动画效果。主要图表有树形面积图、柱状图、环形图、雷达图等。
5.智能看板 左侧有个滑动的信息流列表，中间有个飞线图，动态效果，让整体看起来更加引人注目。主要图表有地图、曲线图，饼图、柱状图等。
​
由于案例太多，在此仅以图片概览的形式简单展开，想要获取31个案例及源代码的，文末直接填写资料。
GIS开发系列公开课 数据可视化开发 看到如此多酷炫的数据可视化案例，是不是也想动手制作出类似的大图？那你一定要关注数据可视化开发课程！
领取ECharts课程和资料https://www.wjx.cn/vj/wFr2wz0.aspx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa0fe2f06d9e7252e9b23bd09f232cf/" rel="bookmark">
			iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 8080...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Error response from daemon: driver failed programming external connectivity on endpoint relaxed_villani (711bd28c90ddc10a2cb2771e599fec3fda0dfb2a2fb80885a5077009efb4edff): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 8080 -j DNAT --to-destination 172.17.0.3:80 ! -i docker0: iptables: No chain/target/match by that name.
重启docker
systemctl restart docker 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/171/">«</a>
	<span class="pagination__item pagination__item--current">172/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/173/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>