<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea20ec666ee98e1808b79db87388012/" rel="bookmark">
			最优化-黄金分割法 原理及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.黄金分割法介绍 黄金分割法，也叫0.618法，主要用于单峰函数，通过不断地分割迭代，从而找到近似于最小值的函数值。
1.1单峰函数： 如图所示，
设f(x)是定义在D上的实值函数，如果存在，使得对D中当任何时，，当时有,那么就说是定义在D上的单峰函数
1.2算法原理 为了找出最小点，我们通过不断试探的方法，首先我们需要给定区间，然受在给定区间内取两点
,
黄金分割的核心原理就是在于对点的选取：
对于x_1和x_2的选取分为以下两种情况：
通过两式的不断迭代，a，b在逐渐靠近，我们设置一个精度epi，当
停止迭代。
2.代码实现 2.1输入函数 我们自己定义区间a，b的值，并且输入所要求的方程形式如（x^2 + 5*x +2）
a = float(input("初始左端点")) b = float(input("初始右端点")) def function(a): fx = str_fx.replace("x", "a") # 所有的"x"换为方法所输入的参数a return eval(fx) #eval类型用于对字符串公式进行转换 init_str = input("请输入一个函数，默认变量为x：\n") # 输入的最初字符串 str_fx = init_str.replace("^", "**") # 将所有的“^"替换为python的幂形式"**" 2.2画出函数并判断是否为单峰函数 通过定义drawf函数，并且传入参数a，b和间隔interp，来画出图像，通过图像判断是否可以使用黄金分割法进行一维线性搜索。
from pylab import * def drawf(a, b, interp): x = [a+ele*interp for ele in range(0, int((b-a)/interp))] y = [function(ele) for ele in x] # y = [function(x)] plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ea20ec666ee98e1808b79db87388012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aafd389d9a7fcbc72d65a985c325c364/" rel="bookmark">
			c语言实现：输入一个字符串,再输入一个字符，在字符串中删除输入的字符,形成新的字符串并输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开始学遇到的一个小问题
先上代码：
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
int main()
{
char s[100], ch;
int i;
gets(s);
scanf_s("%c", &amp;ch);
for (i = 0; i &lt; strlen(s); i++) {
if (s[i] != ch) {
printf_s("%c", s[i]);
}
}
printf_s("\n");
return 0;
}
程序使用了 gets 函数读入字符串（注意，gets 函数不安全，在实际开发中应该使用 fgets 函数代替），然后使用 scanf_s 函数读入一个字符，并遍历字符串逐个比较每个字符是否等于该字符。
如果字符相等，则忽略该字符；否则，使用 printf_s 函数输出该字符。最后，程序使用 printf_s 函数输出一个换行符，并返回 0 表示正常退出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1a1df217c3d73037b20254506c9dfa/" rel="bookmark">
			最新版WSL启用Systemd和配置固定网络[WSL2.04]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新版WSL启用Systemd和配置固定网络[WSL2.04] WSL的安装最新版本：wsl --update --pre-release 可以让WSL更新到2.0以上
现在最新已到2.05
启用systemd WSL2.0已支持Systemd,通过在子系统中配置wsl.conf来启用
子系统中配置启用systemd脚本
vi /etc/wsl.conf 配置内容如下: [boot] systemd=true [network] generateResolvConf=false 配置后重启重新进入子系统使配置生效
wsl --shutdown
wsl -d CentOS8
配置固定IP WSL的网络模式默认为NAT模式，以下内容仅是NAT模式下的固定IP配置，mirrored（镜像网络模式）下目前未研究出来，有经验的童学可以告知下
wsl的版本
&gt;wsl --version WSL 版本： 2.0.4.0 内核版本： 5.15.123.1-1 WSLg 版本： 1.0.58 MSRDC 版本： 1.2.4485 Direct3D 版本： 1.608.2-61064218 DXCore 版本： 10.0.25880.1000-230602-1350.main Windows 版本： 10.0.22621.2428 设置子系统添加固定IP地址
先进入子系统查看WSL NAT网络模式下默认初始的网络接口和IP网段 C:\Users\Administrator&gt;wsl -d CentOS8 [root@VPC-CentOS8 Administrator]# ifconfig eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.97.175 netmask 255.255.240.0 broadcast 172.31.111.255 inet6 fe80::215:5dff:fe83:5152 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:15:5d:83:51:52 txqueuelen 1000 (Ethernet) RX packets 66 bytes 7174 (7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d1a1df217c3d73037b20254506c9dfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05432d189017b04d69ac05033dfd349e/" rel="bookmark">
			快速上手vue elementUI好看的登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个非常非常适合新手的vue登录界面，总体来说美观大气，axios那部分没有发，有需要的大家可以自己进行二次开发，继续编写。
用到了技术栈有
vue/cli 5.07 + element-ui 2.15.9
适合入门级新手，展示下页面
emmm验证码，什么的可以等有兴趣的人二次开发
好下面来讲述具体如何来实现这个页面。
一、创建vue项目 使用vue的脚手架创建项目，然后把不需要的内容删去，可以看到页面如下：
需要注意的是你创建时候需要去勾选router选项,如果不勾选的话未来会很麻烦，需要自己重新配置下载，如何创建vue项目，可以翻找我的博文，我的博文里面有记载。
二、引入依赖 把需要的依赖引入，这里我不打算讲太深，就是很简单的把element-ui依赖下载
具体怎么下载打开terminal，输入指令npm install element-ui -S就可以下载，下载完可以在package.json可以看到
我这里有个axios不用在意，因为我实现了前后端互联，所以对于基础功能而言这些是不需要注意的
三、改造下项目 app.vue改造成如下样式
router下的index.js需要改变下，因为新的页面为Login.vue
在assets下加入名为background的图片，图片已取出放在下面了
对了差点忘了要改一下main.js
代码如下：
import Vue from "vue"; import router from "./router"; import ElementUI from 'element-ui'; import App from './App.vue'; import 'element-ui/lib/theme-chalk/index.css'; Vue.use(ElementUI); Vue.config.productionTip = false; new Vue({ router, render: (h) =&gt; h(App), }).$mount("#app"); 还有就是驼峰法则查的很严，
要在vue.config.js上
控制下摆脱这东西，
代码如下：
`const { defineConfig } = require(“@vue/cli-service”); module.exports = defineConfig({ transpileDependencies: true, lintOnSave: false, }); 四、写入Login视图 在views下创建Login.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05432d189017b04d69ac05033dfd349e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17a788cc833977e3ea4943e5590f495/" rel="bookmark">
			Vue.js devtools的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue.js是一种流行的JavaScript框架，用于构建现代化的Web应用程序。
它提供了一个高效、灵活和可扩展的开发环境，使开发人员能够更轻松地构建复杂的前端应用。 Vue.js的强大之处在于其丰富的生态系统和令人惊叹的开发工具，其中之一就是Vue.js devtools。 Vue.js devtools是一个用于调试和分析Vue.js应用程序的浏览器扩展工具。
无论是在开发过程中还是在生产环境中，Vue.js devtools都能为开发人员提供丰富的调试功能，帮助他们更快地定位和解决问题。
Vue.js devtools提供了一个交互式的组件树，显示了应用程序中所有Vue组件的层次结构。开发人员可以通过展开和折叠组件来查看组件之间的父子关系，并且可以查看每个组件的实例属性、状态和计算属性。这对于理解组件之间的数据流和组件的层次结构非常有帮助，有助于更好地组织和管理代码。
Vue.js devtools还提供了一个事件追踪器，允许开发人员查看和调试应用程序中的所有事件。开发人员可以查看事件的名称、触发组件以及事件的详细信息。这对于追踪事件的触发和处理非常有用，帮助开发人员确保事件的正确传递和处理。
Vue.js devtools还提供了一个状态快照功能，允许开发人员捕获应用程序的当前状态并进行比较。开发人员可以在不同的时间点捕获快照，并在两个快照之间比较状态的变化。这对于调试数据状态的变化和追踪bug非常有用，特别是在应用程序变得复杂时。
Vue.js devtools还提供了一些其他有用的工具，如性能监控、路由检查和组件源代码查看等。这些工具可以帮助开发人员更全面地了解应用程序的性能和运行情况，并帮助他们优化应用程序的性能和用户体验。
Vue.js devtools是一个不可或缺的开发工具，可大大简化Vue.js应用程序的调试和分析过程。它提供了丰富的功能，帮助开发人员更好地理解和管理应用程序的组件、事件和状态。无论是初学者还是经验丰富的开发人员
Vue.js devtools都是一个必备的工具，可以提高开发效率和代码质量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6fd1793693b0ca49f4d3cc02325bb4/" rel="bookmark">
			rosbag数据解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
rosbag的数据需要解析才能可视化，故本文借助Helios_5515激光雷达录制XYZIRT格式的rosbag，以研究以XYZIRT储存的数据。
1.pcd头文件含义
以下是录制的rosbag转成的pcd，PCD文件必须用ASCII字符编码。文件格式头（file format header）说明文件中存储的点云数据的格式。每个格式声明及点云数据之间用\n字符隔开。
# .PCD v0.7 - Point Cloud Data file format VERSION 0.7//PCD文件版本 FIELDS x y z intensity ring timestamp//每个点包含哪些维度，xyz表示XYZ三维坐标，intensity表示激光反射强度，ring表示线号，timestamp表示时间戳 SIZE 4 4 4 4 2 8//每个维度的数据占用字节大小 TYPE F F F F U F//每个维度的数据类型，I表示有符号类型int8（char）、int16(short)、int32(int)，U表示无符号类型uint8(unsigned char)、uint16(unsigned short)、uint32(unsigned int)，F表示浮点型,包括float,double,long double COUNT 1 1 1 1 1 1//每个维度含有多少个元素（如果未提供COUNT属性，默认值为1） WIDTH 32//用点的数量表示点云数据集的宽度。有两种含义：1.无序数据集的点云中点的数量 2.有序点云数据集的宽度（一行中点的数量），有序点云数据集中，点云类似图片或矩阵的结构，分为行和列，这种数据通常来自于立体摄像机（stereo camera）、时间飞行摄像机（Time Of Flight camera，使用红外线或者光脉冲来估计光线从发射到检测到的时间延迟来测量距离），知道点的相邻关系，使算法计算更高效。 VIEWPOINT 0 0 0 1 0 0 0//指定数据集合中点的采集视点。可以用来后续可能的坐标转换，或者求平面法线坐标。格式是平移(tx ty tz) + 四元数(qw qx qy qz)，默认是0 0 0 1 0 0 0。 POINTS 57600//点云中点的总数（冗余字段） DATA binary//点云数据的存储类型，0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a6fd1793693b0ca49f4d3cc02325bb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54a37bfa792836237ad8beeacfd4f76/" rel="bookmark">
			解决fastapi项目使用conda新创建的虚拟环境报错：ImportError: DLL load failed while importing _ssl: 找不到指定的模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 针对于网上各种解决这个问题的方法对我无效，因此记录一下自己的解决问题方法
很简单 改变虚拟环境中python的版本
原本使用的python环境是3.9.12，后更改为3.9.18解决问题
附上报错图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf3be01a42d00918754af3a11b5a982/" rel="bookmark">
			微信小程序中不能将类型“string”分配给类型“Record＜string, any＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 源码问题 解决方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c6f6de7aba9c2c949b0a996f6ce698/" rel="bookmark">
			微信小程序订阅消息及遇到的种种坑解决方法（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同点
与「模板消息」不同的是，其是在用户点击触发或者支付成功之后，开发者可在 7天内推送1-3条服务通知。而「订阅消息」则需要用户主动订阅消息通知，开发者才可向用户推送，但不受时间限制，具体发送信息条数根据该能力的不同类型有不同标准。
此外，值得注意的是，使用「订阅消息」后，原小程序模板消息接口将于2020年1月10日下线，也就无法再使用原接口推送模板消息，开发者们需要注意及时调整接口。但是，微信服务号模板消息暂不受影响。
特点
1、选择权回到用户手中。在小程序中，「订阅消息」像是一个开关，需要用户主动点击授权之后，小程序才能向其推送服务通知，当然，用户也可以随时拒收该小程序的服务通知。而此前，用户只能被动地接收消息。
2、时长不受限制。「订阅消息」取消了7天内推送消息的时间限制，只要用户没有主动拒收消息推送，开发者就可以随时推送服务通知。对于服务周期超过7天的小程序而言，这就完美解决了此前的疑虑。
好了那我们来看看如何使用这个订阅消息吧~
简述大概流程
小程序端发起的授权弹窗过程
顺便说一下如何获取用户授权信息wx.getting，及当用户关闭授权如何跳到设置授权页一条龙服务，附上其他诸多问题
授权后服务端下发订阅消息流程
整理一下订阅发送各参数的具体意思，虽然文档有，但是有例子的话对着看更好理解
搜集解疑各种疑难杂症
小程序端发起的授权弹窗过程
调起客户端小程序订阅消息界面，返回用户订阅消息的操作结果。当用户勾选了订阅面板中的“总是保持以上选择，不再询问”时，模板消息会被添加到用户的小程序设置页，通过 wx.getSetting 接口可获取用户对相关模板消息的订阅状态。
留意文档中的这句话 → 如果用户之前设置过不在询问的话，其实是调不起授权弹窗的，那我们怎么获取用户的授权信息呢？
wx.getSetting可以获取这些信息：对应的wx.getting文档
文档后面有示例代码这边就不在贴出来了
如果要获取 订阅消息的订阅状态 需要设置 withSubscriptions 为true即可（默认为false，不开不获取），成功获取后 authSetting 是有关于用户的一些权限，而 subscriptionsSetting 则是我们需要的订阅权限信息，里面有一个总开关 mainSwitch 就是你是否接受当前小程序的订阅信息，如果这个为false的话其实你根本调不起弹窗，那小伙伴就会问如果我要让他知道关闭了权限并且怎么引导他去开呢？
先贴出代码：
发送订阅消息逻辑处理
const SUBSCRIBE_ID = 'RHPuVfEyGe0q0n7lZyzz4r-zyGe07lZyzz4r3' // 模板ID goCollectSet() { let that = this; if (wx.requestSubscribeMessage) { wx.requestSubscribeMessage({ tmplIds: [SUBSCRIBE_ID], success(res) { if (res[SUBSCRIBE_ID] === 'accept') { // 用户主动点击同意...do something } else if (res[SUBSCRIBE_ID] === 'reject') { // 用户主动点击拒绝.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5c6f6de7aba9c2c949b0a996f6ce698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf3d9511f8d85056f681f58647df4107/" rel="bookmark">
			RK3568 RTL8821cs适配 WPA3连接 与 WPA3热点配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kernel：4-19
SOC：RK3568
system：Android12
模组：RTL8821CS
调试手段可以看之前的正基AP6256
一.驱动配置：
首先设备树配置如下:
因为 SDIO 电压是1.8V，必须加上sd-uhs-sdr104;
&amp;sdio_pwrseq{ compatible = "mmc-pwrseq-simple"; clocks = &lt;&amp;pmucru CLK_RTC_32K&gt;; pinctrl-names = "default"; pinctrl-0 = &lt;&amp;wifi_enable_h&gt;; /* * On the module itself this is one of these (depending * on the actual card populated): * - SDIO_RESET_L_WL_REG_ON * - PDN (power down when low) */ post-power-on-delay-ms = &lt;200&gt;; reset-gpios = &lt;&amp;gpio0 RK_PC0 GPIO_ACTIVE_LOW&gt;; status = "okay"; }; //sdio &amp;sdmmc1 { max-frequency = &lt;150000000&gt;; supports-sdio; bus-width = &lt;4&gt;; cap-sd-highspeed; cap-sdio-irq; keep-power-in-suspend; mmc-pwrseq = &lt;&amp;sdio_pwrseq&gt;; non-removable; pinctrl-names = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf3d9511f8d85056f681f58647df4107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6da91a4e88ecc22198ea79826eab44/" rel="bookmark">
			视频怎么在线生码？多格式视频制作活码技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​视频活码怎么生成呢？活码是现在很多制作二维码的小伙伴会选择的一种类型，其优点在于能够随时在二维码图案不变的情况下，修改二维码中的内容，让二维码能够长期使用。那么当需要将视频生成二维码时，视频制作活码有什么操作方法吗？下面就教大家在线制作活码二维码的操作方法。
用360或者谷歌浏览器搜索机智熊二维码，点击首页的【音视频】，上传本地音视频文件。
上传后系统自动转码，耐心等待转码完成，点击生成二维码按钮。
程序自动将视频转二维码，下载使用就可以通过扫码播放音视频。
视频活码二维码制作只需按上面的步骤就可以完成，简单操作适合新手使用，有需要的小伙伴快上传视频自己动手制作感受一下吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e7e80279fb57f52c25b4370b2ab537/" rel="bookmark">
			PIL.Image和cv2.imread读取图片区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PIL.Image和cv2.imread读取图片区别 PIL.Image和cv2.imread读取图片区别 PIL.Image和cv2.imread读取图片区别 PIL.Image读取图片后是RGB
cv2.imread读取图片后是BGR
训练最终需要RBG，所以cv2.imread读取图片后需要从BGR转化成RGB
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b84e15cc770a0b9221bc1187ec870602/" rel="bookmark">
			SQL注入（DVWA靶场搭建及使用、sqlMap注入、sqlmap问题及解决办法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlmap使用教程 1、客户端向服务端请求的流程
2、SQL注入常见分类
3、SQL注入常见过程
4、SQL注入的作用
5、常用SQL测试语句
注释字符：
DVWA靶场搭建及使用（详细图文） 一、下载DVWA
下载地址：DVWA/README.zh.md at master · digininja/DVWA · GitHub
这里我是从GitHub上下载的，小伙伴们自行选择
二、安装DVWA
在安装前，需要做一个准备工作，我们先去做一个PHP+Mysql的环境搭建。
1.下载、安装、启动phpstudy，小皮面板(phpstudy) - 让天下没有难配的服务器环境！
（phpStudy是一个PHP调试环境的程序集成包。恰好我们可以用到"PHP+Mysql+Apache"。）
注意开启apache和mysql
2、将下载的DVWA解压到phpstudy网站根目录下。
例如：我这解压后的路径是“D:\phpStudy\WWW\DVWA-master\”（这里为了后面进入目录方便，我会将文件名改成DVWA）
3、将 config.inc.php.dist 复制一份或重命令为 config.inc.php；
例如：我的配置文件路径是“D:\phpStudy\WWW\DVWA-master\config”。
注意：有的小伙伴操作系统可能会默认不显示文件后缀名，改为显示后缀名之后再重命名文件类型 config.inc.php.dist→config.inc.php。这步必须做。
4、修改 config.inc.php 里代码如下：
$_DVWA[ 'db_server' ] = '127.0.0.1'; #数据库地址
$_DVWA[ 'db_database' ] = 'dvwa'; #数据库名称
$_DVWA[ 'db_user' ] = 'root'; #数据库用户名
$_DVWA[ 'db_password' ] = 'root'; #数据库密码
因为phpstudy默认的mysql数据库地址是“127.0.0.1 或 localhost"，用户名和密码都是"root"。主要是修改’db_password‘为root，这里很重要，修改后自然是需要保存文件的。
三、DVWA使用
1、设置或重置数据库
浏览器只需要直接打开“http://搭建环境的系统ip/DVWA-master/setup.php”即可！如果有”标红“提示，可能你要打开一些模块或做一些设置，否则有些是不能实验的，例如：文件包含、文件上传漏洞。
如：红色字体显示“DVWA-PHP function allow_url_include: Disabled”错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b84e15cc770a0b9221bc1187ec870602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7287a78bd6f1135128867f1ad132385/" rel="bookmark">
			docker和k8s基础介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 Docker介绍 1.1 docker是什么 Docker 是一个开源项目， 诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0协议， 项目代码在 GitHub 上进行维护。Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容（ LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装， 让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。
官方解释:
1.2 为什么要用docker 作为一种新兴的虚拟化方式， Docker 跟传统的虚拟化方式相比具有众多的优势。首先， Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。具体说来， Docker 在如下几个方面具有较大的优势:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7287a78bd6f1135128867f1ad132385/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a9e378fb0c6fe0ab94864f8982c88f1/" rel="bookmark">
			实现Linux下Word转PDF、Java调用命令方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 LibreOffice 实现 Word 转 PDF 和 Java 调用命令 1、 安装 LibreOffice 外网安装 # 一键安装 yum install -y libreoffice # 验证版本 libreoffice --version # Warning: -version is deprecated. Use --version instead. # LibreOffice 7.5.6.2 f654817fb68d6d4600d7d2f6b647e47729f55f15 内网安装
官网下载，找最新版本
使用版本拼接本地下载
https://download.documentfoundation.org/libreoffice/stable/7.5.6/rpm/x86_64/LibreOffice_7.5.6_Linux_x86-64_rpm.tar.gz https://download.documentfoundation.org/libreoffice/stable/7.5.6/rpm/x86_64/LibreOffice_7.5.6_Linux_x86-64_rpm_langpack_zh-CN.tar.gz https://download.documentfoundation.org/libreoffice/stable/7.5.6/rpm/x86_64/LibreOffice_7.5.6_Linux_x86-64_rpm_helppack_zh-CN.tar.gz 下载完成放到内网服务器上
# 安装软件包 tar -zxvf LibreOffice_7.5.6_Linux_x86-64_rpm.tar.gz cd LibreOffice_7.5.6.2_Linux_x86-64_rpm/RPMS/ rpm -ivh *.rpm # 安装中文语言包 tar -zxvf LibreOffice_7.5.6_Linux_x86-64_rpm_langpack_zh-CN.tar.gz cd LibreOffice_7.5.6.2_Linux_x86-64_rpm_langpack_zh-CN/RPMS/ rpm -ivh *.rpm # 安装离线帮助文档 tar -zxvf LibreOffice_7.5.6_Linux_x86-64_rpm_helppack_zh-CN.tar.gz cd LibreOffice_7.5.6.2_Linux_x86-64_rpm_helppack_zh-CN/RPMS/ rpm -ivh *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a9e378fb0c6fe0ab94864f8982c88f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d24f89050361f796dcf030acafe8f80/" rel="bookmark">
			Java中Stream流式编程从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.简介特性 1.Java8开始引入，支持链式书写；
2.存在惰性计算，短路操作，可消费性，所以性能上要优于传统编程；
(1).惰性计算:流的元素只在需要时才进行计算，不会提前计算整个流;
(2).短路操作:类似于 &amp;&amp; ，|| 前面满足条件，后面的计算直接略过；
(3).可消费性:流只能被消费一次，即每个元素只能被处理一次;
3.流在管道中流通，在节点被处理；
4.流【无存储】，流不是一种数据结构，流存储的只是一种数据视图；
5.对于无限序列，如果直接调用 forEach() 或者 count() 求最终值，会直接进入死循环，因为无限序列永远不可能被计算完。所以我们需要先将起转变为有序序列，例如 limit(100) ;
6.并行计算: Stream 为单线程，当我们要使用多线程时，直接使用 parallel() ，自动转化多线程。
二.使用 1.常用操作关键字： 中间操作最终操作map映射，转换forEach遍历filter从头截取到指定索引位置collectcount：返回元素个数skip从指定的索引后一位截取到最后 数
学
（聚合）
计
算
count：返回元素个数sorted排序max:找出最大元素distinct去重min:找出最小元素concat合并流sum:求总和flatMap平面化处理sverage:求平均limit从头截取到指定索引位置 mapToInt
mapToDoube
mapToLong
转成整型流
转成小数流
转成长整型流
2.创建使用： （1）of()创建： Stream&lt;Integer&gt; intStream = Stream.of(1, 2, 3, 4, 5); intStream.forEach(System.out::println); （2）使用集合： //1.创建list集合 转成流 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { list.add(i); } //转成流 list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d24f89050361f796dcf030acafe8f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/890a5f15228a0dc36db2d8011b312314/" rel="bookmark">
			【215. 数组中的第K个最大元素】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、题目描述二、算法原理三、代码实现 一、题目描述 二、算法原理 三、代码实现 class Solution { public: int getRandom(int left,int right,vector&lt;int&gt;&amp; nums) { return nums[rand()%(right-left+1)+left]; } int qsort(int l,int r,vector&lt;int&gt;&amp; nums,int k) { if(i==r) { return nums[l]; } int key=getRandom(l,r,nums); int i=l,left=l-1,right=r+1; while(i&lt;right) { if(nums[i]&lt;key) swap(nums[++left],nums[i++]); else if(nums[i]&gt;key) swap(nums[i],nums[--right]); else i++; } int c=r-right+1,b=right-left-1,a=left-l+1; if(c&gt;=k) { return qsort(right,r,nums,k); } else if(b+c&gt;=k) return key; else { return qsort(l,left,nums,k-b-c); } } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { srand(time(NULL)); return qsort(0,nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/890a5f15228a0dc36db2d8011b312314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c3dfd8eb0d3e84206048adc0feb46c0/" rel="bookmark">
			怎么去Maven公共仓库下载自己想要的jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00
在软件开发中，我们经常需要使用第三方库或框架来加速开发进程。而 Maven 公共仓库是一个非常有用的资源，它提供了大量的开源软件包供我们使用。
0x01：访问 Maven Central Repository 网站
首先，打开的浏览器，并访问 Maven Central Repository 网站（https://mvnrepository.com/）。这是一个非常流行和常用的 Maven 仓库，提供了广泛的第三方库和框架。
0x02：搜索所需的 JAR 包
在 Maven Central Repository 的首页上，可以看到一个搜索框。在搜索框中输入需要下载的 JAR 包的名称，以 "shiro-web" 为例。
0x03：选择合适的版本
搜索结果页面将会显示与关键词匹配的所有 JAR 包信息。可以看到每个 JAR 包的名称、版本号、描述和相关链接。根据需求，选择合适的版本号。比如，选择 "shiro-web-1.10.0.jar"。
0x04：下载 JAR 包
在选择的 JAR 包版本页面中，将看到一个 "Files" 标签页。点击该标签页，将看到可用的下载选项（通常有多个选项，如源码、文档等）。找到并点击想要的 JAR 包下载链接。也可以复制mvn的配置信息。
0x05：将 JAR 包添加到项目中
一旦下载完成，将下载的 JAR 包文件复制到项目目录中。然后，在项目构建工具（如 Maven、Gradle 等）的配置文件中，将该 JAR 包添加为依赖项。以 Maven 为例，在项目的 pom.xml 文件中，找到 `&lt;dependencies&gt;` 标签，并添加以下代码：
&lt;dependency&gt; &lt;groupId&gt;组织ID&lt;/groupId&gt; &lt;artifactId&gt;项目ID&lt;/artifactId&gt; &lt;version&gt;版本号&lt;/version&gt; &lt;/dependency&gt; 替换上述代码中的 `组织ID`、`项目ID` 和 `版本号` 为下载的 JAR 包的实际信息。保存文件后，项目构建工具将自动下载并添加该 JAR 包到项目中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c3dfd8eb0d3e84206048adc0feb46c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2478b0891711daef9f505f9056c11ad/" rel="bookmark">
			ERR_PNPM_LINKING_FAILED Error: EPERM: operation not permitted, rename
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webstorm终端pnpm报错
ERR_PNPM_LINKING_FAILED Error: EPERM: operation not permitted, rename ’
报错原因：powershell权限不够
解决办法：提升权限/在文件打开Powershell安装依赖
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9715e8a6c20f71fc9bd370d9f4e43c26/" rel="bookmark">
			RxJavaCallAdapterFactory默认实现异步调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认添加异步调度 重复的异步调度代码：
设计给Retrofit代理的Flowable 和 Observable的对象默认添加异步调度
Sevice.XXX()
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.subscribe();
根据RxJava2CallAdapterFactory的get方法返回一个CallAdapter的实现类RxJava2CallAdapter，其adapt 方法经过处理得到我们需要的可以操作的对象observable 或者Flowable等
源码分析 final class RxJava2CallAdapter&lt;R&gt; implements CallAdapter&lt;R, Object&gt; { @Override public Object adapt(Call&lt;R&gt; call) { Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Observable&lt;?&gt; observable; if (isResult) { observable = new ResultObservable&lt;&gt;(responseObservable); } else if (isBody) { observable = new BodyObservable&lt;&gt;(responseObservable); } else { observable = responseObservable; } if (scheduler != null) { observable = observable.subscribeOn(scheduler); } if (isFlowable) { return observable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9715e8a6c20f71fc9bd370d9f4e43c26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26a4bb8aab812eb81211a72f917d7bc/" rel="bookmark">
			为什么trim出来的aaa与字符串aaa不双等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探究 public static void main(String[] args) { String a = "aaa"; String b = "12aaa"; String c = " aaa"; String d = "aaa"; System.out.println(b.substring(2, b.length()) == a);// 运行结果:false System.out.println(c.trim() == a);// 运行结果:false System.out.println(d == a);// 运行结果:true } //原因:
String是一种特殊的包装类, 可以通过俩种方式创建
String a = "aaa"
String a = new String("aaa");
第一种方式创建有以下几个步骤: 先在栈中创建一个引用变量String a;
在常量池中查找有没有存放aaa
如果存在, 直接将变量a指向aaa
如果不存在, 则在常量池中创建一个aaa, 并将变量a指向aaa
第二种方式创建有以下几个步骤:
在堆中创建一个对象aaa, 并将变量a指向堆中的aaa
在常量池中查看是否有aaa的字符串对象
如果存在, 将堆中的aaa对象与常量池中的aaa联系起来
如果不错在, 则在常量池中创建一个aaa的字符常量, 再将堆中的aaa对象与常量池中的aaa联系起来
而trim()和substring()内部都是返回的string的一个copy的对象, 即是通过new String()产生的新的对象, 地址不一样, 所以==出来是false;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d26a4bb8aab812eb81211a72f917d7bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2869200d2ac7f73f8601f40382c4b468/" rel="bookmark">
			书单｜1024程序员狂欢节充能书单！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击链接进入图书专题
1024程序员节
“IT有得聊”是机械工业出版社旗下IT专业资讯和服务平台，致力于帮助读者在广义的IT领域里，掌握更专业、更实用的知识与技能，快速提升职场竞争力。 点击蓝色微信名可快速关注我们。
一年一度的1024程序员狂欢节又到啦！成为更卓越的自己，坚持阅读和学习，别给自己留遗憾，行动起来吧！
那么，都有哪些好书值得入手呢？小编为大家整理了前沿技术、人工智能、集成电路科学与芯片技术、新一代信息与通信技术、网络空间安全技术，四大热点领域近期的好书排行，希望能帮忙你做出选择。
重磅推荐
当季新书
1. 速学Linux：系统应用从入门到精通
2. Python网络爬虫入门到实战
3. 强化学习：前沿算法与应用
4. 深度学习：数学基础、算法模型与实战
5. 图解入门——半导体元器件精讲
6. 一本书读懂芯片制程
7. CTF实战：从入门到提升
IT Technology
IT技术 2023年，随着各项前沿技术的发展，我们在迈向数字经济的新时代的征途上又走出了坚实的一步。前沿技术的发展，离不开Linux、Python等技术的支持，近期我们邀请相关领域大咖作者打造了两本相关技术图书，帮助大家精进技术，提升自我！
▊《 速学Linux：系统应用从入门到精通》
良许 著　专业：线上Linux超50万粉丝号主良许以及多位专家联合出版
超值：赠150段速学Linux命令教学视频、电子教案及学习资料
轻松：以角色对话结合图解方式拆分技术细节，减轻学习压力
实战：220个动手练一练、47个知识拓展，看过就能上机操作
互动：扫案例旁二维码即可观看47段教学视频，全程语音讲解
▊《Python网络爬虫入门到实战》
杨涵文 周培源 陈姗姗
本书作者不吃西红柿、川川都是在CSDN等专业网站拥有全网50万粉丝的专业级博主，意见领袖。本书从基础知识到案例实战，200多个案例代码，近200个知识点。
首先介绍了网页的基础知识，然后介绍了urllib、Requests请求库以及XPath、Beautiful Soup等解析库，接着介绍了selenium对动态网站的爬取和Scrapy爬虫框架，最后介绍了Linux基础，便于读者自主部署编写好的爬虫脚本。本书所有代码和相关素材可以到GitHub下载获取
Artificial Intelligence
人工智能 要问2023年人工智能领域的爆点是什么？ChatGPT当之无愧！它的出现标志着语言模型技术的重大突破。它可以根据用户的输入和上下文生成流畅、有趣和合理的对话。ChatGPT不仅可以用于娱乐、教育和社交目的，还可以用于协作创作，例如生成图像、视频、文本等内容。那么是什么让ChatGPT能够拥有如此强大的功能呢？这其中就不得不提到强化学习和机器学习两门人工智能领域的研究方向。
▊《强化学习：前沿算法与应用》
白辰甲 赵英男 郝建业 刘鹏 王震　浙江大学吴飞教授作序 张成奇教授、刘挺教授、邓小铁教授鼎力推荐 。
介绍了强化学习在算法层面的快速发展，以及为了提升样本效率产生的基于模型学习、探索与利用、多目标学习、层次化学习、技能学习等算法，以及一些新兴领域，包括离线学习、表示学习、元学习等。
旨在提升数据高效性和策略的泛化能力的算法，还介绍了应用领域中强化学习在智能控制、机器视觉、语言处理、医疗、推荐、金融等方面的相关知识。
▊《深度学习：数学基础、算法模型与实战》
于子叶
剖析多领域深度学习模型基础与实践，全面介绍深度学习算法原理与多领域落地应用
详解监督学习、无监督学习、概率图模型、核方法和强化学习等多种高级机器学习算法；所有算法均由PyTorch框架实现，配备实战环节讲解，涵盖了点击率预估、变分推断、高斯过程、深度强化学习等前沿领域。
Semiconductor
半导体 面积比邮票还小，厚度比头发直径还薄的半导体，是当前世界经济增长和技术创新的核心组成部分。从智能手机、个人电脑、心脏起搏器到互联网、汽车、航天飞机，无论是在电子设备中，还是在商品和服务的数字化过程中半导体无处不在。它把人类带进信息化智能化世界，是构成信息化社会这座高楼大厦的基础。半导体推动了通信、计算、医疗、军事、交通等无数应用领域的进步。并且催生了人工智能、虚拟现实、物联网等有望使社会变得更好的新技术。半导体产业也因此被誉为高端制造业皇冠上的明珠。在某种程度上，解决半导体技术的“卡脖子”问题，坚决打赢半导体领域核心技术攻坚战，决定着我国在全球科技竞争中的地位。
▊《图解入门——半导体元器件精讲》
[日]执行直之 著 娄煜 译
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2869200d2ac7f73f8601f40382c4b468/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c97b11a712611e13b25f0ba548d2b81/" rel="bookmark">
			可视化大师课：图表史话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提起数学史，你首先会想到什么？
第一个浮现的可能是最开始的欧几里得、毕达哥拉斯；再想想会有牛顿、高斯、欧拉、柯西；怜惜少年英才的会想到阿贝尔、伽罗瓦；对统计学感兴趣的会想起贝叶斯、凯特勒；对近现代数学有了解的则可能会提到康托尔、黎曼、格罗滕迪克等等。
但以上巨擘无法代表群星光芒的全部（虽然高斯确实占了很大一部分），在文明的发展史中，无数有名或无名的、前赴后继的数学家的光辉历程无疑推动了主流研究的前进。
然而，有一个领域的历史足够冷门，那就是统计图表的历史。
有一个被大多数人认可的规律，就是在教学大纲中出现得越早的东西在学科中就越基础和重要。而统计图表在大部分人的记忆中是在小学数学课就开始接触的，没有人会忘记用直尺铅笔在试卷上小心翼翼地画出条形图，再打上斜线阴影的感觉。
统计图表的发明是如此自然且符合人类直觉，以至于几乎让人想不起来去思考它是如何发源、又是如何润物无声地嵌入生活和科学研究中的。 它们是「最熟悉的陌生人」，这可能就是数据可视化这门学科的神秘与魅力之处。
下面我们就来挖掘下我们熟知的统计图表中，一般公认的**「第一个」**是谁发明的。可以通过下面的视频大致了解下（视频借助开源图表库 @VisActor/VChart 制作），同时下文也将详细讲述每个图表的故事。
jvideo
总体时间轴
【15 世纪】一切始于自然哲学——条形图最早雏形的发明者：Nicole Oresme Nicole Oresme（尼科尔·奥雷姆）生年不详，卒于1382年，法王查理五世顾问。他同时也是斜杠青年，经济、数学、物理、天文、哲学、音乐、神学、心理学无一不通。虽然知名度不高，但他是中古晚期的代表性哲学家之一，也是近代科学主要奠基者之一。
在物理学领域，他提出了一个在当时十分有开创性的观点，就是当自由落体在加速时，其重量并没有增加，而是下落的「冲力」增加。为此他又提出了一个现在经常被作为思维实验或者教学案例的假设，就是一拳打爆地球——啊不是，挖穿地球，从地球表面的 A 点挖穿地心，挖掘到地球另一侧表面的 B 点，然后将一个重物落入这隧道。则它会从 A 点经过地心移动到 B 点，就好像单摆从一边摇摆到另外一边。但是，从地心到 B 点的路途中，它是呈升起状态，而重量只能造成物体掉落，因此证明了「冲力」与重量是两个概念[1]。
Oresme 另一个代表性工作是用几何方法证明了平均速度定理。那么他是如何发明条形图的雏形呢？
其实源于 Oresme 在物理领域的一次尝试，他尝试用一种包含「经纬度」体系的平面图形来形象化一些物理概念，其实已经非常接近我们现在所说的直角坐标。
例如用他提出的「经纬度」体系来表达点的运动，时间为经度（x 轴），速度为纬度（y 轴）；那么，位移数量就是给定时间内覆盖的空间。由此，后世的伽利略赖以成名的工作，Oresme 其实在两个世纪以前就开始研究并发表成果了。
如下图，是 Oresme 在 On the Latitude of Forms 中绘制的加速物体的速度与时间的 5 幅关系图，这些被认为是 Oresme 发明的条形图原型。
那么为什么说是「原型」呢？一种原因可能是 Oresme 没有对条形图的图元和视觉编码[2]方式做明确的定义。
在数据可视化理论中，所有的统计图表都有视觉编码的过程。具体来讲是将数据通过某种设计好的方式映射到具体的图元的视觉通道上。图元和视觉通道的概念可以这样定义：
图元：可视化数据的基本图形元素，如点、线、面；视觉通道：图元在视觉上的一些可以量化的特征，如大小、位置、颜色。 下图为常见的图元种类（横轴）和常见的视觉通道（纵轴）示意图[3]：
Oresme 画的图更像是对一个坐标系中的闭合曲线进行分割，而现代的条形图，图元被规定为一个个明确的矩形，在两个轴张成的空间内映射对应的数据项的值。矩形高度和表示数值的数据严格绑定和映射，同时矩形的 x 坐标也和表示类别的数据进行绑定和映射，每个图元都有一个严格而清晰的视觉编码过程。
通过 VChart 可以很方便地制作现代柱状图示例，而且开发者并不需要了解感知视觉编码的细节。下图示例可以与 Oresme 的原型版本进行对比：
【17 世纪】天文学家的罗马之路——第一张统计图表的发明者：Michael van Langren Michael van Langren（米希尔·范·朗格伦，1598—1675）是一位荷兰的天文学家和制图师，他的主要贡献是对经度测量的尝试。比较浪漫和超前的是，他不止测量地球，还尝试测量过月球。他率先找到了一个比较聪明的办法：通过观察整个月相周期中，月球上山峰和环形山的出现和消失，就可提高经度测定的准确度。这一想法促使他在1645年绘制了一幅质量很好的月面图[4]。同时，他也是第一个尝试给月球地貌命名的人：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c97b11a712611e13b25f0ba548d2b81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9c902f811db52462272b035ea885cc/" rel="bookmark">
			ESP32-CAM入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 ESP32-CAM 拥有业内极富竞争力的小尺寸摄 像头模组，该模块可以作为最小系统独立工 作，尺寸仅为 27*40.5*4.5mm，深度睡眠电流 最低达到 6mA。
ESP-32CAM 可广泛应用于各种物联网场合， 适用于家庭智能设备、工业无线控制、无线监 控、QR 无线识别，无线定位系统信号以及其 它物联网应用，是物联网应用的理想解决方 案。
ESP-32CAM 采用 DIP 封装，直接插上底板即 可使用，实现产品的快速生产，为客户提供高 可靠性的连接方式，方便应用于各种物联网硬 件终端场合。
体积超小的 802.11b/g/n Wi-Fi + BT/BLE SoC
模块
- 采用低功耗双核 32 位 CPU，可作应用处理器
- 主频高达 240MHz，运算能力高达 600 DMIPS - 内置 520 KB SRAM，外置 4M PSRAM - 支持 UART/SPI/I2C/PWM/ADC/DAC 等接口
-支持 OV2640 和 OV7670 摄像头，内置闪光灯
- 支持图片 WiFI 上传
-支持 TF 卡
- 支持多种休眠模式。
- 内嵌 Lwip 和 FreeRTOS - 支持 STA/AP/STA+AP 工作模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9c902f811db52462272b035ea885cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc1ef7c699840911ee732207500ce03/" rel="bookmark">
			二叉树迭代遍历(使用栈)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 前序：根左右 1 2 4 5 3 6 7 // 中序：左根右 4 2 5 1 6 3 7 // 后序：左右根 4 5 2 6 7 3 1 #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;queue&gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {}; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}; }; void preTraversal(TreeNode *root) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc1ef7c699840911ee732207500ce03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2921268be3eb2c440bb7edca0f67e0cb/" rel="bookmark">
			Vue 3 使用Vue Router路由守卫和拦截
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 3 使用Vue Router来管理路由，路由守卫和拦截用于在导航到不同页面之前执行一些操作，例如身份验证、权限检查、数据加载等。以下是Vue 3中使用路由守卫和拦截的基本示例：
首先，确保你已经安装了Vue Router。如果还没有安装，你可以使用以下命令安装：
npm install vue-router
然后，在你的Vue项目中创建一个路由实例并配置路由规则。以下是一个示例：
// main.js
import { createApp } from 'vue'
import App from './App.vue'
import { createRouter, createWebHistory } from 'vue-router'
const router = createRouter({
history: createWebHistory(),
routes: [
{ path: '/', component: Home },
{ path: '/about', component: About },
// 其他路由规则
]
})
const app = createApp(App)
app.use(router)
app.mount('#app')
接下来，你可以使用路由守卫来拦截导航。Vue 3 提供了三种类型的路由守卫：
1、全局前置守卫：在路由导航开始之前触发，适用于全局设置。
router.beforeEach((to, from, next) =&gt; {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2921268be3eb2c440bb7edca0f67e0cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07d418a89097310458c5e8e49ccc669/" rel="bookmark">
			Python技能树练习——python字符串转列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目与解 把下列字符串转为列表格式输出
top_ide_trend = """ Rank	Change	IDE	Share	Trend 1	Visual Studio	29.24 %	+3.5 % 2	Eclipse	13.91 %	-2.9 % 3	Visual Studio Code	12.07 %	+3.3 % 4	Android Studio	9.13 %	-2.5 % 5	pyCharm	8.43 %	+0.7 % 6	IntelliJ	6.7 %	+0.8 % 7	NetBeans	4.82 %	-0.3 % 8	Sublime Text	3.49 %	-0.2 % 9	Xcode	3.37 %	-1.2 % 10	Atom	3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a07d418a89097310458c5e8e49ccc669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/140651738881c3f68722c4607a2b8d13/" rel="bookmark">
			Rust语言开发环境搭建详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Rust简介1、rust历史2、rust吉祥物 二、Rust开发环境搭建1、C++环境安装2、Rust下载3、rust安装4、rust环境检测查看rust版本查看cargo版本 5、rust在线环境6、rust更新7、rust卸载8、查看本地文档 三、创建Rust项目1、用代码文件创建项目2、使用cargo创建项目 四、Rust IDE五、Rust学习资料1、参考官网提供的资料2、纸质书3、rust博客4、rust中文社区5、rust源码仓库 一、Rust简介 1、rust历史 rust是一门比较新的编程语言，2015年5月15日，Rust编程语言核心团队正式宣布发布Rust 1.0版本，具体介绍可以参看百度百科：https://baike.baidu.com/item/Rust%E8%AF%AD%E8%A8%80/9502634?fr=aladdin
2、rust吉祥物 Ferris 是 Rust 社区的非官方吉祥物。很多 Rust 程序员自称“Rustaceans”， 它与“crustacean”相似。 我们用“they”、“them”等代词，而不用带性别的代词来指代 Ferris。
Ferris 与形容词“ferrous”相似，它的含义与铁有关。由于 Rust（锈）通常由铁形成， 因此它算得上是个吉祥物名字的有趣来源。
二、Rust开发环境搭建 本篇博客介绍rust编程语言在windows上开发环境的搭建方法。
1、C++环境安装 Rust依赖于C++编译环境，安装rust之前，需要先在windows安装visual studio, 当前最新的是VS2022，链接：
https://visualstudio.microsoft.com/zh-hans/vs/
2、Rust下载 rust中文官网 https://www.rust-lang.org/zh-CN
点击【马上开始】
选择相应的版本下载，例如x64
3、rust安装 友情提示：有梯子的把梯子先打开，目测rust下载时会update相关环境，比较慢，用梯子会快一些。
下载之后，双击打开，如下图：
rustup-init.exe 是 Rust 的安装和管理工具，默认情况下，它会同时安装这些工具：rustc，rust-std，cargo，rust-docs，rustfmt，clippy。其中，rustc 是 Rust 的编译工具，cargo 是 Rust 的包管理工具。
等待安装即可
安装结束
4、rust环境检测 查看rust版本 rustc --version 或者使用命令 rustc -V
查看cargo版本 命令
cargo -V 或者使用命令 cargo --version
如下图
5、rust在线环境 链接：https://play.rust-lang.org/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/140651738881c3f68722c4607a2b8d13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6dd5e806463a51d7d8168ab37ce9f2/" rel="bookmark">
			【一：实战开发testng的介绍】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、主要内容1.1、为啥要做接口测试1.2、接口自动化测试落地过程1.3、接口测试范围1.4、手工接口常用的工具1.5、自动化框架的设计 2、testng自动化测试框架基本测试1、基本注解2、忽略测试3、依赖测试4、超时测试5、异常测试6、通过xml文件参数测试7、通过data实现数据驱动 2.1、suit套件测试（按类分）2.2、分组测试（按方法分组，也可以分开写）2.2.1、在class文件中分组2.2.2、使用xml文件分组 2.3、多线程运行（注解的方式配置）2.4、多线程运行（在xml里面配置） 1、主要内容 1.1、为啥要做接口测试 更容易实现持续集成自动化测试落地性价比更高，比UI更稳定大型系统更多更复杂，系统间模块越来越多BUG更容易定位降低研发成本，提高效率
1.2、接口自动化测试落地过程 需求阶段项目立项，产品设计，需求文档研发阶段UI设计、前端开发，后端开发，测试设计，测试开发测试阶段环境搭建，多项测试执行，BUG修复，测试报告项目上线显示回归测试，上线报告，添加监控 1.3、接口测试范围 1.4、手工接口常用的工具 postman（Chrome）httpRequestfiddlerjemter（统计结果不完善，倾向于性能测试）
1.5、自动化框架的设计 2、testng自动化测试框架 @test:最基本的注解，用来把方法标记为测试的一部分@BeforeMethod: 测试方法之前运行的方法@AfterMethod:测试方法之后运行的方法@BeforeClass: 指的是在类运行之前运行的方法@AfterClass:指的是在类运行之后运行的方法@BeforeTest：多个测试类的集合，在设定好的测试集合前运行的方@AfterTest：多个测试类的集合，在设定好的测试集合后运行的方法@ BeforeSuite: 测试套件，在类运行之前运行的方法：@ AfterSuite: 测试套件，在类运行之后运行的方法@Test(dependsOnMethods = {“test1”})：依赖测试，在执行次方法之前执行test1方法之前1@Test(expectedExceptions = RuntimeException.class)：异常测试，方法里面要抛出异常throw new RuntimeException();，否则会是一个失败的异常测试@Test(enabled = true)：忽略测试@Test(timeOut = 2000)：超时测试@Test(invocationCount = 10,threadPoolSize = 3)，多线程测试，一般用xml配置 总结：testng的annotations运行顺序为：
@BeforeSuite&gt;@BeforeTest&gt;@BeforeClass&gt;@BeforeMethod&gt;@test&gt;@AfterMethod&gt;@AfterClass&gt;@AfterTest&gt;@AfterSuite
基本测试 1、基本注解 import org.testng.annotations.*; public class BasicAnnotation { //最基本的注解，用来把方法标记为测试的一部分 @Test public void testCase1(){ System.out.printf("Thread Id : %s%n",Thread.currentThread().getId()); System.out.println("Test这是测试用例1"); } @Test public void testCase2(){ System.out.printf("Thread Id : %s%n",Thread.currentThread().getId()); System.out.println("Test这是测试用例2"); } @BeforeMethod public void beforeMethod(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6dd5e806463a51d7d8168ab37ce9f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70a6d74d23ee294ad57bdf235112d62/" rel="bookmark">
			DVWA-impossible代码审计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 DVWA靶场—impossible代码审计1.暴力破解（Brute Force）1.1 代码审计1.2 总结 2.命令注入（Command Injection）2.1 代码审计2.2 总结 3.跨站请求伪造（CSRF）3.1 代码审计3.2 总结 4.文件包含漏洞（File Inclusion）4.1 代码审计4.2 总结 5.文件上传漏洞（File Upload）5.1 代码审计5.2 总结 6.不安全的验证码（Insecure CAPTCHA）6.1 代码审计6.2 总结 7.SQL注入（SQL Injection）7.1 代码审计7.2 总结 8.SQL盲注（SQL Injection(Blind)）8.1 代码审计8.2 总结 9.弱会话IDS（Weak Session IDS）9.1 代码审计9.2 总结 10.跨站脚本攻击（XSS(DOM)）10.1 代码审计10.2 总结 11.跨站脚本攻击反射型（XSS(Reflected)）11.1 代码审计11.2 总结 12.跨站脚本攻击存储型（XSS(Stored)）12.1 代码审计12.2 总结 13.内容安全策略（CSP Bypass）13.1 代码审计13.2 总结 14.JavaScript Attacks15.DVWA靶场—impossible代码审计总结15.DVWA靶场—impossible代码审计总结 DVWA靶场—impossible代码审计 1.暴力破解（Brute Force） 1.1 代码审计 Token校验
使用checkToken()函数进行校验防止CSRF 函数说明：
isset()：检测变量是否已声明并且其值不为 null。
checkToken()方法：
对用户的输入的username和password进行消毒 函数说明：
stripslashes()：addslashes的反向操作，移除addslashes()函数添加的转义反斜杠字符。返回一个去除转义反斜线后的字符串（’ 转换为 ’ 等等）。双反斜线（\）被转换为单个反斜线（\）。md5()：计算字符串的 MD5 散列值，并返回该散列值。 定义登录失败限制次数，上锁时间，账户锁定状态的默认值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f70a6d74d23ee294ad57bdf235112d62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576990a98aa4f9eabc05c471d29e72b2/" rel="bookmark">
			Meta Hacker Cup 2023 Round 1 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem A: Here Comes Santa Claus 给一个数列，要求分成若干组，要求每组至少2个数，使得所有组中位数的最大值与最小值之差尽量大，求这个值。
#include&lt;bits/stdc++.h&gt; using namespace std; #define For(i,n) for(int i=1;i&lt;=n;i++) #define Fork(i,k,n) for(int i=k;i&lt;=n;i++) #define ForkD(i,k,n) for(int i=n;i&gt;=k;i--) #define Rep(i,n) for(int i=0;i&lt;n;i++) #define ForD(i,n) for(int i=n;i;i--) #define RepD(i,n) for(int i=n;i&gt;=0;i--) #define Forp(x) for(int p=pre[x];p;p=next[p]) #define Forpiter(x) for(int &amp;p=iter[x];p;p=next[p]) #define Lson (o&lt;&lt;1) #define Rson ((o&lt;&lt;1)+1) #define MEM(a) memset(a,0,sizeof(a)); #define MEMI(a) memset(a,0x3f,sizeof(a)); #define MEMi(a) memset(a,128,sizeof(a)); #define MEMx(a,b) memset(a,b,sizeof(a)); #define INF (0x3f3f3f3f) #define F (1000000007) #define pb push_back #define mp make_pair #define fi first #define se second #define vi vector&lt;int&gt; #define pi pair&lt;int,int&gt; #define SI(a) ((a).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576990a98aa4f9eabc05c471d29e72b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b301b22368935367826eac18c932755/" rel="bookmark">
			Mockito使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mockito 一张思维导图鸟瞰全文 单元测试 一个单元测试应该有如下特点
应该是自动化的应该可以快速运行每个单元测试不应该依赖其它测试的结果和执行顺序，单元测试框架可以按任意的顺序执行每个测试每个单元测试不应该依赖数据库，外部文件，或者任何长时间运行的任务。单元测试应该是独立的，不应该依赖于任何外部环境单元测试应该在任何时间任何环境都可以任意执行，不该依赖外部环境测试应该是有意义的，具有表达性，可以表达出这个测试是测什么，也可以从侧面反推这个被测试的方法的能力测试代码应该跟生产代码拥有同等标准要求 Mockito 是什么 为了满足单元测试的隔离性，隔离外部环境，我们需要将外部依赖，通过替身的方式，模拟出一个可以满足我们测试的假对象。
Mockito 就是可以制作假替身，代替外部依赖，模拟我们自定义的返回操作的替身测试框架。
mock替身，很像电影中的替身演员，在某些场景中我们需要替身来处理某些问题。
Mockito 如何使用 1. 设置测试类依托Mockito管理 Mock 需要先设置测试类被 Mockito 管理。有两种方式。
在测试类上添加注解 @RunWith(MockitoJUnitRunner.class)在@Before方法中，调用 MockitoAnnotations.initMocks(this) 上述两种方法使用其一都可，效果一样。
@Before 注解是 Junit 提供的，在每个@Test测试执行前执行一次。
方式1代码示例：
@RunWith(MockitoJUnitRunner.class) public class MockDemo { @Test public void testMock() { // 处理测试 } } 方式2代码示例：
@Before public void init() { MockitoAnnotations.initMocks(this); } 2.对类构造替身对象 对类构造替身对象有如下几种方式
在测试用例中直接使用 Mockito.mock(Class) 方法，生成替身对象在测试类中声明需生成替身的依赖类，使用 @Mock 注解。 第二种方式是该测试类中所有单元测试唯一的对象，为了防止每个单元测试 stubbing 的先后顺序对其他单元测试的影响，最好写一个 @After 方法，在该方法中使用 Mockito.reset() 方法清空 stubbing 规则。
@After 注解是 Junit 提供的，在每个@Test测试执行后执行一次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b301b22368935367826eac18c932755/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0147663b8c8e0785bd623532bb6e690c/" rel="bookmark">
			【系统与工具】系统环境——VMware安装系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0.1 安装VMware0.2 下载ubuntu镜像0.3 创建系统实例0.4 安装ubuntu0.5 实例配置项0.5.1 安装VMware tools0.5.2 修改静态IP0.5.3 ssh连接 0.6 克隆0.6.1 克隆实例生成MAC地址 0.6.2 修改静态ip0.6.3 修改主机密码名称 参考：https://blog.csdn.net/m0_51913750/article/details/131604868
0.1 安装VMware 从 VMware官网 下载安装包照着点就行 0.2 下载ubuntu镜像 官网
清华大学开源软件镜像站
阿里云开源镜像站
Ubuntu 22.04
0.3 创建系统实例 需要2GB，不然无法安装 0.4 安装ubuntu 0.5 实例配置项 0.5.1 安装VMware tools https://blog.csdn.net/NRWHF/article/details/127809132
开机
从光盘解压到本机
从终端进入该文件夹，运行 sudo ./vmware-install.pl
提示yes的输yes，默认的回车
0.5.2 修改静态IP 因为原系统设置的是动态 ip(BOOTPROTO=“dhcp”)，所以新系统默认也是动态 ip，自动分配了 ip，克隆后并没有与系统的 ip 地址冲突，但为了集群搭建，需要改为可控的静态ip
sudo apt install net-tools ifconfig #查看网卡名称 ip a cd /etc/netplan ls sudo gedit 01-network-manager-all.yaml network: version: 2 renderer: NetworkManager ethernets: ens33: dhcp4: false addresses: [192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0147663b8c8e0785bd623532bb6e690c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecff9eb4786d440c2e3b765a868512ad/" rel="bookmark">
			现在光速成长的赛道还有哪些？24届的你不能错过的就业攻略~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023.10.19 深信服 二面（线下)
之前一面是在线上，二面就改成线下了。先介绍下大概是什么流程：1.先是有很多小伙伴，会在这个酒店这某一层的大厅前边等着，等到面试时间以后，负责签到的HR会叫你的名
题解 | #链表相加(二)#
# class ListNode:# def __init__(self, x):# self.val = x# sel
知乎前端面试
自我介绍CSS如何实现水平垂直居中介绍一下React中常用的Hook函数React组件间通信有哪些方式为什么不能在循环、条件判断或嵌套函数中调用Hooks看代码
同程旅行产品经理面试
为什么想做产品经理产品经理需要哪些能力从产品角度分析一下自己做的项目当前项目后期规划如何把当前的这个政府项目商业化产品该如何推广
题解 | #各城市最大同时等车人数#
select city ,max(wait_diff) max_wait_uvfrom(select city ,date(dt)
看看佬们的建议
秋招快结束了，还有希望嘛{nowcoder-vote}{90455}
圣邦微电子
哈尔滨的圣邦微电子怎么样
题解 | #牛牛的字符矩形#
#include &lt;stdio.h&gt;int main() { char a; int i; while (scanf("
转正求求了
[转正成功][转正成功][转正成功][转正成功][转正成功][转正成功][转正成功][转正成功][转正成功]
大三鼠鼠失败总结
进大三就一直在投简历，准备面试，大厂全投了一遍，也一直在软件上海投。国庆前收到了一些面试：杭州实在智能oc，快手一面挂，百度二面挂，经纬恒润一面挂最终并没有选择
#牛客在线求职答疑中心(35799)#
#牛客在线求职答疑中心# 得力物流管理岗面试问什么啊😢
民生银行信用卡中心大数据岗位笔试
笔试分两大部分第一部分是行测，包括言语理解，资料分析，图推。此外还有性格测试比较恶心的事每到行测题限60s，我基本都是读完题就快到截止时间了，很多都是蒙的😓第
美团三面加签面试是什么意思？
今天下午刚面完技术二面，然后晚上来了个加签面试的通知，想问一下这个加签面试是干什么的？
西安汇川应用软开加班到底咋样呀？
有没有兄弟们了解西安汇川应用软开的加班情况啊，估计下周就开奖了，怕加班太猛诶。
空天院面试
有没有面过苏州空天院 正在等结果的兄弟啊？交流一下～😁 #苏州# #空天院# #研究所# #秋招# #面经#
想问问大家深圳吉泰科驱动技术有限公司有了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecff9eb4786d440c2e3b765a868512ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947269aee7e5087eaf2a1aba6a7e07d4/" rel="bookmark">
			20231019 控制中的卷积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是卷积 对于线性时不变系统而言，其输入和输出之间是卷积关系，也就是每个时刻的系统输入会对其后一段时间之内的系统输出产生影响，而对于某一时刻的输出是前一段时间输入的效果的叠加。
2. 定义单位输入 定义一个单位输入，如
δ ( t ) { 1 Δ , if 0 ⩽ t &lt; Δ 0 , else \delta(t)\left\{\begin{array}{l} \frac{1}{\Delta}, \text{if }0 \leqslant t &lt;\Delta \\ 0, \text { else } \end{array}\right. δ(t){Δ1​,if 0⩽t&lt;Δ0, else ​
假如这样一个输入，经过定常线性连续动态系统后，产生的输出为 h ( t ) h(t) h(t)。注意，对于 t ⩽ 0 t \leqslant 0 t⩽0， h ( t ) h(t) h(t)始终为零，而对于 t &gt; 0 t &gt; 0 t&gt;0， h ( t ) h(t) h(t)至少有一段非零。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/947269aee7e5087eaf2a1aba6a7e07d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c04418bfabf2a9192a8a51d02676da92/" rel="bookmark">
			工业自动化控制通信协议Profinet系列-2、编译p-net在虚拟机树莓派上运行示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工业自动化控制通信协议Profinet系列-2、编译p-net在虚拟机树莓派上运行示例 文章目录 工业自动化控制通信协议Profinet系列-2、编译p-net在虚拟机树莓派上运行示例一、前言二、树莓派虚拟机编译安装测试1、树莓派desktop下载及虚拟机安装2、下载编译安装p-net及运行demo程序 三、p-net缺陷与接下来的测试1、p-net特征2、p-net局限性3、接下来 一、前言 之前已经对Profinet做了一些基础的了解，接下来进行简单的Profinet组网，并利用开源库p-net的示例程序和plc基于profinet网络进行交互，以此抓包分析整个profinet协议交互过程，便于我们进一步开发基于profinet协议的应用。
二、树莓派虚拟机编译安装测试 1、树莓派desktop下载及虚拟机安装 树莓派desktop：https://www.raspberrypi.com/software/raspberry-pi-desktop/
下载树莓派：https://downloads.raspberrypi.org/rpd_x86/images/
文档：https://www.raspberrypi.com/documentation/
Windows和MacOS的PC机都可以通过虚拟机安装该DeskTop，对于学习树莓派很有帮助，还有一些对应的文档资料。
之后的设置一下硬件配置进入安装界面选择图形界面安装后步骤基本上就是常规的安装虚拟机的步骤，没有特殊要求则使用默认的选项一路向下即可，这里不再细说，安装成功并安装vm tools后如下：
2、下载编译安装p-net及运行demo程序 按照教程 的中流程进行下载安装即可，注意使用pi用户去执行即可（注意：安装源也最好先不要换到国内源，我更换之后出了一堆问题，好在是虚拟机可以重装，否则设备板子刷系统还是 挺浪费时间的）：
sudo apt update sudo apt install snapd sudo snap install cmake --classic sudo reboot cmake --version sudo apt install git mkdir /home/pi/profinet/ cd /home/pi/profinet/ git clone --recurse-submodules https://github.com/rtlabs-com/p-net.git #可能耗时较长，可以增加一下内存 cmake -B build -S p-net cmake --build build --target install 运行测试（虚拟机可以直接设置桥接模式，就不需要再单独修改网卡地址了）：
sudo ./pn_dev -v 会需要root权限去读取eth0网卡的网络信息：
三、p-net缺陷与接下来的测试 根据这里的描述：https://zhuanlan.zhihu.com/p/181332329
Profinet IO设备基本分为三类：Device（从站）、Controller（主站）与Supervisor（监视器），结合p-net的GitHub描述，p-net可以用于实现Device也就是Profinet从站IO设备，主要的动能就是读写IO数据（可以用于开发：远程IO、伺服驱动器、变频器等现场设备）。更详细一些的profinet IO系统的说明可以看这里：https://www.founderchip.com/?id=354
如下是机翻的，有一些不太理解，但是大致的意思能看明白，缺陷和特征都是比较明显的。
1、p-net特征 ● 多个以太网端口配置（目前仅适用于 Linux）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c04418bfabf2a9192a8a51d02676da92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386ca25be56c918b16b7b238d6298e5d/" rel="bookmark">
			线程池七大参数解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程池七大参数 概述：
线程池是一种用于管理和控制线程的机制，它可以有效地管理线程的创建、复用、调度和销毁，以提高多线程应用程序的性能和资源利用率。在Java中，线程池的创建和配置通常需要设置七个重要的参数：
1.corePoolSize（核心线程数）：
corePoolSize 是线程池中保持活动状态的最小线程数。即使没有任务执行，线程池也会保持这些核心线程的活动状态。
当有任务提交到线程池时，线程池会首先尝试使用核心线程来处理任务。
2.maximumPoolSize（最大线程数）：
maximumPoolSize 是线程池中允许存在的最大线程数。当任务数量超过核心线程数并且工作队列已满时，线程池会创建新线程，但数量不会超过最大线程数。
超过最大线程数的任务将被拒绝或根据拒绝策略进行处理。
3.keepAliveTime（线程空闲时间）：
keepAliveTime 是非核心线程在空闲状态下的最长存活时间。当线程池中的线程数量超过核心线程数时，空闲的非核心线程在经过一段时间后将被回收。
这个参数与下一个参数（TimeUnit）一起使用来定义空闲时间的单位。
4.unit（时间单位）：
unit 是用于指定 keepAliveTime 的时间单位，可以是毫秒、秒、分钟等。
5.workQueue（工作队列）：
workQueue 是用于保存等待执行任务的队列。当线程池的线程数量达到核心线程数时，新的任务将被放入工作队列中等待执行。
常见的工作队列类型包括有界队列（如 ArrayBlockingQueue）和无界队列（如 LinkedBlockingQueue）等。
6.threadFactory（线程工厂）：
threadFactory 是一个用于创建线程的工厂，通常用于自定义线程的命名和其他属性。
如果不指定 threadFactory，线程池会使用默认的线程工厂。
7.handler（拒绝策略）：
handler 定义了当任务被拒绝时的处理策略。当任务数量超过最大线程数并且工作队列已满时，线程池会根据拒绝策略来处理新提交的任务。
常见的拒绝策略包括 AbortPolicy（抛出异常）、CallerRunsPolicy（由调用线程执行）、DiscardOldestPolicy（丢弃最旧的任务）、DiscardPolicy（丢弃任务）等。
总结：
这些参数的合理配置对于线程池的性能和稳定性非常重要。核心线程数和最大线程数的设置影响了线程池的并发度，而工作队列的类型和大小、线程的存活时间等参数也会影响线程池的行为。拒绝策略的选择取决于应用程序的需求，以及如何处理无法执行的任务。正确配置线程池参数有助于避免资源浪费和性能问题，并提高多线程应用程序的效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52d10c8b385db72caaee95093b30cbd/" rel="bookmark">
			生成微信小程序码、URL Scheme和URL Link
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用第一步,获取access_token,需要服务端去获取并缓存 (APPID和APPSECRET在微信小程序后台查看获取)
https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET 1.获取小程序码(通过该接口生成的小程序码，永久有效，数量暂无限制)
uni.request({ url: "https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=" + access_token,//access_token从服务端获取 method: 'POST', responseType: 'arraybuffer', //设置响应类型 data: { path: 'pages/index/index', // 必须是已经发布的小程序存在的页面（否则报错） scene: encodeURIComponent('id=123&amp;code=xxx'),//小程序端需要 decodeURIComponent(query.scene) width: 360,//最小 280px，最大 1280px auto_color: true, // 默认false, 自动配置线条颜色，如果颜色依然是黑色，则说明不建议配置主色调 }, success: function(res) { console.log('获取二维码信息', res) //返回的是ArrayBuffer对象 const qrcode = "data:image/PNG;BASE64," + uni.arrayBufferToBase64(res.data); console.log("base64的二维码图片地址", qrcode); } }) 2.获取URL Scheme(通过该接口生成的Scheme，只有30天有效期)(iOS可以直接跳,安卓需要适配weixin://xxx这种协议头)
uni.request({ url: "https://api.weixin.qq.com/wxa/generatescheme?access_token=" + access_token, // access_token从服务端获取 method: 'POST', data: { expire_type: 1, //到期失效的 scheme 码失效类型，失效时间：0，失效间隔天数：1 // expire_time: 1606737600, //到期失效的 scheme 码的失效时间，为 Unix 时间戳,最长有效期为30天.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d52d10c8b385db72caaee95093b30cbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd4efcb62194d85cdb863901af35c0d5/" rel="bookmark">
			【Java】学生成绩管理系统（图形化界面实现相关功能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 从功能的代码实现到界面的展示整个制作过程全部用Java语言实现。
1、环境搭建 1、在idea创建一个工程文件，在工程文件下创建一个model模块，在model模块下载创建三个package包分别用来存放(BackEndCode)后端代码包、(MainExe)主程序包、(WebCode)界面实现代码包，再在三个包中创建如下图所示文件
2、容器选择：因为本次使用的是自己创建的Student类并且信息数量不确定，所以选择集合作为Student类的容器
2、功能实现 1、学生信息类的实现（BackEndCode包） 为了防止属性不能被外类随意访问，因此采用private对学生类中的属性进行修饰并且进行创建set、get方法以便于调用属性，再创建打印数据方法，方便数据打印，代码如下：
package BackEndCode; import java.io.Serializable; public class Student implements Serializable { private String StuName; private int id; private int ChineseScores; private int MathScores; private int EnglishScores; public Student() { } public Student(String stuName, int id, int chineseScores, int mathScores, int englishScores) { StuName = stuName; this.id = id; ChineseScores = chineseScores; MathScores = mathScores; EnglishScores = englishScores; } public String getStuName() { return StuName; } public int getId() { return id; } public int getChineseScores() { return ChineseScores; } public int getMathScores() { return MathScores; } public int getEnglishScores() { return EnglishScores; } public int getSum() { return ChineseScores + MathScores + EnglishScores; } @Override public String toString() { return id + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd4efcb62194d85cdb863901af35c0d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb22969705c69a35d39416dfb6c610d/" rel="bookmark">
			记录一下ComboBox在listview中的问题，后面再解决。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在listview的ComboBox，ViewModel类得不到ComboBox的 SelectedModeIndex 和 SelectionChanged事件。
问题描述：
1. 在listview中有ComboBox
2. 数据源类 InspectionInfo ，其中有ComboBox的绑定数据源 ModelList，代码如下：
public class InspectionInfo : BindableBase { /// &lt;summary&gt; /// 模式名称列表 /// &lt;/summary&gt; private ObservableCollection&lt;BaseModeOption&gt; _modelList; public ObservableCollection&lt;BaseModeOption&gt; ModelList { get { return _modelList; } set { SetProperty(ref _modelList, value); } } private ExamePartsStat _examePartInfo; public ExamePartsStat ExamePartInfo { get { return _examePartInfo; } set { SetProperty(ref _examePartInfo, value); } } private Inspection _currentInspection; /// &lt;summary&gt; /// 当前的多项检查 /// &lt;/summary&gt; public Inspection CurrentInspection { get =&gt; _currentInspection; set { SetProperty(ref _currentInspection, value); } } private int _selectedModeIndex = 0; public int SelectedModeIndex { get =&gt; _selectedModeIndex; set =&gt; SetProperty(ref _selectedModeIndex, value); } private DelegateCommand&lt;object&gt; _selectionModeChangedCommand; /// &lt;summary&gt; /// 模式改变事件 /// &lt;/summary&gt; public DelegateCommand&lt;object&gt; SelectionModeChangedCommand =&gt; _selectionModeChangedCommand ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eb22969705c69a35d39416dfb6c610d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cefe227746e47d0b7de4b3420d5ac1b/" rel="bookmark">
			计算机三级备考——数据库技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机三级——数据库技术 一、考试内容及要求
掌握数据库技术 的基本概念、原理、方法和技术能够使用SQL语言实现数据库的基本操作（增删改查）基本数据库系统安装配置以及数据库管理及维护的基本技能掌握数据库管理和维护的方法掌握数据库性能优化的方法了解数据库系统的生命周期及设计和开发过程了解常用的数据库管理和开发工具，具备用指定的工具管理开发简单数据库应用系统的能力了解数据库的最新发展 二、考试题型
选择题——30小题（40分）应用题（填空题）——10小题（30分）设计与应用题——三大题（30分）画E-R图（考试带有作图工具 ）、范式、SQL语句 三、考试环境
软件：SQL service 2008只需在正确答案的前面选中即可（都为单选题） ，在应用题中一空可能会有多个答案选项，在填写答案时要全部写上且要用顿号（、）隔开考试时间为120分钟（上机考试 ），考试结束前5分钟系统会报警提醒考生存盘，考试时间为0自动交卷。 第一章 数据库应用系统开发方法 ①掌握数据库的基本概念。
②了解软件工程和数据库技术
③理解DBAS生命周期模型
第一节 基本概念 第二节 软件工程与数据库技术 第三节 DBAS的生命周期模型 第二章 需求分析 了解需求分析的概念和获取需求的方法了解需求建模的方法结构化分析案例——教材购销系统 第一节 需求分析的概念 第三章 数据库结构设计 第一节 数据库概念设计 第二节 数据库逻辑设计 第三节 数据库物理设计 等等等。。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/affff3c28257ae78c32454d26e006e58/" rel="bookmark">
			计算机三级有必要考吗？计算机三级有哪些科目？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在大学期间，计算机等级考试是一门很火热的考试，很多小伙伴通过二级考试以后在究竟是报考三级还是四级之间徘徊，下面肉丸子就来给大家分析一下，究竟有没有必要考计算机三级考试，以及计算机三级考试的科目有哪些？
一、计算机三级有必要考吗？ 这个要分两种情况来看，如果你的二级通过分数很高，就不建议考计算机三级，没有太大的必要，这个证可以用到的地方不多。考试内容大多是需要背的理论知识。
如果你的计算机二级分数不是很高，并且觉得自己对知识的掌握并不是那么地详细和深入，就可以去参加考试，通过准备考试提升自己对理论知识的理解，能够为后续计算机知识的学习提供帮助。
以上就是给大家的建议，如果你觉得自己想要去复习，多一个证也是没有问题的，毕竟学无止境。
二、计算机三级有哪些科目？ 计算机三级等级考的科目分别是：计算机网络技术、数据库技术、PC技术、信息管理技术。
计算机网络技术：考的人最多
主要考： 计算机基础知识、网络原理、操作系统、网络应用。都是背的，如果想自己考可以上图书管借几本书看看背背就能过的。
难度级别：偏简单，上机C语言，笔试是填空和选择。
数据库技术：考的人位居第二
主要考：计算机基础知识、数据结构、操作系统、数据库原理、数据库的应用及开发。
难度级别：简单， 上机C语言，笔试是填空和选择。
PC技术：考的人屈指可数，含金量也很不错
主要考：计算机基础知识、硬件方面的知识，汇编方面的。
难度级别：偏高，如果你是学电子方面的比如说汇编语言你得会，单片机，数据采集，这些你都得会。 上机汇编语言，笔试是填空和选择。
信息管理技术：这个限制专业的
主要考：计算机基础知识、软件工程、数据库、结构化分析与设计、企业系统规划、战略数据规划等。 上机C语言，笔试是填空和选择。
难度级别：较难
希望大家都能考试顺利，前程似锦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41fd393fc8f731edbee2f6122abdfd2d/" rel="bookmark">
			在客户端和服务端获取、设置和删除cookie的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、什么是cookie
二、在客户端获取、设置和删除cookie的方法
三、在服务端设置和删除cookie的方法
最近在开发项目时，会经常遇到在服务端或者客户端跟cookie打交道的需求，于是总结一些其的一些用法。
一、什么是cookie 在了解cookie的一些操作之前，先了解一下什么是cookie?
Cookie是一种在客户端（用户的浏览器）存储数据的机制，以便在用户的多次请求中跟踪和识别用户。它们是由网站创建的，当用户访问该网站时，这些数据会被发送到用户的浏览器，并在那里存储以供将来使用。例如，当你登录一个网站后，网站会创建一个包含你登录信息的Cookie，然后你的浏览器会保存这个Cookie，当你再次访问该网站时，你的浏览器会发送这个Cookie，网站就可以识别你并保持你的登录状态。
cookie的过期时间？
cookie的过期时间可以在创建或者修改cookie时通过expires或者max-age参数定义，如果都不设置则cookie会在浏览器关闭时过期。如果同时设置，那么Max-Age属性将优先被使用。需要注意的是不是所有的浏览器都兼容Max-Age这个属性的。
1）expires为cookie的过期时间，这个日期和时间必须是GMT格式（可通过toUTCString()方法进行转换）
2）max-age为cookie将要过期的最大秒数
二、在客户端获取、设置和删除cookie的方法 获取cookie:
1）document.cookie
2）使用js-cookie插件
import Cookies from 'js-cookie'; Cookies.get('cookieKey') 设置cookie：
1）
document.cookie = '[cookieKey]:[value];expires=xxx' 2）使用js-cookie插件
import Cookies from 'js-cookie'; Cookies.set([cookieKey],[value],options) 删除cookie：
1）max-age=-1 将要过期的最大秒数设置为-1
2）expires 设置为已过期的时间，例如：Thu, 01 Jan 1970 00:00:00 GMT
3）使用js-cookie插件
import Cookies from 'js-cookie'; Cookies.remove([cookieKey],options) 三、在服务端设置和删除cookie的方法 我在服务端设置cookie一般是使用第三方插件去完成的，例如next/headers、nookies等
import {parseCookies(获取)、setCookie(设置)、destroyCookie(删除)} from 'nookies' import { cookies } from 'next/headers'; cookies().get() //获取 cookies().set() //设置 cookies().delete() //删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0213a541178dc996f2672cef55deb78b/" rel="bookmark">
			穿越代码迷宫：我在字节跳动的前端面试之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在繁华的北京，字节跳动的总部大楼矗立在一片灯火辉煌之中。我，一个普通的前端开发者，怀揣着对技术的热爱和对字节跳动的向往，踏上了这片神秘的土地，开始了我的前端面试之旅。
第一次面试，我带着满满的自信和期待走进了会议室。面试官是一个中年男子，他的眼神中透露出严谨和专业。他开始提问：“你能解释一下JavaScript的事件循环吗？”我回答得滔滔不绝，但面试官的眼神却越来越冷淡。最后，他告诉我：“你的理论知识很扎实，但是缺乏实战经验。”我失落地离开了会议室。
回到家，我开始反思自己的问题。我意识到，理论知识固然重要，但是没有实战经验，就无法真正理解和掌握这些知识。于是，我开始寻找各种前端项目进行实践，从简单的HTML和CSS布局，到复杂的JavaScript交互和性能优化，我都一一尝试。
第二次面试，我再次走进字节跳动的会议室。这次，面试官是一个年轻的女性，她的眼神中充满了挑战和期待。她问：“你能解释一下React的生命周期函数吗？”我深吸一口气，然后详细地解释了React的生命周期函数，包括componentWillMount、componentDidMount、componentWillUpdate、componentDidUpdate、componentWillUnmount等。我还结合自己的实战经验，解释了如何在生命周期函数中进行状态管理和副作用处理。
面试官听完后，眼神中闪过一丝惊讶。她问我：“你是如何理解前端开发的？”我回答：“前端开发不仅仅是编写代码，更是一种解决问题的思维方式。我们需要理解用户的需求，设计出易用、高效、美观的界面。同时，我们还需要关注性能，确保网页在各种设备和网络环境下都能流畅运行。”
面试结束后，我感觉自己仿佛经历了一场激战。虽然结果还未揭晓，但我知道，无论结果如何，这次面试之旅都让我收获了很多。我更加深入地理解了前端开发的知识点，也更加明白了自己的不足和需要改进的地方。
这就是我在字节跳动的前端面试之旅。虽然过程艰难，但我从未放弃。我相信，只要我坚持下去，总有一天，我会站在字节跳动的舞台上，用自己的技术为这个世界带来改变。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc1b07acfd8f61d56a9c14ce9193ea1a/" rel="bookmark">
			Linux杀掉僵尸进程方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明： 一般在使用pytorch训练网络模型时，可能会不正确的终端训练，导致进程僵尸，GPU依然被占用的情况。
解决办法： 查看进程的ID及其父进程ID指令：
ps -ef | grep defunct | more 假设输出如下：
Tokey+ 7567 2959 4 01:06 ? 00:15:03 [python] &lt;defunct&gt; Tokey+ 7675 2964 0 Oct18 ? 00:00:19 [python] &lt;defunct&gt; Tokey+ 45815 27058 0 06:15 pts/3 00:00:00 grep --color=auto defunct 以上对应：UID PID PPID …
UID：用户ID
PID：进程ID
PPID：父进程ID
如果你使用命令 kill -9 7567 尝试杀死ID为7567的进程，可能会没效果。要想成功杀死该进程，需要对其父进程（ID为2959）执行kill命令 kill -9 2959 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07437205eba2ae35386f1363a5b9288c/" rel="bookmark">
			掩膜（mask）的介绍和位与运算结合使用（binwise_and）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
1、掩膜的介绍
1）什么是掩膜？
2）掩膜的作用
3）在python的函数
2、位与"操作（bitwise_and）的介绍
1)什么是位与？
2）在python的函数
3、位与"操作（bitwise_and）和掩膜（mask）的介绍
1）什么时候用其结合？
2）主要应用：
二、代码实现
1、实现目的
2、提供数据
3、代码块
1)导入库
2）主要代码
3）代码结果
一、引言 1、掩膜的介绍 1）什么是掩膜？ 在计算机图像处理中，"掩膜"（Mask）是一种用于选择、过滤或隐藏图像中特定区域的技术。掩膜通常是一个与原始图像具有相同维度的矩阵，其中的元素决定了是否要保留、修改或遮挡对应位置的图像像素。
2）掩膜的作用 掩膜的主要作用有以下几个方面：
选择区域：掩膜可以用来选择图像中的特定区域，通过将掩膜中特定位置的像素值设置为合适的数值（通常是1或非零值），从而使这些区域在后续处理中被突出或保留。
过滤数据：掩膜可以用于过滤掉不感兴趣的图像区域，通过将掩膜中特定位置的像素值设置为零或其他适当的值，从而在后续处理中忽略这些区域。
图像融合：掩膜可用于合并不同图像或图像通道，通过对图像的不同部分应用不同的掩膜，然后将它们组合在一起。
遮罩操作：掩膜也可用于在图像上创建遮罩或蒙板，以实现透明度、混合或融合效果。
图像处理：掩膜还可用于应用各种图像处理操作，如滤波、卷积、锐化或模糊，只对掩膜内的区域进行处理。
在图像处理软件和编程中，掩膜通常是一个矩阵或图像，其中的像素值决定了如何影响原始图像的对应像素。掩膜可以用于各种图像处理任务，包括图像分割、特征提取、滤波、边缘检测等。掩膜的灵活性使其成为图像处理中重要的工具。
3）在python的函数 cv2.calcHist(images, channels, mask, histSize, ranges, hist=None, accumulate=None) 参数详见
注：这里的mask就是掩膜
2、位与"操作（bitwise_and）的介绍 1)什么是位与？ bitwise_and 是位运算操作之一，通常用于对二进制数进行按位与操作。在编程中，特别是在使用编程语言如Python、C++等时，bitwise_and 可以用于执行按位与操作。
2）在python的函数 cv.bitwise_and(src1,src2,mask) 参数为：
src1:第一个数据
src2：第二个数据
mask:掩膜
3、位与"操作（bitwise_and）和掩膜（mask）的介绍 1）什么时候用其结合？ 特别是在图像处理和计算机视觉中。这种结合通常用于选择、过滤或操作图像中的特定区域，以便进行进一步的处理或分析。
2）主要应用： 图像分割：掩膜可以定义一个区域，该区域中的像素将与图像进行按位与操作。这将使你能够提取或突出图像中的感兴趣区域，同时忽略其他区域。
滤波操作：你可以使用掩膜来定义一个滤波区域，然后对该区域进行滤波操作，如平均滤波或高斯滤波。这样可以仅对图像的特定部分进行平滑处理，而保留其他区域的细节。
边缘检测：掩膜通常用于定义用于边缘检测的卷积核。卷积核是一个小矩阵，用于检测图像中的边缘。通过将卷积核与图像进行按位与操作，可以找到图像中的边缘。
颜色掩膜：在彩色图像中，你可以创建一个颜色掩膜，以选择特定颜色范围内的像素。然后，将这个颜色掩膜与原始图像进行按位与操作，以突出或选择特定颜色。
图像混合：你可以使用掩膜来定义两个图像的混合区域。通过将两个图像与各自的掩膜进行按位与操作，然后将结果合并，可以实现图像的混合效果。
综上所述，结合位与操作和掩膜允许你精确地控制图像处理的区域，从而实现许多不同的图像处理和分析任务。这种结合在计算机视觉和图像处理应用中非常常见。
二、代码实现 1、实现目的 加载了一幅灰度图像，创建了一个掩膜，然后使用掩膜对图像进行按位与操作，最后计算和可视化了图像中特定区域的灰度直方图。这种方法可以用于图像分析和处理中的区域选择和直方图计算。
2、提供数据 “apple.png”:
3、代码块 1)导入库 import cv2 import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07437205eba2ae35386f1363a5b9288c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3dfbff6458095c096338fec9e9aff99/" rel="bookmark">
			给出 n，请输出一个直角边长度是 n 的数字直角三角形。所有数字都是 2 位组成的，如果没有 2 位则加上前导 0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main() { int n,cnt=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) { for(int j=i;j&lt;=n;j++) //输入左上直角三角形的方法 { cnt++; //计数都要初始化 计数也可以用来输入按顺序的数字 新思路get！ if(cnt&lt;10)//判断是不是两位数 { printf("%02d",cnt); //两位 没有两位就用0补齐 } else { printf("%d",cnt); } } printf("\n");//打印三角形都要在第一层大循环之后换行 } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f61b0372859e387c000de9cd8ad8f0/" rel="bookmark">
			RV1126 WIFI移植记录AP6256
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AP系列驱动位置，这个是ap通用驱动
kernel/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd
查看原理图和ap6256手册
确认gpio口对应情况，检查供电
WIFI_WAKE_HOST是中断脚，当WiFi开始工作时，唤醒cpu，从低功耗模式到工作模式
HOST_WAKE_WIFI是电源使能脚，WiFi即使在低功耗模式也需要一直使能，否则会造成WiFi内部状态丢失，导致唤醒失败
我这里用万用表检查过供电情况，对照手册确认是工作在正常电压范围内，调试一切硬件都要确保供电正常，这是硬件能否工作的决定性因素。
设备树配置
另外我的AP6256是有37.4MHz的晶振提供时钟的，因此不用主板去给他提供时钟了
WiFi使能脚我不是通过gpio供电的，而是硬件只连的方式，所以设备树没写使能脚
sdio_pwrseq: sdio-pwrseq { compatible = "mmc-pwrseq-simple"; // clocks = &lt;&amp;hym8563&gt;; //时钟由WiFi自带37.4MHz晶振提供 // clock-names = "ext_clock"; pinctrl-names = "default"; pinctrl-0 = &lt;&amp;wifi_enable_h&gt;; /* * On the module itself this is one of these (depending * on the actual card populated): * - SDIO_RESET_L_WL_REG_ON * - PDN (power down when low) */ reset-gpios = &lt;&amp;gpio1 RK_PD1 GPIO_ACTIVE_LOW&gt;; }; wireless_wlan: wireless-wlan { compatible = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f61b0372859e387c000de9cd8ad8f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dce749495a7309ec1234645c8bc05034/" rel="bookmark">
			mac虚拟机安装配置qt遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人的环境大致如下：
VMware Workstation 16pro
Mac镜像 macOS.Mojave10.14.6 （后面在系统中升级到了 Sonoma 14.0）
Qt5.9.6
Xcode15.0
问题1：
环境都安装好后，qt创建工程一直只有.pro文件，看不到头文件和cpp那些，并且也无法创建新文件或添加现有文件。然后报错：
Project ERROR: failed to parse default search paths from compiler output.
这个问题大多数博客都是说Kits编译器的问题，不过我配置了之后都正常的，还是不行。也由于本身在mac上搞这块的比较少，资料也找不到多少。
后来问了同事，然后他在外网英文网站帮我查，大概是这个链接 https://bugreports.qt.io/browse/QTBUG-117519 。
大概来说的话就是 Qt 要根据那个文件里的一些定义来搭建编译环境，但是那个文件写的有 BUG。这个我也不清楚为啥，并且我用的也是官方提供的安装包安装的qt。然后帮我把Qt安装目录下的 mkspecs/features/toolchain.prf 文件里的内容进行了修改。
之后我关掉qt creator重新打开，这次头文件、cpp那些都正常显示出来了。
问题2：
虽然前面文件能正常显示出来了，但是编译运行却跑不起来。报错如下：
This application failed to start because it could not find or load the Qt platform plugin “cocoa” in “”.
Reinstalling the application may fix this problem.
程序异常结束。
这个好像是说在mac使用qt需要这个cocoa依赖，然后找不到吧。但是我在qt目录下，/Users/zhaoyuhui/Desktop/qt5.9.6/5.9.6/clang_64/plugins/platforms，发现是有那些相应的文件的。
于是想尝试添加环境变量，使用在终端输入 export QT_PLUGIN_PATH=路径 或者在 /etc/paths 中添加以上路径也不行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dce749495a7309ec1234645c8bc05034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77298cbcee29d4cde762e712c117fcac/" rel="bookmark">
			浅谈单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		饿汉式懒汉式/Double check（双重检索）静态内部类枚举单例 饿汉式 private static final DispatchSingleton instence = new DispatchSingleton(); public static DispatchSingleton getInstence() { return instence; } 饿汉式是在jvm加载这个单例类的时候，就会初始化这个类中的实例，在使用单例中的实例时直接拿来使用就好，因为加载这个类的时候就已经完成初始化，并且由于是已经加载好的单例实例因此是线程安全的，并发获取的情况下不会有问题，是一种可投入使用的可靠单例。
优点：使用起来效率高、线程安全
缺点：由于jvm在加载单例类的时候需要初始化单例实例，因此在加载单例的时候针对jvm内存不够友好。
懒汉式 private static DispatchSingleton mSluggardInstence; public static DispatchSingleton getSluggardInstence(){ if (mSluggardInstence==null){ mSluggardInstence=new DispatchSingleton(); } return mSluggardInstence; } 最简单的懒汉式，核心思想就是弥补饿汉式的缺点，在jvm加载单例类的时候不去初始化实例，而是在第一次获取实例的时候再去初始化实例。但是这样理论完美的单例在使用的时候有一个致命的缺点，在多线程使用的情况下，有时会出现不同线程从单例实例中获取不同的实体。针对多线程环境中并不可靠。
优点：针对jvm内存比较友好，实现了实例的懒加载。
缺点：多线程环境下不安全，会出现不同线程从单例实例中获取不同的实体的情况。
private static volatile DispatchSingleton mSluggardInstence; public static DispatchSingleton getSluggardInstence() { if (mSluggardInstence == null) { synchronized (DispatchSingleton.class) { if (mSluggardInstence == null) { mSluggardInstence = new DispatchSingleton(); } } } return mSluggardInstence; } synchronized 针对懒汉式的这种线程不安全的现：在单例初始化时，多线程存在创建多次实例的风险
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77298cbcee29d4cde762e712c117fcac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20990ccf02ace619211019dde4ed8d32/" rel="bookmark">
			[常用组件]文本省略 &#43; Tooltip提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[常用组件]文本省略 + Tooltip提示 很常用就对了
单行省略 .text { width: 100px; text-overflow: ellipsis; overflow: hidden; word-break: break-all; white-space: nowrap; } 多行省略 .text{ width: 100px; display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 2; -webkit-box-orient: vertical; } 兼容性较好,Chrome20以上基本都OK
兼容性查询：https://caniuse.com/?search=-webkit-box
判断文本是否溢出 node.clientWidth &lt; node.scrollWidth // 单行 node.clientHeight &lt; node.scrollHeight // 多行 function isOverflowing(node: HTMLElement): boolean { if (!node) return false; const isSingleLine = node.offsetHeight === node.scrollHeight; if (isSingleLine) { return node.clientWidth &lt; node.scrollWidth; // single line overflow } else { return node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20990ccf02ace619211019dde4ed8d32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b091ae04ea6e6b84c33b55172e6aece9/" rel="bookmark">
			解决Github Markdown图片显示残缺的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: 解决Github Markdown图片显示残缺的问题
tags:
个人成长
categories:杂谈 在Github存放Markdown文档，如果图片没有存放在Github服务器上，github会尝试生成Github图片缓存，使用Github图片缓存，进行实际的展示。但比较蛋疼的是，如果原图片尺寸很大，缓存图片失败，会只显示一部分图片内容。
预览图显示
原图缓存图对比
缓存图片的格式大概是这样
https://camo.githubusercontent.com/ac3c95be743bed67a21823a6fc976264729c84678d5fd557aca8c71bf5a5a632/68747470733a2f2f63646e2e66616e677975616e7869616f7a68616e2e636f6d2f6173736574732f313631353532393239373634385244376843686a7a2e6a706567 解决方案 如果我们发现图片有问题，需要手动触发Github图片缓存，运行 curl -X PURGE {图片url} 即可
curl -X PURGE https://camo.githubusercontent.com/ac3c95be743bed67a21823a6fc976264729c84678d5fd557aca8c71bf5a5a632/68747470733a2f2f63646e2e66616e677975616e7869616f7a68616e2e636f6d2f6173736574732f313631353532393239373634385244376843686a7a2e6a706567 运行curl -X PURGE触发重新缓存后，再次使用浏览器尝试访问图片url, 可以看到完整的图片 (如果依然不完整，就多触发几次)
如果你想完全规避以上情况，建议直接将图片存储到github仓库，我写过一个开源小工具，专门用于把README.md里面的图片进行一键转储
https://github.com/zhaoolee/replace_readme_md_image
小结 缓存问题是编程领域的经典问题，用得好可以节约珍贵的算力，提升用户体验，做的烂就全是bug, 我觉得设计缓存机制最基础的原则就是可以很方便地清理缓存，就像Github的图片缓存一样，即使缓存有问题，也允许用户通过简单的命令清理旧图缓存，触发新缓存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e0054d3ea74ad9580d5307fce66ff3/" rel="bookmark">
			br、deflate、gzip压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见http响应头的三种压缩算法标志，客户端请求头中一般显示支持哪几种压缩方式：列如
通常出现在 "Accept-Encoding" 头部中。
gzip： gzip 是一种流行的压缩算法，它能有效地减小传输的数据大小。当服务器在响应头中包含 "gzip" 时，它表明服务器支持使用 gzip 压缩算法来压缩响应数据。大多数现代浏览器都支持 gzip 压缩。
deflate： deflate 也是一种压缩算法，它用于减小传输的数据大小。当服务器在响应头中包含 "deflate" 时，它表明服务器支持使用 deflate 压缩算法来压缩响应数据。大多数现代浏览器同样支持 deflate 压缩。
br（Brotli）： Brotli 是一种新一代的压缩算法，它通常提供比 gzip 和 deflate 更好的压缩率，从而减小传输的数据大小。当服务器在响应头中包含 "br" 时，它表明服务器支持使用 Brotli 压缩算法来压缩响应数据。然而，支持 Brotli 压缩的浏览器相对较新，所以在一些旧的浏览器上可能不受支持。
当客户端浏览器发送请求时，它会在 "Accept-Encoding" 头部中列出它支持的压缩算法。服务器将根据这些算法来选择最合适的压缩方式，以便在传输数据时减小带宽消耗和提高性能。
通常，服务器会优先选择 Brotli（br），然后是 gzip，最后是 deflate，以提供最佳的压缩效果。如果客户端浏览器不支持任何一种压缩算法，服务器将以未压缩的形式传送内容。这有助于提高网站的性能和用户体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dccdface8a4ab4f6f81d875d1525b699/" rel="bookmark">
			Serializable 和Parcelable的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Serializable和Parcelable接口可以完成对象的序列化的过程，当我们需要通过Intent和Binder传输数据时就需要使用Parcelable或者Serializable，有时候我们还需要把对象持久化到存储设备上或者通过网络传输给其他客户端，这个时候也需要使用Seriazable来完成对象的持久化.
Serializable简介 Serializable 是Java所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。使用Serializable来实现序列化相当简单，只需要类在声明中指定一个类似下面的标示即可实现默认的序列化过程。
Parcelable接口 Parcelable也是一个接口，只要实现了这个接口，一个类的对象就可以实现序列化和并且通过Intent和Binder传递。
1、序列化功能由writeToParcel来完成，最终是通过Parcel中的一些列write方法来完成的。2、反序列化是由CREATOR来完成，其内部标明了如何创建序列化对象和数组，并通过Parcel的一些列read方法来完成反序列化过程。3、内容描述功能由describeContents方法来完成，几乎在所有情况下这个方法都应该返回0，仅当前对象中存在文件描述符时，此方法返回1。 平台区别 Serializable是属于 Java 自带的，表示一个对象可以转换成可存储或者可传输的状态，序列化后的对象可以在网络上进行传输，也可以存储到本地。Parcelable 是属于 Android 专用。不过不同于Serializable，Parcelable实现的原理是将一个完整的对象进行分解。而分解后的每一部分都是Intent所支持的数据类型 编写上的区别 Serializable代码量少，写起来方便Parcelable代码多一些，略复杂 选择的原则 1、如果是仅仅在内存中使用，比如activity、service之间进行对象的传递，强烈推荐使用Parcelable，因为Parcelable比Serializable性能高很多。因为Serializable在序列化的时候会产生大量的临时变量， 从而引起频繁的GC。2、如果是持久化操作，推荐Serializable，虽然Serializable效率比较低，但是还是要选择它，因为在外界有变化的情况下，Parcelable不能很好的保存数据的持续性。 本质的区别 1、Serializable的本质是使用了反射，序列化的过程比较慢，这种机制在序列化的时候会创建很多临时的对象，比引起频繁的GC、2、Parcelable方式的本质是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的类型，这样就实现了传递对象的功能了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e6648fb9c20109620eda2c9e03e5cf/" rel="bookmark">
			【Linux&#43;opencv】安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、搭建编译环境 在Linux系统下使用C++开发opencv项目，首先要搭建C/C++开发环境。
1、在终端输入以下代码，以安装C/C++编译器（GCC/G++）。
sudo apt install gcc sudo apt install g++ 2、安装cmake编译工具
（在openCV2.2版本之后，需要用cmake来生成Makefile文件，在安装OpenCV之前，要安装cmake以及cmake依赖库）
sudo apt install cmake 二、安装相关依赖库 1、安装libgtk
(GTK是一个Linux平台下基于Xwindows图形窗口的图形用户编程接口工具，可以借助它开开发Linux平台下基于Xwindows的图形用户界面)
sudo apt install libgtk2.0-dev 2、安装pkg-config
(在Linux系统下安装第三方软件时要用到第三方软件的头文件以及相关库，在编译时指定库和头文件是十分麻烦的，而pkg-config能够把这些头文件和库文件的位置指出来给编译器使用)
sudo apt install pkg-config 三、安装OpenCV 1、在OpenCV官网下载sources。
（https://opencv.org/releases/）
2、打开安装包所在位置，在终端输入：
（解压安装包）
unzip opencv-4.5.5.zip 3、解压完成后，在当前目录下会生成opencv-x.x.x文件夹，在终端输入：
（进入该文件夹）
cd opencv-x.x.x 4、在此路径下新建一个编译目录build。
mkdir build 5、进行cmake-make编译
cmake .. make -j2 make -j2是指2核同时编译，可以根据自己的核数进行调整，比如-j5，核数越多编译速度就越快。
以上操作如果不成功的话尝试以下命令
cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. make -j2 6、在终端输入sudo make install进行安装
sudo make install 四、配置环境变量 1、进入root权限，在终端输入：
sudo -i vim /etc/ld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4e6648fb9c20109620eda2c9e03e5cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431ab79035c3b04123884f252bc24f50/" rel="bookmark">
			Javaweb初学——【JSP&#43;Servlet&#43;JDBC】登录注册简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@【JSP+Servlet+JDBC】登录注册
**登录页面设计** 1，数据库设计与连接 user表， 2，前端设计 登录页面 login.jsp yes ---&gt;success.jsp no ----&gt;error.jsp 注册页面 register.jsp yes ---&gt;success.jsp no ----&gt;error.jsp 3,后端设计 登录---&gt;loginServlet.java 注册---&gt;rigsterServlet.java 效果展示
页面十分简单，主要是我为了学习http与后端以及数据库连接。
1，数据库连接 1.注册驱动：
Class.forName("com.mysql.jdbc.Driver");
2.获取连接
Connection con = DriverManager.getConnection(url , username , password ) ; 3.创建一个preparedStatement
PreparedStatement pstmt = con.prepareStatement(sql) ; 4.执行SQL语句
ResultSet rs = stmt.executeQuery("SELECT * FROM ...") ; JDBCUtils.java
package com.company.utils; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; public class JDBCUtils { public JDBCUtils(){} private static String driverClass; private static String url; private static String username; private static String passward; private static Connection con; static { try { InputStream is = JDBCUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431ab79035c3b04123884f252bc24f50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c4d29c618f08335c6a7ed9a90380538/" rel="bookmark">
			CPU飙高解决思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现CPU飙高时操作 出现cpu飙高时使用先试用top命令查看进程，确定是java进程还是mysql 找到进程号
一、如果是mysql进程 1、那么使用mysql终端或者数据库链接工具执行如下sql语句查看正在执行的sql：show processlist 2、查询慢sql，截取慢sql文件前面10000行数据导出来分析 开启慢sql##进入mysql终端 show global variables like '%query%'; #开启慢sql set global slow_query_log=1; #10s以上的sql才记录慢sql set global long_query_time=10; 使用mysqldumpslow分析-s ORDER what to sort by (al, at, ar, c, l, r, t), 'at' is default al: average lock time ar: average rows sent at: average query time c: count l: lock time r: rows sent t: query time -r reverse the sort order (largest last instead of first) -t NUM just show the top n queries -a don't abstract all numbers to N and strings to 'S' -n NUM abstract numbers with at least n digits within names -g PATTERN grep: only consider stmts that include this string -h HOSTNAME hostname of db server for *-slow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c4d29c618f08335c6a7ed9a90380538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8490fcc6253930583c2867be48b793/" rel="bookmark">
			生产环境Mysql导致CPU飙高的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题表现 生产出现ng经常502，后通过监控mysql服务器cpu飙高
出现CPU飙高时操作
出现cpu飙高时使用先试用top命令查看进程，确定是java进程还是mysql 找到进程号 &lt;pid&gt;
一、如果是mysql 1、那么使用mysql终端或者数据库链接工具执行如下sql语句查看正在执行的sql：show processlist
2、查询慢sql，截取慢sql文件前面10000行数据导出来分析
3、查询进行中的事务，SELECT * FROM information_schema.INNODB_TRX
二、如果是java进程 1、执行命令查看占用最高的线程&lt;tid&gt; ：top -H -p 2、把线程占用最高的id转换为16进制 &lt;tid16&gt; ：printf “0x%x\n” &lt;tid&gt;
3、打印线程堆栈 ：jstack &lt;pid&gt; &gt; /home/finance/jstack.log
4、打开jstack.log 找到步骤3中的十六进制线程号 进行分析 搜索:nid=&lt;tid16&gt; 找到线程名和代码位置
事后分析： 一、mysql
1、分析show processlist 结果中的info查看sql问题，首先使用explain查看执行计划效率，如果效率无问题，查看是否调用频繁比如循环中不停调用
2、分析慢sql使用explain查看执行计划，效率有问题优化sql、优化索引
3、是否有事务死锁，如果有查看原因
二、JAVA
jsatck.log定位到代码后直接分析代码
已确定mysql服务器cpu飙高：因此分析慢sql 数据量
cbcc_work_order：5022940
cbcc_market_call_list：1994558
cbcc_work_order_visble_org：9022940
在慢sql发现该sql频繁出现
select * left join sys_organization t1 on t1.ID=t0.ORG_ID left join sys_organization t2 on t0.RV_ORG_ID=t2.ID where t0.info_sources_code='13' and t0.org_id=#{orgId} and t0.status=1 and t0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd8490fcc6253930583c2867be48b793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443b2fe1d4f9e9d5f0044dab03a4a1a1/" rel="bookmark">
			二叉树递归遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 二叉树遍历是根据节点的位置来判断 // 前序：根左右 1 2 4 5 3 6 7 // 中序：左根右 4 2 5 1 6 3 7 // 后序：左右根 4 5 2 6 7 3 1 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; void PreOrder(TreeNode* root, vector&lt;int&gt; &amp;result) { if(root == nullptr) { return; } // 前中后序只需调整以下三个函数的顺序 result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/443b2fe1d4f9e9d5f0044dab03a4a1a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1709f3062d37105f8cfa65c0942f4457/" rel="bookmark">
			嵌入式软件工程师笔试题-1（含答案讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是预编译？什么时候需要预编译?
2.char *const p和char const *p 以及const char *p三个区别
3.以下程序的输出结果
4. 以下代码中的sizeof用法有什么问题？
5.一个32位的机器，这个机器的指针是几位？ 6.代码输出结果
7.下面代码出错在哪里？
8.下面代码出错在哪里？
9.写一个标准的宏，这个宏输入两个参数并返回较小的哪一个。
10.嵌入式系统经常要用单无羡循环，你怎么用c编写死循环？ 11.关键字static的作用是什么？ 12.关键字const有什么含义？ 13.关键字volatile有什么含义？并列出三个例子 14.int(*s[10](int)) 表示什么意思？
15.看下列程序回答问题 16.交换两个变量的值，不适用第三个变量。即a=3,b=5,交换之后a=5,b=3; 17.C和C++ 中的struct有什么不同？
18.以下代码会出现什么结果？ 19.以下代码会出现什么结果？ 20. 列举几种进程的同步机制，并比较其优缺点
21.进程之间的通信途径 22.进程死锁的原因 23.死锁的4个必要条件 24.死锁处理 25.操作系统当中进程调度策略有哪几种？ 26.类的静态成员和非静态成员的区别 27.纯虚函数该怎么定义？使用的时候要注意什么？ 28.数组和链表区别
29.JSO的七层模型是什么？ TCP/UDP属于哪一层？TCP/udp有什么优缺点？
30.根据代码回答问题
31.（void*）ptr和（*（void**））ptr的结果是不是相同？其中ptr为同一个指针 32.已知一个数组table，用一个宏定义，求这个数据的元素个数 1.什么是预编译？什么时候需要预编译? 答：预编译又可以叫做预处理，是进行一些代码文本的替代工作；
什么时候需要预编译：
不经常需要改动的大型代码；程序有多个模块组成，所有的代码都使用同一组标准的函头文件和相同编译选项 2.char *const p和char const *p 以及const char *p三个区别 char *const p 是一个指针常量，这意味着指针p的值（即它指向的地址）是不可以被改变的，但你可以通过这个指针来修改它所指向的数据。
char const *p 和 const char *p 都是指向常量的指针，这意味着你不能通过这个指针来修改它所指向的数据，但指针p本身（即它指向的地址）是可以改变的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1709f3062d37105f8cfa65c0942f4457/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/885fc6ed70aa74974f6beb340e383780/" rel="bookmark">
			Linux同时安装多个版本的JDK&amp;linux多版本JDK切换配置- [Centos 安装JDK]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux同时安装多个版本的JDK&amp;linux多版本JDK切换配置- [Centos 安装JDK] 一、查询系统是否已经安装jdk rpm -qa|grep java
或 rpm -qa|grep jdk
或 rpm -qa|grep gcj 二、卸载已安装的jdk Centos7存在已安装的JDK1.7时，可以使用以下方式删除1.7的openJDK
rpm -e --nodeps java-1.7.0-openjdk-1.7.0.51-2.4.5.5.el7.x86_64
rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.51-2.4.5.5.el7.x86_64
三、下载安装配置JAVA环境变量 JDK下载地址:
[JDK下载地址](Java Downloads | Oracle)
JDK21
JDK1.8
解压到安装目录
个人喜欢将jdk安装到: /opt/java/目录下
安装准备 ------------------------------------------------------------------- cd /opt/ 切换到opt目录 mkdir java 创建java目录 ------------------------------------------------------------------ 使用wget下载JDK的tar安装包或复制下载好的安装包到/opt/java/目录 cd /opt/java/ 切换java目录 tar -zxvf jdk-8u391-linux-x64.tar.gz ---解压jdk1.8 编辑JDK环境配置参数
vim /etc/profile vim /etc/profile --- 编辑参数配置 配置如下: ---------------------------------------------------------------------- export JAVA_HOME=/opt/java/jdk1.8.0_391 export PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ---------------------------------------------------------------------- source /etc/profile --- 刷新参数配置 java -version --- 查看Java版本，看是否配置成功 四、java多版本安装配置和切换 在/opt/java/目录下安装多个版本的JDK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/885fc6ed70aa74974f6beb340e383780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/977ee24cd83909ebe236e2fe61d57699/" rel="bookmark">
			@Scheduled 注解的基本介绍、使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Scheduled 注解基本介绍 ​ @Scheduled 比较官方一点的介绍 ： 是 Spring 框架中用于定时调度任务的注解。它允许您将一个方法标记为一个定时任务，然后可以配置任务的执行时间间隔或 cron 表达式。这个注解通常与 Spring Boot 一起使用，以创建定时任务。
​ 其实很简单，就是说，被@Scheduled标注的方法，会定时的执行。刚开始接触时，会有点理解不了这个定时执行，因为程序中的方法一般都是被调用之后才会执行。而这个定时执行是什么意思呢？没错，就是你想的这个意思：在spring项目中，主程序执行，项目启动之后，被@Scheduled标注的方法，就会定时的执行（每隔这么久时间就执行一次这个方法），不需要调用。
一般会应用在，比如： 定时执行任务、定时数据同步、缓存刷新、定时提醒和通知、定时报警和日志记录、定时任务调度管理 等场景
@Scheduled 注解基本使用 对这个注解有了大致的了解之后，我们来讲一下怎么使用
因为是Spring框架中的注解，所以当然是要引入Spring Boot Starter 或其他 Spring 的相关依赖啦
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 为了使@Scheduled生效，我们需要在 Spring Boot 应用中启用定时任务调度，很简单，在主应用类上添加 @EnableScheduling 注解就OK了
@SpringBootApplication @EnableScheduling	// 启用定时任务 public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } 然后来看一下@Scheduled 在程序中在哪里定义、怎么去配置定时执行的时间
@Scheduled 注解通常用于Spring管理的Bean的方法
@Component // 声明这个类为一个Spring管理的Bean public class MyScheduledBean { @Scheduled(fixedRate = 5000) // 每隔5秒执行一次 public void myScheduledMethod() { // 这里放置需要定时执行的逻辑 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/977ee24cd83909ebe236e2fe61d57699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f71331a71c883569f9d30c8d61d0009/" rel="bookmark">
			QT自定义空间之软键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT自定义空间之软键盘 1.功能列表2.效果2.1 中文键盘&amp;汉字输入2.2 英文输入法2.3 数字键盘2.4 数据键盘效果 3.部分代码3.1 汉字输入3.2 切换数字键盘3.3 键盘显示&amp;隐藏3.4 控件提升3.5样式设置3.6 使用QLineEditAllKeyBoard 控件 1.功能列表 支持中文输入法支持引文输入支持数字键盘支持中文/英文/数字软键盘切换 2.效果 2.1 中文键盘&amp;汉字输入 2.2 英文输入法 2.3 数字键盘 2.4 数据键盘效果 3.部分代码 3.1 汉字输入 基于googlepingyin输入
void KeyboardForm::displayHanzi() { if (m_hanziPageCnt &lt;= 0) { m_listHanzi[0]-&gt;setEnabled(false); m_listHanzi[hanziCandidate-1]-&gt;setEnabled(false); for (int i = 0; i &lt; hanziCandidate-2; i++) { m_listHanzi[i+1]-&gt;setText(""); m_listHanzi[i+1]-&gt;setEnabled(false); } } else if (m_hanziPageCnt == 1) { m_listHanzi[0]-&gt;setEnabled(false); m_listHanzi[hanziCandidate-1]-&gt;setEnabled(false); int len = m_pinyin.HanziModel.size(); for (int i = 0; i &lt; len; i++) { m_listHanzi[i+1]-&gt;setText(m_pinyin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f71331a71c883569f9d30c8d61d0009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798f90008b77e4b5f87c734a647e3afb/" rel="bookmark">
			都2023了！别再问我，UI自动化测试怎么做了……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文关键词：移动端UI自动化思路
大家好，我是老司机。之前测试交流群里有同学问“有没有自动化测试在工作中的案例可以分享“，有是有的。
今天我会详细的描述一个【UI自动化实战在实际工作中的应用】，这是之前贝壳找房我们团队做的一个真实UI自动化案例，由于APP版本更新迭代太多次，代码也有缺失，所以一些细节没法完全描述清楚。
但我会把做这个项目的思路和流程，详细的分享出来，希望能帮到大家。
本文干货预警，全文5300字，预计阅读时间14分钟。
目录 一、自动化测试的主要分类
二、适合做UI自动化的场景
1）【回归验证】
2）【巡检】
3）【移动端的埋点测试】
三、UI自动化实战案例
1）项目背景
2）项目选型
3）开始安装部署
4）执行测试方案
四、对UI自动化的思考
五、自动化测试学习资源分享
一、自动化测试的主要分类 自动化的形式主要可以分为接口自动化和UI自动化。
根据测试金字塔理论，越往顶层，ROI（投入产出比）就越高。
一般大家都会加大力度投入到接口自动化的建设当中，而UI自动化因为投入产出比太低了，所以基本上对UI自动化的建设会投入比较少。
但这并不代表UI自动化就完全没有必要做，在下边部分我会列举3种【适合做UI自动化的场景】。
二、适合做UI自动化的场景 一般来说有3种场景是比较适合做UI自动化的：回归验证、巡检、移动端埋点测试。
1）回归验证
项目上线或者APP发版，传统的手工测试耗时较多。一到上线发版日，尤其是改动较大的发版，同事们都是采用手工用例走查的方式去进行验证回归，压力非常大！
当时一般一次上线回归验证，基本上都要花费30分钟-2个小时，对于测试人员和开发人员来说，都是一种煎熬。
有时候人手不够了，还需要产品、运营一块协助回归验证，效率十分低下。
这个时候，可以用UI自动化去覆盖一些功能改动较少的功能。
2）巡检
线上环境复杂，容易出现各种意想不到的问题，而手工巡检测试压力大。
比如：
运营配置错误；
用户的一些非常规的操作；
不同手机终端的兼容性问题。
这些问题从暴露给用户，到反馈到开发这边，再到开发修复解决，可能都已经过去很长时间。
以往，同事一般会定期人工线上巡检去发现一些线上问题。
这么做确实也有效果，但问题在于：
人工巡检也会耗费不少测试时间，有时候忙起来，就很难坚持执行下去。
这个时候，可以用UI自动化去覆盖一些主流程，确保主流程不要出问题。
3）移动端的埋点测试
如果一直做简单且重复性高的测试工作，不仅效率低，也非常严重打击测试人员的工作积极性。
最典型的就是移动端的埋点测试，传统的测试方法，就是在手机上操作，触发埋点上报，然后通过手机抓包，获取埋点数据，然后再依据埋点文档，去对每个字段进行一一人工校验。
这一通操作很无脑，但是实际上花费的时间是相当多的，埋点需求一多起来，可能测一天都测不完，还非常消磨测试人员的精力：每次测试完埋点，都感觉自己的视力下降了很多（对数据废眼）。
这个时候，可以尝试用UI自动化去自动触发埋点，并通过一些校验逻辑，对埋点进行自动校对。
4）除此之外，UI自动化还可以解决：
APP 兼容性测试
APP 竞品对比测试
APP 数据抓取
...
如果你还有更多的UI自动化实践案例，欢迎评论区交流。
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：110685036 三、UI自动化实战案例 目录如下：
1）项目背景
2）项目选型
3）开始安装部署
4）执行测试方案
1）项目背景
之前我还在贝壳找房的时候，随着公司业务的不断增长，APP功能越来越多，每一次APP大发版，测试人员都需要花费比以往更多的精力去进行线上回归验证。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/798f90008b77e4b5f87c734a647e3afb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f49f3d2737c6f5863de8e232a0bb71cb/" rel="bookmark">
			Sql Server Report Service 使用简单说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ReportServices做为报表服务器，结合sql直接访问数据库提供基本的报表格式设置显示，可以快速开发报表，主要包含两部分内容：
1.ReportServices服务器配置搭建，承载报表的运行平台
2.设计报表
ReportServices配置
1． 进入报表服务管理器
2.分配Web服务URL的端口号并应用，注：在设计后部署时要用到即TargetServerURL
3.创建ReportServer数据库并应用(ReportServer数据库是ReportService运行时的基础数据库默认创建即可)
4.配置报表管理器URL并应用
设计报表
进入报表设计界面
2. 右击报表添加新报表（此处为引导设置），也可右击选择添加逐项添加数据源、报表
3. 完成添加后在右侧报表数据源中显示输出列、输入参数。结合工具箱完成报表表格设计并将字段拖拽到相应位置
4. 完成报表设计后右击项目 -&gt; 属性进行设置
5. 进入属性界面后,注意配置粗字体部分，TargetServerURL即在Report Service配置中web服务URL
6. 配置完成后右击项目选择部署，若单独修改数据源或报表也可右击单个部署
管理报表服务器
打开浏览器输入URL，进入报表管理器
2. 在文件夹设置中配置用户访问权限
通过URL访问报表
1.访问webUrl地址可以看到报表主目录（本示例：http://dev-pc:8099/ReportServer）
访问报表（RF1下Report1）页面示例
http://dev-pc:8099/ReportServer/Pages/ReportViewer.aspx?%2fRF1%2fReport1&amp;rs:Command=Render
另外有需要云服务器可以了解下风纳云fengnayun.com，海内外云服务器15元起步，三天无理由+7*72小时售后在线，公司持有idc许可证，提供“云服务器、裸金属服务器、高防服务器、香港服务器、美国服务器、虚拟主机、免备案服务器”等云主机租用服务以及企业上云的综合解决方案，具有“安全稳定、简单易用、服务可用性高、性价比高”等特点与优势，专为企业上云打造定制，能够满足用户丰富、多元化的应用场景需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2acf6c58b261e82c103d387df1cf42/" rel="bookmark">
			IDEA如何拉取gitee项目？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.登录gitee 说明：打开idea，在设置上面搜索框输入gitee，然后登录gitee注册的账号。
2. 创建gitee仓库 说明：创建idea中的gitee仓库。
3.寻找项目文件 说明：为需要添加gitee仓库的项目进行添加。
4.项目右键 说明：点击git后子菜单管理远程仓库。
5. 获取gitee项目的SSH 说明：打开到项目主页，将会有克隆/下载。点击后就会显示出对应的SSH的url。
6.添加项目地址 说明：这里以git@gitee.com:mquniversal/git-vue3.git为例进行展示。
7. Clone 说明：点击Git后，后面有子菜单。点击Clone添加项目的url。
8.成功 9.问题 说明：如果发生commit失败，一直提示连接失败！那么我们可以将gitee账号退出，然后重新登陆账号就行了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc980fc31738903f9653a488e3ed34f/" rel="bookmark">
			《树莓派不吃灰》第二十三期：在树莓派搭建个人摄影站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近zhaoolee添置了一台Sony ZV1 M2， 卡片机很小巧，可以塞到兜里，大大提升了出片的速度，为了展示这些照片，本期我会搭建一个运行在树莓派的摄影网站，同时支持外部访问。
在树莓派存放的好处是可以空间便宜，机械硬盘1TB只需要几十块钱，如果使用家庭内网访问网站，即使是超大的原图，也能以极快速度打开。
树莓派通过内网穿透，也能将网站开放到互联网。
最终效果 https://photography.v2fy.com/
点击图片，可以显示大图，宽屏模式下，如果原图保留了拍摄参数，左下角会显示
摄影网站基于Github开源项目 https://github.com/rampatra/photography ，开源项目支持运行gulp resize对摄影图片进行一键裁剪，裁剪后宽度为1024px的图片作为原片放入images/full 文件夹，宽度512px的作为预览图，放入images/thumbs文件夹。
但我希望images/full 放的是最原始的图片，运行gulp resize 后，基于images/full内的图片生成预览图，放入images/thumbs即可，
于是我重写了resize这段逻辑，代码存放在 https://github.com/zhaoolee/photography
photography 这个开源项目是默认基于Github Actions构建，然后使用Github Pages托管静态页，完成发布。但是在中国，Github Pages的图片资源被特色网络搞得无法访问。
为了应对特色网络环境，我把项目改造成了：项目依然托管在Github，但在本地完成静态网站的构建，将构建完成的静态网站资源，通过rsync发送到树莓派特定文件夹，就完成了部署。同时将项目资源发布到Github仓库作为备份。
另外我还做了一些优化，将图片放入fulls文件夹，即可实时自动生成预览图，并实时展示到网页上，原版需要手动运行 gulp resize
实际操作起来，只需将图片放入images/fulls文件夹，运行npm run push , 就完成了发布，并在Github做好了备份。
获取项目, 安装依赖 git clone --depth=1 https://github.com/zhaoolee/photography.git cd photography bundle install npm install 运行项目 npm run dev 浏览器打开http://127.0.0.1:4000 ， 就能看到zhaoolee的摄影网站展示资源，删除images/fulls 和images/thumbs 内的图片资源，将自己的图片放到images/fulls 刷新浏览器即可看到最终效果
生成静态网站 npm run build 运行以上命令后，会在根目录的_site文件夹生成网站所需的全部资源。
只要将_site下面的内容托管给树莓派的nginx就能对内网访问了。
在Nginx创建一个目录，用于存储_site的静态内容
sudo mkdir /usr/share/nginx/photography.v2fy.com sudo chown www-data:www-data /usr/share/nginx/photography.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cc980fc31738903f9653a488e3ed34f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f2e54caf2b8840b165fb62abf64483/" rel="bookmark">
			深入解析HTML三位重要成员，探索html、head和body标签的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟🌟🌟 专栏详解 🎉 🎉 🎉
欢迎来到前端开发之旅专栏！ 不管你是完全小白，还是有一点经验的开发者，在这里你会了解到最简单易懂的语言，与你分享有关前端技术和实用技巧的内容。此专栏的目标是提供易于理解且实用的内容，通过深入浅出的方式让大家掌握前端开发的核心概念和技能。我也相信，通过这个专栏，各位开发者们将更好地理解Web开发的本质，从而掌握更深层次的技术。Are you ready? 各位开发者们你们准备好了吗？
文章目录 一、HTML的html、head和body三个标签作用是什么？1.1、html标签1.2、head标签1.3、body标签 二、关于html、head和body标签的嵌套关系结语 一、HTML的html、head和body三个标签作用是什么？ HTML的核心组成部分是html、head和body三个标签，它们在构建Web页面时起着不同的作用，接下来让我们深入了解每个标签的功能和用途。
1.1、html标签 html标签是整个HTML文档的根节点，它包含了整个文档的内容。
所有的HTML标签都应该位于html标签的内部。
通过设置lang属性，可以指定页面的语言，例如&lt;html lang="en"&gt;表示页面使用英语。
1.2、head标签 head标签位于html标签内部，用于定义文档的头部部分。
head标签中包含了与文档相关的元数据和引用资源的标签。
header标签主要有如下几种
标签说明meta用于设置文档的字符编码、视口宽度等title定义文档的标题，显示在浏览器的标题栏或标签页上link引入外部样式表（CSS）或其他资源script引入外部JavaScript文件或在文档中嵌入脚本style用于在文档中嵌入CSS样式 1.3、body标签 body标签位于html标签内部，用于定义文档的主体内容。
所有在浏览器中可见的网页内容都应该放置在body标签中。
二、关于html、head和body标签的嵌套关系 在HTML中，head和body标签必须位于html标签内部，但它们的顺序可以是任意的。这意味着head标签可以出现在body标签之前。
如下是一个标准的嵌套关系
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;!-- 用于引用资源等 --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 书写内容 --&gt; 我是归来巨星 &lt;/body&gt; &lt;/html&gt; 所以总的来说html用于包裹head和body
结语 ✨ 每天创作一点点
✨ 开心快乐一整天
✨ 点赞关注加收藏
✨ 美好一天又一天
铁铁们 感谢支持 我需要你们的三连 👍👍👍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac46a39b8a4c8651bc52a4c502dc5421/" rel="bookmark">
			2023Java后端开发面试题尝鲜版，认真看完拿个25K没问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 2023年，将是宣告疫情结束，开启新征程的转折。
在此将整理好的最经典的面试真题1000道，每道题目都有详细的解析，收集了JAVA基础、微服务、JVM，Redis、设计模式，Mybatis、Spring、Spring Boot、Spring IOC、 Spring MVCRabbitMQ、MySQL数据库、Java并发编程，等专题的经典面试真题，和详细解析。（pdf文档，文末可取）
文章目录 Java基础——基础知识Java基础——集合框架/泛型/容器Java基础——多线程Java基础——框架基础：注解/反射/流行框架Java基础——面向对象：继承/多态/封装Java基础——设计模式Java基础——JVM/类加载Java基础——I/O网络编程和计网数据库操作系统数据结构
Java基础—基础知识 一、八种基本数据类型的大小，以及他们的封装类。
byte(Byte) 1 ，short(Short) 2 ,int(Integer) 4 ,long(Long) 8 ,float(Float) 4 ,double(Double)8,boolean(Boolean),char(Character)2
二、Switch能否用string做参数？
switch语句中的变量类型可以使byte，short，int，char。从jdk1.7后可以使用String类型，是通过switch中的String.hashcode将String转换成int进行判断的。
三、equals与==的区别。
==操作符是用来比较两个变量的值是否相等，即就是比较变量在内存中的存储地址是否相同，equals（）方法时String类从Object类中继承的，被用来检测两个对象的内容是否相同。
四、String s=new String(‘xyz’);创建了几个object对象?
会创建一个String类型的变量s。在类加载到此处之前没有出现“xyz”字面量的话，加载此处会创建一个对应“xyz”的String常量对象。在符合规范的JVM上，执行到此处new关键字会创建一个String对象。
五、 Object有哪些公用方法？
1、clone()创建斌返回此对象的副本
2、equals()判断
3、getclass（）返回object的运行类
4、hashcode（）返回对象的哈希码值
5、notify（）唤醒正在等待对象监听器的单个进程
6、notifyAll（）唤醒正在等待对象监听器的所有进程
7、wait（）导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法。
8、toString（）返回此对象的字符串表示形式
9、finalize（）当垃圾收集确定不需要该对象时，垃圾回收器调用该方法
六、Java的四种引用，强弱软虚，用到的场景。
强引用：垃圾回收器不会回收
软引用：如果内存空间足够，垃圾回收器就不会进行回收，如果内存空间不足，垃圾回收器就会进行回收
弱引用：一旦发现了只有弱引用的对象，垃圾回收器就会进行回收。
虚引用：如果发现该对象还具有虚引用，就会在回收该对象之前，吧这个虚引用加入到与之关联的引用队列中。
七、静态变量和实例变量的区别。
静态变量前要加上关键字static，实例变量则不会。
实例变量是属于某个对象的属性，必须创建了实例对象，其中的实例变量才会分配空间，才能使用这个实例变量。静态变量不属于任何的实例对象，而是属于类，也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，就会被分配空间。总之就是，静态变量不需要创建任何的对象就可以直接使用，而实例变量需要先创建实例对象才能被使用。
八、 Overload和Override的区别：
重载Overload表示的是同一个类中可以有多个相同名称的方法，但这些方法的参数列表不同，即就是参数参数或参数类型不同。重载时返回值当然可以不一样，但是如果参数列表完全一致时，不能通过返回类型不一致而实现重载，这是不可以的。
重写Override表示子类中的方法可以与父类中的方法名称和参数完全相同，通过子类创建的对象来调用这个方法时，将调用子类中定义的方法，即就是子类中的该方法将父类的该方法覆盖了。子类覆盖父类方法时只能抛比父类更少或者更小的异常。重写的方法其返回必须和被覆盖的方法返回一致。
九、抽象类和接口的区别。
抽象类可以有默认的方法进行实现，可以有构造器，可以有main方法进行运行，可以直接在该类中添加实现的方法接口没有默认的方法进行实现，没有构造器，不可以使用main方法进行运行，在接口中添加方法时需要在具体实现的类中添加方法。
十、String、StringBuffer与StringBuilder的区别。
String表示内容不可修改的字符串，StringBuffer表示内容可以修改的字符串，String覆盖了equals（）方法和hashcode（）方法，而StringBuffer没有覆盖两个方法，，所以StringBuffer对象存储到java集合类中时会出现问题。
StringBulider也表示内容可以修改的字符串，但是其线程是不安全的，运行效率高。
十一、 Java面向对象的特征与含义。
封装、继承、抽象、多态
1、封装：封装的目的在于实现程序的“高内聚，低耦合”，防止程序相互依赖而带来的变动影响。封装是保证是把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和他操作的数据放在同一个类中。
2、抽象：抽象就是找出事物的相似和共性，然后将这些事物归为同一类，这个类只考虑这些事物的相似和共性，忽略和当前主题不相关的因素。
3、继承：子类继承父类的内容作为自己的内容，可以加入新的内容或者是修改父类的内容而更加适合特殊的需要。提高了额程序的可重用性和可扩张性。
4、多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
十二、java多态的实现
接口实现，继承父类进行方法重写，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac46a39b8a4c8651bc52a4c502dc5421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a324da3e3b98b861e83576f48f8b7a/" rel="bookmark">
			浅谈View的绘制流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Window：每个Activity都会创建一个Window用于承载View视图的显示，Window是一个抽象类存在了一个唯一实现类PhoneWindow
DecorView：最顶层的View，是一个FrameLayout子类，最终会被加载到Window当中，它内部只有一个垂直方向的LinearLayout分为两部分： TitleBar：屏幕顶部的状态栏ContentView：Activity对应的XML布局，通过setContentView设置到DecorView中 Activity和Window关联 ActivityThread调用scheduleLaunchActivity()scheduleLaunchActivity发送消息sendMessage(H.LAUNCH_ACTIVITY, r);handleLaunchActivity初始化WindowMannagerServiceperformLaunchActivity创建Activity执行activity的attachnew PhoneWindow(this,window) + 将window和windowMangerService绑定：同时，此时完成了window和activity的绑定 private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); handleResumeActivity(r.token, false, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); } private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent){ //省略 Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); return activity; } final void handleResumeActivity(IBinder token,boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason){ //省略 View decor = r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5a324da3e3b98b861e83576f48f8b7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c87bccad7402b703fc2f48a7473bb31/" rel="bookmark">
			猴子管理法则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猴子管理法则的要点： 1、只照看自己的“猴子”，不要让下属把应其自己照顾的“猴子”放到我们背上。
让下属把猴子放在我们背上，会导致下属时间上处理等待、可以自由挥霍状态，心理上失去紧迫感及压力；而自己可自由支配时间减少，精力被分散。
2、为了增加自己的“自由支配时间”。
对于如问题类的“猴子”，可以引导下属想解决方案，或次之给出解决方案，但需要其自己去解决，而不是领导帮其解决。
2、上司不仅应明确让下属知道他应该照看好哪些“猴子”，更需要训练下属如何照看好他们的“猴子”。
3、“猴子”管理并不适合所有管理，“猴子管理”会使人变得自私，类似于各人自扫门前雪，会使团队失去活力。
4、正常的团队应该是抢着背负“猴子”，只有愿意主动背负他人“猴子”的下属才有机会成为领导，领导应鼓励，赞赏主动背负他人“猴子”的下属。
5、“猴子”应该面对面或通过电话进行喂养，而不要通过邮件喂养。文档处理会增加喂养程序，其不能取代喂养。
6、应确定每只“猴子”的下次喂养时间，且时间可由双方修改并达成一致，但不能模糊不清。
参考资料： 猴子管理法则
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a2d8dd4a68e8ce0e376eaeafa9993b/" rel="bookmark">
			RESTful 接口设计规范-个人总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RESTful 接口设计规范-个人总结 以下接口规范为个人收集并总结，仅供参考。欢迎提供建议
使用名词，使用HTTP 请求方法 接口中不要出现动词，以及动作。
使用HTTP 请求方法作为动作的表达。常见的CRUD，在HTTP 中都有对应的方法，可参考https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods
HTTP 请求方法 表格来自：https://www.runoob.com/http/http-methods.html
方法描述GET请求指定的页面信息，并返回实体主体。HEAD类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。PUT从客户端向服务器传送的数据取代指定的文档的内容。DELETE请求服务器删除指定的页面。CONNECTHTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS允许客户端查看服务器的性能。TRACE回显服务器收到的请求，主要用于测试或诊断。PATCH是对 PUT 方法的补充，用来对已知资源进行局部更新 。 有以下几种：GET、POST、PUT、DELETE和PATCH。与资源相关联的端点的名称必须与应用的操作相关的HTTP方法对应。
// bad case GET /get_users POST /insert_users PUT /modify_users DELETE /delete_users // good case GET /users POST /users PUT /users DELETE /users 日常开发中不一定能保证完全按照HTTP 请求方法的规范，但至少要保证请求方法使用GET，其他使用POST
全部小写 RFC 3986 将 URI 定义为区分大小写，对于不同环境，大小写 URI 代表不同的路径，为了避免混淆，建议在 URI 中应始终使用小写字母。
// bad case /Users/12345 // good case /users/12345 使用斜杠 / 表示层次关系 斜杠/ 通常用于资源的所属关系，后面的属于前面的。这点类似面相对象语言中的.
例如:/users/{userId}/address/ ，{userId}属于users，address属于{userId}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0a2d8dd4a68e8ce0e376eaeafa9993b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94289864a923497a463a8840cd7c71d6/" rel="bookmark">
			web 端 vite 配置 px 转 rem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web 端 vite 配置 px 转 rem 下载插件 postcss-pxtorem
npm install postcss-pxtorem -D
在 vite.config.ts 中配置
const postCssPxToRem = require("postcss-pxtorem"); export default defineConfig({ css: { postcss: { plugins: [ postCssPxToRem({ // 换算基数， rootValue: 16, //允许REM单位增长到的十进制数字,小数点后保留的位数 unitPrecision: 5, propList: ['*'], //默认false，可以（reg）利用正则表达式排除某些文件夹的方法，例如/(node_module)/ 。如果想把前端UI框架内的px也转换成rem，请把此属性设为默认值 exclude: /(node_module)/, //（布尔值）允许在媒体查询中转换px。 mediaQuery: false, //要忽略并保留为px的选择器，本项目我是用的vant ui框架，所以忽略他 selectorBlackList: ['.van'], //设置要替换的最小像素值 minPixelValue: 1, }), ], }, } }) 根据设计稿编写自适应脚本
/******** src/utils/rem.js ********/ const baseSize = 16; // 设置 rem 函数 function setRem() { // 当前页面宽度相对于 750 宽的缩放比例，可根据自己需要修改。 const scale = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94289864a923497a463a8840cd7c71d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd985fd4c959f8473c616ac5ad666666/" rel="bookmark">
			7、Linux驱动开发：设备-自动创建设备节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 🍅点击这里查看所有博文
随着自己工作的进行，接触到的技术栈也越来越多。给我一个很直观的感受就是，某一项技术/经验在刚开始接触的时候都记得很清楚。往往过了几个月都会忘记的差不多了，只有经常会用到的东西才有可能真正记下来。存在很多在特殊情况下有一点用处的技巧，用的不多的技巧可能一个星期就忘了。
想了很久想通过一些手段把这些事情记录下来。也尝试过在书上记笔记，这也只是一时的，书不在手边的时候那些笔记就和没记一样，不是很方便。
很多时候我们遇到了问题，一般情况下都是选择在搜索引擎检索相关内容，这样来的也更快一点，除非真的找不到才会去选择翻书。后来就想到了写博客，博客作为自己的一个笔记平台倒是挺合适的。随时可以查阅，不用随身携带。
同时由于写博客是对外的，既然是对外的就不能随便写，任何人都可以看到。经验对于我来说那就只是经验而已，公布出来说不一定我的一些经验可以帮助到其他的人。遇到和我相同问题时可以少走一些弯路。
既然决定了要写博客，那就只能认真去写。不管写的好不好，尽力就行。千里之行始于足下，一步一个脚印，慢慢来 ，写的多了慢慢也会变好的。权当是记录自己的成长的一个过程，等到以后再往回看时，就会发现自己以前原来这么菜😂。
本系列博客所述资料均来自互联网资料，并不是本人原创（只有博客是自己写的）。出于热心，本人将自己的所学笔记整理并推出相对应的使用教程，方面其他人学习。为国内的物联网事业发展尽自己的一份绵薄之力，没有为自己谋取私利的想法。若出现侵权现象，请告知本人，本人会立即停止更新，并删除相应的文章和代码。
前言 在前面两小节中，我们学习到了设备注册。可以将一个设备驱动注册到内核中。设备注册完成后，还需要通过mknod指令在用户空间中手动创建该驱动对应的设备节点。
root@ubuntu:# mknod /dev/hello_test0 c 237 0 该命令在执行是不会检查参数的合法性。也不会检查设备驱动是否存在。如果系统中所有的驱动都通过该方法创建设备节点，就会出现一个问题。当设备未接入时，就可能会出现很多的设备节点。
实际上Linux内核为我们提供了一组函数，可以在模块加载的时候自动在/dev目录下创建相应设备节点，并在卸载模块时删除该节点，当然前提条件是用户空间移植了udev。
udev udev是一个工作在用户空间的工具，它能根据系统中硬件设备的状态动态的更新设备文件，包括设备文件的创建，删除，权限等。这些文件通常都定义在/dev 目录下，但也可以在配置文件中指定。
当插入新设备—&gt;加入驱动模块—&gt;在sysfs上注册新的数据后，udev会自动创建新的设备节点。udev运行在用户模式中，而并非内核中。
接口 内核中定义了struct class结构体，顾名思义，一个struct class结构体类型变量对应一个类。代码中出现的class指的是 设备类（device classes），是对于设备的高级抽象。但 实际上class也是一个结构体，只不过class结构体在声明时是按照类的思想来组织其成员的。
/** * struct class - device classes * @name:	Name of the class. * @owner:	The module owner. * @class_attrs: Default attributes of this class. * @dev_groups:	Default attributes of the devices that belong to the class. * @dev_kobj:	The kobject that represents this class and links it into the hierarchy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd985fd4c959f8473c616ac5ad666666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff1f8b19e1e1b0fd47f25fb029f9dfb0/" rel="bookmark">
			STM32cubeMx系列小白学习教程（三）——外部中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先了解一下中断是什么。中断是计算机系统中的一种机制，用于处理和响应来自外部设备或内部事件的请求。当一个设备或事件发送一个中断请求时，CPU会暂时停止当前的任务，转而处理中断请求（记住，是暂停，不是同时），一旦中断处理程序执行完毕，CPU会回到原来的任务继续执行。。中断可以是硬件中断，例如设备的输入/输出请求，或者是软件中断，如操作系统的系统调用。
NVIC NVIC (Nested Vectored Interrupt Controller) 中断控制器，NVIC由三个元素组成，中断使能、中断优先级、中断嵌套。
中断使能，相当于就是是否使用中断，
中断优先级，分为抢占优先级和响应优先级，用来管理中断进行顺序的（例如加减乘除，乘除的优先级更高，需要先计算）。可自由分配，如f103，优先级由4位管理，任意分配，数字越小，优先级越高。
中断嵌套，即当一个中断正在处理时，如果有更高优先级的中断请求发生，NVIC 可以暂时挂起当前中断的处理，转而处理更高优先级的中断。
NVIC 还支持中断嵌套，指在处理一个中断的过程中,如果有更高优先级的中断请求发生,系统可以中断当前正在执行的中断处理过程,转而处理更高优先级的中断。一旦更高优先级的中断处理完毕,中断控制器会恢复之前保存的上下文,继续处理原来的中断。
电路 我们继续按这个电路配置：
配置工程 打开之前的工程Test_F103，在这个工程的基础上继续添加外设。
配置GPIO Pinout&amp;Configuration -&gt; System Core -&gt; GPIO -&gt; PA4 -&gt; GPIO_EXTI4；
配置如下：
GPIO mode -&gt; External Interrupt Mode with Falling...
GPIO Pull-up/Pull-down -&gt; Pull-up
User Label -&gt; KEY_2
各模式介绍：
External Interrupt Mode with Rising edge trigger detection：外部中断上升沿触发检测
External Interrupt Mode with Falling edge trigger detection：外部中断下降沿触发检测
External Interrupt Mode with Rising/Falling edge trigger detection：外部中断上升/下降沿触发检测
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff1f8b19e1e1b0fd47f25fb029f9dfb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a498190acfe6468e4775a2b8a490516a/" rel="bookmark">
			服务器往浏览器推消息（SSE）应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，SSE 和 WebSocket 对比 SSE（服务器发送事件）
SSE是一种基于HTTP的单向通信机制，用于服务器向客户端推送数据。它的工作原理如下：
建立连接：客户端通过发送HTTP请求与服务器建立连接。在请求中，客户端指定了接收事件的终点（Endpoint）。
保持连接：服务器接收到连接请求后，保持连接打开，并定期发送事件数据给客户端。
事件流：服务器使用 “Content-Type: text/event-stream” 头部标识SSE连接，并使用特定格式的数据（事件流）发送给客户端。
客户端处理事件：客户端通过JavaScript的 EventSource 接口监听SSE连接，一旦接收到事件，就可以处理数据并更新页面。
SSE的特点和适用场景：
单向通信：SSE是从服务器到客户端的单向通信模型，只能由服务器推送数据给客户端。
实时更新：SSE适用于需要实时更新数据的应用场景，如股票行情、新闻推送等。
简单易用：使用SSE相对简单，无需额外的库或框架支持，可以直接使用浏览器的原生API进行开发。
WebSocket
WebSocket是一种全双工的通信协议，它通过在客户端和服务器之间建立持久连接，实现双向通信。WebSocket的工作原理如下：
握手阶段：客户端向服务器发送WebSocket握手请求，服务器返回握手响应。在这个阶段，客户端和服务器协商选择协议和版本。
建立连接：握手成功后，客户端和服务器之间建立持久连接，可以进行双向数据传输。
双向通信：一旦连接建立，客户端和服务器都可以主动发送消息给对方。数据可以以文本或二进制格式进行传输。
断开连接：当任一方决定关闭连接时，可以发送关闭帧来终止连接。
WebSocket的特点和适用场景：
双向通信：WebSocket支持双向通信，客户端和服务器可以互相发送消息。
实时互动：WebSocket适用于实时互动的应用场景，如聊天应用、协作编辑等。
复杂性和灵活性：相对于SSE，WebSocket更为灵活，可以处理更复杂的通信需求。它允许自定义消息格式、心跳检测、连接状态管理等。
2，具体代码实现 2.1 后端 @GetMapping(value = "/stock",produces = MediaType.TEXT_EVENT_STREAM_VALUE) public SseEmitter streamStockPrice() { SseEmitter emitter = new SseEmitter(); // 模拟生成实时股票价格并推送给客户端 Random random = new Random(); new Thread(() -&gt; { try { while (true) { // 生成随机的股票价格 double price = 100 + random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a498190acfe6468e4775a2b8a490516a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf38668da7af2dbf1775405a2c9dd9f/" rel="bookmark">
			苦味的人生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实没有什么
少年时的贪玩和懵懂无知
少了这些
回顾过往乏善可陈
两只耳朵
不是听了一堆哲理
就会知道人生应该怎么走
喝多了心灵鸡汤
听惯了苦口婆心
大道理都知道了又能怎样
不如向前迈几步
总要经历一些坎坷
才能对未来多几分期待
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47eb5a330e24512f554a525f4a552d6/" rel="bookmark">
			4D标注——将传统标注推向新高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的不断发展，传统的3D建模和标注已经逐渐无法满足人们对于精度和细节的需求。
在这种背景下，4D标注应运而生，它将传统标注推向了一个新的高度，为各行各业带来了更高效、更精确的解决方案。
什么是4D标注？ 4D标注是指在三维空间基础上，加入时间维度的标注过程。传统的三维标注只能捕捉物体的静态信息，而4D标注则可以记录物体在时间轴上的运动和变化。
具体来说，传统的人工标注方式通常需要大量的时间和人力资源，而且容易出现主观误差。而4D标注可以结合计算机视觉算法，通过自动化和半自动化的方式来实现高效的标注。
例如，利用计算机视觉算法对视频进行目标跟踪，可以自动捕捉物体在时间轴上的位置变化（如记录物体进入和离开画面的时间），并进行相应的标注。这样不仅大大节省了标注的时间和成本，也能够提高标注的准确性和一致性。
BEV＆4D标注 BEV全称为Bird’s Eye View（鸟瞰图），意为像鸟一样从高处俯瞰全局，常用于自动驾驶领域。
在自动驾驶领域，车辆传感器收集的数据通常会被转换为BEV，它能够将复杂的三维环境简化为二维图像、
通过BEV视角观察物体，再在3D空间中对车辆、行人、交通标志等物体进行4D标注，可以准确标注物体的位置、大小、形状以及运动轨迹等信息，更精准地完成物体检测、路径规划等任务。
4D标注社会化应用 4D标注在许多领域都具有较广泛应用，其中最常见的两个方向是自动驾驶与医学研究。
在自动驾驶领域，车辆和行人的运动轨迹分析对于提高安全性至关重要。通过对视频素材进行4D标注，可以精确地记录每个物体的位置、速度和加速度等信息，为自动驾驶算法提供精准的训练数据。
在医学影像分析中，4D标注可以用于疾病的早期诊断和病例研究。比如，通过对肿瘤生长过程的4D标注，医生可以更准确地评估肿瘤的发展速度和侵蚀程度，为治疗方案的制定提供更有效的依据。
尽管4D标注在许多领域中显示出了巨大的潜力，但仍面临一些挑战和限制。
首先，4D标注技术需要大量的人力和时间投入。由于4D标注需要对物体在时间维度上进行跟踪和标记，因此对标注员的要求更高。需要具备专业的技术和判断能力，同时需要对特定领域的知识有一定了解。此外，由于标注过程需要连续的时间序列数据，需要更多的时间和耐心。
其次，在应用4D标注技术时，需要解决大规模数据集的存储和处理问题。对于视频数据来说，数据量较大，传统的存储和处理方式可能会面临挑战。因此，需要开发更高效的数据存储和处理方法，以便更好地支持4D标注技术的应用。
此外，随着4D标注技术的应用范围扩大，对于标注结果的质量和一致性要求也越来越高。需要建立标准化的标注流程和评估标准，确保标注结果的准确性和可靠性。同时，还需要开发自动化的标注工具和算法，以提高标注的效率和精度。
总之，4D标注通过融合时间维度，为数据分析和模型训练提供了更丰富、准确的数据。已在多个领域技术实现落地。然而，要进一步拓宽4D标注应用范围，还需重视上述问题，相信随着技术的不断创新，4D标注将会为更广泛的领域带来变革。
关于曼孚科技 曼孚科技作为一家深耕自动驾驶数据标注领域的数据智能服务商，现已在3D、4D点云数据处理领域，建立起6-12个月的技术壁垒。
旗下自研的MindFlow SEED数据智能平台历经多代版本更新，在业内率先实现了AI数据低成本、无上限、规模化量产。
具体应用场景上，MindFlow SEED平台支持自动驾驶等场景下2D、3D、4D全类别标注，如2/3D融合、点云分割、点云时序叠帧、BEV标注等。
在4D标注方面，曼孚科技自研地图分片与LOD大规模点云渲染技术，4D点云车道线与4D点云分割场景均可实现低配置单帧数亿级点云平稳运行。
凭借从战略到技术落地的一站式数据解决方案，曼孚科技目前已与数百家企业达成深度合作，业务场景涵盖自动驾驶数据标注、AI数据生命周期管理等。用户包括主机厂、造车新势力、一线科技公司、主流算法公司以及世界顶级Tier1厂商等。
未来，曼孚科技将继续加大技术研发投入，不断完善AI基础设施建设，助力用户以更精简方式训练与部署人工智能应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbbc9f664176d10ef4c0cecb527b991b/" rel="bookmark">
			关于CW32单片机pack包安装 KEIL IAR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CW32 系列微控制器软件开发工具入门
芯片包 1. 下载芯片包 官方下载链接：武汉鑫源半导体
2. 安装芯片包 双击芯片包.pack文件
支持 CW32F 系列的 IDE 支持 CW32F 系列的工具链： • • EWARM v7.70 或更高版本 MDK-ARM v5.17 或更高版本 2.1 EWARM 工具链 2.1.1 EWARM V9.30 或更高版本 从 EWARM V9.30 版本开始，IAR 已全面支持芯源半导体的 MCU。通过 EWARM 可以快速的对 CW32 系列 MCU 进行开发。步骤如下： 1. 启动 IAR Embedded Workbench for ARM. 如图 2-1： 图 2-1 MDK-ARM 工具链 （以 CW32F030 系列为例。） 1. 双击固件包“IdeSupport\MDK”目录下的 WHXY.CW32F030_DFP.x.y.z.pack 文件（如图 2-23）, 在弹出 的界面下点击“Next”进行安装 Pack，如图 2-24： 打开 Keil MDK-ARM 微控制器集成开发环境，如图 2-25： 选择工具栏的“Option”按钮，以显示“Option”对话框，选择“Device”标签，在器件列表中选择“WHXY” 目录下的相应器件（以 CW32F030C8 为例），并点击“OK”确定，如图 2-27： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8275709e2be5703c9f2992057d065e84/" rel="bookmark">
			前端HTML要了解的知识，DOCTYPE 声明究竟是做什么的、作用是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟🌟🌟 专栏详解 🎉 🎉 🎉
欢迎来到前端开发之旅专栏！ 不管你是完全小白，还是有一点经验的开发者，在这里你会了解到最简单易懂的语言，与你分享有关前端技术和实用技巧的内容。此专栏的目标是提供易于理解且实用的内容，通过深入浅出的方式让大家掌握前端开发的核心概念和技能。我也相信，通过这个专栏，各位开发者们将更好地理解Web开发的本质，从而掌握更深层次的技术。Are you ready? 各位开发者们你们准备好了吗？
文章目录 一、DOCTYPE究竟是做什么的？二、DOCTYPE的作用2.1、 确定文档类型2.2、 触发浏览器进入相应的文档模式：2.3、验证和错误检测2.3、向开发者和工具提供信息 结语 一、DOCTYPE究竟是做什么的？ 在我们构建一个html文件时，我们常常会发现，一个标准的html并不是只会有html、head、body这三个标签，而是会有很多另外的标签包裹在其中，诸如 &lt;!DOCTYPE html&gt;
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 归来巨星 &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; 写在头部，并且没有结束标签，和我们之前所学习到的单标签，双标签不一致，那么接下来就为大家介绍此标签的作用
DOCTYPE声明是HTML文档的一条特殊指令，它告诉浏览器如何正确解析和显示网页。我们写这个的作用就是让浏览器认识我们这个html页面（当然大家或许会说，那我不写也能呈现出来页面呀？注：因为现在很多浏览器都有着一定各自的标准，但是基本的差异其实是大差不差的，都对html进行了一定的识别所以能呈现出来效果）
首先，DOCTYPE声明的格式是，就像是一种开头的标识。它告诉浏览器，这个网页是用HTML这种语言写的，并且是HTML5这个版本。
在html5之前还有多个版本（有兴趣的同学可以去了解一下）快速跳转
HTML 1.0（1993年）：HTML的最初版本，提供了基本的文本标记和链接功能。
HTML 2.0（1995年）：引入了一些新的标记和功能，例如表格和图像。
HTML 3.2（1997年）：增加了更多的标记和功能，包括框架（Frameset）和表单（Form）。
HTML 4.01（1999年）：对HTML进行了一些修订和标准化，引入了样式表（CSS）和脚本编程（Scripting）等功能。
XHTML 1.0（2000年）：基于XML的HTML版本，强调文档的结构和规范性，更严格地遵循XML的语法规则。
XHTML 1.1（2001年）：对XHTML 1.0进行了一些扩展和修订，增加了一些模块和规范。
HTML5（2014年）：HTML的最新版本，引入了许多新特性和改进，如语义化标签（Semantic Tags）、多媒体支持、Canvas绘图、本地存储等。HTML5也更加灵活，并且提供了更好的跨浏览器兼容性。
二、DOCTYPE的作用 既然我们知道了HTML的DOCTYPE声明的作用是告诉浏览器如何解析和渲染HTML文档。那同样的我们也要知道DOCTYPE声明的具体作用是什么
2.1、 确定文档类型 DOCTYPE声明指定了HTML文档的类型和版本。不同的HTML版本可能具有不同的语法和功能，因此指定正确的DOCTYPE声明可以确保文档被正确解析。
2.2、 触发浏览器进入相应的文档模式： 根据DOCTYPE声明的不同，浏览器会进入不同的文档模式（也称为渲染模式或呈现模式），以确定如何解析和呈现HTML文档。常见的文档模式包括标准模式、怪异模式以及准标准模式。不同的文档模式会影响浏览器对HTML和CSS的解析规则和渲染结果，因此DOCTYPE声明对于确保一致的跨浏览器显示非常重要。
2.3、验证和错误检测 DOCTYPE明可以用于验证HTML文档的正确性。浏览器会根据指定的DOCTYPE声明来检查文档的结构和语法是否符合规范。如果存在错误或不合法的代码，浏览器可能会给出警告或错误信息，帮助开发者及时发现和修复问题。
2.3、向开发者和工具提供信息 DOCTYPE声明还为开发者和相关工具提供了关于文档类型和版本的重要信息。这有助于开发者选择适当的工具和技术来处理和处理HTML文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8275709e2be5703c9f2992057d065e84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa6f645cef05a5ab67d169f1cd3b1959/" rel="bookmark">
			20231018 自然常数的存在性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 除了使用魏尔斯特拉斯定理，还可以使用不定式的洛必达法则来证明这一极限。首先，将 lim ⁡ x → ∞ ( 1 + 1 x ) x \lim _{x \rightarrow \infty}\left(1+\frac{1}{x}\right)^x x→∞lim​(1+x1​)x 写成以下形式：
lim ⁡ x → ∞ ( 1 + 1 x ) x = lim ⁡ x → ∞ e x ln ⁡ ( 1 + 1 x ) \lim _{x \rightarrow \infty}\left(1+\frac{1}{x}\right)^x = \lim _{x \rightarrow \infty} e^{x \ln\left(1+\frac{1}{x}\right)} x→∞lim​(1+x1​)x=x→∞lim​exln(1+x1​)
现在，我们可以使用洛必达法则，对指数函数的极限求导：
lim ⁡ x → ∞ x ln ⁡ ( 1 + 1 x ) = ∞ ∞ \lim _{x \rightarrow \infty}x \ln\left(1+\frac{1}{x}\right) = \frac{\infty}{\infty} x→∞lim​xln(1+x1​)=∞∞​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa6f645cef05a5ab67d169f1cd3b1959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a008645554b8ae4b5c8572111bff13/" rel="bookmark">
			linux磁盘挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文经过多次编辑，存在数据上下文不一致情况，大家理解操作即可，无须在意数据。
下面的所有操作，记得注意权限问题，可切换到root用户
一 、挂载到新目录 查看磁盘 [root@localhost ~]# fdisk -l Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000c81ed Device Boot Start End Blocks Id System /dev/vda1 * 2048 104857566 52427759+ 83 Linux Disk /dev/vdb: 2199.0 GB, 2199023255552 bytes, 4294967296 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes 磁盘/dev/vdb尚有2199GB未分配
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a008645554b8ae4b5c8572111bff13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ecbcecd7966ee71647292f51ae62888/" rel="bookmark">
			怎么让smartgit不自动更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件本身会自动联网检查更新
在C:\Windows\System32\drivers\etc路径下的hosts文件中加入
127.0.0.1 www.syntevo.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa11306d8e953841c37eca768e7e957/" rel="bookmark">
			Nginx一个server中配置多个前端项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置方式一： 配置多少个前端就开启多少个端口定义多少个server
# 配置第一个前端项目 server { listen 80; server_name 127.0.0.1; # 前端项目二 location / { root html/dist; index index.html index.htm; } } # 配置第二个前端项目 server { listen 90; server_name 127.0.0.1; # 前端项目二 location / { root html/dist_cz; index index.html index.htm; } } 配置一访问路径：
访问前端一：
http://127.0.0.1:80
访问前端二：
http://127.0.0.1:90
配置方式二： 一个server中配置多个前端
server { listen 80; server_name 127.0.0.1; # 前端项目一 location / { root html/dist/; index index.html index.htm; } # 前端项目二 location /cz { alias html/dist_cz; # 一个server中配置多个前端项目要使用alias,不要使用root index index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa11306d8e953841c37eca768e7e957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26075e384372657b9e59f007c3f0b121/" rel="bookmark">
			Ubuntu18.04 Teamviewer远程卡通过xorg创建虚拟屏幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用虚拟显示器的软件Xorg，使用如下命令进行安装：
$ sudo apt-get install xserver-xorg-core-hwe-18.04
$ sudo apt-get install xserver-xorg-video-dummy-hwe-18.04 --fix-missing
创建一个配置文件（默认使用虚拟显示器）：
$ sudo gedit /usr/share/X11/xorg.conf.d/xorg.conf
在文件中下入下述内容并保存：
Section "Monitor"
Identifier "Monitor0"
HorizSync 28.0-80.0
VertRefresh 48.0-75.0
# https://arachnoid.com/modelines/
# 1024x768 @ 60.00 Hz (GTF) hsync: 47.70 kHz; pclk: 64.11 MHz
Modeline "1024x768_60.00" 64.11 1024 1080 1184 1344 768 769 772 795 -HSync +Vsync
EndSection
Section "Device"
Identifier "Card0"
Driver "dummy"
VideoRam 256000
EndSection
Section "Screen"
DefaultDepth 24
Identifier "Screen0"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26075e384372657b9e59f007c3f0b121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07decc6c3edc985fb233d4587d2299f/" rel="bookmark">
			Visual Studio 各版本密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Visual Studio 2022 Enterprise（企业版）:VHF9H-NXBBB-638P6-6JHCY-88JWHProfessional（专业版）:TD244-P4NB7-YQ6XK-Y8MMM-YWV2J Visual Studio 2019 Enterprise
BF8Y8-GN2QH-T84XB-QVY3B-RC4DFProfessional
NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y Visual Studio 2017 Enterprise: NJVYC-BMHX2-G77MM-4XJMR-6Q8QF
Professional: KBJFW-NXHK6-W4WJM-CRMQB-G3CDH
Visual Studio 2015: 专业版(Visual Studio Professional 2015 with Update 3)：HMGNV-WCYXV-X7G9W-YCX63-B98R2企业版(Visual Studio Enterprise 2015 with Update 3)：HM6NR-QXX7C-DFW2Y-8B82K-WTYJV Visual Studio 2013 Visual Studio Ultimate 2013 KEY（密钥）：BWG7X-J98B3-W34RT-33B3R-JVYW9Visual Studio Premium 2013 KEY（密钥）：FBJVC-3CMTX-D8DVP-RTQCT-92494Visual Studio Professional 2013 KEY（密钥）： XDM3T-W3T3V-MGJWK-8BFVD-GVPKYTeam Foundation Server 2013 KEY（密钥）：MHG9J-HHHX9-WWPQP-D8T7H-7KCQG Visual Studio 2012 Visual Studio 2012 Ultimate旗舰版序列号：
YKCW6-BPFPF-BT8C9-7DCTH-QXGWC
RBCXF-CVBGR-382MK-DFHJ4-C69G8
YQ7PR-QTHDM-HCBCV-9GKGG-TB2TM
Visual Studio 2010 Visual Studio Ultimate 2010 KEY: YCFHQ9DWCYDKV88T2TMHG7BHP 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e079b3ba0f47ce417a5db66471ccc34a/" rel="bookmark">
			IDEA社区版，真香！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA（IntelliJ IDEA）是众多 Java 开发者的首选。
商业版的昂贵 IDEA 商业版（IntelliJ IDEA Ultimate）功能非常强大，能够满足 Java 开发的所有需求，但其高昂的价格……
此时只能感叹，不是不想用正版，而是正版用不起！
破解版的弊端 除了购买正版，只能选择破解版了。
网上有非常多的破解教程，每个版本都会跟进，只要勤加动手，总是能破解的。
相信这是大多数开发者的选择，本人很长一段时间也是这样做的，但它有以下几个缺点：
BUG 频发。
由于是破解版，总会有一些莫名其妙的 BUG。
不能升级版本。
如果升级版本需要重新破解，比较麻烦，且成功的可能性未知。
不能稳定使用。
由于是破解版，随时可能遭遇官方的封杀，这样就不能用了，只能寻求其他破解之法。
所以，破解版虽然能够白嫖，但白嫖的代价可不低，特别是在工作场景中，工具的不稳定是会影响工作效率的，甚至是工作的心情。
社区版的真香 在经历了破解版的种种弊端后，我决定尝试下社区版。
之前白嫖商业版习惯了，从来没有关注过社区版，这次尝试之后，只能感叹，真香！
优点 社区版有两大显而易见的优点：
免费。
相较于商业版高昂的价格，社区版的免费无疑是最大的优点。
正版。
社区版由于是免费的，可以直接使用正版，省去了破解的麻烦，也规避了破解的所有缺点。
缺点 当然了，社区版的缺点也是有的：
功能较少。
社区版只提供了最基本的 Java 开发相关功能，商业版中的 Web 开发、数据库管理、特色功能都是没有的。
个人觉得这不是问题，因为 Web 开发、数据库管理都是有专业免费的工具可以实现的，那些特色功能在 Java 开发中也不是必需的。
性能较弱。
社区版的维护是没有商业版频繁的，所以性能和响应速度这些肯定无法与商业版相比。
在一段时间的使用下来，这点性能和响应速度的减弱是完全可以接受的，而且性能较弱也意味着占用的内存较少，对于 IDEA 这个”内存大户”甚至可以归为优点。
使用 在了解了社区版的优缺点后，就该介绍社区版的使用了。
首先声明，社区版的使用逻辑与商业版没有任何区别。
所以，对于熟悉商业版的开发者来说，社区版是没有学习成本的。
功能 这里只介绍社区版相较于商业版不能直接使用的功能。
社区版自带的功能与商业版一致，就不赘述了。
Lombok 与商业版不同，社区版是没有默认安装 Lombok 插件的，所以不能直接使用 Lombok 的功能，需要先安装插件：
安装插件后，Lombok 的功能与商业版一致，这里就不详细介绍了。
Docker 与商业版不同，社区版是没有默认安装 Docker 插件的，所以不能直接使用 Docker 的功能，需要先安装插件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e079b3ba0f47ce417a5db66471ccc34a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c81afd500ae070032ec70f9634bc959/" rel="bookmark">
			Python真的这么好吗？为什么大家都首选Python？全方面解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、Python的易用性二、Python在数据科学领域的应用三、Python在Web开发中的应用四、Python在人工智能领域的应用五、Python社区的活跃性和开放性六、Python在教育领域的应用总结在这里插入图片描述关于Python技术储备一、Python所有方向的学习路线二、Python基础学习视频这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【`保证100%免费`】 前言 Python是一种高级编程语言，近年来因其简单易学、功能强大和广泛应用而备受欢迎。在本文中，我将深入探讨Python为什么如此火爆的原因，并从多个角度解释其成功之处。
一、Python的易用性 Python语法简单易懂，类似于英语，因此初学者可以快速上手。相较于其他编程语言，Python语法的简洁性为开发者节省了时间和精力，使得编写代码更加轻松、愉悦。
Python拥有大量的库和工具，可以方便地进行各种操作，例如图像处理、网络爬虫、Web开发、数据科学等等。Python还支持交互式编程，因此开发者可以在命令行窗口中进行代码测试和调试。此外，Python有丰富的文档和社区支持，使得开发者可以很容易地找到解决问题的方法和答案。
Python还具有跨平台的特性，可以在不同操作系统和硬件平台上运行。这意味着开发者可以使用同一份代码在多个平台上进行开发和部署。
二、Python在数据科学领域的应用 Python是数据科学家的首选语言之一。Python拥有许多优秀的第三方库和工具，例如NumPy、Pandas、Matplotlib和Scikit-Learn等，这些库和工具可以轻松地进行数据处理、可视化和机器学习等操作。此外，Python还有一些流行的数据科学框架，例如TensorFlow和PyTorch等，这些框架可以用于深度学习、自然语言处理等领域。
在数据科学领域，Python被广泛应用于数据清洗、可视化、探索性数据分析、模型构建和模型部署等任务。Python的简单易用性、强大的数据处理能力和大量的数据科学库和工具使得Python成为了数据科学家们的不二之选。
三、Python在Web开发中的应用 Python可以用于Web开发，而且非常流行。Python的Web开发框架有很多，其中最流行的是Django和Flask。这些框架提供了丰富的功能和工具，例如ORM（对象关系映射）、模板引擎、表单处理和安全措施等。Python的Web开发框架使得Web开发变得更加快速、高效和可维护。
四、Python在人工智能领域的应用 Python在人工智能领域中也得到了广泛应用。Python的第三方库和工具可以用于
机器学习、自然语言处理、计算机视觉和强化学习等领域。在机器学习方面，Python的库和工具非常丰富，例如Scikit-Learn、Keras、PyTorch和TensorFlow等。这些库和工具提供了丰富的算法和工具，可以轻松地进行机器学习任务。
在自然语言处理领域，Python也是最受欢迎的语言之一。Python的库和工具可以用于文本处理、文本分类、情感分析、语音识别等任务。在计算机视觉领域，Python的库和工具可以用于图像处理、目标检测、人脸识别和图像分类等任务。在强化学习领域，Python的库和工具可以用于构建强化学习算法和实现机器人控制等任务。
五、Python社区的活跃性和开放性 Python社区非常活跃和开放，有大量的开源项目和库。Python社区的开放性和活跃性使得开发者可以轻松地分享代码和知识，并且可以很容易地得到其他开发者的帮助和支持。Python社区还提供了很多教程、文档和示例代码，使得开发者可以很容易地学习和使用Python。
六、Python在教育领域的应用 Python的简单易用性和广泛的应用使得Python在教育领域得到了广泛的应用。许多高校和中小学都将Python作为计算机编程教学的主要语言。Python的简单易学性和实用性使得学生们可以快速掌握编程知识，并且可以很快地应用到实际项目中去。
总结 综上所述，Python之所以如此火爆，是因为其简单易学、功能强大和广泛应用。Python在数据科学、Web开发、人工智能等领域中得到了广泛应用，并且有丰富的库和工具来支持这些应用。Python社区的活跃性和开放性使得开发者可以轻松地分享代码和知识，并且可以很容易地得到其他开发者的帮助和支持。此外，Python在教育领域也得到了广泛应用，使得更多的人可以学习和使用Python。总之，Python是一门值得学习和使用的编程语言，将会在未来继续保持其火爆程度。
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
👉CSDN大礼包：《Python入门资料&amp;实战源码&amp;安装工具】免费领取（安全链接，放心点击）
一、Python所有方向的学习路线 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python基础学习视频 ② 路线对应学习视频
还有很多适合0基础入门的学习视频，有了这些视频，轻轻松松上手Python~在这里插入图片描述
③练习题
每节视频课后，都有对应的练习题哦，可以检验学习成果哈哈！
因篇幅有限，仅展示部分资料
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74056e40f4212b8a2b87126423d1c189/" rel="bookmark">
			TED-别不信，你只需20小时，就能学会任何事情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Now,what’s interesting to note is that,for skills that we want to learn for ourselves,we don’t care so much about time,right?We just care about how good we are,whatever good happend to mean.So if we relabel performance time to how good you are,the graph flips,and you get his famous and widely known, this is the learning curve.
And the story of the learning curve is when you start,you’re grossly(非常) incompetent and you know it ,right?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74056e40f4212b8a2b87126423d1c189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df404d77d1ec131e4c0e9cafcc51495/" rel="bookmark">
			谈离散对数问题难解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、对数问题
二、离散对数问题
写在前面：
关于解离散对数问题的困难性，本文是笔者自己的一些思考，有误解之处还请不吝赐教。
一、对数问题 对于函数，如果我们已知底数a和函数值b，那么我们很容易就可以通过计算出对应x的值，且x值是唯一的，与b值是一一对应的关系。需要注意的是，图像本身是一个连续的函数图像，数值的变化具有规律性，因此我们已知a和b便很容易得到x。
二、离散对数问题 对于离散问题，若，上面的方法便不再适用，即使我们已知a和b，我们也很难确定唯一的一个x值，因为存在不止一个这样的x0使成立。这些x都是离散分布的。
因此离散对数问题难解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80c3cd042f9f99445c9e07c3e4abb8c/" rel="bookmark">
			解决telnet不是内部或外部以及验证某个端口是否开放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.怎么解决telnet不是内部或外部命令 （1）telnet在win10下默认是不开启的，所以需要我们自己手动开启。
（2）在控制面板中，我们选择程序–启动或关闭windows功能，然后勾选Telnet客户端选项，确定进行安装。
（3）勾选【Telnet客户端】
2.测试端口是否开放 （1）如下图所示，8383端口没有开放
（2）如下图所示，9800端口开放
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/142f4904f8113127b7edb8c6aa96647a/" rel="bookmark">
			pycharm中对于包的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在PyCharm中，可以使用以下快捷键来整理包：
自动导入包：如果在代码中使用了未导入的包，可以使用快捷键Alt + Enter来自动导入缺失的包。
优化导入：可以使用Ctrl + Alt + O快捷键来优化导入语句，去除多余的导入，按照字母顺序排列导入语句。
排列包：可以使用Ctrl + Alt + L快捷键来对代码进行格式化和排列，包括包的导入语句。
折叠包：可以使用Ctrl + -和Ctrl + +快捷键来折叠和展开包的结构。
查看包结构：可以使用Ctrl + F12快捷键来查看当前文件的包结构，可以方便地导航到其他包和文件。
这些是PyCharm中用于整理包的一些常用快捷键，可以根据个人习惯进行调整和自定义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283b6e2b878156abf3d7a6186acb9ddd/" rel="bookmark">
			ubuntu20.04 nerf开山之作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码
GitHub - yenchenlin/nerf-pytorch: A PyTorch implementation of NeRF (Neural Radiance Fields) that reproduces the results.
代码的相关解读
NeRF代码解读-相机参数与坐标系变换 - 知乎
原文题目：NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis
git：
git clone https://github.com/yenchenlin/nerf-pytorch.git2 cd nerf-pytorch 环境配置(建议先跳到下面miniconda，不用conda的直接去github)
#########################################################################
在终端输入
pip install -r requirements.txt
（注意这个requirements.txt最好是用tab补全，我直接复制执行会报错）
pip的时候会经常timeout
可参考
Python下载库超时Connection to files.pythonhosted.org timed out问题解决（换源）-CSDN博客
总结就是
pip命令+ -i +镜像地址。（可独立安装requirements.txt各自的库）例如 pip install numpy -i https://mirrors.aliyun.com/pypi/simple/
正常用阿里云就可以，有条件的可以挂tizi
正常后面会有cuda版本和gpu显卡的问题
这里提前处理
首先点开自己的软件与更新，选择附加驱动里自己适合的nvidia驱动，我的535或者525都可以，那我就装低版本的525。因为后面cuda的版本是跟这个相对应，我选择535后要选择cuda12.2,但是pytorch现在才到cuda12.1。导致我们没法成功安装pytorch。所以只能525+cuda12.0+pytorch(支持的cuda12.1)
先安装好nvidia驱动，然后在终端输入
nvidia-smi
查看对应的cuda版本
然后在官网(下cuda)
CUDA Toolkit Archive | NVIDIA Developer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283b6e2b878156abf3d7a6186acb9ddd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c723c66a2d7e1d7abf0fe6662a11d141/" rel="bookmark">
			苹果笔记本磁盘工具怎样分区 苹果电脑系统u盘读不出来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苹果笔记本拥有优秀的性能和设计，给用户带来了良好的使用体验。但是，苹果笔记本也会遇到一些问题，比如磁盘空间不足、u盘无法识别等。这些问题可能会影响到我们的工作和生活，所以我们需要及时解决它们。本文将介绍苹果笔记本磁盘工具怎样分区和苹果电脑系统u盘读不出来的原因和解决方法。
一、苹果笔记本磁盘工具怎样分区
磁盘分区是指将一个物理磁盘划分为多个逻辑磁盘，每个逻辑磁盘可以有自己的文件系统和容量。磁盘分区有很多好处，例如：可以提高磁盘的利用率和管理效率，可以隔离不同类型的数据，可以提高系统的安全性和稳定性等。
图1：磁盘分区
苹果笔记本自带了一个磁盘工具软件，可以方便地对磁盘进行分区。以下是使用磁盘工具进行分区的步骤：
1、打开磁盘工具，选择要分区的磁盘，点击“分区”按钮。
图2：分区
2、在弹出的窗口中，可以看到当前磁盘的分区情况，点击“+”号可以添加新的分区，点击“-”号可以删除已有的分区。
图3：调整分区
3、调整每个分区的大小和名称，选择每个分区的格式（建议使用Mac OS扩展（日志式）格式），点击“应用”按钮。
图4：设置格式
4、等待磁盘工具完成分区操作，可能需要一段时间，请耐心等待。
5、完成后，可以在桌面或者访达中看到新建的分区。
注意事项：
1、在进行分区之前，请备份好重要的数据，以防止数据丢失或损坏。
2、在进行分区之前，请确保电源充足或接通电源，以防止电池耗尽导致分区失败。
3、在进行分区之后，请不要随意修改或删除分区，否则可能会导致系统无法启动或数据丢失。
二、苹果电脑系统u盘读不出来
我们经常会用u盘来备份重要的文件或者安装系统等。但是，有时候我们会发现苹果电脑系统无法识别或者读取u盘，这可能会给我们带来很多麻烦。那么，苹果电脑系统u盘读不出来的原因和解决方法是什么呢？
苹果电脑系统u盘读不出来可能有以下几种原因：
1、u盘本身有问题。
比如u盘损坏、老化、接触不良等。
2、u盘格式不兼容。
比如u盘使用了Windows专用的NTFS格式。
3、u盘驱动缺失或者冲突。
比如u盘需要特定的驱动程序才能正常工作，但是Mac OS没有安装或者安装了错误的驱动程序等。
4、u盘权限设置错误。
比如u盘被设置为只读或者隐藏等。
针对以上原因，我们可以尝试以下方法来解决苹果电脑系统u盘读不出来的问题：
1、检查u盘本身是否有问题。
检查u盘是否有损坏、老化、灰尘，u盘是否插入正确和牢固等。如果有问题，可以更换一个新的或者干净的u盘。
图5：U盘
2、检查u盘格式是否兼容。
检查u盘是否使用了Mac OS支持的格式，如FAT32、exFAT等。如果不兼容，可以使用磁盘工具或者其他软件来格式化u盘为兼容的格式。如果你想使用NTFS格式的u盘，你可以使用一款叫做Tuxera NTFS for mac的软件，它可以让你在Mac OS上读写NTFS格式的u盘。你可以在Tuxera 。安装后，你就可以像使用其他格式的u盘一样使用NTFS格式的u盘了。
Tuxera NTFS for Mac 2022下载：https://souurl.cn/fIerPb
Tuxera Ntfs For Mac 2023下载：https://souurl.cn/GaQ2qJ
图6：免费下载
3、检查u盘驱动是否缺失或者冲突。
检查u盘是否需要特定的驱动程序才能正常工作，Mac OS是否安装了正确的驱动程序。如果有问题，可以尝试更新或者卸载重装驱动程序。
4、检查u盘权限是否设置正确。
检查u盘是否被设置为只读或者隐藏，这可能会导致u盘无法被识别或者访问。如果有问题，可以使用磁盘工具或者其他软件来修改u盘的权限设置。
图7：U盘权限
三、总结
本文介绍了苹果笔记本磁盘工具怎样分区和苹果电脑系统u盘读不出来的原因和解决方法。希望这些信息能够对你有所帮助，让你能够更好地使用苹果笔记本和u盘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8176660005ec4afa56378374cbbe1877/" rel="bookmark">
			Python使用openpyxl操作excel文件：某一列为数学公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for row in range(2, worksheet.max_row + 1): cell = worksheet[column + str(row)] value = cell.value 这个value是：
=AW2/AX2
=AW2/AX2
=AW3/AX3
…
怎么把这个公式计算出来读取，而不是读取公式？
解决方法：
想要获取公式计算后的结果而不仅仅是公式本身，可以使用openpyxl库中的data_only参数来加载Excel文件。该参数将强制Excel加载已经计算过的值，而不是公式。
# 打开Excel文件，并加载已经计算过的值 workbook = openpyxl.load_workbook('input.xlsx', data_only=True) 这样，当我们读取单元格的值时，将会获取到公式计算后的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45aa91d5adb057891166d235948d8e38/" rel="bookmark">
			Spring事件ApplicationEvent源码浅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 demo应用实现基于注解事件过滤异步事件监听 源码解读总结 ApplicationContext 中的事件处理是通过 ApplicationEvent 类和 ApplicationListener 接口提供的。如果将实现了 ApplicationListener 接口的 bean 部署到容器中，则每次将 ApplicationEvent 发布到ApplicationContext 时，都会通知到该 bean，这简直是典型的观察者模式。设计的初衷就是为了系统业务逻辑之间的解耦，提高可扩展性以及可维护性。
Spring 中提供了以下的事件
Event描述ContextRefreshedEventApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生ContextStartedEvent当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序ContextStoppedEvent当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作ContextClosedEvent使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启RequestHandledEvent这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务ServletRequestHandledEventRequestHandledEvent的一个子类，用于添加特定于Servlet的上下文信息。 demo应用 具体的详情可以访问：https://cuizb.top/myblog/static/resource/Untitled-1697189238408.png
这里只是个demo例子
实现 1、 自定义事件类，基于ApplicationEvent实现扩展；
public class DemoEvent extends ApplicationEvent { private static final long serialVersionUID = -2753705718295396328L; private String msg; public DemoEvent(Object source, String msg) { super(source); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45aa91d5adb057891166d235948d8e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7616069a53b149b1174d9728613bc798/" rel="bookmark">
			属于Java的docker - centos7配置docker TCP的端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在服务器上使用命令 cat /etc/redhat-release 查看服务器版本 简易安装docker
yum 原始安装docker
yum list installed | grep docker yum -y install docker docker ps systemctl start docker sudo curl -L https://github.com/docker/compose/releases/download/1.28.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose version 修改docker 配置文件已开启端口
vi /usr/lib/systemd/system/docker.service 查找到ExecStart= 位置,修改参数:
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:1457 -H unix:///var/run/docker.sock 注: 文章采用1457端口
此次原文件内容:
[Unit] Description=Docker Application Container Engine Documentation=http://docs.docker.com After=network.target Wants=docker-storage-setup.service Requires=docker-cleanup.timer [Service] Type=notify NotifyAccess=main EnvironmentFile=-/run/containers/registries.conf EnvironmentFile=-/etc/sysconfig/docker EnvironmentFile=-/etc/sysconfig/docker-storage EnvironmentFile=-/etc/sysconfig/docker-network Environment=GOTRACEBACK=crash Environment=DOCKER_HTTP_HOST_COMPAT=1 Environment=PATH=/usr/libexec/docker:/usr/bin:/usr/sbin ExecStart=/usr/bin/dockerd-current \ --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \ --default-runtime=docker-runc \ --exec-opt native.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7616069a53b149b1174d9728613bc798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357284fe34f26b71b77b71fcd96199ca/" rel="bookmark">
			雪花算法生成ID传到前端之后精度丢失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：使用注解解决 使用方便简单，粒度高，适用于部分字段需要单独转换的场景，灵活度高
// 两种注解，选其一即可 // @JsonFormat(shape = JsonFormat.Shape.STRING) @JsonSerialize(using = ToStringSerializer.class) private Long largeId = 1332345432341123411L; 第二种：直接对SimpleModule对象配置，避免其他地方的Jackson配置被覆盖的问题 @Configuration public class JsonModuleConfig extends SimpleModule { public JsonModuleConfig() { //super(JsonModuleConfig.class.getName()); this.addSerializer(Long.class, ToStringSerializer.instance); this.addSerializer(Long.TYPE, ToStringSerializer.instance); } } 第三种：通过 WebMvcConfigurer 配置转换规则 会根据扫描到的配置类顺序加载，如果匹配到第一个，则放弃后续的配置，所以自己的框架如果有配置Jackson配置的话，使用这个方法会导致原有配置被覆盖
注意：如果项目使用了的是自己的框架，这里的配置可能会引起自己框架配置的jackson失效
@EnableWebMvc @Configuration public class WebDataConvertConfig implements WebMvcConfigurer { public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); ObjectMapper objectMapper = new ObjectMapper(); /** * 序列换成json时,将所有的long变成string * 因为js中得数字类型不能包含所有的java long值 */ SimpleModule simpleModule = new SimpleModule(); simpleModule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/357284fe34f26b71b77b71fcd96199ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a068cf39873b4305db3b266d787a68/" rel="bookmark">
			滚动条样式优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌、Edge
// 设置滚动条的样式 ::-webkit-scrollbar { width: 30px; height: 30px; background-color: rgba(red, .3); } // 滚动条两端按钮 ::-webkit-scrollbar-button { background: green; border: 3px solid blue; } ::-webkit-scrollbar-button:active { background: blue; border: 3px solid green; } ::-webkit-scrollbar:hover { background-color: #eee; } // 滚动槽外层轨道 ::-webkit-scrollbar-track { width: 5px; height: 5px; border-radius: 10px; -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3); background-color: rgba(green, .1); } // 内层滚动槽 ::-webkit-scrollbar-track-piece { background-color: rgba(skyblue, .3); } // 滚动条滑块 ::-webkit-scrollbar-thumb { border-radius: 15px; -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a068cf39873b4305db3b266d787a68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b078e4e01c82054b8363aadd79f768b/" rel="bookmark">
			LeetCode——动态规划篇（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷题顺序及思路来源于代码随想录，网站地址：https://programmercarl.com 目录
300. 最长递增子序列 - 力扣（LeetCode）
674. 最长连续递增序列 - 力扣（LeetCode）
718. 最长重复子数组 - 力扣（LeetCode）
1143. 最长公共子序列 - 力扣（LeetCode）
1035. 不相交的线 - 力扣（LeetCode）
300. 最长递增子序列 - 力扣（LeetCode） 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 import java.util.Arrays; /** * @author light * @Description 最长递增子序列 * * * （思路：数组中只要有递增的就行，无需连续 * 动态规划--弄明白dp数组所表示的含义 * dp[i]:nums[i]之前（包括nums[i])的字序列最大递增子序列长度为dp[i] * @create 2023-10-15 9:50 */ public class LengthOfLISTest { public static void main(String[] args) { int[] nums={0,1,0,3,2}; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b078e4e01c82054b8363aadd79f768b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/51/">«</a>
	<span class="pagination__item pagination__item--current">52/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/53/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>