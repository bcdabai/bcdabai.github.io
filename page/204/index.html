<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905c694442bfebbcbe97c1a509eaeaa1/" rel="bookmark">
			根据月份判断春夏秋冬
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一年有12个月，分属于春夏秋冬4个季节，键盘录入一个月份，请用程序实现判断该月份属于哪个季节，并输出。
package com.JavaClass; /* * 春夏秋冬 * 需求： * 一年有12个月，分属于春夏秋冬4个季节，键盘录入一个月份，请用程序实现判断该月份属于哪个季节，并输出。 * 春：3、4、5 * 夏：6、7、8 * 秋：9、10、11 * 冬：1、2、12 */ import java.util.Scanner; public class Season { public static void main(String[] args){ // 键盘录入月份数据，使用变量接收 Scanner sc = new Scanner(System.in); while (true) { System.out.println("请输入月份数据（q退出）："); int month = sc.nextInt(); // 多情况判断，使用switch语句 switch (month) { case 3: case 4: case 5: System.out.println("春季"); break; case 6: case 7: case 8: System.out.println("夏季"); break; case 9: case 10: case 11: System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/905c694442bfebbcbe97c1a509eaeaa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb0cbb84668205eca804ca19a1e0048/" rel="bookmark">
			第四章 servlet技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Servlet概述 1.什么是servlet: 狭义的servlet是一个接口，广义是指任何实现了这个servlet接口的类。
2:servlet的作用： servlet专门用来接收客户端的请求，专门接收客户端的请求数据，然后调用底层service处理数据并生成结果
浏览器http请求------》tomcat服务器-------》到达servlet-----》执行doget，dopost方法----》返回数据
客户端发送请求到服务器端
服务器将请求信息发送至Servlet
Servlet生成响应内容并将其传给服务器。
服务器将响应返回给客户端。
3.servlet里的三大作用域： request(请求)：它的作用范围是一次请求和响应，是三个作用域中最小的。
session（会话）：它的作用比request要大一点，一次会话过程中，它的作用域就一直存在，(默认是30分钟)
servletcontext：它作用范围最大，作用于整个服务器中。（Application）
3.2.Servlet的生命周期 Servlet的生命周期的四个阶段分别为：加载阶段、初始化阶段、请求处理以及销毁阶段
3.3.servlet细节 1.Servlet提供的两种跳转方式：
request对象提供的：请求转发Forward
response对象提供的：重定向Redirect
2.如何解决Servlet线程安全？
使用同步代码块synchronize(this){}
让Servlet实现SingleThreadModle接口不再是单例模式每个请求都会创建一个Servlet实例浪费服务器资源已经过时，不建议使用
尽量不要在Servlet实例内使用共享变量
学习心得： 明白了servlet专门用来接收客户端的请求，专门接收客户端的请求数据，servlet分为四个阶段。
我个人觉得学习servlet有几点需要注意，我觉得
把这几点弄明白了，那么参看api就可以动手编程了(当然前提是需要把HTTP协议弄清楚
了)。
几点需要注意的点： 1、一定明白servlet就像插件一样，是被web服务器（具体来说是里面的servlet引擎）调用的。
2、servlet引擎再调用一个相应的servlet对象的service（）方法时，会同时创建两个
对象，一个是HttpServletResponse，一个是HttpServletRequest。
3、对于servlet与jsp或者数据库中的中文乱码问题：编码集涉及到iso8859-1,utf8，gb2312，unicode。注意中文字符在utf8，gb2312，unicode中都是存在的。iso8859-1中是不存在的。其中注意，因为java中采用的是unicode的编码，所以应用程序中，unicode就相当于枢纽一样，很多编码都是先解码到unicode，再从unicode编码到其他一些具体字符。
像gb2312—&gt;unicode—&gt;gb2312,utf8—&gt;unicode—&gt;utf8,
gb2312—&gt;unicode—&gt;uft8,uf8----&gt;unicode—&gt;gb2312等，都是可以进行转换的。
第四章思维导图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27046009546b7d564ab0585d61f3f77d/" rel="bookmark">
			FPGA时序约束之时钟约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://cloud.tencent.com/developer/article/1533419
此外可以参考：https://blog.csdn.net/huan09900990/article/details/77163970
https://blog.csdn.net/u012176730/article/details/54412323
毋庸置疑，create_clock是最基本、最简单的时序约束命令，而且在FPGA设计中必然会用到。但看似简单的命令，却也常常被用错。这里我们就来回答一些常见的问题。
问题1：什么样的时钟需要用create_clock约束？
有三类时钟时钟需要用create_clock进行约束，分别是：
从全局时钟管脚进来的主时钟（Primary Clock）
7系列FPGA高速收发器输出时钟（RXOUTCLK/TXOUTCLK）
用于接口约束的虚拟时钟（Virtual Clock）
问题2：什么是虚拟时钟（VirtualClock）？
虚拟时钟，顾名思义，在实际设计中并不存在的时钟，主要用于输入、输出接口的约束。这里给出一个虚拟时钟案例，如下图所示。
问题3：如何约束高速收发器的输出时钟？
这里要分两种情况进行讨论。对于7系列FPGA，需要约束GT的RXOUTCLK和TXOUTCLK，具体约束如下图所示。事实上，只有在这种情形下create_clock命令才会和get_pins命令结合使用（通常是和get_ports一起使用）。
对于UltraScale系列FPGA，只用约束参考时钟即可。Vivado会自动推断GT的生成时钟约束。
问题4：如何约束差分时钟？
对于差分时钟，一定会用到IBUFGDS，只用约束P端。工具会据此自动将此约束传播到IBUFGDS的输出端口。如果既约束P端又约束N端，工具会认为这是两个独立的时钟，进而分析相应的内部路径，最终导致错误的时序需求（Requirement）。
问题5：create_clock的时钟定义在BUFG的输出端会有什么影响？
在Vivado中，这两条约束是不同的，因为它们定义了不同的零时刻起点。这个零时刻起点是用来计算Clock Latency和Uncertainty的，而这两个值又是用来计算Slack的。换言之，零时刻起点直接影响了Slack的计算。通常，Vivado会忽略零时刻起点上游所有时钟树的延迟。如果在BUFG的输出端定义主时钟，那就意味着只有部分Latency会被使用。如果该时钟与其他时钟有交互，那么它们之间的Clock Skew将不再准确，最终影响Slack的准确度。
结论：
对于从全局时钟管脚进来的时钟，create_clock会和get_ports结合使用；
对于7系列高速收发器的输出时钟，create_clock会和get_pins结合使用；
对于虚拟时钟，create_clock会单独使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025ea526435c203f3bf38511ef4d0f0f/" rel="bookmark">
			使用scanf向c语言的结构体数组输入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # include &lt;stdio.h&gt; struct STU { char name[10]; int age; char sex; char num[20]; }; int main() { struct STU stu[3]; scanf ("%s%d %c%s", stu[0].name, &amp;stu[0].age, &amp;stu[0].sex, stu[0].num);/*%c前面要加空格, 不然输入时会将空格赋给%c*/ printf("学生姓名：%s 学生年龄：%d 学生性别：%c 学生学号：%s\n", stu[0].name, stu[0].age, stu[0].sex, stu[0].num); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63529833a20c27316d618d73b9bd8272/" rel="bookmark">
			android课程表网络爬虫,又到了每年此刻，教你把课程表导入日历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天学校公布了我们下学期的课程表。唉，没想到大三的课程表居然比大二还多！好吧，我也只能乖乖地把课程表整理下，一起导入到日历里。
其实 App Store 里课程表的应用并不少，各个学校也可能有自己的教务系统爬下来做出来的课程助手，所以管理课程这件事并不是难事。但是谁叫我生来(才怪)就是不喜欢这样一些乱七八糟功能堆积的 App，反而享受做出符合自己需求的玩意儿。所以别企图用 XX 课程助手这样的应用来搞定我。
将课程表导入到日历管理的好处十分明显：
统一管理。将课程和其他安排统一管理，方便安排和查看
节省空间。在 Widget 里只需要留一个日历插件，就能一目了然
足够装X。嗯……是的。
于是我写了一个将课程导入日历的 Python 脚本，这个脚本是我一年前写的，一直想分享但是一直找不到点拿出来分享，今天心情好(才怪)，觉得是时候分享了～下面是使用说明。
脚本概要
程序总共由两个脚本完成，最后将 ICS 导入日历即可。步骤概要：
1、使用 excelReader.py 将保存的 classInfo Excel 表格导出容易解析的 conf_classInfo.json
2、使用 main.py 将配置好的 conf_classTime.json 和生成的 conf_classInfo.json 生成一个 class.ics
3、将 class.ics 导入手机或者电脑
4、搞定！
环境要求
Python 2.7+
执行详解
1、配置 classInfo Excel 表格
在工作目录下创建一个 classInfo Excel 表格，表格表头有如下参数：
className：课程名称
startWeek：起始周
endWeek：结束周
weekday：星期
classTime：第几节。这个参数要配合 conf_classTime.json 文件，下文会讲。
classroom：教室
2、配置 conf_classTime.json
来吧，照猫画虎：
{
"classTime": [
{
"name":"第 1、2 节"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63529833a20c27316d618d73b9bd8272/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970090134b1e954b990ac4612d6d94e4/" rel="bookmark">
			解决YAMLException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xorg.yaml.snakeyaml.error.YAMLException: java.nio.charset.MalformedInputException: Input
现象：项目能在我笔记本电脑上运行，但在台式的时候出现一些莫名奇妙的问题，这个就是其中之一。
org.yaml.snakeyaml.error.YAMLException: java.nio.charset.MalformedInputException: Input length
解决方案：
修改编码格式
将其改成UTF-8
复制yml里面的代码，删除yml再创个新的yml配置文件，将代码复制进去。问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d563190376711bb49148ec29d1a0129c/" rel="bookmark">
			Java面向对象（3） —— 抽象类、接口、内部类、匿名内部类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 抽象类（abstract）抽象类的使用方法抽象类的应用：模板方法模式 接口接口的概念接口的特点接口的使用接口实现与抽象类继承的区别接口的多继承 内部类概念成员内部类（使用较多）及应用创建成员内部类的实例在成员内部类中访问外部类的成员方法和属性外部类不能直接访问内部类的成员，必须先建立内部类的对象才能访问 成员内部类有以下限制 匿名内部类概念匿名内部类的创建与访问 抽象类（abstract） java中可以定义没有方法体（只有方法头）的方法，该方法由子类来具体实现。该没有方法体的方法我们称之为抽象方法，含有抽象方法的类我们称之为抽象类。
有抽象方法的类，一定是抽象类。即抽象方法只能放在抽象类中。
但是抽象类中可以有具体方法，可以没有抽象方法。
特点：
（1）抽象方法不能被调用
抽象方法代表一种不确定的操作或行为
（2）抽象类不能被实例化
虽然按照提示也能完成方法体实例化，但这是不靠谱的使用方式（这种不靠谱的方式也是后面提及的匿名的内部类）
（3）抽象方法用abstract来修饰
不可以被实例化，那怎么使用这个抽象类呢？
抽象类的使用方法 做一个类来继承这个抽象类，继承的时候把方法体实现了,如下：
//抽象方法只能放到抽象类里面，因此前面也要加abstract abstract class Test1 { abstract void printInfo(); //在抽象类里面的方法，要么完善方法体，要么作为抽象方法 } //没有方法体的方法，该方法由子类来具体实现 //类似C语言中对函数的声明 class Test2 extends Test1 //继承抽象类，从而使用抽象类 { @Override public void printInfo() { System.out.println("来自：test2"); } } public class Demo1 { public static void main(String[] args){ Test2 t2 = new Test2(); t2.printInfo(); } } 抽象类的应用：模板方法模式 模板方法模式定义：
父类抽象（abstract）化定义一系列方法作为模板（不具体），把一些步骤推迟到子类去实现，子类将重写这些方法以提供具体行为。
之前做的智能家居可以运行在多个平台上，比如51，32，树莓派，现在就定义在每个平台上完成这个项目的通用模板，然后再在具体平台实现，以51为例子（当然这只是一个类比，java在51单片机上不能运行）:
abstract class Control { abstract void getCommand(); //是概括了在不同平台上完成智能家居项目的模板 abstract void socketCommand(); //抽象化这些方法，在子类（类比于具体平台） abstract void lightControl(); //中再进行具体化 abstract void cameraControl(); public void work(){ //控制的基本流程 getCommand(); //接收指令 socketCommand(); //来自socket的指令 lightControl(); //灯的控制 cameraControl(); //相机的控制 } } class C51platform extends Control //当这个地方出现红色波浪线的时候 { //光标放上去，可以看到解决方法的快捷键 @Override //把抽象方法重写，全部具体实现 void getCommand() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d563190376711bb49148ec29d1a0129c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b83011d860fea227dcac9bfdf5b3404/" rel="bookmark">
			耦合电容的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		耦合即把一端的能量传递到另一端去，有光耦合、电耦合等，本文主要介绍电耦合。
**
1.那么电容是如何将前端的电传递到后端的呢？ **常用的耦合结构模型如下：
我们要分析Vin的信号如何传递到Vout端，需要用到一个高通滤波器模型，因为最终Vout是要连接下一端电路的。在这里我们可以把它简化为负载电阻R，则模型如下：
这就是一个高通滤波器，将Vin端的信号传递到Vout端，我们只需要用阻抗、容抗计算Vout端的电压即可。Vout=VinR/（R+1/（2/πfC））。这里的f是Vin端信号的频率。
我们要保证Vin的信号较好的传递到Vout端，那么需要一个衡量的尺度截止频率，这个概念不懂的自己百度，截止频率Ft=1/（2πR*C）。即如果要保证信号的传递不失真，则电路的R、C、f需要满足这个公式。
**
2.那么到底电子是如何从Vin端传递到Vout端呢？ 我们暂时假设100M的正弦波信号需要从Vin传递到Vout端，Vpp=1V,电压向上偏移1v，即Vin端产生的信号为1----2V的正弦信号。
信号上升阶段，即Vin的信号从1V上升到2V,此时电子传递模型如下：
**
加粗样式 **
正弦波上升时期，Vin对电容C1充电，则电子逐渐聚集到电容C1的左电极上。此时Vout相对GND端，输出正的电压，逐渐升高；
正弦波信号下降阶段，即Vin的信号从2V逐渐下降到1V，此时电子的传递模型如下：
正弦波下降阶段，C1左电极上的电子开始想Vin方向传递，Vout端的电流传递是从GND向Vout，表现为Vout端的电压为负电压。
因此交流信号通过如上模型，传递到Vout端。
**
3.假如Vin的频率很低，接近0hz，或者远低于截止频率，Vout端的电压如何？ 首先Vin输出的信号为直流时，Vout端的电压为0，因为根据上图电子传递模型，C1左端的电压不发生变化，没有电子传递，则Vout=0.
当Vin的信号频率远低于截止频率时，Vin的信号通过C1到达Vout后，Vout的信号幅度衰减很大，根据问题1的电压计算公式可以计算出来，如果信号远远低于截止频率，那么Vout的电压也可能会衰减为0.
**
4.正常输出时Vout单端的信号波形如何？ 当我们用电容进行耦合输出时，即使我们Vin端输出的电压为1v—2v的正弦波信号，因为耦合电容的作用，Vout端的输出电压则为-0.5v到0.5v的正弦波信号，这也就是耦合电容的特性，隔离直流分量，只输出交流信号。
5.电容的选型问题？ 通过我们上面的分析，电容的容量选择越大越好，那么信号的截止频率就会很小，信号不会衰减厉害。但是呢，电容量选的越大，则电容的ESR参数会越大，对信号的干扰越大，因此我们倾向于选择ESR损耗小的电容进行耦合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b84e845627e6a66bedab877e998d13fc/" rel="bookmark">
			signature=4663d2e4a53027c30ebb84732728e07e,vue-web3/yarn.lock at master · morrislaptop/vue-web3 · Gi...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1
"@octokit/rest@^14.0.3":
version "14.0.9"
resolved "https://registry.yarnpkg.com/@octokit/rest/-/rest-14.0.9.tgz#d5e0a00dcb78901dd7b2ef852acfc0aea7c479ef"
dependencies:
before-after-hook "^1.1.0"
debug "^3.1.0"
is-array-buffer "^1.0.0"
is-stream "^1.1.0"
lodash "^4.17.4"
url-template "^2.0.8"
"@semantic-release/commit-analyzer@^5.0.0":
version "5.1.0"
resolved "https://registry.yarnpkg.com/@semantic-release/commit-analyzer/-/commit-analyzer-5.1.0.tgz#9faffaa59a7b4a08adab7747da67afd57a997314"
dependencies:
conventional-changelog-angular "^5.0.0"
conventional-commits-filter "^2.0.0"
conventional-commits-parser "^3.0.0"
debug "^3.1.0"
import-from "^2.1.0"
lodash "^4.17.4"
"@semantic-release/error@^2.1.0":
version "2.2.0"
resolved "https://registry.yarnpkg.com/@semantic-release/error/-/error-2.2.0.tgz#ee9d5a09c9969eade1ec864776aeda5c5cddbbf0"
"@semantic-release/github@^3.0.1":
version "3.0.3"
resolved "https://registry.yarnpkg.com/@semantic-release/github/-/github-3.0.3.tgz#a986fa36111a34b3cc42b1a7f41fe4f019df570b"
dependencies:
"@octokit/rest" "^14.0.3"
"@semantic-release/error" "^2.1.0"
debug "^3.1.0"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b84e845627e6a66bedab877e998d13fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c0d2cb9f93a1f4b6d20ce3b434f8e4/" rel="bookmark">
			android查看线程信息,android线程消息机制之Handler详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android线程消息机制主要由Handler,Looper,Message和MessageQuene四个部分组成。平常在开发中，我们常用来在子线程中通知主线程来更新，其实整个安卓生命周期的驱动都是通过Handler(ActivityThread.H)来实现的。
首先我们先介绍这四个类的作用：
Handler：消息的发送者。负责将Message消息发送到MessageQueue中。以及通过Runnable,Callback或者handleMessage()来实现消息的回调处理
Looper：是消息的循环处理器，它负责从MessageQueue中取出Message对象进行处理。(Looper含有MessageQueue的引用)
Message：是消息载体，通过target来指向handler的引用。通过object来包含业务逻辑数据。其中MessagePool为消息池，用于回收空闲的Message对象的。
MessageQueue：消息队列，负责维护待处理的消息对象。
通过上面的图，我们可以比较清楚地知道他们的作用以及关系。接下来，我们从源码角度来分析这种关系是如何建立的。
public Handler(Looper looper, Callback callback, boolean async) {
mLooper = looper;
mQueue = looper.mQueue;
mCallback = callback;
mAsynchronous = async;
}
hander的其它构造方法可以自己去查看，通过这个构造方法，我们知道，handler持有MessageQueue的引用。所以可以方便地将Message加入到队列中去。
通过源码我们发现，sendMessage-&gt;sendMessageDelayed-&gt;sendMessageAtTime-&gt;enqueueMessage
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
MessageQueue queue = mQueue;
if (queue == null) {
RuntimeException e = new RuntimeException(
this + " sendMessageAtTime() called with no mQueue");
Log.w("Looper", e.getMessage(), e);
return false;
}
return enqueueMessage(queue, msg, uptimeMillis);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84c0d2cb9f93a1f4b6d20ce3b434f8e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5673bdf2f113fffd3a106a96284a3a51/" rel="bookmark">
			Android手机投屏后没有声音,乐播投屏电视没有声音怎么办_乐播投屏电视没有声音手机有声音解决办法_3DM手游...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐播投屏是一个非常不错的投屏软件，操作使用简单，最近不少小伙伴都在用。但是在使用乐播投屏的时候，有很多小伙伴出现了电视没有声音手机有声音的情况，这是怎么回事呢？我们一起来看看乐播投屏电视没有声音的解决办法吧！
乐播投屏电视没有声音怎么办？
解决办法一：
手机打开乐播投屏，在左上角设置里，打开镜像麦克风采集声音。打开之后，再一次使用镜像投屏时，电视就会采集手机收听到的声音。
但要注意：除小米手机外，其他安卓手机都是采集的环境声音，所以电视可能有杂音。
解决办法二：
如果不能直接传输声音，我们可以可戴耳机观看，手机插耳机。或者通过配置蓝牙音箱传声，将手机蓝牙和电视蓝牙打开，利用手机搜索电视蓝牙配对后，蓝牙传输声音。
解决方法三：改用推送模式。
如果你最终是为了投屏视频，请关闭镜像。也就是说不用直接使用乐播投屏手机版里的镜像同屏功能。可以直接在第三方视频APP找到TV投屏按钮，此模式可将声音同步至电视，投屏后还可关闭手机。具体怎么操作，请参考电视乐播中的视频投屏教程。
备注：Windows电脑，苹果手机/电脑镜像是直接有声音的。
如果发现苹果手机也没有声音。主要原因是你的苹果手机静音键打开了，请把它关闭不要禁音即可。
安卓手机没有声音原理：
由于安卓系统缺陷，手机厂商都禁止将录音权限给第三方。所以任何APP都拿不到录音授权。除非又战略合作。因此你可将这个问题反馈给你的手机客服，在不断努力下，小米手机已经和乐播合作，取得镜像声音授权。记得将小米手机升级到MIUI8.2以上版本。
以上就是小编带来的全部内容，更多乐播投屏相关教程，请关注3DM手游网。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f40d810628c6626d5cab12ae236b79/" rel="bookmark">
			扩展原理——BeanDefinitionRegistryPostProcessor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、BeanDefinitionRegistryPostProcessor后置处理器 BeanDefinitionRegistryPostProcessor接口继承BeanFactoryPostProcessor接口，在所有bean定义信息将要被加载，bean实例还没有创建的时候执行。BeanDefinitionRegistry是bean定义信息的保存中心，以后BeanFactory就是按照BeanDefinitionRegistry里面保存的每一个bean定义信息创建bean实例
BeanDefinitionRegistryPostProcessor会在BeanFactoryPostProcessor之前执行，可以利用BeanDefinitionRegistryPostProcessor给容器中添加一些其它组件
自定义MyBeanDefinitionRegistryPostProcessor组件，实现BeanDefinitionRegistryPostProcessor接口
@Component public class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor { public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { System.out.println("MyBeanDefinitionRegistryPostProcessor...postProcessBeanDefinitionRegistry方法 " + "Bean的数量：" + registry.getBeanDefinitionCount()); //手动注册一些bean定义信息 RootBeanDefinition beanDefinition = new RootBeanDefinition(Girl.class); registry.registerBeanDefinition("helloGirl",beanDefinition); AbstractBeanDefinition beanDefinition1 = BeanDefinitionBuilder.rootBeanDefinition(Girl.class).getBeanDefinition(); registry.registerBeanDefinition("byeGirl",beanDefinition1); } public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { System.out.println("MyBeanDefinitionRegistryPostProcessor...postProcessBeanFactory方法 " + "Bean的数量：" + beanFactory.getBeanDefinitionCount()); } } 测试
二、BeanDefinitionRegistryPostProcessor优先执行原理 首先是准备创建ioc容器
调用refresh()刷新容器
refresh()方法会调用invokeBeanFactoryPostProcessors(beanFactory)方法
invokeBeanFactoryPostProcessors(beanFactory)方法会从容器中获取到所有的BeanDefinitionRegistryPostProcessor组件，然后调用invokeBeanDefinitionRegistryPostProcessors()方法
遍历每一个BeanDefinitionRegistryPostProcessor组件，触发postProcessBeanDefinitionRegistry()方法
执行自定义的postProcessBeanDefinitionRegistry()方法
执行完invokeBeanDefinitionRegistryPostProcessors()方法之后，会继续调用invokeBeanFactoryPostProcessors()方法
遍历每一个BeanDefinitionRegistryPostProcessor组件，触发postProcessBeanFactory()方法，这个方法是BeanFactoryPostProcessor规定的方法，但是BeanDefinitionRegistryPostProcessor接口继承了BeanFactoryPostProcessor接口，重写了该方法
执行自定义的postProcessBeanFactory()方法
至此，BeanDefinitionRegistryPostProcessor的两个方法都执行完成，即BeanDefinitionRegistryPostProcessor组件执行完毕。
接下来会从容器中找到BeanFactoryPostProcessor组件，依次触发postProcessBeanFactory()方法，由于BeanDefinitionRegistryPostProcessor组件优先BeanFactoryPostProcessor组件执行，所以BeanDefinitionRegistryPostProcessor组件继承的postProcessBeanFactory()方法也会优先于BeanFactoryPostProcessor组件里面的postProcessBeanFactory()方法
所以，BeanDefinitionRegistryPostProcessor组件优先BeanFactoryPostProcessor组件执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bae03798b006d8a72a530f3c8f6ce45/" rel="bookmark">
			五、 循环结构基础（头歌实践平台）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：Java循环结构之while循环
任务描述
本小节需要你完成一个做俯卧撑的小程序，效果如下：
相关知识
Java中常用的循环有三种：while，do…while，for。
本小节我们先来看看while循环。
while循环的特点
循环顾名思义就是：重复的做某个事情，Java中的循环也是如此，当我们在开发中需要重复的做某个事情的时候，你就要想到循环了，接下来我们就来看看while循环是怎么使用的吧！
while(条件){
&lt;条件成立执行的代码&gt;
}
哈哈，是不是似曾相识呢？和我们在之前中讲到的if语句很像吧。没错while语句的用法和if差不多，if语句的特点是如果小括号中的条件成立，就执行一次大括号中的代码，那while循环语句的特点呢？我选择保密。
while循环体验
在D盘下新建一个文件HelloWorld.java输入下列代码。
编译运行。
做完上面两步之后你会发现你的程序一直在运行，根本停不下来，这是什么原因呢？也许你已经看出来了。
可是怎么解决呢？哈哈，授人以鱼不如授人以渔。
编程要求
在start-end区域中填充代码，使程序能输出如下效果：
测试说明
如果你写了一个死循环，评测的时候会导致评测超时，如果右侧一直在加载，说明评测超时了，这个时候请刷新你的页面。
代码实现
package step1; public class HelloWorld { public static void main(String[] args) { /*****start*****/ int i=0; while(i&lt;6){ i++; System.out.println("做了"+ i +"个俯卧撑"); } /*****end*****/ } } 第2关：Java循环结构之while循环练习
任务描述
使用while循环实现一个1到100的整数相加的小程序。效果图如下：
相关知识
经过上一小节，你应该认识到了，循环就像在操场跑圈，而编写一个循环语句需要三个要素：1.控制循环的条件，2.控制循环的次数，3.编写循环执行的代码；
知道了这些知识，你应该可以完成本关的任务了吧，我们一起来思考一下。 要实现一个从1到100整数相加的程序，如果没有学循环，你是不是这样写呢？ java int sum = 1 + 2 + 3 + 4 + 5 +…..+ 100;不过现在我们学了循环就不能用前面那么费劲的方式写了，可以发现这个程序需要我们重复做一个事情，而且数据也是不断变化的，所以需要你思考两个问题： 1. 重复做的事情是什么？ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bae03798b006d8a72a530f3c8f6ce45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f146d1f320e0c003a2576d62d0141b0c/" rel="bookmark">
			一、Java初体验（头歌实践平台）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：Java第一课
任务描述
本关任务：编写你的第一个Java程序，效果图如下：
编写第一个Java程序
1.新建一个HelloWorld.java文件（新建HelloWorld.txt将后缀.txt改成.java就ok了 注意：Java对大小写敏感所以大小写不要弄错了哦，在本案例H和W都是大写）；
2.在文件中添加如下代码：
public class HelloWorld{ public static void main(String[] args){ System.out.println("我要学java！"); } } （在这里你可能会有疑惑，这么多英文是干什么用的呢？现阶段，你可以不用管这样子写的原因，只需要记住public static void main(String[] args){}这个是程序的主入口，在你学习java基础阶段，你的代码都需要写在这里就行啦。）
好了，接下来将新建好的HelloWorld.java文件放在D盘下。
打开控制台：依次输入：
D: （切换目录到D盘下 因为HelloWorld.java文件在D盘）
Javac HelloWorld.java （编译java文件，代码写的有问题就会报错）
Java HelloWorld （运行编译生成的字节码文件）
运行编译完成之后即会打印出“我要学Java”
细心的小伙伴会发现当执行javac HelloWorld.java成功后D盘会多生成一个HelloWorld.class文件，这是为什么呢？这我们就要说到JAVA程序的运行流程了，关于这个你只需要记住一张图即可。
这张图也就是Java程序的编写执行流程：
1.将Java代码编写到扩展名为.java的文件中；
2.通过javac命令对该java文件进行编译；
3.通过java命令对生成的class文件进行运行（注意:虽然我们执行的是class文件但是在命令行中执行的时候不需要加 .class后缀）；
编程要求
是否能独立的写出一个Java程序了呢？在Begin-End区域内编辑器中编写代码输出如下结果：
测试说明
平台会对你的代码进行运行测试，如果实际输出与预期输出相同，则算通关。
代码实现：
public class HelloWorld{ /********* Begin *********/ public static void main(String[] args){ System.out.println("姓名：张三"); System.out.println("年龄：25"); System.out.println("职业：JAVA高级工程师"); System.out.println("薪资：15K"); } /********* End *********/ } 第2关：Java关键字
任务描述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f146d1f320e0c003a2576d62d0141b0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e0298dd34ae64cb721218e82df1d59/" rel="bookmark">
			Android 7.1 音效 杜比,杜比 7.1 环绕声 (Dolby Surround 7.1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		be_ixf; dotnet_sdk; dotnet_sdk_1.4.9
https://origin-www.dolby.com/cn/zh/technologies/dolby-surround-7-1.html
https://ixf2-api.bc0a.com/api/ixf/1.0.0/get_capsule/f00000000107113/1240707331?client=dotnet_sdk&amp;client_version=1.4.9&amp;orig_url=https%3A%2F%2Forigin-www.dolby.com%2Fcn%2Fzh%2Ftechnologies%2Fdolby-surround-7-1.html&amp;base_url=https%3A%2F%2Forigin-www.dolby.com%2Fcn%2Fzh%2Ftechnologies%2Fdolby-surround-7-1.html&amp;user_agent=Mozilla%2F5.0+(Macintosh%3B+Intel+Mac+OS+X+10_13_6)+AppleWebKit%2F537.36+(KHTML%2C+like+Gecko)+Chrome%2F79.0.3945.88+Safari%2F537.36
https://origin-www.dolby.com/cn/zh/technologies/dolby-surround-7-1.html
sdk.environment=production;sdk.charset=UTF-8;api.endpoint=https://ixf2-api.bc0a.com;sdk.account=f00000000107113;sdk.connectTimeout=2000;sdk.socketTimeout=2000;sdk.crawlerConnectTimeout=10000;sdk.crawlerSocketTimeout=10000;whitelist.parameter.list=ixf;flat.file=true;sdk.proxyPort=0;sdk.proxyProtocol=http;crawler.useragents=google|bingbot|msnbot|slurp|duckduckbot|baiduspider|yandexbot|sogou|exabot|facebot|ia_archiver;forcedirectapi.parameter.list=ixf-api|ixf;capsule.mode=remote.prod.capsule;page.independent=false;page.alias.url=https://origin-www.dolby.com/cn/zh/technologies/dolby-surround-7-1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25fd7b5ae0effddbef6ed949e0f609ce/" rel="bookmark">
			video视频直播总结（m3u8格式、flv格式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、视频播放标签video video属性和方法的可以在网上直接找，链接菜鸟教程
如果是MP4格式的视频，可以用video标签直接播放，其属性可以直接用，这个格式视频一般是静态的资源，可能是本地也可能是服务器上。 &lt;video class="video-img" :src="url" controls="controls"&gt;&lt;/video&gt;//url即视频地址 2、video标签事件与方法 事件是可以直接放到video标签上进行监听，在视频播放过程中会执行相应事件。方法是可以直接获取video元素，不管是原生的getElementById(),还是vue的this.$refs来让video元素执行方法，video标签的方法比较少，如图，其他的都是事件，事件比较多。
3、m3u8格式视频流播放 该格式需要安装videojs与video标签结合播放 //html代码 &lt;video id="videoss" class="video-js vjs-default-skin" style="width: 100%;height: 100%" muted&gt; &lt;source :src="videoSrc" /&gt; &lt;/video&gt; //js import videojs from "video.js";//引入videojs //在mounted中初始化 this.video = videojs( "videoss", { controls: false,//这些都是video标签的属性 loop: true, autoplay: true, width: "100%", height: "100%", preload: "auto", }, function () { this.play(); } ); 4、flv.js播放HTTP-FLV协议视频流 安装flvjs cnpm install --save flv.js代码 &lt;template&gt; &lt;div class="video"&gt; &lt;video id="videoElement" class="centeredVideo" autoplay controls width="1024" height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25fd7b5ae0effddbef6ed949e0f609ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6203b9477f49b81ae54d97d7cecf913e/" rel="bookmark">
			647.回文子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		647.回文子串 解题思路：
中心扩散法
Manacher 算法
package leadcode; /** * @author : icehill * @description : 回文子串 * 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 * 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 * 示例 1： * 输入："abc" * 输出：3 * 解释：三个回文子串: "a", "b", "c" * 示例 2： * 输入："aaa" * 输出：6 * 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa" * 提示： * 输入的字符串长度不会超过 1000 。 * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/palindromic-substrings * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 * @date : 2021-05-28 */ public class Solution647 { public static void main(String[] args) { Solution647 solution647 = new Solution647(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6203b9477f49b81ae54d97d7cecf913e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4001779fbb07c0e13d8a91ece1054c/" rel="bookmark">
			【Unity学习笔记】TextMeshPro文档(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人英语渣渣翻译，稍微删减了些自认为可以忽视的部分，原文地址 http://digitalnativestudios.com/textmeshpro/docs/textmeshpro-component/
Text Objects 提供了两个TextMesh Pro物体，一个用于Unity UI，另一个是用于3D场景。二者功能大体相同，但也有少许区别。本文使用用于UI那个来描述功能，也会指出二者的不同。
1 Text Objects 你可以通过GameObject&gt;UI&gt;Text-TextMeshPro来添加该UI物体。和其它UI物体一样，这个新物体也有Transform和Canvas Renderer组件，然后你就可以通过Text Mesh Pro组件来管理文本，你也可以将此组件添加到其它游戏物体中，它会自动的添加必要的属性。
1.1 UI Material 在Inspector面板也能看到渲染文本所用的material。通常情况下，UI物体是不会用这方式显示它们的material的，因为它们没有Mesh Renderer组件。在这里，它实际是inspector面板的一部分。如果你给这个物体添加更多的组件，它们会显示到material的下面，除非你改变它们的排序。（但是我没看到这种现象，可能版本更新了？）
通过这个material可以很方便的访问文本的材质。但是，它不允许UI物体的Material属性设置动画，这是Unity的UI解决方案的限制。
1.2 3D Text Object 3D物体通过GameObject&gt;3D Object&gt;Text-TextMeshPro来创建。创建的文本是平的，看起来就和UI文本一样。但是它是单独存在于游戏场景中的，而不是Canvas的子物体。（它和3D游戏物体一样，可以在3D空间中旋转缩放移动）
在这里，该物体有它自己的Mesh Renderer组件，Material属性也被显示得很好，并且material属性可以动画化。另外，尽管它是3D物体，但依然使用的是Rect Transform组件。
2 Text Input Box 文本输入框是用来输入文字的
2.1Right-to-left Mode 你可以勾选Enable RTL Editor单选框转换为从右到左的文本排列方式（相当于把字符的显示顺序颠倒，abc显示为cba），文本在显示前会将字符顺序颠倒过来。勾选后，Inspector面板上会多出一个RTL Text Input输入框，可以直接编辑已经反顺序的文字。
RTL模式仅仅是反转文本顺序，其它不变。
3 Main Settings 关于字体、字体风格、对齐方式等的设置
3.1 Font Asset TextMesh Pro使用它自己的字体资产(Font Asset)，你可以通过Font Asset Creator面板进行创建。默认使用的是LiberationSans SDF。
3.2 Material Preset 材质预设。每个字体资产都有默认的材质，你也可以为它创建自定义的材质。你可以使用这个下拉列表快速切换。
这个列表中的材质是通过搜索 名称中包含对应字体名字并且使用对应的字体图集纹理的材质 添加的。
3.3 Font Style 有七种字体风格供你选择。如果你想让其中部分文字效果不同，可以使用富文本（rich text）标签
前俩选项是粗体和斜体，它们的外观依赖字体资产（Font Asset）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f4001779fbb07c0e13d8a91ece1054c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29622369059d53cd7a4809e0eab765f9/" rel="bookmark">
			PTA 谁先倒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目
代码
#include&lt;stdio.h&gt; int main(){ char r; int s[110],s1,s2,j1[110],j2[110],y1[110],y2[110],n,t,i; scanf("%d%d",&amp;s1,&amp;s2); int s11=0,s22=0; scanf("%d",&amp;n); for(i=0;i&lt;n;++i){ scanf("%d%d%d%d",&amp;j1[i],&amp;j2[i],&amp;y1[i],&amp;y2[i]); } for(i=0;i&lt;n;++i){ s[i]=0; s[i]=j1[i]+y1[i]; if(j2[i]==s[i]&amp;&amp;y2[i]!=s[i]) s11++; if(j2[i]!=s[i]&amp;&amp;y2[i]==s[i]) s22++; if(s11&gt;s1){ t=s22; r='A'; break;	} if(s22&gt;s2){ t=s11; r='B';	break; } } printf("%c\n%d\n",r,t); return 0; } 问题：1.读题问题，数据得全部输出，采用数组
2.“两人同赢或两人同输则继续下一轮，直到唯一的赢家出现”对文字的处理
3.“第二行中输出没倒的那个人喝了多少杯。”注意文中最终求计算的是什么
问题代码
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(){ char r; int s,s1,s2,j1,j2,y1,y2,n,t;//问题 scanf("%d%d",&amp;s1,&amp;s2); int s11=s1,s22=s2; scanf("%d",&amp;n); while(n--){ scanf("%d%d%d%d",&amp;j1,&amp;j2,&amp;y1,&amp;y2); s=0; s=j1+y1; if(j2==s) s1--;//问题 if(y2==s) s2--;//问题 if(s1==0){ t=s22-s2; r='A'; break;	} if(s2==0){ t=s11-s1; r='B';	break; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29622369059d53cd7a4809e0eab765f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef674f70e27b2e1fb998954902509ba3/" rel="bookmark">
			华为鸿蒙ai字幕,EMUI11一个值得吹爆的功能？AI字幕，支持翻译英日韩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在昨天华为的HDC开发者大会上，华为不仅带来了自研鸿蒙系统的最新消息，表示年底华为手机将开始适配鸿蒙系统，明年华为手机则将全面支持鸿蒙系统，而且还发布了全新的EMUI11。EMUI11相比上一代EMUI10.1，功能更加丰富了，分布式操作也更加完善，其中，EMUI11带来了一个全新的功能，笔者认为这个功能值得吹爆，也就是AI字幕。
AI字幕，相信大家都已经有粗略的了解，就是一个翻译的功能，支持翻译英语、日语、韩语。不过，华为这个AI字幕，不是简单的翻译功能那么简单，它这个技术是可以实时翻译的。比如你在播放一个讲英语的视频，AI字幕会自动获取这个视频的音源，然后进行翻译，并且自动实时的将翻译成汉语的字幕打在视频上。这个功能真的是太牛了，因为它不是静态的，而是实时动态的翻译，这个技术估计短时间内只有华为可以做到了吧。
其实早在去年，华为就有推出类似的功能了，也就是同声传译，启动这个功能后，和外国人打电话的时候，华为手机就会实时的自动将英语翻译成汉语，也能将汉语翻译成英语，这样听不懂英语、不会说英语的朋友，也能愉快的沟通了。以前是英语翻译成汉语，语音到语音，而这一次AI字幕，是直接英语翻译成汉字，语音到字体。
值得一提的是，AI字幕这个功能对于那些平时喜欢追美剧、韩剧、日剧，但又碍于听不懂的朋友来说，简直就是一大神器啊。此外，EMUI11各项功能也更加完善了，动画更加流畅了，不少了解了EMUI11的朋友，都纷纷表示想要换华为手机了。对此，大家有什么看法？欢迎评论留言，不妨说说看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d507300baf66bc0d486958b6165d95/" rel="bookmark">
			软件工程期末试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程期末试题 软件工程期末试题（一）单项选择题设计题 软件工程期末试题（二）一, 判断题(正确的在括号内打上"√",错误的打上"×".每题1.5分,共15分)二,单项选择题(每小题2分,共10分)三,多项选择题(每题2分,共10分.注:正确得2分,漏选得1分,多选,错选不得分.)四,简答题(每题6分,共24分) 软件工程期末试卷（三）一、填空题（每空1分，共20分）二、单项选择题（每小题2分，共10分）三、多项选择题（每题2分，共10分）四、判断题五、简答题（每题5分，共20分）六、分析设计题（共20分） 一、 简答题（25%， 每小题5分）：二、 应用题（45%，1-3每小题10分，4小题15分）软件工程期末试卷（五）一、填空题二、单项选择题三、多项选择题四、判断题五、问答题 软件工程期末试卷（六）一．选择二.填空三．判断 软件工程期末试卷（七）一、判断题（每题2分，共30分）二。单选题（每题2分，共20分）三。简答题（每题5分，共25分） 软件工程期末试卷（八）选择填空 软件工程期末试卷（九）(十)软件工程专项训练选择简答 软件工程期末试题（一） 单项选择题 1.瀑布模型的存在问题是（ B ）
A．用户容易参与开发 B．缺乏灵活性
C．用户与开发者易沟通 D．适用可变需求
2.开发软件所需高成本和产品的低质量之间有着尖锐的矛盾，这种现象称做( C )
A.软件工程 B.软件周期
C.软件危机 D.软件产生
3.数据耦合、公共耦合、标记耦合、控制耦合的耦合性从低到高的顺序是（ B ）
A.数据、公共、标记、控制 B.数据、标记、控制、公共
C.控制、数据、标记、公共 D.控制、数据、公共、标记
4.在SD方法中全面指导模块划分的最重要的原则是( D )
A.程序模块化 B.模块高内聚
C.模块低耦合 D.模块独立性
5．软件测试的目的是（ B ）。
A． 评价软件的质量 B. 发现软件的错误
C． 找出软件的所有错误 D. 证明软件是正确的
6．在设计测试用例时，（ A ）是用得最多的一种黑盒测试方法。
A． 等价类划分 B. 边界值分析 C. 因果图 D. 判定表
需求分析最终结果是产生( B )。 A. 项目开发计划 B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10d507300baf66bc0d486958b6165d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557ce14afd96edcabec177669736712a/" rel="bookmark">
			FPGA MultiBoot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引 1. MultiBoot工作流程2. IPROG命令 Xilinx FPGA的多启动镜像方案为MultiBoot。
该方案的目的是：
当FPGA更新程序时无法加载成功或者工作不正常的时候，可以通过加载Golden Image备份镜像来重新加载进行恢复。
1. MultiBoot工作流程 Flash中划分为两个（或多个）区域，基地址（Addr0）存储Golden image备份程序，高位地址存储MultiBoot image升级程序。Golden image中除了备份程序还内嵌了multiboot启动地址（WBSTAR）和IPROG命令。
FPGA加载启动流程：
FPGA上电后先加载0地址的Golden image，当执行到IPROG命令时跳转地址到WBSTAR地址继续加载MultiBoot image进行程序升级。若在加载过程中错误或中断，则Fallback回到0地址执行Golden image，同时忽略热启动地址和IPROG命令，以确保可以正常加载启动FPGA。
2. IPROG命令 Xilinx的Multiboot方案中使用了一条加载命令：IPROG。而这条命令是放在Golden image中。
具体说，对于FPGA直接从0地址开始读取，先开始加载Golden image，但是这个镜像是经过特别处理的，在镜像数据刚开始的部分添加了IPROG命令和MultiBoot image的地址。当FPGA读取到这个命令之后，就会直接跳过后面的数据，从设置的地址开始继续加载。
当发生了Fallback之后，工程会反跳回0地址开始加载，从新加载G镜像。这里，FPGA内部的配置寄存器会做记录，当发生Fallback之后，会自动忽略IPROG命令，直接加载G镜像后续的部分，来保证G镜像有机会被完整的加载。
链接Xilinx 7系列FPGA Multiboot介绍: link.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bade5714f4096f5949746d318b93a4f/" rel="bookmark">
			怎样下载网页中.ts视频文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先打开360浏览器下载“视频下载神器”插件。点击浏览器左侧管理 -》添加，如下图所示。
然后在搜索框中搜索“视频下载神器”并安装，如下图所示
安装完成后，打开网页在未播放前,等待网页中的视频缓存完毕后点击全部下载，如下图所示
下载下来的视频是按照1-100编号排序的，下面就需要将多个视频合并成一个。 使用Win + R打开下面窗口，输入“cmd”，点击“确定”.
打开下面窗口，输入命令行：“copy /b D:\f\*.ts D:\f\new.ts”，然后回车。
在D盘目录下new.ts就是合并好的文件
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ded44a40a67fd3e6c6300458220d28/" rel="bookmark">
			s905l android5,魔百盒M101晶晨S905L处理器专用安卓纯净刷机rom固件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		魔百和M101主板上的处理器芯片为S905L的，
固件下载：请点击上面的购买rom按钮进行下载；
刷机工具及教程：点击此处查看；
固件下载后参考刷机教程自己就可以操作了
本页面是关于魔百盒M101盒子晶晨S905L处理的盒子固件！
下载前请先看下主板上的处理器芯片是否为S905L在进行下载，
*********************************************************************
一：如您的主板芯片型号与对本页对照图一致则说明可以下载刷机；
二：如不一致，那么请点击此处查找适配您主板的固件在精确下载；
**********************************************************************
以下是安卓纯净桌面
以上就是关于魔百和M101网络机顶盒怎么刷入安卓固件的教程了，
感谢您对麒麟刷机网的支持！购买rom的用户刷机过程中遇到问题
可以添加咱们网站首页的QQ群进行反馈交流互动哦!
温馨提示及免责声明 ：
1、刷机有风险，动手需谨慎。szjytx.com不对任何因刷机造成的一切机器故障负责!
2、本站所有软件版权均归软件作者所有，我们仅提供下载服务。
3、软件只限于个人封装技术研究交流使用，请在下载后24小时内删除，切勿用于商业用途。
4、如您已下载本页面的固件或教程，说明您已充分了解了本站的声明及提醒，
___由此造成(产生)的任何一切问题及后果将由您自行承担。
5、本站所提供软件来源于互联网或网友提供，如果该程序涉及或侵害到您的版权请立即写信通知我们删除。
___本站邮箱admin#szjytx.com将#换成@[来信请提供详细证明材料，我们将严格审核后撤下相关侵权内容]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/437d177c05d2508b1206f3e0a8305134/" rel="bookmark">
			android pixel 2,谷歌 Pixel 2 评测：目前最好的安卓手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：谷歌 Pixel 2 评测：目前最好的安卓手机
两周前，谷歌在旧金山举行发布会，推出了 Pixel 2 智能手机。现在，谷歌 Pixel 2 智能手机的首批媒体评测已经出炉。大部分评测都很正面，认为 Pixel 2 是目前能买到最好的 Android 手机，也是苹果 iPhone 系列最强力的竞争对手。
The Verge 认为 Pixel 2 XL 的设计和外观非常出色，比 Pixel 2 更好。Pixel 2的边框宽一些，而 XL 的边框非常窄。设备搭载高通骁龙 835 处理器，4GB 运行内存，整个体验比较流畅，要比三星或 LG 版 Android 更好。电池续航方面，The Verge 认为能够坚持一天。拍照方面，要比 iPhone 8 和 Note 8 更好。
TechCrunch 网站认为，Pixel 2 XL 就像是 S 系列的 iPhone，这意味着 Pixel 2 是初代 Pixel 的进化版， 但缺少“令人印象深刻”的功能。不过， Pixel 2 可以采用单个摄像头实现这种拍摄效果还是很出色的，低光和混合光线环境下，拍照效果都非常不错。虽然 Pixel 2 XL 价格高达 800 美元，TechCrunch 还是认为很便宜，毕竟没有超过 1000 美元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/437d177c05d2508b1206f3e0a8305134/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf3035597a759702c64d542fe9635e9/" rel="bookmark">
			建了索引但是用不上的3种情况?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言建了索引但是用不上的3种情况? 前言 如果您觉得有用的话，记得给博主点个赞，评论，收藏一键三连啊，写作不易啊^ _ ^。
而且听说点赞的人每天的运气都不会太差，实在白嫖的话，那欢迎常来啊!!!
建了索引但是用不上的3种情况? 查询数据内容不走左匹配查询字段使用函数运算查询没有使用联合索引最左边的列 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8599a1c76308422a44ce54588804c8d9/" rel="bookmark">
			使用RedisTemplate保存数据，Redis中出现乱码的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言使用RedisTemplate保存数据，Redis中出现乱码的问题 前言 如果您觉得有用的话，记得给博主点个赞，评论，收藏一键三连啊，写作不易啊^ _ ^。
而且听说点赞的人每天的运气都不会太差，实在白嫖的话，那欢迎常来啊!!!
使用RedisTemplate保存数据，Redis中出现乱码的问题 原因:默认情况下RedisTemplate针对Key和Value使用了jdk序列化，所谓的一串乱码其实就是字符串经过jdk序列化的结果。
解决: 使用StringRedisTemplate或者设置Key的序列化方式为字符串。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56687d7e202e7129ac04b18850e647b8/" rel="bookmark">
			为什么读写文件会遇到乱码问题?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言为什么读写文件会遇到乱码问题? 前言 如果您觉得有用的话，记得给博主点个赞，评论，收藏一键三连啊，写作不易啊^ _ ^。
而且听说点赞的人每天的运气都不会太差，实在白嫖的话，那欢迎常来啊!!!
为什么读写文件会遇到乱码问题? 答:FileReader 是以当前机器的默认字符集来读取文件的
解决:如果希望指定字符集的话，需要使用InputStreamReader和FileInputStream
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973d4a9d9180aad3dcb0591c01086528/" rel="bookmark">
			线程池通过submit提交任务，出现任务，会怎样?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言线程池通过submit提交任务，出现任务，会怎样? 前言 如果您觉得有用的话，记得给博主点个赞，评论，收藏一键三连啊，写作不易啊^ _ ^。
而且听说点赞的人每天的运气都不会太差，实在白嫖的话，那欢迎常来啊!!!
线程池通过submit提交任务，出现任务，会怎样? 答:线程不退出，但是异常被生吞。
解决:通过submit提交的任务，保存Future，通过get方法获取返回内容以及可能出现的异常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a0f6d99fbc9034635050b71fc4bb3b/" rel="bookmark">
			为什么我使用了ConcurrentHashMap，还是没有发挥性能优势?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言为什么我使用了ConcurrentHashMap，还是没有发挥性能优势? 前言 如果您觉得有用的话，记得给博主点个赞，评论，收藏一键三连啊，写作不易啊^ _ ^。
而且听说点赞的人每天的运气都不会太差，实在白嫖的话，那欢迎常来啊!!!
为什么我使用了ConcurrentHashMap，还是没有发挥性能优势? 答:仍然想使用hashmap那样使用加锁的方式来使用；
解决:
使用ConcurrentHashMap的读写操作来发挥性能优势，ConcurrentHashMap 只能保证读写操作原子性，其他size、isEmpty、containsValue等聚合方法不能保证，只能做为参考，不能作为流程控制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aef89fa40b0afe606a598a4a56170cc/" rel="bookmark">
			粒子群算法原理|python实现|参数调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		粒子群算法是比较有名的群体智能算法之一，其他群体智能算法还包括蚁群算法、鱼群算法、人工蜂群算法等。今天学习一下粒子群算法。
文章目录 算法原理（Inspiration）优化过程python实现参数调优w参数的设置参数 c i c_i ci​的设置速度范围的设置种群规模的设置 算法结果 算法原理（Inspiration） 粒子群算法来源于鸟群的觅食行为，一群鸟随机寻找区域内唯一食物的位置，粒子群算法中的粒子就是鸟群中的小鸟。
该算法最重要的三个变量即每只鸟拥有的信息：
当前位置（向量X）、
自己当前位置距离食物的距离（适应度P，即当前X对应的目标函数值Y）、
飞行速度（向量V，即下一步X调整的方向和速度）。
优化过程 初始化
与大多数机器学习算法一样，粒子群算法的初始值随机确定。
初始值包括鸟群的初始位置(即X) X[popsize,num_variables]，
初始位置对应的适应度(即目标函数值y) fitness[popsize]，
初始速度 V[popsize]*；
计算当前个体最优(即每只鸟所取得过的y中的最优值) fitnessinbest[popsize]、
个体最优对应的位置(即X) inbest[popsize,num_variables]、当前整体最优(即所有鸟取得过的y中的最优值) fitnessglbest、
整体最优对应的位置 glbest[num_variables]。
其中，popsize表示鸟群中鸟的数量，num_variables表示问题中自变量的个数，如一元函数中num_variables为1，二元函数为2，等等。
迭代更新
在每次鸟群按照当前速度飞行一个单位时间（即一次迭代）后，所有粒子共享信息，从而计算出自己飞行到的所有地方中距离食物最近的点（局部最优）和所有鸟群飞到的位置中距离食物最近的点（全局最优），并计算加权平均决定下一步飞行的速度和位置。
速度和位置的更新公式如下：
V k + 1 = w V k + c 1 r 1 ( i n b e s t i d k − X i d k ) + c 2 r 2 ( g l b e s t k − X i d k ) V^{k+1}=wV^k+c_1r_1(inbest_{id}^k-X_{id}^k)+c_2r_2(glbest^k-X_{id}^k) Vk+1=wVk+c1​r1​(inbestidk​−Xidk​)+c2​r2​(glbestk−Xidk​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aef89fa40b0afe606a598a4a56170cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c5aa0736f4ad01e1239f0f0dd7bb13/" rel="bookmark">
			线程池通过execute提交任务，出现异常，会怎样?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言线程池通过execute提交任务，出现异常，会怎样? 前言 如果您觉得有用的话，记得给博主点个赞，评论，收藏一键三连啊，写作不易啊^ _ ^。
而且听说点赞的人每天的运气都不会太差，实在白嫖的话，那欢迎常来啊!!!
线程池通过execute提交任务，出现异常，会怎样? 答:线程退出，向标准错误输出打印了异常的线程名称和异常信息
解决:以execute方法提交到线程池的异步任务，最好在任务内部做好异常处理，并设置自定义的异常处理程序作为保底。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1f44c8eaa0c9c6570b16551e9132226/" rel="bookmark">
			Excel VBA-正则表达式汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		========================
'Pattern代码汇总 '^\s 替换行首空格 '^\n 替换行首的换行符 '"^\d\.\s*" 去除序号 '^(.*)$ 匹配整行 ========================
Private Sub 批量替换去除无用字符() Application.ScreenUpdating = False '关闭屏幕刷新 Dim RegExp As Object Dim SearchRange As Range, Cell As Range '此处定义正则表达式 Set RegExp = CreateObject("vbscript.regexp") '初始化正则对象 With RegExp .Global = True .IgnoreCase = True .MultiLine = True .Pattern = "^\n" End With '此处指定查找范围 Set SearchRange = Selection '遍历查找范围内的单元格 For Each Cell In SearchRange Set matches = RegExp.Execute(Cell.Value) If matches.Count &gt;= 1 Then Cell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1f44c8eaa0c9c6570b16551e9132226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1a419f288a76eae4ff2ab6401e0f2c/" rel="bookmark">
			android qq 文件怎么打开,如何更改腾讯QQ手机版默认的文件打开方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机QQ是陪伴我们时间最长的一款通讯社交软件了，最原始的腾讯QQ只可以用来聊聊天打视频电话什么的，但是随着科技和互联网的发展，QQ中已经出现了很多种新奇的功能了，这些功能让我们的生活变得更加的方便快捷，就比如我们在电脑和手机上面登录同一个QQ号，然后就可以实现文件分享，那么大多数人的手机QQ中都有一个默认的文件打开方式，有很多用户不知道要如何更改默认的打开方式，所以小编今天就来跟大家分享一下具体的方法步骤吧。
方法步骤
1.首先第一步我们打开手机界面之后在手机界面中找到系统自带的设置应用然后点击进去。
2.进入到手机的设置界面之后滑动手机界面，然后在界面的主菜单栏中找到“应用管理”这个选项然后点击进去。
3.点击进入到应用管理界面之后，我们就可以看到手机中已经安装好的一些应用了，然后我们在列表中找到QQ应用点击进去。
4.进入到QQ应用中之后我们接着往下滑动手机界面，然后在界面中找到“默认打开”这个选项。
5.点击进入到默认打开选项之后，我们可以点击界面中的清除默认设置按钮来清除已经设置的默认打开方式，这样就大功告成了。
使用以上方法就可以在更改手机QQ应用中的默认文件打开方式了，有很多朋友在使用手机QQ的时候肯定都有遇到过上述教程中的问题，所以有需要的朋友不妨试一试叫教程中的方法，希望能够帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c92e13049ead762e0976e4565538372a/" rel="bookmark">
			华为手机android目录,华为手机中的文件夹代表什么，哪些可以删除，看完秒懂...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用华为手机的小伙伴都知道，华为手机里面自带的有文件管理功能，在文件管理功能里面有很多以英文命名的文件夹，因为这些文件夹都是以英文命名的，所以很多人都不知道这些文件夹代表什么意思。
在对手机进行内存清理的时候，也不敢轻易删除，那么下面小编就来带大家了解一下，华为手机文件管理里面的几个主要的文件夹代表什么意思，能否删除。
1. tencent
这个文件夹相信大家都很熟悉，因为这个文件夹的意思是腾讯的意思，主要用来保存一些微信、QQ缓存的垃圾文件，其中包含很多微信聊天产生的垃圾图片和视频文件。这一个文件夹里面的东西是可以进行删除的。
2. data
date的中文意思是数据的意思，这个文件夹里面主要负责保存手机里面的一些重要的数据信息，在对手机数据清理时，这个文件夹里面的信息还是要谨慎清理的。
3. cache
cache中文意思是隐藏，缓存文件的意思，它里面的东西都是手机应用过程中产生的一些缓存数据，这些缓存数据一般都是没什么用的，所以是可以进行删除的。
4. backups
backups的中文意思是备份文件的意思，这个文件夹中主要是一些手机数据的备份，所以在清理时，这个文件夹要谨慎清理。
5. Alipay
Alipay文件夹顾名思义就是支付的意思，里面主要放的是一些关于支付宝的一些数据，主要是缓存的一些没有用的文件，这个是可以根据需要进行删除的。
6. Android
Android文件夹就是安卓的意思了，它里面放的就是一些我们的手机系统平时所产生的垃圾，这个文件夹里面的信息都是可以进行删除的，涉及到重要的信息不可以删除的系统会进行提醒，所以这个文件夹可以放心的进行删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22380f9d99ab79dca446611d83ad5ed/" rel="bookmark">
			吃鸡ios和android灵敏度,吃鸡灵敏度2021最新版分享码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详情
吃鸡灵敏度2021最新版分享码，最稳吃鸡灵敏度工具，支持不同手机型号轻松最稳吃鸡，自定义调节游戏参数，，免root操作，用户可以提供输入手机型号来调整灵敏度，带来最稳的吃鸡工具，轻松压枪射击敌人哦，快来下载吧。
吃鸡灵敏度2021最新版分享码使用说明
下载完成后一键安装;
软件免root;
一键设置你喜欢的灵敏度;
自动保存上次的设置;
打开之后可以后台运行，不会影响游戏速度;
这款软件拥有防封设置，玩家可以放心使用。
吃鸡灵敏度2021最新版分享码亮点
1.修改后，您可以去训练场进行适应，并且可以自己更改任何不满意之处;
2.注销后，数据将始终存储在云中，因此下次直接登录时无需更改设置。
3.只要您熟悉它，并且发现爆头不是梦，这不是梦，那么您现在就可以成为伟大的上帝。
吃鸡灵敏度2021最新版分享码功能
1、全局灵敏度
系统推荐【中级】灵敏度
2、自由镜头灵敏度
第三人称人物、载具状态自由镜头(小眼睛)105%
跳伞状态自由镜头(小眼睛)105%
第一人称人物自由镜头(小眼睛)90%
3、镜头灵敏度
第三人称不开镜66%
第一人称不开镜70%
红点、全息、机瞄52%
2倍镜35%
3倍镜24%
4倍镜、vss23%
6倍镜12%
8倍镜7%
4、开火镜头灵敏度
第三人称不开镜66%
第一人称不开镜88%
红点、全息、机瞄53%
2倍镜38%
3倍镜40%
4倍镜、vss24%
6倍镜22%
8倍镜7%
5、陀螺仪灵敏度
第三人称不开镜181%
第一人称不开镜1%
红点、全息、机瞄300%
2倍镜276%
3倍镜203%
4倍镜、vss189%
6倍镜30%
8倍镜15%
吃鸡灵敏度2021最新版分享码大全
最强二指 灵敏度分享码
1、花老师-无陀螺仪：1531-7769-1499-1925-09
2、烤羊腿-全陀螺仪：1539-3617-8429-9198-85
3、无陀螺仪二指：1742-1453-4255-4325-1
最强三指 灵敏度分享码
1、萌少解说-全陀螺仪：1532-1540-2385-8943-40
2、冷宴华-无陀螺仪：2977-9506-0037-4196-11
3、无陀螺仪 红米k20pro：1051-1864-8301-8854-3
最强四指 灵敏度分享码
1、键位码:1550-0710-1686-4094-33
2、灵敏度:1538-3762-8262-6071-83
3、四指全陀螺仪-1531-5142-9921-6523-36
4、少白四指全陀螺仪：1395-8388-1798-6477-0
最强五指 灵敏度分享码
1、难言-半陀螺仪：2978-7614-0430-0341-51
2、难言-半陀螺仪：1539-5675-8839-4606-25
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b22bb21e00c2b49424b812a32131b3ed/" rel="bookmark">
			originos是鸿蒙系统吗,originos系统是安卓吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		originos系统是安卓吗？很多小伙伴们对于这个手机系统都是一头问号，不是很清楚这个系统是什么系统，而且还是最近比较火爆的新闻，那么originos系统是安卓吗？下面就让小编给大家介绍一下。
originos系统介绍
OriginOS是vivo旗下的操作系统，于2020年11月18日发布，是基于安卓的手机系统。一直以来，FuntouchOS 的使命就是服务好用户，并在多年来收获了广大用户的信赖。然而我们没有停止在手机操作系统上的探索，在 5G 和万物互联时代，特别是在未来的 3-5 年，手机依然是数字世界最核心、最无可替代的入口，我们一直在思考，还能够解决哪些痛点和需求？如今，OriginOS 带来了我们对用户需求的全新解读和诠释，它就是追求极致用户体验的产物。
翻译一下，就是 FuntouchOS 的历史使命差不多完成了(但线下用户依旧会继续使用的)，OriginOS 是面向未来的设计，提供给喜欢折腾手机还喜欢上网分享讨论体验的人。
相较于先前的系统，这次 OriginOS 不是例行的升级，而是全新的重构，除了依旧基于 Android 系统进行深度定制之外，已经和前面的 FuntouchOS 没有什么关系了。这体现在新系统的方方面面，比如桌面应用架构，交互，通知体系，主题壁纸等等。
以上就是originos系统是安卓吗的全部内容，希望以上内容能帮助到朋友们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef79a5a8f393516681c473064288d34c/" rel="bookmark">
			Learn Linux 101: Basic network troubleshooting
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文 Overview In this tutorial, learn to troubleshoot networking issues on your Linux client system. Learn to:
Manually configure network interfaces, including viewing and changing the configuration of network interfaces using iproute2.Manually configure routing, including viewing and changing routing tables and setting the default route using iproute2.Debug problems associated with the network configuration.Recognize the legacy net-tools commands. Networking in Linux In today’s world, computer networking enables information sharing, research, and commerce across the country or across the world.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef79a5a8f393516681c473064288d34c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee7d552e619b04c300a274b3bb717ce/" rel="bookmark">
			微信小程序（企业客户服务功能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开发者在小程序管理后台申请使用插件，添加路径：设置 -&gt;第三方服务 -&gt; 插件管理 -&gt; 添加插件，搜索并添加插件ID： wx104a1a20c3f81ec2，无需审核确认。开发者在小程序app.json 文件中添加对插件的引用 "plugins": { "contactPlugin": { "version": "1.3.0", //使用最新版本 "provider": "wx104a1a20c3f81ec2" } } 开发者在具体引用插件的页面文件json文件中，添加对组件的引用， "usingComponents": { "cell": "plugin://contactPlugin/cell" } 开发者在引用插件的wxml文件中添加组件的具体代码，其中plugid为在企业微信管理后台配置的客服ID，将该ID作为参数传入组件 &lt;cell bind:startmessage='startmessage' bind:completemessage="completemessage" plugid='plugid' /&gt; 企业管理员可在“企业微信管理后台-客户联系”中完成「联系我」二维码和「联系我」按钮两种联系方式的创建和配置，从而建立企业成员与客户的连接。其中「联系我」按钮需要开发者做简单的开发配置，开发者可按以下文档说明完成配置「联系我」按钮到小程序的接入工作completemessage 回调接收的参数格式如下： errcode: 0, // 消息发送状态 name: '', // 推送的客服人员姓名 headurl: '' // 推送的客服人员头像 小程序版本的插件目前仅支持运行在微信的小程序环境中，企业微信环境暂不支持。插件扩展参数说明
效果如下
详细地址参考官方文档
https://work.weixin.qq.com/api/doc/90000/90136/93582 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f826e53ad6f5add210af39849374c93/" rel="bookmark">
			华为鸿蒙系统安装需要备份吗,想要安装华为鸿蒙系统是不是要更换手机呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：想要安装华为鸿蒙系统是不是要更换手机呢？
说到手机操作系统，除了已经歇菜了的Windows以及最早的诺基亚塞班系统，目前仅有自成一派的苹果iOS系统与谷歌的安卓系统。而我国拥有全世界最大的手机消费市场以及众多知名的手机厂商，却没有独立的操作系统，国内众多手机品牌都要依赖于谷歌的安卓系统。为了在智能手机和电脑业务中摆脱对谷歌或微软的依赖，华为宣布将会推出鸿蒙系统。
对于华为鸿蒙系统的即将推出，很多网友也是充满期待同时又充满着疑问。在即将迎来5G时代迎接5G手机，我们此前了解到了在5G时代要想使用5G网络我们就必须更换成5G手机，那么对于华为自主研发的鸿蒙系统，想要更新是否也需要更换手机呢？
答案是肯定的，据了解，华为鸿蒙操作系统目前只适用于华为手机，所以如果我们使用的手机是华为品牌的话，那么根据情况基本是不需要买新手机就能更换系统。
那么对于华为以外的安卓机来说，安装鸿蒙系统是否就需要更换新手机？从本质上来说，华为鸿蒙系统就是冲着替代安卓系统去的，所以鸿蒙系统是可以兼容全部的安卓应用和web。不过目前鸿蒙操作系统应该会只适用于华为手机，因为华为的麒麟处理器也是鸿蒙操作系统的一部分，其有部分基础是在这个处理器上的。所以即使ROOT、刷机其他手机品牌也无法使用鸿蒙系统。
此外，华为的鸿蒙系统将会比安卓系统更优越，使用起来不会比安卓系统来得卡，体验感会更佳。不同于安卓系统不能直接和系统的底层直接通信，需借助于虚拟机这个“二传手”，所以手机用久了就会觉得卡顿。而华为鸿蒙系统经方舟编译器的编译就可直接和系统底层进行通信，完全就不需要虚拟机这个所谓的“二传手”。与苹果的iOS系统一样直接为机器底层写代码，自然系统就会流畅许多。
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f010605f6843e3c6ad6e98b5c180fd/" rel="bookmark">
			Element ui 日期时间今天，昨天，近七天，等快捷选择及:default-time无效处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求描述：
项目里每月需要统计当月的一些数据，或者随时需要调取部分时间段的数据，用Element ui的日期时间控件来实现，如下图：
但为了便捷，就加入几个固定的时间快捷选项，因为数据库里的时间存储的是时间戳，所以前端查询需要给提供具体的时间段部分。
Element ui的DateTimePicker组件提供了个default-time属性，可以预设具体的时间，但这个属性有个问题，设置好以后，只能对在通过日历插件选择的日期有效，对快捷选项是无效。
我这里用一个方案，就是**setHours(0,0,0,0)**，然后再将其转换为时间对象。
二、解决问题知识点：
1.JavaScript Date 对象转化：
获取当前时间戳（13位）
new Date().getTime() //输出时间戳：1605871486784 时间戳转为时间对象函数
new Date(timestamp) 用法示例：
// 不写new获取的是当前时间 Date(1553323849459) //“Sat Mar 23 2019 14:58:21 GMT+0800 (中国标准时间)” // 写new可以将时间戳转换为时间对象 new Date(1553323849459) //Sat Mar 23 2019 14:50:49 GMT+0800 (中国标准时间) 2.JavaScript setHours() 方法
三、参考源码：
&lt;template&gt; &lt;div class="index-content"&gt; &lt;el-date-picker size="mini" :picker-options="pickerOptions" v-model="arr_date" @change="changeTime" type="datetimerange" range-separator="至" start-placeholder="开始时间" end-placeholder="结束时间" value-format="yyyy-MM-dd HH:mm:ss" :default-time="['00:00:00', '23:59:59']"&gt; &lt;/el-date-picker&gt; &lt;/div&gt; &lt;/template&gt; export default { data() { return { pickerOptions: { shortcuts: [ { text: '今天', onClick(picker) { // const end = new Date(); // const start = new Date(); // picker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5f010605f6843e3c6ad6e98b5c180fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b87c21d1643d89eec930eb6c5df54c9/" rel="bookmark">
			android textview伸缩,Android可收缩/扩展的TextView【2】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿
Android可收缩/扩展的TextView【2】
我写的可扩展/收缩的TextView：PhilExpandableTextView使用方法在附录文章1中已经说明。简单的使用，可以直接写在布局中，初始默认是收缩成3行(可修改继续定制)，当用户从触发expand事件后，PhilExpandableTextView将伸展成完全的行数。
PhilExpandableTextView在ListView一类的使用中，有些特殊，现在以PhilExpandableTextView在Android RecyclerView中的使用为例加以说明。
测试的主Activity MainActivity.java:
package zhangphil.text;
import java.util.ArrayList;
import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.LinearLayout;
public class MainActivity extends Activity {
private ArrayList flags;
private MyRecyclerViewAdapter adapter;
private String test_str = "";
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
// 测试的字符串
for (int i = 0; i &lt; 100; i++)
test_str = test_str + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b87c21d1643d89eec930eb6c5df54c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2153f789d7fce0ede4573db6d418aa/" rel="bookmark">
			《阳光劫匪》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《阳光劫匪》是由北京劳雷影业有限公司、华谊兄弟电影有限公司等出品的喜剧犯罪片，由李玉执导，马丽、宋佳、老虎文文领衔主演，张海宇、谢锐韬主演 。
该片改编自日本作家伊坂幸太郎的同名小说《阳光劫匪》，讲述了四个奇异青年组成“劫匪”团体，勇闯黑帮夺老虎的传奇冒险故事 [2] 。该片于2021年5月1日在中国上映 。
这个电影好像是改编自一个日本的小说，整个电影二倍速观看，昨天晚上开始看，现在刚刚看完。能感动我的东西比较少，感觉一般般吧，没有触碰到我的心灵。推荐的话就是不用看，没什么值得学习的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1681f0ea57793aed82b9379a793239/" rel="bookmark">
			windows下搭建sftp服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 系统没有sftp 服务，linux 下 sftp 默认安装，所以在windows下我们需要自己搭建sftp服务。
薅羊毛还是免费的香，我用的是：freeSSHd，免踩雷步骤
1、免费的安装包下载地址（选择1.3.1版本）：http://www.freesshd.com/?ctt=download
2、傻瓜式安装（默认装到C盘就可以）
3、安装完成后打开
4、选择Users标签，点击Add添加用户（用户名密码要选个能记住的），确定。
5、选择SSH标签，监听地址选本机IP，端口默认选择22，应用。
6、选择SFTP标签，选择服务器发布路径，应用。
7、选择Authentication标签，password要选Required，应用。
8、选择Server status标签，启动服务，应用。
9、测试连接文章：https://blog.csdn.net/weixin_45442296/article/details/117328712?spm=1001.2014.3001.5501
10、选择Online users标签查看连接
到这里我们就搭建完成了，可是还会遇到一些问题：
1、服务不能运行---杀掉服务进程，使用管理员权限运行
2、服务没有安装到C盘，看是否生成密钥文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10f69a068e518a8e5a038dc7470ba3c/" rel="bookmark">
			android failed to fetch url,已解决: Failed to fetch url - Intel Community
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello,
My code is:
intel.xdk.device.getRemoteData(app.url + 'some/url',"POST","some=data","success","error");
It works great in emulate tab, but if I build crosswalk for android or just android it doesnt work.
I've tried export app to chrome and check it console. This is what i get:
Uncaught ReferenceError: intel is not defined
Legacy hybrid mobile app build -&gt; Android make a build with this works, but resolution is too high and I cant see anything except a data is downloaded from external server successfully.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a10f69a068e518a8e5a038dc7470ba3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bf0006a685eca4a3a2441d356165303/" rel="bookmark">
			Android——Handler详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 Handler是一套 Android 消息传递机制,主要用于线程间通信。
用最简单的话描述： handler其实就是主线程在起了一个子线程，子线程运行并生成Message，Looper获取message并传递给Handler，Handler逐个获取子线程中的Message.
Binder/Socket用于进程间通信，而Handler消息机制用于同进程的线程间通信
可以说只要有异步线程与主线程通信的地方就一定会有 Handler。
在多线程的应用场景中，将工作线程中需更新UI的操作信息 传递到 UI主线程，从而实现 工作线程对UI的更新处理，最终实现异步消息的处理
使用Handler消息传递机制主要是为了多个线程并发更新UI的同时，保证线程安全
2. 相关概念解释 Handler、Message、Message Queue、Looper
Message ：代表一个行为what或者一串动作Runnable, 每一个消息在加入消息队列时,都有明确的目标Handler
ThreadLocal： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。ThreadLocal的作用是提供线程内的局部变量TLS,这种变量在线程的生命周期内起作用,每一个线程有他自己所属的值(线程隔离)
MessageQueue (C层与Java层都有实现) ：以队列的形式对外提供插入和删除的工作, 其内部结构是以双向链表的形式存储消息的
Looper (C层与Java层都有实现) ：Looper是循环的意思,它负责从消息队列中循环的取出消息然后把消息交给Handler处理
Handler ：消息的真正处理者, 具备获取消息、发送消息、处理消息、移除消息等功能
Android消息机制：
以Handler的sendMessage方法为例，当发送一个消息后，会将此消息加入消息队列MessageQueue中。Looper负责去遍历消息队列并且将队列中的消息分发给对应的Handler进行处理。在Handler的handleMessage方法中处理该消息，这就完成了一个消息的发送和处理过程。 Handler示意图：
消息机制的模型：
Message：需要传递的消息，可以传递数据；MessageQueue：消息队列，但是它的内部实现并不是用的队列，实际上是通过一个单链表的数据结构来维护消息列表，因为单链表在插入和删除上比较有优势。主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next)；Handler：消息辅助类，主要功能向消息池发送各种消息事件(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)；Looper：不断循环执行(Looper.loop)，从MessageQueue中读取消息，按分发机制将消息分发给目标处理者。 消息机制的架构
在子线程执行完耗时操作，当Handler发送消息时，将会调用 MessageQueue.enqueueMessage ，向消息队列中添加消息。当通过 Looper.loop 开启循环后，会不断地从线程池中读取消息，即调用 MessageQueue.next然后调用目标Handler（即发送该消息的Handler）的 dispatchMessage 方法传递消息，然后返回到Handler所在线程，目标Handler收到消息，调用 handleMessage 方法，接收消息，处理消息。 3. Handler 的基本使用 3.1 创建 Handler Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。
这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bf0006a685eca4a3a2441d356165303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6176ad62664cdb5cb37ae84b2bc1552b/" rel="bookmark">
			python实现有趣的emoji表情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编写代码的过程中加入一些有趣的操作，例如emoji表情包，可以极大地提升代码的友好度和趣味性！
Python 支持 emoji 表情的输出，实现方式相当简单。
有两种方式可以实现在python中输出emoji表情
1.python中的emoji库 安装第三方库emoji: pip install emoji，这种方式几乎支持所有的emoji表情
2.unicode编码方式 Unicode字符集：Unicode码位的取值范围是0x0至0x10ffff——这是十六进制数，等于十进制数0到1114111，新加入Unicode字符集的“颜文字”（Emoji）位于0x1f300~0x1f6ff区域。
欢迎大家转发，一起传播知识和正能量，帮助到更多人。辛苦大家转发时注明出处(也是咱们公益编程交流群的入口网址)：http://liujingwei.cn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76aa6ab004e8fb563da057daa0f154dd/" rel="bookmark">
			idea中调试Android,在Intellij IDEA中调试Android小部件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0
I wasn't able to reproduce the ANR. I'm using IntelliJ Idea 12, tried it with Android 4.1.2 and 2.3.3 emulators.
我无法重现ANR。我正在使用IntelliJ Idea 12,尝试使用Android 4.1.2和2.3.3模拟器。
But if you find that the Eclipse solution is working for you, there is a way to attach to a running process in IntelliJ's debugger as well. First you just "Run" the app, and then attach the debugger to it using these steps. I set a breakpoint in the onUpdate() method of the widget and it worked successfully.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76aa6ab004e8fb563da057daa0f154dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf6b899677074ade8f1e374e7a9ed677/" rel="bookmark">
			android 4.4 读写 sd卡权限,Android4.4下MediaProvider无法向外置SD卡中文件写数据的解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实例讲述了Android4.4下MediaProvider无法向外置SD卡中文件写数据的解决方法。分享给大家供大家参考，具体如下：
Android4.4平台限制应用对外置SD卡的读写权限。MediaProvider通过 checkAccess方法 限制对外置SD卡的读写。
private void checkAccess(Uri uri, File file, int modeBits) throws FileNotFoundException {
final boolean isWrite = (modeBits &amp; MODE_WRITE_ONLY) != 0;
final String path;
try {
path = file.getCanonicalPath();
} catch (IOException e) {
throw new IllegalArgumentException("Unable to resolve canonical path for " + file, e);
}
Context c = getContext();
boolean readGranted =
(c.checkCallingOrSelfUriPermission(uri, Intent.FLAG_GRANT_READ_URI_PERMISSION)
== PackageManager.PERMISSION_GRANTED);
if (path.startsWith(sExternalPath) || path.startsWith(sLegacyPath)) {
if (!readGranted) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf6b899677074ade8f1e374e7a9ed677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ab9403c00e2c1ffe40f3aad287bdb6/" rel="bookmark">
			android的handler使用方法,android中handler用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Handler的定义:
Handler主要接收子线程发送的数据, 并用此数据配合主线程更新UI，用来跟UI主线程交互用。比如可以用handler发送一个message，然后在handler的线程中来接收、处理该消息，以避免直接在UI主线程中处理事务导致影响UI主线程的其他处理工作，Android提供了Handler作为主线程和子线程的纽带；也可以将handler对象传给其他进程，以便在其他进程中通过handler给你发送事件；还可以通过handler的延时发送message，可以延时处理一些事务的处理。
通常情况下，当应用程序启动时，Android首先会开启一个主线程 (也就是UI线程) ,
主线程为管理界面中的UI控件，进行事件分发。如果此时需要一个耗时的操作，例如:联网读取数据，或者读取本地较大的一个文件的时候，你不能把这些操作放在主线程中，如果你放在主线程中的话，界面会出现假死现象,如果5秒钟还没有完成的话，会收到Android系统的一个错误提示"强制关闭".
这个时候我们需要把这些耗时的操作，放在一个子线程中,因为子线程涉及到UI更新，但是当子线程中有涉及到操作UI的操作时，就会对主线程产生危险，也就是说，更新UI只能在主线程中更新，在子线程中操作是危险的.
这个时候，Handler就出现了来解决这个复杂的问题，由于Handler运行在主线程中(UI线程中)，它与子线程可以通过Message对象来传递数据，这个时候，Handler就承担着接受子线程传过来的(子线程用sedMessage()方法传递)Message对象，(里面包含数据),
把这些消息放入主线程队列中，配合主线程进行更新UI。
二、Handler一些特点
handler可以分发Message对象和Runnable对象到主线程中,
每个Handler实例,都会绑定到创建他的线程中(一般是位于主线程), 也就是说Handler对象初始化后，就默认与对它初始化的进程的消息队列绑定，因此可以利用Handler所包含的消息队列，制定一些操作的顺序。
三、Handler中分发消息的一些方法
post(Runnable)
postAtTime(Runnable,long)
postDelayed(Runnable long)
post类方法允许你排列一个Runnable对象到主线程队列中
sendEmptyMessage(int)
sendMessage(Message)
sendMessageAtTime(Message,long)
sendMessageDelayed(Message,long)
sendMessage类方法, 允许你安排一个带数据的Message对象到队列中，等待更新.
四、应用实例：
1，传递Message。用于接受子线程发送的数据,
并用此数据配合主线程更新UI。
在Android中，对于UI的操作通常需要放在主线程中进行操作。如果在子线程中有关于UI的操作，那么就需要把数据消息作为一个Message对象发送到消息队列中，然后，用Handler中的handlerMessge方法处理传过来的数据信息，并操作UI。类sendMessage(Message msg)方法实现发送消息的操作。
在初始化Handler对象时重写的handleMessage方法来接收Messgae并进行相关操作。
2，传递Runnable对象。用于通过Handler绑定的消息队列，安排不同操作的执行顺序。
Handler对象在进行初始化的时候，会默认的自动绑定消息队列。利用类post方法，可以将Runnable对象发送到消息队列中，按照队列的机制按顺序执行不同的Runnable对象中的run方法。
另外，Android的CPU分配的最小单元是线程，Handler一般是在某个线程里创建的，因而Handler和Thread就是相互绑定的，一一对应。而Runnable是一个接口，Thread是Runnable的子类。所以说，他俩都算一个进程。
视频教程中的例子：
1.
public class HandlerActivity extends Activity {
2.
3.
//声明两个按钮控件
4.
private Button startButton = null;
5.
private Button endButton = null;
6.
@Override
7.
public void onCreate(Bundle savedInstanceState) {
8.
super.onCreate(savedInstanceState);
9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61ab9403c00e2c1ffe40f3aad287bdb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a76088dfe6979a1d8fef6c462296806b/" rel="bookmark">
			网关详细解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是网关 首先要明白，网关（Gateway）本质上不是一个产品而是一个网络层的概念，网关（Gateway）就是一个网络连接到另一个网络的“关口”。 计算机本身不具备路由寻址能力，所以计算机要把所有的 IP 包发送到一个默认的中转地址上面进行转发，也就是默认网关。这个网关可以在路由器上，可以在三层交换机上，可以在防火墙上，可以在服务器上，所以和物理的设备无关。
现实生活中，很多人也会把具有网关功能的设备称作是网关，比如路由器，这里要理解清楚。
按照不同的分类标准，网关也有很多种。TCP/IP 协议里的网关是最常用的，在这里我们所讲的“网关”均指 TCP/IP 协议下的网关。
网关实质上是一个网络通向其他网络的 IP 地址。
比如有网络 A 和网络 B，网络 A 的 IP 地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为 255.255.255.0；网络 B 的 IP 地址范围为“192.168.2.1~192.168.2.254”，子网掩码为 255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行 TCP/IP 通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP 协议也会根据子网掩码（255.255.255.0）与主机的 IP 地址作 “与” 运算的结果不同判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。
如果网络 A 中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络 B 的网关，网络 B 的网关再转发给网络 B 的某个主机。网络 A 向网络 B 转发数据包的过程。
所以说，只有设置好网关的 IP 地址，TCP/IP 协议才能实现不同网络之间的相互通信。那么这个 IP 地址是哪台机器的 IP 地址呢？网关的 IP 地址是具有路由功能的设备的 IP 地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。
2、默认网关 2.1 什么是默认网关 如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。
2.2 为什么默认网关最后一位总是 1？ 网关的 IP 必须要和局域网在同一网段，比如一个局域网网段为 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a76088dfe6979a1d8fef6c462296806b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d324eeb95accf061a1c1dd818f239c41/" rel="bookmark">
			多径信道的仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述： 无线信道的建模向来是移动无线通信系统理论中具有挑战性的难点，通常采用统计的方法进行信道建模，根据所研究信号在特定环境下的特性来选择不同的信道模型。目前，在OFDM系统的仿真中，涉及无线信道的仿真方法主要有以下几种：1) 设定延时和衰落幅度值，然后与信号相乘并求和，这是最简单的多径信道仿真；2) 设定各延迟路径的时延和功率，根据路径功率用高斯过程分别得到复抽头系数的实部和虚部，然后用复抽头系数与信号相乘并求和，这也是一种简化的仿真方式；3) 产生Rayleigh衰落因子，如MATLAB中的函数raylrnd产生rayleigh幅度衰落，再用衰落因子与信号相乘；4),用FIR滤波器模拟信道；5) 利用各系统级仿真工具中的现成多径模块，如MATLAB的Simulink, Agilent的ADS等等。
当OFDM系统中的宽带无线信道近似为慢衰落信道[8]时：假设信道的衰落足够慢，在一个OFDM符号周期内可认为是恒定值。在这种假设下可以采用上述前三种方法。如果基站、移动台和散射体都是固定的，信道可以看做是一个非时变的滤波器，因此可以采用上述第四种方式。上述前四种方法是粗略的模型，它们没有考虑实际中宽带无线通信信道的时变特性。上述第五种方法采用国外软件中的现成模块，模型比较精细，但是做仿真的时候因为不清楚模块是如何产生的，如果对模块中各种参数的定义理解不够准确，往往不能合理的设置系统参数，达到需要仿真的效果。
2.部分程序： 3.仿真结论： 下面是一条多径，衰弱为3db的情况：
下面是二条多径，衰弱为3db，6db的情况：
A-01-46
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316cc7974578767b8cc89f2bb4300504/" rel="bookmark">
			android fragment页面切换,CorePage(Android使用Fragment打造万能页面切换框架)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键思路：
1、BaseActivity作为fragment的容器，里面负责跳转入口openPage和gotoPage
openPage: 打开一个新的fragment，默认都addToBackStack
gotoPage: 跳转的之前打开过的fragment。在BaseActivity有一个栈，保存所有已打开过的activity，gotoPage就是遍历所有的activity，然后findFragmentByTag找到fragment，如果 没找到，就finish activity，继续下一个activity
2、每个Activity中的Fragment没有另外用一个集合管理，都交给了该activity
3、同一activity中的不同fragment间onFragmentResult实现：采用回调方式
//调用方式
openPageForResult("test2",bundle,CoreAnim.fade,requestCode);
//获取想要打开的Fragment实例
BaseFragment frg = (BaseFragment) CorePageManager.getInstance().openPageWithNewFragmentManager(getSupportFragmentManager(), pageName, bundle, animations, addToBackStack);
if (frg == null) {
return null;
}
final BaseFragment opener = fragment;
//设置requestCode和回调listener给想要打开的fragment，便于关闭时调用回调函数
frg.setRequestCode(page.getRequestCode());
frg.setFragmentFinishListener(new BaseFragment.OnFragmentFinishListener() {
@Override
public void onFragmentResult(int requestCode, int resultCode, Intent intent) {
//收到回调，调用原fragment的onFragmentResult方法
opener.onFragmentResult(requestCode, resultCode, intent);
}
});
//被打开界面中调用回调函数，
Intent intent=new Intent();
Bundle bundle=new Bundle();
bundle.putString("data","this is a result");
intent.putExtras(bundle);
setFragmentResult(500,intent);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316cc7974578767b8cc89f2bb4300504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e5ff668559e670ac699cb270e2ec894/" rel="bookmark">
			android 4.0 打开gps,Android获取定位权限，手动打开GPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取定位权限，并且在没有打开GPS的时候引导用户打开手机GPS定位。
超级简单的
private Button button;
private int GPS_REQUEST_CODE = 1;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
button = findViewById(R.id.open_gps);
button.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
openGPSSEtting();
}
});
}
private boolean checkGpsIsOpen() {
boolean isOpen;
LocationManager locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);
isOpen = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);
return isOpen;
}
private void openGPSSEtting() {
if (checkGpsIsOpen()){
Toast.makeText(this, "true", Toast.LENGTH_SHORT).show();
}else {
new AlertDialog.Builder(this).setTitle("open GPS")
.setMessage("go to open")
// 取消选项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e5ff668559e670ac699cb270e2ec894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a024546f8ae33437eaea69c3315de6c5/" rel="bookmark">
			杜比专为旧版本Android,杜比音效app(dolby audio) v2.1.0 安卓版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杜比音效(dolby audio)是有关于音频音效处理的应用工具，拥有强大的功能，不仅拥有无损高音质，还具有多设备兼容性，可以进行环绕声录制，能够带来用户高品质听感体验，让你无论是看视频还是听音乐都很清晰逼真。有需要的朋友可以来这里下载体验哦！
杜比音效app(dolby audio)简介：
杜比音效是一款可以对手机进行音效提升的工具，包括以下诸多技术：移动环绕声、音场扩展处理器、自然低音处理器、高频增益处理器、音频响度控制器、音色图形均衡器和扬声器均衡器。这些技术能够为移动设备带来冲击力十足的丰富音效。
杜比音效手机版特色：
1、杜比数字 (Dolby Digital) 技术是针对独立 5.1 声道电视广播的全球标准。
2、杜比音效 (Dolby Audio) 技术可在机顶盒、手机和平板电脑以及家用音频系统等设备中将采用杜比格式 (例如，广播节目中的杜比数字+ (Dolby Digital Plus) 技术或蓝光碟中的杜比 TrueHD (Dolby TrueHD) 技术)所灌制的内容与辅助回放技术进行整合。如此一来，无论您在何处以及通过何种方式来享受娱乐，均可实现始终如一的高品质听感体验。
3、杜比 TrueHD (Dolby TrueHD) 技术是一种“无损”格式，您所听到的每一“比特”音效均与其在电影音轨或演唱会录音室中所制作时的音效分毫厘不差。杜比 TrueHD (Dolby TrueHD) 技术提供多达 7.1 声道的独立环绕声音效。该技术尤其适用于蓝光碟并可完美补充蓝光所提供的高清视频。
4、杜比数字+ (Dolby Digital Plus) 技术专为带宽较小的应用(例如，广播、流式传输和移动应用)而开发。它可为从独立 7.1 声道到单声道的各类回放系统自动优化音效。
应用功能：
1、环绕声录制
5.1 声道视频录制使用智能手机的多个麦克风捕获 360° 音频，从左到右，从前到后，让您的视频片段能够强力唤醒激情时刻。
2、音质如水晶般清晰
您的视频音量大且音质清晰，同时对话清楚且细节逼真，让您喜爱的娱乐冲击力大增。
3、多设备兼容性
同步 AAC 2.0 立体声支持可确保您的片段能够在未采用杜比音效 (Dolby Audio) 技术的智能手机上播放，让您可以将自己的故事与全世界分享。
4、随时随地回放
您的视频、电影、电视节目和体育赛事在通过耳机、个人电脑或家庭影院的 5.1 环绕声回放时，能提供更令人愉悦的体验。
更新日志：
-功能更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42dd3ba8b6dd10977a8016503b8fb195/" rel="bookmark">
			android studio 使用git需要忽略.idea,android studio 新手入门教程（三）Github（ ignore忽略规则）的使用教程图解...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio 里集成了上传代码到 github 的功能，所以使用上还是很简单的，设置里添加账号并测试，之后就可以很方便地上传代码到 github 了
如果你的项目是使用Android Studio新建的，那么关于 github 基本就没什么问题了。Android Studio新建项目是自带 .ignore 文件的，也就是说默认是使用了忽略规则上传。默认忽略的是
*.iml
.gradle
/local.properties
/.idea/workspace.xml
/.idea/libraries
.DS_Store
/build
/captures
但是如果你的项目是之前从 eclipse 导入的，这里你就要注意了，按照上述操作，在 github 上新建项目后，在接下来的同步选项中，你会看到项目里的所有文件都会被上传，包括apk、iml、idea文件夹、gradle文件夹等。
很明显，我并不需要把每次编译就发生变动的文件(例如debug的apk文件)都上传，我需要有所忽略的上传，这也正是.ignore文件的作用。为了使用忽略规则，我拷贝了.ignore文件进项目，再重复上传操作，文件并没有起作用，后来进过一番探索，发现要这样操作：
1、移除已有的版本控制：
2、关闭Android Studio，进入项目的文件夹中删除 .git 文件夹(如果没有看到该文件夹请打开显示隐藏文件选项)
3、复制一份 .gitignore 文件到项目根目录(可使用 AS 新建项目，其根目录就有该文件，或使用插件.gitignore生成，插件在 AS 里搜索就有)附上我使用的忽略规则：
*.iml
.gradle
/local.properties
/.idea/workspace.xml
/.idea/libraries
.DS_Store
/build
/captures
# OSX
*.DS_Store
# Gradle files
build/
.gradle/
*/build/
# Intellij project files
*.iml
*.ipr
*.iws
.idea/
# Built application files
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42dd3ba8b6dd10977a8016503b8fb195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/360639807873e15312f8729dddb8717c/" rel="bookmark">
			android 音效下载地址,V4A&#43;Dolby Atmos安卓全局音效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是V4A+Dolby Atmos安卓全局音效，在论坛混了那么久，受益良多，是时候回报大家，今天隆重推荐一款安卓音效神器VIPERAtmos，由SDappStudio大神制作，综合了V4A和DolbyAtmos的优点，提供了无与伦比的现场效果，观看电影或打游戏时声音全四面八方扑面而来，让你如身历其境。
软件说明
安装要求：安卓系统已root，BusyBox已安装(理论上可装于安卓系统已root的手机、电视、电视盒)。
使用说明
1、安装为系统应用。用RE管理器复制到/system app下安装，赋予权限，启动APP，进入音效设置界面选择你想需要的效果(如果不能开机启动则下载一个自启动管理软件设置为开机启动)。
2、直接安装为第三方应用。方法简单，直接安装进入界面设置音效就行，不过不能开机自启动，每次开机后需手动启动APP后方可生效。
Ok! Have Fun and Happy New Year!
软件截图
相关软件
安卓7.1.1＆7通用蝰蛇音效卡刷包：这是安卓7.1.1＆7通用蝰蛇音效卡刷包，分享一个安卓7.1.1，理论安卓7通用的蝰蛇音效卡刷包，本人在r11s上完美使用，直接用第三方TWRP卡刷就可以了，不用双清，卡刷完直接重启就可以了！然后安装蝰蛇app就可以享受完美音质了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ff6dfbfb53a148fe03c11100049d51/" rel="bookmark">
			达梦数据库DBLINK初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、外部链接对象是什么 外部链接对象（LINK）是 DM 中的一种特殊的数据库实体对象，它记录了远程数据库的连接和路径信息，用于建立与远程数据的联系。通过多台数据库主库间的相互通讯，用户可以透明地操作远程数据库的数据，使应用程序看起来只有一个大型数据库。用户远程数据库中的数据请求，都被自动转换为网络请求，并在相应结点上实现相应的操作。用户可以建立一个数据库链接，以说明一个对象在远程数据库中的访问路径。这个链接可以是公用的（数据库中所有用户使用），也可以是私有的（只能被某个用户使用）。 用户可以通过外部链接对远程数据库的表进行查询和增删改操作，以及本地调用远程的存储过程。 二、如何创建外部连接对象 语法如下：
CREATE [OR REPLACE] [PUBLIC] LINK &lt;外部链接名&gt; CONNECT ['&lt;连接库类型&gt;'] WITH &lt; 登录名&gt; IDENTIFIED BY &lt;登录口令&gt; USING '&lt;外部连接串&gt;'; &lt;连接库类型&gt; ::= DAMENG | ORACLE | ODBC &lt;外部链接串&gt;::=&lt; DAMENG 外部链接串&gt;| &lt; ORACLE 外部链接串&gt; | &lt;ODBC 外部链接串&gt; &lt;DAMENG 外部链接串&gt;::=[&lt;连接类型&gt;;]&lt;服务器列表&gt; &lt;连接类型&gt;::= PRIMARY FIRST | STANDBY FIRST | PRIMARY ONLY | STANDBY ONLY &lt;服务器列表&gt;::=&lt;服务器地址&gt; | &lt;服务器地址&gt;{,&lt;服务器地址&gt;} &lt;服务器地址&gt;::=&lt;实例 IP 地址&gt;/&lt;实例端口号&gt; | &lt;MAL IP 地址&gt;/&lt;MAL 端口号&gt; | &lt;实例名&gt; &lt;ORACLE 外部链接串&gt;::= &lt;tsn_name&gt; |&lt;description&gt;|&lt;IP 地址&gt;/&lt;服务名&gt; &lt;description&gt;::=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST= &lt;IP 地址&gt;)(PORT=&lt;端口号&gt;)))(CONNECT_DATA=(SERVICE_NAME=&lt;服务名&gt;))) &lt;ODBC 外部链接串&gt;::= &lt;ODBC 数据源 DSN&gt; 参数说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68ff6dfbfb53a148fe03c11100049d51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10ed4acf36632aca39a2da62362e0305/" rel="bookmark">
			centos7.6下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://archive.kernel.org/centos-vault/7.6.1810/isos/x86_64/
https://www.centos.org/download/(官方网址)
http://man.linuxde.net/download/CentOS
http://mirrors.btte.net/centos/7/isos/x86_64/
http://mirrors.cn99.com/centos/7/isos/x86_64/
http://mirrors.sohu.com/centos/7/isos/x86_64/
http://mirrors.aliyun.com/centos/7/isos/x86_64/
http://centos.ustc.edu.cn/centos/7/isos/x86_64/
http://mirrors.neusoft.edu.cn/centos/7/isos/x86_64/
http://mirror.lzu.edu.cn/centos/7/isos/x86_64/
http://mirrors.163.com/centos/7/isos/x86_64/
http://ftp.sjtu.edu.cn/centos/7/isos/x86_64/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d1d9f3e4a5be0e26ab909641d19cdb/" rel="bookmark">
			linux cache写入失败,Linux下squid服务启动失败 无法写入cache.log Permissiondenied解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突然 squid 就启动不了了，打开 squid.out，发现报错：
WARNING: Cannot write log file: /var/log/squid/cache.log
/var/log/squid/cache.log: Permission denied
messages will be sent to 'stderr'.
关键字：Permission denied
Permission - 允许，批准
Denied - Deny过去式，拒绝
直接 cd 进入 /var/log/squid 目录，ls -l 查看当前权限
所有文件都属于 root:root，再返回上一级目录，看 squid 也是 root:root
先把权限还给 squid 吧
sudo chown -R squid.squid squid
然后设置访问权限
sudo chmod -R 770 squid
现在试试启动 squid
sudo service squid start
如果还是失败，打开 squid.out 文件看看，还是不是 Permission denied 的问题
接着返回到 squid 上一级目录，执行
sudo squid -NCd10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06d1d9f3e4a5be0e26ab909641d19cdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf8fbb73f1bbd564d51bb02d6a59c9c/" rel="bookmark">
			Spring Cloud Bus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud Bus 简介 Spring Cloud Bus 使用轻量级的消息代理来连接微服务架构中的各个服务，可以将其用于广播状态更改（例如配置中心配置更改）或其他管理指令，本文将对其用法进行详细介绍。
我们通常会使用消息代理来构建一个主题，然后把微服务架构中的所有服务都连接到这个主题上去，当我们向该主题发送消息时，所有订阅该主题的服务都会收到消息并进行消费。使用 Spring Cloud Bus 可以方便地构建起这套机制，所以 Spring Cloud Bus 又被称为消息总线。Spring Cloud
Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。目前 Spring Cloud Bus 支持两种消息代理：RabbitMQ 和 Kafka，下面以 RabbitMQ 为例来演示下使用Spring Cloud Bus 动态刷新配置的功能。
RabbitMQ的安装 安装Erlang，下载地址：http://erlang.org/download…
安装RabbitMQ，下载地址：https://dl.bintray.com/rabbitmq…
安装完成后，进入RabbitMQ安装目录下的sbin目录：
在RabbitMQ安装目录下的sbin目录的地址栏输入cmd并回车启动命令行，然后输入以下命令启动管理功能：
rabbitmq-plugins enable rabbitmq_management 访问地址查看是否安装成功：http://localhost:15672/
输入账号密码并登录：guest guest
动态刷新配置 使用 Spring Cloud Bus 动态刷新配置需要配合 Spring Cloud Config 一起使用，我们使用上一节中的config-server、config-client模块来演示下该功能。
给config-server添加消息总线支持 在pom.xml中添加相关依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 添加配置文件application-amqp.yml，主要是添加了RabbitMQ的配置及暴露了刷新配置的Actuator端点；
server: port: 8904 spring: application: name: config-server cloud: config: server: git: # 配置存储配置信息的Git仓库 uri: https://gitee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbf8fbb73f1bbd564d51bb02d6a59c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3f0485ac017be10c7ee54a9d29e7974/" rel="bookmark">
			相机和镜头选型需要注意哪些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 最近需要优于项目需求需要对工业相机和镜头进行选型，于是我就开启的学习相机之旅，虽然我一直在做机器视觉方向，但是我对相机的了解还是很少，我想正好趁这次机会好好学习一下。如果有错误的观点请指正。
一、相机相关的一些指标 1. 靶面尺寸 相机的靶面尺寸就是用于接收光信号的传感器的尺寸，业界规定在描述靶面尺寸时1英寸=16毫米（当然实际情况下1英寸=25.4mm）。相机的靶面尺寸是用靶面对角线的长度与16mm的比值表示的，如对角线为4mm的靶面尺寸为1/4”，然后根据4:3的长边短边比，利用勾股定理就可以计算出靶面的边长。在其他条件一致的情况下，相机的靶面尺寸越大则可获得的视野范围越大。
图1. 相机靶面尺寸
2. 像元尺寸 像元就是传感器上的感光单元，这些感光单元可以把光信号转换为电信号。如像元尺寸为4.8um*4.8um。像元有方形的也有长方形的。
3. 相机分辨率 分辨率就是相机的传感器上即感光靶面上横向和竖向各有多少个感光单元（像元）。当然“靶面尺寸”，“像元尺寸”和“分辨率”三者之间是有联系的，比如我们已经知道了“像元尺寸”和“分辨率”那么我们就可以直接计算出相机靶面的长和宽出来，如“分辨率”为2592*2048，“像元尺寸”为4.8um，那么靶面长=2596*0.0048=12.44mm，靶面宽=2048*0.0048= 9.83mm，这与在图1中靶面尺寸为1”的长边和宽边的长度有些出入，这主要是近似的缘故。
4. 镜头分辨率 什么是传递函数（又叫MTF），什么是极限空间分辨率 简单来说MTF是空间分辨率的一种表达方式，单位：线对/mm。每个光学或者光电成像器件都有各自的MTF，镜头有MTF，相机也有MTF。光学器件或者光电成像器件的MTF越好，或者MTF对应的空间截止频率越高，证明器件自身的空间分辨率越好，越能看清楚更小的细节。MTF对应的空间截止频率又叫极限空间分辨率。
镜头中的百万像素，二百万像素，五百万像素是指什么？ 其实，镜头中的百万像素，二百万像素，五百万像素同样是指镜头的空间分辨率，因为镜头必须配合相机使用，为了方便记忆镜头和相机的匹配关系，人们常采用对应的相机的分辨率来命名镜头，这种命名方式其实是不科学的，同时给新接触视觉系统的人带来很多误解，经常或机械的套用百万像素分辨率相机对应百万像素分辨率镜头，二百万像素分辨率相机对应二百万像素分辨率镜头，五百万像素分辨率相机对应五百万像素分辨率镜头。其实镜头与相机对应的不是相机本身的像素分辨率（像素数），而是各自的极限空间分辨率。按照目前公开的性能指标来说，百万像素镜头对应的极限空间分辨率为90线对/mm，二百万像素镜头对应的极限空间分辨率为110线对/mm，五百万像素镜头对应的极限空间分辨率为160线对/mm，因此百万像素镜头配合相机的极限空间分辨率必须低于90线对/mm， 二百万像素镜头配合相机的极限空间分辨率必须低于110线对/mm，五百万像素镜头配合相机的极限空间分辨率必须低于160线对/mm。而决定相机极限空间分辨率的并不是相机自身的像素分辨率，而是相机的单个像元尺寸大小。
相机的极限空间分辨率 相机的极限空间分辨率代表了相机能够分辨的空间最小细节，其计算公式可以理解为：1/(单个像元尺寸*2)，单位：线对/mm。为啥需要在像元尺寸上乘以2呢，这是因为，两个像元才对应一对黑白条，如下图所示。
图2. 两个像元对应一对黑白条
相机和镜头的配套原则 镜头的极限空间分辨率必须高于相机的极限空间分辨率，这样才能让相机实现最佳成像性能。
二、项目中如何根据实际需要选择合适的相机和镜头呢？ 1. 相机输出接口选择USB3.0还是GIGE千兆网 同等像素条件下，各种接口的总线其相机帧率是不一样的，一般来说Camera Link&gt;USB3&gt;GIGE&gt;1394B&gt;USB2,1394A。现在最快的是Camera Link总线，USB3的理论速度达到了5Gbps即640MB，实际表现来看，应该有80%的有效带宽，即有512M左右的总带宽可供实际传输，这样如果一个500万像素的相机，每幅图像5M，那么也可能达到100帧每秒，速度也非常快了。而对于GIGE千兆网相机，500万像素的相机，较快的可以做到23FPS。1394B的500万像素相机可以做到13FPS，USB2，1394A一般为5~6帧的样子。除了考虑两者的传输速率，还要考虑两者的工作距离，通常情况下USB3.0的工作距离为5米以内，GIGE千兆网接口的工作距离为100米以内。根据下表对比USB3.0和GIGE接口的特点选择适合自己的接口形式。
表1. USB3.0和GIGE对比
带宽
理论下载速度
实际下载速度
500万图像传输帧率
优点
缺点
USB3.0接口
5Gbps
640MB
约512MB
约100fps
1. 帧率高
2. 不需要单独供电
1. 工作距离近，通常在5m内。
2. 占用CPU内存。
3.电脑端无卡扣容易被扯掉
GIGE接口
1KMbps
128MB
约100MB
约20fps
1. 传输距离远，通常在100m以内。
2. 不占用CPU内存。
3. 两头有卡扣，确保连接稳定。
1. 帧率没有USB3.0高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3f0485ac017be10c7ee54a9d29e7974/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3472a2f52ad473b078cc6c6f8edd82d2/" rel="bookmark">
			华为p8升级android8系统资源,华为鸿蒙系统已陆续推送! 安卓系统可无缝升级: 升级包容量高达6GB...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：华为鸿蒙系统已陆续推送! 安卓系统可无缝升级: 升级包容量高达6GB
相信大家都知道，自从华为手机业务遭受到芯片断供危机以后，也是直接将会把重点放在软件系统层面，很多花粉们都纷纷期待，华为鸿蒙OS系统早日转正的一天，而华为终端CEO余承东表示：“华为鸿蒙OS系统将会在四月份迎来首次推送升级，而华为Mate X2系列手机将会成为首批升级机型”；而华为鸿蒙OS系统负责人王成录也表示，在2021年将会有超过1亿台华为手机，可升级至最新鸿蒙OS系统，并且华为将会依靠鸿蒙OS系统来硬扛华为手机2-3年的硬件停滞期，帮助华为手机渡过这次“缺芯”危机；
而就在近日， 华为鸿蒙OS系统也是再次迎来了批量推送升级，正式开启全面公测，并且已经有超过十多款华为手机可以升级至最新鸿蒙OS系统，虽然华为官方还没有明确鸿蒙OS系统正式转正时间，但从华为鸿蒙OS系统内测版本情况来看，目前华为鸿蒙OS系统已经推出了3个内测版本，而根据最新鸿蒙OS系统用户反馈，在升级了鸿蒙OS系统最直观感受，就是华为鸿蒙OS系统占用硬件资源极少，据不少网友晒出的鸿蒙系统截图可以看到，一部内存8G的手机在使用了鸿蒙系统后占用仅1G多，所以即便是配置较低的华为手机， 也可以体验到极致的流畅度，就连很多APP应用运行速度都快了不少，这无疑也是直接提高了华为老款手机的使用寿命，进一步挽留华为手机用户继续使用华为手机，而不是更换其他品牌的手机，但对于很多花粉们而言，到底有哪些老旧机型可以升级至鸿蒙OS系统呢？
目前很多升级了鸿蒙OS系统用户，都纷纷晒出了截图，其中显示鸿蒙OS系统OTA升级包容量更是高达6GB，并且在从Android系统切换至鸿蒙OS系统只有，是不需要清空手机中的内部数据，联系人、短信等数据都可以全面转移至最新鸿蒙OS系统，不会给用户造成任何的困扰。
当然这次华为鸿蒙OS系统全面公测以后，在系统UI、交互方式方面也给予了改进，但相对于基于Android底层的EMUI系统，也是没有太大的改变，并且首款出厂预装鸿蒙OS系统的华为手机也遭到了曝光，这款新机为华为Mate40 Pro 4G版，整体配置并没有任何变化，处理器依旧还是麒麟9000，硬件方面的唯一区别就是这款新机并不支持5G网络，最高只支持4G网络；
最后：华为鸿蒙OS系统已经开启全面公测了，各位花粉们，你们升级了吗？欢迎在评论区中留言讨论，期待你们的精彩评论！返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60607ec99e4aa31ddbcb26c08b3641e4/" rel="bookmark">
			modbus总线协议（三）modbus tcp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍
modbus tcp是用于以太网的数据帧，比如和用网口和plc通信的时候就可以选择用modbus tcp。
二、modbus tcp协议详解
1、模式
和rtu一样，master和slave模式，master是主机，slave是从机，一个总线网络只能有一个主机，多个从机，一般作为边缘网关的时候边缘网关会建一个master和底下的从通信，然后建一个slave和云平台通信
注意：Modbus服务器默认端口 502 通信端口，在Modbus客户器程序中设置任意通信端口
2、协议描述
MBAP+PDU
（1）MBAP部分
事务处理标识 ：简单理解报文的序列号，每次通信之后就要加1以区别不同的通信数据报文
协议标识符 ：00 00 ModbusTCP协议
长度 ：接下来的数据长度，单位字节
单元标识符 ：简单理解设备地址
（2）PDU部分
功能码：
（1）标准功能01~21，以下为常用标准功能
01 (0x01) 读线圈 02 (0x02) 读离散量输入 03 (0x03) 读保持寄存器 04(0x04) 读输入寄存器 05 (0x05) 写单个线圈 06 (0x06) 写单个寄存器 15 (0x0F) 写多个线圈 16 (0x10) 写多个寄存器 （2）拓展功能备用，22~64
（3）用户功能，65~72
（4）非法功能，73~119
（5）内部使用保留，120~127
（6）异常应答保留，128~255
例如读取保持寄存器：
请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）
响应：MBAP 功能码 数据长度 寄存器数据(长度：9+寄存器数量×2)
00 01 00 00 00 06 01 03 00 00 00 03
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60607ec99e4aa31ddbcb26c08b3641e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94eac03935beef590bcac2ae6c85140/" rel="bookmark">
			android访问win10共享,android访问win10共享文件怎么操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多用户使用的手机都是android系统，同时也能够将一些文件传输到win10电脑中来，但是对于win10电脑中设置好的共享文件，有些用户却不知道该如何访问了，导致需要重新传输，那么android手机如何访问win10共享文件呢？下面小编就来教大家android访问win10共享文件操作方法。
具体方法：
第一步、在你要共享的文件夹上点右键然后再点【共享】---【特定用户】
第二步、在这里选择一个要添加的用户或是组。点击【添加】
第三步、添加你想共享的用户名，如果向所有的用户开放则需要添加【Everyone】这个用户。据需要调整权限级别。
第四步、创建完成，如果局域网的其它的计算机要访问这台电脑的共享文件夹则可以//加计算机名加共享文件夹名称就可以访问了。
第五步、通过建立共享文件夹，用户之间的数据传输和共享将会变得更加的方便，因此，如果你是企业用户的话，赶紧为自己和同事建立一个共享文件夹吧。
安桌和WINDOWS 不是一个共用平台，除非你用windows 手机如P8等通过设置都可以。所以要达到以上的要求就必须要进行第三方工具的使用操作才能完成。
以上就是关于android访问win10共享文件操作方法了，还有不清楚的用户就可以参考一下小编的步骤进行操作，希望能够对大家有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62cc22df98390365cfe43f9b7c7bc55a/" rel="bookmark">
			超好用的网站克隆工具，就是玩！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTrack是一个免费的网站克隆工具。它允许您将Internet上的万维网站点下载到本地目录，以递归方式构建所有目录，并从服务器到计算机获取HTML，图像和其他文件。HTTrack安排原始站点的相对链接结构。只需在浏览器中打开“镜像”网站的页面，就可以从一个链接到另一个链接浏览该网站，就像您正在在线查看它一样。HTTrack还可以更新现有的镜像站点，并恢复中断的下载。HTTrack是完全可配置的，并且具有集成的帮助系统。
安装HTTrack
apt-get更新 sudo apt-get updatekali安装HTTrack sudoapt-get install httrack webhttrack 运行HTTrack
安装成功执行 webhttrack命令。浏览器输入http://localhost:8080打开如下页面。 网站克隆
克隆百度的搜索页面
输入完成之后，一直next即可。最后克隆的网站预览。
哎，就是玩！
可能对于刚刚接触html的同学有用吧，可以更方便的学习人家的编码技巧,希望对你们有用。
官网地址：http://www.httrack.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bedb2ba5e2a2b1c8fda413514c08e7/" rel="bookmark">
			Co Attention注意力机制实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“Hierarchical Question-Image Co-Attention for Visual Question Answering”中的图像和文本间的Co Attention协同注意力实现
参考：
https://github.com/SkyOL5/VQA-CoAttention/blob/master/coatt/coattention_net.py
https://github.com/Zhangtd/Models-reproducing/blob/master/NIPS2016/selfDef.py
Co Attention示意图如下：
有两种实现方式，分别为Parallel co-attention mechanism和Alternating co-attention mechanism
基于PyTorch实现Parallel co-attention mechanism，代码如下：
from typing import Dict, Optional import numpy as np import torch.nn as nn import torch import torch.nn.functional as F from torch import Tensor def create_src_lengths_mask( batch_size: int, src_lengths: Tensor, max_src_len: Optional[int] = None ): """ Generate boolean mask to prevent attention beyond the end of source Inputs: batch_size : int src_lengths : [batch_size] of sentence lengths max_src_len: Optionally override max_src_len for the mask Outputs: [batch_size, max_src_len] "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bedb2ba5e2a2b1c8fda413514c08e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c25d4a62d809fb1abae18e0ad6fd50e/" rel="bookmark">
			kubeadm 部署 Kubernetes 集群（长文预警）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8s 集群部署 v1.7.2（kubeadm） 一般常用的k8s集群的部署方式有两种：
通过批量工具（ansible/saltstack）部署
这类部署方式的可控性强，方便后期的维护和管理；
生产环境的k8s集群建议采用这种方式部署。通过k8s自己的kubeadm工具进行部署
优点是实现起来相对简单；
缺点是很多操作kubeadm都替你执行了，它做了什么你很难知道，在后期需要维护时会有些麻烦。
这种方式可以用于测试k8s环境的搭建，生产中还是可控性强些比较好。 本次部署k8s-1.17.2，之所以不安装最新版本，是因为之后还要进行k8s集群升级的实验。
一：环境准备 1.1：服务器 一个最基础的高可用k8s集群环境需要以下几个部分：
一套负载均衡：实现k8s管理端的高可用，以及node节点级别的业务负载均衡至少3台master节点：3台master节点可以容错1台master节点的故障若干个node节点：整个k8s集群中最需要高配置服务器的地方。私有Docker镜像仓库：用于存储内部业务镜像和常用基础镜像。 本次准备的实验环境：
角色/hostname物理网络 IP 地址配置系统master1192.168.1.1012c-2g-50GUbuntu 1804master2192.168.1.1022c-2g-50GUbuntu 1804master3192.168.1.1032c-2g-50GUbuntu 1804lb1192.168.1.1041c-1g-20GUbuntu 1804lb2192.168.1.1051c-1g-20GUbuntu 1804harbor192.168.1.1061c-2g-100GUbuntu 1804node1192.168.1.1074c-4g-100GUbuntu 1804node2192.168.1.1084c-4g-100GUbuntu 1804 所有服务器均安装必要的工具、设置好主机名、配置内核参数和资源限制参数，需要特别注意的是：
时间一定要同步；主机名设置后，后期不得更改；将k8s的master节点和node节点的swap都禁掉，或者在装系统时就不要分配swap了。 具体的服务器初始准备可以参考博客《centos系统初始化》以及《ubuntu系统初始化》。
1.2：网络规划 物理网络不用赘述，在k8s集群中要规划好两个网络：
Pod网络：用于为Pod分配IP
网段可以划分得大一些，足够pod使用。Service网络：用于为Service分配IP
相对pod网络，service网络可以划得小一些，service的数量相较pod要少很多。 本次的规划：
网络类型网段物理网络192.168.1.0/24Service网络172.16.0.0/20Pod网络10.10.0.0/16 二：搭建负载均衡 角色/hostname物理网络 IP 地址配置系统lb1192.168.1.1041c-1g-20GUbuntu 1804lb2192.168.1.1051c-1g-20GUbuntu 1804 通过Haproxy+Keepalived的方式实现高可用负载均衡。
2.1：Keepalived 配置 将lb1设置为MASTER，lb2设置为BACKUP，添加vip 192.168.1.248，用于k8s集群管理端的访问入口。
lb1：
vrrp_instance VIP { state MASTER interface eth0 garp_master_delay 10 smtp_alert virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c25d4a62d809fb1abae18e0ad6fd50e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6f97475fc36bfef007ee7854d9e904/" rel="bookmark">
			android动画框架,GitHub - azhengyongqin/CustomAnimationFramework: Android自定义曲线路径动画框架...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android自定义曲线路径动画框架
最近在一个项目中需要一个像QQ打开个人爱好那样的动画效果如下图:
可以看出每个小球都是以顺时针旋转出来的,说明像这样的曲线动画用Android中自带的平移动画是很难实现的。
曲线动画怎么画???
我们先来看看Android自带的绘制曲线的方式是怎样的:
android自定义View中path经常用到函数
1、moveTo
moveTo 不会进行绘制，只用于移动移动画笔,也就是确定绘制的起始坐标点。结合以下方法进行使用。
2、lineTo
lineTo 用于进行直线绘制
mPath.lineTo(300, 300);
canvas.drawPath(mPath, mPaint);
默认从坐标(0,0)开始绘制。如图：
把画笔移动(100,100)处开始绘制
mPath.moveTo(100, 100);
mPath.lineTo(300, 300);
canvas.drawPath(mPath, mPaint);
效果如图：
3、quadTo
quadTo() 用于绘制圆滑曲线，即贝塞尔曲线。
4、cubicTo
cubicTo() 同样是用来实现贝塞尔曲线的。mPath.cubicTo(x1, y1, x2, y2, x3, y3) (x1,y1) 为控制点，(x2,y2)为控制点，(x3,y3) 为结束点。那么，cubicTo 和 quadTo 有什么不一样呢？说白了，就是多了一个控制点而已。然后，我们想绘制和上一个一样的曲线，应该怎么写呢？
mPath.moveTo(100, 500);
mPath.cubicTo(100, 500, 300, 100, 600, 500);
看看效果：
一模一样！如果我们不加 moveTo() 呢？
则以(0,0)为起点，(100,500)和(300,100)为控制点绘制贝塞尔曲线：
受到上面的启发,我们也可以用同样的方法来实现一个曲线动画框架
在写框架之前我们必须要先了解一样东西:
贝塞尔曲线:
维基百科中这样说到:
在数学的数值分析领域中，贝塞尔曲线(英语：Bézier curve)是计算机图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。 ###
贝塞尔曲线于1962年，由法国工程师皮埃尔·贝塞尔(Pierre Bézier)所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝塞尔曲线。
1、线性贝塞尔曲线
给定点P0、P1，线性贝塞尔曲线只是一条两点之间的直线。这条线由下式给出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6f97475fc36bfef007ee7854d9e904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9f0186e1d5a6e8982c82961fe05829/" rel="bookmark">
			python 保留浮点数为两位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要有三种： Tips: round的计算不是简单地四舍五入，一般如果对精度有要求，不推荐用round（如果是numpy ndarray,还可以用np.around(x,2)）
另外，python不支持浮点数float小数点填充"0":
所以在某些场景下，需要保留确定位数显示小数的话，只能使用字符串格式化的方法：
参考： https://www.cnblogs.com/zhzhlong/p/10732218.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c620239f784c37c6d6dbad75a38a37d/" rel="bookmark">
			ground android 百度地图 bitmap 太大,Android 百度地图覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处：http://blog.csdn.net/tanzuai/article/details/43833125
本篇博客要实现的功能
先上效果图：
上面就是我们最终要实现的效果
1.首先我们来介绍下要实现的功能：
A.更改坐标的位置
B.更改坐标的图标
C.删除图标
D.坐标每隔一段时间变动一次
clear.覆盖物的清楚
2.下面我们通过实例，一一的解析上面的功能
2.1首先我们初始化要用到的变量
/**
* MapView 是地图主控件
*/
private MapView mMapView;
/**
* 百度地图
*/
private BaiduMap mBaiduMap;
/**
* Marker表示为标记
*/
private Marker mMarkerA;
private Marker mMarkerB;
private Marker mMarkerC;
private Marker mMarkerD;
//private Marker mMarkerE;
/**
* 信息窗
*/
private InfoWindow mInfoWindow;
/**
* 初始化全局 bitmap 信息，不用时及时 recycle
*/
private BitmapDescriptor bdA;
private BitmapDescriptor bdB;
private BitmapDescriptor bdC;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c620239f784c37c6d6dbad75a38a37d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f2f55f0ae5cd757571be3ef19786b7/" rel="bookmark">
			QML | 实现一个转圈等待控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中需要一个转圈等待，就自己实现了一个Rotatingwait，-----------------------后来发现QML有自带的一个等待指示器BusyIndicator(/ㄒoㄒ/)
//RotatingWait.qml import QtQuick 2.7 import QtGraphicalEffects 1.0 Item { Rectangle { id: rect width: parent.width height: parent.height color: Qt.rgba(0, 0, 0, 0) radius: width / 2 border.width: width / 6 //设置边框，看起来是一个圆环 visible: false } //旋转的渐变色，效果是圆环外部看起来转动的颜色变化 ConicalGradient { width: rect.width height: rect.height gradient: Gradient { GradientStop { position: 0.0; color: "#687698" } GradientStop { position: 1.0; color: "#37415F" } } source: rect //渐变色作用范围 //边框中的一个圆形， 可以看成旋转的头部 Rectangle { anchors.top: parent.top anchors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35f2f55f0ae5cd757571be3ef19786b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/611d08c651b0905cef8bbd6c8377b84f/" rel="bookmark">
			android开启手机gps定位,如何让安卓手机GPS定位加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开RE管理器，进入目录/system/etc，找到文件"gps。conf"在RE管理器的右上角点击"挂载为读/写"长按文件"gps。conf"，选择"用文本编辑器打开"分为两类型用户分别替换成如下：
【电信2G或3G完美使用版配置】：
NTP_SERVER=cn。pool。ntp。org
XTRA_SERVER_1=http://xtra2。gpsonextra。net/xtra。bin
XTRA_SERVER_2=http://xtra1。gpsonextra。net/xtra。bin
XTRA_SERVER_3=http://xtra3。gpsonextra。net/xtra。bin
SUPL_HOST=suplcn。sirf。com
SUPL_PORT=7275
PPP1_ID=ctwap@mycdma。cn
PPP1_PW=vnet。mobi
【移动和联通使用版配置】：
NTP_SERVER=cn。pool。ntp。org
XTRA_SERVER_1=http://xtra2。gpsonextra。net/xtra。bin
XTRA_SERVER_2=http://xtra1。gpsonextra。net/xtra。bin
XTRA_SERVER_3=http://xtra3。gpsonextra。net/xtra。bin
SUPL_HOST=suplcn。sirf。com
SUPL_PORT=7275
最后，修改好点击“保存并退出”。
此时，RE管理器会自动生成一个"gps。conf.bak",不要先急着删了他哦！！必要时我们就靠他来还原了！如果还是不太放心的童鞋，可以在修改之前先备份一个到你的SDcard，那就万无一失了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb618487f3b2546fbab6231b13c0044/" rel="bookmark">
			android studio arr包类导入不成功,android studio aar包引用 报NoClassDefFounderror.以module形式就可以完美运行，为什么？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		02-23 14:45:27.576 19788-19816/com.ifeimo.l.im E/AndroidRuntime: FATAL EXCEPTION: Thread-3341
Process: com.ifeimo.l.im, PID: 19788
java.lang.NoClassDefFoundError: com.ifeimo.im.framwork.IMConnectManager
at com.ifeimo.im.framwork.IMSdk.addLoginCallBack(IMSdk.java:132)
at com.ifeimo.im.framwork.IMSdk.Login(IMSdk.java:81)
at com.ifeimo.l.im.Navigaimen.createMuccChat(Navigaimen.java:34)
at com.ifeimo.l.im.Navigaimen.access$000(Navigaimen.java:13)
at com.ifeimo.l.im.Navigaimen$1.run(Navigaimen.java:27)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0f8fc9a7429b524fb1a1bf7b01bae4/" rel="bookmark">
			android webview常见问题,android webview常见问题以及性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.webview导致内存泄露问题
使用 WebView 的时候，不在 XML 里面声明，而是在代码中直接 new 出来，传入 application context 来防止 activity 引用被滥用
WebView webView = new WebView(getContext().getApplicationContext());
webFrameLayout.addView(webView,0);
在activity的ondestory的时候需要做一下操作
if (mWebView != null) {
mWebView.stopLoading();//再次打开页面时，若界面没有消亡，会导致进度条不显示并且界面崩溃
mWebView.onPause();
mWebView.clearCache(true)
mWebView.clearHistory();
mWebView.removeAllViews();
mWebView.destroyDrawingCache();
ViewGroup parent = (ViewGroup) mWebView.getParent();
if (parent != null) {
parent.removeView(mWebView);
}
mWebView.removeAllViews();
mWebView.destroy();//这句由于有些在其他线程还没有结束，会导致空指针异常导致没办法使用
mWebView = null;
}
这里面有个需要特别注意的地方就是如果你在调用webview.destory();的时候，如果webview里面还有别的线程在操作，就会导致当前这个webview为空。这时候我们需要结束相应线程。例如我们项目中有一个广告拦截是通过在
public void onPageFinished(final WebView view, String url)
里面启用一个runnable去执行一串的js脚本，如果用户在你脚本没执行完成的时候就关闭了当前界面，系统就会抛出空指针异常。这时候就需要通过去onPageFinished获取webview对象，封装成以下方法
public void stopJsLoad(){
if (mWebView != null) {
mWebView.removeCallbacks(runnable);
runnable = null;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd0f8fc9a7429b524fb1a1bf7b01bae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f50cade2bec0635b9339ade18aacee/" rel="bookmark">
			64码高清电视 android版,电视果app下载-电视果客户端v6.12.0.64 安卓版-腾牛安卓网...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电视果app是一个手机投屏软件，可以将几十种视频APP的内容投屏到电视大屏上，无需电视会员，手机能看的，就能大屏观看。
应用信息：
电视果是一款连接手机与电视的智能设备，带来“手机内容电视看”的大屏高清观影体验。
电视果支持爱奇艺、腾讯、优酷、哔哩哔哩、AcFun、百度网盘等几十种视频APP的一键投屏，只要手机能看的内容，无需电视会员，也可大屏观看。
电视果APP——让电视果更好用的手机投屏APP。
功能特点：
- 手机快捷遥控
无论是锁屏、通知中心还是3D touch，借助iPhone的小控件(Widget)，都可以非常便捷的遥控电视果，比电视遥控快半秒。
- 海量搜索片库
海量视频资源，都是你的家庭片库，一键搜索，轻松投屏。
- 丰富辅助功能
不仅仅是在线视频，本地视频、文档、照片、音乐APP都可以分享至电视，畅享大屏体验。
- 追踪热点内容
为您呈现热点韩剧、新鲜出炉的奥斯卡影单、微博热议豆瓣高分的影视节目，紧跟实时剧集，专治“今晚看什么”。
电视果，陪你一起，用手机玩电视。微信号：TV-GUO
更新内容：
1. 电视果播放时，可通过锁屏遥控快捷控制电视果哦！
2. 电视果APP连Wi-Fi体验优化。
3. 修复了部分线上偶现的问题。
版本记录
2021-02-02版本: 6.12.0.64
1. 新增收藏功能，可以同步爱奇艺收藏夹中的视频2. 新增隐私菜单，强化隐私保护3. 优化了第三方来源视频的投屏和展示逻辑
2020-09-27版本: 6.9.1.3
1. 支持给电视果设置0.5倍速播放了；
2. 修复了遥控器浮层遮挡页面等显示问题及一些偶现的bug。
2020-08-28版本: 6.9.0.39
1. 详情页新增“摇一摇”趣味投屏
2. 优化APP启动时间
2020-07-17版本: 6.8.1.38
1. 投屏列表功能上线啦！为电视果自定义连播内容，解放你的手机；
2. 电视剧/电影/少儿/动漫频道新增热门内容标签；
3. 修复其他线上偶现的问题。
2020-06-23版本: 6.8.0.12
1. 支持为 5S/5S PLUS 添加和管理蓝牙外设(电视果ROM 升级到6.8.0)
2. 支持爱奇艺星钻会员投屏星钻影院全片
3. 其他 bug 修复
展开 +
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77f50cade2bec0635b9339ade18aacee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd912d3ccc3989afcf38b83167d10005/" rel="bookmark">
			64码高清电视 android版,64体育app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		64体育直播官方版是款简单好用的手机比赛观看软件，通过我们的快捷下载用户们就能在手机上对各种比赛和球赛进行最新观看。超快速度完全免费，良心无比的观看体验等待着大家前去使用，喜欢的朋友不妨速速下载吧
软件介绍
64体育直播官方版是一款由腾讯推出的NBA英超中超直播和社区，在社区你可以与球星直接面对面对话、与球友开心斗嘴、与专家意见领袖热烈讨论此外还有超多高频率的社区线上线下活动让你拿奖拿到手抽筋！
软件特色
NBA独家直播
NBA新赛季，每天至少三场视频直播，只在腾讯体育
全赛程直播点播
涵盖NBA、英超、欧冠等十余项赛事，最全面的视频直播与点播
体育社区
体育球迷的专属社区，在这里能寻找到更多同阵营小伙伴
互动竞猜
边看边聊边竞猜，丰富互动玩法high翻天更有惊喜大奖抽不停
软件功能
1.好玩，是因为这里有非常多的球友们和你一起吐槽、玩弹幕、上道具、竞猜赢大奖。请快来加入！和朋友们一起做喜欢的事。
2.好看，是因为App在手，“天下我有”！每赛季600场NBA比赛、足球五大联赛以及欧冠，世界杯，F1，电子竞技......24小时经典比赛随时随地让你high起来。
最新更新
1.社区新增荣誉榜，每月打榜奖不停！
2.赛前也可以参与竞猜啦，看看谁是预言帝！
3.英超增加付费视频直播外链，土豪请关注！
4.比赛直播流畅极致体验；
5.比赛互动全面升级，实时竞猜、聊天互动，大奖不停歇
6.社区产品，让你找到同好，和各路大神球星一起分享运动的快乐
7.600场NBA独家视频资源，英超、中超独播资源，让你全年爽不停
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af266e6eed7e416b8807b0733b4b138/" rel="bookmark">
			64码高清电视 android版,爱直播tv版-爱直播v4.7.64 安卓智能电视版__西西安卓tv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爱直播tv版是一款安卓智能盒子上的播放直播应用，让观众体验到免费看电视台的快乐，尽享天伦之乐。
简介：
主要是提供了央视和各省卫视的电视节目，多数为高清节目源，稳定流畅，全面支持遥控器操作，适合在OTT盒子和智能电视上面使用，联通线路尤为稳定。
更新日志：
爱直播v4.7.61版
1.添加收藏功能和设置项；
2.优化响应速度，提高使用体验；
3.添加高清节目源，清晰稳定。
爱直播v4.7.22版更新内容
1：添加收藏功能和设置项；
2：优化响应速度，提高使用体验；
3：添加高清节目源，清晰稳定。
爱直播v4.2.02版更新内容
1.优化应用响应速度，提高使用体验；
2.更新优质节目源，清晰稳定；
3.修复小米盒子上面播放黑屏问题。
爱直播v4.2.01版更新内容
更新日志：
1.优化应用响应速度，提高使用体验；
2.更新优质节目源，清晰稳定；
3.修复小米盒子上面播放黑屏问题。
爱直播V4.1.01 TV版更新内容
更新日志：
1：优化应用响应速度，提高使用体验；
2：更新优质节目源，清晰稳定；
3：修复小米盒子上面播放黑屏问题。
爱直播V4.0.10 TV版更新内容
更新日志：
1：优化应用响应速度，提高使用体验；
2：更新优质节目源，清晰稳定；
3：修复小米盒子上面播放黑屏问题。
爱直播V4.0.08 TV版更新内容
更新日志：
1：优化应用响应速度，提高使用体验；
2：更新优质节目源，清晰稳定；
3：修复小米盒子上面播放黑屏问题。
爱直播V4.0.06 TV版更新内容
更新日志：
1：优化应用响应速度，提高使用体验；
2：更新优质节目源，清晰稳定；
3：修复小米盒子上面播放黑屏问题。
爱直播V4.0.04 TV版更新内容
更新日志：
1：优化应用响应速度，提高使用体验；
2：更新优质节目源，清晰稳定；
3：修复小米盒子上面播放黑屏问题。
V3.0.25 TV版更新内容
1：优化应用响应速度，提高使用体验；
2：更新优质节目源，清晰稳定；
3：修复小米盒子上面播放黑屏问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468bc7ef37c364c6ddd83517440b2e79/" rel="bookmark">
			android 低电量,如何在Android设备中模拟低电量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下,模拟低电量是不知道的(如果您使用eclipse作为im).
但是如果你在linux中,你可以使用telnet连接到本地主机模拟器并执行’Power’动作(没有使用它们也许你可以试试)
http://handycodeworks.com/?p=46
但你不必经过这个过程.只需注册ACTION_BATTERY_LOW的广播接收器,并保证在低电量情况下被调用.
希望它有帮助
编辑：
这是直接的答案(假设你运行窗口).
如果您已经没有,请在Windows上启用“telnet”.
控制面板 – &gt;程序 – &gt;在“程序和功能”下选择“打开或关闭窗口功能” – &gt;它打开一个新窗口选择’telenet客户端’,然后单击确定.
启动命令提示符与管理员权限(在AllPrograms搜索’cmd’,右键单击它并选择以admin身份运行).
然后使用这个命令
1)telnet localhost 5554 //where 5554 is your emulator id, which is displayed top left corner of ur emulator
2)power capacity 10 //set the battery level to 10%
3)power ac off //turns off charging mode
现在,您可以在仿真器中看到低电量对话框.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f87cf29e5f66e4a33b76437e098bc95/" rel="bookmark">
			android ble 蓝牙绑定流程,BLE 配对与绑定过程详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 蓝牙绑定
绑定真正来说属于通用访问规范的讨论范畴。绑定指的无非是将密钥及相关身份信息保存到数据库中。如果设备不保存这些值，他们虽然能匹配，但不能绑定。
只要当中某一个设备不保存，重新连接后，只有一个设备拥有LTK，因此加密的启动将会失败。
为了避免这种情况，两个设备在最初配对时就会交换绑定信息，从而能够清楚地知道对方是否保留了该绑定信息。
如果对方设备不保存信息，那么一旦启动加密的尝试失败，主机将试图再次配对。
2. 绑定的相关知识
绑定并不是一个独立存在的过程。 可以理解成配对有两种方式， 没有设置绑定表示的配对请求和设置绑定标志的配对请求。
配对的目的就是单纯的加密链路，但是配对过程比较耗时(包括配对信息交换，用户输入配对码或带外传输配对码，协议层的配对确认交换和
随机数交换以及确认验证，都没问题后才会生成链路加密秘钥来加密链路)，如果为了数据始终都是加密传输而每次连接都去配对的话就比较麻烦，
所以又定义了一个绑定过程，绑定过程是在 配对后链路加密的情况下 分发一个 LTK(其他秘钥这里不涉及)，这个LTK就可以供以后直接加密链路，
而不用经过繁琐的配对过程。
Notes：其实LTK分配之后，每次重新连接时的加密并不是用LTK直接加密链路，而是双方交换一些信息(称为会话秘钥分散器)，然后利用这些信息和LTK
最终生成一个会话秘钥，真正的加密是用这个会话秘钥。
3. 总结
1)配对认证：主从机一方提供密码，一方输入密码，如果双方密码一致，那么此密码将作为TK(临时密码)；
2)加密链路：利用得到的TK(临时密码)等信息计算出STK(短期密码)用来做加密认证；
3)绑定：加密认证通过后，利用STK等信息生成LTK(长期密码)，把LTK保存下来，用于下次连接时做加密认证，不需要再次配对就可以加密链路，这就是绑定了；
绑定后通讯过程 : 每次连接时，从机会向主机发送安全请求，如果主从机相互绑定过，主机不会发送配对请求，主机直接利用绑定时保存的LTK发送加密请求,
从机也会利用绑定时保存的LTK来做加密回复，三次握手成功后(加密成功，三次握手通讯由底层完成，用户不可见)，从机回复主机加密状态success。
4. 配对和绑定区别:
1)连接：通讯的基础，通讯数据为明文；
2)配对：配对仅仅是为了在连接的基础上加密(通讯数据经过加密为密文)，提高蓝牙链路传输的安全性。不配对也能连接进行通信。
3)绑定：绑定是配对发起时的一个可选配置。把配对信息记录下来， 下次不用配对自动进入加密的连接；所以没在bonding列表里的设备不影响连接，照连不误。
阅读(3405) | 评论(0) | 转发(0) |
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c2a99348a4c75cc481de058d7a0c0a0/" rel="bookmark">
			android 第三方圆弧进度条,android 可配置的圆弧进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arc ProgressBar Configurable 圆弧环形进度条
DEMO
Attributes
name
format
description
borderWidth
integer
圆弧边框的宽度
progressStyle
tick/arc
进度条类型，tick 为带刻度的
radius
integer
半径
arcbgColor
color
圆弧的边框背景
degree
integer
弧度，设置为 0 即为圆形进度条，180 为半圆
tickWidth
integer
刻度的宽度
tickDensity
integer
刻度的密度 2~8 越小越密
bgShow
boolean
是否显示圆弧边框背景
arcCapRound
boolean
圆弧的笔触是否为圆形，tick 无效
interface
提供了绘制圆弧中间区域的一个接口
/**
*
* @param canvas
* @param rectF 圆弧的 Rect
* @param x 圆弧的中心 x
* @param y 圆弧的中心 y
* @param storkeWidth 圆弧的边框宽度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c2a99348a4c75cc481de058d7a0c0a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/421bf229ee362093306abed9c0c45785/" rel="bookmark">
			如何理解mqtt用到的101交换协议？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用过mqtt的同学都知道，mqtt连接时，在Network面板中的status是101。
NameStatusTimemqtt101（Switching Protocols）Pending 那么101（Switching Protocols）到底是什么意思呢？
这篇文章将带你理解101交换协议是什么，以及101交换协议运用的协议升级机制。
101交换协议协议升级机制 101交换协议 HTTP的101交换协议意味着client向server发送的消息中包含了Upgrade请求头，server会根据client发送的这个请求头切换协议。
server会在response中添加一个Upgrade响应头，来指示server切换到的协议。
用一句话来说就是：client通过在请求头中添加Upgrade告诉server切换协议，server在响应头中添加upgrade说明切换后的协议。
再简单一点就是：客户端告诉服务端去切换协议。
General Request URL: wss://foo.bar Request Method: GET Status Code: 101 Switching Protocols Request Headers Connection: Upgrade Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits Sec-WebSocket-Key: xxx Sec-WebSocket-Protocol: mqtt Sec-WebSocket-Version: 13 Upgrade: websocket // client告诉server使用websocket协议 ... Response Headers connection: Upgrade sec-websocket-accept: fNs9ByuvC+rD75+tj2GMQAzbJms= // server基于client发出的Sec-WebSocket-Key:xxx计算得出，计算过程文章末尾有介绍 sec-websocket-protocol: mqtt Upgrade: websocket // server告诉client，我们（client，server）使用的是websocket协议 ... 其中这些请求头是什么意思呢？Connection，Sec-WebSocket-Extensions，Sec-WebSocket-Key，Sec-WebSocket-Protocol，Sec-WebSocket-Version等等。
响应头呢？sec-websocket-accept，sec-websocket-protocol。
看了下面的协议升级机制就明白了。
协议升级机制 HTTP1.1版本的协议有一个特殊的机制：升级一个已经建立的连接为另外一个协议，一般是通过Upgrade头来实现。
这个机制是可选的，它不能强制协议改变。虽然实现支持新协议，但是也可以选择不升级。在实际应用中，通常这个机制用于引导WebSocket进行连接。
注意，HTTP2.0版本明确禁止使用这个机制。只能用于HTTP1.1。
升级HTTP/1.1连接 client可以使用Upgrade头去邀请服务器去切换为协议列表中的某一项，按照降序。
因为Upgrade是一个逐跳头，因此它需要一个Connection头。
这也就意味着一个典型的包含Upgrade报文头的请求为：
GET /index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/421bf229ee362093306abed9c0c45785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d578a92c096ad17cd4cc7726bec32e4d/" rel="bookmark">
			Vue实现前端实现数据查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端我们这里采用模板为：【vue-admin-template-master】
1、添加路由 在 router/index.js文件中
成功显示页面如下：
2、修改文件的路径 测试list.vue文件中代码如下：
显示成功之后效果如下：
3、在api文件夹创建 teacher.js 定义访问的接口地址 4、在list.vue文件中获取后端返回的数据 代码如下：
&lt;script&gt; //引入 import teacher from '@/api/edu/teacher/teacher' //核心代码 export default { data() { // 定义当前数据变量和初始值 return { list: null, // 查询之后返回的数据集合 current: 1, // 当前页 size: 10, // 每页显示的数据条数 teacherQuery: { // 条件封装的对象 } } }, created() { // 页面渲染之前执行，一般调用methods中定义的方法 this.getList() }, methods: { // 创建具体的方法，调用 teacher.js 定义的方法 // 讲师列表的方法 getList() { teacher.pageTeacherCondition(this.current, this.size, this.teacherQuery) // 请求成功返回数据 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d578a92c096ad17cd4cc7726bec32e4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ca64205e4517dcfdaa8571ddf84c86/" rel="bookmark">
			问题：ifconfig命令给网卡指定mac地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：服务器在进行重启操作后mac地址发生了改变，与业务绑定的mac地址不匹配导致业务无法启动。
解决办法：
1.ifconfig 先看下mac地址和网卡名称
2.ifconfig bond0 hw ether mac地址
解释： ifconfig 网卡名称 hw ether（mac地址的名称） 指定的mac地址
3.ifconfig 查看一下。
注意：mac地址不能产生冲突，缺点，是临时启用的重启网卡或者主机会失效。
参看办法：有待验证
1.将命令加到开机自启文件里/etc/rc.d/rc.local
2.将mac地址加到网卡配置文件里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4420f529a705ca83623834a44e73cc1/" rel="bookmark">
			Android横向伸缩,android使用Textview实现伸缩效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android使用Textview实现伸缩效果
发布时间：2020-08-23 23:22:00
来源：脚本之家
阅读：152
作者：刘启刚
android开发过程中，经常遇到Textview展示不完全的情况。
遇到此情况，通常的处理是：
方案一、Textview添加android:ellipsize属性，让展示不完的部分使用省略号代替。
方案二、Textview采用走马灯效果，使其滚动展示全部文本内容。
对于方案一，如果想查看被省略后的内容，如何实现？微信的评论列表，豌豆荚视频详情介绍都有类似使用场景。
下面来看下Demo例子的收起效果，文本内容没有展示完全，使用省略号代替，提示“更多”和向下箭头标识，截图如下：
当点击“更多”和向下箭头时，被省略的内容全部展示出来，提示“更多”和向上收起标识箭头，截图如下：
对于以上效果，实现思路如下：
1、设置Textview默认展示固定行，比如3行，内容展示不完全，在Textview尾部使用省略号代替。
xml文件内容为：
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
tools:context=".MainActivity" &gt;
android:id="@+id/text_content"
android:layout_width="fill_parent"
android:layout_height="wrap_content"
android:ellipsize="end"
android:maxLines="3"
android:singleLine="false" /&gt;
android:id="@+id/show_more"
android:layout_below="@id/text_content"
android:layout_alignParentRight="true"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_marginTop="3dip"
&gt;
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_alignParentRight="true"
android:textSize="13sp"
android:textColor="#999"
android:layout_marginRight="34dip"
android:text="更多" /&gt;
android:id="@+id/spread"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_alignParentRight="true"
android:background="@drawable/ic_details_more" /&gt;
android:id="@+id/shrink_up"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_alignParentRight="true"
android:background="@drawable/ic_shrink_up"
android:visibility="gone" /&gt;
2、点击“更多”和向下箭头时，通过Textview的setMaxLines()方法改变Textview的最大行数。即可实现上述效果。
Java代码为：
package com.example.testdemo;
import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4420f529a705ca83623834a44e73cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c28eda5ea5a032649d23cad436f5cf/" rel="bookmark">
			查看Keras版本号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一 打开Anaconda Prompt，输入pip install keras
方法二 在集成开发环境当中编写如下代码：
import keras print(keras.__version__) # 注意version前后各有两个下划线 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4137eb3e91c7a6548aeea03bc9c59af9/" rel="bookmark">
			android&#43;圆角屏幕方法,android屏幕圆角实现方法的示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在很多全面屏手机的屏幕四角做成圆的，其圆润的感觉给人带来别样的视觉体验。先来一张我大锤子镇楼(不是广告呀，锤子没给钱)，大家来直观感受一下圆角的魅力。
锤子.jpg
当然这种是硬件上实现的，我怀疑也是方的显示屏，然后做了个圆角遮蔽。那对于我们这些脸方的手机，就不能笑嘻嘻的圆一回吗？答案是肯定的，no picture say ...
(应该能看出来我用的是神马手机吧)
圆角实现：
那我们就应该思考了，软件层面怎样实现这种效果呢。相信很多朋友立马会想到――使用悬浮窗。
实现原理：利用WindowManager将我们的圆角加到屏幕的四个角，圆角颜色设置为黑色，形成视觉圆角屏幕。
1.自定义圆角view
很显然，首先我们需要实现一个形状如下图的圆角，怎么做呢？用path(不熟悉的小伙伴可以百度一下哈)，这里我们以左上角为例实现这个圆角。
圆角
// top left
case Gravity.TOP | Gravity.LEFT:
path.moveTo(0.0f,0.0f);
path.lineTo(0.0f,(float) h);
path.arcTo(new RectF(0.0f,0.0f,((float) w) * 2.0f,((float) h) * 2.0f),180.0f,90.0f,true);
path.lineTo((float) w,0.0f);
path.close();
break;
为了能让用户自定义圆角颜色，大小，透明度，各个角是否显示，我在里面加了对应的控制变量，当用户设置的时候更新view就可以了。
public void setCornerSize(int size){
this.cornerSize = size;
requestLayout();
invalidate();
}
是不是很简单，这样一个圆角view就实现了。
2.显示圆角
现在我们就要在屏幕的四个角将圆角加上去了。这里使用了android的悬浮窗技术。即用windowmanager将我们的圆角加到顶层的window上，遮蔽其他部分。windowmanager在添加view的时候需要设置一个WindowManager.LayoutParams。下面我们初始化这个Params：
// window manager
manager = (WindowManager) this.getApplicationContext()
.getSystemService(Context.WINDOW_SERVICE);
params = new WindowManager.LayoutParams();
/*
系统提示类型:7.0以前可以直接用TOAST的类型，不用申请权限，直接添加
7.0以后不行了,需要申请SYSTEM_ALERT_WINDOW权限，window type最好
设置为ERROR 或者 PHONE
*/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4137eb3e91c7a6548aeea03bc9c59af9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27fb078aa1f70b07348c66f478514ade/" rel="bookmark">
			【GAMES201学习笔记】物质点法入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 流体力学中的两种描述 1.1 拉格朗日描述 1.1.1 什么是拉格朗日描述 拉格朗日描述 的观察对象是组成物体的 质点 ， 粒子（particle） ，或者说 流体微元 ：
随着物体变化，对应 “粒子” 的位置也会随之变化，跟踪的观察对象是单个 “粒子” 的属性变化；拉格朗日描述最显著的特征就是观察对象会发生位置或者形状的变换。 1.1.2 常见的使用拉格朗日描述的方法 弹簧质点模型（观察质点的变换）有限元法（观察有限微元的变换） 1.1.3 拉格朗日描述擅长的地方 拉格朗日描述擅长对独立粒子的操作；物体的变换操作：这时对粒子施加相应的变换即可；粒子的质量和动量守恒是简单的；定义物体的材质：定义单个粒子相关参数。 1.1.4 拉格朗日描述不擅长的地方 由于粒子经过变换之后，对应的位置和形变都是不确定的，因此虽然可以查询之前已经建立了 邻接信息 的粒子之间的关系（当然，在拉格朗日中找邻接粒子本身是一个困难的问题）；但查询未确立 邻接信息 的粒子之间的关系（例如任意两个粒子之间的距离），会异常困难。
这导致当有查询 未邻接的两个粒子 之间关系的需求时，会遇到一定的麻烦：例如在使用有限元进行仿真时，如果没有合理处理自相交问题，会发生模型穿透的情况。
弹性方块的 FEM 模拟 ：
弹性平面的 FEM 模拟 ：
由于仅做了邻接粒子之间、粒子与球之间的碰撞检测，所以在平面折叠时发生了穿透。 不过目前在有限元领域，对于碰撞问题，也已经有了对应的解决方案：
[SIGGRAPH 2020] Incremental Potential Contact (IPC) 1.2 欧拉描述 1.2.1 什么是欧拉描述 欧拉描述 的观察对象是物体所在 空间的场 ， 网格（Grid） ，或者说 流体元胞（Cell） ：
网格是在空间中的绝对参照系的微元，随着物体变化，网格的位置和形状不会随之变化，仅物体映射到网格上的信息发生改变；欧拉描述最显著的特征就是观察对象不会发生位置或者形状的变换。 1.2.2 欧拉描述擅长的地方 拉格朗日描述擅长处理粒子之间的相对关系；物体性质的变化：质量密度、速度、温度、熵、焓，甚至单位流体中的磁通量；物体内部的压力压强计算，可以很快的获得能量密度函数；边界碰撞检测：欧拉描述可以很快的获得任意粒子之间的相对关系信息，或者说在欧拉视角下物体自然而然地在进行着碰撞检测。 1.2.3 欧拉描述不擅长的地方 物体的变换：显然，拉格朗日描述擅长的地方就是欧拉描述不擅长的地方，在物体发生变换的过程中，需要更新网格和相邻网格的信息，这个过程是较为繁琐的。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27fb078aa1f70b07348c66f478514ade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de6b0f9591a8d90f0a701c0b272ad0c/" rel="bookmark">
			gitlab 清理指定时间前的，merge的早期分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于分支管理的问题，导致gitlab上面堆积了许多无用的分支。
gitlab上面也不好操作，我们可以借助git客户端来删除远程分支
需要删除哪些分支 指定时间 + merged合并过的代码
Shell脚本如下 cat delete.sh #!/bin/bash # 批量删除远程分支 shell script reponsitory_name="$1" echo "您即将删除【"$reponsitory_name"】下的分支，请先找其他人备份好,以免误删！！！！"; echo " " cd $reponsitory_name; git checkout master for branch in `git branch -r --merged | grep -v HEAD`; do # 分支名称 simple_name=`echo $branch |grep '/' | cut -d '/' -f 2`; # 切换到分支 git checkout $simple_name # 分支最后提交时间 branch_timestamp=`git show --format="%at" |head -n 1`; # 当前系统时间 cur_sec_and_ns=`date '+%s-%N'`; cur_sec=${cur_sec_and_ns%-*}; # 时间差 time_different=$[cur_sec-$branch_timestamp]; # 阈值，这里清理30天前 time_require=$[3600*24*30]; echo 最后提交$branch_timestamp 分支$simple_name 时间差$time_different if [[ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de6b0f9591a8d90f0a701c0b272ad0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c73b97c9c75379e4c588c057e42d810a/" rel="bookmark">
			stat() 之权限查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看文件的权限方式
struct stat *file_info = calloc(1,sizeof(struct stat));
stat(dir,file_info);
unsigned int mask = 0000777;
unsigned int access = mask &amp; file_info-&gt;st_mode;
printf("before chmod dir mode = %o, flowop mode = %o\n", access, flowop-&gt;fo_modes);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9ef87c96877bc7c61a9360d7259386/" rel="bookmark">
			Ajax笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 客服端和服务器
1.1 上网的目的
1.2 服务器
1.3 客户端
2 URL地址
2.1 概念
2.2 组成部分
3 客服端与服务器的通信过程
3.1 图解客户端与服务器的通信过程
3.2 基于浏览器的开发者工具分析通信过程
4 服务器对外提供了哪些资源
5 什么是Ajax
5.1 概述
5.2 学习目的
5.3 Ajax的应用场景
6 jQuery中的Ajax
6.1 概述
6.2$.get()函数的语法
6.2 $.get()发起不带参数的请求
6.3 $.get()发起带参数的请求
6.4 $.post()函数的语法
6.5 $.ajax()函数的语法
7 接口
7.1 接口的概念
7.2 分析接口的请求过程
7.2.1 通过get方式请求接口的过程
7.2.2 通过post方式请求接口的过程
7.3 接口测试工具
7.4 使用postman测试post接口
7.5 接口文档
8 from表单的基本使用
8.1 什么是表单
8.2 表单的组成部分
8.3 标签的属性
8.3.1 action属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e9ef87c96877bc7c61a9360d7259386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69342ec1829f2e5720b0dc64add04358/" rel="bookmark">
			深度学习之超分辨率算法——VDSR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比较于之前的FSRCNN来说，VDSR我认为主要引入了以下优秀特点 首先是卷积层数的上的增加，卷积层数直接代表着模型提取特征的能力强弱小卷积核的进一步引入，利用卷积核3x3堆叠层数，模型一共20层。引入残差网络 缺点： 原文依然采用的MSE损失，单纯比较像素之间的差异。图像相对比较平滑。训练依然采用是SRCNN的训练方法，先上采样到高分辨率尺寸大小再进行训练。 两张图理解：
（输入尺寸等于输出尺寸的模型实现） 使用数据集:train.h5 model.py import torch import torch.nn as nn from math import sqrt class VDSR(nn.Module): def __init__(self): super(VDSR, self).__init__() # 残差网络 self.residual_layer = self.make_layer(Conv_ReLU_Block, 18) # 输入 self.input = nn.Conv2d(in_channels=1, out_channels=64, kernel_size=(3,3), stride=(1,1), padding=(1,1), bias=False) self.output = nn.Conv2d(in_channels=64, out_channels=1, kernel_size=(3,3), stride=(1,1), padding=(1,1), bias=False) self.relu = nn.ReLU(inplace=True) self.init_weights() def init_weights(self): # 模型初始化参数 for m in self.modules(): if isinstance(m, nn.Conv2d): n = m.kernel_size[0] * m.kernel_size[1] * m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69342ec1829f2e5720b0dc64add04358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9171a74b23e8d6d2317e9e9c227713d/" rel="bookmark">
			android9.0后台检查,Notes: Android上检测应用是否被调到了后台/前台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天在做一个密码管理本类的应用，遇到这么一个需求：
应用每次退出到后台，都要关闭存储密码信息的数据库，并在应用再切换到前台时，向用户展示一个输入框让用户输入访问口令(该口令用于对数据库进行加解密)。
这就要求我对应用的前后台切换进行监听。
为实现这个需求，我第一个想到就是借助Activity生命周期各个回调方法来实现。
大致思路就是在onPause()/onStop()方法中关闭数据库，然后在onStart()/onResume()方法中检查数据库的状态，
然后根据这个状态值的来做出对应的动作。伪代码表示如下：
public class BaseActivity extends AppCompatActivity {
@Override
protected void onStart() {
super.onStart();
if(isSecureDataBaseClosed()){
showEnterPasswordActivity();
}else{
//do something else here
}
}
@Override
protected void onStop() {
super.onStop();
closeSecureDatabase();
}
}
兴冲冲地按照这个思路实现了代码，在虚拟机上测试，很快就暴露了问题：
当一个Activity启动另外一个Activity，或者一个Activity从另外一个Activity返回时，都会调用相应的onStart()和onStop()方法。
因此这个方法仅仅适用于应用只有单个Activity情况，当有多个Activity时，上面的思路并不能够达到需求。
于是只能看看有没有别的方法。例行google了一下，发现stackoverflow上早已有人问过类似的问题。有两个高票回答看起来都十分可行。于是决定整理一下，当作笔记。
1. 使用定时器TimerTask + Timer
第一个的思路跟我上面所述的方法十分地相似，但是解决了上述方法中存在的问题。
上述方法之所以不能工作，原因在于在onStop()方法中马上就认为应用即将进入后台，并且马上关闭了数据库。这样就会对Activity间的切换进行误判。
而stackoverflow上的方案就是对时间进行了一个判断。因为Activity间的一次切换时间是比较短的，因此可以借助这一点来改良上述方案。
下面给出描述这个思路的伪代码：
private final long MAX_ACTIVITY_TRANSITION_TIME_MS = 2000;
@Override
public void onResume(){
super.onResume();
if(wasAppInBackground()){
//Do specific came-here-from-background code
}
stopTimer();
setAppWasInBackground(false);
}
@Override
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9171a74b23e8d6d2317e9e9c227713d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a134f7a58127dd43a1250d67db39871/" rel="bookmark">
			android开启gps功能,android 打开GPS的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在讨论打开gps的之前先看下如何检测gps的开关情况:
方式一:
boolean gpsEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);
方式二(此方式需要android.permission.WRITE_SECURE_SETTINGS权限,此权限仅限于系统应用,所以需要将app安装特定文件夹(此句待验证)):
boolean gpsEnabled = Settings.Secure.isLocationProviderEnabled(context.getContentResolver(), LocationManager.GPS_PROVIDER );
2.开启 GPS的方法:
方式一:手动的定位到"设置-位置信息访问权限"进行设置.
Intent settingsIntent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);
settingsIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
context.startActivity(settingsIntent);
方式二,gps的开关,此方法根据不同值还可设置其他功能(0-wifi,1-brightness,2-sync,3-gps,4-bluetooth),本人的4.2.4版本失效,其他版本未测.
public static void toggleGPS(Context context){
Intent GPSIntent = new Intent();
GPSIntent.setClassName("com.android.settings",
"com.android.settings.widget.SettingsAppWidgetProvider");
GPSIntent.addCategory("android.intent.category.ALTERNATIVE");
GPSIntent.setData(Uri.parse("custom:3"));
try {
PendingIntent.getBroadcast(context, 0, GPSIntent, 0).send();
} catch (CanceledException e) {
e.printStackTrace();
}
}
方式三,此处同检测gps的方式二,都是通过Setting.Secure来完成,需要android.permission.WRITE_SECURE_SETTINGS权限
Settings.Secure.setLocationProviderEnabled( context.getContentResolver(), LocationManager.GPS_PROVIDER, false );
暂时了解这些,欢迎共同讨论
android activity启动的4种方式记录及打开其他应用的activity的坑
Android启动的四种方式分别为standard,singleTop,singleTask,singleInstence. standard是最常见的activity启动方式,也是默认的启动的方式. ...
Android请求服务器的两种方式--post&amp;comma; get的区别
android中用get和post方式向服务器提交请求_疯狂之桥_新浪博客http://blog.sina.com.cn/s/blog_a46817ff01017yxt.html Android提交数 ...
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a134f7a58127dd43a1250d67db39871/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3272c5f3d527eed98e6e605764e5bea/" rel="bookmark">
			echarts 的tooltip 自定义提示框 formatter无法使用回调函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用echats时无论如何都无法使用formatter 做函数回调 今天在做一个功能时需要重新写一个Tooltip的样式，但是发现只能使用字符串模板的格式 tooltip:{ trigger: 'axis', formatter:'&lt;div style="padding:10px;fontSize:14px;"&gt;' + {b0} ： {c0} + '&lt;/div&gt;' +'&lt;div style="padding:10px;fontSize:14px;"&gt;' + {b1} ： {c1} + '&lt;/div&gt;' } 上面是一个数据的简写模式，{a},{b},{c}是echats中代表数据的占位数字 但是这样写有个大麻烦就是我对数据进行了对比，比如2月份和3月份做对比，那2月份没有30日就会直接显示{b0}：{c0}
所以我不得不重新来找导致我无法使用回调函数的原因，我在界面上打印了传入echats的option发现了一个大问题，配置中居然没有我写的回调函数！！！，这是怎么回事？
然后我重新看了一遍代码，终于恍然大悟！！！
[{a:1,b:2,c:function(){console.log(‘c’)}},{a:2,b:3},…]
对象数组越复杂，那数据只做浅拷贝的可能性越大。
在写代码时我们为了避免数据只做浅拷贝，导致数据不及时更新的问题，经常会通过改变数据类型的方式来实现。
比如对于对象数组
我们一般可能直接用传统方法进行深拷贝处理：
JOSN.parse(JSON.stringfy())
这种方法可以很好的做到深拷贝但是会有个问题，他会把对象中存在的function方法去掉，同样我在更新echats配置时也是用
JOSN.parse(JSON.stringfy(Option))
导致formatter 函数被去除了。
为了解决这个问题，我们使用lodash 函数库 的 cloneDeep()方法，就可以避免发生类似的问题。
setOption(lodash.cloneDeep(option))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9ddcc60fd14a0ec953f14601b56364/" rel="bookmark">
			拨号上网变成WiFi热点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前景: 以前在学校上信息课, 手机信息特别差老师开了屏蔽仪, 但是电脑的网速特别的快, 我就在想有没有什么办法把电脑变成一个热点发射WiFi信息呢, 后来再我不懈的努力下, 成功了(ps: 百度上的东西有时候挺耽误人的, 甚至让我觉得这是可能的事情, 但是我对网络通信略知一二这个是肯定可以实现的)
1、进入dos命令窗口:
window+R 2、设置承载网络:
netsh wlan set hostednetwork mode=allow ssid=javaniubi key=password 正常会输出：
承载网络模式已设置为允许。
已成功更改承载网络的 SSID。
已成功更改托管网络的用户密钥密码。
3、查看驱动：
netsh wlan show drivers 正常输出：
接口名称: WLAN
驱动程序 : Qualcomm Atheros AR956x Wireless Network Adapter 供应商 : Qualcomm Atheros Communications Inc. 提供程序 : Qualcomm Atheros Communications Inc. 日期 : 2017/4/16 版本 : 10.0.0.352 INF 文件 : oem6.inf 类型 : 本机 WLAN 驱动程序 支持的无线电类型 : 802.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d9ddcc60fd14a0ec953f14601b56364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f47c5089ef8964b5d1ec1229fdc6d9/" rel="bookmark">
			android 自定义圆形progressbar,Android-自定义ProgressBar实现圆弧进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继承于ProgressBar实现，保留了Progressbar的特性，源码在文尾。
参数nameformatdescriptionborderWidthinteger圆弧边框的宽度
progressStyletick/arc进度条类型，tick为带刻度的
radiusinteger半径
arcbgColorcolor圆弧的边框背景
degreeinteger弧度，设置为0即为圆形进度条，180为半圆
tickWidthinteger刻度的宽度
tickDensityinteger刻度的密度 2~8 越小越密
bgShowboolean是否显示圆弧边框背景
arcCapRoundboolean圆弧的笔触是否为圆形，tick无效
interface
提供了绘制圆弧中间区域的一个接口 ，可根据自己的需求自由绘制/**
*
* @param canvas
* @param rectF 圆弧的Rect
* @param x 圆弧的中心x
* @param y 圆弧的中心y
* @param storkeWidth 圆弧的边框宽度
* @param progress 当前进度
*/
public interface OnCenterDraw {
public void draw(Canvas canvas, RectF rectF, float x, float y,float storkeWidth,int progress);
}
默认提供了两个实现
onImageCenter and OnTextCenter
UsemProgress.setOnCenterDraw(new ArcProgress.OnCenterDraw() { @Override
public void draw(Canvas canvas, RectF rectF, float x, float y, float storkeWidth,int progress) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43f47c5089ef8964b5d1ec1229fdc6d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6fe8b92d6387bf65a9e976633221109/" rel="bookmark">
			计算机软考初级含金量高吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先软考的含金量就很高，软考分为三个级别初、中和高级，相应的级别科目考试对于相应的证书同时也对于相应的职称。因为软考是可以以考代评，一考两用，软考证书即是职称又是资格证书。所以就算是初级，也有初级职称，当然初级再软考中含金量是比不上中高级的，相应的好处也都有，有一证在手也固然是好呀。
软考初级科目有：程序员、网络管理员、信息处理技术员和信息系统运行管理员。
通过软考考试获得证书的人员，表明其已具备从事相应专业岗位工作的水平和能力，用人单位可根据工作需要从获得证书的人员中择优聘任相应专业技术职务（技术员、助理工程师、工程师、高级工程师）。
有能力的可以备考中高级，若是在IT行业或国企、事业单位等软考的中高级证书在工作上帮助还是很大的，也有利于提升、升职加薪等。
软考级别对应表如下：
有一些备考资料，需要的可以留评发邮箱的▲
留邮箱的也发了，放到群里面了，直接到群文件下载会更方便
软考资料q裙：651180059
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce85a4f4195377200e685825f8e2a35/" rel="bookmark">
			图像成像模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像采集中的主要模型包括成像模型和亮度模型。在图像表达f(x,y)中,(x,y)表示像素的空间位置，是由成像时的几何模型所确定的，而f表示像素的幅值数值(灰度)，是由成像时的亮度成像模型所确定的。
(1)几何模型 图像采集的过程从几何角度可看作是一个将客观世界的场景通过投影进行空间转化的过程，这个投影过程可用投影变换(也称为成像变换或几何透视变换)描述。一般情况下，客观场景、摄像机和图像平面各有自己不同的坐标系统，所以投影成像涉及到在不同坐标系统之间的转换。
这里主要包括三个坐标系统:**(1)世界坐标系统：也称为真实或现实世界坐标系统XYZ,它是客观世界的绝对坐标(也称客观坐标系统)(2)摄像机坐标系统：是以摄像机为中心制定的坐标系统xyz，一般取摄像机的光学轴为Z轴(3)**图像平面坐标系统:是在摄像机内形成的图像平面坐标系统x’y’。一般取图像平面与摄像机坐标系的xy平面平行，且x轴与x’轴、y轴与y’轴分别重合，这样图像平面的原点就在摄像机的光学轴上。
根据前面3个坐标系之间不同的相互关系，可以得到不同的摄像机模型。
&lt;1&gt;重合模型 考虑摄像机坐标系统xyz与世界坐标系XYZ重合的简单情况，其中图像平面的中心处于原点，镜头中心点的坐标是 ( 0 , 0 , λ ) (0,0,\lambda) (0,0,λ)， λ \lambda λ是镜头的焦距，当焦距为1时，该摄像机叫归一化摄像机，对较远的目标，其投影更靠近图像中心。如下图所示:
空间点坐标和图像点坐标之间的几何关系，其中 Z &gt; λ Z&gt;\lambda Z&gt;λ，借助相似三角形则有下式:
x λ = − X Z − λ 式 ( 1 − 1 ) \frac{x}{\lambda}=\frac{-X}{Z-\lambda} \quad 式(1-1) λx​=Z−λ−X​式(1−1)
y λ = − Y Z − λ 式 ( 1 − 2 ) \frac{y}{\lambda}=\frac{-Y}{Z-\lambda} \quad 式(1-2) λy​=Z−λ−Y​式(1−2)
由此，可以推导出:
x = λ X λ − Z 式 ( 1 − 3 ) x=\frac{\lambda X}{\lambda-Z} \quad 式(1-3) x=λ−ZλX​式(1−3)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce85a4f4195377200e685825f8e2a35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aabc80ebdf065794498b451e2f1ae65/" rel="bookmark">
			[leetcode]给定一个二叉树，它的每个结点都存放着一个整数值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个二叉树，它的每个结点都存放着一个整数值 找出路径和等于给定数值的路径总数。
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。
示例： root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -&gt; 3 2. 5 -&gt; 2 -&gt; 1 3. -3 -&gt; 11 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } count := pathSumCore(root, sum) count += pathSum(root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aabc80ebdf065794498b451e2f1ae65/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/203/">«</a>
	<span class="pagination__item pagination__item--current">204/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/205/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>