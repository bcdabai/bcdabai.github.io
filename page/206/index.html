<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323a52ca6cf37b9c9288aa4df7ae2608/" rel="bookmark">
			java开发冷知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Timestamp只能使用到2038年，2038年后Timestamp不适用的（可能会推出新的时间类型）
2.递归调用容易造成内存泄漏（如果没有父子级关系，不建议使用），可以改用while或者for循环
3.内网无法访问到外网服务器，不能互通
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a29aef0f4395cec8403a260c9e101976/" rel="bookmark">
			spring boot&#43;vue 前后不分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 thymeleaf 视图解析器 pom.xml配置
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; application.properties配置
spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.mode=HTML5 在controller层直接return页面 //测试页面 @RequestMapping("/testPage") public String testPage(){ return "test/testPage"; } 新建html页面放在resources底下的templates html页面跳转到vue页面 跳转需要的js
vue-router.js
详情地址：https://www.runoob.com/vue2/vue-routing.html
使用httpVueLoader.js来运行.vue文件
详情地址：https://codechina.csdn.net/mirrors/franckfreiburger/http-vue-loader/-/tree/master/src
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt; &lt;link rel="stylesheet" href="./js/element-ui/2.11.0/lib/theme-chalk/index.css"&gt; //element的js &lt;script src="./js/vue.js"&gt;&lt;/script&gt; //vue的js &lt;script src="./js/vue-router.js"&gt;&lt;/script&gt; //vue路由的js &lt;script src="./js/httpVueLoader.js"&gt;&lt;/script&gt; &lt;script src="./js/axios.min.js"&gt;&lt;/script&gt; //axios的js &lt;script src="./js/element-ui/2.11.0/lib/index.js"&gt;&lt;/script&gt; //element的js &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app" v-cloak&gt; //keep-alive作用：在组件切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性 &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;script&gt; const router = new VueRouter({ //路由 routes: [ { path: '/', name: 'testPage', component: httpVueLoader('/vue/testPage/testPage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a29aef0f4395cec8403a260c9e101976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f396ee512b5b559b09d8112ceda91bd6/" rel="bookmark">
			c语言圆周长面积公式,怎么用c语言计算圆周长和面积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下：
#include
int main(){
int radius;
float area,perimeter;
radius=6;
perimeter=2*3.14*radius;
printf("圆的周长=%f英寸\n",perimeter);
area=3.14*radius*radius;
printf("圆的面积=%f平方英寸\n",area);
return(0);
}
2、c语言计算矩形的周长和面积
#include
/*长方形的高和宽，单位为米*/
int width;
int height;
int area;
int perimeter;
int main(){
height=7;
width=5;
perimeter=2*(height+width);
printf("矩形的周长=%d米\n",perimeter);
area=height*width;
printf("矩形的面积=%d平方米\n",area);
return(0);
}
扩展资料：
使用C语言计算圆周长和面积的优势:
1、简洁紧凑、灵活方便
C语言一共只有32个关键字，9种控制语句，程序书写形式自由，区分大小写。把高级语言的基本结构和语句与低级语言的实用性结合起来。C语言可以像汇编语言一样对位、字节和地址进行操作，而这三者是计算机最基本的工作单元。
2、运算符丰富
C语言的运算符包含的范围很广泛，共有34种运算符。C语言把括号、赋值、强制类型转换等都作为运算符处理。从而使C语言的运算类型极其丰富，表达式类型多样化。灵活使用各种运算符可以实现在其它高级语言中难以实现的运算。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f5d2527d1872b2aab69a9a1cfa4736/" rel="bookmark">
			编写一个程序，开启3个线程，这3个线程的ID分别为A、B、C，每个线程将自己的ID在屏幕上打印10遍，要求输出结果必须按ABC的顺序显示；如：ABCABC….依次递推
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写一个程序，开启3个线程，这3个线程的ID分别为A、B、C，每个线程将自己的ID在屏幕上打印10遍，要求输出结果必须按ABC的顺序显示；如：ABCABC….依次递推 首先三个线程如果不同步的话，是处于竞争状态的，那么会导致乱序执行，系统的调度算法是时间片轮询的话，那么会出现一个线程运行一段时间，然后另一个线程再运行一段时间…
要满足ABCABC…一次递推的话，那么必然要使用同步的方法控制三个线程的运行顺序
A-&gt;B B-&gt;C C-&gt;A
这三个线程相当于是一个环，都互相死等，此时是处于死锁状态
解除死锁让A先运行，就需要我们的主线程，手动解除A的wait条件
/************************************************************************* &gt; File Name: ABC.c &gt; 作者:YJK &gt; Mail: 745506980@qq.com &gt; Created Time: 2021年05月13日 星期四 13时10分22秒 ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;pthread.h&gt; #include &lt;unistd.h&gt; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t condC_A = PTHREAD_COND_INITIALIZER; pthread_cond_t condA_B = PTHREAD_COND_INITIALIZER; pthread_cond_t condB_C = PTHREAD_COND_INITIALIZER; void *threadA(void *arg) { for (int i = 0; i &lt; 10; i++) { pthread_mutex_lock(&amp;mutex); pthread_cond_wait(&amp;condC_A, &amp;mutex); // 解锁mutex，阻塞 函数返回加锁 printf("A-----%ld\n", pthread_self()); pthread_mutex_unlock(&amp;mutex); pthread_cond_signal(&amp;condA_B); } } void * threadB(void *arg) { for (int i = 0; i &lt; 10; i++) { pthread_mutex_lock(&amp;mutex); pthread_cond_wait(&amp;condA_B, &amp;mutex); // 解锁mutex，阻塞 函数返回加锁 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79f5d2527d1872b2aab69a9a1cfa4736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde59584f07a3d0c63cf9b6e10a240b4/" rel="bookmark">
			手把手教你开发基于单片机的wifi通信的物联网项目（远程灯控制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《《《《《正文》》》》》
《前言》
本文主要介绍开发一个基于单片机的wifi通信远程灯控制的方法，单片机只需支持UART通信即可，以实现最简单的远程控制开关、远程控制亮度，配网后，只需手机联网就可控制联网设备；
本文的wifi模块是基于涂鸦智能的wifi模块，主芯片使用STM32F103C8T6；wifi模块与主芯片使用最基本的UART串口实现通信；
《WIFI模块申请》
1、登入涂鸦智能loT平台；
平台网址：https://www.tuya.com/cn/
2、创建产品；
3、方案选择；
方案选择wifi，点击创建产品。这里有很多涂鸦自己定义的产品，我们先选这个；其他可根据自己的项目选择；
4、功能定义；
第3步之后会跳出功能选择；选择自己需要的功能；
我定义了开关状态值，bool类型表示开\关；以及亮度值，Value类型表示亮度，从0-1000；
5、选择手机app面板；
下载手机涂鸦智能App，这里我使用了涂鸦提供的界面，这个界面根据自己需求开发，或者有特殊要求也可以提交需求，涂鸦会帮你开发；
6、选择wifi模组，并下单购买；
下面是我的模块，你选择一个模块就行；
7、其他默认即可；等待模块快递寄到；
《硬件设计》
1、获取模组封装尺寸；
在硬件开发下，模组详情下获取封装尺寸；
2、下面这个是我的封装尺寸，涂鸦自家的模块封装尺寸都差不多；
3、画模块封装pcblib；
这里我自己画的，带3D；供参考；下载地址：
https://pan.baidu.com/s/1hqxgKS46EaokUoN7utyw7g
提取码：airX
4、原理图设计：
按键是长按5s进入配网；灯是指示wifi模块工作状态，常亮表示联网正常，长灭表示未配网；快闪表示正在配网状态；wifi模组与MCU使用usart串口连接；这里的按键口A_14和灯口A_19注意，会在下面代码配置里使用到；
5、布板
略。。。。就是拉拉线，没什么特殊要求；
我的部分pcb；
6、回来的板子；
焊接后：这里我把最初的原理图端口和封装端口左右镜像弄反了，所以只能这么焊；上面分享的封装资源是修改后ok的；
《软件设计》
当中涉及的PWM、UART等模块代码可参考以下文章。
基于C语言的机械按键模块化软件开发（模块化程度高，可高速移植）
STM32F103之脉冲宽度调制（PWM）模块开发（含呼吸灯实例源代码）
STM32F103之时基中断（TIM）模块开发
STM32F103调试串口（USART）模块开发（内含Printf重定向函数说明）
软件其实主要是模块与主芯片之间的UART通信；我这里使用涂鸦的提供的WIFI的SDK进行移植；
1、获取我上面文章的USART模块代码;
相关代码获取地址：
https://pan.baidu.com/s/1zyrOF18WxIq0H3_4qU7Evg
关注公众号，发送1234，获取提取码；
2、获取SDK：进入涂鸦平台，进入产品开发，在硬件开发的最下面下载MCU_SDK，这里有很多资料，都可以下载看看；
3、打开下载包，将里面的mcu_sdk复制到usart工程文件下，除了VERSION.md文件，其他都加入工程；
3、下面开始移植，涂鸦有移植教学文档；在网站的文档中心搜索移植就可以找到移植说明文档，这里你可以看他的文档详细些；下面是我的移植过程；
4、在文件路径中添加mcu_sdk文件路径；
把wifi.h头文件写到main.h
把main.h头文件写在wifi.h里
这个时候编译还有很多问题，不急；
5、我们模块的方式使用模块自处理模式，找到protocol.h下将这个功能宏定义打开；并根据硬件，指示灯GPIO是A_19，就是19，按键GPIO是A_14,就是14，如下代码：
6、在protocol.c添加字节发送函数；
7、在USART串口接收中断函数中添加uart_receive_input（）函数；如下：
8、在protocol.c的all_data_update函数上传自己初始化数据的；这个是用来上电更新所有数据的，我就默认上电关闭led，亮度值为1%，即10；如下代码；
如果你本地改变了数据，就调用上面的各自的函数就能实现数据上传了；
mcu_dp_bool_update(DPID_SWITCH_LED,0); //BOOL型数据上报;mcu_dp_value_update(DPID_BRIGHT_VALUE,100); //VALUE型数据上报; 9、在protocol.c里有数据下传的函数，只要在这个函数里添加自己的响应操作就就可以实现wifi控制了；我这个有2个功能，开关和亮度，就有下面2个函数，有多少数据下传就有多少个函数；
10、在主函数main.c初始化调用wifi_protocol_init();usart波特率为9600；在死循环里调用wifi_uart_service();必须放在while（1），不要加任何判断；
int main(void){ NvicConfig(); USART_init(9600); wifi_protocol_init(); for(;;) { wifi_uart_service(); }} 11、最后编译，把错误去掉，一般都是些中文。注释掉就可以了；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dde59584f07a3d0c63cf9b6e10a240b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/246b1774d166841bc9b8996960855342/" rel="bookmark">
			自学单片机是否先学c语言,学习单片机需要先学好C语言再去学单片机吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先肯定一点的是学习单片机不需要先学好C语言再去学单片机，而是在学习单片机的过程中可以促进C语言的学习！
我在学习单片机时对C语言也只是了解其皮毛，我对C语言比较深刻的了解是在学习单片机过程中逐渐形成的。通过编写简单的小程序慢慢验证C语言语句的各种执行情况，比如在学习for循环语句时，我们可以用流水灯的循环来验证；学习数组时我们可以用数码管来验证；学习c语言指针时我们可以用LCD1602液晶让其显示字符串来验证等等。那怕就是C语言的复合语句表达式，也是可以用一个或者两个LED灯显示亮灭情况来验证这个句语的逻缉关系的。
所以单片机的学习和C语言的学习可以是同时进行的，两者是互相促进相辅相承的关系，单片机本身及其外设可以用C程序控制，而C程序控制单片机及其外设反而又使我们对硬件的进一步加深了理解，在两者同时学习的过程中我们又锻炼了对程序调试的能力，也就是提升了我们发现问题解决问题的能力！所以我建议学习单片机的朋友在学习C语言和单片机的选择上要同时进行，以上就是我学习单片机时的体会
学习单片机可以不先学习c语言，但是对于单片机，学习c语言又是最好的途径，操作单片机的c语言叫做keil c。
一般，学习单片机时候，都是从单片机的内存结构，引脚作用，各个模块功能来学习的，这个时候，会先学习一门底层语言叫做汇编，这是一个能操作到内存单元和寄存器的语言，但是过于复杂和繁琐。c语言操作单片机的优势在于它属于一门高级语言，比较易于理解，便于编写，而且单片机也会加深你对c语言的底层理解，所以说是学习单片机的一门比较好的语言。
如果你要打算做单片机，C语言你是早晚都需要学好的，但是并不需要把C语言学的非常好再去学单片机，把C语言基本语法和数据类型(基本数据类型和复合数据类型)学好，就差不多了。我觉得开始时候学C语言主要是为学单片机，方便做实验服务的，毕竟你要做单片机实验再用汇编就太没效率了，另外纯汇编编程以后基本不会再用到了。学单片机的核心还是单片机的接口和技术，比如IO原理、USART等通信接口、中断、内存分配、数据总线和时钟树、低功耗，以及一些电路知识等等，这些基础打好后在逐渐提高难度，比如TCPIP、文件系统、RTOS等。对做单片机来说，C语言是为单片服务的，C语言基础学好后，工作学习中遇到问题有目的的去更深度的学C语言，以及操作系统原理、编译原理、TCPIP协议等，在单片机和PC系统上的C语言编程思想是不一样的。总之两者是相辅相成循序渐进的，比如你用简单的51单片机可能你根本不需要多少C语言水平就够了，但是你如果用M7核的肯定需要的C语言水平就高了去了才能发挥它的性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424516ca53b4ad4bef37ed04f8795a88/" rel="bookmark">
			webpack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这东西想要学习好多次，但是都没有坚持啊学完，现在还是一头雾水，整备找教程学，但是好像和当前版本差别比较大，算了，这次跟着官方文档学，能学多少学多少。
概念 js程序的静态模块打包器，递归构建依赖关系图，其中包含程序包含的模块，把模块打包成一个或者多个bundle（捆，束缚）高度可配置，灵活性高四个核心概念 入口 输出 loader 插件 入口（entry） 简单，就是webpack从哪个模块开始构建依赖和打包，找相关依赖打包到dunles **单个入口的写法** *entry: string|Array&lt;string&gt;* 就是entry：字符创或者字符串数组 要在**webpack.config.js**里面写 module.exports = { entry: './path/to/my/entry/file.js' }; module.exports = config; 简写就不导出了
const config = { entry: { main: './path/to/my/entry/file.js' } }; tip 当你向 entry 传入一个数组时会发生什么？
向 entry 属性传入「文件路径(file path)数组」将创建“多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用。
chunk：n.厚块; 部分; 相当数量; 知识块
v.将…分成数份; 将…组合; 发出“砰啷”(或“嚓卡”)声; 抛; 扔; 切分; 切割
简单说 就是多个入口一起构建模块依赖，用字符串数组给多个入口，将会创建多个主入口，一起一来到chunk
对象语法复杂，但是使得入口定义可扩展
const config = { entry: { app: './src/app.js', vendors: './src/vendors.js' } }; app与vendor（第三方库）分离，创建的依赖图也彼此分离、相互独立
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/424516ca53b4ad4bef37ed04f8795a88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86b189ce591a0a1e33c2c0c3e1bf08cd/" rel="bookmark">
			生产环境CPU飙高问题解决，记一次完整解决过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.发现问题 前段时间我们新上了一个新的应用，因为流量一直不大，集群QPS大概只有5左右，写接口的rt在30ms左右。
因为最近接入了新的业务，业务方给出的数据是日常QPS可以达到2000，大促峰值QPS可能会达到1万。
所以，为了评估水位，我们进行了一次压测。压测过程中发现，当单机QPS达到200左右时，接口的rt没有明显变化，但是CPU利用率急剧升高，直到被打满。
压测停止后，CPU利用率立刻降了下来。
于是开始排查是什么导致了CPU的飙高。
二.排查问题 在压测期间，登录到机器，开始排查问题。
本案例的排查过程使用的阿里开源的Arthas工具进行的，不使用Arthas，使用JDK自带的命令也是可以。
在开始排查之前，可以先看一下CPU的使用情况，最简单的就是使用top命令直接查看：
top - 10:32:38 up 11 days, 17:56, 0 users, load average: 0.84, 0.33, 0.18 Tasks: 23 total, 1 running, 21 sleeping, 0 stopped, 1 zombie %Cpu(s): 95.5 us, 2.2 sy, 0.0 ni, 76.3 id, 0.0 wa, 0.0 hi, 0.0 si, 6.1 st KiB Mem : 8388608 total, 4378768 free, 3605932 used, 403908 buff/cache KiB Swap: 0 total, 0 free, 0 used.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86b189ce591a0a1e33c2c0c3e1bf08cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d168dd11c0d92661b7cb8913c520dcb/" rel="bookmark">
			git for windows疯狂占用内存、Pycharm使用git非常慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10系统，git for windows占用内存非常高，长时间位于30%以上。Pycharm指定git之后，可以快速对比当前修改的代码，但是也非常慢。
原因是git版本问题，当前版本是2.31。之前使用的是2.23，不会卡顿。直接搜索下载git2.23的wins安装包，安装即可，会提示你覆盖之前版本的git。安装之后就正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473002110591335303b5287fc67de514/" rel="bookmark">
			查看docker 容器的端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看docker 容器的端口
sudo netstat -tulpn | grep docker 查看指定端口，可以结合grep命令：
netstat -ap | grep 80
查找指定端口使用的pid
fuser 80/tcp
若要关闭使用这个端口的程序，使用kill + 对应的pid
kill -9 PID号
--------------------------------------------
Linux 下查看某个端口被哪个进程或程序占用。
netstat -anp|grep 3306
kill -9 进程号 可结束该进程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8aff8b3e1190138e8a031b97b7fe484/" rel="bookmark">
			sonarqube安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 . SonarQube代码质量检查工具简介 Sonar (SonarQube)是一个开源平台，用于管理源代码的质量
Sonar 不只是一个质量数据报告工具，更是代码质量管理平台
支持Java, C#, C/C++, PL/SQL, Cobol, JavaScrip, Groovy 等等二十几种编程语言的代码质量管理与检测。
Sonar可以从以下七个维度检测代码质量，而作为开发人员至少需要处理前5种代码质量问题。
不遵循代码标准
sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具规范代码编写。
潜在的缺陷
sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具检 测出潜在的缺陷。
糟糕的复杂度分布
文件、类、方法等，如果复杂度过高将难以改变，这会使得开发人员 难以理解它们, 且如果没有自动化的单元测试，对于程
序中的任何组件的改变都将可能导致需要全面的回归测试。
重复
显然程序中包含大量复制粘贴的代码是质量低下的，sonar可以展示 源码中重复严重的地方。
注释不足或者过多
没有注释将使代码可读性变差，特别是当不可避免地出现人员变动 时，程序的可读性将大幅下降 而过多的注释又会使得开发人员将精力过多地花费在阅读注释上，亦违背初衷。
缺乏单元测试
sonar可以很方便地统计并展示单元测试覆盖率。
糟糕的设计
通过sonar可以找出循环，展示包与包、类与类之间的相互依赖关系，可以检测自定义的架构规则 通过sonar可以管理第三方
的jar包，可以利用LCOM4检测单个任务规则的应用情况， 检测藕合。
为什么要选择sonarQube?
个人使用之后认为 : sonarQube的优势如下(相比于阿里编码规约这种市面上常见类似软件):
更加优秀的图形化界面
基本上通过界面就可以对自己项目的代码状况一目了然
可以查询出其它软件难以定位到的问题
比如 :
可能导致空指针异常的问题 (对象在进行使用前没有加空的判断)
可能导致内存泄漏的问题, 在try catch 块里面,直接使用e.printStackTrace()将堆栈信息打印到内存的
可能导致的漏洞 : 成员变量使用public定义的
还有诸如 : 流等未关闭或者是非正常关闭都能够检测出来!
功能非常强大!!
二. 安装： 2.1 安装SonarQube web server
首先确保安装了jdk1.8 +
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8aff8b3e1190138e8a031b97b7fe484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67482d99b30528b811d99dc67f4329b4/" rel="bookmark">
			c语言去字符串重复元素,[蓝桥杯][算法提高VIP]删除重复元素 （C语言代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解题思路:
我的思路就是使用一个数组来储存每一个字符出现的次数，最后判断对应位置上的数组元素是否为1(因为删除的重复元素且不相邻的也算)，例如：先设两个数组 char a[101]; int b[101](b的初始值全都为0);a用来储存输入的字符串，b用来判断字符串每一个位置上的字符串出现的次数。看下面例子：
a="432112",遍历这个字符串：第一个元素是4，那把b的4号位的元素加一(即0+1=1)；第2个元素是3，那么把b数组3号位的元素加1；第3个元素把b数组2号位元素值加一，第4个元素是1把b数组的1号位元素值加一，第5个元素是1，把b数组的1号位元素加一(注意此时b数组的1号位元素值为2，因为前面加过一次了)；后面原理一样。最终a、b数组的元素如下；元素
下标012345678字符串a432112\0
数组b2211
上面表格得出；不重复的元素只有3 4(因为出现次数均为1)
注意事项:
注意b数组的的含义
参考代码:#include #include #include #include #include #include #include #include #include #include using namespace std;
const int maxn=1&lt;&lt;8;
char p[maxn];
int str[maxn];
int main()
{
fgets(p, maxn, stdin);
for(int i = 0, len = strlen(p); i {
str[p[i]]++; //统计每一个字符出现的次数
}
for(int i = 0, len = strlen(p); i {
if(str[p[i]] == 1)
{
printf("%c", p[i]);
}
}
printf("\n");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67482d99b30528b811d99dc67f4329b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62780f4fde2868075f2c6d8e7693e78f/" rel="bookmark">
			c语言对比两个字符串相等,c语言中如何判断两个字符串相等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用库函数strcmp判断，具体如下：
strcmp是C语言比较字符串的库函数，形式为int strcmp(char *a, char *b);
该函数会对a和b的每个字符，按照ascii码值比较，如果二者完全相同返回0；如果a的ascii码值先出现较大者，会返回1；否则返回-1。
所以，要判断字符串相等，可以使用。
扩展资料：
关于上述strcmp()函数比较字符串的例子
#include #include int main(void)
{
char str_1[] = "abc";
char str_2[] = "abc";
char str_3[] = "ABC";
if (strcmp(str_1, str_2) == 0)
printf("str_1 is equal to str_2. \n");
else
printf("str_1 is not equal to str_2. \n");
if (strcmp(str_1, str_3) == 0)
printf("str_1 is equal to str_3．\n");
else
printf("str_1 is not equal to str_3．\n");
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a94875ad390f25630c8b9778ea4be3e/" rel="bookmark">
			ESP32的UART串口通信（基于micropython）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP32的UART串口通信（基于micropython） ESP32的UART串口通信（基于micropython）摘要软硬件环境正文I have an ESP32I have a 串口屏Ehn！ ESP32串口屏所有文件 碎碎念 摘要 关于esp32基于micropython开发的资料不多，如MicroPython 文档，里面的例程不多。在UART串口通信上的例程更少，故今日来分享一下个人的学习收获。
软硬件环境 硬件有ESP-WROOM-32，TJC3224K028_011串口屏，USB转串口模块，杜邦线若干
软件有thonny，正点原子的XCOM，USART HMI，win10系统，还需要装好串口驱动。
正文 I have an ESP32 我学习ESP32的途径主要有MicroPython 文档和randomnerdtutorials。
esp32 上有三对UART串口，一般情况下esp32开发板的串口0是用来烧录的，串口1接了外置sd卡，所以最好使用闲置的串口2，避免发生冲突，方便调试。
首先，初始化串口2，并设置波特率为115200。关于初始化串口，还有一些参数可添加，此处这两个就够了，详情可参考此处。
from machine import UART #　导入串口模块 uart = UART(2, 115200) #　初始化一个串口　然后通过几个函数，进行数据的收发。
uart.read() # 读取所有收到的信息 uart.write('abc') # 发送abc三个字符 关于发送数据，有点py基础的人应该都知道字符串前加上标识表是不同类型的字符，如：详情可参考此处
'\xff' # 默认字符串，该转义的会转义 u'\xff' # 同上 r'\xff' # 不转义字符串 b'\xff' # 二进制字符串 而对于串口屏的数据发送，最好还是采用b'\xff'的格式，否则会出现结束符无法被串口屏识别的情况。如
上图中有效的结束符只有第四句uart.write(b"\xff\xff\xff")，uart.write(r"\xFF\xFF\xFF")也不行，我试过了，反正用二进制发送准没错。
建议修改句也用二进制发送，以免出现莫名其妙不可预知的问题。
好了，此时基础的数据收发已经学会了，现在我们需要整串口屏了
I have a 串口屏 关于串口屏的学习建议参考此处，讲的非常清楚。
通过USART HMI搭一个用来演示的界面，图中蓝框选中的是数字控件n0，右下角选中的是控件所显示的值val，我们可以通过修改n0的val值n0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a94875ad390f25630c8b9778ea4be3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c8beeccdc4751aa6d40da2d69a57b8/" rel="bookmark">
			笔记-软件质量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 文字阴影
一 字体样缩写
font : 文字粗细 大小/行高 字体名称; font bold 20px/200px '微软雅黑'; 二 CSS3中的文字阴影
text-shadow: x y r color; text-shadow: 0px 0px 0px red; 注:
01 x表示阴影在水平方向的偏移量,可以设置负值,正负不表示大小, 只表示方向, 水平向右为正, 向左为负, 单位是px.
02 y表示阴影在垂直方向的偏移量,垂直向上为负,向下为正.
03 r表示阴影的模糊程度, 数值越大阴影月模糊, 单位px
04 color 表示阴影颜色
05 c3 允许一段文字有多层阴影, 多层之间用逗号隔开,每一层内,不同参数之间用空格隔开.
1.2 过渡属性
过渡属性的作用就是在元素的默认样式与最终样式变化之间产生一个过程。在 C3 中新增了一个属性叫 transition
Transition: all 1s linear 0s; 注:
01 第一个参数的作用是设置元素身上的哪些属性产生过渡，一般用 all 表示所有的属性都过渡。
02 第二个参数的作用设置过渡需要时长，单位是 s 不要省略
03 第三个参数的作用设置过渡的动画形式，linear 表示匀速
04 第四个参数设置当前过渡等待多久之后才会执行( 延时 )。即使为 0 ，单位也不能省。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72c8beeccdc4751aa6d40da2d69a57b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2226a8227bdff0040b43b4e6630670e/" rel="bookmark">
			linux怎么比较两个csv,linux awk比较两个csv文件并使用标志创建一个新文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有2个CSV文件,我需要比较并获得新格式化文件的差异.样品如下.
旧文件
DTL,11111111,1111111111111111,11111111111,Y,N,xx,xx
DTL,22222222,2222222222222222,22222222222,Y,Y,cc,cc
DTL,33333333,3333333333333333,33333333333,Y,Y,dd,dd
DTL,44444444,4444444444444444,44444444444,Y,Y,ss,ss
DTL,55555555,5555555555555555,55555555555,Y,Y,qq,qq
新文件
DTL,11111111,1111111111111111,11111111111,Y,Y,xx,xx
DTL,22222222,2222222222222222,22222222222,Y,N,cc,cc
DTL,44444444,4444444444444444,44444444444,Y,Y,ss,ss
DTL,55555555,5555555555555555,55555555555,Y,Y,qq,qq
DTL,77777777,7777777777777777,77777777777,N,N,ee,ee
输出文件
我想比较旧的和新的CSV文件,并找到在新文件中产生的更改,并更新标记以表示这些更改
U – 如果新文件记录是UPDATED
D – 如果旧文件中存在的记录在新文件中被删除
N – 如果新文件中存在的记录在旧文件中不可用
示例输出文件是这样的.
DTL,11111111,1111111111111111,11111111111,Y,Y,xx,xx U
DTL,22222222,2222222222222222,22222222222,Y,N,cc,cc U
DTL,33333333,3333333333333333,33333333333,Y,Y,dd,dd D
DTL,77777777,7777777777777777,77777777777,N,N,ee,ee N
我使用了diff命令,但它也会重复UPDATED记录,这不是我想要的.
DTL,11111111,1111111111111111,11111111111,Y,N,xx,xx
DTL,22222222,2222222222222222,22222222222,Y,Y,cc,cc
DTL,33333333,3333333333333333,33333333333,Y,Y,dd,dd
---
DTL,11111111,1111111111111111,11111111111,Y,Y,xx,xx
DTL,22222222,2222222222222222,22222222222,Y,N,cc,cc
5a5
DTL,77777777,7777777777777777,77777777777,N,N,ee,ee
我使用AWK单行命令来过滤掉我的记录
awk 'NR==FNR{A[$1];next}!($1 in A)' FS=: old.csv new.csv
这个问题是没有得到我只属于OLD文件的记录.
是的
DTL,33333333,3333333333333333,33333333333,Y,Y,dd,dd
我发起了一个驱动的bash脚本,以便对此进行讨论,但没有找到一个很好的例子.
myscript.awk
BEGIN {
FS = "," # input field seperator
OFS = "," # output field seperator
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2226a8227bdff0040b43b4e6630670e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a285e60f7705bed1fe6cbda486959eff/" rel="bookmark">
			linux怎么比较两个csv,在bash（Linux）中查找另一个csv中的值（如vlookup）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本上我有两个CSV文件(管分隔)：
file1.csv：
123 | 21 | 0452 | IE | IE | 1 | MAYOBAN | BRIN | OFFICE | STREET | MAIN STREET | MAYOBAN |
123 | 21 | 0453 | IE | IE | 1 | CORKKIN | ROBERT | SURNAME | CORK | APTS | CORKKIN |
123 | 21 | 0452 | IE | IE | 1 | CORKCOR | NAME | HARRINGTON | DUBLIN | STREET | CORKCOR |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a285e60f7705bed1fe6cbda486959eff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d90dbb35989cfc9c66ff7122b7f5834c/" rel="bookmark">
			东芝 rc100 linux,东芝RC100 M.2 NVMe固态硬盘HMB特性解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		东芝RC100是一款非常特殊的NVMe固态硬盘，它使用M.2 2242规格，单面PCB布局，能够安装在各种紧凑型笔记本电脑以及普通桌面电脑当中。除了独特的单芯片结构之外，它还是首个应用Host Memory Buffer主机内存缓冲的原厂固态硬盘。
观察结构图可以看到，东芝RC100芯片中封装了PCIE NVMe主控和闪存阵列两部分。闪存部分由多个最新一代64层堆叠技术制造的BiCS3闪存晶粒组成，PCIE NVMe主控内部则集成了小容量的SRAM缓存，没有独立的“外置缓存”芯片出现。
传统的无外置缓存SSD由于SRAM容量不足以容纳全部Look-up-Table闪存查找表数据，需要有独立的外置DRAM缓存芯片来确保性能的发挥，通常LUT表的容量配比是每1GB闪存存储空间需要搭配1MB的DRAM缓存容量。
而在HMB(Host Memory Buffer主机内存缓冲)技术的帮助下，东芝RC100可以调用部分系统内存作为第二LUT表使用。
东芝RC100的LUT查找表最终被分成了三部分，主控集成的SRAM能够直接管理大约1GB容量的范围，加上HMB主机内存缓冲后可以直接管理大约24GB的范围。超出HMB管理容量之外的LUT表则在NAND闪存当中存储。
针对不同大小的工作集，下图展现了在2-24GB范围内，HMB主机内存缓冲对于4K QD1随机读取性能的积极影响。
RC100可以根据数据热度动态调整主控SRAM以及HMB主机内存缓冲当中的LUT表，实现对缓存高效利用。
RC100最高只调用38MB系统内存，这样的设定能够在几乎所有PC平台下得到满足。或许有朋友会问，为何东芝不采用1GB:1MB的比例将完整的LUT查找表全部放入HMB主机内存缓冲当中?这是因为Windows操作系统架构上的限制，HMB使用的内存必须专用于非页面缓冲池，并且锁定到主机无法重新分配的特定物理地址，从而限制到主机内存的效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e75b5aa99ae5e45fae4c98206074b7/" rel="bookmark">
			c语言打印字母倒金字塔,打印字母金字塔，昨晚看到某个帖子的题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该楼层疑似违规已被系统折叠 隐藏此楼查看此楼
编程实现打印字母金字塔
如以下形式：
A
ABA
ABCBA
ABCDCBA
ABCDEDCBA
ABCDEFEDCBA
ABCDEFGFEDCBA
ABCDEFGHGFEDCBA
ABCDEFGHIHGFEDCBA
ABCDEFGHIJIHGFEDCBA
程序代码：
#include
#include
void print1(int i,int n);//打印每行的空格
void print2(int n);//打印字母
int main()
{
int n;
loop:printf("输入你要金字塔层数n:");
scanf("%d",&amp;n);/*输入金字塔的层数*/
if(n&gt;0&amp;&amp;n&lt;27)
{
print2(n);//打印金字塔
}
else
{
printf("您的输入有误0
goto loop;
}
return 0;
}
void print1(int i,int n)/*打印每层前半部和后半部的空格*/
{
while(n-i-1&gt;0)
{
printf(" ");
i++;
}
}
void print2(int n)
{ int i,j;
char *str;
printf("%d层字母金字塔:\n",n);
str=(char*)malloc(sizeof(char)*n);/*n层金字塔包含n个字母*/
str[0]='A';/*首字母为A*/
for(i=0;i
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e75b5aa99ae5e45fae4c98206074b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c54888c251e5525727ced416709cba/" rel="bookmark">
			linux device_create_file属性 怎么调用,device_create_file创建多级目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始写Linux设备驱动程序的时候，很多时候都是利用mknod命令手动创建设备节点(包括ldd3中不少例子也是这样)，实际上现在Linux内核为我们提供了一组函数，可以用来在模块加载的时候自动在/dev目录下创建相应设备节点，并在卸载模块时删除该节点。
内核中定义了struct class结构体，顾名思义，一个struct class结构体类型变量对应一个类，内核同时提供了class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面，一旦创建好了这个类，再调用device_create(…)函数来在/dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节点。
此外，利用device_create_file函数可以在/sys/class/下创建对应的属性文件，从而通过对该文件的读写实现特定的数据操作。
一、class_create
官方说明：
/* This is a
#define to keep the compiler from merging different
* instances of the __key variable */
#define
class_create(owner, name) \
({ \
static struct lock_class_key __key; \
__class_create(owner, name, &amp;__key); \
})
/**
* class_create - create a struct class
structure
* @owner: pointer to the module that is to
"own" this struct class
* @name: pointer to a string for the name of
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8c54888c251e5525727ced416709cba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ab5a26b549853e257f742c1c53d33cc/" rel="bookmark">
			《python程序设计题目》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python刷题 题目：第4章-9 查询水果价格 (15 分) 给定四种水果，分别是苹果（apple）、梨（pear）、桔子（orange）、葡萄（grape），单价分别对应为3.00元/公斤、2.50元/公斤、4.10元/公斤、10.20元/公斤。
首先在屏幕上显示以下菜单：
[1] apple [2] pear [3] orange [4] grape [0] exit
用户可以输入编号1~4查询对应水果的单价。当连续查询次数超过5次时，程序应自动退出查询；不到5次而用户输入0即退出；输入其他编号，显示价格为0。
输入格式:
输入在一行中给出用户连续输入的若干个编号。
输出格式:
首先在屏幕上显示菜单。然后对应用户的每个输入，在一行中按格式“price = 价格”输出查询结果，其中价格保留两位小数。当用户连续查询次数超过5次、或主动输入0时，程序结束。
输入样例1:
3 -1 0 2
输出样例1:
[1] apple
[2] pear
[3] orange
[4] grape
[0] exit
price = 4.10
price = 0.00
输入样例2:
1 2 3 3 4 4 5 6 7 8
输出样例2:
[1] apple
[2] pear
[3] orange
[4] grape
[0] exit
price = 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ab5a26b549853e257f742c1c53d33cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00088bfab93165b94b6e275a4e0a4504/" rel="bookmark">
			关于maven依赖的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用maven时配置JAVA所需依赖 为方便以后配置maven时的使用，将所需配置写在这里
&lt;properties&gt; &lt;spring.version&gt;4.3.7.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt; &lt;!--开源日志组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;!-- spring基本框架核心工具类，其他spring组件都需要依赖这个包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;!--包含配置文件，创建和管理bean --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00088bfab93165b94b6e275a4e0a4504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66ceab7b5cda92bcaa7e14bee41050c/" rel="bookmark">
			window10 电脑总是会从睡眠模式中自动唤醒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么会自动唤醒 可能是外部设备的原因，鼠标，键盘，耳机的插拔，蓝牙的连接。也可能是软件程序或唤醒计时器（wake timer）。
怎么停止 1）进入电源和睡眠设置，可以通过 设置-》系统-》电源和睡眠进入，或搜索栏搜索 电源和睡眠设置。
2）进入界面后，选择其他电源设置-》更改计划设置-》更改高级电源设置
3）选择列表里的睡眠-》允许使用唤醒定时器-》选择禁用；然后，应用。
这样之后，就可以制止 软件程序 或 操作系统 有消息通知你而自动唤醒，当然也可以选择仅限重要的计时唤醒器
由于其他的原因，也可能会自动唤醒。
怎么查看谁导致了自动唤醒 搜索栏输入cmd，选择以管理员身份运行，打开cmd窗口
1）报告有关从上次睡眠转换中 唤醒系统的信息。
powercfg /lastwake 键盘鼠标唤醒输出： C:\Users\aaa&gt;powercfg /lastwake 唤醒历史记录计数 - 1 唤醒历史记录 [0] 唤醒源计数 - 1 唤醒源 [0] 类型: 设备 实例路径: PCI\VEN_8086&amp;DEV_A2AF&amp;SUBSYS_50071458&amp;REV_00\3&amp;11583659&amp;1&amp;A0 友好名称: Intel(R) USB 3.0 可扩展主机控制器 - 1.0 (Microsoft) 描述: 符合 USB xHCI 的主机控制器 制造商: 通用 USB xHCI 主机控制器 网卡唤醒输出： C:\Users\aaa&gt;powercfg /lastwake 唤醒历史记录计数 - 1 唤醒历史记录 [0] 唤醒源计数 - 1 唤醒源 [0] 类型: 设备 实例路径: PCI\VEN_10EC&amp;DEV_8168&amp;SUBSYS_E0001458&amp;REV_16\4&amp;1cfe19ee&amp;0&amp;00E0 友好名称: Realtek Gaming GbE Family Controller 描述: Realtek Gaming GbE Family Controller 制造商: Realtek 2） 枚举活动的唤醒计时器。查看是否有任务或进程被运行，将会唤醒电脑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a66ceab7b5cda92bcaa7e14bee41050c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad9e02d88ce310152b93bf9ca82fab67/" rel="bookmark">
			c语言程序设计形成性作业3,C语言程序设计形成性作业3–4.doc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言程序设计形成性作业3–4
C语言程序设计形成性作业三
选择题
1.在下面的(C)函数声明语句存在语法错误。
A．AA(int a,int b); B．AA(int ,int) C．AA(int a;int b) D．AA(int a,int)
2．在下面的(C)不能作为函数的返回类型。
A．void B．int C．new D．long
3．下面正确的函数原型语句是(B)。
A．int Function(void a); B．void Function(int);C．int Function(a); D．void int(double a);
4．函数调用func(exp1,exp2),exp3*exp4-exp5)中所含实参的个数为(B)个。
A．1 B．2 C．4 D．5
5．下面的标识符中，(C)是文件级作用域。
A．函数形参 B．语句标号 C．外部静态类标识符 D．自动类标识符
6．下面的标识符中，(B)具有全局级作用域。
A．函数形参 B．全局变量 C．内部静态类标识符 D．自动变量符
7．假定p是一个指向float型数据的指针，则p+1所指数据的地址比p所指数据的地址大(C)字节。
A．1 B．2 C．4 D．8
8．假定a为一个字符数组名，则a[8]的地址比该数组的首地址大(B)个字节。
A．4 B．8 C．16 D．32
9．假定a为一个数组名，则下面的(B)表示有错误。
A．a[i] B．*a++ C．*a D．*(a+1)
10．用calloc函数创建具有10个整型元素的一维数组的正确语句是(C)。
A．int *p=calloc(10,2); B．int *p=callo(10;
C．int *p=calloc(10,4); D．int *p=malloc(10);
11．假定变量m定义为“int m=7;”，则定义p的正确语句为(B)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad9e02d88ce310152b93bf9ca82fab67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d4309df7ac1b293aca5ad6b31c1386/" rel="bookmark">
			c语言倒字母金字塔,C语言编程实现可移动的“字母金字塔”程序教学探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言
程序的效果是要在屏幕上产生一个如图1所示的“字母金字塔”在屏幕上完成从左至右的移动的动态过程。
这个问题的解决,我们按照下面几个步骤来完成:
2 首先按照先易后难的原则,编程完成一个静态的“字母金字塔”
可以用循环及循环的嵌套来实现。
(1)首先这个金字塔是由26行组成,可设一个循环变量i来控制行的变化,i依次由1循环变到26,这是一个外层循环,i增加1,就输出打印出一行的全部内容。
(2)当行i确定后,每一行里又是由若干个空格和若干个字符组成,这可用二个内层循环来实现。假设用j来控制每一行里的空格数,用k来控制每一行里的字符数,下面我们列表来分析一下,当行i确定以后,每一行里最大空格数、最大字符数、字符对应的A S C I I码的变化规律C。
行数i空格数j字符数k字符的ASCII码
显然当外层循环i值确定后,内层空格j循环的终值为26-i,内层字符数k循环的终值为2*i-1,对应同行上的字符的a s c i i码值为:65+i-1即64+i。这样我们就可以方便地写出实现这个静态的“字母金字塔”的C程序的源代码如下:
{
{
}
}
3完成可在屏幕上向右移动的“字母金字塔”
可以这样来考虑,每执行一次上面的循环可完成一个“字母金字塔”。我们可再设计一个更外层的循环,每循环一次将“字母金字塔”整体向右移动一个空格,也就是
每一行的空格数增加一个,然后将前面一个“金字塔”清屏删除掉,为产生下一个向右整体移动一格的“字母金字塔”做准备。
因此我们在上面的源程序i循环变量的外面再设计一个循环变量kk来控制“字母金字塔”向右移动的空格数,例如移动100个空格,这样我们可以让kk从1变到100,终值为100,k k每循环一次,上面的循环执行一次。完成一次k k循环后,就会生成一个完整的“字母金字塔”,然后我们要清屏删除掉(可用D o s的清屏命令来实现:system(“cls”);),以便供下一个整体向右移动一格的“字母金字塔”生成。最后整个“字母金字塔”在屏幕上就完成了向右移动的过程。
实现这个功能的源程序代码如下:
{
{
for(i=1;i&lt;=26;i++)
{
}
}
}
4结语
通过这个程序的实现,可以让学生体会C语言的循环及循环的嵌套功能非常强大,它能实现很多意想不到的功能,“只有你想不到的,没有它做不到的”,从而提高学生学习C语言的积极性,为今后编程打下坚实的基础。C语言编程实现可移动的“字母金字塔”程序教学探讨@江军$电子科技大学成都学院!四川成都611731本文是关于学生在学习了C语言循环及循环嵌套的知识后,为了增加学生学习的兴趣性,应用所学知识编程实现一个可移动的"字母金字塔"的程序探讨。C语言;;编程;;教学
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d3eca7b8db24593c8d78a94c845fe2/" rel="bookmark">
			c语言字母正倒金字塔,C语言倒金字塔解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言倒金字塔
初学，研究了半个多小时才写出来的，两边数字对称倒金字塔程序！共勉之！
实现效果：
12321
121
1
代码如下：
#include int main(void)
{
int number;
int i,j,k,n,m,temp;
printf("请输入要打印的层数:");
scanf("%d",&amp;number);
temp = (number*2)-1;
for (i = number; i &gt; 0; i--)
{
for (k = i; k {
printf(" ");
}
n = 0;
for (j = 0; j {
if (j n++;
if (j &gt;= i )
n--;
printf("%d",n);
}
temp-=2;
printf("\n");
}
return 0;
}
------解决思路----------------------
仅供参考#include char s[]="15141312111098765432123456789101112131415";
int n,y;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9d3eca7b8db24593c8d78a94c845fe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9be39107d0b1744400fd971d6cf3c4/" rel="bookmark">
			Vue结合element-ui实现省市区三级区域联动选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明： 代码自带地区JSON数据，由于篇幅限制，只放了部分地区数据，完整地区数据或者vue组件模式代码github地址
效果：
代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="author" content="LF" /&gt; &lt;meta name="description" content="" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css" /&gt; &lt;title&gt;地址选择&lt;/title&gt; &lt;style&gt; #app[v-cloak] { display: none; } .width300 { width: 300px; } .address-info span { display: inline-block; width: 20%; text-align: center; margin-bottom: 20px; cursor: pointer; } .address-info span.active { font-weight: bold; color: #970022; } .address-info span:hover { font-weight: bold; color: #970022; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee9be39107d0b1744400fd971d6cf3c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86d4da15be0af35810a0eae4d7a0fcb5/" rel="bookmark">
			shell脚本实现服务监控报警并重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一篇 使用crontab指令的shell脚本实现服务监控报警重启 这两天做了一个服务监控报警重启的脚本。本质就是用一个shell命令去监控服务状态，如果宕机就会自动重启，并向指定邮箱发送邮件对管理人员进行提醒，再使用crontab命令设置每隔一分钟运行一次这个shell脚本，实现对服务的监控。
本来很简单，以为半天就能实现，结果问题出在了发送邮件上，硬生生的搞了两天，才在部门其他大神的帮助下搞定，所以在此总结下。
首先先写一个简单的监控服务的shell脚本，公司在服务器上跑的是以jar包的形式，为了方便测试，我就随便找了一个jar包，命名为1.jar
直接新建编辑一个moni.sh 脚本文件
vi moni.sh 在moni.sh中进行编辑
run=$(ps -ef |grep "1.jar" |grep -v "grep") if [ "$run" ] ; then echo "The service is alive!" else echo "系统宕机" | mail -s "警告" 2364******@qq.com #接收人邮箱地址 echo "The service was shutdown!" echo "Starting service ..." nohup java -jar 1.jar &amp; echo "The service was started!" fi 再对crontab命令进行设置
crontab -e 直接会进入编辑页面，输入以下代码设置间隔时间自动运行
*/1****bash /home/wangzh/moni.sh #设置为每间隔1分钟执行一次脚本 @reboot nohup java -jar 1.jar &amp; #每当系统重启时都会自动运行服务 linux发送邮件很简单，它自带有发送邮件的mail，一开始我使用mail进行发送邮件发现不成功；就想通过linux的sendmail来发送，这个需要使用yum下载sendmail的rpm包，且配置十分麻烦，最后由于种种原因放弃了，回归linux自带的mail发送邮件方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86d4da15be0af35810a0eae4d7a0fcb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3575972f3a08300a710d0ff8c3af99/" rel="bookmark">
			nvidia linux 指令,Linux 如何用指令查詢 Nvidia 驅動程式版本與 GPU 顯示卡資訊？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		這裡介紹幾種在 Linux 系統上使用指令查詢 Nvidia 驅動程式版本以及 GPU 顯示卡資訊的方法。
nvidia-smi 指令工具
Nvidia 所提供的 nvidia-smi(NVIDIA System Management Interface)管理工具可以直接查詢驅動程式與顯示卡的資訊：nvidia-smiTue Feb 14 15:43:58 2017
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 375.26 Driver Version: 375.26 |
|-------------------------------+----------------------+----------------------+
| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC |
| Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. |
|===============================+======================+======================|
| 0 GeForce GTX 106... Off | 0000:03:00.0 Off | N/A |
| 28% 29C P0 27W / 120W | 0MiB / 6072MiB | 0% Default |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd3575972f3a08300a710d0ff8c3af99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5b69d325621bb4c872c476f869a419/" rel="bookmark">
			计算机网络：物理层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Contents 物理层的基本服务功能物理层协议的类型基于点-点通信线路的物理层协议基于广播通信线路的物理层协议 数据通信的基本概念信息、数据与信号信息与编码数据通信方式传输介质的主要类型与特性数据编码分类 多路复用技术 物理层的基本服务功能 物理层处于OSI参考模型的最低层，它向数据链路层提供比特流传输服务。
连接物理层的传输介质可以有不同类型，如电话线、同轴电缆、光纤与无线通信线路，不同类型的传输介质对于被传输的信号要求也不同。
研究人员需要针对不同类型的传输介质和通信技术的特点，制定与之相适应的物理层协议。因此设置物理层的目的是屏蔽物理层所采用的传输介质、通信设备与通信技术的差异性，使数据链路层只需要考虑如何使用物理层的服务。
物理层协议的类型 物理层协议可分为两类：基于点-点通信线路的物理层协议与基于广播通信线路的物理层协议。
基于点-点通信线路的物理层协议 EIA-232-C标准是基于点-点电话线路的串行、低速、模拟传输设备的物理接口标准，目前很多低速的数据通信设备仍然采用这种标准。
随着Internet接入技术的发展，家庭接入主要通过ADSL调制解调器与电话线路接入，通过线缆调制解调器（Cable Modem）与有线电视电缆接入。ADSL物理层协议定义了上行与下行传输速率标准、传输信号的编码格式与电平、同步方式、连接接口装置的物理尺寸等内容。
基于广播通信线路的物理层协议 广播通信线路可分为有线通信线路与无线通信线路
最早的Ethernet是在共用总线的同轴电缆上用广播的方式发送和接收数据。
无线网络采用广播方式发送和接收数据。
数据通信的基本概念 信息、数据与信号 信息：传统的信息主要指文本或数字类信息。现在逐步发展到包含语音、图形、图像与视频等多种类型的多媒体信息。信息的载体可以是文字、语音、图形、图像或视频。
数据：计算机为了存储、处理和传输信息，首先要将表达信息的字符数字、语音、图形、图像或视频用二进制数据表示。计算机存储与处理的事二进制代码。
信号：通信系统中，二进制代码0/1比特序列必须变换成用不同电平会频率变化的信号之后才能用传输介质传输。
信息与编码 目前，应用最广泛的是美国信息交换标准编码ACSII码。二进制编码按高位到低位（共7位）顺序排列，最高的第八位一般用于字符的校验。
数据通信方式 在传输介质上传输的信号类型有两种：模拟信号与数字信号。
电平幅度连续变化的电信号成为模拟信号，人的语音信号属于模拟信号。传统的电话线用来传输模拟信号。
计算机产生的电信号是用两种不同电平表示0,1比特序列电压跳变的脉冲信号，称为数字信号。
如果通信信道不允许直接传输计算机所产生的的数字信号，那么就需要在发送端将数字信号变换成模拟信号，在接收端再将模拟信号还原为数字信号，这个过程称为调制/解调。
信道与线路是不同的概念：如一条光纤去连接两台路由器，那么这条光纤称为一条通信线路。光纤的带宽很宽，会采用多路复用的方法，在一条线路上划分出多条通信信道，用于发送与接收数据。因此，一条线路包含一条或多条信道。
通信方式主要有串行通信与并行通信，单工、半双工与全双工通信，同步技术。
串行通信只需在收发方之间建立一条通信信道。并行通信则建立多条通信信道，并行通信在单位时间内所传送的码元数是串行通信的n倍。并行通信造价较高，因此远程通信一般采用串行通信。
单工、半双工与全双工通信
同步技术。数据通信的同步包括位同步、字符同步。接收端根据发送端发送数据的时钟频率与比特流的起始时刻，校正自己的时钟频率与接收数据的起始时刻，这个过程称为位同步。实现位同步的方法有内同步法与外同步法。保证收发双方正确传输字符的过程叫做字符同步。实现方法有同步传输、异步传输（同步通信比异步通信的传输效率高，因此同步通信更适用于高速数据传输。）
传输介质的主要类型与特性 双绞线
双绞线是局域网中最常用的传输介质。分为屏蔽双绞线和非屏蔽双绞线。每条导线相互绞合的目的是为了使通信线路之间的电磁干扰达到最小。
同轴电缆
同轴电缆是早期的传输介质，由内导体、绝缘层、外屏蔽层及外部保护层组成。特点是抗干扰能力强。
光纤
光纤是传输介质中性能与应用最好的一种。光纤传输有两种模式。
单模光纤，光信号仅与光纤轴成单个可分辨角度的单路光载波传输。多模光纤，光信号与光纤轴成多个可分辨角度的多路光载波传输。单模光纤的性能优于多模光纤 光纤最基本的连接方式是点-点连接，光纤不熟外界电磁干扰与噪声的影响，在长距离、高速率的传输中保持低误码率。随着光纤应用范围扩大，出现了多种以光纤为传输介质的物理层标准。了解光纤的物理层标准，需要注意以下问题。
影响光纤传输距离的因素主要是传输模式、光载波频率、光纤尺寸。物理层协议规定的物理参数主要包括：传输模式、上行光纤与下行光纤光载波的频率、光线尺寸、光接口，以及光纤最大传输距离。 由于单根光纤可能因为外力作用导致弯曲形变，所以需要用其他高强度材料将多根光纤包裹组成光缆。
缆芯是光缆的主体，它包含多根光纤。中心加强芯从来加强光缆的抗拉强度。护套是光缆的外部保护层。
无线与卫星通信技术
不同频率的电磁波可以分为无线、微波、红外、可见光、紫外线、X射线与γ射线。目前,用于通信的主要有无线、微波、红外与可见光。描述电磁波的参数有三个:波长、频率与光速，三者关系为：波长 * 频率 = 光速。
移动物体与固定物体、移动物体与移动物体之间的通信都属于移动通信，例如人、汽车、轮船、飞机等移动物体之间的通信。支持移动物体之间通信的系统主要是:无线通信系统、微波通信系统、蜂窝移动通信系统、卫星移动通信系统。
无线通信：国际通信组织对各个频段都规定了特定的服务。以高频HF为例，频率在3MHz~ 30MHz之间，被划分成多个特定的频段，分别分配给移动通信(空中、海洋与陆地)、广播、无线电导航、业余电台、宇宙通信与射电天文等方面。微波通信：在电磁波谱中，频率在100MHz~ 10GHz的信号称为微波，对应的信号波长为3cm~3m。只能进行视距传播，大气对微波信号的吸收与散射影响较大。蜂窝无线通信：为了提高覆盖区域的系统容量与充分利用频率资源，人们提出了小区制的概念。小区制是将一个大区覆盖的区域划分成多个小区，在每个小区中设立一个基站，用户手机通过基站接人到移动通信网。小区覆盖的半径较小(一般为1~20km)，可以用较小的发射功率实现双向通信。卫星通信：由于卫星通信具有通信距离远、覆盖面积大、不受地理条件限制、费用与通信距离无关、可进行多址通信与移动通信的优点，因此卫星通信在近年来得到迅速发展，成为现代主要的通信手段之一。 数据编码分类 将发送端的数字信号变换成模拟信号的过程称为调制。实现调制功能的设备称为调制器。
将接收端的模拟信号还原成数字信号的过程称为解调，实现解调功能的设备称为解调器。
模拟数据信号编码方法
振幅键控（ASK）：通过改变载波信号振幅来表示数字信号1、0。ASK信号实现容易、技术简单但抗干扰能力较差。移频键控（FSK）：通过改变载波信号角频率来表示数字信号1、0。FSK信号实现容易、技术简单，抗干扰能力较强，是目前最常用的调制方法之一。移相键控（PSK）：通过改变载波信号的相位值来表示数字信号1、0。如果用相位的绝对值表示数字信号1、0，则称为绝对调相。如果用相位的相对偏移值表示数字信号1、0，则称为相对调相（两比特信号交界处遇0，载波信号相位不变，；两比特信号交接处遇1，载波信号相位偏移π）。 为了提高数据传输速率。人们常采用多相调制的方法，称为正交相移键控(QPSK）。 波特率的定义
调制速率描述通过模拟线路传输模拟数据信号过程中，从调制解调器输出的调制信号每秒钟载波调制状态改变的数值，单位是1/s，称为波特(baud)。调制速率也称为波特率，波特率描述的是码元传输的速率。
比特率的定义
数据传输速率描述在计算机通信中每秒传送的构成代码的二进制比特数，单位是bps，因此也可以称为比特率。
比特率和波特率的关系
比特率S(单位为bps)与调制速率B(单位为baud)之间关系可以表示为: S=B * log₂k。式中k为多相调制的相数。log₂k 值表示次调制状态的变化传输的二进制比特数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5b69d325621bb4c872c476f869a419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c086bf381868ff2b7fb8d628fd7cb193/" rel="bookmark">
			flink1.12.3&#43;python3.7&#43;pyflink实时消费kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境介绍
二、思路梳理
三、启动zookeeper、kafka、flink集群（本地）等步骤省略
四、数据生成器（这个测试的时候用的python2，问题不大）
五、pyflink实时读流
六、提交作业
七、一些异常和报错
一、环境介绍 centos7、anaconda的虚拟环境python3.7、官网原生flink1.12.3、官网原生kafka_2.12-2.7.0、官网原生apache-zookeeper-3.6.3-bin
开始想用python2来搞，但是问题比较多，参看官网，python2.7只能支持到flink1.9.3，后面的tableAPI没有什么支持。
二、思路梳理 写一个数据生成器往kafka里面生产数据——&gt;pyflink实时消费kafka的流数据
三、启动zookeeper、kafka、flink集群（本地）等步骤省略 四、数据生成器（这个测试的时候用的python2，问题不大） # --coding=utf8-- import kafka # 循环向kafka写数 import datetime import time kp=kafka.KafkaProducer(bootstrap_servers="localhost:9092") for i in range(0,100): kp.send(topic="haha",value="test_"+datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")) time.sleep(1) kp.flush() kp.close() 五、pyflink实时读流 pip install apache-flink==1.12.0
此处参考了一个前辈的代码，这里根据个人需要测试，进行了修改，原文在这：
pyflink消费kafka-connect-jdbc消息(带schema) - 知乎
#--coding=utf8-- from pyflink.datastream import StreamExecutionEnvironment from pyflink.table import StreamTableEnvironment, TableConfig # 1.创建执行环境 s_env = StreamExecutionEnvironment.get_execution_environment() s_env.set_parallelism(1) st_env = StreamTableEnvironment.create(s_env, TableConfig()) st_env.get_config().set_python_executable("python3") # 2.利用实时流建表，format的raw应该表示的是非格式化的原生内容（raw的单词意思） ddlKafkaConn = """ create table sourceKafkaConn( `CREATE_TIME` STRING comment '行数据' ) with( 'connector' = 'kafka', 'topic' = 'haha', 'properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c086bf381868ff2b7fb8d628fd7cb193/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbe686d9c2c0adf1e71f4ddf0cd8a6f/" rel="bookmark">
			ubuntu linux关闭防火墙命令,Linux 命令详解（十三）如何启动、关闭和设置ubuntu防火墙...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo ufw enable|disable
由于LInux原始的防火墙工具iptables过于繁琐，所以ubuntu默认提供了一个基于iptable之上的防火墙工具ufw。
ubuntu 9.10默认的便是UFW防火墙，它已经支持界面操作了。在命令行运行ufw命令就可以看到提示的一系列可进行的操作。
最简单的一个操作：sudo ufw status可检查防火墙的状态，我的返回的是：不活动
sudo ufw version防火墙版本：
ufw 0.29-4ubuntu1
Copyright 2008-2009 Canonical Ltd.
ubuntu 系统默认已安装ufw.
1.安装
sudo apt-get install ufw
2.启用
sudo ufw enable
sudo ufw default deny
运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。关闭所有外部对本机的访问，但本机访问外部正常。
3.开启/禁用
sudo ufw allow|deny [service]
打开或关闭某个端口，例如：
sudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口
sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口
sudo ufw allow 53 允许外部访问53端口(tcp/udp)
sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口
sudo ufw allow proto udp 192.168.0.1 port 53 to 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cbe686d9c2c0adf1e71f4ddf0cd8a6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7a19aa4dd39ebd670d3cdd7150cd0ee/" rel="bookmark">
			微信小程序使用async 语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在原生的微信小程序项目中需要把原来es6的promise方法改成es7的async await，这样代码看起来更直观，也方便以后的兄弟维护，但是改了代码之后项目就报错了。;
提示的错误是：regeneratorRuntime is not defined 1.解决步骤
勾选ES6转ES5 2.下载 facebook的regenerator库中的regenerator/packages/regenerator-runtime/runtime.js
请注意：这里的给出的库是指定版本的，不要下载最新的。 3.在小程序目录下新建文件夹 lib/runtime/runtime.js，将代码拷贝进去。
4在每一个需要使用async语法的页面js文件中，都引入（不能全局引入），只需要引入，不需要调用。
import regeneratorRuntime from '../../lib/runtime/runtime'; 最后就可以正常使用了async语法处理异步请求了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00c18e42ef801306dbca40a5996ef98/" rel="bookmark">
			树莓派综合项目2：智能小车（三）无线电遥控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 阅读本篇文章前建议先参考前期文章：
树莓派基础实验34：L298N模块驱动直流电机实验
树莓派综合项目2：智能小车（一）四轮驱动
树莓派综合项目2：智能小车（二）tkinter图形界面控制
《智能小车（一）四轮驱动》中，实现了代码输入对四个电机的简单控制。《智能小车（二）tkinter图形界面控制》中，实现了本地图形界面控制小车的前进后退、转向和原地转圈。
本实验中将使用无线电遥控设备控制小车的前进后退、转向和原地转圈。使用传统无线电通信设备通信仍然是非常重要的通信方式，比如无线电台、对讲机，航模、车模、船模遥控等等。与手机移动网络、WIFI连接相比，无线电连接有它独特的优势，遥控距离远，实时性好，操作灵活，不受网络信号限制。
其它基础内容可以参考文集：树莓派基础实验。
二、组件 ★Raspberry Pi 3 B+全套*1
★睿思凯Frsky XM+ 迷你接收机*1
★电平反向器模块*1
★睿思凯Frsky Taranis X9D PLUS SE2019遥控器*1
★L298N扩展板模块*1
★智能小车底板模块*1
★减速电机和车轮*4
★跳线若干
三、实验原理 本实验中使用的遥控系统可以自行选择其它品牌的产品，如国产的天地飞还不错。
这里的遥控器就是像电视机遥控器、空调遥控器一样可以不用接触到被控设备，而通过一个手持器件，使用无线电与被控设备进行通信，从而达到对设备的控制。
遥控器想到达到与小车通信的功能需要有两部分配合完成。即：发射器（遥控器）与接收机。遥控器上的控制杆转为无线电波发送给接收机，而接收机通过接收无线电波，读取遥控器上控制杆的读数，并转为数字信号发送到树莓派中。
接收机输出两种信号，一种是模拟信号PWM，一种是SBUS数字信号。
由于每一路遥控器通道都需要一个PWM采集器进行采集，但是对于树莓派来说不可能使用多个定时器来采集多个通道的PWM，这对于树莓派的GPIO端口资源来说十分浪费，因此我采用的就是SBUS信号，可以在一个管脚中传输多路控制信号。
S-BUS其实是一种串口通信协议，采用100000的波特率，数据位点8bits，停止位点2bits，偶效验，即8E2的串口通信。使用树莓派的串口GPIO（TXD/RXD）中的RXD端口接收接收机的SBUS输出信号，解析出每路通道的控制信号，进而控制小车行进。
但是S-BUS采用的是反向电平传输，也就是说，在S-BUS的发送端高低电平是反向的，协议中的所有高电平都被转换成低电平，协议中的所有低电平都被转换成高电平。所以在S-BUS的接收端需要增加一个高低电平反向器来进行电平反转。
关于解析无线电接收机PWM、SBUS信号的更详细内容，请参考树莓派基础实验39：解析无线电接收机PWM、SBUS信号。
四、实验步骤 第1步： 连接电路。在树莓派综合项目2：智能小车（一）四轮驱动中的接线基础上，接入电平反向器、无线电接收机。
树莓派（name）树莓派（BOARD）L298N小车扩展板GPIO.011ENAGPIO.213IN1GPIO.315IN2GPIO.112ENBGPIO.416IN3GPIO.518IN4GNDGND电池组供电负极 关于这里树莓派GND、L298N小车扩展板的电池组供电负极相连，是特殊情况下的情况，经测试发现：
如果树莓派用的是充电头供电，而L298N扩展板用的是电池组供电，这两个负极必须相连，否则马达不动。
如果树莓派用的是L298N扩展板接出来的5V供电，即两者同一个电源，则这里不用连接。
L298N小车扩展板电池组树莓派电压表头马达电池+（-）电池+（-）5V供电电源接口+（-）+（-）T1（L后）+（-）T2（L前）+（-）T3（R前）+（-）T4（R后）+（-） 树莓派（name）树莓派（BOARD）电平反向器无线电接收机A6SBUS_OUTRXD10B63.3V1VCC0V9GND5V2VCC0V14GND 这里也要注意，由于树莓派的GPIO只能接收3.3V的最高输入，所以电平反相器的电源也只能使用3.3V，若反向后接收的信号需要是5V，则电平反相器的电源就使用5V。
这里我将18650电池组换成了航模使用的格氏ACE锂电池（3S/11.1V/2200MAH/40C），电压更高，能给树莓派提供更稳定的电源，动力性也更好，效果非常不错。
第2步： 编写电机的驱动程序，文件名为motor_4w.py。与树莓派综合项目2：智能小车（一）四轮驱动中的程序完全相同。
该车的行进控制与履带车的行进控制类似：
前进和后退很简单，左右两边的方向都朝前或朝后，速度一致；
原地顺时针旋转时，左边轮子前进，右边轮子后退，速度一致；
原地逆时针旋转时，左边轮子后退，右边轮子前进，速度一致；
偏左前进时，左右两边的方向都朝前，左轮速度比右轮速度慢一点；
偏右前进时，左右两边的方向都朝前，左轮速度比右轮速度快一点；
偏左后退时，左右两边的方向都朝后，左轮速度比右轮速度慢一点；
偏右后退时，左右两边的方向都朝后，左轮速度比右轮速度快一点；
motor_4w.py：
#!/usr/bin/env python #-*- coding: utf-8 -*- #本模块只含SMPcar()一个类，用于树莓派对电机信号的控制 #通过GPIO输出信号，直接对某个电机的转动方向、速度进行控制 import RPi.GPIO as GPIO class SMPcar(): '''控制小车四轮动作的类''' ENA = 11 #使能信号A，左边两轮 IN1 = 13 #信号输入1 IN2 = 15 #信号输入2 ENB = 12 #使能信号B，右边两轮 IN3 = 16 #信号输入3 IN4 = 18 #信号输入4 GPIO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00c18e42ef801306dbca40a5996ef98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414a999bf3c102c387e1c08d5721b24e/" rel="bookmark">
			@Autowired注解位置、@Autowired与@Resource的区别与注入流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc] 常用注解注释位置(@Autowired放置在构造器上与放在属性上的区别)对成员变量注释对构造函数注释对成员方法注释@Autowired和构造方法执行的顺序 @Autowired与@Resource注入方式(注意)基于Setter的依赖注入基于构造函数的依赖注入基于setter的依赖注入缺点 @Autowired注入流程 @Resource注入流程 @Configuration与@Bean spring Bean单例下的并发问题 常用注解 注释位置(@Autowired放置在构造器上与放在属性上的区别) @Autowired 可以对成员变量、方法以及构造函数进行注释
对成员变量注释 相当于在配置文件中配置bean，并且使用setter注入。
对构造函数注释 就相当于是使用构造函数进行依赖注入
对成员方法注释 如果方法中有实体参数，会对方法里面的参数进行装配，并调用一次该方法
@Component public class User { } @Component public class MyTest { @Autowired public void myAutowired1(){ System.out.println("运行了myAutoWired1"); } @Autowired public void myAutowired2(User user){ System.out.println("运行了myAutoWired2,user="+user); } } 运行了myAutowired1 运行了myAutoWired2,user=com.chieng.boot.demo.User@4ce1d99f @Autowired和构造方法执行的顺序 Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法
类加载顺序规定先加载构造方法，再加载普通方法，当构造器中使用到属性时，会发现属性还没有被实例化，则会报错，因此，当构造方法中用到了属性时，应该将注解加在构造器上；
这段代码会报NPE， @Autowired private User user; private String school; //因为会先执行构造函数，再执行上面的依赖注入，故NPE public UserAccountServiceImpl(){ this.school = user.getSchool(); } 当构造方法中用到了属性时，应该将注解加在构造器上,如下 private User user; private String school; @Autowired public UserAccountServiceImpl(User user){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/414a999bf3c102c387e1c08d5721b24e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b146baef879400618056692ae26269/" rel="bookmark">
			AntiAliasing学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 MSAA是直接硬件支持的，使用pattern在一个像素上做多次fragment计算，最后对去结果做平均的方式，这是在输出之前对结果做滤波，但是这个方法的缺点是占用的显存会变成原来的pattern采样点的倍数。当然这个MSAA多重采样的性质也可以用到别的需要这个这特特性的地方，比如Voxel化
FXAA和SMAA都是形态学方法抗锯齿，简单而言就是找到边界，在边界位置做低通滤波，即采样求平均值，就可以做到抗锯齿
TAA则是采用Temporal的方法，做时间上的滤波，需要注意上一帧的数据在当前帧是否被遮挡住了
FXAA FXAA的核心思路就是查找当前边界并做滤波，通常称为形态学方法，实现参考FXAA3.11
边缘检测用灰度值，或者要效率高点直接使用Green通道也行，虽然效果会差一点（其实可以看颜色频谱分布，绿色在中间，而且所占的频谱范围更广）
Local Contrast Check: 采样上下左右的点的灰度值，计算出最大contrast，如果对比度不大，就可以直接判断当前像素点不在边缘上
l.contrast &lt; max(_ContrastThreshold, _RelativeThreshold * l.highest); Sub-pixel Aliasing Test: 对当前像素周围所有像素，计算当前的Sub-pixel混合权重，让blend更平滑一点
float DeterminePixelBlendFactor (LuminanceData l) { float filter = 2 * (l.n + l.e + l.s + l.w); filter += l.ne + l.nw + l.se + l.sw; filter *= 1.0 / 12; filter = abs(filter - l.m); filter = saturate(filter / l.contrast); float blendFactor = smoothstep(0, 1, filter); return blendFactor * blendFactor * _SubpixelBlending; } 边缘检测
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b146baef879400618056692ae26269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/628fea8e2b7ac1050bab9aab15352169/" rel="bookmark">
			ResNet网络结构详解及代码复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ResNet论文详解 1.1. Introduction 一般网络越深，特征就越丰富，模型效果也就越好。在深度重要的驱动下，出现了2个问题：
梯度消失和梯度爆炸：
梯度消失：误差梯度&lt;1，当网络层数增多时，最终求的梯度会以指数形式衰减梯度爆炸：误差梯度&gt;1，当网络层数增多时，最终求的梯度会以指数形式增加解决方式： Xavier 初始化、Kaiming 初始化等
Batch Normalization
退化问题：在适当深度的模型中添加更多的层会导致更高的训练误差，如下图：
在本文中，我们通过残差结构来解决退化问题。
原本是通过堆叠非线性层来适合 H ( x ) H(x) H(x)，现在是让这些非线性层来适合 F ( x ) F(x) F(x)，原始映射被表示为： H ( x ) : = F ( x ) + x H(x):=F(x)+x H(x):=F(x)+x
H ( x ) : H(x): H(x): 原本需要学习的映射 F ( x ) : F(x): F(x): 现在需要学习的映射 x : x: x: 单位映射，可以跳过一层或多层的连接(shortcut connection) 实验表示：
极深残差网络很容易优化很容易获得网络深度带来的准确性的提高 1.2. Deep Residual Learning 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/628fea8e2b7ac1050bab9aab15352169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7bb39fc2700303d35c47f9a3f6fe52f/" rel="bookmark">
			Arm64内存屏障
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、内存类型
ARMv8架构将系统中所有的内存，按照它们的特性，划分成两种，即普通内存和设备内存。并且它们是互斥的，也就是说系统中的某段内存要么是普通内存，要么是设备内存，不能都是。
1）普通内存（Normal Memory）
普通内存的特性是，在没有别的写入的情况下，每次读取出来的值都是一样的。针对普通内存，Arm处理器会采用比较激进的优化方式，从而导致指令重排序的问题。
普通内存可以被指定为支持缓存（Cached）或不支持缓存（Non-Cached）。如果两个模块之间不支持数据一致性协议，那么它们之间的共享内存一定是不支持缓存的。
2）设备内存（Device Memory）
设备内存一般是对外部设备的一段内存映射，在没有写入的情况下，可能每次读取出来的值都不一样。也有可能写入这段内存会产生别的边际效应，如触发一个中断。
二、共享域
为了支持数据一致性协议，需要增加硬件很多开销，会降低系统的性能，同时也会增加系统的功耗。但是，很多时候并不需要系统中的所有模块之间都保持数据一致性，而只需要在系统中的某些模块之间保证数据一致性就行了。因此，需要对系统中的所有模块，根据数据一致性的要求，做出更细粒度的划分。
ARMv8架构将这种划分称作为域（Domain），并且一共划分成了四类：
1）非共享（Non-shareable）域
处于这个域中的内存只由当前CPU核访问，既然只能自己访问，那当然不用考虑跟系统中的其它模块，如其它CPU核或其它设备之间的数据同步问题。所以，如果一个内存区域是非共享的，系统中没有任何硬件会保证其缓存一致性。如果一不小心共享出去了，别的CPU核可以访问了，那必须由软件自己来保证其一致性。
2）内部共享（Inner Shareable）域
处于这个域中的内存可以由系统中的多个模块同时访问，并且系统硬件保证对于这段内存，对于处于同一个内部共享域中的所有模块，保证缓存一致性。
一个系统中可以同时存在多个内部共享域，对一个内部共享域做出的操作不会影响另外一个内部共享域。
3）外部共享（Outer Shareable）域
处于这个域中的内存也可以由系统中的多个模块同时访问，并且系统硬件保证对于这段内存，对于处于同一个外部共享域中的所有模块，保证缓存一致性。外部共享域可以包含一个或多个内部共享域，但是一个内部共享域只能属于一个外部共享域，不能被多个外部共享域共享。
对一个外部共享域做出的操作会影响到其包含的所有的内部共享域。
4）全系统共享（Full System）域
这个很好理解，表示对内存的修改可以被系统中的所有模块都感知到。
在一个具体的系统中，不同域的划分是由硬件平台设计者决定的，不由软件控制。并且，Arm的文档中也没有提及具体要怎么划分。但有一些指导原则，一般在一个操作系统中可以看到的所有CPU核要分配在一个内部域里面，如下图所示：
这些域的划分只是为了更细粒度的管理内存的缓存一致性，理论上所有内存都放到全系统共享域中，从功能上说也可以，但会影响性能。
可缓存性和共享性一定是对普通内存才有的概念。设备内存一定是不支持缓存的，且是外部共享的。
三、屏障
前面说的缓存一致性保证的是对同一段内存的操作，系统中的所有模块，在经过一定的时间后，大家读取到的值最终是一样的。比如说，CPU0对全局变量A写入1，而CPU1对全局变量A写入2，那么经过一定时间后，两颗CPU看到全局变量的值要么都是1要么都是2，不会一个是1一个是2。但是，缓存一致性并不能保证内存操作的顺序，这个需要内存屏障来保证。
在ARMv8架构下，共有下面四种指令提供所谓的屏障的功能：
1）指令同步屏障（ISB, Instruction Synchronization Barrier）
Arm系统有两种类型的缓存，一种是指令缓存（I-Cache），还有一种是数据缓存（D-Cache）。因此，内存屏障指令还要区分是对指令的还是针对普通数据的。
指令同步屏障会清洗当前CPU核的流水线和指令预取缓冲，以保证所有这条指令前面的指令都执行完毕之后，才执行这条指令后面的指令。
2）数据内存屏障（DMB, Data Memory Barrier）
数据内存屏障保证，站在系统中其它同属一个域的模块来看，在这条指令之前的存储器访问操作（包括加载或存储）一定比在这条指令之后的存储器访问操作，先被感知到。也就是说，数据内存屏障指令阻止在这条指令之前的所有存储器访问操作被重排序到这条指令之后，同时也会阻止这条指令之后的所有存储器访问指令被重排序到这条指令之前。
3）数据同步屏障（DSB, Data Synchronization Barrier）
数据同步屏障在保证和前面的数据内存屏障相同的存储器访问操作顺序的同时，还会保证在这条指令之后的所有指令（不光是存储器操作指令）一定会在这条指令之后才会执行。因此，数据同步屏障比数据内存屏障更加严格。
DMB和DSB指令都需要带一个参数，这个参数指明了数据屏障指令的作用范围和针对的共享域。共享域前面说过了，一共有四种。作用范围表示数据屏障指令具体对哪些存储器访问操作起作用，ARMv8共定义了三种，分别是：
Load - Load, Load - Store：表示内存屏障保证其之前的所有加载操作一定在其之前完成，其之后的所有加载和存储操作一定在其之后才开始，但是其之前的存储操作有可能会在其之后才执行。
Store - Store：表示内存屏障保证其之前的所有存储操作一定在其之前完成，而其之后的存储操作一定在其之后才能开始，但是对于加载操作没有任何限制。
Any - Any：表示内存屏障保证其之前的所有加载和存储操作一定在其之前完成，而其后的所有加载和存储操作一定在其之后才能开始。
注意，ARMv8不提供所谓的Store-Load型的顺序保证，如果真的需要这种保证，只能使用Any-Any型的。关于DMB和DSB指令的参数，可以总结为如下表格：
参数 作用范围 共享域
OSHLD Load - Load, Load - Store 外部共享域
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7bb39fc2700303d35c47f9a3f6fe52f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b066af092108aa90c659691f9f42d85f/" rel="bookmark">
			Go语言学习-基本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命名 如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。（注意区分包内和包外，包内不仅指当前文件，包外是指在整个包的外部，注意这个包包含哪些文件）
声明 Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。
作用域的判断跟C是基本一样的，主要是要理解分析清楚实际是在哪里声明的，应该用在什么地方。
func 一个函数的声明由func关键字、函数名、参数列表、返回值列表（这个例子里的main函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。这样 func main() { 写出来的就是返回值是空的，还可以括号起来多个返回值。
函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用。
在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。
var var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：
var 变量名字 类型 = 表达式 其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量，数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：
var i, j, k int // int, int, int var b, f, s = true, 2.3, "four" // bool, float64, string 下面这些都等价：
s := "" var s string var s = "" var s string = "" ​在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。
​注意：“:=”是一个变量声明语句，而“=”是一个变量赋值操作。
​简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。但简短变量声明语句中必须至少要声明一个新的变量。
​简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。
​比如一个变量 x 在函数外已经声明了，在函数里再有一个 x := 的话，函数里的这个 x 会被看作一个新的变量，在函数里对已有的 x 进行覆盖。因为“:=”是一个变量声明语句，而“=”是一个变量赋值操作，用 = 的话还是用原来的 x。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b066af092108aa90c659691f9f42d85f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861e20b2e4e59fd34d7f5e817a2979e9/" rel="bookmark">
			Go语言学习-数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
基础类型 整型 不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。事实上，内置的len函数返回一个有符号的int。
var x uint8 = 1&lt;&lt;1 | 1&lt;&lt;5 var y uint8 = 1&lt;&lt;1 | 1&lt;&lt;2 fmt.Printf("%08b\n", x) // "00100010", the set {1, 5} fmt.Printf("%08b\n", y) // "00000110", the set {1, 2} ​当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。
o := 0666 fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666" x := int64(0xdeadbeef) fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x) // Output: // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF 浮点型 浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。
通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分。
math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1)。函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值，nan := math.NaN()。
var f float64 = 212 fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/861e20b2e4e59fd34d7f5e817a2979e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65644cb8a47118c82e31140535fc4409/" rel="bookmark">
			VSCODE 全部保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ctrl + K S
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca6471fb650cd9c1d7c7b803026b83ca/" rel="bookmark">
			注意 driver.find_elements_by_xpath()和driver.find_element_by_xpath()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yes, 存在多个定位元素时使用第一个elements，只有一个时则后者
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24ab93060ea7c31eba3d7cc82e083852/" rel="bookmark">
			linux 窗口退不出去了,linux系统进入文件这个编辑后，出现是这样子，啥也点不了，退也退不出来，以往还可以按：q出来？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入VIM编辑器1VIM编辑器，可以新2113建文件5261也4102可以修改文件，命令为：vim /usr/local/con.cfg如图！请点1653击输入图片描述2如果这个文件，以前是没有的，则为新建，则下方有提示为新文件，如图。如果文件已存在，则没有提示。请点击输入图片描述3进入编辑器后，我们先按"I”，即切换到“插入”状态。就可以通过上下左右移动光标，或空格、退格及回车等进行编辑内容了，和WINDOWS是一样的了。请点击输入图片描述END退出vim编辑器的方法及区别当文本编辑结束之后，通常需要退出编辑器。退出编辑器又分为4种情况：保存退出、正常退出、不保存退出及强制退出。下面简单说下吧！1、先介绍一下保存退出。当我们编辑或修改好了文件内容，如图。请点击输入图片描述我们当然要保存并退出了，然后下一步了。这时，我们要按键盘左上角的"ESC"，留意到了没有？左下角的插入状态不见了，如图。请点击输入图片描述然后这时，我们输入“冒号”，即":"(不需双引号)，在下方会出现冒号，等待输入命令，如图，我输入的是WQ。功能如下。W：write，写入Q：quit，退出再回车，就保存退出了其实，保存退出还有二个方法：A：在最后输入命令时，直接输入"x"，也是一样的，即X=WQ。B：最快捷的方法：按了ESC后，直接按shift+zz，或者切换到大写模式按ZZ，就可以保存退出了，即是按2下大写的Z。请点击输入图片描述我们可以用查看命令：cat查看其内容：cat /usr/local/con.cfg，如图。请点击输入图片描述2、再说下正常退出，正常退出有个前提条件是：打开的文本文件在内容上没有被改动过。按了ESC后再输入冒号，在输入命令时，直接输入"q"，请点击输入图片描述3、来看看不保存退出的方法吧，很多时候打开了文件，或者修改了一些地方，才发现错了，非常需要不保存退出。先按ESC，再输入冒号，在输入命令时，直接输入"q!"，如图。请点击输入图片描述4、强制退出。这个实在是不应该做的操作，因为很操蛋！先按ESC，再按冒号，在输入命令时，直接输入"!"，如图。但退出后，会有提示！请点击输入图片描述请点击输入图片描述
阅读全文 &gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72bf58d19284130b0397b7e2aba3ca9b/" rel="bookmark">
			SecureCRT_Python笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 说明常用语法python脚本开头格式Sleep睡眠发送命令或文本弹出消息框 常用对象操作Application 应用程序对象属性ActivePrinter 活动打印机ScriptFullName 脚本名称Version 版本 方法ClearLastError 清除最新错误GetLastError 获取最新错误GetLastErrorMessage 获取最新错误消息Quit 退出CRT**Sleep** 睡眠 Arguments 命令行启动参数对象获取对象属性Count 数量 方法GetArg Clipboard 剪贴板对象属性Format 获取/设置格式Text 返回或设置剪贴板的内容 CommandWindow 命令窗口对象属性SendCharactersImmediately 立即发送字符SendToAllSessions 是否发送到所有会话Text 返回或设置命令窗口中的文本Visible 窗口是否可见 方法Send 发送命令窗口的文本到会话 dialog 对话框对象方法FileOpenDialog 打开文件对话框MessageBox 弹出消息框Prompt 弹出输入框 FileTransfer 文件传输对象属性DownloadFolder 下载路径ZmodemUploadAscii 设置Zmodem上传模式 方法AddToUploadList 将文件放在Y/Zmodem上载列表中ClearUploadList 清除Y/Zmodem上载列表SendKermit 启动Kermit协议文件发送ReceiveKermit 启动Kermit协议文件下载SendXmodem 启动Xmodem协议文件发送ReceiveXmodem 启动Xmodem协议文件下载SendYmodem 启动Ymodem协议文件发送ReceiveYmodem 启动Ymodem协议文件下载 screen 屏幕对象属性CurrentColumn 当前列坐标CurrentRow 当前行坐标Columns 当前屏幕最大列宽IgnoreEscape 忽略特殊控制字符MatchIndexRows 当前屏幕最大行数Selection 返回选择的内容Synchronous 屏幕同步 方法Clear 清屏Get() 获取矩形框内的屏幕上的字符Get2() 获取矩形框内的屏幕上的字符IgnoreCase() 忽略大小写Print 打印ReadString 读取字符Send() 向屏幕发送命令或字符串SendKeys 发送按键SendSpecial 发送CRT内置功能WaitForCursor 等待光标移动WaitForKey() 等待按键WaitForString() 等待字符出现WaitForStrings() 等待字符(多个)出现 Session 会话属性Config 配置Connected 已连接LocalAddress 本地地址Locked 锁定LogFileName 日志文件名Logging 正在记录Path 路径RemoteAddress 远程地址RemotePort 远程端口 方法Connect 连接ConnectInTab 连接Tab里的Disconnect 断开Lock 锁定Log 日志LogUsingSessionOptions 日志选项SetStatusText 设置文本状态Unlock 解除锁定 SessionConfiguration 对象OpenSessionConfiguration 打开会话配置方法ConnectInTab 连接到会话GetOption 获取指定选项值Save 保存SetOption 设置选项 Tab 标签GetScriptTab 获取脚本所在的选项卡GetTabCount 获取选项卡数量GetTab 获取选项卡GetActiveTab 获取活动选项卡属性Caption 标题Index 索引Screen 屏幕Session 会话 方法Activate 活动的Clone 克隆Close 关闭ConnectSftp 连接到sftp Window 窗口对象属性Active 活动Caption 标题State 状态 方法Activate 激活Show 显示 说明 以SecureCRT 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72bf58d19284130b0397b7e2aba3ca9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324473f4d002fadf83c36d0819e427da/" rel="bookmark">
			《算法笔记》2.8小节——C/C&#43;&#43;快速入门-＞结构体(struct)的使用 问题 B: C语言11.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 B: C语言11.2 题目描述输入输出样例输入样例输出示例代码参考代码 题目描述 输入 第一行有一个整数n，表示以下有n个学生的信息将会输入。保证n不大于20。
以后的n行中，每一行包含对应学生的学号、名字、性别和年龄，用空格隔开。保证每一个人名都不包含空格且长度不超过15，性别用M和F两个字符来表示。
输出 有n行，每行输出一个学生的学号、名字、性别和年龄，用空格隔开。
请注意行尾输出换行。
样例输入 3 10101 LiLin M 18 10102 ZhangFun M 19 10104 WangMin F 20 样例输出 10101 LiLin M 18 10102 ZhangFun M 19 10104 WangMin F 20 示例代码 #include&lt;iostream&gt; using namespace std; int main(){ struct student { int num; char name[20]; char sex; int age; }; student stu[30]; student *p=stu; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++){ scanf("%d %s %c %d"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/324473f4d002fadf83c36d0819e427da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d4f9c80fb8cca49c1bf656f0867b78f/" rel="bookmark">
			linux gfs原理,Linux GFS 配置方法及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿
Linux GFS(Global File System)是实现为多个访问节点或者主机能同时读写的分布式文件系统。
现测试基于RedHat的GFS简单 配置方法及注意事项实验记录如下：
1.GFS安装配置
在10.100.15.11和10.100.15.12配置yum源，创建配置文件,启动相关进程，两个节点做同样的配置
2.安装集群套件及GFS RPM包：
注，使用gfs文件系统，需要安装如下rpm包：
3.2节点配置cluster集群文件
注：name必须和vg名字相同
4.2个节点设置服务启动并允许开机启动如下服务
[root@localhost ~]#chkconfig rgmanager on
[root@localhost ~]#chkconfig ricci on
[root@localhost ~]#chkconfig cman on
[root@localhost ~]#chkconfig clvmd on
[root@localhost ~]#chkconfig gfs2 on
[root@localhost ~]# clustat
4. 在共享存储上划分LVM,在一个节点上操作即可
[root@localhost ~]# pvcreate /dev/mpath
Physical volume "/dev/mpath" successfully created
[root@localhost ~]# vgcreate mpath300G /dev/mpath
Clustered volume group "fmpath300G" successfully created
[root@localhost mnt]# lvcreate -n gfs -l 79462 300G_gfs
Logical volume "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d4f9c80fb8cca49c1bf656f0867b78f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b710c0e9f544923f40d583e1f0edc67f/" rel="bookmark">
			加载dll动态库时LoadLibrary与LoadLibraryEx的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若DLL不在调用方的同一目录下，可以用LoadLibrary(L"DLL绝对路径")加载。
但若被调DLL内部又调用另外一个DLL，此时调用仍会失败。解决办法是用LoadLibraryEx：
LoadLibraryEx(“DLL绝对路径”, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
通过指定LOAD_WITH_ALTERED_SEARCH_PATH，让系统DLL搜索顺序从DLL所在目录开始。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d6536ac60430414e608717b6426a7c4/" rel="bookmark">
			linux安装nginx1.12,CentOS7.2编译安装Nginx1.12.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境说明:
1、系统：CentOS最小化安装；升级软件补丁，内核和系统版本不升级；关闭SELinux和防火墙。
2、软件：安装包统一放置在/usr/src目录下，安装位置统一在/usr/local目录下。
开始安装：
[root@localhost ~]# yum -y install pcre-devel
2、安装编译需要的组件
[root@localhost~]# yum -y install zlib-devel openssl-devel
3、创建软件配套专用的用户(禁止登录及不创建家目录)[root@localhost~]# useradd www -s /sbin/nologin -M
4、进入/usr/src目录下载并解压软件包[root@localhost src]# cd /usr/src/
[root@localhost src]#tar -zxf nginx-1.12.2.tar.gz
5、进入解压的软件目录并编译配置文件
[root@localhost src]# cd nginx-1.12.2
[root@localhost nginx-1.12.2]# ./configure --user=www --group=www --prefix=/usr/local/nginx-1.12.2 --with-mail_ssl_module --with-http_stub_status_module --with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module --with-http_sub_module
6、编译及安装软件
[root@localhost nginx-1.12.2]# make &amp;&amp; make install
7、创建软链接
[root@localhost nginx-1.12.2]# ln -s /usr/local/nginx-1.12.2/ /usr/local/nginx
8、检查Nginx配置文件语法
[root@localhost nginx-1.12.2]# /usr/local/nginx/sbin/nginx -t
9、把Nginx服务添加进启动自定义文件内并启动Nginx软件
echo"/usr/local/nginx/sbin/nginx"&gt;&gt;/etc/rc.local&amp;&amp;/usr/local/nginx/sbin/nginx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d6536ac60430414e608717b6426a7c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d02932659b2aab271e64a7138cb6c9/" rel="bookmark">
			微信小程序退出，web-view里h5音乐继续播放问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说结论，那就是通过监听visibilitychange事件
这个问题，首先看你的需求是不是要在页面切换的时候停止播放，对我们的项目来说，播放的是对景点的详情解说，由于景点的文字解说在小程序页面，所以当webview里面的音乐播放的时候，用户从webview返回到小程序页面时，不希望播放的解说停止，所以我们对这个不作处理。
不过，刚开始也找了解决方案，经过测试，安卓，ios都可以实现对播放的停止。
visibilitychange事件:当其选项卡的内容变得可见或被隐藏时，会在文档上触发 visibilitychange (能见度更改)事件。
document.addEventListener("visibilitychange", function() { if (document.visibilityState === 'visible') { backgroundMusic.play(); } else { backgroundMusic.pause(); } }); 可以通过判断document.visibilityState 是否为 ‘visible’ 或者 判断document.hidden是否为true去判断当前页面是否被隐藏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef627682604998a6e8d1224bb29d80c7/" rel="bookmark">
			数据库-事务及相关技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务 事务的提出主要是为了解决并发情况下保持数据一致性的问题
用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位
ACID 原子性、一致性、隔离性、永久性
原子性和隔离性都会影响一致性（原子性相当于是看事务自己是否正确做完或都不做，隔离性主要是并发的时候）
永久性是为了应对系统崩溃的情况，一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
并发一致性问题 丢失修改、读脏数据（原先的rollback了，即读到另一个未提交事务的数据）、不可重复读、幻读
不可重复读和幻读的区别：
从总的结果看都表现为两次读取结果不一致
从控制的角度看，不可重复读只要锁住满足条件的记录，幻读需要锁住满足条件及相近的记录（理解成前者锁行，后者锁表）
不可重复读的重点在于update和delete，幻读的重点在于insert
产生并发一致性问题的主要原因是破坏了事务的隔离性（不同事务互相影响了）
解决方法是并发控制，可以通过封锁来实现，但是封锁需要用户自己控制。
DBMS提供事务的隔离级别，以更轻松的方式处理并发一致性问题
事务隔离级别 作用是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。
下面这四个隔离级别是越来越高的，对性能的影响也是越来越大的
MySQL默认的隔离级别是可重复读（为了平衡）
1.未提交读 一个事务可以读到另一个事务已经修改了但是还没提交的数据。（会导致脏读）
2.提交读 一个事务只能读取已提交的事务所做的修改。相当于只有commit了之后，才能被其他事务读到，不然其他事务读到的还是之前的。（所以就可以解决脏读）
3.可重复读（RR） 保证在同一个事务中多次读取同一数据的结果是一样的。
只能读在该事务之前提交的修改。（MVCC里根据版本号来判断）
不过还是可能出现幻读的问题（因为修改的数据是本身有的，新插入的话还是会被读出来）
为什么上了写锁，别的事务还可以读？（没有提交的话别的事务读到的是原始的数据）
因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，不会被阻塞。
4.可串行化 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。
该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。
读读操作不会被阻塞，读写、写读、写写都会被阻塞
脏读不可重复读幻读未提交读×××提交读√××可重复读√√×可串行化√√√ 隔离级别实现原理 MVCC（多版本并发控制） 是MySQL的InnoDB存储引擎实现隔离级别的一种具体的方式，用于实现读已提交和可重复读这两种隔离级别。读未提交总是读取最新的数据行，无需使用MVCC。可串行化隔离级别需要对所有的行都加锁，仅仅依赖MVCC是无法实现的。
MVCC可以认为是行级锁的一个变种，但是他在很多情况下都避免了加锁操作，因此开销更低。与基于锁的并发控制相比，多版本并发控制好处是：读不加锁，读写不冲突。可以避免不必要的加锁操作。
利用多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。
MVCC规定只能读取已经提交的快照，就可以避免脏读和不可重复读问题。
系统版本号：每开始一个新的事务，系统版本号就会自动递增
事务版本号 TRX_ID：事务开始时的系统版本号
在MVCC中事务的修改操作（DELETE、INSERT、UPDATE）都会为数据行新增一个版本快照。多版本指的就是多个版本的快照。快照存储在Undo日志中，通过回滚指针把一个数据行的所有快照连接起来。Undo日志里相当于存着多个快照版本。
MVCC维护了一个 ReadView 结构，主要包含当前系统未提交的事务列表TRX_IDs，还有该列表的最小值和最大值。
在进行SELECT操作的时候，根据数据行快照的TRX_ID和最小值最大值之间的关系，从而判断该数据行快照是否可以使用：小于最小值，说明该数据行快照在当前所有未提交事务之前更改的，可以使用，相当于就是可以读已提交的；大于最大值，说明该数据行快照是在事务启动之后被更改的，不能使用；在最小值和最大值之间，则需要根据隔离级别再进行判断。
提交读：如果该快照在列表中，说明该快照对应的事务还未提交，则该快照不可使用。若不在列表中，说明已经提交了，就可以使用。
可重复读：都不可以使用。
在当前数据行快照不可使用的情况下，需要沿着 Undo log的回滚指针找到下一个快照，再进行上面的判断。
简单来说，就是查询时，
如果该行数据没有被加行锁中的X锁（也就是没有其他事务对这行数据进行修改），那么直接读取数据（前提是数据的版本号&lt;=当前事务版本号的数据,不然不会放到查询结果集里面）。该行数据被加了行锁X锁（也就是现在有其他事务对这行数据进行修改），那么读数据的事务不会进行等待，而是回去undo log端里面读之前版本的数据（这里存储的数据本身是用于回滚的）。在提交读的隔离级别下，从undo log中读取的总是最新的快照数据（有提交的就可以读出来了）；在可重复读的隔离级别下，从undo log中读取的数据总是事务开始时的快照数据(也就是版本号小于当前事务ID的数据) 在多版本并发控制中，读操作分成两类：
快照读（snapshot read）:快照读，读取的是记录的可见版本，可能是历史版本，不用加锁。**当前读（current read）：**读取读，读取的是最新版本，当前读返回的记录，都会加锁，保证其他事务不会并发地修改这条记录。 简单的select操作属于快照读，不用加锁；会对数据库进行修改的操作：插入、更新、删除操作，属于当前读，需要加锁（需要读最新版本的需要加锁）
在一个事务内，多次执行SELECT语句，查询到的数据都是事务开始时那个状态的数据（这样就不会受其他事务修改数据的影响）
数据行要被查询出来必须满足两个条件， 数据行删除版本号为空或者 &gt; 当前事务版本号的数据（否则数据已经被标记删除了)创建版本号 &lt;= 当前事务版本号的数据（否则数据是后面的事务创建出来的） 简单来说，就是查询时，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef627682604998a6e8d1224bb29d80c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803e0ee90067bb00fc6900ff02fe707b/" rel="bookmark">
			linux tar xzvf,【分享】tar的xzvf和xjvf命令区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		x是解压 x。。f
c 是压缩 c。。f
z指gz文件。
j指bz文件
f指定文件
================
1、".bz2"格式：
解压：tar xjvf FileName.tar.bz2
压缩：tar cjvf FileName.tar.bz2
2、".gz"格式：
解压：tar xzvf usr.tar.gz
压缩：tar czvf usr.tar.gz /home
例如：解压/root/zihan 目录下的123.tar.gz文件 解压到/root/zihan2 目录下。
[root@localhost zihan]# tar xzvf 123.tar.gz -C ../zihan2
test1.txt
test2.txt
test3.txt
./dir3/
例如：解压/root/zihan 目录下的123.tar.gz文件 解压到/root/zihan2 目录下。
[root@localhost zihan]# tar xzvf 123.tar.gz -C /home/
test1.txt
test2.txt
test3.txt
./dir3/
z用来解压.tar.gz的文件，.tar.bz2的文件得换成j，象这样：
tar -xjvfLinux-2.6.20.tar.bz2
看看参数说明：
x：解压
j：bz2
f：指定文件
===========================================
另一种解读方法：
===========================================
x是解压
c 是压缩
z指gz文件。
j指bz文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/803e0ee90067bb00fc6900ff02fe707b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f764bd31058a1c5be727bc26e7a915c6/" rel="bookmark">
			linux 搜狗输入法显示繁体字,搜狗输入法繁体字切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多使用搜狗输入法的小伙伴不知道电脑或者手机的繁体字如何切换，有的喜欢方便的简体字，也有小伙伴喜欢古色的繁体字，今天小编教大家如何在电脑和手机上设置字体，具体的教程一起来看看吧。
【搜狗输入法常见问题】
搜狗输入法繁体字切换的步骤
电脑繁体字切换的方法
方法一：可以进行快捷设置，直接在打字的时候，按住“ctrl+shift+f”就可以进行简繁切换了。
方法二：
1、切换出搜狗输入法，鼠标右键点击输入法选择“简繁切换”，接着点击右侧“简体”即可切换成简体。
2、如果要设置为繁体，即在简繁切换右侧点击繁体
方法三：在任务栏右下角的输入法图标上点击右键，选择“属性设置”，点击常用，在默认状态中进行简繁切换
手机繁体字切换的方法
1、选择输入法标题上的“S”形图标
2、右击“S”形图标，可以呼出菜单，选择“简繁转换
3、左击“简繁转换”，呼出下级菜单，初始情况下默认为简体，如果需要转换简繁体，选择繁体即可
以上就是系统家园为您带来的搜狗输入法繁体字切换的步骤，希望可以解决掉您的困惑。想了解更多的问题请收藏系统家园哟。欢迎您的查看。
本条技术文章来源于互联网，如果无意侵犯您的权益请点击此处反馈版权投诉
本文系统来源：互联网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52f6dd1ac02758fb4cd03a7cb01d7020/" rel="bookmark">
			秒懂设计模式之原型模式（Prototype Pattern）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[版权申明] 非商业目的注明出处可自由转载
博文地址：https://blog.csdn.net/ShuSheng0007/article/details/116463979
出自：shusheng007
设计模式汇总篇，一定要点赞收藏：
永不磨灭的设计模式（有这一篇真够了，拒绝标题党）
文章目录 概述类型难度 定义使用场景UML类图实例第一步，原型接口第二步，原型类第三，客户端使用技术要点总结优缺点优点缺点 总结 概述 原型模式属于创建型模式，所以它是描述如何创建对象的模式。顾名思义，先搞一个原型对象出来，然后在这个原型对象的基础上修修补补再弄出一个新对象来。
我们一定要牢记设计模式是前人总结的一套可以有效解决问题的经验，不要一写代码就在考虑该使用什么设计模式，这是极其不可取的。正确的做法应该是在实现业务需求的同时，尽量遵守面向对象设计的六大设计原则即可。后期随着业务的扩展，你的代码会不断的演化和重构，在此过程中设计模式绝逼会大放异彩的。
类型 创建型（creational）
难度 2颗星
定义 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。
你看看这定义，就是不说人话！不管它，一会通过实例意会一下，再通过使用场景知道解决什么问题就可以了
使用场景 当一个对象的构建代价过高时。例如某个对象里面的数据需要访问数据库才能拿到，而我们却要多次构建这样的对象。当构建的多个对象，均需要处于某种原始状态时，就可以先构建一个拥有此状态的原型对象，其他对象基于原型对象来修改。 UML类图 照例上一张手撕UML类图
UML 类图也比较简单，只有两个部分
Prototype 这个是一个接口，里面必须含有一个可以克隆自己的方法。在Java中，我们可以使用JDK自带的java.lang.Cloneable接口来替代此接口
ConcretePrototype 实现了Prototype接口的原型对象，这个对象有个能力就是可以克隆自己。
实例 上回我们说到王二狗公司的大老板要看商城项目的周报表，二狗他们在开发中发现，批量导出报表时特别慢。经过调查发现是报表的主体部分特别耗时，那些头部，作者什么的都不怎么耗时。那二狗他们就在想，能不能将那些耗时的操作作为原型对象，然后在这个原型对象上添加上其他部分，对头，用原型模式可解。
假设一篇报表由报表头与报表体组成，报表体获取特别耗时，报表头不耗时，我们如何大量导出报表呢？
第一步，原型接口 原型接口必须有一个可以克隆自己的方法，反回类型为Prototype
public interface Prototype { Prototype copy(); } 第二步，原型类 这个类就是我们的原型类，准备被其他人克隆使用的，所以其实现Prototype接口，具备克隆的能力。根据业务需求，克隆可以是浅克隆，也可以是深克隆。
我们假设此类含有一个存放内容的List，这些数据都是从数据库读取的相对比较耗时。假设我们要生成多篇不同报表，内容基本不变（这是要点，只有你需要的对象是可以基于原型对象的才有意义），头部要不同。
public class Report implements Prototype { private List&lt;String&gt; parts; public Report() { this.parts = new ArrayList&lt;&gt;(); } public Report(List&lt;String&gt; parts) { this.parts = parts; } //耗时的数据加载操作 public void loadData() { pats.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52f6dd1ac02758fb4cd03a7cb01d7020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb009a1a3b73fca14c1ef9c31c17946/" rel="bookmark">
			Vue事件总线实例（全局事件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		得到事件总线对象 // src/assets/js/event-bus.js import Vue from 'vue' export const EventBus = new Vue() 注册监听事件 &lt;script&gt; import { EventBus } from '@/assets/js/event-bus.js' export default { name: 'CustomerManagement', data () { return { } }, mounted () { // 参数一为事件渠道标识，与触发中的标识一致；参数二位事件回调函数，函数内携带事件传递的数据 EventBus.$on('selected-industry', (data) =&gt; { console.log(data) }) }, methods: { } } &lt;/script&gt; 触发事件 &lt;script&gt; import { EventBus } from '@/assets/js/event-bus.js' export default { name: 'IndustryTree', props: { }, data () { return { } }, methods: { selectedIndustry (data) { // 第一个参数为事件渠道标识，与注册中的标识一致，第二个为事件携带的数据 EventBus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb009a1a3b73fca14c1ef9c31c17946/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8620b704e52f50e4ce1abb6203bb2f16/" rel="bookmark">
			【Nginx】同时配置http和https访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线上运行的平台突然出现无法访问的情况，经过排查发现是SSL证书过期了，但是已经下班，来不及处理，就临时改为http访问了；第二天再进行处理。
由于是小范围内使用的平台，通知使用人员地址略有变化也不是什么大问题；当如果第二天修改后，再通知使用https访问，就太麻烦了。
于是有了需求：用户永远使用http进行访问，如果SSL正常可用时，则默认跳转使用https访问；如果下次再出现再出现SSL不能使用的情况，则修改为http访问时，无需再通知用户更改访问地址。
查了几个方法，采用了最简单的一个。
当使用http访问https的请求时，nginx会产生497的状态码，因此将该状态码重新定向到https地址即可。这样就能实现同一个端口同时使用http和https访问。
问题来了：如果要把未配置SSL访问的https请求定向到http可以吗？
暂时还没找到实现的方法，是不是不能实现呢？如果不能实现，也是有道理的。
从http定向到https访问，安全性是升级的，用户不用担心，也无需察觉；
但如果用户需要使用https访问，却被直接定向到安全层级低的http了，可能会产生一些问题。
暂时知识猜测，待研究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5511ca49c7a64293c298cac341ab0364/" rel="bookmark">
			Spring Data MongoDB 与 mongo java driver 与 spring Framework 的版本兼容情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 近期基于业务和成本的考虑，需要对MongoDB进行升级。 使用方式上只要是用 spring-data-mongodb 对mongodb 操作。所以后续操作都是基于spring-data-mongodb 该组件来讨论
调研过程中发现了些问题，特此分享一下。
后续调研发现支持升级的版本有：
MongoDB 与 java Driver 兼容性 ，如下图：
发现 如果要升级到最新的版本MongoDB4.4 ，则java Driver 需要4.1， 而目前（2020-09-14）Spring Data MongoDB 3.0.3 RELERSE 依赖org.mongodb:mongodb-driver-core:jar:4.0.5。
也就是会没有Spring 还没有完全兼容MongoDB4.4。
后来大致梳理了下 Spring Data MongoDB 与 mongo java driver 与 spring Framework 的版本兼容情况.
Spring Data MongoDB
1.8.0.RELEASE
1.9.0.RELEASE
1.9.4.RELEASE
1.9.9.RELEASE
2.0.0.RELEASE
2.1.9.RELEASE
3.0.3.RELEASE
mongo-java-driver
2.13.0
2.14.0
2.14.3
2.14.3
3.5.0
3.8.2
4.0.5
Spring Framework
4.1.7.RELEASE
4.2.5.RELEASE
4.2.8.RELEASE
4.3.13.RELEASE
5.0.0.RELEASE
5.1.8.RELEASE
5.2.8.RELEASE
核心的还是 Spring Framework 。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97b1c9651dc101ab553893b9b672ca8f/" rel="bookmark">
			linux中.rpm文件,Linux中RPM文件操作的常用命令总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
众所周知在Linux操作系统中，有一个系统软件包，它的功能类似于Windows里面的“添加/删除程序”，但是功能又比“添加/删除程序”强很多，它就是Red Hat Package Manager(简称RPM)。本文介绍的就是关于Linux中RPM文件操作的常用命令，下面话不多说，来一起看看吧。
一、RPM 安装操作
命令：
rpm -i需要安装的包文件名
举例如下：
rpm -i example.rpm 安装 example.rpm 包；
rpm -iv example.rpm 安装 example.rpm 包并在安装过程中显示正在安装的文件信息；
rpm -ivh example.rpm 安装 example.rpm 包并在安装过程中显示正在安装的文件信息及安装进度；
二、RPM 查询操作
命令：
rpm -q…
附加查询命令：
a 查询所有已经安装的包以下两个附加命令用于查询安装包的信息；
i 显示安装包的信息；
l 显示安装包中的所有文件被安装到哪些目录下；
s 显示安装版中的所有文件状态及被安装到哪些目录下；以下两个附加命令用于指定需要查询的是安装包还是已安装后的文件；
p 查询的是安装包的信息；
f 查询的是已安装的某文件信息；
举例如下：
rpm -qa | grep tomcat4 查看 tomcat4 是否被安装；
rpm -qip example.rpm 查看 example.rpm 安装包的信息；
rpm -qif /bin/df 查看/bin/df 文件所在安装包的信息；
rpm -qlf /bin/df 查看/bin/df 文件所在安装包中的各个文件分别被安装到哪个目录下；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97b1c9651dc101ab553893b9b672ca8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555b2b1fda1b35fa34bee5a300b6647c/" rel="bookmark">
			恢复linux  yum源,Centos系统还原官方yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将近两个月没有登录过我的美国服务器SSH了，登录后心血来潮来了个yum update，发现yum源是国内大厂某某云的，我顿时就迷了，我一个美国服务器要啥自行车？直接用官方源不是更快更香吗？
于是我就开始着手还原yum到官网状态，下面记录一下操作步骤：
Centos6:
cd /etc/yum.repos.d/
rm -rf CentOS-*
rpm -Uvh --force http://mirror.centos.org/centos-6/6.10/os/x86_64/Packages/centos-release-6-10.el6.centos.12.3.x86_64.rpm
yum clean all
yum makecache
yum update -y
Centos7:
cd /etc/yum.repos.d/
rm -rf CentOS-*
rpm -Uvh --force http://mirror.centos.org/centos-7/7.7.1908/os/x86_64/Packages/centos-release-7-7.1908.0.el7.centos.x86_64.rpm
yum clean all
yum makecache
yum update -y
Centos8:
cd /etc/yum.repos.d/
rm -rf CentOS-*
rpm -Uvh --force http://mirror.centos.org/centos-8/8.1.1911/BaseOS/x86_64/os/Packages/centos-release-8.1-1.1911.0.8.el8.x86_64.rpm
yum clean all
yum makecache
yum update -y
以上操作步骤使用前请确认好您当前使用的Centos版本，出问题博主可不负责哦，本文中的RPM链接我不敢保证会不会和谐，截止2020/02/11是可用的，如发现失效了可评论留言联系博主更新，或自行查阅官方资源库！希望可以帮到您！
展开全文 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d11f45e2bf3f0485d99a70aa4581933c/" rel="bookmark">
			Windows RPC 入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RPC，即 Remote Procedure Call，远程过程调用。
Microsoft RPC 采用客户机/服务器（C/S）模式，客户机负责发送请求；服务器响应请求，达到通信目的。
客户机和服务器共同维护一个命令列表，发送请求时命令作为第一个参数，服务器通过命令来调用正确的处理程序，返回客户机需要的信息
例子1：入门 hello world 客户端程序通过RPC远程过程调用，传递一个字符串“Hello,World”给服务端，
服务端输出字符串该串“Hello,World”到命令行控制台中。
一、vs 新建空项目 winRPC； 1.1 添加新的空项目，取名 IDL；
1.2. 进入 IDL文件夹，cmd 命令行也进入这个目录，执行 uuidgen /i /oRPCTest.idl 命令后生成文件 RPCTest.idl
【说明】 uuidgen 就是 uuidgen.exe 工具，安装完 vs 基本有这个。 /i /o 是选项
1.3. 右键 IDL项目，添加现有项即刚生成的 RPCTest.idl, 双击添加两个函数HelloProc(), Shutdown()：
a. 定义头中包含了自动生成随机的 UUID 和版本号。版本号作兼容之用。客户端、服务端的版本只有兼容了，才可以连接。
b. 函数的参数 pszString有两个属性[in]和[string]：
[in]属性告诉运行库此参数只能从客户端传送到服务端。
[string]属性指定了桩要按C风格的字符串来处理此参数。
// RPCTest.idl [ uuid(8119ceb2-4586-4cdf-9fa3-7cff4b36274d), version(1.0) ] interface RPCTest { void HelloXXXXXX([in, string] unsigned char* pszString); void Shutdown(void); } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d11f45e2bf3f0485d99a70aa4581933c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d926d4a5de36405f9d0176c64f21d948/" rel="bookmark">
			unity3d连接sqlserver ，SocketException: 由于目标计算机积极拒绝，无法连接。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题前言一、首先看IP地址和端口二、另外一个工作（可能有用）总结 问题前言 释放：困扰了我一天的问题终于解决了。。。。。
问题：用unity3d 2020 连接SqlServer时，一直提示SocketException: 由于目标计算机积极拒绝，无法连接，根据网上所述的解决方法（链接地址：https://blog.csdn.net/dingjia7050/article/details/102262690），修改了以后，任然不能成功的链接我的数据库。经过百般折磨，终于成功了，由于对着之间的原理不懂，只是记录一下我是做了哪些工作才使我的链接成功。下面见分晓…
一、首先看IP地址和端口 unity3d连接sqlserver，网上很多代码啊所用的IP都是127.0.0.1，我尝试了这个，连接脚本为：
string connectionString = "Data Source=127.0.0.1;DataBase=QuarryED_DB;uid=sa;pwd=sa123456;"; SqlConnection con = new SqlConnection(); con.ConnectionString = connectionString; try { con.Open(); print("连接成功!"); con.Close(); } catch { print("连接失败!"); throw; } 但是不成功，报错如下
由此，只是用IP地址不可，还要端口。摸索了好久没找到端口，但是在偶尔的情况下，找到一个端口，就是 通过 开始—Microsoft SQL Server 2014—SQL Server 2014配置管理器—MR2014的协议(安装sql时没设置的话应该是MSSQLSERVER),，然后右边窗口有个TCP/IP协议，右键点击，打开属性-IP地址，将所有的IP都设置为启用外，记录下最后那个动态端口，我的是61306。
至此，IP地址和端口都知道了，能不能成功，试试就知道了，…
我以为不会成功，但是居然成功了，哭了，因为除了上述步骤，我还做了另外一个工作…，见下。。
Tips：如果 server=localhost ，连接不成功的话，尽量往 IP地址+端口 上面靠，如我总结里面的脚本一样。
二、另外一个工作（可能有用） 就是打开 服务.exe 里面的 SQL server 代理（MR2014），将类型调为自动，然后点击启动，然后确定。O了。但是后面我返回去将这个调为手动，也是没问题的，所以这个当白做了，先做个记录吧，万一哪天不行了呢，又来调整了试试。
总结 最终算是连接成功了，也能获取到我数据库的数据，目前看来，最大的原因就是Data Source或者server的值没有设置清楚。经过一天的琢磨加到处尝试摸索，后面就不说了，看我最终的代码。。。 using UnityEngine; using System.Data.SqlClient; public class SQLConnectTest : MonoBehaviour { void Start() { string connectionString = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d926d4a5de36405f9d0176c64f21d948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ac3f9c01af7720ad7a9919ca9060a6/" rel="bookmark">
			《算法笔记》进制转换问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。
输入：
多组数据，每行为一个长度不超过30位的十进制非负整数。
（注意是10进制数字的个数可能有30个，而非30bits的整数）
输出：
每行输出对应的二进制数。
样例输入：
985
211
1126
样例输出：
1111011001
11010011
10001100110
注：每段代码变量不一致，以最后Code为标准。
分析： 每组数据输入长度不超过30位的十进制非负数。
不是30bits！不是30bits！不是30bits！
按照大数的一般操作，我们可以先用字符数组存储后，再进一步用整型数组存储，以便后续转为二进制。
char str[35]; int num[35]; for(int len=0;str[len];++len){ num[len]=str[len]-'0'; } 进制转换，从十进制 -&gt; x 进制，一般操作（应该没有其他办法了吧_小声_） 是将十进制数 n 对 x 取模结果存入ans数组内（我是用ans数组存放转换成的二进制答案的 ），然后通过 n /= x 更新 n 的值。
int i=0; int n,x; int ans[MAXN]; do{ ans[i++] = n % x; n /= x; }while(n); 问题：
如果是普通整型范围内的非负整数是能直接进行运算的（或者用python，手动滑稽），本题数据均是超过30位的非负整数，就需要用到大数除以及取模操作。开始时，我能想到的只有暴力。显然，暴力不能解决问题。于是我就…打开了万能的百度…
本题特别的由十进制转二进制。在转二进制时，如何判断当前数值取模结果，主要在于当前十进制数末位奇偶状态，奇数为1，偶数为0。
int len = strlen(str); ans = num[len-1]%2; 取模后，需要用当前数除进制数 ”2“得新数 ，按照除法运算的规则，可以明显发现，被除数当前位为奇时，借给下一位的值为10，反之为0。可以用和大整数加法类似的变量 x 来存储借位值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92ac3f9c01af7720ad7a9919ca9060a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbdccf54e400c40ee3c4c86b31b353c7/" rel="bookmark">
			linux 16.04 WIFI,解决Ubuntu 16.04没有WiFi链接的方法（自测成功）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
Ubuntu16.04无法连接Wifi解决方案 (绝对有效)
方法二：
【菜鸟向】Ubuntu无法连接wifi问题的解决
方法三：我使用的方法
１．　查找自己电脑的无线网卡型号
lspci -nnk | grep -iA2 net
我的结果为
03:00.0 Ethernet controller [0200]: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller [10ec:8168] (rev 0c)
Subsystem: Lenovo RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller [17aa:36f3]
Kernel driver in use: r8169
Kernel modules: r8169
04:00.0 Network controller [0280]: Realtek Semiconductor Co., Ltd. RTL8821CE 802.11ac PCIe Wireless Network Adapter [10ec:c821]
Subsystem: Lenovo Device [17aa:c024]
Kernel driver in use: rtl8821ce
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbdccf54e400c40ee3c4c86b31b353c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce902300c7c01d9c5471c1f995b0d79/" rel="bookmark">
			resnet152
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		152是指152次卷积
其中block共有3+8+36+3 = 50个
每个block是由3层卷积构成的bottle_net block.共150个卷积
开头一个卷积将3通道的图片提取特征。
后面一个nn.AdaptiveAvgPool2d((1,1)), 就是自适应平均池化，输出维度为1.
因为本来上面的各层卷积后输出的还是一个二维矩阵。图中的64,128等都是通道数，也就是二维矩阵的个数。最后要通过自适应池化将卷积最后的矩阵转换称一个1维的数。
然后才能用线性层进行维度映射。进行分类。
resnet用于不同的任务中，前面的提取特征部分都是一样的，知识后面的池化+线性部分，也就是决策器，不同。
用于图像分类、识别、跟踪、分割
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8183aaea0023aa08c15a5d975af9095/" rel="bookmark">
			win10 git是linux吗,Windows计算机上的Git Bash和Linux之间是什么关系？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我已经在Windows计算机上安装了Git Bash。 它的行为与正常的命令提示符非常不同。
为什么有什么不同？ 它看起来像Linux。 仅仅是类似于Linux的命令编写风格还是Git Bash中包含Linux？
它的行为与cmd不同，因为它是bash(再次是bourne shell)。
What is the relationship between Git Bash and Linux
Linux和Bash之间的唯一关系是Bash经常用于Linux系统(以及其他系统)。 Git Bash只是为了能够找到Git工具而设置的Bash。在Linux系统上通常不需要这样做(因此，在Linux系统上找不到称为Git Bash的东西)。
It behaves very differently from the normal command prompt.
这是一个不同的外壳(和一个不同的终端仿真器)。
It seems to behave like Linux.
无论Bash是在Windows还是Linux(或OS X，BSD或任何其他操作系统)上运行，Bash的行为实际上都相同。但这是Bash的属性，而不是Linux的属性。
is Linux included in Git Bash
没有。
git bash是bash解释器。
bash是一个外壳程序(bash实际上是Bourne Again SHell的首字母缩写)，它是在类Unix系统上非常流行的外壳程序，不包括Linux，也包括OS-X等其他系统。
但是它不包括linux(基本上是一个二进制文件；如果您从w32系统中提取cmd.exe，并将其提供给朋友，那么您就没有给他们Windows了)。
bash非常强大，但是其真正的优势来自于Unix哲学，即拥有许多可以(仅)擅长完成工作的小工具。外壳将那些工具粘合在一起。
bash的行为与cmd完全不同，因为它是另一种语言的解释器。就像python与java不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad5e3f7631cbc18fcc477c1b214b9f8/" rel="bookmark">
			[GWCTF 2019] xxor 笔记与思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对我这种新手来说算是比较怪异的一题了，故此记录一下过程。
解题过程：
直接放入IDA，并找到main函数，得到如下代码(看了一些其他师傅的WP，发现我们的IDA分析结果各不相同，最明显的就是HIDOWRD和LODWORD函数，该差异将在下文分析)
__int64 __fastcall main(int a1, char **a2, char **a3) { int i; // [rsp+8h] [rbp-68h] int j; // [rsp+Ch] [rbp-64h] __int64 v6[6]; // [rsp+10h] [rbp-60h] BYREF __int64 v7[6]; // [rsp+40h] [rbp-30h] BYREF v7[5] = __readfsqword(0x28u); puts("Let us play a game?"); puts("you have six chances to input"); puts("Come on!"); v6[0] = 0LL; v6[1] = 0LL; v6[2] = 0LL; v6[3] = 0LL; v6[4] = 0LL; for ( i = 0; i &lt;= 5; ++i ) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad5e3f7631cbc18fcc477c1b214b9f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fecd48bdc3d6691df083ada858276e9d/" rel="bookmark">
			MVC【AJAX技术】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**AJAX技术是一种后台请求服务器，而不需要加载Web页面的一种技术** 1，AJAX的来源地： MVC框架支持AJAX，而AJAX的核心来自于jQuery，所以编写的代码也在JQuery里面。 2，AJAX的使用方式 **jQuery.ajax函数** 例如： 第一步：
HTML代码
&lt;div id="div"&gt; &lt;label&gt;标题：&lt;/label&gt;&lt;input name="title" id="title" type="text" /&gt;&lt;br /&gt; &lt;button onclick="Check()"&gt;提交留言&lt;/button&gt; &lt;/div&gt; JS代码
&lt;script&gt; function Check() { $.ajax({ url: "/Ajax/A", type: "post", data: { "title": $("#title").val(), "email": $("#email").val(), "qq": $("#qq").val(), "content": $("#content").val() }, success: function (fanhui) { if (fanhui) { $("#div").html(fanhui) } } }) } &lt;/script&gt; 第二步：
控制器代码
public ActionResult A() { return View(); } [HttpPost] public string A(string title) { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fecd48bdc3d6691df083ada858276e9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989732ea71016d74585af7485182dd8d/" rel="bookmark">
			linux双机配置文件,linux双机GFS的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、两台服务器安装如下包：
apr-1.2.7-11.el5_3.1.x86_64.rpm
apr-util-1.2.7-11.el5.x86_64.rpm
cman-2.0.115-34.el5.x86_64.rpm
cman-devel-2.0.115-34.el5.i386.rpm
cman-devel-2.0.115-34.el5.x86_64.rpm
gfs2-utils-0.1.62-20.el5.x86_64.rpm
gfs-utils-0.1.20-7.el5.x86_64.rpm
gmp-4.1.4-10.el5.x86_64.rpm
httpd-2.2.3-43.el5.x86_64.rpm
ipvsadm-1.24-10.x86_64.rpm
kernel-xen-2.6.18-194.el5.x86_64.rpm
kmod-gfs-0.1.34-12.el5.x86_64.rpm
kmod-gfs-xen-0.1.34-12.el5.x86_64.rpm
lvm2-cluster-2.02.56-7.el5.x86_64.rpm
openais-0.80.6-16.el5.x86_64.rpm
perl-Net-Telnet-3.03-5.noarch.rpm
perl-XML-LibXML-1.58-6.x86_64.rpm
perl-XML-LibXML-Common-0.13-8.2.2.x86_64.rpm
perl-XML-NamespaceSupport-1.09-1.2.1.noarch.rpm
perl-XML-SAX-0.14-8.noarch.rpm
pexpect-2.3-3.el5.noarch.rpm
php-5.1.6-27.el5.x86_64.rpm
php-cli-5.1.6-27.el5.x86_64.rpm
php-common-5.1.6-27.el5.x86_64.rpm
piranha-0.8.4-16.el5.x86_64.rpm
postgresql-libs-8.1.18-2.el5_4.1.x86_64.rpm
ql-dynamic-tgt-lun-disc-2.3.tgz
rgmanager-2.0.52-6.el5.x86_64.rpm
system-config-cluster-1.0.57-3.noarch.rpm
rpm -ivh * --force
2、两台服务器修改主机名
/etc/sysconfig/network
/etc/init.d/network restart
3、修改/etc/lvm/lvm.conf中的locking_type值为3：locking_type = 3
4、在两个节点上配置集群
service cman start
service clvmd start
service gfs start
service rgmanager start
5、一个节点
pvcreate /dev/mapper/mpath1
vgcreate /dev/vggfs /dev/mapper/mpath1
lvcreate -L 95G -n lvgfs vggfs
在另一节点
vgscan
lvscan
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/989732ea71016d74585af7485182dd8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4d4b39e43ab6aaddb5a51ee7d6f4020/" rel="bookmark">
			linux的学习路径,Linux学习路线图『从入门到精通』
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习任何知识，目标明确很重要。如果你要学习Linux，下面分享一张Linux学习路线图，帮你明确学习目标，告诉你Linux应该怎样学。
一、学习Linux要达到什么程度?
1. 掌握至少50个以上的常用命令。
2. 熟悉Gnome/KDE等X-Windows桌面环境操作 。
3. 掌握.tgz、.rpm等软件包的常用安装方法
4. 学习添加外设，安装设备驱动程序(比如网卡)
5. 熟悉Grub/Lilo引导器及简单的修复操作 。
6. 熟悉Linux文件系统 和目录结构。
7. 掌握vi,gcc,gdb等常用编辑器，编译器，调试器 。
8. 理解shell别名、管道、I/O重定向、输入和输出以及shell脚本编程。
9. 学习Linux环境下的组网。
二、Linux学习路线图
嵌入式Linux学习大致分为三部分：
A、 Linux操作系统使用
本课程从零起点，讲述了linux内核的起源、发展历程以及目前广泛的应用场合;概述了linux系统的基本组成框架及组件功能;详细介绍Linux下的文件管理、用户管理、网络管理、软件管理等基本命令;以及包括VI编辑器，GCC编译器，GDB调试器和 Make 项目管理工具等在内的C语言环境搭建知识。
B、嵌入式Linux C语言编程
C语言是嵌入式领域重要也是主要的编程语言，本课程将在学员C语言基础知识之上，通过大量编程实例重点讲解C语言的高级编程知识，包括函数与程序结构、指针、数组、常用算法、库函数的使用等知识。
C、嵌入式Linux C语言数据结构及经典算法编程
数据结构是一门非常重要的基础课，在linux内核、底层驱动、通信协议及实际开发中都有大量应用。本课程重点讲解数据结构的基础内容，包括顺序表、链表、队列、栈、树、图、哈希表、各种查找和排序算法等。每种重要的数据结构都会介绍其理论知识及C语言的实现，还会结合实例讲解其在实际中的应用。
华清远见嵌入式Linux学习路线图：
linux和嵌入式系统属于相互交叉，嵌入式系统的发展让linux的应用更加广泛，同样linux的开源，可定制，灵活性强适合嵌入式系统，所以这里给出的是完整的嵌入式Linux学习路线图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8639446a950b49367d33c6e3637ed6ee/" rel="bookmark">
			第九届蓝桥杯大赛个人赛决赛（软件类）C大学B组 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因能力有限，题解部分参照前辈想法，并加以博主思考。
如有不足，欢迎指正~！
目录 试题A： 换零钞试题B： 激光样式试题C： 格雷码试题D： 调手表试题E： 搭积木（待解决）试题F： 矩阵求和（待解决） 试题A： 换零钞 题目：
x 星球的钞票的面额只有：100元， 5元， 2元， 1元，共4种。
小明去x星旅游，他手里只有2张100元的 × 星币，太不方便，恰好路过×星银行就去换零钱。
小明有点强迫症，他坚持要求200元换出的零钞中2元的张数刚好是1元的张数的10倍，剩下的当然都是5元面额的。
银行的工作人员有点为难，你能帮助算出：在满足小明要求的前提下，最少要换给他多少张钞票吗?
（5元， 2元， 1元面额的必须都有，不能是0）
注意，需要提交的是一个整数，不要填写任何多余的内容。
答案：
74
题解：
简单数学题，若使零钞最少，则5元面额最多，且1元、2元、5元面额必须都有。
假设num1、num2、num5分别是1元、2元和5元零钞的张数，
其中 num2 == 10 * num1; num1 + 2 * num2 + 5 * num5 == 200。
通过循环枚举即可解决问题。
#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main(){ /* num1、num2、num5分别是1元、2元和5元零钞的张数， 其中 num2==10*num1; num1+2*num2+5*num5==200。 */ int num1,num2,num5; for(num1=1;num1&lt;=200;++num1){ num2=num1*10; if((200-(num1+2*num2))%5==0){ num5=(200-(num1+2*num2))/5; // num5 必须为正数 if(num5&gt;0) break; } // break条件，在最少零钞前提下，x星币价值==200。 } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8639446a950b49367d33c6e3637ed6ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e413e7c25a646ccf3b02249b098f27/" rel="bookmark">
			【前端性能优化】长列表优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是长列表？ 1.1 概念 前端的业务开发中会遇到一些数据量较大且无法使用分页方式来加载的列表，我们一般把这种列表叫做长列表。
1.2 参考案例 比如淘宝网的商品列表页，一个手机屏可以容纳10个左右商品。如果每次只请求10个商品，一次请求10个商品和50个商品，数据返回所需要的时间相差不大。对于mysql优化，强调的也是减少查询的次数。所以说如果每次只请求10条数据对服务端来说压力会比较大，前端的长列表优化就变得比较重要。
2 优化方案 完整渲染的长列表基本上很难达到业务上的要求的，非完整渲染的长列表一般有两种方式：
2.1 懒渲染 2.1.1 懒渲染概念 就是常见的无线滚动，每次只渲染一部分（比如10条），等剩余部分滚到可见区域，再渲染一部分。
2.1.2 原理 用数组保存所有的数据，根据一屏幕能渲染的数量大致算出一次性渲染的数量，比如10，然后将数据源数组10个分为一组生产一个二维数组。列表后面跟着一个dom，监听滚动事件，当这个dom滚动到可视区域时，取出二维数组中数据来渲染。
2.1.3 参考实践 根据一屏幕数量分割源数组，splitArray方法。记录渲染了几组数据 groupIdx，默认0记录已经渲染的数据 componentList添加滚动事件在滚动事件中，判断列表后面的dom是否进入可视区域。 components/LazyLoad/index.js
import React, { useEffect, useState, useRef, useMemo } from 'react'; import PropTypes from 'prop-types'; // import loadable from '@loadable/component'; import { splitArray } from '../../utils/index'; import './index.css' // const RenderComponentByType = loadable(() =&gt; import('../RenderComponentByType/index')); function LazyLoadC({ dataSource }) { const clientHeight = document.documentElement.clientHeight || document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e413e7c25a646ccf3b02249b098f27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf64dd00edd3b22ad35dd16ae327e57/" rel="bookmark">
			linux安装redis5.0.7，并使用systemd管理redis服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装之前需要确认gcc版本，版本过低会导致下面编译报错
升级gcc
yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash echo "source /opt/rh/devtoolset-9/enable" &gt;&gt; /etc/profile 下载redis 官网👉https://redis.io/download
旧版本👉https://github.com/redis/redis/tags
上传、解压 [root@hadoop100 opt]# tar -zxvf redis-5.0.7.tar.gz 移动到/usr/local/redis [root@hadoop100 opt]# mv redis-5.0.7 /usr/local/redis [root@hadoop100 opt]# cd /usr/local/redis/ 编译 [root@hadoop100 redis]# make 编译成功结果如下👇
Hint: It's a good idea to run 'make test' ;) make[1]: Leaving directory `/usr/local/redis/src' 安装 [root@hadoop100 redis]# make PREFIX=/usr/local/redis install 修改配置文件 [root@hadoop100 redis]# vim redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf64dd00edd3b22ad35dd16ae327e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d9d11bdafafd8a65efb545fb3fd4fa/" rel="bookmark">
			通信方式的分类（串行通信和并行通信）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通信方式的分类串行通信和并行通信串行通信同步通信和异步通信单工、半双工和双工 并行通信 通信方式的分类 通信方式是指通信双方之间的工作方式或信号传输方式。
终端与其他设备（例如其他终端、计算机和外部设备）通过数据传输进行通信，根据数据的传输方式，有串行通信和并行通信。
串行通信又称为点对点通信，对于点对点之间的通信，
根据数据的同步方式，又分为异步传送和同步传送两种方式。
根据数据的传输方向与时间关系，又可分为单工通信、半双工通信及全双工通信三种方式。
通信方式的分类
该「通信方式的分类」图片引用CSDN博主「MR_普罗米修斯」的总结 https://blog.csdn.net/qq_44431690/article/details/104114594
串行通信和并行通信 数据通信的基本方式可以分为串行通信与并行通信两种。
串行通信：
定义：串行通信是指利用一条传输线将数据一位位地顺序传送。
传输方式：传输一个字节（8个位）的数据时，串口是将8个位排好队，逐个地在1条连接线上传输。
特点：通信线路简单，利用电话或电报线就可以实现通信，降低成本，适用于远距离通信，但传输速度慢。
并行通信：
定义：并行通信是指利用多条传输线将一个数据的各位同时传送。
传输方式：传输一个字节（8个位）的数据时，并口是将8个位一字排开，分别在8条连接线上同时传输。
特点：传输速度块，适用于短距离通信。
串行通信 同步通信和异步通信 根据通讯的数据同步方式，又分为同步和异步两种。可以根据通讯过程中是否有使用到时钟信号进行简单的区分。
异步通信：
在异步通讯中，不使用时钟信号进行数据同步，它们直接在数据信号中穿插一些同步用的信号位，或者把主体数据进行打包，以数据帧的格式传输数据。例如规定由起始位、数据位、奇偶校验位、停止位等。
某些通讯中还需要双方约定数据的传输速率，以便更好地同步 。波特率(bps)是衡量数据传送速率的指标。
同步通信：
在同步通讯中，收发设备双方会使用一根信号线表示时钟信号，在时钟信号的驱动下双方进行协调，同步数据。通讯中通常双方会统一规定在时钟信号的上升沿或下降沿对数据线进行采样。
在同步通讯中，数据信号所传输的内容绝大部分就是有效数据，而异步通讯中会包含有帧的各种标识符，所以同步通讯的效率更高，但是同步通讯双方的时钟允许误差较小，而异步通讯双方的时钟允许误差较大。
该「同步通信和异步通信」总结引用于博客园「孤情剑客」的《USART串口协议》https://www.cnblogs.com/The-explosion/p/11587930.html
单工、半双工和双工 串行通信又称为点对点通信，对于点对点之间的通信，根据数据的传输方向与时间关系，又可分为单工通信、半双工通信及全双工通信三种方式。
单工方式：
只允许数据按照一个固定的方向传送，在任何时刻都只能进行一个方向的通信，一个设备固定为发送设备，一个设备固定为接收设备。
半双工方式：
两个设备之间可以收发数据，但是不能在同一时刻进行，每次只能有一个设备发送，另一个站接收。
全双工方式：
在同一时刻，两个设备之间可以同时进行发送和接收数据。
并行通信 并行是指多比特数据同时通过并行线进行传送，数据的各个位同时传送，可以字或字节为单位并行进行，这样数据传送速度大大提高，通信速度快，但并行传送用的通信线多、成本高，线路长度受到限制，故不宜进行远距离通信。并且长度增加，干扰也会增加，数据也就容易出错。计算机或PLC各种内部总线就是以并行方式传送数据的。
参考：
「MR_普罗米修斯」的总结 https://blog.csdn.net/qq_44431690/article/details/104114594
「孤情剑客」的《USART串口协议》https://www.cnblogs.com/The-explosion/p/11587930.html
声明：[笔记整理] 内容整理自网络，如有错误欢迎指正，版权归原作者所有，若有侵权请联系删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e7ece751b6f9f7aab6bd1dcbe646bb/" rel="bookmark">
			最好用的数据分析软件jmp16中文版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jmp16(软件获取点击这里)是专为科学家和工程师打造的一款预测分析软件，也是该系列中的最新版本，所提供的一系列丰富的算法，能够让你更高效的构建和验证模型，从中找出最适合的问题解决方案，已成为全世界数十万科学家，工程师和其他数据探索人员选择的数据分析工具。同时，该版本也进行了多方面的优化和新增，提供了一些高级功能帮助用户从容应对复杂的分析工作，包括预测建模和交叉验证技术，从而将统计发现工作提升至全新的水平，还可通过新的度量和可视化，模型快捷方式和交互式模型比较，增强结构方程建模，另外，文本分析器平台推出了全新的词条选择和情感分析，支持您执行数据推导的情感分析，更好地了解客户真正要表达的含义。而且借助jmp16 pro可以帮助你解决例行性和存在性的统计问题，从轻松访问各种来源的数据，到使用快速，可靠的数据准备工具，以及执行选择统计分析，JMP都能让你在任何情况下最充分地利用数据，以此使数据科学家可以使用更多的预测方法来构建和识别更好的统计模型。
jmp pro16新功能 模型筛选PRO
没有一个模型可以拟合所有问题。您需要选择最适合的模型来探索当下问题的答案。欢迎使用全新的模型筛选平台：在这里，您可以比较多个模型并确定最适合您需求的模型，来减少模型拟合过程中所需的时间。
自动拟合多个预测模型，助您选出性能最佳的模型。
使用默认的微调参数，即可拟合所有可用的分类响应或连续响应的预测模型。
词条选择和情感分析PRO
您是否需要更好地了解客户的心声？文本分析器平台推出两个新功能，支持您执行数据推导的情感分析，更好地了解客户真正要表达的含义。
使用词条选择寻找到与您的响应变量关联度最强的词条。
使用情感分析功能，对客户评价、调查响应和表述进行分类，并从中解读出客户的情绪。
检测限分析
更轻松地执行分析，并支持针对定制设计中的一个或多个响应，制定检测下限和检测上限。
增强的结构化方程模型
支持以全新的测量和可视化方式评估测量模型、提供模型快捷方式，来轻松地指定相同模型以及交互式的模型比较表。
刻画器外推法控制
在刻画器探索预测或执行优化时，提供控制以免在原始数据范围之外外推过远。
其他功能
支持向量机(SVM)平台中支持超参数的回归和自动调整。
全新的拟合曲线实验设计(CDOE)在拟合曲线平台中使用广义回归，来预测样本中不必观察的补充变量的组合响应曲线。
函数数据分析器更新：全新的函数PCA诊断可呈现清晰的视图，让您了解已选定的FPC得分分数如何影响相应的预测。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a3f70f77f26bdef8b3d1369555f319/" rel="bookmark">
			Educational Codeforces Round 108 (Rated for Div. 2)  D. Maximum Sum of Products  思维 &#43; dp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传送门
文章目录 题意：思路： 题意： 给你两个长度为 n n n的数组 a , b a,b a,b，你可以至多反转一段连续区间，求 ∑ i = 1 n a i ∗ b i \sum _{i=1}^n a_i*b_i ∑i=1n​ai​∗bi​最大是多少。
n &lt; = 5 e 3 n&lt;=5e3 n&lt;=5e3
思路： 首先我们可以通过 n 2 n^2 n2来枚举所有的区间，但是要计算翻转之后的贡献的话还需要多加一个 n n n，这样复杂度是 n 3 n^3 n3，显然不可接受。
考虑能否通过小区间来递推出大区间。
定义 f [ i ] [ j ] f[i][j] f[i][j]为将 [ i , j ] [i,j] [i,j]段区间翻转之后变换的值，我们发现如果我们知道一个小区间 [ l , r ] [l,r] [l,r]，那么 [ l − 1 , r + 1 ] [l-1,r+1] [l−1,r+1]的区间贡献就是在 [ l , r ] [l,r] [l,r]的贡献基础上再将 l − 1 , r + 1 l-1,r+1 l−1,r+1两个位置的值互换了一下，互换两个值 l , r l,r l,r对答案的贡献为 a [ l ] ∗ b [ l ] + a [ r ] ∗ b [ r ] + a [ l ] ∗ b [ r ] + a [ r ] ∗ b [ l ] = a [ l ] ∗ ( b [ r ] − b [ l ] ) + a [ r ] ∗ ( b [ l ] − b [ r ] ) a[l]*b[l]+a[r]*b[r] +a[l]*b[r]+a[r]*b[l]=a[l]*(b[r]-b[l])+a[r]*(b[l]-b[r]) a[l]∗b[l]+a[r]∗b[r]+a[l]∗b[r]+a[r]∗b[l]=a[l]∗(b[r]−b[l])+a[r]∗(b[l]−b[r])，所以我们可以通过 [ l , r ] [l,r] [l,r]扩展到 [ l − 1 , r + 1 ] [l-1,r+1] [l−1,r+1]，所以转移方程为 f [ l ] [ r ] = f [ l − 1 ] [ r + 1 ] + ( a [ l ] − a [ r ] ) ∗ ( b [ r ] − b [ l ] ) f[l][r]=f[l-1][r+1]+(a[l]-a[r])*(b[r]-b[l]) f[l][r]=f[l−1][r+1]+(a[l]−a[r])∗(b[r]−b[l])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05a3f70f77f26bdef8b3d1369555f319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49374a8b3a6ae7f579a2c3c48e72efa/" rel="bookmark">
			Tik
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在 [filter_remote] 中添加以下内容
https://raw.githubusercontent.com/Semporia/Quantumult-X/master/Filter/TikTok.list, tag=TikTok, force-policy=TikTok, update-interval=86400, opt-parser=false, enabled=true 2.在 [rewrite_local] 中添加以下内容
(?&lt;=&amp;mcc_mnc=)4 url 307 2 ^(https?:\/\/(tnc|dm)[\w-]+\.\w+\.com\/.+)(\?)(.+) url 302 $1$3 (?&lt;=\d\/\?\w{7}_\w{4}=)1[6-9]..(?=.?.?&amp;) url 307 17 (?&lt;=_region=)CN(?=&amp;) url 307 US 3.在 [mitm] 中添加以下内容
hostname = *.tiktokv.com, *.byteoversea.com, *.tik-tokapi.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b7d54aef887a88f1ddcb1eea5fc617/" rel="bookmark">
			SPSS报错can not create java virtual machine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决SPSS中can not create java virtual machine问题
https://blog.csdn.net/a273868471/article/details/76427702
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446ecb006773805247c7a0b5fe287a88/" rel="bookmark">
			Ansible 2.4：Playbook 中变量的多种使用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.4：Playbook 中变量的多种使用方式 关于如何在Playbook中使用变量的官方文档：https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html
在Playbook中调用变量的方式有：
调用变量的值：{{ VARIABLE_NAME }}有时需要加双引号，避免被解析为内联字典："{{ VARIABLE_NAME }}"当调用变量的字符串中有:时，避免被解析为key: value，也要为整个字符串加上引号："STRING: {{ VARIABLE_NAME }}"当调用变量作为key: value中的value时，也需要加上引号：key: "{{ VARIABLE_NAME }}"调用变量名，则直接使用变量名，什么也不加：VARIABLE_NAME
比如在Playbook中的某些模块中使用var参数来指定变量名：debug: var=VARIABLE_NAME Playbook中调用的变量有以下来源：
setup模块获取的fact信息，其中就包含了大量的变量，可以直接调用。
为Playbook传递的自定义变量，这其中包括了：
通过命令行 ansible-playbook -e VARIABLE_NAME=VALUE PLAYBOOK.yml 定义的变量；Playbook中通过var_files定义的变量文件中的变量；Playbook中通过vars定义的变量；Ansible项目中在host_vars/HOSTNAME文件中定义的主机变量（文件名是HOSTNAME，与主机清单中定义的主机名一致）；主机清单文件中定义的主机变量；Ansible项目中在group_vars/GROUPNAME文件中定义的主机组变量（文件名是GROUPNAME，与主机清单中定义的主机组名一致）；Ansible项目中在group_vars/all文件中定义的公共变量（该文件中定义的变量对主机清单中的所有主机生效）；主机清单文件中定义的主机组变量。 优先级从高到低。
为Playbook的Role传递的自定义变量：
roles/ROLE_NAME/vars/main.yml文件中定义的变量；roles/ROLE_NAME/defaults/main.yml文件中定义的变量。 优先级从高到低。
2.4.1：使用 facts 信息中的变量 Playbook在执行时默认就会收集目标主机的facts信息并存为变量，可以指定变量来直接调用。当在Playbook中使用facts变量时，就不能将gather_facts设为no。
2.4.1.1：ansible_nodename 该变量保存的是目标主机的主机名。
示例：
- hosts: websrvs tasks: - name: ansible_nodename debug: msg: "目标主机名: {{ ansible_nodename }}" 执行结果：
2.4.1.2：ansible_IFNAME.ipv4.address 该变量保存的是目标主机特定网络接口的ipv4地址。
IFNAME为目标主机的网络接口名称，如eth0。
也可以由ansible_facts.IFNAME.ipv4.address取得。
示例：
- hosts: websrvs tasks: - name: ansible_eth0.ipv4.address debug: msg: "eth0的ipv4地址: {{ ansible_eth0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/446ecb006773805247c7a0b5fe287a88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325d2adf87448e53256166f95f71768a/" rel="bookmark">
			linux中配置文件作用,linux各种配置文件的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家总结一下linux中各种配置文件的作用，这样配置开发环境时，会事半功倍。
笔者的linux是Centos6.0，可能有些配置文件与其他distributions不同。
/etc/profile
这个文件是系统的总体设置，也就是说，所有用户在登录时，都会读取这个文件的配置，如果你想为所有用户设置通用的环境变量，比如java开发环境的jdk环境变量，可以写在这个文件里。这个文件设置的变量主要有：
PATH：会依据UID决定PATH变量要不要含有sbin的系统命令目录；
MAIL：依据帐号设置好用户的mailbox到/var/spool/mail/帐号名；
USER：根据用户的帐号设置此变量内容；
HOSTNAME：依据主机的hostname命令决定此变量内容；
HISTSIZE：历史命令记录条数。
这个文件里还有一些shell脚本，主要是调用其他配置文件的数据：
/etc/inputrc:用户自定义输入按键功能
/etc/profile.d/*.sh：bash操作接口的颜色、语系、命令别名
/etc/sysconfig/i18n：默认语系
下面是笔者系统中该文件的部分内容：
#You could check uidgid reservation validity in
# /usr/share/doc/setup-*/uidgid file
if [ $UID -gt 199 ] &amp;&amp; [ "`id -gn`" = "`id -un`" ]; then
umask 002
else
umask 022
fi
for i in /etc/profile.d/*.sh ; do
if [ -r "$i" ]; then
if [ "${-#*i}" != "$-" ]; then
. "$i"
else
. "$i" &gt;/dev/null 2&gt;&amp;1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/325d2adf87448e53256166f95f71768a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16dd25d16359464c2baf843ff1e8cb6/" rel="bookmark">
			linux 5060端口号,linux常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有指令都可以通过man查看使用方法，比如想知道cp的使用方法直接敲man cp，按q退出
1、网络类
功能 指令
查看端口占用情况 lsof -P -i -n | grep 5060
查看端口状态(Linux) netstat -antp | grep 5060
查看端口状态(Windows) netstat -anb | find "5060"
过滤方法(加上-v -E过滤不需要的内容) netstat -antp | grep 5432 | grep -v -E "postgres"
临时关闭防火墙 service iptables stop
永久关闭防火墙 chkconfig --level 345 iptables off
查看SELinux状态 sestatus
关闭SELinux状态(需重启) vim /etc/sysconfig/selinux
SELINUX =disabled
添加路由(Linux) route add -net 207.207.0.0 gw 208.208.69.1 netmask 255.255.0.0
添加路由(Windows) route add 207.207.0.0 mask 255.255.0.0 208.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e16dd25d16359464c2baf843ff1e8cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a57ef7d5ebcca29c150a3100500bf0f/" rel="bookmark">
			使用windbg挖地雷直接取胜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用windbg挖地雷直接取胜
前面一篇文章探讨了如何直接明挖地雷,通过windbg修改了雷区就可以了. 这次我们更直接,看看如何通过函数飞针直接取胜.
使用windbg直接打开winmine.exe
先运行起来:g 共99个雷.
先看如何把雷个数改为0, break这个程序. 用x命令显示所有符号
0:005&gt; x winmine!*
01001004 winmine!_imp__RegSetValueExW = &lt;no type information&gt;
0100511c winmine!yCur = &lt;no type information&gt;
01005b8c winmine!__onexitend = &lt;no type information&gt;
01001108 winmine!_imp__GetDlgItemTextW = &lt;no type information&gt;
010010cc winmine!_imp__RegisterClassW = &lt;no type information&gt;
010057a0 winmine!cBoxVisitMac = &lt;no type information&gt;
01001178 winmine!_imp____p__fmode = &lt;no type information&gt;
0100118c winmine!_imp____getmainargs = &lt;no type information&gt;
01005158 winmine!hGrayPen = &lt;no type information&gt;
01002eab winmine!ChangeBlk = &lt;no type information&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a57ef7d5ebcca29c150a3100500bf0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22211c8aa910fc5488903a5b5da8575f/" rel="bookmark">
			linux程序间管道通信,linux进程间通信——管道 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		管道是Linux中很重要的一种通信方式，是把一个程序的输出直接连接到另一个程序的输入。常说的管道多是指无名管道，
无名管道只能用于具有亲缘关系的进程之间，这是它与有名管道的最大区别。
有名管道叫named pipe或者FIFO(先进先出)，可以用函数mkfifo()创建。
Linux管道的实现机制
在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现为：
· 限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即
4K字节，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如：
在写管道时可能变满，当这种情况发生时，
随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。
· 读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，
管道变空。当这种情况发生时，
一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。
注意：
从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。
1. 管道的结构
在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。
2.管道的读写
管道实现的源代码在fs/pipe.c中，在pipe.c中有很多函数，其中有两个函数比较重要，即管道读函数pipe_read()和管道写函数 pipe_wrtie()。管道写函数通过将字节复制到 VFS 索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，
内核必须利用一定的机制同步对管道的访问，为此，内核使用 了锁、等待队列和信号。
当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的 file 结构。file 结构中指定了用来进行写操作的函数(即写入函数)地址。于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查 VFS 索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：
·内存中有足够的空间可容纳所有要写入的数据；
·内存没有被读程序锁定。
如 果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在 VFS 索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。
写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写 入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。
管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。
因为管道的实现涉及很多文件的操作，因此，当读者学完有关文件系统的内容后来读pipe.c中的代码，你会觉得并不难理解。
Linux 管道的创建和使用都要简单一些，唯一的原因是它需要更少的参数。实现与 Windows 相同的管道创建目标，Linux 和 UNIX 使用下面的代码片段：
int fd1[2];
if(pipe(fd1))
{ printf("pipe() FAILED: errno=%d",errno);
return 1;
}
Linux 管道对阻塞之前一次写操作的大小有限制。 专门为每个管道所使用的内核级缓冲区确切为 4096 字节。 除非阅读器清空管道，否则一次超过 4K 的写操作将被阻塞。 实际上这算不上什么限制，因为读和写操作是在不同的线程中实现的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22211c8aa910fc5488903a5b5da8575f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0755e6aac4c95695a88181ac3bcc3938/" rel="bookmark">
			Restful  API规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.0 restful规范 restful规范是前端与后台进行通讯的一种规范，使用这个规范可以使前后端开发更方便。
1.1 协议 采用http或https协议。
1.2 数据传输格式 数据传输的格式应该都采用json,而不使用XML。
1.3 urL链接 url链接不能有动词，只能有名词，并且对于一些名词，如果出现复数，应该在后面加s
1.4 http请求方法 GET：从服务器上获取资源POST：在服务器上新建一个资源PUT：在服务器上更新资源，客户端提供所有改变后的数据PATCH：在服务器上更新资源，客户端只提供需要改变的属性DELETE:从服务器上删除资源 #示例： GET /users/ :获取所有用户 POST /user/:新建一个用户 GET /user/id/ :根据id获取一个用户 PUT /user/id :更新某个id的用户信息，（需要提供用户所有信息） PATCH /user/id/: 更新某个id的用户信息(只需要提供需要改变的信息) DELETE /user/id/:删除一个用户 2.0 状态码 状态码描述200服务器成功响应请求400用户发出的请求有错误，服务器没有进行新建或修改数据的操作401用户没有权限访问这个请求403因为某些原因禁止访问这个请求404用户发送的请求url不存在406用户的请求不被服务器接收，500服务器内部错误，如出现了bug 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca10ae3cc5872580d3af9b37590f49f1/" rel="bookmark">
			使用kettle从pg同步增量数据到clickhouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pg测试表 create sequence public.add1byself INCREMENT BY 1 MINVALUE 1 START WITH 1; create table public.tb3 ( id int not null default nextval( 'public.add1byself' ) primary key, name varchar(20), update_sj timestamp(0) ); --搞几条数据 insert into tb3 (name, update_sj) values ( 'shanghai', now() ); clickhouse测试表 create table tb5 ( id UInt64, name String default '', gxsj DateTime default '0000-00-00 00:00:00' ) engine = MergeTree PARTITION BY toYYYYMMDD(gxsj) ORDER BY gxsj SETTINGS index_granularity = 8192; kettle 先把连接建起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca10ae3cc5872580d3af9b37590f49f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4a5f1b86168771a0086e232fd9a8439/" rel="bookmark">
			kettle添加clickhouse插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打jar包 到这个地址把代码down下来
https://github.com/aaa8210/kettle2clickhouse/pull/1
打包会得到以下两个jar文件：
KettleClickhouseJDBC-9.1.0.0-324.jar
TncKettleClickhouse-1.0-SNAPSHOT.jar
把这两个文件copy到kettle的 plugin/clickhouse-plugin 下，自己把目录建起来。
然后再把clickhouse-jdbc-0.3.0.jar， lz4-1.3.0.jar 这两个文件copy到 libswt\win64下。
clickhouse-jdbc-0.3.0.jar的下载地址：
https://mvnrepository.com/artifact/ru.yandex.clickhouse/clickhouse-jdbc/0.3.0
lz4-1.3.0.jar的下载地址：
https://mvnrepository.com/artifact/net.jpountz.lz4/lz4/1.3.0
这样就可以启动了。
kettle的版本 以上步骤在7.1环境中测试通过。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98cf3abb72e75442a24b2af9eb87ca9e/" rel="bookmark">
			Delphi随笔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、判断语句
当出现多个判断条件时，如果是and，前面出现false的情况时，后面的条件不会进行判断，如果是or，前面出现true的情况时，后面的条件不会进行判断
procedure TForm1.FormCreate(Sender: TObject); var function Check1: Boolean; begin ShowMessage('1'); result := False; end; function Check2: Boolean; begin ShowMessage('2'); Result := True; end; begin if Check1 and Check2 then ShowMessage('3'); // 分别弹出 1 3 if Check1 or Check2 then ShowMessage('4'); // 1 2 3 if Check2 and Check1 then ShowMessage('5'); // 2 1 5 if Check2 or Check1 then ShowMessage('6'); // 2 6 end; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7698a3db59a789462475b381de79cccb/" rel="bookmark">
			Kettle8.2 百度网盘下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 csdn上很多无耻之人将免费的东西拿去卖钱！！！ 下面这个是免费的百度版 https://www.pianshen.com/article/9692267032/
欢迎拿走 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5937e97c9db0e918b644d7af738ce1a4/" rel="bookmark">
			c&#43;&#43; pipeline设计模式的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pipeline 设计模式的实现， 有几个小问题暂时还懒得解决
第二版已修复
getDownStream 每次都重新生成新的对象，可以优化下pipeline 模式的核心是 downstream 可以方便提供， 目前写死了。 #include &lt;string.h&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;numeric&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; #include &lt;unordered_set&gt; #include &lt;utility&gt; #include &lt;vector&gt; #include &lt;thread&gt; #include &lt;atomic&gt; #include &lt;typeinfo&gt; #include &lt;pthread.h&gt; using namespace std; class LifeCycle { public: virtual void init(std::string config) = 0; virtual void startUp() = 0; virtual void shutDown() = 0; }; template&lt;typename T&gt; class Component : public LifeCycle { public: virtual std::string getName() = 0; virtual void execute(T t) = 0; }; template&lt;typename T, typename R&gt; class AbstractComponent : public Component&lt;T&gt; { protected: virtual std::vector&lt;shared_ptr&lt;Component&lt;R&gt;&gt;&gt; getDownStream() = 0; protected: virtual R doExecute(T t) = 0; public: void init(std::string config) override { } void execute(T t) override { R r = doExecute(t); cout &lt;&lt; this-&gt;getName() + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5937e97c9db0e918b644d7af738ce1a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a8010c66b2aa1e65b0be28dfeafe70/" rel="bookmark">
			总结20 -- 有关netstat命令的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 经过查阅资料，总结有关netstat命令如下：
目录
netstat命令的作用：
netstat命令的常见参数:
如何利用netstat命令查看某个端口是否被占用？
如何杀死杀掉占用端口的进程？ netstat命令的作用： Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接等。
netstat命令的常见参数: -a : (all)显示所有选项，默认不显示LISTEN相关
-t : (tcp)仅显示tcp相关选项
-u : (udp)仅显示udp相关选项
-n : 拒绝显示别名，能显示数字的全部转化成数字。
-l : 仅列出有在 Listen (监听) 的服務状态
-p : 显示建立相关链接的程序名
-r : 显示路由信息，路由表
-e : 显示扩展信息，例如uid等
-s : 按各个协议进行统计
-c : 每隔一个固定时间，执行该netstat命令。
提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到
如何利用netstat命令查看某个端口是否被占用？ #我习惯加上下面的参数，既可以看到端口号、也可以看到是否端口号被占用和使用该端口号的进程
#查看当前所有已经使用的端口情况
netstat -nultp #查看某一个端口的具体信息
netstat -nultp | grep 端口号 如何杀死杀掉占用端口的进程？ kill -9 端口号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b164fd5bf9ad48118e8171e4c505a8db/" rel="bookmark">
			ISO9706.1中对于医疗器械的安全分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		医用设备的分类
按防电击类型分类：
Ⅰ类设备和Ⅱ类设备 按防电击的程度分类：
——B型设备：对电击有特定防护程度的设备。允许漏电流，保护接地连接（若有）的可靠性。如：彩超、电子血压计等。
——BF型：有F型应用设备部分的B型设备。允许漏电值规定值增加了对应用部分加电压的电流测试。如：理疗科低频电子脉冲治疗设备。
——CF型：对电击的防护特别是在允许漏电流值方面高于BF型，并且有F型应用部分的设备。CF型主要预期直接用于心脏。如：心电图机、心电监护仪。
按运行模式分类：
——连续运行；
——短时运行；
——间歇运行；
——短时加载连续运行；
——间歇加载连续运行。
漏电流测试：
I 类设备外壳漏电流的测量应仅限于：
——未保护接地外壳的每一部分(如有)到地。
——未保护接地外壳的各部分(如有)之间。
图10 图11 图12 图13 图16 图17 图18 图19 电介质强度：
电压试验：
电气间隙和爬电距离：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7521cbe29efa0b67aed1aea8cf1b1be/" rel="bookmark">
			计算机网络之基本计量单位和进制转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络之存储单位 计算机及计算机网络中传输、存储、运算基本计量单位基本计量单位计算机计量标准 进制说明进制转换进制转换总结 计算机及计算机网络中传输、存储、运算基本计量单位 基本计量单位 位（bit）：
位是计算机内部数据储存的最基本单位。也称比特，可用b来表示数据在物理层就是通过比特流进行传输的计算机中的CPU位数指的是CPU一次能处理的最大位数 字节（byte）：
字节是计算机中数据处理的基本单位，计算机中以字节为单位存储和解释信息。可用B表示规定一个字节由八个二进制位构成，即一个字节等于8个比特（1Byte = 8bit）通常1 个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。 字（word）：
字是计算机进行数据处理时，计算机一次存取、加工和传送的数据长度。一个字通常由一个或多个字节构成例如286微机的字是由两个字节组成，它的字长为16；486微机的字由4个字节组成，它的字节为32位机 字长：
字长是计算机中每个字包含的位数。根据计算机的不同，字长有固定和可变两种。固定字长，即长度不论什么情况都是固定不变的；可变字长，则在一定范围内，其长度是可变的计算机的字长是CPU一次操作可以处理的二进制比特数(0或1)。计算机处理数据的速率，自然和它一次能加工的位数以及进行运算的快慢有关 计算机计量标准 Linux操作系统中两套计量标准：
SI标准：国际单位制IEC标准：国际电工委员会标准 计算机中计量标准：
1B = 8b1KB = 1024B1MB = 1024KB1GB = 1024MB1TB = 1024GB1PB = 1024TB1EB = 1024TB 进制说明 进制定义：
进制也就是进位计数制。对于任何一种进制 =&gt; x进制，就表示每一个位置上的数运算时都是逢x进一位，如：十进制逢十进1，二进制逢二进1，八进制逢八进1，十六进制逢十六进1
计算机中常用进制：
十进制：
逢十进一基符：0，1，2，3，4，5，6，7，8，9比较普遍的一种进制，在工作、学习、生活中随处可见。 二进制：
逢二进一基符：0，1多用于计算机中 八进制：
逢八进一基符：0，1，2，3，4，5，6，7例如每周循环或Linux系统中权限表示 十六进制：
逢十六进一基符：0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F（a~f）多用于存储大数据中，例如IPV6地址，MAC地址 进制转换 十进制转换为二进制：
2^72^62^52^42^32^22^12^012864321684212551051011201111000 上图为：十进制5转二进制和十进制120转二进制
(5)10 = (101)2
(120)10 = (1111000)2
二进制转换为十进制：
2^72^62^52^42^32^22^12^0128643216842125510(1100)211001210(10110011)21011001117910 上图为：(1100)2 = (12)10 、(10110011)2 = (179)10
十进制转换为八进制：
2^72^62^52^42^32^22^12^0128643216842125510(120)101111000(120)8转换为二进制000从后面三位一组取出08111从后面三位一组取出78001从后面三位一组取出18最终取出1708 由3位二进制可以表示一位八进制，把二进制3位一组转换为八进制。将十进制转换二进制，再转换为八进制 上图为：(120)2 = (170)8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7521cbe29efa0b67aed1aea8cf1b1be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45b6074f6b17255ee23d4e3e0b2a7e1/" rel="bookmark">
			linux怎么看sda3内容,linux系统中/dev/sda3表示什么。急
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/dev/sda3表示的是硬盘分区。
/dev/sda是指接在SATA、SCSI第一个接口上的硬盘。
/dev/sda是指整个硬盘，实际使用中一般都会有分区，也就是/dev/sda1, /dev/sda2这样的。有一些分区已经挂载了，使用df命令，可以看到各个分区分区被挂载到哪个目录，然后ls查看想要查的目录。
使用fdisk命令查看分区的三种方法：
1、sudo fdisk -l
2、sudo fdisk /dev/sda进入交互模式，然后输入p
3、查看单个硬盘，通过 fdisk -l /dev/sad1
扩展资料：
对分区/dev/sda3的操作命令：
1、挂载：mount /dev/sda1 /mnt/asd，这样挂载分区到文件系统上，才能看/mnt/asd里的东西。
2、查看：ls -hl /mnt/asd
3、卸载：umount /dev/sda1
文件系统：指定要卸载的文件系统或者其对应的设备文件名
(1)、通过设备名卸载：umount -v /dev/sda1
(2)、通过挂载点卸载：umount -v /mnt/mymount/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c681f528a7a63ff3ea6a969fce97c0b0/" rel="bookmark">
			Django实现用户管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django实现用户管理 前言第一节 - 自定义模版和静态文件1. 自定义模版位置和静态文件2. 通用静态文件和模版设置模版设置： 3. 关于访问 /admin 报错的探究 第二节 - 用户登陆1. 创建应用 account2. 创建表单3. 编写视图函数4. 编写登陆页面的模版 第三节 - 用户登陆扩展知识（使用内置方法）1. 内置用户权限2. 内置的登陆和登出修改默认登陆方式的重定向地址 第四节 - 用户注册1. 注册表单类2. 视图函数编写3. 附加注册内容4. 管理新增的注册内容 附加：请求/响应对象属性剖析1. HttpRequest 对象2. HttpResponse 对象 结束 Django实现简单博客系统
建议先看文章列表中的《Django实现简单博客系统》，毕竟得一步一步来嘛。当然有过 Django 开发经验的，那就不说了。
django 官网地址：https://docs.djangoproject.com/zh-hans/2.2/contents/
本节 github：https://github.com/champion-yang/django_blog/tree/dev/blog_02
前言 在 《Django实现简单博客系统》中，我实现了一个简单的博客系统，可以增加修改用户，可以增改文章，并且可以让别人看到我的博客。但是这么简单的东西怎么能体现出来我的技术呢，哈哈，必须得给他上难度。所以本文打算设计一个用户模块，允许用户注册登陆退出网站，并且超级管理员可以对用户进行管理。
Djanog 中用户管理 django.auth.contrib.auth 有默认的登录方法login()，但是没有注册方法。本文介绍了一种自己实现登陆的方法，当然也对既有的登陆方法做了说明（支持），采用的数据模型是 Django 自带的 User，也对用户信息做了扩展 UserProfile 。
其实针对 Django 中的用户注册，是有第三方的方法的。比如 django-registration 。django 登陆模块还可以与第三方的账号集成，比如公司的域账号，不过需要第三方提供相应的 api。可以通过 Social Auth 了解一下 https://github.com/omab/django-social-auth。
第一节 - 自定义模版和静态文件 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c681f528a7a63ff3ea6a969fce97c0b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40f690390b188a6ec6e649cb2ad1261/" rel="bookmark">
			lmportError: DLL load failed while importing QtCore:找不到指定的程序。[15396] Failed to execute script界面i
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 用pyqt5做界面 然后报这个错误
ImportError: DLL load failed while importing QtCore:找不到指定的程序。
百度一大堆都是说什么python3.dll没有 但是我换过很多次都没有用
Traceback (most recent call last): File "界面1.py"， line 11， in &lt;module&gt; lmportError: DLL load failed while importing QtCore:找不到指定的程序。[15396] Failed to execute script界面i 最近在用pyqt5做界面 一开始都好好的 什么问题都没有 但是到最后一步用pyinstaller打包成exe可执行程序就开始无限的报错，我这里大概描述下遇到的哪些bug 第一个说我pyinstaller版本太低 python3.7不能搭配pyinstaller3.3 用 于是我去升级 升级报错 我就不知道怎么办了 我用的是vs2019 然后把代码发给同学 他就能打包 正常用，后来想办法升级了pyinstaller 重新打包 又报win32不是有效的程序，这应该和下载的位数有关，我又把pyqt5重新安装 接下来又遇到上面这个报错 这我心态已经没了 弄了好几天 我把环境全部重新卸载了重新装 aconda pycharm 结果还是报错 我有创了个虚拟机 重新做 遇到上面的这个问题 重新装下pyqt5就好了 虚拟机就可以用了 ， 解决方案： 重新安装pyqt5
如果还是不行 就看看pyqt5-tools 这个有没有 没有的话安装上 还是不行就去配置pyqt5的环境 如果还是不行 就去虚拟机里嚯嚯吧。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c40f690390b188a6ec6e649cb2ad1261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e8f539890ee7b2fa3d5f39be6027ac/" rel="bookmark">
			MAC 怎么查看8080端口是否被占用并且释放进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看端口被哪个程序占用
sudo lsof -i tcp:port（port是端口号） 如：sudo lsof -i tcp:8080 查看8080端口是否被占用
2.看到进程的PID，可以将进程杀死。（PID是输入查看指令后“node”后面的那个数字）
sudo kill -9 PID 如：sudo kill -9 3210
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f330a93cc2ee6235ce00bcfabc40e5/" rel="bookmark">
			C&#43;&#43;回调函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回调函数详解 1、什么是回调函数2、为什么需要回调函数3、有哪些函数可以做回调函数3.1静态成员函数做回调函数 4、小结 1、什么是回调函数 回调函数本质上也是普通函数，只是调用机制有所区别——首先通过传参的形式将该函数的地址传递给其他函数，然后在其他函数中通过函数指针调用该函数。在其他函数中通过函数指针调用该函数的过程称为回调，而作为被调用的该函数则被称为回调函数。有人可能会疑惑何必多此一举，直接在其他函数中调用该函数就好，为何一定要通过指针中转。 2、为什么需要回调函数 这就不得不提到项目联合开发带来的必然后果——接口的兼容性问题。举个超级简单的例子：程序员小A和程序员小B联合开发一个项目，要求小A开发的函数必须为小B开发的函数提供灵活可用的接口。 假如小A小B是好朋友，他们天天在一起，而且也不考虑开发效率问题，那就串行方式一起开发好了。如下例所示，在同一个文件中，小A先负责开发Add()函数，小B后负责开发add()函数，小A需要调用小B的函数，即小A为小B提供了一个接口，通过这个接口小B可以随意通过更改add()函数，间接更改了Add()函数。 由于小A在使用小B的函数前小B还没有实现，所以他们需要先一起商量一下小B需要实现的函数名称、函数返回值、参数类型，然后小A在调用前先声明。小A在完成自己的工作后就可以休息了，然后小B就按照之前商量好的定义函数，对于函数体中具体怎么写完全由小B自由发挥了： /*test.h*/ #include&lt;iostream&gt; using namespace std; int add(int,int); void Add(int a, int b) { cout &lt;&lt; add(a, b) &lt;&lt; endl; } int add(int a, int b) { return a + b; } /*main.cpp*/ #include"test.h" void main() { Add(1, 2); } 延续上文的故事，但现在场景变了。为了提高效率需要小A和小B并行操作，但工作类容没有变。显然他们需要在两个文件中完成各自的任务。小A同样需要声明小B的函数。对于现实中的项目开发而言，这种方式最为常见。 /*test.h*/ #pragma once #include&lt;iostream&gt; using namespace std; int add(int, int); void Add(int a, int b) { cout &lt;&lt; add(a, b) &lt;&lt; endl; } /*test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f330a93cc2ee6235ce00bcfabc40e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81482bce76e20547273bed161c562ee7/" rel="bookmark">
			Springboot任务管理(邮件发送异步同步,定时)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章节目录 前言一、任务管理的介绍二、使用步骤需要用到的依赖启动器1.异步任务无返回值异步任务调用1．Spring Boot 项目创建引入Web依赖2．编写异步调用方法3．开启基于注解的异步任务支持4．编写控制层业务调用方法5．异步任务效果测试有返回值异步任务调用 定时任务@EnableScheduling@**Scheduled**1.编写定时任务业务处理方法2.开启基于注解的定时任务支持3.定时任务效果测试 发送纯文本邮件1.添加邮件服务的依赖启动器2.添加邮件服务配置3.定制邮件发送服务4.纯文本邮件发送效果测试 发送带附件和图片的文件1.定制邮件发送服务 发送模板邮件 前言 这章节来学习Springboot的异步处理
提示：以下是本篇文章正文内容，下面案例可供参考
一、任务管理的介绍 开发Web应用时，多数应用都具备任务调度功能。常见的任务包括异步任务、定时任务和发邮件任务。
我们以数据库报表为例看看任务调度如何帮助改善系统设计。报表可能是错综复杂的，用户可能需要很长时间找到需要的报表数据，此时，我们可以在这个报表应用中添加异步任务减少用户等待时间，从而提高用户体验；除此之外，还可以在报表应用中添加定时任务和邮件任务，以便用户可以安排在任何他们需要的时间定时生成报表，并在Email中发送。
二、使用步骤 需要用到的依赖启动器 &lt;!-- 添加Thymeleaf模板引擎依赖启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加邮件服务的依赖启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.异步任务 无返回值异步任务调用 1．Spring Boot 项目创建引入Web依赖 2．编写异步调用方法 代码如下（示例）：
创建业务异步处理类
@Service public class MyAsyncService { @Async public void sendSMS() throws Exception { System.out.println("调用短信验证码业务方法..."); Long startTime = System.currentTimeMillis(); Thread.sleep(5000); Long endTime = System.currentTimeMillis(); System.out.println("短信业务执行完成耗时：" + (endTime - startTime)); }} 3．开启基于注解的异步任务支持 在启动类中加入核心注解@EnableAsync 4．编写控制层业务调用方法 @RestController public class MyAsyncController { @Autowired private MyAsyncService myService; @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81482bce76e20547273bed161c562ee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5690505901d2ed7b28f1968c4609668f/" rel="bookmark">
			TF卡实际容量为什么比标注容量小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 比如一个刚购买4G的TF卡用户反映，当连接电脑后，电脑显示这张卡的容量只有3.8G。此名用户对此表示迷惑不解：明明内存卡上标示了容量为4G的，为何我花钱买回来的容量中有接近200mb不翼而飞呢？这200M足以装下50首以上的歌曲，难道这是产品质量问题还是厂商故意的缺斤少两？细心的用户可以发现，不但在内存卡上会出现这样的情况，其实在U盘乃至移动硬盘上都会出现这样的情况，一个标示250G容量的硬盘往往在电脑上会显示只有233G甚至更少。其实，这并非厂商的过错，造成这样的情况是有多方面的原因，综合起来主要一下原因：
（1）计算方法的误差
存储设备制造厂商在标称存储容量时所使用的进制为1000为1K，而操作系统因为采用二进制的关系，格式化后软件占用空间时进制为1024为1K，这样就会令使用时的存储空间看起来比实际的要少。比如：
存储厂商的标准：1MB＝1，000KB
））1KB＝1，000byte；
操作系统的算法：1MB＝1，024KB））1KB＝1，024byte；
存储厂商的标准：128MB=128，000KB=128，000，000byte；
操作系统的算法：128MB=131，072KB=134，217，728byte；
关于容量问题这些都是正常的：128，000，000÷1024÷1024=122.0703（MB）
如硬件标称128MB的MP3，换算成软件的识别的容量就是
128MB×1000KB/1024KB=125MB，这样就会有3MB的计算误差。
容量越大的存储产品，算法误差也就越大。
（2）内部文件占用空间
在分区和格式化后，系统会在硬盘上占用一些空间，提供给系统文件使用，与硬盘一样，闪存盘也是采用FAT文件系统，而FAT文件系统包括MBR主引导分区、FAT文件分配表和ROOT目录区等，这些区域一般占用几百kb闪存空间，所以操作系统显示的总容量和硬盘的型号容量存在差异这是一个正常现象。
此外，由于闪存芯片本身在制造时的问题，闪存介质允许有坏块（BadBlock）的存在，这些坏块不能被使用，也不算做有效容量。
也就是说,厂家和电脑的换算方法不一样,令一个就是U盘有一定的系统空间,导致你的U盘比实际的小!
1G=1024MB而成家认为1000MB所以换算成你的1GB也就是
1000GB/1024*1000=976.5MB还有点系统文件,所以970M很正常啦!
以此类推：
2G=1.8G左右
4G=3.6G左右
8G=7.4G左右
16G=14.8G左右
这就是足量卡显示的实际容量！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fd3e71af8d24f45983ff5143cfbb6b8/" rel="bookmark">
			软件缺陷报告模板（微信缺陷报告案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是缺陷报告？ 所谓软件缺陷，就是计算机软件或程序中存在的某种破坏正常运行能力的问题、错误、或者隐藏的功能、性能缺陷
美国电气和电子工程师协会对缺陷的定义
从产品内部看，缺陷是软件产品开发或维护过程中存在的错误、毛病等各种问题
从产品外部看，缺陷是系统所需要实现的某种功能的失效或违背
只要满足下列5个规则之一则称为发生了一个软件缺陷： 软件未实现产品说明书要求的功能
软件实现了产品说明书未提到的功能
软件出现了产品说明书未指明不应该出现的错误
软件未实现产品说明书虽未明确提及但是应该实现的功能
软件难以理解、不易使用、运行缓慢、或者从测试员的角度看，最终用户会认为不好
一张图带你了解软件测试的八大要素 微信缺陷报告案例： 感谢阅读！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a8d319b040f5635a71cb819c80e232c/" rel="bookmark">
			SpringBoot configuration Annotation Processor not configured问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： SpringBoot configuration Annotation Processor not configured的意思是：
未处理SpringBoot配置注释处理器
解决： 在pom.xml文件中引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 如出现以下问题：
解决：
1.主启动类上添加@EnableConfigurationProperties
2.
3.
最后重启或点一下蓝色的提示即可
加依赖的作用：
有代码提示，很方便快捷。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ffdcfdfb4c1d3e007bd34e514ed54a/" rel="bookmark">
			js的输入和输出语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章技术分享为js的输入和输出语句
文章目录 前言一、输出二、输入 总结 前言 输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。
举例说明：如按键盘上的方向键，向上/下键可以滚动页面，按向上/下键这个动作叫作输入，页面发生了滚动了这便叫输出。
一、输出 JavaScript 可以接收用户的输入，然后再将输入的结果输出：
alert()、document.wirte()
以数字为例，向 alert() 或 document.write()输入任意数字，他都会以弹窗形式展示（输出）给用户。
二、输入 向 prompt() 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JavaScript 基础 - 输入输出&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // 1. 输入的任意数字，都会以弹窗形式展示 document.write('要输出的内容'); alert('要输出的内容'); // 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号 prompt('请输入您的姓名:'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 总结 我们知道,输入和输出语句往往是一些逻辑性的感觉,以上知识简单进行举例子说明,也是比较简单的js输入和输出语句!
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/205/">«</a>
	<span class="pagination__item pagination__item--current">206/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/207/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>