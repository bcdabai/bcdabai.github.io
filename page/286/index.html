<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c8e4e95de3083d5447ea28eeb25a5c/" rel="bookmark">
			Java二分查找法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		含义：
二分查找又称折半查找，一种效率较高的查找方法
条件：
1、必须为顺序存储结构；2、必须按关键字大小有序排列；
原理：
例：int arrays[]={2,8,10,16,64,512,1024};
1、将有序数组分为三个部分，分别为中间值前（中间值数之前的一组数据），中间值和中间值后（中间值之后的一组数据）
2、将要查找的数与中间值的数相比较，等于则退出查找，小于则在中间值前进行比较，大于在在中间值后进行比较,依次递归，直至查找到对应的值为止。
3、此处中间值为{16}，中间值前为{2,8,10}，中间值后为{64,512,1024}。
图解：
（图片来源于百度）
实例：
1、循环实现
2、递归实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a65c98ce5554da1552d63f3e941f4a/" rel="bookmark">
			解决H5页面在安卓Android系统上软键盘顶起布局问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期在做一个项目，是基于APP内置的二级H5应用，APP由RN搭建，H5应用由react搭建。
H5应用中，有一个页面，需求是页面分header body footer三个模块，header和footer需要固定宽高。由于UI给的图就是px为单位。。项目设计比较大，里面有一些其他的工程，早期第一版没有引入rem单位，后期不敢乱动，而且真的会去抠px值，虽然说不会那么精确，但是会量就是了。。。所以没办法换成rem。
header和footer是固定高度的，那么根据屏幕尺寸不同，中间的body模块就需要自适应了。
现在的问题是：如何实现一个上下固定，中间自适应的布局，而且布局不会被软键盘顶起。
我第一次的布局是这样的：
1 .header{ 2 position: absolute; 3 top: 0; 4 left: 0; 5 height: 50px; 6 } 7 .footer{ 8 position: absolute; 9 bottom: 0; 10 left: 0; 11 height: 200px; 12 } 13 .body{ 14 position: absolute; 15 top:50px; 16 } 可以实现：在iOS上正常，并无异常。这个跟安卓和iOS的系统有关。
但是，安卓上，随软键盘的弹起，布局会被撑起来。
查了一下原因是，安卓上软键盘会顶走absolute和fixe布局的元素！
解决方案1：当键盘弹起时：将被顶起的div设置为position：static。不再是position：absolute。
这样确实是可行的，就是需要判断键盘弹起的状态，这个可以通过判断视图的高度来判断，当软键盘顶起布局时，视图的高度会变小，但是因为我的页面上还有一些其他的操作影响判断，有些麻烦，本人是懒人。。。能用简洁的方法解决自己的问题就不会选择麻烦的。
解决方案2：更改布局，如下：
.header{ height: 50px; } .footer{ height: 200px; } .body{ height: calc(100% - 250px); min-height: 200px; } 因为我的body.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38a65c98ce5554da1552d63f3e941f4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4490a8a0308342a2cec5e7f2b0d5a76/" rel="bookmark">
			firefox 禁止缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发者修改css时不能更新更改的内容，这其实是浏览器中缓存的原因，这里拿firefox浏览器举例禁止浏览器缓存来解决这一问题的出现：
在地址栏中打about:config
在搜索中输入：browser.cache.disk.enable
选项解释：When a page is loaded, it can be cached so it doesn’t need to be downloaded to be redisplayed. For e-mail and news, messages and attachments are cached as well. This preference controls whether to use the hard drive for caching purposes. browser.cache.disk.capacity controls the maximum amount of disk space to use.
双击这个选项就可以更新修改的内容了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/356d6baa4ffca34d1e1825a9299b6401/" rel="bookmark">
			修改 input type=file 的样式的最简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很多人说网页中&lt;input type="file"&gt;的样式是很难修改的，事实上也是，bootstrap也没用对其有什么美化，但是那么丑，要怎么修改呢？
其实很简单！！！很多人都想复杂了。
先卖个关子，有些人是这么做的，另外写一个按钮的样式，然后将自己写的按钮和这个默认的样式的定位改为重合，并将默认的按钮设置opacity:0，即设置透明度为完全透明，这样就可以在表面上是点击自己定义的样式，而实际上是点击input这个按钮。这正是这篇博客所说：https://blog.csdn.net/dear_mr/article/details/56040549
可是让这两个东西完全重合，不是很麻烦的一件事情么，这个想法可以去回答知乎的：有哪些看似精妙实际很蠢的设计 从上面的方法中得到了如下思路，下面进入最简单的方法： 1、重写一个新的样式 2、将默认样式设置display:none;，即设为不可见 3、在js里调用：当点击新样式的时候，调用这个input的点击事件
这就完啦！！！何必还要多此一举将两个东西设为完全重合呢，写新样式就完全可以放飞自我啦
下面附上简单的代码吧，我的js用了jquery框架
html
&lt;div class="head-img"&gt; &lt;img src="./imgs/王小波.jpg" id="my-img"&gt; &lt;input type="file" id="img-upload"/&gt; &lt;/div&gt; css
.head-img{ text-align: center; } #img-upload{ display: none; } js/jquery
$(document).ready(function(){ $('#my-img').click(function(){ $('#img-upload').click(); }); }); 效果如下图，点击王小波的皂片就可以弹出文件选择框啦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e5a926dec88601422911d94f99b75b/" rel="bookmark">
			C&#43;&#43;类型转换 LPWSTR转char*
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /****************************************************************************************** Function: ConvertLPWSTRToLPSTR Description: LPWSTR转char* Input: lpwszStrIn:待转化的LPWSTR类型 Return: 转化后的char*类型 *******************************************************************************************/ char* ConvertLPWSTRToLPSTR(LPWSTR lpwszStrIn) { LPSTR pszOut = NULL; try { if (lpwszStrIn != NULL) { int nInputStrLen = wcslen(lpwszStrIn); // Double NULL Termination int nOutputStrLen = WideCharToMultiByte(CP_ACP, 0, lpwszStrIn, nInputStrLen, NULL, 0, 0, 0) + 2; pszOut = new char[nOutputStrLen]; if (pszOut) { memset(pszOut, 0x00, nOutputStrLen); WideCharToMultiByte(CP_ACP, 0, lpwszStrIn, nInputStrLen, pszOut, nOutputStrLen, 0, 0); } } } catch (std::exception e) { } return pszOut; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da5ac866be1dd5bf8bc7745a412babe/" rel="bookmark">
			ubuntu 进程管理工具 supervisorctl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; Supervisor是基于 Python 的进程管理工具，可以帮助我们更简单的启动、重启和停止服务器上的后台进程，是 Linux 服务器管理的效率工具。
什么情况下我们需要进程管理呢？就是执行一些需要以守护进程方式启动的程序，比如一个后台任务、一组 Web 服务的进程（说是一组，是因为经常用 Nginx 来做负载均衡），这些很可能是一些网站、REST API 的服务、消息推送的后台服务、日志数据的处理分析服务等等。
安装 博主用的是ubuntu系统，网上好多Supervisor安装方法，但还是感觉最好用的还是apt-get
apt-get install supervisor supervisor安装完成后会生成三个执行程序：supervisortd、supervisorctl、echo_supervisord_conf，分别是supervisor的守护进程服务（用于接收进程管理命令）、客户端（用于和守护进程通信，发送管理进程的指令）、生成初始配置文件程序。
配置 supervisortd默认配置位置为
/etc/supervisor/supervisord.conf
可以通过运行echo_supervisord_conf程序生成supervisor的初始化配置文件，自带的配置文件内容不全，建议重新初始化，如下所示：
echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf 参数说明 supervisor的配置参数较多，下面介绍一下常用的参数配置，详细的配置及说明，请参考官方文档
注:“；”开头表示注释
[unix_http_server] file=/tmp/supervisor.sock ;UNIX socket 文件，supervisorctl 会使用 ;chmod=0700 ;socket文件的mode，默认是0700 ;chown=nobody:nogroup ;socket文件的owner，格式：uid:gid ;[inet_http_server] ;HTTP服务器，提供web管理界面 ;port=127.0.0.1:9001 ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性 ;username=user ;登录管理后台的用户名 ;password=123 ;登录管理后台的密码 [supervisord] logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.log logfile_maxbytes=50MB ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小 logfile_backups=10 ;日志文件保留备份数量默认10，设为0表示不备份 loglevel=info ;日志级别，默认info，其它: debug,warn,trace pidfile=/tmp/supervisord.pid ;pid 文件 nodaemon=false ;是否在前台启动，默认是false，即以 daemon 的方式启动 minfds=1024 ;可以打开的文件描述符的最小值，默认 1024 minprocs=200 ;可以打开的进程数的最小值，默认 200 [supervisorctl] serverurl=unix:///tmp/supervisor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2da5ac866be1dd5bf8bc7745a412babe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f5639dcab23d527e74c3afe15eeadd/" rel="bookmark">
			解决“VMware Station无法检测此光盘映像中的操作系统。您需要指定要安装的操作系统。”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ISO文件是我从官网下载的，资源本身肯定是没有问题的。
我的解决办法是，选择稍后安装操作系统。在自定义硬件里，选择使用ISO映像文件。
然后配置好后打开虚拟机即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8369ef826f224d09de987c538689d169/" rel="bookmark">
			Android设置drawableleft图片大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 xml没有属性设置从代码里可以 Drawable drawable=getResources().getDrawable(R.drawable.ic_phone); drawable.setBounds(0,0,30,35);//第一0是距左边距离，第二0是距上边距离，30、35分别是长宽 tv_phone.setCompoundDrawables(drawable,null,null,null);//只放左边 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2f76497ee3403819807d24063d8875a/" rel="bookmark">
			nginx配置前后端分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		server { listen 80; server_name admin.simikongjian.xin; root /home/wwwroot/admin.simikongjian.xin; index index.htm index.html index.php ; location /server { index index.html; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://admin.shopservice.cn/; } location /apim { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://wiki.shopservice.cn:8001/; } location ~.*\.(gif|jpg|jpeg|png|bmp|swf|mp4)$ { proxy_pass http://admin.shopservice.cn; } location / { try_files $uri $uri/ @router; index index.html; } location @router { rewrite ^.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2f76497ee3403819807d24063d8875a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66702cb40b932edd2b2809890a497714/" rel="bookmark">
			汇编语言程序设计之二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从键盘输入一系列字符（以回车结束）,按数字，大小写字母分类计数，并在屏幕上打印出来。 DATA SEGMENT INFOR1 DB 0AH,0DH,"Please Press Any Key to input a letter:$" INFOR2 DB 0AH,0DH,"Lowercase Letter : $" INFOR3 DB 0AH,0DH,"Uppercase Letter : $" INFOR4 DB 0AH,0DH,"Digit : $" INFOR5 DB 0AH,0DH,"Other Letter : $" DATA ENDS CODE SEGMENT ASSUME CS:CODE,DS:DATA START: PRINT MACRO STR,RHS ; MACRO 为宏 LEA DX,RHS MOV AH,09H INT 21H MOV DL,STR ADD DL,30H MOV AH,02H INT 21H ENDM MOV AX,DATA MOV DS,AX MOV DX,OFFSET INFOR1 MOV AH,09H INT 21H MOV BX,0 MOV CX,0 XUNHUAN: MOV AH ,01H INT 21H ;AL CMP AL,0DH ; \n JZ DISPLAY CMP AL,'0' JB OTHER CMP AL,'9' JBE DIGIT CMP AL,'A' JB OTHER CMP AL,'Z' JBE UPPER CMP AL,'a' JB OTHER CMP AL,'z' JBE LOWER JMP XUNHUAN LOWER: INC BL JMP XUNHUAN ; UPPER: INC BH JMP XUNHUAN DIGIT: INC CL JMP XUNHUAN OTHER: INC CH JMP XUNHUAN DISPLAY: PRINT BL,INFOR2 PRINT BH,INFOR3 PRINT CL,INFOR4 PRINT CH,INFOR5 MOV AH,4CH INT 21H CODE ENDS END START 小结： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66702cb40b932edd2b2809890a497714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/988930d8b3d2274dae9df578914b3fc2/" rel="bookmark">
			关于RESTful API的一些思考与疑问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在研究API规范的最佳实践。发现关于RESTful API规范的信息甚是模糊，没有一个明确的权威的说法，至少国内搜到的信息是这样的。比如下面的三篇文章，其中的内容差异很大，甚至相反（比如PUT和POST的用法），有此可见整个RESTful API规范实现的乱象。
RESTful API 规范 v1.0
Restful API 的设计规范
REST API URI的七大设计原则
其实RESTful API并没有一个权威的标准（至少笔者没有查到），REST只是一个抽象概念，RESTful API相当于其具体应用实现，既然没有绝对的标准，那么今天就来讨论一下吧。
1、是否启用PUT、DELETE？修改和创建，哪个用PUT哪个用POST？ 参考：POST增、GET查、DELETE删、PUT改
eg：GET /companies、GET /companies/3、POST /companies/3、DELETE /companies/3、PUT /companies/3
讨论：HTTP 1.1 这个版本是当前版本，包含GET(0.9) HEAD(1.0) POST(1.0) OPTIONS PUT DELETE TRACE CONNECT这8个方法，兼容性是毫无问题的。但是POST和PUT的区别是什么？
2、是否可以有动词？名词单数还是复数？ 参考：不应该有动词（用POST、GET、DELETE、PUT区分），全是名词复数。
eg：/companies/3/employees/45
讨论：这样看起来的确优雅，但是下面的场景如何处理呢。
详情页与编辑页（浏览器地址）如何设计？例：员工列表-&gt;员工详情 / 员工编辑详情页就是子层级的列表页时如何设计？例：公司列表-&gt;公司详情（就是部门列表）-&gt;部门详情（就是员工列表）-&gt;员工详情tabs怎么办？用query？ 3、单词连接用"-"横线、"_"下划线，还是驼峰？ 参考：用横线"-"，防止整个地址有超链接下划线时"_"看不出，RFC 3986将URI定义为区分大小写，但scheme 和 host components除外。
eg：/salary-records/3/paybill-details/34
讨论：python的变量推荐用"_"，这种习惯会被带到这里；另外，返回的数据里的key是否应该采用驼峰？eslint的报错很烦的。
4、结尾应不应该包含斜杠“/”？ 参考：不加
讨论：在地址栏与API中，以"/"为结尾有何区别？
5、地址栏的URL与API的get请求如何区分？ 参考：用域名区分
eg：https://www.example.com/companies/3 、 https://apis.example.com/companies/3
讨论：会不会混淆或有其他副作用？另外还有2当中讨论的第一个场景。
6、是否与http统一状态码？ 参考：返回状态码推荐标准HTTP状态码
有很多服务器将返回状态码一直设为200，然后在返回body里面自定义一些状态码来表示服务器返回结果的状态码。由于rest api是直接使用的HTTP协议，所以它的状态码也要尽量使用HTTP协议的状态码。
eg：200 OK 服务器返回用户请求的数据，该操作是幂等的
201 CREATED 新建或者修改数据成功
204 NOT CONTENT 删除数据成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/988930d8b3d2274dae9df578914b3fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d534cce4655ae020c8f424dba3b0ad2/" rel="bookmark">
			类和类之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类和类之间的6种关系
一、UML
a) Unified Modeling Language (UML)又称统一建模语言或标准建模语言
b) 它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持
c) 它不仅统一了Booch、Rumbaugh和Jacobson的表示方法，而且对其作了进一步的发展，并最终统一为大众所接受的标准建模语言
d) UML定义了10种模型图,对应软件设计开发的不同阶段
i. 用例图
ii. 静态图：类图，包图，对象图。
iii. 行为图：状态图和活动图
iv. 交互图：顺序图和协作图
v. 实现图：组件图、部署图
二、常用的UML软件
a) 商业软件，功能强大
a) Rational Rose：UML建模为主，辅以数据库建模
b) PowerDesigner：数据库建模工具、辅以UML建模
c) MicroSoft Office visio：专业制图软件，地铁、装修、建筑都可以，也支持数据库和UML建模
b) 开源软件、功能不弱
a) starUML
b) umlet
c) eclipse（需要添加插件）
三、类和类（接口）之间的关系
1. 继承关系（泛化关系 Generalization）
a) 语义：
i. 类和子类的关系，接口和子接口的关系；
ii. 一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能
b) 语法：extends
c) 符号：
i. 一条带空心三角箭头的实线，从子类指向父类，或者子接口指向父接口。
ii. 2. 实现关系(Realization)
a) 语义：
i. 类和接口之间的关系；
ii. 一个类可以实现多个接口，实现所有接口的功能；体现了规范和实现分离的原则
b) 语法： implements
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d534cce4655ae020c8f424dba3b0ad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e44a5e107db3e435e5f1cf8795ab85d8/" rel="bookmark">
			HashMap底层实现原理及面试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		①HashMap的工作原理 HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。
当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。
因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。
②HashMap和Hashtable的区别 HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。
HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。HashMap不能保证随着时间的推移Map中的元素次序是不变的。 要注意的一些重要术语： 1) sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。
2) Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。
3) 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。
我们能否让HashMap同步？ HashMap可以通过下面的语句进行同步：
Map m = Collections.synchronizeMap(hashMap);
结论 Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。
ashMap和HashSet的区别是Java面试中最常被问到的问题。如果没有涉及到Collection框架以及多线程的面试，可以说是不完整。而Collection框架的问题不涉及到HashSet和HashMap，也可以说是不完整。HashMap和HashSet都是collection框架的一部分，它们让我们能够使用对象的集合。collection框架有自己的接口和实现，主要分为Set接口，List接口和Queue接口。它们有各自的特点，Set的集合里不允许对象有重复的值，List允许有重复，它对集合中的对象进行索引，Queue的工作原理是FCFS算法(First Come, First Serve)。
首先让我们来看看什么是HashMap和HashSet，然后再来比较它们之间的分别。
③HashMap和HashSet的区别 HashMap和HashSet的区别是Java面试中最常被问到的问题。如果没有涉及到Collection框架以及多线程的面试，可以说是不完整。而Collection框架的问题不涉及到HashSet和HashMap，也可以说是不完整。HashMap和HashSet都是collection框架的一部分，它们让我们能够使用对象的集合。collection框架有自己的接口和实现，主要分为Set接口，List接口和Queue接口。它们有各自的特点，Set的集合里不允许对象有重复的值，List允许有重复，它对集合中的对象进行索引，Queue的工作原理是FCFS算法(First Come, First Serve)。
首先让我们来看看什么是HashMap和HashSet，然后再来比较它们之间的分别。
什么是HashSet HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。
public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。
什么是HashMap HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。
public Object put(Object Key,Object value)方法用来将元素添加到map中。
HashSet和HashMap的区别 *HashMap**HashSet*HashMap实现了Map接口HashSet实现了Set接口HashMap储存键值对HashSet仅仅存储对象使用put()方法将元素放入map中使用add()方法将元素放入set中HashMap中使用键对象来计算hashcode值HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回falseHashMap比较快，因为是使用唯一的键来获取对象HashSet较HashMap来说比较慢 ④面试题 HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！
“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”
几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：
“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”
你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。”
但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：
“当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：
“如果两个键的hashcode相同，你如何获取值对象？” 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e44a5e107db3e435e5f1cf8795ab85d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2abd06ebca4bac3be874d6e65eca3fc0/" rel="bookmark">
			linux初学者的学习路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个linux小白，在详细的学习linux之前总是喜欢为自己规划一些路线，寻找各位大神前辈留下的一些经典书籍，以下就是我收集的一些东西，希望可以尽全力帮到大家：
一 必须知道的五大网站
1 想必大家想学习linux都听过鸟哥的大名，《鸟哥私房菜》也是对于刚入门的学习者必不可少的学习网站 下面是《鸟哥私房菜》的繁体版网址： 鸟哥私房菜繁体版 鸟哥私房菜简体版 也可以下载鸟哥私房菜的pdf:
2 Linux中国 这是一个关于Linux的资讯网站，网站提供了各种关于Linux的资讯你都可以在这里找到，是Linux学习者非常不错的一个资讯阅读平台，也是强行安 利！！
3 实验楼 这是一个IT学习网站，但是，但是，对于Linux学习者来说绝对是福利网站，因为网站配有Linux在线开发环境，你可以随便折腾，不用搭建本地开发环境，而且也有很多非常不错的Linux课程，强行安 利！！
4 Linux下载站 可以在这个网站下载到各种Linux各种发行版，以及相关的软件、游戏……，虽说可以去官网下载，但是作为初学者来说这样一个集中式下载的网站也是非常方便滴~
5 Linux公社 这也是一个Linux资讯网站，里面同样可以找到很多关于Linux的相关文章，可以看看~
二、Linux命令行汇总
【Linux】linux常用基本命令 （Linux基本命令大全、此部分是学习的第一块也是最重要的一块，勤于练习，忘记图形界面，不要想图形界面能不能提供你问题的答案， 而是满世界的去找，去问，如何用命令行解决你的问题。 ）
All commands sorted by votes | commandlinefu.com （国外某个分享Linux命令的地方，一些比较有用命令上面都有，有兴趣的朋友可以整理一下上面的命令）
对 Linux 新手非常有用的 20 个命令 （如果你想偷懒，或许初期学习时间有限，你可以先掌握这几个命令，掌握这几个命令至少可以满足你得一些基本需求了）
二、一些视频教程现在已下架
《Linux从入门到精通》教学视频课程（共24课时）_在线培训教程_51CTO学院 （适合：Linux初学者、Linux爱好者、系统管理员。视频内容包括Linux概述、 Linux安装、Linux编程工具、Shell编程、服务器基础知识、Apache服务器、vsftpd服务器、Samba服务器、NFS服务器、任务 计划、防火墙和网络安全、病毒和木马防范等） Linux达人养成计划 I Linux 达人养成计划 II
通过学习以上两节课程，您将有如下收获： 1、全面了解Linux的前世今生 2、能够独立安装Linux操作系统 3、从对Linux常用命令的一无所知，到运用自如 4、与shell编程基础亲密接触
Linux软件安装管理 （软件安装对于操作系统来说是常用的操作，那如何在Linux中使用命令进行软件安装呢？本课程就带你来了解Linux中的软件如何进行安装、卸载、升级等管理。课程内容包括rpm命令管理、yum在线管理、源码包管理和脚本安装包。）
Linux网络管理 （ Linux装好以后是不能和网络中的其他机器进行通信的，本课程会为你解决Linux网络配置的问题。首先会介绍网络基础知识，然后进行IP地址的配置，并总结了在配置网络环境中经常遇到的问题，最后介绍了几种常用远程登录工具的使用，如XShell和SecureCRT。 ）
Linux C语言编程基本原理与实践（ 介绍C语言基本工作原理以及适用与C的实际开发方式，并指导童鞋们能在Linux环境下编写并运行符合实际商业开发环境下的C语言程序。 ）
三、一些免费书籍
10本Linux免费电子书 （整理了一些Linux电子书（多数都有可下载的PDF格式），可用作为参考书，或学习材料。主题覆盖比较广，从Java高级编程、GNU、Emacs、设备驱动到内核等。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2abd06ebca4bac3be874d6e65eca3fc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b5e194ae838a3b09f0f375de113df6c/" rel="bookmark">
			Boost Graph Library 快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Boost Graph Library 快速入门 图领域的数据结构和算法在某些方面比容器更为复杂，图算法在图中移动有着众多的路线，而STL使用的抽象迭代器接口不能有效的支持这些。作为替换，我们为图提供了一个的抽象的结构，其与容器迭代器的目的类似（尽管迭代器扮演着更大的角色）。图1 描述了STL 和BGL 之间的对比。
图1: The analogy between the STL and the BGL.
图由一系列顶点vertices，以及连接顶点的边edges组成. 如图2描述了一个拥有5个顶点和11条边的有向图directed graph. 离开一个顶的边称为该点的out-edges。边 {(0,1),(0,2),(0,3),(0,4)} 都是节点0的out-edges ,进入一个顶点的边称为该点的in-edges , 边{(0,4),(2,4),(3,4)} 是节点0的in-edges 图2 一个有向图例子
在后面的章节中，我们使用BGL构造上图并展示各种操作。全部的代码可以在examples/quick_tour.cpp 中找到，下面每个章节都是这个例子文件的一个片断。
构造一个图 在这个例子中，我们将使用BGL邻接表adjacency_list 类来示范BGL接口中的主要概念。adjacency_list类提供了典型邻接表数据结构的一个泛型版本。 adjacency_list 是一个拥有6个模板参数的模板类。但我们只使用了前3个参数，剩余的3个使用默认参数。头两个模板参数(vecS, vecS)分别用来描述离开顶点的out-edges边和图中顶点的集合所使用的数据结构(阅读 Choosing the Edgelist and VertexList 章节可以获得更多关于平衡不同数据结构的信息)。 第三个参数, 使用bidirectionalS表示选择一个可访问出、入边的有向图，其中directedS 为选择一个仅提供出边的有向图；undirectedS 表示选择一个无向图。
一旦我们选定了图的类型，我们可以创建一个图2所示的图。声明一个图对象，使用 MutableGraph 接口中的add_edge() 函数来填充边，在这个例子中我们简单的使用 pairs 数组edge_array来建立边在这个例子中我们简单的使用 pairs 数组edge_array来建立边。
#include &lt;iostream&gt; // for std::cout #include &lt;utility&gt; // for std::pair #include &lt;algorithm&gt; // for std::for_each #include &lt;boost/graph/graph_traits.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b5e194ae838a3b09f0f375de113df6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c939f79f3c58106fdf16917a1e716f9/" rel="bookmark">
			程序员们，只需三步，教你搭建一个区块链程序 | 经典好文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区块链，大家或许都不陌生，或多或少都对它有一些了解。不过，这些了解可能都是支离破碎的。当问及其中一些概念是如何实现的，你可能就「蒙圈」了。那想了解其中的实现细节怎么办呢？
这篇文章可以手把手的教你搭建一个区块链程序，让你从技术层面，详细了解区块链的实现细节。我相信你把这篇文章的代码跑一遍，你会有一种「哦！原来是这么实现的」想法。下面，我们就来试试吧。
作者 | Daniel van Flymen
译者 | Aholiab、科科
你会点开这篇文章，说明你跟我一样，眼看加密货币价格的暴涨，很想弄清楚区块链到底是什么？背后有哪些技术。
不过，要完全理解区块链不是件容易的事，起码对我而言。为了搞懂区块链，我看过大量的视频、研究过各种教程和为数不多的几个案例，整个过程虐心之极。
所以，我决定在实践中学习。在实践中学习的一大好处是它能逼着你去理解区块链最底层的原理，并且容易让人坚持下去。如果你也想试试这个方法的话，建议你好好读完这篇文章，跟着步骤一步步地去操作。这样，你不仅可以亲自开发出一个功能完备的区块链，同时也搞清楚了区块链的机制到底是什么？
准备工作
在开始之前，我们需要做些准备工作，搞清楚一些问题。
什么是区块链？区块链是由不可变的、有顺序记录的区块组成。他们可以包含交易数据、文件数据或者其他你想要记录的数据。不过最重要的是这些区块通过哈希表链接在一起。
什么是散列？散列函数是一个输入值函数，从该输入创建一个确定输入值的输出值。更多解释可以点击下边这个链接：
﻿https://learncryptography.com/hash-functions/what-are-hash-functions
这篇文章适合谁，首先Python程序员，你只要能轻松地读写一些基本的Python代码就可以了；第二是HTTP程序员，因为我们接下来讲到的区块链，是构建在HTTP上面的，这需要你起码要了解HTTP请求的工作原理。
我需要做什么？首先要确保安装了Python 3.6以上的环境和Flask，此外还需要安装一个碉堡的Requests库。版本信息如下：
pip install Flask==0.12.2 requests==2.18.4 哦对了，你还需要一个HTTP客户端，比如 Postman 或者 cURL
在哪里下载完整代码，请猛戳：
https://github.com/dvf/blockchain。
下面跟着我一步一步来操作吧。
第一步：创建区块链
打开你常用的编辑器，我个人比较喜欢PyCharm。创建一个新的文件，命名为 blockchain.py。整个项目，我们都只会用到这一个文件。有不清楚的地方，可以参考源代码。
表示一个区块链
我们将创建一个 Blockchain 类，它的构造函数里创建了一个初始为空的列表（用于存储我们的区块链），和一个存储交易的列表。下边是这个类的代码：
class Blockchain(object):
def __init__(self):
self.chain = []
self.current_transactions = []
def new_block(self):
# Creates a new Block and adds it to the chain
pass
def new_transaction(self):
# Adds a new transaction to the list of transactions
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c939f79f3c58106fdf16917a1e716f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dcba4a21e6a864b5e9f086e705c2939/" rel="bookmark">
			idea jfinal tomcat 之打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于windows和linux的mysql数据库有所差别，一个区分大小写，一个不区分大小写，我在windows写完项目之后 要部署到linux上，然后需要把所有的数据库表名统一大小写，在 .java 文件中修改保存之后，直接打包，发现部署上取得war里面的大小写竟然没有变化（tomcat报错提示），然后突然想到应该是自己没有编译运行，就去查看了一下 .class 文件已看还真是 里面的大小写没有变化。 也是编译运行了之后重新打包，发布就正常了。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4d0b79869e07f7341b0b829980bebb/" rel="bookmark">
			Java Web项目登录报Session Error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在web.xml文件添加下面红色代码即可，注意：添加代码后，格式化一下代码。
&lt;servlet&gt;
&lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt; &lt;servlet-class&gt;org.directwebremoting.servlet.DwrServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;activeReverseAjaxEnabled&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;initApplicationScopeCreatorsAtStartup&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;maxWaitAfterWrite&lt;/param-name&gt; &lt;param-value&gt;500&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt;
&lt;param-name&gt;crossDomainSessionSecurity&lt;/param-name&gt;
&lt;param-value&gt;false&lt;/param-value&gt;
&lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f819635aeb02fcf07782ae57f27ae45/" rel="bookmark">
			深入理解ICMP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ICMP概述：ICMP使用IP数据报传送。允许主机或路由器报告差错情况和提供有关异常的报告。使IP数据报转发更有效，提高交付成功的机会。 不产生ICMP差错报文的情况： 1）ICMP差错报文（但是，ICMP查询报文可能会产生） 2）目的地址是广播地址或多播地址的IP数据报。 3）作为链路层广播的数据报。 4）不是IP分片的第一片。 5）源地址不是单个主机的数据报。 目的是为了不产生广播风暴。 ICMP的规则：ICMP差错报文必须包括生成该差错报文的数据报IP首部，还必须至少包括跟在IP首部后面的前8个字节（TCP/UDP首部等）。
ICMP报文的分类 一、ICMP差错报告报文 1、终点不可达 Destination Unreachable Message 代码Code：
0 = net unreachable网络不可达; 1 = host unreachable主机不可达; 2 = protocol unreachable协议不可达; 3 = port unreachable端口不可达; 4 = fragmentation needed and DF set需要分片但设置了不可分片比特; 5 = source route failed源站选路失败. 123456789101112 产生的原因：UDP的规则之一是，如果收到一份UDP数据报而目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。
2、 源点抑制Source Quench Message 产生的原因：当一个系统（路由器或主机）接收数据报的速度比其处理速度快时，即路由器或者主机因拥塞丢弃数据报，可能产生这个差错，以减慢发送速度。
3、 时间超过Time Exceeded Message Code :
0 = time to live exceeded in transit传输期间生存时间为0; 1 = fragment reassembly time exceeded在数据报重装期间生存时间为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f819635aeb02fcf07782ae57f27ae45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e0509446fe5521ad0bfb8a80f1f621/" rel="bookmark">
			强迫症适用的python中文对齐问题.format细节修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原代码
print('{:^9}\t'.format(ii),end = '') # 采用居中对齐 左图 print('{:&lt;9}\t'.format(ii),end = '') # 采用左对齐 右图 运行结果
一点都不齐 =，=
原因
因为我们的输出结果中有中文，当我们输出的中文宽度不够约定的宽度时，系统会自动进行填充。
而问题恰恰出现在填充这里：系统填充的是英文字符，而我们输出占用的是中文字符的宽度。单位不一致，自然会显得很别扭。
解决方案
替换填充字符 ---》祭出神器 chr(12288) 中文空格
代码
print('{0:{1}^9}\t'.format(ii,chr(12288)),end = '') # 居中对齐 print('{0:{1}&lt;9}\t'.format(ii,chr(12288)),end = '') # 左对齐 用chr(12288)去填充，即这里的{1} .format 方法补充
修改后
至此，解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b963d8fd4a6e4924ce80a749f392824/" rel="bookmark">
			Java并发编程之ConcurrentLinkedQueue详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现，下面我们一起来研究下Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的。
ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改。
ConcurrentLinkedQueue的类图如下：
ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。
ConcurrentLinkedQueue源码详解 我们前面介绍了，ConcurrentLinkedQueue的节点都是Node类型的：
private static class Node&lt;E&gt; { volatile E item; volatile Node&lt;E&gt; next; Node(E item) { UNSAFE.putObject(this, itemOffset, item); } boolean casItem(E cmp, E val) { return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); } void lazySetNext(Node&lt;E&gt; val) { UNSAFE.putOrderedObject(this, nextOffset, val); } boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) { return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); } private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static { try { UNSAFE = sun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b963d8fd4a6e4924ce80a749f392824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e72bace52f4bca4f25e9b07669e3df2d/" rel="bookmark">
			ArcMap 字段计算器（Field Calculator）的使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.某一个字段写入 固定字符串 ----选择python，字符串 gxsj="2018-06-25" 点击确定。 2.根据ID字段填写URL字段
----新建url字段，类型为文本类型，简单模式下选择Python脚本 ----输入表达式："assets/imgs/M2U004"+str(int( !ID! %26+30))+".jpg" ----其中%为取余；int为取整；str为数值转字符。 3.高级模式
4.注意python语法之缩进问题，字段类型要与返回结果类型一致。
5.实现ID字段自增：注意缩进语法
----Python #程序语言 ----Code Block: #下面这部分是具体实现，注意在放字段计算器时只需要下面这部分 rec=0 def autoIncrement(): #定义方法名 global rec pStart = 1 #初始值, 可以调整 pInterval = 1 #自增间隔, 可以调整 if (rec == 0): rec = pStart else: rec = rec + pInterval return rec ---表达式 autoIncrement() #表达式方法 6.计算数值型字段的累加值
-----Python -----Code Block: #下面这部分是具体实现，注意在放字段计算器时只需要下面这部分 total = 0 def accumulate(increment): global total if total: total += increment else: total = increment return total ----表达式 accumulate(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e72bace52f4bca4f25e9b07669e3df2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a36dd383df478924288f0da3daf1dc/" rel="bookmark">
			基于深度学习的Image Inpainting (图像修复)论文推荐(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统的图形学和视觉的研究方法，主要还是基于数学和物理的方法。然而随着近几年深度学习在视觉领域取得的卓越的效果，视觉领域研究的前沿已经基本被深度学习占领。在这样的形势之下，越来越多的图形学研究者也开始将目光投向深度学习。在图形学和视觉交叉的领域，一系列问题的研究正在围绕深度学习火热展开，特别是在图像编辑(image editing)和图像生成(image generation)方面，已经初见成效。今天我们讨论的问题，图像补全(image inpainting)，正是介于图像编辑和图像生成之间的一个问题。
图像补全最初是一个传统图形学的问题。问题本身很直观：在一幅图像上挖一个洞，如何利用其它的信息将这个洞补全，并且让人眼无法辨别出补全的部分。这个问题对我们人类似乎很容易，比如下面这个洞，大家很容易脑补出洞里应该有窗户和门，背景是墙，如果还有一些绘画天赋的话，大概就能想象着把它补出来。但是这个任务对于计算机却显得格外困难，首先这个问题没有唯一确定的解，其次如何利用其它的信息？如何判断补全结果是否足够真实？
以深度学习为代表的机器学习，正在逐渐席卷整个图形学研究领域。研究者们逐渐发现，当传统的基于物理的模型发展遇到瓶颈的时候，机器学习的方法也许能够帮助我们解释这些复杂的数理模型。毕竟只有理解了图像的深层结构，才能更好地指导图像的生成和处理。
文章推荐
1. CVPR 2016的Context-Encoders（CNN+GAN， 鼻祖级的 NN修复方法） 链接： Feature Learning by Inpainting; Github代码:
pathak22/context-encoder​github.com
2. CVPR 2017的High Resolution Inpainting(Context-Encoders+CNNMRF) 链接： High-Resolution Image Inpainting using Multi-Scale Neural Patch Synthesis; Github代码:
leehomyc/Faster-High-Res-Neural-Inpainting​github.com
3. ICCV 2017的on demanding learning(感觉也是Context-Encoders的衍生版...) 链接：
On-Demand Learning for Deep Image Restoration， Github代码:
rhgao/on-demand-learning​github.com
4. SIGGRAPH 2017 (ACM ToG)的Globally and Locally Consistent Image Completion (CE中加入Global+Local两个判别器的改进)， Github代码:
1)https://github.com/satoshiiizuka/siggraph2017_inpainting​github.com
2)https://github.com/shinseung428/GlobalLocalImageCompletion_TF
其中第二个实现稍微不同于原论文。但是展示效果非常棒。
5. ICLR 2018的New AI Imaging Technique Reconstructs Photos with Realistic Results Image Inpainting for Irregular Holes UsingPartial Convolutions 号称秒杀PS的AI图像修复神器，来自于Nvidia 研究团队。引入了局部卷积，能够修复任意非中心、不规则区域），代码还没有放出来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3a36dd383df478924288f0da3daf1dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a26d8790b4db1fc870f0c5d32c047c84/" rel="bookmark">
			g&#43;&#43; 编译指令备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		g++编译指令备忘 -fpic:表明使用地址无关代码.适用于共享库(shared library).
-fPIC:表明使用地址无关代码,适用于动态连接(dynamic linking)。PIC：Position Independent Code. -shared:表明产生共享库,Linux下编译共享库时，必须加上-fPIC参数(常用-shared -fPIC)
-I:指定额外编译时头文件目录（-I../include 或者 -I ../include）
-L:指定额外编译时链接库目录（-L../lib 或者 -L ../lib），与运行时库目录不同
-g:指示编译器，在编译的时候，产生调试信息
-w:关闭所有警告，不建议使用
-s:Remove all symbol table and relocation information from the executable.
-o:指定目标名称,缺省的时候,gcc/g++ 编译出来的文件是a.out
-O[0~3]:编译器优化选项，1为默认值，0没有优化，3优化最大,优化越强编译时间越长，运行时可能更快
-Wall:一般使用该选项，允许发出GCC能够提供的所有有用的警告。也可以用-W{warning}来标记指定的警告
-Wl,-Bstatic：表明后续所有库为静态库(动态库静态库混编结合-Wl,-Bdynamic使用)
-Wl,-Bdynamic: 表明后续所有库为动态库
-Wl,--as-needed:去除没有使用的动态库
-Wl,--no-as-needed:不去除没有使用的动态库
-Wl,--rpath:指定运行时额外库目录（-Wl,--rpath=../lib）
或者终端下export临时指定库目录
或者在/etc/ld.so.conf中添加库目录路径，然后sudo ldconfig使修改可用
-Wl,--no-copy-dt-needed-entries : binutils2.22开始，其中的ld开始把--no-copy-dt-needed-entries默认打开，这样一来，ld不会再自动递归地解析链接的lib，而需要由用户来一一指定。
因为链接库顺序错误示例：
/usr/bin/ld: /tmp/ccbb2XTW.o: undefined reference to symbol 'AdjustLogLevel'
../lib/liblogsystem.so: error adding symbols: DSO missing from command line
-Wl,--copy-dt-needed-entries: 与--no-copy-dt-needed-entries相反，递归的链接库，不需要关心链接库的顺序。
参考：
Linux共享对象之编译参数fPIC
gcc/g++ 静态动态库 混链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a26d8790b4db1fc870f0c5d32c047c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f20ebefd6e0c40af3d4081818227dfe/" rel="bookmark">
			ThymeLeaf简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是IT修真院,一枚正直纯洁善良的如刚入门的Java程序员，今天跟大家分享一下修真院官网JAVA任务十，深度思考中的知识点————
1.知识背景
Thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP，Velocity，FreeMaker等， 它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。与其它模板引擎相比， Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用。
thymeLea支持Spring Expression Language语言作为方言，也就是SpEL，在学习JSP时我们对EL表达式都有一定的认识了，SpEL是可以用于Spring中的一种EL表达式。
简而言之，与我们使用过的JSP不同，thymeLeaf是使用html的标签来完成逻辑和数据的传入进行渲染， 而且不用像jsp一样作为一个servlet被编译再生成。即便单独的thymeleaf html文件依旧可以正确打开并有少量（相对）有价值的信息，并且是可以被浏览器直接打开的。
可以说用thymeLeaf完全替代jsp是可行的。何况他的功能更强大。
2.知识剖析
Thymeleaf 是一种模板语言。那模板语言或模板引擎是什么？常见的模板语言都包含以下几个概念：数据（Data）、模板（Template）、模板引擎（Template Engine）和结果文档（Result Documents）。
数据 数据是信息的表现形式和载体，可以是符号、文字、数字、语音、图像、视频等。数据和信息是不可分离的，数据是信息的表达，信息是数据的内涵。数据本身没有意义，数据只有对实体行为产生影响时才成为信息。模板 模板，是一个蓝图，即一个与类型无关的类。编译器在使用模板时，会根据模板实参对模板进行实例化，得到一个与类型相关的类。
模板引擎 模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。
结果文档 一种特定格式的文档，比如用于网站的模板引擎就会生成一个标准的HTML文档。 模板语言用途广泛，常见的用途如下： - 页面渲染 - 文档生成 - 代码生成 - 所有 “数据+模板=文本” 的应用场景
3. 常见问题
ThymeLeaf与jsp的区别？
ThymeLeaf如何替换模板和数据？
如何使用ThymeLeaf？
ThymeLeaf可以怎么学习？
4. 解决方案
ThymeLeaf与jsp的区别
Thymeleaf是以HTML文件为基础，添加标签完成“数据+模板=文本”的过程，而jsp虽然看起来像XML或者HTML，但其实都不是。
加之其使用了大量java源码（scriptlet）jsp标签库（jstl）使得文件可读性不高，也摧毁了我们想维持一个格式良好的文档的可能性。
JSP缺乏良好格式的一个副作用就是它很少能够与其产生的HTML类似。所以，在Web浏览器或HTML编辑器中查看未经渲染的JSP模板是非常令人困惑的，而且得到的结果看上去也很丑陋。
因为JSP并不是真正的HTML，很多浏览器和编辑器展现的效果都很难在审美上接近模板最终所渲染出来的效果。
Thymeleaf是在标签中通过添加th:的方式实现逻辑和数据传递，html文件本身可以被浏览器很好的支持，即使没有后台的数据传输，也可以显示一个相差不多的页面。
在查找资料时有看到不少评论说ThymeLeaf有性能方面的问题，而同时也看到不少评论说在经过多年的升级过后，thymeleaf的性能已经提升了数十倍。总之，性能应该目前不算是问题。
与此同时，一些评论也称，需要严格遵守XMl规范的写法让他们难以接受，以及js脚本必须加入‘/’。
不过，ThymeLeaf现在时Spring官方的模板引擎方案。从1.5（或许更早）开始spring-boot对jsp的支持也有不少问题
所以无论优缺点，别问，问就是学就完事了。
ThymeLeaf如何替换模板和数据？
模板引擎可以让程序实现界面与数据分离，业务代码与逻辑代码的分离，这就提升了开发效率，良好的设计也使得代码复用变得更加容易。
一般的模板引擎都包含一个模板解析器和一套标记语言，好的模板引擎有简洁的语法规则、强大的功能、高效的渲染效率、详尽的帮助说明与不断的更新与维护。
如何使用ThymeLeaf？
spring-boot中不进行任何配置也可以使用，此时使用的是默认配置，需要自定义配置时在properties文件中配置即可。
传统spring项目中，可以通过配置类和xml方式配置模板和视图处理器的Bean
代码就不放在PPT中了。
ThymeLeaf可以怎么学习？
官方有个5分钟入门文档（英文）：https://www.thymeleaf.org/doc/articles/standarddialect5minutes.html
官方还有一个互动教程可以通过简单的练习快速了解ThymeLeaf：http://itutorial.thymeleaf.org/
我自己clone了一个spring-boot的教程项目，里面用了ThymeLeaf：https://github.com/JeffLi1993/springboot-learning-example
百（gu）度（ge）
5. 编码实战
6.扩展思考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f20ebefd6e0c40af3d4081818227dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0dddbc230eff543b183bd89194303a/" rel="bookmark">
			dump文件生成和分析查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，生成dump文件： 1.1手动生成dump文件： 如图：
命令如下：
ps -ef | grep list-app | grep -v grep jmap -dump:file=test.hprof,format=b 3307 1.2自动生成dump文件： 1. -XX:+HeapDumpOnOutOfMemoryError 当OutOfMemoryError发生时自动生成 Heap Dump 文件。 这是一个非常有用的参数，因为当你需要分析Java内存使用情况时，往往是在OOM(OutOfMemoryError)发生时。 2. -XX:+HeapDumpBeforeFullGC 当 JVM 执行 FullGC 前执行 dump。 3. -XX:+HeapDumpAfterFullGC 当 JVM 执行 FullGC 后执行 dump。 4. -XX:+HeapDumpOnCtrlBreak 交互式获取dump。在控制台按下快捷键Ctrl + Break时，JVM就会转存一下堆快照。 5. -XX:HeapDumpPath=d:\test.hprof 指定 dump 文件存储路径。 注意：JVM 生成 Heap Dump 的时候，虚拟机是暂停一切服务的。如果是线上系统执行 Heap Dump 时需要注意。
2，查看dump文件 推荐使用jdk自带的visualVM，其在JDK_HOME/bin目录下，可搜：jvisualvm。注意：windows系统是jvisualvm.exe文件。
然后装入快照即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36cdb5736de660963fdf3195daf78fad/" rel="bookmark">
			feignClient调用接口String类型转化异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章是对上篇feignClient文章的补充，具体场景是我用A服务去调用B服务的接口，B接口返回的是一个对象ObectX，里面包含1个布尔类型字段，2个String字段，1个Date类型字段。由于A服务已经添加了B服务的依赖，所以A服务可以直接使用B中的类ObjectX。所以A服务就用ObjectX来接收对B服务的调用结果，但是出现了异常，就是常见的String类型转换异常。
分析得出结论，两个服务之间调用的时候，传输的数据是Sting类型的json字符串，B服务的Date字段被转化成了String,再用Date类型接收，就出现类型异常了。
解决办法：在A服务中声明一个对象，把Date字段类型改为Stirng。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/108000b295dd9d14a51466bbcafd6c73/" rel="bookmark">
			Windows 环境下编译Hadoop源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows 环境下编译Hadoop源码 为了便于在Windows系统平台开发和调试Hadoop相关程序，我们需要重新编译Hadoop源码，使其能够在Windows环境下运行。我们需要一些额外的软件工具来辅助完成编译工作。
准备工作 Hadoop源码包根目录下的BUILDING.txt文档，介绍了当前Hadoop版本在不同平台编译所需软件和注意事项： 本文所需罗列如下： - 操作系统：Windows 10 64位 - Hadoop：hadoop-2.6.5-src.tar.gz - JDK：jdk-7u65-windows-x64.exe - Maven：apache-maven-3.3.9-bin.zip - CMake：cmake-3.12.0-rc1-win64-x64.zip - ProtocolBuffer：protobuf-2.5.0.zip - protoc：protoc-2.5.0-win32.zip - zlib：zlib-1.2.11.tar.gz - Cygwin：3.12.0 setup-x86_64.exe - Visual Studio 2010 以上软件包均可在我的百度网盘直接下载：https://pan.baidu.com/s/1YAAtLwKgoclEPz0pEej7BQ
安装软件 JDK：此处不再累述Maven：此处不再累述Hadoop：解压到指定目录CMake：解压到指定目录ProtocolBuffer：解压到指定目录protoc：解压并将protoc.exe放置在ProtocolBuffer的src目录zlib：解压到指定目录Cygwin：安装到指定目录Visual Studio 2010 ：安装到指定目录 配置环境变量 Platform：新建系统变量Platform=x64JDK：不再累述 Maven：将bin目录添加至PATH系统变量CMake：将bin目录添加至PATH系统变量ProtocolBuffer：将src目录添加至PATH系统变量zlib：新建ZLIB_HOME系统变量，并指向其解压根目录Cygwin：将bin目录添加至PATH系统变量 环境变量配置好后，进入ProtocolBuffer的java子目录，使用mvn install命令将其注入进maven的本地仓库中，并使用protoc --version 验证： 编译Hadoop 上述准备工作完成后，便可以编译Hadoop了。使用Visual Studio x64 Win64 命令提示(2010)进入Haddoop源码包根目录，执行mvn package -Pdist,native-win -DskipTests -Dtar命令重新编译打包（需要耐新等待，此处足足执行了26min54s）： 编译成功的基于Windows平台的文件将会存放在根目录下的hadoop-dist\target目录： 总结 由于我在最初编译Hadoop的过程中遇到了各种各样的问题，所以才有了写这样一篇博文的念头，以便自己或他人日后查阅。 以上配置执行的过程经过一路填坑，亲测可以正确无误的编译成功，因此没有记录太多中间遇到的编译中断、失败的问题。总结下来无非就是各种软件版本不匹配的问题，我在一开始本着越新越好的原则，在Jdk8、Visual Studio 2017等平台编译，总是出错，最终才领会到彼此匹配才是最好。所以提醒各位编译前先了解下Hadoop的版本，找到最合适的编译环境。
为了方便大家使用，现将编译后的软件包共享出来：
CSDN资源地址：hadoop-2.6.5.tar.gz百度网盘地址：hadoop-2.6.5.tar.gz 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4697e856af2acacb0d52701f73afc00/" rel="bookmark">
			SpringMVC集成Swagger2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 建立基本SpringMVC工程 1.1 建立SpringMVC Maven工程 web.xml &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;description&gt;Servlet Context&lt;/description&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-config/applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;!-- 拦截所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 1.2 创建一个TestController package com.study.swagger.control; @Controller @RequestMapping("/test") public class TestController { @RequestMapping(value="/hello", method=RequestMethod.GET) @ResponseBody public String sayHello(String name){ return "hello " + name; } } 1.3 配置spring bean applicatonContext.xml
&lt;mvc:annotation-driven /&gt; &lt;mvc:default-servlet-handler/&gt; &lt;context:component-scan base-package="com.study.swagger.control" /&gt; 2 引入Swagger2 2.1 引入Swagger2依赖 &lt;!-- Swagger2 Dependency --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4697e856af2acacb0d52701f73afc00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f969f4bab81c1793380dbe995900da82/" rel="bookmark">
			手工开发RTMP-HLS简易服务器_1_知识梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务要求： 输入：对接OBS推流
输出：能够在手机端浏览器观看OBS推流的视频/音频
源码： gitee：https://gitee.com/walty/WQ_RTMP
由于个人在C、C++方面能力有限，所以用Java写的项目，很多地方不成熟，还望包含。
知识补充： 1、HLS协议 HLS协议在Android端浏览(chrome)器与IOS端浏览器(safari)支持很好，只需要单纯的HTML的&lt;video src="xxxx.m3u8"&gt; 即可直接对接到该协议。
HLS协议主要分为两类文件，
1）一类为视频文件(.ts)文件，该文件主要保存了视频与音频，ts文件有多个，每个ts文件保存极短的视频。
2）第二类为 清单文件(.m3u8)，该文件内保存有视频文件的清单，m3u8文件只有一个，主要功能是指明当前视频是那个ts文件，下一个视频是哪个ts文件。
2、RTMP协议 RTMP协议是OBS软件推送数据(音频数据、视频数据、控制数据等)协议。
RTMP协议还包含有以下协议，用于压缩数据。
1）AMF0协议 amf0协议主要用于压缩控制数据，如：开始推流、停止推流、视频音频规格等等。[注]当前较为流行的是amf3协议，由于我做是去年做的、且RTMP协议也属于较老的协议，所以可能目前还没跟上时代的潮流。
2）FLV协议 flv协议主要用于压缩视频音频数据。
3）H264、AAC H264为视频格式，AAC为音频格式。虽然有MP4、wav等格式，但是在直播技术中较为主流的还是h264、aac。[注]最近已经有推出h265协议，压缩能力更强。
3、FFmpeg 如果你是工作需要，建议使用FFmpeg 代码主要思想 总：RTMP协议解析OBS推流的数据--&gt;&gt;提取、保存H264/AAC数据--&gt;&gt;构建TS文件和更新m3u8文件--&gt;&gt;HTML端通过Video标签访问m3u8清单文件，实现直播效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ecaa070c66db8d852d594500bb29b81/" rel="bookmark">
			error: invalid use of void expression
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		void*类型定义的指针变量只可以接收对象的地址，而没有对象类型这个概念。所以void*指针变量是不能直接用“*指针变量”去访问，需要强制类型转换后才能“间接”访问：
*(type*)指针变量，必须给出正确的type！
转载于:https://www.cnblogs.com/jiangyibo/p/9215138.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d53ca5f8301c05e1b7ea041dc8a444/" rel="bookmark">
			js中时间戳转换成时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function timestampToTime(timestamp) { var date = new Date(timestamp );//时间戳为10位需*1000，时间戳为13位的话不需乘1000 Y = date.getFullYear() + '-'; M = (date.getMonth()+1 &lt; 10 ? '0'+(date.getMonth()+1) : date.getMonth()+1) + '-'; D = date.getDate() + ' '; h = date.getHours() + ':'; m = date.getMinutes() + ':'; s = date.getSeconds(); return Y+M+D;//时分秒可以根据自己的需求加上 } 运用上面输出的时间格式为：yyyy-MM-dd
例如：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8e30c7b36591a86df394ce8880e4a0a/" rel="bookmark">
			虚拟化平台vcenter导入部署ovf格式的虚拟机报错:缺少所需要的磁盘映像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景描述：
在向虚拟化平台的的vCenter导入OVF格式的文件时，页面报如下错误。
2.原因分析
原来的镜像名字中包含有中文，导出的时候在.OVF里面，对应的磁盘名字的中的中文变成了乱码，导致导入的时候，平台无法通过.OVF找到对应的磁盘影响。
3.解决：
修改上图中的文件名字，重新导入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd62d98d1c8c317582260ad10ba49348/" rel="bookmark">
			网上投稿地址大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上投稿地址大全
上海科技报 kgbshen@online.sh.cn
厂长经理日报 cjb490@sina.com
四川日报 sichuandaily@scol.com.cn
四川农村日报 country@scol.com.cn
华西都市报 wccdaily@scol.com.cn
天府早报 morning@scol.com.cn
家庭与生活报 homelife@scol.com.cn
四川质量报 quality@scol.com.cn
21世纪体育报 sports@scol.com.cn
大众健康报 dzjkb@swww.com.cn
德阳日报 dyrb@swww.com.cn
读者报 mdzb@swww.com.cn
改革时报 ggsb@swww.com.cn
四川工人日报 scgrrb@swww.com.cn
四川广播电视报 gbdsb@swww.com.cn
广元日报 gyrb@swww.com.cn
华西都市报 hxdsb_02@sina.com
家庭与生活报 jtysh@swww.com.cn
四川价格报 scjgb@swww.com.cn
金融投资报 jrb@swww.com.cn
教育导报 jydb@swww.com.cn
四川经济日报 scjjrb@public2.swww.com.cn
精神文明报 jswmb@swww.com.cn　警钟长鸣报 jzcmb@263.net
四川科技报 skb@swww.com.cn
劳动导报 lao@swww.com.cn
凉山日报 lsrb@swww.com.cn
泸州日报 jcxqk@lz-public.sc.cninfo.net
泸州广播电视报 lzgdb@sww.com.cn
眉山日报 msrb@swww.com.cn
眉山广播电视报 msgdb@swww.com.cn
绵阳日报 myrb@swww.com.cn
樊枝花日报 pzhrb@swww.com.cn
四川青年报 scyn@swww.com.cn
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd62d98d1c8c317582260ad10ba49348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772ed10860db7579b25a19d83c1c81d9/" rel="bookmark">
			iOS常用方法——URL编码和URL解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		URL编码是一种常见的编码方式，作用不多说，直接上代码。
URL编码： - (NSString *)URLEncodedString { // CharactersToBeEscaped = @":/?&amp;=;+!@#$()~',*"; // CharactersToLeaveUnescaped = @"[]."; NSString *unencodedString = self; NSString *encodedString = (NSString *) CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (CFStringRef)unencodedString, NULL, (CFStringRef)@"!*'();:@&amp;=+$,/?%#[]", kCFStringEncodingUTF8)); return encodedString; } URL解码： - (NSString *)URLDecodedString { NSString *result = [(NSString *)self stringByReplacingOccurrencesOfString:@"+" withString:@" "]; return [result stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; } 建议这两个方法放在NSString的分类中，并且声明为实例方法，这样可以直接用NSString的对象去调用。 - 调用示例：
NSString * string = @"zhansan啦啦啦啦1234567"; NSString * urlEncode = [string URLEncodedString]; NSString * urlDecode = [string URLDecodedString]; NSLog(@"urlEncode == %@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/772ed10860db7579b25a19d83c1c81d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ddd5a96ca740ab46ec5e4bd3468513/" rel="bookmark">
			分布式CAP定理，为什么不能同时满足三个特性？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在弄清楚这个问题之前，我们先了解一下什么是分布式的CAP定理。
根据百度百科的定义，CAP定理又称CAP原则，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），最多只能同时三个特性中的两个，三者不可兼得。
一、CAP的定义 Consistency (一致性)：
“all nodes see the same data at the same time”,即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。
Availability (可用性):
可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。
Partition Tolerance (分区容错性):
即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。
分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。
二、CAP定理的证明 现在我们就来证明一下，为什么不能同时满足三个特性？
假设有两台服务器，一台放着应用A和数据库V，一台放着应用B和数据库V，他们之间的网络可以互通，也就相当于分布式系统的两个部分。
在满足一致性的时候，两台服务器 N1和N2，一开始两台服务器的数据是一样的，DB0=DB0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。 当用户通过N1中的A应用请求数据更新到服务器DB0后，这时N1中的服务器DB0变为DB1，通过分布式系统的数据同步更新操作，N2服务器中的数据库V0也更新为了DB1，这时，用户通过B向数据库发起请求得到的数据就是即时更新后的数据DB1。
上面是正常运作的情况，但分布式系统中，最大的问题就是网络传输问题，现在假设一种极端情况，N1和N2之间的网络断开了，但我们仍要支持这种网络异常，也就是满足分区容错性，那么这样能不能同时满足一致性和可用性呢？
假设N1和N2之间通信的时候网络突然出现故障，有用户向N1发送数据更新请求，那N1中的数据DB0将被更新为DB1，由于网络是断开的，N2中的数据库仍旧是DB0；
如果这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据DB1，怎么办呢？有二种选择，第一，牺牲数据一致性，响应旧的数据DB0给用户；第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作完成之后，再给用户响应最新的数据DB1。
上面的过程比较简单，但也说明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。也就是说分布式系统不可能同时满足三个特性。这就需要我们在搭建系统时进行取舍了，那么，怎么取舍才是更好的策略呢?
三、取舍策略 CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：
CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。
CP without A：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。
AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。
三、总结 现如今，对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，节点只会越来越多，所以节点故障、网络故障是常态，因此分区容错性也就成为了一个分布式系统必然要面对的问题。那么就只能在C和A之间进行取舍。但对于传统的项目就可能有所不同，拿银行的转账系统来说，涉及到金钱的对于数据一致性不能做出一丝的让步，C必须保证，出现网络故障的话，宁可停止服务，可以在A和P之间做取舍。
总而言之，没有最好的策略，好的系统应该是根据业务场景来进行架构设计的，只有适合的才是最好的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e439edbeb35f52a8b23efedad03940/" rel="bookmark">
			iOS阿里云对象存储 OSS文件的上传/下载的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的项目中，图片语音等资源文件都是直接上传数据流给服务器，然后服务器进行处理和存储。最近的这个项目，服务器直接开的OSS，然后客户端直接使用阿里云提供的上传下载功能来上传和下载资源。 阿里云对图片的处理做的很到位，尺寸在获取图片时可自定义。 首先在项目中导入阿里云OSS的库，直接在pod中加上如下代码：
pod 'AliyunOSSiOS' 如果不是用pod的话，可点击此链接前往下载：https://help.aliyun.com/document_detail/32173.html 我们可以封装一个OSS的工具类，专门用来管理文件的上传和下载。OSS的初始化和配置代码：
//以下参数服务器端可提供 #define ACCKEY @"Mt5jQPnQQECHqTEST" #define ACCSECRET @"2QgUjalQoBsdLn2iYFpqW0TEST" #define ENDPOINT @"http://oss-cn-hangzhou.aliyuncs.com" #import "BZHttpFileHelper.h" #import &lt;AliyunOSSiOS/OSSService.h&gt; @interface BZHttpFileHelper () @property(nonatomic,strong) OSSClient * client; @end @implementation BZHttpFileHelper +(instancetype)fileHelperShareInstance{ static BZHttpFileHelper * fileHelper = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ fileHelper = [[BZHttpFileHelper alloc] init]; [fileHelper initAliClient]; }); return fileHelper; } -(void)initAliClient{ id&lt;OSSCredentialProvider&gt; credential = [[OSSPlainTextAKSKPairCredentialProvider alloc] initWithPlainTextAccessKey:ACCKEY secretKey:ACCSECRET]; OSSClientConfiguration * conf = [OSSClientConfiguration new]; // 网络请求遇到异常失败后的重试次数 conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0e439edbeb35f52a8b23efedad03940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd806f132ded8577bdf708da596cfa3d/" rel="bookmark">
			P2P技术原理及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P2P技术原理及应用 作 者：金海 廖小飞 摘要：对等网络(P2P)有3种主要的组织结构：分布式哈希表(DHT)结构、树形结构、网状结构。P2P技术已经延伸到几乎所有的网络应用领域，如分布式科学计算、文件共享、流媒体直播与点播、语音通信及在线游戏支撑平台等方面。现在人们已经开始将重心转入到覆盖层网络的节点延时聚集研究、覆盖网之间(Inter-Overlay)优化研究、P2P支撑平台研究以及P2P安全研究等方面。 关键词：对等网络；分布式哈希表；覆盖层网络 Abstract:ThePeer-to-peer(P2P)network has three main structures: Distributed Hash Table (DHT) structure, tree structure, and mesh structure. P2P technology has been extended to almost all areas of network applications, including distributed scientific computing, file sharing, streaming media on-demand and live broadcast, voice communications, and online gaming support platform. Now, study areas such as node latency aggregation for overlay network, Inter-Overlay optimization, P2P supporting platform, and P2P security are receiving more attention.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd806f132ded8577bdf708da596cfa3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e3480e699d98b0c44a2bf1f1f702744/" rel="bookmark">
			行走在centos的弯路上：Restarting network (via systemctl)::  Job for network.service failed. ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次安装了一个centos安装了7.0版本，结果之后网络在安装文件时候出错了果断重装，之后又安装了一个centos6.5，但卡在了第一步桥接网络上，现在又重新安装7.0版本：
在配置了ifcfg-eno16777736文件后（方法请参考：https://www.cnblogs.com/jasmine-Jobs/p/5928218.html）；
之后运行service network restart 的时候出来错误：
Restarting network (via systemctl): Job for network.service failed. See 'systemctl status network.service' and 'journalctl -xn' for details. [FAILED] 之后通过查找知道了7.0需要运行systemctl 而不是service ：systemctl restart network.service 但问题还没有解决：
Job for network.service failed. See 'systemctl status network.service' and 'journalctl -xn' for details. [FAILED] 这个问题还没有解决：
参考：https://blog.csdn.net/zkja595470467/article/details/53007915
运行：
systemctl status network.service
出现了：
按照网上方法还是没有解决问题；但受到了启发，我作为桥连接的是移动网卡但是我目前使用的是网线，之前由于配置网络的时候用的是有线网络，在配置centos6.5的时候把它改成无线了，所以不能用！，所以我果断连上了wife在试了一次
systemctl restart network.service 成功！！！
ping 一下电脑的ip或者网址，可以连接！！！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18aea8d69e495a9c3e1093bf522b6ad4/" rel="bookmark">
			Windows 服务器查看远程登录的IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先感谢本文方法的原作者, 原文地址 : win7 查看远程登录 ip-CSDN
我使用的服务器是Windows Server 2008 r2 Ent, 我的环境是英文环境, 中文环境应该是一样的
一, 在开始菜单中搜索 “Event Viewer” 二, 展开左侧的 “Windows Logs” 然后双击 “Security” 三, 点击最右边”Actions” 栏中的 “Filter Current Log…” 四, 在弹出的窗口选择时间 (Logged), 和输入事件ID : 4648, 我这里是想查看过去一个小时远程到本机的记录 五,方法选中一条过滤出来的记录, 然后 点击 左边的 “Details”, 其中 “EventData” 下的 “IpAddress” 即为远程过来的IP地址 六, 再次感谢原作者 原文地址 : win7 查看远程登录 ip-CSDN 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7b2487813bbbf5ee7c35c7ac6ebbf2/" rel="bookmark">
			【通俗易懂】机器学习中 L1 和 L2 正则化的直观解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人网站：红色石头的机器学习之路 CSDN博客：红色石头的专栏 知乎：红色石头 微博：RedstoneWill的微博 GitHub：RedstoneWill的GitHub 微信公众号：AI有道（ID：redstonewill）
机器学习中，如果参数过多，模型过于复杂，容易造成过拟合（overfit）。即模型在训练样本数据上表现的很好，但在实际测试样本上表现的较差，不具备良好的泛化能力。为了避免过拟合，最常用的一种方法是使用使用正则化，例如 L1 和 L2 正则化。但是，正则化项是如何得来的？其背后的数学原理是什么？L1 正则化和 L2 正则化之间有何区别？本文将给出直观的解释。
1. L2 正则化直观解释 L2 正则化公式非常简单，直接在原来的损失函数基础上加上权重参数的平方和：
L=Ein+λ∑jw2j L = E i n + λ ∑ j w j 2 其中，Ein 是未包含正则化项的训练样本误差，λ 是正则化参数，可调。但是正则化项是如何推导的？接下来，我将详细介绍其中的物理意义。
我们知道，正则化的目的是限制参数过多或者过大，避免模型更加复杂。例如，使用多项式模型，如果使用 10 阶多项式，模型可能过于复杂，容易发生过拟合。所以，为了防止过拟合，我们可以将其高阶部分的权重 w 限制为 0，这样，就相当于从高阶的形式转换为低阶。
为了达到这一目的，最直观的方法就是限制 w 的个数，但是这类条件属于 NP-hard 问题，求解非常困难。所以，一般的做法是寻找更宽松的限定条件：
∑jw2j≤C ∑ j w j 2 ≤ C 上式是对 w 的平方和做数值上界限定，即所有w 的平方和不超过参数 C。这时候，我们的目标就转换为：最小化训练样本误差 Ein，但是要遵循 w 平方和小于 C 的条件。
下面，我用一张图来说明如何在限定条件下，对 Ein 进行最小化的优化。
如上图所示，蓝色椭圆区域是最小化 Ein 区域，红色圆圈是 w 的限定条件区域。在没有限定条件的情况下，一般使用梯度下降算法，在蓝色椭圆区域内会一直沿着 w 梯度的反方向前进，直到找到全局最优值 wlin。例如空间中有一点 w（图中紫色点），此时 w 会沿着 -∇Ein 的方向移动，如图中蓝色箭头所示。但是，由于存在限定条件，w 不能离开红色圆形区域，最多只能位于圆上边缘位置，沿着切线方向。w 的方向如图中红色箭头所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f7b2487813bbbf5ee7c35c7ac6ebbf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0581465eb859c844234b9122b382c69e/" rel="bookmark">
			你还在把Java当成Android官方开发语言吗？Kotlin了解一下！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语：2017年Google IO大会宣布使用Kotlin作为Android的官方开发语言，相比较与典型的面相对象的JAVA语言，Kotlin作为一种新式的函数式编程语言，也有人称之为Android平台的Swift语言。
本文由腾讯Bugly发表在腾讯云+社区
先让我们看下实现同样的功能，Java和Kotiln的对比：
// JAVA，20多行代码，充斥着findViewById，类型转换，匿名内部类这样的无意义代码 public class MainJavaActivity extends Activity { @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView label = (TextView) findViewById(R.id.label); Button btn = (Button) findViewById(R.id.btn); label.setText("hello"); label.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.d("Glen","onClick TextView"); } }); btn.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v) { Log.d("Glen","onClick Button"); } }); } } 复制代码 再来看Kotlin
// Kotlin,没有了冗余的findViewById，我们可以直接对资源id进行操作，也不需要匿名内部类的声明，更关注函数的实现本身，抛弃了复杂的格式 class MainKotlinActivity:Activity() { override fun onCreate(savedInstanceState: Bundle?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0581465eb859c844234b9122b382c69e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac89b50f9c2a2478b061d731121128f6/" rel="bookmark">
			python五子棋--博弈树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from graphics import * from math import * import numpy as np def ai(): """ AI计算落子位置 """ maxmin(True, DEPTH, -99999999, 99999999) return next_point[0], next_point[1] def maxmin(is_ai, depth, alpha, beta): """ 负值极大算法搜索 alpha + beta剪枝 """ # 游戏是否结束 | | 探索的递归深度是否到边界 if game_win(list1) or game_win(list2) or depth == 0: return evaluation(is_ai) blank_list = list(set(list_all).difference(set(list3))) order(blank_list) # 搜索顺序排序 提高剪枝效率 # 遍历每一个候选步 for next_step in blank_list[0:60]: # 如果要评估的位置没有相邻的子， 则不去评估 减少计算 if not has_neightnor(next_step): continue if is_ai: list1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac89b50f9c2a2478b061d731121128f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bdab7b7752a1feff6bba562222cbd14/" rel="bookmark">
			Soundex UVA - 10260（soundex编码）（水）（略坑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传送门
题意：Soundex编码是将基于它们的拼写听起来相同的单词归类在一起。例如，“can”和“khawn”在Soundex编码下是等价的。
这道题WA了两发，拓展了个知识。
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;map&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int maxn=25; char s[maxn]; int main() { map&lt;char,int&gt;m; m['B']=1; m['F']=1; m['P']=1; m['V']=1; m['Z']=2; m['X']=2; m['S']=2; m['Q']=2; m['K']=2; m['J']=2; m['G']=2; m['C']=2; m['T']=3; m['D']=3; m['L']=4; m['N']=5; m['M']=5; m['R']=6; while(scanf("%s",s)!=EOF){ int len=strlen(s); vector&lt;int&gt;v; for(int i=0;i&lt;len;i++){ if(m[s[i]]){ v.push_back(m[s[i]]); }else{ v.push_back(0); } } int len1=v.size(); for(int i=0;i&lt;len1;i++){ int flag=1; for(int j=i+1;j&lt;len1;j++){ if(v[j]==v[i]){ v[j]=0; }else{ flag=0; } if(!flag){ break; } } } len1=v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bdab7b7752a1feff6bba562222cbd14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d5f4c829b73a2b5e472d367318f777/" rel="bookmark">
			奖金（信息学奥赛一本通-T1352）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目描述】 由于无敌的凡凡在2005年世界英俊帅气男总决选中胜出，Yali Company总经理Mr.Z心情好，决定给每位员工发奖金。公司决定以每个人本年在公司的贡献为标准来计算他们得到奖金的多少。
于是Mr.Z下令召开m方会谈。每位参加会谈的代表提出了自己的意见：“我认为员工a的奖金应该比b高！”Mr.Z决定要找出一种奖金方案，满足各位代表的意见，且同时使得总奖金数最少。每位员工奖金最少为100元。
【输入】 第一行两个整数n,m，表示员工总数和代表数；
以下m行，每行2个整数a,b，表示某个代表认为第a号员工奖金应该比第b号员工高。
【输出】 若无法找到合理方案，则输出“Poor Xed”；否则输出一个数表示最少总奖金。
【输入样例】 2 1
1 2
【输出样例】 201
【源程序】 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;string&gt; #include&lt;cstdlib&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;set&gt; #define INF 0x3f3f3f3f #define PI acos(-1.0) #define N 100001 #define MOD 123 #define E 1e-6 using namespace std; int n,m; int head[N],side[N]; int f[N],q[N]; int vis[N]; int cnt; struct node{ int pre; int next; }a[N]; void add_edge(int x,int y) { cnt++; a[cnt].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d5f4c829b73a2b5e472d367318f777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feff081650fee019d7eef19fb80cf7a6/" rel="bookmark">
			Win7开机卡在Windows Update 35%的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一台Win7老机器，多年未清理，用DISM++清理后，开机重启一直卡在Windows Update 35%转圈圈数小时，无法进入系统。
强制按关机键，F8进入安全模式依然同样现象。
查阅MSDN后，有人提到用DISM撤销上次的系统操作可解决问题。
用WinRE恢复模式或WinPE启动，运行如下的命令，其中X:为Win7系统所在盘符。
DISM /Image:X:\ /Cleanup-Image /RevertPendingActions 重启后，发现问题已解决，直接进入了Win7登录界面。
转载于:https://www.cnblogs.com/teacat/p/9204225.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8e9a290c2950f2c3ff2d2879e1eb9e1/" rel="bookmark">
			navicat 导入导出数据库表及结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导出：数据传输（这个名字比较容易让人误解） 使用数据传输可以导出表结构或数据，还可以分别选择每个表是否导出。"数据传输"这个名字起的可能使人误导，实际上它不只可以传输到另一个数据库，也可以保存为sql文件。
在数据传输的"高级"界面可以分别选择是否导出表结构和是否导出数据。
在"常规"界面选择文件的话，可以存储为sql文件。选择连接可以直接将表从一个数据库复制到另一个数据库中。
即完成导出表格的结构和数据。
导入：运行SQL文件 在需要导入的数据库上，右击选择“运行SQL文件”会弹出一个框，点击“...”选择文件所在的路径，点击开始，文件就会导入成功！
注意哦：导入后需要关闭数据库，重新连接才能看到导入的表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d10591ac64cd1ac0b7ef5a5821fef9d/" rel="bookmark">
			Html主题样式切换方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着网站个性化体验的要求不断提高，无论移动和PC 端，都会有主题切换的功能；当然切换的样式复杂度大小不同，从简单的配色切换到复杂的配色布局切换；现总结几种方案，可根据项目需求，实现复杂程度和效果体验，选择方案；
一、切换样式表引用：
编写两套样式 them1.css 、them2.css 通过js 动态切换 link 标签的属性，或追加目标主题样式表、清除现有样式表；Fixfox 浏览器可以通过浏览器切换 link 样式表，但是IE 浏览器不支持，需要手动实现
优点：简单、快捷、方便；
缺点：由于是切换引用css 文件，会由于网络原因造成加载css 文件延迟、或由于javascript 错误阻塞造成切换失败，不利于客户体验；
&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;CSS主题切换&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="a.css" title="a"&gt; &lt;link rel="alternate stylesheet" type="text/css" href="b.css" title="b"&gt; &lt;script&gt; // 对切换主题的按钮绑定事件，用来做触发 document.getElementById("sheet-a").addEventListener("click",function(){ setStyleSheet("a"); }); document.getElementById("sheet-b").addEventListener("click",function(){ setStyleSheet("b"); }); /** * 查找所有的link标签，找到符合条件的css进行切换 * @title:需要切换的css文件名称，也可以是某值，主要是能够找到所要切换的link标签 **/ function setStyleSheet(title){ // 首先找到DOM中所有的link标签 var link_list = document.getElementsByTagName("link"); if ( link_list ){ for ( var i=0;i&lt;link_list.length;i++ ){ // 要找到所有link中rel属性值包括style的，也就是包括stylesheet和alternate stylesheet; if ( link_list[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d10591ac64cd1ac0b7ef5a5821fef9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbca83d0958dfcc72c1e5deeeacb2378/" rel="bookmark">
			Android源码解析:Application的onCreate()方法是如何被调用的.md
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		带着疑问看源码1
1.一个程序的入口是main方法,而当我们接触安卓的时候都是Activity的各种生命周期方法,那main在哪里调用呢?就是ActivityThread中,该类也代表应用程序的主进程.
ActivityThread -&gt; main() public static void main(String[] args) { //... 1.开启Looper Looper.prepareMainLooper(); //2.实例化ActivityThread,并调用attach()方法 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } //... Looper.loop(); } -&gt;attach(false)方法 private void attach(boolean system) { if (!system) { //... //1.内部调用者的是AMS,将ApplicationThread对象与AMS联系起来,ApplicationThread作为AMS的代理类 //调用AMS的attachApplication()方法,最后还是调用到ApplicationThread的bindApplication()方法 final IActivityManager mgr = ActivityManager.getService(); try { mgr.attachApplication(mAppThread); // } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } // ... }else{ // ... } ApplicationThread.bindApplication()方法 public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial) { //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbca83d0958dfcc72c1e5deeeacb2378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da7cc639bce55d5fd334e3708c9fa261/" rel="bookmark">
			ubuntu vi不能正常使用上下左右方向键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 $sudo apt-get remove vim-common $sudo apt-get install vim 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cdb7cb507a6dbf5f4f6d9cc08feb517/" rel="bookmark">
			ToList()所带来的性能影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文: ToList()所带来的性能影响 前几天优化师弟写的代码，有一个地方给我留下很深刻的印象，就是我发现他总是将PLINQ的结果ToList&lt;&gt;()，然后再返回给主程序，对于这一点我十分不解，于是去问他是什么原因，得到的答案很幽默:因为习惯。
有时候对于方法的不甚了解加上“习惯”，往往是程序性能和稳定性终结者，就拿这个Case来说吧，原始代码如下：
var query = from cr in LCRNormal.AsParallel() let listId = from crt in LCRNormal group crt by crt.KeyValue into m select m.Max(n =&gt; n.DBID) where listId.Contains(cr.DBID) &amp;&amp; !cr.IsRegularRecord &amp;&amp; cr.Status != 3 select new ComputingResultForTemp() { KeyValue = cr.KeyValue, DBID = cr.DBID, Status = cr.Status }; 经过以上PLINQ后，泛型列表中大概还剩下60万至100万条数据，然后我们这位师弟做了两个很“施瓦辛格”的动作：ToList&lt;&gt;()和Count()，测试程序运行在一台4*2G HZ，12GB内存的服务器上，竟然跑了2天多！我觉得正式这两个方法导致了程序性能的降低，为了 确定我的判断，我分别在以上代码、ToList&lt;&gt;()和Count()周围加上了StopWatch计时器，然后将结果以文本的形式输出：
● 100万数据PLINQ：
==========3/26/2011 01:34:31 PM ===========
**(GetDeletedRecords)Start PLINQ(LINQ FITTER)
==========3/26/2011 01:38:38 PM ===========
**(GetDeletedRecords)Finish PLINQ (LINQ FITTER)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cdb7cb507a6dbf5f4f6d9cc08feb517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864cfd3a09620801151bc5c4d43150d3/" rel="bookmark">
			smali 语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.smali
apk文件通过apktool反编译出来的都有一个smali文件夹，里面都是以.smali结尾的文件。
smali语言是Davlik的寄存器语言，语法上和汇编语言相似，Dalvik VM与JVM的最大的区别之一就是Dalvik VM是基于寄存器的。基于寄存器的意思是，在smali里的所有操作都必须经过寄存器来进行。
2.基本数据类型 B—byte
C—char
D—double
F—float
I—int
S—short
V—void
J—long
Z—boolean
注意J、Z两个不是对应类型的首字母；
在dalvik字节码中，寄存器都是32位的，能够支持任何类型，Long和Double类型是64位的，需要2个寄存器；
V 只能用于返回值类型；
3.数组和对象是引用类型 数组的表示方式是在基本类型前加上前中括号“[”，例如int数组和float数组分别表示为：[I、[F；
对象类型以L作为开头来表示，格式是Lpackage/ClassName;（用分号表示对象结束是必须的），示例：
String对象在smali中为：Ljava/lang/String;
Class1对象的一个boolean成员表示为：Lcom/disney/Class1;-&gt;isRunning:Z
Class1对象的一个String对象成员表示为：Lcom/disney/Class1;-&gt;name:Ljava/lang/String;
可以总结为格式为对象类型-&gt;成员名:成员类型，-&gt;表示所属关系，类型尾部必须包括一个分号。
内部类表示为：Lpackage/ClassName$innerObjectName;，也就是在内部类前加“$”符号。
4.函数 格式：Func-Name (Para-Type1Para-Type2Para-Type3…)Return-Type
返回类型在最后，参数之间没有任何分隔符，示例：
void fun() fun()V boolean fun(int, int, int) fun(III)Z String fun(boolean, int[], int[], String, long) fun(Z[I[ILjava/lang/String;J)Ljava/lang/String; 5.语法 #标记，构造函数的返回类型为V，名字为&lt;init&gt;
# static fields 定义静态变量的标记 # instance fields 定义实例变量的标记 # direct methods 定义静态方法的标记？？ # virtual methods 定义非静态方法的标记？？ .class public Lcom/disney/WMW/WMWActivity; .super Lcom/disney/common/BaseActivity; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864cfd3a09620801151bc5c4d43150d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056f56d836d7dac7077b8a79b3999856/" rel="bookmark">
			arcgis for android 100.2去掉水印和logo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们进入arcgis for android界面，点击如图所示的位置。
如图依次选择【APIs&amp;SDKs】、【Runtime SDKs】
跳转到该界面后如图所示，下拉到网页的尾部。
点击【license you app】如下图所示
点击如上图所示的【Show my ArcGIS Runtime Lite license key】。值得注意的用户此登录的账号必须是开发者账号。获取key后在代码里面如图的方式写入即可。
如果想去掉下面的logo可以使用下面的方法
mapView.setAttributionTextVisible(false)
更多内容，微信扫二维码关注公众号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b463df9144e059623110cd0b499154b/" rel="bookmark">
			OC NSRange用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 NSRange的定义 typedef struct _NSRange { NSUInteger location; NSUInteger length; } NSRange; 从源码中我们可以看到,NSRange是一个结构题,其中location是一个以0为开始的index,length是表示对象的长度;
NSRange用来表示事务的一个范围,通常是字符串里的自负范围或数组里面的元素范围,NSRange有两个成员;
location 表示范围的起始位置;
length 表示该范围的长度;
NSRange的创建 //通过结构体变量来访问成员 NSRange a; a.location=1; a.length=2; //结构体变量整体赋值 NSRange b={2,3}; NSRange c={.location=3,.length=4}; /** 通过NSMakeRange结构体变量整体赋值 NS_INLINE NSRange NSMakeRange(NSUInteger loc, NSUInteger len) { NSRange r; r.location = loc; r.length = len; return r; } */ NSRange d=NSMakeRange(0,2); 实例:查询字符串"that girl"中的"girl"的起点和长度; NSString *str=@"that girl"; NSRange loveRange=[str rangeOfString:@"girl"]; NSLog(@"%d_%d",loveRange.location,loveRange.length); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/733a4a368e4439ef92f095bc18330592/" rel="bookmark">
			docker默认安装路径的调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 的镜像与容器都存储在 /var/lib/docker 下面，那么基于不同的系统又有不同的存储方式，在 ubuntu 下面存储方式为 AUFS；在 Centos 下面存储方式又是 device mapper。
一：/var文件系统
/var文件系统
/var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充的。原来/var目录中有些内容是在/usr中的，但为了保持/usr目录的相对稳定，就把那些需要经常改变的目录放到/var中了。每个系统是特定的，即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。
1. /var/catman 包括了格式化过的帮助(man)页。帮助页的源文件一般存在/usr/man/man中；有些man页可能有预格式化的版本，存在/usr/man/cat中。而其他的man页在第一次看时都需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman 经常被清除，就像清除临时目录一样。) 2. /var/lib 存放系统正常运行时要改变的文件。
3. /var/local 存放/usr/local 中安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。
4. /var/lock 锁定文件。许多程序遵循在/var/lock 中产生一个锁定文件的约定，以用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。
5. /var/log 各种程序的日志(log)文件，尤其是login (/var/log/wtmp log纪录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息)。/var/log 里的文件经常不确定地增长，应该定期清除。
6. /var/run 保存在下一次系统引导前有效的关于系统的信息文件。例如， /var/run/utmp 包含当前登录的用户的信息。
7. /var/spool 放置“假脱机(spool)”程序的目录，如mail、news、打印队列和其他队列工作的目录。每个不同的spool在/var/spool下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail 中。
8. /var/tmp 比/tmp 允许更大的或需要存在较长时间的临时文件。注意系统管理员可能不允许/var/tmp 有很旧的文件。
二：镜像查找
一、在image文件夹中寻找
1.找到镜像库的文件
首先看repositories.json中的数据
root@ubuntu:/var/lib/docker#cat /var/lib/docker/image/aufs/repositories.json | python -mjson.tool
{
"Repositories": {
"ubuntu": {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/733a4a368e4439ef92f095bc18330592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8292d3de7bb49d507762d502270387/" rel="bookmark">
			vue 封装方法并每个页面调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建一个js export function activeFn(yong) { // 中英文互换 let storage=localStorage.getItem("key") if(storage=="zhCHS"){ this.ch=false this.eng=true this.$i18n.locale='zhCHS' }else { this.$i18n.locale='en' this.eng=false this.ch=true } yong(11) 每个页面调用这个方法 }
页面调用
通过export方式导出，在导入时要加{ }，export default则不需要
import {activeFn} from "../../../unit";
methods：{
activeFn, }
每次页面加载调用yong()
mounted（）{ this.activeFn(yong); } 如果打包出现问题如
ERROR in .xxx.js from UglifyJs Unexpected token: 有人说这是es6不支持。选择babel-loader没有。我认为是单纯的安装路径找不到，解决方法
在build里的webpack.base.conf.js里找到下面的一行代码添加你的路径 例如：
{ test: /\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test'),resolve('unit/index')] }, 就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb234da1bc4a3540aff8b835ad1e04cf/" rel="bookmark">
			Integer.MIN_VALUE和Integer.MAX_VALUE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先去看原码、反码和补码那一篇。
java源代码： Integer.MAX_VALUE经常会在集合中用到，对这个概念一直没有深究过，查看一下源码。
一个常数，持有了int类型数最小值，-2^31次方，-2147483648。负21亿多。
/**
* A constant holding the minimum value an {@code int} can
* have, -2&lt;sup&gt;31&lt;/sup&gt;.
*/
@Native public static final int MIN_VALUE = 0x80000000;
一个常数，持有了int类型数的最大值，2^31次方，2147483648，正21亿多
/**
* A constant holding the maximum value an {@code int} can
* have, 2&lt;sup&gt;31&lt;/sup&gt;-1.
*/
@Native public static final int MAX_VALUE = 0x7fffffff;
解释： 1、0x80000000 0x表示16进制
80000000一共8位16进制，也就是32位的2进制，2进制写法位数太多了，不展开写了，这也是为什么用16进制表示的原因。
1000 后面28个0，前面1表示负数，后面的27个0，这个应该是补码，那就是-1，会得到27个1，然后再求反码，27个0，纳尼？？？
因为这个数达到了32位二进制的上限，所以我们不会再去按照-1，再反码的方式求真正的值，直接按照原码的负数计算即可。也就是-2^31次方。
2、0x7fffffff 展开就是0111后面28个1，也就是一共31个1的整数，2^31 - 1
3、MAX_VALUE + 1 == MIN_VALUE 这他妈就好玩了，0111 1111 1111 1111 1111 1111 1111 1111+1 = 1000 0000 0000 0000 0000 0000 0000 0000 没毛病。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb234da1bc4a3540aff8b835ad1e04cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d1ed7474bd136ec7c8140047fa2089/" rel="bookmark">
			es6-algorithm 之 Queue和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Queue的概念 我们知道队列是一种常用的先进先出（FIFO）的有序集合。队列的实际应用其实非常广泛。比如排队，event loop里的事件队列，优先队列，循环队列，操作系统中也大量运用队列。废话不多说，看看实现。
Queue队列的实现 首先创建Queue, Queue一般有 enqueue(队列尾部插入一条数据)，dequeue（删除队列第一条数据，也就是最先进来的那条）， front(获取队列第一条数据)，size (队列的长度)，isEmpty（判断队列是否空），print（打印整个队列信息）等方法。基本结构如下。
const Queue = (() =&gt; { const wp = new WeakMap() class Queue { constructor () { wp.set(this, []) } enqueue (ele) { wp.get(this).push(ele) } dequeue () { return wp.get(this).shift() } front () { return wp.get(this)[0] } isEmpty () { return wp.get(this).length === 0 } size () { return wp.get(this).length } print () { return wp.get(this).toString() } } return Queue })() 具体使用如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19d1ed7474bd136ec7c8140047fa2089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86b52e172c25c0ab351b5069ef721982/" rel="bookmark">
			使用vue-grid-layout完成桌面拖拽布局功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在用写公司项目里的一个桌面布局功能 需要使用到vue-grid-layout
看了下网上的 基本上只有demo的使用，这个插件虽然挺不错但是缺陷也很大.
没有下边界，发生碰撞的时候块会无限的往下移动
https://github.com/jbaysoluti... 先撸一遍demo吧
&lt;template&gt; &lt;grid-layout :layout="layout" :auto-size="false" :col-num="20" :row-height="50" :max-rows="100" :is-draggable="true" :is-resizable="false" :vertical-compact="false" :margin="[10, 10]" :use-css-transforms="true" &gt; &lt;grid-item v-for="item in layout" :key="item.i" :x="item.x" :y="item.y" :w="item.w" :h="item.h" :i="item.i" @resize="resizeEvent" @move="moveEvent" @resized="resizedEvent" @moved="movedEvent" &gt; {{item.i}} &lt;/grid-item&gt; &lt;/grid-layout&gt; &lt;/template&gt; &lt;script&gt; import Vue from 'vue' import VueGridLayout from 'vue-grid-layout' Vue.use(VueGridLayout) var testLayout = [ {"x":0,"y":0,"w":1,"h":1,"i":"0"}, {"x":0,"y":1,"w":1,"h":1,"i":"1"}, {"x":0,"y":2,"w":1,"h":1,"i":"2"}, {"x":0,"y":3,"w":1,"h":1,"i":"3"}, {"x":1,"y":0,"w":1,"h":1,"i":"4"}, {"x":1,"y":1,"w":1,"h":1,"i":"5"}, {"x":1,"y":2,"w":1,"h":1,"i":"6"}, {"x":1,"y":3,"w":1,"h":1,"i":"7"}, {"x":2,"y":0,"w":1,"h":1,"i":"8"}, {"x":2,"y":1,"w":1,"h":1,"i":"9"}, {"x":2,"y":2,"w":1,"h":1,"i":"10"}, {"x":2,"y":3,"w":1,"h":1,"i":"11"}, {"x":3,"y":0,"w":1,"h":1,"i":"12"}, {"x":3,"y":1,"w":1,"h":1,"i":"13"}, {"x":3,"y":2,"w":1,"h":1,"i":"14"}, {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86b52e172c25c0ab351b5069ef721982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af78d888e621272d79b3248840db9a7/" rel="bookmark">
			五.shiro表单拦截器FormAuthenticationFilter如何认证,登录成功后如何继续访问原请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shiro有几种默认的拦截器，authc,anno,roles,user等 authc就是FormAuthenticationFilter的实例
ShiroFilterFactoryBean的配置：
private Map&lt;String, Filter&gt; filters; &lt;取名，拦截器地址&gt;,可以自定义拦截器放在这 private Map&lt;String, String&gt; filterChainDefinitionMap; &lt;url,拦截器名&gt;哪些路径会被此拦截器拦截到
public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) { ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.setSecurityManager(securityManager); shiroFilterFactoryBean.setLoginUrl("/login"); shiroFilterFactoryBean.setSuccessUrl("/index"); shiroFilterFactoryBean.setUnauthorizedUrl("/403"); // private Map&lt;String, Filter&gt; filters; shiro有一些默认的拦截器 比如auth，它就是FormAuthenticationFilter表单拦截器 &lt;取名，拦截器地址&gt;,可以自定义拦截器放在这 //private Map&lt;String, String&gt; filterChainDefinitionMap; &lt;url,拦截器名&gt;哪些路径会被此拦截器拦截到 // 拦截器. Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;(); // 配置不会被拦截的链接 顺序判断 filterChainDefinitionMap.put("/static/**", "anon"); filterChainDefinitionMap.put("/ajaxLogin", "anon"); filterChainDefinitionMap.put("/focus/userlogin", "anon"); filterChainDefinitionMap.put("/swagger-ui.html#", "anon"); // 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 // &lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问;user:remember me的可以访问--&gt; filterChainDefinitionMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9af78d888e621272d79b3248840db9a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6a86beb6e6e631d87308fa2825104c/" rel="bookmark">
			springboot &#43; shiro 简单实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文属于原创，说明简介，如果有问题，可留言一起探讨 1.搭建springboot项目，这里不做概述 2.引入shiro 依赖 &lt;!-- apache shiro 权限框架 --&gt; &lt; dependency &gt; &lt; groupId &gt; org.apache.shiro &lt;/ groupId &gt; &lt; artifactId &gt; shiro-spring &lt;/ artifactId &gt; &lt; version &gt; 1.4.0 &lt;/ version &gt; &lt;/ dependency &gt; 3.创建 ShiroRealm package wx.milk.web.controller.admin; import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.*; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.springframework.beans.factory.annotation. Autowired ; import org.springframework.stereotype. Component ; import wx.milk.service.admin.IUserService; import wx.milk.web.utils.SpringBeanFactoryUtils; import wx.query.Query; import wx.query.Statement; import wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6a86beb6e6e631d87308fa2825104c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae2542c0e1e182645a2e15e02857577/" rel="bookmark">
			对C#的控件的Width等属性进行修改无效的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果对控件的Width属性进行修改，但是修改没有生效，那么可以去看看这个控件的AutoSizeMode，将AutoSizeMode设置为GrowOnly或者其他，即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2073fe82ec657d625d8e98f47096e5db/" rel="bookmark">
			unity中实现城市夜晚汽车流水的效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里着重说明unity中怎么用代码控制纹理的偏移和平铺；偏移的纹理可以实现很多流动的效果，如本例中的车流水线……； using System.Collections; using System.Collections.Generic; using UnityEngine; public class roadFlow : MonoBehaviour { float roadChange,offset; // Use this for initialization void Start () { if (transform.name == "Road01"||transform.name=="Road04"||transform.name=="Road07") { offset = 1.3f; } if (transform.name == "Road02" || transform.name == "Road05" || transform.name == "Road08") { offset = 1.6f; } if (transform.name == "Road03" || transform.name == "Road06" || transform.name == "Road09") { offset = 1.9f; } } // Update is called once per frame void Update () { //得到纹理的x方向偏移 // offset = transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2073fe82ec657d625d8e98f47096e5db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6fe16361e81e7ce48191ed507f6b2ef/" rel="bookmark">
			JavaScript 格式化数字、金额、千分位、保留几位小数、舍入舍去…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端开发中经常会碰到用 JavaScript 格式化数字，最最常见的是格式化金额，一般格式化金额需要千分位分隔，保留2位小数等等。
简单的功能函数 类似的代码网上有很多：
JavaScript 代码:
/*** 将数值四舍五入(保留2位小数)后格式化成金额形式** @param num 数值(Number或者String)* @return 金额格式的字符串,如'1,234,567.45'* @type String*/function formatCurrency(num) {num = num.toString().replace(/\$|\,/g,'');if(isNaN(num))num = "0";sign = (num == (num = Math.abs(num)));num = Math.floor(num*100+0.50000000001);cents = num%100;num = Math.floor(num/100).toString();if(cents&lt;10)cents = "0" + cents;for (var i = 0; i &lt; Math.floor((num.length-(1+i))/3); i++)num = num.substring(0,num.length-(4*i+3))+','+num.substring(num.length-(4*i+3));return (((sign)?'':'-') + num + '.' + cents);} 或者
JavaScript 代码:
function fmoney(s, n) {/** 参数说明：* s：要格式化的数字* n：保留几位小数* */n = n &gt; 0 &amp;&amp; n &lt;= 20 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6fe16361e81e7ce48191ed507f6b2ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf3d115fc96992fb58045e8b4135996/" rel="bookmark">
			com.sun.mail.util.MailConnectException: Couldn&#39;t connect to host异常解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个接口项目，需要捕获所有的异常信息，并发送邮件给管理员。使用了JavaMail来实现，然后发现在本地（windows环境）上可以正常发送邮件，而放到了linux环境上就无法发送邮件。相关错误如下：
org.springframework.mail.MailSendException: Mail server connection failed; nested exception is com.sun.mail.util.MailConnectException: Couldn't connect to host, port: 220.181.15.111, 25; timeout -1; nested exception is: java.net.ConnectException: Connection timed out (Connection timed out). Failed messages: com.sun.mail.util.MailConnectException: Couldn't connect to host, port: 220.181.15.111, 25; timeout -1; nested exception is: java.net.ConnectException: Connection timed out (Connection timed out) at org.springframework.mail.javamail.JavaMailSenderImpl.doSend(JavaMailSenderImpl.java:446) ~[spring-context-support-5.0.6.RELEASE.jar:5.0.6.RELEASE] 重要信息Failed messages: com.sun.mail.util.MailConnectException: Couldn't connect to host和25。首先想到的是linux的端口25没有开通，遂联系相关人员开通，但是可能出于安全考虑没有同意开通。 没办法，只能更换端口了，需要对配置进行修改 原始配置
spring.mail.host=220.181.15.111 #smtp.126.com 的ip地址 spring.mail.username=邮箱 spring.mail.password=权限密码 spring.mail.default-encoding=UTF-8 修改为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf3d115fc96992fb58045e8b4135996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041eac0115f908978100c2110bea4eca/" rel="bookmark">
			微信公众号开发[该公众号提供的服务出现故障，请稍后再试]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能出现的原因：
标签的大小写。查看回复内容中代码是否标签大小写有问题。xml里面不能有空格，比如 &lt;Content&gt; &lt;! [CDATA[ 怎么] ]&gt; &lt;/Content&gt; 中间都不能有空格。
3.在进行视频回复的时候，出现此问题，可能是网络不好导致。所以换个视频容量小的再试，比如10秒以内的。 4.确定代码书写无误，比如返回的数据是否正确
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa193b4de82520a32fd79629f1ac1fef/" rel="bookmark">
			php 操作 amqp demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$mqConf = Config::getInstance()-&gt;getConf('rabbitmq'); //创建连接 $conn = new \AMQPConnection($mqConf);//连接 mq和channel if(!$conn-&gt;connect()){//连接成功返回true Helper::writeLog(null, 'rabbitmq', 'error', 'rabbitmq 连接失败', 'rabbitmq'); return false; } //创建channel $channel = new \AMQPChannel($conn); //创建交换机 $ex = new \AMQPExchange($channel); //设置名字 $ex-&gt;setName('CREDITS_EXCHANGE'); //设置DIRECT类型 $ex-&gt;setType(AMQP_EX_TYPE_DIRECT); //持久化 $ex-&gt;setFlags(AMQP_DURABLE); //声明创建一个ex $ex-&gt;declareExchange(); // 打印状态 //echo "exchange status:".$status . PHP_EOL; //发送消息 $flag = $ex-&gt;publish($message, 'worker'); if(!$flag){ Helper::writeLog(null, 'rabbitmq', 'error', 'rabbitmq 消息发送失败失败', $uid); } //关闭连接 $conn-&gt;disconnect();
如果希望绑定到队列 可执行以下代码
// 创建队列
$q = new AMQPQueue($channel);
$q-&gt;setName($q_name);
$q-&gt;setFlags(AMQP_DURABLE); //持久化 // $q-&gt;declareQueue(); // 同上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa193b4de82520a32fd79629f1ac1fef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e171b578e1a3065eacb583c2cab1fd6/" rel="bookmark">
			ehcache学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ehcache入门基础示例
https://blog.csdn.net/vbirdbest/article/details/72763048
http://www.ehcache.org/
https://blog.csdn.net/u014209975/article/details/53320395/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41adcebf8b634db0e44a6fb98be03aa0/" rel="bookmark">
			jquery中有两种绑定事件及移除事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //jquery中有两种绑定事件及移除事件
事件绑定 /* 1、eventName $("button").click(function(){ alert（‘click’） }) 部分事件不支持 2、on(ecentName,fn) $("button").on('click',function(){ alert（‘click’） }) 所有事件都支持 都可以绑定多个事件，不会覆盖 */ /* 事件移除 $("button").off() 如果不传参，会移除所有的事件 $("button").off('click') 如果传递一个，会移除相同类型的所有事件 $("button").off('click'，test) 如果传递两个，指定的事件 */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946c7abb68fd826bb61151f76d55093a/" rel="bookmark">
			ERROR [com.alibaba.druid.pool.DruidDataSource] abandon connection, owner thread:  已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2018-06-12 15:41:36 ERROR [com.alibaba.druid.pool.DruidDataSource] abandon connection, owner thread: http-nio-8080-exec-1, connected at : 1528789080759, open stackTrace
框架：spring4.3+hibernate5.0 ssh框架，有时候会抛出这个异常，找了挺多资料，终于发现问题 问题主要代码
&lt;!-- 运行程序，当连接超过3分钟后会强制进行回收，并输出异常日志。 此配置项会影响性能，只在排查的时候打开。系统运行时最好关闭。 --&gt; &lt;!-- start --&gt; &lt;!-- 超过时间限制是否回收 --&gt; &lt;!-- &lt;property name="removeAbandoned" value="true" /&gt; --&gt; &lt;!-- 超时时间；单位为秒。180秒=3分钟 --&gt; &lt;!-- &lt;property name="removeAbandonedTimeout" value="180" /&gt; --&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;!-- &lt;property name="logAbandoned" value="true" /&gt; --&gt; &lt;!-- end --&gt; 全部配置：
&lt;!-- 配置数据源 --&gt; &lt;bean name="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="${url}" /&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946c7abb68fd826bb61151f76d55093a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28fe31ac6d190bc168ec9bd57d69891/" rel="bookmark">
			解决java.lang.IllegalArgumentException: No converter found for return value of type: class java.util.A
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天使用SSM框架，用@ResponseBody注解，出现了这个问题
这是由于springmvc默认是没有对象转换为json的转换器的，需要我们配置其他转换器，在这里我用了阿里的fastJson
首先引入fastJson的jar包
然后在springmvc配置文件中配置
&lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="false"&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.xml.XmlAwareFormHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.ByteArrayHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.BufferedImageHttpMessageConverter"/&gt; &lt;!-- 配置Fastjson支持 --&gt; &lt;bean id="fastJsonHttpMessageConverter" class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 重启服务器后，在运行，问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/692159ea4e780ff27652403bfff06447/" rel="bookmark">
			ubuntu16.04查看CUDA和cuDNN版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cat /usr/local/cuda/version.txt
cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2
nvcc -V
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5e558e3a457beda8335a6a6a3415ce/" rel="bookmark">
			-xzvf的具体意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 x 解压 z gzip压缩格式 v 显示详细信息 f file. tar 的参数. man一下. tar zxvf 目标压缩包 z 将要解压的包压缩格式为 gzip格式 x 要执行的是解压动作（与压缩 c 相对) v 显示解压过程中的信息 f 代表file ,固定要带的.（也可以理解为有文件要创建——解压或者压缩一个包肯定有文件要创建) z gzip压缩格式 v 显示详细信息 f file. tar 的参数. man一下. tar zxvf 目标压缩包 z 将要解压的包压缩格式为 gzip格式 x 要执行的是解压动作（与压缩 c 相对) v 显示解压过程中的信息 f 代表file ,固定要带的.（也可以理解为有文件要创建——解压或者压缩一个包肯定有文件要创建) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cbd15504edf94052f598507080d5e12/" rel="bookmark">
			Map与Json之间的转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Map转化成JSON
package com.dbzhang.demo; import java.io.IOException; import java.util.HashMap; import java.util.Map; import com.fasterxml.jackson.core.JsonParseException; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JsonMappingException; import com.fasterxml.jackson.databind.ObjectMapper; public class Json2Map { /** * 该方法主要是用来将json字符串转化成map集合 * @param args * @throws IOException * @throws JsonMappingException * @throws JsonParseException */ public static void main(String[] args){ String json = "{\"name\":\"zdb\",\"age\":\"26\"}"; Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); ObjectMapper mapper = new ObjectMapper(); try { map = mapper.readValue(json, new TypeReference&lt;HashMap&lt;String, String&gt;&gt;() { }); System.out.println(map); } catch (JsonParseException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cbd15504edf94052f598507080d5e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773c6e6e684f2cb7510b5997254aee69/" rel="bookmark">
			JAVA  第五次实验：类的多态性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的：
理解类的多态性，掌握方法的继承、重载和覆盖，掌握如何从键盘输入数据以及多重循环的使用。
二、实验环境：
Windows下java SE。 三、实验内容：
（一）类的多态性练习
1． 理解类的多态性
类的继承发生在多个类之间，而类的多态只发生在同一个类上。在一个类中，可以定义多个同名的方法，只要确定它们的参数个数和类型不同。这种现象称为类的多态。
多态使程序简洁，为程序员带来很大便利。在OOP 中，当程序要实现多个相近的功能时，就给相应的方法起一个共同的名字，用不同的参数代表不同的功能。这样，在使用方法时不论传递什么参数，只要能被程序识别就可以得到确定的结果。
类的多态性体现在方法的重载（overload）上，包括成员方法和构造方法的重载。
2． 方法的重载 方法的重载是指对同名方法的不同使用方式。
1) 程序功能：对不同的数进行排序输出。在IntSort 类中定义2 个同名的方法sort。
2) 编写KY5_1.java 文件，源代码如下。
class IntSort { public String sort (int a, int b) { if (a&gt;b) return a+" "+b; else return b+" "+a; } public String sort (int a, int b, int c) { int swap; if (a&lt;b) { swap=a; a=b; b=swap; } if (a&lt;c) { swap=a; a=c; c=swap; } if (b&lt;c) { swap=b; b=c; c=swap; } return a+"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/773c6e6e684f2cb7510b5997254aee69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5af68e6f9f6b4b3fe915a48de1cc30/" rel="bookmark">
			Windows server 2008远程桌面会话主机和远程桌面授权（解决120天过期问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统环境
部署RemoteAPP是加入域控管理的，这样可以方便授权管理，域部署查看：https://blog.csdn.net/tladagio/article/details/80464833
二、远程桌面服务安装和配置
1、使用域管理员用户登录操作，要不等下安装会有问题。首先在添加角色向导勾选远程桌面服务
2、在角色服务勾选远程桌面会话主机和远程桌面授权
3、身份验证方法选择第二个，后面会提到使用别的方法对用户进行访问限制
4、授权模式，选择每用户，这里会看到使用时间是120天，所以等下需要激活
5、在用户组这里先添加域控制器里面的Domain Users组，作用是只要是域用户都可以访问
6、如果不使用域管理员用户登录操作，这里就会报错。安装路径根据实际情况修改，这里默认
7、确认安装
8、安装完重启
三、远程桌面授权服务激活
1、打开RD授权管理器，右键点击激活服务器
2、连接方法选择：Web浏览器
3、点击打开远程桌面授权网站
4、选择中文
5、输入ID，公司名称任意，选择国家
6、下一步
7、记住红色框ID
8、许可证程序选择：企业协议
9、数量任意，协议号可以输入图中的，也可以上网查找
10、确认无误，下一步
11、记住红色框ID，激活结束。
12、回到服务器激活向导，输入刚才红色框的ID：VF2V2-PP67R-PH2XY-J9Y3J-WKT23-W743J-8339W
13、勾选立即启动许可证安装向导
14、然后再输入刚才的ID：G27CP-9KXBF-QMKHJ-6MB62-HC9BG-6F4WK-HJPRP ，这里跳过去的就不截图了
15、激活成功
16、查看确认
四、远程桌面的连接数
1、一般远程桌面只能两个用户同时登陆，但是配置以上设置之后就没有限制了
2、默认同一个用户不能同时打开两个相同远程桌面，但是开启如下设置就可以同时登陆了
3、查看确认
五、授权不同用户访问相同或不同的.rdp远程桌面连接
1、创建一个共享文件夹
2、打开RemoteApp管理器，点击添加RemoteApp程序
3、勾选这台服务器已经安装好的程序发布，这里以计算机为例。另外已经安装没有显示出来的可以通过浏览程序安装目录添加
4、点击完成
5、创建.rdp文件
6、下一步
7、保存到刚才创建好的共享文件夹，另外端口根据实际情况修改，防火墙也放通对应端口出入，这里为了方便关闭了防火墙。
8、完成
9、客户端连接
10、使用创建好的普通域用户访问
11、发布的计算机客户端就可以使用了
12、可以对发布的程序右键属性里面设置用户分配，可以指定哪些域用户可以访问，没有指定的默认就拒绝了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb5307462bddc46c4e2dc2ac3a738c2/" rel="bookmark">
			AndroidStudio与安卓手机链接调试（USB数据线链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓手机，苹果就放弃吧！ ============ 今日更新文章 2020年1月6日 =============
打开你手机上的开发者选项，打开USB调试，如果有允许USB安装（允许通过USB安装应用），打开。即可看到弹窗请求
确定即可！就可以真机测试了！
以下是很早之前写的！！！！！
==================================================================
1.设置手机
打开开发者选项
设置手机为允许USB调试（每个型号的手机百度有，自行解决）
2.数据线与电脑连接
3.打开AndroidStudio,等待程序加载完毕，之后点击箭头所指地方
4.打开后如图，点击 EditConfigurations,进入下一步
5.按下图进行设置选中USB Device
6.接下来运行你的程序即可，部分手机运行后此时弹出USB调试手机的授权，点击允许即可，等待运行
7.如果运行报错没有找到设备，那就重启软件一下，检查手机是否设置为管理手机文件，有些手机有好多USB选项（仅充电、管理照片，照片备份，管理设备文件等选项），选中管理设备文件
检查是否选中的事管理设备文件的方法:
手机与电脑通过数据线连接
打开此电脑（快捷键Windows+E），检查是否有自己的手机
如果有手机检查是否可以管理文件，比如、删除文件、创建文件夹等
如果可以删除创建，说明已经成果打开管理设备文件这一选项
重新启动AndroidStudio，点击运行
还有一种方法：无线调试&lt;-点击进入
如果对此帖有疑问，欢迎下方评论留言！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ed9e9d7fa3fb2132c933aceb2450d20/" rel="bookmark">
			关于多线程的常问面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 什么是线程？
线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。
2、线程和进程有什么区别？
1）线程是进程的子集，一个进程至少有1个线程，每条线程并行执行不同的任务。
2）不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。
3）每个线程都拥有单独的栈内存用来存储本地数据。
3、 如何在Java中实现线程？
通常80%的回答是两种方式，继承Thread 类和实现Runnable接口，但如果要加分的话，答出实现Callable接口以及使用线程池，所以面试的最好回答是答出这4种方式。
4、用Runnable还是Thread？
用实现Runnable接口要比继承Thread好：
1）适合多个线程共享同一资源
2）避免单继承的局限性
3）将线程任务与线程对象进行分离，解耦，增加程序的健壮性 4）线程池中 只能使用Runnable Callable
5、Thread 类中的start() 和 run() 方法有什么区别？
start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。
6、Java中Runnable和Callable有什么不同？
Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。
7、Java中的volatile 变量是什么？
volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生。
8、什么是线程安全？Vector是一个线程安全类吗？ 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。
9、Java中如何停止一个线程？
Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。
10、如何在两个线程间共享数据？
1）如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如，卖票系统就可以这么做。
2）如果每个线程执行的代码不同，这时候需要用不同的Runnable对象，例如，设计4个线程。其中两个线程每次对j增加1，另外两个线程对j每次减1，银行存取款
有两种方法来解决此类问题：
将共享数据封装成另外一个对象，然后将这个对象逐一传递给各个Runnable对象，每个线程对共享数据的操作方法也分配到那个对象身上完成，这样容易实现针对数据进行各个操作的互斥和通信
将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法
11、Java中notify 和 notifyAll有什么区别？
notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。
12、为什么wait, notify 和 notifyAll这些方法不在thread类里面？
回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。
13、什么是ThreadLocal变量？
ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。
14、什么是FutureTask？
在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。
15、 为什么wait和notify方法要在同步块中调用？
主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ed9e9d7fa3fb2132c933aceb2450d20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f3319cbb3db9e14f8c5839d366375e1/" rel="bookmark">
			ajax传递knockout对象的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际应用中我们将各个文本框用ko进行了绑定之后，此时用户填好各个文本框的值之后，就需要提交表单了，以前，我们获取各个文本框的值用的是Jquery的val()方法，例如，我们要获取用户名的值，则这样获取：var UserName=$("#UserName").val()
,但用到了knockout对各个文本框进行了绑定之后，则可以这样传值：
前端代码：
@{ ViewBag.Title = "Index"; } &lt;h2&gt;Index&lt;/h2&gt; &lt;head&gt; &lt;script src="~/Scripts/Knockout.js"&gt;&lt;/script&gt; &lt;script src="~/Scripts/knockout-map.js"&gt;&lt;/script&gt; &lt;script src="~/Scripts/jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;script src="~/Scripts/jquery.json.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () { var ViewMode={}; ViewMode =function () { this.UserName = ko.observable("张三"); this.Age = ko.observable("21"); }; ko.applyBindings(ViewMode); var Model = new ViewMode(); var temp = ko.mapping.toJS(Model);// ko.mapping.toJS：将ko对象转换为JS对象 var Json = $.toJSON(temp);//将JS对象序列化为JS字符串 $("#btn1").click(function () { $.ajax( { url: "/Test/Create", data: { "param": Json }, ansyc: true, type: "post", datatype: "json", success: function (data) { } }); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 姓名：&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f3319cbb3db9e14f8c5839d366375e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991fb8c54e13afa0e9298313e3600787/" rel="bookmark">
			eBPF 简史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近总能看到bpf，但苦于找不到合适的资料理解，终于找到一个分析讲解较全面的文章，分享给大家，原网址如下： http://www.linux-ren.org/tech/2230.mhtml https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html
数日之前，笔者参加某一技术会议之时，为人所安利了一款开源项目，演讲者对其性能颇为称道，称其乃基于近年在内核中炙手可热的 eBPF 技术。 – 张亦鸣
本文导航
◈ 源头：一篇 1992 年的论文 01%
◈ Pseudo Machine Language 08%
◈ LSF: Linux 下的 BPF 实现 27%
◈ 演进：JIT For BPF 37%
◈ 进化：extended BPF 42%
◈ 再见了汇编 52%
◈ BPF 程序的类别以及 Map 机制 58%
◈ 新的指令集 73%
◈ In-kernel Verifier 80%
◈ Overview: eBPF 的架构 86%
◈ 追求极简：BPF Compiler Collection（BCC） 87%
◈ 结束语 95%
◈ 参考资源 96%
对这 eBPF 的名号，笔者略有些耳熟，会后遂一番搜索学习，发现 eBPF 果然源于早年间的成型于 BSD 之上的传统技术 BPF（Berkeley Packet Filter），但无论其性能还是功能已然都不是 BPF 可以比拟的了，慨叹长江后浪推前浪，前浪死在沙滩上之余，笔者也发现国内相关文献匮乏，导致 eBPF 尚不为大众所知，遂撰此文，记录近日所得，希冀可以为广大读者打开新世界的大门。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/991fb8c54e13afa0e9298313e3600787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26f64acd81d1e2c3486df44366c38d2/" rel="bookmark">
			java-try-catch对性能的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package cn.qiweiwei.trycatch; /** * @author 作者：qiww * @createDate 创建时间：2018年6月11日 上午8:45:14 */ public class TryCatchTest { public static void main(String[] args) { int[] ss = new int[100000000]; long startTime; long endTime; startTime = System.currentTimeMillis(); for (int j = 0; j &lt; ss.length; j++) { ss[j] = ss[j] + 1; ss[j] = ss[j] - 1; } endTime = System.currentTimeMillis(); System.out.println("无try-catch：程序运行时间：" + (endTime - startTime) + "ms"); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; ss.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f26f64acd81d1e2c3486df44366c38d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f5d5dc0a4393a7c3b8e8249a55ac01b/" rel="bookmark">
			Linux系统部署LAMP的详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lamp的搭建对于初学者是一件困难的事情，但是不用慌。此教程，手把手的教你如何快速搭建linux+apache+mysql+php的方法，希望能帮到你。
一、首先，搭建一个稳定的LAMP的环境，需要确保你Centos虚拟机能连通网。自己可以自行测试一些。在虚拟机里边ping一下，要是出现和我下图一样的，说明网络已经调通了。
如果出现的效果与我上图不一致，可以试试我这种方法。在Centos，选择设置-》网络-》网路地址转换，然后再ping一下。
没什么意外，应该是可以了。
接下来，我教你们Apache、PHP、MySQL。
下面开始我们搭建LAMP的步骤吧 1、安装虚拟机(最好选用桥接模式，看自己的需要吧)
2、安装CentOS7(在root权限下开始下面的安装)
二、安装Apache a).安装httpd yum -y install httpd b).启动httpd服务 systemctl start httpd.service c).设置开机启动 systemctl enable httpd.service d).验证 httpd是否安装成功 http://www.mixuejm.cn
使用 ip addr 查看虚拟机的ip地址 然后去本机的浏览器上访问自己的ip 发现访问是不成功的, 不用担心，我们把防火墙配置一下就可以了 要让外网能都访问到apache的主目录，执行以下命令: firewall-cmd --zone=public --add-service=http --permanent firewall-cmd --zone=public --add-service=https --permanent firewall-cmd --reload
也可以输入命令查看Apache的安装情况：
httpd -v
三、安装PHP a) 安装 yum -y install php b) 重启apache服务 systemctl restart httpd.service
c) 然后我们写一个简单的php文件在浏览器中访问一下 touch /var/www/html/phpinfo.php vi /var/www/html/phpinfo.php
按 a或i进入插入模式 &lt;?php phpinfo(); ?&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f5d5dc0a4393a7c3b8e8249a55ac01b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcca835122fa3a06e98c23aad010a6dd/" rel="bookmark">
			python之selenium的坑总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		+update 2020-02-11
最近锁王唐唐很厉害啊，甚是迷恋，鄙人观望了小呆的微博已经两天了，路转粉，绝对铁粉，闲来无事，我要开始分析wuli唐唐了。爬取了小呆的新浪微博，赞帖，帖子内容，发帖时间，转发数，评论数，点赞数。其中，不乏入坑无数，然而，都一一克服了，不得不说，这就是小呆的力量。
1. 模拟人类自动登录记住cookie 1.1 捕获当前所有窗口 在这里，不得不说，新浪微博的爬取并非易事。
首先，进入"https://weibo.com/”的登录页面，自动化介入，点击“登录”的同时，网页跳转了，此时，需要捕捉当前所有窗口。
handles = browser.window_handles #获取当前打开的所有窗口的句柄 1.2 页面跳转/窗口切换 捕获全部窗口，锁定当前窗口。
browser.switch_to.window(handles[1]) #切换到第二个窗口的句柄 print(browser.current_window_handle) print(browser.current_url) 1.3 iframe窗口解决自动登录 经过无数次xpath的元素定位查找，总是出现NoSuchElementException，并未能解决，经过查阅大量资料，无意中发现iframe类型，查看原码，发现该登陆窗口是iframe形式，大喜！
browser.implicitly_wait(5) #先找到到iframe（id ） browser.switch_to_frame("ptlogin_iframe") browser.find_element_by_xpath('//*[@id="qlogin_list"]/a[1]').click() 定位并点击进行登陆，需要说明，这里我是通过扣扣注册的新浪微博，同时需要把扣扣登陆上。
1.4 搜索框自动搜索 定位并点击搜索，接下来就是一些列的自动click，直到进入目标任务的主页。
browser.implicitly_wait(5) search = browser.find_element_by_xpath('//*[@id="plc_top"]/div/div/div[2]/input').send_keys("唐禹哲") browser.find_element_by_xpath('//*[@id="plc_top"]/div/div/div[2]/a').click() 需要保留cookie的保留，下次直接cookie就可以。
同时，在爬取过程中，页面加载可能需要时间，此时，需要设置等待时间。
2. 异步加载 新浪微博的页面比较特殊，需要大概三次拖拽方可将第一页加载完全，其他页也是一样，找了很多selenium异步加载的文章都未能解决问题，直到遇到下面的解决方案。何为异步加载，当滑到底部，页面出现待加载的内容。
time.sleep(10) def selenuim_loading_more(browser, method_index=0): if method_index==0: browser.implicitly_wait(3) # 为了快速滑动，先设置超时时间为3秒 # while True: for i in range(1, 4): # at most 3 times print("loading more, window.scrollTo bettom for the"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcca835122fa3a06e98c23aad010a6dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120b675e223f17c9420eb67fd5256df3/" rel="bookmark">
			使用git merge --squash，让commit变得优雅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文需要3分钟
情景模拟 我们有三个分支，master，develop以及feature特性分支，假定我们开发时使用的是feature分支，我们来这里查看提交记录
当然，使用IDEA内置的 Version Control（默认快捷键 alt + 9） 也能看到
However，我只是想写一句话却commit了3次，就如同为了完成一个功能但是完善了很多地方（bug，逃。。），
如果你不想在合并分支时体现你多次commit记录的话，下面正是你想要找的东西
步骤 切换分支前，请输入 git status，确保你开发分支是都已commit的
输入 git checkout branch_name，切换到你要合并的分支，并拉取最新的代码
例：希望将分支 feature-1.0.0 的代码合并到 master（实际操作一般还有预发布分支，这里简化）
git三连：合并，提交，推送
git merge --squash feature-1.0.0，注意：squash前面是两个短杠
git commit -m '修复了xxx'
git push origin master，注意：推到GitHub则需要登陆一下
验收 输入 git log ，可以看到简洁的提交记录，log不再凌乱
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ddc6fc661cbec22f0a34dc59bbbf24d/" rel="bookmark">
			https 单向认证和双向认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自 https 单向认证和双向认证
一、Http HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。
使用TCP端口为：80
二、Https Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。
使用TCP端口默认为443
三、SSL协议加密方式 SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。
对称加密 速度高，可加密内容较大，用来加密会话过程中的消息
公钥加密 加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥
四、单向认证 Https在建立Socket连接之前，需要进行握手，具体过程如下：
1、客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。
2、服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书
3、客户端使用服务端返回的信息验证服务器的合法性，包括：
证书是否过期
发型服务器证书的CA是否可靠
返回的公钥是否能正确解开返回证书中的数字签名
服务器证书上的域名是否和服务器的实际域名相匹配
验证通过后，将继续进行通信，否则，终止通信
4、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择
5、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。
6、服务器将选择好的加密方案通过明文方式返回给客户端
7、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器
8、服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。
五、双向认证 双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：
1、客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。
2、服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书
3、客户端使用服务端返回的信息验证服务器的合法性，包括：
证书是否过期
发型服务器证书的CA是否可靠
返回的公钥是否能正确解开返回证书中的数字签名
服务器证书上的域名是否和服务器的实际域名相匹配
验证通过后，将继续进行通信，否则，终止通信
4、服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端
5、验证客户端的证书，通过验证后，会获得客户端的公钥
6、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择
7、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式
8、将加密方案通过使用之前获取到的公钥进行加密，返回给客户端
9、客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端
10、服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d2633ea6a537b58f9affcfd430511c/" rel="bookmark">
			在Intellij IDEA中使用Debug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Debug用来追踪代码的运行流程，通常在程序运行过程中出现异常，启用Debug模式可以分析定位异常发生的位置，以及在运行过程中参数的变化。通常我们也可以启用Debug模式来跟踪代码的运行流程去学习三方框架的源码。
所以学习下如何在Intellij IDEA中使用好Debug，主要包括如下内容：
Debug开篇
基本用法&amp;快捷键
变量查看
计算表达式
智能步入
断点条件设置
多线程调试
回退断点
中断Debug
附：JRebel激活
一、Debug开篇
首先看下IDEA中Debug模式下的界面。如下是在IDEA中启动Debug模式，进入断点后的界面，我这里是Windows，可能和Mac的图标等会有些不一样。就简单说下图中标注的8个地方：
以Debug模式启动服务，左边的一个按钮则是以Run模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。
断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点，断点行的颜色可自己去设置。
Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置，如图1.2。
调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。在菜单栏Run里可以找到同样的对应的功能，如图1.4。
服务按钮：可以在这里关闭/启动服务，设置断点等。
方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。
Variables：在变量区可以查看当前断点之前的当前方法内的变量。
Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 [图1.1]
[图1.2]：在设置里勾选Show debug window on breakpoint，则请求进入到断点后自动激活Debug窗口
[图1.3]：如果你的IDEA底部没有显示工具栏或状态栏，可以在View里打开，显示出工具栏会方便我们使用。可以自己去尝试下这四个选项。
[图1.4]：在菜单栏Run里有调试对应的功能，同时可以查看对应的快捷键。
二、基本用法&amp;快捷键
Debug调试的功能主要对应着图一中4和5两组按钮：
1、首先说第一组按钮，共8个按钮，从左到右依次如下：
[图2.1]
Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。
Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。
Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。
Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。
Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。
Drop Frame (默认无)：回退断点，后面章节详细说明。
Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37d2633ea6a537b58f9affcfd430511c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798e470e7ef303f1fce3db356beafe54/" rel="bookmark">
			python爬虫工具安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 re与urllib re与urllib模块一般python自带
requests模块安装 pip install requests selenium 有些网站是js渲染的，需要借助浏览器加载，在此需要安装selenium
pip install selenium chromedrive 还需要安装chrome浏览器以及浏览器对应的chromedrive
安装成功测试：
from selenium import webdriver driver = webdriver.Chrome() driver.get("https://weibo.com/p/1004061634785555/home?is_search=0&amp;visible=0&amp;is_all=1&amp;is_tag=0&amp;profile_ftype=1&amp;page=1#feedtop") phantomjs 可以看出以上需要打开一个网页，也可以使用phantomjs，运行时不需要打开网了，即可在后台运行。
from selenium import webdriver driver = webdriver.PhantomJS() driver.get("baidu.com") 也不得不说PhantomJS里面的坑很多，要想轻松点，上一个选择就可以了。
lxml 提供xpath的高效解析方式
pip install lxml beautifulsoup4 beautifulsoup4也是一个网页解析库,使用方便，依赖xlml，安装之前先安装lxml。
pip install beautifulsoup4 调用方式
from bs4 import BeautifulSoup soup = BeautifulSoup('&lt;html&gt;&lt;/html&gt;','lxml') # 使用xlml解析 pyquery 网页解析库，相对bs4是要方便的，语法跟jQuery是相似的。
from pyquery import PyQuery as pq doc = pq("&lt;html&gt;hello&lt;/html&gt;") result = doc("html").text() result # 'hello' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a93a5a68246f8721546c42ea0a27cc/" rel="bookmark">
			在线图床工具的使用 https://sm.ms/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先附上 网站的链接：https://sm.ms/
转载于:https://www.cnblogs.com/yuanhailiang/p/9159002.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b499068f5a0610437d890a5662e56dc1/" rel="bookmark">
			SpringBoot___自定义消息转换器、MVC配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 自动配置的消息转换器 在SptingBoot的源码中的spring-boot-autoconfig的Jar包下，我们可以找到org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration.class文件，这个类就是自动配置消息转换器：
@Configuration @ConditionalOnClass(HttpMessageConverter.class) @AutoConfigureAfter({GsonAutoConfiguration.class, JacksonAutoConfiguration.class}) @Improt({JacksonHttpMessageConvertersConfiguration.class, GsonHttpMessageConvertersConfiguration.class}) public class HttpMessageConverterAutoConfiguration{ static final String PREFERRED_MAPPER_PROPERTY = "spring.http.converters.preferred-json-mapper"; private final List&lt;HttpMessageConverter&lt;?&gt;&gt; converters; } 在这个类中定义了一个String类的转换器，其源码如下：
@Configuration @ConditionalOnClass(StringHttpMessageConverter.class) @EnableConfigurationProperties(HttpEncodingProperties.class) protected static class StringHttpMessageConverterConfiguration{ private final HttpEncodingProperties encodingProperties; protected StringHttpMessageConverterConfiguration( HttpEncodingProperties encodingProperties){ this.encodingProperties = encodingProperties; } @Bean @ConfigurationOnMissingBean public StringHttpMessageConverter StringHttpMessageConverter(){ StringHttpMessageConverter converter = new StringHttpMessageConverter( this.encodingProperties.getCharset()); converter.setWriterAccpetCharset(false); return converter; } } 注意：在默认的消息转换器中，使用的编码为UTF-8。
2. 自定义消息转换器 自定义消息换换器，我们只需要在配置类@Configuration的类中添加消息转换器的@Bean加入spring容器，就会被SpringBoot自动加入到容器中。 例如：
@Bean public StringHttpMessageConverter stringHttpMessageConverter(){ StringHttpMessageConverter converter = new StringHttpMessageConverter( Charset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b499068f5a0610437d890a5662e56dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2206415b4fa7158b4f12d53563d4e151/" rel="bookmark">
			SpringBoot___web开发自动配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web开发的自动配置类为：org.springframework.boot.autoconfigure 1. web自动配置解析 SpringBoot项目的web开发的自动配置位置如下： 然后寻找 2. 自动配置的ViewResolver（视图解析器） 我们都知道在使用Spring的过程中都离不开解析器，而最后返回的视图是根据视图解析器来操作的。而SpringBoot的web开发的自动配置中，肯定会有一个默认的视图解析器。我们来看下源码：
@Bean @ConditionalOnMissingBean public InternalResourceViewResolver defaultViewResolver(){ InternalResourceResolverViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(this.mvcProperties.getView().getPrefix()); resolver.setPrefix(this.mvcProperties.getView().getSuffix()); return resolver; } @Bean @ConditionalOnBean(View.class) @ConditionalOnMissingBean public BeanNameViewResolver beanNameViewResolver(){ BeanNameViewResolver resolver = new BeanNameViewResolver(); resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10); return resolver; } 3. 自动配置的View（视图） 上面代码中默认的视图解析器ViewResolver会返回一个视图View。我们来看下这个视图的定义，其位置在org.springframework.boot.autoconfigure.web.WebMvcProperties.View。 其代码如下：
public static class View{ //视图前缀 private String prefix; //视图后缀 private String suffix; public String getPrefix() { return this.prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2206415b4fa7158b4f12d53563d4e151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec106bf1608ac928c6d1f91ce793b9e/" rel="bookmark">
			阻塞队列LinkedBlockingDeque与LinkedBlockingQueue（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述： 声明：本文转载为转载文章，原出处为：
Java并发学习(二十三)-LinkedBlockingQueue和LinkedBlockingDeque分析
LinkedBlockingDeque是基于链表的、线程安全的双端阻塞队列。LinkedBlockingQueue是基于链表的先进先出的阻塞队列。
特点：
链表结构（动态数组）通过ReentrantLock实现锁利用Condition实现队列的阻塞等待，唤醒LinkedBlockingQueue 这是一个先进先出的队列，通过ReentrantLock和两个Condition来实现并发安全与阻塞。它的结构基本字段如下：
/** * 基于链表。 * FIFO * 单向 *最大容量是Integer.MAX_VALUE. */ public class LinkedBlockingQueueAnalysis&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable { /* * 两个方向。 * putLock * takeLock * 有些操作会需要同时获取两把锁。 * 例如remove操作，也需要获取两把锁 */ //主要的node节点 static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node(E x) { item = x; } } //容量，一开始就固定了的。 private final int capacity; //用AtomicInteger 来记录数量。 private final AtomicInteger count = new AtomicInteger(); //head节点 head.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ec106bf1608ac928c6d1f91ce793b9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f170e5e1a566a8d23406fb9fc73962/" rel="bookmark">
			es6-algorithm 之 Fibonacci 尾调用优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天无意中翻到闰土大叔的一篇推文，关于面试题斐波拉契数列，求第n项的值，如第1000位。 首先它的特征长这样： 1,2,3,5,8,13,21,34… 常见的方案是这样的：
const f = (n) =&gt; { if(n === 0) return 0; if(n === 1) return 1; return f(n - 1) + f(n -2); } 聪明的你肯定能第一时间写出递归形式的解法。我们测一下性能：
console.time('fibonacci') const f = (n) =&gt; { if(n === 0) return 0; if(n === 1) return 1; return f(n - 1) + f(n -2); } f(40) // 165580141 console.timeEnd('fibonacci') 发现计算 f(40) 即斐波拉契的第40个数，得到 fibonacci: 8574.739013671875ms 花了8574ms，如果计算 f(50)，等了很久，调用栈溢出，浏览器崩溃。~ 如果面试官让你算出第1000个数呢，岂不是gg。所以面试者如果答成这样，可能很难通过的，就算你写出非递归等其它写法，也悬。 很明显，这个题目虽然简单，但人家考察你的可能是对新技术的追求 es6(不能说新了)…
如何优化 这个题，要运用到es6的尾调用和默认参数了。先上代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f170e5e1a566a8d23406fb9fc73962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/829f4942457749b0e4973e44f4ec7409/" rel="bookmark">
			js解析Dicom文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小伙伴 : 当你看到这篇博客的时候,你的问题将全部迎刃而解.
1.如何在自己的vue项目中展示Dicom文件,
2.js如何解析Dicom文件
3.前端如何显示Dicom
这些问题也困扰我很长时间,不过都是小事,没有你著哥解决不了的技术问题so easy! 推荐另外一篇文章: cornerstone.js解析Dicom图像并显示 下面分享干货 JavaScript Dicom Parsing ...
方法一: 在 vue 中呈现 dicom 图像( Dicom Viewer )
1.按照 README.md 文件里的做 三分钟就能本地跑起来
2.注意 : 在 dwv.vue 中 要格外 注意代码格式 尤其 分号和空格
方法二: JavaScript 解析 Dicom 呈现在 web 浏览器( Dicom Parsing )
基于 cornerstone.js 实现 这个 类似于一个 Demo 没有多余的功能,仅显示 Dicom文件,附带简单交互, 缩放位移等等
1.按照 README.md 文件里的做一切都会OK的
方法三: JavaScript 解析 Dicom 呈现在 web 浏览器 ( Interactive Medical Images )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/829f4942457749b0e4973e44f4ec7409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/054b780874bfd0979e8b970059acfdd5/" rel="bookmark">
			bcftools将vcf生成bgzip和index格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用bcftools软件将vcf格式生成gz格式和index格式，需要用到“-Oz”和“index”命令，具体如下：
/bcftools-1.8/bin/bcftools view ExAC.vcf -Oz -o ExAC.vcf.gz /bcftools-1.8/bin/bcftools index ExAC.vcf.gz 转载于:https://www.cnblogs.com/chenwenyan/p/9151672.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a40c9237e77bbb8831a4181418dc08/" rel="bookmark">
			bibliographystyle{plain} %这行命令不能少，不然会出错：I found no bibstyle command---while
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BibTeX使用介绍 Posted on 2008-05-07 by BibTeX 是一种格式和一个程序, 用于协调LaTeX的参考文献处理.
BibTeX 使用数据库的的方式来管理参考文献. BibTeX 文件的后缀名为 .bib . 先来看一个例子
@article{name1,
author = {作者, 多个作者用 and 连接},
title = {标题},
journal = {期刊名},
volume = {卷20},
number = {页码},
year = {年份},
abstract = {摘要, 这个主要是引用的时候自己参考的, 这一行不是必须的}
}
@book{name2,
author ="作者",
year="年份2008",
title="书名",
publisher ="出版社名称"
}
说明:
第一行@article 告诉 BibTeX 这是一个文章类型的参考文献. 还有其它格式, 例如 article, book, booklet, conference, inbook, incollection, inproceedings, manual, misc, mastersthesis, phdthesis, proceedings, techreport, unpublished 等等.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36a40c9237e77bbb8831a4181418dc08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6742d6fb6245b1a0e04663b924931aac/" rel="bookmark">
			IntelliJ idea 主题包下载以及安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IntelliJ idea默认的主体只有简单的白和灰，不一定能满足所有人的喜好，所以想要下载一些其它不错的主题包；
主题下载地址 ；（已失效）
那还是去他们的网站主题栏目下吧 https://plugins.jetbrains.com/search?tags=Theme
部分截图；
选择自己喜欢的主题下载，个人还是比较喜欢Sublime Text 2主题，下载好之后，随意放个找得到的位置（还是放在安装目录下面吧，是个整体嘛），是个jar包。
安装：
file –&gt; import setttings –&gt; 找到你下载的主题包 —确认完之后，重启idea ,
重启之后主题就应用了，默认的字体12，很小，可以重新设置字体
file –&gt; setttings –&gt; Editor –&gt; Color Scheme –&gt; Color Scheme Font –&gt; 给你需要的主题设置字体大小间距；
注：idea版本 IntelliJ IDEA 2018.1.4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c7c676310a4a1dc45c6941727adfc6/" rel="bookmark">
			MPP(大规模并行处理)简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 什么是MPP？
MPP (Massively Parallel Processing)，即大规模并行处理，在数据库非共享集群中，每个节点都有独立的磁盘存储系统和内存系统，业务数据根据数据库模型和应用特点划分到各个节点上，每台数据节点通过专用网络或者商业通用网络互相连接，彼此协同计算，作为整体提供数据库服务。非共享数据库集群有完全的可伸缩性、高可用、高性能、优秀的性价比、资源共享等优势。
简单来说，MPP是将任务并行的分散到多个服务器和节点上，在每个节点上计算完成后，将各自部分的结果汇总在一起得到最终的结果(与Hadoop相似)。
2、MPP(大规模并行处理)架构 (MPP架构)
3、 MPP架构特征
● 任务并行执行;
● 数据分布式存储(本地化);
● 分布式计算;
● 私有资源;
● 横向扩展;
● Shared Nothing架构。
4、 MPP服务器架构
它由多个SMP服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个SMP服务器(每个SMP服务器称节点)通过节点互联网络连接而成，每个节点只访问自己的本地资源(内存、存储等)，是一种完全无共享(Share Nothing)结构，因而扩展能力最好，理论上其扩展无限制。
5、MPPDB
MPPDB是一款 Shared Nothing 架构的分布式并行结构化数据库集群，具备高性能、高可用、高扩展特性，可以为超大规模数据管理提供高性价比的通用计算平台，并广泛地用于支撑各类数据仓库系统、BI 系统和决策支持系统
6、MPPDB架构
MPP 采用完全并行的MPP + Shared Nothing 的分布式扁平架构，这种架构中的每一个节点（node）都是独立的、自给的、节点之间对等，而且整个系统中不存在单点瓶颈，具有非常强的扩展性。
MPPDB架构
7、 MPPDB特征
MPP 具备以下技术特征：
1) 低硬件成本：完全使用 x86 架构的 PC Server，不需要昂贵的 Unix 服务器和磁盘阵列； 2) 集群架构与部署：完全并行的 MPP + Shared Nothing 的分布式架构，采用 Non-Master 部署，节点对等的扁平结构；
3) 海量数据分布压缩存储：可处理 PB 级别以上的结构化数据，采用 hash分布、random 存储策略进行数据存储；同时采用先进的压缩算法，减少存储数据所需的空间，可以将所用空间减少 1~20 倍，并相应地提高 I/O 性能； 4) 数据加载高效性：基于策略的数据加载模式，集群整体加载速度可达2TB/h； 5) 高扩展、高可靠：支持集群节点的扩容和缩容，支持全量、增量的备份/恢复; 6) 高可用、易维护：数据通过副本提供冗余保护，自动故障探测和管理，自动同步元数据和业务数据。提供图形化工具，以简化管理员对数据库的管理工作；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c7c676310a4a1dc45c6941727adfc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6e808879497fbef2f0bcde326bb724/" rel="bookmark">
			JSTL fmt:formatNumber日期、 数字、货币格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSTL fmt:formatNumber日期、 数字、货币格式化 使用&lt;fmt&gt;标签应先导入
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
其uri可在fmt.tld文件下
1. 日期格式化 &lt;fmt:formatDate value=“${XXX.date}” pattern=“yyyy-MM-dd HH:mm:ss”/&gt;
value:要格式化的日期
pattern:日期格式化的格式
2 数字格式化 &lt;fmt:formatNumber value="12" type="currency" pattern="＄.00"/&gt; －－ ＄12.00
&lt;fmt:formatNumber value="12" type="currency" pattern="＄.0#"/&gt; －－ ＄12.0
&lt;fmt:formatNumber value="1234567890" type="currency"/&gt; －－ ＄1,234,567,890.00(那个货币的符号和当前web服务器的 local 设定有关)
&lt;fmt:formatNumber value="123456.7891" pattern="#,#00.0#"/&gt; －－ 123,456.79
&lt;fmt:formatNumber value="123456.7" pattern="#,#00.0#"/&gt; －－ 123,456.7
&lt;fmt:formatNumber value="123456.7" pattern="#,#00.00#"/&gt; －－ 123,456.70
&lt;fmt:formatNumber value="12" type="percent" /&gt; -- 1,200% (type 可以是currency、 number、 和percent)
java格式化输出：
DecimalFormat df = new DecimalFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd6e808879497fbef2f0bcde326bb724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e1cb13d42e190b3e65b1a49b832542/" rel="bookmark">
			waiting for changelog lock.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 解决方案：
一般情况下是因为数据库重构工liquibase被锁，可以按照以下方式解决
数据库执行：
USE databaseName
SELECT * FROM DATABASECHANGELOGLOCK
查出的数据中有一条数据的locked的值是1，说明database被锁了，删除该条数据，或者更新该条数据：LOCKED=0，LOCKGRANTED=null,LOCKEDBY=null
***如果按照上述方式执行以后还出现相同的问题，那就说明是相关映射出了问题，请仔细检查项目中关于DAO层映射(尤其是方法中)，删除错误的映射之后即可正常运行
转载于:https://my.oschina.net/u/3717025/blog/1825707
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464cd6c9bd14eb137e60a5a29cd298bf/" rel="bookmark">
			intellij idea报错“Error updating changes: svn: E155036: Please see the &#39;svn upgrade&#39;..........”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用intellij idea时间不长，使用svn更新和提交代码一直都没问题，突然今天提示“Error updating changes: svn: E155036: Please see the 'svn upgrade'..........”错误，百思不得其解，最后经过一段时间的摸索，终于解决
问题截图：
解决方法：
1、执行cmd命令，并切换目录到idea的工程目录文件夹
2、执行svn upgrade
3、回到intellij idea工具中，点开Version Control，工具栏，点击左上角的“刷新”按钮
4、问题解决
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/285/">«</a>
	<span class="pagination__item pagination__item--current">286/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/287/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>