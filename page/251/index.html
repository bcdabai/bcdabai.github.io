<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11538dac3e7a6ec94107c1edc82ebbf7/" rel="bookmark">
			详解如何使用 PCem 安装 Windows 98 操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实这篇本来是打算和DOSBox那篇写在一起的，可是写到后来发现篇幅太长，于是就干脆拆分成了两篇来写。相对于DOSBox而言PCem对Windows 98的支持性要好上太多，这也就是为什么博主把Windows 95和Windows 98拆到两个平台来写的原因，而且相对于DOSBox复杂难懂的配置文件，PCem明显就友好很多，简直是小清新啊。
写在之前：本文假定你对MS-DOS及WINDOWS 9X操作系统有一定的了解，掌握基本的DOS命令，熟悉WINDOWS系统的基本够成与操作方法。前一篇篇幅过长的原因大部分是由于我假定各位不太熟悉这些古董级的操作系统，然后发现陷入了不可知论越写范围越大，越来越累，所以本文不打算展开讲解了，有不懂的各位可以留言，博主会解答。
软件名称：PCem Emulator
软件版本：v15
官方主页：http://pcem-emulator.co.uk
网盘链接：https://pan.baidu.com/s/1xIE-BJRIRe0X5P1ydBL-fA
序号附件名称备注及说明1PCemV15Win.zipPCem Emulator 程序包，版本 v15 (20190519)2PCem-ROMs-15.0.zip ROMs for PCem v15.0 (20190730)
工程地址：https://github.com/BaRRaKudaRain/PCem-ROMs
本文用到的软件从DosBox那篇照搬过来就可以，如下：
软件名称：Windows 9x 驱动程序与软件包
网盘链接：https://pan.baidu.com/s/15Fjsd7JkrbaVT9YxUXYQsA
提取码：et5d
补充说明：不需要把网盘中的文件全部下载下来，本文需要用到的文件如下，按需下载即可
Boot Disks.zip3DFX.zipWindows 9x Drivers and Software.zipharddisk.7z * 博主自己制作的磁盘镜像，需要用到的驱动程序及软件已经写入，建议下载 1. 安装 PCem Emulator 并初始化 说是安装，其实PCem本身并没有安装程序，直接把压缩包释放到任意指定的目录即可，该目录所在路径中最好不要包含特殊字符、中文字符及空格，以避免触发不必要的错误。
接下来，把下载得到的"PCem-ROMs-15.0.zip"中的所有文件，覆盖到PCem安装目录下的"roms"文件夹中
好了，恭喜你，现在你已经完成了PCem的初始化，对比DosBox简直容易到令人发指！唯一的困难在于寻找ROM包，百度贴吧等到处都是求ROM包的，博主上面直接把工程地址分享出来了，也算是授人以渔了。
2. 配置一台虚拟机 首次运行PCem，会显示如上界面，基本的操作说明博主已经标注出来，首先要创建一个虚拟机的配置文件。
3. 创建磁盘镜像文件并挂载 前面的步骤仅仅只算是完成了一台虚拟机的基本配置，但是并没有挂载任何硬盘，所以是无法运行的，现在我们要执行的就是创建硬盘镜像文件并挂载。相较于DOSBox复杂的imgmake和imgmount命令，PCem确实直观了很多，如下：
这里同样使用CHS方式创建磁盘镜像文件，首先指定磁盘镜像存储位置，博主选择将其存放在PCem目录下的"images"子目录中方便管理，CHS参数分别设置为4092、16、63，这样就可以创建一块容量为2GB的磁盘镜像。有关CHS寻址及容量计算公式博主已经在DOSBox那篇中作了详细讲解，此处不再赘述。
将下载的"harddisk.7z"压缩包中的磁盘镜像文件"vmdk_hdd_slave.img"释放到任意目录中，然后挂载到从盘位置，即下图中磁盘位置显示为"Drive 1 Primary Slave (D:)"的选项下，如下图所示：
上述设置完成后，直接点击"OK"按钮保存，至此基本的配置已经完成，接下来开始准备安装操作系统。
4、安装 Windows 98 点击启动按钮，虚拟机会开始执行自检，看到熟悉的能源之星标志是不是有点小兴奋？接下来，要挂载启动盘，调整BIOS设置准备安装操作系统了，按照下图所示展开菜单，挂载启动盘。启动盘在博主提供的网盘链接中有提供，不知道在哪里、不知道怎么提取的可以去参考DOSBox那篇相关步骤，博主累了，不想反反复复的写了。
特别说明：PCem同样会捕获鼠标，如果发现鼠标移不出来了，按Ctrl+End键释放鼠标即可，莫慌。
4.1、调整BIOS设置 按DEL键（就是键盘上的Delete键，过去的电脑是通过DEL键进入BIOS设置界面的，不是现在常用的F1或F2等。博主真心不想再解释这种问题，不解释又怕有人问，解释吧又觉得自己傻，毕竟，感觉不知道啥是DEL键也就不用再继续看下去了）进入BIOS设置界面，移动光标至"IDE HDD AUTO DETECTION"，按回车。
接下来BIOS会自动检测IDE设备并显示信息，输入"Y"并按回车键确认即可，如此操作直至主、从盘检测结束，后续的检测直接默认输入"N"跳过即可。 检测完成后回到BIOS主界面，移动光标至"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11538dac3e7a6ec94107c1edc82ebbf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c682b0a3ff5543e3a35e8ae36b988d8e/" rel="bookmark">
			Git常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
设置相关
设置用户名和邮箱
为所有项目设置默认的用户名和邮箱
不同的项目设置不同的用户名和邮箱
历史版本相关
回滚到任意历史版本
从指定历史版本拉取新分支
获取指定的历史版本代码
补丁相关
补丁生成
应用补丁
注意事项
分支相关
重命名本地分支
跟踪远程分支
删除远程分支
重命名远程分支
推送本地分支到远程仓库
合并指定commits到另一个分支
从远程仓库获取最新代码合并到本地分支
从指定提交创建分支
撤销相关
撤销当前目录下工作区所有修改
撤销暂存区所有修改
撤销已经推送到远程的修改
日志相关
查看最近几条提交记录的日志
查找包含关键字的日志记录
子模块相关
初始化子模块
克隆项目时自动初始化并更新仓库中的每一个子模块
更新子模块
添加子模块
删除子模块
标签相关
创建轻量标签
创建附注标签
在之前的提交上打标签
推送单个标签
推送多个标签
删除远程标签
重命名标签
列出所有标签
查找标签
查看标签对应的提交信息
想要工作目录与仓库中特定的标签版本完全一样
问题解决
No submodule mapping found in .gitmodule
暂存
保存本地修改
恢复暂存的修改
删除暂存的修改
查看所有暂存的修改
查看暂存修改的内容
其他
修改默认编辑器
参考文章
设置相关 设置用户名和邮箱 为所有项目设置默认的用户名和邮箱 git config --global user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c682b0a3ff5543e3a35e8ae36b988d8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f98ff6446d70f95eb133f43bde15fa/" rel="bookmark">
			jsDeliver&#43;github打造属于自己的图床
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 简介1.什么是图床2.什么是jsDelive3.为什么搭建图床 二. github的配置1.创建github仓库2.推送图片资源到仓库3.发布版本 三. jsDelive加载资源四. 服务器图床盘点五. 总结 一. 简介 1.什么是图床 百度：“图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。”
注意：github 支持的就是cdn加速
2.什么是jsDelive jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。包含 JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。
我们可以进入 jsDeliver官网来查看
3.为什么搭建图床 我们在写用markdown写博客的时候，需要插入图片，图片存在本地的话上传到微博或者自己搭建的博客网站上面是无法显示的编写网页的时候，需要插入图片的地方，我们总不能放在相应的文件夹，这样会影响网页的加载速度 所以我就就需要用到图床，将图片保存到服务器上，使用的时候直接用
URL 来获取先显示
注意：URL是文件的网络地址，相当于人的住址，每一个网络资源都有固定且唯一的网络地址
二. github的配置 1.创建github仓库 如果你初次接触github 的话，你可以先学习一下 github入门
2.推送图片资源到仓库 将本地的图片资源上传到我们的仓库，方法很多我们采用微软的github软件来推送到我们的仓库
我也就不多说了，不会的还是看一下 github入门
注意
鼠标在那个文件夹下左键打开 git bash here，执行命令就默认在那个文件夹下推送的文件特别多，我们可以采用 * 代表全部文件 git add * //注意 *代表当前目录下所用的文件 git commit -m "add files" //然后推送到本地仓库 git push //推送到远程仓库 3.发布版本 点击release 发布版本
发布成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7f98ff6446d70f95eb133f43bde15fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b97823f4249e21e5ed0a1a83b8d1761/" rel="bookmark">
			第1单元 基础入门7-1 jmu-Java-01入门-第一个PAT上Java程序 (5分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.Scanner;
public class Main {
/*
本题目要求读入若干对整数a和b，然后输出它们的和。
输入格式:
在一行中给出一对整数a和b。 以下输入样例只有两对，实际测试数据可能有多对值。
输出格式:
对每一组输入，如果a的绝对值&gt;1000，输出|a|&gt;1000，否则输出a+b的值。
输入样例:
18 -299
1001 -9
-1001 8
输出样例:
-281
|a|&gt;1000
|a|&gt;1000
*/
public static void main(String[] args) {
Scanner in = new Scanner(System.in);
while(in.hasNextInt()){
int a = in.nextInt();
int b = in.nextInt();
if (Math.abs(a)&gt;1000) {
System.out.println("|a|&lt;=1000");
}
else {
System.out.println(a + b);
}
}
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02afb6e2b20f95f2b65f1841f5c44e37/" rel="bookmark">
			C语言求字符串数组的长度函数计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的计算长度的函数有两个，sizeof（）和strlen（），但是，它们之间的差别还是很大的。
sizeof（）：主要负责计算数组的长度；
strlen（）：主要负责计算字符串的长度。
（1）sizeof（）：数组占用字节除以数组类型所占字节，结果为数组元素个数
使用方法：sizeof（数组名）/ sizeof（数组类型名）
（2）strlen（）：strlen，求字符串有效长度
例如：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { printf("%d\n",strlen("school")); printf("%d\n",sizeof("school")); scanf("%c",&amp;s); } 输出结构：
6
7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0196c046948d54d4e986c160d916e06a/" rel="bookmark">
			小米电视精简，去开机广告，系统更新，删除无用内置软件等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小米电视精简，去开机广告，系统更新，删除无用内置软件等 首先安装第三方桌面
接下来打开电视的开发者模式（点击‘产品型号’7次）
adb调试选择允许(帐号与安全—ADB调试)
PC上安装“线刷宝”并打开Adb命令行
“Adb命令行”里面输入：
adb connect 192.168.*.* adb devices 此时屏幕上会弹出一个提示框“允许USB调试吗？”，选择“确定”，就表示连接成功了。
开机广告：
adb shell pm uninstall --user 0 mitv.service 系统更新
adb shell pm uninstall --user 0 com.xiaomi.mitv.upgrade 应用商店
adb shell pm uninstall --user 0 com.xiaomi.mitv.appstore 米家
adb shell pm uninstall --user 0 com.xiaomi.smarthome.tv 小米商城
adb shell pm uninstall --user 0 com.xiaomi.mitv.shop 小米支付
adb shell pm uninstall --user 0 com.xiaomi.mitv.payment 小米钱包
adb shell pm uninstall --user 0 com.mipay.wallet.tv 游戏中心
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0196c046948d54d4e986c160d916e06a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697d1d1ab2c53216db0d016d02803275/" rel="bookmark">
			linux常用配置文件作用及其用法（更新中。）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各种profile 用户环境配置 当用户刚登录Linux时，首先会启动/etc/profile文件 ,~/.bash_profile、 ~/.bash_login、 ~/.profile。 如果 ~/.bash_profile文件存在的话，一般还会执行~/.bashrc文件。
要注意的是在/etc/profile 文件中设置的变量是全局变量。
关于各个文件的作用域：
/etc/profile： 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从/etc/profile.d目录的配置文件中搜集shell的设置。/etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取（即每次新开一个终端，都会执行bashrc）。~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。默认情况下,设置一些环境变量,执行用户的.bashrc文件。~/.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。~/.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件. 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承 /etc/profile中的变量,他们是"父子"关系。~/.bash_profile: 也可能是 .profile 是交互式、login 方式进入 bash 运行的~/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调u用后者。 /etc/profile.d目录下的文件和 /etc/profile 的区别：
两个文件都是设置环境变量文件的，/etc/profile是永久性的环境变量,是全局变量，/etc/profile.d/设置所有 用户生效/etc/profile.d/比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d/下对应的shell脚本即可，不用 像/etc/profile需要改动此文件
下面以jdk的安装为例 vi /etc/profile.d/java.sh
#set java environment JAVA_HOME=/var/mysoft/jdk1.7.0_80 PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME PATH /etc/skel/ 新增用户初始化配置 /etc/skel/目录是用来存放新用户配置文件的目录，当我们添加新用户的时候，这个目录下的所有文件会自动被复制到新添加的用户的家目录下。
默认情况下这个目录下的所有文件都是隐藏文件（以.点开头的文件）。
可以通过修改、添加、删除/etc/skel目录下的文件，为新创建的用户提供统一的、标准的、初始化用户环境。
如果在新建用户时，没有自动建立用户家目录，则无法调用到此框架目录。
如果不想以默认的/etc/skel目录作为框架目录，可以在运行useradd命令时指定新的框架目录。例如：
sudo useradd -d /home/zbuter -m -k /etc/my_skel zbuter 上述命令将新建用户zbuter，设置用户根目录为/home/zbuter，并且此目录会自动建立；同时指定框架目录为/etc/my_skel。
如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改/etc/default/useradd配置文件来改变默认的框架目录，方法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/697d1d1ab2c53216db0d016d02803275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/636e2ad48f3a57dc4e0133ce1856fd31/" rel="bookmark">
			我的bashrc控制台样式and一些全局变量and一些alias
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# .bashrc # User specific aliases and functions alias rm='rm -i' alias cp='cp -i' alias mv='mv -i' alias svi='sudo vim' alias install='sudo apt-get install' alias update='sudo apt-get update; sudo apt-get upgrade' alias ..="cd .." alias ...="cd ..; cd .." # 颜色定义 start RCOL='\e[0m' # 颜色重置 # Regular Bold Underline High Intensity BoldHigh Intens Background High Intensity Backgrounds BLACK='\e[0;30m'; BBLACK='\e[1;30m'; UBLACK='\e[4;30m'; IBLACK='\e[0;90m'; BIBLACK='\e[1;90m'; ONBLACK='\e[40m'; ONIBLACK='\e[0;100m'; RED='\e[0;31m'; BRED='\e[1;31m'; URED='\e[4;31m'; IRED='\e[0;91m'; BIRED='\e[1;91m'; ONRED='\e[41m'; ONIRED='\e[0;101m'; GREEN='\e[0;32m'; BGREEN='\e[1;32m'; UGREEN='\e[4;32m'; IGREEN='\e[0;92m'; BIGREEN='\e[1;92m'; ONGREEN='\e[42m'; ONIGREEN='\e[0;102m'; YELLOW='\e[0;33m'; BYELLOW='\e[1;33m'; UYELLOW='\e[4;33m'; IYELLOW='\e[0;93m'; BIYELLOW='\e[1;93m'; ONYELLOW='\e[43m'; ONIYELLOW='\e[0;103m'; BLUE='\e[0;34m'; BBLUE='\e[1;34m'; UBLUE='\e[4;34m'; IBLUE='\e[0;94m'; BIBLUE='\e[1;94m'; ONBLUE='\e[44m'; ONIBLUE='\e[0;104m'; PURPLE='\e[0;35m'; BPURPLE='\e[1;35m'; UPURPLE='\e[4;35m'; IPURPLE='\e[0;95m'; BIPURPLE='\e[1;95m'; ONPURPLE='\e[45m'; ONIPURPLE='\e[0;105m'; CYAN='\e[0;36m'; BCYAN='\e[1;36m'; UCYAN='\e[4;36m'; ICYAN='\e[0;96m'; BICYAN='\e[1;96m'; ONCYAN='\e[46m'; ONICYAN='\e[0;106m'; WHITE='\e[0;37m'; BWHITE='\e[1;37m'; UWHITE='\e[4;37m'; IWHITE='\e[0;97m'; BIWHITE='\e[1;97m'; ONWHITE='\e[47m'; ONIWHITE='\e[0;107m'; # 颜色定义 end # 有时候切换组或者切换用户时会出现未找到命令 注意不能再/etc/bashrc中设置。需要在个人的家目录中的 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/636e2ad48f3a57dc4e0133ce1856fd31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358b545bac6be007ac7a2710edc4ead4/" rel="bookmark">
			Consul环境搭建（Windows系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、下载Consul 2、启动Consul服务 3、访问Consul 默认访问地址：http://localhost:8500 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a60a0b5bdf25b850e8e13dd47a90d6/" rel="bookmark">
			Zookeeper环境搭建（Windows系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、下载Zookeeper https://www.apache.org/dyn/closer.cgi/zookeeper/ 2、修改配置文件 3、配置环境变量 4、启动Zookeeper服务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b3da9ac1af1ae85bf589ba2934531f/" rel="bookmark">
			计算机视觉——SIFT特征提取与检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SIFT算法
1.1算法介绍
1.2算法特点
1.3特征检测
1.4特征匹配
二、SIFT特征提取与检索实验
2.1实验要求
2.2实验准备
2.3实验过程
2.3.1图片的SIFT特征提取
2.3.2计算两张图片其SIFT特征匹配结果
2.3.3寻找匹配图像
三、实验总结
地理标记图像匹配
一、 实验描述
二、环境配置
2.1安装Graphviz
2.2安装pydot
三、实验数据准备
四、实验代码
4.1提取特征
4.2使用局部描述子匹配
4.3可视化连接图像
4.4实验结果图
五、实验总结
RANSAC算法
一、算法介绍及原理
二、实验过程
一、SIFT算法 1.1算法介绍 SIFT特征是基于物体上的一些局部外观的兴趣点而与影像的大小和旋转无关。对于光线、噪声、微视角改变的容忍度也相当高。基于这些特性，它们是高度显著而且相对容易撷取，在母数庞大的特征数据库中，很容易辨识物体而且鲜有误认。使用SIFT特征描述对于部分物体遮蔽的侦测率也相当高，甚至只需要3个以上的SIFT物体特征就足以计算出位置与方位。在现今的电脑硬件速度下和小型的特征数据库条件下，辨识速度可接近即时运算。SIFT特征的信息量大，适合在海量数据库中快速准确匹配。
1.2算法特点 1.SIFT特征是图像的局部特征，其对旋转、尺度缩放、亮度变化保持不变性，对视角变化、仿射变换、噪声也保持一定程度的稳定性；
2. 区分性好，信息量丰富，适用于在海量特征数据库中进行快速、准确的匹配；
3. 多量性，即使少数的几个物体也可以产生大量的SIFT特征向量；
4.高速性，经优化的SIFT匹配算法甚至可以达到实时的要求；
5.可扩展性，可以很方便的与其他形式的特征向量进行联合。
1.3特征检测 SIFT特征检测主要包括以下4个基本步骤：
1.尺度空间极值检测：
搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。
2. 关键点定位
在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。
3. 方向确定
基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。
4. 关键点描述
在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。
1.4特征匹配 SIFT特征匹配主要包括2个阶段：
第一阶段：SIFT特征的生成，即从多幅图像中提取对尺度缩放、旋转、亮度变化无关的特征向量。
第二阶段：SIFT特征向量的匹配。
二、SIFT特征提取与检索实验 2.1实验要求 针对自己所处的环境，拍摄多张图片（注意要来自不同场景），构造出一个小的数据集（15张以上）实现数据集中，每张图片的SIFT特征提取，并展示特征点给定两张图片，计算其SIFT特征匹配结果给定一张输入的图片，在数据集内部进行检索，输出与其匹配最多的三张图片 2.2实验准备 1）实验数据
2）环境配置
2.3实验过程 2.3.1图片的SIFT特征提取 1）实验代码
# -*- coding: utf-8 -*- from PIL import Image from pylab import * from PCV.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b3da9ac1af1ae85bf589ba2934531f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eee1b1dab2b33d35fc20ff4e74c6af2/" rel="bookmark">
			Springboot 2.x源码解析之源码下载与搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言操作系统环境准备源码下载编译源码导入 IntelliJ IDEA导入完成后出现的问题1、maven版本过高2、maven配置内存过低 导入Demo启动测试 前言 推荐大家去看Spring官方网站：https://spring.io，Spring家族都在这里哦。
操作系统 MacOs Catalina 10.15.3
环境准备 Java JDK 1.8 版本Maven 至少是v3.5版本以上，请勿使用v3.6版本，否则可能会出现不兼容的问题，点击 下载 可以下载其他本，另需配置maven镜像仓库，选择阿里云的镜像即可IntelliJ IDEA 源码下载 源码仓库在：官方仓库，可以看到springboot有1.x版本和2.x版本，目前我的当前版本是v2.1.0.M1版本，可以直接点击下载：https://github.com/spring-projects/spring-boot/archive/v2.1.0.M1.zip，或者通过git clone命令将源码下载至本地：# git clone https://github.com/spring-projects/spring-boot.git
编译 下载解压后，开始准备编译前步骤，首先检查环境是否准确，检查步骤如下：
检查Java环境：# java -version 出现版本号则正常，版本至少1.8。检查maven环境 # mvn -v 出现版本号则正常，检查你的maven版本是不是至少v3.5版本,另附maven3各个版本的下载地址：http://archive.apache.org/dist/maven/maven-3/检查你的终端访问磁盘权限是否已打开（注意我的是mac系统，如果你的不是此系统请忽略此步骤），进入设置-安全与隐私-隐私，如下图：没有勾上的请勾上，不然执行maven 命令会提示没有访问磁盘权限
检查通过后，打开终端进入源码根目录，执行以下命令，等待编译完成：
# mvn clean install -DskipTests -Pfast -DskipTests -Pfast 表示跳过测试用例
当出现下图的情况就是编译成功了：
源码导入 IntelliJ IDEA 首先我们看一下源码目录：
其中spring-boot-project模块就是核心代码，而spring-boot-samples模块就是官方提供的Demo，spring-boot-samples-invoker模块你可以理解为插件，它是用来构建spring-boot-samples模块的，spring-boot-tests就是一些测试代码。接下来我们以maven形式导入进IntelliJ IDEA，首先我们修改一下在源码根目录下的pom文件，在properties标签里加上&lt;disable.checks&gt;true&lt;/disable.checks&gt;，避免编译报错，如下图：
然后我们打开spring-boot-samples-invoker模块下的pom文件，在properties标签里加上&lt;skipTests&gt;true&lt;/skipTests&gt;，同样避免编译报错，如下图：
打开Idea，选择导入：
选择源码代码根目录
选择maven
其他配置都是默认，等待导入完成！！！
导入完成后出现的问题 1、maven版本过高 如果你的maven版本是v3.6版本以上，建议换成v3.5版本，否则会出现不兼容的问题出现如下错误：
报错内容如下：
如果你出现这种情况，建议降低版本，比如我的maven版本是v3.5.3，maven其他版本下载地址：http://archive.apache.org/dist/maven/maven-3/。下载完成后，重新配置一下maven环境变量切换到v3.5版本，在终端修改# vi ~/.bash_profile，将maven配置的路径换成你下载的当前版本即可，修改完成后记得# source ~/.bash_profile , 输入命令# mvn -v查看是否切换成功。除此之外，你还需要修改idea的maven依赖的环境版本，在idea打开Preferences &gt; Build, Execution, Deployment &gt; Build Tools &gt; Maven，将maven home改成你当前的v3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eee1b1dab2b33d35fc20ff4e74c6af2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82143fce6d419ad3353ce6663eb46c93/" rel="bookmark">
			微信小程序实现对数据库的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一开始，只要用微信提供的接口就好，即we.request,然后设置相应的参数就好，可是在设置参数的时候我遇到了问题，即不太明白如何动态设置要传递的参数，会获取输入框的值但并不能设置到we,rewuest中
看代码
wxml
&lt;input bindinput="inputdd" placeholder="输入要删除的学号"&gt;&lt;/input&gt; &lt;view&gt; &lt;button bindtap='bindtest'&gt;test&lt;/button&gt; &lt;/view&gt; data: { no : '', abc:'', inputDate :'', iconSize: [20, 30, 40, 50, 60, 70], iconColor: [ 'red', 'orange', 'yellow', 'green', 'rgb(0,255,255)', 'blue', 'purple' ], iconType: [ 'success', 'success_no_circle', 'info', 'warn', 'waiting', 'cancel', 'download', 'search', 'clear' ] }, inputdd: function(e){ this.setData({ inputDate : e.detail.value }) }, bindtest: function () { wx.request({ url: 'http://localhost:8888/StudentMannger/delteservlet', //本地服务器地址 data: { sno: this.data.inputDate, // 对于我来说上面这句话就是困扰我很久的东西 }, method: 'GET', header: { 'content-type': 'application/json' //默认值 }, success: function (res) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82143fce6d419ad3353ce6663eb46c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f462f751bcd6ba8902cda996d1e9a7/" rel="bookmark">
			Java中BigDecimal除法保留小数位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 计算除法，并进行小数位的保留（结果四舍五入、向上取整、向下取整等）的格式：
BigDecimal result= 被除数.divide(除数,保留小数位, RoundingMode.结果处理); 说明：1、保留小数位填写Integer类型
2、结果处理（四舍五入、向上取整、向下取整等）通过RoundingMode中枚举来实现，常用的：
RoundingMode.UP:直接进位，比如1.22222如果保留1位小数，得到的就是1.3
RoundingMode.DOWN:直接省略多余的小数，比如1.28888如果保留1位小数，得到的就是1.2
RoundingMode.FLOOR:向下取整，2.35保留1位，变成2.3
RoundingMode.HALF_UP:四舍五入（舍入远离零的舍入模式），2.35保留1位，变成2.4
RoundingMode.HALF_DOWN:四舍五入（接近零的舍入模式），2.35保留1位，变成2.3
举例：
实现保留两位小数的结果进行四舍五入处理：
BigDecimal bigDecima1 = BigDecimal.valueOf(2); BigDecimal bigDecima2 = BigDecimal.valueOf(3); BigDecimal divide = bigDecimal .divide(bigDecima2,2, RoundingMode.HALF_UP); System.out.println("divide======"+divide);//0.67 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ca83b5e0c052877f237a535ed8f496/" rel="bookmark">
			CountdownLatch详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
CountdownLatch
核心属性
构造函数
核心方法
文章转载自：https://segmentfault.com/a/1190000016508108
CountdownLatch CountDownLatch本身是基于共享锁实现的，该工具是为了解决某些操作只能在一组操作全部执行完成后才能执行的情景CountDown是倒数计数，所以CountDownLatch的用法通常是设定一个大于0的值，该值即代表需要等待的总任务数，每完成一个任务后，将总任务数减一，直到最后该值为0，说明所有等待的任务都执行完了，“门闩”此时就被打开，后面的任务可以继续执行。
举个例子：一个app中三个线程同时进行飞机票查询，设置CountDown初值为3，每结束一个线程CountDown减1，CountDown为0时统计机票数并输出。在CountDown大于0之前，所有已完成任务的进程都会被阻塞，CountDown为0后，由latch.await()方法唤醒被阻塞的进程继续执行latch.await()方法后续方法。
先看下面例子，后面再详细分析
public class FightQueryDemo { private static List&lt;String&gt; company= Arrays.asList("东方航空","南方航空","海南航空"); private static List&lt;String&gt; fightList=new ArrayList&lt;&gt;(); public static void main(String[] args) throws InterruptedException{ String origin="BJ"; String dest="SH"; Thread[] threads=new Thread[company.size()]; CountDownLatch latch=new CountDownLatch(company.size()); for (int i = 0; i &lt; threads.length; i++) { String name=company.get(i); threads[i]=new Thread(()-&gt;{ System.out.printf("%s 查询从%s到%s的机票\n",name,origin,dest); //随机产生票数 int val=new Random().nextInt(10); try { TimeUnit.SECONDS.sleep(val); fightList.add(name+"--"+val); System.out.printf("%s公司查询成功！\n",name); latch.countDown(); } catch (InterruptedException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ca83b5e0c052877f237a535ed8f496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae17938655413111a0bef2d902d8b4a3/" rel="bookmark">
			Game101课程笔记_lecture07_着色1（光照与基本着色模型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Game101课程笔记_lecture07_着色1（光照与基本着色模型） 1 occlusion1 z-buffer2 算法2 z-buffer 复杂度 2 Shading1 什么是着色2 基础的着色模型3 shading local4 漫反射 3 视频 1 occlusion 先把远处的画完，再画近处的，这就是画家算法。
图形学中用画家算法，需要排序，但是要特别注意顺序，要不然画出来不对；
但是有一中特殊的情况不对。
提出了一种深度缓冲的算法；对每一个像素的深度进行比较是可以的。
同步生成两个图，一种是frambuffer帧缓冲，帧缓冲放着每个像素的颜色值。另一个就是深度图，深度缓冲，放着每个
1 z-buffer 我们认为：深度是摄像机到这个点的深度，永远是正的，值越小离的越近。
近的颜色黑，远的颜色浅。近的值小，远的值大。
2 算法 5小于R,所以将R在对应的像素上更新深度缓冲。
再插入第二个三角形。做上角8&gt;5,对应的像素被原来的三角形遮挡。左下角3&lt;5,跟新颜色，同时跟新z-buffer;
所有的操作都是针对于一个像素来说的，渲染的结果和深度缓冲都是同步更新。
2 z-buffer 复杂度 这里并没有排序，深度缓冲的算法只是一直在求最小值而已。
这里老师是如何说这个复杂度 的？再听一下？
浮点数判断相等是很难的，深度完全一样如何处理？
在很多硬件中使用这个算法。
z-bufffer处理不了透明问题。
2 Shading 1 什么是着色 不同的物体应用不同的材质。
2 基础的着色模型 高光+漫反射+环境光=材质
ambient lighting：间接光照，通过别的物体反射得到的光照，在路径追踪中讲
3 shading local local 局部，只看它自己，不考虑其他物体的存在。
shading point—》本身的颜色，多么亮。
shading≠shadow
4 漫反射 光是能量，看到的物体是接收到了多少能量。看shading point周围一个单位面积会受到多少能量.
地球上有四季之分，是因为夏天会被光直射，单位面积接收到的能量大。
lameber余弦定律:shading point 接收到多少光与cos成正比。
光线在传播的过程与光线传播的距离R的平方成反比
为啥要做max呢，当是负数的时候，没有任何物理意义，就认为是0；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae17938655413111a0bef2d902d8b4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a56f950f612b781c134365d604943228/" rel="bookmark">
			操作系统 知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一章 概论第二章 进程管理第三章 内存管理第四章 文件管理第五章 I/O管理实验实验1实验2实验3操作其他 题目 第一章 概论 单处理中，进程之间叫并发不是并行用户通过命令接口（批处理和交互式）和系统调用来使用计算机缓存全部由os管分时time-sharing有批处理、分时和实时os中断使得io和cpu可以并行多道程序cpu利用率高，吞吐量大，io利用率高资源利用率不是实时os目标优先级加非抢占式调度，可以改善系统响应时间分时系统期待快速响应用户定义原语的方式是关闭中断，让其所有动作不可分割的完成之后再打开命令解释在用户态进行中断处理和子程序调用都会压栈来保护现场，中断一定会保存程序状态字寄存器（PSWR）关中断指令不能在用户态内部异常处理后，不一定能回到异常指针，可能跳过异常也称内中断外部中断时，os需要保存通用寄存器内容并发和共享是现代os基础 第二章 进程管理 调度是分配给资源。现有资源调度，后有进程切换进程通信，pv是低级操作，高级有： 共享存储消息传递（直接和间接）管道通信（半双工）。管道大小可以设置，管道在空或者满的时候，会读或写阻塞。只允许一边写入，一边读出 进程是为了多道程序，线程是为了提高并发性能。有就绪阻塞运行三种状态。就是轻量级进程在支持线程的os中，线程是独立调度的基本单位，进程是拥有资源的基本单位。有了线程，则调度的时候可能发生进程切换也可能不发生，所以平均开销变小了。设备分配是io系统，不新进程。P操作会导致阻塞态Cpu抢占，进程变为就绪态不能调度与切换：1）处理中断时，2）临界区，3）源自操作Preemptive周转时间是完成减去提交，带权周转是周转除以实际运行时间等待是周转减运行响应是提交到首次响应高响应比优先调度：响应比R=（等待+要求服务时间）/要求服务时间。它综合考虑了等待时间和执行时间；满足短作业优先且不会饥饿为了提高利用率，io越长应该越先 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VXFqf2xp-1583500272226)(file:///C:/Users/Kfor/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)]
时间片用完，执行态变就绪态临界区也可以调度。比如打印机时间片轮转，不会饥饿硬件实现同步，可以中断屏蔽或者硬件指令。满足互斥但不有限等待 boolean TestAndSet(boolean *target) { boolean rv = *target; *target = true; return rv; } // boolean lock = false 对于第i个进程: do { while (TestAndSet(&amp;lock)) ; Critical Section lock = false; Remainder Section }while(1); 使用信号量完成前驱关系。只需要画出前驱图，然后每个分支设置一个信号量即可。Semaphore。注意，两个wait在一起，同步wait在互斥wait前管程。每次只能有一个进程进入管程。在x.wait()，x是条件变量，则其阻塞该进程并插入x的阻塞队列中Cs full = 0, empty = n, mutex = 1 // producer while (true) { // produce an item wait (empty); wait (mutex); // add the item to the buffer signal (mutex); signal (full); } // consumer while (true) { wait (full); wait (mutex); //remove an item from buffer signal (mutex); signal (empty); // consume the removed item } Read and write mutex = 1, wrt = 1 //readers readcount = 0 wait(mutex); readcount++; if (readcount == 1) wait(rt); signal(mutex); //reading is performed wait(mutex); readcount--; if (readcount == 0) signal(wrt); signal(mutex)； //writers wait(wrt); //writing is performed signal(wrt); 哲学家 semaphore chopstick[5] = 1。 对于第i哲学家： do { wait(chopstick[i]); wait(chopstick[(i+1) % 5]); eat; signal(chopstick[i]); signal(chopstick[(i+1) % 5]); think; } while (1); 死锁。预防保守，是要破坏四个必要条件（互斥、不剥夺、hold and wait、循环等待），宁可资源闲置。避免是找安全序列。检测是通过剥夺等来检测并解除死锁避免：银行家算法 Banker’s Algorithm(Deadlock Avoidance) Resource-Request Algorithm 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a56f950f612b781c134365d604943228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d555e91f05a2cdc0170acd08d80dab6a/" rel="bookmark">
			vmware虚拟机搭建开发环境经验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 使用虚拟机搭建开发环境的优点：
不会污染宿主机；切换开发电脑不需要重新搭建开发环境； 使用虚拟机搭建开发环境的缺点：
虚拟机的性能会略低于宿主机；某些开发无法在虚拟机中进行，例如GPU程序开发； 建议 硬盘建议 添加多个支持永久写入的独立虚拟硬盘；
原因：
I.这种硬盘里的数据，不会因为切换快照而消失；
II.多个虚拟硬盘可以分别存放便携软件和程序数据等，这样就算切换快照也不用重新安装工具软件，复制数据。将虚拟机放在固态硬盘中，并定期备份到机械硬盘；
原因：
I.可以大大提升虚拟机的响应速度；
II.由于固态硬盘存在读写次数的问题，所以定期备份到机械硬盘可以预防数据丢失。 系统建议 关闭系统自动更新；
原因：当你切换到某个快照重启时可能会遇到系统更新，需要等待不少时间影响开发效率。如果虚拟机安装Windows系统，建议使用序列号不要使用破解器；
原因：破解器容易被系统杀毒软件不断报毒，比较烦人。 快照建议 关闭虚拟机后拍摄快照；
原因：虚拟机运行时拍摄的快照在切换宿主机之后，可能无法恢复。对操作系统进行一些重要修改如安装大型软件后及时拍摄快照并命名；
原因：不拍摄快照，一不小心容易使花费心血安装的软件等工作瞬间泡汤。 其他建议 重要数据及时保存到虚拟机外，如网盘等；
原因：虚拟机容易出现损坏，导致其中的数据丢失。尽量使用便携版的工具软件；
原因：配合支持永久写入的独立虚拟硬盘，可以实现切换快照后不需要重新安装工具软件。无法安装vmware tools时，可以通过在宿主机中设置共享文件夹，虚拟机访问共享文件夹。 后记 以上这些建议都是小强我踩了不少坑之后自己总结出来的，希望对小伙伴有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dbb8ffd66d58a974ce72912d4fabec6/" rel="bookmark">
			idea使用git如何把master修改的内容提交其他分支上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚开发时往往不注意，就一直使用master分支忘了切换，修改完后commit，push不上去才发现。
那怎么样才能把修改完的内容提交到其他分支再push呢？
步骤： 1、先切换分支，我的切换到feature分支
2、切换分支途中可能会有冲突，一定把冲突文件提交或搁置起来，否则下面一步报错
3、你提交到master上面的记录，右键选择cherry-pick
4、这时候你就会发现你在master提交的东西，都跑到feature分支上来了，直接push feature分支就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6ba81a4c729649744c4ed27865695c/" rel="bookmark">
			ArcFace
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文：ArcFace: Additive Angular Margin Loss for Deep Face Recognition
代码：https://github.com/deepinsight/insightface
0 摘要 本文提出了新的监督值： cos ⁡ ( θ + m ) \cos(\theta + m) cos(θ+m)，在进行权重和特征归一化的基础上最大化角度空间的决策边界。
还强调了使用深度网络进行人脸识别过程中的网络设置和数据修正的重要性。
1 简介 目前已经有大量的基于深度学习的人脸识别模型，这些模型主要有三方面的不同：
训练数据的规模不同：目前常用的人脸识别数据集VGG-Face,VGG-Face2,CAISA-WebFace,UMDFaces,MS-Celeb-1M,MegaFace，图像的规模从几千到数十万不等。虽然MS-Celeb-1M,MegaFace收集的大量人员的人脸图像，但是他们存在标注噪声和长尾效应。作为对比，谷歌的私有人脸数据集包含数百万人员的照片，FRVT比赛的冠军依图科技，用于18亿规模的私有数据集。因为数据集的规模不同，工业界人脸识别产品的性能要好于学术界。由于数据集规模不同，很多深度学习模型的效果无法完全复现。
网络结构及相关参数设置不同：如果使用大的网络(ResNet和Inception-Resnet)，效果就要比小网络(VGGNet和Google Inception V1)要好。不同的应用场景需要考虑的产品性能不同，移动式设备上根据关注识别效率，安保场景下更加关注识别精度。
损失函数不同：
[1]基于欧式间隔的损失： center loss,Range loss,Marginal loss在类别数很多时占用GPU过多，contrastive loss，triplet loss构建样本对需要很强的策略性；[2]基于角度和余弦间隔的损失：L-softmax提出了 cos ⁡ ( m θ ) \cos(m\theta) cos(mθ)实现了在角度空间内进行识别，SphereFace(A-Softmax)在其基础上加上了权重归一化，AM-Softmax提出了 cos ⁡ ( θ ) − m \cos(\theta) - m cos(θ)−m在余弦空间内进行识别，取得了当下最先进的识别结果。
相比于欧式空间间隔，角度空间间隔和余弦空间间隔在超平面上增加了判别限制，符合人脸分布在超平面上这一先验知识。 作者认为，数据、网络和损失由高到低的影响识别效果。
本文作者对这三方面分别做了以下工作：
数据：作者修正了最大的人脸公开数据集MS-Celeb-1M，也发现了MegaFace和FaceScrub之间存在数据重复，作者公开了修正后的训练和测试数据；
网络：作者提出的网络对大的姿态和年龄变化具有很好的识别鲁棒性。作者也验证了当前各网络识别效果和效率；
损失：提出了新的损失，additive angular margin， cos ⁡ ( θ + m ) \cos(\theta + m) cos(θ+m)。对归一化后的权重和特征在角度空间内进行优化以最大化决策边界。新提出的损失比A-softmax和AM-softmax几何含义更加直观，识别效果也更好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb6ba81a4c729649744c4ed27865695c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b076814c350a4677e65c8104b8a5e5/" rel="bookmark">
			常用定时任务（cron）表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 0 2 1 * ? *：表示在每月的1日的凌晨2点调整任务；
0 15 10 ? * MON-FRI：表示周一到周五每天上午10:15执行作业；
0 15 10 ? 6L 2002-2006：表示2002-2006年的每个月的最后一个星期五上午10:15执行作；
0 0 10,14,16 * * ?：每天上午10点，下午2点，4点；
0 0/30 9-17 * * ?：朝九晚五工作时间内每半小时；
0 0 12 ? * WED：表示每个星期三中午12点；
0 0 12 * * ?：每天中午12点触发；
0 15 10 ? * *：每天上午10:15触发；
0 15 10 * * ?：每天上午10:15触发；
0 15 10 * * ? *：每天上午10:15触发；
0 15 10 * * ? 2005：2005年的每天上午10:15触发；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b076814c350a4677e65c8104b8a5e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477759aeb406b6b9c3daa79e92b70b79/" rel="bookmark">
			漫画 | 外包程序员的真实体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在软件外包公司工作过挺长时间，确实或多或少会有类似上文说的情况。有些同事私下会抱怨不满，感觉待在外包公司保险。
但说实话，现在的社会，哪还有真正意义的保险，那么多知名的大公司，不也照样说裁员就裁员。指望着公司，依仗着别人，永远不保险，真要保险，还得靠自己的实力。
在外包公司的这段时间里，我身边也不断有牛人涌现。
一个94年小伙，年少有为，两年前就是高级开发职位了，入职没几个月，被甲方收编；
一个91年小伙，技术控，一直待在外包，凭借对技术的热爱一路升级为公司的技术顾问，专搞各种痛点；
一个92年姑娘，凭借一口流利英语，熟练的业务知识，一步步从测试、BA、走到部门主管；
如果你有更好的选择当然可以，但外包也并没有传说中的那么不堪，身在其中，也一样能得到锻炼。
对于牛人而言，选择很多，道路很宽，走到哪里都被爱戴，赚钱只是顺便。
最后，江湖中存在一个公认的秘诀，几乎所有大牛程序员都具备。查看这个秘诀，请私信我:大牛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b6f129de33cda0ef5bb3101958533f/" rel="bookmark">
			css隐藏滚动条同时不影响布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在页面中有撑出滚动条的需求，但又不想看到浏览器那丑丑的滚动条，所以研究了下解决办法：
.scroll-hidden{ width:calc(~"100% + 15px"); padding-right: 15px; overflow: auto; } 将大盒子的宽度设置为100%，同时加上滚动条的宽度，给大盒子padding-right滚动条的宽度，这样就可以将滚动条撑到页面外去。当然，不同的浏览器撑出的滚动条宽度是不一样的，想要达到页面的绝对统一也是不可能的。这里的calc()f方法是less预编译器的写法，必须按照此规定写，不然是没有办法自动计算宽度的。方法里面的内容写法很重要。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff0671aefd3afc9b8fc3f4723f599a5c/" rel="bookmark">
			【解决方法】java命令运行class文件提示“错误：找不到或无法加载主类”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 执行java Test命令时报错找不到或无法加载主类。
第一种
第二种
原因 环境变量没有把当前路径(.代表当前路径)加进去。java命令执行时package指定的包路径没写。 解决方法 java执行class文件是根据CLASSPATH指定的地方来找，不是我们理解当前目录。
如果希望它查询当前目录，需要在CLASSPATH中加入“.;”,代表当前目录。
比如CLASSPATH：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar
然后重启cmd命令行，再执行就可以了。
java执行class文件对package的路径是强依赖的。
它在执行的时候会严格以当前用户路径为基础，按照package指定的包路径转化为文件路径去搜索class文件。
所以返回package指定的包路径的上一层路径去执行，就不会报错了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5259e89f749b3a2488cd4d8b52e6155/" rel="bookmark">
			burp suite安装过程中遇到的一些小问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 设置代理8080端口后无效 * 原因
* 浏览器挂了其他端口。
*
8080端口被其他进程占用，burp suite中的8080端口无法被勾选。
*
解决方法
* 找一个随机高端口（必须确认没有被占用，在proxy中设置并勾选）
*
更改Windows代理的端口。与在proxy中设置的保持相同。
2.
BurpSuite环境设置
* 先确认已经安装了Java虚拟机。
*
将burp suite的安装文件、破解文件、中文输入法插件、vbs和bat的链接文件找到。
*
完成破解之后，直接使用vbs打开。
3.
burp suite字体调节
* 安装好的burp suite的用户选项标签页打开，设置相应的字体大小等诸多参数，重启之后即可使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20fc5d033113017101f3bc66344af3f8/" rel="bookmark">
			网络安全学习框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全
网络基础
* 网络概述
*
行业背景+就业方向+课程体系结构
*
VMware
*
IP地址的概述与应用
*
DOS命令与预处理
*
Windows服务安全
* 用户管理
*
破解系统用户密码
*
NTFS权限
*
文件服务器
*
Windows安全基线——Windows sever 2003安全配置基线
*
路由交换技术
* 回顾Windows服务
*
OSI协议簇
*
交换机的基本原理与配置
*
IP包头分析与静态路由
*
高级网络技术
* 回顾
*
三层交换
* ACL-1
*
ACL-2
*
网络安全基线——Cisco基础网络设备安全配置基线
*
安全设备防护
* 防火墙原理及部署方式
*
防火墙高级配置
*
IDS
*
WAF
*
服务安全
* Linux安全运维
* Linux操作系统介绍与安装以及目录结构分析
*
Linux系统的基本操作与软件安装
*
Linux系统下用户以及权限管理
*
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20fc5d033113017101f3bc66344af3f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a1c1b43cc85bb39ed6cb679b00b70f/" rel="bookmark">
			C语言进阶 ~ 内存四区（栈、堆、全局、代码区）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特别声明：该部分是根据B站大佬---什么都想干好的视频学习而来。
目录
1.1 数据类型本质分析
1.1.1 数据类型概念
1.1.2 数据类型的本质
1.1.3 数据类型的别名
1.1.4 数据类型之 void
1.2 变量的本质分析
1.2.1 变量的概念
1.3 程序的内存四区模型
1.3.1 全局区（全局变量、静态变量（const，constant或final等）、文字常量区）
1.3.2 栈区（栈区(stack) :① 由编译器自动分配释放，存放函数的参数值，局部变量的值等。② 函数运行时分配，函数结束时释放。由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。）
1.3.3 堆区(heap) : 一般由程序员分配释放(动态内存申请与释放)，若程序员不释放，程序结束时可能由操作系统回收。
1.4 函数的调用模型
1.5 栈的生长方向和内存存放方向
1.1 数据类型本质分析 1.1.1 数据类型概念 “类型”是对数据的抽象 类型相同的数据有相同的表示形式、存储格式以及相关的操作 程序中使用的所有数据都必定属于某一种数据类型 1.1.2 数据类型的本质 数据类型可理解为创建变量的模具：是固定内存大小的别名。数据类型的作用：编译器预算对象（变量）分配的内存空间大小。 注意：数据类型只是模具，编译器并没有分配空间，只有根据类型（模具）创建变量（实物），编译器才会分配空间。 #include &lt;stdio.h&gt; int main(void) { int a = 10; //告诉编译器，分配4个字节的内存 int b[10]; //告诉编译器，分配4*10 = 40 个字节的内存 printf("b:%p, b+1: %p, &amp;b:%p, &amp;b+1: %p\n", b, b + 1, &amp;b, &amp;b + 1); //b+1 和 &amp;b+1的结果不一样 （+1 ---&gt; +4; +1 ---&gt; +40） //是因为 b 和 &amp;b 所代表的数据类型不一样 //b 代表数组首元素的地址 //&amp;b 代表整体数组的地址 return 0; } b+1 和 &amp;b+1的结果不一样 （+1 ---&gt; +4; +1 ---&gt; +40）是因为 b 和 &amp;b 所代表的数据类型不一样b 代表数组首元素的地址&amp;b 代表整体数组的地址 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4a1c1b43cc85bb39ed6cb679b00b70f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0cab504c823c6b17ca1a7b2bb5710cc/" rel="bookmark">
			PyQt5项目打包成exe文件（pyinstaller）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景之工具/版本 安装环境：Windows7 64bit使用版本Python3.6（需安装pyinstaller）PyQt5 二、pyinstaller安装 打开cmd，输入pip install pyinstaller，回车，即可安装。（Anaconda环境使用：conda install pyinstaller 命令进行安装）。
常用参数说明（pyinstaller -h 来查看参数）：
--icon=图标路径
--noconsole执行生成的exe文件时，不显示控制台。
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
详细参数说明传送门&gt;&gt;&gt;
三、pyinstaller使用 1、打开项目目录（若您用的是Eric+PyQt开发，则此目录会有 *.e4p文件）按住shift点击鼠标右键，选择在此处打开命令窗口。
2、输入如下打包命令：
pyinstaller -F --icon=favicon.ico test.py --noconsole 即可打包成功，当前目录下会生成dist文件夹，包含目标exe文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3934498042d30fabbf92698888ab1f4/" rel="bookmark">
			C&#43;&#43;实现高精度大整数及其运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 高精度大整数头文件结构体通过字符数组赋值输出大整数大整数的比较 大整数的运算大整数之间的加法大整数之间的减法高精度大整数与低精度的乘法高精度除以低精度数,同时返回r为余数其他运算 使用示例例题1(贪心+大整数)题目AC代码 高精度大整数 对于一个数,如果其超过了0x7fffffff,则无法用int存储,如果超过2^63-1则long long也无法存储。因此构造结构体来存储这样的高精度大数。
头文件 #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; 结构体 struct bign{	//存123时: d={3,2,1}llen =3; int d[1000]; int len; bign(){ memset(d,0,sizeof(d)); len = 0;} }; 通过字符数组赋值 bign change(char str[]){	//通过字符串读取大整数 //str[]={'1','2','3'} -&gt;a.b={3,2,1} bign a; a.len = strlen(str); for(int i=0;i&lt;a.len;i++){ a.d[i] = str[a.len-1-i] - '0'; } return a; } 输出大整数 void print(bign a){	//输出大整数 for(int i=a.len-1;i&gt;=0;i--) printf("%d",a.d[i]); return; } 大整数的比较 int compare(bign a,bign b){	//比较a和b的大小,a&gt;b返回1,相等返回0,a&lt;b返回-1 if(a.len&gt;b.len) return 1; if(a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3934498042d30fabbf92698888ab1f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd15d87064afeef1cf71600853c4da13/" rel="bookmark">
			Ant-Design-Vue table 合并单元格，并且添加点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击行，有一个customRow。可以配置点击事件。
单元格的自定义分为两种方式。
一种是：通过template标签。
html部分 // text为dataIndex中的值，data为行数据，index为索引值 &lt;template slot="xxx" slot-scope="text,data,index"&gt; {{text|xxxFormat}} &lt;/template&gt; js部分 //table的columns设定，customRender对应着html中的slot值 columns = [ { title: "列名", dataIndex: "aaa", scopedSlots: { customRender: 'xxx' }}, ] 一种是：customRender。下面给出来的是合并单元格的一段代码。
vm.columns = [ { title: "列名", dataIndex: "aaa", customRender: (text, row, index) =&gt; { var obj = { children: text, attrs: {} } if (index % 2 == 0) { obj.attrs.rowSpan = 2; } else { obj.attrs.rowSpan = 0; } return obj; } }, ]; 在合并单元格的代码中可以看出。obj实际上操作的是td的相关属性。children中的内容是放在td中的。这个内容就类似于上面的template。因为能操作td以及内部的内容，所以这种方法的灵活性更加高。对于单元格合并这种操作来说，只能通过customRender来了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd15d87064afeef1cf71600853c4da13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b2d9759135df5e7dcacf38eb47beb62/" rel="bookmark">
			虚拟机中安装oracle环境并使用plsql，instantclient远程进行连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、涉及到的软件 安装的软件主要有3个，因为3种软件因为版本的不同会出现版本不兼容的情况，所以我目前搭建的环境版本如下：Oracle 12c rease2，plsqldeveloper13,instantclient-basic-windows.x64-12.1.0.2.0。
二、安装过程 在oracle官网上下载oracle 12c：https://www.oracle.com/database/technologies/oracle-database-software-downloads.html，需注册oracle账号
下载完毕后在虚拟机中安装，安装过程可自行在百度上搜索，教程较多。
说一个我遇到的一个很奇葩的问题：在打开安装文件时总是报错：[INS-13001]环境不满足最低要求。但是我是win7 64位系统，与oracle版本应该是不存在这个问题的，最后发现是因为计算机名包含了下划线“_”，才报此错误。oracle 安装完成后，在本机安装plsql和instantclient。
主要是instantclient的配置：
instantclient是免安装的，下载下来后需在根目录中添加文件夹：NETWORK
NETWORK下添加ADMIN文件夹
ADMIN文件夹下添加tnsnames.ora文件
添加内容如下：IP为虚拟机的IP。
ORCL =
(DESCRIPTION =
(ADDRESS_LIST =
(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168..)(PORT = 1521))
)
(CONNECT_DATA =
(SERVICE_NAME = orcl)
)
) 配置环境变量：
NLS_LANG
AMERICAN_AMERICA.AL32UTF8
TNS_ADMIN
F:\tools\instantclient-basic-windows.x64-12.1.0.2.0\instantclient_12_1\NETWORK\ADMIN
instantclient的配置内容完毕，然后是进入plsql，先无登录进入，点击首选项，进行oracle的连接配置。
两个输入框分别为：
F:\tools\instantclient-basic-windows.x64-12.1.0.2.0\instantclient_12_1
F:\tools\instantclient-basic-windows.x64-12.1.0.2.0\instantclient_12_1\oci.dll
设置完毕后退出plsql重新登录，登录时输入oracle的system用户及账号，数据库选择tnsnames.ora中配置的orcl，登录成功则已成功远程到虚拟机的oracle。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/036327e521a6e64fb4a1427da5607831/" rel="bookmark">
			一文了解各大图数据库查询语言（Gremlin vs Cypher vs nGQL）| 操作入门篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章的开头我们先来看下什么是图数据库，根据维基百科的定义：图数据库是使用图结构进行语义查询的数据库，它使用节点、边和属性来表示和存储数据。
虽然和关系型数据库存储的结构不同（关系型数据库为表结构，图数据库为图结构），但不计各自的性能问题，关系型数据库可以通过递归查询或者组合其他 SQL 语句（Join）完成图查询语言查询节点关系操作。得益于 1987 年 SQL 成为国际标准化组织（ISO）标准，关系型数据库行业得到了很好的发展。同 60、70 年代的关系型数据库类似，图数据库这个领域的查询语言目前也没有统一标准，虽然 19 年 9 月经过国际 SQL 标准委员会投票表决，决定将图查询语言（Graph Query Language）纳为一种新的数据库查询语言，但 GQL 的制定仍需要一段时间。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FUrKYa4B-1583375942780)(https://user-images.githubusercontent.com/38887077/75741236-f357d380-5d44-11ea-8c43-65283b49bbef.png)]
介于市面上没有统一的图查询语言标准，在本文中我们选取市面上主流的几款图查询语言来分析一波用法，由于篇幅原因本文旨在简单介绍图查询语言和常规用法，更详细的内容将在进阶篇中讲述。
图查询语言·介绍 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TXof8o9B-1583375942786)(https://user-images.githubusercontent.com/38887077/75741240-f5ba2d80-5d44-11ea-80f6-f44d39fff43a.png)]
图查询语言 Gremlin Gremlin 是 Apache ThinkerPop 框架下的图遍历语言。Gremlin 可以是声明性的也可以是命令性的。虽然 Gremlin 是基于 Groovy 的，但具有许多语言变体，允许开发人员以 Java、JavaScript、Python、Scala、Clojure 和 Groovy 等许多现代编程语言原生编写 Gremlin 查询。
支持图数据库：Janus Graph、InfiniteGraph、Cosmos DB、DataStax Enterprise(5.0+) 、Amazon Neptune
图查询语言 Cypher Cypher 是一个描述性的图形查询语言，允许不必编写图形结构的遍历代码对图形存储有表现力和效率的查询，和 SQL 很相似，Cypher 语言的关键字不区分大小写，但是属性值，标签，关系类型和变量是区分大小写的。
支持图数据库： Neo4j、RedisGraph、AgensGraph
图查询语言 nGQL nGQL 是一种类 SQL 的声明型的文本查询语言，nGQL 同样是关键词大小写不敏感的查询语言，目前支持模式匹配、聚合运算、图计算，可无嵌入组合语句。
支持图数据库：Nebula Graph
图查询语言·术语篇 在比较这 3 个图查询语言之前，我们先来看看他们各自的术语，如果你翻阅他们的文档会经常见到下面这些“关键字”，在这里我们不讲用法，只看这些图数据库常用概念在这 3 个图数据库文档中的叫法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/036327e521a6e64fb4a1427da5607831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4a6779efe1653e190baa7f49f5429c/" rel="bookmark">
			如何将二维数组转化为一维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天碰到一道面试题，如何将二维数组转化为一维 数组
问题是这样子的：[[0, 1], [2, 3], [4, 5]] 如何转化为 [0, 1, 2, 3, 4, 5]？
方法一：使用ES5的reduce reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。
arr.reduce(callback,[initialValue]) callback （执行数组中每个值的函数，包含四个参数）
1： previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
2：currentValue（数组中当前被处理的元素）
3：index （当前元素在数组中的索引）
4：array （调用 reduce 的数组）
initialValue （作为第一次调用 callback 的第一个参数。）
var arr=[[0,1],[2,3],[4,5]]; var onearr=arr.reduce(function(a,b){ return a.concat(b); }) console.log(onearr);//[0,1,2,3,4,5] 方法二：使用apply（） 语法：apply([thisObj[,argArray]])
定义：应用某一对象的一个方法，用另一个对象替换当前对象
var arr=[[1,2],[3,4],[5,6]]; var onearr=[].concat.apply([],arr); console.log(onearr);//[0,1,2,3,4,5] 方法三：使用Array.prototype.flat() flat() 方法会递归到指定深度将所有子数组连接，并返回一个新数组 语法：var newArray = arr.flat(depth)，参数说明：depth，可选，指定嵌套数组中的结构深度，默认值为1。flat()方法会移除数组中的空项。但undefined、null仍会保留。
var arr=[[1,2],[3,4],[5,6]]; var onearr=arr.flat(); console.log(onearr);//[0,1,2,3,4,5] 方法四： 通过将数组转变成字符串，利用str.split(',')函数把字符串分割到数组中实现，但是这样数字全都变成字符串了
var arr1 = [[0, 1], [2, 3], [4, 5]]; 第一种：var arr = (arr1 + '').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e4a6779efe1653e190baa7f49f5429c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37e4d13f5a659711b1af77ed9c6ec35/" rel="bookmark">
			poi批量导入数据时部分数据丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		poi批量导入ecxel表格里的数据时，最后两列单元格里的数据丢失了。 解决思路：
①debug：发现physicalNumberOfCells代表的单元格数量与表格列数不符，这就意味着最后两列的单元格根本没有读取到。
②查阅资料：发现获取单元格列数使用的是getPhysicalNumberOfCells方法，而该方法读取的是不为空的单元格总列数，恰好导入的表格中有两列为空的单元格，故导致读取单元格与实际不符合。
③解决方案：将获取单元格的方法改为获取最后一个不为空单元格列数的方法：getLastCellNum即可解决问题。
总结： poi获取列数的两种方法：
①getPhysicalNumberOfCells：获取不为空的单元格的总列数。
②getLastCellNum：获取最后一个不为空的单元格的列数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72dbe3b09bf27eb2ad330b0b5f1dd990/" rel="bookmark">
			Tensorflow基础7：形状的重设
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tensorflow 基础7：形状的重设 numpy当中reshape可以进行形状的调整
tf中分为静态和动态形状: ts.get_shape:获取形状
tf.reshape():重设形状
with one.as_default(): plh = tf.placeholder(dtype='int32',shape=[3,3,3]) a = tf.constant(np.random.randint(0,100,(2,2,2))) with tf.Session(graph=one) as sess: plh_reshape = tf.reshape(plh,[9,3]) print(sess.run(plh_reshape,feed_dict={plh_reshape:np.random.randint(0,10,(9,3))})) print(a.get_shape()) [[8 8 9]
[5 3 5]
[4 8 1]
[7 8 2]
[1 2 1]
[4 2 2]
[8 8 9]
[6 9 3]
[7 6 9]]
(2, 2, 2)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a4dc06fa2dedbd4c0248db9d2cac70/" rel="bookmark">
			图像处理技术之八：点云图、深度图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度图像 也叫距离影像，是指将从图像采集器到场景中各点的距离（深度）值作为像素值的图像。
获取方法有：激光雷达深度成像法、计算机立体双目视觉成像、坐标测量机法、莫尔条纹法、结构光法。
点云 当一束激光照射到物体表面时，所反射的激光会携带方位、距离等信息。若将激光束按照某种轨迹进行扫描，便会边扫描边记录到反射的激光点信息，由于扫描极为精细，则能够得到大量的激光点，因而就可形成激光点云。点云格式有*.las ;*.pcd; *.txt等。 深度图像经过坐标转换可以计算为点云数据；有规则及必要信息的点云数据可以反算为深度图像
RGB-D 图像中的rgb图片提供了像素坐标系下的x，y坐标，而深度图直接提供了相机坐标系下的Z ZZ坐标，也就是相机与点的距离。
根据 RGB-D 图像的信息和相机的内参，可以计算出任何一个像素点在相机坐标系下的坐标。
根据 RGB-D 图像的信息和相机的内参与外参，可以计算出任何一个像素点在世界坐标系下的坐标。
相机视野范围内，相机坐标系下的障碍物点的坐标，就是点云传感器数据，也就是相机坐标系下的点云数据。点云传感器数据可以根据 RGB-D 图像提供的坐标与相机内参算出来。
所有世界坐标系下的障碍物点的坐标，就是点云地图数据，也就是世界坐标系下的点云数据。点云地图数据可以根据RGB-D 图像提供的坐标与相机内参和外参算出来。
https://blog.csdn.net/go_clever_boy/article/details/102295371?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task
https://blog.csdn.net/ff_xun/article/details/85318093
参考资料
《机器人学、机器视觉与控制》
https://www.cnblogs.com/gaoxiang12/p/4652478.html
http://www.cnblogs.com/cv-pr/p/5719350.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89774d5e9f3e7172dfaf072ec12f7c82/" rel="bookmark">
			为docker设置国内镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker的默认镜像（https://hub.docker.com/）地址，拉取镜像时是比较慢的，经常会超时，有时拉取几个小时。为了加快拉取的时间和速度，需要添加中国的镜像地址
1. 国内加速地址 Docker中国区官方镜像
https://registry.docker-cn.com
网易
http://hub-mirror.c.163.com
ustc
https://docker.mirrors.ustc.edu.cn
中国科技大学
https://docker.mirrors.ustc.edu.cn
阿里云容器 服务
https://cr.console.aliyun.com/
首页点击“创建我的容器镜像” 得到一个专属的镜像加速地址，类似于“https://1234abcd.mirror.aliyuncs.com”
2.添加方式 2.1 添加"https://registry.docker-cn.com" 到 registry-mirrors 数组。 [root@localhost ~]# vim /etc/docker/daemon.json { "registry-mirrors": ["https://registry.docker-cn.com"] } [root@localhost ~]# systemctl restart docker.service 2.2 使用命令方式添加 [root@localhost ~]# dockerd --registry-mirror=https://registry.docker-cn.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c129c7c2a4efab09ee3bca1ba3b10c2/" rel="bookmark">
			fanuc机器人roboguide软件中的程序导入示教器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a79f218813ab9bf772f3f3b17ce2439/" rel="bookmark">
			Python获取字典键对应的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两种方法
当知道字典的键时： unit_rooms={ 3:{301:[1,80],302:[1,80],303:[2,90],304:[2,90]}, 4:{401:[1,80],402:[1,80],403:[2,90],404:[2,90]}, 5:{501:[1,80],502:[1,80],503:[2,90],504:[2,90]} } for i in range(3,6): rooms=unit_rooms[i] print(rooms) 运行结果：
当不知道字典的键时： unit_rooms = {3:{301:[1,80],302:[1,80],303:[2,90],304:[2,90]}, 4:{401:[1,80],402:[1,80],403:[2,90],404:[2,90]}, 5:{501:[1,80],502:[1,80],503:[2,90],504:[2,90]} } for rooms in unit_rooms.values(): print(rooms) 运行结果：
获取字典的值：
for value in DictName.values(): # value的名字可以自行另取 # DictName是要遍历的字典的名称 # .values():是固定的用法 获取键值：
for k,v in DictName.items(): #遍历字典的键值对，k对应键，v对应值 #k,v 的名字可以自己取，DictName是字典名 unit_rooms = {3:{301:[1,80],302:[1,80],303:[2,90],304:[2,90]}, 4:{401:[1,80],402:[1,80],403:[2,90],404:[2,90]}, 5:{501:[1,80],502:[1,80],503:[2,90],504:[2,90]} } for sub_dict in unit_rooms.values(): # 遍历大字典的值，即小字典sub_dict for room,info in sub_dict.items(): print('房间号：%d,方向：%d,面积：%d'%(room,info[0],info[1])) 运行结果：
方向1代表南北，方向2代表东西
把数字替换掉：
unit_rooms = {3:{301:[1,80],302:[1,80],303:[2,90],304:[2,90]}, 4:{401:[1,80],402:[1,80],403:[2,90],404:[2,90]}, 5:{501:[1,80],502:[1,80],503:[2,90],504:[2,90]} } for sub_dict in unit_rooms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a79f218813ab9bf772f3f3b17ce2439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/265a80292469e04ec64a9645c0c8fdb1/" rel="bookmark">
			报错：yum install 安装时报yum doesn&#39;t have enough cached data to continue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yum install 安装时报错 One of the configured repositories failed (未知),
and yum doesn’t have enough cached data to continue. At this point the only
safe thing yum can do is fail. There are a few ways to work “fix” this:
详细信息：
[root@ec-cache ~]# yum install gcc 已加载插件：fastestmirror base | 3.6 kB 00:00:00 One of the configured repositories failed (未知), and yum doesn't have enough cached data to continue. At this point the only safe thing yum can do is fail.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/265a80292469e04ec64a9645c0c8fdb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e25a5a1bf31fb5442335a304ad2237a4/" rel="bookmark">
			新冠病毒爆发如何预防？用Python模拟病毒应对策略（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019年末，在中国武汉爆发的冠状病毒疫情冲击了整个金融市场和实体经济。这座总人口超过千万，春运期间流动人口超过500万的巨型城市的灾难在世界各地引发了一连串蝴蝶效应，也在全球普通民众中引发恐慌。
武汉的这场灾难引发了全球对于城市规划和防疫政策的思考。如果疾病不是在武汉，而是在另一座人口规模更小、人口流动也更弱的城市，它的传染性和感染人数，又会是怎样的故事？
在这篇文章中，我们将讨论当流行病袭击一个城市时产生的影响和应对措施。我们以亚美尼亚首都，人口刚过百万的城市埃里温市为例进行研究，建立数学模型并用Python模拟冠状病毒在该市的传播，研究城市流动模式如何影响疾病的传播。
01
城市流动性
有效、高效和可持续的城市流动性对现代城市的运作至关重要。它已经被证明会直接影响城市的宜居性和经济产出(GDP)。然而，一旦发生疫情，它就会火上浇油，扩大疾病的传播。
那么，让我们先来看看埃里温市在一个平面坐标系上的聚合OD流动网络(Origin-Destination)，以了解城市流动模式的空间结构：
接着，如果我们观察网格的总流入量，我们会看到或多或少的单中心空间组织，其中一些网格的日流入量较高但位于中心之外:
现在，假设一种流行病在城市的任意地点爆发。它将如何传播？我们能做些什么来控制它？
02
流行病学建模
为了回答这些问题，我们将用Python建立一个简单的房室模型来模拟传染病在城市中的传播。
当一种流行病爆发时，其传播动力会有显著变化，这取决于最初感染的地理位置及其与城市其他地区的连接性。这是最近关于城市人口流行病的数据驱动研究得出的最重要见解之一。然而，正如我们将在下文进一步看到的，各种结果都要求采取类似的措施来控制疫情，并在规划和管理城市时考虑到这种可能性。
注：compartmental model，房室模型，也称SIR模型，是一种简化的传染病数学模型。
由于我们的目标是展示城市流行病传播的一般原理，而不是建立一个实时的精确模型，我将参考《自然》杂志的一篇文章，通过简单地修改经典SIR模型即可满足我们的需求。
相关链接：
https://www.nature.com/articles/s41467-017-02064-4
这个模型把人口分成三部分。在时间t的每个位置i，其三个房室如下：
Si,t：尚未感染或易感的人数
Ii,t：感染疾病并有能力将疾病传播给易感人群的人数
Ri,t：由于康复或者死亡，在被感染后从受感染组中移除的人数。这个群体中的个体没有能力再次感染该疾病或将感染病传染给他人。
在我们的模拟中，时间将是一个离散变量，因为系统的状态是以日为单位进行建模的。在t时刻j点的完全易感人群中，感染病出现的概率为：
βt是t时刻的传输率
mj,k是从k地到j地的流动性
xk,t 和yk,t 代表t时刻k地和j地的感染和易感人群数
其中xk,t = Ik,t / Nk，yj,t = Sj,t / Nj，Nk和Nj代表k地和j地的人口总数。然后，我们继续模拟一个随机过程，将这种疾病引入完全易感人群所在的地区,其中Ij，t+1是概率为h(t,j)的伯努利随机变量。
一旦感染在随机地点出现，疾病不仅会在该地点传播，还会通过携带者传播到他处。这就是以OD流矩阵为特征的城市流动模式发挥关键作用的地方。
此外，为了确定疾病是如何通过感染者传播的，我们需要考虑其R0值。此处，其中y表示的是治愈率，也可以认为是二次感染率。在撰写本文时，新型冠状病毒的基本再生数估计值在1.4到4之间。凡事做最坏的准备，因此我们假设R0值为4。需要注意的是，R0值是一个有期望值的随机变量。为了让事情更有趣一点，我们在每个地区采用不同的R0值进行模拟，其中R0值服从均值为4的伽玛分布:
现在我们来讨论所建立的模型：
βk,t是t时刻k地的转移率
α是刻画出行方式倾向的参数
上述的模型十分简洁：为了求得t + 1时刻的j地的尚未感染或易感的人数，我们需要从t时刻的j地的尚未感染或易感的人数中减去j地本地感染的人数（第一个方程的第二部分），还要减去从其他地方来到j地的感染者数，这些外来的感染者通过其传输率进行加权计算（第一个方程的第三部分）。
由于总人口数Nj = Sj + Ij + Rj，我们需要将减去的部分移至感染组，同时将治愈的部分移至Rj,t+1(第二个和第三个方程)。
03
仿真建立
在此分析中，我们将使用由当地共乘公司gg提供的GPS数据获得的一个典型日的总OD流量矩阵作为埃里温市交通模式的代表。
接下来，我们需要每个250×250m网格单元的人口计数，通过按比例缩放提取的流量计数来近似计算，从而使不同位置的总流入量之和接近埃里温市110万人口的一半。这是一个大胆的假设，但对结果影响不大。
04
减少公共交通？
第一次模拟，我们将模拟背景设定为一个高度依赖公共交通的未来城市，设定流动率α=0.9：
可以看到，经过大约8-10天左右的时间感染人数比例迅速增加至70%，达到峰值，但此时仅有小部分（约10%）的人康复。至100天时，疫情逐渐缓解，康复人数比例达到了惊人的90%！
现在，我们再来看一下如果将公共交通强度α降低至0.2时，是否有利于缓解传染病的传播。这可以解释为采取严厉措施来降低城市流动性（例如实施宵禁），或者增加私家车出行比例，以减少人们出行期间感染的机率。
可以发现在这种假设下，疫情在16至20天左右到达顶峰，峰值感染人数比例明显降低（约45%），并且此时康复人数为之前的两倍（约20%）。在疫情结行将结束时，易感染人群比例也是之前的两倍（约24% vs. 约12%），这意味着更多的人躲过了这场疫情。正如人们所期望的，通过实施严厉的管控措施来临时降低城市的流动性对于减少传染病传播有明显作用。
05
隔离热门区域？
接着，再来看另一个直观想法——隔离一些关键区域能否得到预期的效果。为了测试这一想法，先挑选人流量位于前1%的区域：
接着完全限制这些区域的进出，建立有效的隔离制度。从这张图我们可以看出，在埃里温市这些位置主要位于市中心，另两个位置是两家最大的购物商场。将α取中间值，即0.5，我们得到如下结果：
感染人数比例的峰值更小了（约35%），并且更重要的是，在疫情行将结束时，大约一半的人未被感染，说明该种方法能够帮助人们有效的降低感染风险！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e25a5a1bf31fb5442335a304ad2237a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/333a6484fd4143a636c546fe134d7f67/" rel="bookmark">
			Linux 查看内存使用情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 . top : 用于实时显示 process 的动态
PID：进程的ID　USER：进程所有
PR：进程的优先级别，越小越优先被执
VIRT：进程占用的虚拟内
RES：进程占用的物理内
SHR：进程使用的共享内
S：进程的状态,S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负
%CPU：进程占用CPU的使用
%MEM：进程使用的物理内存和总内存的百分
TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值
COMMAND：进程启动命令名称
2.free：查看系统内存使用情况
total:总计物理内存的大小
used:已使用多大
free:可用有多少
shared:多个进程共享的内存总额
buff/cached:磁盘缓存的大小
free命令主要用于显示内存数量，如下图中内容所表示
free -h 命令
free -m 命令
3.cat /proc/meminfo: 查看RAM使用情况最简单的方法是通过/proc/meminfo
这个动态更新的虚拟文件实际上是许多其他内存相关工具(如：free / ps / top)等的组合显示。
/proc/meminfo列出了所有你想了解的内存的使用情况。
进程的内存使用信息也可以通过/proc/&lt;pid&gt;/statm 和 /proc/&lt;pid&gt;/status 来查看。
Linux服务器CPU100%问题 背景：用户反应我们系统卡顿，开始排查步骤：
1、查消耗cpu最高的进程PID。top -c 显示进程运行信息列表，按下大P，进程按照cpu使用率排序，发现第一位使用率172%，记下PID：6846。
2、根据PID查出消耗cpu最高的线程号。top -Hp 6846，显示一个进程的线程运行信息列表。按下大P，进程按照cpu使用率排序，可以看到前面四个的cpu都是80+%，记下四个线程号，分别是：6849、6850、6851、6852。
3、把上面四个线程的十进制数转成十六进制（printf %x 6849、printf %x 6850、printf %x 6851、printf %x 6852），分别是：
1ac1、1ac2、1ac31、1ac4。
4、根据线程号查出对应的java线程，进行处理。jstack -l 6846 &gt; ./6846.stack，然后执行grep命令，看线程1ac1做了什么
由上图可见，cpu使用率高的线程都在GC task，JVM的GC线程一直在占用大量CPU，然后再搜索一下 项目名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/333a6484fd4143a636c546fe134d7f67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d296b4a00c8f83dc91bc86261ce49cb6/" rel="bookmark">
			数据结构 -- 递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归的三大要素 1.明确这个函数想要干什么
例如，我定义了一个函数，想要算n的阶乘：
// 算 n 的阶乘(假设n不为0) def f(n): return None 第二要素：寻找递归结束条件
所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。
上面那个例子，当 n = 1,2时，那你应该能够直接知道 f(n) 是啥吧？此时，f(1) = 1，f(2) = 2。完善我们函数内部的代码，把第二要素加进代码里面，如下:
#当n为1或者2时，返回的是自己，也意味着函数终止 def f(n): if(n&lt;=2):return n 第三要素：找出函数的等价关系式
第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。
说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即f(n) = n * f(n-1)。
找出了这个等价，继续完善我们的代码，我们把这个等价式写进函数里。如下：
def f(n): if(n&lt;=2):return n else: return n*f(n-1) 常见递归(使用以上思路)： 案例1：斐波那契数列
斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34….，即第一项 f(1) = 1,第二项 f(2) = 1……,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。
1、第一递归函数功能
假设 f(n) 的功能是求第 n 项的值，代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d296b4a00c8f83dc91bc86261ce49cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aeb5ee38c6d5322ec7a34f520898b5f/" rel="bookmark">
			jQuery基本选择器语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本选择器 返回id名的元素 $("#id") 返回标签名的元素 $("标签") 根据给定的元素名匹配元素	$(element) 匹配所有元素	$(*) 返回所有class元素	$(".class名") 返回包含class的所有标签元素列表 $(标签.class名) 将每一个选择器匹配到的元素合并后一起返回	$(1,2,3,...,n) 层次选择器 根据元素之间的层次关系来选取特定元素 选取后代元素	$("ancestor descendant") 选取子元素	$("parent &gt; child") 选取紧接在元素后的next元素	$("prev + next") 选取prev元素后的所有siblings元素$("prev ~ siblings") 基本过滤选择器 选取第一个元素	$("某个标签:first") 选取最后一个元素	$("某个标签:last") 取出所有与给定选择器匹配的元素	$("某个标签:not(类型)") 选取索引时偶数的所有元素，从0开始	$("某个标签:even") 选取索引时奇数的所有元素，从0开始	$("某个标签:odd") 选取索引等于index的元素，从0开始	$("某个标签:eq(index)") 选取索引大于index的元素，从0开始	$("某个标签:gt(index)") 选取索引小于index的元素，从0开始	$("某个标签:lt(index)") 选取所有的标题元素	$("某个标签:header") 选取当前正在执行动画的所有元素	$("某个标签:animated") 内容过滤选择器 主要体现在它所包含的子元素和文本内容上 选取含有文本内容为text的元素	$(标签:contains(文本内容)) 选取不包含子元素或者文本的空元素	$("某个标签:empty") 选取含有选择器所匹配的元素的元素	$("某个标签:has(类型)") 选取含子元素或者文本元素	$("某个标签:parent") 可见性过滤选择器 选取所有不可见的元素	$("标签:hidden") .show()可以让它可见 选取所有可见的元素	$("标签:visble") 属性过滤选择器 选取拥有此属性的元素	$(标签[属性]) 选取指定属性的值为？的元素	$(标签[属性=？]) 选取指定属性的值不为？的元素	$(标签[属性!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aeb5ee38c6d5322ec7a34f520898b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016da538c0f9951491f8177383a9a1b8/" rel="bookmark">
			【微信小程序】base64转为本地图片详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序在生成海报过程中，需要在海报里生成对应商品id的二维码，可以使用字符串将其转化为二维码图片，因图片格式为base64，所以在微信开发者工具可以查看，但是手机上测试却无法显示，需要把base64图片转为本地图片
1.新建base64src.js文件
// 小程序分享二维码是base64格式，在生产分享图片时，需要转换为图片格式
const fsm = wx.getFileSystemManager(); const FILE_BASE_NAME = 'file_base64src'; //自定义文件名 function base64src(base64data, cb) { const [, format, bodyData] = /data:image\/(\w+);base64,(.*)/.exec(base64data) || []; if (!format) { return (new Error('ERROR_BASE64SRC_PARSE')); } const filePath = `${wx.env.USER_DATA_PATH}/${FILE_BASE_NAME}.${format}`; const buffer = wx.base64ToArrayBuffer(bodyData); fsm.writeFile({ filePath, data: buffer, encoding: 'binary', success() { cb(filePath); }, fail() { return (new Error('ERROR_BASE64SRC_WRITE')); }, }); }; export { base64src }; 2、在需要使用的文件中引入并使用
import { base64src } from '../utils/base64src.js' Page({ data: { shareImage: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/016da538c0f9951491f8177383a9a1b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/507ef5c8ca3aeccfd734f3d62f51f2c0/" rel="bookmark">
			ansible register详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们需要判断对执行了某个操作或者某个命令后，如何做相应的响应处理，也就是说在ansible的playbook中task之间的相互传递变量。
例如以下的yaml文件，该yaml文件要实现的功能是：打包一个文件夹，然后改变这个压缩包的名称，用ip命名该压缩包。
--- - hosts: all gather_facts: no tasks: - name: tar_file shell: "cd /appslog/scans/ &amp;&amp; tar -zcf scan.tar.gz log/" become: true become_method: su become_user: root ignore_errors: yes - name: register vars shell: ifconfig | grep -A 2 bond0 | grep netmask | awk '{print $2}' register: info - name: mv_file shell: mv /appslog/scans/scan.tar.gz /appslog/scans/{{ item }}.tar.gz with_items: "{{ info.stdout }}" become: true become_method: su become_user: root ignore_errors: yes 第一个任务就是用shell模块，执行打包命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/507ef5c8ca3aeccfd734f3d62f51f2c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f215f88c9e2c8646e5d591c167811c1/" rel="bookmark">
			hive调优之map task数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：
1.当输入文件超过mapred.max.split.size大小时，以Math.max(minSize,Math,min(maxSize,blockSize))为单位（以他的倍数）切分成不大于mapred.max.split.size大小的split分片。其余的生成碎片文件如果大于nodeSize就生成split，否则待处理
2.当输入文件小于mapred.min.split.size大小时，进行合并文件生产split分片，但是合并的当前文件要小于maxSize。其余的生成碎片文件如果大于nodeSize就生成split，否则待处理
第二步：
1.合并同一个节点的碎片，合成条件满足不小于nodeSize（mapred.min.split.size.per.node）
2.合并同一个机架的碎片，合成条件满足不小于rackSize（mapred.min.split.size.per.rack）
3.合并不同机架的碎片，合成条件只要长度超过mapred.max.split.size就合并成一个split, 剩下的碎片无论长度, 合并成一个split
备注：如果设置mapred.combine.input.format.local.only=false时，在切分完之后，发现split小于maxSize时，就进行合并，并且是挂节点和挂机架的合并，这个要慎用
**例题1：**输入目录下五个文件,rack1下三个文件,长度为2050,1499,10, rack2下两个文件,长度为1010,80. 另外blockSize为500.
mapred.max.split.size=1000
mapred.min.split.size.per.node=300
mapred.min.split.size.per.rack=100
第一步：
rack1 split：1000 1000 1000 499 碎片：50 10
rack2 split: 1000 碎片：10 80
第二步：
rack1 split：1000 1000 1000 499 碎片：50+10
rack2 split: 1000 碎片：10+80
第三步：
rack1 split：1000 1000 1000 499
rack2 split: 1000 碎片（50+10）+（10+80）=150
以上例题是理想情况下，一般的话可能出现同一个文件在不同节点上出现，所以我们通过这种方式是计算的大概。
所以：
以上例题是理想情况下，一般的话可能出现同一个文件在不同节点上出现，所以我们通过这种方式是计算的大概。
所以：
当增加map task数量时：
要尽量拆分文件，调小maxSize（如果文件大于maxSize时，就要切分）
要避免合并文件，调小minSize（默认就行，默认大小为1，如果文件小于minSize就要合并文件，而此时文件都不具备合并条件，所以切分出的split数量就多）
当减小map task数量时：
要尽量合并文件，适量调大minSize（minSize &lt; maxSize ,如果minSize大于文件时，就具有合并文件，需要合并多大文件还需要看maxSize的大小，当前合并的文件如果超过maxSize就不能合并了，比如文件，a=123,b=423,c=843,maxSize=500,当a,b合并后为546，在合并c时，发现已经大于500了，就不在合并了）
要避免拆分文件，调大maxSize
备注：
maxSize=mapred.max.split.size
minSize=mapred.min.split.size
nodeSize=mapred.min.split.size.per.node
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f215f88c9e2c8646e5d591c167811c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb2a9fe8ad81f615d107f2ce4e1d64ae/" rel="bookmark">
			SaltStack之salt-ssh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. salt-ssh介绍1.1 salt-ssh的特点1.2 salt-ssh远程管理的方式 2. salt-ssh管理2.1 通过使用用户名密码的SSH实现远程管理 1. salt-ssh介绍 salt-ssh可以让我们不需要在受控机上安装salt-minion客户端也能够实现管理操作。
1.1 salt-ssh的特点 远程系统需要Python支持，除非使用-r选项发送原始ssh命令salt-ssh是一个软件包，需安装之后才能使用，命令本身也是salt-sshsalt-ssh不会取代标准的Salt通信系统，它只是提供了一个基于SSH的替代方案，不需要ZeroMQ和agent
注意，由于所有与Salt SSH的通信都是通过SSH执行的，因此它比使用ZeroMQ的标准Salt慢得多 1.2 salt-ssh远程管理的方式 salt-ssh有两种方式实现远程管理，一种是在配置文件中记录所有客户端的信息，诸如 IP 地址、端口号、用户名、密码以及是否支持sudo等；另一种是使用密钥实现远程管理，不需要输入密码。
2. salt-ssh管理 在 master 上安装 salt-ssh
[root@master ~]# yum -y install salt-ssh 2.1 通过使用用户名密码的SSH实现远程管理 修改配置文件，添加受控机信息
[root@node01-linux ~]# vim /etc/salt/roster [root@node01-linux ~]# cat /etc/salt/roster # Sample salt-ssh config file #web1: # host: 192.168.42.1 # The IP addr or DNS hostname # user: fred # Remote executions will be executed as user fred # passwd: foobarbaz # The password to use for login, if omitted, keys are used # sudo: True # Whether to sudo to root, not enabled by default #web2: # host: 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb2a9fe8ad81f615d107f2ce4e1d64ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd04616757eb13fc6628d61a7a8966bb/" rel="bookmark">
			CountDownLatch详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 CountDownLatch中count down是倒数的意思，在构造CountDownLatch的时候需要传入一个整数n，在这个整数“倒数”到0之前，主线程需要等待，而这个“倒数”过程则是由各个执行线程驱动的，每个线程执行完一个任务“倒数”一次。总结来说，CountDownLatch的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行。CountDownLatch主要有两个方法：countDown()和await()。countDown()方法用于使计数器减一，其一般是执行任务的线程调用，await()方法则使调用该方法的线程处于等待状态，其一般是主线程调用。需要注意的是，countDown()方法并没有规定一个线程只能调用一次，当同一个线程调用多次countDown()方法时，每次都会使计数器减一；另外，await()方法也并没有规定只能有一个线程执行该方法，如果多个线程同时执行await()方法，那么这几个线程都将处于等待状态，并且以共享模式享有同一个锁 使用场景 CountDownLatch非常适合于对任务进行拆分，使其并行执行，比如某个任务执行2s，其对数据的请求可以分为五个部分，那么就可以将这个任务拆分为5个子任务，分别交由五个线程执行，执行完成之后再由主线程进行汇总，此时，总的执行时间将决定于执行最慢的任务，平均来看，还是大大减少了总的执行时间。另外一种比较合适使用CountDownLatch的地方是使用某些外部链接请求数据的时候。比如图片，我们使用的图片服务只提供了获取单个图片的功能，而每次获取图片的时间不等，一般都需要1.5s~2s。当我们需要批量获取图片的时候，比如列表页需要展示一系列的图片，如果使用单个线程顺序获取，那么等待时间将会极长，此时我们就可以使用CountDownLatch对获取图片的操作进行拆分，并行的获取图片，这样也就缩短了总的获取时间。 使用实例 public class Test { public static void main(String[] args) throws InterruptedException { CountDownLatch latch = new CountDownLatch(5); Service service = new Service(latch); Runnable task = () -&gt; service.exec(); for (int i = 0; i &lt; 5; i++) { Thread thread = new Thread(task); thread.start(); } System.out.println("main thread await. "); latch.await(); System.out.println("main thread finishes await. "); } } class Service { private CountDownLatch latch; public Service(CountDownLatch latch) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd04616757eb13fc6628d61a7a8966bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde4598e17e17f3f4fc9d1cf6be24be6/" rel="bookmark">
			Unity3d中场景漫游的制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习Unity 3D漫游制作，发现这篇博文，转载过来，感谢原作者，Unity3d中场景漫游的制作
Unity3d中场景漫游的制作，非常方便！！！
首先在3d软件中准备好模型，我找了个maya制作的房子。
注意：我这里用的是真实世界的比例，旁边测量工具测量的是1000cm,10米高.
导出fbx格式文件。
注意： 勾选光滑组输出，设置单位为厘米，Y轴朝上。
3. 新建一个unity项目：
勾选你将来要用到的引擎自带的几个资源包例如：
Character Controller.unityPackage（这个里面有一个第一人称控制，一个第三人称控制。）
Particles.unityPackage
Skyboxes.unityPackage天空盒
Terrain Assets.unityPackage地形素材包
或者先新建一个空的项目，再open打开Program Files\Unity\Editor\Standard Packages目录下的这些. unityPackage文件，效果是一样的。
把fbx文件和贴图用鼠标拖进这里，表给我说你连用鼠标拖拽都不会。
我的fbx文件名是Building01,贴图放textures目录里了。这直接把texutres目录拖进来。
5. 把Building01拖进Hierarchy栏或者直接拖进编辑窗口，区别是一个自动放在0点位置，一个在你松鼠标 的位置。
6. 创建一个地形：
Terrain-&gt;Create Terrain创建，Terrain-&gt;Set Resolution设置地形参数，宽高长红线画的。
7. 点选地形，选择绘制地形贴图笔刷，点击Edit Textures,从项目栏选张贴图拖到4的位置，然后点Add.然后刷吧！！！树和草也是用相同的流程建立的，草也是拖张贴图上去，
树则是拖一个实现做好的prefab,你可以从Unity官网上下一个地形资源包里面有树，草，石头，地形贴图免费的！！！Unity还有个类似Speedtree的内置工具，你可以用它做自己需要的树并方便的调整造型什么的，有兴趣可以自己研究下。
8.点击GameObject-&gt;Create Other-&gt;Directional Light建立方向光,勾选Shadow Type中的软阴影，哈！！可以
看见影子了，其他的颜色啊强度参数自己试试调整吧。
注意：只有Pro版才能打开光影效果，免费版试用版是没这个功能的。也不能生成可运行文件。
9.现在放个人进去跑跑。
第一人称或者第三人称随你选。这个是Character Controller.unityPackage资源包里面的，在创建项目的时候可别忘记勾选这个资源包哦！！
真的很方便，unity把很多东西都给你预备好了，快来试试吧！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb1ad0d090b91a753daab4ab6b6eb03/" rel="bookmark">
			C#示波器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先上界面（VisualStudio2013旗舰版-64位）
参考JScope编写的上位机曲线界面，可增加最多6条数据线（在dataGridView1上右键即可），可改变曲线颜色；
接收总点数（每单条线）有限制Int32.MaxValue / 4;
在显示刷新时，建议显示总点数尽量不要太大，否则会刷新过慢
2、注意事项
1）自定义控件直接放在一个Form中刷新显示，会比直接在一个界面上刷新显示慢点；
2）默认是3条数据线，如果想要修改可修改“”public static int DefineActualLineCount = 3;//定义实际显示的线条数量“”
3)串口解析数据在“UsartScope.cs”中，需要特别注意串口解析数据，否则会丢包
3、添加数据
以添加三条数据为例，在串口接受事件中添加以下代码
if (CustomScopeControl.TestCustomJScope_1.myScope1.MyScopeAxis.ScopeEnableDrawState == true) { CustomScopeControl.TestCustomJScope_1.myScope1.AddSourceData(data1Temp, 0); CustomScopeControl.TestCustomJScope_1.myScope1.AddSourceData(data2Temp, 1); CustomScopeControl.TestCustomJScope_1.myScope1.AddSourceData(data3Temp, 2); CustomScopeControl.TestCustomJScope_1.myScope1.Refresh_Scope(); } 4、自定义示波器实例代码请参考以下链接
https://download.csdn.net/download/feiyingzaishi/12205112
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e2ed822e89ac9cf842c15a9f6d6999/" rel="bookmark">
			---Linux 下Java6(1.6)通用安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java6就是Java1.6, 有些在Java6下开发程序，在新版的Java7+，会有问题出错跑不起来，就得按装它了。
网上大部分安装方法都不能用了, 原因是Sun被Oracle收购了之后，应该是管理加强，收紧了发布控制，
只能用这种Linux 的常规通用方法, 我自己有时候觉得这种安装方法的好处是：
１) 易于管理，Linux通用，容易迁移
２) 建议尽力采用这种简单的发布方式
1. 安装： mkdir java
cd java
#下载 https://download.csdn.net/download/bzhao/12204377
7z x jdk-6u45-linux-x64.bin.7z
chmod +x ./jdk-6u45-linux-x64.bin
./jdk-6u45-linux-x64.bin
２．使用：
vim ./java6.env: (创建环境文件)
export JAVA_HOME=/home/bill/java/jdk1.6.0_45
export CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$JAVA_HOME/bin:$PATH
每次跑java6的程序前：
source ./java6.env 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8312bbab739cfd9e73a71d3b5aae61c2/" rel="bookmark">
			逻辑函数(表示方法、形式转换、化简、最小项、最大项)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑函数：
若以逻辑变量为输入，运算结果为输出，则输入变量取值确定以后，输出的取值也随之而定。输入与输出之间是一种函数关系。
如：Y=F（A,B,C……）
在二值逻辑中，输入、输出都只有两种取值：0、1。
【1. 逻辑函数的表示方法】 真值表、逻辑式、逻辑图、波形图。
真值表
逻辑式
将输出与输入之间的逻辑关系用与、或、非的运算式进行表示。
逻辑图
用逻辑图形符号标识逻辑运算关系，与电路的实现相对应。波形图
将输入变量所有取值组合与对应输出按时间顺序排列，画成波形。 【2. 逻辑函数形式的变换】 1. 波形图→真值表
从波形图上找出每个时间段里输入变量与函数输出的取值，然后将这些输入、输出取值对应列表，就得到了所求的真值表。即穷举。
2. 真值表→波形图
将真值表中所有的输入变量与对应的输出变量取值依次排列成以时间为横轴的波形。
3. 真值表→逻辑式
①找出真值表中使逻辑函数Y=1的那些输入变量取值的组合。
②每组输入变量取值的组合对应一个乘积项，其中取值为1的写入原变量，取值为0的写入反变量。
③将这些乘积项相加，即得Y的逻辑式。
5. 逻辑式→真值表
将输入变量取值的所有组合状态逐一带入逻辑式求出函数值，即得真值表。
6. 逻辑式→逻辑图
用逻辑图形符号代替逻辑函数式中的逻辑运算符号并按运算优先顺序将它们连接起来即可。
7. 逻辑图→逻辑式
从逻辑图的输入端到输出端逐级写出每个图形符号的输出逻辑式，即可在输出端得到逻辑式。
【3. 逻辑函数的化简】 逻辑式的最简形式
以最简与或逻辑式为例：
（1）包含的与项已经最少。
（2）每个与项的因子也已经最少。
公式化简法：
反复应用基本公式和常用公式，消去多余的与项和多余的因子。
PS：化简的过程、结果不唯一。
【4. 逻辑函数的最小项】 1. 最小项
在有n个变量的逻辑函数中，若m为包含n个因子的乘积项，而且这n个变量均以原变量或反变量的形式在m中出现一次，则称m为该组变量的最小项。
即：包含所有变量且每个变量只出现一次的乘积项。
2. 最小项的编号
3. 最小项的性质
①对于n变量逻辑函数有2^n个最小项。
②在输人变量的任一取值下，有且仅有一个最小项的值为1。
③全体最小项之和为1。
④任意两个最小项的乘积为0。
⑤具有相邻的两个最小项之和可以合并，消去一对公因子，只留下公共因子。
相邻：仅一个因子不同的最小项。
如：A’BC’ 和 A’BC
A’BC’+A’BC=A’B(C+C’)=A’B
【5. 逻辑函数的最大项】 1. 最大项
在有n个变量的逻辑函数中，若M为n个变量之和，且每个变量均以原变量或反变量的形式在M中出现一次，则M为该组变量的最大项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8312bbab739cfd9e73a71d3b5aae61c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccfa7816a80202fefae8b942d2e82103/" rel="bookmark">
			并发编程系列（十）—深入理解共享锁和ReentrantReadWriteLock
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文对Java的“共享锁”进行介绍，JUC中的共享锁有CountDownLatch, CyclicBarrier, Semaphore, ReentrantReadWriteLock等；本章会以ReentrantReadWriteLock为例对共享锁进行说明。内容包括
ReadWriteLock 和 ReentrantReadWriteLock介绍ReadWriteLock 和 ReentrantReadWriteLock函数说明ReentrantReadWriteLock 类图结构ReentrantReadWriteLock原理ReentrantReadWriteLock示例 ReadWriteLock 和 ReentrantReadWriteLock介绍 ReadWriteLock维护了一对相关的锁 — — “读取锁”和“写入锁”，一个用于读取操作，另一个用于写入操作。
“读取锁”用于只读操作，它是“共享锁”，能同时被多个线程获取。
“写入锁”用于写入操作，它是“独占锁”，写入锁只能被一个线程锁获取。
注意：不能同时存在读取锁和写入锁！
ReadWriteLock 和 ReentrantReadWriteLock函数说明 // 返回用于读取操作的锁。 Lock readLock() // 返回用于写入操作的锁。 Lock writeLock() // 创建一个新的 ReentrantReadWriteLock，默认是采用“非公平策略”。 ReentrantReadWriteLock() // 创建一个新的 ReentrantReadWriteLock，fair是“公平策略”。fair为true，意味着公平策略；否则，意味着非公平策略。 ReentrantReadWriteLock(boolean fair) // 返回一个 collection，它包含可能正在等待获取读取锁的线程。 protected Collection&lt;Thread&gt; getQueuedReaderThreads() // 返回一个 collection，它包含可能正在等待获取读取或写入锁的线程。 protected Collection&lt;Thread&gt; getQueuedThreads() // 返回一个 collection，它包含可能正在等待获取写入锁的线程。 protected Collection&lt;Thread&gt; getQueuedWriterThreads() // 返回用于读取操作的锁。 ReentrantReadWriteLock.ReadLock readLock() // 返回用于写入操作的锁。 ReentrantReadWriteLock.WriteLock writeLock() ReentrantReadWriteLock 类图结构 从类图结构看出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccfa7816a80202fefae8b942d2e82103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0681c22929d5ce23625863060b9d2b2/" rel="bookmark">
			linux自动解压式安装java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux自动解压式安装java 创建目录下载压缩包解压JDK设置环境变量验证安装 安装java比较快捷的方式是通过yum的apt-get来安装，但是openJdk类库并不是全量的，安装后可能会出现意料之外的错误，所以我建议通过解压的方式来安装。 创建目录 在/usr/local下创建java目录
mkdir /usr/local/java 进入到java目录下 ，通过wget方式下载安装包，下载时间可能会有点慢，耐心等待即可。(当然也可以在本地下载好之后pdf上传都可以)
下载压缩包 到官网获取到所需的安装包路径，下载对应的安装包。
下载linux版本，也许每个人所需的版本不一样，但是只要后缀是.tar.gz就可以了。
这里我下载的32位的版本 jdk-8u241-linux-i586.tar.gz
cd /usr/local/java wget https://download.oracle.com/otn/java/jdk/8u241-b07/1f5b5a70bf22433b84d0e960903adac8/jdk-8u241-linux-i586.tar.gz?AuthParam=1583035440_6e96be618c3af5c7221897cd160c8d02 解压JDK 使用tar命令解压
tar -zxvf ./jdk-8u241-linux-i5.tar.gz 设置环境变量 修改 /etc/profile 文件，配置环境变量
在profile文件末尾添加一下内容并保存 set java environment JAVA_HOME=/usr/local/java/jdk1.8.0_151 JRE_HOME=/usr/local/java/jdk1.8.0_151/jre CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin export JAVA_HOME JRE_HOME CLASS_PATH PATH JAVA_HOLE和JRE_HOME设置为你jdk的安装地址。
2. 使用source使配置生效
source /etc/profile 验证安装 输入 java -version 查看安装结果
如图所示，则为安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28869e44c3a8a048578730356c772a58/" rel="bookmark">
			如何去设计一个深度学习加速器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		How to make your own deep learning accelerator chip! Currently, there are more than 100 companies all over the world building ASICs (Application Specific Integrated Circuit) or SOC’s (System on Chip) targeted towards deep learning applications. There is a long list of companies here. In addition to these startup big companies like Google (TPU), Facebook, Amazon (Inferentia), Tesla etc are all developing custom ASIC’s for deep learning training and inference.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28869e44c3a8a048578730356c772a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2fca1d2c7530f706eb6a10314b961d/" rel="bookmark">
			Game101课程笔记_lecture01_计算机图形学概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lecture01_计算机图形学概述_Game101课程笔记 1 什么是图形学2 为什么要学习图形学1 应用1 video Games 游戏2 movie 电影3 Animations 动画4 Design设计5 Visualization可视化6 虚拟现实7 Augmented Reality 增强现实8 Digital Illustration数字插图9 Simulation仿真10 Graphical User Interfaces --GUI11 Typography字体排版 2 Fundamental Intellectual Challenges3 Technical Challenges 3 课程内容1 光栅化Rasterization2 曲线和曲面Curves and Meshes3 光线追踪Ray Tracing4 动画/仿真Animation/Simulation 4 注意1 不讲OpenGL等API2 不讲3D 建模软件3 计算机视觉和计算机图形学4 参考书 5 视频 1 什么是图形学 计算机图形学（Computer graphics，CG）是研究计算机在硬件和软件的帮助下创建计算机图形的科学学科，是计算机科学的一个分支领域，主要关注数字合成与操作视觉的图形内容。简单的说它与计算机视觉（Computer vision，CV）的区别就是，CG是通过几何图形等构建物体，而CV则是让计算机理解捕捉到的画面，理解物体是什么，CV具有一定的推测性。
2 为什么要学习图形学 1 应用 1 video Games 游戏 什么才是好的画面呢？
标准-看画面是否足够亮！
原因是-在渲染中涉及到一个全局光照，如果全局光照做的好，整个画面就会亮，看起来就会很舒服。如果看的暗就表明在一定程度上的技术不足！
卡通这个效果是如何表现的呢？也是图形学要研究的内容
2 movie 电影 特效，子弹时间！最简单的图形学的应用，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2fca1d2c7530f706eb6a10314b961d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6747e064b9d92bcc67340fb63c9415f3/" rel="bookmark">
			【CSS】滚动条样式的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 优化后的滚动条会提亮我们的网站页面。
例如：CSS-TRICKS这个网站如果采用的是浏览器默认的滚动条，不进行优化，页面会显得很不搭。
所以该网站的滚动条样式优化如下：
html::-webkit-scrollbar { width: 30px; height: 30px; } html::-webkit-scrollbar-thumb { background: -webkit-gradient(linear,left top,left bottom,from(#ff8a00),to(#e52e71)); background: linear-gradient(180deg,#ff8a00,#e52e71); border-radius: 30px; box-shadow: inset 2px 2px 2px hsla(0,0%,100%,.25), inset -2px -2px 2px rgba(0,0,0,.25); } html::-webkit-scrollbar-track { background: linear-gradient(90deg,#201c29,#201c29 1px,#100e17 0,#100e17); } 那么::-webkit-scrollbar、::-webkit-scrollbar-thumb和::-webkit-scrollbar-track是什么以及怎么用请继续往下阅读。
webkit内核下 这些伪元素仅使用在支持webkit的浏览器上（如Chrome和Safari）。
滚动条伪元素作用的位置::-webkit-scrollbar整个滚动条::-webkit-scrollbar-button滚动条上的按钮 (上下箭头)::-webkit-scrollbar-thumb滚动条上的滚动滑块::-webkit-scrollbar-track滚动条轨道::-webkit-scrollbar-track-piece滚动条没有滑块的轨道部分::-webkit-scrollbar-corner当同时有垂直滚动条和水平滚动条时交汇的部分::-webkit-resizer某些元素的corner部分的部分样式(例:textarea的可拖动按钮) 在图上就能更清晰地呈现：
总结：这些伪元素支持Chrome Edge、Opera Safari、Android webview、Chrome for Android、Opera for Android、Safari on iOS和Samsung Internet,不支持Firefox、Internet Explorer和Firefox for Android。所以想要兼容其余浏览器，就得转Trident（IE）内核下目录。
当然webkit提供的不止这些，还有很多伪类，更丰富滚动条样式：
滚动条伪类作用的位置:horizontal适用于任何水平方向上的滚动条:vertical适用于任何垂直方向的滚动条:decrement适用于按钮和轨道碎片。表示递减的按钮或轨道碎片，例如可以使区域向上或者向右移动的区域和按钮:increment适用于按钮和轨道碎片。表示递增的按钮或轨道碎片，例如可以使区域向下或者向左移动的区域和按钮:start适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的前面:end适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的后面:double-button适用于按钮和轨道碎片。判断轨道结束的位置是否是一对按钮。也就是轨道碎片紧挨着一对在一起的按钮。:single-button适用于按钮和轨道碎片。判断轨道结束的位置是否是一个按钮。也就是轨道碎片紧挨着一个单独的按钮。:no-button表示轨道结束的位置没有按钮。:corner-present表示滚动条的角落是否存在。:window-inactive适用于所有滚动条，表示包含滚动条的区域，焦点不在该窗口的时候。 根据这些知识，可以得出CSS-TRICKS这个网站的滚动条样式：
水平滚动条高30px,垂直滚动条宽30px滚动条上的滚动滑块背景色是从上到下#ed4f32渐变到#f5f5f5，边框圆角是30px，内部阴影是x方向上和y方向上平移2px和-2px,阴影颜色分别是hsla(0,0%,100%,.25)和rgba(0,0,0,.25)滚动条轨道背景色渐变 写炫酷的滚动条样式是要积累的。
不会写box-shoadow可以使用Box-shadow_generator生成器
伪元素+伪类更能精准定位达到意想不到的效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6747e064b9d92bcc67340fb63c9415f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c654e01421d81130237fc1a5b845c54/" rel="bookmark">
			excel vba saveas 另存为使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 excel vba 保存代码
Sub 保存工作簿() ThisWorkbook.Save '.save相当于按保存按钮；无参数 ThisWorkbook.SaveAs "另存为工作簿" '把当前工作簿另存为一份新的工作簿 ThisWorkbook.SaveCopyAs "另存一份副本" '另存一份副本为新工作簿，而不关闭当前工作簿。只有一个参数，就是新的文件名。 ThisWorkbook.SaveAs '前三个参数比较关键，均可以不填，全不填差不多相当于.save 'filename,fileformat,password '"第一个参数为名称", "第二个参数为格式", "第三个参数为设置打开密码" '第一个参数可以是全路径名；也可以是不含路径的名称，会保存在原文件所在文件夹 '第二个参数为格式，常用格式设置51即可， '格式参考网址："https://docs.microsoft.com/zh-cn/office/vba/api/excel.xlfileformat" End Sub 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92358f9f93b88c896f44c9d5fd656d1e/" rel="bookmark">
			我的新博客地址-简书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我的新博客地址-简书：https://www.jianshu.com/u/ca154a9151bb 最近开通了简书，欢迎来关注！！！！！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06d8b0cb67f2b3fed1c2ac902e1f84a/" rel="bookmark">
			CentOS 7 搭建docker&#43;vulhub环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、配置yum源 为了更快下载更新的系统和安装软件包，建议将yum源替换为国内源
首先，备份系统自带yum源
cd /etc/yum.repos.d mkdir repo_bak mv *.repo repo_bak 配置阿里云yum源
curl -O http://mirrors.aliyun.com/repo/Centos-7.repo curl -O http://mirrors.aliyun.com/repo/epel-7.repo curl -O http://mirrors.aliyun.com/repo/epel-testing.repo 重新建立yum缓存
yum clean all &amp;&amp; yum makecache 2、安装docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口.
首先，我们得确保 yum 包更新到最新
yum -y update 如果安装过旧版本的话，请先卸载旧版本
yum -y remove docker docker-common docker-selinux docker-engine 安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的
yum install -y yum-utils device-mapper-persistent-data lvm2 使用阿里云Docker Yum源
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum makecache fast 查看所有仓库中所有docker版本，以便选择版本安装
yum list docker-ce --showduplicates | sort -r 安装docker
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b06d8b0cb67f2b3fed1c2ac902e1f84a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f544249bf5e93e3b84a3f3b608e176d/" rel="bookmark">
			LinkedBlockingDeque自动阻塞，put和take方法的阻塞实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LinkedBlockingDeque自动阻塞的双端队列。
增删元素的方法都是用ReentrantLock上锁的。
add方法无返回值，满了报异常，offer方法满了return false，put方法满了await自动阻塞。
以putFirst(E e)为例：
final ReentrantLock lock = new ReentrantLock(); private final Condition notFull = lock.newCondition(); public void putFirst(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; lock.lock(); try { while (!linkFirst(node))//returns false if full. notFull.await(); //实现list满了的情况下就会自动阻塞 } finally { lock.unlock(); } } 以pollFirst()为例，peek，get等方法均不阻塞
public E pollFirst() { final ReentrantLock lock = this.lock; lock.lock(); try { return unlinkFirst(); } finally { lock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f544249bf5e93e3b84a3f3b608e176d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe93eac68ed0f7ac862571903b7d073/" rel="bookmark">
			Supervisor 管理进程服务重启报警（Event &amp; Listener 监控进程并报警）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求： 服务、进程等都被 Supervisor 管理，想实现 被管理的程序异常退出后，或者程序尝试重启多次失败后，Supervisor可以告警通知。
二、实现思路 Event 是在 Supervisor 3.0 引入的一个高级特性，如果只简单使用 Supervisor 管理进程，则不需要了解 Event。
但如果希望监控 Supervisor 管理的进程的各种状态（如: 启动、退出、失败、退出状态码 …）并支持告警，才需要了解Event。
利用 Supervisor 的 Event &amp; Listener 功能进行订阅异常退出事件，并进行报警处理。
Supervisor 官方对其 Event 机制的描述是：一个进程的监控/通知框架。
该机制主要通过一个 event listener 订阅 event 通知实现。当被 Supervisor 管理的进程有特定行为的时候，supervisor 就会自动发出对应类型的 event。即使没有配置 listener，这些 event 也是会发的；如果配置了 listener 并监听该类型的 event，那么这个 listener 就会接收到该 event。 event listener 需要自己实现，并像 program 一样，作为 superviosr 的子进程运行。
三、具体配置实现 1、配置事件监听器 主管事件侦听器是通过 配置文件中的[eventlistener：x]指定的。关于Supervisor [eventlistener：x] 在配置中允许的键方面，几乎与supervisor [program：x]完全一样，只是Supervisor不遵循事件侦听器进程的“捕获模式”输出（即事件侦听器不能是 PROCESS_COMMUNICATIONS_EVENT事件生成器）。因此，在事件``侦听器的配置中指定stdout_capture_maxbytes或 stderr_capture_maxbytes是错误的。可以放入配置文件的事件侦听器部分的数量没有人为限制。
vim /etc/supervisord.d/eventlistener.ini
[eventlistener:mylistener] command=/opt/my_custom_listener.py ; 自定义的监控程序 events=PROCESS_STATE_EXITED,PROCESS_STATE_FATAL,TICK_60 ; 监控事件 ; 下面的配置和`[program：x]`完全一样 autostart=true autorestart=true log_stdout=true log_stderr=true stdout_logfile=/opt/supervisor_event_exited-stdout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fe93eac68ed0f7ac862571903b7d073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce25da40a64e2196c546cd30486e0f0/" rel="bookmark">
			梭哈游戏规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【梭哈游戏规则】
【基本规则】
梭哈游戏使用28张扑克牌，取黑桃、红桃、草花、方片四种花色的8、9、10、J、Q、K、A进行游戏，游戏人数可为2―4人。
游戏开始后，先发给各家2张牌，从第二张牌开始自动亮出，每发一张牌，从牌面较大者逆时针下注。优先下注者可选择下注、不加或放弃；当别人下注后，可考虑是否“跟”或“加”注。当发到第四张牌时，可以选择“梭”，即增加下注到允许的最大筹码值。 最后的胜利者获得本局桌面上的全部筹码，如果输家剩余的筹码数少于规定坐下的最小数额将被请出桌子。
【牌型比较】
牌型：同花顺＞铁支＞葫芦＞同花＞顺子＞三条＞两对＞对子＞散牌
点数：Ａ＞Ｋ＞Ｑ＞Ｊ＞１０＞９＞８
花色：黑桃＞红桃＞草花＞方片
【牌型说明】 同花顺：拥有五张连续数字同花色的顺子，以黑桃Ａ为首的同花顺最大；
铁支：四张相同数字的牌，外加一单张。比数字大小，「Ａ」铁支最大；
葫芦：由「三条」加一个「对子」所组成的牌。若别家也有此牌型，则比三条数字大小；
同花：不构成顺子的五张同花色的牌。比花色后比大小；
顺子：五张连续数字不花色的牌组成。 以A为首的顺子最大，如果大家都是顺子，比最大的一张牌，如果大小还一样就比这张牌的花色，黑桃A顺子最大；
三条：牌型由三张相同的牌组成，以A为首的三条最大；
二对：牌型中五张牌由两组两张同数字的牌所组成。若遇相同则先比这副牌中最大的一对，如又相同再比第二对，如果还是一样，比大对子中的最大花色；
对子：牌型由两张相同的牌加上三张单张所组成。如果大家都是对子，比对子的大小，如果对子也一样，比这个对子中的最大花色
散牌：由单一型态，不构成上面的牌型的五张散牌组成，先比最大一张牌的大小，如果大小一样，比这张牌的花色
等级
初级场：1200金币以上的玩家进入，以10金币为基数
1.临时工
2.正式工=1000 (换装)
3.助理主管=1100 (换装)
4.主管=1300 (换装)
5.助理经理=1700 (不换)
6.经理=2500 (换装)
7.助理总裁=4100 (不换)
8.副总裁=7140 (换装)
9.总裁=12612 (不换)
高级场：22462金币以上的玩家进入，以100金币为基数
10.董事=22462 (换装)
11.副董事长=38222 (不换)
12.董事长=61862 (换装)
13.赌王=94958 (不换)
14.赌圣=154530 (换装)
15.赌神=249845 (不换)
赌神场：383286金币以上的玩家进入，以1000金币为基数
16.老对首富=383286 (换装)
17.中国首富=596791 (不换)
18.亚洲首富=938399 (不换)
19.世界首富=1484971 (不换)
20.财神=2359486 (换装)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e14c72fcb98132a8f7800298af9e43d/" rel="bookmark">
			nginx代理前端VUE项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		user root; worker_processes auto; pid /run/nginx.pid; events { worker_connections 768; } http { sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/conf/mime.types; default_type application/octet-stream; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; access_log /etc/nginx/logs/access.log; error_log /etc/nginx/logs/error.log; gzip on; gzip_disable "msie6"; include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; server { listen 8080; //前端端口 listen 443 ssl; server_name 192.168.140.80;	# 前端地址 # ssl on; ssl_certificate /etc/nginx/1data.crt; ssl_certificate_key /etc/nginx/1data.key; location / { root /root/dist; //前端代码放的路径，将打包生成的dist文件夹放到/root/下 index index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e14c72fcb98132a8f7800298af9e43d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c8fcca50eb7a93d7197c145986d51aa/" rel="bookmark">
			洛谷P1152   欢乐的跳   题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目描述】
一个n个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了[1,n−1]之间的所有整数，则称之符合“欢乐的跳”，如数组1 4 2 3符合“欢乐的跳”，因为差的绝对值分别为：3,2,1。
给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。
【输入】
每组测试数据第一行以一个整数n(1≤n≤1000)开始，接下来n个空格隔开的在[−108，108]之间的整数。
【输出】
对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出"Jolly"，否则输出"Not jolly"。
【输入样例】
4 1 4 2 3
【输出样例】
Jolly
【分析】
解决这个题的方法挺多的，对于下面这个方法，需要明白一个问题：一个数组里如果任意两个连续整数差互不相同，那么他一定满足欢快地跳。知道了这一点，后面的就迎刃而解了。
【代码】
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; int a[100005]={}; int b[100005]={}; int main() { int n,count = 0,c; scanf("%d",&amp;n); scanf("%d",&amp;a[0]);/*先输入数组中第一个数*/ for(int i = 1;i &lt; n; i++) { scanf("%d",&amp;a[i]);/*陆续输入数组中除了第一个元素之外的其他元素*/ c = abs(a[i - 1]-a[i]);/*每输入数组中一个元素就算出这个元素与他的前一个元素的差的绝对值*/ if(b[c] == 0) count++; //如果我们所计算的相邻的两个差没有出现过，那么我们就计数加以 b[c] = 1;//确保统计过的数字不会被重复统计 } if(count == n - 1)/*表明数组中任意两个连续的整数之差都不相等*/ printf("Jolly\n");//满足‘欢快的跳’ else printf("Not jolly\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c8fcca50eb7a93d7197c145986d51aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccc804e2fead65d1d5fe9206c95f8ad5/" rel="bookmark">
			牛客网 python 输入刷题笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：最近在牛客网上刷题，我发现python的输入总是出问题，经常弹出您的结果和测试样例不一致。然后又看到很多程序员和我一样，对牛客网的输入搞不清楚是怎么一回事。于是我刷了一下午加一晚上的数字输入问题，得到答案，和大家分享！希望大家都拿到好offer！
刷题的网站如下：
https://ac.nowcoder.com/acm/contest/320?&amp;headNav=www
1 牛客网的标准python输入(按照这个模式来，后面的都很简单) 首先，题目如图：要我从输入流中得到四个数字，从大佬那里学来的代码给大家整理好了：
import sys for line in sys.stdin: a = line.split() print(int(a[0]) + int(a[1])) 先看第一行 import sys，导入sys模块。sys模块下有一些方法，类什么的，我不知道。再看第二行中的sys.stdin，显然这是一个对象(我不知道是不是，我就当它是对象了)，同时它又写在for循环的末尾，所以这是一个iterable——可迭代对象，它产生的效果是把字符串中的’\n’都去掉，只每一行，放进line中。第一次迭代，line(str类)实际上等于’1 5’,第二次迭代，line(str类)=‘10 20’。分别对两个字符串使用split()方法——split方法无参数，则默认以空格作为分隔符，返回a，a是一个列表对象，第一次迭代完成后，a=[‘1’,’‘5’]，后面的操作就特别简单了，也就是用int函数将它们转化为可加减的int型。
2牛客网刷题遇到测试样例为通过率为0的技巧 如图是我编写的正确的代码，但是不是任何时候都可以得到正确的代码。我将第15行中的output_list改为output，这样会让程序出现error。但是此时编译器只会提示通过率为0%。其输出如下：
刚开始刷题的同学往往找不到问题所在，下午我特别发现了一个办法，先点击界面中的“自测”，得到如下界面：
此时先点1：示例1，再点自我调适，即可在底端看见python中出现error的地方
先跟着图中3看懂错在哪里，然后想好对策即可点击4，回到编程界面！错在哪里都不知道的问题终于解决了！
3解决先输入数量，再输入数据问题的偷鸡方法 题目如下，要我先读入数据的量，也就是2组，或者更多。这只能读一个数字。后面是每一行2个数字，可以参考大标题1中的分割方法进行分割。本章主要解决单独输入的问题
经过尝试，我发现使用input方法先读入这个2，然后输入字符串中‘’2\n’就已经消失在输入字符串中了，此事再用大神的方法进行分割，即可快速的秒杀该题目。
4刷题的答案 代码可以分享给大家：
import sys output_list = [] for lines in sys.stdin: input_list = lines.split(' ') sum=0 for vals in input_list: sum+=int(vals) output_list.append(sum) length=len(output_list) for i in range(length): if i&lt;length-1: print(output_list[i]) elif i==length-1: print(output_list[i]) 看起来很复杂，其实还是1中的东西，一样的。学会这一套，换汤不换药。。
5 小结 经过一下午的努力，终于再也不会在输入中倒下了，7个输入题目全都做出来了，希望接下来能战胜华为的机考，也祝大家刷题愉快
明天把字符串的做了，如果能做出来，还会继续来分享，感谢大家的观看。=.。=
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c56a9457e75f90920545c0fc17e693dd/" rel="bookmark">
			Tensorflow2中load_weights的一些研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设我们定义了一个keras模型,并且使用它的save_weights函数保存了一些参数.现在我们只定义这个模型的一部分,并且使用load_weights去加载我们保存的这个完整的模型,会发生什么?
首先看源代码,load_weights实际上是调用了tensorflow_core/python/keras/engine/network.py文件中Network类的load_weights函数,而在这个函数中,分别对save_format为tf和h5两种类型的文件做了不同的处理,我们这里不是h5文件,那么显然就应该是tf文件.源代码就不贴了,根据源代码,我猜测读取tf文件的函数是tensorflow_core/python/training/tracking/util.py中的TrackableSaver类的restore函数.我在这个函数的doc中发现了这样一句话.
If the checkpoint has not been consumed completely, then the list of restore ops will grow as more objects are added to the dependency graph.
这句话好像在说如果我们的checkpoing文件中的内容没有被全部加载,那么剩下没有加载的变量将会在我们使用这个图的时候动态的加载.
那么来做实验吧.首先我们定义了一个图,就是prosody-tacotron中的global style token(gst)层.这个图有两种模式,'reference'和'weight',在'reference'模式下模型参数会被完全定义,而在'weight'模式下,模型只会定义gst嵌入,而不会定义多头注意力层和卷积层的变量.下面是效果
hp.gst_mode = 'reference' model = get_gst() for i in model.trainable_variables: print(i.name) """ 输出: gst_tokens:0 gst/multihead_attention/attention_v:0 gst/multihead_attention/attention_g:0 gst/multihead_attention/attention_b:0 gst/multihead_attention/conv1d/kernel:0 gst/multihead_attention/conv1d/bias:0 gst/multihead_attention/conv1d_1/kernel:0 gst/multihead_attention/conv1d_1/bias:0 """ hp.gst_mode = 'weight' model = get_gst() for i in model.trainable_variables: print(i.name) """ 输出: gst_tokens:0 """ 我们在'reference'模式下保存模型,并且在'weight'模式下读取模型,然后比较它们是否相同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c56a9457e75f90920545c0fc17e693dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e930b755f2163911fe0db008500bdd0/" rel="bookmark">
			【ASP.NET】终于知道通过ajax异步为什么无法实现模型自动验证了，探索模型验证方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般的，我们在添加信息时，可以通过ModelState快速实现模型验证
[HttpPost] [ValidateAntiForgeryToken] public ActionResult Create(UserInfo userInfo) { if (ModelState.IsValid) { db.UserInfo.Add(userInfo); db.SaveChanges(); return RedirectToAction("Index"); } return View(userInfo); } 效果，自动验证
但是，改用ajax异步操作，就无法通过模型自动验证了
ASP.NET实现ajax异步，要添加jquery.unobtrusive-ajax.js文件，只需在NuGet搜索下载即可
添加引用
&lt;script src="~/Scripts/jquery.unobtrusive-ajax.js"&gt;&lt;/script&gt; 在视图中，需要将@using (Html.BeginForm()) 改为 @using (Ajax.BeginForm())，
@using (Ajax.BeginForm("VerifyUser", "UserInfo", new AjaxOptions() { OnSuccess = "afterCreate" }, new { @class = "form-signin" })) 然后点击确定按钮提交表单，却一直无反应，试过很多次还是无反应
分析 后面，想着想着才知道这是操作，就是视图局部更新，而上面同步的操作，当模型验证失败时通过在整个视图添加错误信息到达验证模型的效果，而异步操作就是局部更新，当然不会执行整个视图的更新，只能通过js代码执行更新操作
当执行后台方法VerifyUser后执行afterLogin方法
对Create方法进行改造
[HttpPost] [ValidateAntiForgeryToken] public ActionResult Create(UserInfo userInfo) { if (ModelState.IsValid) { db.UserInfo.Add(userInfo); db.SaveChanges(); return Content("ok"); } return Content("添加失败"); } 当后台只有返回ok时，才执行跳转，否则则弹框提示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e930b755f2163911fe0db008500bdd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ee5eae8c7581e5756ae78cd669d6af/" rel="bookmark">
			C#学习笔记： 学习资源分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、刘铁猛《C#语言入门详解》全集 2、致远在线课堂-C#教程之自定义控件的开发 3、横刀天笑的碎碎念 - .NET技术面面观 4、进击的NetER-异步多线程专题 5、利用插件系统从头开发项目 6、开放工厂-免费开放的插件仓库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c06759a2644f868709e1dedb951c527/" rel="bookmark">
			node.js | 从控制台获得输入并输出（同步方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		太难了，一下午就找了个同步输入，网上全都是异步方式，我太难了……
process.stdin.setEncoding('utf8'); // This function reads only one line on console synchronously. After pressing `enter` key the console will stop listening for data. function readlineSync() { return new Promise((resolve, reject) =&gt; { process.stdin.resume(); process.stdin.on('data', function (data) { process.stdin.pause(); // stops after one line reads resolve(data); }); }); } // entry point async function main() { let inputLine1 = await readlineSync(); console.log('inputLine1 = ', inputLine1); let inputLine2 = await readlineSync(); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c06759a2644f868709e1dedb951c527/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d89d2efd1bcb3f272138f4e75c34df/" rel="bookmark">
			最新JAVA的NLP工具DJL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、其他：NLP工具包 LingPipe
是alias公司开发的一款自然语言处理软件包。
主题分类（Top Classification） 命名实体识别（Named Entity Recognition） 词性标注（Part-of Speech Tagging） 句题检测（Sentence Detection） 查询拼写检查（Query Spell Checking） 兴趣短语检测（Interseting Phrase Detection） 聚类（Clustering） 字符语言建模（Character Language Modeling） 医学文献下载/解析/索引（MEDLINE Download, Parsing and Indexing） 数据库文本挖掘（Database Text Mining） 中文分词（Chinese Word Segmentation） 情感分析（Sentiment Analysis） 语言辨别（Language Identification） HanLP
HanLP是一系列模型与算法组成的NLP工具包，目标是普及自然语言处理在生产环境中的应用。
FudanNLP
FNLP主要是为中文自然语言处理而开发的工具包，也包含为实现这些任务的机器学习算法和数据集。 本工具包及其包含数据集使用LGPL3.0许可证。
信息检索： 文本分类 新闻聚类 中文处理： 中文分词 词性标注 实体名识别 关键词抽取 依存句法分析 时间短语识别 结构化学习： 在线学习 层次分类 聚类 Apache OpenNLP
OpenNLP支持最常见的NLP任务:
例如标记化，句子分段，词性标记，命名实体提取，分块，解析，语言检测和共指解析 Stanford CoreNLP
斯坦福大学开发的自然语言处理工具套件,包括词性标注、命名实体识别、共指消解等 NLP 任务:
一、简介 开源库以Java构建和部署深度学习、编写一次即可在任何地方运行。使用DJL开发模型并在您选择的引擎上运行。直观的API使用本机Java概念并抽象化了深度学习所涉及的复杂性。引入您自己的模型，或使用我们库中的最新模型在几分钟内进行部署。
二、开源地址：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73d89d2efd1bcb3f272138f4e75c34df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7b68eaf58cfca9378e64fff13bf949/" rel="bookmark">
			Channel shutdown: channel error; protocol method 错误处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息
Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg 'type' for exchange 'kxg-fanout' in vhost '/': received 'fanout' but current is 'direct', class-id=40, method-id=10)
这是因为在写消息接收者的时候方法写错了，重启项目 队列已经注册过了，再次运行项目队列信息不匹配所致
解决办法一
暴力解决 ：
rabbitmqctl stop_app rabbitmqctl reset rabbitmqctl start_app 但是这种方式会造成 的后果是、添加的用户信息和权限全部擦除，还得重新设置
方法二：登录管理平台-&gt;选择队列名-&gt;找到delete选项删除即可
purag 是删除暂存在队列里的消息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f4c1d6e0ad58123756800a4f566c57/" rel="bookmark">
			Elasticsearch学习，请先看这一篇！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/achuo/article/details/87865141
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14523b0869ca55a77c3a90c345e6d8d0/" rel="bookmark">
			zynq中常用几种gpio小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载链接:https://blog.csdn.net/husipeng86/article/details/52123465
三种GPIO的介绍 学了zynq一段时间，一上来的时候就被zynq的GPIO唬住了，实在没搞清楚zynq的GPIO怎么回事，一会这样，一会那样，最后才慢慢发现zynq至少有3种GPIO可以调用。难怪我觉得每篇介绍GPIO的博客说的有一些不一样呢。
我们先看有哪三种GPIO：MIO、EMIO、AXI_GPIO。其中MIO和EMIO是直接挂在PS上的GPIO。而AXI_GPIO是通过AXI总线挂在PS上的GPIO上。
我们先看一下MIO和EMIO：下图EMIO和MIO的结构。其中MIO分布在BANK0，BANK1，而EMIO则分布在BANK2、BANK3。注意一下几项：
首先、MIO在zynq上的管脚是固定的，而EMIO，是通过PL部分扩展的，所以使用EMIO时候需要在约束文件中分配管脚，所以设计EMIO的程序时，
需要生成PL部分的bit文件，烧写到FPGA中。
其次、由下图可以看出MIO共占54bit，而EMIO占64bit。其中MIO占用IO号为0-53。而EMIO占用IO号为54-117。
再者、无论是EMIO还是MIO都属于PS上的IO，直接由PS操作。在调用头文件，只调用#include "xgpiops.h"即可，而在调用AXI_GPIO时，则需要#include "xgpio.h"。
最后、在设计好bd文件后、系统会自动在路径：..\standalone_bsp_0\ps7_cortexa9_0\include生成 xparameters.h文件.我们可以在
xparameters.h文件中查看我们在bd设计时添加的外设ID。例如我们添加了EMIO，可以查到到该IO的地址和ID号。
[cpp] view plain copy #define XPAR_PS7_GPIO_0_DEVICE_ID 0 #define XPAR_PS7_GPIO_0_BASEADDR 0xE000A000 #define XPAR_PS7_GPIO_0_HIGHADDR 0xE000AFFF 再举例添加了两个AXI_GPIO，例化为BTNS_4BIT和SW_4BIT [cpp] view plain copy /* Definitions for driver GPIO */ #define XPAR_XGPIO_NUM_INSTANCES 2 /* Definitions for peripheral BTNS_4BIT */ #define XPAR_BTNS_4BIT_BASEADDR 0x41210000 #define XPAR_BTNS_4BIT_HIGHADDR 0x4121FFFF #define XPAR_BTNS_4BIT_DEVICE_ID 0 #define XPAR_BTNS_4BIT_INTERRUPT_PRESENT 0 #define XPAR_BTNS_4BIT_IS_DUAL 0 /* Definitions for peripheral SW_4BIT */ #define XPAR_SW_4BIT_BASEADDR 0x41200000 #define XPAR_SW_4BIT_HIGHADDR 0x4120FFFF #define XPAR_SW_4BIT_DEVICE_ID 1 #define XPAR_SW_4BIT_INTERRUPT_PRESENT 0 #define XPAR_SW_4BIT_IS_DUAL 0 再来看一下，AXI_GPIO相当于GPIO的IP核，我们调用时是占用相应AXI总线地址空间，如下图，占用地址为0x41200000和0x41210000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14523b0869ca55a77c3a90c345e6d8d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12277c0cbcac03cb5fcc274cab58079c/" rel="bookmark">
			mysql字段按字段的数值大小排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询数据对数字排序的时候出现1 11 12 13 14....2 21 22 23 24... 现需要按数字大小排序则需要处理
①：ORDER BY 字段+0
②：ORDER BY CAST(字段 AS SIGNED)
③：ORDER BY 字段*1
根据测试此方式只支持纯数字（1,10）或者以数字开头（1a,11a）的字段，如果字段是按字符+数字形式的（a1,a2,b1,b2,a1a,a2a），则上面的方式达不到排序的目的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d639bc2f636ea3285beb74ebdb0158d/" rel="bookmark">
			Invalid location of tag 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Invalid location of tag 解决方案 Invalid location of tag (form)
form 应该写到table外面去，form标签只能嵌套进入div等行级元素中，放进块元素会报invalid。
Invalid location of tag (style)
style应该写在head里面。
Invalid location of tag (script)
script应该写到body，head里面。
Attribute name(Name) uses wrong case character
虽说HTML不区分大小写，但是在Myeclipse里面，大写的话就报错，所以，还是乖乖的改成小写吧。
Invalid location of tag (div)
这个错误是因为div的标签使用不当，需要更换为标签
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa6179ea18cfa3457db39a59c1f9fa2/" rel="bookmark">
			eBPF &amp; bcc实例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多文章目录：点击这里
GitHub地址：https://github.com/ljrcore
上一篇博客简单介绍了 eBPF 并介绍了 bcc 框架的安装及简单应用，本篇开始实战，动手写 bcc 程序。先来一个简单的bcc 程序，作用为探测 sys_sync ，检测到 sync 时打印出“sys_sync() called”。sys_sync系统调用被用户空间函数调用，用来将内核文件系统缓冲区的所有数据写入存储介质，sys_sync系统调用将buffer、inode和super在缓存中的数据写入设备。
在此之前，先来点题外话，笔者看到 sys_sync 系统调用就想了解一下，此处介绍的内容与 bcc 关系不大，只想了解 bcc 的读者可以直接往后看。关于sys_sync系统调用在linux-5.0\fs\sync.c中先看如下代码：
void ksys_sync(void) { int nowait = 0, wait = 1; wakeup_flusher_threads(WB_REASON_SYNC); iterate_supers(sync_inodes_one_sb, NULL); iterate_supers(sync_fs_one_sb, &amp;nowait); iterate_supers(sync_fs_one_sb, &amp;wait); iterate_bdevs(fdatawrite_one_bdev, NULL); iterate_bdevs(fdatawait_one_bdev, NULL); if (unlikely(laptop_mode)) laptop_sync_completion(); } SYSCALL_DEFINE0(sync) { ksys_sync(); return 0; } 可以看到SYSCALL_DEFINE0(sync)函数中调用了ksys_sync();，实际上它会扩展为asmlinkage long sys_sync()，asmlinkage 告诉编译器 sys_sync 函数通过堆栈而不是通过寄存器传递参数，尽管该函数并不接收任何参数。
且看 asmlinkage 宏定义，在linux-5.0\arch\x86\include\asm\linkage.h中定义如下：
#ifdef CONFIG_X86_32 #define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0))) #endif /* CONFIG_X86_32 */ 其中 attribute 是关键字，是gcc的c语言扩展。__attribute__机制是GNU C的一大特色，它可以设置函数属性、变量属性和类型属性等。可以通过它们向编译器提供更多数据，帮助编译器执行优化等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa6179ea18cfa3457db39a59c1f9fa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd38e5c4c01cafc7904fddbd3a386eb/" rel="bookmark">
			RestTemplate如何发送带headers的GET请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：拦截器 直接看RestTemplate提供的几个Get请求接口:getForEntity()，getForObject()，exchange()，并没有发现有设置请求头的地方，是不是就表明没法设置请求头了？
答案档案是能设置了,具体的使用思路有点类似mvc中的拦截器，自定义一个拦截器，然后在你实际发起请求时，拦截并设置request的请求头
注意到 RestTemplate 的父类InterceptingHttpAccessor提供了一个接收Interceptor的接口org.springframework.http.client.support.InterceptingHttpAccessor#setInterceptors，这个就是我们所需要的关键点（讲道理，除非事先就知道有这么个玩意，不然真让你去找，还不一定能找到）
所以第一步就是写一个ClientHttpRequestInterceptor类，添加请求头
public class UserAgentInterceptor implements ClientHttpRequestInterceptor { @Override public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { HttpHeaders headers = request.getHeaders(); headers.add(HttpHeaders.USER_AGENT, "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"); return execution.execute(request, body); } } 下一步就是在创建RestTemplate对象之后，声明解释器并测试使用了
@Test public void testGetHeader() { String url = "http://localhost:8080/agent?name=一灰灰Blog"; RestTemplate restTemplate = new RestTemplate(); restTemplate.setInterceptors(Collections.singletonList(new UserAgentInterceptor())); ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fd38e5c4c01cafc7904fddbd3a386eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c84f924d24302cf493a3bb63abd4ce3/" rel="bookmark">
			error: You have not concluded your merge (MERGE_HEAD exists). 【已解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因可能是在以前pull下来的代码自动合并失败 解决办法：切换到项目文件夹中，使用git命令 舍弃本地代码,远端版本覆盖本地版本(慎重) $:git fetch --all $:git reset --hard origin/master $:git fetch 保留本地的更改,中止合并-&gt;重新合并-&gt;重新拉取 $:git merge --abort $:git reset --merge $:git pull 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0847f9b02e1026937410d0844e0f71a5/" rel="bookmark">
			千锋学习日记--flask_SQLALchemy之多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLAlchemy SQLAlchemy是一个基于Python实现的ORM框架。该框架建立在DB API之上，使用关系对象映加粗样式射进行数据库操作，简单地说就是：将类和对象转换成SQL，然后使用数据API执行并获取执行结果。
今天要说的就是 flask_SQLALchemy之多表查询
1.join查询 先假设一个需求，知道一个用户的学习成绩，要查询这个学习成绩所属的用户，第一个办法就是连接多个filter()来查询。
for u, s in session.query(User, Course).filter(User.uid==Course.uid).filter(Course.score=='80').all(): print(u,s) # 执行结果 张三 80 还可以使用join（）方法：
u = session.query(USER).join(Course).filter(Course.score=='80').one() print(u) # 执行结果 张三 Query.join() 知道如何在 User 和 Course 之间进行连接，因为我们设定了外键。假如我们没有指定外键，比如这样：
class User(Base): __tablename__ = 'user' uid = Column(Integer, primary_key=True) username = Column(String(50)) password = Column(String(12)) class Course(Base): __tablename__ = 'Course' sid = Column(Integer, primary_key=True) score = Column(String, nullable=False) user_id = Column(Integer) 我们可以这样来让join()生效：
query,join(Course, User.uid==Course.user_id) query.join(User.course) query.join(Address, User.Course) query.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0847f9b02e1026937410d0844e0f71a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fad12c2228d0f07d4aee389f37a2a90/" rel="bookmark">
			Docker 三剑客之 Docker集群管理（harbor私有镜像仓库的创建、部署等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Harbor简介 Harbor私有仓库的部署登录harbor仓库上传和拉取镜像从节点上拉取镜像 （将密钥传给各个节点）创建个人用户仓库私有仓库验证是否成功（节点是否会自动拉取镜像） 一、Harbor简介： Harbor是VMware公司开源了企业级Registry项目, 其的目标是帮助用户迅速搭建一个企业级的Docker registry服务。它以Docker公司开源的registry为基础，额外提供了如下功能: Cloud native registry:支持容器镜像和Helm Charts，为云原生环境提供服务 Role based access control：基于角色的访问控制 Policy based image replication：基于策略的镜像复制 Vulnerability Scanning：镜像的漏洞扫描 LDAP/AD support：AD/LDAP集成 Image deletion &amp; garbage collection：镜像的删除和空间清理 Notary：可以保证镜像的真实性 Graphical user portal：友好的管理UI Auditing：日志审计 RESTful API：提供RESTfull接口易于与外部系统集成 Easy deployment：部署简单
二、Harbor私有仓库的部署 （一）、实验步骤：
实验环境的部署：
主机名 IP地址 系统作用 reg.westos.org 172.25.6.3 rhel7.5为集群（server1、server2、server3）提供docker软tar包的主机 server1 172.25.6.1 rhel7.5swarm集群控制节点 server2 172.25.6.2 rhel7.5swarm集群从节点 server4 172.25.6.4 rhel7.5swarm集群从节点 实验步骤：
部署的软件：
docker-ce-18.09.6-3.el7.x86_64.rpm docker-ce-cli-18.09.6-3.el7.x86_64.rpm containerd.io-1.2.5-3.1.el7.x86_64.rpm container-selinux-2.21-1.el7.noarch.rpm harbor软件包： harbor-offline-installer-v1.8.2.tgz 四台虚拟机上都要安装docker服务（前面已经装过了）
1、检查虚拟机网络是否畅通
ping baidu.com
2、将harbor软件 转给需要布置harbor仓库的主机、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fad12c2228d0f07d4aee389f37a2a90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73fde2dcb1f239204d3b87abd6c5bf59/" rel="bookmark">
			Python爬虫——xpath出现错误  AttributeError: &#39;NoneType&#39; object has no attribute &#39;xpath&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AttributeError: ‘NoneType’ object has no attribute ‘xpath’ 在利用xpath爬取网站信息时
import requests from lxml import etree url = "https://movie.douban.com/top250" html = requests.get(url).text Movie = etree.HTML(html) MovieTitle = Movie.xpath("/html/head/title/text()")[0] print(MovieTitle) **‘NoneType’**表示缺少头部，解决办法是只需添加一个头部即可：
import requests from lxml import etree url = "https://movie.douban.com/chart" header = {"User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36"} html = requests.get(url, headers=header).text Music = etree.HTML(html) MusicTitle = Music.xpath("/html/head/title/text()")[0] print(MusicTitle) # 输出结果为：豆瓣电影 Top 250 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6dfbcfd4ac45d1cd9d6582c48e0e9f2/" rel="bookmark">
			SourceTree提示ssh密钥认证失败以及通过http方式gitclone出现内存不够问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
1. 某一天一直出现git clone http:// xxxx 出现内存不够的错误， 基本上尝试了网上所有方法都不行
2. 修改为ssh clone方式， 出现ssh 密钥认证失败
经过学习大神们的方法， 加上自己的多次尝试， 得偿所愿完成通过ssh clone，记录以备后续学习。
其实本身我的gitlab或者sourcetree 都有建立了ssh密钥， 但是仍然提示失败， 只能重新创建。
1. 删除gitlab和sourcetree上面旧的ssh密钥，
2. 打开本地电脑，随便找个路径，最好纯字母路径， 不要带有特殊字符， 建立一个ssh专属文件夹，打开后，鼠标邮件打开git bash
敲入 ssh-keygen， 路径下会自动生成2个文件
idrsa_20200227, 用来导入到sourcetree 的设置里面
idrsa_20200227.pub，打开里面内容，复制内容到gitlab 的ssh方框内
如下passphrase里面，最好用gitlab的登录密码， 我试过如果是其他密码，可能还是会认证失败
ssh密钥生成后， 先打开gitlab的ssh设定， 把idrsa_20200227.pub里面的内容全部复制进去， 点击add，
gitlab的SSH key就添加成功了
再打开Sourcetree--工具--选项， 添加SSH密钥， 如idrsa_20200227
SSH客户端，选择“OpenSSH”
完成后， 关闭Sourcetree， 再次打开， 提示输入passphrase， 如上之前git bash里面添加的密码，直接回车。
至此， 基本设定已经完成了， 然后通过添加先Clone路径， 选择用ssh方式进行clone， 验证所有设定是否OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a8e1bbf0c7fd5c34608177a5933666/" rel="bookmark">
			shell 列表操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是列表的各种添加方式，拷贝自他人博客。详细用法参考https://blog.csdn.net/asty9000/article/details/87103111
删除列表元素用法：
unset array_name[index]
其中，array_name 表示数组名，index 表示数组下标。如果不写下标，写成下面这样就是删除整个数组：
unset array_name
下图是我本人借助这两个用法写得的一个具体的脚本，通过以下这些ip段，把所有ip输出到一个列表中：
#!/bin/bash declare -a iplist line_count=`cat lt_ip.txt | wc -l` for((a=1;a&lt;=${line_count};a++));do start_ip=`sed -n "${a}p" lt_ip.txt | awk '{print $1}'` end_ip=`sed -n "${a}p" lt_ip.txt | awk '{print $1}'` #截取ip段，比如是1.1.1.1这个ip，这里就是1.1.1 ip_duan=${start_ip%.*} #echo "$ip_duan" #计算ip段的个数，比如1.1.1.1-1.1.1.7，这就是7-1 let ip_cha=${end_ip##*.}-${start_ip##*.} #如果ip_cha=0,就是表示这个段就只有一个ip if [ "$ip_cha" -eq 0 ];then #echo "$start_ip" iplist+=($start_ip) companylist+=($company) ##如果ip_cha不等于0,就计算这个范围有多少个ip else let end_postion=${start_ip##*.}-1 let number=${ip_cha}+1 #echo "$end_postion" for ((b=1;b&lt;=${number};b++));do let end_postion+=1 ip=`echo ${ip_duan}.${end_postion}` #echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4a8e1bbf0c7fd5c34608177a5933666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4c81f938d158264b48757f7d48193f/" rel="bookmark">
			JMP入门官方文档---发现JMP.pdf---中文版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现JMP官方的一本很不错的中文版入门手册： 点击下载：JMP入门官方文档-发现 JMP.pdf
关于本指南 发现 JMP 提供了有关 JMP 软件的全面介绍。本指南假设您完全不熟悉 JMP。无论您是分析人
员、研究人员、学生、教授还是统计人员，本指南向您全面展示 JMP 的用户界面和功能。
本指南介绍下列信息：
• 启动 JMP
• JMP 窗口的结构
• 准备和操控数据
• 使用交互式图形挖掘数据
• 执行简单的分析以扩充图形
• 定制 JMP 和特殊功能
本指南共六章。每章都包括一些示例，帮助您加深理解该章中出现的概念。所有统计概念都仅
做初步介绍。本手册中使用的样本数据附带在软件中。下面是各章的简介：
• 第 1 章， JMP 简介，概述 JMP 应用程序。您将学习如何组织内容以及如何导航软件。
• 第 2 章，使用数据，说明如何从各种来源导入数据并准备数据进行分析。此外，概述了数据
操控工具。
• 第 3 章，可视化数据，对您可以用于可视化以及理解数据的图形和图表进行了说明。示例既
包括简单的单变量分析，也包括多变量图形，您可以通过这些图形查看多个变量之间的关系。
• 第 4 章，分析数据，说明多种常用分析技巧。这些技巧既包括不需要使用统计方法的简单技
巧，也包括需要使用统计知识的高级技巧。
• 第 5 章，保存和共享您的工作，说明如何使用记录和项目以及保存脚本。
• 第 6 章，特殊功能，说明如何在数据发生更改时自动更新图形和分析、如何使用首选项定制
报表，以及 JMP 如何与 SAS 交互。
学习了本指南之后，您将可以在 JMP 中轻松地导航和使用数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4c81f938d158264b48757f7d48193f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7553267c0662b21028d151cc9b3bbe77/" rel="bookmark">
			JMP如何切换系统默认语言英文为中文？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 默认为英文，改为中文步骤如下，中文改为英文同理。 1. 点击File—&gt;Preferences或者直接Ctrl+K 2. 点击Preferences里的Windows Specific—&gt;Display Language 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c70ed40e13e063300dcc97e43096887b/" rel="bookmark">
			在Jupyter Notebook终止cell（代码块）而非终止（重启）整个Jupyter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当IPython的某个cell陷入死循环或长时间没有响应，想终止当前cell，但不想重启Kernel，可以这样做：
（1）在工具栏，点击Kernel（内核）子菜单中的Interrupt（中断）。
（2）在想终止的cell，按ESC键，让其脱离编辑状态，在命令状态中，连续按两次“I”键（interrupt的首字母）（简单：推荐）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e64165759a63a2c666dbebfd717b348/" rel="bookmark">
			C#播放音频的正确姿势（一）——NAudio的简介与基础播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 各网查了一圈，NAudio相关中文资料较少。鉴于本人最近在使用此库的播放音频方面有所涉及，在此将自己的学习过程与经验总结与大家分享，同时也欢迎大佬探讨和指正。
简介 为什么使用NAudio NAudio为.NET平台下的开源库，采用ML-PL协议，开源地址：https://github.com/naudio/NAudio。截至今日，已有约2.4k的stars。
NAudio功能强大，且其入门容易。
强大在于：它支持许多音频操作，可实现多种API播放与录制、多种不同音频格式、音频格式转换（重采样、位深、声道等）、音频编码、多通道播放、音频效果处理等等（详细介绍可以看Github readme）。
入门容易在于：对C#的语法、结构友好，且对于一个仅仅是播放声音的需求，几行即可搞定：
using(var audioFile = new AudioFileReader(audioFile)) using(var outputDevice = new WaveOutEvent()) { outputDevice.Init(audioFile); outputDevice.Play(); // 异步执行 while (outputDevice.PlaybackState == PlaybackState.Playing) { Thread.Sleep(1000); } } Demo来自于官方Readme
另一方面，基于NAudio本身的架构值得学习
其框架系统、完善，但实际开箱即用的功能并不是十分的齐全（相对于Bass），对于一个喜爱倒腾的人来说，容易激发学习研究的兴趣，其官方教程与例子很是齐全。
快速入门：https://github.com/naudio/NAudio#tutorials
深入学习：https://markheath.net/category/naudio（作者博客）
与其他播放方式对比 基于使用角度考虑，NAudio的优势在于，它是一个原生的.NET轻量库（其底层与其他API交互，但透明于使用者）。在不需要COM、独立SDK、手动P/Invoke的同时，对于音频交互更加可控、并且可以完成比以上更加复杂的功能。当然其也有一定的不足，例如目前无法跨平台，底层API强依赖于Windows（作者表示期待.NET Core的Span&lt;T&gt;的后续发展，时机成熟会考虑跨平台）。
目前常见的播放方案：
方式简介备注系统事件声音仅播放系统事件声音System.Media.SystemSounds 静态类SoundPlayer使用方便。但是仅支持PCM的wav播放、单通道播放System.Media.SoundPlayer类Windows Media Player COM组件要求电脑上安装WMP，仅能完成简单播放功能，不利于自定义化MME API (Multimedia Extensions)自由度高。但是由于未经封装，若需求复杂则操作复杂，且P/Invoke不安全winmm.dllDirectX自由度高，相较于MME更为现代化，能从硬件层完成更多音频功能DirectX SDKBass功能强大的封装，但常见交换库对C#的语法、结构不友好Bass.NET（需进行授权使用） 或 ManagedBass 还有很多未列出。
例1：制作一个简易的音乐播放器 目标：制作一个Winform的音乐播放器，仅实现读取mp3、播放、暂停、停止、进度拖动及显示、音量控制功能。
为了直观的展示，本例将弱化OOP封装思想。
回顾开篇的代码：
using(var audioFile = new AudioFileReader(audioFile)) using(var outputDevice = new WaveOutEvent()) { outputDevice.Init(audioFile); outputDevice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e64165759a63a2c666dbebfd717b348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce062f0d27f52798e771dd90de601b6/" rel="bookmark">
			强大的中间人攻击工具（Bettercap）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言安装常用功能及模块介绍实战应用ARP欺骗DNS欺骗注入脚本替换下载文件 ~~~~~~~~ 因为想要面对一个新的开始，一个人必须有梦想、有希望、有对未来的憧憬。如果没有这些，就不叫新的开始，而叫逃亡。 ​​​​
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ————玛丽亚·杜埃尼亚斯
前言 提到中间人攻击，最知名的莫过于ettercap，这是kali下一款优秀的ARP欺骗工具，但是它自从2015年开始就没有更新了，同时在大型网络环境中ettercap的主机发现以及欺骗功能效果较差，于是就诞生了bettercap。Bettercap是一个非常强大、灵活可移植的中间人攻击框架，它具有跨平台、轻量级以及模块化等优点，在渗透测试过程中能够非常好的进行中间人测试。
安装 在kali命令行下运行
root@kali:~# apt-get install bettercap 使用如下命令打开bettercap（注意：一般打开就会列出局域网中存活的主机，但是我这儿没有，是因为主机发现模块没有打开，打开就好命令：net.recon on）
root@kali:~# bettercap #开启bettercap，默认是开启的eth0网卡，如果想开启其他网卡，比如无线网卡wlan0，可以bettercap iface wlan0 使用net.show可以列出局域网存活的主机
输入help 可以查看bettercap的用法（绿色表示启用，红色表示未启用） help后面跟模块名可以查看模块的详情。比如：help net.recon
常用功能及模块介绍 #功能解释 help 模块名称 显示指定模块的帮助 active： 显示当前运行中的模块的信息 quit ： 结束会话并退出 sleep 秒数： 休眠指定的秒数（和shell中的sleep一样） get 变量： 获取变量的值 set 变量值 ： 设置变量的值（有些模块有自定义变量，比如可用net.sniff.output变量指定嗅探器的输出的保存路径） read 变量提示： 显示提示来让用户输入，输入内容会被储存在变量中 clear： 清屏 include CAPLET： 在当前会话读取并运行这个caplet ! 命令 ： 运行相应的shell命令并显示输出 alias MAC地址 别名 给MAC地址设置一个别名 # 常用模块 api.rest： RESTful API模块 net.recon ： 主机发现模块，用于发现局域网内存活的主机，默认是开启的 arp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce062f0d27f52798e771dd90de601b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091e47bc44625e17f3ab8425f2156482/" rel="bookmark">
			Dubbo invoke时提示No such method...异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常开发中我们需要通过dubbo的telnet方式调用接口进行测试代码.
如果遇到No such method…异常, 其实并不是说没有这个方法,除非你真的把你调用的方法名写错了(一般人干不出来), 而是99%可能是你的方法入参不对.
一般非对象的入参不会出错, 类似
void addUserInfo(String name, int year) telnet调用如下
invoke UserInfoFacade.addUserInfo(“阿苏”, 2017)
多半出错的问题是入参中有对象的情况
举例如下
package con.infuq; public class Person { private String address; } public class Request { private int id; } public interface UserInfoFacade { List&lt;UserInfoDO&gt; addUserInfo(Person person); List&lt;UserInfoDO&gt; addUserInfo(Person person, Request req); } 对于第一个方法,有一个参数,通过telnet调用的写法如下
invoke UserInfoFacade.addUserInfo({“class”:“com.infuq.Person”,“address”:“天津市”})
对于第二个方法,有两个参数,通过telnet调用的写法如下
invoke UserInfoFacade.addUserInfo({“class”:“com.infuq.Person”,“address”:“天津市”},{“class”:“com.infuq.Request”,“id”:456})
总结
如果入参中有对象, 每个对象都需要使用一个{“class”:“x.y.z.Object”}类似这样的东东表示, 记得哦, 是一个对象对应一个{}, 如上面的举例, 两个入参对象就需要使用两个{}表示.
个人网站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898c4f9c9934a433d4505a3d2d89e14e/" rel="bookmark">
			高阶函数05——请用sorted()对上述列表分别按名字排序、再按成绩从高到低排序：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 假设我们用一组tuple表示学生名字和成绩：
L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)] 1. 请用sorted()对上述列表分别按名字排序：
L = [('Bob',75), ('Admin', 92), ('Bart', 66), ('List', 88)] def by_name(t): return t[0].lower() L2 = sorted(L, key=by_name) print(L2) 2.再按成绩从高到低排序：
L = [('Bob',75), ('Admin', 92), ('Bart', 66), ('List', 88)] def by_score(t): return t[1] L3 = sorted(L, key=by_score, reverse=True) print(L3) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d70d8d55c995c17475664e839b1410/" rel="bookmark">
			Failed to execute goal org.apache.maven.plugins:maven-resources-plugin:3.1.0:resources on project...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven package 打包时出现错误，记录一下。
错误信息：
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-resources-plugin:3.1.0:resources (default-resources) on project longtoshort: Cannot create resource output directory: D:\Software\工具\Git_project3\LongToShort\target\classes -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6d70d8d55c995c17475664e839b1410/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce84ca49df1c36ff0cecef8e73c2a8eb/" rel="bookmark">
			Qt模块与Qt5和4区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
Qt 5 与 Qt 4 最大的一个区别之一是底层架构有了修改。Qt 5 引入了模块化的概念，将众多功能细分到几个模块之中。Qt 4 也有模块的概念，但是是一种很粗的划分，而 Qt 5 则更加细化。本节主要对 Qt 5 的模块进行一个简单的介绍，以便以后大家需要哪些功能的时候知道到哪个模块去寻找。
Qt 5 模块分为 Essentials Modules 和 Add-on Modules 两部分。前者是基础模块，在所有平台上都可用；后者是扩展模块，建立在基础模块的基础之上，在能够运行 Qt 的平台之上可以酌情引入。
Qt 基础模块分为以下几个：
Qt Core，提供核心的非 GUI 功能，所有模块都需要这个模块。这个模块的类包括了动画框架、定时器、各个容器类、时间日期类、事件、IO、JSON、插件机制、智能指针、图形（矩形、路径等）、线程、XML 等。所有这些类都可以通过 头文件引入。
Qt Gui，提供 GUI 程序的基本功能，包括与窗口系统的集成、事件处理、OpenGL 和 OpenGL ES 集成、2D 图像、字体、拖放等。这些类一般由 Qt 用户界面类内部使用，当然也可以用于访问底层的 OpenGL ES 图像 API。Qt Gui 模块提供的是所有图形用户界面程序都需要的通用功能。
Qt Multimedia，提供视频、音频、收音机以及摄像头等功能。这些类可以通过 引入，而且需要在 pro 文件中添加 QT += multimedia。
Qt Network，提供跨平台的网络功能。这些类可以通过 引入，而且需要在 pro 文件中添加 QT += network。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce84ca49df1c36ff0cecef8e73c2a8eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0afbfcc11fdf9b3b0c3d573365cd311/" rel="bookmark">
			渗透测试笔记总结（九）——社会工程学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、社会工程学
二、社工技术框架
1、信息搜集
2、诱导
3、托词
三、伪装木马
1、常见的伪装方式
2、传播途径
3、木马程序的制作
4、木马程序的“免杀”处理
四、网站钓鱼
1、SET工具包
2、钓鱼网站的制作
五、邮件钓鱼
六、U盘攻击
文档截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bab31aa41ab50638be5520b92c324e6/" rel="bookmark">
			山农某Freshman的试水——结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨晚和今早学习讲述的内容是结构
经过老师和B站视频av3425303的教育，我大概对结构有了一点理解
按我理解总结起来就是结构是多个内容的统一体，自己还带了一个名字。
就像山东与中国的关系一样。
先来介绍一下结构体的结构：
struct 标识符//自行确定，相当于变量名 { 类型 成员1 ; 类型 成员2 ; … 类型 成员n ; } ; //最后的这个分号一定不能落下 例如：
struct employee { char name [ 10 ] ; long code ; double salary ; char address [ 50 ] ; char phone [ 20 ] ; } ; 下面是对结构体更为官方的解释
结构是由不同数据类型的数据组成的集合体。
结构由数目固定的成员构成
各成员可以具有不同的数据类型
一个结构变量在内存占有一片连续的存储空间
值得一提的是最后一条关于结构体的存储
就如数组一样，定义一个数组a[10]，只要a[0]确定了地址，这个数组后面的a[1]到a[9]会紧跟着a[0]。也就是说标识符的地址确定了后，其后面的每一个成员的地址都会紧随其后。
在定义一个结构变量的时候，可以声明类型之后声明变量：
struct employee { char name [ 10 ] ; long code ; double salary ; char address [ 50 ] ; char phone [ 20 ] ; }; employee worker1, worker2, *Emp ; 也可以声明类型的同时声明变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bab31aa41ab50638be5520b92c324e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e53ef74212e2760ee737023f87d532/" rel="bookmark">
			报错：iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 5000
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker启动容器报错 docker: Error response from daemon: driver failed programming external connectivity on endpoint myrabbit
详细信息：
docker: Error response from daemon: driver failed programming external connectivity on endpoint myrabbit \ (892f397b0ad5c6cca695f2d9ae770d0856745f58009bb75d5e6e13d4a7d88e9e): \ (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport \ 15672 -j DNAT --to-destination 172.17.0.3:15672 ! -i docker0: iptables: \ No chain/target/match by that name. 解决方案：
重启docker
systemctl restart docker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f111a67cabcaa67efda75aa59d44da49/" rel="bookmark">
			WEB编程（五）HTML页面内容填充，常用标签介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 WEB编程（一）前言学习目标WEB编程（二）拆解目标，分析页面结构WEB编程（三）使用工具准备介绍WEB编程（四）HTML页面框架搭建WEB编程（五）HTML页面内容填充，常用标签介绍WEB编程（六）CSS页面装修优化WEB编程（七）JS页面动态效果控制 前景回顾 上一篇我们了解了HTML页面的基本结构，页面结构是固定的，至于为啥，大家可以百科哈（偷个懒）。这篇开始使用常用标签填充页面内容，还是以模拟百度为目标。
HTML标签 大家可以到w3school体验，所有HTML标签，上面有对每个标签的解释。
标签从大的分类来说，可以分为两种：
展示型：静态展示，带默认样式，不带有单独的事件功能，这种标签普遍具有可替代性。功能型：基于展示型，另外携带有特有的事件，可以用属性或脚本控制（在文章最后有列出）。 模拟百度首页布局 之前我们分析过百度首页，从上至下分为三大块：
拆分如上图，现在我们开始分析页面中，所需要的标签：
拆分三大块，我们用&lt;div&gt;标签。页头的超链接区域，我们用&lt;a&gt;标签。内容区域，我们用&lt;div&gt;，&lt;img&gt;，&lt;form&gt;，&lt;input&gt;，&lt;button&gt;，&lt;p&gt;标签。页脚区域，我们用&lt;div&gt;，&lt;img&gt;，&lt;a&gt;标签。 标签说明&lt;div&gt;标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。&lt;a&gt;标签定义超链接，用于从一张页面链接到另一张页面。&lt;img&gt;元素向网页中嵌入一幅图像。&lt;form&gt;标签用于为用户输入创建 HTML 表单。&lt;input&gt;标签用于搜集用户信息。&lt;button&gt;标签定义一个按钮。&lt;p&gt;标签定义段落。 下面我们就这些标签，构建页面内容：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;模拟百度页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--页头导航栏--&gt; &lt;div&gt; &lt;a href="http://news.baidu.com"&gt;新闻&lt;/a&gt; &lt;a href="https://www.hao123.com"&gt;hao123&lt;/a&gt; &lt;a href="http://map.baidu.com"&gt;地图&lt;/a&gt; &lt;a href="http://v.baidu.com"&gt;视频&lt;/a&gt; &lt;a href="http://tieba.baidu.com"&gt;贴吧&lt;/a&gt; &lt;a href="http://xueshu.baidu.com"&gt;学术&lt;/a&gt; &lt;a href="https://passport.baidu.com/v2/?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2F"&gt;登录&lt;/a&gt; &lt;a href="http://www.baidu.com/gaoji/preferences.html"&gt;设置&lt;/a&gt; &lt;a href="http://www.baidu.com/more/"&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;!--主显示区域--&gt; &lt;div&gt; &lt;!--Logo展示--&gt; &lt;div&gt; &lt;img src="http://www.baidu.com/img/bd_logo1.png" alt=""&gt; &lt;/div&gt; &lt;!--搜索输入框--&gt; &lt;form id="form" action="https://www.baidu.com/s"&gt; &lt;input id="kw" name="kw" type="text"&gt; &lt;button type="submit" id="su"&gt;百度一下&lt;/button&gt; &lt;/form&gt; &lt;!--二维码展示--&gt; &lt;div&gt; &lt;!--二维码--&gt; &lt;div&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f111a67cabcaa67efda75aa59d44da49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ded4a3da417c5c608b2863adf610943/" rel="bookmark">
			数据结构 - 二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树 概念 二叉树是一种非常重要的数据结构，非常多其他数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们寻常所说的层次遍历。由于树的定义本身就是递归定义，因此採用递归的方法去实现树的三种遍历不仅easy理解并且代码非常简洁，而对于广度遍历来说，须要其他数据结构的支撑。比方堆了。所以。对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。
把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：
(01) 每个节点有零个或多个子节点；
(02) 没有父节点的节点称为根节点；
(03) 每一个非根节点有且只有一个父节点；
(04) 除了根节点外，每个子节点可以分为多个不相交的子树。
四种基本的遍历思想 前序遍历：根结点 —&gt; 左子树 —&gt; 右子树
中序遍历：左子树—&gt; 根结点 —&gt; 右子树
后序遍历：左子树 —&gt; 右子树 —&gt; 根结点
层次遍历：仅仅需按层次遍历就可以
比如。求以下二叉树的各种遍历
前序遍历：1 2 4 5 7 8 3 6
中序遍历：4 2 7 5 8 1 3 6
后序遍历：4 7 8 5 2 6 3 1
层次遍历：1 2 3 4 5 6 7 8
树的基本术语 若一个结点有子树，那么该结点称为子树根的"双亲"，子树的根是该结点的"孩子"。有相同双亲的结点互为"兄弟"。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。
结点的度：结点拥有的子树的数目。
叶子：度为零的结点。
分支结点：度不为零的结点。
树的度：树中结点的最大的度。
层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。树的高度：树中结点的最大层次。
无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置。有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ded4a3da417c5c608b2863adf610943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d879eb12875e8a8edce314f7faef6285/" rel="bookmark">
			【Golang】gorm添加数据库排他锁，for update
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用于先读后更新的数据竞争场景，且应该将加锁操作放到事务中，防止锁被自动释放，原因参考mysql doc
func UpdateUser(db *gorm.DB, id int64) error { tx := db.Begin() defer func() { if r := recover(); r != nil { tx.Rollback() } }() if err := tx.Error; err != nil { return err } user := User{} // 锁住指定 id 的 User 记录 if err := tx.Set("gorm:query_option", "FOR UPDATE").First(&amp;user, id).Error; err != nil { tx.Rollback() return err } // 更新操作... // commit事务，释放锁 if err := tx.Commit().Error; err !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d879eb12875e8a8edce314f7faef6285/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/250/">«</a>
	<span class="pagination__item pagination__item--current">251/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/252/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>