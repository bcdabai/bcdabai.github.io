<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05deaad6f205f2d9f845f4234cf0e85d/" rel="bookmark">
			【STM32知识点】关于不同外设中断标志位清除的使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用中断函数的时候，我们往往忘记在中断服务函数内清除中断标志位而导致一些未知错误。
以下我总结了几个外设关于中断标志位的清除问题。
定时器：
1、在程序有使用到中断的情况下，定时器在使能之前需要先清除更新中断标志位，否则会出现定时器一使能就进入中断的现象。
2、常规情况下，在进入中断服务函数以后，需要软件清除标志位。
3、如果使用HAL库的话，并且有使用到回调函数的话，不需要用户自己清除中断标志位，因为中断服务函数调用的HAL_TIM_IRQHandler这个函数里面已经包含了清除中断标志位，以及回调函数。
调用过程：ADVANCE_TIM_IRQHandler ()—&gt;HAL_TIM_IRQHandler()
—&gt;void HAL_TIM_PeriodElapsedCallback()
串口：
1、串口中断标志位，既可以通过软件清除标志位，也可以通过读写DR寄存器硬件清除寄存器。
————————————————
版权声明：本文为CSDN博主「Hello_96_world」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_29031103/article/details/120185089
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebfaeaef8096991ab49df5caaf42a8cb/" rel="bookmark">
			C语言 守护进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每隔两秒将当前时间写入/time.txt中（sudo）
// 、、使用内存映射可以拷贝文件 /* 对原始文件进行内存映射 创建一个新文件 把新文件的数据拷贝映射到内存中 通过内存拷贝将第一个文件的内存映射区拷贝到第二个文件的内存映射区 释放资源 */ // 匿名映射，不需要文件实体来进行内存映射 // 只能用于有血缘关系的进程间通信 #include &lt;sys/mman.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; // int main() // { /* // kill函数 // pid》0将信号发送给指定进程 // =0：将信号发送给当前进程组 // =-1：将信号发送给每一个有权限接受这个信号的进程 // 《-1：进程组id的绝对值 // sig，要发送的信号 // kill(getppid(), 9); // kill(getpid(), 9); // raise函数，给当前进程发送信号 // sig，要发送的信号，成功返回0，失败返回非0*/ // alarm函数 // 设置定时器，倒计时，当时间为0的时候，会给当前进程发送一个 SIGALARM信号 // 取消定时器，alarm(0)即可 // 返回值是unsigned int，倒计时剩余的时间（上一个alarm剩余的时间） // SIGALRARM信号默认终止当前进程，每个进程只能设置一个定时器 // int seconds = alarm(5); // printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebfaeaef8096991ab49df5caaf42a8cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/080c9929a180e24d43b80f08c82ceed5/" rel="bookmark">
			vue3小兔鲜儿项目文档，视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档
https://megasu.gitee.io/erabbit-client-pc-document/guide/00-vue3pre.html
csdn
https://blog.csdn.net/weixin_51689029/article/details/119683515
视频
https://www.bilibili.com/video/BV1cf4y1j7hL
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe1aeeacbc8a55c0235340abf907c76/" rel="bookmark">
			C&#43;&#43; Matlab混合编程时“函数或变量 ‘matlabrc‘ 无法识别”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在QT中调用Matlab初始化时，出现了“函数或变量 ‘matlabrc’ 无法识别”的情况，接着崩溃。
而且比较神奇的是，前一次是可以初始化的，但运行过程中发生了崩溃。
直接搜解决办法，发现冰柚子给出了有效的解决办法。
具体操作很简单：
即删除此文件夹便可，同时，如果你遇到的情况和我类似，即一开始可以初始化，但程序崩溃后无法再次初始化，很有可能是内存不足，在该缓存文件中存在记录并限制了再次运行。请关闭其他程序，或者扩容内存后，删除上述文件夹后重试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9399b7f1b29cf97cfa760aacc4801c1/" rel="bookmark">
			解决vscode空格间距过小 tab只能退两格不是四格的问题（一句话解决 超简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决vscode空格间距过小 tab只能退两格不是四格的问题 1.首先打开vscode2.打开设置3.搜索框输入font4.修改Font Family5.修改成功 重新启动vscode就可以了 1.首先打开vscode 2.打开设置 在左下角
点击设置
3.搜索框输入font 下方会出现 Font Family
4.修改Font Family 将方括号里面修改为下方代码即可
Consolas, 'Courier New', monospace 5.修改成功 重新启动vscode就可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a95a68d382253a4e4f0c8837df95961/" rel="bookmark">
			Sentinel配置规则持久化至Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文中使用的nacos版本1.4.2、sentinel版本1.8.3
问题 当集成了Sentinel的客户端应用重启之后，在控制台配置的规则全部都没有了，如果需要上生产环境需要将规则配置进行持久化。下面就来实现Sentinel规则配置持久化。
添加Maven依赖 需要持久化至nacos就需要添加相关Maven依赖
&lt;!-- Sentinel Datasource 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinel-datasource&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Sentinel Datasource Nacos 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;/dependency&gt; 配置 默认 Nacos 适配的 dataId 和 groupId 约定如下：
groupId: SENTINEL_GROUP规则配置 dataId: {appName}-flow-rules，比如应用名为 appA，则 dataId 为 appA-flow-rules spring: cloud: sentinel: datasource: # 自定义命名 flow-rule: # 支持多种持久化数据源：file、nacos、zk、apollo、redis、consul nacos: # naco服务地址 server-addr: localhost:8848 # 命名空间，根据环境配置 namespace: public # 这里我做了一下细分，不同规则设置不同groupId group-id: SENTINEL_FLOW_GROUP # 仅支持JSON和XML类型 data-id: ${spring.application.name}-flow-rules.json # 规则类型：flow、degrade、param-flow、system、authority rule-type: flow # nacos开启了认证需要配置username、password # username: nacos # password: nacos Nacos配置 [{ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a95a68d382253a4e4f0c8837df95961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf186cf94c28d1e7002a1d8930e2348/" rel="bookmark">
			jdk11启动nacos报错Error: Could not find or load main class Caused by: java.lang.ClassNotFoundException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改startup.sh文件
1.
JAVA_OPT_EXT_FIX="-Djava.ext.dirs= J A V A H O M E / j r e / l i b / e x t : {JAVA_HOME}/jre/lib/ext: JAVAH​OME/jre/lib/ext:{JAVA_HOME}/lib/ext" JAVA_OPT=" J A V A O P T − D j a v a . e x t . d i r s = {JAVA_OPT} -Djava.ext.dirs= JAVAO​PT−Djava.ext.dirs={JAVA_HOME}/jre/lib/ext:${JAVA_HOME}/lib/ext"
2.
echo “$JAVA $JAVA_OPT_EXT_FIX ${JAVA_OPT}” echo “$JAVA ${JAVA_OPT}”
3.
echo “$JAVA $JAVA_OPT_EXT_FIX ${JAVA_OPT}” &gt; ${BASE_DIR}/logs/start.out 2&gt;&amp;1 &amp; nohup “ J A V A "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bf186cf94c28d1e7002a1d8930e2348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28f1dbf7356a9180f9adee2084d693a/" rel="bookmark">
			Mysql索引原理、聚簇索引和非聚簇索引、回表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们都知道索引的作用是增加查询速度，大部分系统都是读多写少，索引对查询的帮助是非常大的。特别是数据量越大的时候，索引对应查询性能的影响非常关键。就好比一本字典，如果没有目录，想要找一个字的话就要一页一页的查找，非常耗时，通过字典里面的目录就可以直接定位到数据在哪一页，这样查找效率就非常高。索引就类似字典里面的目录。
一、索引的底层数据结构 1、Hash（哈希表）
哈希算法也叫散列算法，就是把任意的key通过哈希函数转变为固定长度的地址。
2、B+树
Mysql默认使用的就是B+树，B+树是一种平衡查找树。在B+树中，所有记录节点都是按照键值大小按照顺序存放在同一层叶子节点上，各个叶子节点用指针进行连接，每个叶子节点保存了相邻的节点的指针。
浅蓝色为一个磁盘块，深蓝色为数据项，黄色为指针。
如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。
二、聚簇索引和非聚簇索引 1、聚簇索引是按照表的主键构建的有顺序的索引，叶子节点存储了整行的字段信息，非聚簇索引存储的是索引本身和主键值。（ InnoDB引擎里面表的主键就是聚簇索引，如果没有指定主键，系统会默认生成隐式的主键）；
2、聚簇索引一个表只能有一个，非聚簇索引可以有多个；
3、聚簇索引是按照顺序保存的，所以要按照顺序插入，否则可能会引起页分裂，影响性能。
三、Mysql索引分类 1、主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引；
2、单值索引：即一个索引只包含单个列，一个表可以有多个单列索引；
3、唯一索引：索引列的值必须唯一，但允许有空值；
4、复合索引：即一个索引包含多个列，由多个字段组合而成；
四、什么是回表 回表的产生是查询的时候使用到了非聚簇索引，而非聚簇索引只存储了数据行的主键，通过非聚簇索引找到主键后，再通过主键去找到最后的数据，应该尽量避免回表。但是如果查询的字段就是非聚簇索引本身，比如mobile为索引，sql里面只查询了mobile字段，这个时候就直接返回，不用回表了。
五 、InnoDB和MyISAM的区别 项目InnoDBMyISAM事务支持不支持行锁支持不支持表锁支持支持外键支持不支持计数器不支持支持聚簇索引支持不支持 六 、索引最左匹配原则 建立如下组合索引(a,b,c)，索引会从最左边开始匹配，a,b,c、a、a,b、a,c都可以命中索引，b,c、b,a,c、c都无法命中索引。
因为B+树是从左到右建立索引树的，只能先匹配到最左边的索引字段才知道下一步去哪个范围查询，否则都不知道下一步，只能全文检索，无法命中索引。
七 、Explain执行计划 可以通过explain来查看sql的执行计划等详细信息，对于SQL调优有很大帮助
字段描述id查询标识符select_type查询类型table输出的表partitions匹配的分区type联接类型，表示SQL语句的好坏，从好到差：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALLpossible_keys可供选择的索引key实际选择的索引，如为NULL，则表示未使用索引key_len表示索引中所使用的字节数，可通过该列计算查询中使用的索引长度ref与索引比较的列rows估计要读取的行数filtered百分比值，表示存储引擎返回的数据经过滤后，剩下多少满足查询条件记录数量的比例Extra附加信息 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba9f69337d84bee0e42d810fcae53d7a/" rel="bookmark">
			修改gitignore文件后，清除已被上传至远程仓库里的被忽略的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景说明 有些时候 上传代码的时候，不小心把日志、编译产物等不相关的文件也一起push到远程仓库了。这时，我们就有个需求，就是 忽略日志和编译产物等非必须文件，并删除远程仓库里这些需要忽略的文件。
方式一 简单粗暴型的，就是既不要本地的这些忽略文件，也不要远程仓库里的忽略文件，那就先删除，再提交，最后再push。（该种方式，我是commit 删除动作之后，再修改gitignore文件的）
方式二 此时，我们的要求是，保留本地这些被忽略的文件，但是删除远程仓库里的已被忽略的文件。
操作： 修改 gitignore文件，在本地仓库的根目录下执行 git rm -r --cached “被忽略的文件或文件名” 执行。然后执行 add commit，和push操作。这时便会保留本地被忽略的文件，删除远程仓库里被忽略的文件。
原理： git rm -r --cached 清除缓存操作，在版本库里执行的是删除操作，该删除操作会被push到远程仓库，所以远程仓库中的忽略文件就被删除了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3cc29027ce4e22a49d7f76205f1653a/" rel="bookmark">
			Python|遥感影像重投影与重采样、样本矢量转栅格、样本栅格扩充与原始影像相同大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、测试gdal是否成功运行 import gdal import os from matplotlib import pyplot as plt import rasterio as ras import numpy as np from osgeo import gdal import os import pathlib import rasterio from rasterio.plot import show import pandas as pd import multiprocessing as mp from itertools import repeat #查看gdal版本 print(gdal.VersionInfo()) #打开栅格文件 path=r'F:\重庆数据\潼南-中分影像\32645490313\4903132021010100000000332239150100002.tif' ds = gdal.Open(path) if ds is None: print("打开失败！") else: #读取行列数 print("读取行列数:") cols=ds.RasterXSize rows=ds.RasterYSize print("行数为：{} 列数为：{}".format(cols,rows)) #读取坐标系统 print("读取坐标系统:") proj=ds.GetProjection() del ds print(proj) i=490313 二、进行重投影与重采样 # %%time "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3cc29027ce4e22a49d7f76205f1653a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de70faf6f9f4f3a9b1ec9abe84bfb9f1/" rel="bookmark">
			了解CV和RoboMaster视觉组（五）滤波器、观测器和预测方法：卡尔曼滤波器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--neozng1@hnu.edu.cn
Kalman Filter（卡尔曼滤波器，时域）
KF家族从被提出以来可谓是运用的最多最广的滤波器了，并且其发明者Kalman教授以他的一己之力将控制领域的研究从频域转换到时域（以状态空间设计为基础的现代控制理论）上来，虽然他在后半生一直热衷于频域分析的研究。Kalman滤波器最出名的轶事就是在Kalman博士访问NASA后，那里的工程师认为这是一个极佳的时域修正方法，并且直接在阿波罗6登月飞行器的轨道矫正系统上使用了扩展卡尔曼滤波器。
相比于传统的时域滤波器和频域滤波器，KF运用马尔卡夫假设（从概率和信息观测的角度），只需要保留前一个状态的信息，占用内存小且速度非常快。
这一小节主要推荐一些非常棒的教程。关于KF的工程应用和直观理解，Matlab官方出品的这个系列视频很好地讲解了运用过程：Kalman Filter。另外若想从概率统计和数学角度初步理解KF，可以进一步参照这篇可可爱爱的教程：How a Kalman Filter works。
若是结合控制和概率论解释，并且完整地进行数学推导，请看bilibili up主 DR_CAN的：卡尔曼滤波器系列视频，另外，他从工程的角度讲解了状态空间法中的观测器设计，这能让你更好地从控制角度理解KF，请戳：状态观测器的设计。
若你学习过自动控制原理（准确的说是现代控制理论，主要用到的是关于稳定性分析和线性代数的知识），想从李雅普诺夫稳定性角度分析为什么KF是高斯噪声影响下的最优线性滤波器和其收敛性、抗扰能力，请戳卡尔曼滤波器原理介绍。
如果想进一步了解状态估计和机器人学中的概率论相关知识，可以参阅《state esstimation of robotics》和《probabilitics robotics》这两本经典的作品中相关的内容，里面详尽地介绍了KF为什么是高斯意义下地最优滤波器以及作为一个贝叶斯估计器的扩展，KF是怎样演化成这种形式的。
KF从多个信息来源获取数据后的融合过程图示
​
由KF的构成我们可以发现，它能够综合多个数据来源(观测模型)和系统状态转移的模型并根据他们置信度（由协方差的大小来表示）来对各个信息来源赋予不同的权重最终融合得到预测结果。而EKF、UKF都是对非线性系统作近似线性化而产生的滤波器，对于工作点附近非线性程度较小、容易线性化近似的系统（容易指的是求导生成的Jacobian矩阵较好计算，不会包含很多非线性函数）有着很好的效果。显然在比赛中大部分的控制数据和传感器数据都是能够比较好地用近似线性化来拟合的，比如在传感器帧率高、处理速度快的时候我们常常假设对手机器人的运动是匀速直线运动，因此KF系列便顺利成章地作为我们使用滤波器的首选。
若我们想用KF来修正之前的数据（如t-1，t-2时刻），那么卡尔曼滤波器相当于一个插值或平滑数据的装置；若想通过KF来融合当前采集的 数据并且消除噪声，那么它是一个估计器，和前者一样都是贝叶斯方法，即利用后验信息来修正概率模型；若想通过它来预测t+1时刻的值即通过修改状态转移矩阵用历史数据来推测将来值，这时候就是一个预测器（单纯从名词直译来理解）。
有了以上教程的铺垫，我们就可以通过修改KF的状态转移矩阵来预测将来的数据了：以装甲板的运动为例，我们一般对解算得到的装甲板的中点进行运动学建模并假设装甲板的运动模型（一般假设为匀速直线或匀加速直线）和观测模型（也就是相机的成像模型，可以使用小孔成像）的非线性程度较小。这样我们便能选用EKF来对其进行线性化。我们可以把当前帧和之前若干帧的装甲板位置的世界坐标系坐标相减并除以相机的帧率的倒数得到其运动速度，或者进一步求差分以得到加速度信息。在得到这些信息后，把他们填入状态转移矩阵并设置一个合理的时间间隔（曝光时间+单帧处理时间+数据发送到电控的通信时间+电机响应时间+子弹飞行时间等，一般需要实车调试进行修改），EKF便能根据转移矩阵和置信度计算出此确定的时间间隔后装甲板的位置了。我们会在 5.3.2 进一步介绍运动预测方法，在 6.4 也会详细讲解如何利用KF对装甲板的运动进行预测。
UKF则是EKF的改进版，全称为Unscented KF。当系统模型的非线性程度较大的时候，我们就很难用局部线性化的方法去得到贴近实际的近似分布，因此我们会在参数未进入系统前随机生成服从高斯分布的一组点同时给它们赋予不同的权重（为什么要这么做？），然后将他们一起投入到此非线性变换模型中，并在变换结束后统计这些点的均值和方差，利用这些数据重建一个高斯分布（点参数估计）用于近似此模型的分布。显然，使用的随机点越多则近似越准确（大数定律），但是消耗的资源也越大，这点和下一个要介绍的PF是完全一样的。不过，在实践中的经验来看，UKF对高维模型的近似并不是很好，一来是高维空间的分布更加复杂难以通过线性系统（在这里我们使用高斯分布）近似，另一方面是计算开销也随着维度增加而迅速上涨，维度爆炸是这两种方法（UKF和PF）共同的、最大的问题。
好在我们的系统并不复杂，最多只有速度、位置、加速度三个维度（加上加加速度和加加加速度也是没有任何问题的，如果你觉得者能够提升你模型的精确度并且这些数值的噪声足够小的话，或者你能够找到其他能够增加置信度的先验信息和其他可用传感器数据）。
​UKF的流程图解；图源知乎-"fishmarch"的专栏'概率机器人'
​
​ 根据上图我们可以把UKF的迭代过程分为以下四步：
选取服从Gauss分布的随机点
和数据一起投入变换
根据权重和新的均值方差得到新的Gauss分布，并假设此高斯分布就是经过变换后状态的近似分布
此外，卡尔曼滤波器还有各式各样的变种，如SCKF（状态约束）、ESKF（误差状态）、AUKF（增强无迹）等，有兴趣的读者可以自行了解相关的内容，无非是从不同状态变量的关系之间入手增加额外信息或约束以进一步逼近真值，或是通过更合理的方法来近似非线性部分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44584036791f40b77703327330b0e8e0/" rel="bookmark">
			JS（六）定时器和变量的作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 定时器定时器在JavaScript中的作用定时器类型及语法练习制作反复移动动画定时器制作图片无缝往返滚动播放定时器制作时钟定时器制作倒计时弹框 变量作用域全局变量局部变量 定时器 定时器在JavaScript中的作用 制作动画异步操作函数缓冲与节流 定时器类型及语法 setTimeout(函数名或匿名函数,延迟时间(单位ms)) ：只执行一次的定时器clearTimeout(定时器名)：关闭只执行一次的定时器setInterval(函数名或匿名函数,延迟时间(单位ms))：反复执行的定时器clearInterval(定时器名)：关闭反复执行的定时器
注：不需要写单位 练习 制作反复移动动画 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;移动动画&lt;/title&gt; &lt;style&gt; div{ position: fixed; width: 200px; height: 200px; background-color: chocolate; top: 100px; left: 0; } &lt;/style&gt; &lt;script&gt; window.onload = function(){ var sBox = document.getElementById('box'); var box_left = sBox.style.left; var left_num = 0; var speed = 50; //只执行一次向左移动 // var Once_move = setTimeout(function(){ // sBox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44584036791f40b77703327330b0e8e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f99baf9a2785a450ed318bece3f042/" rel="bookmark">
			网卡bonding模式 - bond0、1、4配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网卡bonding简介 网卡绑定就是把多张物理网卡通过软件虚拟成一个虚拟的网卡，配置完毕后，所有的物理网卡的ip和mac将会变成相同的。多网卡同时工作可以提高网络速度，还可以实现网卡的负载均衡、冗余。
bonding模式
1 round-robin(mode=0)
轮转策略，轮流在每一个slave网卡上发送数据包，提供负载均衡和容错能力。 2 active-backup(mode=1)
主备策略，只有一个slave被激活，只有当active的slave的接口down时，才会激活其它slave接口。主备模式下发生一次故障切换，在新激活的slave接口上会发送一个或者多个gratuitous ARP。主salve接口上以及配置在接口上的所有VLAN接口都会发送gratuitous ARP，需要在这些接口上配置了至少一个IP地址。VLAN接口上发送的的gratuitous ARP将会附上适当的VLAN id。本模式提供容错能力。
3 XOR(mode=2)
基于所选择的hash策略，本模式也提供负载均衡和容错能力。
4 broadcast(mode=3)
广播策略，向所有的slave接口发送数据包，本模式提供容错能力。
5 802.3ad(mode=4)
动态链路聚合，根据802.3ad标准利用所有的slave建立聚合链路。slave接口的出口取决于传输的hash策略，默认策略是简单的XOR策略，而hash策略则可以通xmit_hash_policy选项配置。
前提：每个slave网卡支持ethtool获取速率和双工状态
交换机支持IEEE 802.3ad标准(可能需要配置启用)
IEEE 802.3ad 是执行链路聚合的标准方法。将多个以太网适配器聚集到单独的虚拟适配器方面与“以太通道（EtherChannel）”的功能相同，能提供更高的带宽防止发生故障。例如，eth0 和 eth1 可以聚集到称作 eth3 的 IEEE 802.3ad链路聚合；然后用 IP 地址配置接口 eth3。系统将这些聚集的适配器作为一个适配器来考虑。因此，可以像在任何以太网适配器上一样配置它们的 IP。
6 balance-tlb(mode=5)
自适应传输负载均衡：根据每个slave的负载(相对速度)决定从哪个接口发送数据包，从当前接口接收数据包。如果接收的slave接口故障，其它slave接口将接管它的mac地址继续接收。
前提：每个slave网卡支持ethtool获取速率。
7 balance-alb(mode=6)
自适应负载均衡：
前提：每个slave网卡支持ethtool获取速率
每个slave网卡支持启用时重新设置硬件地址
小结：
mode 1、5、6不需要交换机设置
mode 0、2、3、4需要交换机设置
缺省使用mode 0
bonding驱动加载
cat /boot/config-2.6.32-431.el6.x86_64 | grep -i bonding CONFIG_BONDING=m # 这里可以看出bonding驱动编译成可以动态加载的内核模块 [root@compute1 ~]# vim /etc/modprobe.d/bond.conf # 开机自动加载bonding驱动 alias bond0 bonding options bond0 miimon=100 mode=0 # miimon：多长时间检查一次网络，单位ms; bonding模式0配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f99baf9a2785a450ed318bece3f042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5570ac34afdbe1ff820ffc027a553bd4/" rel="bookmark">
			Java数组的基本使用(超详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组的基本使用 为什么需要数组 一个养猫场有 6 只鸡，它们的体重分别是 3kg,5kg,1kg,3.4kg,2kg,50kg 。请问这六只猫的总体重是多少?平均体重是多少? 思路分析：定义 6 个变量 , 加起来 总体重,求出平均体重.引出 -&gt; 数组 数组介绍 数组可以存放多个同一类型的数据。可以存储基本数据类型，引用数据类型（对象）. 数组本身也是一种数据类型，是引用类型。数据类型可以是任意类型 即：数(数据)组(一组)就是一组数据 int[] 表示引用数据类型 数组是一个容器，容器都是存取数据，容器容量固定 数组有length属性 数组内存是连续的，有索引，查询是快, 增删比较慢 数组快速入门 比如，我们可以用数组来解决上一个问题。思路分析： 我们可以通过 cats[下标] 来访问数组的元素，下标是从 0 开始编号的比如第一个元素就是 cats[0]，第2个元素就是 cats[1] , 依次类推 通过for就可以循环的访问 数组的元素/值 使用一个变量 totalWeight 将各个元素累积 double[] cats = {3, 5, 1, 3.4, 2, 50}; double totalWeight = 0; for (int i = 0; i &lt; cats.length; i++) { System.out.println("第" + (i+1) + "个元素的值=" + cats[i]); totalWeight +=cats[i]; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5570ac34afdbe1ff820ffc027a553bd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc6a78cd898e524a2d5dad46b4427af7/" rel="bookmark">
			Django中{%for%}需要注意的细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目问题我的解决方案 题目 Django中for循环需要注意的细节
问题 在{%for%}循环中添加onclick()函数往往会指向最后一个item，而不是指向其相对应的item test_base.html
&lt;!-- * @Description: test_base.html * @Autor: 365JHWZGo * @Date: 2022-02-15 18:12:33 * @LastEditors: 365JHWZGo * @LastEditTime: 2022-03-09 11:38:38 --&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;测试页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {% block content %} {% endblock content %} &lt;/body&gt; &lt;/html&gt; test.html
&lt;!-- * @Description: 测试for循环模版 * @Autor: 365JHWZGo * @Date: 2022-02-15 17:01:24 * @LastEditors: 365JHWZGo * @LastEditTime: 2022-03-09 19:43:28 --&gt; {% extends "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc6a78cd898e524a2d5dad46b4427af7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ccc2172bb2cf02fc688669b33ba1acb/" rel="bookmark">
			1.什么是SQL？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL（Structured Query Language）是一种数据库的结构化查询语言。
数据库分为关系型数据库、非关系型数据库。
关系型数据库：MySQL、SQL Server、Access、Oracle、DB2、SQLite、Sybase。
MySQL：由瑞典MySQL AB公司开发，目前归甲骨文拥有的开源数据库，支持多种操作系统，体积小，速度快，总体使用成本低。适用于中小型的公司和web网站。
SQL Server：微软开发的商业数据库，只能在windows系统上使用。
Access：由微软发布的关系数据库管理系统。它结合了 MicrosoftJet Database Engine 和 图形用户界面两项特点，是 Microsoft Office 的系统程序之一。
Oracle：甲骨文开发的商业数据库，不开源，支持所有主流平台，性能好，功能强，稳定性好，安全性好，支持大数据量，比较复杂，收费昂贵。
DB2：美国IBM公司开发，主要应用于大型应用系统，具有较好的可伸缩性，可支持从大型机到单用户环境，应用于所有常见的服务器操作系统平台下。
SQLite：开源、轻型、无服务器、零配置，一个数据库就只是一个文件，在应用程序内执行操作，占用资源小，可用于嵌入式或小型应用。
Sybase：由美国Sybase公司于1987年推出的数据库产品，是一种典型的UNIX或WindowsNT平台上客户机服务器环境下的大型数据库系统。
非关系型数据库：NoSql、HiveSQL、Cloudant、MongoDb、redis、HBase，用来存储非结构化的数据，如HTML、XML文档。
SQL语言分类：
①数据定义语言DDL：Data Definition Language，对数据库、表、视图、索引等对象进行创建、修改、删除等操作。如:
创建数据库CREATE DATABASE，
修改数据库ALTER DATABASE,
创建表CREATE TABLE，
修改表ALTER TABLE，
删除表DROP TABLE，
创建索引CREATE INDEX,
删除索引DROP INDEX,
创建查询命令CREATE VIEW，
修改查询命令ALTER VIEW，
删除查询命令DROP VIEW，
删除数据表内容TRUNCATE TABLE
②数据操作语言DML：Data Manipulation Language，对表进行 增INSERT、删DELETE、改UPDATE、查SELECT等操作
③数据控制语言DCL：Data Control Language，数据权限的相关设置。是用来设置或者更改数据库用户或角色权限的语句，这些语句包括GRANT、DENY、REVOKE等语句，在默认状态下，只有sysadmin、dbcreator、db_owner或db_securityadmin等角色的成员才有权利执行数据控制语言。
基础知识学习网站：W3school、菜鸟教程
SQL 教程 (w3school.com.cn)https://www.w3school.com.cn/sql/index.aspSQL 简介 | 菜鸟教程 (runoob.com)https://www.runoob.com/sql/sql-intro.html
基础知识学习路径：
①基本语法、
②数据类型、
③运算符、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ccc2172bb2cf02fc688669b33ba1acb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45cb7c3054e21780f3f60151fe7b574d/" rel="bookmark">
			resnet18到resnet152模型pytorch实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		resnet在深度学习领域的重要性不言而喻，自从15年resnet提出后，被各种深度学习模型大量引用。得益于其残差结构的设计，使得深度学习模型可以训练更深层的网络。常见的resnet有resnet18、resnet34、resnet50、resnet101、resnet152几种结构，resnet残差网络由一个卷积块和四个残差块组成，每个残差块包含多个残差结构。从残差结构上看，resnet18和resnet34结构近似，使用相同的残差结构，仅在残差结构数量上有区别，都是使用两个卷积层加一个残差连接层作为残差结构。
resnet18与resnet34的残差结构：
输入特征图x经过两个卷积核大小为3*3的卷积层，使用padding为1的填充保持特征图大小不变，每个卷积层后接BN层和Relu层，完成两次卷积核将结果与输入特征图x直接相加。resnet50到resnet152使用另一种残差结构，这种残差结构使用两个1*1的卷积核加一个3*3的卷积核。
resnet18resnet34resnet50resnet101resnet152block11*conv1*conv1*conv1*conv1*convblock22*res(2*conv)3*res(2*conv)3*res(3*conv)3*res(3*conv)3*res(3*conv)block32*residual(2*conv)4*res(2*conv)4*res(3*conv)4*res(3*conv)8*res(3*conv)block42*residual(2*conv)6*res(2*conv)6*res(3*conv)23*res(3*conv)36*res(3*conv)block52*residual(2*conv)3*res(2*conv)3*res(3*conv)3*res(3*conv)3*res(3*conv)FNlinearlinearlinearlinearlinear resnet18的模型实现：
import torch.nn as nn from torch.nn import functional as F # 残差单元 class Residual(nn.Module): def __init__(self, input_channel, out_channel, use_conv1x1=False, strides=1): super().__init__() self.conv1 = nn.Conv2d(input_channel, out_channel, kernel_size=3, stride=strides, padding=1) self.conv2 = nn.Conv2d(out_channel, out_channel, kernel_size=3, stride=1, padding=1) if use_conv1x1: self.conv3 = nn.Conv2d(input_channel, out_channel, kernel_size=1, stride=strides) else: self.conv3 = None self.bn1 = nn.BatchNorm2d(out_channel) self.bn2 = nn.BatchNorm2d(out_channel) self.relu = nn.ReLU(inplace=True) def forward(self, X): Y = self.relu(self.bn1(self.conv1(X))) Y = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45cb7c3054e21780f3f60151fe7b574d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e56924734823bc6e29087127cdf30b1/" rel="bookmark">
			CVE-2019-0708漏洞 复现利用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天我研究了一下cve-2019-0708，一开始出错只能把win7打成蓝屏，但经过多次的更换靶机和攻击的试探最终功夫不负有心人，我利用cve-2020-0708终于拿到了win7的shell权限 演示步骤如下
首先搭建虚拟机漏洞环境：
靶机：win7旗舰版 IP：192.168.220.151
攻击机：kali2021 IP：192.168.220.148
靶机需要额外的内部环境配置，首先需要将靶机的防火墙关闭，其次将远程控制功能开启并允许所有机可以远程控制。然后将防火墙设置高级模式，在高级模式中的添加入站规则，设置新增端口3389开放并命名为ceshi。演示如图，依次排列
虚拟机环境搭建完成。
下面开始实验：
首先打开kali的msf（msfconsole），输入命令：search cve-2019-0708，得到漏洞模块（有一点就是我的kali是新版里面有漏洞模块，老版本的没有需要下载并更改。避免麻烦建议大家用新版本的）。第一个模块是检测靶机里有没有该漏洞。我们先检测输入命令： use auxiliary/scanner/rdp/cve_2019_0708_bluekeep
然后指定IP 输入 set RHOSTS 192.168.220.151 再输入 show options 查看攻击模块，确定之后最后输入命令运行。最后得到有该漏洞。演示图依次排列.
下面开始利用模块攻击，输入命令：use exploit/windows/rdp/cve_2019_0708_bluekeep_rce，其次查询攻击板块输入命令：show targets，然后确定板块之后我先输入的set target 1 我感觉不匹配于是改成 set target 4，接着指定IP 输入命令：set RHOSTS 192.168.220.151 最后运行 输入命令run 结果显示还是蓝屏于是我就尝试输入 set target 1 然后攻击。不料真的可以获取权限，得到shell权限可以使用命令shell提权查看IP是否是的,使用exit退出最高权限。使用 screenshot 命令截屏等等一些命令
漏洞修复：
及时打对应系统的安全补丁
关闭3389端口或添加防火墙安全策略限制对3389端口的访问
打不了补丁的可以开启远程桌面（网络级别身份验证(NLA)），可以临时防止漏洞攻击
本文只是我的愚见大佬不喜欢勿喷 此文仅供实验参考请勿做他用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a1db112d5906a4881c08d9d35cee18/" rel="bookmark">
			oracle基础常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle最基础的常用命令↓
explain plan FOR sql语句；--然后执行 SELECT * FROM TABLE (dbms_xplan.display()); --查看sql执行计划
select tablespace_name from dba_tablespaces; --查询所有表空间名
select * from all_users; --查询所有用户
select * from dba_sys_privs where grantee='大写的用户名'; --查询用户所拥有的权限
drop user 用户名 cascade; --删除用户名
DROP TABLESPACE 表空间名 INCLUDING CONTENTS AND DATAFILES; --删除表空间
create tablespace 表空间名 datafile 'D:\路径\文件名.DMP' size 200m autoextend on next 100m maxsize 10240M; --创建表空间
create user FUWUQISYMBOL identified by 123456 default tablespace FUWUQISYMBOL; --创建用户名
grant connect，resource，dba to FUWUQISYMBOL; --授权用户dba权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3a1db112d5906a4881c08d9d35cee18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/601c018399289f9c47fc23c5e6451c94/" rel="bookmark">
			centos安装nvm的node版本管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意需要外网环境，翻墙
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.38.0/install.sh | bash 安装成功后编辑.bash_profile,加入一下内容
cd ~ vim .bash_profile export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node export NVM_DIR="$HOME/.nvm" [ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm [ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion nvm ls 查看已经安装版本 nvm use 切换版本 nvm install 安装指定版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9bef7ecaa56386d7f71681fc64e040/" rel="bookmark">
			VBA之正则表达式（33）-- 网页表格提取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例需求：示例数据如下所示。
&lt;td&gt;&lt;a href="javascript:;" data-url="/gstdHb/queryInfo" data-param="{stdId:'46826'}" data-tempid="shb-info"&gt;电力变压器&lt;/a&gt;&lt;/td&gt; &lt;td class="txt-nowrap"&gt;DL/T 1539-2016&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; 从示例数据提取名称、规格和数量
电力变压器
DL/T 1539-2016
1
方法1： Sub Demo1() Dim regExp As Object, regExpMHs As Object Set regExp = CreateObject("vbscript.regExp") regExp.Global = True regExp.MultiLine = True regExp.Pattern = "&gt;([^&lt;\r\n]+)&lt;" txt = [a1] Set regExpMHs = regExp.Execute(txt) For j = 0 To regExpMHs.Count - 1 Debug.Print regExpMHs(j).submatches(0) Next Set regExpMHs = Nothing Set regExp = Nothing End Sub 代码解析：
第3行代码创建正则表达式对象。
第4行代码设置全局匹配。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a9bef7ecaa56386d7f71681fc64e040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05153949fcb316686087e91e644d2ebc/" rel="bookmark">
			git 切换分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、查看所有分支
git branch -a 2、查看当前分支(*号表示当前分支)
git branch 3、切换分支
git checkout '分支名' 4、修改代码仓库
git remote set-url origin '仓库地址' 5、提交分支代码的正确步骤
//检查本地修改文件状态 git status //添加修改文件到暂存区 git add . //提交文件到缓存区 git commit -m '这里可以写本次提交内容' //拉取服务器代码，先拉取防止代码冲突 git pull //提交文件到服务器 git push 6、拉取服务器代码到本地
git clone '服务器代码仓库地址' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b26afa7b92d98bd712a5c03deceb0c9/" rel="bookmark">
			如何在vscode当前窗口中同时打开两个项目的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近想将一个项目的工程在一个新的工程上移植，就想在当前窗口同时打开第两个项目，但是当打开新的项目文件夹时就会把第一个项目的文件夹覆盖掉，这种情况怎么解决呢？
经过查找资料，如下图操作将第二个项目的文件夹加入到工作区就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6445e6e1334f911732a21cdc25b1e838/" rel="bookmark">
			JS常用工具函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//获取随机布尔值 const randomBoolean = () =&gt; Math.random() &gt;= 0.5; randomBoolean() //反转字符串 const reverseStr = (str) =&gt; str.split('').reverse().join(''); reverseStr("hello") //数组去重 const removeDuplicates = (arr) =&gt; [...new Set(arr)]; removeDuplicates(['foo', 'bar', 'bar', 'foo', 'bar']) //判断数字奇偶 const isEven = (num) =&gt; num % 2 === 0; isEven(5) //获取日期对象的时间部分 const timeFromDate = (date) =&gt; date.toTimeString().slice(0, 8); timeFromDate(new Date(2021, 0, 10, 17, 30, 0)) //判断是否为Apple设备 const isAppleDevice = /Mac|iPod|iPhone|iPad/.test(navigator.platform) isAppleDevice //滚动到页面顶部 const goToTop = () =&gt; window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6445e6e1334f911732a21cdc25b1e838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495c8b2ba0fb9c2cbaadf488ba40432c/" rel="bookmark">
			二维数组或三维数组转换为一维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二维数组或三维数组转为一维数组 1.二维数组转换为一维数组:
设二维数组a[i][j]，数组a行数x行，列数y列； 一维数组b[n]，数组b最多存储m=x*y个元素。 令x=3，y=4则：m=12 此时，数组a中元素的位置序号(i j)为： 00	01	02	03 10	11	12	13 20	21	22	23 数组b中元素的位置序号(n)为： 0	1	2	3 4	5	6	7 8	9	10	11 数组a中每一行位置j的序号均为：0	1	2	3 因此，数组b中元素的位置序号可写成： 0+0	1+0	2+0	3+0 4+0	4+1	4+2	4+3 8+0	8+1	8+2	8+3 数组a中每列位置i的序号均为：0 1 2 因此，数组b中元素的位置序号可写成： 0*4+0	0*4+1	0*4+2	0*4+3 1*4+0	1*4+1	1*4+2	1*4+3 2*4+0	2*4+1	2*4+2	2*4+3 由上述数组b中元素的位置序号可得： n=i*y+j,其中y为数组a的列数,此例中y=4。 综上所述，经猜想与反复验证数组a中元素的位置序号(i j)与 数组b中元素的位置序号(n)的关系为；n=i*y+j(y为数组a的列数)	代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495c8b2ba0fb9c2cbaadf488ba40432c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a774029dfc405d291c97a0f9d85ef822/" rel="bookmark">
			安装pycocotools库踩坑 ERROR: Failed building wheel for pycocotools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装pycocotools库踩坑 报错： ERROR: Failed building wheel for pycocotools
subprocess-exited-with-error
legacy-install-failure
Encountered error while trying to install package.
╰─&gt; pycocotools
解决方法 输入：
pip install pycocotools-windows -i https://pypi.tuna.tsinghua.edu.cn/simple 成功！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07dd747069e346bdcbf0e2146f9798f0/" rel="bookmark">
			idea编译nacos源码失败com.alibaba.nacos.consistency.entity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		com.alibaba.nacos.consistency.entity 报错信息解决步骤下载protobuf工具配置环境变量编译 报错信息 找不到entity包
import com.alibaba.nacos.consistency.entity.ReadRequest; import com.alibaba.nacos.consistency.entity.Response; import com.alibaba.nacos.consistency.entity.WriteRequest; 解决步骤 下载protobuf工具 https://github.com/protocolbuffers/protobuf/releases/tag/v3.16.0
配置环境变量 在Path中添加D:\Program Files\protoc-3.16.0-win64\bin
编译 进入到源码的这个consistency/src/main/proto/路径下，使用cmd命令，运行如下指令
protoc --java_out=…/java/ ./consistency.proto
protoc --java_out=…/java/ ./Data.proto
命令执行完，就能编译成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d518b14acc388572f88a73d03cbd7472/" rel="bookmark">
			STM32CubeIDE开发笔记 MK.II - ST-LINK调试 与 建立用户驱动库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32CubeIDE开发笔记 MK.II - ST-LINK调试 与 建立用户驱动库 ST-LINK 构建Debug与下载调试代码编写完毕后，开始构建Debug相应设置下载并调试 建立用户驱动库建立源文件夹添加头文件和源文件文件路径配置 ST-LINK 构建Debug与下载调试 代码编写完毕后，开始构建Debug 待到构建完成后，连接ST-LINK（可能会显示更新ST-LINK驱动，显示DFU-MODE、RESTART等字样时，拔插一遍ST-LINK即可进行upgrade）
相应设置 基本保持默认设置即可
这里需要注意的是，使用ST-LINK的话，
选择调试配置 &gt; 调试器 下
ST-LINK(ST-LINK GDB server)（这里可能会弹出需要安装下这个GDB server）和SWD
下载并调试 然后再次点击Debug图标
显示下载成功
建立用户驱动库 建立源文件夹 右键工程 &gt; 新建 &gt; 源文件夹
输入源文件夹名，一般设置为那个最为经典的HARDWARE
我自己设置成了我喜欢的 User_Driver = =
在源文件夹内建立 Inc 文件夹 和 Src 文件夹 ，分别存放 .h 和 .c 文件
添加头文件和源文件 这里 以 MK.I - 点亮LED灯 为例
新建 .h 和 .c 文件
在Inc文件夹下输入XXX.h 头文件并完成创建
同理，在Src文件夹下创建XXX.c源文件
文件路径配置 右键工程 &gt; 属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d518b14acc388572f88a73d03cbd7472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e71ced5c4a8d26b9ff95038c82cd4c/" rel="bookmark">
			三分钟学会渗透测试——信息收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是信息收集 信息收集主要是收集服务器的配置信息和网站的敏感信息，主要包括域名信息、子域名信息、目标网站信息、目标网站真实IP、目录文件、开放端口和服务、中间件信息等等。在进行渗透测试之前，第一步也是非常关键的一步就是对目标进行信息收集，我们尽可能收集关于目标的信息，这将会大大提高发现漏洞的概率
当拿到一个网站的时，从基本信息入手，可以收集如IP、端口、域名、网段等；从系统信息入手，可以获取其中操作系统与版本；从应用信息入手，获取各个端口应用服务，如web应用、邮件应用等；又或者从服务信息入手，获取高危服务，如文件共享服务
信息收集大致分类 第一类：主动信息收集。通过直接访问、扫描网站
第二类：被动信息收集。利用第三方的服务对目标进行访问了解，比例：谷歌搜索、SSL证书查询、Shodan搜索等等
Whois 在进行网站注册的时候，需要申请域名，申请之后这些注册的信息将会保存到相关的域名数据库服务器中，并且这些域名信息经常是公开的，任何人都可以查询。
如果我们可以获取目标的真实ip，那么还需要对网站域名whois信息进行收集。
Whois就是一个用于查询域名是否已经被注册，如果以及注册，可以查询相关信息的数据库（注册人姓名、注册人的E-mail、电话号、注册机构、通信地址、邮编、注册有效时间、失效时间查询等等），然后利用谷歌的语法搜索，搜索出关于域名的很多信息。
1）利用网站 网站查询：Network Tools by YouGetSignal.com
站长之家：http://whois.chinaz.com
2）利用kali下自带的whois kali下的whois+域名
子域名探测 子域名也称二级域名，当进行渗透测试的时候，一些目标网站的规模比较大，主站会进行重点防御，安全性强，下手难度高。通过子域名探测，可以对目标网站下发现更多的域或子域，大大提高漏洞发现的概率，再通过这些子域，接近真正的目标。除了不太现实的手动探测外，一般使用工具进行挖掘，如Layer，subDomainsBrute，K8PortScan
一.工具 1）Layer子域名挖掘工具 直接输入域名，选择要扫描的端口，设置线程即可，而且图形化界面使用起来简单快捷
2）subDomainsBrute lijiejie 基本命令python subDomainsBrute.py baidu.com
扫描完成之后，在M:\子域名检测lijiejie\subDomainsBrute-master\tmp下存放着扫描到的子域名
3）scanport 二.语法搜索 利用谷歌的语法搜索子域名
谷歌常用语法及其说明
关键字
说明
举例
site
限制搜索范围的域名
site:edu.cn
inurl
URL中存在关键字的网页
Inurl:ganyu
intext
搜索网页&lt;body&gt;部分的关键字
Intext:ganyu
filetype
搜索文件的特定后缀或者扩展名
filetype:txt
intitle
搜索网页标题的关键字
intitle:ganyu
link
返回所有与baidu.com做链接的URL
link:baidu.com
info
查找指定站点的一些基本信息
Info:baidu
三.SSL证书 https://myssl.com/ssl.html
CDN绕过 什么是CDN？ CDN全称是Content Delivery Network（内容分发网络），用处是将源站内容分发存储至各个节点，当用户需求源站资源时，只需取得距用户最近的一个节点，获取所需内容，大大提高了用户访问时的响应速度，解决因分布距离、带宽大小、服务器性能带来的访问延迟问题，其实就是将内容缓存在终端用户附近。
举个例子，当用户点击网站的一个URL时，DNS会根据点击的这个URL去寻求IP地址解析，如果网站开启了CDN服务，会由CDN专用DNS服务器去处理这个IP，然后将CDN的全局负载均衡设备IP地址返回用户。用户根据给的IP，访问全局负载均衡，负载均衡按照用户的URL，选择一台举例用户最近缓存服务器，将这台服务器的IP告诉用户，用户向缓存服务器发起请求，最后将资源传输给用户终端。
所以如果信息收集目标开启了CDN服务，虽然可以直接ping域名，但是得到的并非真正的IP，只是距离我们最近一台目标节点的CND服务器IP，所以使得我们无法或者真实的IP地址。
一.判断是否开启了CDN绕过 1)在不同的地方ping同一个域名【有时候ping出的ip不唯一但是固定的几个，可能未使用CDN而使用的是双线。】
2)利用在线网站进行多地区ping 多个地点Ping服务器,网站测速 - 站长工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e71ced5c4a8d26b9ff95038c82cd4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb4783d701d111b07f835affc1570f45/" rel="bookmark">
			Property ‘xxx‘ does not exist on type ‘xxx‘报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用ts写一个组件的时候，遇到了Property ‘increment’ does not exist on type 'Add’的红点儿报错，但神奇的是竟然还能正常运行。
在参考一些正确的代码后，有两个解决方案。
在export default class Add extends Vue {} 里面定义对应的Prop：
import { Component, Vue, Prop } from “vue-property-decorator”;
import { mapState } from “vuex”;
@Component({
computed: {
…mapState({
sum: (state) =&gt; (state as Record&lt;string, number&gt;).sum,
}),
},
methods: {
//…mapActions([“Add”, “Subtract”]),
increment() {
this.KaTeX parse error: Expected 'EOF', got '}' at position 28: …ch("Add"); }̲, decrement…store.dispatch(“Subtract”);
},
},
})
export default class Add extends Vue {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb4783d701d111b07f835affc1570f45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c3794e7cffb9cb27b0f21faf346595/" rel="bookmark">
			下载网页视频并自动合成视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （本人博客已迁移至 https://nasdaqgodzilla.github.io/）
1. 首先使用Chrome打开网页，单击F12打开开发者工具 开始视频播放，在F12出来的界面中单击Network在Network中有文件列表，检查当中是否存在m3u8结尾的文件 2. 如果有m3u8结尾的文件，把它的源地址复制下来 源地址复制下来可能分两段（两个http），一段是跳转地址，一段是目标地址，将目标地址保留下来即可。正确的m3u8文件地址大概的样子在下面的命令示例中 3. 使用以下命令一键下载并自动合成、转码为mp4 ffmpeg -i http://xxx.com:8891/1231/index.m3u8 -c copy -bsf:a aac_adtstoasc output.mp4 4. 注意事项 必须安装ffmpeg，Linux、Mac可以使用常规方法安装，Windows直接去官网下载二进制包直接用、当网页中播放的视频流是ts格式的时候，本方法适用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995fd66126ace5c0f2beac35ae86d061/" rel="bookmark">
			golang操作mongodb数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装驱动并连接数据库 下载地址https://www.mongodb.com/try/download/community
打开客户端 mongo.exe 创建数据库 use go_db; 创建集合 db.createCollection("student"); 下载驱动https://pkg.go.dev/go.mongodb.org/mongo-driver go get go.mongodb.org/mongo-driver/mongo go连接MongoDB package main import ( "context" "fmt" "log" "go.mongodb.org/mongo-driver/mongo" "go.mongodb.org/mongo-driver/mongo/options" ) var client *mongo.Client func initDB() { // 设置客户端连接配置 co := options.Client().ApplyURI("mongodb://localhost:27017") // 连接到MongoDB var err error c, err2 := mongo.Connect(context.TODO(), co) if err2 != nil { log.Fatal(err2) } // 检查连接 err3 := c.Ping(context.TODO(), nil) if err != nil { log.Fatal(err3) } fmt.Println("mongodb connected") } func main() { initDB() } 添加文档 添加一条文档
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995fd66126ace5c0f2beac35ae86d061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579baed83e3f6ff94f35e23ccb64b60c/" rel="bookmark">
			Visual Studio工具过滤不想关的文件和文件夹目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点击Visual Studtio左下角的设置功能
2.选择Setting菜单项
3.在搜索框中输入file exclude
4.在Add Pattern中输入要过滤的文件和目录
**/*.d 过滤掉所有文件夹中的.d文件
**/tmp：过滤掉所有文件目录下的tmp文件目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d744c89c4ed670af04d53a8a3d2c3f25/" rel="bookmark">
			IDEA配置Gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Git配置1.Git安装教程2.IDEA配置Git 二、Gitee配置1.安装Gitee插件2.注册Gitee账号3.配置Gitee相关账号信息4.进行代码绑定5.Gitee代码上传下载1.云端文件下载到本地2.本地文件上传云端 前言 本教程所需前提本地Git安装，以及Gitee账号注册
一、Git配置 1.Git安装教程 链接: Git安装教程
2.IDEA配置Git File-&gt;Setting-&gt;Version Control-&gt;Git选择Git安装目录 二、Gitee配置 1.安装Gitee插件 File-&gt;Settings-&gt;Plugins-&gt;Gitee安装后重启 2.注册Gitee账号 注册Gitee账号，绑定邮箱链接: Gitee 3.配置Gitee相关账号信息 File-&gt;Setting-&gt;Version Control-&gt;Gitee
Add account
填写Gitee账号（邮箱）和密码
4.进行代码绑定 在Gitee云端新建仓库
选择项目-&gt;VCS-&gt;Import into Version Control-&gt;Create Git Repository
选择当前文件（不要选择父级目录）
如果项目出现这些红色文件，说明项目和git绑定成功，处在版本控制内
5.Gitee代码上传下载 复制云端仓库地址
本地项目和云端地址绑定
选中项目-&gt;Git-&gt;Repository-&gt;Remotes
＋-&gt;粘贴Gitee仓库地址
1.云端文件下载到本地 选中项目-&gt;Git-&gt;Repository-&gt;Pull
将云端项目拉取到本地
云端文件拉取到本地
2.本地文件上传云端 选中当前项目-&gt;Git-&gt;Add
选中当前项目-&gt;Git-&gt;Commit Directory尽量选中src文件目录下的和pom.xml文件提交，其他文件提交可能会导致冲突
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18244d9317612ab4303c5f25364b8e9/" rel="bookmark">
			Uncaught ReferenceError: module is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误出现原因：由于是js原生，系统不自带module对象。
解决方案：
const obj = {}; try { console.log(window.name) } catch (e) { module.exports = obj } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23275dcb9a064729561bd64b3e002285/" rel="bookmark">
			C语言 系统调用操作内核信号集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 、、使用内存映射可以拷贝文件 /* 对原始文件进行内存映射 创建一个新文件 把新文件的数据拷贝映射到内存中 通过内存拷贝将第一个文件的内存映射区拷贝到第二个文件的内存映射区 释放资源 */ // 匿名映射，不需要文件实体来进行内存映射 // 只能用于有血缘关系的进程间通信 #include &lt;sys/mman.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; // int main() // { /* // kill函数 // pid》0将信号发送给指定进程 // =0：将信号发送给当前进程组 // =-1：将信号发送给每一个有权限接受这个信号的进程 // 《-1：进程组id的绝对值 // sig，要发送的信号 // kill(getppid(), 9); // kill(getpid(), 9); // raise函数，给当前进程发送信号 // sig，要发送的信号，成功返回0，失败返回非0*/ // alarm函数 // 设置定时器，倒计时，当时间为0的时候，会给当前进程发送一个 SIGALARM信号 // 取消定时器，alarm(0)即可 // 返回值是unsigned int，倒计时剩余的时间（上一个alarm剩余的时间） // SIGALRARM信号默认终止当前进程，每个进程只能设置一个定时器 // int seconds = alarm(5); // printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23275dcb9a064729561bd64b3e002285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e2bec5b1466cf10d6725bf57a3310c/" rel="bookmark">
			Cannot load configuration class: org.springframework.boot.autoconfigure报错 如何解决？注意核对版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贴一下报错信息
D:\Android\JDK\bin\java.exe "-javaagent:D:\IDEA\IntelliJ IDEA Community Edition 2021.3.2\lib\idea_rt.jar=59350:D:\IDEA\IntelliJ IDEA Community Edition 2021.3.2\bin" -Dfile.encoding=UTF-8 -classpath E:\Code\JA_code\miaosha1\target\classes;C:\Users\\.m2\repository\org\springframework\boot\spring-boot-starter-web\2.0.5.RELEASE\spring-boot-starter-web-2.0.5.RELEASE.jar;C:\Users\\.m2\repository\org\springframework\boot\spring-boot-starter\2.0.5.RELEASE\spring-boot-starter-2.0.5.RELEASE.jar;C:\Users\\.m2\repository\org\springframework\boot\spring-boot\2.0.5.RELEASE\spring-boot-2.0.5.RELEASE.jar;C:\Users\\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\2.0.5.RELEASE\spring-boot-autoconfigure-2.0.5.RELEASE.jar;C:\Users\\.m2\repository\org\springframework\boot\spring-boot-starter-logging\2.0.5.RELEASE\spring-boot-starter-logging-2.0.5.RELEASE.jar;C:\Users\\.m2\repository\ch\qos\logback\logback-classic\1.2.3\logback-classic-1.2.3.jar;C:\Users\\.m2\repository\ch\qos\logback\logback-core\1.2.3\logback-core-1.2.3.jar;C:\Users\\.m2\repository\org\slf4j\slf4j-api\1.7.25\slf4j-api-1.7.25.jar;C:\Users\\.m2\repository\org\apache\logging\log4j\log4j-to-slf4j\2.10.0\log4j-to-slf4j-2.10.0.jar;C:\Users\\.m2\repository\org\apache\logging\log4j\log4j-api\2.10.0\log4j-api-2.10.0.jar;C:\Users\\.m2\repository\org\slf4j\jul-to-slf4j\1.7.25\jul-to-slf4j-1.7.25.jar;C:\Users\\.m2\repository\javax\annotation\javax.annotation-api\1.3.2\javax.annotation-api-1.3.2.jar;C:\Users\\.m2\repository\org\springframework\spring-core\5.0.9.RELEASE\spring-core-5.0.9.RELEASE.jar;C:\Users\\.m2\repository\org\springframework\spring-jcl\5.0.9.RELEASE\spring-jcl-5.0.9.RELEASE.jar;C:\Users\\.m2\repository\org\yaml\snakeyaml\1.19\snakeyaml-1.19.jar;C:\Users\\.m2\repository\org\springframework\boot\spring-boot-starter-json\2.0.5.RELEASE\spring-boot-starter-json-2.0.5.RELEASE.jar;C:\Users\\.m2\repository\com\fasterxml\jackson\core\jackson-databind\2.9.6\jackson-databind-2.9.6.jar;C:\Users\\.m2\repository\com\fasterxml\jackson\core\jackson-annotations\2.9.0\jackson-annotations-2.9.0.jar;C:\Users\\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.9.6\jackson-core-2.9.6.jar;C:\Users\\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.9.6\jackson-datatype-jdk8-2.9.6.jar;C:\Users\\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.9.6\jackson-datatype-jsr310-2.9.6.jar;C:\Users\\.m2\repository\com\fasterxml\jackson\module\jackson-module-parameter-names\2.9.6\jackson-module-parameter-names-2.9.6.jar;C:\Users\\.m2\repository\org\springframework\boot\spring-boot-starter-tomcat\2.0.5.RELEASE\spring-boot-starter-tomcat-2.0.5.RELEASE.jar;C:\Users\\.m2\repository\org\apache\tomcat\embed\tomcat-embed-core\8.5.34\tomcat-embed-core-8.5.34.jar;C:\Users\\.m2\repository\org\apache\tomcat\embed\tomcat-embed-el\8.5.34\tomcat-embed-el-8.5.34.jar;C:\Users\.m2\repository\org\apache\tomcat\embed\tomcat-embed-websocket\8.5.34\tomcat-embed-websocket-8.5.34.jar;C:\Users\\.m2\repository\org\hibernate\validator\hibernate-validator\6.0.12.Final\hibernate-validator-6.0.12.Final.jar;C:\Users\\.m2\repository\javax\validation\validation-api\2.0.1.Final\validation-api-2.0.1.Final.jar;C:\Users\\.m2\repository\org\jboss\logging\jboss-logging\3.3.2.Final\jboss-logging-3.3.2.Final.jar;C:\Users\\.m2\repository\com\fasterxml\classmate\1.3.4\classmate-1.3.4.jar;C:\Users\\.m2\repository\org\springframework\spring-web\5.0.9.RELEASE\spring-web-5.0.9.RELEASE.jar;C:\Users\\.m2\repository\org\springframework\spring-beans\5.0.9.RELEASE\spring-beans-5.0.9.RELEASE.jar;C:\Users\\.m2\repository\org\springframework\spring-webmvc\5.0.9.RELEASE\spring-webmvc-5.0.9.RELEASE.jar;C:\Users\\.m2\repository\org\springframework\spring-aop\5.0.9.RELEASE\spring-aop-5.0.9.RELEASE.jar;C:\Users\\.m2\repository\org\springframework\spring-context\5.0.9.RELEASE\spring-context-5.0.9.RELEASE.jar;C:\Users\\.m2\repository\org\springframework\spring-expression\5.0.9.RELEASE\spring-expression-5.0.9.RELEASE.jar com.miaoshaproject.App Hello World! . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7e2bec5b1466cf10d6725bf57a3310c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39136d72500619ae234d6634412a0091/" rel="bookmark">
			2022年最新前端面试题（大前端时代来临卷起来吧小伙子们..持续维护走到哪记到哪）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML和Css部分 1、对BFC规范（块级格式化上下文）的理解 BFC 块级格式化上下文 一块独立的区域，有自己的规则，bfc中的元素与外界的元素互不影响
BFC是一块用来独立的布局环境，保护其中内部元素不受外部影响，也不影响外部。
怎么触发BFC
1. float的值left或right
2. overflow的值不为visible（默认）
3. display的值为inline-block、table-cell、table-caption
4. position的值为absolute（绝对定位）或fixed固定定位
规则：
1、BFC的区域不会与float box重叠。
2、BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。
3、计算BFC的高度时，浮动元素也会参与计算。
4、内部的Box会在垂直方向上一个接一个放置。
5、Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。
BEC的应用 1、可以用来自适应布局
利用BFC的这个原理可以实现两栏布局，左边定宽，右边自适应。不会相互影响，哪怕高度不相等。
给左边盒子加浮动，右边盒子加overflow:hidden;变成BFC，就可以消除外部左边盒子因浮动对他的影响
2、可以清除浮动
一个父元素中的子元素，设置浮动时，父元素没有设置高度，这时子元素脱离文档流，父元素感知不到子元素的高度，造成父元素的塌陷。 这时候给父元素添加overflow:hidden / auto,变成BFC就可以解决这种问题。
**3、**解决垂直边距重叠 1.父子关系的边距重叠
父子关系，如果子元素设置了外边距，在没有把父元素变成BFC的情况下，父元素也会产生外边距。
解决办法: 是给父元素添加一个 overflow:hidden，这样父元素就变为BFC，不会随子元素产生外边距
2.同级兄弟关系的重叠
同级元素在垂直方向上外边距会出现重叠现象，最后外边距的大小取两者绝对值大的那个
可通过添加一个空元素或伪类元素，设置overflow:hidden;解决
2、什么是渐进增强优雅降级 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后在针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
3、从浏览器地址栏输入url到显示页面的步骤 · 浏览器根据请求的 URL 交给 DNS 进行域名解析，找到真实 IP 地址，向服务器发起请求；
· 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、CSS、JS、images等）；
· 浏览器对加载到的资源（HTML、CSS、JS、images等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
· 载入解析到的资源文件，渲染页面，完成。
4、CSS特性：继承性，层叠，优先级 1、继承性：子标签会继承父标签的某些样式，如文本颜色和字号。(text- font- color)
2、层叠性：样式冲突，遵循的原则是就近原则。
3、优先级：定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，谁的权重高显示谁的样式。
（选择器相同，则执行层叠性；选择器不同，就会出现优先级的问题。）
!Important &gt; 行内式 &gt; id &gt; 类/伪类/属性 &gt; 标签选择器 &gt; 全局
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39136d72500619ae234d6634412a0091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24cd7d6bb536333cbab1a0c601f276f5/" rel="bookmark">
			python 读取数据出现UnicodeDecodeError：: ‘utf-8‘ codec can‘t decode byte 0xc8 in position 0: invalid contin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法: 读取时也可以用二进制模式打开的文件（包括模式参数中的'rb'）将内容作为字节对象，而不进行任何解码。
然后使用line.decode(‘utf-8’，errors = 'ignore')解码，其中的errors参数:修改字符集参数，一般这种情况出现得较多是在国标码(GBK)和utf-8之间选择出现了问题。出现异常报错是由于设置了decode()方法的第二个参数errors为严格（'strict'）形式造成的，因为默认就是这个参数，将其更改为'ignore'等即可。
举例:
import os path = r'.\es' for file in os.listdir(path): file_path = os.path.join(path,file) file_output = os.path.join(path,f"{file}.txt") with open(file_path,mode='rb') as f: # 使用二进制形式'rb'进行读取 with open(file_output,mode='a+',encoding = 'utf-8') as w: for line in f.readlines(): line_content = line.decode('utf-8',errors='ignore').strip().split() # 使用'utf-8'进行解码,errors='ignore'进行忽略 if len(line_content) == 0: w.write('\n') else: w.write(str(line_content[0].strip()) + ' ' + str(line_content[-1].strip()) + '\n') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c6af8974f249e702105bdb92d84450/" rel="bookmark">
			什么是守护线程？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java提供了两种线程：守护线程和用户线程
守护线程，是指在程序运行时 在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分。通俗点讲，任何一个守护线程都是整个JVM中所有非守护线程的"保姆"。
用户线程和守护线程几乎一样，唯一的不同之处在于如果用户线程已经全部退出运行，只剩下守护线程存在了,JVM也就退出了。因为当所有非守护线程结束时，没有了被守护者，守护线程也就没有工作可做，当然也就没有继续执行的必要了，程序就会终止，同时会杀死所有的"守护线程"，也就是说只要有任何非守护线程还在运行，程序就不会终止
在Java语言中，守护线程一般具有较低的优先级，它并非只由JVM内部提供，用户在编写程序时也可以自己设置守护线程，例如：将一个线程设置为守护线程的方法就是在调用start()启动线程之前调用对象的setDaemon(true)方法，若将以上参数设置为false，则表示的是用户进程模式，需要注意的是，当在一个守护线程中产生了其他的线程，那么这些新产生的线程默认还是守护线程，用户线程也是如此。
class MyThread extends Thread{ @Override public void run() { System.out.println(Thread.currentThread().getName()+" begin...."); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+" end....."); } } public class Test { public static void main(String[] args){ System.out.println("main begin...."); Thread thread = new MyThread(); thread.setName("线程A"); thread.setDaemon(true); thread.start(); System.out.println("main end....."); } } 从运行结果可以发现，没有输出线程A end…之所以结果是这样，是因为在启动前将线程A设置为了守护线程，当程序中只有守护线程存在时，JVM是可以退出的。也就是说，当JVM中只有守护线程运行时JVM会自动关闭。因此当main方法调用结束后，main线程退出，此时守护线程A还处于休眠状态没有运行结束，但是由于此时只有守护线程在运行，JVM将会关闭。因此不会输出线程A end…
守护线程的一个典型的例子就是垃圾回收器。只要JVM启动，它始终在运行，实时监控和管理系统中可以被回收的资源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd763950d483ed7636ba4f23850673f/" rel="bookmark">
			动态规划之背包问题——完全背包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法相关数据结构总结：
序号数据结构文章1动态规划动态规划之背包问题——01背包 动态规划之背包问题——完全背包
动态规划之打家劫舍系列问题
动态规划之股票买卖系列问题
动态规划之子序列问题
算法（Java）——动态规划2数组算法分析之数组问题3链表算法分析之链表问题 算法（Java）——链表4二叉树算法分析之二叉树 算法分析之二叉树遍历
算法分析之二叉树常见问题
算法（Java）——二叉树5哈希表算法分析之哈希表
算法（Java）——HashMap、HashSet、ArrayList6字符串算法分析之字符串
算法（Java）——字符串String7栈和队列算法分析之栈和队列
算法（Java）——栈、队列、堆8贪心算法算法分析之贪心算法9回溯Java实现回溯算法入门（排列+组合+子集）
Java实现回溯算法进阶（搜索）10二分查找算法（Java）——二分法查找11双指针、滑动窗口算法（Java）——双指针
算法分析之滑动窗口类问题 文章目录 一、完全背包问题二、完全背包遍历顺序三、leetcode例题讲解完全背包问题518. 零钱兑换 II377. 组合总和 Ⅳ322. 零钱兑换279. 完全平方数139. 单词拆分 四、完全背包问题总结1. 动规五步分析法2. 背包递推公式3. 遍历顺序 前面整理了01背包，在leetcode题库中主要就是01背包和完全背包问题，所以在这里整理一下完全背包的知识点。
一、完全背包问题 有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。
完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。
注：leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题。
01背包和完全背包唯一不同就是体现在遍历顺序上，所以针对遍历顺序进行分析。其它动规五部曲参考01背包。
二、完全背包遍历顺序 首先回顾一下01背包的遍历顺序：
for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } 我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd763950d483ed7636ba4f23850673f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a16487f7c578c679a865fb9bb6fe7bbd/" rel="bookmark">
			老杜MySQL入门34道题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、取得每个部门最高薪水的人员名称
SELECT ENAME,SAL,T1.DEPTNO
FROM(SELECT MAX(SAL) MAXSAL,DEPTNO FROM EMP GROUP BY DEPTNO) T1
JOIN EMP T2
ON T1.DEPTNO=T2.DEPTNO AND T1.MAXSAL=T2.SAL;
2、哪些人的薪水在部门的平均薪水之上
SELECT ENAME,SAL,AVGSAL,T1.DEPTNO
FROM (SELECT AVG(SAL) AVGSAL,DEPTNO FROM EMP GROUP BY DEPTNO) T1
JOIN EMP T2
ON T1.DEPTNO=T2.DEPTNO
WHERE SAL&gt;AVGSAL;
3、取得部门中（所有人的）平均薪水的等级
SELECT DEPTNO,AVGSAL,GRADE
FROM (SELECT AVG(SAL) AVGSAL,DEPTNO FROM EMP GROUP BY DEPTNO) T1
JOIN SALGRADE T2
ON T1.AVGSAL BETWEEN T2.LOSAL AND T2.HISAL;
4、不准用组函数（Max），取得最高薪水
//降序，limit 1
SELECT SAL
FROM EMP ORDER BY SAL DESC LIMIT 1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a16487f7c578c679a865fb9bb6fe7bbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983f96cc676679cf2330ae8094603609/" rel="bookmark">
			使用 Canvas 手画不规则多边形，并限制相交线和凹多边形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 使用 Canvas 实现的手画不规则多边形功能。通过鼠标在画面上点击的点作为多边形的顶点，连线形成多边形。除了手画之外，还加入了随机生成和回显，检测多边形横穿，凹凸性的检测。注意：两个点如果靠太近会被认为是同一个点而忽略。闭合区域需要点击图形中的第一个点，或者点击“闭合图形”按钮。
两个 Canvas 图层 由于要实现线条跟随鼠标运动功能，而且 Canvas 的图形无法清除单个绘制命令，因此我用 CSS 的绝对定位，在同一个区域叠加了两个 Canvas 对象。一个在下面，表示已经绘制结束的图形，叫做固定 Canvas；一个在上面，每次鼠标移动就重新绘制跟随鼠标移动的线条，叫做临时 Canvas。canvasTemp 即为临时 Canvas。
&lt;template&gt; &lt;div class="canvas-box" :style="{ width: canvasWidth + 'px', height: canvasHeight + 'px' }" &gt; &lt;canvas ref="canvas" :width="canvasWidth" :height="canvasHeight" class="canvas" &gt;&lt;/canvas&gt; &lt;canvas ref="canvasTemp" class="canvas" :width="canvasWidth" :height="canvasHeight" @mousedown="draw" &gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/template&gt; &lt;style lang="less" scoped&gt; .canvas-box { margin: 5px auto; background: #aaa; position: relative; .canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; } } &lt;/style&gt; 绘制过程 绘画过程简要描述为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/983f96cc676679cf2330ae8094603609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ea835e8e94301e2c9c03ea450ea59e/" rel="bookmark">
			史上最全linux语法汇总，教你一文掌握linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hadoop命令： #登录hadoop：kinit [user] kinit &lt; passwd hadoop fs -ls /user/ # 查看hdfs目录下文件 hadoop fs -put file /user/ # 上传passwd文件到hadoop目录 #调取hadoop日志： alias bhive=beeline -u "hadoop.com" --hivevar user=hongshaofen bhive -f obtain_log_wjwl_0902.sql hadoop fs -getmerge /user/hive/warehouse/tj_tmp.db/hongshaofeng_monitorlog_jryk_20210902 hongshaofeng_monitorlog_jryk_20210902.tsv（大写会变小写） #在Hadoop上下载该日志到本地服务器： hadoop fs -ls /user/hive/warehouse/tj_tmp.db/ |grep hongshaofeng # 查看关于我的进程文件 yarn application -list ：显示当前集群中的任务列表，任务状态包含：SUBMITTED，ACCEPTED，RUNNING yarn application -kill [application ID] ：application ID可以使用list获得，停止指定ID的集群中的任务。KILL后的认为状态为KILLED。 linux 常用语法： 快捷键：ctrl +A 回到行首，ctrl +E 回到行尾，ctrl+u删除所有输入的字符，ctrl+w删除最近一个单词。ctrl+c退出回到终端，ctrl+z 退出python命令。 home，0回到行首，end、$回到行尾，u撤回。 0、文件权限： d表示文件夹，-表示普通文件。rwx表示权限，r可读，w可写，x可执行，---表示不可读不可写不可执行。 1、查看命令 ll | grep name # 列出name字段的文件及文件夹，有序显示出来， ls -a #列出所有文件包括以‘.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ea835e8e94301e2c9c03ea450ea59e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306c9c488efe599c899ea0be14897c11/" rel="bookmark">
			linux下查看显卡和驱动版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$ lspci | grep -i vga 17:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1) 65:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1) 看其中某一个更详细的信息
lspci -v -s 17:00.0 17:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1) (prog-if 00 [VGA controller]) Subsystem: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] Flags: bus master, fast devsel, latency 0, IRQ 67, NUMA node 0 Memory at b4000000 (32-bit, non-prefetchable) [size=16M] Memory at 381fe0000000 (64-bit, prefetchable) [size=256M] Memory at 381ff0000000 (64-bit, prefetchable) [size=32M] I/O ports at 7000 [size=128] [virtual] Expansion ROM at b5000000 [disabled] [size=512K] Capabilities: &lt;access denied&gt; Kernel driver in use: nvidia Kernel modules: nvidiafb, nouveau, nvidia_drm, nvidia nvidia显卡可以用nvidia-smi查看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/306c9c488efe599c899ea0be14897c11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17449b27221657c47d97e60704d1861c/" rel="bookmark">
			自己的网站被劫持跳转时该怎么解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为前段时间有朋友咨询了这个问题，今天就给各位看官好好讲讲网站被劫持跳转时该怎么解决这个问题！
大多数因特网服务依赖于DNS而工作，一旦DNS出错，就无法连接Web站点，电子邮件的发送也会终止，其解决跳转的方式为
1；用Chrome浏览器打开阿里云管理后台，点击域名。
2；在域名控制台招待你要修改的DNS的域名，点击其后面的管理。
3；点击DNS修改
4；点击修改DNS服务器。
5；填写新的DNS记录值，然后确认
6；最后输入手机号验证码。
注意事项；DNS作为可以将域名和IP地址互相映射的一个分布式数据库，能够使人更方便的访问互联网，而不用不记住能被机器直接读取的IP数串。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ef9e01b8eddd3371821ee3c6296ecc/" rel="bookmark">
			Java虚拟机常用性能监控和故障处理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.jps：虚拟机进程状况工具 JDK的很多小工具的名字都参考了UNIX命令的命名方式，jps（JVM Process Status Tool）是其中 的典型。除了名字像UNIX的ps命令之外，它的功能也和ps命令类似：可以列出正在运行的虚拟机进 程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一 ID（LVMID，Local Virtual Machine Identifier）。虽然功能比较单一，但它绝对是使用频率最高的JDK 命令行工具，因为其他的JDK工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进 程。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID，Process Identifier）是一致的，使 用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID，但如果同时启动了 多个虚拟机进程，无法根据进程名称定位时，那就必须依赖jps命令显示主类的功能才能区分了。
public class JavaVMStackOOM { private void dontStop() { while (true) { } } public void stackLeakByThread() { Thread thread = new Thread(new Runnable() { @Override public void run() { dontStop(); } }); thread.start(); } public static void main(String[] args) { JavaVMStackOOM javaVMStackOOM = new JavaVMStackOOM(); javaVMStackOOM.stackLeakByThread(); System.out.println(System.getProperties()); } } 启动上边测试程序查看进程状态
2. jstat：虚拟机统计信息监视工具 jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可 以显示本地或者远程[1]虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据，在没有 GUI图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ef9e01b8eddd3371821ee3c6296ecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e86ab8e5b937c7afead0cfbd26520f/" rel="bookmark">
			课堂同步练习选择题（第三章）题库信阳师范学院柳春华老师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有红色，红色为正确答案 ；若无，蓝（绿）色为正确答案 第三章 处理机调度与死锁 一、章节习题 1、在分时系统中，进程调度经常采用______算法。
A 先来先服务 B 最大优先权 C 时间片轮转 D 随机
2、进程调度有各种各样的算法，如果算法处理不当，就会出现____现象。
A 颠簸（抖动） B 饥饿 C 死锁 (竞争资源) D Belady（异常）
3、下列____进程调度算法会引起进程的饥饿问题。
A 先来先服务 B 时间片轮转 C 优先级 D 多级反馈队列
4、在进程调度中，最有利于提高资源的使用率、能使短作业、长作业及交互作业用户都比较满意的调度算法是_______.
A FCFS调度算法 B 短作业优先调度算法 C 时间片轮转法 D 多级反馈队列调度算法
5、进程调度又称低级调度，其主要功能是________.
A 选择一个作业调入内存 B 选择一个主存中的进程调出到外存
C 选择一个外存中的进程调入内存 D 将一个就绪的进程投入运行
6、若进程P一旦被唤醒就能够投入运行，系统可能为______
A 分时系统，进程P的优先权最高 B 抢占调度方式，就绪队列上的所有进程的优先级皆比P的低
C 就绪队列为空队列
D 抢占调度方式，P的优先级高于当前运行的进程
7、_____优先权是在创建进程时确定的，确定之后在整个进程的运行时间不再改变
A 先来先服务 B 静态 C 动态 D 短作业
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73e86ab8e5b937c7afead0cfbd26520f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b421c56d3193151eabea7edd24f4645b/" rel="bookmark">
			Errors during downloading metadata for repository ‘appstream‘ Centos8 yum 失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Errors during downloading metadata for repository ‘appstream’ Centos8 yum 失败 问题说明 在使用yum命令下载安装一些包时发现官方源下线导致无法使用。
提示如下错误信息：Errors during downloading metadata for repository ‘appstream’:
错误：为仓库 ‘appstream’ 下载元数据失败 : Cannot download repomd.xml: Cannot download repodata/repomd.xml: All mirrors were tried
解决方案：将yum更换到最新的阿里源
操作流程 操作流程 进入文件路径查看当前配置文件
# 进入配置文件夹，查看配置文件列表 cd /etc/yum.repos.d/ 移除当前配置文件
# 删以.repo结尾的文件 rm *.repo # 重新查看列表，确认repo文件已完全删除 ls 从阿里镜像站找到Centos8最新repo文件并复制对应URL地址
根据URL地址下载repo文件
# 根据请求地址下载repo文件 wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo 运行 yum makecache 生成缓存
yum makecache 重新yum命令，已经可以正常使用。(图中执行的是docker安装)
小结 持续解决遇到的异常问题，不断积累对虚拟环境的了解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179e877c60d30a254747801b88881a4d/" rel="bookmark">
			史上最全pandas语法汇总，教你一文掌握pandas
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/usr/bin/env python # -*- coding: utf-8 -*- # @Author : honshaofeng # @Time : 2021/7/28 17:51 # @File : notes.py # @Project : tianjikit-master sklearn语法模块汇总 import matplotlib.pyplot as plt from sklearn import datasets from sklearn.model_selection import train_test_split,cross_val_score from sklearn.model_selection import GridSearchCV from sklearn.metrics import accuracy_score from xgboost import XGBClassifier from xgboost import plot_importance from sklearn.ensemble import RandomForestRegressor 【集成学习】sklearn中xgboost模块的XGBClassifier函数 # 常规参数 booster：gbtree时，树模型为基分类器（默认）；gbliner时， 线性模型为基分类器. silent ：silent=0时，不输出中间过程（默认）； silent=1时，输出中间过程. nthread： nthread=-1时，使用全部CPU进行并行运算（默认） nthread=1时，使用1个CPU进行运算。 scale_pos_weight：正样本的权重，在二分类任务中，当正负样本比例失衡时，设置正样本的权重，模型效果更好。例如，当正负样本比例为1:10时，scale_pos_weight=10。 # 模型参数 n_estimatores：总共迭代的次数，即决策树的个数 early_stopping_rounds ：含义：在验证集上，当连续n次迭代，分数没有提高后，提前终止训练。调参：防止overfitting。 max_depth：树的深度，默认值为6，典型值3-10。 调参：值越大，越容易过拟合；值越小，越容易欠拟合。 min_child_weight：默认值为1。 调参：值越大，越容易欠拟合；值越小，越容易过拟合（值较大时，避免模型学习到局部的特殊样本）。 subsample：训练每棵树时，使用的数据占全部训练集的比例。默认值为1，典型值为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/179e877c60d30a254747801b88881a4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261e701afcdcdc39171bcef8624c0f60/" rel="bookmark">
			计算机里边的单位换算：b、KB、MB、GB、TB等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Mbps即“传输速率”，也叫带宽。理论上8Mbps换算成下载速度是1MB/s，实际情况中8Mbps的带宽往往达不到1MB/s的下载速度，能达到800KB/s以上算是正常情况。
1Mbps=0.125MB（1Byte=8bit）大小写严格限定，不能混用
bit代表位，存放一位二进制数，即0或1，最小的存储单位
Byte代表字节，8个二进制位为一个字节，即1Byte=8bit，Byte为数据量常用单位
Mbps（Mb/s）的含义是兆比特每秒，指每秒传输的位数量
MB/s的含义是兆字节每秒，指每秒传输的字节数量
2、常用的单位换算：
1Byte=8bit
1KB=1024Bytes
1MB=1024KB=1024*1024Bytes
1GB=1024MB=1024*1024*1024Bytes
1TB=1024GB=1024*1024*1024*1024Bytes
厂商的换算方式：1TB=1000GB 1GB=1000MB 1MB=1000KB
3、补充
计算机存储单位一般用bit、B、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB…来表示
1 Tera Byte（TB）= 1024 GB
1 Peta Byte（PB） = 1024 TB
1 Exa Byte（EB） = 1024 PB
1 Zetta Byte（ZB） = 1024 EB
1Yotta Byte（YB）= 1024 ZB
1 Bronto Byte（BB） = 1024 YB
1Nona Byte（NB）=1024 BB
1 Dogga Byte（DB）=1024 NB
1 Corydon Byte（CB）=1024DB
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eca2d48e3d2bf5f93771d562fce4372/" rel="bookmark">
			腾讯云ubuntu服务器tomcat访问慢的原因分析及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在腾讯云上配了个一元的学生云，开始一切正常，直到配置tomcat开始出现各种莫名其妙的问题。最莫名其妙的是tomcat启动了，端口也 正常监听，安全组也放行端口了，然后问题来了。
用浏览器访问tomcat主页，会发现超级慢，浏览器一直在等待服务器的响应，从这里可以看出能够接入8080端口，但是服务器没有返回数据。（这个问题折腾几天）
后来在网上找了无数资料，终于发现了原因。tomcat8.0在腾讯云ubuntu14.04上有bug。
问题原因：
随机数引起线程阻塞。
tomcat不断启动，关闭， 启动关闭。几次后会出现卡死状况。需很久才能加载完成
阿里云同样配置，同样系统，则很难出现卡死状况。 即使出现过几十秒后也会释放出来。 而腾讯云 ubuntu 不会 腾讯云的 centos不知道。
多次启动关闭，产生随机数的时候引起线程阻塞，，然后卡死。
解决办法：
tomcat bin/ catalina.sh 中加入
JAVA_OPTS="$JAVA_OPTS -Djava.security.egd=file:/dev/./urandom" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1eb73e889299f9c3e8c17e6d60e7764/" rel="bookmark">
			改进DevSecOps框架的 5 大关键技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markets and Markets的一项研究显示，全球DevOps的市场规模从2017年的29亿美元增加到2023年的103.1亿美元，预测期的年复合增长率(CAGR)为24.7%。人们对DevOps越来越感兴趣，因为DevOps不仅能够压缩软件的交付周期，还能提高交付的速度和质量。
Verified Market Research还预测，2019 年全球DevSecOps市场价值为 21.8 亿美元，预计到 2027 年将达到 171.6 亿美元，从2020年到2027年的年复合增长率为30.76%。
IT社区中，采用DevOps方法的项目越来越多，很多组织认可DevSecOps的优势。顾名思义，它意味着DevOps方法的安全性。在整个开发过程中，花在保持、维护开发安全性的时间会减少。安全代码是提升DevOps的重要组成部分。
DevSecOps的重要目标是：将安全防护融入软件开发的整个生命周期中。这一目标将由安全团队和运营团队来完成。此文将讲述如何实施DevSecOps方法，以及从持续集成到部署的整个过程如何成功实现自动化。
1.团队需要了解DevSecOps的新文化 DevSecOps 团队由三个团队组成：开发团队、运维团队和安全团队。DevSecOps 团队的目标是在应用程序和基础设施层面增强安全协议。
现代开发最佳实践迫使公司将开发、运维和安全团队整合到一个DevSecOps保护伞下，通过将安全性与左移策略集成，以更快的速度构建、发布代码。
它通过频繁沟通、参与、协作和团队协调来减轻负担，建立信任并授权部署过程。
2.在DevSecOps中使用敏捷开发 DevSecOps不能取代敏捷方法论。它是对敏捷的一种赞美，但它不能替代从快速开发到交付产品的过程。DevSecOps中的敏捷方法有助于以更快、更频繁的产品发布方式交付代码。
敏捷方法涵盖了软件测试、质量保证和生产支持，而DevSecOps提供了促进敏捷适应的工具。DevSecOps 在早期阶段就已经开始强调安全测试，从而提高软件质量。DevSecOps被视为软件持续集成和持续交付不可或缺的部分。
3.采用自动化测试 DevSecOps 综合了DevOps和自动化测试的优势。自动化测试有助于保持DevOps模型的联系。它使管道中的交付速度得以提升、质量得以提高。而且为软件发布和后续发现错误提供了平台。
网络攻击在各行各业都在加强，DevSecOps也在处理网络攻击方面发挥着关键作用。自动化测试方法提供了全面的安全测试策略，保证了企业关键应用程序的安全。将此作为发布周期的一部分，可以有效应对早期的常见漏洞和补丁。所以，它从扮演攻击者角色的应用程序或基础设施着手，这样就可以克服此类漏洞。
4.全天候持续监控和扩展 7*24的全天候持续监控是DevSecOps的基本要求。此过程包括各种持续监控工具，可确保安全系统智能运行。使我们得以更好地跟踪、审计和全面了解安全性。
此外，在维护大型数据中心时，持续监控和扩展有助于扩展IT基础设施的自动化流程，避免资源浪费。
5.保证CI-CD管道的安全性 近年来，DevSecOps的采用帮助许多企业在产品负责人、产品经理、开发、测试和 CloudOps 等各个领域承担起安全责任和所有权。问题包括大规模的落差、高管的突然辞职以及高管未能满足消费者需求。为了解决这些问题，企业强调，DevSecOps需要联合安全团队、合作伙伴，制定 CI-CD 管道中的安全自动化方案。
此外，许多团队也遵循敏捷开发流程，其中，DevSecOps发挥安全审计和渗透测试的作用。
DevSecOps 设计师与持续的 CI-CD 交付管道集成，确保产品（软件）交付的安全性。这让公司能按照可预测的时间和预算，快速响应安全事件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b7edd88f63d1ac1438dd8fc8580e39/" rel="bookmark">
			QT 程序详解（以MDI为案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统的应用程序设计中有多文档界面（Multi-document Interface，MDI）应用程序，Qt 为设计 MDI 应用程序提供了支持。
目录
运行效果如下：
qformdoc.ui界面如下：
qwmainwindow.ui界面如下：
​
main.cpp
qformdoc.h
qformdoc.cpp
ui_qformdoc
qwmainwindow.h
qwmainwindow.cpp
ui_qwmainwindow
运行效果如下： qformdoc.ui界面如下： qwmainwindow.ui界面如下： main.cpp //在C++里,任何窗体或界面组件都是用类封装的,一个类一般有一个头文件(.h文件)和一个源程序文件(.cpp文件) //.h文件是所设计的窗体类的头文件,.cpp文件是定义类的实现文件 //mian.cpp是主程序入口文件 #include "qwmainwindow.h"//引入所设计的窗体类的头文件 #include &lt;QApplication&gt;//QGuiApplication的子类，为基于QWidget的应用程序提供支持，包括界面的初始化等 //在有中文的类，头文件声明中加上 #pragma execution_character_set("utf-8") 解决汉子乱码问题/ int main(int argc, char* argv[]) { QApplication a(argc, argv);//定义并创建应用程序/定义一个实例a,也就是应用程序对象 MainWindow w;//定义并创建窗口/定义一个MainWindow类的变量w,MainWindow是本实例设计的窗口的类名(基类:QMainWindow/QWidget/QDialog) w.show();//显示窗口 return a.exec();//应用程序运行 } qformdoc.h #ifndef QFORMDOC_H #define QFORMDOC_H //头文件定义时的一个常用方法，为了避免重复包含同一个头文件。#pragma once具有类似的作用 //（1）防止重复定义的错误； //（2）如果这个头文件变化，那么所有include这个文件的源文件都需要重新编译，即使没有去使用里面的任何内容 #include &lt;QWidget&gt; //窗体继承的基类为QWidget，基类还有QMainWindow、QDialog，共三种 //一.QMainWindow： //QMainWindow类提供一个带有菜单条，工具条和一个状态条的主应用程序窗口。主窗口通常提供一个大的中央窗口部件，以及周围菜单，工具条，和一个状态栏。QMainWindow窗口经常被继承，使得封装中央部件，菜单，工具条，状态栏等都变得很容易，当用户点击它的时候，相应的槽就会被调用。 //二.QWidget //QWidet类是所有用户界面对象的基类，窗口部件是用户界面的一个基本单元，它从窗口系统接收鼠标，键盘和其他消息，并在屏幕上绘制自己。一个窗口部件可以被他的父窗口或者是其他窗口挡住一部分。 //三.QDialog //QDialog类是对话框窗口的基类，对话框窗口主要用于短期任务和用户进行短期通讯的顶级窗口，QDialog可以是模态对话框或者是非模态对话框。QDialog支持扩展并带有返回值，他们可以带有默认值 namespace Ui { class QFormDoc; } //声明一个名称为Ui的命名空间,包含一个类QFormDoc,这个类QFormDoc并不是本文件里定义的QFormDoc,而是ui_**文件里定义的类,用于描述界面组件的 // //QFormDoc类的定义 class QFormDoc : public QWidget//窗口类 //窗体类继承的基类为QWidget //在C++里,任何窗体或界面组件都是用类封装的,一个类一般有一个头文件(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70b7edd88f63d1ac1438dd8fc8580e39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ecc7571c0062c03ca59444d791506b/" rel="bookmark">
			Unity动态修改物体Tag
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Tag可选列表已存在新tag(只需要修改) this.transform.tag="newtag"; Tag可选列表不存在新tag(需要先修改列表，只有Editor可用) using System.Linq; using UnityEditor; using UnityEngine; string newtag="newtag"; #if UNITY_EDITOR if(!UnityEditorInternal.InternalEditorUtility.tags.Contains(newtag)) UnityEditorInternal.InternalEditorUtility.AddTag(newtag); #endif this.transform.tag="newtag"; 参考链接 UnityException: Tag: xxx is not defined.Unity动态添加tag 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4b2473bf574f0f9d685327d82f4764/" rel="bookmark">
			利用栈实现深度优先遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、什么是深度优先遍历？二、实现原理三、实现代码总结 前言 之前软考的时候光看概念一直没搞懂(有点笨),导致考试的时候丢分了,因此特地去了解了并用JAVA代码实现.下面我将介绍使用栈和递归来实现深度优先遍历的方法.
一、什么是深度优先遍历？ 深度优先遍历就是对每一个可能的分支路径深入到不能再深入为止，不能深入了就向上回溯,然后从其他分支再次开始深入到不能深入为止的原则,最后当所有路径都被访问过了,也就代表着遍历结束了(每个节点只能访问一次)
步骤:
1、从某个顶点(可以随机选取)开始,此时指针指向的是顶点
2、访问自己的一个未被访问过的邻接端点,将指针指向该邻接端点,如果没有未被访问过的邻接的端点则向上回溯至自己的直接父端点,当回溯至开始的顶点且顶点此时没有未访问的邻接端点时此时遍历结束.
3、重复步骤2
二、实现原理 1、利用递归思想,直至所有端点都被访问
2、利用栈先进后出原理存放当前遍历对象所有父端点,用于当前对象无未访问过的邻接端点时回溯
三、实现代码 代码如下（示例）：
/** * 深度优先遍历 */ public class Test { /** * 端点数组 */ private static final String[] ENDPOINT; /** * 边二维数组 */ private static final Integer[][] SIDE_ARRAY; /** * 判断俩顶点是否存在边 */ private static final Integer SIDE_FLAG = 1; /** * 未被访问的顶点map */ private static final Map&lt;Integer, String&gt; NOT_VISITED_ENDPOINT_MAP; /** * map table最大数 */ private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static { ENDPOINT = new String[]{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e4b2473bf574f0f9d685327d82f4764/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf6eafc898e90215397dcd99eed0b78/" rel="bookmark">
			zzcms靶场搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zzcms8.2需要把install.lock文件删除了，安装
可能不一样，自行删改
http://127.0.0.1/zzcms/install/index.php 解决无图方法：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b566a54f7a7f215fc02538bbb5d574d/" rel="bookmark">
			QuestDB测试类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于使用官网jdbc示例无法进行数据插入，可能问题为使用try with resource写法造成，具体原因未知。
改后示例：
public static void main(String[] args) throws Exception{
Properties properties = new Properties();
properties.setProperty("user", "admin");
properties.setProperty("password", "quest");
properties.setProperty("sslmode", "disable");
final Connection connection = DriverManager.getConnection("jdbc:postgresql://127.0.0.1:8812/qdb", properties);
//connection.setAutoCommit(false);
final PreparedStatement statement = connection.prepareStatement("CREATE TABLE IF NOT EXISTS trades (ts TIMESTAMP, date DATE, name STRING, value INT) timestamp(ts);");
statement.execute();
PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO trades VALUES (?, ?, ?, ?);");
preparedStatement.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
preparedStatement.setDate(2, new java.sql.Date(System.currentTimeMillis()));
preparedStatement.setString(3, "abc");
preparedStatement.setInt(4, 11);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b566a54f7a7f215fc02538bbb5d574d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2733b0267b5fbbaafbfdf6a3886d86fc/" rel="bookmark">
			MySQL中的DATE_SUB()函数和DATE_ADD()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DATE_SUB() ：从日期减去指定的时间间隔，返回的是一个字符串
SELECT DATE_SUB(NOW(), INTERVAL 1 MONTH) FROM DUAL; 输出结果：
2021-03-05 14:07:17 DATE_ADD() ：从日期增加指定的时间间隔，返回的是一个字符串
SELECT DATE_ADD(NOW(), INTERVAL 1 MONTH) FROM DUAL; 输出结果：
2022-04-07 12:48:48 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba9c0df14cd5ce385575a9dec4908a8/" rel="bookmark">
			Python编程从入门到实践（第2版）第四章 操作列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章 操作列表 4.1 遍历整个列表4.1.1 深入研究循环4.1.2 在for循环中执行更多操作4.1.3 在for循环中执行更多操作 4.2 避免缩进错误4.2.1 忘记缩进4.2.2 忘记缩进额外的代码行4.2.3 不必要的缩进4.2.4 循环不必要的缩进4.2.5 遗漏了冒号动手试一试 4.3 创建数值列表4.3.1 使用函数range()4.3.2 使用函数range()创建数字列表4.3.3 对数字列表执行简单的统计计算4.3.4 列表解析动手试一试 4.4 使用列表的一部分4.4.1 切片4.4.2 遍历切片4.4.3 复制列表动手试一试 4.5 元组4.5.1 定义元组4.5.2 遍历元组中的所有值4.5.3 修改元组变量动手试一试 4.1 遍历整个列表 需要对列表中每个元素都执行相同的操作时，可使用Python中的for循环。
下面使用for循环来打印魔术师名单中的所有名字：
输入：
magicians = ['alice','david','carolina'] for magician in magicians: print(magician) 输出：
alice david carolina 4.1.1 深入研究循环 for in 循环
for magician in magicians:#依次获取magicians的每一个元素值，并分别与magician关联，打印输出。 4.1.2 在for循环中执行更多操作 输入：
magicians = ['alice','david','carolina'] for magician in magicians: print(f"{magician.title()},that was a great trick!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ba9c0df14cd5ce385575a9dec4908a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70bbbfb2009a320c9ec1850ad162c91d/" rel="bookmark">
			手写一个我的HashMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* *@description: Map接口定义 *@author: winyinghouse *@date：2021/3/7 */ public interface Map&lt;K,V&gt; { V put(K k ,V v); V get(K k); void resize(); interface Entry&lt;K,V&gt;{ } } /* *@description: HashMap实现 *@author: winyinghouse *@date：2021/3/7 */ public class HashMap&lt;K, V&gt; implements Map&lt;K,V&gt; { Entry&lt;K,V&gt; table[] = null; int length; int size; //默认值 final int DEFAULT_LENGTH =16; final double LOADFACTOR = 0.75; /* 构造方法 */ public HashMap() { this.table = new Entry[DEFAULT_LENGTH]; this.length = DEFAULT_LENGTH; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70bbbfb2009a320c9ec1850ad162c91d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb71ec54ff1dfded30f19ed87844a37/" rel="bookmark">
			ubuntu系统替换源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更换阿里云源 # 1. 备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak # 2. 查看版本信息，系统代号，如bionic lsb_release -c # 3. vim /etc/apt/sources.list将原有的内容注释掉，添加以下内容（bionic） deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eb71ec54ff1dfded30f19ed87844a37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ac33576aa7201835fb7a36bb73dd087/" rel="bookmark">
			mac下载EasyConnect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载链接：https://vpn.xhhos.com/com/installClient.html?language=zh_CN
注意：要通过Safari浏览器下载，不要用谷歌
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4238a693eeea40fadd6963004ef157f7/" rel="bookmark">
			SSH登录及失败解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ssh登录 命令登录： ssh root@192.168.2.3 MobaXterm软件登录： SecureCRT软件登录： ssh登录失败，系统可能未安装服务 # 安装ssh服务端 sudo apt-get install openssh-server # 先检查SSH服务有没有开启（看到sshd ------则ssh-server已经启动了，只有ssh-agent----则ssh-server还没有启动） ps -e | grep ssh # 如果需要再次确认或者没有以上的结果，可使用命令开启，会有starting ssh.service sudo /etc/init.d/ssh start # 其他 sudo service ssh status # 查看服务状态 sudo service ssh stop # 关闭服务 sudo service ssh restart # 重启服务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b59476164d8adce819940e8ea407878/" rel="bookmark">
			数据清洗，Python读取txt数据，txt数据分隔符处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在处理txt文件时遇到了一些问题，它不是格式化的数据，行前行末都有空格，而且每个元素的分隔符不一致，没法进行分割处理，如果用read_csv或者read_table函数是无法直接处理的，得到的只有一个数据块，txt数据如下
所以我想给它先转换成格式化的数据，再利用函数进行处理。
先用原生Python对空格分隔符进行处理
# 读取 inputfile = open('_data_1lognorm_nh42so4_ 5_12.out_new.txt', 'r') a = [] # 将数据进行格式化处理，获取dataframe类型数据 for line in inputfile: #剪切掉行前和行末的空格,若只想剪切行前，则用line.lstrip(),行末则用line.rstrip() line = line.strip() #分割，用split(),默认是按空格分割，无论是一个空格还是多个空格均可 wordlist = line.split() #可以将字符串转化为浮点型数据 #int_list = [float(x) for x in wordlist] a.append(wordlist) 然后将格式化的数据存为dataframe类型数据
# 添加表头 names = ['x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7', 'x8', 'x9', ] df = pd.DataFrame(columns=names, data=a) # 修改格式后的源数据 df.to_csv('dataframe.csv') 这样就得到了格式化的数据，如下所示
然后就可以利用pandas，或者numpy进行数据处理了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa8dcaca2ee91953b95c7b3e73cade6/" rel="bookmark">
			WireShark常用过滤器语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以wireshark--查看用户手册或帮助--说明文档查看查看使用方法。
为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。
Wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容。如果是处理HTTP、HTTPS 还是建议大家用Fiddler, 其他协议比如TCP、UDP等等就可以直接使用Wireshark。
1.界面介绍 1号窗口展示的是wireshark捕获到的所有数据包的列表。注意最后一列Info列是wireshark组织的说明列并不一定是该数据包中的原始内容。
2号窗口是1号窗口中选定的数据包的分协议层展示。
3号窗口是1号窗口中选定的数据包的源数据，其中左侧是十六进制表示右侧是ASCII码表示。另外在2号窗口中选中某层或某字段，3号窗口对应位置也会被高亮。
2.捕获过滤器 捕获过滤器表达式作用在wireshark开始捕获数据包之前，只捕获符合条件的数据包，不记录不符合条件的数据包。一般不用。
3.显示过滤器 显示过滤器表达式作用在在wireshark捕获数据包之后，从已捕获的所有数据包中显示出符合条件的数据包，隐藏不符合条件的数据包。
显示过滤表达示在工具栏下方的“显示过滤器”输入框输入回车即可生效。
4.表达式 一、捕获过滤器表达式 语法：
&lt;Protocol&gt; &lt;Direction&gt; &lt;Host(s)&gt; &lt;Value&gt; &lt;Logical Operations&gt; &lt;Other expression&gt;
说明：
Protocol（协议）：ether，fddi， ip，arp，rarp，decnet，lat， sca，moprc，mopdl， tcp ， udp 等，如果没指明协议类型，则默认为捕捉所有支持的协议。Direction（方向）：src， dst，srt，src and dst， src or dst等，如果没指明方向，则默认使用 “src or dst” 作为关键字。Host(s)：net, port, host, portrange等，默认使用”host”关键字，”src 10.1.1.1″与”src host 10.1.1.1″等价。Logical Operations（逻辑运算）：not, and, or 等，否(“not”)具有最高的优先级。或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。 （1） 只捕获某主机的HTTP流量 host 192.168.5.231 and port 80 and http #只捕获主机192.168.5.231 、端口为80的http流量。
not port 80 and !http # 捕获除 http和端口80 之外的其他所有流量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fa8dcaca2ee91953b95c7b3e73cade6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c71466733a2b934b09033b837c125937/" rel="bookmark">
			二分查找——部分题目汇总——长长文详细分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言二分查找第一题：二分查找解题思路GIF代码 第二题：搜索插入位置解题思路代码 第三题：寻找旋转排序数组中的最小值解题思路代码 第四题：寻找峰值解题思路代码 第五题：在排序数组中查找数字Ⅰ解题步骤代码 前言 这篇文章我整理了力扣上一些难度偏低和适中的二分查找例题，整理了一些我对二分查找的浅见和方法，题解也仅是通俗讲解，并非代表最好，希望帮助 大家能够更好地理解二分查找。本人代码和见识有限，，有错误欢迎指出！
二分查找 二分查找也叫作折半查找法，每次查找一次便缩小一次范围，关键就在于边界问题和范围的缩小
第一题：二分查找 首先我们举一个比较经典的例子：力扣：二分查找
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
我们先随便举出一种情况：
题目变量：int search(int* nums, int numsSize, int target)
解题思路 我们首先定义两个边界int left = 0，right = numsSize - 1，需要注意的是我所定义的right变量是最后一个元素的下标。
关于循环部分：while(left &lt; right)，因为我的左边界left和右边界right都是可以取到的下标（不会越界访问），当left = right的时候结束循环，如果按照这种方法写while(left &lt;= right)的话，部分情况会出现死循环的情况
然后再定义int mid = left + (right - left) / 2;，除了这个表达式之外，还有一个int mid = (left + right) / 2;其实这两个表达式的运算结果都是一样的，但是前者能够防止数据溢出的情况
如果nums[mid]&lt;target，那就说明mid在target的左边（题意数组是升序的），因为target不可能出现在[0,mid]的位置了，所以这时候我们就要调整左边界left的大小，让搜索范围更新成[mid+1,right] ，即left = mid +1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c71466733a2b934b09033b837c125937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27c2600a9e8be179530288fa16ff839c/" rel="bookmark">
			pycharm的debug模式，程序卡住（已开启gevent兼容）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 我在利用python跑深度学习项目。发生了运行时能正常运行，但是调试时候会卡住的bug（抓取数据时）。
解决办法： 将下图中第一行（调试时自动附加到子进程的√去掉）
参考资料： 使用pycharm进行调试PyTorch项目时遇到"KeyboardInterrupt"程序终止_Nin7a的博客-CSDN博客 原因分析： 经过我的定位，发现问题出在queue.py这个文件。该文件如下语句所在段落出现死循环。
timeout = deadline - time.monotonic() 这个文件是python自带的库。我在该文件如下语句。
加了一行print，发现系统循环输出print的结果。查阅相关资料，推测该文件可能和线程有关。在调试时可能是开了线程，但线程锁导致不同线程结束时间不同 ，进行后处理的线程开始执行时，抓图线程还没有返回图片，进而导致死循环。
文件：/home/luoxinhao/anaconda3/envs/AdelaiDet-master/lib/python3.7/multiprocessing/queues.py
网上查阅资料，找到了参考资料里说的做法，抱着试试看的态度，发现对我的问题同样有用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83223b11230b216cc460938fd9f5086b/" rel="bookmark">
			BFS计算最短路径（python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们这里所说的最短路径是从根节点到某一指定叶子节点的最短路径。
如上图，我们把E,当成根节点，我们到B的最短路径就是ECB。
我们用代码来实现。我们用到的思路就是使用一个字典来存放节点的父节点，仔细看parent和ver 的关系，ver是取到的队头元素，我们用for循环在grep[ver]中找到子元素，所以我们可以反过来用parent[i] = ver 来存放子对父的key_value。
grap = { "A": ["B", "C"], "B": ["A", "C", "D"], "C": ["A", "B", "D", "E"], "D": ["B", "C", "E", "F"], "E": ["C", "D"], "F": ["D"] } # 存图 def BFS(grap, star): # BFS算法 queue = [] # 定义一个队列 seen = set() # 建立一个集合，集合就是用来判断该元素是不是已经出现过 queue.append(star) # 将任一个节点放入 seen.add(star) # 同上 parent = {star:None} #存放parent元素 while (len(queue) &gt; 0): # 当队列里还有东西时 ver = queue.pop(0) # 取出队头元素 notes = grap[ver] # 查看grep里面的key,对应的邻接点 for i in notes: # 遍历邻接点 if i not in seen: # 如果该邻接点还没出现过 queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83223b11230b216cc460938fd9f5086b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e108314e0e89972364d6cf0dd326c8/" rel="bookmark">
			LWIP (1.1) ETH Module以太网模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 以太网 ETH模块说明
1.overview
2.ETH module in stm32h743
STM32H743 为例
开局一张图 ETHER 模块 红框所示 以STM32H743为例
32 BIt AHB为内部高速总线 D2 域，Master为可以发起读写。AHB总线在STM32 H743的最高速率 为240MHz。
对外接口为MII/RMII
开局第二张图
Ethernet high-level block diagram
Eth_hclk ETH 模块的时钟源
DMA Arb 对模块外部 AHB Master可以主动发起数据的读写。对内连接 两个专用DMA (数据发送DMA，数据接收DMA)其分别连接 Tx,Rx FIFO （深度为2K）。FIFO连接两个对外数据寄存器 MAC Tx,MAC Rx ,对外用RMII/MII 对外引脚输出连接PYH。
AHB Slave 不可发起读写，CPU通过AHB Slave接口配置CRS控制寄存器控制整个ETH。
1.总线接口 ，用作数据传输。Master 用于DMA数据的 搬移，Slave 用于CPU对状态寄存器的读写。
2.DMA
3.MTL 缓存FIFO
4.MAC 以太网MAC协议处理
5.RMII，MII接口
开机第三张图 STM32 ETH模块主要实现MAC层
MAC数据包格式
IEEE 对以太网上传输的数据包格式也进行了统一规定，该数据包被称为 MAC 数据包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e108314e0e89972364d6cf0dd326c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a0a9504372c13f083288ee1dc47a517/" rel="bookmark">
			判断 素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题的目标很简单，就是判断一个给定的正整数是否素数。
输入格式： 输入在第一行给出一个正整数N（≤ 10），随后N行，每行给出一个小于2^31
的需要判断的正整数。
输出格式： 对每个需要判断的正整数，如果它是素数，则在一行中输出Yes，否则输出No。
输入样例：
2
11
111
输出样例：
Yes
No
我的基本思路是自定义一个输出的方法和一个判断是否为质素的方法，在main里面直接调用输出方法，在输出方法中调用素数的判断方法，根据返回的结果输出不同的内容。
代码如下：
import java.util.Scanner; public class Ispn{ //输出结果 public static void fun(int N){ Scanner in = new Scanner(System.in); Ispn hh = new Ispn(); //for循环每输入一个数进行一次判断 for(int i=0 ;i&lt;N;i++){ int data = in.nextInt(); if(hh.jd(data))//调用函数进行判断，如果返回值为true则输出Yes System.out.println("Yes"); else//如果不为true则输出No System.out.println("No"); } } //判断是否是素数 public static boolean jd(int data){ boolean T = true; if(data==1) T = false; else{ for(int i=2;i&lt;data-1;i++){//用输入的数分别除以除了1和它本身以外的数，如果能整出则不是素数，反之则是素数 if(data % i == 0){ T = false; } } } return T; } //主函数入口 public static void main(String[] args){ Scanner in = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a0a9504372c13f083288ee1dc47a517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf44dd03ba8a9c67922bb9fda3759376/" rel="bookmark">
			go-consul实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		consul简介 官网介绍地址 视频介绍的挺不错的，不过是英文的
Consul is a service mesh solution providing a full featured control plane with service discovery, configuration, and segmentation functionality. Each of these features can be used individually as needed, or they can be used together to build a full service mesh. Consul requires a data plane and supports both a proxy and native integration model. Consul ships with a simple built-in proxy so that everything works out of the box, but also supports 3rd party proxy integrations such as Envoy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf44dd03ba8a9c67922bb9fda3759376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84931d82b11bd5e122add6514db589a/" rel="bookmark">
			Spring主从数据库的配置和动态数据源切换原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在大型应用程序中，配置主从数据库并使用读写分离是常见的设计模式。在Spring应用程序中，要实现读写分离，最好不要对现有代码进行改动，而是在底层透明地支持。
Spring内置了一个AbstractRoutingDataSource，它可以把多个数据源配置成一个Map，然后，根据不同的key返回不同的数据源。因为AbstractRoutingDataSource也是一个DataSource接口，因此，应用程序可以先设置好key， 访问数据库的代码就可以从AbstractRoutingDataSource拿到对应的一个真实的数据源，从而访问指定的数据库。它的结构看起来像这样：
配置多数据源 首先，我们在SpringBoot中配置两个数据源，其中第二个数据源是ro-datasource：
spring: datasource: jdbc-url: jdbc:mysql://localhost/test username: rw password: rw_password driver-class-name: com.mysql.jdbc.Driver hikari: pool-name: HikariCP auto-commit: false ... ro-datasource: jdbc-url: jdbc:mysql://localhost/test username: ro password: ro_password driver-class-name: com.mysql.jdbc.Driver hikari: pool-name: HikariCP auto-commit: false ... 在开发环境下，没有必要配置主从数据库。只需要给数据库设置两个用户，一个rw具有读写权限，一个ro只有SELECT权限，这样就模拟了生产环境下对主从数据库的读写分离。
在SpringBoot的配置代码中，我们初始化两个数据源：
@SpringBootApplication public class MySpringBootApplication { /** * Master data source. */ @Bean("masterDataSource") @ConfigurationProperties(prefix = "spring.datasource") DataSource masterDataSource() { logger.info("create master datasource..."); return DataSourceBuilder.create().build(); } /** * Slave (read only) data source. */ @Bean("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a84931d82b11bd5e122add6514db589a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdedeeb2981b0bf6f0502579c721230d/" rel="bookmark">
			排序算法总结（Python版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经典排序算法总结与实现 经典排序算法在面试中占有很大的比重，也是基础，为了未雨绸缪，这次收集整理并用Python实现了八大经典排序算法，包括冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序以及基数排序。希望能帮助到有需要的同学。之所以用 Python 实现，主要是因为它更接近伪代码，能用更少的代码实现算法，更利于理解。
本篇博客所有排序实现均默认从小到大。
一、冒泡排序BubbleSort 介绍： 冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 Python源代码（错误版本）：
def bubble_sort(arry): n = len(arry) #获得数组的长度 for i in range(n): for j in range(i+1, n): if arry[i] &gt; arry[j] : #如果前者比后者大 arry[i],arry[j] = arry[j],arry[i] #则交换两者 return arry 注：上述代码是没有问题的，但是实现却不是冒泡排序，而是选择排序（原理见选择排序），注意冒泡排序的本质是“相邻元素”的顺序交换，而非每次完成一个最小数字的选定。
Python源代码（正确版本）：
def bubble_sort(arry): n = len(arry) #获得数组的长度 for i in range(n): for j in range(1, n-i): # 每轮找到最大数值 或者用 for j in range(i+1, n) if arry[j-1] &gt; arry[j] : #如果前者比后者大 arry[j-1],arry[j] = arry[j], arry[j-1] #则交换两者 return arry 不过针对上述代码还有两种优化方案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdedeeb2981b0bf6f0502579c721230d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/993365cd702472f558c12289c29dd3b6/" rel="bookmark">
			关于JDK8的LongAdder类源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public void add(long x) { Cell[] cs; long b, v; int m; Cell c; //Cell数组为null时，会尝试CAS对basecount+x。若不成功进入if //这里可以看到cells!=null条件的优先级高，因此Longadder会优先选择在cells中更新。 if ((cs = cells) != null || !casBase(b = base, b + x)) { boolean uncontended = true; //CASE1：Cell数组为null //CASE2：Cell数组所在索引上的Cell对象是null //CASE3：1、2都不是null，就尝试CAS更改该Cell中的value，并且更改失败 //以上三种情况都会进入if if (cs == null || (m = cs.length - 1) &lt; 0 || (c = cs[getProbe() &amp; m]) == null || !(uncontended = c.cas(v = c.value, v + x))) longAccumulate(x, null, uncontended); } } final void longAccumulate(long x, LongBinaryOperator fn,boolean wasUncontended) { int h; if ((h = getProbe()) == 0) { ThreadLocalRandom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/993365cd702472f558c12289c29dd3b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06815a25686a4c46914772a49fe6fdf/" rel="bookmark">
			JAVA常见工具类DatatypeConverter、StringUtils、common-lang,appache commons,guava
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DatatypeConverter：在类里面提供了一些静态方法，这些方法就是Decode（解码）或者Encode(编码)使用，提供一些Java中数据格式的转换
简单来说就是各种常见数据类型之间的相互转化，如int long string byte hex decimal base64 unsigned date等相互转化
eg：printHexBinary(byte[]):将字节数组打印成16进制字符串
parseHexBinary(String):将16进制字符串转化成字节数组 CommonsLang：工具包Utils的延伸，更多高级和实用的日常操作类 ArrayUtils 数组的操作，如拷贝、添加、查找、删除、子数组、倒序、元素或者集合类型转换等；
BitField 位操作类；
BooleanUtils boolean操作类；
CharEncoding 根据本地编码进行当前的编码判断；
CharRange 设定字符范围并做相应检查；
CharSet 字符集操作；
CharSetUtils 对字符集进行操作；
CharUtils 对char值和Character对象进行操作；
ClassUtils 对class对象进行操作；
ObjectUtils 对object对象进行操作；
RandomStringUtils 生成随机的字符串；
SerializationUtils 序列化处理类；
StringEscapeUtils 正确处理转义字符，产生正确的Java、JavaScript、HTML、XML和SQL代码；
StringUtils String处理类，像isnotempty等判断；
SystemUtils 在java.lang.System基础上提供更方便的访问，如用户路径、Java版本、时区、操作系统等判断；
Validate 提供验证的操作，有点类似assert断言；
WordUtils 处理单词大小写、换行等。
Guava：google core library for java annotations 无
base 避免null，条件检查，joiner splitter等辅助字符串操作（分割连接填充），排序等Objects.equal(“a”, “a”) Objects.equal(null, “a”);等比较
cache 缓存及其过期策略等
collect 不可变集合，multisets, multimaps,bimap， tables, bidirectional maps等新集合，其中table有rowKey,columnKey,value作为复合索引等避免嵌套，装饰器迭代器等
escape 转义处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b06815a25686a4c46914772a49fe6fdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f61434a7ccd68857f25795566c6d66f/" rel="bookmark">
			【报错】：org.apache.commons.exec.ExecuteException: Process exited with an error: 1 (Exit value: 1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误如下 [ERROR] Command execution failed. org.apache.commons.exec.ExecuteException: Process exited with an error: 1 (Exit value: 1) at org.apache.commons.exec.DefaultExecutor.executeInternal (DefaultExecutor.java:404) at org.apache.commons.exec.DefaultExecutor.execute (DefaultExecutor.java:166) at org.codehaus.mojo.exec.ExecMojo.executeCommandLine (ExecMojo.java:804) at org.codehaus.mojo.exec.ExecMojo.executeCommandLine (ExecMojo.java:751) at org.codehaus.mojo.exec.ExecMojo.execute (ExecMojo.java:313) at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137) at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210) at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156) at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117) 解决如下：
或者在POM中加入
&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt; &lt;configuration&gt; &lt;classpathScope&gt;test&lt;/classpathScope&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dee5f24987d8f44a4c33510e73eba67/" rel="bookmark">
			Spring源码解析十三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇，我们分析了bean标签下各种子标签的解析，最终都是将这些标签解析到的信息封装到BeanDefinition中。Spring得到这些BeanDefinition之后会做什么呢？肯定是要把这些BeanDefinition信息保存到Spring容器中的。所以Spring拿到这些BeanDefinition之后就要注册到Spring容器的。所以这一篇我们将要介绍BeanDefinition的信息时如何注册的Spring容器的。
我们回顾一下我们上一篇中的内容：
可以看到，当解析完成各种标签后直接就将BeanDefinition返回了。
我们在回到ParseBeanDefinitionElement的位置看下：
可以看到，前面解析的bean标签下的各种属性和标签都是在方法ParseBeanDefinitionElement中完成了，然后得到GenericBeanDefinition对象。
最后，我们可以看到ParseBeanDefinitionElement方法其实就是将BeanDefinition，连带着解析得到的别名aliasesArray一起封装到了BeanDefinitionHolder中，BeanDefinitionHolder我们可以理解为持有BeanDefinition的一个对象而已。
我们在回退到上一个方法的位置看下：
可以看到，方法parseBeanDefinitonElement返回了我们刚才封装好的BeanDefinitionHolder。
方法 decorateBeanDefinitionIfRequired 其实是对标签进一步的检测，如果发现bean标签中还存在自定义标签，就对自定义标签进行解析，当然自定义标签的解析我们这里不再深究，接下来，我们重点来看下BeanDefinitionReaderUtils中的registerBeanDefinition 方法里面的逻辑，也就是BeanDefinition是如何注册的Spring容器中的。
我们跟进到方法registerBeanDefinition中看下：
我们就要看到在registerBeanDefinition方法中，首先会从BeanDefinitionholder中获取beanName以及BeanDefinition，然后调用registerBeanDefinition方法进行注册。
我们继续到方法registerBeanDefinition中看下：
@Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, "Bean name must not be empty"); Assert.notNull(beanDefinition, "BeanDefinition must not be null"); // 如果beanDefinition 是AbstractBeanDefinition if (beanDefinition instanceof AbstractBeanDefinition) { try { // 校验beanDefinition 中的methodOverride属性 ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, "Validation of bean definition failed", ex); } } // 判断beanDefinitionMap中是否存在名称为beanName的BeanDefinition beanDefinitionMap 就是spring容器 BeanDefinition existingDefinition = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dee5f24987d8f44a4c33510e73eba67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00ba18f44bb802ab7c63fe3b4d228fb/" rel="bookmark">
			Typescript封装axios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、认识axios
目前在开发中会使用axios来发送ajax请求，其具有以下几个特点：
1、在浏览器中发送 XMLHttpRequests 请求 2、在浏览器中发送 XMLHttpRequests 请求 3、 支持 Promise API 4、拦截请求和响应 5、转换请求和响应数据 等等... 支持多种请求方式：
axios(config)
axios.request(config)
axios.get(url[,config])
axios.delete(url[,config])
axios.head(url[,config ])
axios.post(url[,data[,config]])
axios.put(url[,data[,config]])
axios.patch(url[,data[,config]])
有时候我们需要同时发送两个请求，应该使用axios.all，可以放入多个请求的数组。
常见的一些配置选项
1、请求地址： url: '/url' 2、请求类型 method: 'get' 3、基本路径 baseURL: 'http://www.mt.com/api' 4、请求前的数据处理 transformRequest:[function(data){}] 5、请求后的数据处理 transformResponse: [function(data){}], 6、自定义的请求头 headers:{'x-Requested-With':'XMLHttpRequest'}, 7、 URL查询对象 params:{ id: 12 } 8、查询对象序列化函数 paramsSerializer: function(params){ } 9、request body data: { key: 'aa'}, 10、超时设置s timeout: 1000 11、跨域是否带Token withCredentials: false 12、自定义请求处理 adapter: function(resolve, reject, config){} 13、身份验证信息 auth: { uname: '', pwd: '12'}, 14、响应的数据格式 json / blob /document /arraybuffer responseType: 'json' axios拦截器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b00ba18f44bb802ab7c63fe3b4d228fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18d11b2a73a7e5f953ab490c1e10bf2/" rel="bookmark">
			crontab表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cron表达式用于配置cronTrigger的实例。
cron表达式实际上是由七个子表达式组成，至少由六个子表达式组成。
Cron有如下两种语法格式：
（1）Seconds Minutes Hours DayofMonth Month DayofWeek Year
（2）Seconds Minutes Hours DayofMonth Month DayofWeek
这些表达式之间用空格分隔。如下：
1、 Seconds （秒）
2、 Minutes（分）
3、 Hours（小时）
4、 Day-of-Month （天）
5、 Month（月）
6、 Day-of-Week （周）
7、 Year（年）可选
例：“0 0 12 ? * WED” 意思是：每个星期三的中午12点执行。
个别子表达式可以包含范围或者列表。例如：上面例子中的WED可以换成"MON-FRI”，“MON,WED,FRI”，甚至"MON-WED,SAT"。
子表达式范围：
1 Seconds (0~59)
2 Minutes (0~59)
3 Hours (0~23)
4 Day-of-Month (1~31,但是要注意有些月份没有31天)
5 Month (0~11，或者"JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC")
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e18d11b2a73a7e5f953ab490c1e10bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47a5c99cb2402a408c7056c681b9600a/" rel="bookmark">
			IDEA--通过cherrypick实现指定几条git提交记录合并到新分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【学习背景】
Hi，大家好，我是贾斯汀，今天分享一个工作经验小技巧，相信很多小伙伴都有使用IDEA编写代码，然后git作为版本控制，可能大家平时比较习惯用的是从原分支合并(merge)所有提交记录到新分支，但是实际当中也有这样的一种需求，就是只想合并原分支的指定几条git提交记录到新分支，今天主要分享，如何通过IDEA中的cherrypick功能实现指定几条git提交记录合并到新分支。
【实现过程】
一般每个公司对于分支的定义都有不同的命名规范，本文以master和develop分支为例进行说明，develop就是开发人员日常进行开发提交代码的分支，而master分支则一般代表比较严格的分支，主要将在develop开发分支完成测试过的代码合并到master分支。
开发分支：develop
目标分支：master
（1）切换Local本地为master分支
（2）拉取master分支最新代码
（3）切换branch为origin/develop远程分支
切换后如下：
（4）从下往上，依次选中指定提交记录cherrypick
（5）完成cherrypick后，push推送master到远程
（6）确定push，确定推送到远程
（7）最后检查master目标分支，可以看到从develop分支cherrypick到master分支的指定两条提交记录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4e8f86c6763e370e5ad332b1f2947e/" rel="bookmark">
			怎么解决win10访问mac共享目录时账号密码错误？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用mac的时候，经常需要互传文件。以前经常是使用U盘拷贝，但是太麻烦。后面发现mac自带有文件共享功能。但是在配置好以后，使用win10电脑去访问的时候，却一致提示账号密码错误。研究了一下才发现，还需要一些特别设置，下面我们一起来看。
工具/原料 mac笔记本
windows10系统
方法/步骤 点击系统界面的apple图标，然后选择系统偏好设置，进入到系统设置界面。
在系统设置界面找到共享图标，点击进去。然后可以看到设置好的文件共享如下面第二张图所示，可以看到默认情况下，下载目录对于文件夹共享用户是只读的。
经过一番研究后发现，如果windows系统想要访问mac系统的共享文件夹，需要一些额外设置。点击用户上面的选项按钮。
在选项里面我们看到有一段提示，就是说，如果想在window上访问mac的共享目录，需要在这里保存共享用户的密码。我们点中共享文件夹用户
然后会弹出来窗口，要求我们输入共享文件夹用户的密码。输入后，点击好按钮。保存这个用户的密码。
然后再选项界面就能看到共享文件夹用户被选中了，点击完成。结束设置。然后再回到windows系统上，通过文件夹路径访问，就能够通过验证，看到正确的目录了，如下面第二张图中所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342c6aabd6a9cfe1dcf31ef2c721e219/" rel="bookmark">
			Python基础（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此次博客主要记录了博主初学的python，刚刚尝试代码的一些操作，主要为输入输出，此外还做了注释方面的说明以及对python数据类型的查看，此后会逐渐总结整理个数据类型的一些相关知识进行发布。
1. 输入 1.1 只输入一个数据 data = input("请输入你想要的内容：") 之后在输出端输入你想要的内容。
1.2 一行需要输入多个数据 当一行需要输入多个数据时，可以使用分隔符进行分割，split() 默认以空格形式分隔字符 split(’,’) 以逗号形式分割字符
例如：
m, n = input().split() 也可以采用map（）函数，map(function,iterable,…),这里使用function=int或者float修改输入数据的类型
m, n = map(int, input().split()) 此外，可以在map函数外再嵌套一个list()，将数据存入一个列表
l = list(map(float, input().split())) # 输入：1， 2 print(l) # 输出：[1.0, 2.0] # map（）里面定义的类型时float，因此时浮点类型的 1.3 多行输入，多维数组 先输入一个数字代表需要输入几行，比如n=4，那么就需要再输入4行数据
n = int(input()) # 输入：4 s = [] for i in range(n): x = list(map(int, input().split())) s.append(x) # 输入：1 4 3 # 1 2 3 # 4 5 6 # 1 2 5 print(s) #输出： [[1, 4, 3], [1, 2, 3], [4, 5, 6], [1, 2, 5]] 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/342c6aabd6a9cfe1dcf31ef2c721e219/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb802641aae5284c82251b0537530142/" rel="bookmark">
			vue—解决“You may use special comments to disable some warnings. Use eslint-disable-next-line to
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误： 启动vue项目时，出现很多语法错误，并出现以下提示
出错原因： ESLint 对语法的要求过于严格导致编译的时候报上图那些错误。
要知道，这并不是代码有异常，而是代码格式有问题，这些错误并不会影响代码的执行结果。
解决方法： 很简单，就如提示所言，我们我可以取消ESLint验证规则，这样就不会报这些异常了。
方法1：
如果你的项目是vue脚手架工程，那么找到项目根目录下的bulid文件夹 -&gt; webpack.base.conf.js
找到以下代码块并注释掉第三行代码
module: { rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), //注释掉该行代码 { test: /.vue$/, loader: 'vue-loader', options: vueLoaderConfig }, 注释完保存退出，重新启动项目即可。
方法2
当项目并不存在build文件夹，即不属于vue脚手架工程，那请到根目录下 config文件夹下的index.js文件，将useEslint属性设置为false。
若是不存在useEslint属性，可以自己添加进去（亲测有效）。
改完保存，重新启动项目即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3795218b70205b8b21a1ffc7fe8c2b97/" rel="bookmark">
			关于“文件或目录损坏且无法读取” 的 CHKDSK 修复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CHKDSK 的功能 CHKDSK 全称 Microsoft Check Disk，是一个用于磁盘检查的指令程序。CHKDSK 的基本功能是扫描磁盘上的文件系统的完整性，并修复文件系统的错误；CHKDSK 还支持扫描磁盘上的磁盘区，并试图修复损毁的磁盘区。用户可以手动调用命令行以检测磁盘分区。如果不输入任何参数，CHKDSK 一般只显示被检测磁盘的状态报告。若附带指定参数，CHKDSK 便会修复错误。
CHKDSK 的句法 以下是关于 CHKDSK 的句法以及常用参数的详细介绍：
CHKDSK的句法为：chkdsk [Volume] [Path] [/f] [/v] [/r] [/x] [/i] [/c] [/l:Size] [/b] [/perf ] [/scan ] [/?]
volume 指定驱动器(后面跟一个冒号)、装入点或卷名。filename 仅用于 FAT/FAT32: 指定要检查是否有碎片的文件/F 修复磁盘上的错误。/V　在 FAT/FAT32 上: 显示磁盘上每个文件的完整路径和名称。在 NTFS 上: 如果有清除消息，将其显示。/R 查找不正确的扇区并恢复可读信息(隐含 /F)。/L:size 仅用于 NTFS:? 将日志文件大小改成指定的 KB 数。如果没有指定大小，则显示当前的大小。/X 如果必要，强制卷先卸下。卷的所有打开的句柄就会无效(隐含 /F)/I 仅用于 NTFS: 对索引项进行强度较小的检查/C 仅用于 NTFS: 跳过文件夹结构的循环检查。/I 和 /C 命令行开关跳过卷的某些检查，减少运行 Chkdsk 所需的时间 CHKDSK 的使用示例 C:\Users\Jeffrey D. Sachs&gt;chkdsk g: /f 文件系统的类型是 FAT32。 卷序列号为 0403-0201 指定的磁盘似乎是非 Windows XP 磁盘。 正在更新 FAT 媒体类型。 \ 项含有无效链接。 Windows 正在校验文件和文件夹.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3795218b70205b8b21a1ffc7fe8c2b97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d636ecb5b212bd0e6026b428478654a7/" rel="bookmark">
			通用接口API,赶紧收藏备用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度 api集市免费接口 IP地址查询
频道新闻API_易源
微信热门精选
天气查询
中国和世界天气预报
股票查询
身份证查询
美女图片
音乐搜索
图灵机器人
汇率转换
节假日
pullword在线分词服务
去哪儿网火车票
笑话大全
银行卡查询服务
语音合成
宅言API-动漫台词接口
去哪儿景点门票查询
手机号码归属地
体育新闻
手机归属地查询
科技新闻
空气质量指数
天狗健康菜谱
热门游记列表
天狗药品查询
汉字转拼音
国际新闻
彩票
微信精选
天狗健康资讯
兴趣点检索
用药参考
天狗健康知识
奇闻趣事
花边新闻
天狗医院大全
生活健康
其他免费API接口 豆瓣开放
淘宝开放平台
图灵语音
讯飞语音
马化腾的微信开放平台（对应的还有腾讯开放平台）
融云IM
百度开发者中心
人脸识别
高德地图
蜻蜓FM
聚合的免费API接口 手机号码归属地API接口
历史上的今天API接口
股票数据API接口
全国WIFI接口
星座运势接口
黄金数据接口
语音识别接口
周公解梦接口
天气预报API接口
身份证查询API接口
笑话大全API接口
邮编查询接口
老黄历接口
网站安全检测接口
手机固话来电显示接口
基金财务数据接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d636ecb5b212bd0e6026b428478654a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec6940d573f83bb951430d45d577ae2/" rel="bookmark">
			Docker的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Docker概念
Docker安装
配置docker加速器
Docker命令
docker进程命令 docker镜像命令
容器命令
Docker容器的数据卷
数据卷概念
数据卷配置
数据卷容器
docker部署mysql
1、搜索mysql镜像
2、拉取mysql镜像
3. 创建容器，设置端口映射、目录映射
4、设置端口映射、目录映射
Tomcat部署
配置nginx
redis
Docker镜像
镜像制作
docker服务编排工具 一、安装Docker Compose
二、卸载Docker Compose
三、 使用docker compose编排nginx+springboot项目
docker私有仓库
一、私有仓库搭建
二、将镜像上传至私有仓库
三、 从私有仓库拉取镜像
平时我们开发会接触到开发环境、测试环境、生产环境 。
如果开发环境时jdk8，到测试环境时jdk7同样的代码可能就会出错。
那么可以将jdk8和代码一起装入到容器，测试环境在容器里就不会有环境的问题。
Docker概念 docker是一个开源的应用容器引擎。
Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，规避了因为环境而引起的问题。
容器是完全使用沙箱机制，相互隔离。
容器性能开销极低。
CE(社区版),EE(企业版)
docker是一种容器技术，解决了软件环境迁移的问题。
Docker安装 # 1、yum 包更新到最新 yum update
# 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2
# 3、 设置yum源
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cec6940d573f83bb951430d45d577ae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7a0746a6b7ba71f85f0579f4a1bf84/" rel="bookmark">
			mybatis plus框架的@TableField注解不生效问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 最近遇到一个mybatis plus的问题，@TableField注解不生效，导致查出来的字段反序列化后为空
数据库表结构：
CREATE TABLE `client_role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增主键', `name` varchar(64) NOT NULL COMMENT '角色的唯一标识', `desc` varchar(64) DEFAULT NULL COMMENT '角色描述', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='角色表' 对应的实体类
@Data @EqualsAndHashCode(callSuper = false) @Accessors(chain = true) @TableName("client_role") @ApiModel(value = "ClientRole对象", description = "角色表") public class ClientRole implements Serializable { private static final long serialVersionUID = 1L; /** * 自增主键 */ @ApiModelProperty(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c7a0746a6b7ba71f85f0579f4a1bf84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a869c1d0d5ed887fd500cc3be2d9cc4f/" rel="bookmark">
			Spring Boot 整合 Sharding-JDBC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 ShardingSphere，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（计划中）这3款相互独立的产品组成。定位为轻量级Java框架。其实就是一个增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。内部改写了SQL的添加和查询规则。适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。
技术架构： Spring Boot 2.6.3 、 Sharding-JDBC 3.0.0.M3、MySql 1主2从模式、 JDK1.8
导入依赖 &lt;!-- for spring boot --&gt; &lt;dependency&gt; &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${sharding-sphere.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;/dependency&gt; application.yml配置
#sharding-jdbc sharding.jdbc: datasource: names: ds-master,ds-slave-0,ds-slave-1 ds-master: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.116.105:3306/test-01 username: root password: root ds-slave-0: type: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a869c1d0d5ed887fd500cc3be2d9cc4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ff297b7cf1755734171111669d8e923/" rel="bookmark">
			SpringBoot定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot启动类注解 @EnableScheduling //开启基于注解的定时任务 controller层定时触发任务 //定时方法 @Scheduled(cron = "0 0/1 * * * ?") public void timedTask() throws ParseException { //查询所有订单列表 List&lt;Order&gt; order = orderService.selectAll(); System.out.println(order); Date date = new Date(); SimpleDateFormat sim1 = new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy", Locale.US); SimpleDateFormat sim2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String format1 = sim2.format(date); //遍历每个订单数据 for (int i = 0; i &lt; order.size(); i++) { String orderTime = String.valueOf(order.get(i).getOrderTime()); Date date1 = sim1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ff297b7cf1755734171111669d8e923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7aab0f8136faa24907e77f605497cf/" rel="bookmark">
			字符串模式匹配之KMP算法 ＜- AcWing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】
给定一个主串S，以及一个模式串T。且所有字符串中只包含大小写英文字母以及阿拉伯数字。
模式串T在主串S中多次作为子串出现。
求出模式串T在主串S中所有出现的位置的开始下标。
【输入格式】
第一行输入整数M，表示模式串T的长度。
第二行输入模式串T。
第三行输入整数 N，表示主串S的长度。
第四行输入主串S。
【输出格式】
共一行，输出所有出现位置的开始下标（下标从 0开始计数），整数之间用空格隔开。
【数据范围】
1≤N≤10^5
1≤M≤10^6
【输入样例】
3
aba
5
ababa
【输出样例】
0 2
【算法分析】
KMP算法本身并不复杂，主要分为两步：求next[ ]数组、匹配字符串。但绝大部分的文章把它讲混乱了，以致造成很多混淆。
KMP算法每次在失配时，不是把模式串T往后移动一位，而是把模式串T往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次模式串T移动的步数就是通过查找next[ ]数组确定的。next[ ]数组，是KMP算法的核心。
偶尔发现 https://www.acwing.com/solution/content/14666/ 文章讲得太好了，现加上个人见解分享之。
一、next[ ]数组的含义
next[ ]数组，既然是KMP算法的核心，因此在编码实现前就十分有必要了解一下求解next[ ]数组的思想以及涉及的基本概念。
1.求解next[ ]数组涉及到的基本概念
“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。简称前缀。
“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。简称后缀。
“部分匹配值”：前缀和后缀集合中最长共有元素的长度。
“部分匹配值表”，即next[ ]数组。它存储的是每一个下标对应的“部分匹配值”，是KMP算法的核心。
2.求解next[ ]数组的基本思想
下图是通过前缀和后缀集合中最长共有元素的长度，来构建“部分匹配值表”，即next[ ]数组的过程。
二、求next[ ]数组的代码
next[ ]数组的求法，是通过模式串T自己与自己进行匹配得出来的（代码和下文“匹配字符串”的操作几乎一样）。
for(int i=2, j=0; i&lt;=m; i++) { //求next[]数组。i从2开始，j从0开始。 while(j &amp;&amp; t[i]!=t[j+1]) j=ne[j]; //由于移动后可能仍然失配，所以要用while继续移动 if(t[i]==t[j+1]) j++; ne[i]=j; } 下图是T[a,b]=T[1,j]时，模式串T的状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c7aab0f8136faa24907e77f605497cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e24af9a22425663da0717637caa8a0f/" rel="bookmark">
			Hive03：Hive安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Hive安装部署 想要安装Hive，那首先要下载Hive的安装包，进入Hive的官网，找到download下载链接。
发现目前hive主要有三大版本，Hive1.x、Hive2.x、Hive3.x
Hive1.x已经2年没有更新了，所以这个版本后续基本不会再维护了，不过这个版本已经迭代了很多年了，也是比较稳定的
Hive2.x最近一直在更新
Hive3.x上次是19年8月份更新的，也算是一直在维护
那我们到底选择哪个版本呢？注意了，在选择Hive版本的时候我们需要注意已有的Hadoop集群的版本。因为Hive会依赖于Hadoop，所以版本需要兼容才可以。
具体Hive和Hadoop的版本对应关系可以在download页面下的news列表里面看到。
https://hive.apache.org/downloads.html
按照这里面说的hive2.x的需要在hadoop2.x版本中运行，hive3.x的需要在hadoop3.x版本中运行。
所以在这里我们最好是使用Hive3.x的版本
那我们就下载hive-3.1.2这个版本，如果想要下载其它历史版本的话这里面还找不到，不过可以使用apache的一个通用archive地址
https://archive.apache.org/dist/hive/
在这里面就可以找到hive的所有历史版本了
下面开始安装Hive
Hive相当于Hadoop的客户端工具，安装时不一定非要放在集群的节点中，可以放在任意一个集群客户端节点上都可以
1、文件下载上传 把下载好的hive安装包上传到bigdata04机器的/data/soft目录中，并且解压
[root@bigdata04 soft]# ll -rw-r--r--. 1 root root 278813748 May 5 23:08 apache-hive-3.1.2-bin.tar.gz [root@bigdata04 soft]# tar -zxvf apache-hive-3.1.2-bin.tar.gz 2、重命名配置文件 接着需要修改配置文件，进入hive的conf目录中，先对这两个模板文件重命名
[root@bigdata04 soft]# cd apache-hive-3.1.2-bin/conf/ [root@bigdata04 conf]# mv hive-env.sh.template hive-env.sh [root@bigdata04 conf]# mv hive-default.xml.template hive-site.xml 3、修改文件内容 然后再修改这两个文件的内容
注意：在hive-env.sh文件的末尾直接增加下面三行内容，【根据实际的路径配置】
[root@bigdata04 conf]# vi hive-env.sh ..... export JAVA_HOME=/data/soft/jdk1.8 export HIVE_HOME=/data/soft/apache-hive-3.1.2-bin export HADOOP_HOME=/data/soft/hadoop-3.2.0 注意：在hive-site.xml文件中根据下面property中的name属性的值修改对应value的值，这些属性默认里面都是有的，所以都是修改对应的value的值即可。
注：安装MySQL8.0.16 由于这里面需要指定Metastore的地址，Metastore我们使用Mysql，所以需要大家提前安装好Mysql，我这里使用的是Mysql8.0.16版本，Mysql安装包会提供给大家，建议大家直接在自己的windows机器中安装Mysql即可。
如果对MySQL8.x的安装部署不太熟悉的话，请参考下面的安装部署步骤，以及如何开启MySQL8的远程访问权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e24af9a22425663da0717637caa8a0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c82c74db6e51376970a7b9ed21e3ba72/" rel="bookmark">
			数据库常用命令之外键（foreign key）之多对一（总结，基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是小白，刚接触MySQL不久，现阶段正在学习，为此在CSDN上留下自己的学习笔记。如果有错误的地方还请大家见谅，评论或者私发我错误地方哦，谢谢大家，嘿嘿~
此篇将记录外键的相关知识，上篇内容为对一张表的约束条件（传送门：创建表的完整性语法）
外键（foreign key）：百度百科
引言：
要使两张表形成关联，外键只能引用外表中的列的值或使用空值。可以保持数据一致性，完整性，主要目的是控制存储在外键表中的数据。
如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。外键又称作外关键字。
员工表（关联表），部门表（被关联表） 对上表进行关联
foreign key注意：
1、被关联的字段必须是一个key，通常是id字段
2、创建表时：必须先建立被关联的表，才能建立关联表
建表（先创建部门表） 建立部门表：
create table dep(
id int primary key auto_increment,
dep_name varchar(20),
dep_info varchar(20)
);
建立员工表：
create table emp(
id int primary key auto_increment,
name varchar(20),
age int,
dep_id int,
constraint fk_emp_dep
foreign key(dep_id) references dep(id)
);
运行截图
语法
constraint 外键名字 foreign key(当前表需要关联的id：此处为dep_id) references 被关联的表名：此处为dep(被关联表的id，此处为id)
注：
1.constraint 外键名字：也可以不写，外键名字自己取，此处取为fk_emp_dep
2."constraint fk_emp_dep
foreign key(dep_id) references dep(id)"
可以写在一行，constraint fk_emp_dep foreign key(dep_id) references dep(id)，这里为了美观写为了两行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c82c74db6e51376970a7b9ed21e3ba72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3757220e5515e5d63c1f267d31a31e43/" rel="bookmark">
			Js拓展_算法课程设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、合作题1、破损的砝码问题优化前代码优化后 2、猜算式3.螺旋矩阵 二、个人题目1、找出亲密数2.蛇形矩阵 一、合作题 1、破损的砝码问题 优化前代码 // 找出所有砝码相加等于40的情况 (function() { let i, j, k, l; for (i = 1; i &lt;= 40; i++) { for (j = i + 1; j &lt;= 40; j++) { for (k = j + 1; k &lt;= 40; k++) { for (l = k + 1; l &lt;= 40; l++) { if (i + j + k + l === 40) { calculate(i, j, k, l) // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3757220e5515e5d63c1f267d31a31e43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605cb9f01b2f628f84ac633912faf0d8/" rel="bookmark">
			密码学 SM3算法 Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码学 SM3算法 Python实现 #SM3 IV = [0x7380166F, 0x4914B2B9, 0x172442D7, 0xDA8A0600, 0xA96F30BC, 0x163138AA, 0xE38DEE4D, 0xB0FB0E4E] T = [0x79cc4519, 0x7a879d8a] def ROL(X,i): i = i % 32 return ((X&lt;&lt;i)&amp;0xFFFFFFFF) | ((X&amp;0xFFFFFFFF)&gt;&gt;(32-i)) def FF(X,Y,Z,j): if j&gt;=0 and j&lt;=15: return X ^ Y ^ Z else: return ((X &amp; Y) | (X &amp; Z) | (Y &amp; Z)) def GG(X,Y,Z,j): if j&gt;=0 and j&lt;=15: return X ^ Y ^ Z else: return ((X &amp; Y) | (~X &amp; Z)) def P0(X): return X^ROL(X,9)^ROL(X,17) def P1(X): return X^ROL(X,15)^ROL(X,23) def T_(j): if j&gt;=0 and j&lt;=15: return T[0] else: return T[1] def Fill(message): m = bin(int(message,16))[2:] if len(m) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/605cb9f01b2f628f84ac633912faf0d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c566915a26ba2d9f61a1a87c780bcdac/" rel="bookmark">
			密码学 ZUC算法 Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码学 ZUC算法 Python实现 #ZUC算法 #测试向量 #KEY:(3d 4c 4b e9 6a 82 fd ae b5 8f 64 1d b1 7b 45 5b) #IV:(84 31 9a a8 de 69 15 ca 1f 6b da 6b fb d8 c7 66) S0=[[0x3e, 0x72, 0x5b, 0x47, 0xca, 0xe0, 0x00, 0x33, 0x04, 0xd1, 0x54, 0x98, 0x09, 0xb9, 0x6d, 0xcb], [0x7b, 0x1b, 0xf9, 0x32, 0xaf, 0x9d, 0x6a, 0xa5, 0xb8, 0x2d, 0xfc, 0x1d, 0x08, 0x53, 0x03, 0x90], [0x4d, 0x4e, 0x84, 0x99, 0xe4, 0xce, 0xd9, 0x91, 0xdd, 0xb6, 0x85, 0x48, 0x8b, 0x29, 0x6e, 0xac], [0xcd, 0xc1, 0xf8, 0x1e, 0x73, 0x43, 0x69, 0xc6, 0xb5, 0xbd, 0xfd, 0x39, 0x63, 0x20, 0xd4, 0x38], [0x76, 0x7d, 0xb2, 0xa7, 0xcf, 0xed, 0x57, 0xc5, 0xf3, 0x2c, 0xbb, 0x14, 0x21, 0x06, 0x55, 0x9b], [0xe3, 0xef, 0x5e, 0x31, 0x4f, 0x7f, 0x5a, 0xa4, 0x0d, 0x82, 0x51, 0x49, 0x5f, 0xba, 0x58, 0x1c], [0x4a, 0x16, 0xd5, 0x17, 0xa8, 0x92, 0x24, 0x1f, 0x8c, 0xff, 0xd8, 0xae, 0x2e, 0x01, 0xd3, 0xad], [0x3b, 0x4b, 0xda, 0x46, 0xeb, 0xc9, 0xde, 0x9a, 0x8f, 0x87, 0xd7, 0x3a, 0x80, 0x6f, 0x2f, 0xc8], [0xb1, 0xb4, 0x37, 0xf7, 0x0a, 0x22, 0x13, 0x28, 0x7c, 0xcc, 0x3c, 0x89, 0xc7, 0xc3, 0x96, 0x56], [0x07, 0xbf, 0x7e, 0xf0, 0x0b, 0x2b, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xa6, 0x4c, 0x10, 0xfe], [0xbc, 0x26, 0x95, 0x88, 0x8a, 0xb0, 0xa3, 0xfb, 0xc0, 0x18, 0x94, 0xf2, 0xe1, 0xe5, 0xe9, 0x5d], [0xd0, 0xdc, 0x11, 0x66, 0x64, 0x5c, 0xec, 0x59, 0x42, 0x75, 0x12, 0xf5, 0x74, 0x9c, 0xaa, 0x23], [0x0e, 0x86, 0xab, 0xbe, 0x2a, 0x02, 0xe7, 0x67, 0xe6, 0x44, 0xa2, 0x6c, 0xc2, 0x93, 0x9f, 0xf1], [0xf6, 0xfa, 0x36, 0xd2, 0x50, 0x68, 0x9e, 0x62, 0x71, 0x15, 0x3d, 0xd6, 0x40, 0xc4, 0xe2, 0x0f], [0x8e, 0x83, 0x77, 0x6b, 0x25, 0x05, 0x3f, 0x0c, 0x30, 0xea, 0x70, 0xb7, 0xa1, 0xe8, 0xa9, 0x65], [0x8d, 0x27, 0x1a, 0xdb, 0x81, 0xb3, 0xa0, 0xf4, 0x45, 0x7a, 0x19, 0xdf, 0xee, 0x78, 0x34, 0x60]] S1=[[0x55, 0xc2, 0x63, 0x71, 0x3b, 0xc8, 0x47, 0x86, 0x9f, 0x3c, 0xda, 0x5b, 0x29, 0xaa, 0xfd, 0x77], [0x8c, 0xc5, 0x94, 0x0c, 0xa6, 0x1a, 0x13, 0x00, 0xe3, 0xa8, 0x16, 0x72, 0x40, 0xf9, 0xf8, 0x42], [0x44, 0x26, 0x68, 0x96, 0x81, 0xd9, 0x45, 0x3e, 0x10, 0x76, 0xc6, 0xa7, 0x8b, 0x39, 0x43, 0xe1], [0x3a, 0xb5, 0x56, 0x2a, 0xc0, 0x6d, 0xb3, 0x05, 0x22, 0x66, 0xbf, 0xdc, 0x0b, 0xfa, 0x62, 0x48], [0xdd, 0x20, 0x11, 0x06, 0x36, 0xc9, 0xc1, 0xcf, 0xf6, 0x27, 0x52, 0xbb, 0x69, 0xf5, 0xd4, 0x87], [0x7f, 0x84, 0x4c, 0xd2, 0x9c, 0x57, 0xa4, 0xbc, 0x4f, 0x9a, 0xdf, 0xfe, 0xd6, 0x8d, 0x7a, 0xeb], [0x2b, 0x53, 0xd8, 0x5c, 0xa1, 0x14, 0x17, 0xfb, 0x23, 0xd5, 0x7d, 0x30, 0x67, 0x73, 0x08, 0x09], [0xee, 0xb7, 0x70, 0x3f, 0x61, 0xb2, 0x19, 0x8e, 0x4e, 0xe5, 0x4b, 0x93, 0x8f, 0x5d, 0xdb, 0xa9], [0xad, 0xf1, 0xae, 0x2e, 0xcb, 0x0d, 0xfc, 0xf4, 0x2d, 0x46, 0x6e, 0x1d, 0x97, 0xe8, 0xd1, 0xe9], [0x4d, 0x37, 0xa5, 0x75, 0x5e, 0x83, 0x9e, 0xab, 0x82, 0x9d, 0xb9, 0x1c, 0xe0, 0xcd, 0x49, 0x89], [0x01, 0xb6, 0xbd, 0x58, 0x24, 0xa2, 0x5f, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xb8, 0x95, 0xe4], [0xd0, 0x91, 0xc7, 0xce, 0xed, 0x0f, 0xb4, 0x6f, 0xa0, 0xcc, 0xf0, 0x02, 0x4a, 0x79, 0xc3, 0xde], [0xa3, 0xef, 0xea, 0x51, 0xe6, 0x6b, 0x18, 0xec, 0x1b, 0x2c, 0x80, 0xf7, 0x74, 0xe7, 0xff, 0x21], [0x5a, 0x6a, 0x54, 0x1e, 0x41, 0x31, 0x92, 0x35, 0xc4, 0x33, 0x07, 0x0a, 0xba, 0x7e, 0x0e, 0x34], [0x88, 0xb1, 0x98, 0x7c, 0xf3, 0x3d, 0x60, 0x6c, 0x7b, 0xca, 0xd3, 0x1f, 0x32, 0x65, 0x04, 0x28], [0x64, 0xbe, 0x85, 0x9b, 0x2f, 0x59, 0x8a, 0xd7, 0xb0, 0x25, 0xac, 0xaf, 0x12, 0x03, 0xe2, 0xf2]] D=[ 0x44d7, 0x26bc, 0x626b, 0x135e, 0x5789, 0x35e2, 0x7135, 0x09af, 0x4d78, 0x2f13, 0x6bc4, 0x1af1, 0x5e26, 0x3c4d, 0x789a, 0x47ac] S = [0]*16 X = [0]*4 W = 0 R1 = 0 R2 = 0 def L1(X): return X^ROL(X,2)^ROL(X,10)^ROL(X,18)^ROL(X,24)&amp;0xFFFFFFFF def L2(X): return X^ROL(X,8)^ROL(X,14)^ROL(X,22)^ROL(X,30)&amp;0xFFFFFFFF def ROL(X,i): return ((X&lt;&lt;i)&amp;0xFFFFFFFF) | (X&gt;&gt;(32-i)) def S_box(X): temp = [X&gt;&gt;24, (X&gt;&gt;16)&amp;0xFF, (X&gt;&gt;8)&amp;0xFF, X&amp;0xFF] S_result = [0]*4 for i in range(4): if i==0 or i==2: for m,n in [(temp[i] &gt;&gt; 4,temp[i] &amp; 0xf)]: S_result[i] = S0[m][n] else: for m,n in [(temp[i] &gt;&gt; 4,temp[i] &amp; 0xf)]: S_result[i] = S1[m][n] return (S_result[0]&lt;&lt;24 | S_result[1]&lt;&lt;16 | S_result[2]&lt;&lt;8 | S_result[3]) def BitReconstruction(): X[0] = (((S[15]&gt;&gt;15)&amp;0xFFFF)&lt;&lt;16) | (S[14]&amp;0xFFFF) X[1] = ((S[11]&amp;0xFFFF)&lt;&lt;16) | ((S[9]&gt;&gt;15)&amp;0xFFFF) X[2] = ((S[7]&amp;0xFFFF)&lt;&lt;16) | ((S[5]&gt;&gt;15)&amp;0xFFFF) X[3] = ((S[2]&amp;0xFFFF)&lt;&lt;16) | ((S[0]&gt;&gt;15)&amp;0xFFFF) def F(X0,X1,X2): global W,R1,R2 W = ((X0^R1)+R2)%(2**32) W1 = (R1+X1)%(2**32) W2 = R2^X2 temp1 = ((W1&lt;&lt;16) | (W2&gt;&gt;16))&amp;0xFFFFFFFF temp2 = ((W2&lt;&lt;16) | (W1&gt;&gt;16))&amp;0xFFFFFFFF R1 = S_box(L1(temp1)) R2 = S_box(L2(temp2)) def LFSRWithInitialisationMode(u): v = ((2**15)*S[15]+(2**17)*S[13]+(2**21)*S[10]+(2**20)*S[4]+(1+2**8)*S[0])%(2**31-1) S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c566915a26ba2d9f61a1a87c780bcdac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda064d02b406ce8649aa4e654ae7f9b/" rel="bookmark">
			计操实验 分页存储管理C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计操实验 分页存储管理 C语言 需求：
假定页面大小为4K，物理内存128M，设计并实现一个内存分配和回收的程序，使用C语言或Python语言编写程序实现这个程序并进行测试。
（1）至少5个进程；
（2）要求有空块管理；
（3）要求有一个逻辑地址到物理地址的变换。
流程图：
//页面大小4K,物理内存128M //分配、释放内存，逻辑地址到物理地址，空块管理 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; #define COUNT 32768 //块数量 #define SIZE 4096 //块大小 int BLOCK[COUNT]; //物理块状态 0空闲1占用 int BlankBlockNum=COUNT; //空块数量 typedef struct ProcessList { int ID; int Size; int Pages; int Page[100]; //页表 struct ProcessList *next; }Process; Process *head=NULL; void InitProcess() { int num,RandomNumber; printf("请输入进程数:\n"); scanf("%d",&amp;num); Process *temp; for(int i=0;i&lt;num;i++) { temp = (Process*)malloc(sizeof(Process)); printf("请输入进程的序号、大小:\n"); scanf("%d %d",&amp;temp-&gt;ID,&amp;temp-&gt;Size); if(temp-&gt;Size%SIZE==0) { temp-&gt;Pages = temp-&gt;Size/SIZE; } else { temp-&gt;Pages = temp-&gt;Size/SIZE+1; } temp-&gt;next = NULL; //空块管理 if(temp-&gt;Pages&lt;BlankBlockNum) { BlankBlockNum -=temp-&gt;Pages; } else { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fda064d02b406ce8649aa4e654ae7f9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c83f0503b43b8287f6e0c46d1a641074/" rel="bookmark">
			计操实验 多级反馈队列C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计操实验 多级反馈队列C语言 需求：
1.队列4级，每一级的队列长度均为10；第一级的时间片为T，第二级的时间片为2T，第三级的时间片为4T，第四级的时间片为8T；（T的大小自己定）
2.非立即抢占的剥夺式调度算法；
3.要有：在调度高级别队列时，有新来的进程进入系统。
流程图：
代码如下：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #define T 1 typedef struct Node { int ArrivalTime; //到达时间 int WorkTime; //服务时间 int number; //到达顺序 int flag; //0等待，1运行完成 struct Node *next; }Process; typedef struct QueueList { int TimeSlice; //时间片 int length; //队列长度 Process *front; //队列第一个进程指针 struct QueueList *next; }Queue; Queue *head = NULL; Process *Finish = NULL; //已完成 int time = 0; void InitQueue() { Queue *temp; for(int i=0;i&lt;4;i++) { temp = (Queue*)malloc(sizeof(Queue)); temp-&gt;front = NULL; temp-&gt;TimeSlice = pow(2,i)*T; temp-&gt;length = 10; temp-&gt;next = NULL; if(head == NULL) { head = temp; temp = NULL; } else { Queue *temp2; temp2 = head; while(temp2-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c83f0503b43b8287f6e0c46d1a641074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc340d8bddca9ebd89370c6d0f2a12ec/" rel="bookmark">
			跨模态检索研究进展综述【跨模态检索的核心工作在于：①不同模态数据的特征提取、②不同模态数据之间内容的相关性度量】【主流研究方法：基于传统统计分析的技术、基于深度学习的技术】【哈希编码提高检索速度】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网上多媒体数据的爆炸式增长,单一模态的检索已经无法满足用户需求,跨模态检索应运而生.
跨模态检索旨在以一种模态的数据去检索另一种模态的相关数据。
跨模态检索的核心任务是：数据特征提取 和 不同模态数据之间内容的相关性度量。
文中梳理了跨模态检索领域近期的研究进展,从以下角度归纳论述了跨模态检索领域的研究成果.：
传统方法；深度学习方法；手工特征的哈希编码方法；深度学习的哈希编码方法 在此基础上,对比分析了各类算法在跨模态检索常用标准数据集上的性能。最后,分析了跨模态检索研究存在的问题,并对该领域未来发展趋势以及应用进行了展望.
一、概述 随着互联网上数据规模的不断壮大,数据类型越来越呈现多样化的特点,用户感兴趣的数据模态不再单一,用户的检索需求也越来越呈现出从单一模态到跨模态的发展态势.模态是指数据的表达形式,包括文本、图像、视频和音频等.
跨模态检索是至少两种模态的数据之间互相检索，通常是以一种模态作为查询来检索另一种模态的相关数据。通过找出不同模态数据之间的潜在关联，实现相对准确的交叉匹配.
如以文本检索相关图像,文本集为 T ＝ { t , … , t n } T＝\{t_,…,t_n\} T＝{t,​…,tn​}, 图像集为 V ＝ { v , … , v n } V＝\{v_,…,v_n\} V＝{v,​…,vn​}，针对查询文本 t q , q ∈ [ 1 , n ] t_q,q∈[1,n] tq​,q∈[1,n],检索出与 t q t_q tq​ 最相似的图像 v q ＝ { v i ∣ m a x s i m ( t q , v i ) , i ∈ [ 1 , n ] } v_q＝\{v_i|maxsim(t_q,v_i),i∈[1,n]\} vq​＝{vi​∣maxsim(tq​,vi​),i∈[1,n]}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc340d8bddca9ebd89370c6d0f2a12ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db1158a3df9b377333982198ae93a375/" rel="bookmark">
			Qt QTableView之QSqlTableModel数据库显示及插入删除操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QTableView的使用 初始化QTableView控件
//设置tableview行表头 文字居中
horizontalHeader()-&gt;setDefaultAlignment(Qt::AlignCenter);
//设置tableview列表头 文字居中
verticalHeader()-&gt;setDefaultAlignment(Qt::AlignCenter);
//设置列的默认大小
verticalHeader()-&gt;setDefaultSectionSize(50);
//设置列表头是否显示
verticalHeader()-&gt;setVisible(false);//true-&gt;显示 ， false-&gt;不显示
//设置最后一行自动调整
horizontalHeader()-&gt;setStretchLastSection(true);
//自动调整大小
//resizeColumnToContents(int);//第几列
//setSectionResizeMode(QHeaderView::Stretch);等宽
//设置是否有网格线
setShowGrid(true);
setGridStyle(Qt::SolidLine);//设置网格线类型Qt::DashLine -&gt;虚线
horizontalHeader()-&gt;setHighlightSections(false); //解决表头塌陷问题:点击表格时不对表格行光亮使用tableview控件的设置
//单一和多选选择
setSelectionMode(QAbstractItemView::SingleSelection);
setSelectionMode(QAbstractItemView::ExtendedSelection);
//选择整行
table-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);
//去掉水平滚动条
table-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//内容不可编辑
table-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers); 附上QTableView控件初始化函数接口
/************************************************* Function: tableviewInit// 函数名称 Description: QTableview 初始化函数// 函数功能、性能等的描述 Input: QTableView *table -&gt;控件名// 输入参数说明，包括每个参数的作用、取值说明及参数间关系。 Return: 无// 函数返回值的说明 *************************************************/ void Widget::tableviewInit(QTableView *table) { table-&gt;horizontalHeader()-&gt;setDefaultAlignment(Qt::AlignCenter); table-&gt;verticalHeader()-&gt;setDefaultAlignment(Qt::AlignCenter); table-&gt;verticalHeader()-&gt;setDefaultSectionSize(50); table-&gt;verticalHeader()-&gt;setVisible(false); table-&gt;setSelectionMode(QAbstractItemView::SingleSelection); table-&gt;setSelectionBehavior(QAbstractItemView::SelectRows); table-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); table-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers); //table-&gt;resizeColumnToContents(2); //table-&gt;resizeColumnToContents(3); //table-&gt;resizeColumnToContents(4); //table-&gt;setColumnWidth(6,152); table-&gt;horizontalHeader()-&gt;setStretchLastSection(true); //table-&gt;verticalHeader()-&gt;setMinimumWidth(30); table-&gt;setShowGrid(true); table-&gt;setGridStyle(Qt::SolidLine); } SQL 映射到QTableView 控件上 附上SQL映射Qtableview函数接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db1158a3df9b377333982198ae93a375/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/166/">«</a>
	<span class="pagination__item pagination__item--current">167/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/168/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>