<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a62379247b46117405b266effafcc777/" rel="bookmark">
			postgresql中的substr()函数使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.SELECT substr(o.code,15) FROM sys_org as o 2.select substr('alphabet', 3, 2) 3.select substr('alphabet', 3) sys_org表中的code字段的指是：
代码执行结果分别是：
substr(String ss,int a,int b)
切记a最好从1往上了写，b表示截取几位。 a写1表示从第一位开始截取，
a可以写 1 0 -1 … ，1表示从第一位开始截取，0表示从第一位前一位开始截取(-1位截取)， -1表示从第一位前两位开始截取(-2位截取)。 以此类推！！！
这辈子坚持与不坚持都不可怕，怕的是独自走在坚持的道路上！
欢迎加入技术群聊！ 参考链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22bb05a1083d68dca6b4877ccd2e72b8/" rel="bookmark">
			漏洞信息收集之——指纹识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指纹识别 目录 指纹识别目的常见指纹检测的对象常见指纹识别方式1、特定文件的MD52、正常页面或错误网页中包含的关键字3、请求头信息的关键字匹配4、部分URL中包含的关键字，比如wp-includes、dede等URL关键特征5、开发语言的识别 常见指纹识别工具 目的 知道对方使用的CMS（是自己开发还是开源的，有什么端口，中间件，IP，服务器存放地址），二级域名，敏感信息，
在这个过程可以加入端口扫描，敏感信息收集
御剑web指纹识别系统
whatweb
wapplyzer
在线识纹识别：
http://whatweb.bugscaner.com/look/
http://www.yunsee.cn/finger.html
Waf 识别
github.com/EnableSecurity/wafw00f
CDN 识别 https://raw.githubusercontent.com/3xp10it/mytools/master/xcdn.py
参考资料（安全客web指纹识别技术研究与优化实现）https://www.anquanke.com/post/id/178230
常见指纹检测的对象 1、CMS信息：比如大汉CMS、织梦、帝国CMS、phpcms、ecshop等；
2、前端技术：比如HTML5、jquery、bootstrap、pure、ace等；
3、Web服务器：比如Apache、lighttpd, Nginx, IIS等；
4、应用服务器：比如Tomcat、Jboss、weblogic、websphere等；
5、开发语言：比如PHP、Java、Ruby、Python、C#等；
6、操作系统信息：比如linux、win2k8、win7、kali、centos等；
7、CDN信息：是否使用CDN，如cloudflare、360cdn、365cyd、yunjiasu等；
8、WAF信息：是否使用waf，如Topsec、Jiasule、Yundun等；
9、IP及域名信息：IP和域名注册信息、服务商信息等； 10、端口信息：有些软件或平台还会探测服务器开放的常见端口。
常见指纹识别方式 1、特定文件的MD5 一些网站的特定图片文件、js文件、CSS等静态文件，如favicon.ico、css、logo.ico、js等文件一般不会修改，通过爬虫对这些文件进行抓取并比对md5值，如果和规则库中的Md5一致则说明是同一CMS。这种方式速度比较快，误报率相对低一些，但也不排除有些二次开发的CMS会修改这些文件。
获得哈希值，工具对比
2、正常页面或错误网页中包含的关键字 先访问首页或特定页面如robots.txt等，通过正则的方式去匹配某些关键字，如Powered by Discuz、dedecms等。
或者可以构造错误页面，根据报错信息来判断使用的CMS或者中间件信息，比较常见的如tomcat的报错页面。
3、请求头信息的关键字匹配 根据网站response返回头信息进行关键字匹配，whatweb和Wappalyzer就是通过banner信息来快速识别指纹，之前fofa的web指纹库很多都是使用的这种方法，效率非常高，基本请求一次就可以，但搜集这些规则可能会耗时很长。而且这些banner信息有些很容易被改掉。
根据response header一般有以下几种识别方式：
查看http响应报头的X-Powered-By字段来识别；
根据Cookies来进行判断，比如一些waf会在返回头中包含一些信息，如360wzws、Safedog、yunsuo等；
根据header中的Server信息来判断，如DVRDVS-Webs、yunjiasu-nginx、Mod_Security、nginx-wallarm等；
根据WWW-Authenticate进行判断，一些路由交换设备可能存在这个字段，如NETCORE、huawei、h3c等设备。
4、部分URL中包含的关键字，比如wp-includes、dede等URL关键特征 通过规则库去探测是否有相应目录，或者根据爬虫结果对链接url进行分析，或者对robots.txt文件中目录进行检测等等方式，通过url地址来判别是否使用了某CMS，比如wordpress默认存在wp-includes和wp-admin目录，织梦默认管理后台为dede目录，solr平台可能使用/solr目录，weblogic可能使用wls-wsat目录等。
5、开发语言的识别 web开发语言一般常见的有PHP、jsp、aspx、asp等，常见的识别方式有：
通过爬虫获取动态链接进行直接判断是比较简便的方法。
asp判别规则如下&lt;a[^&gt;]*?href=(‘|”)[^http][^&gt;]*?\.asp(\?|\#|\1)，其他语言可替换相应asp即可。
通过X-Powered-By进行识别
比较常见的有X-Powered-By: ASP.NET或者X-Powered-By: PHP/7.1.8
通过Set-Cookie进行识别
这种方法比较常见也很快捷，比如Set-Cookie中包含PHPSSIONID说明是php、包含JSESSIONID说明是java、包含ASP.NET_SessionId说明是aspx等。
常见指纹识别工具 Wappalyzer(集成在浏览器或可单独)
whatweb（集成在kali）
what web -v（详细信息）+ 域名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22bb05a1083d68dca6b4877ccd2e72b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc16a038f082bbbabe7bb5d80d55f79/" rel="bookmark">
			数据中心EOR/MOR/TOR布线概念（整理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据中心机房平面布局通常采用矩形结构，为了保证制冷效果，通常将10 至 20 个机柜背靠背并排放置成一行，形成一对机柜组（又称为一个POD）。POD中的机柜都采用前后通风模式，冷空气从机柜前面板的吸入并从后部排出，由此在机柜背靠背摆放的POD中间形成 “热通道”，相邻的两个POD之间形成“冷通道”。热通道正对CRAC（机房空调），热空气沿热通道流回CRAC，再开始新一次循环。
每个POD由服务器机柜和网络机柜组成，其中服务器机柜占多数。由于服务器的形态差异（机架式服务器、刀片服务器），POD中服务器机柜和网络机柜的布线方式也存在差异。
一、机架式服务器布线方式： EOR（End of Row）
EOR是数据中心综合布线最传统的方法，接入交换机集中安装在一列机柜端部的机柜（交换机机柜）内，通过水平线缆以永久链路方式连接设备柜内的主机/服务器/小型机设备。
交换机EOR布线方式最为常见。通常在服务器和接入交换机安装以前，服务器机柜到网络机柜的布线施工已经完成，设备（服务器/交换机）安装和跳线工作都在服务器机柜内和网络机柜内进行。
二、机架式服务器的布线方式：MOR（Middle of Row）
MOR布线是对EOR布线方式的改进，主要区别是在摆放列头机柜的位置，MOR是将其放在每一列机柜的中间 。MOR方式的网络机柜部署在POD的两排机柜的中部，由此可以减少从服务器机柜到网络机柜的线缆距离，简化线缆管理维护工作。MOR的设置方式可以使得线缆从中间位置的列柜向两端布放，降低线缆在布线通道出入口的拥堵现象，并减少线缆的平均长度，也适合实施定制长度的预连接系统，而且对布线机柜内配线设备的交叉连接和管理较EOR 要方便 。
三、机架式服务器的布线方式： TOR（Top of Rack）
交换机TOR布线方式是对EOR/MOR方式的扩展，采用TOR布线时，POD中每个服务器机柜的上端部署1-2台两台接入交换机，机架式服务器通过跳线接入到机柜内的交换机上，交换机上行端口通过铜缆或光线接入到EOR/MOR的网络机柜中的汇聚交换上。如图所示
TOR布线方式简化了服务器机柜与网络机柜间的布线，从每个服务器机柜到EOR/MOR的网络机柜的光纤或铜缆数量较少（4-6根）。
机柜中服务器的密度高。对于标准的19英寸宽，42U高的机柜，如果采用交换机TOR布线方式，则每个机柜可部署15-30台1U高度的机架式服务器（具体数量需要考虑单台服务器的功耗和机柜的电源输出功率）。
随着用户数据业务需求的猛增，数据中心机房服务器密度越来越高，虚拟化和云计算等新技术趋势日益流行，使得服务器对应的网络端口大大增加，并且增加了管理的复杂性，另外以太网（LAN）与光纤存储区域网络（SAN）的融合也越来越常见，这就必然要求一种新的网络拓扑结构与之相对应。在云计算的大潮下，这种分布式架构的业务扩展性极强，要求的服务器数量也越来越多。海量的服务器数量要求充分利用数据中心机柜空间的同时，海量的业务数据也需要更快更直接的高性能链路把数据传送到网络核心。在这样的趋势下，显然TOR更加适用，在业务迅速扩展的压力下，TOR的方式可以更好的实现网络的更快速扩展。
四、对比
EOR布线的缺点：
从服务器机柜到网络机柜的铜缆多（约有20-40根铜缆），且距网络机柜越远的服务器机柜的铜缆，在机房中的布线距离越长，由此导致线缆管理维护工作量大、灵活性差。
TOR布线的缺点：
1、可能造成端口浪费：一直以来，TOR被诟病最多的就是交换机端口冗余问题。
每个服务器机柜受电源输出功率限制，可部署的服务器数量有限，由此导致机柜内交换机的接入端口利用率不足。在几个服务器机柜间共用1-2台接入交换机，可解决交换机端口利用率不足的问题，但这种方式增加了线缆管理工作量。
TIA TR-42 通信布线系统工程委员会副主席Valerie Maguire曾介绍过一个真实案例，某用户共有336个服务器机柜，每个机柜配置2台48端口的TOR交换机和40台服务器，这就使得每个交换机有8个端口是空闲的，整个网络就有112整台交换机端口数量都是空闲的。这些超额购买的设备和3年维护的成本总计将达到112万美金。如果考虑机柜受供电能力约束的真实情况，每个机柜能放置的服务器数量远小于40台，则浪费的总额将更高。而若采用集中式布线只需花费 27.5万美金，通过在布线上的投资就能换来极大的交换机等设备的节约。
从网络设计考虑，TOR布线方式的每台接入交换机上的VLAN量不会很多，在网络规划的时候也要尽量避免使一个VLAN通过汇聚交换机跨多台接入交换机，因此采用TOR布线方式的网络拓扑中，每个VLAN的范围不会太大，包含的端口数量不会太多。但对于EOR布线方式来说，接入交换机的端口密度高，在网路最初设计时，就可能存在包含较多端口数的VLAN。
2、成本未必节省
TOR方式得到推广的一个重要理由，是节省了大量的布线成本和制冷成本，简化结构，使得机房更加绿色节能。但深入研究会发现，布线成本减少的代价是网络接入设备成本的增加和端口冗余，并且缩减也只是水平铜缆布线的部分，TOR对于光纤的要求比传统布线方式更多。在初期建设成本之外，后期的管理和扩展问题有可能变得更加复杂。
3、增加管理难度：TOR方式的接入交换机数量多，EOR方式的接入交换机数量少，所以TOR方式的网络设备管理维护工作量大。
五、刀片服务器的布线方式
集成刀片交换机的刀片服务器在进行机柜安装时，不需要考虑机柜内从服务器到接入交换机/或配线架的跳线，只需考虑刀片交换机上行端口的配线方式即可。集成交换机模块的刀片服务器主要采用EOR/MOR布线方式，但这种EOR布线方式与机架式服务器TOR布线方式的特点基本相同。服务器在服务器机柜内完成网络接入，从服务器机柜到EOR/MOR网络机柜的电缆主要是刀片交换机上行汇聚交换机的光线，而且数量比较少。但刀片服务器的计算单元的密度比机架式服务器更高，所以对单个机柜的电源输出功率以及机房制冷环境的要求也更高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9225376c6aa729b6fced7236a3e9adb4/" rel="bookmark">
			像羽毛一样轻的MVVMLight（一）（MVVM 和 MVVMLight简介）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		致敬 在此致敬翁智华大佬，感谢大佬为后辈们写下如此详细的文档，本文将在原文基础上添加些自己的理解，希望这样优秀的文档广为流传。
原文请参考
https://www.cnblogs.com/wzh2010/p/6285954.html
一、MVVM 和 MVVMLight
要了解MVVMLight，得先了解MVVM。
首先，MVVM是Model-View-ViewModel的简写。类似于目前比较流行的MVC、MVP设计模式，
主要目的是为了分离视图（View）和模型（Model）的耦合。它是一种极度优秀的设计模式，但并非框架级别的东西
（所以不要再说MVVM框架了），它是由MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型
架构。
结构如图所示:
相对于之前把逻辑结构写在Code Behind（就是将代码直接写在cs里面导致界面逻辑和业务逻辑混在一起） 里面的方式，
MVVM几乎完全解耦了视图和逻辑业务的关系，通过数据绑定和命令来处理UI属性及事件驱动（即数据驱动界面）。
同理，ViewModel的视图交互业务逻辑处理导致的属性变更也会通知到View前端，让View前端实时更新。
Model（模型）：存放数据模型和数据逻辑、业务逻辑。
ViewModel：负责Model和View之间的协调调用，即捕捉View上进行的操作后，再调用Model的相关类的方法对属性和变量等进行更改。
View（视图）：负责界面展示。
一个View可以绑定一个ViewModel,但是一个ViewModel可以对应多个View,
这种类型的双向绑定非常优秀，View的变动，会自动反应到ViewModel上，反之亦然。
MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点
1. 低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，
当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
2. 可重用性：可以把一些视图逻辑放在一个ViewModel里面，让很多View重用这段视图逻辑。
3. 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，
使用Expression Blend可以很容易设计界面并生成xml代码。
4. 可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。
希望对MVVM有更进一步了解的同学可以看看这篇文章：https://www.codeproject.com/kb/wpf/wpfmvvmquickstart.aspx，
作者从MVVM的模式介绍到数据绑定、消息通知、命令等几个主要方面都有详细的说明。
如果你目前正在进行微软的 WPF 、Windows Phone、Windows 8、SilverLight相关项目的开发，
我觉得很有必要了解一下MVVM Light框架。它轻量（相对于Prism），专注（仅负责MVVM架构模式的实现，
没有其他多余的组件），高效（使用简易，省时减力）,能够帮助你更好的开发你的应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9300d28d9d15a4610b8a7230605daa7/" rel="bookmark">
			Game101课程笔记_lecture18_复杂外观、高级光线传播与实时光线追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Game101课程笔记_lecture18_复杂外观、高级光线传播与实时光线追踪 1 高级光线传播1 无偏2 BDPT 双向路径追踪3 MLT (Metropolis light Transport)4 光子映射5 VCM6 Instant Radiosity(IR) 2 高级外观1 非表面模型1 散射介质。2 Hair3 Fur 2 Granular Material颗粒模型。3 表面模型Translucent material半透明材质次表面散射 4 Cloth布料 3 Detailed Appearance细节渲染4 Wave Optics.波动光学5 程序生成外观 BTF —空间变化BRDF
1 高级光线传播 1 无偏 2 BDPT 双向路径追踪 path tracying第一个弹射是漫反射的时候，就可能没有光路生成。
双向路径追踪的话可以从光源出发,同时从眼睛出发，如果有交点就可以了，这样就会形成更多的光路。
3 MLT (Metropolis light Transport) 马尔可夫链
pdf 和积分函数形状一致的时候，pdf是最好的。
马尔可夫链可以让任何未知函数可以形成一些样本可以和pdf形状一致。
下面的图：
半开着门，越难的场景，mlt最适合。
游泳池低的场景，从眼睛出发，先经过
specular path.
但是这个方法无法估计啥时候收敛。
简单的蒙特卡洛方法是可以的。
有一些像素收敛的快，有些收敛的慢。结果会很脏。
不能作为渲染动画的方法。
4 光子映射 特别适合渲染caustics–由于光线的聚焦生成的一些效果。
国内的翻译很多翻译的这个词有问题。
实现方法狠多。
两部做法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9300d28d9d15a4610b8a7230605daa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4447cdcebf17626aabade221fb6eced8/" rel="bookmark">
			AES解密，key长度不够16处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AES解密，有时会遇到key长度不够16位的场景，如何处理，如下以AES-128-ECB解密模式为例进行展示。
public class Test { public static void main(String[] args) throws Exception { String str="htNbZOHaXvMimfeSoK5jQg==";//AES-128-ECB加密后的密文 String decStr=decrypt(str,"123"); System.out.println(decStr); } /* * * @Author na_tion * @Description AES解密函数 * 也可以使用其他网上常见的函数 * @Date 10:53 上午 2020/04/10 * @Param [content, passwd] * @return java.lang.String **/ public static String decrypt(String content, String passwd) { try { Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");// 创建密码器 SecretKeySpec key = new SecretKeySpec(passwd.getBytes(), "AES"); cipher.init(Cipher.DECRYPT_MODE, key);// 初始化 byte[] result = new BASE64Decoder().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4447cdcebf17626aabade221fb6eced8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982438ffaa28ba18859bce51def4f3f6/" rel="bookmark">
			sql Server2012 彻底删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上有很多方案，也参考过很多大佬们的方法，这里我就总结一下，自己也操作过的，希望能帮助大家解决sql 重新安装的问题
一、卸载sql数据库
首先下载一个电脑管家，用电脑管家卸载sql数据库（如果从电脑的程序里面卸载的话，东西太多，容易删错，少删东西），其次，在卸载程序里面搜索sql的相关文件，把可以删除的都删除，若出现一些警告的文件，可以不删除。
二、删除注册表
1、HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Microsoft SQL Server
（这个地方注意了，在这个附近，有可能有你安装的部分组
件的注册嘛，名字前缀都是Microsoft SQL，一并删除了。如下：）
2、HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ MSSQLServer
3、HKEY_CURRENT_USER\ Software\ Microsoft\ Microsoft SQL Server
三、删除C盘的两个sql文件
1、C:\Program Files\Microsoft SQL Server
2、C:\Program Files (x86)\Microsoft SQL Server
四、重启电脑
删除的注册表需要重启一下才能生效
五、安装
建议还是不要更改安装路径，方便你后期的处理，小编当时也改过，但后来数据库出问题的时候，就觉得很麻烦。希望此方法对你有效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76c8d89f683cc205f2959fc030c0b485/" rel="bookmark">
			KNN算法实战之手写数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、说明二、题目三、实践部分3.1 准备数据：将图像转换为测试向量3.2 KNN算法3.3 测试算法：使用kNN识别手写数字3.4 截图 四、源代码4.1 KNN.py4.2 KNN.ipynb 一、说明 我是在jupyter完成的，然后导出成markdown格式，ipynb文件导出为markdown的命令如下：
jupyter nbconvert --to markdown xxx.ipynb
二、题目 构造使用K-近邻分类器的手写识别系统。由于能力有限，这里构造的系统只能识别0-9。需要识别的数字已经使用图形处理软件，处理成具有相同的色彩和大小：32像素*32像素的黑白图像。
例如：
当前使用文本格式存储图像，即使不能有效的利用空间，但是为了方便理解，还是将图像转换成文本格式。
示例：使用k-近邻算法的手写识别系统
（1）收集数据：提供文本文件。
（2）处理数据：编写img2vector()函数，将图像格式转换成分类器使用的向量格式。
（3）分析数据：在Python命令提示符中检查数据，确保它符合要求。
（4）训练算法：此步骤不适用于k-近邻算法。
（5）测试算法：编写函数使用提供的部分数据集作为测试样本，对学习算法进行测试。
（6）使用算法：本例没有完成此步骤
三、实践部分 3.1 准备数据：将图像转换为测试向量 trainingDigits中包含了大约2000个例子，每个数字大约有200个样本；测试文件testDigits中包含了大约900个测试数据。两组数据没有重叠。为了使用kNN算法分类器必须将一个3232的二进制矩阵转换为11024的向量，以便我们使用分类器处理数字图像信息。
首先定义img2vector()函数，将3232的二进制矩阵转换成11024的矩阵并返回。
# 图片 to 向量 def img2vector(filename): returnVect = zeros((1, 1024)) fr = open(filename) for i in range(32): lineStr = fr.readline() for j in range(32): returnVect[0, 32 * i + j] = int(lineStr[j]) return returnVect 该函数使用方法
testVector = img2vector("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76c8d89f683cc205f2959fc030c0b485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c12cd8bd549fe4984fe181501a83905/" rel="bookmark">
			Django 的 Admin 界面Excel数据导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将介绍如何在Django 框架中方便的在 Admin 界面加入 Excel导出功能。
目录 1. 安装依赖2. 构建通用的 Excel 文件返回函数3. 在 Admin 模块创建 action 1. 安装依赖 本文中的 Excel 文件的生成模块为 xlwt
pip install xlwt 2. 构建通用的 Excel 文件返回函数 import datetime import xlwt from django.http import FileResponse def file_iterator(filename, chuck_size=512): """ 将文件分块返回 :param filename: 文件名称 :param chuck_size: 块的大小，默认 512 :return: 文件以可迭代对象的方式分块返回 """ with open(filename, "rb") as f: while True: c = f.read(chuck_size) if c: yield c else: break def export_excel(queryset, headers, columns, filename='file_name', choices_fields_value=None): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c12cd8bd549fe4984fe181501a83905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d725b2da6797a613b5ae7d9a07a125a/" rel="bookmark">
			openwrt luci 实现框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.总述 上一篇总结了uhttpd的工作方式，openwrt中利用它作为web服务器，实现客户端web页面配置功能。对于request处理方式，采用的是cgi，而所用的cgi程序就是luci，工作框架如下图所示：
Client端和serv端采用cgi方式交互，uhttpd服务器的cgi方式中，fork出一个子进程，子进程利用execl替换为luci进程空间，并通过setenv环境变量的方式，传递一些固定格式的数据（如PATH_INFO）给luci。另外一些非固定格式的数据（post-data）则由父进程通过一个w_pipe写给luci的stdin，而luci的返回数据则写在stdout上，由父进程通过一个r_pipe读取。
下面的图描述了web配置时的数据交互：
首次运行时，是以普通的file方式获得docroot/index.html，该文件中以meta的方式自动跳转到cgi的url，这是web服务器的一般做法。
然后第一次执行luci，path_info='/'，会alise到'/admin'（'/'会索引到 tree.rootnode，并执行其target方法，即alise('/admin')，即重新去索引adminnode，这在后面会详细描述），该节点需要认证，所以返回一个登录界面。
第3次交互，过程同上一次的，只是这时已post来了登录信息，所以serv端会生成一个session值，然后执行'/admin'的target（它的target为firstchild，即索引第一个子节点），最终返回/admin/status.html，同时会把session值以cookie的形式发给client。这就是从原始状态到得到显示页面的过程，之后主要就是点击页面上的连接，产生新的request。
每个链接的url中都会带有一个stok值（它是serv生成的，并放在html中的url里），并且每个新request都要带有session值，它和stok值一起供serv端联合认证。
2.luci程序流程 前面已经说明了，luci作为web服务器的cgi程序，是通过execl函数替换到进程空间的，并且详细说明了它与其它进程的交互方法。另外上一节给出了初始阶段http报文，可以看到从第2次交互开始，所有request都是cgi方式（除一些css、js等resource文件外），且执行的cgi程序都是luci，只是带的参数不同，且即使所带参数相同（如都是'/'），由于需要认证，执行的过程也是不同的。
正是由于多种情况的存在，使得luci中需要多个判断分支，代码多少看起来有点乱，但openwrt还是把这些分支都糅合在了一个流程线中。下面首先给出整体流程，首先介绍一下lua语言中一个执行方式coroutine，它可以创造出另一个执行体，但却没有并行性，如下图所示，每一时刻只有一个执行体在执行，通过resume、yield来传递数据，且数据可以是任意类型，任意多个的。
Luci正是利用了这种方式，它首先执行的是running()函数，其中create出另一个执行体httpdispatch，每次httpdispatch执行yield返回一些数据时，running()函数就读取这些数据，做相应处理，然后再次执行resume(httpdispath)，……如此直到httpdispatch执行完毕，如下图所示：
如上图所示，其实luci真正的主体部分正是dispatch，该函数中有多个判断分支，全部糅合在一起，代码比较烦，总体上有4个部分，下面对它们进行一些描述。
首先说明一下代码组成，在openwrt文件系统中，lua语言的代码不要编译，类似一种脚本语言被执行，还有一些uhttpd服务器的主目录，它们是：
/www/index.html
/cgi-bin/luci
/luci-static/xxx/xx.css、js、gif
/usr/lib/lua/nixio.so、uci.so
/luci/http.lua、dispatcher.lua、core…
/controller/xxx.lua
/model/xxx.lua
/view/xxx.lua
2.1节点树node-tree 在controller目录下，每个.lua文件中，都有一个index()函数，其中主要调用entry()函数，形如entry(path,target,title,order)，path形如{admin,network,wireless}，entry()函数根据这些创建一个node，并把它放在全局node-tree的相应位置，后面的参数都是该node的属性，还可以有其他的参数。其中最重要的就是target。
Createtree()函数就是要找到controller目录下所有的.lua文件，并找到其中的index()函数执行，从而生成一个node-tree。这样做的io操作太多，为了效率，第一次执行后，把生成的node-tree放在/tmp/treecache文件中，以后只要没有更新（一般情况下，服务器里的.lua文件是不会变的），直接读该文件即可。生成的node-tree如下：
转存失败重新上传取消
这里要注意的是，每次dispatch()会根据path_info逐层索引，且每一层都把找到的节点信息放在一个变量track中，这样做使得上层node的信息会影响下层node，而下层node的信息又会覆盖上层node。比如{/admin/system}，最后的auto=false，target=aa，而由于admin有sysauth值，它会遗传给它的子节点，也即所有admin下的节点都需要认证。
2.2target简介 对每个节点，最重要的属性当然是target，这也是dispatch()流程最后要执行的方法。target主要有：alise、firstchild、call、cbi、form、template。这几个总体上可以分成两类，前两种主要用于链接其它node，后一个则是主要的操作、以及页面生成。下面分别描述。
链接方法：在介绍初始登录流程时，已经讲到了这种方法。比如初始登录时，url中的path_info仅为'/'，这应该会索引到rootnode节点。而该节点本身是没有内容显示的，所以它用alias('admin')方法，自动链接到admin节点。再比如，admin节点本身也没有内容显示，它用firstchild()方法，自动链接到它的第一个子节点/admin/status。
操作方法：这种方法一般用于一个路径的叶节点leaf，它们会去执行相应的操作，如修改interface参数等，并且动态生成页面html文件，传递给client。这里实际上是利用了所谓的MVC架构，这在后面再描述，这里主要描述luci怎么把生成的html发送给client端。
Call、cbi、form、template这几种方法，执行的原理各不相同，但最终都会生成完整的http-response报文（包括html文件），并调用luci.template.render()，luci.http.redirect()等函数，它们会调用几个特殊的函数，把报文内容返回给luci.running()流程。
转存失败重新上传取消
如上图所示，再联系luci.running()流程，就很容易看出，生成的完整的http-response报文会通过io.write()写在stdout上，而uhttpd架构已决定了，这些数据将传递给父进程，并通过tcp连接返回给client端。
3.sysauth用户认证 2.1节已描述了，由于节点是由上而下逐层索引的，所以只要一个节点有sysauth值，那么它所有的子节点都需要认证。不难想象，/admin节点有sysauth值，它以下的所有子节点都是需要认证才能查看、操作的；/mini节点没有sysauth值，那么它以下的所有子节点都不需要认证。
luci中关于登陆密码，用到的几个函数为：
可以看出它的密码是用的linux的密码，而openwrt的精简内核没有实现多用户机制，只有一个root用户，且开机时自动以root用户登录。要实现多用户，必须在web层面上，实现另外一套（user、passwd）系统。
另外，认证后，serv端会发给client一个session值，且它要一直以cookie的形式存在于request报文中，供serv端来识别用户。这是web服务器的一般做法，这里就不多讲了。
4.MVC界面生成 这其实是luci的精华所在，第二节开始介绍/usr/lib/lua/luci/下有三个目录model、view、controller，它们对应M、V、C。第2.2节介绍了生成的界面怎么传递给client，下面简单介绍生成界面的方法。
Call()方法会调用controller里的函数，主要通过openwrt系统的uci、network、inconfig等工具对系统进行设置，如果需要还会生成新界面。动态生成界面的方法有两种，一是通过cbi()/form()方法，它们利用model中定义的模板map，生成html文件；另一种是通过template()方法，利用view中定义的htm（一种类似html的文件），直接生成界面。
上面的标题是由node-tree生成的，下面的内容由每个node通过上面的方法来动态生成。这套系统是很复杂的，但只要定义好了，使用起来就非常方法，增加页面，修改页面某个内容等操作都非常简单
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae2a3c76ea1b70f24a1365d36b8e43c6/" rel="bookmark">
			better-scroll.js文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 better-scroll介绍better-scroll 是什么起步滚动原理better-scroll 在 MVVM 框架的应用 安装NPMscript 加载 选项 / 基础startXstartYscrollXscrollYfreeScrolldirectionLockThresholdeventPassthroughclickdblclick(v1.12.0+)tapbouncebounceTimemomentummomentumLimitTimemomentumLimitDistanceswipeTimeswipeBounceTimedecelerationflickLimitTimeflickLimitDistanceresizePollingprobeTypepreventDefaultpreventDefaultExceptionHWCompositinguseTransitionuseTransformbindToWrapperdisableMousedisableTouchobserveDOM(v1.5.3+)autoBlur(v1.7.0+)stopPropagation(v1.9.0+) 选项 / 高级wheelsnapscrollbarpullDownRefreshpullUpLoadmouseWheel(v1.8.0+)zoom(v1.11.0+)infinity(v1.12.0+) 方法 / 通用refresh()scrollTo(x, y, time, easing)scrollBy(x, y, time, easing)scrollToElement(el, time, offsetX, offsetY, easing)stop()enable()disable()destroy()on(type, fn, context)once(type, fn, context)off(type, fn) 方法 / 定制goToPage(x, y, time, easing)next(time, easing)prev(time, easing)getCurrentPage()wheelTo(index)getSelectedIndex()finishPullDown()openPullDown(config) (v1.9.0+)closePullDown() (v1.9.0+)autoPullDownRefresh() (v1.14.0)finishPullUp()openPullUp(config) (v1.9.0+)closePullUp() (v1.9.0+)zoomTo(scale, x, y) (v1.12.0+) 事件beforeScrollStartscrollStartscrollscrollCancelscrollEndtouchEndflickrefreshdestroypullingDownpullingUpzoomStartzoomEnd 属性xymaxScrollXmaxScrollYmovingDirectionXmovingDirectionYdirectionXdirectionYenabledisInTransitionisAnimating better-scroll 介绍 better-scroll 是什么 better-scroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。
better-scroll 是基于原生 JS 实现的，不依赖任何框架。它编译后的代码大小是 63kb，压缩后是 35kb，gzip 后仅有 9kb，是一款非常轻量的 JS lib。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae2a3c76ea1b70f24a1365d36b8e43c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fadbf12a45deefc060e13ca182cbb122/" rel="bookmark">
			数位统计DP-计数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定两个整数 a 和 b，求 a 和 b 之间的所有数字中0~9的出现次数。例如，a=1024，b=1032，则 a 和 b 之间共有9个数如下：
1024 1025 1026 1027 1028 1029 1030 1031 1032 其中‘0’出现10次，‘1’出现10次，‘2’出现7次，‘3’出现3次等等…
思路：
暴力做法：出现几个1就统计几次，时间复杂度是10^8*8
优化做法：分情况讨论，可以转化为求1～n中x出现的次数，然后求一个前缀的答案，然后两个相减。
以x = 1为例，看看怎么求：
没怎么听懂后面再补
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e539a4f66aa565664a2a3d0dae8e91df/" rel="bookmark">
			PTA   7-4 列出叶结点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 对于给定的二叉树，本题要求你按从上到下、从左到右的顺序输出其所有叶节点。
输入格式： 首先第一行给出一个正整数 N（≤10），为树中结点总数。树中的结点从 0 到 N−1 编号。随后 N 行，每行给出一个对应结点左右孩子的编号。如果某个孩子不存在，则在对应位置给出 “-”。编号间以 1 个空格分隔。
输出格式： 在一行中按规定顺序输出叶节点的编号。编号间以 1 个空格分隔，行首尾不得有多余空格。
输入样例： 8 1 - - - 0 - 2 7 - - - - 5 - 4 6 输出样例： 4 1 5 思路分析 先找到父节点，父节点一定不是任何节点的子节点。找到父节点后，根据他的左右子树创建树。
设计一个结构体，可以存当前节点和左右节点。任何定义一个结构体数组，当找到根节点后，递归传入左右子树根的下标和数组即可。
源代码 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct Node *node; struct Node {//储存输入数据，并找到父节点 int on; int left; int right; }; typedef struct Snode *Tree; struct Snode{//树 int data; Tree Left; Tree Right; }; int flag=1;//判断输出时第一个字母不带空格 Tree buidTree(int rot,node nod[]); void myprint(Tree t); int main(){ int n,j=0,num[14]={0}; node tr[14]; char ch; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e539a4f66aa565664a2a3d0dae8e91df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de98d2882efb0cfcd64d8a93a97962f9/" rel="bookmark">
			simulink仿真技术简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Simulink是MATLAB的重要组成部分，可以用于建模，仿真等。可以将理论研究和实践有机的相结合，并且不用书写大量的代码。
Simulink简介
Simulink是MATLAB的一个扩展，它提供了一个集动态系统建模，设置不同的仿真数据等功能的一个软件包。并且simulink提供了大量的模块库，基本可以满足用户的需求，用户可以利用这些提供的模块库很方便的完成仿真模型的建立，并不用了解这些模块内部的结构设置。
Simulink特点
Simulink建模三个特点
可视化：simulink仿真采用交互式开发的方法，操作简单、直观、用户只需要拖拽鼠标即可实现动态系统的仿真。图形化的界面可以避免过多的编程，同时又可以直观的反映仿真的过程。扩展性强：simulink有较强的扩展性，用户可以根据自己的需求来编写自己的模块库，建立子系统，封装子系统。灵活性强：simulink是一个非常灵活的仿真建模工具，虽然MATLAB为用户提供封装了大量的模块，但是用户在使用的时候也可以修改里面的参数。近年来在各大领域的得到了大量的应用。 simulink模型的主要结构
Simulink Start page窗口
仿真结果可视化
演示模型
子系统图标
Simulink数据类型
Simulink支持MATLAB内置的所有数据类型，绝大多数的模块都默认double的数据类型。
在simulink模型窗口中选择Display——&gt;signal&amp;ports——&gt;port Date Types命令，可以查看信号的数据数据类型和输入输出的数据类型。
Simulink模块库
Simulink模块库提供了各种领域的基本模块，按照实际应用及功能组成若干子库。MATLAB在储存这些子库时都按照功能都分门别类以便查找，每一类就是一个模块库。
模块库种类
Commonly Used Blocks模块库 常用的模块库
Sources模块库，为仿真提供各种信号源
Sinks模块库，为仿真提供输出设备原件
Continuous模块库，为仿真提供连续系统
Discrete模块库，为仿真提供离散元件
Math模块库，提供数学运算功能元件
Function&amp;Tables模块库，自定义函数和线形插值查表模块库
Nonlinear模块库，非连续系统元件
Signals&amp;System模块库，提供用于输入、输出和控制的相关信号及相关处理
Subsystems模块库，各种子系统
子系统的创建
通过子系统的模块创建子系统：打开simulink模块中的Port&amp;Subysystems库，将选中的模块拖到模块文件中
模块的基本操作
·模块的选择
用鼠标拖动模块不动放置在需要的地方
模快的位置的调整
当将一定数量的模块放置工作区后，如果想要调整模块的位置就脱脂该模块放置合适的位置：如图：
可以将图中的模块放置你认为最合适的位置
模块参数设置：
双击模块或在菜单栏中的Disgram-&gt;Block Parameter（块参数）命令就会跳出该对话框，就可以在里面设置参数。
·模块的连接：如图，选中目标模块，按住鼠标左键就会出现连接线，拖住箭头至想要的位置。
仿真实例
演示滤波器中的余弦想好，并将分析图放大5倍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a2d2b5cd1f0b77e2a89263e4f99b4af/" rel="bookmark">
			PTA：使用函数删除字符串中的字符 (10分)（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入一个正整数 repeat (0&lt;repeat&lt;10)，做 repeat 次下列运算：
输入一个字符串 str，再输入一个字符 c，将字符串 str 中出现的所有字符 c 删除。
要求定义并调用函数delchar(str,c), 它的功能是将字符串 str 中出现的所有 c 字符删除，函数形参str的类型是字符指针，形参c的类型是char，函数类型是void。
输入输出示例：括号内为说明，无需输入输出
输入样例:
3 (repeat=3）
happy new year (字符串"happy new year")
a (待删除的字符’a’)
bee (字符串"bee")
e (待删除的字符’e’)
111211 (字符串"111211")
1 (待删除的字符’1’)
输出样例:
result: hppy new yer (字符串"happy new year"中的字符’a’都被删除)
result: b (字符串"bee"中的字符’e’都被删除)
result: 2 (字符串"111211"中的字符’1’都被删除)
#include &lt;stdio.h&gt; void delchar(char *str, char c); int main() { int i, j, repeat; char c, s[100]; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a2d2b5cd1f0b77e2a89263e4f99b4af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee702e291635c6478d90ef563d8cb7e/" rel="bookmark">
			解决hash冲突的三个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。下面以创建哈希表为例，说明解决冲突的方法。常用的解决冲突方法有以下四种：
1 开放定址法 这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：
Hi=（H（key）+di）% m i=1，2，…，n
其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：
1.1 线性探测再散列 dii=1，2，3，…，m-1
这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。
1.2 二次探测再散列 di=12，-12，22，-22，…，k2，-k2 ( k&lt;=m/2 )
这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。
1.3 伪随机探测再散列 di=伪随机数序列。
具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。
例如，已知哈希表长度m=11，哈希函数为：H（key）= key % 11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。
如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。
如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。
如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee702e291635c6478d90ef563d8cb7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0648c2b495bbb05420f33bb10d6b9c/" rel="bookmark">
			STM32开发，使用HAL库函数实现按键（中断和普通扫描）控制LED灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32开发，使用HAL库函数实现按键控制LED灯 1 概述1.1 资源概述1.2 引脚资源分配1.3 中断概述1.4 实现功能 2 软件开发,使用中断的方式2.1 CUBEMX配置2.2 程序代码 3 使用两次检测电平的方式4 实现结果 1 概述 1.1 资源概述 开发板：ST官方NUCLEO-F103RB开发板
CUBEMX版本：1.3.0
MDK版本：5.23
主控芯片型号：STM32F103RBT6
1.2 引脚资源分配 序号引脚资源备注1PA13SWDIOSWD输入输出信号2PA14SWDCLKSWD时钟信号3PC13BUTTON用户按键配置为中断4PA5LED2指示灯 1.3 中断概述 外部中断/事件控制器框图
优先级分组可以设置为5种方式。分别是1个抢占优先级/16个子优先级到16个抢占优先级/1个子优先级。
1.4 实现功能 实现功能：
1、上电初始化后，LED2灯亮。
2、若按键被按下，触发外部中断，则将LED2灯状态翻转。
2 软件开发,使用中断的方式 2.1 CUBEMX配置 Button部分原理图如下，PC13为低输入有效。电路中与按键并联的100nF是按键消抖用，使用正点原子的开发板没有此电容，会出现按一次，LED灯亮灭各一次的现象，说明抖动了，执行了两次中断。
PC13配置为中断模式，下降沿触发，上拉。
中断分组设置，采用默认设置，抢占优先级0，子优先级0。
中断优先级说明，线10到线15使用同一个中断优先级，PC13对应的是线13。
位置优先级优先级类型名称说明地址4047可设置EXTI15_10EXTI线[15:10]中断0x0000_00E0 2.2 程序代码 生成程序代码，系统自动对LED2和Button进行了初始化，并对Button对应的中断进行了分组和使能。
void MX_GPIO_Init(void) { GPIO_InitTypeDef GPIO_InitStruct = {0}; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET); /*Configure GPIO pin : PtPin */ GPIO_InitStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0648c2b495bbb05420f33bb10d6b9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa99bbfab72a6038431e93bebc440497/" rel="bookmark">
			Qt实现自动补充功能的QLineEdit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、非使用QCompleter版
-------------------------------------CompleteLineEdit.h-------------------------------------
#ifndef COMPLETELINEEDIT_H
#define COMPLETELINEEDIT_H
#include &lt;QtGui/QLineEdit&gt;
#include class QListView;
class QStringListModel;
class QModelIndex;
class CompleteLineEdit : public QLineEdit {
Q_OBJECT
public:
CompleteLineEdit(QStringList words, QWidget *parent = 0);
public slots:
void setCompleter(const QString &amp;text); // 动态的显示完成列表
void completeText(const QModelIndex &amp;index);
// 点击完成列表中的项，使用此项自动完成输入的单词
protected:
virtual void keyPressEvent(QKeyEvent *e);
virtual void focusOutEvent(QFocusEvent *e);
private:
QStringList words; // 整个完成列表的单词
QListView *listView; // 完成列表
QStringListModel *model; // 完成列表的model
};
#endif // COMPLETELINEEDIT_H
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa99bbfab72a6038431e93bebc440497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/733cdcb15f2204ce64df495104119fb3/" rel="bookmark">
			感叹号：Invalid location of tag
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Invalid location of tag (form) form 应该写到table外面去，并且form标签里面也不能套form标签。form标签被嵌套进了span等块级元素里，form标签只能嵌套进入div等行级元素中，放进块元素会报invalid。 Invalid location of tag (style)
style应该写在head里面。Invalid location of tag (script)
script应该写到body或者head里面。Attribute name(Name) uses wrong case character
大写报错，改成小写。Invalid location of tag (div)
div的标签使用不当，需要更换为标签 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f04b9c833bc34ba756c896a1d68aafb/" rel="bookmark">
			Dubbo支持哪些协议，每种协议的应用场景，优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dubbo： 单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步，Hessian序列化；rmi： 采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。
多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞；webservice： 基于WebService的远程调用协议，集成CXF实现，提供和原生WebService的互操作。多个短连接，基于HTTP传输，同步传输，适用系统集成和跨语言调用；http： 基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用；hessian： 集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；memcache： 基于memcached实现的RPC协议redis： 基于redis实现的RPC协议 默认使用dubbo协议
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d7625ef92f253e03824542ff19ee1a/" rel="bookmark">
			SpringBoot实现微信小程序登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、登录流程二、后端实现1、SpringBoot项目结构树2、实现auth.code2Session 接口的封装3、建立用户信息表及用户增删改查的管理4、实现登录认证及令牌生成 三、前端实现与测试1、编写登录公共函数2、搭建登录页面3、登录测试 一、登录流程 首先参考小程序官方文档中的流程图：
根据流程图描述，主要步骤有以下几步
1、小程序端调用 wx.login()向微信接口服务获取 临时登录凭证code ，并上传至开发者服务端。
2、开发者服务端向微信服务接口服务调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。
3、开发者服务端根据session_key等信息,基于JWT标准，生成自定义的网络令牌token，返回至小程序端存储。
关于SpringBoot实现JWT的具体细节，请参考本人博文：
SpringBoot整合SpringSecurity实现JWT认证
本文将具体对微信小程序的前端与后端实现进行详细描述：
二、后端实现 1、SpringBoot项目结构树 2、实现auth.code2Session 接口的封装 WxMiniApi.java
/** * 微信小程序统一服务端API接口 * @author zhuhuix * @date 2020-04-03 */ public interface WxMiniApi { /** * auth.code2Session * https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html * 请求参数 属性	类型	默认值	必填	说明 * @param appId	string	是	小程序 appId * @param secret	string	是	小程序 appSecret * @param jsCode	string	是	登录时获取的 code * grantType	string	是	授权类型，此处只需填写 authorization_code * 返回值 * @return JSON 数据包 * 属性	类型	说明 * openid	string	用户唯一标识 * session_key	string	会话密钥 * unionid	string	用户在开放平台的唯一标识符，在满足 UnionID 下发条件的情况下会返回，详见 UnionID 机制说明。 * errcode	number	错误码 * errmsg	string	错误信息 * * errcode 的合法值 * * 值	说明	最低版本 * -1	系统繁忙，此时请开发者稍候再试 * 0	请求成功 * 40029	code 无效 * 45011	频率限制，每个用户每分钟100次 */ JSONObject authCode2Session(String appId,String secret,String jsCode); } WxMiniApiImpl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91d7625ef92f253e03824542ff19ee1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d74f85173ec4900a6fae91a0b54f35/" rel="bookmark">
			python 去除所有的中文 英文标点符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去除英文标点符号 python的string模块下的 punctuation 包含所有的英文标点符号，所以用replace()一下就可以去除。
代码示例：
import string stri = 'today is friday, so happy..!!!' punctuation_string = string.punctuation print("所有的英文标点符号：", punctuation_string) for i in punctuation_string: stri = stri.replace(i, '') print(stri) 结果：
所有的英文标点符号： !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~ today is friday so happy 注意：
string.punctuation中的标点符号只有英文
去除中文标点符号： 如果是中文文本，可以调用zhon包的zhon.hanzi.punctuation函数即可得到中文的标点符号集合。
代码示例：
from zhon.hanzi import punctuation str = '今天周五，下班了，好开心呀！！' punctuation_str = punctuation print("中文标点符合：", punctuation_str) for i in punctuation: str = str.replace(i, '') print(str) 结果：
中文标点符合： ＂＃＄％＆＇（）＊＋，－／：；＜＝＞＠［＼］＾＿｀｛｜｝～｟｠｢｣､　、〃〈〉《》「」『』【】〔〕〖〗〘〙〚〛〜〝〞〟〰〾〿–—‘’‛“”„‟…‧﹏﹑﹔·！？｡。 今天周五下班了好开心呀 参考博客：python之去除文本标点符号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc27e017680a62d88d49620373d85af/" rel="bookmark">
			Scrapy爬虫小技巧02：HTTP status code is not handled or not allowed的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在scrapy爬虫的过程中出现 HTTP status code is not handled or not allowed 的问题导致爬虫无法继续，如下截图：
解决方式：
在settings.py文件中添加： HTTPERROR_ALLOWED_CODES = [302]
截图中报错302，就在括号里添加302。若报错403就添加403。 附加说明：
scrapy框架中有许多默认设置可参阅：scrapy的settings设置（一） 相关笔记：
Python相关实用技巧01：安装Python库超实用方法，轻松告别失败！Python相关实用技巧02：Python2和Python3的区别Python相关实用技巧03：14个对数据科学最有用的Python库Python相关实用技巧04：网络爬虫之Scrapy框架及案例分析Python相关实用技巧05：yield关键字的使用Scrapy爬虫小技巧01：轻松获取cookiesScrapy爬虫小技巧02：HTTP status code is not handled or not allowed的解决方法数据分析学习总结笔记01：情感分析数据分析学习总结笔记02：聚类分析及其R语言实现数据分析学习总结笔记03：数据降维经典方法数据分析学习总结笔记04：异常值处理数据分析学习总结笔记05：缺失值分析及处理数据分析学习总结笔记06：T检验的原理和步骤数据分析学习总结笔记07：方差分析数据分析学习总结笔记07：回归分析概述数据分析学习总结笔记08：数据分类典型方法及其R语言实现数据分析学习总结笔记09：文本分析数据分析学习总结笔记10：网络分析 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3ba71da4b2af1b2b95f799ca7c8dde/" rel="bookmark">
			React 入门 02 - JSX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在 React 入门 01 - Hello World中，简单了解了下React基本概念以及如何运用到Html中。现在我们学习一下在React中配合使用最多的JSX相关知识。
JSX JSX，是一个 JavaScript 的语法扩展。比如如下行语句，它既不是单纯Html语句也不是普通Java Script。JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式，在React中配合使用非常流行。
const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; JSX 嵌入变量、函数表达式 我们可以声明基本变量、数组，然后在JSX中使用它。
var users = ['Ria', 'Ming']; var arr = ['Let\'s start to learn React!'] ReactDOM.render( &lt;div&gt; { users.map(function(user) { return &lt;div&gt;&lt;h1&gt;Hello, {user}! &lt;/h1&gt;&lt;/div&gt; }) } &lt;div&gt;&lt;h2&gt;{arr}&lt;/h2&gt;&lt;/div&gt; &lt;/div&gt;, document.getElementById('root') ); variable.html Git Hub 🔗
👆上面例子是在JSX中应用变量，同理可以声明函数表达式并完成调用。
function formatName(user) { return user.firstName + ' ' + user.lastName; } const user = { firstName: 'Ria', lastName: 'Yang' }; const element = ( &lt;h1&gt; Hello, {formatName(user)}!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f3ba71da4b2af1b2b95f799ca7c8dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a985877e103be75ef4b84db2ee4aeb3c/" rel="bookmark">
			Numpy（Python）创建数组方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Numpy（Python）创建数组方式 首先我们要知道为什么要使用numpy。
python是一门高级汇编语言，标准的Python中用列表(list)保存一组值，可以当作数组使用。但由于列表的元素可以是任何对象，因此列表中保存的是对象的指针。对于数值运算来说，这种结构显然比较浪费内存和CPU计算。
为了节省计算时间和节省内存空间，我们可以使用Numpy来弥补其中不足。
（小技巧：键盘Home键可以让光标移动到本行最左，而End键可以让光标移动到末尾，先用Home将光标移动到左侧，再按住Shift+End即可圈选本行）
先按照习惯导入numpy import numpy as np 输入“np.array()” 可以通过给array函数传递Python的序列对象创建数组，如果传递的是多层嵌套的序列，将创建多维数组(下例中的变量c): &gt;&gt;&gt; a = np.array([1, 2, 3, 4]) &gt;&gt;&gt; b = np.array((5, 6, 7, 8)) &gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[4, 5, 6, 7], [7, 8, 9, 10]]) &gt;&gt;&gt; b array([5, 6, 7, 8]) &gt;&gt;&gt; c array([[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10]]) &gt;&gt;&gt; c.dtype #数组的元素类型可以通过dtype 属性获得 dtype('int32') 数组的大小可以通过其shape属性获得： &gt;&gt;&gt; a.shape #一维数组 (4L,) &gt;&gt;&gt; c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a985877e103be75ef4b84db2ee4aeb3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a789e7367f8358bab9043a52fcb27d3e/" rel="bookmark">
			lucene和Elasticsearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lucene和Elasticsearch 一.全文检索1.什么是全文检索1.1 数据分类1.2 什么是全文检索 二.lucene2.1 如何使用lucene2.2 索引和搜索流程图2.3 使用2.3.1 LuceneDemo2.3.2 分词器 三.Elasticsearch3.1 Elasticsearch3.1.1 安装3.1.2 修改配置文件3.1.3 访问 3.2 Kibana3.2.1 什么是Kibana3.2.2 安装3.2.3 配置运行 3.2 使用kibana对索引库操作3.3 操作索引库3.4 使用kibana对类型及映射操作3.4.1 创建字段映射3.4.2 映射属性详解1）type2）index3）store4）boost 3.5 使用kibana对文档操作3.5.1 新增文档3.5.2 常用命令3.5.3 自定义模板 3.6 查询3.6.1 词条匹配(term)3.6.2 匹配查询（match）3.6.3 查询所有（match_all)3.6.4 模糊查询(fuzzy)3.6.5 范围查询(range)3.6.6 布尔组合（bool) 3.7 分页，过滤，排序，高亮3.7.1 分页3.7.2 排序3.7.3 过滤结果过滤 - 指定includes和excludes过滤(filter) 3.7.4 高亮 3.8 聚合aggregations3.8.1 桶（bucket ) 类似于 group by3.8.2 度量（metrics）相当于聚合的结果 四.Elasticsearch集群4.1 数据分片和数据备份4.2 搭建集群4.3 测试集群中创建索引库 五.Elasticsearch客户端5.1索引数据操作5.1.1 初始化客户端5.1.2 新增文档5.1.3 修改文档5.14 删除文档5.1.5 查看文档5.1.6 批量新增 5.2 操作5.2.1 查询5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a789e7367f8358bab9043a52fcb27d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8c60efcf9b18233d55906a9b5fbf52/" rel="bookmark">
			二十三.Python学习笔记.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合数据类型
一.集合类型及操作
1.集合是多个 元素的无序组合
-集合类型与数学中的集合概念一致
-集合元素之间无序，每个元素唯一，不存在相同元素
-集合元素不可更改，不能是可变数据类型
2.集合是多个元素的无序组合
-集合用大括号{}表示，元素间用逗号分隔
-建立集合类型用{} 或 set()
-建立空集类型，必须使用set()
3.集合间的操作
4.集合的操作符
操作符及应用描述S竖线T返回一个 新集合，包括集合S和T中的所有元素S-T返回一个新集合，包括在集合S但不在T中的元素S&amp;T返回一个新集合，包括同时在集合S和T中的元素S^T返回一个新集合，包括集合S和T中的非相同的元素S&lt;=T或S&lt;T返回True/False,判断S和T的子集关系S&gt;=T或S&gt;T返回True/False,判断S和T的包含关系 增强操作符
操作符及应用描述S竖线=T更新集合S，包括在集合S和T中的所有元素S-=T更新集合S，包括在集合S但不在T中的元素S&amp;=T更新集合S，包括同时在集合S和T中的元素S^=T更新集合S，包括集合S和T中的非相同元素 二.集合的处理方法
1.
操作函数或方法描述S.add(x)如果x不在集合S中，将x增加到SS.discard(x)移除S中元素x，如果x不在集合S中，不报错S.remove(x)移除S中元素x，如果x不在集合中，产生KeyError异常S.clear()移除S中的所有元素S.pop随机返回S的一个元素，更新S，若S为空产生KeyError异常S.copy()返回集合S的一个副本len(S)返回集合S的元素个数x in S判断S中元素x，x在集合S中，返回True,否则返回Falsex not in S判断S中元素x，x不在集合S中，返回True，否则返回Falseset(x)将其他类型变量x转变为集合类型 2.集合类型处理场景
三.序列类型及操作
1.序列类型定义
序列是具有先后关系的一组元素
-序列是一维元素向量，元素类型可以不同
-类似数学元素序列：s0,s1,……sn-1
-元素间由序号引导，通过下标访问序列的特定元素
2.序列类型同用操作符
6个操作符
操作符及应用描述x in s如果x是序列s的元素，返回True，否则返回Falsex not in s如果x是序列s的元素，返回False,否则返回Trues + t连接两个序列s和ts* n或·n*s将序列s复制n次s[i]索引，返回s中的第i个元素，i是序列的序号s[i: j]或s[i :j :k]切片，返回序列s中第 i 到 j 以 k 为步长的元素子序列 3.序列类型通用函数和方法
5个函数和方法
函数和方法描述len(s)返回序列s的长度min(s)返回序列s的最小元素，s中的元素需要可比较max(s)返回序列s的最大元素，s中元素需要可比较s.index(x)或s.index(x,i,j)返回序列s从i开始到j位置中第一次出现元素x的位置s.count(x)返回序列s中出现x的总次数 四.元祖类型及操作
1.元祖的定义：
元祖是序列类型的一种扩展
-元祖是一种序列类型，一旦创建就不能修改
-使用小括号()或tuple()创建，元素间用逗号,分隔
-可以使用或不使用小括号
2.元祖类型操作
元祖继承序列类型的全部通用操作
-元祖继承了序列类型的全部通用操作
-元祖因为创建后不能修改，因此没有特殊操作
-使用或不使用小括号
五.列表类型及操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e8c60efcf9b18233d55906a9b5fbf52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac0ac8a9fdfc3f0f31c0a184b2a4cf49/" rel="bookmark">
			安装 logstash 和 logstash-input-jdbc 实现数据同步到 es（高版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载es 安装 省略… 我这里安装的是7.5.0 一 安装logstash
下载安装（后面可以改成不同的版本）
wget https://artifacts.elastic.co/downloads/logstash/logstash-7.5.0.zip 下载完之后 解压
unzip logstash-7.5.0.zip 进入 bin 目录下面执行
./logstash -e "" 等会出现seccessfullt 输入hello
看到这个就成功了
二、安装logstash-input-jdbc插件
如果没有安装 gem 的话 安装gem
sudo yum install gem 替换源 原来淘宝的gem源已经停止维护，现在由ruby-china提供镜像服务
gem source -a https://gems.ruby-china.com 安装完以后，输入以下命令查看是否替换成功
gem sources -l 如果看到的不止一个源 那你需要删掉一个
sudo vim ~/.gemrc 手动删除 https://rubygems.org/
如果结果是这样 那就可以了
*** CURRENT SOURCES *** https://gems.ruby-china.com 修改Gemfile的数据源地址。步骤：
whereis logstash # 查看logstash安装的位置， sudo vi Gemfile # 修改 source 的值 为： "https://gems.ruby-china.com" sudo vi Gemfile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac0ac8a9fdfc3f0f31c0a184b2a4cf49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5c25b7e790005c518436b662244170/" rel="bookmark">
			访问http如何自动转换为https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 例子Status Code: 307 Internal RedirectHSTS 一般情况下我们在浏览器中访问一个网站都是以http形式访问的。但是一些网站，比如购物网站由于需要支付，所以需要使用到更加安全的https的访问方式。 那么服务器是怎么让浏览器实现自动转换为访问https的呢？ 例子 在浏览器输入http://www.taobao.com，并且按F12查看服务器给我们发来了什么消息
注意上面我用红色方框圈出的地方，后面我会讲到。
接着，我们直接访问https://www.taobao.com会怎么样呢？
仔细对比两张图的红色方框部分，可以看出，访问http比https多了两个文件（响应头），其中第一个文件最重要，就是因为这个文件，告诉浏览器应该以https重新访问网站。
第一种图右边有两个方框，主要就是这两个信息Status Code: 307 Internal Redirect和Non-Authoritative-Reason: HSTS，接下来就说下这两个信息是什么信息.
Status Code: 307 Internal Redirect 状态代码：307，交互重定向。其实也不一定是307，有些网站是302。
3xx状态码就是告诉客户端，请求的URI不存在，需要去访问另外一个URI。
HSTS HSTS（HTTP Strict Transport Security）国际互联网工程组织IETF正在推行一种新的Web安全协议。
HSTS最为核心的是一个HTTP响应头（HTTP Response Header）。正是它可以让浏览器得知，在接下来的一段时间内，当前域名只能通过HTTPS进行访问，并且在浏览器发现当前连接不安全的情况下，强制拒绝用户的后续访问要求。
HSTS Header的语法如下：
Strict-Transport-Security: &lt;max-age=&gt;[; includeSubDomains][; preload] max-age是必选参数，是一个以秒为单位的数值，它代表着HSTS Header的过期时间，通常设置为1年，即31536000秒。includeSubDomains是可选参数，如果包含它，则意味着当前域名及其子域名均开启HSTS保护。preload是可选参数，只有当你申请将自己的域名加入到浏览器内置列表的时候才需要使用到它。关于浏览器内置列表，下文有详细介绍。 比如上面的网站中：
有了这个就是告诉浏览器接下来的31536000s中，使用https访问网站。
完整的HSTS流程图如下：
撩我？可以搜索我的公众号：Kyda
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c831d16d01881fb1fda1a43c6420d719/" rel="bookmark">
			1.Spring Boot&amp;Spring Cloud介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.Spring Boot的概述
Spring Boot是基于Spring的简化级框架，所谓的简化就是简化了Spring的一系列配置，我们可以从以下几方面来概述 1.Spring Boot简化了其他框架与Spring的集成，我们只需要Maven/Gradle中引入spring-boot-starter-xxx即可完成集成 2.习惯优于配置（例如SpringLectureApplication的启动类要位于最外层的包下，默认扫描就是扫描基于此类的所有同级包） 3.内嵌tomcat/Jetty，可打包为jar独立运行，无需配置部署tomcat Spring Boot的学习重点，熟悉其启动流程，了解其工作原理
后续Spring Boot的分析会着重分析其启动流程 2.Spring Cloud的概述
Spring Cloud是一个基于Spring Boot实现的云原生应用开发工具，它为基于JVM的云原生应用开发中涉及的 配置管理、服务发现、熔断器、智能路由、微代理、控制总线、分布式会话和集群状态管理等操作提供了一种简单的开发方式。 在具体开发中我们可以根据应用的实际需求来拔插式的使用SpringCloud中的组件。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e2276acf98dcfb48c48769ef5b9371/" rel="bookmark">
			uniapp组件出现undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先检查脚本（也就是&lt;script&gt;标签）内的数据名以及数据函数位置有没有语法错误
最重要的坑就是：每次写完必须重启小程序，注意不是重新编译！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700702e589df44c8cfa6b02048257b52/" rel="bookmark">
			达梦数据对象创建语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动作语句非空约束CREATE TABLE TEST_SCHEMA.NOT_Persons(ID int NOT NULL,Name varchar(255) NOT NULL);
insert into TEST_SCHEMA.NOT_Persons values(1,‘古天乐’);
insert into TEST_SCHEMA.NOT_Persons values(1,‘冯小刚’);
commit唯一约束CREATE TABLE TEST_SCHEMA.PK_Persons
(Id_P int,Name varchar(255),Address varchar(255),CONSTRAINT PK_ID_P UNIQUE (Id_P));
insert into TEST_SCHEMA.PK_Persons(1,‘徐帆’,‘黑龙江省佳木斯市’);
insert into TEST_SCHEMA.PK_Persons(2,‘杨过’,‘辽宁省生沈阳市’);
commit主键约束CREATE TABLE TEST_SCHEMA.TABLE_PRI(ID NUMBER ,USERNAME VARCHAR(16),LOCATION VARCHAR(30),CONSTRAINT PK_USERNAME PRIMARY KEY (“USERNAME”));
INSERT INTO TEST_SCHEMA.TABLE_PRI VALUES (1, ‘李亚鹏’,‘黑龙江省佳木斯市’);
commit外键约束CREATE TABLE TEST_SCHEMA.TABLE_FOR(USERNAME VARCHAR(16),ID_CARD VARCHAR(25),CONSTRAINT FK_USERNAME FOREIGN KEY REFERENCES primary_key(USERNAME));
INSERT INTO TEST_SCHEMA.TABLE_FOR VALUES (‘李亚鹏’,‘142232199211182197’);
commitcheck约束create table TEST_SCHEMA.CHECK_TABLE(ID number,NAME varchar2(20),SEX varchar2(4),CONSTRAINT check_sex CHECK (sex in (‘男’,‘女’)));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700702e589df44c8cfa6b02048257b52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f83989d2ff0269642b7ad069b52917/" rel="bookmark">
			iOS OC 对象原理探索一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS OC 对象原理探索一 alloc源码探索思路探索方法alloc源码分析init函数源码分析new方法源码 alloc源码探索思路 iOS中 alloc是怎么创建对象的？init做了什么？ 下面研究探索一下alloc底层实现
探索方法 方法一：
直接代码下断点 ：通过control + in - objc_alloc 找到 libobjc.A.dylib
方法二：
符号断点： libobjc.A.dylib+[NSObject alloc]: 符号断点添加如下图：
方法三：
通过汇编查看，
alloc源码分析 接下来我们来分析一下alloc源码，流程如下：
从上图源码分析中我们可以看出，alloc主要是申请开辟内存，并初始化了一个isa属性，那么我们看下面代码：
LGTeacher *p = [LGTeacher alloc]; NSLog(@"%lu - %lu",class_getInstanceSize([p class]),malloc_size((__bridge const void *)(p))); 打印结果如下：
那么为什么同一个类，会出现两个不同的打印结果呢？
源码分析如下：
分析得知class_getInstanceSize([p class]) 相比较于 malloc_size((__bridge const void *)(p)))少了一步if(size &lt; 16) size = 16的判断，源码如下：
size_t instanceSize(size_t extraBytes) { size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2f83989d2ff0269642b7ad069b52917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f76b9d8aa7a7fe8142dc5ca4adf46ce/" rel="bookmark">
			js小数的取舍处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.丢弃小数部分,保留整数部分 parseInt(7/3) 2.向上取整,有小数就整数部分加1 Math.ceil(5/2) 3,四舍五入 方法一： var num =2.446242342; Math.round(num) //输出结果为2 方法二：保留两位小数 num = num.toFixed(2); // 输出结果为 2.45 4,向下取整 Math.floor(5/2) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80dafa0173049435e81a721de3c853e4/" rel="bookmark">
			计算机视觉——相机模型与参数标定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
相机参数标定
一、相机内参矩阵原理
二、相机标定方法——张正友标定法
2.1方法描述
2.2计算内参和外参的初值
三、实验：Matlab实现
3.1实验数据
3.2实验过程
3.3实验结果
四、实验总结
相机参数标定 在拍摄中，相机可能会出现畸变，用软件的方法校正生成的图像，避免拍摄出的图像产生桶形和枕形畸变
不同的镜头的在生产和组装过程中的畸变程度各不相同，通过相机标定可以校正这种镜头畸变，生成矫正后的图像。
一、相机内参矩阵原理 设P=(X,Y,Z)为场景中的一点，在针孔相机模型中，其要经过以下几个变换，最终变为二维图像上的像点p=(μ,ν)
1、将P从世界坐标系通过刚体变换(旋转和平移)变换到相机坐标系，这个变换过程使用的是相机间的相对位姿，也就是相机的外参数。
2、从相机坐标系，通过透视投影变换到相机的成像平面上的像点p=(x,y)
3、将像点p从成像坐标系，通过缩放和平移变换到像素坐标系上点p=(μ,ν)
相机将场景中的三维点变换为图像中的二维点，也就是各个坐标系变换的组合，可将上面的变换过程整理为矩阵相乘的形式
二、相机标定方法——张正友标定法 2.1方法描述 使用棋盘格标定的方法，将照片中的三维信息压缩为二维（Z=0)
在张氏标定法中，用于标定的棋盘格是三维场景中的一个平面Π，其在成像平面的像是另一个平面π，知道了两个平面的对应点的坐标，就可以求解得到两个平面的单应矩阵H。其中，标定的棋盘格是特制的，其角点的坐标是已知的；图像中的角点，可以通过角点提取算法得到（如Harris角点），这样就可以得到棋盘平面Π和图像平面π的单应矩阵H。
方法步骤：
1、检测每张图片中的棋盘图案的角点；
2、利用解析解估算方法计算出5个内部参数，以及6个外部参数
3、通过基于极大似然准则的优化解,提高A，R，t矩阵的精度。
2.2计算内参和外参的初值 1、计算单应性矩阵H
棋盘格平面到图像平面的单应性关系为：
其中s为尺度因子，K为摄像机内参数，R为旋转矩阵，T为平移向量。令
s对于齐次坐标来说，不会改变齐次坐标值。张氏标定法中，将世界坐标系狗仔在棋盘格平面上，令棋盘格平面为Z=0的平面。则可得
我们把K[r1, r2, t]叫做单应性矩阵H，即
2、计算内参数矩阵
3、计算外参数矩阵
三、实验：Matlab实现 3.1实验数据 我准备了共20张的棋盘数据，在电脑上绘制黑白棋盘表格，并通过测量确定每个小正方格的长宽为 2.54厘米 ，然后再使用手机对棋盘进行拍摄，同时具有角度变换和距离变换等设置。
3.2实验过程 3.2.1实验要求
1.制作棋盘格（每个格子的大小可测量），最好是打印出来，贴在平面上（实在不行就用我刚才演示的黑白棋盘格方法）
2.根据棋盘格，采集10-20张图片，提取角点
3.解算出内外参数，内参截图放在博客中，外部参数最好能可视化
3.2.2标定步骤
3.2.3使用MATLAB自带的工具箱进行标定
MATLAB（matlab calibration toolbox-Matlab标定工具箱使用（单目标定和双目标定）
3.3实验结果 IntrinsicMatrix: [3x3 double] 内参矩阵
四、实验总结 1.Harris角点检测能够快速准确的检测到棋盘网格的边角，这对图像位置信息和空间坐标的标定参考提供了重要的数据。
2.在图片的分析当中，并不是所有拍摄的20张图片都被筛选进标定实验，其中很多不符合设置的，例如光线强度过大、角度变换过大等等影响到了角点检测和参数标定的图片都会被剔除，所以在一开始准备数据时就应该添加更多的图片以增加成功率，在本次实验中就被剔除了8张不合格的图片。
3.从最后的实验结果中，可以知道，我的手机相机的各种内部参数和外部参数。由于每部相机的生产过程当中，或多或少的都会产生一定的误差，而且这些误差也让每一部相机变得独一无二，所以每个人的相机参数都不会完全相同。
4.观察每张标定图可以发现，每张图中设置的X,Y和起始点设置都不是完全一样的，它会根据图片的旋转和角度等因素调整坐标系，说明图片的旋转和角度变换不会影响到标定结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c62078be7f56cc3de8d30bb8d41c32/" rel="bookmark">
			mycat 添加数据时报错主键已存在(duplicate entry &#39;22&#39; for key &#39;PRIMARY&#39;)问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端时间项目优化修改，因使用的mycat 分库分表机制，部分库表用到了分库配置，本地测试修改部分正常。但上到服务器上时添加数据会报错主键id已存在，duplicate entry '22' for key 'PRIMARY'。经过一段时间排查分析，确定为经过mycat添加数据时会返回以前已经存在的id，mycat采用的是主键id自增机制，所以导致无法正常添加。mycat配置没有问题，最终定位在本地是用mysql数据连接，使用的是mysql添加数据，服务器使用的是mycat连接，使用的是mycat添加数据。mycat无法识别到mysql增加数据时的自增id，导致mysql的自增id与mycat的自增id不同步。问题原因找到了，那就可以解决这个问题了。修改mycat库中的mycat_sequence表中的对应分库表的最大id值数据，然后重启mycat就正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/620953cfda02d50a1941e791d7b826dd/" rel="bookmark">
			Tensorflow-image classification
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://tensorflow.google.cn/tutorials/images/classification
Import packages import tensorflow as tf from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense, Conv2D, Flatten, Dropout, MaxPooling2D from tensorflow.keras.preprocessing.image import ImageDataGenerator import os import numpy as np import matplotlib.pyplot as plt 数据下载 下载 _URL = 'https://storage.googleapis.com/mledu-datasets/cats_and_dogs_filtered.zip' path_to_zip = tf.keras.utils.get_file('cats_and_dogs.zip', origin=_URL, extract=True) PATH = os.path.join(os.path.dirname(path_to_zip), 'cats_and_dogs_filtered') 导入 train_dir = os.path.join(PATH, 'train') validation_dir = os.path.join(PATH, 'validation') train_cats_dir = os.path.join(train_dir, 'cats') # directory with our training cat pictures train_dogs_dir = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/620953cfda02d50a1941e791d7b826dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a94cbb9e7f4fe16034cbd2cb8d8189/" rel="bookmark">
			在vue项目中使用md5加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍：MD5:信息-摘要算法，是让大容量信息在用数字签名软件签署私人密匙前被"压缩"成一种保密的格式
参考网址
一般我们把登录和注册信息的密码进行加密
1.安装模块
npm install js-md5 -D 2.在项目中引入模块
import md5 from 'js-md5' 3.把你需要加密的信息进行前期处理
CalcuMD5 = function (pwd) { pwd = pwd.toUpperCase(); pwd = md5(pwd); return pwd; } 4.加密你的信息
CalcuMD5（'password'） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/485cbc94cacfcfdd9c0bd9377274b20a/" rel="bookmark">
			浙大版《C语言程序设计（第3版）》题目集 习题8-3 数组循环右移 (20分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt; #define MAXN 10 int ArrayShift(int a[], int n, int m); int main() { int a[MAXN], n, m; int i; scanf("%d %d", &amp;n, &amp;m); for (i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); ArrayShift(a, n, m); for (i = 0; i &lt; n; i++) { if (i != 0) printf(" "); printf("%d", a[i]); } printf("\n"); return 0; } int ArrayShift(int a[], int n, int m) { int i, temp, j; m = m % n; for (i = 0; i &lt; m; i++) { temp = a[n - 1]; for (j = n - 1; j &gt;= 1; j--) { a[j] = a[j - 1]; } a[j] = temp; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b128239e8b4c9271e22aa73e78d7b7f9/" rel="bookmark">
			资源优化断舍离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过学习《整理师：怎样做商业上的断舍离》，理解了西贝在几方面取得了成功：
1、断舍离：通过在菜品、店铺面积、店铺装修几方面断舍离，降低店铺复杂性，搭上中国在中央厨房、供应链、物理等技术发展便车，降低边际成本，实现企业规模化，避免陷入中餐“逆规模化效应”紧箍咒；
2、顺势而为：轻装上阵，西贝的选址可以更靠近热点区域更加灵活性的空间，因地制宜地采用方桌可拆可拼，采用全透明橱窗亮出安全厨房，简化菜品简化供应链精心制作倒计时快速上菜，推出营销口号“闭着眼睛点，道道都好吃”，捕捉到新的创新点与利益点。
同样，对于工作生活，也需要多学习断舍离的精神，我们听过很多关于乔班主、巴神的故事，两位大神在生活中保持简单。乔帮主的卧室只有一张床，将苹果产品线简化，每个产品都打造成极简的精品；巴神一直居住在自己的老房子里、开着老车，投资方法简单老套。从意志力方面分析，断舍离是有一定生理原理基础，意志力不是取之不尽用之不竭的，它像肌肉一样，每次使用都会消耗，用多了需要消耗更多的血糖产生疲惫。因此我们对于工作生活也需要做减法：
1、生活上降低物欲：购买必要的家庭用品、衣物，及时清理不需要使用的物品、衣物，避免消耗过多的精力在生活物质上；
2、工作中集中精力：设定工作目标，将精力投入在产出最高的事情上，根据个人生理特点合理安排作休时间，多使用高效工具分担低效事项，减少不必要会议；
3、学习保持专注：纵向保持学习主线足够专注，横向适当补充通俗教育知识完善知识内涵，删减自己的书库，正所谓书多易堕，多读经典提升元知识体系深度，减少精力分散。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90cfc347151a071f380f1ba400e20633/" rel="bookmark">
			python可视化图表——pyecharts 库 找不到Bar,并且AttributeError: &#39;str&#39; object has no attribute &#39;get&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一下今天遇到的坑:
网站上看到了一个可视化图表的代码
https://www.jianshu.com/p/b718c307a61c
代码可以说是非常的简单，然后就拿到本地运行了一下，就出现了一堆问题：
首先可视化图表的话需要安装pyecharts库，然后导入它的Bar 库
from pyecharts import Bar #from pyecharts.echarts import Bar #from pyecharts.charts.basic_charts import bar (bar.Bar()) attr = ['衬衫','羊毛衫','雪纺衫','裤子','高跟鞋','袜子'] v1 = [5,20,36,10,75,90] v2 = [10,25,8,60,20,80] bar = Bar('X 轴与 Y 轴交换') bar.add('商家A',attr,v1) bar.add('商家B',attr,v2,is_convert = True) # is_convert = True:X 轴与 Y 轴交换 bar.render() 我安装pyecharts库的时候是直接在pycharm里安装了最新的版本，但是导库的时候from pyecharts import Bar一直报Bar不存在，就更换了别的导库的方法#from pyecharts.echarts import Bar，结果这样了之后上面Bar库可以识别了，但导下面bar = Bar('X 轴与 Y 轴交换')的时候又报错了，网上又查了一波，说重新导包，from pyecharts.charts.basic_charts import bar（把Bar写成了bar，并且下面的Bar()改成了bar.Bar()）,这样所有的代码可以识别了，一运行之后
报了这么个错误，然后点击一下，它指的刚好就是Bar()这个地方bar = Bar('X 轴与 Y 轴交换')说什么不能是字符串，网上了查了一波，几乎没人提到Bar的这个问题，查了老久，天哪，终于看到了一篇博客
https://www.pianshen.com/article/1332746951/
还真有人遇到了这样的问题，看到了希望啊啊啊啊
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90cfc347151a071f380f1ba400e20633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5334bb1d88970150c481a84d67d2c97/" rel="bookmark">
			给一组数据，用递归实现树的结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给一组这样的数据
var college = [
{id: 128, name: “广材信息服务”, parentid: 1, cnt: 224},
{id: 1, name: “计价软件”, parentid: 28, cnt: 11580},
{id: 129, name: “业务知识”, parentid: 28, cnt: 362},
{id: 73152, name: “16”, parentid: 0, cnt: 22},
{id: 2, name: “计量软件”, parentid: 28, cnt: 28022},
{id: 130, name: “土建业务知识”, parentid: 129, cnt: 333},
{id: 131, name: “安装业务知识”, parentid: 129, cnt: 20},
{id: 73154, name: “456”, parentid: 72216, cnt: 0},
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5334bb1d88970150c481a84d67d2c97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bfe36057bff7e5488cf746afd4c38f1/" rel="bookmark">
			IF语句练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.小布什买了一筐鸡蛋，如果坏蛋少余5个，他就吃掉，否则他就去退货。
2.要求用户输入两个数a、b,如果a能被b整除或a加b大于1000，则输出a，否则输出b
3.要求输入一个年份，判断他是不是闰年，以下情况能判断是否闰年
1）能被4整除，但不能被100整除
2）能被400整除
4.输入小明的考试成绩，显示所获得奖励
成绩100分：爸爸给他买辆车
成绩大于90分：妈妈给她买mp4
成绩小于90:妈妈给她买参考书
成绩&lt;60:什么都不买!
5.小明为他手机设定了自动拨号
按1拨通爸爸的电话
按2拨通妈妈的电话
按3拨通爷爷的电话
按4拨通奶奶的电话
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a83ad9314c40d16cd31cdd92054f9ac/" rel="bookmark">
			软件工程——图书预定系统的各层数据流图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 图书预订系统：
书店向顾客发放订单，顾客将所填订单交由系统处理，系统首先依据图书目录对订单进行检查并对合格订单进行处理，处理过程中根据顾客情况和订单数目将订单分为优先订单与正常订单两种，随时处理优先订单，定期处理正常订单。最后系统根据所处理的订单汇总，并按出版社要求发给出版社。
画出图书预定系统的各层数据流图: 顶层图：
0层图：
1层图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c5789e9863fad0fdb79b751409de947/" rel="bookmark">
			Spring Aop JDK动态代理实现原理分析(源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring动态代理的方式有两种，本文主要是介绍jdk方式，我们另外一篇主要介绍另外一种方式，也就是cglib方式
1、spring 的aop作用 spring 的aop的动态代理都是为了给实现了接口的类做增强（必须是实现了接口），比如增加日志的功能。
2、本文对你的收获： 我们从这个文章中应该能知道生成的代理对象是什么样的；同时就能知道代理对象对象方法执行流程，
首先我们看下代理后的对象张什么样，其中ConfigInterface是我们需要代理的对象。
//这里删掉了一些不重要的方法。 package com.sun.proxy; #ConfigInterface 用户自己的接口，需要代理的接口 public final class $Proxy23 extends Proxy implements ConfigInterface, SpringProxy, Advised, DecoratingProxy { private static Method m1; private static Method m13; private static Method m24; private static Method m21; private static Method m16; public $Proxy23(InvocationHandler var1) throws { super(var1); } public final boolean equals(Object var1) throws { try { return (Boolean)super.h.invoke(this, m1, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final void haha() throws { try { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c5789e9863fad0fdb79b751409de947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63415c9882e80f45de40b9e66e0a2232/" rel="bookmark">
			win10连接远程桌面提示你的凭据不工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows10系统连接远程桌面的时候，提示“你的凭据不工作”，导致无法远程桌面，出现这样的情况怎么办呢？下面就来看一下解决的方法吧。
在Windows10系统桌面，右键点击桌面左下角的开始按钮，在弹出菜单中选择“运行”菜单项。
在打开的运行窗口中输入命令gpedit.msc，然后点击确定按钮。
这时会打开“本地组策略编辑器”窗口，在窗口左侧边栏依次点击“计算机配置/管理模板/系统”菜单项。
在Windows10组件菜单下找到“凭据分配”菜单项，点击后在右侧窗口中找到“允许分配保存的凭据用于仅NTLM服务器身份验证”一项。
右键点击上面的设置项，在弹出菜单中选择“编辑”菜单项。
这时会打开该项的编辑窗口，在窗口中选中“已启用”一项，点击选项窗口中的“显示”按钮，在弹出的显示内容窗口中输入termsrv/*，最后点击确定按钮。
方法/步骤2 如果上面的设置还没有解决问题的话，接下来继续下面的操作。同样打开本地组策略编辑器窗口，在窗口中依次点击“计算机配置/Windows设置/安全设置/安全选项”菜单项。
在右侧窗口中选中“网络访问：本地帐户的共享和安全模型”设置项。
右键点击上面的设置项，然后在弹出菜单中选择“属性”菜单项。
在打开的编辑窗口中选择“经典：对本地用户进行身份验证，不改变其本来身份”菜单项，最后点击确定按钮。再次连接远程桌面，就不再弹出无法连接的提示了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21805504db82944d20e9deff0ce08e12/" rel="bookmark">
			习题 - 数据链路层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用滑动窗口，每个窗口10 个数据包， RTT 为100 ms ，假设有 1250 字节数据包，最大吞吐量是多少？（注意 1250 字节数据包是 10000 位。要找出最大的吞吐量，假设网络容量不是一个限制因素，忽略数据包丢失)
2、若数据链路层的发送窗口尺寸W=4，在发送3号帧、并收到2号帧的确认帧后，发送方还可以连续发送多少个帧？（采用累计确认）
3、在回退n帧协议中，当帧序号为5比特，发送窗口的最大尺寸是多少？
4、数据链路层采用了回退n帧协议（GBN），发送方已经发送了编号为0~7的帧，当计时器超时时，若发送方只收到0、2、3号帧的确认，则发送方需要重发多少帧？
5、系统采用纠1位错的海明码，码字总长度是 11 位（n=8）。 假设8 位码字由 A B C D E F G H I J K 代表，问这些位中，哪些位置是数据位？
6、采用比特填充的比特标记法，对0111 1100 0111 1110 组帧后，对应的比特串是多少？
7、数据链路层采用选择重传协议（SR）传输数据，发送方已发送了0~3号数据帧，现已收到1号帧的确认，而0、2号帧依次超时，则此时需要重传的帧数是多少？
8、系统采用纠1位错的海明码，待传输的数据是：10101111，校验集合采用偶校验，编码后的码字是下面哪一个？
9、一个系统采用了循环冗余校验检错码。如果生成多项式是G(x)= x^3+ x^2+ 1，接收方收到的码字是1100101，关于这个码字，下面哪个说法是正确的？
10、主机甲和主机乙之间使用后退N帧协议（GBN）传输数据，甲的发送窗口尺寸为1000，数据帧长为1000字节，信道为100Mbps，乙每收到一个数据帧立即利用一个短帧（忽略其传输延迟）进行确认。若甲乙之间的单向传播延迟是50ms，则甲可以达到的最大平均传输速率约是哪一个？
11、数据传输过程中，出现的差错类型主要要两类：突发错误和下面哪个？
12、一个系统中的码字的海明距离是5，能够纠正4位错误。（错误）
13、点到点协议PPP的两种认证方式中，PAP不仅简单，而且也解决了拒绝服务攻击和明文传输的问题。（错误）解析：CHAP三次握手认证才具备题干中所说的特点
注：习题练习源自学堂在线 华南理工大学 老师授课习题整理（自己学习整理）
https://next.xuetangx.com/course/SCUT08091000715/1510610
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1b9655c4a500dc8fe532b40df29ba2/" rel="bookmark">
			算法之分治法解决平面最近点对问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。严格地说，最接近点对可能多于1对。为了简单起见，这里只限于找其中的一对。
思路：
设S中的点为平面上的点，它们都有2个坐标值x和y。为了将平面上点集S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px&gt;m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。
由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离d1和d2。现设d=min(d1,d2)。若S的最接近点对(p,q)之间的距离d(p,q)&lt;d则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于d。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为d的2个垂直长条，则p∈S1，q∈S2，如图所示:
P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n^2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)&lt;d。满足这个条件的P2中的点一定落在一个d×2d的矩形R中。
因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。
//用类PointX和PointY表示依x坐标和y坐标排好序的点 class PointX { public: int operator&lt;=(PointX a)const { return (x&lt;=a.x); } int ID; //点编号 float x,y; //点坐标 }; class PointY { public: int operator&lt;=(PointY a)const { return(y&lt;=a.y); } int p; //同一点在数组x中的坐标 float x,y; //点坐标 }; #include &lt;cstdlib&gt; #include&lt;time.h&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #include&lt;Quoit_design.h&gt; using namespace std; const int M=50; float Random(); template &lt;class Type&gt; float dis(const Type&amp;u,const Type&amp;v); bool Cpair2(PointX X[], int n,PointX&amp; a,PointX&amp; b, float&amp; d); void closest(PointX X[],PointY Y[],PointY Z[], int l, int r,PointX&amp; a,PointX&amp; b,float&amp; d); template &lt;typename Type&gt; void Copy(Type a[],Type b[], int left,int right); template &lt;class Type&gt; void Merge(Type c[],Type d[],int l,int m,int r); template &lt;class Type&gt; void MergeSort(Type a[],Type b[],int left,int right); int main() { srand((unsigned)time(0)); int length; cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe1b9655c4a500dc8fe532b40df29ba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7776bab59d85e58b01940ed06f4d4839/" rel="bookmark">
			PCL中使用VoxelGrid体素滤波器对点云进行降采样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用体素化网格方法实现降采样，即减少点的数量，减少点云数据，并同时保持点云的形状特征，在提高配准、曲面重建、形状识别等算法速度中非常实用。
PCL实现的VoxelGrid类通过输入的点云数据创建一个三维体素栅格（可把体素栅格想象为微小的空间三维立方体的集合），然后在每个体素（即，三维立方体）内，用体素中所有点的重心来近似显示体素中其他点，这样该体素就内所有点就用一个重心点最终表示，对于所有体素处理后得到过滤后的点云。这种方法比用体素中心来逼近的方法更慢，但它对于采样点对应曲面的表示更为准确。
所以这种方法可以用于对大数据量的降采样处理，尤其是在配准、曲面重建等工作之前通过这种方式对数据进行预处理，可以提高程序的运行速度。
下载测试数据文件 table_scene_lms400.pcd 并保存下来，放到同一文件夹下
完整的源码src/voxel_grid_filter.cpp文件如下：
#include &lt;iostream&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/filters/voxel_grid.h&gt; #include &lt;pcl/console/parse.h&gt; #include &lt;pcl/visualization/cloud_viewer.h&gt; int main(int argc, char** argv) { std::vector&lt;int&gt; filenames; filenames = pcl::console::parse_file_extension_argument (argc, argv, ".pcd"); pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;); pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZI&gt;); // 装载点云数据 pcl::io::loadPCDFile(argv[filenames[0]], *cloud); // 创建滤波器对象 pcl::VoxelGrid&lt;pcl::PointXYZI&gt; sor;//滤波器处理对象 sor.setInputCloud(cloud);//设置输入点云 sor.setLeafSize(0.01f, 0.01f, 0.01f);//设置滤波器处理时采用的体素大小的参数，体素大小是长宽高均为0.01 sor.filter(*cloud_filtered);//执行下采样，下采样之后的点云数据保存到 cloud_filtered 中 std::cerr &lt;&lt; "PointCloud after filtering: " &lt;&lt; cloud_filtered-&gt;width * cloud_filtered-&gt;height &lt;&lt; " data points (" &lt;&lt; pcl::getFieldsList(*cloud_filtered) &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7776bab59d85e58b01940ed06f4d4839/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d0ad508fe2d9932facc751df8e77e8/" rel="bookmark">
			基于KNN的手写字符识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理了一下自己之前做过的手写字符识别的资料，分享出来供大家学习交流，后续可能还会分享一些其他方法进行手写字符识别的资料，敬请期待~ 一、任务和设计思路二、KNN算法实现1、KNN算法简介2、简单的KNN代码3、使用sklearn的KNN分类器4、Kd_tree介绍（1）Kd_tree的构造（2）Kd_tree的查询 一、任务和设计思路 目的是要对手写字符的图片进行识别， 使用的是Chars74K 数据集，其中有0-9和a-z共36类的图片。设计思路如下：（1）先将彩色图片转换为二值图，再将其按照原来的像素形式（如32*32）存放在txt文件中。（2）将转换后的文件划分为训练组和测试组。（3）使用KNN算法对数据进行分类，通过实验结果选取合适的K值使识别率最高。
二、KNN算法实现 1、KNN算法简介 通过先前输入的训练数据确定了基本的类别，当新的数据输入时，通过计算与训练数据的广义上的距离，并通过设置临近的k个样本点与输入数据距离的权重，综合判断出输入数据的类别。所以关键在于距离的定义，k值得选择以及权重的设定。对于距离来说，我们经常使用的是欧式距离，k的选择则需要根据实验的结果进行选取，k太小容易造成过拟合，太大则会使分类结果过于模糊，效果不佳。权重的选择则要根据实际问题进行选择。
2、简单的KNN代码 首先分享一个很简单的KNN代码，直接上代码！
import csv import random # 读取 with open('Prostate_Cancer.csv', 'r') as file: reader = csv.DictReader(file) datas = [row for row in reader] # csv读出的都是字符串 # 分组 n = len(datas) // 3 random.shuffle(datas) # 貌似木有用 test_set = datas[0:n] train_set = datas[n:] # KNN 距离 def distance(d1, d2): res = 0 for key in ("radius","texture","perimeter","area","smoothness","compactness","symmetry","fractal_dimension"): res += (float(d1[key])-float(d2[key])) ** 2 return res ** 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d0ad508fe2d9932facc751df8e77e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a1e4fe619e913b647b2cdf975e12c7/" rel="bookmark">
			爱奇艺大数据实时项目统计项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目介绍 1、功能开发：
功能一：今天到现在为止，每个栏目的访问量
功能二：从搜索引擎引流过来的，每个栏目的访问量
二、Pyhton脚本实现模拟日志生产，定时执行 #coding=UTF-8 import random import time url_paths = [ "www/2", "www/1", "www/6", "www/4", "www/3", "pianhua/130", "toukouxu/821" ] status_code = [404,302,200] ip_slices = [132,156,124,10,29,167,143,187,30,100] http_referers = [ "https://www.baidu.com/s?wd={query}", "https://www.sogou.com/web?qu={query}", "http://cn.bing.com/search?q={query}", "https://search.yahoo.com/search?p={query}" ] search_keyword = [ "猎场", "快乐人生", "极限挑战", "我的体育老师", "幸福满院" ] #ip��ַ def sample_ip(): slice = random.sample(ip_slices,4) return ".".join([str(item) for item in slice]) def sample_url(): return random.sample(url_paths,1)[0] def sample_status(): return random.sample(status_code,1)[0] def sample_referer(): if random.uniform(0,1) &gt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16a1e4fe619e913b647b2cdf975e12c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c57ed2af09ec0d83a3e6b8b27e85b5/" rel="bookmark">
			PAT 1103 Integer Factorization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目的意思是给定n,k,p，求是否存在k个正整数，每个数的p次幂相加的结果等于n。
有，输出k个数相加的结果最大的那个，如果有多个，输出序列从大到小排最大的那个（从左往右比较，若 i &lt; l , a i = b i , a l &gt; b l i&lt;l,ai=bi,a_l&gt;b_l i&lt;l,ai=bi,al​&gt;bl​，则序列a大于序列b）。
这一题一开始毫无思路，如果暴力肯定会超时。随后查了别人的讲解，有人就简单提到深度优先搜索，还是想不出来。看了一下柳神的讲解，挺详细，原来是先把从i=0开始p次方小于等于n的数保存下来，然后用深度优先搜索，每次把值加上去，判断是否大于n，不是就接着搜索。
这一题一开始写好，我每次搜索都是从头开始搜索，第二个测试点自己测的时候要很久才出来，比较了一下与别人的代码，发现可以每次可以从上一个元素的位置开始遍历，因为上一个元素的前一个元素前面已经遍历过，所以这次不用。而且求的是从大到小最大序列，就不用重复计算。
遍历的时候最好从大到小遍历，因为这样，就不用比较相等的情况，大的序列肯定在前面产生。
今天才发现深度优先搜索还可以这样用，以前只认为用在图中，也算是让我的思维打开了一点，加深了一下对深度优先搜索的理解。
（用时：1：41：22.47）
附上别人的讲解：
https://blog.csdn.net/liuchuo/article/details/52493390
#include &lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; numVec; int maxNumSum = -1; int vecSize = 0; int maxNum[401]; void dfs(int numSum,int currenSum,int k,int addCount,int n,int num[],int index) { if(k==addCount) { if(currenSum==n) { if(maxNumSum &lt; numSum) { maxNumSum = numSum; for(int i=0; i&lt;k; i++) { maxNum[i] = num[i]; } } } return; } for(int i=index; i&gt;=1; i--) { if(currenSum + numVec[i] &lt;= n) { num[addCount] = i; dfs(numSum + i, currenSum + numVec[i], k, addCount+1,n,num,i); } } } int main() { int n,k,p; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5c57ed2af09ec0d83a3e6b8b27e85b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaddd34e2a32e6df446d4bff94c173e4/" rel="bookmark">
			鲲鹏云HCIA知识总结（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
大二下学期有幸参加了华为鲲鹏云的一个训练营，自开营已经过去了一周时间，期间学到了很多新的知识，也拓宽了自己的眼界(●ˇ∀ˇ●)。训练营的最终目的是通过华为的HCIA认证，因此总结一下这几天的知识点。
不得不说这几天学习的内容是挺多的，内容也很琐碎，看来想通过这个认证着实不容易，好了开始总结知识点 (ง •_•)ง
第一章 鲲鹏介绍 这章在考试大纲中占10%，而且全是理论知识，主要介绍了鲲鹏计算产业以及鲲鹏生态，华为鲲鹏处理器的架构，型号与规格，技术创新与应用场景，TaiShan200机架服务器和高密服务器，华为云鲲鹏云服务，鲲鹏计算平台的操作系统兼容性以及openEuler开源操作系统的发展和特性等内容。记录一下重点的内容。
2019年华为推出的鲲鹏920处理器是业界第一颗7nm工艺处理器。
鲲鹏生态兼容的操作系统介绍：
华为鲲鹏伙伴计划
思考题：
华为鲲鹏计算产业相关产品有哪些？（ ABC ）
A、华为鲲鹏处理器
B、TaiShan服务器
C、华为云鲲鹏云服务
围绕鲲鹏计算产业，华为提供（ ABCD ）支持。
A、云服务
B、工具链
C、社区服务
D、专业服务
华为鲲鹏处理器架构介绍： 华为鲲鹏处理器基于ARM架构。ARM是一种CPU架构，有别于Intel、AMD CPU采用的CISC复杂指令集，ARM CPU采用RISC精简指令集（reduced instruction set computer，精简指令集计算机）。
Kunpeng 920内置多种加速引擎，同时TaiShan 200服务器基于Kunpeng 920芯片提供的硬件加速解决方案，包含了对称加密、非对称加密和数字签名、压缩解压缩等算法。
Kunpeng 920加速器简介：
思考题
Kunpeng 920加速器子系统需要安装？（√）
Suse操作系统是从哪个版本开始处于Kunpeng 920的OS生态圈？（D）
A. SLES 12.3
B. SLES 12.4
C. SLES 15
D. SLES 15.1
以下哪些关于华为鲲鹏920处理器的描述是正确的？（ ABCD）
A.采用了7nm的制造工艺；
B.支持8通道的DDR4控制器；
C.支持PCIe 4.0接口，并兼容PCIe 3.0/2.0/1.0；
D.支持多种加速器；
华为鲲鹏920处理器内置了那些加速器？（ABC）
A、SSL加速引擎
B、加解密加速引擎
C、压缩解压缩加速引擎
以下哪些属于华为鲲鹏920芯片的特点？（ABC）
A. 集成最多64个自研核
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaddd34e2a32e6df446d4bff94c173e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/870620b31b680976ef868f4420353060/" rel="bookmark">
			PING 怎么知道网络速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：如果你想通过PING知道网络速度情况；
速度：
网络延迟1ms到60ms是正常情况。
理想情况：1-60 ms
一般情况：61ms-90ms
较差：91ms-120ms
很差：120ms以上
1ms到30ms是极快的，几乎察觉不出有延迟，玩任何游戏速度都特别顺畅。
31ms到50ms是良好，可以正常游戏，没有明显的延迟情况。
51ms到100ms是普通，对抗类游戏能感觉出明显延迟，稍有停顿。
100ms差，无法正常游戏，有卡顿，丢包并掉线现象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd8e8746dd876689f5690ab3f1bfa48/" rel="bookmark">
			CSS网页变灰色实例汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 CSS网页变灰色实例汇总1.搜狐2.B站3.搜狗4.天猫5.百度6.58同城7.央视网 CSS网页变灰色实例汇总 1.搜狐 代码：
style="filter: grayscale(1); 2.B站 代码：
html.gray { -webkit-filter:grayscale(.95); } 3.搜狗 代码：
html { filter: grayscale(100%); -webkit-filter: grayscale(100%); -o-filter: grayscale(100%); } *{ filter: gray; } 4.天猫 代码：
html { -webkit-filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1) } 5.百度 代码：
body.qm-activity #head_wrapper,body.qm-activity #u,body.qm-activity #u1,body.qm-activity .s-top-left.s-isindex-wrap { filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%); filter: gray } 6.58同城 代码：
html { filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: progid:DXImageTransform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd8e8746dd876689f5690ab3f1bfa48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c869e886e99ea88ca3190375e378aa/" rel="bookmark">
			获取JSON文本（复嵌对象）转换指定JSON数据并Ajax实现数据初始可视化【附上echarts地图官方数据形式json文件数据】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这里简单采用固定数据实现了以百度地图为基准的数据映射，那么可以看到全国各地的geoCoord（经纬度），完全可以采用本地导入json文本的来减少代码量。于是乎我在网上找到了一个老哥写的json文本（后来证实不是很全。具体是哪位记不得了就不写引用了，原谅我。），它的文件格式是这样子的：
PS：阿里云geoJson获取 以及 http://geojson.io/
[ { "name": "北京市", "log": "116.46", "lat": "39.92", "children": [ { "name": "北京", "log": "116.46", "lat": "39.92" }, { "name": "平谷", "log": "117.1", "lat": "40.13" }, { "name": "密云", "log": "116.85", "lat": "40.37" }, { "name": "顺义", "log": "116.65", "lat": "40.13" }, { "name": "通县", "log": "116.67", "lat": "39.92" }, { "name": "怀柔", "log": "116.62", "lat": "40.32" }, { "name": "大兴", "log": "116.33", "lat": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c869e886e99ea88ca3190375e378aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66fef0d00df1ce18e53e1a58efca2d64/" rel="bookmark">
			Python基础——从csv文件中读取数据，提取数据的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据保存在csv文件中
1.从csv文件中读取数据 参数header=None的有无 （1）没有header=None——直接将csv表中的第一行当作表头
# 读取数据 import pandas as pd data = pd.read_csv("data1.csv") print(data) 打印结果为：
（2）有header=None——自动添加第一行当作表头
# 读取数据 import pandas as pd data = pd.read_csv("data1.csv",header=None) print(data) 打印结果为：
2.数据切割 （这里根据csv表的格式，将header=None不写）
（1）获取所有列，并存入一个数组中
# 读取数据 import pandas as pd data = pd.read_csv("data1.csv") # print(data) # ①获取所有列，并存入一个数组中 import numpy as np data = np.array(data) print(data) # 用户编号 性别 年龄(岁) 年收入(元) 是否购买 # [[15624510 1 19 19000 0] # [15810944 1 35 20000 0] # [15668575 2 26 43000 0] # [15603246 2 27 57000 0] # [ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66fef0d00df1ce18e53e1a58efca2d64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c318d99822038527e5a081843e8cb9e7/" rel="bookmark">
			数据资产管理概要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是数据资产？
1.1、数据的来源
数据是由企业过去经营过程中交易或事项积累下来的数字化记录，不仅包含传统意义上的数据，还包括文本、声音、图像、照片和视频等类型的数据，也包括微博、微信、消费记录、出行记录、文件等等数据。
1.2、什么数据才能称为资产？
会计学中资产的定义：“资产是指企业过去的交易或者事项形成的、由企业拥有或者控制的、预期会给企业带来经济利益的资源。”
因此，我们将数据资产定义为企业过去的交易或者事项形成的，由企业拥有或者控制的，预期会给企业带来经济利益的，以物理或电子的方式记录的数据资源，如文件资料、电子数据等。即，如果数据要成为数据资产，至少要满足3个核心必要条件：
企业过去的交易或者事项形成的；
企业拥有或者控制；
预期会给企业带来经济利益。
在企业中，并非所有的数据都构成数据资产，数据资产是能够为企业产生价值的数据资源。企业可能在长期的经营中，存储下了大量的数据，但如果这些数据不能持续给企业带来现金流，反而需要企业花成本去收集、整理、维护，那这对企业来说，不是“资产”，而是“负债”，它需要企业持续投入，如果长期看不到收益的“预期”，反而会摊薄企业的利润。因此，只有那些能够给企业带来可预期经济收益的数据资源，才能够被称为数据资产。
二、数据资产管理的重要性
2.1、数据资产管理的概念
前面我们介绍过只有那些能够给企业带来可预期经济收益的数据资源，才能够被称为数据资产，因此数据资产管理的目的是“盘活”数据以充发挥它的价值。
数据资产管理（DAM，Data Asset Management）是指规划、控制和提供数据及信息资产的一组业务职能，包括开发、执行和监督有关数据的计划、政策、方案、项目、流程、方法和程序，从而控制、保护、交付和提高数据资产的价值。数据资产管理需要充分融合业务、技术和管理，以确保数据资产保值增值。
2.2、数据资产管理的内涵
大数据发展方向可以定义为三层：大数据处理能力、数据资产管理、业务价值实现。
其中，大数据处理能力是应对大数据发展挑战的基础，它不仅包括目前技术领域所关注的海量数据采集、存储、分布式计算、实时事件应对等，还要具备对各种格式类型的数据进行加工、处理、识别、解析等相关能力。
数据资产管理位于业务价值实现应用和大数据处理能力底层平台中间，处于承上启下的重要地位。对上支持以价值创造为导向的数据应用开发，对下依托大数据平台实现数据全生命周期的管理。数据资产管理包括两个重要方面，一是数据资产管理的核心管理职能，二是确保这些管理职能落地实施的保障措施，包括战略规划、组织架构、制度体系等。
数据资产管理贯穿数据采集、存储、应用和销毁整个生命周期全过程。企业管理数据资产就是对数据进行全生命周期的资产化管理，促进数据在“内增值，外增效”两方面的价值变现，同时控制数据在整个管理流程中的成本消耗。在数据的生命周期开始前，企业先期制定数据规划、定义数据规范，以期获得实现数据采集、交付、存储和控制所需的技术能力。数据资产管理一般来说包括统筹规划、管理实施、稽核检查和资产运营四个主要阶段。
2.3、数据价值难以有效发挥的原因
缺乏统一数据视图：企业的数据资源散落在多个业务系统中，企业主和业务人员无法及时感知到数据的分布与更新情况，无法快速找到符合自己需求的数据，也无法发现和识别有价值的数据并纳入数据资产。
数据孤岛：据统计，98%的企业都存在数据孤岛问题。而造成数据孤岛的原因既包括技术上的，也包括标准和管理制度上的，这阻碍了业务系统之间顺畅的数据共享，降低了资源利用率和数据的可得性。
数据质量低：数据质量低直接影响业务决策，导致数据统计分析不准确、监管业务难、高层领导难以决策等问题。根据数据质量专家Larry English的统计，不良的数据质量使企业额外花费15%到25%的成本。而数据能够被当作资产，并发挥越来越大的价值，其前提是数据质量的不断提升。
缺乏安全的数据环境：数据安全造成的风险主要包括数据泄露与数据滥用等。根据数据泄露水平指数(Breach Level Index)监测，自 2013 年以来全球数据泄露高达 130 亿条，其中很多都是由于管理制度不完善造成。随着各个机构数据的快速累积，一旦发生数据安全事件，其对企业经营和用户利益的危害性将越来越大，束缚数据价值的释放。
缺乏数据价值管理体系：大部分企业还没有建立起一个有效管理和应用数据的模式，包括数据价值评估、数据成本管理等，对数据服务和数据应用也缺乏合规性的指导，没有找到一条释放数据价值的“最优路径”。
2.3、数据资产管理是充分发挥数据价值的必经之路
数据资产管理通过解决释放数据价值过程中面临的诸多问题，以体系化的方式实现数据的可得、可用、好用，用较小的数据成本获得较大的数据收益，具体体现在以下六个方面：
全面掌握数据资产现状：数据资产管理的切入点是对数据家当进行全面盘点，形成数据地图，为业务应用和数据获取夯实基础。数据地图作为数据资产盘点的输出物之一，可以帮助业务人员快速精确查找他们想要的据。其次，数据地图作为企业数据的全盘映射，帮助数据开发者和数据使用者了解数据，并成为对数据资产管理进行有效监控的手段。
提升数据质量：数据资产管理通过建立一套切实可行的数据质量监控体系，设计数据质量稽核规则，加强从数据源头控制数据质量，形成覆盖数据全生命周期的数据质量管理，实现数据向优质资产的转变。
实现数据互联互通：数据资产管理通过制定企业内部统一的数据标准，建立数据共享制度，完善数据登记、数据申请、数据审批、数据传输、数据使用等数据共享相关流程规范，，打破数据孤岛，实现企业内数据高效共享。同时搭建数据流通开放平台，增强数据的可得性，促进数据的交换流通，提升数据的服务应用能力。
提高数据获取效率：数据资产管理通过搭建数据管理平台，采取机器学习等相关自动化技术，将大量前期的数据准备时间和交付项目的时间缩短，提升数据的获取和服务效率，让数据随时快速有效就绪，缩短数据分析人员和数据科学家的数据准备时间，加快数据价值的释放过程。
保障数据安全合规：保障安全是数据资产管理的底线，数据资产管理通过制定完善的数据安全策略、建立体系化的数据安全措施、执行数据安全审计，全方位进行安全管控，确保数据获取和使用合法合规，为数据价值的充分挖掘提供了安全可靠的环境。
数据价值持续释放：存储和管理数据的最终目的是实现数据的价值，数据资产管理将数据作为一项资产，并通过一个持续和动态的全生命周期管理过程，使数据资产能够为企业数字化转型提供源源不断的动力。从企业高管到业务人员及技术人员，全员都要以持续释放数据价值为理念来重视数据资源管理工作。管理方面，建立一套符合数据驱动的组织管理制度流程和价值评估体系。技术方面，建设现代化数据平台、引入智能化技术，确保数据资产管理系统平台持续、健康地为数据资产管理体系服务。
三、如何进行数据资产管理
数据资产管理框架包含8个管理职能和5个保障措施。管理职能是指落实数据资产管理的一系列具体行为，保障措施是为了支持管理职能实现的一些辅助的组织架构和制度体系。
数据资产管理的管理职能包括数据标准管理、数据模型管理、元数据管理、主数据管理、数据质量管理、数据安全管理、数据价值管理以及数据共享管理等 8 个方面。
数据资产管理是体系化非常强的工作，需要充分考虑企业内部 IT系统、数据资源以及业务应用的开展现状，同时也要考虑围绕业务开展所设立的人员和组织机构的情况，在此基础上设计一套有针对性的数据资产管理组织架构、管理流程、管理机制和考核评估办法，通过管理的手段明确“责权利”以保障数据资产管理工作有序开展。数据资产管理的保障措施可以从战略规划、组织架构、制度体系、审计方式和培训宣贯五方面进行展开。数据资产管理的详细内容见《数据资产管理实践白皮书（4.0版）》。
注：部分摘编《数据资产管理实践白皮书（4.0版）》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87413e0099c41f70e3739290ab02e406/" rel="bookmark">
			Java实现贪吃蛇（代码逐行注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在最前 作为本人学习Java的第二篇博客，也是自己练手的第一个小项目。耗费了大量的时间和精力，遇到的问题分享给大家，希望大家可以有所收获。
视频展示 Java贪吃蛇
整体思路 因为所有的游戏都要有一个帧的概念，也就是看似动态的画面实则是由多个静态的、变化的画面组成的，当这样的画面足够多的时候，就有了一个动态的观感。这就是我理解的帧的概念。
有了这个思路，我们只要设计好贪吃蛇每一个静态画面，把它的变化连续起来就可以。
那么他们的变化有什么规律呢？
答案就是，我们把蛇在画面中的运动看做是坐标的不断变化，蛇的每一节与前一节的值都是相等的。
比如说，最开始蛇头的坐标是（1,1），蛇身的坐标是（0,1）当蛇运动的时候，蛇头的坐标变成了（2,1），那么蛇身变成（1,1），蛇的每一节一直等于他的前一节，我们利用这样的规律来制作一个贪吃蛇的小游戏。
贪吃蛇主界面（Startgame类） 首先我们要启动一个窗口，在这个窗口里面不断的进行操作，我用的是Java自带的swing写的。
import javax.swing.*; public class Startgame { public static void main(String[] args) { /* 绘制一个静态窗口 */ JFrame frame = new JFrame("贪吃蛇by宋阳");//创建一个窗口，参数是窗口标题显示的文字 frame.setBounds(430, 180, 900, 720);//设置一个窗口的大小 frame.setResizable(false);//窗口大小不可以改变 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口可以关闭，此处填写参数3可以 frame.add(new GamePanel());//添加组件 frame.setVisible(true);//打开窗口 } } 对于 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)这行代码可以进行扩展一下; ** setDefaultCloseOperation(int operation)是设置用户在此窗体上发起 “close” 时默认执行的操作。方法中的参数解释如下： 为“0”或DO_NOTHING_ON_CLOSE：
不执行任何操作；要求程序在已注册的WindowListener 对象的 windowClosing 方法中处理该操作。
为“1”或HIDE_ON_CLOSE
调用任意已注册的 WindowListener 对象后自动隐藏该窗体。此时没有关闭程序，只是将程序界面隐藏了.
为“2”或DISPOSE_ON_CLOSE
调用任意已注册 WindowListener 的对象后自动隐藏并释放该窗体。但继续运行应用程序，释放了窗体中占用的资源。
为“3”EXIT_ON_CLOSE（在 JFrame 中定义）：使用 System exit 方法退出应用程序。仅在应用程序中使用。结束了应用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87413e0099c41f70e3739290ab02e406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0bb43b28e41b66de6a2f0173425ee8a/" rel="bookmark">
			docker 创建tomcat成功却访问404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker 创建tomcat成功却访问404 1.启动tomcat容器 2.进入容器目录:docker exec -it 你的容器id /bin/bash 3.移除webapps:rm -rf webapps 4.更换webapps文件:mv webapps.dist webapps 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20bf518129535f2e339e30dfaee2bfde/" rel="bookmark">
			vmware虚拟机安装centos,主机访问不到虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vmware虚拟机安装centos,主机访问不到虚拟机 如下图: 我这里选择nat模式,就需要如上图中勾选红框的选项,如果出现红框勾选了保存不成功的时候,就需要清除注册表,可使用360或者ccleaner清除后再次勾选保存,之后就可以正常使用了,主机也就能访问到虚拟机了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d68f6409f09f50e5031c950966ede5/" rel="bookmark">
			牛客网刷题C语言  求中位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 中位数定义：一组数据按从小到大的顺序依次排列，处在中间位置的一个数（或最中间两个数据的平均数）. 给出一组无序整数，求出中位数，如果求最中间两个数的平均数，向下取整即可（不需要使用浮点数）
输入描述: 该程序包含多组测试数据，每一组测试数据的第一行为N，代表该组测试数据包含的数据个数，1&lt;=N&lt;=10000. 接着N行为N个数据的输入，N=0时结束输入 输出描述: 输出中位数，每一组测试数据输出一行 示例1
输入 复制
4 10 30 20 40 3 40 30 50 4 1 2 3 4 0 输出 复制
25 40 2 #include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void qsort(int a[], int left, int right)
{
int low,high;
low = left;
high = right;
int key = a[low];
if(left&gt;=right)
{
return ;
}
while(low&lt;high)
{
while(low&lt;high&amp;&amp;a[high]&gt;=key)
{
high--;
}
a[low]=a[high];
while(low&lt;high&amp;&amp;a[low]&lt;=key)
{
low++;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6d68f6409f09f50e5031c950966ede5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e794e1f83c4eed2d18211ce0508864/" rel="bookmark">
			数据分析学习总结笔记09：文本分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分析学习总结笔记09：文本分析 1 文本分析1.1 文本分析概述1.2 结构/非结构化数据1.3 文本数据特点1.4 自然语言处理——NLP1.5 文本挖掘的应用 2 文本分词2.1 英文分词——KNIME2.2 中文分词2.2.1 中文分词工具2.2.2 分词的方法2.2.3 中文分词实操——pynlpir2.2.3.1 pynlpir准备2.2.3.1 操作步骤 3 中文关键词提取3.1 关键词提取概述3.2 关键词提取方法3.2.1 TF-IDF3.2.2 TextRank 3.3 关键词提取实操——pynlpir 4 中文停用词过滤4.1 停用词概述4.2 停用词实操——pynlpir 5 中文词频统计5.1 NLTK简介5.2 词频统计实操——NLTK 6 中文命名实体识别6.1 命名实体识别概述6.2 命名实体识别类型6.3 命名实体识别方法6.4 命名实体识别实操——pynlpir6.4.1 pynlpir实体分类结构6.4.2 pynlpir实操 1 文本分析 1.1 文本分析概述 文本分析是指对文本的表示及其特征项的选取；文本分析是文本挖掘、信息检索的一个基本问题，它把从文本中抽取出的特征词进行量化以表示文本信息1。
1.2 结构/非结构化数据 结构化数据：指的就是可以用二维表组织、分析处理过程较为明确的信息，可以将这种结构化的二维表组织方式理解为一个表格，表格里的每一个元素都被明确标记并很容易被识别。数字、符号等属于结构化数据。非结构化数据：指多种信息的无结构混合，通常无法直接知道或明确理解其内部结构，只有经过识别、有条理的存储分析后才能体现其结构化特征，通过文本挖掘，发现价值。文本、图片、声音、视频等属于非结构化数据。半结构化数据：介于结构化数据和非结构化数据两者之间的数据称为半结构化数据，大多数文本，既包含标题、作者、分类等结构字段，又包含非结构化的文字内容，这类文本均属于半结构化数据。如，新闻等。 1.3 文本数据特点 （1）非结构化（非结构化数据占绝大部分）
（2）海量数据
（3）高维稀疏性
（4）语义/情感
1.4 自然语言处理——NLP 自然语言处理（Natural Language Processing，NPL）作为计算机科学领域与人工智能领域中的一个重要方向，是处理文本信息的一种重要手段。它研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法。主要包括以下内容：
机器翻译自动摘要文本分类信息检索信息抽取自动问答情感分析…… 1.5 文本挖掘的应用 词频分析关键词提取语义网文本分类情感分析主题模型…… 2 文本分词 分词，是将连续字符组成的语句按照一定规则划分成一个个独立词语的过程。
停用词：“This”，“that”，“的”、“地”、“啊”，……歧义词：我们需要有自主权→自主/主权未登录词：“喜大普奔”，“洪荒之力”，……
2.1 英文分词——KNIME （1）软件官方下载地址：KNIME.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e794e1f83c4eed2d18211ce0508864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aaf808e3e1044087cb3d57a32ef0fab/" rel="bookmark">
			三个线程循环打印ABC10次的几种解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目:有三个线程分别打印A、B、C，请用多线程编程实现，在屏幕打印10次ABC 整体思路：该问题为三个线程的同步唤醒机制即ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。
public class MyThreadPrinter2 implements Runnable { private String name; private Object prev; private Object self; private Thread thread; public MyThreadPrinter2(String name,Object prev,Object self) { this.name=name; this.prev=prev; this.self=self; thread=new Thread(this,name); } @Override public void run() { // TODO Auto-generated method stub int count=10; while (count&gt;0) { synchronized (prev) { synchronized (self) { System.out.print(name); count--; self.notify(); } try { prev.wait(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aaf808e3e1044087cb3d57a32ef0fab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3712a0aa654ceabc751157d32661e7e3/" rel="bookmark">
			Jeston nano远程桌面闪退解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Jeston nano远程桌面闪退解决方案 最近在用NVIDIA的jetson nano进行开发的时候遇到了远程桌面无法连接的状况，原因在于jetson不允许两个用户同时登录，解决方案就是注释掉自动登录的选项：
sudo vi /etc/gdm3/custom.conf # AutomaticLoginEnable=true # Automatic Login=[user1]` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c7291fd087d6d3880bb31c073cb0e4/" rel="bookmark">
			GitLab 用邮件找回密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天登陆GitLab 死活进不去，使用邮件找回密码，也收不到邮件，后来我尝试用以下方式 就可以进去了
打开网址：https://about.gitlab.com/get-help/
点进去 https://gitlab.com/users/confirmation/new
希望能帮到其他的遇到此类问题的同伴哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a841386c6e390a2bd02fd8f3f3bc638b/" rel="bookmark">
			浙大PTA线性表元素的区间删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目要求：若Data数组中存在元素X满足minD&lt; X &lt; maxD,则把这个元素删除
思路：新建一个下标，指向处理后的数组当前位置，若符合要求，则把原数组的元素放进来，并且下标后移一位，否则不放进来。遍历完原数组之后，应当把L-&gt;Last修改成j-1,因为前面的j++,已经为下一个处理做准备了。
List Delete( List L, ElementType minD, ElementType maxD ) { Position i=0,j=0; for(i=0,j=0; i&lt;=L-&gt;Last; i++) { if(minD &lt; L-&gt;Data[i] &amp;&amp; L-&gt;Data[i] &lt; maxD){} else{ L-&gt;Data[j]=L-&gt;Data[i]; j++; } } L-&gt;Last = j - 1; return L; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be098b652faf42660ceed669a9c3064/" rel="bookmark">
			浙大PTA弹球距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目思路：
通过这个图片可以看到第i次弹起和第i+1下降经过的路程是一样的，并且等于第i次下降的路程*p,因此我们只需要将第一次下降加起来，留下的每俩段合起来一起加上去，直到弹起的高度达不到TOL阈值
double dist( double h, double p ) { double current = h, sum = 0; sum += h; current *= p; while(current &gt;= TOL){ sum += 2 * current; current *= p; } return sum; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63f5d5f2dff8556b13d16901571e7d4a/" rel="bookmark">
			浙大PTA递增的整数序列链表的插入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目要求：在递增链表中插入一个值，使得插入之后，链表仍然为递增。
思路：从前往后遍历，找到第一个比待插入值大的节点，插在这个节点前面，在这个例子中就是找到4(第一个比3大的元素)插在它前面。但是问题是单链表不能回溯，因此我们用当前节点的next的值来与待插入值X做比较。
下面展示 代码。
List Insert( List L, ElementType X ) { List s; List p = L; s = (struct Node*)malloc(sizeof(struct Node));//构造新结点 s-&gt;Data = X; while(p-&gt;Next &amp;&amp; X &gt; p-&gt;Next-&gt;Data) p = p-&gt;Next; s-&gt;Next = p-&gt;Next; p-&gt;Next = s; return L; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e21ae286979bdf070a0db9f113a108e/" rel="bookmark">
			Kafka配置4--Windows下配置Kafka的SSL证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka配置1--Windows环境安装和配置Kafka
Kafka配置2--Windows下配置Kafka的SASL-PLAIN身份验证
Kafka配置3--Windows下配置Kafka集群
Kafka配置4--Windows下配置Kafka的SSL证书
Kafka配置5--Windows下配置Kafka的集群+SASL+SSL
Kafka配置6--Windows下设置和增加SASL用户或用户权限
修改hosts，配置主机名称
Windows路径为C:\Windows\System32\drivers\etc，在hosts文件中追加如下配置：
# Kafka相关配置
192.168.2.200 kafka-main
1、服务器端SSL证书签发
1.1、生成kafka1.keystore.jks
以管理员身份运行CMD，定位到Java安装目录的bin文件夹下，如D:\Net_Program\Net_Java\bin，然后输入如下命令：
keytool -keystore D:\Net_Program\Net_KafkaSsl\kafka1.keystore.jks -alias kafka1 -validity 3650 -genkey -keyalg RSA 紧接着就是输入2次密码，如qubernet
您的名字与姓氏是什么? 输入主机的IP地址或主机绑定的域名，如kafka-main
您的组织单位名称是什么? ~ 该单位的双字母国家/地区代码是什么? 都输入cn
最后在确定没有问题后输入y确认
再次输入密码qubernet
1.2、生成CA
以管理员身份运行CMD，然后输入如下命令：
openssl req -new -x509 -keyout D:\Net_Program\Net_KafkaSsl\ca-key -out D:\Net_Program\Net_KafkaSsl\ca-cert -days 3650 紧接着就是输入2次密码，如qubernet
Country Name (2 letter code) [AU] ~ Organizational Unit Name (eg, section) [] 都输入cn
Common Name (e.g. server FQDN or YOUR name) [] 输入主机的IP地址或主机绑定的域名，如kafka-main
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e21ae286979bdf070a0db9f113a108e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903d06732cc43dfbfc4df999643e2070/" rel="bookmark">
			java使用redisTemplate获取list类型的数据报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java使用redisTemplate获取list类型的数据报错
2020-04-03 15:05:04.794 DEBUG 8392 --- [nio-8080-exec-1] c.x.s.c.s.c.DefaultErrorController : 异常堆栈信息: org.springframework.data.redis.serializer.SerializationException: Could not read JSON: Unexpected token (START_OBJECT), expected START_ARRAY: need JSON Array to contain As.WRAPPER_ARRAY type information for class java.lang.Object at [Source: [B@7d39faab; line: 1, column: 1]; nested exception is com.fasterxml.jackson.databind.JsonMappingException: Unexpected token (START_OBJECT), expected START_ARRAY: need JSON Array to contain As.WRAPPER_ARRAY type information for class java.lang.Object at [Source: [B@7d39faab; line: 1, column: 1] at org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer.deserialize(Jackson2JsonRedisSerializer.java:73) at org.springframework.data.redis.serializer.SerializationUtils.deserializeValues(SerializationUtils.java:50) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/903d06732cc43dfbfc4df999643e2070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d41e18d264578a6677cdafa43007b59e/" rel="bookmark">
			c&#43;&#43;多线程和单线程的性能的小测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;future&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;chrono&gt;
#include&lt;ctime&gt;
using namespace std;
double caculate(double v)
{
if (v &lt;= 0)
return v;
this_thread::sleep_for(chrono::milliseconds(10));//让当前线程暂停
return sqrt((v * v + sqrt((v-5)*(v+2.5))/2.0)/v);
}
template&lt;typename Iter, typename Fun&gt;
double visitRange(thread::id id,Iter iterBegin,Iter iterEnd,Fun func)
{
auto curId = this_thread::get_id();
if (id == curId)
{
cout &lt;&lt; curId &lt;&lt; "hell main thread\n";
}
else { cout &lt;&lt; curId &lt;&lt; "hello work thread\n"; }
double v = 0;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d41e18d264578a6677cdafa43007b59e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c15cfa57fcf03a695b896f423e3b28d/" rel="bookmark">
			sql一个数据库中的表中某一列插入到另一个数据中的表中某一列当中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sql一个数据库中的表中某一列插入到另一个数据中的表中某一列当中 insert into [NEWU_WCS].[dbo].[mPortCache] (PortID,PortCacheLocation) select newid(),LineInPortCode from [NEWU_WMS].[dbo].[mLineInPort] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39c01fb4781e84cbb62df0a572ce324b/" rel="bookmark">
			Authentication failed.&#39; on server 192.168.29.128:27017. The full response is { &#34;ok&#34; : 0.0, &#34;errmsg&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Authentication failed.’ on server 192.168.29.128:27017. The full response is { “ok” : 0.0, “errmsg” 解释：由于mongodb中的admin库设置了认证的用户名和密码
db.auth('root','123') 如下： spring.data.mongodb.username=root spring.data.mongodb.password=123 # authentication ：身份验证 spring.data.mongodb.authentication-database=admin username和password无法对应上一开始认证的用户名和密码，此时就会提示认证错误 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d8dc0a3ee475328d0044c073532fa3/" rel="bookmark">
			“Error:(6,2) java:找不到符号”的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作：Build Project
问题现象如下图所示：（原因：没有导入这个类或者这个类所在的jar包）
解决方案：按照下图重新Reimport后，再按需导入依赖class
说明：mvn-&gt;reimport更新的是EXternal Libraries中的jar文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/368c52c58bc2a7275067a765a55663d2/" rel="bookmark">
			QQ 音乐加密音乐文件格式转换并附加专辑图片教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主懒得作图了，沿用之前《使用 Unlock Music 解锁加密的音乐文件》的算了，盗自己的图总归不犯法的吧？言归正传，之前已经介绍过如何自己架设服务器解密QQ音乐、网易云音乐等的付费加密音乐文件，但是对于博主这种不追求音质偏爱MP3的人来说，解密后的音乐文件还是看着别扭，而且解密后音乐文件的专辑图片丢失，看着不爽，本篇就分享如何在不安装任何格式转换软件的前提下将解密后的音乐文件转换为MP3并写入专辑图片。
软件名称：FFMpeg
软件主页：http://www.ffmpeg.org/
项目地址：https://github.com/FFmpeg/FFmpeg
下载页面：https://ffmpeg.zeranoe.com/builds/
1. 添加 FFMpeg 实例至操作系统 注意！本篇不是教各位如何白嫖，该花的钱还是要花，至少QQ音乐付费会员还是要开通一下的，实在不行各位找几个朋友众筹一个付费会员账号也行啊。好了，进入正题，下载前面提到的神器FFMpeg，博主自从接触到它之后就深深爱上了它，经常用到的功能诸如HLS协议的视频下载及合并、音频/视频格式转换、压缩等等，几乎无所不能，再也不用安装格式转换软件了。
将下载到的软件包解压缩到指定的目录下，比如博主将软件释放到了"D:\Program Files\FFMpeg"中，然后，请务必记住你所选定的目录完整路径，接下来要用到它。
之后打开命令提示符，输入"sysdm.cpl"打开【系统属性】对话框（桌面"我的电脑"图标上单击鼠标右键，然后在弹出的右键菜单中选择"属性"是一样的效果，不是博主装高深，实在是懒得截图），切到【高级】选项卡，单击下方的"环境变量"按钮，之后在弹出的【环境变量】对话框中选中"Path"变量，点"编辑"按钮，然后在【编辑环境变量】对话框中点"新建"按钮，输入让各位务必记住的FFMpeg软件包释放路径，展开至"bin"子目录然后一路点击"确定"按钮保存即可，如下图所示。
环境变量添加完成后，重新打开一个命令提示符窗口以使环境变量生效，输入"ffmpeg -version"命令并回车如果能看到如下输出则证明现在FFMpeg可以正常使用了。注意，下方示意图仅供参考，博主因为此前已经添加过环境变量，所以没有重新打开一个命令提示符窗口就执行命令了，请务必按照前述说明操作。
2. 下载指定音乐文件并解密 打开QQ音乐，进入设置页面，按照下图勾选"同时下载专辑图片"，同时记住缓存文件夹位置，下图仅供参考。
接下来下载你喜欢的歌曲，这里以周杰伦的黑色毛衣为例，可以看到该歌曲属于付费单曲，仅会员期内可以正常播放，且其它播放器无法播放，这里首先点击播放（重要！播放时会自动下载专辑图片），之后下载该歌曲。
之后打开刚才要求各位记住的QQ音乐缓存文件夹，可以看到专辑图片已经自动下载，先不用管它，等下要用到。至于为啥窗口截图突然变成 Windows 7 的窗口了，因为博主把QQ音乐安装在虚拟机里了，不必在意。
3. 将下载到的加密音乐文件进行解密 本文开头已经给出博主之前写的搭建服务器部署 Unlock Music 的教程链接，喜欢自己动手的可以尝试下在自己操作系统环境中搭建本地 Unlock Music 平台，不想费那功夫的，下面给各位一个现成的。
音乐解锁：http://lclexclusive.top/unlock-music/
打开上方给出的网址，将刚刚下载到的加密音乐文件拖动至指定位置，若无意外，会提示解锁成功，然后页面下方列表区会提供解密完成的音乐文件选项，将该文件下载到本地。
将下载得到的解密后的音乐文件同刚才缓存目录中的专辑图片放在同一文件夹下，为转换格式做好准备。
4. 转换格式并附加专辑图片 打开命令提示符窗口，定位到上述文件夹下，按如下命令格式调用FFMpeg执行转换命令，耐心等待命令执行完毕，之后就可以在目标目录中看到转换完成的音乐文件了，下图供参考。
ffmpeg -i $INPUT_FILE -i $ALBUM_FILE -map 0:a -map 1:v -c copy -id3v2_version 3 -acodec libmp3lame -b:a 192k $OUTPUT_FILE # $INPUT_FILE 即你要转换的音乐文件 # $ALBUM_FILE 即指定的专辑封面图片 # $OUTPUT_FILE 即转换完成后要输出的目标文件 至此，你已经掌握了如何将受版权保护的加密音乐文件转换至任何你想要的音乐文件格式这一技能，博主要说的是，FFMpeg的功能丰富且强大，如果感兴趣而且有一定的水平，建议深入研究一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc5252cce6dc31e69de1ed540461b60c/" rel="bookmark">
			GitLab-CI入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部门决定从SVN迁移到GIT之初，我们暂定的是使用Jenkins作为CI/CD的实现，不过秉承实用的思想我们最终决定直接启用GitLab内置的GitLab-CI作为我们目前的CI/CD实现。
1. 概述 GitLab-CI 即为 GitLab Continuous Integration，也就是GitLab自带的持续集成工具。其思想就是每次用户push代码到gitlab上时触发执行.gitlab-ci.yml 脚本，脚本的内容包括了测试，编译，部署等一系列自定义的内容。
与 Jenkins Pipeline 相比，GitLab-CI 更轻，更方便。它直接通过简单 yaml 文件定义 pipeline，相比与 jenkins 复杂的 groovy 语法，GitLab-CI 更简单。正如官方宣传的"Don’t let your tools slow you down"。
2. 配置GitLab-Runner 想要使用GitLab-CI，我们需要安装一些额外的组件GitLab-Runner。GitLab服务本身只负责任务的派发，具体的执行还是得交给Runner，这也符合最基本的设计准则——调度中心和执行分开，避免相互影响，方便迭代更新，也方便扩容。
GitLab Runner可以跑在一个单独的机子上。只需要这个机器需要能够访问GitLab服务本身。不过笔者建议进行单独安装，避免搅和在一起相互影响。软件开发是一个整体，前期偷的那点懒，之后会成倍地还回来。
这里以CentOS为例：
######## 准备工作 # 操作系统版本 $ rpm -q centos-release centos-release-7-7.1908.0.el7.centos.x86_64 # 更改hostname, 让CI执行日志更有辨识度 $ sudo hostname 252Server ######## 安装 # 下载可执行包 wget -O /usr/local/bin/gitlab-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-linux-amd64 # 赋予执行权限 chmod +x /usr/local/bin/gitlab-runner # 创建runner用户 useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash ######## 注册Runner (目的是实现GitLab-Runner与GitLab-CI之间的信息互注册。Runner知道了自己需要操作哪个项目，CI也知道了该runner的存在。刷新Runners settings就可以看到新注册的Runner了。) # 注意以下输入项大部分是可以在之后进行界面化修改的, 所以不用过分担心.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc5252cce6dc31e69de1ed540461b60c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a286d9991c6a547ae25a5f5216164b8f/" rel="bookmark">
			Join
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客：https://blog.csdn.net/leying521/article/details/93197951
inner join(内连接，只有进行连接的两个表中都存在与连接条件相匹配的数据才会被留下来) 。内连接是最常见的一种连接，它也被称为普通连接，而E.FCodd最早称之为自然连接。其中inner可以省略。inner join == join 等价于早期的连接语法。left join 是左外连接(Left Outer Jion)，其中outer可以省略，left outer join是早期的写法。 full outer join 等价 full join ,全外连接。包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行 。在功能上，它等价于对这两个数据集合分别进行左外连接和右外连接，然后再使用消去重复行的并操作将上述两个结果集合并为一个结果集。
当在内连接（join或者inner join）查询中加入条件时，无论是将它加入到join子句，还是加入到where子句，其效果是完全一样的。
但对于外连接情况就不同了。加入的条件在join子句中和在where子句中效果完全不一样。当把条件加入到 join子句时，SQL Server、Informix会返回外连接表的全部行，然后使用指定的条件返回第二个表的行。如果将条件放到where子句中，SQL Server将会首先进行连接操作，然后使用where子句对连接后的行进行筛选。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/585e882aa67d2f5969d8e4e49c944d7e/" rel="bookmark">
			pyecharts快速入门和疫情数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyecharts快速入门和疫情数据可视化 前言 pyecharts 是基于百度echarts的一个python库，能够很好的集成python相关的前端框架，显示出来的图表也十分漂亮。是否还在烦恼matplotlib 不够漂亮？这个库让你不再烦恼。
文章目录 pyecharts快速入门和疫情数据可视化前言pyecharts入门疫情数据可视化一、导入相关工具包 二、数据获取三、数据可视化四、全部代码五、总结 pyecharts入门 这里我用官网的一个例子带着大家快速入门
这是一个画柱状图的例子：首先这是一个链式调用
from pyecharts.charts import Bar from pyecharts import options as opts from pyecharts.globals import ThemeType bar = ( Bar(init_opts=opts.InitOpts(theme=ThemeType.LIGHT))#初始化配置项 .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"]) .add_yaxis("商家A", [5, 20, 36, 10, 75, 90]) .add_yaxis("商家B", [15, 6, 45, 20, 35, 66]) .set_global_opts(title_opts=opts.TitleOpts(title="主标题", subtitle="副标题")) .set_series_opts(label_opts=opts.LabelOpts(font_size=18))) bar.render()#生成html图标 正常调用
bar = Bar(init_opts=opts.InitOpts(theme=ThemeType.LIGHT)) bar.add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"]) bar.add_yaxis("商家A", [5, 20, 36, 10, 75, 90]) bar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/585e882aa67d2f5969d8e4e49c944d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80044aff6f6890e28488f17b4d6f86a0/" rel="bookmark">
			itop4412开发板-QtE4.7-UVC摄像头使用例程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文档主要介绍 iTOP-4412 开发板 QtE4.7 系统下 UVC 摄像头的使用过程。
工程文件是：“iTOP-4412-QtE4.7-UVC_V1.0”（注意版本更新）。用户可以直接运行
工程文件中的“qtcamera”可执行文件。具体过程如下。
1.1 运行测试
通过 U 盘、tftp 或者 nfs 功能把“qtcamera”可执行文件拷贝到开发板，并在可执行文
件的同一目录下使用“./qtcamera -qws”命令，运行该文件。如下图所示。
此时，开发板的屏幕显示如下图所示。
测试完毕。
补充：
本次提供的 UVC 例程只有一个简单的预览功能，用户可以在给好的源码上添加功能。在
虚拟机 ubuntu 的 qtcreator 上打开该工程文件（因为虚拟机 ubuntu 上没有/dev/video4 节
点，所以无法在虚拟机 ubuntu 的 qtcreator 上运行该工程），修改源码之后，通过
“/opt/qt-4.7.1/bin/qmake”、“make”命令编译得到在 iTOP-4412 开发板上运行的可执
行文件。
部分视频观看地址（ 更多视频教程可在B站上搜索‘迅为电子’ ）
iTOP-4412精英版开发板硬件连接https://www.bilibili.com/video/av82341079iTOP4412开发板系统编程前言https://www.bilibili.com/video/av75754003iTOP4412开发板出厂前首次烧写https://www.bilibili.com/video/av76559271iTOP-4412驱动教程三https://www.bilibili.com/video/av74131033?p=3iTOP-4412开发板之如何扩展不同规格LCD屏幕https://www.bilibili.com/video/av75870604项目实战-迅为实战教程介绍https://www.bilibili.com/video/av78601813项目实战-GPS定位简介https://www.bilibili.com/video/BV1BJ411v7VX?p=2项目实战-机车导航-机车导航项目演示https://www.bilibili.com/video/BV1BJ411v7VX?p=1项目实战-机车导航-定制内核显示logohttps://www.bilibili.com/video/BV1BJ411v7VX?p=4项目实战-机车导航-修改安卓开机启动动画https://www.bilibili.com/video/BV1BJ411v7VX?p=5项目实战-云服务器智能家居-简介https://www.bilibili.com/video/BV1WE411w7jG项目实战-图像识别项目-演示和介绍https://www.bilibili.com/video/BV157411c7s项目实战-图像识别项目-移植opencvhttps://www.bilibili.com/video/BV157411c7sc?p=6 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0205073493347c81bd872b4ddd9a61b/" rel="bookmark">
			weblogic12c服务器的数据源配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.进入到weblogic的控制台
weblogic地址/console即可进入，然后登陆。
2.点击服务--&gt;数据源
3.新建数据源
4.设置jndi名称
5.选择驱动程序
6.事务处理默认就可以
7.连接池配置
8.数据源概要，检查配置是否正确
9.部署到目标服务器上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ecbff54bc6f041da274c12407bf4bf0/" rel="bookmark">
			数据分析学习总结笔记04：异常值处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分析学习总结笔记04：异常值处理 1 异常值概述2 如何判断异常值2.1 简单的统计分析2.2 3δ原则2.3 四分位数检验/箱型图分析2.4 格拉布斯检验2.5 基于模型检测2.6 基于距离检测2.7 基于密度检测 3 如何处理异常值 1 异常值概述 数据存在异常值、缺失值和重复值是数据清洗工作中主要可能遇到的三个问题。
异常值是数据中的极端的观测值，即在数据集中存在不合理的值，又称离群点。
在统计学中异常值（outlier）定义为一组测定值中与平均值的偏差超过两倍标准差的测定值，与平均值的偏差超过三倍标准差的测定值，称为高度异常的异常值1。
一批数据中的异常值值得关注，忽视异常值的存在是十分危险的，不加剔除地把异常值包括进数据的计算分析过程中，对结果会带来不良影响；重视异常值的出现，分析其产生的原因，常常成为发现问题进而改进决策的契机。
响应变量中的异常值：若标准化残差的绝对值大于2，对应的观测点称为异常点。
预测变量中的异常值：若第i个观测点的杠杆值hii大于2(p+1)/n，则称该观测点为高杠杆点。 如果删除一个观测点会导致拟合模型的实质性变化，即系数估计值、拟合值和检验值等发生较大变化，则称这个点为强影响点。
2 如何判断异常值 对于异常值的判断，通常使用的方法有很多种，本文主要介绍以下7种方法。
2.1 简单的统计分析 当我们拿到数据后可以对数据进行一个简单的描述性统计分析，譬如最大最小值可以用来判断这个变量的取值是否超过了合理的范围，不合常理的为异常值。比如，对成绩这个属性进行规约：成绩的区间在[0:100]，如果样本中的成绩不在该区间范围内，则表示该值属于异常值。
2.2 3δ原则 若数据服从正态分布：
根据正态分布的定义可知，距离平均值3δ之外的概率为 P(|x-μ|&gt;3δ) &lt;= 0.003 ，这属于极小概率事件，在默认情况下我们可以认定，距离超过平均值3δ的样本是不存在的。 因此，当样本距离平均值大于3δ，则认定该样本为异常值。
若数据不服从正态分布：
当数据不服从正态分布，可以通过远离平均距离多少倍的标准差来判定，多少倍的取值需要根据经验和实际情况来决定。 2.3 四分位数检验/箱型图分析 将所有数据按大小排序，找到其中上四分位数UQ(Q3)和下四分位数LQ(Q1)，计算其差值IQR=UQ-LQ（中四分位范围，IQR，即内50%范围），所有在 [LQ-1.5IQR，UQ+1.5IQR] 范围之外的数据都可以判定为异常值。
将其形象化的方式就是通过绘制箱型图进行直观判定。箱形图（Box-plot）又称为盒须图、盒式图或箱线图，是一种用作显示一组数据分散情况资料的统计图。因形状如箱子而得名。它主要用于反映原始数据分布的特征，还可以进行多组数据分布特征的比较。
箱形图的绘制依靠实际数据，不需要事先假定数据服从特定的分布形式，没有对数据作任何限制性要求，它只是真实直观地表现数据形状的本来面貌；另一方面，箱形图判断异常值的标准以四分位数和四分位距为基础，四分位数具有一定的耐抗性，多达25%的数据可以变得任意远而不会很大地扰动四分位数，所以异常值不能对这个标准施加影响，箱形图识别异常值的结果比较客观。由此可见，箱形图在识别异常值方面有一定的优越性。
2.4 格拉布斯检验 格拉布斯准则是以正态分布为前提的，理论上较严谨，使用也方便。
格拉布斯的测试一次检测到一个异常值。从数据集中删除该异常值，并且迭代测试直到没有检测到异常值。但是，多次迭代会改变检测概率，并且测试不应该用于六个或更少的样本大小(n&gt;6)，因为它经常将大多数点标记为异常值。
该方法具体可以详见该博主。
2.5 基于模型检测 具体操作就是先建立一个数据模型，异常是那些同模型不能完美拟合的对象；如果模型是簇的集合，则异常是不显著属于任何簇的对象；在使用回归模型时，异常是相对远离预测值的对象。
优点：有坚实的统计学理论基础，当存在充分的数据和所用的检验类型的知识时，这些检验可能非常有效。缺点：对于多元数据，可用的选择少一些，并且对于高维数据，这些检测可能性很差。 2.6 基于距离检测 通常可以在对象之间定义邻近性度量，异常对象是那些远离其他对象的对象。
优点：简单便捷。缺点：首先，基于邻近度的方法需要O(m2)时间，大数据集不适用；其次，对参数的选择较为敏感；其三，同时不能处理具有不同密度区域的数据集，因为它使用全局阈值，不能考虑这种密度的变化。 2.7 基于密度检测 当一个点的局部密度显著低于它的大部分近邻时才将其分类为离群点。适合非均匀分布的数据。
优点：给出了对象是离群点的定量度量，并且即使数据具有不同的区域也能够很好的处理。缺点：与基于距离的方法一样，这些方法必然具有O(m2)的时间复杂度。对于低维数据使用特定的数据结构可以达到O(mlogm)。参数选择困难。虽然算法通过观察不同的k值，取得最大离群点得分来处理该问题，但是，仍然需要选择这些值的上下界2。 3 如何处理异常值 异常值的处理方法常用有四种：
（1）删除含有异常值的记录，尤其需要剔除高度异常的异常值；
（2）将异常值视为缺失值，交给缺失值处理方法来处理；
（3）用平均值来修正；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ecbff54bc6f041da274c12407bf4bf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa950d40f80c4f5f233a766c55abb2a7/" rel="bookmark">
			Selenium反反爬-滑块验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滑动滑块的反爬 即使把window.navigator.webdriver（js检测特征之一）设置为"undefined"了，还是不能通过。
这时候全局搜索一下js，如果网站js里面有一段代码，那很可能就是对selenium的webdriver进行验证的了：
1、chromedriver.exe的反爬： !function(n) { function r() { return "$cdc_asdjflasutopfhvcZLmcfl_"in u || f.webdriver } 可以把webdriver.exe拖动到ide里面去看看，搜索这个字符串“$cdc_asdjflasutopfhvcZLmcfl_”。可以找到真的有在这里面。
字符串上面有个注释：|key| is a long random string, unlikely to conflict with anything else.（|键|是一个很长的随机字符串，不太可能与其他任何字符串发生冲突。）
$cdc_asdjflasutopfhvcZLmcfl_特征
webdriver.exe里面同样有这段一样的字符串，可以用pycharm打开搜索看到，但不能够用pycharm来修改，否则会使这exe文件无法使用。
修改方法：
win平台下可以使用notepad++来打开，直接修改，然后关闭保存就好了。
这里把“$cdc_asdjflasutopfhvcZLmcfl_”更改为“$chr_fajfjafjasifjsiaSsdjdl_”。
linus平台可用vim来进行修改。
2、window.navigator.webdriver反爬 一开始的js代码里面还有一段“|| f.webdriver”，或者是f的webdriver属性，根据测试，这正是浏览器的window.navigator.webdriver属性，正常的浏览器时这样的。
打开webdriver浏览器，不进行任何设置是这样的：
下面来添加一下初始设置选项。 1、关闭“正受到自动测试软件的控制“的显示
# chrome_options 初始化选项 chrome_options = webdriver.ChromeOptions() # 设置浏览器初始 位置x,y &amp; 宽高x,y chrome_options.add_argument(f'--window-position={217},{172}') chrome_options.add_argument(f'--window-size={1200},{1000}') # 关闭自动测试状态显示 // 会导致浏览器报：请停用开发者模式 # window.navigator.webdriver还是返回True,当返回undefined时应该才可行。 chrome_options.add_experimental_option("excludeSwitches", ['enable-automation']) 加了这段代码后会提示：”请停用开发者模式“。
那我们继续关闭开发者模式，并测试一下网站。
2、关闭开发者模式
# 关闭开发者模式 chrome_options.add_experimental_option("useAutomationExtension", False) chrome.get('www.baidu.com') 可以看到这次浏览器没有受控制的提示了，但是.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa950d40f80c4f5f233a766c55abb2a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e622e098bb6a55b257994862b71f1c27/" rel="bookmark">
			重定向时cookie丢失问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景如下图：
在这个过程中A网站首页无法获取到cookie，在网上查找解决办是：
在B设置Cookie时，设置domain属性，并且将domain设置为二级域名，即完整域名为www.test.com，则设置domain为.test.com，这样可以防止Cookie丢失。
但是在测试环境中，有可能A、B在两个不同的主机中，可能没有进行域名的配置，这样的话即使使用了上面的方法也是无法获取到Cookie的，我们需要对host文件进行修改，需要在本地添加上A与B的ip域名映射，A在连接B时也要使用域名，且A所在机器也要配置上ip域名映射。A、B的二级域名要相同才能成功获取到Cookie。如A的域名www.test.com，B的域名为b.test.com。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8feb25f866998e8d3efe32431ff4610/" rel="bookmark">
			处理机调度—调度算法（FCFS、SJF、SRT、RR）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、FCFS
算法原理：first come first served，先到达进程先执行
编程思想：按照到达时间排序，顺序执行
2、SJF
算法原理：shortest job first，从就绪的队列中选择服务时间最短的进程执行
编程思想：按照到达时间、服务时间排序，根据服务时间从小到大的顺序判断进程是否就绪（设置就绪标识、进程完成标识）
3、SRT
算法原理：shortest remaining time，选择预期时间最短的进程。类似于SJF，SJF是选择就绪队列中服务时间最短的进程执行（一直执行到结束）；SRT强化了SJF的强占机制，即有新的进程就绪，且新进程的服务时间小于当前进程的剩余时间，转到新的进程执行。
编程思想：利用vector建立两个容器，当一个新进程就绪时（系统时间等于到达时间），把新的进程放到容器内。判断容器内每个进程仍需要的时间，选择所需时间最小的进程执行，所需执行时间为零时，从容器中拿出。
4、RR
算法原理：round robin，基于时钟的抢占策略，基于FCFS算法。
编程思想：在每一个时刻执行之前，判断该时刻加上时间片之后是否有新的进程就绪（system_time+capacity&gt;=process.arrive_time），如果有新的进程则放到队列的末尾，然后从队首执行，该时间片执行结束之后，把队首放到队尾。
PS：具体实现程序点击蓝字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8accf8120cc550e3fb65f2fe67b5de/" rel="bookmark">
			多种ubuntu后台运行与查看程序的详细方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu后台运行与查看程序的多种详细方法 跑大网络时，经常需要挂网络应该怎么挂
方法1：使用&amp;
方法2：使用nohup
方法3：使用nohup与&amp;组合等（见nohup中第6部分的示例介绍）
方法4：使用screen
一、使用&amp; 一般在执行shell命令的时候我们在命令的后面加上一个‘&amp;’，这样就可以使得该程序在后台运行。
&amp;为后台运行意思，一般在执行命令后面加上&amp;便可 比如：
python A.py &amp; 但是&amp;有一定局限性：
当程序运行起来之后依旧会再次在shell中输出打印信息，shell依旧被占用，关闭shell则程序退出；这个时候我们可以使用ctrl+z命令，使得这个信息消失，可以做别的事情，但是关闭shell的时候程序依旧会退出，因此这些办法都不能解决问题。
由此需要nohup来解决。
二、nohup的介绍与使用 1.简介 nohup的意思就是：永久执行，是no hang up的缩写，指不间断，不挂断。运行一个进程的时候，不想让其在你退出账号时关闭，即可用nohup。nohup用于不挂断地运行命令。nohup在不规定的情况下，所以输出内容会到nohup.out中。
nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响运行，注意了nohup没有后台运行的意思；&amp;是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出。
2.相关介绍（对后面命令书写有作用） 操作系统中有三个常用的流：
0标准输入流 stdin,用户键盘输入的内容1标准输出流 stdout ，输出到显示屏的内容2标准错误流 stderr，报错内容 一般当我们用 &gt;result.txt，实际是 1&gt;result.txt的省略用法；&lt; result.txt ，实际是 0 &lt; result.txt的省略用法。
3.语法（用法） 语法：nohup Command [ Arg … ] [　&amp; ]
例如：
nohup python A.py &amp; Command 为我们要执行的指令，无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。
如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。
退出状态出口值：
126 可以查找但不能调用 Command 参数指定的命令。 127 nohup 命令发生错误或不能查找由 Command 参数指定的命令。 否则，nohup 命令的退出状态是 Command 参数指定命令的退出状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8accf8120cc550e3fb65f2fe67b5de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9eb30db1bb409429313714c2966bf29/" rel="bookmark">
			【2020春招记录】 吉比特游戏研发笔试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		心累笔试 形式
一个半小时，20道选择题，6道读程序写结果，2道编程题。选择题：两三道智力题，一道数据库，一道网络，好几道数据结构，几道算法。阅读程序：十五分钟冲完，乱七八糟不知道看出来啥了编程：一道判断素数，另一道给15位数随机组合被m整除个数，没想出来打了60暴力。 这笔试吐了，时间短而且全是基础知识点，不算没学过的操作系统&amp;计网，也够受了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/072ec2d588b73a5b81d67c472078b77a/" rel="bookmark">
			tf.logging用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用来记录模型训练过程的一些参数。
常用的几项： tf.logging.set_verbosity(tf.logging.INFO)
设计日志级别. 控制那些日志打印到屏幕上。
tf.logging.info(msg, *args, **kwargs)
记录INFO级别的日志. args 是配合msg中的占位符用的. 比如 info("I have been in love with %s for %d years.","yichu",7)
tf.logging.log_every_n( level, msg, n, *args)
改行代码每执行n次输出一次. 打印的时机分别是(1, n+1, 2n+1,…).
举例说明： def main(): tf.logging.set_verbosity(tf.logging.INFO) tf.logging.info("I have been in love with %s for %d years.", "yichu", 7) # 因为set_verbosity这里只设置了INFO级别的日志，所以只会打印上一条I have...years这一条， # 不会打印下面这一行this is ... info这一条，如果希望输出INFO和DEBUG2个级别的信息， # 那么需要再次调用tf.logging.set_verbosity(tf.logging.DEBUG)才可以打印info和debug2个级别。 tf.logging.debug("this is a debug info") train_op = tf.train.GradientDescentOptimizer(learning_rate=LEARNING_RATE).\ minimize(loss_tensor, global_step=tf.train.create_global_step()) with tf.Session() as sess: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/072ec2d588b73a5b81d67c472078b77a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5750c2811a81eb840b1320729e804269/" rel="bookmark">
			tf.flags用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TF中使用flags来定义解析命令行参数，用法类似于Python中的argparse。尤其在我们编写shell脚本训练代码的时候比较方便，比如某shell脚本：
python run_classifier.py \ --task_name=$TASK_NAME \ --do_train=true \ --do_eval=true \ --data_dir=$GLUE_DATA_DIR/$TASK_NAME \ --vocab_file=$ALBERT_CONFIG_DIR/vocab.txt \ --bert_config_file=$ALBERT_CONFIG_DIR/albert_config_tiny.json \ --init_checkpoint=$ALBERT_TINY_DIR/albert_model.ckpt \ --max_seq_length=128 \ --train_batch_size=64 \ --learning_rate=1e-4 \ --num_train_epochs=5.0 \ --output_dir=$CURRENT_DIR/${TASK_NAME}_output/ 在运行run_classifier.py脚本的时候可以动态设置task_name， do_train等的值。
tf.flags只能设置int,string,float,bool四种类型的值，用法是：
1. 调用flags = tf.flags;
2. 开始赋值；
3. 运行tf.app.run()
举例说明：
import tensorflow as tf #1、调用tf.flags: 第一个是参数名称，第二个参数是默认值，第三个是参数描述 tf.flags.DEFINE_string('str_name', 'def_v_1',"descrip1") tf.flags.DEFINE_integer('int_name', 10,"descript2") tf.flags.DEFINE_boolean('bool_name', False, "descript3") # tf.flags.FLAGS是一个FlagValuesWrapper的实例化变量 FLAGS = tf.flags.FLAGS #必须带参数，否则：'TypeError: main() takes no arguments (1 given)'; main的参数名随意定义，无要求 def main(_): # 这里就是使用参数值的方法 print(FLAGS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5750c2811a81eb840b1320729e804269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99c3bc92a09c0194f63bfff0c49c172/" rel="bookmark">
			MethodHandles的机理——java学习总结（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MethodHandles在java的作用就相当于函数指针在C++中的作用，允许java动态引用变量、方法，并调用它们。 1.与C++函数指针的相似 参照一下C++代码
void sort(int list[],const int size,int (*compare)(int,int))； C++中可以传递一个函数指针（入口）作为参数 而Java中却不行，只能实现一个带有compare()方法的接口Comparator 以实现把这个接口作为参数
void sort(List list,Comparator c)； MethodHandle的出现就使java用上了类似于函数指针的方法。
2.MethodHandles的用处（优势） 1.java是静态类型语言，即在编译期就进行类型检查
obj.println("test"); 对于这段代码，Java在编译期就会检查obj是否是printStream类型范围，而对于javascript等动态语言则不会检查，它直到运行期间才会进行类型判断，也就是可以根据用户输入或其他运行时因素确定obj的类型
2.MethodHandles使java可以动态引用变量、方法，并调用他们，即在运行期再进行类型检查，并确定调用的对象，而不必在编译期就进行类型检查。
3.案例
public class MethodHandleTest { static class classA { public void println(String s) { System.out.println(s); } } private static MethodHandle getPrintMH(Object reciever) throws Throwable { //方法的参数类型 返回值类型 MethodType mt = MethodType.methodType(void.class, String.class); //findVirtual找到Object中的该方法,例如下面的System.out和classA,即找到上述两者的println //MethodHandles.lookup()是用于创建方法句柄的工厂对象 return MethodHandles.lookup().findVirtual(reciever.getClass(), "println", mt).bindTo(reciever); //bindTo的作用：调用时，绑定句柄将给定值reciever作为目标的新前导参数插入。 //也就是相当于下面的invokeExact(reciever,"test") } public static void main(String[] args) throws Throwable { //随机选定一个接收者，这是在运行期间发生的 Object obj=System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a99c3bc92a09c0194f63bfff0c49c172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10395bde4e10bc804894b132dd8e1ba/" rel="bookmark">
			1. SpringBoot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 一.了解SpringBoot1. springBoot2. springBoot的特点 二.SpringBoot入门案例1. 创建一个工程2.导入依赖3. 创建一个引导类3. 编写一个controller4. 注解5. springboot 配置文件5.1 properties5.2 yml 三.SpringBoot原理1.springBoot是如何帮助我们创建对象的2.springBoot的工作原理 四.Springboot实战1. 日志控制--Lombok2. 静态资源访问3. 拦截器设置4. 整合mybatis1.配置2.通用mapper 五.SpringBoot整合常用的框架1.整合Thymeleaf1.导入依赖2.编写静态资源2.编写controller 2.整合rabbitMq 六.springBoot项目部署1.1在项目中添加一个插件1.2执行package命令打出一个jar1.3直接使用java -jar 运行jar项目 一.了解SpringBoot 1. springBoot 最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。
2. springBoot的特点 开箱即用 - 如果需要使用到一个框架时直接添加一个带有starter（启动器）的依赖就可以无需任何xml约定大约配置 SpringBoot已经配置好了很多默认项 二.SpringBoot入门案例 1. 创建一个工程 2.导入依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;!-- 目的：约定springboot的版本--&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 3. 创建一个引导类 要有@SpringBootApplication注解
引导类是固定存在的 package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f10395bde4e10bc804894b132dd8e1ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4fe28f0f5a020774339d8d87b16af4/" rel="bookmark">
			spring中/和/*和/**的区别，简介明了搞清楚怎么用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区别是什么？ 请一句话搞明白下面的文字意思，理解可就可以走人。
/ 和 /*区别 / 拦截所有请求 包括静态资源和动态请求 但是不拦截jsp /*拦截所有请求 包括静态资源和动态请求 也拦截jsp 区别就在于/ 不拦截jsp /*拦截jsp /* 和 /** 区别 /**的意思是所有文件夹及里面的子文件夹 /*是所有文件夹，不含子文件夹 注意点案例 理解下面的案例有助于理解如何使用
场景：当我在客户端调用URL：/user/list然后返回user.jsp视图，
当配置的是/：DispathcherServlet拿到这个请求然后返回对应的controller，
然后依据Dispather Type为Forward类型转发到user.jsp视图，即就是请求user.jsp视图(/user/user.jsp)，此时Dispather没有拦截/user/user.jsp，
因为此时你配置的是默认的/，就顺利的交给ModleAndView去处理显示了。当配置的是/*：DispathcherServlet拿到这个请求然后返回对应的controller，然后通过Dispather Type通过Forward转发到user.jsp视图，
即就是请求user.jsp视图(/user/user.jsp)，此时Dispather已经拦截/user/user.jsp，Dispatcher会把他当作Controller去匹配，没有匹配到就会报404错误。 结论：在配置视图的时候尽量用/这种方式。
结论 通过注意点案例我们大概可以理解为什么要有两个的区分。配置/*是为了直接访问静态资源，配置/是为了避免内部forward到视图层时被拦截。所以根据业务决定如何具体控制。另外，无论是拦截器，过滤器，还是安全等本质上都是一样的。上述规则一样有效。
参考：
https://www.cnblogs.com/searain/articles/8391773.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90edfa14b3f351152d3ce530f5de97df/" rel="bookmark">
			Jpa @Query nativeQuery=true
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 "message": "No converter found capable of converting from type [org.springframework.data.jpa.repository.query.AbstractJpaQuery$TupleConverter$TupleBackedMap] to type [com.cocabit.jwtdemo.vo.StudentVo]",
@Entity @Data public class Student { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private String address; } @Data public class StudentVo { private String name; } Student对应数据库StudentVo展示用 通过在Repository中使用@Query的nativeQuery查询
public interface StudentRepostory extends JpaRepository&lt;Student, Long&gt; { @Query(nativeQuery = true,value="select name as name from student") List&lt;StudentVo&gt; findName(); } 调试一下
发生了什么。
用Student试了下，是OK的。
解决方案，
public interface StudentVo { String getName(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d44644e50b835d0db8d7251e612950/" rel="bookmark">
			pgsql命令行直接输入密码登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 我怎么登录，都要求输入密码，如图：
查看如下参数
Connection options:
-h, --host=HOSTNAME database server host or socket directory (default: “local socket”)
-p, --port=PORT database server port (default: “5432”)
-U, --username=USERNAME database user name (default: “root”)
-w, --no-password never prompt for password
-W, --password force password prompt (should happen automatically)
发现-W根本不是密码的输入！！！
命令参数解释 没办法，我查看了所有参数如下，竟然没有指定参数来输入密码！！！
[root@localhost ~]# psql --help psql is the PostgreSQL interactive terminal. Usage: psql [OPTION]... [DBNAME [USERNAME]] General options: -c, --command=COMMAND run only single command (SQL or internal) and exit -d, --dbname=DBNAME database name to connect to (default: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07d44644e50b835d0db8d7251e612950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1f8687055d3c8b828029e0b429a282/" rel="bookmark">
			求候选码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求函数的最小依赖集 第一步：F右边单一化
得到F1={A→B，A→C，ABD→C，ABD→E，E→D}
第二步：逐个去掉X→A依赖后，设剩下函数依赖集为G，求属性集X关于G的闭包，如果闭包包含右边属性A，则去掉该函数依赖。
A→B：(A)+=AC，不包含B，保留。
A→C：(A)+=AB，不包含C，保留。
ABD→C：(ABD)+=ABCDE，包含C，去掉。
ABD→E：(ABD)+=ABCD，不包含E，保留。
E→D：(E)+=E，不包含D，保留。
(在这里，求闭包的时候，不能再用前面去掉的函数依赖了，所以最小依赖集不唯一，写出一个即可。)
所以F2={A→B，A→C，ABD→E，E→D}
第三步：对左边属性单一化，X=B1B2...Bi，逐个用B1→A替代原依赖X→A，判断属性集(X-B1)关于F的闭包，如果包含A则用X-B1代替X。
ABD→E：A→E，求(BD)+=BD，不包含E，不冗余
B→E，求(AD)+=ABCDE，包含E，存在冗余则使用AD→E替换ABD→E
D→E，求(AB)+=ABC，不包含E，不冗余
所以F3={A→B，A→C，AD→E，E→D}
继续第三步
AD→E：A→E，求(D)+=D，不包含E，不冗余
D→E，求(A)+=ABC，不包含E，不冗余
所以最小依赖集Fm={A→B，A→C，AD→E，E→D}
求候选码 按以下步骤求候选键：
1.只在FD右部出现的属性，不属于候选码;
2.只在FD左部出现的属性，一定存在于某候选码当中;
3.外部属性一定存在于任何候选码当中;
4.其他属性逐个与2,3的属性组合，求属性闭包，直至X的闭包等于U,若等于U,则X为候选码。
如果X是L里元素的组合起来的属性组合，X闭包是U，则X是唯一候选码
举个例子
按照上述求法可求得
L :H S
R:G
N:C R T 单个的H 或S的闭包不是全集，所以将他们组合起来是HS ，HS的闭包是全集了，所以是唯一候选码了，但是还可以组合成HSC
这时候它的真子集 HS 也可以唯一标识一个元组，所以HSC就不是候选码了。
候选码的定义：若关系中的一个属性或属性组的值能够唯一地标识一个元组，且他的真子集不能唯一的标识一个元组，则称这个属性或属性组做候选码。
例1：R&lt;U,F&gt;,U=(A,B,C,D,E,G),F={AB--&gt;C,CD--&gt;E,E--&gt;A.A--&gt;G},求候选码。
因G只在右边出现,所以G一定不属于候选码;而B,D只在左边出现,所以B,D一定属于候选码;BD的闭包还是BD,则对BD进行组合,除了G以外,BD可以跟A,C,E进行组合
先看ABD ABD本身自包ABD,而AB--&gt;C,CD--&gt;E,A--&gt;G,所以ABD的闭包为ABDCEG=U 再看BDC CD--&gt;E,E--&gt;A,A--&gt;G,BDC本身自包,所以BDC的闭包为BDCEAG=U
最后看BDE E--&gt;A,A--&gt;G,AB--&gt;C,BDE本身自包,所以BDE的闭包为BDEAGC=U
因为(ABD)、(BCD)、(BDE)的闭包都是ABCDEG所以本问题的候选码有3个分别是ABC、BCD和BDE
例2：R&lt;U,F&gt;,U=(A,B,C),F={AB--&gt;C,C--&gt;B},求候选码。
因为A只出现在左边，所以A一定是候选键。A的闭包还是A，则对A进行组合，可以和B,C进行组合。
首先看AB，AB本身自包AB，而AB--&gt;C，所以AB的闭包是ABC=U。
再看AC，AC本身自包AC，而C--&gt;B，所以AC的闭包是ABC=U。
因为AB,AC的闭包都是ABC，也就是U，所以候选键是AB，AC。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124ff70b3c14719e324f00619c95b6f4/" rel="bookmark">
			流水表与拉链表区分；增量表，快照表与全量表区分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考博客：
https://www.cnblogs.com/wqbin/p/10223988.html
https://blog.csdn.net/sheep8521/article/details/89187601
https://blog.csdn.net/qq_21159963/article/details/86761589
全量表存放最新记录，但是不能查历史。快照表可以查看历史记录，但是存储消耗大。拉链表既可以满足查看历史记录，又可以减少存储消耗。在拉链表基础上当需要知道更细的修改记录时，需查看流水表。增量表适合订单等存储，而流水表更倾向于用户信息等的变更，两者应用环境不同。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0e29cc08b27a9f5127ed6b3ebc43f2/" rel="bookmark">
			定义参照完整性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义参照完整性的概念：
现实世界中的实体之间往往存在着某种联系，在关系模型中实体及实体之间的联系都是用关系来描述的，因此可能存在着关系与关系间的引用。
例如：学生实体和专业实体可以用下面的关系模式表示，其中主键用下划线标识：
学生（学号，姓名，性别，年龄，班级编号）
班级（班级编号，班级名称，年级，班级最大人数）
这两个关系之间存在着属性的引用，即学生关系引用了班级关系的主键“班级编号”。显然，学生关系中的“班级编号”值必须在班级关系中确实存在的班级编号，即班级关系中有该班的记录。这也就是说，学生关系中的“班级编号”的取值需要参照班级关系中“班级编号”的取值，“班级编号”是班级关系的主键，在学生关系中“班级编号”是外键。
定义参照完整性约束定义外键与主键之间的引用规则，即外键的取值或为空，或者等于被参照关系中的某个主键的值，需要遵守以下规则：
（1）被参照表已经使用create table语句创建，或者必须是当前正在创建的表，后者称为自参照表，即参照表与被参考表时同一个表；
（2）必须为被参照表定义主键或候选键；
（3）必须在被参照表的表名后面指定列或列名的组合，这个列或列组合必须是被参照表的主键和候选键；
（4）尽管主键是不能够包含空值的，但允许外键中出现空值。这意味着，只要外键的非空值出现在指定的主键中，这个外键的内容就是正确的；
（5）外键对应列的数目必须和被参照表的主键对应列的数目相同；
（6）外键对应列的数据类型必须和被参照表的主键对应的列的数据类型相同；
（7）外键只可以用在使用存储引擎innodb创建的表中，其他引擎不支持外键。
创建表的同时，创建外键约束，参照完整性约束方式定义外键，语法：
（1）列级方式：字段名 数据类型 references 被参照表名（列名）
（2）表级方式：constraint 外键约束名字 foreign key (列名1,…,列名n) references
被参照表(列名1,…,列名n)。
例1：
先创建被参照表tb_class,该表包括班级编号，班级名称，所属院系，年级，班级最大人数，建表如下：
use db_school;
create table tb_class
(
classno char(6) primary key,
classname varchar(20) ,
department varchar(30) ,
grade int,
classnum int
constraint uq_class unique(classname)
);
再创建参照表tb_student，要求以列级参照完整性约束方式定义外键。
create table tb_student
(
studentno char(10) prmiary key,
studentname varchar(20),
sex char(2),
birthday date,
classno char(6) references tb_class(classno)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc0e29cc08b27a9f5127ed6b3ebc43f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78eb2b6c9c586a04fd73fccedd1384c2/" rel="bookmark">
			简单方法解决火狐浏览器主页被篡改/挟持，主页变成垃圾网站的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家在使用浏览器时经常会发现打开浏览器后主页变成了某个垃圾网站的网页，比如：火狐主页和浏览器经常被篡改成桔梗页面，
一、这些问题都是身边的一些软件造成的，有时候你下载一些软件或者浏览一些网页，它们就会推荐你点击，不知不觉点击后就生成了你的主页。由于浏览器主页被劫持原因很多，这里教大家两种如何简单解决火狐主页和浏览器被篡改的问题。只是简单解决，治标不治本，可正常使用。如不能解决，请继续查找有用文章。。。
下图是我的火狐页面被篡改后的情况：打开主页自动变成了桔梗网
二、修改方法
方法一：修改快捷方式
打开狐火浏览器安装目录，新建快捷方式，把原来的快捷方式删掉，新建的快捷方式重命名，这个快捷方式名字可自己随意更改，再在新生成的快捷方式打开火狐就会避免主页被劫持，这里我把新的快捷方式设置为firefoxABC.exe
方法二、修改浏览器设置里的新窗口和标签页
打开火狐浏览器设置、找到主页，然后将新窗口和标签页打开的页面修改为Firefox主页，或空白页，之后重启浏览器
以上两种方法均是简单解决此问题，并没有从根本上解决，只是胜在简单快捷，但缺点明显，如果浏览器升级，可能又会出现页面被挟持，则还要重新创建快捷方式。如果不能解决你的问题，还请继续搜索有关文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82566678aad6c69e322edda0452c592/" rel="bookmark">
			Gmsh网格剖分学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gmsh is a free 3D finite element mesh generator with a built-in CAD engine and post-processor. Its design goal is to provide a fast, light and user-friendly meshing tool with parametric input and advanced visualization capabilities.
Gmsh is built around four modules: geometry, mesh, solver and post-processing. The specification of any input to these modules is done either interactively using the graphical user interface or in ASCII text files using Gmsh’s own scripting language.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d82566678aad6c69e322edda0452c592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a5c084ba70465fe134e4a0830d1eb59/" rel="bookmark">
			Adobe Acrobat Reader DC 2019 (19.8)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件名称：Adobe Acrobat Reader DC
软件版本：19.8.20071.41678
官方网站：https://www.adobe.com
产品主页：https://acrobat.adobe.com
下载页面：https://get.adobe.com/cn/reader/
网盘链接：https://pan.baidu.com/s/14FT8Dc43mRtbR7qRaL7j4A
提取码：7cmg
奥多比（Adobe）的PDF阅读器，用过的都知道，所以不多说。奥多比的尿性是不提供完整的离线下载安装包，要命的是官方给的安装程序下载速度奇慢无比（如果是博主网络辣鸡就当博主没吐槽过这个）不说还非常不稳定，实在忍不了，这里给出最新的离线下载安装包，是博主趁安装程序下载完毕还没自动删除之前拖出来的，需要的自己下载就可以了。
注：由于博主没有安装 Adobe Acrobat Reader，所以附图是 Acrobat Pro 的截图，别较真儿，差不多意思。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/247/">«</a>
	<span class="pagination__item pagination__item--current">248/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/249/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>