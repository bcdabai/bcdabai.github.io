<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7587063366d1696e08b181d87ec1440/" rel="bookmark">
			Linux下mysql主从同步详细配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下mysql主从同步详细配置 1.环境准备 准备两台服务器，一台主服务器(Master)，另一台从服务器(Slave)，然后要保证Master与Slave的版本要相同且Master不能高于Slave的版本，一般稳健的做法都是使其版本相同，因为MySQL不同版本之间的binlog(二进制日志)格式可能会不一样，最后会导致同步出现异常。
介绍先到这里，以下我们先确认两台服务器的信息：
主服务器（master） IP：10.16.195.49 系统：Linux（redhat centos7 64） mysql版本：8.0.17 同步数据库：model_slave 同步帐号：model_slave 同步密码：slave123 从服务器（slave）两台 IP：10.16.195.50/10.16.195.51 系统：Linux（redhat centos7 64） mysql版本：8.0.17 同步数据库：model_slave 2.master服务器配置 1.修改主服务器配置文件
sudo vim /etc/my.cnf [mysqld] # 新增如下 server-id=1 log_bin=/data/mysql/mysql-bin.log expire_logs_days=10 max_binlog_size=100M binlog_do_db=myslave # 如果需要同时同步多个数据库，请另起一行设置binlog_do_db=需要同步的数据库名称 binlog_ignore_db=mysql # 不想同步的数据库 2.保存退出，重启服务
service mysql restart 如果启动失败，通过查看mysql启动失败的日志，从日志内容寻找解决方案。
cat /data/mysql/mysql.log | tail -30 3.查看并记住master当前二进制名和偏移量。
这个操作的目的是为了在从数据库启动后，从这个点开始进行数据的恢复。
mysql&gt; show master status; +---------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +---------------+----------+--------------+------------------+ | mysql-bin.000002 | 155 | model_slave |mysql | +---------------+----------+--------------+------------------+ 1 row in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7587063366d1696e08b181d87ec1440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f45d0b31ab8ee43042628793eb6b5622/" rel="bookmark">
			服务器的日常维护需要做什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在维护服务器的时候一定要小心处理好维护的工作，否则出现错误的话就会影响很大。
软件维护
一、数据库服务
数据库经过长期的运行，需要调整数据库性能，使之进入最优化状态。数据库中的数据是最重要的，这些数据库如果丢失，损失是巨大的，因此需要定期来备份数据库，以防万一。
二、操作系统的维护
操作系统是服务器运行的软件基础，其重要性不言自明。多数服务器操作系统使用Windows 2003或Windows 2008 Server作为操作系统，维护起来还是比较容易的。
在Windows NT或Windows 2003 Server打开事件查看器，在系统日志、安全日志和应用程序日志中查看有没有特别异常的记录。现在网上的黑客越来越多了，因此需要到微软的网站上下载最新的Service Pack(升级服务包)安装上，将安全漏洞及时补上。
三、用户数据
经过频繁使用，服务器可能存放了大量的数据。这些数据是非常宝贵的资源，所以需要加以整理，并刻成光盘永久保存起来，即使服务器有故障，也能恢复数据。
四、网络服务的维护
网络服务有很多，如WWW服务、DNS服务、DHCP服务、SMTP服务、FTP服务等，随着服务器提供的服务越来越多，系统也容易混乱，此时可能需要重新设定各个服务的参数，使之正常运行。
硬件维护
一、除尘
尘土是服务器最大的杀手，因此需要定期给服务器除尘。对于服务器来说，灰尘甚至是致命的。除尘方法与普通PC除尘方法相同，尤其要注意的是电源的除尘。
二、储存设备的扩充
当资源不断扩展的时候，服务器就需要更多的内存和硬盘容量来储存这些资源。所以，内存和硬盘的扩充是很常见的。增加内存前需要认定与服务器原有的内存的兼容性，最好是同一品牌同一规格的内存。如果是服务器专用的ECC内存，则必须选用相同的内存，普通的SDRAM内存与ECC内存在同一台服务器上使用很可能会引起统严重出错。在增加硬盘以前，需要认定服务器是否有空余的硬盘支架、硬盘接口和电源接口，还有主板是否支持这种容量的硬盘。尤其需要注意，防止买来了设备却无法使用。
三、设备的卸载和更换
卸载和更换设备时的问题不大，需要注意的是有许多品牌服务器机箱的设计比较特殊，需要特殊的工具或机关才能打开，在卸机箱盖的时候，需要仔细看说明书，不要强行拆卸。另外，必须在完全断电、服务器接地良好的情况下进行，即使是支持热插拔的设备也是如此，以防止静电对设备造成损坏。
个人工作经验:日常维护的作用在于
(1)知道服务器本身运行情况,保证公司业务顺畅;
(2)在服务器出现异常情况后,从容不迫,胸有成竹。那么,需要做到:
一、针对服务器本身:
a.在官网找到对应型号服务器的页面,下载user guides跟problem determination,过一遍,基础的硬件知识你要懂,比方说这台服务器硬件是如何模块化的,单位里用的IBM x3850,我会去了解它的cpu跟内存模块如何对应,各面板灯的作用,跳线… …在故障灯亮灯后(突然断电),你起码知道如何定位故障。总之,把user guide跟problem determination这两本pdf过一遍。(这两本书是服务器硬件日常维护基础,不会让你成为专家)
b.这台服务器的业务是提供进存销功能并入库,那么,这个进存销的帮助文档你看懂了吗?如果这个软件崩溃了,你要知道错误码记录位置。了解windows server 2003，按需要开系统日志,一样能记录服务器断电、应用软件崩溃返回码等。然后是数据库,微软的sqlserver2005,了解数据库技术,学会基本的sql查询语句,如果有进存销软件写库或读库出错的情况,排除应用问题后,你要会看数据库的报错。
c.了解备份防灾的知识,保存好你的数据(学会自己写脚本备份数据库吧,然后想办法定期把数据拷贝出来)。
d.硬盘的配置是如何做raid的,硬盘故障后该如何更换。
二、服务器运行依托的环境:
a.服务器网络,服务器用了几块网卡,它的配置是什么,网关、掩码你造吗?服务器如何网络布线的,有做标签吗?如果服务器硬件跟软件运行正常,只是网络断了,你知道如何定位吗?网关是什么路由?思科orH3C,配置你备份了吗?如果是网关出问题了,你该如何处理?有方案准备吗?
b.服务器供电,是UPS供电还是市电直供,会用万用表量电位差吗?电源异常可是会导致服务器宕机的。
懂这些不一定能让你在服务器故障时彻底恢复,但绝对能让你增值,如果不想在服务器故障时束手无策,做好应急准备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2219756aba0f31adf0568ac3029986da/" rel="bookmark">
			debug assertion failed line417
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直在网上搜索这个断言错误产生的原因，没找到解决办法……
编译正常，就是调试出问题。尝试了很多方法，后来发现是输入的数据不对！所以遇到这种情况，请查看你要处理的文件是否正确。
走了很多弯路，希望能帮到出现这个问题的人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aed1a2a94e0ceaa19c70178715feca0/" rel="bookmark">
			ubuntu16.04更新清华源并且sudo apt-get update出错的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设置镜像源 使用清华大学开源镜像网站
Ubuntu 的软件源配置文件是 /etc/apt/sources.list。将系统自带的该文件做个备份，将该文件替换为下面内容，即可使用 TUNA 的软件源镜像。
备份：
sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 替换sources.list内容
sudo gedit /etc/apt/sources.list 更新
sudo apt-get update 2.更新出错误 W: GPG 错误：http://ppa.launchpad.net/ubuntu-desktop/ubuntu-make/ubuntu xenial InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 2CC98497A1231595 W: 仓库 “http://ppa.launchpad.net/ubuntu-desktop/ubuntu-make/ubuntu xenial InRelease” 没有数字签名。 N: 无法认证来自该源的数据，所以使用它会带来潜在风险。 N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 这个根据博客解决。
解决办法：
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 2CC98497A1231595 注意最后一串数字字母改成自己的那个失效的：NO_PUBKEY 2CC98497A1231595
运行结果如下：
最后sudo apt-get update就成功啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756ebf8fa3b98ca273736b4d66735019/" rel="bookmark">
			Games101课程笔记_lecture12_几何(网格细分)&#43;Shodow map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Games101课程笔记_lecture12_几何(网格细分）+Shodow map 1 网格细分mesh subdivision1 概念2 loop subdivison3 catmull-Clark Subdivison细分 2 网格简化1 概念2 边坍缩 3 网格正则化4 Shadows Map1 介绍2 实现3 问题 5 总结6 视频 1 网格细分mesh subdivision 1 概念 引入跟多的三角形，
细分两部操作:分出更多的三角形；形状发生变化
2 loop subdivison 不是循环细分，与循环没有任何关系，发明者是loop。
新的顶点的操作：对周围的顶点加权平均得到白点
如何更新旧的顶点：
自己本身就是旧的顶点，一部分保留自己的位置，一部分愿意信息周围的顶点的平均。通过加权的方式来得到
看这个旧的顶点连接的周围的三角形的个数，少就是与自己关系大，少了旧得到自己的关系小。
可以看到loop细分，
先细分，再调整
3 catmull-Clark Subdivison细分 网格有三角形，四边形，loop细分就不可以了。而这个细分是可以做四边行的。
奇异点：度不为4的点。
步骤如下：
经过一次细分后，还有几个奇异点呢？
现在有四个奇异点。
第一次细分后非四边形面都会变成奇异点。以后奇异点就不会增加了
再细分后：
通过平均的方式让整个曲面变的平滑
新的点:
旧 的点：
2 网格简化 1 概念 目的是减少三角形的数量，但是同时要维持基本的形状。
在什么场合下使用不同的三角形数量是有讲究的。
不同场景下选用不同的三角形。
第一和mipmap有关，是在图像层次结构上的。
第二和几何的层次结构是很难做的
不同三角形数量之间的过渡是非常难的。
2 边坍缩 如下:求平均好结果不对
二次误差度量：二次误差，要求的点到相关点的距离平方和最小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756ebf8fa3b98ca273736b4d66735019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93fc70ef6232869dfb5e088712395759/" rel="bookmark">
			Linux 删除当前文件夹下的所有文件和文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rm -rf *
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691304074395838604cceb52665abd64/" rel="bookmark">
			攻防世界 cgpwn2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乍一看是个普通的溢出，但是没有给binsh字符串，我就想到bugku pwn4里面也是没有字符串，用的$0做字符串，也达到binsh的效果
可是一看只有$么得$0…
然后我就开动脑筋，这回还真没看别人的wp，自己想的，可喜可贺
我灵机一动，，前面输入名字是什么玩意，，点进去name一看在bss段上，，那不就可以找到了，他也没开pie
第一次输入/bin/sh不就完了，然后第二次溢出覆盖返回地址的时候把这个地址传进去
完美
又一道简单题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d3220bddfb6f883c93348494cb990b/" rel="bookmark">
			python opencv视频抽帧保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding:utf8 -*- import cv2 import os import time # 保存图片的路径 video_path = r'D:\underwater_object_detection\all_video' savedpath = r'D:\underwater_object_detection\video_picture' video_list = os.listdir(video_path) # 保存图片的帧率间隔 count = 750 i = 0 j = 0 for index, video_name in enumerate(video_list): video_path_ = os.path.join(video_path, video_name) # 开始读视频 videoCapture = cv2.VideoCapture(video_path_) print("正在处理第{}个视频，总共{}个视频".format(index+1, len(video_list))) while True: success, frame = videoCapture.read() i += 1 if (i % count == 0): # 保存图片 j += 1 savedname = 'video_' + str(j) + '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84d3220bddfb6f883c93348494cb990b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95539bd940594b280e9c747e4830b70c/" rel="bookmark">
			DM日期时间函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ADD_DAYS(data,n):返回日期 date加上相应天数n后的日期值。n可以是任意整数，date是日期类型(DATE)或时间戳类型(TIMESTAMP)，返回值为日期类型(DATE)。
select ADD_DAYS(date '2020-03-30',2);
2.ADD_MONTHS(date,n):返回日期 date加上n个月的日期时间值。n可以是任意整数，date是日期类 型(DATE)或时间戳类型(TIMESTAMP)，返回类型固定为日期类型(DATE)。如果相加之后的结果日期中月份所包含的天数比date日期中的日分量要少，那么结果日期的该月最后一 天被返回。
select ADD_MONTHS(date '2020-01-31',1);
3.ADD_WEEKS(date,n):返回日期 date加上相应星期数n后的日期值。n可以是任意整数，date 是日 期类型(DATE)或时间戳类型(TIMESTAMP)，返回类型固定为日期类型(DATE)。 select ADD_WEEKS(date '2020-3-19',1);
4.CURDATE()/CURRENT_DATE：返回当前的日期。
5. CURTIME()/CURRENT_TIME/LOCALTIME (n):返回当前时间。
select CURTIME(); 6.CURRENT_TIMESTAMP(n):返回当前带会话时区的时间戳，结果类型为TIMESTAMP WITH TIME ZONE。 参数：n：指定毫秒的精度。取值范围0-6，默认为6。 SELECT CURRENT_TIMESTAMP();
7.DATEADD(datepart,n,date): 向指定的日期date加上n个datepart指定的时间段，返回新的timestamp 值。datepart可以为YEAR(缩写YY或YYYY)、QUARTER(缩写QQ或Q)、MONTH(缩写 MM或M)、DAYOFYEAR(缩写DY或Y)、DAY(缩写DD或D)、WEEK(缩写WK或WW)、HOUR(缩 写HH)、MINUTE(缩写MI或N)、SECOND(缩写SS或S)和MILLISECOND(缩写MS)。 8.DATEDIFF/BIGDATEDIFF(datepart,date1,date2):返回跨两个指定日期的日期和时间边界数。
9.DATEPART/DATE_PART(datepart,date) ：返回代表日期 data 的指定部分的整数。
10.DAYNAME(date)：返回日期对应星期几。
select DAYNAME(date '2020-03-19');
11.DAYOFMONTH(date):返回日期是当月的第几天。
select DAYOFMONTH(date '2020-03-19');
12.DAYOFWEEK(date)：返回日期是当前周第几天。
13.DAYOFYEAR(date):返回日期是当年第几天。
14.DAYS_BETWEEN(dt1,dt2):返回两个日期相差天数。
15.EXTRACT(dtfield FROM date):：EXTRACT从日期时间类型或时间间隔类型的参数date中抽取dtfield对应的 数值，并返回一个数字值。如果date是NULL，则返回NULL。Dtfiled 可以是YEAR、 MONTH、DAY、HOUR、MINUTE、SECOND。对于 SECOND 之外的任何域，函数返回整数， 对于SECOND返回小数。 16.GETDATE(n)/NOW(n):返回系统的当前时间戳。
select GETDATE();
17.GREATEST(n1,n2,n3):求n1、n2和n3中的最大日期。
18.GREAT (n1,n2):求n1、n2中的最大日期。 19.HOUR(time):返回时间中的小时值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95539bd940594b280e9c747e4830b70c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f95d2ed3fb861fd5d067666a6146acc/" rel="bookmark">
			JavaScript中cookie的路径(path)和域(domain)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cookie虽然是由一个网页所创建，但并不只是创建cookie的网页才能读 取该cookie。在默认情况下，与创建cookie的网页在同一目录或子目录下的所有网页都可以读取该cookie。但如果在这个目录下还有子目录，要 使在子目录中也可以访问，则需要使用path参数设置cookie，语法如下：
document.cookie="name=value; path=cookieDir";
如果要使cookie在整个网站下可用，可以将cookieDir指定为根目录，示例如下：
document.cookie="userId=320; path=/";
上面所说都指的是在同一个目录中的访问，可是要想在不同虚拟目录中访问则要另外想办法来解决这个问题。但是path不能解决在不同域中访问cookie的 问题。在默认情况下，只有和设置cookie的网页在同一个Web服务器的网页才能访问该网页创建的cookie。但可以通过domain参数来实现对其 的控制，其语法格式如下：
document.cookie="name=value; domain=cookieDomain";
具体代码如下，直接运行即可：
设置路径：
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;设置cookie的路径&lt;/title&gt;
&lt;script language="javascript" type="text/javascript"&gt;
&lt;!--
var now=new Date();
now.setDate(now.getDate()+1);
var cookies="userName="+escape("哈哈")+";expires="+now.toString()+";path=/";
document.cookie=cookies;
document.write("cookie文件中的内容为：&lt;br&gt;",unescape(document.cookie));
--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
设置域：
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;设置cookie的路径&lt;/title&gt;
&lt;script language="javascript" type="text/javascript"&gt;
&lt;!--
var now=new Date();
now.setDate(now.getDate()+1);
var cookies="userName="+escape("哈哈")+";expires="+now.toString()+";path=/; domain=.baidu.com";
document.cookie=cookies;
document.write("cookie文件中的内容为：&lt;br&gt;",unescape(document.cookie));
--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/addc25394172319882775ee30a9fece9/" rel="bookmark">
			Android input输入设备键值从底层到应用层的映射流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android : 输入设备键值从底层到应用层的映射流程 Android input key 设备键值上报及映射流程
一、Android输入子系统简介：
Android输入事件的源头是位于/dev/input/下的设备节点，而输入系统的终点是由WMS管理的某个窗口。最初的输入事件为内核生成的原始事件，而最终交付给窗口的则是KeyEvent或MotionEvent对象。因此Android输入系统的主要工作是读取设备节点中的原始事件，将其加工封装，然后派发给一个特定的窗口以及窗口中的控件。这个过程由InputManagerService（以下简称IMS）系统服务为核心的多个参与者共同完成。
图1：输入系统的总体流程与参与者
二、键值映射关系：
①IR硬件扫描码在驱动里面被映射为 include/uapi/linux/input.h 里面定义的某个键值，但这个键值只在linux系统(内核)中使用。
②Android通过源码目录下的 device/xxx/xxx.kl(keylayout) 文件完成linux键值到Android系统要使用的键值映射。
以HID设备为例，首先内核中的键值转换在drivers/hid/hid-input.c 中进行映射，键值通道也有多种类型，例如：keyboard、consumer 等等；
//keyboard通道键值则是在如下数组添加修改：
static const unsigned char hid_keyboard[256] = { 0, 0, 0, 0, 30, 48, 46, 32, 18, 33, 34, 35, 23, 36, 37, 38, 50, 49, 24, 25, 16, 19, 31, 20, 22, 47, 17, 45, 21, 44, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 28, 1, 14, 15, 57, 12, 13, 26, 27, 43, 43, 39, 40, 41, 51, 52, 53, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 87, 88, 99, 70,119,110,102,104,111,107,109,106, 105,108,103, 69, 98, 55, 74, 78, 96, 79, 80, 81, 75, 76, 77, 71, 72, 73, 82, 83, 86,127,116,117,183,184,185,186,187,188,189,190, 191,192,193,194,134,138,130,132,128,129,131,137,133,135,136,113, 115,114,unk,unk,unk,121,unk, 89, 93,124, 92, 94, 95,unk,unk,unk, 122,123, 90, 91, 85,unk,unk,unk,unk,unk,unk,unk,111,unk,unk,unk, unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk, unk,unk,unk,unk,unk,unk,179,180,unk,unk,unk,unk,unk,unk,unk,unk, unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk, unk,unk,unk,unk,unk,unk,unk,unk,111,unk,unk,unk,unk,unk,unk,unk, 29, 42, 56,125, 97, 54,100,126,164,166,165,163,161,115,114,113, 150,158,159,128,136,177,178,176,142,152,173,140,unk,unk,unk,unk }; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/addc25394172319882775ee30a9fece9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2532a878901ee4667d16ab38d60d3581/" rel="bookmark">
			GreenPlum导入导出数据(二)gpfdist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在linux下启动gpfdist服务 gpfdist是Greenplum自带的工具,无需安装其他依赖或服务
$ gpfdist -d /u01 -p 5555 -l /tmp/gpfdist.log &amp;
参数解释：
-d 数据文件所放的目录
-p 设置访问gpfdist端口，这个可以根据实际情况写。
-l 设置日志文件所放的目录，这个参数也可以不用填写。
&amp; 必须要写。
查看gpfdist是否开启:ps -ef|grep pfdist
启动前:
启动后:
2.导入数据 2.1创建external table(可读外部表)
=# create external table 外部表名（列名1 数据类型，列名2 数据类型...）LOCATION('gpfdist://服务器IP:gpfdist服务的端口/数据源文件') FORMAT '数据源模式' (HEADER DELEMITER AS ',') log errors into err.test_csv encoding 'utf-8';
注意:
外部表的数据定义不能有约束条件如not null ,default 等。
HEADER 表示csv文件的第一行定义了数据的数据类型
DELIMITER ',' 表示用,分隔数据
NULL as '' 表示''为空值
encoding 'utf-8' 表示用utf-8编码
log errors into err.test_csv 表示将错误的数据导出到err.test_csv (Greenplum5已经废除)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2532a878901ee4667d16ab38d60d3581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51fecb8a14f8e39b581228727c6f869/" rel="bookmark">
			CAN总线波特率的计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAN总线波特率的计算方法 can配置 can配置 之前学习can总线的时候，总是遇到can波特率修改，一般情况下用原子的代码默认就行了，都没有研究过为什么要这么配置。有句名言说的比较好：出来混，早晚是要还的…有一天，突然想看看为啥这么配置，百度出来一大堆，还有好搓是错误的，阅读量还不小，后来就啃手册，终于搞清楚了怎么配置。。。can配置一般单片机都有如下几个寄存器：
SYNC_SEG： 同步段 一般默认是1
PROP_SEG:propagation segment 传播段
PSEG1:
PSEG2:
PRESDIV: 分频因子
好多专业的数据手册看的人懵B，还好发现有一张图。一目了然啊：
1.先看can时钟（我这里时15M）
2.看can时钟分频因子：(我这里设置成2)
3，设置PROP_SEG;(我设置成7)
4.设置PSEG1:(我设置7）
5.设置PSEG2：（我设置2）
6.计算：ftq=can时钟/（can时钟分频因子 +1）=15/3=5M
baudrate=ftq/
(1+ (PROP_SEG+PSEG1+2) + (PSEG2+1))=
5M/(1+7+7+2+2+1)=250K
注：在stm32中 的
BS1=(PROP_SEG+PSEG1+2)
BS2=(PSEG2+1)
另外尽可能的把采样点设置为 CiA 推荐的值：
75% when 波特率 &gt; 800K
80% when 波特率 &gt; 500K
87.5% when 波特率 &lt;= 500K
为了方便我做了一个计算器：
有需要可以下载
https://download.csdn.net/download/nopear6/12255858
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d225e78d387cbfd574b7efcb78dbd17/" rel="bookmark">
			广域网互联技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		广域网互联技术
广域网物理连接结构
路由器端口类型 连接线缆 物理层协议
本地环路接入方式 常用 CPE设备工作原理及使用方法
传输网基础架构 不同接入方式
数通工程师 理解用户侧申请应用 接入 传递
广域网的定义和分类
物理连接技术 端口互联 本地环路 架构
链路选择
广域网的定义及物理连接结构
广域网端口互连
广域网协议栈
接口类型 路由器边界设备
物理层协议标准 定义的位置 接口申请
运营商 多业务板
设备端口使用 运营商专线
应用 以太网专线
POS专线
广域网本地环路技术
最后一公里
只能传100米 以太网
光电转换器
光信号和电信号转换 千兆到用户 百兆到桌面
光端机 PDH 光信号 信号转换 协议转换器 协议转换成 作用
传输网架构
业务网 传输网 接入网 支撑网
现代通信网
传输网提供
信号 信令 大容量 复用技术
广域网链路选择
广域网互联协议
广域网互联
以太网专线调试
HDLC概述与配置
高级数据链路控制协议
面向BIT 的控制协议 不在乎 字符集
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d225e78d387cbfd574b7efcb78dbd17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e621a620a6f1c5170db4869df1d1d0a/" rel="bookmark">
			AttributeError: &#39;NoneType&#39; object has no attribute &#39;find_all&#39;(添加请求头信息)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日份遇到错误的解决记录：
今天爬取豆瓣Top250个电影的时候，写好代码却报了这个错，一开始认为列表上用了find()方法，换成find_all（）之后还是不行，换了别的标签也不行，于是使用print(html.text)想的把解析之后的网页代码输出看看，结果啥都没有，连源代码都是空的什么都不输出！！！！
最后想查看一下获取网页源码状态：print(res.status_code)
发现了问题所在，一般源码获取成功的话执行状态码是200，这次却是418！！！
于是查了一下418是代表什么：
执行状态码：418解释（找到了一个介绍比较详细的博客）
原来这里的418是网页服务器的反爬虫程序返回的，意思就我们被该网页服务器的反爬虫程序发现了，并禁止我们爬取，所以下一步就是需要我们模拟浏览器，重新给服务器发送请求，并且添加头等信息headers，headers是解决requests请求反爬的方法之一，相当于我们进去这个网页的服务器本身，假装自己本身在爬取数据。对反爬虫网页，可以设置一些headers信息，模拟成浏览器取访问网站 。
下一步获取并添加这个headers信息：
找到了一个写的超详细的博客【点击字体即可查看】
获取headers信息的步骤：
第一步：找到headers
第二步：找到这个信息之后，把信息添加到代码里面
import requests from bs4 import BeautifulSoup headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36'} href='https://movie.douban.com/top250?start='+str((i-1)*25)+'&amp;filter='#网页链接URL res=requests.get(href,headers=headers) #头等信息 html=res.text soup=BeautifulSoup(html,'html.parser') #解析网页代码 添加进去头信息之后就解决了禁止爬取的问题了。
我的完整代码：
import requests from bs4 import BeautifulSoup headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36'} for i in range(1,11): #因为一页只有25个电影简介，所以需要10页 href='https://movie.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e621a620a6f1c5170db4869df1d1d0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53bea458b2e886c4aec18f258620fe12/" rel="bookmark">
			Lua学习笔记——异常处理pcall、xpcall
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lua学习笔记——异常处理pcall、xpcall、debug 目录 1、博客介绍
（1）pcall
（2）xpcall
3、推送
4、结语
1、博客介绍 本篇文章记录lua学习知识点，异常处理的方法pcall、xpcall、debug
2、内容
（1）pcall pcall有两个参数，写法pcall(parm1,parm2)，参数parma1为需要执行的方法，参数parm2为参数1方法的参数，pcall(~,~)返回一个布尔值，具体的写法如下，如果testFunc可以在接受参数后正常执行不出错，那么将会执行body1和body2的内容，反之则执行body3的内容。
function testFunc(num) -- body1 end if pcall(testFunc,2) then -- body2 else -- body3 end （2）xpcall pcall的进阶版，参数一同样是需要执行的方法，参数二则是一个错误处理函数，可以在这个函数内打印错误相关的堆栈信息并返回错误信息，则xpcall的两个返回值分别是状态和错误信息。
function testFunc(num) error('error..') end function dealMsg(msg) print(msg) print(debug.traceback()) return msg end local statue,mag = xpcall(testFunc,dealMsg) 3、推送 Github：https://github.com/KingSun5
4、结语 若是觉得博主的文章写的不错，不妨关注一下博主，点赞一下博文，另博主能力有限，若文中有出现什么错误的地方，欢迎各位评论指摘。
QQ交流群：806091680（Chinar）
该群为CSDN博主Chinar所创，推荐一下！我也在群里！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae7ec2a0881cb08fc8b3c5845c8ffae6/" rel="bookmark">
			七大原则&#43;23种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 设计模式的意义1. 七大原则1.1 单一职责原则1.2 接口隔离原则1.3 依赖倒转(倒置)原则1.4 里氏替换原则1.5 开闭原则1.6 迪米特法则1.7 合成复用原则小结 2. UML类图3. 设计模式3.1单例模式3.2抽象工厂模式3.3原型模式3.4建造者模式3.5适配器模式类适配器对象适配器接口适配器Spring源码适配器模式分析 3.7桥接模式3.8装饰模式3.9组合模式3.10外观模式 菜鸟教程更香
设计模式的意义 编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，复用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好的
代码复用性可读性可扩展性可靠性 (当我们增加新的功能后，对原来的功能没有影响)使程序呈现高内聚，低耦合的特性 1. 七大原则 设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础
设计模式常用的七大原则有:
单一职责原则接口隔离原则依赖倒转(倒置)原则里氏替换原则开闭原则迪米特法则合成复用原则 1.1 单一职责原则 大白话解释：一个类就是一个最小的功能单位
描述
一个类应该只负责一项职责。
如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2。
实例
假设有一个“交通工具”类，他的作用只有一个，就是“运行交通工具”，假设它只有一个run方法，打印“交通工具 xx 在地上跑”这句话。
如果我们的交通工具只是车，这个类没有问题，如果交通工具加上“飞机”、“船”，那么“交通工具 飞机 在地上跑”、“交通工具 船 在地上跑”就不符合实际。
由于交通工具有多个，因此这个类不符合“单一职责原则”。
我们可以将其改为3个类，“水上交通工具”、“空中交通工具”、“陆地交通工具”，分别对海陆空负责（单一职责）。
此外，由于这个类的功能比较单一，只有run方法，我们也可以在方法级别上实现单一职责原则，即为该类创建“水上运行”、“空中运行”、“陆地运行”方法。
注意事项与细节
降低类的复杂度，一个类只负责一项职责。提高类的可读性，可维护性降低变更引起的风险通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违 反单一职责原则；如果类中方法数量足够少，可以在方法级别保持单一职责原则 1.2 接口隔离原则 大白话解释：实现接口的所有类都应当觉得接口中没有多余的方法
Interface Segregation Principle
描述
客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。
实例
A通过调用B，需要操作1、2、3，
C通过调用D，需要操作1、4、5，
但是B、D都实现了1、2、3、4、5，显然B、D都实现了多余的方法。
若要符合“接口隔离原则”，只需要让B、D实现必需的接口即可。
然而，实际中我们不一定能确定B是否真的不需要4、5方法，也不能确定D是否真的不需要2、3方法。
因此，不是说学好设计模式就万事大吉的。
实际还得多方面考虑。
1.3 依赖倒转(倒置)原则 大白话解释：我们都是用接口声明一个变量，而不是直接使用具体类（如声明一个ArrayList，最左边用的是List接口；声明一个HashMap，最左边用的是Map）
Dependence Inversion Principle
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae7ec2a0881cb08fc8b3c5845c8ffae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77cc43c2561a930036e5a09dbffcaade/" rel="bookmark">
			【你应该掌握的】深入浅出typescript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeScript是一种由微软开发的开源、跨平台的编程语言。它是JavaScript的超集，最终会被编译为JavaScript代码。
TypeScript可以解决JavaScript弱类型和没有命名空间，难以模块化的问题，同时也增强了代码的可读性，在团队协作和大型项目中体现出更大的优势。
本文将从“基础用法、高阶用法、模块、react项目实践中的应用”四个方向展开文章，方便大家理解，都会备注列子、codesandbox上的远程代码。
基础用法
1.变量类型
代码示例 src/components/baseVar.tsx
TypeScript提供与JavaScript几乎相同的数据类型（布尔值boolean，字符串string，数字number，数组[]，元组），此外还提供了枚举enum类型。
当不确定变量的数据类型或者数据类型会在代码运行过程中变化时，使用any来标记这些变量，使它们通过编译阶段的检查。
object表示原始类型以外的类型，即number,string,boolean,symbol,null,undefined以外的类型。
void用于表示没有任何类型，通常用于方法没有返回值时。void类型的变量只能赋值undefined或者null。
null和undefined各自的类型分别为null和undefined，并没有太大用处。
never表示永不存在的类型或方法无法达到终点，当代码中抛出异常或者while(true)时可能会用到。
symbol（自ECMAScript 2015起的新的原生类型），不可改变且唯一，通过Symbol函数构造。TypeScript中内置了一些symbols表示语言内部行为。
类型断言： as / &lt;&gt; / ！
当TypeScript无法推断出对象类型但开发者可以确定时，可以通过类型断言来显式表达变量类型。
在实际使用过程中，原始类型和any以及类型断言较为常用，object，void，null，undefined，never，symbol不经常使用。
2.接口
代码示例 src/components/interface.tsx
相较于基础类型而言，接口用于更具体地声明更加复杂的对象结构，关键字为interface。
声明方法
方法体内的入参名称不要求与接口声明中完全一致。
声明变量
变量声明中：
readonly关键字表示属性只读，不可修改。
？表示可选属性，即可以不传该字段，可选参数在必传参数后面。
[propName: string]:any可以匹配到除前面已声明属性外的所有字符串名称的属性，如：sex: boolean, address: any, email: string等，可用于不确定入参中是否还包含其他属性时。
方法的属性排序不要求与接口声明完全一致。
设置默认值
默认值属于可选参数的一种，但默认值不要求在必选参数之后。
当默认值在可选参数前时，需要传入undefined来获取默认值。
剩余参数
当方法中传参数量不一定或需要批量操作入参时，可以通过剩余参数来操作多个参数。
3.简单的高级类型
代码示例 src/components/types.tsx
交叉类型（&amp;）
交叉类型是将多个类型合并为一个类型，包含所有所需类型的所有属性。
联合类型（|）
联合类型表示一个值可以是几个类型之一。
如果一个值是联合类型，我们只能访问所有类型的共有成员。
字符串/数字字面量类型
字符串字面量类型允许指定字符串类型的固定值。
数字字面量类型允许指定数字类型的固定值。
4.迭代器
代码示例 src/components/for.tsx
因为一些内置的类型Map，Array等实现了各自的Symbol.iterator，因此他们都是可迭代的。
（Symbol.iterator方法，被for-of语句调用。返回对象的默认迭代器）
以下语句可用于遍历可迭代对象。
for…of…
(当生成目标为ES5或ES3，迭代器只允许在Array类型上使用。 在非数组值上使用 for…of语句会得到一个错误，就算这些非数组值已经实现了Symbol.iterator属性。)
for…in…
高阶用法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77cc43c2561a930036e5a09dbffcaade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ffc89fb9e466f86e151128d59632879/" rel="bookmark">
			Kettle （PDI）添加geometry插件支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为了能够处理geometry类型的数据，PDI需要安装pentaho-gis-plugins
该插件下载地址：atolcd / pentaho-gis-plugins
使用参考：https://blog.atolcd.com/une-extension-gis-dans-pentaho-data-integration-5/
不同PDI版本对应选择下载不同版本，比如我的PDI是8.2：
pentaho-gis-plugins-1.3.0-bin-8
***按照README.MD的指引：**** ***Method 2 : Manual installation*** Extract the content of pentaho-gis-plugins-VERSION-bin.zip in ${PENTAHO_HOME}/plugins. Example of extraction from the root directory of the project : wget https://github.com/atolcd/pentaho-gis-plugins/releases/download/v1.2.1/pentaho-gis-plugins-1.2.1-bin-5.zip unzip pentaho-gis-plugins-1.2.1-bin-5.zip -d ${PENTAHO_HOME}/plugins To upgrade the plugin, delete files you added before and start a fresh installation. 重启spoon之后，可以发现核心对象多了 一个geospatial
当打开相关的空间表格的时候，geometry字段可以正常显示了：
---进行空间表的表输入、表输出时候， ----表输出的建表语句大概是这样： Create table xq ( Id , Name, Type, wkt geometry ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d94f92aa2711905a5c2ae6b4cb1b8d8d/" rel="bookmark">
			JS版汉字与拼音互转终极方案，附简单的JS拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 网上关于JS实现汉字和拼音互转的文章很多，但是比较杂乱，都是互相抄来抄去，而且有的不支持多音字，有的不支持声调，有的字典文件太大，还比如有时候我仅仅是需要获取汉字拼音首字母却要引入200kb的字典文件，无法根据实际需要满足需求。
综上，我精心整理并修改了网上几种常见的字典文件并简单封装了一下可以直接拿来用的工具库。
代码和DEMO演示 github项目地址：https://github.com/liuxianan/pinyinjs
完整demo演示：http://demo.liuxianan.com/pinyinjs/
汉字转拼音：
拼音转汉字：
汉字与拼音相关知识普及 汉字范围 一般认为Unicode编码中的汉字范围是 /^[\u2E80-\u9FFF]+$/(11904-40959)，但是其中有很多不是汉字，或者说是可以读的汉字，本文用到的几个字典文件的汉字范围均是 /^[\u4E00-\u9FA5]+$/，也就是(19968-40869)，另外还有一个单独的汉字〇，其Unicode位置是12295。
拼音组合 汉字有21个声母：b, p, m, f, d, t, n, l, g, k, h, j, q, x, zh, ch, sh, r, z, c, s，24个韵母，其中单韵母有6个：a, o, e, i, u, v, 复韵母有18个：ai , ei, ui , ao, ou, iu , ie, ve, er, an , en , in, un , vn , ang, eng, ing , ong，假设声母和韵母两两组合的话，会有24X21=504种组合，实际情况是有些组合是没有意义的，比如bv, gie, ve等，去除这部分后，还剩余412种。
拼音字典文件 按照字典文件的大小从小到大依次介绍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d94f92aa2711905a5c2ae6b4cb1b8d8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52726dfe00c3fa153ab69967df9eaea4/" rel="bookmark">
			psql按年月天小时分钟秒汇总数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 时间字段：f_create_time # 金额字段：f_trans_amount # 开始时间：start_time # 结束时间：end_time # 按年汇总 select to_char(f_create_time, 'YYYY') as t, count(*) as total_count, sum(f_trans_amount) as total_amount from table_name where f_create_time between start_time and end_time group by t; # 按月汇总 select to_char(f_create_time, 'YYYY-MM') as t, count(*) as total_count, sum(f_trans_amount) as total_amount from table_name where f_create_time between start_time and end_time group by t; # 按天汇总 方式一 select to_char(f_create_time, 'YYYY-MM-DD') as t, count(*) as total_count, sum(f_trans_amount) as total_amount from table_name where f_create_time between start_time and end_time group by t; # 按天汇总 方式二 SELECT f_create_time::date, COUNT(*) AS count, SUM(f_trans_amount) AS total_amount FROM table_name WHERE f_create_time &gt;= '2020-01-01 00:00:00' AND f_create_time &lt;= '2020-03-01 23:59:59' GROUP BY f_create_time::date order by 1; # 按小时汇总 select to_char(f_create_time, 'YYYY-MM-DD HH24') as t, count(*) as total_count, sum(f_trans_amount) as total_amount from table_name where f_create_time between start_time and end_time group by t; # 按分钟汇总 select to_char(f_create_time, 'YYYY-MM-DD HH24:MI') as t, count(*) as total_count, sum(f_trans_amount) as total_amount from table_name where f_create_time between start_time and end_time group by t; # 按秒汇总 select to_char(f_create_time, 'YYYY-MM-DD HH24:MI:SS') as t, count(*) as total_count, sum(f_trans_amount) as total_amount from table_name where f_create_time between start_time and end_time group by t; 代元培
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f60249e217bb7c949b40f53521cfa4c/" rel="bookmark">
			C# 唯品会JIT&amp;JITX对接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：其实唯品会的接口使用还是非常简单，开发者可能有疑问还是他们的接口流程问题和如何与自家的ERP对接起来。这篇文章是在记录自己对接唯品会的过程的理解，也因为是第一次接触唯品会，刚开始疑问还挺多的，网上也没啥这类问题的解答，都得自己去研究实验，有需要的可参考参考。
PS：唯品会的开放平台文档N久没更新，有些地方说的已经不存在或者已经变更为其他方式，总之就是看文档会让你产生很多误区，但是你也没地方有资料看了。另外他们的沙箱，提供的数据是全是死的不变的，而且跟实际数据会差很远，我是按自己的理解纯码代码上正式测的。(今年更新了，我这是去年对接的，今年SDK为应对新型肺炎疫情 新增了一些字段，没更新的同志们要注意了)
一、准备工作-秘钥的获取
1.创建应用：这很简单注册成为开发者，供应商认证成功过后就可以创建应用，我创建的是 自研应用 。这里要说明一下，创建应用时填写的选项也是有学问的：
合作类型 -- JIT和直发：
JIT模式：我是服装公司（唯品会称呼我为供应商），客户下单了，由唯品会下指要供应商发货，发到唯品会他们自己的指另的仓库，然后由唯品会的人发货给客户，所以快递费要我们自己出。
直发：客户下单了，由我（供应商）直接发货给客户。PS：这块的接口他们已经弃用了，但是开发者平台没更新。这块的业务已经改为JITX业务了，接口也是另一套。这里也要说明一下：即使是我们自己发货，但你也不要以为你就拥有了自己的这一批客户源，唯品会对用户信息保密异常严格，只有他们自己知道用户信息。我们供应商拿到的全是加密的。
JITX业务说明：因为是由我们直接发货给客户，并且用户信息是保密的，所以承运商+快递单号+快递费 全是由唯品承担。关于退货，这也跟淘宝天猫不一样，商家也不需要处理那些繁杂的退货申请，客户退货也是直接退给唯品的仓库，然后他们处理之后再发回给商家这里。所以 是没有 退货申请 接口的。
PS:关于退货这块，我咨询过公司的业务人员，说是唯品后台会有财务报表，这些报表就是最终生效的订单，我们的业务人员会定期筛选出来导入到我们的ERP系统，这才跟ERP的销售那块的账对上，所以换句话说不用技术人员 再去另外弄销售单。这里不能一概而论所有公司都这样做，还是得看各个公司的业务模式咋样才能决定自家要怎么处理这块。
回调URL：这个就是正式上使用接口必要的参数：access_token，就是需要通过这个获取到。这里要说下，access_token有效期3个月，你只能单独通过https://auth.vip.com/oauth2/authorize?client_id=appKey&amp;response_type=code&amp;redirect_uri=回调URL
这个链接输入VOP系统的账号密码授权之后，唯品会通过你设置的回调地址，将access_token和refresh_token,expires_in,refresh_expires_time返回给你，你需要记录下来，配置到系统中的某个地方，调唯品的接口的时候就用它。那3个月过期之后呢，要么在通过refresh_token（有效期1年）调用唯品的刷新access_token的接口，要么就再一次通过授权这个方式获取token。1年之后吧，就真的需要在一次通过授权去获取access_token了，这就需要你及时更新到才行。
2.拿取 App Key+App Secret
3.配置白名单：即你调用唯品接口的程序发布的服务器IP，
二、码代码
1.0 先从官方将唯品的sdk下载下来，他们封装好了所有接口的请求（包括model,request），链接
JIT和JITX是可以同时跑的，我是先把JIT的对接好了之后，再去对接JITX的。先上JIT的代码吧，因为JITX的稍微要麻烦点，而且JITX的运行跟商家的运营政策不同而编写规则也不同，毕竟 这是要对接自家的ERP系统的。
PS:这里注意，唯品的接口会时不时来个超时，所以要避免这种情况的发生导致我们错过点拉不到数据或拉不全 1.1 唯品的接口里有自己的一套仓库编码和快递承运商编码，我们使用人家的接口的时候 传递的参数值 也必须是 唯品规定的一套枚举值。所以若是 要和自家的ERP关联起来，就要 配置与 唯品一样的或者能2边关联上的 仓库编码和承运商编码
获取承运商的接口 ：vipapis.delivery.JitDeliveryService-1.0.0#getCarrierList
在官网里的这个接口的下面就有仓库的枚举值列表
1.2 先上每个接口必须要用到的公共方法和配置参数：
//这些使用唯品接口必要的参数，我是配置在config里；分别对应 上一节说的 应用的key， 秘钥 ，商户ID ，唯品接口运行地址 private string AppKey = System.Configuration.ConfigurationManager.AppSettings["VPH_AppKey"].ToString(); private string AppSecret = System.Configuration.ConfigurationManager.AppSettings["VPH_AppSecret"].ToString(); private string VendorId = System.Configuration.ConfigurationManager.AppSettings["VPH_VendorId"].ToString(); private string AppUrl = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f60249e217bb7c949b40f53521cfa4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41bd36469294dc5ff042b0c0093937f2/" rel="bookmark">
			navicat 连接postgresql 报错 pg_hba.conf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 navicat 连接postgresql 报错 pg_hba.conf解决方案： navicat 连接postgresql 报错 pg_hba.conf 场景： 在数据库服务器安装了postgresql数据库，然后在应用服务器在navicat 通过 ip加端口形式访问时报错如下：
解决方案： postgresql默认情况下除本机外的机器是不能连接的，要想连接需要配置一下文件：
路径：C:\Program Files\PostgreSQL\11\data\pg_hba.conf
#TYPE DATABASE USER ADDRESS METHOD host all all 0.0.0.0/0 trust 联接使用的认证方法：
trust
无条件地允许联接。这个方法允许任何可以与PostgreSQL数据库服务器联接的用户以他们期望的任意PostgreSQL 数据库用户身份进行联接，而不需要口令。
md5
要求客户端提供一个 MD5 加密的口令进行认证。
注意：
要让本机外的机器访问,除了在pg_hba.conf中增加访问的IP段外，这设置外还要把postgresql.conf里的监听地址设置为:listen_addresses = ‘*’
最后重新启动postgresql数据库服务
测试一下可以正常连接了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3814f65a979138963df8dd4b512cb7/" rel="bookmark">
			以后，要如何更好地输出博客？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
2020魔幻开局。从1月21号起到现在，接近两个月的时间了，我实在没想到这个假期能如此漫长，这或许是退休前最后一个如此长的假期了吧（别再搞了）？年前还和同事们开玩笑，说要想放寒暑假这么长的假期，只能裸辞…实在是没想到。
之前我总盼望着能有一段长假，来充分涉猎提升自己，但是，就像读书时期寒暑假书包里塞的一堆书籍，最后返校时只会嫌自己想太多。
我在疫情待家的这段时间，学习效率确实非常一般，但要说收获，其实也有一些。这些收获不是具体技术上的，而是宏观方向、思维上的。我认为每个程序员都不应该只将自己的思维局限在技术上，留给外界总是那副书呆子般的刻板印象，睁眼看世界，不断思考反省、提高认知。以后我会慢慢把收获都分享出来，大家一起成长 ~
本文作为 2020年第一篇博客，新年新气象，自然要写点不同的东西，为以后的输出规划一个方向，一个我认为不同以往、更好的方向。
思维导图：
一、我为什么要写博客？ 其实，在之前这篇文章里我描述过最初写博客的原因，如今写博客两年多了，有了新的认识，也有了新的写博客的动力。
那么现在，我为什么要写博客呢？内心最真实的想法是什么？总结如下几点，并给出我认为的重要性星级：
原因重要性星级作为笔记，防止遗忘信息（等同于有道云笔记）★将碎片化知识系统化输出，加深思考，强化记忆★★★★锻炼文字表达能力★★★★★将自己遇到的困难、解决问题后的收获分享给需要帮助的人★★★★和大家评论互动，碰撞观点，一起提升★★★持续输出，打造自己的名片★★ 这几点原因以及重要性，大家观点是否一致呢？我想，大概率是有不同意见的，因为这种观点都是动态变化的。先不谈我们各自都有不同的背景，就单从我自己出发，不同时间阶段，我的观点就会产生变化。
比如，我刚开始写博客时，肯定主要侧重于技术点的记忆、思考。慢慢我体会到了帮助人的愉快，意识到了文字表达能力对于技术人员的重要性。然后等博客下面有人和你争论时，发现碰撞能带来不一样的收获。在这过程中我们自己也会关注很多人的博客、公众号，发现前辈们能靠着持续优质输出，获得大量粉丝，打造出了自己的业界名片，也能作为副业提供收入…
很真实，耗费心力写文章给人看，当然不是绝对为了利他，对大多数人来说，利他同时能带来自身的快乐、成长（利己），这应该算是最好的状态了吧。
说到这点，就不得不谈谈王垠了。
包括我在内的很多技术人都或多或少从王垠的博客中有所收获（强烈建议没看过的同学去看看），但是王垠所得到的太少，或许因为自身的经历、性格，他一直不愿意妥协，去利用自己的名气谋求利益，这和当今中国技术圈很多人想方设法变现形成鲜明对比，这种风骨，我很敬佩，但我肯定难以模仿，我也不觉得大家需要去模仿。
有底线，付出后得到自己应得的，不委屈自己，这才是良性社会。
二、大家都在写博客，差别在哪？ 我们既是写博客的人，也是阅读博客的人，更多的时间我们都在阅读别人的文章。所以，如何提升自己输出博客的能力，要从阅读他人的博客开始分析。
就像看小说，看的越多，口味越刁，阅读博客也一样。
看看自己以前的博客，都是完全碎片化的存在，而且都缺乏技术深度，不成体系。很多博客都是解决某个场景下遇到的小问题，这些问题在网上大多都有类似的文章，也缺乏新意人云亦云。
当然，我也不是完全否定我过去所写的博客，因为比我做得更差的人，居然还挺多…
每次我百度搜索资料的时候，最讨厌的就是这种情况：点进去搜索首页的一个相关问题博客，标题较为符合，但阅读后发现不能解决我面临的问题，或者这篇博客本身存在漏洞，于是继续浏览搜索结果，居然发现这些文章全是转载之前的那篇！甚至错误的地方都照搬，有的连转载地址都不加，这一刻我是真的头疼。
还有很多博客在解决问题时完全没有介绍问题背景、当时的环境、问题产生的原因，只有干瘪的一点解决操作，这还可能从别的人哪里复制来的…所以有时不仅无法帮助别人，还会产生误导，耗费别人更多的时间。
还有一些博客，可能是由于CSDN早期排版有问题？反正那博客写的是歪七竖八、花里胡哨，简直挑战阅读者的眼力。遇到这种文章，我扫一眼后基本直接关闭，这并不是“以貌取人”，而是写出这种博客的人，大概率完全不用心，内容质量也堪忧。
所以我写博客，一般不会转载文章，真正遇到有价值的文章，我可能会记录到有道云笔记上。还有，如果我写的博客内容有类似的文章已经存在，我都会结合我自己应用场景、遇到的问题，系统化整理输出，不会完全照搬，因为这样确实没有意义。
说了一堆各种博客的缺点，那么，什么样的博客才是让我觉得赏心悦目、有阅读欲望的存在呢？请看下一小节。
三、如何更好地输出博客？ 首先，我们写出的博客，你觉得是自己修改的多呢？还是自己读的多呢？还是给别人读的多呢？
如果你对技术敏感的话，这时可能会联想到编写代码。
我们编写的代码，大部分时候都是在阅读它，而不是修改它。并且由于软件代码的生命周期一般都大于作者对它的维护期，你当前公司的同事、你跳槽后入职的新员工，都有可能继续维护、阅读你的代码。所以，我们的代码必须具备良好的可读性，非常非常重要！
回到你写的博客，看看它上方的阅读数，再对比下你阅读它的次数，就应该明白可读性是多么关键。
影响博客可读性的第一要素，就是 排版。
一个良好的排版，并不需要花里胡哨、五颜六色，越整洁越好，比如王垠的这种排版：
是不是觉得十分舒服呢？真的会激发我的阅读欲望…
而 CSDN 为了减少程序员在排版上的精力耗费，基本统一化排版，只提供很少的格式选择，较为整洁，这确实也是一种不错的设计，Keep It Simple and Stupid！
解决了排版问题后，我们需要注意文章的 逻辑层次。
所谓的逻辑层次，很多时候就体现在小标题上，每一个小标题都能描述后续文字的核心观点，各个小标题之间也可以形成递进或者并列关系，这样整篇文章的逻辑结构会十分清晰，阅读者也能更加轻易地明白你想表达内容的思路。（小技巧：CSDN可以自动生成目录）
由于我之前写的大多都是碎片化技术文章，漫无目的，所以我计划以后的博客一定要 体系化！
体系化是一个比较宽泛的概念，我未来可能从这几个方面去形成自己的博客体系：
区分技术和非技术文章。因为技术文章往往具备明显的技术点体系结构，比如编程语言 - Java - Spring框架 - 源码分析系列，我们很容易分类形成体系。而非技术文章涉及的面就比较广了，很多时候都是对某一事件有所感悟，或者观察一些现象形成总结，刚开始不好形成体系，可以日后再说。技术文章中尽量不要将技术点孤立开来、过于碎片。比如写Spring相关博客时，我们划分为生产场景问题集锦、底层源码分析系列等，每篇博客标题可以这种形式命名：Spring源码分析系列（1）xxx，将多篇博客关联成一个系列。 具体如何形成自己的体系，还需要慢慢摸索，但这种写博客的方式，肯定比较辛苦，因为不像之前那样随意了，需要一个整体、长期规划，还有可能太监…
我对我未来博客还有一个规划就是，尽量多写一些能体现思想深度、设计理念的文章，计算机知识更新换代很快，经常诞生新知识、淘汰旧知识，但是很多设计思想并没有多少变化。比如最近几年概念炒得火热的大数据领域，本质就是分治算法的应用，通过分布式集群实现存储、计算的分治。
授人以鱼不如授人以渔。我们很多时候太执着于学习一些死知识，被这些看似高端的奇技淫巧所迷惑，记了又忘，挫败感油然而生。其实大可不必，这世界确实变化很快，但总有不变的成分，这些才是我们需要去抓住的 key。
还有一点，关于博客平台的选择，很多大神都有自己的博客网站、或者公众号，如果以后我能持续输出更优质的内容时再考虑吧…现在还是做好自己！CSDN 足矣。
规划很美好…希望我以后能做到吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f49280be4e073ec7c929a64e00d90c/" rel="bookmark">
			vue项目中使用高德地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装
cnpm install vue-amap --save 2.配置 ：main.js中引入并配置，plugin根据自己需要添加
import VueAMap from 'vue-amap'; Vue.use(VueAMap); VueAMap.initAMapApiLoader({ key: 'YOUR_KEY', plugin: ['AMap.Autocomplete', 'AMap.PlaceSearch', 'AMap.Scale', 'AMap.OverView', 'AMap.ToolBar', 'AMap.MapType', 'AMap.PolyEditor', 'AMap.CircleEditor'], v: '1.4.4' }); 3.在vue中使用，template
&lt;template&gt; &lt;div id="app"&gt; &lt;div class="amap-wrapper"&gt; &lt;el-amap class="amap-box" vid="map" :zoom="zoom" :center="center" :plugin="plugin"&gt; &lt;el-amap-marker vid="marker" :position="center" :label="label"&gt;&lt;/el-amap-marker&gt; &lt;el-amap-circle vid="circle" :center="center" :radius="radius" fill-opacity="0.2" strokeColor="#38f" strokeOpacity="0.8" strokeWeight="1" fillColor="#38f" &gt;&lt;/el-amap-circle&gt; &lt;/el-amap&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 4.script
&lt;script&gt; export default { data() { let self = this; return { zoom: 16, //初始化地图显示层级 //center: [113.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f49280be4e073ec7c929a64e00d90c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30ad2b5251f100b89e07c70d2e7f393a/" rel="bookmark">
			SQLAlchemy中一对一，一对多，多对一Mode转dict
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQLAlchemy中一对一，一对多，多对一Mode转dict def sqlModeToDict(sqlObj): resuDict = {} for k,v in sqlObj.__dict__.items(): if isinstance(v, list): info = sqlModeToDict(v[0]) resuDict.update(info) else: resuDict[k] = v resuDict.pop('_sa_instance_state',None) return resuDict 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab2db6c18567e454a341105baf76f50/" rel="bookmark">
			eclipse在java环境基础上配置C&#43;&#43;环境（MinGW安装包&#43;详细步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在eclipse开发java的基础上，又不想再下一个c++的编辑器，如何实现java与c++的转换？
博主整了两天，踩了好多坑，整理出来帮助大家
第一步：在eclipse里下载CDT 打开以后需要一点时间：
搜索CDT，等待下载完成：
**补充说明：**下载成功标志就是你点击file》new》other会有c/c++的文件目录，如果没有安装成功，自己可以去网上下一个 包，然后导入，这一块有很多博主整理了，这里就不再赘述，毕竟这种情况不多。
第二步：下载MinGW并安装 我之前一直在官网下，下了几次都没成功，朋友下了有缺省文件，我在网上找到了集成安装包，很方便，为了方便管理资源，我放在了自己的微信公众号：
取用方式：
微信搜索：松鼠技术站
回复：MinGW
即可获得安装包
下载到本地，解压以后，点击：
都选默认,注意为了方便，这里都勾上（有个下载多选框）
静静等待安装完成
第三步：MinGW的配置 打开控制面板》高级系统设置》环境变量
打开path：加上以下几句
确定后退出，然后打开终端cmd 输入gcc -v若显示如下，配置成功！
第四步：在eclipse配置MinGW 点击window》perferences
new》other
点击刚创建的项目》鼠标右键：加入以下路径
导入：路径是你安装MinGW的路径
编译运行第一个C++ new一个class，然后看到你的目录是这样的：
然后给cpp中添加代码：
注意添加好以后要save一下，之后：build
这样才会通过，因为你里面新建以后没有Main函数会报错：
正确目录如下：
然后就可以运行程序：
注意：
每次写完以后要save之后再编译运行，不然还是会运行之前编译过的代码，甚至会报莫名其妙的错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9286073cb281bc2d8e195148d8a5011d/" rel="bookmark">
			局域网冗余备份技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		局域网冗余备份
冗余备份 链路捆绑
理解并掌握
单星形 容易单点故障 接入和核心 交换机
链路故障和设备故障 经过核心交换机 故障 引擎故障 电源故障等
引擎冗余 电源冗余 设备冗余
链路冗余避免单链路故障
引擎冗余 设备启动后 一块工作 另一块备份 保存配置时 两块引擎 50毫秒内 切换接替
设备电源模块 供电 双电路方式 采购时 注意 耗电量 决定电源的过滤 避免某些板卡不可用
设备荣誉
冷备份 一般冷备份 在线冷备份 备份设备 不参与业务 策略技术没有把流量引入
热备份 平滑接替
故障恢复时间短 不需要人为参与 自动接替
数据应用冗余备份 网络里面的 互联网公司 腾讯 用户的账户信息 小型和 应用集群 存储设备
动态滑接 镜像存储 普通数据 操作系统 应用 导致业务中断 应用中断时体现作用
记录 数据丢失 快照进行数据恢复
冗余备份技术选择
业务可靠性要求
使用一种或多种双引擎单设备 多链路捆绑
数据可靠性要求 核心设备 容灾能力
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9286073cb281bc2d8e195148d8a5011d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35934f707f2e63f9a8213bb04ec33c82/" rel="bookmark">
			c语言输出等腰三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 c语言输出等腰三角形 这个例子的用意是为了加强对于for()语句嵌套的应用能力的加强。
例：
要输出：
我们先一步步分析一下。
首先肯定要弄一个两层循环，一个循环变量 i 用来控制行，一个循环变量 j 用来控制列。
那么外层循环控制的是行还是列？我们来看一下。
通过上图可以知道，外层循环是用来控制行，内层循环是用来控制列。
要想输出目标图形我们可以先输出：
这个图形如何输出我们分析一下：
我们来看一下对不对：
可以看出我们的推理是对的，这种思想是十分重要的。
接下来就是输出我们的目标图形：
下面我们看对不对：
ok大功告成。这道题其实特别简单，但是其中的思想是十分重要的。
另一种方法 这里原理不在赘述 #include&lt;stdio.h&gt; int main(void) { int n; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) { for(j=0;j&lt;=n-i;j++) { printf(" "); } for(j=1;j&lt;=i;j++) { printf("* "); } printf("\n"); } for(i=1;i&lt;=n+1;i++) printf("* "); printf("\n"); for(i=n;i&gt;=1;i--) { for(j=n-i;j&gt;=0;j--) { printf(" "); } for(j=i;j&gt;=1;j--) { printf("* "); } printf("\n"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87dc1ae5b9e7f977a00ee745dc8d578/" rel="bookmark">
			QCustomplot放大与缩小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录[隐藏] QCustomplot 放大与缩小方法 QCustomplot 放大与缩小方法 方法 1 ： 以鼠标当前位置为中心点进行放大缩小 ui-&gt;customplot-&gt;axisRect()-&gt;setRangeZoomFactor(2);ui-&gt;customplot-&gt;axisRect()-&gt;setRangeZoom(Qt::Vertical); 方法 2 ： 链接 mouseWheel 信号进行处理(如果不以鼠标为中心，以 Y 轴中心点为中心) double dCenter = ui-&gt;customplot-&gt;xAxis-&gt;range().center();// 扩大区间 (缩小 plottables 鼠标向内滚动)ui-&gt;customplot-&gt;xAxis-&gt;scaleRange(2.0, dCenter);///缩小区间 (放大 plotTables 鼠标向外滚动)ui-&gt;customplot-&gt;xAxis-&gt;scaleRange(0.5, dCenter); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e5162e573b148b2bc48a1b3dc82d95/" rel="bookmark">
			四、Linux和Windows以及QT下的网络编程之Wireshark抓包分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意： 输入过虑规则时，如果语法有误，显红色，正确，显绿色。
1.基本命令： 1.前面加！号 (加not） 表示否
2.语句之间用 or 表示或者
3.语句之间用and 表示和
4.语句之间用&amp;&amp; 表示且
tcp udp arp icmp http smtp ftp dns msnms ip ssl oicq bootp and or 等等
less than 小于 &lt; lt 小于等于 le
等于 eq 大于 gt
大于等于 ge 不等 ne
2.IP过滤 例子:ip.src eq 192.168.0.1 or ip.dst eq 192.168.0.1 //指定来源或者目标
例子:ip.addr eq 192.168.0.1 // 不指定来源和目标IP 都显示
3.端口过滤 例子:tcp.port eq 80 或者tcp.port == 80 // 不指定来源和目标端口 都显示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03e5162e573b148b2bc48a1b3dc82d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca58f09cc931beda200e130766512c8/" rel="bookmark">
			查看 gem 信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 gem environment 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5da823c79f8b7e32087f8f2e406b64/" rel="bookmark">
			十七、PPPOE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字用户线路DSL(Digital Subscriber Line)是以电话线为传输介质的传输技术，人们通常把所有的DSL技术统称为xDSL，x代表不同种类的数字用户线路技术。目前比较流行的宽带接入方式为ADSL，ADSL是非对称DSL技术，使用的是PPPoE（PPP over Ethernet）协议。
PPPoE协议通过在以太网上提供点到点的连接，建立PPP会话，使得以太网中的主机能够连接到远端的宽带接入服务器上。PPPoE具有适用范围广、安全性高、计费方便等特点。
【附】PPP协议是一种点到点链路层协议，主要用于在全双工的同异步链路上进行点到点的数据传输。
PPPOE DSL应用场景 数字用户线路DSL是以电话线为传输介质的传输技术。简单而言就是通过该技术连接用户。
PPPoE在DSL中的应用 PPPoE报文 PPPoE会话建立过程 PPPoE协议报文 PPPoE发现阶段 客户端通过广播发送PADI报文来发现接入服务器。
所有的PPPoE 服务器在收到PADI报文之后，将客户端请求的服务与自己能够提供的服务进行比较，如果可以提供，则单播回复PADO报文。
PPPoE客户端选择最先收到的PADO报文对应的PPPoE服务器，并单播发送一个PADR报文。
PPPoE会话阶段 PPPoE会话上的PPP协商和普通的PPP协商方式一致，分为LCP、认证、NCP三个阶段。
PPPoE会话的PPP协商成功后，就可以传输PPP数据。
PPPoE会话终结 PADT报文用于通知对端PPPoE会话结束。
PPPoE会话建立过程 实验 配置:
AR8:
# ip pool pool1 gateway-list 119.84.111.254 network 119.84.111.0 mask 255.255.255.0 # aaa local-user huawei password cipher %$%$0`7N=y9YYDw_&amp;79Kn||=XH7K%$%$ local-user huawei service-type ppp local-user huawei2 password cipher %$%$C0|`(K'JwK`b!\8vZz0#XH5]%$%$ local-user huawei2 service-type ppp AR9:
# interface Dialer1 link-protocol ppp ppp chap user huawei ppp chap password cipher %$%$Lh(~,b#E}T/+5b6Jd-FT,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db5da823c79f8b7e32087f8f2e406b64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa1918fd80b438368a35fe12cd6f7b0/" rel="bookmark">
			thinkpad t440p不亮机故障修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020-03-04日，笔者的thinkpad t440p笔记本出现彻底无法开机，黑屏现象，此时无法进bios设置，无法启动操作系统。在此之前约1年半前系统出现cpu风扇噪音异常偏大现象；在此约半年前系统偶发性出现按开机键后无法立即开机启动，等待一段时间后才启动系统的现象；在此1个月前，系统频繁出现按开机键无法立即开机，且等待时间逐渐拉长的现象；直至今日，系统彻底无法开机启动了。
我的选择有两个：购买新本，时逢新冠肺炎防疫期间，实体店未开门营业, 不便购买，况且thinkpad t440p做工质量还是不错，加上我这个本是高配，使用近6年后性能还不算落后，扔掉闲置有些可惜；但要找修理部维修的话，同样也是未开门营业。于是决定网查资料，开始笔记本维修diy之旅。由于新冠肺炎影响，物流未全面恢复，所以网购较慢，也耽误了不少时间。但最终故障被修复，还是很值得记录一下中间过程的。
观察故障现象，笔记本电脑按开机键后，电源指示灯立刻亮，键盘背光很快亮，然后熄灭，cpu风扇立即转一会，然后停止，此后系统无任何响应，屏幕无显示，过一会cpu风扇再次启动，触摸cpu区域笔记本外壳发现较热。根据这些现象，排除电源故障问题，故障应在开机上电后bios启动到操作系统启动之前的这个阶段。跟据网络资料查询，进行拆机，放电，拔cmos电池，更换cmos电池等系列操作后，故障现象依旧，可以排除bios的cmos无电以及设置错误等问题，因为这些情况下系统是可以启动到进bios设置阶段的，但目前的故障机无法到此阶段，因此定位故障源可能与核心硬件有关。另外，网络资料显示，目前的笔记本电脑不同于台式机电脑，因要求进行电池充放电管理等原因，电脑主板上除了有bios程序，还有一个嵌入式管理控制器，简称EC。EC在笔记本有供电电池或连接电源时就处于工作状态，无论笔记本是否开机。EC负责诸如电池充电管理，响应开机键按钮启动系统，充当键盘控制器等功能。EC也有相应的控制程序，但该控制程序运行在EC的微型处理器上，不同于bios，bios程序代码是运行在CPU上的；并且开机过程中EC是比bios更早进入工作状态的。从我的笔记本故障现象来判断，我的笔记本的EC工作状态是正常的，所以应该是在bios工作期间出了故障。
此外，拆机后故障现象多了板载小喇叭beep连响5声的现象。查询网络资料，连响5声的解释，根据bios程序的编写厂家不同而解释不同。目前主要有三家厂商，分别是AMI，Award，Phoenix。由于之前并未注意到thinkpad t440p的bios程序的厂家标记，所以不清楚该机bios是哪个厂家的。网络查询显示该型号机器的bios设置程序里显示的是thinkpad setup，没有任何上述厂家标记。后经一翻摸索，在拔掉内存条然后开机的情况下，beep的报警多了一种现象，会在连响5声后再按1-3-3-1的规律进行数次响铃报警。因为网传资料里介绍beep报警分长响和短响，但此时没有经验，搞不清现在的报警是长响还是短响。但按照响的次数和短暂间隔来判断，可以发现该报警与Phoenix bios的内存故障报警较为接近(后来证实确实应按Phoenix的报警模式来解读beep报警信息，但是thinkpad bios的设置程序的任何地方都没有显示Phoenix字样)。
但是，开机时最早的连响5声报警的含义，在Phoenix的报警说明中找不到匹配项目。另一种对于连响5声报警的解释是CPU故障，这符合AMI的beep报警解释。这两种冲突的解释令人迷惑。后来在网传资料里找到，这是thinkpad机型特有的，跟安全防盗有关，一旦在拆开后盖的情况下加电开机，就会出现连响5声报警(但后来在官方硬件维护手册里查到说这个报警代表要更换主板，幸亏没信这个)。但当时因为这个问题困惑了一段时间，于是决定先更换CPU进行测试来确定是否是CPU故障，所以找同学借来他的笔记本尝试更换cpu进行故障排除法测试。他的笔记本型号也是thinkpad t440p，只是cpu硬盘等配置与我不同，并且他的笔记本也早就出现跟我现象相同的无法开机故障（此处阴谋论一下，怀疑t440p原版bios中存在后门，用户使用年限过长时，故意进行随机故障，然后到一定时间就彻底不让开机使用了。我们2人都已使用5年左右了，出现了同样的故障，不免令人怀疑。后文会讲对这有问题的bios程序已经备份了，将来有时间可以研究一下是否真的）。然后在更换cpu后开机测试，故障依旧，说明不是CPU问题。
到此，按照网查的资料分析，要么是主板故障，要么是bios程序问题。对于前者，咱们非专业人士无法分析原因并进行修复操作；对于后者，经百度查询，需要重刷一下bios程序，操作方法简单明确，经淘宝查询，所需设备材料不贵，非专业人士也可以操作，于是决定网购后diy。
首先通过网查资料并观察t440p的主板结构，找到了内存条旁边的u49芯片就是目标芯片之一，还有一个u113芯片没找到(后网查资料明确，u113是南桥芯片bios程序)，可能在主板背面或其他被遮挡位置处。观察u49芯片上面的标注是"winbond 25Q32EVSIQ 1352"，正是目前主流使用的25系列eprom芯片，容量为4MB。
于是首先网购了USB接口的CH341A编程器，网上有很多教程；同时采购了8脚编程器夹子，这个可以不用把bios eprom芯片从主板上拆下来就能进行编程更新，这个功能是非专业人士能够diy更新bios程序的关键，没这个功能，一般人不可能做到将bios eprom芯片从主板上焊拆下来然后再焊接到主板上还不破坏主板原来结构的，因为这个eprom芯片个头太小了，与主板的印刷电路板连线也非常细小；最后，在万能的淘宝上买了两套据说是thinkpad t440p的原厂bios程序，之前因为找这个bios程序花了大量时间也没找到，还是看网友介绍才知道淘宝有卖的，每套bios都是一个4M的，一个8M的文件，显然u49应该使用4M的那个。买两套是为了节省时间，因为不知道哪个版本是正确的，所以多试1个。
等东西都到货后，找一台能正常工作的电脑，打开CH341A店家给的刷bios软件资料，安装驱动程序后，将CH341A插到usb接口上，设备指示灯亮了，同时打开CH341A.exe软件，软件显示设备已连接，说明CH341A编程器已经可以工作了。接下来的重点是用编程器夹子将CH341A编程器与主板上的u49芯片连接起来。这里有些麻烦，因为针脚和连线很多，而且没有防止误插的标志，好在网络教程有图文说明，而且关键的一点是u49芯片的1号引脚的位置，也在网上找到了标注图片，所以顺利将CH341A与u49芯片连接成功了，尤其注意编程器夹子上的红线要与u49的1号引脚连接，笔记本要断电，拔掉供电电池。这时点击CH341A.exe软件的检测按钮，也成功显示了芯片类型与u49芯片上的文字标注符合，说明连接eprom芯片成功，可以开始下一步工作了。
首先为防止误操作导致刷入错误bios程序后电脑变砖，所以要先将当前带故障状态的本机bios程序备份一下，这时在CH341A.exe点击读取按钮，左下角进度条开始走，CH341A编程器上一个工作状态指示灯亮了，稍后在CH341A.exe主界面上显示了读出来的bios程序数据，不是默认的显示FF FF的状态，说明旧的bios程序已经被读取出来了，这时点击保存按钮，就可以将bios程序内容保存到文件中了，后来查看该文件大小正好是4MB，文件内容与CH341A.exe读出的内容也一致。然后就可以开始刷新的bios程序了。这时不要点击CH341A.exe中的“自动”按钮，据网上资料说该功能有bug，应该手动进行，操作如下：先点击擦除按钮，然后点击查空按钮，无误后点击打开按钮，选择从淘宝上买到的4MB的bios程序文件，然后点击编程按钮，此时进度条走动，指示灯亮，此时就是在进行正真的bios程序更新写入操作，等完成后，一定要点击校验按钮，等校验成功后说明bios程序更新成功完成，如果校验失败，需要重复尝试前述操作。
接下来，拔掉编程器夹子，将故障电脑接电开机测试，这次不一样了。机器先是自动重启了几次，然后机器就点亮了，屏幕上显示时钟错误，CMOS CRC错误等信息, 然后可以按F1进bios了！这么看很有希望啊！然后进bios设置日期时间，并且关闭安全选项里的反偷盗功能, 保存后重启系统。这次重启后仍然出现几次重启失败，但机器会自动重启，很快就出现了正常开机显示，windows也能正常启动了！进windows后，验证了下系统各个配置和功能，尤其是网络功能，一切正常。多试了几次热重启，冷开机，系统都能很快响应并完成开机，这故障就算完美修复了！
总结看来，这次故障点就是u49 bios程序的问题。但是bios程序是EPROM，相对固定不变，怎么会损坏呢？而bios程序的设置参数信息是在cmos中，经检查本机上的原厂cmos电池至今仍然电力充足，也不会有问题。具体原因就真不知道了。网络上有一种说法是冬天人体带着静电，在触摸笔记本开机键或其他部位时，有可能损坏系统，比如bios。这个说法有一定可能性，以前确实发生过手碰到笔记本然后放电的现象。但只是有可能，网络上也没给出确切证据。奇怪的是我同学的本子也跟我的故障一模一样，也用同样的方法修复了，不能都是静电吧，阴谋论的可能性也不能排除。不过，有一点确实要注意，尤其在冬天，拆机维修时，触摸电脑内部设备之前，一定要多摸暖气管子，将身上静电放掉。
后记：
后来总结经验时，找到了资料，详细解释了Phoenix bios故障时beep报警的模式，例如之前的1-3-3-1短响报警，其实这代表一个故障或状态代码，是一个8bit的代码，Phoenix将这8bit二进制分成4个部分，每相邻的2bit构成一个部分，每部分有4个状态值，每个状态值加1后，分别用1到4次短响来代表该部分状态值。因此，前述的1-3-3-1短响其实是表示了0x28这个代码，Phoenix bios对应该代码的描述是Autosize DRAM，正好是对应内存自检过程。这么看来，Phoenix bios的beep报警声还是很有内涵的。
进一步研究发现，现在的电脑系统在上电后都要进行一个Power-On-Self-Test(POST)操作，就是上电自检操作，当POST操作完成后，会启动其他部分的bios程序运行，最后引导操作系统运行。在POST过程中，电脑系统有个0x80号硬件端口寄存器会输出一个8bit状态代码用于故障诊断，叫POST code，代表当前POST操作正在进行哪一步工作。不同厂商的BIOS程序对POST code有自己的定义。当机器出现无法开机故障时，最后一个放到0x80端口的POST code就极具参考价值，它代表了系统在POST进行到哪一步时出现了故障，维修人员可以据此进行排查和修复操作。进一步的，淘宝上有卖主板故障诊断卡，来专门显示POST操作过程中的POST code值以便进行故障诊断，以后如有其他更复杂的故障要解决，可以考虑购买此设备，并且该设备也不贵。当然，如果有时间要研究我的t440p之前为啥出现无法开机的故障，也可以将之前备份的有故障的bios重新刷回机器，然后使用主板故障诊断卡来检查POST code值，从而分析最根本的故障原因。注意台式机与笔记本的主板故障诊断卡是不同的产品，要根据自己情况购买。
另外，现在所刷的bios程序，都是比传统bios更好的UEFI格式，而这个格式的bios程序的组织方式，可以使用UEFITool.exe工具进行查看。使用UEFITool.exe可以分析bios程序内部的结构和布局，有些高手通过使用该工具来在原厂bios的基础上自行定制修改bios程序，这个可以研究下。如果要看看我的本机自带故障bios中是否存在阴谋论，也少不了使用UEFITool.exe工具来研究之前备份的u49 bios程序内部结构。
这次故障也给我提了个醒，下次买新本后，记得要备份下本机自带bios。此时备份bios不要使用编程器，因为使用编程器要拆机，而新买的笔记本一但拆机，厂家就不给保修了。这时应该查找官方网站，找一些能在操作系统中运行的bios备份程序来实现备份。
参考资料：
t440p组装：https://club.lenovo.com.cn/thread-4683110-1-1.html
官方硬件维护手册： https://download.lenovo.com/ibmdl/pub/pc/pccbbs/mobiles_pdf/t440p_hmm_en_sp40a25467_04.pdf
thinkpad wiki: http://www.thinkwiki.org/wiki/Category:T440p
u49芯片位置：https://www.techinferno.com/index.php?/forums/topic/12229-lenovo-thinkpad-t440p-t440s-t540-unlocked-bios-menu-wlan-wi-fi-whitelist-mod/
别人的故障修复案例：http://blog.sina.com.cn/s/blog_6aac786a0102w7l7.html
编程器使用教程：http://tieba.baidu.com/p/6103207732
笔记本开机报警声参考：https://wenku.baidu.com/view/af6a99d2240c844769eaee14.html
台式机开机报警声参考：http://www.doc88.com/p-9965242248173.html
PhoenixBIOS4.0 POST code: https://wenku.baidu.com/view/8eb99766f5335a8102d22093.html
Phoenix ISA/MCA/EISA BIOS Beep codes: http://www.bioscentral.com/beepcodes/phoenixbeep.htm
WinIO硬件端口操作：https://blog.csdn.net/weixin_38907560/article/details/81560943
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de397142cddd6dc026fc93e1c8cce715/" rel="bookmark">
			关于各种软件字体模糊的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于各种软件字体模糊的解决办法 包括adobe acrobat等pdf阅读器，印象笔记等部分字体模糊然后点击又清楚的问题
在设置中找到使用2D渲染加速或类似选项，关闭之。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fd5236df6cb382e69cc539cee2e0025/" rel="bookmark">
			vlan间路由技术和生成树协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标
数据流处理过程
单臂路由工作原理和网络部署
多层交换技术工作原理和网络部署
数据流分析基础
单臂路由实现方式
三层交换路由实现方式
数据流分析基础
二层交换机使用意义
以太网内部局域网组建，端口密度大
基于硬件芯片转发，政府效率高
工作在OSI第二层，转发二层数据
具体层级的数据头部针对
MAC地址表
基于MAC地址表实现二层数据查找转发
收到数据帧查看第二层数据头部提取目标MAC地址 找到对应捆绑的端口使用 交换机
路由器使用意义
多种类型接口，用于连接多个IP子网及多种链路，并实现其互联互通的网络设备
工作在OSI第三层，转发IP数据包
路由表
全局路由表，存储在路由器的内存中，用于指示路由器如何将IP数据包
转发至正确的目的地的信息表
先看MAC是不是发给自己的，如果不是，直接丢弃，如果是自己，剥离第二层，
看第三层目标IP 查看有无去往目标IP的路由
路由器和交换机的部署
交换机用在局域网内部，实现局域网内部通信
路由器放在网络边界 实现远距离互联 运营商专线申请
多个介质多个网段互联 实现广域网互联
同一个子网内如何实现访问，不同子网之间实现访问
同一子网内的访问，数据包封装的目标MAC地址直接为目标设备的MAC
不同网段 ARP广播 不能直接到达，路由器隔离广播 泛洪只能在本网段内部进行
封装的目标MAC地址为网关的MAC
目标PC或者网关的MAC地址可以通过ARP协议获得
单臂路由实现方式
vlan间互通需求
根据连接业务的特点要求实现研发vlan，办公vlan与服务器vlan间数据访问，
不允许研发vlan和办公vlan互访
旁挂的方式，将路由器旁挂到网络边上
三层交换机
所有的子网 所有的vlan必须通过路由器实行一次转发
dot1Q和子接口实现vlan间路由
trunk使得流量全部给路由器
子接口使得vlan区分开
拓扑
用路由器的fa0/1做网关
RT(config)#interface factEthernet 0/1
RT(config-if)#ip address 10.1.1.1/24
RT(config-if)#no shutdown
RT(config)#interface fastEternet 0/1.10
RT(config-subif)#encapsulation dot1Q 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fd5236df6cb382e69cc539cee2e0025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbad9b238dbeaf80dbcf9cfef1df97c5/" rel="bookmark">
			记录一次k8s集群挂掉之后如何恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 查看kubelet的状态 如果是运行状态执行
systemctl restart kubelet 如果是死机状态
systemctl start kubelet 2.查看是否关闭swap free -m 如果未关闭
swapoff -a 3.重新加载文件 systemctl daemon-reload 启动
systemctl restart kubelet 至此解决了我的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebcc3ad34ee1484e942f215d04c2bf4f/" rel="bookmark">
			Tensorflow2.0入门教程19：模型的保存与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、模型保存： 1.保存模型参数
2.保存整个模型
回调函数保存
手动保存
1.回调函数：tf.keras.callbacks.ModelCheckpoint 训练期间保存模型（以 checkpoints 形式保存）,Checkpoint是一个二进制文件，它保存了权重、偏置项、梯度以及其他所有的变量的取值，扩展名为.ckpt
keras.callbacks.ModelCheckpoint(filepath, monitor=‘val_loss’, verbose=0, save_best_only=False, save_weights_only=False, mode=‘auto’, period=1)
filepath：string，保存模型文件的路径。monitor：要监测的数量。verbose：详细信息模式，0或1。save_best_only：如果save_best_only=True，被监测数量的最佳型号不会被覆盖。mode：{auto，min，max}之一。如果save_best_only=True，那么是否覆盖保存文件的决定就取决于被监测数据的最大或者最小值。对于val_acc，这应该是max，对于val_loss这应该是min，等等。在auto模式中，方向是从监测数量的名称自动推断出来的。save_weights_only：如果为True，则仅保存模型的权重（model.save_weights(filepath)），否则保存完整模型（model.save(filepath)）。period:检查点之间的间隔（epoch数）。 import tensorflow as tf (train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data() train_labels = train_labels[:1000] test_labels = test_labels[:1000] train_images = train_images[:1000].reshape(-1, 28 * 28) / 255.0 test_images = test_images[:1000].reshape(-1, 28 * 28) / 255.0 # 定义一个简单的序列模型 def create_model(): model = tf.keras.models.Sequential([ tf.keras.layers.Dense(128, activation='relu', input_shape=(784,)), tf.keras.layers.Dropout(0.2), tf.keras.layers.Dense(10, activation='softmax') ]) model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy']) return model 保存模型参数 model1 = create_model() checkpoint_path1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebcc3ad34ee1484e942f215d04c2bf4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f53b7097e0f8755a5811e55334bbe31/" rel="bookmark">
			spring cloud启动、token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教程重点讲解了SpringCloud各种组件停止更新进入维护阶段后，后续技术组件的升级和替换策略及方案选型，既有传统Eureka、Ribbon、OpenFeign、Hystrix、Config等技术的升级讲解，又有Consul、Gateway、Bus、Stream、Sleuth、zipkin和阿里巴巴最新的Nacos、Sentinel、Seata等技术，分享了服务降级、服务熔断、服务限流、hotkey控制、分布式统一配置管理、分布式全局事务控制、RabbitMQ与Stream整合、Nacos和Nginx配置高可用集群等技术，干货满满！
https://www.bilibili.com/read/cv5421064/ 介绍
Spring Cloud Security
安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。
Spring Cloud Gateway
API网关组件，对请求提供路由及过滤功能。
SpringBoot专注于快速方便的开发单个个体微服务。
SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，
为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务
SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系
SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。
什么是Spring Cloud Config?
在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。
什么是Spring Cloud Gateway?
Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。
nacos作为注册中心，进行注册发现路由转发
Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。
Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；
Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；
Feign：基于Ribbon和Hystrix的声明式服务调用组件；
Zuul：API网关组件，对请求提供路由及过滤功能。
1.获取token的主要流程：
加粗内容为每一步的重点，不想细看的可以只看加粗内容：
用户发起获取token的请求。
过滤器会验证path是否是认证的请求/oauth/token，如果为false，则直接返回没有后续操作。
过滤器通过clientId查询生成一个Authentication对象。
然后会通过username和生成的Authentication对象生成一个UserDetails对象，并检查用户是否存在。
以上全部通过会进入地址/oauth/token，即TokenEndpoint的postAccessToken方法中。
postAccessToken方法中会验证Scope，然后验证是否是refreshToken请求等。
之后调用AbstractTokenGranter中的grant方法。
grant方法中调用AbstractUserDetailsAuthenticationProvider的authenticate方法，通过username和Authentication对象来检索用户是否存在。
然后通过DefaultTokenServices类从tokenStore中获取OAuth2AccessToken对象。
然后将OAuth2AccessToken对象包装进响应流返回。
项目启动顺序
eureka 注册中心
config 配置中心
auth 验证中心
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f53b7097e0f8755a5811e55334bbe31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb024af610e4c5e25850307ba6b95f8/" rel="bookmark">
			解决问题：Fatal error: Uncaught Swoole\Exception: Swoole\Http\Server can only be used in CLI mode in
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fatal error: Uncaught Swoole\Exception: Swoole\Http\Server can only be used in CLI mode in /home/wwwroot/default/twj/swoole/server/http_server.php:5 Stack trace: #0 /home/wwwroot/default/twj/swoole/server/http_server.php(5): Swoole\Server-&gt;__construct('0.0.0.0', 8811) #1 {main} thrown in /home/wwwroot/default/twj/swoole/server/http_server.php on line 5
在执行swolle 的 http_server时候，遇到上面的这个错误，意思就是我们没有使用cli模式去访问。
大家可以使用这个函数来看看你当前的模式
php_sapi_name(); 代码：
浏览器上访问：
linux系统命令行看到是cli
这时候我们又想通过浏览器访问，怎么办？
用虚拟域名+监听的端口就可以了，如图
我没有配置虚拟域名，我是通过我的服务器IP+端口来访问到这个页面的
这时候我们去看监听的文件，显示是cli
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f225ad66ae513fec65b9b17e84f0d6f0/" rel="bookmark">
			IDEA debug模式下没有控制台输出日志怎么打开？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c99d5ce103911cc15b5d769d499aaf/" rel="bookmark">
			【数据库】作业5——SQL练习2 - INDEX / INSERT / SELECT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		INDEX:【例3.13】~【例3.15】INSERT:【例3.69】~【例3.71】REF：使用 INSERT INTO - VALUES 插入数据SELECT:【例3.16】~【例3.28】REF：教材3.4“数据查询”的部分例题 建表&amp;插入数据
1. 在SQLserver上运行，观察运行效果，并把代码写到作业中。
2. 写出自己的理解/收获/心得体会（部分比较复杂的例题，建议增加测试方法和测试数据，举一反三）。
作业原地址：作业
INDEX 1.建立索引
使用CREATE INDEX语句
CREATE [UNIQUE] [CLUSTERER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…);
&lt;表名&gt;：是要建索引的基本表的名字。
索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔。
&lt;次序&gt;：可选ASC（升序）或DESC（降序），默认为ASC。
UNIQUE：表示此索引的每一个索引值只对应唯一的数据记录。
CLUSTER：表示要建立的索引是聚簇索引。（插眼——详细概念在7.5.2）
2.修改索引
对于已经建立的索引，如果需要对其进行重命名，可以使用ALTER INDEX语句
ALTER INDEX &lt;旧索引名&gt;RENAME TO&lt;新索引名&gt;;
3.删除索引
删除索引使用DROP INDEX 语句
DROP INDEX &lt;索引名&gt;;
【例3.13】为学生-课程数据库中的Student，Course和SC三个表建立索引。Student表按学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建唯一索引。
CREATE UNIQUE INDEX Stusno ON Student(Sno); CREATE UNIQUE INDEX Coucno ON Course(Cno); CREATE UNIQUE INDEX SCno ON SC(Sno ASC,Cno DESC); 截图：
【例3.14】将SC表的SCno索引名改为SCSno。
ALTER INDEX SCno RENAME TO SCSno; /*×有问题×*/ 好像又出错了.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c99d5ce103911cc15b5d769d499aaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7abea59d019d8a12e9c21f76cad31ba0/" rel="bookmark">
			Element-UI 使用el-row 高度设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用el-row 布局列数多个时候，出现了高度不适应且排列混乱 的问题
处理办法在 el-row 布局属性上加入
&lt;el-row :gutter="20" class="el-row"&gt; .el-row { margin-bottom: 20px; display: flex; flex-wrap: wrap } .el-card { min-width: 100%; height: 100%; 高度要设置百分比才可以 margin-right: 20px; transition: all .5s; } 设置完成后
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1031720ba7ff19dab99296e2681d4848/" rel="bookmark">
			Element-UI 使用el-row 分栏布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用多个卡片显示的时候，并且要求当列数到一定数目的时候，要自动换行，el-container 布局就满足了需求了，就要用到el-row 布局做分栏处理，
代码如下
&lt;template&gt; &lt;el-row :gutter="20" class="el-row" type="flex" &gt; &lt;el-col :span="8" v-for = "(item,index) in apps" :key="item.id" class="el-col" &gt; &lt;el-card class="el-card" :key="index" onclick=""&gt; &lt;div slot="header" class="clearfix"&gt; &lt;span&gt;{{item.appname}}&lt;/span&gt; &lt;/div&gt; &lt;div &gt; &lt;div class="text item"&gt; &lt;div class="item_tag" &gt; &lt;span &gt;用户标签：&lt;/span&gt; &lt;/div&gt; &lt;div class="item_desr"&gt; &lt;span &gt; {{item.tag}}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="text item"&gt; &lt;div class="item_tag"&gt; &lt;span&gt;搜索标签：&lt;/span&gt; &lt;/div&gt; &lt;div class="item_desr"&gt; {{item.seatag}} &lt;/div&gt; &lt;/div&gt; &lt;div class="text item"&gt; &lt;div class="item_tag"&gt; &lt;span&gt;短信签名：&lt;/span&gt; &lt;/div&gt; &lt;div class="item_desr"&gt; &lt;span&gt; {{item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1031720ba7ff19dab99296e2681d4848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4200c737326f0fb674bf9132397d4ee9/" rel="bookmark">
			Element-UI 使用心得之el-card
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-card 是Element-UI 内置的卡片组件，使用起来很方便，但是对Vuejs和html 不是精通的话，根据自己的要求布局，会出现自己的小困惑，必须添加垂直居中，按照CSS 布局设置，总是 不起作用，与其费力搜寻办法，不如自己简单白痴的去设置一下
1.鼠标放上去有一个动画效果：
.el-card { min-width: 380px; margin-right: 20px; transition: all .5s; } .el-card:hover{ margin-top: -5px; } 2.第三个卡片中的按钮，做到水平垂直效果 ：继承原来的布局属性，加上自己的布局设置
&lt;el-card class="box-card " style="min-height: 200px;" align="middle" onclick=""&gt; &lt;div class="el-card__body mid"&gt; &lt;el-button icon="el-icon-circle-plus" circle&gt;&lt;/el-button&gt; &lt;el-button style="margin-left: 0;color: #505458" type="text"&gt;添加APP&lt;/el-button&gt; &lt;/div&gt; .mid{ margin-top: 25%; height: 50%; } 3.当显示多个卡片时，一直水平排列 ，不能够自动换行，这时候 只能在外层使用 Layout 布局中的分栏布局，会根据设置的列数自动布局
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe6c0dc52290552460bb2351ee442b6/" rel="bookmark">
			成功解决RuntimeError: Variable &#43;= value not supported. Use variable.assign_add(value) to modify the vari
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天又遇到问题了，报错如下：
RuntimeError: Variable += value not supported. Use variable.assign_add(value) to modify the variable value and variable = variable + value to get a new Tensor object.
意思是说这个不支持也就是不要用a+=b，把它换成a=a+b即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7db34f8c9164bddd8176899b05a429/" rel="bookmark">
			开启和禁用hyper-v
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hyper-V会和Vmware，VirtualBox产生冲突，hyper-v和Vmware等只能开启一个。使用vmware产品时必须禁用hyper-v，使用hyper-v时必须开启hyper-v，否则在bios里已经启用了虚拟硬件并开启了hyper-v组件启动Docker时也会提示：Hardware assisted virtualization and data execution protection must be enabled in the BIOS
禁掉 Hyper-V 管理员模式运行 CMD:
//To disable: bcdedit /set hypervisorlaunchtype off 开启Hyper-V //To enable: bcdedit /set hypervisorlaunchtype auto 附赠一条开启hyper-v组件的命令：
dism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All 参考文章
docker desktop : Hardware assisted virtualization and data execution protection must be enabled
如何 禁掉 Hyper-V &amp;&amp; 如何解决禁不掉 Hyper-V 的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d061690f485900ae067171dc2da5ff6/" rel="bookmark">
			从零开始学HTML&amp;&amp;CSS&amp;&amp;JavaScrip——JavaScrip之简易留言板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简易留言板 1.实现的效果要求:2.代码：3.页面上的效果: 1.实现的效果要求: 通过输入框输入内容点击留言按钮，发布到留言板上可以点击留言后面的删除选项进行删除能正确统计出留言板上的留言数量，并用弹框的形式显示出来如果输入框没有内容，点击留言按钮，无法进行留言，同时弹出提示框告知输入内容为空不能留言 2.代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="new_file.css"/&gt; &lt;script type="text/javascript"&gt; window.onload=function(){ var ly=document.getElementById("ly"); var i=1; ly.onclick=function(){ var te=document.getElementById("textss").value; if(te!=""){ var ptext=document.createElement("p"); var span=document.createElement("span"); ptext.innerText=i+"."+te+" "; ptext.className="content"; span.innerText="X"; output.appendChild(ptext); ptext.appendChild(span); document.getElementById("textss").value=""; var dels=document.getElementsByTagName("span"); var ptexts=document.getElementsByTagName("p"); for (var j=0;j&lt;dels.length;j++) { dels[j].index=j; ptexts[j].index=j dels[j].onclick = function () { dels[this.index].remove(); ptexts[this.index].remove(); } } i++; }else{ alert("输入的内容不能为空！！！！"); } } document.getElementById("count").onclick=function(){ alert("留言的数量为:"+(i-1)); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d061690f485900ae067171dc2da5ff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c104bc6f95d6fcf2c11178e99b8c186/" rel="bookmark">
			常见的Tensor操作——tf.reshape; tf.pad; tf.slice; tf.transpose; tf.tile; tf.expand_dims; tf.squeeze
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于Tensor的常见操作无非就是变化一下shape，做个转置，padding一下，取其中固定的维度的信息，增加个维度，减少各维度之类的，具体的分为7个接口，分别如下：
1. tf.reshape 在向量运算时，难免向量的形状跟要求不一致，这个时候需要reshape操作改变向量的形状，该操作只修改各个维度的大小，不修改向量中数据的顺序，比如一个向量a = [1, 2, 3, 4]，它的shape=(4, )，如果想要修改成shape=(2, 2)，那么a = [[1, 2], [3, 4]，而不会变成a = [[1, 3], [2, 4]]。我们经常看到代码中会出现shape = [-1, 2]这种里面出现一个值-1，它表示该维度的值会有其他维度的结果计算得出，shape中可以出现并且仅能出现一个-1值，而且shape中各个维度的数值必须是整数。
# 参数的含义 tf.reshape(tensor, shape, name=None) # 1. tensor: 要修改维度信息的tensor，必填项 # 2. shape: 修改后各个维度的大小，它的乘积必须与原tensor的各个维度乘积相等，必填项 # 3. name: 给这个op取个名字，一般来说都不用写 a = tf.range(24) b = tf.reshape(a, shape=[-1, 2]) c = tf.reshape(a, shape=[2, 3, -1]) d = tf.reshape(a, shape=[2, 3, 4]) e = tf.reshape(a, shape=[-1, ]) f = tf.reshape(a, shape=[-1, 7]) # 这条语句会报错，因为如果a的第二个维度为7，那么第一个维度不能是整数 print (b) # Tensor("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c104bc6f95d6fcf2c11178e99b8c186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd236e30dbe0a0d1dd17fdc89ee0c84/" rel="bookmark">
			redis分布式锁？坑那么多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis分布式锁？坑那么多 一、白话分布式 什么是分布式，用最简单的话来说，就是为了较低单个服务器的压力，将功能分布在不同的机器上面；
就比如：
本来一个程序员可以完成一个项目：需求-&gt;设计-&gt;编码-&gt;测试
但是项目多的时候，一个人也扛不住，这就需要不同的人进行分工合作了
这就是一个简单的分布式协同工作了；
二、分布式锁 首先看一个问题，如果说某个环节被终止或者别侵占，就会发生不可知的事情
这就会出现，设计好的或者设计的半成品会被破坏，导致后面环节出错；
这时候，我们就需要引入分布式锁的概念；
何为分布式锁？
当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。用一个状态值表示锁，对锁的占用和释放通过状态值来标识。 分布式锁的条件：
可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。这把锁要是一把可重入锁（避免死锁）这把锁最好是一把阻塞锁这把锁最好是一把公平锁有高可用的获取锁和释放锁功能获取锁和释放锁的性能要好 分布式锁的实现：
​ 分布式锁的实现由很多种，文件锁、数据库、redis等等，比较多，在实践中，还是redis做分布式锁性能会高一些；
三、redis实现分布式锁 首先看两个命令：
**setnx:**将 key 的值设为 value，当且仅当 key 不存在。 若给定的 key 已经存在，则 SETNX 不做任何动作。 SETNX 是SET if Not eXists的简写。
127.0.0.1:6379&gt; set lock "unlock" OK 127.0.0.1:6379&gt; setnx lock "unlock" (integer) 0 127.0.0.1:6379&gt; setnx lock "lock" (integer) 0 127.0.0.1:6379&gt; expire: EXPIRE key seconds
为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除
127.0.0.1:6379&gt; expire lock 10 (integer) 1 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd236e30dbe0a0d1dd17fdc89ee0c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e6d13326268f26bd333ea7b2020a1e3/" rel="bookmark">
			Linux环境中ElasticSearch启动时常见错误、解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		● ES启动常见报错及解决措施 说明 文章基于ElasicSearch版本：7.3.2，Linux版本：CentOS-7.7。供其他版本参考。
启动报错 报错1—— [xpack.ml.enabled: false] Caused by: org.elasticsearch.ElasticsearchException: Failure running machine learning native code. This could be due to running on an unsupported OS or distribution, missing OS libraries, or a problem with the temp directory. To bypass this problem by running Elasticsearch without machine learning functionality set [xpack.ml.enabled: false]. 解决措施：
vi ElasticSearch-7.3.2/config/elasticsearch.yml 编辑ElasticSearch-7.3.2\config\elasticsearch.yml文件，文件最后追加xpack.ml.enabled: false。注意“:”号存在空格！
报错2——Cannot allocate memory output: # # There is insufficient memory for the Java Runtime Environment to continue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e6d13326268f26bd333ea7b2020a1e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31751350de9eae8274f337a9e9b656c3/" rel="bookmark">
			python操作百度网盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直有种想法，要是我们能用代码操作网盘，我们岂不是可以自动化，解放双手了
无意中发现了一个宝贝bypy，这个可以操作我们的网盘
首先我们要安装它：
[root@VM_0_9_centos ~]# pip install bypy 如果不报错，就说明安装成功了
紧接着就是去和百度进行绑定：
[root@VM_0_9_centos ~]# bypy info 然后需要打开命令行上面显示的链接，拷贝到网页上打开，然后登陆自己的百度账号即可，然后点击授权，就可以得到这么一个页面，我们拷贝这个编码，粘贴到linux中的命令行，然后回车，就能进行授权操作了。
授权成功就会显示这个：
[root@VM_0_9_centos ~]# bypy info Quota: 5.008TB Used: 1.607TB 注：我是授权过了，所以只显示了结果，如果是第一次前面还好出现很多信息，只是最后两行是上面这个内容。
然后在命令行输入bypy -h就会显示提示帮助
[root@VM_0_9_centos ~]# bypy -h usage: bypy [-h] [-V] [-d] [-v] [-r RETRY] [-q] [-t TIMEOUT] [-s SLICE] [--chunk CHUNK] [-e] [-f] [--no-resume-download] [--include-regex INCREGEX] [--on-dup ONDUP] [--no-symlink] [--disable-ssl-check] [--cacerts CACERTS] [--mirror MIRROR] [--select-fastest-mirror] [--rapid-upload-only] [--resume-download-revert-back RCOUNT] [--move] [--processes PROCESSES] [--downloader DOWNLOADER] [--downloader-arguments DOWNLOADER_ARGS] [--config-dir CONFIGDIR] [-c] [command [command .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31751350de9eae8274f337a9e9b656c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183f350bfcafd0f3db3b21e56940efba/" rel="bookmark">
			简单动态留言板的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图展示： 思路 html代码 &lt;textarea name="" id="" cols="30" rows="10"&gt;&lt;/textarea&gt; &lt;button&gt;发表留言&lt;/button&gt; &lt;ul&gt;&lt;/ul&gt; css代码 &lt;style&gt; * { margin: 0; padding: 0; } body { padding: 100px; } textarea { width: 200px; height: 100px; border: 1px solid #000; outline: none; resize: none; } ul { margin-top: 50px; } li { width: 300px; padding: 5px; background-color: rgb(245, 209, 243); color: red; font-size: 14px; margin: 15px 0; } li a { float: right; width: 40px; height: 20px; text-align: center; text-decoration: none; background-color: #fff; border: 1px solid #ccc; color: #000; } &lt;/style&gt; js代码 &lt;script&gt; //点击按钮之后 就动态创建一个li 添加到ul里面 //创建li的同时 把文本域里面的值通过li.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183f350bfcafd0f3db3b21e56940efba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ffed9cd104f46af63c2d957a8f214f/" rel="bookmark">
			PowerShell说明摘要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 了解 PowerShell1-1. 了解重要的 PowerShell 概念1-1-1. 输出是基于对象的1-1-2. 命令系列是可扩展的1-1-3. PowerShell 处理控制台输入和显示1-1-4. PowerShell 使用某些 C# 语法 1-2. 了解 PowerShell 命令名称1-2-1. 学习传统 shell 中的命令名称1-2-2. Cmdlet 使用谓词-名词的名称来减少命令记忆1-2-3. Cmdlet 使用标准参数1-2-3-1. 帮助参数1-2-3-2. 通用参数1-2-3-3. 建议的参数名称 1-3. 使用熟悉的命令名称1-3-1. 解释标准别名1-3-2. 创建新别名 1-4. 获取详细的帮助信息1-4-1. 获取有关 cmdlet 的帮助1-4-2. 获取概念帮助1-4-3. 获取有关提供程序的帮助1-4-4. 获取有关脚本和函数的帮助1-4-5. 在线获取帮助1-4-6. 另请参阅 1-5. 获取有关命令的信息1-5-1. 显示可用的命令类型 1-6. 使用变量存储对象1-6-1. 创建变量1-6-2. 操作变量1-6-3. 使用 cmd.exe 变量 1-7. 了解管道1-7-1. PowerShell 管道1-7-2. 管道中的对象 1-8. 更多 PowerShell 学习1-8-1. 面向 PowerShell 用户的资源1-8-2. Channel 9 视频1-8-3. Microsoft Virtual Academy1-8-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ffed9cd104f46af63c2d957a8f214f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4756889f145de2346d2e460a9c6263/" rel="bookmark">
			使用jmxtrans&#43;influxdb&#43;grafana监控JMX指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接来源：https://www.lagou.com/lgeduarticle/8153.html
使用jmxtrans+influxdb+grafana监控JMX指标 环境信息以Flume为例：1. 开启FlumeJMX端口2. 安装InfluxDB3. 安装jmxtrans4. 安装Grafana 环境信息 CentOS 6.8jdk 1.8.144 废话不多说，先上效果图。
以Flume为例： 需要的环境和安装包如下：
安装包下载链接jmxtranshttps://repo1.maven.org/maven2/org/jmxtrans/jmxtrans/270/jmxtrans-270.rpmInfluxDBhttps://dl.influxdata.com/influxdb/releases/influxdb-1.7.5.x86_64.rpmgrafanahttps://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-6.0.2-1.x86_64.rpm 1. 开启FlumeJMX端口 JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。Flume做为一款Java应用，已经定义了丰富的性能指标，(可以参考Flume监控指标)，通过JMX可以轻松对其进行监控。
参考官网的配置链接: http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#flume-interceptors
在Flume的conf目录下的flume-env.sh export JAVA_OPTS="-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=5445 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false" 重启Flume重启后查看Flume以及JMX端口状态 ps -ef | grep flume atguigu 7024 3138 0 19:31 pts/0 00:00:16 /opt/module/jdk1.8.0_144/bin/java -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=5445 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dflume.monitoring.type=http -Dflume.monitoring.port=34545 -Dflume.root.logger=INFO,console -cp /opt/module/apache-flume-1.7.0/conf:/opt/module/apache-flume-1.7.0/lib/*:/opt/module/hadoop-2.7.2/etc/hadoop:/opt/module/hadoop-2.7.2/share/hadoop/common/lib/*:/opt/module/hadoop-2.7.2/share/hadoop/common/*:/opt/module/hadoop-2.7.2/share/hadoop/hdfs:/opt/module/hadoop-2.7.2/share/hadoop/hdfs/lib/*:/opt/module/hadoop-2.7.2/share/hadoop/hdfs/*:/opt/module/hadoop-2.7.2/share/hadoop/yarn/lib/*:/opt/module/hadoop-2.7.2/share/hadoop/yarn/*:/opt/module/hadoop-2.7.2/share/hadoop/mapreduce/lib/*:/opt/module/hadoop-2.7.2/share/hadoop/mapreduce/*:/opt/module/hadoop-2.7.2/contrib/capacity-scheduler/*.jar:/opt/module/apache-hive-1.2.1/lib/* -Djava.library.path=:/opt/module/hadoop-2.7.2/lib/native org.apache.flume.node.Application -n a1 -f flumeagents/taildirSource-loggerSink.conf netstat -anop | grep 5445 tcp 0 0 :::5445 :::* LISTEN 7024/java off (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c4756889f145de2346d2e460a9c6263/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730599520591e85d4559f18bf15f4448/" rel="bookmark">
			Tomact部署的war包怎么手动打包生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomact部署的war包怎么手动打包生成 win + R 进入cmd里面 ， 然后进入打包的文件中
我这里进去的是E盘的 ww文件里
输入jar -cvf &lt;文件名&gt;.war .
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971c34c08d3cbf5072238c64de152e62/" rel="bookmark">
			小波分析、小波降噪matlab代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小波分析、小波降噪matlab代码实现 软阈值、硬阈值、固定阈值三种方式1. 简介2. 操作步骤3. 直接上代码4. 运行结果显示1. 噪声信号图像2. 硬阈值去噪图像3. 软阈值去噪图像4. 固定阈值去噪图像5. 去噪结果的误差对比 软阈值、硬阈值、固定阈值三种方式 1. 简介 所谓的小波就是指微小的具有波动性的波形，从信号学角度来看，是一个信号滤波的过程。目前，小波去噪已然是一种喜闻乐见的噪声处理方式。
本文使用matlab进行小波降噪，采用软阈值、硬阈值、和固定阈值三种方式，对一维噪声数据进行降噪处理，并输出误差SNR,RMSE,以及降噪前后的噪声图像 。
2. 操作步骤 主要有三个步骤：
对被噪声污染的信号进行小波变换处理；通过对变换后的小波系数进行处理，去除其中的噪声小波逆变换，得到去噪后的信号 3. 直接上代码 %%初始化程序 clear,clc t1=clock; %% 载入噪声信号数据，数据为.mat格式，并且和程序放置在同一个文件夹下 load('filename.mat');%matrix YSJ= filename; %% 数据预处理，数据可能是存储在矩阵或者是EXCEL中的二维数据，衔接为一维的，如果数据是一维数据，此步骤也不会影响数据 [c,l]=size(YSJ); Y=[]; for i=1:c Y=[Y,YSJ(i,:)]; end [c1,l1]=size(Y); X=[1:l1]; %% 绘制噪声信号图像 figure(1); plot(X,Y); xlabel('横坐标'); ylabel('纵坐标'); title('原始信号'); %% 硬阈值处理 lev=3; xd=wden(Y,'heursure','h','one',lev,'db4');%硬阈值去噪处理后的信号序列 figure(2) plot(X,xd) xlabel('横坐标'); ylabel('纵坐标'); title('硬阈值去噪处理') set(gcf,'Color',[1 1 1]) %% 软阈值处理 lev=3; xs=wden(Y,'heursure','s','one',lev,'db4');%软阈值去噪处理后的信号序列 figure(3) plot(X,xs) xlabel('横坐标'); ylabel('纵坐标'); title('软阈值去噪处理') set(gcf,'Color',[1 1 1]) %% 固定阈值后的去噪处理 lev=3; xz=wden(Y,'sqtwolog','s','sln',lev,'db4');%固定阈值去噪处理后的信号序列 figure(4) plot(X,xz); xlabel('横坐标'); ylabel('纵坐标'); title('固定阈值后的去噪处理') set(gcf,'Color',[1 1 1]) %% 计算信噪比SNR Psig=sum(Y*Y')/l1; Pnoi1=sum((Y-xd)*(Y-xd)')/l1; Pnoi2=sum((Y-xs)*(Y-xs)')/l1; Pnoi3=sum((Y-xz)*(Y-xz)')/l1; SNR1=10*log10(Psig/Pnoi1); SNR2=10*log10(Psig/Pnoi2); SNR3=10*log10(Psig/Pnoi3); %% 计算均方根误差RMSE RMSE1=sqrt(Pnoi1); RMSE2=sqrt(Pnoi2); RMSE3=sqrt(Pnoi3); %% 输出结果 disp('-------------三种阈值设定方式的降噪处理结果---------------'); disp(['硬阈值去噪处理的SNR=',num2str(SNR1),'，RMSE=',num2str(RMSE1)]); disp(['软阈值去噪处理的SNR=',num2str(SNR2),'，RMSE=',num2str(RMSE2)]); disp(['固定阈值后的去噪处理SNR=',num2str(SNR3),'，RMSE=',num2str(RMSE3)]); t2=clock; tim=etime(t2,t1); disp(['------------------运行耗时',num2str(tim),'秒-------------------']) 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971c34c08d3cbf5072238c64de152e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/300a2cedd8b7ee561c1b1f0db28d7e05/" rel="bookmark">
			五大常用算法—动态规划详解和经典题目(python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念 把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。
动态规划过程：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。
假设问题是由交叠的子问题所构成，我们就能够用动态规划技术来解决它。一般来说，这种子问题出自对给定问题求解的递推关系中，这个递推关系包括了同样问题的更小子问题的解。动态规划法建议，与其对交叠子问题一次重新的求解，不如把每一个较小子问题仅仅求解一次并把结果记录在表中（动态规划也是空间换时间的）。这样就能够从表中得到原始问题的解。
二、基本思想与策略 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了实用的信息。
在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其它局部解。依次解决各子问题，最后一个子问题就是初始问题的解。
因为动态规划解决的问题多数有重叠子问题这个特点。为降低反复计算。对每个子问题仅仅解一次，将其不同阶段的不同状态保存在一个二维数组中。
与分治法最大的区别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。
三、适用的情况 能采用动态规划求解的问题的一般要具有3个性质：
（1）最优化原理：假设问题的最优解所包括的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
（2）无后效性：即某阶段状态一旦确定。就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响曾经的状态。仅仅与当前状态有关；
（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（该性质并非动态规划适用的必要条件，可是假设没有这条性质，动态规划算法同其它算法相比就不具备优势）。
四、求解的基本步骤 动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。
初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解
(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
(3)确定决策并写出状态转移方程：状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。
只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。
确定状态：最后一步和转化子问题确定转移方程确定边界情况和初始条件确定好计算顺序 五、常见动态规划问题 1、找零钱问题（求最值动态规划）
有面值为1元、2元和7元的硬币若干枚，如何用最少的硬币凑够27元？
1.确定状态 最后一步：（最优策略中使用的最后一枚硬币ak）转化子问题：最少的硬币拼出更小的面值27-ak 2.转移方程
f[X] = min{f[X-2]+1 , f[X-5]+1 , f[x-7]+1}3.初始条件和边界情况
f[0] = 0,如果不能拼出Y,f[Y] = 正无穷4.计算顺序
f[0],f[1],f[2], …代码实现 class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: # 开数组 27 个位置的数组 f = [float("inf")] * (amount+1) # 初始条件：0元0种方法 f[0] = 0 n = len(coins) #f[1],f[2].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/300a2cedd8b7ee561c1b1f0db28d7e05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451a04fa7883a4f8e6d853eacba95f06/" rel="bookmark">
			Oracle对于误删误操作的数据进行恢复（flashback query、flashback drop、flashback table、flashback database）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle对于误删误操作的数据进行恢复。 日常工作中难免遇到自己或者别人误操作、删除、修改了数据库的数据。此时我们该如何恢复数据呢。 1、我们可以应用Flashback Query查询过去的数据 Flashback Query这一特性，最常被应用的就是修复误操作的数据了。注意，这并不是说Flashback Query能够恢复数据。Flashback Query本身不会恢复任何操作或修改，也不能告诉你做过什么操作或修改，实际上Flashback Query特性实际应用时，是基于标准SELECT的扩展，借助该特性能够让用户查询到指定时间点的表中的记录，相当于拥有了看到过去的能力，至于恢复，SELECT的结果都出来了，难道还不懂如何执行INSERT。 注意： Flashback Query查询过去的数据仅对delete 等dml语句有效，如果是通过truncate更改了数据是无法使用 Flashback Query查询过去的数据的 下面举个例子: 首先我准备了一张表，里面有两条数据。 此时我们执行delete语句 将数据删除。 使用flashback query查询 select * from O_MCHT_KEY_API_BAK as of timestamp to_timestamp('2020-03-13 11:00:57', 'yyyy-mm-dd hh24:mi:ss'); 我们可以看到使用flashback query指定时间点为2020-03-13 11:00:57，可以查询到当时的数据是什么样，这个时候我们就可以把这两条数据重新复制出来插到表里，这样就完成了数据恢复。 注意： flashback query有时效性，太久之前的数据会被清除。 如果我们drop了表，该如何恢复呢？ 这里我们先把表drop掉，使用查询可以看到，表已经不存在 2、我们可以应用Flashback table恢复被drop操作的表 这时我们使用flashback query是无法查询到表的原来数据，此时可以使用flashback table。 flashback table O_MCHT_KEY_API_BAK to before drop; 再执行查询之后我们可以看到数据已经恢复成功。
当然flashback tabloe也可以用在对已经delete了的数据进行恢复。 此时我们先删除一行数据，然后执行 flashback table O_MCHT_KEY_API_BAK to timestamp to_timestamp('2020-03-13 11:00:57', 'yyyy-mm-dd hh24:mi:ss'); 可以看到，此时恢复报错，提示[72000][8189] ORA-08189: 因为未启用行移动功能, 不能闪回表
这里只需要给对应的表开启行移动功能即可。 //开启表行移动功能 alter table T_TERM_MCHT_INFO enable row movement; 再次执行 flashback table O_MCHT_KEY_API_BAK to timestamp to_timestamp('2020-03-13 11:00:57', 'yyyy-mm-dd hh24:mi:ss'); 可以看到被删除的一条记录已经恢复成功了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/451a04fa7883a4f8e6d853eacba95f06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8afd188db8cb2b9e087914767fc21ec/" rel="bookmark">
			免费CDN：jsDeliver-Github-搭建过程记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人博客地址 樱花🌸
CDN 解释 内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。
1、 首先创建一个Github仓库 我的仓库名为CDN并不是图中的CDNNAME，因为我已经创建了名字为CDN的仓库，不能创建重复的。
2、 克隆Github仓库到本地 先在本地创建一个文件夹，任意位置都可以（最好不要在C盘），然后进入到文件夹中。
然后再去Github仓库，复制仓库的ssh地址。
在本地目录中右键Git Bash Here,在命令窗口中执行一下命令：
git clone 复制的仓库ssh地址 3、 上传文件到Github仓库 将你要上传的图片视频保存到刚才那个本地文件夹中（上传的单个文件不要大于50M），然后在文件夹中右键Git Bash Here,执行一下命令：
git status //查看状态 git add . //添加所有文件到暂存区 不要忘记后面那个. git commit -m '提交信息' //把文件提交到仓库 git push //推送至远程仓库 4、 发布版本 然后自定义一个发布版本号
到现在就可以使用了。
5、 更新版本 方法一 可以跟上面3、4步骤一样去更新它。
方法二 还有更简便的，前提是已经安装了TortoiseGit.如果没有直接跳过此方法。
1、 首先右键 Git提交
提交右边有个向下的小箭头，可以点选提交并推送。直接完事，然后去github上创建新的版本就可以了。
成功后点击推送。
这就提交到了Github
接下来就是进行第四步的创建版本了。
6、 使用方法 文件网址位置：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径
@发布的版本号 可以不写，默认就是最新版本。
https://cdn.jsdelivr.net/gh/wang1375830242/CDN@1.02/images/Konachan.com-ls-black_hair-f-toriki-touhou.jpg https://cdn.jsdelivr.net/gh/wang1375830242/CDN/images/Konachan.com-ls-black_hair-f-toriki-touhou.jpg 第一个是代版本号的，第二个不带版本号。两个都是一样的图片。
7、 更加具体的方法官网查看 https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8afd188db8cb2b9e087914767fc21ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ade54be6658c854672ad8efa71d98cf8/" rel="bookmark">
			Promise.resolve()与new Promise(r =&gt; r(v))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Promise.resolve方法的参数分成四种情况。 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。
这是一个特殊的情况会和另一种new Promise(r =&gt; r(v))产生不一样的效果，最后说明
参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象
let thenable = { then: function(resolve, reject) { resolve(42); } }; Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。
let thenable = { then: function(resolve, reject) { resolve(42); } }; let p1 = Promise.resolve(thenable); p1.then(function(value) { console.log(value); // 42 }); thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42
参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。
const p = Promise.resolve('Hello'); p.then(function (s){ console.log(s) }); // Hello 由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会执行。Promise.resolve方法的参数，会同时传给回调函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ade54be6658c854672ad8efa71d98cf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19aa043f2f4b81cda06dff3ea6138c29/" rel="bookmark">
			AI初探——百度、阿里、腾讯开放平台OCR功能解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有个小程序的项目，要求使用OCR对名片及车辆的照片进行智能识别。该文会将BAT AI平台OCR功能试用的情况进行详细说明。OCR测试源码已共享，具体参见文末。
网站初览 百度 百度AI平台也叫做百度大脑，分为开放能力、开发平台、行业应用、生态合作、AI市场、开发与教学等栏目。
百度在开发平台上较有特色：比如命名为飞桨的开源深度学习平台等
百度开源深度学习平台
2、阿里
阿里的AI服务与阿里云深度集成：主要有文字、大数据、图影像、视觉、三维场景、机器学习、及各种行业场景的AI解决方案。比如阿里云AI助力新冠新药的研发。
云计算
3、腾讯
腾讯AI开放平台主要分为技术引擎、解决方案、AI加速器、AI资讯、AI在腾讯、文档中心等 。
腾讯AI平台的特点是三大实验室：Ai Lab致力于人工智能；优图致力于识别技术；微信AI致力于微信生态链的人工智能技术。
三大实验室
OCR功能初探 初步了解了BAT AI平台的情况后，接下来回到文章的主题，通过名片识别与车牌识别对三大平台OCR情况作逐一说明：
1、注册及开通
在BAT平台上使用AI开放能力都需要先进行注册，注册后可进入控制台开通对应的API接入。
调用OCR 考虑在windows桌面平台上进行测试调用，OCR调用客户端源码为C#，通过平台提供的Web Api接入方式进行Web调用及测试：具体可参见源码。首先看一下三大平台调用的效果情况：为保证测试的公平性，特地在平台页面下载了例图（百度和腾讯AI的名片图片与车牌图片，阿里云网站未找到例图）
名片例图1识别情况（百度AI网站下载 --名片测试.jpg，例图较模糊）： 百度识别结果：”姓名“，”地址“能识别，电话号码识别错误，”公司“、”手机“、”邮箱“、”网址“，”部门“等未识别出 阿里识别结果： ”公司“，”地址“，”邮箱“，”部门“，”网址“，”姓名“，”移动电话“能识别，”工作电话"未识别 腾讯识别结果：几乎都识别出来了（“手机”将186误识为166），识别的“电话”也能带格式。 名片例图2识别情况（腾讯AI网站下载 --名片测试.jpg，例图较清晰）： 百度识别结果：能识别。 阿里识别结果：能识别。 腾讯识别结果：能识别“QQ”、“微信”。 车牌例图1识别情况（百度AI网站下载 --车牌测试.jpg，车牌较近）： 百度识别结果：能识别蓝牌与车牌号 阿里识别结果：能识别车辆类型与车牌号 腾讯识别结果：能识别车牌号 车牌例图2识别情况（ 腾讯AI网站下载 --车牌测试.jpg，车牌较小）： 百度识别结果： 阿里识别结果： 腾讯识别结果： 以上测试受限于电脑环境、网络情况等，仅做参考，无排名之分。
接入代码解析 百度： HTTP 方法: POST 请求URL: https://aip.baidubce.com/rest/2.0/ocr/v1/license_plate URL参数：ccess_token	（通过API Key和Secret Key获取的access_token） Header如下： Content-Type	application/x-www-form-urlencoded Body请求参数 image	：	图像数据，base64编码后进行urlencode，要求base64编码和urlencode后大小不超过4M，最短边至少15px，最长边最大4096px,支持jpg/jpeg/png/bmp格式 百度OCR调用源码截图
阿里： 车牌调用地址：http(s)://ocrcp.market.alicloudapi.com/rest/160601/ocr/ocr_vehicle_plate.json 请求方式：POST 返回类型：JSON 请求参数（Body）： { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19aa043f2f4b81cda06dff3ea6138c29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/079cf21133d93be9d8b0ae4c84eac9ed/" rel="bookmark">
			Python3 快手视频爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提 我们有一些具体的快手播放地址例如：
https://live.kuaishou.com/u/shengxue1111/3xwgehu7uyudyeq
打开后出现如下
目的 拿到视频的播放地址
解决过程 首先是F12看见返回的网页里面在最后有一个json串
但是在用代码请求的时候没有这个东西，根据地址栏发生了变化 变为了
https://live.kuaishou.com/u/shengxue1111/3xwgehu7uyudyeq?did=web_975948772fda54ca569800162f04e530
猜测可能是有一些跳转，于是清空了 cookie 和缓存的文件，重新请求下发现了端倪
返回的结果里面也有具体的MP4的播放地址
观察其实首页进行了跳转，在response里面有 set cookie
接下来要啥啥，就不用多说了吧，上代码
# coding:utf-8 import pymysql import requests import re import time import json headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36', 'Host': 'live.kuaishou.com', 'content-type': 'application/json', } url = data[1] print(f"开始请求 {url}") response = None response = requests.get(url, headers=headers) text = response.text cookie = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/079cf21133d93be9d8b0ae4c84eac9ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1834a41a96bd6412ccc61e11062e6322/" rel="bookmark">
			AttributeError: &#39;NoneType&#39; object has no attribute &#39;xpath&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 请求时加一个头部信息：
headers={"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36"} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84efd5c32ac80c09561e17093c068e0c/" rel="bookmark">
			MDT 测评 | 小米 10 Pro — 屏幕素质报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小米手机 10 Pro, 迄今为止小米史上屏幕最好的手机，达到了 2340*1080 的FHD+ 分辨率，以及 90Hz 刷新率，同时还拥有出场校准的支持，以及所谓的「色彩管理」，这篇就是 MDT 对它的完整屏幕测试，其他部分的测试也即将完成。
*本次测试基于小米 10 Pro 国行量产销售版本。 色彩模式与色域覆盖： 小米 10 Pro 给出了相当多种类的色彩模式，首先我们在设置中能找到四种色彩模式，分别是自适应、鲜艳、原色和高级设置。 而高级设置之中又有四种模式：鲜艳、原色、P3 色域、sRGB 色域，每一种模式都可以选择进一步的调整选项，这对于专业用户来说很友好，可以通过它解决一些伽马不准确或者 RGB 不平衡的问题。
经过我们的测试，除了直接标明色彩空间的 P3 和 sRGB 模式之外，小米 10Pro 的鲜艳模式，自适应模式和原色模式的最大色彩分别对应了屏幕的极限颜色，P3 和 sRGB 色彩空间。
原色/sRGB模式能覆盖：99.6% sRGB (越接近 100% 越好) 自适应/P3模式能覆盖：95.1% P3 (越接近 100% 越好) 从上边的示意图也能看出来，对于 sRGB 来说覆盖还是很精准的，除了蓝色有一些偏离之外，红绿的极限覆盖都很不错，但是自适应模式表现稍差，主要在于红色有些不足，绿色有些超出，以及蓝色稍微偏差。
如果切换到「瞎艳一通」鲜艳模式的话，那么会达到： 100% sRGB 色域覆盖；172.4% sRGB 色域容积93.5% Adobe RGB 色域覆盖；118.8% Adobe RGB 色域容积100% P3 色域覆盖；122.1% P3 色域容积 但是这个模式还是太瞎眼了，也不符合任何内容标准，所以并不推荐使用。
在色彩管理方面： 只有自适应和原色模式能根据显示的内容来切换色域，但是经过我们的测试这只在官方的相册 App 中能自动识别图片嵌入的颜色配置文件，并且在第三方 App 开启时都无法识别而是转而使用 sRGB, 并不能称之为真正的「全局色彩管理」，而是「手动白名单色彩空间切换」。 另外，如果我们把色彩模式切换到原色或者 sRGB 模式，那么明显能看出 MIUI 11 的系统 UI 是直接被从 P3 色域压缩到了 sRGB, 所以看起来会非常灰暗和欠饱和，这明显还是因为在开发的过程中没有考虑过色彩管理实行一刀切的结果。 因此综合来看，所以我们在接下来的测试之中也选择的是自适应和原色模式，我们也还是推荐大家优先选择自适应模式，然后在需要修图的时候切换到原色/sRGB 以保证分享时的准确性。 光谱： 光谱方面，我们能看出小米 10 Pro 由于 OLED 的特性，蓝光波峰约在 460nm 左右，可以说是避开了 415-455nm 对人眼刺激较大的蓝光波长区域，不需要担心对人眼有较大伤害，RGB 三色的波峰也更纯净，这也是 OLED 的优势，相对于 LCD 来说能很轻易地实现更鲜艳的颜色。 白色准确性测试： 在白点方面，经过测试小米 10 Pro 在自适应/鲜艳模式下默认色温为 7340K, 相对于 sRGB 的标准 6500K 会更偏冷，不过这也是更加符合国人习惯的做法，大部分人看到 6500K 的标准色温都会觉得偏黄。 同时小米 10 Pro也提供了色温切换的选项，在自适应/鲜艳模式最暖情况下（上图橙色点）色温为 6659K, 最冷情况下（下图蓝色点）色温为 8009K.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84efd5c32ac80c09561e17093c068e0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c1e3c4cbc9c34985357e855b6bb6870/" rel="bookmark">
			基于卷积神经网络（CNN）的图像识别 之 火焰识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境描述
操作系统：windows10
开发语言：python3.7.6
深度学习后端：tensorflow2.1.0
深度学习前端：keras（tensorflow内嵌的keras）
显卡：GTX1050TI（安装cuda）
一、准备数据
从百度或谷歌上搜火、火焰、火灾等图片，建立两个文件夹（因为是二分类问题，有火or无火）fire和nofire。效果如下：
截图的文件夹分为conv和不带conv的文件夹，其实是火和无火的图片是经过多次添加的，因为训练数据的过程中会发现某些图片识别效果不是很好，所以得在训练样本中增加特定的图片（比如初次训练的时候没有增加枯草的图片进行训练，然后验证的时候会发现训练结果会误把枯草识别成火，因为数据应该是多次修正和新增的），conv文件夹其实就是将不带conv文件夹内的图片进行统一尺寸和格式（因为网上下载的数据基本上不可能统一尺寸，为了使用深度学习工具进行训练和张量运算，因此要统一尺寸）。
如下图，火的数据：
无火的数据如下：
将图片统一尺寸代码如下（需要自行修改图片路径）：
from PIL import Image import os.path import glob def convertjpg(jpgfile,outdir,width=300,height=300): img=Image.open(jpgfile) try: new_img=img.resize((width,height),Image.BILINEAR) new_img.save(os.path.join(outdir,os.path.basename(jpgfile))) except Exception as e: print(e) for jpgfile in glob.glob('E:/fireimages/sources/nofire-1/*.jpg'): convertjpg(jpgfile,'E:/fireimages/sources/conv_nofire-1') 二、调整数据
新建train和val两个文件夹，将统一尺寸后的图片基本上按照5:1的比例分配到train和val两个文件夹内，train里面包含fire和nofire两个文件夹，val同理，如下图：
三、使用googlenet（inceptionV3模型进行训练）
上代码，自行修改路径：
from tensorflow import keras from keras.applications.inception_v3 import InceptionV3 import numpy as np from keras.preprocessing.image import ImageDataGenerator from keras import models from keras import layers import os from keras import optimizers from keras.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c1e3c4cbc9c34985357e855b6bb6870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55beb6d13d7aa2536807906b68270493/" rel="bookmark">
			Error: Request failed with status code 404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误表示：没有这个路径，查看自己的路径
const result=await this.$http.get(’./api/ligin’,{params:this.model})
这里get路径应该是./api/login o我写的i
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547459704d3b36ce8c32a9559fc388e7/" rel="bookmark">
			Spring Framework源码搭建报错：1、gradle版本不兼容，2、org.springframework.objenesis.xx 不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、gradle版本不兼容2、org.springframework.objenesis.xx 不存在 在用Idea导入Spring Framework源码的时候出现了以下情况的错误： 1、gradle版本不兼容 由于Spring Framework源码是用gradle构建的，我们在选择gradle版本的时候，一定要用Spring Framework默认配置的gradle的版本，gradle版本在Spring Framework目录\spring-framework-5.1.0\gradle\wrapper\gradle-wrapper.properties下，如下图：
上图显示Spring Framework源码默认配的gradle的版本是V4.8.1，最好也是用此版本构建Spring Framework，不然可能会出现不兼容的情况，那么如何配置成V4.8.1？如下图：
在Idea 点击 File | Settings | Build, Execution, Deployment | Build Tools | Gradle
选择使用默认构建版本即可
2、org.springframework.objenesis.xx 不存在 在解决gradle版本不兼容的问题后，构建项目的时候又报类不存在的问题，如下显示：
Error:(20, 50) java: 程序包org.springframework.objenesis.instantiator不存在 Error:(21, 46) java: 程序包org.springframework.objenesis.strategy不存在 Error:(22, 46) java: 程序包org.springframework.objenesis.strategy不存在 Error:(35, 41) java: 找不到符号 符号: 类 Objenesis Error:(47, 23) java: 找不到符号 符号: 类 InstantiatorStrategy 位置: 类 org.springframework.objenesis.SpringObjenesis Error:(49, 60) java: 找不到符号 符号: 类 ObjectInstantiator 位置: 类 org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/547459704d3b36ce8c32a9559fc388e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a0d4250d3b2edc7e3a8f5b638a07010/" rel="bookmark">
			Logstash-安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Logstash安装非常简单
目录
一、Logstash作用
二、安装方法
一、Logstash作用 二、安装方法 1，下载对应的软件包
2，确保本地Java环境是1.8
3，解压后，进入logstash文件文件夹内，运行如下命令
bin/logstash -e 'input { stdin { } } output { stdout {} }' 启动完成后，
终端提示如下界面，则表示启动成功
然后继续输入hello world，即如下的显示
即表明logstash安装成功。
三、指定conf文件启动 启动命令为
bin/logstash -f logstash_elasticsearch.conf 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d803f2b5fbe668ff6541a1122fdf9a2/" rel="bookmark">
			RabbitMQ实战教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是MQ
消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。
其主要用途：不同进程Process/线程Thread之间通信。
为什么会产生消息队列？有几个原因：
不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；
不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；
关于消息队列的详细介绍请参阅：
《Java帝国之消息队列》
《一个故事告诉你什么是消息队列》
《到底什么时候该使用MQ》
MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。
2.RabbitMQ
2.1.RabbitMQ的简介
开发语言：Erlang – 面向并发的编程语言。
2.1.1.AMQP
AMQP是消息队列的一个协议。
2.2.官网
2.3.MQ的其他产品
2.4.学习5种队列
2.5.安装文档
3.搭建RabbitMQ环境
3.1.下载
下载地址：http://www.rabbitmq.com/download.html
3.2.windows下安装
3.2.1.安装Erlang
下载：http://www.erlang.org/download/otp_win64_17.3.exe
安装：
安装完成。
3.2.2.安装RabbitMQ
安装完成。
开始菜单里出现如下选项：
启动、停止、重新安装等。
3.2.3.启用管理工具
1、双击
2、进入C:\Program Files (x86)\RabbitMQ Server\rabbitmq_server-3.4.1\sbin输入命令：
rabbitmq-plugins enable rabbitmq_management
这样就启动了管理工具，可以试一下命令：
停止：net stop RabbitMQ
启动：net start RabbitMQ
3、在浏览器中输入地址查看：http://127.0.0.1:15672/
4、使用默认账号登录：guest/ guest
3.3.Linux下安装
3.3.1.安装Erlang
3.3.2.添加yum支持
cd /usr/local/src/
mkdir rabbitmq
cd rabbitmq
wget http://packages.erlang-solutions ... ns-1.0-1.noarch.rpm
rpm -Uvh erlang-solutions-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d803f2b5fbe668ff6541a1122fdf9a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/795d4071c884e4a6f765b8ce3cce12a8/" rel="bookmark">
			confluence忘记密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab40560222302fc407a8748e2188ca19/" rel="bookmark">
			ESP-15F的认识和入门使用。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 概述1.1. 主要参数1.2. 外观1.3. 管脚定义1.4. 模块内部原理图二、 硬件设计2.1 典型接线图实物接线图 2.2 供电2.3 天线布局要求2.4 GPIO口的使用三、模块应用3.1 模块的烧录3.2 模块各种启动信息说明3.3 AT指令的演示TCP相关的演示UDP相关的演示HTTP相关的演示配网相关的演示注：（配网的时候建议手机更新一下微信和打开手机GPS定位） 一、 概述 手上拿到了 一个ESP-15F， 是由安信可科技开发的Wi-Fi模块，该模块核心处理器 ESP8266 在较小尺寸封装中集成了业界领先的 Tensilica L106 超低功耗 32 位微型 MCU，带有 16 位精简模式，主频支持 80 MHz 和 160 MHz，支持 RTOS，集成 Wi-Fi MAC/ BB/RF/PA/LNA。
1.1. 主要参数 参数
模块型号ESP-15F封装PH2.54接线器/DIP-8封装尺寸41.324.16.6(±0.2)MM（LWH，高度以排针母座为准）天线形式板载 PCB 天线/IPEX 外接天线频谱范围2400 ~ 2483.5MHz工作温度-20 ℃ ~ 70 ℃存储环境-40 ℃ ~ 125 ℃ , &lt; 90%RH供电范围供电电压 5V，供电电流 &gt;800mA支持接口仅支持 UARTIO口数量3（预留）串口速率支持110 ~ 4608000 bps ，默认115200 bps安全性WEP/WPA-PSK/WPA2-PSKSPI Flash默认32Mbit 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab40560222302fc407a8748e2188ca19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90769543fb2956d16591cd0c13cebd24/" rel="bookmark">
			利用arduino制作BadUSB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BadUSB BadUSB是由arsten Nohl和Jakob Lell共同发现，并在2014年的BlackHat安全大会上公布的USB漏洞。早期的U盘病毒是在正常的U盘中存入一个autorun.inf可以自启动程序的小脚本，来自动运行某些程序，以此来达到木马入侵或者病毒攻击的效果，但毕竟时代在进步，如此简单的攻击方法自然很容易就会被各种杀软以及系统自带的防御系统识别kill掉，而且后来微软也发现了这个安全漏洞以至于之后的windows系统版本默认也是吧autorun关闭掉的，所以这种攻击方法已经显得极其鸡肋，于是乎就出现了另一种USB攻击思路，USB设备芯片中往往会有一块闪存负责存储数据，他的作用就像是我们电脑上的硬盘，而在这块闪存中会预留一部分用于存储设备固件，而这中新的思路就是将恶意代码直接植入进固件中，这样既不会被杀软察觉更不会被kill掉而将这种思路付诸实践的就是BadUSB。
早期的BadUSB实现方式有两种：
USB RUBBER DUCKY
简称USB橡皮鸭，是最早的按键注入工具，通过嵌入式开发板实现，后来发展成为一个完全成熟的商业化按键注入攻击平台。它的原理同样是将USB设备模拟成为键盘，让电脑识别成为键盘，然后进行脚本模拟按键进行攻击，现已成为一个商业化的产品。
缺点：通用性较差，需要定制，且根据我的淘宝调研， 他的价格要比之后的两者贵不少，果断pass TEENSY
攻击者在定制攻击设备时，会向USB设备中置入一个攻击芯片，此攻击芯片是一个非常小而且功能完整的单片机开发系统---TEENSY。通过TEENSY你可以模拟出一个键盘和鼠标，当你插入这个定制的USB设备时，电脑会识别为一个键盘，利用设备中的微处理器与存储空间和编程进去的攻击代码，就可以向主机发送控制命令，从而完全控制主机，无论自动播放是否开启，都可以成功 缺点：需要购买定制芯片，且芯片中的程序不开源， 虽然也可以用arduino IDE来做程序的开发， 但这东西不太讨我喜欢，毕竟我是一个凡事都追求开源的人 在后来就轮到最讨我喜欢得arduino了，相比USB RUBBER DUCKY他更廉价且通用性更好，相比TEENSY他开源
首先要说明的是，因为BadUSB的基本实现方法是将一块arduino开发板为装成一个键盘设备来对受害设备进行控制，所以要选用支持USB直接通讯的开发板，不要妄想用arduino nano之类将串口通过CH340G之类转换芯片转换成USB的开发板，一来用了这些转换芯片的的开发板在新设备上想要被识别需要安装驱动（你在渗透攻击受害者电脑的时候总不可能盼着受害人自己安装驱动自己坑自己），二来之后我们要用到的一个头文件只支持有直接USB通讯能力的开发板。
所以我在这就用了Arduino micro开发板，首先他体积够小，其次因为他用ATmega32U4做核心芯片，所以他直接支持USB通讯，详情可自行上网查询关于ATmega32U4的芯片手册
在这里我放了三块开发板，其中中间这一个与装在袋子里的这一个都是我们需要的micro开发板，而上面插杜邦线的这块是Arduino Nano开发板，这两种开发板外观虽然长得非常像，但区别却很大，首先Arduino Nano使用的USB接口是老式的Mini USB接口也也就是早期老式手机的那种充电线，而Micro使用的是现在安卓设备通用的mirco USB接口的数据线，nano使用的芯片一般为ATmega328P或者ATmega168这两种芯片都不支持直接进行USB通讯，需要将串口转换为USB，也就是我刚刚提到的那种情况，而micro使用ATmega32U4的芯片，他支持直接进行USB通讯，但是32U4的价格也要比328P以及168要贵一点，所以开发板自然也就贵一点，除此之外他们两者最大的一个外观区别就是nano要比micro要大不少，nano想要装进U盘外壳且还能完美伪装基本上是不可能的。
我的单个一块开发板大概是17RMB包邮，如果有大量需要但是有觉得零售价格太贵的话，可以考虑直接买ATmega32U4的芯片直接自己DIY一个arduino micro开发板，他是完全开源的（开源万岁），可以直接从官网下载原理图以及PCB图拿去抄板，然后再将bootloader烧写进去就好了
arduino micro官网：
Arduino Mirco
注意官网只有Eagle格式的，没有AD格式的
硬件说完，就该说说软件的开发环境了，开发环境自然是用Arduino IDE可以直接从官网下载所需版本，我这里用的是linux版
在这我要说明的是，Linux下下载好tar.gz压缩包后，解压以后直接打开arduino写代码就好了，不要用install.sh做没必要的安装，而且我在kali下用install.sh安装后使用发现无法正常上传程序并且还导致开发板无法被识别，需要复位后才可以，切忌切忌
打开IDE后如果开发板没有问题的话在工具=》端口一栏中会有/dev/ttyACM0(Arduino Micro)（windows下为COMx(Arduino Micro))的一个勾选框，将它勾选，如过开发板连接有问题或者没有连接开发板的话则只有/dev/ttyS0（windows下为COM1，COM2）,开发板一栏默认会被选为arduino micro如果没被选中请自行选中
然后就可以开始写代码了
如果在linux下出现IDE中无法选择端口的情况，到/dev目录下，找到你的开发板连接电脑后对应的文件，然后sudo chmod 777 /dev/‘你的开发板对应的文件,一个叫tty什么什么的文件
如何查看是哪个文件，你可以在插开发板前ls看一下，插上后再ls看一下，比对插上后比插前多了哪个文件，多出来的那个就是
我这里简单写一个在windows下运行，打开cmd窗口后运行tree指令的代码
#include &lt;Keyboard.h&gt; void setup() { // put your setup code here, to run once: //初始化键盘 Keyboard.begin(); //按下键盘左边的win建 Keyboard.press(KEY_LEFT_GUI); //延时让系统反应 delay(500); //按下r键 Keyboard.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90769543fb2956d16591cd0c13cebd24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6815cbbbe191cc5cf1e5893a552fb6/" rel="bookmark">
			解决vue脚手架问题-Vue项目启动报错This is probably not a problem with npm. There is likely additional logging outp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		111
a111 删除node_modules 以及C盘用户里的有关文件
a222
问题：自己写的代码跑不通，用课程代码就可以跑通，之后自己的代码也通了，但是在登录提交数据判断的时候，用的是课程代码而非自己的代码，而界面仍是自己的界面
这是因为课程代码跑通之后，C盘下载了相应的MOCK数据，后面再用自己的代码跑，仍是课程代码的环境，所以界面是自己的界面，后台判断是课程代码的环境。
如果先用自己的代码跑不通，那么C盘下载的数据就是自己的代码环境，这时课程代码跑一遍也会跑不通，因为用的环境仍是自己的代码
昨晚，在教我前端交流群里面的朋友搭建vue开发环境和构建vue项目的时候发现我自己之前能正常构建vue项目的现在却不行了，排查之下发现
通过脚手架构建项目的时候项目缺失了node_modules文件夹，在我排除了node环境、和配置的环境变量、vue-cli和webpack等一切都没有问题的情况下
差点重新删除node环境和vue脚手架等重装了，但是幸亏我多看了几眼cmd, 发现了貌似是和package-lock.json有关，于是我尝试通过：
npm install express 来解决问题，结果是 node_modules文件夹已经出来了，但是依然没有办法通过 npm run dev 正常运行
于是继续 npm install 发现还是不行，后来发现其实问题很简单，
npm install的执行过程是这样的：
1. 发出npm install命令
2. npm 向 registry 查询模块压缩包的网址
3. 下载压缩包，存放在(本地NPM缓存路径)目录
4. 解压压缩包到当前项目的node_modules目录
也就是说一个模块安装以后，本地其实保存了两份。一份是 npm 目录下的压缩包，另一份是 node_modules 目录下解压后的代码。但是，运行 npm install 的时候，只会检查 node_modules 目录，而不会检查 npm 目录。如果一个模块在 npm 下有压缩包，但是没有安装在 node_modules 目录中，npm 依然会从远程仓库下载一次新的压缩包。
利用已经在缓存中，之前已经备份的模块实现离线模块安装的 cache 机制已经在V5的时候重写了，缓存将由 npm 来全局维护，不再需要开发人员操心，离线安装时将不再尝试连接网络，而是降级尝试从缓存中读取，或者直接失败。就是如果你 offline（离线） ，npm将无缝地使用您的缓存。
所以解决办法就是执行命令清除缓存，npm cache clean --force 命令就是清除这种缓存的，
在执行清除命令之后再重新== npm install ==初始化项目（如果卡住一直不动，可以重新 npm install 重新初始），初始化成功之后再通过 npm run dev 就可以正常运行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11e701678f384f27e1eb4c23be58219/" rel="bookmark">
			vmware ESXi 部署vmdk&#43;ovf格式的虚拟机报错：缺少所需要的磁盘映像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能是修改了OVF/VMDK的文件名，但是OVF里的文件名没有修改，此时可以修改OVF中文件名或者还原OVF/VMDK的文件名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5597c1a26db1707f3842c90e436c01b/" rel="bookmark">
			master主节点初始化报错 /proc/sys/net/ipv4/ip_forward contents are not set to 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：master主节点初始化报错
[root@harbor01 ~]# kubeadm init --config kubeadm-config.yaml
W0311 17:15:57.116061 8185 validation.go:28] Cannot validate kube-proxy config - no validator is available
W0311 17:15:57.116107 8185 validation.go:28] Cannot validate kubelet config - no validator is available
[init] Using Kubernetes version: v1.17.3
[preflight] Running pre-flight checks
[WARNING IsDockerSystemdCheck]: detected “cgroupfs” as the Docker cgroup driver. The recommended driver is “systemd”. Please follow the guide at https://kubernetes.io/docs/setup/cri/
error execution phase preflight: [preflight] Some fatal errors occurred:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5597c1a26db1707f3842c90e436c01b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/affe2fdc749ebc70f79cd9fdc782e7c6/" rel="bookmark">
			重定向  请求转发  与cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是cookie cookie可以说是一种缓存，cookie不是jsp内置对象，所以我们在使用的时候需要创建它，而cookie是由服务器创建，然后发送给客户端。
服务器端创建cookie Cookie cookie=new Cookie(key,value); 服务器端添加cookie到响应中去 response.addCookie(cookie); 如何获得cookie Cookie[] cookies=request.getCookies(); //只能拿到所有cookie，不能只拿一个 重定向 语法：
response.sendRedirect(要重定向的页面的相对路径); 请求转发 语法：
request.getRequestDispatcher(要请求转发的页面的相对路径).forward(request,response); 重定向与请求转发的比较 1： 重定向是两次请求，而请求转发是一次请求
解释：比如我们请求index.jsp页面，再由index.jsp页面重定向到success.jsp页面，那么在请求完index.jsp页面后，index.jsp直接给客户端一个响应，然后客户端再重新发出第二次请求，这次请求是请求页面success.jsp.
而如果是在index.jsp请求转发到success.jsp，那么再请求到达服务器后请求到index.jsp页面时，并不会立即将index.jsp页面响应给客户端，而是直接跳转到success.jsp,在请求success.jsp后再响应到客户端，所以只有一次响应
2：重定向地址栏路径会发生变化，而请求转发地址栏不会发生变化，还是index.jsp的后缀。
一个cookie的例子来了解这三个知识 我们创建一个web项目，主要用到四个jsp文件，他们分别是index.jsp
index2.jsp, success1.jsp success2.jsp
webapp目录如图：
这个简单项目主要是为了探究以下问题
在index.jsp中新建cookie,用response.addCookie方法发送给客户端，但是我们直接在index.jsp页面中重定向到success1.jsp页面。并且我们在success1.jsp页面中尝试获取所有cookie并打印在index2.jsp中新建cookie,用response.addCookie方法发送给客户端，但是我们直接在index2.jsp页面中请求转发到success2.jsp页面。并且我们在success2.jsp页面中尝试获取所有cookie并打印 下面先来看代码：
index.jsp:
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Cookie cookie=new Cookie("name","myCookie"); response.addCookie(cookie); response.sendRedirect("success1.jsp"); %&gt; &lt;/body&gt; &lt;/html&gt; success1.jsp:
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Cookie[] cookies=request.getCookies(); if(cookies==null){ out.print("cookie为空"); }{ for(int i=0;i&lt;cookies.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/affe2fdc749ebc70f79cd9fdc782e7c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f8ac6085c59dd0a75f313845b46926/" rel="bookmark">
			MoM(五)解矩阵方程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在阻抗矩阵填充之后，接下来就是解矩阵方程了。后期在补上公式，先上代码。
注意：方程求得解是 函数的系数。
#pragma once #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;armadillo&gt; #include&lt;math.h&gt; #include&lt;complex&gt; #include&lt;time.h&gt; #include&lt;cmath&gt; #include"FillZmat.h" using namespace arma; using namespace std; extern double k; extern mat basis_list; extern cube element_list; extern int elem_num; extern int rwg_num; extern mat Center; extern vec Area; extern mat CommonEdgeP; extern mat CommonEdgeN; extern vec EdgeLength; //公共边长度 extern vec Vertex_pos; // 正三角形的 非公共边点 编号 extern vec Vertex_naga; extern cube Center_; //九点积分划分后的小三角形重心 extern mat Pho_Pos; //对于正element三角形 非公共边点到重心的向量坐标 extern mat Pho_Naga; //对于负element三角形 非公共边点到重心的向量坐标 extern cube Pho_Pos_; //对于正element三角形 九点划分后 非公共边点到 小三角形重心的向量坐标 extern cube Pho_Naga_; //对于负element三角形 九点划分后 非公共边点到 小三角形重心的向量坐标 extern cx_mat Z; extern rowvec Pol, dz; //定义入射波的极化方向和入射方向(only for r_s = 1) extern double FeedVoltage; //定义馈电电压 extern rowvec FeedEdge; //定义馈电边的EdgeElement编号 rowvec kv(1, 3); cx_colvec I, V; double P_rad = 0; void SolveMat() { kv = k * dz; FillmatZ(); double ScalarTemp = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f8ac6085c59dd0a75f313845b46926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad657a065cb88de90ed976cb719db40/" rel="bookmark">
			推荐系统之ALS算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ALS算法是2008年以来，用的比较多的协同过滤算法。它已经集成到Spark的Mllib库中，使用起来比较方便。
从协同过滤的分类来说，ALS算法属于User-Item CF，也叫做混合CF。它同时考虑了User和Item两个方面。
用户和商品的关系，可以抽象为如下的三元组：&lt;User,Item,Rating&gt;。其中，Rating是用户对商品的评分，表征用户对该商品的喜好程度。
ALS算法是基于模型的推荐算法。起基本思想是对稀疏矩阵进行模型分解，评估出缺失项的值，以此来得到一个基本的训练模型。然后依照此模型可以针对新的用户和物品数据进行评估。ALS是采用交替的最小二乘法来算出缺失项的。交替的最小二乘法是在最小二乘法的基础上发展而来的。
假设我们有一批用户数据，其中包含m个User和n个Item，则我们定义Rating矩阵，其中的元素表示第u个User对第i个Item的评分。
一般情况下，k的值远小于n和m的值，从而达到了数据降维的目的。在实际使用中，由于n和m的数量都十分巨大，因此R矩阵的规模很容易就会突破1亿项。这时候，传统的矩阵分解方法对于这么大的数据量已经是很难处理了。
另一方面，一个用户也不可能给所有商品评分，因此，R矩阵注定是个稀疏矩阵。矩阵中所缺失的评分，又叫做missing item。
针对这样的特点，我们可以假设用户和商品之间存在若干关联维度（比如用户年龄、性别、受教育程度和商品的外观、价格等），我们只需要将R矩阵投射到这些维度上即可。这个投射的数学表示是：
这里的表明这个投射只是一个近似的空间变换。一般情况下，k的值远小于n和m的值，从而达到了数据降维的目的。
幸运的是，我们并不需要显式的定义这些关联维度，而只需要假定它们存在即可，因此这里的关联维度又被称为Latent factor。k的典型取值一般是20～200。
这种方法被称为概率矩阵分解算法(probabilistic matrix factorization，PMF)。ALS算法是PMF在数值计算方面的应用。
为了使低秩矩阵X和Y尽可能地逼近R，需要最小化下面的平方误差损失函数：
考虑到矩阵的稳定性问题，使用Tikhonov regularization，则上式变为：
优化上式，得到训练结果矩阵。预测时，将User和Item代入，即可得到相应的评分预测值。
同时，矩阵X和Y，还可以用于比较不同的User（或Item）之间的相似度，如下图所示
ALS算法的缺点在于：
1.它是一个离线算法。
2.无法准确评估新加入的用户或商品。这个问题也被称为Cold Start问题。
ALS算法优化过程的推导 隐式反馈 用户给商品评分是个非常简单粗暴的用户行为。在实际的电商网站中，还有大量的用户行为，同样能够间接反映用户的喜好，比如用户的购买记录、搜索关键字，甚至是鼠标的移动。我们将这些间接用户行为称之为隐式反馈（implicit feedback），以区别于评分这样的显式反馈（explicit feedback）。
隐式反馈有以下几个特点：
1.没有负面反馈（negative feedback）。用户一般会直接忽略不喜欢的商品，而不是给予负面评价。
2.隐式反馈包含大量噪声。比如，电视机在某一时间播放某一节目，然而用户已经睡着了，或者忘了换台。
3.显式反馈表现的是用户的喜好（preference），而隐式反馈表现的是用户的信任（confidence）。比如用户最喜欢的一般是电影，但观看时间最长的却是连续剧。大米购买的比较频繁，量也大，但未必是用户最想吃的食物。
4.隐式反馈非常难以量化。
http://www.jos.org.cn/1000-9825/4478.htm
Spark中ALS的实现原理 Spark利用交换最小二乘解决矩阵分解问题分两种情况：数据集是显式反馈和数据集是隐式反馈。隐式反馈算法的原理是在显示反馈算法原理的基础上作一定的修改，所以在此我们只会具体讲解数据集为隐式反馈的算法。
推荐系统依赖不同类型的输入数据，最方便的是高质量的显式反馈数据，它们包含用户对感兴趣商品明确的评价。例如，大众点评中对餐厅的评价数据，但是显式反馈数据不一定总是找得到。好在推荐系统还可以从更丰富的隐式反馈信息中推测用户的偏好。隐式反馈类型包括购买历史、浏览历史、搜索模式甚至鼠标动作。例如，反复浏览某一个类型理财产品的用户可能喜欢这类理财产品。
了解隐式反馈的特点非常重要，因为这些特质使我们避免了直接调用基于显式反馈的算法。最主要的特点有如下几种：
（1）没有负反馈。通过观察用户行为，我们可以推测那个商品他可能喜欢，然后购买，但是我们很难推测哪个商品用户不喜欢。这在显式反馈算法中并不存在，因为用户明确告诉了我们他喜欢什么他不喜欢什么。
（2）隐式反馈是内在的噪音。虽然我们拼命的追踪用户行为，但是我们仅仅只是猜测他们的偏好和真实动机。例如，我们可能知道一个人的购买行为，但是这并不能完全说明偏好和动机，因为这个商品可能作为礼物被购买而用户并不喜欢它。
（3）显示反馈的数值表示偏好（preference），隐式回馈的数值表示信任（confidence）。
基于显示反馈的系统用星星等级让用户表达他们的喜好程度，例如一颗星表示很不喜欢，五颗星表示非常喜欢。基于隐式反馈的数值描述的是动作的频率，例如用户购买特定商品的次数。一个较大的值并不能表明更多的偏爱。但是这个值是有用的，它描述了在一个特定观察中的信任度。一个发生一次的事件可能对用户偏爱没有用，但是一个周期性事件更可能反映一个用户的选择。
（4）评价隐式反馈推荐系统需要合适的手段。
3.1显式反馈模型
潜在因素模型由一个针对协同过滤的交替方法组成，它以一个更加全面的方式发现潜在特征来解释观察的ratings数据。我们关注的模型由奇异值分解（SVD）推演而来。一个典型的模型将每个用户u（包含一个用户-因素向量ui）和每个商品v（包含一个用户-因素向量vj）联系起来。预测通过内积rij=（uiT）vj来实现。另一个需要关注的地方是参数估计。许多当前的工作都应用到了显式反馈数据集中，这些模型仅仅基于观察到的rating数据直接建模，同时通过一个适当的正则化来避免过拟合。公式如下：
在上述公式中，lambda是正则化的参数。正规化是为了防止过拟合的情况发生。这样，我们用最小化重构误差来解决协同推荐问题。我们也成功将推荐问题转换为了最优化问题。
3.2隐式反馈模型
在显式反馈的基础上，我们需要做一些改动得到我们的隐式反馈模型。首先，我们需要形式化由rij变量衡量的信任度的概念。我们引入了一组二元变量pj，它表示用户u对商品v的偏好。pj的公式如下：
另外，用户购买一个商品也并不一定是用户喜欢它。因此我们需要一个新的信任等级来显示用户偏爱某个商品。一般情况下，rij越大，越能暗示用户喜欢某个商品。因此，我们引入了一组变量Cj，它衡量了我们观察到pj的信任度。C_j一个合理的选择如下所示：
按照这种方式，我们存在最小限度的信任度，并且随着我们观察到的正偏向的证据越来越多，信任度也会越来越大。
我们的目的是找到用户向量以及商品向量vj来表明用户偏好。这些向量分别是用户因素（特征）向量和商品因素（特征）向量。本质上，这些向量将用户和商品映射到一个公用的隐式因素空间，从而使它们可以直接比较。这和用于显式数据集的矩阵分解技术类似，但是包含两点不一样的地方：（1）我们需要考虑不同的信任度。
（2）最优化需要考虑所有可能的u，v对，而不仅仅是和观察数据相关的u，v对。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0737d07fe0d43a7fbe7b5ed88817e0ea/" rel="bookmark">
			java项目中使用 UEditor 百度富文本框编辑器，操作详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 UEditor 最新版
打开 UEditor 官网（官网网址链接，请点击），进入后如下图
，选择下载，进入下载页面，选择jsp最新版本
解压后，将文件放入项目中。
如我解压后，将文件名字改为“ueditor”,放入到我的项目中。 3.添加ueditor的相关 jar包
将下载下来的文件中 ueditor\jsp\lib 下有 5 个jar包，将这5个jar包添加到项目构建路径。
因为我的项目是 springBoot架构，所以我将jar包添加到项目中是通过maven依赖。步骤如下：（1）在resources 根目录下建立 lib 文件夹，将5个jar包拷入 lib 文件夹下。
（2）在pom.xml 文件中添加依赖，图片下面有 添加依赖的代码
&lt;!-- 百度ueditor引入本地jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.yl.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/src/main/resources/lib/json.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.yl.commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/src/main/resources/lib/commons-io-2.4.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.yl.commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/src/main/resources/lib/commons-fileupload-1.3.1.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.yl.commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/src/main/resources/lib/commons-codec-1.9.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.yl.ueditor&lt;/groupId&gt; &lt;artifactId&gt;ueditor&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/src/main/resources/lib/ueditor-1.1.2.jar&lt;/systemPath&gt; &lt;/dependency&gt; 修改后台配置，即修改 config.json 文件
修改 ueditor/jsp/config.json 文件，我这里只修改了读取文件的路径前缀，上传的路径没有修改，用的默认的路径。（注意：修改读取文件路径前缀时，要写全，如 localhost/XX/XX 这样的不行，需要写成：http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0737d07fe0d43a7fbe7b5ed88817e0ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf125f79297828e7967350f47bb37aae/" rel="bookmark">
			ubuntu开机进入initramfs的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ubuntu开机进入initramfs的解决办法 1.事故原因 由于电脑卡死，只能强制重启，之前启动虚拟机的时候发现虚拟机异常退出无法启动。 这里我的虚拟机是用vagrant方式安装的，正常的vagrant up无法启动，也无法显示错误信息。 2.排查解决过程 改用VirtualBox方式直接启动虚拟机，发现界面停留在Initramfs的界面。
尝试：exit+reboot. 发现还是进不去 $ exit $ reboot 根据Initramfs界面提示，查看是哪个磁盘坏了，例如我的是/dev/sda1，使用fsck命令进行自动修复 $ fsck -y /dev/sda1 静静等待，fsck执行完，再reboot，发现可以进去了。 3.最后 定期将vagrant box虚拟机进行打包备份 $ vagrant package --output ubuntu1804_20191118.box 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ff392e189e4d5ee1c53f281f4aade9a/" rel="bookmark">
			【c#】AutoPostBack属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AutoPostBack属性值 Ture 下拉框的 SelectedIndexChanged 事件能触发False 下拉框的 SelectedIndexChanged 事件不能触发
True表示与服务器交互，False表示不与服务器交互。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59b92150d56668c5e2c4f26e9a5b0b1/" rel="bookmark">
			发布码云代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤：
1、码云上新建一个项目 XXXX （项目名） 2、本地创建一个文件夹E:/XXXX，然后使用git bash 3、cd 到本地文件夹中E:/XXXX //如果是在创建的文件中git bash 则此步骤可省略
4、使用 git init 命令 //初始化一个git 本地仓库此时会在本地创建一个 .git 的文件夹
5、使用git remote add origin https://gitee.com/你的码云用户名/XXXX //添加远程仓库
6、使用 git pull origin master 命令，将码云上的仓库pull到本地文件夹
7、将要上传的文件，添加到刚刚创建的文件夹 8、使用git add . （. 表示所有的）或者 git add + 文件名 // 将文件保存到缓存区
9、使用git commit -m '新添加的文件内容描述' //添加文件描述
10、使用git push origin master ，将本地仓库推送到远程仓库
————————————————
版权声明：本文为CSDN博主「tiegenZ」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/tiegenZ/article/details/79551717
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5094243fc6a4d7ab638bb399ea35072/" rel="bookmark">
			iServer GP服务算子扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Neshoir
上一篇，我们介绍了iServer GP服务的使用，用户反馈我们要实现的业务功能在GP服务算子列表里没有提供，怎么办啊？当然有办法，GP服务设计的初衷就是为了让开发人员能够快速简单的实现一个算子以便于重复使用。GP服务提供了实现算子的接口，开发人员只需要集成接口用注解方式即可快速实现业务算子。GP服务兼容了gt-process模块（gt-process是geotools的地理处理组件，可自行补充该技术点）。我们有几种方式来实现算子的扩展，比如1. 基于gt-process的注解实现。2.基于gt-process的静态方法工厂实现。3.基于GP服务模块的AbstractProcess、IProcessFactory等基类实现。以方式1来自定义实现缓冲区功能为例。
一、扩展实现
通过IDE工具或maven创建java应用工程。
引入scala开发环境，缓冲区功能暂且就用bdt的接口实现。
在main包下新建scala文件夹，并将其设置为"Sources Root"源码文件夹，并新建package。 引入bdt组件的jar库。由于我们要实现的业务功能在bdt组件里提供了接口，且bdt组件包已集成了gt-process模块。注意：如果不用bdt组件包，那么需要在pom.xml文件里引入gt-process的依赖。 &lt;!--没有引用bdt库，就需要单独依赖gt-process--&gt; &lt;dependency&gt; &lt;groupId&gt;org.geotools&lt;/groupId&gt; &lt;artifactId&gt;gt-process&lt;/artifactId&gt; &lt;version&gt;${geotools.version}&lt;/version&gt; &lt;/dependency&gt; 创建一个接口类文件，便于于注解工厂扫描该接口的所有实现类。
public interface IBufferProcess { } 基于AnnotatedBeanProcessFactory基类创建一个类文件，用于IBufferProcess接口的注册。
import org.geotools.process.factory.AnnotatedBeanProcessFactory; import org.geotools.text.Text; public class MyAnnotatedBeanProcessFactory extends AnnotatedBeanProcessFactory { static volatile BeanFactoryRegistry&lt;IBufferProcess&gt; registry; public static BeanFactoryRegistry&lt;IBufferProcess&gt; getRegistry() { try { if (registry == null) { synchronized (MyAnnotatedBeanProcessFactory.class) { if (registry == null) { registry = new BeanFactoryRegistry&lt;IBufferProcess&gt;(IBufferProcess.class); } } } } catch (Exception ex) { ex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5094243fc6a4d7ab638bb399ea35072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df753877f2650e3bfe9299b78cf6e750/" rel="bookmark">
			C&#43;&#43;11 random库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++ 中的随机数 在 C++ 程序中，在新标准出现之前，C 和 C++ 都依赖一个简单的 C 库函数 rand 来生成随机数，但是，这个函数生成的是均匀分布的伪随机数，每个随机数的范围在 0 和一个系统相关的最大值（至少为 32767）之间。
rand 函数有一些问题：即使不是大多数，也有很多程序需要不通范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的随机数。而在编写程序为了解决这些通常会转换 rand 生成的随机数的范围、类型或者是分布时，常常会引入非随机性。
在 C++ 11 标准中，定义在头文件 random 中的随机数库通过一组协作的类来解决这些问题，主要用到的是两个类：
随机数引擎类（random-number engines）、随机数分布类（random-number distribution)。
其中，一个引擎类可以生成 unsigned 随机数列，一个分布使用一个引擎类生成指定类型的，在给定范围内的，服从指定概率分布的随机数。
随机数引擎和分布 随机数引擎是函数对象类，他们定义了一个调用运算符，该运算符不接受参数并返回一个随机的 unsigned 整数。我们可以通过调用一个随机数引擎对象来生成原始随机数。
default_random_engine e; // 生成随机无符号数 for(size_t i=0; i&lt;10; i++) // e() “调用”对象来生成下一个随机数 cout &lt;&lt; e() &lt;&lt;endl; 在上面这几行的代码中，定义了一个名为 e 的 default_random_engine 的对象。在 for 循环内，我们调用对象 e 来获得下一个随机数。
分布类型和引擎 为了得到一个在指定范围内的数，我们一用一个分布类型的对象：
//生成 0 到 9 之间（包含）均匀分布的随机数 uniform_int_distribution&lt;unsigned&gt; u(0,9); default_random_engine e; // 生成无符号随机整数 for (size_t i =0;i&lt;10; i++) // 将 u 作为随机数源 // 每个调用返回在指定范围内并服从均匀分布的值 cout&lt;&lt;u(e)&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df753877f2650e3bfe9299b78cf6e750/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a6f1ef9f437e890a84d4369087c3050/" rel="bookmark">
			模n加法——元素阶的终极规律
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Z6={0,1,2,3,4,5}，模 6 加法的构成的群中，群的阶=？， 元素 5 的阶 |5 |＝？ 。 我们知道，群的阶等于元素个数6，
我们看&lt;Z6，+&gt;中的元素{0,1,2,3,4,5}。取其中的元素1，不停地对自身进行模6加法，即对本身进行幂运算。
可得：
5=5
5+5=10
5+5+5=15
5+5+5+5=20
5+5+5+5+5=25
5+5+5+5+5+5=30
故|5|=6
考虑大数字不好计算，让我们通过编程找规律。
/* 模n加法，群的阶=n，元素的阶=最少几次方（几次相加）=本身。 下面来求元素的阶 */ #include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int as(int a) { int i, j = 0; for (i = 2; i &lt; a; i++) if (a % i == 0) { j = 1; break; } return j; } int main() { int x, y, i; int a = 15, b = 4;//a为元素个数和模a加法中的a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a6f1ef9f437e890a84d4369087c3050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4346ab708591ae3db952d17439a03a82/" rel="bookmark">
			node 终端输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、let readline=require('readline') 2、初始化进程对象 let rl=readline.createInterface({ input:process.stdin, output:process.stdout }) 3、rl.question事件接收键盘输入 rl.question('屏幕显示内容',function(res输入内容){xxx}) 4、关闭question事件 rl.close(); 5、监听关闭事件,结束输出输出进程 rl.on('close',function(){ process.exit(0)}) 代码示例:
键盘输入内容并存到文件里:
let fs =require('fs'); let readline=require('readline'); //实例化接口对象 let rl=readline.createInterface({ input:process.stdin, output:process.stdout }) //question提问事件 rl.question('名字?\n',function(ans){ console.log(ans); //不使用close关闭,question事件不会结束 res=ans; rl.close(); }) async function ques(){ return new Promise(function(resolve,reject){ //question提问事件 rl.question('名字?\n',function(ans){ resolve(ans); }) }) } async function create(){ let res=await ques() fs.writeFile("C:/Users/10853/Desktop/tt.txt",res,function(err){ console.log('已保存'); rl.close(); }) } create(); //close事件监听 rl.on('close',function(){ //结束readline进程 process.exit(0); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc6a590ae2019b490bb2ff73aca24432/" rel="bookmark">
			QT 实现在QLabel上画图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT之所以不能再任意控件上绘图是因为QT的事件过滤器把控件的绘图事件给过滤了。
在paintevent()函数中，通常需要设置QPainter对象，创建QPainter对象的同时需要指定绘图设备，即继承自QPainterDevice的子类作为绘图设备，绘制出来的图形将在这个设备上进行显示，Qt一共提供了4个这样的类，分别是QPixmap，QBitmap，QImage，和QPicture。
在控件上绘图又应该怎么办呢，我这以QLabel为例：使用事件过滤器来使QLabel对象捕获QEvent::Paint事件。即，绘图函数不需要放在paintevent（）函数中也可以实现绘图。 实现这个功能的主要函数就还是事件过滤器的两个重要函数，即installEventFilter（）和eventFileter（)#include “widget.h”
#include "ui_widget.h" Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget) { ui-&gt;setupUi(this); ui-&gt;label-&gt;installEventFilter(this); //这行不能省 } Widget::~Widget() { delete ui; } bool Widget::eventFilter(QObject *watched, QEvent *event) //用过滤器eventFilter（）拦截QLabel中的QEvent::Paint事件 { if(watched ==ui-&gt;label &amp;&amp; event-&gt;type() == QEvent::Paint) paint(); return QWidget::eventFilter(watched,event); } void Widget::paint() //绘图 { QPainter painter(ui-&gt;label); painter.setPen(Qt::blue); // painter.drawLine(100,100,200,200); painter.drawEllipse(30,15,50,65); painter.drawLine(0,100,111,100); } 我在ui里添加了QLabel控件命名label，并且用样式表将label的背景变成黑色方便观察，下面是效果图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d97c58de58620260a27232ae99598af/" rel="bookmark">
			tf.shape和tf.get_shape的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从名字来看，这2个接口都是可以获取tensor的shape的，但有明显的区别，具体为：
1. tf.shape返回的是tensor，而tf.get_shape返回的是一个元组，所以前者想要获取tensor具体的shape结果需要sess.run才行；
2. 对tf.placeholder占位符来说，如果shape设置的其中某一个是None，那么对于tf.shape，sess.run会报错，而tf.get_shape不会，它会在None位置显示“?”表示此位置的shape暂时未知。
a = tf.Variable(tf.constant(1.5, dtype=tf.float32, shape=[1,2,3,4,5,6,7]), name='a') b = tf.placeholder(dtype=tf.int32, shape=[None, 3], name='b') s1 = tf.shape(a) s2 = a.get_shape() print (s1) # Tensor("Shape:0", shape=(7,), dtype=int32) print (s2) # 元组 (1, 2, 3, 4, 5, 6, 7) s11 = tf.shape(b) s21 = b.get_shape() print (s11) # Tensor("Shape_1:0", shape=(2,), dtype=int32) print (s21) # 因为第一位设置的是None，所以这里的第一位显示问号表示暂时不确认 (?, 3) with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print (sess.run(s1)) # [1 2 3 4 5 6 7] print (sess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d97c58de58620260a27232ae99598af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f064e4cd1f0e666d4b2356e802c1374/" rel="bookmark">
			SpringBoot&#43;Mybatis&#43;MybatisPlus 入门整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis-Plus + 代码生成器整合使用个人开发环境java环境：Jdk1.8.0_60编译器：IntelliJ IDEA 2017.1.4Mybatis-Plus 版本：3.xfreemarker模板 版本：2.3.28 （用于mp代码生成器的模板引擎，可根据个人喜好更换模板）官方文档：https://mp.baomidou.com/guide/源码连接：待整理第一步 添加依赖官方提示：引入 MyBatis-Plus 之后请不要再次引入 MyBatis 以及 MyBatis-Spring，以避免因版本差异导致的问题。
org.springframework.boot spring-boot-starter-parent 2.1.3.RELEASE org.springframework.boot spring-boot-starter-web &lt;!--mybatis-plus 相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;${mybatis-plus.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis-plus代码生成器 相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;${mybatis-plus-generator.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--代码生成器使用freemarker模板引擎 相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;${freemarker.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动 相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql-connector.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--pojo实用小插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;!--依赖不传递--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; copy第二步 配置文件application.yml（src/main/resources/application.yml）server:
服务端口 port: 8084
spring:
datasource:
url: jdbc:mysql://localhost:3306/springboot-mybatis
username: root
password: 123456
driver-class-name: com.mysql.jdbc.Driver
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f064e4cd1f0e666d4b2356e802c1374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea78e84284fd6d5084562a99ffaaf60a/" rel="bookmark">
			机器学习笔记(二)——KNN算法之手写数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法简介 手写数字识别是KNN算法一个特别经典的实例，其数据源获取方式有两种，一种是来自MNIST数据集，另一种是从UCI欧文大学机器学习存储库中下载，本文基于后者讲解该例。
基本思想就是利用KNN算法推断出如下图一个32x32的二进制矩阵代表的数字是处于0-9之间哪一个数字。
数据集包括两部分，一部分是训练数据集，共有1934个数据；另一部分是测试数据集，共有946个数据。所有数据命名格式都是统一的，例如数字5的第56个样本——5_56.txt，这样做为了方便提取出样本的真实标签。
数据的格式也有两种，一种是像上图一样由0、1组成的文本文件；另一种则是手写数字图片，需要对图片做一些处理，转化成像上图一样的格式，下文皆有介绍。
算法步骤 收集数据：公开数据源分析数据，构思如何处理数据导入训练数据，转化为结构化的数据格式计算距离（欧式距离）导入测试数据，计算模型准确率手写数字，实际应用模型 由于所有数据皆由0和1构成，所以不需要数据标准化和归一化这一步骤
算法实现 处理数据 在计算两个样本之间的距离时，每一个属性是一一对应的，所以这里将32x32的数字矩阵转化成1x1024数字矩阵，方便计算样本之间距离。
#处理文本文件 def img_deal(file): #创建一个1*1024的一维零矩阵 the_matrix = np.zeros((1,1024)) fb = open(file) for i in range(32): #逐行读取 lineStr = fb.readline() for j in range(32): #将32*32=1024个元素赋值给一维零矩阵 the_matrix[0,32*i+j] = int(lineStr[j]) return the_matrix 计算欧式距离 numpy有一个tile方法，可以将一个一维矩阵横向复制若干次，纵向复制若干次，所以将一个测试数据经过tile方法处理后再减去训练数据，得到新矩阵后，再将该矩阵中每一条数据(横向)平方加和并开根号后即可得到测试数据与每一条训练数据之间的距离。
下一步将所有距离升序排列，取到前K个，并在这个范围里，每个数字类别的个数，并返回出现次数较多那个数字类别的标签。
def classify(test_data,train_data,label,k): Size = train_data.shape[0] #将测试数据每一行复制Size次减去训练数据，横向复制Size次，纵向复制1次 the_matrix = np.tile(test_data,(Size,1)) - train_data #将相减得到的结果平方 sq_the_matrix = the_matrix ** 2 #平方加和，axis = 1 代表横向 all_the_matrix = sq_the_matrix.sum(axis = 1) #结果开根号得到最终距离 distance = all_the_matrix ** 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea78e84284fd6d5084562a99ffaaf60a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349f269ad72664efea8b8fd720b41d6a/" rel="bookmark">
			java压缩zip文件,内中文文件名乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前使用java.util.zipoutputstream发现压缩文件内中文文件名出现乱码，尝试使用URLEncoder.encode(fileName, "UTF-8")/URLEncoder.encode(fileName, "GBK")均无效。后来从网友will_443238794博客https://blog.csdn.net/will_443238794/article/details/78957504处得知新知识点，原来java.util.zipoutputstream无法设置字符集，建议使用org.apache.tools.zip.ZipOutputStream
但我的实际需求是zip中有多个文件,故略微改造...
public void downloadBatchByFile(HttpServletResponse response, Map&lt;String, byte[]&gt; files, String zipName){
try{
response.reset();
//zipName = URLEncoder.encode(zipName, "ISO8859_1");
response.setContentType("application/vnd.ms-excel;charset=UTF-8");
response.setHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(zipName, "UTF-8") + ".zip");
ZipOutputStream zos = new ZipOutputStream(response.getOutputStream());
BufferedOutputStream bos = new BufferedOutputStream(zos);
zos.setEncoding("gbk");//设置中文编码
for(Map.Entry&lt;String, byte[]&gt; entry : files.entrySet()){
String fileName = zipName+"-"+entry.getKey();//每个zip文件名
byte[] file = entry.getValue();//这个zip文件的字节
BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(file));
zos.putNextEntry(new ZipEntry(fileName+".xml"));
int len = 0;
byte[] buf = new byte[10 * 1024];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349f269ad72664efea8b8fd720b41d6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae9a4c1365c51cfc371edd503fb9be90/" rel="bookmark">
			深度学习环境搭建(linux、keras、tensorflow、GPU)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习环境搭建(linux、keras、tensorflow、GPU) Keras的安装有很多方法，可以通过pip 安装或通过conda安装，个人建议使用conda安装，因为conda可以将安装库依赖的其他库也自动安装了。整个学习环境搭建如下：
一、 安装conda 1、 下载anaconda版本，并进行安装
wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.3.1-Linux-x86_64.sh
2、 开始安装conda
sh Anaconda3-5.3.1-Linux-x86_64.sh
注意： 安装过程中会让你进行一些选择，为了避免后面的配置麻烦，建议你全部选择yes。 同时注意，安装过程中，会显示安装的目录，请记录下该目录，后面配置环境变量需要使用。 3、 配置环境变量
安装后，需要将conda的安装路径配置到PATH环境变量。 如果你在第二步没有记录该路径，可以执行conda info 来查看。比如下图，base enviroment路径为/root/miniconda3. 将该路径下的bin路径配置到PATH环境变量里。
修改/etc/profile文件，添加这行： export PATH=$PATH:/root/miniconda3/bin 并运行source /etc/profile使其生效。
注意： 添加环境变量时建议将conda的目录放到PATH之后， 这样不会影响以前的一些环境。
如果不记得安装时的路径，可以执行conda info命令查看。
二、 安装keras、tensorflow 注意： keras和tensorflow有不同的版本，每个版本又有GPU和CPU版本， 不同的tensflow的GPU版本对cuda的版本要求又不一样。以及对python的版本也有要求。所以建议你安装前先查清楚才安装。 说明：我当前的GPU的cuda版本是10.0， 所以我安装了tensorflow-gpu的1.15.0版本。 tensorflow的1.15.0版本配套的keras版本是2.16， 依赖的python版本是3.6.0. 查看版本配套关系可以登录网址： [添加链接描述](https://docs.floydhub.com/guides/environments/) 1、 创建自己的环境
conda create -n tensorflow python=3.6.3
创建一个环境，将其命名为tensorflow,并安装python3.6.3版本
2、 切换到自己的环境
source activate tensorflow
3、 安装gpu版本的tensorflow
conda install tensorflow-gpu=1.15.0
4、 安装gpu版本的keras
conda install keras-gpu=2.1.6
5、 检查安装的keras和tensorflow
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae9a4c1365c51cfc371edd503fb9be90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9426151e2d07dd2e3e61b6db29f99040/" rel="bookmark">
			java多文件打包下载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
* 根据文件，进行压缩，批量下载
* @param response
* @param files 文件转换成的byte字节流
* @throws Exception */
public void downloadBatchByFile(HttpServletResponse response, Map&lt;String, byte[]&gt; files, String zipName){
try{
response.reset();
zipName = java.net.URLEncoder.encode(zipName, "UTF-8");
response.setContentType("application/vnd.ms-excel;charset=UTF-8");
response.setHeader("Content-Disposition", "attachment;filename=" + zipName + ".zip");
ZipOutputStream zos = new ZipOutputStream(response.getOutputStream());
BufferedOutputStream bos = new BufferedOutputStream(zos);
for(Entry&lt;String, byte[]&gt; entry : files.entrySet()){
String fileName = entry.getKey(); //每个zip文件名
byte[] file = entry.getValue(); //这个zip文件的字节
BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(file));
zos.putNextEntry(new ZipEntry(fileName));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9426151e2d07dd2e3e61b6db29f99040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/902cdc0550ff8b2f6f976e3712f998df/" rel="bookmark">
			JAVA计算平方，幂运算，三角函数等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA中要想计算一个数值的平方根， 可以使用 sqrt 方法：
double x = 4;
double y = Math.sqrt(x);
System.out.println(y);
在 Java 中，没有幂运算， 因此需要借助于 Math 类的 pow 方法。语句：
double y = Math.pow(x, a);
将 y 的值设置为 x 的 a 次幂 。 pow 方法有两个 double 类型的参数， 其返回结果也为double 类型
Math 类提供了一些常用的三角函数：
Math,sin
Math.cos
Math.tan
Math.atan
Math.atan2
还有指数函数以及它的反函数—自然对数以及以 10 为底的对数：
Math.exp
Math.log
Math.loglO
最后， Java 还提供了两个用于表示 Π 和 e 常量的近似值：
Math.PI
Math.E
注意
不必在数学方法名和常量名前添加前缀“ Math”， 只要在源文件的顶部加上下面
这行代码就可以了。
import static java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/902cdc0550ff8b2f6f976e3712f998df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f29468b7d8a87889d6fbb4ca2d26832/" rel="bookmark">
			鸡兔同笼问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 有若干只鸡兔同在一个笼子里，从上面数，有a=35个头，从下面数，有b=94只脚。问笼中各有多少只鸡和兔？ 正常情况
解题方法
设鸡有x只，兔有y只。
列方程
x+y=a
2x+4y=b
解方程得
y=0.5b-a
x=a-y
代码
#include&lt;iostream&gt; using namespace std; int main() { int a,b,x,y; cout &lt;&lt; "鸡兔头总量"; cin &gt;&gt; a; cout &lt;&lt; "鸡兔脚总数"; cin &gt;&gt; b; y = 0.5*b-a; x = a - y; cout &lt;&lt; "兔有 " &lt;&lt; x &lt;&lt;"只"&lt;&lt; endl; cout &lt;&lt; "鸡有 " &lt;&lt; y &lt;&lt;"只"&lt;&lt; endl; return 0; } 让我们运行一下
转折点 万一笼子里是其它动物呢？它们的脚数不确定，不妨一个动物1，一个动物2，“两动物同笼”。
解题方法
设动物1有m个脚，动物2有n个脚。已知共a=35个头，b=94只脚，则动物1有x只，动物2有y只。
列方程如下
x+y=a
mx+ny=b
解方程可得
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f29468b7d8a87889d6fbb4ca2d26832/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3eb731c99d595b2b4bdaf30ad85607f/" rel="bookmark">
			openssl实现双向认证教程（服务端代码&#43;客户端代码&#43;证书生成）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景说明 1.1 面临问题 最近一份产品检测报告建议使用基于pki的认证方式，由于产品已实现https，商量之下认为其意思是使用双向认证以处理中间人形式攻击。
《信息安全工程》中接触过双向认证，但有两个问题。
第一个是当时最终的课程设计客户端是浏览器，服务端是tomcat双向认证只需要对两者进行配置并不需要自己真的实现代码。
第二个是虽然课程也有接近双向认证的实现代码，但当时是Java+JCE环境现在要用C+++OpenSSL环境，总体意思确实还是差不多但具体函数和参数差别还是不少。
所以眼下有的是：证书生成的思想+双向认证实现的思想。对读者而言，即要假定已对证书、SSL/TSL、socket编程等几个概念有基本的了解，本文不做详细介绍。
基于此本文要解决的问题是：openssl具体如何生成证书+openssl如何实现双向认证。
1.2 解决办法 1.2.1 openssl具体生成证书解决办法
参考https://blog.csdn.net/gengxiaoming7/article/details/78505107再加其他一些文章总结而成
1.2.2 openssl实现双向认证解决办法
使用https://blog.csdn.net/sardden/article/details/42705897代码实SSL，在其基础上实现双向认证。
双向认证的关键点在以下几个函数（服务端和客户端都一样），其他就不细说参看代码注释：
SSL_CTX_set_verify----配置启用双向认证
SSL_CTX_load_verify_locations----加载信任的根证书
SSL_CTX_use_certificate_file----加载自己的证书
SSL_CTX_use_PrivateKey_file----加载自己的私钥
SSL_get_verify_result----真正进行验证，一定要调用这个函数不然前面四个光配置而已并不会进行双向验证
二、双向认证程序实现 2.1 安装openssl及开发api apt-get install libssl-dev 2.2 服务端代码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;netinet/in.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;openssl/ssl.h&gt; #include &lt;openssl/err.h&gt; #define MAXBUF 1024 void ShowCerts(SSL * ssl) { X509 *cert; char *line; cert = SSL_get_peer_certificate(ssl); // SSL_get_verify_result()是重点，SSL_CTX_set_verify()只是配置启不启用并没有执行认证，调用该函数才会真证进行证书认证 // 如果验证不通过，那么程序抛出异常中止连接 if(SSL_get_verify_result(ssl) == X509_V_OK){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3eb731c99d595b2b4bdaf30ad85607f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c41c25374d5867ab28d2f97ebf09a13/" rel="bookmark">
			PostgreSQL创建触发器，实现自动更新时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：在student里面有一个字段update_time，当该条记录发生变化的时候，该字段要发生相应的变化
1、student结构如下：
drop table if exists student; create table student( id int primary key not null, name char(10) not null, address char(50), create_time timestamp default current_timestamp, update_time timestamp default current_timestamp ); 插入数据的时候，就自动生成create_time和update_time
2、先插入几条数据
insert into student(id,name,address) values(1,'小明','广州'); insert into student(id,name,address) values(2,'小红','广西'); insert into student(id,name,address) values(3,'小甜甜','湖北'); 3、读取数据在表里面的情况：
select * from student; 4、创建函数，用于更新update_time
create or replace function update_timestamp() returns trigger as $$ begin new.update_time = current_timestamp; return new; end $$ language plpgsql; 函数有两个值new和old，我们可以从old获得待处理的那条记录的信息，而new则是要新生成的那条记录，下面的触发器是设置为before，表示在那条记录发生前，这个触发器会先触发，从而执行该函数，这个函数的目的就是获得当前的时间戳，赋值到还没执行的SQL里面，相当于原先的SQL是这样的（假设更新了name字段）update 表 set name = xx where id = xx，经过触发器先处理后变成这样update 表 set name = xx ,update_time = 当前的时间戳 where id = xx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c41c25374d5867ab28d2f97ebf09a13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be0c3dfa3bca5553e204fefa77ceeae/" rel="bookmark">
			项目部署到云服务器上时 “ignoring input and redirecting stderr to stdout”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目部署到云服务器时出现错误 修改一下命令即可解决
将上面的命令修改为：
nohup java -jar dwz-0.0.1-SNAPSHOT.jar &gt;log/lts.txt 2&gt;&amp;1 &amp; 总结：
nohup (no hang up)当账户退出或终端关闭时,程序仍然运行。&amp;：指如果客户端关闭，程序就会停止运行。&gt;log/lts.txt:指程序运行生成日志文件的存储位置，如果不指定，默认该项目所有输出被重定向到nohup.out的文件中。dev/null 表示空设备文件0 表示stdin标准输入1 表示stdout标准输出2 表示stderr标准错误2&gt;&amp;1 就是表示将错误重定向输出到标准输出上。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f936e178e22e77f825837c39401981f/" rel="bookmark">
			PHP的php://
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php:// — 访问各个输入/输出流（I/O streams）
php://stdin标准输入流
php://stdout标准输出
php://stderr错误描述符
php://input访问请求的原始数据的只读流
php://output是一个只写的数据流
php://fd允许直接访问指定的文件描述符。 例如 php://fd/3 引用了文件描述符 3
php://memory是一个类似文件 包装器的数据流，允许读写临时数据。 两者的唯一区别是 php://memory 总是把数据储存在内存中
php://temp是一个类似文件 包装器的数据流，允许读写临时数据。 两者的唯一区别是 php://memory 总是把数据储存在内存中
php://filter 设计用于数据流打开时的筛选过滤应用
https://www.php.net/manual/zh/wrappers.php.php
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/249/">«</a>
	<span class="pagination__item pagination__item--current">250/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/251/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>