<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc26d8e18f5b0bf5e7baffab75f16e5/" rel="bookmark">
			一个易用的消息订阅发布系统-Pubsub.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文作者系360奇舞团前端开发工程师
简介 随着软件架构越来越复杂，如何有效地解决各个模块之间的通信问题变得尤为重要。一种常见的解决方案就是采用消息订阅发布机制。在这种模式下，每个模块只需要关注自己要发送或接收的消息，而不必关心其他模块的内部实现。
今天要介绍的 pubsub.js 就是一个非常实用的消息订阅发布库。它具有使用简单、性能高效、支持多平台等优点，可以很好地满足各种需求。
基本使用 首先，让我们来看看如何使用 pubsub.js 进行消息的发送与接收。首先，我们需要引入库：
import PubSub from "pubsub-js"; 然后，在需要发送消息的地方，我们可以使用 publish 方法：
// 发布一个名为 'testEvent' 的事件，并带上数据 let data = { name: 'John Doe' }; PubSub.publish('testEvent', data); 而在需要接收消息的地方，我们需要先使用 subscribe 方法进行订阅：
// 订阅名为 'testEvent' 的事件 let subscription = PubSub.subscribe('testEvent', function(message, data) { console.log("Received data:", data.name); }); // 当不再需要接收消息时，记得取消订阅 PubSub.unsubscribe(subscription); 以上就是一个简单的消息订阅发布流程。
一些使用场景 比如：状态。
// 可以外部变更组件内状态 pubsub.publish(STATE_UPDATED_EVENT, newState); // 在其他组件中订阅该事件以获得新状态 pubsub.subscribe(STATE_UPDATED_EVENT, (newState) =&gt; { this.setState(newState); }); 事务处理。
// 当异步操作完成时发布事件 function subscribeTransaction() { var subscription = PubSub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bc26d8e18f5b0bf5e7baffab75f16e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998f3a69469e23bb1969a4f229238769/" rel="bookmark">
			使用IDEA创建Vue3通过Vite实现工程化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节介绍控件。有关如何创建项目的分步说明，请参阅 Vite。 名字
指定项目的名称。
位置
指定要在其中创建项目的目录的路径。默认情况下，IDE 会创建一个与项目同名的目录。
节点解释器
指定要在此项目中使用的 Node.js 解释器。您可以从列表中选择已配置的解释器，或单击“添加”以配置新的解释器。
如果计算机上没有 Node.js，请从列表中选择下载 Node.js。
维特
从 Vite 列表中选择 npx create-vite。
或者，对于 npm 版本 5.1 及更早版本，通过在终端中运行自行安装包create-vitenpm install --g create-vite AltF12.创建应用程序时，请选择存储包的文件夹。create-vite
模板
选择社区维护的 Vite 模板，该模板以您将在应用程序中使用的框架为目标。
最终 维特最后修改日期：11 年 2023 月 &lt;&gt; 日 仅在 IntelliJ IDEA Ultimate 中可用：下载以试用或比较版本
所需插件：
JavaScript and TypeScript， - 插件仅在 IntelliJ IDEA Ultimate 中可用，默认情况下它们处于启用状态。Vite
IntelliJ IDEA 集成了 Vite 构建工具，可改善前端开发体验。Vite 由一个开发服务器和一个构建命令组成。生成服务器通过本机 ES 模块提供源文件。build 命令将您的代码与 Rollup 捆绑在一起，Rollup 已预先配置为输出高度优化的静态资产以用于生产。
IntelliJ IDEA 支持 Vue 标签中的 tsconfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/998f3a69469e23bb1969a4f229238769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60607a66f626befe5b745889eaac2ba8/" rel="bookmark">
			Error: The IP address owner cannot perform the track function.VRRP track 提示不能配置该功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		告警信息 监控路由：
[Huawei-Vlanif10]vrrp vrid 10 track ip route 192.168.10.251 24
Error: The IP address owner cannot perform the track function.
监控接口：
[Huawei-Vlanif10]vrrp vrid 10 track interface Vlanif 10
Error: The IP address owner cannot perform the track function.
根因 配置此功能的VRRP备份组中不能含有IP地址拥有者，否则无法配置成功。
注：IP地址拥有者（IP Address Owner）：如果一个VRRP路由器将虚拟路由器的IP地址作为真实的接口地址，则该设备是IP地址拥有者。
解决方案 修改VRRP的实地址和虚地址为不同的IP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7560020e99e2e37e1c6d63d5ce84bd8f/" rel="bookmark">
			C#解决在同一项目中使用不同版本动态库的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录和分享一下在C#开发项目过程中遇到的同一项目中使用不同版本动态库的问题，接下来分享全过程。
报错 错误 CS1705 标识为“XXX, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null”的程序集“XXX”所使用的“System.Windows.Interactivity, Version=4.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35”版本高于所引用的标识为“System.Windows.Interactivity, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35”的程序集“System.Windows.Interactivity”
原因 版本依赖引起，在同一项目中使用了某个动态库的不同版本，但未设置特定版本，则VS会默认引用同一位置的动态库。
具体到我自己遇到的情况是：在同一项目中，引用处引用了一个动态库A，在另外位置设置了文件输出同名动态库A（不同版本），重新添加引用不同位置的动态库A无效仍旧指向的是同一位置（必须同时设置【特定版本】为True才有效）。
解决方法 删除这个动态库的不同版本引用和输出，然后重新引用，引用时，在动态库属性中设置【特定版本】为True，如下图示例。需要输出的文件也重新包含在项目中并设置【复制到输出目录】选项。
大结局 保存以上操作，重新生成，大功告成！程序猿最喜欢看到的全部生成成功结果！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/230885ce28e71728bc570ab70ec2d8f9/" rel="bookmark">
			【案例卡】clickhouse：多行数据拼接在一行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求 针对clickhouse数据库中，group by 分组后的字符串字段，拼接处理在一行的问题实现。在mysql中，可以用group_concat()函数来实现，而clickhouse数据库不支持此函数，特此记录实现方式。
二、clickhouse相关函数介绍 1.groupArray:聚合为数组 groupArray 是 ClickHouse 提供的一种聚合函数，用于在 GROUP BY查询中将行组的某个列的值组合成一个数组。groupArray 函数在分析数据时非常有用，它可以将行组中的数据合并成数组形式，方便后续的处理和分析。
2.arrayStringConcat:将数组中的字符串元素连接成一个字符串 arrayStringConcat 函数的语法如下：
arrayStringConcat(arr, separator) 其中：
arr：要连接的数组。
separator：连接数组元素的分隔符字符串。
三、案例 以下列数据为例，我们要汇总统一年份，有哪些月份上报了数据，并且存储在一行中，就可以用上述函数来实现。
单纯使用groupArray()样例：
上述两个函数结合实现结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31edf99d76de7e6305fca025b4ee7895/" rel="bookmark">
			算法统治者，打破传统方式，GitHub爆火的Leetcode刷题指南来袭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近一个读者和我反馈，他坚持刷题2个月，终于去了他梦寐以求的大厂，薪资涨幅非常可观，期间面字节跳动还遇到了原题！并表示目前国内的大厂和一些独角兽，已经全部效仿硅谷公司的做法，通过面试给定题编程，来考察数据结构和算法的扎实程度
这种方式，即使对于工作多年的开发人员，没有经过训练，很容易就挂了。从而与优秀的公司失之交臂。我认识不少以前履历普通的，通过刷题改变自己进入大厂的轨迹，从而走向更高的平台，刷题确实太重要了。
因为据我所知很多大厂技术面试的要求是：技术要好，计算机基础扎实，熟练掌握算法和数据结构，语言不重要，熟练度很重要。每一轮技术面试都可能考代码，不只考算法，但一定会考算法。
所以说算法是其中必要的一个环节！在面试中业务问题可以好好总结总结，但算法就必须依靠牢固的基础和刷题量。算法根基不扎实，不仅难过面试，对于代码性能的提升、编程语言的驾驭也会比别人弱很多。因此，现在算法基础不牢固的同学，都很难通过大厂的面试。但是只靠刷题去提升算法能力，进度太慢，而且还容易抓不住重点。
不光是算法岗位，现在的互联网公司面试，只要是写代码的岗位，都会来一套算法题组合拳伺候。所以大家在准备校招、社招，或者闲暇的时候，都可以刷刷 Leetcode，保持良好的手感。
之前刷题，一直觉得漫无目的地刷，效率很低。后来小编自己整理了一份LeetCode刷题全解，这份资料从2019年3月开始，目前为止已经耗时一年多，页码已达到1121页（还在持续更新）。小编将自己刷leetcode题的总结都更新在了这里面，绝对性的优势碾压市面上的那些算法文章（免费领取方式小编放在文末啦）！
秋招已经结束了，紧接着就是明年的春招，时间过得很快的。推荐一波，祝各位小伙伴都能斩获满意的 Offer。
先简单介绍下这份刷题笔记！
算法专题 这⼀章就把第一年已经刷完了的专题都整理⼀遍。有相似套路的题⽬都放在⼀起，如果想快速⾯试的话，其实相同的题⽬刷 2，3 道就可以了。相同类型的题⽬⾮常熟练的情况下，再多刷⼏道也是做⽆⽤功。
算法的一些实用的模板 线段树 Segment Tree并查集 UnionFind LeetCode题解 这些题小编都已经 runtime beats 100% 了。但还会继续优化，从解题思路到代码实现
目录展示（涵盖了小编一年多近千道的刷题经验总结） 阿里巴巴内部算法学习指南
1.算法思想
排序贪心DP/动态规划剪枝尺取法 2.数据结构
图搜索树线型 3.大厂算法真题
写在最后的话 使用LeetCode的目的不是硬记题目，而是学习不同的解题思路。如果每道题⾃⼰都能优化到 100% 了，那么⼀段时间以后进步会很⼤。所以总的来说，实在没思路，看解题思路；实在优化不到 100%，看看代码。有了这份文档的话，对于那些想要通过LeetCode提高算法能力的编程爱好者是一个莫大的福音。
如果是学习算法、数据结构、或者是刷题找工作的小伙伴，一定不要错过啦！
文档小编已经全部整理好了！有需要的小伙伴，可以点击文末下方传送门，即可获得免费领取方式！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3527f95bdcf6ed6bdd16289b77470db/" rel="bookmark">
			CLion 总是提示 “This file does not belong to any project target xxx” 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CLion 总是提示 “此文件不属于任何项目目标，代码洞察功能可能无法正常工作”.
解决办法：
ros2功能包编译时候使用下面这命令编译就好了
colcon build --cmake-args -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa50c66691d17eb1dbf2539711f59c58/" rel="bookmark">
			如何在Windows上搭建私有化远程仓库之Gitlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景2.实现步骤 2.1 安装Docker2.2 安装Gitlab并部署2.3 通过Web启动GitLab2.4 修改GitLab密码 1.背景 先说背景，电脑由于没有Linux系统，是Win10系统，但是团队要求部署在自己服务器的远程仓库，这因为代码有保护要求，在比人服务器总归是不安全。这里就有几个选择，首先是Github，由于科学上网要求，传文件太慢；然后是Gitee，国内服务器，但是允许的协作开发人员数量有限制，没记错应该是5位，私有免费库好像也有大小限制；
最终推荐3个方案，根据需要自取：
①VisualSVN方案：使用SVN，古老的软件，大大的作用，但是考虑到我这边是代码居多，而不是美术资源，因此没有使用，但是部署起来也很简单，在我另一篇博客专门出教程；
②BonoboGtiServer方案：选择BonoboGitServer这个是不错的，能够很轻松在Windows上部署，美中不足的自然是功能较少（但是也是优势不需要大的内存去运行，基本的功能都有，小团队足够），在我另一篇博客专门出教程；
③GitLab方案：是现在绝大多数软件公司团队在自己服务器实现私控的方式，选择GitLab，唯一比较麻烦的就是在Win上如何部署，但是在我看来也是小儿科。。的医生——头大0.0。
这里介绍第三种方案，中间有不少坑，按照我的一步步来保证没问题。网址:yii666.com
2.实现步骤 2.1 安装Docker Docker是什么我不做介绍了，暂且可以理解为一个软件引擎，避免去安装虚拟系统,到时候让Gitlab运行在Docker容器上即可。安装前先看自己是win10什么版本，家庭版的要做特殊处理，先不做介绍，这里是专业版64位。
①安装docker，首先下载docker然后需要确定电脑是否开了虚拟配置,这个应该是Win10家庭版没有（不确定，据说是）。在控制面板-程序-启用或关闭Windows功能-勾选Hyper-V，点击确定让它自动配置一会。
去Docker官网下载DockerWindows，下面给出网址，这个Docker的安装非常简单，一路next下去就行了，安装路径自己改。
Docker下载网址：
https://docs.docker.com/desktop/install/windows-install/
②安装完成后在程序里找到DockerDesktop运行，任务栏右下角会出现一个鲸鱼的图标
然后会弹框提示需要安装一个wsl.msl，并且在弹框中人家给出了网址，直接去它给出的网址下载安装下面这个就好了，也非常快。
下载后时这样的，直接双击运行，这个东西呢其实也是Linux内核，我不多讲了，免得头大（其实是不专业）
2.2 安装Gitlab并部署 在确保DockerDesktop运行的情况下，打开cmd运行框，输入
docker search gitlab/gitlab-ce docker pull gitlab/gitlab-ce 去自己的想安装的位置新建三个文件夹：
DockerData/GitlabData/config
DockerData/GitlabData/log
DockerData/GitlabData/data
比如我是在F盘的某文件夹下建立config，比如config我在下面路径建好了
f/s111/D/Docker/fazb/DockerData/GitlabData/config
接下来是重点哦，很多网上教程问题都出自这里，运行下面代码前有几点务必注意：
①下面代码的8880:8880和443:443代表映射端口，很多教程是写的80:80很容易是被占用状态，带来不必要的麻烦，所以建议直接按照我的来
②下面的-v 后面的路径是自己的刚刚建的三个文件夹路径，注意的是必须按照我的写法，*盘符小写不带冒号，前面有个斜杠，而且路径用/间隔开，而不是*
上面两点解决绝大多数坑，不然就等着报错绝对路径等问题吧。
docker run -d ^ --hostname localhost ^ -p 8880:8880 ^ -p 443:443 ^ --name gitlab ^ --restart unless-stopped ^ -v /f/s111/D/Docker/fazb/DockerData/GitlabData/config:/etc/gitlab ^ -v /f/s111/D/Docker/fazb/DockerData/GitlabData/log:/var/log/gitlab ^ -v /f/s111/D/Docker/fazb/DockerData/GitlabData/data:/var/data/gitlab ^ gitlab/gitlab-ce:latest 上面运行完后，不出问题的话，会给出一串数字和字母的组合，这就是Docker容器的ID，干什么用的先不管
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa50c66691d17eb1dbf2539711f59c58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5ae66fa6a14ed7c17df7a4fb5635c2/" rel="bookmark">
			关于@Scheduled注解中cron表达式使用*/x与0/x的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于@Scheduled注解中cron表达式使用*/x与0/x的区别： 1.在@Scheduled注解中使用*/x，代表在系统启动时，每过x时间执行一次对应的方法。
例如：
@Scheduled(cron = "0 */10 * * * ?") public void printHello(){ System.out.println("Hello"); } 上面例子代表系统启动时每过10分钟，就要执行一遍printHello()方法。如果系统启动时时间是2023-10-01 14:05:00，那么下一次执行时间便是 2023-10-01 14:15:00
2.而0/x代表从0开始每过x段时间对应的方法就执行一次。
例如：
@Scheduled(cron = "0 0/10 * * * ? ") public void printHello(){ System.out.println("Hello"); } 上面例子代表着系统启动时，以0开始，每过10分钟执行一次printHello()方法。如果系统启动时时间是2023-10-01 14:05:00，那么下一次执行时间便是2023-10-01 14:10:00。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4e1076b6e85eb1c42b1fcc2fb15c2c/" rel="bookmark">
			【Mquant】5：构建价差套利(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.价差套利原理2. 跨期套利3. 套利实战3.1.投研分析3.2 价差特征分析 4. 总结5. 参考 1.价差套利原理 价差套利是一种金融交易策略，通过利用不同市场或不同交易所之间的价格差异来获取利润。以下是价差套利的原理：
基本原则：价差套利的基本原则是同时在相关合约上建立一个多头部位和一个空头部位，以利用两个头寸之间的差值变化来获利。跨交易所套利：在不同交易所之间进行套利是一种常见的价差套利策略。如果一个交易所的价格比另一个交易所高，可以在高价交易所卖出资产，在低价交易所买入等量的资产，从中获取差价利润。这种策略要求交易者在两个交易所分别持有一定数量的资产，并且需要注意交易手续费和资产转移的效率。期现套利：期现套利是指利用现货市场和期货市场之间的价格差异进行套利。当期货合约的价格高于现货价格时，可以同时买入现货并卖出期货，通过差价获利。关键是确保买入的现货数量和卖出的期货数量相等，以减少风险。期现套利的收益率取决于差价的大小和持仓时间。跨期套利：跨期套利是一种利用同一市场上不同交割月份的期货合约之间的价差进行套利的交易行为。投资者通过同时买入一个合约和卖出另一个合约，以期望在价格关系有利时将两种合约对冲平仓获利。跨期套利是套利交易中最常见的一种形式，也是股指期货市场上常见的套利策略之一。风险：价差套利也存在一定的风险。例如，跨交易所套利可能面临盘口流动性不足、API响应慢或交易不成功等风险。期现套利可能面临现货价格上涨导致浮亏、保证金不足导致爆仓或套利规模过大导致流动性风险等问题 2. 跨期套利 跨期套利的基本原理是利用不同交割月份之间的价格差距出现变化时进行对冲，从中获得利润。当期货市场波动较大时，不同交割月份的合约价格差会出现偏离合理价差的情况。投资者可以根据交割制度，捕捉价格偏离区间的机会，同时总结价差走势规律，判断价差套利机会。
跨期套利可以分为牛市套利和熊市套利。牛市套利是指投资者看多股市，认为较远交割期的期货合约涨幅将大于近期合约的涨幅，或者较远期的期货合约跌幅将小于近期合约的跌幅。熊市套利则相反，投资者认为较远交割期的期货合约跌幅将大于近期合约的跌幅，或者较远期的期货合约涨幅将小于近期合约的涨幅。
跨期套利还可以根据买卖方式分为买进套利和卖出套利。买进套利是指投资者预期不同交割月份的期货合约的价差将扩大，他们会买入价格较高的合约，同时卖出价格较低的合约。卖出套利则相反，投资者预期不同交割月份的期货合约价差将缩小，他们会卖出价格较高的合约，同时买入价格较低的合约。
3. 套利实战 在数字货币交易市场，我们会发现大多数行情下，相同币种之间的不同交割合约会存在一定的价差，由于它们属于同一品种，本身价值不会有任何差别，而且涨跌趋势一致，相关性高。那么如果在它们价差低的时候买入，价差高的时候卖出，这样我们就可以赚取中间的这部分差价，这也就是卖出套利策略。不过在实际交易过程中，我们还需要考虑到交易滑点、手续费、极端行情下，价差有可能会走出趋势特征，这个时候采用买进套利策略会更优。
3.1.投研分析 我们准备了币安交易所所有带有交割合约币种的分钟线、小时线、日线数据。如何获取数据，请看教程
【Mquant】4：量化投研配置本地数据库，如果没有数据的同学也可以私信我，我会发给你所需要的数据。
用到的第一份数据是BTCUSDT_231229_BINANCE.csv，表示BTC近月合约高开低收价格数据
用到的第二份数据是BTCUSDT_240329_BINANCE.csv，表示BTC远月合约高开低收价格数据
投研第一步，对数据进行处理，使用jupyter交互式环境，观察数据样貌
import pandas as pd import plotly.express as px df1 = pd.read_csv("BTCUSDT_231229_BINANCE.csv",index_col="datetime") df1.head() df2 = pd.read_csv("BTCUSDT_240329_BINANCE.csv",index_col="datetime") df2.head() 构建价差数据集
df_data = pd.DataFrame({ "BTC231229":df1["close"], "BTC240329":df2["close"] }) # 清除空值数据 df_data.dropna(inplace=True) df_data["spread"] = df_data["BTC240329"] - df_data["BTC231229"] # 绘制图像 px.line(df_data["spread"]) 保存数据集
# 保存数据 df_data.to_csv("spread_data.csv") 3.2 价差特征分析 价差特征分析是指利用价格或指标之间的差距来进行分析和预测的方法。通过计算不同时间点或不同指标之间的差值，可以揭示出价格或指标的变化趋势和差异，从而帮助我们做出相应的决策。以下是价差特征分析的一些常见应用和方法：
技术指标的价差分析：价差分析也可以用于技术指标的计算和分析。通过计算不同指标之间的差值，可以得到更多的信息。例如，通过计算不同移动平均线之间的差值，可以判断价格的趋势和变化。
历史统计特征的价差分析：价差分析还可以用于计算历史统计特征。通过计算不同时间窗口内的统计特征的差值，可以得到更多的信息。
特征生成和价差分析：在特征工程中，可以利用价差分析生成新的特征。通过计算不同特征之间的差值，可以得到更多的特征。例如，计算不同指标之间的差值，可以生成新的特征来描述指标之间的关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4e1076b6e85eb1c42b1fcc2fb15c2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/885e6cfe2c46a13d16d778a9bab4c258/" rel="bookmark">
			【Mquant】2：量化平台的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、选择因素二、常见的量化平台三、为什么选择VeighNa？四、参考 一、选择因素 功能和工具集：量化平台应该提供丰富的功能和工具集，包括数据分析、策略回测、实时交易等。不同的平台可能有不同的特点和优势，可以根据自己的需求选择适合的平台。
数据源和数据质量：量化交易离不开高质量的数据，因此选择一个平台时要考虑其数据源和数据质量。一些平台可能提供多种数据源，包括股票、期货、外汇等，而且数据质量也可能有所差异。
编程语言和开发环境：量化平台通常需要使用编程语言进行策略开发和回测，因此选择一个熟悉的编程语言和开发环境对于开发者来说很重要。常见的编程语言包括Python、R、C++等，不同的平台可能支持不同的编程语言。
社区和支持：一个活跃的社区和良好的技术支持可以帮助解决问题和分享经验。选择一个有活跃社区和提供良好技术支持的平台可以更好地与其他开发者交流和学习。
安全性和保密性：对于一些敏感的策略和交易数据，安全性和保密性是非常重要的。选择一个有良好安全措施和保密性保护的平台可以保护个人的交易策略和数据。
二、常见的量化平台 掘金：老牌的量化投资工具集平台，提供丰富的功能和工具集，适用于中低频类型的A股市场投研策略。
天软：资历较老的量化投资工具集平台，提供数据分析、策略回测等功能。
文华：期货市场的量化投资工具集平台，适用于期货交易策略的开发和回测。
开拓者：量化投资工具集平台，适用于数量化分析决策思维的工具。
聚宽：基于云端的web版量化平台，提供开发环境、数据API集成、可视化界面和分享互动社区等功能。
优矿：基于云端的量化平台，提供数据分析、策略回测等功能，适用于中小散A股的个人量化投资。
Bigquant：基于云端的量化平台，提供数据分析、策略回测等功能，适用于中小散A股的个人量化投资。
真格量化：适用于期货期权类型的量化平台，提供丰富的报单算法函数和高频交易支持。
Veighna：基于Python的开源量化交易平台开发框架，支持大量高性能交易Gateway接口，用户可以自由选择通过GUI图形界面模式管理，或者使用CLI脚本命令行模式运行。
​
平台名称访问地址数据方面研究方面回测方面模拟交易方面实盘交易方面交流社区方面迅投QMT（Think Trader）合作券商提供提供全部日/分钟/Tick级别股票数据，及财务、分红送配、行业、板块等数据。还提供期货、期权的连续数据及过期合约。支持Python，VBA，提供API接口。支持股票、期货、期权等品种回测及其混合回测，支持日、分钟、Tick全周期回测。支持股票、期货、期权、可转债等品种的日、分钟级别的模拟交易。支持股票、期货、两融、期权、可转债等量化实盘，实盘直接和对接券商开通，具有实盘交易权限后也可以手动交易。券商专业客户服务群恒生PTrade合作券商提供提供沪深股票、期权、期货等全品种L2行情支持。支持Python，提供API接口。支持股票、可转债等品种回测，支持日、分钟、Tick级全周期回测。支持股票、可转债、期权等品种的日、分钟级别的模拟交易。支持股票、可转债、期权等量化实盘，有丰富的手工T0交易工具，实盘直接和对接券商开通，具有实盘交易权限后也可以手动交易。券商专业客户服务群掘金量化（Myquant）https://www.myquant.cn/提供近10年日/分钟/Tick级别股票数据，及财务、分红送配、行业、板块等数据。还提供股指期货、商品期货的连续数据。支持Python，Matlab，C，C++，C#语言，提供API接口。支持股票、期货等品种回测及其混合回测，支持日、分钟、Tick级回测。支持股票、商品期货、股指期货等品种的日、分钟级别的模拟交易。支持股票、期货、两融等量化实盘，实盘开通需要客户提交申请和平台人工审核，具有实盘交易权限后也可以手动交易。掘金量化社区，活跃度一般米筐（Ricequant）ricequant.com/welcome/提供股票、ETF、期货（股指、国债、商品期货）、现货的基本信息。股票、ETF过去10多年以来每日市场数据，股票、ETF在2005年以来的分钟线数据。ETF过去20多年以来的市场数据和财务数据。期货从1999年以来的每日行情数据。期货2010年以来的分钟线数据。中国50 ETF、商品期权的日、分钟数据。舆情大数据。提供基于IPython Notebook的研究平台，支持Python，Matlab，Excel。提供API。支持股票、ETF、期货等品种的回测，支持日、分钟级回测。支持日、分钟级别的股票、ETF、期货等品种的模拟交易。提供期货的实盘交易。“米筐量化社区”，活跃度较高。聚宽（JoinQuant）https://www.joinquant.com/提供2005年至今完整的股市Leve1数据、上市公司财务数据、完整的停复权信息。实时更新行情数据，盘后更新财务数据。此外还提供基金（包括ETF、LOF、分级A/B基金、货币基金）的行情和净值数据，金融期货数据、股票指数数据、行业板块数据、概念板块数据、宏观数据、行情数据等。提供基于IPython Notebook的研究平台，支持Tick级数据，支持Python2、Python3。提供API（Application Programming Interface）。支持股票、基金、期货等品种的回测，支持日、分钟、Tick级回测。支持股票、股指期货、商品期货、ETF等品种的日、分钟、Tick级别的模拟交易。支持股票、场内基金、期货的自动化实盘交易。undefined“聚宽社区”，活跃度很高。Bigquanthttps://bigquant.com/提供日/分钟级别的股票、期货、基金等数据的实时和历史数据，以及新闻、社交等新型数据。支持Python，提供AI开发策略。提供API。支持股票、期货等品种的回测，支持日、分钟、Tick级回测。支持日、分钟级别的股票、期货等品种的模拟交易。可推送秒级交易信号，提供API接口对接交易终端，由用户手动交易。“Bigquant量化社区”，活跃度较高。真格（澎博财经旗下）https://quant.pobo.net.cn主要是商品期货、期货期权、金融期货、股票期权等金融衍生品的数据。支持使用Python进行策略研究。提供API。主要提供期货、期权的日、分钟、Tick级别的回测。使用第三方模拟交易平台，主要提供期货、期权的日级别的回测。主要提供期货的实盘交易。“真格量化社区”，活跃度一般。优矿（Uqer）https://uqer.datayes.com/"2007年以后的沪深港上市公司财务报表数据，沪深交易所股票基本信息和日/分钟级别行情，港股日级别行情。日/分钟级别的场内基金行情、日/分钟/Tick的期货行情、日/分钟级别的指数行情、日/分钟/Tick级别的期权行情。大宗商品、债券、宏观产业数据。以及股票/指数的量化因子库，主流媒体数据，主流电商数据等。提供类似IPython Notebook的研究平台，只支持使用Python2进行策略研究。提供API。支持股票、场内外基金、期货、指数等品种的日、分钟级回测。支持股票、场内外基金、期货、指数等品种的模拟交易。暂时无法实现实盘交易。“优矿社区”，活跃度较高。MindGo（同花顺旗下）https://quant.10jqka.com.cn/view/2005年至今的股票财务数据、资金数据、行业数据，基金数据，指数数据，期货数据，期权数据，可转债数据、因子数据、QuantdI数据、Tushare数据、iFinD数据等。基于Jupyter Notebook研究环境，支持使用Python进行策略研究。提供API。支持股票、场外基金、期货、外汇等T+0和T+D品种的日、分钟级回测。支持日、分钟、Tick级别的模拟交易。暂时无法实现实盘交易。“MindGo量化社区”，活跃度一般。果仁https://guorn.com/主要是近十年的股票、基金数据。非编程量化平台，一站式策略服务，门槛低（其实觉得非编程类严格来说不算量化平台，但是是很好的参考和学习平台）。主要提供股票、基金的策略的日级回测。暂没有明确的模拟交易概念。暂时无法实现实盘交易。没有社区。TradeBlazer(TB交易开拓者)http://www.tradeblazer.net/完备的数据库。涵盖宏观、企业财务数据、板块、复权等等基础数据。 三、为什么选择VeighNa？ 选择Veighna的原因有以下几点：
开源量化平台：Veighna是一个开源的量化平台，这意味着它的代码是公开的，任何人都可以查看和修改。这为用户提供了更大的灵活性和可定制性，可以根据自己的需求进行修改和扩展[1]。
功能丰富：Veighna提供了各种模块和功能，包括数据接口、交易接口、回测模块、策略开发等。用户可以根据自己的需求选择和使用这些功能，从而实现量化交易的各个环节[1]。
多种数据源支持：Veighna支持对接各类数据服务的适配器接口，包括从rqdata获取历史行情数据、连接各类数据库、接入国内外交易所的交易接口等。这使得用户可以方便地获取和处理各种数据，为量化策略的开发和回测提供了便利[2]。
简单易用：Veighna提供了图形界面和命令行界面两种方式进行操作，用户可以根据自己的喜好选择使用。同时，Veighna还提供了丰富的文档和示例代码，帮助用户快速上手和使用平台的各种功能[2]。
社区支持：Veighna拥有一个活跃的开源社区，用户可以在社区中获取帮助、交流经验和分享自己的成果。这为用户提供了一个学习和成长的平台，可以与其他量化交易爱好者共同进步[1]。
四、参考 1.一张图认识【VeighNa开源量化平台】的各种模块！ - 知乎
2. vnpy/VeighNa入门 - 知乎
3. 一张图认识【国内市场】的量化数据服务！ - 主题 - VeighNa量化社区
4. 个人从事量化交易，关于量化平台的选择 - 知乎
5.【思考33】如何选择量化工具与平台 - 知乎
6. 量化投资对于数据源、回测、实盘平台的选择-高顿教育
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1840dfe31e498b56f32a83587dcb31f1/" rel="bookmark">
			【Mquant】6：构建价差套利(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 上节回顾2. 本节内容3. 统计套利3.1 构建均值回归策略 4. 实践4.1 选择交易标的4.2 确定交易规则4.3 策略代码4.4 策略回测 5.实盘交易 1. 上节回顾 【Mquant】5：构建价差套利(一)介绍了价差套利的原理和跨期套利的概念。同时，提到了价差套利存在的一定风险，并且介绍了跨期套利的原理和分类、投研分析和价差特征分析的方法。
2. 本节内容 本文将带领读者从零开始，逐步构建一个完整的价差实战套利策略。这将是一个循序渐进的过程，旨在帮助读者了解价差套利的核心概念和实施步骤。
首先重点讲解价差套利策略的构建过程。这将涉及选择适合价差套利的市场和交易品种，确定合适的套利时机和条件，并建立相应的交易规则和执行策略。使用一些常用的技术工具和指标，帮助读者进行价差分析和套利机会的识别。
在策略构建的过程中，本文将提供详细的实例和案例分析，以便读者能够更好地理解和应用所学知识。同时，作者还会强调风险管理的重要性，分享一些有效的风险控制方法，并提供实用的建议和技巧。
本文最后将引导读者进行模拟交易和实盘操作，以验证和优化所构建的价差套利策略。通过实际的交易实践，读者将能够更好地理解市场动态和实际执行的挑战，并逐步提升自身的交易技能和经验。
3. 统计套利 在统计套利中，常用的方法包括配对交易（Pairs Trading）、均值回归策略（Mean Reversion）、协整关系交易（Cointegration Trading）等。这些方法基于统计学的原理，利用价格或资产之间的相对价差、均值偏离或协整关系等统计指标来确定交易信号和执行策略。
在实践中，统计套利中的某些策略可以包含价差套利的元素，例如配对交易和均值回归策略经常涉及价格差异的利用。同时，统计套利的一些方法和工具，如协整关系的分析和模型构建，也可以为价差套利提供理论支持和辅助分析。
3.1 构建均值回归策略 本文着手于构建一个均值回归策略，通过理论和实践相结合的方式，帮助读者快速构建一套属于自己的交易策略，构造一个均值回归策略涉及以下步骤：
选择资产：首先，选择您感兴趣的资产或市场，可以是股票、期货、外汇等。确保选择的资产存在明显的价格波动和均值回归的趋势。
确定均值：通过历史数据计算资产的均值。常见的方法是使用移动平均线（如简单移动平均线或指数加权移动平均线）来估计资产价格的均值。
计算偏离度：计算资产价格相对于均值的偏离度。可以使用标准差、百分位数或其他统计指标来度量价格的偏离程度。
确定交易信号：根据偏离度确定交易信号。当价格偏离均值超过一定阈值时，产生交易信号。例如，当价格偏离均值超过一个标准差时，可以认为价格过度偏离，产生反向交易信号。
确定交易规则：定义具体的交易规则，包括入场点、出场点和止损点。例如，当价格偏离均值达到一定程度时，进入反向头寸；当价格回归到均值附近时，平仓并获利。
风险管理：制定有效的风险管理策略，包括设置止损点、控制仓位大小和分散投资等。确保风险可控，并考虑交易成本和流动性等因素。
回测和优化：使用历史数据进行回测，评估策略的表现，并进行必要的优化。调整参数和交易规则，以提高策略的盈利能力和稳定性。
实盘交易：在回测和优化后，将策略应用到实盘交易中。始终密切监控市场情况和策略表现，并根据需要进行调整和优化。
4. 实践 4.1 选择交易标的 选择交易标的核心是确保选择的资产存在明显的价格波动和均值回归的趋势
使用统计指标来评估价格的波动性和均值回归的趋势。常用的指标包括标准差、平均绝对偏差（Mean Absolute Deviation）、波动率等。较高的波动性和明显的均值回归特征可能表明资产适合均值回归策略。
协整性分析：对于多个相关资产，可以进行协整性分析。协整关系是指一组资产的价格在长期内存在稳定的线性关系。如果资产之间存在协整关系，并且价格偏离协整关系时会发生均值回归，那么这些资产可能适合均值回归策略。
历史数据分析：通过对资产的历史价格数据进行分析，评估价格的波动性和均值回归的趋势。观察价格的波动范围、频率和幅度，以及价格是否有向均值回归的倾向。
在上节内容【Mquant】5：构建价差套利(一)基础上，这一章节我们对btc数据又进行了一系列的统计学分析，以说明均值回归策略适用于什么周期，用什么指标来量化。
import numpy as np import pandas as pd df = pd.read_csv("spread_data.csv") # 计算价格波动性指标 std = np.std(df['spread']) # 标准差 mad = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1840dfe31e498b56f32a83587dcb31f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb0da1180df98a40754c92e8622a9260/" rel="bookmark">
			mysql之备份和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）备份 1、备份的种类 （1）完全备份：将整个数据库完整的进行备份 （2）增量备份：在完全备份的基础上，对后续新增的内容进行备份 2、备份的需求 （1）在生产环境中，数据的安全至关重要，任何数据的丢失都可能产生严重的后果 （2）数据丢失的原因：程序操作、运算错误、磁盘故障、不可预期的事件、认为操作等等 3、备份的方法 （1）冷备份：关机备份，停止mysql服务，然后进行备份 （2）热备份：开机备份，无需关闭mysql服务，然后进行备份 （3）物理备份：对数据库系统的物理文件（数据文件、日志文件）进行备份 （4）逻辑备份：对数据库的逻辑组件进行备份（表结构），以sql语句的形式，把库、表结构、表数据进行备份保存（直接在数据库系统中删除所有文件，逻辑备份无法恢复） （二）物理备份 1、物理备份：采用完全备份，对整个数据库进行完整的打包备份 2、优点：操作简单（打包、解包） 3、缺点：数据库文件占用量很大，占用空间大，备份和恢复的时间很长，而且需要暂停数据库 4、物理冷备份（关机备份） 打包备份最好关闭服务，避免有新的数据进入、被覆盖，也可能导致恢复失败 （1）创建两个数据库、建表、写入数据 5、远程复制库
（三）热备份中的逻辑备份 1、mysql自带的工具：mysqldump（逻辑恢复数据库） （1）mysqldump：操作方便简单，但是只能基于逻辑上的表结构和表数据恢复，物理删除之后，再用逻辑恢复会报错；也可以作为数据迁移 （2）优点：较物理备份，相对来说占的空间要小得多 （3）缺点：占用空间大 2、命令 备份单个库：mysqldump -u root -p123 --databases test &gt; /opt/test.sql
备份多个库：mysqldump -u root -p123 --databases test test1&gt; /opt/test.sql
备份所有库：mysqldump -u root -p123 --all-databases &gt; /opt/test.sql
3、实验 （1）物理删除数据库，会报错
（2）对多个库一次性备份 （3）备份所有的库
4、只恢复数据表 （1）单个表 （2）多个表 5、mysql的命令 （1）mysql连接执行之后即退出 -e：指定连接mysql之后，执行完命令之后，自动退出 （四）增量备份 1、mysqldump也支持增量备份 增量备份：没有重复数据，备份量小，时间短mysqldump增量备份恢复表数据期间，表会锁定缺点：备份时锁表，必然会影响业务（超过10G大小，耗时会比较长，导致服务不可用）mysql提供的二进制日志间接的视线增量备份 2、mysql二进制日志记录格式有三种 （1）STATEMENT：基于sql语句 特点：记录修改的sql语句，高并发情况下，记录sql语句时候的顺序可能会出错，恢复数据时可能会导致丢失和误差，效率比较高 （2）ROW：基于行 特点：精准记录每一行的数据，准确率高，但是恢复时的效率低 （3）MIXED：混合模式，既可以根据sql语句，也可以根据行 特点：在正常情况下使用STATEMENT，一旦发生高并发，会智能自动切换ROW行 3、二进制文件怎么来（修改配置文件） 4、位置恢复（基于位置点进行恢复）： （1）从某一个点开始，恢复到最后 格式：mysqlbinlog --no-defaults --start-position=’位置点’ 文件名 | mysql -u root -p （2）从开头一直恢复到某个位置 格式：mysqlbinlog --no-defaults --stop-position=’位置点’ 文件名 | mysql -u root -p （3）从指定点到指定结束点（位置范围） 格式：mysqlbinlog --no-defaults --start-position=’位置点’ --stop-position=’位置点’ 文件名 | mysql -u root -p （4）实验 5、时间恢复（基于时间点进行恢复） （1）从某个事件点开始，恢复到最后 格式：mysqlbinlog --no-defaults --start-datetime=’位置点’ 文件名 | mysql -u root -p （2）从开头一直恢复到某个时间点 格式：mysqlbinlog --no-defaults --stop-datetime=’位置点’ 文件名 | mysql -u root -p （3）从指定时间点到指定结束时间点（时间范围） 格式：mysqlbinlog --no-defaults --start-datetime=’位置点’ --stop-datetime=’位置点’ 文件名 | mysql -u root -p （4）实验 6、总结 （1）在生产中，通过binlog进行增量恢复是非常好用的方法，只需要对binlog文件进行备份，随时可以进行备份和恢复 （五）配置文件 1、MySQL 的日志默认保存位置为 /usr/local/mysql/data 2、错误日志，用来记录当MySQL启动、停止或运行时发生的错误信息，默认已开启 （1）log-error=/usr/local/mysql/data/mysql_error.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb0da1180df98a40754c92e8622a9260/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e947410a42ecf862f2aa6907113a9277/" rel="bookmark">
			应急响应—溯源反制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应急响应—溯源反制 1. 攻击后溯源1.1. IP地址1.1.1. IP地址定位1.1.2. IP地址分析 1.2. 域名1.3. 手机号/QQ1.4. ID1.5. 木马样本1.6. 总结 2. 攻击中反制2.1. 定位准确2.2. 反制手段2.2.1. 钓鱼邮件反制2.2.2. 蚁剑反制2.2.2.1. 测试XSS漏洞2.2.2.2. RCE漏洞反弹shell 2.2.3. goby反制2.2.3.1. 修改PHP代码 2.2.4. dnslog反制2.2.4.1. 反制方式2.2.4.2. 查看效果 2.2.5. Cobaltstrike反制 2.3. 总结 3. 攻击前反制 1. 攻击后溯源 所谓被攻击后溯源，意思就是网站已经被攻击者攻击了，而我们需要的是利用攻击者遗留下来的木马文件、访问日志、防火墙日志、态势感知日志等信息去获取相关的资料，在对其资料中可用的内容进行分析溯源。
1.1. IP地址 关于IP地址，是攻击者最容易被遗留下来的数据，类似IP地址可能会遗留在中间件的日志中、Windows中RDP远程连接日志、Linux中SSH远程连接依旧防火墙或态势感知中攻击行为IP地址，都可能会遗留下来。
1.1.1. IP地址定位 这里我用防火墙捕获到的IP地址做测试，这个IP地址好像是某个视频厂商来远程调试，导致误报出现的攻击，具体忘记了是某康还是某视的了。
https://www.opengps.cn/Data/IP/ipplus.aspx https://chaipip.com/ https://www.ipplus360.com/ 1.1.2. IP地址分析 当然IP地址定位只是为了更好的找到攻击者的位置，但是，更多的时候只有说出现大问题的时候才会具体去找人，而攻击者基本上都会隐藏自己的IP地址。所以，IP地址定位多数情况下用处不多。
更好的是将IP地址进行分析，例如是否存在域名等等，例如这里使用微步查看是否曾经有人给该IP打过标签，有没有备案过域名，如果使用的是云服务器，大概率可能会对其备案域名。
由于这里溯源反制比较麻烦，没有真实的IP地址，确实不好对其进行分析，又不能拿别人的博客地址或者什么的来进行分析，这样就是搞别人的隐私了。
1.2. 域名 这里就是依据上述获取到相关的域名才好对其进行分析，例如www.baidu.com完全可用去进行whois查询、备案查询、天眼查、fofa查询等。
可以看一下，我之前注册的域名，并没有使用，也被我关了，可以看到公司那里，就是我的名字，到这里就基本上可能能获取到姓名了，但是需要注意的是，有很多情况下，攻击者基本上都是使用免实名制的域名，那就不好办了…
如果注册公司直接显示的是某家公司，那就可以使用一些查公司的例如天眼查、企查查就可以找到注册人了，通常也就能够获取到手机号了。
1.3. 手机号/QQ 比如，你访问IP地址所属的域名，可以在域名网站中找一找，通常在网站中都会存在例如打赏、微信号、QQ等，如果能够获取到QQ号更好，那么就可以根据QQ号在**库中反差。
由于在网站中获取到手机号基本上是不太可能的，而想要获取到手机号其实是比较麻烦的。而QQ号或微信号是最容易获取的，如果能够加上好友那最好。
拿到qq可以到你懂的的上面去搜，基本上也就能获取到相应的手机号，获取到手机号，那不基本上就是想怎么搞都可以了呀。
手机号： 支付宝、微信、微博等等，通过这些方式，可能能够获取到图片等等，还有可能获取到照片。 1.4. ID ID这个东西吧，有些人会习惯性的各大网站都会使用同一个ID，那就可以直接百度搜索么，包括可以直接拿着ID去圈子里面问问，有没有人认识。
你看我这ID，遍地都是…无语了，我要改名字了，当然在这个圈子里面，谁没被人家恶搞过…
百度搜索、谷歌搜索、src搜索、微博搜索、微信ID搜索、豆瓣、贴吧、知乎等等。 1.5. 木马样本 木马样本中有可能也能够找到一些相关数据，例如我这里使用cs生成一个木马，当然啦，没做免杀，直接获取到木马的IP地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e947410a42ecf862f2aa6907113a9277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be186f11270eabfb26b76ee0e206407d/" rel="bookmark">
			Unity打包安卓、IOS进行人脸捕捉——Live Capture（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言步骤1把从github上下载的包直接导入Unity（文章末尾有链接）2.打包测试3.IOS下载Unity Face Capture4.运行测试 其他 前言 此工程打包到安卓或IOS运行后，需要用另一台IOS设备在App Store上下载Unity Face Capture进行面捕
步骤 1把从github上下载的包直接导入Unity（文章末尾有链接） 2.打包测试 打包好后安卓端安卓安装APk，IOS打包自行搜索打包方法，这里就不演示了，打包后操作跟安卓一样
3.IOS下载Unity Face Capture 在App上输入安卓或IOS设备的网络IP地址，端口号是9000
4.运行测试 liveCapture测试
其他 包链接：https://github.com/huanhpig/liveCapture.git
参考：https://cloud.tencent.com/developer/article/2086337
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f20836c3bdf62173e8ea6e4e694ef24/" rel="bookmark">
			minio的docker启动指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker run -p 9000:9000 -p 9090:9090 \
--name minio \
--restart=always \
-e "MINIO_ACCESS_KEY=minioadmin" \
-e "MINIO_SECRET_KEY=minioadmin" \
-v /mydata/minio/data:/data \
-v /mydata/minio/config:/root/.minio \
-d minio/minio server \
/data --console-address ":9090" -address ":9000"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43636976aa59d8563bb2a26f0ca6cf2/" rel="bookmark">
			pcl&#43;vtk 程序编译无法解析的外部符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #define vtkRenderingCore_AUTOINIT 3(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingOpenGL2) VTK_MODULE_INIT(vtkRenderingOpenGL); 错误 1 error LNK2019: 无法解析的外部符号 "void __cdecl vtkRenderingOpenGL_AutoInit_Construct(void)" (?vtkRenderingOpenGL_AutoInit_Construct@@YAXXZ)，该符号在函数 "public: __thiscall vtkRenderingOpenGL_ModuleInit::vtkRenderingOpenGL_ModuleInit(void)" (??0vtkRenderingOpenGL_ModuleInit@@QAE@XZ) 中被引用 E:\Visual Studio 2013\PCL_FPFH\PCL_FPFH\源.obj PCL_FPFH
错误 2 error LNK2019: 无法解析的外部符号 "void __cdecl vtkRenderingOpenGL_AutoInit_Destruct(void)" (?vtkRenderingOpenGL_AutoInit_Destruct@@YAXXZ)，该符号在函数 "public: __thiscall vtkRenderingOpenGL_ModuleInit::~vtkRenderingOpenGL_ModuleInit(void)" (??1vtkRenderingOpenGL_ModuleInit@@QAE@XZ) 中被引用 E:\Visual Studio 2013\PCL_FPFH\PCL_FPFH\源.obj PCL_FPFH
错误原因：VTK版本的问题
解决方法：
VTK6.0之后版本使用如下语句初始化：
#include &lt;vtkAutoInit.h&gt; VTK_MODULE_INIT(vtkRenderingOpenGL); VTK_MODULE_INIT(vtkInteractionStyle); VTK_MODULE_INIT(vtkRenderingFreeType); VTK6.0之前版本使用如下语句初始化：
#define vtkRenderingCore_AUTOINIT 4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeType,vtkRenderingOpenGL) #define vtkRenderingVolume_AUTOINIT 1(vtkRenderingVolumeOpenGL) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff7f7f1eebe076573f1f414adee5afe/" rel="bookmark">
			若依分离版——配置多数据源（mysql和oracle），实现一个方法操作多个数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、若依平台配置
二、编写oracle数据库访问的各类文件
三. 一个方法操作多个数据源
一、若依平台配置 1、在ruoyi-admin的pom.xml添加oracle依赖
&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;11.2.0.3&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/src/main/resources/lib/ojdbc6.jar&lt;/systemPath&gt; &lt;/dependency&gt; 2、引入ojdbc6.jar包
在ruoyi-admin的resource下创建lib文件夹，将ojdbc6.jar包保存在此目录下
3. 刷新maven
刷新maven保证ruoyi-admin的Dependencies包含com.oracle:ojdbc6:11.2.0.3(system) ，
否则会报java.lang.ClassNotFoundException: oracle.jdbc.driver.OracleDriver 错误
4、在ruoyi-admin模块application-druid.yml配置从库数据源（若依已配置，需要修改） 注意：删除 datasource下的driverClassName: com.mysql.cj.jdbc.Driver，写到master下面
# 数据源配置 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource druid: # 主库数据源 master: url: jdbc:mysql://IP:3306/feedback?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8 username: root password: root driverClassName: com.mysql.cj.jdbc.Driver # 从库数据源 slave: # 从数据源开关/默认关闭 enabled: true url: jdbc:oracle:thin:@IP:1521:orancdb username: root password: root driverClassName: oracle.jdbc.driver.OracleDriver 5、在DataSourceType类添加数据源枚举（若依已配置，忽略）
/** * 从库 */ SLAVE 6、在DruidConfig配置读取数据源（若依已配置，忽略）
@Bean @ConfigurationProperties("spring.datasource.druid.slave") @ConditionalOnProperty(prefix = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cff7f7f1eebe076573f1f414adee5afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8d9b2e96a9c47d0b2ef2a4319ec2bb/" rel="bookmark">
			【发布的微信小程序源码丢失怎么办】【微信小程序反编译】记录一次小程序源码找回经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 之前研发的一款小程序由于审核没有通过一直闲置，经历三四年后想重新调整后再审核。 发现之前的源码不知道丢哪里去了（不要学我，一定要把代码用管理仓库存起来，也能更好的溯源）。 实在是不想再写一遍，开始各种歪脑筋。好在最后成功了，特此记录一下总结过程。 思路： 如何获取已发布的源码已发布的源码是微信原生格式并且编译过，如何格式化整合后的源码如何回归uniapp格式进行二次开发 工具 nodeJs小程序解密工具 提取码：leom反编译工具 提取码：d4x3微信小程序原生转换uniapp格式工具 miniprogram-to-uniapp v2HBuilderX 解决过程 使用【电脑端微信】打开小程序后，在微信【设置】中找到【文件管理】，打开微信文件存储地址（一般在D:\wx\WeChat Files文件夹下），找到【Applet】文件夹，找到自己【小程序的appId】命名的文件夹，最后找到子文件中的名为【APP.wxapkg】文件。
使用小程序解密工具解密当前_APP_.wxapkg文件。提取码：leom。资源来源
使用反编译工具获取符合微信小程序原生格式规则的代码。 提取码：d4x3。资源来源
如果一开始使用的就是微信小程序原生开发，那么这里只需要直接使用HBuilderX开发工具中的miniprogram-to-uniapp v2插件将微信小程序原生代码转换为uniapp格式即可。
使用HBuilderX启动项目就看到一个完整还原的uniapp项目啦。
非微信原生小程序开发项目转uniapp方法 由于我原本的开发框架就是uniapp（其他框架同理），所以反编译出来的代码有标识被拒绝构建为uniapp项目，所以这里需要多进行一步操作：
6. 使用微信小程序开发工具新建一个干净的项目，再将反编译出来的微信小程序原生格式的代码一个个复制进去，去除多余的代码。
7. 此时就得到一个干净的微信原生开发出来的小程序源码，此时再使用【解决过程】中的第4点：使用HBuilderX开发工具中的miniprogram-to-uniapp v2插件将微信小程序原生代码转换为uniapp格式。
至此，完结撒花✿✿ヽ(°▽°)ノ✿~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7127d2bb56dec2b41d7ed441752a9a15/" rel="bookmark">
			基于ATT-ABCNet 改进CRNN的火车票实时识别系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.研究背景与意义 项目参考AAAI Association for the Advancement of Artificial Intelligence
研究背景与意义
随着科技的不断发展，人工智能技术在各个领域得到了广泛的应用。其中，图像识别技术在实际生活中的应用越来越广泛，其中之一就是火车票实时识别系统。火车票实时识别系统可以通过识别火车票上的信息，实现自动化的售票、验票等功能，提高了火车站的工作效率，方便了乘客的出行。
然而，火车票实时识别系统面临着一些挑战。首先，火车票的样式和格式多种多样，包括不同的颜色、字体、布局等。这使得传统的基于规则的方法很难适应各种不同的火车票样式。其次，火车票上的信息需要高精度的识别，以确保售票和验票的准确性。然而，由于火车票上的信息通常是印刷体，存在一定的模糊和变形，这增加了识别的难度。因此，开发一种高效准确的火车票实时识别系统对于提高火车站的工作效率和服务质量具有重要意义。
近年来，深度学习技术在图像识别领域取得了巨大的突破。其中，卷积神经网络（Convolutional Neural Network，CNN）和循环神经网络（Recurrent Neural Network，RNN）是两种常用的深度学习模型。CNN可以有效地提取图像的特征，而RNN可以处理序列数据，适用于文本识别任务。因此，将CNN和RNN相结合的CRNN模型成为了文本识别领域的研究热点。
然而，传统的CRNN模型在火车票实时识别任务中存在一些问题。首先，传统的CRNN模型对于小尺寸的文本识别效果较差，而火车票上的信息通常较小。其次，传统的CRNN模型对于文本的上下文信息利用不充分，导致识别准确率不高。因此，有必要对CRNN模型进行改进，以提高火车票实时识别系统的性能。
基于以上背景和问题，本研究旨在基于ATT-ABCNet改进CRNN模型，实现高效准确的火车票实时识别系统。具体来说，本研究将引入注意力机制（Attention Mechanism）和自适应二维卷积（Adaptive 2D Convolution）来改进CRNN模型。注意力机制可以帮助模型更好地关注文本的重要部分，提高识别准确率。自适应二维卷积可以适应不同尺寸的文本，提高模型对小尺寸文本的识别效果。
本研究的意义主要体现在以下几个方面。首先，通过改进CRNN模型，可以提高火车票实时识别系统的准确性和鲁棒性，提高火车站的工作效率和服务质量。其次，本研究引入的注意力机制和自适应二维卷积可以为其他文本识别任务提供借鉴和参考，拓展了深度学习在文本识别领域的应用。最后，本研究对于推动火车站数字化转型，提高火车站信息化水平具有重要意义。
综上所述，基于ATT-ABCNet改进CRNN的火车票实时识别系统的研究具有重要的背景和意义，对于提高火车站的工作效率和服务质量具有积极的影响。
2.图片演示 3.视频演示 基于ATT-ABCNet 改进CRNN的火车票实时识别系统
4.ABCNet 模型文本识别模型 ABCNet 模型框架 ABCNet模型的网络架构如图3.1所示，模型主要由检测模块、贝塞尔网络以及识别模块组成。检测模块利用ResNet-50作为主干网络，使用FPN融合特征图，并在此基础上预测文本框的位置信息。在回归坐标点时，输入进基于贝塞尔曲线检测算法的 anchor-free 网络，使用坐标点的参数信息对图像中的文本形成文本框。ABCNet模型的识别模块包括六个卷积层、BLSTM网络和CTC层，属于轻量级的识别分支，这样可以保证模型的识别速度。
ABCNet模型采用的贝塞尔曲线检测网络，使其代替传统长方形文本框，对任意形状的文本进行拟合，实现自适应的对图像中的文本进行检测。贝塞尔曲线的计算公式如下，主要由一系列支点b,和关于t的参数方程表示，详见公式4.1和 4.2所示。
其中n为贝塞尔曲线的阶数，因为b的指数是从О开始，所以这里的支点个数为n+1。参数t由0至1进行演化，形成了一条完整的曲线。曲线上的任意一点T(t)的坐标，就是由曲线上全部支点坐标的加权平均值计算得到，T(t)的权重是上述公式中的B。B的方程在数学中叫做伯恩斯坦多项式(Bernstein polynomials）[51l，它也是t的函数，也由支点决定。
基于深度学习的自然场景文本识别算法改进框利用贝塞尔曲线回归，短边是直线段。ABCNet模型使用三阶贝塞尔曲线，每边有四个支点，上下两条曲线需要的总共八个支点坐标，就是检测网络预测的目标。由于采用贝塞尔曲线网络并不会增加太多的参数，因此后续在模型改进时保留了这一部分，在其检测模块和识别模块进行改进。
5.核心代码讲解 5.1 collect_env.py 根据代码，我将其封装为一个名为EnvironmentInfo的类，其中包含一个静态方法collect_env_info用于收集环境信息。
class EnvironmentInfo: @staticmethod def collect_env_info(): def collect_torch_env(): try: import torch.__config__ return torch.__config__.show() except ImportError: # compatible with older versions of pytorch from torch.utils.collect_env import get_pretty_env_info return get_pretty_env_info() def get_env_module(): var_name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7127d2bb56dec2b41d7ed441752a9a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b56add51867f9a5d8508371f084036/" rel="bookmark">
			20个CSS面试题和答案的示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是盒模型？它有哪些部分组成？
答：盒模型是指在网页布局过程中，每个元素都被描绘成一个矩形框，这个矩形框由内容区、内边距、边框和外边距组成。 请解释CSS的层叠顺序（Specificity）是什么，如何计算它？
答：层叠顺序是指在样式冲突时，浏览器根据选择器的特异度（Specificity）来确定应用哪个样式。特异度由选择器中的ID、类、标签等因素决定，一般以四个值的形式表示，越具体的选择器特异度越高。可以使用公式计算：[inline styles] &gt; [IDs] &gt; [classes, pseudo-classes, attributes] &gt; [elements, pseudo-elements]。 介绍一下Flexbox和Grid布局，它们有什么区别？
答：Flexbox是一种一维布局系统，主要用于排列元素，适用于需要灵活调整元素位置和尺寸的情况；而Grid布局是一种二维布局系统，适用于将页面划分为行和列进行布局。 什么是响应式设计？如何通过CSS实现响应式布局？
答：响应式设计是指根据用户设备的不同尺寸和屏幕分辨率，使网站能够自动调整布局以适应不同的显示环境。通过使用媒体查询（@media）和相对单位（如百分比、em等），可以实现响应式布局。 如何垂直居中一个元素？
答：可以使用flex布局或者绝对定位的方式来实现垂直居中，也可以使用表格布局或者CSS3的transform属性。 请解释一下CSS中的伪类和伪元素的区别？
答：伪类是用于向某些选择器添加特殊的效果，比如:hover、:active等，而伪元素则是创建一些不在文档树中的元素，比如::before、::after等。 什么是BFC（块级格式化上下文）？它有什么作用？
答：BFC是块级格式化上下文的缩写，它是页面上的一个独立容器，容器内部的元素不会影响到外部元素，可以避免外边距重叠等问题。 请描述一下CSS中的选择器优先级是如何计算的？
答：选择器优先级是通过计算选择器中ID选择器、类选择器、元素选择器和内联样式的数量来确定的，一般以四个值的形式表示。 介绍一下CSS中的动画和过渡的区别，以及它们的应用场景。
答：过渡是元素从一种状态变换到另一种状态时的平滑过渡效果，而动画则是元素具有连续的动作效果。通常过渡用于简单的交互效果，而动画适用于更复杂的动态效果。 什么是响应式图片？你会如何优化网站中的图片加载速度？
答：响应式图片是能够根据不同设备和屏幕尺寸自动调整大小的图片。优化图片加载速度的方法包括压缩图片、使用合适的图片格式、懒加载以及使用CDN等。 请解释一下CSS中的“box-sizing”属性的作用？
答：box-sizing属性用于指定元素的盒模型是标准盒模型还是IE盒模型，默认值为content-box，可以设置为border-box以方便计算元素的尺寸。 如何实现一个简单的CSS网格系统？
答：可以使用flexbox布局或者CSS Grid布局来实现简单的网格系统，也可以借助float和clear属性来实现。 什么是CSS预处理器？请举例说明它的优点和常用的预处理器有哪些？
答：CSS预处理器是一种将类似于编程语言的结构引入CSS中的工具，比如Sass、Less等，可以让开发者编写更加简洁、易于维护的CSS代码。 什么是CSS Sprites？它们有什么优点和缺点？
答：CSS Sprites是一种将网页中多个图片合并成一张图片，并通过background-position来显示不同部分的技术，可以减少HTTP请求，但维护成本较高。 如何实现一个元素的圆角边框？
答：可以使用border-radius属性来设置元素的圆角边框，也可以利用图片或者伪元素来实现。 请解释一下CSS中的“display: none”与“visibility: hidden”的区别？
答：display: none会使元素完全从页面中移除，占用的空间也会消失，而visibility: hidden则只是将元素隐藏，但保留其占用的空间。 什么是响应式字体？如何实现在不同设备上的字体大小适配？
答：响应式字体是指能够根据设备不同的尺寸和分辨率自动调整大小的字体。可以使用相对单位（如em、rem）或者媒体查询来实现字体大小的适配。 介绍一下CSS中的字体排版相关的属性，比如“line-height”、“letter-spacing”等。
答：line-height用于设置行高，letter-spacing用于设置字符之间的间距，还有text-align、text-transform等属性用于控制文本的对齐和大小写转换。 请描述一下“CSS reset”和“normalize.css”的作用和区别？
答：CSS reset用于重置浏览器默认样式，而normalize.css则是在保留有用的默认样式的基础上，校正浏览器样式的不一致性。 如何实现一个简单的CSS动态效果，比如鼠标悬停时的元素变化？
答：可以使用:hover伪类来实现鼠标悬停时的元素变化，也可以使用transition或者动画来实现更复杂的动态效果。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29d9d4d45c4c4ff833bfa4b4beac77d/" rel="bookmark">
			union和union all
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT语句：用于从数据库中检索数据的关键字。
UNION操作符：用于合并两个或多个SELECT语句的结果集，同时去除重复的数据。
UNION ALL操作符：用于合并两个或多个SELECT语句的结果集，不去除重复的数据。
SELECT count(*)FROM (
SELECT NO FROM a001 UNION SELECT no from b001
UNION SELECT no from c001)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f6fd4434c32dc36085a339f9ba3753e/" rel="bookmark">
			mysql存储过程 REPEAT 嵌套循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1:业务需求 最近有业务需求，存储过程内，实现二次循环的场景：首先对每个站点循环，然后对每个站点的业务进行二次循环。
也就是循环内嵌套循环。
2：存储过程实现嵌套循环 关于 mysql 存储过程内循环如何嵌套循环，也是在博主历经一番研究后，终于搞出来了，废话不多说，上干货。
博主是用的REPEAT +while实现的嵌套循环，说实话，mysql存储过程这个功能有待完善。
废话不多说，看代码：
CREATE DEFINER=`root`@`%` PROCEDURE `A`(dateTime varchar(100)) BEGIN -- 参数 dateTime （格式 yyyy-MM） DECLARE done BOOLEAN DEFAULT FALSE; DECLARE edone BOOLEAN DEFAULT FALSE; DECLARE v_deptId varchar(64); DECLARE v_centerCode varchar(64); DECLARE v_centerName varchar(64); DECLARE v_dictLabel varchar(64); DECLARE v_dictValue varchar(64); DECLARE in_Num BIGINT(12); DECLARE insideInfo CURSOR FOR select dict_label,dict_value from 表A a where dict_type='other_item' and status='0'; DECLARE dayInfo CURSOR FOR select sd.dept_id,sd.center_code,bc.center_name from 表B where sd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f6fd4434c32dc36085a339f9ba3753e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a2ad27f482a7b0360441ee671ad4c3/" rel="bookmark">
			K8S kubectl 常用命令 ， 升级回滚, 弹性伸缩 操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 应用升级nginx到1.15
kubectl -n NAMESPACE set image deployment DEPLOYNAME nginx=nginx:1.15
# 查看升级状态
kubectl -n NAMESPACE rollout status deployment DEPLOYNAME # 查看历史版本
kubectl -n NAMESPACE rollout history deployment DEPLOYNAME # 回滚，还原到上一个版本
kubectl -n NAMESPACE rollout undo deployment DEPLOYNAME # 回滚到指定版本
kubectl -n NAMESPACE rollout undo deployment DEPLOYNAME --to-revision=172
# 2 表示版本？
# 弹性伸缩
kubectl -n NAMESPACE scale deployment DEPLOYNAME --replicas=2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee1c6970f34442341cf151fb280e9bc/" rel="bookmark">
			若依分离版——定时调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时调度操作简单，只需在已有的service方法添加component，并在定时任务中添加任务即可。
一、在已有service类上加上@Component("TestTask")
@Component("TestTask") //定时调度任务 public class SysTestServiceImpl implements ISysTestService { public int updateTestData(){ System.out.println("测试定时任务---")； } }
二、在系统检控的定时任务新增任务
1 . 调用方法添加TestTask.updateTestData，即上面的component和方法
2. cron表达式选择：常用的corn表达式
每隔5秒执行一次：*/5 * * * * ?
每隔1分钟执行一次：0 */1 * * * ?
每天23点执行一次：0 0 23 * * ?
每天凌晨1点执行一次：0 0 1 * * ?
每月1号凌晨1点执行一次：0 0 1 1 * ?
每月最后一天23点执行一次：0 0 23 L * ?
每周星期天凌晨1点实行一次：0 0 1 ? * L
在26分、29分、33分执行一次：0 26,29,33 * * * ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ee1c6970f34442341cf151fb280e9bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18dc61c9efe2aecce9a6a653118ea399/" rel="bookmark">
			win10安装spark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、进入spark下载页面 连接 Downloads | Apache Spark
二、解压下载后的.tgz文件 直接解压即可
三、运行 运行bin目录下的 spark-shell.cmd
提示 Did not find winutils.exe: java.io.FileNotFoundException: java.io.FileNotFoundException: HADOOP_HOME and hadoop.home.dir are unset
解决办法
【精选】spark环境搭建window篇_windows spark_邱可爱的博客-CSDN博客
还有问题可以见第六点
四、运行成功 五、winutils.exe 新版本hadoop没有的原因 winutils.exe 新版本hadoop没有了_mob649e81624618的技术博客_51CTO博客
六、错误解决 执行 hadoop fs -ls
报错
java.lang.UnsatisfiedLinkError: org.apache.hadoop.io.nativeio.NativeIO$POSIX.stat(Ljava/lang/String;)Lorg/apache/hadoop/io/nativeio/NativeIO$POSIX$Stat;
解决办法
https://blog.csdn.net/sx157559322/article/details/115339328
替换 hadoop bin目录下的 hadoop.dll、winutils文件 和 windows/system32 下的 hadoop.dll、winutils文件 说明不能只替换第三点中的 hadoop bin目录下的 hadoop.dll、winutils文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8179e6de35468811053fc93acbf9d8db/" rel="bookmark">
			Vue3 &#43; Vite &#43; Pinia创建单页面应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://labs.pineview.io/learn-how-to-build-test-and-deploy-a-single-page-app-with-vue-3-vite-and-pinia/[1]
作者：Andrei Rusu[2]
正文从这开始~
介绍 诞生于2014年的Vue.js，无疑是目前领先的前端框架之一，随着社区的发展以及生态系统的壮大，在相当一段时间内，它的低位都是稳固的。几年前我曾在个别项目中使用过Vue 2，那是一种令人愉快的体验。
我觉得是时候把我的工具集升级到最新版本了。与此同时，也要升级诸如Vite和Pinia的新型工具。
本篇指南将涵盖详尽的步骤，使用Vue 3来创建一个功能性的书店SPA实例，并使用Vite来运行它。它还包括如何使用Pinia（Vuex的后继者）添加状态管理，以及如何使用Vue Router进行路由管理的细节。
将涵盖的核心概念有：
使用Vite创建Vue 3单页应用(SPA)
使用Vue Router管理路由
使用Pinia管理应用状态
使用VIte运行、构建、发布应用
编写、运行Vue组件单元测试
使用Nightwatch.js编写、运行自动化的端到端测试
这似乎看起来有很多内容，但我认为完全有可能在20分钟内完成所有。上面列出的一些概念可以扩展成单独的完整教程，但这里我只涵盖了启动和运行项目所必需的内容。
最后需要提到的是，本教程不涉及到后端。尽管数据是使用浏览器的Fetch API（XHR的后继者）加载的，但本身是没有服务端组件的。也就是说，可以很容易地添加一个后端组件。
总体而言，我们即将在这里构建的应用程序可以作为一个静态网站部署。如果你渴望马上开始编程，并立刻投入其中，你可以直接使用以下方法来启动和运行该项目：
git clone &lt;https://github.com/beatfactor/middlemarch&gt; npm install npm run dev 或者在Github上fork本项目： https://github.com/beatfactor/middlemarch[3]
步骤一：使用create-vite脚手架工具设置应用程序 我们将要使用官方脚手架工具create-vite来设置项目架构，因此你要确保已经安装了Node 12+与NPM 6+。脚手架工具也支持Yarn和PNPM作为包管理器，但这里我们只涉及NPM。
create-vite会为你创建项目文件夹，所以首先要确保使用cd命令进入到符父文件夹：
cd /workspace 使用以下命令安装Vite并初始化项目：
$ npm init vite@latest 然后你会被提示输入项目名称并选择你想要使用的库。我们从列表中选择vue：
~/workspace % npm init vite@latest npx: installed 6 in 1.051s ✔ Project name: … vue-bookstore ? Select a framework: › - Use arrow-keys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8179e6de35468811053fc93acbf9d8db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97283e038c980be737b6a997687c9528/" rel="bookmark">
			.Net8顶级性能优化:类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言
.Net8通过各种骚操，把性能提升到了前所未有的高度。超越以往任何版本，也涵盖了后续版本，比如.NET9或许可能没有如此大的性能优化了。本篇来看下它其中的一个优化:类型转换的优化效果。
2.示例
通过类型检查的优化，优化掉某些情况下类型转换的时候JIT类型检查的函数。下面的代码是类型检查的典型应用。
[HideColumns("Error", "StdDev", "Median", "RatioSD")] [DisassemblyDiagnoser(maxDepth: 0)] public class Tests { private readonly string[] _strings = new string[1]; [Benchmark] public string Get1() =&gt; _strings[0]; [Benchmark] public string Get2() =&gt; Volatile.Read(ref _strings[0]); } public partial class Program { static void Main(string[] args) { BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); } } 我们看到_strings是个私有数组，Get1函数中获取_strings数组的第一个值。所以它是直接用ldelem.ref IL执行即可
ldelem.ref 但是Get2里面对数组元素进行了引用，所以Roslyn的指令是:
ldelema [System.Runtime]System.String 如果ref类型的变量，被赋值为不同于这个变量的类型则会违反类型安全性。通常情况下ldelema需要进行类型检查，也就是用JIT辅助函数CORINFO_HELP_LDELEMA_REF来进行检查，以确保不会违反类型安全性。
这个安全性的检查会极大损耗性能，.NET8的JIT进行了一个优化，思路是如果是sealed关键字标记的类型，就不会进行安全性检查，这样就会提高性能。为什么sealed不会呢？
这其实是利用了它的一个特性，就是不会被继承。不会被继承，就不会被子类的类型所困扰，只有string一个类型，自然不会用以进行类型检查了。
这是第一点优化,下面看下。
3.第一阶优化
优化了类型安全检查，缩短了编译时间，提高了性能。
来看下.Net7和.NET8的生成Get2函数的的不同点
.Net7:
Tests.Get2() sub rsp,28 mov rcx,[rcx+8] xor edx,edx mov r8,offset MT_System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97283e038c980be737b6a997687c9528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7300306cecf1a00b83549da665805d0d/" rel="bookmark">
			【鸿蒙软件开发】ArkUI容器组件之Grid(网格布局)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Grid1.1 子组件GridItem是什么子组件接口属性事件示例代码 1.2 接口参数 1.3 属性1.4 Grid的几种布局模式1.5 GridDirection枚举说明1.6事件ItemDragInfo对象说明 1.7 示例代码 总结 前言 Grid容器组件：网格容器，由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。
一、Grid 网格容器，由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。
说明
该组件从API Version 7开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。
1.1 子组件 包含GridItem子组件。
说明
Grid子组件的索引值计算规则：
按子组件的顺序依次递增。
if/else语句中，只有条件成立分支内的子组件会参与索引值计算，条件不成立分支内的子组件不计算索引值。
ForEach/LazyForEach语句中，会计算展开所有子节点索引值。
if/else/ForEach/LazyForEach发生变化以后，会更新子节点索引值。
Grid子组件的visibility属性设置为Hidden或None时依然会计算索引值。
Grid子组件的visibility属性设置为None时不显示，但依然会占用子组件对应的网格。
Grid子组件设置position属性，会占用子组件对应的网格，子组件将显示在相对Grid左上角偏移position的位置。该子组件不会随其对应网格滚动，在对应网格滑出Grid显示范围外后不显示。
GridItem是什么 网格容器中单项内容容器。
说明
该组件从API Version 7开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。
子组件 可以包含子组件。
接口 使用下面这个即可创建一个GridItem了，他没有参数
GridItem() 属性 名称: rowStart
参数类型: number
描述: 指定当前元素的起始行号。
名称: rowEnd
参数类型: number
描述: 指定当前元素的终点行号。
名称: columnStart
参数类型: number
描述: 指定当前元素的起始列号。
名称: columnEnd
参数类型: number
描述: 指定当前元素的终点列号。
名称: forceRebuild (已废弃)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7300306cecf1a00b83549da665805d0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fadbda010cf34320c82036d1fc89b4/" rel="bookmark">
			pytorch_神经网络构建5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 生成对抗网络自动编码器变分自动编码器重参数GANS自动编码器变分自动编码器gans网络Least Squares GANDeep Convolutional GANs 生成对抗网络 这起源于一种思想,假如有一个生成器,从原始图片那里学习东西,一个判别器来判别图片是真实的还是生成的,
假如生成的东西能以假乱真,那么生成器就出师了,我们就可以用生成器生成各种各样的东西了
自动编码器 最开始的构想比较简单,原始图像-&gt;编码器-&gt;编码数据-&gt;解码器-&gt;解码的图像,人们企图使用这个思想模型得到预想的解码器
后来发现如果要生成任意图像还是需要预先知道一张图像的隐藏向量信息,解码器才能画出有用的图像,这太扯了
变分自动编码器 思想是,强制编码器输出粗略符合正态分布的数据,给解码器解码
这样我们随机给出标准正态分布的隐含向量,解码器都可以生成图像
然而实际上,原始的图片经过encoder编码后得到的并不是标准正态分布,它和标准正态分布之间的差异loss可以表示为:
KL divergence
重参数 对于变分自动编码器为了避免计算如此复杂的积分,往往采用重参数技巧
含义是:
让编码器不是生成一个隐含向量,而是生成两个向量,分别为均值,标准差
虽然编码器生成的正态分布不一定符合标准正态分布,但是我们可以利用其生成的均值和标准差合成一个标准正态分布
标准正态分布*标准差+均值,得到新的标准正态分布,希望均值为0,方差为1
这样我们随机输入一个标准正态分布,就可以经过解码器得到一张图像
后来人们发现这样也存在问题
无论是自动编码器还是变分自动编码器,训练时计算的loss都是输入和输出像素点之间的误差,实际上即使是相似的像素点视觉效果也不同,需要一种新的方式来计算输入和输出图像是否相同,那么能够不单独比较像素差,而是使用神经网络判断两个图片是否相同呢?
后来有人提出了gans
GANS 真实图像和生成器生成的噪声图像被送入判别网络,随着判别网络的判别结果,对生成器生成参数进行优化,直至生成器生成的图像以假乱真
判别器网络只负责判别真假,0,1
生成器网络相对复杂,它先生成一个高维正态分布噪声向量,然后经过xw+b映射到更高纬度排列成一个矩阵,使其符合图片格式,然后进行卷积,转置卷积,池化,激活函数等等,生成一张假图片送去鉴别,鉴别失败后继续更新生成参数
这个过程中判别器参数不会更新,因为这可能导致生成器无论生成什么图片都无法骗过鉴别器,直到生成器参数优化完毕,以假乱真
接下来依次实践这些编码器查看其实际效果如何
自动编码器 它的构成虽然简单,却是所有编码器的起始部分
接下来我们需要将一些图片的数据预先标准化,然后将其送入多层神经网络中训练,然后查看生成效果
图片数据集数据标准化
# 使用内置函数下载 mnist 数据集 train_set = mnist.MNIST('./data', train=True, download=False) test_set = mnist.MNIST('./data', train=False, download=False) im_tfs = tfs.Compose([ tfs.ToTensor(), tfs.Normalize([0.5], [0.5]) # 标准化 ]) def data_tf(x): x = np.array(x, dtype='float32') / 255 x = (x - 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80fadbda010cf34320c82036d1fc89b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7038efe7251c88456d6e925a4f3abbe/" rel="bookmark">
			OpenGL绘制地球仪（包含环境配置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenGL绘制地球仪 文章目录 OpenGL绘制地球仪环境配置glut配置glaux环境配置源码Main.cppMyTexMgr.hMyTexMgr.cpp 资料下载 环境配置 使用软件：visual studio 2019
glut配置 新建一新项目（控制台应用）点击项目/管理NuGet程序包
搜索nupengl，安装，至此glut配置完成
glaux环境配置 可以自行下载glaux，也可以在文章底部链接下载
glaux.dll放置在
C:\Windows\SysWOW64（64位）
C:\Windows\System32（32位）
glaux.h放置在
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include
在此目录下新建一GL文件夹，将glaux.h放进去
glaux.lib放置在
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\lib\x86
ps:位置可能不一致，但大体相同
源码 Main.cpp #include "MyTexMgr.h" #include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;vector&gt; #include "MyTexMgr.h" #include &lt;GL/glut.h&gt; #define GLUT_WHEEL_UP 3 //定义滚轮操作 #define GLUT_WHEEL_DOWN 4 using namespace std; static float _angle = 30.0f; static float _cameraAngle = 0.0f; static int oldX; static int oldY; static int X = 400; static int Y = 240; static int flag = 33; static float _rotX=0; static float _rotY=0; static float xyz[3]={1,1,1}; static float r=200; static GLUquadric*	_earth; static MyTexMgr	_texLoader; //键盘操作 void handleKeypress(unsigned char key, int x, int y) { switch (key) { case 27: //Escape key exit(0);break; //按键+为我旋转加速 case '+': flag -= 3; break; //按键+为我旋转减速 case '-': flag += 3; break; case 'w': Y += 20; break; case 'a': X -= 20; break; case 's': Y -= 20; break; case 'd': X += 20; break; } } //光照 void initLight() { GLfloat	position[] = { -1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7038efe7251c88456d6e925a4f3abbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d3f97bffe03061a222561d6b0b4de7/" rel="bookmark">
			Ubuntu16.03配置、安装及运行ORB-SLAM3(含遇到的坑与注意事项)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORBSLAM3 实验环境下载依赖2.1 源码下载1、orbslam3源码下载2、Pangolin3、Eigen34、其他依赖 2.2 Eigen 3安装2.3 Pangolin安装2.4 opencv安装2.5 DBoW2 and g2o2.6 安装boost库2.7 安装libssl-dev 编译与运行编译运行1、数据集2、复制运行脚本 注意1、未出现界面2、卡在一开始出不来 结语 实验环境 本文配置、安装与运行ORB-SLAM3于2023.3.25，撰写于2023.3.26，仅根据安装的history查看所有步骤以记录成该文。
我采用的是Ubuntu16.04双系统进行实现，其中ORB-SLAM3源码： ORB-SLAM3 ，我下的这个。
当然可以下带注释的 ORB-SLAM3
下载依赖 2.1 源码下载 最创建个文件夹，把待会要下载的东西都到这个文件夹下。
1、orbslam3源码下载 打开终端，输入下面这个指令
git clone https://github.com/UZ-SLAMLab/ORB_SLAM3.git 如果 git 拒绝连接可以直接去网址下载解压ORB_SLAM3
当然我基本都是用的指令git，除了eigen，下面有详细介绍。
注意，如果是新系统，没有安装git，则需要先装git
sudo apt-get install git 另外，如果是新系统的话，预装的vi编辑器不完整，用不了。
执行如下命令安装vi编辑器。
sudo apt-get remove vim-common sudo apt-get install vim 提前装cmake
sudo apt-get install cmake 2、Pangolin git clone https://github.com/stevenlovegrove/Pangolin.git 或者去这个网址下载压缩包Pangolin
但是我用的这个pangonlin
git clone https://github.com/zzx2GH/Pangolin.git 3、Eigen3 git clone https://github.com/eigenteam/eigen-git-mirror 4、其他依赖 sudo apt install gcc sudo apt install build-essential sudo apt-get install build-essential libgl1-mesa-dev sudo apt-get install freeglut3-dev sudo apt-get install libglew-dev libsdl2-dev libsdl2-image-dev libglm-dev libfreetype6-dev 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73d3f97bffe03061a222561d6b0b4de7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/891f5dbe52d80031c666b72dcceb5a1b/" rel="bookmark">
			Single Image Haze Removal Using Dark Channel Prior(暗通道先验)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去雾算法都会依赖于很强的先验以及假设，并结合相应的物理模型，完成去雾过程。本文作者何凯明及其团队通过大量的无雾图像和有雾图像，归纳总结出无雾图像在其对应的暗通道图像上具有极低的强度值（趋近于0），并结合如下公式：
求出透射率参数以及全球大气光值，进而轻松的求取无雾图像J。
1、暗通道先验是什么？ 暗通道先验是基于户外的的无雾图像总结归纳的，发现的一个普遍存在的现象就是：在大多数的非天空的图像块中，至少有一个图像通道的一些像素值是非常低且接近于0的。作者使用J_dark来表示暗通道图像，具体的计算公式如下所示：
上述公式可以知道，对于无雾图像y，求取其三通道对应像素为的最小值，并使用一个固定大小（15*15）的块去取其中最小的值即为当前像素的暗通道值。
下图很明显的展示了有雾与无雾图像的暗通道图像的差异：对于有雾图像（不考虑天空），暗通道图像偏白，也就是其强度值比较高，而对于无雾图像，暗通道图像整体偏黑，也就是其强度值比较低。
按照暗通道的定义就可以很清楚的知道：
上述公式就是本文的精髓暗通道先验，就是这么一个普普通通的经验总结，但是没有人想到。
作者在发现这个先验以后，还去做了很多的验证工作，其中就包括：
（1）随机选取5000张landscape+cityscape场景的数据，在剪裁掉天空部分后，resize到最长边为500的图像，使用15*15的核区域去计算暗通道图像，统计其强度概率分布图、累积概率强度分布图、图像的强度分布图
得出的结论是：
1、We can see that about 75 percent of the pixels in the dark channels have zero values, and the intensity of 90 percent of the pixels is below 25
2、most dark channels have very low average intensity, showing that only a small portion of outdoor haze-free images deviate from our prior
2、使用暗通道先验进行去雾 2.1 估计透射参数t 假设全球大气光值A是一个常量，利用公式（1）进行归一化操作可得：
接着假设t在一个固定大小的块中是恒定值，并且在公式（7）的两边同时求取暗通道值：
对于无雾图像来说J趋近于0的：
因此可以得出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/891f5dbe52d80031c666b72dcceb5a1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d96b71501f455c3861c6bf5e2596e315/" rel="bookmark">
			《现代C&#43;&#43;语言核心特性解析》笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新基础类型（C++11～C++20） C++基础类型回顾一览表
1. 整数类型 long long 我们知道long通常表示一个32位整型，而long long则是用来表示一个64位的整型。不得不说，这种命名方式简单粗暴。不仅写法冗余，而且表达的含义也并不清晰。如果按照这个命名规则，那么128位整型就该被命名为long long long了。但是不管怎么样，long long既然已经加入了 C++ 11 的标准，那么我们能做的就是适应它，并且希望不会有long long long这种类型的诞生。
C++标准中定义，long long是一个至少为64位的整数类型。请注意这里的用词“至少”，也就说 long long 的实际长度可能大于64位。
另外，long long 是一个有符号类型，对应的无符号类型为 unsigned long long，当然读者可能看到过诸如 long long int、unsigned long long int等类型，实际上它们和long long、unsigned long long具有相同的含义。C++标准还为其定义LL和ULL作为这两种类型的字面量后缀，所以在初始化long long类型变量的时候可以这么写：
long long x = 65536LL; 当然，这里可以忽略LL这个字面量后缀，直接写成下面的形式也可以达到同样的效果：
long long x = 65536; 要强调的是，字面量后缀并不是没有意义的，在某些场合下我们必须用到它才能让代码的逻辑正确，比如下面的代码：
long long x1 = 65536 &lt;&lt; 16; // 计算得到的 x1 值为 0 std::cout &lt;&lt; "x1 = " &lt;&lt; x1 &lt;&lt; std::endl; long long x2 = 65536LL &lt;&lt; 16; // 计算得到的 x2 值为 4294967296（0x100000000） std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d96b71501f455c3861c6bf5e2596e315/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/765bc21e37198eb6fc40127b6859105e/" rel="bookmark">
			win11系统完全卸载Oracle11g图文详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完全卸载Oracle11g图文详细步骤
卸载步骤：
1.停用Oracle服务
2.卸载Oracle产品
3.删除注册表
4.删除环境变量
5.删除安装文件
6.重启电脑
文章目录 1. 停用Oracle服务2. 卸载Oracle产品3. 删除注册表4. 删除环境变量5. 删除安装文件6. 重启电脑扩展了解一下 Oracle相关服务了解Oracle体系结构 1. 停用Oracle服务 按win+r，在【运行】框中输入services.msc命令，出现服务列表，停用Oracle服务
2. 卸载Oracle产品 1.在开始菜单–&gt;所有应用—&gt;Oracle - OraDb11g_home1文件夹中，找到Universal Installer，单击卸载产品。
2.之后进入卸载界面，点击【卸载产品】，点击 全部展开勾选所有，点击删除按钮
弹出警告：进入所指文件目录下找到deinstall.bat ，双击运行该文件 4.如下图出现 指定要取消配置的所有单实例监听程序 [LISTENER]，这里输入[ ] 中提示的内容LISTENER，然后按回车
5.如下图出现 指定在此 Oracle 主目录中配置的数据库名的列表[MYDATABASE]，输入[ ]括号里面的内容，然后回车
​ 这里回车后要有耐心等一下
如下图 出现 指定此数据库 (1. 单实例数据库|2. 启用 Oracle Restart 的数据库) 的类型 [1]: 输入1，直接回车 如图出现 指定数据库的诊断目标位置 [ E:\app\Administrator\diag\rdbms\mydatabase]: 如图输入[ ]中括号里面的路径后回车 如图出现 **指定数据库 ASM|FS 使用的存储类型 [ ]：**这里输入FS，然后回车 如图 出现 如果有任何数据库文件存在于共享文件系统上, 请指定目录的列表。如果找到了 ‘MYDATABASE’ 子目录, 则将删除该子目录。否则将删除指定的目录。此外, 可以指定带有完整路径的数据库文件的列表 [ ]: 直接按回车 如图出现 如果在文件系统上配置了快速恢复区, 请指定其位置。如果找到了 ‘MYDATABASE’ 子目录, 则将删除该子目录。 []: 直接按回车 如图 出现 指定数据库 spfile 位置 [ ]: 直接回车 等待一下 如图出现 是否继续 (y - 是, n - 否)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/765bc21e37198eb6fc40127b6859105e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6bc7053241d148fd7d5d0bf7f4853d7/" rel="bookmark">
			R语言零基础基因/数据差异分析（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 介绍环境搭建软件下载 结果展示基因数据下载流程基因数据处理 利用GEO分析绘制拟火山图 注意，本 系列 有连贯性，每一步都很详细，每一步都很重要，请耐心读完！！ 如果你出现了其他错误，或有疑问，请在评论区留言。最好不要私信发送，消息经常被屏蔽。
介绍 本系列文主要依据真实论文制图流程，详细说明制图过程， 其中包括： 1. 基因数据下载 2. 制图所需数据格式 3. 火山图制作流程 4. 聚类热图制作流程 环境搭建 软件下载 移步至此学习
结果展示 基因数据处理
注意删除末行注释
基因数据下载流程 以GSE137578基因为例，先下载 如图所示文件，并解压如图。
1.
2.
3.新建一个excel,并将解压好的文本拖进去。
4.注意，打开后，此时我们需要对数据进行处理。
基因数据处理 1. 在以 ！开头的行，均是**注释行**，要全部删除，如图示， 2. 删除方法：选择好区域后，右键，删除整行即可 删除之后：
注意，尾部图片选择的整行都要删除：
删除尾部结果：
对于上述数据，我们所需要数据结构模样如上。
注意，我们上述下载的是基因实验数据，它用于绘制热图，这在第三章会详细说明，这里点击另存CSV即可。
利用GEO分析绘制拟火山图 1.点击分析
2. 如图步骤，
1.按住 Shift 选择组别，
2.标记组别
3.如此选择完你的组别
3. 进行分析
4.注意下面我们要绘制的火山图模样，我们点击下载表格即可
4. 文件格式是 tsv，我们利用excel打开，注意，在绘制热图时，我们需要它，所以，请进行备份！
5. 在这里，我们只保留以下列，注意记住以下列的名字，这非常重要，它将决定代码是否成功运行！
保留的列头行名：
GB_ACC（这是基因名，每个文件有所不同，按己索需）P.Value（这里改名为FDR）logFCadj.P.Val
你只要记住你要保留的每行头个单元名称即可，至于是什么，自己可决定。
我们如下整理，请将非数据列放到开头。
注意名称和另存格式
之后，我们将利用此绘制火山图。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16ea05c5137ff255bb5fb6a42816e7b/" rel="bookmark">
			软件测试进阶篇----移动端测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、移动端测试概述 移动端测试不是一个新的领域，所采用的测试的理论、原则和方法、技术和之前web的是一样的。
移动端的手工测试，和web端的点点点是一样的。
移动端的自动化测试，python+appium+unittest/pytest+ddt+BeautifulReport/allure+git/gitee+jenkins
1、移动端设备 当前大部分移动端测试是属于嵌入式测试范畴的，包括移动端的应用（app，小程序）测试以及移动端设备测试
手机（手机终端测试）智能穿戴设备（手环、手表、眼镜、AR设备）车机交互、车载pad、扫地机器人 2、移动端操作系统（os） Androidios鸿蒙os4xiaomi澎湃os黑莓windows phone塞班4、5/米狗 3、移动端应用（app） 这个是软件测试工程师的主要测试对象，以Android为例：
原生app：以Android、iOS、鸿蒙提供的开发环境直接开发的app，数据处理能力比较强混合开发app：数据处理使用Android，页面展示用的H5技术（更好看）web app：纯H5技术开发的app小程序： 微信小程序：随用随装、不同卸载支付宝小程序今日头条小程序百度小程序 二、移动端测试的要点（重点） 1、安装和卸载测试 web端也是需要安装和卸载测试的：
测试环境下，可以根据用户安装手册完成一次部署上线之前的预发布环境中，要完整的执行一次安装过程（预演），上线安装就安全了。内存不足的时候有没有提示是否安装在了指定的文件夹下、是否有多余的文件夹生成在安装过程中有电话打入、短信、消息、闹钟等事件的中断服务器端的安装：金丝雀发布/灰度发布的方式客户端app的安装：（重点） Android： 通过各种渠道获取apk文件，即可安装 iOS： 安装包的后缀是ipa文件app已经获取到苹果发的企业证书，是可以随便装的**上线appstore，下载安装****在测试环境中，将iphone收集的udid编号，给开发，开发打包在app中，该iphone就可以安装了****testflight是苹果提供内测工具，开发组通过testflight给对应测试人员账号发邮件，获取验证码并下载安装** web端的系统卸载：
应用程序包（文件夹），直接删除即可对应的数据库也要手动卸载redis软件支持，也需要删除 移动端的app卸载：
直接卸载检查卸载是否完整、干净（不能有多余的文件夹、缓存数据） 2、UI测试点 在UI页面展示上的不合理的内容、测试点：
要检查页面上是否有错别字要检查页面布局风格：横向上风格要一致，按钮、标签、图片大小和样式要相同页面颜色不能三种以上比较艳丽的颜色文字不能超出所在标签的位置：文字超出文本框的范围，overlap标签与标签之间叠加在一起了，cutoff不允许出现违法、敏感的文字和图片中文字符的支持一些英文单词不能过度翻译：logo 3、app功能性测试（重点） app安装完成之后是否能正常启动app启动时的广告页显示是否正常、倒计时、跳过功能是否正常注册功能登录功能注销功能前后端切换app，检查是否可用 先正常使用app，切到后台，再从后台切回到前台先正常使用app，切到后台，锁屏，解开屏幕，再从后台切回到前台正常使用app，接电话，回来继续使用正常使用app，弹窗了，切回后台，再回来… 登录及免登录的测试数据更新软件更新相机、通讯录、录音机等功能的使用push消息通知测试交叉事件测试 打电话发短信发邮件闹钟 4、兼容性测试（重点） 做兼容性测试的目的是：app可以在不同的手机能正常使用（覆盖市场主流的50+手机以上）
1）需要兼容的要素
和软件的兼容和硬件的兼容 品牌（华为、小米、苹果等）屏幕大小不同：6.X网络制式os系统兼容 iOS：14、15、16等最新三个版本Android：13、14、15版本鸿蒙：1、2、3、4澎湃os：基于Android深度开发的 2）怎么做兼容性测试
兼容性测试一定要采用真实的设备进行测试。
公司没钱买：借手机没钱不想借：租手机，在线的云测平台（20+自备和50+平台租赁）。 testin腾讯wetest优测蒲公英 公司不差钱：买，买最新的（可以是二手的） 3）兼容性测试关注的三个主要问题
Exception：异常ANR：应用程序未响应Crash：崩溃、闪退 4）app专项测试数据（记住）
app耗电量测试app流量测试app内存占用app的cpu占用游戏app测试关注帧率电池温度测试 三、Android系统概述 1、Android系统架构 应用程序层：计算器、qq、微信、支付宝等，主要用的是Android、H5应用程序框架层：进行Android开发的支持的框架，java函数库层（c++、java）Linux内核层 进程调度（SCHED）内存管理（MM）虚拟文件系统（VFS）网络接口（NET）进行间通信（IPC） 2、Android app的四个组件 每一个Android的app都是由四部分组成的。
1）activity：活动
每个app的一屏内容就称之为活动，相当于web中的一个页面，负责页面展示效果
2）service：服务
在app第一次启动的时候启动起来，主要负责数据的处理
3）content-provide：内容提供者
Android系统中的一个数据中转站
4）broadcast receiver：广播接收器
消息推送到Android系统
四、移动端测试环境搭建 本章讲的是Android环境的搭建，实现对Android移动端app的手工测试环境和自动化测试环境。
jdk环境和环境变量配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d16ea05c5137ff255bb5fb6a42816e7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c0a404ef3341883735381333d56ac0/" rel="bookmark">
			使用layui实现模拟考试页面，完成做题，得分，错题详解等功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述与效果图 相信大家疫情期间都有线上考试的 经历，我自己对这个很感兴趣，就模拟考试做了一个页面
先给大家看看效果图吧
这是没有具体题目的一个模拟页面，有具体题目的页面在后面
下面这个是完整的换一种风格的模拟页面
话不多说，上代码 第一种的代码 一定要记得引入layui的相关库啊！！！！！
html及部分css &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;考核页面&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; font-family: 'Microsoft YaHei'; } html,body { width: 100%; height: 100%; } .testitem { width: 100%; height: 100%; } .theory { width: 100%; height: 100%; } .testitem-left { float: left; height: 100%; width: 75%; color:#000; } .testitem-right { float: right; width: 25%; height: 100%; background-color: #e9e9e9; position: relative; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05c0a404ef3341883735381333d56ac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93566451f48a2862bac78c69beb0e4e/" rel="bookmark">
			输入字符串，删除相同的字符。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;strings.h&gt;
int main()
{
char arr[32]={};
int i,j,k;
int n=strlen(arr);
printf("&gt;:");
gets(arr);
for(i=0;arr[i];i++)
{
for(j=i+1;arr[j];j++)
{
if(arr[i]==arr[j])
{
for(k=j;arr[k];k++)
{
arr[k]=arr[k+1];
}
j--;
}
}
}
puts(arr);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/687eb017c81d6261b7878c7282bcb832/" rel="bookmark">
			switch语句，三种循环的使用及深入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言的使用过程中，循环是极其重要的语法之一，下面我将依次讲解。
1.switch语句
首先，switch语句可以实现分支结构，用于判断结果。
switch（expression） { case value 1: case value 2: default: } 通常写出来的结构是这样的，通常会根据expression里面的值来选择我们所要进去的路线，例如（expression必须是整形表达式）expression如果输出的是value 1，那么他就会从value 1处进入，但需要注意的是如果没有用break跳出当前条件下所执行的语句的话，他将接着往下走，也就是会接着执行value 2的语句。当没有找到所对应的条件时，他就会进入default。再加一句，其中的顺序是没有要求的。
2.while，do-while和for循环
为了便于讲解，我在网上找了三张流程图
首先，while循环会进行初步的判断，在while循环后面打上一个（），这个括号里面就是所需要存放的判断条件，如果成立，则执行下面的语句，然后进行的二次判断，知道不成立为止。若循环的条件为非零的数均成立，若为零则不成立。
do-while循环就像他的意思一样，先进行一次条件的执行在进行循环，若不成立则跳出循环，成立则继续进行。
例如这样，他就会依次打印出1到10的数，要注意的是和另外两个循环不同的是，他所加入条件的小括号后面要加上一个分号!这个循环没有另外两个用的频繁。
最后是for循环
for循环是我们运用的最多的了，以一个立体来进行讲解
首先，for循环后面括号有两个分号将其隔开，第一个空间表示的是初始条件，第二个表示循环成立的条件，第三个表示循环条件成立后所要执行的语句，单循环成立时，他会先执行下面的语句，然后再执行小括号后面的三个位置的语句，然后重新进行判断，以此循环。
讲完了三个循环语句的语法，下面我将深入讲解一下循环的continue和break
3.continue和break
这两个关键词的用法是很简单的，continue就是继续循环，而break就是结束循环。在语句执行过程中如果碰到switch，那他将提前进行到下一次循环，从开头开始，而break就是直接结束循环。
4.循环的嵌套
循环时可以用在一起的，我们已打印九九乘法表为例。
首先，按列来讲，九九乘法表是从一到九依次往下排列，按照行来说，那就是小于等于当前的列数，那我们就可以按照此进行双重循环，首先列是从一到九，而在此循环中行是小于等于当前的列数，从一开始循环依次进行打印，最后将每一个式子打印出来，就构成九九乘法表啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ede0b2c01ab245eb32716754e814ef/" rel="bookmark">
			java学习-笔记（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
知识点一：公共字段填充
知识点二:ThreadLocal类
知识点三：Super关键字
知识点四：MultipartFile工具类
知识点五：Map的6种遍历方式
知识点六：JAVA的流式编程
知识点七：postMapping、putMapping、getMapping、deleteMapping 九月第二周的笔记（1）
知识点一：公共字段填充 问题1：在项目中新增员工时候需要设置创建时间，修改时间，修改人姓名等字段，在编辑员工时需要设置的字段，有的属于公共字段，能不能对公共字段在某一个地方进行统一处理，来简化开发，Mybatis Plus 提供了公共字段填充功能。
实现步骤
步骤1：在实体类的属性上加上@TableField注解，指定自动填充的策略
步骤2：按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要要实现MetaObjectHandler接口
@TableField(fill = FieldFill.INSERT):插入时填充字段
@TableField(fill = FieldFill.INSERT_UPDATE)：插入和更新时填充字段
知识点二:ThreadLocal类 问题2：在自动填充createUser和UpdateUser两个字段的时候设置的用户id是固定值，应该动态的获得当天用户固定的值
//这个类是不能获得HttpSession对象的
//客户端发送的每次HTTP请求，对应的在服务器端会分配一个新的线程来处理，在处理过程中设计到下面类中的方法都属于同一个线程
//LgoninCheckFilter的doFilter方法
//EmployeeController的update方法
//MyMetaObjectHandler的updateFill方法
//可以在上面的三个方法中分别加入下面的代码获取当前线程
1.什么是ThreadLocal类？
ThreadLocal并不是一个Thread,而是Thread的变量，当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本，ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取对应的值，线程外不能访问
2.ThreadLocal的常用方法
Public void set(T value) 设置当前线程的线程局部变量的值
Public T get() 返回当前线程所对应的线程局部变量的值
3.可以在LoginCheckFilter的doFilter方法中获取当前登录用户id,并调用ThreadLocal的set方法设置当前线程的局部变量的值（用户id)，然后在MyMetaObjectHandler的updateFill方法中调用ThreadLocal的get方法来获取当前线程所对应的线程局部变量的值（用户id)
4.具体实现方法
步骤1：编写BaseContext工具类，基于ThreadLocal封装的工具类
步骤2：在loginCheckFilter的doFiter方法中调用BaseContext来设置当前登录用户id
步骤3：在MyMetaObjectHandler类的方法中调用BaseContext获取用户登录的id
知识点三：Super关键字 可以引用父类中的成员：Super可以访问父类中定义的属性；super.xxxSuoer可以访问父类中定义的成员方法；super.xxx()Super可以在子类构造器中调用父类方法.super():无参构造方法；super(xxx)有参构造方注意事项：当子类和父类有相同的属性名时，在子类如果要使用父类的属性用super.Super只能应用到成员方法和构造方法中，不能 用在静态方法中如果在构造方法中使用必须放在第一行在构造方法中super()和this()不能同时出现 知识点四：MultipartFile工具类 String getName 返回参数名称
String getOriginalFilename 返回文件的内容类型
String getContentType
Byte[] getBytes[] throw IOException 将文件内容转换为一个byte[]数组
void transferTo(File var1) throws IOException, transferTo是复制file文件到指定位置(比如D盘下的某个位置),不然程序执行完,文件就会消失,程序运行时,临时存储在temp这个文件夹中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ede0b2c01ab245eb32716754e814ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96a611633cd4be209f4786ff2cae7198/" rel="bookmark">
			华为政企路由器产品集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 产品类型产品型号产品说明 maintainProductA821 E_2*10GE/GE/FE(o)+8*GE/FE(o)+8*GE/FE(e),1*交流电源华为企业云端NetEngine A800 E综合业务一体化接入路由器是华为公司面向云时代推出的一款产品，用于企业快速接入网络，具备易部署、易运维、高性能、高可靠等优势，可实现华为控制器iMaster NCE统一管控，同时支持FlexE切片、SRv6、IFIT、L2VPN、L3VPN、EVPN 、IPsec等丰富特性，满足企业快速、高质量上云需求。应用于数字政务、智慧教育、智慧医疗、智慧工厂、智慧矿山等企业多业务上云的城域网络边缘接入场景。maintainProductA821 E_2*10GE/GE/FE(o)+8*GE/FE(o)+8*GE/FE(e),1*交流电源,必配IPv6+功能许可证/年费华为企业云端NetEngine A800 E综合业务一体化接入路由器是华为公司面向云时代推出的一款产品，用于企业快速接入网络，具备易部署、易运维、高性能、高可靠等优势，可实现华为控制器iMaster NCE统一管控，同时支持FlexE切片、SRv6、IFIT、L2VPN、L3VPN、EVPN 、IPsec等丰富特性，满足企业快速、高质量上云需求。应用于数字政务、智慧教育、智慧医疗、智慧工厂、智慧矿山等企业多业务上云的城域网络边缘接入场景。maintainProductM1A _6*10GE+26*GE,1*交流电源,不含软件及资料-高防腐NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductM1A_16*10GE+16*GE,1*交流电源NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductM1A_16*10GE+16*GE,1*交流电源,不含软件及资料-高防腐NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductM1A_2*10GE+16*GE(o)+4*GE(e),1*交流电源NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductM1A_2*10GE+16*GE(o)+4*GE(e),1*交流电源,必配高级包/SRv6/分片/年费NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductM1A_6*10GE+26*GE,1*交流电源NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductM1C_16*10GE+12*GE,2*交流电源NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductM1C_2*10GE+16*GE(o)+4*GE(e),2*交流电源,含高级软件特性NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductM1C_2*10GE+16*GE(o)+4*GE(e),2*交流电源,必配高级包/SRv6/分片/年费NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductM1C_2*10GE+20*GE,2*交流电源NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductM1C_6*10GE+22*GE,2*交流电源NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductNetEngine 8000 M6_2块4万兆MACSEC单板_2块10千兆光单板NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductNetEngine 8000 M6_2块4万兆MACSEC单板_2块10千兆光单板NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。maintainProductNetEngine 8000 M6_2块4万兆MACSEC单板_2块8千兆电单板NetEngine 8000 系列路由器是华为推出的面向云时代的全业务智能路由器平台，超宽的管道打造极简的网络，领先的SR/SRv6使能智能连接，新一代的智慧大脑实现全生命周期自动化、引领主动运维。系列产品涵盖大型框式、紧凑插卡盒式和固定盒式设备，完全满足核心、汇聚、接入等不同的网络场景，具备高性能、高可靠、低功耗、可演进等特性，可应用于企业广域网核心节点、大型企业接入节点、DC互联、园区互联与汇聚节点和各种大型IDC网络出口。企业网关AR5710-H8T2TS1华为NetEngine AR5700系列企业路由器可以按需部署在中小型企业总部或分支，提供企业网络出口能力。该系列包括NetEngine AR5710-H8T2TS1，适配不同规模的企业业务组网需求。maintainProductAR611AR611 提供 WAN：1*GE Combo；LAN：4*GE 电 所有LAN口可切换为WAN，NetEngine AR610系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR611WAR611W 提供 WAN：1*GE Combo ，LAN：4*GE 电所有LAN口可切换为WAN，NetEngine AR610系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。企业网关AR611W-LTE4CNNetEngine AR610系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6121E_单块4GE Combo口插卡典型配置NetEngine AR6100系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6121E_单块8GE电口插卡典型配置NetEngine AR6100系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6121E_双空余扩展卡槽位典型配置NetEngine AR6100系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6140E_9G_2AC_单块4GE Combo口插卡典型配置NetEngine AR6100系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6140E_9G_2AC_单块8GE电口插卡典型配置NetEngine AR6100系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6140E_9G_2AC_无插卡典型配置NetEngine AR6100系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6280_SRU400H_单块8GE电口扩展卡典型配置NetEngine AR6200系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6280_SRU400H_单板_4GE Combo口典型配置NetEngine AR6200系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6280_SRU400H_无扩展板卡典型配置NetEngine AR6200系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6300_单SRU400H主控典型配置NetEngine AR6300系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6300_单SRU400H主控（支持SD-WAN）_无扩展板卡NetEngine AR6300系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR6300_双SRU400H主控（不支持SD-WAN）_无扩展板卡NetEngine AR6300系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全、语音等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。企业网关AR651WAR651W 提供 WAN：2 * GE Combo ，LAN：8*GE电，所有LAN口可切换为WAN；NetEngine AR650系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。maintainProductAR651W-8PAR651W-8P 提供 WAN：2 * GE Combo ；LAN：8*GE电；所有LAN口可切换为WAN。NetEngine AR650系列企业路由器是华为面向云化时代推出的首款企业级AR路由器，具备3倍业界转发性能，5G超宽上行，同时融合SD-WAN、云管理、VPN、 MPLS、安全等多种功能，帮助全球客户轻松应对企业上行流量激增和未来业务多元化发展。企业网关AR8140-12G10XG_4端口GE COMBO WANAR8140-12G10XG 提供 10*10GE光，8*GE Combo，4*GE电 ；所有WAN口可切换为LAN口。NetEngine AR8000系列企业路由器是华为面向云化时代推出的全新一代企业级AR路由器，基于ARM架构多核处理器和无阻塞交换架构，应用于SD-WAN解决方案场景，满足企业客户对网络设备高性能的需求，可广泛部署于大中型园区网出口、大中型企业总部或分支等场景。企业网关AR8140-12G10XG_8GE电口WAN典型配置AR8140-12G10XG 提供 10*10GE光，8*GE Combo，4*GE电 ；所有WAN口可切换为LAN口。NetEngine AR8000系列企业路由器是华为面向云化时代推出的全新一代企业级AR路由器，基于ARM架构多核处理器和无阻塞交换架构，应用于SD-WAN解决方案场景，满足企业客户对网络设备高性能的需求，可广泛部署于大中型园区网出口、大中型企业总部或分支等场景。企业网关AR8140-12G10XG_无扩展板卡典型配置AR8140-12G10XG 提供 10*10GE光，8*GE Combo，4*GE电 ；所有WAN口可切换为LAN口。NetEngine AR8000系列企业路由器是华为面向云化时代推出的全新一代企业级AR路由器，基于ARM架构多核处理器和无阻塞交换架构，应用于SD-WAN解决方案场景，满足企业客户对网络设备高性能的需求，可广泛部署于大中型园区网出口、大中型企业总部或分支等场景。物联网关AR502H-CNAR502H-CN 提供 3 * GE电10/100/1000Mbit/s自适应， 2 * GE combo；华为AR502H系列是新一代边缘计算物联网关，具备强大的边缘计算能力，开放软硬件资源，提供SDK实现计算、存储、网络资源灵活调用，支持容器管理，APP随需部署，广泛应用于各种物联网场景，如智慧用能，物联杆站，智能配电房，智慧园区、智慧水利等领域。物联网关AR502H-NR-CN AR502H-NR-CN 提供 3 * GE 电，10/100/1000Mbit/s 自适应 ；2 * GE combo ，华为AR502H系列是新一代边缘计算物联网关，具备强大的边缘计算能力，开放软硬件资源，提供SDK实现计算、存储、网络资源灵活调用，支持容器管理，APP随需部署，广泛应用于各种物联网场景，如智慧用能，物联杆站，智能配电房，智慧园区、智慧水利等领域。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3b37f432c51ce9e750c8b98fd2462e/" rel="bookmark">
			成功解决：ValueError: not enough values to unpack (expected 3, got 0)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在用yolov5训练自己的数据集时，在训练的时候出现了下列问题：
出错的代码行为：
labels, shapes, self.segments = zip(*cache.values())
发生在yolo5-5.0\utils\dataloaders.py的LoadImagesAndLabels类下的__init__方法中
class LoadImagesAndLabels(Dataset): # for training/testing 在网上找了很久，给出的建议大致分为以下几种：
1. data.ymal（训练集的图片和标签）的路径不对
2、图片， 标签 名称包含中文
3、你的标签文件的class分类是负数
4. 没有归一化
然后我进行了依次的检查，发现我的问题都不符合以上几类。
最后我的解决方法：
将data文件下的train.cache文件删除，然后再进行重新运行，最后程序就可以跑起来了。
train.cache是由DataSet API创建的，当DataSet API在读取预处理数据时，它会将处理后的数据缓存到train.cache文件中，以加速训练过程。也就是说train.cache作为一个缓存文件，用于存储训练过程中的中间结果，加速后续训练速度。每个epoch结束后，train.cache都会记录模型的参数和优化器状态，以及训练集和验证集损失等信息。下一次训练，train.chache文件存在，就可以直接加载其中的信息，避免重新计算，从而提高训练的效率。
总结一下我出现以上问题的原因：因为我先在程序上跑了coco的数据集，则有一个关于coco数据集的缓存，所以在换成我的数据集的时候，里面的缓存依然是coco的数据集信息，所以出现错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82226d16b33e5497dd529b81277a62d/" rel="bookmark">
			ViT模型中的tokens和patches概念辨析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念辨析 在ViT模型中，“tokens”（令牌）和"patches"（图像块）是两个相关但不同的概念。
令牌（Tokens）：在ViT中，令牌是指将输入图像分割成固定大小的图块，并将每个图块映射为一个向量表示。这些向量表示即为令牌。每个令牌代表图像中的一个局部区域，可以看作是图像的抽象表示。通过将图像分割成令牌序列，并将其输入到Transformer模型中，ViT能够利用自注意力机制来建模图像中的全局关系。
图像块（Patches）：图像块是指将输入图像分割成固定大小的小块。在ViT中，图像块被用作生成令牌的基本单位。每个图像块由一组像素组成，并通过线性变换映射为令牌的向量表示。图像块的目的是将图像分割为可处理的小块，以便进行后续的编码和处理。
因此，图像首先被分割为图像块（patches），然后每个图像块被映射为一个令牌（tokens）。令牌是对图像块的抽象表示，用于输入到Transformer模型中进行全局关系的建模。
对于标准的Transformer模块，要求输入的是token（向量）序列，即二维矩阵[num_token, token_dim]，如下图，token0-9对应的都是向量。
输入步骤 首先将一张图片按给定大小分成一堆Patches。以ViT-B/16为例，将输入图片大小(224x224)按照16x16大小的Patch进行划分，划分后会得到 ( 224 / 16 ) 2 = 196 ( 224 / 16 ) ^2=196 (224/16)2=196个Patches。通过线性映射将每个Patch映射到一维向量中，以ViT-B/16为例，每个Patche数据shape为[16, 16, 3]通过映射得到一个长度为768的向量（直接称为token） 总结起来，图像块是图像的原始分割块，而令牌是对图像块的向量表示，用于输入ViT模型进行处理。
参考：Vision Transformer详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c72ed273de92624e9b08ae732462727/" rel="bookmark">
			巴比特 | 每日必读：OpenAI 发布会内容再曝光：将推出 GPT-4 Turbo，具有 128K 的上下文长度...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：11 月 6 日，OpenAI 发布会内容再度曝光。根据爆料者信息，OpenAI 将推出 GPT-4 Turbo，具有 128K 的上下文长度，比 GPT-4 更强大，且价格更低；
李开复创建的 AI 公司“零一万物”正式发布 340 亿参数大模型“Yi”。此次 Yi 系列基础模型的首个公开版本包括两款：Yi-6B（数据参数量为 60 亿）、Yi-34 B（340 亿），均是双语（英文/中文）、支持开源。
图片来源：由无界AI生成
热点资讯
马斯克旗下 xAI 正式发布首个大模型产品“Grok”
巴比特讯，11 月 5 日，马斯克旗下 xAI 宣布正式发布其首个 AI 大模型产品“Grok”。据介绍，Grok 通过 X 平台实时了解世界，还能回答被大多数其他 AI 系统拒绝的棘手问题。xAI 团队表示，Grok 仿照《银河系漫游指南》而设计，可以回答几乎任何问题，甚至就如何提问给出建议。但 Grok 仍然是一个非常早期的测试产品，期望在用户的帮助下每周都能快速改进。
OpenAI 首届开发者大会爆料：将发布用于创建自定义聊天机器人的 Gizmo 工具
据机器之心 11 月 5 日报道，X（推特）用户 CHOI 爆料了 OpenAI 首届开发者大会的信息，他表示 OpenAI 将公布 ChatGPT 的重大更新，包括全新的界面以及一些新功能：自定义聊天机器人、与谷歌和微软的连接器以及新的订阅模式。除此之外，OpenAI 不太可能发布 GPT4-V API。
李开复 AI 公司“零一万物”估值超 10 亿美元，正式发布 340 亿参数大模型“Yi”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c72ed273de92624e9b08ae732462727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35acd44633b2720e0b8001e215d09514/" rel="bookmark">
			数据库索引一：PGSQL数据库查询索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询某个标下的索引：
select * from pg_indexes where tablename='ls_trs_tunnel_route';
查询数据库中全部索引：
SELECT tablename, indexname, indexdef
FROM pg_indexes
WHERE schemaname = 'public';
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a19b4aa435fe9aa9e9cfb222d08e9c/" rel="bookmark">
			nginx 1.9.9 Linux 环境安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、软件下载和安装Nginx相关依赖1. 安装Nginx相关依赖2. 下载Nginx 二、源码安装Nginx2.1. 解压2.2. nginx默认配置2.3. 编译安装2.3. 查找安装路径2.4.启动nginx2.5. 查看是否启动成功 一、软件下载和安装Nginx相关依赖 1. 安装Nginx相关依赖 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 2. 下载Nginx 官网:https://nginx.org/download/
wget https://nginx.org/download/nginx-1.9.9.tar.gz 二、源码安装Nginx 2.1. 解压 tar -zxvf nginx-1.9.9.tar.gz 2.2. nginx默认配置 cd nginx-1.9.9/ ./configure --prefix=/usr/local/nginx --with-stream 2.3. 编译安装 make make install 2.3. 查找安装路径 whereis nginx [root@bogon nginx-1.9.9]# whereis nginx
nginx: /usr/local/nginx
2.4.启动nginx cd /usr/local/nginx/sbin ./nginx 2.5. 查看是否启动成功 ps -ef | grep nginx 然后在网页上访问自己的IP就可以了默认端口为80（出现如下欢迎界面就成功了！）
遇到make[1]: *** [objs/Makefile:445: objs/src/core/ngx_murmurhash.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7a19b4aa435fe9aa9e9cfb222d08e9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2cd6bad6d6f17d8f7507339ed15713c/" rel="bookmark">
			java依赖的jar包下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不需要依赖maven，直接下载jar。
仓库服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4b12547e419a6fb25809e7155ab629/" rel="bookmark">
			redis之缓存击穿、雪崩、穿透(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.缓存穿透 概念： 去查询缓存和数据库都不存在的数据，然后大量请求不存在的数据，导致数据库压力过大崩溃。
解决方案： 把不存在的数据null存入缓存，并给个短期的过期时间。
二.缓存雪崩 概念： 缓存采用相同的过期时间，然后在某一时刻会同时过期，然后请求全部访问数据库，导致数据库崩溃。
解决方案： 把过期时间随机。
三.缓存击穿 概念： 某个会过期的缓存会被大量请求访问，然后在失效的一刻，大量请求访问数据库，导致数据库崩溃。
解决方案： 加锁，大量请求，先让一个请求去查询数据库，然后存在缓存，其余请求都去查询缓存。
加锁：
//1.只要是同一把锁，就能锁住需要这个锁的线程。 //因为springboot是单例的，又因为this代表当前对象，所以可以锁住访问的所有线程 synchronized(this){ //(1) 首先去缓存查询是否存在缓存，存在就不用去查询数据库。 //(2) 不存在去查询数据库并且放在缓存里面。 //注意：要把(1) 和 (2) 都放在锁里面操作。不然会出现锁的时序问题。 } //2.在方法上直接加synchronized也行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/692376d64cca0bffc2e6b108d3955d0f/" rel="bookmark">
			可变参数模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. sizeof...计算参数个数
template&lt;typename... Ts&gt; void magic(Ts... args) { std::cout &lt;&lt; sizeof...(args) &lt;&lt; std::endl; } 2.递归模板函数
template&lt;typename T&gt; void printf1(T value) { std::cout &lt;&lt; value &lt;&lt; std::endl; } template&lt;typename T, typename... Ts&gt; void printf1(T value, Ts... args) { std::cout &lt;&lt;"剩余参数:" &lt;&lt;sizeof...(args)&lt;&lt; "," &lt;&lt; value &lt;&lt; std::endl; printf1(args...); } int main() { printf1(1, 2, "123", 1.1); return 0; } 3.C++17 中增加了变参模板展开的支持
//C++17 中增加了变参模板展开的支持 template&lt;typename T0, typename... T&gt; void printf2(T0 t0, T... t) { std::cout &lt;&lt; t0 &lt;&lt; std::endl; if constexpr (sizeof.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/692376d64cca0bffc2e6b108d3955d0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f49c0d21b15ad87318f421ac69d01d/" rel="bookmark">
			XSS跨站脚本攻击（DVWA XSS攻击详解、XSS平台搭建）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、跨站脚本攻击过程 二、XSS攻击定义及危害 三、XSS攻击常见分类 例：反射型
例：存储型
例：DOM型
四、XSS攻击常见编码 例：
编码后：
五、XSS常见测试语句 Script 标签
Script 标签可以用于定义一个行内的脚本或者从其他地方加载脚本：
Src属性
&lt;img src=x οnerrοr=prompt(1);&gt;
&lt;img/src=aaa.jpg οnerrοr=prompt(1);&gt;
&lt;video src=x οnerrοr=prompt(1);&gt;
&lt;audio src=x οnerrοr=prompt(1);&gt;
事件触发
&lt;svg/οnlοad=prompt(1);&gt;
&lt;marquee/onstart=confirm(2)&gt;/
a标签
2 //可以去掉双引号
&lt;a href=javascript:eval(“\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29”)&gt;2 //不能去掉双引号
&lt;a href=javascript:eval(“alert(‘xss’)”)&gt;2 //可以去掉双引号
原code：
&lt;a href=javascript:eval(“alert(‘xss’)”)&gt;2
&lt;a href=“javascript:aaa” οnmοuseοver=“alert(/xss/)”&gt;22222222
input 标签
&lt;input value=“” οnclick=“alert(xss)” type=“text”&gt;
&lt;INPUT name=“name” value=“01/01/1967” οnmοuseοver=prompt(971874) bad=“”&gt;
触发事件
&lt;svg/οnlοad=prompt(1);&gt;
&lt;marquee/onstart=confirm(2)&gt;/
利用0字节绕过
&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt;
&lt;scri\x00pt&gt;alert(1);&lt;/scri%00pt&gt;
&lt;s%00c%00r%00%00ip%00t&gt;confirm(0);&lt;/s%00c%00r%00%00ip%00t&gt; //
在IE9及以下版本有效。
svg标签
当返回结果在svg标签中的时候，会有一个特性
&lt;svg&gt;&lt;script&gt;varmyvar="YourInput";&lt;/script&gt;&lt;/svg&gt; SVG(Scalable Vector Graphics)是一种基于XML的二维矢量图格式，和我们平常用的jpg/png等图片格式所不同的是SVG图像在放大或改变尺寸的情况下其图形质量不会有所损失，并且我们可以使用任何的文本编辑器打开SVG图片并且编辑它，目前主流的浏览器都已经支持SVG图片的渲染。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f49c0d21b15ad87318f421ac69d01d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a5c239f7ffe91127948ef1efd40adb/" rel="bookmark">
			基于 VTable 的多维数据展示的原理与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多维表格介绍 多维表格又名透视表、交叉表、Pivot Table，指的是可以在行维度和列维度放入一个或多个维度，显示维度之间相互关系的一种表格。用户可以一目了然地分析出各种场景指标以及对比，旨在帮助业务分析推动决策。
假设需要分析如下表格所示的销售数据：
在对这样的表数据进行分析时，不同的数据分析师或者不同角色都会基于自己感兴趣的业务角度提出相关的问题，比如：有人关心各个地区的销售额，希望找出销售情况较低的地区；有人需要了解近期内不同产品类别的销售额对比，便于做后期的产品研发······
这些问题中的业务角度，比如地区、类别、时间年份就是维度，“销售额”就是指标。
多维表格概念 理解 BI 多维分析中的几个核心概念：
维度：用来对数据进行分类和人们观察业务情况的角度；维度的层次：根据维度细节程度不同，划分出来的一类属性，是维度预先定义的不同级别。例如，日期维度的层次包括年、月、日；地区维度的层次包括：国家、省份、城市；维度层次各级别也都属于维度，但维度成员之间具有一定的关系，一般在分析中常作为钻取的方向。维度成员：是各维度上数据项的取值，即维度值。例如，日期维度的层次月的维度成员有：1月、2月、3月等，地区的成员有：东北，华北，华中等；指标：用来描述业务情况的数据，例如，销售额、成本、利润等度量值。 在多维分析表中如何展示维度多的呢？下图中一共有四个业务维度：地区、省份、年份、季度，看数指标：销售额，利润。
针对图中销售数据，位置在单元格[5, 5]，即列5行5的数据：代表了2016年Q2季度下东北地区黑龙江省的销售利润值。也就是对应到行维度值：[‘东北’, ‘黑龙江’]，列维度：[‘2016’, ‘2016-Q2’]，指标：‘利润’。接下来将介绍如何用VTable实现这种多维表格。
VTable实现多维表格 概念映射到配置项 上图透视表的配置如下：
const option={ rows:['region','province'], //行维度 columns:['year','quarter'], //列维度 indicators:['sales','profit'], //指标 records:[ //数据源 { region:'东北', province:'黑龙江', year:'2016', quarter:'2016-Q1', sales:1243, profit:546 }, ... ] } 该配置是多维表格最简配置。随着对功能要求的复杂性可以针对各功能点来添加各项配置来满足需求。
数据分析相关配置： 配置项类型描述rowsstring[]IDimension[]columnsstring[]IDimension[]indicatorsstring[]IIndicator[]dataConfig.aggregationRulesaggregationRule[]按照行列维度聚合值计算规则dataConfig.derivedFieldRulesDerivedFieldRule[]派生字段dataConfig.sortRulessortRule[]排序规则dataConfig.filterRulesfilterRule[]过滤规则dataConfig.totalstotalRule[]小计或总计 dataConfig配置定义：
/** * 数据处理配置 */ export interface IDataConfig { aggregationRules?: AggregationRules; //按照行列维度聚合值计算规则； sortRules?: SortRules; //排序规则； filterRules?: FilterRules; //过滤规则； totals?: Totals; //小计或总计； derivedFieldRules?: DerivedFieldRules; //派生字段定义 ... } dataConfig 应用举例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34a5c239f7ffe91127948ef1efd40adb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d494853f62d58ef47bc412e0471fe4/" rel="bookmark">
			让AI成为你的编程助手——DevChat AI插件在VSCode中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#AI编程助手哪家好？DevChat“真”好用 #
文章目录 0. 前言1. DevChat的优点2. DevChat注册3. DevChat安装依赖安装插件安装 4. DevChat在线体验4.1 逻辑判断能力（1）先有鸡还是先有蛋？（2）鸡兔同笼问题 4.2 代码生成能力（1）简单提问（2）复杂提问 5. 总结 0. 前言 随着人工智能技术的飞速发展，大模型已经成为了这个领域的一股强大力量。它的出现，让我们看到了人工智能在自然语言处理方面的惊人能力，无论是生成文本，还是进行对话，大模型都展现出了令人惊叹的性能。
然而，尽管大模型的功能强大，我们仍然在寻找更加高效、便捷的工具，以更好地满足开发者的需求。这就是DevChat工具诞生的背景。
DevChat助手旨在利用集成多种大模型的强大能力，为开发者提供一个更为智能、高效的开发环境。通过大模型的自然语言处理能力，DevChat可以帮助开发者自动完成一些繁琐的任务，如代码生成、错误排查等，从而大大提高开发效率。
大家不妨自行上号体验一番DevChat助手的强大：http://meri.co/6k2
1. DevChat的优点 多种大模型任意选：复杂任务非 GPT-4 莫属，简单任务交给低成本模型，组合使用效能最佳精准的“上下文”管理；把任意代码段加入对话，不靠 AI 时好时坏的猜测，把控制权交还给用户简单可扩展的提示词目录：开放提示词扩展，Prompts as Code，满足团队和个人自定义需求灵活的 Prompt 模板管理，ask-code功能解答代码库的各类问题产品设计务实，迭代反馈快代码和文档自由生成，而非简单补全对接微软 Azure 服务，可信赖的企业级数据安全 2. DevChat注册 1、打开DevChat官网，点击免费试用：http://meri.co/6k2
2、输入账号和邮箱：
3、再次输入邮箱和收到的验证码：
注册成功邮箱收到邮件，其中包含了 Access Key 如红框那后续我们需要使用到：
3. DevChat安装 依赖安装 这里我们需要电脑上Git，如果有则可以跳过此步骤
1、打开git 下载官网，选择自己合适的版本：https://git-scm.com/download/win
2、安装的时候一直点击next即可：
3、安装完成后再cmd控制输入git --version出现版本号即可：
插件安装 1、打开VScode插件板块输入DevChat，点击安装：
2、安装成功后可以看到多了一个兔子图标：
3、点击设置，点击命令面板：
4、输出devchat key，选择第一个然后回车：
5、接着复制刚才邮箱里面收到的 Access Key 然后回车：
6、这里可以看到有很多模型包括：GPT3.5和GPT4，可供我们使用：
7、我们选择GPT-4问问它：
OK没问题可以使用！
4. DevChat在线体验 4.1 逻辑判断能力 （1）先有鸡还是先有蛋？ 经典问题：先有鸡还是先有蛋？对于这种有争议的问题，DevChat AI的回答特别聪明，给出两种不同的主张观点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d494853f62d58ef47bc412e0471fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c83f73f6f00377380e5cf24f5128261c/" rel="bookmark">
			Python123：使用函数输出一个整数的逆序数（C语言）、数据结构免费资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据结构-顺序表（免费资源）使用函数输出一个整数的逆序数 数据结构-顺序表（免费资源） 功能如下：
顺序表的初始化求顺序表的长度在顺序表中插入结点在顺序表中删除结点在顺序表中取得结点在顺序表中查找顺序表遍历顺序表用后插法插入元素顺序表判空及判满 想要提前了解数据结构顺序表的小伙伴们可以下载这个资源看看呀！（免费的） 资源里有完整可执行代码，也有详细的注释，感兴趣的小伙伴可以运行一下试试看，需要做顺序表实验的也可以根据我的代码来改哈！
链接在这=&gt; 数据结构-顺序表
使用函数输出一个整数的逆序数 题目： 本题要求实现一个求整数的逆序数的简单函数。
函数接口定义：
int reverse( int number ); 其中函数reverse须返回用户传入的整型number的逆序数。
裁判测试程序样例：
#include &lt;stdio.h&gt; int reverse( int number ); int main() { int n; scanf("%d", &amp;n); printf("%d\n", reverse(n)); return 0; } /* 你的代码将被嵌在这里，与上述测试代码一起提交 */ 输入样例：
-12340 输出样例：
-4321 代码1：
#include &lt;stdio.h&gt; int reverse( int number ) { int sum=0,flag=1,x; if(number&lt;0){ number=-number; flag=-flag; } while(number&gt;0){ x=number%10; sum=sum*10+x; number/=10; } sum*=flag; return sum; } int main() { int n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c83f73f6f00377380e5cf24f5128261c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50ece76ddad78c6e5a7d434d04f379f/" rel="bookmark">
			YOLO MAP指标--引领视觉定位技术的新潮流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、MAP指标概念
二、MAP 指标具体详述
三、总结
一、MAP指标概念 YOLO的MAP指标是一种评估目标检测算法性能的指标，全称为mean Average Precision（平均准确率均值）。它综合衡量了检测效果，包括精度和召回率等，是精度和召回率的交点与原点形成的矩形的面积。
在目标检测任务中，MAP指标常用于衡量模型在多个类别上的平均性能。它通过计算每个类别的平均准确率，并取其平均值来评估模型的性能。
在计算MAP指标时，首先需要将预测的边界框与真实标签进行比较，并根据IOU值将它们分类为TP（真正例）、FP（假正例）和FN（假反例）。然后，根据每个类别的精度和召回率计算AP（平均准确率），并将所有类别的AP值相加再除以类别总数，得到最终的MAP值。
YOLO的MAP指标可以用于评估模型在不同类别上的性能，并可以用于比较不同模型之间的性能。在目标检测任务中，高的MAP值通常表示模型具有较好的性能。
二、MAP 指标具体详述 MAP顾名思义，就是各类别AP的平均值。AP是PR曲线下的面积，PR曲线就是以Precision（查准率）以纵坐标、Recall（召回率）为横坐标的坐标系下绘出的曲线，即Precision-Recall曲线，如下图所示：
PR曲线上某一点的意义为：在某一阈值下，模型将大于该阈值的结果判定为正样本，小于该阈值的结果判定为负样本。再根据判定结果统计出TP、FP、TN以及FN，根据这四个统计量计算出对应的precision和recall,TP、FP、TN、FN含义如下：
TP（True Positive）：实际为正例且预测为正例的样本数。FP（False Positive）：实际为负例但预测为正例的样本数。TN（True Negative）：实际为负例且预测为负例的样本数。FN（False Negative）：实际为正例但预测为负例的样本数。 Precision计算公式如下：
Recall计算公式如下：
PR曲线描绘了模型在不同阈值设置下取得的精确度（precision）和召回率（recall）。这一曲线能够体现模型的有效性和鲁棒性，因此适合用于评估模型的综合性能。
在目标检测任务中，模型会生成一系列的矩形检测框集合，这些矩形框的坐标、长宽以及置信度都包含在内。这里，置信度与PR曲线计算的阈值有关。在后续计算MAP（mean Average Precision）时，会详细介绍这一过程。
为了解决目标检测中的二分类问题，我们将矩形检测框视为正样本，将真实目标（GT）视为负样本。那么，如何判断一个预测框是TP（真正例）呢？当矩形检测框与GT的交并比（IOU）大于我们设定的阈值（通常为0.5）时，我们便将该检测框判定为TP。与之相对，IOU小于等于设定值的检测框则被判定为FP（假正例），需要注意的是，FP也包括同一GT的重复检测框。至于FN（假反例），则是那些没有被任何检测框捕捉到的GT数量。
通过上述方式，我们能够更加清晰地理解目标检测任务中的各种评估指标，从而更好地优化模型性能。
三、总结 MAP指标是目标检测任务中重要的评估指标，可以用于衡量模型的性能。同时，PR曲线可以反映模型在不同阈值设定下取得的precision和recall，从而说明模型的有效性和鲁棒性。在目标检测任务中，矩形检测框的匹配被视为二分类问题，并通过TP、FP和FN等指标进行判定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958b86fa3cf86f4df12fe8dee63e4924/" rel="bookmark">
			HTML5&#43;CSS3实现小米商城（课程设计版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这个小米商城用到了html+css+js，内容是今年6月份的。
结构相对简单，比较容易理解。
如果想要纯html+css实现的小米商城，可以看我的这个作品
HTML+CSS实现小米商城
如果需要其他网页作品了，可以看主页其他作品。
HTML+CSS实现华为商城
HTML+CSS实现华为官网
HTML+CSS实现哔哩哔哩首页
HTML+CSS实现小米官网
HTML+CSS实现QQ注册页面
下面先展示一个页面整体结构，然后再分析一下实现代码吧！
文章末尾附项目源代码！！！
一、效果展示 二、代码分析 注：因为代码过多，这里仅展示部分，完整代码在文章末尾 1.轮播图部分 .head3 { // CSS部分 width: 1226px; margin-left: 146px; margin-right: 146px; height: 400px; margin-top: 14px; margin-bottom: 35px; overflow: hidden; float: left; } .head3_lunbo { width: 4904px; height: 400px; animation: text 15s infinite backwards; /*消除图片间隔*/ } .head3_lunbo img { width: 1226px; height: 400px; float: left; } @keyframes text { /*0%-20%是播放下一个图片，0%-10%是图片暂停的时间*/ 0%, 20% { margin-left: 0px; } 25%, 45% { margin-left: -1226px; } 50%, 70% { margin-left: -2452px; } 75%, 100% { margin-left: -3678px; } } &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/958b86fa3cf86f4df12fe8dee63e4924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f27d549607857ffe3f9b5da19153bb/" rel="bookmark">
			Android Studio工程应该忽略的文件及如何使用gitignore
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍版本控制中，Android Studio工程应该忽略的文件，以及如何使用.gitignore文件快速配置自动忽略，教程同时适用于Git和SVN。
应该忽略的文件： *.iml .gradle /local.properties /.idea .DS_Store **/build /captures .externalNativeBuild .iml是IDEA的module描述文件，和工程配置相关，在每一个module都有，需要忽略。*表示忽略所有的.iml 使用gitignore 这是最简单的方式
在项目根目录下创建.gitignore文件，将上面应该忽略的文件，内容复制到.gitignore中。
用Android Studio打开.gitignore文件时会在右上角弹出安装gitignore插件，点击安装即可，安装完成后就自动设置好忽略了，如果要添加忽略文件，只需要在.gitignore中添加文件路径即可。
自己设置忽略 右键点击相应文件，选择相应VCS操作即可。
gitignore 的官方模板仓库 此外github官方提供了一个仓库，里面包含了绝大多数平台，语言的gitignore模板
https://github.com/github/gitignore
本文原始发表于：https://wycode.cn/blog/gitignore 转载请注明出处
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1011e0445bd988950476fa5bdec90036/" rel="bookmark">
			面向BEV感知的4D标注方案 | 万字实录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 隋唐 编辑 | 汽车人
原文链接：https://zhuanlan.zhihu.com/p/642735557
点击下方卡片，关注“自动驾驶之心”公众号
ADAS巨卷干货，即可获取
点击进入→自动驾驶之心【数据闭环】技术交流群
本文只做学术分享，如有侵权，联系删文
各位朋友，大家好，非常荣幸有这样一个机会，在智东西公开课和大家做一次技术分享。
今天我要分享的是《面向BEV感知的4D标注方案》。首先会简单的介绍一些4D标注的技术，以及依赖的硬件基础；之后主要介绍两种标注方案：一种是面向采集场景的，主要是在研发阶段，使用的车辆传感器会按照自己的需求进行改装。一个简单的例子就是可以用一些非量产的传感器；另一种是面向量产场景的，例如针对量产数据badcase迭代阶段，这种场景下只能够利用量产车上的传感器，会有一些限制；最后，我会介绍一下地平线4D-Label的云端运营平台，以及4D-Label技术的未来发展趋势。
1. 4D Label技术简介 首先介绍一下4D-Label技术。4D主要就是3D空间和时序。以BEV为代表的感知技术，典型的特征就是输出的空间从2D的透视图像转换到了3D空间。原先都是在图像空间里，输入的是图像，输出的也是2D图像像素空间的信息，也就是所见即所得。但BEV感知技术输入的是2D的图像或者是2D的video，输出的是3D空间的感知结果，通常是以车体坐标系之下的一些3D静态或者动态的结果。对于BEV感知，真值数据的生成是非常关键的环节，因为标注的空间需要从2D透视图像空间转换到3D空间。其中，考虑到时序动态物体，需要用到一项很重要的技术就是4D重建技术。
这次技术分享涉及到的一些感知任务，大致可以分为三类：第一类是静态感知。静态感知的输出形式，实际上越来越像局部的高精地图，包含物理层，逻辑层以及半动态层。其中物理层主要是路面连续要素如车道线、路面离散要素如路面标识符，空中静态要素如灯牌，半动态层主要是像锥桶这类容易被移动的物体。逻辑关系主要是车道链接关系，以及道路元素和交通灯的关联关系。动态感知主要是运动车辆和行人，包含检测、跟踪、预测，此外还有一些速度、加速度的属性，现有的一些端到端的感知框架，可以直接在同一个网络完成以上所有感知输出。还有一类任务就是通用障碍物感知，主要是针对场景中的非白名单的物体，目前业界主流的的感知任务就是Occupancy和Ocupancy Flow ,这类任务的基本原理是将空间划分成规则的voxel, 预测每个voxel的被占据情况以及每个voxel的速度，本质上是通过几何的方法，而非语义的方法实现对通用物体的识别。今天我们主要就是针对这三类任务，来介绍一些标注方案。
4D-Label整体的技术路线，无论是面向采集场景的多模方案还是面向量产数据的纯视觉方案，都是一致的。整体的思想就是：首先是采集数据，之后进行点云或者Object级别的4D重建。在得到4D重建空间的基础之上，采用人工的方式通过3D 标注工具进行标注和质检，之后完成真值数据的发版。随着人工标注数据越来越多，可以在云端训练一些大模型，用于辅助标注，提升标注效率，降低标注成本。当云上的数据规模累积到一定的程度，云上模型的性能会大幅度提升。此时，大部分的标注任务都可以实现自动化标注。此外，为了进一步提升标注的质量和自动化，我们会设计一些自动质检的策略。比如说，采用多传感器的交叉验证，在2D图像上利用大模型的预刷，得到一些标注结果，同时和3D空间的标注结果进行对比，去除差异较大的数据，只保留一致性好的标注数据作为真值，从而保证真值数据的质量。通过大模型预刷，目前我们可以通过这种策略可以节省80%以上的标注人力，甚至有一些像动态物体的标注，可以实现完全自动化。
4D标注涉及到的硬件基础，首先就是传感器的布局。在L2++以上的自动驾驶方案里面，通常采用周视+环视的布局方式，构成了两层360度成像范围。如果是面向采集场景的采集车，一般会在车顶安装Pandar128 Lidar用于标注。
在得到改装的车辆之后，还要进行传感器之间的外参标定和时间同步，用来实现不同传感器之间数据的时空一致性。涉及到的外参标定主要有Lidar和camera之间的标定，以及GPS、IMU和Vcs坐标系之间的标定。标定的方式可以分为两种，一种是工厂标定，一种是在线标定。工厂标定，是在出厂时进行的一次比较全面和系统的标定，通过特定的标注工具，得到高精度的标定结果，但是无法频繁地进行标定。在线标定，是利用一些端上的感知结果，进行外参标定，在线标定可以高频次进行，能够有效地保证传感器精度的下限，例如当传感器因为抖动而发生位置变化的时候，在线标定可以获取最新的标定结果。在实际过程中，这两种方式我们都会使用，工厂标定得到传感器的外参之后，通过在线标定做实时或者定时更新。在得到外参标定之后，还需要进行多传感器之间的时间同步，用于保证不同传感器之间准确的数据的关联关系。在我们方案里，采用的是11V图像同步曝光，时间偏差小于5ms。另外，介绍一下我们的方案里面涉及到的一些数据格式的定义，这里涉及到两个基本的数据概念。
第一个数据概念是Clip。Clip是一段数据视频，可以是固定的长度或者固定的空间距离。比如说，在量产的时候，可以设定Clip的长度是15s。在采集模式下，可以采用空间距离，限制它为300m的局部片段。每个clip都包含多个传感器的数据。例如在采集模式下，clip包含Lidar点云数据，11V的图像数据，以及GPS、IMU、轮速计等所有传感器的数据。第二个数据概念是Site。Site是一个空间的物理坐标点，可以理解成是一个空间的GPS点。这个空间位置中具有唯一的特性，一个Site可以包含多个经过它的Clip。举个简单的例子，把路口中心点定义成一个Site，就可以通过GPS范围来筛选出所有经过该路口的Clip数据。
2. 面向采集场景的多模标注方案 2.1 路面静态要素标注 上面是一些4D-Label的简单的技术简介。接下来，我会介绍两种方案：一种是面向采集场景的多模标注方案，另一种是面向量产的纯视觉方案。多模标注方案在量产感知传感器基础之上增加了Pandar128雷达。面向量产的标注方案主要是采用量产传感器采集的数据进行标注，我们的方案是纯视觉感知，因此只用图像信息（结合惯导、轮速计等）进行标注。对于一些有Lidar的量产方案，可以将Lidar利用起来，以减少动态标注的难度。首先是多模的方案。我们按照这几种任务，分别来介绍一下标注的过程：我们按照静态、动态和通用障碍物三种任务分别介绍一下多模标注方案。首先是路面静态要素的标注。路面静态要素的标注，本质上是对路面进行建模，也就是局部的建图。在我们的方案里面，采用了单趟重建和多趟聚合的方式。这种方式，一方面可以提升建图效率，平摊标注成本；另一方面也能保证建图的完整性，提升召回以及远距离的真值。
介绍一下具体方案：首先利用Pandar128采集的数据，结合IMU和GNSS数据，做单趟重建，得到单趟的点云地图；每一个clip都对应一个点云地图，之后把位于同一个Site的所有clip的点云地图收集起来，并建立clip之间的关联关系，确定联合优化的范式，将多个clip的点云地图进行聚合，得到完整的局部地图。
在我们的方案里面，需要同时满足城区、高速、还有泊车三个场景的建图。这些环境都存在非常大的挑战，针对单趟局部建图，我们做了一些的优化。例如高速场景的初始化，很容易因为速度过快、环境单一、特征约束不足而失败。我们方案引入了语义信息，来提供更加准确的Lidar关键点的对应关系同时也采用轮速计和GNSS这样的多传感器的数据，来辅助初始化。经过这些优化之后，可以将初始化的成功率提升到98%以上，单趟的重建精度可以达到厘米级（和高精度的Novatel进行评测）。
在得到单趟重建之后，为了提升局部地图的完整性，提升路面元素的召回，需要对多趟clip重建的结果进行聚合。多趟聚合的核心点在于位置重识别，也就是SLAM里面的回环检测。回环检测的关键在于提供feature层面的对应关系。但是，因为这个场景里面比较单一，像高速场景或者是路口场景，能够有效识别的特征并不是很多，容易导致回环检测失败，或者造成比较大的偏差。针对这些问题，我们对聚合做了一些优化：首先和单趟重建一样，引入了一些语义信息，能够得到一些路面和标识牌这些显著的特征，利用语义信息引导进行匹配；另外，也采用了一些learning的方法，得到的一些关键点，能够在一些极端环境下，提供更鲁棒的匹配结果。通过这两种策略，可以使多趟重建的成功率达到90%以上。下面这个demo就是一个全局聚合之后的局部地图的效果，可以看到，由于建图的精度足够高，lidar intensity图上路面的元素结构特别清晰。
Lidar的反射率会对材质敏感，当遇到特殊材质、路面破旧或者有积水的情况，会导致intensity图上路面要素不清晰，难以识别，另一方面Pandar128的intensity本身就需要标定，同一台Lidar传感器，在跨天或者跨地点的时候，会出现Intensity不稳定的情况。为了提升标注的召回，我们的方案里引入了语义图以及纹理图，用于提供更多的信息（见上图）。纹理图，主要是通过Lidar和视觉的外参标定，实现了Pixel -level的融合，最终得到路面纹理的重建结果，纹理图像能提供的信息非常丰富，理论上只要具备行驶条件的场景下的数据，纹理图像都能进行标注。和纹理图一样，语义图是用采用2D图像的感知结果，通过Lidar-camera的融合得到的，引入感知结果可以处理一些弱纹理的情况。在标注的时候，我们将三种不同模态的数据投影到一个平面上得到一幅BEV空间的大图，通过人工标注的方式得到真值数据。由于投影的过程保留了高度信息，因此标注的结果可以利用这些高程信息得到3D空间的数据。当积累一定的量的数据之后，我们利用这些数据训练一个云端大模型用于辅助标注。模型采用了我们自己的一篇工作MapTR，输入是三种模态的大图的信息，输出的直接是实例级别数据。每一条车道线都会表示成有序的点列，这样就节省了很多的后处理。这些标注的结果通过简单的处理就可以得到训练样本。后续我们也会尝试采用MapTR直接标注逻辑层。
这是我们通过多模的方案，做的一个标注案例。这个案例里面有三段clips，左上角不同颜色的轨迹代表不同的clips。通过三个clips的聚合，保证了路口的完整性。因为在有些路口比较大的情况下，单趟的采集和重建，不能保证这个路口能被完整的重建出来。通过多个Clip聚合的方式，可以保证路口的完整性，同时也能满足远距离感知的真值需求。此外，通过聚合的方式，也可以平摊clip的标注成本。因为聚合之后，一张BEV大图，只需要标注一次，就可以生成所有clip的真值。我们采用将标注的真值投影到图像空间，计算重投影误差的方式对多模的真值进行评测。我们的方案可以做到重投影误差小于3个像素。
我们的方案相较于HDmap定位生成真值的方式在多个方面具有优势。首先是可扩展性强。图商的高精地图，在建图的时候，会采用价格高昂传感器，成本很高，可扩展性比较差，体现在现在高能地图的覆盖率并不是很高，尤其是在城市地区。我们的方案虽然是基于采集车，但是也需要考虑采集车队的可扩展性，所以我们采用的是一般精度的传感器。另外，图商的地图在建图主要目的是用来做定位导航，因此需要做完整的建图，而4D-Label的首要目的是用来做标注，感知数据首先要考虑的是质量、数量和多样性，因此所以不需要做完整的地图重建，甚至不需要做地图的维护，只需要在一些区域里面做采样性地重建，就能够满足真值多样性的需求。这是第一个不同点，第二点不同的是图商的地图，受鲜度的影响，地图更新比较慢。这样会导致在生成真值的时候，需要投入大量的人力资源，去识别地图和实际场景不一致的问题。而4D-Label大部分情况都是即建即用，不需要考虑鲜度的问题。此外，定位精度也会存在差别。现在基于视觉感知的的高精地图定位方法，横向误差大概是在10-20cm左右，纵向误差可能会到30-40cm以上。这样的精度，偏差已经大于一根车道线，没有办法满足真值精度的需求。而4D-Label这种方法，不需要考虑全局的定位精度，只需要保证局部的里程计精度，所以它的精度会比较高。横纵向误差都能够到10cm以下。这就是图商HD Map和4D-Label的一些对比。总而言之，4D标注的首要目标是满足感知的真值需求，所有的方案设计都应该从围绕满足真值数据的数量、质量和多样性。
刚才讲的是行车。在泊车场景下的标注，底层的建图方案基本一致。唯一的区别在于地库泊车场景下，没有GNSS信息，无法采用多趟重建+全局聚合的方式。因此在泊车场景下，我们采用全场景建图的方式，将采集的数据进行完整的地图重建。针对建图精度提升的优化策略与行车也基本相同，主要是通过Lidar-seg语义的信息，做了一些约束。泊车场景的重建的精度，能够达到4-5cm。我们主要是通过人工构造回环的方式进行评测。在标注的时候，我们也开发了相应的预刷大模型。像地库位点、限位器、库位角点还有墙壁的检测，现在都是通过大模型预刷的方式来进行。
2.2 动态要素标注 以上介绍的是路面的静态要素的标注，接下来介绍动态物体的标注。动态物体的标注，采用的Lidar+视觉后融合的方案。主要的过程是，首先有一个Lidar检测的大模型，对输入的Pandar128的点云数据进行感知，得到每帧点云上的3D物体的检测框。之后采用传统的卡尔曼滤波的方式，对不同帧之间感知结果的跟踪，得到每个物体的跟踪结果，从而可以获取每个物体在时序上的一条完整轨迹。
通过利用Lidar SLAM获取的自车轨迹，可以将每个运动物体投射到全局坐标系之下，从而得到全局的轨迹。之后，对这些运动物体的轨迹做进一步的优化，比如说轨迹的平滑性，还有动力学约束，能够得到一些更加平滑和准确的轨迹。得到运动物体的轨迹之后，就可以得到其所有信息，包括track ID，预测的信息，速度和加速度等属性。拿到这些信息之后，就可以生成动态感知任务的真值，像检测、预测，还有端到端直接估计速度、加速度的属性。4D标注过程在云上进行的最大的优势就是可以利用未来的信息来做标注。也就是说，一个运动物体可以用其未来的信息来辅助当前的标注，也因此能够得到比较高的一个精度或者召回。我们前面讲到，视觉和Lidar之间会有时间的同步，而视觉11V的图像是同时曝光的，它和Lidar之间的扫描会存在一个时间偏差。利用时间同步的信息和轨迹信息，可以把物体的运动信息插值到任何一个时刻，从而得到每个时刻的真值。例如当某些Lidar帧上出现漏检的情况，可以通过时序轨迹差值的方式补充在该帧上的结果。为了进一步提升真值的质量，我们采用2D预刷大模型的方式，和3D插值的结果进行对比，实现自动质检。只有3D投影的结果和2D有比较高的overlap，才会被当作高质量的真值保留下来，否则会被丢弃掉。这样做并不会影响真值的的效果，因为检测任务中每个训练样本是物体的object，而不是一幅图像。所以，即便在同一个样本里，一幅图像或者一帧点，有部分的object没有被完全准确标注出来， 也并不影响最终的训练任务。一个时刻的图像，如果能保证里面有60% -70%的真值是准确标注的，就能够满足模型训练的需求。这种投影的方式还有一个用处就是将2D感知的属性赋予3D标注结果，例如车辆的车门开合、车灯颜色等，很难通过Lidar识别的信息，可以通过2D图像获取。
2.3 其它静态要素标注 接下来介绍其它静态要素的标注，驾驶场景里面的红绿灯、交通牌和锥桶。这些物体的标注方案和动态物体基本是一致的，主要区别在于两点：3D空间bounding box的获取方式以及跟踪方式。在这里我们以锥桶的方案为案例进行介绍。我们的主要的路线：首先是有一个Lidar分割的大模型，利用Lidar的语义信息，提取锥桶的潜在3D proposal，但这里面可能会存在大量的噪声；之后利用时序的信息对2D锥桶检测结果进行跟踪和关联；最后利用2D锥桶和3D-proposal做关联，去除一些噪声。可以看得出来，最终的标注方案，实际上是比较依赖于2D锥桶检测大模型，它的准召率也依赖于2D锥桶大模型。最后，通过2D和3D交叉验证的方式，得到锥桶的标注结果。我们的方案可以实现锥桶标注的准召率高于95%，测距误差50m范围之内小于5%。
这个demo展示了两个场景下的一些真值标注的效果，一个是泊车场景下，一个是行车场景下。对于一些2D检测出来，但是3D缺少的情况，可以采用标志为 ignore的方式，不参与训练。
2.4 通用障碍物标注 最后，介绍一下通用障碍物的自动标注，其实就是驾驶里面的Occupancy和Occupancy flow的感知任务。Occupancy反映了场景中动静态物体的占据情况，它将空间划分成均匀的体素（voxel）,有物体占据的地方标志为1，没有物体占据的地方标志为0。此外，每个voxel还有一个速度的矢量信息，表示voxel的运动情况，即Occupancy flows。Occupancy和Occupancy flow实际上是对场景进行4D重建, 它主要的优势就是可以识别场景中的一些通用的、非白名单的障碍物，像一些散落的石块、散落的不规则物体、还有像宠物、逆行车等。
现有的Occupancy也有一些真值生成方案，还有一些公开数据集，今年CVPR2023举办了Occupancy的竞赛，也发布了数据集。但是现有的这些方案主要的问题在于过多地依赖了语义信息，例如在将场景分成动态和静态的时候，会通过3D检测的方式来进行的，这就引入很强的语义信息。实际上，在真值生成过程中，过于依赖白名单物体，就会导致实际上生成的真值，并没有办法真正发挥通用物体检测的本初目的。针对这种情况，我们对Occupancy的方案进行了一些改进。主要思路是在整个过程中尽量减少对语义的依赖。在动静态分离的时候，并不是依赖于白名单信息，而是利用几何信息进行运动分割。分割完之后，将静态场景和动态场景分而治之，静态采用前面介绍的静态语义建图的方式来得到静态的点云；动态的话，主要采用Scene Flow或者ICP的方式，来进行动态点云的配准，最终得到整个场景的4D点云。同时，在生成每帧图像的时候，我们也会做图像和3D结果的cross check，最后来生成真值。下面是一些案例，这个场景里面有很多的障碍物，像摆放的不规则、临时的红绿灯，里面还有只宠物狗、行人推的婴儿车。像这只宠物狗，能够比较好的识别出来。还有一些不规则的，像放在十字路口的临时红绿灯，也能够比较好的识别出来。我们针对Occupancy真值的性能做了一些定量的评测。针对50cm×50cm这样的小物体，准召率是高于92%。
3. 面向量产场景的纯视觉标注方案 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1011e0445bd988950476fa5bdec90036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a67ec9a55245d622d8e1004cc2386c/" rel="bookmark">
			【车载开发系列】IEEE 802.3协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【车载开发系列】IEEE 802.3协议 【车载开发系列】IEEE 802.3协议 【车载开发系列】IEEE 802.3协议一. IEEE 802.3协议二.IEEE的概念三. 802.3工作组四. IEEE 802.3ab五. IEEE 802.3u六. IEEE 802.3z七. IEEE802.3ad八. 与IEEE802.11的区别 一. IEEE 802.3协议 IEEE 802.3协议是物理层协议。该协议定义CSMA/CD标准的媒体访问控制（MAC）子层和物理规范。
IEEE802.3它是以太网标准，指的就是LAN有线局域网的标准。
以太网根据传输媒体和传输速率组合分类标准，传输媒体分为双绞线缆、多模光纤和单模光纤，传输速率分为10Mbps、100Mbps、1Gbps、和10Gbps等。
IEEE802.3主要是规定传输介质及其特性。
传输介质一般使用10Base-T形式进行描述。其中10是速率，即10Mb/s;
Base表示传输速率，Base是基带，Broad是带宽；而T则代表传输介质，T是双绞线，F是光纤。
二.IEEE的概念 IEEE叫做电子与电气工程师协会（Institute of Electrical and Electronics Engineers），简称IEEE，总部位于美国纽约，是一个国际性的电子技术与信息科学工程师的协会，也是全球最大的非营利性专业技术学会
三. 802.3工作组 IEEE中有很多委员会，其中IEEE 802又称为LMSC（LAN/MAN Standards Committee，局域网/城域网标准委员会），它致力于研究局域网和城域网的物理层和MAC层中定义的服务和协议，对应OSI网络参考模型的最低两层（即物理层和数据链路层）。
四. IEEE 802.3ab 该标准针对实体媒介部分制定的1000Base-T规格，使得超高速以太网不再只限制于光纤介质。这是一个传输介质为4对CAT-5双绞线、100m内达到以1Gb/s传输数据的标准。
五. IEEE 802.3u 快速以太网（Fast Ethernet）的最小帧长不变，数据速率提高了10倍，所以冲突时槽缩小为5.12us。以太网的计算冲突时槽的公式为：
Slot=2S/0.7C+2tphy
其中，S表示网络的跨距（最长传输距离），0.7C为0.7倍光速（信号传播速率），tphy是发送站物理层时延（由于往返需通过站点两次，所以取其时延的两倍值）。
六. IEEE 802.3z 千兆以太网（Gigabit Ethernet）。千兆以太网标准IEEE 802.3z定义了一种帧突发方式（frame bursting）,这种方式是指一个站可以连续发送多个帧，用以保证传输站点连续发送一系列帧不中途放弃对传输媒体的控制，该方式仅适用于半双工模式。在成功传输一帧后，发送站点进入突发模式以允许继续传输后面的帧，直到达到每次65536比特的突发限制。该标准包含：1000BASELX、1000BASESX,1000BASECX三种。
七. IEEE802.3ad 它定义了链路聚合控制协议（Link Aggregation Control Protocol,LACP）,它得功能是将多个物理链路聚合成一个逻辑链路。链路汇聚技术可以将多个链路绑定在一起，形成一条高速链路，以达到更高得带宽，并实现链路备份和负载均衡
八. 与IEEE802.11的区别 相同点:802.3和803.11都用于局域网的标准
不同点:802.3用于LAN有线局域网，802.11用于WLAN无线局域网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2232edaaa99c5104341451daae624f0/" rel="bookmark">
			基于单片机的自动停车收费系统的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家点赞、收藏、关注、评论啦 ，由于篇幅有限，只展示了部分核心代码。 技术交流认准下方 CSDN 官方提供的联系方式
文章目录 概要 一、主要工作二、系统方案设计2.1 总体设计2.2 系统框架 三、系统的软件设计4.1 控制系统的主程序功能及流程图 四、结论 概要 本课题对自动停车收费系统进行研究，介绍了基于STM32F103C6T6单片机的一种停车场的自动停车收费系统的设计。该基于STM32F103C6T6单片机完成的自动停车收费系统采用了比传统停车计费系统方式更加优异的管理车库的方法，采用RFID检测汽车进入和驶出，然后传递给单片机进行相应的计费方式的计算，具备了能够自动开启关闭大门、显示停车场状态、查询停车场车位、自动显示需要收取费用等的一些功能，使系统更具灵活性，完成了硬件的设计和软件的编程设计。愈来愈多的停车场慢慢地采用更加自动且智能化的管理系统，相比于以前的人工管理的自
动停车场，可以极大地减少了人力成本，增强了管理效率。
关键词：单片机，STM32,自动停车收费，停车场管理
一、主要工作 虽然驾驶人与机动车数量增长迅猛，但由于城市周转腾挪的空间有限，加大车位的供应量，并不能从根本上解决“停车难”问题。尤其在中心城区和拥堵区域，停车位的盲目增加可能会导致交通更加拥堵。因此，对有限的资源进行科学合理的整合和调配是关键。停车设施建设严重落后于车辆的增长情况, 导致停车矛盾愈加严重, 停车难、乱停车的恶性循环成为城市交通管理的难点, 也直接导致交通堵塞、擦车追尾等交通事故, 不同程度阻碍了城市经济的发展。尤其在景区的旅游旺季, 举办大型展览, 会议及大型社会活动时, 人多车多, 停车更是一件非常不易之事, 因此解决停车难就成了所有开发商首先要考虑的一个问题。
因此，停车场管理系统就被大家重视了起来。根据我们国家目前的这一现状，本文提出了一种基于STM32F103C6T6为核心的单片机的智能停车管理系统。该停车场的收费管理系统运行极为简便,且产品价格也相对便宜,而且安装与调试迅捷简单,很好地解决了临时停车位的管理与收费方面的基础问题。同时能够大大节省停车场的管理费用及人手，提高停车场的利用效率。因此，由于这些独特且优秀的特性，使得本设计特别适用于旅游旺季、大型活动以及城市中心地带等所增设的各种停车场的现代化停车场管理收费, 同时也可以大大地缓解因停车难而造成的停车场附近道路交通拥堵等相关问题。
二、系统方案设计 2.1 总体设计 本设计是基于STM32F103C6T6单片机的自动停车收费系统，采用了比传统停车计费系统方式更加优异的管理车库的方法，采用RFID检测汽车进入和驶出，然后传递给单片机进行相应的计费方式的计算，具备了能够自动开启关闭大门、显示停车场状态、查询停车场车位、自动显示需要收取的费用等功能，使系统更具灵活性，为临时停车场提供了一个操作简便、价格低廉，而且行之有效的管理办法。
设计中采用STM32F103C6T6单片机来控制系统，所以需要有时钟电路，键盘电路，OLED显示电路，报警电路等几个部分。要实现系统的设计要用到的知识点有单片机的原理及其应用OLED的原理和应用以及键盘和时钟电路的设计等。
2.2 系统框架 （1）大门控制模块：在单片机的控制下与出入模块协同作业，通过RFID射频识别技术控制舵机执行停车场大门的升闸和降闸。保证了停车场的安全，维护了停车场的秩序，也能够增加停车场的效率。
（2）出入模块：该模块是通过RFID模块安装在停车场入口和出口，用于检测汽车驶入停车场大门和驶出停车场大门，把信息传递给单片机控制中心并进行相应计费，保持了停车场的秩序和安全问题。
（3）OLED显示：显示停车场的各种实时信息，包括北京时间、目前有多少车辆在停车场内、停车场总停车位数、停车需要付款的费用和各种操作提示等内容。
（4）单片机控制中心：采用STM32F103C6T6单片机系统，它是本设计的核心部分。主要功能是：有无车辆的进出，以及车辆进出的记录和将其显示出来；停车收费并进行信息记录与存储；处理键盘状态, 调节键盘操作的各种实时信息；显示和调整停车场状态，控制停车场闸道的升闸和降闸，使得汽车更方便快捷地进入以及离开停车场；有汽车驶入时停车场内的汽车数加一，当停车场内的停车数目与总容纳车数一样时，红灯亮起，不能再让汽车进入停车场。汽车驶出停车场后显示停车场内车辆数减一，闸道转动，让它离开；将车辆在停车场内的时间用单位换算成车辆需要在停车场内付款的总金额；控制显示器的运行，按照停车场内的实时信息显示停车场内的各种信息；如有非正常情况发生，比如火灾，会触发声光报警，提醒停车场内的人们赶紧离开。
（5）操作键盘模块：通过按键可以修改各种OLED显示器上的信息，可以修改显示的时间以及当前停车场内的停车数目以及停车场可以容纳的总共停车数量，也会有一些操作提示等内容。
（6）停车场状态显示模块：显示模块可以显示当前停车场内停的车辆总数以及停车场内允许容纳的最大车辆总数，通过这些就可以得知停车场内目前有多少空位，能容纳多少空余的车辆。当有空余的时候，停车场状态显示上亮的是绿灯，当停车场内没有车位空余时，停车场状态显示模块上的红灯亮起，此时不再允许车辆进入。所以停车场状态显示不仅可以显示车辆停车需要付的费用，更能显示停车场内有无空余车位，以及有多少空余车位。这样不仅方便了停车场的管理状态，还能够极大地方便了各个车辆的选择是否要进入停车场停车，增加停车效率。
三、系统的软件设计 4.1 控制系统的主程序功能及流程图 主程序完成下述主要功能：
初始化程序的设置；时钟的显示与存储；存取车状态的读入；存取车子程序的调入；给存取车控制系统的单片机信号的传递；
6.停车场状态的读取与现实； 四、结论 系统可以实现自动开启关闭大门功能、自动计费功能、显示功能、查询功能，而且时钟显示等均可调节，使系统更具灵活性。
设计中采用单片机来控制系统，有时钟电路，键盘电路，OLED显示电路，报警电路等几个部分组成。
停车收费标准可以调节，方便停车场运营，系统初始值设为2元/时。可以停车时交费也可以离开时交费经营者可以根据自己的情况来定。该系统还可以充当时钟来使用，时间的小时、分钟和秒数都可以调节。实现系统的设计用到了单片机的原理及其应用，键盘和时钟电路的设计等。
系统的实际开发使用将大大节省临时停车场的管理费用及人手，提高临时停车场的利用效率。该课题所实现的功能及性能可以经过适当的设计和完善运用于生活和生产实际中，例如一些临时停车场和大型超市等环境。本课题在设计过程中，最复杂的部分就是硬件电路的设计和单片机编程，在程序设计过程中遇到了问题，这些问题是程序设计中的一个难点，这些问题往往需要多次调试才能实现。所有系统在完善性方面还有待提高。这个系统的实现使我对电工技术、元器件芯片以及单片机的原理及应用都有了深刻的认识，真正做到了学有所得、学有所用，可以说获益匪浅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e605c5bb3e5f2145c31f854dadf7904/" rel="bookmark">
			北京联通iptv组播配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多年前折腾过iptv，近期搬家换了个大电视，打算把iptv配置好了，尽管不怎么看，但聊胜于无。
其实很简单，用到了一些工具，记录如下
1. openwrt配置 因为有软路由，所以就借助openwrt了，一般高端点的路由器都有iptv组播设置，潘多拉，华硕，华为都有，我习惯了openwrt，用了顺手。
找个有udpxy插件的固件，或者手动安装udpxy，此为前提。
配置两个网卡，一个内外，一个连光猫，光猫不需要连iptv口，任意即可，至少北京这几年安装的宽带自带光猫上已经不标注iptv口了，所以，没要求，任意网口即可。
假设内网网段ip是192.168.2.x，光猫是192.168.1.x
内网固定ip，假设为192.168.2.2；
光猫口新建一个连接，名字为wan（如果对应固件已经有wan口了，此步省略），协议是dhcp，防火墙绑定wan，其他都默认，网卡是eth1。
udpxy配置如下，不多说了，截图如下，很简单
​​​
设置好后，打开http://192.168.2.2:4022，显示如下页面，代表配置ok，记得把192.168.2.2换成你真实的openwrt所在局域网的ip
2. m3u文件准备 找个github，下载适合当地的iptv播放列表，很多，例如下面的，或者参考我的附件
GitHub - imDazui/Tvlist-awesome-m3u-m3u8: 直播源相关资源汇总 📺 💯 IPTV、M3U —— 勤洗手、戴口罩，祝愿所有人百毒不侵
关键的动作：
把m3u文件中的rtsp://替换为 http://192.168.2.2:4022/rtp/
替换后效果：
播放软件配置 这个部分配置因人而异，说个例子
1. windows
下载VLC player，打开上一步修改后的m3u文件即可
2. Android
下载iptv pro，导入上述m3u文件即可
如果是电视安装iptv pro，可以设置为开机自启动，打开app后自动打开上次的频道，对于电视用户而言，还是挺友好的。
教程至此结束，enjoy！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03133ba91422b665e25d41661127b00c/" rel="bookmark">
			【问题描述】编写一个程序，用户输入日期，计算该日期是这一年的第几天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【问题描述】编写一个程序，用户输入日期，计算该日期是这一年的第几天。
【输入形式】用户在第一行输入一个日期（年 月 日,中间以空格分割）
【输出形式】程序在下一行输出一个整数
【样例输入】2006 2 21
【样例输出】52
【样例说明】用户以年月日的格式输入，中间以空格分割，程序计算出该天是输入年份的第几天并输出该天数。另外还需要判断这一年是否为闰年。
编程提示：闰年的判断方法，下面两个条件满足一个就是闰年
1、能被4整除，但不能被100整除；
2、能被400整除；
a = input().split() list1 = list(a) sum = 0 # 月份的天数 for i in range(1, int(list1[1])): if i % 2 != 0: # 若为奇数 sum = sum + 31 else: sum = sum + 30 if int(list1[1]) &gt;= 3: if (int(list1[0]) % 4 == 0 and int(list1[0]) % 100 != 0) or (int(list1[0]) % 400 == 0): print(int(sum) - 1 + int(list1[2])) # 为闰年,2月为29 else: print(int(sum) - 2 + int(list1[2])) else: print(sum + int(list1[2])) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c673edfec23875b8525521a602ff73/" rel="bookmark">
			对接企业微信机器人报错：{\“errcode\“:60020,\“errmsg\“:\“not allow to access from your ip, hint: [169917845713115
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prometheus+altermanager对接企业微信机器人报错内容：
level=debug ts=2023-11-05T10:00:57.435Z caller=wechat.go:190 integration=wechat response="{\"errcode\":60020,\"errmsg\":\"not allow to access from your ip, hint: [1699178457562583222455115], from ip: 36.112.180.226, more info at https://open.work.weixin.qq.com/devtool/query?e=60020\"}" incident="{}:{alertname=\"kubernetes-etcd\"}" 解决方案：企业微信机器人添加企业可信IP 即可！
但是但是，第一次配置可信IP地址，需要先配置设置接收消息服务器URL，步骤如下：
打开一台有公网IP的服务器，进行下面操作：
wget https://github.com/sbzhu/weworkapi_python/archive/refs/heads/master.zip unzip master.zip mv weworkapi_python-master weworkapi_python vim wechat.py #-*- encoding:utf-8 -*- from flask import abort, request from flask import Flask from xml.dom.minidom import parseString import _thread import time import os import sys sys.path.append("weworkapi_python/callback") # 正确的模块导入路径 from WXBizMsgCrypt3 import WXBizMsgCrypt # https://github.com/sbzhu/weworkapi_python 项目地址 app = Flask(__name__) # 对应步骤4中接受消息回调模式中的URL，如域名是'www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66c673edfec23875b8525521a602ff73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b61e5c8843584328ae8d5df2b18d639/" rel="bookmark">
			CRUD增删改查，MySql Druid简化代码封装增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识常用的jar包 connection（Driver接口实现的jar包），druid（数据库池管理包），commons-dbutils（简化jdbc数据库的增删改查操作,并且可以封装查询到的结果，同时简化了事务管理）
认识几个常用的类和接口 Driver接口-&gt;提供给数据库厂商使用，把需要用到的数据库驱动程序或者类库加载到项目的classpath（jar）包中
DriverManager类-&gt;用于加载JDBC驱动并创建于数据库的连接，创建驱动最常使用的是Class类的静态方法forName()来实现，但是在jdk4.0之后就不需要手动加载了（在配置文件里面写 driverClass=com.mysql.jdbc.Driver），连接数据库最长使用的方法是getConnection建立连接，返回一个Connection对象
Connection接口可以与数据库进行交互，有了这个对象就可以在进行事务的处理，以及对数据库的增删改查
认识配置文件里的几个参数 url-&gt;通过url可以选择正确的驱动程序，从而连接到我们需要的数据库。
由四部分组成：协议，子协议，子名称，其他参数，例如修改数据库事务为自动提交
配置文件的好处 配置信息需要修改的时候无须改动代码，并且维护简单，省去了配置信息编译的过程
增删改使用的PreparedStatement 对象调用executeUpdate（）
查询使用的是executeQuery（）
但是传统的JDBC连接比较麻烦，并且在对数据库进行增删改查的时候也是代码比较繁琐，因此引入了，druid（数据库池管理包），commons-dbutils（简化jdbc数据库的增删改查操作)
引入德鲁伊（Druid） druid里使用频率最高的是数据源接口DataSource(基于数据库连接池)，数据源调用getConnection()方法,可以说这种方式就是使用了连接池技术.DataSource内部封装了一个连接池,当你获取DataSource的时候,它已经悄悄的与数据库建立了多个Connection,并将这些Connection放入了连接池,此时调用DataSource.getConnection()它从连接池里取一个Connection返回,Connection使用完后被close,但这个close并不是真正的与数据库断开连接,而是告诉连接池"我"已经被使用完,"你"可以把我分配给其它"人"使用了.就这样连接池里的Connection被循环利用,避免了每次获取Connection时重新去连接数据库。
暴露数据源的原因 将数据源对象暴露出去的原因可能是为了让使用者能够更灵活地操作数据源，比如可以通过数据源对象获取一些元数据信息，或者使用数据源对象来创建其他类型的连接等。另外，有些情况下可能需要在不同的方法或类之间共享同一个数据源对象，这时候将数据源对象暴露出去就可以方便地实现这种共享。但是，在暴露数据源对象时需要注意安全性和封装性，避免使用者对数据源对象进行不合理的操作或者直接修改数据源对象的状态。
在这里学会到了两个新的反射方法 getGenericSuperclass()获取父类的类型，得到父类类型后。getActualTypeArguments()得到父类的泛型,在这里父类指的是抽象类（是增删改查的逻辑语句）。
先说说数据库的连接： 在配置文件中有必须的四个参数和其他参数，由于配置文件是键值对的方式，所以可以使用Properties来加载这个文件。
可以把数据库的连接操作单独成一个工具类，最主要的工具是数据源，使用DruidDataSourceFactory.createDataSource(pro)这个方法创建数据源，通过数据源连接数据库.
封装CURD QueryRunner来自commons-dbutils这个jar包，用于简化增删改查的逻辑语句，无论哪个实体调用抽象类都可以，获取到泛型指定的类型就可以把得到的ResultSetHandler集合转成一个Bean实体进行封装。一般来说，增删改都需要用到事务处理，传入数据源，作为参数让QueryRunner对象知道要使用哪个数据库连接来执行查询操作，当使用QueryRunner进行操作的时候，传入数据源，会自动从数据源中获取一个数据库连接，并且在查询结束后，连接会被自动关闭和放回连接池，避免手动创建和管理数据库连接。
数据库连接的最终增删改查版本 package com.sun.utils; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; //创建一个数据源的工具类，此类得到数据源对象 public class JDBCUtils { private static DruidDataSource dataSource; static { try { Properties properties = new Properties(); // 读取 jdbc.properties 属性配置文件 InputStream inputStream = JDBCUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b61e5c8843584328ae8d5df2b18d639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357681e83b669bd4ba4f83e744c290fc/" rel="bookmark">
			VS Code 终于实现了这个特性，撒花！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 你好，我是 EarlGrey，一名双语学习者，会一点编程，目前已翻译出版《Python 无师自通》、《Python 并行编程手册》等书籍。
在这里，我会持续和大家分享好书、好工具和高效生活、工作技巧，欢迎大家一起提升认知思维和人生效率。
都快 2024 年了，现在谁家没有块超大屏幕，或者多个屏幕呀！
早在 2016 年，就有开发者提出 Feature Request，希望 VS Code 可以支持浮动窗口，充分利用屏幕空间或多显示器。
FR 提出后，很快得到数千人赞同，期间帖子也增长到 300 多条，可见这一特性的呼声之高。
https://github.com/microsoft/vscode/issues/10121
7 年后，开发者呼声极高的 VS Code “浮动窗口” 特性，终于实现了。
就在近期发布的 VS Code October 2023 (version 1.84) 更新中，开发团队实现了对浮动窗口的支持（预览特性）：
VS Code 团队也开心地在 issue 最后 “结帖”。
如何启用新功能？ 目前这一特性还不稳定，但 VS Code 团队有信心在近期的稳定版本发布。
现在可以通过安装 VS Code Insiders （下载地址：https://code.visualstudio.com/insiders/），然后在编辑器中运行命令 View: Move Active Editor into a New Window，即可在浮动窗口中打开编辑器。
如果你正好有一块大屏幕或者多个显示器，一定不要错过开启这项新特性哦。
往期推荐：
有了它，再也不存在信息差了
做读书笔记时的一个高效小技巧
普通人创业必读的第一本书
早起，比熬夜更可怕
做读书笔记时的一个高效小技巧
↓ 戳，阅读原文看「更多好书推荐」 分享、在看、点赞，3连 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97f7895ecfe555376ef1d8d2f7668c9/" rel="bookmark">
			Keil MDK5解决error: L6002U: Could not open file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/weixin_44097539/article/details/124798550这里参考了这位的做法 ，确实是电脑命名的时候使用了中文，但运行后还是报错，查看电脑实际命名，我的命名是Default，这里隐藏了需要设置可见文件夹所以改下环境变量再改下就行
Keil5完美编译
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc4d3448f71857f3d06894d5d3284c1/" rel="bookmark">
			【HBZ分享】ES中的DLS命令使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES中常见的DLS关键字及命令的使用案例 match：匹配关键字，包含分词的模糊匹配，以及精准匹配 title: 字段的名称， elasticsearch要查的内容，即查询title中带有elasticsearch的文档 GET /索引库名/_search { "query": { "match": { "title": "elasticsearch" } } } term：用于精确匹配一个指定字段的关键词，不进行分词处理。 category: 字段的名称， books要查的内容， 即查询category = books的文档 GET /索引库名/_search { "query": { "term": { "category": "books" } } } match_all: 全量查询，一般很少用，所有数据全都查出来 match_all后面的大括号就这么写就行，啥也不需要加 GET /shop_v1/_search { "query": { "match_all": {} } } es中的分页 以及 范围查询 gte:大于等于
gt:大于
lte:小于等于
lt:小于
范围擦汗寻， 查询price在5-10之间的数据 GET /shop_v1/_search { "query": { "range": { "price": { "gte": 5, "lte": 100 } } } } 分页查询， size = 每次查询的条数， from = 从第几条开始查 GET /shop_v1/_search { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cc4d3448f71857f3d06894d5d3284c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f30d9665e9356ff6c5f89071b1477f/" rel="bookmark">
			html将复选框变为圆形样例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html将复选框变为圆形样例 说明目录使用对勾图标实现圆形复选框原复选框html代码及默认样式取消复选框未勾选前的样式新增复选框未勾选前的样式新增复选框勾选后的样式获取复选框选中后的value值 使用CSS样式写对勾图标实现圆形复选框 说明 这里记录下用原生html实现将原复选框默认的正方形改为圆形的样例。一共2种方法，第一种是使用对勾图标实现，第二种是自己写CSS样式画一个对勾实现。
目录 一个样例demo,一个对勾图标。
使用对勾图标实现圆形复选框 原复选框html代码及默认样式 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;html将复选框改为圆形样例&lt;/title&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;script type="text/javascript"&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="checkbox" name="test" value="哈哈1"&gt;哈哈 &lt;/body&gt; &lt;/html&gt; 页面效果如下:
取消复选框未勾选前的样式 使用appearance:none;取消复选框默认样式。
appearance属性允许将HTML元素设置成使元素看上去像标准的用户界面元素。该属性支持如下常用的属性值 none:不使用任何界面外观效果 button:将元素设置成按钮的外观效果 checkbox:将元素设置成复选框的外观效果 push-button:将按钮设置成push按钮的外观效果 radio:将元素设置成单选钮的外观效果 searchfield:将元素设置成输入框的外观效果 searchfield-cancel-button:将元素设置成输入框内取消按钮的外观效果 slider-horizontal:将元素设置成水平拖动条的外观效果 slider-vertical:将元素设置成垂直拖动条的外观效果 sliderhumb-horizontal:将元素设置成水平拖动条的滑块的外观效果 sliderhumb-vertical:将元素设置成垂直拖动条的滑块的外观效果 square-button:将按钮设置成square按钮的外观 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;html将复选框改为圆形样例&lt;/title&gt; &lt;style type="text/css"&gt; /*复选框未勾选前的样式*/ input[type="checkbox"]{	appearance:none;/*取消默认的复选框样式*/ } &lt;/style&gt; &lt;script type="text/javascript"&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="checkbox" name="test" value="哈哈1"&gt;哈哈1&lt;br/&gt; &lt;/body&gt; &lt;/html&gt; 页面效果如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f30d9665e9356ff6c5f89071b1477f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dae91f264f81a47db573b6ce342ced43/" rel="bookmark">
			python实现TCP服务端程序开发（含源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发介绍 TCP 网络应用程序开发分为:
TCP 客户端程序开发
TCP 服务端程序开发
说明:
客户端程序是指运行在用户设备上的程序
服务端程序是指运行在服务器设备上的程序，专门为客户端提供数据服务。
TCP开发流程示意图 TCP服务端开发流程： 创建服务端套接字对象：使用socket函数创建一个TCP套接字对象（例如，使用Python中的socket模块创建套接字对象）。
绑定端口号：使用bind函数将服务端套接字绑定到一个特定的IP地址和端口号上。
设置监听：使用listen函数开始监听客户端连接请求。可以指定监听队列的长度，表示可以同时处理的等待连接的最大数量。
等待接受客户端的连接请求：使用accept函数阻塞等待客户端的连接请求。一旦有客户端连接，accept函数会返回一个新的套接字对象，用于与该客户端进行通信。
接收数据：使用recv函数从客户端套接字接收数据。可以指定要接收的数据的最大长度。
发送数据：使用send函数将数据发送给客户端。可以发送指定长度的数据，也可以发送完整的字节串。
关闭套接字：使用close函数关闭服务端套接字和与客户端连接的套接字，释放资源。
需要注意的是，TCP服务端可以是一个循环结构，通过不断地等待新的连接请求和处理已连接客户端的数据来实现长时间运行。在处理多个客户端连接时，可以使用多线程、多进程或异步I/O等技术来实现并发处理。
send和recv 发送接收缓冲区 当创建一个TCP socket对象的时候会有一个发送缓冲区和一个接收缓冲区，这个发送和接收缓冲区指的就是内存中的一片空间。
每个TCP socket都有自己的发送缓冲区和接收缓冲区，它们是独立的，互不干扰。
发送缓冲区和接收缓冲区的大小可以通过设置socket选项来调整，不过一般情况下会使用操作系统默认的大小。这些缓冲区的大小对于TCP的性能和吞吐量有一定的影响，过小的缓冲区可能导致数据丢失或阻塞，而过大的缓冲区可能造成内存资源浪费。
send函数 send函数在应用程序中被调用时，它将数据写入发送缓冲区中，然后由操作系统负责将发送缓冲区中的数据发送到服务端。
send函数会将数据复制到发送缓冲区中，并向操作系统发起发送请求。操作系统会将发送缓冲区的数据复制到网络设备的发送队列中，然后由设备驱动程序控制网卡将数据发送给服务端。
需要注意的是，在发送数据时，操作系统可能会对数据进行分片，并根据网络状况和拥塞情况决定发送的速率。此外，send函数是一个阻塞函数，如果发送缓冲区已满，应用程序的发送操作可能会被阻塞，直到有足够的空间来写入数据。
在实际使用中，建议使用非阻塞I/O或异步I/O来处理发送操作，以避免阻塞整个应用程序的执行。
recv函数 recv函数在应用程序中被调用时，它会从接收缓冲区读取数据，并返回给应用程序使用。
具体来说，当数据到达网络设备时，操作系统会将数据复制到接收队列中，并通知应用程序有数据可读。应用程序调用recv函数时，操作系统将接收缓冲区中的数据复制到应用程序的缓冲区中，并返回实际读取的数据长度。
这种方式将数据接收的过程从应用程序的地址空间转移到操作系统的地址空间，以提高数据接收的效率。操作系统更高效地管理网络设备和底层协议栈，因此能够更好地处理接收数据的任务。
需要注意的是，recv函数是一个阻塞函数，如果接收缓冲区没有数据可读，应用程序的接收操作可能会被阻塞，直到有数据到达并可用。
在实际使用中，建议使用非阻塞I/O或异步I/O来处理发送操作，以避免阻塞整个应用程序的执行。
总结 无论是发送数据还是接收数据，都是通过发送缓冲区和接收缓冲区的中间操作，而最终的数据传输是由操作系统控制网卡来完成的。
发送数据时，应用程序将数据写入发送缓冲区，然后操作系统通过网卡将发送缓冲区的数据发送给对方。接收数据时，操作系统从网卡接收数据，并将数据写入接收缓冲区，应用程序再从接收缓冲区读取数据进行处理。
这种通过缓冲区操作的方式，使得数据的发送和接收能够高效地在应用程序和操作系统之间进行交互，同时也提供了数据的可靠性和可控性。
TCP服务端程序开发 服务端开发步骤 创建服务端端套接字对象
绑定端口号
设置监听
等待接受客户端的连接请求
接收数据
发送数据
关闭套接字
使用python构造服务端 socket 类的介绍 导入 socket 模块
import socket 创建服务端 socket 对象
tcp_server_socket = socket.socket(AddressFamily, Type) 参数说明:
AddressFamily 表示IP地址类型, 分为TPv4和IPv6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dae91f264f81a47db573b6ce342ced43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54940799d1a4b4ef18209ad774c6c06/" rel="bookmark">
			Beyond Compare 4对比工具的密钥解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲测好用，其他方法删除文件夹方法无效（删除后启动会自动生成）
修改注册表
1、在搜索栏中输入 regedit ，打开注册表
2、删除项目CacheId ：
HKEY_CURRENT_USER\Software\Scooter Software\Beyond Compare 4\CacheId
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3de15dfcf0dcac2e91447076edec195/" rel="bookmark">
			看！MySQL 8.2 数据库支持读写分离啦！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多文章，欢迎关注作者公众号，欢迎一起交流。 MySQL 8.2.0创新版本已于2023-10-17发布，MySQL Router 8.2 支持数据库的读/写分离，这里将在InnoDB Cluster集群中演示数如何进行读写分离，本篇内容包括：MySQL Server数据库安装、MySQL Shell安装、MySQL Router安装、InnoDB Cluster安装与读写分离演示，若您只关注读写分离的演示，可直接跳至最后章节。
1 数据库环境 数据库环境为：
环境详情
节点1
节点2
节点3
Server IP
192.168.56.101
192.168.56.102
192.168.56.103
Hostname
clusternode01
clusternode02
clusternode03
Server ID
56101
56102
56103
DB Version
MySQL 8.2
MySQL 8.2
MySQL 8.2
OS
Redhat 8.7
Redhat 8.7
Redhat 8.7
2 数据库安装 分别在clusternode01、clusternode02、clusternode03节点安装MySQL数据库软件并初始化数据库，这里以在节点clusternode01为例进行创建，具体过程为：
1）关闭防火墙
关闭防火墙，并修改/etc/selinux/config文件的SELINUX值为disabled：
[root@clusternode01 ~]# systemctl status firewalld [root@clusternode01 ~]# systemctl stop firewalld [root@clusternode01 ~]# systemctl disable firewalld 2）安装数据库软件所需的软件包
安装libaio库，该libaio库是数据目录初始化和后续服务器启动所需：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3de15dfcf0dcac2e91447076edec195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868284e928909d9572228680224453c8/" rel="bookmark">
			Python的max()min()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		min() max()
函数可以接受多个参数
作用：1.比较数字大小
2.比较字符串大小
使用min()或者max()函数比较字符串时，它会按照字符的ASCII码值进行比较。
例如：s=["seashell","gold","pink","brown","purple","tomato"]print(len(s),min(s),max(s))
输出是6 brown tomato.
如果字符串中的字符全部相同，则函数会返回第一个字符，因为它们的ASCII码值相同。
字符串比较是按照字符的顺序逐个比较，而不是按照字符串的长度进行比较。就像"seashell"比"tomato"字符长，但是max(s)输出的是tomato。因为t的ASCII码比s大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b98ea9f3cfa92cd9a6c9cbae09e57679/" rel="bookmark">
			华为政企网络安全产品集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 产品类型产品型号产品说明 防火墙及应用安全网关ASG5505ASG5000系列上网行为管理产品（以下简称“ASG5000”）是华为面向各类企业、政府、大中型数据中心以及各类无线非经营性场所推出的业界领先的综合上网行为管理产品。
该系列产品可深度识别、管控和审计IM聊天软件、P2P下载软件、炒股软件、网络游戏应用、流媒体在线视频应用等几千种常见应用，并利用多级流控、精准阻断、智能路由等技术提供强大的带宽管理特性。配合创新的网络应用行为精细化管理功能和清晰的易管理日志等功能。
该产品可以帮助企业及各类机构提升员工工作效率、营造安全办公环境，为用户提供一套综合、完善的上网行为审计解决方案。防火墙及应用安全网关ASG5510ASG5000系列上网行为管理产品（以下简称“ASG5000”）是华为面向各类企业、政府、大中型数据中心以及各类无线非经营性场所推出的业界领先的综合上网行为管理产品。
该系列产品可深度识别、管控和审计IM聊天软件、P2P下载软件、炒股软件、网络游戏应用、流媒体在线视频应用等几千种常见应用，并利用多级流控、精准阻断、智能路由等技术提供强大的带宽管理特性。配合创新的网络应用行为精细化管理功能和清晰的易管理日志等功能。
该产品可以帮助企业及各类机构提升员工工作效率、营造安全办公环境，为用户提供一套综合、完善的上网行为审计解决方案。防火墙及应用安全网关ASG5520ASG5000系列上网行为管理产品（以下简称“ASG5000”）是华为面向各类企业、政府、大中型数据中心以及各类无线非经营性场所推出的业界领先的综合上网行为管理产品。
该系列产品可深度识别、管控和审计IM聊天软件、P2P下载软件、炒股软件、网络游戏应用、流媒体在线视频应用等几千种常见应用，并利用多级流控、精准阻断、智能路由等技术提供强大的带宽管理特性。配合创新的网络应用行为精细化管理功能和清晰的易管理日志等功能。
该产品可以帮助企业及各类机构提升员工工作效率、营造安全办公环境，为用户提供一套综合、完善的上网行为审计解决方案。防火墙及应用安全网关ASG5530ASG5000系列上网行为管理产品（以下简称“ASG5000”）是华为面向各类企业、政府、大中型数据中心以及各类无线非经营性场所推出的业界领先的综合上网行为管理产品。
该系列产品可深度识别、管控和审计IM聊天软件、P2P下载软件、炒股软件、网络游戏应用、流媒体在线视频应用等几千种常见应用，并利用多级流控、精准阻断、智能路由等技术提供强大的带宽管理特性。配合创新的网络应用行为精细化管理功能和清晰的易管理日志等功能。
该产品可以帮助企业及各类机构提升员工工作效率、营造安全办公环境，为用户提供一套综合、完善的上网行为审计解决方案。防火墙及应用安全网关ASG5550ASG5000系列上网行为管理产品（以下简称“ASG5000”）是华为面向各类企业、政府、大中型数据中心以及各类无线非经营性场所推出的业界领先的综合上网行为管理产品。
该系列产品可深度识别、管控和审计IM聊天软件、P2P下载软件、炒股软件、网络游戏应用、流媒体在线视频应用等几千种常见应用，并利用多级流控、精准阻断、智能路由等技术提供强大的带宽管理特性。配合创新的网络应用行为精细化管理功能和清晰的易管理日志等功能。
该产品可以帮助企业及各类机构提升员工工作效率、营造安全办公环境，为用户提供一套综合、完善的上网行为审计解决方案。防火墙及应用安全网关HiSecEngine IPS6585F入侵防御产品HiSecEngine IPS6000F系列产品是华为推出的新一代专业入侵防御产品，在传统IPS产品的基础上进行了扩展：采用全新软硬件架构，增加网络环境感知能力、深度应用感知能力、内容感知能力，以及对未知威胁的防御能力，实现了更精准的检测能力、更优化的管理体验。
HiSecEngine IPS6000F系列入侵防御产品主要应用于企业、IDC、校园网和运营商等，更好地保障客户应用和业务安全，实现对网络基础设施、服务器、客户端以及网络带宽性能的全面防护。防火墙及应用安全网关HiSecEngine IPS6615F入侵防御产品HiSecEngine IPS6000F系列产品是华为推出的新一代专业入侵防御产品，在传统IPS产品的基础上进行了扩展：采用全新软硬件架构，增加网络环境感知能力、深度应用感知能力、内容感知能力，以及对未知威胁的防御能力，实现了更精准的检测能力、更优化的管理体验。
HiSecEngine IPS6000F系列入侵防御产品主要应用于企业、IDC、校园网和运营商等，更好地保障客户应用和业务安全，实现对网络基础设施、服务器、客户端以及网络带宽性能的全面防护。防火墙及应用安全网关HiSecEngine IPS6625F入侵防御产品HiSecEngine IPS6000F系列产品是华为推出的新一代专业入侵防御产品，在传统IPS产品的基础上进行了扩展：采用全新软硬件架构，增加网络环境感知能力、深度应用感知能力、内容感知能力，以及对未知威胁的防御能力，实现了更精准的检测能力、更优化的管理体验。
HiSecEngine IPS6000F系列入侵防御产品主要应用于企业、IDC、校园网和运营商等，更好地保障客户应用和业务安全，实现对网络基础设施、服务器、客户端以及网络带宽性能的全面防护。防火墙及应用安全网关HiSecEngine IPS6655F入侵防御产品HiSecEngine IPS6000F系列产品是华为推出的新一代专业入侵防御产品，在传统IPS产品的基础上进行了扩展：采用全新软硬件架构，增加网络环境感知能力、深度应用感知能力、内容感知能力，以及对未知威胁的防御能力，实现了更精准的检测能力、更优化的管理体验。
HiSecEngine IPS6000F系列入侵防御产品主要应用于企业、IDC、校园网和运营商等，更好地保障客户应用和业务安全，实现对网络基础设施、服务器、客户端以及网络带宽性能的全面防护。maintainProductHiSecEngine USG6510E桌面款防火墙华为HiSecEngine USG6500E系列(桌面型)是为小型企业、行业分支、连锁商业机构设计开发的新一代的桌面型AI防火墙，除了传统防火墙管理模式，还支持云管模式。云管模式为大量分支机构安全接入网络提供了即插即用、业务配置自动化、运维自动化可视化和网络大数据分析等优势。产品提供模式匹配以及加解密业务处理加速能力，使得防火墙处理内容安全检测、IPSec等业务的性能显著提升。广泛适用于教育、医疗、零售等行业。防火墙及应用安全网关HiSecEngine USG6525E千兆盒式防火墙华为HiSecEngine USG6500E系列(盒式)是面向中小企业和连锁机构推出的企业级AI防火墙，在提供NGFW能力的基础上，联动其他安全设备，主动积极防御网络威胁，增强边界检测能力，有效防御高级威胁，同时解决性能下降问题。产品提供模式匹配以及加解密业务处理加速能力，使得防火墙处理内容安全检测、IPSec等业务的性能显著提升。支持联动华为乾坤安全云服务，提供边界防护与响应、漏洞扫描、日志审计等服务，端云联动，立体防御。广泛适用于教育、医疗、零售等行业。防火墙及应用安全网关HiSecEngine USG6530E桌面款防火墙华为HiSecEngine USG6500E系列(桌面型)是为小型企业、行业分支、连锁商业机构设计开发的新一代的桌面型AI防火墙，除了传统防火墙管理模式，还支持云管模式。云管模式为大量分支机构安全接入网络提供了即插即用、业务配置自动化、运维自动化可视化和网络大数据分析等优势。产品提供模式匹配以及加解密业务处理加速能力，使得防火墙处理内容安全检测、IPSec等业务的性能显著提升。广泛适用于教育、医疗、零售等行业。maintainProductHiSecEngine USG6555E桌面款防火墙防火墙及应用安全网关|2个10GE以太网光接口+8个GE光电互接口 Combo+2个10/100/1000M自适应以太网电接口|1U盒式|选配硬盘，支持M.2卡，240G |选配冗余电源|吞吐量4Gbits|最大并发连接400万|每秒新建连接7.8万|SSL VPN最大并发用户数1000个|IPSec VPN隧道4000个|IPSec吞吐量4Git/s|虚拟防火墙100个|应用识别|智能选路防火墙及应用安全网关HiSecEngine USG6565E千兆盒式防火墙华为HiSecEngine USG6500E系列(盒式)是面向中小企业和连锁机构推出的企业级AI防火墙，在提供NGFW能力的基础上，联动其他安全设备，主动积极防御网络威胁，增强边界检测能力，有效防御高级威胁，同时解决性能下降问题。产品提供模式匹配以及加解密业务处理加速能力，使得防火墙处理内容安全检测、IPSec等业务的性能显著提升。支持联动华为乾坤安全云服务，提供边界防护与响应、漏洞扫描、日志审计等服务，端云联动，立体防御。广泛适用于教育、医疗、零售等行业。防火墙及应用安全网关HiSecEngine USG6585E千兆盒式防火墙华为HiSecEngine USG6500E系列(盒式)是面向中小企业和连锁机构推出的企业级AI防火墙，在提供NGFW能力的基础上，联动其他安全设备，主动积极防御网络威胁，增强边界检测能力，有效防御高级威胁，同时解决性能下降问题。产品提供模式匹配以及加解密业务处理加速能力，使得防火墙处理内容安全检测、IPSec等业务的性能显著提升。支持联动华为乾坤安全云服务，提供边界防护与响应、漏洞扫描、日志审计等服务，端云联动，立体防御。广泛适用于教育、医疗、零售等行业。安全云服务USG6501E-C为乾坤安全云服务天关USG6500E-C系列，是专门面向中小企业推出的边界防护设备，通过本地天关+云端AI分析处置能力，有效检测拦截攻击行为，快速识别失陷主机、恶意文件和外部攻击源，同时还支持漏洞扫描、日志审计、EDR等服务，云边端联动，立体防御。广泛适用于教育、医疗、零售等行业安全云服务USG6502E-C为乾坤安全云服务天关USG6500E-C系列，是专门面向中小企业推出的边界防护设备，通过本地天关+云端AI分析处置能力，有效检测拦截攻击行为，快速识别失陷主机、恶意文件和外部攻击源，同时还支持漏洞扫描、日志审计、EDR等服务，云边端联动，立体防御。广泛适用于教育、医疗、零售等行业安全云服务USG6503E-C为乾坤安全云服务天关USG6500E-C系列，是专门面向中小企业推出的边界防护设备，通过本地天关+云端AI分析处置能力，有效检测拦截攻击行为，快速识别失陷主机、恶意文件和外部攻击源，同时还支持漏洞扫描、日志审计、EDR等服务，云边端联动，立体防御。广泛适用于教育、医疗、零售等行业安全云服务USG6603F-C为乾坤安全云服务天关USG6600F-C系列，是专门面向中小企业推出的边界防护设备，通过本地天关+云端AI分析处置能力，有效检测拦截攻击行为，快速识别失陷主机、恶意文件和外部攻击源，同时还支持漏洞扫描、日志审计、EDR等服务，云边端联动，立体防御。广泛适用于教育、医疗、零售等行业安全云服务边界防护与响应-专业版边界防护与响应-专业版安全云服务边界防护与响应-基础版边界防护与响应-基础版DDoS攻击防御AntiDDoS1905华为AntiDDoS1000系列DDoS防御系统运用大数据分析技术，针对60多种网络流量进行抽象建模，秒级攻击响应速度和超百种攻击的全面防御。适用于金融、政府、教育、大企业、IDC等各行业客户。
AntiDDoS1000可以灵活部署在用户网络中，实时防御流量型攻击和应用层攻击。当攻击流量超过带宽或本地清洗设备防御能力时，AntiDDoS1000可以与上游运营商或ISP的AntiDDoS设备联动，防御大流量攻击，保护用户业务永续。DDoS攻击防御AntiDDoS1908华为AntiDDoS1000系列DDoS防御系统运用大数据分析技术，针对60多种网络流量进行抽象建模，秒级攻击响应速度和超百种攻击的全面防御。适用于金融、政府、教育、大企业、IDC等各行业客户。
AntiDDoS1000可以灵活部署在用户网络中，实时防御流量型攻击和应用层攻击。当攻击流量超过带宽或本地清洗设备防御能力时，AntiDDoS1000可以与上游运营商或ISP的AntiDDoS设备联动，防御大流量攻击，保护用户业务永续。大数据分析及APT防御FireHunter6300FireHunter沙箱 | 4个GE、2个10GE | 2*8核/2.1GHz CPU | 4*4000GB-SATA +2*240GB-SSD | 8*32GB内存。安全管理LogAuditor1520华为HiSec LogAuditor1500系列日志审计系统作为统一的日志采集与审计平台，通过对网络设备、安全设备、主机和应用系统曰志进行全面标准化处理，及时发现各种安全威胁和异常行为事件；基于标准化关联分析引擎，提供全维度、跨设备、细粒度的关联分析，确保事件可追溯；支持资产统一管理和实时监控，全面审计系统安全状况。适用于政府、电力、企业、教育、医疗等各行业客户。安全管理LogAuditor1580华为HiSec LogAuditor1500系列日志审计系统作为统一的日志采集与审计平台，通过对网络设备、安全设备、主机和应用系统曰志进行全面标准化处理，及时发现各种安全威胁和异常行为事件；基于标准化关联分析引擎，提供全维度、跨设备、细粒度的关联分析，确保事件可追溯；支持资产统一管理和实时监控，全面审计系统安全状况。适用于政府、电力、企业、教育、医疗等各行业客户。安全管理SecoManagerSecoManager是华为面向数据中心、园区等不同场景推出的安全控制器，可实现全网安全策略集中管理、安全业务编排和高性能日志管理。
SecoManager通过用户业务分区和应用的业务编排，自动完成安全策略的生成与部署，实现安全业务分钟级部署，有效降低安全运维成本。SecoManager协同SDN控制器和HiSec Insight安全态势感知系统联动，将威胁分钟级闭环处置，大幅提升企业网络的威胁防御能力，帮助企业构建全网主动防御体系。适用于政府、金融、电力、大企业、教育、医疗等各行业客户。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1520fa34cc629f41980835fcb7e077c2/" rel="bookmark">
			Python123：使用函数输出指定范围内的Fibonacci数、使用函数验证哥德巴赫猜想（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、使用函数输出指定范围内的Fibonacci数2、使用函数验证哥德巴赫猜想 1、使用函数输出指定范围内的Fibonacci数 题目： 本题要求实现一个计算Fibonacci数的简单函数，并利用其实现另一个函数，输出两正整数m和n（0&lt;m≤n≤10000）之间的所有Fibonacci数。所谓Fibonacci数列就是满足任一项数字是前两项的和（最开始两项均定义为1）的数列。
函数接口定义：
int fib( int n ); void PrintFN( int m, int n ); 其中函数fib须返回第n项Fibonacci数；函数PrintFN要在一行中输出给定范围[m, n]内的所有Fibonacci数，相邻数字间有一个空格，行末不得有多余空格。如果给定区间内没有Fibonacci数，则输出一行“No Fibonacci number”。
裁判测试程序样例：
#include &lt;stdio.h&gt; int fib( int n ); void PrintFN( int m, int n ); int main() { int m, n, t; scanf("%d %d %d", &amp;m, &amp;n, &amp;t); printf("fib(%d) = %d\n", t, fib(t)); PrintFN(m, n); return 0; } /* 你的代码将被嵌在这里，与上述测试代码一起提交 */ 输入样例1：
20 100 7 输出样例1：
fib(7) = 13 21 34 55 89 输入样例2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1520fa34cc629f41980835fcb7e077c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854194bd30b876da82b7c49405d61a63/" rel="bookmark">
			C语言数组详解（超详细！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数组的概念 数组是一段相同类型元素的集合。从中有两个限制条件
1、数组存放的是1个或者多个元素，且元素个数不能为0。
2、数组存放的多个元素的类型必须相同。
数组可以分为一维数组和多维数组，多维数组其中二维数组最常用。
二、一维数组的创建 1、数组创建 一维数组创建的基本语法如下：
type arr_name[常量值]； 存放在数组中的值称为元素，数组的大小和数组的元素类型是在数组创建的时候来规定的。
type指定的是数组的元素类型，比如 int 代表元素都是整型，还可以是：char、short、int、float等，还可以是自己定义的类型。
arr_name指定的是数组的名字，没有什么特殊的要求，只要起的有意义就可以了。
[ ]中的常量值是⽤来指定数组的大小的，这个数组的大小是根据实际的需求指定就可以了。
我们来举个例子去创建一个数组，假如我们要储存一周内每一天的消费，数组如下：
int consumption[7]; 2、数组初始化 有的时候，数组在创建的时候需要给定一些值，这就叫做初始化。
那么我们该如何给定他们值来初始化呢？代码如下 ：
int arr1[5] = {1,2,3,4,5}; int arr2[5] = {1}; int arr3[5] = {1,2,3,4,5,6}; 数组的初始化需要后面的大括号来定义 。
第一行代表的是完全初始化，给定了数组中全部的元素相应的值。
第二行则代表的是不完全初始化，数组中的值第一个为1，其他的默认为0。
第三行则是错误的初始化，初始化的项太多。
3、数组的类型 数组是有类型的，数组其实算是一种自定义类型，去除掉数组的名字就是他们的类型。
简单拿代码来举例吧
int arr1[5]; int arr2[20]; char ch[5]; 其中arr1的数组类型就是 int [5]
arr2的数组类型就是int[20]
ch的数组类型就是char[5]
三、一维数组的使用 1、数组下标 C语言中规定在数组中每一个元素下面都会对应一个下标，下标从0开始，假设一个数组中有n个元素，那么对应的下标就是n-1，如下
int arr[10] = {1,2,3,4,5,6,7,8,9,10} V V V V V V V V V V V V V V V V V V V V 下标： 0 1 2 3 4 5 6 7 8 9 C语言中的[ ]其实叫做：下标引用操作符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/854194bd30b876da82b7c49405d61a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/967664f64fed83d339fe5f9da393211a/" rel="bookmark">
			数据结构与算法 | 第三章：栈与队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考网课为 数据结构与算法 1 第三章栈，主讲人 张铭 、王腾蛟 、赵海燕 、宋国杰 、邹磊 、黄群。
本文使用IDE为 Clion，开发环境 C++14。
更新：2023 / 11 / 5
数据结构与算法 | 第三章：栈与队列 栈概念示例 实现顺序栈类定义进出栈进栈出栈 链式栈类定义进出栈进栈出栈 顺序栈 V.S 链式栈 应用表达式求值中缀表达式概念 后缀表达式概念示例对后缀表达式求值中缀表达式转换为后缀表达式 递归概念递归、迭代递归函数尾递归 示例阶乘函数的调用栈递归到非递归的转换 通用的机械转换步骤 队列概念实现顺序队列类定义 链式队列类定义 顺序队列 V.S 链式队列 应用宽度优先搜索示例：人狼羊菜过河初步分析最终分析 参考链接 线性表 可以在表的任意位置进行元素的插入、删除等运算。而 栈（ Stack ）的运算只在表的一端进行，队列（ Queue ）的运算只在表的两端进行，因此可以将 栈 与 队列 视为操作受限的 线性表。
栈 概念 栈 是一种限制访问端口的 线性表，后进先出（ Last In First Out ）。
栈 的主要操作有 进栈（ push ）和 出栈（ pop ）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/967664f64fed83d339fe5f9da393211a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16af86e1cba5d9632a92e7601ad8da02/" rel="bookmark">
			数据结构-各章节-思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构-各章总结-思维导图篇 第一章 绪论第二章 线性表第三章 栈、队列和数组第四章 串第五章 树与二叉树第六章 图第七章 查找第八章 排序各文章-关联链接 第一章 绪论 数据结构-第一章-思维导图缩略图展示如下图1所示：
图1 第二章 线性表 数据结构-第二章-思维导图缩略图展示如下图2所示：
图2 第三章 栈、队列和数组 数据结构-第三章-栈和队列-思维导图缩略图展示如下图3所示：
图3 第四章 串 数据结构-第四章-串-思维导图缩略图展示如下图4所示：
图4 第五章 树与二叉树 数据结构-第五章-树与二叉树-思维导图缩略图展示如下图5所示：
图5 第六章 图 数据结构-第六章-图-思维导图缩略图展示如下图6所示：
图6 第七章 查找 数据结构-第七章-查找-思维导图缩略图展示如下图7所示：
图7 第八章 排序 数据结构-第八章-排序-各排序算法总结展示如下图8所示：
图8 各文章-关联链接 1、数据结构-第一章-时间复杂度示例-对应文章链接为：数据结构-第一章-时间复杂度示例
2、数据结构-第二章-线性表思维导图+小结-对应文章链接为：数据结构-第二章-线性表思维导图+小结
3、数据结构-第三章-栈和队列+串-思维导图-对应文章链接为：数据结构-第三章-栈和队列+串-思维导图
3.1、数据结构-中缀表达式转后缀表达式-对应文章链接为：数据结构-中缀表达式转后缀表达式
4、数据结构-第四章-串对应文章及本章：数据结构-思维导图
5、数据结构-第五章-树与二叉树-思维导图-对应文章链接为：数据结构-第五章-树与二叉树-思维导图
5.1、数据结构-平衡二叉树示例-对应文章链接为：数据结构-平衡二叉树示例
6、数据结构-第六章-图-思维导图+小结-对应文章链接为：数据结构-图-思维导图+小结
7、数据结构-第七章-查找-思维导图+小结-对应文章链接为：数据结构-第七章-查找-思维导图+小结
7.1、数据结构-B树删除示例-对应文章链接为：数据结构-B树删除示例
7.2、数据结构-红黑树插入结点示例-对应文章链接为：数据结构-红黑树插入结点示例
8、数据结构-第八章-各排序算法示例-对应文章链接为：数据结构-第八章-各排序算法示例
以上是本人学习《数据结构》的所有学习记录，希望有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9e50b4f006b9cf89c37dac88935ed6/" rel="bookmark">
			数据结构-排序-示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据结构-排序-示例 1、在线可视化排序工具2、各排序算法示例2.1、直接插入排序2.2、希尔排序2.3、冒泡排序2.4、快速排序2.5、选择排序2.6、堆排序2.7、二路归并排序2.8、基数排序 3、各排序算法总结 1、在线可视化排序工具 网址是：https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html
2、各排序算法示例 关键字序列均为（41，71，84，82，51，7，71 ，39）
2.1、直接插入排序 数据结构-直接插入排序-展示如下图1所示：
图1 2.2、希尔排序 数据结构-希尔排序-展示如下图2所示：
图2 2.3、冒泡排序 数据结构-冒泡排序-展示如下图3所示：
图3 2.4、快速排序 数据结构-快速排序-展示如下图4所示：
图4 2.5、选择排序 数据结构-选择排序-展示如下图5所示：
图5 2.6、堆排序 数据结构-堆排序-展示如下图6所示：
图6 2.7、二路归并排序 数据结构-二路归并排序-展示如下图7所示：
图7 2.8、基数排序 数据结构-基数排序-展示如下图8所示：
图8 3、各排序算法总结 数据结构-各排序总结-展示如下图9所示：
图9 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2717dbe271c74c2ad1b80f29f212f80b/" rel="bookmark">
			时间旅行：Java 中的 Date 和 DateFormat，以及现代日期时间处理最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言一、Date 类1. Date 类概述1.1 日期和时间的表示1.2 Java 中的 Date 类1.3 Date 对象的创建1.4 日期和时间的时区问题 2. Date 对象操作2.1 获取当前日期和时间2.2 获取毫秒数2.3 比较日期2.4 日期的格式化和解析2.5 Date 的可变性和不可变性 3. Date 类的问题3.1 Date 类存在的问题3.2 时区问题的处理3.3 Date 类和多线程问题 4. 替代方案 - java.time 包4.1 为什么要使用 java.time4.2 LocalDateTime、LocalDate 和其他类4.3 与 Date 类的比较4.4 处理时区的新方法 二、DateFormat 类1. DateFormat 类概述1.1 日期和时间的格式化和解析1.2 Java 中的 DateFormat 类1.3 不同国家和地区的日期格式1.4 使用不同日期样式 2. SimpleDateFormat 类2.1 格式化日期和时间2.2 自定义日期格式2.3 解析日期和时间字符串2.4 SimpleDateFormat 的线程安全问题和解决方案 3. DateFormat 类的线程安全问题3.1 DateFormat 对象的线程安全性3.2 SimpleDateFormat 的线程安全问题3.3 使用 ThreadLocal 解决线程安全问题 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2717dbe271c74c2ad1b80f29f212f80b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ec3bcba2c77ddf7896f942bc70c04b/" rel="bookmark">
			springboot/java/php/node/python家具网站【计算机毕设】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本系统（程序+源码）带文档lw万字以上 文末可领取本课题的JAVA源码参考
系统程序文件列表 系统的选题背景和意义 选题背景： 随着互联网的快速发展和人们生活水平的提高，家具行业也逐渐迎来了新的机遇和挑战。传统的实体家具店面受到了线上购物的冲击，越来越多的消费者开始倾向于在家中舒适地选择和购买家具。因此，建立一个专业的家具网站成为了家具行业发展的必然趋势。
选题意义： 建立一个家具网站能够为消费者提供更加便捷的购物体验。通过家具网站，消费者可以在不出门的情况下浏览和比较各种家具产品，从而节省时间和精力。同时，家具网站还可以提供详细的产品信息、用户评价和专业的购买指导，帮助消费者做出明智的购买决策。
家具网站对于家具行业的发展具有重要的推动作用。传统的实体店面受限于空间和地理位置等因素，无法展示大量的家具产品。而通过家具网站，家具企业可以将更多的产品展示给消费者，拓宽销售渠道，增加销售额。同时，家具网站还可以提供个性化定制服务，满足消费者对于个性化家具的需求，推动家具行业向高品质、高定制化方向发展。
家具网站还可以促进家具行业的创新和升级。通过互联网技术的应用，家具企业可以与设计师、供应商等各方资源进行深度合作，推出更加创新和有竞争力的产品。同时，家具网站还可以通过大数据分析和用户反馈等手段，了解消费者的需求和喜好，为产品研发和市场营销提供参考依据。
综上所述，建立一个专业的家具网站对于家具行业来说具有重要的意义。它不仅能够提升消费者的购物体验，推动家具行业的发展，还能促进创新和升级。因此，家具企业应积极借助互联网的力量，建立起自己的家具网站，抓住机遇，迎接挑战。
运行环境 开发工具：idea/eclipse/myeclipse
数据库：mysql5.7或8.0
操作系统：win7以上，最好是win10
数据库管理工具：Navicat10以上版本
环境配置软件： JDK1.8+Maven3.3.9
服务器：Tomcat7.0
技术栈 前端技术: 使用Vue.js框架构建用户界面，它是一个灵活且高效的JavaScript框架，适合构建现代化的单页面应用（SPA）。后端技术: 采用Spring Boot框架进行后端开发，Spring Boot是一个Java平台，它提供了快速搭建、开发、运行Spring应用程序的能力，极大地简化了配置和部署流程。数据库: 使用MySQL作为关系型数据库管理系统，存储应用数据，它是一个流行的开源数据库，适用于各种规模的应用程序。数据库可视化工具: Navicat用于数据库的可视化管理和操作，它支持多种数据库系统，提供了一个直观的用户界面来管理MySQL数据库。开发环境: 使用JDK 1.8进行Java应用的开发，这是Java开发的核心环境，包含了运行Java程序所需的库和工具。服务器: 使用Tomcat 7.0作为Web应用服务器，它是一个开源的Servlet容器，用于部署和运行Java Web应用程序。项目管理工具: Maven 3.3.9用于项目的构建和依赖管理，它通过pom.xml文件定义项目结构和依赖关系，简化了项目构建过程和库管理。 后端由Spring Boot提供支持，前端由Vue.js构建，数据存储和管理通过MySQL和Navicat实现，整个开发流程由Maven进行管理，并在Tomcat服务器上运行。
程序界面： 源码文末获取↓↓↓↓： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bcd6c26b5f052f3912614c1726b0b55/" rel="bookmark">
			JavaScript的四种输出语句（一些使用细节）【js学习笔记1】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😁 作者简介：一名大四的学生，致力学习前端开发技术
⭐️个人主页：夜宵饽饽的主页
❔ 系列专栏：JavaScript小贴士
👐学习格言：成功不是终点，失败也并非末日，最重要的是继续前进的勇气
目录 1.2，JavaScript的输出1.2.1，页面输出1.2.2，控制台输出1.2.3，弹出窗口输出1.2.4，弹出输入框 1.2，JavaScript的输出 1.2.1，页面输出 &lt;script&gt; document.write("在页面显示") &lt;/script&gt; 1.2.2，控制台输出 &lt;script&gt; console.log("输出一条日志"); console.info("输出一条信息"); console.warn("输出一条警告"); console.error("输出一条错误"); &lt;/script&gt; ​ 一些使用控制台输出语句技巧：
​ 1.命名日志打印
function sum(a, b) { console.log({b});//关键语句 return a + b; } sum(1, 2); sum(4, 5); ​ 2. 高级化格式
​ 将某些东西打印到控制台最常见方法是简单地使用一个参数调用console.log()，有时我们可能想要打印一条包含多个信息。幸运地是，console.log()可以使用%s,%i 等说明sprintf()格式化字符串
const user = 'john_smith'; const attempts = 5; console.log(user+"登录失败了"+attempts+"次")//我们也可以用字符串地拼接 console.log('%s 登录失败了 %i 次', user, attempts);//这是高级化格式打印 以下是可用说明符的列表：
说明符作用%s元素转换为字符串
%d 或 %i元素转换为整数
%f元素转换为浮点数
%o元素以最有效的格式显示：
％o说明符(为值关联了正确的打印格式)可以在文本消息中插入数组，对象，DOM元素和常规文本，而不会失去交互性。 const myObject = { name: 'John Smith', profession: 'agent' }; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bcd6c26b5f052f3912614c1726b0b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae92e527838434f4822d97c6b3ad026f/" rel="bookmark">
			js中关于scrollHeight，scrollwidth,scrollLeft,scrollTop的属性使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😁 作者简介：一名大四的学生，致力学习前端开发技术
⭐️个人主页：夜宵饽饽的主页
❔ 系列专栏：JavaScript小贴士
👐学习格言：成功不是终点，失败也并非末日，最重要的是继续前进的勇气
​🔥​前言：
这里是关于js操作页面元素的使用的笔记,希望可以帮助到大家，欢迎大家的补充和纠正
滚动距离 属性说明element.scrollHeight返回整个元素的高度（包括带滚动条的隐蔽的地方）element.scrollwidth返回元素的整个宽度（包括带滚动条的隐蔽的地方）element.scrollLeft返回当前视图中的实际元素的左边缘和左边缘之间的距离element.scrollTop返回当前视图中的实际元素的顶部边缘和顶部边缘之间的距离 1.element.scrollHeight &amp;&amp; element.scrollWidth
element.scrollHeight属性返回整个元素的总高度， element.scrollWidth属性返回整个元素的总宽度。我们可以理解为元素在垂直或水平方向上可以滚动的距离。
它们返回的是整个元素的高度和宽度，包括由于滚动条而不可见的部分。默认情况下，这两个属性包括padding，但是不包括margin和border。
如果元素没有发生溢出（没出现滚动条），那么scrollHeight和clientHeight是相等的，scrollWidth属性与clientWidth属性是相等的。
2.element.scrollLeft &amp;&amp; element.scrollTop
element.scrollLeft属性表示元素的水平滚动条向右侧滚动的距离，element.scrollTop属性表示元素的垂直滚动条向下滚动的距离。
如果没有出现滚动条，那上面的两个属性值就是0。这两个属性都可以读写，对属性值进行设置，就会使得浏览器将指定元素滚动到相应的位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e51aab5ab865bc44cc0b5b5b8f0b530/" rel="bookmark">
			Win11系统下Oracle11g数据库下载与安装使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Oracle下载与安装1.1 解压安装包1.2 开始安装Oracle11g1.2.1 用户 1.3 测试数据库是否配置成功1.4 了解一下 Oracle相关服务1.5 了解Oracle体系结构 二、使用工具连接数据库2.1 PL/ SQL 连接本地oracle 三、PL/ SQL远程访问数据库3.1 可能踩坑问题（TNS: 无监听程序） 点此 oracel下载：比官网下载.速度.要快些,如果过期请私.聊
操作系统：win11
Oracle11g : 很早之前的安装包，win7 系统安装时不会遇到环境不满足最低要求的提示，win11系统安装时会提醒环境不满足，修改配置文件即可
强调：先安装oracle服务端/oracle客户端，再安装第三方工具（PL/ SQL Developer，DBeaver等）
切记！！！一定要点击口令管理，进行口令设置，因为安装时未点击口令管理而点击确定的话，后面各种坑
一、Oracle下载与安装 1.1 解压安装包 由于文件过大，压缩了成了两个文件，下载安装文件之后
新建一个database文件
解压1和2到同一个database文件，再执行安装。
开始安装：双击 setup.exe
当遇到如下问题时，修改一下配置文件，重新安装就可以了，没遇到则略过
版本注册的问题，默认Oracle 11没有添加win11的注册信息，所以要将win11的注册信息添加到Oracle的配置文件里
修改cvu_prereq.xml文件：点击打开"database\stage\cvu\cvu_prereq.xml"文件（用记事本或者其他工具打开） ​ 2. 复制以下内容 粘贴到 &lt;/CERTIFIED_SYSTEMS&gt; 上方
&lt;OPERATING_SYSTEM RELEASE="6.2"&gt; &lt;VERSION VALUE="3"/&gt; &lt;ARCHITECTURE VALUE="64-bit"/&gt; &lt;NAME VALUE="Windows 11"/&gt; &lt;ENV_VAR_LIST&gt; &lt;ENV_VAR NAME="PATH" MAX_LENGTH="1023" /&gt; &lt;/ENV_VAR_LIST&gt; &lt;/OPERATING_SYSTEM&gt; 如图所示
1.2 开始安装Oracle11g 步骤1： 双击 setup.exe ； 取消我希望通过 My Oracel Support 接收安全更新(W)。 点击下一步
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e51aab5ab865bc44cc0b5b5b8f0b530/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f69a2db2344037af2b9d79d2108415/" rel="bookmark">
			Hybrid App（原生&#43;H5）开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 市面上主流的hybrid app框架主要有
React Native：由FaceBook开发，使用JavaScript和React来构建原生应用程序Flutter：由Google开发，使用Dart语言。Flutter使用自己的渲染引擎Ionic：基于 Web 技术（HTML、CSS 和 JavaScript），使用 Angular 框架。Ionic 提供了一组 UI 组件和工具，使开发人员能够构建跨平台移动应用程序。 还有hybrid app框架，但是我本人没有进行过多的涉及，这里就不展开了，想要进一步了解的友友们可以自行查阅资料哈。我在这主要是想讲讲使用hybrid app开发时的一些使用方案，并且结合自己现在做的，总结一下自己的心得。
要解决的问题
web调用原生（实质是JavaScript调用Java）原生调用web（实质是Java调用Java）数据通道的搭建---性能及易用性 原生+webVview方案 这是最常用的Hybrid方案之一。应用的主要框架由原生代码构建，同时在应用的某些部分内嵌入WebView组件，用于显示Web页面加载Web应用。Web页面通过WebView运行，并可以与原生代码进行通信。通俗点来说，就是网页的模式，通常由“HTML5云网站+APP应用客户端”两部分构成。混合开发是一种取长补短的开发模式，原生代码部分利用WebView插件或者其他框架为H5提供容器。
优点：
开发效率高，节约时间。同一套代码在Android和IOS上基本都可以使用更新迭代以及部署比较方便，每次升级版本只需要在服务器端升级即可，不需要再上次App Store进行审核代码维护方便，版本更新快，节约产品成本基于web，但是同时也可用拥有原生支持的业务可离线运行 缺点：
功能/界面无法自定：所有内容都是固定的，不能换界面或者增加功能加载缓慢/网络要求高：混合APP数据需要全部从服务器获取，每个页面都需要重新加载，因此打开速度慢，网络占用高，缓冲时间长，容易让用户反感 但是webview也是有一定的缺点的，即web应用的体验无法达到原生应用的体验。但是开发效率高，被很多app所用。比如京东、淘宝、今日头条等APP都是利用混合开发模式而成的。这也是目前笔者开发团队中开发APP时最经常使用到的方案。
H5和原生如何交互的呢？ H5与原生APP的交互指的是在原生APP中嵌入H5页面，是的用户可以在原生APP中直接访问H5页面并进行交互操作。H5与原生APP交互原理是通过webview实现的。那么webview又是什么呢？
webview webview是Android和IOS系统中提供的一个组件，使得可以在原生APP中嵌入H5页面。webview可以加载HTML、CSS、JavaScript等web技术，同时也可以调用原生APP提供的API，实现与原生APP的交互
H5与原生交互方式 在H5页面中，可以通过JavaScript调用原生提供的API，实现与原生的交互。原生APP需要提供一个JavaScriptBridge类，用来接收H5页面发来的请求，并执行相应的操作。
我这里主要想讲一下如何应用第三方框架实现H5与原生之间的交互。目前比较流行的支持H5与原生App之间交互的框架有：WebViewJavaScriptBridge、JSBridge、HybridBridge等。这些框架都提供了API接口，方便H5页面与原生APP的交互，同时也提供了一些辅助功能，如：H5页面的路由跳转、原生APP的Toase提示、H5页面的Loading动画等。
笔者主要是从事前端开发的，那么也就是在进行Hybrid APP开发时负责的是H5页面的开发，然后我们团队用到的实现与原生APP之间交互的第三方框架主要是dsBridge，所以接下来我也主要围绕dsBridge展开，讲述H5与原生交互的一些主流程以及实际应用。
DSBridge 介绍 国内推出的JavaScript bridge跨平台混合开发框架官方提供了Android/ios版本，真正实现跨平台DSBridge支持同步及异步调用（DSbridge是唯一一个支持同步调用的javascript bridge）无需iFrame，性能好Github地址： IOS：GitHub - wendux/DSBridge-IOS: :earth_asia: A modern cross-platform JavaScript bridge, through which you can invoke each other's functions synchronously or asynchronously between JavaScript and native.Android：GitHub - wendux/DSBridge-Android: :earth_americas: A modern cross-platform JavaScript bridge, through which you can invoke each other's functions synchronously or asynchronously between JavaScript and native.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73f69a2db2344037af2b9d79d2108415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971cf1da8d89e896afc7ed0424cd8232/" rel="bookmark">
			NewStars Moe CTF2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一下最近再BUU打的NewStarCTF以及MoeCTF
这里主要说一下难题的解题过程
ez_rce 题目提示攻击子进程调用，查看一下app里代码
所以考察进程模块实现命令执行
from flask import * import subprocess app = Flask(__name__) def gett(obj,arg): tmp = obj for i in arg: tmp = getattr(tmp,i) return tmp def sett(obj,arg,num): tmp = obj for i in range(len(arg)-1): tmp = getattr(tmp,arg[i]) setattr(tmp,arg[i+1],num) def hint(giveme,num,bol): c = gett(subprocess,giveme) tmp = list(c) tmp[num] = bol tmp = tuple(tmp) sett(subprocess,giveme,tmp) def cmd(arg): subprocess.call(arg) @app.route('/',methods=['GET','POST']) def exec(): try: if request.args.get('exec')=='ok': shell = request.args.get('shell') cmd(shell) else: exp = list(request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971cf1da8d89e896afc7ed0424cd8232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4db31325387e42751c994df6692f18/" rel="bookmark">
			golang 详解协程——errgroup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要有sync.errgroup
go支持并发，一般采用的是 channel 、 sync.WaitGroup 、context，来实现各个协程之间的流程控制和消息传递。
但是对于开启的成千上万的协程，如果在每个协程内都自行去打印 错误日志的话，会造成日志分散，不好分析。
所以我们要实现一种能统一处理各个协程错误的工具
什么是 sync.errgroup
Go团队在实验仓库中添加了一个名为sync.errgroup的新软件包。 sync.ErrGroup再sync.WaitGroup功能的基础上，增加了错误传递，以及在发生不可恢复的错误时取消整个goroutine集合，或者等待超时
主要是利用了 waitgroup,context以及sync.Once，对这三个不熟悉的应先去看下相应的知识点获取方法
go get golang.org/x/sync
1
errgroup 的功能
1、处理子协程 error
func main() { var g errgroup.Group // 声明一个group实例 var urls = []string{ "http://www.golang.org/", "http://www.google.com/", "http://www.somestupidname.com/", } for _, url := range urls { // 分别获取网站内容 url := url // url是局部变量，for循环中对多个协程传递值时，需要重新进行赋值 g.Go(func() error { // group 的go方法，启一个协程去执行代码 // Fetch the URL. resp, err := http.Get(url) if err == nil { resp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e4db31325387e42751c994df6692f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a420899739b8d50a6e829f0e33dddfb6/" rel="bookmark">
			全网免费Token的生成和解析,第一期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Token令牌的作用 身份验证和授权：在网络安全领域，令牌经常被用作身份验证和授权的手段。例如，在OAuth（开放授权）协议中，令牌被用来代表用户账户的权限，使得第三方应用程序可以在用户的许可下访问特定资源，而无需获取用户的用户名和密码。
会话管理：在Web应用中，会话令牌常被用来识别和管理用户的会话。每当用户登录系统时，服务器会生成一个唯一的会话令牌并发送给客户端。客户端在后续的请求中都会携带这个令牌，以便服务器识别用户的身份。
防止跨站请求伪造（CSRF）：令牌也可以用来防止跨站请求伪造攻击。在这种情况下，服务器会为每个会话生成一个唯一的令牌，并将其嵌入到Web页面中。当用户提交表单或进行其他交互操作时，浏览器会自动将这个令牌发送给服务器，服务器通过检查令牌的有效性来确保请求是合法的。
区块链和加密货币：在区块链和加密货币领域，Token（令牌）通常指代具有某种价值或功能的数字资产。例如，以太坊网络上的ERC20 Token，它可以代表一种货币、一份股权、一个投票权等。
API限流：在一些API服务中，为了防止恶意使用或者过度使用，会使用令牌桶算法进行限流，其中的“令牌”就是控制请求频率的单位。
二、选择token加密算法 选择一个适合的加密算法：例如，常见的加密算法包括HMAC、JWT、OAuth等。选择一个安全性高、适用于你的应用场景的加密算法。
生成Payload：Payload是Token中存储的信息，可以包含用户ID、角色、权限等信息。根据需要构建一个包含必要信息的JSON对象或其他格式的数据。
添加时间戳和过期时间：为了增加安全性和控制Token的有效期，通常在Payload中添加一个时间戳字段表示生成Token的时间，并设置一个过期时间。
使用密钥进行签名：使用选定的加密算法和一个密钥对生成的Payload进行签名。这个密钥只有服务器端知道，用于验证Token的真实性和完整性。
生成Token：将签名后的Payload和其他必要信息（如时间戳等）组成Token字符串。
三、本篇一JWT为例（实操） 3.1导包 以下是JWT-java MAVEN 的坐标
&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 3.2JWT官网 https://jwt.io/ （放心点击）
四、Token工具类 4.1创建TokenUtils类 4.1.1实现密钥生成 public class TokenUtils { private static final int KEY_LENGTH = 32; // 密钥长度为32字节（256位） /* * 生成随机密钥 */ public static String generateRandomKey() { byte[] keyBytes = new byte[KEY_LENGTH]; SecureRandom secureRandom = new SecureRandom(); secureRandom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a420899739b8d50a6e829f0e33dddfb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fb9750d9618e148d4a206876b614c1/" rel="bookmark">
			华为政企港口行业解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c90402f1154fe72fb1a28bcc8abf3e/" rel="bookmark">
			华为政企公路行业解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb0349fda130b365a2ced377fd3d4b4/" rel="bookmark">
			wandb 网络连接问题解决指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 我们都知道wandb是非常好用的可视化工具，但是国内这个环境，网络不通畅，使用时常常会无法同步数据，在使用校园网的情况下尤为明显。这里提供了一种解决思路。
环境 windows 10
pycharm
校园网 wifi
报错内容 运行训练代码时出现以下错误
wandb: Network error (TransientError), entering retry loop. 解决办法 需要挂代理，这里用的是clash for windows，你用其他的就挂其他代理服务器地址。
在pycharm 右上角找到 `编辑配置`
找到环境变量
添加以下内容
HTTP_PROXY=http://127.0.0.1:7890;HTTPS_PROXY=http://127.0.0.1:7890 注意每个环境变量之间要用分号隔开。
这样再训练就不会有网络连接错误啦。
注意确保在此之前挂了代理。
原理 如果仅仅挂了代理但是不配置环境变量的话，同样是没有办法解决问题的。因为默认就不会去走代理，具体原因我现在还没有太明白。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff140a3d77992b65a8ecf97ff65665b7/" rel="bookmark">
			ZFNet 详细解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤ 文章有点长，可以收藏一下慢慢看哦 ~ 提出本模型的论文：
Visualizing and Understanding Convolutional Networks
一、写在前面的话 1. 为什么神经网络能够表现这么好？
仅靠一个理论上的自学习和一个理论上的多参数和一个理论上的非线性分类是无法令人们满意的。神经网络的黑盒子特性也让充满好奇心的机器学习学者们拼命想解开神经网络的秘密。在解密神经网络的庞大队伍中的重要分支是想要利用可视化等技术来对神经网络一探究竟，其中 Z 和 F 二人 开篇性的找到了将卷积核可视化的一种可行的方式。中南大学赵颖老师带领的可解释机器学习项目也加入其中，从此……
2. ZFNet 仅仅是在 AlexNet 上做了一些调参：
改变了 AlexNet 的第一层，即将滤波器的大小 11x11 变成 7x7，并且将步长 4 变成了 2（就这么一丁丁操作就改变了整个卷积神经网络的性能，并在2013年ImageNet大赛中夺冠）
========== 对比图：上为 AlexNet，下为 ZFNet ==========
3. ZFNet 凭什么将 11 改成 7，将步长减 2，是盲目调参吗？
显然发了这篇论文肯定是有自己的一个调参方法——根据可视化结果判断模型的效果，并可以确定一定的优化调参方向。
========== 对比图：========== 4. 当然这篇论文还根据遮挡图像的局部对分类结果的影响来探讨了对分类任务而言到底哪部分输入信息更重要。
二、ZFNet 中做出的改进，以及 Z 和 F 在神经网络可视化方面的独到见解 首先肯定是看看可视化神经网络的方式 （1）可视化什么东西： 卷积层提取出来的特征图像。
（2）如何可视化卷积核提取出来的特征图像？
复习 ： 每一层的基本操作是 : 卷积 -&gt; relu -&gt; 池化 -&gt; 归一化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff140a3d77992b65a8ecf97ff65665b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a43a74849b747503fec5bc3bef78f4d/" rel="bookmark">
			[第七届集创赛]紫光同创杯--部分讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备开始更新
紫光的赛题大家可以去官网看看，主要是FPGA实现多路视频采集和PC端跑神经网络识别。
FPGA采集多路视频后还需要对视频进行缩放，拼接。然后通过PCIE传输到PC端上。
首先我将讲解一下其中的一部分。(码字中)
并不是想拖更，因为最近在做FPGA创新设计大赛，同时做了高云和紫光两题，差不多要完成了。再稍等一会，即将补充更新。
紫光的赛题是视频采集以及AI加速
首先讲一下视频采集部分，本次是有四路视频原输入，双目摄像头、HDMI输入、以太网以及光纤。这里光纤是充当一个回环作用，把视频数据经过光纤发送再连接到另一个光纤接收然后重新输出视频数据。
这里重点讲一下大家比较关心的缩放和拼接，也是这个项目的核心内容。
缩放模块 缩放在FPGA用两种比较常用的方法，一种是临近插值，另一种是双线性插值。后者消耗的资源较多，在初赛时，本人是使用双线性插值，由于资源消耗过多，且比赛项目其实不是对视频细节要求很高，最终还是选择了临近插值。
这里先讲解一下双线性插值如何在FPGA上实现。这里先讲一下双线性插值的原理。(后续更新)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/525d607c6c1bce947787f4d8c7e6e083/" rel="bookmark">
			VSCode 的 C/C&#43;&#43; 开发环境的傻瓜级自动部署程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件介绍 VSCode 是一款优秀的编辑器，可以通过各种插件，将其配置成 C/C++ 开发环境。只是对于初学者而言，配置步骤有点繁琐。
软件 VSCode-Setup(MinGW) 提供了自动下载安装 VSCode 并配置成 C/C++ 开发环境的功能。无需担心该软件会对系统有额外修改，每个步骤都有明确提醒，可以使用自动功能，也可以根据提示手动完成配置，都很方便。
软件下载 点击这里下载：VSCode-Setup(MinGW)_v20231016
VSCode-Setup(MinGW) 安装程序分为六个步骤： 下载 VS Code下载 MinGW-W64安装 C/C++ 插件设置 MingGW-W64 环境变量下载 EasyX创建 Demo 示例程序 注意，除了第二步下载很慢之外，其它步骤都建议选择自动操作。
步骤一、下载 VS Code 先选择 VS Code 的安装目录，默认路径是 D:\App\VSCode（后面步骤都以该路径做为示范）
自动下载：点击“点这里开始”按钮进行自动下载，大约一分钟内即可完成。下载完成后，根据提示进行下一步操作即可。
手动下载：从 Visual Studio Code 1.75.1 - AppZip 下载“免安装 x64”版本 VSCode，下载后解压至安装路径下，软件检测到 D:\App\VSCode\Code.exe 后可以点“下一步”按钮进入下一个步骤。
步骤二、下载 MinGW-W64 （注意：本步骤建议手动下载） 由于 MinGW-W64 下载地址在国外，下载速度很慢，而且经常无法下载。
建议使用迅雷下载 MinGW-w64 - for 32 and 64 bit Windows - Browse Files at SourceForge.net 页面中的 MinGW-W64 GCC-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/525d607c6c1bce947787f4d8c7e6e083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/959f4c16838caf1ab1407527687f5036/" rel="bookmark">
			python——dataframe 获得指定行列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python dataframe 获得指定行列 使用pandas库中的DataFrame对象，可以通过行标签和列标签来获取某个或某些行列的数据。
获取行： 通过行标签（索引）获取一行数据：df.loc[row_label]通过行号（位置）获取一行数据：df.iloc[row_index]通过条件筛选获取多行数据：df[df['column_name'] == 'value'] 获取列： 通过列标签获取一列数据：df[column_label]通过列标签获取多列数据：df[[column_label1, column_label2]] 同时获取指定的行和列：
通过行标签和列标签获取指定的行和列数据：df.loc[row_label, column_label]通过行号和列号获取指定的行和列数据：df.iloc[row_index, column_index] 举个例子：
import pandas as pd # 创建一个DataFrame data = {'name': ['Alice', 'Bob', 'Cathy', 'David'], 'age': [25, 30, 35, 40], 'gender': ['female', 'male', 'female', 'male'], 'score': [90, 85, 80, 75]} df = pd.DataFrame(data, columns=['name', 'age', 'gender', 'score']) # 获取第2行数据 print(df.iloc[1]) # 获取gender列的数据 print(df['gender']) # 获取第3行的score列数据 print(df.loc[2, 'score']) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b7d5de1522cb8681430b966db3dc8d/" rel="bookmark">
			Wireshark——过滤器设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学者使用wireshark时，将会得到大量的冗余数据包列表，以至于很难找到自己自己抓取的数据包部分。wireshar工具中自带了两种类型的过滤器，学会使用这两种过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。
（1）抓包过滤器
捕获过滤器的菜单栏路径为Capture --&gt; Capture Filters。用于在抓取数据包前设置。
如何使用？可以在抓取数据包前设置如下。
ip host 60.207.246.216 and icmp表示只捕获主机IP为60.207.246.216的ICMP数据包。获取结果如下：
（2）显示过滤器
显示过滤器是用于在抓取数据包后设置过滤条件进行过滤数据包。通常是在抓取数据包时设置条件相对宽泛，抓取的数据包内容较多时使用显示过滤器设置条件顾虑以方便分析。同样上述场景，在捕获时未设置捕获规则直接通过网卡进行抓取所有数据包，如下
执行ping www.huawei.com获取的数据包列表如下
观察上述获取的数据包列表，含有大量的无效数据。这时可以通过设置显示器过滤条件进行提取分析信息。ip.addr == 211.162.2.183 and icmp。并进行过滤。
上述介绍了抓包过滤器和显示过滤器的基本使用方法。在组网不复杂或者流量不大情况下，使用显示器过滤器进行抓包后处理就可以满足我们使用。下面介绍一下两者间的语法以及它们的区别。
wireshark过滤器表达式的规则 1、抓包过滤器语法和实例 抓包过滤器类型Type（host、net、port）、方向Dir（src、dst）、协议Proto（ether、ip、tcp、udp、http、icmp、ftp等）、逻辑运算符（&amp;&amp; 与、|| 或、！非）
（1）协议过滤 比较简单，直接在抓包过滤框中直接输入协议名即可。
TCP，只显示TCP协议的数据包列表
HTTP，只查看HTTP协议的数据包列表
ICMP，只显示ICMP协议的数据包列表
（2）IP过滤 host 192.168.1.104
src host 192.168.1.104
dst host 192.168.1.104
（3）端口过滤 port 80
src port 80
dst port 80
（4）逻辑运算符&amp;&amp; 与、|| 或、！非 src host 192.168.1.104 &amp;&amp; dst port 80 抓取主机地址为192.168.1.80、目的端口为80的数据包
host 192.168.1.104 || host 192.168.1.102 抓取主机为192.168.1.104或者192.168.1.102的数据包
！broadcast 不抓取广播数据包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b7d5de1522cb8681430b966db3dc8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61290a384ef6c314590c262aff8ce0a9/" rel="bookmark">
			关于编程, 游戏, 学习, 人生和奥特曼的感想 (持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 叠甲
本文章大部分内容个人创作, 是非常主观的看法, 而且会有不合逻辑, 发癫, 痉挛, 蠕动, 等
希望读者带着一颗思辨的心
# 叠甲end
舒服的窝在被窝里 想起了穷游的时候, 凌晨3点, 走在山间小路上, 又冷又困又害怕, 那时候, 我什么都不想要, 只想找个睡觉的地方, 只要是个四面有遮挡的地方就好
还想起了, 第一份工作, 拖了几个月才发第一个月的工资, 没钱, 吃不起饭, 每天都是清汤面
现在简直是太幸福了
小小梦魇2的一个细节 主角被猎枪哥一路追杀, 终于逃到了一个小洞里, 猎枪哥往洞里开了一枪, 没打到
我觉得可以改成这样:
追时音乐紧张刺激, 逃进洞里后音乐停, 让玩家以为安全了
而且洞外是亮的, 洞里很黑, 迫使玩家停一步在这里
这时候伸进枪来, 嘭, 给一枪
老板和乞丐的区别 《天下布魔》的一个剧情, 使我终于明白躺在沙滩上的老板和乞丐的区别是什么了
区别在于, 老板有选择权, 而乞丐没有
李狗嗨sp2 真相, 毫无作用
现代医学就是累累白骨堆成的
我们应该意识到活着的每一天都是奇迹
钙 钙, 铁字旁 (啊? 你说什么? 金子旁? 不不不, 你是说"全字旁"吧?)
所以, 钙也是金属
所以, 人类的骨骼牙齿都是金属
贝壳, 墙皮, 粉笔, 都是金属
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61290a384ef6c314590c262aff8ce0a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ac18f7d36798b8735bde71327acf95/" rel="bookmark">
			后端接口接收对象和文件集合，formdata传递数组对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0 问题 后端接口需要接收前端传递过来的对象和文件集合；对象中存在数组对象
1 前端和后端 前端只能使用formdata来传递参数，后端不使用@RequestBody注解
2 formdata传递数组对象 2.1 多个参数对象数组 addForm: { contactInfo: [ { contactPerson: '', contactPhone: '' } ] }, this.addForm.contactInfo.forEach((value, index) =&gt; { formData.append(`contactInfo[${index}].contactPerson`, value.contactPerson); formData.append(`contactInfo[${index}].contactPhone`, value.contactPhone); }) 2.2 单个参数对象数组 addForm: { region: [ 0, 1, 2 ] }, this.addForm.region.forEach((value, index) =&gt; { formData.append(`region[${index}]`, value) }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0378cb75dc089566aba61e1cba8828c9/" rel="bookmark">
			【protobuf】protobuf自定义数据格式，CMake编译C&#43;&#43;文件读写自定义数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		protobuf自定义数据格式，CMake编译文件读写自定义数据 1.protobuf安装2.定义.proto文件3.编写main.cpp4.编写CMAkeLists配置文件5.运行 1.protobuf安装 protobuf库链接
2.定义.proto文件 新建一个Person.proto文件和一个Animal.proto文件，内容如下：
syntax = "proto3"; package UserInfo; message Person { string name = 1; int32 id = 2; string email = 3; } syntax = "proto3"; package UserInfo; message Animal { string name = 1; int32 id = 2; int32 age = 3; } 3.编写main.cpp main函数中对proto中的对象进行序列化和反序列化，内容如下：
#include "Animal.pb.h" #include "Person.pb.h" #include &lt;fstream&gt; #include &lt;iostream&gt; int main() { { // 创建 Person 对象 UserInfo::Person person; person.set_name("John Doe"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0378cb75dc089566aba61e1cba8828c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74dcc942e9325e9c9756cf1857cc8d35/" rel="bookmark">
			Spring Boot 设置动态定时任务，千万别再写死了~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉 这是一个或许对你有用的社群
🐱 一对一交流/面试小册/简历优化/求职解惑，欢迎加入「芋道快速开发平台」知识星球。下面是星球提供的部分资料： 《项目实战（视频）》：从书中学，往事上“练”
《互联网高频面试题》：面朝简历学习，春暖花开
《架构 x 系统设计》：摧枯拉朽，掌控面试高频场景题
《精进 Java 学习指南》：系统学习，互联网主流技术栈
《必读 Java 源码专栏》：知其然，知其所以然
👉这是一个或许对你有用的开源项目
国产 Star 破 10w+ 的开源项目，前端包括管理后台 + 微信小程序，后端支持单体和微服务架构。
功能涵盖 RBAC 权限、SaaS 多租户、数据权限、商城、支付、工作流、大屏报表、微信公众号等等功能：
Boot 地址：https://gitee.com/zhijiantianya/ruoyi-vue-pro
Cloud 地址：https://gitee.com/zhijiantianya/yudao-cloud
视频教程：https://doc.iocoder.cn
来源：blog.csdn.net/wl_Honest/
article/details/123654621
之前写过文章记录怎么在SpringBoot项目中简单使用定时任务，不过由于要借助cron表达式且都提前定义好放在配置文件里，不能在项目运行中动态修改任务执行时间，实在不太灵活。
经过网上搜索学习后，特此记录如何在SpringBoot项目中实现动态定时任务。
基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能
项目地址：https://github.com/YunaiV/yudao-cloud
视频教程：https://doc.iocoder.cn/video/
因为只是一个demo，所以只引入了需要的依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- spring boot 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74dcc942e9325e9c9756cf1857cc8d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e43adbe65c25e189fae9c8e9c33aed/" rel="bookmark">
			【Linux】编译安装nginx，手写service配置文件，深度理解systemd控制管理服务底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、了解服务
1、服务的本质
2、centos7的systemd的服务
3、service unit file配置文件的组成以及掌握常用选项
4、关于systemd管理的命令学习
5、运行级别
二、编译安装nginx，以及手写service配置文件，请看注释
​编辑
一、了解服务 1、服务的本质 “服务”的本质是一种程序，“服务”分两种：
程序服务程序：对内，为保证计算机的正常运行，比如systemd，协助管理程序
用户服务程序：对外，给网络上用户提供各种功能，比如购物、游戏等，常见httpd
服务一般是后台运行，已准备随时调用
2、centos7的systemd的服务 centos 6采用init初始化进程，是一个一个串行启动
centos7采用systemd作为祖宗进程，systemd也是一种init程序，①解决依赖关系并行启动；②按需启动（根据服务配置设定启动）③负责在系统启动或者运行时，激活系统资源、服务进程等
systemd还提供叫醒服务，举例，安装rpcbind，将其关闭，然后用另一台主机进行探测连接，查看进程状态，实验看一下
systemd可以向后兼容sysvinit，systemd可以将多个程序进行单元管理，单元类型分类：
单元类型扩展名说明Serviceservice描述一个系统服务软件（这是我们最需要知道的）Socket.socket描述一个进程间通信的套接字Device.device描述一个内核识别的设备文件Mount.mount描述一个文件系统的挂载点Automount.automount描述一个文件系统的自动挂载点Swap.swap描述一个内存交换设备或交换文件Path.path描述一个文件系统中文件或目录Timertimer描述一个定时器 (用于实现类似cron的调度任务)Snapshot.snapshot用于保存一个systemd的状态Scope.scope使用systemd的总线接口以编程的方式创建外部进程Slice.slice描述居于Cgroup的一组通过层次组织的管理系统进程Target.taget描述一组systemd的单元（我觉得可以理解为运行级别） 3、service unit file配置文件的组成以及掌握常用选项 要知道，yum和rpm安装的时候系统，安装的是软件包，是已经写好了，会自动将service配置文件放到/usr/lib/systemd/system/这个文件夹中，让这个服务程序自动被systemd管理，但是编译安装是不会自动被管理，那么如果想要被systemd管理，则需要手动编写service配置文件。
这里拓展一下，systemd统一管理的好处：
1、对计算机而言，systemd有一套自己的启动、关闭等命令规则，这样可以套公式一样进行所有程序的管理，也可以理解为这是为了有一套制度，更好的调度计算机理解需求；
2、对于电脑面前的运维工程师，可以更好的去查看记忆程序状态，尤其是管理大量不同程序的情况下，可以统一规则。
关于配置文件的书写格式：
service unit file文件通常由三部分组成： [Unit]：定义与Unit类型无关的通用选项；用于提供unit的描述信息、unit行为及依赖关系等 [Service]：与特定类型相关的专用选项；此处为Service类型 #service这一步非常非常重要！！！ [Install]：定义由“systemctl enable”以及"systemctl disable“命令在实现服务启用或禁用时用到 的一些选项 Unit段的常用选项Description描述信息（一般会写一个描述，等下看实操案例）After/Before自定义unit的启动顺序，表示当前unit应该晚于或者优先于哪些unit启动Requires依赖到的其它units，强依赖，被依赖的units无法激活时，当前unit也无法激活Wants依赖到的其它units，弱依赖Conflicts定义units间的冲突关系 Service段的常用选项 Type定义影响ExecStart及相关参数的功能的unit进程启动类型simple默认值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中forking由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务。原生父程序在启动结束后就会终止oneshot与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中dbus与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作.因此通常也要同时设定BusNname= 才行notify在启动完成后会发送一个通知消息。还需要配合 NotifyAccess 来让 Systemd 接收消息idle与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务notify在启动完成后会发送一个通知消息。还需要配合 NotifyAccess 来让 Systemd 接收消息idle与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务EnvironmentFile环境配置文件ExecStart指明启动unit要运行命令或脚本的绝对路径（最最最重要）ExecStartPre ExecStart前运行ExecStartPost ExecStart后运行ExecStop指明停止unit要运行的命令或脚本的绝对路径（最最最重要）ExecReload指明程序重新加载unit要运行的命令或脚本的绝对路径（最最最重要）Restart当设定Restart=1 时，则当次daemon服务意外终止后，会再次自动启动此服务RestartSec设置在重启服务( Restart= )前暂停多长时间。 默认值是100毫秒(100ms)。 如果未指定时间单位，那么将视为以秒为单位。 例如设为"20"等价于设为"20s"。PrivateTmp设定为yes时，会在生成/tmp/systemd-private-UUID-NAME.service-XXXXX/tmp/目录 Install字段的常用选项Alias别名，可使用systemctl command Alias.serviceRequiredBy被哪些units所依赖，强依赖WantedBy被哪些units所依赖，弱依赖（一般会写一个弱依赖，等下看实操案例）Also安装本服务的时候还要安装别的相关服务 4、关于systemd管理的命令学习 命令功能systemctl start 软件名开启进程systemctl stop 软件名关闭进程systemctl status 软件名查看进程状态systemctl restart 软件名重启进程（先关闭后启动）systemctl reload 软件名重新加载（不关闭的状态下更新）systemctl enable 软件名开机自启动systemctl enable --now 软件名开启自启动并现在启动systemctl disable 软件名开机不自启systemctl disable --now 软件名开机不自启并现在关闭systemctl daemon-reload 重新加载新服务，让系统识别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5e43adbe65c25e189fae9c8e9c33aed/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/46/">«</a>
	<span class="pagination__item pagination__item--current">47/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/48/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>