<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b34f7f4c9de40b9bff51b471691c35/" rel="bookmark">
			Linux 系统 find 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		find 命令是 Linux 系统中常用的文件搜索工具，用于在指定目录及其子目录下查找符合条件的文件或目录。它可以根据文件名、文件类型、文件大小、文件权限、修改时间等多种属性进行搜索。
常用的 find 命令语法如下：
find [path] [expression] 其中 path 参数表示要搜索的目录路径，如果不指定，则默认搜索当前目录及其子目录。expression 参数则是搜索条件表达式，可以使用一系列选项和测试来定义搜索规则。
命令选项 基本选项 -name pattern：按照文件名模式进行匹配搜索。pattern 可以使用通配符进行模式匹配，如 *.txt。-type type：按照文件类型进行匹配搜索。type 可以是以下几种类型之一： f：普通文件d：目录l：符号链接b：块设备文件c：字符设备文件s：套接字文件p：命名管道文件 -size [+|-]n[cbkMG]：按照文件大小进行匹配搜索。+ 表示大于，- 表示小于，n 是具体的大小，[cbkMG] 是可选的单位后缀，分别表示字节、KB、MB、GB 和 TB。例如，-size +1M 表示文件大小大于 1MB。-mtime [+|-]n：按照文件修改时间进行匹配搜索。+ 表示早于，- 表示晚于，n 表示天数。例如，-mtime +7 表示修改时间早于 7 天前的文件。-user owner：按照文件所有者进行匹配搜索。-group group：按照文件所属组进行匹配搜索。-perm mode：按照文件权限进行匹配搜索。mode 可以使用八进制或符号格式表示权限。例如，-perm 644 表示权限为 644 的文件。 扩展选项 -iname pattern：类似于 -name，但忽略模式的大小写。-ipath pattern：类似于 -path，但忽略模式的大小写。-regex pattern：使用正则表达式进行匹配搜索。pattern 是一个正则表达式，用于匹配文件名。-iregex pattern：类似于 -regex，但忽略正则表达式的大小写。 动作选项 -exec command {} \;：对搜索到的每个文件执行指定的命令。{} 会被搜索到的文件名替换。-ok command {} \;：与 -exec 选项类似，但在执行命令之前会询问用户是否继续。-delete：删除搜索到的文件。-print：将搜索到的文件名打印到标准输出。 其他选项 -depth：首先处理深度较大的目录，然后再处理浅层的目录。-maxdepth levels：限制搜索的最大深度。levels 表示目录层级数。-mindepth levels：限制搜索的最小深度。levels 表示目录层级数。-prune：排除指定的目录，不进入其中进行搜索。 常用用法 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7b34f7f4c9de40b9bff51b471691c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28146e8cf6062ff99dd4f26dbffe256c/" rel="bookmark">
			Python数据分析毕业设计选题30个及框架大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当涉及到Python数据分析毕业设计选题时，以下是30个选题建议：
1. 分析社交媒体数据，预测用户行为模式。
2. 使用机器学习算法分析电影评分数据，预测电影票房。
3. 分析股票数据，预测股票的涨跌趋势。
4. 分析用户购物数据，提供个性化推荐系统。
5. 使用自然语言处理技术分析新闻文本数据，提取关键信息。
6. 分析网站访问日志数据，优化网站的用户体验。
7. 分析用户评论数据，帮助企业改进产品和服务。
8. 使用数据聚类算法分析用户行为数据，发现用户群体特征。
9. 分析电影票房数据，预测电影的票房成绩。
10. 分析天气数据，预测未来几天的天气情况。
11. 分析用户搜索数据，优化搜索引擎的搜索结果。
12. 分析学生考试成绩数据，提供个性化的学习建议。
13. 使用机器学习算法分析医疗数据，预测疾病的风险。
14. 分析客户购买历史数据，预测客户的购买意愿。
15. 分析用户点击数据，优化广告投放策略。
16. 使用文本挖掘技术分析舆情数据，预测社会热点事件。
17. 分析交通数据，优化城市交通规划。
18. 分析用户行为数据，提供个性化的音乐推荐。
19. 分析社交网络数据，发现社交网络中的关键人物。
20. 使用图像处理技术分析图像数据，识别图像中的物体。
21. 分析用户位置数据，优化地图导航算法。
22. 分析用户点击数据，优化网页设计和布局。
23. 使用机器学习算法分析用户评论数据，情感分析产品和服务。
24. 分析用户浏览数据，优化电子商务网站的销售策略。
25. 分析用户搜索数据，提供实时搜索结果。
26. 使用数据挖掘技术分析网络日志数据，发现网络攻击行为。
27. 分析用户行为数据，优化移动应用的用户界面。
28. 分析用户购买历史数据，提供个性化的推荐商品。
29. 使用机器学习算法分析用户点击数据，预测用户的兴趣。
30. 分析用户评论数据，优化餐饮服务的质量。
Python数据分析领域有许多流行的框架和库可供选择。以下是一些常用的Python数据分析框架：
1. NumPy：提供了高性能的多维数组和数值计算功能。
2. Pandas：用于数据处理和分析的强大工具，提供了灵活的数据结构和数据操作功能。
3. Matplotlib：用于绘制各种类型的图表和可视化数据的库。
4. Seaborn：基于Matplotlib的高级数据可视化库，提供更美观和简洁的图表风格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28146e8cf6062ff99dd4f26dbffe256c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2fb6ccb8eb9206f968df27d92b41ce/" rel="bookmark">
			2024年MySQL学习指南（四），探索MySQL数据库，掌握未来数据管理趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言9. 约束的概念10. 约束的分类11. 非空约束12. 唯一约束13. 主键约束14. 默认约束15. 外键约束16. 约束的案例练习 前言 接上篇：
2024年MySQL学习指南（一）
2024年MySQL学习指南（二）
2024年MySQL学习指南（三）
9. 约束的概念 约束是作用于表中列上的规则，用于限制加入表的数据。例如，作为主键的列一定是非空的唯一的，否则将无法对数据进行区分。约束的存在保证了数据库中数据的正确性、有效性和完整性。所以约束在数据库设计中是非常重要的。
10. 约束的分类 前面说到SQL标准把约束分为了6大类，分别是非空约束，唯一约束，主键约束，检查约束，默认约束和外键约束，添加约束时我们只需要在SQL中添加关键词，便可以限制表中的数据。
约束类型功能非空约束 NOT NULL保证列中所有的数据不能有null值唯一约束 UNIQUE保证列中所有数据各不相同主键约束 PRIMARY KEY主键是一行数据的唯一标识，要求非空且唯一检查约束 CHECK保证列中的值满足某一条件默认约束 DEFAULT保存数据时，未指定值则采用默认值外键约束 FOREIGN KEY外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性 11. 非空约束 目的：保证列中所有的数据不能有null值
添加约束：
CREATE TABLE 表名( 列名 数据类型 NOT NULL, … ); 建完表后添加非空约束：
ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL; 删除约束：
ALTER TABLE 表名 MODIFY 字段名 数据类型; 12. 唯一约束 目的：保证列中所有数据各不相同
添加约束：
CREATE TABLE 表名( 列名 数据类型 UNIQUE [AUTO_INCREMENT], -- AUTO_INCREMENT: 当不指定值时自动增长 … ); CREATE TABLE 表名( 列名 数据类型, … [CONSTRAINT] [约束名称] UNIQUE(列名) ); 建完表后添加唯有约束：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be2fb6ccb8eb9206f968df27d92b41ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc08afaaf743e704988e9dc1428625df/" rel="bookmark">
			项目事务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当usermapper 插入成功时，才去进行sendUser()，只有sendUser成功，再去提交usermapper的事务。
@Resource private DataSourceTransactionManager transactionManager; @Resource private TransactionDefinition transactionDefinition; /** * 注册用户信息 * * @param user 用户信息 * @return 结果 */ private boolean registerUser3(SysUser user) { TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition); if (userMapper.insertUser(user) &gt; 0) { if (sendUser(user)){ transactionManager.commit(transactionStatus); return true; }else { transactionManager.rollback(transactionStatus); } } return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ea2270b5da2b774ea0b2adde279956/" rel="bookmark">
			代码编程教学入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 代码编程是我们在现代能获得的最宝贵的技能之一，学会写代码不仅让我们在职业前景上更得心应手，而且还能让我们的大脑保持活跃和创造性，甚至我们还有机会创造出一些 awesome 的东西出来。
如果我们才刚刚开始（或准备开始）我们的代码学习之路，这里有几个技巧，也许能帮助我们事半功倍。
想清楚我们想学代码的原因 我们取得的成绩很大程度上取决于我们为什么想要学习代码编程，以及我们花多少时间去学习。如果我们想成为一名程序员，获得比普通人更高的待遇与成就感，外国的一些专业课程可能是我们的选择（谷歌已经为想要成为软件工程师的人员提供了技巧和课程列表），当然我们也有可能只是想给未来更多的可能性、想自己时刻保持清醒和优秀。优秀的培训团队会根据工作量，成本以及我们选择编程的原因，对课程选项进行比较，得出最适合我们的学习过程。
选择正确的语言 世上不存在“最好”的编程语言，一旦您学到了其中一种，就能比较容易掌握另一种语言，所以不要因为选择第一语言而太纠结。也就是说，有些语言比其他语言更适合初学者，而您选择的语言可能取决于您的目的（这些方面的知识，可以向有专业的人询问）。如果您对待编程很认真，能接受放慢脚步学习，享受每日进步的感觉，那么你可以从 C++ 开始你的编程生涯。但总的来说，Java、Python这样的更高级的语言更容易立即进入从业者角色。
从小处开始（并且足够耐心） 无论您选择哪种语言或学习方法，您都应该从现在就开始您追随梦想的脚步（一个非常好的起点）。从基础开始，不断着手练习和思考，是最有效的办法。如果一种学习方法不适合你（例如，书籍），在放弃之前尝试另一种方法，甚至是向专业的机构求助。
尝试开始创造一些小程序 在有了一定的基础之后，我们可以试着自己打造一些小程序，这是一个自然而然的过程，不需要过多的担心。如简单的壁纸下载器、简单的小游戏 等，这样的经验对于一个新手来说，是非常宝贵的经验，同时我们也能从中获得便利、快乐和成就感。
参加语言培训课程 与自己自学编程相比，一对一的教学培训能提供更圆润的教育体验，首先是因为这种教学模式是非线性的，我们在学习的过程当中，哪里有不理解的点，都可以借助导师，站在一个更高的点去纵观整个问题，这无疑大大加快了自身的学习速度和质量。简单举个例子，自己学习就像蚂蚁爬行，它经过花瓶、经过洗手台，一路过来，它的确看到了非常多的零碎的风景。而借助平台学习，则像蚂蚁坐在了蜻蜓的背上。它也经过花瓶、经过洗手台，但看到的其实已经是另一番风景。更重要的是，它还将会见到更多的东西，鲜花、喷泉等等，有了更多的可能性。
买一些经典的书籍 当你遇到问题或需要查找时，参考书会非常方便。一般对于我们选择的编程语言，都会有一些编写较完善的书籍，看完之后可以得到很多编程中不可缺少的知识。
以上是我整理的一部分建议，希望能给楼主带来帮助！楼主有往前沿技术靠这个想法，本身就已经在这个高科技时代先人一步，希望您可以下定决心，然后努力往自己的梦想奔跑！
读者福利：如果你喜欢编程，那这套python学习资料一定对你有用，
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括：Python安装包+激活码、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习等教程。带你从零基础系统性的学好Python！
零基础Python学习资源介绍 👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（学习教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉实战案例👈 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 这份完整版的Python全套学习资料已为大家备好，朋友们如果需要可以微信扫描下方二维码添加，输入"领取资料" 可免费领取全套资料【有什么需要协作的还可以随时联系我】朋友圈也会不定时的更新最前言python知识。↓↓↓
或者
【点此链接】领取
好文推荐 了解python的前景： https://blog.csdn.net/weixin_49892805/article/details/127196159
了解python的副业： https://blog.csdn.net/weixin_49892805/article/details/127214402
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4db7a541add712c02b6f4531aa09c7b/" rel="bookmark">
			10个实用的Python数据可视化图表总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可视化是一种方便的观察数据的方式，可以一目了然地了解数据块。我们经常使用柱状图、直方图、饼图、箱图、热图、散点图、线状图等。
这些典型的图对于数据可视化是必不可少的。除了这些被广泛使用的图表外，还有许多很好的却很少被使用的可视化方法，这些图有助于完成我们的工作，下面我们看看有那些图可以进行。
1、平行坐标图（Parallel Coordinate） 我们最多可以可视化 3 维数据。但是我们有时需要可视化超过 3 维的数据才能获得更多的信息。我们经常使用 PCA 或 t-SNE 来降维并绘制它。在降维的情况下，可能会丢失大量信息。在某些情况下，我们需要考虑所有特征， 平行坐标图有助于做到这一点。
上面的图片。横线(平行轴)表示鸢尾花的特征(花瓣长、萼片长、萼片宽、花瓣宽)。分类是Setosa, Versicolor和Virginica。上图将该物种编码为Setosa→1,Versicolor→2,Virginica→3。每个平行轴包含最小值到最大值(例如，花瓣长度从1到6.9，萼片长度从4.3到7.9，等等)。例如，考虑花瓣长度轴。这表明与其他两种植物相比，濑蝶属植物的花瓣长度较小，其中维珍属植物的花瓣长度最高。
有了这个图，我们可以很容易地获得数据集的总体信息。数据集是什么样子的?让我们来看看。
让我们用Plotly Express库[1]可视化数据。Plotly库提供了一个交互式绘图工具。
import plotly.express as px df = px.data.iris() fig = px.parallel_coordinates(df, color="species_id", labels={"species_id": "Species", "sepal_width": "Sepal Width", "sepal_length": "Sepal Length", "petal_width": "Petal Width", "petal_length": "Petal Length", }, color_continuous_scale=px.colors.diverging.Tealrose, color_continuous_midpoint=2) fig.show() 除了上图以外我们还可以使用其他库，如pandas、scikit-learn和matplotlib来绘制并行坐标。
2、六边形分箱图 （Hexagonal Binning） 六边形分箱图是一种用六边形直观表示二维数值数据点密度的方法。
ax = df.plot.hexbin(x='sepal_width', y='sepal_length', gridsize=20,color='#BDE320') 我考虑了上一节的数据集来绘制上面的六边形分箱图。Pandas 允许我们绘制六边形 binning [2]。我已经展示了用于查找 sepal_width 和 sepal_length 列的密度的图。
如果仔细观察图表，我们会发现总面积被分成了无数个六边形。每个六边形覆盖特定区域。我们注意到六边形有颜色变化。六边形有的没有颜色，有的是淡绿色，有的颜色很深。根据图右侧显示的色标，颜色密度随密度变化。比例表示具有颜色变化的数据点的数量。六边形没有填充颜色，这意味着该区域没有数据点。
其他库，如 matplotlib、seaborn、bokeh（交互式绘图）也可用于绘制它。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4db7a541add712c02b6f4531aa09c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3725fe1dab4d03717cacab3f837ecc78/" rel="bookmark">
			“口罩”结束后，2023年的程序员会饱和吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知乎有个问题，中国的程序员是否过多了？
实际上这问题几乎每年都见过几次。有网友说，早在2000年左右，配合美国互联网泡沫破裂，就有无数人说“别学计算机，饱和了。”
可现实是怎样的呢？
01 程序员真的过多了吗？ 这么说吧。
无论是上市互联网公司还是国企，对程序员的招聘这么多年几乎没间断过。能力强的程序员真心不好招，在面试时他们往往握有主动权——几个offer在手，凭君选择。
不止程序员，许多看起来饱和的岗位其实只是“看起来”。
心理学中有个名词，叫“投射效应”，是指人们倾向于按照自己的感受投射到外界， 以自己为标准去衡量。
用个人经历代替行业趋势，用主观判断代替客观现状。
无数人说IT行业不景气，忽视了层出不穷的互联网新职业；无数人说新媒体大势已去，忽视了哪怕做副业，月入过万的比比皆是。无数人说制造业已成夕阳产业，忽视了它们逐步转型智能化方向。 小编完全理解，人的想法总是个体的，一旦失业，哪怕统计数字再辉煌也暖不了他。
可因为如此，我们容易陷入一叶障目的困局中。
就拿“程序员是否饱和”来说，小编特别认同一位知乎网友的答案：
专业的程序员供不应求，凑数的程序员供大于求。
说句挺残酷的话，有时候可能只是你不行，而不是行业不行。
02 IT行业究竟有什么魔力 学计算机的人和程序员，有没有可能遇到市场饱和的情况？
只能说，可能性极小，至少目前。
仅人社部等官方就联合发布了13个平均年薪25万的新职业，就有100万以上的市场缺口。
它们都是以计算机为基础，生根发芽的新物种。
查理·芒格说得很对，事情一定要习惯反过来想。所以你发现没：
行业激烈变化时，恰恰是机会最多的时候。
大环境不好时，恰恰是优质人才出头的时候。
那么IT行业到底有什么吸引力值得大家去追随呢？
01 IT行业薪资高 2021年春季求职行业平均薪酬榜上，计算机行业以平均薪酬10249元，排名第五，薪资这么高的岗位，入行门槛却低，对绝大部分同学来说是非常友好的了。
02 IT行业不断出现新技术 先说说对IT界不断出现新技术的，新知识的看法。这个是常常不爱计算机工作的人经常提出的一个问题。
不断出现的新知识，不断出现的新解决方案，都让人啧啧称奇。然后自己学会后，觉得人生值得了。而更是由于IT界这样的知识更新率极高，给人感觉这个行业是个十分有活力的行业，而不是死气沉沉的。
03 IT行业就业前景好 IT行业就业前景好是毋庸置疑的，可以从很多权威的数据看到，在最具潜力的薪酬职业中，前二十位里面IT行业总是占有大比重的。而且从事IT行业的人，就算是跳槽再就业也是不会有什么难度的，与其他行业相比，IT行业只要有技术，其他的就都微不足道了。
咱们再来看看行业内技术要求的占比需求。就程序员开发来说，包括有前端/交互/美工，后台开发，算法工程师，移动端开发，产品经理，云计算/大数据等等。接下来咱们看看先这个图的数据再分析。
看到这里，就很明显了，后台开发工程师占比在百分之33，Java开发，目前来看，还是市场需求比较大，需求比较多的，当然其他的重要性，还有地位都是不可动摇的，都是必不可少的，各有优势吧。
04 IT行业学习机会多 IT行业就是需要不断学习的行业。该行业发展迅速，人才辈出，因此在此行业从业者能够随时随地的接触到最新的资讯，了解到最新的技术，不断的充实自己，跟上时代的发展。
03 拥抱变化才有更多机会 坦白讲，许多人骨子里害怕变化和竞争。
其实大可不必。
一来，怕也没用嘛。二来，变化越快，组合要素增加了，意味着新的工作机会越多。
就像传统媒体VS新媒体。
放在10年前连“新媒体”这三个字都没问世，可如今已成为360°覆盖人们的事物。曾经从事纸媒行业的人，开始新模式转型；曾经写书写博客的作者，转移到公众号和微博，以另外一种形式继续写作。
行业是否饱和从来不是关键，关键的还是人。
工作有2个部分，主观+客观。
客观不会迁就你，该来的、该变化，都将像靴子掉落般一一发生。而人的主观则是更重要的部分，你需要知道别人眼下需要什么，你能提供什么，方可站稳脚跟。
最后我想说，不安全感是常态，适度焦虑也是常态，只是，希望我们都能积极地跑起来，别做那个脆弱的人。
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3725fe1dab4d03717cacab3f837ecc78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca341c7806ac24970cb59cd9e4411c8/" rel="bookmark">
			机器学习教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、机器学习的定义 从广义上来说，机器学习是一种能够赋予机器学习的能力以此让它完成直接编程无法完成的功能的方法。但从实践的意义上来说，机器学习是一种通过利用数据，训练出模型，然后使用模型预测的一种方法。
“训练”与“预测”是机器学习的两个过程，“模型”则是过程的中间输出结果，“训练”产生“模型”，“模型”指导 “预测”。机器学习方法是计算机利用已有的数据(经验)，得出了某种模型(迟到的规律)，并利用此模型预测未来(是否迟到)的一种方法。让我们把机器学习的过程与人类对历史经验归纳的过程做个比对。 二、机器学习的范围 其实，机器学习跟模式识别，统计学习，数据挖掘，计算机视觉，语音识别，自然语言处理等领域有着很深的联系。
从范围上来说，机器学习跟模式识别，统计学习，数据挖掘是类似的，同时，机器学习与其他领域的处理技术的结合，形成了计算机视觉、语音识别、自然语言处理等交叉学科。 因此，一般说数据挖掘时，可以等同于说机器学习。同时，我们平常所说的机器学习应用，应该是通用的，不仅仅局限在结构化数据，还有图像，音频等应用。
三、Python机器学习的6大库 Python 用于 AI 和 ML 的 6 大库和框架
Python 编程语言最棒的地方是有大量的机器学习开发的库。以下是 6 大 Python 库，它们通过可读性和强大的算法使人工智能无缝衔接。
1、NumPy
如果没有 NumPy，数据科学将是不完整的。它是一个可以进行科学计算的 Python 软件包。NumPy 是一个神奇的多维数组对象库。它们协同工作，降低了程序的计算复杂性。
2、SciPy
SciPy 是 Python 人工智能项目的另一个热门库，也是涉及数学和工程领域中， Python 程序员科学和重度计算的首选。它提供了数值优化和集成的例程，对于初学者来说非常友好。
3、Scikit-Learn
这个库建立在 NumPy 和 SciPy 之上，主要用于监督和无监督学习。它是一个用于数据挖掘和数据分析的完美工具。
4、Pandas
Pandas 是开源的 Python 软件包，使程序员能够对数据进行操作和分析。它具有高效的数据探索和可视化功能，并提供高级数据结构和多种工具，可用于密切处理多个数据集。
5、Keras
Keras 是一个运行在 TensorFlow 上的 API。Keras的重点是让开发者快速实验人工智能。这个库的用户体验比 TensorFlow 好得多——因为它是用 Python 开发的，所以比其他工具更容易理解。
6、Matplotlib
所有库中最强大的是 Matplotlib。它提供了数据可视化和探索的功能，以及图表、直方图和散点图等，以定制 Python AI 项目。Matplotlib 有助于在更短的时间内快速操作数据进行可视化展示。
这些是 Python和机器学习的6大库。除此以外，还有TensorFlow、NLTK、PyBrain、Caffe等库，这些库会导致AI应用的适当性能。
四、Python机器学习重点 （1）线性代数与微积分 线性代数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ca341c7806ac24970cb59cd9e4411c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a54fccb41389cc9d7dc0a406e9d734/" rel="bookmark">
			可视化库Cartopy安装教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cartopy介绍 Python 环境下常用的地图绘制包是 Basemap，Cartopy，geopandas，KeplerGl，GeoViews等等，我以前常用的是Basemap，但无奈官方已经在2020年更新了，官方推荐使用Cartopy作为替代。
Cartopy最初是在英国气象局开发的，目的是让科学家能够快速、方便、最重要的是准确地在地图上可视化他们的数据。cartopy的主要特点是面向对象的投影定义，以及在投影之间转换点、线、向量、多边形和图像的能力。
pip安装 Cartopy 安装 Cartopy的话官方推荐是使用conda安装
conda install -c conda-forge cartopy 踩的坑 但是我感觉Anconda过于臃肿，而且没有汉化，用起来好难受！！！所以决定用pip安装，踩了一下午的坑qaq
所以今天详细写一下pip的安装教程，大家照着安装就可以了
首先先说一下，我们知道pip安装包一般是如下的命令
pip install xxxxx 但是在Cartopy上不行，Cartopy必须要先安装GEOS、Shapely和 pyshp这三个依赖库，这时候小机灵鬼你又来了，你是不是会说我直接扎这三个库pip安装，然后在pip install cartopy不就好了，虽然这样你也会成功安装，但是你会发现用不了！！！，他喵的
备注:常用的Cartopy依赖库作用
pyproj：处理地图投影变形，Cartopy 基于它定义了丰富的地图投影；
pillow：Python 的图像处理包，读写和操作栅格图像；
pyshp：Python 实现的 ESRI Shapefile 读写包；
shapely：操作和分析空间地理对象；
cartopy：Cartopy 安装包，地图制图工具。
下载依赖库 原因是cartopy和那三个依赖库要对应你python的版本，所以我们需要在 UC Irvine页面寻找你要安装的包与你python版本和电脑所对应的的whl格式文件
https://www.lfd.uci.edu/~gohlke/pythonlibs/ 我以为Shapely为例介绍一下,下方文件p39意思就是python3.9x所对应的版本,amd64表示你电脑是64位的
依次下载下来如下
卸载原有的低版本依赖库 接下来先查找一下所安装的库是否含有Cartopy的依赖库
pip list 然后使用如下命令卸载
pip uninstall xxxx 安装 Cartopy 在cmd窗口中cd进入你存放下载好的文件的文件夹,首先卸载掉原有的低版本依赖库,由于是whl文件,所以需要先下载whl库
pip install whl pip install Shapely-1.8.2-cp39-cp39-win_amd64.whl #注意你的文件名,一个个安装就行,最后安装Cartopy 由于Cartopy一般与matplotlib一起使用,所以我们可以顺便安装一下matplotlib库
pip install matplotlib 验证安装 新建一个python文件,我这里使用的是jupyter.键入如下代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6a54fccb41389cc9d7dc0a406e9d734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353a341997de9608e14b7f6110ccb56f/" rel="bookmark">
			Pytorch 最全入门介绍，Pytorch入门看这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文通过详细且实践性的方式介绍了 PyTorch 的使用，包括环境安装、基础知识、张量操作、自动求导机制、神经网络创建、数据处理、模型训练、测试以及模型的保存和加载。
1. Pytorch简介 在这一部分，我们将会对Pytorch做一个简单的介绍，包括它的历史、优点以及使用场景等。
1.1 Pytorch的历史 PyTorch是一个由Facebook的人工智能研究团队开发的开源深度学习框架。在2016年发布后，PyTorch很快就因其易用性、灵活性和强大的功能而在科研社区中广受欢迎。下面我们将详细介绍PyTorch的发展历程。
在2016年，Facebook的AI研究团队（FAIR）公开了PyTorch，其旨在提供一个快速，灵活且动态的深度学习框架。PyTorch的设计哲学与Python的设计哲学非常相似：易读性和简洁性优于隐式的复杂性。PyTorch用Python语言编写，是Python的一种扩展，这使得其更易于学习和使用。
PyTorch在设计上取了一些大胆的决定，其中最重要的一项就是选择动态计算图（Dynamic Computation Graph）作为其核心。动态计算图与其他框架（例如TensorFlow和Theano）中的静态计算图有着本质的区别，它允许我们在运行时改变计算图。这使得PyTorch在处理复杂模型时更具灵活性，并且对于研究人员来说，更易于理解和调试。
在发布后的几年里，PyTorch迅速在科研社区中取得了广泛的认可。在2019年，PyTorch发布了1.0版本，引入了一些重要的新功能，包括支持ONNX、一个新的分布式包以及对C++的前端支持等。这些功能使得PyTorch在工业界的应用更加广泛，同时也保持了其在科研领域的强劲势头。
到了近两年，PyTorch已经成为全球最流行的深度学习框架之一。其在GitHub上的星标数量超过了50k，被用在了各种各样的项目中，从最新的研究论文到大规模的工业应用。
综上，PyTorch的发展历程是一部充满创新和挑战的历史，它从一个科研项目发展成为了全球最流行的深度学习框架之一。在未来，我们有理由相信，PyTorch将会在深度学习领域继续发挥重要的作用。
1.2 Pytorch的优点 PyTorch不仅是最受欢迎的深度学习框架之一，而且也是最强大的深度学习框架之一。它有许多独特的优点，使其在学术界和工业界都受到广泛的关注和使用。接下来我们就来详细地探讨一下PyTorch的优点。
1. 动态计算图
PyTorch最突出的优点之一就是它使用了动态计算图（Dynamic Computation Graphs，DCGs），与TensorFlow和其他框架使用的静态计算图不同。动态计算图允许你在运行时更改图的行为。这使得PyTorch非常灵活，在处理不确定性或复杂性时具有优势，因此非常适合研究和原型设计。
2. 易用性
PyTorch被设计成易于理解和使用。其API设计的直观性使得学习和使用PyTorch成为一件非常愉快的事情。此外，由于PyTorch与Python的深度集成，它在Python程序员中非常流行。
3. 易于调试
由于PyTorch的动态性和Python性质，调试PyTorch程序变得相当直接。你可以使用Python的标准调试工具，如PDB或PyCharm，直接查看每个操作的结果和中间变量的状态。
4. 强大的社区支持
PyTorch的社区非常活跃和支持。官方论坛、GitHub、Stack Overflow等平台上有大量的PyTorch用户和开发者，你可以从中找到大量的资源和帮助。
5. 广泛的预训练模型
PyTorch提供了大量的预训练模型，包括但不限于ResNet，VGG，Inception，SqueezeNet，EfficientNet等等。这些预训练模型可以帮助你快速开始新的项目。
6. 高效的GPU利用
PyTorch可以非常高效地利用NVIDIA的CUDA库来进行GPU计算。同时，它还支持分布式计算，让你可以在多个GPU或服务器上训练模型。
综上所述，PyTorch因其易用性、灵活性、丰富的功能以及强大的社区支持，在深度学习领域中备受欢迎。
1.3 Pytorch的使用场景 PyTorch的强大功能和灵活性使其在许多深度学习应用场景中都能够发挥重要作用。以下是PyTorch在各种应用中的一些典型用例：
1. 计算机视觉
在计算机视觉方面，PyTorch提供了许多预训练模型（如ResNet，VGG，Inception等）和工具（如TorchVision），可以用于图像分类、物体检测、语义分割和图像生成等任务。这些预训练模型和工具大大简化了开发计算机视觉应用的过程。
2. 自然语言处理
在自然语言处理（NLP）领域，PyTorch的动态计算图特性使得其非常适合处理变长输入，这对于许多NLP任务来说是非常重要的。同时，PyTorch也提供了一系列的NLP工具和预训练模型（如Transformer，BERT等），可以帮助我们处理文本分类、情感分析、命名实体识别、机器翻译和问答系统等任务。
3. 生成对抗网络
生成对抗网络（GANs）是一种强大的深度学习模型，被广泛应用于图像生成、图像到图像的转换、样式迁移和数据增强等任务。PyTorch的灵活性使得其非常适合开发和训练GAN模型。
4. 强化学习
强化学习是一种学习方法，其中智能体通过与环境的交互来学习如何执行任务。PyTorch的动态计算图和易于使用的API使得其在实现强化学习算法时表现出极高的效率。
5. 时序数据分析
在处理时序数据的任务中，如语音识别、时间序列预测等，PyTorch的动态计算图为处理可变长度的序列数据提供了便利。同时，PyTorch提供了包括RNN、LSTM、GRU在内的各种循环神经网络模型。
总的来说，PyTorch凭借其强大的功能和极高的灵活性，在许多深度学习的应用场景中都能够发挥重要作用。无论你是在研究新的深度学习模型，还是在开发实际的深度学习应用，PyTorch都能够提供强大的支持。
2. Pytorch基础 在我们开始深入使用PyTorch之前，让我们先了解一些基础概念和操作。这一部分将涵盖PyTorch的基础，包括tensor操作、GPU加速以及自动求导机制。
2.1 Tensor操作 Tensor是PyTorch中最基本的数据结构，你可以将其视为多维数组或者矩阵。PyTorch tensor和NumPy array非常相似，但是tensor还可以在GPU上运算，而NumPy array则只能在CPU上运算。下面，我们将介绍一些基本的tensor操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/353a341997de9608e14b7f6110ccb56f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a100fefc4a4054ab2b1dfca8fd77f650/" rel="bookmark">
			阿拉伯数字转中文数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过观察会发现规律，就是十百千这三个单位会不断重复。比如在万到亿之间是十万百万千万，亿以上也会有十亿百亿千亿。
所以…
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; string itos(long long num) { // 4 万 // 8 亿 vector&lt;string&gt; unit{"", "十", "百", "千", "万", "", "", "", "亿"}; vector&lt;string&gt; digit{"零", "一", "二", "三", "四", "五", "六", "七", "八", "九"}; int cnt = 0, base = 0; string ans; while (num) { int bit = num % 10; num /= 10; if ((cnt % 4) == 0) ans += unit[cnt]; // 万和亿 ans += unit[cnt % 4]; ans += '0' + bit; cnt++; } reverse(ans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a100fefc4a4054ab2b1dfca8fd77f650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37cebfe89d44f9f7e47d3e170af9c6f6/" rel="bookmark">
			Qt5&#43;VS2013兼容XP方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Qt5+VS2013编译程序默认配置会在XP运行时报"不是有效的Win32程序"
工作需要必须要XP运行
pro文件中加一句:
QMAKE_LFLAGS_WINDOWS = /SUBSYSTEM:WINDOWS,5.01 -------------------------------------------------------
qtbase\mkspecs\common\msvc-desktop.conf
---&gt;请手工修改这一行
QMAKE_LFLAGS_WINDOWS = /SUBSYSTEM:WINDOWS,5.01
-------------------------------------------------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c27acc20747a81ca36a108d4dce8d7d/" rel="bookmark">
			见路不走1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		见路不走，实事求是(发现问题，提出问题，分析问题)，见路不走是’见路非路，即见因果’的意思，跟’见相非相，即见如来’是一个道理，通俗点说就是透过现象看本质。见路不走是实事求事的执行和体现，更具有提示性。见路不走提示我们不要跟着经验，教条跑，也不能跟着形式走，只看因果，本质。
这是个’场’的世界，有多少立场就有多少观点，主意，众生是立场的，利益的，好恶的，众生只相信自己愿意相信的东西，出离立场的观点在立场的圈是没有地方立足的，因为没有’场’可以让你立，面对一个’出离立场’的事物，众生有多少立场和好恶就有多少视角和解释，也就应该有多少视角和解释。当事物作为’果’存在的时候，必然有它的’因’，说出这个因的叫解释因果;唯有变是不变的。
‘实事’就是客观存在着的一切事物，’是’就是客观事物的内部联系，即规律性，’求’就是我们去分析研究。
什么叫问题？问题就是事物的矛盾，哪里有没有解决的矛盾，哪里就有问题。提出问题首先就是要对于问题即矛盾的两个基本方面加以大略的调查和研究，才能懂得矛盾的性质是什么，这就是发现问题的过程。大略的调查和研究问题可以发现问题，提出问题，但还不能解决问题。要解决问题，还必须作系统的周密的调查，研究工作，这就是分析的过程。提出问题也要分析，不然，对着模糊杂乱的一大推事物的现象，你就不能知道问题即矛盾的所在。分析过程是指系统的周密分析过程。问题提出了但还不能解决，就是因为还没有暴露事物的内部联系，是因为还没有经过系统周密的分析过程。一个大的事物，在其发展过程中，包含许多矛盾;一切事物中包含的矛盾方面的相互依赖和相互斗争，决定一切事物的生命，推动一切事物的发展。没有什么事物是不包含矛盾的，没有矛盾就没有世界。过程发展的各个阶段中，只有一种主要的矛盾起着领导的作用，是完全没有疑义的。任何过程如果有多数矛盾存在的话，其中必定有一种是主要的，起着领导的,决定的作用，其他则处于必要和服从的地位。研究任何过程，如果是存在着两个以上矛盾的复杂过程的话，就要用全力找出它的主要矛盾。捉住了这个主要矛盾，一切问题就迎刃而解了。一切过程中矛盾着的各方面，本来是相互排斥，相互斗争，相互对立的。
一点两面三三制，三猛战术，四快一慢
谁是我们的敌人，谁是我们的朋友，团结真正的敌人以攻击真正的敌人
无损复制，最大市场系数
马克思主义的方法去观察问题，提出问题，分析问题，解决问题，我们所办的事才能办好，我们的事业才能胜利。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc657ae02e3b5dd36ef4c8f5863cac0/" rel="bookmark">
			VSCode 使用 Vue2.0 通用结构模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装vscode 官网：https://code.visualstudio.com/
安装 Vetur 插件，识别 vue 文件 应用商店中搜索 Vetur，点击安装，安装完成之后点击重新加载
新建代码片段 文件 ➡ 首选项 ➡ 用户代码片段 ➡ 点击新建全局代码片段 ➡ 取名 vue ➡ 确定
粘入自定义 .vue 模板，代码如下
{ "Print to console": { "prefix": "vue", "body": [ "&lt;!-- $1 --&gt;", "&lt;template&gt;", "&lt;div class='$2'&gt;$5&lt;/div&gt;", "&lt;/template&gt;", "", "&lt;script&gt;", "//这里可以导入其他文件（比如：组件，工具js，第三方插件js，json文件，图片文件等等）", "//例如：import 《组件名称》 from '《组件路径》';", "", "export default {", "//import引入的组件需要注入到对象中才能使用", "components: {},", "data() {", "//这里存放数据", "return {", "", "};", "},", "//监听属性 类似于data概念", "computed: {},", "//监控data中的数据变化", "watch: {},"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc657ae02e3b5dd36ef4c8f5863cac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c973cd3e6c2a831b06803c58150ca1a8/" rel="bookmark">
			(14)微信自动化测试-针对微信控件元素截图操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在(12)PC端微信自动化UI测试-C#采集微信聊天记录 一篇文章中，我们实现了聊天记录的采集功能，但是有小伙伴提出了无法采集到聊天图片的信息，其实我们的组件中已经提供了这块的实现，接下来我为大家解惑！
20240105-1126-1
在FlaUI组件的 AutomationElement 对象下提供了Capture()和CaptureToFile()方法让我们将微信某个UI视觉对象转化为一个Bitmap对象。
private void toolStripButton2_Click(object sender, EventArgs e) { var currentNode = treeView1.SelectedNode.Tag as AutomationElement; if (currentNode != null) { currentNode.Focus(); var map = currentNode.Capture(); ShowElementImage image = new ShowElementImage(); image.SetImage(map); image.Show(); } else { MessageBox.Show("请选择元素"); } } 如果读者对上述文章存在不清晰的地方可以找本人获取运行源码来学习，QQ 978124155
上一篇 下一篇 (15)微信自动化测试-针对微信主窗体的行为控制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd073cd913754d6e9fb9c472b39eb582/" rel="bookmark">
			树形结构存储方案对比分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、邻接表 关系只由一个parent_id维护
1、优点：结构简单，易插入
2、缺点：不易查询
二、前缀编码（物化路径） 存储节点的完整层级路径，借助了unix文件目录的思想。
1、优点：查询方便（效率较高，得看数据分布的选择性程度）
2、缺点：层级太深有可能会超过PATH字段的长度，占用空间大
3、查询示例：
// 查询某一节点下的所有子节点:（以Fruit为例） SET @path = (SELECT path FROM pathTree WHERE node_name = 'Fruit'); SELECT * FROM pathTree WHERE path like CONCAT(@path,'/%'); // 如何查询直属子节点？需要采用MySQL的正则表达式查询： SET @path = (SELECT path FROM pathTree WHERE node_name = 'Fruit'); SELECT * FROM pathTree WHERE path REGEXP CONCAT(@path,'/','[0-9]$'); // 查询任意节点的所有上级：（以Yellow为例）： SET @path = (SELECT path FROM pathTree WHERE node_name = 'Yellow'); SELECT * FROM pathTree WHERE @path LIKE CONCAT(path, '%') AND path &lt;&gt; @path; // 插入新增数据： SET @parent_path = ( SELECT path FROM pathTree WHERE node_name = 'Fruit'); INSERT INTO pathtree (path,node_name) VALUES (CONCAT(@parent_path,'/',LAST_INSERT_ID()+1),'White') 三、左右值编码 利用二叉树的前序遍历（根、左、右）思想编码，存储节点的左右子节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd073cd913754d6e9fb9c472b39eb582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571583a81785e10905a6db270307a393/" rel="bookmark">
			CATIA的OOTB原生命令的探索与调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OOTB原生命令的探索与调用 一、打开CATIA二、选择自定义三、进入命令的XCAA2的工作间呈示四、托进工具条中五、打印（建议全选打印）六、可在文档里根据命令的中文名，找到对应ID的内容，查看对应命令七、调用方法 一、打开CATIA 二、选择自定义 三、进入命令的XCAA2的工作间呈示 四、托进工具条中 五、打印（建议全选打印） 先关闭上述 “定制” 窗口,再点击拖进来的那个图标进行打印：
六、可在文档里根据命令的中文名，找到对应ID的内容，查看对应命令 七、调用方法 其他：
也可以使用脚本调用VB宏代码和直接开发的按钮命令来实现相应效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9aebd1ade597ba95b75639479bea00/" rel="bookmark">
			FA2016AA (MHz范围晶体单元超小型低轮廓贴片) 汽车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &amp;nbsp; &amp;nbsp; &amp;nbsp;随着科技的不断发展，智能汽车逐渐成为人们出行的首选。而其中，频率范围在19.2 MHz ~ 54 MHz的晶体单元超小型低轮廓贴片（FA2016AA）为汽车打造更智能、更舒适、更安全的出行体验。FA2016AA贴片的外形尺寸为2.0 × 1.6 × 0.5 mm，超小型，超薄型，完美融入汽车的各项设计，不占用空间，不影响性能。&amp;nbsp;基本泛音
FA2016AA贴片具备基本泛音效果，能够对周围环境的声音进行智能识别，并根据声音变化做出相应的调整。通过这一技术，贴片能够有效减少噪声干扰。
FA2016AA贴片支持多种应用程序，如汽车配件，汽车摄像系统，车身控制，汽车多媒体。FA2016AA贴片兼容AEC-Q200标准，满足汽车行业的各类需求，为用户带来更广泛的适用性。
规范 外形尺寸 足迹(推荐) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f99d0a9bf691cc01bbb177b6ec8244d2/" rel="bookmark">
			一、交换机的基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、交换机的基本配置 （制作不易，请多点点关注！）
实验目的：
（1）掌握通过console口对交换机配置；
（2）理解并掌握交换机初始配置。
实验器材：
一台PC机，一台以太网二层交换机，console线。
实验内容：
使用PC机通过交换机console口对交换机进行初始配置。
实验步骤：
1、运行Cisco Packet Tracer软件，在逻辑工作区放入一台交换机和一台工作站PC，用控制台电缆（Console）连接交换机和工作站PC，交换机端接Console口，PC端接RS232口。
2、点击工作站PC，进入其配置窗口，选择桌面（Desktop）项，选择运行超级终端（Terminal），弹出超级终端设置（Terminal Configuration）对话框，点击OK按钮确定。
3、弹出超级终端运行界面，显示交换机的启动信息，出现“Press RETURN to get started!”提示，按“回车”键直到出现用户模式提示符Switch&gt;
表4-1 交换机配置
①从用户模式进入特权模式
②从特权模式进入全局配置模式
③设置交换机名称为SwitchA
⑤从特权模式进入全局配置模式
⑥禁止名称解析服务
⑦退到上一级操作模式
⑧从特权模式进入全局配置模式
⑨配置管理IP
⑩设置默认网关地址
⑪从特权模式进入全局配置模式
⑫进入端口1配置模式
⑬配置端口速度
⑭端口工作模式配置
⑯显示启动配置文件内容
⑰显示VLAN信息
⑱显示端口信息
6、配置交换机支持Telnet
(1) 设置计算机的IP地址和子网掩码分别为192.168.0.2、255.255.255.0。
(2)在交换机上配置管理IP地址
验证测试：验证交换机管理地址已经配置和开启。
（3）配置交换机远程登录密码
（4）保存在交换机上所做的配置
验证测试：
实验结果（附数据和图表）：
显示端口信息：
配置交换机远程登录密码：
配置完后用密码远程登陆交换机：
实验结果分析及结论：
通过在交换机上划分VLAN,并用ping命令测试在同VLAN和不同VLAN中设备的连通性，验证了在交换机上划分VLAN的作用。通过这个实验，学会了设置Tag VLAN Trunk属性、怎样用命令语言划分VLAN以及怎样测试等操作,也更加熟悉交换机的VLAN配置，深入了解了交换机的基本配置、VLAN配置及给交换机设置远程登录密码等知识，对于今后的网络管理和维护都有很大的帮助，受益匪浅。
实验心得体会和建议：
本次实验中对交换机的基本配置的学习研究有了新的体会,掌握了在计算机上配置交换机的基本配置步骤,交换机命令行各种操作模式的区别，以及模式之间的切换。另外对交换机的工作原理也有了进一步的认识。 实现上有了一定的突破，在配置过程中用到的命令,让我感觉到英语也要多学习，对配交换机有很大帮助!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48fe7e1c639b812217ac1eb453cf02e5/" rel="bookmark">
			Excel如何将单元格设为文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、打开excel文件二、选中单元格三、右键设置单元格格式四、设置界面选择文本后点确定五、其他问题 在caa开发过程中遇到从CATUnicodeString转成CString时，通过SetItemText写入将ID号写入单元格，无法保存ID号中的数字0，故将单元格格式改为文本来存储。效果如下： 单元格格式为默认的“常规”时，ID号中所有的前缀 “0 ”丢失：
单元格格式为“文本”时，正常：
一、打开excel文件 二、选中单元格 三、右键设置单元格格式 四、设置界面选择文本后点确定 五、其他问题 关闭开发的程序后，打开xlxs文件查看内容，若显示被锁定
说明开发的程序不直接打开编辑.xlxs的软件，而是在后台启用了其进程进行写入编辑操作，关闭开发的程序后，该进程还在，可手动结束进程或者使用C++做杀进程来解除占用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b2e2a7f5d489e9bb326758510b8982/" rel="bookmark">
			零基础程序员自学编程的6种方法，你知道吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网日趋迅猛，编程已经在我们生活当中无处不在了。众所周知，程序员的工资都很不错，于是越来越多的人，都想加入到编程的行业中来。那么如何加入到程序员的行业当中？
PHP从入门到放弃，C语言从入门到放弃，Java从入门到放弃，Python从入门到放弃...
在自学编程的过程中，一部分程序员遇到冰冷的英语字母，枯燥的编程教程，果断选择了放弃。
但其实自学编程不是那么难，只要是逻辑思维或者理科比较好的还行的小伙伴，编程入门完全可以。
下面小编就介绍一些自学编程的小方法，希望能对你有帮助：
首先我们要明确自己的学习目标，不管我我们学习什么样的知识，都要有一个明确的目标，我们需要朝着目标前进，才能少走弯路，从而在学习中得到提升。
0.最好的学习方式 对于初学者来说，可以采用视频+书籍的方式进行学习。这两种方式形成互补关系。另外阅读代码也可以帮助你解决问题，了解最佳做法，这里的阅读代码是指书籍，博客文章，开源代码等等。
编程教学视频可以让你迅速掌握编程语法等等，比较生动、容易理解。而书本是比较系统，还有很多细节视频不会讲的，但是枯燥，所以最好的方法是书和视频结合。
当你已经过了入门期之后，看书、看视频、看博客就可以随心所欲。
但在阅读代码后，你需要自己实际去写代码。可以是任何东西。可以是小的编码任务或者是一个小模块，必须确保你能将之付诸于实践，并用某种方式使用你学到的东西。如果你不这样做，你会发现自己面对编辑器会无从下手。知识等待使用的时间越长，知识这把斧头就越钝。等待学习新知识的时间越久，你就越难以将其融入到代码中。
1.入门期坚持学习 自学编程难免遇到这种现象：学了一两个月，发现自己会的不多。
编程在一开始不会有那么大的反馈，这种现象非常正常！关键是你要坚持个三个月到半年的时间，熬过这个艰难的入门期。
小编推荐三件事情以避免僵局。第一是试着阅读更多关于技术的文章，并总体掌握正在发生什么。通常，当你陷入困境时，意味着你对需要澄清的事情做出了不正确的假设。第二是咨询互联网。这一点很显然是值得一提。在网上查找并询问有过这个问题的人是一个非常重要的技能。Stackoverflow可以说是互联网上最好的网站。不要害怕在那里问自己的问题。通常，只要尽力正确地阐述你的问题就OK了。小编的第三个建议是向你认识的人请求帮助。通常，你或许已经理解了技术，而且有了问题，但是你可能需要更高层次的上下文才能真正解开谜团。不要胆怯，大着胆子上前去问吧。
2.初学者尽量不要钻牛角尖 对于人生来说，其中任何目标的实现都离不开耐心。编程学习就如其它任何学习任务一样，都需要反复努力并投入大量时间。
如果遇到难题，耗了半天时间还是没弄懂，可以暂时跳过，知识积累到一定程度，回头再进行解决你会发现简单多了。不要一味的去钻牛角尖，一定要解决，这样会耗费大量的时间与精力。
3.寻找良师益友 学习编程的一个很好的方法就是和其他的程序员交谈。不必谈论任何特定的内容。可以是你正在学习的东西，也可以是你认为很酷的东西，更可以是你正在工作的东西，皆可。你会发现很多程序员并不喜欢只是聊编程。这样做可能会让你学到很多关于库，服务器，编程语言和模式方面的知识。但是，最重要的是，你将了解到其他人是如何看待编程的。你会发现，你认为理所当然或从来没有考虑的事情在人与人之间是非常不同的。
还有你遇到的那些小问题，已经有无数前辈也曾遇到过，他们总结了并分享在互联网上了，前人的经验是你的宝贵资源，要善于利用谷歌等软件。
4.有目的的练习 不要想着学习完就可以赚1w+这样很容易放弃编程，编程语言是一个很大的知识库，需要你不断的学习。
最好是奔着一个小项目而学习编程，当你把作品做出来了，有了成就感，同时基本上具备找工作的能力，就找个初级的开发岗位，再进阶，你的自学之路功与名都有了。
没有什么可以与工作于自己的项目以学习编程更有用的了。有了一个点子并试图实现这个点子是非常具有挑战性的。它需要很强的自律心及耐心。但是，通过尝试实际做一件事情，你可以学到如何分解问题并应用技术。你面对的各种问题，以及你如何解决它们才真正是所谓的编程。此外，想要完成项目的驱动力是继续学习的动力。从业余项目获得的满足感远远超过你在抽象中学习东西的满足感。
小编建议，选择你感兴趣的同时你也有想法如何实现的东西。能够在开始之前表达实现总是有助于保持我的动力。在此旅途之中你一定会学到很多！
5.完美主义者和搬运工的区别 编程是一门手艺，需要反复练习，脱离书本和视频看是否能独立实现？学到最后的境界无非就是：我亦无他，惟手熟尔 。
有两种类型的程序员：完美主义者和搬运工。有些人希望一切都是正确的，他们希望完美，他们希望遵循所有的最佳实践，并写出漂亮的优雅的代码。他们想要理解每一行代码。有别于那些不管三七二十一，只要自己的代码能工作即可，即使对代码库有损害的人。平衡这两种技能是非常重要的。有时你应该深入钻研一个问题或项目，看看发生了什么。有时你应该让它工作即可，即使你不知道发生了什么。
每当你花费太多时间在某个东西上时，那就问问自己：我应该采取哪种方法？在大多数情况下，你会想取中间值。你想提供一个好的、坚实的解决方案，同时你可以自信地理解和修改，但没有耗费荒谬的时间。随着你作为开发人员的成长，你会更好地明白什么时候就此离开就可以，以及什么时候需要以某些方法完成。
结论 这些方法可以帮助新手在他们漫长的学习旅程中起到至关重要的作用。我知道需要学习的东西还很多，并将继续学习。最重要的事情说三遍，请继续，不要放弃，不要放弃，不要放弃。当然，说说容易，因为学习编程有时可能会令人非常沮丧！不要担心。这是正常的。每个人都经历过这样的心情
最后免费分享给大家一份Python全套学习资料，包含视频、源码，课件，希望能帮到那些不满现状，想提升自己却又没有方向的朋友。
点击免费领取：Python开发全套学习笔记/实战项目/安装工具长按二维码【添加微信】 即可免费领取资料！！！【100%免费获取】Python开发资料+永久开发工具+各类https://mp.weixin.qq.com/s/JV46bELrtsoNurF44PCEBA
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具 三、Python视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。 四、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。 五、Python练习题 检查学习结果。 六、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。 这份完整版的Python全套学习资料已经打包好，需要的小伙伴可以戳下方链接免费领取
读者福利《Python全套学习资料》，戳这里免费领取！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8282f0cdd00f917216fc6ad4431ac3da/" rel="bookmark">
			适合Python练手的8个经典项目，有趣又实用，提升Python编程能力必看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享的，是一些实战练习的小案例，如果你还是Python小白，可以再看看我前面几篇文章，如果是有了一点基础，那就尝试完成下面这些案例吧！
一、自动发送邮件
用Python编写一个可以发送电子邮件的脚本。
提示：email库可用于发送电子邮件。
import smtplib from email.message import EmailMessage email = EmailMessage() ## Creating a object for EmailMessage email['from'] = 'xyz name' ## Person who is sending email['to'] = 'xyz id' ## Whom we are sending email['subject'] = 'xyz subject' ## Subject of email email.set_content("Xyz content of email") ## content of email with smtlib.SMTP(host='smtp.gmail.com',port=587)as smtp: ## sending request to server smtp.ehlo() ## server object smtp.starttls() ## used to send data between server and client smtp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8282f0cdd00f917216fc6ad4431ac3da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8ecaaf8f53df0a1fbfa616e3fcf9af/" rel="bookmark">
			（2023）mac 安装Android studio（安装jdk，Android SDK）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装jdk并配置环境变量 1.下载安装jdk 网址：Java Downloads | Oracle
注意这里需要注册登录后才可下载。
选择下载java8，jdk1.8。打开安装即可。
​
2.配置环境变量 打开终端，输入java -version，能够看到jdk版本；
​ 查看jdk的位置，/usr/libexec/java_home -V；记下这个路径，后面配置环境变量会用到；
​
然后open .bash_prfile文件，如果没有则touch .bash_profile新建 ；
加入以下内容： JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_361.jdk/Contents/Home
PATH=JAVAHOME/bin:JAVA_HOME/bin:JAVAH​OME/bin:PATH:.
CLASSPATH=JAVAHOME/lib/tools.jar:JAVA_HOME/lib/tools.jar:JAVAH​OME/lib/tools.jar:JAVA_HOME/lib/dt.jar:.
export JAVA_HOME
export PATH
export CLASSPATH
其中第一个JAVA_HOME要改成自己的路径，就是上一步查到的。
配置完成后，输入命令echo $JAVA_HOME验证。
​
二、下载安装Android studio 官网：developer.android.com/studio
下载最新版即可；
​
​
根据自己电脑芯片类型选择是intel还是apple芯片，下载对应的安装包拖进去即可；
​
打开后，根据安装向导进行一些配置即可，一直选next，直到安装成功。
三、软件配置与安装Android SDK 启动软件打开项目后，还需要安装一些东西，第一次打开需要等待比较久。
​
1.选择jdk版本 菜单-&gt;Android Studio-&gt;Preferences
Build, Execution, Deployment-&gt;Build Tools-&gt;Gradle
可切换jdk版本。
​
2.安装SDK并配置环境变量 菜单-&gt;Android Studio-&gt;Preferences
Appearances &amp; Behavior-&gt;System Settings-&gt;Android SDK
如果安装sdk,选中要安装的版本后 点 Apply 按钮会开始下载并安装。
​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8ecaaf8f53df0a1fbfa616e3fcf9af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dbff873f4c27924775fed4931bba5ac/" rel="bookmark">
			Java学习6个阶段，完整Java入门教程学习步骤来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java是一门跨平台的面向对象编程语言，应用广泛，尤其在企业级应用开发方面有很高的竞争力。如果你想学习Java编程，那么本篇文章将为你提供一个完整的Java入门教程学习步骤，帮助你从零开始学习Java。
第一步：下载和安装Java开发工具 为了学习Java编程，你需要下载和安装Java开发工具。官方的Java开发工具是JDK(Java Development Kit)，你可以在Oracle官网下载JDK。下载成功后，按照提示进行安装即可。
第二步：了解Java基础知识 在学习Java编程之前，你需要了解一些Java基础知识，如常量、变量、运算符、流程控制等。在这个阶段，你可以通过阅读Java编程书籍或者观看Java编程视频教程来了解这些基础知识。
第三步：学习Java面向对象编程 Java是一门面向对象编程语言，因此在学习Java编程时，你需要了解对象、类、继承、封装、多态等面向对象编程概念及相关知识。
第四步：学习Java数据结构和算法 学习Java数据结构和算法可以使你更好地理解Java编程思想，也可以为你以后的Java编程工作打下基础。在这个阶段，你可以学习Java集合框架、数组、链表、树等数据结构，同时也可以了解Java中常用的算法，如递归、排序等。
第五步：学习Java框架和开发工具 Java具有非常丰富的框架和开发工具，如Spring、Hibernate、Maven、Eclipse、IntelliJ IDEA等。在这个阶段，你需要了解一些Java框架和开发工具的基本用法，以便能够更好地进行Java编程。
第六步：练习Java编程 经过前面的学习之后，你已经掌握了Java编程的基础知识和相关技能。在这个阶段，你需要通过不断地练习来提高自己的Java编程能力，如编写小程序、练习算法、编写Java Web应用等。
总结 Java编程是一项很有挑战性的任务，但是只要你掌握了必要的Java基础知识，学习Java编程就会变得更加容易。通过不断地学习和练习，你会逐渐成为一名Java编程高手，并且能够为公司或个人开发出高效、高质量的Java应用。
题外话 在此疾速成长的科技元年，编程就像是许多人通往无限可能世界的门票。而在编程语言的明星阵容中，Python就像是那位独领风 骚的超级巨星， 以其简洁易懂的语法和强大的功能，脱颖而出，成为全球最炙手可热的编程语言之一。
Python 的迅速崛起对整个行业来说都是极其有利的 ，但“人红是非多”，导致它平添了许许多多的批评，不过依旧挡不住它火爆的发展势头。
如果你对Python感兴趣，想要学习pyhton，这里给大家分享一份Python全套学习资料，都是我自己学习时整理的，希望可以帮到你，一起加油！
😝有需要的小伙伴，可以点击下方链接免费领取或者V扫描下方二维码免费领取🆓
👉CSDN大礼包🎁：全网最全《Python学习资料》免费分享（安全链接，放心点击）👈
​
1️⃣零基础入门 ① 学习路线 对于从来没有接触过Python的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
② 路线对应学习视频 还有很多适合0基础入门的学习视频，有了这些视频，轻轻松松上手Python~
③练习题 每节视频课后，都有对应的练习题哦，可以检验学习成果哈哈！
2️⃣国内外Python书籍、文档 ① 文档和书籍资料 3️⃣Python工具包+项目源码合集 ①Python工具包 学习Python常用的开发软件都在这里了！每个都有详细的安装教程，保证你可以安装成功哦！
②Python实战案例 光学理论是没用的，要学会跟着一起敲代码，动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。100+实战案例源码等你来拿！
③Python小游戏源码 如果觉得上面的实战案例有点枯燥，可以试试自己用Python编写小游戏，让你的学习过程中增添一点趣味！
4️⃣Python面试题 我们学会了Python之后，有了技能就可以出去找工作啦！下面这些面试题是都来自阿里、腾讯、字节等一线互联网大厂，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
5️⃣Python兼职渠道 而且学会Python以后，还可以在各大兼职平台接单赚钱，各种兼职渠道+兼职注意事项+如何和客户沟通，我都整理成文档了。
上述所有资料 ⚡️ ，朋友们如果有需要的，可以扫描下方👇👇👇二维码免费领取🆓
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e14ae00b65ec81f0ea524768e374de8/" rel="bookmark">
			springcloud之Feign超时提示Read timed out executing POST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： Feign接口调用分两层，Ribbon的调用和Hystrix调用，理论上设置Ribbon的时间即可，但是Ribbon的超时时间和Hystrix的超时时间需要结合起来，按照木桶原则最低的就是Feign的超时时间，建议最好配置超时时间一致.当Fegin调用时，调用的外部接口，延迟挺大，会造成Feign一直提示Read timed out executing POST
解决方法： yml文件中如下配置即可
#hystrix的超时时间 hystrix: command: default: execution: timeout: enabled: true isolation: thread: #超时设置 timeoutInMilliseconds: 30000 ribbon: ReadTimeout: 30000 #ribbon的超时时间 ConnectTimeout: 30000 ------------------------------------------与正文内容无关------------------------------------
如果觉的文章写对各位读者老爷们有帮助的话，麻烦点赞加关注呗！小弟在这拜谢了!
如果您觉得我的文章在某些地方写的不尽人意或者写的不对，从而让你对你人生观产生颠覆（概不负责），需要斧正，麻烦在评论区不吝赐教，作者看到后会根据您的提示查阅文章进行修改，还这世间一个公理一片蓝天
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/520de3e92169c1e68cbcbbbb05a780cf/" rel="bookmark">
			为什么你的pycharm打开时很卡，今天来教你解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多刚开始使用pycharm不太熟练的小伙伴，每天一开机打开pycharm总是卡半天，不知道的还以为是电脑卡了或者啥问题的。莫慌，其实并不是…
今天我们就来解决一下这个问题
大致总结了以下这几种方法
1、exclude不必要文件
依次打开 file(文件) → project：administrator（project：administrator 项目：管理员） → project structure （项目结构），把没有用的都删掉就可以了。
2、关闭自动更新
依次打开 file(文件) → appearance &amp; behavior （外观和行为）→system settings （系统设置）→ updates (更新) → 取消对钩
3、退出时把.py或.ipynb 的文件关掉， 不关掉的话，第二次打开pycharm会预加载python文件中的库。
4、使用节能模式，CPU使用率明显降低。
依次点击 file(文件) → power save mode (省电模式) 即可
5、电脑配置过低
硬件要求的话当然有条件就弄好一点，没条件将就一下吧。
​最后 为了帮助大家更好的学习网络安全，小编给大家准备了一份网络安全入门/进阶学习资料，里面的内容都是适合零基础小白的笔记和资料，不懂编程也能听懂、看懂，所有资料共282G，朋友们如果有需要全套网络安全入门+进阶学习资源包，可以点击免费领取（如遇扫码问题，可以在评论区留言领取哦）~
😝有需要的小伙伴，可以点击下方链接免费领取或者V扫描下方二维码免费领取🆓
👉CSDN大礼包🎁：全网最全《网络安全入门&amp;进阶学习资源包》免费分享（安全链接，放心点击）👈
​
网络安全源码合集+工具包
​​
网络安全面试题
最后就是大家最关心的网络安全面试题板块
所有资料共282G，朋友们如果有需要全套网络安全入门+进阶学习资源包！ ​视频配套资料&amp;国内外网安书籍、文档
😝有需要的小伙伴，可以点击下方链接免费领取或者V扫描下方二维码免费领取🆓
👉CSDN大礼包🎁：全网最全《网络安全入门&amp;进阶学习资源包》免费分享（安全链接，放心点击）👈
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd9a7ca0777644211e92582b101bc1eb/" rel="bookmark">
			PyCharm安装PyQt5及工具（Qt Designer、PyUIC、PyRcc）详细教程来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt是常用的用户界面设计工具，而在Python中则使用PyQt这一工具包，它是Python编程语言和Qt库的成功融合。这篇博文通过图文详细介绍在PyCharm中如何完整优雅地安装配置PyQt5的所有工具包，主要内容包括PyQt5、PyQt5-tools的依赖包安装和Qt Designer、PyUIC、PyRcc三个工具的设置。最后简单演示了PyQt5的调用方式及三个工具的使用方法。
前言 很多情况下需要为程序设计一个GUI界面，在Python中使用较多的用户界面设计工具是PyQt。由于通常我们使用较多的IDE是PyCharm，为了方便地使用PyQt进行用户界面设计，这里总结了在PyCharm安装配置的简单安装方法。可能有人还不清楚这几个工具的用途，这里对要安装配置的依赖包和工具简介如下：
PyQt5：PyQt5是一套Python绑定Digia QT5应用的框架。Qt库是最强大的GUI库之一，PyQt5做为Python的一个模块，它有620多个类和6000个函数和方法。这是一个跨平台的工具包，它可以运行在所有主要的操作系统，包括UNIX，Windows，Mac OS。PyQt5是双重许可。开发者可以在GPL和商业许可之间进行选择，详细可访问PyQt5的官方网站。
PyQt5-tools：PyQt5中没有提供常用的Qt工具，比如图形界面开发工具Qt Designer，PyQt5-tools中包含了一系列常用工具。
Qt Designer：可以通过Qt Designer来编写UI界面，Qt Designer的设计符合MVC的架构，其实现了视图和逻辑的分离，从而实现了开发的便捷。Qt Designer中的操作方式十分灵活，其通过拖拽的方式放置控件可以随时查看控件效果。Qt Designer随PyQt5-tools包一起安装，其安装路径在 “Python安装路径\Lib\site-packages\pyqt5-tools”下。
PyUIC：Qt Designer生成的.ui文件（实质上是XML格式的文件）可以通过pyuic5工具转换成.py文件。
PyRcc：在使用PyQt开发界面时，在Qt Designer中使用的图片等资源需要将其编译为py文件，这时需要用到PyRcc工具方便地将qrc文件转换为py文件。
​
1. 工具包安装 对于一个新创建的Python环境，首先需要安装PyQt的相关工具包，因为是Python的依赖包所有可以通过pip进行安装，由于我们在PyCharm中进行程序设计，这里我们可以通过PyCharm中的环境管理界面进行安装。对于新建的项目test，其文件界面如下图所示：
点击菜单栏“File”，选择弹出的“Setting”选项，如下图所示：
选择“Project”，选择弹出的“Project Interpreter”选项，点击可看到当前已安装的环境和依赖包，如下图所示，点击右侧“加号”按钮可添加新的依赖包：
pyqt5
可以看出当前尚未安装pyqt5的依赖包，点击“加号”按钮弹出安装界面如下图所示，在搜索框输入“PyQt5”可以搜索到对应的依赖包，点击“Install Package”按钮进行安装（绿色框处可选择安装版本），等待安装完成：
PyQt5-tools
同样地安装PyQt5-tools工具包，在搜索框中输入“PyQt5-tools”，选中要安装的依赖包，点击“Install Package”进行安装，如下图中所示的步骤所示：
这两个工具包安装完成，返回上一界面可以看到依赖包管理界面中出现了这两个依赖包，如下图所示：
至此PyQt的工具包安装完成，在编辑器或命令行可以通过“import PyQt5”调用该库。这里确定一下安装位置，正常情况下这两个包的安装位置在Python的安装目录下的“\Lib\site-packages\”目录，如我这里的两个安装位置如下图所示（我这里Python为虚拟环境，安装位置在“E:\test\venv”）：
2. 设计工具配置 依赖包安装完成，接下来介绍如何在PyCharm中添加工具，其实这几个工具在安装PyQt5-tools的时候已经包括在目录中，只不过要在PyCharm中方便使用还需要一些配置步骤。首先为了保证Windows系统能够正确识别PyQt5-tools的常见命令，还需要将PyQt5-tools的安装目录添加到系统环境变量Path中。
环境变量设置
一、在文件管理器中右击“我的电脑”，弹出快捷菜单，选择“属性”→“高级系统设置”弹出系统属性对话框，如下图所示：
二、选择“高级”，点击下面的“环境变量”，弹出环境变量设置框，选择系统变量中的“Path”变量，如下图所示：
三、双击“Path”环境变量，进入环境变量编辑界面，点击“编辑”在最后添加pyqt5-tools的安装位置，点击确定，如下图所示：
这一步也可以选择“浏览”，通过文件夹选择对话框选中pyqt5-tools的安装位置，其安装路径在 “Python安装路径\Lib\site-packages\pyqt5-tools”（需根据实际情况进行修改），如下图（点击放大图片）所示：
四、在环境变量界面中点击“新建”，在系统环境变量中新建名为“QT_PLUGIN_PATH”的变量，如下图所示：
该变量值为Qt插件的安装位置，可通过“浏览目录”依次找到“plugins”文件夹，通常其位置在“Python安装路径\Lib\site-packages\PyQt5\Qt\plugins\”位置（需根据实际情况修改），点击“确定”，如下图所示：
环境变量设置完成，接下来介绍在PyCharm中设置Qt工具，主要包括Qt Designer、PyUIC、PyRcc这三个工具，前言中已介绍其作用，下面依次介绍工具设置过程。
​
Qt Designer
一、点击菜单栏“File”，弹出下拉框，选择“Setting”，弹出设置界面。在设置界面中选择“Tools”→“External Tools”，该部分操作如下图所示：
点击“加号”按钮新建工具，弹出工具配置界面：在“Name”一栏填写“Qt-Designer”；在“Program”一栏填写designer.exe文件位置，我这里位置为：“E:\test\venv\Lib\site-packages\pyqt5_tools\Qt\bin\designer.exe”（需根据实际情况填写）；在“Working directory”一栏填写“”。最后点击“OK”，如下图所示：
二、点击菜单栏“Tools”，弹出下拉框，选择“External Tools”，弹出工具选择框。选择“Qt-Designer”并点击，若出现Qt Designer的软件界面则表示配置成功，当然也可能出现如下的问题框：
‪若出现以上问题，解决方案是将pyqt5_tools\Qt\plugins文件夹进行复制，覆盖到site-packages\pyqt5_tools\Qt\bin目录下，覆盖后的文件夹如下：
以上操作后，再次按照步骤二的操作即可打开Qt Designer软件界面。
PyUIC
一、同样按照以上方式添加PyUIC工具，点击“加号”按钮，在弹出的编辑设置框中Name一栏填写“PyUIC”；
二、Program中填写pyuic5.exe这个程序的文件路径，一般在“Python环境目录\Scripts\pyuic5.exe”（此处需根据实际情况修改），也可以点击右侧的文件夹选择按钮浏览文件夹选中该位置；
三、在Arguments中内容填写如下：
$FileName$ -o $FileNameWithoutExtension$.py 四、Working directory内容填写如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd9a7ca0777644211e92582b101bc1eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9654e17af5b3c51b40349c9b8da10091/" rel="bookmark">
			关于mipi数据的一些评估计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 了解最大数据传输速率的限制 image.png
qcom文档已经解释得比较清楚了，这边详细解析一下。主要限制在两个方面，第一个是mipi协议的限定，D-PHY为mipi协议中的物理传输层，规定每lane最大传输数据量为1.5 Gbps，就是每秒传输1.5G的bit，该值为理论值，实际可能就1.0Gbps；第二个方面是平台的数据处理能力，该平台最大VFE时钟为266MHZ，则该平台每lane能处理数据量为 266M * (raw图一像素bit数) / lane num ，对应驱动op_pixel_clk属性值。
二、根据分辨率选择合适的输出 image.png
上图列出了各种size输出状态下的最大分辨率case的mipi 的传输速率配置，那假如需要720p的30fps预览输出需要怎么配置:
可以计算下一秒需要传输的数据：1280 * 720 * 10 * 30 = 264 M
则mipi data最少需要264Mbps，不过这个数值一般sensor供应商会算好。不过mipi协议并不是只传帧数据，还有帧头帧尾，控制信号等等 ，所以实际配置的mlk一定会留有一定余地的。
三、 数据量评估 使用上面8M sensor 全尺寸输出预览30fps，2 lane传输，看是否能够hold住：
每lane 比特传输速率 : 8M * 10 * 30 / 2 = 1200 Mbps (接近1.5 Gbps)
像素传输速率 : 8M * 30 = 240 Mhz (接近266 Mhz)
作者：窝窝蜗牛
链接：https://www.jianshu.com/p/18e054600b7a
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
---------------------
作者：染不尽的流年
来源：CSDN
原文：https://blog.csdn.net/flomingo1/article/details/118693813
版权声明：本文为作者原创文章，转载请附上博文链接！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9654e17af5b3c51b40349c9b8da10091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9299a39776d3f2eda97eaba7c5b85f1/" rel="bookmark">
			word2019保存后的图片变模糊了怎么办？Word 2019 默认保存后压缩变模糊的问题，解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Word 2019 默认保存后压缩变模糊的问题，解决方案
1，新建word 文件，插入一张原始图片，1080*1920，如下图：
2，保存时，word 2019默认选项，导致word 保存后，图片变模糊的原因如下图：
3，勾选选项如下图：
4，点击“确定”, 以后word将不再压缩图片，保持原有的清晰度（分辨率）；
5，总结：养成新建word文件后，勾选 不压缩图片的好习惯！完美解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62272bfd011ce48e5801dee6c9e9611b/" rel="bookmark">
			redis报错：Creating Server TCP listening socket 127.0.0.1:6379: bind: No error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis启动时报错： Creating Server TCP listening socket 127.0.0.1:6379: bind: No error
这个错误说明已经开启了redis，并且已经占用了端口6379，需要停止redis后再开启。
redis-cli.exeshutdownexitredis-server redis.windows.conf
参考：https://blog.csdn.net/ItBJLan/article/details/105816463
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0712d9f0b56e1bcdf841825fcdfd42dd/" rel="bookmark">
			SpringBoot 上传下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt; &lt;/dependency&gt; 2. application.yml spring: servlet: multipart: max-request-size: 500MB max-file-size: 500MB 3. 创建接口类 import org.apache.commons.io.FileUtils; import org.springframework.http.ContentDisposition; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RequestPart; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.net.URL; import java.net.URLConnection; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; @RestController public class FileController { /** * 文件上传到服务器 */ @PostMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0712d9f0b56e1bcdf841825fcdfd42dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff15d5cad1c6bb4b2e630ccafac5be8d/" rel="bookmark">
			MySQL回表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL中，回表查询（也称为“回索引查询”或“书签查找”）是一个发生在使用二级索引（secondary index，即非主键索引）进行查询时的步骤。这个过程包括两个阶段：
二级索引扫描：
首先使用二级索引来查找与搜索条件相匹配的行。二级索引包含了指定的索引列和指向表数据行的指针（在InnoDB存储引擎中，这个指针通常是主键的值）。
数据回表：
在通过二级索引找到对应的行之后，数据库需要通过索引中包含的主键指针去聚簇索引（也称为主键索引，InnoDB的表数据实际上是按照主键顺序存储的）中检索完整的行数据。这个步骤就被称为回表查询，因为它涉及根据主键回到数据表中检索完整的数据行。
为什么会需要回表查询呢？当二级索引的列不足以满足查询要求（例如，查询要求返回不包含在二级索引中的列）时，就必须查找每个匹配行的完整数据。回表查询可能对性能产生负面影响，特别是在处理大量数据和需要频繁进行回表操作的场景中。
为减少回表查询的性能影响，可以采取以下策略：
投影查询：尽量只查询包含在二级索引中的列，这样可以避免回表。覆盖索引：设计二级索引覆盖所有查询需要的列，这样查询操作可以直接在二级索引上完成，不需要回表。查询优化：调整查询语句或逻辑以减少需要回表的次数。 虽然回表查询可能会影响性能，但二级索引的使用仍然是关系数据库中数据检索的一个强大工具，尤其是在处理正确索引的大型数据集时。通过优化索引设计和查询策略，可以最大限度地减少性能开销。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11fa7a8b2639f5aba92c08c2099198c/" rel="bookmark">
			MySQL最左匹配原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL中，最左匹配原则是指在使用复合索引（即包含多个列的索引）进行查询操作时，查询条件从索引的最左列开始匹配，并且必须是连续的。这个原则非常重要，因为它影响到查询时索引的使用效率。
复合索引类似于电话簿的排序方式：首先按照姓氏排序，然后是名字，最后是电话号码。如果你要查找一个人的电话号码，首先你会按姓氏查找（最左侧），然后是名字。如果你不知道姓氏只知道名字，这样的查找效率会大大降低。
在MySQL中，考虑一个复合索引包括三列：(col1, col2, col3)。以下是几个使用这个复合索引有效（或无效）的例子，依据最左匹配原则：
有效的使用案例：
WHERE col1 = 'A'：使用了索引的最左列。WHERE col1 = 'A' AND col2 = 'B'：连续使用了索引的前两列。WHERE col1 = 'A' AND col2 = 'B' AND col3 = 'C'：连续使用了所有索引列。WHERE col1 = 'A' ORDER BY col2：即使第二个条件是排序而非过滤，也使用了前两列。 部分有效的使用案例：
WHERE col1 = 'A' AND col3 = 'C'：虽然使用了索引的第一列和最后一列，但由于跳过了中间的列，所以对 col3 的过滤不会利用到索引。 无效的使用案例：
WHERE col2 = 'B'：没有使用最左列 col1，因此复合索引不会被使用。WHERE col3 = 'C'：没有使用最左列 col1，也没有中间列 col2，索引不会被使用。WHERE col2 = 'B' AND col3 = 'C'：没有从最左列开始，因此索引不会被充分利用。 要充分利用复合索引的优势，查询应尽可能从索引的最左列开始，并沿着索引定义的顺序连续使用列。这样，MySQL查询优化器可以有效地定位和过滤数据，提高查询效率。如果查询中使用了索引的非连续列，数据库可能会采用索引跳转扫描（Index Skip Scan），效率较低，或者干脆不使用索引。
有些地方称为联合索引？ 联合索引和复合索引其实是同一个概念的不同说法，在MySQL中完全可以互换使用。它们都是指在数据库表的多个列上创建的一个索引，数据结构中的索引项是基于这些列的组合值构建的。
复合索引（又称联合索引）中包含了多个列，因此它们的性能和使用特点与单一列索引不同。如前所述，复合索引在查询中遵循最左前缀规则，即在进行查询时从复合索引的最左边的列开始使用索引进行检索和匹配。这种索引可以极大地提高通过这些列进行查询和排序操作的效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f11fa7a8b2639f5aba92c08c2099198c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d128ed7f63dfada99ff6b6e093d17026/" rel="bookmark">
			阿里的通义灵码在android studio上的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通义灵码是阿里推出的免费AI编程工具，基于通义大模型，国内Copilot平替产品，
1，提供行级/函数级实时续写、
2，自然语言生成代码、
3，单元测试生成、
4，代码注释生成、
5，代码解释、
6，研发智能问答、
7，异常报错排查等能力，
8，并针对阿里云 SDK/OpenAPI 的使用场景调优，助力开发者高效、流畅的编码。
安装方法，在android studio的插件中查询lingma，安装即可。
实际使用当中，代码提示和生成代码的功能实用性很强。以下是官方的使用指南。
通义灵码使用指南 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7216178a36a68f72a0aab7284a753e02/" rel="bookmark">
			Camx 添加pipeline实现流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和你一起终身学习，这里是程序员Android
经典好文推荐，通过阅读本文，您将收获以下知识点:
一.需求概述
二.简介
三.添加pipeline实现
一.需求概述 添加一条PipeLine实现两路Raw进，一路Raw出
二.简介 要添加的PipeLine：SWMFMergeRawTwo2One
包含1个memcpy node，
这个node用于将2个raw buffer input输入 变为 1个raw buffer output输出
三.添加pipeline实现 3.1 在相应的Usecase下添加一个pipeline xml vendor\qcom\proprietary\chi-cdk\oem\qcom\topology\usecase\components\usecases\UsecaseZSL\pipelines
目录下放置pipline文件：camxSWMFMergeRawTwo2One.xml
3.2 填充pipline xml文件 填充camxSWMFMergeRawTwo2One.xml
(1).SWMFMergeRawTwo2One //PipelineName 是唯一的
(2).在NodesList里链接所有需要链接的Node //List all nodes required by the pipeline in
3.3 修改NodesList： NodeId：
外部定制的Node使用 NodeId 255 (例如自己加的算法Node)
NodePropertyId：
1是定制的Lib
NodePropertyValue：
填入chi node lib name
关于 NodeProperty 的相关定义可以在 vendor\qcom\proprietary\chi-cdk\api\common\chi.h 中查到
3.4 修改PortLinkages PortLinkages：input target，chi/camx Node 和 output target 的链接链表
SourceBuffer：NodeId 4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7216178a36a68f72a0aab7284a753e02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42de00580230d659b548f54f88e6b48b/" rel="bookmark">
			Js的String的replace(和replaceAll(
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EcmaJavascriptJs的String的 replace( 和 replaceAll( 方法 String.prototype.replaceString.prototype.replaceAll 相同点
都是String.prototype的函数都是用于字符串替换都是两个参数第一个参数都可以是正则或字符串第二参数都可以是字符串或者回调函数, 回调会传入一个参数, 参数是本次匹配到的内容第二参数为字符串时,都可以用$&amp;指代匹配到的内容 不同点
参数1的不同 replace的参1为字符串时,只匹配第一个,只匹配一次; 参1为正则时, 可通过标识g匹配一个或全部 ;replaceAll的参1为字符串时,匹配全部; 为正则时, 必须带有全局标志g, 否则抛异常 replace可以替换一个或所有, replaceAll只能替换所有 给匹配到的内容加上括号的例子 比如给字符串"abcdaabcdefgabcaabcdefg"中符合/aa/规则的内容加括号
以下代码等效
"abcdaabcdefgabcaabcdefg".replace(/aa/g , "($&amp;)" ); "abcdaabcdefgabcaabcdefg".replaceAll(/aa/g , "($&amp;)" ); "abcdaabcdefgabcaabcdefg".replaceAll("aa" , "($&amp;)" ); 也可以使用函数方式
replace(/aa/g , matcher=&gt;"("+matcher+")"); replace(/aa/g , "($&amp;)" ); replace(/aa/g , function(matcher){return "("+matcher+")";}); replaceAll(/aa/g , matcher=&gt;"("+matcher+")"); replaceAll("aa" , matcher=&gt;"("+matcher+")"); replaceAll(/aa/g , "($&amp;)" ); replaceAll("aa" , "($&amp;)" ); replaceAll(/aa/g , function(matcher){return "("+matcher+")";}); replaceAll("aa" , function(matcher){return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42de00580230d659b548f54f88e6b48b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9630c9eaecbb4cf91551d687acc9478f/" rel="bookmark">
			【Windows日常】Win10,Win11家庭版如何开启远程桌面？——（2024最新）Mac笔记本如何远程控制Windows电脑？Windows 11远程控制的账号和密码是多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 工作中经常需要远程控制其它电脑，特别是在公司的网络中通过端口映射后进行直接的访问。市面上很多免费的远程控制方法，比如QQ的远程协助，向日葵远程控制，等等，这些软件都是垃圾，难用的要死 被卡死了之后就来考虑更快的解决方案了。目前的场景是，只需要在公司公网的局域网内使用的情况下，windows远程桌面无疑是最理想的选择了，而不用那些todesk这些垃圾软件还绕一圈他们服务器来了。但我最近的操作系统都是买电脑时赠送的Windows 10/Windows 11家庭中文版。可能是因为有安全隐患的原因，Home版没有开放远程桌面功能，让用习惯了Windows远程桌面功能的我不太习惯。百度后有很多家庭版开启远程桌面的教程，但是感觉不容易抓住要领，配置起来很费劲。特此写下本文以减少配置过程中的烦恼。特别是已经尝试了从家庭版升级专业版遇到的各种问题 输入密钥、kms啥的也行不通之后。
以下是我升级专业版时踩的坑，在此记录一下：
Windows家庭版如何升级成专业版？亲测可用！
win11专业版激活密钥（亲测有效）2个
win 10家庭版升专业版报错：0xC004F069在运行Microsoft Windows非核心版本的计算机上……_运行在非核心版本
试了以上所有的方法，都行不通。。。
实验环境：Windows 10 Home，Windows 11 Home
1. 下载安装开源的RDP Wrapper软件 1.1 下载 下载地址：https://github.com/stascorp/rdpwrap/releases
注意访问github可能需要梯子，大家自己想办法去下载。
截止到现在(2024/1/6)最新版是1.6.2，msi安装包是1.6.2新增的，但是建议选择第二个zip包。这个包里面有配置确认工具，用起来更方便。
Tips 下载时提示有危险不能保存的处理办法
现在网络浏览器为了避免用户下载网络上的可执行文件，都会做危险文件提醒的。
打开浏览器菜单&gt;下载内容&gt;“保留危险文件”，即可保留这个安装包文件。
1.2 安装 下载之后解压到自己设定的某个目录下。下图是解压完后的样子
用管理员权限打开install.bat进行安装。安装过程没有提示，会自动安装到C:\Program Files\RDP Wrapper目录下。此安装目录只有rdpwarp.dll和rdpwarp.ini两个文件。请注意一下rdpwarp.ini这个文件，待会需要用到以及可能修改。
2. 配置防火墙 由于远程桌面是通过3389 TCP端口进行访问的，Windows Home版是默认关闭了这个端口的，需要手工去放行这个端口，不然还是不能使用远程桌面访问。
2.1 打开Windows防火墙 以win11为例，打开设置，菜单&gt;隐私和安全，进入windows 安全中心，点击“防火墙和网络保护”，
按照我以下的内容进行设置，然后点开高级设置。
（如果上图中的“高级设置”是灰色的不能用，请关闭你的第三方杀毒软件。我的是Thinkpad, 可以按照如下方法关闭。）
2.2 配置允许使用远程桌面访问端口3389的防火墙放行规则 打开防火墙窗口后，添加新的入站规则。选择端口类型。
端口是TCP 3389。
选择运行连接类型防火墙。
局域网的域，专用可以都选上。为了安全，公用可以不选。
然后命名保存即可。保存后，在防火墙列表中应该可以看到刚才新建的防火墙规则。
3. 确认配置状况 运行本文1.2节里面的RDPConf.exe, 会弹出如下窗口。如果Diagnostics里面的状态都是绿色的，恭喜你配置完成，可以远程访问了。
===================== 问题 ===================== 安装后确认状态，大概率会出现红色状态。我也经历过下面这样的。
侦听器Listener状态不对，主要是防火墙配置得晚了些。要重启远程桌面服务。
当前的windows版本(本例为10.0.22000.318)不支持，就会出现[not supported]的状态。
windows版本不支持解决办法，需要下载支持这个版本的配置内容。
解决办法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9630c9eaecbb4cf91551d687acc9478f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a23e302a580742155c93e91de9782da/" rel="bookmark">
			什么是CHATGPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT是一个基于大型变换器模型（Transformer model）的对话AI，它通过机器学习的方法训练，能够生成人类般的文本。GPT（Generative Pre-trained Transformer）是由OpenAI开发的，其中“GPT”表示模型的类型，而“Chat”表明该模型特别针对生成对话内容进行了优化。
它的工作原理基于以下几个关键点：
预训练：GPT先在大量的文本数据上进行预训练，以理解语言的基本结构和规则。
微调：之后，它可能会被进一步微调，以适应特定的任务，比如继续在对话数据上训练以更好地执行对话任务。
生成文本：在预训练和微调后，GPT可以通过给定的提示或问题继续生成连贯的文本回复。
交互式对话：ChatGPT可以与用户进行交互式对话，理解用户的输入并给出响应，模拟真实的对话体验。
这种模型可以应用于各种不同的语言任务，包括但不限于聊天机器人、问答系统、文本摘要、文章创作等。由于其生成的文本通常是连贯且可信的，它在客户服务、虚拟助理和娱乐等领域变得非常有用。随着这个领域的技术不断进步，ChatGPT和类似的模型越来越能够提供高质量、上下文相关的文本生成，从而提升用户体验。
chatgpt 能干什么 ChatGPT是一个基于人工智能的对话系统，它可以执行多种任务，包括但不限于：
提供信息：用户可以询问定义、事实、解释和其他类型的信息，ChatGPT可以提供相应的答案。
教育辅导：ChatGPT可以帮助学习者理解复杂的概念，解答学术问题，比如数学问题、科学理论等。
技术支持：它可以辅助解决技术问题，提供故障排除建议，或指导用户完成某些技术操作。
语言翻译：ChatGPT能够理解和生成多种语言，从而协助用户翻译文本。
创造内容：用户可以利用它来生成文章、故事、诗歌、歌词等创造性文本。
娱乐对话：ChatGPT能与用户进行轻松的闲聊，讲笑话，甚至进行一些简单的角色扮演游戏。
情感支持：虽然它不能取代专业的心理健康服务，但ChatGPT可以提供一定程度的情感支持和劝导。
辅助编程：对于编程问题，ChatGPT可以提供代码示例和编程概念的解释。
协助决策：它可以帮助列举决策的利弊，虽然最终的决策应由用户自行做出。
生活助手：ChatGPT可以帮助规划日程、提供旅行建议和制定备忘清单等。
这些仅是ChatGPT能力的一部分。由于ChatGPT基于机器学习，它在许多情况下都能适应和提供有用的回答或建议，但用户应注意其生成的信息并不总是完全可靠，应当结合其他信息来源和个人判断。此外，ChatGPT的应用也应遵循道德和法律的标准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/492b591b6486a036f0659a33cffd37c8/" rel="bookmark">
			福利来袭，.NET Core开发5大案例，30w字PDF文档大放送！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		千里之行，始于足下，若想提高软件编程能力，最最重要的是实践，所谓纸上得来终觉浅，绝知此事要躬行。根据相关【艾宾浩斯遗忘曲线】研究表明，如果不动手实践，记住的东西会很快忘记。
为了便于大家查找，特将之前开发的.Net Core相关的五大案例整理成文，共计440页，32w字，免费提供给大家，文章底部有PDF下载链接。
ASP.NET Core学生信息管理系统 ASP.NET Core开发学生信息管理系统（一）
ASP.NET Core开发学生信息管理系统（二）
ASP.NET Core开发学生信息管理系统（三）
VUE3.0+Antdv+WebApi学生信息管理系统 Antdv+Asp.net WebApi开发学生信息管理系统（一）
Antdv+Asp.net WebApi开发学生信息管理系统（二）
Antdv+Asp.net WebApi开发学生信息管理系统（三）
Antdv+Asp.net WebApi开发学生信息管理系统（四）
VUE3.0+Antdv+Asp.net WebApi开发学生信息管理系统（完）
ASP.NET Core+Element校园图书管理系统 ASP.NET Core+Element+SQL Server开发校园图书管理系统（一）
ASP.NET Core+Element+SQL Server开发校园图书管理系统（二）
ASP.NET Core+Element+SQL Server开发校园图书管理系统（三）
ASP.NET Core+Element+SQL Server开发校园图书管理系统（四）
ASP.NET Core+Element+SQL Server开发校园图书管理系统（完）
WPF+Prism+MAH+WebApi学生信息管理系统 WPF开发学生信息管理系统【WPF+Prism+MAH+WebApi】（一）
WPF开发学生信息管理系统【WPF+Prism+MAH+WebApi】（二）
WPF开发学生信息管理系统【WPF+Prism+MAH+WebApi】（三）
WPF开发学生信息管理系统【WPF+Prism+MAH+WebApi】（四）
WPF开发学生信息管理系统【WPF+Prism+MAH+WebApi】（完）
ASP.NET Core MVC商城系统 ASP.NET Core MVC开发实战之商城系统(开篇)
ASP.NET Core MVC开发实战之商城系统(一)
ASP.NET Core MVC开发实战之商城系统(二)
ASP.NET Core MVC开发实战之商城系统(三)
ASP.NET Core MVC开发实战之商城系统(四)
ASP.NET Core MVC开发实战之商城系统(五)
ASP.NET Core MVC开发实战之商城系统(六)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/492b591b6486a036f0659a33cffd37c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b26de0472bd862f26d87b044a8903986/" rel="bookmark">
			如何自己实现一个分布式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现分布式事务是一个复杂的过程，它需要精心设计并考虑数据的一致性、系统的可用性和分区容错能力。分布式事务确保在分布式系统中，即使是跨多个数据库、服务或消息队列，事务要么完全成功，要么完全失败。
以下是实现分布式事务的一些常见方法和步骤：
1. 两阶段提交（2PC, Two-Phase Commit） 两阶段提交是实现分布式事务的经典算法，它包括两个阶段：
准备阶段：事务协调器询问所有参与者是否准备好提交事务。如果所有参与者都响应说准备好了，就进入第二阶段。提交/回滚阶段：如果所有参与者都准备好提交，协调器发送一个提交请求给所有参与者。如果任何一个参与者无法准备好，协调器发送一个回滚请求。 2. 三阶段提交（3PC, Three-Phase Commit） 三阶段提交是对两阶段提交的改进，增加了一个额外的阶段来减少阻塞和提高容错性。它包括以下阶段：
询问阶段：协调器询问参与者是否可以提交事务，并且等待响应。准备阶段：如果所有参与者同意，协调器指示所有参与者准备提交。提交/回滚阶段：根据参与者的准备情况，协调器决定是否提交或回滚。 3. 补偿事务（Sagas） 在Sagas模式中，分布式事务被分解为一系列本地事务，每个本地事务都有对应的补偿（回滚）操作。如果某个本地事务失败，之前已经完成的事务会通过执行补偿操作来回滚。
4. 分布式事务框架 使用现成的分布式事务框架，如Seata、Atomikos或者JTA（Java Transaction API）。这些框架提供了API和工具，以简化分布式事务的实现。
实现步骤 以下是自己实现分布式事务的一般步骤：
定义事务边界：确定事务的开始和结束，以及哪些操作包含在事务中。
资源管理器：实现或使用资源管理器来管理不同系统（如数据库、消息队列等）的资源。
事务协调器：实现或使用事务协调器来管理事务的各个阶段和状态。
参与者协调：确保所有参与分布式事务的服务都遵循协调器的指令。
日志记录：记录事务日志，用于故障恢复。
超时和故障处理：实现超时策略和故障恢复机制，以应对部分失败的情况。
测试：测试分布式事务的所有路径，包括成功、失败和部分失败的场景。
实现分布式事务要求深入理解分布式系统的理论和实践，以及对具体应用场景的深刻洞察。在实施之前，评估是否真的需要分布式事务，因为它会增加系统的复杂性，并可能影响性能。在一些情况下，可以通过设计来避免对分布式事务的需求，例如通过使用幂等操作、最终一致性模型或者其他事务模式。
在Spring中实现自定义的分布式事务通常涉及多个资源管理器（通常是不同的数据库或消息队列）的协调。Spring提供了一些工具和抽象来帮助实现这一点，尤其是当标准的@Transactional注解不足以处理复杂的事务场景时。
以下是一个通过Spring平台事务管理器（PlatformTransactionManager）来自定义分布式事务管理的例子。这个例子使用编程式事务管理，而不是声明式事务管理，因为它提供了更细粒度的控制。
import org.springframework.transaction.PlatformTransactionManager; import org.springframework.transaction.TransactionDefinition; import org.springframework.transaction.TransactionStatus; import org.springframework.transaction.support.DefaultTransactionDefinition; @Service public class CustomDistributedTransactionService { @Autowired private PlatformTransactionManager transactionManager1; @Autowired private PlatformTransactionManager transactionManager2; public void executeDistributedOperations() { // 定义事务属性 TransactionDefinition definition = new DefaultTransactionDefinition(); // 开始第一个资源的事务 TransactionStatus status1 = transactionManager1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b26de0472bd862f26d87b044a8903986/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769f3986182b25b40ab47b838c246032/" rel="bookmark">
			Clickhouse 为什么快
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ClickHouse是一个用于联机分析处理（OLAP）的开源列式数据库管理系统（DBMS）。它之所以能提供出色的查询性能和处理速度，主要归功于以下几个方面的设计和优化：
列式存储
ClickHouse存储数据按列而不是按行组织。这种存储方式对于分析查询非常有效，因为它可以快速读取用于计算的特定列，而不必加载整个行的数据，这对于处理大量数据和复杂查询时尤其有益。
数据压缩
ClickHouse对列数据进行高效的压缩。由于列中的数据通常类型相同或者相似，因此可以更有效地压缩。压缩减少了磁盘空间的需求，同时也提升了读取速度，因为从磁盘读取的数据量减少了。
向量化查询执行
ClickHouse执行查询时，会采用向量化的方法，这意味着在处理数据时，每次操作可以处理数据列的一部分而不是单个值。这种处理方式使得CPU能够更有效地利用现代处理器的SIMD（单指令多数据）指令集。
优化的数据结构
ClickHouse为各种查询场景设计了高效的索引和数据结构（如MergeTree引擎），这些数据结构支持快速的数据插入和查询，特别是对于时间序列数据的聚合和查询。
并行处理
ClickHouse能够将查询分解成多个部分并行执行，充分利用多核CPU的能力。此外，它还可以在多个服务器节点上分布式地执行查询，进一步提高处理速度。
高度定制化的系统设置
ClickHouse提供了大量的配置选项，以便管理员可以根据具体的硬件和场景调整DBMS的行为，使之最优化。
预先计算的视图和物化视图
ClickHouse支持创建物化视图，这些视图可以在数据插入时自动更新，因此可以快速返回预先计算的结果。
数据分区和分片
在ClickHouse集群中，数据可以根据某个键自动分区和分片，这样可以在查询时只访问包含所需数据的分区和分片，减少不必要的数据扫描。
实时性能
ClickHouse设计为实时分析系统，可以保证在连续插入的同时还能提供高性能查询。
这些特性共同作用，使得ClickHouse成为处理大规模数据分析的强有力工具。然而，实际性能也取决于具体的硬件配置、数据模型设计以及查询的复杂性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eacb7cccc05242b1c0aebc2c3e1cc0ea/" rel="bookmark">
			FPGA设计时序约束十五、Set_Bus_Skew
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、序言
二、Set Bus Skew
2.1 基本概念
2.2 设置界面
2.3 命令语法
2.4 报告分析
三、工程示例
3.1 工程代码
3.2 时序报告
四、参考资料
一、序言 在时序约束中，对时钟的约束除了set clock latency,set clock uncertainty,set input jitter外，还有一条set bus skew的约束命令。该命令主要用于跨时钟域的场景中，下面将对set bus skew的使用进行详细的介绍。
二、Set Bus Skew 2.1 基本概念 Set Bus Skew用于在多个跨时钟域路径中设置一个最大的偏斜要求，可以限制用于发送数据的源时钟沿的数目以及被目的时钟沿捕获。和普通路径上的时钟偏斜不同，bus skew对应的是约束下所有路径中最大的捕获时钟偏斜值，该值同时应用到fast corner和slow corner。
Bus skew约束通常用于以下几种跨时钟域的拓扑结构中：
a) 格雷码总线切换中，例如异步FIFOs
b)带有CE，MUX或MUX hold的多比特跨时钟域电路中
c) 配置寄存器的跨时钟域
尽管set_bus_skew命令可以设置一个总线偏斜约束到同步跨时钟域中，但这种做法是多余的，因为setup和hold检查已经可以确保在两个时序安全的同步跨时钟域路径间安全切换。
总线偏斜约束不属于时序例外，和set_data_check一样，它属于时序断言。因此，总线偏斜约束不会被时序例外约束，如set_clock_group,set_false_path,set_max_delay,set_multicycle_path约束影响，仅可能会被route_design优化掉。
约束设置时建议将总线偏斜约束到没有扇出fanout的路径上，并且，每个总线偏斜约束必须覆盖最少两个起点和两个终点。
2.2 设置界面 进入Timing Constraints界面，在左侧Assertions栏中选中Set Bus Skew，右侧即显示Set Bus Skew
设置界面中Specify bus skew设置总线信号上最快的信号和最慢的信号间的偏斜，start points和end points分别设置起点和终点，Through points设置中间路径，也可不设。同时，也可指定只分析rise、fall或都分析
约束from/to的对象，只能为Cells或cell pins或clocks
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eacb7cccc05242b1c0aebc2c3e1cc0ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a63b9d15467f9a4c74fc5b183f89f13/" rel="bookmark">
			es索引数据过滤查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.我们往kibana插入数据,来进行查询 POST /t1/_doc/ { "name":"cat", "age":"18", "address":"BJ", "job":"dev" } POST /t1/_doc/ { "name":"dog", "age":"19", "address":"SD", "job":"ops" } POST /t1/_doc/ { "name":"alice", "age":"20", "address":"BJ", "job":"dev" } POST /t1/_doc/ { "name":"tigger", "age":"20", "address":"AH", "job":"ops" } POST /t1/_doc/ { "name":"fix", "age":"21", "address":"HN", "job":"dev" } POST /t1/_doc/ { "name":"jack", "age":"18", "address":"BJ", "job":"dev" } POST /t1/_doc/ { "name":"Tom", "age":"21", "address":"HN", "job":"ops" } 2.查询 #term查询，是根据具体的字段进行查询 #查询所有 GET t1/_search #查询name为cat的 GET t1/_search { "query": { "term": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a63b9d15467f9a4c74fc5b183f89f13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbc5f0dc3bedea167085c2f23c8186c/" rel="bookmark">
			NtCurrentTeb()-＞ReservedForOle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个结构体有很多成员，我在这里慢慢记录
啥时候碰到就来这里更新一下
typedef struct _ReservedForOle { UNKNOWN; CSmAllocator* csmAllocator; // 0x4 指针，占用4bytes } ReservedForOle; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45a1e665768d89a95bf58d347d538ca2/" rel="bookmark">
			Python正则表达式急速入门~正则居然这么容易掌握！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式在程序开发中会经常用到，比如数据（格式）验证、替换字符内容以及提取字符串内容等等情况都会用到，但是目前许多开发人员对于正则表达式只是处于了解或者是基本会用的阶段。一旦遇到大批量使用正则表达式的情况（例如网络爬虫）可以说基本上就抓瞎了。这篇文章我将带领大家利用 Python 来学习一下正则表达式。在阅读这篇文章前你需要掌握 Python 基础知识，或者具有其他开发语言的基础知识也可以，因为基本上每种语言使用正则表达式的方式都是类似的。
零、正则表达式基础
1.提取字符（串） 有时我们需要从一个字符串中获取一段内容，这段内容可能是一个字符也可能是一段字符串，如果用逐字对比遍历的话不仅耗时耗力而且还容易出错。那么这个时候我们就可以用到正则表达式中的 字符匹配 功能。正则表达式为我们提供了 4 种字符匹配的方法，见下表：
语法说明例子可匹配字符串.匹配除了换行符 “\n” 以外的任意字符a.bacb、adb、a2b、a~b\转义，将转移字符后面的一个字符改变原来的意思a[b \ . \ \ ]cabc、a.c、a\c[]匹配括号内的任意字符a[b,c,d,e]fabd、acf、adf、aef[^]除了括号内的字符外，其他的字符都匹配a a,b,c,d,e fa1f、a#f、azf、agf
2.预定义字符 所谓预定义字符就是正则表达式中为我们预留的专门用来匹配格式化内容的字符，例如匹配数字用的 \d 和匹配空白符的 \s 等等。我们可以利用预定义字符快速的匹配出一个字符串中符合要求的内容。预定义字符匹配的内容，同样也可以利用前面所讲的字符匹配的方式匹配出来，但是代码量会相对来说多一点。下表所列的就是预定义字符：
语法说明例子可匹配字符串^以什么字符串开始^123123abc、123321、123zxc$以什么字符串结尾123$abc123、321123、zxc123\b匹配单词边界，不匹配任何字符\basd\basd\d匹配数字0-9zx\dczx1c、zx2c、zx5c\D匹配非数字zx\Dczxvc、zx$c、zx&amp;c\s匹配空白符zx\sczx c\S匹配非空白符zx\Sczxac、zx1c、zxtc\w匹配字母、数字和下划线zx\wczxdc、zx1c、zx_c\W匹配非字母、数字和下划线zx\Wczx c、zx$c、zx(c
在预定义字符中有如下几点需要注意：
\b 匹配的只是一个位置，这个位置的一侧是构成单词的字符，另一侧为非单词字符、字符串的开始或结束位置。\b 是零宽度。\w 在不同编码语言中匹配的范围是不一样的，在使用 ASCII 码的语言中匹配的是 [a-zA-Z0-9 ] ，而在使用 Unicode 码的语言中匹配的是 [a-zA-Z0-9 ] 和汉字、全角符号等特殊字符。 3.限制数量 在某些情况下我们需要匹配重复的内容，这时我们可以使用 数量限定 模式来进行操作。数量限定如下表：
语法说明例子可匹配字符串*匹配0到多次zxc*zx、zxccccc+匹配1次到多次zxc+zxc、zxccccc?匹配0次或1次zxc?zxc、zx{m}匹配m次zxc{3}vbzxcccvb{m,}匹配m次或多次zxc{3,}vbzxcccvb、zxccccccccvb{,n}匹配0次到n次zxc{,3}vbzxvb、zxcvb、zxccvb、zxcccvb{m,n}匹配m次到n次zxc{1,3}zxcvb、zxccvb、zxcccvb
4. 断言 断言，又称零宽断言，指的是当断言表达式为 True 时才进行匹配，但是并不匹配断言表达式内容。和 ^ 代表开头， $ 代表结尾， \b 代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为零宽。所谓位置，是指字符串中第一个字符的左边、最后一个字符的右边以及相邻字符的中间。零宽断言表达式有四种：
零宽度负回顾后发断言 (?&lt;!exp)，表达式不成立时匹配断言后面的位置，成立时不匹配。例如 \w+(?&lt;zxc)\d，匹配不以 zxc 结尾的字符串；零宽度负回顾先行断言 (?!exp)，表达式匹配断言前面的位置，成立时则不匹配。例如：\d(?!zxc)\w+，匹配不以 zxc 开头的字符串；先行断言 (?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45a1e665768d89a95bf58d347d538ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d2e06b4f09fd962b80f862472cb921/" rel="bookmark">
			控制障碍函数(Control Barrier Function,CBF) 二、示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、示例 2.1、系统模型 这里我们举一个CBF作者给出的经典示例
我们定义控制输入 u u u 为蓝色车的推力。 p p p 为蓝色车的位置， v v v 为蓝色车的速度， z z z 为蓝色车与黄色车之间的距离， v 0 v_0 v0​ 为黄色车的速度。我们定义系统的状态为
x = [ p v z ] ∈ R 3 x = \begin{bmatrix} p \\ v \\ z \end{bmatrix} \in \mathbb{R}^3 x= ​pvz​ ​∈R3
对其求导为
x ˙ = [ v − 1 m F r ( v ) v 0 − v ] + [ 0 1 m 0 ] u \dot x = \begin{bmatrix} v \\ -\frac{1}{m} F_r(v) \\ v_0 - v \end{bmatrix} + \begin{bmatrix} 0 \\ \frac{1}{m} \\ 0 \end{bmatrix} u x˙= ​v−m1​Fr​(v)v0​−v​ ​+ ​0m1​0​ ​u
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0d2e06b4f09fd962b80f862472cb921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba7b8574f3883cbec6a09ef73d6878b0/" rel="bookmark">
			ps -ef | grep 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ps 命令的作用是显示进程信息的；
| 符号，是个管道符号，表示ps 和 grep 命令同时执行；
grep 命令是查找（Global Regular Expression
Print），能使用正则表达式搜索文本，然后把匹配的行显示出来；
ps命令有一些参数：
-e : 显示所有进程
-f : 全格式
-h : 不显示标题
-l : 长格式
-w : 宽输出
a ：显示终端上的所有进程，包括其他用户的进程。
r ：只显示正在运行的进程。
u ：以用户为主的格式来显示程序状况。
x ：显示所有程序，不以终端机来区分。
示例：
[root@izbp163wlhi02tcaxyuxb7z wang]# ps -f | grep rabbitmq_server-3.6.1/ root 8684 6682 0 16:41 pts/3 00:00:00 grep --color=auto rabbitmq_server-3.6.1/ 结果信息从前到后依次是：
UID PID PPID C STIME TTY TIME CMD zzw 14124 13991 0 00:38 pts/0 00:00:00 grep –color=auto dae 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e3cad86fdfb2f5a0e41a31d8525b3c9/" rel="bookmark">
			matlab数值计算函数--ode45
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当难以求得微分方程的解析解时，可以求其数值解，Matlab中求微分方程数值解的函数有七个：ode45，ode23，ode113，ode15s，ode23s，ode23t，ode23tb。本文讲解ode45，其实原理都是相似的。
一、函数语法 ode45函数的形式张下面的样子
[T,Y] = ode45(odefun,tspan,y0,options) odefun: 函数句柄，用于表示ODE的右侧，例如：dy/dt=f(t,y)，可以写为f。函数句柄可以是函数，也可以是匿名函数或者内联函数tspan: 时间区间，可以是一个向量，也可是一个区间（如[t0,tf]）。y0: 初始条件，可以是一个向量。options: 可选参数，常用于控制ODE45的行为，如精度、步长等。 二、示例 我们举一个自由落体的例子来讲解ode45这个函数
{ x ˙ = v v ˙ = g \begin{cases} \dot x = v \\ \dot v = g \\ \end{cases} {x˙=vv˙=g​
其中 x x x 为位置， v v v 为速度， g g g 为重力加速度，设置初始值均为 0
clc;clear; % 初始状态 state0 = [0,0]; % 时间区间 t = [0,10]; % 运算，得到T为时间点，Y为对应时间点的状态 [T,Y] = ode45(@odefunc, t, state0); % 绘图 figure(1) plot(T,Y(:,1)); xlabel('t(s)'); ylabel('x') figure(2) plot(T,Y(:,2)); xlabel('t(s)'); ylabel('v') % 写微分方程 function dy = odefunc(t, y) g = 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e3cad86fdfb2f5a0e41a31d8525b3c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df9423b50cddf5b68f0410d21f85197/" rel="bookmark">
			Git合并代码问题：Committer identity unknown *** Please tell me who you are
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 由于很久没操作git分支上的代码，最近在idea中做分支合并的时候遇到了如下问题：Committer identity unknown *** Please tell me who you are. Run git config --global user.email "you@example.com" git config --global user.name "Your Name" to set your account's default identity. Omit --global to set the identity only in this repository. unable to auto-detect email address (got 'EDY@WIN-EERRLLM4V43.(none)')
翻译大概意思：提交人身份未知***请告诉我你是谁。运行git-config--global user.email“you@example.com“git-config--global user.name”Your name“用于设置帐户的默认标识。Omit--global仅在此存储库中设置标识。
解决方案 在报错中其实已经说明了解决方案，在执行git操作时，没有设置用户名和邮箱地址导致的，因此解决方案就是设置git提交的账号和邮箱。
直接打开idea的Terminal输入如下两个命令，直接回车即可。
第一个是绑定自己的邮箱。建议使用一个真实存在的邮箱地址。这样，当你提交代码、接收合并请求或进行其他与代码协作相关的操作时，你就能及时收到相关的邮件通知。
第二个就是你提交git的时候的名称，名称随意。
git config --global user.email "你的邮箱地址" git config --global user.name "你的用户名" 如果你只想在当前仓库设置用户信息，可以删掉 --global 参数即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cd972ef6ed81b441b4de87b4b14560/" rel="bookmark">
			数据表示和进制转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入计算机的数字、字符、符号等信息必须转换成0、1组合的数据形式才能被计算机接收、存储并进行运算。能够进行算术运算并且得到明确的数值的数据概念的信息叫数值数据，其余的信息成为非数值数据。
权：每位数的数值。
基数：指该进位制中允许选用的数码的个数。
数值数据的表示 数值数据的计数方式是进位制，方式按进位的方式计数的数制都叫进位制。用有限的数码表示，例如二进制、八进制、十进制、十六进制。
二进制 基数为2的进制叫二进制，只有0和1两种数码，逢二进一，英文缩写BIN（前缀是0b）。
数据的最小单位：bit位
数据的基本单位：byte字节
1 Byte = 8 bit
1 KB = 1024 Byte
1 MB = 1024 KB
1 GB = 1024 MB
1 TB = 1024 GB
1 PB = 1024 TB
二进制转换成十进制 0b 1010 = 1*2^3 + 0*2^2 + 1*2^1 + 0*2^0 = 8 + 2 = 10
0b 1111 = 1*2^3 + 1*2^2 + 1*2^1 + 1*2^0 = 8 + 4 + 2 + 1 = 15
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3cd972ef6ed81b441b4de87b4b14560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0eb67adf9eb52c465e8896b0e23e718/" rel="bookmark">
			【占用网络】VoxFormer 基于视觉的3D语义场景方案 CVPR 2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文分享“占用网络”方案中，来自CVPR2023的VoxFormer，它基于视觉实现3D语义场景补全。
使用Deformable Attention从图像数据中，预测三维空间中的体素占用情况和类别信息。
VoxFromer是一个两阶段的框架：
第一个阶段：预测每个像素的深度值，将像素投影三维空间中，2D图像到3D空间的思想。然后预测每个三维网格是否被占用，生成稀疏体素特征。最后选择其中是“占用”的体素，作为“体素查询特征”进入第二阶段。这个阶段只预测占用情况，选择一些值得分析的体素。第二个阶段：根据一阶段提议的体素特征，生成体素Query，使用交叉注意力从3D体素Query到2D图像中查询融合特征的思想；然后使用掩码标记与自注意力，预测那些“没占用”的网格，补全得到完整的体素特征。后面接3D语义场景任务头，预测每个三维网格的类别情况。 论文地址：VoxFormer: Sparse Voxel Transformer for Camera-based 3D Semantic Scene Completion
代码地址：https://github.com/NVlabs/VoxFormer 一、框架思路 VoxFromer仅通过2D图像，不依赖点云数据，能预测完整的3D几何形状和语义信息。
它输入图像数据，默认是多视角图像数据，比如6个相机的。也可以只输入单张图像数据，单目相机场景。
第一阶段：通过预测图像中每个像素点的深度信息，结合相机内外参，投影到三维空间中。然后预测每个三维网格是否被占用，并选择状态是“占用”的体素，得到提议的3D体素Query。这样模型会选择一些值得分析的体素，进入下一阶段。第二阶段-1：得到的提议的3D体素Query，使用交叉注意力，3D体素Query到2D图像中查询融合特征，生成进一步的3D体素Query'。（这里体素特征Query'，表示图像中可见区域生成的，是有占用的；而不是被遮挡或空的空间）第二阶段-2：然后使用自注意力，类似MAE的掩码预测，生成完整的体素特征。（基于提议的有占用体素特征，预测其它空间的情况，得到完整的体素特征） 最后输出3D语义场景信息，包含体素占用情况和类别信息。
Voxel Queries: 表示体素查询。其中，体素是三维空间中的一个立方体单元，可以想象为三维像素。
体素查询与注意力机制相结合，使模型能够专注于输入数据中的重要部分，然后进行提取特征。
VoxFromer的详细的思路流程，如下图所示：
阶段一：
对图像中的每个像素，预测其深度值。结合相机内外参，投影到三维空间中，形成稀疏的3D点。初始化一个体素查询矩阵Q，结合稀疏的3D点，对每个体素进行二元分类。当网格被占用时，预测为1；当网格没有被占用时，预测为0。图像中可见区域生成的，是有占用的；而不是被遮挡或空的空间。设定数量Np，选择Np个最有可能是占用状态的网格特征，组成体素查询Qp。这里选择其中是“占用”的体素，作为“体素查询特征”进入第二阶段。这个阶段只预测占用情况，选择一些值得分析的体素。 阶段二：
使用可变形交叉注意力，根据体素查询Qp，融合对应的图像特征。3D体素Query到2D图像中查询融合特征。然后使用自注意力，类似MAE的掩码预测，生成完整的体素特征。基于提议的有占用体素特征，预测其它空间的情况，得到完整的体素特征。 Mask Tokens 掩码标记与体素查询一起使用，以帮助模型预测那些在点云数据中缺失但对于理解整体场景很重要的体素。
每个掩码标记都是一个可学习的向量，代表一个缺失体素的存在，而位置嵌入（positional embeddings）则确保掩码标记能够了解它们在3D空间中的位置。
二、核心内容——第一阶段（预测深度值、预测网格是否被占用） 第一个阶段主要包括：预测深度值、预测网格是否被占用。
一阶段详细步骤：
深度估计：从给定的二维图像中，使用深度估计模型来预测每个像素点的深度。结果是一个深度图，其中每个像素的值代表从相机到场景中相应点的距离。
体素化：利用这些深度信息，结合相机内外参，投影到三维空间的体素网格。每个体素是三维空间中的一个立方体区域，类似于二维图像中的像素点。
占用决策（深度修正）：对于每个体素，根据其内部是否有从深度图中推导出的点来决定其占用状态。如果一个体素在其对应的深度图区域内有深度信息（即至少有一个像素点的深度信息指向该体素的空间区域），则该体素被标记为“占用”（通常用1表示）。如果没有深度信息指向该体素，它被标记为“空闲”（通常用0表示）。
二值化占用图：通过这种方式，可以生成一个二值化的占用图，这是一个三维网格，其中每个体素的值指示该区域是否被占用。
查询提案：接下来，系统会选择这些“占用”的体素进行进一步的处理，如特征提取或语义分割，在本文中是输入到第二阶段。在Class-Agnostic Query Proposal阶段，模型不区分体素类别，而是根据它们是否包含足够的信息（即是否占用）来选择哪些体素值得进一步分析。
有了每个像素的深度值后，可以利用相机的内外参，来将图像反投影至3D点云空间：
通过这种方法生成的3D点云在远距离区域特别是地平线附近的质量非常低，原因在于这些区域的深度极不一致。
此外，只有极少数像素决定了大片区域的深度，导致这些区域的点云相对稀疏。
为什么要做深度校正，也就是外什么还有用一个模型来预测每个网格是否占用？
深度修正背景：
在场景的远处，如地平线区域，因为在这些区域，相机捕捉到的深度信息往往因为距离过远而不准确或者分辨率不足。这种情况下，直接从图像像素得到的深度数据是不可靠的，需要进行校正。地平线区域进行深度估计的问题通常是因为在这些远距离处，深度信息变得非常稀疏和不连续。在普通的二维图像中，地平线附近的物体通常比较小，因此在点云数据中，它们可能只对应非常少的点，甚至可能没有点。 解决方案：是使用一个模型来预测占用图，这是一个在较低空间分辨率下的二进制体素网格。每个体素表示一小块三维空间。
如果至少有一个点在该体素的空间范围内，则该体素在占用图中被标记为1，表示该区域被占用；如果没有点，则标记为0，表示未被占用。
这种占用信息有助于对深度信息进行修正，因为它提供了场景中哪些区域是空的，哪些是有物体的更明确的信息。
深度修正的思路流程：
使用深度估计模型从图像获取初步的深度信息。将这个初步深度信息转换成一个低分辨率的体素网格，即占用图。通过检查哪些体素被占用（至少有一个点），哪些没有被占用（没有点），来校正深度信息。这样可以修正因为分辨率不足或其他原因造成的误差。 详细步骤：
生成初步深度图：首先，利用深度估计模型（比如基于单目或立体视觉的深度估计网络）从二维图像中生成一个初步的深度图。这个深度图在远处尤其是地平线区域可能会存在较大的误差。
构建占用图：随后，将初步深度图转换为一个三维体素网格。这个过程中，每个体素根据是否存在对应的深度点被标记为占用（1）或未占用（0）。由于地平线区域的深度信息可能不连续，所以此时的体素网格是低分辨率的，也就是说，每个体素覆盖的空间较大，可以包含较多的潜在深度信息。
低分辨率修正：在低分辨率的占用图中，可以辨别出哪些区域是连续被占用的，哪些区域是空的。由于每个体素较大，即使远处的深度点非常稀疏，也更可能被检测到占用。然后，可以对那些在初步深度图中看起来是空的但在占用图中被标记为占用的区域进行深度修正。
插值和平滑：在确认了哪些大体素内的空间确实存在物体后，可以在这些区域应用插值或平滑技术来估计更准确的深度值。例如，如果一个大体素被标记为占用，而其内部的小体素深度值不连续，可以通过插值周围小体素的深度值来估计这些小体素的深度，使深度信息在大体素内部更加连续。
高分辨率细化：最后，使用这个经过低分辨率修正的占用图作为一个指导，可以在更高分辨率的深度图上进行细化，进一步提高深度估计的准确性。这可以通过在高分辨率深度图上应用从占用图中得到的占用信息来完成，进而优化整个场景的深度估计。
三、核心内容——第二阶段（交叉注意力、自注意力、生成完整的体素特征） 在第一阶段，系统已经生成了体素查询提案特征，表示这些体素值得进一步分析。
第二阶段是关于如何利用这些体素查询提案来提取丰富的图像特征，并对它们进行分割，区分不同类别的物体。
第二阶段-1：得到的提议的3D体素Query，使用交叉注意力，3D体素Query到2D图像中查询融合特征，生成进一步的3D体素Query'。（这里体素特征Query'，表示图像中可见区域生成的，是有占用的；而不是被遮挡或空的空间）第二阶段-2：然后使用自注意力，类似MAE的掩码预测，生成完整的体素特征。（基于提议的有占用体素特征，预测其它空间的情况，得到完整的体素特征） 首先使用ResNet以及FPN提取多尺度图像特征。使用可变形交叉注意力，根据体素查询Qp，融合对应的图像特征。3D体素Query到2D图像中查询融合特征。
然后使用自注意力，类似MAE的掩码预测，生成完整的体素特征。基于提议的有占用体素特征，预测其它空间的情况，得到完整的体素特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0eb67adf9eb52c465e8896b0e23e718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/017497dacd90592cd56b3148a3a6accd/" rel="bookmark">
			K8s系列---【安装nfs文件系统（为k8s提供动态创建pv的能力）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8s系列—【安装nfs文件系统（为k8s提供动态创建pv的能力）】
安装nfs文件系统（为k8s提供动态创建pv的能力）
1.1 安装nfs-server
# 在每个机器执行下面这条命令(包含master)。 yum install -y nfs-utils 下面的/nfs/data目录可以自定义，这个是用来供node节点往master节点同步pv数据用的目录
# 在master 执行以下命令，直接粘贴执行，或者粘贴到shell脚本中执行 echo "/nfs/data/ *(insecure,rw,sync,no_root_squash)" &gt; /etc/exports # 在master执行以下命令，启动 nfs 服务;创建共享目录 mkdir -p /nfs/data # 在master执行 systemctl enable rpcbind systemctl enable nfs-server systemctl start rpcbind systemctl start nfs-server # 使配置生效 exportfs -r #检查配置是否生效 exportfs 验证：执行完命令之后，出现/nfs/data ,则说明执行成功。
1.2 配置nfs-client（选做）
主要用来把node节点的/nfs/data的数据同步到master节点，下面命令直接复制所有并在所有node节点执行。
#在所有node节点执行，下面的ip改成你自己的master的ip，注意：这里也可以自己挂自己，即一台机器上两个目录间共享。 showmount -e 192.168.110.181 mkdir -p /nfs/data #在所有node节点执行，下面的ip改成你自己的master的ip,注意：如果自己挂自己，最后一个"/nfs/data"换成本机上的另一个目录，上一步创建的和第一个服务端目录不能一样，因为一台机器上不可能创建两个一模一样的文件夹。 mount -t nfs 192.168.110.181:/nfs/data /nfs/data 1.3 配置动态创建pv默认存储
把下面的两处ip更换成自己的nfs的server服务的ip，这里我已把master作为nfs的server服务，所以更换成master的ip即可。
在nfs服务器上创建sc.yml文件：vi sc.yaml
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/017497dacd90592cd56b3148a3a6accd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826fc789f3843cfc229cf396ab149c7c/" rel="bookmark">
			航天航空线束工艺3D虚拟展馆支持多人异地参观漫游
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了满足汽车线束企业员工工作需要，让新老员工了解到更先进、规范的线束工艺设计技术，华锐视点基于VR虚拟仿真、web3d开发和图形图像技术制作了一款汽车线束工艺设计VR虚拟仿真模拟展示系统。
汽车线束工艺设计VR虚拟仿真模拟展示系统共分为pc电脑端和VR端，电脑端提供虚拟设计和模拟试验环节，VR端则能将制作好的线束图360度多角度呈现，此外在VR端的汽车线束工艺展示大厅中，还提供汽车线束工艺设计知识讲解，学员能结合理论知识和实践操作掌握先进的线束工艺设计技能。
相比传统线束工艺设计制作需要大量物料和空间，有了汽车线束工艺设计VR虚拟仿真模拟展示系统，员工打开电脑就能进入线束工艺设计编辑器上传现实中需要用/构想中的设计图设置尺寸生成工装板，然后进行线束制作虚拟试验，成功后还可以同步传输到VR汽车线束工艺展示大厅，让其他人也能参观学习，或者给出指导意见，优化设计方案，减少物料损耗及不安全因素。
汽车线束工艺设计VR虚拟仿真模拟展示系统摆脱了传统手把手教学，新上岗员工可以先熟悉线束工艺设计流程、工序及注意事项，尝试不同汽车线束设计图纸，丰富线束工艺设计经验，提高上岗作业正确率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec21e7bba9515f5b4dab524178b6dda/" rel="bookmark">
			qiankun 公共依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、提取公共依赖的目的 减少相同资源的重复加载 资源版本不同步 打包文件庞大 2、如何提取公共依赖 基本思路： 1、相同依赖 采用 CDN 的方式加载，并把 所有依赖的 CDN 链接 统一放到一个文件中进行管理
2、把存放 CDN 链接的文件，引入到 vue.config.js 中去
3、在项目打包时，添加忽略部分文件打包的配置，把以CDN方式加载的依赖忽略掉
4、把CDN加载的链接，动态添加到 index.html 中去
2.1 改造主应用 2.1.1 修改目录、添加配置文件及资源
在主应用的 public 下新建 global &gt; config 文件夹，用于存放 全部应用公共接口地址配置、微应用配置、公共依赖 CDN 地址 等内容
在 config 文件夹下 新建 api-config.js，用于存放全部应用公共接口地址配置
在 config 文件夹下 新建 config-micro-app.js，用于存放微应用配置
在 config 文件夹下 新建 config-webpack.js，用于存放公共依赖 CDN 地址
在主应用的 public 下新建 libs 文件夹，用于存放各种依赖包
2.1.2 config-webpack.js 中，导出公共依赖地址配置
微应用中的依赖，就是读取主应用中的 config-webpack.js 这个配置文件
把项目打包部署到服务器上，public 文件夹内容不会被打包改变；因此线上项目的 public/libs 文件夹中就是依赖，依赖包的在线地址就能拿到了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fec21e7bba9515f5b4dab524178b6dda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cffdc3925fc7daa772680cba1d13941/" rel="bookmark">
			EasyExcel导出带下拉选数据的Excel数据导入模板（以及下拉选数据量多不展示的问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#因为项目中需要导入一些信息，但是这些信息比较不常见，且在项目字典数据中维护有这些数据，所以在导出模板的时候，把这些数据一并导出，可以减少用户的编写，避免在导入的时候因为数据错误，发生一些业务问题
直接开始
一、首先引入依赖 easyexcel依赖 &lt;!--easyexcel依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.10&lt;/version&gt; &lt;/dependency&gt; 二、创建自定义注解 import java.lang.annotation.*; /** * 标注导出的列为下拉框类型，并为下拉框设置内容 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface ExcelSelected { /** * 固定下拉内容 */ String[] source() default {}; /** * 动态下拉内容 */ Class&lt;? extends ExcelDynamicSelect&gt;[] sourceClass() default {}; /** * 设置下拉框的起始行，默认为第二行 */ int firstRow() default 1; /** * 设置下拉框的结束行，默认为最后一行 */ int lastRow() default 0x10000; } 三、解析自定义注解接口 public interface ExcelDynamicSelect { /** * 获取动态生成的下拉框可选数据 * @return 动态生成的下拉框可选数据 */ String[] getSource(); } 四、创建一个实体类，（这边以我项目内的演示） import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cffdc3925fc7daa772680cba1d13941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a655c2dde102a50f34c84db4fa8a5b78/" rel="bookmark">
			微信小程序如何使用天地图的逆地理编码api
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文只介绍如何使用天地图api，如若要显示天地图，使用 web-view 天地图逆地理编码api 1、使用wx.request 发送请求 getLocation() { wx.getLocation({ type: 'gcj02', success: (res) =&gt; { // 调用天地图逆地理编码api this.initTianDiMap(res.longitude, res.latitude) }, fail: (err) =&gt; { console.log('err', err); } }) } initTianDiMap(longitude, latitude) { let that = this wx.request({ url: 'http://api.tianditu.gov.cn/geocoder', //逆地理编码接口地址 data: { postStr: JSON.stringify({'lon':longitude,'lat':latitude,'ver':1}), type: 'geocode', tk: '2826428fe95fecce4433373ebf0d9945' }, //逆地理编码接口参数 success: function (res) { console.log(143, res.data); }, fail: function (res) { console.log(res.errMsg); } }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af358504a66540ddf9b95fa409f72255/" rel="bookmark">
			微信小程序-----身份证校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在utils目录下创建idCardNumber.js文件
//身份证号严格校验 function identityIDCard(code) { //身份证号前两位代表区域 var city = { 11: "北京", 12: "天津", 13: "河北", 14: "山西", 15: "内蒙古", 21: "辽宁", 22: "吉林", 23: "黑龙江 ", 31: "上海", 32: "江苏", 33: "浙江", 34: "安徽", 35: "福建", 36: "江西", 37: "山东", 41: "河南", 42: "湖北 ", 43: "湖南", 44: "广东", 45: "广西", 46: "海南", 50: "重庆", 51: "四川", 52: "贵州", 53: "云南", 54: "西藏 ", 61: "陕西", 62: "甘肃", 63: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af358504a66540ddf9b95fa409f72255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d48c46298ee7ba2b22c9d327c248539/" rel="bookmark">
			vmware虚拟机安装esxi7.0步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装准备 1、下载镜像文件 下载链接：https://pan.baidu.com/s/12XmWBCI1zgbpN4lewqYw6g 提取码：mdtx
2、vmware新建一个虚拟机 2.1 选择自定义 2.2 选择ESXi对应版本 2.3 选择稍后安装操作系统
2.4 默认选择 2.5 自定义虚拟机名称及存储位置 2. 6 配置虚拟机处理器和内核数 2.7 配置虚拟机的内存 2.8 选择网络模式 2.9 设置硬盘（推荐即可） 2.10 磁盘类型（推荐） 2.11 创建新虚拟磁盘 2.12 设置磁盘大小 2.13 指定磁盘文件（推荐） 2.14 创建完成 2.15 配置启动文件，选择使用ISO映像文件，然后浏览选择准备好的镜像文件，记得勾选启动时连接
二、开始安装 开启虚拟机
开始加载
按enter继续
按 F11 接收并继续
选择要安装系统的磁盘（图片是虚拟机的虚拟磁盘，真机会显示物理机器的硬盘），按 Enter 继续
按 Enter 继续
设置 root 密码（之后管理该 ESXI 主机需要使用该密码）密码要求七位以上，包含数字、大小写字母、特殊符号，参考：Aa123321.
按 F11 安装
等待安装完成
安装结束（实体机拔下U盘）按下 Enter，等待系统重启
重启后会显示远程连接的ip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcf3b5854ba34f9235608397baecfcc3/" rel="bookmark">
			微信小程序根据生日获取年龄
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 根据出生日期计算年龄周岁 传参格式为1996-06-08
// 根据出生日期计算年龄周岁 传参格式为1996-06-08 function getAge(strBirthday) { var returnAge = ''; var mouthAge = ''; var strBirthdayArr = strBirthday.split("-"); var birthYear = strBirthdayArr[0]; var birthMonth = strBirthdayArr[1]; var birthDay = strBirthdayArr[2]; var d = new Date(); var nowYear = d.getFullYear(); var nowMonth = d.getMonth() + 1; var nowDay = d.getDate(); if (nowYear == birthYear) { // returnAge = 0; //同年 则为0岁 var monthDiff = nowMonth - birthMonth; //月之差 if (monthDiff &lt; 0) { } else { mouthAge = monthDiff + '个月'; } } else { var ageDiff = nowYear - birthYear; //年之差 if (ageDiff &gt; 0) { if (nowMonth == birthMonth) { var dayDiff = nowDay - birthDay; //日之差 if (dayDiff &lt; 0) { returnAge = ageDiff - 1 + '岁'; } else { returnAge = ageDiff + '岁'; } } else { var monthDiff = nowMonth - birthMonth; //月之差 if (monthDiff &lt; 0) { returnAge = ageDiff - 1 + '岁'; } else { mouthAge = monthDiff + '个月'; returnAge = ageDiff + '岁'; } } } else { returnAge = -1; //返回-1 表示出生日期输入错误 晚于今天 } } return returnAge + mouthAge; //返回周岁年龄+月份 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22ab5dfc06fa266b977608116e0d809/" rel="bookmark">
			Qt 中如何将图片转化为yuv420p
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 QImage 存储的图片，如果想转成yuv420p 发送出去，该怎么办呢？
QImage 存储图片有多种格式，可以通过image.format() 查看当前的格式；
建议通过将格式转换为mage.convertToFormat(QImage::Format_RGB888)，这样rgb的存储每个八字节，按照rgb rgb 的格式存储；image.bitPlaneCount() 可以查看一个像素点需要用的bit数；
默认是 QImage::Format_ARGB32_Premultiplied格式，此时一个像素用四个字节存储，按照argb argb的格式，不同的格式转换为yuv420p的时候，由于rgb的数据排列方式不同，需要采用不同的计算方式，因此建议转化为QImage::Format_RGB888；
这里给出计算方式：
#include &lt;QtGui/QImage&gt; #include &lt;QtCore/QByteArray&gt; /* origin_image QImage图片 width /height 图片的宽度/高度 yuvData yuv420p数据 */ void convertRGBToYUV420P1(const QImage&amp; origin_image, int width, int height, QByteArray&amp; yuvData) { QImage image ; // 将图片转换为指定大小 image = origin_image.scaled(width, height, Qt::IgnoreAspectRatio, Qt::SmoothTransformation); qDebug() &lt;&lt; "Format:" &lt;&lt; image.format(); image = image.convertToFormat(QImage::Format_RGB888); qDebug() &lt;&lt; "Format:" &lt;&lt; image.format(); // 提取RGB数据 QByteArray rgbData; const int bytesPerLine = image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a22ab5dfc06fa266b977608116e0d809/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b966d92085e1e2893a74afff031cafe3/" rel="bookmark">
			二进制安装包安装Prometheus插件安装（mysql_exporter）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 mysql_exporter是用来收集MysQL或者Mariadb数据库相关指标的，mysql_exporter需要连接到数据库并有相关权限。既可以用二进制安装部署，也可以通过容器形式部署，但为了数据收集的准确性，推荐二进制安装。
一，下载安装包并解压 **安装包下载地址：**https://github.com/prometheus/mysqld_exporter/releases
同样物理机上下载，然后上传到服务器，本次安装使用的版本为：mysqld_exporter-0.14.0.linux-amd64
1，根据服务器情况选择安装目录，上传安装包。 cd /prometheus #解压 tar -xvzf mysqld_exporter-0.14.0.linux-amd64.tar.gz mv mysqld_exporter-0.14.0.linux-amd64 mysqld_exporter cd mysqld_exporter 二，创建配置文件 创建配置文件.my.cnf ，填入如下内容后保存:wq [client] user = exporter password = &lt;your password&gt; host = 11x.xx.xx.7 port = &lt;your port&gt; vim .my.cnf cat .my.cnf mysql创建用户并授权，注意服务ip不要填错 CREATE USER 'exporter'@'&lt;安装Prometheus的主机IP&gt;' IDENTIFIED BY '&lt;your password&gt;'; GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'exporter'@'&lt;安装Prometheus的主机IP&gt;'; flush privileges; 三，进行系统service编写 创建mysqld_exporter.service配置文件 cd /usr/lib/systemd/system vim mysqld_exporter.service mysqld_exporter.service 文件填入如下内容后保存:wq [Unit] Description=https://prometheus.io [Service] Restart=on-failure ExecStart=/prometheus/mysqld_exporter/mysqld_exporter --config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b966d92085e1e2893a74afff031cafe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19cff8fc50bfbb21d9a7e15336afe319/" rel="bookmark">
			使用 Java 携手 SpringBoot &#43; PhantomJS &#43; ECharts 在服务端生成图表并存为图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、简介
2、PhantomJS 下载安装
3、PhantomJS 测试脚本
4、Echarts 环境配置
脚本使用
5、SpringBoot 调用 PhantomJS
5.1、在 pom.xml 引入 freemarker，用于解析 ftl 模板文件。
5.2、在 templates 目录下 创建 echarts 目录，并放入 EChartsLineOption.ftl 模板文件，可通过 ftl 模板调整参数完成自定义图片。示例为折线图，有需要别的图表类型自行更换 Option 内容即可。
5.3、创建 EchartsUtil 工具类，编写 generateEChartsBase64() 方法，用于生成 base64 编码图片。
5.4、创建 RESTUtil 工具类，用于发送 Http 请求。
5.5、创建 FreemarkerUtil 工具类，用于读取解析 ftl 模板文件。
5.6、创建 Base64Util 工具类，将生成的 bae64 转为 java.io.File 文件
5.7、编写 EChartsService 服务层业务代码，调用工具类生成图片。
1、简介 PhantomJS 是一个不需要浏览器的富客户端
官方介绍：PhantomJS是一个基于 WebKit 的服务器端JavaScript API。它全面支持web而不需浏览器支持，支持各种Web标准：DOM处理，CSS选择器, JSON，Canvas，和SVG。PhantomJS常用于页面自动化，网络监测，网页截屏，以及无界面测试等
通常我们使用PhantomJS作为爬虫工具。传统的爬虫只能单纯地爬取html的代码，对于js渲染的页面，就无法爬取，如Echarts统计图。而PhantomJS正可以解决此类问题。
我们可以这么理解 PhantomJS，PhantomJS是一个无界面、可运行脚本的谷歌浏览器。
2、PhantomJS 下载安装 PhantomJS安装非常简单，直接在官网 http://phantomjs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19cff8fc50bfbb21d9a7e15336afe319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2178756678b4c2590a52087d7d60d99/" rel="bookmark">
			redis重启后数据丢失问题解决（亲测好用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis修改密码重启后发现redis中的数据丢失了
解决办法：
首先在redis的安装目录下查找重启之前的dump.rdb文件，发现只有当天的一个dump.rdb文件，确认不是重启备份的文件
然后我就全盘找一下dump.rdb的备份文件，找到前一天的备份文件
然后将这个dump.rdb文件放到原安装目录下的，替换掉原来的dump.rdb文件，并将原来的备份
这时候连接redis发现数据仍然不全，然后我又重启redis
重启成功后发现dump.rdb文件又变小了，redis连接后数据仍然缺失；
最后我先把redis进程kill掉，然后将备份dump.rdb文件替换掉，然后再重新启动，启动后发现redis数据回来了，啊啊啊，真是个振奋人心的时刻！！！！！！
另外需要注意一下，最好能给redis设置重启备份！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3719a6bc8042b28e70b6bab0e4eb9c41/" rel="bookmark">
			支付宝沙箱支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.沙箱支付 1.1.什么是沙箱支付 支付宝沙箱支付（Alipay Sandbox Payment）是支付宝提供的一个模拟支付环境，用于开发和测试支付宝支付功能的开发者工具。在真实的支付宝环境中进行支付开发和测试可能涉及真实资金和真实用户账户，而沙箱环境则提供了一个安全、隔离的环境，使开发者能够模拟支付过程，测试支付功能，而不会使用真实资金。
使用支付宝沙箱支付环境，开发者可以模拟各种支付场景，包括交易创建、支付请求、支付回调等，以验证支付功能的正确性和稳定性。沙箱环境中的所有交易和数据都是虚拟的，不会产生真实的交易或资金流动。
支付宝沙箱支付提供了开发者工具和接口，使开发者能够在模拟环境下进行支付流程的调试和测试。开发者可以在沙箱环境中创建测试账户、配置模拟的交易金额和状态，使用沙箱环境中的接口进行支付操作，并模拟支付回调接口接收支付结果。
通过使用支付宝沙箱支付，开发者可以更安全、更有效地进行支付功能的开发和测试，避免了对真实环境的影响和风险。一旦支付功能在沙箱环境中验证通过，开发者可以将其部署到真实的支付宝生产环境中，与真实用户进行交互和支付。
1.2.配置沙箱支付 1.2.1.接入支付宝开放平台 登陆支付宝：支付宝开放平台
点击登录按钮之后，使用手机的支付宝进行二维码扫码登录，如下：
登录成功之后，点击控制台跳转到控制台主页面，将浏览器进度条滚动到最下面，选择沙箱，最后点击沙箱选项即可，如下：
1.2.2.下载 下载安装支付宝开放平台开发助手：小程序文档 - 支付宝文档中心
注意：请不要安装在含有空格的目录路径下，否则会导致公私钥乱码的问题
安装完成之后，点击“支付宝开放平台开发助手”开始生成密钥。
1.2.3.配置秘钥 打开支付宝开放平台开发助手，如下：
选择密钥方式，选择RSA2方式，最后点击生成密钥即可生成得到私钥和公钥。
1.2.4.生成支付宝公钥 根据支付宝开放平台开发助手生成的应用公钥，生成支付宝公钥：
找到支付宝开放平台的沙箱应用一栏，选择“开发信息”接口加签方式中的自定义密钥方式，点击设置并查看按钮：
生成支付宝公钥，如下：
1.2.5.配置沙箱账号（买家） 配置沙箱账号（买家）并完成手动充值：登录 - 支付宝
1.2.6.下载沙箱支付宝 下载沙箱支付宝（只支持安卓）：登录 - 支付宝
2.开发接入 2.1.配置依赖 &lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt; &lt;artifactId&gt;alipay-easysdk&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 2.2.配置AlipayConfig 开发文档：小程序文档 - 支付宝文档中心
将课件资料中的AlipayConfig.java导入到项目中，并修改主要配置：
第一步：修改沙箱支付配置参数：
private Config aliconfig(){ Config config=new Config(); //沙箱支付宝地址 config.gatewayHost="openapi-sandbox.dl.alipaydev.com"; //协议https config.protocol="https"; //应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号 config.appId="请填写您的AppId，例如：2019091767145019"; //支付宝公钥 config.alipayPublicKey="请填写支付宝公钥"; //签名方式 config.signType="RSA2"; //商户私钥（应用私钥），您的PKCS8格式RSA2私钥 config.merchantPrivateKey="请填写商户私钥（应用私钥），您的PKCS8格式RSA2私钥"; return config; } 注意：这里沙箱支付宝地址有巨坑，由于支付宝沙箱已经全面升级了，导致接口文档与实际的案例接口不匹配，从而影响了以前的老接口的使用，只需要调整接口地址接口，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3719a6bc8042b28e70b6bab0e4eb9c41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6ed75ba85e1929235acb5062d7e0254/" rel="bookmark">
			Docker·1（简介、安装、基本使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 什么是Docker1.1. 什么是容器1.2. 什么是Docker 2. 安装Docker3. 镜像操作3.1. 拉取镜像3.2. 卸载镜像/容器3.3. 使用镜像/容器 4. 相关指令说明 1. 什么是Docker 1.1. 什么是容器 虚拟机： 操作系统是一个很笨重的程序，即是啥都不干，虚拟本身都要占用很多内存和磁盘，并且启动很慢（操作系统要从头到尾把该检测的都检测了，该加载的都加载上）。
容器： 类似于码头的集装箱——相互隔离、长期反复使用、快速装载和卸载、规格标准，在港口和船上都可以摆放。
虚拟机&amp;Docker的隔离：
隔离： 虚拟机：现代软件开发的一大目的就是隔离，通过将应用程序部署在不同的虚拟机中从而实现隔离容器：只隔离应用程序的运行时环境（程序运行依赖的各种库以及配置）但容器之间可以共享同一个操作系统 容器的优势：轻量级且占用的资源更少，与操作系统动辄几G的内存占用相比，容器技术只需数M空间，因此我们可以在同样规格的硬件上大量部署容器，而且不同于操作系统数分钟的启动时间容器几乎瞬时启动 1.2. 什么是Docker Docker： Go语言开源项目，docker将程序以及程序所有的依赖都打包到docker container。Docker可以把程序所需要的环境装在容器里面，以做到一次容器配置，程序处处可运行。
组成（理解）：
dockerfile——源代码image——可执行的程序container——进程 关键指令：
docker build
docker编译docker file：client在接收到请求后转发给docker daemon，接着docker daemon根据docker file创建出“可执行程序”image docker run
docker daemon（守护进程，负责管理容器和镜像的生命周期，以及提供其他相关的管理和维护功能）将image加载到内存执行，跑起来的image就是container docker pull
docker daemon接收到命令后向docker registry（镜像库）发送image下载请求 Docker的关键组件：
容器技术：Docker使用容器技术来隔离应用程序及其依赖项。每个容器都包含了一个应用程序及其所有的依赖项，并且彼此相互隔离。这使得应用程序的部署、管理和扩展变得更加简单和高效。镜像：Docker使用镜像来定义容器的运行环境。镜像是一个轻量级的、可执行的独立软件包，包含了运行应用程序所需的所有文件和配置。Docker通过读取镜像来创建和运行容器。Docker守护进程：Docker守护进程是Docker引擎的核心组件，负责管理容器和镜像的生命周期。它接收来自Docker客户端的命令和请求，并在后台运行容器和执行相关的操作。Docker注册中心：Docker注册中心用于存储和共享镜像。它提供了一个中央化的存储和分发机制，使得镜像可以轻松地在不同的机器和环境之间传输和共享。Docker CLI（命令行接口）：Docker CLI是Docker的命令行工具，用于与Docker守护进程进行交互。通过Docker CLI，用户可以创建、运行、停止、删除容器和镜像等操作。Docker网络：Docker网络负责管理容器之间的网络通信以及容器与外部网络的连接。它提供了一种灵活的网络模型，使得容器可以轻松地相互通信并暴露给外部世界。Docker存储驱动：Docker使用存储驱动来管理容器的文件系统和卷。不同的存储驱动可以根据需求选择，以满足不同的性能和可靠性要求。 2. 安装Docker 本文全的案例与指令全是基于Centos7.6！！！
注意：Docker默认安装目录：/var/lib/docker
查看docker稳定版本，并选择安装：
# 在存储库中列出可用版本 yum list docker-ce --showduplicates | sort -r # 安装 yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6ed75ba85e1929235acb5062d7e0254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc8821e33d426ec56247474a223f355/" rel="bookmark">
			spring boot dispatcherServlet注册到tomcat及tomcat请求如何找到dispatcherServlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring boot dispatcherServlet如何注册到tomcat容器中，及request请求如何在tomcat的servlet容器找到dispatcherServlet
##spring boot 注册dispatcherServlet
javax.servlet.ServletContext.addServlet添加tomcat容器
##spring boot 注册dispatcherServlet
##request请求如何在tomcat的servlet容器找到dispatcherServlet
##
##添加 / 匹配的servlet默认的context.defaultWrapper请求处理
##处理请求
##查找匹配的servlet
##没有匹配到，使用默认的dispatcherServlet接收处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328fb56d9da3085e13c66e52ec062971/" rel="bookmark">
			Qt3D 纹理模块使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Qt3D 中，纹理相关的类用于定义和管理3D对象的纹理贴图，以及与纹理相关的属性和特性。
1. **Qt3DRender::QAbstractTexture**
- `QAbstractTexture` 类是纹理的抽象基类，用于表示2D、3D或立方体纹理。
- 使用 `QAbstractTexture` 可以创建一个纹理对象，并设置其属性，如尺寸、格式、过滤方式等。
- 通过设置不同的纹理图像，可以定义对象的外观和表面特性。
2. **Qt3DRender::QTexture2D**
- `QTexture2D` 类是 `QAbstractTexture` 的子类，用于表示2D纹理。
- 使用 `QTexture2D` 可以创建一个2D纹理对象，并设置其图像数据、像素格式、过滤方式等属性。
3. **Qt3DRender::QTextureImage**
- `QTextureImage` 类代表了纹理图像，它包含了纹理的图像数据和像素格式等信息。
- 使用 `QTextureImage` 可以创建一个纹理图像对象，并将其赋给纹理对象的 `images` 属性，以定义纹理的图像数据。
4. **Qt3DRender::QTextureWrapMode**
- `QTextureWrapMode` 类定义了纹理的环绕模式，用于控制纹理坐标超出范围时的行为。
- 通过设置纹理对象的 `wrapMode` 属性，可以定义纹理的环绕模式，包括重复、镜像重复、边缘填充等。
这些类，可以在 Qt3D 中定义和管理3D对象的纹理贴图，包括2D纹理、3D纹理、纹理图像等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84066ab4f1be5cbfea870589004e1dd1/" rel="bookmark">
			深信服技术认证“SCSA-S”划重点：XSS漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为帮助大家更加系统化地学习网络安全知识，以及更高效地通过深信服安全服务认证工程师考核，深信服特别推出“SCSA-S认证备考秘笈”共十期内容，“考试重点”内容框架，帮助大家快速get重点知识~
划重点来啦
*点击图片放大展示
深信服安全服务认证工程师（SCSA-S），定位于普适性的安全服务技术，适合在校生、应届毕业生或具备0-3年工作经验的网络安全工程师。该认证包含网络安全法律法规、操作系统基础、计算机网络基础、渗透测试基础、漏洞扫描、信息收集、WEB漏洞挖掘、安全事件处置等课程内容，侧重考核网络安全服务相关知识，评估网络安全实战型人才。
学习并获得SCSA-S认证后，可以具备识别网络威胁和安全事件、收集、整理、管理威胁信息、漏洞扫描与验证，漏洞分类分级、针对WEB系统进行脆弱性测试和渗透性测试等能力。
深信服技术认证SCSA-S样证
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5810a265edf0f3ab7eb68e5e2573497/" rel="bookmark">
			揭秘 docker 容器内 DNS 解析原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 这几天在使用 docker 中，碰到了在容器中 DNS 解析的一些问题。故花些时间弄清了原理，写此文章分享。
1. docker run 命令启动的容器 以启动一个 busybox 容器为例：
root@ubuntu20:~# docker run -itd --name u1 busybox 63b59ca8aeac18a09b63aaf4a14dc80895d6de293017d01786cac98cccda62ae root@ubuntu20:~# docker exec -it u1 sh / # / # ping www.baidu.com PING www.baidu.com (14.119.104.189): 56 data bytes 64 bytes from 14.119.104.189: seq=0 ttl=127 time=34.976 ms 64 bytes from 14.119.104.189: seq=1 ttl=127 time=35.369 ms ^C --- www.baidu.com ping statistics --- 2 packets transmitted, 2 packets received, 0% packet loss round-trip min/avg/max = 34.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5810a265edf0f3ab7eb68e5e2573497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6aab7ac48e9d8899a489fcfb2cf825a/" rel="bookmark">
			微信小程序多选标签的实现（单选或者多选）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		暑假留在社团跟别人一起开发一个校园小程序，如今也基本快开发完成了，整理一下日后可能用到的小组件。
类似于上图，下方的待选项为一个组件，根据父组件传入传入的参数决定是否为多选。
父组件的HTML代码如下
&lt;view class="my-tag"&gt; &lt;view class="tag-des" &gt; &lt;text&gt;个人标签&lt;/text&gt; &lt;text class="tips-text" wx:if="{{ !alreadyselect }}"&gt;可多选&lt;/text&gt; &lt;view wx:else="{{ alreadyselect }}" class="selected-my-tag"&gt; &lt;block wx:for="{{ SelectMyTag }}" wx:key="index" &gt; &lt;view&gt;{{ item.type }}&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;Tag bindonClickSelectTypeMulit='SelectMyTags' tags="{{ MyTagsList }}"/&gt; &lt;view style='height:30rpx;'&gt;&lt;/view&gt; &lt;/view&gt; 接下来是CSS样式。
.my-tag{ width: 682rpx; border-radius: 38rpx; background: #fff; box-shadow: 0px 1px 3px rgba(0, 0, 0, 0.16); margin-top: 68rpx; margin-left: 34rpx; } .tag-des{ padding-top: 34rpx ; margin-left: 34rpx; margin-right: 41rpx; font-weight: bold; font-size: 28rpx; border-bottom: 3rpx solid rgb(230, 230, 230); display: flex; align-items: center; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6aab7ac48e9d8899a489fcfb2cf825a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80a8fa3805a1fd83d4937ad21f3190bc/" rel="bookmark">
			jdbc---Java---mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、注册驱动
法一： DriverManager.registerDriver(new Driver());//过度依赖包；会注册两次 法二：
Class.forName("com.mysql.jdbc.Driver");//动态加载类，只有执行的时候才会看引号中内容 2、获取链接
法一：（3个参数） Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb_21","root","root"); 法二：（2个参数）
Properties info = new Properties(); info.setProperty("user","root");//key-value info.setProperty("password","root"); Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb_21", info); 法三：（1个参数）
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb_21?user=root&amp;password=root"); 3、获取执行sql语句的对象
查询----executeQuery ResultSet rs = stat.executeQuery("select * from user"); 增加、删除、修改-----executeUpdate
int i = stat.executeUpdate("insert into user values(3,90,'bj')");//有几行被影响 int i = stat.executeUpdate("update user set age = 99 where age = 90"); int i = stat.executeUpdate("delete from user where age = 99"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80a8fa3805a1fd83d4937ad21f3190bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c9b2d76c33b5b14b3b732a6cffabbc/" rel="bookmark">
			CentOs搭建Kafka集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7搭建Kafka集群 一、集群规划二、环境准备三、安装kafka集群1、下载kafka安装包2、解压3、配置环境变量4、编辑配置文件①修改broker.id②配置kafka运行日志路径③配置Zookeeper集群地址 5、启动集群6、测试kafka①、创建topic②、查看当前服务器中的所有topic③、生产者与消费者 一、集群规划 192.168.239.140192.168.239.141192.168.239.142zookeeperzookeeperzookeeperkafkakafkakafka 二、环境准备 请自行安装JDK与Zookeeper集群
Zookeeper集群安装参考
三、安装kafka集群 1、下载kafka安装包 通过此地址下载kafka
kafka_2.13-3.6.1.tgz 2、解压 tar -zxvf kafka_2.13-3.6.1.tgz 3、配置环境变量 vim /etc/profile.d/my_env.sh 在“my_env.sh”文件中添加如下内容：
#KAFKA_HOME（路径按需修改） export KAFKA_HOME=/wz_program/kafka/kafka_2.13-3.6.1 export PATH=$PATH:$KAFKA_HOME/bin 文件编辑完后执行如下命令：
source /etc/profile 4、编辑配置文件 进入“config”目录下，修改server.properties文件
vim server.properties ①修改broker.id 特别注意：broker.id在整个集群中全局唯一，不能重复，只能是数字
broker.id ②配置kafka运行日志路径 kafka运行日志(数据)存放的路径，路径不需要手动创建，kafka会自动创建。可以配置多个磁盘路径，路径与路径之间可以用","分隔。
log.dirs ③配置Zookeeper集群地址 zookeeper.connect= 5、启动集群 启动kafka集群前需要保证zookeeper集群已启动！！！
进入kafka的bin目录下执行如下命令：
./kafka-server-start.sh -daemon ../config/server.properties 关闭集群可使用如下命令：
./kafka-server-stop.sh 特别注意：停止Kafka集群时，一定要等Kafka所有节点进程全部停止后再停止Zookeeper集群。因为Zookeeper集群当中记录着Kafka集群相关信息，Zookeeper集群一旦先停止，Kafka集群就没有办法再获取停止进程的信息，只能手动杀死Kafka进程了。
6、测试kafka ①、创建topic kafka-topics.sh --bootstrap-server hadoop001:9092 --create --partitions 1 --replication-factor 3 --topic test_first ②、查看当前服务器中的所有topic kafka-topics.sh --bootstrap-server hadoop001:9092 --list ③、生产者与消费者 生产者：
kafka-console-producer.sh --bootstrap-server hadoop001:9092 --topic test_first 消费者：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c9b2d76c33b5b14b3b732a6cffabbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e22eb37e643661add1f9955dbb7928/" rel="bookmark">
			Java实现登录验证码的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给项目换了一个登录页面，而这个登录页面设计了验证码，于是想着把这个验证码功能实现一下。
这篇文章就如何实现登录时的验证码的验证功能结合代码进行详细地介绍，以及介绍功能实现的思路，文章不是一次写成的，中间考虑可能出现的问题，最后给出了一个比较稳定的版本。
目录
一、页面效果
二、实现思路
三、具体代码实现
1、准备工作
创建项目
添加依赖
修改配置
2、功能实现
后端代码
CaptchaController.java
UserLoginDTO.java
UserController.java
UserService.java
UserServiceImpl.java
前端代码
login.html
login.js
一、页面效果 登录的时候会把用户名、密码和验证码一起传到后端，并对验证码进行验证，只有验证码正确才能登录。
二、实现思路 那么，具体是如何实现的呢，首先大概介绍一下我实现这个功能的思路：
验证码图片的url由后端的一个Controller生成，前端请求这个Controller接口的时候根据当前时间生成一个uuid，并把这个uuid在前端使用localStorage缓存起来，下一次还是从缓存中获取。Controller生成验证码之后，把前端传过来的uuid通过redis缓存起来，这里分两次缓存 缓存uuid以uuid为key，缓存验证码这样，当点击登录按钮将数据提交到后台登录接口时，会从redis中获取uuid，然后通过这个uuid去获取验证码，和前端用户输入的验证码进行比较。 潜在问题：这样的设计可能会导致以下问题
多个用户同一时间访问登录页面，导致生成的uuid一样，数据会互相覆盖；uuid这个key被其他用户修改； 改进方案
前端生成随机的uuid，并缓存到localStorage，登陆的时候也把这个uuid传到后端，这样就解决了key重复和key被覆盖的问题。 三、具体代码实现 1、准备工作 创建项目 为了保存代码，在idea中新建一个springboot项目
创建好的项目目录结构
添加依赖 删除多余的文件及文件夹（可选），在pom.xml中添加必要的依赖~
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.9&lt;/version&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;groupId&gt;cn.edu.sgu.www&lt;/groupId&gt; &lt;artifactId&gt;login-captcha&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;login-captcha&lt;/name&gt; &lt;description&gt;Java实现登录验证码功能&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--validation--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36e22eb37e643661add1f9955dbb7928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83647d5d0d235f4db2995e96eb90c927/" rel="bookmark">
			逻辑控制使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 概述2. 顺序结构3. 分支结构3.1 if 语句3.2 switch 语句 4. 循环结构4.1 while 循环4.2 for 循环4.3 do while 循环 5. break和continue的区别5.1 break5.2 continue 6. 输入输出6.1 输出到控制台4.2 从键盘输入 1. 概述 逻辑控制有三种结构：顺序、选择、循环结构。
2. 顺序结构 顺序结构比较简单，按照代码书写的顺序一行一行执行。
System.out.println("aaa"); System.out.println("bbb"); System.out.println("ccc"); // 运行结果 aaa bbb ccc 如果调整代码的书写顺序, 则执行顺序也发生变化
System.out.println("aaa"); System.out.println("ccc"); System.out.println("bbb"); // 运行结果 aaa ccc bbb 3. 分支结构 3.1 if 语句 注意：if的参数一定是布尔表达式！！
1. 语法格式1
if(布尔表达式){ // 语句 } 如果布尔表达式结果为true，执行if中的语句，否则不执行。
2. 语法格式2
if(布尔表达式){ // 语句1 }else{ // 语句2 } 如果布尔表达式结果为true，则执行if中语句，否则执行else中语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83647d5d0d235f4db2995e96eb90c927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5854e2fda22ec9e8d7c143d66d0ae04/" rel="bookmark">
			2024年防止内卷和被潜规则，RocketMQ消息中间件实战派上下册上线啦｜架构随笔录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023已经过去啦，作为技术小伙伴一定要做好2024年的规划，只有这样才能够避免内卷和潜规则。
2024年即将是一个重新开始的一年，但是你要说互联网不倦，那是不可能的，就连某大厂都开始走下坡路啦，里面卷的是不要不要的，更何况是其它互联网公司呢？
2024年1月，我的新书RocketMQ消息中间件实战派上下册上线啦！，这本是既我的Spring Cloud Alibaba微服务架构实战派上下册巨无霸书籍上架两年之后的，又一本绝对的巨无霸技术类型的书籍。
作为技术人，要想不被别人卷，你得先自己卷自己，也就是你要将自己的Level提高，这样你就会从当前这个比较卷的层次跳出来，你上去之后，人家就卷不到你啦。
当然我不是说升职之后，就不卷啦，而是卷的对象也不一样了，这样你的体验会好一点。假如你一直停留在一线开发层次，那么你卷的对象总是那些工作5年左右的年轻人，那么作为一个大龄程序员，你有这么多的精力去和他们内卷吗？
可能你的能力很强，经验也很丰富，但是耐不过岁月不饶人，你就那么多精力啦，一方面被家庭内耗了一大半，再被同龄人打压了一部分，那么就剩下那么一点耐力和精力啦，怎么能卷的过那些无牵无挂的年轻人了。
总之，我还是那句话，一定要提升自己的Level，并努力的提高自己内卷对象的水平，而不是扎堆去内卷，那样技术人会很惨的。
本书花费了我大概一年半左右的时间，全书总共八百多页，总共有14章。
第1章 初识RocketMQ 第2章 实现通信渠道 第3章 消息路由的无状态存储和管理 第4章 生产消息和消费消息 第5章 存储消息 第6章 治理消息 第7章 实现分布式事务 第8章 实现消息的可靠性 第9章 保证消息的稳定性 第10章 消息的高并发 第11章 消息的高可用 第12章 消息的高性能 第13章 RocketMQ在分布式架构中的应用 第14章 分析RocketMQ5.x的新特性 本书总共包括如下十大特色，供技术小伙吧去参考。
【特色一】由浅到深 本书将RocketMQ的技术原理和最佳实践体系化，按照由浅到深的顺序呈现给读者，使读者可以按照章节顺序按部就班地学习。当学习完全书内容之后，读者不仅能熟悉RocketMQ的核心原理，还能充分理解RocketMQ的“根”。
【特色二】技术新 本书不仅包括RocketMQ4.x（4.9.2版本）的核心原理分析和最佳实践，还包括RocketMQ5.x（5.1. 0版本）的新特性分析和最佳实践。
【特色三】精心设计的主线：零基础入门，循序渐进，直至彻底掌握RocketMQ 本书精心研究了程序类、架构类知识的认知规律，全书共分为6篇：①基础；②进阶；③高级；④高并发、高可用和高性能；⑤应用；⑥新特性，是一条相对科学的主线，让读者快速从“菜鸟”向“RocketMQ分布式架构实战高手”迈进。
【特色四】绘制了大量的图，便于读者理解RocketMQ的原理、架构、流程 一图胜于文，书中在涉及原理、架构、流程的地方配有插图，以便读者更加直观地理解。
【特色五】从架构师和技术专家的视角分析RocketMQ 本书创造性地分析了RocketMQ具备高并发、高可用和高性能的功能及原理，并从架构的视角展开分析，这些也是程序员进阶为技术专家或架构师必备的技能。
以下为从架构师和技术专家的视角分析RocketMQ典型案例，读者阅读完本书之后，也能够达到这样的水准。
【特色六】不仅有原理分析，还有大量的实战案例 本书介绍了大量的实战案例，能让读者“动起来”，在实践中体会功能，而不只是一种概念上的理解。
在讲解每一个知识模块时，我在思考：在这个知识模块中，哪些是读者必须实现的“标准动作”（实例）；哪些“标准动作”是可以先完成的，以求读者能快速有一个感知；哪些“标准动作”具有一定难度， 需要放到后面完成。读者在实践完书中的案例之后，就能更容易理解那些抽象的概念和原理了。
本书的目标之一是，让读者在动手中学习，而不是“看书时好像全明白了，一动手却发现什么都不会”。通过体系化的理论和实战案例去培养读者的主动学习能力，这样本书的价值就会被最大化。 本书相信“知行合一”的理念，而不是“只知，而不行”，避免开发人员出现眼高手低的现象。尤其是在技术面试过程中，面试官更加看重的是既懂原理，又能够主动是实践技术的技术人。
【特色七】深入剖析原理 本书以系统思维的方式，从业务功能视角剖析 RocketMQ 底层的技术原理，使读者具备快速阅读 RocketMQ 框架源码的能力。读者只有具备了这种能力，才能举一反三，实现更复杂的功能，应对更复杂的应用场景。
【特色八】从运维的视角分析 RocketMQ 的最佳实践 本书除了分析大量的原理和实战案例，还从运维的视角分析 RocketMQ 的最佳实践（消息的可追踪性和稳定性），让开发人员也能从中受益。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5854e2fda22ec9e8d7c143d66d0ae04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1697822969dc734519b93d07586b6660/" rel="bookmark">
			xshell配色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xshell-设置命令行提示符&amp;配色方案 更换配色： Protect Eyes.xcs
[Protect Eyes] text=00ff40 cyan(bold)=93a1a1 text(bold)=839496 magenta=dd3682 green=80ff80 green(bold)=859900 background=042028 cyan=2aa198 red(bold)=cb4b16 yellow=b58900 magenta(bold)=6c71c4 yellow(bold)=657b83 red=dc322f white=eee8d5 blue(bold)=ae81ff white(bold)=fdf6e3 black=002b36 blue=268bd2 black(bold)=073642 [Names] name0=Protect Eyes count=1 设置命令行提示符 1. 实际遇到问题 $提示符后，没有空格，导致输入命令 和 $间，太紧密，不好看
通过 修改 PS1
修改后 ： $ 后 加了一个空格
效果：source 应用后 ，$ 后多了一个空格
2. 其他参数 参考 在命令行提示符显示用户名，当前机器IP，当前时间，当前路径等信息。但有时候如果我们的目录很长，敲击命令很不方便，可以通过修改 PS1 环境变量，让命令提示符在第二行显示：
如下示例，后面的 \n 就是起到了提示符 $ 在第二行显示效果。
export PS1="\[\033[01;31m\]\u\[\033[00m\]@\[\033[01;32m\]\h\[\033[00m\][\[\033[01;33m\]\t\[\033[00m\]]:\[\033[01;34m\]\w\[\033[00m\]\n$ " 效果如下：
注： 设置为什么颜色，可以自己根据显示效果调，很灵活。 建议 如果要写入shell配置文件，建议写到环境变量文件/.bash_profile，而不要写入/.bashrc，否则借助ssh类的工具都将因为trap DEBUG信号的特殊性而无限等待，比如scp/rsync等。
或者，直接判断是否是交互式登录，是的话就设置，否则不设置：
if [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1697822969dc734519b93d07586b6660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9eac1fec5d7cb31758f98a2e860da6d/" rel="bookmark">
			[转]YOLOv8-Cls推理详解及部署实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、YOLOv8-Cls推理(Python) 1. YOLOv8-Cls预测2. YOLOv8-Cls预处理3. YOLOv8-Cls推理二、YOLOv8-Cls推理(C++) 1. ONNX导出2. YOLOv8-Cls预处理3. YOLOv8-Cls推理三、YOLOv8-Cls部署 1. 源码下载2. 环境配置 2.1 配置CMakeLists.txt2.2 配置Makefile3. ONNX导出4. 源码修改结语下载链接参考 前言 梳理下 YOLOv8-Cls 的预处理流程，顺便让 tensorRT_Pro 支持 YOLOv8-Cls
参考：https://github.com/shouxieai/tensorRT_Pro
实现：https://github.com/Melody-Zhou/tensorRT_Pro-YOLOv8
一、YOLOv8-Cls推理(Python) 1. YOLOv8-Cls预测 我们先尝试利用官方预训练权重来推理一张图片，看能否成功
在 YOLOv8 主目录下新建 predict-cls.py 预测文件，其内容如下：
import cv2 from ultralytics import YOLO if __name__ == "__main__": model = YOLO("yolov8s-cls.pt") img = cv2.imread("ultralytics/assets/bus.jpg") result = model(img)[0] names = result.names top1_label = result.probs.top1 top5_label = result.probs.top5 top1_conf = result.probs.top1conf top5_conf = result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9eac1fec5d7cb31758f98a2e860da6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e51ddd1447acaa568087c1dd815ce2/" rel="bookmark">
			深入了解Python中的进程控制和监控技巧，提高系统稳定性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 在计算机系统中，进程管理是一个重要的任务，它涉及创建、启动、监控、终止和管理运行中的进程。Python作为一门强大的编程语言，提供了丰富的库和模块，使得进程管理变得相对容易。本文将介绍如何使用Python来实现系统进程管理，包括创建和管理进程、与进程通信以及监控进程的状态。
创建进程 要创建新的进程，Python提供了多种方式。最常用的是使用subprocess模块来启动外部命令或应用程序，以及使用multiprocessing模块来创建并行进程。
使用 subprocess 启动外部命令 subprocess模块允许在Python中启动外部命令或应用程序。
下面是一个简单的示例，演示如何使用subprocess来运行一个外部命令：
import subprocess # 启动外部命令并等待它完成 result = subprocess.run(["ls", "-l"], stdout=subprocess.PIPE, text=True) # 打印命令的输出 print(result.stdout) 在上述示例中，使用subprocess.run函数来运行ls -l命令，并通过stdout=subprocess.PIPE参数来捕获命令的输出。然后，打印了命令的输出。
使用 multiprocessing 创建并行进程 multiprocessing模块允许在Python中创建并行进程，以充分利用多核处理器。
下面是一个简单的示例，演示如何使用multiprocessing来创建并行进程：
import multiprocessing def worker_function(): print("Worker process") if __name__ == "__main__": # 创建并启动一个进程 worker_process = multiprocessing.Process(target=worker_function) worker_process.start() # 等待进程完成 worker_process.join() print("Main process") 在上述示例中，定义了一个名为worker_function的函数，然后在主程序中创建了一个新的进程并启动它。最后，等待进程完成，并打印出主进程的消息。
进程间通信 在多进程应用程序中，进程之间通常需要进行通信以交换数据或协调操作。Python提供了多种方式来实现进程间通信，包括使用multiprocessing模块的队列、管道和共享内存等机制。
使用队列进行进程间通信 队列是一种常见的进程间通信机制，它允许一个进程将数据放入队列，而另一个进程则可以从队列中取出数据。
下面是一个使用multiprocessing模块的队列进行进程间通信的示例：
import multiprocessing def producer(queue): for i in range(5): queue.put(i) print(f"Produced {i}") def consumer(queue): while True: item = queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28e51ddd1447acaa568087c1dd815ce2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/884519bbc8b5f08cb6dac0406089e4fa/" rel="bookmark">
			Docker无法启动Postgresql容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题描述解决问题 问题描述 拉取了一个Postgresql14.2的镜像，在docker run创建并运行容器之后使用docker ps发现容器没有跑起来，再次使用docker start也没跑起来。
docker run -d --name mypg -v psql-data:/var/lib/postgresql/data -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=admin -p 5432:5432 postgres:14.2 后面我尝试了以下的解决方案：
重启docker，删除容器之后再次docker run→无法运行修改指令，docker run -d→docker run -dit（后台运行→前台交互运行）→无法运行 解决问题 这时候只能看容器的日志了docker logs mypg（mypg是容器名）
[root@VM-8-9-centos lib]# docker logs mypg ls: cannot access '/docker-entrypoint-initdb.d/': Operation not permitted 这样我就好百度解决问题了 原因： 权限问题。
解决：
docker rm删除容器重新run，并加上--privileged=true（让容器以privileged模式运行，即拥有几乎与主机（root）相同的权限）
注意： 使用--privileged=true选项可以让容器执行一些通常不能执行的操作，例如加载内核模块、直接操作硬件设备等。然而，这也带来了严重的安全隐患。由于privileged容器具有几乎与主机相同的权限，如果容器被恶意代码控制，攻击者可以轻易地突破容器的边界，对主机进行任意操作。
建议使用其他更细粒度的权限控制手段，例如通过 --cap-add 或 --device 参数来分别添加必要的capabilities或设备访问权限。这样可以更好地控制容器的权限，并减少潜在的安全风险，如下。
docker run --cap-add SYS_ADMIN -d mypg [省略] 至于该配置什么权限，可以参考这篇博客：https://developer.aliyun.com/article/722230
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6452930af3fb319c99b8a0fbd909d009/" rel="bookmark">
			雪球股票数据接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录儿 雪球K线接口K线对象属性 雪球 K线接口 https://stock.xueqiu.com/v5/stock/chart/kline.json?symbol=SZ300396&amp;begin=1664553600000&amp;period=day&amp;type=before&amp;count=-8&amp;indicator=kline
symbol：股票代码（前缀SZ表示深圳证券交易所，SH表示上海证券交易所）
begin：开始时间戳（一定要13位，不够用0补足）
period：周期（day-日，week-周，…）
type：类型（before-历史）
count：周期数（-8表示获取前8个周期（日）数据）
indicator：指示信号（kline-K线，pe-市盈率，pb市净率 等等）
K线对象属性 "timestamp", // 时间戳 ms "volume", // 成交量 股 "open", // 开盘价 元 "high", // 最高价 元 "low", // 最低价 元 "close", // 收盘价 元 "chg", // "percent", // 涨幅 % "turnoverrate", // 换手率 % "amount", "volume_post", "amount_post", "pe", // 市盈率 "pb", // 市净率 "ps", // 市销率 "pcf", // 市现率 "market_capital", // 市场资金 "balance", "hold_volume_cn", "hold_ratio_cn", "net_volume_cn", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6452930af3fb319c99b8a0fbd909d009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc71816f2b4b9c2658696ae0b6d7f73e/" rel="bookmark">
			java打包成mac程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MacJava! Tutorial Commands ========================== If you don't like reading instructions, run through the whole tutorial by just pasting the commands below into the terminal. Notes: 1) Be sure you have the latest version of openjdk installed: brew install openjdk 2) When the "ShowTime" application is launched, quit the application to continue on with the remaining commands. 3) For details visit: https://centerkey.com/mac/java Copy-and-paste commands ----------------------- echo "&gt;&gt;&gt; Start" java --version mkdir showtime cd showtime curl --remote-name https://centerkey.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc71816f2b4b9c2658696ae0b6d7f73e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1903906f3ce02d554d082324a24a51c/" rel="bookmark">
			TPS5430正负电源模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TPS5430正负电源模块 Chapter1 TPS5430正负电源模块一、芯片重要参数二、tps5430参考电路讲解以及PCB布局1.正压降压（15V转12V）2.正压降负压（15V转-12V） Chapter2 使用tps5430制作正负DC-DC降压电源，tps7a47和tps7a33制作正负LDO线性电源第一部分、TPS5430制作正负DC-DC降压电源第二部分、TPS7a33,TPS7a47制作正负LDO线性电源LT3045 / LT3042LT1764 Chapter3 TPS5430开关电源 正负电源 低噪声设计 选材分析 布局布线分析 原理图PCB分析基本原理芯片选型原理图&amp;3D-PCB具体讲解1、正压降压2、负压反压3、L1,L2电感选型4、C2,C8电容选型5、D1,D2整流二极管6、PCB布局7、PCB布线 Chapter1 TPS5430正负电源模块 原文链接：https://blog.csdn.net/HDUGEEK/article/details/128159983
一、芯片重要参数 （1）输入电压范围：5.5V~36V
（2）输出电压范围：1.23V~31V
（3）最大输出电流：3A
（4）静态电流： 3mA
二、tps5430参考电路讲解以及PCB布局 1.正压降压（15V转12V） 1.1原理图
原理图参考下图，输入C3尽力靠近芯片输入端口VCC，EN悬空默认为芯片工作状态。C4的电容值必须为0.01uF。输出电压公式(R1 / R2 + 1) * 1.221。
1.2器件选择
（1）L1：由于tps5430芯片的峰值电流为3A，选择的电感峰值电流要大于等于3A，选用10uH电感（一般选择饱和电流更大的一体成型电感）。
（2）C3：由于开关波形的存在，电容必须选用有极性的电容才能更好的起到滤波的效果，容值合适即可，不可过大，这样会加重开关电源开启时的电流负担，正压滤波电容耐压值一般需要大于输入电压，最好是2倍。这里选择10uF钽电容来滤波。
（3）D1：开关电源需要整流滤波才能输出直流电压，所以整流二极管的选型也很重要，模块设计时兼容性价比采用了SS34，即为40V反偏电压，3A最大电流，能满足电流设计，有条件的可以使用SS54或者SS56等更大功率的管子，可以提高输出电流的稳定度。
1.3PCB布局
注：U2、U3为贴片排针
布局指点：
输入电容C1与芯片输入电压引脚7（VIN）以及芯片接地引脚形成的回路面积尽可能小。（如图右下角绿色边框内部区域）
芯片引脚8（PH）应该靠近捕获二极管D1以及电感L1，并尽量减小PCB面积来防止过度电容耦合。二极管D1也应较靠近PH端来最小化输出电流回路面积。（中间紫色边框区域）
芯片引脚1（BOOT）靠近电容器C2，尽量减小导线轨迹长度。
铺铜区域和布线避免锐角和直角，便于电压电流传输。
线宽的大小根据原理图电流大小设计,例3A大概用100mil120mil、2A大概用60mil80mil、1A用40mil~60mil。电流回路上线一定要够粗，保证有一定的余量。
电感下面最好不要铺铜，减小电感开关纹波的电磁效应。
2.正压降负压（15V转-12V） 负电压的器件选择跟正电压一致，这里不再重复。PCB布局要求基本一致，但有些重要点会在下面强调。
2.1原理图
输出电压公式(R1 / R2 + 1) * 1.221。
2.2PCB布局
Chapter2 使用tps5430制作正负DC-DC降压电源，tps7a47和tps7a33制作正负LDO线性电源 原文链接：https://blog.csdn.net/qq_41120409/article/details/90127517
今天，小刚我制作了一款DC-DC和LDO线性电源，其输入范围为10V-35V
配置4个电源输出端分别为：
开关电源tps5430-------------------------正负12V 正负5V
LDO线性电源tps7a47和tps7a33-----正负5V 正负3.3V
第一部分、TPS5430制作正负DC-DC降压电源 先来介绍TPS5430这款芯片
TPS5430参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1903906f3ce02d554d082324a24a51c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cce5cfb1d61f759787cbb20d40bc550e/" rel="bookmark">
			微信小程序抽屉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!--屏幕背景变暗的背景 --&gt; &lt;view class="commodity_screen" bindtap="hideModal" wx:if="{{showModalStatus}}"&gt;&lt;/view&gt; &lt;!--弹出框 --&gt; &lt;view animation="{{animationData}}" class="commodity_attr_box" wx:if="{{showModalStatus}}"&gt; &lt;view class="commodity_tit"&gt;&lt;text class="comtittext"&gt;这里写标题&lt;/text&gt; &lt;view class="clenrbox" bindtap="hideModal"&gt; &lt;image class="clenr" src="/Images/communitysafety/clenr.png" mode="" /&gt; &lt;/view&gt; &lt;/view&gt; &lt;!--这里写内容 --&gt; &lt;view class="contbox"&gt; &lt;/view&gt; &lt;/view&gt; showModal() { // 显示遮罩层 var animation = wx.createAnimation({ duration: 200, timingFunction: "linear", delay: 0, }); this.animation = animation; animation.translateY(300).step(); this.setData({ animationData: animation.export(), showModalStatus: true, }); setTimeout( function () { animation.translateY(0).step(); this.setData({ animationData: animation.export(), }); }.bind(this), 100 ); }, //隐藏对话框 hideModal: function () { // 隐藏遮罩层 var animation = wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cce5cfb1d61f759787cbb20d40bc550e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768b4676c1324946f6597b1af81be698/" rel="bookmark">
			Git 简单学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言
一、Git
二、安装Git
1、下载与安装
1.1、基本配置
1.2、为常用指令配置别名
1.3、中文乱码
2、获取本地仓库
3、基础操作指令
4、添加文件到忽略列表
5、简单练习
6、开发中的分支使用原则与流程
7、分支操作练习
三、远程仓库使用
3.1 gitee的使用
3.2 注册码云
3.3创建远程仓库
3.4 配置SSh公钥
3.5 操作远程仓库
3.5.1 添加远程仓库
3.5.2 查看远程仓库
3.5.3推送到远程仓库
3.5.4 从本地分支与远程分支的关联关系
3.5.5 从远程仓库克隆
3.5.6 从远程仓库中抓取和拉取
3.5.7 解决合并冲突
四、IDEA 操作GIT
4.1 IDEA 中配置 git
4.2 在 IDEA 中操作 Git
4.2.1 IDEA 创建git 仓库提交代码
4.2.2 通过 IDE 克隆项目
4.2.3 IDE 创建分支
4.2.4 IDE 解决代码冲突
4.2.5 版本回退
4.3 操作入口
4.4 IDEA 集成 GitBash 作为 Terminal
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/768b4676c1324946f6597b1af81be698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfaff1241b0c8c1a99372fda1f47f0df/" rel="bookmark">
			【C&#43;&#43;】vevtor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 使用举例 2.定义和初始化 构造函数功能vector&lt;T&gt; v1vector保存类型为T的的对象；默认构造函数；v1为空；vector&lt;T&gt; v2(v1)v2为v1的副本vector&lt;T&gt; v3(n, i)v3包含n个值为i的元素vector&lt;T&gt; v4(n)v4含有值初始化的元素的n个副本 3.vector对象的操作 操作功能v.empty()如果v为空，则返回true,否则返回false。v.size()返回v中元素的个数。v.push_back(t)在v的末尾添加一个元素t。v[n]返回v中位置为n的元素。 4.遍历vector(不使用迭代器) 5.遍历vector(使用迭代器) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b9e2afbf8c1978f940122a6b1cac43/" rel="bookmark">
			关于“Python”的核心知识点整理大全59
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
19.3.2 将数据关联到用户
1. 修改模型Topic
models.py
2. 确定当前有哪些用户
3. 迁移数据库
注意
19.3.3 只允许用户访问自己的主题
views.py
19.3.4 保护用户的主题
views.py
views.py
19.3.6 将新主题关联到当前用户
views.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
19.3.2 将数据关联到用户 现在，需要将数据关联到提交它们的用户。我们只需将最高层的数据关联到用户，这样更低 层的数据将自动关联到用户。例如，在项目“学习笔记”中，应用程序的最高层数据是主题，而 所有条目都与特定主题相关联。只要每个主题都归属于特定用户，我们就能确定数据库中每个条 目的所有者。
下面来修改模型Topic，在其中添加一个关联到用户的外键。这样做后，我们必须对数据库 进行迁移。最后，我们必须对有些视图进行修改，使其只显示与当前登录的用户相关联的数据。
1. 修改模型Topic 对models.py的修改只涉及两行代码：
models.py from django.db import models from django.contrib.auth.models import User class Topic(models.Model): """用户要学习的主题""" text = models.CharField(max_length=200) date_added = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey(User) def __str__(self): """返回模型的字符串表示""" return self.text class Entry(models.Model): --snip-- 我们首先导入了django.contrib.auth中的模型User，然后在Topic中添加了字段owner，它建 立到模型User的外键关系。
2. 确定当前有哪些用户 我们迁移数据库时，Django将对数据库进行修改，使其能够存储主题和用户之间的关联。为 执行迁移，Django需要知道该将各个既有主题关联到哪个用户。最简单的办法是，将既有主题都 关联到同一个用户，如超级用户。为此，我们需要知道该用户的ID。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b9e2afbf8c1978f940122a6b1cac43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f8cd683169db0aa0c240766b265301f/" rel="bookmark">
			Linux 如何 kill 指定的 python 进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 写在前面一、显示python相关的进程二、找到自己想要 kill 的进程，执行下述指令 写在前面 自己的系统是 Ubuntu 20.04
一、显示python相关的进程 ps -ef | grep python 显示结果如下
其中，第二列分别是各个进程的 PID 号。
二、找到自己想要 kill 的进程，执行下述指令 kill -s 9 进程PID号 如果提示权限不足，则增加 sudo， 即执行下述指令：
sudo kill -s 9 进程PID号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9c33b27cd1000aa6d8be874decb425/" rel="bookmark">
			zookeeper 常见客户端介绍和使用 zkCli、自带API、 zkClient、Curator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Zookeeper的命令行使用二、Zookeeper自带API的使用2.1 引入API2.1 API简单使用 三、Zookeeper三方客户端zkClient的使用3.1 引入依赖3.2 简单的使用案例四、Curator 客户端框架4.1 引入依赖4.2 简单使用案例 一、Zookeeper的命令行使用 ZooKeeper解压后，在其bin目录下包含着常用的程序，例如 zkServer.sh zkCli.sh
我们使用zkCli.sh 就可以通过命令行使用Zookeeper客户端
连接zookeeper服务器
连接后输入help就可以查看所有命令和使用方式的说明了
#对于本地默认端口 则可以直接 ./zkCli.sh # -server 指定服务地址和端口 [root@localhost bin]# ./zkCli.sh -server localhost:15881 创建节点命令
create [-s][-e] path data acl
-s或-e分别指定节点特性，顺序或临时节点，若不指定，则创建持久节点；acl⽤来进⾏权限控制。
# 创建顺序节点 [zk: localhost:15881(CONNECTED) 0] create -s /zk-test dataContent1111 Created /zk-test0000000007 # 创建临时节点，临时节点在会话结束后由就会被自动删除 [zk: localhost:15881(CONNECTED) 0] create -e /zk-temp data222 Created /zk-temp # 创建永久节点 [zk: localhost:15881(CONNECTED) 2] create /zk-test-permanent data333 Created /zk-test-permanent 读取节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a9c33b27cd1000aa6d8be874decb425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85898a0129b64eb935660407a47207f/" rel="bookmark">
			Swagger2入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.背景介绍
2.什么是Swagger2
3.常用注解
4.SpringBoot整合Swagger2
4.1.导入依赖
4.2.创建Swagger配置类
4.3.综合案例​编辑
@Api
@ApiOperation
@ApiImplicitParam
@ApiImplicitParams
@ApiModel和@ApiModelProperty
@ApiParam
5.生产环境下屏蔽Swagger2
5.1.修改Swagger2配置类
5.2.修改application.yml
5.3.使用maven package打包测试​编辑
5.4.运行测试
1.背景介绍 在团队开发中，一个好的 API 文档不但可以减少大量的沟通成本，还可以帮助一位新人快速上手业务。传统的做法是由开发人员创建一份 RESTful API 文档来记录所有的接口细节，并在程序员之间代代相传。这种做法存在以下几个问题：
1）API 接口众多，细节复杂，需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等，想要高质量的完成这份文档需要耗费大量的精力；
2）难以维护。随着需求的变更和项目的优化、推进，接口的细节在不断地演变，接口描述文档也需要同步修订，可是文档和代码处于两个不同的媒介，除非有严格的管理机制，否则很容易出现文档、接口不一致的情况；
Swagger2 的出现就是为了从根本上解决上述问题。它作为一个规范和完整的框架，可以用于生成、描述、调用和可视化 RESTful 风格的 Web 服务：
接口文档在线自动生成，文档随接口变动实时更新，节省维护成本；
支持在线接口测试，不依赖第三方工具；
2.什么是Swagger2 Swagger2 是一个规范和完整的框架，用于生成、描述、调用和可视化Restful风格的web服务，现在我们使用spring boot 整合它。作用：
接口的文档在线自动生成；
功能测试；
3.常用注解 注解描述@Api将类标记为 Swagger 资源。@ApiImplicitParam表示 API 操作中的单个参数。@ApiImplicitParams允许多个 ApiImplicitParam 对象列表的包装器。@ApiModel提供有关 Swagger 模型的其他信息。@ApiModelProperty添加和操作模型属性的数据。@ApiOperation描述针对特定路径的操作或通常是 HTTP 方法。@ApiParam为操作参数添加额外的元数据。@ApiResponse描述操作的可能响应。@ApiResponses允许多个 ApiResponse 对象列表的包装器。@Authorization声明要在资源或操作上使用的授权方案。@AuthorizationScope描述 OAuth2 授权范围。 4.SpringBoot整合Swagger2 4.1.导入依赖 &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;groupId&gt;io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f85898a0129b64eb935660407a47207f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/127499ca60537a046a195e2344de5dae/" rel="bookmark">
			PLSQL存储过程中异常的传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.PLSQL异常处理的几个原则 异常是指程序在编译时不能被发现，而在运行时出现的错误，异常处理可以使程序正常结束 ，并且可以灵活指定异常处理动作。
异常的作用域是本异常所覆盖的语句块或部分语句块，对于嵌套的语句块，外部定义的异常适用于处理所有内部块中所匹配出现的异常；
异常出现后，在块中直接跳到异常处理部分，出现异常问题的后面非异常处理语句不会获得执行；
嵌套块中，内部块已处理过异常后，不会再传递进入外部块中处理，在内部块执行完成跳出内部块后，内部块外面外部块的语句仍按顺序执行，不会直接跳到外部块异常页结束块；
嵌套块中，内部块未进行异常处理时，会将异常往外层块传递，如果外层块中可以捕获到对应异常，则由外部块处理异常。
2. 栗子 2.1 单个存储过程 创建类似测试过程：
CREATE OR REPLACE PROCEDURE TEST_INNER_EXCEPTION (O_CODE OUT NUMBER, O_NOTE OUT VARCHAR2 ) IS V_RESULT NUMBER; BEGIN O_CODE := 1; O_NOTE :='SUCCESS'; SELECT 1/0 INTO V_RESULT FROM DUAL; DBMS_OUTPUT.PUT_LINE('异常后是否执行'); EXCEPTION WHEN OTHERS THEN O_CODE :=-1; O_NOTE :='Failure: '||SQLERRM; END ; 数据库单步测试该过程，将会看到执行到1/0时会发生除零运行时异常，触发ORACLE内置OTHERS异常后，直接跳到EXCEPTION ,执行此异常后的语句，而不会执行发生异常后正常块语句：DMBS_OUTPUT.PUT_LINE打印语句:
2.2 嵌套存储过程 (1) 创建外层存储过程调用内层存储过程:内部处理异常，外部不再处理，执行外部异常只会得到外部结果，不会传递内部异常到外部。
CREATE OR REPLACE PROCEDURE TEST_OUTER_EXCEPTION (O_CODE OUT NUMBER, O_NOTE OUT VARCHAR2 ) IS V_RESULT NUMBER; BEGIN TEST_INNER_EXCEPTION(O_CODE,O_NOTE); O_CODE := 1; O_NOTE :='SUCCESS'; EXCEPTION WHEN OTHERS THEN O_CODE :=-1; O_NOTE :='Failure: '||SQLERRM; END ; 单步调试此过程，将会看到在内部除零错误时，内部异常处理，此时O_CODE=-1,O_NOTE为内部失败信息，但注意此时，内部存储过程执行结束后，由于其异常已在其内部本身被处理，因而不会被传递到外部存储过程的异常处理部分，因此，跳出内部存储过程后，依然执行下一句：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/127499ca60537a046a195e2344de5dae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d01f9336b4da7bafb4483a1450d227c/" rel="bookmark">
			Linux 进程(七) 进程地址空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟地址/线性地址 学习c语言的时候我们经常会用到 “&amp;” 符号，以及下面这张表，那么取出来的地址是否对应的是真实的物理地址呢？下面我们来写代码一步一步的验证。
从上面这张图不难看出，从正文代码，到命令行参数环境变量，的地址依次是从低到高的，我们来写一段代码验证一下。
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int g_unval; int g_val= 100; int main() { printf("code addr:%p\n",main); printf("init data addr:%p\n",&amp;g_val); printf("uninit data addr: %p\n",&amp;g_unval); char* heap = (char*)malloc(20); printf("heap addr:%p\n",heap); printf("stack addr:%p\n",&amp;heap); return 0; } 从这里我们不难发现：地址确实是从高到低依次出现的。
那么命令行参数以及环境变量呢，下面我们再多写几组代码。
int g_unval; int g_val= 100; int main(int argc,char* argv[],char* env[]) { printf("code addr:%p\n",main); printf("init data addr:%p\n",&amp;g_val); printf("uninit data addr: %p\n",&amp;g_unval); char* heap = (char*)malloc(20); char* heap1 = (char*)malloc(20); char* heap2 = (char*)malloc(20); char* heap3 = (char*)malloc(20); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d01f9336b4da7bafb4483a1450d227c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/590563d5bdb16fd4e9a7a630522cf633/" rel="bookmark">
			Yolov5 多边形标签转换，所有json文件自动转成txt格式[详细过程]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题引入
Labelme简要介绍
多边形标签的处理方法
转换后的txt格式如下：
代码实现
多边形标签代码实现方法
json转化为txt的部分代码如下：
数字规范化的代码如下：
最后附上我的完整代码
问题引入 网上的json转化为txt的教程都比较简要，查找了很多资料之后，再自己一个一个的运行代码最后才终于知道其原理。
Labelme简要介绍 通过labelme对图进行标注后，得到的是json文件，而Yolov5对数据进行模型构建的时候，读取需要的是txt格式的文件。所以需要先通过Python进行文件格式的转换
注：labelme是麻省理工（MIT）的计算机科学和人工智能实验室（CSAIL）研发的图像标注工具，人们可以使用该工具创建定制化标注任务或执行图像标注，项目源代码已经开源。
Labelme程序运行，通过标注后如图所示：
图1 Labelme标注
此图片可以得到以下格式的json文件：
文件中的字段如下：
‘version’——版本号
‘shapes’——里面装的是Yolov5需要的数据
‘label’——你在labelme里面设置的类
‘points’——点的坐标
我这里的label如图1所示共有5类，等下进行json转化为txt的时候用
对应这些类创一个字典以便json进行转换
例：name2id={'bike':0,'arrow':1,'crossline':2,'building':3,'car':4,'person':5}
可能某一张图片中可能不存在上述的某个类，所以这里请以某个json中最多的类创建这个字典。
多边形标签的处理方法 由于yolov5 仅支持矩形图形的识别，所以需要通过数据处理，将多边形变换为矩形。
处理原理：遍历该标签所有的坐标，获取最大x_max,y_max,最小x_min,y_min的x和y的坐标。
然后再进行数据的规范化。
转换后的txt格式如下： 第一个是类，比如第一行中的第一个数字是4，我的name2id中car也为4，即这里指代的就是'car'这个标签。
第一行 第二个 和 第三个数字 为数字为图片中心点(x,y)的坐标
第四个数字和第五个数字对应的是 这个标签的 宽和高。 代码实现 多边形标签代码实现方法 x_max=0 y_max=0 x_min=float("inf") y_min=float("inf") for lk in range(len(i['points'])): x1=float(i['points'][lk][0]) y1=float(i['points'][lk][1]) if x_max&lt;x1: x_max=x1 if y_max&lt;y1: y_max=y1 if y_min&gt;y1: y_min=y1 if x_min&gt;x1: x_min=x1 bb = (x_min, y_max, x_max, y_min) json转化为txt的部分代码如下： import os def decode_json(json_floder_path, txt_outer_path, json_name, convert=True): txt_name = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/590563d5bdb16fd4e9a7a630522cf633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b132d3ef8b2873df66be080f9eb31110/" rel="bookmark">
			如何在win7同样支持Webview2 在 WPF 中使用本地 Webview2 ,如何不依赖系统 Runtime
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行环境：
.Net Framework 4.5.2
Windows 7 x64 Service Pack 1
WebView2 Microsoft.WebView2.FixedVersionRuntime.120.0.2210.91.x64
考虑到很多老项目，本项目使用的是.Net Framework 4.5.2，.Net 更高版本的其实也是可以支持的。
1、下载 WebView2 固定版本 Runtime WebView2 Runtime: https://developer.microsoft.com/zh-CN/microsoft-edge/webview2/#download
首先下载自己想要的固定版本的 WebView2 Runtime[1]
下载下来的文件为 Cab 格式的文件，此文件为压缩文件 将其解压，可得到如下的目录
2、创建项目，将Webview2 复制到项目中 创建.Net Framework 4.5.2 WPF 项目，将解压的Webview2 复制到项目中，如下图所示：
文件夹 WebView2 中就是cap文件解压后的二进制文件以及文件夹
将 WebView2 文件夹中所有文件
属性 - 高级 - 复制到输入目录 设置为 如果较新则复制
属性 - 高级 - 生成操作 设置为 无
如下图所示：
3、在项目的 MainWindow 后台代码中写逻辑 在MainWindow.cs 文件中添加代码
Public partial class MainWindow : Window { public string Url { get; set; } = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b132d3ef8b2873df66be080f9eb31110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5387eabb3c85a356a6316ca6875b19be/" rel="bookmark">
			解决printf无法打印输出的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FreeRTOS中直接使用newlib库是有问题的，相信使用过freertos进行printf都能发现这个问题，这个问题网上有两种方法：
1、使用printf.stdarg.c，问题在于，这个库没有包含float型的输出！你没办法printf出浮点数。
2、使用优化过的printf，这个能输出float型，但是在中断中如果使用float输出，就会莫名其妙的整个程序卡住，我找不出bug。
static int inHandlerMode (void) //若在中断中__get_IPSR()返回1，否则返回0 { return __get_IPSR(); } void print_usart2(char *format, ...) { char buf[64]; if(inHandlerMode() != 0) { taskDISABLE_INTERRUPTS(); } else { while(HAL_UART_GetState(&amp;huart2) == HAL_UART_STATE_BUSY_TX)//若串口忙则挂起此任务 taskYIELD(); } va_list ap; va_start(ap, format); vsprintf(buf, format, ap); HAL_UART_Transmit(&amp;huart2, (uint8_t *)buf, strlen(buf), 100); va_end(ap); if(inHandlerMode() != 0) taskENABLE_INTERRUPTS(); } 这破问题一直找不到bug在哪里，烦死了，我忍不了了！敲了个伪printf，思路很简单，遍历一遍要输出的字符串，这过程中遇到%就标记，再遇到'.'这个字符就记录一下'.'后面的数字，然后从va_list中根据%x 判断一下属于哪个类型，用va_arg读取到值，再将该值的每个十进制位读取成字符后放进输出字符串里面，就完成了！代码如下：
#include"iostream" #include "stdarg.h" using namespace std; void GetIntToString(char *target,int* target_site,int value,int num_value){ char temp[20]; int temp_site = 0,site = *target_site,flag = 0,neg_flag = 0; if(num_value !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5387eabb3c85a356a6316ca6875b19be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c5c426a5401002a2552d6c9f9e3096/" rel="bookmark">
			STM32 CubeMX 中断NVIC 实战 (超详细配30张高清图，附源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 CubeMX 中断NVIC 实战 (超详细配30张高清图，附源码) 1. 中断基础概念 STM32F407的嵌套向量中断控制器（Nested Vectored Interrupt Controller，NVIC）管理所有中断，它有82个可屏蔽中断，还有13个系统中断。82个可屏蔽中断和部分系统中断可配置中断优先级，总共有16个优先级。
触发条件： 中断是由外部事件触发的，这些事件可以是来自硬件（比如传感器输入、定时器结束等）或软件（比如系统调用或特定指令）的信号。响应过程： 当中断事件发生时，处理器暂停当前正在执行的任务，保存当前状态（比如程序计数器、寄存器状态等），然后跳转执行预定义的中断服务程序（ISR，Interrupt Service Routine）。中断服务程序： 这是一段专门设计来处理特定中断的代码。它会执行必要的操作以响应中断事件，可能会读取外部设备状态、清除中断标志、执行特定操作并最终恢复被打断的程序执行。中断优先级： 中断可以具有不同的优先级，允许系统在有多个中断发生时确定哪个中断应该首先被处理。 NVIC是ARM Cortex-M处理器内部的模块，负责管理处理器的中断。它的特性包括：
嵌套性： 允许不同优先级的中断按照其优先级被嵌套处理，优先级高的中断可以中断优先级低的中断。向量表： 每个中断都有一个唯一的编号（向量），这些向量存储在向量表中。当中断发生时，处理器通过查找向量表中的特定入口点来确定要执行的中断服务程序。优先级和控制： NVIC允许配置每个中断的优先级，并可以通过控制寄存器来使能或禁用特定的中断。 在STM32系列中，要使用中断，通常的步骤包括配置相关的外部硬件（如果需要）、配置NVIC以及编写中断服务程序。在初始化过程中，需要确保配置中断优先级和使能相应的中断。
2. 中断向量表 STM32F4系列使用的是ARM Cortex-M内核，中断向量表是处理器中的一组特殊地址，存储着每个中断服务程序的入口地址。当发生中断时，处理器会根据中断编号查找中断向量表，并跳转到相应中断服务程序的入口地址执行。
STM32F4的中断向量表结构： 存储位置： 中断向量表存储在处理器的内存中，通常位于微控制器的Flash起始地址处。在STM32F4中，中断向量表通常位于0x00000000的地址处，是一个连续的地址空间。向量表项： 每个中断有一个向量表项。这些项是连续存储的，每个项占据4个字节。中断服务程序入口地址： 每个向量表项存储着对应中断服务程序的入口地址。当中断发生时，处理器会根据中断编号找到相应的入口地址并跳转执行。 STM32F4的中断向量表组成： 在STM32F4中，中断向量表包括了两种类型的向量表项：
ARM Cortex-M处理器核心向量表： 这部分向量表项包含了Cortex-M处理器的核心中断服务程序入口地址，如： 初始栈指针（Initial Stack Pointer）复位（Reset）NMI（Non-Maskable Interrupt）Hard Fault等 STM32特定的外设中断向量表： 在ARM Cortex-M处理器核心向量表后面，是STM32特定的外设中断向量表项。这些项存储着与STM32F4系列相关的外设中断服务程序的入口地址，比如TIM1、TIM2、USART1等。如下图所示： 用STM32CubeMX生成代码后，在 startup_stm32f407zgtx.s 汇编文件中，我们可以看到中断向量表具体的定义和中断服务函数。
3. 中断优先级 在STM32F4系列中，中断优先级用于确定当多个中断同时发生时，处理器应该先处理哪个中断。这个优先级系统是由ARM Cortex-M内核提供支持的。
3.1 中断优先级的特点： 可编程性：
STM32F4允许针对每个可中断的外设配置中断优先级。这使得开发者可以根据系统需求对中断进行优先级管理。
优先级位数：
Cortex-M内核中的中断优先级分为抢占优先级（Preemption Priority）和子优先级（Subpriority）。在STM32F4中，通常抢占优先级占据较高的位数，子优先级占据较低的位数。
数值越小，优先级越高：
优先级数值越小，表示优先级越高。比如，抢占优先级数值为0的中断优先级最高。
3.2 中断优先级的配置： 在STM32F4中，使用NVIC（Nested Vectored Interrupt Controller）来配置中断优先级。配置中断优先级的步骤如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90c5c426a5401002a2552d6c9f9e3096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d13f11783465fb40560e87d8ff252a49/" rel="bookmark">
			【AI】一文读懂大模型套壳——神仙打架？软饭硬吃？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、套壳的风波此起彼伏
二、到底什么是大模型的壳
2.1 大模型的3部分，壳指的是哪里
大模型的内核
预训练（Pre-training）
调优（Fine-tuning）
2.2 内核的发展历程和万流归宗
2.3 套壳不是借壳
三、软饭硬吃，套壳真的不行吗
四、神仙打架，百姓吃瓜
4.1 自研的佼佼者
4.2 模仿也不丢人
4.3 读书人偷书不算偷
模仿学习（Imitation Learning）
知识蒸馏（Knowledge Distillation）
五、我们还要再硬一点
一、套壳的风波此起彼伏 国内“百模大战”，我形容是“群模乱舞”，具体国内有哪些著名的大模型，请参考我的文章——
群模乱舞，AI大模型盛开，国内大模型盘点_ai大模型有哪些-CSDN博客
里面列出了大厂的模型，以及很多学院派的大模型。
大模型一夜之间，如同AIGAI，自体繁殖一样多起来，很多媒体的声音，也此起彼伏，说国内的大模型，很多都是开源大模型的套壳版本。
这里面动静最大的，可能是李开复先生的零一大模型张量命名事件。其推出的“Yi”大模型，这款模型被揭露只是对LLaMA进行了表面上的修改——仅仅改变了两个张量的名称。这种创新，确实在AI界并非孤例，而是一个普遍现象。
有人说，开源就该这样利用，不然开源干什么？有人说，闭源才是自主研发，参考开源就是套壳。
2023年2月，Meta首次发布了Llama羊驼系列模型。在这个初始版本中，羊驼系列包括了四种不同规模的模型：参数量分别为7亿、13亿、33亿和65亿。7月，Meta公布最新大模型 Llama 2(羊驼 2),包含 7B、13B 和 70B 三种参数变体,可免费用于商业或者研究。这引起不小的轰动，不光是国内，很多国外的大模型，基本都是复用了Llama2，后面我们会讲，为什么选择这个大模型，因为确实不用重复发明轮子了。
有想了解开源和闭源生态的，可以参考我的文章：【AI】马斯克说大模型要开源，我们缺的是源代码？（附一图看懂6大开源协议）_马斯克说大模型在技术上的突破-CSDN博客
非 AI 从业者，视套壳如洪水猛兽，吃瓜者认为套壳就是抄袭的代名词；真正的 AI 从业者，对套壳讳莫如深，需要借鉴，又狠怕惹锅上身。但由于“套壳”本身并没有清晰、准确的定义，导致行业对套壳的理解也是一千个读者有一千个哈姆雷特。
那么，问题来了——
二、到底什么是大模型的壳 2.1 大模型的3部分，壳指的是哪里 要想知道什么是大模型的壳，我们要先知道，大模型包括哪几个部分。
大模型的内核 大模型的内核通常指的是模型的核心架构和算法，这些设计决定了模型如何处理输入数据并生成输出。在大模型中，内核往往包含了大量的计算单元（如神经元、层等），以及它们之间的连接方式和权重。这些计算单元通过特定的数学运算（如矩阵乘法、激活函数等）共同工作，以提取输入数据的特征并做出预测。
大模型的内核设计通常基于深度学习理论，尤其是神经网络。近年来，如上所述，Transformer架构因其出色的性能成为了大模型内核的热门选择。Transformer利用自注意力机制来处理序列数据，能够捕获长距离依赖关系，并在各种NLP任务中取得了显著成果。
也就是说，大家的内核，基本都来自相同的老祖宗。
预训练（Pre-training） 预训练是指在大规模数据上对模型进行初步的训练。这个过程通常是无监督的，意味着模型不需要人工标注的数据就可以学习。预训练的目标是让模型学习到通用的知识和表示方法，这样它就能够更好地适应各种下游任务。
在大模型中，预训练尤为重要，因为庞大的参数量需要大量的数据来有效训练。预训练不仅可以提高模型的泛化能力，还可以加速后续任务的学习过程。例如，在NLP领域，BERT、GPT等模型就是通过在大规模文本语料库上进行预训练来获得强大的语言理解能力的。
调优（Fine-tuning） 调优，也叫做“微调”，是指在特定任务的数据上对已经预训练过的模型进行进一步的训练。这个过程通常是有监督的，需要使用标注好的数据来指导模型的学习。调优的目标是调整模型参数，使其更好地适应特定任务的需求。
在大模型中，调优通常比从头开始训练要高效得多，因为预训练已经为模型提供了一个很好的起点。通过调优，模型可以在较少的迭代次数和较小的数据集上达到较好的性能。此外，调优还可以使模型更加灵活地适应各种场景和任务需求。
在漫长的预训练之后会得到一个基座模型（Base Model），在基座模型的基础上加入特定行业的数据集做进一步的微调，就会得到一个微调模型（Fine-tuning Model），或者称为行业模型、垂直模型。
2.2 内核的发展历程和万流归宗 我们都知道，是大模型让AI达到如此的地位，实际上，AI经历了一段低迷期。
关于AI复兴推进器的自然语言处理、神经网络、遗传算法，我都分别写过文章去介绍。还有AI爆发的推进器之卷积神经网络、生成对抗网络、变分自动编码器、迁移学习、知识图谱、注意力机制与深度学习模型等，也可以参考我的之前的文章。
在 2020 年之前，NLP 的模型研究基本都是围绕算法展开，基于 BERT、T5 与 GPT 架构的模型百花齐放。这一时期模型参数较小，基本都在 10 亿以内量级。其中，谷歌 BERT 的表现独领风骚，基于 BERT 架构的模型一度在阅读理解的竞赛排行榜中屠榜。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d13f11783465fb40560e87d8ff252a49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4495a8915c570af1a25e69499921a9ac/" rel="bookmark">
			面试经典题---14.最长公共前缀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		14.最长公共前缀
我的解法：
主要思路是定义一个函数longestCommonPrefix(const string s1,const string s2)用于获取字符串s1和s2的最长公共前缀字符串，之后依次计算strs中的相邻字符串的最长公共前缀。
cmp初值为strs中的第一个字符串strs[0]；依次计算cmp与strs中后一个字符的最长公共前缀，并以该前缀来更新cmp；一旦发现cmp长度为0，则直接break class Solution { public: string longestCommonPrefix(const string s1,const string s2){ int len = min(s1.size(),s2.size()); int i = 0; while(i &lt; len &amp;&amp; s1[i] == s2[i]){ ++i; } return s1.substr(0,i); } string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { string cmp = strs[0]; for(int i = 1; i &lt; strs.size(); ++i){ cmp = longestCommonPrefix(cmp,strs[i]); if(cmp.size() == 0){ break; } } return cmp; } }; 可以一开始加一个判断：若strs的大小为0，则直接返回空字符串""
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a7a919801252eabffcd2749f2300dc/" rel="bookmark">
			音频筑基：基音、基频和共振峰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 音频筑基：基音、基频和共振峰 是什么深入理解相关参考 音频信号分析中，经常遇到基音、周期、共振峰的概念，这里总结下自己的粗浅理解，不当之处，还望各位大佬提出指正。
是什么 基音，是复音中强度最大、频率最低的音。表征着声音的音高，即人们所感知到的音调高低。通常是以频率维度衡量，所以也叫基音频率，简称基频F0。有时粗略讲，又叫音高，英文名Pitch。
基音周期Period：气流经声门的周期间隔，体现声源激励信息，设时间为T（s），物理含义为是时域波形最小重复的时间。 周期Period是指声音波形中一个完整的周期所需要的时间。周期Period一般可以通过分析波形的重复模式来确定，比如：计算波形中相邻两个峰值（或谷值）之间的时间间隔来获得。 基音频率Fundamental Frequency，是基音周期的倒数F0=1/T。 共振峰，英文名Formant，表现为频谱上由基频衍生的次谐波（能量最强的一根根横线）。
共振峰产生原理：F1、F2，经声门后来到声道处与发声环境产生共振的频率，体现声道环境信息。 深入理解 周期Period和基音Pitch如何转换？
Pitch指的是音频信号的基波周期，用周期或者频率来表示，如周期为4.3ms，对应频率就是230Hz，跟频谱图的频率概念是有别的。语音信号场景，基音指标十分重要。
转换公式为：Pitch = 1 / Period。换句话说，基音Pitch的值是周期Period的倒数。这意味着，周期越短，基音Pitch就越高；周期越长，基音Pitch就越低。
严格意义上讲，音高Pitch和基频F0有何区别？
严格说，音高的概念更广，音高主要由基频决定。通常认为，音高增高八度音程相当于基频翻倍。
基频F0是指声音波形中最低频率的周期性振动频率，也就是声音的基频。在语音信号中，基频F0通常对应于说话人的声调（tone），也就是说话人说话时的基本音高。基频F0的单位是赫兹（Hz）。基音Pitch是指声音的音高，通常用赫兹（Hz）或半音（semitone）来表示。在音乐领域中，Pitch通常指的是乐器演奏的音高，而在语音领域中，Pitch通常指的是说话人的音高。 相关参考 声音基频f0_音高和基频（Pitch and F0），link音频（二） 基音周期与共振峰， link基音周期和共振峰，linkWikipedia：共振峰，link口语元音中的共振峰和谐波，link 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68320b5425b0b60295ed797005daf2e4/" rel="bookmark">
			stm32学习总结：5、Proteus8&#43;STM32CubeMX&#43;MDK仿真串口并使用串口打印日志（注意重定向printf到串口打印的问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stm32学习总结：5、Proteus8+STM32CubeMX+MDK仿真串口并使用串口打印日志（注意重定向printf到串口打印的问题） 文章目录 stm32学习总结：5、Proteus8+STM32CubeMX+MDK仿真串口并使用串口打印日志（注意重定向printf到串口打印的问题）一、前言二、资料收集三、注意事项四、STM32CubeMX配置五、MDK工程相关代码1、非中断方式的按键处理2、开关机业务3、printf重定向到串口打印4、日志打印封装 六、Proteus项目配置七、仿真测试结果八、最后 一、前言 上一节模拟实现了串口收发打印，一般我们裸机打印日志通过串口或者JLINK工具等带的RTT打印，对于仿真，我们选择使用串口打印再合适不过了，这里总结一下重定向printf到串口打印日志的过程；期间，尝试了CLion+arm gcc的方式，发现stm32f10x的flash还是支撑不起来未裁剪的标准库，只要使用stdio相关标准库编译时就很容易flash超标。
二、资料收集 https://blog.csdn.net/m0_54490453/article/details/128921674
https://www.cnblogs.com/pianist/p/3315801.html
https://blog.51cto.com/u_13682052/5670642
STM32串口使用printf打印日志：
https://community.st.com/t5/stm32-mcus-products/how-to-get-printf-example-working-in-another-project/m-p/392014
https://community.st.com/t5/stm32-mcus-products/stm32g0-redirect-printf-to-write-and-use-uart-how-to/m-p/66318
三、注意事项 如果是使用arm gcc编译器的，尽量不要使用printf，这会引入标准库，而对应库不像mdk的microlib做了裁剪，它是比较占用flash的，而stm3210x的flash最多只有32KB，很容易在编译时出现section .rodata’ will not fit in region FLASH'也就是超出flash范围的问题：
网上所说的修改xxx.ld配置文件这些方法很多时候是无效的，不能盲目去修改flash配置。
可以使用比如RTT打印等方式来打印日志，也可以换一些资源比较丰富的板子，也许官方可以出一些裁剪过的利用arm-none-eabi gcc编译的标准库（后面有机会的话我会来尝试一下，用stm32F10x的话arm gcc基本上没办法用printf，引入标准库加上一两个简单的外设接口就肯定会flash超标，用mdk原有的编译器就不会有这个问题）。
四、STM32CubeMX配置 这次彻底精简一下相关配置：
1、一个按钮BUTTON，PA1配置GPIO OUTPUT用来接入按钮，使用默认配置即可，默认低电平，未拉高拉低，添加用户标签BUTTON： 2、五个LED，PA4-PA8配置GPIO OUTPUT用来接入LED，使用默认配置即可，默认低电平，未拉高拉低，添加用户标签LED_1到LED_5： 3、开启USART1，PA9\PA10来作为打印的串口，配置只发送，波特率设置为9600，不需要配置全局中断，我们使用该串口作为打印串口，只需要发送即可，所以不需要配置中断方式来接收： 然后生成代码即可。
五、MDK工程相关代码 1、非中断方式的按键处理 通过读取IO口的电平判断是否按下按钮，之后通过全局变量确认按下松开以及长短按，这种方式在理解上比较直观（按键这里的处理逻辑是判断LED灯1的电平变化来确定是否开关机，开关机的逻辑我们通过控制LED灯的亮灭来展示）：
#include "gpio.h" #include "key.h" #include "pwr.h" //#include "log.h" // 按键的键值 #define KEY_Press 1 // 读取IO口的电平 #define KEY_PWR HAL_GPIO_ReadPin(GPIOA, BUTTON_Pin) uint8_t key_old, count; uint8_t ScanKey(void) { if (GPIO_PIN_RESET == KEY_PWR) { HAL_Delay(40);//延时10-20ms，防抖 if (GPIO_PIN_SET == KEY_PWR) { count++; return KEY_Press; } } else { HAL_Delay(40); } return 0; } void DealKey(void) { uint8_t key_value = 0; //获取键值 key_value = ScanKey(); if (key_value !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68320b5425b0b60295ed797005daf2e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2ce62b4639212a189069766eded6b0/" rel="bookmark">
			B端产品经理学习-需求挖掘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B端产品需求挖掘 目录
识别和管理干系人
决策人和负责人需求挖掘
针对用户进行需求挖掘
用户访谈结果整理
B端产品的需求来源是非常复杂的，要考虑多个方面；如果你是一个通用性的产品，要考虑市场、自身优劣势、干系人。而定制型B端产品会更多的去关注干系人的需求。
一个平台一款产品适合做什么不适合做什么，例子：我是一个B端产品，我的优势是我有一个高效的开发团队，我的工程师厉害；我的劣势是我的服务部署到客户现场时间较长；根据自身的优劣势就可以判断我们适合和一些算法准确度较高大公司合作，因为大公司可以承担时间较长的部署周期和部署成本，一些中小型公司就不是我们的业务重点。
干系人即产品决策者、影响者、使用者等他们希望实现什么样的目标，这是非常关键的，这也是本篇文章的重点。
干系人 干系人是对产品由权利或有责任的任何人，干系人的范围很广泛，一般分为4个类别，分别是：决策人，负责人，执行人和其他影响人
决策人：决定是否购买产品或服务（通用型产品），或为产品功能最终拍板（定制型产品）该角色一般是公司的高管
负责人：一般是某条业务线的负责人，能极大影响高管的决策，一般在B端项目中对接人一般是直接的需求方。
执行人：负责某个业务的具体执行，B端产品的核心用户（一线员工、初级管理者）
其他影响人：一定程度上影响决策者的购买决策或影响功能范围的优先级；例如领域专家、技术团队、客服人员。
如何找到产品的干系人 这个步骤很多同学都不知道如何下手，在实行中并不困难，如果是通用型产品，公司内部一般是已经有了管理框架，比如说你是做面向中小餐厅的点单服务的产品，你的公司已经积累了一批客户，已经识别出什么样的人是决策权的，什么人是业务负责人。也可以通过销售、客服等跟客户直接沟通较多的同事去了解。如果是定制型的产品，一般都会有一个直接对接人，让对接人去发起和识别就可以，对于定制型的项目，一定要和直接对接人保持紧密的合作关系，因为他们将在整个项目周期是非常重要的，是各类信息的来源，也可以帮助我们去承担部分项目管理的工作，比如用户访谈的预约，项目进度的安排等等
案例：
认识该产品的干系人 S集团内部：战略规划部、信息技术部、经销商管理部、销售管理部（直接对接人
）经销商：销售人员、库存管理、前台接待、门店主管、大区主管。
通过梳理，我们得出决策者是：战略规划部，负责人包括销售管理部、经销商管理部；执行人包括：销售人员、库存管理、前台接待、门店主管；其他影响人包括：信息技术部、大区主管、购车人
干系人管理矩阵 识别出干系人之后需要对干系人进行管理，如下图所示，因为执行人需要用新的系统，日常的工作都需要使用，所以他们的关注度很高，但是对决策人的日常工作关系不太大。
一般来说，负责人是双高，对产品关注度高，影响力也高，但是影响力比决策者要低一点。其他影响人对于产品的影响力和关注度都是偏低的。
对于本项目的MVP版本，我们主要需要满足销售管理部门和经销商管理部门的需求，同时尽量满足战略规划部的需求。一线人员（该项目中的销售）虽然不具备决策权，但我们作为一个定制化产品，需要保证一线人员的跑通，也需要关注一线人员的需求。
决策人和负责人需求挖掘 在项目中，我们会优先挖掘决策人和负责人的需求，再去挖掘执行人（核心用户）的需求。因为决策人和负责人对项目的愿景和范围有更大的影响。我们了解了他们的需求之后，可以防止我们在后面的项目中跑偏。
如何挖掘决策人和负责人的需求呢？当然是要做好充分的准备；决策人和负责人一般是企业中高层的管理人员，和他们沟通的时候要体现自己的专业度，要非常的注意沟通的效率，做需求挖掘的形式一般选择面访。按照下图的方法走流程
一定要在准备的时候给决策者和负责人介绍项目的背景，因为他们是很忙的，不一定知道这个项目是干什么的。
访谈背景介绍参考 包含要素：项目名称、产品用户、产品价值、访谈规则、访谈时长
例子：本次访谈的目的是S汽车集团经销商销售系统搜索内部干系人的输入，了解集团业务和技术背景。本项目的目标是打造一套面向所有经销商的销售系统，供经销商一线销售人员和管理者使用，减少集团的管理成本。
访谈的内容只用于项目调研，并且会对受访者信息进行脱敏处理。同时，您可以跳过任何不想回答的问题，或者随时结束访谈。本次访谈大约花费45分钟。
通用问题参考 基础问题：您在公司主要负责哪些业务？您在这个项目中主要承担什么角色？我们主要竞争对手是谁？
项目相关：这个项目将如何影响您的工作？如何衡量这个项目是否成功？您认为本项目的主要限制或困难在哪里？
针对性的问题 产品愿景
对于我们要打造的经销商系统，您所理解的产品愿景是什么？
我们是否有想通过这个产品实现具体目标？
现存问题
目前是如何对经销商进行管理的?
这样的管理方式存在哪些问题？
不同区域的经销商是否存在差异？
对业务流程和用户的理解
请描述一下现在经销商的销售流程
您认为这个流程设计到主要的用户角色有哪些
这些角色之间的工作如何配合的
现有资源
针对我们的项目范围和目标，集团在过去是否做过调研和规划？
是否能够分享现有的调研数据和分析结论
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/28/">«</a>
	<span class="pagination__item pagination__item--current">29/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/30/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>