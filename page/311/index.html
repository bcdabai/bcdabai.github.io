<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01770e32415674c27dedf84c7cb40723/" rel="bookmark">
			学习笔记：alignas用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		struct Test{ char arr[9]; alignas(16) int a; double b; char c; }; int main() { auto sizeof_test = sizeof(Test); auto alignof_test = alignof(Test); auto offsetof_a=offsetof(Test,a); auto offsetof_b=offsetof(Test,b); auto offsetof_c=offsetof(Test,c); return 0; }
问题1） 什么是对齐。 举例说明，某个int类型的对象，要求其存储地址的特征是4的整倍数。例如0x0000CC04。我们把地址值0x0000CC04除以4，余数0，那么这个对象的地址就是对齐的。 问题2） 为什么要对齐。 举例说明，对于int数据，硬件只能在4的倍数的地址读写，假设某int对象的地址是0x0000CC06，则硬件先读取0x0000CC04开始的4个字节，取其0x0000CC06, 0x0000CC07。硬件然后读取0x0000CC08开始的4个字节，取其0x0000CC08, 0x0000CC09。将两次读取的有用信息拼接即可。显然，效率不高。更严重的，硬件会报错，程序执行不下去。 问题3） x86体系下，用#pragma pack(1) 改变结构体中int成员的对齐属性，也没报错呀 只能说x86容忍性高，程序正常跑，不见得效率没有降低。 问题4） C++11的alignas是什么。
改变一个数据类型的对齐属性。在例子中，Test::a的对齐值变成16，意味着a的地址值必须能被16整除。 考察a的偏移值是16，意味着arr[9]后面被插入填充用的7个字节了。 问题5) 上例中，只是a相对结构体首地址的偏移值16，如果结构体首地址的值是0x0000CC01，然后+16 = 0x0000CC11，显然不满足地址值的16倍数对齐了 在哪里创建Test当然是很重要的，为了防止上述事件发生，需要编译器和程序员的共同努力，但主要担子还在编译器上。例如在函数栈上创建一个Test对象，编译器必须选择一个好地方才行。 问题6) 为什么sizeof(Test)是48 offsetof(a)=16，a本身长4字节，b的偏移本应是20。 但是考虑到b的类型是double，其默认对齐值是8。20不是8的倍数，填充4个垃圾字节，现在到达偏移值24。 所以b的真正偏移值是24，b占8个字节。 现在到达c，c的偏移值是32，c本身占1个字节，整个test的长度貌似是33。 可是你要考虑test数组，例如数组test kk[2]。kk[1].a, 相对于数组首地址的偏移为33+16=49。这个地址不满足a的对齐了。 但是在c的后面填充15个垃圾字节，则 kk[1].a的地址 = kk的首地址值 + kk[0]长度48 + kk[1].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01770e32415674c27dedf84c7cb40723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a2d538d5bf95f737b3491327eb92f2/" rel="bookmark">
			软件设计师之路 --------UML类图符号，各关系说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UML简述----Unified Modeling Language
UML，又称为统一建模语言，始于OMG标准---Object Management Group：对象管理组织。用于为开发团队提供标准通用的设计语言开发和构建计算机应用，也方便地描述对象与类之间的关系。
UML，描述类与对象之间的关系方式包括：依赖--dependency，关联--association，聚合--aggregation，组合--composition，泛化--generalization，实现--realization。
依赖--dependency：元素A的变化会影响元素B，但反之不成立，那么B和A的关系是依赖关系。在UML中用带箭头的虚线表示依赖关系，箭头指向被依赖元素。
1.依赖关系是类与类之间的连接。
2.依赖关系总是单向（避免互相依赖，不应该存在互相依赖）
3.依赖关系在面向对象语言中体现为局部变量，方法的参数或对静态方法的调用。
比如：
关联--元素的结构化 关系，是一种弱关系，被关联的元素通常可以被独立的考虑。UML中用实线箭头表示关联关系。 1.关联关系是类与类之间的联结，他是一个类知道另一个类的属性和方法。
2.关联可以是双向的，也可以单向，双向关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。
3.在面向对象语言中，关联关系是通过使用成员变量来实现的。
聚合：关联关系的一种特例，表示部分和整体（has a部分关系）。uml中用带空心菱形的实线表示聚合关系
1.聚合关系是关联关系的一种，是强的关联关系。
2.聚合是整体和部分之间的关系，例如汽车是由于引擎，轮胎以及其他零件组成。
3.聚合关系也是通过成员变量 实现的，但是，关联关系所涉及的两个类处在同一个层次，而聚合关系中，两个类处于不同的层次，一个代表整体，一个代表部分
4.关联与聚合在面向对象语言中表达形式一样，必须要考察类之间的逻辑结构。
符号：用带空心菱形箭头表示聚合，菱形指向整体
组合关系：组合是聚合关系的变种，表示元素之间更加强的组合关系，如果是组合关系，如果整体被破坏，则个体一定被破坏，而聚合的个体则可能则可能是多个整体所共享，不一定随着整体的破坏而破坏，UML中用带实心体菱形表示组合关系。
1.组合关系是关联关系的一种，比聚合关系还要强
2.他要求普通的聚合关系中代表的整体对象的生命周期负责部分的对象的生命周期。
泛化关系和实现关系：泛化：通常所说的继承（特殊个体is kind of 一般个体）表示：用空心箭头的实线表示，箭头指向一般个体。 实现：元素A定义一个约定，元素B实现这个约定，则B和A的关系是实现，这个关系最常用于接口，用 虚线加空心的箭头表示实现关系。所指向的是定义约定的元素。
1.在面向对象中用于表示类与类之间的继承关系，接口与接口之间的继承关系，或对接口的实现关系。一般化关系是子类指向父类，或者从实现接口的类指向实现接口：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd8106671d36b38fb5ac132ba400f2d/" rel="bookmark">
			将QT开发的界面程序封装成DLL，在VC中成功调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近手头的一个项目需要做一个QT界面，并且封装成DLL，然后再动态调用DLL给出的接口函数，使封装在DLL内部的QT界面跑起来，在网上查了很多资料，今天终于成功了，经验不敢独享，因为CSDN给了我很多帮助，将心得写在这里供大家参考。 PS:本文中谈的是用QT封装一个包含界面的DLL，然后在其他任何地方使用任何语言来调用这个DLL，不是那种在qt creator里面建一个dll工程，然后再在qt creator里建一个调用该dll的工程的情况（这种示例可参考该链接http://download.csdn.net/source/2855817）。 本文所讲的例子在qt 4.7.3 opensource 以及VC6.0/VS2005成功运行 首先，在qt creator中是可以直接建立一个C++ DLL工程的，编译以后也可以生成dll，但是这样生成的dll拿VC去调是不会成功的。后来在CSDN上看到有人发的这样一篇帖子（原文链接http://blog.csdn.net/normallife/article/details/5397980）。里面谈到 “因为 QT 必须有调用 QApplication 的 exec 方法，这样才能产生消息循环， QT 的程序才可以运行。所以说如果我们使用了 QT 编写了 dll 程序，在普通的 windows 程序中是不能调用的。在调用的时候会出现错误。当然 QT 提供了解决方法：那就是 QTWinmigrate”。喜出望外啊，赶紧的把QTWinmigrate下下来。 打开QTWinmigrate文件夹，里面有几个目录，buildlib,doc,examples,lib,src。 在examples目录下给出几个应用QTWinmigrate的例子，其中有一个就是qtdll,嘿嘿，用qt creator打开其中的qtdll.pro工程文件。因为这个是已经做好的程序，所以可以直接在此基础上修改。右键单击 目录树最上层的工程名qtdll，选择“添加新有文件”，然后新建一个“QT设计师界面类”，类名什么的自己填上，点确定返回，可以看到后缀为.ui的界面文件及界面文件的.h文件和.cpp文件已经加入到qtdll工程里面了，界面你怎么画都行，剩下的步骤就是修改工程中的main.cpp文件 首先在main.cpp文件里面把界面文件的头文件include进来，然后将DLL发布接口函数的部分修改为如下所示： extern "C" __declspec(dllexport) int main(int argc, char *argv[]) { QApplication a(argc, argv); ****** w; w.show(); return a.exec(); } 其中******是你界面文件的.h文件中定义的界面类名 这样我们得DLL就做好了，然后点构建，就可以生成封装了QT界面并且可以用VC调用的DLL了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0df504f18bfea4a6f15116b4cc10f572/" rel="bookmark">
			详解 Qt 下 QLibrary 动态加载 dll (Fortran)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 下 QLibrary 动态加载 dll是本文要介绍的内容，先来配置环境，测试平台：Windows XP Sp3 + Qt 4.5 + Compaq Visual Fortran Version 6.6。
下了个Qt Creator功能挺强大的，测试一下QLibrary动态加载VS下编译的Fortran写的dll。在pushButton上建立click()信号的槽
#include "mainwindow.h" #include "ui_mainwindow.h" #include &lt;QLibrary&gt; #include &lt;qtextcodec.h&gt; //解决中文显示所需的库 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindowClass) { ui-&gt;setupUi(this); QTextCodec::setCodecForTr(QTextCodec::codecForLocale()); //设置中文显示，使用本地字库 connect(ui-&gt;OKButton,SIGNAL(clicked()),this,SLOT(close())); //将OKButton的Clicked（）信号帮定close（）槽 } MainWindow::~MainWindow() { delete ui; } void MainWindow::on_OKButton_2_clicked() //OKButton_2的槽 { ui-&gt;label-&gt;setText(QApplication::translate("MainWindowClass", "aaa", 0,QApplication::UnicodeUTF8 )); //另一种文本转换方法，不知有啥优点... int a=1,b=2,c=6; typedef void (*myfun)(int,int,int *); // 定义导出函数类型 QLibrary hdll( "test01.dll" ); //加载dll，当前目录 if(hdll.load()) { myfun fun1 = (myfun)hdll.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0df504f18bfea4a6f15116b4cc10f572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/709ad170d6b61d2bdff9808a69c09be4/" rel="bookmark">
			amazon V4鉴权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
Signature Version 4 Signing Process The signature version 4 signing specification describes how to add authentication information to AWS requests—that is, how to sign AWS requests. As a security measure, most requests to AWS must be signed using an access key (access key ID and secret access key). If you use the AWS Command Line Interface (CLI) or one of the AWS SDKs, those tools all automatically sign requests for you, based on credentials that you specify when you configure the tools.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/709ad170d6b61d2bdff9808a69c09be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e18ccc59781ce853385571d3878494/" rel="bookmark">
			win7 mysql安装和vc6.0调用mysql测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用过MySQL之后，不论容量的话，发现比其他两个（sql server 、oracle）好用的多，一下子就喜欢上了。下面给那些还不知道怎么弄的童鞋们写下具体的方法步骤。（我这个写得有点太详细了，甚至有些繁琐，有很多步骤在其他的教程文档里都是省略掉的，但我还是要写出来，因为我当时走了很多弯路，我希望你们能够避免我走的这些弯路。当然，知道同学的可以略过，选择你想知道的地方看）
· 电脑win7 64bit
方法/步骤
1. 1
第一大步：下载。
a.俗话说：“巧妇难为无米之炊”嘛！我这里用的是 ZIP Archive 版的，win7 64位的机器支持这个，所以我建议都用这个。因为这个简单嘛，而且还干净。
地址见图
拉倒最下面，看清楚了64bit ZIPArchive ，点击Download。
2. 2
b.点开之后会进入另一个页面，但却没有开始下载，这个时候不用怕，看不懂没关系，你只要知道他是要让你们登录（login），或者 申请账号（sign up）个就行了，登录或者申请成功后就会开始下载。（记住密码要字母和数字组合，字母要有大写）
3. 3
c.注意：密码要字母和数字组合，字母要有大写字母
4. 4
d.当然你如果有账户的话，也可以直接登录进去
5. 5
成功后点击DownNow。文件不大，才200多M，很快的，稍等一下（成功后按理说也是到达下面这个地方的，但假如不知这样的话，你自己找一下，或者直接退出来，重复以上步骤，选登录那个就是了。
6. 6
在多说一句，MySQL 是开源（open source）数据库，所谓开源就是可以查看源代码的，我相信很多童靴都会对这个感兴趣。那么在哪下源代码呢？
在刚进-(第一个图片那地址)的时候。有一个Select Platform，选择下面的source code就行。
（同理如果要下载linux平台下的MySQL也是在这找）
下载完毕，下面开始着手安装和配置
7. 7
第二大步：安装（解压）
ZIP Archive版是免安装的。只要解压就行了。和安装版的没什么不同，但就是不需要安装。找到下载好的mysql-x.x.xx-winx64.zip右键选择（解压到...），找到你想安装的地方，喜欢放C:盘的就选择C:盘，不喜欢的就自己选个就是了，小编喜欢放D：盘，毕竟c:系统盘放的东西太多不好。解压完就ok了，是不是很简单？知道 ZIP Archive版的好处了吧
8. 8
你是不是要问了？怎么用啊？\bin点里面的mysql。exe怎么出来一个黑窗口就没反应了？
没反应是因为服务还没开！
没开，是不是打开就好了？
服务还没安装！
怎么安装？
下面讲！
9. 第三大步：配置默认文件
其实理论上现在这样就可以直接安装服务了，但是因为是默认配置，我们使用的时候会出现很多问题。比如里面的汉字全是乱码之类的，所以建议你先配置一下默认文件。在mysql-x.x.xx-winx64（小编的是5.6.17根据自己的版本来定）目录下，新建个my.ini。复制下面的代码保存就ok了。my.ini会替换掉下面的my-default.ini文件。.ini文件是window里面的配置文件。保存里面各种默认的数据。安装版的是在安装的时候让你自己选然后系统给你保存进来，zip archive是自己写，都一样。里面的代码语法是什么意思童鞋们自己查相关资料吧。毕竟我一两句话说不清。这个文件在软件运行时加载。
10. 代码：（把里面D:\mysql\mysql-5.6.17-winx64改成你自己的软件路径，保存）
[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8 [mysqld]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e18ccc59781ce853385571d3878494/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/839d5f1e0c75b44922379089ecaaa2e2/" rel="bookmark">
			动态input text 取值（动态id）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;input type="text" size="5" id="score"/&gt; &lt;input type="button" value="评分" οnclick="addScore(this.id);" id="${userLesson.id}"/&gt;
function(id){
$("#score").val() ;
}
动态生成的input text ，若想用jquery $("#score").val() 取值，
会发现如果只有一个那可以顺利取到，如果有多个就不能顺利取到值，
我想大概是因为id 相同的原因，若id 改为动态&lt;input type="text" size="5" id="${userLesson.id}"/&gt; 估计能够解决此问题
但是我这个id 还不能传到js中， 所以此方法行不通，
后来找到此解决方法
&lt;input type="text" size="5" id="score"/&gt;
&lt;input type="button" value="评分" οnclick="addScore(this.id,this);" id="${userLesson.id}"/&gt;
function addScore(id,obj){
var o=$(obj);
var score = o.prev().val();
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8a21a94e0b9b1664a626788d1b97c0b/" rel="bookmark">
			python中mock的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查了很多资料，很多资料都是把mock跟unittest结合在一起讲的，unittest本身是有一定难度的，其实我们完全可以单独使用mock的。参考文献1中把mock讲的很详细，只要静下心来看，必定收获很多，感谢译者的辛勤付出！参考文献2中有个pdf文档，是最详细的官方文档，大概100页，也很不错，没有深入读了，以后用到了再在这篇博客里更新。 我现在主要是在nose框架下使用的mock，mock主要有name，return_value,side_effect,和spec四个函数，其中的意义都看下面的文档吧。 四个主要的assert方法： assert_called_with 是否调用了这个函数 assert_called_once_with 是否只调用了一次这个函数 assert_has_calls 查看方法调用的顺序 assert_any_calls 是否调用了这个函数，前两个函数只能判断离它们最近的一次调用，这个是全局的。 参见代码： from mock import Mock, call class Order(object): # instance properties _orderItem = "None" _orderAmount = 0 _orderFilled = -1 # Constructor def __init__(self, argItem, argAmount): print "Order:__init__" # set the order item if (isinstance(argItem, str)): if (len(argItem) &gt; 0): self._orderItem = argItem # set the order amount if (argAmount &gt; 0): self._orderAmount = argAmount # Magic methods def __repr__(self): # assemble the dictionary locOrder = {'item':self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8a21a94e0b9b1664a626788d1b97c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/345c415da8c0d2b5c045f8bf7c2ca52b/" rel="bookmark">
			MySql通过数据库文件恢复数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以表”Table”为例:
如类型是MyISAM, 数据文件则以”Table.frm””Table.MYD””Table.MYI””三个文件存储于”/data/$databasename/”目录中.
如类型是InnoDB, 数据文件则存储在”$innodb_data_home_dir/″中的ibdata1文件中(一般情况)，结构文件存在于table_name.frm中.
MySQL的数据库文件直接复制便可以使用，但是那是指“MyISAM”类型的表。
而使用MySQL-Front直接创建表，默认是“InnoDB”类型，这种类型的一个表在磁盘上只对应一个“*.frm”文件，不像MyISAM那样还“*.MYD,*.MYI”文件。
MyISAM类型的表直接拷到另一个数据库就可以直接使用，但是InnoDB类型的表却不行。解决方法就是:
同时拷贝innodb数据库表“*.frm”文件和innodb数据“ibdata1”文件到合适的位置。启动MySQL的Windows服务
由于MySQL这样数据混杂的形式, 往往很容易让使用者在备份时忘记了备份InnoDB, 从而导致了上述错误.
意思就是说在数据库引擎类型为InnoDB时，拷贝数据文件的同时还需要拷贝ibdata1，于是把ibdata1也拷贝过去覆盖，发现还是有点问题，于是停止mysql服务，将目录下的ib_logfile*文件全部删除掉，重新启动mysql服务，well done，可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda4f6c27ccfad86e73b3498b1a6ed7e/" rel="bookmark">
			使用ajaxSubmit方法实现多文件上传(异步)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、上传按钮
&lt;button οnclick="toImport()" class="btn green"&gt;导入&lt;i class="icon-upload-alt"&gt;&lt;/i&gt;&lt;/button&gt; 2、文件选择弹出层和添加组件的html代码 &lt;div id="import_modal" class="modal hide fade"&gt;&lt;formaction="${pageContext.request.contextPath }/**/importFile!impXLS.do"id="ajax_form" class="form-horizontal"&gt;&lt;div class="modal-header"&gt;&lt;button type="button" class="close cancelUpload"data-dismiss="modal" aria-hidden="true"&gt;&lt;/button&gt;&lt;h3&gt;文件导入&lt;/h3&gt;&lt;/div&gt;&lt;div class="modal-body form"&gt;&lt;div class="alert alert-error hide"&gt;&lt;button class="close" data-dismiss="alert"&gt;&lt;/button&gt;&lt;span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class="control-group"&gt;&lt;label class="control-label"&gt;&lt;/label&gt;&lt;div class="controls"&gt;&lt;span style="color:red"&gt;*注：上传文件个数不能超过5个&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="control-group"&gt;&lt;label class="control-label"&gt;选择文件：&lt;/label&gt;&lt;div class="controls"&gt;&lt;div class="fileupload fileupload-new" data-provides="fileupload"&gt;&lt;div class="input-append"&gt;&lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda4f6c27ccfad86e73b3498b1a6ed7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7caf9ed480b9c04743c09b2534991079/" rel="bookmark">
			混合推荐总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 混合推荐系统是推荐系统的另一个研究热点，它是指将多种推荐技术进行混合相互弥补缺点，从而可以获得更好的推荐效果。 最常见的是将协同过滤技术和其他技术相结合，克服cold start的问题。 （1）加权型 就是将多种推荐技术的计算结果加权混合产生推荐。 最简单的方式是线性混合，首先将协同过滤的推荐结果和基于内容的推荐结果赋予相同的权重值，然后比较用户对项的评价与系统的预测是否相符，然后调整权重值。 加权型混合方式的特点是整个系统性能都直接与推荐过程相关，这样一来就很容易在这之后斤西瓜信任分配和调整相应的混合模型，不过这种技术有一个假设的前提是对于整个空间中所有可能的项，使用不同技术的相关参数值都基本相同。 （2）转换型 根据问题背景和实际情况采用不同的推荐技术。 比如，使用基于内容推荐和协同过滤混合的方式，系统首先使用基于内容的推荐技术，如果它不能产生高可信度的推荐，然后再尝试使用协同过滤技术。 因为需要各种情况比较转换标准，所以这种方法会增加算法的复杂度和参数化，当然这样做的好处是对各种推荐技术的优点和弱点比较敏感。 （3）合并型 同时采用多种推荐技术给出多种推荐结果，为用户提供参考。 比如，可以构建这样一个基于web日志和缓存数据挖掘的个性化推荐系统，该系统首先通过挖掘web日志和缓存数据构建用户多方面的兴趣模式，然后根据目标用户的短期访问历史与用户兴趣模式进行匹配，采用基于内容的过滤算法，向用户推荐相似网页，同时，通过对多用户间的系统过滤，为目标用户预测下一步最有可能的访问页面，并根据得分对页面进行排序，附在现行用户请求访问页面后推荐给用户。也就是“猜你喜欢可能感兴趣的网页”。 （4）特征组合 将来自不同推荐数据源的特征组合起来，由另一种推荐技术采用。 一般会将协同过滤的信息作为增加的特征向量，然后在这增加的数据集上采用基于内容的推荐技术。 特征组合的混合方式使得系统不再仅仅考虑协同过滤的数据源，所以它降低了用户对项目评分数量的敏感度，相反的，它允许系统拥有项的内部相似信息，其对协同系统是不透明的。 （5）瀑布型 后一个推荐方法优化前一个推荐方法：它是一个分阶段的过程，首先用一种推荐技术产生一个较为粗略的候选结果，在此基础上使用第二种推荐技术对其作出进一步精确地推荐。 瀑布型允许系统对某些项避免采用低优先级的技术，这些项可能是通过第一种推荐技术被较好的予以区分了的，或者是很少被用户评价从来都不会被推荐的项目。 因为瀑布型的第二步，仅仅是集中在需要另外判断的项上。另外，瀑布型在低优先级技术上具有较高的容错性，因为高优先级得出的评分会变得更加精确，而不是被完全修改。 （6）特征递增型 前一个推荐方法的输出作为后一个推荐方法的输入。 比如，你可以将聚类分析作为关联规则的预处理，首先对会话文件进行聚类，再针对每个聚类进行关联规则挖掘，得到不同聚类的关联规则。当一个访问会话获得后，首先计算该访问会话与各聚类的匹配值，确认其属于哪个聚类，再应用这个聚类对应的关联规则进行推荐。 这个类型和瀑布型的不同点在哪里呢？ 在特征递增型中，第二种推荐方法使用的特征包括了第一种的输出。 而在瀑布型中，第二种推荐方法并没有使用第一种产生的任何等级排列的输出，其两种推荐方法的结果以一种优化的方式进行混合。 （7）元层次型 用一种推荐方法产生的模型作为另一种推荐方法的输入。 这个与特征递增型的不同在于： 在特征递增型中使用一个学习模型产生某些特征作为第二种算法的输入，而在元层次型中，整个模型都会作为输入。 比如，你可以通过组合基于用户的协同过滤和基于项目的协同过滤算法，先求解目标项目的相似项目集，在目标项目的相似项目集上再采用基于用户的协同过滤算法。这种基于相似项目的邻居用户协同推荐方法，能很好地处理用户多兴趣下的个性化推荐问题，尤其是候选推荐项目的内容属性相差很大的时候，该方法性能会更好。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed8e28b172b0afb7f0fc5d24a3d453c/" rel="bookmark">
			Android多线程及异步任务消息处理机制(一)--Handler的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处：http://blog.csdn.net/yegongheng/article/details/38845953
前言 我们知道，不管在任何的语言或操作系统平台(Android系统也不例外)，多线程、多进程和异步任务的相关技术地讨论都是永恒的话题，很多的开发需求都需要使用多线程及异步任务以便实现多任务的同时执行和灵活的用户操作界面，而很多系统在使用过程中出现诸多莫名其妙的问题，都是由于开发人员使用多线程不当造成的，因此掌握在各个平台上的多线程及异步任务的原理和使用方法非常有必要。那从今天开始，我们将通过一系列的博文来学习在Android平台上的多线程以及异步任务的特点及使用方法，并一步步深入其源码，了解其实现机制。
Handler的概念 每个Android应用程序都运行在单独的Davlik虚拟机中，当进程开启时会自动启动一个主线程(Main Thread)，主线程主要负责与UI相关事件的交互，因此我通常将主线程又称之为UI线程。由于Android采用UI单线程模型，一般情况下，当应用程序执行比较耗时的操作时(例如文件读写、数据库操作和音频视频得下载等)，为了防止由于线程执行时间过长而产生的UI线程阻塞，从而导致应用程序出现ANR(Application not response)的情况，我们通常会将该耗时操作放在新建的一个子线程中执行。但是因为UI是非线程安全的，我们又不能在子线程中对操作的结果进行UI元素的更新，只能在UI线程中进行，那怎么办呢？别急，Android类库提供的Handler类很好的解决了该问题。接下来我们将详细讲解Handler消息处理机的使用方法和原理：
概念：Handler是Android类库提供的用于接受、传递和处理消息或Runnable对象的处理类，它结合Message、MessageQueue和Looper类以及当前线程实现了一个消息循环机制，用于实现任务的异步加载和处理。下面有一张用于描述消息循环处理机制的关系图，如下：
上面这一张消息处理机制的关系图清晰地描述了使用Handler实现消息任务的异步加载和处理的一个整体流程，其中还涉及到了除Handler类之外的Message、MessageQueue和Looper类。那为了更进一步地使读者了解其中运行原理，我们来看看Handler、Message、MessageQueue和Looper这几个类的作用，如下：
Handler:将Message或Runnable对象传递到MessageQueue中，接收从MessageQueue分发出来的Message或Runnable对象；
MessageQueue:用于存放Message或Runnable对象的消息队列。它由对应的Looper对象创建，并由Looper对象管理；
Message：消息体，用于装载需要发送的对象；
Looper：循环不断地管理MessageQueue接收和分发Message或Runnable的工作。
了解了这些类的作用后，我们再来学习下它们之间有哪些关系。首先要明白的是，Handler和Looper对象是属于线程内部的数据，不过也提供与外部线程的访问接口，Handler就是公开给外部线程的接口，用于线程间的通信。Looper是由系统支持的用于创建和管理MessageQueue的依附于一个线程的循环处理对象，而Handler是用于操作线程内部的消息队列的，所以Handler也必须依附一个线程，而且只能是一个线程。基本了解了这四个类的各自职责和相互之间的关系后，我们再使用文字来描述一下整体消息处理机制的运行流程：
当应用程序开启时，系统会自动为UI线程创建一个MessageQueue(消息队列)和Looper循环处理对象，用户通过在UI线程创建的Handler不断地将Message(消息)或Runnable对象传递到MessageQueue中，Looper循环处理对象在系统的支持下管理着MessageQueue对Message或Runnable的接收和分发，另外Handler也接收从MessageQueue分发出来的特定的Message或Runnable对象。通俗地来讲，一般我们在实际的开发过程中用的比较多一种情况的就是主线程的Handler将子线程中处理过的耗时操作的结果封装成Message(消息),并将该Message(利用主线程里的MessageQueue和Looper)传递到主线程中，最后主线程再根据传递过来的结果进行相关的UI元素的更新，从而实现任务的异步加载和处理，并达到线程间的通信。
Handler的用途 通过上一小节对Handler的一个初步认识后，我们可以很容易总结出Handler的主要用途，下面是Android官网总结的关于Handler类的两个主要用途： (1)线程间的通信
在执行较为耗时的操作时，Handler负责将子线程中执行的操作的结果传递到UI线程，然后UI线程再根据传递过来的结果进行相关UI元素的更新。(上面已有说明)
(2)执行定时任务
指定任务时间，在某个具体时间或某个时间段后执行特定的任务操作，例如使用Handler提供的postDelayed(Runnable r,long delayMillis)方法指定在多久后执行某项操作，比如当当、淘宝、京东和微信等手机客户端的开启界面功能，都是通过Handler定时任务来完成的。 Handler的使用实例 上面我们学习Handler概念时讲了Handler和Looper是属于线程内部的数据，意思就是说每一个实例化的Handler和Looper的对象都是依附于一个线程，这里称为宿主线程。我们知道， Android应用程序是通过消息来驱动的，系统为每一个应用程序维护一个消息队列，应用程序的主线程不断地从这个消息队例中获取消息（Looper），然后对这些消息进行处理（Handler），这样就实现了通过消息来驱动应用程序的执行。我们在启动应用程序时，系统会自动为UI线程创建Looper对象和MessageQueue，用于接受、管理和分发不同消息。而对于其它非UI线程来讲，就必须要手动创建了。 废话不多说，先来总结一下使用Handler实现异步消息处理的编程步骤，一般分为如下6个步骤： (1)调用Looper.prepare()方法，实例化Looper和MessageQueue对象；(系统自动主线程创建，此步骤省略) (2)实例化Handler对象，并重写对象中的handleMessage()方法，用于处理Looper对象分发过来的消息； (3)实例化Message对象，并将需要传递的结果对象添加到Message对象中； (4)调用目标Handler对象的sendMessage(Object obj)等方法，将Message传递到MessageQueue中； (5)调用Looper.loop()方法，启动消息循环管理；(UI线程会自动自动启动loop()方法，此步骤省略) (6)在handleMessage()中接收Looper对象分发过来的消息(Message)，并执行相关操作UI线程更新等操作。 我们下面来做几个实验，通过在不同线程中创建Looper和Handler，然后利用它们来实现异步消息的处理，看一下运行的结果，以便我们在后面的学习中更好地理解异步任务消息处理机制的实现原理。我们将做如下几个实例： (1)在主线程中创建Handler和Looper对象，并使用它们执行异步任务的操作； (2)在子线程中创建Handler对象，在主线程创建Looper，并使用它们执行异步任务的操作； (3)在子线程中创建Handler和Looper对象，并使用它们执行异步任务的操作； (4)使用Handler对象的定时任务的功能实现APP首页欢迎界面的功能。 下面是实例的主界面，如图： 接下来我们实现代码，实现代码的步骤按照上面所罗列出的编码步骤实现。首先看下主界面MainActivity.java的代码(源代码在文末尾可下载)，如下： public class MainActivity extends Activity{ private ImageView mImageView ; private static final String TAG = "androidleaf"; private String urlStr = "https://img-my.csdn.net/uploads/201408/25/1408936379_4781.png" ; @Override protected void onCreate(Bundle savedInstanceState) { // TODO Auto-generated method stub super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ed8e28b172b0afb7f0fc5d24a3d453c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b4d416ba34cc9db4dbcac94d3dcee3/" rel="bookmark">
			哪些数据适合放在二级缓存中？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 哪些数据适合放在二级缓存中？
二级缓存是一级缓存的缓冲器，一级缓存用于暂时存储并向CPU递送各类运算指令。二级缓存的作用是存储那些CPU处理时需要用到、一级缓存又无法存储的数据。
在程序中的表现形式：一级缓存就是session级别的缓存，因为hibernate中的session存有数据的备份，同一个session再次访问该数据时是首先通过该备份去查找的，如果查找不到的话，才会去硬盘或者数据库当中查找的；
二级缓存是sessionFactory级别的缓存，在一个数据库中只有一个sessionFactory而次缓存即为所有session缓存的共同体，包含所有一级缓存中的对象，如果二级缓存打开的话，一级缓存查找数据的时候，会首先去二级缓存当中查找的。
适合存放在二级缓存中的数据：
很少被修改，不是很重要的数据，允许出现偶尔的并发问题 不适合放入二级缓存中的数据：
经常被修改，财务数据，绝对不允许出现并发问题，与其他应用数据共享的数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2fbbe36cf6d9b6fb034e50d1d53b714/" rel="bookmark">
			1151Word Reversal ACM题答案 java版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.Scanner;
public class WordReversal1151 {
static int N = 0;// N个输入块
static int num;// 每个输入块里有多少句话
static String blank_line;
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
N = sc.nextInt();
for (int i = 0; i &lt; N; i++) {
num = sc.nextInt();
blank_line=sc.nextLine(); //因为跟在num之后的是半截空行，要去掉
for (int j = 0; j &lt; num; j++) {
String sen = sc.nextLine();
reversal(sen);
}
//输出块之间的空行
if(i!=N-1)//最后一块不要输出空行，不然会报Presentation Error错误
System.out.println();
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2fbbe36cf6d9b6fb034e50d1d53b714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e419da6944dd5e5aa7405f903d59b579/" rel="bookmark">
			评估指标：准确率(Precision)、召回率(Recall)以及F值(F-Measure)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了能够更好的评价IR系统的性能，IR有一套完整的评价体系，通过评价体系可以了解不同信息系统的优劣，不同检索模型的特点，不同因素对信息检索的影响，从而对信息检索进一步优化。
由于IR的目标是在较短时间内返回较全面和准确的信息，所以信息检索的评价指标通常从三个方面考虑：效率、效果和其他如数据规模。
下面简单介绍几种常用的信息检索评价指标：
1、准确率与召回率（Precision &amp; Recall）
精度和召回率是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。其中精度是检索出相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率；召回率是指检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率。
一般来说，Precision就是检索出来的条目（比如：文档、网页等）有多少是准确的，Recall就是所有准确的条目有多少被检索出来了。
正确率、召回率和 F 值是在鱼龙混杂的环境中，选出目标的重要评价指标。不妨看看这些指标的定义先：
1. 正确率 = 提取出的正确信息条数 / 提取出的信息条数 2. 召回率 = 提取出的正确信息条数 / 样本中的信息条数 两者取值在0和1之间，数值越接近1，查准率或查全率就越高。 3. F值 = 正确率 * 召回率 * 2 / (正确率 + 召回率) （F 值即为正确率和召回率的调和平均值）
不妨举这样一个例子：某池塘有1400条鲤鱼，300只虾，300只鳖。现在以捕鲤鱼为目的。撒一大网，逮着了700条鲤鱼，200只虾，100只鳖。那么，这些指标分别如下：
正确率 = 700 / (700 + 200 + 100) = 70%
召回率 = 700 / 1400 = 50%
F值 = 70% * 50% * 2 / (70% + 50%) = 58.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e419da6944dd5e5aa7405f903d59b579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16b2148b6451acf61161c7920cc76a9d/" rel="bookmark">
			Java并发编程系列博文目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【Java并发编程】线程的概念及简单实现；【Java并发编程】线程的状态、分类及优先级； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7238c834073fbe0013807f4742e7b106/" rel="bookmark">
			Apache安全配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vi /etc/httpd/conf/httpd.conf #编辑文件
ServerTokens OS　在44行修改为：ServerTokens Prod （在出现错误页的时候不显示服务器操作系统的名称）
ServerSignature On　在536行修改为：ServerSignature Off （在错误页中不显示Apache的版本）
Options Indexes FollowSymLinks　在331行修改为：Options Includes ExecCGIFollowSymLinks（允许服务器执行CGI及SSI，禁止列出目录）
#AddHandlercgi-script .cgi　在796行修改为：AddHandlercgi-script .cgi .pl（允许扩展名为.pl的CGI脚本运行）
AllowOverride None　在338行修改为：AllowOverride All （允许.htaccess）
AddDefaultCharset UTF-8　在759行修改为：AddDefaultCharset GB2312　（添加GB2312为默认编码）
Options Indexes MultiViewsFollowSymLinks 在554行修改为 Options MultiViewsFollowSymLinks（不在浏览器上显示树状目录结构）
DirectoryIndex index.html index.html.var 在402行修改为：DirectoryIndex index.html index.htm Default.html Default.htm
index.phpDefault.phpindex.html.var （设置默认首页文件，增加index.php）
KeepAlive Off 在76行修改为：KeepAlive On （允许程序性联机）
MaxKeepAliveRequests 100 在83行修改为：MaxKeepAliveRequests 1000 （增加同时连接数） :wq! #保存退出
/etc/init.d/httpd restart #重启
rm -f /etc/httpd/conf.d/welcome.conf /var/www/error/noindex.html #删除默认测试页
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7238c834073fbe0013807f4742e7b106/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68534e5150cdd8ee1dcbeb89c06d19c1/" rel="bookmark">
			压力测试tps性能下降问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压力测试tps性能下降问题解决方案 背景 测力测试时反映tps一直下滑的问题，为了重现该问题，开发一个简单交易进行测试，测试代码如下
录制该交易脚本，并放在LoadRunner11中进行测试，场景为10个用户同时启动并持续的跑。可以看到1分钟之后tps开始下降，并在后期持续下降。
此时分析服务端日志、javacore、heapdump、gc等，并未发现异常现象。修改服务端线程池相关等，但测试结果却是一如既往的下滑。记录服务端处理请求时间，发现一直很稳定，初步怀疑是客户端压力不够导致，但一直无具体证据，因此压测tps下滑问题一度搁置。
转折点 本周一时，一同事开始做压力测试，交流这个问题后，那边现场也开始了类似测试，但测试结果如出一辙。后来广发使用了LoadRunner中的按进程运行vuser，测试效果如下。可以看到，整个过程跑了3个小时，tps一直稳定在950左右，这下总算有了突破口。
分析 LoadRunner中按进程运行vuser与按线程运行vuser跑出来的结果竟然会有那么大区别，那么他们两者的结果为什么差别那么大呢。
LoadRunner中对这两种分别是这样说明的：
Ø 按线程运行vuser
启动多线程以便每台负载生成器计算机运行更多的vuser。
Ø 按进程运行vuser
禁用多线程并将每个vuser作为完整的进程运行。用于非线程安全协议
网上对于两者有这样的解释：
线程的资源是从进程资源中分配出来的，因此同一个进程中的多个线程会有共享的内存空间
那么回过头来使用神器javavisualvm查看下使用按线程运行vuser时mdrv.exe(lr跑vuser的程序)进程的内存使用情况，可以看到运行7分钟时间内fullgc执行了94次，仔细看下可以发现新生代为896k+64k*2=1024k,最大4992k，年老代为4m，最大59.125m。此时猜想为jvm内存分配太小导致的
调优 现在调整下虚拟机内存并使用同样的场景进行测试，jvm参数与测试结果如下：
Jvm参数：-Xmn128m -Xmx384m -Xms384m-XX:PermSize=64m -XX:MaxPermSize=128m
果然和猜想的一样，测试期间稳定运行，下面为本次的内存使用截图
可以看到年老代内存使用一直稳定在1.457m，持久代内存一直稳定在5.616m，
整个过程没有进行fullgc，垃圾回收全部在年轻代。
基于本次测试，继续调整基于本场景下的虚拟机参数，增大年轻代，缩小年老代与持久代。并使用同样的场景进行测试，jvm参数与测试结果如下：
Jvm参数：-Xmn320m -Xmx384m -Xms384m -XX:PermSize=12m -XX:MaxPermSize=12m
继续看测试过程中内存使用情况。
可以看到运行1:40期间，年轻代执行gc 2304次，耗时45.703s，相对于上次测试的运行1:10，年轻代执行gc 3228次，耗时35.965s，有一定的提升。
结论 此次发现的压力测试tps持续下降问题并非由服务端和客户端处理性能导致，而是由压测客户端内存分配不合理导致。
后续测试时如出现类似情况可选取按进程运行vuser，也可根据实际运行交易场景进行内存参数调整，保证后续测试正常进行。
附 按进程运行vuser时其中一个进程的内存使用截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7fe66e9faf244fbd72fe63b97d77a4/" rel="bookmark">
			线程的状态、分类及优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转转请注明出处：http://blog.csdn.net/yegongheng/article/details/38708765
上一篇《线程的概念及简单实现》博文我们简单地认识了关于多线程的概念以及使用Java语言实现多线程，这算是我们对Java并发编程学习的一个入门吧，那本篇博文我们将继续更深入地学习多线程方面的知识。
线程的状态 同样的，线程作为一项任务的执行者，从开启、运行到终结、销毁，都有它自己的生命周期。那在Java定义中，一般线程可以分为六种状态,我们通过查看Thread类源码发现，在Thread类中定义了一个线程状态的枚举，代码如下： public enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * ... */ RUNNABLE, /** * ... */ BLOCKED, /** * ... */ WAITING, /** *... */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; } 下面我们对每一种线程状态进行简要的说明： 1. 新生(New)：在Java中使用new Thread(r)来创建一个新的线程，此时线程处于新生的状态，但是程序还没有开始运行线程的代码； 2. 可运行(Runnable)：在Java中当调用start()方法后，线程进入了可运行的状态，此时线程可能正在运行，也可能没有运行，这个取决于CPU是否给当前线程提供了时间片； 3. 阻塞(Blocked)：一般在如下情况下，线程会处于阻塞状态：当线程想要获取内部的对象锁，而该锁被其它线程持有，此时线程陷入阻塞； 4. 等待(Wait)：当线程调用Thread.join()方法将CPU的执行权力(即时间片执行权力)出让给其它线程时或调用wait()方法让当前线程等待其它线程资源执行时，线程处于等待状态。阻塞状态和等待状态的区别还是比较大的。 5. 计时等待(Timed waiting)：计时等待和上面所说的等待状态类似，不同的是计时等待是在其所设置的超时时间后从等待状态自动自我唤醒，然后进入到可运行状态，而前者是需要其它线程进行手动唤醒。那一般设置定时等待的方法有sleep(long millis)、wait(long timeout)或join(long millis)。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb7fe66e9faf244fbd72fe63b97d77a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc565711c902225e4db8b1fddbb0bcb/" rel="bookmark">
			DXUT 初步学习 框架初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初识DXUT 什么是DXUT 这个概念性的东西，不同的人不同的理解，总的来说还是比较简单的D3D小框架，对D3D的一个简单的封装，可以理解成一个类库。微软作用，可以更好的展示D3D的功能和新发布的特性；游戏开发者作用，可以更快更轻巧的展示模型结果，检验算法效果；学习者作用，可以是一个入门的精巧例子，由于D3D的例子大部分都是利用DXUT的，所以可以更快的学习D3D SDK中的例子，加速学习过程。
现在的DXUT 现在的DXUT主要有D3D9 D3D10和D3D11三个版本，可以看出来D3DX的版本是跟着SDK的，到了D3D11 的DXUT就是一个额外的部分的，不随着SDK一起发布了，这个是后话，现在一般还是有的。这篇入门级别的文章还是D3D9的。
架构浅解 dxut库 打开sdk 里面的例子可以看到DXUT,进入dxut那么就会看见两个目录，core 和optional。意思是很明白的，一个是dxut的核心部分，一个是dxut的可选部分，我们的文章现在只是关注核心的这一部分。打开core里面的工程，如果没有什么配置问题，直接编译就会生成dxut的静态库。dxut.lib这个就是牛气轰轰的dxut核心库了。我们可以在项目中加入头文件和生成的库来构建程序，也就是使用了dxut。我没有发现dxut封装到dll中的可能，因为里面的函数没有导入和导出关键字，也就是说，现在的dxut仅支持静态链接。可选库也可以这样子获得，不过这篇文章没有这样做。
dxut代码 我们也可以不用库，直接在项目中加入dxut的源代码，代价就是编译时间长一些罢了，但是，不符合库的思想而已。
dxut运行过程 dxut先配置一些回调函数，然后就是主函数的实际操作进入消息循环。就这么简单，客户要使用这些功能就是在各种回调函数里面编写代码。说的挺简单的，但是要想真的学习dxut这个类库，还是需要熟练记住一些函数的，是的，我们编程不要求死记硬背，但是你花费半个小时去背一些主要函数你就会发现自己对库的理解不仅仅一丁半点了。理解这段话需要有一定的win32和d3d基础。
应用练习 配置目录 配置d3d和dxut的头文件目录。d3d头文件目录在sdk中，dxut的头文件目录是自己创建的，将core下的头文件添加上就可以了。配置库目录，d3d库目录还是在sdk中，dxut的库目录还是自己创建的，将生成的dxut.lib加入就可以了。至于如何配置这些目录就是项目属性里面找了。
程序代码 #pragma once //win32 #pragma comment(lib,"comctl32.lib") //d3d #pragma comment(lib,"dxerr.lib") #pragma comment(lib,"d3dx9.lib") //dxut #pragma comment(lib,"dxut.lib") //dxut #include"DXUT.h" HRESULT CALLBACK OnDeviceCreate( IDirect3DDevice9* pd3dDevice, const D3DSURFACE_DESC* pBackBufferSurfaceDesc, void* pUserContext ); void CALLBACK OnDeviceDestroyed( void* pUserContext ); void CALLBACK OnFrameRender( IDirect3DDevice9* pd3dDevice, double fTime, float fElapsedTime, void* pUserContext ); void SetUpMatrix( IDirect3DDevice9* pd3dDevice); void SetupLight( IDirect3DDevice9* pd3dDevice); //TODO: global variables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc565711c902225e4db8b1fddbb0bcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b09a6cbaaa1868184e63772aadf8c2/" rel="bookmark">
			loadpe给程序添加导入表的时候
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会loadlibrary一下dll，如果dllmain中发生异常了的话可能导致失败。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ea5b89ddd4aace9e6d28d72fbdf87c/" rel="bookmark">
			进程同步，进程锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 进程同步方式
HANDLE hMutex = CreateMutex(NULL, FALSE, "xiaoyu2"); //创建有名互斥量
if (NULL == hMutex)
{
cout &lt;&lt; "create mutex fail" &lt;&lt; endl;
}
DWORD dwErrno = GetLastError();
bool bClient = false;
if (ERROR_ALREADY_EXISTS == dwErrno)
{
cout &lt;&lt; "mutex already exist." &lt;&lt; endl;
CloseHandle(hMutex);
hMutex = OpenMutex(SYNCHRONIZE, FALSE, "xiaoyu2");
bClient = true;
}
while(1)
{
Sleep(1000);
cout &lt;&lt; "wait to get mutex" &lt;&lt; endl;
WaitForSingleObject(hMutex, INFINITE); //一个进程获得后，在它Release之前，其他进程无法获得
cout &lt;&lt; "get mutex"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4ea5b89ddd4aace9e6d28d72fbdf87c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac57b82c7134f9a4a2e36099dd1d5e3/" rel="bookmark">
			C&#43;&#43;编程-&gt;pair（对组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pair 是 一种模版类型。每个pair 可以存储两个值。这两种值无限制，可以是tuple，vector ，string，struct等等。
首先来看一下pair的函数
初始化，复制等相关操作如下：
default (1) constexpr pair(); copy / move (2) template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr); template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr); pair (const pair&amp; pr) = default; pair (pair&amp;&amp; pr) = default; initialization (3) pair (const first_type&amp; a, const second_type&amp; b); template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b); piecewise (4) template &lt;class... Args1, class... Args2&gt; pair (piecewise_construct_t pwc, tuple&lt;Args1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ac57b82c7134f9a4a2e36099dd1d5e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd9c63adcde302ccdc399d49a9b4762e/" rel="bookmark">
			qemu迁移使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址：qemu 迁移使用方法 作者：志坚苦行 迁移是qemu中支持的，libvirt只是封装好命令并传递给qemu的监控模块。 1、qemu中使用方法： 在server端，在启动qemu的命令行中加入-incomingtcp:0:4444(4444为端口）参数，启动后可以应用netstat -apn 命令查看，4444端口是不是在监听。 在client端，启动qemu后（sdl模式下）， 使用ctrl+alt+2切换到监视端口，输入命令:migrate -dtcp:10.10.10.1:4444。（可以使用info migrate 查看migrate状态） 2、virsh中使用实例： migrateqemu://10.10.10.1/system （tls 模式） migrate qmeu+ssh://10.10.10.1/system （ssh 模式） migrate qmeu+tcp://10.10.10.1/system （tcp模式） 上面是静态迁移，其中tls模式需要加密和鉴权文件，详细操作见下面网址： http://wiki.libvirt.org/page/TLSSetup#Full_list_of_steps migrate --live qemu+ssh://10.10.10.1/system（动态迁移） 3、在virt-manager中，在虚拟机名字上右击鼠标右键，弹出的对话框中，有迁移一项，选上offline为静态迁移，不选为动态迁移。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d15bb26fe7f1820e2258f43991f95500/" rel="bookmark">
			wrap_content 和fill_parent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android fill_parent、wrap_content和match_parent的区别
（别处抄来做笔记用）
三个属性都用来适应视图的水平或垂直大小，一个以视图的内容或尺寸为基础的布局比精确地指定视图范围更加方便。
1）fill_parent
设置一个构件的布局为fill_parent将强制性地使构件扩展，以填充布局单元内尽可能多的空间。这跟Windows控件的dockstyle属性大体一致。设置一个顶部布局或控件为fill_parent将强制性让它布满整个屏幕。
2） wrap_content
设置一个视图的尺寸为wrap_content将强制性地使视图扩展以显示全部内容。以TextView和ImageView控件为例，设置为wrap_content将完整显示其内部的文本和图像。布局元素将根据内容更改大小。设置一个视图的尺寸为wrap_content大体等同于设置Windows控件的Autosize属性为True。
3）match_parent
Android2.2中match_parent和fill_parent是一个意思 .两个参数意思一样，match_parent更贴切，于是从2.2开始两个词都可以用。那么如果考虑低版本的使用情况你就需要用fill_parent了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2be3e0d39e370f738f86601685d21c8/" rel="bookmark">
			ios--UIImageView添加边框和阴影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		- (void)viewDidLoad { [super viewDidLoad]; //添加显示 UIImage *image = [UIImage imageNamed:@"0_wanggsx20080817.jpg"]; UIImageView *imageView = [[UIImageView alloc]initWithImage:image]; imageView.frame = CGRectMake(50, 100, 200, 300); //添加边框 CALayer * layer = [imageView layer]; layer.borderColor = [[UIColor redColor] CGColor]; layer.borderWidth = 5.0f; //添加四个边阴影 imageView.layer.shadowColor = [UIColor greenColor].CGColor;//阴影颜色 imageView.layer.shadowOffset = CGSizeMake(0, 0);//偏移距离 imageView.layer.shadowOpacity = 0.5;//不透明度 imageView.layer.shadowRadius = 10.0;//半径 // //添加两个边阴影 // imageView.layer.shadowColor = [UIColor blueColor].CGColor;//阴影颜色 // imageView.layer.shadowOffset = CGSizeMake(4, 4);//偏移距离 // imageView.layer.shadowOpacity = 0.5;//不透明度 // imageView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2be3e0d39e370f738f86601685d21c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c37d3f7c1355235c712c2578ee0e595/" rel="bookmark">
			关于Xcode5中使用脚本自动生成Doxygen注释在OS X 10.9中bug的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直以来，我一直使用脚本快速生成Doxygen风格的代码注释，方法见：IOS开发之—-Xcode4快速Doxygen文档注释
但是更新了OS X 10.9以后，我发现生成的注释带各种莫名的符号了，比如下面：
1 2 3 4 5 6 7 8 9 [ "" ] /** [""] * @brief &lt;#Description#&gt; [""] * [""] * @param value &lt;#value description#&gt; [""] * @param key &lt;#key description#&gt; [""] * [""] * @return &lt;#return value description#&gt; [""] */ - ( void )setPostValue:(id &lt;NSObject&gt;)value forKey:(NSString *)key; 而且void类型的返回也会带return。
于是在我用0基础的Ruby看了下，判断下应该是ruby版本更新以后scan函数返回从一维数组变成二维数组导致的。
修改的方法就是把代码中所有的matches[0]替换为matches[0][0]
Test：
1 2 3 4 5 6 7 /** * @brief &lt;#Description#&gt; * * @param value &lt;#value description#&gt; * @param key &lt;#key description#&gt; */ - ( void )setPostValue:(id &lt;NSObject&gt;)value forKey:(NSString *)key; Mession Complete!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c37d3f7c1355235c712c2578ee0e595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4850c156797bcc53fbab40a6feb5c945/" rel="bookmark">
			svn图标不显示的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现svn图标莫名其妙的不显示，其他操作都正常。在网上搜了一些方法。
解决方法一（失败）：
升级最新版本，我的本来就是最新版本
解决方法二（失败）：
右键-&gt;TortoiseSVN-&gt;setting-&gt;Icon Overlays-&gt;Status cache-&gt;default/Shell。none是不显示
解决方法三（失败）：
修复或者卸载重装
解决方法四（成功）：
Windows Explorer Shell 支持 Overlay Icon 最多15个，Windows 自身已经使用了4个，所以就只剩下了11个 供我们使用。如果你之前安装了例如Groove这样的软件，那么可能我们可利用的就更少了，轮不到Tortoise了。像这样的情况，我们可以调整 Tortoise图标名称的字母顺序，来提高Tortoise的优先位置，因为Windows 内部就是安装名称的字母顺序来优先显示的。 解决的步骤 在 运行里 输入 regedit 进入 注册表 界面，HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;Microsoft-&gt;Windows-&gt;CurrentVersion-&gt;Explorer-&gt;ShellIconOverlayIdentifiers打开后发现Tortoise 系列（1TortoiseNormal，2TortoiseAdded等）前面有好多项，Tortoise 系列排到了15名之后，难怪不显示。现在的任务就是把它们提到前面了，修改一下它们的名字就好（我是看第一项的前缀是空格，说明空格的字符排序在前面，我就加了几个空格），我改后的名字如（ TortoiseNormal， TortoiseAdded等），然后关闭再打开注册表，发现Tortoise 系列系列图标已经排到前面了，这时SVN的图标并没有显示，靠，重启Explorer（在任务管理器中结束explorer.exe，在文件 -&gt; 新建任务 -&gt; 输入explorer，当然可以重启电脑，不过好sb），这样就ok了，可爱的SVN图标又出现了。
总结：
原因可能是因为我安装了好多的同步网盘（金山快盘，酷盘，everbox，百度网盘，dropbox等）占用了15 Overlay Icon，怪不得有的同步网盘的状态图标不显示呢。但是这样SVN的图标是显示了，但是肯定其他什么软件的图标又会不显示了。
转载自http://www.cnblogs.com/likebeta/archive/2012/07/01/2571731.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01660a31386eab831e27f311c17404aa/" rel="bookmark">
			ARM汇编编程基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(一) -- ARM CPU寄存器
本系列文章节选自本人所著《深入浅出嵌入式底层软件开发》。
本系列文章，所需代码请从以下地址下载:
http://download.csdn.net/download/scyangzhu/4602585
ARM的汇编编程，本质上就是针对ＣＰＵ寄存器的编程，所以我们首先要弄清楚ARM有哪些寄存器？这些寄存器都是如何使用的？
ARM寄存器分为2类，普通寄存器和状态寄存器，如表1-1所列。
表1 - 1 ARM寄存器
寄存器类别
寄存器在汇编中的名称
各模式下实际访问的寄存器
用户
系统
管理
中止
未定义
中断
快中断
通用寄存器和程序计数器
R0(a1)
R0
R1(a2)
R1
R2(a3)
R2
R3(a4)
R3
R4(v1)
R4
R5(v2)
R5
R6(v3)
R6
R7(v4)
R7
R8(v5)
R8
R8_fiq
R9(SB,v6)
R9
R9_fiq
R10(SL,v7)
R10
R10_fiq
R11(FP,v8)
R11
R11_fiq
R12(IP)
R12
R12_fiq
R13(SP)
R13
R13_svc
R13_abt
R13_und
R13_irq
R13_fiq
R14(LR)
R14
R14_svc
R14_abt
R14_und
R14_irq
R14_fiq
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01660a31386eab831e27f311c17404aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61243460ba22b06b976f667a3b9468b8/" rel="bookmark">
			阻止文件不被上传到iCloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IOS--阻止文件被iTunes和iCloud同步，Do Not Backup属性 (2013-01-14 10:28:06) 转载▼ 标签： 杂谈 分类： iphone开发 http://www.cocoachina.com/bbs/read.php?tid=86244 http://www.ooso.net/archives/617 http://blog.csdn.net/theonezh/article/details/7711749 https://gist.github.com/4527957 如何阻止文件被iTunes和iCloud同步 How do I prevent files from being backed up to iCloud and iTunes? iOS 5有了iCloud后，Apple更新了数据存储指导方针，以适应于iCloud存储，同时增加了“不要备份”文件属性，可以指定文件不备份和上传到iCloud 摘录如下，供大家参考： iOS 数据存储指导方针 iCloud 包括了备份，会通过Wi-Fi每天自动备份用户iOS设备。app的home目录下的所有东西都会被备份，除了应用Bundle本身、缓存目录和temp 目录。已购买的音乐、应用、书籍、Camera Roll、设备设置、主屏幕、App组织、消息、铃声也都会被备份。由于备份通过无线进行，并且为每个用户存储在iCloud中，应用需最小化自己存储的 数据数量。大文件会延长备份时间，并且消耗用户的可用iCloud空间。 为了确保备份尽可能快速高效，应用存储数据需要遵循以下指导方针： 1. 只有那些用户生成的文档或其它数据，或者应用不能重新创建的数据，才应该存储在/Documents目录下，并且会被自动备份到iCloud。 2. 可以重新下载或生成的数据，应该存储在/Library/Caches目录。例如数据库缓存文件、可下载文件（杂志、报纸、地图应用使用的数据）等都属于这一类。 3. 临时使用的数据应该存放在/tmp目录。尽管这些文件不会被iCloud备份，应用在使用完之后需要记得删除这些文件，这样才不会继续占用用户设备的空间。 4. 使用"不要备份"属性来指定那些需要保留在设备中的文件（即使是低存储空间情况下）。那些能够重新生成，但在低存储空间时仍需保留，对应用正常运行有影 响，或者用户希望文件在离线时可用的文件，需要使用这个属性。无论哪个目录下的文件（包括Documents目录），都可以使用这个属性。这些文件不会被 删除，也不会包含在用户的iCloud或iTunes备份中。由于这些文件一直占用着用户设备的存储空间，应用有责任定期监控和删除这些文件。 iOS 5.0.1开始支持"do not back up"文件属性，允许开发者明确地指定哪些文件应该被备份，哪些是本地缓存可以自动删除，哪些文件不需要备份但不能删除。此外，对目录设置这个属性，会阻止备份该目录和目录中的所有内容。 注 意"do not back up"属性只能用于iOS 5.0.1以后版本。之前版本的应用需要存储数据到/Library/Caches目录才能避免被备 份。由于老的系统忽略这个属性，你需要确保应用在所有iOS版本中，都遵循上面的iOS Data Storage Guidelines。 数据处理分类 com.apple.MobileBackup 文件属性就是iOS 5.0.1引入的"do not back up"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61243460ba22b06b976f667a3b9468b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d2aa45771ee97c7f547e77599dce9a/" rel="bookmark">
			C#下操作USB设备的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想必大家对LibUSB不陌生，没错，它就是很有名的开源usb驱动，其提供的API可以很方便的操作linux或者WIN下的USB设备，非常的方便！但是libusb是基于c语言的，那么在C#下是不是就不能使用libusb呢？当然不是了，你完全可以把libusb提供的dll封装成自己的C#库，但是这个工作量是非常大的而且调试的过程中肯定会有些意想不到的事情发生，那么在C#下该如何使用libusb呢，下面介绍C#下的强大的开源USB类库就登场了：LibUSBDotNet，没错就是.NET下的libusb，这也是个开源项目，已经把libusb封装成了一个完整的类库，可以去下面链接下载：
http://download.csdn.net/detail/cumtwys/7713473（CSDN不要分）
或者
http://sourceforge.net/projects/libusbdotnet/（官方）
它是sourceforge上的一个开源项目，下载WIN下的EXE安装即可，里面包含了很多的范例，还有说明文档（CHM格式的，超级方便的）。
下面简单介绍一下该如何使用LibUSBDotNet。
1、首先你需要创建一个C#的应用程序（控制台、窗体都可以）
2、将LibUsbDotNet安装目录下Src目录下LibWinUsb拷贝一份到你的工程根目录下
3、不需要多说了吧，在你的解决方案上右击，添加现有项目，将LibWinUsb目录下的项目包含进来
4、在你的项目上右击，添加引用，选择LibUSBDotNet项目，如下图：
5、在你的CS文件开头，添加引用：
using LibUsbDotNet; using LibUsbDotNet.Main; using LibUsbDotNet.Info; using LibUsbDotNet.Descriptors; using LibUsbDotNet.LibUsb; using LibUsbDotNet.WinUsb; 6、下面提供一个读取数据的范例（摘自CHM说明文档） using System; using System.Text; using LibUsbDotNet; using LibUsbDotNet.Main; namespace Examples { internal class ReadPolling { public static UsbDevice MyUsbDevice; #region SET YOUR USB Vendor and Product ID! public static UsbDeviceFinder MyUsbFinder = new UsbDeviceFinder(1234, 1); #endregion public static void Main(string[] args) { ErrorCode ec = ErrorCode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03d2aa45771ee97c7f547e77599dce9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61175a4203b010745c24985e0ef27270/" rel="bookmark">
			商务通 vs 快商通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		商务通 vs 快商通
共性：网站客服平台
语言版本：商务通有多语言版本。快商通目前只有中文版。
快商通：还有免费电话平台（这个功能比较独特）也销售400号码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e1809a7568f79798188379c73dec6a/" rel="bookmark">
			如何查看某个网站的ip地址(根据域名怎么知道IP)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
在dos中输入 nslookup www.baidu.com
注：nslookup这个命令是系统专门用于解析网站域名 IP 的一个内部命令。
www.baidu.com是我们要解析的域名（或网站）
方法二：
用ipconfig www.baidu.com
这个命令也能查看某个域名对应的IP
域名和IP地址的关系：
IP地址： 是人们在Internet上为了区分数以亿计的主机而给每台主机分配的一个专门的地址，通过IP地址就可以访问到每一台主机。（注：特殊情况下，一台计算机可以设定多个IP地址）
域名系统 ： ip没有什么实际的意义，很难记忆，所以我们用域名，（我们记不住百度的服务器的IP，但知道www.baidu.com）
虽然域名方便记忆，但网络本身只认识二进制的IP地址，因此，当人们使用域名方式访问某台远程主机时，必须首先将域名“翻译”成对应的IP地址，然后才能通过IP地址与该主机联系。这个“翻译”的过程称为域名解析；反过来，由IP地址得出域名地址的过程则称为域名反向解析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f73f393599d81ad84d8aa542f06b664/" rel="bookmark">
			C#调用带结构体指针的C Dll的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#中调用C（C++）类的DLL的时候，有时候C的接口函数包含很多参数，而且有的时候这些参数有可能是个结构体，而且有可能是结构体指针，那么在C#到底该如何安全的调用这样的DLL接口函数呢？本文将详细介绍如何调用各种参数的方法。
一、调用接口仅含普通变量
eg：int fnAdd(int num1,int num2);
那么在C#调用这种函数最简单了，直接用函数原型即可，如下：
[DllImport("你的dll名称", EntryPoint = "fnAdd", CallingConvention = CallingConvention.Cdecl)] public static extern int fnAdd(int num1, int num2); 这样在C#的方法内可以放心的使用这个dll函数了。
二、调用接口含普通变量的指针
大家都知道C#为了安全起见，隐形的避开了指针（其实在C#完全可以使用指针的，只是为了安全），采用了引用的方式来取代指针，引用的好处就是可以和指针一样操作参数原地址内的数据，并且这些数据在调用函数返回时还存活，但是引用不可以想指针那样++或者--到此PC指针乱跑，引出的一系列问题，下面举例来操作普通变量的指针，如下：
eg：int fnAdd(int *p_n1,int *p_n2);
上文已经说了C#采用引用来代替指针，那么好了调用接口可以这么写了：
[DllImport("你的dll名称", EntryPoint = "fnAdd", CallingConvention = CallingConvention.Cdecl)] public static extern int fnAdd(ref int num1,ref int num2); 对，就这样的简单，这样C#便可以调用带指针的普通变量了。
三、来电稍微难度点的，调用接口含结构体
eg：在C的头文件内包含这样一个简单的结构体
struct mybuf { int num1; int num2; } 接口函数如下：
int fnAdd(struct mybuf mydata);
那么这样在C#该如何调用这样的接口函数呢？
首先在C#我们要声明一个结构体，在C#结构体并没有被抛弃，只不过在使用结构体时需要注意一些细节，比如要调用C的DLL那么最好在C#内定义的结构体前加上一些修饰符，如下：
[StructLayout(LayoutKind.Sequential)] public struct MyBuf { public int num1; public int num2; public MyBuf(int n1,int n2) { num1 = n1; num2 = n2; } } [DllImport("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f73f393599d81ad84d8aa542f06b664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5fb4b21d469b0c9ea7de6610c54137/" rel="bookmark">
			【Linux知识】服务器性能测试--UnixBench
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接地址： http://blog.csdn.net/jason_asia/article/details/38309079
1.1. 服务器性能测试UnixBench
分别在DELL R720和DELL R610作为测试的服务器，因服务器配置不同，结果仅供参考.
下载：
wget http://byte-unixbench.googlecode.com/files/UnixBench5.1.3.tgz
安装：
tar zxf UnixBench5.1.3.tgz
cd UnixBench
make
运行：
./Run
服务器配置信息：
Product Name: Dell Inc. PowerEdge R720
Host Name: test
Kernel Version: 2.6.32-358.el6.x86_64 x86_64
OS Version: CentOS release 6.4 (Final)
Time Zone: Asia/Ho_Chi_Minh +0700
Char Set: en_US
Memory: 4 memories,total size is 32768MB,Speed: 1600 MHz,Type: DDR3
CPU info: Intel(R) Xeon(R) CPU E5-2609 v2 @2.50GHz, 2 * 4 core, cache size 10240 KB
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa5fb4b21d469b0c9ea7de6610c54137/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d262563863a09b49a141e6e2c3414957/" rel="bookmark">
			关于QT的折腾
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为要改其他人的一个源代码以便拿来给自己用，折腾了好久。
他的源码是QT5.1编的，编译器用的一直是vs2008，而我用的是QT5.2，qtcreater，以及mingw编译器，还有是他的库是release编译，我一直用debug编译，所以就出现各种各样的链接库的问题。头疼死了。
后来我把编译工具都换成和他一样的，才能使用他的库...所以说大家没事的话不要乱搞自己的环境，这个东西太微妙的，稍微哪有问题就不能用了。
之后我在5.2下写的东西要换到5.1下使用，因为我用的oracle库是在5.2下编译的，所以现在还得重新编译。编译oracle库就是要把qt目录里的oci.pro文件进行编译，我之前写过这个问题，我出现的问题是找不到oci.h，这是因为没有把oracle安装目录下的oci.h文件include进去，大家到工程属性里面设置一下就好。之后又报找不到QT5qsqld.lib这些错，这是因为在项目属性里lib的包含目录里写错了，把“d'去掉，改成QT5qsql.lib就好了。最后一个问题是在debug下编译出来的是qsqlocid.dll和qsqlocid.lib，在release下编译出来的是qsqloci.dll和qsqloci.lib，可能是你的源码是debug编译就要用有d的，release就要用没d 的，这个我没试过，不太清楚，我需要的是没d 的，用带d的还是说driver not loaded。
由于换5.1，之前的代码里的中文全不能识别了，都是乱码。刚开始编译不过，只要把.cpp和.h文件用记事本打开再保存就能编译通过了，不过还是显示乱码，没什么用。我把中文都换成英文了.......费死劲了.........以后就用英文了,也算走向国际了.........
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb256e9ae3c33367b179f296f76cf12/" rel="bookmark">
			游戏外挂：劫持技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1． 安装DetoursExpress30.msi,点击安装，安装后的目录结构如下：
在sample里面有例子，可供查看使用
2.第一步，打开VS2013开发人员命令提示（E:\Installed\MicrosoftVisual Studio 12.0\Common7\Tools\Shortcuts\VS2013 开发人员命令提示），进入Detours安装目录下的src目录，效果图如下：
2．新建项目，暂定项目名称是“劫持”
3．lib知识点
选中解决翻案à添加à新建项目à常规，输入lib名称
创建一个1.c文件
同理，添加一个1.h,内容如下
void msg();
添加一个1.c,内容如下：
#include&lt;Windows.h&gt;
void msg()
{
MessageBoxA(0, "11111", "2222", 0);
}
右击项目à属性à常规à配置类型à静态库.lib
然后，生成à生成lib,执行完成后发现资源目录里面的Debug目录下就有lib.lib文件了。
如果想在劫持项目中使用自己写的静态链接库。右击劫持项目à属性à链接器à常规à输入à附加依赖库，在最前面添加 lib.lib; 截图如下：
将lib.lib文件放到源文件同级目录下，截图如下：
在劫持项目里的hello.c文件中添加函数声明
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
voidmsg();
void main()
{
printf("hello world");
getchar();
}
这时候运行的时候就可以调用了lib.lib了。
动态库随时加载，随时注入。
静态库只有在编译的时候才可以调用。
4.使用detours做劫持(将项目改成release模式),其中项目结构如下（下面是劫持自己的过程）：
A放文件有：
detours.h (src下)
detours.lib (lib.X86下)
detver.h (src下)
将上面的文件放在源文件目录下即可
B.添加
#include"detours.h" //载入头文件
#pragma comment(lib, "detours.lib")//表明要使用静态库
C:定义一个新的函数取代旧的函数。
int newsystem(const char *_Command) //新的函数
{
return 0;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb256e9ae3c33367b179f296f76cf12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0391975e9d459a07f87e24a613e99183/" rel="bookmark">
			矩阵的物理意义（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面让我们把视力集中到一点以改变我们以往看待矩阵的方式。我们知道，线性空间里的基本对象是向量，而向量是这么表示的：
[a1, a2, a3, ..., an]
矩阵呢？矩阵是这么表示的：
a11, a12, a13, ..., a1n
a21, a22, a23, ..., a2n
...
an1, an2, an3, ..., ann
不用太聪明，我们就能看出来，矩阵是一组向量组成的。特别的，n维线性空间里的方阵是由n个n维向量组成的。我们在这里只讨论这个n阶的、非奇异的方阵，如果一组向量是彼此线性无关的话，那么它们就可以成为度量这个线性空间的一组基，从而事实上成为一个坐标系体系，其中每一个向量都躺在一根坐标轴上，并且成为那根坐标轴上的基本度量单位（长度1）。现在到了关键的一步。看上去矩阵就是由一组向量组成的，而且如果矩阵非奇异的话（我说了，只考虑这种情况），那么组成这个矩阵的那一组向量也就是线性无关的了，也就可以成为度量线性空间的一个坐标系。（方阵非奇异=矩阵可逆=矩阵满秩=矩阵行向量线性无关=矩阵列向量线性无关）结论：矩阵描述了一个坐标系。之所以矩阵又是运动，又是坐标系，那是因为——“运动等价于坐标系变换”。对不起，这话其实不准确，我只是想让你印象深刻。准确的说法是：“对象的变换等价于坐标系的变换”。或者：“固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换。”说白了就是： “运动是相对的。” 让我们想想，达成同一个变换的结果，比如把点(1, 1)变到点(2, 3)去，你可以有两种做法。第一，坐标系不动，点动，把(1, 1)点挪到(2, 3)去。第二，点不动，变坐标系，让x轴的度量（单位向量）变成原来的1/2，让y轴的度量（单位向量）变成原先的1/3，这样点还是那个点，可是点的坐标就变成(2, 3)了。方式不同，结果一样。从第一个方式来看，那就是我在《理解矩阵》1/2中说的，把矩阵看成是运动描述，矩阵与向量相乘就是使向量（点）运动的过程。在这个方式下，
Ma = b的意思是：
“向量a经过矩阵M所描述的变换，变成了向量b。”
而从第二个方式来看，矩阵M描述了一个坐标系，姑且也称之为M。那么：
Ma = b的意思是：
“有一个向量，它在坐标系M的度量下得到的度量结果向量为a，那么它在坐标系I的度量下，这个向量的度量结果是b。”
这里的I是指单位矩阵，就是主对角线是1，其他为零的矩阵。而这两个方式本质上是等价的。我希望你务必理解这一点，因为这是本篇的关键。正因为是关键，所以我得再解释一下。在M为坐标系的意义下，如果把M放在一个向量a的前面，形成Ma的样式，我们可以认为这是对向量a的一个环境声明。它相当于是说： “注意了！这里有一个向量，它在坐标系M中度量，得到的度量结果可以表达为a。可是它在别的坐标系里度量的话，就会得到不同的结果。为了明确，我把M放在前面，让你明白，这是该向量在坐标系M中度量的结果。” 那么我们再看孤零零的向量b：
b 多看几遍，你没看出来吗？它其实不是b，它是：
Ib
也就是说：“在单位坐标系，也就是我们通常说的直角坐标系I中，有一个向量，度量的结果是b。”
而 Ma = Ib的意思就是说：
“在M坐标系里量出来的向量a，跟在I坐标系里量出来的向量b，其实根本就是一个向量啊！”这哪里是什么乘法计算，根本就是身份识别嘛。从这个意义上我们重新理解一下向量。向量这个东西客观存在，但是要把它表示出来，就要把它放在一个坐标系中去度量它，然后把度量的结果（向量在各个坐标轴上的投影值）按一定顺序列在一起，就成了我们平时所见的向量表示形式。你选择的坐标系（基）不同，得出来的向量的表示就不同。向量还是那个向量，选择的坐标系不同，其表示方式就不同。因此，按道理来说，每写出一个向量的表示，都应该声明一下这个表示是在哪个坐标系中度量出来的。表示的方式，就是 Ma，也就是说，有一个向量，在M矩阵表示的坐标系中度量出来的结果为a。我们平时说一个向量是[2 3 5 7]T，隐含着是说，这个向量在 I 坐标系中的度量结果是[2 3 5 7]T，因此，这个形式反而是一种简化了的特殊情况。
注意到，M矩阵表示出来的那个坐标系，由一组基组成，而那组基也是由向量组成的，同样存在这组向量是在哪个坐标系下度量而成的问题。也就是说，表述一个矩阵的一般方法，也应该要指明其所处的基准坐标系。所谓M，其实是 IM，也就是说，M中那组基的度量是在 I 坐标系中得出的。从这个视角来看，M×N也不是什么矩阵乘法了，而是声明了一个在M坐标系中量出的另一个坐标系N，其中M本身是在I坐标系中度量出来的。
回过头来说变换的问题。我刚才说，“固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换”，那个“固定对象”我们找到了，就是那个向量。但是坐标系的变换呢？我怎么没看见？请看：
Ma = Ib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0391975e9d459a07f87e24a613e99183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ed9358e3bc6ef1d501a7056d97fa28/" rel="bookmark">
			Android解耦库EventBus的使用和源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尊重原创：http://blog.csdn.net/yuanzeyao/article/details/38174537
代码下载：http://download.csdn.net/detail/yuanzeyao2008/7684041 在编程过程中，当我们想通知其他组件某些事情发生时，我们通常使用观察者模式，正式因为观察者模式非常常见，所以在jdk1.5中已经帮助我们实现了观察者模式，我们只需要简单的继承一些类就可以快速使用观察者模式，在Android中也有一个类似功能的开源库EventBus，可以很方便的帮助我们实现观察者模式，那么我们就开始学习如何使用EventBus.
在接下来的内容中，我首先会介绍如何使用EventBus,然后再简单的学习一下EventBus的底层实现原理，因为仅仅学习如何使用总是感觉内心不够踏实，万一哪天出了Bug也无从下手，了解了它的基本实现后，就会用得游刃有余。好了 废话不多说，下面开始学习吧
1、下载EventBus库：
EvnetBus的下载地址：https://github.com/greenrobot/EventBus.git
2、将EventBus.jar放入自己工程的libs目录即可
3、定义一个事件，这个事件一旦被EventBus分发出去就是代表某一件事情发生了，这个事件就是某个观察者关心的事情(不需要继承任何类)
4、定义观察者，然后将该观察者注册到EventBus
5、由EventBus分发事件，告知观察者某一件事情发生了
6、使用完成后从EventBus中反注册观察者。
熟悉观察者模式的朋友肯定对于上面的流程非常熟悉，其实和观察模式基本是一样的。但是也是有区别的。在观察者模式中，所有的观察者都需要实现一个接口，这个接口有一个统一的方法如:
public void onUpdate()；
然后当某一个事件发生时，某个对象会调用观察者的onUpdate方法通知观察者某件事情发生了，但是在EventBus中不需要这样，EventBus中是这样实现的：
在EventBus中的观察者通常有四种订阅函数（就是某件事情发生被调用的方法）
1、onEvent
2、onEventMainThread
3、onEventBackground
4、onEventAsync
这四种订阅函数都是使用onEvent开头的，它们的功能稍有不同,在介绍不同之前先介绍两个概念：
告知观察者事件发生时通过EventBus.post函数实现，这个过程叫做事件的发布，观察者被告知事件发生叫做事件的接收，是通过下面的订阅函数实现的。
onEvent:如果使用onEvent作为订阅函数，那么该事件在哪个线程发布出来的，onEvent就会在这个线程中运行，也就是说发布事件和接收事件线程在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。
onEventMainThread:如果使用onEventMainThread作为订阅函数，那么不论事件是在哪个线程中发布出来的，onEventMainThread都会在UI线程中执行，接收事件就会在UI线程中运行，这个在Android中是非常有用的，因为在Android中只能在UI线程中跟新UI，所以在onEvnetMainThread方法中是不能执行耗时操作的。
onEvnetBackground:如果使用onEventBackgrond作为订阅函数，那么如果事件是在UI线程中发布出来的，那么onEventBackground就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么onEventBackground函数直接在该子线程中执行。
onEventAsync：使用这个函数作为订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync.
下面就通过一个实例来看看这几个订阅函数的使用吧
1、定义事件：
public class AsyncEvent { private static final String TAG = "AsyncEvent"; public String msg; public AsyncEvent(String msg) { this.msg=msg; } } 其他的事件我就不都贴出来了，我会提供代码的下载的。 2、创建观察者（也可以叫订阅者），并实现订阅方法 public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册EventBus EventBus.getDefault().register(this); } // click--------------------------------------start---------------------- public void methodPost(View view) { Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25ed9358e3bc6ef1d501a7056d97fa28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c060d9a5d116dacd45940ed357f57a5/" rel="bookmark">
			关闭窗体后，进程仍然在运行的问题重现与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题陈述
在开发中，遇到这样一个问题：
点击程序主窗体右上角的叉号关闭应用程序后，程序的进程却没有关闭。
通过查阅资料，了解到，产生此类问题的原因主要有以下两点：
1）程序中存在死循环。
2）程序为多线程程序，且在窗体关闭后，仍有线程在工作。
本文将针对此类问题，进行重现并提出解决方案。
2 场景再现
@场景1
新建Windows应用程序CloseWindowExp，程序每隔一秒钟改变一次窗体的背景色。
程序运行后的效果，如下图所示（变化的过程，就请大家在脑子中想象一下吧）。
程序的主要代码如下所示。
//************************************************************ // // 窗体关闭问题示例代码 // // Author：三五月儿 // // Date：2014/07/27 // // http://blog.csdn.net/yl2isoft // //************************************************************ using System; using System.Drawing; using System.Threading; using System.Windows.Forms; namespace CloseWindowExp { public partial class frmCase1 : Form { Random rand = new Random(); public frmCase1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { while (true) { int c1 = rand.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c060d9a5d116dacd45940ed357f57a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a858274a76b2275ffd68eadbf77586c5/" rel="bookmark">
			在JS数组指定位置插入元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接: Array: Insert an Item at a Specific Index with JavaScript 原文日期: 2014年07月24日 翻译日期: 2014年07月26日 翻译人员: 铁锚 很多与数组有关的任务听起来很简单,但实际情况并不总是如此,而开发人员在很多时候也用不到他。最近我碰到了这样一个需求: 将一个元素插入到现有数组的特定索引处。听起来很容易和常见,但需要一点时间来研究它。 // 原来的数组 var array = ["one", "two", "four"]; // splice(position, numberOfItemsToRemove, item) // 拼接函数(索引位置, 要删除元素的数量, 元素) array.splice(2, 0, "three"); array; // 现在数组是这个样子 ["one", "two", "three", "four"] 如果你对扩展原生 JavaScript 不反感,那么可以将这个方法添加到数组原型(Array prototype)中: Array.prototype.insert = function (index, item) { this.splice(index, 0, item); }; 此时,可以这样调用: var nums = ["one", "two", "four"]; nums.insert(2, 'three'); // 注意数组索引, [0,1,2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a858274a76b2275ffd68eadbf77586c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cfee3c24fafa3c54bf304fcb175a47f/" rel="bookmark">
			objective-c中的本地化操作（序列化，归档）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先介绍一个自定义类描述的方法description，一般情况下，一个自定义类我们在用%@输出的时候，给出的是一个内存地址，我们在该类的.m文件里重写description方法，来修改输出内容，呆会儿我们要用到这个方法来验证今天学习内容，所以先看一段代码熟悉一下：
Human.h:
[plain] view plain copy #import &lt;Foundation/Foundation.h&gt; @interface Human : NSObject { int age; NSString *name; Human *child; } @property int age; @property (copy)NSString *name; @property (retain)Human *child; @end Human.m: [plain] view plain copy #import "Human.h" @implementation Human @synthesize age; @synthesize name; @synthesize child; //-(NSString *)description //{ // NSString *des = [NSString stringWithFormat:@"%d,%@,%@",age,name,child]; // return des; //} @end 上面的重写描述被注释掉了，我们先看未修改前的输出： main.m:
[plain] view plain copy #import &lt;Foundation/Foundation.h&gt; #import "Human.h" int main(int argc, const char * argv[]) { @autoreleasepool { Human *human1=[[Human alloc]init]; Human *human2=[[Human alloc]init]; human1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cfee3c24fafa3c54bf304fcb175a47f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918601b083f4002affcd3b3df046daf6/" rel="bookmark">
			iOS 完全复制UIView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果要完全复制一个UIView和对象的时候可以使用对象序列化方法
// Duplicate UIView - (UIView*)duplicate:(UIView*)view { NSData * tempArchive = [NSKeyedArchiver archivedDataWithRootObject:view]; return [NSKeyedUnarchiver unarchiveObjectWithData:tempArchive]; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1117069078cc17bbf78f828932e95da0/" rel="bookmark">
			C#中动态修改ListBox的Item的颜色的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近搞了C#需要在ListBox中显示不同类型的数据，为了让用户容易区分，增加了颜色区分的功能，就是需要不同的类型数据显示出不同的颜色。针对上述的要求我们需要使用控件的重绘方法，就是用重绘的方法激活重绘事件，在重绘事件内修改Item的字体颜色。方法如下（基于DrawItem事件）
一、新建一个C#的窗口应用程序，在form1内添加一个ListBox控件，一个TextBox控件，一个按钮控件；我们要求如下：按一次按钮将文本框内的内容添加到ListBox内，并且ListBox在显示的时候根据Item的内容显示不同的颜色，比如添加的Item内包含了"你好"，那么这个Item用绿色来显示；如果包含了"你坏"用红色来表示。界面如下图所示：
二、界面准备完成，我们需要对ListBox控件的属性进行修改，才能使ListBox控件支持DrawItem的事件，我们要在ListBox控件的【DrawMode】属性修改为下图中的任意一个，具体的区别还没有深入研究，我选择的是【OwnerDrawFixed】属性，如下图：
三、还是要选中ListBox控件，在【事件】属性栏内找到【DrawItem】事件，双击，便在CS文件添加了该控件的DrawItem事件的处理函数。如下图
四、添加相应的处理【一】中需求的方法，比如按钮事件，获取文本框的文本并显示在ListBox内；
五、详细源码
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; namespace TestListBoxColor { public partial class Form1 : Form { public Form1() { InitializeComponent(); } // ListBox DrawItem事件响应函数 private void listBox1_DrawItem(object sender, DrawItemEventArgs e) { if (e.Index &gt;= 0) { e.DrawBackground(); Brush mybsh = Brushes.Black; // 判断是什么类型的标签 if (listBox1.Items[e.Index].ToString().IndexOf("你好") != -1) { mybsh = Brushes.Green; } else if (listBox1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1117069078cc17bbf78f828932e95da0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af3e6669a8f232a1cbd22326c19879b/" rel="bookmark">
			互斥类(Cmutex)——MFC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关于CMutex类
1、CMutex只是对 win32API 的互斥操作进行了封装
2、它的参数与 win32 API 中的 CreatMutex() 相对应
3、CMutex的构造函数调用 CreatMutex() 创建并检查
4、其Lock操作从基类继承，调用WaitForSingleObject()获得所有权，互斥类重载 Unlock 调用ReleaseMutex()释放所有权。
所以，MFC其实就是简单了封装了 win32 API 函数。
二、CMutex的实现：
1、CMutex::CMutex(BOOL bInitiallyOwn, LPCTSTR pstrMame)
2、CMutex::~CMutex()
3、BOOL CMutex::Unlock()
三、使用，用法：
首先，创建工程——win32 console Application——工程名——OK——an application that supports MFC——finish
1、例子1，单独操作(伪代码)
CMutex mutex; //声明互斥
UINT mythreadA：mutex.Lock();
//动作
mutex.Unlock();
Sleep(1000);
UINT mythreadB：mutex.Lock();
//动作
mutex.Unlock();
Sleep(1000);
int _tmain():int flag=0;
if(!AfxWinInit(::GetModuleHandle(NULL),NULL,::GetCommandLine(),0))
{cerr&lt;&lt;.......... ; flag=1; }
else
{
AfxBeginThread(mythreadA,NULL);
AfxBeginThread(mythreadB,NULL);
Sleep(10000);
}
return flag;
2、这个例子（和CSingleLock使用）：
1）通过某个成员函数访问被 CMutex 对象保护的资源（即array[1024];）时，要创建CSingleLock或者是CMultiLock,它以 CMutex 对象的指针为参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3af3e6669a8f232a1cbd22326c19879b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4696dbb7f3df7af41a2bbfd54c3caafa/" rel="bookmark">
			Maven常用命令、配置、POM、仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）常用命令 1）Maven 导出依赖lib 并打包 mvn clean dependency:copy-dependencies -DoutputDirectory=target/classes/lib -DincludeScope=runtime package 2）忽略测试错误 mvn test -Dmaven.test.failure.ignore=true 3） 安装跳过单元测试 mvn install -Dmaven.test.skip=true 4）运行 mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main 好处：不用向classpath中添加所有的依赖 5）独立jar加入本地仓库 mvn install:install-file -Dfile=jar包的位置 -DgroupId=上面的groupId -DartifactId=上面的artifactId -Dversion=上面的version -Dpackaging=jar 如：mvn install:install-file -DgroupId=org.apache.commons -DartifactId=commons-email -Dversion=1.3.2 -Dpackaging=jar -Dfile=E:\workspace\sca-crawler\lib\commons-email-1.3.2.jar 6）查看插件信息 mvn help:describe -Dplugin=exec -Dfull （二）插件定制 向插件传参数定制行为 1）设置主类 &lt;build&gt;
&lt;plugins&gt;
&lt;plugin&gt;
&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
&lt;version&gt;2.4&lt;/version&gt;
&lt;configuration&gt;
&lt;outputDirectory&gt;target&lt;/outputDirectory&gt;
&lt;archive&gt;
&lt;manifest&gt;
&lt;addClasspath&gt;true&lt;/addClasspath&gt;
&lt;classpathPrefix&gt;./lib/&lt;/classpathPrefix&gt;
&lt;mainClass&gt;com.ailk.tosd.ua.hadoop.tool.UAClassifierJob&lt;/mainClass&gt;
&lt;/manifest&gt;
&lt;/archive&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt; 2）测试过程测试失败错误:mvn test &lt;build&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4696dbb7f3df7af41a2bbfd54c3caafa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de067ca8850ee7e45e19bb4566976b5/" rel="bookmark">
			使用ValidationRule类来检查用户输入的有效性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 新建WPF应用程序ValidationRuleExp
整个程序的结构如下图所示。
程序运行起来后的效果如下图所示。
用户操作程序时，先输入固话、手机、Email、个人网站等信息，再点击右侧的“点我记住你”按钮，便可以保存用户输入的信息。
2 新建业务实体类ContactModel（类文件为ContactModel.cs）
ContactModel类包含固话、手机、Email、个人网站等属性，分别与界面的固话文本框、手机文本框、Email文本框、个人网站文本框绑定。ContactModel类实现INotifyPropertyChanged接口，这样一来，当ContactModel类的某一属性发生改变时，便可以向执行绑定的客户端发出某一属性值已更改的通知。例如：将ContactModel类的TelePhone属性与客户端的“固话”文本框进行绑定，一旦TelePhone属性的值发生改变，将会通知“固话”文本框更新自己的值。
详细代码如下所示。
//************************************************************ // // ValidationRule类示例代码 // // Author：三五月儿 // // Date：2014/07/11 // // http://blog.csdn.net/yl2isoft // //************************************************************ using System.ComponentModel; namespace ValidationRuleExp { public class ContactModel : INotifyPropertyChanged { /// &lt;summary&gt; /// 固话号码 /// &lt;/summary&gt; private string telePhone; public string TelePhone { get { return telePhone; } set { telePhone = value; NotifyPropertyChanged("TelePhone"); } } /// &lt;summary&gt; /// 手机号码 /// &lt;/summary&gt; private string mobilePhone; public string MobilePhone { get { return mobilePhone; } set { mobilePhone = value; NotifyPropertyChanged("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7de067ca8850ee7e45e19bb4566976b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f2f62f4c3f0549225f416dc9b6c089e/" rel="bookmark">
			谈谈饥荒这个游戏的内部技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于我来说，我想Hook饥荒，可这是一个神奇的程序，用了D3D9但是又截获不到dx的present函数，也就是它内部没有调用。
不过游戏的显示依然正常，绘制非常流畅，应该不是使用gdi/gdiplus。分析了一下加载的模块，包含了谷歌的angelproject。谷歌这个项目是opengl es的directx实现。但不管是什么项目，如果用dx，最终都应该调用present/ex吧！
摸不清饥荒的套路，望思路清晰的高手指教。
转载于:https://www.cnblogs.com/fyter/p/dontstarve_tech_community.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f685f3e095a2dcb6a9ccbadb55bd158/" rel="bookmark">
			网络常用命令(八)ebtables
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 待续... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0d6febd4eac19d22373e7b534ba1cb/" rel="bookmark">
			windows屏幕捕捉BitBlt函数鼠标闪烁问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://liufan5005.blog.163.com/blog/static/26710173200911291739569/
我们在用BitBlt函数进行屏幕捕捉时，若传递了CAPTUREBLT(捕捉alpha blending，即半透
明窗口)标志，鼠标就会闪烁，这是为什么呢？ 下文是本人阅读英文解释后的个人理解： 在windows2000及以后的系统上，鼠标及半透明窗口这两种图形对象是浮于桌面其他图形对象之上的，这里我们称它们为层叠窗口。层叠窗口并不存在于通常的显示场景(具体是在显示的哪一层，我也不清楚，姑且称它为场景M)中，只有在显示到屏幕的最后一刻，Windows才把层叠窗口绘制到屏幕上。 仅使用SRCCOPY标志时，Windows只需要从M中拷贝屏幕图像就行了。而若使用了CAPTUREBLT标志，导致的结果是鼠标及半透明窗口均被捕捉下来。但在设计上，BitBlt函数是不允许捕捉鼠标的。于是，系统只好先隐藏鼠标，然后捕捉图像，再恢复鼠标，结果就导致了鼠标的闪烁。 另附 捕捉鼠标代码：
//包含鼠标 CAPTUREBLT 会闪烁
// 将屏幕数据画如内存上下文
BitBlt(hDCMem,0,0,xScrn,yScrn,hDCSource,0,0,SRCCOPY|CAPTUREBLT);
// 因为获取的屏幕上不包含鼠标信息，可以手动添加到内存上下文
POINT ptCursor;
GetCursorPos(&amp;ptCursor); DrawIconEx(hDCMem, ptCursor.x, ptCursor.y, hCursor, 0, 0, 0, NULL, DI_NORMAL | DI_COMPAT | DI_DEFAULTSIZE); 附上英文原文： You may have noticed that when you press the PrtSc key to take a screenshot, the cursor blinks briefly. Believe it or not, it actually does this for the same reason that the Windows XP fade-out shutdown screen does not include translucent windows.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d0d6febd4eac19d22373e7b534ba1cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac4bc23cdf4ba0c9a121dc5ce47fa2ad/" rel="bookmark">
			解决vsftp无法上传文件及文件夹的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近一段时间，因为搞hadoop的缘故，考虑到启动linux桌面会给电脑带来比较卡。。所以就将图形界面的启动给关闭，完全在命令的模式下使用linux。
使用yum搭建了ftp服务。。yum的使用参考：http://blog.csdn.net/enson16855/article/details/9140623
windows使用FileZilla连接linux的ftp，比较郁闷的是上传问题，弄了半个下午的时间都没有成功，刚刚终于弄好了。。下面说一下思路：
1、安装vsftp
yum install vsftp2、启动vsftp service vsftpd start 虽然可以正确启动，基本都是按照默认的配置走，匿名登录无法上传文件及文件夹的，网上收罗了一堆： 以上是：
vim /etc/vsftpd/vsftpd.conf 的结果内容，标红的地方表示的是允许匿名上传文件和文件夹的权限。重启vsftpd服务。。 虽然配置没什么问题了，可是还是不能上传文件，报的还是权限的问题。。
搜罗一看，原来是selinux需要关闭：
修改 vim /etc/selinux/config 以上方式禁用掉selinux服务，需要重启电脑，当然还有一种临时禁用，可以上网搜一下处理方式~
搞定ok之后，发现还是上传不了文件。。晕死了 今天。。。
搜罗一番，还要对ftp的root文件夹权限设置：
chmod 777 -R /var/ftp/pub 设置完成后，终于可以上传文件了。。。。当然需要上传到的是pub文件夹中。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/694494f9994744570824f663124a9a93/" rel="bookmark">
			尚未备份数据库 xxxx  的日志尾部。如果该日志包含您不希望丢失的工作，请使用 BACKUP LOG WITH NORECOVERY 备份该日志。请使用 RESTORE 语句的 WITH REPLA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此错误的原因是：你的数据库服务器中存在同名数据库！
RESTORE DATABASE [student] FROM DISK = N'G:\备份文件' WITH FILE = 1, MOVE N'student' TO N'G:\student.mdf', MOVE N'student_log' TO N'G:\\student.ldf', NOUNLOAD,REPLACE, STATS = 10, PASSWORD = '123456'
所以 在WITH 后加入 REPLACE 或 STOPAT 就可以还原啦 ！但同名数据库可能被覆盖！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e7a0da3eb184181f46309b40b500663/" rel="bookmark">
			Hibernate or 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Restrictions.or(Restrictions.like(),Restrictions.or(Restrictions.like,........))
里面的or可以无限加的.还是比较好用
Session session = getHibernateTemplate().getSessionFactory()
.openSession();
Criteria criteria = session.createCriteria(Film.class);
List&lt;Film&gt; list = criteria.add(
Restrictions.or(Restrictions.like("description", key,MatchMode.ANYWHERE),
Restrictions.or(Restrictions.like("name", key,MatchMode.ANYWHERE),
Restrictions.or( Restrictions.like("direct", key,MatchMode.ANYWHERE),
Restrictions.or(Restrictions.like("mainplay",key,MatchMode.ANYWHERE),
Restrictions.like("filearea", key,MatchMode.ANYWHERE)))))).list();
session.close();
return list;
================================================百度来的~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e529866f5d532146aab8f8fd5b958740/" rel="bookmark">
			取得数据库表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是用连接的方式取得表结构，有4列，最后一列用于标明约束是单一的还是联合的。 适用于oracle，执行需要管理员权限，如果用schema来约束可以查询整个schema的数据库表结构，执行速度有点慢，如果程序中有用最好将查询结果放到 一个表中。可以按照需要对代码进行调整。
select aa.column_name,aa.comments,aa.datatype,bb.constraint_type ,bb.column_name from ( select a.column_name ,a.comments,b.data_type|| (CASE WHEN b.data_scale &gt;=0 THEN '('||b.data_length||','||b.data_scale||')' ELSE '('||b.data_length||')' END ) as datatype ,a.table_name from all_col_comments a,all_tab_columns b where a.table_name=b.table_name and a.column_name=b.column_name ） aa, ( select DECODE(au.constraint_type, 'P', '主键约束', 'U', '唯一约束') as constraint_type, cu.constraint_name AS column_name,cu.column_name AS comments ,au.table_name from all_cons_columns cu, all_constraints au where cu.constraint_name = au.constraint_name and (au.constraint_type = 'P' or au.constraint_type ='U') ) bb where aa.table_name=bb.table_name(+) and aa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e529866f5d532146aab8f8fd5b958740/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34cba5be00968b30d0a6170640c8b5a/" rel="bookmark">
			CF 444A(DZY Loves Physics-诱导子图的密度)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. DZY Loves Physics time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output DZY loves Physics, and he enjoys calculating density.
Almost everything has density, even a graph. We define the density of a non-directed graph (nodes and edges of the graph have some values) as follows:
where v is the sum of the values of the nodes, e is the sum of the values of the edges.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34cba5be00968b30d0a6170640c8b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4646995e4cce27ec43101cd12e978b1/" rel="bookmark">
			golang时间处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang时间处理
相关包 "time" 当前时间戳 fmt.Println(time.Now().Unix()) # 1389058332 当前格式化时间 fmt.Println(time.Now().Format("2006-01-02 15:04:05")) # 这是个奇葩,必须是这个时间点, 据说是go诞生之日, 记忆方法:6-1-2-3-4-5 # 2014-01-07 09:42:20 时间戳转str格式化时间 str_time := time.Unix(1389058332, 0).Format("2006-01-02 15:04:05") fmt.Println(str_time) # 2014-01-07 09:32:12 str格式化时间转时间戳 the_time := time.Date(2014, 1, 7, 5, 50, 4, 0, time.Local) unix_time := the_time.Unix() fmt.Println(unix_time) # 389045004 还有一种方法,使用time.Parse the_time, err := time.Parse("2006-01-02 15:04:05", "2014-01-08 09:04:41") if err == nil { unix_time := the_time.Unix() fmt.Println(unix_time)	} # 1389171881 示例 package main import ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4646995e4cce27ec43101cd12e978b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36776110b86c032050a24f9cae8041fd/" rel="bookmark">
			boost::lockfree::stack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;boost/thread/thread.hpp&gt; #include &lt;boost/lockfree/stack.hpp&gt; #include &lt;iostream&gt; #include &lt;boost/atomic.hpp&gt; boost::atomic_int producer_count(0); boost::atomic_int consumer_count(0); boost::lockfree::stack&lt;int&gt; stack(128);//多生产者多消费者无锁栈 const int iterations = 10000; const int producer_thread_count = 4; const int consumer_thread_count = 4; void producer(void) { for (int i = 0; i != iterations; ++i) { int value = ++producer_count; while (!stack.push(value)) ; } } boost::atomic&lt;bool&gt; done (false); void consumer(void) { int value; while (!done) { while (stack.pop(value)) ++consumer_count; } while (stack.pop(value)) ++consumer_count; } int main(int argc, char* argv[]) { using namespace std; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36776110b86c032050a24f9cae8041fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24cfcef2faa0130af8ba445f2c98255/" rel="bookmark">
			unity3d中获得物体的size
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以size的x方向为例
1:gameObject.renderer.bounds.size.x;//这个值的结果真实反应出有MeshRenderer这个组件的模型的尺寸。不需要再乘以localScale.x。
2:gameObject.GetComponent&lt;MeshFilter&gt;().mesh.bounds.size.x;//通过MeshFilter获得原始模型的mesh，该值返回的结果是原始mesh的尺寸。
若要获得模型的尺寸大小还需要乘以模型的localScale.x。
即：gameObject.GetComponent&lt;MeshFilter&gt;().mesh.bounds.size.x*gameObject.transform.localScale.x;
3:为物体添加Collider,然后使用XXX.collider.bounds.size；
这个不一定能很好的反应物体的大小，bounds获得的是物体的外包矩形。而且这个外包矩形的X,Y,Z和世界坐标一致。因此，若物体有旋转，获得的尺寸就不能反应出物体的真实大小，只是其外包矩形的大小。。。
如：获得terrain的尺寸
terrainWidth = terrain.collider.bounds.size.x;
terrainLength = terrain.collider.bounds.size.z;
terrainHeight = terrain.collider.bounds.size.y;
4：代码实现获得复杂物体的尺寸（诸如根节点没有MeshFilter，MeshRenderer组件，物体是由很多复杂不规则的小mesh子物体组成的）
如：
Camera的口径Size
当投影类型为Perspective时，fieldOfView属性表示口径的度数，范围为[1,179]
当投影类型为Orthgraphic, orthographicSize属性为正交模式下的口径尺寸
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ffce9c14d263f7eac4013e780b6b63b/" rel="bookmark">
			Labview操作串口-----------通过VISA驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章将会详细介绍如何通过labview的VISA驱动模块来操作PC的串口。（基于LABVIEW2012、VISA530full.exe）
1、首先需要安装LABVIEW，接下里安装VISA530驱动模块（否则编译本代码时会出现缺少VISA驱动模块的提示）。
2、新建一个VI项目，保存为mycomm.vi
3、在VI前面板内添加如下图所示的控件：
【接收区域】为【系统】控件内的“系统字符串”，右键属性内修改为自动换行、显示垂直滚动条；然后右键将其修改为“转换为显示控件”。这个控件用户可以自行修改为其它设置的控件。
【发送区域】为【系统】控件内的“系统字符串”，同理右键修改为自动换行、显示垂直滚动条；然后切记要右键属性内勾选“键入时刷新”，否则发送是会出现重复发送上次内容的情况，如下图：
【端口号】控件为【系统】空间内的“系统下拉列表”，右键增加属性值（添加COM1、COM2、COM3等等）。
【串口状态指示灯】为布尔控件内的圆形指示灯，用户自行修改其开关颜色。
【退出程序】、【发送】按钮为系统布尔按钮，修改机械操作位“保持转换直到释放”，如下图：
【打开】按钮修改为多字符串显示“打开”和“关闭”字符，机械操作修改为“释放时转换”
4、编写“程序框图”
创建两个while循环，一个循环处理用户事件（比如：按钮事件、程序运行初始化、退出等），一个循环用来处理接收数据的任务。
首先第一个循环：初始化
其中的带小房间的局部变量可以在前面板的控件上右击“创建局部变量”来放置；while循环创建移位寄存器，用来处理不同状态的任务（Init，Event，Exit三种）；下面看Event任务，如下图：
打开串口按钮事件，使用端口号控件的值配合VISA资源名称控件（在前面板----&gt;新式----&gt;IO----&gt;VISA资源名称，右键选择VISA类----&gt;IO session----&gt;Serial Instr，然后在程序框图内右键选择”转换为常量“，则VISA资源名称控件变为如下图）
然后在空间内添加资源名称如上上图。
后面几个事件就不介绍了，包含了发送，关闭等操作稍后送上源码。
第二个循环，接收：
当串口打开标识为真时才执行读取的操作，使用VISA属性节点（在仪器IO----&gt;VISA----&gt;高级VISA----&gt;VISA属性节点），右键选择类----&gt;VISA----&gt;IO session----&gt;Serial Instr，然后单击属性，选择如下图蓝色部分所示：Number of Bytes at Serial Port
到此即可进行串口通信了，将PC的2、3两线相连测试测试代码。
源码下载地址CSDN：
http://download.csdn.net/detail/cumtwys/7592575 0分资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7870cc8be02e2b46f1a97a780032b440/" rel="bookmark">
			Android 项目开发建议标准规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 项目开发建议标准规范 /**
* 本文档的制定为了使应用开发更清晰，以实际开发中加以完善此文档所作规范。
* @author haxido
* @date 2011-5-18
* @version 1.0.0
*/
一、项目目录结构说明
1.src存放源代码文件
2.assets存放流文件
3.doc存放文档文件
4.res/drawable-large存放480*800分辨率资源图片
5.res/drawable-mdpi存放320*480分辨率资源图片
6.res/layout-large存放480*800分辨率布局文件
7.res/layout-mdpi存放320*480分辨率布局文件
8.res/raw存放媒体文件
9.values/保存字符串资源等
10.gen中为项目自动生成文件
11.AndroidManifest.xml配置文件
二、文件命名规范
1.代码文件命名规范
a.一般的代码文件命名以继承名类名为前缀，例：继承自Activity的文件可写成ActivityMain.java。
b.一些纯粹的类名命名遵守以大的归类为前缀，可自定，如InfoRank.java。
c.首字母及新单词开始必须大小写，遵从匈牙利命名法则（前缀+修饰语）。
2.图片资源文件命名命名规范
a.命名以全小写，单词不缩写。
b.图片的命名必须唯一，整套图片直接存放于drawable文件夹下，以命名分类。
c.按钮类图片命名以button为前缀，如buttonok,buttoncancel。
d.背景类图片命名以back为前缀。
e.显示类图片命名以view为前缀。
f.展示类图片命名以dis为前缀，如幻灯片播放。
g.临时用图命名以tmp为前缀。
h.其他图上命名以other为前缀。
3.布局文件命名规范
a.命名以全小写，单词不缩写。
b.布局文件的命名可参照代码文件的命名，一般来说一个页面一个xml,对应也会有一个java代码，对应的java和
xml命名可相同。
c.对于一些属性文件命名以css为前缀。
4.字符串命名规范
a.字符串命名采用全小写，下划线作为分隔符。
b.应用名字以app_为前缀。
c.网址以url_为前缀。
d.文字说明或参照内容以string_为前缀。
e.颜色以color_为前缀。
f.密码文字password_为前缀。
g.全数字以digit_为前缀。
5.包的建立规范
a.com.smarch为根目录，此目录只允许建立文件夹，不直接存放具体文件。
三、代码书写要点规范
1.xml中控件命名规范
a.命名遵守骆驼法则，即首字母小写。
b.命名在整个项目中必须唯一，以xml文件名 + 控件类型为前缀，如对activityclickme.xml中的一个Button命名，
可以写成如下形式activityclickmeButtonClose这种方式会显得文件名较长，但能保证唯一，还有一种做法，可
去掉xml文件前缀，上面的名字可写成如下clickmeButtonClose，建议采用第二种方法，比较清晰。
2.java代码中控件命名规范
a.以控件类型缩写名为前缀的方式，如TextView类型的控件可命名成tvShow, Button类型的控件可命名成btnOK等。
来自：http://hi.baidu.com/haxido/item/1b67cb40178ffbfcdc0f6cce
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7163dff53e4d6c552ee8e6571303e38/" rel="bookmark">
			VS2010 从“const time_t *”到“const __time32_t *”的类型不兼容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接到main/config.w32.h注释到这句 #define _USE_32BIT_TIME_T 1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d27cf0e7bb9919d3f306ebc948a68ab/" rel="bookmark">
			codeblocks 控制台输出乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在CodeBlocks下折腾来半天，终于把中文乱码给解决了，其实很简单。 在环境设置里进行如下设置：
把Terminal to launch console programs那个选项改成
gnome-terminal -t $TITLE -x 原来是xterm -T $TITLE -e 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae58b4e7bf83f995244887e10e7eee4c/" rel="bookmark">
			codeblocks 包含头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接设置：项目－》构建选项－&gt;搜索路径－》编译器，添加目录就可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038dc8c7d6cefe745b636ed9a2933d85/" rel="bookmark">
			PowerDesigner将PDM导出生成WORD文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步，点击Report Temlates 制作模板
第二步，时间问题，我们在PATH小图标中 ，选择我们已经做好的一个FDATemplate模板，并双击，没有模版的朋友，点New图标
这时候，我们左右2个区，Aavailable区域中选择你想要在WORD文档中展示的东东，这里我们选择List ofTables,和List of Table Columns[数据表格信息]
如图，右键点击，Selection
选择你想要在数据表格中展示的信息，想要展示的就打钩
鼠标右键选择LAYOUT样式功能
制作样式
点击保存，一个简单的RTP文档就制作完成了。
接着，我们导出WORD文档
在点击OK按钮之后，就会产生我们期待已久的，WORD文档了
I List oftables Name
Code
FDACaseAccept
FDACaseAccept
FDACaseAcceptDeal
FDACaseAcceptDeal
FDACaseAcceptRevert
FDACaseAcceptRevert
FDACaseCategory
FDACaseCategory
FDACaseDocumentMonitor
FDACaseDocumentMonitor
FDACaseReason
FDACaseReason
FDACaseSources
FDACaseSources
FDACaseSourcesWay
FDACaseSourcesWay
FDACaseSuspectMoney
FDACaseSuspectMoney
II FDACaseAccept Code
Comment
Data Type
Mandatory
Default
Primary
Foreign Key
AcceptCodeID
案件编码
varchar(15)
FALSE
FALSE
FALSE
AcceptId
ID主键
numeric
TRUE
TRUE
FALSE
AcceptUserID
受理人ID
int
FALSE
FALSE
FALSE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/038dc8c7d6cefe745b636ed9a2933d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87169726690a0c1c5ea5a01ac6c08c2d/" rel="bookmark">
			WPF 获取IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List&lt;string&gt; ipList = new List&lt;string&gt;(); foreach (IPAddress _IPAddress in Dns.GetHostEntry(Dns.GetHostName()).AddressList) { if (_IPAddress.AddressFamily.ToString() == "InterNetwork") { ipList.Add(_IPAddress.ToString()); } } 转载于:https://www.cnblogs.com/gaobing/p/3811974.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa7304eb97bdd259f8631dc40203bda/" rel="bookmark">
			吧啦下 Background Geoprocessing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天和大家说一下后台地理处理（GP），说到后台，自然会想到前台。
其实在 ArcGIS Desktop 9.X 以及更早的年代，ArcToolbox 中的工具运行的模式只有前台模式，也就是大家熟悉的情景：运行某个工具，然后工具运行窗口挡在 ArcMap的前面，窗口中的Log不停的滚动，直至工具运行完毕，ArcMap 才能使用。并且，由于 ArcMap 和 ArcCatalog 是 32 的程序，单进程使用的系统资源是有限的。
为了解决这些问题，后台地理处理就产生了，从 ArcGIS 10.0 之后的版本，后台地理处理一直存在着。如果我们现在使用的操作系统是64bit的，那还可以安装后台地理处理64位程序包，在安装光盘中可以找到 ArcGIS for Desktop Background Geoprocessing （64bit）。
为什么安装 ArcGIS for Desktop Background Geoprocessing（64 位）？
因为，后台执行一个工具时，在后台会启动一个新的进程，我们可以理解成开了一个新的 ArcMap，只是没有界面的ArcMap。安装 ArcGIS for Desktop—Background Geoprocessing（64 位） 之后，就替代了原先的常规 32 位后台处理。在 RAM 容量较大的系统中，使用 64 位后台处理，有助于处理在 32 位环境中无法处理的大数据。由于所有执行工作都在原生 64 位空间中完成，因此可使用更多系统资源。
由于新开进程，所以，在打开 ArcMap 之后的第一次执行后台GP，会发现很慢有延迟，之后的几次会很快出现进度条和消息。实际上，后台处理会启动两个进程，两个 RuntimeLocalServer.exe 进程。在工具执行期间不要随便结束这两个进程，否则可能会导致结果异常。
如何选择前台与后台GP处理？
实际上，如果我们只是在做一些日常的小测试，做些小数据量的处理，可能除了结果之外，响应速度是我们关心的，那还是完全可以选择前台的，毕竟省去了新开进程的时间。但是如果仅仅因为在某些情况下的不稳定放弃后台运行，不是很明智，毕竟后台执行GP可以完全不耽误你手头的工作，还能更好的利用系统的资源。后台运行从10.0版本开始产生，早期bug缠身，但是随着版本的更新，日趋稳定，10.2之后也开始支持并行运算，后台处理GP还是个不错的选择。
还是需要注意，什么情况下，后台GP不适用？
后台64GP不支持的数据类型： 个人地理数据库 (.mdb)， Excel 表（.xls、.xlsx） 不在后台运行的工具包括：
元数据转换工具集（Metadata conversion ）中的工具地理数据库管理工具集（Geodatabase administration）中的工具所有 Coverage 工具用于创建包（Packages）的工具绘图工具（Graphing tools）（仅针对 64 位地理处理；这些工具在传统的 32 位后台处理中运行）作者禁用后台处理的自定义脚本、模型或功能工具 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b74921c381ab22329cb4feac50d7f4/" rel="bookmark">
			PHP&#43;MYSQL&#43;APACHE简易环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP+MYSQL+APACHE简易环境搭建
一、 版本
php-5.2.12-Win32-VC6-x86.zip
mysql-5.0.67-win32.zip
httpd-2.0.64-win32-x86-no_ssl.msi（win7用这个版本没有问题）
apache_2.0.50-win32-x86-no_ssl.msi（win7不能用此版本）
二、 安装配置Apache
1、安装Apache
运行相应版本的Apache，出现如下画面：
点击Next&gt;继续下一步。
同意条款(I accept theterms in the license agreement)继续（Next &gt;）
继续下一步(Next &gt;)
此页面为设置系统信息，在Network Domain下填入您的域名（一般用localhost），在Server Name下填入您的服务器名称（一般用localhost）,在Administrator’sEmail Address下填入管理员邮箱，可任意填写，但必须是邮箱的格式。点击Next &gt; 继续下一步
选择安装类型，Typical是默认安装，Custom为自定义安装。多数选择自定义安装，点击Next &gt; 继续下一步
出现选择安装项界面，只需点击Change…选择您所要的安装位置即可，选择好后点击Next &gt; 继续下一步
注意：不要选择系统盘！点击OK继续下一步
点击Next &gt; 继续下一步
如果您要重新配置可以点击 &lt;Back 回退，如果无误点击 Install安装
点击 Finish 完成安装。这时可以在右下角看到Apache的图标
下面我们运行网站页面进行测试，在浏览器地址栏是键入http://127.0.0.1,按下回车键，如果看到如下画面则表示Apache已经安装成功
三、 配置Apache服务器
在安装Apache的文件下的conf找到 httpd.conf 打开（注：不要用记事本、word等打开，可以用EditPlus、dreamwerver等网站工具打开）
找到&lt; DocumentRoot” ” &gt;,把“ “中的地址改成您的网站根目录（就是您项目存放的地址）
找到&lt; Diretory “ “ &gt;，把” “中的改成您的网站根目录
找到DiretoryIndex （目录索引，也就是在仅指定目录的情况下，默认显示的文件名），可以添加很多，系统会以从左至右的顺序来优先显示以单个半角空格隔开，如下：
下面使Apache支持PHP，找到#LoadModulessl_module modules/mod_ssl.so，在其下面写入
LoadModulephp5_module E:/WEB/SERVER/PHP5/php5apache2.dll
PHPIniDir"E:/WEB/SERVER/PHP5"（指定PHP安装目录）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83b74921c381ab22329cb4feac50d7f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74e0650b1a614e600717144c0b4270b7/" rel="bookmark">
			【深度探索 STL】hashtable（哈希表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希表是一个很重要的数据结构，在各大场合均有应用，比如在内核网络栈中的 sock_array 的结构。
之前也学习过哈希表 ，建议看此文之前，先看前面用C++实现的简洁的哈希表。这里通过剖析SGI STL 中的hashtable 来进一步探索hashtable。
SGI STL 中哈希表采用链接法解决冲突。结构中维护了一个 vector，vector 中每一个元素称为一个桶（bucket），它包含的是一个链表的第一个节点。
哈希表的思想这里就不赘述了，直接通过STL 的源码来剖心其内部实现。
一、 hash table 的节点定义：
template &lt;class Value&gt; struct __hashtable_node { __hashtable_node* next; //下一个节点 Value val; //键值 }; bucket 所维护的正是上述的 hash table node。 从上图可知，buckets vector 中存放的是bucket，然后每个bucket 存放链表（如果有的话）。通俗的说bucket 就是动态array 中的一个元素。
二、hashtable 的迭代器：
template &lt;class Value, class Key, class HashFcn, class ExtractKey, class EqualKey, class Alloc&gt; struct __hashtable_iterator { //typedef 定义 typedef hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; hashtable; typedef __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; iterator; typedef __hashtable_const_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; const_iterator; typedef __hashtable_node&lt;Value&gt; node; typedef forward_iterator_tag iterator_category; //迭代器类型 typedef Value value_type; //迭代器所指对象的型别 typedef ptrdiff_t difference_type; //两个迭代器之间的距离 typedef size_t size_type; typedef Value&amp; reference; typedef Value* pointer; node* cur; //迭代器目前所指节点 hashtable* ht; //保持对容器的连结关系（因为可能需要从bucket跳到bucket） /*构造函数*/ __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {} __hashtable_iterator() {} /*运算符重载*/ reference operator*() const { return cur-&gt;val; } pointer operator-&gt;() const { return &amp;(operator*()); } iterator&amp; operator++(); //前缀++ iterator operator++(int); //后缀++ bool operator==(const iterator&amp; it) const { return cur == it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74e0650b1a614e600717144c0b4270b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdded0b939fdc0940638568eb5c642de/" rel="bookmark">
			Xcode文档、模拟器路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Xcode文档安装路径 /Applications/Xcode.app/Contents/Developer/Documentation/DocSets 2.Xcode模拟器安装路径 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 3.模拟器应用程序的安装路径 /Users/aplle/资源库/Application Support/iPhone Simulator/7.1/Applications 来自为知笔记(Wiz) 转载于:https://www.cnblogs.com/David-T/p/3799113.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e37732b2032c8abeae719e279ce865b5/" rel="bookmark">
			为什么不发博客呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到跟自己同一时代的ACMer博客都不怎么跟新了，上次更新时间大多都在2013年，眼看2014年已经过半了，自己也开始即将毕业了，也与ACM接触的不多了，之前的ACMer都已经打算读研或者跟我一样就业或者留学，但是博客还是要发的吧，至少代表这一种不断学习成长的过程，提醒自己更新博客。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/399c1084807f6ca1a8353a885e97c25d/" rel="bookmark">
			深入浅出linux系统umask值及其对应的文件权限讲解 （转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签： linux文件权限 linux系统umask 老男孩培训教案 老男孩培训出书草稿 版权声明：原创作品，如需转载，请与作者联系。否则将追究法律责任。 缘起：
1、此文的撰写特别为感谢51cto的博客工作人员和领导，老男孩博客很荣幸的成为了专家博客，老男孩责任更重了，争取以后加油为大家分享文章。
2、老男孩本人驾驶考试今天正好拿到本（历时2个月，完全靠实力通过，补考一次）。
3、有一些网友和学生总纠结这个umask问题，到处搜索也找不到好的说明文章。
另：本文最值得博友思考的地方不是内容，而是勤于思考并较周全的努力实践的学习心态，然后能够自我下一个比较准确结论的学习记忆的思路，打个比方吧，金庸的小说大家很难记，那么把它搞成对联后就没人能忘记掉了了。在学习linux运维方向同样如此，我们应该多模拟设定一些试验场景去验证测试，最后总结一个自己能牢记住的小结论，这才是学习linux的最佳途径。
本文省略了对linux文件权限和umask基本知识的介绍，有需要的了解的博友可以参看其他资料。
1）简单好用的加减法计算（老男孩推荐）
特别说明：第一种计算法简单、易用、好记，但是由于大部分网友都直接用减法（不考虑此方法的特殊性而被批判）或被某些书籍误导甚至不相信不敢用这个方法了。其实，学习就是一个记忆的思路而已，没有对错，就是多思考多实践，然后，总结一个小技巧结论，有利于自己学习记忆就够了。
最后，老男孩想说的是学习总结结论不是做科学，所以，未必就需要那么严谨，有伪科学的小结论很正常（但追求严谨的心态必须要有），例如：nginx服务配置的标准是什么，mysql优化的标准是什么，装linux系统选择安装包的标准是什么，给系统分区的标准是什么，其实，这些都是没标准答案的，但是这不影响我们学好linux运维，这就是老男孩传导给大家的思维。
文件权限计算小结论：
创建文件默认最大权限为666 （-rw-rw-rw-），默认创建的文件没有可执行权限x位。
对于文件来说，umask的设置是在假定文件拥有八进制666的权限上进行的，文件的权限就是666减去umask(umask的各个位数字也不能大于6，如，077就不符合条件)的掩码数值；重点在接下来的内容，如果umask的部分位或全部位为奇数，那么，在对应为奇数的文件权限位计算结果分别再加1就是最终文件权限值。
创建目录默认最大权限777（-rwx-rwx-rwx）,默认创建的目录属主是有x权限，允许用户进入。
对于目录来说，umask的设置是在假定文件拥有八进制777权限上进行，目录八进制权限777减去umask的掩码数值。
文件权限的一般计算方法：
默认文件权限计算方法 1）假设umask值为：022（所有位为偶数）
6 6 6 ==&gt;文件的起始权限值
0 2 2 - ==&gt;umask的值
---------
6 4 4
2）假设umask值为：045（其他用户组位为奇数）
6 6 6 ==&gt;文件的起始权限值
0 4 5 - ==&gt;umask的值
---------
6 2 1 ==&gt;计算出来的权限。由于umask的最后一位数字是5，所以，在其他用户组位再加1。
0 0 1 +
---------
622 ==&gt;真实文件权限
默认目录权限计算方法 7 7 7 ==&gt;目录的起始权限值
0 2 2 - ==&gt;umask的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/399c1084807f6ca1a8353a885e97c25d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c74517ce28ee8f9623a9a14f420eb04c/" rel="bookmark">
			通过global_dbname和dbname访问数据库的不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两者的主要区别是: 全局数据库名访问 用于客户端和服务端在2个不同的域之间
数据库名（实例名）访问 用于客户端和服务端在同一个域内
数据库名访问举例：
只需要在客户端的tnsname.ora文件中配置如下信息：
ORA11G_243 = // ORA11G_243 可随便定义
(DESCRIPTION =
(ADDRESS = (PROTOCOL = TCP)(HOST = xxx.xxx.xxx.xxx)(PORT = xxxx)) //服务端IP地址和端口根据实际情况填写
(CONNECT_DATA =
(SERVER = DEDICATED)
(SERVICE_NAME = xxxx) //服务名填写服务端数据库实例名，即SID
)
)
全局数据库名访问举例：
首先在服务端修改监听文件listener.ora，配置如下信息：
SID_LIST_LISTENER =
(SID_LIST =
(SID_DESC =
(GLOBAL_DBNAME = ora11g)
(ORACLE_HOME = /oracle/app/product/11g/db)
(SID_NAME = ora11g)
)
(SID_DESC =
(GLOBAL_DBNAME = ora11g.home1) // 这里就是全局数据库名，通常格式为 db_name.db_domain
(ORACLE_HOME = /oracle/app/product/11g/db)
(SID_NAME = ora11g) //服务端数据库实例名，即SID
)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c74517ce28ee8f9623a9a14f420eb04c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b14809b4838faaa6de1e6e374f5e0601/" rel="bookmark">
			IE 浏览器 如何关闭令人讨厌的“此网站需要运行以下加载项：XXX。如果您信任该网站和该加载项并允许运行该加载项，请单击这里......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、运行gpedit.msc
2、在打开的组策略中打开用户配置——管理模板——Windows组件——Internet Explorer
3、选择“关闭ActiveX选择启用提示”，将其状态改为“已启用”。
转载于:https://www.cnblogs.com/williamchang/p/3795529.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/682c121ec3fad2b108642202a9890b50/" rel="bookmark">
			【网络协议】TCP协议简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文只是对TCP协议做个简要的介绍。
TCP协议，即传输控制协议，与UDP协议同处于传输层，同样使用相同的网络层，但TCP提供了一种可靠的、面向连接的数据传输服务，它会在两个使用TCP的应用之间建立一个TCP连接，在该连接上进行数据的传输。
TCP通过以下方式提供可靠性：
1、应用程序被分割成TCP认为最合适发送的数据块。这点与UDP完全不同，应用程序产生的UDP数据报长度将保持不变，加上IP首部后，才会进行IP分片。
2、当TCP发出一个报文段后，它会启动一个定时器，等待目的端发确认收到这个报文段，如果没能及时收到该确认信息，则将重发这个报文段。
3、当TCP接收端收到发送端发来的TCP报文段时，它将发送一个确认，这个确认不是立即发送的，通常会推迟几分之一秒。
4、TCP将保持它首部和数据的校验和。这是一个端到端的校验和，如果收到的报文段的校验和有差错，TCP将丢弃该报文段，同时不发送确认收到的消息，从而使发送端超时重发。
5、TCP能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间，TCP的接受端只允许另一端发送接收端缓冲区所能接纳的数据，这将防止较快主机致使较慢主机的缓冲区溢出。
6、由于TCP报文段作为IP数据报来传输，IP数据报的到达可能会失序，因此TCP报文段的到达也可能失序，如果必要，TCP将对收到的数据进行重排序，将收到的数据以正确的顺序交给应用层。
7、由于IP数据报有可能发生重复，TCP的接收端必须丢弃重复的数据。
从上面几点可以看出，TCP协议保持可靠性的方式就是超时重传，这种方式很好，虽然TCP也可以通过向源主机发送各种各样的ICMP报文或者来处理这些，但这也是不可靠的，试想，如果ICMP报文在发送回来的过程中丢失了，很明显这种方式就不可靠了。最可靠的方式就是只要得不到确认，就重新发送数据，直到得到确认为止。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e05be28282538a7c7dacf90fc9d888b2/" rel="bookmark">
			关于开发中的虚拟机介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们通常所说的虚拟化主要是指平台虚拟化技术，通过使用控制程序（Control Program，也被称 为 Virtual Machine Monitor 或 Hypervisor），隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的 计算环境（称为虚拟机）。在[url=http://www.shopjsp.com/]java商城开发[/url]以及[url=http://www.shopjsp.com/]jsp商城[/url]开发中虚拟机中运行的操作系统被称为客户机操作系统（Guest OS），运行虚拟机监控器的操作系统被称为主机操作系统 （Host OS），当然某些虚拟机监控器可以脱离操作系统直接运行在硬件之上（如 VMWARE 的 ESX 产品）。运行虚拟机的真实系统我们称之为 主机系统。 可以想象一下，未来的虚拟化发展将会是多元化的，包括服务器、存储、网络等更多的元素，用户将无法分辨哪些是虚，哪些是实。虚拟化将改变现在的传统IT架 构，而且将互联网中的所有资源全部连在一起，形成一个大的计算中心，而我们却不用关心所有这一切，而只需关心提供给自己的服务是否正常。虽然虚拟化技术前 景看好，但是，这一过程还有很长的路要走，因为还没有哪种技术是不存在潜在缺陷甚至陷阱的。但是相信，虚拟化技术将会成为未来的主要发展方向。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b610d658244d9ade346e16e623c2a7c/" rel="bookmark">
			jquery ajaxSubmit 异步提交的简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了jquery ajaxSubmit 异步提交的简单实现。需要的朋友可以过来参考下，希望对大家有所帮助
前台js
$("#nickForm").ajaxSubmit({ type: "post", url: "http://localhost:8080/test/myspace.do?method=updateNick¶m=1", dataType: "json", success: function(result){ //返回提示信息 alert(result.nickMsg); } }); 后台封装： public ActionForward toUpdateNickName(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response){ PrintWriter pw = response.getWriter(); JSONObject obj = new JSONObject(); obj.put("nickMsg", "昵称修改成功！"); pw.print(obj); pw.close(); } 详细出处参考：http://www.jb51.net/article/47391.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e988b20a7cfa4c4c3cd4dfaf30b6f638/" rel="bookmark">
			UEditor Java 上传图片配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不使用默认的ueditor-mini.jar进行上传，自定义上传 关于UEditor的搭建我这里就不用细说了，这个官网的例子很详细 这里只说配置上传，使用的springmvc 首先找到umeditor.config.js，找到下面这样的代码 //为编辑器实例添加一个路径，这个不能被注释
UMEDITOR_HOME_URL : URL
//图片上传配置区
,imageUrl:URL+"jsp/imageUp.jsp" //图片上传提交地址
,imagePath:URL + "jsp/" //图片修正地址，引用了fixedImagePath,如有特殊需求，可自行配置 ,imageFieldName:"upfile" //图片数据的key,若此处修改，需要在后台对应文件修改对应参数
现在来说一下上面的参数： URL，这里指向的是你项目的ueditor文件夹 比如我的umeditor.js放在项目webroot/ueditor/umeditor.js这里，那么URL就是 HTTP://ip:port/webname/ueditor/， 当然具体的地址要根据你的配置文件而定 其中的imageFieldName:"upfile"这里的upfile就是&lt;input type="file" name="upfile"/&gt;这个upfile很重要，后台的数据就靠它获得，你这里修改了后台也要做相应处理 然后把上面的代码修改成指向自己写的contorller //为编辑器实例添加一个路径，这个不能被注释
UMEDITOR_HOME_URL : URL
//图片上传配置区
,imageUrl:root+"/upload/img" //图片上传提交地址
// ,imageUrl:URL+"jsp/imageUp.jsp" //图片上传提交地址
// ,imagePath:URL + "jsp/" //图片修正地址，引用了fixedImagePath,如有特殊需求，可自行配置
// 这里的imagePath就是下面的_file方法
// 其路径是root/upload/file/+result.url，result是上传返回的json
,imagePath:root + "/upload/file/" ,imageFieldName:"upfile" //图片数据的key,若此处修改，需要在后台对应文件修改对应参数
里面的root是项目的根路径 /upload/img就是后台的controller处理地址 /upload/file/也是后台的处理地址，这个这里有一点要注意，我在controller里说明 接下来是/upload/img的controller /**
* @upfile 就是上面提到的upfile，要对应一致
*/
@RequestMapping("/upload/img")
@ResponseBody
public String upload(@RequestParam("upfile") MultipartFile upfile,HttpServletRequest request, HttpServletResponse response) throws Exception {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e988b20a7cfa4c4c3cd4dfaf30b6f638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f92777ce1c91ddce30a877009378931/" rel="bookmark">
			在Ubuntu安装JDK并且配置在Sudo下可执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu14.04默认没有安装JDK或者OpenJDK，我需要自己安装，至于安装方法网上一大堆，基本路数就是去Oracle下载tar文件，解压，配置CLASSPATH和JAVA_HOME。
这些都没有问题，可是我安装好了之后，发现普通用户模式下执行java命令没有问题，比如java -version。 但是有的时候你需要使用sudo方式来执行默写以来java环境的程序，这个时候就会报错，说找不到java命令，在网上查了半天，发现一些文章说使用“sudo -E java -version" 或者”sudo -s java -version"就可以执行了，我也查了下，这两个命令选项都有保留当前用户环境变量，阻止sudo执行重置环境变量的功用，但是非常悲催的，我发现在我及其的Ubuntu上，这个两个命令都不行，于是，继续找，终于被我找到了下面这个链接里面提到的如何在Ubuntu上安装和配置JDK。
http://www.wikihow.com/Install-Oracle-Java-on-Ubuntu-Linux
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd9ef60519a321e346f1fa126cda1d7/" rel="bookmark">
			Ubuntu安装为知笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来想安装Evernote的，结果发现居然没有Linux版本的，于是搜索了一下，发现很多人在用为知笔记，于是也装个试试，在这记录下安装过程，留着以后重装的时候可以参考。
在终端下执行如下命令：
$ sudo add-apt-repository ppa:wiznote-team
$ sudo apt-get update
$ sudo apt-get install wiznote
启动的时候，在命令行下输入：
WizNote
应该有更好的办法，现在先不研究了，回头研究了再更新在这里。
查了一把，本来打算给wiznote添加desktop文件，结果去/usr/share/applications目录下一看，已经有了，那就更好办了，在系统左上角的Dash主页中，搜索wiznote，然后把它拖到侧边的快速启动栏，就OK了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01031a6923fc12a42d38f07925e97a56/" rel="bookmark">
			Ubuntu安装sogou中文输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Ubuntu的时候，选择了安装中文输入，结果进去后发现，安装的是google拼音，还有一堆其他的拼音，双拼和五笔输入法，全都是平时不怎么用的，于是想删除然后安装sogou的linux版本。
由于对Ubuntu不熟悉，折腾了半天想找一个类似windows下面的输入法设置的界面，死活没有找到。于是，直接下载sogou的Ubuntu安装文件，双击安装的时候，又出错。
于是，想到彻底删除掉，然后再装，如下步骤：
在Ubuntu软件中心中搜索 fcitx然后卸载所有的相关项目下载sogou输入法linux版双击下载的sogou输入法文件等待安装，然后重启，就可以在右上方的键盘图标下找到sogou输入法了 如下图：
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677d654156eef7a49644b5e4fd6e9ae5/" rel="bookmark">
			android下的简单win8风格。win8style
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章都是参考别人的源码记录下来，参考了好几个版本的win8风格代码，这个算是最简单的，就是贴图，稍微好点的会带动态效果，根据用户按压的区域图片在相应的位置有倾斜的旋转。win8风格主要在布局上的设计，不过在以后的博客上会继续有关于win8风格的android源程序，动态效果做的很炫。直接看源代码，在本例子中，只看xml文件就够了，。。其它都是加载的图片
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="horizontal" android:paddingTop="30dp" android:paddingBottom="30dp" android:paddingLeft="20dp" android:background="@drawable/rootblock_default_bg" &gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="fill_parent" android:orientation="vertical" android:layout_weight="1"&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_width="108dp" android:layout_height="108dp" android:background="#FF7F24"&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="108dp" android:layout_height="108dp" android:layout_marginLeft="5dp" android:background="#FF7F24"&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="5dp" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_width="108dp" android:layout_height="108dp" android:background="#3399ff"&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="108dp" android:layout_height="108dp" android:layout_marginLeft="5dp" android:background="#3399ff"&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="5dp" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_width="108dp" android:layout_height="108dp" android:background="#3399ff"&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="108dp" android:layout_height="108dp" android:layout_marginLeft="5dp" android:background="#3399ff"&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/677d654156eef7a49644b5e4fd6e9ae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb4cb424f9e928cafa8c8a10898b633/" rel="bookmark">
			YModem协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YModem协议：
YModem协议是由XModem协议演变而来的，每包数据可以达到1024字节，是一个非常高效的文件传输协议。
下面先看下YModem协议传输的完整的握手过程：先看下图
SENDER:发送方。
RECEIVER:接收方。
第一步先由接收方，发送一个字符'C'
发送方收到'C'后，发送第一帧数据包，内容如下：
SOH 00 FF Foo.c NUL[123] CRC CRC
第1字节SOH:表示本包数据区大小有128字节。如果头为STX表示本包数据区大小为1024
第2字节00: 编号，第一包为00,第二包为01，第三包为02依次累加。到FF后继续从0循环递增。
第3字节FF: 编号的反码。 编号为00 对应FF，为01对应FE，以此类推。
第4字节到最后两字节：若第1字节为SOH时有128字节，为STX时有1024字节，这部分为数据区。“Foo.c” 文件名， 超级终端下，在文件名后还有文件大小。官方dome也是因为使用了这个文件大小进行比对。这就是为什么用SecureCRT中的YMODEM协议而无法正确传输的原因。在文件名和文件大小之后，如果不满128字节，以0补满。
最后两字节：这里需要注意，只有数据部分参与了效CRC验,不包括头和编码部分。
16位CRC效验，高字节在前，低字节在后。
接收方收到第一帧数据包后，发送ACK正确应答。
然后再发送一个字符'C'。
发送方收到'C'后，开始发送第二帧，第二帧中的数据存放的是第一包数据。
接收方收到数据后，发送一个ACK然后等待下一包数据传送完毕，继续ACK应答。直到所有数据传输完毕。
数据传输完毕后，发送方发EOT，第一次接收方以NAK应答，进行二次确认。
发送方收到NAK后，重发EOT，接收方第二次收到结束符，就以ACK应答。
最后接收方再发送一个'C'，发送方在没有第二个文件要传输的情况下，
发送如下数据
SOH 00 FF 00~00(共128个) CRCH CRCL 接收方应答ACK后，正式结束数据传输。
以上部分，为YMODEM协议的基本操作流程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc29401365480547060210a6d034bf45/" rel="bookmark">
			qt中修改系统或用户环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要修改系统的环境变量只能是修改注册表。
1.修改或增加系统的环境变量，vista以上的系统需要uac权限
&lt;1&gt;注册表地址:HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Session Manager\\Envrionment
&lt;2&gt;使用QSetting s(regPath, QSettings::NativeFormat); s.setValue("Path",";c:/boost/bin");
2.修改或增加当前用户的环境变量
&lt;1&gt;用户的当前环境变量比较恶心，因为注册表是这么给出的：
这里其实我们需要的是S-1-5-21-20851841.....，问题是这个序号每个用户都是不一样的，怎么得到当前用户的注册表路径呢，
如下：
将HKEY_USERS\S-1-5-21-20851841.....修改为HKEY_CURRENT_USER\Environment其他的也就一样了。OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92c61f6a2cc77aacbf958b48c83a827/" rel="bookmark">
			自动更新时，设置IIS  MIME类型 支持apk和.ipa的文件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为IIS的默认MIME类型里没有.apk和.ipa的文件，所以无法通过网络直接下载。 解决办法：既然.apk .ipa无法下载是因为没有MIME，那么添加一个MIME类型就可以了。 解决步骤： 1）、打开IIS服务管理器，找到服务器，右键-属性，打开IIS服务属性； 2、单击MIME类型下的“MIME类型”按钮，打开MIME类型设置窗口； 3）、单击“新建”，建立新的MIME类型； 扩展名是：.apk MIMI类型是：application/vnd.android.package-archive 扩展名是：.ipa MIMI类型是：application/iphone 4）、单击“确定”保存设置。重启IIS，使设置生效。 如此操作之后，使用IIS服务器的网站便可以下载.apk文件、.ipa文件了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aac341452e443b8ff7a1cd930d41762/" rel="bookmark">
			TDSSNIClient initialization failed with error 0x2, statuscode 0x1.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		After I modify the IP on the DB server , when I restore the modify but my SQLserver service can not start normally and I Cannot open SQLserver configuration manger,you can found some error log in the windows application log. Symptoms error log 1:
SQL Server could not spawn FRunCM thread. Check the SQLServer error log and the Windows event logs for information about possible relatedproblems.
error log 2:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aac341452e443b8ff7a1cd930d41762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15636f8b9a408144fa7a8e9ac13cc88b/" rel="bookmark">
			intellij idea背景色设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 绿色RGB 对眼睛有益的RGB数值分别是（199,237,204）
Idea背景色设置路径 File &gt; Settings &gt; Editor &gt; General &gt; Default text Eclipse背景色设置路径 Windows-&gt;Preferences-&gt;General-&gt;Editors-&gt;Text Editors Appearance Color options:Background color 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8767519fb87f334232a5dd31039e3916/" rel="bookmark">
			一个用SSH框架开发的简单的登录注册系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我用SSH框架开发的一个简单的注册登录系统，包括js校验，css前端样式呈现等等；下面来详细介绍系统的开发流程：
软硬件平台
软件环境
1.win7 32为操作系统；
2.MyEclipse10.5；
3.Tomcat7.0；
4.Java EE6；
5.jdk1.7；
6.MySQL 5.6；
硬件环境
CPU：Intel Pentium Dual-Core T4500 2.3GHZ处理器；
内存：2G；
项目所依赖的包：Hibernate3.0；Spring3.0；Struts2；struts-dojo-plugin-2.3.1.2；struts-spring-plugin-2.0.11.2；
项目的总体架构图如下：
以下为前端的呈现界面：
以下为核心代码：
其中，将com.yile.vo包下的Users实体类的代码粘贴如下：
package com.yile.vo;
import java.io.Serializable;
public class User implements Serializable {
private Integer id;
private String userName;
private String password;
public Integer getId() {
return id;
}
public void setId(Integer id) {
this.id = id;
}
public String getUserName() {
return userName;
}
public void setUserName(String userName) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8767519fb87f334232a5dd31039e3916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97bc8b7b66262892d180200ca5e8c898/" rel="bookmark">
			Java 延时常见的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 用Thread就不会iu无法终止 new Thread(new Runnable() { public void run() { while (true) { test(); try { Thread.sleep(500); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } private void test() { // TODO Auto-generated method stub } public Runnable start() { // TODO Auto-generated method stub return null; } }.start()); 2、 或者用现成的 javax.swing.Timer timer = new javax.swing.Timer(500, new ActionListener() { public void actionPerformed(ActionEvent e) { repaint(); } }； timer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97bc8b7b66262892d180200ca5e8c898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6b01ff1b816b2a659d657669174fa8/" rel="bookmark">
			VMware-workstation-full-10.0.2中英文切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware-workstation-full-10.0.2-1744117安装默认为中文版，
如果要使用英文版做如下操作：
找到你的VMware安装目录：例如：
D:\Program Files (x86)\VMware\VMware Workstation\messages
有ja、zh_CN两个语言包，只需要把zh_CN文件夹重命名，或移动保存到其他盘符，再重启VMware，就是英文了，
如果要使用中文版则把zh_CN文件夹恢复回来即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/456073c660704413b1f4970023873729/" rel="bookmark">
			汇编移位: SHL、SHR、SAL、SAR、ROL、ROR、RCL、RCR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SHL、SHR、SAL、SAR: 移位指令 ;SHL(Shift Left): 逻辑左移 ;SHR(Shift Right): 逻辑右移 ;SAL(Shift Arithmetic Left): 算术左移 ;SAR(Shift Arithmetic Right): 算术右移 ;其中的 SHL 和 SAL 相同, 但 SHR 和 SAR 不同. ;SHL、SAL: 每位左移, 低位补 0, 高位进 CF ;SHR : 每位右移, 低位进 CF, 高位补 0 ;SAR : 每位右移, 低位进 CF, 高位不变 ;它们的结果影响 OF、SF、ZF、PF、CF ;它们的指令格式相同: SHL r/m, i8 SHL r/m, CL
ROL、ROR、RCL、RCR: 循环移位指令
;ROL(Rotate Left): 循环左移 ;ROR(Rotate Right): 循环右移 ;RCL(Rotate through Carry Left): 带进位循环左移 ;RCR(Rotate through Carry Right): 带进位循环右移 ;ROL: 循环左移, 高位到低位并送 CF ;ROR: 循环右移, 低位到高位并送 CF ;RCL: 循环左移, 进位值(原CF)到低位, 高位进 CF ;RCR: 循环右移, 进位值(原CF)到高位, 低位进 CF ;它们的结果影响 OF、CF ;它们的指令格式相同: SHL r/m, i8 SHL r/m, CL
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbc6ea184d4bdcd1f09a6b1b475c0c42/" rel="bookmark">
			Vim下批量删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我今天遇到了这样一个情景：需要在Vim下批量删除C++下的注释，也就是需要把“//”及其后面的字符全部删除掉，初步见识了模式匹配的强大简洁，在此做一个备忘，日后补充一些关于正则表达式、模式匹配的内容进来。
批量删除“//”及其后面所有的字符的命令：
：%s/ \/\/.*/ \是转义字符。举一反三可以完成许多批量操作的命令Magical &amp; Powerful TODO: 感觉有必要继续深入的学习一下Regular Expression
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b9ba9add85b9860dd6a1d9c668b5a2/" rel="bookmark">
			print与printf的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		print与printf的区别 1，print 中不能使用%s ,%d 或%c；
2，print 自动换行，printf 没有自动换行。
[root@localhost awk-study]# awk '{n++}END{printf("last word is: %s\n", $NF)}' test.c
last word is: 2432tt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7435c65acd86a62469f946267fca9028/" rel="bookmark">
			boost进程间通信常用开发一篇全（消息队列，共享内存，信号）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文概要： 敏捷开发大家想必知道而且评价甚高，缩短开发周期，提高开发质量。将大工程独立为不同的小app开发，整个开发过程，程序可用可测，所以提高了整体的质量。基于这种开发模式和开发理念，进程间通信必然是童鞋们必掌握技能之一了，而boost库是众多库中平台支持性很好，效果很高之一。做嵌入式或者服务器等应用的人肯定有所涉及。本文以手册方式讲述boost共享内存，信号，以及消息队列的编程方式。很简单，列出最常用用法，供大家拷贝直接使用。本文出自CSDN-固本培元。转载注明出处-leoluopy@gmail.com。
应用思路注意事项： 信号是进程内通信，非常类似于Qt的信号槽，配合消息队列以及boost多线程使用效果很好。 共享内存： #include &lt;boost/interprocess/shared_memory_object.hpp&gt; #include &lt;boost/interprocess/mapped_region.hpp&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; int main(int argc, char *argv[]) { using namespace boost::interprocess; if(argc == 1){ //Parent process //Remove shared memory on construction and destruction struct shm_remove { shm_remove() { shared_memory_object::remove("MySharedMemory"); } ~shm_remove(){ shared_memory_object::remove("MySharedMemory"); } } remover; //Create a shared memory object. shared_memory_object shm (create_only, "MySharedMemory", read_write); //Set size shm.truncate(1000); //Map the whole shared memory in this process mapped_region region(shm, read_write); //Write all the memory to 1 std::memset(region.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7435c65acd86a62469f946267fca9028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec9ca179a87ec52740a0d1258de31f07/" rel="bookmark">
			转：OIO、NIO、AIO的区别是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上很多IO资料，对新手来说，越看越晕。根据自己的理解，总结对比了一下OIO、NIO、AIO。
OIO：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。如下图：
NIO(reactor模型)：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。如下图：
AIO(proactor模型)：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a960b657590aeb3382ee3b93d6bf6ae4/" rel="bookmark">
			BIO、NIO、AIO区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上很多IO资料，对新手来说，越看越晕。根据自己的理解，总结对比了一下BIO、NIO、AIO。
BIO：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。如下图：
NIO(reactor模型)：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。如下图：
AIO(proactor模型)：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。如下图：
个人浅见，欢迎拍砖！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa86ad810e4bcd3982bdcbdbcff78e5/" rel="bookmark">
			javascript for语句最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当执行冗长的for语句时，要保持语句块的尽量简洁，例如： 糟糕！！ for(var i = 0; i &lt; someArray.length; i++) { var container = document.getElementById('container'); container.innerHtml += 'my number: ' + i; console.log(i); } 这样每次循环都要计算数组的长度，并且每次都要遍历dom查询“container”元素——效率严重地下！ 建议！！ var container = document.getElementById('container'); for(var i = 0, len = someArray.length; i &lt; len; i++) { container.innerHtml += 'my number: ' + i; console.log(i); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e89b14d4638e4c79edbcde580c249874/" rel="bookmark">
			win2008 64位支持32位Asp.net程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在windows2008 x64位系统下的IIS7下部署asp.net程序。
vs2005或vs2008默认的情况下是Any cpu 的也就是支持x86和x64两种系统的。可我的程序在引用了一个三方dll组件时引起了这样的错误：
错误“/test”应用程序中的服务器错误。 -------------------------------------------------------------------------------- 未能加载文件或程序集“XXX”或它的某一个依赖项。试图加载格式不正确的程序。 说明: 执行当前 Web 请求期间，出现未处理的异常。请检查堆栈跟踪信息，以了解有关该错误以及代码中导致错误的出处的详细信息。 异常详细信息: System.BadImageFormatException: 未能加载文件或程序集“XXX”或它的某一个依赖项。试图加载格式不正确的程序。 源错误: 执行当前 Web 请求期间生成了未处理的异常。可以使用下面的异常堆栈跟踪信息确定有关异常原因和发生位置的信息。 程序集加载跟踪: 下列信息有助于确定程序集“XXX”无法加载的原因。 警告: 程序集绑定日志记录被关闭。 要启用程序集绑定失败日志记录，请将注册表值 [HKLM\Software\Microsoft\Fusion!EnableLog] (DWORD)设置为 1。 注意: 会有一些与程序集绑定失败日志记录关联的性能损失。 要关闭此功能，请移除注册表值 [HKLM\Software\Microsoft\Fusion!EnableLog]。 在网上搜索了N久。查询到如下信息。
ASP.NET 程序在编译的时候默认是Any CPU ，即编译的程序可以在X86 、X64 系统平台上运行。若希望我们的ASP.NET 程序运行在X64 系统上，我们所要做的仅仅是部署IIS ，修改配置。 若想程序运行于IIS32 位模式下，即运行在.net framwork32 位下进行如下配置： 1.cscript %systemdrive%\inetpub\adminscripts\adsutil.vbs set w3svc/appPools/enable32bitapponwin64 1 修改IIS 配置，允许32 位程序运行 2.C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_regiis -i 为IIS 注册asp.net32 。注册后在IIS 的web 扩展里显示的是Asp.net2.0.*32bit 。 3.Web 扩展里允许 Asp.net2.0.*32bit 运行。运行的是w3wp32.exe 进程。 二.64 位模式 1.cscript %systemdrive%\inetpub\adminscripts\adsutil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e89b14d4638e4c79edbcde580c249874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b4e1eddc6fad585db0078a24d326831/" rel="bookmark">
			linux上安装oracle后，客户端连接报出ORA-12505的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux上安装了oracle11gR2，配置好监听后可用，由于网络原因修改ip后再次启动客户端连接时提示连接失败，把/home/oracle/app/oracle/product/11.2.0/dbhome_1/network/admin/listener.ora中HOSTNAME改为固定ip后再次连接，出现ORA-12505异常
状态: 失败 -测试失败: Listener refused the connection with the following error: ORA-12505, TNS:listener does not currently know of SID given in connect descriptor 查了下资料，把listener.ora中的sid重新指定，改为如下后，再次连接正确 # listener.ora Network Configuration File: /home/oracle/app/oracle/product/11.2.0/dbhome_1/network/admin/listener.ora # Generated by Oracle configuration tools. LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.104)(PORT = 1521)) ) ) SID_LIST_LISTENER = (SID_LIST = (SID_DESC = # (GLOBAL_DBNAME = ORCL) (ORACLE_HOME = /home/oracle/app/oracle/product/11.2.0/dbhome_1) (SID_NAME = orcl) ) ) ADR_BASE_LISTENER = /home/oracle/app 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b7f8d00421b26240bcc84d67eac49a/" rel="bookmark">
			linux下java应用启动参数配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际部署java应用时，在sun jdk1.6的环境下，为使应用能够高效率长时间稳定运行，需要配置特定的虚拟机参数。每到此时都会想有没有一个基准配置用来供选择，使用基准配置就可以使服务器性能达到一个较高水准，下面就根据实际使用情况，列出必选配置与可选配置，供系统测试或系统上线使用。
一、必选：
1、jvm类型 -server 一定要作为第一个参数，在多个CPU时性能佳，默认模式。 默认，服务端模式，启动慢，运行快，占用内存较大，编译器优化 -client 客户端模式，启动快，占用内存较小，编译器优化 使用下列命令可以查看初始占用： java -client -XX:+PrintFlagsFinal -version 2&gt;&amp;1 | grep -i -E 'heapsize|permsize|version' -XX:+PrintCommandLineFlags ，这个参数的作用是显示出VM初始化完毕后所有跟最初的默认值不同的参数及它们的值 java -XX:+PrintCommandLineFlags -d64 64位java环境，建议需要使用4G以上内存时使用。同时添加压缩对象参数： -XX:+UseCompressedOops -d32 32位java环境，普通情况下使用。 -DTEST=TEST1 设置环境变量TEST的值为TEST1 2、gc相关 -verbose:gc 打开gc日志开关 -Xloggc:./log/gc.log 将GC日志进行记录，后边可跟相对路径或绝对路径 -XX:+PrintGCDetails JVM做GC时在gc日志里记录详细的gc信息 -XX:+PrintGCTimeStamps 了解垃圾收集发生的时间 -XX:+PrintGCApplicationStoppedTime 打印垃圾回收期间程序暂停的时间 回收器选择 JVM给了三种选择(三选一，默认为并行收集器)：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。 默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。 1、串行收集器 --适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。 --缺点：只能用于小型应用 -XX:+UseSerialGC：设置串行收集器 2、并行收集器(吞吐量优先) --适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。 --缺点：应用响应时间可能较长 -XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 -XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 -XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。 -XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒），如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 -XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等。 此参数建议使用并行收集器时，一直打开。 3、并发收集器(响应时间优先) --适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。 CMS， 全称Concurrent Low Pause Collector，是jdk1.4后期版本开始引入的新gc算法，在jdk5和jdk6中得到了进一步改进，它的主要适合场景是对响应时间的重要性需求 大于对吞吐量的要求，能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用。CMS是用于对tenured generation的回收，也就是年老代的回收，目标是尽量减少应用的暂停时间，减少FullGC发生的几率，利用和应用程序线程并发的垃圾回收线程来 标记清除年老代。 -XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了。所以，此时年轻代大小最好用-Xmn设置。 -XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73b7f8d00421b26240bcc84d67eac49a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b174e6a955144f2698069bcb579cfce/" rel="bookmark">
			Ember学习（5）：计算型属性和使用@each聚合数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 英文原址：http://emberjs.com/guides/object-model/computed-properties-and-aggregate-data/
通常，你可能会定义一个计算型属性，它的值依赖于一个数组中的所有元素的值。比如说，你可能想要对controller中的所有todo项目来计数，以统计它们中的多少是完成了的，下面说明了它可能会是什么样的：
App.TodosController = Ember.Controller.extend({ todos: [ Ember.Object.create({ isDone: false }) ], remaining: function() { var todos = this.get('todos'); return todos.filterBy('isDone', false).get('length'); }.property('todos.@each.isDone') }); 注意这里，它依赖的关键字是todos.@each.isDone，其中含有关键字@each。这指示Ember在下列事件发生时，自动为这个计算型属性更新绑定并且触发观察事件： 任意一个todos数组中的元素的isDone属性改变时一个新的元素被添加到todos数组从todos数组中删除一个元素controller中的todos数组本身被改变以指向不同的数组 在上面的例子中，remaining的值是1 App.todosController = App.TodosController.create(); App.todosController.get('remaining'); // 1如果我们改变todo的isDone属性，remaining属性的值会自动更新： var todos = App.todosController.get('todos'); var todo = todos.objectAt(0); todo.set('isDone', true); App.todosController.get('remaining'); // 0 todo = Ember.Object.create({ isDone: false }); todos.pushObject(todo); App.todosController.get('remaining'); // 1 请注意，@each只能对往下一层生效。你不能对它使用嵌套的形式，比如todos.@each.owner.name或者todos.@each.owner.@each.name。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/310/">«</a>
	<span class="pagination__item pagination__item--current">311/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/312/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>