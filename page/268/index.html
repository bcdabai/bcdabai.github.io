<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b77d471d186628d76128a1522876cf3/" rel="bookmark">
			内核调试器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Section #1. Kernel Debuggers
The instruction-level Kernel DeBugger (kdb) and the source-level Kernel GNU DeBugger (kgdb) are the two main Linux kernel debuggers. Whether to include a debugger as part of the stock kernel has been an oft-debated point in kernel mailing lists, but a lightweight version of kgdb has finally been integrated with the mainline kernel starting with the 2.6.26 release. Even if you prefer to stay away from the seemingly esoteric operation of kernel debuggers, you can glean information about kernel panics and peek at kernel variables via the plain GNU DeBugger (gdb).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b77d471d186628d76128a1522876cf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1405aa9ae7fb0c21c1b5d1f5a6a62582/" rel="bookmark">
			SpringBoot 日志 Log4j比System.out.println的优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Log4j比System.out.println的优势 log4j可以自己定义日志文件的，命名规则，备份规则，存放路径，system.out默认输出到控制台log4j 可以自己定义日志的格式，使得日志可读性更加好log4j 可以灵活使用日志的级别，通过设置日志级别，可以在不同的运行环境使用不同的日志级别，从而达到只输出我们需要的日志到文件的目的。 （日志级别从小到大：debug,info,warn,error） SpringBoot 日志， 默认日志级别是info, 默认日志采用sl4j package com.controller; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @Description: java类作用描述 * @Author: Bsea * @CreateDate: 2019/6/7$ 20:15$ */ @RestController public class TestController { private Logger log = LoggerFactory.getLogger(this.getClass()); @RequestMapping("/show1") public String t1(){ log.debug("这个是debug-测试 基本的日志信息"); log.info("这个是info-普通信息 基本的日志信息"); log.warn("这个是warn-警告 基本的日志信息"); log.error("这个是error--错误 基本的日志信息"); return "tt"; } } 测试结果：
2019-06-07 20:19:11.599 INFO 5748 — [nio-8080-exec-1] com.controller.TestController : 这个是info-普通信息 基本的日志信息
2019-06-07 20:19:11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1405aa9ae7fb0c21c1b5d1f5a6a62582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fda5ee66c13124860835ef2968980b2/" rel="bookmark">
			PN结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直不太能理解PN结问题，今天学习了来做一做总结。
PN结正向偏置：低阻状态，导通状态
PN结反向偏置：高阻态，近似于截止状态
PN结电流方程：
UT：等效电压——&gt;KT/q
Is：反向饱和电流
阳极为P区，阴极为N区
PN结的电容效应 ：
(1) 势垒电容CB ：（耗尽层宽窄变化）（反偏）
(2) 扩散电容CD
扩散电容是由多子扩散后，在PN结的另一侧面积累而形成的。因PN结正偏时，由N区扩散到P区的电子，与外电源提供的空穴相复合，形成正向电流。反之，由P区扩散到N区的空穴，在N区内也形成类似的浓度梯度分布曲线。
当外加正向电压不同时，扩散电流即外电路电流的大小也就不同。所以PN结两侧堆积的多子的浓度梯度分布也不同，这就相当电容的充放电过程。势垒电容和扩散电容均是非线性电容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547d1755779614212e20ff99493ff5fa/" rel="bookmark">
			vue：跨域以及sessionId不一致问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情景：
使用Vue和SpringBoot做前后端分离项目，出现跨域问题，因为前端访问调用后端3个接口，
第一：session校验 ，第二：登录 ，第三：查询接口
但是将session分别获取，然后打印出来，发现sessionid不一致，导致访问第三个查询数据接口而失败。
后端springboot处理： 拦截器preHandle中加入如下 代码：
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception { response.setHeader("Access-Control-Allow-Origin",request.getHeader("Origin")); response.setHeader("Access-Control-Allow-Methods", "*"); response.setHeader("Access-Control-Allow-Credentials", "true"); response.setHeader("Access-Control-Allow-Headers", "Authorization,Origin, X-Requested-With, Content-Type, Accept,Access-Token");//Origin, X-Requested-With, Content-Type, Accept,Access-Token return true; } 关键是这两句 response.setHeader("Access-Control-Allow-Origin",request.getHeader("Origin"));//支持跨域请求
response.setHeader("Access-Control-Allow-Credentials", "true");//是否支持cookie跨域
注意：当Access-Control-Allow-Credentials设置为ture时，Access-Control-Allow-Origin不能设置为*
package com.huayong.bi.web.interceptor; import com.huayong.bi.inter.constants.EnumHttpStatusType; import com.huayong.bi.inter.util.LogUtil; import com.huayong.bi.web.common.util.SpringUtil; import com.huayong.bi.web.dao.impl.PermissionCheckImpl; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import com.alibaba.fastjson.JSONObject; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.PrintWriter; import java.util.Arrays; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/547d1755779614212e20ff99493ff5fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef7141b52c7633a17eae0ecf7c5ee6a4/" rel="bookmark">
			redis 反序列化deserialize异常问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 org.springframework.data.redis.serializer.SerializationException: Cannot deserialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.StreamCorruptedException: invalid stream header: 31323334 at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize(JdkSerializationRedisSerializer.java:84) at org.springframework.data.redis.core.AbstractOperations.deserializeValue(AbstractOperations.java:334) at org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:60) at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:224) at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:184) at org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:95) at org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:48) at redis.RedisDemo.test1(RedisDemo.java:27) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:73) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:83) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef7141b52c7633a17eae0ecf7c5ee6a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/977e48c74bd5bd46504931b8bb4dff02/" rel="bookmark">
			CC2530程序烧录问题001
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		买了块成都亿佰特2530模块，E18-MS1-PCB，自己做了块底板用于调试和写程序，发现如下问题：
1、模块与底板不是直接焊接，通过铜线接触，导致接触不好，弄了几次不灵，还以为片子搞坏了，后来直接飞线焊接，问题解决
2、底板上有5v转3.3v，5v是通过USB转TTL线供电，这样产生的问题是烧录程序校验总是出错，无法正常写程序，后来用USB转TTL线的3.3v直接供电则问题解决，没有想通为什么？
后来找到原因：底板LP38690封装不对，量输出不是3.3V，当时用的现成的封装，没注意管脚，结果焊接上去输入变成输出了，悲催呀，修改后一切正常。
2019-6-6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e48e1a659c6fb981dd4aa4af54674a3/" rel="bookmark">
			hyper-v虚拟机监控程序未运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于虚拟机监控程序未运行,无法启动模拟器
解决方案：
以管理员权限打开命令提示符
输入bcdedit /set hypervisorlaunchtype Auto
重启计算机
bcdedit /set hypervisorlaunchtype off (禁止hyper-v)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5404662339037abd9ba2c3f914c4d31e/" rel="bookmark">
			python3连接access数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先,引入pypyodbc模块(没有该模块需要先pip install pypyodbc)
import pypyodbc
如果数据库文件.mdb在当前目录下则
import os
path = os.getcwd();
#取得当前文件目录
mdb = 'Driver={Microsoft Access Driver (*.mdb)};DBQ='+ path +'\\foods_data.mdb' #foods_data.mdb是数据库文件
#连接字符串
conn = pypyodbc.win_connect_mdb(mdb)
#建立连接
也可以直接给出数据库文件的路径，替换mdb(连接字符串)。
接下来开始使用sql语句对数据库操作。
cur = conn.cursor() #操作之前，先这么做就对了
sql = "SELECT count(*) FROM 管理员 WHERE [账号]=? AND [密码]=?"
#sql语句 ?先用来占位,亦可以直接替换成完整的sql语句
cur.execute(sql,(username,password))
#执行sql语句,后面的元组元素按照顺序替换之前sql语句的占位符，注意，一定是元组，即使一个数据也要(data,)
cur.commit()
#执行完该条语句才能让提交结果最终生效
如果想要获得查询语句得到的结果，则可以按照下列方式遍历数据，如:
for num, in cur.execute(sql,(username,password)):#每次循环取出一行数据
print(num)
每行数据只有一个元素也要使用元组！！！！！！比如上面的(num,).
参考:
https://www.jianshu.com/p/00b53a386c2a
https://my.oschina.net/zhengyijie/blog/35587
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e91dd470109ebfdc4e0648cd513c37e4/" rel="bookmark">
			java.lang.NoSuchMethodError: javax.servlet.http.HttpServletResponse.setConte。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：我用的tomcat7，方法应该是tomcat8才有所以报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120102b2039f2949117742be0f96c206/" rel="bookmark">
			采用 position absolute和fixed布局，安卓键盘顶起遮挡正常页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 h5页面采用 position absolute和fixed布局时，安卓键盘弹起时，采用absolute和fixed布局的标签也会跟随滑动，会遮挡正常页面，导致正常页面不能正常操作。
方法一是：采用 input框聚焦和失焦的时候，做一些操作，但这个方法有可能效果不是很好，因为聚焦时，软键盘可能存在不会弹起的bug。
方法二是采用 监听页面是否有变化来做一些操作，安卓软键盘弹起时，安卓键盘占据了页面的一部分空间，所以此时页面高度会比没有弹起来变小，就有了操作空间。
export default { data() { return { fullHeight:document.documentElement.clientHeight, // 保存初始高度 allHeight:document.documentElement.clientHeight, }; }, mounted(){ var that=this; window.onresize = () =&gt; { return (() =&gt; { window.fullHeight = document.documentElement.clientHeight that.fullHeight = window.fullHeight // &lt; 说明安卓软键盘弹起来了 if(that.fullHeight&lt;that.allHeight){ that.show_buttom_text=false; }else{ that.show_buttom_text=true; } })() } }, methods: { } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7bd8912d1a7e04d3af3288a6947c730/" rel="bookmark">
			微信小程序：web-view嵌套的h5页面退出后音频没有停止播放的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序的web-view可以嵌套h5页面，h5内容可以在小程序上展示。
&lt;web-view src="{{url}}?isLogin={{isLogin}}&amp;id={{id}}&amp;userId={{userId}}&gt;&lt;/web-view&gt; 传参方式如上
碰到的问题是：当进入到H5页面时，会播放音乐，当返回到小程序或者退出小程序后，在微信聊天界面音频还在继续播放，直到音频播放完毕，这对用户的体验的非常不好。刚开始的做法是在嵌套h5的页面里用onUnload将src中的url设置为空，但是在安卓机上可行，ios上依然在播放，真的是很苦恼，又继续找方法。
直到后面看到了阮一峰的一篇文章（http://web.jobbole.com/95344/）解决了问题
document.addEventListener('visibilitychange', function () { // 用户离开了当前页面 if (document.visibilityState === 'hidden') { document.title = '页面不可见'; var music = document.getElementById("play"); music.pause();//暂停 } // 用户打开或回到页面 if (document.visibilityState === 'visible') { document.title = '页面可见'; var music = document.getElementById("play"); music.play();//播放 } }); 监听网页的可见与不可见，网页不可见时暂停播放，可见时播放。非常感谢阮一峰的分享，这个问题着实排查了很久。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35486bc31160a2b66dd468b9344728c6/" rel="bookmark">
			Feign实现微服务间调用返回stream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来讲述一下fegin的调用返回stream，得到stream我们可以下载，写入到页面展示图片等；
我们就开始讲述一下：
服务提供者流接口 @RequestMapping(value = "feginProcessDiagram", method = RequestMethod.GET, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE) public void genFeginProcessDiagram(HttpServletResponse httpServletResponse, String processId) throws Exception { ProcessInstance pi = runtimeService.createProcessInstanceQuery().processInstanceId(processId).singleResult(); //流程走完的不显示图 if (pi == null) { return; } Task task = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult(); //使用流程实例ID，查询正在执行的执行对象表，返回流程实例对象 String InstanceId = task.getProcessInstanceId(); List &lt; Execution &gt; executions = runtimeService.createExecutionQuery().processInstanceId(InstanceId).list(); //得到正在执行的Activity的Id List &lt; String &gt; activityIds = new ArrayList &lt; &gt; (); List &lt; String &gt; flows = new ArrayList &lt; &gt; (); for (Execution exe: executions) { List &lt; String &gt; ids = runtimeService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35486bc31160a2b66dd468b9344728c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3261a6ed4b5435770c6ddb680cdd2832/" rel="bookmark">
			Android版Expo 最新版工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些手机没办法下载 Expo，只能通过’一些渠道’去下载，而且有可能比较麻烦，你去下载别人的还要c币，有想要的可以私我…
点击下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf486f58602d5fe2203a371c27decbca/" rel="bookmark">
			SheetJS/js-xlsx修改表头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SheetJS/js-xlsx修改表头 我们经常使用到json_to_sheet方法将json数据转化到worksheet（表示excel文件中的一个表）中，最后导出excel表，列头会默认采用数据的键名，但是为了方便查看数据需要一个对应的中文表头。
const data = [ { name: 'jzx', age: 17 }, { name: 'wmp', age: 17 } ] const fields = [ 'name', 'age' ] const workSheet = XLSX.utils.json_to_sheet( data, { header: fields } ) console.log(workSheet)：
可以看到对象的每个属性名都很有规律，都是字母+数字的组合，字母表示列，数字表示行，行从1开始计数，列从字母A开始，直到Z，超出的依次在后面叠加字母，也就是说第27列应该用字母AA表示，以此类推。
属性值中t表示类型，v是原始值。可以看到的是列表头会用第一行来表示，也就是A1,B1，表头加两行数据，总共3行。
你可以直接替换A1,B1对应的表头名称，但是这在列数增加到几十个的时候很麻烦，对于这样的规律数据用一个循环来处理最好了。
首先需要拿到所有列的字母，得到所有列以后，依次后面加1就是所有的表头字段，然后替换属性值里的v属性即可，这里要用到XLSX.utils.encode_col和XLSX.utils.decode_range方法，以及workSheet的!ref属性。
先来看看workSheet的!ref属性：
workSheet['!ref']) // A1:B3 // 冒号前是第一个单元格，冒号后是最后一个单元格 XLSX.utils.decode_range方法可以将对应的字母转化为数字：
const range = XLSX.utils.decode_range(ws['!ref']) // range对象的值： { s: { c: 0, // 第一行 r: 0 // 第一列 }, e: { c: 1, // 第二列 r: 2 // 第三行 } } s指的是第一个单元格，c是指列，r是指行，e是最后一个单元格，ok，有了这个对象，我们就知道了这个workSheet的所有列是从数字0到数字1对应的所有字母，最后使用XLSX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf486f58602d5fe2203a371c27decbca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e80501f45352c02068ff2318fe8f0c/" rel="bookmark">
			利用VLMCSD部署本地KMS服务器（Windows &#43; CentOS7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用KMS激活Windows操作系统和Office早已不是什么新鲜事，但是呢，不信任来路不明的激活工具，外部服务器又不稳定，随时可能停服，所以，还是发扬自己动手、丰衣足食的优良作风，求人不如求己，那就自己搭一台好了。当然，这里说的部署并不是真的要部署一台微软的KMS服务器，显然博主掏不起那个银子，所以，薅羊毛而已啦，下面进入正题。
项目名称：VLMCSD
项目简介：KMS Emulator in C (Currently runs on Linux, Mac OS, iOS, Windows with or without Cygwin)
项目主页：https://github.com/Wind4/vlmcsd
软件下载：https://github.com/Wind4/vlmcsd/releases/download/svn1112/binaries.tar.gz
首先通过上述下载页面将软件下载下来，不过由于GitHub自身原因，下载不是特别的稳定，博主已经把最新版本的源代码和编译好的工具下载好并打包上传，网友们可以自行下载。信不过博主的，可以通过上述链接自行下载。
# vlmcsd-1112-2018-10-20-Hotbird64
链接: https://pan.baidu.com/s/1Bh4BJR3zwWuucXvgSJr2XA
提取码: dgr4
1. Windows 平台部署KMS服务器 将下载好的工具软件解压到指定的目录下，记得事先关闭杀毒软件（Windows自带的Windows Defender也算）以防发生意外。将工具软件的服务端拷贝到系统文件夹中，方便后续创建系统服务，操作如下：
# VLMCSD 服务端参考路径 # $APP_PATH\vlmcsd-1112-2018-10-20-Hotbird64\binaries\Windows\intel\vlmcsd-Windows-x64.exe copy vlmcsd-Windows-x64.exe %windir%\System32\vlmcsd.exe 接下来，以管理员模式创建命令提示符窗口，我们要创建系统服务并设置为自动启动，同时打开防火墙服务端口，参考命令如下：
# Create System Service sc create KMSSrv binpath=%windir%\System32\vlmcsd.exe type=own start=auto displayname="KMS Emulator" # Run Vlmcsd net start KMSSrv # Open Port:1688 netsh advfirewall firewall add rule name="KMS Emulator Server"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88e80501f45352c02068ff2318fe8f0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7eb35a9f84866fad06d3f299762061a/" rel="bookmark">
			SQL语言书写规范（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 这周在帮同事的安装程序中嵌入Mysql时，遇到在Linux平台移植DML脚本错误的问题，具体定位到是Mysql在window平台默认对表名大小写不敏感，而Mysql在Linux平台默认表面是大小写敏感的。
由于SQL语言没有官方的书写规范，因此每个人在编写存储过程中遵循的都是不同的规则，而差的SQL语言书写规范会导致阅读性变差，跨平台性变差。 因此，我开始准备着手收集一些优秀的SQL语言书写规范，其中打钩的，是推荐遵守的。
参考： https://blog.csdn.net/qq_34100655/article/details/82904797
https://www.cnblogs.com/yangkunlisi/archive/2011/09/14/2176773.html
https://www.runoob.com/mysql/mysql-insert-query.html
SQL书写规范： 0、SQL语言应正确、规范、高效和最优；（书写目标）√
1、在同一个项目中，SQL遵守同一书写规范；（提高代码阅读性）√
2、建议SQL的表名、列明小写，系统保留字、内置函数大写；（不同数据库或者平台，对大小写敏感设置都是不同的，提高SQL移植性）√
3、or、and、in等连接符前后加上空格；（提高代码阅读性）
4、使用INSERT语句时，应指定插入的字段名，不建议直接插入VALUES；（防止数据错位）√
INSERT INTO runoob_tbl (runoob_title, runoob_author, submission_date) VALUES ("学习 PHP", "菜鸟教程", NOW()); 5、使用SELECT语句时，应指定列名，不建议使用*代替；（提高SQL运行速度）√
SELECT list.manifest_no, list.bill_no, stat.list_stat FROM mft_list list, list_stat stat WHERE list.manifest_no = stat.manifest_no AND list.bill_no = stat.list_no; 6、表数据尽量使用英文、当确定表数据会出现中文时，应当建表时设置好字符集-utf8；（提高容错性）√
CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80897290ba8b16bf72157ca837d8a0e6/" rel="bookmark">
			【项目管理】项目总结会要点和内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
要点
内容
实践
要点 1. 全体参与讨论
包括所有项目干系人，强调的是所有干系人，项目成果是全体项目干系人共同创造的，参与总结会很重要的一个意义就是让每个参与的人更加系统和全面了解项目，这个项目在哪方面取得了哪些不错的成绩，哪些地方有待提高，在实际的项目中总结经验教训，从而不断提升自己能力，提升团队协作能力，团队战斗力等。同时作为参与者，可以在会议上积极发言，充分表达个人的意见和建议，有利于更加客观全面评价项目。
2. 确认
与会人员要根据项目中梳理的各项绩效数据进行一致性确认，并讨论这些绩效数据背后原因，有无改进空间，如何改进，有哪些不错的最佳实践等。
3. 形成文件
针对讨论内容进行梳理归纳，形成会议文件作为公司的组织过程资产，为后续其他项目提供宝贵的参考指导。
内容 1. 项目绩效
项目完成情况，计划完成率，项目目标完成，作为全体项目共同成绩。
2. 技术绩效
最终工作范围跟最初比较结果，变更哪些，是否合理，处理是否有效；对质量，进度，成本是否有重大影响，是否符合预计的质量标准和达到客户满意度。
3. 成本绩效
最终成本跟原始预算费用比较，变更增加预算是否存在较大偏差，项目盈利状况如何，影响到项目组成员的绩效和奖金的分配。
4. 进度计划绩效
偏差比较，提前或滞后的原因
5. 项目沟通
是否建立完善和有效利用沟通体系，让客户参与项目决策和执行，客户定期检查项目状况，客户参与定期沟通和阶段总结会议，及时通知客户潜在问题风险，一起参与问题的解决，沟通计划完成情况如何，项目内部会议记录资料是否完备。
6. 识别问题和解决问题
问题是否解决，问题原因是否可以避免，如何改进
7. 意见和建议
项目成员对项目管理本身和项目执行计划是否有合理建议和意见，是否得到大多数参与成员的认可，是否能在未来项目中加以应用改进。
实践 本人组织过一个中等项目的总结会，在开总结会前提前准备好相关绩效数据。提前通知相关干系人时间，地点，议题等。在该项目总结会过程中，不一定按照上面梳理出各种绩效报告数据。我主要从项目的结果，项目过程风险，风险应对，项目存在的问题，问题解决情况，项目成果，项目建议这几方面在会议上作重点的讨论。
1. 项目全周期简单介绍
从启动，规划，执行，监控，收尾已时间轴简单介绍项目生命周期（里程碑事件），让参与者知道项目粗略的概貌
2. 重点过程风险，问题和应对以及结果
具体时间点出现项目风险，从主观和客观上都做了哪些具体行动来应对出现的问题，行动之后的结果如果
3.项目成果，哪些做的好的，哪些存在不足
成果：
功能开发：V1.0版本完成，完成两个业务系统整合，第一个版本开发测试，另外产品工厂引入，用户中心接入。技术引入：领域驱动，自动化测试方案落地，uflo工作流引入团队能力提升：统一技术栈，基础架构，基础平台，基础组件，敏捷开发最佳实践落地... 待改进地方（大家发言）：
项目定调（开始高，后期低）-随着业务战略调整，资源投入存在较明显的变化，导致进度延误的原因之一。【建议】客观原因，市场变化，业务变化，尽量预判和做好相关评估。项目统筹权责不对等--业务，产品，开发，测试等多头权衡，有些时候无法保证统一决策，需要耗费较多时间沟通。【建议】权责高度统一，多人可以协同，但必须有唯一项目负责人，即有决策权，其他团队服从和配合。一次性引入太多“新技术”--不同技术栈的切换，甚至基于该项目应用作为落地的试验项目，过程中踩坑，解决问题耗费较多时间。【建议】跟项目定位有关，考虑学习成本，试错风险。产品需求原型修改较为频繁，业务需求随着项目推进，之前投入开发功能不需要，从而导致开发无用功。【建议】没有抓住主要核心功能，主流程，先完成再完美。... 以上讨论内容最终形成wiki文档，综上，经过大家总结复盘，每个人都较为深刻认识到项目成功是综合各方面的因素的结果，对项目存在分问题如何解决，避免等也做了深入的讨论分析，这些讨论和意见都是大家一线参与最客观真实的反映，对于每个参与者和项目团队为改进后续新项目流程协作等提供实际案例的参考指导。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d8f2ed3b0c1a4dcd7e2b22aa7d16c8/" rel="bookmark">
			OOAD实验四教务管理系统设计之顺序图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OOAD实验四教务管理系统设计之顺序图 一、图形文档学籍子系统四个详细用况评估子系统四个详细用况 二、顺序图综述、对象接受/发送消息的描述学籍管理评估管理 一、图形文档 学籍子系统四个详细用况 学籍登记用况
学籍查询用况
学籍管理用况
学籍汇总用况
评估子系统四个详细用况 进行评估用况发布评估用况
查看评估用况统计评估用况 二、顺序图综述、对象接受/发送消息的描述 学籍管理 学籍登记用况
学籍管理员登录到总系统，通过系统核实后，进入到学籍登记界面，由该管理员负责录入信息，然后写入数据库，完成用况。学籍查询用况
学生登录到总系统，通过系统核实后，进入到学籍查询界面，由控制类向数据库申请相应数据，并返回到查询界面，结束用况。学籍管理用况
学籍管理员登录到总系统，通过系统核实后，进入到学籍管理界面，向数据库查询到相应的学籍资料后，提交修改，控制类对数据库进行更新，完成管理用况。学籍汇总用况
学籍管理员登录到总系统，通过系统核实后，进入到学籍汇总界面，向数据库请求数据后，选择需要汇总的学籍，由控制类生成汇总表，完成学籍汇总用况。 评估管理 进行评估用况
学生登录到总系统，通过系统核实后，从数据库请求到待评估资料清单，进入到进行评估界面，完成评估后提交至数据库保存，完成进行评估。
发布评估用况
教务管理员登录到总系统，通过系统核实后，进入到发布评估界面，并由控制类将待评估资料更新到数据库，完成发布评估用况。
查看评估用况
教师登录到总系统，通过系统核实后，进入到查看评估界面，并由数据库返回该教师已完成的评估内容，完成发布评估用况。
统计评估用况
教务管理员登录到总系统，通过系统核实后，进入到统计评估界面，管理员选择需要统计的范围，由控制类执行统计算法，返回统计结果，完成统计评估用况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3da6d7a0afcdac3c2d0da665c814229a/" rel="bookmark">
			gitflow（重新）init
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我用gitlow init的时候设置错了production 分支，现在想将其设置为master。
查看init下的指令
~/IdeaProjects/myproject(feature/my20190111) » git flow init -h USAGE: git flow init [flags] args flags: -h show this help (default: false) -f force setting of gitflow branches, even if already configured (default: false) -d use default branch naming conventions (default: false) 上面可以看到除了-h之外还有两个指令可以使用，-d使用默认设置，-f就是我现在需要用到的用来更改设置错误的设置。
git flow init -f 执行上面指令后可以重新设置初始化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6941bab44f697c785c23d954ff8c67/" rel="bookmark">
			linux中^M
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		^M产生原因：
linux和windows
在unix操作系统下的换行符格式为0A（ascii码），而dos格式下的换行符为 0D 0A(也就是&lt;CR&gt;)，&lt;CR&gt;其实就显示为^M了。
^M去掉方法：vi进去之后在命令模式下输入：%s/^M//g 或者 %s/\r//g 然后esc退出 :wq保存退出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3037e7486b09d8ac3ec6132df51264/" rel="bookmark">
			pom.xml报错：Failure to find org.apache.maven.doxia:doxia-logging-api:jar:1.1 in http://repo.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在maven本地库中找到对应的地址:org.apache.maven.doxia找到对应的文件：doxia-logging-api发现文件中包含有lastUpdated字样，表示该文件并未下载完成，然后将整个2.6版本删除，项目上右键&gt;Maven&gt;Update project 即可。
《Failure to find org.apache.maven.doxia:doxia-logging-api:jar:1.1 in http://repo.maven.apache.org/mav》
参考网址：参考网址
pom.xml报错：
Multiple annotations found at this line:
- Missing artifact log4j:log4j:jar:1.2.15:compile
- Missing artifact org.apache.xmlbeans:xmlbeans-xpath:jar:2.4.0:compile
- Missing artifact org.apache.ws.commons.axiom:axiom-dom:jar:1.2.5:compile
- Missing artifact org.apache.httpcomponents:httpcore:jar:4.0-alpha5:compile
参考地址
更新时将此勾选：
转载于:https://www.cnblogs.com/Linlearn/p/10972454.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946e768744f61ab67565ea69684971db/" rel="bookmark">
			无感方波和FOC堵转检测策略参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://mcu.eetrend.com/content/2017/100007230.html
基于S12ZVM的车用无传感器BLDC堵转检测方法探讨 judy 发布于：周一, 07/31/2017 - 11:05 ，关键词：
传感器S12ZVM恩智浦 本文介绍了车用无传感器BLDC堵转检测的重要性以及实现的方法，分别讲述了六步方波堵转检测以及FOC正弦波堵转检测的方法。重点介绍了基于S12ZVM的FOC正弦波堵转检测的原理、代码实现和测试。最后总结了S12ZVM在车用BLDC电机控制中的优势，特别是对于FOC正弦波控制而言。有了恩智浦强大的汽车电机Enablement，AMMCLIB，FreeMASTER、MCAT、ToolBox等等，很多复杂的功能和算法实现起来都容易了很多。本文希望对于使用S12ZVM来开发BLDC项目的工程师，能起到一定的帮助作用。
随着汽车自动化程度不断提高，电机在汽车上的应用也越来越广泛。无论是传统燃油汽车还是新能源汽车，电机作为执行器，扮演着越来越重要的角色。汽车电机大家族里面有一类电机叫流体控制类电机，包括各类风扇、鼓风机、水泵、油泵以及压缩机等。这些电机目前很多都已经使用无刷直流电机（BLDC），或者在往无刷直流电机切换的过程中。无刷直流电机有着高效、高可靠性的特点，再加上流体类电机几乎不工作在低速区，因此无传感器的无刷直流电机控制就特别适合汽车的这些应用。
无刷直流电机的无传感器控制一般包含方波控制和正弦波控制。无论是哪一种控制方式，由于没有传感器信号的接入，一旦遇到外界阻力或者巨大的负载突变，都可能会使得系统进入到堵转状态。在这种堵转状态下，电机只是原地抖动并消耗电流，而系统会处于异常状态。长时间保持这样的状态，无疑是有害的。
众所周知，对于有传感器的无刷直流电机系统，堵转检测就变得很简单了。只需要检测传感器信号是否在正常刷新就可以了，而对于无传感器系统，可靠的堵转检测就变得没那么容易了。本文会就这个议题进行详尽的解析，希望可以起到抛砖引玉的作用，对大家无传感器的无刷直流电机控制项目起到实际的帮助作用。
一． 六步方波无传感器BLDC堵转检测
对于直流无刷电机的无传感器六步方波，转子位置信息的获取是通过对三相反电动势信号进行采集、比较和计算得到的；其转速也是通过根据过零点的时间差计算得来的。其系统框图如图1所示。但如何来实现其堵转检测功能呢？NXP的无传感器BLDC方波控制方案给出了答案，总体思路就是对反电动势过零的周期进行判断。如果反电动过零周期异常并持续一段时间，就触发堵转检测。在AN4704的参考程序中，StallCheck函数就是实现堵转检测的。可以看到首先该函数对6个过零点周期进行判断，找出最大值和最小值；然后再计算6个过零点周期的平均值；接着对过零点周期平均值和最大值的一半以及过零点周期平均值和最小值的2倍进行比较，如果过零点周期平均值小于最大值的一半或者大于最小值的2倍，那么就属于异常状态，堵转检测故障因子就增加。另外一点就是还要考察如果过零点周期的最小值，看其是否小于设定的堵转检测换相周期最小值，如果是的话，堵转故障因子也增加。如果以上的条件都不满足的话，堵转因子就减小。最后判断堵转因子的值如果超过设定值，就产生堵转事件停机。
图1 无传感器BLDC方波控制系统框图
经过实践的证明，无论是启动阶段还是正常运行阶段，该堵转检测方法都可以可靠且有效的检测出堵转事件。其后面的物理含义也是比较好理解的，我们都知道电机正常运行时，一个电周期中有6次换向，对于大部分流体类应用，连续的6个换向周期内不会存在很大的突变，因此其平均值和最大值及最小值的差距不会特别大，且最小值也不会特别小，因此这两个判据是可以可靠的把堵转事件给检测出来的。
相应的代码请参考AN4704的软件包里的StallCheck函数。当然，可以根据电机参数及实际应用，修改STALLCHECK_MIN_CMT_PERIOD和STALLCHECK_MAX_ERRORS的值。对于STALLCHECK_MIN_CMT_PERIOD参数，主要是考虑到电机的最高转速下对应的值，其越小，电机的转速越高，堵转事件发生的条件就越苛刻；对于STALLCHECK_MAX_ERRORS参数，实际上就是容错处理，其值越大，也是越不容易发生堵转事件。
StallCheck的流程图如图2所示。对于方波控制来讲，堵转检测确实不算复杂，那对于磁场定向控制的无传感器方案呢，堵转检测功能该怎么做呢？
图2 无传感器BLDC方波控制堵转检测流程图
二． 正弦波FOC无传感器堵转检测
目前对于无刷直流电机的无传感器FOC控制来讲，其堵转检测一般有两种方法，速度波动检测法和反电动势校验法。
2.1 速度波动检测法
速度波动检测法的基本思路就是在快速环路（电流环）内记录观测器输出的速度值，然后在慢速环路（速度环）内计算速度的平均值以及速度的波动。如果速度的波动超过设定的阈值就可以判断为发生了堵转事件。是不是感觉这种方法似曾相识呢。速度波动法和前面介绍的无传感器BLDC的方波控制堵转检测实质上是一个思路，那就是判断速度反馈是否合理。由于速度波动检测法本身比较简单，另外对于一些反电动势观测器来讲，在某些特定场景下，这种方法可能失效，特别是负载突变的时候，反电动观测器还会继续工作，电机相电流波形也很好，速度输出也会很稳定，但实际上电机并没有运行而是在原地抖动。基于这个原因，本文并不推荐速度波动检测法来检测堵转事件，也就不再花篇幅来深入下去了。另一方面，反电动势校验法则可靠很多，会是本文的重点。
2.2 反电动势校验法
目前反电动势校验法是检测无传感器FOC方案的主流方案。接下来会重点介绍该方法的原理、代码实现及测试等。
2.2.1原理
对于无传感器的FOC控制，恩智浦方案中最常用的是反电动势观测器，其框图如图3所示。该观测器将αβ坐标系的电压和电流通过Park变换到垂直的γδ坐标系。而γδ坐标系和同步坐标系dq之间的角度差是θerr。后面的Position Tracking Controller实际上就是个PLL，目标是锁定θerr=0；从而确保输出的θestim和转子真实的位置重合。图4为γδ坐标示意图。
图3 反电动势观测器和PLL框图
图4 γδ坐标系示意图
由图3可以看到back-EMF State Filter的输出是γδ坐标系的反电动势。当γδ坐标系与dq坐标系重合的时候，Eδ实际上就是Eq。如果观测器正常工作，Eδ的输出是和转速成正比例的，转速稳定的情况下，Eδ也是平稳的。从另一个角度来看，对于q轴反电动势，如果知道反电动势系数和转速，也是可以根据公式来计算得到的。这样就会有两种途径来获得q轴的反电动势，一个是从观测器输出得到，另一个是从转速和反电动势系数得到。如果两个途径得到的反电动Eq相差比较大，超出了阈值，就可以判定为堵转事件。原理图框图如图5所示。
图5 反电动势校验法原理框图
2.2.2 代码实现
由于恩智浦在汽车电机控制上的积累，使得AMMCLIB（Automotive Math and Motor Control Library）非常适合于汽车电机的应用。无论是数学运算还是各种滤波器，目前AMMCLIB都能很好的支持，同时AMMCLIB还集成了包括扩展的反电动势观测器在内的诸多高级电机控制算法。AMMCLIB可以说是为汽车行业量身定做的，其满足SPICE LEVEL 3标准。因此本文的代码也是基于AMMCLIB来写的。
上面的原理框图中，ε为允许偏差范围百分比；如果允许20%偏差，那么ε=0.2；Ke与Ke_offset可以通过实验的方法得到。举例说明如下，比如恩智浦的演示电机，可以分别让其跑在1000RPM、2000RPM、3000RPM以及4000RPM稳定转速下，分别得到其Eq值和转速值。然后做一个线性方程就可以解出Ke和Ke_offset，理论上两个点就可以了。然后设置一个合理的ε值，比如20%。这样就可以算出来Eq的变化范围，然后去比较Eδ和Eq的范围边界，如果出界，ErrorCounter加1。如果在一定的Counter范围内，ErrorCounter超出设置阈值，则判断为堵转事件发生。图6对Eδ的允许范围做了很清晰的描述，如果Eδ不在蓝色的范围带内，就说明观测器输出是异常的，积累一定次数后就可以判定堵转事件。然后就可以进入到堵转故障处理程序了，通常是停机，然后尝试重新启动。这部分代码实现不算复杂，目前实现该功能的基本代码已经写好了，限于篇幅的原因，就不直接放出来了。
图6 反电动势Eδ允许的范围示意图
2.2.3 测试
堵转检测的测试主要考察两个方面，一个是启动阶段，一个是正常运行阶段。测试平台采用恩智浦的S12ZVMx12EVB开发套件，搭配12V电源和示波器。如图7所示。
图7 无刷直流电机堵转检测平台
测试1：启动阶段用手堵住电机的圆盘，然后启动电机运行，目标转速1000RPM。因为电机被堵转，没法转动，此时电机出现抖动，电流保持正弦。此时堵转检测功能没有使能，电流激励一直维持。
测试2：其他条件和测试1一致，使能堵转检测功能。电机在抖动几秒后触发了堵转故障，成功了检测出了堵转故障。重复10次每次都可以成功。
测试3：其他条件和测试2一致，但没有在启动前就堵转电机，而是等待进入速度闭环，也就是稳定跑到1000RPM时，突然施加外力到圆盘上，电机在励磁几秒后触发了堵转故障，成功的检测出堵转事件。整个测试故障可以在FreeMaster上进行查看，一个触发成功的图片如图7所示。
图8 FreeMASTER上堵转故障被触发
测试结论：该堵转检测方法经过测试验证是有效的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946e768744f61ab67565ea69684971db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d46982ad852ee612ea6c273434e90e/" rel="bookmark">
			避免死锁方法之银行家算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 死锁银行家算法原理银行家算法具体介绍 要介绍银行家算法应该先简单说一下死锁： 死锁 死锁概念：在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源时，就会造成死锁。尽管死锁很少发生，但一旦发生就会造成应用的停止响应。
死锁的两种情况：
同一个线程先后两次调用lock,在第二次调用时,由于锁已经被自己占用,该线程会挂起等待自己释放锁,由于该线程已被挂起而没有机会释放锁,因此 它将一直处于挂起等待状态，变为死锁；
线程A获得了锁1,线程B获得了锁2,这时线程A调用lock试图获得锁2,结果是需要挂起等待线程B释放锁2,而这时线程B也调用lock试图获得锁1,结果是需要挂起等待线程A释放锁1,于是线程A和B都在等待对方释放自己才释放，从而造成两个都永远处于挂起状态，造成死锁。
产生死锁的必要条件：
互斥条件：指线程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个线程占用。如果此时还有其它线程程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
请求和保持条件：指线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求线程阻塞，但又对自己已获得的其它资源保持不放。
不剥夺条件：指线程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
环路等待条件：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
如何避免死锁呢？
理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、线程调度等方面注意如何能够不让这四个必要条件成立，如何确定资源的合理分配算法，避免线程永久占据系统资源。
此外，也要防止线程在处于等待状态的情况下占用资源,在系统运行过程中，对线程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配。因此，对资源的分配要给予合理的规划，银行家算法就是一种很好解决的方式
银行家算法原理 这里是引用一个银行家共有20亿财产
第一个开发商：已贷款15亿，资金紧张还需3亿。
第二个开发商：已贷款5亿，运转良好能收回。
第三个开发商：欲贷款18亿
在这种情况下，如果你是银行家，你怎么处理这种情况？一个常规的想法就是先等着第二个开发商把钱收回来，然后手里有了5个亿，再把3个亿贷款给第一个开发商，等第一个开发商收回来18个亿，然后再把钱贷款给第三个开发商。
银行家算法是避免死锁的一种重要方法。 操作系统按照银行家制定的规则为线程分配资源，当线程首次申请资源时，要测试该线程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当线程在执行中继续申请资源时，先测试该线程已占用的资源数与本次申请的资源数之和是否超过了该线程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。
银行家算法具体介绍 每一个线程进入系统时，它必须声明在运行过程中，所需的每种资源类型最大数目，其数目不应超过系统所拥有每种资源总量，当线程请求一组资源系统必须确定有足够资源分配给该进程，若有在进一步计算这些资源分配给进程后，是否会使系统处于不安全状态，不会（即若能在分配资源时找到一个安全序列），则将资源分配给它，否则等待。
假定系统中有五个线程{P0，P1，P2，P3，P4}和三类资源{A,B,C},各类资源数量分别为10,5,7,在T0时刻分配资源情况如图：
Max:表示线程对每类资源的最大需求量；Allocation:表示系统给线程已分配每类资源的数目；Need:表示线程还需各类资源数目；Available:表示系统当前剩下的资源。
从初始找出安全序列：
首先系统剩下资源{3,3,2}，查表可满足5个进程Need的进程有：P1(1,2,2)、P3(0,1,1),先给P1分配；P1分配以后执行完释放其所占资源后系统此时剩下资源有：Allocation+{3,3,2}={5,3,2};根据系统剩下资源查表可满足剩下4个进程Need的进程有P3{0,1,1}、P4{4,3,1}，再给P3分配；P3分配以后执行完释放其所占资源后系统此时剩下资源有：Allocation+{5,3,2}={7,4,3};根据系统剩下资源查表可满足剩下3个进程Need的进程有P0{7,4,3}、P2{6,0,0}、P4{4,3,1},再给P4分配；P4分配以后执行完释放其所占资源后系统此时剩下资源有：Allocation+{7,4,3}={7,4,5};根据系统剩下资源查表可满足剩下2个进程Need的进程有P0{7,4,3}、P2{6,0,0},再给P2分配;P2分配以后执行完释放其所占资源后系统此时剩下资源有：Allocation+{7,4,5}={10,4,7};根据系统剩下资源查表可满足剩下1个进程Need的进程有P0{7,4,3},最后给P0分配;P0分配以后执行完释放其所占资源后系统此时剩下资源有：Allocation+{10,4,7}={10,5,7};所有进程按此序列{P1,P3,P4,P2,P0}可安全执行完毕，最后系统资源全部释放。（由以上也可知安全序列不唯一，但只要找出一个安全序列，说明此系统是安全的（找到安全序列可按此序列真正执行进程推进顺序，若没找到，则恢复初始状态，其并没有真正给进程分配资源，只是提前避免）） 下面用代码实现银行家算法
#function：命令行界面实现对各进程请求通过银行家算法实现分配资源 import numpy as np #导入numpy模块 #初始化各数据结构 Available = np.array([3,3,2]) #可利用各资源总数 Max = np.array([[7,5,3],[3,2,2],[9,0,2],[2,2,2],[4,3,3]]) #各进程最大需求资源数 Allocation = np.array([[0,1,0],[2,0,0],[3,0,2],[2,1,1],[0,0,2]]) #已分配各进程的资源数 Need = np.array([[7,4,3],[1,2,2],[6,0,0],[0,1,1],[4,3,1]]) #各进程尚需的资源数 safeList=[] #安全进程执行序列 Request=[] #各进程对各资源的请求 Request_name="" #进程名称 def input_Request(): global Allocation,Available,Max,Need,safeList,Request,Request_name try: Request_name=input("请输入请求线程的编号：\n0 1 2 3 4\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d46982ad852ee612ea6c273434e90e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7946c2e2d3fdfeb1905bbc089f1c23a3/" rel="bookmark">
			npm包 -- http-Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http-server 开启本地服务器 需求下载使用 需求 在调试html文件时，如果在本地文件夹中直接打开，通常会使用file协议。
当代码中存在http或https的链接时，HTML页面就无法正常打开。
为了解决这种情况，需要在在本地开启一个本地的服务器。
下载 1、 下载node.js
官网地址： https://nodejs.org/ 下载完成后在命令行输入命令$ node -v以及$ npm -v检查版本，确认是否安装成功。
2、下载http-server
在终端输入： $ npm install http-server -g
使用 1、 开启 http-server服务
通过终端进入目标文件夹，然后在终端输入：
1 $ http-server -c-1 （⚠️只输入http-server的话，更新了代码后，页面不会同步更新） 2 Starting up http-server, serving ./ 3 Available on: 4 http://127.0.0.1:8080 5 http://192.168.8.196:8080 6 Hit CTRL-C to stop the server 2、 终端按 CTRL-C显示^Chttp-server stopped.即关闭服务成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c2862aa6abaa6809ad0bbaabc4c10a/" rel="bookmark">
			安装配置饥荒专用服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装篇Windows下安装Ubuntu下安装安装运行环境安装服务器 配置篇目录结构配置文件说明下载mod 后记 本篇介绍使用SteamCMD（Steam命令行版客户端）搭建饥荒专用服务器。
SteamCMD文档地址：
https://developer.valvesoftware.com/wiki/SteamCMD:zh-cn#.E4.B8.8B.E8.BD.BD_SteamCMD
安装篇 Windows下安装 下载
https://steamcdn-a.akamaihd.net/client/installer/steamcmd.zip
解压到一个单独目录并运行steamcmd.exe
首次运行会自动下载相应文件
在steam命令行运行以下指令
# 匿名登录 login anonymous # 设置存储游戏的目录 # 如果不设置默认在&lt;steamcmd.exe所在目录\steamapps\common\Don't Starve Together Dedicated Server&gt; force_install_dir D:\Game\DST # 下载游戏。不知道把游戏下载好放入上面目录行不行，未测试。 app_update 343050 validate # 退出steamcmd quit 启动服务器
进入D:\Game\DST\bin，创建批处理文件dst_overworld.bat：
dontstarve_dedicated_server_nullrenderer -console -persistent_storage_root D:/Game -cluster DediServer -console参数允许在服务器命令行输入命令
执行批处理文件启动服务器
输入c_shutdown()关闭服务器
Ubuntu下安装 安装运行环境 Ubuntu/Debian 64位
sudo apt-get -y install lib32gcc1 RedHat/CentOS 32位
sudo yum -y install glibc libstdc++ RedHat/CentOS 64位
sudo yum -y install glibc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26c2862aa6abaa6809ad0bbaabc4c10a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c138ea98146136bcafc9ca2c53a832/" rel="bookmark">
			信息学奥赛一本通C&#43;&#43;语言——1065：奇数求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】
计算非负整数m到n(包括m和n)之间的所有奇数的和，其中，m 不大于 n，且n 不大于300。例如 m=3, n=12, 其和则为：3+5+7+9+11=35。
【输入】
两个数 m 和 n，两个数以一个空格分开，其中 0 ≤ m ≤ n ≤ 300 。
【输出】
输出一行，包含一个整数，表示m 到 n（包括m 和 n ）之间的所有奇数的和。
【输入样例】
7 15
【输出样例】
55
代码
#include&lt;cstdio&gt; using namespace std; int n,m,s=0; int main() { scanf("%d%d",&amp;m,&amp;n); for(int t=m;t&lt;=n;t++) { if(t%2!=0) s=s+t; } printf("%d",s); return 0; } #include&lt;iostream&gt; using namespace std; int n,m,s=0; int main() { cin&gt;&gt;m&gt;&gt;n; for(int t=m;t&lt;=n;t++) { if(t%2!=0) s=s+t; } cout&lt;&lt;s; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b02bfa71edd9030a676144000e07bd/" rel="bookmark">
			Java 贪吃蛇 最简易地实现方法 超简短代码实现 （附源码 详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一个我刚刚写的贪吃蛇小游戏，非常简短的代码实现方法。这可能是全网最简单实现方法，效果图如下：
ps 最新贪吃蛇源码+教学视频+论文下载 java贪吃蛇
有多简短呢 ？ 上代码！！
一共四个类！
Food类
package com.snake; import java.awt.Color; import java.awt.Graphics; import java.awt.Point; public class Food {//食物也是一个长宽各为20的小格子 public Point point=null;	public final int width=20; public final int height=20; public Food(Point p) { this.point=p; } public void drawFood(Graphics g) { g.setColor(Color.RED); g.fillRect(this.point.x, this.point.y, this.width, this.height); } } Snake类
package com.snake; import java.awt.Color; import java.awt.Graphics; import java.awt.Point; public class Snake { public Point point=null; //一直蛇其实就是一个小格子 public final int width=20; public final int height=20; public Snake(Point p) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b02bfa71edd9030a676144000e07bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a34a487d5fdc437a7b87f060cb8352/" rel="bookmark">
			【SVG】getBBox方法获取svg text文本元素的宽高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		getBBox 使用方法和getBoundingClientRect类似，不同的是getBoundingClientRect方法的坐标是相对于视口。
getBBox方法返回一个包含svg元素的最小矩形的坐标对象。
example：
const svgText = document.querySelector('...') const rect = svgText.getBBox() // 如下 { x: 50, y: 50, width: 50, height: 50, // __proto__: SVGRect } 坐标的位置相对于svg元素的原点，且不受任何transform变换的影响。
对于测量text文本元素的宽度、高度很有用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c57ae28b8a43559cd14ef7252bb18f0/" rel="bookmark">
			2.1利用两个线性表LA和LB分别表示两个集合A和B，求新的集合AUB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//将所有在线性表lb中但不在la中的数据元素插入到la中 #include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; #define OVERFLOW -2 #define OK 1 #define ERROR 0 #define LIST_INIT_SIZE 20//线性表存储空间的初始量 #define LISTINCREMENT 10//线性表存储空间的增量 typedef struct{ int *elem;//储存空间的基地址 int length;//当前长度 int listsize;//当前分配的储存容量 }SqList; SqList la,lb; int InitList(SqList &amp;l) { l.elem=(int*)malloc(LIST_INIT_SIZE*sizeof(int)); if(!l.elem) exit(OVERFLOW); l.length=0; l.listsize=LIST_INIT_SIZE; return OK; } int Find(SqList la,int e) { int i,j=0; for(i=1;i&lt;=la.length;i++) { if(la.elem[i]==e) j++; }	if(j==0) return ERROR; else return OK; } void Union(SqList &amp;la,SqList lb) { int *base; int i=1,j; while(i&lt;=lb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c57ae28b8a43559cd14ef7252bb18f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030f48e52ac7d9fdd197e1ca1095f45d/" rel="bookmark">
			关于vue本地与发布线上跨域问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景：www.baidu.com 跳转 m.baidu.com
module.exports = { publicPath: './', devServer: { proxy: { // 这里是配置代理的 "/api": { target:'http://www.baidu.com', changeOrigin: true, // 允许跨域 ws: true } } } } util.ajax = axios.create({ timeout: 30000, withCredentials: true }); 我们根据实际情况只需要修改proxyTable对于配置即可。假设我后端请求地址是http://www.baidu.com，所有api的接口url都以/api开头。所以首先需要匹配所有以/api开头的.然后修改target的地址为http://www.baidu.com。最后修改pathRewrite地址。将前缀 '^api' 转为 '/api'。如果本身的接口地址就有 '/api' 这种通用前缀，就可以把 pathRewrite 删掉。注意这个方式只能在开发环境中使用。
location /api { proxy_pass http://127.0.0.1:9999; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With'; } 因为在本地构建成功之后访问的是本地服务器转发远程服务器，如果发布到测试环境需要在nginx中配置对应的转发,即可解决跨域问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0f319b166f41b167b38b51be8fa517a/" rel="bookmark">
			怎么查看电脑内存的型号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种是用第三方的工具，比如 鲁大师可以看到很详细的内容，驱动精灵、驱动人生只能看到大小
另一种方法用命令：
可以利用运行代码查看内存型号，右击左下角的开始按钮，选择运行。
输入代码“cmd”，点确定。
调出命令行模式，输入代码“wmic”回车。
在新出现的命令行里，输入代码“memorychip”然后回车。
接下来就可以看到内存的型号还有内存的大小了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b7a9469ea22ef775051bbdec6ea0c7/" rel="bookmark">
			插入、快排、堆排、归并、计数和桶排序详解以及测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==&gt; 学习汇总（持续更新）
==&gt; 从零搭建后端基础设施系列（一）-- 背景介绍
代码 核心思想测试结果总结 一、代码 package com.example.sort; import java.util.ArrayList; import java.util.Comparator; import java.util.Random; public class Sort { public static void main(String[] args) { int n = 1000000; int BUCKET_COUNT = 1000; int bound = n; int[] array1 = genRandArray(n, bound); int[] array2 = new int[n]; System.arraycopy(array1, 0, array2, 0, n); int[] array3 = new int[n]; System.arraycopy(array1, 0, array3, 0, n); int[] array4 = new int[n]; System.arraycopy(array1, 0, array4, 0, n); int[] array5 = new int[n]; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83b7a9469ea22ef775051bbdec6ea0c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f1e251fe1f4d61d56d8bba56d03ae6/" rel="bookmark">
			[数据结构与算法]二叉排序树之红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 红黑树1. 红黑树的特性2. 红黑树时间复杂度证明3. 红黑树的基本操作4. 红黑树插入5. 红黑树结点删除6.完整代码7. 示例 整理时长两天半的红黑树，虐死我了，昨晚还失眠了！ 红黑树 红黑树是二叉查找树的一种,每个节点上多了一个表示颜色的存储位.
1. 红黑树的特性 每个结点是黑色或者红色根结点为黑色空结点为黑色(这里把空结点称为叶节点)红色结点的子节点都为黑色从一个结点到其子孙叶子结点所有路径具有相同数目的黑结点 特性5和特性4保证了没有一条路径会比其他路径长出两倍.所以说红黑树是接近平衡的二叉树
2. 红黑树时间复杂度证明 定理
一棵含有n个结点的红黑树的高度至多为 2 l o g ( n + 1 ) 2log(n+1) 2log(n+1)
证明
(1) 转换为逆否命题
其逆否命题为:
一棵高度为h的红黑树结点数至少为 2 h / 2 − 1 2^{h/2}-1 2h/2−1
h ≤ 2 l o g ( n + 1 ) h \leq 2log(n+1) h≤2log(n+1)
l o g ( n + 1 ) ≥ h / 2 log(n+1) \geq h/2 log(n+1)≥h/2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8f1e251fe1f4d61d56d8bba56d03ae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e3eb6370754e3a2c56ffe752195eb7/" rel="bookmark">
			xShell&#43;xFtp 破解版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解除xshell只能打开4个tab页，xftp只能打开2个的限制。
原文地址：https://www.jianshu.com/p/9aed2044d31a
如果原文失效可以联系我。
如果机器上已有Xshell和Xftp：
配置内容默认会存在C:\Users\admin\Documents\NetSarang Computer\6\Xshell\Sessions中，安装的所有xshell都会读这个文件，备份这个文件，防止新安装的软件找不到配置信息卸载已有的xshell和xftp关掉360等工具，执行脚本会拦截 如果安装或卸载报1605和1628问题：
win+r--输入regedit编辑--查找，输入Xftp或Xshell将搜索出的结果删掉，F3继续搜索，一直闪完进入C:\Program Files (x86)\InstallShield Installation Information，清空 如果已经安装Xmanager套件：
建议不要卸载，如果卸载不成功会导致运行xshell或xftp失败如果已经卸载，而且xshell和xftp不能使用，每次在xftp中创建文件夹都失败或者打开软件提示安装信息，建议安装回Xmanager套件Xmanager5 安装包： 链接：https://pan.baidu.com/s/11KjZ1gUqKr6m13DUmkfkDA 提取码：6jba 如果已经把注册列表弄乱：
使用Ccleaner的注册列表清理功能即可安装及破解参考：https://blog.csdn.net/nickDaDa/article/details/93972434 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193fd90de7e2af65cbc1ff13f39ab59a/" rel="bookmark">
			机器学习之熵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熵这个词本来是物理学中表示分子混乱程度的物理量，香农(Claude Elwood Shannon)借用过来描述信源的平均不确定性。信息熵的内容在信息论相关教材中有详细的描述，这里仅对机器学习中用到的部分相关概念做个笔记。
1.信息 信息有别于消息，是对事物运动状态或存在方式的不确定性的描述，并且这种不确定性是有大小的。
比如我们在手机上看到这样两则新闻：
科学家通过新技术复活了一只原核细菌。
科学家通过新技术复活了一只恐龙。
听到这两句话的时候，我们内心的波动是不一样的，对于复活的细菌，我们可能看一眼就刷过去了；对于复活的恐龙，我们可能迫不及待的细看一下，如果可以的话，我们也想亲眼见识见识这数千万年前的庞然大物。换言之，这两句话带给我们的信息量是不同的，原核生物复活的可能性大，信息量就小；恐龙复活的可能性小，信息量就大。
2.自信息量 那么信息量的大小如何度量呢？前面说到信息是对事物不确定性的描述，不确定性与事件发生的概率有关，概率越小，不确定性越大，事件发生后所含的信息量就越大。
设事件的概率为,则它的自信息量为
代表两种含义：在事件发生以前，表示事件发生的不确定性的大小；在事件发生以后，表示事件所包含的信息量。
式中对数的底可任取，
底为2时，单位为比特 (bit); 底为e时，单位为奈特 (nat); 底为10时，单位为哈特 (hart). 一般取2为底，常省略。
注：因为我们考察的只是一个随机事件本身的信息量，所以称为自信息，如果考察两个事件的相互影响，则为互信息。互信息我们未使用，暂且不谈。
3.信息熵—平均自信息量 信息熵是对系统平均不确定性的描述。从概率统计的角度，信息熵就是随机变量的函数的期望，也就是所有事件自信息量的加权平均，即
其中，为的所有可能取值个数。
例：随机变量对应的概率空间为
0.98
0.01
0.01
则的信息熵为
4.联合熵与条件熵 将联合自信息与条件自信息进行平均，便得到联合熵与条件熵。
假设二维随机变量的概率空间为
联合熵定义为联合自信息的数学期望，是二维随机变量的不确定性的度量
条件熵 表示在已知随机变量X的条件下随机变量Y的不确定性。定义为X给定条件下Y的条件概率分布的熵对X的数学期望
其中，，即为给定的条件下Y的条件概率分布的熵。代入上式展开为
信息熵与联合熵、条件熵的关系： 5.交叉熵(Cross Entropy) 形式上，交叉熵是一个随机变量的概率分布对另一个概率分布定义的自信息的数学期望，表示为
如果为某个数据集的真实分布，为非真实的近似分布，交叉熵就表示使用分布来消除分布的不确定性所需代价的大小。
由吉布斯不等式（当时等号成立）知，信息熵是消除系统不确定性所需的最小代价，真实分布与任何其他非真实分布的交叉熵都比其自身的信息熵大。这也就是说，交叉熵能够反映两个分布的差异性大小，交叉熵越小，近似分布就越接近真实分布（如果分布就是分布了，那么交叉熵就是信息熵，即，此时消除系统不确定性所需代价达到最小）。所以一些分类算法中经常使用交叉熵作为损失函数。
6.相对熵（K-L散度） 交叉熵间接反映了两个分布的差异性大小，更直接一点，如果用分布近似分布，那么它们的差异性究竟有多大呢？我们可以用两者的相对熵（K-L散度，也就是两者熵之差）来定量衡量。
用分布近似真实分布，交叉熵为
真实分布自身的信息熵为
相对熵（K-L散度），即两者熵之差为：
它恒为正值，直接地衡量了两个分布差异性的大小。 在分类算法中，我们需要评估优化标签和预测值之间的差距，使用KL散度正好合适，只不过是固定不变的，所以我们只需要使用前半部分的交叉熵就可以了。也有人将K-L散度称为两个分布的K-L距离，只是它不是对称的，即.
pdf下载
参考：
李亦农,李梅 《信息论基础教程》李航 《统计学习方法》简书 https://www.jianshu.com/p/43318a3dc715?from=timeline知乎 https://www.zhihu.com/question/41252833维基百科 https://en.wikipedia.org/wiki/Gibbs%27_inequality 转载于:https://www.cnblogs.com/alexhg/p/10953813.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c96b9119b1ea0850c612fd0caf55a8a/" rel="bookmark">
			C语言--memset结构体初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 memset可以方便的清空一个结构类型的变量或数组。如：
struct sample_struct { char csName[16]; int iSeq; int iType; }; 对于变量 struct sample_strcut stTest;
一般情况下，清空stTest的方法：
stTest.csName[0]='\0'; stTest.iSeq=0; stTest.iType=0; 用memset就非常方便：
memset(&amp;stTest,0,sizeof(struct sample_struct)); 如果是数组：
struct sample_struct TEST[10]; 则
memset(TEST,0,sizeof(struct sample_struct)*10); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba6a180708ee10cb45588ee88eef15c/" rel="bookmark">
			Spring的自动装配是什么？有哪些自动装配？byType、byName、constructor、@AutoWired、@Resource、@Value有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring的自动装配是什么？ spring中提供了向Bean中自动注入依赖的功能，这个过程就是自动装配，当向bean中注入的内容非常多的时候，自动注入依赖的功能将极大的节省注入程序的时间。
Spring自动装配有两类：
基于xml文件的自动装配：byType(类型），byName(名称)， constructor(根据构造函数）
基于注解的自动装配：@Autowired，@Resource，@Value
使用XML文件的自动装配 使用xml文件的自动装配有三种类型：
byType byName constructor
byType(类型） 在byType(类型模式中）spring容器会基于反射查看bean定义的类，然后找到依赖类型相同的bean注入到另外的bean中，这个过程需要setter注入来完成，因此必须存在setter方法，否则就会注入失败
Dao实现层 public class UserDaoImpl implements UserDao{ @override public void done(){ System.out.println("UserDaoImpl.invoke....."); } } Service层 public class UserServiceImpl implements UserService{ private UserDao userDao； @param userDao // 在这里将属性注入了进去 public void setUserDao(UserDao userDao){ this.UserDao=userDao; } @override public void done(){ userDao.done(); } } 对应的配置文件为： &lt;bean id="userDao“ class="com.spring.springioc.dao.impl.UserDaoImpl”/&gt; &lt;!--byType根据类型自动装配userDao--&gt; &lt;bean id="userService" autowire="byType" class="com.spring.springioc.service.impl.UserServiceImpl"/&gt; 对应的测试代码为 @Test public void test3(){ ApplicationContext applicationContext=new ClassPathXMLApplicationContext("/spring/spring-ioc2.xml"); UserSercie userService=(userService）applicationContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dba6a180708ee10cb45588ee88eef15c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e368ced4473f3c1154442cebaf4ea7c/" rel="bookmark">
			无法获取dubbo目标类名问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在应用端想拦截dubbo client方法的类名，除了实现dubbo 的Filter外，可以使用@Aspect注解和实现MethodInterceptor 接口。但是消费端proxy必须设置jdk，否则获取到的都是“com.alibaba.dubbo.common.bytecode.proxy0”代理类名。
1.使用@Aspect注解核心代码段
Method method = ((MethodSignature) pjp.getSignature()).getMethod(); Class&lt;?&gt; clazz = method.getDeclaringClass(); ManagerMethodInfo info = new ManagerMethodInfo(); info.setClazz(clazz.getName()); info.setMethod(method.getName()); 2.实现MethodInterceptor接口核心代码段 Method method = invocation.getMethod(); Class&lt;?&gt; clazz = method.getDeclaringClass(); ManagerMethodInfo info = new ManagerMethodInfo(); info.setClazz(clazz.getName()); info.setMethod(method.getName()); 3.dubbo消费端配置方式-xml方式 &lt;dubbo:consumer check="false" proxy="jdk" retries="0" timeout="10000"/&gt; 4.3.dubbo消费端配置方式-spring boot方式
@Configuration public class DubboProviderConf { @Resource private ApplicationConfig applicationConfig; @Resource private RegistryConfig registryConfig; @Bean public ReferenceBean&lt;VerifyCodeService&gt; verifyCodeService() { return getRef(VerifyCodeService.class); } private &lt;T&gt; ReferenceBean&lt;T&gt; getRef(Class&lt;T&gt; tClass) { return getRef(tClass, 3000); } private &lt;T&gt; ReferenceBean&lt;T&gt; getRef(Class&lt;T&gt; tClass, Integer timeout) { return getRef(tClass, timeout, 0, true); } private &lt;T&gt; ReferenceBean&lt;T&gt; getRefNotCheck(Class&lt;T&gt; tClass, Integer timeout) { return getRef(tClass, timeout, 0, false); } private &lt;T&gt; ReferenceBean&lt;T&gt; getRef(Class&lt;T&gt; tClass, Integer timeout, Integer retry, boolean check) { ReferenceBean&lt;T&gt; config = new ReferenceBean&lt;T&gt;(); config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e368ced4473f3c1154442cebaf4ea7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b97d0907f46b6eb2dfc7359edf33c6/" rel="bookmark">
			周期性线程池newScheduledThreadPool详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
return new ScheduledThreadPoolExecutor(corePoolSize);
}
ScheduledThreadPoolExecutor类的构造：
public ScheduledThreadPoolExecutor(int corePoolSize) {
super(corePoolSize, Integer.MAX_VALUE, 0, TimeUnit.NANOSECONDS,
new DelayedWorkQueue());
}
此线程池keepAliveTime参数为0，缓存对列为DelayedWorkQueue。
jdk1.5之前的版本中更多的是借助Timer类来实现，Timer和ScheduledThreadPoolExecutor的区别：
a.Timer单线程运行，一旦任务执行缓慢，下一个任务就会推迟，而如果使用了ScheduledThreadPoolExecutor线程数可以自行控制
b.当Timer中的一个任务抛出异常时，会导致其他所有任务不在执行
c.ScheduledThreadPoolExecutor可执行异步的任务，从而得到执行结果
ScheduledExecutorService接口继承了ExecutorService，在ExecutorService的基础上新增了以下几个方法：
①schedule方法： public ScheduledFuture&lt;?&gt; schedule(Runnable command,
long delay, TimeUnit unit);
command：执行的任务 Callable或Runnable接口实现类
delay：延时执行任务的时间
unit：延迟时间单位
示例：
ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
ScheduledFuture&lt;String&gt; scheduledFuture = executorService.schedule(new Callable&lt;String&gt;() {
public String call() throws Exception {
return "call";
}
}, 10, TimeUnit.SECONDS);
System.out.println(scheduledFuture.get());
executorService.shutdown();
延迟10秒后，返回call字符串并输出。
执行任务案例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4b97d0907f46b6eb2dfc7359edf33c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1624a4cb553e94169967f85d811dd17c/" rel="bookmark">
			GPIO的内部结构和工作模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接已放至最上方，大家如果有疑惑也可直接观看参考链接。
[1]https://www.eefocus.com/component/405097/r0
[2]https://blog.csdn.net/techexchangeischeap/article/details/72569999
GPIO支持三种最大翻转速度：2MHz、10MHz、50MHz。每个I/O口可以自由编程，但I/O寄存器必须按32位字被访问。GPIO共有8种工作模式，通过编程选择相应的工作模式。
一、输入： 浮空输入、上拉输入、下拉输入、模拟输入 [1]
（一）浮空输入 1)外部通过IO口输入电平(上下拉电阻处于关闭状态)
2)传输到施密特触发器(此时施密特触发器为打开状态)
3)继续传输到输入数据寄存器IDR
4)CPU通过读输入数据寄存器IDR实现读取外部输入电平值
施密特触发器可以解决基本IO电路在读取外部信号的跳变沿时出现的抖动现象 [2]。浮空输入容易受外部噪声信号干扰，改变输入端检测到的电平 [2]。
（二）上拉输入 外部输入通过上拉电阻，施密特触发器存入输入数据寄存器IDR，被CPU读取。
输入上拉模式有上拉电阻连接至VDD，上拉电阻开关接通，阻值约30-50K [1]。当输入管脚悬空时不受外部噪声信号干扰。对于此种输入方式，无论输入管脚悬空或者被高电平驱动时，读取的都是1。只有在输入端为0的时候，读取到的值才是0。因此采取的时非0输入模式。即若读取非0，即为1，若读取为0，即为0 [2]。
（三）下拉输入 与上拉模式相同，外部输入通过下拉电阻，施密特触发器存入输入数据寄存器IDR，被CPU读取。
输入下拉模式有下拉电阻连接至VSS，下拉电阻开关接通，阻值约30-50K [1]。但是该电路对外呈现的不是高阻，某种意义上说也在向外输出，当外部驱动电路不同时可能出现错误的检测结果 [2]。
（四）模拟输入 此时，上下拉处于关闭状态。施密特触发器处于截止状态。通过模拟输入通道输入到CPU，IO口外部电压为模拟量(电压形式非电平形式),作为模拟输入范围一般为0~3.3V [1]。
二、输出： 推挽输出、开漏输出、推挽复用输出IO、开漏复用输出IO
（一）开漏输出 开漏输出即三极管的集电极或者MOS管的漏极进行输出。开漏输出可以实现线与功能。开漏输出只能输出强低电平，高电平需要依靠外部上拉电子拉高，适合做电流型驱动，吸收电流能力较强[1]。
1）CPU写入位设置/清楚寄存器BSRR,映射到输出数据寄存器ODR
2）联通到输出控制电路(也就是ODR的电平)
3）ODR电平通过输出控制电路进入N-MOS管
1、ODR输出0：
N-MOS截止，IO端口电平不会由ODR输出决定，而由外部上拉/下拉决定　在输出状态下，输出的电平可以被读取，数据存入输入数据寄存器，由CPU读取，实现CPU读取输出电平　所以，当N-MOS截止时，如果读取到输出电平为1，不一定是我们输出的1，有可能是外部上拉产生的1
2、ODR输出1：
N-MOS开启，IO端口电平被N-MOS管拉倒VSS，使IO输出低电平。此时输出的低电平同样可以被CPU读取到
（二）推挽输出 与开漏式输出不同，推挽式输出采用上图结构。推挽输出可以采取强高/强低输出，可以连接数字电路。[1-2]
但推挽输出的一个缺点是，如果当两个推挽输出结构相连在一起，一个输出高电平，即上面的MOS导通，下面的MOS闭合时；同时另一个输出低电平，即上面的MOS闭合，下面的MOS导通时。电流会从第一个引脚的VCC通过上端MOS再经过第二个引脚的下端MOS直接流向GND。整个通路上电阻很小，会发生短路，进而可能造成端口的损害。这也是为什么推挽输出不能实现" 线与"的原因。[2]
（三）推挽复用输出IO 与推挽输出模式唯一的区别在于输出控制电路之前电平的来源，推挽输出模式的输出电平是由CPU写入输出数据寄存器控制的，推挽复用输出模式的输出电平是由复用功能外设输出决定的。其他与开漏输出模式相似。
（四）开漏复用输出IO 与开漏输出模式唯一的区别在于输出控制电路之前电平的来源。开漏输出模式的输出电平是由CPU写入输出数据寄存器控制的，开漏复用输出模式的输出电平是由复用功能外设输出决定的。其他与开漏输出模式相似。
https://blog.csdn.net/qq_38410730/article/details/79858906
https://blog.csdn.net/huanggenda568/article/details/7723238
https://www.cnblogs.com/sky-heaven/p/8553951.html
https://wenku.baidu.com/view/b627eb2b482fb4daa58d4b80.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd6b0b456528b8b8e6793eb233957ed/" rel="bookmark">
			sklearn机器学习（六）逻辑回归实例乳腺癌检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节采用逻辑回归算法完成乳腺癌的检测。
逻辑回归主要用于这种二项分类问题，采用sigmoid函数作为预测函数，当x=0时，sigmoid函数的值为0.5，之后向两边趋近，因此它得到的结果都是非黑及白的。例如划分乳腺癌是为阴性还是阳性，就比较好划分
from sklearn.datasets import load_breast_cancer cancer=load_breast_cancer()#加载乳腺癌数据 x=cancer.data#加载乳腺癌判别特征 y=cancer.target#两个特征，y=0时为阴性，y=1时为阳性 print('data shape:{0};no.positive:{1};no.negative:{2}'.format(x.shape,y[y==1].shape,y[y==0].shape)) print(cancer.data[0])#输出 以下是上代码块的输出：
data shape:(569, 30);no.positive:(357,);no.negative:(212,)
[1.799e+01 1.038e+01 1.228e+02 1.001e+03 1.184e-01 2.776e-01 3.001e-01
1.471e-01 2.419e-01 7.871e-02 1.095e+00 9.053e-01 8.589e+00 1.534e+02
6.399e-03 4.904e-02 5.373e-02 1.587e-02 3.003e-02 6.193e-03 2.538e+01
1.733e+01 1.846e+02 2.019e+03 1.622e-01 6.656e-01 7.119e-01 2.654e-01
4.601e-01 1.189e-01]
从中我们可以看出X中data一共有569个数据，30个特征。只是其关注特征其实为10个，即为
radius：半径，即病灶中心点离边界的平均距离
texture：纹理，灰度值的标准偏差
perimeter：周长，即病灶的大小
area：面积，反映病灶大小的一个指标
smoothness：平滑度，即半径的变化幅度
compactness：密实度，周长的平方除以面积的熵，再减一
concavity：凹度，凹陷部分轮廓的严重程度
concave points：凹点，凹陷轮廓的数量
symmetry：对称性
fractal dimension：分形维度
每一个有着对应的标准差与最大值，所以这里会有30个特征值。
from sklearn.model_selection import train_test_split X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.2)#划分训练集和测试集 from sklearn.linear_model import LogisticRegression model=LogisticRegression()#逻辑回归模型的建立 model=fit(X_train,y_train)#逻辑回归模型的训练 train_score=model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bd6b0b456528b8b8e6793eb233957ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a462cb13eacb2ba3b6e8edd2596770a9/" rel="bookmark">
			GreenPlum数据分布以及执行计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行计划/数据分布情况 1.Gather Motion (N:1)，聚合，每个节点将表查询后的数据发到主节点master上聚合起来，哪个节点的数据先返回就将此数据先放在master上。
2.Redistribute Motion (N:N) ，重新分布，利用join的列值hash不同，将新的分布键（关联键）重新打散到每个segment重新分布。 3.Broadcast Motion (N:N) ,广播，将表的数据全量的发送到每一个节点进行，即每个节点相当于一份全量数据去进行join等操作。
1.当进行join操作时，如果发生广播，GP会优先将小表广播到各个segment上，如果关联表都很大，则广播数据网络就会成为瓶颈。
2.当关联的多表的分布键和关联键相同，在单库查询时，就不会造成广播和重分布。
3.如果关联的2个表，A表关联键是分布键，B表不是,执行计划则通过2表的数量集采用2种方式来实现表关联。
（1）根据B表的关联键重新分布，发布到各个节点，然后各个节点的数据内部join。
（2）将A表广播，每个节点都放置一份全量A数据，再与各表的B数据关联。
GP案例 1.演示 选择正确的分布键 db_zbtest SELECT count(*) FROM db_zbtest.t_ajhz a
WHERE EXISTS (SELECT 1 FROM db_zbtest.t_gzhz_aj b WHERE a.c_bh_aj = b.c_bh_aj) ;
--数据量
select 't_ajhz', count(1) from db_zbtest.t_ajhz
union ALL
select 't_gzhz_aj', count(1) from db_zbtest.t_gzhz_aj
--原始默认分布键
alter table db_zbtest.t_gzhz_aj set distributed by (c_bh_gz);
--分布键
alter table db_zbtest.t_gzhz_aj set distributed by (c_bh_aj);
--数据分布
select gp_segment_id,count(1) from db_zbtest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a462cb13eacb2ba3b6e8edd2596770a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/636cfeb39ce9fea9d87762cd37fbade8/" rel="bookmark">
			[flowable]启动卡住liquibase.lockservice.StandardLockService - Waiting for changelog lock....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 打开日志，级别从warn调为info修改表ACT_CMMN_DATABASECHANGELOGLOCK 2019-05-29 15:40:24.563 [restartedMain] INFO liquibase.executor.jvm.JdbcExecutor - SELECT `LOCKED` FROM crm.ACT_CMMN_DATABASECHANGELOGLOCK WHERE ID=1 2019-05-29 15:40:24.570 [restartedMain] INFO liquibase.lockservice.StandardLockService - Waiting for changelog lock.... 解决:把1改为0
https://blog.csdn.net/qq_36196686/article/details/80604759
转载于:https://my.oschina.net/u/2464371/blog/3055871
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7dc6c52c806c15d78f5f2145e38f62/" rel="bookmark">
			SFTP向服务器上传文件失败问题的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FileZilla和XShell都可以通过FTP传输文件。
FileZilla连接上服务器后，可以下载文件，但是不能上传，传输会有提示：“无法启动传输”。
这个问题一般情况有如下三个原因：
1、文件夹权限不够，修改之（chmod 777 文件夹名）；
2、你的空间或服务器已经满了，请空下回收站或者扩容（查看命令：df -lh）；
3、文件正在被占用，关闭后传输。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7da73d2d6a96f1a293b94f0c3e16cfd/" rel="bookmark">
			深度学习笔记（一）DNN-在mnist数据集上用keras搭建dnn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文代码运行的环境为:
ubuntu 16.04 64cuda=9.0cudnn=7.0.5tensorflow=1.12.0python=3.6.4(anaconda 3.5.1) 本文包含的知识点有:
Keras简介Keras使用Sequential序列模型Keras模型可视化Keras模型编译运行Keras模型保存与加载 1. Keras 简介 Keras 是一个用于构建和训练深度学习模型的高阶 API。它可用于快速设计原型、高级研究和生产。当我们有一些新的想法时，可以借助keras快速实现。tensorflow1.x是支持keras高层API的，内置于TensorFlow的Keras版本在原先的基础上增加了具有TensorFlow特定的增强功能。所以文章中的代码都是基于tensorflow内置keras实现的。
这里需要说明为什么使用tf 1.x而不是最新的2.0中的keras。目前tf 2.0中的keras和1.x中的keras可以做到一定程度兼容。但是tensorflow2.0吧，感觉不太稳定；另外不怕被人笑话，像我这种面向开源项目编程的选手，需要用到了2.0版本的代码时，才会去学2.0。所以本文中代码全是在1.x环境实现的。
2. Keras实现dnn手写数据的识别 2.1 数据加载和参数定义 import numpy as np from tensorflow.keras.datasets import mnist from tensorflow.keras.utils import to_categorical, plot_model from tensorflow.keras.models import Sequential, load_model from tensorflow.keras.layers import Dense, Dropout from tensorflow.keras.optimizers import SGD, Adam from tensorflow.keras.regularizers import l2 # load data and configure parameters x_dim = 28*28 num_classes = 10 batch_size = 50 epochs=10 (x_train, y_train), (x_test, y_test) = mnist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7da73d2d6a96f1a293b94f0c3e16cfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c139c22972cf335701e77abaf130c16a/" rel="bookmark">
			解决mybatis IN语句拼接sql过长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 前言 1、mybatis作为轻量级的orm框架被广泛使用 但是也有其不完善地方。例如mybatis对IN语句的支持，自生成IN的辅助查询类不可传空集合
2、oracle在sql中in的元素集合元素个数不能超过1000 但是可以通过多个in的元素集合通过 or进行组合
二 解决方案 1、使用mybatis自定义xml编写
SELECT * FROM TABLE WHERE ID IN &lt;foreach collection="Array" index="index" item="item" open="(" close=")"&gt; &lt;if test="index != 0"&gt; &lt;choose&gt; &lt;when test="index % 1000 == 999"&gt; ) OR ID IN( &lt;/when&gt; &lt;otherwise&gt;,&lt;/otherwise&gt; &lt;/choose&gt; &lt;/if&gt; #{item} &lt;/foreach&gt; 1、Array为ids集合 2、代码逻辑如下 ###open： （ ###index：0 ids[0] ###index：i!=N*1000+999 , ids[i] ###index：i=N*1000+999 ) OR ID IN ( ids[i] ###index：i!=N*1000+999 , ids[i] ###close： ） 则ql ID IN（ids[0],ids[1]+...+ids[998]）OR ID IN (ids[999],ids[1000],.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c139c22972cf335701e77abaf130c16a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f814e2b452ab5dbc4e34c83a2de247/" rel="bookmark">
			关于内网使用Nginx正向代理发送极光推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于内网使用Nginx正向代理发送极光推送 一 业务场景二 使用极光前的准备工作三 配置nginx.conf四 极光推送部分代码结束语 一 业务场景 微信支付返回交易信息到内网的系统，信息由内网系统处理后访问极光提供的API https://api.jpush.cn/v3/push 由此来完成消息的推送。内网系统不能直接访问外网，准备使用nginx做正向代理访问极光的API。 二 使用极光前的准备工作 1 下载极光的jar包添加到项目中 2 服务器安装nginx 由于管网的文档很详细，以上两步自行解决。 三 配置nginx.conf 1 服务器IP 假设nginx IP为 33.33.33.33 2 极光IP 极光域名 api.jpush.cn 的IP是动态变化的，官方建议是开放域名访问，最要不要在hosts里绑定IP。 官方有几个固定IP 113.31.138.48 113.31.138.47 183.232.57.12 但是不保证固定不变，并且如果有变动也只会主动通知极光的VIP。 所以你可以用固定的IP，也可以ping一下 api.jpush.cn 得到IP。 我就使用的 113.31.138.48 PS：使用极光V3接口（只支持https请求）要开放443端口（），使用V2接口要开放80端口，但是后者已经不再维护了，所以不建议使用。 3 配置hosts view /etc/hosts 在hosts文件解析域名 113.31.138.48 api.jpush.cn 保存 4 配置nginx.conf nginx.conf一版在默认目录 /etc/niginx/ 下 http { log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12f814e2b452ab5dbc4e34c83a2de247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50eea88dffd0f91e282d9c9f56a14536/" rel="bookmark">
			Bi-lstm&#43;CRF实现NER（随机生成词向量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尊敬的读者您好：笔者很高兴自己的文章能被阅读，但原创与编辑均不易，所以转载请必须注明本文出处并附上本文地址超链接以及博主博客地址：https://blog.csdn.net/vensmallzeng。若觉得本文对您有益处还请帮忙点个赞鼓励一下，笔者在此感谢每一位读者，如需联系笔者，请记下邮箱：zengzenghe@gmail.com，谢谢合作！
最近跟进的项目中时刻不离NER任务，笔者团队采用过多个版本bi-lstm+CRF程序去实现NER的bi-lstm+CRF，感觉每个版本都有每个版本的优势，所以下面就来分享第一个版本，该版本中的输入词向量是随机生成的并且所有的.py文件中有不容易读懂的地方，笔者都进行了注释，方便自己也方便大家。
1、如果需要本文源码请自行转向“https://download.csdn.net/download/vensmallzeng/11212457”。
2、该版本主要包括以下几个部分：
checkpoints文件夹用于保存训练好的模型以及参数；
data文件夹用于保存训练、验证、测试数据等；
tensorboard文件夹用于保存张量可视化的数据； 3、Data_process.py文件包含一些数据预处理的函数如read_data、build_vocab、sequence2id以及process_seq等，各函数具体功能见注释。
4、Parameters.py文件见其名知其义，应该存放一些用于模型训练、测试的参数。
5、biLstm_Crf.py文件主要是用于实现bi-Lstm+CRF功能，下面将着重介绍该文件。
首先随机生成词向量（每一次训练都会重新生成，所以省去了预训练词向量的工作），生成的词向量被用于查询bi-Lstm+CRF模型的输入词向量。
然后构建bi-Lstm+CRF模型，该模型的输入为查询得到的词向量。
bi-Lstm层：
CRF层：
损失函数用的是最大似然函数，这里采用梯度下降算法来优化损失函数，所以需要给损失函数加负号：
优化损失函数
模型搭建好后要考虑给模型喂数据，因此需要将数据按要求进行打包处理之后方能喂给模型。
模型测试调用代码
实际应用调用代码
6、Train_Model.py文件主要是用于训练bi-Lstm+CRF模型，并将训练好的模型参数保存下来，以便后期直接调用。
7、serve.py文件主要是用于实际应用，可以实现输入一句话，自动提取出人名、地点和机构。
主体代码如下：
实际效果如下：
最后想和大家谈谈几个关于Bi-lstm+CRF的个人总结：
① 与传统Lstm不同，双向Lstm同时考虑了过去的特征（通过前向过程提取）和未来的特征（通过后向过程提取）。说直白点，后向过程其实相当于将原始序列逆向输入到Lstm中。因此从这个角度来看，双向Lstm相当于两个Lstm（一个正向输入序列，一个反向输入序列），最后将两者的输出结合起来作为最终的结果。
② 采用CRF层的原因：Bi-lstm考虑了输入词(字符)向量序列的上下文信息，CRF考虑了tag之间的依赖关系信息，因此二者结合无疑可以选择出最适合的预测tag序列。
如：句子的开始单词的标签类型应该是B或O，而不是I；限制一些格式，B-Person I-Person是合理的，B-Person I-Organization是不合理的
③ 需要训练的参数有：Bi-lstm中的参数与CRF中转移概率矩阵A
④ Bi-lstm+CRF训练时采用监督学习方法，通过最大化预测为真实标记序列的概率（将概率取对数再取负，然后用梯度下降算法优化）来更新Bi-lstm中的参数与CRF中转移概率矩阵A。虽然刚开始训练“真实标记序列不会对应最大的概率值”，但通过样本的连续迭代优化，最终会实现“真实标记序列应该对应最大的概率值”；Bi-lstm+CRF测试时，直接根据训练好的参数求出所有可能的预测序列对应的得分（这里应该会用到维特比算法），最后取对应最大得分的预测序列作为最终预测结果。
⑤ Bi-lstm+CRF的输入是一组词（字符）向量，输出是一组预测tag序列。
参考文献：
【1】https://blog.csdn.net/bobobe/article/details/80489303
日积月累，与君共进，增增小结，未完待续。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98633902b0e0db2fa0f0e149a5b66d41/" rel="bookmark">
			C&#43;&#43; 简单的多线程测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;thread&gt; using namespace std; static const long STEP = 100000000; long long sum[10] = { 0 }; long long totalSum = 0; int Flag[10] = { 0 }; void getSum(int idx) { long begin = idx * STEP; for (long i = 0; i &lt; STEP; i++){ sum[idx] += begin + i; } Flag[idx] = 1; printf("sum[%d] = %lld\n", idx, sum[idx]); } int main() { for (int i = 0; i &lt; 10; i++) { thread t(getSum, i); t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98633902b0e0db2fa0f0e149a5b66d41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482fbd87a5318984a844bd67e66641d2/" rel="bookmark">
			盘点一些跨端框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 盘点一些跨端框架 Chameleon 变色龙
滴滴开源的跨端框架：一套代码运行多端，一端所见即多端所见（5.1 star）
omi
腾讯：基于 Web Components 并支持 IE8+(omio)，小程序(omip) 和 任意前端框架集成（9k star）
uni-app
7端跨端框架：uni-app 是一个使用 Vue.js 开发跨平台应用的前端框架（7.5k star）
taro
JD:多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信/百度/支付宝/字节跳动小程序、H5、React Native 等的应用。(18.8k star)
react native
使用JavaScript和React构建本机移动应用程序(77.6k star)
Vue weex
阿里：基于vue构建移动跨平台UI的框架(17.5k star)
ionic
开源移动应用程序开发框架，可以使用Web技术轻松构建高质量的原生和渐进式Web应用程序,已经支持vue了(38.1k star)
flutter
Flutter可以轻松快速地构建漂亮的移动应用程序。今年支持web端了(65.2k star)
Hybrid APP， PhoneGap/Cordova
比较早期的构建移动端应用工具，性能上和其他的相比较落后
​ posted on 2019-05-28 14:46 calamus 阅读( ...) 评论( ...) 编辑 收藏 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f1fa481e4854bb3c7d557b95ada023/" rel="bookmark">
			ImportError: DLL load failed: 找不到指定的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装tensorflow pip install tensorflow==1.4.0
在安装完tensorflow后执行
&gt;&gt;&gt; import tensorflow as tf时，报错，错误信息
Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "E:\anaconda\lib\site-packages\tensorflow\__init__.py", line 24, in &lt;module&gt; from tensorflow.python import * File "E:\anaconda\lib\site-packages\tensorflow\python\__init__.py", line 52, in &lt;module&gt; from tensorflow.core.framework.graph_pb2 import * File "E:\anaconda\lib\site-packages\tensorflow\core\framework\graph_pb2.py", line 6, in &lt;mo dule&gt; from google.protobuf import descriptor as _descriptor File "E:\anaconda\lib\site-packages\google\protobuf\descriptor.py", line 47, in &lt;module&gt; from google.protobuf.pyext import _message ImportError: DLL load failed: 找不到指定的程序。 解决：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50f1fa481e4854bb3c7d557b95ada023/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a568e8d830fde11846348f77b443af/" rel="bookmark">
			vue移动端使用video标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 移动端播放视频之前没用过，这个学习网上找到一个可以学习方法
HTML部分：
&lt;div v-on:click="playVideo()"&gt; &lt;video :src="videoSrc" id="videoPlay" v-show="false" class="video"&gt;您的浏览器不支持 video 视屏播放。&lt;/video&gt; //隐藏video标签，因为移动端点击视频播放时会自动弹出 &lt;/div&gt; JS部分：
export default{ data(){ return { videoSrc: 'example.mp4' //获取视频播放资源 } }, methods: { playVideo(){ var vdo = document.getElementById("videoPlay"); vdo.play(); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1531a6e3a66bb1d1399bc642dc94d5db/" rel="bookmark">
			vue中把含有html标签转为html渲染页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在标签内部添加v-html指令即可
使用pug的写法：
这个content表示的是一个含标签的变量
输入content为：&lt;p&gt;我是p标签&lt;/p&gt;
输出结果是：我是p标签
普通用户一样：
同上理
加v-html就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876d27d3f46785885865485397a0b9be/" rel="bookmark">
			常用PHP商城系统缓存技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在研究商城系统源码，市面上的很多开源商城系统都支持缓存技术，比如DSMall开源商城系统之类的都支持以下缓存技术。
1、全页面静态化缓存 全页面静态化缓存是将页面全部生成html静态页面，用户访问时直接访问的静态页面，而不会去走php服务器解析的流程。此种方式在CMS系统中比较常见，如dedecms。 比较常用的实现方式是直接写入Html：
2、页面部分缓存 该种方式，是将一个页面中不经常变的部分进行静态缓存，而经常变化的块不缓存，最后组装在一起显示；可以使用类似于ob_get_contents的方式实现，也可以利用类似ESI之类的页面片段缓存策略，使其用来做动态页面中相对静态的片段部分的缓存。
3、数据缓存 缓存数据的一种方式；比如，商城系统中的为了获取某条信息，当用固定id去请求时，就会得出包括对应ID所相关的数据数据，此时就可以将这些数据写入缓存到一个php文件中，用于保存，缓存文件包含固定id来建一个唯一标示；下一次有人想查看这个商品时，首先判断缓存中是否有此条数据，缓存是否过期，如果合理就直接获取数据，如果没有，就直接查询数据库，写入数据，其实缓存文件中缓存的就是一个php数组之类。
4、内存缓存 通过缓存查询结果，来减少数据库的访问次数，从而提高网站的响应速度。通常使用redis,memcached等nosql数据库设置PHP缓存，Redis是一个开源的数据库，支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 memcached是一套分布式的高速缓存系统，被许多网站使用。这是一套开放源代码软件。
5、apache缓存模块 apache安装完以后，是不允许被cache的。如果外接了cache或squid服务器要求进行web加速的话，就需要在htttpd.conf里进行设置，当然前提是在安装apache的时候要激活mod_cache的模块。
5、php APC缓存扩展 Php有一个APC缓存扩展，windows下面为php_apc.dll，需要先加载这个模块，然后是在php.ini里面进行配置。
转载于:https://my.oschina.net/u/3952157/blog/3054969
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99599988718bc626fc5b1e98504f671c/" rel="bookmark">
			CentOS7忘记root密码的处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7忘记root密码（实践有效）。
如果在操作过程中发现无效，看看是不是自己在修改密码的时候小键盘没开启，因为这个我还一度怀疑这个流程不对，因为我在虚拟机里配置的，所以小键盘每次都要手动开启，文章转载自：
原文：https://blog.csdn.net/q290994/article/details/78825667 步骤
1.启动系统，在GRUB2引导画面，按E键，编辑引导项 2.删除linux16这一行最后的 rhgb和 quiet参数（在UEFI系统中是linuxefi），删除rhgb和quiet这两个参数是为了显示系统信息 3.添加以下参数：rd.break enforcing=0 在64位IBM Power Series是linux这一行尾；在x86-64 BIOS引导的系统中是linux16这一行尾；在UEFI引导的系统中是linuxefi这一行尾 4.按CTRL+X用改变的参数引导系统 5.在/sysroot/文件系统被挂载为只读时，你不能改变密码，因为文件系统为不可写入。重新挂载文件系统为可写入。 mount -o remount,rw /sysroot
6.文件系统被重新挂载为可写，像下面这样改变文件系统的root chroot /sysroot
7.输入passwd命令，接下来命令行提示改变root密码 8.更新password文件会导致SELinux安全上下文文件错误。键入以下命令在下次系统引导前重新标记所有文件： touch /.autorelabel
9.重新挂载系统为只读： mount -o remount,ro / 10.键入exit命令退出chroot环境： exit
11.再次键入exit命令完成初始化，完成系统引导。 exit 至此，密码修改成功，完成最后一步exit后会等待时间长一点，然后便会进入启动页面输入root用户的密码后可以成功登陆了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb54b310bcef954876c61a34c13ee0e/" rel="bookmark">
			postgresql报错28000 pg_hba.conf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的开发环境是C#，，报错信息如下：
Npgsql.NpgsqlException: ????????: 28000: ??????????? "172.19.71.20", ??? "postgres", ????? "opp", SSL ??? ?? pg_hba.conf ???
网上搜索一圈后，用这个办法解决：
1，找到pg_hba.conf文件，并打开。
2，在ipv4那里添加一行，保存，重启postgresql，再试就可以了。
# IPv4 local connections:
host all all 127.0.0.1/32 md5
hostnossl all all 0.0.0.0/0 md5
祝大家成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2fbe1c0476f4afb95af4ee6dcbfa18b/" rel="bookmark">
			Opencv：验证码图像处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇讲的主要是对验证码图片的二值去边去线降噪。
最近天热了。人也有点疲惫，不打太多字。
首先安装 opencv ：（点击链接查看）
https://blog.csdn.net/weixin_43582101/article/details/88660570
我自己画了个图（下文图片数据根据这张图写的）
图片名：1234567.png：
读入图片1234567.png
import cv2 im = cv2.imread('1234567.png') 使用cvtColor方法进行颜色空间转换，转成黑白的
im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY) 可以保存下看看：
cv2.imwrite('33333.png',im) 然后我们先去除边框：
啥原理呢，就是把这个边框范围的 所有坐标的像素 都变成 255 白色的。这个具体要看你的图片的边框值是多少，需要你看情况。
def clear_border(img): h, w = img.shape[:2] # h高、w宽 for y in range(0, w): for x in range(0, h): if y &lt; 50 or y &gt; w - 61: # 把在50以内的像素坐标[0,0]到[高,50],[0,宽-50]到[高，宽]，都变白色 img[x, y] = 255 if x &lt; 60 or x &gt; h - 60: # 如上 img[x, y] = 255 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2fbe1c0476f4afb95af4ee6dcbfa18b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e67479890461657504ba6997d9baed53/" rel="bookmark">
			sqlsever 2008 创建用户并指定该用户只能看指定的视图或表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，在sql server中选择好要操作的数据库
2,--当前数据库创建角色 exec sp_addrole '*****' --创建了一个数据库角色，名称为:[seeview]
3,--分配视图权限 GRANT SELECT ON veiw TO [角色] --指定视图列表 指定“****”这个角色可以查看的视图表名称；也就是这个角色可以查看下面赋予这些视图信息，除此之外的所有的东西都看不到
GRANT SELECT ON 表名或视图名 TO （建立的角色）
4,--添加只允许访问指定视图的用户: exec sp_addlogin '登录名','密码','默认数据库名' exec sp_addlogin '****','****','****’ 要求密码强度要带有大小写和数字，可手工进行在登录用户中创建
5,--添加只允许访问指定视图的用户到（指定的角色-2中创建的角色）: exec sp_adduser '登录名','用户名','角色' exec sp_adduser '*****','****','****'
（可通过角色、登录用户手工创建）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607a52dfd68526bcbe9e167d524bdb42/" rel="bookmark">
			java 解压缩中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容转载自https://blog.csdn.net/u014298330/article/details/79976983
引入zip4j
import net.lingala.zip4j.core.ZipFile; public static void unZip( String zipPath, String destDir ) throws Exception { ZipFile zipFile = new ZipFile( zipPath ) ; zipFile.setFileNameCharset( getEncoding( zipPath ) ) ; zipFile.extractAll( destDir ) ; } @SuppressWarnings( "unchecked" ) private static String getEncoding( String path ) throws Exception { String encoding = "GBK" ; ZipFile zipFile = new ZipFile( path ) ; zipFile.setFileNameCharset( encoding ) ; List&lt;FileHeader&gt; list = zipFile.getFileHeaders() ; for( int i = 0; i &lt; list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/607a52dfd68526bcbe9e167d524bdb42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acca411a0a91f2e6dd2f561087f4dd50/" rel="bookmark">
			Servlet如何生成单号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发过程中，经常会遇到这样的情况，在需要一个有规律的单号时，而且这个单号在数据库中也是唯一的，如果需要用户手工输入很不方便，也容易产生重复的一系列错误，解决这个问题的最好方法就是让系统自动生成唯一的单号。生成单号可以有多种形式，本实例创建了一个保存预约客户的信息的方法，其中由系统自动生成单号，那么该如何实现自动生成单号而且又不重复呢？
预约单号由字母KH、当前系统日期、4位数字和一些分隔符组成的，格式为：KH-20180216-0001,首先判断每一天预约单号是否存在，如果不存在，则预约单号为 KH + 系统日期 + “0001”；如果存在，则去数据库查询这一天的最大预约单号，此时预约单号为KH+系统日期+4为数字编码+1。
在实现编码+1时，数字前面的0被忽略，实现数字前加0的格式，可以采用字符串的format()方法。
Format()方法用于输出指定格式的字符串，其语法格式如下：String.format(“%04d”,num);
参数说明：num：是数字格式的变量；”%04d”：设定数字的格式的位数是4位，如果不足4位则前面补0。
以下是实现生成预约单号的方法：
首先创建一个Date当前系统时间对象，然后创建时间格式化类对象，调用该对象的方法format(Date date)格式化时间。创建StringBuffer对象来拼接预约单号，然后调用查询数据库方法，查询当天单号的情况，如果当天没有单号，则该单号从1开始，否则+1；
以下是查询数据库的方法，该方法主要查询当天单号的情况：
首先，声明一条SQL语句，通过传过来的时间格式来查询当天的单号情况，然后用预约单号从大到小来排序，获取到当天单号的最大值，截取预约单号的最后4位数，返回该数字：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/befa302493c0b4aa0380fd52b2718c8b/" rel="bookmark">
			SSH的免密登录详细步骤（注释&#43;命令&#43;图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 为了保证一台Linux主机的安全，所以我们每个主机登录的时候一般我们都设置账号密码登录。但是很多时候为了操作方便，我们都通过设置SSH免密码登录。
在这里我对本地机器Cloud10和目标机器Cloud11、Cloud12进行免密登录
大致的三步 1.本地机器生成公私钥
2.上传公钥到目标机器
3.测试免密登录
具体操作 1.准备工作
使用root权限分别修改每台机器的hosts，添加每台机器所对应的IP和主机名（我这里分布式集群是3台机器组成的，所以配置3台，习惯将自己的ip和主机名放在第一行）
sudo vim /etc/hosts
删除文件里内容后添加如下内容
查看本地机器的隐藏文件 .ssh
ll -a
2.在本地机器用ssh-keygen 生成一个公私钥对
在ssh目录下进行，输入三个回车
进入.ssh目录 cd .ssh发起公钥请求 ssh-keygen -t rsa
在.ssh/目录下，会新生成两个文件：id_rsa.pub和 id_rsa 3.上传公钥到目标机器
ssh-copy-id hduser@192.168.157.146
ssh-copy-id hduser@Cloud12
注意：（@前边是接受公钥机器的用户名，后边是接受放的ip，因为配置了映射所以ip可以用主机名代替）
查看远程从节点主机上是否接收到 authorized_keys文件
这个时候Cloud10的公钥文件内容会追加写入到Cloud11的 .ssh/authorized_keys
文件中查看Cloud11下的authorized_keys文件与Cloud10下的id_rsa.pub中内容是一样的,如下图所示
重启 SSH服务命令使其生效:（3台机器都要重启)
sudo service sshd restart
另外我们要注意，
.ssh目录的权限为700，其下文件authorized_keys和私钥的权限为600。否则会因为权限问题导致无法免密码登录。我们可以看到登陆后会有known_hosts文件生成。
chmod -R 700 .ssh/
sudo chmod 600 .ssh/authorized_keys
4.测试免密登录
使用IP免密登录（用户名相同时，ssh+主机名；如果不同，登录方式就是 ssh+用户名@IP地址）
ssh Cloud10
ssh Cloud11
ssh Cloud12
退出免密登录
exit
注意事项 免密码登录的处理是用户对用户的，切换其他用户后，仍然需要输入密码远程机器的.ssh目录需要700权限，authorized_keys文件需要600权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/befa302493c0b4aa0380fd52b2718c8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2e44ac8ff7afc8c3029c94ecff64a7/" rel="bookmark">
			SVN安装语言包后无中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给svn下载了个语言包，但是安装后无反应，重启了下还是无反应。 后来看了一下svn版本，是12的下载的语言包是11的。就重新下一个版本一样的试试。结果ok了
下载安装ok去选择即可，我的安装后自动就选择了。
版本选择地址https://osdn.net/projects/tortoisesvn/storage/ 温馨提示《=V=》谷歌一下进去了火狐好慢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc64f347e485ea45ab95d32da2eabbb9/" rel="bookmark">
			SpringBoot启动源码介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一: SpringApplication构造方法 1.首先SpringBoot项目启动类来看
@SpringBootApplication public class DemoApplication { public static void main(String[] args) { //从SpringApplication.run方法中获取取到ApplicationContext上下文对象, 同时启动SpringBoot项目 ApplicationContext ctx = SpringApplication.run(DemoApplication.class, args); } } 2.看一下SpringApplication构造方法
public SpringApplication(Class... primarySources) { this((ResourceLoader)null, primarySources); } public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { this.sources = new LinkedHashSet(); this.bannerMode = Mode.CONSOLE;//控制banner展示类型 this.logStartupInfo = true; //控制启动日志输出 this.addCommandLineProperties = true; //控制是否添加命令行配置 this.headless = true; //控制项目以headless模式启动(无gui和键盘鼠标) this.registerShutdownHook = true; //控制是否注册虚拟机关闭监听 this.additionalProfiles = new HashSet(); this.resourceLoader = resourceLoader; Assert.notNull(primarySources, "PrimarySources must not be null"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc64f347e485ea45ab95d32da2eabbb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33421669eb4df13351eda14a7ab87326/" rel="bookmark">
			Pandas 基础之 数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Series 一维数据对象 创建 Series 列表形式创建指定索引创建传入一个字典 import pandas as pd print('\n用列表创建') s1 = pd.Series(['a', 'b', 'c', 'd']) print(s1) print('\n用指定索引创建') s2 = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd']) print(s2) print('\n传入一个字典') s3 = pd.Series({'a': 1, 'b': 2, 'c': 3}) print(s3) 获取索引 直接用 index 方法就可以获取其索引
# 获取索引 print(s1.index) # 列表形式插入的数据 print(s2.index) # 指定索引插入的数据 print(s3.index) # 字典形式插入的数据 获取值 直接用 values 方法就可以获取其值
# 获取索引 print(s1.values) # 列表形式插入的数据 print(s2.values) # 指定索引插入的数据 print(s3.values) # 字典形式插入的数据 DataFrame 表格数据结构 series 是一组数据 + 索引。 DataFrame 是一组数据 + 一对索引，该模式与 Excel 的数据储存非常相似，我们主要也用 DataFrame 进行操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33421669eb4df13351eda14a7ab87326/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca59ac0fb29e7da64af3c2116534784/" rel="bookmark">
			ubuntu相关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ubuntu pinyin输入法数字键选择失效
TL;DR: rm ~/.cache/ibus/libpinyin/* https://askubuntu.com/questions/1053182/selecting-a-number-does-not-always-return-a-chinese-character-with-ibus-pinyin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/411f674c007816745b4b2ad72621c633/" rel="bookmark">
			数据流图、数据字典、流程图、系统流程图等的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据流图（数据流程图） Data Flow Diagram：简称DFD它从数据传递和加工角度来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。数据流图不是传统的流程图或框图，数据流也不是控制流。数据流图是从数据的角度来描述一个系统，而框图是从对数据进行加工的工作人员的角度来描述系统。 数据字典 Data Dictionary， 简称DD数据字典是指对数据的数据项、数据结构、数据流、数据存储、处理逻辑等进行定义和描述，其目的是对数据流程图中的各个元素做出详细的说明，使用数据字典为简单的建模项目。简而言之，数据字典是描述数据的信息集合，是对系统中使用的所有数据元素的定义的集合。数据流图上所有的成分的定义和解释的文字集合就是数据字典，而且在数据字典中建立的一组严密一致的定义，很有助于改进分析员和用户的通信。数据库数据字典不仅是每个数据库的中心，而且对每个用户也是非常重要的信息。用户可以用SQL语句访问数据库数据字典。 流程图 以特定的图形符号加上说明，表示算法的图，称为流程图或框图。流程图有时也称作输入-输出图。该图直观地描述一个工作过程的具体步骤。流程图对准确了解事情是如何进行的，以及决定应如何改进过程极有帮助。这一方法可以用于整个企业，以便直观地跟踪和图解企业的运作方式。流程图使用一些标准符号代表某些类型的动作，如决策用菱形框表示，具体活动用方框表示。但比这些符号规定更重要的，是必须清楚地描述工作过程的顺序。流程图也可用于设计改进工作过程，具体做法是先画出事情应该怎么做，再将其与实际情况进行比较。流程图有几个类型分别是文件流程图、数据流程图、系统流程图、程序流程图。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2787808e7a88cbd385180aa8b9275402/" rel="bookmark">
			进程动态拦截注入API HOOK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近工作中遇到一个问题，需要通过程序界面进行判断程序的运行状态，刚开始认为很简单，不就是一个窗体控件获取，获取Button的状态和Text。刚好去年干过该事情，就没太在意，就把优先级排到后面了，随着项目交付时间的临近，就准备开始解决问题，一下懵逼了，这次软件作者也聪明了，居然换了花样。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eD8V3KNi-1614069739264)(]
)
从图中可以发现，此处的按钮上的文字等信息不是通过Button信息进行操作。静想猜测是通过Windows API直接将信息进行写入，那么哪个API可以进行写入呢，想想不难发现，其实就是窗口程序中在窗口中写入文字的方法DrawText，同时隐约记得SetWindowsText也具备该功能。既然有猜想了那就实践看看，验证下猜想。
开干之前，还需要理理思路：
既然程序会调用DrawText方法，那我要获取文本，就必须截获到该方法截获方法不就是使用Windows上大名鼎鼎的**钩子(Hook)**函数。说到钩子函数，这又分钩窗口消息和钩API函数。对于本文来说当然就是后者了。实现API HOOK主要有两个重要环节： 如何把代码注入到目标地址空间如何让自己的代码被调用 稍稍查询下资料，发现钩窗口函数貌似就复杂了，如果要研究细节请参考该文进一步资料查询，我发现以牛逼函数库（居然还是微软自己开发的）：Detours（当然我会提供下载链接）Detours它用于实现拦截Win32二进制代码中的API函数。它使用一个JMP指令替换了目标函数的前面几个字节，使得控制直接调用实现的Detours函数。并通过一个trampoline函数保留了原来函数的功能调用。到目前为止就是对该库的使用了。从文档上来看应该没什么问题了。但是文档上是通过创建进程进行注入DetourCreateProcessWithDll，对目前我的应用场景就不太匹配了。客户程序一直处于运行状态，我需要获取动态注入，那么问题来了，如何解决了？ BOOL WINAPI DetourCreateProcessWithDll(LPCSTR lpApplicationName, LPSTR lpCommandLine, ...); 能提出问题，基本上问题就解决了一般。果不然，通过百度和Google的不懈努力，终于发现原来Detours1.5版本中有个方法DetourContinueProcessWithDll该方法就是进行动态注入的，这下就可以开干了（至于Detours的原理本文就不再赘述，请大家自行查询资料，本文以解决实际问题问题主） BOOL WINAPI DetourContinueProcessWithDll(HANDLE hProcess, LPCSTR lpDllName); 经过上面几个步骤下来，已经有了完整的思路，下文主要结合实践，进行代码实践。本文主要从如下几个方面进行时间：
首先，居然是要截取函数DrawText和SetWindowText那么首先的先实现自己的函数（通过DLL封装）然后，就是动态注入我们的DLL文件指定进程最后，拿出来溜溜（本文为了简便，仅将相关信息打印到DebugView中） 实现HookWindowTextDll 首先，按照Detours的编程规范，需要在加载HookWindowTextDll时通过方法DetourFunctionWithTrampoline进行注册。在卸载的时候通过DetourRemove卸载。
该处主要分以下几步：
需要Hook的方法声明和实现安装和卸载注入方法 Hook方法声明和实现 首先需要声明我们的方法
BOOL WINAPI MySetWindowTextA( HWND hWnd, LPCTSTR lpString ); BOOL WINAPI MySetWindowTextW( HWND hWnd, LPCWSTR lpString ); int WINAPI MyDrawTextA( HDC hDC, LPCTSTR lpString, int nCount, LPRECT lpRect, UINT uFormat ); int WINAPI MyDrawTextW( HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat ); //该方法主要是用Real_SetWindowTextA保存原来函数SetWindowTextA地址，方便后面调用 DETOUR_TRAMPOLINE( BOOL WINAPI Real_SetWindowTextA( HWND a0, LPCTSTR a1 ), SetWindowTextA ); DETOUR_TRAMPOLINE( BOOL WINAPI Real_SetWindowTextW( HWND a0, LPCWSTR a1 ), SetWindowTextW ); DETOUR_TRAMPOLINE( int WINAPI Real_DrawTextA( HDC a0, LPCTSTR a1, int a2, LPRECT a3, UINT a4 ), DrawTextA ); DETOUR_TRAMPOLINE( int WINAPI Real_DrawTextW( HDC a0, LPCWSTR a1, int a2, LPRECT a3, UINT a4 ), DrawTextW ); //代码实现，限于篇幅，仅列出MySetWindowTextA BOOL WINAPI MySetWindowTextA( HWND hWnd, LPCTSTR lpString ) { #ifdef _DEBUG char strMsg[ 1024 ]=｛0｝; wsprintf( strMsg, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2787808e7a88cbd385180aa8b9275402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/675e111bf5e763ed72dda3048e2e8328/" rel="bookmark">
			Python 序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 序列包括：字符串类型，元组类型，列表类型
x in s 如果x是序列s，返回 True ，否则返回False
x not in s 如果x是序列s，返回 False，否则返回True
s + t 链接连个序列s和t
s*n 或 n*s 将序列 复制 n次
s[i] 索引，返回s中的第i个元素，i是序列的序号
s[i:j] 或 s[i:j:k] 切片，返回序列s中第i到j以k为步长的元素序列
len(s) 返回序列s的长度
min(s) 返回序列s中的最小元素 ，s序列中的元素是要可比较的
max(s) 返回序列s中的最大元素，s序列中的元素是要可比较的
s.index(x) 或 s.index(x,i,j) 返回序列s从i开始到j位置中第一次出现元素x的位子
s.count(x) 返回x在序列s中出现的总次数
s = [123,'中国',5,'python','QQ',000,'love',000] n = [1,6,9] print('中国' in s) print(123 not in s) print(s + n) print(2*s) print(s[1]) print(s[0:7:2]) print(len(s)) print(min(n)) print(max(n)) print(s.index(000)) print(s.count(000)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1350032a98f5904c06a971a9037070c/" rel="bookmark">
			mybatis中CDATA的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis中&lt;![CDATA[]]&gt;的作用 在使用mybatis 时我们sql是写在xml 映射文件中，如果写的sql中有一些特殊的字符的话，在解析xml文件的时候会被转义，但我们不希望他被转义，
所以我们要使用&lt;![CDATA[ ]]&gt;来解决。
&lt;![CDATA[ ]]&gt; 是什么，这是XML语法。 在CDATA内部的所有内容都会被解析器忽略。
如果文本包含了很多的"&lt;“字符 &lt;=和”&amp;"字符——就象程序代码一样，那么最好把他们都放到CDATA部件中。
但是有个问题那就是
&lt;if test=""&gt; &lt;/if&gt; &lt;where&gt; &lt;/where&gt; &lt;choose&gt; &lt;/choose&gt; &lt;trim&gt; &lt;/trim&gt; 等这些标签都不会被解析，所以我们只把有特殊字符的语句放在 &lt;![CDATA[ ]]&gt; 尽量缩小 &lt;![CDATA[ ]]&gt; 的范围。
实例如下：
&lt;select id="findWeiboOfHome" resultType="Weibo"&gt; &lt;![CDATA[ SELECT u_id,m_id as id,m_date as pubTime,m_body as body,m_image as image,m_tranum as tranum, m_comnum as comnum,m_colnum as colnum,m_like as likeN ,to_char(m_date,'yyyy-mm-dd hh24:mi:ss') as str_pubTime FROM ( SELECT A.*, ROWNUM RN FROM (SELECT M_ID,U_ID,M_TRANUM,M_COMNUM,M_COLNUM,M_LIKE,M_DATE,M_BODY,M_IMAGE,M_STATE,M_TAG,M_LIKE+M_TRANUM+m_comnum+m_colnum as m FROM weibo_tab where m_state=#{param1} order by m desc)A WHERE ROWNUM &lt;= #{param3} ) WHERE RN &gt;= #{param2} ]]&gt; &lt;/select&gt; 因为这里有 “&gt;” “&lt;=” 特殊字符所以要使用 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1350032a98f5904c06a971a9037070c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a35c0029d49516bacad0aae262067b2/" rel="bookmark">
			springboot整合EasyExcel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot整合EasyExcel
easyexcel是阿里开源的解析excel的工具,可以把它看作对poi的优化版。
Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel重写了poi对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到KB级别，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便。
easyexcel核心功能 功能描述参考：Java解析excel工具easyexcel 助你快速简单避免OOM_成长中的巨人-CSDN博客_excel解析 读任意大小的03、07版Excel不会OOM读Excel自动通过注解，把结果映射为java模型读Excel支持多sheet读Excel时候是否对Excel内容做trim()增加容错写小量数据的03版Excel（不要超过2000行）写任意大07版Excel不会OOM写Excel通过注解将表头自动写入Excel写Excel可以自定义Excel样式 如：字体，加粗，表头颜色，数据内容颜色写Excel到多个不同sheet写Excel时一个sheet可以写多个Table写Excel时候自定义是否需要写表头 1、引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;1.1.2-beta5&lt;/version&gt; &lt;/dependency&gt; 依赖包是目前最新的版本 2、实体类
package com.xxx.xxxutils.utils; import com.alibaba.excel.annotation.ExcelProperty; import com.alibaba.excel.metadata.BaseRowModel; import lombok.*; @EqualsAndHashCode(callSuper = true) @Data @AllArgsConstructor @NoArgsConstructor @Builder public class TableHeaderExcelProperty extends BaseRowModel{ /** * value: 表头名称 * index: 列的号, 0表示第一列 */ @ExcelProperty(value = "姓名", index = 0) private String name; @ExcelProperty(value = "年龄",index = 1) private int age; @ExcelProperty(value = "学校",index = 2) private String school; } 3、excel工具方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a35c0029d49516bacad0aae262067b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d340d20f5571b9fd40af3d3dce49dfff/" rel="bookmark">
			从零开始的MFC实现串口输出（MFC初上手&#43;串口上手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从零开始的MFC实现串口输出 吐槽环境配置学习基本的mfc控件操作，编辑方法声明变量及绑定编码 串口串口调试 串口代码学习 吐槽 本文是一个实际项目的我负责的一小部分，由于投标了甲方没有采取，所以就扔到龙腾杯拿了个一等奖，，当然我们几个学生也就是刚接触，肯定没有别的竞争者做得好，，
环境 使用安装VC++的VS IDE，本人用的VisualStudio2015（需要自定义安装，勾选VC++选项）
本案例使用C++语言
本人有java基础，没有接触过C++
需要面向对象思想以及会基本的使用方法，变量
了解C++ 头文件.h用于声明和定义 .cpp文件用于实现（新建一个看看大概就知道了）
配置 参考Vs2015 com串口编程Mscomm控件导入(基于win7/win10 64位)：
https://blog.csdn.net/youxishaonian/article/details/52590316
备注：命令行中 cd（空格）绝对路径（从资源管理器复制即可）
来定位
若出错考虑在syswow64中注册：
https://blog.csdn.net/llllllllll4er5ty/article/details/76798195
学习基本的mfc控件操作，编辑方法 新建的项目（选择对话框）
工具箱中可拖出控件
工具箱没有：视图-工具箱
没有对话框：资源视图-项目-.rc-Dialog-…_DIALOG
对常用的:button edit control static text 尝试，学习，右下角有具体属性框自己试试，，，
声明变量及绑定 建议把控件先放到位
对每个控件，属性中改变ID（命名）
然后
随便哪里右击-类向导，类名选好当前项目名+Dlg的类，-成员变量
其中像长方体的是已经绑定，黑框+的是未绑定，
选择控件，添加变量
注意
变量类型(对于value一定要注意) 你之后用到的值的类型
类别 控制control型还是值value型
设置变量名（随意）
完成以后对于要写代码的控件双击，自动生成方法框架，如果仅仅是文字输入之类不需要操作的框可以不用
一旦完成添加变量或者双击，值或者方法就被声明了，如果要删除需要在.h和.cpp中手动删除
编码 对于每个需要读取、改变MFC界面上的值的方法，都需要用
UpdateData(TRUE);
代码
UpdateData(FALSE);
意思是更新（读取，输出）各个值
串口 串口的硬件得自己买，，
我们用的是一个像u盘两头usb的东西如下
串口调试 下载串口调试助手和虚拟串口软件
本人用串口调试助手sscom32
可以多开，一个测试发送一个测试接收
以及虚拟串口软件Configure Virtual Serial Port Driver
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d340d20f5571b9fd40af3d3dce49dfff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8f3f6a02d4d62dfef9b06aa76ff6e2e/" rel="bookmark">
			VS2017无法断点调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天换了个固态，然后重装了一下系统，然后呢就把固态分了几个盘，特意搞了个20G的盘放代码，然后今天在调试VS2017的时候就很尴尬了，发现断点调试功能完全不能用，提示如下：
Module containing this breakpoint has not yet loaded or the breakpoint address not be obtained.
百度这句英文完全没有找到相关任何解决方法，搜“VS2017无法断点调试”能到一些但是照着试了完全解决不了，随后在一位大佬的帮助下，被大佬一眼发现了我的VS项目文件夹和源代码不在一个盘。。。。。。就只是因为不在一个盘而已。。。。。。然后我把项目文件夹移到了我的代码所在的盘，断点调试功能立马恢复正常！！！！！！也算是坑了自己一把。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25bc5fa63c9d1472ecb7e23550b1f932/" rel="bookmark">
			Windows下使用curl访问url后面参数接收不到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows系统IDEA使用Terminal的curl时，访问url除第一个参数，后面参数接收不到的问题，需要记录一下。 在访问 http://localhost:8080/test/validate.json?id=123msg=123456 时。开始使用了转义字符将&amp;进行转义，不起效果，任然得不到参数，只能获取id。
使用" "将链接包起来起来可以。
代码：curl -s “http://localhost:8080/test/validate.json?id=123msg=123456”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fff00b3ca08cb27bca48b30bb8bc37a/" rel="bookmark">
			Android studio&#43;opencv-4.1.0 开发环境搭建（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一图像处理APP的时候需要用到opencv，发现从配置个方面都十分蛋疼，好在经过一番折腾，算是大概弄出来了，在这里大概说说，我用的是android studio开发环境，具体安装配置不再多说，直接从opencv开始。
opencv下载
opencv官网
先去官网下载，我在这里选择了目前的最新版4.1版，选择下载android版本的
下载好后，直接解压，不需要安装之类的步骤，进入解压后的文件夹会有四个文件
sdk是一些编译好的文件，包括.so和.a库，samples中是一些后面会用到的项目文件
然后打开android studio，新建项目，项目建好后，点击File，然后选择NEW，再选择Import Moudle…
(这里不知道为什么电脑抽筋了，没办法截图凑合看吧）
然后是如下界面
然后选择目录，选择opencv文件夹下的sdk，然后选择sdk中的java文件夹，确定即可，这里是我的目录，我之前吧opencv解压后的默认文件夹名称改了，所以按照你的电脑上的文件夹名称就可以了
之后他会让你写module名称
起好后next，会看到如下界面，这里默认就好，finish
这一步结束后，模块基本上导入成功了，但是有些文件还是需要该一下
吧你的项目app文件夹下的build.gradle文件直接拷贝到项目根目录下之前导入模板的文件夹中，文件夹名称就是你刚刚起的那个
例如我刚刚Module name起的是opencv，那我就去项目目录下找opencv文件夹，这个文件夹中原本就有一个build.gradle文件，直接覆盖替换掉就好了，当然也可以直接吧app文件夹里build.gradle的内容直接写道module的build.gradle中，吧module中原本build.gradle文件的内容全部清掉，我在这里用了第二种办法，可以直接在android studio里改，如图（绿色是module的build.gradle，红色是app的build.gradle）
其实这里怎么操作无所谓，只要保证两个build.gradle文件中的版本信息一样就行了
然后，把moudle中的build.gradle中的部分内容稍微改一下
先把apply plugin: 'com.android.application’改成apply plugin: ‘com.android.library’（app的build.gradle文件原样不动）
然后，把applicationId "com.example.mplog"这一句去掉
如图，上面是app的build.gradle，下面是module的build.gradle
之后直接在app的build.gradle文件中的dependencies 中加上implementation project(":你的module名称")
把
dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:28.0.0' implementation 'com.android.support.constraint:constraint-layout:1.1.3' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2' implementation 'com.android.support:design:28.0.0' } 改成
dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:28.0.0' implementation 'com.android.support.constraint:constraint-layout:1.1.3' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fff00b3ca08cb27bca48b30bb8bc37a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79a2850fba013d4b9b93dbbe103ac554/" rel="bookmark">
			PHP7和PHP5的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/li_xue_zhao/article/details/79800877
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54912702296d3b9ed47cba16458b4f1c/" rel="bookmark">
			一个超好用的侧拉删除框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢大神，赐给我力量 implementation 'com.github.mcxtzhang:SwipeDelMenuLayout:V1.3.0' 布局文件如下： &lt;com.mcxtzhang.swipemenulib.SwipeMenuLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="wrap_content" android:minHeight="98px" android:clickable="true" app:ios="false" app:leftSwipe="true" app:swipeEnable="true"&gt; &lt;LinearLayout android:layout_width="match_parent" android:orientation="horizontal" android:layout_height="48dp"&gt; &lt;TextView android:layout_width="wrap_content" android:text="正常布局内容" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt; &lt;Button android:id="@+id/btnDelete" android:layout_width="60dp" android:layout_height="match_parent" android:background="#ff4a57" android:text="删除" android:textColor="@android:color/white"/&gt; &lt;/com.mcxtzhang.swipemenulib.SwipeMenuLayout&gt; adapter如下
class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; { ViewHolder holder = null; private onSwipeListener mOnSwipeListener; public void setOnDelListener(onSwipeListener mOnDelListener) { this.mOnSwipeListener = mOnDelListener; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(GoldMajorListActivity2.this).inflate(R.layout.item_gold2, parent, false); holder = new ViewHolder(view); holder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54912702296d3b9ed47cba16458b4f1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887557498ae8bdb97cfdfb01e245fd13/" rel="bookmark">
			js中创建数组，遍历json，向数组中添加元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js中创建数组，遍历集合类型的json（d），向数组中添加元素 创建数组 ：var arr=[];
遍历集合类型的json(d)，向数组中添加元素：
//d为集合类型的json
$.each(d,function(n,value){
arr.push(value.id);
arr.push(value.name);
…
});
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7939b60220ebf4fab4ac5010b134aa8/" rel="bookmark">
			js实现主动使input失去焦点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 解决手机软键盘重复弹出
2 重复弹框。重复调用
var input =document.getElementById("input-id"); input.blur(); Tips：【小程序云开发】中高级前端面试题库（源码：小程序中联系我哟）。
---------- 创作不易，感谢大家，请多多支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f2dab80c4b822c6b8c8789a2a7d927/" rel="bookmark">
			springboot的阿里数据库连接池druid配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引入springboot druid依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.14&lt;/version&gt; &lt;/dependency&gt; 2.application.yml中配置 其实在这里如果无特殊需要，在第1步中的依赖引入成功后，当项目启动连接数据库时就会默认使用druid的连接了。如果需要配置，需在appliaction.yml里进行配置，具体位置是在：
spring: #配置数据源 datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/roleDemo?serverTimezone=GMT username: root password: root druid: 在数据库的基本信息的同级下方输入druid就可以进行配置了，会有提示，按照自己所需进行配置，如果想尝试druid的更多功能,那么使用官网给的文档是最权威的，官方文档传送门：https://github.com/alibaba/druid
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aad8223a837bd81200aadc5388fafbd/" rel="bookmark">
			Beyond compare4 激活和秘钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装完 Beyond Compare 4 以后。打开输入密匙是不是会跳到官网去？
不用慌，我们只需要删除你安装Beyond Compare 4目录下的 BCUnrar.dll 文件，然后再打开就不会跳到官网去。
然后这个时候，我们就需要一个完整的密匙来激活 Beyond Compare 4，下面是一个完整的密匙。亲测可激活
w4G-in5u3SH75RoB3VZIX8htiZgw4ELilwvPcHAIQWfwfXv5n0IHDp5hv
1BM3+H1XygMtiE0-JBgacjE9tz33sIh542EmsGs1yg638UxVfmWqNLqu-
Zw91XxNEiZF7DC7-iV1XbSfsgxI8Tvqr-ZMTxlGCJU+2YLveAc-YXs8ci
RTtssts7leEbJ979H5v+G0sw-FwP9bjvE4GCJ8oj+jtlp7wFmpVdzovEh
v5Vg3dMqhqTiQHKfmHjYbb0o5OUxq0jOWxg5NKim9dhCVF+avO6mDeRNc
OYpl7BatIcd6tsiwdhHKRnyGshyVEjSgRCRY11IgyvdRPnbW8UOVULuTE
注意，这是一个完整的密匙，复制一行无用！！！
永久使用需删除目录下所有：
C:\Users\***\AppData\Roaming\Scooter Software\Beyond Compare 4
*** 是你注册的电脑用户名。比如我的是admin ，那么 *** 就是 admin
AppData 是一个隐藏文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52ff8ec7338fbc9c19ff16f5806ba22f/" rel="bookmark">
			C&#43;&#43;生成均匀分布随机数（附C&#43;&#43;代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成均匀分布随机数的准备 准备随机数生成引擎，这里用到默认引擎——defalut_random_engin my_engine_name创建均匀分布随机数生成器实例——uniform_int_distribution my_object_name(LOW, HIGH)（两边均为闭区间）传入引擎利用生成器生成随机数——object_name(my_engin_name) Show me the code #include &lt;iostream&gt; #include &lt;random&gt; #include &lt;vector&gt; using namespace std; int main() { // 设置随机数引擎 const int SEED = 666; default_random_engine dre(SEED); // 1——10均匀分布的随机数生成器 uniform_int_distribution&lt;int&gt; d(1, 10); // 创建一个vector用来接收 const int LEN = 20; vector&lt;int&gt; v; v.reserve(LEN); for (int i = 0; i &lt; LEN; ++i) { v.push_back(d(dre)); } cout &lt;&lt; "RESULT:" &lt;&lt; endl; for (int i = 0; i &lt; LEN; ++i) { cout &lt;&lt; v[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52ff8ec7338fbc9c19ff16f5806ba22f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/842a19b20a4136877da7f94fcbbc3caa/" rel="bookmark">
			postman上传图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设置headers
Content-Type设置为multipart/form-data; boundary=； 不要设置multipart/form-data
2.设置body
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa20f23c94ac52db7609f5da05f28460/" rel="bookmark">
			springboot&#43;mybatis-plus&#43;mysql&#43;微信小程序实现简单的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序代码:
list.js // pages/list/list.js Page({ /** * 页面的初始数据 */ data: { list:[] }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { }, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () { }, /** * 生命周期函数--监听页面显示 */ onShow: function () { var that=this; wx.request({ url: 'http://localhost:8080/test/list', method:'GET', data:{}, success:function(res){ var list=res.data; if(list==null){ var toastText='获取数据失败'; wx.showToast({ title: toastText, icon:'', duration:2000 //弹出时间 }) }else{ that.setData({ list:list }) } } }) }, /** * 生命周期函数--监听页面隐藏 */ onHide: function () { }, /** * 生命周期函数--监听页面卸载 */ onUnload: function () { }, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { }, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () { }, /** * 用户点击右上角分享 */ onShareAppMessage: function () { }, addArea:function(){ wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa20f23c94ac52db7609f5da05f28460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e44830e0ae2e7bc2dd952345b812e4/" rel="bookmark">
			tensorflow为何采用图（Graph）方式之我的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图可并行处理方便梯度计算 数据流是一种用于并行计算的常用编程模型。在数据流图中，节点表示计算单元，边缘表示计算使用或产生的数据。例如，在 TensorFlow 图中，tf.matmul 操作对应于单个节点，该节点具有两个传入边（要相乘的矩阵）和一个传出边（乘法结果）。
在执行您的程序时，数据流可以为 TensorFlow 提供多项优势：
并行处理。 通过使用明确的边缘来表示操作之间的依赖关系，系统可以轻松识别能够并行执行的操作。
分布式执行。 通过使用明确的边缘来表示操作之间流动的值，TensorFlow 可以将您的程序划分到连接至不同机器的多台设备上（CPU、GPU 和 TPU）。TensorFlow 将在这些设备之间进行必要的通信和协调。
编译。 TensorFlow 的 XLA 编译器可以使用数据流图中的信息生成更快的代码，例如将相邻的操作融合到一起。
可移植性。 数据流图是一种不依赖于语言的模型代码表示法。您可以使用 Python 构建数据流图，将其存储在 SavedModel 中，并使用 C++ 程序进行恢复，从而实现低延迟的推理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b013a987157161a80191f22442f440/" rel="bookmark">
			Pytorch学习笔记（I）——预训练模型（十一）：ResNet152网络结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VGG VGG11VGG13VGG16VGG19 ResNet ResNet18ResNet34ResNet50ResNet101ResNet152 ResNet( (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False) (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace) (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False) (layer1): Sequential( (0): Bottleneck( (conv1): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False) (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73b013a987157161a80191f22442f440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16fd23ffca944112f627a115b0d38500/" rel="bookmark">
			深度学习笔记（一）DNN-在mnist数据集上用tensorflow搭建dnn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文代码运行的环境为:
ubuntu 16.04 64cuda=9.0cudnn=7.0.5tensorflow=1.9.0python=3.6.4(anaconda 3.5.1) 本文包含的知识点有:
DNN基本概念DNN和多层感知机区别神经网络层数到底怎么回事Mnist数据集介绍tensorflow定义网络结构tensorflow定义损失函数tensorflow选择优化算法tensorflow定义测试指标tensorflow模型的保存和加载 1.从感知机到DNN 感知机(Perception)就不细讲了,讲清楚需要大量篇幅.可以参见网上感知机的简单理解或Using neural nets to recognize handwritten digits等.其中的思想并不简单.
多层感知机MLP(Multi Layer Perception)由感知机推广而来,是一种前馈神经网络,有多个神经元层.DNN(Deep Neural Network)是Hinton大神在2006年提出的概念,也是是一种前馈人工神经网络,DNN与MLP的不同在于,DNN在做有监督学习前要先做非监督学习(一般使用RBM或Autoencoder)，然后将非监督学习学到的权值当作有监督学习的初值进行训练.
比如CNN后面的全连接层我们成为MLP比较合适,而一个使用无监督预训练权重的多层前馈神经网络,我们称之为DNN比较合适.
但日常使用中,何必分这么细呢对不对.MLP和DNN所表达的网络结构是相同的,所以MLP就是DNN,DNN就是MLP,DNN名字明显高大上,所以以下统一称为DNN. DNN常见网络结构如下:
这是一个三层的神经网络.这里提一下神经网络的层数,类比下感知机就明白了,感知机有输入层和输出层却叫单层感知机.我们说神经网络层数的时候,这里的"层"是带有运算单元和激活函数的层数,所以不把输入层计算在内.所以双隐层+输入层是一个三层神经网络.
首先看下数据集吧.
2.数据集Mnist Mnist已经用"烂"了,但有些人可能还不是很了解,下面简要介绍下.
Mnist数据可从THE MNIST DATABASE获取.训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据.
它有7万张黑底白字手写的0-9数字图片，其中60000张为训练集,10000张为测试集.本文调用tensorflow中的read_data_sets函数,会把训练集分为55000的训练集，和5000张的验证集.当然也可以自己分.每张图片大小为 28x28 像素，图片中纯黑色的像素值为0，纯白色像素值为1.
3.实战 第一步,配置基本参数
import tensorflow as tf import numpy as np from tensorflow.contrib.layers import fully_connected from tensorflow.examples.tutorials.mnist import input_data # load data and configure parameters mnist = input_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16fd23ffca944112f627a115b0d38500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f68a3932e0fd299c11a179f99c3569a/" rel="bookmark">
			LANMP安全配置之Apache安全配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 前言 主要是参考了《PHP Web安全开发实战》一书，再百度了一些知识点进行补充
抱着了解的心态学习了一下 之后深入学习时再补充笔记吧~~
0x01 屏蔽版本信息 关闭步骤：
（1）打开Apache配置文件httpd.conf
a.找到ServerRoot OS,修改为ServerRoot ProductOnly
b.找到ServerSignature On，修改为ServerSignature Off
（2）重启Apache
0x02 目录权限隔离 Apache安装后会产生ServerRoot、DocumentRoot、ScripAlias、Customlog、Errorlog目录，这些目录分别有对应的功能，所以需要对它们设置单独的权限，具体权限配置如下。
（1）ServerRoot目录只有具有管理权限的用户才能访问
（2）DocumentRoot能够被管理Web站点内容的用户、使用Apache服务器的Apache用户（组）访问
（3）只有Admin组的用户可以访问日志目录
0x03 关闭默认主机 在安装好Apache后一般会有一个默认的主机目录，这个目录可以不通过域名访问IP直接访问到，主机中可能会存在一些服务器敏感信息。
因此换件搭建好了后记得关闭默认主机，只开放自定义的主机以避免留下安全隐患。
默认如下：
改虚拟主机的话就只能访问一个域名
但打开虚拟主机配置文件httpd-vhosts.conf就能配置多个网站域名
并且在主配置文件下打开虚拟主机配置文件，主配置文件就失效了
0x04 低权限运行 Windows系统下，Apache默认由root权限安装、运行。
为避免风险，要让Apache在低权限下运行。
打开httpd.conf，在文件中找到User和Group：
User和Group表示运行httpd服务的用户和组，主要是给网站应用降权的。apache默认是用daemon来运行的，建议降权，所以我得改改了。
改为:
User nobody; Group# -1; 具体的降权操作可参考：
windows服务器下Apache 的降权
0x05 防止用户自定义设置 在httpd.conf进行以下设置，阻止用户建立、修改.htaccess文件，防止用户超越能定义的系统安全性。
也就是这三个参数分别设置成None、None、all
Options是控制特定目录将启用哪些服务器特性AllowOveride参数就是指明Apache服务器是否去找.htacess文件作为配置文件，如果设置为none,那么服务器将忽略.htacess文件，如果设置为All,那么所有在.htaccess文件里有的指令都将被重写。Allow from all 用来控制目录和文件的访问授权。
详见Apache的Order Allow,Deny 配置详解 顺便将Options中参数含义都列出来学习一下
All 准许以下除MultiViews以外所有功能
MultiViews 允许多重内容被浏览，如果你的目录下有一个叫做foo.txt的文件，那么你可以通过/foo来访问到它，这对于一个多语言内容的站点比较有用
Indexes 若该目录下无index文件，则准许显示该目录下的文件以供选择
IncludesNOEXEC 准许SSI，但不可使用#exec和#include功能
Includes 准许SSI
FollowSymLinks 在该目录中，服务器将跟踪符号链接。注意，即使服务器跟踪符号链接，它也不会改变用来匹配不同区域的路径名，如果在;标记内设置，该选项会被忽略
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f68a3932e0fd299c11a179f99c3569a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1c6dddc7e26ea91bc8fe2db1f0134f/" rel="bookmark">
			mysql 指定字段 大小值 排序 例如 id 2，0，1排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据库设计的status状态时0是刚申请1是审核过2是拒绝审核 但是现在要按照 拒绝审核、刚申请、 审核过这种排序方式排序 那就是2，0，1的排序方式排序 order by status desc asc 肯定都不行 通过查询资料找到
select * from order o ORDER BY field(o.status,‘2’,‘0’,‘1’)(o.type,‘1’,‘0’,‘2’)中to.status是要排序的字段
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0705b4dc78f7809f5c266c9009db5620/" rel="bookmark">
			mysql用navicate链接远程数据库很慢 很卡 链接本地数据库正常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、最近在开发项目的时候 navicat 链接远程数据 很慢很卡 而且数据量不是很大 十多万条数据 就很卡 我想不是数据库数据量大的问题 在搜索后，发现了一个配置似乎可以解决这样的问题，就是在mysql的配置文件中增加如下配置参数：
[mysqld]
skip-name-resolve
在linux下配置文件是/etc/my.cnf，
在windows下配置文件是mysql安装目录下的my.ini文件。
注意该配置是加在 [mysqld]下面，在更改配置并保存后 然后就很快了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c299a819c1db5537f825e3d88d94fc/" rel="bookmark">
			R语言正则表达式语法共享（更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 R语言正则表达式语法
在之前文章stringr包里面提到需要用到正则表达式的去处理一些杂乱数据，尤其是在处理从网络爬取的数据，而非自由平台的数据时候，数据是非常脏的。
R语言可运用正则表达式的函数 1、有基础包自带函数grep, grepl, regexpr, gregexpr，regexec，sub，gsub 这些函数的参数都一样
grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, useBytes = FALSE, invert = FALSE) 常用参数说明
pattern：正则表达式或者固定字符串
x：需要处理的数据向量/文本
ignore.case：是否区分大小写
perl：是否用perl兼容的参数
invert：是否返回不匹配的值
2、stringr包中的匹配、提取函数（如：str_replace、str_replace_all、str_detect、str_match、str_extract）同样可以根据正则表达式语法构造所需要的通配符。
正则表达式基本语法： 在R正则表达式里预定义的字符类选集 [:digit:]数字：0-9[:punct:]标点符号[:lower:]小写字母：a-z[:graph:]图形字符：[:alnum:]、[:punct:][:upper:]大写字母：A-Z[:blank:]空格字符：空格和制表[:alpha:]字母字符：a-zA-Z[:space:]空字符：空格、制表、换行和其他空字符[:alnum:]数字和字母字符[:print:]可打印字符：[:alnum:]、[:punct:]、[:space:] R正则表达式里的量化符 ？前面的元素是可选的，并且最多匹配一次*?重复任意次，但尽可能少重复*前面的元素会被匹配0次或者多次+?重复1次或更多次，但尽可能少重复+前面的元素会被匹配1次或者多次??重复0次或1次，但尽可能少重复{n}前面的元素会正好被匹配n次{n,m}?重复n到m次，但尽可能少重复{n，}前面的元素会被匹配n次或者多于n次{n,}?重复n次以上，但尽可能少重复{n，m}前面的元素至少会被匹配n次，但不超过m次　R中部分含有特殊含义的符号 \w单词字符：[[:alnum:]]\W非单词字符：^[[:alnum:]]\s空字符:[[:blank:]]\S非空字符:^[[:blank:]]\d数字：[[:digit:]]\D非数字：^[[:digit:]]\b单词的边界\B非单词的边界\&lt;单词的起始\&gt;单词的结尾.匹配除换行符以外的任意字符$匹配字符串的结束^匹配字符串的开始\转义字符，用于查找元字符本身，如：.，*name|loc匹配 name 或 loc　[nameloct]匹配所包含的任意一个字符　[^nameloct]匹配未包含的任意字符　更新中，请谅解》》》》》》》》》》》》》》》》》》》》》》》》》 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3629b1c46ba79144c0cca246c3d78012/" rel="bookmark">
			SpringBoot项目打jar包供别的项目调用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如有两个项目A和B,假如A项目想打成jar包，然后在B中引入该jar包。
1、SpringBoot的Maven插件打包 如果用Idea创建的SpringBoot会自带maven打包插件。
&lt;build&gt;
&lt;plugins&gt;
&lt;plugin&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;
表1.1、引入SpringBoot会自带maven打包插件
然后点击idea左边的Maven Project-&gt;你的项目名-&gt;Lifecycle-&gt;instal就会把这个项目放入你本地的Maven库，如图1.1。而且还会在你的项目下生成一个jar包，如图1.2。
图1.1、打包过程
图1.2、生成的jar包
SpringBoot会自带打包插件打的包不能用。将SpringBoot会自带打包插件打的包解压后会看到它的目录结构，它把包都达到BOOT-INF这个目录下了，引用的时候我们引用不到，会报“Cannot resolve symbol”的错，如图1.3。
图1.3、报的错
2、原生的Maven插件打包 SpringBoot会自带打包插件打的包不能用，不能用我改为用原生的Maven打包插件打包。
&lt;build&gt;
&lt;plugins&gt;
&lt;plugin&gt;
&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
&lt;configuration&gt;
&lt;source&gt;${java.version}&lt;/source&gt; &lt;!--指明源码用的Jdk版本--&gt;
&lt;target&gt;${java.version}&lt;/target&gt; &lt;!--指明打包后的Jdk版本--&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;
表2.1、引入原生maven打包插件
然后点击idea左边的Maven Project-&gt;你的项目名-&gt;Lifecycle-&gt;instal就会把这个项目放入你本地的Maven库，而且还会在你的项目下生成一个jar包，如图2.1。
图2.1、打包过程
图2.2、生成的jar包
这种方式打完包并安到本地仓库后可以通过两种方式引用该jar包。
1、通过你打包项目的坐标然后在调用的项目中引用能够引用的到。
A项目的坐标
&lt;groupId&gt;com.bonc&lt;/groupId&gt;
&lt;artifactId&gt;mcp-activiti-invoke&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
表2.2、打包项目坐标
B项目中引用
&lt;dependency&gt;
&lt;groupId&gt;com.bonc&lt;/groupId&gt;
&lt;artifactId&gt;mcp-activiti-invoke&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
表2.3、引入打包到本地库中jar的坐标
2、我们直接把jar包放在本地，然后通过maven引入本地jar包能够引用到。但是这种方式有个问题，那就是打包那个项目的依赖不会打入jar包。这种方式如果想用，还得在项目中已入依赖，这种方式是不行的。
引用方法：在项目下创建个文件夹（一般都会命名为lib,这个可以随意定），然后把jar包放在该文件加下，如图2.3。最后在pom文件中已入该jar包，如表2.1。
图2.3、jar放的位置
&lt;dependency&gt;
&lt;groupId&gt;com.bonc&lt;/groupId&gt;
&lt;artifactId&gt;mcp-activiti-invoke&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;scope&gt;system&lt;/scope&gt;
&lt;systemPath&gt;${project.basedir}/src/main/resources/lib/mcp-activiti-invoke-0.0.1-SNAPSHOT.jar&lt;/systemPath&gt;
&lt;/dependency&gt;
表2.4、引入本地jar
这种打包方式用第一种引用可以，用第二种不行。如果B项目想用A项目打的包，我只需要把A的包引入就可以，不需要考虑A的依赖。为了解决这个问题，我又找到了第三种方式。
3、Assembly插件打包 为了解决A项目打的包直接可以放在B项目中用，在B用A项目打的包的时候不需要考虑A项目中的依赖，我找到了这种打包方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3629b1c46ba79144c0cca246c3d78012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13d3c78f518be4529678224763e937d/" rel="bookmark">
			javascript递归理解及实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、递归： 函数中调用函数自己，在使用递归的时候一定需要有结束递归的条件，否则就会变成死循环。
想要用递归必须知道两个条件：
1、递归出口(终止递归的条件)
2、递归表达式(规律)
技巧： 在递归中常常是将问题切割成两个部分(1和整体的思想)，这能够让我们快速找到递归表达式(规律)
二、递归和循环的区别
简单来说，循环是有去无回，而递归则是有去有回(因为存在终止条件)。
举个栗子，你用你手中的钥匙打开一扇门，结果去发现前方还有一扇门，紧接着你又用钥匙打开了这扇门，然后你又看到一扇们…但是当你开到某扇门时，发现前方是一堵墙无路可走了，你选择原路返回——这就是递归 但是如果你打开一扇门后，同样发现前方也有一扇们，紧接着你又打开下一扇门…但是却一直没有碰到尽头——这就是循环。
三、实例
1、递归案例:求一个数字各个位数上的数字的和
function getEverySum(x) { if(x&lt;10){ return x; } //获取的是这个数字的个位数 return x % 10 + getEverySum( parseInt( x/ 10 ) ); } console.log(getEverySum(987654321)); // 45 2、平铺多维数组
let arr = [ [1,2,], 3 ,4, [5, [6, [7 ,8, [9]]]]] let temp = [] function digui(arr) { for (let i = 0; i&lt; arr.length; i++) { // 判断是不是数组，若是数组就在进行递归 if (dataType(arr[i]) === 'array') { digui(arr[i]) } else { // 不是数组直接push 进去 temp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f13d3c78f518be4529678224763e937d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec8d1268bd4bc5209918f6624827dd3/" rel="bookmark">
			Multiple annotations found at this line: Invalid location of tag  (form). No end tag (form）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个BUG是form失效了
原因是form处在
标签之间，只要把form移出table标签范围就好，也可以直接把table标签删了，我是选择直接删了table标签 这样就好了，至于为什么form处于table标签之间会出问题，这我就不清楚了，如果有知道的看到的希望不吝指教( __) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08696c86f9ff2a5716c54264c105deeb/" rel="bookmark">
			推荐算法－NFM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐算法－NFM FM对于特征的组合仅限于二阶，缺少对特征之间深层次关系的抽取。因此，NFM提出来就是在FM的基础上引入神经网络，实现对特征的深层次抽取。NFM的模型结构图如下所示：
模型的结构如上图所示，首先输入就是离散化的特征，然后再进行embedding操作，获得每一个特征的向量表示。接着就到了Bi-interaction Pooling层，这里其实就是FM部分。FM的公式如下图所示：
去掉最外层的累加号，我们得到的是一个长度为K的向量，也就是embedding部分的长度。然后再对这个向量送入几层全连接层即可，最后输出ctr预估值。这就是NFM的整体思路。
代码实现 权重构建，就是初始化一下embedding部分的数据，以及全连接部分的权重。然后就可以实现计算图了。
权重部分如下：
def _initWeights(self): weights = dict() # embedding weights['feature_embedding'] = tf.Variable(tf.random_normal(shape=[self.featureSize, self.embeddingSize], mean=0.0, stddev=0.001), name='feature_embedding') weights['feature_bias'] = tf.Variable(tf.random_normal(shape=[self.featureSize, 1], mean=0.0, stddev=0.001), name='feature_embedding') weights['bias'] = tf.Variable(tf.random_normal(shape=[1]), name='bias') # deep weights['layers_{}'.format(0)] = tf.Variable(tf.random_normal(shape=[self.embeddingSize, self.deepLayers[0]], mean=0, stddev=0.001), name='layers_{}'.format(0)) weights['bias_{}'.format(0)] = tf.Variable(tf.random_normal(shape=[1, self.deepLayers[0]]), name='bias_{}'.format(0)) for i in range(1, len(self.deepLayers)): weights['layers_{}'.format(i)] = tf.Variable(tf.random_normal(shape=[self.deepLayers[i-1], self.deepLayers[i]], mean=0.0, stddev=0.001), name='bias_{}'.format(i)) weights['bias_{}'.format(i)] = tf.Variable(tf.random_normal(shape=[1, self.deepLayers[i]]), name='bias_{}'.format(i)) weights['layers_output'] = tf.Variable(tf.random_normal(shape=[self.deepLayers[-1], 1], mean=0.0, stddev=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08696c86f9ff2a5716c54264c105deeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4638ace46fa23916abe0c35c66f899b9/" rel="bookmark">
			20190507(select()函数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.select()学习 学习select()是因为要用到了，要仿照写一个进程，
学习网站：https://blog.csdn.net/cstarbl/article/details/7645298
select函数用于在非阻塞中，当一个套接字或一组套接字有信号时通知你，系统提供select函数来实现多路复用输入/输出模型。
#include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; int select(int maxfd,fd_set *rdset,fd_set *wrset,fd_set *exset,struct timeval *timeout); 功能：把当前符合要求的fd(可读，可写，有异常)分别放入rdset,wrset,exset中；
参数：maxfd：需要监视的最大的文件描述符值+1；
rdset： 用来检查可读性的一组文件描述字
wrset：用来检查可写性的一组文件描述字
exset：用来检查是否有异常条件出现的文件描述字。(注：错误不包括在异常条件之内)
struct timeval结构用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为0。有三种可能：
1.timeout=NULL（阻塞：select将一直被阻塞，直到某个文件描述符上发生了事件）
2.timeout所指向的结构设为非零时间（等待固定时间：如果在指定的时间段里有事件发生或者时间耗尽，函数均返回）
3.timeout所指向的结构，时间设为0（非阻塞：仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生）
PS： fd_set（数据类型）是一组文件描述字(fd)的集合，它用一位来表示一个fd，
对于fd_set类型通过下面四个宏来操作： FD_ZERO(fd_set *fdset);将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。
FD_SET(int fd,fd_set *fdset);用于在文件描述符集合中增加一个新的文件描述符。 FD_CLR(int fd,fd_set *fdset);用于在文件描述符集合中删除一个文件描述符。 FD_ISSET(int fd,fd_set *fdset);用于测试指定的文件描述符是否在该集合中。 过去，一个fd_set通常只能包含小于32的fd（文件描述字），因为fd_set其实只用了一个32位矢量来表示fd；现在,UNIX系统通常会在头文件&lt;sys/select.h&gt;中定义常量FD_SETSIZE，它是数据类型fd_set的描述字数量，其值通常是1024，这样就能表示小于1024的fd
PS: 注意fd的最大值必须&lt;FD_SETSIZE。
socket s; ..... fd_set set; while(1) { FD_ZERO(&amp;set);//将你的套节字集合清空 FD_SET(s, &amp;set);//加入你感兴趣的套节字到集合,这里是一个读数据的套节字s select(s+1,&amp;set,NULL,NULL,NULL);//检查套节字是否可读, //很多情况下就是是否有数据(注意,只是说很多情况) //这里select是否出错没有写 if(FD_ISSET(s, &amp;set) //检查s是否在这个集合里面, { //select将更新这个集合,把其中不可读的套节字去掉 //只保留符合条件的套节字在这个集合里面 recv(s,...); } //do something here } 理解select模型的关键在于理解fd_set,为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4638ace46fa23916abe0c35c66f899b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db0e5c4554b84731194c8abd6b33e03/" rel="bookmark">
			使用jersey组件向图片资源服务器上传图片报405 Method Not Allowed错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息大致如下:
按照B站教程学习springmvc框架
B站springmvc教程
照着老师思路配置和部署的.
环境:WIN7 IDEA tomcat9.0.6 jdk1.8
1.除了spring全家桶之外相关包引入:
&lt;!--文件上传组件--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传组件结束--&gt; &lt;!--用于跨服传文件(向文件服传输文件)--&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--用于跨服传文件(向文件服传输文件) 结束--&gt; 2.springmvc.xml:
&lt;context:component-scan base-package="com.chenmual.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 激活基于注解的配置 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!--文件解析器对象, 用于解析上传文件upload的,要求id必须为multipartResolver--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!--最大文件大小--&gt; &lt;property name="maxUploadSize" value="10485760" /&gt; &lt;/bean&gt; &lt;!-- 静态资源配置 SpringMVC3.0 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 视图层配置 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"/&gt; &lt;property name="suffix" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1db0e5c4554b84731194c8abd6b33e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0beb8d2fc5ffafab6752e61d21863d54/" rel="bookmark">
			java 中字符串转为可执行的逻辑表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户有有一个需求，规定了几个运算符，如 ！ &amp; | （ ），然后是一些特定条件进行运算，根据他的条件，可以把表达式简化为 一个 只有0和1进行按条件运行的逻辑表达式。如果把0替换为false ，把1替换为true， 把 | 替换为 || ，把&amp; 替换为 &amp;&amp;，！保持不变，就变成这样的表达式( java表示 )：
String str="（true || false） &amp;&amp; ！false || true"
表达式可以无限扩充，这样最终会得到一个boolean值，能满足用户要求。问题是如何把字符串转为可执行的表达式呢。想了许久，可以用栈Stack,但有点复杂。上网上找点资料吧，最终还是找到了，就是用 jxel工具包。验证成功。但“-true”居然可以正常运行，让我大跌眼镜，原来jxel把“-”当作取反来使用了。jxel是apache的工具包，有很多有用的工具类，有兴趣的看下。
public class Test
{
public static void main(String[] args)
{
String str="(true || false) &amp;&amp; !false || true";
JexlBuilder jexlBuilder = new JexlBuilder();
JexlEngine jexl = jexlBuilder.create();
JexlExpression jexlExpression = jexl.createExpression(str);
MapContext jexlContext = new MapContext();
Object result = jexlExpression.evaluate(jexlContext);
System.out.println((boolean) result);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0beb8d2fc5ffafab6752e61d21863d54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd33481206380c86dd63a6a320214cc/" rel="bookmark">
			[蓝桥杯填空]激光样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 x星球的盛大节日为增加气氛，用30台机光器一字排开，向太空中打出光柱。
安装调试的时候才发现，不知什么原因，相邻的两台激光器不能同时打开！
国王很想知道，在目前这种bug存在的情况下，一共能打出多少种激光效果？
显然，如果只有3台机器，一共可以成5种样式，即：
全都关上（sorry, 此时无声胜有声，这也算一种）
开一台，共3种
开两台，只1种
30台就不好算了，国王只好请你帮忙了。
要求提交一个整数，表示30台激光器能形成的样式种数。
注意，只提交一个整数，不要填写任何多余的内容。
答案: 2178309
这个题其实挺好玩的,我是找了一下规律:
如果是1台, 那就是两种情况:开或者不开
如果是2台, 那就是三种情况:不开(1种),开任意一台(两种)
如果是3台,那就是五种情况
如果是4台,那就是八种情况
.........
1.可以看出这就是斐波那契数列,f(x)=f(x-1)+f(x-2)
#include&lt;iostream&gt; using namespace std; long long fun(long long x) { if(x == 1)return 2; if(x == 2)return 3; return fun(x - 1) + fun(x - 2); } int main() { long long res = fun(30); cout&lt;&lt;res&lt;&lt;endl; return 0; } 2.也可以用dfs
#include&lt;iostream&gt; using namespace std; long long ans = 0; int sta[33]; void dfs(int x) { if(x == 31){ ans++; return ; } dfs(x + 1);//这个灯关的 if(sta[x - 1] == 0) { sta[x] = 1; //打开这个灯,向下搜索 dfs(x + 1); sta[x] = 0; } return ; } int main() { dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f432ad62e8a5bbc19a3595a3502bc4/" rel="bookmark">
			sprinboot 基础学习2:  springboot jpa 和 thymeleaf 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、先了解下什么是JPA
JPA(Java Persistence API)是Sun官方提出的Java 持久化规范, 它为 Java 开发人员提供了一种对象/关联映射工具来管理 Java 应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate，TopLink，JDO 等 ORM 框架各自为营的局面。 对持久化规范可以理解为 “持久化” 和 “规范”.
比较专业说法： 持久化（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在的数据库中，或者存储在磁盘文件中、XML数据文件中等等。
持久化是将程序数据在持久状态和瞬时状态间转换的机制 所谓的规范意指明文规定或约定俗成的标准。如：道德规范、技术规范，公司管理规范。 如果没有一个规范来进行约束，那么一些新出现的框架，就会随意的按照自己的标准来，那么我们开发者在开发的是应该遵从那个标准喃？我们就不能很好的去关注自身业务了。其他的相关内容这里就不在赘述了请自行了解。 springboot jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data Jpa 可以极大提高开发效率！Spring Boot Jpa 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现
二、spring boot jpa 基本使用
1、先在pom中引入springboot jap 依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; 2、建立实体类
3、定义 数据访问层接口 UserRepository 然后继承 jpaRepository&lt;User,long&gt; ， 在写添加方法时 修改通过@Query注解加上 ， nativeQuery = true 来 使用原生SQL ,如果不使用 就是HQL。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f432ad62e8a5bbc19a3595a3502bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dbbde4c82fbdc27ea20a6cd3576bd87/" rel="bookmark">
			mongo 默认查询顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果 mongo 查询没有指定 sort 排序，那么 find() 的结果集的默认顺序为插入的顺序
MongoDB 自然排序
natural order
该排序下数据库参照文档在磁盘上的存储顺序。这是默认的排序顺序。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/267/">«</a>
	<span class="pagination__item pagination__item--current">268/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/269/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>