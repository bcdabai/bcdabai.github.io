<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/880c57a13ae10a4b8d880819391cf38e/" rel="bookmark">
			IC验证-SDHOST项目1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现在越来越多的人转行做IC验证，以至于校招中仅有一个项目明显处于劣势，一般来说比较好入手的项目有SRAMC、SPI、MCDF、SDHOST等。
要了解SDHOST项目首先要了解它的结构以及功能和特性
1. 控制器AHB总线接口数据处理符合AMBA2.0协议
2.具备多个控制配置寄存器，可以实现对命令和数据的控制。
3.build in DMA ，支持AHB总线 single/INCR传输
4.支持对卡的单块、多块读写和读写加速
5.与系统内SDIO模块共享FIFO和DMS模块
6.内含相应的寄存器和分频电路，实现SD总线的时钟控制
7.允许读操作时，硬件停时钟功能
主要模块有
sd_if ：它是ahb slave接口模块 内涵控制寄存器 供 CPU访问 决定HOST的工作模式
sd clk：hclk分频电路 作为HOST模块时钟输入（在这里写下分频代码，后续验证其分频功能）
sd_cmd_fsm模块：命令操作控制模块，控制sd_cmd_send_shift_register（命令发送端口）和sd_cmd_receive_shift_register（命令接收端口）
sd_data_fsm模块：数据操作控制模块，控制sd_data_send_shift_register（数据发送端口）和sd_data_receive_shift_register（数据接收端口）
fifo模块：数据缓存模块
DMA模块：数据搬运模块 DMA的全称Direct Memory Access 要记住
上述模块中，数据的读写 命令的读写以及FIFO和DMA的数据搬运功能，都是验证的重点以及面试的重点，也是我们书写testcase时，要重点考察的地方。
SDHOST其实也是IP级别的验证，模块嵌有基于AHB总线的SLAVE和MASTER端口，所以集成时，本模块可作为IP直接挂在AHB总线上，实现其它master（如CPU）访问本端slave，本端master访问其它slave（如sram）
第一幅图要会画，面试中更容易问，后续将针对SD host中的testcase展开介绍。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92cbafc1ae3a71621bd921e71cbc5f2b/" rel="bookmark">
			数据压缩—BMP2YUV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.BMP文件格式介绍二.实验流程三. 实验原理及代码四. 实验结果： 一.BMP文件格式介绍 位图文件格式（BMP）是Windows采用的图像文件存储格式，在Windows环境下运行的所有图像处理软件都支持这种格式。
BMP文本大体上分为四个部分：
部分说明位图文件头BITMAPFILEHEADER包含BMP图像文件的类型，显示内容等信息位图信息头BITMAPINFOHEADER包含有BMP图像的宽，高压缩方法，以及定义颜色等信息调色板 Palette可选，真彩（24BMP）不需要调色板实际的位图数据 ImageData根据位图使用的位数不同而不同，在24位图中直接使用RGB，而其他的小于24位的使用颜色板中索引值 1.位图文件头
typedef struct tagBITMAPFILEHEADER { WORD bfType;//说明文件的类型 DWORD bfSize;//说明文件的大小，以字节为单位 WORD bfReserved1;//保留，设置为0 WORD bfReserved2;//保留，设置为0 DWORD bfOffBits;//说明从BITMAPFILEHEADER结构开始到实际的图像数据之间的字节偏移量 }BITMAPFILEHEADER; 2.位图信息头
typedef struct tagBITMAPINFOHEADER { DWORD biSize;//说明结构体所需字节数 LONG biWidth;//以像素为单位说明图像的宽度,对于32为的机子来说，LONG也是4字节，只是有一位被用来做符号位 LONG biHeight;//以像素为单位说明图像的高度 WORD biPlanes;//说明位面数，必须为1 WORD biBitCount;//说明位数每像素，1，2，4，8，24 DWORD biCompression;//说明图像是否压缩及压缩类型 DWORD biSizeImage;//以字节为单位说明图像大小，必须是4的整数倍 LONG biXPelsPerMeter;//目标设备的水平分辨率，像素每米 LONG biYPelsPerMeter;//目标设备的垂直分辨率，像素每米 DWORD biClrUsed;//说明图像实际用到的颜色数，如果为0，则颜色数为2的biBitCount次方 DWORD biClrImportant;//说明对图像显示有重要影响的颜色索引的数目，如果是0，表示都重要 }BITMAPINFOHEADER; 3.调色板
typedef struct tagRGBQUAD { BYTE rgbBlue;//指定蓝色分量 BYTE rgbGreen;//指定绿色分量 BYTE rgbRed;//指定红色分量 BYTE rgbReserved;//保留，指定为0 }RGBQUAD; 使用FlexHEX打开实验所需BMP文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92cbafc1ae3a71621bd921e71cbc5f2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c665c43f3471e97369a0cd5cbe0dda50/" rel="bookmark">
			larave8中添加sql运行日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在app/Providers/EventServiceProvider.php的boot方法中加入监听：
public function boot() { try{ if (env('APP_DEBUG_SQL') == true) { DB::listen(function ($query) { $tmp = str_replace('?', '"'.'%s'.'"', $query-&gt;sql); $arrBindings = []; foreach ($query-&gt;bindings as $key =&gt; $value) { if (is_numeric($key)) { $arrBindings[] = $value; } else { $tmp = str_replace(':'.$key, '"'.$value.'"', $tmp); } } if($arrBindings){ $tmp = vsprintf($tmp, $arrBindings); $tmp = str_replace("\\", "", $tmp); } $logFile = fopen( storage_path('logs' . DIRECTORY_SEPARATOR . date('Y-m-d') . '_query.log'), 'a+' ); $strShowLog='--------------------------------------------------------------------start'. PHP_EOL; $strShowLog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c665c43f3471e97369a0cd5cbe0dda50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e725b8c9c6c91394a57767a7fe3afceb/" rel="bookmark">
			记录一次spark2.x数据倾斜(隐藏的笛卡尔积)排查处理过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、问题描述
二、尝试调整参数
三、查看spark具体sql流程图
一、问题描述 有一个dwd层中间表的入表任务，有几天的日期永远无法执行成功，平时的任务时间大概在2分钟。之前也遇到过一次这样的情况，是通过排查脏数据得到了解决（长字符串id中有不规则脏字符），这次实在没有头绪。
二、尝试调整参数 因为查看yarn任务的页面，发现总是报错在拒绝连接，看到有个别任务总是执行半天卡住，并且shuffle的records数量也明显高于其他exceutor，并且不仅spill到内存，甚至到了磁盘，说明还是数据倾斜。于是上网查找优化资料，陆续调整了几个参数：
--conf spark.shuffle.sort.bypassMergeThreshold=5000 （该参数应该是设置不合理，作用也不明显，后剔除）
--conf spark.reducer.maxSizeInFlight=256M
--conf spark.shuffle.file.buffer=96K
当加上第3个参数之后，任务不会那么快跑崩了，但最后还是存在问题。
也考虑在join的key上增加随机数前缀（2表关联，a表增加0-n随机数前缀，b表扩充随机数范围的n倍（0到n每个都作为前缀放到b表前，这样保证能和a表关联上）），但是任务sql较大，关联表过多，所以即便加随机数也要知道加在哪一步。于是决定查看spark的执行计划的sql流程图。
三、查看spark具体sql流程图 整个图很长，但是只要没有spill信息的都不太重要，最后发现了红框的地方，找到上游表。但是看到这个表的时候，我十分困惑，因为这个表是目的表的前7天数据，里面包含新用户和回流用户。按理说新用户和回流用户即便是多天融合，也不应该存在重复，但是口说无凭，查询这些天的新用户表，进行查看：
果然！新用户表存在id重复现象。那么一个是反馈给上游做表的同学（次要），一个是采取去重处理（主要，因为重复不多，而且之前验证过一天的新用户是没有重复的，所以考虑仍为uuid哈希碰撞这样的原因） 。
最终只要在有重复的表加一句group by 去重即可。
最后一天只要3分钟就成功跑完，问题解决。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e44657a2105ddb055ea3c776ff1d27e4/" rel="bookmark">
			java如何获取线程的返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java实现多线程有三种方式，分别是继承Thread类和实现Runnable,Callable接口，然而这三种方式的run()方法都是无返回值的，那么该如何实现获取线程的返回值呢？
1）主线程等待法
这是最简单的方法，通过判断返回值不为空从而得到返回值，缺点就是不能精准判断子线程是否执行完成，直接看代码：
public class TestThread extends Thread { public String value = null; @Override public void run() { System.out.println("TestThread start...."); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("TestThread end"); value = "TestThread"; } } public class Test { public static void main(String[] args) throws InterruptedException { TestThread thread = new TestThread(); thread.start(); while (thread.value == null){ Thread.sleep(100); } System.out.println(thread.value); } } 2）使用Thread类的join()阻塞当前线程以等待子线程执行完成
public class Test { public static void main(String[] args) throws InterruptedException { TestThread thread = new TestThread(); thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e44657a2105ddb055ea3c776ff1d27e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb39b109766f31bfdf6e8e83934ce8db/" rel="bookmark">
			vuepress（一）：搭建个人博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 记录一下使用vuepress搭建个人博客的流程。最好先简单看一下官方文档。
官方文档：
VuePress 中文网
创建项目 初始化
npm init 安装
yarn add -D vuepress 或 npm install -D vuepress 目录结构 官方推荐的目录结构：
. ├── docs │ ├── .vuepress (可选的) │ │ ├── components (可选的) │ │ ├── theme (可选的) │ │ │ └── Layout.vue │ │ ├── public (可选的) │ │ ├── styles (可选的) │ │ │ ├── index.styl │ │ │ └── palette.styl │ │ ├── templates (可选的, 谨慎配置) │ │ │ ├── dev.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb39b109766f31bfdf6e8e83934ce8db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321f75921a7b76bb6a3ee69d838a4e28/" rel="bookmark">
			TI 高精度实验室 ADC第二节Delta-Sigma and SAR(下)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		固有噪声是自然产生的，是由电路元件本身产生。外部噪声是从其他电路甚至电路外部接收到的噪声。
电网50/60Hz的噪声
奈奎斯特 带外混叠噪声
RF无线电噪声
供电电源和地 的噪声
50和60Hz的噪音是一个问题。delta-sigma转换器有一个特殊的低延迟滤波器，专门设计来抑制50和60Hz信号。这种类型的滤波器与Sinc滤波器有类似的响应，在50和60hz有一个额外的陷波。
混叠是一种效应，经过采样的高频信号会以低频信号的形式出现，称为“混叠”。这种混叠与其他的低频信号难以区分，我们通常希望避免它们。为了防止混叠，我们必须考虑Nyquist准则，该准则规定输入信号频率必须保持在采样频率的一半以下。任何频率大于采样频率一半的输入信号都会产生混叠。
噪声频率大于采样频率的两倍的时候，会产生频率混叠。
有效的做法是在ADC 信号输入端加入低通滤波。
前端滤波电路的参数选择
在这个例子中，抗混叠滤波器是一个有源二阶低通滤波器，截止频率为10 kHz。这个滤波器在奈奎斯特频率处衰减为60dB，因此它可以作为一个有效的抗混叠滤波器。
有一些ADC内部在前端具有低通滤波器，作用是滤除低频信号。
热噪声，时钟源的抖动噪声、电压参考噪声和量化噪声
时钟抖动是时钟源定时边缘的随机变化，这种变化具有高斯分布。和时钟源的质量有关。
看起来像白噪声叠加在输入信号上
对于较低的输入信号频率，抖动可能不是一个重要的问题。另一方面，对于高频器件，抖动可能是限制性能的基本因素
ADS1252 delta-sigma转换器的噪声规格
SAR采样率可以从0调整到1000kSPS，但无论采样率如何，它的相关噪声都是一个恒定的23uVrms。这是因为SAR没有集成的数字滤波器，输入上的任何噪声都会混叠回到奈奎斯特波段，无论采样率如何
一般来说，ADC噪声将是热和量化噪声的组合。直流输入直方图是一个很好的展示方法。
对于低分辨率器件，LSB尺寸相对于任何热噪声来说都比较大，因此低分辨率器件往往被量化噪声所主导。左边的例子是一个12位的SAR转换器，但是分辨率小于16位的delta-sigma转换器也会被量化噪声所主导。
对于中等分辨率的器件，噪声将是热和量化噪声的混合物。SAR转换器通常就属于这一类。
高分辨率器件往往被热噪声所主导。这对于宽带设备来说尤其如此，因为噪声不受滤波器的限制。这个例子展示了一个宽带宽的delta-sigma转换器，你可以看到噪声清晰地跟随a
高斯分布，因此器件主要受热噪声影响。请注意，在非常低的采样率下运行的直流优化δ -sigma可能有非常低的热噪声，因此直方图将显示热噪声和量化噪声的组合，类似于中间的图。
放大器通常用于宽带SAR和delta-sigma应用，放大器也可以用于输入信号链需要衰减或放大传感器输出以匹配ADC输入范围的情况。最后，放大器可以帮助增加输入阻抗以匹配
考虑的情况是将可编程增益放大器或PGA集成到ADC中。在这种情况下，不需要外部放大器。集成PGA在delta-sigma转换器中非常常见，但也可以在一些SAR转换器中找到。通常，这种内部特性用于低带宽应用，而宽带宽应用使用离散的外部放大器。
最后一种情况是，数据转换器没有集成的PGA，但传感器直接连接到开关电容输入。SAR和delta-sigma转换器都可以使用这种方法。这通常用于低频应用。在这种情况下，内部开关电容电路将需要通过传感器的源阻抗充电并稳定下来。
ADC 转换器的选择
决策树从传感器特定的输入开始。有许多delta-sigma转换器专门设计来测量某种类型的传感器。例子包括rtd、热电偶和磅秤。这些传感器特定产品通常具有广泛的集成功能，便于对特定传感器的测量。例如，RTD解决方案将包括精确的激励电流源。热电偶经常有开放传感器检测，和局部温度传感器冷结补偿。通常，这些类型的转换器是优化的
SAR可用于测量传感器输出时，较低的分辨率系统是足够的和高速采样率。
多个热电偶通过多路复用器连接到离散PGA和SAR转换器。请记住，多路复用器和PGA是一个离散的前端，delta-sigma选项集成了这些组件。如前所述，delta-sigma更常用于低频类型的传感器
在之前的决定中，我们看到一些delta-sigma转换器包括传感器信号调理的集成功能。
然而，这并不是传感器特定产品所独有的。许多在本质上是通用的有用功能可以被集成。例如，一些设备包括滤波器，电压参考，阈值检测器，可编程增益放大器，振荡器，RMS和CRC计算以及。传统上，delta-sigma转换器倾向于包含更多的集成功能，但最近这在SAR转换器中也变得普遍。
下一步要考虑的是应用程序是否需要DC精度但分辨率较低。对于小于或等于16位的转换器来说，SAR或delta-sigma更适合测量低频信号?在这种情况下，两种类型的转换器都有很好的选择。我们关注的是delta-sigma选项。这种delta-sigma会使用一个低延迟的数字滤波器来减少噪声。它们还经常包括集成多路复用器和PGA。通常，这种转换器被称为通用的delta-sigma ADC
SAR转换器的一个优点是，它可以用来快速抓拍直流输入信号，然后它进入一个低功耗的状态。此外，可能有一个应用程序中，系统中的大多数信号是直流的，但有些信号需要更快的采样率。在这种情况下，SAR可能是最好的选择。
当监测具有高分辨率要求的直流信号时，delta-sigma转换器通常是最好的解决方案。
记住，delta-sigma使用噪声整形和内部数字滤波器来获得非常低的噪声。也有人会对a积分
50/60Hz带阻滤波器。最后，许多delta-sigma转换器集成了高阻抗PGA，因此不需要外部放大器。
里我们展示了一个更高分辨率的SAR转换器被用于监测直流信号。通常情况下，delta-sigma会用于这种应用，但如果一个信号的频率较高，或者如果系统用于拍摄快照，并在样本之间保持休眠状态，则SAR可能有用。SAR转换器确实有高分辨率的选项，但通常高分辨率SAR不用于监测直流信号。
最终低噪声的直流精密测量，delta-sigma转换器是最好的选择。这些设备可以有高达32位的分辨率和超低噪音。例如，ADS1263的总综合噪声只有7nVrms。
一些测量应用程序需要在特定时间对瞬态信号进行快照，以便捕获一些关键事件。
当需要测量更高频率的交流信号时，可以使用宽带宽的delta-sigma转换器或SAR转换器。对于delta-sigma选项，这些器件将包含一个宽带宽、具有更高延迟的平坦通带滤波器。
请记住，延迟本质上是输入信号和数字化输出信号之间的延迟。delta-sigma选项只能在低延迟不重要的情况下使用。例如，短延迟可能不会影响音频、地震或医疗成像应用程序。
在需要宽带宽和低延迟的应用中，SAR转换器是最好的选择。一些需要低延迟的例子包括控制系统、安全继电器和位置传感器。基本上，任何需要数字化输入信号立即响应的应用都应该使用SAR。
最后介绍和比较了SAR和delta-sigma转换器。这张幻灯片回顾了我们考虑的三个关键选项。SAR转换器主要用于捕获瞬态快照，以及低延迟是重要的交流应用。对于小型通用转换器来说，它也是一个不错的选择。
直流优化的delta-sigma转换器可以有非常高的分辨率和低噪声。通常这种转换器可以用于低频传感器，如rtd。宽带宽delta-sigma转换器可以用于SAR转换的许多应用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2146701100bc3515e88fccf3c40942b7/" rel="bookmark">
			Gitee基础操作流程 - 创建仓库及push，pull等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Gitee操作 前提知识各部分介绍提交操作拉取操作一般开发流程 gitee操作流程创建远程仓库新建分支将远程仓库克隆到本地切换分支vim编辑更新的内容工作区-&gt;暂存区-&gt;本地仓库本地仓库-&gt;远程仓库（push）查看提交情况远程仓库-&gt;本地（pull）成员管理 前提知识 各部分介绍 提交操作 拉取操作 一般开发流程 gitee操作流程 创建远程仓库 新建远程仓库
填写仓库名称和路径(自动补充 可修改)
初始化仓库
新建分支 新建两个分支(注意：可以自己选择在哪个起点中新建分支)
将远程仓库克隆到本地 复制仓库位置(HTTPS)
打开git bash
将远程仓库克隆到本地
第一次克隆时，需要输入用户名和密码
查看当前目录中 已经存在了仓库内容
切换分支 切换到刚克隆下来的那个文件夹中
切换到自己负责的分支中
vim编辑更新的内容 工作区-&gt;暂存区-&gt;本地仓库 本地仓库-&gt;远程仓库（push） 查看提交情况 在远程仓库中查看自己分支的提交内容
在统计中可以看到自己以及团队成员的提交说明信息
远程仓库-&gt;本地（pull） 成员管理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/defb9047a1b2722c5b300e2c776e6fb6/" rel="bookmark">
			leetcode刷题(第621题)——任务调度器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目
给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间 内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。 然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的 最短时间 。 二、示例
输入：tasks = ["A","A","A","B","B","B"], n = 2 输出：8 解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B 在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而 执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 输入：tasks = ["A","A","A","B","B","B"], n = 0 输出：6 解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0 ["A","A","A","B","B","B"] ["A","B","A","B","A","B"] ["B","B","B","A","A","A"] ... 诸如此类 输入：tasks = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/defb9047a1b2722c5b300e2c776e6fb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/770c48054f925e10557cb5c4cd2515e1/" rel="bookmark">
			ubuntu使用sed替换/查找文件中的内容，使用grep查找包含指定内容的多个文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sed -i "s/查找字段/替换字段/g" grep 查找字段 -rl 路径 文件名
-i 表示inplace edit，就地修改文件-r 表示搜索子目录-l 表示输出匹配的文件名s表示替换，d表示删除不需要排除去掉exclude就行或者要排除多个目录呢 --exclude-dir={.git,res,bin}或者排除一些指定后缀名的文件 比如排除扩展名为 java 和 js 的文件
--exclude=*.{java,js} demo
把当前目录下lishan.txt里的shan都替换为hua
sed -i "s/shan/hua/g" lishan.txt 递归替换
把28080替换为18080 在/data/conf/pb-test下查找
sed -i "s/28080/18080/g" `grep "28080" -rl /data/conf/pb-test` demo2 ## 文件内容含有"tct"的字符全部替换为"wt",且排除搜索.git目录 sed -i "s/tct/wt/g" `grep "tct" -rl ./ -R --exclude-dir=.git` xxx.txt demo3,修改etc/apt/sources.list源
sudo sed -i "s/mirrors.tuna.tsinghua.edu.cn/mirrors.aliyun.com/g" `grep "mirrors.tuna.tsinghua.edu.cn" -rl ./sources.list` demo4
修改默认的ubuntu源替换成ali云源
sed -i "s/cn.archive.ubuntu.com/mirrors.aliyun.com/g" `grep "cn.archive.ubuntu.com" -rl /etc/apt/sources.list` 使用sed查找catalina.out日志文件 按照时间查找文件，并导出到临时文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/770c48054f925e10557cb5c4cd2515e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe50eebadd217b503223bc482143589/" rel="bookmark">
			go container/heap源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//heap的接口类：使用时候需要实现它的方法 type Interface interface { sort.Interface Push(x any) // add x as element Len() Pop() any // remove and return element Len() - 1. } //shifDown() //堆化(heapify):如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动 func down(h Interface, i0, n int) bool { i := i0 for { j1 := 2*i + 1 //获取i这个下标所在节点的left child if j1 &gt;= n || j1 &lt; 0 { //验证是否超过堆数组范围 break } j := j1 if j2 := j1 + 1; j2 &lt; n &amp;&amp; h.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe50eebadd217b503223bc482143589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7dfffd5a1a52e341195445a4fd93486/" rel="bookmark">
			Kafka日志收集简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka日志收集实现
使用github.com/Shopify/sarama连接kafka，并往其中写数据使用github.com/hpcloud/tail读取日志文件使用zookeeper做集群管理使用ini做配置文件解析 关于Kafka原理及工作流程见https://blog.csdn.net/wzb_wzt/article/details/107367245
初始化kafka连接、以及往kafka发送数据的方法
package kafka import ( "fmt" "github.com/Shopify/sarama" ) //专门往kafka写日志的模块 //sarama v1.20之后的版本加入了zstd压缩算法，需要用到cgo，在Windows平台编译时会报错 var ( client sarama.SyncProducer ) // Init 初始化生产者 func Init(addrs []string)(err error){ config:=sarama.NewConfig() config.Producer.RequiredAcks=sarama.WaitForAll //ACK反馈机制，all(需要leader 和follow都确认了) config.Producer.Partitioner=sarama.NewRandomPartitioner//指定写往哪个分区 新选出一个partition config.Producer.Return.Successes=true//成功交付的信息将在success channel返回 //连接kafka client, err = sarama.NewSyncProducer(addrs, config) if err != nil { fmt.Printf("producer close the err is %v",err) return } //defer client.Close() //不需要关闭 日志每时都在产生，所以不需要关闭 return } func SendToKafka(topic,data string)(err error){ //构造一个消息 msg:=&amp;sarama.ProducerMessage{} msg.Topic=topic msg.Value=sarama.StringEncoder(data) //发送消息 message, offset, err := client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7dfffd5a1a52e341195445a4fd93486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72cdd0dea46c18dc9f4f9fd1512d79d3/" rel="bookmark">
			数据库学习记录——错题总结（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一套 1.在一个关系中如果有这样一个属性存在，它的值能惟一地标识关系中的每一个元组，称这个属性为（）
正确答案: A 你的答案: C (错误)
关键字
数据项
主属性
主属性值
学号能够唯一标识一个学生，班级+座位号也能唯一标识一个学生，所以学号和（班级，座位号）都是关键字或者候选码。 主属性：包含在任一候选码中的属性，叫做主属性。所以学号，班级，座位号三个都是主属性，但是单独的班级或者座位号是不能唯一标识一个学生的，也就是说主属性不一定能唯一标识
2.假设牛客网上有一份绝密文件存于某台机器的secretData数据库中的某个表里面，现在出于数据安全的考虑，对于新创建的用户都只能拥有该机器的登录权限，而不能拥有数据库的其他权限，那么新创建nkw用户满足这一要求的语句是（）
正确答案: D 你的答案: A (错误)
grant usage on *.* with 'nkw'@'%'; grant usage on secretData.* to 'nkw'@'%'; grant usage on secretData.* with 'nkw'@'%'; grant usage on *.* to 'nkw'@'%'; B答案：grant usage on secretData.* to ‘nkw’@’%’;授权的用户对secretData下的所有表有登录权限；
D答案：grant usage on . to ‘nkw’@’%’;授权的用户对该机器下的下的所有数据库下的所有表有登录权限； with表示该用户有对往其他用户向下授权的权限（这里向下授予的权限仅是用户自己有的权限）；
题目说的是新建用户对机器只有登录权限，机器可能有多个数据库D符合，B授予的权限小了；
第二套 1.数据库应用系统包括（ ） 。
正确答案: B 你的答案: C (错误)
数据库语言、数据库
数据库、数据库应用程序
数据管理系统、数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72cdd0dea46c18dc9f4f9fd1512d79d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c375261891d691528ab86519461a83/" rel="bookmark">
			RPGMakerMV学习笔记（二）—— 制作第一个RPG游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、创建项目、载入地图
二、设置玩家初始位置 设置设置房间名称、场景背景音乐、禁止跑步 （这里要注意一下音量设置，一定要调低不然会轰炸你的耳朵，因为软件默认音量是100%）
调节开始菜单北京音乐音量 修改游戏名称
清空其他角色 关闭进入游戏时的开场动画（为了加快测试）
三、场景切换
新建一个地图（因为是同一类场景所以不需要切换场景音乐）
双击2F的楼梯会出现一个事件编辑器，然后双击黑色方格所在行，然后选择面板2，选择场所移动，指定移动位置和方向（方向是由画面楼梯的朝向决定的）
在下楼梯时需要按下空格，同理从1F上楼到2F
为下楼梯添加音效
出门
新建事件
指定场景移动位置
添加音效
设置移动路线
完事动画，即开门后主角自动上前一步然后跳转场景 抓迷藏小游戏
新建一个小男孩角色
创建对话选项，如果主角接受则开启A开关（即执行事件2）
然后小男孩开始导数3个数（注意是并行执行，这样在倒数时主角才能移动） 倒数完成则开启B开关（执行事件3）
此时设置任务接近，当人物接近后则促发对话，然后开启C开关（执行事件4）
小男孩开始自由移动 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2199058e968768ab223efff0bd4aeff9/" rel="bookmark">
			关于 安装完MathType 后 Microsoft Word出现 53号错误 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装完MathType之后使用Word时出现如下错误：
解决方法：
第一步：查看是否被添加进加载项中
打开word---》文件---》选项---》加载项（找到你加载的路径）
第二步：打开上一步找到的目录StartUp文件夹，里面的文件就是word启动时会寻找的加载项，如果这些文件出了问题就会弹各种错误。可能你的目录里有MathType Commands 6 for word 2013.dotm这个文件，也可能啥也没有。
这个MathType Commands 6 for word 2013.dotm还有MathType.wll就是MathType的加载项，如果它不见了或者损坏了，MathType就没法嵌在word中使用了。
第三步：修复方法：先找到mathtype安装路径：打开mathpage文件夹，复制（MathPage.will）这个文 件；然后，将复制的（MathPage.WLL）粘贴到Office16文件夹里， 而不是Office16/STARTUP文件夹内
第三部尤为重要，我发现很多方法是安装到STARTUP文件夹内，这让我在失败中踽踽前行，最后发现原来如此简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9c8d44d5bc822de0904379691fa0f7/" rel="bookmark">
			HTML5 表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、表单标签 定义：收集客户端的数据发送给服务器的标签
结构：&lt;form 属性 = “值”&gt; 数据 &lt;/form&gt;
属性：action 服务器地址（目标地址） action=“路径”
method 提交方式：以某种形式从客户端将数据提交给服务器
取值：get 明文提交
特点：1.传输文件大小不超过2kb
2.传输不安全，会将传输的信息展示在地址栏中
3.传输速度很快
post：匿名提交
特点：1.传输文件不受限制
2.传输安全，不会将信息展示在地址栏中
3.传输速度相对较慢
二、表单中标签 注意：form表单本身并没有任何页面效果，真正能够跟用户交互的是嵌入其中子标签
1.普通文本框&lt;input type = "text"&gt; 姓名 账号 文字信息
2.密码文本框&lt;input type = "password"&gt; 密码
3.特殊字符
&amp;nbsp； 空格 产生2-4px
&amp;yen；人民币符号
&amp;copy；版权
4.按钮
普通按钮&lt;input type = "button" value = "名称值"&gt;
提交按钮&lt;input type = "submit" value = "名称值"&gt;
复位按钮&lt;input type = "reset" value = "名称值"&gt;
图片按钮&lt;input type = "image" value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9c8d44d5bc822de0904379691fa0f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d746040853dc3ba9ebbd04663b9de28f/" rel="bookmark">
			3-2 高速公路超速处罚 (15 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按照规定，在高速公路上行使的机动车，达到或超出本车道限速的10%则处200元罚款；若达到或超出50%，就要吊销驾驶证。请编写程序根据车速和限速自动判别对该机动车的处理。
输入格式： 输入在一行中给出2个正整数，分别对应车速和限速，其间以空格分隔。
输出格式： 在一行中输出处理意见：若属于正常行驶，则输出“OK”；若应处罚款，则输出“Exceed x%. Ticket 200”；若应吊销驾驶证，则输出“Exceed x%. License Revoked”。其中x是超速的百分比，精确到整数。
输入样例1： 65 60 输出样例1： OK 输入样例2： 110 100 输出样例2： Exceed 10%. Ticket 200 输入样例3： 200 120 输出样例3： Exceed 67%. License Revoked 这道题的难点在于理解限速的10%，这是一道数学公式，也就是(a-b)/b，这个限速的10%不是单纯的吧a/b,而是求出差之后在进行除法，解决完这个就是单纯的条件语句if-else啦。
代码如下：
#include&lt;stdio.h&gt; int main(){ int a,b; float c; scanf("%d %d",&amp;a,&amp;b); //这里我直接用一个式子做出判断便于理解 //开始的if语句我先判断是否小于10% if((a-b)*1.0/b&lt;0.1){ printf("OK\n"); }else{ //然后再else语句内在嵌套一个if-else语句，这类运用形式主要是用于三个因素的判断 if((a-b)*1.0/b&gt;=0.1 &amp;&amp; (a-b)*1.0/b&lt;0.5) //这里我出过一个错误就是运行结果出来之后，老是提交出错，实例三运行错误，但是我的输出结果是正确的，我在查阅其他人的代码后，发现我是的(a-b)*1.0/b&lt;=0.5)这里写啦一个等号导致提交结果出错，所以大家写代码的时候要细心 printf("Exceed %.f%%. Ticket 200\n",(a-b)*100.0/b); else printf("Exceed %.f%%. License Revoked\n",(a-b)*100.0/b); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a2520bf2b656b5cf4ef95183deace1/" rel="bookmark">
			Kafka生产者原理与优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.Kafka生产者原理：
1.基础流程：
2.Sender相关：
3.怎样保证消息的有序性：
2.Kafka消费者：
1.Kafka生产者原理： 1.基础流程： Kafka生产者生产消息，基本上包括下面4个部分：
线程：多个线程可以操作同一个kafkaProducer去生产消息，并且可以给多个不同的topic生产消息。kafkaProducer: kafka消息生产者，具体对应kafka的一个java类，里面包含了partitioner分区器（根据具体消息的key去选择发送到哪个分区，如果没有key则轮询选择分区）；accumulator累加器(针对缓冲区进行操作，缓存产生的消息，缓冲区大小可以根据业务调优-调优，默认是32M)，还有双向队列dq用来缓存消息（缓冲区中topic-&gt;partition），dq中的又包含了batch，batch默认大小为16K，每个batch中可以存放一条或者多条消息，因为默认是16K，所以如果出现很多消息msg&gt;16K的情况，就不能使用默认大小的已经开辟出内存的batch，需要重新进行系统调用开辟符合大小的batch内存，用完后还要回收，这样既可能造成内存碎片，还有频繁的系统调用，降低性能，所以需要根据msg大小对batch大小进行调整（调优），使得kafkaProducer开辟出符合业务需求的固定大小的batch。kafkaProducer 生产消息-&gt; accumulator累加器（缓冲区）-&gt; dq双向队列（t每个partition对应一个dq，并且对其操作是线程安全的） -&gt; batch。Sender：这是一个IO thread，用来将缓冲区缓存的消息发送到broker集群。有一个kafkaProducer的参数定义IO thread发送数据的时间间隔，如果这个参数设置为0，那么缓冲区每写入一个消息，就发送一次，这样的话缓冲区的意义就不存在了，例如可以将这个参数的值设置为10秒，这样的话，每隔10秒，IO thread就会将缓存区缓存的消息发送到broker集群。Sender(IO thread)与kafkaProducer是一对一的关系， 在kafkaProducer的构造方法中会为其生成一个sender（IO thread），还有就是在执行newSender(...)方法的时候，会new Selector，最终调用到java.nio.channels.Selector.open()，使用到了NIO（但是不是使用Netty，是自己实现NIO），要把channel注册到selector。broker集群：就是kafka集群，每个broker表示一个kafka单例。 2.Sender相关： conf.setProperty(ProducerConfig.MAX_REQUEST_SIZE_CONFIG, "1048576")，表示每次Sender(IO thread) 发送出去的数据的最大大小，这1M大小是由多个batch组成的。
(1).accumulator累加器（缓冲区）在累加的数据达到MAX_REQUEST_SIZE_CONFIG之后，就会唤醒IO thread进行发送？？？不是这样的，kafkaProducer会把消息以topic-&gt;partition-&gt;dq-&gt;batch的方式存放到缓冲区，IO thread每隔一段时间会以MAX_REQUEST_SIZE_CONFIG的大小从缓冲区拉取数据，发送到kafka集群。可以针对MAX_REQUEST_SIZE_CONFIG大小进行调优，但是要同时调整kafka集群接收端的大小。
IO thread在非阻塞的情况下每次发送最大的数据量是1M，但是最小的是多少呢？在阻塞的情况下，每发送一条消息到缓冲区，IO thread会将其发送到kafka集群。
(2).conf.setProperty(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION,"5");表示连续发送5次，但是kafka没返回，那么kafkaProducer就不再发了，这里也可以进行调优。这里是什么情况？
(3). 这两个是Kafka自己设置的默认的TCP（socket）的缓冲区的大小。可以使用netstat - natp指令查看每个网络应用的tcp缓冲区大小。 conf.setProperty(ProducerConfig.SEND_BUFFER_CONFIG,"32768"); //32K -1 conf.setProperty(ProducerConfig.RECEIVE_BUFFER_CONFIG,"32768"); //32k -1k 可以根据需要将其调大，进行调优。
其实操作系统有自己的TCP(socket) IO缓存的大小，所有的网络应用都要用到这个系统缓冲区，如果kafkaProducer需要发送大量数据，但是速度达不到预期，造成一些消息的积压，可以将上面的两个参数都设置为-1（调优），这样的话，就会使用操作系统默认的大小124928.
(4).综上所述，如果业务需要，可以通过设置缓冲区大小、batch大小（缓冲区相关，还有Sender相关的几个参数）来给kafkaProducer进行调优，但是这是有个前提的，那就是只有在ACK被设置为0的时候才会发挥缓冲器的作用，并且还要求用的是非阻塞的方式发送消息。ACK可以被设置为1,0,-1或者all，这4种方式代表不同的意义。
进入到 IO thread. 如果ACK设置为1或-1，那么往batch存一条消息，IO thread会立即将其发送给broker，这样缓冲区就不起作用了。
3.怎样保证消息的有序性： 有序的消息要保存到某个topic的用一个分区，为了保证这点，要将任务交给同一个线程，并且是同一个kafkaProducer，消息的key必须是相同的，kafkaProducer的分区器是根据key为消息选择分区的，如果没有key，那么消息将以轮询的方式分散发送给topic下的所有分区。
2.Kafka消费者： 需要注意的是：
每个KafkaConsumer都要指定一个group，这样的话这个consumer因为意外导致重启的时候，还能够继续从原来的offset进行消费；如果不指定具体的group名字，那么意外重启后，会属于一个随机的group，跟原来不一样，无法从原来的offset继续消费，因为offset记录在group中。虽然offset是属于某个partition的，但是根据不同业务的需要，也是按照group来存储的，多个业务消费同一个partition，就需要group，每个业务在不同的group中。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca1f1c63ee20f2fdd9b85a73641f0f83/" rel="bookmark">
			(五) 爬虫教程 ｜Ajax 数据爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 有时候我们在用 requests 抓取页面的时候，得到的结果可能和在浏览器中看到的不一样：在浏览器中可以看到正常显示的页面数据，但是使用 requests 得到的结果并没有，这是因为requests 获取的都是原始的 HTML 文档，而浏览器中的页面则是经过 JavaScript 处理数据后生成的结果，这些数据的来源有多种，可能是通过 Ajax 加载的， 可能是包含在 HTML 文档中的，也可能是经过 JavaScript 和定算法计算后生成的
对于第一种情况，数据加载是一种异步加载方式，原始的页面最初不会包含某些数据，原始页面。加载完后，会再向服务器请求某个接口获取数据，然后数据才被处理从而呈现到网页上，这其实就是发送了一个 Ajax 请求。
照Web 发展的趋势来看，这种形式的页面越来越多 网页的原始 HTML 文档不会包含任何数据，数据都是通过Ajax统一加载后再呈现出来的，这样在 We 开发上可以做到前后端分离，而且降低服务器直接渲染页面带来的压力。所以如果遇到这样的页面，直接利用requests 等库来抓取原始页面，是无法获取到有效数据的，这时需要分析网页后台 接口发送的 jax 请求，如果可以用 requests 来模拟 Ajax 请求，那么就可以成功抓取了。
所以，本章我们的主要目的是了解什么是 jax 及如何去分析和抓取 Ajax 请求
二、什么是Ajax Ajax ，全称为 Asynchronous JavaScript and XML ，即异步的 JavaScript XML 它不是一门编程
语言，而是利用 JavaScript 在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。
对于传统的网页，如果想更新其内容，那么必须要刷新整个页面，但有了 Ajax ，便可以在页面不被全部刷新的情况下更新其内容 在这个过程中，页面实际上是在后台与服务器进行了数据交互，获取到数据之后，再利用 JavaScript改变网页，这样网页内容就会更新了。
我们以CSDN为例子，点击Python，我们向下拉取页面，数据会不断的更新有新的内容，这就是Ajax。我们注意到页面其实并没有整个刷新，也就意味着页面的链接没有变化，但是网页中却多了新内容，也就是后面刷出来的新微博，这就是通过Ajax获取新数据呈现的过程 三、Ajax分析方法 我们以前面的CSDN为例，知道拖动刷新的内容由Ajax加载，而且也没的URL没有变化，那么应该到哪里去看这些Ajax请求呢？
1.右击点击检查2.点Network3.点击XHR会呈现出XHR数据4.向下滑动，会有一条条XHR数据更新，这样我们就可以捕获到所有的 Ajax 请求了 四、实战演练 4.1爬取肯德基餐厅信息 需求：爬取肯德基餐厅查询，指定地点的餐厅数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca1f1c63ee20f2fdd9b85a73641f0f83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/031982e0cb170257c61ff7308faafb75/" rel="bookmark">
			Laravel视图blade模板使用集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{{ $var }} - 打印内容
{{ $var or 'default' }} - 打印内容并带一个默认值
{{{ $var }}} - 打印转义内容
{{-- Comment --}} - 注释
@extends('layout') - 继承模板‘layout’
@if(condition) - if开始
@else - else不带条件
@elseif(condition) - else带条件
@endif - 结束if
@foreach($list as $key =&gt; $val) - foreach使用
@endforeach - 结束foreach
@for($i = 0; $i &lt; 10; $i++) - for循环开始
@endfor - for循环结束
@while(condition) - while循环开始
@endwhile - while循环结束
@unless(condition) - unless开始
@endunless - unless结束
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/031982e0cb170257c61ff7308faafb75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d129c52318235148c9fded9e9a951e4/" rel="bookmark">
			【laravel5.1】Blade模板继承简要使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模板继承什么用？ 自然是增强基础页面的复用，有利于页面文档的条理，也便于更改多处使用的内容，如页头、页脚
1.用法概要 @include('common.header') 包含子视图@extends('article.common.base') 继承基础模板@yield('content') 视图占位符@section('content') @endsection继承模板后向视图占位符中填入内容{{-- 注释 --}} Blade模板中注释的使用 2.具体使用 2.1 新建Article基础模板base.blade.php 直接使用Bootstrap4模板代码及CDN,新建视图基础模板
路径resources/views/article/common/base.blade.php
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;Artilce|标题在此&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;meta http-equiv="x-ua-compatible" content="ie=edge"&gt; &lt;link rel="stylesheet" href="https://cdn.rawgit.com/twbs/bootstrap/v4-dev/dist/css/bootstrap.css"&gt; &lt;/head&gt; &lt;body&gt; {{-- 包含页头 --}} @include('article.common.header') {{-- 继承后插入的内容 --}} @yield('content') {{-- 包含页脚 --}} @include('article.common.footer') &lt;script src="http://ajax.useso.com/ajax/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.rawgit.com/twbs/bootstrap/v4-dev/dist/js/bootstrap.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.2. 建子视图文件 页头和页脚 页头文件 resources/views/article/common/header.blade.php &lt;nav class="navbar navbar-light bg-faded"&gt; &lt;div class="container"&gt; &lt;a class="navbar-brand" href="#"&gt;Articles&lt;/a&gt; &lt;ul class="nav navbar-nav"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d129c52318235148c9fded9e9a951e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5b70718090e304b787b7ffde4f7f1d0/" rel="bookmark">
			计算机网络-第三章-数据链路层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据链路层 数据链路层属于计算机网络的底层。数据链路层使用的信道主要有： （1）点对点信道
（2）广播信道
本章节重要内容：（1）数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的的协议（ppp）协议以及（CSMA/CD协议）的特点。
（2）数据链路层的三个基本问题：封装成桢、透明传输和差错检测。
（3）以太网MAC层的硬件地址。
（4）适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。
计算机网络-第三章-数据链路层 数据链路层属于计算机网络的底层。数据链路层使用的信道主要有： （1）点对点信道
（2）广播信道
使用点对点通信的数据链路层 数据链路和帧：
链路是从结点到相邻结点的一段物理线路中间没有任何其他交换结点；数据链路是必须有一条物理线路外还必须要有的通信协议来控制这些数据协议来控制这些数据传输。常用的方法是使用网络适配器（硬件、软件）
数据链路层的协议数据单元——帧
三个基本问题：封装成帧、透明传输、差错检测。下面一一介绍这三个问题；
1 封装成帧：是在一段数据的前后分别添加首部和尾部。首部和尾部的重要作用是进行帧定界。关于所传送帧的数据部分长度上限——最大传送单元（MTU，Maximum Transfer Unit)
2 透明传输 ；透明这个词得特殊理解，所谓“透明”便是：某一个实际存在的事物看起来却好像不存在一样。那么透明传输的理解就是：不管所传数据是什么样的比特组合，都应当能够在链路上传送
3 差错检测；
在实际的链路传输中可能会产生差错，0可能会变成1,1变成0这种比特差错；误码率：出错的比特占比比特总数比率。为了保证数据传输的可靠性就必须采用各种差错检测方法，在数据链路层较多使用CRC循环冗余检验。
CRC冗余检验原理：
1 先在K个数据的后面添加供差错检验用的n位冗余码；
2 发出（k+n）位
3 进行模2运算。
4 得出余数若为0便没错。
最后再强调一下，在数据链路层若仅仅使用循环冗余检验 CRC,差错检测技术，则只能做到对帧的无差端接受，即：“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为在传输过程中没有产生差错”。接收丢弃的帧虽然曾收到了，但最终还
是有差错被丢弃，即没有被接受。以上所述通常都是这样认为小
“凡是接收端数据链路层接受的帧均无差错”。
点对点协议PPP ppp协议数据链路层广泛使用的协议
ppp协议需要满足：
1 简单 2封装成帧 3透明性 4多种网络层协议 5多种类型链路 6差错建议 7检测连接状态 8最大传送单位 9网络层地址协商 10数据压缩协商 PPP协议组成： 一个将IP数据报封到串行链路的方法。PPP既支持异步链路（无奇偶校验的8比特数据），也支持面向比特的同步链路。一个用来建立、配置和测试数据链路的链路控制协议LCP（Link Control Protocol）。通信的双方可协商一些选项。在[RFC 1661]中定义了11种类型的LCP分组。
3.一套网络控制协议NCP（Network Control Protocol），支持不同的网络层协议，如IP、OSI的网络层、DECnet、AppleTalk等。 PPP协议帧格式： 字节填充： 示例：异步传输时有转义字符0x7D（01111101）使用字节填充。
1把信息字段中出现的每一个0x7E字节转变为2字节序列(0x7D，0x5E)。
2若信息字段中出现一个0x7D的字节(即出现了和转义字符一样的比特组合)，则把转义字符0x7D转变为2字节序列(0x7D，0x5D)。
3若信息字段中出现ASCII码的控制字符(即数值小于0x20的字符)，则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。例如，出现0x03(在控制字符中是“传输结束”ETX)就要把它转变为2字节序列的(0x7D，0x23)。
零比特填充：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5b70718090e304b787b7ffde4f7f1d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0453ccb13be1587c8c973c974de688db/" rel="bookmark">
			matlab 用古典雅可比方法求矩阵特征根 （仅使用基础函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们先看看《数值计算方法》这本书上关于古典雅可比方法的例题：
%author FoddcusL FAFU %The Jacobi For root %输入：目标矩阵（input）；目标接近的特征值（charnum）、迭代上限（aimnum）、目标误差（errorS） %输出：目标特征值（output）；xform、zfrom，包含x、z特征向量的值。 %input输入矩阵，包括系数和参数 %inputC 用于分解LU矩阵的合成矩阵 %oringinData保留的初始矩阵 %output 输出答案，对应X的各个值 %Toutput：修正顺序后的答案，对应输入数据的X顺序 %rememberdet：行列变化中介值 %remember：行列变化记录矩阵 %xnum,ynum 输入矩阵的尺寸 %Lneed 消元中，主式需要乘的变量 %keepnum 保留小数位数 % clear all%启用模块化后需要注释该句 input=[2,-1,0; -1,2,-1; 0,-1,2];%输入矩阵 errorS=10^(-20); %% oringinData=input; error1='the condition are not meet for using this algorithm' ; keepnum=-10;%设置保留n位小数,记得加负号表示小数位 [ynum,xnum]=size(input);%获取输入矩阵大小 if ynum~=xnum disp(error1) end dealdet=input; knum=1000; R3det=[]; ddet=[]; %% for k=1:knum%迭代次数knum %挑选i值和j值 absfator=0; id=0; jd=0; for i=1:xnum for j=1:ynum if i~=j if absfator&lt;roundn(abs(dealdet(j,i)),keepnum) absfator=abs(dealdet(j,i)); id=i;%++列 jd=j;%++行 end end end end %计算旋转矩阵 a=(dealdet(jd,jd)-dealdet(id,id))/(2*dealdet(jd,id)); fiv=acot(a)/2; b=tan(fiv); c=cos(fiv); d=sin(fiv); %V值 V=eye(ynum); V(id,id)=c; V(jd,jd)=c; V(id,jd)=-d; V(jd,id)=d; V3det(:,:,k)=V; %计算新矩阵 dealdet=V*dealdet*(V'); R3det(:,:,k)=dealdet; ddet(k,1)=jd; ddet(k,2)=id; %计算误差 errorN=0; for i=1:xnum for j=1:ynum if i~=j errorN=errorN+dealdet(i,j)^2; end end end errorf(k,1)=errorN; if errorN&lt;errorS break end end Vedet=V3det(:,:,1); for i=1:k-1 Vedet=Vedet*V3det(:,:,k+1-i); end for i=1:ynum disp(["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0453ccb13be1587c8c973c974de688db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8539a5c270a14aa18cbc58fe108ace23/" rel="bookmark">
			C语言，if循环 for 循环 while循环 switch循环 do...while()循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、if循环
二、 switch循环
break语句
default子句
三、while循环
break在while循环中的作用
continue在while循环中的作用就是
四、for循环
break和continue在for循环中
五、do...while()循环
一、if循环 if语句的语法结构：
if(表达式) 语句; if(表达式) 语句1; else 语句2; //多分支 if(表达式1) 语句1; else if(表达式2) 语句2; else 语句3; 在实际书写中，要执行多条语句，应该使用代码块，一对 { } 就是一个代码块。
适当的使用 { } 可以使代码的逻辑更加清楚。
规则整齐的 { }能让我们的代码一目了然，错误的使用 { } 会让你的代码晦涩难懂。
#include &lt;stdio.h&gt; int main() { if(表达式) { 语句列表1； } else { 语句列表2； } return 0; } if书写形式的对比：
//代码1 if (condition) { return x; } return y; //代码2 if(condition) { return x; } else { return y; } 同样的代码，我们发现代码2 给人的感觉最好
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8539a5c270a14aa18cbc58fe108ace23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad2aa40dbea9e5c57eb56f5f506cb91/" rel="bookmark">
			好的测试数据管理，到底要怎么做？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你的组织是否实施了测试数据管理？如果你的组织处理关键或敏感的业务数据，测试数据管理肯定会让组织受益。与测试数据相关的问题占所有软件缺陷的 15%，这一事实强调了测试数据的重要性。
本文将准确讨论测试数据经理职责、测试数据经理需要什么技能、以及雇佣测试数据经理的好处。
什么是测试数据管理？ 让我们首先深入了解测试数据管理 (TDM)的定义，管理满足自动化测试要求所需的数据的过程称为测试数据管理。测试数据经理可以使用测试数据管理解决方案来根据测试的需要创建测试数据。
测试数据管理解决方案必须确保它只提供高质量的数据。质量差的数据比完全没有数据更糟，低质量的数据可能会产生不可信的错误结果。保真度是测试数据的另一个重要要求：测试数据必须尽可能接近真实生产数据。
测试数据经理的工作职责 测试数据经理的主要职责之一是制定和执行组织的企业测试数据管理长期战略。此外，测试数据经理负责测试相关任务的估算、测试需求的分析、支持工具的设计和开发、测试以及TDM流程和解决方案的实施。测试数据经理创建的流程既一致又可重复，以支持多种功能。这些功能可以包括针对不同应用的测试数据的重复识别和屏蔽，以及根据需要频繁刷新和更新测试数据。
测试数据经理的另一个非常重要的职责是确保遵守 IT 安全指南和数据合规性法规。
测试数据经理还负责为 QA 测试、用户验收测试和性能测试提供数据。
测试数据经理需要哪些技能？ 必须确保测试数据经理具备处理该职位所有职责所需的技能。例如，他们应该知道如何使用 TDM 工具来创建和挖掘测试数据、能够自动快速生成数据。这对组织来说是一个很大的好处，因为这样可以非常快速地测试许多场景。
才华横溢的测试数据经理会发现测试数据中的低效率并对其进行优化以改进测试过程。比如，我们需要不时的手动保存文件以覆盖原有旧文件。测试数据经理认为此过程缓慢且容易出错。在这种情况下，他们可能决定创建一个简单的脚本来验证文件版本时间并不断自动保存。
合格的候选人应该能够理解和处理来自测试数据分析师和其他请求者的测试数据请求。他们应该能够与所有类型的分析师和工程师一起工作。因此，测试数据经理必须具有广泛的工程技能。例如，Java（Hive、Apache、Hadoop）和 Scala（Apache Spark、Kafka）等技能是有益的。
测试数据经理还应该有使用 Excel 宏、QTP 和类似工具进行自动化的经验。此外，对大数据、Hadoop、Teradata、SQL Server 或 DB2 等数据库技术有很好的了解将有助于候选人管理数据存储任务。
最后，应用数据屏蔽技术的能力对于测试数据经理的职位来说是一项不容商榷的技能。屏蔽数据对于通过避免有害的数据泄露来保护您公司的声誉和用户数据是必要的。
测试数据管理的好处 1. 为自动化测试提供高质量数据 聘请测试数据经理的最重要原因是确保将高质量数据提供给自动化测试算法。
如果提供给测试的数据质量很差，那么测试很可能会失败。如果使用低质量的数据，再多的策略也无法挽救这次测试。因此，如果没有高质量的数据，请不要花费大量时间来创建详细的测试策略。
2. 使数据可用于测试 测试数据经理的主要角色是测试数据的生成和测试本身。测试数据管理器可确保在需要时始终提供高质量的测试数据，这会使得测试过程顺利。
在测试需要时提供高质量的测试数据至关重要，这正是测试数据经理所做的。例如，假设开发团队正在等待有关新创建版本的测试反馈。但由于测试数据仍未创建，开发团队的速度变慢了。理想情况下，测试数据经理决定在开发新功能时需要创建哪些测试数据。这样，测试数据的可用性与新版本相一致，并且可以立即对版本进行测试。这样就为开发团队节省了宝贵的时间。
3. 帮助创建记录在案的 TDM 流程 测试数据经理可以记录 TDM 过程，这相当重要。拥有文档化的 TDM 流程有助于其他团队成员了解测试数据经理如何生成测试数据并处理应用场景的测试。
如果您的测试数据经理请假或离职，组织仍然可以依靠测试数据经理记录的流程，团队将能够快速理解和执行与 TDM 相关的任务。
4. 帮助尽早发现错误 测试数据管理器可确保您的 TDM 流程顺利运行。这会增加更快发现错误的机会。修复错误的成本将随着检测它们所需的总时间而增加。
对测试数据管理人员日益增长的需求 由于产生的数据量急剧增加，对测试数据经理的需求也日益增长。如今生成的数据量巨大，每天生成 2.5 千亿字节的数据。仅在过去两年中，我们就生成了这个世界上有史以来生成的所有数据的 90%。
需要测试数据管理器的另一个原因是防止测试数据泄露。每次数据泄露的成本可能高达 400 万美元。然而，许多组织还没有看到测试数据管理的价值，目前只有 24%的组织掩盖了他们的数据。
填补测试数据经理的职位并不容易，该职位需要许多不同领域的技能，如编程、工程、数据屏蔽和项目管理。公司之间在招聘具有正确技能组合的测试数据经理方面存在着激烈的竞争。
但实际上，一款合适的软件就可以满足如上大部分需求，为企业节约人力成本和时间成本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad2aa40dbea9e5c57eb56f5f506cb91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab3c4e615ff1bdbc9b2a1bf7f0881e2/" rel="bookmark">
			芯片与CPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义
⋅ \cdot ⋅ 中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。
⋅ \cdot ⋅ 目前我们使用的CPU是由运算器、控制器、寄存器、高速缓存及实现它们之间联系的数据、控制及状态的总线构成。
什么是芯片？
⋅ \cdot ⋅ 芯片就是集成电路，包含了各种组件，可以实现某种特定功能。
集成电路英语：integrated circuit，缩写作 IC；或称微电路（microcircuit）、微芯片（microchip）、晶片/芯片（chip）在电子学中是一种将电路（主要包括半导体设备，也包括被动组件等）小型化的方式，并时常制造在半导体晶圆表面上。
⋅ \cdot ⋅ 造芯片的厂家（和海思一样）：AMD，英特尔
i5/i7/r7什么的都是产CPU的这些公司的一个系列罢了。
芯片与CPU关系： CPU是芯片的一种，但芯片不一定就是CPU。
CPU是超大规模的集成电路的一种，而集成电路都可以叫做芯片。
如 果 说 C P U 是 大 脑 ， 那 么 电 子 产 品 里 面 其 他 芯 片 就 相 当 于 小 脑 、 脑 干 之 类 的 ， 这 个 比 喻 不 是 很 准 确 ， 反 正 就 是 负 责 内 容 不 一 样 吧 ， 有 些 芯 片 负 责 记 忆 ， 有 些 芯 片 负 责 升 压 降 压 （ 改 变 电 源 电 压 ） ， 而 C P U 只 是 相 当 于 大 脑 思 考 的 那 部 分 ， C P U 不 会 记 东 西 哦 。 \footnotesize{如果说CPU是大脑，那么电子产品里面其他芯片就相当于小脑、脑干之类的，这个比喻不是很准确，反正就是负责内容不一样吧，有些芯片负责记忆，有些芯片负责升压降压（改变电源电压），而CPU只是相当于大脑思考的那部分，CPU不会记东西哦。} 如果说CPU是大脑，那么电子产品里面其他芯片就相当于小脑、脑干之类的，这个比喻不是很准确，反正就是负责内容不一样吧，有些芯片负责记忆，有些芯片负责升压降压（改变电源电压），而CPU只是相当于大脑思考的那部分，CPU不会记东西哦。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ab3c4e615ff1bdbc9b2a1bf7f0881e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b859ee8fcb48739a011a4e86b1f5625/" rel="bookmark">
			webstorm编写NodeJS没有代码提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学NodeJs,使用编码工具参照菜鸟教程案例练习时，发现一直没有代码提示，如下：
先要输入一个 fs.readFile() 的方法，发现一直未出现方法提示。
解决方法如下：
1.找到左上角 File &gt;&gt; Settings，打开设置页面，找到“Languages &amp; Frameworks”，如下图，将属性“javaScript language version”的下拉选项值设置为“ECMAScript6”。
2.安装Node提示插件
（1）在“JavaScript”菜单子目录里面找到“libraries”，点击打开配置页面如下，
（2）然后点击右侧“Download”按钮，会出现下载选项页面（页面加载可能会有点慢），
（3）往下滚动选择“node”后点击“Download And Install” 开始安装
（4）安装完成后，记得勾选，然后保存。
3.再次编写代码就会有提示了。
（完。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88de3d88e607ad5fade066a5df1b919d/" rel="bookmark">
			【数学知识】质数与质因子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、质数 1. 概念 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数，否则称为合数。
规定1既不是质数也不是合数质数的个数是无穷的 2. 例题：AcWing 3497 质数 3. 代码： 判断质数时for循环的停止条件可以有几种形式：
i &lt; = n / i i&lt;=n/i i&lt;=n/i i &lt; = s q r t ( n ) i&lt;=sqrt(n) i&lt;=sqrt(n)：相较第一种运算速度慢 i ∗ i &lt; = n i*i&lt;=n i∗i&lt;=n：要注意i的平方是否会溢出 #include &lt;iostream&gt; using namespace std; /* AcWing 3497 质数 */ const int maxn = 1e4 + 10; int p[maxn]; void getPrime(){ p[1] = 2; int n = 3, i = 2; while(i &lt;= 1e4){ int flag = 0; for(int i = 2; i &lt;= n / i; i++){ if(n % i == 0){ flag = 1; break; } } if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88de3d88e607ad5fade066a5df1b919d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acbd6332a71a1736cea2286c5c932424/" rel="bookmark">
			如何获取当前目录_bat_shell(转载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、bat文件获取当前目录
方法1：获取到的是bat文件的路径(一般会用这个)
@echo off echo 当前目录:%~dp0 pause 方法2：获取到的是当前cmd窗口的路径
@echo off echo 当前目录:%cd% pause 注意：如果目录乱码，将bat文件保存为 ANSI格式
二、shell脚本，获取当前目录 workdir=$(cd $(dirname $0); pwd) echo 下面输出当前路径 echo $workdir 参考：
bat获取当前文件夹路径_未名编程的博客-CSDN博客_bat获取当前目录路径
https://www.jb51.net/article/142194.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a916c500138351c3e2fbfa3d783b7698/" rel="bookmark">
			Go语言获取当天、昨天、明天、某天0点时间戳以及格式化时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取当前时间 到 明天0点整的时间差的秒级时间戳的字符串形式 func GetTimeDifference() string { nowTime := time.Now() // 当天秒级时间戳 nowTimeStamp := nowTime.Unix() nowTimeStr := nowTime.Format("2006-01-02") //使用Parse 默认获取为UTC时区 需要获取本地时区 所以使用ParseInLocation t2, _ := time.ParseInLocation("2006-01-02", nowTimeStr, time.Local) // 第二天零点时间戳 towTimeStamp := t2.AddDate(0, 0, 1).Unix() return strconv.FormatInt(towTimeStamp - nowTimeStamp, 10) } 当天0点时间戳 addTime := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location()) timeSamp := addTime.Unix() fmt.Println(timeSamp) // 1649952000 当天0点格式化时间： t := time.Now() addTime := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a916c500138351c3e2fbfa3d783b7698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ba2e9cf538a6ad47a8a50da68b2e016/" rel="bookmark">
			引入xxl-job配置，启动报Address already in use的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己挖坑自己踩。
在本机项目中测试引用xxl-job配置，启动报错：java.net.BindException: Address already in use: bind
一开始以为是地址端口冲突了，尝试修改好几次，‘屡试都爽’。
百度说是引用低版本依赖问题，换成不同版本尝试，发现还是不行。
然后启动源码库上测试项目，发现能正常启动。
然后比对本机项目引入Configuration配置，发现有所不同。
原来xxl-job在版本更新之后@bean不需要加(initMethod = “start”, destroyMethod = “destroy”)
删掉重启，本地项目启动正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eeae62e65cfec324de952a60f45ad8c/" rel="bookmark">
			TypeError: __init__() got an unexpected keyword argument ‘n_iter‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如上
该分类器中的参数n_iter 在新版本中变成了n_iter_no_change
仅仅因为版本更新了而已
所以把n_iter用n_iter_no_change替换一下就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d7f09aaadc4ce63130b07a3179c952/" rel="bookmark">
			HTML 排列页面内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、主要标签 1.a标签 超链接跳转实现页面相互跳转
属性：href：目标路径
路径分为两种：绝对路径：网址从电脑域名开始书写D：//目录1/目录2/页面.html
相对路径：相对于当前页面的位置 推荐各位使用 tips：尽量将页面用到的所有资源放在同一个项目中
2.audio音频标签
属性：src引用资源 controls 控制面板 autoplay自动播放
兼容：各个浏览器对标签的解析效果不一样 IE7以下版本不支持audio
格式：支持mp3 .w4ma
3.video视频标签
属性：src contr autoplay poster封面
格式：mp4
4.ul无序列表
结构：
&lt;ul&gt; &lt;li&gt; &lt;/li&gt; &lt;/ul&gt; 属性：type图标类型 disc默认实心圆 circle空心圆 square正方形
用途：菜单导航
5.ol有序列表
属性：type图标类型 order list 默认数字 1 A a start自定义设置开始的序号
tips：ul和ol的用途类似重叠，推荐使用ul
6.图文混编列表
结构
&lt;dl&gt; &lt;dt&gt;图片&lt;/dt&gt; &lt;dd&gt;文字&lt;/dd&gt; &lt;dl&gt; 用途：商品信息展示 人物介绍
7.div，span 容器标签
div 块级容器标签
span 行级容器标签
用途：以后画页面时，需要将页面分为若干个区域，可以使用div和span
8.table标签
定义：集中展示多行多列的数据
tr行标签 td单元格标签
结构
&lt;table&gt; &lt;tr&gt; &lt;td&gt;文字&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; table标签常用属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70d7f09aaadc4ce63130b07a3179c952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/594b56cc0fe731382d5a73236993b816/" rel="bookmark">
			vue中用Ajax请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http&gt;index.js 封装Ajax
function get( url, fn){ // 原生ajax const xhr = new XMLHttpRequest(); xhr.open("GET", url, true); // true 异步 false 同步 xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState == 4) { if (xhr.status == 200) { console.log("结果是：", xhr.responseText); let obj= JSON.parse( xhr.responseText ); console.log(obj); // 0-----------------返回值怎么办？---- // return 123; fn(obj) } else { console.log("请求失败", xhr.status); } } }; } export default { get }; 原生 home.vue 请求数据 原生---&gt;jq写法回调写法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/594b56cc0fe731382d5a73236993b816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd16317044a6b3d5199bf32cbe6dcf3a/" rel="bookmark">
			vuex传参------
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		index.js
import Vue from "vue"; import Vuex from "vuex"; Vue.use(Vuex); const store = new Vuex.Store({ state: { use: "gao", num: 2 }, mutations: { tongChange(state, n) { state.use = n }, tongNum(state) { state.num += 1 }, //异步 不推荐 yibuNum(state) { setTimeout(() =&gt; { state.num += 1 }, 3000) } }, getters: { updateNum(state) { return state.use.toUpperCase() } }, actions: { actionTongNum({ commit }) { commit("tongNum") }, actionYiNum({ commit }) { setTimeout(() =&gt; { commit("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd16317044a6b3d5199bf32cbe6dcf3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2c6f9b92a9eef7f31d854150def49e/" rel="bookmark">
			【C语言】游戏开发：天天酷跑丨完美练手项目 [附源码]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.项目说明：
二.项目作用
三.项目技术要求
四.库、宏、主函数说明
五.项目实现
5.1游戏背景的实现
5.2实现Hero奔跑
5.3 实现Hero跳跃
5.4 优化帧等待
5.6使用结构体优化障碍物
5.7添加柱子障碍物
5.8碰撞检测
5.9优化下蹲-实现血条
5.10判断游戏结束、添加背景音乐、添加初始界面
5.11解决死亡障碍
5.12​​​​​​​显示分数
5.13​​​​​​​判断胜利
六：成品展示
一.项目说明： 原作者：奇牛编程 Rock老师
视频原地址：C语言手写天天酷跑_哔哩哔哩_bilibili
1.编程语言：C语言加上一点点C++的函数
2.开发环境：VC2010-VS2022 都可
3.开发用时：7小时
4.素材、源码、第三方库等加学习群：817459939 【传送门】
二.项目作用 1. 多层次滚动背景实现立体距离
2. 游戏引擎架构的设计
3. 多重障碍物的设计和实现
4. 游戏核心：碰撞检测的实现
5. 跳跃、下蹲的设计和实现
6. 炫酷分数的设计和实现
能够快速提升项目开发能力！
项目和笔记，可以直接作为课设。
三.项目技术要求 最低要求：
常量，变量，数组，循环，函数。
四.库、宏、主函数说明 #define _CRT_SECURE_NO_WARNINGS//使用scanf函数防止报错 #define WIN_SCORE 20//用于定义游戏获胜的分数条件 #define WIDTH 1012//游戏背景的宽度 #define HEIGHT 396//高度 #define OBSTACLE_COUNT 10//障碍物数量 #include&lt;stdio.h&gt;//标准输入输出库函数 #include&lt;graphics.h&gt;//引入图形库 #include&lt;conio.h&gt;//按键输入库 #include"tools.h"//添加本地头文件 #include&lt;vector&gt;//引入c++库用于使用容器变长数组 —————————————————————————————————————————————————— int main(void) { init();//初始化函数 loadimage(0, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d2c6f9b92a9eef7f31d854150def49e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3626b3149f661d8fe5bd86a26487ebc0/" rel="bookmark">
			线程池的使用（7种创建方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 固定数量的线程池
2. 带缓存的线程池
3. 执⾏定时任务
4. 定时任务单线程
5. 单线程线程池
6. 根据当前CPU⽣成线程池
7. ThreadPoolExecutor
(1). Executors ⾃动创建线程池可能存在的问题
(2). ThreadPoolExecutor 使⽤
线程状态
1. 固定数量的线程池 线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客
2. 带缓存的线程池 ​​​​​​线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客
3. 执⾏定时任务 线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客
4. 定时任务单线程 线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客
5. 单线程线程池 线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客
6. 根据当前CPU⽣成线程池 线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客
7. ThreadPoolExecutor (1). Executors ⾃动创建线程池可能存在的问题 a. OOM 代码演示 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolDemo54 { static class MyOOMClass { // 1M 空间（M KB Byte） private byte[] bytes = new byte[1 * 1024 * 1024]; } public static void main(String[] args) throws InterruptedException { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3626b3149f661d8fe5bd86a26487ebc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ed7177da8738a523992cd969889534b/" rel="bookmark">
			Java八股学习——设计模式的分类和介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总的分类 创建型模式（五种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
结构型模式（七种）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式
行为型模式（十一种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
具体解释： 创建型 Factory Method(工厂模式)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。
Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。
Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
结构型 Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
Decorator(装饰模式)：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。
Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问[1]。
Facade（外观模式）：为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
Composite(组合模式)：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。
Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。
行为型 Chain of Responsibility（职责链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。
Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
Mediator（中介模式）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。
Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。
State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。
Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce1f358cf9b140c41c34e5a464efd90/" rel="bookmark">
			AcWing 1084. 数字游戏 II（数位dp）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意： 定义一种取模数，这种数字必须满足 各位数字之和 mod N 为 0。
指定一个整数闭区间 [a, b]，问这个 区间内有多少个取模数。
思路： 一般来说，数位Dp这类题目难点在于 如何预处理左分支方案数
对于本题，假设我们当前枚举到的第 i 位，且第 i 位上的数字是 x，那么对于答案中的第 i 位数字 j 来说，可以填两类数：
1.0 ~ x - 1
用 j 表示第 i 位数字（最高位），用 last 表示当前数严格前面数位上的数字之和，用sum表示后 i + 1 位（包括第 i 位）数字之和，
则sum 与 last 的 关系式 为 (last + sum) % N == 0（保证各个数位总和模 N 得 0），
将上式稍作变形，即得 sum % N 的结果 等价于 (- last) % N，答案 res 累加：res += f[i + 1][j][((- last) % N)]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce1f358cf9b140c41c34e5a464efd90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95fb244239e4208794742a4329e3c07/" rel="bookmark">
			二分查找详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.简介
2. 例子
3. 第一种写法（左闭右闭）
3.1 正向写法（正确演示）
3.2 反向写法(错误演示)
4. 第二种写法（左闭右开）
4.1 正向写法（正确演示）
4.2 反向写法（错误演示）
5. 总结
写在前面：
主要解释了二分法的左闭右闭区间，左闭右开区间两种写法，并且每个写法都举了相应的反例，范围写错的话可能会出现的错误等…
1.简介 有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1 本书。
保安怎么知道只有一本书📖没有登记出借，万一全部都没有登记呢​？
这个故事其实说出了二分查找需要的条件
用于查找的内容逻辑上来说是需要有序的查找的数量只能是一个，而不是多个 比如在一个有序的数组并且无重复元素的数组中，例如[1, 2, 3, 4, 5, 6]，需要查找3的位置就可以使用二分查找。
在二分查找中，目标元素的查找区间的定义十分重要，不同的区间的定义写法不一样
因为查找的区间是不断迭代的，所以确定查找的范围十分重要，主要就是左右区间的开和闭的问题，开闭不一样，对应的迭代方式也不一样，有以下两种方式：
左闭右闭[left, right]
左闭右开[left, right)
2. 例子 这是一个使用二分查找的例题
二分查找-I_牛客题霸_牛客网 (nowcoder.com)
题目如下：
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
示例一：
输入: nums = [-1,0,3,5,9,12], target = 9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a95fb244239e4208794742a4329e3c07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94ee317fadd57cd754b7b5c757175d11/" rel="bookmark">
			内部类与外部类之间的访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 1.内部类与外部类
2.内部类的特点：内部类可以直接访问外部类的成员(成员变量和成员方法)，包括私有成员。
3.内部类与外部类之间的访问
在测试类中调用成员内部类中的方法:
外部类访问成员内部类中的成员:
静态的成员内部类,只能访问外部类的静态成员
私有的成员内部类，外界就无法直接创建其对象,可以通过外部类的方法访问
局部内部类，在外界没有直接创建其对象的语法
局部内部类访问外部类的局部变量:
1.内部类与外部类 将一个类A 定义到另一个类B的内部，那么类A叫做内部类，类B叫做外部类。
根据内部类在外部类中定义的位置不同，分为 成员内部类，和局部内部类
成员内部类: 定义在外部类的成员位置。局部内部类: 定义在外部类的局部位置，也就是外部类中的方法内部。 class B { //B是外部类 class A { //A是成员内部类 } public void show() { class C { //C是局部内部类 } } } 2.内部类的特点：内部类可以直接访问外部类的成员(成员变量和成员方法)，包括私有成员。 package org.xingyun.interface1; public class Wai { //外部类 int num = 20; private int a = 60; //成员内部类 public class Nei { public void neiShow() { System.out.println("内部类的show方法"); //内部类的特点：内部类可以直接访问外部类的成员，包括私有成员。 System.out.println(num); //外部类的成员变量 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94ee317fadd57cd754b7b5c757175d11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f702371c2017ecc1ca54880fed0531d/" rel="bookmark">
			PTA 利用指针找最大值 (10 分)本题要求实现一个简单函数，找出两个数中的最大值。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题要求实现一个简单函数，找出两个数中的最大值。
函数接口定义： void findmax( int *px, int *py, int *pmax ); 其中px和py是用户传入的两个整数的指针。函数findmax应找出两个指针所指向的整数中的最大值，存放在pmax指向的位置。
裁判测试程序样例： #include &lt;stdio.h&gt; void findmax( int *px, int *py, int *pmax ); int main() { int max, x, y; scanf("%d %d", &amp;x, &amp;y); findmax( &amp;x, &amp;y, &amp;max ); printf("%d\n", max); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： 3 5 输出样例： 5 void findmax( int *px, int *py, int *pmax ) { if(*px&gt;*py) *pmax=*px; else *pmax=*py; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e66ef30e68d6457bcd94bc463e5dcc6c/" rel="bookmark">
			Spring扩展之BeanFactoryPostProcessor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用 BeanFactoryPostProcessor，BeanFactory后置处理器是 Spring 的扩展点之一。通过自定义 BeanFactoryPostProcessor 可以实现对 BeanDefinition 的修改。
执行入口 BeanFactoryPostProcessor 的执行入口在容器的刷新方法refresh中
@Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { prepareRefresh(); ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); prepareBeanFactory(beanFactory); try { postProcessBeanFactory(beanFactory); // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法 // 采用注解方式时，在这里，会扫描注解将类解析成bean定义放到map中 invokeBeanFactoryPostProcessors(beanFactory); registerBeanPostProcessors(beanFactory); initMessageSource(); initApplicationEventMulticaster(); onRefresh(); registerListeners(); finishBeanFactoryInitialization(beanFactory); finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); } destroyBeans(); cancelRefresh(ex); throw ex; } finally { resetCommonCaches(); } } } 其中invokeBeanFactoryPostProcessors(beanFactory)顾名思义就是执行 BeanFactoryPostProcessor 的地方
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e66ef30e68d6457bcd94bc463e5dcc6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba501f7c98b5116fb54704a388509d5f/" rel="bookmark">
			JavaWeb14.购物车案例（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目案例：JavaWeb14购物车案例
目录
项目实现功能
显示层
用户登录界面 login.jsp
用户登录操作页面 doLogin.jsp
主页主界面 index.jsp
添加购物车操作界面(添加至主页数组) doAddCart.jsp
实体类
商品实体类 Goods.java
用户实体类 User.java
数据库帮助类 DBHelper.java
数据库访问层
用户数据库访问接口 IUserDao.java
用户数据库访问实现类 UserDaoImpl.java
商品数据库访问接口 IGoodsDao.java
商品数据库访问实现类 GoodsDaoImpl.java
业务逻辑层
用户业务逻辑处理接口 IUserBiz.java
用户业务逻辑处理实体类 IUserBizImpl.java
商品业务逻辑处理接口 IGoodsBiz.java
商品业务逻辑处理实现类 GoodsBizImpl.java
项目实现功能 显示层 用户登录界面 login.jsp &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="${pageContext.request.contextPath}/bootstrap-3.3.7-dist/css/bootstrap.css"&gt; &lt;script src="${pageContext.request.contextPath}/bootstrap-3.3.7-dist/js/jquery-3.5.1.js"&gt;&lt;/script&gt; &lt;script src="${pageContext.request.contextPath}/bootstrap-3.3.7-dist/js/bootstrap.js"&gt;&lt;/script&gt; &lt;style&gt; * { outline: none !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba501f7c98b5116fb54704a388509d5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac1eba9818d0090df53d3a6d2e88748/" rel="bookmark">
			vSphere通 python API接口创建虚拟机及修改配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：跟OA流程打通，自动化创建虚拟机，减少系统工程师重复工作时间，通过vSphere 提供的接口创建虚拟机，笔者通过 vsphere-automation-sdk-python 创建虚拟机，pyvmomi 给VM添加磁盘，打开VM电源，获取虚拟机IP地址 笔者系统环境：windows python版本：python3.8 完整代码如下： import urllib3 import requests import time import calendar from com.vmware.vcenter.ovf_client import LibraryItem, DiskProvisioningType, ImportFlag from com.vmware.vcenter_client import Folder, ResourcePool, Cluster, Network, Datastore from vmware.vapi.vsphere.client import create_vsphere_client from com.vmware.content_client import Library, LibraryModel, LocalLibrary, SubscribedLibrary from com.vmware.content.library_client import Item, ItemModel, StorageBacking, SubscribedItem from pyVim.connect import SmartConnectNoSSL from pyVmomi import vim def create_vm(user, ip, password, network_name, cluster_name,datastore_name, folder_name, content_library_name, template_name, vm_name, annotation): """ 通过 vsphere-automation-sdk-python 从模板库复制虚拟机 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ac1eba9818d0090df53d3a6d2e88748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae3453504ea8bb7057ac8496c217f6f/" rel="bookmark">
			Atlassian应对CVE-2022-22963，CVE-2022-22965的常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CVE-2022-22965 常见问题解答 基本信息
已发现 Spring Framework 中的关键远程代码执行漏洞 CVE-2022-22965。根据 Spring 的安全公告，此漏洞会影响在 JDK 9 及更高版本上运行的 Spring MVC 和 Spring WebFlux 应用程序。
此页面包含有关“CVE-2022-22965：通过 JDK 9+ 上的数据绑定的 Spring Framework RCE”的常见问题和解答。Atlassian会及时更新，欢迎关注。
云实例是否受到影响？
不，Atlassian的云实例没有受到任何已知漏洞的影响，客户不需要采取任何行动。我们的分析没有发现Atlassian系统或客户数据受到任何影响。出于谨慎考虑，使用受影响的Spring版本的服务将作为优先事项进行修补，以防发现新的攻击载体。
本地服务器版/数据中心版产品是否受到影响？
正在进行的调查已确定，当满足一组狭隘的前提条件时，以下本地部署的产品易受攻击：
Bamboo服务器版和数据中心版Confluence服务器版和数据中心版Jira Software服务器版和数据中心版Jira Service Management服务器版和数据中心版 要成功被攻击，须满足以下所有前提条件：
产品在JDK9或更高版本上运行攻击者欺骗用户，发出恶意的HTTP请求该请求包含一个有效的跨站请求伪造令牌（请注意，同源策略会阻止攻击者获得用户的有效令牌）。目标用户以 "系统管理员 "的权限登录到应用程序。仅限Jira和Confluence：目标用户还拥有一个活跃的 “安全管理员会话”（注意，这些会话默认只持续10分钟）。 产品将根据我们的数据中心和服务器错误修复政策进行更新。
以下本地服务器版产品使用受影响的Spring版本，但不易受到任何已知漏洞的攻击：
Bitbucket 服务器版和数据中心版CrowdCrucibleFisheye 出于谨慎考虑，这些产品将根据我们的数据中心和服务器错误修复政策进行更新。
以下本地服务器版产品不使用 Spring，也不需要打补丁：
基于Mac的Sourcetree基于Windows的Sourcetree 在补丁可用之前，是否有任何临时解决方案可以缓解此漏洞？
使用受影响的本地部署产品的客户可以从运行 JDK 9 或更高版本降级到 JDK 8 或更低版本。这将消除被攻击的可能性。这些指令可用于更改 Jira 和 Confluence 的 Java 版本：
Jira：https://confluence.atlassian.com/jirakb/change-the-java-version-used-by-jira-server-765594330.htmlConfluence：https://confluence.atlassian.com/doc/change-the-java-vendor-or-version-confluence-uses-962342397.html Marketplace 应用程序是否受到影响？ 云应用程序
由 Atlassian 开发的适用于我们云产品的Marketplace应用程序目前不易受到任何已知的 CVE-2022-22965 漏洞的攻击。出于谨慎考虑，Atlassian 使用受影响的 Spring 版本开发的 Marketplace 云应用程序将作为优先事项进行修补，以防发现新的攻击媒介。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cae3453504ea8bb7057ac8496c217f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b77eb4ac05eb442b871a6e0f1bb88f/" rel="bookmark">
			联想L440笔记本 ，如何开启虚拟化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先重启电脑，在开机前一直按F1 进入BIOS（不同电脑的按键可能不同）；
然后 找到Security选项下的 Virtualization,enter进入；
将Intel Virtualization Technology 和 Intel VT-d 都enter下 改为Enabled；
最后按F10 -&gt;yes 之后会重启电脑，虚拟化开启了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dbcbae15320613c570dac5212f8fe7b/" rel="bookmark">
			微信小程序开发 编译后 保留在当前页面 的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 配置：
编译模式中，选择添加编译模式配置编译后停留的页面 保存后，在编译模式下拉中，选中即可 。 ------- 选中后，即可跳转到编译后停留的页面。每次编译后都会显示该页面修改、删除。选中编辑按钮/icon后，可在编辑弹窗中进行修改 / 删除。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d661a4be34ed924947f4b690c70506/" rel="bookmark">
			ASAN内存校验器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简介ASAN原理 2. DemoUAFHeapOutOfBoundsStackOutOfBoundsuseAfterReturnuseAfterScopec++静态初始化顺序问题内存泄露 3. 其它参考文章 1. 简介 Windows wdk提供了verifier校验器，用于排查内存泄漏等不好发现和定位的问题。
Linux上的校验器就比较多了，如：
Dr.Memory， 检测未初始化的内存访问、double free、use after free 等错误；Mudflap， 检测指针的解引用，静态插桩；Insure， 检测内存泄漏；Valgrind, 慢；ASAN，本文主角。 如果只是检测 memcpy/memset/strcpy 危险函数，可以使用 _FORTIFY_SOURCE机制。
Google的ASAN（AddressSanitizer）应该是最给力的，结合编译器插桩和运行时快速内存检测，包括缓冲区溢出、空指针引用、野指针、Double Free等。
ASAN 不支持检测【使用未初始化的内存】，MSAN（MemorySanitizer）可以。Google其实是提供了一整套校验程序。
项目地址：https://github.com/google/sanitizers
工具原理wiki介绍得很详细。本问主要记录一下ASAN的用法。
ASAN原理 AddressSanitizer is a part of LLVM starting with version 3.1 and a part of GCC starting with version 4.8。
ASAN由两部分组成：
编译时插桩模块；运行时库，替换一些内存操作函数，比如用__asan_malloc替换malloc。 检测原理是在变量的左右内存区域下毒，这些区域又叫雷区/redzone：
void *__asan_malloc(size_t sz) { void *rz = malloc(RED_SZ); // 上接雷区 Poison(rz, RED_SZ); void *addr = malloc(sz); // 真正分配的内存 UnPoison(addr, sz); rz = malloc(RED_SZ); // 下接雷区 Poison(rz, RED_SZ); return addr; // 返回分配的内存首地址 } 内存空间会被划分为以下两个类别：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d661a4be34ed924947f4b690c70506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4672e7ee43ed49a10d9fcc6423cb2d9/" rel="bookmark">
			ElementPlus的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.安装element-plus框架
npm install element-plus 2.全局引入：在main.js文件中引入element plus组件
import { createApp } from 'vue' import App from './App.vue' import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' import router from "@/router"; import './assets/css/global.css' createApp(App).use(ElementPlus).use(router).mount('#app') 使用提示框时，要在使用的组件中引入
import { ElMessage } from 'element-plus' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0b9c2e461bad979f9c997667a3b87a6/" rel="bookmark">
			Realsense-D455的IMU在ubuntu18.04使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一。配置realsense-ros: 已经新建了ROS工作空间，可以直接在工作空间的src目录下克隆相关功能包，然后进行编译，具体命令参考下方：
1、已建好工作空间Realsense_D435i:
cd Realsense_D435i/src
git clone -b 2.2.11 https://github.com/IntelRealSense/realsense-ros.git
git clone https://github.com/pal-robotics/ddynamic_reconfigure.git
原文链接：https://blog.csdn.net/hltt3838/article/details/120691764
2.完成上述步骤后，使用以下命令进行测试：
cd Realsense_D435i
catkin_make
source devel/setup.bash
roslaunch realsense2_camera rs_camera.launch
3.打开新的终端查看节点：
rostopic list
可以看到，只有图片信息的话题，！！！！！！！！！！！！！！！！没有IMU信息的话题，因为这是原launch文件中默认的！！！！！！，想要打开IMU 信息话题，需要在相应的launch文件作修改，因此不建议使用一键安装realsense-ros方法 https://blog.csdn.net/weixin_50508111/article/details/121087220 。
二。打开IMU话题 针对相机的各种配置参数，通过 /realsense-ros/realsense2_camera/launch/rs_camera.launch 文件传给ROS系统。
将rs_camera.launch 复制了一份命令成lee_test.launch,在其中更改打开IMU话题的相关命令。
设备默认打开深度图，深度自信度，RGB图像，关闭IMU数据，
在这里将最后两个标识符设置为true，即可打开陀螺仪和加速计的数据流。删除build和devel文件重新catkin_make编译一下，使用命令：roslaunch realsense2_camera lee_test.launch 打开，报错
原因是没有添加环境变量，有俩个方法
(1.)添加: echo “source ~/Realsense_D435i/devel/setup.bash” &gt;&gt; ~/.bashrc source ~/.bashrc (2.)终端输入：cd Realsense_D435i source devel/setup.bash
成功打开
realsense d455在ROS中发布的IMU数据分红了两个：
“/camera/gyro/sample” 发布角速度 “/camera/accel/sample” 发布线加速度app 同时这两个的时间戳也不太同样，在launch文件中的频率也不同：
&lt;arg name="gyro_fps" default="400"/&gt; &lt;arg name="accel_fps" default="250"/&gt; 设置同步选项，以下部分参考自https://blog.csdn.net/weixin_46363611/article/details/114643088
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0b9c2e461bad979f9c997667a3b87a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15138effeca83acb8cd4bbfffeca8a12/" rel="bookmark">
			Django和Vue实现登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django后端连接数据库实现登录
import jwt import json import datetime from django.views import View from django.http import JsonResponse class denglu(View): def post(self,request): z=json.loads(request.body) s=warehouse.objects.filter(users=z['input1'],password=z['input2']).values() if s: dic = { 'exp': datetime.datetime.now() + datetime.timedelta(days=1), # 过期时间 'iat': datetime.datetime.now(), # 开始时间 'iss': 'lianzong', # 签名 'data': { # 内容，一般存放该用户id和开始时间 'a': 1, 'b': 2, }, } s1 = jwt.encode(dic, 'secret', algorithm='HS256') # 加密生成字符串 return JsonResponse({'data': s1,'code':200,'message':'登录成功'}) else: return JsonResponse({'code': 400,'message':'密码或用户名错误'}) vue通过点击事件执行denglu()，把输入的数据发送给后端，后端判断数据库中是否存在，存在则返回jwt将jwt保存到本地，不存在则返回密码或用户名错误。
async denglu(){ var z=await this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15138effeca83acb8cd4bbfffeca8a12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e89852414c72294a8c184709fb8ddc2/" rel="bookmark">
			Spring第14篇：lookup-method和replaced-method比较陌生，怎么玩的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lookup-method：方法查找 通常情况下，我们使用的bean都是单例的，如果一个bean需要依赖于另一个bean的时候，可以在当前bean中声明另外一个bean引用，然后注入依赖的bean，此时被依赖的bean在当前bean中自始至终都是同一个实例。
先来个案例回顾一下 package com.javacode2018.lesson001.demo13.normal; public class ServiceA { } package com.javacode2018.lesson001.demo13.normal; public class ServiceB { private ServiceA serviceA; public ServiceA getServiceA() { return serviceA; } public void setServiceA(ServiceA serviceA) { this.serviceA = serviceA; } } 上面2个类，ServiceA和ServiceB，而ServiceB中需要用到ServiceA，可以通过setServiceA将serviceA注入到ServiceB中，spring配置如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"&gt; &lt;bean id="serviceA" class="com.javacode2018.lesson001.demo13.normal.ServiceA" scope="prototype"/&gt; &lt;bean id="serviceB" class="com.javacode2018.lesson001.demo13.normal.ServiceB"&gt; &lt;property name="serviceA" ref="serviceA"/&gt; &lt;/bean&gt; &lt;/beans&gt; 上面serviceA的scope是prototype，表示serviceA是多例的，每次从容器中获取serviceA都会返回一个新的对象。
而serviceB的scope没有配置，默认是单例的，通过property元素将serviceA注入。
来个测试案例，如下：
package com.javacode2018.lesson001.demo13; import com.javacode2018.lesson001.demo13.normal.ServiceA; import com.javacode2018.lesson001.demo13.normal.ServiceB; import org.junit.Test; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e89852414c72294a8c184709fb8ddc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4f9a5d48e82e12d97b41a48cfa9eacf/" rel="bookmark">
			Vue前端框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web应用分类： 1.传统Web页面2.单页应用 1.传统Web页面 1.H5（不等同于HTML5） 一般称之为H5页面（营销页面）
即：在传统的平面海报中增加交互体验和数据存储，用于营销推广和数据信息收集等
2.传统技术特点： .单击某个链接，按钮或提交表单后，页面整体刷新
3.传统技术缺点： 1.每次页面整体刷新，都要导致浏览器重新加载对应的内容2.加载内容繁多，传统页面的css/js多达上百个，每次打开页面都需要发送上百次请求，卡顿现象严重 2.单页应用（Single Page App,SPA） 1.整个应用只有一个主页面，其余的“页面”，实际上是一个个的“组件”2.单页应用中的“页面跳转”，实际上是组件的切换，在这个过程中，只会更新局部资源，页面不会整个刷新（正是因为这个原因，当我们的前端代码有更改，重新部署之后，如果用户不主动刷新，就会发现有“资源缓存”） 1.单页应用特点 1.页面是局部刷新的，响应速度快，不需要每次加载所有的资源2.前后端分离，前端不受后端的限制 2.单页应用框架 1.Angular 1.特点 1.业内第一个SPA框架2.实现了前端的MVC解耦3.双向绑定，Model层的数据变化会直接影响View,反之亦然 2.缺点 不易学习，文档差
2.React 1.特点 1.使用js一种语言就可以写前端(H5)+后端2.React Native可以直接运行在手机端，性能接近原生APP3.可使用组件多 2.缺点 1.html代码需要写在js文件中，前后端代码写在一起的风格2.多语言混合式编程，代码难以理解，开发和调试 3.Vue 1.特点 1.基于MVVM（Model-View-ModelView）的SPA框架 View：视图Model：数据ModelView：连接View与Model的纽带 2.Vue.js和微信小程序，阿里巴巴的Weex相似 3.Ajax和XML 1.概述 1.Ajax（Asynchronous JavaScript And XML）：异步js与XML2.Ajax名称本意是：异步js与XML，但是现在服务器端返回的数据几乎都使用JSON，而抛弃了XML3.Ajax每次打开新的网页时，页面不会整体刷新，而是由js发起一个HTTP异步请求 2.特点 1.节省页面加载时间2.节省了带宽3.减轻客户端和服务器端的负担 Vue Vue (读音类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架
1.构建用户界面：将数据通过某种方式展示到前端页面2.渐进式：Vue可以自底向上逐层的应用，由浅入深，由简单到复杂（即：如果简单应用只需要引入一个轻量小巧的核心库，复杂应用可以根据需要引入各式各样的Vue插件，从一个轻量小巧的核心库逐渐递进到各式各样的Vue插件库） 简介 1.尤雨溪开发的一款轻量级框架2.2015年正式发布Vue1.0.03.2016年正式发布Vue2.0.04.2020年正式发布Vue3.0.0 特点 1.采用组件化模式，提高代码复用率，且让代码更好维护2.声明式编码，无需直接操作DOM，提高开发效率//命令式编码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;原生JavaScript&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="list"&gt;&lt;/ul&gt; &lt;script type="text/javascript"&gt; // 需要展示的数据 let persons = [ {id: '001',name: '张三', age: 18}, {id: '002',name: '李四', age: 19}, {id: '003',name: '王五', age: 20}, ] //准备html字符串 let htmlStr = '' //遍历数据拼接html字符串 persons.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4f9a5d48e82e12d97b41a48cfa9eacf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3f023b89bacbe7fe1d01caa77605aa/" rel="bookmark">
			HTML5 第一章 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、HTML介绍及其工具 www：world wide web 万维网 互联网
定义：将所有连入次网络的电脑实现数据交互（HTML文件交互）
组成：url：统一资源定位器（网址、域名、ip地址）
http：超文本传输协议
html：hyper text markup language 超文本标记语言
w3c组织负责维护和发布web标准，由三个部分组成
html标准 html5 css标准 层叠样式表 javasrcipt标准 脚本语言
二、HTML常用标签 HTML页面是由若干个标签组成的，学习HTML语言其实就是学习各个标签
按个分类：双标签 单标签
1.h1---h6标题标签 作用：加粗，大小
属性：align对齐方式 取值left center right
2.p标签 段落标签 修饰当前是一段正文
属性：algin对齐方式
style标签样式
title 文字提示
3.br 换行标签 单标签
4.hr 水平线标签
属性：align 对齐方式
width宽度 size高度（使用像素为单位） color 颜色 取值：关键字 red blue grenn yellow black white puple 16进制表示法
5.b、strong 加粗标签
6.img图片标签
属性：src图片路径 注意：一定将显示图片放置在页面的旁边
width宽度 height高度 align：控制旁边文字对齐方式 top垂直向上 middle中 bottom下 left左
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b3f023b89bacbe7fe1d01caa77605aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477b0bd912ffbe2b717091b9f444b923/" rel="bookmark">
			网络七层协议结构分析图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、网络七层协议结构图详解二、TCP和UDP的区别1.TCP（打电话）1.连接稳定2.客户端，服务端3. 传输完成，释放连接，效率低，4. 三次连接四次挥手1.三次连接2.四次挥手 2.UDP（发短信）1.连接不稳定2.客户端，服务端，没有明确的界限3.不管有没有准备好都可以发送 前言 提示：以下是本篇文章正文内容，下面案例可供参考
一、网络七层协议结构图详解 二、TCP和UDP的区别 1.TCP（打电话） 1.连接稳定 2.客户端，服务端 3. 传输完成，释放连接，效率低， 4. 三次连接四次挥手 1.三次连接 A：你愁啥？(客户端发送请求连接)
B：瞅你咋滴了？（服务端收到客户端的请求连接后响应并确定请求是否存在）
A：来干一架！（客户端和服务端相互确认后建立连接）
2.四次挥手 A：我要走了！
B：你真的要走了吗？
B：你真的，真的要走了！
A：我真的要走了！
2.UDP（发短信） 1.连接不稳定 2.客户端，服务端，没有明确的界限 3.不管有没有准备好都可以发送 优质文章推荐java[参考文档]
https://blog.csdn.net/m0_67929156/article/details/123963794?spm=1001.2014.3001.5501.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba3f32a1de7633bd736bc045a141ded/" rel="bookmark">
			SEERC2018 Broken Clock
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SEERC2018 Broken Clock Problem Statement 时针, 分针, 秒针的程度分别为 A , B , C A,B,C A,B,C, 并且假设时钟共有 N N N个时刻. 并且由于时钟被破坏时针, 分针和秒针可以指向任意一时刻, 问时针, 分针和秒针能够形成多少个包含时针中心的三角形.
Solution 我们考虑三角形的生成函数. 假设时针分针和秒针组成三角形的三条边分别为 a , b , c a,b,c a,b,c, 那么他们所对应的圆心角应该有 θ 1 + θ 2 + θ 3 = 2 π \theta_1+\theta_2+\theta_3=2\pi θ1​+θ2​+θ3​=2π. 由于 N N N个时刻, 每个时刻所对应圆心角相等, 所以角度有 N N N等分. 当然由于包含时针中心且能组成三角形那么 2 π N ≤ θ 1 , θ 2 , θ 3 ≤ π \frac{2\pi}{N}\leq\theta_1,\theta_2,\theta_3\leq\pi N2π​≤θ1​,θ2​,θ3​≤π.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cba3f32a1de7633bd736bc045a141ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/883b424320a158146180683ac0e4fce5/" rel="bookmark">
			升级 IDEA 2021 lombok 报错 You aren‘t using a compiler supported by lombok
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景： 由于 IDEA 版本过旧，导致有些插件使用不了，于是索性直接升到最新版本 IDEA 2021.3.1，升级后编译代码，发现编译不过，详细的报错信息如下：
java: You aren't using a compiler supported by lombok, so lombok will not work and has been disabled. Your processor is: com.sun.proxy.$Proxy27 Lombok supports: sun/apple javac 1.6, ECJ 从提示信息可以看得出是 lombok 不工作了，导致一些 get set 方法不存在，导致编译不通过
解决方案： 方案一：
lombok 的版本可能过旧，可以尝试升级 lombok 到最新版本，当前最新版本为
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 或者直接到 官网 查看最新版本是多少，自己引入需要的版本
方案二：
如果实在不想升级lombok，当然也可以设置一下 IDEA 的编译的 VM 餐宿，只要在下图的位置添加：
-Djps.track.ap.dependencies=false 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bb42e356b66a3af834b494dffe37b7/" rel="bookmark">
			EL1007E: Property or field ‘username‘ cannot be found on null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 出现如下报错：
2022-04-13 22:14:24.738 ERROR 20160 --- [nio-8081-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateProcessingException: Exception evaluating SpringEL expression: "session.loginUser.username" (template: "index" - line 49, col 37)] with root cause org.springframework.expression.spel.SpelEvaluationException: EL1007E: Property or field 'username' cannot be found on null 这是因为thymeleaf取对象时，要求判断该对象不为空，故在对象前加入“？”再用”.“调用属性 。
错误的格式：
&lt;li&gt;&lt;span&gt;欢迎您，[[${session.loginUser.username}]]&lt;/span&gt;&lt;/li&gt; 正确的格式为：
&lt;li&gt;&lt;span&gt;欢迎您，[[${session.loginUser?.username}]]&lt;/span&gt;&lt;/li&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/512f7a1470e6f2c1f7f7ce87c6171c59/" rel="bookmark">
			http-server使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http-server简介 http-server是一个简单的零配置命令行http服务器。 它足够强大，足以用于生产用途，但它既简单又易于破解，可用于测试，本地开发和学习。
当我们想要在服务器运行一些代码，但是又不会配置服务器的时候，就可以使用http-server就可以搞定了。
应用场景 任意设备通过局域网访问本机静态页面本机静态页面跨域请求服务器api接口验证前端页面是否打包正常能正常访问 安装 1、安装nodejs环境
2、利用npm安装http-server
npm install http-server -g 使用 把你想要作为服务器的文件夹用终端打开，运行如下命令
http-server 参数选项说明 命令描述默认值-p或--port要使用的端口。用于-p 0查找从 8080 开始的开放端口。8080-a要使用的地址0.0.0.0-d显示目录列表true-i显示自动索引true-g或者--gzip启用后，它将./public/some-file.js.gz代替./public/some-file.js当文件的gzip压缩版本存在且请求接受gzip编码时。false-b或者--brotli启用后，它将./public/some-file.js.br代替./public/some-file.js文件的 brotli 压缩版本存在并且请求接受br编码时提供服务。如果 gzip 也被启用，它会首先尝试提供 brotli。false-e或者--ext如果没有提供默认文件扩展名html-s或者--silent禁止输出中的日志消息--corsAccess-Control-Allow-Origin通过标头启用 CORS-o [path]启动服务器后打开浏览器窗口。（可选）提供要打开的 URL 路径。例如：-o /其他/目录/-c为缓存控制 max-age 标头设置缓存时间（以秒为单位），例如-c1010 秒。要禁用缓存，请使用-c-13600-U或者--utc在日志消息中使用 UTC 时间格式。--log-ip启用客户端 IP 地址的日志记录false-P或者--proxy代理所有无法在本地解析到给定 url 的请求。例如：-P http://XXXX.com--proxy-options使用嵌套的虚线对象传递代理选项。例如：--proxy-options.secure false--username基本身份验证的用户名--password基本认证密码-S,--tls或--ssl启用使用 TLS/SSL (HTTPS) 的安全请求服务false-C或者--certssl 证书文件的路径 cert.pem-K或者--keyssl 密钥文件的路径 key.pem-r或者--robots自动提供一个 /robots.txt （其内容默认为User-agent: *\nDisallow: /）false-h或者--help打印此列表并退出。--no-dotfiles不显示点文件--mimetypes用于自定义 mimetype 定义的 .types 文件的路径-v或者--version打印版本并退出。 本文来源：http-server使用手册 | 猿小莫的博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1ffb0b840263d66652302ec43fed4b/" rel="bookmark">
			四种权限修饰符的相关介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录​​​​​​​ priavte(私有的)
default默认（缺省）（没有修饰符）：
protected(受保护的)：
public(公共的) ：
四种权限修饰符的访问权限
四种权限修饰符:private(私有的) , default默认(缺省) , protected(受保护的) , public(公共的) priavte(私有的) priavte(私有的)相关详细介绍在这里 ------&gt; 这里这里!
default默认（缺省）（没有修饰符）： 它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问.
protected(受保护的)： ​ 当前类或子类可以访问，同时相同包内的其他类也可以访问protected成员；它主要的作用就是用来保护子类的。
public(公共的) ： ​ 它具有最大的访问权限，可以访问任何一个在CLASS PATH下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。
四种权限修饰符的访问权限 在同一个类当中使用public、protected、（default）、private修饰的成员变量或者成员方法，都可以直接访问或调用类中的成员变量或者成员方法在同一个包中的两个不同类时，使用public、protected、（default）修饰的成员变量或者成员方法，可以直接访问或调用两个类中的成员变量或者成员方法在某一个类和不同包的子类，使用public、protected修饰的成员变量或者成员方法，可以直接访问或调用两个类中的成员变量或者成员方法在某一个类和不同包的非子类中，使用public修饰的成员变量或者成员方法，可以直接访问或调用两个类中的成员变量或者成员方法 总结:
访问控制修饰符同类同包不同包子类不同包非子类private√default(默认)√√protected√√√public√√√√ 奉上图图:
(小编也在努力学习更多哟!以后会多多分享哒!) 希望对友友们有所帮助!!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edfd229304634479ac586e61dcb85006/" rel="bookmark">
			MySQL----多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL----多表查询 多表关系表与表之间的联系：一对多(多对一)多对多一对一 多表查询多表查询的分类数据准备内连接外连接自连接联合查询子查询标量子查询列子查询行子查询表子查询 多表查询案例 多表关系 在进行数据库表结构的设计时，会根据业务的需求和业务模块之间的关系，分析设计表结构，由于业务之间相互关联，所以各个表结构之间也存在各种联系
表与表之间的联系： 1.一对多(多对一)
2.多对多
3.一对一
一对多(多对一) 例如，一个员工对应一个部门，一个部门可以对应多个员工
一般在多的一方创建外键，指向一的那一方
员工与部门，在员工表上设置外键，指向部门表
多对多 例如，一个学生可以选修多门课程，一个课程可以被多名学生选修
一般会建立第三张表，至少包含两个外键，分别指向两张表的主键
一对一 例如，用户和自己的学历信息的关系，一个人只对应一条学历信息
可以在任意一方加入外键，关联另一方的主键，并且设置外键为唯一(unique)
注：可以放在一张表中，但是对其进行拆分，一张表放基础信息，另一张表放详情，可以提升操作效率
多表查询 概述：
从多张表中查询数据
笛卡尔积：
笛卡尔积为两个集合(两张表)中的每条数据进行两两组合的结果
在多表查询时会产生笛卡尔积，要通过添加条件消除笛卡尔积
dept表：
emp表：
查询产生笛卡尔积的结果：
select * from emp, dept ; 消除笛卡尔积(添加条件)：
select * from emp, dept where emp.dept_id=dept.id; 多表查询的分类 1.连接查询：
内连接： 相当于查询AB的交集部分 外连接： 左外连接： 查询A的所有数据，同时拼接上B对应的数据 右外连接： 查询B的所有数据，同时拼接上A中对应的数据 自连接： 表与自身连接查询 自连接必须给表取别名 2.子查询
数据准备 部门表：
create table dept ( id int auto_increment primary key comment 'id', name varchar(50) not null comment '部门名称' ) comment '部门表'; insert into dept (id, name) values (1, '研发部'), (2, '市场部'), (3, '财务部'), (4, '销售部'), (5, '总经办'), (6, '人事部'); 员工表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edfd229304634479ac586e61dcb85006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/117d9598e9710fe943dfe7222b98bd69/" rel="bookmark">
			单页应用首屏加载速度慢怎么解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是首屏加载时间？ 首屏加载时间是指浏览器从相应用户输入网址到首屏内容渲染完成的时间，从用户的角度来说就是：“地址栏输入网址之后网页呈现的速度”。整个网站并不需要全部加载完成，但需要展示当前可视窗口中的内容。
2、如何计算首屏加载时间？ 常用方法：
首屏模块标签标记法统计首屏内加载最慢的图片的时间自定义首屏内容计算法借助第三方工具（pagespeed、vue-cli等等） 其实很简单，并不需要我们手动去计算。打开F12控制台，然后刷新网页，其中Load就是首屏加载时间。
3、首屏加载速度慢的原因 在页面渲染的过程，导致加载速度慢的因素可能如下
网络延时问题资源文件体积是否过大问题资源是否重复发送请求去加载问题加载脚本的时候，渲染内容堵塞问题 4、解决方案 路由懒加载 以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定路由的时候才会加载对应的路由组件。
静态资源本地缓存 前端合理使用localStorage，sessionStorage等缓存方式。 接口采用http缓存，合理设置cache-control等请求头。
图片压缩 像一些icon图标，我们并不需要在本地存放一张张的图片，可以用在线字体图标代替，或者将多个图标合并到一张图上，以减轻请求压力。
webpack处理图片常用依赖：
file-loader：在css 和html 主页中，相对路径的图片都会被处理，发布到输出目录中
url-loader：是对file-loader的封装，因此在安装了file-loader和url-loader 后，在webpack.config.js 中只对url-loader 做配置即可。url-loader的自身功能是给图片一个limit 标准，当图片小于limit时，使用base64 的格式引用图片；否则，使用url 路径引用图片。
image-webpack-loader：压缩图片。这个用得不算太多，因为前期可以直接让UI设计把图片压缩好，像ps 就可以自动的批量压缩图片。
减少重复请求 像一些表单提交或者长列表，合理使用防抖节流，以减少不必要的请求，减轻服务器压力。
UI框架按需加载 借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的
开启GZip压缩 代码优化 1.v-if 和 v-show 的合理使用
2.使用v-for的时候为item设置唯一key值
3.细分vuejs组件
4.减少watch的数据
使用SSR服务端渲染 SSR（server side render），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器。
SSR技术会实现将指定的异步数据在服务端渲染好，再返回给客户端，这样就减轻了客户端的请求异步数据的压力，渲染页面就更快了。
vue可使用Nuxt.js框架实现服务端渲染react多采用koa2等技术的实现方案。 使用CDN 使用CDN主要解决两个问题：
① 打包时间太长、打包后代码体积太大、请求慢
② 服务器网络不稳定带宽不高，使用cdn刻意回避服务器贷款问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c6470d1e375119fc13891e682b0f1af/" rel="bookmark">
			深度学习head、neck、backbone三个术语分别是指什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.backbone：是主干网络，是提取特征的网络，这些网络经常使用的是resnet18，Darknet53等，通常不是我们自己设计的网络，因为这些网络已经证明了在分类等问题上的特征提取能力是很强的。在用这些网络作为backbone的时候，都是直接加载官方已经训练好的模型参数，后面接着我们自己的网络。让网络的这两个部分同时进行训练，因为加载的backbone模型已经具有提取特征的能力了，在我们的训练过程中，会对他进行微调，使得其更适合于我们自己的任务。
2.head：检测头，主要用于预测目标的种类和位置(bounding boxes)，利用之前提取的特征，做出预测。
3.neck:是放在backbone和head之间的，是为了更好的利用backbone提取的特征
简而言之，基于深度学习的目标检测模型的结构是这样的：backbone-&gt;neck-&gt;head-&gt;输出。backbone主干网络提取特征，neck脖子提取一些更复杂的特征，然后head头部计算预测输出
参考文献：链接：https://www.jianshu.com/p/014e76d3b614
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf50280f1d048f261960812fac0f0f9d/" rel="bookmark">
			CUDA error: invalid device ordinal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用服务器进行单机多卡数据并行训练的时候，出现了一个小问题，本来以为可以直接创建4个process，可以4路数据并行，结果运行时发现报以下错：
RuntimeError: CUDA error: invalid device ordinal 原因：当前设备的GPU数量与cuda数量不匹配，
解决方案：
（1）先使用nvidia-smi命令查看服务器GPU数量
nvidia-smi 比如我这里看了一下，只有两张1080 Ti的卡
（2）根据GPU的数量改以下代码里的进程数量
（3）运行成功
#这里是调用cuda设备(GPU) device = torch.device("cuda:{}".format(rank)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9272950e8bdf2fa147965176c083c595/" rel="bookmark">
			#入门级七层架构（了解网络基础知识）实测易懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSI七层模型介绍易懂版 看了很多大神写的网络七层架构，小编自己觉得实在是让我这种入门级的小白有点难懂，小编用新人的角度去编写较为简单点的方式，带领小白们共同学习网络七层架构，不喜勿喷。
OSI七层模型介绍
首先OSI是开放式系统互连通信的参考模型，是一种概念模型，由国际标准化组织提出，主要作用就是试图使各个计算机在世界范围内互连为网络的标准框架。它有三个基本功能：提供给开发者一个必须的、通用的概念以便开发完善、可以用来解释连接不同系统的框架。（简单来说它就是一个基本的国际网络标准协议，也是开放式系统互联参考的模型）
下面介绍一下OSI的7层模型
第一层 物理层，是参考模型中的最底层，主要定义了系统的电气、机械、过程和功能标准。如：电压、物理数据速率、最大传输距离、物理联接器和其他的类似特性。物理层的主要功能是利用传输介质为数据链路层提供物理联接，负责数据流的物理传输工作。物理层传输的基本单位是比特流，即0和1，也就是最基本的电信号或光信号，是最基本的物理传输特征。
第二层 数据链路层，它就是把之前的传送数据分帧，并处理流控制。然后通过特定的拓扑结构（不懂得可以百度哈，反正就是按不同形状分类，什么星型啦等等）来提供硬件的寻址，也就是我们知道MAC地址。简单来说就像邮局里的装拆箱工人，分类运输。
第三层 网络层，主要为数据在节点之间传输创建逻辑链路，通过路由选择算法为分组选择最佳路径，从而实现拥塞控制、网络互联等功能。网络层是以路由器 的最高节点俯瞰网络的关键层，它负责把分组从源网络传输到目标网络的路由选择工作。互联网是由多个网络组成在一起的一个集合，正是借助了网络层的路由路径选择功能，才能使得多个网络之间的联接得以畅通，信息得以共享。网络层提供的服务有面向联接和面向无联接的服务两种。面向联接的服务是可靠的联接服务，是数据在交换之前必须先建立联接，然后传输数据，结束后终止之前建立联接的服务。网络层以虚电路服务的方式实现面向联接的服务。面向无联接的服务是一种不可靠的服务，不能防止报文的丢失、重发或失序。面向无联接的服务优点在于其服务方式灵活方便，并且非常迅速，网络层以数据报服务的方式实现面向无联接的服务。
第四层 传输层，提供给终端到终端的可靠链接（也就是我们要去了解的TCP和UDP两种协议），传输层网络体系结构中高低层之间衔接的一个接口层。传输层不仅仅是一个单独的结构层，而是整个分析体系协议的核心。传输层主要为用户提供End—to—End(端到端)服务，处理数据报错误、数据包次序等传输问题。传输层是计算机通信体系结构中关键一层，它向高层屏蔽了下层数据的通信细节，使用户完全不用考虑物理层、数据链路层和网络层工作的详细情况。传输层使用网络层提供的网络联接服务，依据系统需求可以选择数据传输时使用面向联接的服务或是面向无联接的服务
第五层 会话层，允许用户使用简单易记的名称建立连接，相当于收取快递的人收取、寄快递和拆快递的人。
第六层 表示层，协商数据交换格式 相当公司中简报老板、替老板写信的助理。
第七层 应用层，是直接面向用户的一层，用户的通信内容要由应用进程解决，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，并且保证这些不同类型的应用所采用的低层通信协议是一致的。应用层中包含了若干独立的用户通用服务协议模块，为网络用户之间的通信提供专用的程序服务，比如微信、QQ等聊天软件。
上面简单的介绍了一下ISO七层模型，相信大家也能有个基础认识，下面我会继续更新，跟大家一起继续学习新的网络知识。
我会继续更新，跟大家一起共同学习新的网络知识，希望各位持续关注小编继续更新，谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146674c26a26393f3341dc8660ca7624/" rel="bookmark">
			bat命令 获取当前盘符 路径 写环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批处理命令获取当前盘符和当前目录 当前盘符：%~d0
当前路径：%cd%
当前执行命令行：%0
当前bat文件路径：%~dp0
当前bat文件短路径：%~sdp0
其他命令 echo 打印字符串
set name=%~d0 变量赋值 调用 %name%
cd 切换当前工作路径
cd .. 切换为当前工作路径的父目录
pause 防止dos窗口关闭
start "" "目录或文件" 打开指定文件夹或文件
start D:\软件\Notepad++7.7.1\notepad++.exe "D:\test.txt"
start 打开文件的应用程序路径及名称 "被打开的文件路径及名称"
rem 注解
rem lss表示小于
rem [not]为可选参数,表示非,即如果变量num1不小于变量num2就输出第一个数字大,否则输出第二个数字大
if语句 if not %num1% LSS %num2% ( echo 第一个数字大 ) ELSE ( echo 第二个数字大 ) 比较运算符 EQU - 等于 NEQ - 不等于 LSS - 小于 LEQ - 小于或等于 GTR - 大于 GEQ - 大于或等于 //第一个例子 set /p num1=请第一个输入数字: set /p num2=请第二个输入数字: if not %num1% LSS %num2% ( rem lss表示小于 rem [not]为可选参数,表示非,即如果变量num1不小于变量num2就输出第一个数字大,否则输出第二个数字大 echo 第一个数字大 ) ELSE ( echo 第二个数字大 ) pause&gt;nul //第二个例子 set /p num1=请第一个输入数字: set /p num2=请第二个输入数字: if "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/146674c26a26393f3341dc8660ca7624/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/885bf86ca2c043c2a1924908cf0a40a2/" rel="bookmark">
			Swin Transformer理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在阅读transformer，也作个笔记，供学习使用。希望阅读者有CNN的基础，如YOLO,MobileNets，ResNet等,并且一定要先阅读ViT。不然读起来可能比较吃力。当然笔记也尽可能解释清楚
1 核心参考 ① B站跟李沐学AI
② Swin Transformer论文精读【论文精读】
友情提示：看完笔记，还需要阅读原文，去看代码，才会有大的收获。
2 研究背景：ViT的缺点 1、显存占用–Token数量。Token是指模型运行中的最小处理单元。ViT中的Token指的是一个Patch，Token的数量就是Patch的数量。那Patch又是什么呢？就是一张图片被切分成9小片，那么每一小片就是一个Patch。所以这里Token=Patch=小片。Pacth大小固定的情况下，分辨率越高，Patch的数量越多；分辨率固定的情况下，Patch大小越大，Patch的数量越少。
2、表示方法–Token应该多大。这里其实不确定，在论文PVT中发现图像内容越简单，倾向于Token越大；内容越复杂，倾向于Token越小。但是在其他任务中可不可以也这样理解，其实不太确定，Token应该多大，怎么表示？如果不太确定，是不是该用金字塔结构？注：但是 后面几句话不太理解也没关系，不影响本文阅读。
3、难以用在下游任务（检测、实例分割，语义分割）。Patch大小越小-&gt;Token数量越多-&gt;MHA复杂度越高-&gt;显存资源不足；Patch大小越大-&gt;Token数量越少-&gt;Feature Map分辨率越低-&gt;下游任务性能越差。所以需要控制MHA的复杂度，以便使用金字塔结构。注：再次提醒要先阅读ViT,再来看该篇论文。
3 研究意义 这是第一篇广泛接受的在下游任务中使用纯Transformer结构的方式；后续有非常多的工作都是在Swin Transformer的基础上做的
4 摘要 1、本文提出一种可以适用于多种任务的backbone（特征提取网络）-&gt;swin transformer（swin: shifted windows结合:移动窗口）
2、Transformer在CV中运用有两个难点：物体尺度不一，图像分辨率大（在NLP中，单词的数量少，而图像中像素却很多，如果单纯把transformer运用到CV中，会面临像素点爆炸问题，计算的复杂度也会异常大）
3、使用分层结构Shifted windows解决物体尺度不一
4、限制attention计算使得能够在高分辨率上运行
5、在多种任务中运用都很好
5 引言 Swin Transformer的研究动机是让Transformer作为一个通用的骨干网络（backbone）。在ViT中把图片打成Patch，其中Patch Size为16×16。所以图中(b)的16×也就是16倍下采样率，也就意味着每一个Patch(token)，它至始自终代表的尺寸是差不多的，每一层的Transformer block看到token的尺寸都是16倍下采样率。虽然它可以通过全局的自注意力的操作来达到全局建模能力，但是它对多尺寸的特征把握就会弱一点。但是我们知道，多尺寸的特征对于下游任务是非常重要的，比如目标检测中的FPN，通过不同尺寸的特征融合，从而能够很好的处理物体不同尺寸的问题。而在ViT中，它处理的特征都是单一尺寸，而且是low resolution。也就是说自始至终都是处理16倍下采样过后的特征，也就意味着ViT不适合处理密集预测型的任务，同时对于ViT而言，它的自注意力始终在最大窗口（整图，图中红框）上进行的，即它是一个全局建模，也就是说它的复杂度是跟图像的尺寸进行平方倍的增长。之前虽然Patch Size为16×16能处理224×224的图片，但是图像尺寸为800×800，即使用Patch Size为16×16，序列的长度依旧很长，这个计算复杂度还是很难承受的。
所以，基于这些挑战，作者提出了Swin Transformer,文章其实是借鉴了很多CNN的设计理念以及它的先验知识。比如，为了减少序列长度，降低计算复杂度，文章中采取小框（图中蓝框）之内计算自注意力，而不是像ViT，在整图上去算自注意力。这样只要窗口大小固定，自注意力的计算复杂度就是固定的，那整张图的计算复杂度就会跟这张图片大小而成线性增长关系，即假如图片增大了x倍，那么窗口的数量也就增大了x倍，那么计算复杂度也就是乘x,而不是乘x的平方。那这个其实就是利用了CNN的Locality的Inductive Bias,也就是局部性的先验知识。就是说同一物体的不同部位，或者语义相近的不同物体，还是大概率会出现在相连的地方。所以，我在一个local，一个小范围的窗口，去算自注意力也是差不多够用的。全局去算自注意力，对于视觉任务来说，其实是有点浪费资源的。
那么另外一个挑战，就是如何去生成多尺寸的特征呢？CNN主要采用pooling池化操作，池化操作能够增大卷积层能看到的感受野，从而使每次池化后的特征去抓住物体的不同尺寸。Swin Transformer也提出一个类似池化的操作，叫做Patch merging,就是把相邻的小patch合成一个大patch，那这样合并成的一个大patch就能看到之前小patch看到的内容，这感受野就增大了，同时也能抓住多尺寸的特征。所以Swin Transformer刚开始是4倍下采样，然后变成8倍、16倍。之所以刚开始是4倍，是因为它最开始的这个patch是4×4大小的。那当有了多尺寸的信息，即4×，8×，16×的特征图，那么就可以把这些多尺寸的特征图输给一个FPN，从而就可以做检测了。
Swin Transformer的一个关键设计因素，移动窗口。如图所示，如果在Transformer第l层，把输入或者特征图分成红色小窗口的话，那就会有效的降低序列程度，从而减少计算复杂度。图中灰色的小patch，是最基本的元素单位，也就是那个4×4的Patch。每个红色的框是一个中型的计算单元，也就是一个窗口。在论文中，每一个窗口默认有7×7=49个小Patch。图中主要是画了一个示意图，主要是讲解shift操作是怎么完成的。那么，如果我们用蓝色的框表示整体特征图，shift操作就是往右下角的方向整体移动了两个patch，也就变成了像右图那个的格式，然后我们在新的特征图里再次分成四个方格，那最后shift我们就有很多窗口。这样的好处就是窗口与窗口之间现在可以有信息交流了，而之前没有shift，这些窗口之间没有重叠，每次自注意力的操作都在小窗口里进行了，这样这个窗口里的patch就无法注意到别的窗口里的那些patch的信息，这就达不到使用Transformer的初衷了。因为Transformer的初衷就是更好的理解上下文。再配合上之后提出的 patch merging，合并到 Transformer 最后几层的时候，每一个 patch 本身的感受野就已经很大了，就已经能看到大部分图片了，然后再加上移动窗口的操作，它所谓的窗口内的局部注意力其实也就变相的等于是一个全局的自注意力操作了。这样既省内存，效果也好。
6 算法模型总览 假设我们现在有一张输入图片224×224×3，首先第一步像ViT那样，把图片拆分重排成patch。由于论文中patch_size大小为4×4（这里指的是把一张大的图片拆成4×4个小图片，不是拆分后的每一个小图片大小为4×4），图片经过Patch Partition，就是拆分重排为patch之后，得到图片的尺寸为56×56×48，其中56=224/4，是因为patch_size=4；向量的维度48，是因为4×4×3，其中3位图片channel，也就是RGB通道。接下来为Linear Embedding，也就是把向量的维度变成一个预先设置好的值，即Transformer能够接受的值，在论文中把这个差参数设置为C（96），所以经历完Linear Embedding，图像尺寸变成了56×56×96，而56×56被拉平成3136，变成序列长度，96就变成每一个token的维度。其实这里的Patch Partition和Linear Embedding就相当于ViT中Patch Projection那一步操作。注：这个在代码里用一次卷积操作就完成了。这些其实跟ViT是没有区别的，但是接着区别就来了。
首先，我们可以看到现在的序列长度为3136，而在ViT中，由于patch_size大小为16×16，他的序列长度只有196，而这里3136就太长了，是目前Transformer不能接受的序列长度，那应该怎么做呢？Swin Transfomer文中引入了基于窗口的自注意力计算，每个窗口只有49（7×7）个patch，所以序列长度只有49，这样就很小了，这样就解决了计算复杂度的问题。也就是说Swin Transformer Block是基于窗口去算自注意力的，至于每个一个Block里做了什么，我们之后讲，先把它当成是一个黑盒，现在只关心输入输出的维度。大家也知道，如果不对Transformer去做更多的约束的话，那Tranformer输入的序列长度是多少，那么它输出的序列长度也是多少。注：这里读了ViT论文的应该知道。
所以说经过两层Swin Transformer Block之后，输出还是56×56×96。那到这，其实Swin Transformer的第一个阶段（stage 1）已经走完了。注：作者写的是两个 Swin Transformer Block，实际上这里永远是偶数个，我们可以看到这里面，LN其实就是layer norm，MLP，这里和Transfomer Block是一样的，唯一的区别就是把原来的MSA换成W-MSA，作者接连使用了两个Transformer Block，是因为作者要使用一个W-MSA和一个SW-MSA，这两个东西都得用，才能取得比较好的结果。所以我们可以注意看，作者使用的Swin Transformer Block都为偶数个。也就是说该模型最重要的就是W-MSA和SW-MSA，当然可能还有一个Patch Merging不知道是怎么操作的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/885bf86ca2c043c2a1924908cf0a40a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef4d907ef6d1aa66a886025b4676001/" rel="bookmark">
			PVS显示unknown device
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 不要unknown的那块pv盘的解决办法
1. 不要unknown的那块pv盘的解决办法 [root@gezi ~]# pvs WARNING: Device for PV D1LLfT-3Hle-NbrP-5165-Q6WR-2UWF-2xEIR3 not found or rejected by a filter. PV VG Fmt Attr PSize PFree /dev/xvda2 vg1 lvm2 a-- 79.51g 23.62g /dev/xvdb lvm2 --- 250.00g 250.00g unknown device vg1 lvm2 a-m 250.00g 250.00g [root@gezi ~]# vgs WARNING: Device for PV D1LLfT-3Hle-NbrP-5165-Q6WR-2UWF-2xEIR3 not found or rejected by a filter. VG #PV #LV #SN Attr VSize VFree vg1 2 2 0 wz-pn- 329.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ef4d907ef6d1aa66a886025b4676001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cf9658354c22bcc8b7776ffbb62f53/" rel="bookmark">
			轻量迅捷时代，Vite 与Webpack 谁赢谁输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你知道Vite和Webpack吗？也许有不少"程序猿"对它们十分熟悉。
Webpack Webpack是一个JavaScript应用程序的静态模块打包工具，它会对整个应用程序进行依赖关系图构建。而这也会导致一个不可避免的情况，使用Webpack启动应用程序的服务器，会花费比较长的时间——一些大型应用程序可能需要10分钟以上。
此时你心里可能已经在抓狂了，为什么会这么费时间？那就让我们一起看看基于 Webpack 包的整个工作流。
基于Webpack包的工作流 当我们保存文件时，整个JavaScript包将由Webpack重建，即使启用了HMR，我们进行修改可能也需要10秒钟才能在浏览器呈现。在比较复杂的环境下，Webpack的反馈却如此之慢，会为开发人员带来极大不便。
说完了Webpack我们再为大家介绍一下Vite。
Vite Vite是新一代JavaScript构建工具，旨在提高开发人员在构建JavaScript应用程序时对Webpack的体验。
Vite根据JavaScript生态系统中最近所做的两项改进——浏览器中ES模块的可用性，以及esbuild等本机捆绑工具的编译功能，为开发者提供更加强大的支持。
Vite的核心理念是非捆绑式开发建设。
浏览器中ES模块的可用性允许您在浏览器上运行JavaScript应用程序，而无需将它们捆绑在一起。
Vite的核心思想很简单：当浏览器请求时，使用ES模块进行转换并提供一段应用程序代码。
开始开发后，Vite将首先将JavaScript模块分为两类：依赖模块和应用程序模块。
依赖模块是从node_modules文件夹导入的JavaScript模块。这些模块将使用esbuild进行处理和绑定，esbuild是用Go编写的JavaScript绑定器，执行速度比Webpack快10到100倍。
应用程序模块是为应用程序编写的模块，通常涉及特定于库的扩展，如：jsx / vue 或 scss文件。
虽然基于捆绑程序的工作流（如Webpack）必须在单个浏览器请求之前处理整个JavaScript模块，但Vite仅在单个浏览器请求之前处理依赖模块。
在必要时，Vite会对我们的整个应用模块进行转换。
为了方便大家的理解，下面为大家介绍基于Vite的完整工作流程。
基于 Vite的工作流程 这张图可以清晰的让大家理解，为什么Vite能够比Webpack更快地处理我们的开发构建。
如果用一个通俗的说法比较二者，就好像我们去一家餐厅吃饭，Webpack的后厨一口气做完所有的饭，然后一道道为你上菜；而Vite的厨子手脚麻利，很快做完一道菜就上一道菜。
使用Vite，处理开发构建的时间会随着应用程序的增长缓慢增加。
Vite 的捆绑构建 虽然现在所有主流浏览器都支持原生ES模块，但发布一个包含诸如tree-shaking、延迟加载和通用块拆分等性能优化技术的捆绑应用程序，仍然比非捆绑应用程序会为开发者带来更好的使用体验，整体性能更高。
由于这个原因，Vite内置了一个build的配置的命令，该命令使用Rollup捆绑应用程序；我们可以根据自己的具体需求对Rollup进行自由配置。
Vite 入门基础 使用Vite构建一个应用很简单，vite build创建一个预配置的应用程序，主流前端框架React、Vue和Svelte等都可以支持。
创建应用程序所需的命令：
$ npm init @vitejs/app 或者
$ yarn create @vitejs/app 终端中的提示将指导您创建正确的应用程序，然后运行 npm install
启动开发服务器
npm run dev 除此之外，还可以创建Vite+React的应用程序。React 的起始页与Create React App的默认模板非常相似，只是稍作修改：
此外Vite preview用于在本地对应用进行预览，还支持许多官方模板，包括vanilla JavaScript和TypeScript。
结论 从目前的的使用状况来看，Vite毫无疑问是新一代JavaScript构建工具中最快捷的，但是面对竞争，Webpack也对一些内容进行优化，作为经典老牌工具Webpack用户基数本身就很大， 实力依旧不容小觑，现在依旧是许多流行应用程序（如Next）的默认JavaScript构建工具。
但随着时间不断推移，Vite周边的生态力量逐渐跟上，结合它本身有的快速的优势，后来居上，也是显而易见的事情。
作为开发者，当然也不会独断专言必须使用哪一个，根据不同得场景选不同的工具，期待在未来这些工具可以进一步为开发助力，让开发变得更加方便。
拓展阅读 大家如果对Vue感兴趣，不妨跟着实战教程，亲自搭建一个基于Vue3的表格编辑系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5cf9658354c22bcc8b7776ffbb62f53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1380546d1498923a01a14b663de8110/" rel="bookmark">
			Java中使用@Scheduled定时器操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中使用@Scheduled定时器的几种种操作方式。
1、fixedRate
例：@Scheduled(fixedRate = 5000) //上一次开始执行时间点之后5秒再执行
2、fixedDelay
例：@Scheduled(fixedDelay = 5000) //上一次执行完毕时间点之后5秒再执行
3、cron
例：@Scheduled(cron = "0 0/1 9-21 * * ?")//每天早上9点-晚上21点间执行，每次执行间隔一分钟
着重讲一下cron:
Scheduled(cron="0 0 21 * * ?") 配置完整格式为： [秒] [分] [小时] [日] [月] [周] [年]
其中每个元素
可以是一个值(如6),
一个连续区间(9-12),
一个间隔时间(8-18/4)(/表示每隔4小时),
一个列表(1,3,5),
通配符。
由于"月份中的日期"和"星期中的日期"这两个元素互斥的,必须要对其中一个设置
附上一点代码示例：
@Component @EnableAsync public class ThirdOverTimePushTask { private Logger logger = LogManager.getLogger(); @Autowired private LawyerDontReceivingService lawyerDontReceivingService; //@Scheduled(fixedRate = 60000)//每隔一分钟执行一次 @Scheduled(cron = "0 0/1 9-21 * * ?")//每天早上9点-晚上21点间执行，每次执行间隔一分钟 public void run() { try { run(()-&gt; { logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1380546d1498923a01a14b663de8110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5317eb6217c42a578af7bec071f4570a/" rel="bookmark">
			sequence point
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		顺序点，C语言冰山位于海面下的角落。
副作用side effect，简单理解就是变量值被改变这个事实。i++这个表达式，副作用就是i被增加1。a = 10；这个表达式，副作用就是a被赋值成10。
一个复杂的表达式，其求值过程是有迹可循的。例如：i++ + ++i 这个表达式，根据运算符的结合性或优先级关系，可以被人为是如下等效形式：(i++) + (++i).现在的问题来了，它的求值结果是什么？答案是：未定义行为（undefined）。未定义的意思是：无法预测结果。对比另一个叫做为未指定行为（unspecified） ,说的是有几个结果，发生哪一个不知道。显然，未定义是更危险的。
这里面涉及到顺序点这个事。具体细节参考sequence point « Eternity
简单的说，就是在顺序点之前，何时完成副作用，是不确定的事，不能根据子表达式，就说在此子表达式完成副作用。
顺序点是语法解析过程，对指定的几个词法位置的特殊标记。就好比道路上的路牌作用。
常用的顺序点(我用@符号表示这个路牌)：
1） 分号位置。
a = 10 ;@ 2） 逗号表达式位置
a = 10 ,@ i++ ,@ a=i ;@
3) 三目运算符
a&gt;0 ?@ i++ :@ j++ ;@
4) ......
副作用被限制在顺序点之间的任意位置发生。即两个@路牌之间发生。
回到 (i++) + (++i)这个面试和考试常考的地方，因为+号不是顺序点，所以，不能断言出i++的副作用在+之前完成。
可以想象成i++和++i的副作用是多线程方式（parallel）方式进行的。这是个多线程写。
另一个例子是a[i] = i++;因为[]和=都不是合规的顺序点，因此将发生多线程的读写。因此上述两个例子的结果都是不确定的。
实际上没有多线程，只是想象，帮助你理解为什么不能那么写程序，也不能拿这种例子考试别人。
只是编译器厂家可以做生成的指令重排列做效率优化（只要保证在顺序点之前实现副作用）。重排列指令顺序后，等效于多线程（单核）指令交替执行的效果。
下面是各个编译器上机实验：
#include &lt;iostream&gt; int main() { int i = 1; int a = i++ + ++i; std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; } GCC： 提示 undefined behavior。不是说未定义变量i。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5317eb6217c42a578af7bec071f4570a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711dbd5dd474e2b8a7e0e0ea4bd90c68/" rel="bookmark">
			iOS实现LRU缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.LRU简介 LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。
见leetcode146题:
LRU缓存机制
二.在iOS中的运用 实现一个 Memory Cache 类 LRUCache，使用 LRU 淘汰策略，它有容量上的限制 capacity，实现接口：
- (id)initWithCapacity:(NSInteger)capacity; - (void)setItem:(id)item forKey:(NSString *)key; - (id)getItemForKey:(NSString *)key; 分析:
使用双向链表实现,可以在时间复杂度O(1)内完成删除和插入的操作.
模版代码
class LRUCache { init(_ capacity: Int) { } func get(_ key: Int) -&gt; Int { } func put(_ key: Int, _ value: Int) { } } 三.实现 1.先实现链表节点 class ListNode { var key: Int var value: Int var next: ListNode? var prev: ListNode?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/711dbd5dd474e2b8a7e0e0ea4bd90c68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a8b512c6cce2ba2c9b7de13806038f/" rel="bookmark">
			结构光与TOF的对比区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据使用场景判断使用机构光还是tof的相机。
一、概述 结构光（Structuredlight），通常采用特定波长的不可见的激光作为光源，它发射出来的光带有编码信息，投射在物体上，通过一定算法来计算返回的编码图案的畸变来得到物体的位置和深度信息，镜头需要定制镜头或者特殊镜头设计。
光飞行时间法（TOF），利用测量光飞行时间来取得距离，简单来说就是，发出一道经过处理的光，碰到物体以后会反射回来，捕捉来回的时间，因为已知光速和调制光的波长，所以能快速准确计算出到物体的距离。
相对结构光方案，TOF的3D方案实现起来更为简单，主要包括投射器和接收模组，通过控制投射器发出经调制的近红外光波，遇物体后反射，接收模组计算发射光波和接收光波的时间差或相位差，换算成被拍摄景物的距离，以获取深度信息。
对比：
二、TOF优缺点 1.优点
优点一，工作距离远，可以获得5m内的有效&amp;实时深度信息。
优点二，适用场景广，无论被摄物体有无特征点，无论环境光较强（如：日光）或较弱，都可获得有效的景深信息。
优点三，较远距离精度高，ToF被摄物体之间的相对精度，都可以达到厘米级的水平。（精度还是结构光更高）
2.缺点
缺点一：元件在工作时的功耗与发热量也相对较大，长时间工作需要很好的散热条件，在消费类电子设备上使用还需要不断优化。
缺点二：目前基于ToF方案的解决方案还未完全成熟，相应的内容生产和开发群体较为薄弱，支持的应用场景较少。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35ac95d0c57dd6409553e41655c36b8/" rel="bookmark">
			Photoshop简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义 a.photoshop是由adobe公司开发的一款专业图形处理软件是各行各业用于图形处理的首选软件
b.用途：网页设计，平面设计，摄影后期，动画和CG
c.界面组成：菜单栏，工具箱，状态栏，面板
d.工具箱常用工具：移动工具，选取工具，套索工具，魔棒工具，文字工具，抓手工具
e.历史：adobe公司两款软件：flash，ps，flash视频软件，视频格式，用于互联网网页所有视频的浏览，由于微软、谷歌、苹果三家极力阻扰，flash视频被w3c的html的vedio标签取代
html的canras标签封装了150个函数和300个属性用来全面ps功能
常用快捷键
填充前景色 alt+del
填充后景色 ctrl+del
变换形状 ctrl+T
复制并拖动图层 alt+左键
等比例绘制正圆或者正方形 shift+左键
tips：ps是由若干个图层组成，优先级为：上层图层覆盖下层图层
二、图层操作 常用快捷键
复制图层：
1.移动工具下 alt+左键
2.ctrl+J 提示：新建选区选中部分
移动图层：
1.ctrl+] 上移图层
2.ctrl+[ 下移一层
3.ctrl+shift+] 置顶
tips：所有新建的图层默认的背景颜色为透明色，图层优先级：从上往下
色彩的搭配 一、色彩的三个要素：色相、明度、纯度
二、色相是由6种颜色组成：红色、橙色、黄色、蓝色、绿色、紫色
三、色相环中相邻的颜色：类比色
色相环中对角的颜色：补色
色相环中一种颜色：单色
色相环中红色、蓝色、绿色：原色
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b0bc6aaf89fc9086f90f7539717ebc/" rel="bookmark">
			【研一小白论文精读】《MoCo》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实之前读simclr那篇论文的时候已经涉及到一些moco的内容，现在的moco已经更新到了v3。
moco是一种典型的contrastive unsupervised learning。
Momentum Contrast for Unsupervised Visual Representation Learning 在moco提出的时候现有的contrastive learning有两种手段：
第一种是end to end，就是一个sample经过不同的图像增强作为querry和key，放到两个encoder里面，然后算相似程度，同一个样本产生的querry和key相似程度是高的，不同样本产生的相似程度是低的，这种方法对两边的encoder都做传递，这一点和attention很像，互搏。
第二种呢则是memory bank，memory bank就是锁住一边的key，其实就相当于把所有的key存在一个bank里，那么每次一个新图像进来过encoder得到一个querry的时候，从bank中sample出一些representation和这个querry来做比较，那么显然这一部分是不需要传递梯度的。
那么最后就是moco
moco的原理其实非常简单，就是一个batch的图像仍然经过不同的图像增强策略，左边这支叫querry，右边这支叫key，querry过一个encoder，key也过一个encoder，不过这个encoder是momentum ecdoer。然后呢我们就得到了他们的represention，但是key的represention不仅有这个batch的represention，还有之前batch保存下来的represention，所以我们看到这里其实是维护了一个队列。这样做的好处就是比起之前的simclr一个batch内相互做contrastive learning，现在一个batch通过很少的代价获得了更多的negative samples，那么还是两个represention之间计算相似度来得到这个contrastive loss。
而这个contrastive loss如上图就是我们很熟悉的NCE，分子部分就是querry和对应的key的相似程度，分母就是querry和其他所有的key他们对应的相似程度的和，这里的“套”就是temperature，用来控制loss的分布，这就是contrastive loss的部分。
momentum ecdoer部分就是我在更新了querry的encoder之后呢，并不是直接复制到key的encoder里面，而是我已一定的比例更新这个key。
Methodology 接下来结合作者提供的伪代码来看一下：
代码一开始momentum encoder和encoder的参数是相等的已经初始化好了，然后对于一个sample来说，做不同的两种图像增强策略，得到querry的sample和key的sample，分别送到两个encoder里面。因为key是不需要计算梯度的，所以detach一下。先把q的vetor和k的vetocr做一个变形，然后两个做内积，就产生positive loss了。那么negaive loss就是所有的q和之前维护的队列中的key一起做个矩阵乘法。然后把得到的positive loss和negaive loss做串起来，传入这个形如softmax加CrossEntropy的loss中计算。这里非常巧妙的一点就是这里的logits有n行k+1列，第一列是positive sample，其余的key列都是样本和negaive的相关程度。告诉CrossEntropy index为0的这一列是positive sample。然后再做传递，更新一下encoder network的参数，然后再用momentum更新一下momentum encoder，到此网络就结束了。最后维护一下key的队列，然后把最早的一个bacth的样本弹出来。
以上就是moco的实现方法。
Resuluts：Linear Classification 实验结果也是对比了之前end to end还有memory bank，随着negative sample的增加，模型的效果肯定也越来越好。
作者也测试了不同的momentum，应该以怎样的速率更新这个momentum encoder呢，可以看到这些结果。
这里其实是一个非常有意思的实验，shufflinfg batch normalization，作者说其实包括之前的论文也有汇报，我们的batch normalization其实会阻碍unsupervised learning的，阻碍我们的模型学到好的representation，那么可能的原因就是network在做batch normalization时应用到了一个batch中所有样本的信息，那么在这个normalization的过程中，不同不同样本之间的信息可能就泄露给对方了，这样呢就会使contrastive loss更容易达成，为了克服这个困难作者就使用了shufflinfg batch normalization，具体来说就是作者在多块GPU上训练了这个模型，他就是在每一个GPU上做 batch normalization，同时因为有两支，一支是key，一支是query，query又是打乱顺序之后送到GPU里的，也就说到最后对应的query和key不是从同一个batch normalization里出来的，这个技巧就称之为shufflinfg batch normalization。并且可以看到使用linear layer，也就是虚线，可以看到区别不是很明显，linear layer毕竟还是很强的模型，但是如果用KNN作为分类器，有没有shufflinfg batch normalization还是有影响的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90b0bc6aaf89fc9086f90f7539717ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/402128fa9ab31c0a6dbfad2276d61c6e/" rel="bookmark">
			关于访问对象存储中的影像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编者：王丽莉
SuperMap 的镶嵌数据集和影像服务都支持管理对象存储中的影像文件，包括：华为OBS对象存储服务、阿里OSS对象存储服务、S3简单存储服务，并且这些对象存储都支持以HTTP访问协议和GDAL的vsis3文件系统程序来访问，这里推荐使用GDAL的vsis3文件系统程序来访问。
SuperMap 镶嵌数据集和影像服务都需要通过影像文件清单来指定所管理的对象存储中的影像文件，清单文件为一个 .txt文本文件，每行为一条记录，每条记录为一幅影像文件的全路径。这样，镶嵌数据集就可以通过清单文件将其中的影像文件添加进来进行管理；影像服务也可以通过该清单文件将其中的影像文件发布为影像服务（如何基于清单文件发布影像服务，请参见SuperMap iServer帮助文档），关于对象存储中影像文件的路径的写法规则如下：
1、HTTP访问协议：影像文件的路径的写法为：
/vsicurl/http://1.1.1.1:80/mybucket/L51C001003.tif，其中：“/vsicurl/”是http协议访问方式的必须前缀；“mybucket”为桶名。
2、HTTPS访问协议：影像文件的路径的写法为：
/vsicurl/https://1.1.1.1:443/mybucket/L51C001003.tif，其中：“/vsicurl/”是http协议访问方式的必须前缀；“mybucket”为桶名。
3、GDAL的vsis3文件系统程序访问：影像文件的路径的写法为：/vsis3/mybucket/L51C001003.tif，其中，“/vsis3/”是必须前缀；“mybucket”为桶名。
以上为镶嵌数据集和影像服务如何访问对象存储中的影像文件的内容，SuperMap程序能够成功访问对象存储中的影像文件，还需要进行机器环境的相关配置，即需要配置如下所示的几个系统环境变量：
1、配置对象存储的访问协议 新建一个名为“AWS_HTTPS”的系统环境变量来指定对象存储的访问协议。默认访问协议为 HTTPS。
若采用HTTP访问协议，“AWS_HTTPS”变量的值设置为NO；若采用HTTPS访问协议，“AWS_HTTPS”设置为TRUE，且为默认值。
2、指定对象存储的URI 新建一个名为“AWS_S3_ENDPOINT”的系统环境变量，变量的值设置为对象存储的访问地址，支持域名和IP+端口两种地址形式。
例如：
AWS_S3_ENDPOINT=obs.cn-north-4.myhuaweicloud.com
AWS_S3_ENDPOINT=1.1.1.1:80
AWS_S3_ENDPOINT=1.1.1.1:443
备注说明：关于端口的说明，若对象存储采用HTTPS协议访问，默认端口为443；若采用HTTP协议访问，默认端口为80。
3、对象存储的访问密钥AK\SK 新建名称为“AWS_ACCESS_KEY_ID”和“AWS_SECRET_ACCESS_KEY”的系统环境变量，变量的值设置为密钥AK\SK值。
4、配置对象存储的桶的访问方式 访问公有云对象存储时无需设置该环境变量，而访问私有云对象存储时必须配置。
新建一个名为“AWS_VIRTUAL_HOSTING”的系统环境变量，变量的值设置为FALSE。
这是因为“AWS_VIRTUAL_HOSTING”默认值为TRUE，此时，桶的访问方式为桶名+HostName，例如：mybucket.cname.domain,com，而SuperMap支持桶的访问方式为将桶作为对象存储URI的顶级目录，即cname.domain,com/mybucket，因此，需要将“AWS_VIRTUAL_HOSTING”设置为FALSE。
5、无需签名的配置 访问公有云对象存储时无需设置该环境变量，而访问私有云对象存储时必须配置。
新建一个名为“AWS_NO_SIGN_REQUEST”的系统环境变量，变量的值设置为YES。
当访问私有云对象存储中的数据时，如果遇到如下所示的错误信息（The request signature we calculated dose not match the signature you provided. Check your key and signing method.），可以通过“AWS_NO_SIGN_REQUEST=YES”系统环境变量设置来解决。
6、配置CURL SSL证书 当访问对象存储中的数据失败时，且遇到如下所示的错误信息（CURL error: SSL certificate problem:），您需要下载一个CURL SSL证书并完成配置。如果未遇到此问题，请忽略此步骤。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f376fb6904bdf69c2b76572503ca324/" rel="bookmark">
			linux安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装一些依赖
yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 2、下载安装包–我安装到/usr/local下
cd /usr/local mkdir nginx cd nginx //下载tar包 wget http://nginx.org/download/nginx-1.13.7.tar.gz //解压 tar -xvf nginx-1.13.7.tar.gz 3、安装nginx
cd /usr/local/nginx //进入目录 cd nginx-1.13.7 //执行命令 添加两个模块 ./configure --with-http_stub_status_module --with-http_ssl_module //执行make make //执行make install make install 4、启动nginx服务
​​​​​​​/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 5、查看nginx是否启动
ps -ef | grep nginx 扩展:一般来说一台服务器可能有多个web项目，所以我们要以nginx.conf当作注的配置文件，通过include xxx.conf的方式指定我们项目的配置的文件
说明：只说必填项
listen：访问路径的端口号 如服务器的ip为172.50.62.10。则访问的地址为172.50.62.10:8080
root：前端dist的项目路径
/caiyun/api：后端接口请求的地址
proxy_pass：后端接口访问的的整体路径。如http://172.50.62.10:8088/caiyun/api
access_log和error_log：打印日志文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f1a2c5e4085a72f6b0bd69a0786117/" rel="bookmark">
			Linux：redis环境搭建（单机模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装前置环境 在Linux上运行gcc，出现下图结果表示已经安装gcc,否则运行yum install gcc 安装。这为后面的redis编译和安装做准备。
下载安装 1.下载
官网下载：https://redis.io/
2.解压
将下载好的安装包上传到linux中，并解压
3.编译
解压后，可以看到有Makefile文件，在当前路径运行 make 进行编译
make 4.安装
# 在make编译完成后，紧接着下面的命令 (安装路径自行选择) make install PREFIX=/usr/unchinese/redis 安装参考博客：https://blog.csdn.net/qq_25287393/article/details/84785516
启动 1.启动redis
安装成功后，可以看到安装路径下有redis的运行文件
运行 ./redis-server出现下图表示安装成功。现在redis默认是前台启动，如果需要切换成默认后台启动，则需要修改配置文件。
2.修改redis配置文件
将解压包里的redis.conf默认配置文件复制到redis安装目录下的/bin下，然后主要修改如下几个配置
daemonize：是否在后台运行如需要在后台运行，把该项的值改为yes
port：监听端口，默认为6379
3.测试
使用redis-cli测试本地的redis是否启动成功
redis-cli -h host -p port -a password -h：服务器地址，默认为localhost -p：端口号，默认为6379 -a：密码 使用RDM远程连接 虽然redis服务器本地客户端可以连上redis，但是外面的客户端不能连上，经过排查。
telnet redis服务器ip 端口，报如下图所示错误
原因是因为redis默认是用保护模式启动的，如果要使用远程连接
要么关掉redis的保护模式重启要么给redis的客户端设置连接密码 # 在redis服务器的机子上使用客户端连接 ./redis-cli # 获取当前redis连接密码 config get requirepass # 设置连接密码 config set requirepass 123456 # 退出客户端 exit # 重新使用客户端连接 localhost:6379的redis服务器 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5f1a2c5e4085a72f6b0bd69a0786117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7befea9c1a5fe1fa2f73865d877ba197/" rel="bookmark">
			关于attr方式实现主题针对BottomNavigationView 深色主题选中修改指定特定颜色。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		selector_second_color.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!-- //代码设置着色，是为了让深色模式的选中 tab颜色变成紫色 但是发现使用属性的话永远是默认主题的颜色--&gt; &lt;item android:color="?attr/defaultThemeColorSecond" android:state_checked="true" /&gt; &lt;item android:color="@color/blackForebg" android:state_checked="false"/&gt; &lt;/selector&gt; ColorStateList colorStateList = ContextCompat.getColorStateList(this,R.color.selector_second_color); getBinding().navView.setItemIconTintList(colorStateList); getBinding().navView.setItemTextColor(colorStateList); 其中defaultThemeColorSecond在每一个主题都有实现，包括红色，蓝色， 深色 模式下都有实现，
但是如果不使用ContextCompat.类而是使用resource.getColorStateList);是有bug的，动态设置theme永远是默认主题的颜色，所以需要这个进行处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3da30291864d87f0a180dc64561797fc/" rel="bookmark">
			日志清理脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、创建一个日志清理脚本 #/bin/bash for i in `find /root/.pm2/logs -name "*.log"` do cat /dev/null &gt; $i done 将该脚本添加至定时任务，每隔30分钟执行一次 */30 * * * * /usr/bin/sh /root/.pm2/logs/cleanlog.sh &gt;/dev/null 2&gt;&amp;1 删除/opt目录下所有的日志文件 find /opt -name *.log.* | xargs rm -rf 查看/opt目录下，所有日志文件及大小 find /opt -name *.log | xargs du -sh #查找目录下的.log后缀的文件，并清空文件内容(这里不是删除文件) find /opt -name *.log -exec cp /dev/null {} ; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3ae5917206c5ffa8b5d9b8bbb33d8c0/" rel="bookmark">
			go tool link: fork/exec /usr/local/go/pkg/tool/darwin_amd64/link: no such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接
https://chowdera.com/2022/03/202203260446500777.htmlhttps://blog.csdn.net/m0_46521785/article/details/123712337 原因 从MacOS 12.3 Beta版本开始，Apple不再内置python2且将无法正常安装python2，无论是intel芯片还是Apple芯片的设备都无法安装。原因是/usr/bin/python的软链接无法正常被删除或覆盖。
解决办法 首先你需要安装一个Python2，下载地址：https://www.python.org/downloads/release/python-2718/
方法一：修改link文件 将link文件的第一行修改为#!/usr/bin/env python
sudo vim /usr/local/go/pkg/tool/darwin_amd64/link 两者区别：https://www.cnblogs.com/qiulinzhang/p/9901110.html
方法二：添加Python到/user/bin目录 自行查阅
以上是网络上解决方案，但方案二中的看的不是很明白
本质其实是找不到 python 环境，安装 python2 后，安装目录如下：
lrwxr-xr-x 1 root wheel 68B Apr 12 21:25 /usr/local/bin/python -&gt; ../../../Library/Frameworks/Python.framework/Versions/2.7/bin/python 将link文件的第一行修改为#!/usr/local/bin/python 也能解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8d6dad6794c01f8b030afbab90e90d/" rel="bookmark">
			【文献阅读笔记】之基于注意力机制的深度学习路面裂缝检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文，计算机辅助设计与图形学学报，第 32 卷 第 8 期，2020 年 8 月。
DOI: 10.3724/SP.J.1089.2020.18059
摘要： 为实现自动准确地检测路面裂缝, 提升路面裂缝检测效果, 提出了一种基于注意力机制的裂缝检测网络 (attention-based crack networks, ACNet). 该网络采用编码器-解码器网络构架, 编码器采用 ResNet34 为骨干网, 提取路面裂缝特征; 在编码器和解码器间加入基于注意力机制的特征模块(attention-based feature module, AFM), 以利用全局信息和增加对检测不同尺度裂缝的鲁棒性, 更好地提取裂缝特征和定位裂缝位置; 在解码阶段也引入注意力机制, 设计了基于注意力机制的解码模块(attention-based decoder module, ADM), 实现对裂缝的准确定位. 在公共裂缝 数据集 CFD 和 CRACK500 上, 与U-Net 等其他 8 种方法进行了比较, 结果表明, ACNet 裂缝检测效果更理想, 在主观视觉上, 裂缝定位更准确, 细节更丰富; 在实验指标 F1和重合率上, 检测结果都有明显提升, 说明了该网络的有效性。
研究背景 基于图像的路面裂缝检测, 可以看成是从图像中分割出裂缝区域,图像分割时, 一般以图像(单通道或多通道)为输入, 输出是带有标签的分类后的图像, 而图像的大小保持不变。
传统方法 基于直方图估计、梯度方向直方图、局部二值模式、Gabor 滤波和多特征融合。
局限性：对输入图像的质量要求较高, 往往在外界环境发生变化、光线不均和有噪声干扰时, 裂缝检测的性能将受到极大影响。
基于深度学习的方法 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c8d6dad6794c01f8b030afbab90e90d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a141a43b41d1dd8a615f5aaca74a4b/" rel="bookmark">
			STM32之音乐播放器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32之音乐播放器 1.硬件平台 CPU：STM32F103ZE 屏幕：3.5寸TFTLCD屏 音频解码器： VS1053 SD卡、外扩Sram 2.示例效果 3.软件设计 VS1053b 是单片 Ogg Vorbis/MP3/AAC/WMA/MIDI 音频解码器，及 IMA ADPCM 编码器和用户加载的 OggVorbis 编码器。
支持： MP3/WMA/OGG/WAV/FLAC/MIDI/AAC 等音频格式的解码，并支持： OGG/WAV 音频格式的录音，支持高低音调节设置， 功能十分强大。
它包含了一个高性能、有专利的低功耗 DSP 处理器内核VS_DSP4、工作数据存储器、供用户应用程序和任何固化解码器一起运行的 16 KiB 指令 RAM 及 0.5KiB 多的数据 RAM、串行的控制和输入数据接口、最多 8 个可用的通用 I/O 引脚、一个 UART、并有一个优质的可变采样率立体声 ADC（“咪”、“线路”、“线路+咪”或“线路*2”） 和立体声 DAC、和跟随的一个耳机功放及一个公共电压缓冲器。
3.1 硬件接口 引脚GPIO说明VS_MISOPA6主机输入VS_MOSIPA7主机输出VS_SCKPA5时钟VS_XCSPF7命令片选(低电平有效)VS_XDCSPF6数据片选（低电平有效）VS_DREQPC13数据请求线（高电平表示可以接收数据）VS_RSTPE6复位脚(低电平复位) 3.2 VS1053驱动 /**************硬件接口***************** **VS_MISO -- PA6 主机输入 **VS_MOSI -- PA7 主机输出 **VS_SCK -- PA5 时钟 **VS_XCS -- PF7 命令片选(低电平有效) **VS_XDCS -- PF6 数据片选（低电平有效） **VS_DREQ -- PC13 数据请求线（高电平表示可以接收数据） **VS_RST -- PE6 复位脚(低电平复位) ** *****************************************/ void VS1053_Init(void) { /*1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1a141a43b41d1dd8a615f5aaca74a4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93099274a217d787d1c3e1f6ba4020dc/" rel="bookmark">
			Android判断当前网络能否上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
* 判断当前网络是否可用(6.0以上版本)
* 实时
* @param context
* @return
*/
public static boolean isNetSystemUsable(Context context) {
boolean isNetUsable = false;
ConnectivityManager manager = (ConnectivityManager)
context.getSystemService(Context.CONNECTIVITY_SERVICE);
if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) {
NetworkCapabilities networkCapabilities =
manager.getNetworkCapabilities(manager.getActiveNetwork());
if (networkCapabilities != null) {
isNetUsable = networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED);
}
}
return isNetUsable;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394406895596453079e95d6cfd4cb1ac/" rel="bookmark">
			js基础总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
目录
前言
一、循环
1.While 循环
1.1 while
1.2 do..while
1.3 while和do..while的区别
1.4 break
1.5contiune
1.6 break和contiune的区别
2.for循环
3.补充
1.死循环
2.三种循环的总结
二、数组
数组的创建方式
遍历数组
新增数组元素
冒泡排序
翻转数组
四、函数
1.声明函数和调用函数
2.函数的形参和实参
3.函数的返回值return
4.arguments的使用
5.案例
六、作用域
全局作用域和局部作用域
七、对象
1.创建对象的方式
遍历对象
New关键字执行过程
案例补充：
八、内置对象 1.Math内置对象
2.Array内置对象
3.Date内置对象
4.String内置对象
总结
前言 记录自己的学习过程，补全前几天的知识点，顺便总结复习一下。本文内容包括while循环、数组的基本使用、函数、作用域简单理解、预解析、对象。
以下是本篇文章正文内容，下面案例可供参考
一、循环 1.While 循环 1.1 while while 循环会在指定条件为真时循环执行代码块。
语法
var num = 1;//1、声明循环变量 while (num&lt;=10){//2、判断循环条件; document.write(num+"&lt;br /&gt;");//3、执行循环体操作； num++;//4、更新循环变量； } //他的执行思路是：当条件表达式为真时，执行 内部的执行语句，如果为假，则不执行。 //案例 var num = 1; while(var i&lt;=100){ //打印1-100； console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/394406895596453079e95d6cfd4cb1ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93690d2af0e976d30cf82c5ee2f31164/" rel="bookmark">
			IDEA 运行报错 Scala Compile Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息:
Scala Compile Server
Error occurred during initialization of VM
Could not reserve enough space for 2097152KB object heap
不影响scala代码运行，但看着不顺眼！
报错原因：
网上找到许多资料说是内存不够使用
解决办法：
修改之后再运行文件，就不会报错了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cca86639af367db0b6541f2a6d7791a/" rel="bookmark">
			基于springBoot动态配置定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景描述:
在生产环境中,有时要临时调整定时任务时间,或者禁用/启用定时任务; 以前都是修改cron表达式后重启项目; 总是感觉这个操作有点麻烦,不够方便, 于是,想实现一个动态的配置处理!!!
功能实现:
1.代码结构:
2.代码实现:
2.1 创建定时任务配置表
CREATE TABLE `scheduled` ( `id` int(11) NOT NULL AUTO_INCREMENT, `task_key` varchar(127) NOT NULL COMMENT '任务key值（使用bean名称）', `name` varchar(127) DEFAULT NULL COMMENT '任务名称', `cron` varchar(63) NOT NULL COMMENT '任务表达式', `status` int(2) DEFAULT '0' COMMENT '状态(0.禁用; 1.启用)', `create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间', `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`), UNIQUE KEY `uniqu_task_key` (`task_key`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='定时任务配置表'; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cca86639af367db0b6541f2a6d7791a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d7b43f16ed7f97e1fff52a3436da7a/" rel="bookmark">
			Python的pyc字节码反编译反汇编相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用pyc转py的工具 pycdc Decompyle++ Decompyle++旨在将编译后的Python字节码转换回有效的、人类可读的Python源代码。虽然其他项目取得了不同程度的成功，但Decompyle++的独特之处在于，它寻求支持来自任何版本的Python的字节码。
Decompyle++包含一个字节码反汇编器(pycda)和一个反编译器(pycdc)。
该工具需要手动编译，使用kali编译以后的样本：https://pan.baidu.com/s/1tAzVPMzFmhWko915yguOUg?pwd=ekgi 提取码：ekgi
decompyle3 仅支持3.8及以下版本 原生Python跨版本反编译器和片段反编译器。是改进版本的uncompille6。
pip install decompyle3
常用exe转pyc的工具 pyinstxtractor.py 将exe解压成pyc文件夹，内含各种资源以及pyc文件
https://pan.baidu.com/s/1tAzVPMzFmhWko915yguOUg?pwd=ekgi 提取码：ekgi
使用dis.dis 该工具是python自带的库，可将已经编译为pyc的文件反编译为汇编
例如源程序 def main(): a = 1 b = 2 c = a + b d = [c]*3 d2 = enumerate(d) e = [x[0] + x[1] for x in d2] return e r = main() print(len(r)) print(r) 反汇编方式 import dis s = open('test.py').read() co = compile(s, 'test.py', 'exec') dis.dis(co, file=open('./test.txt', 'w')) 反汇编结果 1 0 LOAD_CONST 0 (&lt;code object main at 0x0000018F5DECC5B0, file "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d7b43f16ed7f97e1fff52a3436da7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287293ddaaeaf5f57d80170642a876d9/" rel="bookmark">
			【Execl】电子表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本操作 a.定义：excel其实就是一个工作簿，一个工作簿中可以包含多个工作表sheet
b.格式：后缀名分别为xlsx和xls，一般情况下2003的版本都为xls，excel的版本高的软件可以打开版本低文件，反之则不可以
c.tips：1.一张工作表是由多个单元格组成
2.每个单元格都有其对应的坐标，其中用阿拉伯数字表示行号，用大写的字母表示列号 如：D5代表第五行第四列的单元格
二、公式函数 a.公式其实就是一个具备运算能力的表达式，excel支持数学的所有公式
b.函数：其实就是封装了特定功能公式
c.任何单元格要想使用公式或者函数的话，必须先输入一个等于=
d.常用函数
sum（开始的位置：结束位置）求和 只能做数字运算
average（） 求平均值
max（）求最大值
min（）求最小值
countif（）如果满足条件之后的数量
count（）数数包含数字的单元格数量
counta（）数非空单元格的数量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb4d87e6b117f1298110972f53fdb19/" rel="bookmark">
			docker-compose部署项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 使用命令 docker version 确定服务器是否安装了docker
使用命令 yum list installed | grep docker 查看是否已安装docker列表
如果无返回结果，则进入下一步安装Docker
yum -y install docker
使用命令systemctl start docker启动docker，注意启动成功也不会返回提示信息，直接下一步查看docker的服务状态。
启动：systemctl start docker 开机启动：systemctl enable docker
docker-compose 安装docker - compose
curl -L "https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 如果 安装慢的话 可以尝试一下换个源：
curl -L "https://get.daocloud.io/docker/compose/releases/download/1.27.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 随后加上 可执行权限
chmod +x /usr/local/bin/docker-compose 安装成功后使用 docker-compose --version 检测版本是否安装成功
随后把docker-compose.yml移动到对应url(和docker-compose同路径)
使用docker 登录私服
docker login 私服地址
输入账号密码回车
之后在docker-compose.yml的路径下执行docker-compose up -d 安装docker-compose
安装完成之后需要给容器的文件夹赋予权限，url为docker-compose.yml中配置的各容器的url。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deb4d87e6b117f1298110972f53fdb19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98f5738eb2f6e8c2655c22eac715be6/" rel="bookmark">
			Cisco Packet Tracer汉化处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、汉化包获取 点击链接下载汉化包，提取码：4pkx
二、操纵 将汉化包解压到Packet Tracer安装的路径下的languages目录下，如下图：
打开Packet Tracer，点击Options - Preference
选择OK，重启Packet Tracer即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979dce616f1cc093d75ab71e0c821f2d/" rel="bookmark">
			Anaconda navigator 打不开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. Anaconda navigator 实例已运行 Anaconda navigator 会启动一个名为pythonw的进程，杀死进程 tasklist | findstr "pythonw" TASKKILL /F /PID 28384 2. Anaconda Navigator一直在loading界面打不开 在Anaconda的安装文件夹里依次找到：D:\Anaconda\Lib\site-packages\anaconda_navigator\api\anaconda_api.py 文件 # versions=[vsdata.get('productVersion')], # 修改成 versions=["1b8e8302e405050205e69b59abb3559592bb9e60"], 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7beabc22bf357575dbd3bf212a0f76bf/" rel="bookmark">
			H5静态网页手端预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备
1、Node.js
2、Npm
在终端全局安装 anywhere npm install anywhere -g 在你需要的文件夹目录下执行 anywhere
anywhere 在手端浏览器输入地址即可
备注： 执行anywhere默认会执行index.html，若执行其他的则在anywhere 文件名就行啦
手机上运行时确保手机和电脑都在一个局域网内
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588873346405f12f8fae2801e53b9074/" rel="bookmark">
			Ubuntu 20.04 Nvidia Driver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Environment
Hardware: Lenovo y9000p 2019 - intel i7-9750H
OS: Ubuntu 20.04 LTS Dual Boot
Kernel version: Linux 5.13.0-39-generic
GPU model: GTX 1660 Ti 6GB
Install Nvidia Drivers through GUI choose the right tested driver version via Software &amp; Updates - Additional Drivers
then click apply changes
wait for it to download and configure the drivers.
After that, a window will prompt out to tell you you need to set up a key for secure boot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588873346405f12f8fae2801e53b9074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e69120d217a4c54c25e150d360f03b/" rel="bookmark">
			死锁的产生原因以及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、什么是死锁
2、死锁的代码展示
3、死锁产生的原因
4、如何解决死锁问题
1、什么是死锁 死锁就是两个或两个以上线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。
2、死锁的代码展示 也就是两个线程在各自拥有锁的情况下，又去尝试获取对方的锁，从而造成的一直阻塞的情况。
public class Thread18 { public static void main(String[] args) { Object lockA = new Object(); Object lockB = new Object(); Thread t1 = new Thread(() -&gt; { // 1.占有一把锁（锁A） synchronized (lockA) { System.out.println("线程1：获得锁A。"); // 休眠 1s(让线程2有时间先占有锁B) try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // 2.获取线程2的锁B synchronized (lockB) { System.out.println("线程1：获得锁B。"); } } }); t1.start(); Thread t2 = new Thread(() -&gt; { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3e69120d217a4c54c25e150d360f03b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55ca84b7172659ebff20e6dd36c4ca3/" rel="bookmark">
			AD9在PCB上不自动捕捉焊盘中心设置办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将snap On All Layers前的复选框选中即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8530f5b48ed7645a554b9d7d3f43b51/" rel="bookmark">
			Ubuntu（WSL）安装PostgreSQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 PostgreSQL安装1.1 PostgreSQL安装命令1.2 PostgreSQL启动、停止、重启与状态查询命令1.3 PostgreSQL登录1.3.1 为账户postgres添加密码1.3.2 登录PostgreSQL数据库1.3.3 为数据库postgres管理员用户设置密码1.3.4 数据库日常登录访问 2 设置PostgreSQL远程访问2.1 数据库访问权限配置 pg_hba.conf2.2 数据库服务器参数配置 postgresql.conf2.3 重启PostgreSQL服务实现远程连接 3 卸载PostGreSQL12 1 PostgreSQL安装 sudo apt update 命令后，执行以下安装命令
1.1 PostgreSQL安装命令 sudo apt install postgresql postgresql-contrib 此命令一般会安装Ubuntu中默认能够安装的最高版本，安装后获取版本号。
psql --version psql (PostgreSQL) 12.9 (Ubuntu 12.9-0ubuntu0.20.04.1) 1.2 PostgreSQL启动、停止、重启与状态查询命令 sudo service postgresql status 用于检查数据库的状态。 ps -ef | grep postgresql 用于显示postgresql进程状态。 sudo service postgresql start 用于开始运行数据库。sudo service postgresql stop 用于停止运行数据库。sudo service postgresql restart 用于重启运行数据库。 sudo service postgresql status 12/main (port 5432): down sudo service postgresql start * Starting PostgreSQL 12 database server [ OK ] sudo service postgresql status 12/main (port 5432): online sudo service postgresql stop * Stopping PostgreSQL 12 database server [ OK ] sudo service postgresql status 12/main (port 5432): down sudo service postgresql restart * Restarting PostgreSQL 12 database server [ OK ] sudo service postgresql status 12/main (port 5432): online 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8530f5b48ed7645a554b9d7d3f43b51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000759394fdc0440d64c3f0f818c014f/" rel="bookmark">
			Spring Cloud之负载均衡组件Ribbon原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud之负载均衡组件Ribbon原理分析 前言一个问题引发的思考Ribbon的简单使用Ribbon 原理分析@LoadBalanced 注解@Qualifier注解 LoadBalancerAutoConfiguration 自动装配RestTemplateCustomizerLoadBalancerInterceptorRibbonLoadBalancerClient#execute ZoneAwareLoadBalancer 负载均衡器如何获取所有服务如何判断服务是否可用心跳检测 Task Ribbon 的负载均衡算法 总结 前言 在微服务中，对服务进行拆分之后，必然会带来微服务之间的通信需求，而每个微服务为了保证高可用性，又会去部署集群，那么面对一个集群微服务进行通信的时候，如何进行负载均衡也是必然需要考虑的问题。那么有需求自然就有供给，由此一大批优秀的开源的负载均衡组件应运而生，本文就让我们一起来分析一下 Spring Cloud Netflix 套件中的负载均衡组件 Ribbon。
一个问题引发的思考 首先我们来看一个问题，假如说我们现在有两个微服务，一个 user-center，一个 user-order，我现在需要在 user-center 服务中调用 user-order 服务的一个接口。
这时候我们可以使用 HttpClient，RestTemplate 等发起 http 请求，user-center 服务端口为 8001，如下图所示：
@RestController @RequestMapping(value = "/user") public class UserController { @Autowired private RestTemplate restTemplate; @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } @GetMapping("/order") public String queryOrder(){ return restTemplate.getForObject("http://localhost:8002/order/query",String.class); } } 而 user-order 服务中只是简单的定义了一个接口，user-order 服务端口为 8002：
@RestController @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/000759394fdc0440d64c3f0f818c014f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f3ebc204e28e4aefd393ff6f8d2387/" rel="bookmark">
			vue项目 前端跨域进行配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。 同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域； 如a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名有一个不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是浏览器的限制。理解这一点很重要！！！
1）首先建立两个文件并进行配置
***注意：不需要去引用，VUE_APP_开头的变量会被webpack自动加载；
2）配置路由
***注意mode："history"
Vue-router 中有hash模式和history模式，vue的路由默认是hash模式，一般开发的单页应用的URL都会带有#号的hash模式，因为整个应用本身而言就只有一个HTML，其他的都是通过router来渲染。简单介绍下两种模式：
hash —— 即地址栏 URL 中的 # 符号。比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。 ******最重要！ 例如：
//根据不同环境设置baseURL,最终发送的请求URL为：baseURL+发送请求时的url
//例如： baseUrl: '/dev-api'
//get请求 get('/test')
//最终发出的请求：/dev-api/test
3）vue.config.js进行配置
通过代理进行拦截，然后进行重新配置！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/159/">«</a>
	<span class="pagination__item pagination__item--current">160/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/161/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>