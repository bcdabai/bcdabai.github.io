<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f62ce4978efd4744711de6082cb16402/" rel="bookmark">
			欧拉系统openEuler21.03在使用yum命令的时候报错&amp;解决方案Errors during downloading metadata for repository ‘openEuler-sou
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 解决欧拉openEuler不同版本的使用yum命令404错误思路，本文是针对openEuler的21.03版本的问题。依次类推其实针对欧拉openEuler不同版本个人觉得应该解决方法都是一样的针对这个问题，大家后续遇到这样的问题，就可以先去看官网的地址和那个openEuler.repo文件中的地址是否一致，将其都替换成官网一样的地址，即可解决问题。
问题描述 在接到新系统的时候，当我需要在新系统安装某些软件时候，使用yum命令报错如下：
openEuler-source 721 B/s | 146 B 00:00 Errors during downloading metadata for repository 'openEuler-source': - Status code: 404 for https://repo.openeuler.org/openEuler-21.03/source/repodata/repomd.xml Error: Failed to download metadata for repo 'openEuler-source': Cannot download repomd.xml: Cannot download repodata/repomd.xml: All mirrors were tried
去网上找的解决方法，基本上如下操作：
#关闭防火墙和 selinux 并重启
sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
systemctl disable --now firewalld
#配源
vim /etc/yum.repos.d/openEuler.repo
...
#更新yum源
yum makecache
我按照上述方式试了，并不能解决这个问题，后面我突然看到欧拉其他版本解决方式来了灵感。
解决方法 1. 先去找欧拉的官方地址：https://archives.openeuler.openatom.cn/ 找到我们对应的欧拉的版本，在错误信息里面会有提示，在上述错误信息中我的欧拉版本是21.03
2. 根据官方地址，配置欧拉源 vim /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f62ce4978efd4744711de6082cb16402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/402b1bedc3736caea561a9257cc1dfb8/" rel="bookmark">
			基于征程5芯片的BEV感知方案与部署实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：8月24日，最新一期地平线「你好，开发者」自动驾驶技术专场在智东西公开课顺利完结直播。专场由地平线感知算法工程师朱红梅博士主讲，主题为《基于征程5芯片的BEV感知方案与部署实践》。
本文是此次专场主讲环节的实录整理。如果对直播回放以及Q&amp;A有需求，可以点击阅读原文前去观看。
各位智东西公开课的朋友们，大家晚上好，我是来自地平线的感知算法工程师朱红梅，今天很荣幸跟大家分享 《基于征程5芯片的BEV感知方案与部署实践》 。我将从五个方面去展开介绍。
文章目录 1. BEV感知框架总体介绍2. 时空融合模块与芯片部署3. 静态与Occupancy感知要素解析4. 动态感知预测端到端与芯片部署5. 实车部署与闭环验证 1. BEV感知框架总体介绍 随着2021年征程5芯片的发布，我们基于征程5芯片设计了 BEV的感知原型方案，输入的是车载多视角的图像序列或者多模信号，在网络内部进行时空双维度的中融合（middle fusion），使得神经网络能够原生输出鸟瞰视角下的动静态感知、预测结果。下面是一个框架图。
绿底部分表示纯视觉的信号处理，输入的是各摄像头的图像， 经过第一阶段的模型提取图像特征，通过视角转换做 BEV视角下的多视角空间融合；再对BEV的特征进行时序融合，进而送入第二阶段做BEV上的特征提取；最后，输入到head部分做感知要素的输出。如果系统里有Lidar，也会接入 Lidar点云。前期会做栅格化的编码处理，也会做时序融合，最后和视觉的BEV特征做中融合，同样也是送入到二阶段去做BEV上感知要素的输出。
蓝底的部分是已经参与过多轮的闭环迭代。关注地平线的同学应该知道在今年4月份的上海车展上，这部分内容已经支持了闭环的实车demo展示。在最近半年，我们对其中“动态障碍物检测”在感知要素功能上进行了扩充，基于它接了Transformer的 head，去做动态障碍物的Track id、速度估计、轨迹预测。虚线部分是目前我们正在研发的，也是想充分利用BEV上的动静态感知结果做动静态感知需要交互的要素输出，比如行为预测。
这里的纯视觉方案主要有两种模式。一种是面向双征程5芯片的行泊一体11v融合方案；另一种是面向单征程芯片的方案，其中行车7v融合、泊车5v融合。今天的分享主要针对视觉方案里的时空融合部分，感知要素的解析，还有关于动态的，特别是动态感知预测端到端的方案与部署的介绍。
2. 时空融合模块与芯片部署 首先介绍一下目前板端采用的是四平面的空间融合方法。它是以自车坐标系的xy平面作为基础平面，在此基础上增加了三个高度平面，希望获取更多不同高度的场景图像信息。时序融合这一块比较简单，我们会缓存上一时刻时序融合后的特征，利用帧间的自车运动将历史帧对齐到当前帧，并与当前帧的空间融合特征进行融合，再去卷积送入到后面的网络结构做感知输出。
那么为什么我们用这样的方案呢？
在研发前期，我们也对比了不同的空间融合方法，前期为了快速打通流程，采用了最简单的基于单平面IPM的方法，打通了整个框架的感知。之后去摸底了征程5上做基于深度的融合以及基于Transformer的融合方案。考核维度是在征程5上的延迟，假设前提条件是能够在征程5单核上独立跑这个模型到30fps以上，去设计相应的网络参数。
这里影响BEV的感知性能有两个关键参数，一个是一阶段的图像feature分辨率，另一个是BEV上的融合分辨率。 对于BEV上的融合分辨率是比较直接的，分辨率越高，对于一些小目标的感知以及点元素的感知更有优势。图像分辨率决定了二阶段输入的信息量。
这里有一个车道线模拟图，每一段车道线的物理尺寸是一样的。由于是透视投影，在图像中越远的车道线，它的成像像素会相对越少。BEV索引图像特征，一般是一个逆向实现的过程，而BEV上一般是等分辨率去设计的，比如说常用0.6、0.4米Grid分辨率。 当通过 BEV的坐标去索引场景中比较远的目标时，图像里的像素对应的物理分辨率就已经比 BEV上分辨率要低了，这时候BEV上就会出现特征重复，也就是常见的拉伸现象。反映到感知上，比如检测框可能会出现目标分裂成一串的现象，所以一阶段的 feature分辨率也是非常重要的。
我们抓取了中间这一列像素，去模拟2M图像和8M图像在50米处相邻两行像素的z值变化对比。可以看到，低分辨率的图像在相邻两行像素对应的物理范围变化已经达到2米多了。对于高分辨率的图像，它相邻的两像素只有0.6米左右。所以反过来看融合方案时，不仅要考虑单个任务是否满足一定的精度要求，还要考虑最后部署的时候，因为是多任务不同感知要素输出，所以希望一阶段的特征和BEV融合的分辨率能够更高一些。
从这个角度来看，目前基于Transformer的结构能够满足征程5单核30+FPS的一阶段分辨率和二阶段融合分辨率都比较低，并且在这个条件下延迟过高。而基于深度的融合方法一阶段相对单平面来说较低。另外没有采用它的一个原因是基于深度的部署针对征程5做了一些特定的改进，达到一个9.6ms的二阶段延迟。在原型方案验证的阶段，对于车上搭载不同数目的摄像头的灵活度是不够的，所以在这个阶段我们采用了平面映射融合方法。前期用单平面，而实际去做闭环验证的时候发现单平面对相机参数的泛化性、鲁棒性确实不够，且又比较敏感。所以我们在进一步的研发过程中去改进，通过多种测试、验证，最终采用四平面的融合方法，它在性能和延迟上面都能达到比较好的平衡。
对于时序融合，研发前期同样也会对比不同的时序融合方法，基本的做法都是先将历史的BEV特征对齐到当前帧，采用不同的融合方法去做时序融合。这里也是对比了融合不同帧数，用当时积累的实验数据做了10帧的验证。在10帧情况下，相对于仅空间有3.5个点的提升，对于latency，因为部署的时候是 recurrent模式，所以仅仅增加了1ms。
同样我们也对比了获取历史帧的两种方法。一种是等时间间隔的去截取历史信息，另一种是等空间间隔。等时间间隔是用系统的时间戳去索引，读取相应的帧。等空间间隔就是随着自车的运动算平移的距离，然后去取帧。最终我们发现，6帧的等空间间隔和10帧的等时间间隔性能是差不多的，两者也可以做结合，但多一些融合帧提升并不是很大。所以为了部署简单，我们目前采用等时间间隔的时序融合方法。
时序融合在训练和部署的时候有几个点可能存在差异，一个是对齐相邻两帧的时候用的Odometry，为了使训练的模型性能和实车部署的一致性，遵守的一个原则是模型输入尽量和板端信号一致。我们用轮速计的Odometry去做模型训练，在不同的方法获取的Odometry上做测试。发现如果和训练时候的帧间间隔是一致的，那么这个因素影响不是很大。 另外，比如100ms间隔取得了历史帧，用10fps训练数据训练的模型，在10fps、15fps、30fps上去做测试。得到的结论是，如果部署和训练的时候差异比较大，指标差距会更大一些。实际的系统帧率是受系统实时的负载影响，可能无论怎么设置训练时候的帧间间隔，都不是完全对齐的。一般周视感知能够在15fps左右，基本上能满足功能需求，在1.5个点的范围也是能接受的。这部分也可以通过一些数据增强的手段，使得时序训练数据的分布更丰富，缓解这样的问题。
另外一个是时序在训练的时候，如果没有特定的优化，时序数据随着帧数的增加，可能出现内存、显存的一些OOM（Out of Memorry）问题，从而导致训练速度过慢。训练的方法是采用feature cache策略去缓解或者避免这样的问题出现。但是在板端部署时考虑到板端的内存限制和加载回来的带宽，最终板上采用最精简的一种策略recurrent模式。
3. 静态与Occupancy感知要素解析 静态感知的一个重要的组成就是真值，BEV上的真值是怎么来的呢？
从最开始研发到现在，用到过三种静态真值。最开始用过高精地图，现在大规模使用的是基于多模的真值生产链路， 目前也有纯视觉的局部建图结果参与到了训练当中。对于建图质量的好坏，是由我们公司专门的4D-Label团队负责开发。在地平线「你好，开发者」自动驾驶技术专场上一讲，地平线4D标注技术负责人隋伟博士也跟大家分享了《面向BEV感知的4D标注方案》，如果感兴趣可以去回顾一下。
对于算法而言，算法同学要更多地参与到标注规则的制定。即使真值是大模型刷的，大模型也需要真值，所以标注规则需要感知算法的同学深入参与，特别是实际测试场景是非常复杂的。标注规则的一个参考条件是建图得到的Lidar点云底图，是一个BEV上的强度图，再通过参考图像或者视频去判断，才能去标注。比如车道线，要标注颜色、一些功能属性和一些下游功能所必须的且从Lidar底图上无法得到的，都需要结合图像去做。 对于路面标志一般都是去标旋转框，对需要有明确方向指向的，需要标有序的点列。泊车的要素基本上是以关键点的标注方式去标车位、轮档器、减速带等。
模型的输出跟标注是对应的。标注的信息会做一定的预处理，生成模型的真值。真值做监督输出，才能满足下游的功能需求。车道线输出的是实例点列位置和属性；交叉点是点位置和类型；路沿也是实例位置和类型；路面离散标志是检测框和类型。这些静态感知要素是非常丰富的。对于模型方案，有一个前景提取的分类学习，一个精确位置的回归学习，车道线还有一个实例特征的学习。整体来说静态感知方案比较常规，在解析的时候，像车道线这种线元素会通过Class Map的score去提取前景，再通过 Embedding的相似度去做聚类得到这个点列，反向地去属性特征上去索引这些点相应的特征。
对于车道线而言，在实际软件解析的时候，要考虑软件上面的延迟，按照预设通过垂直点去大致地估计车道线的方向，沿着这个方向做一维搜索，缩减车道线的后处理时间。现在我们的方案最新优化，对这部分处理不到3ms。路面标识、交叉点的检测点或者框这一类的解析是CenterNet那一套：卡score→maxpolling→TopK→属性提取→输出。
对于泊车要素，车位会输出有序的角点位置、占用情况、车位的类型方向；轮挡器是有序的端点位置、类型；停车场下的地锁、立柱都是以检测框输出，和前面的点和线框的解析思路是一样的。这里的车位是有两个小head，其中一个是为了获取车位的整体属性，比如它的占用情况，车位类型是平行库位还是垂直库位。还有一个Local的head，是为了精确地估计库位的角点，因为对库位这种角点的精度要求非常高。 在得到了比较精确的之后，再和 global下面得到的粗糙的角点位置去算点的匹配。因为这个点是有序的，卡一个距离的阈值即可，匹配完之后做角点坐标的替换，就可以得到一个库位的精确的角点坐标。
这是我们性能上的表现。地平线的2D感知方案之前也是打磨了比较久，对BEV的感知来说，相当于有一个很好的参考baseline。
车道线和路面标志相比于2D的方案，在测距上，比如车道线在不同距离段，路面标志的箭头、停止线，都有一个比较大的提升。对于车位，地平线也有一个前融合方案，送入网络前先把4路鱼眼图像先做IPM融合，得到覆盖自车周围360°的IPM图像，再融入网络做车位的输出。现在BEV就是前面框架介绍的，在模型内部对feature 做融合。目前在这三类库位上面同样都是有比较大的提升。
看一下这个视频，这是一个高速的车道线的可视化展示，有一条宽虚线，接下来出匝道。这里是一个分流点、虚实变化点，箭头代表方向。
对于泊车的车位感知，这里选了一个泊入的场景，红线代表入口线，黄色的x代表占用，黄色的小框是停车场的立柱，草绿色的是轮档器。
接下来讲Occupancy的感知。首先说一下Occupancy是一个2D占用图，是一个二值图，0表示未占用，1表示占用，我们内部称它为Freespace。传统的Freespace是图像分割做后处理，去计算在BEV下的可行驶区域。而BEV上做就比较自然一些，直接在 BEV上去输出一个这样的二值图。它的真值依赖Lidar分割模型+检测模型+多帧聚合点云卡高度的阈值，去获取地面上的一些障碍物。 Lidarseg主要是先得到基础面，把路平面这一类作为可行驶区域；Lidar3D检测是去补充白名单的动态障碍物的占用真值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/402b1bedc3736caea561a9257cc1dfb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83567affdd2ca402f19c057effa0713/" rel="bookmark">
			【Linux】——网络基础：http协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
应用层
认识协议
协议的概念
传输结构化数据
序列化和反序列化
网络版本计算器
服务器端Server
客户端Client
协议定制
其它
运行效果
HTTP协议
HTTP的简介
认识URL
urlencode和urldecode
HTTP协议格式
HTTP请求
HTTP响应
HTTP的方法 GET和POST方法
POSTMAN演示
HTTP的状态码
HTTP常见header
Cookie和session
前言 本文主要探究理解应用层的作用, 介绍HTTP协议的工作原理，同时介绍一些常用的分析网络问题的工具和方法。在详细了解HTTP协议之后，我们不难发现在网络通信的过程中使用HTTP协议存在安全隐患。因此还会详细介绍基于HTTP协议的HTTPS协议是如何在网络通信的过程中还能够保证数据的安全性。
应用层 应用层是计算机网络体系结构中的一个层级，位于网络协议栈的最顶部。它提供一些应用程序与网络之间的接口，使得应用程序能够通过网络进行通信和数据交换。
在应用层，各种应用程序可以利用不同的协议来实现数据传输和通信。一些常见的应用层协议包括HTTP、FTP、SMTP、DNS等。这些协议定义了数据传输的格式、交互方式和错误处理等规范。
应用层的功能包括数据编码与格式化、数据压缩、安全认证、数据加密、资源共享等。它为用户提供了各种各样的应用，例如网页浏览器、电子邮件客户端、文件传输工具等。
总结来说，应用层是网络协议栈中负责为应用程序提供通信接口的层级，它使得不同的应用程序能够通过网络进行数据交换和通信。
网络应用程序体系结构
从应用程序研发者的角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合。在另一方面，应用程序体系结构（ application architecture)由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。在选择应用程序体系结构时，应用程序研发者很可能利用现代网络应用程序中所使用的主流体系结构之一:客户-服务器体系结构。
客户——服务器体系结构
在客户-服务器体系结构（client- server architecture）中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。值得注意的是利用客户-服务器体系结构,客户相互之间不直接通信。客户-服务器体系结构的另一个特征是该服务器具有固定的、周知的地址，该地址称为IP地址。因为该服务器具有固定的、周知的地址，并且因为该服务器总是打开的，客户总是能够通过向该服务器的IP地址发送分组来与其联系。具有客户-服务器体系结构的非常著名的应用程序包括Web,FTP以及电子邮件。
在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。为此，配备大量主机的数据中心(data center)常被用于创建强大的虚拟服务器。一个数据中心能够有数十万台服务器，它们必须要供电和维护。此外，服务提供商必须支付不断出现的互联和带宽费用，以发送和接收到达/来自数据中心的数据。
应用层协议
应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。
其中我们主要介绍HTTP协议：
http：Web的应用层协议是超文本传输协议（即http，它是web的核心）。HTTP由两个程序实现:一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。
认识协议 协议是一种 "约定"。使用过socket网络套接字通信的人应该都知道socket api的接口, 在读写数据时, 都是按 "字符串" 的方式来发送接收的。如果我们要传输一些"结构化的数据" 怎么办呢?比如下面的情况：
我们想要实现一个网络版本的计算器，计算器想要完成一个计算，最好是直接传给它一个包含着两个操作数和一个操作符的结构体对象。但是使用socket通信的时候，UDP/TCP发送的是数据报或者字节流的数据。所以此时我们如果想要发送一些“结构化的数据”就需要制订协议了。
//网络计算器需要的数据是结构体 typedef struct request{ int x; //左操作数 int y; //右操作数 char op; //操作符 }; //网络通信发送的数据是string string request = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f83567affdd2ca402f19c057effa0713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cef8bf406b37198c7021564bbd957bd/" rel="bookmark">
			10-65 查询课程成绩最高二人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题目要求编写SQL语句，
检索C002号课程的成绩最高的二人学号，姓名与成绩
表结构: 请在这里写定义表结构的SQL语句。例如：
CREATE TABLE `stu` (
`sno` char(4) NOT NULL,
`sname` char(8) NOT NULL,
`sex` tinyint(1) DEFAULT NULL,
`mno` char(2) DEFAULT NULL,
`birdate` datetime DEFAULT NULL,
`memo` text,
PRIMARY KEY (`sno`),
);
CREATE TABLE `sc` (
`sno` char(4) NOT NULL,
`cno` char(4) NOT NULL,
`grade` decimal(6,1) DEFAULT NULL,
PRIMARY KEY (`sno`,`cno`),
CONSTRAINT `fk_sc_sno` FOREIGN KEY (`sno`) REFERENCES `stu` (`sno`)
);
表样例 请在这里给出上述表结构对应的表样例。例如
stu表：
sc表：
输出样例: 请在这里给出输出样例。例如：
select stu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cef8bf406b37198c7021564bbd957bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/471572c40b67272d57696c4b66f1526c/" rel="bookmark">
			GPIO输入输出模式原理(八种工作方式附电路图详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几篇博文讲的不错，可参照着理解：
STM32下拉输入模式与振动传感器的使用
“上拉电阻与下拉电阻”通俗解读
上、下拉电阻（定义、强弱上拉、常见作用、吸电流、拉电流、灌电流）
个人总结：
模拟量选浮空输入，模拟量是连续变化的值数字量就两种状态0和1，选上拉和下拉，通过“拉高拉低”增益效果，消除中间态“”模糊电压“，同时赋予电路确定的初始值高或低。 目录 STM32引脚说明GPIO种类GPIO基本结构GPIO输入输出的8种模式上拉输入模式下拉输入模式浮空输入模式模拟输入模式开漏输出模式开漏复用输出模式推挽输出模式推挽复用输出模式 模式用途1、 GPIO_Mode_AIN ：模拟输入2、GPIO_Mode_IN_FLOATING ：浮空输入3、GPIO_Mode_IPD：下拉输入4、GPIO_Mode_IPU：上拉输入5、GPIO_Mode_Out_OD：开漏输出6、GPIO_Mode_Out_PP：推挽输出7、GPIO_Mode_AF_OD：复用开漏输出8、GPIO_Mode_AF_PP：复用推挽输出 总结与分析1、什么是推挽结构和推挽电路2、开漏输出和推挽输出的区别3、STM32如何选择I/O模式 STM32F1xx官方资料：
《STM32中文参考手册V10》-第8章通用和复用功能IO(GPIO和AFIO )
芯片数据手册（datasheet)
STM32引脚说明 GPIO是通用输入/输出端口的简称，是STM32可控制的引脚。GPIO的引脚与外部硬件设备连接，可实现与外部通讯、控制外部硬件或者采集外部硬件数据的功能。
STM32的大部分引脚除了当GPIO使用之外，还可以复用位外设功能引脚（比如串口），这部分在【STM32】STM32端口复用和重映射（AFIO辅助功能时钟） 中有详细的介绍。
GPIO种类 本博板子STM32F103ZET6共有7组IO口，每组16个，共16×7=112个，分别为：
GPIOA——&gt;PA0、PA1、PA2…PA15
GPIOB——&gt;PB0、PB1、PB2…PB15
.
.
.
GPIOG——&gt;PG0、PG1、PG2、…PG15
GPIO基本结构 每个GPIO内部都有这样的一个电路结构，这个结构在本文下面会具体介绍。
这边的电路图稍微提一下：
保护二极管：IO引脚上下两边两个二极管用于防止引脚外部过高、过低的电压输入。当引脚电压高于VDD时，上方的二极管导通；当引脚电压低于VSS时，下方的二极管导通，防止不正常电压引入芯片导致芯片烧毁。但是尽管如此，还是不能直接外接大功率器件，须加大功率及隔离电路驱动，防止烧坏芯片或者外接器件无法正常工作。P-MOS管和N-MOS管：由P-MOS管和N-MOS管组成的单元电路使得GPIO具有“推挽输出”和“开漏输出”的模式。这里的电路会在下面很详细地分析到。TTL肖特基触发器：信号经过触发器后，模拟信号转化为0和1的数字信号。但是，当GPIO引脚作为ADC采集电压的输入通道时，用其“模拟输入”功能，此时信号不再经过触发器进行TTL电平转换。ADC外设要采集到的原始的模拟信号。 这里需要注意的是，在查看《STM32中文参考手册V10》中的GPIO的表格时，会看到有“FT”一列，这代表着这个GPIO口时兼容3.3V和5V的；如果没有标注“FT”，就代表着不兼容5V。 GPIO输入输出的8种模式 GPIO支持4种输入模式（浮空输入、上拉输入、下拉输入、模拟输入）和4种输出模式（开漏输出、开漏复用输出、推挽输出、推挽复用输出）。同时，GPIO还支持三种最大翻转速度（2MHz、10MHz、50MHz）。
每个I/O口可以自由编程，但I/O口寄存器必须按32位字被访问。
程序中标识模式GPIO_Mode_AIN模拟输入GPIO_Mode_IN_FLOATING浮空输入GPIO_Mode_IPD下拉输入GPIO_Mode_IPU上拉输入GPIO_Mode_Out_OD开漏输出GPIO_Mode_Out_PP推挽输出GPIO_Mode_AF_OD复用开漏输出GPIO_Mode_AF_PP复用推挽输出 下面将具体介绍GPIO的这八种工作方式：
上拉输入模式 默认情况下输入引脚数据为1，高电平。
上拉输入模式下，I/O端口的电平信号直接进入输入数据寄存器。但是在I/O端口悬空（在无信号输入）的情况下，输入端的电平保持在高电平（自己理解：上拉电阻连接电压）；并且在I/O端口输入为低电平的时候，输入端的电平也是低电平（自己理解：上拉电阻上的电压和端口导通）。
施密特触发器：施密特就是为了防止在某一个临界电平的情况出现各种情况的抖动出现，为了稳定我们的输出而设计的。
施密特触发器采用电位触发方式，其状态由输入信号电位维持；对于负向递减和正向递增两种不同变化方向的输入信号，施密特触发器有不同的阈值电压。
下拉输入模式 默认情况下输入引脚为0，低电平。
下拉输入模式下，I/O端口的电平信号直接进入输入数据寄存器。但是在I/O端口悬空（在无信号输入）的情况下，输入端的电平保持在低电平；并且在I/O端口输入为高电平的时候，输入端的电平也是高电平。
浮空输入模式 浮空输入模式下，I/O端口的电平信号直接进入输入数据寄存器。也就是说，I/O的电平状态是不确定的，完全由外部输入决定；如果在该引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的。
通常用于IIC、USART。
模拟输入模式 模拟输入模式下，I/O端口的模拟信号（电压信号，而非电平信号）直接模拟输入到片上外设模块，比如ADC模块等。模拟信号一般：3.3v 5v 9v。
开漏输出模式 可以输出0和1，适用于电平不匹配场合，要得到高电平需要上拉电阻才行。
开漏输出模式下（上拉电阻+N-MOS管），通过设置位设置/清除寄存器或者输出数据寄存器的值，途经N-MOS管，最终输出到I/O端口。这里要注意N-MOS管，当设置输出的值为高电平的时候，N-MOS管处于关闭状态，此时I/O端口的电平就不会由输出的高低电平决定，而是由I/O端口外部的上拉或者下拉决定；当设置输出的值为低电平的时候，N-MOS管处于开启状态，此时I/O端口的电平就是低电平。同时，I/O端口的电平也可以通过输入电路进行读取；注意，I/O端口的电平不一定是输出的电平。
开漏复用输出模式 开漏复用输出模式，与开漏输出模式很是类似。只是输出的高低电平的来源，不是让CPU直接写输出数据寄存器，取而代之利用片上外设模块的复用功能输出来决定的。
片内外设功能：TX1，MOSI，MISO，SCK，SS
推挽输出模式 可以输出高低电平0和1，适用于双向IO使用。
推挽输出模式下（P-MOS管+N-MOS管），通过设置位设置/清除寄存器或者输出数据寄存器的值，途经P-MOS管和N-MOS管，最终输出到I/O端口。这里要注意P-MOS管和N-MOS管，当设置输出的值为高电平的时候，P-MOS管处于开启状态，N-MOS管处于关闭状态，此时I/O端口的电平就由P-MOS管决定：高电平；当设置输出的值为低电平的时候，P-MOS管处于关闭状态，N-MOS管处于开启状态，此时I/O端口的电平就由N-MOS管决定：低电平。同时，I/O端口的电平也可以通过输入电路进行读取；注意，此时I/O端口的电平一定是输出的电平。
推挽复用输出模式 推挽复用输出模式，与推挽输出模式很是类似。只是输出的高低电平的来源，不是让CPU直接写输出数据寄存器，取而代之利用片上外设模块的复用功能输出来决定的。
片内外设功能IIC的SCL、SDL
模式用途 1、 GPIO_Mode_AIN ：模拟输入 一般用于ADC模拟输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/471572c40b67272d57696c4b66f1526c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736830dd44e7a8316d43097d3f06b304/" rel="bookmark">
			代码随想录算法训练营20期|第三十一天|● 理论基础 ● 455.分发饼干 ● 376. 摆动序列 ● 53. 最大子序和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理论基础 贪心的本质是选择每一阶段的局部最优，从而达到全局最优
贪心算法一般分为如下四步：
将问题分解为若干个子问题找出适合的贪心策略求解每一个子问题的最优解将局部最优解堆叠成全局最优解 455.分发饼干 感觉还没背熟，要多刷这个章节
class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int res = 0; int idx = s.length - 1; //遍历胃口 for (int i =g.length - 1; i &gt;= 0; i--) { if (idx &gt;= 0 &amp;&amp; s[idx] &gt;= g[i]) { res++; idx--; } } return res; } } 376. 摆动序列 三种情况：
1. 上下坡中有平坡
2. 数组首尾两端
3. 单调坡中有平坡
class Solution { public int wiggleMaxLength(int[] nums) { if (nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/736830dd44e7a8316d43097d3f06b304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c119ec6e712485b3316a537549cf6886/" rel="bookmark">
			网络原理（一）网络基础，包括IP ，网络相关的定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络基础，包括IP ，网络相关的定义 网络基础冲突域广播域DNSNATNAPT 网络基础 以下图片是书上的网图。
什么是IP地址？
IP地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址。P地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。
格式：通常是一个32位的二进制数，被分割成4个8位二进制
IP地址分为两个部分，网络号和主机号
网络号：标识网段，保证相互连接的两个网段具有不同的标识；主机号：标识主机，同一网段内，主机之间具有相同的网络号，但是必须有不同的主机号
这个因为时代问题，现在大部分存在的IP地址通常都是 IPv4 ，使得所有的IP地址会有用完的一天。此时就有可能出现IP不够用的一天，并且在中美问题出现问题的今天，IP地址的分配是有美国进行全球分配的，对于国防和网络安全存在隐患，所以经过国家统一调度，使得国内的设备现在支持两种 IP 方式，也就是 IPv6 和 IPv4，目前国内还在沿用 IPv4 ，但是遇到 特殊状况，就可以随时启动 IPv6 ，规避风险。
在上述分类中：存在 IP 地址浪费的问题：
单位一般会申请B类网络（C类连接主机数量有限），但实际网络架设时，连接的主机数量又常远
小于65534（B类连接主机数），造成IP地址浪费；同理，A类网络的IP地址也会造成大量的浪费。
当一个单位申请了一个网络号。他想将该网络能表示的IP地址再分给它下属的几个小单位时，如果
在申请新的网络就会造成浪费。
而为了解决子网掩码的问题，引入了子网掩码来进行子网划分。
什么是子网掩码？
子网掩码格式和IP地址一样，也是一个32位的二进制数。
其中左边是网络位，用二进制数字“1”表示，1的数目等于网络位的长度右边是主机位，用二进制数字“0”表示，0的数目等于主机位的长度 作用：
划分A，B，C三类 IP 地址子网
如一个B类IP地址：191.100.0.0，按A ~ E类分类来说，网络号二进制数为16位网络号+16位主机号。假设使用子网掩码255.255.128.0（即17） 来划分子网，意味着划分子网后，高 17 位都是网络位 / 网络号，也就是将原来16位主机号，划分为1位子网号+15位主机号。
IP地址组成为：网络号+子网号+主机号，网络号和子网号统一为网络标识（划分子网后的网络号 / 网段）
网络通信时，子网掩码结合IP地址，可以计算获得网络号（划分子网后的网络号）及主机号（划分子网后的主机号）。一般用于判断目的IP与本IP是否为同一个网段。 计算方式：
将 IP 地址和子网掩码进行“按位与”操作（二进制相同位，与操作，两个都是1结果为1，否则为0），得到的结果就是网络号。将子网掩码二进制按位取反，再与 IP 地址位与计算，得到的就是主机号。
特殊的 IP 地址
主机号微 0 的 ip ，192.168.0.0 就是网络好，局域网里不应该存在某个主机，主机号微 0
主机号全为 1 的IP ，广播地址，往这个地址发送UDP 数据包，此时的数据包就会发给整个局域网中的所有主机（TCP不支持广播）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c119ec6e712485b3316a537549cf6886/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b23af07d5b93f2cc7114e666604a00aa/" rel="bookmark">
			给孩子讲的睡前寓言故事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哦, 对了, 我没有孩子, 那就讲给你听吧
乖
三季人 子贡在门口扫地
来了一个人说: 你是孔子的徒弟, 来, 我考考你, 一年有几个季节?
子贡说: 一年是四季啊
那人说: 不对, 是三季
子贡说: 四季
那人说: 三季
子贡说: 四季
那人说: 三季
然后俩人谁也不服谁, 吵起来了
咱们去问孔子吧, 谁输了谁磕头道歉
孔子说: 一年三季, 你给人磕头道歉吧
完事, 那人走了
子贡问孔子: 一年四季, 我没错啊?
孔子说:
你看那人, 一身发绿, 他是什么? 他是蚂蚱, 蚂蚱过完秋天就死了, 他见不到冬天, 所以他是三季人
你一年四季, 没错. 他一年三季, 也没错
所以, 你和他吵, 吵不出结果来
那你跟他吵什么呢?
塞翁失马 从前, 有个老爷爷叫塞翁, 家里有一匹马
有一天, 马跑了
塞翁说: 不一定是坏事
过了几天, 马自己回来了
还带了另一匹马回来
塞翁说: 不一定是好事
那匹马是野马
塞翁的儿子骑马, 把腿摔断了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b23af07d5b93f2cc7114e666604a00aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3299d6d355490d0506a17e009dd105a2/" rel="bookmark">
			docker容器内访问宿主机127.0.0.1服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker容器内访问宿主机127.0.0.1服务 原创 技术生活 技术生活 2020-04-15 09:00
点击上方”技术生活“，选择“设为星标”
做积极的人，而不是积极废人
背景
原因分析
解决方案
背景
已经通过docker启动的elasticsearch 服务，监听端口9200。在宿主机中直接通过http://127.0.0.1:9200 可以直接访问，但是通过docker访问缺不行，访问url：http://127.0.0.1:9200 或者http://localhost:9200
原因分析
docker是一个虚拟环境,127.0.0.1和localhost指的是虚拟环境内部,而不是外部宿主机,所以无法这样访问.
解决方案
1、 对于mac和windows,可以使用host.docker.internal替换127.0.0.1,如http://host.docker.internal:9200 (亲测好使)
2、对于Linux可以采用如下方案
创建一个桥接网络
下面的localNet是网络名字,可自行修改;关于192.168.0.0这个子网,也可以自行定义.
默认按照下面的命令,执行后将可以通过192.168.0.1访问宿主机.
docker network create -d bridge --subnet 192.168.0.0/24 --gateway 192.168.0.1 localNet 使用192.168.0.1替换127.0.0.1,如http://192.168.0.1:9200
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e43ec20fba86cd546cbb21b633cf85/" rel="bookmark">
			Markdown格式下符号及数学公式的输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		符号 文章目录 符号上下标:运算符：向量：微积分：不定积分定积分二重积分三重积分极限 累加累乘括号：省略号：数学符号百分号约等号向上/下取整希腊字母：集合运算符：对数符号：排列组合:箭头符号：三角运算符：分段函数的写法在数学公式中加空格绝对值输出矩阵阵列公式推导回归方程符号说明: 上下标: d p i dp_{i} dpi​ : $dp_{i}$
d p a r i dp_{ar_{i}} dpari​​ : $dp_{ar_{i}}$
a 2 2 a^{2^2} a22 : $a^{2^2}$
A i − 1 A_{i-1} Ai−1​ : $A_{i-1}$
A i − 1 A^{i-1} Ai−1 : $A^{i-1}$
运算符： 乘号 × \times × ：$\times$ d p i = d p i − 1 × ( 1 − p ) dp_{i} = dp_{i-1} \times (1-p) dpi​=dpi−1​×(1−p) : $dp_{i} = dp_{i-1} \times (1-p)$ 除号 ÷ \div ÷ : $\div$加减号 ± \pm ± : $\pm$开方 x \sqrt{ x } x ​ : $\sqrt{x}$开n次方 x n \sqrt[ n ]{ x } nx ​ : $\sqrt[n]{x}$ 如果要把符号往正上方或者正下方放
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33e43ec20fba86cd546cbb21b633cf85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18af9ebbdf37df6cf78e74483b516034/" rel="bookmark">
			2023 高教社杯 数学建模国赛（C题）深度剖析|数学建模完整代码&#43;建模过程全解全析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9月7日18：00开赛后持续更新！！！
当大家面临着复杂的数学建模问题时，你是否曾经感到茫然无措？作为2021年美国大学生数学建模比赛的O奖得主，我为大家提供了一套优秀的解题思路，让你轻松应对各种难题。
我的解题思路是基于数学建模领域的前沿理论和实践研究，具有极强的创新性和实用性。我深入分析了各种数学建模问题，并总结出了一套行之有效的解决方案，帮助大家在竞赛中脱颖而出，或在实际情景中解决问题。我们的团队既注重理论分析，又重视实际应用。在此次美赛中，我们依据实际问题出发，结合数学建模理论进行分析，并给出可行的解决方案。通过我的解题思路，你可以快速理解各种数学建模问题，并有效地解决它们。
我的解题思路的实用性得到了众多用户的认可，许多人已经使用我的方法成功地解决了各种问题，了解了各种思路和技巧。通过使用我的解题思路，大家可以快速理解和掌握数学建模问题，并且取得更好的成绩和效果。
希望这些想法对大家的做题有一定的启发和借鉴意义。
问题重述： 在生鲜商超中，一般蔬菜类商品的保鲜期都比较短，且品相随销售时间的增加而变差， 大部分品种如当日未售出，隔日就无法再售。因此，商超通常会根据各商品的历史销售和需 求情况每天进行补货。 由于商超销售的蔬菜品种众多、产地不尽相同，而蔬菜的进货交易时间通常在凌晨 3:00- 4:00，为此商家须在不确切知道具体单品和进货价格的情况下，做出当日各蔬菜品类的补货 决策。蔬菜的定价一般采用“成本加成定价”方法，商超对运损和品相变差的商品通常进行 打折销售。可靠的市场需求分析，对补货决策和定价决策尤为重要。从需求侧来看，蔬菜类 商品的销售量与时间往往存在一定的关联关系；从供给侧来看，蔬菜的供应品种在 4 月至 10 月较为丰富，商超销售空间的限制使得合理的销售组合变得极为重要。
问题 1 蔬菜类商品不同品类或不同单品之间可能存在一定的关联关系，请分析蔬菜各 品类及单品销售量的分布规律及相互关系。
1. 数据预处理：
· 首先，从附件2中提供的销售流水明细数据中，筛选出与蔬菜类商品相关的数据。
· 对数据进行清洗，包括去除缺失值、异常值，以确保数据的质量。
· 将销售日期与销售数量按蔬菜品类或单品进行分类。
2. 描述性统计分析：
· 对每个蔬菜品类和单品的销售量进行统计分析，计算平均值、方差、中位数等统计量。
· 绘制销售量的直方图和箱线图，以了解销售量的分布情况。
3. 相关性分析：
· 利用统计工具（如相关系数）分析不同蔬菜品类或单品之间的销售量关联性。
· 绘制散点图来可视化销售量之间的关系。
· 数据准备：根据问题1的目标，选择需要分析的蔬菜品类或单品的销售数据，将其提取出来。
· 计算相关性：使用统计方法（如皮尔逊相关系数、斯皮尔曼相关系数）来计算不同蔬菜品类或单品之间的销售量相关性。
· 可视化：绘制散点图或热力图，将相关性可视化，以便更清晰地观察不同品类或单品之间的关系。
4. 时间序列分析：
· 对于每个蔬菜品类或单品，可以将销售量随时间的变化进行时间序列分析，识别销售趋势和季节性。
· 使用时间序列模型（例如ARIMA模型）来预测未来的销售量。
· 数据准备：选取需要分析的蔬菜品类或单品的销售数据，并按时间进行排序。
· 时间序列分解：将时间序列数据拆解为趋势、季节性和噪声成分，以便更好地理解销售趋势。
· 模型拟合：根据时间序列的性质，选择合适的时间序列模型，如ARIMA模型。拟合模型并进行参数估计。
· 预测未来销售量：使用拟合的模型进行未来销售量的预测，以了解可能的销售趋势。
5. 聚类分析：
· 使用聚类分析方法（如K均值聚类）来将蔬菜品类或单品进行分组，找出销售行为相似的商品群组。
· 进一步研究每个群组内的销售量关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18af9ebbdf37df6cf78e74483b516034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed2a0c5f8194eaa1260014681b9878a/" rel="bookmark">
			Shell编写清除日志脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Shell编写清除日志脚本 一、shell编写清除日志脚本，清除日志并保留五个最新日志
while [1] do date="$(date +%Y%m%d)" ReservedNum = 5#保留文件数量 rm_file_dir="/app/hfis/log" cd $rm_file_dir #进入文件 RootDir=$(cd $(dirname $0);pwd)#获取当前路径 FileNum=$(ls -l|grep hfis-app.log.|wc -l)#查找文件数量 OldFile=$(ls -trl hfis-app.log.* |head -1)#找出最早的文件，只显示一条 echo $OldFile#显示最早的文件 if[$RootDir == $rm_file_dir];then#判断两个目录是否一致 while(($FileNum&gt;$ReservedNum))#文件数超过数量才执行 do echo "Delete File:"$RootDir'/'$OldFile #打印要删除的文件 rm -f $RootDir'/'$OldFile #删除文件 let "FileNum--" OldFile = $(ls -trl hfis-app.log*|head -1)#更新最早文件 done else echo "error file path" #错误打印，请确认文件目录 fi sleep 300 done 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ded3b17446135b49859ed1bb86d9a68b/" rel="bookmark">
			软件测试适合零基础学么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零基础学习软件测试不失为一个好的选择，虽然IT行业里对小白最友好的非软件测试莫属了，但是也要看你个人在学习软件测试这件事上面花费了多少的时间和努力了~
每年毕业季，IT行业依然是比较热门且收入是最高的行业。对于应届毕业生来说想要进入IT行业，除了前后端开发，软件测试是个不错的选择，至于好不好找工作还是取决于你的综合能力的，比如，学历，年龄，最关键的还是技术能力，接下来就说说原因：
问题一、什么人适合学测试？
可以分为几大类：
1、0基础、0经验、在职的想转行的小白用户
2、其他开发工程师快速系统学习测试的
3、计算机、通信、电信、网络专业的大学生，专业对口
4、想快速转行测试的。
5、对测试和测试工具感兴趣的。
6、自学过一点测试，想系统学习测试的。
问题二、学测试职业未来职业发展有什么空间？
从两种不同的路径发展来看：
1、管理路线➡测试工程师➡中级测试工程师➡测试主管
2、技术路线➡软件测试工程是➡中级测试工程师➡高级测试工程师➡测试专家➡测试总监
问题三、测试对年龄、学历有要求吗？
学历至少是大专及以上，小学、初中、高中学历的人员，如果是奔着就业来的，不建议学习测试，因为现在招聘都看学历，学历很低，不太好找工作。同时学历较低的人群，接受测试的技术能力较差，理解技术比较困难，后期毕业和找工作都不太容易。
目前测试行业现状 软件越来越多，要靠质量取胜，就倒逼测试人员需求越来越大 使用软件产品的过程中，出现影响用户体验的问题，会大大减少用户的粘性和信心，给企业带来不可估量的损失。
通俗来说，软件测试，就是测试软件的过程，包括软件功能、易用性、性能、安全等质量维度的测试。
保障软件产品正式发布后的质量，提升用户对产品的体验和信心。
但软件给我们带来极大的便利的同时，也给人们带来各种各样的麻烦。有兴趣可以去搜一下软件业最著名的十大Bug，都是惊天动地。在我国，由于很多软件企业存在着“重开发、轻测试”的现象，造成日后软件产品质量问题频出。只要留心我们生活中的日常，就会发现软件bug导致的各种麻烦：比如红绿灯控制系统bug，导致交通瘫痪；地铁控制系统出bug，导致人们上班迟到；关键时刻手机卡顿死机，导致很多正常的生活工作无法开展……
随着国内软件行业的深入发展，人们生活水平越来越高，这就导致人们对软件质量的要求也越来很高，这就倒逼软件企业要靠软件产品质量去占领市场，随之推动的就是企业对测试人员的需求越来越大。
测试人才缺口30万，最近两年薪资频频跳涨 与之相反，由于软件测试最近几年才引起重视，大学教育完全没有跟上，就算是培训机构，软件测试相关培训也是少之又少，软件测试人才严重短缺，导致很多企业只好退而求其次拿软件开发人员急用。据中华英才网显示，目前软件测试人才缺口在30万人以上。人才缺口必然导致的是薪资的跳涨。据职友集统计，软件测试人才在2015年和2017年这两年，行业薪资跳涨率分别达到了40%和33%。
当前自动化测试已成风口，人才奇缺 测试其实可以细分为很多种类。仅按照是否需要编程这个维度来分，可以分为手工测试，自动化测试，测试开发。目前测试领域存在突出矛盾：一方面企业需要技术层级稍高的测试人才，比如自动化测试，性能测试；另一方面却是目前测试从业人员因知识不成体系，只能从事简单的手工测试工作。所以自动化测试人才奇缺，只要掌握了一定的自动化测试技术，往往就会被市场争抢，当然也就能高薪资。
所以对于我们新人来说，首先选择了正确的行业，就要考虑如何坚持下去。做好自己的职业规划可能是我们想要在这个行业快速成长的重要事情。
测试行业的发展规划 整体职业规划分为如下几个阶段：
第一阶段：初级测试工程师
一般刚刚入门，熟悉基本的测试流程，入门薪资一般在6000-8000元之间。
具体工作是：
（1）按照测试方案和流程对产品进行功能测试，检查产品是否有缺陷。
（2）具有一些手工测试经验，开发测试脚本并开始熟悉测试生存周期和测试技术
第二阶段：中级测试工程师
初级测试工程师积累1-2年工作经验后，可逐步发展为中级测试工程师，一般月薪能达到8K-15K
之间。
具体工作是：
（1）编写测试方案，测试文档、与项目组一起制定测试阶段的工作计划。
（2）项目完整流程和整体质量把控介入、和开发高效沟通以及关系处理
（3）能够在项目中合理利用测试工具来完成测试任务。能够独立编写自动测试脚本程序并担任 测试编程初期的领导工作
第三阶段：高级测试工程师/测试组负责人
一般拥有3-4年测试经验，可以对初级测试工程师指导工作，一般月薪可以达到15-25K左右。
高级测试工程师具体工作是：
（1）帮助开发或维护测试或编程标准与过程，分析软件需求，获得测试需求。
（2）熟悉产品代码和产品整体架构设计，项目整体流程体系改进
（3）参与同行的评审(软件需求，软件测试计划等)，并为其它初级的测试工程师或程序员充当 顾问。
（4）了解自动化持续集成并能进行系统运用
测试组负责人：
除了技术上需要达到高级测试工程师的水平外，同时在管理上有额外的要求：
（1）设计测试计划及进行测试项目的管理
（2）项目及测试流程和工具的选择及优化
（3）担负一些进度安排和工作规模/成本估算职责
第四阶段： 测试专家/测试经理
一般有6—10年经验的测试工程师，薪资在30K-50K之间。
测试专家一般是在性能、或者安全、或者测试开发方向等特定领域有技术专长的测试人员。具体
工作是：
（1）性能测试整体方案设计，软件系统性能问题定位和性能优化，内存优化及分析数据溢出等
（2）分析系统的安全漏洞等
（3）自动化持续集成体系建设等
而测试经理的工作重心主要在管理方向，具体工作如：
（1）负责进度安排、工作规模/成本估算、按进度表和预算目标交付产品。
（2）负责团队测试项目的质量及控制。
（3）构建测试团队及进行测试团队的管理
软件测试是一种入门起点较低、上手迅速、且发展空间比较大的职业，因此，对于很多学生而言，作为进入IT就业的初级岗位，是非常合适的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ded3b17446135b49859ed1bb86d9a68b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d43ff7efefdf358aa1a68fefdc55de12/" rel="bookmark">
			【故障处理】java程序cpu飙高如何排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用传统jstack手法来排查 如何使用原生top命令、jstack命令来做定位具体代码的位置处理
简单步骤有下面几步 执行top命令，查看CPU占用情况，找到进程的pid(12002)使用 top -Hp &lt;pid&gt; 命令（为Java进程的id号）查看该Java进程内所有线程的资源占用情况找出负载高的线程，记录tid（26917）；printf “%x\n” 命令（tid指线程的id号 26917）将以上10进制的线程号转换为16进制nid(6925）；jstack -l &lt;pid&gt;(12002) &gt; ./jstack_result.log 【采用jstack命令导出线程快照 ,通过使用jdk自带命令jstack获取该java进程的线程快照并输入到文件中： jstack -l 进程id号 &gt; ./jstack_result.txt 命令（为Java进程的id号）来获取线程快照结果并输入到指定文件。】cat jstack_result.log | grep -A 200 &lt;nid&gt;(6925)【根据线程号定位具体代码 cat jstack_result.log | grep -A 100 6925】 实践 以下案例是java应用docker容器部署排查的，jar方式部署的话排查步骤是一样的
使用top命令查看
top 查看cpu使用率比较高的线程
top -Hp 1 然后将占用最高的 pid 转换为 16 进制 printf '%x\n' pid 得到 nid：
printf '%x\n' 106 接着直接使用 jstack 导出进程1的堆栈信息
jstack -l 1 &gt; ./jstack_result.log 接着直接导出的堆栈文件里面中找到相应的16进制转换后的线程堆栈信息 cat jstack_result.log |grep -A 200 'nid=0x6a' 可以看到我们已经找到了 nid 为 0x6a的堆栈信息，接着只要仔细分析一番即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d43ff7efefdf358aa1a68fefdc55de12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d57f583ea056b939c324d841c2b0c35/" rel="bookmark">
			一篇文章搞懂正定矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看文献时，很多条件下的矩阵都要求是正定矩阵，虽然之前线性代数学习过，但也遗忘地差多了，今天就重新温习一下。
定义 根据百度百科，正定矩阵分为广义和狭义两个定义。
（1） 广义定义：设M是n阶方阵，如果对任何非零向量z，都有，其中zT 表示z的转置，就称M为正定矩阵
（2）狭义定义：一个n阶的实对称矩阵M是正定的的条件是当且仅当对于所有的非零实系数向量z，都有zTMz&gt; 0。其中zT表示z的专制。
（3）对称正定矩阵：，若，,如果对任何非零向量X，都有,则称A为对称正定矩阵。
正定矩阵的性质 正定矩阵有以下性质：
（1）正定矩阵的行列式恒为正；
（2）实对称矩阵A正定当且仅当A与单位矩阵合同；
（3）若A是正定矩阵，则A的逆矩阵也是正定矩阵；
（4）两个正定矩阵的和是正定矩阵；
（5）正实数与正定矩阵的乘积是正定矩阵。
判定方法 根据正定矩阵的定义及性质，判别对称矩阵A的正定性有两种方法：
（1）求出A的所有特征值。若A的特征值均为正数，则A是正定的；若A的特征值均为负数，则A为负定的。
（2）计算A的各阶主子式。若A的各阶主子式均大于零，则A是正定的；若A的各阶主子式中，奇数阶主子式为负，偶数阶为正，则A为负定的。
何为矩阵的主子式和顺序主子式？
主子式：在n 阶行列式中，选取行号（如 1、3、7行），再选取与行号相同的列号（1、3、7 列），则行数和列数都为i个的行列式即为n阶行列式的i阶主子式，也可以说由上述选取的行列交汇处的元素所组成的新的行列式 就称为“n 阶行列式的一个 i 阶主子式。
顺序主子式是取n阶方阵的部分元素化为行列式形式，方阵的第k阶行列式是由该方阵的前k行和k列元素组成（可以看作是主子式的一个特例）。对于n阶方阵A，其共有n阶顺序主子式。设A为n*n阶矩阵，子式
称为A的顺序主子式 。
等价命题 对于n阶实对称矩阵A，下列条件是等价的：
（1）A是正定矩阵；
（2）A的一切顺序主子式均为正；
（3）A的一切主子式均为正；
（4）A的特征值均为正；
（5）存在实可逆矩阵C，使A=C′C；
（6）存在秩为n的m×n实矩阵B，使A=B′B；
（7）存在主对角线元素全为正的实三角矩阵R，使A=R′R 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acbdd6776e5dbfa05ee604a4bed608d6/" rel="bookmark">
			掌握3个Mock工具，轻松玩转单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司要求提升单元测试的质量，提高代码的分支覆盖率和行覆盖率，安排我研究单元测试，指定方案分享并在开发部普及开。
单元测试中的Mock的目的 Mock的主要目的是让单元测试Write Once, Run Everywhere.
即编写一次后，可以在任意时刻任意环境运行，无需依赖数据库网络等。
Mock工具介绍 Mock工具经过调研，基本上是表格下面的这么个情况：
简要介绍下各个的特点和为什么没选：
rap2和easy-mock等，都是基于node开发的，和我们开发部的主力语言Java相性一般，后续改造难度大，并且不支持请求超时的配置和上下文的配置，优点是使用操作简单，pass。
wiremock，和rap2差不多，就是多个支持延时请求，不过是英文的，pass。
mock-server，基于java语言的，底层是netty，编程自由，比较适合java技术栈的团队。
postman，虽然有mock功能，但是只能针对某个请求的返回固定mock，并且每次启动mock的端口和url完全随机，无法接受，pass。
我们最后选的是mockito和mock-server，mockito因为是java的mock工具包，所以并不在上面的表格里。
mockito 相关介绍 这个包是spring官方也推荐的Mock依赖，在spring-boot-starter-test中默认就会自动包含。
这个包提供的相关类，主要功能就是对某个对象进行mock，通过其提供的特殊的语法，对某个对象的返回以及行为做Mock。
应用场景 单元测试时，如果依赖其他系统的RPC调用（比如feign或dubbo），可以针对相关RPC的调用对象进行直接Mock，直接返回成功、超时、异常，减少依赖。
在对系统内部的某些工具类或者数据库层进行单元测试时，可以模拟一些异常情况，比如数据库超时、框架层抛出某些很难复现的特定异常返回，可以通过直接Mock实现来达到效果。
mockito除了Mock外也支持spy，Mock与spy的区别是，Mock产生的是一个空对象，对mock对象未做配置的方法调用均返回null或异常。
spy产生的是一个代理对象，对那些做了配置的方法按照配置的预期返回，未做配置的方法直接会调用原方法。
使用方式（spring） maven中引入：
&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-all&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 在测试类中进行如下定义：
//需要mock的服务，一般是RPC，也可以是工具类，总而言之是一个对象 @Mock TestRpc testRpc; @Autowired TestService testService; //在@Before中对其进行初始化 @Before public void initMocks() throws Exception { //1.1 初始化的api，在这一步执行后，testRpc被初始化为一个mock对象 MockitoAnnotations.initMocks(this); //1.2 使用mock对象替换spring中的bean：这里是将后面要用到的testService中的testRpc这个rpc对象， //替换为上面@Mock为我们创建的mock对象，然后我们就可以对这个对象进行mock了，这里的替换是spring容器级别的替换 //注意，理论上对RPC的service进行mock即可，即替换调用RPC的那个bean中的rpc对象。 ReflectionTestUtils.setField(AopTargetUtils.getTarget(orderPayFacade), "testRpc", testRpc); //1.3 定义mock返回：对新的mock对象进行定义，当后续请求这个rpc的该方法时，会直接return一个空的成功对象 final ResultRpc&lt;TestVO&gt; testVo = new ResultRpc&lt;&gt;(); when(testRpc.getAccountByBindCardId("101010")).thenReturn(testVo); } 或者：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acbdd6776e5dbfa05ee604a4bed608d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/081b41c4c76846370d3955c9a39c4634/" rel="bookmark">
			Kubernetes双主集群的部署（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
二、k8s双主架构集群的部署
1.另一台Master同样做初始化配置
2.配置 Master02
3.配置负载均衡器（nginx+keepalived）
4.修改k8s集群配置 三、安装Dashboard前端管理软件
1.Dashboard介绍
2.安装Dashboard
四、创建pod
1.使用kubectl创建pod
2.使用Dashboard创建pod
二、k8s双主架构集群的部署 k8s集群master01：192.168.116.10
k8s集群master02：192.168.116.20（第二部分高可用架构会加入）
k8s集群node01：192.168.116.30
k8s集群node02：192.168.116.40
etcd集群节点1：192.168.116.10（etcd集群原则上单独部署，此实验为方便部署在节点上）
etcd集群节点2：192.168.116.30
etcd集群节点3：192.168.116.40
负载均衡nginx+keepalive01（master）：192.168.116.50
负载均衡nginx+keepalive02（backup）：192.168.116.60
1.另一台Master同样做初始化配置 2.配置 Master02 在master01上操作
#将master所需文件复制给master02 cd /opt/ scp -r etcd/ kubernetes/ master02:/opt/ cd scp -r .kube/ master02:/root cd /usr/lib/systemd/system scp kube-* master02:`pwd` 在master02上操作
#修改apiserver配置文件（其他组件配置文件监听地址为127.0.0.1，所以不需要修改） cd /opt/kubernetes/cfg/ vim kube-apiserver #将通告和监听地址改为本机ip --bind-address=192.168.116.20 \ --secure-port=6443 \ --advertise-address=192.168.116.20 \ 然后启动3个组件服务
将k8s命令做软连接，使用kubectl查看etcd集群状态（此时完成了master02与etcd集群的对接）
3.配置负载均衡器（nginx+keepalived） 初始化，并下载nginx和keepalived
systemctl disable --now firewalld.servive setenforce 0 #准备nginx官方源 cd /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/081b41c4c76846370d3955c9a39c4634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91681438ba24c52dbc7a135fa3d04cb5/" rel="bookmark">
			Studio配置SVN(上传代码时文件忽略设置)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android Studio创建的Android项目，必须先来添加要忽略的文件，再关联SVN，一般需要忽略以下内容：
1 .idea文件夹
2 .gradle文件夹
3 所有的build文件夹
4 所有的.iml文件
5 local.properties文件
如何添加忽略也可参考：
http://jingyan.baidu.com/article/a378c960bd502fb32828309b.html
&gt;在上传之前一定要忽略一些文件，否则在上传的时候，AndroidStudio检测到了，会自动断掉上传。 忽略文件的不足为File–&gt;Settings找到Version Control—&gt;&gt;Ignored Files.具体要忽略的可以大体的分为以下几种。 1.文件：local.properties;这个文件中包含了sdk的存储路径，因为每个人的存储路径都有可能会不太相同，所以还是建议忽略了比较好。当然不忽略也没错。 2.文件夹：以点开头的所有文件夹都要忽略，其中包括：.gradle和.idea。然后就是所有的build文件夹，注意是文件夹不是文件，如果将build的文件忽略了也会自动停止上传。包括：app目录下的build和总目录下的build。 3.所有文件：*.iml这个没有什么好解释的 忽略相同后缀文件：
最后设置忽略文件之后，如图：
SVN在Android Studio中的配置
androidStudio中配置SVN
TortoiseSvn下载地址
Android Studio-SVN代码下载,提交,冲突解决方案
AndroidStudio SVN插件配置与使用
androidStudio中使用svn进行代码的更新和提交
Android Studio SVN配置忽略文件
注：注意一点，配置忽略文件必须在Share到SVN之前进行，如果在Commit后配置，貌似就不起作用了。
Android Studio SVN配置忽略文件
微信公众号【码农园区】，技术分享，值得关注 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3597f3423c9d0614e515ddec7198db9c/" rel="bookmark">
			文件系统和日志分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件系统
xfs文件系统进行备份和恢复（数据要先备份才能恢复）
1、添加磁盘，分区
2、创建文件系统
3、挂载
4、在挂载目录下写入内容（在磁盘中写入内容）
5、备份
6、恢复
二、日志分析
实验：配置日志服务器，收集日志
20.0.0.10 客户端——使用功能
20.0.0.20 服务端——提供功能进行服务
20主机上所有系统日志，不在记录在自己本地，而是发送给10，记录在10 的服务器上
1、关闭防火墙和安全机制
2、进入/etc/rsyslog.conf
3、查看514端口是否正常运行
4、查看日志
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/063aa594923b4f8637215f76d2d1aed4/" rel="bookmark">
			BeanPostProcessor和BeanFactoryPostProcessor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BeanPostProcessor和BeanFactoryPostProcessor都是Spring初始化bean的时候提供的拓展点，也叫做后置处理器。
BeanFactoryPostProcessor在bean实例化前被调用，BeanPostProcessor在实例化后被调用。
实现接口BeanFactoryPostProcessor可以在实例化前作操作，根据业务修改配置。也可以配置多个BeanFactoryPostProcessor，通过order属性控制执行顺序
实现接口BeanPostProcessor可以在实例化之后，初始化前后添加自定义逻辑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9996415107fb6f764a4b5e3f5fedf6/" rel="bookmark">
			深入分析标准modbus TCP 和modbus RTU 信号输入输出区别【温湿度传感器为例】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：RS485信号输出的温湿度传感器和RJ45信号输出的温湿度传感器深入分析拓展
485信号输出的温湿度传感器
modbus TCP/IP协议和modbus RTU协议是两种不同的通讯协议，它们在通讯方式、数据格式和适用场景等方面存在一定的差异。下面将对这两种协议进行详细介绍和比较。
一、modbus TCP/IP协议
Modbus TCP/IP协议是基于以太网的一种通讯协议，它使用TCP/IP协议进行数据传输。该协议最初是为RS-485总线而设计的，后来被移植到以太网上。Modbus TCP/IP协议具有以下特点：
易于集成：Modbus TCP/IP协议具有良好的兼容性和可移植性，可以方便地与其他系统进行集成。
传输速度快：以太网的传输速度非常快，可以达到100Mbit/s或更高，因此Modbus TCP/IP协议的传输速度也很快。
传输距离远：以太网的传输距离非常远，可以达到数公里，因此Modbus TCP/IP协议的传输距离也很远。
支持热插拔：以太网支持热插拔，即在不关闭电源的情况下更换硬件设备，Modbus TCP/IP协议也支持热插拔。
支持多主机连接：Modbus TCP/IP协议支持多个主机同时连接到一个设备，可以实现多个主机同时读取设备的数据。
二、modbus RTU协议
Modbus RTU（Remote Terminal Unit）协议是一种串行通讯协议，它使用RS-485总线进行数据传输。该协议最初是为短距离、低速率的串行通讯而设计的，但也可以通过串口转以太网的转换器实现基于以太网的数据传输。Modbus RTU协议具有以下特点：
数据格式简单：Modbus RTU协议的数据格式比较简单，易于理解和实现。
支持多种数据类型：Modbus RTU协议支持多种数据类型，包括位、字节、字、双字等。
可编程性强：Modbus RTU协议支持多个从设备连接到一个主设备，并且每个从设备可以独立地响应主设备的请求。这使得Modbus RTU协议具有较强的可编程性，可以方便地实现自动化控制。
传输速度较慢：RS-485总线的传输速度比以太网慢，因此Modbus RTU协议的传输速度也较慢。
传输距离较短：RS-485总线的传输距离比以太网短，因此Modbus RTU协议的传输距离也较短
RJ45信号输出的以太网温湿度传感器【支持POE供电】
三、比较与分析
通讯方式：modbus TCP/IP协议基于以太网进行数据传输，而Modbus RTU协议使用RS-485总线进行数据传输。因此，modbus TCP/IP协议适用于较大的网络系统，而Modbus RTU协议适用于较小的系统。
数据格式：modbus TCP/IP协议的数据格式与Modbus RTU协议略有不同。在Modbus RTU协议中，数据按照特定的字节顺序进行编码，而在modbus TCP/IP协议中，数据按照网络字节顺序进行编码。此外，Modbus RTU协议支持更多的数据类型。
适用场景：由于modbus TCP/IP协议基于以太网进行数据传输，因此它适用于较大的网络系统，如工业自动化、智能建筑等。而Modbus RTU协议适用于较小的系统，如楼宇自动化、HVAC控制等。
四、重新改写
为了更好地理解modbus TCP/IP协议和Modbus RTU协议的区别，下面将重新改写上述内容。
modbus TCP/IP协议是一种基于以太网的通讯协议，它使用TCP/IP协议进行数据传输。该协议适用于较大的网络系统，如工业自动化、智能建筑等。其优点在于易于集成、传输速度快、传输距离远和支持热插拔。然而，由于其数据格式与Modbus RTU略有不同，且需要更多的网络配置，因此在某些情况下可能不太适用。
相反，Modbus RTU协议是一种串行通讯协议，它使用RS-485总线进行数据传输。该协议适用于较小的系统，如楼宇自动化、HVAC控制等。其优点在于数据格式简单、支持多种数据类型和较强的可编程性。然而，由于其传输速度较慢和传输距离较短，因此在某些情况下可能不太适用。
总之，选择合适的通讯协议取决于具体的应用场景和需求。在较大的网络系统中，modbus TCP/IP可能是更好的选择；而在较小的系统中，Modbus RTU可能是更好的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d22b34b8ae46068f37428856b1dcc4/" rel="bookmark">
			PCIe 5.0验证实战，经常遇到的那些问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCIe 5.0是当前最新的PCI Express规范，提供了更高的数据传输速率和更大的带宽。
PCIe是连接两个芯片的接口，负责两个芯片通信, 连接芯片的通路为高速SerDes, 称之为链路。PCIe确保通路正常-链路训练状态机。PCIe在芯片内部是非常重要的一个大的模块，如果PCIe不能正常工作，那芯片则视为石头。
越来越多的HR开始把PCIe等高速串行接口相关经验列为了加分项，以确保可以招聘到合适而高效的验证工程师、FPGA的设计以及芯片设计工程师。学习PCIe无疑是一个值得当下就去做的一件事情。
在职场上刚接触PCIe 5.0，应用起来比较吃力，经常会遇到一些问题，今天移知小编为大家搜集了，《PCIe验证实战》第一期，学员时常问到的一些问题，以及老师的解答。希望能给大家带来帮助，建议收藏。
文末分享PCIe学习资料，私信领取。
01、PCIe 5.0学习问答 Q、RC中几个端口，是否可以进行P2P间的验证？
解答:
看RC的具体实现，比如有些RC内部只有一个port也就不能进行p2p，之前做过这样的设计采用dual ip，这样就只有一个port，目前x86 RC内部port多，支持p2p，具体看下CPU Feature.
Q、 PCIe链路训练均衡的问题；
如何配置Synopsys的EP控制器的寄存器，使得在链路训练过程中修改HOST侧的PCIE PHY的TX preset值。GEN3_RELATED_OFF寄存器GEN3_EQ_CONTROL_OFF寄存器，通过配置EP的这两个寄存器配置是否可以实现，修改HOST侧的TX preset值。
解答:
1-EQ流程，RX会根据CTLE/DTE评估的情况来调节对端设备的TX FFE。
2-源码分析，不能按照问题操作
3-需要仿真-doing
Q、EP在detect的时候TS1发出的 datarate只支持GEN1， 最终EP 和RC也training到GEN1 ，但此时发现 RC target speed 也切到GEN1 ，这个过程是哪一部分会修改到RC的target speed吗？
解答：
1-bios到是有可能；我见过原型验证中有通过bios修改cpl timeout。
2-需要确认controller此寄存器会不会硬件自动修改，RTL代码确认不会修改。
Q、cxl下rc remote访问EP的MEMBAR0下挂的ELBI接口空间支持2DW读？
解答：
不支持，RTL代码返回CA
cxl文档里有一个ELBI2的方式，ELBI2将1K-DW(ELBI)扩展到512K-DW，这也是访问CCG Reg的方式。ELBI的空间太小，不满足要求。因此2dw的访问是ELBI2可以支持的，只是ELBI方式不支持。
Q、目标为16G，请问老师，LTSSM为什么跳过了5G，直接进入8G？
解答：
到16G的训练流程就是2.5-8-16，pcie vip还提供了一种配置直接2-16.
6.0spce看到过这方面内容的描述。
Q、PCIE序的场景，需要列举
解答：
读不超越写，请求依赖与响应因此响应不能依赖与请求，i响应包不能穿越P包(host读tag，ep写数据)。
移知《PCIe验证实战–2期》，本月强势回归，理论结合实操，全方位的学习体验，一课搞定设计和验证，本课程以可流片的PCIe代码为基础，介绍了PCIe理论以及PCIe实战的内容，目标是大家能在实际的PCIe项目中可以上手干活。共22个章节，理论和实战相结合，从验证环境的搭建，到DUT data path的梳理，学完即可上手做PCIe RTL设计以及验证工作。
02、PCIe学习资料免费领取 PCIe学习有一定的难度，想要学习好就需要不断的摸索，而PCIe的学习资料全网都是，但是真正要找干货，还要看几本经典的书。今天在这里推荐学习 PCIe 的英文资料最经典的是《PCI Express System Architecture》绝大多数的中文互联网有关 PCIe 的内容，都来自或者基于这本书。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81d22b34b8ae46068f37428856b1dcc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09b400e74ad56693fb3ff17e4b6329f/" rel="bookmark">
			“百模大战”大模型哪家强？开源的全面评测来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，一则推送在网上火了：《世界人工智能大会上的大模型都在这了，让你一次看个够》 小编兴奋地点开文章，好家伙，整篇文章没有字，只有满眼的 “大模型”。
小编顶着昏花的老眼，手动数了一下，在 WAIC 大会上发布的大模型，至少有 58 个之多。🤦
而根据今年的《中国人工智能大模型地图研究报告》，国内现在已经发布了多达 79 个参数 10 亿规模以上的大模型。可谓是百花齐放，各有千秋。在各家对各自模型的宣传中，也都展示了自己模型强悍的一面，让不少围观者不禁为之振奋，直呼牛哇。
然而，市面上也存在着相当一部分疑惑的声音——作为用户，我们怎么能直观地知道哪个模型更强呢？不可否认的是，目前大模型评测还是一个比较困难的问题。尽管此前已经有了 MMLU、CEval 等比较权威的开源数据集榜单，可是它们只能反映模型在某个点上的能力，并无法准确地衡量出一个模型的综合能力。
另一方面，市面上也存在着一些对大模型进行评测的方案。可是，它们有的偏向学术研究，上手较难，让普通用户望而却步；有的方案并非完全公开，用户想要得知结果，只能手动提交评测申请，再望穿秋水地等待结果。 这时，我们就需要一个全面、公正、开源的裁判，让大家伙儿随时在同一条起跑线上进行全能测试。小编在此隆重介绍我们今天的主角 —— OpenCompass！
GitHub - open-compass/opencompass: OpenCompass is an LLM evaluation platform, supporting a wide range of models (LLaMA, LLaMa2, ChatGLM2, ChatGPT, Claude, etc) over 50+ datasets.OpenCompass is an LLM evaluation platform, supporting a wide range of models (LLaMA, LLaMa2, ChatGLM2, ChatGPT, Claude, etc) over 50+ datasets. - GitHub - open-compass/opencompass: OpenCompass is an LLM evaluation platform, supporting a wide range of models (LLaMA, LLaMa2, ChatGLM2, ChatGPT, Claude, etc) over 50+ datasets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c09b400e74ad56693fb3ff17e4b6329f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f83a28eff64c33f81095d41ff16165/" rel="bookmark">
			Kafka为什么吞吐量高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷盘快：顺序读写+延迟小。
1.顺序读写磁盘：更少的磁盘寻道提高io性能。
kafka按照topic存储，topic中的数据按照分区存储不同的broker，分区按照分段存储，kafka为每个分段建立了索引文件，分区+索引的设计提高读写率。
kafka的读写是批量操作，减少了网络io。
kafka使用了批量压缩，减少了网络io的消耗。
2.延迟小：采用0拷贝技术，消息被存储在磁盘中而不是通过内存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305acd682fe6a2626218cb377966cb18/" rel="bookmark">
			数据结构-01 数据结构基本概念,算法时间复杂度，空间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 数据结构概述 四门课的关系 1 绪论 数据对象、数据元素、数据项关系 1.1 数据结构的基本概念 1.2 算法和算法评价 小练习
空间复杂度中的递归调用
n只是传入
n也是数组，计算存储数组flag的空间大小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba4d821348fe85bca1093e9311ce8c11/" rel="bookmark">
			linux文件系统和日志分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件数据包：存储的文件（图片，视频，文本）
linux的存储有两种机制：inode 和 block
1.inode：文件会生成一个inode号 查看inode号的方式：ls -i 123.txt 或者 ls -i 234.txt
2.block:文件必然要占用存储空间，也就是block，block块最小为4K，如果文件大小不满4K，也会占用4K
inode号: 元信息（文件的属性）
1.存储的元信息：里面包含文件的创建者，更改日期，文件的大小，文件的权限，跟随inode号标识，存储在硬盘上的，一般inode号占用的空间在512K左右，小一点的也有128-256字节，如果inode号用完了，既然磁盘还有空间也无法创建数据，(磁盘无法读取时可以查看一下inode号还是否用完，或使用iostat查看磁盘空间用完)，一个文件必须需要占用一个inode号，至少占一个块，所以文件必须要有inode号，创建的文件不满4K也要占用一个块。
2.linux一切皆文件，目录也是文件，linux内部怎么识别文件，系统识别的是inode号，对于系统来说，文件名只是inode号的别称，方便用户使用，文件名和inode号一一对应，文件的元信息当中，是不包含文件名的。
stat
stat 命令可以查询文件的详细信息
stat+ 文件名 比如 stat 123.txt 或 stat 234.txt
access ：atime ：访问这个文件就会改变这个时间
modify ：mtime :修改文件数据内容，就会更新
change ：ctime ：（主要涉及到block块）修改文件的权限或者是属性，更改文件内容也可能会变,也可能不会变
文件名和inode 号剥离之后
1.文件名包含特殊字符，可能无法正常删除，这时可以通过inode号，直接找到数据所在块，直接删除
2.移动，重命名，不影响inode号
3.一旦打开文件之后，系统全部以inode号来识别文件，这个时候文件名就不在系统考虑范围之内
4.vim编辑器修改文件内容，可能会生产新的inode号，但不绝对
5.文件名不在元信息当中的
如果有些删除不掉的的乱码文件可以通过索引号进行删除 实验
实验二
全量恢复文件
实验三
ssh服务日志单独存放
先关防火墙，两个主机都要关
1.systemctl stop filewalld
2.setenforce 0
3.vim /etc/rsyslong.conf
4.local6.* /var/log/ssh.log
5.vim /etc/ssh/sshd_config
6.在SyslogFacility AUTHPRIV 前面加上注释 # 7.加上SyslogFacility LOCAL6 之后wq！保存退出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba4d821348fe85bca1093e9311ce8c11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/521241ebe1ca48f56a0dd67ff8a519c0/" rel="bookmark">
			查看Ubuntu系统的IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看Ubuntu系统的IP地址 方法1-查看详细IP地址 展示系统IP地址
ifconfig 方法2-查看详细IP地址 ip add show 方法3-只展示IP地址 使用如下命令，即可输出Ubuntu系统的IP地址
hostname -I 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a62e0d0e30629471b2b6292532c27124/" rel="bookmark">
			2023全国大学生数学建模竞赛B题思路模型代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一.选题建议先发布，思路模型代码论文第一时间更新，获取见文末名片
二.选题建议，后续思路代码论文
B 题 多波束测线问题
各题分析
获取完整思路代码见此处名片
一.选题建议先发布，思路模型代码论文第一时间更新，获取见文末名片 二.选题建议，后续思路代码论文 思路代码模型论文https://www.bilibili.com/video/BV1BH4y1X7TF/?buvid=Z54D8D5201DFFE8446E0929CB6DE5CF3C1F5&amp;is_story_h5=false&amp;mid=1uAkA2uLc2GvBgMfMTENag%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=ipad&amp;share_plat=ios&amp;share_source=COPY&amp;share_tag=s_i×tamp=1694085016&amp;unique_k=S6O26uc&amp;up_id=1770130606
B 题 多波束测线问题 单波束测深是利用声波在水中的传播特性来测量水体深度的技术。声波在均匀介质中作匀
速直线传播，在不同界面上产生反射，利用这一原理，从测量船换能器垂直向海底发射声波信
号，并记录从声波发射到信号接收的传播时间，通过声波在海水中的传播速度和传播时间计算
出海水的深度，其工作原理如图 1 所示。由于单波束测深过程中采取单点连续的测量方法，因
此，其测深数据分布的特点是，沿航迹的数据十分密集，而在测线间没有数据。
各题分析 A题：定日镜场的优化设计
A题是数模类赛事很常见的物理类赛题，需要学习不少相关知识。一些数值计算的部分，应该还需要用到运筹学的多目标规划。
这里简单提一下第一问的思路，问题一要求计算定日镜场的年平均光学效率、年平均输出热功率和单位镜面积年平均输出热功率。针对这个问题，我们可以采用以下步骤和算法解题：
1确定定日镜位置：根据给定的定日镜中心位置，在圆形定日镜场中确定每个定日镜的坐标。
2计算太阳高度角和方位角：根据地理位置和日期时间，使用公式计算太阳的高度角和方位角，以获取入射光线的方向。
3计算法向直接辐射辐照度：利用所得到的太阳高度角和方位角，结合地球上垂直于太阳光线的平面单位面积上接收到的太阳辐射能量的公式，计算法向直接辐射辐照度。
4计算定日镜的光学效率：利用光学效率公式，分别计算阴影遮挡效率、余弦效率、大气透射率和集热器截断效率，并将它们相乘得到定日镜的光学效率。
5计算定日镜场的输出热功率：根据法向直接辐射辐照度和定日镜的光学效率，计算每个定日镜的输出热功率，并将它们相加得到定日镜场的输出热功率。
6计算单位镜面积年平均输出热功率：将定日镜场的输出热功率除以定日镜总面积，得到单位镜面积年平均输出热功率。
在解题过程中，可能需要使用数值计算和优化算法来处理复杂的计算和问题求解。例如，可以使用数值积分方法来估计法向直接辐射辐照度，使用迭代或优化算法来确定定日镜的最佳位置和尺寸等。
这道题专业性较高，后续账号会在出本题具体思路分析时，再进行具体分析与建模。开放程度低，难度适中。但这类赛题通常门槛较高，小白/非相关专业同学谨慎选择。答案的正确与否会对最终成绩产生较大影响。建议物理、电气、自动化等相关专业选择。
B题：多波束测线问题
今年的国赛题目很奇怪，可能是因为chatgpt等一系列AI工具的普及，B题与A题一样，均为物理类题目，这两道题目的类型很相似。往年一般会有一个趣味性一点的题目。但B题可以明显看出是对数学、统计学相关专业较为友好。B题需要用到不少模拟仿真相关算法，推荐利用lingo进行求解。
这里就不再进行更细致的分析了，我们会在晚上发布相关具体思路，可以关注下。
这道题存在最优解，开放程度低，难度适中。大家选择此题最好在做完后，线上线下对对答案。推荐统计学、数学、物理等专业同学选择。
C题：蔬菜类商品的自动定价与补货决策
这道题就是很多同学在训练的时候经常做的题目类型了，属于大数据、数据分析类题目，同时也是团队擅长的题目。需要一定的建模能力，和其他赛事赛题类型类似，建议大家（各个专业均可）进行选择。
题目需要建立数学模型，大家可以使用评价类算法，比如灰色综合评价法、模糊综合评价法对各个指标建立联系。
第一问前大家需要对数据进行分析和数值化处理，也就是EDA（探索性数据分析）。对于数值型数据，大家用归一化、去除异常值等方式就可以进行数据预处理。而对于非数值型数据进行量化，大家可以使用以下方法：
1
而第一问可以给小白先提示下，后续我们还会更新具体的每问思路。第一问是需要我们做相关性分析，看那几个指标之间的相关系数是否高，如果高则代表影响较大，低代表影响较小。这里可以用热力图进行绘制，从而可视化影响程度。另外，对于分布规律，我的建议是简单一点做，就用统计描述：计算每个蔬菜品类及单品的销售总量、平均销售量、最大销售量和最小销售量等统计指标，以了解它们的整体情况。
如果可以的话，也可以用聚类算法：根据蔬菜品类或单品的销售特征，可以使用聚类分析方法（如K-means聚类）将其划分为不同的群组，进一步了解不同群组之间的销售量分布规律。
由于这篇是选题建议，详细思路可以看我的后续文章/视频。就不赘述了。数据集怎么分析，可视化代码什么的，后续会更新。这道题目开放度较高，难度较易，是本次比赛本科组获奖的首选题目。推荐所有专业同学选择门槛较低且开放度也相对较高。
获取完整思路代码见此处名片 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f653fac9315487ead7ff0dd0e2ecf4a7/" rel="bookmark">
			nested exception is java.io.FileNotFoundException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整的错误信息： [main] ERROR o.s.boot.SpringApplication - Application run failed
org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [com.heima.article.ArticleApplication]; nested exception is java.io.FileNotFoundException: class path resource [com/heima/apis/article/IArticleClient.class] cannot be opened because it does not exist.
找不到配置类错误，这个我是在初学微服务的时候遇到的，添加一个微服务运行时无法启动。
解决问题方法：
在maven中clean一下，将target清理掉重新运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d51244bb445d4d9901600274b771af/" rel="bookmark">
			数据结构与算法之字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.字符串定义2.串的几个基本概念2.1 空串:2.2空格串2.3子串2.4串相等2.5串比较 3.串的基本操作(`此处以java为例`)3.1赋值操作StrAssign(s,t)3.2 连接操作 Concat(s,t)3.3求串长StrLength(s)3.4比较StrCompare(st)3.5 求子串_SubString(s,start,len) 4.串的存储结构4.1 串的顺序存储结构4.2 串的链式存储 5.朴素的模式匹配算法6.改进的模式匹配算法(KMP算法) 1.字符串定义 字符串是一种特殊的线性表，是由字符构成的有限序列，其数据元素是字符。
2.串的几个基本概念 2.1 空串: 长度为零的串称为空串，空串不包含任何字符。
2.2空格串 由一个或多个空格组成的巾。虽然空格是一个空白字符，但它也是一个字符,在计算串长度时要将其计算在内。
2.3子串 由串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。子串在主串中的位置是指子串首次出现时，该子串的第一个字符在主串中的位置。空审是任意串的子串。
2.4串相等 指两个串长度相等且对应序号的字符也相同。
2.5串比较 两个串比较大小时以字符的ASCI码值(或其他字符编码集合作为依据实质上，比较操作从两个串的第一个字符开始进行，字符的码值大者所在的串为大,若其中一个串先结束，则以串长较大者为大。
3.串的基本操作(此处以java为例) java中的字符串是一个final类，实现了CharSequence接口。实际内部也是也是一个字符数组，如下截图
3.1赋值操作StrAssign(s,t) 将串s的值赋给串t。
String s1 = new String("我是字符串1"); String s2 = "我是字符串1"; String s21 = "我是字符串1"; System.out.println(s1==s2);//false System.out.println(s1.hashCode()==s2.hashCode()); //true System.out.println(s2==s21);//true String s3 = new String("我是字符串2"); String s4= new String("我是字符串2"); System.out.println(s3==s4); //false System.out.println(s3.hashCode()==s4.hashCode()); //true 3.2 连接操作 Concat(s,t) 将串t接续在串s的尾部，形成一个新串
String s1="我是字符串1"; String s2="我是字符串2"; System.out.println(s1.concat(s2)); 3.3求串长StrLength(s) 返回串s的长度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07d51244bb445d4d9901600274b771af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3477e8da9d7a1f7b4b5783272e84d14/" rel="bookmark">
			Mac M1安装虚拟机及Centos系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，首先，M1的芯片适合Centos8 ARM的版本。
x86的格式以及Centos7 arm是不适合的，其他的没有尝试，不知道适不适合，但是7不适合，之前的版本应该也是不适合的。
问题1:当安装Centos7 x86版本时，不会显示安装阶段，甚至无法打开虚拟机的电源。
问题2:换成Centos7 arm版本时，安装阶段(Install Centos7)会报错，错误为：
error : attempt to read or write outside of disk cd0
error: you need to load the kernel first.
解决办法：换成Centos8arm版本，这个版本是在以下链接中找的，步骤也是按照这个来的。
最终成功启动虚拟机
http://t.csdn.cn/D4MLQ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b49a8ea7699946c684d5dc1e2967659a/" rel="bookmark">
			《Python机器学习原理与算法实现》PDF太强了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python上手易学，灵活开源免费，可用于各种数据分析场景，但是学python光看视频不行，需要边看书边操作。推荐一下 《Python机器学习原理与算法实现》（杨维忠 张甜 著 2023年2月 清华大学出版社） ，这是今年的新书，数据科学作家杨维忠、张甜的最新作品。附赠全书代码、思维导图、PPT，约12小时教学视频。每一章后面都有练习题，也有习题答案。目前当当，京东，淘宝都有销售，几十块钱一本，相对于视频，对着书边学习边操作，事半功倍。
本书的推出，旨在解决以往学习中经常出现的“Python课程学习”与“机器学习课程学习”机械割裂导致学习效果不好的问题。一方面，单纯学习Python语言而不是以应用为导向、以解决问题为目的，无法将其用于科学研究或应用实践，那么大家在学习时就会感觉相对枯燥，容易学不进去或学了就忘、效果不好；另一方面，单纯学习机器学习算法，而机器学习的原理相对艰深，基础薄弱的初学者会因各种数学模型的复杂推导望而却步。
这本书的特色是将Python语言与机器学习的讲解进行深度融合，既全面深入地讲好Python语言，又深入浅出地讲好机器学习，以学以致用为桥梁实现了两者之间的高效联动协同，使读者通过本书的学习能够同时掌握Python语言和机器学习这两大专业利器，达到“一箭双雕”的学习效果，有效提升读者的科研与应用水平。当当、京东、淘宝等平台均有销售。
“Python课程学习”与“机器学习课程学习”有机结合，一方面，当前机器学习正在广泛应用于高校科研和企事业单位经营管理实践，是一个非常好的学习Python语言、实现学以致用的切入口，应用Python开展机器学习能够让大家更有动力、更有兴趣、更具效果地去学好Python语言；另一方面，用基于Python的操作实现与结果解读来引领机器学习的课程学习，相对更易入门和进阶，大大降低了学习难度，能够让大家更好地掌握机器学习相关技能。
《Python机器学习原理与算法实现》致力于让掌握Python机器学习应用更简单、更实用、更高效，清晰解释Python运行代码，深入浅出讲解机器学习原理，精选商业建模实践案例，演绎常用机器学习算法，精准解读运行结果。实现从入门上手到活学活用。附赠全书代码、思维导图、PPT，约12小时教学视频。
题外话 在此疾速成长的科技元年，编程就像是许多人通往无限可能世界的门票。而在编程语言的明星阵容中，Python就像是那位独领风 骚的超级巨星， 以其简洁易懂的语法和强大的功能，脱颖而出，成为全球最炙手可热的编程语言之一。
Python 的迅速崛起对整个行业来说都是极其有利的 ，但“人红是非多”，导致它平添了许许多多的批评，不过依旧挡不住它火爆的发展势头。
在下个十年的剩余时间里，Python 还能如此重要以及保持完整性吗？今天，我们将对事实进行分析，破除一些误解。
CSDN大礼包：全网最全《全套Python学习资料》免费分享🎁 😝朋友们如果有需要的话，可以扫描下方二维码免费领取🆓
如果你对Python感兴趣，想通过学习Python获取更高的薪资，那下面这套Python学习资料一定对你有用！
资料包括：Python安装包+激活码、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习等学习教程。0基础小白也能听懂、看懂，跟着教程走，带你从零基础系统性地学好Python！
​
​
这份完整版的Python全套学习资料已经打包好，需要的小伙伴可以戳下方链接免费领取
读者福利《Python全套学习资料》，戳这里免费领取！！！
​
一、Python所有方向的学习路线
Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python学习软件
工欲善其事，必先利其器。学习Python常用的开发软件都在这里了！
三、Python入门学习视频
还有很多适合0基础入门的学习视频，有了这些视频，轻轻松松上手Python~
四、Python练习题
每节视频课后，都有对应的练习题哦，可以检验学习成果哈哈！
五、Python实战案例
光学理论是没用的，要学会跟着一起敲代码，动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。这份资料也包含在内的哈~
六、Python面试资料
我们学会了Python之后，有了技能就可以出去找工作啦！下面这些面试题是都来自阿里、腾讯、字节等一线互联网大厂，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
七、资料领取
上述完整版Python全套学习资料已经上传CSDN官方，需要的小伙伴可自行微信扫描下方CSDN官方认证二维码免费领取
​
这份完整版的Python全套学习资料已经打包好，需要的小伙伴可以戳下方链接免费领取
读者福利《Python全套学习资料》，戳这里免费领取！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0289b812fe5cf10f5d528280e4d46582/" rel="bookmark">
			ICCV2021 Exploring Cross-Image Pixel Contrast for Semantic Segmentation (Oral)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Exploring Cross-Image Pixel Contrast for Semantic Segmentation 探索语义分割的跨图像像素对比度
Paper：https://openaccess.thecvf.com/content/ICCV2021/html/Wang_Exploring_Cross-Image_Pixel_Contrast_for_Semantic_Segmentation_ICCV_2021_paper.html
Code：https://github.com/tfzhou/ContrastiveSeg
Video：https://www.youtube.com/watch?v=roWqXRZPhmk
Abstract 当前的语义分割方法仅侧重于通过上下文聚合模块（例如，扩张卷积、神经注意力）或结构感知优化标准（例如，类 IoU 损失）来挖掘“局部”上下文，即各个图像内像素之间的依赖关系。然而，他们忽略了训练数据的“全局”上下文，即不同图像的像素之间丰富的语义关系。
受无监督对比表示学习最新进展的启发，我们提出了一种在完全监督环境下进行语义分割的逐像素对比算法。核心思想是强制属于同一语义类的像素嵌入比来自不同类的嵌入更相似。它通过明确探索以前很少探索的标记像素的结构，提出了用于语义分割的像素级度量学习范例。我们的方法可以轻松地合并到现有的分割框架中，而在测试期间无需额外的开销。
我们通过实验表明，利用著名的分割模型（即 DeepLabV3、HRNet、OCR）和骨干网（即 ResNet、HRNet），我们的方法在不同数据集（即 Cityscapes、PASCAL-Context、COCO-Stuff、CamVid）上带来了性能改进）。我们希望这项工作将鼓励我们的社区重新思考当前语义分割中事实上的训练范例。
1 Introduction 语义分割旨在推断图像中所有像素的语义标签，是计算机视觉中的一个基本问题。在过去的十年中，在大规模数据集（例如 Cityscapes [15]）的可用性和卷积网络（例如 VGG [63]、ResNet [32]）的快速发展的推动下，语义分割取得了显着的进展。作为分割模型（例如，全卷积网络（FCN）[51]）。特别是，FCN[51]由于其在端到端像素级表示学习方面的独特优势，成为现代分割深度学习技术的基石。然而，其空间不变性阻碍了对像素之间（图像内）有用上下文进行建模的能力。因此，后续工作的主流是深入研究有效上下文聚合的网络设计，例如扩张卷积[80,8,9]、空间金字塔池化[84]、多层特征融合[58,47]和神经注意力[35] ，24]。此外，由于广泛采用的逐像素交叉熵损失从根本上缺乏空间区分能力，因此提出了一些替代优化标准来在分割网络训练期间明确解决对象结构[40,2,86]。
基本上，这些分割模型（不包括[37]）利用深层架构将图像像素投影到高度非线性的嵌入空间中（图1（c））。然而，他们通常学习的嵌入空间仅利用像素样本周围的“局部”上下文（即单个图像内的像素依赖性），但忽略整个数据集的“全局”上下文（即图像之间的像素语义关系）。
因此，该领域长期以来一直忽视一个基本问题：一个好的分割嵌入空间应该是什么样子？
理想情况下，它不仅应该 1) 解决单个像素嵌入的分类能力，而且 2) 具有良好的结构，以解决类内紧凑性和类间分散性问题。关于2），在嵌入空间中，来自同一类的像素应该比来自不同类的像素更接近。先前关于表示学习的研究 [49, 60] 也表明，对训练数据的内在结构进行编码（即 2））将有助于特征判别性（即 1））。因此我们推测，尽管现有算法已经取得了令人印象深刻的性能，但通过考虑 1) 和 2) 可以学习更好的结构化像素嵌入空间。
无监督表示学习 [12, 31] 的最新进展可归因于对比学习的复兴——深度度量学习的重要分支 [39]。核心思想是“学习比较”：给定一个锚点，在投影的嵌入空间中将相似（或正）样本与一组不相似（或负）样本区分开来。特别是在计算机视觉领域，基于图像特征向量来评估对比度；锚图像的增强版本被视为正图像，而数据集中的所有其他图像则被视为负图像。
无监督对比学习的巨大成功和我们前面提到的推测共同促使我们重新思考当前语义分割中事实上的训练范式。基本上，无监督对比学习的力量源于结构化比较损失，它利用了训练数据中的上下文。有了这种见解，我们提出了一种逐像素对比算法，以便在完全监督的环境中更有效地进行密集表示学习。具体来说，除了采用逐像素交叉熵损失来解决类别歧视（即属性 1））之外，我们还利用逐像素对比损失通过探索标记像素样本的结构信息来进一步塑造像素嵌入空间（即属性 2))。逐像素对比损失的想法是计算像素到像素的对比度：强制嵌入对于正像素是相似的，对于负像素是不相似的。由于训练时给出了像素级分类信息，正样本是属于同一类的像素，负样本是来自不同类的像素（图1（d））。通过这种方式，可以捕获嵌入空间的全局属性（图1（e）），以更好地反映训练数据的内在结构并实现更准确的分割预测。
通过我们的监督像素对比算法，开发了两种新技术。首先，我们提出了一个区域内存库来更好地解决语义分割的本质。面对大量高度结构化的像素训练样本，我们让内存存储语义区域的池化特征（即来自同一图像的具有相同语义标签的像素），而不是仅存储像素级嵌入。这导致了像素到区域对比度，作为像素到像素对比度策略的补充。这样的内存设计使我们能够在每个训练步骤中访问更具代表性的数据样本，并充分探索像素和语义级片段之间的结构关系，即属于同一类的像素和片段在嵌入空间中应该接近。其次，我们提出了不同的采样策略，以更好地利用信息样本，让分割模型更加关注那些分割困难的像素。之前的工作已经证实硬负例对于度量学习至关重要[39,60,62]，我们的研究进一步揭示了在这种监督的密集图像预测任务中挖掘信息丰富的负例/正例和锚点的重要性。
简而言之，我们的贡献有三方面：
我们提出了一种用于语义分割的监督式逐像素对比学习方法。它将当前的图像训练策略提升到图像间、像素到像素的范式。它本质上是通过充分利用标记像素之间的全局语义相似性来学习结构良好的像素语义嵌入空间。我们开发了区域存储器，以更好地探索大型视觉数据空间并支持进一步计算像素到区域的对比度。与像素到像素对比度计算相结合，我们的方法利用了像素之间以及像素与语义区域之间的语义相关性。我们证明可以提供具有更好示例和锚点采样策略的更强大的分割模型，而不是选择随机像素样本。 我们的方法可以无缝地合并到现有的分割网络中，无需对基本模型进行任何更改，并且在测试期间不会产生额外的推理负担（图 2）。因此，我们的方法显示，在具有挑战性的数据集（即 Cityscapes [15]、PASCAL-Context [53]、COCO-Stuff[5] 和 CamVid[3]）上，使用 state-of-最先进的分割架构（即 DeepLabV3 [9]、HRNet [65] 和 OCR [81]）和标准主干网（即 ResNet [32]、HRNet [65]）。令人印象深刻的结果揭示了度量学习在密集图像预测任务中的前景。我们希望这项工作能够深入了解全局像素关系在分割网络训练中的关键作用，并促进对所提出的开放问题的研究。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0289b812fe5cf10f5d528280e4d46582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e09bf9f4b002b74a4956ea1e9ddd084/" rel="bookmark">
			Jetpack Compose 入门教程之Text
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个文本显示组件应该是我们最常用的组件,下面会非常细 归纳
实例 下面一一演示这些属性与控制逻辑
文本的展示 Text组件 所有构造方法都是text:String,要想用string.xml里面的字符串资源 得使用
stringResource方法,其相似方法如下 /* * Copyright 2019 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e09bf9f4b002b74a4956ea1e9ddd084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94dc281548eae8f8a875922c3625be30/" rel="bookmark">
			Unity3D | FPS游戏_人物相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次报名参加了训练营，初次尝试Unity3D的游戏开发，很庆幸的是有老师很详细的指导，拖了一些时间，也总算完成了。依照惯例，继续来写总结，同时这次几乎上学到的都是新知识，在不熟悉的前提下，还比较复杂散碎，相互之间的关联还是比较密切的，之前实现都是比较简单，尽管有联系，每个知识单独拿出来记录也是可以的。所以说这次的知识有可能会来回跳转，最后呢，有什么不妥多多担待😛
############### 思路有限状态机射线检测协程 实现后坐力瞄准射击效果 问题/解决方法/小技巧 简单的介绍一下游戏，和普遍的FPS游戏类似，玩家可以左键开火攻击敌人，每次射击造成的伤害固定，子弹小于当前弹匣子弹上限可以换弹，备用子弹数量有限，玩家生命值100。 在人物的模型以及控制上，直接使用老师的预制体，很感谢老师，着实省了很大是功夫。射击的方面，并不是采用的真实的子弹，而是利用射线检测，实例化弹坑，模拟出射击的效果；按住鼠标右键会有瞄准的功能；通过人物相机视角的变化，模拟出后坐力的效果；最主要的其实还是有限状态机的状态转换，这是这次最核心的技术。
思路 有限状态机 网上总结有限状态机的定义：
有限个状态，且状态间存在转移关系某个时间点，有且仅有一个状态存在 实现有限状态机，需要清楚“状态-行为-转换”，根据此次训练实际内容，具体实现为一下三步
1.定义有限状态列表（状态）
首先枚举，列出所有的状态，之后定义状态函数，在这一步的状态中，可以改变控制动画播放的条件，这样之后状态转换，首先考虑的就是动画改变播放。
[SerializeField] private PlayerState playerState; //当某个状态切换时，进行该状态的初始化 public PlayerState PlayerState { get =&gt; playerState; set { playerState = value; switch (playerState) { case PlayerState.Idle: animator.SetBool("Shoot", false); animator.SetBool("Reload", false); FirePoint.gameObject.SetActive(false); break; case PlayerState.Shoot: if (curr_BulletNum &gt; 0) { Shoot(); } //没有子弹，判断备用子弹 else { if (standby_BulletNum &gt; 0 &amp;&amp; curr_BulletNum &lt; curr_MaxBulletNum) { PlayerState = PlayerState.Reload; } else { PlayerState = PlayerState.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94dc281548eae8f8a875922c3625be30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a291f2635fcba7bf9bcd612656d86653/" rel="bookmark">
			Unity3D | FPS游戏_敌人相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书接上回，在上一篇中当说到有些交叉知识的时候，会进行简单标注，在这里围绕敌人来进行详细的解说。
#################### 思路_有限状态机_对象池导航组件 实现AI随机出生点攻击判定 尚未解决的问题/拓展 首先会简单介绍一下敌人的逻辑以及行为，敌人会随机在地图上的五个出生点刷新和重生，敌人的数量开始会从0增加到10，并且在击杀之后持续重生保持数量。敌人会在各个出生点之间巡逻，当敌人与人物的距离到达一定限制或者人物在敌人一定范围内射击（可以理解为开枪吸引敌人），敌人会锁定人物，切换为追击状态。 思路 有限状态机 敌人的状态机和人物的类似，尤其特殊需要注意的一点是，敌人有一个终点状态，同时使用对象池管理
①在进入Dead状态之后，不会再进行任何状态转换：同时关闭所有协程（在本例中每次敌人受伤，会开启一个击退协程）
②在每次从对象池中取出，要对敌人的状态初始化：简单距离描述一个敌人的完整过程：实例化敌人 -&gt; HP&lt;=0 -&gt; SetActive(false)，进入对象池，此时的敌人状态是Dead -&gt; 需要一个新的对象，同时池中存在对象 -&gt; SetActive(true),同时状态需要切换为Idle
在初始状态机开始有一个关键性判断，实现上面的两点的注意
if (zombieState == ZombieState.Dead &amp;&amp; value != ZombieState.Idle) { return; } 这段判断表示的意思：如果当前的状态是Dead，并且希望去往的状态不是Idle，则结束函数。这样一来既满足了Dead是终点状态的定义，也可以满足初始化时可以从Dead切换到Idle
初始化代码：
public void Init() { Debug.Log("初始化"); animator.SetTrigger("init"); capsuleCollider.enabled = true; hp = 100; ZombieState = ZombieState.Idle; } 动画开关init控制AnyState到Idle
对象池 这里首先演示使用对象池之后敌人的游戏项目管理
1.为什么使用对象池
这里个人理解会和两点有关：
①Destroy(gameObject);
根据老师的指导，个人增加了一些对Destory的理解，当代码中执行Destroy(gameObject);时候，虽然在Hierarchy中已经看不到该游戏项目，但是在Unity的底层中，并没有删除该项目，而是类似于给他打上一个删除的标签，之后游戏中的项目愈来愈多，到达内存和资源的占用越来越多都内存满，然后会检视有哪些是带有删除标签的，再将其删除。
综合上述的原理，如果是每击杀一个敌人之后，删除该游戏项目，再实例化一个新的敌人，内存占用会越来越大。
②需要重复使用对象
使用对象池，每次击杀的敌人会将其游戏项目SetActive(false);然后将其添加到对象池（队列Queue）下面作为子项目。这样之后每次需要一个新的对象时，会先去查看对象池是否为空，若不为空，则SetActive(true)使用；若为空，则实例化新的对象。
以下为代码管理敌人生成的协程，以及消灭之后进入对象池的函数
IEnumerator CheckZombie() { while(true) { yield return new WaitForSeconds(1f); if(zombies.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a291f2635fcba7bf9bcd612656d86653/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/722540f873d56c3b3e313866ef3cd97b/" rel="bookmark">
			Linux中screen常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 screen介绍screen基本命令 screen介绍 Screen是一个在Unix和Linux系统上常用的终端多路复用工具，它允许用户同时在一个终端会话中运行多个终端窗口，并且可以在不同的窗口之间切换。Screen的主要目的是在断开网络连接或关闭终端窗口后，仍然能够保持会话的持续运行。
screen基本命令 新建一个screen会话 screen -S &lt;名字&gt; 查看所有screen会话 screen -ls 恢复之前分离的会话 screen -r &lt;会话ID&gt; 退出当前screen会话 键盘点击ctrl+a , 然后按d 查看当前所在会话(id.name) echo $STY 关闭会话 如果在会话之中，输入exit或者Ctrl+d来终止这个会话。成功终止后，如果有其他处于Attached状态的screen界面，他就会跳到那个界面中，如果没有，他就会跳到默认界面上。
删除会话 screen -X -S session_name quit 清理会话 screen -wipe #清理那些dead的会话 screen状态介绍
Screen 的状态有两种，Attached 和 Detached，分别表示前台运行和后台运行。使用 screen -r 会话名（或者会话编号）可以将 Detached 状态的屏幕会话状态修改为 前台运行 ，并同时切换到这个会话中。如果会话状态已经是Attached状态，使用命令 screen -r name（或者会话编号）将会报错：There is no screen to be resumed matching 767(会话编号).如果需要切换到状态为Attached 的会话下，需要先执行 screen -d 会话名 将会话状态修改为 Detached。将当前会话转为后台运行可以使用快捷键ctrl + a,d。 如有错误欢迎指正！如果帮到您了，请点赞加收藏吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58fc1382aabfbf34ae6c21fb38affe2/" rel="bookmark">
			Android SELinux访问向量规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般如果系统某个文件无法访问，log中出现 avc 权限问题，我们只需要在对应 te 中添加 allow 规则就行。如下，只需要在 init.te 中为 vendor_sysfs_graphics:lnk_file 增加 read 权限即可。
init : type=1400 audit(0.0:14): avc: denied { read } for name="device" dev="sysfs" ino=51107 scontext=u:r:init:s0 tcontext=u:object_r:vendor_sysfs_graphics:s0 tclass=lnk_file permissive=0 但有时候会出现添加 allow 规则后编译不过情况。这种情况一般是由于源码 system 目录下 neverallow 规则冲突导致，需要针对修改 neverallow （system目录下这个修改大概率会导致GMS测试不过）。
上面就是我们最常见的修改。这里涉及到两个访问向量： allow、neverallow。除此之外，还有两个不常修改的两个：dontaudit、auditallow。
allow 表示允许主体对客体执行后面的操作
neverallow 表示不允许主体对客体执行后面的操作
dontaudit 表示检查策略信息，但是不记录违反规则的信息
auditallow 表示检查策略信息，记录违反规则的信息
前面两个好理解，后面两个简单来说。dontaudit 标记的权限，检查访问者无权限直接阻值，但是不输出任何记录，从log中看不到avc异常之类信息。auditallow 区别就在于会记录违反规则的信息，在log中输出提醒。
例子：
android P之后，/proc/stat CPU信息这个节点就禁止非系统应用访问。通过三方app去读取的话，可以看到有以下提示。
avc: denied { open } for path="/proc/stat" dev="proc" ino=4026532037 scontext=u:r:untrusted_app_all tcontext=u:object_r:proc_stat:s0 tclass=file permissive=1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d58fc1382aabfbf34ae6c21fb38affe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11741ad22e4cdeee557a84617a250596/" rel="bookmark">
			优生优育科学指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		受孕最好季节在夏末秋处的79月份，孩子在来年46月份，大热天”坐月子”即不利母亲的身体健康，也不利于婴儿的喂养。
在正常月经周期28天中，月经来潮第12~16天是排卵期，在这段时间性交可受孕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e7e1c79c36abfc5c53853c8dc9c0100/" rel="bookmark">
			Android 状态栏显示运营商名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 原生设计中在锁屏界面会显示运营商名称，用户界面中，大概是基于 icon 数量长度显示考虑，对运营商名称不作显示。但是国内基本都加上运营商名称。对图标显示长度优化基本都是：缩小运营商字体、限制字数长度、信号图标压缩上下叠加等。
SIM卡的 icon 对应的文件是 StatusBarMobileView，默认包含信号格、漫游、网络制式、上下行等图标。只需要在默认基础上，添加运营商名称View。
一、添加运营商名称view 在信号格后面增加运营商名称，System中对文字图标显示自定义 AutoMarqueeTextView 类（主要增加跑马灯和省略号的样式自动切换）处理，我们使用 AutoMarqueeTextView 显示名称即可。
//frameworks/base/packages/SystemUI/res/layout/status_bar_mobile_signal_group.xml &lt;FrameLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical"&gt; &lt;com.android.systemui.statusbar.AnimatedImageView android:id="@+id/mobile_signal" android:layout_height="wrap_content" android:layout_width="wrap_content" systemui:hasOverlappingRendering="false" /&gt; &lt;ImageView android:id="@+id/mobile_roaming" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/stat_sys_roaming" android:contentDescription="@string/data_connection_roaming" android:visibility="gone" /&gt; &lt;/FrameLayout&gt; &lt;com.android.systemui.util.AutoMarqueeTextView android:id="@+id/qs_carrier_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_weight="1" android:textAppearance="@style/TextAppearance.QS.Status" android:textDirection="locale" android:textSize="8dp" android:marqueeRepeatLimit="marquee_forever" android:singleLine="true" android:maxEms="4"/&gt; 然后调整好文字大小和长度适配。
二、对网络制式、上下行漫游图标长度压缩 默认图标都是从左到右排序的，这样会导致整体icon太长，状态栏放不下，从而导致icon被收到省略号中无法显示。
//frameworks/base/packages/SystemUI/res/layout/status_bar_mobile_signal_group.xml &lt;com.android.keyguard.AlphaOptimizedLinearLayout android:id="@+id/mobile_group" android:layout_width="wrap_content" android:layout_height="match_parent" android:gravity="center_vertical" android:orientation="horizontal" &gt; &lt;ImageView android:id="@+id/mobile_volte" android:layout_height="wrap_content" android:layout_width="wrap_content" android:visibility="gone" android:paddingEnd="2dp"/&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;FrameLayout android:layout_height="10dp" android:layout_width="10dp"&gt; &lt;ImageView android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e7e1c79c36abfc5c53853c8dc9c0100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/022b696ff5d7e97cc6cbc8ab09268336/" rel="bookmark">
			Error和Exception的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		error和exception都继承Throwable
error一般无法处理，编码时的异常，问题很严重
exceptiion指程序本身可以处理的异常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e255f80ccf252ae6c06083c53997fe7/" rel="bookmark">
			控制台实现汽车租赁系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汽车租赁系统需求：（基于控制台实现，适合基础小白练习使用）
1、包含汽车租赁和汽车管理两个模块
2、汽车租赁需要包含汽车租赁天数以及汽车租金结算功能
3、汽车管理需要包含租赁汽车的添加、删除、修改、查询功能
代码如下：
package Demo20230907; import java.util.HashMap; import java.util.Map; import java.util.Scanner; import java.util.Set; /** * &lt;p&gt;汽车租赁系统&lt;/p&gt; * * @author 波波老师(weixin : javabobo0513) */ public class Test01 { public static void main(String[] args) { //map存储店铺所有车 Map&lt;Integer, Car&gt; map = new HashMap&lt;&gt;(); map.put(1, new Car("跑车", "玛莎拉蒂", "鄂A11111", 1500.0D)); map.put(2, new Car("客车", "金龙", "鄂A22222", 1100.0D)); map.put(3, new Car("卡车", "皮卡", "鄂A333333", 800.0D)); map.put(4, new Car("跑车", "兰博基尼", "鄂A444444", 3200.0D)); Integer menuId = 0; do{ try { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e255f80ccf252ae6c06083c53997fe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44f06cf3729e91a9e285560ea47624a/" rel="bookmark">
			分辨率、刷新率、像素时钟速率、通道速率（dsi）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷新率： 分为垂直刷新率和水平刷新率，一般提到的刷新率通常指垂直刷新率。垂直刷新率表示 屏幕的图象每秒钟重绘多少次，也就是每秒钟屏幕刷新的次数，以Hz(赫兹)为单位。刷新率越高越好，图象就越稳定，图像显示就越自然清晰，对眼睛的影响也越小。刷新频率越低，图像闪烁和抖动的就越厉害，眼睛疲劳得就越快。一般来说，如能达到80Hz以上的刷新频率就可完全消除图像闪烁和抖动感。
分辨率： 分辨率可以从显示分辨率与图像分辨率两个方向来分类。
显示分辨率(屏幕分辨率)是屏幕图像的精密度，是指显示器所能显示的像素数量。由于屏幕上的点、线和面都是由像素组成的，显示器可显示的像素数量越多，画面就越精细，同样的屏幕区域内能显示的信息也越多，所以分辨率是个非常重要的性能指标之一。可以把整个图像想象成是一个大型的棋盘，而分辨率的表示方式就是所有经线和纬线交叉点的数目。显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。
图像分辨率则是单位英寸中所包含的像素点数，其定义更趋近于分辨率本身的定义。
mipi： 总述 在上一篇DSI协议协议讲解后，相信很多人还是云里雾里，因为一个是概念太多，另一个是纯理论，没有结合实际项目分析，难以让人有深刻的理解。看完本篇章依旧会云里雾里。但是还是要讲。本篇章将讲述DSI协议的时钟计算和常见概念区分，结合实际的开发过程，把MIPI时钟的意义、计算方式以及DSI协议中的几个容易混乱的概念进行区分。
（一）DSI协议讲解
（二）DSI时钟的计算和常见概念区分
（三）DSI时序讲解与实际测试
注：本系列文章有时候描述不严谨，MIPI 与DSI混用，MIPI是包括多种协议接口的总称，而DSI是特指MIPI在显示屏上的应用协议。大部分情况下，这么混用，相信大部分读者也是不会有误解的。
时钟计算 任何一个协议接口，都必须依赖时钟进行数据传输，比如串口、SPI、I2C、MIPI，包括其他液晶接口LVDS EDP等等。因为只有有时钟，数据才能进行按部就班的传输，否则传送接收不按照一定的规则来，就无法被准确识别。只是有的协议接口上明着存在时钟线，比如I2C（i2c clk）、MIPI(clock lane)，有的协议明面上没有一条时钟线，比如串口，但是他们一定会依赖时钟来进行传输数据，串口来说就是波特率，它是主从设备两端通过一定的时钟频率来发送接收的概念，所以串口本质上还是要依靠时钟来进行传输数据。
回到DSI的时钟上，我们来讲讲它的时钟是什么，有哪些种类，怎么计算。
我们还是先搬出这张DSI接口图，可以看到有一组Clock+ Clock-的连接线，这组连接线就是DSI的时钟信号线了。主从设备依靠这组时钟线上传输的时钟信号来指挥数据的传输和解析（LP模式下不需要这组时钟，因为在LP模式下的数据传输依靠的是Data0+ Data0-的异或来作为时钟的）。
液晶基础时钟概念
通用时钟概念 PORCH：液晶时序当中，常常用到的一些参数HSYNC、HBP、HACTIVE、HFP，VSYNC、VBP、VAVTIVE、VFP，概念如下：
HFP: Horizon front porch
HBP: Horizon back porch
VFP: Vertical front porch
VBP: Vertical back porch
HACTIVE： Horizon display period
VAVTIVE: Vertical display period
H-total = HSYNC+HBP+HACTIVE+HFP
V-total = VSYNC+VBP+VACTIVE+VFP
上述porch概念的具体含义，这里就不展开描述了。网上有很多资料，后续如果有更新液晶接口系列——RGB接口的话也许会重点讲解下这部分。简单说H-total 和V-total分别表示，为了传送一帧图像，每一行数据需要实际传送的像素数（H-total ）和总共需要传输几行（V-total），而这两个值不等于分辨率原因在于图像传输有一些时序要求，方便数据的同步等，所以每一行都会用一些无用（非图像数据）的像素（pixel）传输。
2、DSI时钟概念
Total pixel = H-total x V-total x fps（一般是60） fps是帧率，表示1s内传输的图像帧数，H-total x V-total表示一帧图像要传输的总pixel数，所以Total pixel 表示1s内要传输的pixel总数。说白了就是1s要传输多少个点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c44f06cf3729e91a9e285560ea47624a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776349873c2a6e0ff0d03e860bbbba58/" rel="bookmark">
			git报错：Please make sure you have the correct access rights and the repository exists
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在用vscode上 push更新到gitee上时报错Please make sure you have the correct access rights and the repository exists，原来是ssh key有问题，连接不上服务器，这里记录一下解决办法。
原因是我可能在企业的gitee上删掉了自己的另一个git账号。导致没权限访问和提交。
1. 重新在git设置一下身份的名字和邮箱
cmd|powershell| bash进入要提交的目录下，然后
git config --global user.name "yourname" git config --global user.email“your@email.com" 注：yourname是你要设置的名字，your@email是你要设置的邮箱。 2. 删除.ssh文件夹（直接搜索该文件夹）下的known_hosts，删除。
.ssh文件在C盘里面的。把known_hosts删除。
3. git bash输入命令
ssh-keygen -t rsa -C "your@email.com"（请填你设置的邮箱地址）
就像这样，然后一直回车就行了
打开C盘文件
id_rsa是私钥，要保管好，id_rsa.pub是公钥，复制里面的内容
4. 打开giuhub进行配置
右上角图标-&gt; settings-&gt; SSH and GPG keys
5. 重新push，就可以成功了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88aa27010f072c0dc870221048d40210/" rel="bookmark">
			springboot 请求https的私有证书验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、方案描述 我这里采用RestTemplate的方式调用https请求，请求第三方接口获取数据，证书由第三方私自签发的证书，我们构建的是一个springboot的API项目。
1.pom文件引入jar &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Apache HttpClient - Used to request HTTP resources over the network --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.构建一个RestTemplateConfig 构建RestTemplateConfig为了初始化RestTemplate让它具备验证证书功能。
/** * @Author: LongGE * @Date: 2023-08-28 * @Description: */ @Configuration public class RestTemplateConfig { /** * 1.创建一个KeyStore，并将需要信任的证书加载到KeyStore中。示例代码如下： * @return * @throws CertificateException * @throws IOException * @throws KeyStoreException * @throws NoSuchAlgorithmException */ @Bean public KeyStore createKeyStore() throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException { CertificateFactory certFactory = CertificateFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88aa27010f072c0dc870221048d40210/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89995e76c9119cfdaca79ec51dff32cb/" rel="bookmark">
			Qt制作基础功能的串口调试助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整工程文件详见uart: Qt制作串口调试助手
使用Qt5.12制作串口调试助手，实现功能如下图展示
相关设计逻辑及代码展示
串口调试助手首先是要对串口进行相关设置 private: Ui::Widget *ui;// ui对象指针，用于访问界面元素 QSerialPort mSerialPort; QString mPortName; // 端口号 QString mPortBaudrate; // 波特率 QString mPortParity; // 校验位 QString mPortDatabits; // 数据位 QString mPortStopbits; // 停止位 bool Widget::getSerialPortConfig() { //获取串口配置 mPortName = ui-&gt;Box_COM-&gt;currentText(); mPortBaudrate = ui-&gt;Box_baud-&gt;currentText(); mPortParity = ui-&gt;Box_parity-&gt;currentText(); mPortDatabits = ui-&gt;Box_databits-&gt;currentText(); mPortStopbits = ui-&gt;Box_stopbits-&gt;currentText(); /*设置串口配置*/ mSerialPort.setPortName(mPortName); // 端口号 mSerialPort.setBaudRate(mPortBaudrate.toInt());// 波特率 // 校验位 if("Even"==mPortParity) { mSerialPort.setParity(QSerialPort::EvenParity); }else if("Odd"==mPortParity) { mSerialPort.setParity(QSerialPort::OddParity); }else { mSerialPort.setParity(QSerialPort::NoParity); } // 数据位 if("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89995e76c9119cfdaca79ec51dff32cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad07a3e0cee932ea0d785cd23ed2924/" rel="bookmark">
			华清远见培训后感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是2023年7月10日来到华清学习，转眼间已经过去快两个月了，下面我来说说这段时间的心得。总的来说呢还是不错的，学习氛围浓厚，在这里可以感受到极大紧张感和压迫力，但一切的压力都是来源于自己的心理问题吧，。每天早九晚十，周末除了出去玩也会在教室里面自习，日复一日，给我的感觉就是很充实，每天都过的很快，但是有时候也有摆烂过，
放松过，这是因为偶尔缺失了学习的动力，但这种不好的状态只是暂时的，我会迅速的调整过来，总的来说就是不要给自己那么大压力，我应该过好每一天，学好每一天，每天都是学一点进步一点就完事了，不要太急于求成，每个人的成功经历都会要那么一个过程的。。
如果自己心理上出了问题，首先反省问题出在哪，想好了之后就去解决它，不能堆得太久，这样会对自己后续的学习生活都会有影响。还有一个就是我发现自己学的挺一般，一到做项目就不会了，总感觉自己学的比别人慢，但是我想想，这个到无所谓了，每个人的学习进度和成功都不一样，
有的人天生就逻辑好呢，这哪能比呀，所以我想的是别人一遍就学会了，那我学了两遍、三遍，我也不就会了嘛，这又啥打不了的呢？emm，感觉就这么多吧，也不知道该说啥了，总之我记得老师跟我说的话，最好不要掉队就行了，要跟上课堂的节奏就ok了。最后呢还有两个多月的学习时间，好好努力，且行且珍惜，实在不行就划班咯！
下面我分享一下我的部分学习笔记：
sqlist3:
对于表：
1.增：create table if no exists xx(num int); //create table 表名（列名，类型）
2.删：drop table xx; 3.改：只能增加列，不能减少列
alter table xx add colume num int //alter table 表名 add colume 列名 类型
4.查：.table .table xx
对于表中的数据：
1.增：insert into xx values(); //有多少列就加多少数据，不能多也不能少
2.删：delete from xx where name = "wzx"; //delete from 表名 where 条件
3.改：update xx from set name="wzx",num=1001 where name = "wzx";
4.查：select * from xx; //按表明查找
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad07a3e0cee932ea0d785cd23ed2924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23747626afaf2fd8001a73f979e21500/" rel="bookmark">
			win11 系统 Internet Connection Sharing (ICS) 服务无法关闭-问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题出现在matebook ego ,出现一个问题就是一连上电源，运行ipconfig ，WLAN 2就会自动给配上一个192.168.137.1的ip,一断开电源这个ip就会小时，因为我要创建一个热点，如果这个ip有了那么热点会创建失败！于是开始排查，先要停止这个服务。
运行compmgmt.msc正常停止提示
windows 无法停止 Internet Connection Sharing (ICS) 的解决方法
解决方法：
停止 Hyper-v 服务。进入控制面板-- 程序–查看或关闭windows功能 去掉Hyper-v 前面的勾，确定，重启电脑
如果不好用可以先禁用网卡，再进行尝试，或者把WlanSvc也停止了,记得之后打开不然wifi图标就没有了
sc stop WlanSvc
后来服务终于被停止了，但是接上电源线后发现这个服务又被人给偷偷起来了，看样子还是没有找到源头。先把服务删除了
sc delete SharedAccess
发现ip依然会分配。于是重置了系统好了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c505c9da12f78f78dc6e60026c12bdc9/" rel="bookmark">
			【消息中间件】详解三大MQ：RabbitMQ、RocketMQ、Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介
前言
博主之前写过一个完整的MQ系列，包含RabbitMQ、RocketMQ、Kafka，从安装使用到底层机制、原理。专栏地址：
https://blog.csdn.net/joker_zjn/category_12142400.html?spm=1001.2014.3001.5482
本文是该系列的清单综述，会拉通来聊一下三大MQ的特点和各种适合的场景。
目录
1.概述
1.1.MQ简介
1.2.MQ的应用场景
1.3.关注MQ的角度
2.RabbitMQ
3.RocketMQ
4.Kafka
5.三大MQ的对比
1.概述 1.1.MQ简介 消息中间件，其实准确的叫法应该叫消息队列（message queue），简称MQ。其本质上是个队列，有FIFO的性质，即first in first out，先入先出。
目前市场上主流的MQ有三款：
RabbitMQRocketMQKafka 1.2.MQ的应用场景 MQ一般用在几种场景：
流量削锋应用解耦异步任务 1.流量削锋
流量过大的时候，用MQ作为一个中间层，暂时存储流量，让流量在队列中排队去访问服务，从而控制直接访问服务的流量，减轻服务的实时流量压力。
以网购下订单为例：
2.应用解耦
使用MQ作为应用之间的中间层，从而使得应用直接不存在直接调用的关系，解除应用之间的耦合。这样在被调用的应用挂掉以后，应用之间的调用不会直接产生异常，请求仍可以正常发送，待被调用应用重新起来以后，再去消费处理MQ中挤压的调用请求，为系统的修复争取到了时间。
以支付系统为例：
3.异步任务
有些服务调用对于响应的实时性要求不高，允许延迟响应、异步处理。使用MQ可以将这些可以异步处理的请求，暂存在队列中，调用方不必等待，直接向下执行其他任务，被调用方消费MQ中消息后自行返回给调用方响应。
1.3.关注MQ的角度 虽然市面上的MQ数量众多、种类繁杂，但MQ其本质上就是用来暂时存放消息的一种中间件，其实从三个角度去关注MQ即可抓住MQ的核心：
消息可靠性消息模型吞吐量 1.消息可靠性
消息可靠性，即消息会不会丢失？围绕防止消息丢失做了哪些工作？
2.消息模型
消息模型，即支持以什么样的模式去消费消息？点对点？广播？发布订阅？其消息模型丰富度如何？
3.吞吐量
MQ作为用来减轻系统压力的中间件，其自身势必会经常面对很大的流量，吞吐量如何自然是要考虑的。
本文在最后横向对比三大MQ的时候就会从以上三点出发。除了以上三点，还有一点是值得额外关注的，就是扩容是否方便，即是否在架构上能很好的支持分布式架构。当然这不是核心点，要扩容怎么都能扩，只是看方便与否。
2.RabbitMQ RabbitMQ有几个特点：
遵从AMQP协议丰富的消息模型极消息可靠性高但是吞吐量不高 1.遵从AMQP
博主在之前的中间件系列中详细介绍了AMQP：
详解AMQP协议__BugMan的博客-CSDN博客
AMQP简单来说就是规定好了MQ的各个抽象组件，RabbitMQ则是一款完全严格按照AMQP来实现的开源MQ，使得很好被开源框架所集成，比如Spring AMQP专门就是用来操作AMQP架构的中间件的，因此RabbitMQ可以被Spring Boot很方便的集成。
2.丰富的消息模型
RabbitMQ也是三大MQ里提供的消息模型最丰富的一种MQ。
博主之前在博主在之前的中间件系列中详细介绍了RabbitMQ的六大消息模型：
SpringBoot RabbitMq 六大模式_springboot整合rabbitmq六种模式__BugMan的博客-CSDN博客
3.消息可靠性高但是吞吐量不高
RabbitMQRabbitMQ 提供了多种机制来确保消息的可靠性，包括持久化、消息确认、发布确认等。这些机制确保消息不会丢失，并且能够在各种情况下处理消息传递失败。但是由于存在这些用于保证消息可靠性的机制，RabbitMQ的吞吐量在三大中间件中是最低的。
博主在之前的中间件系列中详细介绍了RabbitMQ的消息防丢失：
RabbitMq消息防丢失（含springboot代码示例）_rabbitmq springboot work模式数据丢失__BugMan的博客-CSDN博客
博主在之前的中间件系列中也详细介绍了RabbitMQ如何防止重复消费，这种解法对所有MQ都是通用的，此处只是以RabbitMQ为例：
RabbitMQ重复消费_rabbitmq消息重复消费__BugMan的博客-CSDN博客
3.RocketMQ RocketMQ是一款开源的分布式消息中间件，最初由阿里巴巴集团开发并开源。它旨在为分布式系统提供可靠、高性能、可扩展的消息通信能力。其已经是阿里内部最核心的消息中间件，用来保证每年双十一期间系统的稳定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c505c9da12f78f78dc6e60026c12bdc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51619a5f6ca503b58b829a7616cf0f3/" rel="bookmark">
			【C&#43;&#43;】不用任何函数的简单 wstring to LPWSTR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::wstring wstr = L"Hello, World"; LPWSTR a = &amp;wstr[0]; 非常简单；string 类型同理；
解释一下：
大概是因为 LPWSTR本质上是指针，其次是一个以’\0’结尾的 wchar_t 数组；
而wstring/string在内存中其实也是以 ‘\0’ 结尾，这就确保了对齐；
联想一下普通的 char 数组中，可以用数组名作为数组首元素指针的特性，这里其实就是把wstring的首元素的地址赋值给 LPWSTR 变量，LPWSTR会从该地址开始，直到第一个出现在该内存区的 ‘\0’ 都视为一个整体；
所以如果只要你的 wstring/ string 中间不会出现 ‘\0’，那么啥事没有；
中间出现 ‘\0’ 实际上也是不可能的；
形如：
std::wstring a = L"He\0ll\0o"; 会发现实际上 a 保存的值就只有 “He” 两个；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315cd285b70054548f3842da1ff8d2b3/" rel="bookmark">
			部署Gitlab服务-推送、拉取代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备环境: 关闭防火墙和selinux
192.168.126.139 git-server #Gitlab服务器
192.168.126.140 git-client #gitlab客户端，用于拉取代码
我们是用ssh连接的，所以client创建秘钥，把公钥发给server
[root@client ~]# ssh-keygen #生成秘钥 [root@client ~]# ssh-copy-id -i git@192.168.246.214 #将秘钥传输到git服务器中的git用户 然后两个机器都要下载安装git 1.配置yum源 [root@git-server ~]# cd /etc/yum.repos.d/ [root@git-server yum.repos.d]# vim gitlab-ce.repo [gitlab-ce] name=Gitlab CE Repository baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever gpgcheck=0 enabled=1 安装相关依赖 [root@git-server yum.repos.d]# yum install -y postfix curl policycoreutils-python openssh-server [root@git-server yum.repos.d]# systemctl enable sshd [root@git-server yum.repos.d]# systemctl start sshd 安装postfix [root@git-server yum.repos.d]# yum install postfix -y #安装邮箱 [root@git-server yum.repos.d]# systemctl start postfix [root@git-server yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/315cd285b70054548f3842da1ff8d2b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f430e971dc13691eeeb6dd440df9aa2d/" rel="bookmark">
			jsvmp逆向(补环境篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书接上回 上篇文章写到tx的jsxmp的算法逆向，文章链接在这里。初试jsvmp加密
。但是可能有伙伴觉得不够详细。
这里放一个大佬的文章链接。
https://www.52pojie.cn/thread-1521480-1-1.html 。其实就是一个变形的xtea加密。
大佬的文章已经讲了很清楚了，我这里就不狗尾续貂了。
查看node环境参数 在逆向算法的时候，我们简单补了一下环境，让jsvmp能再node环境里面跑起来。但是生成结果肯定是不对的。直接拿来用是不行的。
我们上次在jsvmp里面插桩。拿到输出结果。
我们可以找到四个类似的字符串，我们逆向出算法可以知道，就是collect就是由这四个的字符串加密出来的。
我们拿到这个四个字符串和浏览器生成的进行对比。
查看浏览器生成的参数 我们在浏览器进行覆盖js，把我们本地js拿到浏览器里面运行，查看浏览器输出的环境，看看有啥不一样。
最后对比浏览器环境和node环境生成参数 这里拿别人大佬分析的参数，我自己再补充几个
data = { "0": 1, "1": "Mozilla/5.0 不给看 Edg/100.0.1185.44", "2": 12, "3": 0, "4": 1, "5": "2560-1440-1392-24-*-*-|-*", "6": "**0.***.***.*46", "7": "GgoAAAANSUhEUgAA 不给看 iPegAAAABJRU5ErkJggg==", "8": [], "9": 1440, "10": 0, "11": 0, "12": "ANGLE 不给看 vs_5_0 ps_5_0, D3D11)", "13": "https://captcha.gtimg.com/1/template/drag_ele.html?rand=1519713624347", "14": ["zh-CN", "en", "en-GB", "en-US"], "15": 1689646445, "16": 396149498, "17": 1689155967, "18": 1689646443, "19": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f430e971dc13691eeeb6dd440df9aa2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc815e40e7c40f40297952a113ab9432/" rel="bookmark">
			Studio 3T for MongoDB的介绍及语法简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用法介绍 Studio 3T是一款用于MongoDB数据库管理和开发的图形化工具，它提供了许多功能来简化MongoDB的操作和开发过程。以下是一些常见的Studio 3T用法：
连接到MongoDB服务器：
打开Studio 3T并创建一个新连接配置。输入MongoDB服务器的主机名、端口号、认证信息等。测试连接并保存配置，然后连接到MongoDB服务器。 导航数据库和集合：
在连接成功后，您可以在左侧的导航栏中看到MongoDB的数据库和集合列表。选择要操作的数据库和集合，然后在右侧的工作区中进行操作。 查询数据：
Studio 3T提供了一个强大的查询构建器，可以轻松构建MongoDB查询。选择要查询的集合，然后使用查询构建器创建查询条件。执行查询并查看结果。 编辑文档：
选择一个文档并在编辑器中进行编辑。您可以添加、删除或更新字段，然后保存更改。 导入和导出数据：
Studio 3T支持从各种数据源导入数据到MongoDB，也可以将数据导出到不同格式的文件中。 创建索引：
通过Studio 3T，您可以轻松创建和管理MongoDB的索引，以提高查询性能。 数据可视化：
Studio 3T提供数据可视化工具，可以帮助您分析和可视化MongoDB中的数据。 自动化任务：
Studio 3T还提供了一些自动化任务，如备份和恢复数据库，以及执行定期任务等。 查询性能优化：
使用Studio 3T的查询性能优化工具，可以分析和改进查询的性能。 版本控制：
Studio 3T支持版本控制，可以帮助团队合作开发MongoDB应用程序。 请注意，Studio 3T的功能和界面可能会有一些变化，因此建议查看官方文档以获取最新的使用指南和功能说明。希望这些基本用法可以帮助您开始使用Studio 3T来管理和开发MongoDB应用程序。
语法说明 以下是一些Studio 3T中常用的MongoDB语法示例，这些示例可以帮助您更好地理解如何使用Studio 3T来执行不同的操作：
查询数据：
查找所有文档：db.collection.find({}) 查找特定条件下的文档：db.collection.find({ field: value }) 更新文档：
更新单个文档：db.collection.updateOne({ field: value }, { $set: { newField: newValue } }) 更新多个文档：db.collection.updateMany({ field: value }, { $set: { newField: newValue } }) 插入文档：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc815e40e7c40f40297952a113ab9432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0137f98b99719e7aef7556fb14ce8503/" rel="bookmark">
			QT组件布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;QApplication&gt; // 包含Qt应用程序的头文件 #include &lt;QWidget&gt; // 包含QWidget类的头文件 #include &lt;QSpinBox&gt; // 包含QSpinBox类的头文件 #include &lt;QSlider&gt; // 包含QSlider类的头文件 #include &lt;QHBoxLayout&gt; // 包含QHBoxLayout类的头文件 int main(int argc, char *argv[]) { QApplication app(argc, argv); // 创建Qt应用程序对象 QWidget *window = new QWidget; // 创建一个窗口的指针 window-&gt;setWindowTitle("Enter your age"); // 设置窗口标题 QSpinBox *spinBox = new QSpinBox; // 创建一个微调框的指针 QSlider *slider = new QSlider(Qt::Horizontal); // 创建一个水平滑块的指针 spinBox-&gt;setRange(0, 130); // 设置微调框的数值范围 slider-&gt;setRange(0, 130); // 设置滑块的数值范围 // 建立滑块的valueChanged信号和微调框的setValue槽的连接，使它们的值保持同步 QObject::connect(slider, SIGNAL(valueChanged(int)), spinBox, SLOT(setValue(int))); // 建立微调框的valueChanged信号和滑块的setValue槽的连接，使它们的值保持同步 QObject::connect(spinBox, SIGNAL(valueChanged(int)), slider, SLOT(setValue(int))); spinBox-&gt;setValue(35); // 设置微调框的初始值为35 QHBoxLayout *layout = new QHBoxLayout; // 创建一个水平布局管理器的指针 layout-&gt;addWidget(spinBox); // 向布局管理器中添加微调框 layout-&gt;addWidget(slider); // 向布局管理器中添加滑块 window-&gt;setLayout(layout); // 将水平布局设置为窗口的主要布局管理器 window-&gt;show(); // 显示窗口 return app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0137f98b99719e7aef7556fb14ce8503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/818df23f7baa61ef5aa4b628482a2016/" rel="bookmark">
			Qt核心特性之 —— 「信号(Signal)与槽(Slot)」机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Qt 与 Qt Creator简介：
2、关于引用头文件的一些事儿： 3、信号(Signal)与槽(Slot)机制：
3.1、一个小例子： 4、自定义信号与槽： 4.1、运行效果：
5、信号与槽的特性： 6、Qt 4 版本以前 connect 用法：
7、使用 Lambda 表达式建立连接：
1、Qt 与 Qt Creator简介： Qt：
Qt (官方发音 [kju:t]，音同 cute)是一个跨平台的 C++ 开发库，主要用来开发图形用户界面 (Graphical User Interface，GUI) 程序，当然也可以开发不带界面的命令行 (Command-Line Interface，CLI) 程序。
Qt 是纯 C++ 开发的，所以学好 C++ 非常有必要。当然 Qt 还存在 Python、Ruby、Perl 等脚本语言的绑定， 也就是说可以使用脚本语言开发基于 Qt 的程序。
Qt 支持的操作系统有很多，例如通用操作系统 Windows、Linux、Unix，智能手机系统 Android、iOS、WinPhone，嵌入式系统 QNX、VxWorks 等等。
（简介来自http://c.biancheng.net/view/1792.html，里面还提供了 Qt 下载安装教程）
Qt Creator：
除此以外，就像使用 Visual Studio 集成开发环境来创建Windows平台下的 Winform / WPF 应用程序一样；我们也需要一个类似的软件来创建基于 Qt 的应用程序。这个软件就是 Qt Creator。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/818df23f7baa61ef5aa4b628482a2016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f67a5911d648c287781d143ef98beaff/" rel="bookmark">
			使用QT的QML实时显示海康威视网络摄像头的视频数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求背景：
开发的监控软件中有个监控页面需要实时显示网络摄像头的数据，整个监控软件是基于QT的QML语言开发的。在QML中播放视频使用MediaPlayer组件就可以，但网上看到的一些都是播放录制好的视频文件，对于实时播放摄像头数据介绍的比较少。
开发环境：
Debian11.3
Qt 5.15
海康威视网络摄像机视频流地址
若要从网络摄像头实时获取数据，需要知道摄像头的视频流地址，仅此而已。这里需要获取rtsp协议的地址，它是一种实时数据流传输协议。地址如下：
格式：
rtsp://用户名:密码@ip地址:554/Streaming/Channels/101
样例：
取第1个通道的主码流预览
rtsp://admin:123456789@10.10.6.100:554/Streaming/Channels/101
取第1个通道的子码流预览
rtsp://admin:123456789@10.10.6.100:554/Streaming/Channels/102
取第12个通道的主码流预览
rtsp://admin:123456789@10.10.6.100:554/Streaming/Channels/1201
QML代码实现
import QtQuick 2.12 import QtQuick.Controls 2.5 import QtMultimedia 5.0 Rectangle { x: 10 y:10 width: 1200 height: 800 color: "white" MediaPlayer { id: player autoPlay: true //source: "file:///home/test/test_camera.mp4" //播放本地视频文件 source: "rtsp://admin:123456789@10.10.6.100:554/Streaming/Channels/101" //播放摄像头实时数据 onError: { console.log(errorString) } } VideoOutput { anchors.fill: parent source: player } } 啰嗦一句
从上面的QML代码看，播放网络实时视频流实际和播放本地的视频文件一样，都是把URL赋值给source属性。差异只是不同的数据源需要填写正确的视频流地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ad6e71222be89a08ea533377cae8f6/" rel="bookmark">
			忘记mysql root账号密码解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		忘记mysql密码无法登录
1、跳过检查方式启动mysql服务
service mysqld start --skip-grant-tables 或（systemctl start mysqld --skip-grant-tables）
2、无密码登录mysql
mysql -uroot
use mysql
3、设置新密码（我是5.7版本没有password字段，可以用desc user 查看密码字段）
update user set authentication_string=password('你的密码') where user='root'; 4、退出重启MySQL服务
quit
service mysqld restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/941bd901d0aecef7d65808d3e74518bc/" rel="bookmark">
			FPGA开发中的常用通信协议与通信接口区别与联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、各类通信协议二、各类通信接口总结 前言 在FPGA开发中，通信接口和通信协议起着至关重要的作用。
一、通信接口是物理层的连接方式，它提供了电信号的传输通道，使得设备能够进行数据交换。通信接口规定了物理连接的引脚定义、电压电平、时序要求等。通信接口的作用表现在：
1. 通信接口提供了FPGA与外部设备之间的物理连接方式。通过选择适当的通信接口，FPGA可以与各种外部设备进行连接，例如传感器、执行器、显示器、通信模块等。
2. 通信接口的选择要考虑设备的特性和需求，以确保有效的数据交换和通信。通信接口决定了数据在FPGA和外部设备之间的传输速率。不同的应用可能对数据传输速率有不同的要求，如高速数据采集、实时控制等。选择适合需求的通信接口可以满足数据传输的实时性和带宽要求。
3. 通信接口定义了数据的格式和传输规则。不同的通信接口支持不同的数据格式和协议，如串行、并行、同步、异步等。选择适当的通信接口可以确保数据的正确传输和解析，同时简化数据处理的流程。
4. 通信接口的带宽和延迟对于数据传输的效率和实时性至关重要。高带宽的通信接口可以支持大量数据的高速传输，而低延迟的通信接口可以实现快速响应和实时控制。
二、通信协议是一组规定了数据传输的格式、编码方式、传输控制和错误检测等规则的约定。它定义了数据的结构和序列化方式，以确保通信的可靠性和一致性。
1. 数据传输规范：通信协议定义了数据的格式、编码方式、传输控制和错误检测等规范。它确保了数据在FPGA和外部设备之间的正确传输和解析。合适的通信协议可以确保数据的完整性、准确性和可靠性。
2. 通信协议定义了与其他设备或系统进行数据交换的规则和约定。通过选择广泛采用的通信协议，FPGA可以与其他设备或系统实现无缝的互操作性。这样可以简化系统集成的过程，并增强FPGA与其他设备的兼容性。
3. 带宽和速度要求：不同的应用可能对数据传输的带宽和速度有不同的要求。通信协议的选择可以根据系统需求来满足这些要求。
4. 资源利用和性能优化：通信协议的选择可以影响FPGA的资源利用和性能优化。某些协议可能需要更多的逻辑资源或存储器资源，而某些协议可能需要更多的计算资源。在设计中，需要综合考虑资源的分配和优化，以满足通信需求并提高系统性能。
5. 系统可扩展性：通信协议在系统的可扩展性方面起着关键作用。通过选择支持多主机或多设备连接的协议，可以轻松地扩展系统，并支持更复杂的通信拓扑。
一、各类通信协议 在FPGA开发中，常用的通信协议包括：
1. UART（通用异步收发传输器）：UART 是一种通用的串行通信接口。它通常用于连接外部设备，如微控制器、传感器等。
module UART_Transmitter ( input wire clk, input wire rst, input wire [7:0] data_in, output reg tx ); // UART波特率和时钟频率 parameter BAUD_RATE = 9600; parameter CLK_FREQ = 50000000; // 50 MHz reg [3:0] bit_count; reg [3:0] baud_counter; reg [7:0] data; reg start_bit; reg stop_bit; always @(posedge clk or posedge rst) begin if (rst) begin // 复位 bit_count &lt;= 4'b0000; baud_counter &lt;= 4'b0000; data &lt;= 8'b00000000; start_bit &lt;= 1'b0; stop_bit &lt;= 1'b1; tx &lt;= 1'b1; end else begin if (baud_counter == 0) begin baud_counter &lt;= CLK_FREQ / BAUD_RATE - 1; if (bit_count == 0) begin // 启动位 start_bit &lt;= 1'b0; data &lt;= data_in; bit_count &lt;= 4'b0001; end else if (bit_count &lt;= 7) begin // 数据位 start_bit &lt;= 1'b1; data &lt;= data &gt;&gt; 1; bit_count &lt;= bit_count + 1; end else if (bit_count == 8) begin // 停止位 start_bit &lt;= 1'b1; stop_bit &lt;= 1'b0; bit_count &lt;= bit_count + 1; end else if (bit_count == 9) begin // 空闲状态 start_bit &lt;= 1'b1; stop_bit &lt;= 1'b1; bit_count &lt;= 4'b0000; end end else begin baud_counter &lt;= baud_counter - 1; end end end always @(posedge clk) begin if (start_bit || (bit_count &gt;= 1 &amp;&amp; bit_count &lt;= 8)) tx &lt;= ~data[0]; else tx &lt;= 1'b1; end endmodule 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/941bd901d0aecef7d65808d3e74518bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4f6509c5d8f5381baefc24d7909cb6/" rel="bookmark">
			后台管理系统需要同时支持http和https的访问网址，而且只登录一次即可另一个网址自动登录——技能提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后台管理系统需要同时支持http和https的访问网址，而且只登录一次即可另一个网址自动登录 场景1.判断是否有`token`且`token`是否有效2.`vuex`中的`refreshPermissions`刷新权限功能根据`token`获取用户信息：通过`commit`给`mutations`中的`setUser`方法设置用户信息。`loadRoutes`就是加载路由的方法，由于权限部分有控制路由的展示与隐藏，因此在加载路由之前，要先获取权限，此处加个延时也是为了权限获取成功后再加载路由。 http与https区别Http码分类常用Http状态码全面的Http状态码 场景 最近在做后台管理系统，由于本人对这个不是很熟悉，因此今天遇到一个需求：要求同时支持http和https的访问链接时，我的第一反应就是这得后端处理，处理成http和https的自动切换，这样就不用我这边处理了。
后来发现，后台管理系统配置好http和https之后，其实是支持同时登录的，但是遇到了一个报错，如下：
这个是由于：在http登录后，用https的网址再次登录时，会因为页面中含有token并且在有效时间内，所以页面直接跳过login登录直接跳转到首页，这个功能是在app.vue中完成的。但是此时需要通过接口拿到用户信息及权限才可以。我漏了这个获取用户信息和权限的部分，导致上面展示用户信息时的报错。
在app.vue中的mounted生命函数中，先判断是否有token且token是否有效，如果有效，则触发vuex中的refreshPermissions刷新权限的功能，否则的话，会跳转到login页面。
上图中的checkAuthorization()方法就是判断是否有token且token是否有效的。
1.判断是否有token且token是否有效 function checkAuthorization(authType = AUTH_TYPE.BEARER) { switch (authType) { case AUTH_TYPE.BEARER: if (Cookie.get(xsrfHeaderName)) { const token = Cookie.get(xsrfHeaderName); const expiresIn = Cookie.get("expiresIn"); if (token &amp;&amp; new Date().getTime() &lt; expiresIn) { return true } } break case AUTH_TYPE.BASIC: case AUTH_TYPE.AUTH1: case AUTH_TYPE.AUTH2: default: break } return false } 2.vuex中的refreshPermissions刷新权限功能 actions: { refreshPermissions({ commit }, callback) { const accessToken = Cookie.get("Authorization"); var token = accessToken.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf4f6509c5d8f5381baefc24d7909cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3c5c0df087dc4a7108094bc3497469/" rel="bookmark">
			Ubuntu中安装gcc编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、gcc编译器是什么？二、使用步骤 1.Ubuntu安装gcc编译器2.使用gcc编译器生成可自行文件 前言 在Ubuntu中是可以直接编译C语言文件的，需要安装gcc编译器，在Ubuntu中默认是没有安装gcc编译器需要自己手动安装，安装完直接就可以使用
一、Ubuntu安装gcc编译器 build-essential就是gcc的安装包，提供了编译程序所需的所有软件包
打开Ubuntu终端，输入" sudo apt-get install build-essential " 输入自己的密码开始安装
sudo apt-get install build-essential
等待安装完成，完成之后输入" gcc -v " 命令查看gcc编译器的版本号 gcc -v
最后下面的“gcc version 7.5.0”说明本机的 gcc 编译器版本为 7.5.0
二、使用步骤 1.编写一个最简单的C程序 新建一个C语言.c文件在终端中输入touch 文件名.c 输入以下代码保存
touch my_mian.c
#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
printf("Hello World!\n");
}
2.编译可执行文件 我们使用“gcc my_main –o my_main.c”来编译 my_main.c 文件，使用参数“-o”来指定编译生成的可执行文件名字，至此我们就完成 Linux 下 C 编程和编译的一整套过程。
gcc -o my_mian my_mian.c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e02641e2205603a3c82301e0f67d620/" rel="bookmark">
			解密全产业供应关系，助力企业寻找客户资源，洞察商机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在当今商业竞争日益激烈的时代，企业要实现长期可持续的发展，需要深入了解供应链关系，抢先捕获商机，拓展优质的客户资源。然而，供应链关系错综复杂，商机、客户隐藏在其中，如何挖掘和洞察成为了企业亟需解决的难题。
五度易链基于产业链上下游的视角，帮助企业构建全局的供应链可视性。企业能够了解自身在供应链内所处的位置，摸清上游原材料及零部件供应企业，下游业务依赖企业、配套服务商和耗材生产商，从而挖掘潜在的合作伙伴，优化供应链合作，提高整体供应链的效率和灵活性。企业还可以结合平台情报监测和企业大数据，预判供应链上下游的潜在风险及供应商的可持续性，及时调整合作战略。
一、解析供应链，掌握全局洞察
企业的供应链关系涵盖了多个环节，关系错综复杂。了解整个供应链的运作模式和关系，对于企业发展至关重要。通过绘制供应链全景图谱，将各个环节有机连接，帮助企业掌握全局，做出更为明智的决策。企业可以轻松洞察到供应链中的关键节点和合作伙伴，为发展提供更有力的支持。
二、细化环节，剖析商机潜力
供应链的每个环节都可能隐藏着商机的潜力。然而，要想准确捕获这些商机，需要对每个细分领域环节进行深入剖析。通过细化供应链环节，企业可以更清晰地了解每个环节的特点和潜力，从而更好地把握商机。这种精细化的洞察将帮助企业在激烈的市场竞争中脱颖而出。
三、输出清单，实现精准匹配
了解供应链关系之后，企业需要找到与自身业务相匹配的合作伙伴。通过输出各环节企业清单，企业可以精准地匹配合作伙伴，找到最适合自己的资源和合作机会。这种精准匹配将为企业的合作和发展带来更大的便利和效益。
四、洞察竞品，抢占市场份额
除了了解合作伙伴，了解竞争对手同样重要。通过绘制供应链全景图谱，企业不仅可以洞察自身的合作伙伴，还可以清晰地了解竞争对手的供应链关系。这有助于企业抢占市场份额，制定更有针对性的竞争策略，保持在竞争中的优势地位。
五、优化协同，提升效率
供应链的高效协同对于企业的运营效率至关重要。通过绘制供应链全景图谱，企业可以更好地识别供应链中的协同问题和瓶颈，从而采取相应的优化措施。优化协同将使供应链更加流畅，企业的生产和运营效率得到提升。
六、引领未来，迎接挑战
企业在发展过程中难免会遇到各种挑战，而供应链的稳定性和高效性是应对挑战的重要基础。通过深入了解供应链关系，企业可以更好地预测未来的发展趋势，迎接挑战。这种前瞻性的洞察将使企业在不断变化的商业环境中保持灵活应变的能力。
综上所述，供应链关系的洞察和商机的捕获对于企业的发展至关重要。通过绘制供应链全景图谱，细化供应链细分领域环节，输出各环节企业清单，企业可以更好地掌握供应链关系，捕获商机，实现智能决策。这种深入洞察的方式将引领企业走向更加智能、高效的发展之路。
产业分析产业链建设产业大数据产业园招商大数据招商智慧招商平台数字化园区数字经济产业集群计算机视觉汽车产销量纺织行业分析半导体设备半导体芯片光刻机行业 产业大经济大数据解决方案大数据智慧招商解决方案企业创新服务解决方案产业大数据开放服务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b40fb42e97952fd4b9e5680bbe508318/" rel="bookmark">
			在Vue3中导入Echart飞机航线图的china.js文件，控制台报错TypeError: Cannot read properties of undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整报错为：TypeError: Cannot read properties of undefined (reading 'echarts')at china.js:13:22
at china.js:15:3
问题前景：我echarts也下载了，main.js也引入了，使用静态的（echarts官网所提供的）图是可以渲染出来，并没有报错，但是唯独需要导入第三方js脚本的echarts图却报错，排查了下，在import “../src/assert/china.js”的时候就报错。
解决方案：可能是因为echarts的5版本的原因哈，猜测。。。
把china.js文件放到你安装下载的echarts目录里面（echarts@5.4.3/node_modules/echarts/）
把china.js文件放到echarts@5.4.3/node_modules/echarts/下面，然后在导入，就完美解决了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52df3a8cfd52560e4e6e526918cdda01/" rel="bookmark">
			vue 脚手架新手入门（vue cli 3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、vue中的 “:” 绑定和 “@” 监听1.1、v-model 双向绑定 2、if 、else 、for3、computed 计算属性4、生命周期（属性加载顺序）5、watch 侦听器6、 components 组件6.1、props 从父组件获取收据6.2、emits 向父组件触发事件6.3、slots插槽， 将模板片段传递给子组件 1、vue中的 “:” 绑定和 “@” 监听 “:” 是指令 “v-bind”的缩写。用来绑定数据@”是指令“v-on”的缩写。用来监听，并调用方法 下面是绑定class属性的数值。
监听点击动作
1.1、v-model 双向绑定 双向绑定
上面的操作等于
&lt;input v-model="text"&gt; v-model 会将被绑定的值与 的值自动同步，这样我们就不必再使用事件处理函数了。
v-model 不仅支持文本输入框，也支持诸如多选框、单选框、下拉框之类的输入类型。
完整示例
&lt;script&gt; export default { data() { return { text: '' } }, methods: { } } &lt;/script&gt; &lt;template&gt; &lt;input v-model="text" placeholder="这里输入"&gt; &lt;p&gt;{{ text }}&lt;/p&gt; &lt;/template&gt; 2、if 、else 、for if、else
&lt;script&gt; export default { data() { return { awesome: false } }, methods: { toggle() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52df3a8cfd52560e4e6e526918cdda01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff8cf99116a44fede7d0561cbf0fbc7/" rel="bookmark">
			解决nginx反向代理缺少css,js文件的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接粘贴到配置文件即可
location ~* \.(js|css|png|jpg|jpeg|gif|ico|eot|otf|ttf|woff|woff2)$ { proxy_pass 代理的地址; add_header Access-Control-Allow-Origin *; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; expires 1d; } location = /favicon.ico { log_not_found off; } location /oa/ { proxy_pass http://192.168.189.164:1340/; } location /static/ { proxy_pass http://192.168.189.164:1340/static//; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ccf624783066b27a7f21c75c5575a5/" rel="bookmark">
			微信小程序：自定义多选框样式，实现多选、全选功能，以及使用css实现选中打钩效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;scroll-view class="page-container" scroll-y="true" enable-back-to-top="{{true}}"&gt; //多选组 &lt;checkbox-group bindchange="checkboxChange"&gt; &lt;view class="box" wx:for="{{records}}" wx:key="id"&gt; //使用label包裹多选框和自定义样式 &lt;label class="box-checkbox {{item.checked? 'is-checked':''}}"&gt; //隐藏原生多选框 &lt;checkbox value="{{item.id}}" hidden="{{true}}" checked="{{item.checked}}"/&gt; //自定义多选框 &lt;view class="box-checkbox_icon"&gt;&lt;/view&gt; &lt;/label&gt; &lt;view class="box-item"&gt; //...记录项内容 &lt;/view&gt; &lt;/view&gt; &lt;/checkbox-group&gt; &lt;/scroll-view&gt; &lt;!-- 底部固定卡片 --&gt; &lt;view class="fixedCard"&gt; &lt;view class="fixedCard-text"&gt; &lt;view class="fixedCard-text_allcheck"&gt; &lt;checkbox-group bindchange="handleAllCheck" &gt; &lt;label class="box-checkbox {{allcheck? 'is-checked':''}}"&gt; &lt;checkbox value="{{allcheck}}" hidden="{{true}}" checked="{{allcheck}}" /&gt; &lt;view class="box-checkbox_icon"&gt;&lt;/view&gt; &lt;/label&gt; &lt;/checkbox-group&gt; &lt;view&gt;全选&lt;/view&gt; &lt;/view&gt; &lt;view&gt; 共&lt;text class="fixedCard-text_highlight"&gt;{{totalOrder}}&lt;/text&gt;个订单，&lt;text class="fixedCard-text_highlight"&gt;{{totalMoney}}&lt;/text&gt;元 &lt;/view&gt; &lt;/view&gt; &lt;view class="fixedCard-button" bind:tap="handleNextStep"&gt;下一步&lt;/view&gt; &lt;/view&gt; //选择订单项 checkboxChange(e){ const records = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ccf624783066b27a7f21c75c5575a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dfc52f1c2b64af90682b1c02541b479/" rel="bookmark">
			keras模型训练 &#43; .h5转变可部署.pb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核对环境：
tensorflow版本： 2.0.1 keras版本: 2.3.1 数据集文件夹结构：
模型训练：
# -*- coding: utf-8 -*- """ Created on Sat Jun 6 14:28:50 2020 @author: USER """ from __future__ import absolute_import,division,print_function,unicode_literals import tensorflow as tf from tensorflow.keras.preprocessing.image import ImageDataGenerator from tensorflow.keras import layers import os import matplotlib.pyplot as plt import pathlib data_dir = '~/dataset/my_dataset/' PATH = pathlib.Path(data_dir) train_dir = os.path.join(PATH,'train') validation_dir = os.path.join(PATH,'validation') train_rose_dir = os.path.join(train_dir,'rose') train_sunflowers_dir = os.path.join(train_dir,'sunflowers') validation_rose_dir = os.path.join(validation_dir,'rose') validation_sunflowers_dir = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dfc52f1c2b64af90682b1c02541b479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08eae7df8883abd3b9a07e29f57075ba/" rel="bookmark">
			【火电机组、风能、储能】高比例风电电力系统储能运行及配置分析附Matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器
信号处理 图像处理 路径规划 元胞自动机 无人机 电力系统
⛄ 内容介绍 第十四届全国大学生电工数学建模竞赛A题论文及代码
要实现碳中和，就需要找到清洁能源代替非清洁能源这一切实可行的方法；另一方面，能源需求和经济发展之间具有同步增长规律。也就是说，当中国经济维持上升趋势时，能源需求量也会相应增加，若不对单位GDP相应能源的碳排放量进行有效约束，碳中和目标就很难实现。
风能是可再生清洁能源，因总资源蕴藏量巨大，可再生，无污染，日益引起世界各国关注。伴随着风电在电源结构中所占比重的日益提高，风电自身存在的随机性，波动性和不稳定性等问题对于电力系统的安全和稳定运行产生了日益显着的影响。大规模风电消纳问题始终是个棘手问题。
储能技术对于解决风电消纳比例较高，提高系统可靠性具有重要意义。充分利用风能资源可以实现绿色发展和节能降耗，但风力发电特点不同于常规发电，风电具有间歇性和波动性，大范围风能并网对电网造成影响。为了解决高渗透分布式风电并网给配电网带来的安全性和可靠性等问题，储能技术成为保证风电消纳和提高系统经济效益的有效手段。研究电力系统储能系统的功能定位和配置原则，有着十分重要的意义。
目标函数为系统发电总成本最小，发电总成本=火电成本+风电成本+储能成本+弃风损失+失负荷损失；
火电成本=运行维护成本+发电煤耗成本+碳捕集成本，
当使用传统的火电机组煤耗量计算公式对该最优化调度问题进行建模时，将会得到一个二次规划问题，这是由于火电机组的煤耗量是关于机组出力的一元二次函数，使得该问题的目标函数中含有非线性的部分，而当模型中火电机组的个数或调度周期增加时，求解该最优化问题的时间成本和难度将大大上升。基于此，为了降低模型求解难度，加快最优化求解计算速度，本文使用分段线性化方法将火电机组的二次煤耗量计算公式转为一次函数，进而使整个最优化模型转化为线性规划模型。火电机组的煤耗量函数图像如下，其中实线表示分段线性化处理后的火电机组煤耗量函数，虚线表示分段线性化处理之前的火电机组煤耗量函数。
⛄ 部分代码 clc;
clear;
%% 定义
load One_day_load;
load One_day_Wind;
mpc = [600,300,150;
180,90,45;
0.72,0.75,0.79;
786.8,451.32,1049.5;
30.42,65.12,139.6;
0.226,0.588,0.785];
tan = 0;
%% 求解
[Cost,PDE] = Yalmip_Cplex(Load,mpc,tan);
zongfuhe=0.25*sum(Load)
%% 画图
figure(1);
bar(PDE(1,:));
hold on
bar(PDE(2,:));
bar(PDE(3,:));
plot(Load,'r-*');
plot(PDE(1,:)+PDE(2,:)+PDE(3,:),'k--')
hold off
legend('一号机组','二号机组','三号机组','负荷需求','总发电功率');
xlabel('时段/15min');
ylabel('功率/MW');
title('机组日发电计划曲线');
⛄ 运行结果 ⛄ 参考文献 [1]孙伟卿, 罗静, 张婕.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08eae7df8883abd3b9a07e29f57075ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/830897a5201970c8f68500c5ff5c3a17/" rel="bookmark">
			Keil最舒服的配色方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次重装keil，都会重新配置下颜色，因为默认的颜色，看久了实在不太舒服，每次调到一个舒服的颜色，都要花不少时间，为了后面节省时间，现记录一下，如下就是我觉得还不错的配色方案，如果你觉得也还可以，可以接着往下看！
一、进入配置
二、光标所在行颜色配置
右边就是光标所在行前景色跟背景色的配置，我配置的背景色RGB是 216 171 237
三、编辑区颜色配置
前景色都不用修改，主要是配置背景色
RGB 230 251 246，然后添加到自定义颜色
然后将如下红色框中，除了红线划掉的那两个，其它的背景色都配置成刚刚自定义的那种颜色
这样编辑区中的颜色就修改完成了
如果你还想改工程中其它方框中的颜色，就接着往下看！
如左侧工程方框跟编译输出方框中的背景色，这个是跟随系统的，需要改注册表中的配置！
四、工程背景色修改
①按下win+R，输入 regedit 回车
然后找到这里的Window双击，就可以配置背景色了，输入230 251 246
修改完后需要重启一下电脑才能生效！
最后，如果你觉得改的不好，想恢复默认，那么很简单
只需将安装目录下的global.prop文件删除就行了，如我的keil是安装在C盘，global.prop文件在C:\Keil_v5\UV4下，删除它重新打开keil就恢复到配置之前的颜色了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3056545fa4aeb80dc705b2990145845f/" rel="bookmark">
			企业微信自建应用开发流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发需知 1、企业微信后台管理（不是小程序管理后台）：企业微信
2、企业微信开发者文档（不是小程序文档）：概述 - 接口文档 - 企业微信开发者中心
3、开发应用的类型：根据开发应用类型选择文档。
4、文档中有服务端API和客户端API，根据需要查看对应的API说明。一般授权相关的在服务端API，相询基础信息、客户信息、联系人等在客户端API。
5、开发需知：https://developer.work.weixin.qq.com/document/path/90665，https://developer.work.weixin.qq.com/document/path/91039
6、创建企业内部应用的步骤：https://developer.work.weixin.qq.com/tutorial/detail/45
构造访问链接 1、在自建应用里找到创建的应用，点击应用进入应用详情，能看到AgentId,Secret等信息。
2、设置应用主页，如下图：
这个主页就是我们要访问的应用首页地址。格式：https://open.weixin.qq.com/connect/oauth2/authorize?appid=CORPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE&amp;agentid=AGENTID#wechat_redirect 参数说明：
参数必须说明appid是企业的CorpIDredirect_uri是授权后重定向的回调链接地址，（即我们创建的应用首页的访问地址，需用域名）请使用urlencode对链接进行处理response_type是返回类型，此时固定为：codescope是应用授权作用域。 snsapi_base：静默授权，可获取成员的基础信息（UserId与DeviceId）； snsapi_privateinfo：手动授权，可获取成员的详细信息，包含头像、二维码等敏感信息。state否重定向后会带上state参数，企业可以填写a-zA-Z0-9的参数值，长度不可超过128个字节agentid是应用agentid，建议填上该参数（对于第三方应用和代开发自建应用，在填写该参数的情况下或者在工作台、聊天工具栏、应用会话内发起oauth2请求的场景中，会触发接口许可的自动激活）。snsapi_privateinfo时必填否则报错；#wechat_redirect是终端使用此参数判断是否需要带上身份信息 员工点击后，页面将跳转至 redirect_uri?code=CODE&amp;state=STATE，企业可根据code参数获得员工的userid。code长度最大为512字节。
详细介绍：构造网页授权链接 - 接口文档 - 企业微信开发者中心
注意事项：
1、链接中appid前面是固定的，https://open.weixin.qq.com/connect/oauth2/authorize?
2、redirect_uri的值就是我们应用的访问地址，并且要用域名访问。需要转码。
3、在线转码工具：在线URL编码解码工具-UrlEncode编码-UrlDecode解码在线工具
例如，应用的主页地址为：
https://open.weixin.qq.com/connect/oauth2/authorize?appid=ww123456&amp;redirect_uri=https://test.com.cn/#/test/index&amp;response_type=code&amp;scope=snsapi_privateinfo&amp;state=wechat&amp;agentid=10000#wechat_redirect
用上面的转码工具转码后的地址为：
https%3A%2F%2Fopen.weixin.qq.com%2Fconnect%2Foauth2%2Fauthorize%3Fappid%3Dww123456%26redirect_uri%3Dhttps%3A%2F%2Ftest.com.cn%2F%23%2Ftest%2Findex%26response_type%3Dcode%26scope%3Dsnsapi_privateinfo%26state%3Dwechat%26agentid%3D10000%23wechat_redirect
此转码后的地址即为应用主页地址。
注意：
1、应用主页只能填写一个地址，所以为了区分测试和生产环境，要创建两个应用。两个应用有两个不同的应用id和应用secret。在注入应用权限时要区分应用id。
2、获取access_token是调用企业微信API接口的第一步，相当于创建了一个登录凭证，其它的业务API接口，都需要依赖于access_token来鉴权调用者身份。因此开发者，在使用业务接口前，要明确access_token的颁发来源，使用正确的access_token。每个应用有独立的secret，获取到的access_token只能本应用使用，所以每个应用的access_token应该分开来获取。所以要把两个应用的secret都要提供给后台（access_token是后台获取的，需要企业id和应用secret）。
详细开发流程及API调用：
https://github.com/limchen233/Front-Web/blob/dev/22%20%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/2%E3%80%81%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%BB%BA%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.mdhttps://github.com/limchen233/Front-Web/blob/dev/22%20%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/2%E3%80%81%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%BB%BA%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.md 22 第三方应用开发/2、企业微信自建应用开发流程.md · lamCheung/Front-Web - Gitee.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/500bc6c56bac4517c47e556e213ad23c/" rel="bookmark">
			线性空间、子空间、基、基坐标、过渡矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性空间的定义 满足加法和数乘封闭。也就是该空间的所有向量都满足乘一个常数后或者和其它向量相加后仍然在这个空间里。进一步可以理解为该空间中的所有向量满足加法和数乘的组合封闭。即若 V 是一个线性空间，则首先需满足：
注：线性空间里面的元素称为向量 线性空间证明 若要证明 V 是数域 P 上的线性空间（表示为V(P))，必须验证 V 对于向量的加法与数乘运算封闭，且满足8条性质；若要说明 V 不是数域 P上的线性空间，则只需说明 V 对于向量的加法与数乘运算其中之一不封闭，或者运算不满足8条中的某一条即可。 例题：
证明：定理1.1 线性空间Ｖ 有唯一的零元素，任一元素也有唯一的负元素.
注：零元素不一定都是0.
常见的线性空间 比如 就是一个线性空间，图形表示就是一个平面直角坐标系。任取向量 和 做线性组合，+=
{0} （向量0）也是一个线性空间，并且是最简单的线性空间，很容易验证0满足加法数乘封闭和8条运算规则虽然很容易就列出了两个线性空间，但并不是所有空间都是线性空间.
非线性空间 线性子空间 定义：设是数域 K 上的线性空间Ｖ的一 个非空子集合，且对已有的线性运算满足 ：
（１）如果，则。
（２）如果，则 。
注：(1)(2)表示的是加法和数乘封闭原则。
则称为Ｖ的线性子空间或子空间。 如果 (表示空集) ，称为平凡子空间；否则称为非平凡子空间。
例如：
基 例题：
在中，求 在基（I）：
下的坐标。
由：
解出：
从而A在基（I）下的坐标为：
基变换与坐标变换 坐标变换公式为式1.1.8 例题：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8159762ab27932cdb665c6825d6b8fb5/" rel="bookmark">
			Mysql的B树和B&#43;树分别能存储多大的数据量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql的B树和B+树分别能存储多大的数据量 1、Mysql B-Tree (不读"B减树"，而读"B杠树"或者"B树") 第一层: 16
由于数据与key和指针都存放在了各自节点中，所以16k的节点，按数据1k计算，只能存放16条数据，即16个key
第二层: 16 * 16 = 256
第三层: 16 * 16 * 16 = 4096
三层加起来: 大约4000条数据
2、Mysql B+Tree 第一层: 16 * 1000 / 16 = 1000条
16 * 1000表示节点大小默认为16k，估算1k=1000，16表示8字节key长度+8字节指针。但有资料说指针长度是6字节，加起来应该是14字节，此处仅估算按16字节
第二层: 1000 * 1000 = 100w条
第一层的一个节点中有1000条数据，那分段有多少呢，1000+1个分段，但此处估算就不+1了，每个分段有一个指针指向二层的子节点，将有1000个子节点，每个子节点的数据量与第一层的数据量一样，即1000条数据
第三层: 1000 * 1000 * 16 = 1600w条
第三层因为存放了数据，所以key的数量就没那么大了，按一条数据1k计算，大约能存16条数据(16k/1k=16条)
1000表示第二层有1000个节点，第二个1000表示第二层每个节点有1000个指针(即在第三层上有1000个子节点)，第三层的每个节点有16条数据
总数据量并不是将三层的数据量加起来，因为B+树只有叶子节点存数据，即第一层和第二层没有存放数据。所以第三层的数据量就是总数据量: 1600w条数据。上线取整到2000w条数据。
3、总结 B-Tree: 4000 条, 千级
B+Tree: 2000w条,千万级
一般是3层，即Mysql通过3次IO操作就可以找到数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8276402da3f3c3b869be8010db41f63b/" rel="bookmark">
			中科软面试经历，已拿到offer请大佬给点意见。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java面试题网站：www.javaoffers.com
今天去了中科软，先笔试，笔试完了，面试，面试官和我聊得都很开心，技术上感觉面试官不是大牛。当场给了我offer。
我要的工资是8K。在网上查了一下这个公司，基本都是负面的信息。现在犹豫要不要去。。。。。请大佬给点意见。。
现在来补充：
offer已经委婉拒绝，这里再次感谢中科软能给我这次机会谢谢。原因：我本人是个技术控，喜欢学习更牛更先进的技术，听说他们那里的技术都是老技术。比如底层纯servlet，本人也想找一个好一点的公司和团队，并打算一直发展下去。
哎。继续投简历继续面试吧。。。。。
2018年
-----------------------------------------------------------------------------------------------------------
2023年
北漂的这几年我也经历了好几家公司. 创业形公司,中厂,大厂都去过. 目前在大厂. 无论如何自己一定要坚持学习. it这个道路不好走. 摆好心态尽力而为. 加油兄弟们.github自己写的开源项目.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395c811374cc269f613509ec079d0282/" rel="bookmark">
			手把手教你写一个简单的ioc容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ioc IOC（控制反转） 就是 依赖倒置原则的一种代码设计思路。就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。
Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。实现IOC的主要设计模式是工厂模式。
一、主要实现的功能 创建自定义注解@WqxBean，该注解的功能是：被该注解标记的类，会被注册到ioc容器中创建自定义注解@Di，该注解的功能是：被该注解标记的属性，将会从ioc容器中取出对应的实例化对象，使用该对象将被标记的属性初始化。 二、实现的步骤 1.创建模块 wqx-spring2.创建两个测试需要用到的类service，dao3.创建两个注解 @WqxBean @Di4.创建ioc容器接口5.实现ioc容器接口 2.1 创建模块 2.2 创建两个测试需要用到的接口及其实现类service，dao interface UserDao.class
package wqx.dao; /** * @author Watching * * @date 2023/9/5 * * Describe: */ public interface UserDao { public void run(); } class UserDaoImpl.class
package wqx.dao.impl; import wqx.anno.WqxBean; import wqx.dao.UserDao; /** * @author Watching * * @date 2023/9/5 * * Describe: */ @WqxBean public class UserDaoImpl implements UserDao { @Override public void run() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/395c811374cc269f613509ec079d0282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6addb5d44e6854c8bf24416395df571d/" rel="bookmark">
			自用常用正则表达式合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		export default { validation: ((rule, value, callback) =&gt; { //使用示例 // rule = { // 'text1': [ //'text1'为表单变量字段名,与v-model中的formData.xxxx保持一致，与el-form-item中的prop=xxxx保持一致； // { // validator: this.validation, //必填：固定值 // check: ['empty', 'blank'], //必填：字符串数组，其中的类型值可参考validation.js中switch case语句中的注释 // label: '用户名', //选填：字符串，若传此参数，错误信息文本的前面则会加上此文本，如“不能为空”将变成“用户名不能为空” // message: '请输入正确的身份证号码', //选填：字符串，若传此参数，则会使用此文本作为错误提示 // maxlength: 5, //选填：数字，若传此参数，除了check中的项目，还会追加字符长度验证 // }], // } if (rule &amp;&amp; rule.check) { let result, message = rule.lable || ''; //如果值为空且不包含非空验证，则跳过本次验证 if (!rule.check.includes('empty') &amp;&amp; !value) { result = true } else { for (let type of rule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6addb5d44e6854c8bf24416395df571d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eee3aca639fd3c75cc9eb71d71bfb92/" rel="bookmark">
			-source 1.7 中不支持 lambda 表达式(请使用 -source 8 或更高版本以启用 lambda 表达式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.idea 的sdk，jdk也已经设置为了java1.8 2.本地jvm环境也是1.8 还是这样 后来发现是我的maven的配置的java环境不是1.8。选择idea使用的maven的配置文件 打开H:\apache-maven-3.3.9-repository下的setting.xml，看到原来配置的是java1.7，更改为1.8就好了。 推荐一个 宝宝启蒙、动物认知、动物叫声 的小程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444d62b74099e6370406f00c1221ff56/" rel="bookmark">
			SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside stric
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let session = require('express-session'); ^^^ SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode at exports.runInThisContext (vm.js:53:16) at Module._compile (module.js:373:25) at Object.Module._extensions..js (module.js:416:10) at Module.load (module.js:343:32) at Function.Module._load (module.js:300:12) at Module.require (module.js:353:17) at require (internal/module.js:12:17) at Object.&lt;anonymous&gt; (/home/qubianzhong/workspace/antzb-operate/operate-backend/bin/www:7:11) at Module._compile (module.js:409:26) at Object.Module._extensions..js (module.js:416:10) 这是因为 node的版本太低造成的，可以去官网上下载了个最新的版本（ https://nodejs.org/zh-cn/download/current/），或者升级一下node的版本。 node 升级 node有一个模块叫 n ，是专门用来管理node.js的版本的。 第一步：首先安装n模块： npm install -g n
第二步：升级node.js到最新稳定版 n stable
第二步：n后面也可以跟随版本号比如： n v0.10.26
n 0.10.26
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/444d62b74099e6370406f00c1221ff56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a98b655ad84801d8b5d5d81d53f6695/" rel="bookmark">
			SQLServer数据库、附加数据库时出错。有关详细信息，请单击“消息”列中的超链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SQL Server 数据库中附加数据库时出错： 这是由于权限的问题，找到数据库所在文件或文件件： 我的数据库文件放到了 “新建文件夹（2）” 中了，所以，我设置下这个文件夹的权限： 1、点击右键，选中属性 **2、点击安全 → 编辑 → 添加 → 高级 → 立即查找 → ** **3、选中 Everyone 点击 确定 → 确定 → ** **4、勾选上 完全控制 点击 应用 点击 确定 → 确定 ** OK啦！ 再去数据库 附加一下吧 ！ 推荐一个 宝宝启蒙、动物认知、动物叫声 的小程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3719232472d00a236bba9c218a7053/" rel="bookmark">
			golang string、int、int64 float 互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#string到int int,err := strconv.Atoi(string) #string到int64 int64, err := strconv.ParseInt(string, 10, 64) //第二个参数为基数（2~36）， //第三个参数位大小表示期望转换的结果类型，其值可以为0, 8, 16, 32和64， //分别对应 int, int8, int16, int32和int64 #int到string string := strconv.Itoa(int) //等价于 string := strconv.FormatInt(int64(int),10) #int64到string string := strconv.FormatInt(int64,10) //第二个参数为基数，可选2~36 //对于无符号整形，可以使用FormatUint(i uint64, base int) #float到string string := strconv.FormatFloat(float32,'E',-1,32) string := strconv.FormatFloat(float64,'E',-1,64) // 'b' (-ddddp±ddd，二进制指数) // 'e' (-d.dddde±dd，十进制指数) // 'E' (-d.ddddE±dd，十进制指数) // 'f' (-ddd.dddd，没有指数) // 'g' ('e':大指数，'f':其它情况) // 'G' ('E':大指数，'f':其它情况) #string到float64 float,err := strconv.ParseFloat(string,64) #string到float32 float,err := strconv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b3719232472d00a236bba9c218a7053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f39be024a8c85d27bf760f89337f009/" rel="bookmark">
			Content type ‘text/plain；charset=UTF-8‘ not supported
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：我是使用postman发送请求时，报的这个异常 2016-11-02 10:35:50,142 ERROR [http-bio-8080-exec-1] [com.confucian.framework.web.exception.ExceptionControllerAdvice:143] - &lt;rqid:188-75-5c5c56df-1cb8-4afa-a74c-698f146d0fdb,exception:org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'text/plain;charset=UTF-8' not supported 这是我要访问的请求所对应的controller @RequestMapping(path = "/register", method = RequestMethod.POST) public Object register(@RequestBody StudentRegisterBean registerInfo, HttpServletRequest request, HttpServletResponse response) { 这是我的postman的界面，原因是因为数据传输格式选择错误。 推荐一个 宝宝启蒙、动物认知、动物叫声 的小程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbba2a6c5b5e569c2687a5884ad2e760/" rel="bookmark">
			Curl 使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： Curl 是一个利用URL语法在命令行下工作的文件传输工具。它支持文件上传和下载，是综合传输工具。curl就是客户端（client）的URL工具的意思。
发起 GET 请求： 不带有任何参数时，curl 就是发出 GET 请求。
curl https://www.baidu.com 重定向跟踪 (-L) 当请求一个 URL 返回 301 之类的重定向响应时，可以使用 -L 参数来自动跟踪重定向。curl 默认不跟随重定向。
curl -L https://www.baidu.com 保存响应体到文件 (-o/O) 使用 -o 参数指定文件名，可以将响应结果储存到文件中
curl -o 1.html https://www.baidu.com 还可以使用 -O 参数直接用服务器上的文件名保存在本地
curl -O http://www.test.com/1.txt 获取 HTTP 响应头 (-i) 使用 -i 参数可以查看请求 URL 的响应头与响应体一起返回打印出来。。
curl -i https://www.baidu.com 如果只想获取响应头，可以使用 -I 参数。
curl -I https://www.baidu.com 构造 GET 查询参数 (-G) 在发起 GET 请求时，可能我们需要在 URL 后面跟上查询参数，如 https://www.google.com/search?q=test 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbba2a6c5b5e569c2687a5884ad2e760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56cdcaf09c642e009841bacaf2168843/" rel="bookmark">
			(最新)ubuntu搭建PX4无人机仿真环境(1) —— 概念介绍及环境建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言 概念介绍环境建议参考 前言 搭建PX4仿真环境一个有挑战性的过程，如果没有一个有经验的人来带的话会走很多弯路。我在搭建PX4仿真环境的时候，不知道Linux、ROS、git，语言也只会一个C语言，没有任何无人机基础，纯小白一个，靠着自学与网上的各种教程，花了一两个月才搭好基本的仿真环境框架。我会将搭建步骤一步步演示，强烈建议大家看看 环境建议 这一节，概念的话了解就行。
搭建仿真环境系列教程👇
ubuntu搭建PX4无人机仿真环境(1) —— 概念介绍
ubuntu搭建PX4无人机仿真环境(2) —— MAVROS安装
ubuntu搭建PX4无人机仿真环境(3) —— ubuntu安装QGC地面站
ubuntu搭建PX4无人机仿真环境(4) —— 仿真环境搭建
ubuntu安装ROS melodic(最新、超详细图文教程)
概念介绍 在搭建环境之前还是希望大家能看看这些概念，避免大家概念模糊。
PX4 所谓无人机的飞控，就是无人机的飞行控制系统。无人机飞控能够稳定无人机飞行姿态，并能控制无人机自主或半自主飞行，是无人机的大脑。而PX4是自动驾驶仪软件（或称为固件），基于Nuttx实时操作系统开发的，可以驱动无人机或无人车。它是Pixhawk 的原生固件，虽然起步比APM晚。它与地面站（地面控制站）在一起组成一个完全独立的自动驾驶系统。它是一个在GitHub上开源的一个项目，项目地址 ,还有官方参考文档 (这里建议可以多看看)。
QGC QGC地面站是Dronecode地面控制站称为QGC地面站 。它是基于 Qt 开发的。如果使用的是 PX4固件 ，建议使用QGC地面站 。使用者可以用QGroundControl将PX4固件加载（烧写）到飞行器控制硬件上，可以设置飞行器，更改不同参数，获取实时飞行信息以及创建和执行完全自主的任务，如航点规划。QGroundControl是跨平台的，可以在Windows，Android，MacOS或Linux上运行。它是一个在GitHub上开源的一个项目，项目地址 ,还有官方参考文档
MAVSDK MAVSDK 基于Mavlink协议的sdk包，可以使机载电脑与MAVLink协议兼容的无人机通信，从而控制无人机。多用于PX4固件 ，它最初是使用C++写的，经过发展，现在已经支持Python、Java、C#、Rust、Swift、Go、JavaScript，适合多平台开发。它是一个在GitHub上开源的一个项目，mavlink/MAVSDK: API and library for MAVLink compatible systems ，还有官方参考 Introduction · MAVSDK Guide
APM Ardupilot Mega或称为APM 也是一款自驾仪软件，是早在2007年由DIY无人机社区(DIY Drones)推出的飞控产品。APM刚开始是基于Arduino的开源平台，后来软件代码不断状大，原来的硬件不能胜任最新代码，再后来开发者就把Ardupilot代码转移到了Pixhawk平台上，基于Nuttx实时操作系统，兼容了Pixhawh硬件平台。目前主要是支持的5种设备的目录包括ArduPlane(固定翼)、ArduCopter(直升机/多旋翼)、APMrover2、AntennaTracker、ArduSub。它是一个在GitHub上开源的一个项目，项目地址 ,还有官方参考文档 。
MP Misson Planner简称MP ，是Windows 平台运行的一款APM/PIX的专属地面站，基于 C# 开发的，对于Windows 兼容更好，其他平台也可以运行，但兼容性不是很好。如果使用 APM固件 ，建议使用MP地面站 。它的基本功能与 QGC 是一样的，虽然功能强大多样，但是太冗余。它是一个在GitHub上开源的一个项目，项目地址 ,还有官方参考文档
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56cdcaf09c642e009841bacaf2168843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e654bf2a4c66732ad6ed5b03b90f3829/" rel="bookmark">
			python简单小游戏代码10行,python超简单小游戏代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小编为大家解答python编写的入门简单小游戏代码大全的问题。很多人还不知道python编写的入门简单小游戏代码，现在让我们一起来看看吧！
1、小恐龙 玩法：上下控制起跳躲避
import cfg import sys import random import pygame from modules import * '''main''' def main(highest_score): # 游戏初始化 pygame.init() screen = pygame.display.set_mode(cfg.SCREENSIZE) pygame.display.set_caption('九歌') # 导入所有声音文件 sounds = {} for key, value in cfg.AUDIO_PATHS.items(): sounds[key] = pygame.mixer.Sound(value) # 游戏开始界面 GameStartInterface(screen, sounds, cfg) # 定义一些游戏中必要的元素和变量 score = 0 score_board = Scoreboard(cfg.IMAGE_PATHS['numbers'], position=(534, 15), bg_color=cfg.BACKGROUND_COLOR) highest_score = highest_score highest_score_board = Scoreboard(cfg.IMAGE_PATHS['numbers'], position=(435, 15), bg_color=cfg.BACKGROUND_COLOR, is_highest=True) dino = Dinosaur(cfg.IMAGE_PATHS['dino']) ground = Ground(cfg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e654bf2a4c66732ad6ed5b03b90f3829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5df3b55be91723b23aa453572de15d/" rel="bookmark">
			带你玩转PX4无人机仿真(1) —— 运行官方案例（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 创建功能包二. 编译运行修改官方代码参考 前言： 本次教程是官方提供的 MAVROS Offboard (板外) 控制示例，使用之前请搭建好 PX4 仿真环境
注：搭建仿真环境可以看下面教程👇
ubuntu搭建PX4无人机仿真环境(1) —— 概念介绍
ubuntu搭建PX4无人机仿真环境(2) —— MAVROS安装
ubuntu搭建PX4无人机仿真环境(3) —— ubuntu安装QGC地面站
ubuntu搭建PX4无人机仿真环境(4) —— 仿真环境搭建
ubuntu安装ROS melodic(最新、超详细图文教程)
一. 创建功能包 没有创建工作空间，可以执行下列代码，如果创建了可以跳过（如果是跟着我之前的教程，那就不用执行这一步）
注： catkin_make 与 catkin build 是编译功能包的两种方式，catkin_make 用的多一点，有兴趣的话可以看看它们的区别 👉 Migrating from catkin_make — catkin_tools mkdir -p ~/catkin_ws/src cd catkin_ws/src &amp;&amp; catkin_init_workspace # 使用catkin build话，则为cd catkin_ws &amp;&amp; catkin init cd .. &amp;&amp; catkin_make# 使用catkin build话，则为 catkin build # 再将 source ~/catkin_ws/devel/setup.bash 提案加到 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f5df3b55be91723b23aa453572de15d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eabea64cd9fabb36baa2500d56a1e8c/" rel="bookmark">
			Linux，看这篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 一、为什么要学linux二、目录介绍三、vi / vim编辑器四、网络配置4.1、修改 IP 地址4.2、配置主机名4.2.1、修改主机名称4.2.2、修改 hosts 映射文件 五、系统配置5.1、service 服务管理5.2、systemctl5.3、防火墙5.4、关机重启命令5.5、查看系统内核与版本 六、常用命令6.1、文件目录类1）、pwd 显示当前工作目录的绝对路径2）、ls 列出目录的内容3）、cd 切换目录4）、mkdir 创建一个新的目录 、 rmdir 删除一个空的目录5）、touch 创建空文件6）、cp 复制文件或目录7）、rm 删除文件或目录8）、mv 移动文件与目录或重命名9）、cat 查看文件内容10）、more 文件内容分屏查看器11）、less 分屏显示文件内容12）、echo输出内容到控制台14）、tail 输出文件尾部内容15）、&gt; 输出重定向 和 &gt;&gt; 追加16）、ln 软链接17）、history 查看已经执行过历史命令18)、时间日期类 6.2、用户管理命令1）、useradd 添加新用户2）、passwd 设置用户密码3）、id 查看用户是否存在4）、cat /etc/passwd 查看创建了哪些用户5）、su 切换用户6）、userdel 删除用户7）、sudo 设置普通用户具有 root 权限8）、usermod 修改用户9）、groupadd 新增组10）、groupdel 删除组11）、groupmod 修改组12）、cat /etc/group 查看创建了哪些组 6.3、文件权限类1）、文件属性2）、chmod 改变权限3）、chown 改变所有者4）、chgrp 改变所属组 6.4、搜索查找类1）、find 查找文件或者目录2）、locate 快速定位文件路径3）、grep 过滤查找及 | 管道符 6.5、压缩和解压类1）、gzip/gunzip 压缩2）、zip/unzip 压缩3）、tar 打包 6.6、磁盘查看和分区类1）、du 查看文件和目录占用的磁盘空间2）、df 查看磁盘空间使用情况3）、lsblk 查看设备挂载情况4）、mount/umount 挂载/卸载5）、fdisk分区 6.7、进程管理类1）、ps 查看当前系统进程状态2）、kill 终止进程3）、pstree 查看进程树4）、top 实时监控系统进程状态5）、netstat显示网络状态和端口占用信息6）、crontab 定时任务设置 七、软件包管理7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eabea64cd9fabb36baa2500d56a1e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae7daf66b6f722702cf6485a543194d5/" rel="bookmark">
			如何将一个页面的数据以数组的形式传递到另外一个页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：列表渲染的情况下：通过json.stringify将数组转化成对象
​ &lt;template&gt; &lt;view&gt; &lt;view v-for="(item,index) in box" :key="index" class="box" @click="viper(index)"&gt; &lt;view class="box1"&gt;{{item.name}}&lt;/view&gt; &lt;view class="box1"&gt;{{item.sex}}&lt;/view&gt; &lt;view class="box1"&gt;{{item.num}}&lt;/view&gt; &lt;view class="box1"&gt;{{item.score}}&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default{ data(){ return{ box:[ { name:'1', sex:'男', num:'12', score:'90' }, { name:'2', sex:'男', num:'12', score:'91' }, { name:'3', sex:'女', num:'12', score:'92' }, { name:'4', sex:'男', num:'15', score:'99' }, ] } }, methods:{ viper(index){ uni.navigateTo({ url:'/pages/将页面的数据传输到另外一个页面/B页面?box=' + JSON.stringify(this.box[index]) }) console.log(this.box[index]) } } } &lt;/script&gt; &lt;style&gt; .box{ width: 100%; height: 350rpx; background-color: aqua; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae7daf66b6f722702cf6485a543194d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7380519d6d9954e7b9e4b37e0c533beb/" rel="bookmark">
			基于kafka的日志收集分析平台搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、整体架构图
二、环境准备
1、准备好8台虚拟机(centos7 2核1G)用来搭建nginx和kafka集群
2、配置静态ip地址
3、修改主机名
4、每一台机器上都写好域名解析
5、安装基本软件
6、安装时间同步服务
7、关闭防火墙和selinux
三、搭建nginx集群
1、安装
2、启动并设置开机自启
3、编辑配置文件
4、语法检测并重新加载nginx
四、nginx反向代理配置
1、编辑配置文件
2、语法检测并重新加载nginx
五、搭建keepalived双VIP高可用
1、安装
2、编辑配置文件
3、开启keepalived服务
4、查看效果
六、搭建kafka和zookeeper集群
1、安装
2、解包
3、配置kafka
4、配置zookeeper
5、启动zookeeper
6、启动kafka
七、部署filebeat集群
1、安装
2、配置
3、启动filebeat
4、测试
八、访问nginx集群生成日志
1、添加域名解析
2、访问www.test.com
3、创建消费者获取日志
九、数据入库
1、建表
2、编写python脚本
3、运行效果
4、查看数据库
一、整体架构图 主机名IP描述keepalived01192.168.226.13反向代理机1，使用keepalived做高可用keepalived02192.168.226.14反向代理机2，使用keepalived做高可用nginx01192.168.226.101运行nginx和filebeat服务nginx02192.168.226.102运行nginx和filebeat服务nginx03192.168.226.103运行nginx和filebeat服务nginx-kafka01192.168.226.149运行kafka和zookeeper服务nginx-kafka02192.168.226.150运行kafka和zookeeper服务nginx-kafka03192.168.226.151运行kafka和zookeeper服务 二、环境准备 1、准备好8台虚拟机(centos7 2核1G)用来搭建nginx和kafka集群 每台机器都配置好相应的主机名和ip地址，kafka集群还要配置好域名解析，这里以nginx-kafka01为例
2、配置静态ip地址 [root@nginx-kafka01 ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static IPADDR=192.168.226.149 #静态ip NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.226.2 #网关 DNS1=8.8.8.8 #DNS服务器 jDEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=0bb9f3ba-4245-4281-9844-e9c8e7be74af DEVICE=ens33 ONBOOT=yes 3、修改主机名 [root@nginx-kafka01 ~]# vim /etc/hostname #修改主机名 nginx-kafka01 4、每一台机器上都写好域名解析 [root@nginx-kafka01 ~]# vim /etc/hosts #配置域名解析 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7380519d6d9954e7b9e4b37e0c533beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ec60adf52235a11b65e048227a92ac/" rel="bookmark">
			Error: MiniProgramError{“errMsg“:“navigateTo:fail can not navigateTo an unregistered page
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这种情况一般就是忘记在pages.json里面忘记配置页面信息了，我这里是忘记配置pageA/audit/audit了。
解决方法： 就可以了，今天看了半天原来是这个问题笑死我了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf42bf25cd85daef6e17a68e5d9b6cd2/" rel="bookmark">
			Future异步回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、理解 相当于之前学习的Ajax
常用他的实现类CompletableFuture
二、一般是用这个异步回调，会有两种业务需求 1、无返回值的异步回调
使用了runAsync方法，里面传一个Runnable接口
public class Test01 { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建异步回调的类对象 //无返回值的异步回调任务，里面传递一个Runnable接口，这里使用Lambda表达式 CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;{ try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "--&gt;runAsync"); }); System.out.println("1111111"); completableFuture.get(); //获取异步阻塞执行的结果 } } 2、有返回值的异步回调
调用CompletableFuture.supplyAsync方法，里面传递一个供给型接口，如果想返回调用成功的值或者调用失败的返回值，需要用到whenComplete方法
public class Test01 { public static void main(String[] args) throws ExecutionException, InterruptedException { //调用有返回值的异步回调 future02 future02 = new future02(); future02.asyn(); } } //测试有返回值的异步回调 class future02{ public void asyn() throws ExecutionException, InterruptedException { CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf42bf25cd85daef6e17a68e5d9b6cd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a20009bd7ef35bd777012167799c72/" rel="bookmark">
			不同版本的Dev Tools基本使用语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同版本的Dev Tools基本使用语法 ES7版本之前 1、创建index // 创建index PUT /zhang // 验证index是否存在 HEAD zhang 2、删除index // 删除index DELETE /zhang // 删除所有index（将会导致kibana无法使用。需要重启kibana，慎用。） DELETE /* 3、查询所有索引 // 查询所有的索引 GET /_cat/indices?v 4、创建Type // 创建Type put /zhang { "settings": { "number_of_shards": 3, "number_of_replicas": 1 }, "mappings": { // nginxlog为一个Type, 可以有多个Type "nginxlog": { "properties": { "prov": { "type": "keyword" }, "isp": { "type": "keyword" }, "dt": { "type": "date" }, "bd": { "type": "float" } } } } } 5、对Type的操作 // 查询type的mapping GET /zhang/_mapping/nginxlog // 创建document, 指定了_id为1, 可以根据_id查询document, 如若未指定则会自动生成_id POST zhang/nginxlog/1 { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a20009bd7ef35bd777012167799c72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b12b98fe524e3a72833a3c26100509/" rel="bookmark">
			AP6256 WIFI蓝牙模块 调试使用测试记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、wifi的基础知识储备 wifi通常情况下可以处在sta和ap模式下：
sta模式：作为终端去连接其他WiFi网络
ap模式：作为接入的热点中心，被其他终端连接
二、实操：设备在sta模式下，怎么通过命令连入别的wifi网络？ 要在设备上以**STA（Station）模式**连接到其他WiFi网络，您可以使用命令行工具，通常使用**wpa_supplicant**和**wpa_cli**工具来配置和管理WiFi连接。以下是一般步骤：
1. **检查WiFi适配器**：首先，确保您的设备上有可用的WiFi适配器，并且已正确安装WiFi驱动程序。
2. **启动wpa_supplicant**：运行以下命令来启动wpa_supplicant，其中 `interface_name` 是您的WiFi适配器的名称：
```shell
sudo wpa_supplicant -B -i interface_name -c /etc/wpa_supplicant.conf
```
`-B` 标志表示在后台运行，`-i` 指定WiFi接口，`-c` 指定配置文件的路径。请确保 `/etc/wpa_supplicant.conf` 文件包含要连接的WiFi网络的配置信息。示例配置：
```plaintext
network={
ssid="Your_SSID"
psk="Your_Password"
}
```
替换 `"Your_SSID"` 和 `"Your_Password"` 为目标WiFi网络的SSID和密码。
3. **使用wpa_cli连接**：运行以下命令使用wpa_cli连接到WiFi网络：
```shell
sudo wpa_cli -i interface_name
```
这将进入wpa_cli的交互模式。
4. 在wpa_cli中，输入以下命令连接到WiFi网络（请替换 `&lt;Your_SSID&gt;` 和 `&lt;Your_Password&gt;` 为目标网络的SSID和密码）：
```shell
scan
add_network
set_network 0 ssid "&lt;Your_SSID&gt;"
set_network 0 psk "&lt;Your_Password&gt;"
enable_network 0
```
这将扫描可用的WiFi网络，为目标网络创建一个新网络配置，并启用它。确保使用正确的SSID和密码。
5. 最后，运行以下命令来等待连接到网络：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88b12b98fe524e3a72833a3c26100509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acaddcea79916643622c03447ed58e29/" rel="bookmark">
			Java手写数组队列和链表队列并使用java里面现成的队列方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java队列实现与常用使用方法介绍 说明使用数组手动实现队列功能使用单向链表手动实现队列功能Java中ArrayBlockingQueue和ArrayQueue和LinkedBlockingQueue使用ArrayQueue使用方法如下:ArrayBlockingQueue常用使用方法如下:LinkedBlockingQueue常用使用方法如下:ArrayBlockingQueue和LinkedBlockingQueue区别 说明 这里记录下使用数组和链表手动实现队列功能，并使用java里面现成的队列方法。
使用数组手动实现队列功能 package com.example.deesign_patterns.test; //java使用数组简单实现队列 public class ArrayQueue { private int[] queue; // 内部数组 private int front; // 队列头部指针 private int rear; // 队列尾部指针 private int size; // 队列当前元素个数 private int capacity; // 队列容量 //构造方法,初始化的时候必须要传队列容量值 public ArrayQueue(int capacity) { this.capacity = capacity; queue = new int[capacity]; front = 0; rear = -1; size = 0; } //判断是否是空队列 public boolean isEmpty() { return size == 0; } //判断队列是否已满 public boolean isFull() { return size == capacity; } //队列元素个数 public int size() { return size; } //元素入队列 public void add(int value) { if (isFull()) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acaddcea79916643622c03447ed58e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1babfb79d0a467f6de9699e545dd053d/" rel="bookmark">
			@Autowired注入时出现Could not autowire. No beans of ‘xxx‘ type found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 记录一下使用@Autowired注入时出现Could not autowire. No beans of ‘xxx’ type found.无法自动连线，未找到xxx类型的bean的问题
这个问题对编译运行没有影响，只是IDEA没有找到对应的bean。
应该是没有正确使用注解，参考：autoWired注解报错 Could not autowire. No beans of ‘xxxService‘ type found.
不同的包下使用不同的注解注入 @Repository：代表dao层 @Component：惯用实体类 @Service ： 用于service层 @Controller ： 用于Controller 上面的注解作用都一样，只是在不同的包下尽量使用对应的注解
新手上路，如有错误欢迎指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61427ee935e3dbce45972e4590c95630/" rel="bookmark">
			Android AAPT: error: resource color 异常原因处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常体现：
Android resource linking failed ERROR:E:\software\Developer\APP\GaoDeTest2\app\src\main\res\values\themes.xml:3:5-9:13: AAPT: error: resource color/purple_500 (aka com.example.gaodetest2:color/purple_500) not found. ERROR:E:\software\Developer\APP\GaoDeTest2\app\src\main\res\values\themes.xml:3:5-9:13: AAPT: error: resource color/purple_700 (aka com.example.gaodetest2:color/purple_700) not found. ERROR:E:\software\Developer\APP\GaoDeTest2\app\src\main\res\values\themes.xml:3:5-9:13: AAPT: error: resource color/teal_200 (aka com.example.gaodetest2:color/teal_200) not found. ERROR:E:\software\Developer\APP\GaoDeTest2\app\src\main\res\values-night\themes.xml:3:5-9:13: AAPT: error: resource color/purple_200 (aka com.example.gaodetest2:color/purple_200) not found. ERROR:E:\software\Developer\APP\GaoDeTest2\app\src\main\res\values-night\themes.xml:3:5-9:13: AAPT: error: resource color/purple_700 (aka com.example.gaodetest2:color/purple_700) not found. ERROR:E:\software\Developer\APP\GaoDeTest2\app\src\main\res\values-night\themes.xml:3:5-9:13: AAPT: error: resource color/teal_200 (aka com.example.gaodetest2:color/teal_200) not found. 该异常是删除了项目创建时系统引用的颜色资源，导致的编译失败异常；
异常解决：
根据提示在color.xml里加入报错的颜色资源
&lt;color name="purple_200"&gt;#FFBB86FC&lt;/color&gt; &lt;color name="purple_500"&gt;#FF6200EE&lt;/color&gt; &lt;color name="purple_700"&gt;#FF3700B3&lt;/color&gt; &lt;color name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61427ee935e3dbce45972e4590c95630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c4e9dbe6d93691375bfff252308f7e/" rel="bookmark">
			定时任务管理器（xxl-job）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 xxl-job简介安装使用拉取xxl-job项目导入数据库表启动 admin 服务端Spring Boot 整合 xxl-job修改执行器新建定时任务 xxl-job简介 XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。开箱即用。
admin ：理解为 server服务端 ，负责提供xxljob相关功能
demo： 理解为 client客户端，你自己想用xxljob的服务
HTML页面， 可视化操作，任务调度。
安装使用 拉取xxl-job项目 pg版本：https://gitee.com/V88888_admin/xxl-job-pg/tree/master/
mysql版本（官方）：https://gitee.com/xuxueli0323/xxl-job
IDEA上打开项目。
导入数据库表 找到pgsql文件，去数据库执行
启动 admin 服务端 先修改 application.properties 配置文件
改完后启动 admin：
然后去HTML管理界面看下，http://localhost:8961/xxl-job-admin：
默认账号 admin
默认密码 123456
Spring Boot 整合 xxl-job 接入xxljob，开始使用xxljob实现定时任务
加入依赖：
&lt;!-- xxl-job-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;/dependency&gt; 修改配置文件
加入注解
编写配置
package com.xxl.job.executor.core.config; import com.xxl.job.core.executor.impl.XxlJobSpringExecutor; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class XxlJobConfig { private Logger logger = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c4e9dbe6d93691375bfff252308f7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87b211c1342c98e2102352ad5e1d873/" rel="bookmark">
			井盖异动传感器-井盖在线监测设备-旭华智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们的日常生活中，井盖可能看似微不足道，但实际上它们承载着许多关键设施，如供排水、通信、电力、燃气等。然而，传统的井盖管理方式存在诸多隐患，如无法及时发现损坏、难以定位丢失的井盖等。这些问题不仅影响城市形象，还可能造成安全隐患。幸运的是，随着物联网技术的发展，我们有了新的解决方案——井盖异动传感器
旭华智能井盖异动传感器实现“一盖一码”，记录着井盖一生的信息，并且采用NB-IoT网络通讯，相比4G来说，穿透力更好，传输距离更长，在井下环境中也能够对井盖状态进行实时监控。
当井盖出现异常，例如：开盖、越限、浸水，倾斜时，终端会在30s内发出警报，并通过手机APP通知管理人员，管理人员会通过平台分析研判，对比监测值与设定值分析报警级别，并根据不同的报警类型，及时联动相应的责任人，从而达到精准高效的处理效果。
此外，这款井盖异动传感器采用IP68防护，并且安装8500mAh大容量电池，大大增加了设备的使用寿命。如遇检修、安装等状况，可以开启撤防，以防多报误报，引起资源浪费。
井盖异动传感器已经在国内一些城市得到了成功应用。据反馈，使用该传感器的城市在井盖管理方面取得了显著成效。不仅丢失的井盖能够迅速找回，而且由于能够及时发现潜在问题，安全事故也大幅减少。
总的来说，井盖异动传感器作为一种新型的物联网产品，为我们的城市管理带来了诸多便利。它就像一位默默无闻的守护者，守护着我们的地下宝藏。在未来，随着物联网技术的不断发展，我们有理由相信，井盖异动传感器将会在全球范围内发挥更大的作用，为我们的城市发展贡献更多力量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756545023d10aa386d08ba92c2a4864b/" rel="bookmark">
			SpringBoot实现发送邮件功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时注册或者登录一个网站时，可能收到过邮件用来发送验证码等，邮件在项目中经常会被用到，比如邮件发送通知，比如通过邮件注册，认证，找回密码，系统报警通知，报表信息等。
发送邮件用到了Spring Email的技术，我们这里使用的是SMTP。
1.邮箱打开SMTP服务 找一个邮箱用来给其他邮箱发送文件，要用SMTP服务发送邮件，所以邮箱要提前开启这个功能。
以163邮箱为例：（其他邮箱也是相同的操作）
开启SMTP服务后，会出现弹框，将授权密码记录下来，注意：只出现一次
还可以看到服务器地址 2.SpringBoot集成Email 将下面的maven配置拷贝下来，集成到SpringBoot中。 &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 3.邮箱参数配置 首先进行配置文件，配置文件的目的是告诉Spring需要用哪个邮箱来发送邮件
写到SpringBoot的yaml配置文件里面
（登录授权密码不是你邮箱的密码，是你邮箱开启SMTP服务后显示的那个授权密码）
spring: mail: #邮箱域名、端口、邮箱账号、登录授权密码、启用smtps安全协议、采用ssl安全链接 host: smtp.163.com port: 465 username: ************@163.com password: ************ protocol: smtps properties: mail.smtp.ssl.enable: true 4.发送邮件工具类 package com.kyw.util; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.mail.javamail.JavaMailSender; import org.springframework.mail.javamail.MimeMessageHelper; import org.springframework.stereotype.Component; import javax.mail.MessagingException; import javax.mail.internet.MimeMessage; @Component public class MailClient { private static final Logger logger = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756545023d10aa386d08ba92c2a4864b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21499e211f412d18d5ca1b88ce0bd10f/" rel="bookmark">
			【Github】git本地仓库建立与远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、git简介二、git下载2.1下载地址 三、git安装3.1安装3.2 配置3.3 config设置（增删改查） 四.github与git连接——本地Git仓库4.1 建本地的版本库4.2 源代码放入本地仓库4.3提交仓库 五、github与git的连接——远程连接5.1 创建SSH Key5.2 github填写SSH Key5.3验证5.4 github建仓库5.5 关联远程仓库 六、总结步骤与常见错误6.1 步骤6.2 常见错误（不断更新中） 前言 一、git简介 Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。
二、git下载 2.1下载地址 Git客户端官网下载链接：https://git-scm.com/downloads
选择适合自己本机的版本下载。
三、git安装 3.1安装 双击“Git-2.17.0-64-bit.exe”，进入安装导向界面，点击Next&gt;
选择安装路径，next&gt;
next&gt;
开始菜单快捷方式目录，默认配置即可，点击Next&gt;
选择默认的编辑器：Vim，点击Next&gt;
选择命令行工具，一般选择:User Git from Git Bash only，点击Next&gt;
接下来一路next&gt;，直至install，安装完成。
3.2 配置 计算机右键-属性：
为方便后续应用和验证是否安装成功，配置环境变量配置path(本步骤可不做)
cmd输入“git --version”，出现版本信息即安装成功。
3.3 config设置（增删改查） 设置username 和 email
$ git config --global user.name "name"//自定义用户名 $ git config --global user.email "youxiang@qq.com"//用户邮箱 修改
git config --global configname configvalue 查询
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21499e211f412d18d5ca1b88ce0bd10f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1dac422d26a494b6661120ae6b2644/" rel="bookmark">
			CentOS7 离线安装mysql8数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：下载离线安装包 下载地址：https://dev.mysql.com/downloads/
第二步：上传下载包到服务器 上传文件mysql-8.0.23-1.el7.x86_64.rpm-bundle.tar到服务器上。
第三步：解压文件包 切换到上传文件目录下运行如下命令：
tar -vxf mysql-8.0.23-1.el7.x86_64.rpm-bundle.tar
[root@gelong-vm1 rpms]# tar xvf mysql-8.0.23-1.el7.x86_64.rpm-bundle.tar mysql-community-client-8.0.23-1.el7.x86_64.rpm mysql-community-client-plugins-8.0.23-1.el7.x86_64.rpm mysql-community-common-8.0.23-1.el7.x86_64.rpm mysql-community-devel-8.0.23-1.el7.x86_64.rpm mysql-community-embedded-compat-8.0.23-1.el7.x86_64.rpm mysql-community-libs-8.0.23-1.el7.x86_64.rpm mysql-community-libs-compat-8.0.23-1.el7.x86_64.rpm mysql-community-server-8.0.23-1.el7.x86_64.rpm mysql-community-test-8.0.23-1.el7.x86_64.rpm 第四步：卸载系统自带的数据库 1.检查系统自带的 MariaDB 检查系统是否自带MariaDB,命令如下：
rpm -qa | grep mariadb
如果系统自带MariaDB,删除掉，删除命令如下：
rpm -e --nodeps mariadb-libs-5.5.44-2.el7.centos.x86_64
2.检查系统自带的mysql数据库安装包 检查系统是否自带Mysql数据库，名利如下：
rpm -qa | grep mysql
如果系统自带mysql数据库，删除掉，删除命令如下：
rpm -e --nodeps mysql-libs-5.1.73-8.el6_8.x86_64
第五步：按照顺序安装mysql数据库 按照如下顺序安装：
1. rpm -ivh mysql-community-common-8.0.25-1.el7.x86_64.rpm 2. rpm -ivh mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm 3. rpm -ivh mysql-community-libs-8.0.25-1.el7.x86_64.rpm 4. rpm -ivh mysql-community-client-8.0.25-1.el7.x86_64.rpm 5. rpm -ivh mysql-community-server-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a1dac422d26a494b6661120ae6b2644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815f70d3ba49c3a778a7900c032b01c1/" rel="bookmark">
			神仙级python入门教程(非常详细)，从0到精通，从看这篇开始！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 毫无疑问，Python 是当下最火的编程语言之一。对于许多未曾涉足计算机编程的领域「小白」来说，深入地掌握 Python 看似是一件十分困难的事。其实，只要掌握了科学的学习方法并制定了合理的学习计划，Python 从 入门到精通只需要一个月就够了！
今天给大家分享一份《Python学习笔记》，这份文档包含35个知识点，如：类型、字符串、列表、元组、语句语法、循环、模块等等，笔记将一个知识点的内容都统筹在一个章节里面，因此提炼性大大提高。
这份笔记的目标是为了给出一份比较精炼，但是又要浅显易懂的Python教程。对于Python新手，这份文档难度不大。但是如果您对Python有一定的熟练程度，您会发现这份文档行云流水，一气呵成，阅读起来就没有停顿感。
完整版领取见文末
完整版领取见文末
文档目录
部门内容展示 全文档共138页，文章有限制，不再一一展示了，完整版领取看文末
本套视频一共400集，本套视频共分3季：
第一季 【基础篇】Python基础 （115集）
第二季 【提高篇】Python深入和扩展（100集）
第三季 【扩展篇】网络编程、多线程、扩展库（85集）
第四季 【高手篇】算法、Python源码、函数式编程、手工实现神经网络（100集）
第1阶段python开发基础和核心特性
1.变量及运算符2.分支及循环3.循环及字符串4.列表及嵌套列表5.字典及项目练习6.函数的使用7.递归及文件处理8.文件9.面向对象10.设计模式及异常处理11.异常及模块的使用12.坦克大战13.核心编程14.高级特性15.内存管理
第2阶段数据库和linux基础
1.并发编程2.网络通信3.MySQL4.Linux5.正则表达式
第3阶段web前端开发基础
1.html基本标签2.css样式3.css浮动和定位4.js基础5.js对象和函数6.js定时器和DOM7.js事件响应8.使用jquery9.jquery动画特效10.Ajax异步网络请求
第4阶段Python Web框架阶段
1.Django-Git版本控制2.Django-博客项目3.Django-商城项目4.Django模型层5.Django入门6.Django模板层7.Django视图层8.Tornado框架
第5阶段Python 爬虫实战开发
1.Python爬虫基础2.Python爬虫Scrapy框架
想要本视频的小伙伴 看下图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fd25a30bd5f0fc4f3a7e306848d34f/" rel="bookmark">
			StringBuffer类详解(java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 🐒个人主页🏅JavaSE系列专栏📖前言：🎀StringBuffer类与String类的渊源🎀StringBuffer类与StringBuilder的区别🎀StringBuffer类常用方法： 🐒个人主页 🏅JavaSE系列专栏 📖前言： 本篇博客主要以介绍StringBuffer类的常用方法及一些底层原理
🎀StringBuffer类与String类的渊源 🍉由于String类字符串底层是一个final关键字修饰的数组，这也导致了字符串长度不可变，每次拼接时都需要创建新的字符串对象，当进行大量拼接时，既耗时，又浪费空间。于是StringBuffer应运而生！
🍉而StringBuffer是‘带有缓冲区的字符串，即可以改变数组字符串长度。从而解决了大量字符串拼接消耗大的问题。
🎀StringBuffer类与StringBuilder的区别 🍑他们都是继承了AbstractStringBuffer抽象类,里面的方法大致基本相同。
但是值得注意的是：
🍑StringBuffer中的方法被synchronized关键字修饰，支持多线程，是线程安全的，就是在多核CPU下有多个线程任务的情况下更加安全。
🍑StringBuilder建议在单线程使用。
🎀StringBuffer类常用方法： 常用方法 方法内容介绍构造方法方法内容介绍StringBuffer()📖初始化“”的字符串缓冲区，初始容量为16个字符StringBuffer( int capacity )📖自定义初始缓冲区大小StringBuffer(String str)📖初始化为“str”字符串缓冲区,初始容量为16个字符+初始化字符串长度常用方法方法内容介绍StringBuffer append(objiect b)📖拼接字符串int capacity()📖返回当前容量(eg:初始容量为16)char charAt(int index)📖返回指定索引处的字符StringBuffer delete(int start, int end)📖删除对应区间字符串字符StringBuffer deleteCharAt(int index)📖删除对应索引处字符串字符int indexOf(String str)📖返回指定子字符串第一次出现的字符串内的索引。int indexOf(String str, int fromIndex)📖与上面描述一样，但从指定的索引开始StringBuffer insert(int offset, Object obj)📖将 Object参数的字符串表示插入到此字符序列中int lastIndexOf(String str)📖返回指定子字符串最后一次出现的字符串中的索引int lastIndexOf(String str, int fromIndex)📖返回指定子字符串最后一次出现的字符串中的索引。StringBuffer replace(int start, int end, String str)📖实现对应区间字符串的替换void setCharAt(int index, char ch)📖指定索引处的字符设置为 ch 。String substring(int start)📖拷贝对应区间子串StringBuffer reverse()📖实现字符串的逆序 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/59/">«</a>
	<span class="pagination__item pagination__item--current">60/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/61/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>