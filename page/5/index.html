<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3fa72f9bcf2acdc706c548758d2eb6/" rel="bookmark">
			数据库系统概论（第五版）——第五章参考答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第5章 数据库完整性
1 ．什么是数据库的完整性？
数据库的完整性是指数据的正确性和相容性。
2 ．数据库的完整性概念与数据库的安全性概念有什么区别和联系？
数据的完整性和安全性是两个不同的概念，但是有一定的联系。前者是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出，即所谓垃圾进垃圾出所造成的无效操作和错误结果。后者是保护数据库防止恶意的破坏和非法的存取。也就是说，安全性措施的防范对象是非法用户和非法操作，完整性措施的防范对象是不合语义的数据。
3 ．什么是数据库的完整性约束条件？可分为哪几类？
完整性约束条件是指数据库中的数据应该满足的语义约束条件。一般可以分为六类：静态列级约束、静态元组约束、静态关系约束、动态列级约束、动态元组约束、动态关系约束。静态列级约束是对一个列的取值域的说明，包括以下几个方面： ( 1 ）对数据类型的约束，包括数据的类型、长度、单位、精度等； ( 2 ）对数据格式的约束； ( 3 ）对取值范围或取值集合的约束； ( 4 ）对空值的约束； ( 5 ）其他约束。静态元组约束就是规定组成一个元组的各个列之间的约束关系，静态元组约束只局限在单个元组上。静态关系约束是在一个关系的各个元组之间或者若干关系之间常常存在各种联系或约束。
常见的静态关系约束有： ( 1 ）实体完整性约束； ( 2 ）参照完整性约束； ( 3 ）函数依赖约束。
动态列级约束是修改列定义或列值时应满足的约束条件，包括下面两方面： ( 1 ）修改列定义时的约束； ( 2 ）修改列值时的约束。动态元组约束是指修改某个元组的值时需要参照其旧值，并且新旧值之间需要满足某种约束条件。动态关系约束是加在关系变化前后状态上的限制条件，例如事务一致性、原子性等约束条件。
4 . DBMS 的完整性控制机制应具有哪些功能？
DBMS 的完整性控制机制应具有三个方面的功能： ( 1 ）定义功能，即提供定义完整性约束条件的机制； ( 2 ）检查功能，即检查用户发出的操作请求是否违背了完整性约束条件；
( 3 ）违约反应：如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性。
5 . RDBMS 在实现参照完整性时需要考虑哪些方面？
RDBMs 在实现参照完整性时需要考虑以下几个方面：
( 1 ）外码是否可以接受空值。
( 2 ）删除被参照关系的元组时的考虑，这时系统可能采取的作法有三种： 1 ）级联删除（ CASCADES ) ; 2 ）受限删除（ RESTRICTED ) ; 3 ）置空值删除（ NULLIFIES ）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3fa72f9bcf2acdc706c548758d2eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f0f219c5a84ad7d6f1ed4e495d5d87/" rel="bookmark">
			如何学好编程？相见恨晚的学习方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要学好编程，就得把它当作一场激动人心的探险。这不仅是一段技术旅程，更是个性和创造力的展现。
第一步：初识神秘世界（基础知识入门）
就像每个探险故事的开始，你得先了解这个新世界的地图和语言。这里的“地图”是各种编程语言的基础知识，比如数据结构、基本语法等等。想象你在阅读一本古老的地图册，每一种编程语言都有其独特的符号和规则。这些基础就像是探险中的指南针，帮助你在接下来的旅程中不迷路。
第二步：勇闯荒野（动手实践编码）
接下来，就像探险家一样，你需要实际踏入未知的丛林。编程的学习也是一样，理论知识固然重要，但真正的技能是在实践中锻炼出来的。一开始，你可能只能完成一些简单的任务，比如写出“Hello World”这样的程序。但就像每次探险都会让你更加强大，每次编码练习都会提升你的技能。从最简单的程序开始，慢慢地，你会写出越来越复杂的代码，就像是在丛林中越走越深。
第三步：构建自己的王国（完成个人项目）
有了一定的经验后，是时候开始你自己的项目了。这就像是在荒野中建立自己的营地。通过完成个人项目，你不仅能把之前学到的知识综合运用起来，还能学到许多新的技能。在这个过程中，你会遇到各种挑战，比如如何优化代码，如何解决突如其来的bug，这些都像是探险中的意外发现和难题。每解决一个问题，就像是在你的探险地图上标记了一个新的地点。
第四步：传授秘籍（费曼学习法）
当你对某个领域有了一定的掌握后，尝试去教导别人。这就是著名的费曼学习法。就像是你成为了一名经验丰富的探险导师，指导新手探险家。通过教学，你不仅能帮助别人，自己对知识的理解也会更加深刻。这个过程就像是复习和总结你的探险经历，帮助你巩固记忆，同时也能发现自己之前没有注意到的细节。
总结：编程之旅，不仅仅是技术的提升
整个编程学习过程，就像是一场冒险旅行。你会从一个对这个神秘世界一无所知的新手，逐渐变成一个经验丰富的探险家。在这个过程中，你不仅仅学到了编程技能，更重要的是，你学会了如何面对挑战，如何解决问题，以及如何不断自我提升。
所以，不要害怕编程学习的复杂性。把它当作一次刺激的探险，享受过程中的每一个发现和挑战。记住，每一个伟大的探险家都是从第一步开始的。拿起你的键盘，就像拿起你的探险装备，开始你的编程旅程吧！
关于Python学习指南 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后给大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，人工智能、自动化办公等学习教程。带你从零基础系统性的学好Python！
👉Python所有方向的学习路线👈 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取）
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
温馨提示：篇幅有限，已打包文件夹，获取方式在：文末 👉Python70个实战练手案例&amp;源码👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉Python大厂面试资料👈 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
👉Python副业兼职路线&amp;方法👈 学好 Python 不论是就业还是做副业赚钱都不错，但要学会兼职接单还是要有一个学习规划。
👉 这份完整版的Python全套学习资料已经上传，朋友们如果需要可以扫描下方CSDN官方认证二维码或者点击链接免费领取【保证100%免费】
点击免费领取《CSDN大礼包》：Python入门到进阶资料 &amp; 实战源码 &amp; 兼职接单方法 安全链接免费领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2592a9506f4d77e0a407096e3fdfdcb3/" rel="bookmark">
			三.逻辑架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑架构 1.逻辑架构剖析1.1服务器处理客户端请求1.2Connectors1.3 第一层：连接层1.4 第二层：服务层1.5 第三层：引擎层1.6存储层1.7小结 2.SQL执行流程2.1MySQL中的SQL执行流程2.2MySQL8中SQL执行原理2.3MySQL5.7中SQL执行原理2.4SQL语法顺序2.5 Oracle中的SQL执行流程(了解) 3.数据库缓冲池(buffer pool)3.1缓冲池vs查询缓存3.2 缓冲池如何读取数据3.3 查看/设置缓冲池的大小3.4 多个Buffer Pool实例3.5 引申问题 1.逻辑架构剖析 1.1服务器处理客户端请求 首先MySQL是典型的C/S架构，即Client/Server架构，服务器端程序使用mysqld
不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：客户端进程向服务器进程发送一段文本（SQL语句）,服务器进程处理后再向客户端进程发送一段文本（处理结果）。
那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：
下面继续看下（5.7版本为例）
逻辑架构说明
1.2Connectors Connectors,指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL,我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。或者比较方便的办法是调用SDK,比如Native C API、JDBC、PHP等各语言MySQL Connector,或者通过ODBC。但通过SDK来访问MySQL,本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互。
接下来的MySQL Server结构可以分为如下的三层：
1.3 第一层：连接层 系统（客户端）访问MySQL服务器前，做的第一件事就是建立TCP连接。
经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限获取。
用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限 接着我们来思考一个问题
一个系统只会和MySQL服务器建立一个连接吗？只能有一个系统和MySQL服务器建立连接吗？
当然不是，多个系统都可以和MySQL服务器建立连接，每个系统建立的连接肯定不止一个。所以，为了解决TCP无限创建与TCP频繁创建销毁带来的资源耗尽、性能下降问题。MySQL服务器里有专门的TCP连接池限制连接数，采用长连接模式复用TCP连接，来解决上述问题。
TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。
这些内容我们都归纳到MySQL的连接管理组件中。
所以连接管理 的职责是负责认证、管理连接、获取权限信息。
1.4 第二层：服务层 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。
在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。
如果是SELECT语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。
SQL Interface: SQL接口
接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL InterfaceMySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口 Parser: 解析器
在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。 Optimizer: 查询优化器
SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划。这个执行计划表明应该使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。
它使用“选取-投影-连接”策略进行查询。例如： SELECT id,name FROM student WHERE gender = '女'; 这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2592a9506f4d77e0a407096e3fdfdcb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e289bbbd86c26511ca4329810be7358a/" rel="bookmark">
			电商API接口|爬虫案例|采集某东商品评论信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
平常大家都有网上购物的习惯，在商品下面卖的好的产品基本都会有评论，当然也不排除有刷评论的情况，因为评论会影响我们的购物决策。今天主要分享用python+re正则表达式获取京东商品评论。API接口获取京东平台商品详情SKU数据！
环境准备：
pyhon编译器版本python3.7.4
集成开发环境(IDE)pycharm版本2020.1.5
相关包的安装
pip install requests
整体框架：
分析商品评论网页
发送请求，获取响应内容
re正则表达式提取信息
pandas保存信息
运行主程序
总结
分析网页
打开京东官网，我搜的是电脑，因为是获取商品的评论，我选了评论数比较多的产品，然后可以在下方可以看到商品的评论。
接下来就是按F12，选择网页。然后点击第二页刷新网页。在往下拉的过程中可以看到有个productPageComments.......页面，点击然后看下预览。下方就可以看到评论信息comments，依次点开后查看第一个信息，网页往上拉返回可以看到网页的信息和我们要查看的信息一致。
正是我们需要找的信息，这里注意的是因为选择第二页刷新的信息，如果第一页刷新过，也有第一页的网页productPageComments,如何去辨别呢。我们可以看下参数信息，也就是查看载荷。
看下参数下面有个page：1。注意刷新的页面还是第二页。这个很容易判断是第一页。我们先滚动页面，继续找到productPageComments,然后可以看到载荷下面的参数page:0
也就是页面的规律是从0开始的，我们可以再验证一下，选择第三页刷新看载荷下方的参数，顺便看下参数是否有加密。
第三页可以发现page:2,说明页面就是从0开始的，然后看下其他的参数基本不变，没有出现加密的情况，变化的主要page。这就是我们要找的网页页面规律。
然后需要看下响应的内容，继续回到预览，可以看到一页有10条评论，初步判断格式比较像json格式，json格式的数据和python数据结构的字典比较类似，这里面涉及python的基本语法，不在这赘述。
2.发送请求，获取响应内容
首先看下标头信息
我们需要了解基本的请求网址，请求方法，状态码。
请求方法是get，后面就可以通过get方法向网页发送请求，有些网页是post。状态码是200,说明请求是ok的，如果遇到其他状态码，说明请求不成功，比如304，503。具体的状态码不在这赘述，可以网上查资料了解。不妨借助下ChatGPT的回答
ChatGPT的回答还是比较详细，给它点个赞
另外需要看的是请求标头下方的信息，比如cookie,user_agent。
cookie是用来存储用户信息，服务器会去识别用户的信息。一般请求头需要带上cookie来做浏览器的伪装。下面看下百科的解释
然后对比下ChatGPT的回答
user_agent（用户代理）是电脑的基本信息，电脑系统的版本，用的浏览器版本等，一般也是用来做浏览器的伪装。
然后看下ChatGPT对User_agent的解释
接下来看下具体的请求代码
注释：定义函数获取响应内容，带上请求头信息，用requests 和get方法发送请求，text就是响应的内容。
3.re正则表达式提取信息
re(regular expression)正则表达式的作用是精确匹配网页的信息，提取关键信息，功能也是比较强大，比如提取用来数字包括小数，整数等,还可以用来提取邮箱，身份证信息等。
下面看下ChatGPT回答
具体也可查阅其他资料详细了解其用法。
re提取信息的关键代码如下：
4.用pandas来保存信息。
相关代码如下
定义函数 参数是data,下面是字段名称，用pandas构造DataFrame保存到excel表格中。
5.运行主程序
考虑到程序的性能和评论的时效性，本次采集前50页信息，用for循环遍历每一页的url，然后批量获取每一页的信息。
相关代码如下
运行结果部分数据展示：
总共获取500条评论。
完整代码：
import requests import re import json import pandas as pd # 基本url BASE_URL = "https://club.jd.com/comment/productPageComments.action?
callback=fetchJSON_comment98&amp;productId=100035712310&amp;score=0&amp;sortType=5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e289bbbd86c26511ca4329810be7358a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10dddb463b86ee3f355cd344169e7111/" rel="bookmark">
			数字孪生系统的难点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字孪生系统的开发和实施涉及一些技术难点，这些难点需要综合应用多个领域的知识和技术来克服。以下是一些数字孪生系统开发中的技术难点，希望对大家有所帮助。北京木奇移动技术有限公司，专业的软件外包开发公司，欢迎交流合作。
1.高精度建模： 实现物理实体的高精度数字模型，包括准确的几何形状、材料属性和物理行为。这对于精确的模拟和预测是必要的。
2.实时性和高性能计算： 实现实时模拟和监测要求高性能计算能力。数字孪生系统需要在几乎实时的基础上更新模型，确保与物理实体的同步性。
3.数据集成和标准化： 将来自不同源头的数据整合到一个一致的数字模型中，可能涉及多种数据格式和标准。数据的一致性和标准化是一个挑战。
4.物理-数学模型融合： 实现物理和数学模型的融合，以保持数字模型与实际物理实体的一致性。这涉及到多学科的知识交叉。
5.数据安全和隐私： 由于数字孪生系统通常涉及大量的实时数据，确保这些数据的安全性和隐私保护是一个关键问题。
6.多模态数据处理： 处理来自不同传感器、设备和数据源的多模态数据，确保这些数据能够被整合和利用。
7.算法复杂性： 实现高效的数据分析算法，以从实时模拟中提取有价值的信息。这可能涉及到监测、预测、优化等复杂的算法。
8.用户界面设计： 设计用户友好且功能强大的用户界面，使利益相关者能够直观地理解和操作数字孪生系统。
9.可伸缩性： 能够处理不同规模和复杂性的物理实体，确保数字孪生系统在不同场景下具有可伸缩性。
10.互操作性： 保证数字孪生系统与其他系统和平台的互操作性，以便与现有的企业系统集成。
11.合规性和法规遵循： 确保数字孪生系统的开发和运行符合相关的法规和标准，特别是涉及到敏感数据和行业规定的情况。
克服这些技术难点需要跨学科的团队合作，包括工程师、数据科学家、领域专家等，以确保数字孪生系统的有效实施和应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc596ffa63bbcc9e25eaa73d2cc8d142/" rel="bookmark">
			9本考研大概率寄 想冲算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【24秋招】ENFJ的求职恋爱日记
🔥华为研发招聘🔥岗位多多！base地多多！HC多多！ 🔥岗位∶涵盖大部分程序员类岗位！【前端、
华为2012被毁意向
超听劝,修改简历学历太低感觉没救了
嵌入式好难找啊，没有面试机会
两个月速成[赞]
腾讯 IEG 光子工作室群后台开发 OC
还有救吗，哪个金融实习会要我
还有救吗，哪个金融实习会要我
许愿快手和WXG hr面
写代码到底怎么分包结构呢？
架构师们都选择这种！
华为荣耀
华为上海青浦，和荣耀南研所怎么选，薪资华子略高，荣耀很有诚意，家在南京，9本硕，希望来点建议。引流：华为 荣耀 华子 上海青浦，荣耀解约 荣耀毁约 荣耀解
24. 某总线有 104 根信号线，其中
24. 某总线有 104 根信号线，其中数据总线（DB）32 根，若总线工作频率为 33MHz，则其理论最大传输率为 （24） 。A.33 MB/sB.64MB
9本考研大概率寄 想冲算法
本身考研的目的也是想冲算法搞AI有竞赛无实习目前面了几家算法&amp;大模型（美团、理想、字节） 感觉不是很理想之后考研寄的话可能会考个雅思25spring/f
龙年大吉，刷到交好运
#龙年大吉# 整体感受：被秋招上强度了，明白了自己和同龄人里面大佬的差距。同时看到了以前一个班的同学们不同的成长路径，既有被线下真实到又有他人的鼓励。真幸运以前
【奖金区Master】带你打kaggle
【奖金区Master】带你打kaggle_HMS_Harmful Brain Activity Classification比赛名称：有害脑活动分类竞赛比赛类型
【奖金区Master】带你打kaggle
【奖金区Master】带你打kaggle_The Learning Agency Lab - PII Data Detection比赛名称：从教育数据中检测并删
阿里巴巴国际化电商部门招算法
💼 公司岗位团队招人，校招社招均可，阿里国际电商板块，业务发展迅速，推荐营销算法方向，大量hc，简历发过来！https://aidc-jobs.alibaba
喜马拉雅测试岗值得去吗
12月之前在考研，感觉上岸有点悬准备两手准备，考不上就去打工，现在一个实习都没有，想着应该积累积累经验才找到一个喜马拉雅的测试岗的实习，值得去吗，会对春招有帮助
快手offer审批已经快一个月了会不会
快手offer审批已经快一个月了会不会有什么问题啊许愿求求快点收邮件吧
【南京OD急招】团队氛围好，有专家，有导
【南京OD急招】团队氛围好，有专家，有导师带，新人友好；业界TOP项目，发展空间大。JAVA/C/JS，HC充足，欢迎私聊
列表
# 相当于C语言的数组但是列表是动态存储且可以进行任何类型数据混存print('-----------创建列表---------')# 创建列表方法一：使用'[
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc596ffa63bbcc9e25eaa73d2cc8d142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2b6358d346d2db09ba2b1b878aa1a7/" rel="bookmark">
			idea 打包跳过测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA操作 点击蓝色的小球
手动命令 mvn clean package -Dmaven.test.skip=true # 下载源码 ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ff15aad1c9a546b6ab0556b5b135f409.png) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6cebefdfbed034b6fe337ed28472d2/" rel="bookmark">
			读取CSV文件并使用3Σ准则进行离群异常点检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用您提供的Python代码以绘制file_path指定的文件内容，我们首先需要读取该CSV文件中的数据。我会假设CSV文件中包含了一列或多列数值数据。在此基础上，我将对代码进行相应的修改：
引入pandas库来读取CSV文件。使用pandas读取位于file_path的CSV文件。选择文件中要分析的数据列（这里我会假设是第一列）。接着，使用这些数据替换原来随机生成的data数组。最后，绘制这些数据的异常值检测图。 请注意，由于无法直接访问您的文件系统，您需要在自己的环境中运行修改后的代码。下面是修改后的代码示例：
# -*- coding: utf-8 -*- # @Time : 2024/1/26 8:39 # @Author : 王摇摆 # @FileName: code7.py # @Software: PyCharm # @Blog ：https://blog.csdn.net/weixin_44943389?type=blog # 使用3Σ准则对数据进行异常点检测和处理 import matplotlib.pyplot as plt import numpy as np import pandas as pd # 导入pandas # 设置matplotlib配置参数，使用支持中文的字体 plt.rcParams['font.sans-serif'] = ['SimHei'] # 设置宋体 plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号 file_path = r'C:\Users\Administrator\Desktop\Code\PistonPumpFaultDiagnosis\dataset\X_train.csv' # 读取CSV文件 data_df = pd.read_csv(file_path) # 假设我们使用第一列数据 data = data_df.iloc[:, 0].values # 计算均值和标准差 mean_value = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6cebefdfbed034b6fe337ed28472d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/094727ecfd059159e812d28a24a58489/" rel="bookmark">
			Node.js Cool 框架分页数据 如果在一个状态下获取多个状态的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需求
比如你想实现 订单状态列表的获取 有可能orderStatus=12 的时候 想返回 orderStatus=10 11 12 13 的时候 分页返回
2.解决
query.orderProgress=[] 此时条件就变成了一个数组
//订单列表 async getOrderListByprogress(query) { const { userId } = this.ctx.clientInfo; query.userId = userId; // 构建查询条件 if (query.orderProgress == 12) { // 当 orderProgress = 12 时，匹配 orderProgress = 10, 11, 12, 13 的记录 query.orderProgress = [10, 11, 12, 13]; } const option = { fieldEq: ['userId', 'orderProgress'], }; if (query.orderProgress === '') { delete query.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/094727ecfd059159e812d28a24a58489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032ca548556fbae49750db3ee6d3bb03/" rel="bookmark">
			单片机变量存储大小由什么决定？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注+星标公众号，不错过精彩内容
作者 | strongerHuang
微信公众号 | 嵌入式专栏
最近看到群友在讨论【单片机变量存储大小由什么决定？】的话题。
比如：int、long int 有多大？结构体占多大空间？
描述
在实际情况中，不同的处理器架构、操作系统、以及编译器等都不是决定整形变量大小的关键因素，比如：51、ARM、x86、x64等不同的处理器架构，FreeRTOS、 Linux、Windows等不同的操作系统，gcc、AC、clang等不同编译器。
主要是处理器位数决定。（当然，目前我验证过的所有情况是由处理器位数决定，其他决定性因素有待考证）
首先，整型变量大小由编译器（编译）得来，而编译器首先会考虑编译环境（这个环境主要是CPU的位数）。
之前给大家分享过《用Keil验证8位和32位单片机变量占用空间大小》，其中就体现了8位和32位CPU中变量占用空间的大小。
验证
之前分享《用Keil验证8位和32位单片机变量占用空间大小》的内容，主要在Keil这个编译环境下，通过编译大小验证。
这其中是想描述Keil环境下CPU位数，以及大小端对变量占用空间大小的影响。
而最直接的办法则是通过sizeof得出大小，打印出来。
这里额外提一下sizeof 和 sizeof 的区别：
sizeof通常计算变量大小，strlen计算字符串长度
sizeof是运算操作符，strlen是函数
sizeof在编译的时候得出大小，strlen要考虑’\0字符的长度
例子源代码：
#include &lt;stdio.h&gt; int main(void) { printf( " char: %d\n" , sizeof(char)); printf( " short int: %d\n" , sizeof(short int)); printf( " int: %zd\n" , sizeof(int)); printf( " long int: %d\n", sizeof(long int)); printf( "long long int: %d\n", sizeof(long long int)); printf( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/032ca548556fbae49750db3ee6d3bb03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9a96ad233034c02a577317945d302a/" rel="bookmark">
			程序员薪资升级秘籍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78bc833145f0a3197e80662967719bc0/" rel="bookmark">
			人人必备的学会沟通中掌控情绪，避免冲突方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、了解自己的情绪
2、换位思考
3、掌握正确的沟通技巧
4、保持冷静
5、尊重对方
6、学会道歉
1、了解自己的情绪 在沟通中掌控情绪的第一步，就是了解自己的情绪。当我们感到愤怒、不满、焦虑等负面情绪时，应该首先意识到自己的情绪状态。只有了解自己的情绪，才能更好地掌控自己的情绪，避免情绪冲突的发生。
2、换位思考 沟通中的另一个重要的技巧就是换位思考。换位思考是指从对方的角度去思考问题，理解对方的感受和想法。当我们能够真正理解对方的立场和情感时，就能够更好地掌控自己的情绪，避免冲突的发生。
3、掌握正确的沟通技巧 在沟通中，正确的沟通技巧是非常重要的。例如，正确地表达自己的意见和观点，避免使用攻击性语言和过激言辞，以及倾听对方的意见和想法等。只有掌握了正确的沟通技巧，才能更好地掌控自己的情绪，避免情绪冲突的发生。
4、保持冷静 在沟通中，保持冷静是非常重要的。当我们感到愤怒或者不满的时候，应该先停下来，冷静下来，不要冲动地做出任何决定或者发表任何言论。只有在冷静的状态下，才能更好地掌控自己的情绪，避免情绪冲突的发生。
5、尊重对方 在沟通中，尊重对方是非常重要的。对于对方的观点和意见，我们应该给予足够的尊重和理解。只有尊重对方，才能建立良好的人际关系，从而更好地掌控自己的情绪，避免情绪冲突的发生。
6、学会道歉 在沟通中，如果我们做错了什么，或者说错了什么，应该学会及时道歉。道歉不仅能够缓解对方的情绪，还能够让对方感受到我们的诚意和善意。只有学会道歉，才能更好地掌控自己的情绪，避免情绪冲突的发生。
总之，在沟通中掌控情绪，避免冲突，需要我们从多个角度来分析和思考。只有了解自己的情绪、换位思考、掌握正确的沟通技巧、保持冷静、尊重对方和学会道歉，才能更好地掌控自己的情绪，避免情绪冲突的发生。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a45ffc0beca7a4b94c72168ac5112dca/" rel="bookmark">
			计算机Java项目｜游戏美术外包管理信息系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：编程指南针
作者简介：Java领域优质创作者、CSDN博客专家 、CSDN内容合伙人、掘金特邀作者、阿里云博客专家、51CTO特邀作者、多年架构师设计经验、腾讯课堂常驻讲师
主要内容：Java项目、Python项目、前端项目、人工智能与大数据、简历模板、学习资料、面试题库、技术互助
收藏点赞不迷路 关注作者有好处
文末获取源码 项目编号：L-BS-ZXBS- 一，环境介绍 语言环境：Java: jdk1.8
数据库：Mysql: mysql5.7
应用服务器：Tomcat: tomcat8.5.31
开发工具：IDEA或eclipse
技术：ssm
二，项目简介 随着科学技术的发展，电脑已成为人们生活中必不可少的生活办公工具，在这样的前提下，网络技术被应用到各个方面，网络信息技术飞速发展提高了办公生活效率，使得人类社会进入了全新的信息化的时代。
游戏美术外包管理信息一直是一大难题，游戏美术外包管理作品信息量多，外包需求量大，因此寻找有效便捷的游戏美术外包管理信息方法就是当务之急。利用日趋成熟的计算机信息管理技术搭建游戏美术外包管理信息系统便成为解决这一难题的唯一之选。
使用游戏美术外包管理信息系统相对传统线下管理方式具备很多优点：首先可以大幅提高游戏美术外包管理信息检索，只需输入游戏美术外包管理相关信息就能在数秒内反馈想要的结果；其次可以对游戏美术外包需求管理、外包应征管理，流程追踪管理，在线交流管理，在线回复管理等进行有效管理。再次，相比传统管理信息，游戏美术外包管理信息安全性保障更高，游戏美术外包管理信息系统更节省空间人力资源。这些优点大大提高效率并节省成本。因此，开发游戏美术外包管理信息系统是很必要的，不仅提高了游戏美术外包管理信息效率，增加了用户信息安全性，方便及时反馈信息给管理员，增加了与管理员之间的互动交流。
本系统为了数据库结构的灵活性所以打算采用MySQL来设计数据库，而java技术，B/S架构则保证了较高的平台适应性。本文主要介绍了本系统的开发背景，所要完成的功能和开发的过程，主要说明了系统设计的重点、设计思想。
系统功能需求分析是通过软件开发者在参与市场调研，与管理者及使用者交流后经过详细缜密的思考，再讨论研究后得出的初步系统开发所需实现功能。这是开发的第一步，也是至关重要的一步，如果不在这个阶段制定系统所需模块，日后会带来不必要的麻烦。因此，必须严肃认真，全身心投入去做好这个步骤。
本系统采用自上往下的方法开发，基本定位如下功能：
本课题要求实现一套游戏美术外包管理信息系统，系统主要包括管理员模块和用户模块、公司模块。
通过市场调研及咨询研究，了解了使用者及管理者的使用需求，于是制定了管理员和用户等模块。其功能结构图如下图
三，系统展示 3.1 APP端 登录，用户和公司通过输入账号和密码，选择用户类型并点击登录进行系统登录操作，如图5-1所示。
图5-1登录界面图
用户登陆系统前台，可以对首页，作品信息，外包需求，我的等功能进行详细操作，如图5-2所示。
图5-2前台首页界面图
公司，在我的页面可以查看作品订单，外包需求，外包应征，流程追踪，在线交流，在线回复，留言反馈等详细信息进行操作；如图5-3所示。
图5-3公司功能界面图
用户，在我的页面可以对作品信息，作品订单，外包应征，流程追踪，在线交流，在线回复，留言反馈等详细信息进行操作，如图5-4所示。
图5-4用户功能界面图
3.2管理员功能模块 管理员登录进入游戏美术外包管理信息系统可以查看首页，个人中心，用户管理，公司管理，作品信息管理，作品订单管理，外包需求管理，外包应征管理，流程追踪管理，在线交流管理，在线回复管理，管理员管理，留言反馈，系统管理等功能进行详细操作，如图5-5所示。
图5-5管理员功能界面图
用户管理；在用户管理页面中可以对索引，用户名，用户姓名，性别，头像，身份证，手机，信用分，审核回复，审核状态，审核等内容进行详情，修改和删除操作；如图5-6所示。
图5-6用户管理界面图
公司管理；在公司管理页面中可以对索引，账号，公司名称，负责人，性别，图片，联系电话，邮箱，地址，信用分，审核回复，审核状态，审核等内容进行详情，修改和删除操作；如图5-7所示。
图5-7公司信息管理界面图
公告信息；在公告信息页面中可以对索引，标题，图片等内容进行详情，修改和删除操作；如图5-8所示。
图5-8公告信息界面图
作品信息管理；在作品信息管理页面中可以对索引，作品名称，作品类型，图片，价格，发布时间，用户名，用户姓名，手机等内容进行详情，修改和删除操作；如图5-9所示。
图5-9作品信息管理界面图
作品订单管理；在作品订单管理页面中可以对索引，订单编号，作品名称，作品类型，图片，用户名，用户姓名，价格，下单时间，账号，公司名称，是否支付，审核回复，审核状态等内容进行详情，修改和删除操作；如图5-10所示。
图5-10作品订单管理界面图
外包需求管理；在外包需求管理页面中可以对索引，作品名称，作品类型，图片，价格，发布时间，账号，公司名称，联系电话等内容进行详情，修改和删除操作；如图5-11所示。
图5-11外包需求管理界面图
外包应征管理；在外包应征管理页面中可以对索引，订单编号，作品名称，作品类型，图片，账号，公司名称，价格，下单时间，用户名，用户姓名， 是否支付，审核回复，审核状态等内容进行详情，修改和删除操作；如图5-12所示。
图5-12外包应征管理界面图
管理员管理；在管理员管理页面中可以对索引，用户名，密码，角色等内容进行详情，修改和删除操作；如图5-13所示。
图5-13管理员管理界面图
系统管理；在轮播图管理页面中可以对索引，名称，值等内容进行详情和修改操作，还可以对公告信息进行操作，如图5-14所示。
图5-14系统管理界面图
四，核心代码展示 五，相关作品展示 基于Java开发、Python开发、PHP开发、C#开发等相关语言开发的实战项目
基于Nodejs、Vue等前端技术开发的前端实战项目
基于微信小程序和安卓APP应用开发的相关作品
基于51单片机等嵌入式物联网开发应用
基于各类算法实现的AI智能应用
基于大数据实现的各类数据管理和推荐系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7963313a2928d267185dc3b8866e8431/" rel="bookmark">
			YOLO-V4源码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 整体架构
整体架构和YOLO-V3相同（感谢知乎大神@江大白），创新点如下：
输入端 --&gt; Mosaic数据增强、cmBN、SAT自对抗训练；
BackBone --&gt; CSPDarknet53、Mish激活函数、Dropblock；
Neck --&gt; SPP、FPN+PAN结构；
Prediction --&gt; GIOU_Loss、DIOU_nms。
二. 输入端
数据加载流程（以训练为例） “darknet/src/darknet.c”–main()函数：模型入口。
...... // 根据指令进入不同的函数。 if (0 == strcmp(argv[1], "average")){ average(argc, argv); } else if (0 == strcmp(argv[1], "yolo")){ run_yolo(argc, argv); } else if (0 == strcmp(argv[1], "voxel")){ run_voxel(argc, argv); } else if (0 == strcmp(argv[1], "super")){ run_super(argc, argv); } else if (0 == strcmp(argv[1], "detector")){ run_detector(argc, argv); // detector.c中，run_detector函数入口，detect操作，包括训练、测试等。 } else if (0 == strcmp(argv[1], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7963313a2928d267185dc3b8866e8431/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10b4f53ad6954effb06b16e1248790a/" rel="bookmark">
			基于本地缓存制作一个分库分表的分布式ID生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 代码在 https://gitee.com/lbmb/mb-live-app 中 【mb-live-id-generate-provider】 模块里面 如果喜欢 希望大家给给star 项目还在持续更新中。
背景介绍 项目整体架构是 基于springboot 3.0 开发 rpc 调用采用 dubbo
注册配置中心 使用 nacos 采用sharding-jdbc 来实现分库分表。
基于以上情况 我想生成分布式id。再根据生成的分布式id 存到不同的表中
例如 id 1000 存在 user01表 id 1001 存到 user02表，然后sharding-jdbc会根据我们
基础成长 可以学习到多线程、线程池的使用和设计分布式id器的优化策略（预加载、类似hashmap扩容） 首先我们需要设计一张id策略表
CREATE TABLE `t_id_generate_config` ( `id` int NOT NULL AUTO_INCREMENT COMMENT '主键 id', `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '描述', `next_threshold` bigint DEFAULT NULL COMMENT '当前 id 所在阶段的阈\n值', `init_num` bigint DEFAULT NULL COMMENT '初始化值', `current_start` bigint DEFAULT NULL COMMENT '当前 id 所在阶段的开始\n值', `step` int DEFAULT NULL COMMENT 'id 递增区间', `is_seq` tinyint DEFAULT NULL COMMENT '是否有序（0 无序，1 有序）', `id_prefix` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '业务前缀码，如果没有则返回\n时不携带', `version` int NOT NULL DEFAULT '0' COMMENT '乐观锁版本号', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时\n间', `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; INSERT INTO `t_id_generate_config` (`id`, `remark`, `next_threshold`, `init_num`, `current_start`, `step`, `is_seq`,`id_prefix`, `version`, `create_time`, `update_time`) VALUES (1, '用户 id 生成策略', 10050, 10000, 10000, 50, 0, 'user_id', 0, '2023-05-23 12:38:21', '2023-05-23 23:31:45'); 定义全局变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a10b4f53ad6954effb06b16e1248790a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b8b5a879f0ea11f8d44809bfe02e9f/" rel="bookmark">
			Spring-Kafka 3.0 消费者消费失败处理方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 我们作为Kafka在使用Kafka是，必然考虑消息消费失败的重试次数，重试后仍然失败如何处理，要么阻塞，要么丢弃，或者保存
二、设置消费失败重试次数 1 默认重试次数在哪里看 Kafka3.0 版本默认失败重试次数为10次，准确讲应该是1次正常调用+9次重试，这个在这个类可以看到 org.springframework.kafka.listener.SeekUtils
2 如何修改重试次数 据我的实验，spring-kafka3.0版本通过application.yml 配置是行不通的，也没有找到任何一项配置可以改重试次数的（网上很多说的通过配置spring.kafka.consumer.retries 可以配置，我尝试过了，至少3.0版本是不行的，如果有人成功试过可以通过application.yml 配置消费者的消费的重试次数可以留言通知我，谢谢）
经过我不懈努力和尝试，只能通过Java代码配置的方式才可以，并且这种方式相对于application.yml配置更加灵活细致，上代码
public CommonErrorHandler commonErrorHandler() { BackOff backOff = new FixedBackOff(5000L, 3L); return new DefaultErrorHandler(backOff); } 然后把这个handler 添加到ConcurrentKafkaListenerContainerFactory中就行了
三、设置消费失败处理方式 1 保存到数据库重试 我们需要在创建DefaultErrorHandler类时加入一个ConsumerAwareRecordRecoverer参数就可以了，这样在重试3次后仍然失败就会保存到数据库中，注意这里save to db成功之后，我认为没有必要执行consumer.commitSync方法，首先这个consumer.commitSync这个方法默认是提交当前批次的最大的offset（可能会导致丢失消息），其次不提交Kafka的消费者仍然回去消费后面的消息，只要后面的消息，消费成功了，那么依然会提交offset，覆盖了这个offset
public CommonErrorHandler commonErrorHandler() { // 创建 FixedBackOff 对象 BackOff backOff = new FixedBackOff(5000L, 3L); DefaultErrorHandler defaultErrorHandler = new DefaultErrorHandler((ConsumerAwareRecordRecoverer) (record, consumer, exception) -&gt; { log.info("save to db " + record.value().toString()); }, backOff); return defaultErrorHandler; } 如果你硬要提交也可以试试下面这种，指定提交当前的offset
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0b8b5a879f0ea11f8d44809bfe02e9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7c132e9ba17024f8288bb90ff395607/" rel="bookmark">
			自然语言处理中的文本纠错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​目录
1.背景介绍
2.核心概念与联系
3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
3.1 基于规则的文本纠错算法
3.2 基于统计的文本纠错算法
4.具体代码实例和详细解释说明
API 设计
文本纠错（高级版-通用领域-中文）
调用须知
请求参数
返回数据
调用接入
错误码
1.背景介绍 自然语言处理（NLP）是计算机科学与人工智能的一个分支，研究如何让计算机理解、生成和处理人类语言。在自然语言处理中，文本纠错是一种重要的技术，它旨在修正文本中的错误，以提高文本的质量和可读性。
文本纠错技术广泛应用于各种领域，如新闻报道、社交媒体、电子邮件、文档编辑等。在这篇文章中，我们将深入探讨文本纠错的核心概念、算法原理、具体操作步骤以及数学模型公式。我们还将通过具体代码实例来解释这些概念和算法，并讨论未来发展趋势和挑战。
2.核心概念与联系 在自然语言处理中，文本纠错主要涉及以下几个核心概念：
错误类型：文本纠错可以分为两类：语法错误和语义错误。语法错误是指文本中的拼写错误、格式错误等，而语义错误是指文本中的意义错误，例如使用错误的词汇或表达不清晰的句子。
纠错方法：文本纠错方法可以分为两类：规则引擎方法和统计方法。规则引擎方法依赖于预先定义的规则来检测和修正错误，而统计方法则依赖于大量的文本数据来学习错误的模式。
纠错模型：文本纠错模型可以分为两类：基于规则的模型和基于机器学习的模型。基于规则的模型依赖于预先定义的规则来检测和修正错误，而基于机器学习的模型则通过训练在大量文本数据上学习错误的模式。
3.核心算法原理和具体操作步骤以及数学模型公式详细讲解 在本节中，我们将详细讲解文本纠错的核心算法原理、具体操作步骤以及数学模型公式。
3.1 基于规则的文本纠错算法 基于规则的文本纠错算法依赖于预先定义的规则来检测和修正错误。这些规则可以是简单的拼写检查规则，如检测重复的字符或空格，或者是更复杂的语法规则，如检测句子结构的错误。
具体操作步骤如下：
读取文本数据。遍历文本中的每个单词。根据预先定义的规则检测单词是否存在错误。如果单词存在错误，则根据规则修正错误。将修正后的文本输出。 3.2 基于统计的文本纠错算法 基于统计的文本纠错算法依赖于大量的文本数据来学习错误的模式。这种方法通常使用统计学习方法，如朴素贝叶斯、支持向量机等，来建立文本纠错模型。
具体操作步骤如下：
收集大量的文本数据。预处理文本数据，包括分词、标记化等。使用统计学习方法建立文本纠错模型。使用模型对新文本进行纠错。 4.具体代码实例和详细解释说明 在本节中，我们将通过具体代码实例来解释前面提到的核心概念和算法。
4.1 基于规则的文本纠错算法实例
python复制代码import re
def correct_text(text):
# 定义正则表达式规则
rules = [
(r'\b\w\w\w\w\w\b', r'\1'),
(r'\b\w\w\w\w\w\w\b', r'\1'),
(r'\b\w\w\w\w\w\w\w\b', r'\1'),
]
# 遍历文本中的每个单词
words = text.split()
corrected_words = []
for word in words:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7c132e9ba17024f8288bb90ff395607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d4dc51b21f215193807bf1456fe596/" rel="bookmark">
			【渗透测试】借助PDF进行XSS漏洞攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 在平时工作渗透测试一个系统时，常常会遇到文件上传功能点，其中大部分会有白名单或者黑名单机制，很难一句话木马上传成功，而PDF则是被忽略的一个点，可以让测试报告更丰富一些。
含有XSS的PDF制作步骤 1. 编辑器生成含有XSS的PDF 下载PDF编辑器
迅捷PDF编辑器 - 多功能的PDF编辑软件
新建一个文档
点击编辑器左下角的文件属性选择Javascript-&gt;添加-&gt;输入恶意XSS代码
app.alert(‘xss’);
利用 JavaScript 进行攻击时只能使用 Adobe 所支持的功能
保存后，使用浏览器打开
弹框成功
2.Python生成含有XSS的PDF 若不想PDF带水印，还可以使用Python编写poc制作含有XSS的PDF
安装第三方库：
pip install PyPDF2 -i https://pypi.tuna.tsinghua.edu.cn/simple
from PyPDF2 import PdfReader,PdfWriter new_PDF = PdfWriter() # 写入JavaScript代码 new_PDF.add_js("app.alert('xss');") f = open("没有危害的PDF.pdf","wb") new_PDF.write(f) f.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13cac13527f3fb712e5140e40011645d/" rel="bookmark">
			深入探究 Android 内存泄漏检测原理及 LeakCanary 源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入探究 Android 内存泄漏检测原理及 LeakCanary 源码分析 一、什么是内存泄漏二、内存泄漏的常见原因三、我为什么要使用 LeakCanary四、LeakCanary介绍五、LeakCanary 的源码分析及其核心代码六、LeakCanary 使用示例 一、什么是内存泄漏 在基于 Java 的运行时中，内存泄漏是一种编程错误，它会导致应用程序保留对不再需要的对象的引用。因此，为该对象分配的内存无法回收。
例如，Android实例在调用Activity其方法后不再需要，并且在静态字段中存储对该实例的引用可防止其被垃圾收集。onDestroy()
二、内存泄漏的常见原因 大多数内存泄漏是由与对象生命周期相关的错误引起的。以下是一些常见的 Android 错误：
将实例添加Fragment到后台堆栈而不清除 Fragment 的视图字段Fragment.onDestroyView()（更多详细信息请参阅此 StackOverflow 答案）。将实例存储Activity为Context对象中的字段，该对象在由于配置更改而导致活动重新创建后仍然存在。注册引用具有生命周期的对象的侦听器、广播接收器或 RxJava 订阅，并在生命周期结束时忘记取消注册。 三、我为什么要使用 LeakCanary 内存泄漏在 Android 应用程序中非常常见。随着小内存泄漏的累积、内存使用量的增加，垃圾收集器 (GC) 运行更加频繁并消耗更多的 CPU，导致卡顿、UI 冻结和应用程序无响应 (ANR)报告，最终导致OutOfMemoryError (OOME)崩溃。LeakCanary 将帮助您在开发过程中发现并修复这些内存泄漏。当 Square 工程师首次在 Square Point Of Sale 应用程序中启用 LeakCanary 时，他们修复了多个漏洞，并将 OOM 崩溃率降低了94%。
四、LeakCanary介绍 Android 内存泄漏是指应用程序中的对象在不再需要时仍然保持对内存的引用，导致内存无法回收，最终可能导致应用程序的性能问题和崩溃。内存泄漏的常见原因包括静态引用、匿名内部类、长时间保持对对象的引用等。
LeakCanary 是一个流行的开源库，用于检测 Android 应用程序中的内存泄漏。它的工作原理可以简单概括为以下几个步骤：
监控对象的生命周期：LeakCanary 使用 Android 的垃圾收集器（Garbage Collector）的回调机制来监控对象的生命周期。它通过注册一个专门的引用队列（ReferenceQueue）来跟踪应用程序中的对象。
检测对象泄漏：当一个对象被垃圾收集器回收时，如果该对象仍然存在于 LeakCanary 的引用队列中，LeakCanary 就会认为该对象存在泄漏。它会触发一个分析过程，以确定泄漏对象的引用链。
分析引用链：LeakCanary 会分析引用链，即导致泄漏对象保持在内存中的对象引用序列。它会跟踪这些引用链，以确定导致泄漏的根本原因。
生成报告：一旦确定了泄漏对象和其引用链，LeakCanary 将生成一个报告，其中包含详细的信息，如泄漏对象的类名、引用链中的对象等。报告通常以通知的形式显示在设备上，以便开发人员能够及时发现和解决内存泄漏问题。
五、LeakCanary 的源码分析及其核心代码 关于 LeakCanary 的源码分析及其核心代码，由于篇幅限制和代码复杂性，无法在此详细介绍。但是，您可以通过查看 LeakCanary 的源代码仓库（https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13cac13527f3fb712e5140e40011645d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926eeee939c5d01a5c2b5edc48ef584d/" rel="bookmark">
			mysql面试题合集-分布式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 前文介绍了MySQL基础知识，现在继续介绍分布式数据库相关知识。
mysql分布式面试题合集 什么是分布式数据库？它与集中式数据库有何不同？在分布式数据库中，如何解决数据分片后的一致性问题？你如何理解MySQL的分布式解决方案，例如MySQL Cluster、MySQL Replication等？请解释一下MySQL Replication的工作原理，以及它是如何实现数据备份和读取负载均衡的？你有没有使用过MySQL Proxy？它在分布式系统中起到了什么作用？在分布式数据库系统中，事务的处理方式与传统关系型数据库有何不同？如何保证分布式事务的一致性？请解释一下分布式数据库中的分片（Sharding）技术，以及如何实现数据路由？你如何理解分布式数据库的扩展性和高可用性？在分布式数据库中，如何进行故障恢复和数据备份？在分布式数据库中，如何解决数据冲突和保证数据一致性？在分布式数据库中，如何进行性能优化和监控？
先列出问题，接下来评论回复交流。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03d8e6797a58117d424f8d8e9c61ede/" rel="bookmark">
			如何将知识图谱与AIGC结合？京东是这么做的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后台留言『交流』，加入 NewBee讨论组
导读 大家好，这里是NewBeeNLP。本文将分享如何将知识图谱应用到电商场景下的 AIGC。
文章将围绕下面五个方面进行分享：
1. 导言
2. 基于领域知识图谱的商品文案生成
3. 基于通用知识图谱的商品文案生成
4. 基于领域知识图谱的 LLM
5. 基于通用知识图谱的 LLM
分享嘉宾｜李浩然博士 京东科技 言犀大模型算法负责人
出品社区｜DataFun
01
导言
首先介绍一下京东在电商场景下 AIGC 方面的探索。
这是一个商品营销文案自动生成的全景图，自下而上首先是商品的输入信息。输入信息是异构多源的，包括商品的商详页里的图片、文本、商品的标题以及商品的知识图谱。通用的知识图谱是三元组的形式，也就是头实体、尾实体以及关系，比如“中国的首都是北京”（头实体：中国；尾实体：北京；关系：首都）。在电商场景下，三元组的知识图谱转化为一个二元组，是一个“商品属性-属性值”对。商品里含有图片信息，也就是说实际上这是一个多模态文本生成的场景。当我们拿到这些较为丰富的信息后，会对信息做一些初步处理，包括提取它的卖点（描述了商品非常好的、值得大家去参考的一些价值点）、要素（对商品知识图谱的凝练，比如空调，它的要素就有电机、静音、能效等等，当描述到能效可能就会介绍到环保、节能、省电这样的要素和要素词的体系）。
信息得到初步处理后会进入模型侧。模型侧有编码器、解码器，因为输入信息是多模态的，所以编码器又分文本编码器和图片编码器。在解码器方面会使用受限解码、复制解码的形式来满足 AIGC 在电商这一严肃场景下的应用。除此之外也会用到现在比较流行的预训练语言模型、句间流畅度模型。句间流畅度模型是对传统解码器的加强，因为传统解码器最关注的点是词与词之间的衔接性（或者说连贯性），但是对短句与短句之间的衔接性的关注并不直接，所以需要加入一个句间流畅度模型加强短句之间的连贯性或者逻辑的一致性。
此外，还会涉及标点纠错模型，比如有时生成的文案会倾向于“一逗到底”（整个文案里面所有的标点都是逗号）。
最上面就是输出，输出是多种多样的文案，包括 50 字、100 字较短的文案，也包括 500 字甚至 1000 字更长的直播文案。
接下来给大家展示一些京东电商场景下的真实应用。
首先是京东 APP 的发现好货频道，这个频道内会给用户推荐优质商品，有图片、商品卖点标题以及商品文案等展示形式。
第二个场景是导购机器人，当和京东客服进行交流的时候，在人工客服或智能客服解答用户问题之前，导购机器人会根据用户需要咨询的商品，首先给他推送一条商品的介绍文案，预期达到通过介绍文案直接解答用户的一些疑问和进一步对商品进行促销的效果。
第三个场景是社交 APP 京粉，这是个社交团购的场景，通过对文案进行一些个性化的处理（加一些表情符号、促销信息），方便分享到社交平台。
第四个场景是直播机器人，直播场景下需要生成比较长的文案，有时可能超过一千字，用于给虚拟主播或者一些没有经验、没有运营团队的真人直播提供文案参考。
最后一个场景就是搭配购，搭配购和前面四个场景不同点在于前面四个场景都是为单一商品生成文案，搭配购是给多个商品生成文案。例中商品是上衣、裤子和书包，他们都是符合某一种风格的——比如颜色相近，或者说都是运动风——模型需要基于这种相似性自动生成文案对商品组合形成促销。
实际上，大多数使用场景的底层技术都是文本生成，或者说可控文本生成。也就是在相对严肃场景下，不借助人工的审核或编辑，直接生成文案展示给用户，并且不会出现一些比较离奇的、难以接受的错误，比如说描述出一个错误的属性，描述出一个不通顺的文本。
近年来，可控文本生成技术在学术界的关注也呈现出爆发增长的趋势，根据最近几年 NLP 领域两个顶会 ACL 和 EMNLP 的文本生成相关论文统计，2018 年之前相关论文投稿数仅有个位数，而到 2019 年之后出现了激增，并一直保持在两位数以上，说明相关话题在学术界已经得到了足够的关注。
那么如何做到可控文本生成呢？主要有三个角度去实现。
首先第一个角度，是从输入方面控制输入文本，我们知道“garbage in garbage out”，如果输入里面有非常多的垃圾信息，模型学习压力就比较大。比如说一些违反广告法的“最”、“顶级”等词，就不希望出现在输入里面。
第二个控制方向是词表，比如希望某些词（如卖点词、属性词、知识图谱相关的描述词）被鼓励，或某些词是被禁止的，我们可以以调整词表的形式，在解码端对词的概率进行调整。
第三个角度是模型，这是一个比较有效但难度也比较大的方式，例如可以通过改变解码器的初始化、解码器改变编码器的初始化、添加一些辅助任务以及做一些多任务学习来调整模型。
电商领域的文本生成研究面临着非常多挑战。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c03d8e6797a58117d424f8d8e9c61ede/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0cb83e4d72ad1517f6d6bd3e26c493c/" rel="bookmark">
			UE4运用C&#43;&#43;和框架开发坦克大战教程笔记（十六）（第49~50集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UE4运用C++和框架开发坦克大战教程笔记（十六）（第49~50集） 49. 创建多个资源对象补全调用链并测试生成多个同种类名资源对象实现创建多个同资源名的对象实例 50. 资源加载系统测试补全调用链并测试生成多个同名资源对象测试生成 Widget 资源对象测试生成 Object 资源对象 49. 创建多个资源对象 补全调用链并测试生成多个同种类名资源对象 上节写好了 DDWealth 里的创建同种类名资源对象的方法，这集开头先来补充完整 DDWealth – DDModule – DDOO – 对象 这条调用链。
DDModule.h
public: // 创建同资源种类名的对象实例，同种类名下的每个资源链接创建一个对象实例 void BuildKindClassWealth(EWealthType WealthType, FName WealthKind, FName ObjectName, FName FunName, TArray&lt;FTransform&gt; SpawnTransforms); DDModule.cpp
void UDDModule::BuildKindClassWealth(EWealthType WealthType, FName WealthKind, FName ObjectName, FName FunName, TArray&lt;FTransform&gt; SpawnTransforms) { Wealth-&gt;BuildKindClassWealth(WealthType, WealthKind, ObjectName, FunName, SpawnTransforms); } 对于 DDOO 来说，要根据生成对象的种类类型来区分调用方法。并且也不需要传 ObjectName，因为它自带有。
DDOO.h
protected: // 创建同资源种类名的对象实例，同种类名下的每个资源链接创建一个对象实例 void BuildKindClassWealth(EWealthType WealthType, FName WealthKind, FName FunName); void BuildKindClassWealth(EWealthType WealthType, FName WealthKind, FName FunName, FTransform SpawnTransform); void BuildKindClassWealth(EWealthType WealthType, FName WealthKind, FName FunName, TArray&lt;FTransform&gt; SpawnTransforms); DDOO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0cb83e4d72ad1517f6d6bd3e26c493c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282a7bf44c5697744c909b38974b1fd4/" rel="bookmark">
			爬虫实战小案例—获取喜马拉雅账号的关注数据和粉丝数据生成电子表格并实现批量关注或者取关然后生成表格文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫案例—获取喜马拉雅账号的关注数据和粉丝数据生成电子表格并实现批量关注或者取关然后生成表格文件 ​ 有好多人平时应该很喜欢听喜马拉雅的广播，也有自己的账号。我本人平时很少听喜马拉雅广播，前几天一个朋友问我能不能帮他获取喜马拉雅账号的已关注的数据和粉丝的数据， 然后再查找有哪些自己已关注的但没有关注自己（也就是不是自己的粉丝）的，还有自己没关注的粉丝数据。接下来这个朋友又提出能不能帮助实现批量取关和关注数据，然后再生成一个关注和取关的数据表格文件。
​ 大家听起来估计也有点绕了，我也是有这个同感。话不多说了，我接到他这个请求之后，第一时间想到用爬虫来实现这个功能。喜马拉雅的登录页面如下：
登录之后进入 个人主页，点击账号头像然后再点击个人页。如下图所示：
然后进入到个人主页，按下F12键进入开发者工具模式（Chrome浏览器），再点击关注标签，进入关注页面，如下图所示：
如红框所示就是关注页面的链接，点击红框可以看到headers请求头包含url，如下图所示：
通过分析此页面是异步加载方式，响应的数据为json格式，点击如下图红框所示的标签：
粉丝页面跟这个是同理。不在这里一一截图展示了。那么接下来就是如何获取关注和粉丝的数据了，登录账号以后，就很简单了，代码如下：
import pandas as pd import requests import datetime headers = { 'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36', } # 粉丝数据函数 def get_fans_info(fans_url): # cookies = {'Cookie':'_xmLog=h5&amp;c8be971d-2bc5-45e7-8688-bcdd1db6756e&amp;process.env.sdkVersion; xm-page-viewid=ximalaya-web; impl=www.ximalaya.com.login; x_xmly_traffic=utm_source%253A%2526utm_medium%253A%2526utm_campaign%253A%2526utm_content%253A%2526utm_term%253A%2526utm_from%253A; Hm_lvt_4a7d8ec50cfd6af753c4f8aee3425070=1704697013; wfp=ACM3OGI2ZWMyZjA0YmZmNzZjbgf-TtTrRsF4bXdlYl93d3c; 1&amp;remember_me=y; 1&amp;_token=460178701&amp;BC39CDE0340ND8AF9619AA1EE929208BF9A358F59A66F0159C7A3207C10994A33085862F14E2119M775F0459473319F_; 1_l_flag=460178701&amp;BC39CDE0340ND8AF9619AA1EE929208BF9A358F59A66F0159C7A3207C10994A33085862F14E2119M775F0459473319F__2024-01-2419:20:17; Hm_lpvt_4a7d8ec50cfd6af753c4f8aee3425070=1706145114; web_login=1706148245440' # } session = requests.Session() res = session.get(fans_url, headers=headers)#, cookies=cookies) res_fans = res.json()['data']['fansPageInfo'] fans_id = [] fans_nickname = [] for fan in res_fans: fans_id.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/282a7bf44c5697744c909b38974b1fd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e6687cbcc184e80a37ddd1e991ddd6/" rel="bookmark">
			Spring 事务和事务传播机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Spring 声明式事务 声明式事务的实现很简单,只需要在需要的方法上添加 @Transantioinal 注解就可以实现了,无需手动开启事务和提交事务,进入方法时自动开启事务,方法执行完后会自动提交事务,如果中途发生了没有处理的异常会自动回滚事务.
@RestController @Transactional public class UserController { @Autowired private UserService userService; @RequestMapping("/add") public int add(){ UserInfo userInfo=new UserInfo(); userInfo.setUsername("张三"); userInfo.setPassword("123"); System.out.println("插入成功"); int result=userService.add(userInfo); //出现异常会自动回滚,数据库中不会出现对应的数据 int a=10/0; return result; } } Transactional 作用范围:
修饰方法时：需要注意只能应用到 public 方法上，否则不生效。修饰类时：表明该注解对该类中所有的 public 方法都生效 @Transactional 参数说明
参数作用value当配置了多个事务管理器时，可以使用该属性指定选择哪个事务管理器transactionalManager当配置了多个事务管理器时，可以使用该属性指定选择哪个事务管理器propagation事务的传播行为，默认值为 Propagation.REQUIREDisolation事务的隔离级别，默认值为 Isolation.DEFAULTtimeout事务的超时时间，默认值为 -1，如果超过该时间限制，但事务还没有完成，则自动回滚事务readOnly指定事务是否为只读事务，默认值为false,为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 trueroolbackFor用于指定能够触发事务回滚的异常类型，可以指定多个异常类型rollbackForClassName用于指定能够触发事务回滚的异常类型，可以指定多个异常类型noRollbackFor抛出指定的异常类型不回滚事务，也可以指定多个异常类型noRollbackForClassName抛出指定的异常类型不回滚事务，也可以指定多个异常类型 二. 事务的隔离级别 2.1 事务特性回顾 事务由 4 大特性（ACID)，原子性，持久性，一致性，和隔离性：
原子性（Atomicity)：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。一致性(Consistency)：在事务开始之前和事务结束之后，数据库的完整性没有被破坏，这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度，串联性以及后续数据库可以自发性地完成预定的工作持久性(Isolation)：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失隔离性(Durability)：数据库允许多个并发事务同时对其数据进行读写和修改能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同的级别，包括读未提交（Read uncommitted)、读已提交（Read committed)、可重复读（repeatable read) 和串行化（Serializable)。 2.2 MySQL 事务隔离级别 READ UNCOMMITTED ：读未提交，也叫未提交读，该隔离级别的事务可以看到其他事务中未提交的数据。该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读。READ COMMITTED：读已提交，该隔离级别的事务能读取到已提交事务的数据，因此它不会有脏读问题。但由于事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读。REPEATABLE READ：可重复读，是 MySQL 的默认隔离级别，它能确保同一事务多次查询的结果一致。但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以在事务中查询不到这条信息，但自己就是插入不进去，这就叫做幻读SERIALIZABLE：序列化，事务最高隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读的问题，但因为执行效率低，所以真正使用的场景并不多。 在数据库中通过以下 SQL 查询全局事务隔离级别和当前连接事务隔离级别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65e6687cbcc184e80a37ddd1e991ddd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55cabb38e819f7efacfe40300d94ea0d/" rel="bookmark">
			电容主要特点和作用，不同类型的电容区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电容 两个相互靠近的金属板中间夹一层绝缘介质组成的器件，当两端存在电势差时，由于介质阻碍了电荷移动而累积在金属板上，衡量金属板上储存电荷的能力称之为电容，相应的器件称为电容器。
电容（Capacitance）亦称作“电容量”，是指在给定电位差下自由电荷的储藏量，记为C，国际单位是法拉（F）。一般来说，电荷在电场中会受力而移动，当导体之间有了介质，则阻碍了电荷移动而使得电荷累积在导体上，造成电荷的累积储存，储存的电荷量则称为电容。
电容是指容纳电荷的能力。
计算公式 定义式：
电容器所带电量Q与电容器两极间的电压U的比值，叫电容器的电容。电容的符号是C。
单位及转换 在国际单位制里，电容的单位是法拉，简称法，符号是F，由于法拉这个单位太大，所以常用的电容单位有毫法（mF）、微法（μF）、纳法（nF）和皮法（pF）等，换算关系是：
1法拉（F）= 103 毫法（mF）=106 微法（μF）=109 纳法（nF）=1012 皮法（pF）=1015 fF
法拉（F）是一个很大的单位，平时很少用到
电容表示方法 有标注的例如云母电容就按照上面标注的读，上面会写明容值，例如68uF。贴片的没标注的只能测试。电容的读法和电阻一样，例如104，是10乘以10的四次方，100000pF，注意单位是pF。
电子电容上的104用的是数字计数法，这种计数法一般是3位数字，最左边的第一位和中间的一位数字是有效数字，最右边的一位数字是表示倍数，也就是10的多少次方，如果没有标明单位，一般默认是pF。如果是带小数点的数字，同时没有标明单位，则单位是uF。
1、数字计数法 例如104，那么它的大小就是：10X10^4=100000pF，也就是0.1uF=100nF，这种电容一般是瓷片电容
2、直标法 直标法就是用数字以及单位直接标出来。例如：1.5uF表示1.5微法，这样直接表示。在有些电容当中会用大写字母“R”代表小数点，同时位于数字前面，例如R47uF表示0.47uF，这类表示方法比较少见。
3、色标法 顾名思义就是用色环的方法，与电阻的色环表示方法一样。
电容误差一般用不同的字母表示：
B表示误差在0.1%
C表示误差在0.25%
D表示误差在0.5%
F表示误差在1%
J表示误差在5%
K表示误差在10%
M表示误差在20%
4、文字符号表示 就是用数字和文字符号组合起来读数的一种方法。例如p47表示4.7pF、3p0表示3pF等。
用万用表蜂鸣器档检测电容 利用数字万用表的蜂鸣器档，可以快速检查电解电容器的质量好坏。将数字万用表拨至蜂鸣器档，用两支表笔分别与被测电容器C的两个引脚接触，应能听到一阵短促的蜂鸣声，随即声音停止，同时显示溢出符号“1”。接着，再将两支表笔对调测量一次，蜂鸣器应再发声，最终显示溢出符号“1”，此种情况说明被测电解电容基本正常。此时，可再拨至20MΩ或200MΩ高阻档测量一下电容器的漏电阻，即可判断其好坏
原理图中电容表示方法 C3和C4表示有极性的电容，如电解电容，钽电容
电容的主要特点 “充电” “放电” “隔直” “通交”
充电： 电源输出电流经电容器，在电容上获得大量电荷的过程称为电容的“充电”
放电： 电容一个极板上的正电荷经一定的途径流到另一个极板，中和该极板上的负电荷的过程称为电容器的“放电”
隔直： 将电容器串联到一个由直流电源、开关、灯泡的电路中，刚开始直流电源对电容器充电而通过电容器，该过程很短，充电结束后，直流电无法通过电容器，这就是电容的隔直性质
通交： 将电容器串联到一个由交流电源、开关、灯泡的电路中，交流电源的极性不断变化，使得电容的充电和反充电交替进行，从而始终有电流流过电容器。
电容的所有用途基本都是围绕这四个特性进行的。
注意：电容内部有绝缘介质，内部不会导通，通交流是应用电容的充放电功能，从外部看，感觉导通了而已。
充放电有个过程，电容两端电压不能突变，如果突变，将会产生很大的充放电电流，设计时需要避免，可以通过电阻，电感等器件进行限流。
电容的作用 1、储能 储能型电容器通过整流器收集电荷，并将存储的能量通过变换器引线传送至电源的输出端。电压额定值为40~450VDC、电容值在220～150 000uF之间的铝电解电容器(如ERCOS公司的 B43504或B43505）是较为常用的。根据不同的电源要求，器件有时会采用串联、并联或其组合的形式，对于功率级超过10KW的电源，通常采用体积较大的罐形螺旋端子电容器电解电容一般有正负极之分，注意区分
2、滤波 从理论上（即假设电容为纯电容）说，电容越大，阻抗越小，通过的频率也越高。但实际上超过1μF 的电容大多为电解电容，有很大的电感成份，所以频率高后反而阻抗会增大。有时会看到有一个电容量较大电解电容并联了一个小电容，这时**大电容滤低频，小电容滤高频。电容的作用就是通交流隔直流，通高频阻低频。**电容越大高频越容易通过。具体用在滤波中，**大电容（1000μF）滤低频，小电容（20pF）滤高频。**曾有网友形象地将滤波电容比作“水塘”。由于电容的两端电压不会突变，由此可知，信号频率越高则衰减越大，可很形象的说电容像个水塘，不会因几滴水的加入或蒸发而引起水量的变化。它把电压的变动转化为电流的变化，频率越高，峰值电流就越大，从而缓冲了电压。滤波就是充电，放电的过程。
3、旁路 旁路电容是为本地器件提供能量的储能器件，它能使稳压器的输出均匀化，降低负载需求。就像小型可充电电池一样，旁路电容能够被充电，并向器件进行放电。为尽量减少阻抗，旁路电容要尽量靠近负载器件的供电电源管脚和地管脚。这能够很好的防止输入值过大而导致的地电位抬高和噪声。地电位是地连接处在通过大电流毛刺时的电压降。
4、去耦 去耦，又称解耦。从电路来说， 总是可以区分为驱动的源和被驱动的负载。如果负载电容比较大， 驱动电路要把电容充电、放电， 才能完成信号的跳变，在上升沿比较陡峭的时候， 电流比较大， 这样驱动的电流就会吸收很大的电源电流，由于电路中的电感，电阻（特别是芯片管脚上的电感）会产生反弹，这种电流相对于正常情况来说实际上就是一种噪声，会影响前级的正常工作，这就是所谓的“耦合”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55cabb38e819f7efacfe40300d94ea0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/647003cf619349eb3d08cf14d856a097/" rel="bookmark">
			每次打开都是：已在调试程序中暂停的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击F12，把这个勾选去掉就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ad15fdf748e090793c97f75684aa41/" rel="bookmark">
			云计算项目六：升级网站运行平台｜部署缓存服务｜数据迁移｜部署集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		升级网站运行平台｜部署缓存服务｜数据迁移｜部署集群 案例1：升级网站运行平台步骤一：清除当前配置步骤二：部署LNMP步骤三：测试配置 案例2：部署内存存储服务步骤一：部署redis服务器（6台都要配置）步骤二：创建redis集群步骤三：配置网站服务器步骤四：测试配置 案例3：数据迁移步骤一：配置从服务器(把主机192.168.4.66 配置为192.168.4.11的从服务器)步骤二：配置第1台PXC服务器(192.168.4.66)步骤三：配置第2台PXC服务器(192.168.4.10)步骤四：配置第3台PXC服务器(192.168.4.88)步骤五：公共配置(192.168.4.88、192.168.4.10、192.168.4.66) 案例4：部署LB集群步骤一：安装软件: 在haproxy99主机上安装haproxy软件步骤二：修改配置文件步骤三：启动服务步骤四：测试配置：在网站服务器连接haproxy99主机访问数据 案例5：部署HA集群步骤一：准备备用调度器主机步骤二：安装软件步骤三：修改配置文件步骤四：启动服务步骤五：测试配置 升级网站运行平台 部署内存存储服务 部署pxc集群 解决数据库服务负载问题 解决调度器单点故障问题 案例1：升级网站运行平台 步骤一：清除当前配置 # 停止网站 [root@web33 ~]# /usr/local/tomcat/bin/shutdown.sh [root@web33 ~]# vim /etc/rc.local #/usr/local/tomcat/bin/startup.sh # 卸载掉web服务器挂载 umount /usr/local/tomcat/webapps/ROOT/ vim /etc/fstab # 注销掉挂载 步骤二：部署LNMP # 安装软件 [root@web33 ~]# yum -y install gcc zlib-devel pcre-devel //安装源码Nginx依赖软件 [root@web33 ~]# tar -zxvf nginx-1.12.2.tar.gz //解压 [root@web33 ~]# cd nginx-1.12.2 //进源码目录 [root@web33 nginx-1.12.2]# ./configure //配置 [root@web33 nginx-1.12.2]# make //编译 …… …… sed -e "s|%%PREFIX%%|/usr/local/nginx|" \ -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5ad15fdf748e090793c97f75684aa41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c97f675607196d74935a7ea9ae5db2/" rel="bookmark">
			C&#43;&#43;练习题1-9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 NO1、选出妃子、宫女和嬷嬷No2、根据数字判断月份No3、循环计数No4、循环选数No5、玩转字符No6、计算字符串长度No7、显示字符串中的字符No8、字符串反转No9、二维数组的应用 NO1、选出妃子、宫女和嬷嬷 其他要求：
超女用结构体表示不要嵌套if输入所有数据后再判断 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; struct CGirl { int age; int high; string sc; //c风格字符串 char sc[31]; 字符串比较就要用 strcmp bool yz; }; int main() { CGirl g; cout &lt;&lt; "请依次输入年龄、身高(cm)、身材(火辣/普通)、颜值(漂亮/一般)："; string stringYz{0}; cin &gt;&gt; g.age &gt;&gt; g.high &gt;&gt; g.sc &gt;&gt; stringYz; g.yz = (stringYz == "漂亮") ? true : false; if ((g.age &gt;= 18 &amp;&amp; g.age &lt;= 25) &amp;&amp; (g.high &gt;= 165 &amp;&amp; g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c97f675607196d74935a7ea9ae5db2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19bb72aa0c1df1ce537c2f51c8837043/" rel="bookmark">
			jquery多选框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用hbuilder
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="GBK"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table id="myTable"&gt; &lt;tr&gt; &lt;td&gt;黄1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;行2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;行3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;button id="button" onclick="submit"&gt;点击我&lt;/button&gt; &lt;/html&gt; &lt;script src="F:\Carry\1 1808\jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function() { // 获取表格的所有行 //var rows = $('#myTable tr'); //$(rows).append('&lt;input type="checkbox" /&gt;'); $.ajax({ //url: 'your-api-url', // 替换为你的API接口URL url:"date.json", type: "get", // 或者使用POST，根据你的接口要求 success: function(response) { console.log(response) debugger //	var rows = $('#myTable tr'); var rows = $('#myTable tr:eq(0)'); var name = $('#myTable tr:eq(0) td').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19bb72aa0c1df1ce537c2f51c8837043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc71a847d2d7e44356287dd83afa6b90/" rel="bookmark">
			.NET 2024 年 1 月更新｜.NET 8.0.1、7.0.15、.NET 6.0.26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Rahul Bhandari (MSFT)
排版：Alan Wang
今天，我们发布了 .NET 2024 年 1 月更新。这些更新包含安全性和非安全性改进。如果您还没有部署最新的 .NET 更新，您的应用程序将可能存在漏洞。
您可以下载适用于 Windows、macOS 和 Linux（x86、x64、Arm32 和 Arm64）的 8.0.1、7.0.15 和 6.0.26 版本。
安装程序和二进制文件：8.0.1 | 7.0.15 | 6.0.26发行说明：8.0.1 | 7.0.15 | 6.0.26容器镜像Linux 软件包：8.0.1 | 7.0.15 | 6.0.26发布反馈/问题已知问题：8.0 | 7.0 | 6.0 Windows Package Manager CLI (winget) 您现在可以使用 Windows Package Manager CLI (winget) 安装 .NET 更新：
安装 .NET 8 运行时：winget install dotnet-runtime-8安装 .NET 8 SDK：winget install dotnet-sdk-8更新现有安装：winget upgrade 有关详细信息，请参阅使用 Windows Package Manager CLI (winget) 安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc71a847d2d7e44356287dd83afa6b90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cbc3720d7ecec47b8babd228a15a7b9/" rel="bookmark">
			翻硬币-贪心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路： 其实这道题就是比较与给出的字符串的不同，翻转的时候，只需要考虑当前的一步就行；
代码： #include &lt;iostream&gt; using namespace std; string str1,str2; auto turnover(char s){ if(s=='*') return 'o'; else return '*'; } int main() { cin&gt;&gt;str1&gt;&gt;str2; int i,cnt=0,len=str1.length()-2; for(i=0;i&lt;=len;i++){ if(str1[i]!=str2[i]) str1[i]=turnover(str1[i]),str1[i+1]=turnover(str1[i+1]),cnt++; else ; } cout&lt;&lt;cnt; // 请在此输入您的代码 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b9e27b53ab38f79a105c0c643bc504c/" rel="bookmark">
			Mysql系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 MySQL设计表的三大范式是什么？ MySQL设计表时遵循的三大范式是关系型数据库设计理论中的基本规范，它们确保了数据在数据库中的存储结构合理、无冗余且一致。以下是三大范式的详细介绍：
第一范式（1NF：First Normal Form） 要求：
每个属性（列）都必须是不可再分的原子值。表中所有字段的值都是基本的、不可分解的数据项。 这意味着在一个关系型表格中，每一列的单元格都应该只包含一个值，而不能是多个值的集合或复合值。例如，地址不应该作为一个字段来存储，因为它可以被分解为街道、城市、省份等独立的部分。
第二范式（2NF：Second Normal Form） 要求：
数据表必须满足第一范式。表中的非主键字段完全依赖于整个候选键（通常是主键），而不是部分依赖。 换句话说，在第二范式中，不允许存在非主键列对部分主键的依赖。如果存在这种情况，需要将这部分非主键列单独拆分为一个新的表，并通过外键与原表关联。这样可以消除数据冗余并确保每个表都有明确的主题。
第三范式（3NF：Third Normal Form） 要求：
数据表必须满足第二范式。所有非主键字段之间不存在传递依赖关系，即没有任何一个非主键字段依赖于另一个非主键字段。 第三范式进一步消除了冗余数据，它规定任何非主键字段的信息都只能直接依赖于主键，不能通过其他非主键字段间接依赖于主键。如果存在这种传递依赖，则需要继续拆分表以达到3NF的要求。
总结来说，三大范式旨在减少数据冗余、提高数据一致性以及简化数据修改操作的复杂性。在实际数据库设计中，根据业务需求和性能考量，有时会适度地违反某些范式，如引入适当的冗余以提升查询效率，这需要设计者权衡规范化与性能之间的平衡。
2 MySQL的selete * 和seltet 全字段的区别？ MySQL中SELECT *和SELECT 全部字段名在查询结果上没有区别，它们都会返回表中的所有列数据。但二者在性能、可读性以及数据库设计原则上有以下几点差异：
性能影响：
SELECT *：MySQL服务器需要解析查询语句时确定*代表的所有字段，这可能会比直接指定字段名稍微多花一点时间。此外，如果表中有大量字段，而应用程序只需要其中一部分，那么使用SELECT *会增加网络传输的开销，因为返回了不必要的字段信息。SELECT 全部字段名：当明确列出所有字段名时，MySQL可以直接处理这些字段而无需额外解析步骤。尤其在大表中，只选择必要的字段可以减少I/O操作和网络传输量。 索引优化：
使用覆盖索引（Covering Index）的情况下，如果仅查询索引包含的字段，MySQL有可能直接从索引中获取所需数据，而不必访问实际的数据页，从而提高查询效率。但如果执行SELECT *，即使部分字段可以通过索引查找，其他非索引字段仍需回表查询，导致无法充分利用索引优化。 可读性和维护性：
SELECT *降低了代码的可读性，因为阅读者不能一眼看出具体查询哪些字段，增加了未来维护成本。明确写出每个字段名则提高了SQL语句的可读性，并且有助于保持代码整洁和明确。 表结构变更的影响：
当表结构发生变化（如添加或删除字段）时，使用SELECT *的代码可能不会反映出这种变化，导致预期外的行为。而在代码中明确列出字段，则可以避免因表结构变动带来的问题。 综上所述，在编写SQL查询时，除非确实需要表的所有字段，一般推荐明确列出所要查询的字段名称以提升性能和维护性。
3 MySQL的seletet *除了是全字段扫描外为什么慢？ MySQL的SELECT *语句之所以在某些情况下执行较慢，主要是因为以下几个原因：
数据传输量大：
当查询表中的所有字段时，数据库需要将所有列的数据从磁盘读取到内存，并通过网络发送给客户端。如果表结构中有大量字段或者字段值占用空间较大（如文本、二进制数据等），这会显著增加网络传输和内存使用，特别是在带宽有限或内存资源紧张的情况下。 索引利用率低：
如果查询中没有明确指定索引字段，即使表中有适合当前查询的索引，也无法利用索引来加速查询。由于索引通常只包含部分字段（尤其是主键和唯一索引），因此全字段扫描不会直接利用索引提高查询速度。 I/O操作成本高：
在大数据量的表中，全字段扫描意味着对表进行全表扫描，可能导致大量的磁盘I/O操作，尤其当数据无法全部加载到内存时，频繁的磁盘访问会使查询响应时间大大增加。 无谓的计算开销：
对于存储过程、触发器或者其他后续处理来说，可能只需要其中一部分字段，但SELECT *却返回了所有字段，导致不必要的计算和处理。 未优化的查询计划：
数据库优化器可能无法提供一个最优的查询计划，因为它不能针对未知的具体列做出最佳选择。 缓存效率较低：
查询结果缓存通常基于SQL语句和所涉及的具体列来实现。SELECT *与具体列出列名的查询相比，在缓存匹配上的效率可能会降低，因为相同的表查询不同列集可能会产生不同的缓存项。 为了提高查询性能，应尽量避免在生产环境中使用SELECT *，除非确实需要获取所有字段信息。推荐的做法是根据实际需求指定要查询的列，同时结合适当的索引策略以减少不必要的I/O和CPU开销
4 MySQL如何做优化？ MySQL数据库优化涉及多个层面，包括但不限于以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b9e27b53ab38f79a105c0c643bc504c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74b0d372ffc66b8a947decf5ab398d9/" rel="bookmark">
			WPS JS宏的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * aa Macro */ function aa() { var strTest; var mySheet; strTest = "testaaaa"; mySheet = Worksheets.Item("Sheet2"); mySheet.Cells.Item(1,1).Value2 = strTest; // Worksheets.Item("Sheet2").Cells.Item(1,1).Value2 = "aaa"; alert("ok"); } 官方文档：WPS 开放平台
https://open.wps.cn/docs/client/wpsLoad
/** * aa Macro */ function aa() { var nBookCount; var nBookIndex; var sheetTemp; var strText; nBookCount = Workbooks.Count; for(nBookIndex = 1; nBookIndex&lt;= nBookCount; nBookIndex++) { //判断是否有第二张表，如果只有一张工作表，则添加一个 if(Workbooks.Item(nBookIndex).Worksheets.Count==1) { Workbooks.Item(nBookIndex).Worksheets.Add(); } //每个工作簿第二张表，A1单元格，写上序号 strText = "这是第" + nBookIndex.toString() + "表"; Workbooks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d74b0d372ffc66b8a947decf5ab398d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/addb80c8487835f890a91bef1af9be59/" rel="bookmark">
			【Pytorch 第二讲】 如何遍历 或者查看Model权重/参数/tesnsor_size/dict_names
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for (name, param), (key, value) in zip(network.named_parameters(),network.state_dict().items()): print(f"{name} Tensor size: {param.size()} {key} Tensor size: {value.size()}") print("\nParameter details:") State_dict keys:
patch_embed.conv_down.0.weight Tensor size: torch.Size([64, 3, 3, 3])
patch_embed.conv_down.1.weight Tensor size: torch.Size([64])
Parameter details: patch_embed.conv_down.1.bias Tensor size: torch.Size([64])
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6ececaba5758de6d82df89ec1fce72/" rel="bookmark">
			【Linux】 开始使用 gcc 吧！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 1 认识gcc2 背景知识3 gcc 怎样完成 ？3.1 预处理预处理^条件编译 3.2 编译3.3 汇编3.4 链接 4 函数库5 gcc 基本选项Thanks♪(･ω･)ﾉ谢谢阅读下一篇文章见！！！ 1 认识gcc 我们在windows环境和macos环境里都有功能强大的集成开发环境（IDE）供我们使用
，但是在Linux中我们如何编译运行我们的代码呢？这里就需要使用gcc / g++ 了。
2 背景知识 在学习使用gcc之前，我们需要了解代码的编译过程(可以看文章: 编译与链接)：
预处理 （进行宏替换，去注释，头文件展开等）编译（将 C语言 转换为 汇编语言 ）汇编（将 汇编语言 转换 二进制目标文件）链接 （形成可执行程序） 3 gcc 怎样完成 ？ 了解了上述背景知识，我们需要通过gcc来帮助我们实现这四个步骤，让代码可以成功运行。
gcc [选项] 要编译的文件 [选项] [目标文件]
这一步指令就可以帮助我们得到可执行程序。效果如下：
我们接下来再来看具体每一步的操作如何实现
3.1 预处理 预处理 预处理指令：
gcc -E 要预处理的文件 [选项] [目标文件]
一般我们得到的预处理文件使用.i后缀
我们可以验证一下预处理是不是完成去注释等操作：
可以看到经过预处理之后，我们的代码变成了近千行，这就是对头文件进行的引用展开（去注释后），展开宏定义的效果。
^条件编译 先引入一个问题，一个产品的不同版本（个人版 社区版 专业版）需要维护几个文件？？？
答案是： 一个
条件编译就是实现这个的重要方法；
通过条件编译我们就实现了对于一个代码的不同版本实现！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6ececaba5758de6d82df89ec1fce72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf4bc208c6c41a137d21becbe8a9682/" rel="bookmark">
			2024年，40个张家口数据中心重点项目公示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，张家口市发改委公示张家口市2024年市重点建设项目计划（第一批）名单。共270个项目，其中，建设项目20项，续建项目90项，新开工项目70项，前期项目90项。这些重点项目中包含数据中心项目高达40个。
2022年2月，张家口地区被设立为枢纽数据中心集群，作为全国一体化算力网络京津冀枢纽节点的重要组成部分，该地区逐步形成以怀来大数据产业基地、张北云计算基地等为核心的数据产业集聚区，已成为全国大数据产业发展速度最快的地区之一。据公开数据，2023年，河北地区数据中心项目审批通过超过50个，其中30多个落地在张家口怀来地区。张家口集群城市地区由于自身资源优势，成为环京地区热点区域。
在市场需求方面，随着云计算、人工智能等技术的广泛应用，张家口地区的数据中心市场需求呈现出快速增长的态势。特别是随着数字政府、智慧城市等项目的推进，政企客户对数据中心的算力、存储和安全性等方面的需求不断提升。
在市场供给方面，张家口地区的数据中心市场竞争较为激烈。除了本土企业外，还有阿里、合盈、秦淮、电信、百度等多家国内知名数据中心服务商在该地区布局。这些服务商在基础设施建设、技术研发、服务品质等方面展开激烈竞争，推动了整个行业的快速发展。
未来，张家口地区的数据中心市场仍将保持快速增长的态势。按照《张家口数据中心集群建设方案》，到2025年，张家口市将形成海量规模数据存储和大规模数据“云端”分析处理能力，建成京津冀枢纽核心区和绿色集约创新发展示范区。到2025年，新增标准机柜55万架，总量达到70万架；算力规模达到15EFlops；可再生能源使用率达到70%以上；可调度算力占总算力的比重超50%。同时，随着AI等新兴技术的普及，算力市场的需求还将进一步细分，个性化服务将成为竞争的关键。
“
以下是张家口市2024年市重点建设项目计划（第一批）名单公示中具体数据中心项目
一、续建项目（17项目）
8.河北宝宣数据科技有限公司宝之云华北基地项目
9.怀来斯达惠数据有限公司环首都·存瑞云计算产业基地建设项目（二期）
10.怀来斯达俊数据有限公司环首都·存瑞云计算产业基地建设项目（三期）
11.怀来斯达皓数据有限公司环首都·存瑞云计算产业基地建设项目（四期）
12.怀来斯达华数据有限公司秦淮数据总部基地三期建设项目
13.怀来斯达智数据科技有限公司环首都·桑园云计算产业基地建设项目（二期）
14.怀来斯达昕数据有限公司环首都·桑园云计算产业基地建设项目（三期）
15.怀来互联云科技有限公司世纪互联华北云计算中心基地
16.怀来合盈悦信数据科技有限公司怀来合盈金融数据科技产业园项目（二期第二阶段）
17.怀来合盈建信数据科技有限公司怀来合盈建信金融数据科技产业园项目（二期第三阶段）
18.怀来合盈智信数据科技有限公司怀来合盈智信金融数据科技产业园项目（二期第四阶段）
19.怀来合盈嘉信数据科技有限公司怀来合盈金融数据科技产业园项目（三期第一阶段）
20.怀来合盈博信数据科技有限公司怀来合盈金融数据科技产业园项目（三期第二阶段）
21.中国联合网络通信有限公司河北省分公司中国联通（怀来）大数据创新产业园项目
22.中国联合网络通信有限公司河北省分公司中国联通算力高效调度示范项目-怀来数据中心
23.中国电信集团有限公司智慧云基地怀来园区建设运营中心中国电信智慧云基地怀来园区项目
24.怀来智慧云港科技有限公司京北云计算软件研发中心项目
25.涿鹿万润数字科技有限公司数字经济产业示范园项目（首期）
二、新开工项目（5项）
1.河北幽算初字数据科技有限公司华章宣化算力枢纽产业基地(一区)项目
2.河北幽节尔字数据科技有限公司华章宣化算力枢纽产业基地(二区)项目
3.河北幽策珊字数据科技有限公司华章宣化算力枢纽产业基地(三区)项目
4.张北云联数据服务有限责任公司云联张北云数据中心项目
5.中国移动通信集团有限公司河北分公司中国移动京津冀（张家口）数据中心建设项目（一期）
三、前期项目（18项）
1.张家口聚数建设发展有限公司张家口人工智能智算中心项目
2.张家口智数建设发展集团有限公司数字服务产教融合职教中心项目
3.张家口智数建设发展集团有限公司人工智能技术研发中心项目
4.思一斐拓（张家口）科技有限公司飞拓低碳绿色大数据产业基地一期项目
5.辰思（张家口）科技有限公司飞拓低碳绿色大数据产业基地二期项目
6.张家口拓思游云信息技术有限公司飞拓低碳绿色大数据产业基地三期项目
7.张家口思驰信息技术有限公司飞拓低碳绿色大数据产业基地四期项目
8.河北幽苍思字数据科技有限公司华章宣化算力枢纽产业基地（四区）项目
9.河北幽章伍算数据科技有限公司华章宣化算力枢纽产业基地（五区）项目
10.河北幽繁陆算数据科技有限公司华章宣化算力枢纽产业基地（六区）项目
11.河北新新瑞数字科技有限公司张家口新新瑞云计算数据中心项目
12.怀来合盈云璟诚数据科技有限公司合盈数据（怀来）科技产业园项目四期第一阶段项目
13.怀来合盈云融诚数据科技有限公司合盈数据（怀来）科技产业园项目四期第二阶段项目
14.怀来合盈云立诚数据科技有限公司合盈数据（怀来）科技产业园项目四期第三阶段项目
15.怀来合盈云康诚数据科技有限公司合盈数据（怀来）科技产业园项目五期第一阶段项目
16.怀来合盈云锐诚数据科技有限公司合盈数据（怀来）科技产业园项目五期第二阶段项目
17.怀来合盈云佳诚数据科技有限公司合盈数据（怀来）科技产业园项目五期第三阶段项目
18.河北数速数据技术有限公司天汇智算中心项目
| 文章来源：中国IDC圈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9b7464a0ea81c09d69b38c1f1927d0/" rel="bookmark">
			EWOK报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
ERROR: cannot launch node of type [ewok_simulation/ewok_simulation]: Cannot locate node of type [ewok_simulation] in package [ewok_simulation]. Make sure file exists in package path and permission is set to executable (chmod +x)
ERROR: cannot launch node of type [ewok_simulation/trajectory_replanning_example]: Cannot locate node of type [trajectory_replanning_example] in package [ewok_simulation]. Make sure file exists in package path and permission is set to executable (chmod +x)
ERROR: cannot launch node of type [robot_state_publisher/robot_state_publisher]: robot_state_publisher
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f9b7464a0ea81c09d69b38c1f1927d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1d4b30c2daa3918a1fe817957065960/" rel="bookmark">
			C&#43;&#43; day2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思维导图
封装一个矩形类
#include &lt;iostream&gt; using namespace std; class Rect { private: int height; int width; public: void init(int w,int h) { width = w; height = h; } void set_w(int w) { width = w; } void set_h(int h) { height = h; } void show() { cout &lt;&lt; "周长为：" &lt;&lt; (width+height)*2 &lt;&lt; endl; cout &lt;&lt; "面积为：" &lt;&lt; width * height &lt;&lt; endl; } }; int main() { Rect s1; s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1d4b30c2daa3918a1fe817957065960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141d0a5d5b13689b4889f4e30daf94db/" rel="bookmark">
			3d gaussian splatting介绍整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3D 高斯分布是用于实时辐射场渲染的 3D 高斯分布中描述的一种光栅化技术，它允许实时渲染从小图像样本中学习到的逼真场景。
paper
github
本文翻译整理自：
blog: Introduction to 3D Gaussian Splatting
DDPMs - Part 2
给出一些2D图片，用colmap得到稀疏 (SfM) 点，可重建出逼真的3D场景。
3DGS的核心是光栅化技术。
这类似于计算机图形学中的三角形光栅化，用于在屏幕上绘制许多三角形。
图片来自blog
但是，它不是三角形，是高斯。
这里补充一些高斯相关：
正态分布 多元正态分布 协方差 协方差矩阵 每个元素(i, j) 定义了向量的两个随机变量的协方差。
而且对角线上的元素
下面看下两个随机变量负协方差，0协方差，正协方差时的分布
这是负协方差 3维看上去的效果，从顶上看就是上面的左图，从侧面看是高斯分布。45度更加平坦。
各向同性高斯 一个例子：
回到3D高斯，既然是3D，那就是3个变量（x, y, z)
它由以下参数描述：
位置：所在的位置 (XYZ)
协方差：如何拉伸/缩放（3x3 矩阵）
颜色：它是什么颜色（RGB）
Alpha : 透明度 (α)
3个的高斯叠加在一起的效果：
那么700万高斯叠加的效果呢。
运行步骤：
1.运动结构
第一步是使用运动结构 (SfM) 方法从一组图像中估计点云。这是一种从一组 2D 图像估计 3D 点云的方法。这可以通过COLMAP库来完成。
2.转换为高斯分布
接下来，每个点都转换为高斯分布。这对于光栅化来说已经足够了。然而，只能从 SfM 数据推断位置和颜色。为了学习产生高质量结果的表示，需要对其进行训练。
3.训练
训练过程使用随机梯度下降，类似于神经网络，但没有layers。训练步骤为：
使用可微分高斯光栅化将高斯光栅化为图像（稍后详细介绍）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/141d0a5d5b13689b4889f4e30daf94db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef7be75ae0b706f5c3e781dc629ec24/" rel="bookmark">
			AIGC（MLLM、VLM、LLM、SD）系列——论文解读目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		涉及面广：多模态生成模型——MLLM （ 目前集中在视觉语言模型——VLM）、大语言模型——LLM、生成模型（SD系列）、对比学习的经典模型（CLIP系列）。
持续更新：对于已经完成解读的会附上链接（有的会在一些场景做尝试，也会附上链接供大家快速参考结果），准备写的会备注筹备中。
适宜人群：节省大把时间，快速定位需要的部分，适合学生、入门AIGC者和从业者作为笔记检索使用。
RAM 论文题目：Recognize Anything: A Strong Image Tagging Model
关键词：RAM、属性识别、多标签分类、解读
论文解读：RAM（recognize anything）—— 论文详解-CSDN博客
应用测试：RAM（recognize anything）—— 项目使用——调整阈值（获得置信度）_from ram.models import ram-CSDN博客
RAM++ 论文题目：Open-Set Image Tagging with Multi-Grained Text Supervision
关键词：RAM++、RAM plus plus、属性识别、多标签分类、open set、解读
论文解读：RAM++（recognize anything++）—— 论文详解-CSDN博客
应用测试：暂同 RAM（recognize anything）—— 项目使用——调整阈值（获得置信度）_from ram.models import ram-CSDN博客
OR as Next Token Prediction 论文题目：Object Recognition as Next Token Prediction
关键词：属性识别、多标签分类、open set、解读
论文解读：VLM 系列——Object Recognition as Next Token Prediction——论文解读-CSDN博客
应用测试：暂无
CLIP 论文题目：Learning Transferable Visual Models From Natural Language Supervision
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ef7be75ae0b706f5c3e781dc629ec24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33891469bab0c3cb15f251f0d04ef30/" rel="bookmark">
			【翻译】基于半监督联邦学习的物联网入侵检测方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【翻译】基于半监督联邦学习的物联网入侵检测方法 《Semisupervised Federated-Learning-Based Intrusion Detection Method for Internet of Things》论文翻译
Semisupervised Federated-Learning-Based Intrusion Detection Method for Internet of Things | IEEE Journals &amp; Magazine | IEEE Xplore
文章目录 【翻译】基于半监督联邦学习的物联网入侵检测方法Introduction相关工作A. 基于 DL 的 IDSB. 基于 FL 的 IDS 背景A. Baseline 1: FL 方案B. Baseline 2: FD 方案C. Baseline 3: DS-FL 方案 建议的 SSFL 方案A. 基于 CNN 的基线模型B. Proposed SSFL Scheme1）训练分类器：2）训练鉴别器：3）过滤和上传：投票和广播： 实验结果A. 数据集的描述B. 数据预处理1）数据分区：2）归一化：3）Dimensionalization: C. 实验设置1）实验环境：2）实施细节：3） 评价指标： D. 用于入侵检测的 SSFL 的检测性能E. 所提出的 SSFL 方法的通信效率F.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33891469bab0c3cb15f251f0d04ef30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7fc12cd2c46a26076dd3cfe362d52c/" rel="bookmark">
			错误票据-蓝桥杯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路： 其实只是排序一下，然后遍历，如果两个值差2，则输出两个值的平均数，如果两个数差值为0 ，那么则这个值就是重复的值 代码： #include &lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n; cin&gt;&gt;n; vector&lt;int&gt;a; while(n--){ int c; while(cin&gt;&gt;c){ a.push_back(c); if(cin.get()=='\n') break; } } int i; sort(a.begin(),a.end()); int b,d; for(i=1;i&lt;=a.size()-1;i++){ if(a[i]-a[i-1]==2) b=a[i]-1; if(a[i]-a[i-1]==0) d=a[i]; } cout&lt;&lt;b&lt;&lt;" "&lt;&lt;d; // 请在此输入您的代码 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd92b684d30d3d674e876310f1d5731/" rel="bookmark">
			HTML5和CSS3的新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML5的新特性主要是针对于以前的不足，增加了一些新的标签、新的表单和新的表单属性等
1，HTML5新增的语义化标签 &lt;header&gt; 头部标签
&lt;nav&gt; 导航标签
&lt;article&gt; 内容标签
&lt;section&gt; 定义文档某个区域（&lt;div&gt;）
&lt;aside&gt; 侧边栏标签
&lt;footer&gt; 尾部标签
2，HTML5新增的多媒体标签 使用他们可以很方便的在页面中嵌入音频和视频，而不再去使用flash和其他浏览器插件
2.1 视频：&lt;video&gt; 语法：
&lt;video src="文件地址" controls="controls"&gt;&lt;/video&gt;
属性 值 描述
autoplay autoplay 视频就绪自动播放（谷歌浏览器需要添加muted来解决自动播放问题）
controls controls 向用户显示播放控件
width pixels（像素） 设置播放器宽度
height pixels（像素） 设置播放器高度
loop loop 播放完是否继续播放该视频，循环播放
preload auto（预先加载视频） 规定是否预加载视频（如果有了autoplay 就忽
none（不应加载视频） 略该属性）
src url 视频url地址
poster imgurl 加载等待的画面图片
muted muted 静音播放
2.2 音频：&lt;audio&gt; 语法：
&lt;audio src="文件地址" conrtols="controls"&gt;&lt;/audio&gt;
属性 值 描述
autoplay autoplay 音频就绪后自动播放
controls controls 向用户显示播放控件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd92b684d30d3d674e876310f1d5731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e8f358d95d0381513f3122315d4bc8/" rel="bookmark">
			android 相机预览数据两个 GL_TEXTURE_EXTERNAL_OESS和GL_TEXTURE_2D类型的数据应用场景，以及同时渲染的原因和关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相机哪些功能可用GL_TEXTURE_2D类型的数据渲染？
在Android的相机预览中，可以使用GL_TEXTURE_2D类型的数据来渲染以下功能：
界面元素：应用程序可以使用GL_TEXTURE_2D类型的纹理来渲染界面元素，例如按钮、文本框、标签等。这些界面元素可以与相机预览画面进行叠加或组合，以提供更加丰富和个性化的用户界面。图形效果：使用GL_TEXTURE_2D类型的纹理可以执行各种图形效果，例如色彩调整、滤镜、叠加、动态模糊等。这些效果可以通过对相机预览数据进行处理和渲染来实现，以提高预览画面的视觉效果和艺术感。动态内容：应用程序可以使用GL_TEXTURE_2D类型的纹理来渲染动态内容，例如动画、粒子效果等。这些动态内容可以通过对纹理数据进行编程和着色来实现，以增强预览画面的互动性和视觉表现力。 需要注意的是，使用GL_TEXTURE_2D类型的纹理来渲染相机预览数据可能会对性能产生一定的影响，因为这种类型的纹理需要进行额外的格式转换或拷贝操作。相比之下，使用GL_TEXTURE_EXTERNAL_OES类型的纹理可以直接从SurfaceTexture中获取数据，更加高效。因此，在实际应用中，应该根据具体的需求和性能要求选择适合的纹理类型来处理和渲染相机预览数据。
相机哪些功能可用GL_TEXTURE_EXTERNAL_OES类型的数据渲染？
在Android的相机预览中，GL_TEXTURE_EXTERNAL_OES类型的纹理主要用于处理从相机预览获取的实时视频流。这种类型的纹理可以直接从SurfaceTexture中获取数据，因此可以提供高效的视频处理和渲染性能。
具体来说，以下是一些可以使用GL_TEXTURE_EXTERNAL_OES类型纹理渲染的相机功能：
实时预览：GL_TEXTURE_EXTERNAL_OES类型的纹理可以用于渲染相机预览的实时视频流。应用程序可以使用这种类型的纹理来获取相机采集的图像数据，并在界面上实时显示预览画面。视频录制：在视频录制过程中，可以使用GL_TEXTURE_EXTERNAL_OES类型的纹理来渲染录制帧。这种方式可以避免将每一帧数据拷贝到应用程序缓冲区中，从而减少了CPU和GPU之间的数据传输，提高了视频录制的效率。图像处理和增强：对于需要进行图像处理和增强的相机功能，例如色彩校正、滤镜、美颜等，可以使用GL_TEXTURE_EXTERNAL_OES类型的纹理来获取原始图像数据。这种类型的纹理可以直接从相机硬件获取数据，避免了额外的格式转换或拷贝操作，提高了处理效率。 需要注意的是，由于GL_TEXTURE_EXTERNAL_OES类型的纹理是特定于Android的，因此在其他操作系统上可能无法使用。此外，使用这种类型的纹理需要考虑到兼容性和性能问题，特别是在低性能设备上可能会影响预览和录制的流畅度。因此，在实际应用中，应该根据具体的需求和性能要求选择适合的纹理类型来处理和渲染相机预览数据。
同时渲染的原因和关系：
在Android的相机预览中，同时使用GL_TEXTURE_EXTERNAL_OES和GL_TEXTURE_2D类型的纹理数据可能是由于以下原因：
不同的使用场景：GL_TEXTURE_EXTERNAL_OES类型的纹理主要用于处理从相机预览获取的实时视频流，它可以提供高效的视频处理和渲染性能。而GL_TEXTURE_2D类型的纹理则可以用于处理各种2D图像数据，例如界面元素或图形等。兼容性和可用性：由于不同的设备和GPU可能支持不同的纹理类型，因此同时使用两种类型的纹理可以确保应用程序在各种设备和GPU上都能正常工作。灵活性和扩展性：使用两种类型的纹理可以增加应用程序的灵活性和扩展性。例如，在某些情况下，可以使用GL_TEXTURE_EXTERNAL_OES类型的纹理来渲染实时视频流，而在其他情况下，可以使用GL_TEXTURE_2D类型的纹理来渲染其他2D图像数据。 综上所述，同时使用GL_TEXTURE_EXTERNAL_OES和GL_TEXTURE_2D类型的纹理数据是为了满足不同的使用场景、兼容性和扩展性的需求。这两种类型的纹理各有特点和优势，可以根据具体的需求选择适合的类型来处理和渲染数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02c0ba35df20d6d7eac7f009dc0cecc2/" rel="bookmark">
			Web 开发 6：Redis 缓存（Flask项目使用Redis并同时部署到Docker详细流程 附项目源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好！欢迎来到第六篇 Web 开发教程，今天我们将探讨一个非常重要的话题：Redis 缓存。作为一个互联网开发者，你一定知道在处理大量请求时，性能优化是至关重要的。而 Redis 缓存正是帮助我们提升系统性能的利器。Redis 是一个流行的开源内存数据库，它提供了强大的缓存功能。
在本教程中，我们将学习如何在PyCharm 中使用 Flask 进行 Web 开发，并利用 Redis 缓存来优化我们的应用程序。
什么是 Redis？ Redis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，它可以用作数据库、缓存和消息中间件。它支持多种数据结构，如字符串、哈希表、列表、集合和有序集合，并提供了丰富的操作命令。Redis 的特点是数据存储在内存中，因此具有非常高的读写性能。
为什么要使用 Redis 缓存？ 在 Web 应用中，数据库是最常用的数据存储方式。然而，频繁地从数据库中读取数据会导致性能瓶颈，从而影响用户体验。这时候，使用 Redis 缓存可以显著提升系统性能。
Redis 缓存的工作原理 Redis 缓存的工作原理非常简单明了。当用户请求某个数据时，首先检查 Redis 缓存中是否存在该数据。如果存在，则直接从 Redis 中获取数据并返回给用户，避免了频繁访问数据库的开销。如果数据不存在于 Redis 缓存中，则从数据库中读取数据，并将数据存储到 Redis 缓存中，以便下次请求时可以直接从缓存中获取。
缓存命中率 在使用 Redis 缓存时，我们关注的一个重要指标是缓存命中率。缓存命中率是指从缓存中获取数据的次数与总请求次数的比例。高缓存命中率表示大部分数据都可以从缓存中获取，系统性能较好。而低缓存命中率则意味着缓存的效果不佳，需要优化缓存策略或增加缓存的数据范围。
如何使用 Redis 缓存？ 使用 Redis 缓存的步骤如下：
安装和配置 Redis：首先，你需要在你的服务器上安装 Redis，并进行基本的配置。你可以在 Redis 的官方网站上找到安装和配置的详细指南。
选择缓存数据：根据你的应用需求，选择需要缓存的数据。通常，频繁读取且不经常变化的数据是最适合缓存的。
编写缓存逻辑：在你的应用程序中，编写缓存逻辑来处理数据的读取和写入。当需要读取数据时，首先检查 Redis 缓存中是否存在该数据，如果存在，则直接返回缓存数据；如果不存在，则从数据库中读取数据，并将数据存储到 Redis 缓存中。
设置缓存过期时间：为了避免缓存数据过期，你可以设置缓存数据的过期时间。当数据过期时，系统会重新从数据库中读取最新数据，并更新 Redis 缓存。
处理缓存更新：当数据发生变化时，你需要更新 Redis 缓存中的数据。这可以通过在数据更新的同时，更新 Redis 缓存来实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02c0ba35df20d6d7eac7f009dc0cecc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6e904dad5b0681ae31fa3ab2d79706/" rel="bookmark">
			MySQL（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四、事务 一、概念 对数据库的一次执行中有多条sql语句执行。这多条sql在一次执行中，要么都成功执行，要么都不执行。保证了数据完整性。MySQL中只有innodb引擎支持事务。
二、特性 事务是必须满足 4 个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务中多条sql要么都执行，要么都不执行，不执行的回滚到事务执行前状态。 隔离性：事务可以多个同时执行，要对多个事务进行隔离。
持久性：事务正常提交后，可以保证数据持久保存，即使宕机也不丢失。 一致性：原子性，持久性，隔离性都是为了保证一致性，保证数据是完整可靠的。 三、设置 默认情况下, MySQL 启用自动提交模式（变量 autocommit 为 ON）。
MYSQL 事务处理主要有两种方法： 1、用 BEGIN, ROLLBACK, COMMIT 来实现 BEGIN 开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认 2、直接用 SET 来改变 MySQL 的自动提交模式: SET GLOBAL / SESSION autocommit=0; 禁止自动提交 SET GLOBAL / SESSION autocommit=1;开启自动提交 查看 autocommit 模式 SHOW GLOBAL / SESSION VARIABLES LIKE 'autocommit'; 四、事务隔离级别 一、读未提交(read uncommitted)： 一个事务可以读取到另一个事务未提交的修改。这会带来脏读，幻读，不可重复读问题。 SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED 二、读已提交(read committed)： 一个事务只能读取另一个事务已经提交的修改。其避免了脏读，仍然存在不可以重复读和幻读问题。 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED 三、可重复读(repeatable read MySQL 默认隔离级别)： 同一个事务中多次读取相同的数据返回的是一样的。其避免了脏读和不可重复读问题，普通查询解决了幻读问题,如果在查询中添加 for update 语句, 会出现幻读问题.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b6e904dad5b0681ae31fa3ab2d79706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddcced4d3a7833ca21e6c85e81e15e24/" rel="bookmark">
			【C&#43;&#43;】list的模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言：1 节点类2 模拟实现list类2.1 成员变量2.2 初始化2.3 构造2.4 拷贝构造2.5 赋值重载2.6 析构2.7 交换、清理、返回元素个数、判空2.8 获取第一个节点数据和最后一个节点数据2.9 pos位置插入2.10 pos位置删除2.11 尾插、尾删、头插、头删2.12 迭代器遍历 3 正向迭代器类4 反向迭代器类5 全部代码list.htest.cpp 前言： list是带头双向循环链表，与vector的底层结构不一样，vector是连续的空间，list的每个节点是独立的空间。
模拟实现list主要有以下类：
struct ListNode//节点类 struct ListIterator//正向迭代器类 struct ReverseIterator//反向迭代器类 class list//模拟实现list类 1 节点类 每个节点都有它的指针域和数据域，因为是双向的，所以指针域有两个分别为前指针和后指针。同时写个构造函数，用来创建新节点。
template&lt;class T&gt; struct ListNode//节点类 { ListNode&lt;T&gt;* _prev; ListNode&lt;T&gt;* _next; T _val; ListNode(const T&amp; x = T()) :_prev(nullptr) ,_next(nullptr) ,_val(x) {} }; 使用类模板可以传任意类型。
2 模拟实现list类 2.1 成员变量 私有成员变量是链表的头，即哨兵位节点，类型是节点类指针类型，方便连接其他节点。
节点类的名字有点长，可以重命名简化：
typedef ListNode&lt;T&gt; Node; 成员变量：
private: Node* _head; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddcced4d3a7833ca21e6c85e81e15e24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f70a32a6cbb629b5d122e21716a8a9/" rel="bookmark">
			Oracle按日周月年自动分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、分区键
2、初始分区
3、周月年自动分区
4、按日自动分区表建表语句
与普通建表语句相比，分区表多了一些分区信息；
1、分区键 以下面销售明细表为例，以data_dt为分区键，NUMTODSINTERVAL(1, 'day') 按日分区
PARTITION BY RANGE (data_dt) INTERVAL (NUMTODSINTERVAL(1, 'day'))
2、初始分区 设置part_t01为初始的分区，可以根据实际需求设置初始分区的边界。
(PARTITION part_t01 VALUES LESS THAN(to_date('2020-01-01', 'yyyy-mm-dd')))
3、周月年自动分区 按其他周月年分区需要 替换 标黄部分。（前缀英文不一样注意区分）
PARTITION BY RANGE (data_dt) INTERVAL (NUMTODSINTERVAL(1, 'day'))
--按日分区 NUMTODSINTERVAL(1, 'day')
--按周分区 NUMTODSINTERVAL (7, 'day')
--按月分区 NUMTOYMINTERVAL(1, 'month')
--按年分区 NUMTOYMINTERVAL(1, 'year') 4、按日自动分区表建表语句 -- Create table CREATE TABLE sales_info ( data_dt DATE, prod_id VARCHAR2(50), prod_num VARCHAR2(50), prod_nm VARCHAR2(100), prod_color VARCHAR2(20), prod_size VARCHAR2(10), quantity_sold INTEGER, data_tm TIMESTAMP ) PARTITION BY RANGE (data_dt) INTERVAL (NUMTODSINTERVAL(1, 'day')) (partition part_t01 values less than(to_date('2020-01-01', 'yyyy-mm-dd'))); ; --按日分区 NUMTODSINTERVAL(1, 'day') --按周分区 NUMTODSINTERVAL (7, 'day') --按月分区 NUMTOYMINTERVAL(1, 'month') --按年分区 NUMTOYMINTERVAL(1, 'year') 【注】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f70a32a6cbb629b5d122e21716a8a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3fe039a985e1ca9a72f90526171f46/" rel="bookmark">
			x-cmd pkg | sqlite3 - 轻量级的嵌入式关系型数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介首次用户 技术特点竞品和相关产品sqlite 与 x-cmd进一步阅读 简介 sqlite3 是一个轻量级的文件数据库，体积非常小，提供简单优雅而功能强大的 sql 化的数据查询。
通常情况下，sqlite 指的是 SQLite 2.x 版本，而 sqlite3 指的是 SQLite 3.x 版本。相比于 sqlite ，sqlite3 拥有更多功能和改进，是当前广泛使用的版本，也是推荐的版本。
首次用户 使用 x sqlite3 即可自动下载并使用
在终端运行 eval "$(curl https://get.x-cmd.com)" 即可完成 x 命令安装, 详情参考 x-cmd 官网 x-cmd 提供1分钟教程，其中包含了 sqlite3 命令常用功能的 demo 示例，可以帮你快速上手 sqlite3 。
使用案例:
# 启用 sqlite3 x sqlite3 # 打开并使用 ex1.db 数据库文件 .open ex1.db # 查看当前使用的数据库 .database # 显示当前数据库中的所有表 .tables # 显示当前数据库中的所有表的结构 .schema # 将数据库内容呈现为 SQL .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa3fe039a985e1ca9a72f90526171f46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb6ef28e3ea57bf88c2db44ee0603a1/" rel="bookmark">
			【机器学习300问】18、正则化是如何解决过拟合问题的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我初次看见“正则化”三个字的时候，我简直头疼。在我的理解里“正则”还是Python中用在字符串处理的re正则库呢！怎么加一个“化”字就看不懂了！听我给你慢慢道来。
一、正则化中的“正则”是个啥玩意儿？ 正则化（Regularization）中的“正则”这个词来源于英文术语“regularization”，直译成中文即“规范化”或“正规化”。这里的“正则”并不是指严格意义上的“规则”或“规律”，而是指通过一定的数学手段规范或约束模型的学习过程，使其更加稳健、简洁并且避免过拟合。
所以正则化就是规范和约束模型参数的意思。
二、怎么去理解正则化能够解决过拟合（感性上）？ 还是用我一贯的做法，先看看例子和图片从直觉上感受一下正则化解决过拟合的直观体验。接下来文章中以房价预测任务+线性回归模型+均方误差损失函数+L2正则化（又叫权值缩减）为例。
（1）未使用正则化手段出现过拟合时 可以从图中明显的看到出现了过拟合现象，虽然模型（也就这条线）很好的穿过了所有点（也就是模型在训练集上表现很好）但显然如果用一个没见过的数据来进行预测的话结果会很差（也就是模型在测试集上表现很差），因为房价随着房子面积肯定是增长的而图中模型最后都下降了。
（2）使用了“轻微的”正则化后 使用正则化后可以发现这条线明显比之前要平滑，没有那么的抖动了。
（3）使用了“合适的”正则化后 假设正确的拟合模型是对数函数曲线，但上图这个模型曲线虽然还有些扭曲但比一开始已经平滑很多了。
三、怎么去理解正则化能够解决过拟合（理性上）？ 在L2正则化中，模型的目标函数被修改为原始损失函数与模型参数的L2范数（即参数平方和）的和，加上一个正则化系数λ的权重。目标函数可以表示为：
其中，L(θ) 是原来的损失函数，如均方误差，θ 是模型的参数向量（之前我都是写的w和b这里用θ统称他们），λ 是正则化强度（正则化系数），它控制着正则化项的影响力。 在梯度下降的过程中，模型参数θ的更新规则会受到正则化项的影响。当计算损失函数关于参数θ的梯度时，正则化项会产生额外的梯度贡献，这部分梯度指向使参数θ减小的方向。对于每一个参数，其梯度不仅受到原始损失函数的影响，还受到正则化项的影响，即：
在更新参数时，如果某个参数的绝对值已经比较大，那么正则化项会使该参数的梯度增加，进一步推动参数朝着减小方向更新。特别是对于较大的参数，正则化项的效应更加明显，会强制这些参数变得更小。
这样一来，通过正则化，模型学会了“谦虚”，即不赋予任何单个特征过大的权重，从而减少了模型对个别特征的过度依赖，增强了模型对未知数据的泛化能力，有效地缓解了过拟合现象。同时，由于参数受到了限制，模型的整体复杂度也会相应降低，这也是正则化能够抑制特征权重过大的机制。
四、正则化强度参数非常重要 正则化确实会导致模型的所有参数（特征权重）在某种程度上变小，但不同的特征权重缩小的程度可能并不相同。这是因为正则化是通过对损失函数添加了一个对参数的惩罚项，使得在训练过程中不仅关注原始损失的最小化，同时也关注参数的大小。
在L2正则化中，参数的梯度更新时会受到正则化项的影响，这会促使所有的参数向更小的值收缩，但是收缩的程度取决于：
参数原有的大小：原本较大的参数受到正则化的影响更为显著，它们会被更多地减小。正则化强度（λ）：λ值越大，正则化对参数的影响越强，所有参数都会更大幅度地减小。 正则化强度（通常表示为 λ）是一个至关重要的超参数，它决定了正则化项在优化过程中对模型参数的约束力度。选择合适的正则化强度直接影响到模型的泛化能力，即模型在未见过的新数据上的表现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54620efd448eb1a6a7ffb3d2e70057d/" rel="bookmark">
			kafka生产者与消费者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 pom.xml依赖包二、yml配置文件三、消费者四、生产者总结 提示：这里可以添加本文要记录的大概内容：
一、 pom.xml依赖包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; 二、yml配置文件 spring: kafka: listener: concurrency: 3 #线程数 ack-mode: manual_immediate type: batch #批量 bootstrap-servers: 192.168.1.214:9092 # 生产者配置 producer: # retries: 1 # 消息发送重试次数 batch-size: 16384 buffer-memory: 33554432 value-serializer: org.apache.kafka.common.serialization.StringSerializer key-serializer: org.apache.kafka.common.serialization.StringSerializer #消费者需配置，生产者不需要 consumer: key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.apache.kafka.common.serialization.StringDeserializer group-id: goodwe-touring-car-groupid-1 auto-offset-reset: earliest #latest, earliest, none enable-auto-commit: false auto-commit-interval: 5000 max-poll-records: 1000 #批量消费最大数量 topic: portable_performance #自定义项目run, 运行kafka. custom: run: kafka: true ############################### 参数说明 ######################################### consumer: # 自动提交的时间间隔 在spring boot 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a54620efd448eb1a6a7ffb3d2e70057d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971694dd60031889099844b6fe6ce1fe/" rel="bookmark">
			帆软MVP专访 | BI佐罗：用数据分析不断拆开商业运作的“黑盒”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据产业创新服务媒体
——聚焦数据 · 改变商业
近日，2023帆软MVP（Fanruan Most Valuable Professional）获奖名单公布，全球知名零售集团数据分析师、自媒体大咖BI佐罗获此殊荣。
帆软最具价值专家，简称帆软MVP（Fanruan Most Valuable Professional )，是帆软颁发给产品用户专家的一项荣誉认证，以感谢他们为帆软产品的发展所做出的卓越贡献。
帆软MVP计划上线后，收到了非常多优秀数据分析师的报名，来自各行各业，都是深耕在业务中的数据分析从业者，他们用自己的专业知识、技能和热情，帮助广大用户解决问题，推动技术交流，助力行业发展。他们的无私奉献和分享，为帆软产品生态的发展和用户的成长提供了强大的支持！全球知名零售集团数据分析师、自媒体大咖BI佐罗也是其中一员，并且从众多候选人中脱颖而出，获得2023帆软MVP荣誉奖励。
BI佐罗是数据分析的科班出身，毕业后一直从事数据分析相关的工作，从业的十几年间，BI佐罗从最开始的技术岗位做起，后来逐渐偏向企业业务价值本身以及企业的商业模式，正是由于在大公司、大平台的历练和个人持之以恒的积累，使得BI佐罗既懂得数据分析师的成长路径，又深谙企业数字化转型的方向。目前，BI佐罗既是很多数据分析师的教练，又为企业提供数字化转型的咨询服务，在C端和B端同时发力。
C端和B端同时发力是不少人梦寐以求的事业发展方向，但是这对于个人或企业的专业能力要求很高、对实践经验考验非常大。拿数据分析来说，处于不同岗位、位置的人而言，看到的、想到的、考虑的事情完全不一样，基层的数据分析师可能更多的考虑技术实现，高层的管理者考虑的是通过数据分析发现业务短板、战略转型机会……
作为企业数字化转型顾问，BI佐罗如何通过商业数据分析理解商业的本质呢？企业管理者是否应该依赖各类数据分析报表做决策？如何看待ChatGPT等人工智能大模型对这个岗位的冲击呢？带着这些问题，数据猿专访了BI佐罗。
打开商业运作的“黑盒”
说起用商业数据分析理解商业的本质，BI佐罗有自己的一套逻辑，他借用卡耐基梅隆大学在软件工程领域中的软件能力成熟度模型，进而形成了自己的一套考察企业能力成熟度的体系。在这个体系中，他将企业能力的成熟度分为如下五个阶段。
第一个阶段是初始期，初始期一般是企业的最开始的时期，一家公司只要能赚钱、只要能活着，就是企业最开始的形态，这个阶段企业的商业数据开始不断的积累。
第二个阶段是可重复期，在初始期，随着业务的发展，企业会发现有越来越多重复的客户或者重复的交易类型，把这些可重复的客户或者交易管理好、服务好，就是该阶段的重要任务。
第三个阶段是标准期，在积累了越来越多的客户和交易之后，企业开始运用标准化的流程、规范等，使企业的产品、服务、交易过程等到达标准化和确定性。这就是在数字化系统不发达时，很多企业倡导的“凡事有流程、每个环节有标准”。
第四个阶段是可量化期。随着数字化办公系统和信息化的逐渐深入，企业的很多业务数据、运营数据、财务数据，甚至企业的管理，都开始进入了数字化，企业所有的商业运转都进入了可量化的时期。
第五个阶段是持续优化期，这个时期，企业的运营人员可以从大规模的报表中解放出来，业务部门提出需求，运营部门可以直接在数字化平台上自动产生报表，自动化的过程极大提升了原来报表的制作效率，并提出新的业务需求重新循环。
从上述五个阶段来看，通过数据分析理解企业运行的本质主要是在第四阶段之后，当企业的运营和管理开始步入可量化期后，企业管理者就可以根据报表，清晰的看到营收、利润、成本等核心项目的来源以及变化情况。众所周知，这些报表跟数据指标的拆解有很重要的关系，比如营收就可以拆解为客单价、进店关注人数、转化率、复购率等因素相乘，所谓围绕着这些因素，企业管理者和不同的运营部门之间，又可以构建指标，从而促进核心项目的增长，由此，便形成企业的数据指标体系。
当然，现有的报表并非数据分析的终点，而是新的起点。BI佐罗认为，由于企业在不同阶段、不同发展期，其核心的目标和关注点并不完全相同，在不同的战略阶段内，企业会不断订立新的“北极星”指标，对应的数据指标体系也需要不断的升级和改进。
由此可见，商业数据分析师可以通过企业的数据报表，分析当下企业运作和战略的内在逻辑，建立完善的指标体系，将企业运转的情况尽快的展现出来，为企业未来的发展、转型等变革提供方向支持。那商业数据分析师或者企业运营者如何选择数据分析工具呢？帆软的产品又有哪些亮点呢？
帆软的顺势而为
在实际的数据分析过程中，很多企业用的最多的工具可能就是Excel了，国外用微软的excel，国内的产品就是WPS，也有很多数据分析和商业智能的软件工具，比如：微软的Power BI、帆软的FineBI等，都说“工欲善其事，必先利其器”。企业究竟该如何选择这些工具呢？BI佐罗认为，每个工具都有自身的适应环境和场景，并没有绝对的好坏，也没有特别的短板。数据分析师在解决问题时，往往是根据问题和场景的需要做选择，而非根据单一的工具应对所有场景。
在很多人的印象中，总有一种“外来的和尚好念经”的偏见，其实在BI的工具上，帆软的BI产品更了解中国的市场需求，同时在功能上，也会有独特的优势。作为行业的“老兵”，基本市面上的主流工具都用的BI佐罗，在使用FineBI时也有不少功能让他感到亮眼。
首先是个人版与企业版完全一样，不需要重新适应。个人使用的产品与企业版本的产品完全一样，自己沉淀、积累的工具等，可以很快的应用到企业中，降低了使用者的门槛和学习成本。
其次，帆软的FineBI中有很多行业案例、职能案例和功能案例，这些案例可以帮助运营人员参考同行业的例子，也可以看相同功能下的多种花样，这个功能实际上给使用者提供了快速学习和入手的方式，借鉴他人的经验，站在别人的肩膀上发展。
第三是函数，在FineBI中，强大的函数功能使得它成为“最亮的仔”，尤其是动态生成维度的def函数。BI佐罗认为，函数功能的出现，其实是给用户提供了一种可能性，使得他们可以探索高级自助商业智能，这个功能是FineBI的核心特色。
当然，除了上面的三个亮点，帆软产品的亮点还有很多，比如包括地图在内的辅助资源，使得产品在功能细节上非常实用、易用。
当被问到为什么选择申请帆软MVP时，他说了三方面的原因。首先，FineBI是一套有原创思想的国内领先BI产品，能够为该产品的进化和演化做出贡献并帮助更多国人使用自主研发的BI是一件有巨大意义的事情；其次，商业智能工具的使用是极度灵活的，如何更好地利用技术工具的最佳方法的探索可以帮助的更多企业和个人，是有意义和快乐的事；第三，将FineBI的技术能力与社区更多企业个人的实际问题和工作融合，升华出更多创新，也是很有意义和价值的。
因此，他非常愿意在帆软，尤其是FineBI的生态中，做出深度研究和帮助支持更多个人与企业，同时获得个人的成长。在优秀的平台上成就学员、成就客户企业、成就自己，同时也成就了平台本身，或许这就是BI佐罗内心不断前行、积极分享的动力来源。
理解数据、走出数据
在拥有了强大的产品和工具之后，企业管理者对于数据的理解越来越深入，但同时也会越来越依赖数据，一旦对数据分析产生依赖，也容易影响到企业的决策。最近10年，企业的数字化或数智化变革越来越深入，除了互联网企业外，越来越多的传统行业也开始数字化转型，企业在完善了数字化的系统、技术之后，管理者开始体验到数据报表辅助决策带来的重要性，很多管理者甚至对数据产生了依赖，任何决策都要看数据、分析数据，从数据出发定目标，公司的各个部门开始围绕着各自的指标运转，以求数字达到领导的满意。
不得不说，在数字化程度越来越高的企业中，各个部门的运营数据的确为管理者进行企业决策带来不少的便利，增加了决策的科学性，但是BI佐罗也提醒到，企业管理者需要“理解数据，走出数据”。
很多商业数据分析师都会强调数据分析的重要性，在真实的商业场景中，其实BI并非很重要。BI佐罗认为，一家企业的BI系统即使短时间内宕机，它实际上并不会给企业带来直接的损失，或者直接影响企业的业务运转，因此从这个角度看，BI系统本身并没有嵌入到企业经营中，它天生就是辅助管理者做决策。
而且BI系统非常有趣的是，虽然不涉及经营，但企业又不能没有它，因为它可以让企业管理者理解数据，可以更加清晰的让管理者看到企业发展背后的商业链条、各部门的运转情况，从而能从更高的位置俯看企业的经营。当然，BI系统能发挥多大的价值，更多的取决于使用者的水平，如果使用者的商业分析能力强，便可以让BI系统发挥更大的价值。
管理者在通过BI系统理解数据之后，接下来其实需要从数据中“走出来”。BI佐罗认为，企业的生意是被做出来的，不是被分析出来的。举例来说，临近年底，很多企业都会制定明年的目标，有的CEO可能会说根据去年前年数据的趋势，明年的目标应该定一个比较合理的目标，但真正的CEO会直接确定明年的目标，然后带头干，这个目标从BI的角度来看可能无法实现，因为通过BI的分析，这个目标不应该产生，但是企业管理者就是应该打破分析，目标应该是努力做到的。
因此，不难看出，BI系统对企业来说就是一个“副驾驶”，它的好处是可以在行驶过程中提供“导航”，但是它不具有人类本身的商业的洞察力和敏感度，管理者要控制数字，而不是被数字、数据、报表裹挟，商业本身是有风险的，风险越大，收益越大，而人最大的能力和智慧就是在于借助方法和工具驾驭风险、创造机会。
AI时代，数据分析师保住“饭碗”
除了B端企业在近几年的数字化转型过程中遇到不少难题之外，不少数据分析师自今年以来，也开始对岗位未来的发展充满迷茫和担忧。
最近一年，ChatGPT的“爆火”以及其他AIGC大模型的出现，让各行各业的从业者感受到“被取代”的压力。AIGC可以根据数据画图表、做分析、写代码等，效率极高。不少数据分析的从业者可能也会担心自己的工作未来会被取代，但是，BI佐罗认为，AIGC目前仍然是“副驾驶”，很难成为数据分析行业的“主驾驶”。
BI佐罗首先从数据的范畴出发，详细介绍了他的思考。他认为，大数据从广泛的角度可以分为三类：一类是以统计学、数理统计为基础的、具有连续性的科学数据，偏向于科学研究的范畴；第二类是机器的传感器、互联网为代表的产生的海量数据，这类数据更多的是从数据本身出发，分析和挖掘数据的特点，从而进行图像识别、音频识别、机器学习等研究，偏向于大数据的范畴；第三类是介于前两者之间，是重复发生的商业事件产生的数据，比如：一个个的订单数据、用户注册数据、库存数据等，基于这些结构化的数据分析是商业数据分析师的范畴。
从商业数据分析师所处理的数据范畴来看，数据之间的商业逻辑关联性非常强，它对分析者的逻辑思维、商业洞察要求较高，并非只是画图表。而AIGC本身的原理是一个大模型，它是根据文本做后面内容的预测或概率的计算，从而生成相关的内容。从这个底层逻辑看，除非天然存在某些数据可以训练它的逻辑、商业敏感性，否则AIGC很难取代商业数据分析师。目前来看，商业数据分析本身的逻辑链条越来越复杂，所以BI佐罗认为，AIGC很难取代商业数据分析师，但是它可以帮助分析师判断方向、判断逻辑。
换言之，商业数据分析师的核心竞争力并不仅仅是技术，更应该是商业逻辑的分析和洞察，而商业逻辑的洞察并非单纯从报表上观察，更重要的是从实践中不断积累、沉淀、升华，数据分析师只有更贴近业务本身，理解业务的复杂关系，不断的打造核心竞争力，才能不陷入工具，在行业和企业中保持领先；反之，仅仅流于表面的做做图，同环比，则真的存在保住“饭碗”的风险。
无论是数字化转型中的企业还是数据分析师，数据是基础，商业智能是工具，企业和个人真正需要做的是对商业、业务本身的不断深入理解和洞见，并在框架和方法之下选择工具组合，辅以达成商业目的。
文：赢家 / 数据猿
责任编辑：凝视深空 / 数据猿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54031a6cda4e7869a9b5b371504bd401/" rel="bookmark">
			java以SSL方式连ES
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先做准备工作，浏览器方式访问 ES7.X url https://127.0.0.1:8027 弹出用户名和密码
输入后在浏览器得到
{
“name” : “DTCNPEMS04”,
“cluster_name” : “cnp-es-cluster”,
“cluster_uuid” : “wb0So_FqQBOKqtXnsqofTg”,
“version” : {
“number” : “7.14.1”,
“build_flavor” : “default”,
“build_type” : “docker”,
“build_hash” : “66b55ebfa59c92c15db3f69a335d500018b3331e”,
“build_date” : “2021-08-26T09:01:05.390870785Z”,
“build_snapshot” : false,
“lucene_version” : “8.9.0”,
“minimum_wire_compatibility_version” : “6.8.0”,
“minimum_index_compatibility_version” : “6.0.0-beta1”
},
“tagline” : “You Know, for Search”
}
说明浏览器可以获得SSL证书，然后用户可以按用户名/密码访问
后续思路就是从浏览器导出证书（略过）,导入到JDK的security目录下，然后在代码里调用嵌入用户名和密码，SSL访问即可。
1） 假设浏览器导出证书为
2） 将证书转换为cer格式
openssl x509 -outform der -in es-devtest -out es-devtest.cer
3） 将证书导入到JDK的security目录下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54031a6cda4e7869a9b5b371504bd401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34e000681168fb81cff246bcf6747c68/" rel="bookmark">
			【Linux】开始使用 vim 吧！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 1 what is vim ？2 vim基本概念3 vim的基本操作 ！3.1 vim的快捷方式3.1.1 复制与粘贴3.1.2 撤销与剪切3.1.3 字符操作 3.2 vim的光标操作3.3 vim的文件操作 总结Thanks♪(･ω･)ﾉ感谢阅读下一篇文章见！！！ 1 what is vim ？ 我们先来了解 vi ，
vi/vim的区别简单点来说，它们都是多模式编辑器，不同的是vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。例如语法加亮，可视化操作不仅可以在终端运行，也可以运行于 x window、 mac os、windows。
vim相当于是vi的升级版， vim具有程序编辑能力，可以主动以字体颜色标识语法的正确性，方便代码编写 ，程序简单，编辑速度非常快
综上所述 这是一个老式的文字处理工具，但是功能很齐全，不仅是文本处理工具，还是一个程序编辑工具
最重要的是 vim 生态丰富，使用起来十分方便。
2 vim基本概念 vim具有主要有三个模式（vim具有非常多的模式）：
命令模式 底行模式 插入模式
1. 命令/正常模式 (Normal mode)： 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode 2. 插入模式 (Insert mode)： 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。该模式是使用的最频繁的编辑模式。 3. 末行模式(last line mode) 文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。 在命令模式下，shift+: 即可进入该模式。要查看你的所有模式：打开vim，底行模式直接输入 （我的vim配置过了，界面略有不同）
3 vim的基本操作 ！ 我们了解vim之后，下一步就要学习如何使用这个实用工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34e000681168fb81cff246bcf6747c68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2058315a6a50b6bd60343bf1b33aa2c4/" rel="bookmark">
			配置负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （1）准备两台 tomcat 服务器，一台 8080，一台 8081
（2）在两台 tomcat 里面 webapps 目录中，创建名称是 paga文件夹，在 page文件夹中创建页面 a.html，用于测试
在 nginx 的配置文件中进行负载均衡的配置 upstream myserver{ # ip_hash; server 192.168.56.10:8080; server 192.168.56.10:8081; proxy_pass http://myserver; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878c219a7c3c3c8b4a070dedf632c2fa/" rel="bookmark">
			C语言实现“空心”正方形图案输出的程序解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以利用循环结构和条件判断语句来绘制各种图形。下面，我将对一个通过while循环和嵌套for循环实现“空心”正方形输出的C语言代码进行详细解析。
#include &lt;stdio.h&gt; int main() { int a; while (scanf("%d", &amp;a) != EOF) { // 输入循环，直到遇到文件结束符EOF // 外层循环控制行数，即正方形的边长 for (int i = 0; i &lt; a; i++) { // 内层循环控制每行的列数，同样为正方形的边长 for (int j = 0; j &lt; a; j++) { // 使用条件判断语句来决定是否输出星号或空格 if (i == 0 || i == a - 1 || j == 0 || j == a - 1) { // 当位于正方形的边界（第一行、最后一行、第一列或最后一列）时，输出星号* printf("* "); } else { // 否则，在内部区域（非边界位置）输出空格，形成“空心”效果 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878c219a7c3c3c8b4a070dedf632c2fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815741e456372f70793cd5531a8566e5/" rel="bookmark">
			【UE5】 “Download Image”节点浅测：网上下载图片应用到材质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Download Image节点
下载图片下来直接用
要图片的网址
赋值给材质对象即可。
用法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f626afc89cad79c345557148da72ef04/" rel="bookmark">
			[docker] Docker镜像的创建以及Dockerfile的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Dokcer镜像的创建 创建镜像有三种方法，分别为基于已有镜像创建、基于本地模板创建以及基于Dockerfile创建。
1.1 基于现有镜像创建 （1）首先启动一个镜像，在容器里做修改 docker run -it --name web centos:7 /bin/bash #启动容器 ​ yum install -y epel-release #安装epel源 yum install -y nginx #安装nginx yum install -y net-tools #安装tools工具 nginx #启动服务 netstat -natp |grep 80 #查看端口是否开启 ​ docker ps -a #查看容器ID ​ （2）然后将修改后的容器提交为新的镜像，需要使用该容器的ID号创建新镜像 docker commit -m "new nginx" -a "xxxx" 容器id nginx:centos7 #常用选项: -m 指定说明信息; -a 指定作者信息; -p 生成过程中停止容器的运行。 c7f4bc905c29 原容器ID。 nginx:centos 生成新的镜像名称。 ​ docker images #查看生成的新镜像 docker run -itd nginx:centos7 bash #使用新的镜像创建容器 docker ps -a #查看容器状态 docker exec -it 容器id bash #进入容器 nginx #启动nginx服务 netstat -natp |grep 80 #查看80端口是否开启 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f626afc89cad79c345557148da72ef04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bfe2e7df0dca40320041d0899888cfd/" rel="bookmark">
			Java PDFBox 提取页数、PDF转图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDF 提取 使用Apache 的pdfbox组件对PDF文件解析读取和转图片。
Maven 依赖 导入下面的maven依赖：
&lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox&lt;/artifactId&gt; &lt;version&gt;2.0.30&lt;/version&gt; &lt;/dependency&gt; 读取总页数 和 转图片 dpi越大转换后越清晰，相对转换速度越慢，建议取值500-800。
图片类型可以选择jpg或者png：
jpg图片大小比png要小很多jpg图片转换速度比png快相同dpi jpg和png清晰度差别不大 package tech.pplus.common.util; import lombok.extern.slf4j.Slf4j; import org.apache.pdfbox.pdmodel.PDDocument; import org.apache.pdfbox.rendering.PDFRenderer; import org.springframework.web.util.UriComponentsBuilder; import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.net.URL; import java.util.LinkedList; import java.util.List; /** * @author zl * @date 2024-01-24 */ @Slf4j public class PDFUtil { /** * dpi越大转换后越清晰，相对转换速度越慢 */ private static final Integer DPI = 500; private static final String IMG_SUFFIX = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bfe2e7df0dca40320041d0899888cfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ae2ab3cfcb86581a8482dbd560ce60/" rel="bookmark">
			AWS CI/CD之Vuejs（pnpm版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 最近需要在AWS国际版上面部署一下前端web的CI/CD。之前介绍过在CodeBuild中使用yarn进行前端构建的文章，这次我们在CodeBuild中使用pnpm方式进行构建，同时把结合CodePipeline形成前端的CI/CD工作流。
1.创建前端部署s3桶 设置桶名称：如下图：
2.创建前端pnpm缓存桶 设置桶名称，如下图：
并依次创建好对应的文件夹，具体如下图：
创建root文件夹，如下图：
在root文件下面再创建一个.pnpm-store文件夹，具体结果如下：
3.创建刷新cloudfront自定义策略 打开IAM策略主页，准备创建刷新CDN自定义权限策略，如下图：
设置权限策略内容，如下图：
具体内容如下：
{ "Version": "2012-10-17", "Statement": [ { "Sid": "CloudfrontCreateInvalidation", "Effect": "Allow", "Action": "cloudfront:CreateInvalidation", "Resource": "*" } ] } 设置策略名称，如下图：
4.修改s3自定义策略 由于CodeBuild除了需要CDN刷新策略之外，还需要读写上述2个s3桶的权限。故按照上述方式设置s3上述2个桶水读写策略。创建自定义权限策略dev-codebuild-s3，设置内容如下：
{ "Version": "2012-10-17", "Statement": [ { "Sid": "ListObjectsInBucket", "Effect": "Allow", "Action": [ "s3:ListBucket" ], "Resource": [ "arn:aws:s3:::dev-xxx", "arn:aws:s3:::dev-pnpm-codebuild" ] }, { "Sid": "AllObjectActions", "Effect": "Allow", "Action": "s3:*Object", "Resource": [ "arn:aws:s3:::dev-xxx/*", "arn:aws:s3:::dev-pnpm-codebuild/*" ] } ] } 5.创建codebuild构建vuejs工程 打开codebuild主页，开始创建新vuejs构建项目，如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ae2ab3cfcb86581a8482dbd560ce60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57312b734064809ae7d31832472954fa/" rel="bookmark">
			力扣hot100 搜索二维矩阵 II 二分 抽象BST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem: 240. 搜索二维矩阵 II
文章目录 💖 二分💖 抽象BST 💖 二分 👨‍🏫 参考思路
⏰ 时间复杂度: O ( n log ⁡ n ) O(n\log{n}) O(nlogn)
🌎 空间复杂度: O ( 1 ) O(1) O(1)
class Solution { public boolean searchMatrix(int[][] matrix, int target) { int n = matrix.length; int m = matrix[0].length; if (n == 0 || m == 0) return false; for (int i = 0; i &lt; n; i++) { if (matrix[i][0] &gt; target) break; if (matrix[i][m - 1] &lt; target) continue; int col = bsearch(matrix[i], target); if (matrix[i][col] == target) return true; } return false; } //	在 a 中二分查找 x，没找到返回 -1 private int bsearch(int[] a, int x) { int l = 0; int r = a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57312b734064809ae7d31832472954fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de346a184b443f6dc9050554efb81294/" rel="bookmark">
			【JS基础】DOM的一些基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、声明变量const优先二、DOM的认识2.1 作用和分类2.2 什么是DOM2.3 DOM树2.4 DOM对象 三、DOM 的一些操作3.1 获取DOM 对象根据css选择器来获取对象其他获取DOM对象的方法 3.2 修改DOM元素内容.innerText.innerHtml 3.3 修改DOM元素属性3.4 操作css属性3.5 通过类名修改样式3.6 通过classList修改样式 总结 前言 DOM（Document Object Model）是一种用于表示和操作HTML或XML文档的接口。通过DOM，我们可以使用JavaScript来动态地操纵文档的结构、内容和样式。DOM 提供了一种树形结构的方式，将文档表示为一个由节点组成的层次结构。在本文中，我们将介绍一些基础的DOM操作，帮助初学者了解如何使用JavaScript与网页交互。
一、声明变量const优先 变量声明有三个 var let 和 const
我们应该用那个呢?
首先var 先排除，老派写法，问题很多，可以淘汰掉…
let or const ?
建议:
const 优先，尽量使用const，原因是:
const 语义化更好
很多变量我们声明的时候就知道他不会被更改了，那为什么不用 const呢?
实际开发中也是，比如react框架，基本const
如果你还在纠结，那么我建议:
有了变量先给const，如果发现它后面是要被修改的，再改为let
二、DOM的认识 2.1 作用和分类 作用:就是使用JS去操作 html和浏览器
分类: DOM (文档对象模型)、BOM (浏览器对象模型)
2.2 什么是DOM DOM(Document Object Model–文档对象模型)是用来呈现以及与任意 HTML或 XML文档交互的API
白话文: DOM是浏览器提供的一套专门用来 操作网页内容 的功能
DOM作用：
开发网页内容特效和实现用户交互
2.3 DOM树 DOM树是什么：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de346a184b443f6dc9050554efb81294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3279768feeac49b924a54853789ba47f/" rel="bookmark">
			大创项目推荐 题目：垃圾邮件(短信)分类 算法实现 机器学习 深度学习 开题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言2 垃圾短信/邮件 分类算法 原理2.1 常用的分类器 - 贝叶斯分类器 3 数据集介绍4 数据预处理5 特征提取6 训练分类器7 综合测试结果8 其他模型方法9 最后 1 前言 🔥 优质竞赛项目系列，今天要分享的是
基于机器学习的垃圾邮件分类
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
2 垃圾短信/邮件 分类算法 原理 垃圾邮件内容往往是广告或者虚假信息，甚至是电脑病毒、情色、反动等不良信息，大量垃圾邮件的存在不仅会给人们带来困扰，还会造成网络资源的浪费；
网络舆情是社会舆情的一种表现形式，网络舆情具有形成迅速、影响力大和组织发动优势强等特点，网络舆情的好坏极大地影响着社会的稳定，通过提高舆情分析能力有效获取发布舆论的性质，避免负面舆论的不良影响是互联网面临的严肃课题。
将邮件分为垃圾邮件(有害信息)和正常邮件，网络舆论分为负面舆论(有害信息)和正面舆论，那么，无论是垃圾邮件过滤还是网络舆情分析，都可看作是短文本的二分类问题。
2.1 常用的分类器 - 贝叶斯分类器 贝叶斯算法解决概率论中的一个典型问题：一号箱子放有红色球和白色球各 20 个，二号箱子放油白色球 10 个，红色球 30
个。现在随机挑选一个箱子，取出来一个球的颜色是红色的，请问这个球来自一号箱子的概率是多少？
利用贝叶斯算法识别垃圾邮件基于同样道理，根据已经分类的基本信息获得一组特征值的概率（如：“茶叶”这个词出现在垃圾邮件中的概率和非垃圾邮件中的概率），就得到分类模型，然后对待处理信息提取特征值，结合分类模型，判断其分类。
贝叶斯公式：
P(B|A)=P(A|B)*P(B)/P(A)
P(B|A)=当条件 A 发生时，B 的概率是多少。代入：当球是红色时，来自一号箱的概率是多少？
P(A|B)=当选择一号箱时,取出红色球的概率。
P(B)=一号箱的概率。
P(A)=取出红球的概率。
代入垃圾邮件识别：
P(B|A)=当包含"茶叶"这个单词时，是垃圾邮件的概率是多少？
P(A|B)=当邮件是垃圾邮件时，包含“茶叶”这个单词的概率是多少？
P(B)=垃圾邮件总概率。
P(A)=“茶叶”在所有特征值中出现的概率。
3 数据集介绍 使用中文邮件数据集：丹成学长自己采集，通过爬虫以及人工筛选。
数据集“data” 文件夹中，包含，“full” 文件夹和 “delay” 文件夹。
“data” 文件夹里面包含多个二级文件夹，二级文件夹里面才是垃圾邮件文本，一个文本代表一份邮件。“full” 文件夹里有一个 index
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3279768feeac49b924a54853789ba47f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826a85973c5b0b1380c6573cd5b86fe6/" rel="bookmark">
			Prometheus 采集snmp监控数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言snmp_exporter snmp_exporter是一个用于收集SNMP（Simple Network Management Protocol）设备指标的开源软件，它是Prometheus生态系统中的一个组件。SNMP是一种用于网络设备监控和管理的协议，通过查询和获取设备的各种信息来提供实时的状态和性能数据。
snmp_exporter充当一个代理，运行在需要被监控的SNMP设备（如路由器、交换机、防火墙等）的旁边。它会定期向这些设备发送SNMP请求，获取特定的OID（Object Identifier）值，并将其转换为Prometheus可读的指标数据。
snmp_exporter可以提供各种与SNMP设备相关的指标，如接口流量、CPU利用率、内存使用情况、链路状态、错误计数等。这些指标可以帮助管理员了解设备的运行状况、网络流量情况和性能指标，并及时做出反应。
通过将snmp_exporter与Prometheus结合使用，管理员可以定期从snmp_exporter暴露的HTTP或HTTPS端点获取SNMP设备的指标数据，并将其存储、分析和可视化。使用Prometheus的查询语言，用户可以构建自定义的监控规则和警报条件，以便快速检测和响应设备问题。
download snmp_exporter snmp_exporter采集数据 snmp_exporter 一键监控安装脚本 /opt/snmp_exporter 目录位置 端口9116配置文件/opt/snmp_exporter/snmp.yml vim /snmp_exporter.sh #!/bin/bash # -*- coding: utf-8 -*- # Author: make.han # Email: CIASM@CIASM # Date: 2024/01/17 OPT_CATALOGUE=/opt SNMP_EXPORTER_PREFIX=/opt/snmp_exporter SNMP_EXPORTER_URL=https://github.com/prometheus/snmp_exporter/releases/download/v0.25.0/snmp_exporter-0.25.0.linux-amd64.tar.gz SNMP_EXPORTER_GZ=snmp_exporter-0.25.0.linux-amd64.tar.gz SNMP_EXPORTER_DIRECTORY=snmp_exporter-0.25.0.linux-amd64 SNMP_EXPORTER_NEW=snmp_exporter SNMP_EXPORTER_PORT=9116 install_snmp_exporter (){ if [ ! -d ${SNMP_EXPORTER_PREFIX} ];then # selinux stop setenforce 0 sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config if [ $? -eq 0 ];then echo "download snmp_exporter" curl -o $OPT_CATALOGUE/$SNMP_EXPORTER_GZ $SNMP_EXPORTER_URL echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/826a85973c5b0b1380c6573cd5b86fe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da9b756131e50e5ca1fe67a16bb4584/" rel="bookmark">
			C语言常见面试题：什么是函数指针，函数指针的作用是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数指针是指向函数的指针变量，其本质是指向代码块的指针。每个函数在编译时都会有一个唯一的入口地址，这个地址就是函数指针所指向的地址。在C和C++等编程语言中，函数指针通常是指向特定函数类型的指针，即函数原型和返回类型都一致的函数。
函数指针的作用主要有两个：
作为参数传递给其他函数：回调函数是函数指针的一个重要应用场景。通过将一个函数指针作为参数传递给其他函数，后者可以将“回调”用户函数。这种设计模式在很多场景下都非常有用，例如实现一个与类型无关的查找函数（单链表），要求可以查找任何类型的值。这时可以将参数类型声明为void *，表示“一个指向未知类型的指针”，然后通过函数指针来调用相应的查找函数。转换表：函数指针可以用于实现转换表。转换表是一种将输入数据按照一定规则转换成另一种数据类型的方法，而这个转换规则可以通过函数指针来实现。具体来说，可以将每个转换规则对应的函数指针存储在一张表中，根据输入数据的特点来选择相应的函数指针进行数据转换。这种方法的优点是可扩展性好，如果需要添加新的转换规则，只需要在表中添加相应的函数指针即可。 此外，函数指针还有其他一些应用场景，例如实现事件驱动的编程模型、实现动态绑定等。通过灵活运用函数指针，可以实现更加灵活和高效的代码生成。
函数指针是C、C++、D语言、其他类C语言和Fortran 2003中的概念。在C语言中，函数同样有个地址，所以可以定义一个指针来指向一个函数，称为函数指针。函数指针为C语言提供了灵活性和动态性，可以用于实现回调函数、动态函数调用、函数表等多种应用场景。
在C语言中，函数指针的定义如下：
c复制代码
return_type (*function_pointer_name)(parameter_list); 其中，return_type 是函数的返回类型，function_pointer_name 是函数指针的名称，parameter_list 是函数的参数列表。函数指针名后的括号中的内容表示函数的参数列表，括号内的内容表示函数的返回类型。
下面是一个具体的示例：
c复制代码
#include &lt;stdio.h&gt; int add(int a, int b) { return a + b; } int main() { int (*func_ptr)(int, int); // 定义一个函数指针，指向返回类型为int且有两个int参数的函数 func_ptr = &amp;add; // 将函数指针指向add函数 printf("%d\n", func_ptr(2, 3)); // 调用函数指针，输出结果5 return 0; } 在上面的示例中，我们定义了一个函数指针 func_ptr，它指向返回类型为 int 且有两个 int 参数的函数。然后我们将 func_ptr 指向了 add 函数，最后通过函数指针调用了 add 函数，并输出了结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec52d67259484b4af56247427dd035c1/" rel="bookmark">
			【java学习-Spring】Spring-data-jpa(Java Persistence API)和Template
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，概念 1）JPA 场景：整合第三方ORM框架，建立一种标准的方式ORM 访问数据库的统一。
现阶段JPA几乎都是接口，实现都是Hibernate在做。我们都知道，在使用持久化工具的时候，一般都有一个对象来操作数据库，在原生的Hibernate中叫做Session，在MyBatis中叫做SqlSession，而在JPA中叫做EntityManager通过这个对象来操作数据库。
对象关系映射（Object Relational Mapping，简称ORM）
通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中。
2）占位符 JPA里占位符：?1（必须按顺序传参）或 :userName （推荐，本地sql中出现的冒号需要通过双斜杠转义）。
3）JSR338（Java Specification Requests，JPA规范） JSR 338主要定义了如何通过普通的Java domain进行关系数据库的操作及映射，概括如下：
1&gt;Entity 必须是顶级类@Entity注解的类必须有一个无参的public 或 protected的构造方法不能是final类，且不能有final方法或final变量一个Entity类通常与数据库的一张表进行对应一个Entity实例表现为数据库的一条数据对Entity的操作即对数据库的操作生命周期包含初始、托管、释放、消亡 2&gt;EntityManager 对Entity持久化操作的主要对象通过EntityManagerFactory获取实例一个实例代表一个数据库连接每个线程拥有自己的EntityManager实例主要方法有persist、remove、merge、createQuery、find @PersistenceContext private EntityManager em; 3&gt;EntityManagerFactory 创建EntityManager的工厂EntityManagerFactory的创建成本很高，对于给定的数据库，系统应该只创建一个与之关联的Factory可使用@PersistenceUnit注入 4&gt; EntityTransaction 表示数据库事务，在增、删、改时使用可通过EntityManager.getTransaction()获取 5&gt;Persistence Context 维护一组托管状态的Entity实例与EntityManager是相关联的 6&gt;Persistence Unit 一组Entity及相关设置的逻辑单元定义创建EntityManagerFactory所需要的参数通过persistence.xml定义或者通过一个PersistenceUnitInfo对象 7&gt;总结 通过Persistence Unit创建EntityManagerFactory，再通过EntityManagerFactory获取EntityManager。
2，EntityManager EntityManager是JPA中用于增删改查的接口，它的作用是：对一组实体类（Entity Bean）与底层数据源（tabel或临时表）之间进行 O/R 映射的管理。
1）Entity生命周期 状态名描述作为java对象存在在实体管理器中存在在数据库存在New（瞬时对象）尚未有id，还未和Persistence Context建立关联的对象yesnonoManaged（持久化受管对象）有id值，已经和Persistence Context建立了关联的对象yesyesyesDetached（游离态离线对象）有id值，但没有和Persistence Context建立关联的对象nononoRemoved（删除的对象）有id值，尚且和Persistence Context有关联，但是已经准备好从数据库中删除yesyesno 2）方法 1&gt; 新增数据：em.persist(Object entity); 如果entity的主键不为空，而数据库没有该主键，会抛出异常；
如果entity的主键不为空，而数据库有该主键，且entity的其他字段与数据库不同，persist后不会更新数据库；
2&gt; 根据主键查找数据：em.find(Class entityClass, Object primaryKey); 如果主键格式不正确，会抛出illegalArgumentException异常;
如果主键在数据库未找到数据返回null；
3&gt;删除数据：em.remove(Object entity); 只能将Managed状态的Entity实例删除，由此Entity实例状态变为Removed；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec52d67259484b4af56247427dd035c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47366f6dd8d3160479d18a7cd55b4f6d/" rel="bookmark">
			电脑监控系统：企业网络安全解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今数字化的世界里，企业的网络安全已经成为一项至关重要的任务。电脑监控系统作为一种有效的解决方案，正在被越来越多的企业所采用。
电脑监控系统是一种集成了多种安全功能的综合性解决方案，旨在为企业提供全面的网络安全防护。该系统能够实时监测网络流量，识别和拦截潜在的威胁；对员工的网络行为进行监控和管理，防止敏感信息的泄露；同时还能够快速响应安全事件，及时处理和解决各种网络安全问题。
对于企业而言，电脑监控系统的应用具有多方面的优势。首先，它可以提高企业的网络安全水平，有效防止各种网络攻击和数据泄露事件的发生。其次，该系统能够提升企业的管理效率，通过监控和管理员工的网络行为，减少不必要的网络使用和资源浪费。此外，电脑监控系统还可以帮助企业建立完善的网络安全体系，提高企业的形象和信誉度。
当然，电脑监控系统的实施也需要考虑到一些潜在的问题和挑战。其中最重要的是保护个人隐私和合规性问题。企业需要严格遵守相关法律法规和伦理规范，确保监控行为合法合规，同时采取必要的措施保护个人隐私和数据安全。
综上所述，电脑监控系统作为一种有效的企业网络安全解决方案，具有多方面的优势和价值。然而，企业在应用该系统时也需要注意潜在的问题和挑战，并采取相应的措施来确保合法、合规和安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aba9b71efaa9b6293752c58915fc304/" rel="bookmark">
			MWORKS.Syslab 如何统一 Julia、C/C&#43;&#43;、Python 乃至 MATLAB —— 解密多语言统一的底层机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		科学世界蓬勃发展，注入了许多时代特有的活力。年轻理科生们的口中逐渐出现了诸如“调参侠”“调包小子”“炼丹师”等新潮的调侃词语，这些来自机器学习/深度学习领域的“梗”在社交网络中逐渐扩散，让人们不禁感叹科学计算已经成为了炙手可热的“显学”。
虽然科学计算正呈现大兴之势，但其内生的复杂性和综合性仍然导致生态分化严重。尽管Python和C/C++是主流方案，但该方案在科学计算领域并非万能；注重开箱即用的工程师们依然使用MATLAB和R，而追求抽象复用和语言底层能力的框架开发者们则热衷于折腾Julia。
同元软控MWORKS.Syslab是现代化统一科学计算环境，经多年综合权衡，底层选用性能/功能上限相对高的Julia语言，同时，集成诸如Python、M语言等现有科学计算生态。虽然MWORKS.Syslab使用Julia作为底层，但生态体量庞大的Python开发者也能平滑适应Syslab开发环境。在MWORKS.Syslab中，用户可以点击左上方“新建”按钮，轻松创建Python脚本进行开发，对于熟悉Python开发的用户，他们会发现MWORKS.Syslab移植了Python开发的常见工作流，其中一个不可忽视的关键特性是，在MWORKS.Syslab中，Python程序可以通过先进的“Seamless FFI”方式轻松访问 Julia 编写的 MWORKS.Syslab 函数库。
△ Syslab Python调用Julia案例
图中的TyPlot和TyMathCore其实是由Julia编写的图形库和数学库，然而它们如图被导入和使用时，看起来就像普通的Python库一样。这种方便的技术是如何实现的呢？
答案就是利用了前面所提到的FFI（外部函数接口）。FFI 技术用于实现不同编程语言间的相互调用，从而使上图中这种跨语言的兼容成为可能。正如上图所示，Syslab 通过FFI技术，实现了在Python中调用Julia编写的TyPlot和 TyMathCore。部分读者或许并不熟悉FFI，但其相关技术却无处不在，尽管整个科学计算生态错综复杂，但底层则是统一的：一个经典例子是 Fortran 编写的线性代数计算库，无论是 NumPy、PyTorch、Julia 还是 R，都依赖 FFI 技术调用这些 Fortran 库。
在解释什么是FFI以及MWORKS.Syslab做了什么有趣的事之前，我们不妨先看看这个领域的背景。
基于C语言的 FFI 技术，是科学计算领域统合多语言的基石。全球有成百上千种独特的编程语言，其中大部分都在其特定领域发挥着不可替代的作用。为了满足现实场景的复杂需求，我们常常需将多种技术整合在一块。因此，很多时候我们需要某种跨语言调用技术，以便同时使用多种编程语言来达成目的，而对科学计算领域来说，这个技术就是基于C FFI的多语言互调用。
我们常见的网络服务就是一种简洁的跨语言调用技术，但由于性能问题，该技术不适用科学计算领域。总的来说，网络服务端提供的服务可以被视为由服务器所用的编程语言导出的“函数”，来自网络的JSON数据则作为这些函数的“参数”。“参数”通过反序列化过程转化为相应语言能够理解的数据格式，然后被服务器提供的服务处理，这个过程就被视为“函数调用”。最后，函数调用的结果会被序列化为JSON数据，并反馈给客户端。在跨语言调用的意义上，客户端处理数据的过程与服务端是相似的。
虽然，基于网络服务的跨语言调用方案普遍适用于非科学计算领域。但对科学计算领域来说，情况则截然不同。
让我们看下图这个例子：
△Python远程调用：服务端/客户端
根据上图代码启动服务器，并在客户端运行10000次本地请求，运行时间超过20s。
根据上述实验可知，仅仅10000次基于网络的同步跨语言调用，Python的开销长达20s。熟悉Python底层的朋友都知道，Python的基础四则运算，性能基本在100 纳秒内，在网络调用中却退化到毫秒级，性能上相差四个数量级。这样的性能损耗，对于科学计算这样大部分都是低开销密集计算的场景来说，即使基于网络的跨语言调用再怎么方便，也无法满足要求。
实际上，在计算性能要求较高的场景中，传统的跨语言互调用方案通常采用的是“进程内互调用”的FFI技术，且通常是基于C的FFI技术。在这种方案中，C API成为了C FFI的核心概念。
C语言作为几乎所有编程语言的底层，有着一项特别的殊荣：绝大多数语言都提供一组C API，从而支持与C语言的进程内互操作。像Python这样有运行时的语言，以动态链接库的形式存在 (libpython.so)，这些动态链接库导出一组完整的、能精细控制该语言的C函数符号；而像Rust这样没有运行时的语言，则由编译器直接生成二进制文件，其编译器支持按需导入或导出指定的C函数符号。上述C函数符号，以及对其调用方式、参数内存的约定，就是技术领域常说的C API。
△ Python Stable C API 例子：PyLong_FromSsize_t
上述事实揭示了一项普遍情况：绝大多数语言都支持导出C API，让外部语言操作自身；同时，它们也支持导入C API，以便操作其他外部语言。因此，从理论上来说，基于C API，任意两门编程语言都可以轻松相互调用。
△ 基于C API的Python/Julia简单互调用
但是，事情真的如此简单吗？
△ Python/Julia互调用问题：复杂数据类型
以上述例子为例，它揭示了一个关键问题：不同语言之间复杂数据的不兼容性。具体来说，在Julia中如上图所示定义一个MyStruct类型，与在Python中定义MyStruct类型存在本质差异。
为了更好地理解这种差异，我们可以从一个简单的角度来考察：比较Julia的MyStruct实例和Python的MyStruct实例在内存方面的差异。
△ Python/Julia定义的相似结构MyStruct的内存差异
结果显示，Julia的MyStruct和C结构体类似，共16字节，其内存结构相对易于理解。然而，Python作为一种高级解释语言，依赖于一个复杂的数据模型。在Python中，MyStruct的一个实例表面上占据了48个字节，其中包含了大量的指针（类似于C++的虚表结构），还包含一个指向哈希结构的数据指针，这个哈希结构中存储了MyStruct实例的字段。
如此不同的结构，为什么两者都能使用简单的a.b语法来存取字段呢？
这是因为：在C API层面，不同编程语言的语义截然不同。Julia为语法a.b赋予了指针简单存取的语义，而Python则具有更复杂的语义。在Python中，对象首先查找其类型头指针，再经过一系列复杂的查找，最终找到适用于MyStruct类型的函数指针，用于对象属性访问。通过调用该函数指针，最终在用户层面呈现为一种黑盒式的、易于理解的字段存取行为。
△ 疑惑：Julia结构体在Python中是一个整数？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aba9b71efaa9b6293752c58915fc304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4bd97c61754f1cc660d11c485a4d54c/" rel="bookmark">
			K8S安全机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全机制
k8s的安全机制，分布式集群管理工具，就是容器编排，安全机制的核心就是围绕API SERVER ，作为整个集群内部通信的中介，也是外部控制的入口，所有的安全机制都是围绕api server来进行设计
请求api资源需要过三关
1.认证
2.鉴权
3.准入机制
三个条件都通过，才可以在k8s集群当中创建
认证
Anthentcation
HTTP 通过token识别合法用户，token是一个很长，很复杂的一个字符串，字符串是用来表达客户的一种方式，而每一个token都对应一个用户名，用户名存储在apiserver能够访问的文件中，当客户端发起请求时，http headr包含token。
流程：客户端发起请求到-token-apiserver(用户存储文件)-解码-用户名-访问集群
http base
用户+密码的验证方式，用户名和密码都是通过base64进行加密，加密完成的字符串，http requset的header Atuthorization发送给服务端，服务端会收到加密的字符串，解码，之后获取用户名和密码
https证书
最严格的方式，也是最严谨的方式，基于CA根证书签名的客户端身份进行验证
认证的访问类型
k8s的组件对api server的访问 如kubelet，kube-proxy
pod对apiserver的访问 如pod coredns，dashborad都是pod，也需要访问api
客户端和kubectl
Kubelet kube-proxy：
Controller manager sheduler 与api server在一台服务器，可以直接使用api server的非安全端口访问有可能是（8080）
Kubectl和kubelet和kube-proxy都是通过api server的https证书进行双向验证，都是用6443端口进行验证
签发证书
手动签发
二进制部署就是手动签发，CA签发就是把证书匹配到每个对应组件，然后访问6443即可
自动签发
kubeadm，kubelet第一次要访问api server使用的是token，token通过之后，comtroller manager 会为kubelet生成一个证书，以后都是通过证书访问，kubeadm修改了证书的有效期，默认是1年
Kubeconfig
文件包含了集群的参数，CA证书，API server地址，客户端的参数（客户端的整数和私钥），以及集群的名称和用户名，k8s组件都是通过启动时制定访问不同的kubeconfig文件切换到不同的集群，再到api server--namespace再到资源对象，pod，容器，kubeconfig既是集群的描述文件，也是一个集群信息的保存文件，包含了集群的访问方式和他的认证信息，一般都在家目录下（隐藏文件）.kube/config保存的是kubectl的访问认证信息
ServiceAccount
就是为了方便pod中的容器来访问API server，pod的动作（增删改查），动态的，每个pod手动生成一个证书就不现实了，于是k8s使用了service Account来循环认证，包含了统一的认证信息，直接进行api server访问
Secret
保存资源对象，aserviceAccount内部，保存的token service-account-token，secret保存的是自定义的保密信息
ServiceAccount
1.Token
2.Ca.crt
3.Namespace
都会被自动挂载到pod当中
鉴权
鉴权
之前的认证过程，只是确认了双方都是可信的，可以互相通信的，鉴权是为了确定请求方的访问权限，能做哪些指定的操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4bd97c61754f1cc660d11c485a4d54c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e5c28c6d716121fe63252574be24ee5/" rel="bookmark">
			centos安装aws，aws: 未找到命令...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装awscli 1. 环境：安装pip3 #yum install -y python3-pip
查看是否安装成功
#pip3 -V
2.安装aws cli工具 ① # pip3 install awscli --upgrade --user --upgrade: 如果已经安装了 AWS CLI，此选项会将其升级到最新版本。 --user: 将 AWS CLI 安装到用户主目录下，而不是全局 Python 环境。避免了管理员权限的安装，同时也不会对系统的 Python 包产生全局影响。 如果报错“Retrying (Retry(total=4*”**，请往下翻
查看是否安装成功
#aws --version
② 配置aws cli #aws configure
AWS Access Key ID [None]: AKI*****************UIZ #唯一标识你的 AWS 账户的标识符 AWS Secret Access Key [None]:km6******Q2kW #与你的 AWS Access Key ID 相对应的秘密密钥。它用于对 AWS 资源进行身份验证和访问 Default region name [None]:cn****1 #AWS 资源所在的默认区域，每个区域都有不同的资源（例如 EC2 实例、S3 存储桶等。） Default output format [None]: j*** #AWS CLI 返回结果的默认输出格式 AWS Access Key ID 和 Secret Access Key 是敏感信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e5c28c6d716121fe63252574be24ee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1979985df1baf200f2fe04606c2387bd/" rel="bookmark">
			中间件安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中间件安全 vulhub漏洞复现：https://vulhub.org/操作教程：https://www.freebuf.com/sectool/226207.html 一、Apache Apache(音译为阿帕奇)是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。Apache是用C语言开发的基于模块化设计的web应用，核心代码不多。多数功能分散在各个模块中 1.Apache 解析漏洞（CVE-2017-15715) 影响版本：2.4.0~2.4.29
漏洞原理：apache这次解析漏洞的根本原因就是这个 ∗ ∗ ，正则表达式中，我们都知道 ** ，正则表达式中，我们都知道 ∗∗，正则表达式中，我们都知道用来匹配字符串结尾位置**
$符号: 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r' 要匹配 $ 字符本身，请使用\$ 如果设置MULTILINE标示，就当作换符处理，如果不设置就当作一行文本处理 本次实验是vulhub下的，所以找到apache配置文件，路径在/etc/apache2/ 下， apache2.conf 是apache核心配置文件查看其文件发现如下代码：意思是包含这两个文件下的以conf结尾的文件
IncludeOptional confenabled/*.conf IncludeOptional sitesenabled/*.conf 跟进该文件发现关于php的配置文件为docker-php.conf,打开为如下
&lt;FilesMatch \.php$&gt; SetHandler application/xhttpdphp &lt;/FilesMatch&gt; 可以看到在正则中是 .php , 因为结尾有个 ,因为结尾有个 ,因为结尾有个符号，结合上述原理，$匹配 ‘\n’ 或 ‘\r’，所以我们修改数据包在文件名后加\n，\n的十六进制为0a
首先查看index.php文件中的php源码
&lt;?php if(isset($_FILES['file'])) { $name = basename($_POST['name']); $ext = pathinfo($name,PATHINFO_EXTENSION); if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'])) { exit('bad file'); } move_uploaded_file($_FILES['file']['tmp_name'], '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1979985df1baf200f2fe04606c2387bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f7b69078ab1c9f1ba223ab0be26790b/" rel="bookmark">
			RabbitMQ之死信交换机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 消息队列是分布式系统中常用的组件，用于异步通信、解耦和提高系统可靠性。然而，在实际应用中，难免会遇到一些异常情况，例如消息处理失败、超时等。为了更好地处理这些异常情况，死信交换机（Dead Letter Exchange）应运而生
一.什么是死信？ 在了解死信交换机之前我们先了解什么是死信
消息变成死信一般是由于以下几种情况：
1. 重试次数超限： 消息在处理过程中多次重试仍然失败，达到预定的重试次数上限； 2. 消息被拒绝：（ Basic.Reject/Basic.Nack ），并且设置 requeue 参数为 false ； 3.消息过期：消息在队列中等待时间过长，超过了设置的过期时间 ； 4. 队列满： 当消息队列的长度达到上限时，新的消息可能成为死信。 二.什么是死信交换机？ 死信交换机是消息队列系统中的一种特殊交换机，用于处理那些无法被正常消费的消息。当消息满足一定的条件，例如重试次数达到上限或者处理失败，就会被标记为死信（Dead Letter）并被发送到死信交换机
1.死信交换机工作原理 （1）.消息被标记为死信：
当消息无法被正常消费时，可以通过设定一些条件将其标记为死信。这些条件可能包括消息的重试次数、过期时间等。
（2）.发送到死信交换机：
一旦消息被标记为死信，它将被发送到预先指定的死信交换机。
（3）.重新处理或记录：
死信交换机可以将死信消息重新发送到其他队列进行处理，也可以将其记录到日志中供后续分析。
三.优势与应用场景 1.优势 错误隔离： 死信交换机可以将异常消息隔离，避免影响正常消息的处理。重试机制： 通过重新发送死信消息，可以实现简单的重试机制，提高消息的可靠性。异常处理： 将死信记录到日志中，有助于系统运维人员进行故障排查。 2.应用场景 应用场景： 业务异常： 处理业务逻辑失败的消息，例如订单支付失败。超时处理： 处理处理时间超过预定阈值的消息，避免长时间占用资源。重试机制： 对于多次重试后仍然无法处理的消息，标记为死信，进行后续处理。 四.实战与应用 1.时间过期进入到死信队列 创建绑定死信延迟队列
//死信、延迟队列 @Bean public Queue queueA() { Map&lt;String, Object&gt; config = new HashMap&lt;&gt;(); //message在该队列queue的存活时间最大为10秒 config.put("x-message-ttl", 10000); //x-dead-letter-exchange参数是设置该队列的死信交换器（DLX） config.put("x-dead-letter-exchange", "ExchangeB"); //x-dead-letter-routing-key参数是给这个DLX指定路由键 config.put("x-dead-letter-routing-key", "bb"); return new Queue("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f7b69078ab1c9f1ba223ab0be26790b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e8ee78afe9ff67b038fa6ce406610e/" rel="bookmark">
			如何让haproxy不命中已经失效的服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做负载均衡时，服务总是不稳定，经过日志分析，发现是haproxy负载代理时，命中了已经失效的服务节点。那么如何让haproxy不命中已经失效的服务器呢？
你可以配置服务器的健康检查（Health Check）以确保不命中已经死掉的服务器。HAProxy提供了多种健康检查的方式，其中一个常用的方法是使用HTTP健康检查。按如下步骤操作即可。
1、配置服务器的健康检查： 为每个后端服务器配置健康检查，通常使用HTTP健康检查。这意味着HAProxy将定期发送HTTP请求到每个服务器，并根据响应的状态来确定服务器是否健康。 在HAProxy配置文件中，可以使用类似下面的配置来定义健康检查： plaintext Copy code
backend my_backend server server1 192.168.1.101:80 check server server2 192.168.1.102:80 check 在上述配置中，check 参数表示要对这些服务器执行健康检查。
2、配置健康检查的参数： 你可以进一步配置健康检查的参数，如检查的时间间隔、允许失败的次数等。这些参数可以根据你的需求进行调整。
backend my_backend server server1 192.168.1.101:80 check inter 2000 rise 2 fall 3 server server2 192.168.1.102:80 check inter 2000 rise 2 fall 3 在上述配置中，inter 参数表示检查的时间间隔，rise 表示允许服务器重新上线之前必须连续成功的次数，fall 表示服务器被标记为不健康之前必须连续失败的次数。
3、监控健康检查日志： HAProxy会记录健康检查的结果到日志中，你可以监视这些日志以查看服务器的状态。根据服务器的状态，HAProxy将动态地调整请求的路由，确保不会命中已经死掉的服务器。 通过配置健康检查，HAProxy将定期检查后端服务器的状态，并在服务器死掉或不健康时自动将其从负载均衡中移除。这有助于确保不会将请求发送到已经不可用的服务器上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76db72aac24ea50214ac23bd7a914c8c/" rel="bookmark">
			蚂蚁集团去中心化的高性能存储服务 LiteIO 正式开源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在传统分布式存储盛行的时代，LiteIO 作为点对点块设备服务的代表作，在蚂蚁集团内部实践中，带来了极大的业务与技术收益。并在近期由阿里云软硬件结合研发团队与蚂蚁集团数据库技术团队联合撰写的论文《LightPool: A NVMe-oF-based High-performance and Lightweight Storage Pool Architecture for Cloud-Native Distributed Database 》，被 HPCA‘24 论文评审结果收录，CCF-A 类论文也肯定了 LiteIO 的技术先进性。趁着这个机会，我们非常荣幸的宣布蚂蚁集团去中心化的高性能存储服务 LiteIO 正式开源。将我们的技术与全世界的开发者共享，激发更多的创意和想法，我们相信，对于数据库、存储产品类有状态的、有产品层多副本能力的产品，需要 LiteIO 这样的点对点技术来适配当下的 FinOps。
我们希望吸引更多社区的想法，只有通过开放和协作，LiteIO 才能够迎接更多的挑战，解决更多的问题，并为用户带来更多的价值，让 LiteIO 项目走得更远，成为云原生时代，存储使用的一种标准范式。
开源项目仓库：https://github.com/eosphoros-ai/liteio
"什么是 LiteIO ？"
LiteIO 是一款高性能、易扩展的云原生块设备服务，专为超融合架构下的 Kubernetes 设计。在蚂蚁集团内部孵化 3 年并大规模应用在生产环境，为蚂蚁集团全数据型、存储型产品提供稳定、高效、易扩展的磁盘服务。
LiteIO 是将本地磁盘/逻辑卷，通过网络的方式共享给远程其他服务器使用，结合云原生 Kubernetes 的调度，将一系列磁盘统一管理、池化的通用技术。点对点的技术设计，相较传统分布式存储，有效地控制住硬件故障所带来的爆炸半径，同时去除存储冗余，有更多使用空间。
01
设计背景
在降本增效的时代，FinOps 显得格外重要，尤其像蚂蚁集团这种存储服务器规模庞大的体系，全局 1% 的存储利用率提升都会带来巨大的成本经济收益。因此需要再成本优化、保证通用性的同时稳定性不降。
数据库是一种重 IO 的软件系统，对于 IO 的稳定性和性能要求极高，一般生产系统都将数据库部署在本地磁盘的服务器上，这将带来两个问题：
利用率不均：IO 密集型和计算密集型的 workload 不同，这就会出现一台机器计算用完而存储富裕，亦或者存储用完计算还富裕，且通过调度也很难做到全局最优解。
扩展性差：当出现存储不足，需要 scale up 存储，不得不通过迁移的手段换一台更大存储的服务器，拷贝数据的过程长。
传统分布式存储也是一种不错的解决方案，但在数据库领域，它将带来几个方面的问题：
副本数上升（成本）：分布式存储的优势在于通过 EC、多副本技术将存储池化，对于单硬件故障有很好的保护，但通过 EC、多副本技术造成单份数据副本在此架构下副本数将大于1，往往副本数在1.375~2之间。数据库作为业务服务重要的组成，往往在上层有异 AZ、异地容灾的要求，在另一个 AZ 已经有数据库层面的备副本。总数据副本数会增加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76db72aac24ea50214ac23bd7a914c8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc7ca4517d9e76f3994cf599adabc37/" rel="bookmark">
			C语言常见面试题：什么是条件编译，条件编译的作用是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件编译是一种编程技术，它允许程序员根据不同的条件来选择性地编译源代码中的部分内容。条件编译在编译过程中起到了非常重要的作用，它可以根据不同的条件来生成不同的代码，从而实现更加灵活和高效的代码生成。
条件编译的作用主要有以下几个方面：
代码复用和避免重复：在大型软件项目中，可能需要根据不同的环境、语言版本或操作系统等条件来选择性地包含或排除特定的代码段。通过条件编译，可以实现更加灵活的代码复用，避免重复的代码出现在多个地方，提高了代码的维护性和可读性。定制化开发：在一些需要针对不同用户或不同需求进行定制化开发的场景下，可以通过条件编译来实现。例如，根据用户的定制需求来选择性地包含或排除某些功能模块，从而生成符合用户需求的特定版本的程序。调试和优化：在软件开发过程中，可能需要对不同的代码段进行调试和优化。通过条件编译，可以方便地将不同的代码段分别编译和链接，从而方便地对各个部分的代码进行单独的调试和优化。处理文件之间的关系：在一些情况下，可能需要处理多个文件之间的关系，例如在大型项目中可能需要包含多个头文件，但是某些头文件之间可能存在包含冲突或者重复包含等问题。通过条件编译，可以方便地处理这些问题，从而避免编译错误和不必要的重复包含。 总之，条件编译是一种非常有用的编程技术，它可以提高代码的复用性、灵活性、可维护性和可读性，从而实现更加高效和灵活的软件开发和维护。
在实际项目开发中，可以使用条件编译来实现更加灵活和高效的代码生成。下面是一些常见的使用条件编译的场景和方法：
头文件中的条件编译：在头文件中使用条件编译，可以避免头文件的重复包含和编译冲突等问题。通常可以使用预处理器指令来定义常量或条件编译指令，例如：
c复制代码
#ifndef HEADER_FILE_NAME #define HEADER_FILE_NAME // 头文件内容 #endif // HEADER_FILE_NAME 根据不同的编译选项编译不同的代码：在编译过程中，可以通过设置不同的编译选项来选择性地包含或排除某些代码段。例如，在C++中可以使用预处理器指令来根据不同的编译选项定义常量或条件编译指令，例如：
cpp复制代码
#ifdef DEBUG // 调试模式下使用的代码 #else // 非调试模式下使用的代码 #endif 根据不同的运行时条件编译不同的代码：在运行时，可以根据不同的条件来选择性地执行某些代码段。例如，在C++中可以使用条件语句来根据变量的值选择不同的代码分支，例如：
cpp复制代码
if (condition) { // 条件为真时执行的代码 } else { // 条件为假时执行的代码 } 使用宏定义来实现条件编译：在C和C++中，可以使用宏定义来实现更加灵活的条件编译。例如，可以使用defined运算符来检查宏是否已定义，例如：
c复制代码
#if defined(MACRO_NAME) // MACRO_NAME已定义时执行的代码 #endif 这些是在实际项目开发中使用条件编译的一些常见场景和方法。根据具体的项目需求和开发环境，还可以使用其他的方法和技巧来实现更加灵活和高效的代码生成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d46438e7cca98518d931b809d75505/" rel="bookmark">
			VirtualBox如何复制虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于vmware或virtual pc虚拟机，要想快速复制几个虚拟机，以便集群使用，方法比较简单，例如直接复制其虚拟机相应的磁盘文件和配置文件即可，例如对于vmware，修改vmx文本文件中的内容如虚拟机名称、磁盘文件路径即可，在启动时选择已经复制磁盘文件，便可以成功。
但对于virtualbox，则有些不同，如果直接用以上方法，会报磁盘文件的UUID冲突，表示已经有相同的磁盘文件在使用，那么该如何解决呢？那就是复制完磁盘文件后，还要修改磁盘文件的UUID，而这个UUID不是记录在其它配置文件中的， 而是就这个磁盘文件上。而这个磁盘文件是非常大的，不能采用手工的办法去修改这个UUID，而要利用VirtualBox提供的工具：
VBoxManage internalcommands sethduuid path/to/your/disk.vmdk 将 path/to/your/disk.vmdk修改为你自己的路径，执行命令，会回显出一个新的UUID，表示修改成功了。
当然也可以用第三方的工具。无论哪种方法，都建议在进行操作之前先备份原始的虚拟硬盘文件，以防万一。
以上是关键步骤，成功后，按照传统方式操作即可，如：
打开VirtualBox管理界面： 打开VirtualBox并进入管理界面。
导入虚拟机： 使用“导入”功能导入你复制的虚拟机。选择导入时不要复制虚拟硬盘，因为虚拟硬盘已经在复制时包含在新文件夹中。
修改虚拟机设置： 在VirtualBox中选择新导入的虚拟机，点击设置。检查硬盘、网络适配器等设置，确保它们符合你的要求。
启动虚拟机： 启动新导入的虚拟机，确保它能够正常运行。
通过这些步骤，你应该能够成功复制虚拟机而避免ID冲突的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3949ef21ccc3fab8082dca117c9ee910/" rel="bookmark">
			CSS之粘性定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让我为大家介绍一下粘性定位吧！
大家应该都了解过绝对定位，它是相对于父级定位
那么粘性定位相对于谁呢？
它相对于overflow:hidden;
如果没找到就会跟fixed固定定位一样，相对于视口
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } body { height: 2000px; } dl { width: 200px; margin: 0 auto; border: 1px solid red; } dt { position: sticky; top: 0; font-size: 20px; color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;dl&gt; &lt;dt&gt;A&lt;/dt&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;B&lt;/dt&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;C&lt;/dt&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 感谢大家的阅读，如有不对的地方，可以向我提出，感谢大家！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8671f5bf0aa2ffc40b5cda7b0079ed5e/" rel="bookmark">
			api管理工具的新发现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、之前用过的api管理工具 关于api管理工具，之前用过yapi和postman，但是后来发现了这两个工具
二、新发现的更强大的：Apifox和Eolink Apifox和Eolink，那这两个工具有什么优势呢？
2.1Apifox 其中 Apifox= Postman + Swagger + Mock + JMeter，这样就相当于一个工具集成了 API 文档、API 调试、API Mock、API 自动化测试一体化协作平台。官网如下，并且官网还封装了一些常见网站的api测试平台，十分方便，Apifox - API 文档、调试、Mock、测试一体化协作平台。拥有接口文档管理、接口调试、Mock、自动化测试等功能，接口开发、测试、联调效率，提升 10 倍。最好用的接口文档管理工具，接口自动化测试工具。
2.2Eolink Eolink有三个产品：
apikit是API 设计、文档管理、自动化测试、监控、研发管理和团队协作的一站式 API 生产平台；apinto_pro定位是一个网关（还没实际使用过）；
apispace，也是集成了很多第三方的api接口，很适用
APISpace-探索API数据接口-API接口大全-免费API接口服务
官网：
Apikit_API协作管理平台_API文档管理-Eolink
大家有空可以去体验体验啊，真的很强大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb8cc39f5bf596e76f690fcf3582683/" rel="bookmark">
			如何使用Flutter构建高质量的用户界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter 是一种比较流行的移动应用开发框架，可以让开发者使用一个代码库构建高质量的 iOS 和 Android 应用。Flutter 以其快速、美观、高度可定制等优点吸引了开发社区的广泛关注。但如何使用 Flutter 构建高质量的用户界面呢？下面分为以下几个部分简单的介绍一下。
基础概念和语法
在使用 Flutter 构建高质量的用户界面之前，你需要先了解 Flutter 的基本概念和语法。Flutter 使用 Dart 编程语言，这是一种面向对象的语言，具有强类型、动态类型和异步编程等特性。Flutter 的布局系统是基于组件树的，每个界面都由多个组件组成。组件可以是布局、容器或其他 UI 元素等，而每个组件都有自己的样式和属性。Flutter 提供了丰富的组件库，开发者可以使用这些组件来构建复杂的用户界面。
Material Design 或 Cupertino 风格
Flutter 提供了两种主题风格， Material Design 和 Cupertino。Material Design 是一种现代化和通用的设计语言，而 Cupertino 是模仿苹果设备的风格。根据你的应用需求选择合适的风格，并使用相应的组件和样式。Material Design 风格的应用一般具有鲜明的色彩和流畅的转换效果，而 Cupertino 风格的应用则更加注重简洁和直观。在构建用户界面时，你需要使用相应的组件和样式，确保你的应用符合选定风格的设计规范。
布局和组件
在使用 Flutter 构建用户界面时，你需要熟悉各种布局和组件。Flutter 提供了丰富的布局组件，这些组件可以帮助你管理和组织界面元素。另外，Flutter 还提供了各种基础组件用于展示内容和响应用户操作。在使用布局和组件时，你需要根据界面需求选择合适的组件，并进行组合和嵌套。例如，你可以使用 Row 和 Column 组件来创建网格布局，使用 Stack 组件来堆叠组件等。
自定义组件
如果标准组件无法满足你的需求，你可以自定义组件。通过继承现有组件或组合多个组件，你可以创建符合自己设计和交互规范的 UI 控件。例如，你可以创建一个自定义按钮组件，其中包含你自己的样式和动画效果。在创建自定义组件时，你需要考虑组件的复用性和可维护性。尽量将组件拆分成独立的部分，并使用合适的属性和回调函数来控制组件行为。
响应式设计
Flutter 强调响应式设计，根据屏幕尺寸和设备方向等动态调整界面布局。使用 MediaQuery 和 OrientationBuilder 等工具来适配不同的屏幕尺寸，确保你的应用在各种设备上都能提供一致的用户体验。在构建响应式界面时，你需要设计灵活的布局和组件，它们可以适应不同的屏幕尺寸和方向。例如，你可以使用 Expanded 组件来填充空余空间，使用 Flexible 组件来调整组件大小等。
动画和交互效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eb8cc39f5bf596e76f690fcf3582683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bafa43db6262e34911f60647c1a54c5c/" rel="bookmark">
			力扣hot100 旋转图像 模拟 坐标映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Problem: 48. 旋转图像
文章目录 思路💖 原地旋转 思路 👨‍🏫 参考
💖 原地旋转 时间复杂度: O ( n 2 ) O(n^2) O(n2)
空间复杂度: O ( 1 ) O(1) O(1)
class Solution { public void rotate(int[][] matrix) { int n = matrix.length; for(int i = 0; i &lt; n/2; i++) for(int j = 0; j &lt; (n+1)/2; j++) { int t = matrix[i][j]; matrix[i][j] = matrix[n-1-j][i]; matrix[n-1-j][i] = matrix[n-1-i][n-1-j]; matrix[n-1-i][n-1-j] = matrix[j][n-1-i]; matrix[j][n-1-i] = t; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9bb7fd36ef039c9ed369f53237ba87/" rel="bookmark">
			Android Studio线程——界面自动跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实现页面的诺干秒后的自动跳转效果run方法(函数)是线程要做的”事情”
Thread t = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(5000); } catch (InterruptedException e) { throw new RuntimeException(e); } //页面跳转 Intent intent = new Intent(MainActivity2.this,MainActivity.class); startActivity(intent); } }); t.start(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fbf5f5aa59a5ba59350c459995c214e/" rel="bookmark">
			深度学习还是用python比较简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进行深度学习任务时，Python通常是首选语言，原因如下：
丰富的库和框架：Python拥有众多强大的深度学习库，如TensorFlow、PyTorch、Keras等。这些库为构建复杂的神经网络提供了便利，包括LSTM（长短期记忆网络）。
社区和文档支持：Python有一个庞大且活跃的社区，提供大量的教程、文档和论坛支持。无论是初学者还是经验丰富的开发者，都能在社区中找到有价值的资源和帮助。
简洁的语法：Python的语法简单清晰，使得编写和阅读代码更加容易。这对于快速开发和维护深度学习模型尤为重要。
数据处理能力：Python提供了诸如NumPy、Pandas等强大的数据处理库，这对于深度学习中的数据预处理和分析至关重要。
科学计算和可视化工具：Python还提供了强大的科学计算库如SciPy和数据可视化工具如Matplotlib，这些工具对于深度学习的研究和分析非常有用。
跨领域应用：Python在多个领域都有广泛应用，包括网页开发、数据分析、机器学习、网络爬虫等，这使得它成为一种多用途且实用的编程语言。
由于这些优势，Python成为了执行深度学习和其他类型的机器学习任务的首选语言。当然，选择哪种编程语言还应根据个人偏好、项目需求和现有生态来决定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d7ad1c31b538cca9ebea33aefcee11/" rel="bookmark">
			JS事件之visibilitychange(页面可见性改变)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让我为大家介绍一下这个事件吧！
这个事件如何触发？
当我们切换页面的时候会触发
事件中有一个叫做visibilityState的属性可以获取到页面的状态
document.addEventListener("visibilitychange", function () { console.log(document.visibilityState) }) hidden为隐藏
visible为显示
这样我们就可以做许多的事情，就比如小游戏，我们切出去就暂停游戏，切回来游戏继续
不知道大家有没有遇到过这种情况，使用定时器时，我们切换页面再回来发现定时器出现问题
setInterval(() =&gt; { console.log(1); }, 500) 当我们切换页面的时候，浏览器就会想着，哎，你切出去了，那我可要开始节流了，定时器就会变成1秒执行一次，就会造成许多的问题，比如生成类的游戏，切出去后，它一直在生成，可能500毫秒生成一个，结果切出去后，1秒生成一个就会造成大问题，我们就可以切出去使用事件，判断页面可见性，控制游戏的开始与暂停。
感谢大家的阅读，如有不对的地方，可以向我提出，感谢大家！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a96af25799552c4502820889650f4e/" rel="bookmark">
			面试经典题---3.无重复字符的最长子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 3.无重复字符的最长子串
我的解法：
滑动窗口：
维护一个[left, right)的滑动窗口，其中[left, right - 1]都是不重复子串；每轮while循环都计算一个滑动窗口的无重复子串长度len，每轮也让right后移一步； 内部的for循环用于判断[left, right - 1]部分的元素与元素s[right]是否相同，一旦发现s[right]与其中某个元素相同，则窗口左端会收缩至right + 1位置，更新窗口大小len；当窗口[left, right - 1]部分的元素与元素s[right]都不相同时，将元素s[right]加入无重复子串，滑动窗口右移一步，窗口大小len加1 class Solution { public: int lengthOfLongestSubstring(string s) { int left = 0, right = 0; int len = 0, res = 0; while(right &lt; s.size()){ char str = s[right]; for(int index = left; index &lt; right; index++){ if(s[index] == str){ left = right + 1; len = right - left; break; } } right++; len++; res = max(res,len); } return res; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66df4e9645a0088987078043cfdc4670/" rel="bookmark">
			uniapp 解决键盘弹出页面内容挤压问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		page.json 配置
加 “app-plus”: {
“softinputMode”: “adjustResize”
}
{ "path": "pages/jxx/xx", "style": { "navigationBarTitleText": "贺卡DIY", "enablePullDownRefresh": false, "app-plus": { "softinputMode": "adjustResize" } } }, 背景图不要设置成高100%，实时监控窗口高度给背景图高赋值。
&lt;view class="bgbg" :style="{height: screenHeight == 0 ? '100%':screenHeight+'px'}"&gt;&lt;/view&gt; created() { this.screenHeight = uni.getSystemInfoSync().windowHeight; }, ok完美解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75d8684621cd4a7274d2938ba83bc18/" rel="bookmark">
			Redis面经——Redis的双写一致性，一篇文章带你彻底搞懂什么是Redis的双写一致，如何推演实现的？以及成熟的解决方案！黄金文档！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、双写一致性概念
当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致
Redis的双写一致性，一般是基于两种场景，第一个是追求强一致性，第二个允许延迟一致（保证数据的最终一致性）
二、保证双写一致性细节
追求强一致性
（一）读操作
缓存命中，直接返回；缓存没有命中则查询数据库，写入缓存，设定超时时间
（二）写操作
延迟双删
那么问题来了，是先删除缓存呢还是先修改数据库呢？
1、先删除缓存，再操作数据库
假设最开始缓存和数据库中的数据都是10条
有两个线程
（1）先删除缓存
（2）更新数据库数据
（3）查询缓存，缓存未命中，则查询数据库，将数据写入到缓存中
但是这种方式还是会存在问题的！
请继续往下看
（1）线程1此时删除了缓存，由于线程的调度完全是由CPU来控制，此时线程1挂起，而线程2开始查询数据，此时线程2肯定是未命中的状态，就去查询数据库，并将数据库更新前的数据又重新写入到缓存了
（2）此时，线程1开始执行，线程1完成了数据库的数据更新，数据库数据变成了20，但是此时的缓存中数据还是10，这就造成了脏数据的情况！！！
2、先操作数据库，再删除缓存
1）正常的流程
假设初始缓存和数据库中的数据都是10
线程2开启，并直接更新了数据库，然后线程2删除了缓存。此时线程1查询缓存，发现缓存未命中，直接去查询数据库，此时查询的数据是正确的，然后紧接着将数据库更新后的数据写到缓存中了。到此为止，数据还是一致性的
2）存在的问题
（1）如果此时缓存中的数据过期了，那么线程1是拿不到数据的，直接查询数据库拿到一开始的10
（2）接下来线程2在线程1未同步到缓存前，先更新数据库，并且删除了缓存（此时缓存中key已经过期，删不删除都是一样的），线程2成功将数据更新成了20，但是线程1开始执行，将一开始读取到的10写入到了缓存中，又总成了数据的不一致！
我们继续回到上面的问题
写操作，要延迟双删
那么又有一个新的问题，就是为什么要删除两次缓存呢？
因为再次删除缓存，目的就是为了降低脏数据的风险
还又一个新的问题，为什么要延时删除呢？
因为数据库一般都是搭建主从集群的，所以要等待数据库的数据全部同步后开始删除缓存，否则还是会出现脏数据的情况。注意，这种方式没有绝对的一致性，延时多久不可预知，如果出现主从未完全同步时写入缓存，还是会导致脏数据
保证写操作强一致性的方法！！！！重头戏！！！！！！
1、加入分布式锁，来控制
2、进阶版
因为一般写入到缓存中的数据都是读多写少的情况，这个时候我们就不用分布式锁了，直接使用读写锁！
具体的代码实现：
下面的读写代码，一定可以实现强一致性！但是性能就很低了！
（1）读操作：
（2）写操作：
注意读写锁的锁要保持一致
允许延迟一致（保证数据的最终一致性）
1、异步通知来保证数据的最终一致性
2、基于Canal的异步通知
canal是基于MySQL的主从同步来实现的
会监听主节点的binlog文件，binlog二进制文件中记录了所有的DDLH和DML语句，但是不包括数据查询，比如select或者show语句。
当文件发生更新了，那么就会通知缓存数据变更的情况。这种方式是对业务代码0侵入的，如果我们的业务场景中允许数据短暂延时，这种方式还是相对推荐的
至此，关于双写一致性的推演介绍完毕，内容比较多，希望大家能够收藏反复学习，后续还会持续更新相关面试题，敬请期待！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f210d18ec35fb80d80875765932253/" rel="bookmark">
			Redis面经——哨兵模式的脑裂问题，详细介绍！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、脑裂问题
实际脑裂问题场景
1、由于哨兵和集群中的主从节点可能处于不同的网络分区，哨兵只能监测到从节点们，这个时候哨兵会发现监测的节点中没有主节点，那么他会经过选举产生一个新的主节点，但是客户端这个时候还是会持续的向老的主节点发送数据，新的主节点此时时没有新的数据写入的，这样就造成了类似大脑分裂的情况。
2、而当网络恢复后，哨兵会将老的主节点降为从节点，这时候再从新的主节点master中同步数据，老master会把自己节点中的数据清空，从而导致数据丢失
二、解决方案
修改Redis的两个参数来解决问题
min-replicas-to-write 1 #表示最少的slave节点为1个，这样就能保证如果出现网络问题，如果主节点没有从节点了，那么服务端拒绝写入数据，这样老的主节点是没有新数据产生的
min-replicas-max-lag 5 #表示数据复制和同步的延迟不能超过5秒
至此，关于脑裂问题的介绍已经完毕，后续还会持续更新，敬请期待！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1feb8fdc7fa527c970a4d9c5fe112783/" rel="bookmark">
			前端页面使用html2canvas生成图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先引入两个js文件： &lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/html2canvas.js"&gt;&lt;/script&gt; HTML代码： &lt;div id="app_name" &gt;生成图片&lt;/div&gt; &lt;hr /&gt; &lt;div id="div1"&gt; &lt;img src="/image/ercode.jpg" style="width: 100%;" /&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;p&gt;123&lt;/p&gt;	&lt;p&gt;123&lt;/p&gt; &lt;p&gt;123&lt;/p&gt; &lt;/td&gt; &lt;td align="center"&gt; &lt;img src="img/index.jpg" height="80" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;span&gt;● 生成图片 &lt;/span&gt;&lt;br /&gt; &lt;span&gt;1.生成图片；&lt;/span&gt;&lt;br /&gt; &lt;span&gt;2.生成图片；&lt;/span&gt;&lt;br /&gt; &lt;span&gt;3.生成图片；&lt;/span&gt;&lt;br /&gt; &lt;span&gt;4.生成图片；&lt;/span&gt;&lt;br /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;td colspan="2" class="weixin-tip"&gt; 此处是动态生成的二维码	&lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;td colspan="2" style="font-size: 14px;"&gt;啦啦啦&lt;/td&gt; &lt;/tr&gt; &lt;tr align="right"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1feb8fdc7fa527c970a4d9c5fe112783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa650aca40a135a191cab7eefcdc4d9/" rel="bookmark">
			Vite&#43;Vue3使用Vue-i8n笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载依赖 vue-i18n yarn add vue-i18n 创建存放语言文件的目录 以及配置文件的配置 我是在src/lang 新建index.ts、cn.ts、en.ts以及test文件夹其中再分别新建cn.ts以及en.ts
/lang/index.ts 用于导出vue-i18n需要的配置对象
import en from "./en.ts"; import zh from "./cn.ts"; const messages = { en, zh, }; const language = ( // 读取本地浏览器语言环境中文 zh-CN 英文 eng (navigator.language ? navigator.language : navigator.userLanguage) || "zh" ).toLowerCase(); export default { fallbackLocale: "zh", legacy: false, // composition API globalInjection: true, //全局生效$t locale: language.split("-")[0] || "zh", // 默认zh翻译 messages, }; /src/lang/en.ts 以及同目录下的cn.ts用于收集模块的语言文件并统一提供给Index.ts导出
import test from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faa650aca40a135a191cab7eefcdc4d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5503c25df0e94e51a492836729deb71/" rel="bookmark">
			UnityUI看向相机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注释 在项目中经常会用到名字始终看向相机，可以挂上如下代码
using UnityEngine; public class LookAtCamera : MonoBehaviour { public Camera _camera; public void Start() { _camera = Camera.main; } void Update() { //transform.LookAt(transform.position + _camera.transform.rotation * Vector3.forward, _camera.transform.rotation * Vector3.up); transform.eulerAngles = new Vector3(_camera.transform.eulerAngles.x, _camera.transform.eulerAngles.y, 0); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a6eaacc70c8b0a8995e8ccd782d9a0/" rel="bookmark">
			js 判断数据是不是{}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js 判断数据是不是{} var aa={} 1.JQ的方法（推荐）
$.isEmptyObject(aa) 返回true 2.将对象装换成JSON字符串，再判断是否为“{}”
var b = (JSON.stringify(aa) == "{}"); 3.Object.getOwnPropertyNames()方法
4.使用ES6的Object.keys()方法
var bb = Object.keys(aa) alert(bb.lenght =='0') //true 另外还可以使用 typeof 运算符来判断一个数据是否为对象，并且可以使用 Object.keys() 方法来判断一个对象是否为空对象（即是否没有任何属性）。
以下是一个示例代码：
function isObjectEmpty(data) { if (typeof data !== 'object') { return false; } return Object.keys(data).length === 0; } console.log(isObjectEmpty({})); // true console.log(isObjectEmpty({ key: 'value' })); // false console.log(isObjectEmpty('string')); // false console.log(isObjectEmpty(123)); // false console.log(isObjectEmpty(null)); // false console.log(isObjectEmpty(undefined)); // false 上述代码中，isObjectEmpty() 函数接受一个参数 data，首先使用 typeof 运算符判断 data 的类型是否为对象，如果不是，则返回 false。如果是对象，则使用 Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4a6eaacc70c8b0a8995e8ccd782d9a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f876a4b59a74b3998452cb04c364ffca/" rel="bookmark">
			Python爬取猫眼电影专业评分数据中的应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据分析和可视化展示中，获取准确的电影专业评分数据至关重要。猫眼电影作为中国领先的电影信息与票务平台，其专业评分对于电影行业和影迷的数据来说具有重要意义。通过Python爬虫技术，我们可以实现从猫眼电影网站上自动获取这些数据目标。通过编写爬虫程序，我们可以模拟浏览器行为，访问猫眼电影网站并提取所需的专业评分数据，为后续的数据分析和可视化提供支持。
为了实现自动获取猫眼电影专业评分数据的目标，我们需要编写一个高效的Python爬虫程序。通过分析猫眼电影网站的页面结构和网络请求，我们可以找到包含专业评分数据的接口，并编写相应的爬虫代码来实现数据的自动抽取。
首先，我们将介绍如何使用Python的Requests库和BeautifulSoup库来抓取猫眼电影网站上的专业评分数据。Requests库是一个简单易用的HTTP库，用于发送网络请求和获取响应数据。BeautifulSoup库则是一个用于解析HTML和XML文档的Python库，可以帮助我们从网页中提取所需的数据。
# 导入所需的库 import requests from bs4 import BeautifulSoup import pandas as pd import matplotlib.pyplot as plt # 设置代理信息 proxyHost = "www.16yun.cn" proxyPort = "5445" proxyUser = "your_proxy_user" proxyPass = "your_proxy_password" # 设置代理 proxyMeta = "http://%(user)s:%(pass)s@%(host)s:%(port)s" % { "host": proxyHost, "port": proxyPort, "user": proxyUser, "pass": proxyPass, } proxies = { "http": proxyMeta, "https": proxyMeta, } # 设置请求头，模拟浏览器访问 headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f876a4b59a74b3998452cb04c364ffca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a13b6a38ab9229eedfcdba6c34a345a/" rel="bookmark">
			基于Skywalking开发分布式监控（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接手为微服务系统搞链路监控项目一年多，也和skywalking打了一年多的交道，也应该有个总结，主要谈一下搭建监控系统遇到的难点和解决方案。
说明： 本文的代码均由本地演示代码替代，非实际代码
为啥选skywalking，因为由于微服务分成多个团队在开发，有平台，有应用，日志分析已经力不从心，下决心引入分布式监控，skywalking对我们来说有两个基本好处，1） 代码入侵非常低（最后仅仅在多线程跟踪，加了几处装饰器），监控基本可以独立安排版本或者变更，这对管理友好 2） Agent+插件模式对应用性能影响不大，预估不太会出幺蛾子…
开发过程中，我们遇到一些问题，本篇先聚焦第一个问题：
Agent插件二次开发，分两类
1） 修改，例如对dubbo-plugin，把DubboInstrumentation.java中
public class DubboInstrumentation extends ClassInstanceMethodsEnhancePluginDefine { // add logger private static final ILog LOGGER = LogManager.getLogger(DubboInstrumentation.class); private static final String ENHANCE_CLASS = "com.alibaba.dubbo.monitor.support.MonitorFilter"; //需修改 private static final String INTERCEPT_CLASS = "org.apache.skywalking.apm.plugin.dubbo.DubboInterceptor"; @Override protected ClassMatch enhanceClass() { return NameMatch.byName(ENHANCE_CLASS); } @Override public ConstructorInterceptPoint[] getConstructorsInterceptPoints() { return null; } @Override public InstanceMethodsInterceptPoint[] getInstanceMethodsInterceptPoints() { return new InstanceMethodsInterceptPoint[] { new InstanceMethodsInterceptPoint() { @Override public ElementMatcher&lt;MethodDescription&gt; getMethodsMatcher() { //LOGGER.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a13b6a38ab9229eedfcdba6c34a345a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da71b18191d30684213c40592c931114/" rel="bookmark">
			UnitTest自动化测试框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、UnitTest单元测试框架提供了那些功能 1.提供用例组织和执行
如何定义一条“测试用例”?
如何灵活地控制这些“测试用例”的执行?
2.提供丰定的断言方法
当测试用例的执行结果与预期结果不一致时，判定测试用例失败。在自动化测试中，通过“断言”来判定测试用例执行成功与否，测试框架提供丰富的断言方法，例如:判断相等/不相等包含/不包含、True/False等
3.提供丰富的日志
需要从结果中清晰地看出失败的原因。另外,我们还需要统计测试用例的执行结果，如总执行时间、失败测试用例数、成功测试用例数等，这些功能也是由单元测试框架提供的。
二、认识unittest 1.引入unittest模块，自定义的类必须要继承unittest模块的TestCase类
2.创建的测试方法，必须以test开头
3.重要的概念
3.1 TestCase
Test Case是最小测试单元,用于检查特定输入集合的特定返回值。unittest提供的TestCase基类被自定义的测试类进行继承,它可以用来创建新的测试用例
3.2 TestSuite
测试套件事测试用例\测试套件或者两者的集合,用于组装一组要运行的测试
3.3 Test Runner
Test Runner是一个组件,用于协调测试的执行并向用户提供结果。Test Runner可以用图形界面、文本界面或返回特殊值来展示执行测试的结果
3.4 Test Fixture
Test Fixture代表执行一个或多个测试所需的环境准备,以及关联的清理动作。
三、断言方法 四、测试用例的组织 1、unittest中的TestLoader类提供的discover()方法可以从多个文件中查找测试用例
2、找到指定目录及其子目录下的所有测试模块，只有匹配的文件名才能被加载,如果启动的不是顶层目录,那么顶层目录必须单独指定
discover(start_dir,pattern=’ test*.py’ ,top_level_dir=None) 3、start_dir:待测试的模块名或测试用例目录
4、pattern= 'test*.py’:测试用例文件名的匹配原则
5、top_level_dir:测试模块的顶层目录,如果没有顶层目录,则默认为None
五、测试用例的执行顺序 多个目录&gt;多个测试文件&gt;多个测试类&gt;多个测试方法
执行多级目录的测试用例
unittest默认按照ASCII码的顺序加载测试用例(字母与数字顺序为0-9,A-Z,a-z)
执行多级子目录下放一个__init__.py文件,该文件的作用是将一个目录标记一个标准python模块 import unittest test_dir = './test_case' suite=unittest.defaultTestLoader.discover(test_dir, pattern='test*.py') if __name__ == '__main__': runner = unittest.TextTestRunner() runner.run(suite) 六、跳过测试和预期失败 七、数据驱动应用 安装方式
pip install parameterized
使用方式
通过@parameterized.expand()去装饰测试用例,expand中的每个元组都被认为是一条测试用例,元组中的数据就为测试用例变化的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da71b18191d30684213c40592c931114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d357779e921f918b138d27ee248332b0/" rel="bookmark">
			使用vscode查bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体操作 修改CMakeList.txt # set(CMAKE_BUILD_TYPE "Release")//注释Release模式 set(CMAKE_BUILD_TYPE "Debug")//设置为Debug模式 # set(CMAKE_CXX_FLAGS_RELEASE "-O3 -Wall -g")//注释 *这行代码是用来设置 CMake 构建系统中 Release 模式下 C++ 编译器的标志（flags）。 set: 这是 CMake 中用于设置变量的命令，它将一个变量设置为指定的值。 CMAKE_CXX_FLAGS_RELEASE: 这是一个预定义的 CMake 变量，用于存储 Release 模式下 C++ 编译器的标志。 "-O3 -Wall -g": 这是被设置的值，它是一个字符串，包含了一系列的编译器标志。具体解释如下： -O3: 启用高级优化级别，这通常会提高代码的执行速度。 -Wall: 启用警告信息，让编译器产生更多的警告，帮助开发者发现潜在的问题。 -g: 在生成的可执行文件中包含调试信息，以便在调试时能够获取更多的信息。 因此，这行代码的作用是在 Release 模式下，为 C++ 编译器设置了一些优化和调试相关的标志，以提高代码性能并帮助调试。* 点击 creat a launch .json file. 在vscdoe右下角会出现一个蓝色按钮“Add Configuration”，点击这个蓝色按钮，创建一个launch.json文件，该文件位于工作空间的.vscode隐藏文件夹下。launch.json文件内容默认如下： { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d357779e921f918b138d27ee248332b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f96eb60e3ca3fb38d06d177326bbd85/" rel="bookmark">
			力扣hot100 螺旋矩阵 模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem: 54. 螺旋矩阵
文章目录 思路💖 收缩边界法 思路 👨‍🏫 参考题解
💖 收缩边界法 ⏰ 时间复杂度: O ( n m ) O(nm) O(nm)
🌎 空间复杂度: O ( 1 ) O(1) O(1)
class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { if (matrix.length == 0) return new ArrayList&lt;Integer&gt;(); int l = 0;// 左边界 int r = matrix[0].length - 1;// 右边界 int t = 0;// 上边界 int b = matrix.length - 1;// 下边界 List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (true) { for (int i = l; i &lt;= r; i++)//顶部 从左到右 res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f96eb60e3ca3fb38d06d177326bbd85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d123b573eacc93db53e01e28d42d9e60/" rel="bookmark">
			springboot127基于Springboot技术的实验室管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 【毕设源码推荐 javaweb 项目】基于springboot+vue 的
适用于计算机类毕业设计，课程设计参考与学习用途。仅供学习参考， 不得用于商业或者非法用途，否则，一切后果请用户自负。
看运行截图看 第五章 第四章 获取资料方式 **项目编号：springboot **
**源码合集(千套源码任你挑)：www.yuque.com/mick-hanyi/javaweb **
**源码下载：私小编 **
项目包含 开发环境 jdk: JDK 1.8部署工具：IntelliJ IDEA 2023.xx/Eclipse.xxx数据库：Mysql 5.7.20Tomcat: Tomcat 8.0.xx/9.0.xx 项目内容 实验室管理系统 摘要
随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了实验室管理系统的开发全过程。通过分析实验室管理系统管理的不足，创建了一个计算机管理实验室管理系统的方案。文章介绍了实验室管理系统的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本实验室管理系统管理员功能有个人中心，学生管理，教师管理，公告信息管理，知识库管理，实验课程管理，实验室信息管理，实验室预约管理，实验设备管理，采购记录管理，维修记录管理，系统管理。学生和教师都是可以注册登录，查看实验室相关信息。因而具有一定的实用性。
本站是一个B/S模式系统，采用Spring Boot框架，MYSQL数据库设计开发，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得实验室管理系统管理工作系统化、规范化。本系统的使用使管理人员从繁重的工作中解脱出来，实现无纸化办公，能够有效的提高实验室管理系统管理效率。
**关键词：**实验室管理系统；Spring Boot框架；MYSQL数据库
**
**
1系统概述 1.1 研究背景 随着计算机技术的发展以及计算机网络的逐渐普及，互联网成为人们查找信息的重要场所，二十一世纪是信息的时代，所以信息的管理显得特别重要。因此，使用计算机来管理实验室管理系统的相关信息成为必然。开发合适的实验室管理系统，可以方便管理人员对实验室管理系统的管理，提高信息管理工作效率及查询效率，有利于更好的为人们服务。
1.2研究目的 随着互联网技术的快速发展，网络时代的到来，网络信息也将会改变当今社会。各行各业在日常企业经营管理等方面也在慢慢的向规范化和网络化趋势汇合。实验室管理系统的信息化程度体现在将互联网与信息技术应用于经营与管理，以现代化工具代替传统手工作业。无疑，使用网络信息化管理使信息管理更先进、更高效、更科学，信息交流更迅速。
对于之前实验室管理系统的管理，大部分都是使用传统的人工方式去管理，这样导致了管理效率低下、出错频率高。而且，时间一长的话，积累下来的数据信息不容易保存，对于查询、更新还有维护会带来不少问题。对于数据交接也存在很大的隐患。如果采用电子化的存储方式就会带来很大的改善，而且给用户的查询带来了很大便利，因此设计一个实验室管理系统刻不容缓，能够提高信息的管理水平。
1.3系统设计思想 一个成功的网站应明确建设网站的目的，确定网站的功能，确定网站规模、投入费用，进行必要的市场分析等。只有详细的策划，才能避免在网站建设中出现的很多问题，使网站建设能顺利进行。同时，一个大型的计算机网站系统，必须有一个正确的设计指导思想，通过合理选择数据结构、网络结构、操作系统以及开发环境，构成一个完善的网络体系结构，才能充分发挥计算机信息管理的优势。根据现实生活中网民的实际需求，本系统的设计按照下述原则进行。
有效性：实际上这里的有效性包括两个方面的意思：有用性和可用性。有用性是指站点潜在的能满足用户需求的功能，而可用性是指能够通过站点的操作实现特定的目标。可以看出一个站点如果不能恰当运行或设计得非常槽糕就不是一个好站点。可用站点的效益应该非常高，并易于学习，在实现用户目标时令人满意而不出错。高可靠性：一个实用的网站同时必须是可靠的，本设计通过合理而先进的网络设计以及软、硬件的优化选型，可保证网站的可靠性与容错性。高安全性：在设计中，将充分利用网络软、硬件提供的各种安全措施，既可以保证用户共享资源，充分考虑系统及数据资源的容灾、备份、恢复的要求。为系统提供强大的数据库备份工具。可以保证关键数据的安全性。操作权限级，设置不同的角色确保每一步的操作权限，可以由管理员进行设置。先进性：采用目前国际上最先进的开发技术，使用JSP开发技术，MYSQL作为网站后台数据库。采用这些技术降低了以后的系统运营成本，提高了系统的稳定性和易维护性。采用标准技术：本网站的所有设计遵循国际上现行的标准进行，以提高系统的开放性。外观和技术平衡：系统采用Web风格的界面设计，界面友好、美观，使用方便，易学易用。网站设计的关键问题是外观和技术的平衡。外现不好的网站令人厌烦，站点可以运行很好，但却不能带动用户积极性，相反，如果外观非常有表现力，但技术有限，用户则会感到非常失望。在外观与技术之间需要确定一个清晰而连续的关系，即外观与站点的意图相关，对不同类型的网站处理方法不同。 2相关技术 2.1 MYSQL数据库 MySQL是一个真正的多用户、多线程SQL数据库服务器。 是基于SQL的客户/服务器模式的关系数据库管理系统，它的有点有有功能强大、使用简单、管理方便、安全可靠性高、运行速度快、多线程、跨平台性、完全网络化、稳定性等，非常适用于Web站点或者其他应用软件的数据库后端的开发工作。此外，用户可利用许多语言编写访问MySQL数据库的程序。作为开放源代码运动的产物之一，MySQL关系数据库管理系统越来越受到人们的青睐，应用范围也越来越广。速度和易用性使MySQL特别适用于Web站点或应用软件的数据库后端的开发工作。
MYSQL数据库具有以下特点：
1、C和C ++中使用和测试，以确保源代码的编译器的便携性和灵活性。
2、支持多种操作系统AIX的，FreeBSD下，HP-UX，Linux和Mac OS中，Novell公司的Netware，OpenBSD系统，OS/2裹时，Solaris，Windows等。
3、提供了用于不同的编程语言的API。编程语言，如C, C ++，Python和Java的，的Perl，PHP，埃菲尔铁塔，Ruby和Tcl的。
4、以及使用的CPU资源来支持多线程。
5、算法优化查询SQL，切实提高搜索速度。
6、网络上的客户端和服务器可以用来编程任何独立的编程环境，也有中国，GB2312，BIG5，日文写作，一般基金，用于支持多国语言，并且可以嵌入在数据表和其他软件shift_jis访问柱可以用作的名称。
7、TCP / IP，ODBC和JDBC数据库，并提供连接到其他。
8、管理工具的管理，控制和优化数据库的操作。
9、可以数以千万计的记录在一个大的数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d123b573eacc93db53e01e28d42d9e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3dfd844021861de7a8ef5b010e7c6f/" rel="bookmark">
			优雅的控制协程(goroutine)的并发数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对golang熟悉的小伙伴都知道，在go中开启go协程是一件简单的事，只需要一个关键字”go“。
并且相比于线程，所需要的系统资源非常少。于是在程序中我们总会开启协程去并发获取数据。
例如：
商城首页，每个商品需要获取图片、价格、销量、店铺、优惠等等一系列信息。
如果单个单个的请求，肯定会由于响应太慢，流失用户。
于是我们自然的会想到使用并发去获取数据，组装后在返回给前端展示。
不过在微服务中，一般信息不会都存在自己这里，会有下游服务进行提供，为了保护自己的系统不会被高流量打垮，下游一般都会限制请求的qps。
比如你有50个商品，但是下游限制10个并发。那么我们就需要一种控制并发数量的手段去请求下游。
在golang中，channel 和 waitgroup 就是常用的控制并发请求的手段。下面我们就来实现一个通用的并发控制方法。
//定义通用函数，包装用户的业务函数，返回单次执行的result和error type fcWarp func(interface{}) (interface{}, error) /** goNum := 一共需要开启的协程数 data := 业务请求参数,必须是slice fc：定义通用函数，包装用户的业务函数，返回单次执行的result和error 返回： result：slice类型,包含多次请求的结果 resErrs :slice类型,包含多次请求中出现的err */ func concurrent(goNum uint, data interface{}, fc fcWarp)(result []interface{},resErrs []error) { if goNum &lt;= 0 { panic("goNum must positive") } vType := reflect.TypeOf(data) if vType.Kind() != reflect.Slice{ panic("data must slice") } vValue := reflect.ValueOf(data) limiter := make(chan struct{},goNum) result = make([]interface{},vValue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3dfd844021861de7a8ef5b010e7c6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5316359fb52327674a2c060cca3690df/" rel="bookmark">
			第十章认识Ajax(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识Ajax 概述：
Ajax是（Asynchronous JavaScript and XML） 异步JavaScript和XML的缩写，它是一种基于浏览器与服务器交互的Web开发技术。
Ajax通过使用JavaScript、XMLHttpRequest和DOM实现了在不刷新整个页面的情况下更新部分页面的能力。Ajax让网页能够达到更高的交互性和更好的用户体验。
特点：
异步传输：Ajax能够使用XMLHttpRequest在后台异步地发送和接收数据，不会对页面的加载和性能产生影响。
部分更新：通过JavaScript和DOM技术，Ajax可以对网页的某个部分进行更新，而不必刷新整个页面。
客户端脚本：Ajax的实现离不开JavaScript和DOM技术，这些技术可以使网页更加动态和交互。
跨平台、跨浏览器：Ajax可以在所有支持XMLHttpRequest的浏览器和平台上使用，因此具有很好的跨平台、跨浏览器的特性。
支持多种数据格式：Ajax可以支持多种数据格式，例如XML、JSON、HTML等，能够适应不同的应用场景。
提高用户体验：由于异步传输和部分更新的特性，Ajax能够提高用户体验，使得网页的加载速度更快，更加流畅。
Ajax 的优点包括：
减少页面刷新，提高了用户的交互体验。可以异步地发送和接收数据，可以避免页面等待。可以通过JavaScript和DOM来实现数据更新和操作，使得开发和维护更加容易。支持多种数据格式，如XML、JSON等。 Ajax 的缺点包括：
无法完全支持Web应用所有的用户操作，例如，需要支持后退按钮等功能。需要JavaScript支持，如果用户的浏览器禁用了JavaScript，则Ajax功能无法正常工作。对搜索引擎的支持不友好，因为它们无法处理动态生成的内容。Ajax的一些操作可能会增加服务器的负担，需要进行适当的优化。 Ajax的基本实现步骤 实现Ajax，首先要先创建服务器，然后配置Ajax对象，最后通过Ajax对象向服务器端发送请求来获取服务器端的响应
一、创建服务器
新建文件为D:code\chapter04，然后在此目录下新建server目录，并在server目录下下载Express框架（忘了可以去看第七章认识express框架的安装步骤），并新建app.js文件，编写如下代码
const express = require("express"); //引入Express框架模块 const path = require("path"); //引入node.js核心模块path，用于处理文件路径 const app = express(); //创建一个Express应用程序实例 app.use(express.static(path.join(__dirname, 'public'))); //设置静态文件目录。将public文件作为静态资源根目录 app.get("/first", (req, res) =&gt; { //定义一个GET请求的路由处理程序，当路径为/first时触发处理程序 res.send('hello,Ajax'); //发送响应给客户端，返回一个简单的文本消息 }); app.listen(3000); console.log('服务器启动成功！'); 这段代码的功能是创建一个简单的Express服务器，当访问路径为/first时，返回一个包含文本消息hello,Ajax的响应。静态文件目录的设置允许访问public文件夹中的静态资源。
注意：第四行代码中使用内置中间件express.static()来设置静态文件，其中path.join()方法用于拼接静态文件访问目录，__dirname表示绝对路径，public表示文件路径。
将上述代码编写完毕就可以在命令行中输入node app.js来启动端口
（提示：服务器虽然启动成功但可能无法显示页面信息，这需要配置一些需要用到的文件）
二、配置Ajax对象
在学会如何创建服务器之后，还需要去配置Ajax对象。首先需要先创建Ajax对象，然后使用open()方法来配置Ajax对象，最后使用send()方法发送请求。步骤如下：
创建Ajax对象的语法：
var xhttp = new XMLHttpRequest(); 配置Ajax对象的语法：
xhttp.open(method, url, async); //xhttp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5316359fb52327674a2c060cca3690df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73c5a7592e980c77136ca1d6c9ea7d2/" rel="bookmark">
			验厂的类型的流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【验厂的类型的流程】
在全球贸易一体化的进程中，验厂已经成为出口外贸企业真正与世界接轨的一道门槛，并且通过近几年的不断发展，验厂也逐渐为企业所熟知和充分重视。
如何正确理解验厂标准，实施有效的方案，满足验厂的要求，突破贸易壁垒，保持竞争优势，已成为许多企业在新形势下不得不解决的重大问题。
什么是验厂
验厂又叫工厂审核，俗称查厂，简单地理解就是检查工厂。
为什么要验厂
对于外商来说，验厂主要目的是保护其公司品牌形象。外商距离中国都很远，若合约工厂产品或管理出现问题，解决就很棘手。因此，为了减少这些不必要的麻烦，优化供应链管理，外商在进行采购前都会实施验厂，对合约工厂进行全面的评估，待合约工厂各方面都合格之后再下订单。
验厂的意义
通过验厂能有效地监督合约工厂的劳工、质量等问题，有利于保护和提升企业品牌的价值，避免公司声誉遭受损失。而且，欧美等发达国家通过法律、行政和投资贸易等手段，鼓励跨国公司监督国外工厂遵守劳工标准，制裁违反劳工标准的工厂。
验厂的类型
验厂一般分为人权验厂（社会责任验厂）、品质验厂（质量技术验厂）、反恐验厂（供应链安全验厂）、环境验厂等等。当然，也有人权反恐二合一、人权反恐质量三合一等一些整合性验厂。
1、人权验厂（社会责任验厂）：客户对劳工的权益、工作条件以及环境保护方面进行审核。
2、品质验厂（质量技术验厂）：客户对于工厂生产能力的评估，表明工厂有能力且持续的满足客户的要求和适用法规要求的合格产品生产。
3、反恐验厂（供应链安全验厂）：通过工厂本身来保障出口货物运输、使用安全的一套安全控制程序。
验厂的流程
验厂流程是指验厂过程进行中的次序或顺序的布置和安排。不同的客户或品牌审核的流程大致相同。
1、申请
2、计划
3、实施
4、改善
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/4/">«</a>
	<span class="pagination__item pagination__item--current">5/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/6/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>