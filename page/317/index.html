<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67720fb901d90b3496408264132aed5e/" rel="bookmark">
			远程服务器返回错误: (500) 内部服务器错误解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在.net中发送 xml post请求和接受xml 的post请求时，经常会遇到“远程服务器返回错误: (500) 内部服务器错误”。这里有2种解决办法： 第一种方法：修改请求端Content-Type 为“text/xml”(httpclient.Headers.Add("Content-Type", "text/xml");)
第二种方法：在我们平常开发异步接口的时候，往往需要开发一个windows service用来发送post请求（可以调用第一种方法）；另外需要提供一个web接收端接收对方的异步调用。当接收的post数据是xml时，对方调用你的提供的接口是就会出现“远程服务器返回错误: (500) 内部服务器错误。”。 这是请求验证所导致的，只需要禁用掉请求验证就可以正常通讯了。在&lt;@Page..%&gt;中设置 ValidateRequest="false" 即可。（这里无需修改Content-type）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f30e36830b3eb8fd1613c6e22bd1c66/" rel="bookmark">
			安装好cuda相关工具后发现原来基于mfc平台的opengl程序出现闪烁，最终解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改前，会闪烁，一开始以为是窗体view的OnEraseBkgnd函数无法禁止造成的，其实是像素格式的参数设置问题
修改前，会闪烁的设置：
// static PIXELFORMATDESCRIPTOR pfd={// sizeof(PIXELFORMATDESCRIPTOR),// 1,// PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER|PFD_SUPPORT_GDI|// PFD_TYPE_RGBA,// 24,// 0, 0, 0, 0, 0, 0,// 0,// 0,// 0,// 0, 0, 0, 0, // 32,// 0,// 0,// PFD_MAIN_PLANE,// 0,// 0,0,0// };// int pixelformat;// if ((pixelformat=ChoosePixelFormat(pDC-&gt;GetSafeHdc(),&amp;pfd))==0)// {// MessageBox(_T("choose pixelformat erro"),_T("erro"),MB_SYSTEMMODAL);// return FALSE;// }// if (SetPixelFormat(pDC-&gt;GetSafeHdc(),pixelformat,&amp;pfd)==0)// {// MessageBox(_T("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f30e36830b3eb8fd1613c6e22bd1c66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc4543755e3c40fad8cc3fa299a2c9b/" rel="bookmark">
			xml 文件 压缩与解压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 共3种 1.zip 2.gzip 3.bzip2 ... gzip 压缩器基于 DEFLATE 无损数据压缩算法，它使用 LZ77 算法和 Huffman 编码的组合。为了压缩数据，LZ77 算法使用对匹配数据的引用来取代数据部分。匹配数据已经通过编码器和解码器传递。Huffman 编码使用一种特定方法选择每个符号的表示，使用当时短位字符串的最常见的字符被使用，而不使用不常见的源符号。 bzip2 压缩器使用 Burrows-Wheeler 转换，将经常重复的字符序列转换成相同的字母字符串，然后应用 Move To Front 转换，最后使用 Huffman 编码。Burrows-Wheeler 变换排列字符的顺序可实现以下效果，如果原始字符串有经常出现的几个子字符串，那么变换后的字符串就会有几个地方出现一个字符，在一行中某个字符会重复出现多次。这种方法对于压缩非常有用，因为它往往容易压缩拥有多行重复字符的字符串。在实践中，[color=red]bzip2 压缩方法压缩文件的比率比使用 gzip 进行压缩的比率高，但是性能也较低。[/color] 参考 http://snowolf.iteye.com/blog/643010和 http://blog.csdn.net/buyaore_wo/article/details/7047343（代码） http://www.ibm.com/developerworks/cn/xml/x-datacompression/index.html（原理） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cdac62259bec2ca545202036805a8f9/" rel="bookmark">
			jQuery UI Autocomplete 体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要的参数 jQuery UI Autocomplete常用的参数有：
Source：用于指定数据来源，类型为String、Array、Function String：用于ajax请求的服务器端地址，返回Array/JSON格式 Array：即字符串数组 或 JSON数组 Function(request, response)：通过request.term获得输入的值，response([Array])来呈现数据；(JSONP是这种方式) minLength：当输入框内字符串长度达到minLength时，激活Autocomplete autoFocus：当Autocomplete选择菜单弹出时，自动选中第一个 delay：即延迟多少毫秒激活Autocomplete 其他不常用的就不罗列了。
使用方法 假如页面上有以下输入框：
&lt;input type="text" id="autocomp" /&gt; AJAX请求 通过指定source为服务器端的地址来实现，如下：
? 1 2 3 4 $( "#autocomp" ).autocomplete({ source: "remote.ashx" , minLength: 2 }); 然后在服务器端接收，并输出相应结果，注意默认传递的参数名称为term：
public void ProcessRequest(HttpContext context) { // 查询的参数名称默认为term string query = context.Request.QueryString["term"]; context.Response.ContentType = "text/javascript"; //输出字符串数组 或者 JSON 数组 context.Response.Write("[{\"label\":\"博客园\",\"value\":\"cnblogs\"},{\"label\":\"囧月\",\"value\":\"囧月\"}]"); } 本地Array/JSON数组 ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 本地字符串数组 var availableTags = [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cdac62259bec2ca545202036805a8f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7783a4b33210b009b173cc04e0c79076/" rel="bookmark">
			javax.script包探秘 javascript与java交互执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个包用来和JavaScript进行互操作,比如JAVA类可以调用JavaScript中的方法,而JS也可调用 JAVA中的方法. 1、可用的脚本引擎 Java 6提供对执行脚本语言的支持，这个支持来自于JSR223规范，对应的包是javax.script。默认情况下，Java 6只支持javascript脚本，它底层的实现是Mozilla Rhino，它是个纯Java的javascript实现。可以通过下面的代码列出当前环境中支持的脚本引擎： 1.ScriptEngineManager manager = new ScriptEngineManager(); 2. ListScriptEngineFactory&gt; factories = manager.getEngineFactories(); 3. for (ScriptEngineFactory f : factories) { 4. System.out.println( 5. "egine name:"+f.getEngineName()+ 6. ",engine version:"+f.getEngineVersion()+ 7. ",language name:"+f.getLanguageName()+ 8. ",language version:"+f.getLanguageVersion()+ 9. ",names:"+f.getNames()+ 10. ",mime:"+f.getMimeTypes()+ 11. ",extension:"+f.getExtensions()); 12. } 输出结果：egine name:Mozilla Rhino,engine version:1.6 release 2,language name:ECMAScript,language version:1.6,names:[js, rhino, javascript, javascript, ECMAScript, ecmascript],mime:[application/javascript, application/ecmascript, text/javascript, text/ecmascript],extension:[js]。 可以看到，Java内置只支持javascript一种脚本。但是，只要遵循 JSR223，便可以扩展支持多种脚本语言，可以从https://scripting.dev.java.net/上查找当前已被支持的脚本的第三方库。 2、hello script 接下来给出在Java中使用javascript的Hello world示例： 13.ScriptEngineManager manager = new ScriptEngineManager (); 14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7783a4b33210b009b173cc04e0c79076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f5b5e3eba84e56816b16907a95b84d4/" rel="bookmark">
			23种设计模式对比与总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式总结:
前言：个人觉得设计模式就是各个对象在不同的时机、不同的调用方被创建，组合结构和封装的侧重点有些不同，从而形成了各个模式的概念。
1. 简单工厂模式
通过在工厂类中进行判断，然后创建需要的功能类。
优点：不必使用具体的功能类去创建该类的实例。缺点：新增一个功能类就需要在工厂类中增加一个判断。
2. 策略模式
假设一个功能类是一个策略，调用的时候需要创建这个策略的实例，传进一个类似策略控制中心的方法中，然后通过策略基类调用这个传进去的实例子类的方法。
优点：就是相对工厂模式免去了创建那个功能类的判断，简化了工厂模式。缺点：就是把子类实例赋值给了父类，这样就丢掉了子类新增的功能。
3. 工厂方法模式(属于工厂模式)
把简单工厂模式中的工厂类，做了进一步的抽象为接口或抽象类，给各个功能创建一个对应的工厂类，然后在这个工厂类里面去创建对应的实例。
缺点：当新增一个功能类，就需要创建对于的工厂类，相比简单工厂模式，免去了判断创建那个具体实例，但会创建过多的类，还不如策略模式。
4. 装饰模式
一般情况下，当一个基类写好之后，我们也许不愿意去改动，也不能改动，原因是
这样的在项目中用得比较久的基类，一旦改动，也许会影响其他功能模块，但是，
又要在该类上面添加功能。使用继承，当在A阶段，写出继承类，用过一段时间，发
现又要添加新功能，于是又要从原始类或A阶段的类继承，周而复始，慢慢的，子类就越来越多，层级就越来越深。然而，事实上，在C阶段需要A阶段的功能，但不需要B阶段的功能，在这种复杂情形下，继承就显得不灵活，于是想到了装饰模式。
装饰模式：
需要扩展一个类的功能，或给一个类增加附加责任
需要动态地给一个对象增加功能，这些功能可以再动态地撤销。
需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。
在使用装饰模式前，需要了解虚方法和抽象方法的区别：虚方法，是实例方法，可以在子类中覆盖，也可以由该类对象直接调用。抽象方法需要写在抽象类中，抽象类不能实例化，所以要使用抽象方法必须由子类实现后方可调用。
该模式中，要被扩展的类可以是包含抽象方法的抽象类，也可以是包含虚方法的实例类，也可以是普通实例类。装饰模式就是在原有基类上做扩展，至于基类是什么性质并不重要.
装饰模式在C#代码，和扩展方法，惊人的类似。
5. 代理模式
代理类成为实际想调用对象的中间件，可以控制对实际调用对象的访问权限；维护实际调用对象的一个引用。
6. 原型模式
创建好了一个实例，然后用这个实例，通过克隆方式创建另一个同类型的实例，而不必关心这个新实例是如何创建的。
原型模式使用时需要注意浅拷贝与深拷贝的问题。
7. 建造者模式
每个对象都具备自己的功能，但是，它们的创建方式却是一样的。这个时候就需要中间这个建造者类来负责功能对象实例的创建。在调用端只需调用特定的方法即可。
这个和策略模式有点类似。
8. 抽象工厂模式
使用该功能类的功能类，利用抽象工厂去创建该功能类的实例。这样的好处在于尽可能的避免去创建功能的实例。
更牛逼的做法就是使用反射去创建这个功能类的实例，在调用端就一点都不需要知道要去实例化那个具体的功能类。这当然不是抽象工厂模式独有的。
9. 外观模式
外观模式：为外界调用提供一个统一的接口，把其他类中需要用到的方法提取出来，由外观类进行调用。然后在调用段实例化外观类，以间接调用需要的方法。这种方式形式上和代理模式有异曲同工之妙。
10.模板模式
模板模式：其实就是抽象出各个具体操作类的公共操作方法，在子类重新实现,然后使用子类去实例化父类。这个模板类其实可以使用接口替换。事实上接口才是专门用来定义操作规范。当然，当有些公共方法，各个子类均有一致需求，此时就不应使用接口，使用抽象类。
11. 状态模式
一个方法的判断逻辑太长，就不容易修改。方法过长，其本质就是，就是本类在不同条件下的状态转移。状态模式，就是将这些判断分开到各个能表示当前状态的独立类中。
12. 备忘录模式
备忘录模式：事实上我觉得这个东西没什么用，安照这种方式进行备份，会因为值类型与引用类型的不同而导致数据丢失。
13. 适配器模式
适配器模式：其实就是代理模式的一个变种，代码的编写方式都差不多。只是，使用这两种模式的出发点不一样，导致这两种模式产生了细微的差别。
14. 组合模式
当对象或系统之间出现部分与整体，或类似树状结构的情况时，考虑组合模式。相对装饰模式来说，这两个有异曲同工之妙，都强调对象间的组合，但是，装饰模式同时强调组合的顺序，而组合模式则是随意组合与移除。
15. 单例模式
能避免同一对象被反复实例化。比如说，访问数据库的连接对象就比普通对象实例化的时间要长;WCF中，维护服务器端远程对象的创建等，这类情况，很有必要用单例模式进行处理对象的实例化。
16. 迭代器模式
提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。
Foreach就是这种模式应用的代表。
17. 职责链模式
职责链模式：就是一个将请求或命令进行转发的流程，类似工作流。并且，也非常类似状态模式，它们共同的特点就是将一个复杂的判断逻辑，转移到各个子类，然后在由子类进行简单判断。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f5b5e3eba84e56816b16907a95b84d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666e039986a2efea1f59bdb75ddb73f2/" rel="bookmark">
			Agile Software - PLM (产品生命周期管理)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Agile软件公司　Agile Software公司于1995年创立于美国圣荷西，Agile是第一家专为电子制造业设计供应链标准模式的PLM（生命周期管理软件）厂商。 Oracle Agile的愿景是 “Deliver solutions that help companies work with their customers and suppliers to build better, more profitable products faster.” Agile软件用于全程跟踪企业产品。PLM( 产品生命周期管理)解决的是企业协同设计的问题，也就是在产品生命周期的各个环节使用同一种资料语言，实现ERP、SCM和CRM等各个 供应链系统的协同工作。Agile PLM解决方案就是针对上述的挑战的解决方案并提供各个产业在现今竞争激烈的环境拔得头筹。同时Agile PLM解决方案也可使企业完整管理从产品设计、询价、制造、销售与售后服务的整个环节。 Agile PLM解决方案由下列商业就绪(Business Ready)的解决方案所组成： ● Product Collaboration(产品协同) ● Product Cost Management(产品成本管理) ● Product Service &amp; Improvement(产品服务及改善) ● Product Portfolio Management(产品组合管理) ● Product Governance &amp; Compliance(产品管理与法令) ●Product Quality Management(产品质量管理) ● Engineering Collaboration(工程协同) ● Enterprise Visualization(企业可视化) Oracle(甲骨文)公司于2007年5月宣布并购Agile公司，并于2007年11月01日完成并购。 Agile客户 Oracle Agile目前在高科技电子制造业的客户可分为几种类型: EMS/CEM专业服务代工厂有Solectron、 Flextronics、 Jabil、SCI、Foxconn、USI 等 (Top 20中有17家为Agile用户) OEM/ODM 原厂有Dell、Compaq、 Gateway、 Philips Mobile Computing &amp; WebTV、 Lucent Technologies、 Texas Instruments、 Nokia、 Nortel、AMD、 Transmeta等; 日本方面有NEC、Hitachi、Sharp、Fujitsu、Fujifilm、Matsushita等; 在半导体业界则有Altera、Amkor、nVidia、Qualcomm等。 大中国地区之参考客户: 国内已成功导入上线的客户超过22家；如有鸿海NWING事业体、 广明光电、环隆电气、环隆科技、突破光电、环信通讯、纬创、 广达电脑、统宝光电、研华科技、 威达电、凌华科技、讯连科技及三希科技集团之 广州制造中心。鸿海与Xircom及Cisco之间的工程变更就是以Agile来处理，位置含盖美国、 台湾、大陆及 马来西亚，在Intel做客户品质稽核时曾给予相当高的评价。广明的上线状况也是非常良好，让使用单位简化了许多作业流程，对这套系统的稳定性并表示肯定。 Agile还要一套用于类似食品和医药行业的PLM系统，称为Agile PLM for Process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/666e039986a2efea1f59bdb75ddb73f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c39ccde9f35ca153e77687f32590c3/" rel="bookmark">
			教你通过修改配置文件让你的GPS导航仪提高搜星速率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面分享一下网友2012GPSHK航空兵关于修改凯立德配置文件让您的导航仪能几秒钟搜星的解决方法：
用UEDIT以十六进制方式打开pnavi.dll或者navione.dll（不同凯立德版本打开的程序不同）,搜索到$PSRF104（也即前文修改96000的同一位置），你会看到凯立德启动GPS时所用的指令“$PSRF104,0,0,0,96000,237759,922,12,4*2E&lt;CR&gt;&lt;LF&gt;”，其中4*2E表明首次启动GPS时用冷启动，但我怀疑可能凯立德每次启动GPS时都是用冷启动，故每次搜星定位速度都很慢，而且还会清除QuickGPS数据，因此，我将冷启动修改为热启动，即将前述的4*2E修改为1*2B，保存文件。OK！大功告成
下面是解释：试用一下修改后的凯立德，搜星定位速度超快，几乎都在两三秒钟内(记得在首次启动前更新QUICK GPS数据)。
解释： $PSRF104复位指令(主机输出)： $PSRF104,&lt;纬度偏移&gt;,&lt;经度偏移&gt;,&lt;高度偏移&gt;,&lt;时钟补偿&gt;,,,&lt;频道&gt;,&lt;复位选项&gt;*&lt;校验和&gt; &lt;纬度偏移&gt; 范围90到-90度，GPS定位准确的默认可为0。
&lt;经度偏移&gt; 范围180到-180度，GPS定位准确的默认可为0。
&lt;高度偏移&gt; GPS定位准确的默认可为0。
&lt;时钟补偿&gt; 为0时则调用上次存储的数据，默认为96000。默认为237759。这个参数可能用处不是很大，我这里串口**出来的数据为922。 &lt;频道&gt; GPS所用的频道，范围0到12。默认可为12。
&lt;复位选项&gt; 1=热启动,所有数据均有效 2=暖启动,星历清除
3=暖启动,星历清除并加载初始化数据 4=冷启动,清除内存所有的数据
8=清除内存中所有的数据并复位GPS回到出厂状态。
例子：热启动、暖启动、冷启动
$PSRF104,0,0,0,96000,237759,922,12,1*2B:
$PSRF104,0,0,0,96000,237759,922,12,2*28
$PSRF104,0,0,0,96000,237759,922,12,4*2E 温馨提示：对于新版的凯立德地图应是修改NaviOneSCH.dll文件，而不是navione.dll文件
欢迎测试！同时注意备份好配置文件，避免不成功无法恢复！
本篇文章来源于凯立德之家,转载请注明出处,详细网址：http://www.gpskld.com/html/48-2/2050.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2558e5a9a22ba9a1b03e1fdbef6bc5c/" rel="bookmark">
			“拖延症”的良方——对于追求完美，自制力差，情绪化的人很受用...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上大学以后，我开始有了拖延的毛病。立下目标无数，但时常却动力奇缺，常常在网上浏览着各色的小说和帖子，或是玩很无聊的弱智在线小游戏，却不愿碰专业书本或文献一下，甚至哪怕deadline就在几天之后，只有在deadline之前一点点时间才会因紧迫感而开始着手学习任务。这样下来，学业上总体来说算是马马虎虎，但却离自己的理想越来越远。总之，就是无法完全地上进，又不愿彻底地堕落。
拖延的基础，实际上是对自身很高甚至不切实际的期望。如果说完成任务是走过一块一人宽、十米长的厚木板，那么当它放在地面上时，几乎人人都可以轻松地走过。但对结果的高期望则像是将这块木板架到了两座高楼间十层楼高的地方，于是我们会害怕掉下去，即害怕失败或害怕成功(比如我有时偷偷希望实验不要成功，这样我就可以不用面对之后更大强度的后续实验，其实是害怕失败的一种变体)，于是我们甚至不敢向前迈上一步。而deadline则是身后的一团火，当它离我们足够近时，害怕被烧着的恐惧感战胜了对掉下去的恐惧感，于是我们一下子冲了过去，在deadline前赶完了任务，尽管质量很难说。
更可怕的是，很多拖延的人(包括我自己)甚至很享受那种deadline过后突然一下放松的感觉，而且拖延的结果有时反而挺好(比如我本科时写实验报告，如果我拖到最后，我往往可能因为能够和其他人讨论并参考其他人的观点而比我先完成要写得更全面更好)。这种时候，我会在心里表扬自己很有“效率”。同时，长期这样下来，尽管我不愿承认，但我潜意识里确实觉得自己如果花了很多时间成绩却平平，会是一件非常丢脸的事情。于是这一切的一切，都再次强化的拖延——即使结果不好，我也可以说，那是因为我没尽全力，如果我真正努力，肯定会结果很好的(心理学上的高自尊人格)。
但我们不能永远靠放火来逼自己走过木板，那样的话，总会有烧着自己的一天;而且，那种压抑的焦虑感和对自己不满意的感觉也并不令人愉快。因此，最好的办法是将木板的高度降低——不要对自己的结果(比如分数)太高的要求，认真完成就好。由于我们的天资和其它能力的限制，也许即使我们竭尽全力也无法像某些出众人物一样做得那么好，但不管怎么样，绝大多数情况下，尽力的结果都会比我们不去努力要来得好得多，不是吗?
对此在网上看到的一个帖子里有个非常有趣的方法。那位作者将一篇论文拖了几个月之久都不愿开写，她的心理师让她不要管好坏，以她可以写出的最差的论文为目标写一篇出来作为试验。作者照做了，然后惊讶地发现她写出来的“最差”的文章竟然挺让自己满意的，感觉稍做修改就可以交给导师过目了。当然，有时写出来的初稿和论文要求还是有差距的，比如要求12页但初稿只有5页。这种情况下作者就用了心理师教她的另一个方法：每次工作一个小时，目标是让论文多一页，同样以“最差”为目标。这个方法实际就是大大降低了拖延者做事的心理成本和负担，相当于把“木板”放到了“地面”上。不妨一试。
人的完美倾向，严重点就是完美主义，在拖延中也起了很大作用。当我想起幼时的远大理想并希望为之努力时，我只要想起我的同学中无处不在的“牛人”，便会觉得自己已经浪费了太多时间，而且别人现在不仅比我强得多，更因为他自身的优势而占有了比我更好的资源，所以我现在即使努力估计也赶不上他了，更别提什么远大的理想了，于是就又开始了拖延。
事实上，这就像是一场马拉松，你在开始因为种种原因落后于别人不少，于是你就开始纠结自己到底有没有跑下去的必要，却不努力去跑，于是被拉得更远。这时，你望着遥远的终点，感觉很绝望，都不想跑下去了。这时，如果你不去看不去想重点，也不去想别人，只看着自己的脚下跑——“管它呢，我先跑过这个小土丘再说。”就这样一个小目标一个小目标地跑，最终你一定会跑到终点线，那时你也许会发现，你并不是最慢的，甚至是很不错的。所以，专注于你努力的过程而非最后的结果，为你认真学习了一个下午或认真做了一个实验而不是最后考试的那个A或一个漂亮的实验结果而表扬自己，你会发现完成工作其实不怎么难。
另外，专注于当下对拖延者来说也是很需要注意的一个地方。这里说的专注于当下，不是指专注于你现在脑子里的想法和情绪，而是专注于你现在在做的或选择要做的事情。其实，很多拖延的人恰恰就是太过关注自己一时的情绪，比如觉得自己不开心了，得放松一下，上上网……然后就开始了拖延。其实从心理学角度来说，过于关注自己一时的情绪是不懂得推迟满足感的一种表现，就像小孩子想要一个玩具就非要马上得到不可一样，这样的做法会大大削弱一个人的自制力。而且，心理学实验表明，满足自己一时的情绪需求并非最佳策略，从长期角度上来讲，它会降低一个人的自我满足感和幸福感而非增加，想想因为玩乐休闲而拖延了工作后自己的负罪感和焦虑感就知道了。
在这个方面，我个人认为森田疗法的理念是很适用的。具体而言，就是不去理会那些打搅你的情绪波动(比如对自己说：“你要郁闷就郁闷吧，不管你了。”然后就不理会了)，顺其自然，专心做你要做的事情。就像一颗小石子投入湖中，会泛起一圈圈涟漪，你若不理，湖面最终会自己平静下来;倘若你过于注意那颗小石子，试图把它捞出来，反而会激起更大的波澜，使湖面不得平静。豆瓣那个帖子的作者提供了一个方法，我觉得也是很有用的：把你当时因为一时情绪想要做的事情(比如上网、玩游戏、看电影、看小说等等)记下来，告诉自己等你做完工作就去做那些事情，然后就专心工作，等到工作结束再去做记下的事情。
此外，不要为未来过度操心也是专注当下的一个方面。这点很容易理解，我就不在此赘言了。
同时，对于已经发生的不愉快的事情，或是对自己过去行为的不满，面对和接受好了，不必逃避。但面对和接受不是放任自流，而是不再沉浸于自责、痛苦等负面情绪中，客观地更好地理解当下的状况，进而为以后做打算。这一点可以和前文提到的“马拉松”的例子联系起来，只有真正面对和接受了你落后于别人的事实，你才不会为“我想得第一可是却落后别人那么多”之类的想法而纠结，进而才能以现实为基础，踏踏实实地努力去跑。
另外，在看书的时候(当然也有其它时候)，很多人都常有“刚才看了好几页却不知道讲了些什么”的“不自主飞翔”的神游体验。对此，养成发现新事物的习惯，像初生的婴儿一样去看世界，是很有好处的。无论在什么环境中，时刻注意那些熟悉的东西有什么变化，比如看书，就可以注意想想这书里讲的和我以前知道的有什么不同又有什么联系、有什么很有意思的地方等等，慢慢地，就能做到专注于当下而不至于迷失。
战胜拖延，追根究底，还是要改变自己的思维方式。这并不容易，但不是不可能。改变思维方式，尤其是改变潜意识，最重要的是要改变自我对话的方式。下面是一些自我对话的tips(括号里是要丢弃的自我对话方式)：
1.我选择/我想要……(vs.我必须/我一定得……)
2.这个任务我可以每次做一小步(vs.这个任务太大了)
3.我今天要开始做……(vs.我今天必须完成……)
4.我也可以是平凡人(vs.我必须完美/出类拔萃)
5.我一定要休息娱乐/休息娱乐是正常生活的一部分(vs.我没空休息娱乐/休息娱乐就是偷懒)
我想大多数有拖延情况的人也许都还没到严重成“症”的地步，但也或多或少地被它影响了生活，影响了对心中理想的追寻。克服一个问题并不简单，需要自己给自己很多的支持与鼓励，期间也许会有许多的反复，但只要我们的大方向是好的，我们就该肯定自己。
“认识到眼前残酷(这个词程度太深，但我想不出换什么好)的现实，同时又看到未来的光明与希望。”这是我一直很欣赏的对生活的态度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3647d9aed8111424e1204137d3bf02/" rel="bookmark">
			Python sort sorted函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、sort函数 sort函数是序列的内部函数 函数原型: L.sort(cmp=None, key=None, reverse=False) 函数作用: 它是把L原地排序，也就是使用后并不是返回一个有序的序列副本，而是把当前序列变得有序 参数说明： (1) cmp参数 cmp接受一个函数，拿整形举例，形式为: def f(a,b): return a-b 如果排序的元素是其他类型的，如果a逻辑小于b，函数返回负数； a逻辑等于b，函数返回0； a逻辑大于b，函数返回正数就行了 (2) key参数 key也是接受一个函数，不同的是，这个函数只接受一个元素,形式如下 def f(a): return len(a) key接受的函数返回值，表示此元素的权值，sort将按照权值大小进行排序 (3) reverse参数 接受False 或者True 表示是否逆序 sort举例： (1)按照元素长度排序 L = [{1:5,3:4},{1:3,6:3},{1:1,2:4,5:6},{1:9}] def f(x): return len(x) sort(key=f) print L 输出: [{1: 9}, {1: 5, 3: 4}, {1: 3, 6: 3}, {1: 1, 2: 4, 5: 6}] (2)按照每个字典元素里面key为1的元素的值排序 L = [{1:5,3:4},{1:3,6:3},{1:1,2:4,5:6},{1:9}] def f2(a,b): return a[ 1 ]-b[ 1 ] L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a3647d9aed8111424e1204137d3bf02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc18054389136a2ee9df6d07f387fc89/" rel="bookmark">
			127.0.0.1是什么地址？localhost呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多人会接触到这个ip地址127.0.0.1。也许你会问127.0.0.1是什么地址？
其实127.0.0.1是一个回送地址，指本地机，一般用来测试使用。大家常用来ping127.0.0.1来看本地ip/tcp睁不正常，如能ping通即可正常使用。对于大多数习惯用localhost的来说，实质上就是指向127.0.0.1这个本地IP地址。在操作系统中有个配置文件将localhost与127.0.0.1绑定在了一起。可以理解为本地主机的意思。你可以看下什么是hosts文件？hosts文件在哪里？这篇文章。127.0.0.1对于网站建设者来说是常常用到的。
127.0.0.1和localhost有什么区别？
相信有人会说是本地ip，曾有人说，用127.0.0.1比localhost好，可以减少一次解析，其实这两者是有区别的。 localhost也叫local ，正确的解释是:本地服务器 127.0.0.1在windows等系统的正确解释是:本机地址(本机服务器) localhot(local)是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。 127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。一般设置程序时本地服务用localhost是最好 的，localhost不会解析成ip（如果您对解析还不是很了解，请看DNS是什么意思？），也不会占用网卡、网络资源。有时候用localhost可以，但用127.0.0.1就不可以的情况就是在于此。猜想localhost访问时，系统带的本机当前用户的权限去访问，而用ip的时候，等于本机是通过网络再去访问本机，可能涉及到网络用户的权限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7cc6ac7c7065f9ae4c2a43dd0088276/" rel="bookmark">
			JAVA数据结构课后习题——2的100次方（mod5）是多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package Algorithm; public class Algorithm_modTest { public static void main(String[] args) { modProcess mp = new modProcess(2,100,5); mp.findModProcess(); mp.getResult(); } } class modProcess { int baseNumber; int exponent; int modNumber; int minExponent; int modResult; modProcess(int b,int e,int m) { this.baseNumber = b; this.exponent = e; this.modNumber = m; this.minExponent =1; this.modResult = 0; } public void findModProcess() { if(this.exponent&lt;this.modNumber) { this.modResult = getExponentValue(this.baseNumber, this.exponent)%this.modNumber; } else { this.minExponent = findMinExponent();	//找到最小的指数 int remainExponent = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7cc6ac7c7065f9ae4c2a43dd0088276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6bc66a14afb9aae67dca5e4d7a83abe/" rel="bookmark">
			Delphi 的RTTI机制浅探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		====================================================== 注：本文源代码点此下载 ====================================================== 目 录
===============================================================================
⊙ dfm 文件与持续机制(persistent)
⊙ readcomponentresfile / writecomponentresfile 函数
⊙ delphi 持续机制框架简述
⊙ 一个 tform 对象的创建过程
⊙ tstream class 和 tstream.readcomponent 方法
⊙ treader class 和 treader.readrootcomponent 方法
⊙ treader.readprefix 方法
⊙ tcomponent.readstate 虚方法
⊙ treader.readdata 方法
⊙ treader.readdatainner 方法
⊙ treader.readproperty 方法
⊙ tpersistent.defineproperties 虚方法
⊙ treader.readcomponent 方法
⊙ treader.readvalue / treader.nextvalue 系列方法
⊙ treader.readstr 方法
⊙ treader.readinteger / readstring / readboolean 系列方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6bc66a14afb9aae67dca5e4d7a83abe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452c6a04ecd9e6ef8debeb48bf5155ec/" rel="bookmark">
			《深入浅出MFC》学习笔记之Win32程序设计原理（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Win32程序开发流程：
win32程序分为程序代码和UI资源两大部分，程序代码由C编译器编译成.obj目标文件，UI资源（.rc文件）由RC编译器编译成.res文件，最后由连接器将.obj文件和.res文件以及所需的函数库连接成最终的EXE文件。
Windows程序支持动态联结，即应用程序所调用的Windows API函数是在程序运行期间才联结上的。联结时期所需要的函数库即动态链接库，.dll,.exe,.fon,.mod,.drv,.ocx都是所谓的动态链接库。
Windows程序调用的函数分为C Runtimes以及WIndows API两大部分。MSVCRT.DLL是C Runtime函数动态链接库。Windows三大模块GDI32.DLL，USER32.DLL， KERNEL32.DLL提供一部分API。
动态联结在程序执行时才联结上，但是在程序联结时期，联结器仍然需要为应用程序准备一些适当的信息，才能够在执行时期顺利跳到DLL执行。这些信息即所谓的 import函数库(以.LIB结尾的文件)，32位Windows的三大模块所对应的import函数分别为GDI32.LIB,USER32.LIB,KERNEL32.LIB。
二、以消息为基础，事件驱动。
WIndows程序的进行依靠外部发生的事件来驱动，即程序不断等待（利用一个while回路），等待任何可能的输入，然后做判断，然后再做相应的处理。上述的输入是由操作系统捕捉到后，一消息的形式进入程序之中。操作系统通过USER模块捕捉外围设备所发生的事件 。消息分为两类，由硬件装置产生的消息（鼠标键盘等），存放在系统队列（system queue）中，以及由windows系统或者其他windows程序传送过来的消息，存放在程序队列（application queue）中，但应用程序并不知道传送过来的消息是哪一种（实际上，它无需知道）。
接受并处理消息的主角是窗口，没一个窗口都应该有一个函数负责处理消息，程序员必须负责设计这个所谓的窗口函数（window procedure）。
三、一个windows应用程序基本结构
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/976b1e30679e9d44e675acfb404ff4a7/" rel="bookmark">
			POJO式开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POJO式开发 2011年03月17日 POJO POJO 就是简单 java 对象，不实现任何特殊接口。 POJO 这一名字由 Fower 、 Rebbecca 、 Parsos 、 Josh MacKenzie(Foeler POJO) 发明，目的地是为了给普通 Java 对象取个令人兴奋的、过目不忘的名字。 早期 EJB 及其存在的问题 EJB1.0 版本发布于 1998 年，它提供了两种企业 bean ：会话 bean 和实体 bean 。会话 bean 便是无状态服务或与客户端之间的有状态会话。实体 bean 表示数据库里的数据，最初意在实现业务对象。 EHB2 提炼了 EJB 编程模型。不仅增加了支持由容器管理的关系增强型实体 bean ，还新增了消息驱动 bean( 负责处理 Java Message Service 或 JMS ，消息 ) 。 EJB 存在的问题 尽管有很多书帮助开发人员对付 EJB ，并学会如何有效的使用 EJB ，但是 EJB 的；两个主要问题并没有直接解决。 第一， EJB 鼓励开发人员编写过程式应用程序 第二， 使用 EJB 开发相当麻烦 过程式设计的缺点： 对业务逻辑的组织方式主要有两种：过程式或面向对象。过程式方式以函数为单元组织代码，这些函数操作单独的简单数据对象。在过程式架构中，数据结构遍布各处，并作为参数传入函数，或返回给调用函数。 数据与操作之间的关系非常松散 ，并且完全由开发人员自己维护。在面向对象语言出现之前，这种编程方式主导了软件开发。 与之相比，面向对象方法则以对象为单元组织代码，这些对象 具有状态和行为 ，并与其他对象协作。 数据结构和操作定义在一个语言构造单元内，数据和对数据操作并存于其中。数据和操作之间的关系 ( 和状态 ) 由语言本省维护 。与过程式设计相比，面向对象设计更易理解、维护、扩展和测试。 如果业务逻辑够简单，过程式设计方法倒也不成问题，但是业务逻辑总有变得愈加复杂的趋势。一旦需求改变，业务逻辑就必须实现新的特性， EJB的代码量会不断增加。 EJB2 在一定程度上就是鼓励人们编写过程式代码， 实现新行为时，不必像设计真正的对象模型那样费心地识别类并赋予其职责。相反，你可以编写一个新的会话 bean 方法或在现有方法里添加代码 。 这钟过程式的设计方法，有些开发人员仍把持久对象简单的视为一种向数据库存取数据和编写过程式业务逻辑方法，这就是所谓的贫血模型 EJB 开发的麻烦： n 你必须面对恼人而长的编辑 - 编译 - 调试周期 n 你得面对关注点缺少分离的显示 n 你必须编写大量的代码才能实现一个 EJB n 你必须编写数据传输对象 (DTO) 用 POJO 开发 用 POJO 进行开发，仅有 POJO 本身还是不够的。在企业应用程序里，你还需要诸如事务管理、安全和持久化等服务，此前这些服务由 EJB 容器提供。现在的解决方案是使用所谓"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/976b1e30679e9d44e675acfb404ff4a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8b2b7947d37837ef40c939e1a405ed/" rel="bookmark">
			Qt之获取光标行列简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //通过textEdit的光标位置得到 光标所在行值，其中keyText是textEdit
QTextCursor cursor; cursor = keyText-&gt;textCursor(); int lineNumber = cursor.blockNumber();//获取光标所在列用cursor.columnNumber(); //当然也可以利用来获取 QTextBlock textBlock = textDocument-&gt;findBlockByLineNumber(lineNumber);//通过行号找到指定行 数据块 QString selectLine = textBlock.text();//将得到的数据存入一个字符串。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2475b49ecc26ee40fa42929d1c5d2109/" rel="bookmark">
			Qt代码实现QDialog对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在qt中可以直接利用Qt Creator做出一个简单的图形界面的，但是代码实现起来可以了解其中的机制，对美化界面做准备，下面只是一些简单的例子进行讲解
其中是定义一个QDialog对象，一个图形界面的，this代表了父窗口；
是一个定义一个行编辑器的，他的父窗口时findDlg；
是一个按钮的；
然后就是定义一个垂直布局的括号中的参数代表了父对象，并利用将行编辑器以及按钮加入到垂直布局中；
最后的是相当于信号和槽的定义go to slog，是利用代码实现。
QTextEdit是一个用来定义编辑框，其中有find的一个函数，第一个findText是待查找的文字，第二个参数是查找方式(向后，向前，全文等等)，在本例中是向后，返回值是一个bool类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59a733648fce692617c1a539e7039992/" rel="bookmark">
			利用request.getHeader(＂user-agent＂)获取客户端浏览器和操作-
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用request.getHeader("user-agent")获取客户端浏览器和操作系统信息
String Agent = request.getHeader("User-Agent");
StringTokenizer st = new StringTokenizer(Agent,";");
st.nextToken();
//得到用户的浏览器名
String userbrowser = st.nextToken();
//得到用户的操作系统名
String useros = st.nextToken();
取得本机的信息也可以这样：
操作系统信息
System.getProperty("os.name"); //win2003竟然是win XP？
System.getProperty("os.version");
System.getProperty("os.arch");
瀏覽器：
request.getHeader("User-Agent")
request.getHeader(“User-agent”)返回客户端浏览器的版本号、类型
getHeader(String name)：获得http协议定义的传送文件头信息，
request. getMethod()：获得客户端向服务器端传送数据的方法有GET、POST、PUT等类型
request. getRequestURI()：获得发出请求字符串的客户端地址
request. getServletPath()：获得客户端所请求的脚本文件的文件路径
request. getServerName()：获得服务器的名字
request.getServerPort()：获得服务器的端口号
request.getRemoteAddr()：获得客户端的IP地址 本文来自织梦
request.getRemoteHost()：获得客户端电脑的名字，若失败，则返回客户端电脑的IP地址
request.getProtocol()：
request.getHeaderNames()：返回所有request header的名字，结果集是一个Enumeration（枚举）类的实例
request.getHeaders(String name)：返回指定名字的request header的所有值，结果集是一个Enumeration（枚举）类的实例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc6d503503850ed3c3b7a9a415ec080/" rel="bookmark">
			Qt文件读取之QFile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt提供了QFile类来进行文件处理，为了更方便地处理文本文件或二进制文件，Qt还提了QTextStream类和QDataStream类， QFile file(fileName);
if(!file.open(QFile::WriteOnly|QFile::Text))//以只写方式打开文件，如果打开失败则弹出提示框并返回
{
QMessageBox::warning(this,tr("保存文件"),tr("无法保存文件 %1:\n %2").arg(fileName).arg(file.errorString()));
//%1,%2表示后面的两个arg参数的值，在""中会将变量当作普通字符串处理
return false;
}
QTextStream out(&amp;file);
out&lt;&lt;ui-&gt;textEdit-&gt;toPlainText();//将文本编辑器里的内容以纯文本的形式输出到流对象中
QTextStream in(&amp;file);
ui-&gt;textEdit-&gt;setText(in.readAll()); //将文件中的所有内容都写到文本编辑器中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb32571db2b42a1f849b49d70b59b2e1/" rel="bookmark">
			H3C s5500-SI-EI系列交换机 WEB界面登录配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置以太网交换机VLAN 1接口的IP地址为10.153.17.82，子网掩码为255.255.255.0。
[H3C]system-view
[H3C] interface vlan-interface 1
[H3C-VLAN-interface1] ip address 10.153.17.82 255.255.255.0
用户通过Console口，在以太网交换机上配置欲登录的WEB网管用户名和认证口令。
配置WEB网管用户名为admin，认证口令为admin，用户级别为3级。
[H3C] local-user admin
[H3C-luser-admin] service-type telnet [H3C-luser-admin] password simple admin
[H3C-luser-admin] authorization-attribute level 3
转载于:https://blog.51cto.com/1585205/765846
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db3a7dc39b80bf80c8432fd83ee4e89/" rel="bookmark">
			电脑公司特别版论坛常见问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑公司特别版论坛常见问题及解决方案 2011年11月29日 电脑公司特别版论坛常见问题及解决方案 [b]1、论坛新手教程－－请新手们进来看看！[/b] http://www.dhghost.cn/read.php?tid=2630 -----xxyz [b]2、电脑公司特别版常见问题解答[/b] 问：声卡驱动不了！装好但不发声，或装的过程中系统突然自动重启。 解答：目前集成驱动的自动识别能力尚未能达到百分之百的准确。体现在个别声卡和网卡可能会认错。最为明显的例子是，AD188X的声卡，会误认为是Realtek声卡。幸好在安装之前会弹出安装向导。此时，用户不要急着点击继续，而要先搞清楚声卡的类型。如果的确是Realtek的声卡，则可放心继续；如果发现实际上是AD188X的声卡，则点击：从列表或指定位置安装─→不要搜索，我要自己选择要安装的驱动程序，此时，会列出很多种类型的声卡。从中选择 SoundMAX即可（SoundMAX是AD188X芯片的驱动名称）。如果已经误装了，也可以在“设备管理器”里找到该硬件，按右键─→更新驱动，再重复上述步骤即可。如何知道该声卡实际上是什么类型？打开机箱看芯片，或在开始菜单找到“EVEREST”工具来检测。这是一名合格的技术员应具备的技能，在此不赘述。 ------------------------------------------------- 问：装好系统后找不到光驱！设备管理器里的光驱有个感叹号！ 解答：这是装错了声卡驱动造成设备冲突所致。如何装声卡驱动请看上一个解答。 ------------------------------------------------- 问：为什么网上邻居别的电脑访问不到我的电脑? 解答：XP要搞局域网本身就有诸多条目。本系统为了保障安全性，也没有事先搞好局域网。不过已经为用户充分考虑过了，做好了开通局域网共享的批处理文件，您只需执行一下即可。该批处理位于开始菜单--程序―装机人员工具―解决局域网共享。 另外，如果本机装了金山网镖，就会造成不能访问本机（连查看工作组都不行，可恶），要把金山网镖卸了，重启后，局域网才会恢复正常。 ------------------------------------------------- 问：日文和韩文输入法不能使用。无论怎么输，打出来的都是英文。 解答：日本和韩国的输入法在系统里占了60多M的空间（太大了）。我们是中国人，我们绝大部分人可能一辈子都用不上,所以删掉了。 输入法的目录在系统中的位置是： C:windowsime 如果确实需要日韩输入法，只需找部装有XP系统的电脑，把该目录整个拷过来，覆盖原有目录。日文、韩文输入法立即就可以恢复正常。 ------------------------------------------------- 问：为什么装这个系统后我的硬盘变成可插拨设备了，我以前不是这样的。 解答：你用的是nForce主板加串口硬盘。nForce芯片组驱动程序含特有的IDE驱动（叫nvidia IDE SW）。本系统集成了这个驱动并且自动安装了。系统托盘栏就出现一个可插拨设备的图标。你原来没这个图标是因为你没装这个驱动，性能未能得到充分发挥。 ------------------------------------------------- 问：我装好了，可是启动速度很慢！完全不是作者所说的进度条滚一圈半就可以过去！ 解答：启动速度的快慢不仅仅和系统有关，还和你的硬件设定有关，请逐一检查： 1、开机自检的表格中看看硬盘是什么模式，DMA模式是正常的，PIO模式是极慢的。若是PIO模式，请进入BIOS并装入默认值，再开机看看，应该就变回了DMA。 2、开机自检的表格中看看光驱是不是接在从盘了。如果是，将严重拖慢开机速度。因为启动时系统先检测主盘，然后再检测从盘，若主盘为空则在这里消耗几秒钟。请关机，把光驱接回主盘。不动硬件也可以，那就是在光驱所在的IDE属性里把主盘设为“无”即可。有些光驱出厂时跳线就设在从盘，如果你从来没留意过，那就请现在留意一下吧！ 3、硬盘(并口)应该使用80芯的数据线，请勿用40芯的光驱线来代替。光驱线的速度只能达到DMA33，而硬盘的速度可达DMA100或DMA133。 4、新一代的主板增加了SATA硬盘接口。而用户的硬盘一般只有一块。这就是说，总会有IDE口或SATA口是闲置的。每次开机时系统都要检测各个硬盘接口。没有挂接设备的接口，就会因检测而消耗几秒种的时间。所以这类主板启动滚动条多滚几圈（如Intel 865及以后的主板）。我们应在设备管理器里把闲置的IDE或SATA通道关闭。启动时即可达到滚一圈半的理想状态。如果你的硬盘是高转速、高密度的新款硬盘，那么进度条不到一圈即过。 问题：在线更新补丁到2006年3月1日后，发现不能通过微软正版验证了。其网页上提示：未能找到密钥。 解决办法：打开这个文件夹：C:Documents and SettingsAll UsersApplication DataWindows Genuine Advantagedata，内有data.dat，其属性是只读的，先把只读取消,用记事本打开该文件，把原有文字删除，再打上几个字母（随意即可）。保存，恢复只读属性。到微软验证网站看看，嘿，又可以通过正版验证了。就这样简单，方法跟以前网友公布的完全一样。 --------------------------------------- 问题：在线更新补丁后，开始菜单的“装机人员工具”里的“TCPIP并发连接数破解”无法运行，说版本不符，无法操作。 解决办法：更新补丁后tcpip.sys版本升级了，微软又把并发连接数设为10了，原破解工具不能再用。现在有新的破解工具，下载地址:http://www.51ct.cn/downinfo/420.html --------------------------------------- 问题：宽带拨号，拨上后，数秒内死机。 解决办法：据调查，受影响的是主板集成的8100芯片的网卡(用的是和8139一样的驱动)，通过局域网上网正常，但拨号上网会死机。造成此问题的原因是本系统集成的8139驱动有bug（驱动日期为2005.9.18）。请自行更换其它版本的8139驱动即可（或使用XP自带的8139驱动）。相信许多用户被这个问题困扰着，抱歉。 --------------------------------------- 问题：Office中的公式编辑器打出来的是乱码。 解决办法：这是系统删减了部分字体所致。是用XPlite 1.7（一个XP减肥软件）删减了“额外字体”。具体是什么字体尚不知道，不过把字体目录补充完整就可以解决。字体不是简单拷贝就可以了的，需要安装才生效。安装方法是：进入c:windows onts,在“文件”菜单下选择“安装新字体”。字体来源？你可以从网上邻居的某部机把fonts目录共享过来。 --------------------------------------- 问题：局域网互访，别的电脑访问本机，可以进入本机，但不能打开任何文件夹，提示：没有权限访问。 解决办法：据分析，这是本机打开Guest帐户所致。实验结果说明：需要对方是administrator帐户，才能正常访问，否则就出现上述问题。把guest帐户关闭，就可以解决了。关闭后，对方访问本机，弹出询问用户名和密码的对话框，填写正确后就可以访问了。 --------------------------------------- 问题：最近卡巴斯基杀毒软件升级病毒后，本系统被查到几个boot.ini相关的文件是木马。 解决办法：本系统的几个boot.ini是一键备份/一键恢复时用来替换原有的同名文件的，绝非木马。据分析，打开boot.ini，把C:grldr=DOS工具中的“DOS工具”加上双引号。卡巴斯基就不报木马了。 --------------------------------------- 问题：在小于256M内存的机（如128M）上安装，在恢复过程中提示虚拟内存不足，dllcache的恢复无法进行。 原因分析：虽然这里无法进行，但会推后到首次进入桌面后进行的，系统一样可以成功安装。出现此问题的原因是制作克隆之前把虚拟内存关闭了。这是某些教程上说的。事实证明此步骤多此一举。其它光盘制作者需留意了。 --------------------------------------- 问题：装完系统后以后，刻录机放入光盘，出现函数不正确！，可用空间为0。 解决办法：打开 IMAPI CD-Burning COM Service 服务即可,方法如下： 你可以右击“我的电脑”再选择“管理”，在打开的“计算机管理”窗口中双击“服务和应用程序”（左右窗口中的均可）再双击选择“服务”，在右边的窗口中，找到“IMAPI CD-Burning COM Service”项，双击之，在“启动类型”的下拉列表中选择“自动”，点“确定”之后，重新启动计算机。 ----------donghai [b]3、光盘刻录及使用的一些共性问题：[/b] 问：我下载的是RAR文件啊！我解开了，把里面所有文件刻到光盘了。但是这光盘怎么不能启动啊？ 解答：你看哪里知道是RAR文件？就因为看到有个WinRAR的图标，于是就解压？你应该看扩展名，不是RAR，是ISO，即光盘镜像。光盘镜像是不能把它解压的，解开后启动信息就丢失了。如果原下载文件已删除，那你就必须要重新下载。 ----------------------------------------- 问：我没有解压，我是直接刻那个iso文件的！但是怎么仍然不能启动？ 解答：怎么个直接法？直接把iso拖进编辑窗口就错了。正确的方法是：运行nero─→文件菜单─→打开，文件类型选择*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9db3a7dc39b80bf80c8432fd83ee4e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ea7d9cccc0286dc20a6c6efd873650/" rel="bookmark">
			【转】3D程序员面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【转】3D程序员面试题 2011年06月13日 [b]不知道是哪个公司的。。。[/b] [b]1.请介绍D3D或OpenGL中渲染对象时需要设置的3个矩阵及它们各自的作用[/b] [b]2.请简单介绍D3D的渲染流水线流程及各步骤的作用，以及实际应用中我们可以在这些步骤做些什么效果应用？[/b] [b]3.ZBuffer有什么作用，渲染任何物体时是否都一定要打开ZBuffer？为什么？[/b] [b]4.请介绍你所有知道的纹理Alpha混合方式，原理(公式)，以及他们的实际应用(做什么样的效果时需要这种方式) [/b] [b]5.请介绍你所知道的所有3D动画方式、实现原理，以及他们的实际应用(做什么样的效果时需要这种方式) [/b] [b]6.现在的显卡已经可以每秒渲染上千万个三角形以上(而一般的游戏场景也就几万个三角形)，而已已经有了很多自动的显示剪裁，是否意味着使用BSP或其他优化方法组织场景数据已经没有必要了？为什么？ [/b] [b]7.使用硬件支持的D3D灯光有什么优点和缺点，好的3D引擎一般用什么方法弥补这种缺点？[/b] [b]8.GF4 MX系列与GF4 TI系列显卡有什么不同点？这些不同有什么作用？[/b] [b]（答案在后面）[/b] 自己做了一下，1―3题基本没问题，第4看过但没刻意记，5―7题能答出一些，第8题完全不会，对硬件没怎么研究过。昨天还看了看育碧的笔试题，勉强能答出点，由此看来功力还是不够啊。。。― ― [b]答案：[/b] 1.世界矩阵(World Matrix)、视图矩阵(View Matrix)以及投影矩阵(Projection Matirx); 世界矩阵确定一个统一的世界坐标，用于组织独立的物体形成一个完整的场景; 视图矩阵就是我们能看到的那部分场景，由虚拟摄像机负责拍摄； 投影矩阵就是3维物体的平面影射.把三维场景在一个二维的平面上显示. 2.可分为两个阶段，T&amp;L和光栅化处理；主要步骤包括世界变换、视图变换、照明、投影变换、裁剪、w切分、视口变换等.通过渲染流水线可以得到视觉上的三维场景及其变换效果. 3.深度缓冲.作用是确保多边形能够正确的显示在它们本来的深度.对于两个物体以上的场景来说，一般都要求打开ZBuffer,否则可能出现非正常的立体感观. 4. 公式为: Color = (源颜色 * 源系数) OP (目标颜色 * 目标系数);其中OP（混合方式）有 加，减，反减，取最小，取最大; Alpha混合用于做半透明效果. 5.主要有关节动画、单一网格模型动画(关键帧动画)、骨骼动画.关节动画把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画,角色比较灵活Quake2中使用了这种动画;单一网络模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量,然后插值运算实现动画效果,角色动画较真实;骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点;骨骼按角色特点组成一定的层次结构，由关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观。皮肤网格每一个顶点都会受到骨骼的影响，从而实现完美的动画. 6.不是。MMORPG一个特别重要的问题就是同步，如果不使用优化方法组织场景数据，减轻计算负荷，在数据访问量过大时，可能会造成服务响应命令延迟的问题，从而造成玩家异步，严重损害网络游戏的可玩性。在时效与技术允许的情况下,依赖硬件处理的思想都不值得提倡。 7.硬件支持的D3D灯光使游戏逼真，渲染速度快,效果显著.但并非所有的硬件都支持D3D灯光。游戏引擎必须检测显示卡是否支持D3D灯光以决定是否依赖硬件抽象层(HAL)来完成这个渲染工作. 8.GF4 TI 是先进的硬件显示卡,性能好，价格高,完全支持DX8.1，有灯光效果和动态模糊等特效; GF4 MX 不支持DX8.1,渲染的图形质量没GF4 TI系列高,逼真度较低。 这个不同将导致3D程序员不得不考虑是否使用DX8里的一些已经不继续更新的内容,比如DirectShow等以及一些特殊动态链接库的使用问题. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b84ec67bc005563f5b7fcef011d2689/" rel="bookmark">
			Ubuntu Tab键不能补齐 解决问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在终端里输入：. /etc/bash_completion 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9b64e4983332b307ed78d33e532df07/" rel="bookmark">
			crontab 没有立即生效原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种是脚本执行了，但是报错：在crontab里调度运行，结果发现没有结果，查看/var/log/message 日志，发现crontab有执行，但是失败。 手动运行都是可以的，放在crontab里边发现就不能运行了。 处理方法：脚本中不要采用相对路径，全部改为绝对路径 第二种是编辑/var/spool/cron/user user为执行用户名，一般为root 如更改后不起效果，请重新加载cron： 处理方法： /etc/init.d/crond reload 第三种 用crontab -e 进行编辑 use the following command add entries to crontab should take effect right away.
#crontab -e
如还不行就从其服务：
处理方法：/etc/init.d/crond restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f7cf6aa6fc82d3b934e3c02000ed32/" rel="bookmark">
			所有的程序员都是自学成才
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我十几岁的时候就开始玩甲级级棒球。我水平很差，但当我决定要做好什么事时，最终总能如我愿。现在我是计算机专业 3 年纪的学生。在编程上，有些事情和体育是截然不同的：棒球教练可以教会你如何打棒球，但一个计算机教授却不能教你如何编程。
我很吃惊，在整个大一期间，我的老师或教授从来不点评我的代码，大二时更是如此。我们的作业很多，题目很难，但在完成了数据结构课上的 2000 行的代码后，我从来没有收到过老师的任何一条评论——只要程序能编译通过，单元测试显示没有错误，这就行了。直到遇到了一个小组开发的项目，我才认识到我的代码写的多烂，我才开始询问：好的程序应该如何写。
但是，什么样的代码才是好的代码？我花了大量的时间来提高代码的可读性，添加注释。我努力模仿 UNIX 的哲学观，力求简约，首先让程序能跑起来，在此基础之上，在需要的情况在进行优化。复杂的东西要逐步增加。除非必要，我不使用线程。但是，说实话，我不知道这是不是好的代码(说实话，我觉得自己水平很差)。
我很幸运，能和一群优秀同学一起工作，他们都是出色的程序员，他们在微软、谷歌、亚马逊等公司实习。他们的观点都很一致，认为自己的知识都是自己总结或从其他程序员那里学到的。即使是非常资深的软件工程师也有这样的看法。所以，我的结论是：
所有程序员都是自学成才的。
我受的教育给了我很好的基础：数据结构，算法，数据库设计，并行计算，网络编程，敏捷开发以及各种编程模式。但所有的这些，即使是它们使得编程更高效和更精巧，你仍然可能用错它们——我曾经看过一些学生在这些课程上学习成绩非常好，但写的代码却让人想哭。
我并不认为学过计算机科学、软件工程或得到一个大学文凭会有多大的用处，如果你想靠写代码为生，自学是你不可缺少的途径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ac852a89cceb1cb5b7a0da5c8a00d4/" rel="bookmark">
			所有程序员都是自学成才的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是从 All Programmers Are Self-Taught这篇文章翻译而来。
在我十几岁的时候就开始玩甲级级棒球。我水平很差，但当我决定要做好什么事时，最终总能如我愿。现在我是计算机专业3年纪的学生。在编程上，有些事情和体育是截然不同的：棒球教练可以教会你如何打棒球，但一个计算机教授却不能教你如何编程。
我很吃惊，在整个大一期间，我的老师或教授从来不点评我的代码，大二时更是如此。我们的作业很多，题目很难，但在完成了数据结构课上的2000行的代
码后，我从来没有收到过老师的任何一条评论——只要程序能编译通过，单元测试显示没有错误，这就行了。直到遇到了一个小组开发的项目，我才认识到我的代码
写的多烂，我才开始询问：好的程序应该如何写。
但是，什么样的代码才是好的代码？我花了大量的时间来提高代码的可读性，添加注释。我努力模仿UNIX的哲学观，力求简约，首先让程序能跑起
来，在此基础之上，在需要的情况在进行优化。复杂的东西要逐步增加。除非必要，我不使用线程。但是，说实话，我不知道这是不是好的代码(说实话，我觉得自
己水平很差)。
我很幸运，能和一群优秀同学一起工作，他们都是出色的程序员，他们在微软、谷歌、亚马逊等公司实习。他们的观点都很一致，认为自己的知识都是自己总结或从其他程序员那里学到的。即使是非常资深的软件工程师也有这样的看法。所以，我的结论是：
所有程序员都是自学成才的。
我受的教育给了我很好的基础：数据结构，算法，数据库设计，并行计算，网络编程，敏捷开发以及各种编程模式。但所有的这些，即使是它们使得编程更高效和更精巧，你仍然可能用错它们——我曾经看过一些学生在这些课程上学习成绩非常好，但写的代码却让人想哭。
我并不认为学过计算机科学、软件工程或得到一个大学文凭会有多大的用处，如果你想靠写代码为生，自学是你不可缺少的途径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8729f23d3d8b2ccfa4c057893f1640/" rel="bookmark">
			用dos的copy命令合并文件(如何消除结尾的1A结束符)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近公司Tenfore FeedHandler项目分割存储了大量的RawData文件。由于TenforeRawData非常大， 因此存储策略是每一小时存储一个rawdata文件。但在进行数据分析回放时，又希望将它们合并成一个大文件。刚开始是想到网上找一个第三方合并工具，后一想，dos的copy命令不是可以合并文件吗？ 马上试一下！ 例如，希望将a.dat和b.dat合并成c.dat。其中，a.dat二进制内容如下“30 78 30 31 30 78 30 32”，b.dat二进制内容如下“30 78 30 33 30 78 30 34”，写了个dos脚本merge.bat，内容如下：" copy a.dat+b.dat c.dat"。 但新生成的c.dat文件最后多了个结束符"1A"，c.dat文件内容如下“30 78 30 31 30 78 30 32 30 78 30 33 30 78 30 34 1A”。 后上网查找了一下原因，是由于copy命令默认是将目标文件和源文件均视为文本文件，因此新生成的文件带上了文本结束符"1A"。 解决的办法很简单，就是在拷贝时指明是拷贝二进制文件。 新的批处理内容如下：" copy /b a.dat+b.dat c.dat" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b328ec458480a0da14a210ca8846b57/" rel="bookmark">
			MIUI ROM可精简apk详细列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FC=force close(强制关闭或者等待) AccountsAndSyncSettings.apk　账户与同步设置（不需要同步的可删，删后会有对应功能FC）
AntiSpam.apk　防打扰（就是短信和电话防火墙黑名单，不喜可删，对应功能FC）
ApplicationsProvider.apk　应用程序支持服务（亲测可删，占内存的大户）
AppShare.apk　MIUI网盘（不需要可删，对应功能FC）
Backup.apk　MIUI备份（不需要可删，对应功能FC）
Bluetooth.apk　蓝牙（可删且删后蓝牙依旧有效，无FC）
Browser.apk　默认浏览器（不需要可删，无FC，但默认浏览器就没了，可用UC等替换）
Calculator.apk　计算器（不需要可删，无FC，但计算器就没了，可用第三方替换）
Calendar.apk　日历（不需要可删，对应功能FC）
CalendarProvider.apk　日历支持服务（日历的对应服务，删除日历就可删除此项）
CertInstaller.apk　证书安装器（对应WIFI服务，中国一般不会遇到证书加密的WIFI，所以鸡肋服务，可删）
CloudService.apk　云服务（备份的对应服务，不需要备份的可删，无FC）
Contacts.apk　MIUI联系人（删了就和通讯录白白，必留）
ContactsProvider.apk　MIUI联系人支持服务（删了就和通讯录白白，必留）
DefaultContainerService.apk　默认通讯录服务（删了就和通讯录白白，必留）
DeskClock.apk　桌面时钟（含系统自带闹钟，不需要删，可用第三方闹钟代替，无FC）
DownloadProvider.apk　下载管理器（不需要可删，删除后在线主题下载FC）
DownloadProviderUi.apk　下载内容查看器（不需要可删，无FC）
DrmProvider.apk　受数字版权保护的数据存储服务（国外下歌用，国内鸡肋，可删无影响，无FC）
Email.apk　电子邮件（可**大多国内电子邮箱如:163,设置较麻烦，网上有教程，不喜删，无FC）
FileExplorer.apk　MIUI文件管理（可以删，删后主题选择-&gt;从SD卡导入FC）
FM.apk　MIUI收音机（用耳机线做天线不费流量的收音机，国内电台通吃，不喜可删，无FC）
Gallery.apk　MIUI图库（不需要可删，但图库就没了，可用第三方替换）
Gmail.apk　谷歌G邮箱（不喜谷歌者或不需要可删，无FC）
GoogleBackupTransport.apk　谷歌备份传输（不喜谷歌者或不需要可删，无FC）
GoogleCalendarSyncAdapter.apk　谷歌日历同步适配器（不喜谷歌者或不需要可删，无FC）
GoogleContactsSyncAdapter.apk　谷歌联系人同步适配器（不喜谷歌者或不需要可删，无FC）
GooglePartnerSetup.apk　谷歌辅助装置（不喜谷歌者或不需要可删，无FC）
GoogleServicesFramework.apk　谷歌服务构架（不喜谷歌者或不需要可删，无FC）
HTMLViewer.apk　HTML浏览器（不需要可删，无FC）
LatinIME.apk　拉丁输入法（安卓默认输入法，删后无输入法，但可第三方替换，占内存大户，无FC）
Launcher2.apk　MIUI桌面（较卡但有文件夹功能且和MIUI整体最配不好取舍，可用第三方代替，可删）
LiveWallpapersPicker.apk　动态壁纸选择器（不喜动态桌面或省电可删，删除后对应功能FC）
MarketUpdater.apk　电子市场更新装置（不需要可删，删除后对应功能FC）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b328ec458480a0da14a210ca8846b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0898974cf5db1953399a6b32c8da90/" rel="bookmark">
			V4L2 - 基础知识/附图说明/易于理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Videofor Linux two(Video4Linux2)简称V4L2，是V4L的改进版。V4L2是linux操作系统下用于采集图片、视频和音频数据的API接口，配合适 当的视频采集设备和相应的驱动程序，可以实现图片、视频、音频等的采集。在远程会议、可视电话、视频监控系统和嵌入式多媒体终端中都有广泛的应用。
一、Video for Linux two 在Linux下，所有外设都被看成一种特殊的文件，成为“设备文件”，可以象访问普通文件一样对其进行读写。一般来说，采用V4L2驱动的摄像头设备文 件是/dev/v4l/video0。为了通用，可以建立一个到/dev/video0的链接。V4L2支持两种方式来采集图像：内存映射方式 (mmap)和直接读取方式(read)。V4L2在include/linux/videodev.h文件中定义了一些重要的数据结构，在采集图像的过 程中，就是通过对这些数据的操作来获得最终的图像数据。Linux系统V4L2的能力可在Linux内核编译阶段配置，默认情况下都有此开发接口。 V4L2从Linux 2.5.x版本的内核中开始出现。
V4L2规范中不仅定义了通用API元素(Common API Elements)，图像的格式(Image Formats)，输入/输出方法(Input/Output)，还定义了Linux内核驱动处理视频信息的一系列接口(Interfaces)，这些接 口主要有：
视频采集接口——Video CaptureInterface;
视频输出接口—— Video OutputInterface;
视频覆盖/预览接口——Video Overlay Interface;
视频输出覆盖接口——Video Output OverlayInterface;
编解码接口——Codec Interface。
二、应用程序通过V4L2进行视频采集的原理 V4L2支持内存映射方式(mmap)和直接读取方式(read)来采集数据，前者一般用于连续视频数据的采集，后者常用于静态图片数据的采集，本文重点讨论内存映射方式的视频采集。
应用程序通过V4L2接口采集视频数据分为五个步骤：
首先，打开视频设备文件，进行视频采集的参数初始化，通过V4L2接口设置视频图像的采集窗口、采集的点阵大小和格式;
其次，申请若干视频采集的帧缓冲区，并将这些帧缓冲区从内核空间映射到用户空间，便于应用程序读取/处理视频数据;
第三，将申请到的帧缓冲区在视频采集输入队列排队，并启动视频采集;
第四，驱动开始视频数据的采集，应用程序从视频采集输出队列取出帧缓冲区，处理完后，将帧缓冲区重新放入视频采集输入队列，循环往复采集连续的视频数据;
第五，停止视频采集。
1.视频采集的参数初始化
在Linux下，摄像头硬件已经被映射为设备文件“/dev/video0”，用open函数打开这个设备文件，获得其文件描述符fd_v4l2，然后对这个文件描述符进行参数初始化。
(1) 设置视频的采集窗口参数
设置采集窗口就是在摄像头设备的取景范围之内设定一个视频采集区域。主要是对结构体v4l2_crop赋值，v4l2_crop由一个 v4l2_buffer_type枚举类型的type和v4l2_rect类型的结构体c构成，来描述视频采集窗口的类型和大小。type设置为视频采集 类型V4L2_BUF_TYPE_VIDEO_CAPTURE。c是表示采集窗口的大小的结构体，它的成员Left和Top分别表示视频采集区域的起始横 坐标和纵坐标，width和height分别表示采集图像的宽度和高度。赋值后，用ioctl函数通过这个结构体对fd_v4l2进行设置。
struct v4l2_crop {enum v4l2_buf_type type;
struct v4l2_rect c;
};
(2)设置视频点阵格式和点阵大小
主要是对结构体v4l2_format进行赋值，它由type和联合体fmt构成，来描述视频设备当前行为和数据的格式。
把type赋值为视频采集类型V4L2_BUF_TYPE_VIDEO_CAPTURE，表示定义了一个视频采集流类型的buffer。fmt 中，pix为表示图形格式的v4l2_pix_format型结构体。需要设定pix里的几个变量，pixelformat表示采集格式，设置为V4L2_PIX_FMT_YUV420;width、height表示图像的宽度、高度，以字节为单位;sizeimage表示图像所占的存储空间大 小，以字节为单位;bytesperline表示每一行的字节数。赋值后，用ioctl函数通过这个结构体对fd_ v4l2进行设置。
struct v4l2_format
{ enum v4l2_buf_typetype;
union
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f0898974cf5db1953399a6b32c8da90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29346dd4b9e7a282b13a90d348aa6827/" rel="bookmark">
			下面的命令可以查出在域控中过去10周内没有登陆的计算名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面的命令可以查出在域控中过去10周内没有登陆的计算机名
dsquery computer -inactive 10 -limit 0
下面的命令可以直接从域控中删除这些计算机
dsquery computer -inactive 10 -limit 0 | dsrm
转载于:https://blog.51cto.com/wujunfeng/754724
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8b331261a9f6acfb5d7cf617a38375/" rel="bookmark">
			使用dumpbin命令查看dll导出函数及重定向输出到文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前查看dll导出函数，一般使用Viewdll等第三方工具。但由于Viewdll采用dephi编写，因此仅能查看32位的dll。其实微软已经帮我们提供一个查看dll导出函数的命令，嵌在VS开发环境中，可以查看32位和64位的dll。具体使用方法如下：（例如查看d:\a.dll的导出函数）
1. 进入VS开发环境，然后Tools -&gt; Visual studio 2010 Command Prompt
2. cd到d:\下
3. 输入命令d:\dumpbin /exports a.dll回车即可看到a.dll的所有导出函数
如果要重定向输出至b.txt文本文件，则命令格式如下：d:\dumpbin /exports a.dll /out:b.txt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c258520f20fe249c5f71aefe4836d9c/" rel="bookmark">
			MapReduce/GFS/BigTable三大技术资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MapReduce/GFS/BigTable三大技术资料 首先是在孟岩博客中发现以下内容：
Google的三大核心技术MapReduce、GFS和BigTable的论文都已经被翻译成高质量的中文；三篇论文的链接地址如下：
MapReduce：
http://blog.csdn.net/active1001/archive/2007/07/02/1675920.aspx
GFS:
http://blog.csdn.net/xuleicsu/archive/2005/11/10/526386.aspx
BigTale:
http://blog.csdn.net/accesine960/archive/2006/02/09/595628.aspx
然后在百度空间发现了一些内容加上自己找了些资料：
http://www.cnblogs.com/duguguiyu/archive/2009/02/22/1396034.html 分布式基础学习【一】 —— 分布式文件系统
http://www.cnblogs.com/duguguiyu/archive/2009/02/28/1400278.html 分布式基础学习【二】 —— 分布式计算系统（Map/Reduce） MapReduce:
http://blog.csdn.net/active1001/archive/2007/07/02/1675920.aspx MapReduce:超大机群上的简单数据处理
http://codex.wordpress.org.cn/MapReduce MapReduce
http://zh.wikipedia.org/w/index.php?title=MapReduce&amp; MapReduce维基百科 http://en.wikipedia.org/wiki/MapReduce MapReduce Wikipedia
http://www.phpchina.com/html/67/t-164467.html Meng Yan 解析的Map Reduce - the Free Lunch is not over? http://news.mydrivers.com/1/98/98013.htm Google每天处理20PB数据 37倍于三年前
Tinyfool：什么是MapReduce? Google的分布运算开发工具!
梦想风暴：MapReduce
SQLiu：从Map和Reduce说起
is03kyh：My Map Reduce
田春峰：MapReduce:Google的人间大炮
Xerdoc：Map Reduce - the Free Lunch is not over?
IcyRiver：MapReduce与Database之争
http://book.51cto.com/art/200907/140632.htm 3.4.1 MapReduce分布式处理技术
http://www.hadoop.org.cn/mapreduce/nutch-mapreduce/ Nutch中MapReduce的分析
http://pages.cs.wisc.edu/~gibson/mapReduceTutorial.html MapReduce: HowTo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c258520f20fe249c5f71aefe4836d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d594c392d840fafec077533d6b301a55/" rel="bookmark">
			去掉linux文件中^M符号方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux下，不可避免的会用VIM打开一些windows下编辑过的文本文件。我们会发现文件的每行结尾都会有一个^M符号，这是因为 DOS下的编辑器和Linux编辑器对文件行末的回车符处理不一致， 对于回车符的定义： windows：0D0A unix\linux: 0A MAC: 0D 比较快捷的去除这些符号的方法有这么几种： （1）是用VI的命令： 使用vi打开文本文件 vi dos.txt 命令模式下输入 :set fileformat=unix :w (2) VI下使用正则表达式替换 g/\^M/s/\^M// 或者 %s/^M//g （3）使用sed 工具 sed ’s/^M//’ filename &gt; tmp_filename （4）既然window下的回车符多了‘\r’，那么当然通过删除‘\r’ ，也可以实现： tr -d '\r' （5）最后一个方法是本人最常用的方法，个人觉得最方便 在终端下敲命令： $ dos2unix filename 直接转换成unix格式，就OK了！～ 转载于:https://blog.51cto.com/mrcelite/745576
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa62173a78304012878cdc42383459a/" rel="bookmark">
			使用C语言去掉字符串集合重复元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一种最直接的方法可以去掉一个集合中重复的元素，这种方法据说就是“交给下面去做”，然而有时候，你自己动手去做一下也是不错的。如果交给下面去做，最直接的选择就是使用map，在java中，我们有HashMap，TreeMap等等实现了map接口的类可用，c++中，同样有STL的同类集合可以使用，在各类高级语言中，就更不必说了，然而在c中，就没有那么幸运了，很多东西需要你来自己实现。 根据《C语言内力修炼与软件工程》，用c语言自行实现这个东西，其实对于软件工程而言没有必要，然而可以训练一下自己，增加一些内力。我不认为自己是个高手，更非大侠，然而因为我懂得少，只能自己重新来做，真恨自己没有在5年前多学习一些编程语言。 先来简单分析一下需求，就是一个字符串集合中，去掉重复的字符串，换句话说就是每一个字符串只保留一个。题目没有说是否保持原有的字符串输入顺序，作为完美主义的我，我还是将其当成了一个隐含的需求。那么下一步就是将问题进行简化和转化，如果我们能将这一堆字符串进行排序，那么最终遍历这个排过序的字符串集合，发现和前一个相同的字符串就跳过不输出，对于排序，再简单不过了，至少N中排序算法，本文不讨论各种排序算法，只使用最简单的冒泡排序来分析。那么怎么保留原有的输入序呢？这也很简单，就是在排序元素中增加一个指向原有序的指针即可，另外还有一种方法，那就是排序过程仅仅是一个删除重复元素的过程，而不影响原有的输入序列，这个动态行为可以用二叉树的插入来实现，或者其它的AVL树以及红黑树都可以，本文不会去谈这几棵树的特性，只是用最简单的排序二叉树来分析。 我们知道，在二叉树插入中，首先要进行一次查找，现在要做的是，如果没有找到相同的，则插入，如果找到了相同的，则不插入，同时为该元素置入删除标识。代码如下： // // main.c // dup-del // // Created by ya zhao on 11-12-17. // Copyright 2011年 __MyCompanyName__. All rights reserved. // #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct sorted_order_str_map_with_thread { char *sorted_order_str; //保存排序后的字符串 char *normal_order_str; //保存原始字符串 int tag; //指示是否要删除 struct sorted_order_str_map_with_thread *self; //指向原始的位置 }; void sort(struct sorted_order_str_map_with_thread smwt[], const int size, int (*cmp)(void *, void *), void (*swap)(void *q1, void *q2)); int cmp_node(void *, void *); //比较函数，如果相同则将其tag位设置为0，标示要删除 int cmp_node(void *q1, void *q2) { int res; struct sorted_order_str_map_with_thread *cmp1, *cmp2; cmp1 = (struct sorted_order_str_map_with_thread*)q1; cmp2 = (struct sorted_order_str_map_with_thread*)q2; res = strcmp(cmp1-&gt;sorted_order_str, cmp2-&gt;sorted_order_str); if (res == 0) { struct sorted_order_str_map_with_thread *p = cmp2-&gt;self; p-&gt;tag = 0; } return res; } //交换函数，不光要交换元素，还要交换其self指针 void swap_node(void *q1, void *q2) { struct sorted_order_str_map_with_thread *swp1, *swp2,*temp; char *strTemp; swp1 = (struct sorted_order_str_map_with_thread*)q1; swp2 = (struct sorted_order_str_map_with_thread*)q2; strTemp = swp1-&gt;sorted_order_str; temp = (swp1-&gt;self); swp1-&gt;sorted_order_str = swp2-&gt;sorted_order_str; swp1-&gt;self = swp2-&gt;self; swp2-&gt;sorted_order_str = strTemp; swp2-&gt;self = temp; } //标准冒泡排序 void sort(struct sorted_order_str_map_with_thread smwt[], const int size, int (*cmp)(void *q1, void *q2), void (*swap)(void *q1, void *q2)) { int flag = 1; for (int i = 0; i &lt; size - 1; i ++) { flag = 1; for (int j = 0; j &lt; size - i - 1; j ++) { int res = 0; if ((res = cmp(&amp;smwt[j], &amp;smwt[j+1])) &gt; 0) { swap(&amp;smwt[j], &amp;smwt[j+1]); flag = 0; } } if (flag == 1) break; } } int main (int argc, const char * argv[]) { int i = 0; //为了简化，下面使用了最恶心的初始化方法。方便复制粘贴 struct sorted_order_str_map_with_thread smwt[20] = {{NULL, NULL, 0 NULL}}; smwt[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfa62173a78304012878cdc42383459a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5b0b9ca38e8ef23908c48dc91117a6/" rel="bookmark">
			如何用JavaScript动态修改CSS样式表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看过我写的《如何用JavaScript动态建立或增加CSS样式表》之后，你就很容易想明白如何修改CSS样式表了。
正好今天在论坛碰到一位朋友问这样的一个问题：
&lt;style&gt;
.ls{width=120px;}
&lt;/style&gt;
&lt;script&gt;
//在这里加一句来改变.ls中width的值，如何写
&lt;/script&gt;
有的朋友回答：“如果使用.ls的对象很多的话，用JS确实不方便, jquery方便,$(".ls").width(200);这样就行”。
他是想用JQ的类选择器.ls选择所有使用这个样式的对象，对它们逐个进行调整，而非更改CSS样式表，所以会有“对象很多”的顾虑。
但问题是，这只是改了那些对象的具体表现样式，而并非改了.LS的设置。如果再出现一个使用.LS风格的元素，它还是老样子，你还需要对这个元素再去调整，治标不治本。而且这种方式也决定了不可能简单地通过一句话就实现。
这样想的人还不少，而如果你看了《如何用JavaScript动态建立或增加CSS样式表》这篇文章之后，相信你很容易就想到如何用一句话来解决这个问题，既简洁高效（浏览器会自动重新设置所有应用这个样式的元素），而且真正的修改了样式设置，新增的使用这个样式的元素将自动应用被修改过的设置。于是，你已经学到了和很多人区分开来的更高阶的知识。下面我把方法具体再说一下：
由于上面的例子，不容易看出效果，我下面另外写了个例子，通过颜色的改变，比较容易看到效果：
&lt;STYLE&gt; .theforever {width:50px;color:red;} #theforever {width:150px;color:silver;} &lt;/STYLE&gt; &lt;div class="theforever"&gt;这里应该是红色的，但它会被下面的JS通过改变CSS样式设置而变成黄色&lt;/div&gt; &lt;div id="theforever"&gt;这里应该是银灰色的，的确这个不会发生变化，只作为对比&lt;/div&gt; &lt;script&gt; document.styleSheets[0].cssText=document.styleSheets[0].cssText.replace(/red/g,"yellow"); //一句，不就OK了？ &lt;/script&gt; 上面的例子，针对的不是某个特定的样式名称，而是泛泛的颜色（如果你直接挪到含有更为复杂的CSS页面里，其中有不表示颜色的RED字样，这还会导致错误。我对不动脑子的代码拿来主义者一向极其反感，不作过多指示），但如果想要针对特定的样式名称进行更改，同样很容易：
从上面，可以看出document.styleSheets[0].cssText就是整个&lt;STYLE&gt;&lt;/STYLE&gt;内部的内容，相当于一个字串变量，所以假如针对.LS要改变它的设置，只需要把“.ls{width=120px;}”作为 replace 要替换的部分，把“.ls{width=555px;}”作为替换目标，这样就行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c6fa7566d898f34b64ca56c9f136758/" rel="bookmark">
			JS动态添加select下拉框（城市区域多级下拉框demo）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态获取select中的options数量：
Var size = document.getElementById("ddlResourceType").options.length;
动态删除select中的所有options： document.getElementById("ddlResourceType").options.length=0; 动态删除select中的某一项option： document.getElementById("ddlResourceType").options.remove(indx); 动态添加select中的项option: document.getElementById("ddlResourceType").options.add(new Option(text,value)); 上面在IE和FireFox都能测试成功，希望以后你可以用上。 其实用标准的DOM操作也可以，就是document.createElement，appendChild，removeChild之类的。 取值方面
function getvalue(obj)
{
var m=obj.options[obj.selectedIndex].value
alert(m);//获取value
var n=obj.options[obj.selectedIndex].text
alert(n);//获取文本
}
==============================================================================
1 检测是否有选中 if (objSelect.selectedIndex &gt; - 1 ) { // 说明选中 } else { // 说明没有选中 } 将option设为选中：document.getElementById("province").options.selected = true;
2 删除被选中的项 objSelect.options[objSelect.selectedIndex] = null ; 3 增加项 objSelect.options[objSelect.length] = new Option( " 你好 " , " hello " ); 4 修改所选择中的项 objSelect.options[objSelect.selectedIndex] = new Option( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c6fa7566d898f34b64ca56c9f136758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c31dbccb3b74ce17a35639e4b7073cf8/" rel="bookmark">
			java 驱动调度 电梯调度算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验三 驱动调度
一、实习内容
模拟电梯调度算法，实现对磁盘的驱动调度。
二、实习目的
磁盘是一种高速、大容量、旋转型、可直接存取的存储设备。它作为计算机系统的辅助存储器，担负着繁重的输入输出任务，在多道程序设计系统中，往往同时会有若干个要求访问磁盘的输入输出请求等待处理。系统可采用一种策略，尽可能按最佳次序执行要求访问磁盘的诸输入输出请求，这就叫驱动调度，使用的算法称驱动调度算法。驱动调度能降低为若干个输入输出请求服务所需的总时间，从而提高系统效率。本实习要求学生模拟设计一个驱动调度程序，观察驱动调度程序的动态运行过程。通过实习使学生理解和掌握驱动调度的职能。
三、实习题目
模拟电梯调度算法，对磁盘进行移臂调度和旋转调度。
[提示]：
(1) 磁盘是可供多个进程共享的存储设备，但一个磁盘每个时刻只能为一个进程服务。当有进程在访问某个磁盘时，其它想访问该磁盘的进程必须等待，直到磁盘一次工作结束。当有多个进程提出输入输出请求而处于等待状态时，可用电梯调度算法从若干个等待访问者中选择一个进程，让它访问磁盘。选择访问者的工作由“驱动调度”进程来完成。
由于磁盘与处理器是可以并行工作的，所以当磁盘在为一个进程服务时，占有处理器的另一进程可以提出使用磁盘的要求，也就是说，系统能动态地接收新的输入输出请求。为了模拟这种情况，在本实习中设置一个“接收请求”进程。
“驱动调度”进程和“接收请求”进程能否占有处理器运行，取决于磁盘的结束中断信号和处理器调度策略。在实习中可用随机数来模拟确定这两个进程的运行顺序，以代替中断处理和处理器调度选择进程的过程。因而，程序的结构可参考图10-1。
图10-1 程序结构
(2) “接收请求”进程建立一张“请求I/O”表，指出等待访问磁盘的进程要求访问的物理地址，表的格式为：
进程名
柱面号
磁道号
物理记录号
M
M
M
M
M
M
M
M
假定某个磁盘组共有200个柱面，由外向里顺序编号（0-199），每个柱面上有20个磁道，编号为0-19，每个磁道分成8个物理记录，编号0-7。进程访问磁盘的物理地址可以用键盘输入的方法模拟得到。图10-2是“接收请求”进程的模拟算法。
图10-2 “接收请求”模拟算法
在实际的系统中必须把等待访问磁盘的进程排入等待队列，由于本实习模拟驱动调度，为简单起见，在实习中可免去队列管理部分，故设计程序时可不考虑“进程排入等待队列”的工作。
(3) “驱动调度”进程的功能是查“请求I/O”表，当有等待访问磁盘的进程时，按电梯调度算法从中选择一个等待访问者，按该进程指定的磁盘物理地址启动磁盘为其服务。
对移动臂磁盘来说，驱动调度分移臂调度和旋转调度。电梯调度算法的调度策略是与移动臂的移动方向和移动臂的当前位置有关的，所以每次启动磁盘时都应登记移臂方向和当前位置。电梯调度算法是一种简单而实际上用的驱动调度算法，这种调度策略总是优先选择与当前柱面号相同的访问请求，从这些请求中再选择一个能使旋转距离最短的等待访问者。如果没有与当前柱面号相同的访问请求，则根据移臂方向来选择，每次总是沿臂移动方向选择一个与当前柱面号最近的访问请求，若沿这个方向没有访问请求时，就改变臂的移动方向。这种调度策略能使移动臂的移动频率极小化，从而提高系统效率。用电梯调度算法实现驱动调度的模拟算法如图10-3。
(4) 图10-1中的初始化工作包括，初始化“请求I/O”表，置当前移臂方向为里移；置当前位置为0号柱面，0号物理记录。程序运行前可假定“请求I/O”表中已经有若干个进程等待访问磁盘。
在模拟实习中，当选中一个进程可以访问磁盘时，并不实际地启动磁盘，而用显示：“请求I/O”表；当前移臂方向；当前柱面号，物理记录号来代替图10-3中的“启动磁盘”这项工作。
图10-3 电梯调度模拟算法
四、实习报告
(1) 实习题目。
(2) 程序中使用的数据结构及其说明。
(3) 打印一份源程序并附上注释。
(4) 打印驱动调度进程每次选择访问请求的“请求I/O”表以及每次选中的进程名、访问的柱面号、物理记录号和当前移臂方向（用up代表里移，down代表外移）。打印格式为：
“请求I/O”表
进程名
柱面号
物理记录号
方向
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.sau.news;
import java.util.LinkedList;
import java.util.Scanner;
public class Drive {
private static void DeleteCourse(CourseClass cou) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c31dbccb3b74ce17a35639e4b7073cf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70aee36b248267e668382eede5d36403/" rel="bookmark">
			threadpoolexecutor 使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从 Java 5 开始，Java 提供了自己的线程池。线程池就是一个线程的容器，每次只执行额定数量的线程。 java.util.concurrent.ThreadPoolExecutor 就是这样的线程池。它很灵活，但使用起来也比较复杂，本文就对其做一个介绍。
首先是构造函数。以最简单的构造函数为例：
public ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) public ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 看起来挺复杂的。这里介绍一下。
corePoolSize 指的是保留的线程池大小。 maximumPoolSize 指的是线程池的最大大小。 keepAliveTime 指的是空闲线程结束的超时时间。 unit 是一个枚举，表示 keepAliveTime 的单位。 workQueue 表示存放任务的队列。
我们可以从线程池的工作过程中了解这些参数的意义。线程池的工作过程如下：
1、线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。
2、当调用 execute() 方法添加一个任务时，线程池会做如下判断：
a. 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；
b. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列。
c. 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建线程运行这个任务；
d. 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常，告诉调用者“我不能再接受任务了”。
3、当一个线程完成任务时，它会从队列中取下一个任务来执行。
4、当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。
这样的过程说明，并不是先加入任务就一定会先执行。假设队列大小为 10，corePoolSize 为 3，maximumPoolSize 为 6，那么当加入 20 个任务时，执行的顺序就是这样的：首先执行任务 1、2、3，然后任务 4~13 被放入队列。这时候队列满了，任务 14、15、16 会被马上执行，而任务 17~20 则会抛出异常。最终顺序是：1、2、3、14、15、16、4、5、6、7、8、9、10、11、12、13。下面是一个线程池使用的例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70aee36b248267e668382eede5d36403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc89b89095bf811d113dc76c59df860e/" rel="bookmark">
			struts的DevMode模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际应用开发或者是产品部署的时候，对应着两种模式：开发模式（devMode）；此时 DevMode=ture；
产品模式(proMode)；此时 DevMode=false；
在一些服务器或者框架中也存在着这两种模式，例如：tomcat、struts2等(其他的有待学习，呵呵)，在这两种不同的模式下，他们运行的性能方面有很大的差异，前面曾对tomcat产品部署作过介绍，下面主要介绍一下struts2在产品部署时要做的配置：
在struts.properties或者struts.xml中有devMode的配置，在devMode被激活的模式下，能够明显的提高开发效率，它会提供更多的日志或着debug信息。当然提高开发效率，在性能方面会付出一定的代价。所以struts默认的是非开发模式。设置为开发模式之后：
1、每次请求都会重新加载资源文件，所以当对properties文件进行修改后，下一次请求是就能够反映相应的变化。（struts.i18n.reload = true也可以达到相同的效果）
2、每次请求的时候也会重新加载xml配置文件、验证文件等，这样可以方便调试或者修改相应的配置文件，而不用重新部署重启web服务器。(struts.configuration.xml.reload = true 也可以达到相同的效果)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102cc73aedc7d175c9109ad9a9003dc0/" rel="bookmark">
			CL &amp; LINK的命令行用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CL.exe 是控制 Microsoft C 和 C++ 编译器与链接器的 32 位工具。编译器产生通用对象文件格式 (COFF) 对象 (.obj) 文件。链接器产生可执行文件 (.exe) 或动态链接库文件 (DLL)。
注意，所有编译器选项都区分大小写。
用法如下：
CL [option...] file... [option | file]... [lib...] [@command-file] [/link link-opt...]
option : 一个或多个 CL 选项。请注意，所有选项都应用于所有指定的源文件。选项是由一个
正斜杠 (/) 或一个短划线 (-) 指定的。如果某个选项带有参数，则该选项的说明指
定在选项和参数之间是否允许有空格。选项名（/HELP 选项除外）区分大小写。有关
更多信息，请参见 CL 选项的顺序。
/c : 编译但不链接
/Zs : 检查语法 /? : 列出编译器选项 /arch : 使用 SSE 或 SSE2 指令生成代码 /arch:SSE2 /clr : 启用 C++ 的托管扩展并产生在公共语言运行库上运行的输出文件 /F : 设置堆栈大小 | 此选项设置程序堆栈大小（以字节为单位）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/102cc73aedc7d175c9109ad9a9003dc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8393b579fea17780a166a56370c112/" rel="bookmark">
			程序员的自我经营之道第三层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（5） 笔试没有60分及格线这么一说
应聘职位的"笔试"和我们在学校的"考试"完全不同，不存在"及格"与"不及格"的问题，
也许你某一个道题回答的很精彩，但是总分并不是很理想也会被录用。
1.2.3.3 笔试技巧
我挑了几道笔试题，曾经给入职程序员出过的几个测试题，大家看看应该怎么作答，我
们再看看需要注意什么，题目如下：
1.2.3.3.1 例题1：请说出这个程序的目的是什么？返回结果是什么？
public Station(URL urla){
try
{
String a="",b="";
InputStream ins = urla.openStream();
BufferedReader bReader = new BufferedReader(new
InputStreamReader(ins));
String info = bReader.readLine();
int i=1;
info=bReader.readLine();
while(info!=null){
a=info.substring(0,info.indexOf("@"));
b=info.substring(info.indexOf("@")+1,info.length());
if (i==1){
this.X1=Integer.parseInt(a);
this.Y1=Integer.parseInt(b);
}
if (i==2){
this.X2=Integer.parseInt(a);
this.Y2=Integer.parseInt(b);
}
if (i==3){
this.X3=Integer.parseInt(a);
this.Y3=Integer.parseInt(b);
}
if (i==4){
this.X4=Integer.parseInt(a);
this.Y4=Integer.parseInt(b);
}
i++;
info=bReader.readLine();
}
}
catch(MalformedURLException e){
System.out.println(e);
该题解释：
第二问，返回值是什么？
总有人直接回答，说"没有返回值"，这说明没有弄明白构造函数的声明，如果是普通函
数没有返回值的话，应该用"void"而不是没有写任何东西。
第一问，这个程序的目的是什么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb8393b579fea17780a166a56370c112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2097b10e6c4d52d1b77370fc2b931c16/" rel="bookmark">
			错误：没有注册类别 (异常来自 HRESULT:0x80040154 (REGDB_E_CLASSNOTREG))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：第三方组件使用的COM组件未注册。 解决方法：使用 regsvr32命令重新注册即可。(regsvr 32命令是Windows中控件文件(如扩展名为DLL、OCX、CPL的文件)的注册和反注册工具)。 最简单的一种用法是：regsvr32 +dll/ocx/cpl的实际路径 eg:注册demo.dll,则在开始-&gt;运行中输入 regsvr32 f:\\demo.dll 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f82f77065c306826cdc0199cefdf022/" rel="bookmark">
			C&#43;&#43;移位运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于逻辑移位、算术移位可参见迅雷深大笔试题部分。的一道题。
以前看到C++标准上说，移位运算符（&lt;&lt;、&gt;&gt;）出界时的行为并不确定：
The behavior is undefined if the right operand is negative, orgreater than or equal to the length in bits of the promoted left operand.
我当时也没有深究过这个问题。前几天有个网友来信问起这件事，我才发现，这和IntelCPU的移位运算有关。下面是那位网友的来信以及我的回复：
您好！运算符&lt;&lt;作为位操作中的高效的操作，但我遇到一个问题：下面在VC环境下发现一个很不明白的地方，下面标注。
#include &lt;stdio.h&gt;
void main()
{
unsigned int i,j;
i=35;
//为什么下面两个左移操作结果不一样？
j=1&lt;&lt;i; // j为8
j=1&lt;&lt;35; // j为0
}
不知是哪里没有理解对。
原因是这样的：i=35;j=1&lt;&lt;i;这两句在VC没有做优化的情况下，将被编译成下面的机器指令：
mov dword ptr [i],23h
mov eax,1
mov ecx,dword ptr [i]
shl eax,cl
mov dword ptr [j],eax
在shl一句中，eax=1，cl=35。而IntelCPU执行shl指令时，会先将cl与31进行and操作，以限制左移的次数小于等于31。因为35 &amp; 31 =3，所以这样的指令相当于将1左移3位，结果是8。
而j=1&lt;&lt;35;一句是常数运算，VC即使不做优化，编译器也会直接计算1&lt;&lt;35的结果。VC编译器发现35大于31时，就会直接将结果设置为0。这行代码编译产生的机器指令是：
mov dword ptr [j],0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f82f77065c306826cdc0199cefdf022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a649861c6000d3e333747535419accc3/" rel="bookmark">
			C&#43;&#43; rand,srand用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机的随机数都是由伪随机数，即是由小M多项式序列生成的，其中产生每个小序列都有一个初始值，即随机种子。（注意： 小M多项式序列的周期是65535，即每次利用一个随机种子生成的随机数的周期是65535，当你取得65535个随机数后它们又重复出现了。） 我们知道rand()函数可以用来产生随机数，但是这不是真正意义上的随机数，是一个伪随机数，是根据一个数（我们可以称它为种子）为基准以某个递推公式推算出来的一系列数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统。
1.rand()
功能:随机数发生器
用法:int rand(void)
所在头文件: stdlib.h
rand()的内部实现是用线性同余法做的，它不是真的随机数，因其周期特别长，故在一定的范围里可看成是随机的。
rand()返回一随机数值的范围在0至RAND_MAX 间。RAND_MAX的范围最少是在32767之间(int)。用unsigned int 双字节是65535，四字节是4294967295的整数范围。0~RAND_MAX每个数字被选中的机率是相同的。 用户未设定随机数种子时，系统默认的随机数种子为1。
rand()产生的是伪随机数字，每次执行时是相同的;若要不同,用函数srand()初始化它。
2.srand()
功能:初始化随机数发生器 用法: void srand(unsigned int seed)
所在头文件: stdlib.h
srand()用来设置rand()产生随机数时的随机数种子。参数seed必须是个整数，如果每次seed都设相同值，rand()所产生的随机数值每次就会一样。
3.使用当前时钟作为随机数种子
rand()产生的随机数在每次运行的时候都是与上一次相同的。若要不同,用函数srand()初始化它。可以利用srand((unsigned int)(time(NULL))的方法，产生不同的随机数种子，因为每一次运行程序的时间是不同的。
4.产生随机数的用法
1) 给srand()提供一个种子，它是一个unsigned int类型；
2) 调用rand()，它会根据提供给srand()的种子值返回一个随机数(在0到RAND_MAX之间)；
3) 根据需要多次调用rand()，从而不间断地得到新的随机数；
4) 无论什么时候，都可以给srand()提供一个新的种子，从而进一步“随机化”rand()的输出结果。
0~RAND_MAX之间的随机数程序
#include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; using namespace std; int main() { srand((unsigned)time(NULL)); for(int i = 0; i &lt; 10;i++ ) cout &lt;&lt; rand() &lt;&lt; '/t'; cout &lt;&lt; endl; return 0; }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a649861c6000d3e333747535419accc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2e9c3e387b1accfe9f2a44fc01dadc/" rel="bookmark">
			C&#43;&#43; memset详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述:
int * cow = new int[n+1];
memset(cow,0,(n+1)*4);
将N+1个元素置成0,为什么不行
memset是对一个字节的int4个字节,因此*4
但是只能为0,其他例如1就不可以,详见最后一个例子
memest原型 (please type "man memset" in your shell) void *memset(void *s, int c, size_t n); memset:作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。
常见的三种错误
第一: 搞反了c 和 n的位置. 一定要记住 如果要把一个char a[20]清零, 一定是 memset(a, 0, 20) 而不是 memset(a, 20, 0) 第二: 过度使用memset, 我想这些程序员可能有某种心理阴影, 他们惧怕未经初始化的内存, 所以他们会写出这样的代码: char buffer[20]; memset(buffer, 0, sizeof((char)*20)); strcpy(buffer, "123"); 这里的memset是多余的. 因为这块内存马上就被覆盖了, 清零没有意义. 第三: 其实这个错误严格来讲不能算用错memset, 但是它经常在使用memset的场合出现 int some_func(struct something *a){ … … memset(a, 0, sizeof(a)); … } 问:为何要用memset置零?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2e9c3e387b1accfe9f2a44fc01dadc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a0f65259dfcd7509dd9053319e8af5/" rel="bookmark">
			HashMap与CorruntHashMap性能对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [color=red]测试电脑：cpu 2.6Ghz 内存 2G [/color] 100万数据量级 HashMap put:1734ms get:3921ms CorruntHashMap put:1891ms get:3281ms [color=red]建议在map中最多存储十万级别的数据如果存储过多会造成栈溢出。[/color] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6517725036f9ef5190977df6a9ead24f/" rel="bookmark">
			linux  shell 按行循环读入文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux shell 按行循环读入文件常用代码如下：
#/bin/bash printf "*************************************\n" echo " cat file whiel read line" cat test.txt |while read line do echo $line; done printf "*************************************\n" echo "while read line &lt;file" while read line do echo $line; done &lt;test.txt printf "*************************************\n" echo "for line in cat test.txt" SAVEIFS=$IFS IFS=$(echo -en "\n") for line in $(cat test.txt) do echo $line; done IFS=$SAVEIFS 注意：for line in $(cat test.txt) 当文件中有空格或者tab 时，一定要设置一下IFS变量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f76496abc0077d8e7cfa74bdb05d3c7/" rel="bookmark">
			联想笔记本电脑开机后，两声短响，自动然后关机的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的是08年买的lenovo thinkpad r61系列笔记本，由于公司可以带自己的电脑去上班，我就把自己的电脑常常背着去上班，下班。有一天我照常带着电脑去上班，结果一开机，就出现了标题上所说的情况，一开始googlebaidu了一番，说bios可能有问题，怀疑内存，硬盘都没有救，最后把拆开的机器装上，突然就好了，我想了一下，很有可能是电池的卡口没有打到锁的状态，由于用久了，不免从包里掏出来的时候把电池的卡口绊到了开的状态，估计联想的电脑都有这个检验的，要卡口打到锁的状态才能开机正常吧，总之很奇怪的问题
补充，今天又发现开不了机，黑屏幕上弹出一个fan error，于是我一google才知道风扇可能用久了，拆下来擦掉灰，好像还是没有用，看来要换风扇了，开机时嗡嗡的响，过一段时间换一个风扇试试，不过开机时按一下ESC也可以进入系统的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2f60addfed7c36e8d25eaabda7364b/" rel="bookmark">
			MySQL 分区的七大好处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 逻辑数据分割 提高单一的写和读应用速度 提高分区范围读查询的速度 分割数据能够有多个不同的物理文件路径 高效的保存历史数据 一个表上的约束检查 不同的主从服务器分区策略，例如master按Hash分区，slave按range分区 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77ae02128e4f6e8a01263c92de5936c/" rel="bookmark">
			adb logcat 查看日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 logcat 命令
查看和跟踪系统日志缓冲区的命令logcat的一般用法是：
[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 下文介绍过滤器和命令选项，详细内容可参见Listing of logcat Command Options。
可以在开发机中通过远程shell的方式使用logcat命令查看日志输出：
$ adb logcat 如果是在远程shell中可直接使用命令：
# logcat 过滤日志输出
每一条日志消息都有一个标记和优先级与其关联。
标记是一个简短的字符串，用于标识原始消息的来源 (例如"View" 来源于显示系统)。
优先级是下面的字符，顺序是从低到高：
V — 明细 (最低优先级)
D — 调试
I — 信息
W — 警告
E — 错误
F — 严重错误
S — 无记载 (最高优先级，没有什么会被记载)
通过运行logcat ，可以获得一个系统中使用的标记和优先级的列表，观察列表的前两列，给出的格式是&lt;priority&gt;/&lt;tag&gt;。
这里是一个日志输出的消息，优先级是“I”，标记是“ActivityManager”：
I/ActivityManager( 585): Starting activity: Intent { action=android.intent.action...} 如果想要减少输出的内容，可以加上过滤器表达式进行限制，过滤器可以限制系统只输出感兴趣的标记-优先级组合。
过滤器表达式的格式是tag:priority ... ，其中tag是标记， priority是最小的优先级， 该标记标识的所有大于等于指定优先级的消息被写入日志。也可以在一个过滤器表达式中提供多个这样的过滤，它们之间用空格隔开。
下面给出的例子是仅输出标记为“ActivityManager”并且优先级大于等于“Info”和标记为“MyApp”并且优先级大于等于“Debug”的日志：
adb logcat ActivityManager:I MyApp:D *:S
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b77ae02128e4f6e8a01263c92de5936c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1daf9fd7f59031c714a245ae5c1a1969/" rel="bookmark">
			关于键盘冲突那点事（3键冲突/7键冲突/PS2/USB的各种原理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自外设天下 感谢外设天下的会员：白金之星 （UID:110238）的总结 最近闲得无聊，正好看到有人发帖提问，于是就来详细说说所谓键位冲突和无冲突的各种原理——基本上这也是个老生常谈的话题了，但相关的技术帖比较零乱难找，而且充斥了大量电工术语，也不是很容易看懂。这里就尽量用通俗易懂的语言来讲（我的目标是即使你只有初中文化水平也能看懂，保守地说绝对不超过高中文科生能理解的范围），帖子比较长，有兴趣的朋友请慢慢阅读。慢慢看，用心理解，包你看懂。
为了降低阅读门槛，本文难免有不严谨之处，还请工科同学高抬贵手。如果是特别荒谬的原则性错误，欢迎指正。
——————电路基本常识：输出与输入—————— 我们的手指按下一个键，电脑是怎么知道的呢？在这短短几十微秒的时间里发生了什么事呢？为什么有时候同时按下几个键就没反应了呢？首先要讲讲电路的通断。 即使你没有什么计算机知识，大概也应该听过一个词：【二进制】。不管你家里的电脑外表多么五颜六色，它底层的逻辑却是非黑即白，只有【1】和【0】。任何储存在你电脑里的东西，无论游戏、音乐还是你最钟爱的小电影，都是用一长串你数不清的1和0的组合来记录和处理的。 明白了这个概念以后，再想想，电脑电脑，它的基础是什么？对，要有【电】。下一个问题很自然地：这电怎么就能变成1和0呢？说来更简单，有电就是1，没电就是0呗——这么说似乎太不专业了。严谨一点说：在电路中一个点，它当前表示的数据是1还是0，需要检测这一点的电压到底是更接近【悬空】（对于USB和PS/2接口，指+5V），还是更接近【大地】（0V）。如果高于某个界限值，称作【高电平】，也就是1；而相对地，低于某个界限值，称作【低电平】，也就是0。 接下来的问题更是小学生也会答：1×1等于多少？ 你当然知道答案是1。 那么1×0呢？ 对了，不管什么数字乘以0，结果都是0。 如同在游泳池里面尿尿一样，一泡尿就把干净水变成脏水。大地就是这么邪恶：无数个悬空的点，它们之间互相连接还是悬空，然而只要其中有一个点接着地，它们就全等于接地了。 （重要知识）高电平的点和低电平的点连通短接之后，两点都成为低电平。 你压住不耐烦，看到这里，心想，这他妈的和键盘有毛的关系？ 别着急，我们再来看看一个典型的可编程芯片是什么样子（图片引自泡泡网的poker拆解）： 这个黑色方方的就是芯片，它周围那一排排张牙舞爪的刺叫做【引脚】，是芯片用来和外界沟通的渠道，图中这只芯片一共有48个引脚。 其中一些引脚负责电源、时钟、控制等基础功能，但占绝对多数的是负责输入/输出数据的，称为【I/O引脚】。 通过程序设置，芯片既可以改变每个I/O引脚的电压（设置1或0的值），也可以检测引脚的电压（读取1或0的值），以下如果没有特殊说明，提到引脚一词均指数据I/O引脚。 现在请假设这样一个场景： 你是一颗芯片，你的左手和右手是两个引脚，有一大团杂乱无章的导线，露出两个线头摆在你面前，你如何判断它们是否是同一根线的两头？（即这两个线头是否连通） 仔细考虑之后，聪明的你大概可以想到：只要把左手设置为0，右手设置为1，分别握上两个线头，然后检查右手的状态，如果变成0了，说明它们刚刚做过一次相乘运算，1被拉下水变成了0，这条线是连通的。 换一个比喻：如同一根管道，在左手的洞口放一只小老鼠，右手的洞口放一块奶酪（这只小老鼠的速度无敌快）。当小老鼠从左边进去，又从右边钻出来吃掉了奶酪，说明管道中间没有被堵死。 对，这就是键盘按键接通的原理。 在按键下面的【电路板】（或者电路薄膜）上，印制有许多导线，导线经过每个按键下方的部分是断开的。按键，也就是开关，当它压下的时候，下面的导线会被接通。而导线最终两端都是连接到芯片上，芯片会不停地反复检测每条线的连通情况，从而随时判断哪个键当前是按下的。这就好像学校的保安头子坐在监控室里，切换着镜头，偷窥哪个自习室中有男女生OOXX那样。 ——————主控芯片与矩阵设计—————— 我们继续深入话题：一块普通的键盘，少则几十个多则上百个按键，显然无论从哪个方面看，怎么都不可能给每个键都单独连个导线到CPU芯片去——先不说成本多高，谁愿意桌面上横着手腕粗的一大捆线呢？ 在上个世纪末，电脑开始走入寻常百姓家庭，当时的PC界霸主是IBM公司。为了简化接口，顺便垄断标准，IBM陆续设计了XT、AT、PS/2协议用来处理键盘这样的输入设备，大体意思是，只要在键盘内部放一块主控芯片，用来管理所有按键状态并转换为串行信号，包括电源在内总共只要4根线就可以传输所有的数据（扫描码），而相应地，主板上也会有一个称作键盘控制器的IO芯片（一般集成在南桥中），把这些扫描码翻译为ASCII码给CPU。 最后，PS/2协议作为成熟而稳定的形态，成为了二十多年来的市场规范，也就是大家熟知的那个圆形接口，里面实际用到的4根线分别负责：时钟、数据、电源、接地。 上面这一段可能有点复杂，如果你没能全看懂，也没啥大碍，只是为了说明【键盘主控芯片】的存在。 总之，整理一下到目前为止的知识，现在你应当知道键盘是遵循如下的通讯过程： 【按键】——【键盘主控芯片】——（翻译成扫描码，经过PS/2协议）——【主板IO芯片】——（翻译成ASCII码）——【CPU】 这样看起来不错，但还有个问题：主控芯片是怎么“知道”所有键的状态的？ 按照前面说的，要得知一个按键是否按下，需要在引脚A输出0，引脚B输出1，再检测引脚B的值是1还是0。（如果这里看不懂就麻烦了，请向上翻翻，复习一下左右手攥电线或者小老鼠吃奶酪的例子） 现在，假设我们要做一个36键的键盘，包括10个数字和26个英文字母。 于是我们令引脚A永远＝0，而且连接到所有的按键上。 然后做引脚B1、B2、B3、……、B36，分别与对应的36个按键连接。 这样总共是需要37个引脚。 接着，先令所有B引脚＝1，然后从B1到B36挨个检查，谁变成0了，就说明谁对应的按键按下了。当然，为了时刻获取最新的状态，每秒钟要进行几十至上百轮这样的扫描。 但是104个键的键盘怎么办？老老实实做105个引脚吗？这也太复杂了吧！有没有办法能用更小、更简单一些的芯片实现呢？要知道这可直接关系到成本啊。 工程师们想了个办法：【矩阵】。听起来很专业，其实就是利用“组合”，来成倍地提高引脚利用率。还拿上面的例子说，我们可以把引脚数量从37缩减到12。怎么做呢？ 请想象一个表格，行标题为A1、A2、A3、A4、A5、A6，列标题为B1、B2、B3、B4、B5、B6。这样就构成了一个6×6＝36的矩阵。然后把按键分别放到每个格子里面去，如下图。 在电路中，每个按键都是负责连接它所对应的两个引脚，比如按键A连接引脚A1和B1，而按键W连接A5和B4。这样一来，引脚之间就形成了【交叉组合关系】，也就是矩阵。任意两个引脚之间只通过一个按键连接。 现在我们按下J键，芯片中的程序是怎么检测到这个行动的呢？ 首先令A1＝0，其他所有引脚＝1，然后从B1到B6挨个检查。由于那一列的按键都没有按下，没有任何一个B引脚和A1接通，因此它们的值都是1。 接下来，令A2＝0，其他所有引脚＝1，重复以上工作。接着再检查A3列…… 最后所有行列检查完毕后，结果发现只有在A4＝0的时候，B2＝0，也就是说A4和B2是接通的。于是程序便通过预先定义好的按键表格，知道按下的是J键。 同样地，这一整轮扫描每秒要重复几十上百遍，所以你在任何时候敲下或抬起按键，电脑都能很快反应出来。 现在市面上绝大多数键盘的工作原理都是基于这种矩阵的。我们很容易想到，矩阵的行数乘以列数的结果，就是它能够容纳按键的最大数量。普通的104键键盘是应用16×8的矩阵，来覆盖所有按键。只需要24个数据引脚。 ——————三键冲突：矩阵的麻烦—————— 如果你耐心地一行一行读到这里，我相信经过了两节的铺垫，你已经掌握了足以继续读下去的基础知识。那么废话到此为止，下面开始介绍本帖的重点问题：【键位冲突】。 在刚才的段落中，你已经知道了系统是如何判定单个键有没有按下的。但我们人类的双手上长了十个手指，谁也不能保证不会同时按下两个按键——甚至很多时候组合键是故意设计要用的。这样一来，就会有一个潜在的问题出现…… 请回忆一下刚才用来举例的36格矩阵图，如果我们同时按下B、H、G键，在程序看来是什么样子呢？ 像平时一样，它从（A1，B1）开始检测，现实中我们并没有按下A键，所以当A1＝0，其他引脚＝1的时候，B1的值应该是1，表示A键没有被按下才对。但是，请注意： 由于G键被按下，A1和B2是接通的， 由于H键被按下，B2和A2是接通的， 由于B键被按下，A2和B1也是接通的！ 也就是说，现在的电路中，A1和B1其实是连在一起的！ 还记得吗？不管多少个1相乘，只要中间有0，最后就会变成0。 换句话说，我们见A1和B1没有直接连通，就天真地以为B1的奶酪不会被吃掉——但有个致命的错误就在于我们根本不关注其它奶酪。瞬间，电流飞驰，经过3个按键，最终钻进地下。这只飞快的小老鼠沿着管线从A1出发，先是吃掉了B2的奶酪，然后又吃掉了A2，最后从B1钻出来大快朵颐。（注：严格来说，其实老鼠与电流方向是相反的，此处的比喻是为了更容易理解） 就这样，芯片以为A键也被按下了。 事实上，按下这4键中的任意3键，在电脑看来都是相同的，因为A1、A2、B1、B2这四点已经变成短路的状态。 任意两行两列所构成的4个交点，也即某长方形的四角所对应的4个键，同时按下3个时，都会出现这样的问题——在四通八达的管道中，剩余的那个键的状态到底是按下还是没按下，对于芯片来讲是一片茫然。怎么办呢？ 扫描按键的程序是人写的，稍作改动也不是不可能。于是需要增加如下的处理方法：给它一个“小账本”，随时记录当前按下的所有按键。每当按下或抬起某个键时，就在账本中如实增加或抹除。但是，如果账本显示：某个“四角组合”其中已经有两个按键同时按下时，这个组合剩余的键就被逻辑锁定——即使你按了，程序也拒绝接受，除非之前的某个键抬起。 这样设计的理由很简单：宁可错杀一千，不能放过一个，不知道按没按的话，当成没按更保险。你能想象当你同时按下B键和G键以后，再按H键，屏幕上出现的却是A吗？太无厘头了，还不如什么反应都没有。 这也就是所谓的三键冲突的原型所在。 任何没做无冲处理的矩阵式键盘，都存在许多特定的三键组合不能同时按。举个著名的例子，黑寡妇的A、W、L。 你可能会说：“不会啊我的键盘可以七键一起按都没冲突的。” 是的，不同品牌型号的键盘走线设计可能有区别，因此它们存在冲突的键位也不一样。只要不构成四角组合关系，大部分键都是可以随便同按的，以打字为主要用途的普通键盘，即使有这样那样的冲突，也足够日常使用了。 但是四角组合数不胜数——比如上面例子中6×6的矩阵就存在多达55个四角组合，220种三键冲突，可想而知全尺寸键盘会有多少个键位冲突。虽然大部分冲突组合都是你平时不会按到的，但玩游戏的时候需要的键位总是千奇百怪各不相同，比如玩劲乐团可能需要SDF空格JKL不冲突，而BMIIDX则需要ZSXDCFV不冲突。如果你什么都玩，有很大几率会碰到那么一两个冲突键位郁闷你。即使对键盘最没要求的FPS游戏，还是有少数键盘的四角组合悲剧地包含QWA或者1WD之类经常需要一起按的键…… 一个比较讨巧的办法就是把左侧常用十来个键位的走线全部串到一起，这样至少可以保证打CS情绪稳定。因为我们知道，会起冲突的按键是位于任意两行两列的4个交点中的3个，而全部处于同一列或同一行的键，不管怎么按也不会冲突。 当然，最完美的还是全键盘无冲突，也就是所谓的【NKRO】。这就要放在下一节讲了。 ——————无冲突的技术本源—————— 之前你已经意识到了，普通的矩阵键盘，都会存在成百上千的三键冲突组合。但是市面上却有那么几款键盘，号称全键无冲突，实际测试也是威武异常，整个手掌拍下去都能毫不犹豫地识别出来，这是为什么呢？ 这里要介绍一个美妙的电气元件——【二极管】。 二极管是计算机逻辑电路最基本的元件之一（包括CPU芯片在内的各种集成电路芯片内部都有大量的二极管和三极管），大家津津乐道的LED就是二极管中能发光的一种。 一个典型的二极管会有两条腿，即阳极和阴极。它的特点就是——电流只能从它的阳极流向阴极，而反向则难以通过。 如果身为芯片的你捏着一个二极管的两端，你左手是1，右手是0时，只消一瞬间，左手的1就会变成0。但若调换成右手是1，左手是0，右手的1则不会受到影响。这二极管就相当于一个单向的小门，老鼠只可以从这边跑到那边，却不能从那边跑到这边。 那么这个特点对我们具体有什么帮助呢？ 只要你回忆一下按键冲突的问题是如何产生的，就会恍然大悟了。 冲突，是为了防止当A1和B2、A2和B2、A2和B1分别连通时，程序误以为A1和B1也连通，因此当发现3个按键互相形成回路时，就屏蔽第三颗按键的设计。 现在，我们在每个按键的电路中增加一个二极管，让小老鼠只能从A端跑到B端，而不能从B跑向A。 回到之前的例子，同时按下B、H、G三个键。尽管H键接通了A2和B2，但由于二极管的限制，信息只能从A2到B2传导，而不能从B2到A2。 于是，虽然受G键按下的影响，当A1＝0的时候，B2的值被修改为0，但这个0在这里就到此为止了。因为老鼠到达B2后，被门挡住，无法继续去吃A2的奶酪。既然A2不会跟着变成0，而是保持正确的1，B1的值当然也还是1。 由此，系统自然能够判断出，A键没有被按下，和事实一致。也就是说，二极管的防逆流特性，彻底消除了按键之间的干扰。 有了这些二极管做保障，自然根本不需要什么屏蔽第三颗按键的逻辑了。于是，每一颗按键可以独立自主反应，活动自如，成就了我们的无冲突键盘。 至于为什么无冲突键盘基本都是机械键盘，我想可能有两个原因： 1，机械键盘采取的电路板比较容易安装二极管。而薄膜键盘基本无解。 2，机械键盘本身的定位也比较高，相对这个售价水平来讲，增加一百颗二极管的成本并不显著。 ——————USB永远的痛—————— 讲了这么多，终于到最后一节了。前面已经把造成键盘冲突的原理和解决办法从头到尾介绍了一遍，但还没有讲过USB接口的键盘，即使硬件上是NKRO结构了，为什么还是只能做到6键无冲突。 这里所指的6键，是除去Ctrl、Shift、Alt、Win之外的键，同时按下任意6个都不会有冲突，但第7个键按下就没有反应——或者会直接抹掉第一个键，总之逻辑上同时只能有6个键处于按下的状态。 但是这样的键盘，使用PS2转接头连接电脑，又可以实现完美NKRO（除了部分键盘干脆不支持PS/2转接，例如poker）。 看来问题就出在USB接口上了。 事实上的确是这样，因为键盘输入设备在USB接口和PS/2接口的传输协议完全不同，也就是说，它们采取了完全不同的工作方式，也难怪效果不同。现在你能买到的大部分机械键盘，其主控芯片可以根据当前连接的端口，自动适应PS/2或USB协议。只有少量无法转接。 既然你已经坚持看到这里了，我相信你对它们的具体区别会比较感兴趣，别着急，这就慢慢道来。 （还是有些废话：如果你搞不清【字节】和【位】的概念请看本段） 位（bit，缩写为小写的b），就是二进制位，取值范围只有0和1两个值，是最小的单位。 字节（Byte，缩写为大写的B），为8个位的组合，取值范围是从0到255（2的8次方），也是常见的计算机数据量单位。 1字节=8位，所以如果你的网速标称10Mb，实际下载速度只有1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1daf9fd7f59031c714a245ae5c1a1969/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95eeb3f4ad9cd926f3882357f32d1ab/" rel="bookmark">
			qt4 udp  QUdpSocket  -------wireshark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四十六、Qt网络（六）UDP 像QQ那样，当有很多用户，发送的大部分都是短消息，要求能及时响应，并且对安全性要求不是很高的情况下使用UDP协议。 发送（客户请求发送数据） 很简单，仅需QUdpSocket 的writeDatagram函数即可 void Widget::on_pushButton_clicked() { QUdpSocket *sender; sender = new QUdpSocket(this); QByteArray datagram = "hello world!"; sender-&gt;writeDatagram(datagram.data(),datagram.size(),QHostAddress("192.168.1.100"),45454); //sender-&gt;writeDatagram(datagram.data(),datagram.size(),QHostAddress::Broadcast,45454); // sender-&gt;writeDatagram(datagram.data(),datagram.size(),QHostAddress::LocalHost,45454); delete sender; } 接收（服务器端监听） 使用QUdpSocket 的bind函数监听某个端口 当监听的端口有数据到达时，QUdpSocket 的信号readyRead()就emit，然后在对应的槽函数里使用QUdpSocket 的readDatagram读取数据 void QIODevice::readyRead () [signal] This signal is emitted once every time new data is available for reading from the device. It will only be emitted again once new data is available, such as when a new payload of network data has arrived on your network socket, or when a new block of data has been appended to your device.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c95eeb3f4ad9cd926f3882357f32d1ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57bd6d25528cca90fe87d1725e3af18/" rel="bookmark">
			tomcat配置多个端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://wenku.baidu.com/view/762ed73467ec102de2bd8971.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2e84842fc4dff6ba98c8f6538ff140/" rel="bookmark">
			Quartz中时间表达式的设置-----corn表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quartz中时间表达式的设置-----corn表达式
时间格式: &lt;!-- s m h d m w(?) y(?) --&gt;, 分别对应: 秒&gt;分&gt;小时&gt;日&gt;月&gt;周&gt;年, 举例:
1.每天什么时候执行:
&lt;value&gt;0 59 23 * * ?&lt;/value&gt;: 如下为每天23:59:00开始执行
&lt;value&gt;0 1,2,3 11,12 * * ? &lt;/value&gt;: 每天11:01,11:02,11:03; 12:01,12:02,12:03分执行任务
2.每隔多久执行:
汇总说明:
Cron表达式的时间字段除允许设置数值外，还可使用一些特殊的字符，提供列表、范围、通配符等功能，细说如下：
●星号(*)：可用在所有字段中，表示对应时间域的每一个时刻，例如，*在分钟字段时，表示“每分钟”；
●问号（?）：该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；
●减号(-)：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；
●逗号(,)：表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；
●斜杠(/)：x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；
==================================================
Quartz cron 表达式的格式十分类似于 UNIX cron 格式，但还是有少许明显的区别。区别之一就是 Quartz 的格式向下支持到秒级别的计划，而 UNIX cron 计划仅支持至分钟级。许多我们的触发计划要基于秒级递增的(例如，每45秒)，因此这是一个非常好的差异。
在 UNIX cron 里，要执行的作业（或者说命令）是存放在 cron 表达式中的，在第六个域位置上。Quartz 用 cron 表达式存放执行计划。引用了 cron 表达式的CronTrigger 在计划的时间里会与 job 关联上。
另一个与 UNIX cron 表达式的不同点是在表达式中支持域的数目。UNIX 给出五个域(分、时、日、月和周)，Quartz 提供七个域。表 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af2e84842fc4dff6ba98c8f6538ff140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e3f8287a75a30e3da09dec1e29c080/" rel="bookmark">
			GTP协议的分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 引言
在GPRS系统的GSN（GPRS Support Node，包括SGSN和GGSN）之间采用GTP（GPRS Tunnel Protocol）协议，GTP在整个GPRS协议栈中起着举足轻重的作用，GTP协议承载在TCP或UDP协议之上，分为信令平面和传输平面，其信令平面定义了多种消息，涉及到GPRS许多重要方面，传输平面则提供了GSN之间数据包传送的隧道。另外以GTP为基础的GTP'协议用于GPRS计费数据采集和传输，深入理解GTP协议是熟悉GPRS网络所必须的。
二、 GTP包头
GTP包头的格式如图1所示，Version表示协议版本；PT=1指示GTP协议，PT=0指示GTP'协议（GPRS计费采集协议）；SNN指示包头中是否包含SNDCP N-PDULLC Number；Message Type字段指示消息类型，GTP中涉及的消息及其对应的消息类型在本文“信令平面”一节中介绍。Length字段指示包的长度（不含包头）；Sequence Number对于信令消息而言是交互的标识，对于T-PDU而言是顺序号；SNDCP N-PDULLC Number用于越SGSN切换时协调MS与SGSN之间的数据传送；Flow Lable唯一标识一个GTP流；TID是隧道标识，由IMSI和NSAPI两部分组成，用于指明MM（Mobility Management）和PDP（Packet Data Protocol）上下文。
无论是信令平面还是传输平面都采用如图1所示的GTP包头，但是其中有些字段的含义和用法存在一定的区别。
三、 信令平面
承载GTP的协议（UDP或TCP）称为路径协议（Path Protocol），每个GSN对之间有多个路径，每个路径上可以存在多个隧道，GTP负责隧道的建立、使用、管理和释放。信令平面主要包含路径管理、隧道管理、位置管理、移动性管理四大类。
对于信令消息，GTP包头中的字段设置如下：
· SNN置为0；
· SNDCP N-PDULLC Number不使用，发端将该字段置为255，收端忽略该字段；
· 对于一个路径或一个隧道上的信令，其request类消息的Sequence Number是唯一的，相应的response消息的Sequence Number从接收的request消息的该字段拷贝；
· 对于路径管理消息、位置管理消息、移动性管理消息而言，TID置为0；对于隧道管理消息而言，TID用于指出目的端GSN的MM和PDP上下文；
· 对于路径管理消息、位置管理消息而言，Flow Lable不使用而置为0；对于移动性管理消息、隧道管理消息而言，Flow Lable应该指出其试图操作的GTP流，例如在Create PDP Context Request消息中分配GTP流的Flow Lable，在对应的Create PDP Context Response消息中应该包含该字段。
GPRS信令消息格式与电信界其他信令定义方式类似，每条消息都包含若干个参数（Information Element），参数分为TV（Type，Value）和TLV（Type，Length，Value）两种类型，TV参数的Type字节的最高位为0，TLV参数的Type字节的最高位为1。每个参数都具有唯一的Type标识。
1 路径管理消息
路径管理是所有其它管理活动的基础，只有确保消息传送的通路处于可用状态，消息才能被正确发送与接收。具体的路径管理消息如下：
· Echo Request/Response(类型码1／2)消息主要用于探测对端GSN是否仍然处于激活状态，路径是否畅通；
· Version Not supported(类型码3)用于指示对端版本不符，同时指出本节点支持的版本。
2 隧道管理消息
隧道管理围绕PDP上下文展开，是GPRS会话过程的核心，具体消息类型如下：
· Create PDP Context Request/Response(类型码16／17)消息用于PDP上下文的建立请求和响应，SGSN向GGSN发请求消息，GGSN向SGSN发响应消息；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4e3f8287a75a30e3da09dec1e29c080/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224b818a2577f8c8a1c9f221a0533cbb/" rel="bookmark">
			Eclipse下搭建Android开发环境（Windows XP SP2 32位）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Java JDK下载与安装
下载Java JDK，如图所示。默认安装到目录"C:\Program Files\"，"C:\Program Files\Java"包含两个子目录："jdk1.7.0_01"和"jre7"。
下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html
JDK环境变量设置
右击"我的电脑"，选择"属性"，在"高级"选项栏中打开"环境变量"对话框，确认添加以下系统变量。
变量名：JAVA_HOME 变量值：C:\Program Files\Java\jdk1.7.0_01
变量名：CLASSPATH 变量值：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar (注意前面的点号和分号)
变量名：Path 在变量值的最前面添加 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; (注意后面要带分号)
查询JDK版本，可以在命令提示行中输入java -version。 2. Eclipse IDE for Java EE Developers下载
下载Windows 32-bit的Eclipse，然后解压缩到目录"C:\Program Files\"（不需要安装），如图所示。执行文件是C:\Program Files\eclipse\eclipse.exe，为方便使用，可在桌面上创建快捷方式。
下载地址：http://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/indigosr1
3. ADT插件的安装
ADT(Android Development Tools)是Eclipse IDE环境下开发Android应用程序的插件，是开发工具的升级下载工具，目前最新版本为ADT 15.0.0。
下载地址：http://dl.google.com/android/ADT-15.0.0.zip
打开Eclipse，菜单"Help-&gt;Install New Software..."，点击"Add"按钮，"Name"一栏中输入"ADT"，点击"Archive"按钮并选择下载的文件"ADT-15.0.0.zip"（不下载ADT，在线安装的方法：Location一栏中输入https://dl-ssl.google.com/android/eclipse/ 或者http://dl-ssl.google.com/android/eclipse/），最后点击"OK"按钮。
如图所示，选择所有要安装的工具，点击"Next"按钮进行安装。再次点击"Next"按钮，会出现一个"Review Licenses"的对话框，选择"I accept the terms of the license agreements"后点击"Finish"按钮即可。继续安装完ADT，重启Eclipse。
成功安装ADT后，Eclipse的菜单"Window"下会多出两个子菜单"Android SDK Manager"和"AVD Manager"。
4. Android SDK安装
下载Android SDK后直接进行默认安装，默认的安装目录为：C:\Program Files\Android\android-sdk。
下载地址：http://dl.google.com/android/installer_r15-windows.exe
安装完成后，打开Eclipse 菜单"Window-&gt;Preferences"，左栏中选择Android，右栏中SDK Location关联到SDK的安装目录"C:\Program Files\Android\android-sdk"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/224b818a2577f8c8a1c9f221a0533cbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9391515300456ef767388339cb555a6c/" rel="bookmark">
			Windows7英文系统显示中文乱码的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows7英文系统显示中文乱码的解决
很多安装Windows7英文操作系统的朋友会显示中文乱码，特别是在安装了中文程序的时候，那么如何解决呢？
如果我们所使用的操作系统是英文版的，那么会发现在运行简体中文的程序时无法正常显示中文，中文都变成了乱码。
这是由于大部分中文程序所使用的文字编码与Windows7英文系统的文字编码不同，所以会发生显示乱码的情况。
我们可以通过下面的方法对系统进行设置，来正常显示中文。
请点击Startmenu并点击ControlPanel来打开控制面板，点击Clock Language andRegion下面的Changedisplay language。如图所示：
在弹出窗口中点击Administrative选项卡，如图所示：
点击Changesystem locale按钮，如图所示：
将Currentsystem locale改为：Chinese(Simplified, PRC)，如图所示：
点击OK按钮后重新启动计算机，查看是否能够正常显示中文。
如果我们想要正常显示其他语言的程序，那么将Currentsystem locale改为相应的语言即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f66267c4c29e80a0b840120407a304/" rel="bookmark">
			Firefox启动慢等问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文系转载于百度文库，原文地址：http://wenku.baidu.com/view/b70fd90a79563c1ec5da71b1.html
Firefox启动慢等问题解决办法 对于安装
Firefox 浏览器的网友，在刚安装上 Firefox(火狐游览器 )后，在启动时总是要10多秒以上，哎，怎么会这么慢的呢？即使再重新 下载firefox，重装一次，还是慢，还有打开Firefox时为何占用系统****%内存呢？好吧，现在就告诉你吧，是你的设置不对，怎么做呢？请先把下面的文章看完吧。 firefox优化
总共四个步骤，另加一项（第五步，可选）
第一 步 如何加快浏览速度
首先在浏览器地址栏里输入“about:config”，等系统调用完毕之后按照下列步骤：
（1）更改　"network.http.pipelining"　为　ture
（2）更改　"network.http.proxy.pipelining" ture
（3）更改　"network.http.pipelining.maxrequests"为8，意思是同时可以接受8条申请
第二步 如何减少Firefox
(火狐)的内存占用量 输入about:config --〉点击右键，new-integer（整数） --〉输入 browser.cache.memory.capacity ---〉ok --〉输入数值，推荐16000。
第三步 如何加速Firefox的启动速度
做法简单，右键点击你的桌面上firefox快 捷方式，“属性”—&gt;“快捷方式”—&gt;“目标”，加参数“ /Prefetch:1”。即："D:\\ProgramFiles\\Mozilla Ffox\\firefox.exe" /Prefetch:1”（注意：“/”前有空格。这个D：是笔者Firefox的安装位置，请你根据自己的安装位置来，不要傻呼呼的连这也要问我呀。）
第 四步 设置信息反应
最后一步就是在Firefox再次输入“about:config”，在页面任何一个地方点右键，选择“New”— “Integer”在弹出的对话框中输入“nglayout.initialpaint.delay”并将其值改为“0”，表示当浏览器收到网站回复的信息后能够快速的反应。
第五 步 另外
装了那个tabs插件以后 firefox启动 慢了很多,要好几秒钟，让人难以忍受，其实firefox自身的简单设置其实完全可以摆脱TAB插件，实现完全在同一个firefox 窗口中浏览了。
（1） 在firefox地址栏里输入"about:config"打开设置
（2）找 到"browser.tabs.showsinglewindowmodeprefs"双击修改其值为"True"
（3）打开firefox的 Options(选项) 高级选项卡，找到标签页浏览设置，启用“强制打开新窗口的链接在下面打开”，选择子项中的“新标签页”。
*此外browser.tabs.loaddivertedinbackground 选项可以改变新tab的载入方式，前台或者后台
True=在后台 打开连接； False=在前台打开连接
*还可以鼠标中键(滚轮)关闭标签页，前提是middlemouse.contentLoadURL 值改"false"（默认）
问题：如何卸载、重装扩展
有的时候用ff卸载扩展时，“工具”－&gt;“扩展”中老是出现该扩展将在重启后卸载字样，重启后依然。解决方法是：
（1）找到扩展位置
C:\\Documents and Settings\\用户名\\ApplicationData\\Mozilla\\Firefox\\Profiles\\huktwibl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3f66267c4c29e80a0b840120407a304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d86b1437150bc9aece8e202b9bc498f/" rel="bookmark">
			Linux Shell 脚本中字符串的连接方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux Shell 脚本中字符串的连接方法 如果想要在变量后面添加一个字符，可以用一下方法：
$value1=home
$value2=${value1}"="
echo $value2
把要添加的字符串变量添加{}，并且需要把$放到外面。
这样输出的结果是：home=，也就是说连接成功。
又如：
[root@localhost sh]# var1=/etc/
[root@localhost sh]# var2=yum.repos.d/
[root@localhost sh]# var3=${var1}${var2}
[root@localhost sh]# echo $var3
/etc/yum.repos.d/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82725e7974d4bf610278b63c5dbb7f0/" rel="bookmark">
			Android中的Activity生命周期以及Task小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于activity和task的理解，网上可以找到一箩筐，中文的英文的，不过那始终是别人的理解，这里按照自己的思维习惯记录一下。
1、什么是task？
在Android中Task是为了完成特定功能的一些列activity的集合，是一个LIFO（Last In, First Out。后进先出）的栈，一个back stack（可以通过back键弹出top activity）。
要点：
1、不管Task A中的activity A是新建一个task还是在自己的task中启动activity B，在activity B中按返回键返回的始终是B前面一个activity A（如果A还存在的话），只有一种情况例外，activity B声明了launchMode为signalTask，如果这个时候后台任务中已经有一个Task B包含B，在B中按返回键将返回Task B中activity B的前面一个activity。下面这个图是典型的实例：
2、程序员可以通过下面两种方式来管理task。
1）在AndroidManifest.xml文件的activity属性中定义launchMode.
"standard"
默认的模式，系统会在启动这个activity的task中创建一个实例并把Intent传递给这个activity。这个activity可以被创建多次，各个实例可以存在与不同的task中，一个task也可以存在多个该activity实例。
"singleTop"
如果这个activity已经存在于当前任务并且是top activity，则系统不会另外创建一个实例（如果是standard模式则会另外创建一个），而是将Intent通过onNewIntent传递给这个实例。这个activity也可以被创建多次，各个实例可以存在与不同的task中，一个task同样可以存在多个这个activity的实例，前提是已经存在的activity不是当前任务的top activity。
"singleTask"
系统总是会创建一个新的task，并将这个activity初始化为这个新task的root activity。但是如果已经有另外一个task存在这个activity的实例，系统则不会另外创建，而是通过调用onNewIntent将intent传递给这个activity，任何时候都只有一个该activity的实例存在。（问题：这个时候如果这个activity不是top activity，在这个实例之上的其他activity如何处理？只是简单的将这个activity resume吗？"Note: Although the activity starts in a new task, the BACK key still returns the user to the previous activity.",从这个note看似乎是这样的，需要测试一下。）
singleTask的意思应该是任何时候只有一个task存在这个activity的实例。
"singleInstance"
与single类似，只有一点不同，系统不会引入任何其他activity到包含这个activity的task中，也就是说，singleInstance的意思是，这个activity是它所在的task的唯一成员，它启动的任何activity都会在其他task中打开。
2）调用startActivity时传入相应的Intent flag。
"FLAG_ACTIVITY_NEW_TASK"
行为与singleTask一样。
"FLAG_ACTIVITY_SINGLE_TOP"
行为与singleTop一样。
"FLAG_ACTIVITY_CLEAR_TOP"
单独使用这个flag时，只在这个activity存在与当前task时起作用，如果这个activity不是top activity，会清掉它上面的所有activity，resume该activity，并且通过onNewIntent传入intent。
这个flag通常和FLAG_ACTIVITY_NEW_TASK一起使用，这时候就会找到后台中存在这个activity的task并且把他放到可以处理这个intent的状态中（清掉它上面的activity）
3、任何activity在收到新的Intent之前都会先被暂停，因此这之后onResume总会被调用到，引用至onNewItem.
4、从eg702t stk和utk的表现来看，即使一个activity已经自杀了（某个时候自己调用finish），也会被am当作仍然存在于task中，因此不再重新创建这个activity，有可能会直接调用onNewIntent，明天去试试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f7bb5f14f572507ffc1dcb3249c290/" rel="bookmark">
			struts2 if 标签 test属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		====================正确的用法======开始===============================
&lt;s:if test="deptType==1" &gt;下属 &lt;/s:if&gt;如果你的数据库对应的字段类型为整形，可以这样使用；
&lt;s:if test="deptType=='1'" &gt;下属 &lt;/s:if&gt;如果你的数据库对应的字段类型为char，可以这样使用；
&lt;s:if test="deptType=='aa'" &gt;下属 &lt;/s:if&gt;如果你的数据库对应的字段类型为varchar，并且数据库中的字符串都是多余一个字符的字符串，可以这样使用；
&lt;s:if test="deptType==\"1\"" &gt;下属 &lt;/s:if&gt; &lt;s:else&gt;直属 &lt;/s:else&gt;（测试通过，这样用是最正确的）
==================正确的用法======结束================================
&lt;s:if test="deptType==\"1\"" &gt;下属&lt;/s:if&gt;&lt;s:else&gt;直属&lt;/s:else&gt;（测试通过，最正确的）
&lt;s:if test="{#deptType == '1'}" &gt;下属&lt;/s:if&gt;&lt;s:else&gt;直属&lt;/s:else&gt;（匹配的类型是char型）
前提：数据库中的类型是varchar，pojo中对应的字段的类型也是string。
如果数据库中的数据是整数字符串，例如1、2、3等，那么使用==
&lt;s:if test="deptType==1" &gt;下属 &lt;/s:if&gt; &lt;s:else&gt;直属 &lt;/s:else&gt;
如果数据库中的数据是字符串，aa、bb、cc等等
那么就要使用 &lt;s:if test="deptType=='aa'&gt;下属aa &lt;/s:if&gt; &lt;s:else&gt;直属 &lt;/s:else&gt;
如果数据库中既有数字字符串也普通的字符串，那么 &lt;s:if test="deptType=='aa'¦ ¦deptType=='1'"&gt;下属aa &lt;/s:if&gt; &lt;s:else&gt;直属 &lt;/s:else&gt; 无法正常的解析，
经过详细的测试，我确认这是struts2的一个bug
&lt;s:if test="%{deptType}==1" &gt;下属机构&lt;/s:if&gt;&lt;s:else&gt;直属机构&lt;/s:else&gt;失败!
&lt;s:if test="%{deptType}=='1'" &gt;下属机构&lt;/s:if&gt;&lt;s:else&gt;直属机构&lt;/s:else&gt;失败!
&lt;s:if test="deptType=='1'" &gt;下属机构&lt;/s:if&gt;&lt;s:else&gt;直属机构&lt;/s:else&gt;失败！
&lt;s:if test="%{deptType=='1'}" &gt;下属机构&lt;/s:if&gt;&lt;s:else&gt;直属机构&lt;/s:else&gt;失败！
&lt;s:if test="%{#deptType=='1'}" &gt;下属机构&lt;/s:if&gt;&lt;s:else&gt;直属机构&lt;/s:else&gt;失败！
&lt;s:if test="deptType==1" &gt;下属机构&lt;/s:if&gt;&lt;s:else&gt;直属机构&lt;/s:else&gt;（终于成功了）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82f7bb5f14f572507ffc1dcb3249c290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f414cd4a0774b5bc162e155d975000/" rel="bookmark">
			oracle 9i,10g,11g补丁下载地址大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		############################
Oracle Database Patch Number
############################ 9.2.0.4 = 3095277 9.2.0.5 = 3501955 9.2.0.6 = 3948480 9.2.0.7 = 4163445 9.2.0.8 = 4547809 10.1.0.3 = 3761843 10.1.0.4 = 4163362 10.1.0.5 = 4505133 10.2.0.2 = 4547817 10.2.0.3 = 5337014 10.2.0.4 = 6810189 10.2.0.5 = 8202632 11.1.0.7.0 = 6890831 11.2.0.2.0 = 10098816 ( 补丁超大,比IBM的补丁还猛) ###########################
oracle 11g 11.2.0.2 patch
########################### AIX 64bit (6.8G) ftp://updates.oracle.com/1009881 ... 0_AIX64-5L_1of7.zip ftp://updates.oracle.com/1009881 ... 0_AIX64-5L_2of7.zip ftp://updates.oracle.com/1009881 ... 0_AIX64-5L_3of7.zip ftp://updates.oracle.com/1009881 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26f414cd4a0774b5bc162e155d975000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4cbea92cfc4e32810ba1b0d0cf0f9f4/" rel="bookmark">
			C#控件及常用设计整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、窗体... 1
2、Label 控件... 3
3、TextBox 控件... 4
4、RichTextBox控件... 5
5、NumericUpDown 控件... 7
6、Button 控件... 7
7、GroupBox 控件... 7
8、RadioButton控件... 8
9、CheckBox 控件... 8
10、ListBox 控件... 9
11、ComboBox 控件... 10
12、CheckedListBox 控件... 10
13、PictureBox 控件的使用... 11
14、Timer 控件... 11
15、ProgressBar控件和 TrackBar控件... 12
16、HScrollBar 控件和 VScrollBar控件的使用... 13
17、OpenFileDialog 控件... 13
18、SaveFileDialog 控件... 14
19、FontDialog 控件... 14
20、ColorDialog控件... 14
21、PrintDialog控件和 PrintDocument 控件... 15
22、用户自定义对话框... 15
23、菜单控件... 15
25、MDI 应用程序设计... 16
26、键盘事件处理... 17
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4cbea92cfc4e32810ba1b0d0cf0f9f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e16ee9a9c7ee7a08f29a4de069a1a8d/" rel="bookmark">
			程序是调试出来的吗?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处：blog.csdn.net/zhangxingping
前些天听到有人无意中说到写程序就是要慢慢调试，看其表情，听其语气很有程序就是要慢慢调试才能写好的意思。当时心里楞了一下，不过由于事情比较多，也没有过多留意。事后有空想起这件事情让我感觉到有必要思考一下这么几个问题：程序是调试出来的吗？程序应该是调试出来的吗？好的程序应该是调试出来的吗？
还是先从自己从业的经历来说起，来思考这几个问题吧。大学毕业后，从事商用软件开发也不下5年的时间了，如果算上在校研究生期间跟导师做项目的话，编程的年龄已超过10年了。还记得上大学期间学习C语言的时候，老师布置一个用链表实现简单的学生信息管理的小程序。链表操作中大量使用到了指针，当时自己整整花费了4个小时在学校的机房里面调试程序中对链表的操作。那情形真可谓是“屡战屡败，屡败屡战”！最终在吃晚饭前把程序调试出来了。也就是经过那次4个多小时的调试，让我深深理解到了C语言中指针操作常常会出现哪些问题，以及应该如何避免这些常见的问题。也是那次调试深深理解到了有人说的“指针才是C的精华”这句话的含义。以至于后来在工作中，自己每次使用指针的时候都是小心翼翼。在编写和指针相关的代码的时候头脑中总是迸出一下的几个问题：这个指针如何初始化？是指向已有空间的地址还是需要新申请空间？如果是指向已有空间的地址，那该空间是否需要由自己编写的模块负责释放？如果是需要自己新申请空间，那么这些空间中的初始值是什么？这些空间应该由自己的模块负责释放还是别的模块赋值释放？这些空间应该在何时被释放？申请和释放使用的函数是否匹配（malloc，free，new ，delete），甚至是delete p; ，还是delete []p;都要在脑子里面思考一下，并在代码或者相关文档中查找相关的证据证明应该这样做而不是那样做。人就是这样，吃一堑，长一智。
还记得大学毕业的时候，老师们组织对毕业生的设计做检查，轮到检查我的时候，有一个老师问我到：“你做的这个软件有需求说明书吗？”。自己楞了几秒，然后低声说到没有。庆幸的是由于毕业设计做的那个小软件功能还算可以，也就顺利毕业了。但是那个老师的问题我依然没有忘记。回忆在学校做的毕业设计大部分都来自于老师的项目，我们只是跟着老师干活，具体就是编程了。软件需要实现那些功能也都是由导师口头表述给我们。需求说明书的概念只有在软件工程的课堂上听过。说实话当时连正式的软件说明书张什么样子都不是特别清楚。
毕业后有幸在一家国内一流的通信设备制造商那里从事交换机主机软件的开发。该公司当时是遵循SW－CMM的要求来对软件开发过程进行管理，以确保软件的质量。初次接受这样的管理过程很不适应，在学校里面基本上不用写什么需求分析，概要设计，详细设计等文档，写的代码也不作什么单元测试，集成测试等。老师口述要做什么，自己直接就编码，基本调试通过就给老师看看结果，老师说OK就OK了，不OK则继续修改或调试。在学校那些小程序真的是调试出来的，没有设计可以言。程序都是流水账，写到那儿算那儿。更谈不上复用性，维护性，可读性等。工作了，一切都不一样了！有了严格的开发过程保证，甚至这些过程文档还要经过评审，评审的意见还有很多“率”的要求。每个开发阶段都有很多的指标要求，达到这些指标了方能进行下一个阶段的开发。所以当时心里那是个抵触呀！不过抵触归抵触，该干的事情还是得干。当时加班加点已经是家常便饭。一两年下来，也做了两三个项目，这些项目有的做的还不错，也的也不是很理想。后来自己作项目也就自然按照公司的规范要求去做了，只是后面的几个项目做的就要比前面轻松多了。现在回顾起来，为什么后面越做越轻松了？也许是真正体会到了那些个严格过程的最终目的，以及理解了这些过程是怎样保证了能够达到这个最终目的的，因此自己就自然的顺应了这样的开发过程了吧。这段时间个人感觉是我进步最大的一段时间了，工作虽然辛苦，但是很充实。感觉比在大学期间学习的东西还多。
再后来，由于个人的原因离开这家公司。先后在两三家国内比较有名的公司从事软件开发工作，但都是感觉不自然，直到现在从事的这份工作吧。想想为什么后来的这几家公司让我感觉到不自然了，主要原因都是有种强烈的回到了学校的那种开发过程的感觉。
这里说说曾经去某大型公司面试的经历吧。该公司是一家国际知名的IT企业。技术面试的时候有一位面试官的问题几乎都是围绕这代码的调试这个主题进行的。面试完毕，我就感觉恐怕不能去这家公司了。因为从面试官的问题可以看出至少这位面试官对软件开发的和我的认识大相径庭。
也许正是我的这种认识让我在听到了文中开始那位开发人员的话的时候楞了一下。也许正是这种认识让促使我思考文中开始的那几个问题。程序的调试是软件开发过程中的一个必然的步骤。世界上恐怕不存在高人的程序不需要调试就能完美运行并满足要求的。但是调试真的足以重要到会影响真个程序的运行以至于不得不说程序是调试出来的吗？
也许现实中，有些程序基本上就是靠开发人员的不断调试和修正最终才运行起来的。自己在上大学期间的程序基本上也都是靠着这种调试才出来的。但是，为什么会这样呢？我想主要原因就是在开发前没有精密的设计和慎重的思考。正是由于没有这种思考，而直接上机器进行编程，才导致需要花费大量的时间来对程序进行调试和修改。实际上这种调试和修改都是针对之前没有进行缜密思考和设计的补偿，或者说大量的调试工作都是因为之前没有进行良好的设计和缜密思考的后果。正是在这种情况下，调试才显得非常重要。试想，如果在编码之前，进行了神秘的分析和良好的设计，并在编码的时候严格按照设计时的想法进行，稍有编程功底的人恐怕都不会再调试上花费太多的精力就能使自己的程序快速并良好的运转起来。也许小程序可以不需要编码前的思考和分析，完全可以在编码的过程中进行分析和思考，并通过大量的调试来弥补思考和分析不足带来的缺陷。但是，软件开发可决不能，也不应该是这样的。一个小程序往往都是自己一个人的事情，至于你浪费了多少时间进行调试，恐怕出来自己没有别人会关系。现在软件开发往往都是大型的，代码量上万，甚至十几万，几十万行的，也往往是团队协作开发的。此时，浪费的时间和精力往往会成为影响开发成本的一个主要因素。
开发人员往往都有这样的体会：调试时候的一个问题常常需要花费较多的时间来进行定位，分析，有的甚至需要数天的时间才能定位出问题的原因，而且这种时间上的花费往往是不可预期的。时而还会出现问题定位后，才发现修改是个大麻烦，因为可能涉及到程序的整个框架。但是如果先前有过良好的设计和缜密的分析，这种问题就在开发的前期被避免了。程序员要做的恐怕就是按照详细设计文档写好自己的代码，进行编译，消除编译时的告警和错误就可以了。但是由于前期良好的设计和分析避免了后期问题的出现所带来的成本降低往往是隐形的，不易被察觉的。因为没有出现问题，大家都认为这完全是理所当然的。很少有人会意识到这是前期缜密分析和良好设计的结果。实际中还有这样的情况：一个项目组在开发过程中经常加班加点，最后软件交付前还有一堆问题亟待解决。而有的项目组在整个开发过程中都很轻松没，交付时软件质量也很好。当然这样局面的出现可能有很多的原因，比如后者的开发人员经验丰富等。但是我想至少有一条就是后者在开发前期分析透彻，设计良好。正如成功需要一万个努力，而失败只要一个理由就够了。当然，前期的透彻分析和良好设计不是谁都能做到的，需要经验积累，需要耐心分析。因此，我们需要在工作中对造成目前不好的局面进行分析，为什么会这样？思考如何在下次避免这种情况的发生。按照PDCA循环来说，一开始做某件或者某种事情的时候，可能由于没有经验，P做的不是很好。此时只能依靠D和C来检验这种方法做事的结果。也就是说一开始我们编写程序（软件）的时候可能由于经验不足，分析和设计做得不好，甚至没有分析和设计，只能依靠调试来弥补这种缺失。但是，随着每次在PDC之后的A的进行，我们的经验在不断得到累计，对事物的认识也在不断深入，这样一来，我们就有能力在后续做同类事情的时候进行缜密的分析和良好的设计，以确保D本身就是按照正确的方式进行的，此时C的工作量也就小了很多。具体到程序（软件）的开发上来，有了相关的经验以后，我们就有能力在编码前对需求进行缜密的分析，给出良好详细的设计方案，那么在编码的时候就会轻松很多，调试也会变得简单很多。实际中有些开发人员之所以认为调试是相当重要的，以至于感觉到程序是调试出来的，就是因为前期没有做好分析和设计，导致所以问题都累积到了编码和调试阶段，此时不进行加班加点的调试就无法按时交付。个人认为PCDA中A的作用就是为了避免以后出现类似的问题，尽量把问题消灭在萌芽状态，消灭在开发过程的早期，这样不经能降低开发成本，也能保证交付良好的软件。
但愿所有的开发人员都不在加班加点进行调试。
PDCA：http://baike.baidu.com/view/529300.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2870fc2df6d79e9acff7459244ecf101/" rel="bookmark">
			RMAN-06207 &amp; RMAN-06208 问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RMAN-06207: WARNING: 11 objects could not be deleted for DISK channel(s) due
RMAN-06208: to mismatched status. Use CROSSCHECK command to fix status
RMAN-06210: List of Mismatched objects
RMAN-06211: ==========================
RMAN-06212: Object Type Filename/Handle
RMAN-06213: --------------- ---------------------------------------------------
RMAN-06214: Datafile Copy /u01/backup/ORCL_20110907_data_D-ORCL_I-1288914708_TS-SYSAUX_FNO-3_0dmlv7ia.bak
RMAN-06214: Datafile Copy /u01/backup/ORCL_20110907_data_D-ORCL_I-1288914708_TS-SYSTEM_FNO-1_0emlv7ip.bak
RMAN-06214: Datafile Copy /u01/backup/ORCL_20110907_data_D-ORCL_I-1288914708_TS-UNDOTBS1_FNO-2_0fmlv7j0.bak
RMAN-06214: Datafile Copy /u01/backup/ORCL_20110907_data_D-ORCL_I-1288914708_TS-UNDOTBS2_FNO-4_0gmlv7j7.bak
RMAN-06214: Datafile Copy /u01/backup/ORCL_20110907_data_D-ORCL_I-1288914708_TS-USERS_FNO-5_0hmlv7ja.bak
RMAN-06214: Datafile Copy /u01/backup/ORCL_20110908_data_D-ORCL_I-1288914708_TS-SYSAUX_FNO-3_0jmm1c89.bak
RMAN-06214: Datafile Copy /u01/backup/ORCL_20110908_data_D-ORCL_I-1288914708_TS-SYSTEM_FNO-1_0kmm1c8g.bak
RMAN-06214: Datafile Copy /u01/backup/ORCL_20110908_data_D-ORCL_I-1288914708_TS-UNDOTBS1_FNO-2_0lmm1c8v.bak
RMAN-06214: Datafile Copy /u01/backup/ORCL_20110908_data_D-ORCL_I-1288914708_TS-USERS_FNO-5_0mmm1c96.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2870fc2df6d79e9acff7459244ecf101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b8a8218af462ab24fb703a1147b6ff6/" rel="bookmark">
			青软实训报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		青软实训学习报告 接到去青软实训的实习通知以后，我毅然报了名，我不能错过这个千载难逢增长见识的机会，周五下午，我们一行十七人和带队老师踏上了旅程。汽车在当天晚上到了青岛，我们马上被安排下来，我们每个人都带着激动而好奇的心情开始了为期四天的实训体验生活。
由于实训时间很短，我们的课程很简单，就是网站编程的最基础的知识，包括HTML，JAVASCRIPT以及单间一个最简单的JSP网页。教授我们课程的张磊老师，真的很棒，我打心底尊敬这位年轻富有开发经验的老师，不厌其烦的给我们讲解知识细节。
张磊老师的教学方法和我们大学中学习编程语言是不一样的，在大学我们单纯注重的理论灌输，我们只停留在理论上，这段时间给我的最大感受之一是以前觉得自己学的很不错的编程语言竟然在实践中是这样不堪一击，差点让我绝望了。理论和实践差距就是这么大。
张磊老师首先和我们讲授基本理论，然后进行实例演示效果，加深我们对概念的理解，最后给我们几分钟的时间去练习掌握这些知识。我感觉这种教学方法非常实用见效，既学习了知识理论，又将所学知识马上运用到实践中，并且从中获得了编程的乐趣和快乐。
第二天，李老师带领我们参观了青岛软件园的以太科技软件公司，感受真正的IT企业应该是什么样子，让我们张了见识，了解IT行业的工作流程，参观公司的研发的产品和公司获得一些荣誉。在参观看见他们在各自的格子间里忙碌的身影，深知这个行业需要真正的技术高低，只要你有技术，我相信就一定可以混出自己的一片天地。
周一周二工作日，我们早上晚上挤公交，青岛是典型的岛城，路都有的一定的坡度，而且车多，公交车是哪个挤，感受上班族为生活拼搏的艰辛，想到我也即将踏入社会，和他们一样，常常使我我陷入沉思……
四天的实习生活就这样匆匆过去了，虽然这几天没有时间去青岛的景点去玩一玩，但我想自己获得了最有价值的经验，找到了自己与社会需求的真正差距，给我们警示我们还有好多东去学习，只有不断学习，才能不被社会抛弃。我会将这段学习经历铭记于心，它会成为踏入社会的宝贵经验。
杨传东 2011.10.19
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5166c7c6daa66f52d3800caa914e95/" rel="bookmark">
			事件查看器ID 1041
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件查看器ID 1041 事件类型: 错误
事件来源: Userenv
事件种类: 无
事件 ID: 1041
日期: 2010-3-14
事件: 15:48:04
用户: NT AUTHORITY\SYSTEM
计算机: LENOVO-S8K
描述:
Windows 不能为 {7B849a69-220F-451E-B3FE-2CB811AF94AE} 查询 DllName 注册表项，它将不会被加载。最有可能的原因是注册错误。
事件类型: 错误
事件来源: Userenv
事件种类: 无
事件 ID: 1041
日期: 2009-08-27
事件: 13:34:25
用户: NT AUTHORITY\SYSTEM
计算机:
描述:
Windows 无法查询 {CF7639F3-ABA2-41DB-97F2-81E2C5DBFC5D} 的 DllName 注册表项，它将不会被加载。最有可能的原因是注册错误。
有关更多信息，请参阅在 http://go.microsoft.com/fwlink/events.asp 的帮助和支持中心。
事件类型: 错误
事件来源: Userenv
事件种类: 无
事件 ID: 1041
日期: 2009-08-27
事件: 13:34:25
用户: NT AUTHORITY\SYSTEM
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d5166c7c6daa66f52d3800caa914e95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b104898f6d26089a48f79e4edfd1002d/" rel="bookmark">
			Detours使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Detours使用说明
1 介绍... 1
2 Detours API hook. 1
2.1 hook DLL 中的函数... 2
2.2 hook自定义c 函数... 3
2.3 hook类成员函数... 4
2.4 DetourCreateProcessWithDll 5
2.5 Detouring by Address. 5
1 介绍 Api hook包括两部分：api调用的截取和api函数的重定向。通过api hook可以修改函数的参数和返回值。关于原理的详细内容参见《windows核心编程》第19章和第22章。
2 Detours API hook "Detours is a library for intercepting arbitrary Win32 binary functions on x86 machines. Interception code is applied dynamically at runtime. Detours replaces the first few instructions of the target function with an unconditional jump to the user-provided detour function.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b104898f6d26089a48f79e4edfd1002d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c622f3b41ede85a7c81a01b2a31e33/" rel="bookmark">
			Nvl函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NVL函数　Oracle/PLSQL中的一个函数。
格式为：
NVL( string1, replace_with)
功能：如果string1为NULL，则NVL函数返回replace_with的值，否则返回string1的值。
注意事项：string1和replace_with必须为同一数据类型，除非显示的使用TO_CHAR函数。
例：NVL(TO_CHAR(numeric_column), 'some string') 其中numeric_column代指某个数字类型的值。
例：nvl(yanlei777,0) &gt; 0 NVL(yanlei777, 0) 的意思是 如果 yanlei777 是NULL， 则取 0值
通过查询获得某个字段的合计值，如果这个值为null将给出一个预设的默认值
例如： select nvl(sum(t.dwxhl),1) from tb_jhde t 就表示如果sum(t.dwxhl) = NULL 就返回 1
另一个有关的有用方法 declare i integer select nvl(sum(t.dwxhl),1) into i from tb_jhde t where zydm=-1这样就可以把获得的合计值存储到变量
i中，如果查询的值为null就把它的值设置为默认的1 orcale中: select nvl(rulescore,0) from zwjc_graderule where rulecode='FWTD';
如果记录中不存在rulecode ='FWTD'的数据.则查不出数据.
select nvl(rulescore,0) into rule_score from zwjc_graderule where rulecode='FWTD';会报查不到数据的错
select nvl(sum(rulescore),0) from zwjc_graderule where rulecode='FWTD';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c622f3b41ede85a7c81a01b2a31e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b571fccfa8b11670efc2ae248409f7e/" rel="bookmark">
			尚未备份数据库 &#34;***&#34; 的日志尾部。如果该日志包含您不希望丢失的工作，请使用 BACKUP LOG WITH NORECOVERY 备份该日志。请使用 RE...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用SQL Server 2005还原备份的数据库文件时出现的问题，如题。
前提：如果你有个数据库的.bak的备份文件。
右键点击 数据库任务--&gt;还原--&gt;数据库 1.还原的目标选择你要覆盖的数据库
2.还原的源选择 源设备找到你的.bak备份文件的路径
注意：选项中选择“覆盖现有数据库”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90cc1707871e64c6bf56f5bb2edb5400/" rel="bookmark">
			Web页面标签技术的使用(收集整理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页面标签技术是一种从访客浏览器端收集数据的技术，通常是通过放置在网站中每个页面的代码进行收集的。有些网站分析供应商也会添加一些特定的标签收集额外的信息，这是一种基于客户端的数据收集技术。 近几年来，页面标签技术使用很多。一方面，从技术的角度，页面分析技术更加容易实现；另外一方面，由于采集到的数据是在第三方服务器上存储和处理的，因此，数据维护的成本也大大降低。 页面标签技术的优点与缺点 优点： 1.不受代理和缓存服务器影响，提供更精确的会话跟踪 2.追踪客户端事件——例如，Javascript、Flash等Web2.0 3.收集客户端电子商务数据 4.实时收集和处理客户端数据 5.自动升级 6.数据存放在云端
缺点 1.错误设置回导致数据丢失 2.会受防火墙阻隔 3.不能追踪宽带或下载完成 4 .不能追踪搜索引擎蜘蛛
常用的 标签：
Jakarta Taglibs ----- JSTL(JavaServer Pages Standard Tag Library)的一个参考实现 http://tomcat.apache.org/taglibs/standard/
它是为了减少对解决类似通用问题的独立标记库的需求，在Java Community Process（JSR 52）的赞助下创建了JSTL（JavaServer Pages Standard Tag Library，JSP）标准标记库，为解决这些通用功能提供一个单一的标准解决方案。 JSTL特别为条件处理、迭代、国际化、数据库访问和可扩展标记语言（XML）处理提供支持。JSTL还引入了expression language（EL，表达式语言），极大地简化了对JSP中应用数据的访问和操作。JSTL包括4个JSP 1.2自定义标记库，每一个都涵盖了一个特定的功能领域。 核心（Core）标记库为日常任务提供通用支持，如显示和设置变量、重复使用一组项目、测试条件以及其他操作（如导入和重定向Web内容）。
XML标记库提供了对XML处理和操作的支持，包括XML节点的解析、迭代、基于XML数据的条件评估以及可扩展样式表语言转换（Extensible Style Language Transformations，XSLT）的执行。
国际化（Internationalization）标记库支持多语种的应用程序。
数据库（Database）标记库对访问和修改数据库数据提供标准化支持。
你能自定义扩展jsp 标签: http://tomcat.apache.org/taglibs/site/tutorial.html
cewolf tag ---- 用来在web上显示复杂图形报表的一个jsp tag。 http://cewolf.sourceforge.net/new/index.html
Google Tag Library -----该标记库和 Google 有关。使用该标记库，利用 Google 为你的网站提供网站查询，并且可以直接在你的网页里面显示搜查的结果 http://google-taglib.sourceforge.net/
Strut1 Tag Library http://struts.apache.org/1.3.10/struts-taglib/index.html
Strut2 Tag Library http://struts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90cc1707871e64c6bf56f5bb2edb5400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0291fc9406d3dcfddc61f9af7f8b445a/" rel="bookmark">
			iptables封ip段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下实用iptables封ip段的一些常见命令： 封单个IP的命令是： iptables -I INPUT -s 211.1.0.0 -j DROP 封IP段的命令是： iptables -I INPUT -s 211.1.0.0/16 -j DROP iptables -I INPUT -s 211.2.0.0/16 -j DROP iptables -I INPUT -s 211.3.0.0/16 -j DROP 封整个段的命令是： iptables -I INPUT -s 211.0.0.0/8 -j DROP 封几个段的命令是： iptables -I INPUT -s 61.37.80.0/24 -j DROP iptables -I INPUT -s 61.37.81.0/24 -j DROP 想在服务器启动自运行的话有三个方法： 1、把它加到/etc/rc.local中 2、iptables-save &gt;;/etc/sysconfig/iptables可以把你当前的iptables规则放到/etc/sysconfig/iptables中，系统启动iptables时自动执行。 3、service iptables save 也可以把你当前的iptables规则放/etc/sysconfig/iptables中，系统启动iptables时自动执行。 后两种更好此，一般iptables服务会在network服务之前启来，更安全。 解封的话： iptables -D INPUT -s IP地址 -j REJECT iptables -F 全清掉了 假如61.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0291fc9406d3dcfddc61f9af7f8b445a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8581a33c7ae856859fee2dd4e728e6b2/" rel="bookmark">
			Invalid location of tag (form) 的提示 原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;form&gt;&lt;/form&gt;不能写到&lt;table&gt;&lt;/table&gt;里面！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b845ec71e6ae8a791b393f142e724a82/" rel="bookmark">
			volatile、restrict、gcc优化、内嵌汇编的memory修饰符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GCC在C语言中内嵌汇编-转载 http://hi.baidu.com/liu_bin0101/blog/item/433103007852b216738b658d.html 在内嵌汇编中，可以将C语言表达式指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入哪个寄存器，以及如何将计算结果写回C 变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。
1、简单的内嵌汇编
例：
__asm__ __volatile__("hlt"); "__asm__"表示后面的代码为内嵌汇编，"asm"是"__asm__"的别名。"__volatile__"表示编译器不要优化代码，后面的指令 保留原样，"volatile"是它的别名。括号里面是汇编指令。
2、内嵌汇编举例
使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如在下面的汇编语句：
__asm__ __violate__ ("movl %1,%0" : "=r" (result) : "m" (input));
"movl %1,%0"是指令模板；"%0"和"%1"代表指令的操作数，称为占位符，内嵌汇编靠它们将C 语言表达式与指令操作数相对应。指令模板后面用小括号括起来的是C语言表达式，本例中只有两个："result"和"input"，他们按照出现的顺序分 别与指令操作数"%0"，"%1"对应；注意对应顺序：第一个C 表达式对应"%0"；第二个表达式对应"%1"，依次类推，操作数至多有10 个，分别用"%0","%1"...."%9"表示。在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。 "result"前面的限制字符串是"=r"，其中"="表示"result"是输出操作数，"r" 表示需要将"result"与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是"result"本身，当然指令执行 完后需要将寄存器中的值存入变量"result"，从表面上看好像是指令直接对"result"进行操作，实际上GCC做了隐式处理，这样我们可以少写一 些指令。"input"前面的"r"表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。
C表达式或者变量与寄存器的关系由GCC自动处理，我们只需使用限制字符串指导GCC如何处理即可。限制字符必须与指令对操作数的要求相匹配，否则产生的 汇编代码将会有错，读者可以将上例中的两个"r"，都改为"m"(m表示操作数放在内存，而不是寄存器中)，编译后得到的结果是：
movl input, result
很明显这是一条非法指令，因此限制字符串必须与指令对操作数的要求匹配。例如指令movl允许寄存器到寄存器，立即数到寄存器等，但是不允许内存到内存的操作，因此两个操作数不能同时使用"m"作为限定字符。
内嵌汇编语法如下：
__asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分)
共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用":"格开，汇编语句模板必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用":"格开，相应部分内容为空。例如：
__asm__ __volatile__("cli": : :"memory")
1、汇编语句模板
汇编语句模板由汇编语句序列组成，语句之间使用";"、"\n"或"\n\t"分开。指令中的操作数可以使用占位符引用C语言变量，操作数占位符最多10个，名称如下：%0，%1，...，%9。指令中使用占位符表示的操作数，总被视为long型（4个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，"b"代表低字节，"h"代表高字节，例如：%h1。
2、输出部分
输出部分描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由限定字符串和C 语言变量组成。每个输出操作数的限定字符串必须包含"="表示他是一个输出操作数。
例：
__asm__ __volatile__("pushfl ; popl %0 ; cli":"=g" (x) )
描述符字符串表示对该变量的限制条件，这样GCC 就可以根据这些条件决定如何分配寄存器，如何产生必要的代码处理指令操作数与C表达式或C变量之间的联系。
3、输入部分
输入部分描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符由限定字符串和C语言表达式或者C语言变量组成。
例1 ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b845ec71e6ae8a791b393f142e724a82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183b11e5c9d5b3dff2414e876f786d5e/" rel="bookmark">
			JavaScript 获得 汉字 的 完整 拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var Pinyin={} Pinyin._pinyin={"a":"\u554a\u963f\u9515","ai":"\u57c3\u6328\u54ce\u5509\u54c0\u7691\u764c\u853c\u77ee\u827e\u788d\u7231\u9698\u8bf6\u6371\u55f3\u55cc\u5ad2\u7477\u66a7\u7839\u953f\u972d","an":"\u978d\u6c28\u5b89\u4ffa\u6309\u6697\u5cb8\u80fa\u6848\u8c19\u57ef\u63de\u72b4\u5eb5\u6849\u94f5\u9e4c\u9878\u9eef","ang":"\u80ae\u6602\u76ce","ao":"\u51f9\u6556\u71ac\u7ff1\u8884\u50b2\u5965\u61ca\u6fb3\u5773\u62d7\u55f7\u5662\u5c99\u5ed2\u9068\u5aaa\u9a9c\u8071\u87af\u93ca\u9ccc\u93d6","ba":"\u82ad\u634c\u6252\u53ed\u5427\u7b06\u516b\u75a4\u5df4\u62d4\u8dcb\u9776\u628a\u8019\u575d\u9738\u7f62\u7238\u8307\u83dd\u8406\u636d\u5c9c\u705e\u6777\u94af\u7c91\u9c85\u9b43","bai":"\u767d\u67cf\u767e\u6446\u4f70\u8d25\u62dc\u7a17\u859c\u63b0\u97b4","ban":"\u6591\u73ed\u642c\u6273\u822c\u9881\u677f\u7248\u626e\u62cc\u4f34\u74e3\u534a\u529e\u7eca\u962a\u5742\u8c73\u94a3\u7622\u764d\u8228","bang":"\u90a6\u5e2e\u6886\u699c\u8180\u7ed1\u68d2\u78c5\u868c\u9551\u508d\u8c24\u84a1\u8783","bao":"\u82de\u80de\u5305\u8912\u96f9\u4fdd\u5821\u9971\u5b9d\u62b1\u62a5\u66b4\u8c79\u9c8d\u7206\u52f9\u8446\u5b80\u5b62\u7172\u9e28\u8913\u8db5\u9f85","bo":"\u5265\u8584\u73bb\u83e0\u64ad\u62e8\u94b5\u6ce2\u535a\u52c3\u640f\u94c2\u7b94\u4f2f\u5e1b\u8236\u8116\u818a\u6e24\u6cca\u9a73\u4eb3\u8543\u5575\u997d\u6a97\u64d8\u7934\u94b9\u9e41\u7c38\u8ddb","bei":"\u676f\u7891\u60b2\u5351\u5317\u8f88\u80cc\u8d1d\u94a1\u500d\u72c8\u5907\u60eb\u7119\u88ab\u5b5b\u9642\u90b6\u57e4\u84d3\u5457\u602b\u6096\u789a\u9e4e\u8919\u943e","ben":"\u5954\u82ef\u672c\u7b28\u755a\u574c\u951b","beng":"\u5d29\u7ef7\u752d\u6cf5\u8e66\u8ff8\u552a\u5623\u750f","bi":"\u903c\u9f3b\u6bd4\u9119\u7b14\u5f7c\u78a7\u84d6\u853d\u6bd5\u6bd9\u6bd6\u5e01\u5e87\u75f9\u95ed\u655d\u5f0a\u5fc5\u8f9f\u58c1\u81c2\u907f\u965b\u5315\u4ef3\u4ffe\u8298\u835c\u8378\u5421\u54d4\u72f4\u5eb3\u610e\u6ed7\u6fde\u5f3c\u59a3\u5a62\u5b16\u74a7\u8d32\u7540\u94cb\u79d5\u88e8\u7b5a\u7b85\u7be6\u822d\u895e\u8df8\u9ac0","bian":"\u97ad\u8fb9\u7f16\u8d2c\u6241\u4fbf\u53d8\u535e\u8fa8\u8fa9\u8fab\u904d\u533e\u5f01\u82c4\u5fed\u6c74\u7f0f\u7178\u782d\u78a5\u7a39\u7a86\u8759\u7b3e\u9cca","biao":"\u6807\u5f6a\u8198\u8868\u5a4a\u9aa0\u98d1\u98d9\u98da\u706c\u9556\u9573\u762d\u88f1\u9cd4","bie":"\u9cd6\u618b\u522b\u762a\u8e69\u9cd8","bin":"\u5f6c\u658c\u6fd2\u6ee8\u5bbe\u6448\u50a7\u6d5c\u7f24\u73a2\u6ba1\u8191\u9554\u9acc\u9b13","bing":"\u5175\u51b0\u67c4\u4e19\u79c9\u997c\u70b3\u75c5\u5e76\u7980\u90b4\u6452\u7ee0\u678b\u69df\u71f9","bu":"\u6355\u535c\u54fa\u8865\u57e0\u4e0d\u5e03\u6b65\u7c3f\u90e8\u6016\u62ca\u535f\u900b\u74ff\u6661\u949a\u91ad","ca":"\u64e6\u5693\u7924","cai":"\u731c\u88c1\u6750\u624d\u8d22\u776c\u8e29\u91c7\u5f69\u83dc\u8521","can":"\u9910\u53c2\u8695\u6b8b\u60ed\u60e8\u707f\u9a96\u74a8\u7cb2\u9eea","cang":"\u82cd\u8231\u4ed3\u6ca7\u85cf\u4f27","cao":"\u64cd\u7cd9\u69fd\u66f9\u8349\u8279\u5608\u6f15\u87ac\u825a","ce":"\u5395\u7b56\u4fa7\u518c\u6d4b\u5202\u5e3b\u607b","ceng":"\u5c42\u8e6d\u564c","cha":"\u63d2\u53c9\u832c\u8336\u67e5\u78b4\u643d\u5bdf\u5c94\u5dee\u8be7\u7339\u9987\u6c4a\u59f9\u6748\u6942\u69ce\u6aab\u9497\u9538\u9572\u8869","chai":"\u62c6\u67f4\u8c7a\u4faa\u8308\u7625\u867f\u9f87","chan":"\u6400\u63ba\u8749\u998b\u8c17\u7f20\u94f2\u4ea7\u9610\u98a4\u5181\u8c04\u8c36\u8487\u5edb\u5fcf\u6f7a\u6fb6\u5b71\u7fbc\u5a75\u5b17\u9aa3\u89c7\u7985\u9561\u88e3\u87fe\u8e94","chang":"\u660c\u7316\u573a\u5c1d\u5e38\u957f\u507f\u80a0\u5382\u655e\u7545\u5531\u5021\u4f25\u9b2f\u82cc\u83d6\u5f9c\u6005\u60dd\u960a\u5a3c\u5ae6\u6636\u6c05\u9cb3","chao":"\u8d85\u6284\u949e\u671d\u5632\u6f6e\u5de2\u5435\u7092\u600a\u7ec9\u6641\u8016","che":"\u8f66\u626f\u64a4\u63a3\u5f7b\u6f88\u577c\u5c6e\u7817","chen":"\u90f4\u81e3\u8fb0\u5c18\u6668\u5ff1\u6c89\u9648\u8d81\u886c\u79f0\u8c0c\u62bb\u55d4\u5bb8\u741b\u6987\u809c\u80c2\u789c\u9f80","cheng":"\u6491\u57ce\u6a59\u6210\u5448\u4e58\u7a0b\u60e9\u6f84\u8bda\u627f\u901e\u9a8b\u79e4\u57d5\u5d4a\u5fb5\u6d48\u67a8\u67fd\u6a18\u665f\u584d\u77a0\u94d6\u88ce\u86cf\u9172","chi":"\u5403\u75f4\u6301\u5319\u6c60\u8fdf\u5f1b\u9a70\u803b\u9f7f\u4f88\u5c3a\u8d64\u7fc5\u65a5\u70bd\u50ba\u5880\u82aa\u830c\u640b\u53f1\u54e7\u557b\u55e4\u5f73\u996c\u6cb2\u5ab8\u6555\u80dd\u7719\u7735\u9e31\u761b\u892b\u86a9\u87ad\u7b1e\u7bea\u8c49\u8e05\u8e1f\u9b51","chong":"\u5145\u51b2\u866b\u5d07\u5ba0\u833a\u5fe1\u61a7\u94f3\u825f","chou":"\u62bd\u916c\u7574\u8e0c\u7a20\u6101\u7b79\u4ec7\u7ef8\u7785\u4e11\u4fe6\u5733\u5e31\u60c6\u6eb4\u59af\u7633\u96e0\u9c8b","chu":"\u81ed\u521d\u51fa\u6a71\u53a8\u8e87\u9504\u96cf\u6ec1\u9664\u695a\u7840\u50a8\u77d7\u6410\u89e6\u5904\u4e8d\u520d\u61b7\u7ecc\u6775\u696e\u6a17\u870d\u8e70\u9edc","chuan":"\u63e3\u5ddd\u7a7f\u693d\u4f20\u8239\u5598\u4e32\u63be\u821b\u60f4\u9044\u5ddb\u6c1a\u948f\u9569\u8221","chuang":"\u75ae\u7a97\u5e62\u5e8a\u95ef\u521b\u6006","chui":"\u5439\u708a\u6376\u9524\u5782\u9672\u68f0\u69cc","chun":"\u6625\u693f\u9187\u5507\u6df3\u7eaf\u8822\u4fc3\u83bc\u6c8c\u80ab\u6710\u9e51\u877d","chuo":"\u6233\u7ef0\u851f\u8fb6\u8f8d\u955e\u8e14\u9f8a","ci":"\u75b5\u8328\u78c1\u96cc\u8f9e\u6148\u74f7\u8bcd\u6b64\u523a\u8d50\u6b21\u8360\u5472\u5d6f\u9e5a\u8785\u7ccd\u8d91","cong":"\u806a\u8471\u56f1\u5306\u4ece\u4e1b\u506c\u82c1\u6dd9\u9aa2\u742e\u7481\u679e","cu":"\u51d1\u7c97\u918b\u7c07\u731d\u6b82\u8e59","cuan":"\u8e7f\u7be1\u7a9c\u6c46\u64ba\u6615\u7228","cui":"\u6467\u5d14\u50ac\u8106\u7601\u7cb9\u6dec\u7fe0\u8403\u60b4\u7480\u69b1\u96b9","cun":"\u6751\u5b58\u5bf8\u78cb\u5fd6\u76b4","cuo":"\u64ae\u6413\u63aa\u632b\u9519\u539d\u811e\u9509\u77ec\u75e4\u9e7e\u8e49\u8e9c","da":"\u642d\u8fbe\u7b54\u7629\u6253\u5927\u8037\u54d2\u55d2\u601b\u59b2\u75b8\u8921\u7b2a\u977c\u9791","dai":"\u5446\u6b79\u50a3\u6234\u5e26\u6b86\u4ee3\u8d37\u888b\u5f85\u902e\u6020\u57ed\u7519\u5454\u5cb1\u8fe8\u902f\u9a80\u7ed0\u73b3\u9edb","dan":"\u803d\u62c5\u4e39\u5355\u90f8\u63b8\u80c6\u65e6\u6c2e\u4f46\u60ee\u6de1\u8bde\u5f39\u86cb\u4ebb\u510b\u5369\u840f\u5556\u6fb9\u6a90\u6b9a\u8d55\u7708\u7605\u8043\u7baa","dang":"\u5f53\u6321\u515a\u8361\u6863\u8c20\u51fc\u83ea\u5b95\u7800\u94db\u88c6","dao":"\u5200\u6363\u8e48\u5012\u5c9b\u7977\u5bfc\u5230\u7a3b\u60bc\u9053\u76d7\u53e8\u5541\u5fc9\u6d2e\u6c18\u7118\u5fd1\u7e9b","de":"\u5fb7\u5f97\u7684\u951d","deng":"\u8e6c\u706f\u767b\u7b49\u77aa\u51f3\u9093\u5654\u5d9d\u6225\u78f4\u956b\u7c26","di":"\u5824\u4f4e\u6ef4\u8fea\u654c\u7b1b\u72c4\u6da4\u7fdf\u5ae1\u62b5\u5e95\u5730\u8482\u7b2c\u5e1d\u5f1f\u9012\u7f14\u6c10\u7c74\u8bcb\u8c1b\u90b8\u577b\u839c\u837b\u5600\u5a23\u67e2\u68e3\u89cc\u7825\u78b2\u7747\u955d\u7f9d\u9ab6","dian":"\u98a0\u6382\u6ec7\u7898\u70b9\u5178\u975b\u57ab\u7535\u4f43\u7538\u5e97\u60e6\u5960\u6dc0\u6bbf\u4e36\u963d\u576b\u57dd\u5dc5\u73b7\u765c\u766b\u7c1f\u8e2e","diao":"\u7889\u53fc\u96d5\u51cb\u5201\u6389\u540a\u9493\u8c03\u8f7a\u94de\u8729\u7c9c\u8c82","die":"\u8dcc\u7239\u789f\u8776\u8fed\u8c0d\u53e0\u4f5a\u57a4\u581e\u63f2\u558b\u6e2b\u8f76\u7252\u74de\u8936\u800b\u8e40\u9cbd\u9cce","ding":"\u4e01\u76ef\u53ee\u9489\u9876\u9f0e\u952d\u5b9a\u8ba2\u4e22\u4ec3\u5576\u738e\u815a\u7887\u753a\u94e4\u7594\u8035\u914a","dong":"\u4e1c\u51ac\u8463\u61c2\u52a8\u680b\u4f97\u606b\u51bb\u6d1e\u578c\u549a\u5cbd\u5cd2\u5902\u6c21\u80e8\u80f4\u7850\u9e2b","dou":"\u515c\u6296\u6597\u9661\u8c46\u9017\u75d8\u8538\u94ad\u7aa6\u7aac\u86aa\u7bfc\u9161","du":"\u90fd\u7763\u6bd2\u728a\u72ec\u8bfb\u5835\u7779\u8d4c\u675c\u9540\u809a\u5ea6\u6e21\u5992\u828f\u561f\u6e0e\u691f\u6a50\u724d\u8839\u7b03\u9ad1\u9ee9","duan":"\u7aef\u77ed\u953b\u6bb5\u65ad\u7f0e\u5f56\u6934\u7145\u7c16","dui":"\u5806\u5151\u961f\u5bf9\u603c\u619d\u7893","dun":"\u58a9\u5428\u8e72\u6566\u987f\u56e4\u949d\u76fe\u9041\u7096\u7818\u7905\u76f9\u9566\u8db8","duo":"\u6387\u54c6\u591a\u593a\u579b\u8eb2\u6735\u8dfa\u8235\u5241\u60f0\u5815\u5484\u54da\u7f0d\u67c1\u94ce\u88f0\u8e31","e":"\u86fe\u5ce8\u9e45\u4fc4\u989d\u8bb9\u5a25\u6076\u5384\u627c\u904f\u9102\u997f\u5669\u8c14\u57a9\u57ad\u82ca\u83aa\u843c\u5443\u6115\u5c59\u5a40\u8f6d\u66f7\u816d\u786a\u9507\u9537\u9e57\u989a\u9cc4","en":"\u6069\u84bd\u6441\u5514\u55ef","er":"\u800c\u513f\u8033\u5c14\u9975\u6d31\u4e8c\u8d30\u8fe9\u73e5\u94d2\u9e38\u9c95","fa":"\u53d1\u7f5a\u7b4f\u4f10\u4e4f\u9600\u6cd5\u73d0\u57a1\u781d","fan":"\u85e9\u5e06\u756a\u7ffb\u6a0a\u77fe\u9492\u7e41\u51e1\u70e6\u53cd\u8fd4\u8303\u8d29\u72af\u996d\u6cdb\u8629\u5e61\u72ad\u68b5\u6535\u71d4\u7548\u8e6f","fang":"\u574a\u82b3\u65b9\u80aa\u623f\u9632\u59a8\u4eff\u8bbf\u7eba\u653e\u531a\u90a1\u5f77\u94ab\u822b\u9c82","fei":"\u83f2\u975e\u5561\u98de\u80a5\u532a\u8bfd\u5420\u80ba\u5e9f\u6cb8\u8d39\u82be\u72d2\u60b1\u6ddd\u5983\u7ecb\u7eef\u69a7\u8153\u6590\u6249\u7953\u7829\u9544\u75f1\u871a\u7bda\u7fe1\u970f\u9cb1","fen":"\u82ac\u915a\u5429\u6c1b\u5206\u7eb7\u575f\u711a\u6c7e\u7c89\u594b\u4efd\u5fff\u6124\u7caa\u507e\u7035\u68fc\u610d\u9cbc\u9f22","feng":"\u4e30\u5c01\u67ab\u8702\u5cf0\u950b\u98ce\u75af\u70fd\u9022\u51af\u7f1d\u8bbd\u5949\u51e4\u4ff8\u9146\u8451\u6ca3\u781c","fu":"\u4f5b\u5426\u592b\u6577\u80a4\u5b75\u6276\u62c2\u8f90\u5e45\u6c1f\u7b26\u4f0f\u4fd8\u670d\u6d6e\u6daa\u798f\u88b1\u5f17\u752b\u629a\u8f85\u4fef\u91dc\u65a7\u812f\u8151\u5e9c\u8150\u8d74\u526f\u8986\u8d4b\u590d\u5085\u4ed8\u961c\u7236\u8179\u8d1f\u5bcc\u8ba3\u9644\u5987\u7f1a\u5490\u5310\u51eb\u90db\u8299\u82fb\u832f\u83a9\u83d4\u544b\u5e5e\u6ecf\u8274\u5b5a\u9a78\u7ec2\u6874\u8d59\u9efb\u9efc\u7f58\u7a03\u99a5\u864d\u86a8\u8709\u8760\u876e\u9eb8\u8dba\u8dd7\u9cc6","ga":"\u5676\u560e\u86e4\u5c2c\u5477\u5c15\u5c1c\u65ee\u9486","gai":"\u8be5\u6539\u6982\u9499\u76d6\u6e89\u4e10\u9654\u5793\u6224\u8d45\u80f2","gan":"\u5e72\u7518\u6746\u67d1\u7aff\u809d\u8d76\u611f\u79c6\u6562\u8d63\u5769\u82f7\u5c34\u64c0\u6cd4\u6de6\u6f89\u7ec0\u6a44\u65f0\u77f8\u75b3\u9150","gang":"\u5188\u521a\u94a2\u7f38\u809b\u7eb2\u5c97\u6e2f\u6206\u7f61\u9883\u7b7b","gong":"\u6760\u5de5\u653b\u529f\u606d\u9f9a\u4f9b\u8eac\u516c\u5bab\u5f13\u5de9\u6c5e\u62f1\u8d21\u5171\u857b\u5efe\u54a3\u73d9\u80b1\u86a3\u86e9\u89e5","gao":"\u7bd9\u768b\u9ad8\u818f\u7f94\u7cd5\u641e\u9550\u7a3f\u544a\u777e\u8bf0\u90dc\u84bf\u85c1\u7f1f\u69d4\u69c1\u6772\u9506","ge":"\u54e5\u6b4c\u6401\u6208\u9e3d\u80f3\u7599\u5272\u9769\u845b\u683c\u9601\u9694\u94ec\u4e2a\u5404\u9b32\u4ee1\u54ff\u5865\u55dd\u7ea5\u643f\u8188\u784c\u94ea\u9549\u88bc\u988c\u867c\u8238\u9abc\u9ac2","gei":"\u7ed9","gen":"\u6839\u8ddf\u4e98\u831b\u54cf\u826e","geng":"\u8015\u66f4\u5e9a\u7fb9\u57c2\u803f\u6897\u54fd\u8d53\u9ca0","gou":"\u94a9\u52fe\u6c9f\u82df\u72d7\u57a2\u6784\u8d2d\u591f\u4f5d\u8bdf\u5ca3\u9058\u5abe\u7f11\u89cf\u5f40\u9e32\u7b31\u7bdd\u97b2","gu":"\u8f9c\u83c7\u5495\u7b8d\u4f30\u6cbd\u5b64\u59d1\u9f13\u53e4\u86ca\u9aa8\u8c37\u80a1\u6545\u987e\u56fa\u96c7\u560f\u8bc2\u83f0\u54cc\u5d2e\u6c69\u688f\u8f71\u726f\u727f\u80cd\u81cc\u6bc2\u77bd\u7f5f\u94b4\u9522\u74e0\u9e2a\u9e44\u75fc\u86c4\u9164\u89da\u9cb4\u9ab0\u9e58","gua":"\u522e\u74dc\u5250\u5be1\u6302\u8902\u5366\u8bd6\u5471\u681d\u9e39","guai":"\u4e56\u62d0\u602a\u54d9","guan":"\u68fa\u5173\u5b98\u51a0\u89c2\u7ba1\u9986\u7f50\u60ef\u704c\u8d2f\u500c\u839e\u63bc\u6dab\u76e5\u9e73\u9ccf","guang":"\u5149\u5e7f\u901b\u72b7\u6844\u80f1\u7592","gui":"\u7470\u89c4\u572d\u7845\u5f52\u9f9f\u95fa\u8f68\u9b3c\u8be1\u7678\u6842\u67dc\u8dea\u8d35\u523d\u5326\u523f\u5e8b\u5b84\u59ab\u6867\u7085\u6677\u7688\u7c0b\u9c91\u9cdc","gun":"\u8f8a\u6eda\u68cd\u4e28\u886e\u7ef2\u78d9\u9ca7","guo":"\u9505\u90ed\u56fd\u679c\u88f9\u8fc7\u9998\u8803\u57da\u63b4\u5459\u56d7\u5e3c\u5d1e\u7313\u6901\u8662\u951e\u8052\u872e\u873e\u8748","ha":"\u54c8","hai":"\u9ab8\u5b69\u6d77\u6c26\u4ea5\u5bb3\u9a87\u54b4\u55e8\u988f\u91a2","han":"\u9163\u61a8\u90af\u97e9\u542b\u6db5\u5bd2\u51fd\u558a\u7f55\u7ff0\u64bc\u634d\u65f1\u61be\u608d\u710a\u6c57\u6c49\u9097\u83e1\u6496\u961a\u701a\u6657\u7113\u9894\u86b6\u9f3e","hen":"\u592f\u75d5\u5f88\u72e0\u6068","hang":"\u676d\u822a\u6c86\u7ed7\u73e9\u6841","hao":"\u58d5\u568e\u8c6a\u6beb\u90dd\u597d\u8017\u53f7\u6d69\u8585\u55e5\u5686\u6fe0\u704f\u660a\u7693\u98a2\u869d","he":"\u5475\u559d\u8377\u83cf\u6838\u79be\u548c\u4f55\u5408\u76d2\u8c89\u9602\u6cb3\u6db8\u8d6b\u8910\u9e64\u8d3a\u8bc3\u52be\u58d1\u85ff\u55d1\u55ec\u9616\u76cd\u86b5\u7fee","hei":"\u563f\u9ed1","heng":"\u54fc\u4ea8\u6a2a\u8861\u6052\u8a07\u8605","hong":"\u8f70\u54c4\u70d8\u8679\u9e3f\u6d2a\u5b8f\u5f18\u7ea2\u9ec9\u8ba7\u836d\u85a8\u95f3\u6cd3","hou":"\u5589\u4faf\u7334\u543c\u539a\u5019\u540e\u5820\u5f8c\u9005\u760a\u7bcc\u7cc7\u9c8e\u9aba","hu":"\u547c\u4e4e\u5ffd\u745a\u58f6\u846b\u80e1\u8774\u72d0\u7cca\u6e56\u5f27\u864e\u552c\u62a4\u4e92\u6caa\u6237\u51b1\u553f\u56eb\u5cb5\u7322\u6019\u60da\u6d52\u6ef9\u7425\u69f2\u8f77\u89f3\u70c0\u7173\u623d\u6248\u795c\u9e55\u9e71\u7b0f\u9190\u659b","hua":"\u82b1\u54d7\u534e\u733e\u6ed1\u753b\u5212\u5316\u8bdd\u5290\u6d4d\u9a85\u6866\u94e7\u7a1e","huai":"\u69d0\u5f8a\u6000\u6dee\u574f\u8fd8\u8e1d","huan":"\u6b22\u73af\u6853\u7f13\u6362\u60a3\u5524\u75ea\u8c62\u7115\u6da3\u5ba6\u5e7b\u90c7\u5942\u57b8\u64d0\u571c\u6d39\u6d63\u6f36\u5bf0\u902d\u7f33\u953e\u9ca9\u9b1f","huang":"\u8352\u614c\u9ec4\u78fa\u8757\u7c27\u7687\u51f0\u60f6\u714c\u6643\u5e4c\u604d\u8c0e\u968d\u5fa8\u6e5f\u6f62\u9051\u749c\u8093\u7640\u87e5\u7bc1\u9cc7","hui":"\u7070\u6325\u8f89\u5fbd\u6062\u86d4\u56de\u6bc1\u6094\u6167\u5349\u60e0\u6666\u8d3f\u79fd\u4f1a\u70e9\u6c47\u8bb3\u8bf2\u7ed8\u8bd9\u8334\u835f\u8559\u54d5\u5599\u96b3\u6d04\u5f57\u7f0b\u73f2\u6656\u605a\u867a\u87ea\u9ebe","hun":"\u8364\u660f\u5a5a\u9b42\u6d51\u6df7\u8be8\u9984\u960d\u6eb7\u7f17","huo":"\u8c41\u6d3b\u4f19\u706b\u83b7\u6216\u60d1\u970d\u8d27\u7978\u6509\u56af\u5925\u94ac\u952a\u956c\u8020\u8816","ji":"\u51fb\u573e\u57fa\u673a\u7578\u7a3d\u79ef\u7b95\u808c\u9965\u8ff9\u6fc0\u8ba5\u9e21\u59ec\u7ee9\u7f09\u5409\u6781\u68d8\u8f91\u7c4d\u96c6\u53ca\u6025\u75be\u6c72\u5373\u5ac9\u7ea7\u6324\u51e0\u810a\u5df1\u84df\u6280\u5180\u5b63\u4f0e\u796d\u5242\u60b8\u6d4e\u5bc4\u5bc2\u8ba1\u8bb0\u65e2\u5fcc\u9645\u5993\u7ee7\u7eaa\u5c45\u4e0c\u4e69\u525e\u4f76\u4f74\u8114\u58bc\u82a8\u82b0\u8401\u84ba\u857a\u638e\u53fd\u54ad\u54dc\u5527\u5c8c\u5d74\u6d0e\u5f50\u5c50\u9aa5\u757f\u7391\u696b\u6b9b\u621f\u6222\u8d4d\u89ca\u7284\u9f51\u77f6\u7f81\u5d47\u7a37\u7620\u7635\u866e\u7b08\u7b04\u66a8\u8dfb\u8dfd\u9701\u9c9a\u9cab\u9afb\u9e82","jia":"\u5609\u67b7\u5939\u4f73\u5bb6\u52a0\u835a\u988a\u8d3e\u7532\u94be\u5047\u7a3c\u4ef7\u67b6\u9a7e\u5ac1\u4f3d\u90cf\u62ee\u5cac\u6d43\u8fe6\u73c8\u621b\u80db\u605d\u94d7\u9553\u75c2\u86f1\u7b33\u8888\u8dcf","jian":"\u6b7c\u76d1\u575a\u5c16\u7b3a\u95f4\u714e\u517c\u80a9\u8270\u5978\u7f04\u8327\u68c0\u67ec\u78b1\u7877\u62e3\u6361\u7b80\u4fed\u526a\u51cf\u8350\u69db\u9274\u8df5\u8d31\u89c1\u952e\u7bad\u4ef6\u5065\u8230\u5251\u996f\u6e10\u6e85\u6da7\u5efa\u50ed\u8c0f\u8c2b\u83c5\u84b9\u641b\u56dd\u6e54\u8e47\u8b07\u7f23\u67a7\u67d9\u6957\u620b\u622c\u726e\u728d\u6bfd\u8171\u7751\u950f\u9e63\u88e5\u7b15\u7bb4\u7fe6\u8dbc\u8e3a\u9ca3\u97af","jiang":"\u50f5\u59dc\u5c06\u6d46\u6c5f\u7586\u848b\u6868\u5956\u8bb2\u5320\u9171\u964d\u8333\u6d1a\u7edb\u7f30\u729f\u7913\u8029\u7ce8\u8c47","jiao":"\u8549\u6912\u7901\u7126\u80f6\u4ea4\u90ca\u6d47\u9a84\u5a07\u56bc\u6405\u94f0\u77eb\u4fa5\u811a\u72e1\u89d2\u997a\u7f34\u7ede\u527f\u6559\u9175\u8f7f\u8f83\u53eb\u4f7c\u50ec\u832d\u6322\u564d\u5ce4\u5fbc\u59e3\u7e9f\u656b\u768e\u9e6a\u86df\u91ae\u8de4\u9c9b","jie":"\u7a96\u63ed\u63a5\u7686\u79f8\u8857\u9636\u622a\u52ab\u8282\u6854\u6770\u6377\u776b\u7aed\u6d01\u7ed3\u89e3\u59d0\u6212\u85c9\u82a5\u754c\u501f\u4ecb\u75a5\u8beb\u5c4a\u5048\u8ba6\u8bd8\u5588\u55df\u736c\u5a55\u5b51\u6840\u7352\u78a3\u9534\u7596\u88b7\u9889\u86a7\u7faf\u9c92\u9ab1\u9aeb","jin":"\u5dfe\u7b4b\u65a4\u91d1\u4eca\u6d25\u895f\u7d27\u9526\u4ec5\u8c28\u8fdb\u9773\u664b\u7981\u8fd1\u70ec\u6d78\u5c3d\u537a\u8369\u5807\u5664\u9991\u5ed1\u5997\u7f19\u747e\u69ff\u8d46\u89d0\u9485\u9513\u887f\u77dc","jing":"\u52b2\u8346\u5162\u830e\u775b\u6676\u9cb8\u4eac\u60ca\u7cbe\u7cb3\u7ecf\u4e95\u8b66\u666f\u9888\u9759\u5883\u656c\u955c\u5f84\u75c9\u9756\u7adf\u7ade\u51c0\u522d\u5106\u9631\u83c1\u734d\u61ac\u6cfe\u8ff3\u5f2a\u5a67\u80bc\u80eb\u8148\u65cc","jiong":"\u70af\u7a98\u5182\u8fe5\u6243","jiu":"\u63ea\u7a76\u7ea0\u7396\u97ed\u4e45\u7078\u4e5d\u9152\u53a9\u6551\u65e7\u81fc\u8205\u548e\u5c31\u759a\u50e6\u557e\u9604\u67e9\u6855\u9e6b\u8d73\u9b0f","ju":"\u97a0\u62d8\u72d9\u75bd\u9a79\u83ca\u5c40\u5480\u77e9\u4e3e\u6cae\u805a\u62d2\u636e\u5de8\u5177\u8ddd\u8e1e\u952f\u4ff1\u53e5\u60e7\u70ac\u5267\u5028\u8bb5\u82e3\u82f4\u8392\u63ac\u907d\u5c66\u741a\u67b8\u6910\u6998\u6989\u6a58\u728b\u98d3\u949c\u9514\u7aad\u88fe\u8d84\u91b5\u8e3d\u9f83\u96ce\u97ab","juan":"\u6350\u9e43\u5a1f\u5026\u7737\u5377\u7ee2\u9104\u72f7\u6d93\u684a\u8832\u9529\u954c\u96bd","jue":"\u6485\u652b\u6289\u6398\u5014\u7235\u89c9\u51b3\u8bc0\u7edd\u53a5\u5282\u8c32\u77cd\u8568\u5658\u5d1b\u7357\u5b53\u73cf\u6877\u6a5b\u721d\u9562\u8e76\u89d6","jun":"\u5747\u83cc\u94a7\u519b\u541b\u5cfb\u4fca\u7ae3\u6d5a\u90e1\u9a8f\u6343\u72fb\u76b2\u7b60\u9e87","ka":"\u5580\u5496\u5361\u4f67\u5494\u80e9","ke":"\u54af\u5777\u82db\u67ef\u68f5\u78d5\u9897\u79d1\u58f3\u54b3\u53ef\u6e34\u514b\u523b\u5ba2\u8bfe\u5ca2\u606a\u6e98\u9a92\u7f02\u73c2\u8f72\u6c2a\u778c\u94b6\u75b4\u7aa0\u874c\u9ac1","kai":"\u5f00\u63e9\u6977\u51ef\u6168\u5240\u57b2\u8488\u5ffe\u607a\u94e0\u950e","kan":"\u520a\u582a\u52d8\u574e\u780d\u770b\u4f83\u51f5\u83b0\u83b6\u6221\u9f9b\u77b0","kang":"\u5eb7\u6177\u7ce0\u625b\u6297\u4ea2\u7095\u5751\u4f09\u95f6\u94aa","kao":"\u8003\u62f7\u70e4\u9760\u5c3b\u6832\u7292\u94d0","ken":"\u80af\u5543\u57a6\u6073\u57a0\u88c9\u9880","keng":"\u542d\u5fd0\u94ff","kong":"\u7a7a\u6050\u5b54\u63a7\u5025\u5d06\u7b9c","kou":"\u62a0\u53e3\u6263\u5bc7\u82a4\u853b\u53e9\u770d\u7b58","ku":"\u67af\u54ed\u7a9f\u82e6\u9177\u5e93\u88e4\u5233\u5800\u55be\u7ed4\u9ab7","kua":"\u5938\u57ae\u630e\u8de8\u80ef\u4f89","kuai":"\u5757\u7b77\u4fa9\u5feb\u84af\u90d0\u8489\u72ef\u810d","kuan":"\u5bbd\u6b3e\u9acb","kuang":"\u5321\u7b50\u72c2\u6846\u77ff\u7736\u65f7\u51b5\u8bd3\u8bf3\u909d\u5739\u593c\u54d0\u7ea9\u8d36","kui":"\u4e8f\u76d4\u5cbf\u7aa5\u8475\u594e\u9b41\u5080\u9988\u6127\u6e83\u9997\u532e\u5914\u9697\u63c6\u55b9\u559f\u609d\u6126\u9615\u9035\u668c\u777d\u8069\u8770\u7bd1\u81fe\u8dec","kun":"\u5764\u6606\u6346\u56f0\u6083\u9603\u7428\u951f\u918c\u9cb2\u9ae1","kuo":"\u62ec\u6269\u5ed3\u9614\u86de","la":"\u5783\u62c9\u5587\u8721\u814a\u8fa3\u5566\u524c\u647a\u908b\u65ef\u782c\u760c","lai":"\u83b1\u6765\u8d56\u5d03\u5f95\u6d9e\u6fd1\u8d49\u7750\u94fc\u765e\u7c41","lan":"\u84dd\u5a6a\u680f\u62e6\u7bee\u9611\u5170\u6f9c\u8c30\u63fd\u89c8\u61d2\u7f06\u70c2\u6ee5\u5549\u5c9a\u61d4\u6f24\u6984\u6593\u7f71\u9567\u8934","lang":"\u7405\u6994\u72fc\u5eca\u90ce\u6717\u6d6a\u83a8\u8497\u5577\u9606\u9512\u7a02\u8782","lao":"\u635e\u52b3\u7262\u8001\u4f6c\u59e5\u916a\u70d9\u6d9d\u5520\u5d02\u6833\u94d1\u94f9\u75e8\u91aa","le":"\u52d2\u4e50\u808b\u4ec2\u53fb\u561e\u6cd0\u9cd3","lei":"\u96f7\u956d\u857e\u78ca\u7d2f\u5121\u5792\u64c2\u7c7b\u6cea\u7fb8\u8bd4\u837d\u54a7\u6f2f\u5ad8\u7f27\u6a91\u8012\u9179","ling":"\u68f1\u51b7\u62ce\u73b2\u83f1\u96f6\u9f84\u94c3\u4f36\u7f9a\u51cc\u7075\u9675\u5cad\u9886\u53e6\u4ee4\u9143\u5844\u82d3\u5464\u56f9\u6ce0\u7eeb\u67c3\u68c2\u74f4\u8046\u86c9\u7fce\u9cae","leng":"\u695e\u6123","li":"\u5398\u68a8\u7281\u9ece\u7bf1\u72f8\u79bb\u6f13\u7406\u674e\u91cc\u9ca4\u793c\u8389\u8354\u540f\u6817\u4e3d\u5389\u52b1\u783e\u5386\u5229\u5088\u4f8b\u4fd0\u75e2\u7acb\u7c92\u6ca5\u96b6\u529b\u7483\u54e9\u4fea\u4fda\u90e6\u575c\u82c8\u8385\u84e0\u85dc\u6369\u5456\u5533\u55b1\u7301\u6ea7\u6fa7\u9026\u5a0c\u5ae0\u9a8a\u7f21\u73de\u67a5\u680e\u8f79\u623e\u783a\u8a48\u7f79\u9502\u9e42\u75a0\u75ac\u86ce\u870a\u8821\u7b20\u7be5\u7c9d\u91b4\u8dde\u96f3\u9ca1\u9ce2\u9ee7","lian":"\u4fe9\u8054\u83b2\u8fde\u9570\u5ec9\u601c\u6d9f\u5e18\u655b\u8138\u94fe\u604b\u70bc\u7ec3\u631b\u8539\u5941\u6f4b\u6fc2\u5a08\u740f\u695d\u6b93\u81c1\u81a6\u88e2\u880a\u9ca2","liang":"\u7cae\u51c9\u6881\u7cb1\u826f\u4e24\u8f86\u91cf\u667e\u4eae\u8c05\u589a\u690b\u8e09\u9753\u9b49","liao":"\u64a9\u804a\u50da\u7597\u71ce\u5be5\u8fbd\u6f66\u4e86\u6482\u9563\u5ed6\u6599\u84fc\u5c25\u5639\u7360\u5bee\u7f2d\u948c\u9e69\u8022","lie":"\u5217\u88c2\u70c8\u52a3\u730e\u51bd\u57d2\u6d0c\u8d94\u8e90\u9b23","lin":"\u7433\u6797\u78f7\u9716\u4e34\u90bb\u9cde\u6dcb\u51db\u8d41\u541d\u853a\u5d99\u5eea\u9074\u6aa9\u8f9a\u77b5\u7cbc\u8e8f\u9e9f","liu":"\u6e9c\u7409\u69b4\u786b\u998f\u7559\u5218\u7624\u6d41\u67f3\u516d\u62a1\u507b\u848c\u6cd6\u6d4f\u905b\u9a9d\u7efa\u65d2\u7198\u950d\u954f\u9e68\u938f","long":"\u9f99\u804b\u5499\u7b3c\u7abf\u9686\u5784\u62e2\u9647\u5f04\u5785\u830f\u6cf7\u73d1\u680a\u80e7\u783b\u7643","lou":"\u697c\u5a04\u6402\u7bd3\u6f0f\u964b\u55bd\u5d5d\u9542\u7618\u8027\u877c\u9ac5","lu":"\u82a6\u5362\u9885\u5e90\u7089\u63b3\u5364\u864f\u9c81\u9e93\u788c\u9732\u8def\u8d42\u9e7f\u6f5e\u7984\u5f55\u9646\u622e\u5786\u6445\u64b8\u565c\u6cf8\u6e0c\u6f09\u7490\u680c\u6a79\u8f73\u8f82\u8f98\u6c07\u80ea\u9565\u9e2c\u9e6d\u7c0f\u823b\u9c88","lv":"\u9a74\u5415\u94dd\u4fa3\u65c5\u5c65\u5c61\u7f15\u8651\u6c2f\u5f8b\u7387\u6ee4\u7eff\u634b\u95fe\u6988\u8182\u7a06\u891b","luan":"\u5ce6\u5b6a\u6ee6\u5375\u4e71\u683e\u9e3e\u92ae","lue":"\u63a0\u7565\u950a","lun":"\u8f6e\u4f26\u4ed1\u6ca6\u7eb6\u8bba\u56f5","luo":"\u841d\u87ba\u7f57\u903b\u9523\u7ba9\u9aa1\u88f8\u843d\u6d1b\u9a86\u7edc\u502e\u8366\u645e\u7321\u6cfa\u6924\u8136\u9559\u7630\u96d2","ma":"\u5988\u9ebb\u739b\u7801\u8682\u9a6c\u9a82\u561b\u5417\u551b\u72b8\u5b37\u6769\u9ebd","mai":"\u57cb\u4e70\u9ea6\u5356\u8fc8\u8109\u52a2\u836c\u54aa\u973e","man":"\u7792\u9992\u86ee\u6ee1\u8513\u66fc\u6162\u6f2b\u8c29\u5881\u5e54\u7f26\u71b3\u9558\u989f\u87a8\u9cd7\u9794","mang":"\u8292\u832b\u76f2\u5fd9\u83bd\u9099\u6f2d\u6726\u786d\u87d2","meng":"\u6c13\u840c\u8499\u6aac\u76df\u9530\u731b\u68a6\u5b5f\u52d0\u750d\u77a2\u61f5\u791e\u867b\u8722\u8813\u824b\u8268\u9efe","miao":"\u732b\u82d7\u63cf\u7784\u85d0\u79d2\u6e3a\u5e99\u5999\u55b5\u9088\u7f08\u7f2a\u676a\u6dfc\u7707\u9e4b\u8731","mao":"\u8305\u951a\u6bdb\u77db\u94c6\u536f\u8302\u5192\u5e3d\u8c8c\u8d38\u4f94\u88a4\u52d6\u8306\u5cc1\u7441\u6634\u7266\u8004\u65c4\u61cb\u7780\u86d1\u8765\u87ca\u9ae6","me":"\u4e48","mei":"\u73ab\u679a\u6885\u9176\u9709\u7164\u6ca1\u7709\u5a92\u9541\u6bcf\u7f8e\u6627\u5bd0\u59b9\u5a9a\u5776\u8393\u5d4b\u7338\u6d7c\u6e44\u6963\u9545\u9e5b\u8882\u9b45","men":"\u95e8\u95f7\u4eec\u626a\u739f\u7116\u61d1\u9494","mi":"\u772f\u919a\u9761\u7cdc\u8ff7\u8c1c\u5f25\u7c73\u79d8\u89c5\u6ccc\u871c\u5bc6\u5e42\u8288\u5196\u8c27\u863c\u5627\u7315\u736f\u6c68\u5b93\u5f2d\u8112\u6549\u7cf8\u7e3b\u9e8b","mian":"\u68c9\u7720\u7ef5\u5195\u514d\u52c9\u5a29\u7f05\u9762\u6c94\u6e4e\u817c\u7704","mie":"\u8511\u706d\u54a9\u881b\u7bfe","min":"\u6c11\u62bf\u76bf\u654f\u60af\u95fd\u82e0\u5cb7\u95f5\u6cef\u73c9","ming":"\u660e\u879f\u9e23\u94ed\u540d\u547d\u51a5\u8317\u6e9f\u669d\u7791\u9169","miu":"\u8c2c","mo":"\u6478\u6479\u8611\u6a21\u819c\u78e8\u6469\u9b54\u62b9\u672b\u83ab\u58a8\u9ed8\u6cab\u6f20\u5bde\u964c\u8c1f\u8309\u84e6\u998d\u5aeb\u9546\u79e3\u763c\u8031\u87c6\u8c8a\u8c98","mou":"\u8c0b\u725f\u67d0\u53b6\u54de\u5a7a\u7738\u936a","mu":"\u62c7\u7261\u4ea9\u59c6\u6bcd\u5893\u66ae\u5e55\u52df\u6155\u6728\u76ee\u7766\u7267\u7a46\u4eeb\u82dc\u5452\u6c90\u6bea\u94bc","na":"\u62ff\u54ea\u5450\u94a0\u90a3\u5a1c\u7eb3\u5185\u637a\u80ad\u954e\u8872\u7bac","nai":"\u6c16\u4e43\u5976\u8010\u5948\u9f10\u827f\u8418\u67f0","nan":"\u5357\u7537\u96be\u56ca\u5583\u56e1\u6960\u8169\u877b\u8d67","nao":"\u6320\u8111\u607c\u95f9\u5b6c\u57b4\u7331\u7459\u7847\u94d9\u86f2","ne":"\u6dd6\u5462\u8bb7","nei":"\u9981","nen":"\u5ae9\u80fd\u6798\u6041","ni":"\u59ae\u9713\u502a\u6ce5\u5c3c\u62df\u4f60\u533f\u817b\u9006\u6eba\u4f32\u576d\u730a\u6029\u6ee0\u6635\u65ce\u7962\u615d\u7768\u94cc\u9cb5","nian":"\u852b\u62c8\u5e74\u78be\u64b5\u637b\u5ff5\u5eff\u8f87\u9ecf\u9c87\u9cb6","niang":"\u5a18\u917f","niao":"\u9e1f\u5c3f\u8311\u5b32\u8132\u8885","nie":"\u634f\u8042\u5b7d\u556e\u954a\u954d\u6d85\u4e5c\u9667\u8616\u55eb\u8080\u989e\u81ec\u8e51","nin":"\u60a8\u67e0","ning":"\u72de\u51dd\u5b81\u62e7\u6cde\u4f5e\u84e5\u549b\u752f\u804d","niu":"\u725b\u626d\u94ae\u7ebd\u72c3\u5ff8\u599e\u86b4","nong":"\u8113\u6d53\u519c\u4fac","nu":"\u5974\u52aa\u6012\u5476\u5e11\u5f29\u80ec\u5b65\u9a7d","nv":"\u5973\u6067\u9495\u8844","nuan":"\u6696","nuenue":"\u8650","nue":"\u759f\u8c11","nuo":"\u632a\u61e6\u7cef\u8bfa\u50a9\u6426\u558f\u9518","ou":"\u54e6\u6b27\u9e25\u6bb4\u85d5\u5455\u5076\u6ca4\u6004\u74ef\u8026","pa":"\u556a\u8db4\u722c\u5e15\u6015\u7436\u8469\u7b62","pai":"\u62cd\u6392\u724c\u5f98\u6e43\u6d3e\u4ff3\u848e","pan":"\u6500\u6f58\u76d8\u78d0\u76fc\u7554\u5224\u53db\u723f\u6cee\u88a2\u897b\u87e0\u8e52","pang":"\u4e53\u5e9e\u65c1\u802a\u80d6\u6ec2\u9004","pao":"\u629b\u5486\u5228\u70ae\u888d\u8dd1\u6ce1\u530f\u72cd\u5e96\u812c\u75b1","pei":"\u5478\u80da\u57f9\u88f4\u8d54\u966a\u914d\u4f69\u6c9b\u638a\u8f94\u5e14\u6de0\u65c6\u952b\u9185\u9708","pen":"\u55b7\u76c6\u6e53","peng":"\u7830\u62a8\u70f9\u6f8e\u5f6d\u84ec\u68da\u787c\u7bf7\u81a8\u670b\u9e4f\u6367\u78b0\u576f\u580b\u562d\u6026\u87db","pi":"\u7812\u9739\u6279\u62ab\u5288\u7435\u6bd7\u5564\u813e\u75b2\u76ae\u5339\u75de\u50fb\u5c41\u8b6c\u4e15\u9674\u90b3\u90eb\u572e\u9f19\u64d7\u567c\u5e80\u5ab2\u7eb0\u6787\u7513\u7765\u7f74\u94cd\u75e6\u7656\u758b\u868d\u8c94","pian":"\u7bc7\u504f\u7247\u9a97\u8c1d\u9a88\u728f\u80fc\u890a\u7fe9\u8e41","piao":"\u98d8\u6f02\u74e2\u7968\u527d\u560c\u5ad6\u7f25\u6b8d\u779f\u87b5","pie":"\u6487\u77a5\u4e3f\u82e4\u6c15","pin":"\u62fc\u9891\u8d2b\u54c1\u8058\u62da\u59d8\u5ad4\u6980\u725d\u98a6","ping":"\u4e52\u576a\u82f9\u840d\u5e73\u51ed\u74f6\u8bc4\u5c4f\u4fdc\u5a09\u67b0\u9c86","po":"\u5761\u6cfc\u9887\u5a46\u7834\u9b44\u8feb\u7c95\u53f5\u9131\u6ea5\u73c0\u948b\u94b7\u76a4\u7b38","pou":"\u5256\u88d2\u8e23","pu":"\u6251\u94fa\u4ec6\u8386\u8461\u83e9\u84b2\u57d4\u6734\u5703\u666e\u6d66\u8c31\u66dd\u7011\u530d\u5657\u6fee\u749e\u6c06\u9564\u9568\u8e7c","qi":"\u671f\u6b3a\u6816\u621a\u59bb\u4e03\u51c4\u6f06\u67d2\u6c8f\u5176\u68cb\u5947\u6b67\u7566\u5d0e\u8110\u9f50\u65d7\u7948\u7941\u9a91\u8d77\u5c82\u4e5e\u4f01\u542f\u5951\u780c\u5668\u6c14\u8fc4\u5f03\u6c7d\u6ce3\u8bab\u4e9f\u4e93\u573b\u8291\u840b\u847a\u5601\u5c7a\u5c90\u6c54\u6dc7\u9a90\u7eee\u742a\u7426\u675e\u6864\u69ed\u6b39\u797a\u61a9\u789b\u86f4\u871e\u7da6\u7dae\u8dbf\u8e4a\u9ccd\u9e92","qia":"\u6390\u6070\u6d3d\u845c","qian":"\u7275\u6266\u948e\u94c5\u5343\u8fc1\u7b7e\u4edf\u8c26\u4e7e\u9ed4\u94b1\u94b3\u524d\u6f5c\u9063\u6d45\u8c34\u5811\u5d4c\u6b20\u6b49\u4f65\u9621\u828a\u82a1\u8368\u63ae\u5c8d\u60ad\u614a\u9a9e\u6434\u8930\u7f31\u6920\u80b7\u6106\u94a4\u8654\u7b9d","qiang":"\u67aa\u545b\u8154\u7f8c\u5899\u8537\u5f3a\u62a2\u5af1\u6a2f\u6217\u709d\u9516\u9535\u956a\u8941\u8723\u7f9f\u8deb\u8dc4","qiao":"\u6a47\u9539\u6572\u6084\u6865\u77a7\u4e54\u4fa8\u5de7\u9798\u64ac\u7fd8\u5ced\u4fcf\u7a8d\u5281\u8bee\u8c2f\u835e\u6100\u6194\u7f32\u6a35\u6bf3\u7857\u8df7\u9792","qie":"\u5207\u8304\u4e14\u602f\u7a83\u90c4\u553c\u60ec\u59be\u6308\u9532\u7ba7","qin":"\u94a6\u4fb5\u4eb2\u79e6\u7434\u52e4\u82b9\u64d2\u79bd\u5bdd\u6c81\u82a9\u84c1\u8572\u63ff\u5423\u55ea\u5659\u6eb1\u6a8e\u8793\u887e","qing":"\u9752\u8f7b\u6c22\u503e\u537f\u6e05\u64ce\u6674\u6c30\u60c5\u9877\u8bf7\u5e86\u5029\u82d8\u570a\u6aa0\u78ec\u873b\u7f44\u7b90\u8b26\u9cad\u9ee5","qiong":"\u743c\u7a77\u909b\u8315\u7a79\u7b47\u928e","qiu":"\u79cb\u4e18\u90b1\u7403\u6c42\u56da\u914b\u6cc5\u4fc5\u6c3d\u5def\u827d\u72b0\u6e6b\u9011\u9052\u6978\u8d47\u9e20\u866c\u86af\u8764\u88d8\u7cd7\u9cc5\u9f3d","qu":"\u8d8b\u533a\u86c6\u66f2\u8eaf\u5c48\u9a71\u6e20\u53d6\u5a36\u9f8b\u8da3\u53bb\u8bce\u52ac\u8556\u8627\u5c96\u8862\u9612\u74a9\u89d1\u6c0d\u795b\u78f2\u766f\u86d0\u883c\u9eb4\u77bf\u9ee2","quan":"\u5708\u98a7\u6743\u919b\u6cc9\u5168\u75ca\u62f3\u72ac\u5238\u529d\u8be0\u8343\u737e\u609b\u7efb\u8f81\u754e\u94e8\u8737\u7b4c\u9b08","que":"\u7f3a\u7094\u7638\u5374\u9e4a\u69b7\u786e\u96c0\u9619\u60ab","qun":"\u88d9\u7fa4\u9021","ran":"\u7136\u71c3\u5189\u67d3\u82d2\u9aef","rang":"\u74e4\u58e4\u6518\u56b7\u8ba9\u79b3\u7a70","rao":"\u9976\u6270\u7ed5\u835b\u5a06\u6861","ruo":"\u60f9\u82e5\u5f31","re":"\u70ed\u504c","ren":"\u58ec\u4ec1\u4eba\u5fcd\u97e7\u4efb\u8ba4\u5203\u598a\u7eab\u4ede\u834f\u845a\u996a\u8f6b\u7a14\u887d","reng":"\u6254\u4ecd","ri":"\u65e5","rong":"\u620e\u8338\u84c9\u8363\u878d\u7194\u6eb6\u5bb9\u7ed2\u5197\u5d58\u72e8\u7f1b\u6995\u877e","rou":"\u63c9\u67d4\u8089\u7cc5\u8e42\u97a3","ru":"\u8339\u8815\u5112\u5b7a\u5982\u8fb1\u4e73\u6c5d\u5165\u8925\u84d0\u85b7\u5685\u6d33\u6ebd\u6fe1\u94f7\u8966\u98a5","ruan":"\u8f6f\u962e\u670a","rui":"\u854a\u745e\u9510\u82ae\u8564\u777f\u868b","run":"\u95f0\u6da6","sa":"\u6492\u6d12\u8428\u5345\u4ee8\u6332\u98d2","sai":"\u816e\u9cc3\u585e\u8d5b\u567b","san":"\u4e09\u53c1\u4f1e\u6563\u5f61\u9993\u6c35\u6bf5\u7cc1\u9730","sang":"\u6851\u55d3\u4e27\u6421\u78c9\u98a1","sao":"\u6414\u9a9a\u626b\u5ac2\u57fd\u81ca\u7619\u9ccb","se":"\u745f\u8272\u6da9\u556c\u94e9\u94ef\u7a51","sen":"\u68ee","seng":"\u50e7","sha":"\u838e\u7802\u6740\u5239\u6c99\u7eb1\u50bb\u5565\u715e\u810e\u6b43\u75e7\u88df\u970e\u9ca8","shai":"\u7b5b\u6652\u917e","shan":"\u73ca\u82eb\u6749\u5c71\u5220\u717d\u886b\u95ea\u9655\u64c5\u8d61\u81b3\u5584\u6c55\u6247\u7f2e\u5261\u8baa\u912f\u57cf\u829f\u6f78\u59d7\u9a9f\u81bb\u9490\u759d\u87ee\u8222\u8dda\u9cdd","shang":"\u5892\u4f24\u5546\u8d4f\u664c\u4e0a\u5c1a\u88f3\u57a7\u7ef1\u6b87\u71b5\u89de","shao":"\u68a2\u634e\u7a0d\u70e7\u828d\u52fa\u97f6\u5c11\u54e8\u90b5\u7ecd\u52ad\u82d5\u6f72\u86f8\u7b24\u7b72\u8244","she":"\u5962\u8d4a\u86c7\u820c\u820d\u8d66\u6444\u5c04\u6151\u6d89\u793e\u8bbe\u538d\u4f58\u731e\u7572\u9e9d","shen":"\u7837\u7533\u547b\u4f38\u8eab\u6df1\u5a20\u7ec5\u795e\u6c88\u5ba1\u5a76\u751a\u80be\u614e\u6e17\u8bdc\u8c02\u5432\u54c2\u6e16\u6939\u77e7\u8703","sheng":"\u58f0\u751f\u7525\u7272\u5347\u7ef3\u7701\u76db\u5269\u80dc\u5723\u4e1e\u6e11\u5ab5\u771a\u7b19","shi":"\u5e08\u5931\u72ee\u65bd\u6e7f\u8bd7\u5c38\u8671\u5341\u77f3\u62fe\u65f6\u4ec0\u98df\u8680\u5b9e\u8bc6\u53f2\u77e2\u4f7f\u5c4e\u9a76\u59cb\u5f0f\u793a\u58eb\u4e16\u67ff\u4e8b\u62ed\u8a93\u901d\u52bf\u662f\u55dc\u566c\u9002\u4ed5\u4f8d\u91ca\u9970\u6c0f\u5e02\u6043\u5ba4\u89c6\u8bd5\u8c25\u57d8\u83b3\u84cd\u5f11\u5511\u9963\u8f7c\u8006\u8d33\u70bb\u793b\u94c8\u94ca\u87ab\u8210\u7b6e\u8c55\u9ca5\u9cba","shou":"\u6536\u624b\u9996\u5b88\u5bff\u6388\u552e\u53d7\u7626\u517d\u624c\u72e9\u7ef6\u824f","shu":"\u852c\u67a2\u68b3\u6b8a\u6292\u8f93\u53d4\u8212\u6dd1\u758f\u4e66\u8d4e\u5b70\u719f\u85af\u6691\u66d9\u7f72\u8700\u9ecd\u9f20\u5c5e\u672f\u8ff0\u6811\u675f\u620d\u7ad6\u5885\u5eb6\u6570\u6f31\u6055\u500f\u587e\u83fd\u5fc4\u6cad\u6d91\u6f8d\u59dd\u7ebe\u6bf9\u8167\u6bb3\u956f\u79eb\u9e6c","shua":"\u5237\u800d\u5530\u6dae","shuai":"\u6454\u8870\u7529\u5e05\u87c0","shuan":"\u6813\u62f4\u95e9","shuang":"\u971c\u53cc\u723d\u5b40","shui":"\u8c01\u6c34\u7761\u7a0e","shun":"\u542e\u77ac\u987a\u821c\u6042","shuo":"\u8bf4\u7855\u6714\u70c1\u84b4\u6420\u55cd\u6fef\u5981\u69ca\u94c4","si":"\u65af\u6495\u5636\u601d\u79c1\u53f8\u4e1d\u6b7b\u8086\u5bfa\u55e3\u56db\u4f3a\u4f3c\u9972\u5df3\u53ae\u4fdf\u5155\u83e5\u549d\u6c5c\u6cd7\u6f8c\u59d2\u9a77\u7f0c\u7940\u7960\u9536\u9e36\u801c\u86f3\u7b25","song":"\u677e\u8038\u6002\u9882\u9001\u5b8b\u8bbc\u8bf5\u51c7\u83d8\u5d27\u5d69\u5fea\u609a\u6dde\u7ae6","sou":"\u641c\u8258\u64de\u55fd\u53df\u55d6\u55fe\u998a\u6eb2\u98d5\u778d\u953c\u878b","su":"\u82cf\u9165\u4fd7\u7d20\u901f\u7c9f\u50f3\u5851\u6eaf\u5bbf\u8bc9\u8083\u5919\u8c21\u850c\u55c9\u612b\u7c0c\u89eb\u7a23","suan":"\u9178\u849c\u7b97","sui":"\u867d\u968b\u968f\u7ee5\u9ad3\u788e\u5c81\u7a57\u9042\u96a7\u795f\u84d1\u51ab\u8c07\u6fc9\u9083\u71e7\u772d\u7762","sun":"\u5b59\u635f\u7b0b\u836a\u72f2\u98e7\u69ab\u8de3\u96bc","suo":"\u68ad\u5506\u7f29\u7410\u7d22\u9501\u6240\u5522\u55e6\u5a11\u686b\u7743\u7fa7","ta":"\u584c\u4ed6\u5b83\u5979\u5854\u736d\u631e\u8e4b\u8e0f\u95fc\u6ebb\u9062\u69bb\u6c93","tai":"\u80ce\u82d4\u62ac\u53f0\u6cf0\u915e\u592a\u6001\u6c70\u90b0\u85b9\u80bd\u70b1\u949b\u8dc6\u9c90","tan":"\u574d\u644a\u8d2a\u762b\u6ee9\u575b\u6a80\u75f0\u6f6d\u8c2d\u8c08\u5766\u6bef\u8892\u78b3\u63a2\u53f9\u70ad\u90ef\u8548\u6619\u94bd\u952c\u8983","tang":"\u6c64\u5858\u642a\u5802\u68e0\u819b\u5510\u7cd6\u50a5\u9967\u6e8f\u746d\u94f4\u9557\u8025\u8797\u87b3\u7fb0\u91a3","thang":"\u5018\u8eba\u6dcc","theng":"\u8d9f\u70eb","tao":"\u638f\u6d9b\u6ed4\u7ee6\u8404\u6843\u9003\u6dd8\u9676\u8ba8\u5957\u6311\u9f17\u5555\u97ec\u9955","te":"\u7279","teng":"\u85e4\u817e\u75bc\u8a8a\u6ed5","ti":"\u68af\u5254\u8e22\u9511\u63d0\u9898\u8e44\u557c\u4f53\u66ff\u568f\u60d5\u6d95\u5243\u5c49\u8351\u608c\u9016\u7ee8\u7f07\u9e48\u88fc\u918d","tian":"\u5929\u6dfb\u586b\u7530\u751c\u606c\u8214\u8146\u63ad\u5fdd\u9617\u6b84\u754b\u94bf\u86ba","tiao":"\u6761\u8fe2\u773a\u8df3\u4f7b\u7967\u94eb\u7a95\u9f86\u9ca6","tie":"\u8d34\u94c1\u5e16\u841c\u992e","ting":"\u5385\u542c\u70c3\u6c40\u5ef7\u505c\u4ead\u5ead\u633a\u8247\u839b\u8476\u5a77\u6883\u8713\u9706","tong":"\u901a\u6850\u916e\u77b3\u540c\u94dc\u5f64\u7ae5\u6876\u6345\u7b52\u7edf\u75db\u4f5f\u50ee\u4edd\u833c\u55f5\u6078\u6f7c\u783c","tou":"\u5077\u6295\u5934\u900f\u4ea0","tu":"\u51f8\u79c3\u7a81\u56fe\u5f92\u9014\u6d82\u5c60\u571f\u5410\u5154\u580d\u837c\u83df\u948d\u9174","tuan":"\u6e4d\u56e2\u7583","tui":"\u63a8\u9893\u817f\u8715\u892a\u9000\u5fd2\u717a","tun":"\u541e\u5c6f\u81c0\u9968\u66be\u8c5a\u7a80","tuo":"\u62d6\u6258\u8131\u9e35\u9640\u9a6e\u9a7c\u692d\u59a5\u62d3\u553e\u4e47\u4f57\u5768\u5eb9\u6cb1\u67dd\u7823\u7ba8\u8204\u8dce\u9f0d","wa":"\u6316\u54c7\u86d9\u6d3c\u5a03\u74e6\u889c\u4f64\u5a32\u817d","wai":"\u6b6a\u5916","wan":"\u8c4c\u5f2f\u6e7e\u73a9\u987d\u4e38\u70f7\u5b8c\u7897\u633d\u665a\u7696\u60cb\u5b9b\u5a49\u4e07\u8155\u525c\u8284\u82cb\u83c0\u7ea8\u7efe\u742c\u8118\u7579\u873f\u7ba2","wang":"\u6c6a\u738b\u4ea1\u6789\u7f51\u5f80\u65fa\u671b\u5fd8\u5984\u7f54\u5c22\u60d8\u8f8b\u9b4d","wei":"\u5a01\u5dcd\u5fae\u5371\u97e6\u8fdd\u6845\u56f4\u552f\u60df\u4e3a\u6f4d\u7ef4\u82c7\u840e\u59d4\u4f1f\u4f2a\u5c3e\u7eac\u672a\u851a\u5473\u754f\u80c3\u5582\u9b4f\u4f4d\u6e2d\u8c13\u5c09\u6170\u536b\u502d\u504e\u8bff\u9688\u8473\u8587\u5e0f\u5e37\u5d34\u5d6c\u7325\u732c\u95f1\u6ca9\u6d27\u6da0\u9036\u5a13\u73ae\u97ea\u8ece\u709c\u7168\u71a8\u75ff\u8249\u9c94","wen":"\u761f\u6e29\u868a\u6587\u95fb\u7eb9\u543b\u7a33\u7d0a\u95ee\u520e\u6120\u960c\u6c76\u74ba\u97eb\u6b81\u96ef","weng":"\u55e1\u7fc1\u74ee\u84ca\u8579","wo":"\u631d\u8717\u6da1\u7a9d\u6211\u65a1\u5367\u63e1\u6c83\u83b4\u5e44\u6e25\u674c\u809f\u9f8c","wu":"\u5deb\u545c\u94a8\u4e4c\u6c61\u8bec\u5c4b\u65e0\u829c\u68a7\u543e\u5434\u6bcb\u6b66\u4e94\u6342\u5348\u821e\u4f0d\u4fae\u575e\u620a\u96fe\u6664\u7269\u52ff\u52a1\u609f\u8bef\u5140\u4ef5\u9622\u90ac\u572c\u82b4\u5e91\u6003\u5fe4\u6d6f\u5be4\u8fd5\u59a9\u9a9b\u727e\u7110\u9e49\u9e5c\u8708\u92c8\u9f2f","xi":"\u6614\u7199\u6790\u897f\u7852\u77fd\u6670\u563b\u5438\u9521\u727a\u7a00\u606f\u5e0c\u6089\u819d\u5915\u60dc\u7184\u70ef\u6eaa\u6c50\u7280\u6a84\u88ad\u5e2d\u4e60\u5ab3\u559c\u94e3\u6d17\u7cfb\u9699\u620f\u7ec6\u50d6\u516e\u96b0\u90d7\u831c\u8478\u84f0\u595a\u550f\u5f99\u9969\u960b\u6d60\u6dc5\u5c63\u5b09\u73ba\u6a28\u66e6\u89cb\u6b37\u71b9\u798a\u79a7\u94b8\u7699\u7a78\u8725\u87cb\u823e\u7fb2\u7c9e\u7fd5\u91af\u9f37","xia":"\u778e\u867e\u5323\u971e\u8f96\u6687\u5ce1\u4fa0\u72ed\u4e0b\u53a6\u590f\u5413\u6380\u846d\u55c4\u72ce\u9050\u7455\u7856\u7615\u7f45\u9ee0","xian":"\u9528\u5148\u4ed9\u9c9c\u7ea4\u54b8\u8d24\u8854\u8237\u95f2\u6d8e\u5f26\u5acc\u663e\u9669\u73b0\u732e\u53bf\u817a\u9985\u7fa1\u5baa\u9677\u9650\u7ebf\u51bc\u85d3\u5c98\u7303\u66b9\u5a34\u6c19\u7946\u9e47\u75eb\u86ac\u7b45\u7c7c\u9170\u8df9","xiang":"\u76f8\u53a2\u9576\u9999\u7bb1\u8944\u6e58\u4e61\u7fd4\u7965\u8be6\u60f3\u54cd\u4eab\u9879\u5df7\u6a61\u50cf\u5411\u8c61\u8297\u8459\u9977\u5ea0\u9aa7\u7f03\u87d3\u9c9e\u98e8","xiao":"\u8427\u785d\u9704\u524a\u54ee\u56a3\u9500\u6d88\u5bb5\u6dc6\u6653\u5c0f\u5b5d\u6821\u8096\u5578\u7b11\u6548\u54d3\u54bb\u5d24\u6f47\u900d\u9a81\u7ee1\u67ad\u67b5\u7b71\u7bab\u9b48","xie":"\u6954\u4e9b\u6b47\u874e\u978b\u534f\u631f\u643a\u90aa\u659c\u80c1\u8c10\u5199\u68b0\u5378\u87f9\u61c8\u6cc4\u6cfb\u8c22\u5c51\u5055\u4eb5\u52f0\u71ee\u85a4\u64b7\u5ee8\u7023\u9082\u7ec1\u7f2c\u69ad\u698d\u6b59\u8e9e","xin":"\u85aa\u82af\u950c\u6b23\u8f9b\u65b0\u5ffb\u5fc3\u4fe1\u8845\u56df\u99a8\u8398\u6b46\u94fd\u946b","xing":"\u661f\u8165\u7329\u60fa\u5174\u5211\u578b\u5f62\u90a2\u884c\u9192\u5e78\u674f\u6027\u59d3\u9649\u8347\u8365\u64e4\u60bb\u784e","xiong":"\u5144\u51f6\u80f8\u5308\u6c79\u96c4\u718a\u828e","xiu":"\u4f11\u4fee\u7f9e\u673d\u55c5\u9508\u79c0\u8896\u7ee3\u83a0\u5cab\u9990\u5ea5\u9e3a\u8c85\u9af9","xu":"\u589f\u620c\u9700\u865a\u5618\u987b\u5f90\u8bb8\u84c4\u9157\u53d9\u65ed\u5e8f\u755c\u6064\u7d6e\u5a7f\u7eea\u7eed\u8bb4\u8be9\u5729\u84ff\u6035\u6d2b\u6e86\u987c\u6829\u7166\u7809\u76f1\u80e5\u7cc8\u9191","xuan":"\u8f69\u55a7\u5ba3\u60ac\u65cb\u7384\u9009\u7663\u7729\u7eda\u5107\u8c16\u8431\u63ce\u9994\u6ceb\u6d35\u6e32\u6f29\u7487\u6966\u6684\u70ab\u714a\u78b9\u94c9\u955f\u75c3","xue":"\u9774\u859b\u5b66\u7a74\u96ea\u8840\u5671\u6cf6\u9cd5","xun":"\u52cb\u718f\u5faa\u65ec\u8be2\u5bfb\u9a6f\u5de1\u6b89\u6c5b\u8bad\u8baf\u900a\u8fc5\u5dfd\u57d9\u8340\u85b0\u5ccb\u5f87\u6d54\u66db\u7aa8\u91ba\u9c9f","ya":"\u538b\u62bc\u9e26\u9e2d\u5440\u4e2b\u82bd\u7259\u869c\u5d16\u8859\u6daf\u96c5\u54d1\u4e9a\u8bb6\u4f22\u63e0\u5416\u5c88\u8fd3\u5a05\u740a\u6860\u6c29\u7811\u775a\u75d6","yan":"\u7109\u54bd\u9609\u70df\u6df9\u76d0\u4e25\u7814\u8712\u5ca9\u5ef6\u8a00\u989c\u960e\u708e\u6cbf\u5944\u63a9\u773c\u884d\u6f14\u8273\u5830\u71d5\u538c\u781a\u96c1\u5501\u5f66\u7130\u5bb4\u8c1a\u9a8c\u53a3\u9765\u8d5d\u4fe8\u5043\u5156\u8ba0\u8c33\u90fe\u9122\u82ab\u83f8\u5d26\u6079\u95eb\u960f\u6d07\u6e6e\u6edf\u598d\u5ae3\u7430\u664f\u80ed\u814c\u7131\u7f68\u7b75\u917d\u9b47\u990d\u9f39","yang":"\u6b83\u592e\u9e2f\u79e7\u6768\u626c\u4f6f\u75a1\u7f8a\u6d0b\u9633\u6c27\u4ef0\u75d2\u517b\u6837\u6f3e\u5f89\u600f\u6cf1\u7080\u70ca\u6059\u86d8\u9785","yao":"\u9080\u8170\u5996\u7476\u6447\u5c27\u9065\u7a91\u8c23\u59da\u54ac\u8200\u836f\u8981\u8000\u592d\u723b\u5406\u5d3e\u5fad\u7039\u5e7a\u73e7\u6773\u66dc\u80b4\u9e5e\u7a88\u7e47\u9cd0","ye":"\u6930\u564e\u8036\u7237\u91ce\u51b6\u4e5f\u9875\u6396\u4e1a\u53f6\u66f3\u814b\u591c\u6db2\u8c12\u90ba\u63f6\u9980\u6654\u70e8\u94d8","yi":"\u4e00\u58f9\u533b\u63d6\u94f1\u4f9d\u4f0a\u8863\u9890\u5937\u9057\u79fb\u4eea\u80f0\u7591\u6c82\u5b9c\u59e8\u5f5d\u6905\u8681\u501a\u5df2\u4e59\u77e3\u4ee5\u827a\u6291\u6613\u9091\u5c79\u4ebf\u5f79\u81c6\u9038\u8084\u75ab\u4ea6\u88d4\u610f\u6bc5\u5fc6\u4e49\u76ca\u6ea2\u8be3\u8bae\u8c0a\u8bd1\u5f02\u7ffc\u7fcc\u7ece\u5208\u5293\u4f7e\u8bd2\u572a\u572f\u57f8\u61ff\u82e1\u858f\u5f08\u5955\u6339\u5f0b\u5453\u54a6\u54bf\u566b\u5cc4\u5db7\u7317\u9974\u603f\u6021\u6092\u6f2a\u8fe4\u9a7f\u7f22\u6baa\u8d3b\u65d6\u71a0\u9487\u9552\u9571\u75cd\u7617\u7654\u7fca\u8864\u8734\u8223\u7fbf\u7ff3\u914f\u9edf","yin":"\u8335\u836b\u56e0\u6bb7\u97f3\u9634\u59fb\u541f\u94f6\u6deb\u5bc5\u996e\u5c39\u5f15\u9690\u5370\u80e4\u911e\u5819\u831a\u5591\u72fa\u5924\u6c24\u94df\u763e\u8693\u972a\u9f88","ying":"\u82f1\u6a31\u5a74\u9e70\u5e94\u7f28\u83b9\u8424\u8425\u8367\u8747\u8fce\u8d62\u76c8\u5f71\u9896\u786c\u6620\u5b34\u90e2\u8314\u83ba\u8426\u6484\u5624\u81ba\u6ee2\u6f46\u701b\u745b\u748e\u6979\u9e66\u763f\u988d\u7f42","yo":"\u54df\u5537","yong":"\u62e5\u4f63\u81c3\u75c8\u5eb8\u96cd\u8e0a\u86f9\u548f\u6cf3\u6d8c\u6c38\u607f\u52c7\u7528\u4fd1\u58c5\u5889\u6175\u9095\u955b\u752c\u9cd9\u9954","you":"\u5e7d\u4f18\u60a0\u5fe7\u5c24\u7531\u90ae\u94c0\u72b9\u6cb9\u6e38\u9149\u6709\u53cb\u53f3\u4f51\u91c9\u8bf1\u53c8\u5e7c\u5363\u6538\u4f91\u83b8\u5466\u56ff\u5ba5\u67da\u7337\u7256\u94d5\u75a3\u8763\u9c7f\u9edd\u9f2c","yu":"\u8fc2\u6de4\u4e8e\u76c2\u6986\u865e\u611a\u8206\u4f59\u4fde\u903e\u9c7c\u6109\u6e1d\u6e14\u9685\u4e88\u5a31\u96e8\u4e0e\u5c7f\u79b9\u5b87\u8bed\u7fbd\u7389\u57df\u828b\u90c1\u5401\u9047\u55bb\u5cea\u5fa1\u6108\u6b32\u72f1\u80b2\u8a89\u6d74\u5bd3\u88d5\u9884\u8c6b\u9a6d\u79ba\u6bd3\u4f1b\u4fe3\u8c00\u8c15\u8438\u84e3\u63c4\u5581\u5704\u5709\u5d5b\u72f3\u996b\u5ebe\u9608\u59aa\u59a4\u7ea1\u745c\u6631\u89ce\u8174\u6b24\u65bc\u715c\u71e0\u807f\u94b0\u9e46\u7610\u7600\u7ab3\u8753\u7afd\u8201\u96e9\u9f89","yuan":"\u9e33\u6e0a\u51a4\u5143\u57a3\u8881\u539f\u63f4\u8f95\u56ed\u5458\u5706\u733f\u6e90\u7f18\u8fdc\u82d1\u613f\u6028\u9662\u586c\u6c85\u5a9b\u7457\u6a7c\u7230\u7722\u9e22\u8788\u9f0b","yue":"\u66f0\u7ea6\u8d8a\u8dc3\u94a5\u5cb3\u7ca4\u6708\u60a6\u9605\u9fa0\u6a3e\u5216\u94ba","yun":"\u8018\u4e91\u90e7\u5300\u9668\u5141\u8fd0\u8574\u915d\u6655\u97f5\u5b55\u90d3\u82b8\u72c1\u607d\u7ead\u6b92\u6600\u6c32","za":"\u531d\u7838\u6742\u62f6\u5482","zai":"\u683d\u54c9\u707e\u5bb0\u8f7d\u518d\u5728\u54b1\u5d3d\u753e","zan":"\u6512\u6682\u8d5e\u74d2\u661d\u7c2a\u7ccc\u8db1\u933e","zang":"\u8d43\u810f\u846c\u5958\u6215\u81e7","zao":"\u906d\u7cdf\u51ff\u85fb\u67a3\u65e9\u6fa1\u86a4\u8e81\u566a\u9020\u7682\u7076\u71e5\u5523\u7f2b","ze":"\u8d23\u62e9\u5219\u6cfd\u4ec4\u8d5c\u5567\u8fee\u6603\u7b2e\u7ba6\u8234","zei":"\u8d3c","zen":"\u600e\u8c2e","zeng":"\u589e\u618e\u66fe\u8d60\u7f2f\u7511\u7f7e\u9503","zha":"\u624e\u55b3\u6e23\u672d\u8f67\u94e1\u95f8\u7728\u6805\u69a8\u548b\u4e4d\u70b8\u8bc8\u63f8\u5412\u54a4\u54f3\u600d\u781f\u75c4\u86b1\u9f44","zhai":"\u6458\u658b\u5b85\u7a84\u503a\u5be8\u7826","zhan":"\u77bb\u6be1\u8a79\u7c98\u6cbe\u76cf\u65a9\u8f97\u5d2d\u5c55\u8638\u6808\u5360\u6218\u7ad9\u6e5b\u7efd\u8c35\u640c\u65c3","zhang":"\u6a1f\u7ae0\u5f70\u6f33\u5f20\u638c\u6da8\u6756\u4e08\u5e10\u8d26\u4ed7\u80c0\u7634\u969c\u4ec9\u9123\u5e5b\u5d82\u7350\u5adc\u748b\u87d1","zhao":"\u62db\u662d\u627e\u6cbc\u8d75\u7167\u7f69\u5146\u8087\u53ec\u722a\u8bcf\u68f9\u948a\u7b0a","zhe":"\u906e\u6298\u54f2\u86f0\u8f99\u8005\u9517\u8517\u8fd9\u6d59\u8c2a\u966c\u67d8\u8f84\u78d4\u9e67\u891a\u8707\u8d6d","zhen":"\u73cd\u659f\u771f\u7504\u7827\u81fb\u8d1e\u9488\u4fa6\u6795\u75b9\u8bca\u9707\u632f\u9547\u9635\u7f1c\u6862\u699b\u8f78\u8d48\u80d7\u6715\u796f\u755b\u9e29","zheng":"\u84b8\u6323\u7741\u5f81\u72f0\u4e89\u6014\u6574\u62ef\u6b63\u653f\u5e27\u75c7\u90d1\u8bc1\u8be4\u5ce5\u94b2\u94ee\u7b5d","zhi":"\u829d\u679d\u652f\u5431\u8718\u77e5\u80a2\u8102\u6c41\u4e4b\u7ec7\u804c\u76f4\u690d\u6b96\u6267\u503c\u4f84\u5740\u6307\u6b62\u8dbe\u53ea\u65e8\u7eb8\u5fd7\u631a\u63b7\u81f3\u81f4\u7f6e\u5e1c\u5cd9\u5236\u667a\u79e9\u7a1a\u8d28\u7099\u75d4\u6ede\u6cbb\u7a92\u536e\u965f\u90c5\u57f4\u82b7\u646d\u5e19\u5fee\u5f58\u54ab\u9a98\u6809\u67b3\u6800\u684e\u8f75\u8f7e\u6534\u8d3d\u81a3\u7949\u7957\u9ef9\u96c9\u9e37\u75e3\u86ed\u7d77\u916f\u8dd6\u8e2c\u8e2f\u8c78\u89ef","zhong":"\u4e2d\u76c5\u5fe0\u949f\u8877\u7ec8\u79cd\u80bf\u91cd\u4ef2\u4f17\u51a2\u953a\u87bd\u8202\u822f\u8e35","zhou":"\u821f\u5468\u5dde\u6d32\u8bcc\u7ca5\u8f74\u8098\u5e1a\u5492\u76b1\u5b99\u663c\u9aa4\u5544\u7740\u501c\u8bf9\u836e\u9b3b\u7ea3\u80c4\u78a1\u7c40\u8233\u914e\u9cb7","zhu":"\u73e0\u682a\u86db\u6731\u732a\u8bf8\u8bdb\u9010\u7af9\u70db\u716e\u62c4\u77a9\u5631\u4e3b\u8457\u67f1\u52a9\u86c0\u8d2e\u94f8\u7b51\u4f4f\u6ce8\u795d\u9a7b\u4f2b\u4f8f\u90be\u82ce\u8331\u6d19\u6e1a\u6f74\u9a7a\u677c\u69e0\u6a65\u70b7\u94e2\u75b0\u7603\u86b0\u7afa\u7bb8\u7fe5\u8e85\u9e88","zhua":"\u6293","zhuai":"\u62fd","zhuan":"\u4e13\u7816\u8f6c\u64b0\u8d5a\u7bc6\u629f\u556d\u989b","zhuang":"\u6869\u5e84\u88c5\u5986\u649e\u58ee\u72b6\u4e2c","zhui":"\u690e\u9525\u8ffd\u8d58\u5760\u7f00\u8411\u9a93\u7f12","zhun":"\u8c06\u51c6","zhuo":"\u6349\u62d9\u5353\u684c\u7422\u8301\u914c\u707c\u6d4a\u502c\u8bfc\u5ef4\u855e\u64e2\u555c\u6d5e\u6dbf\u6753\u712f\u799a\u65ab","zi":"\u5179\u54a8\u8d44\u59ff\u6ecb\u6dc4\u5b5c\u7d2b\u4ed4\u7c7d\u6ed3\u5b50\u81ea\u6e0d\u5b57\u8c18\u5d6b\u59ca\u5b73\u7f01\u6893\u8f8e\u8d40\u6063\u7726\u9531\u79ed\u8014\u7b2b\u7ca2\u89dc\u8a3e\u9cbb\u9aed","zong":"\u9b03\u68d5\u8e2a\u5b97\u7efc\u603b\u7eb5\u8159\u7cbd","zou":"\u90b9\u8d70\u594f\u63cd\u9139\u9cb0","zu":"\u79df\u8db3\u5352\u65cf\u7956\u8bc5\u963b\u7ec4\u4fce\u83f9\u5550\u5f82\u9a75\u8e74","zuan":"\u94bb\u7e82\u6525\u7f35","zui":"\u5634\u9189\u6700\u7f6a","zun":"\u5c0a\u9075\u6499\u6a3d\u9cdf","zuo":"\u6628\u5de6\u4f50\u67de\u505a\u4f5c\u5750\u5ea7\u961d\u963c\u80d9\u795a\u9162","cou":"\u85ae\u6971\u8f8f\u8160","nang":"\u652e\u54dd\u56d4\u9995\u66e9","o":"\u5594","dia":"\u55f2","chuai":"\u562c\u81aa\u8e39","cen":"\u5c91\u6d94","diu":"\u94e5","nou":"\u8028","fou":"\u7f36","bia":"\u9adf"}; Pinyin._ucfirst=function(l1){ if (l1.length&gt;0) { var first = l1.substr(0,1).toUpperCase(); var spare = l1.substr(1,l1.length); return first + spare; } } Pinyin._arraySearch=function(l1,l2){ for (var name in this._pinyin){ if (this._pinyin[name].indexOf(l1)!=-1) { return this._ucfirst(name); break; } } return false; } Pinyin.get=function(l1){ var l2 = l1.length; var I1 = ""; var reg = new RegExp('[a-zA-Z0-9\- ]'); for (var i=0;i&lt;l2;i++) { var val = l1.substr(i,1); var name = this._arraySearch(val,this._pinyin); if(reg.test(val)) { I1 += val; } else if (name!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183b11e5c9d5b3dff2414e876f786d5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c314086069b806c3023d4b7c57a6cf5e/" rel="bookmark">
			【转】推荐五款支持外链的免费网盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐五款支持外链的免费网盘 为什么是国外网盘呢，因为相对于国内网盘的服务、稳定和信誉来说，国外网盘实在是好太多太多了。
为什么要推荐呢，因为他们支持外联地址，所以你的歌，你的图片等等都可以放上来，然后直接取到地址。因为是外联地址，所以放到blog，网站，帖子里，任何地方都可以。
还有，它们都很稳定，不稳定的要来有什么意义呢，例如FileDen之类，参数再好也没用。
文件存放时间要没有限制，永恒性是我或者我们都喜欢追求的东西。
OK，下面开始，其中前面两个是不支持上传工具的，后面三个支持。
对我来说，更喜欢有上传工具的网盘。
◆第一个是：[url]http://fileupyours.com[/url]
容量100MB，月流量500MB，虽然不大，但相对于国内的网络硬盘已经是非常好的了，文件类型的限制不大，除了htm,asp之类的文件其它都几乎可以上传。
胜在界面简洁使用，网站稳定可靠。
◆第二个是：[url]http://uploadingit.com[/url]
uploadingIT，25GB总上传空间，支持下列格式的文件上传：jpg, jpeg, gif, png, bmp, tiff, raw, psd, pdf, zip, mp3, mov, mpg, mpeg, mp4, swf, flv, txt, wma, wmv。上传速度很快。单个文件上传最大750MB。mp3文件在线播放速度很快，所有文件支持外链，流量无限制。
值得注意的是，此网盘不支持RAR，所以用RAR的朋友，还是三思。
◆第三个是：[url]http://www.esnips.com[/url]
共5GB空间。用户可以上传任何图片、提供RSS订阅。上传下载速度据说不错，但在我这里速度不是很快。
它有一个上传工具，支持图片，文件等。
◆第四个是：[url]http://www.mybloop.com[/url]
总容量：无限，单个文件：无限
它的上传工具你可以直接点右键取到地址，发现这个地址做了重重包装，做了些限制，类似很多国外网站的下载，需要点开才能用，不能直接复制到下载工具。这点，比不上boxstr。除此以外，做个备份网站还是不错的。
值得注意的是，它的上传工具安装包看上去很小，实际上是两款广告程序的安装，你可以都取消勾选。
后面它会自动下载真正的上传工具，大概有9M左右。
◆第五个是：[url]http://boxstr.com[/url]
这个是我认为迄今为止最厚倒最好的网盘，它的上传工具可以直接给你地址。而且地址支持无限次的点击和直接连接，复制到下载工具。
空间大小5G，月流量10G，这是相当充裕的了，上传和下载的速度都是非常不错的，支持的文件类型也很多。
它可以让你把文件压缩成zip文件再进行上传下载，例如你要上传很多图片，你可以打个包，传完后，它可以给你解包后的地址，省去了一个个取地址的麻烦。
还有个特色的地方是，它有上传工具，很好用，你可以不用开网站上传文件图片。
如果是图片，传完后，会给你一个地址，打开就是图片，非常方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422dd0f58eb4e97d81d17b0ef5f5d765/" rel="bookmark">
			错误parsing XML: ubound prefix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能的原因是layout文件的根节点没有声明命名空间。例如：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;ScrollView android:layout_width="fill_parent" android:layout_height="fill_parent" android:scrollbars="vertical" android:fadingEdge="vertical"&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" android:scrollbarStyle="outsideInset" android:scrollbars="vertical" /&gt; &lt;/ScrollView&gt; 需要指明当前layout所用的android的命名空间为：
"http://schemas.android.com/apk/res/android" 具体操作是在ScrollView中使用任何android:XXX之前加上
xmlns:android="http://schemas.android.com/apk/res/android" 在修改Launcher源码时发现加上这个命名空间仍然会保存，那是因为layout中用到了自定义的树形launcher:XXXX，这样还需要加速相应的命名空间，比如Launcher模块可以加上下面这个： xmlns:launcher="http://schemas.android.com/apk/res/com.android.launcher" 参考： http://trinea.iteye.com/blog/1084706
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27baa509df598d954c514df5737e7fe3/" rel="bookmark">
			全面剖析XMLHttpRequest对象(转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 全面剖析XMLHttpRequest对象 XMLHttpRequest对象是当今所有AJAX和Web 2.0应用程序的技术基础。尽管软件经销商和开源社团现在都在提供各种AJAX框架以进一步简化XMLHttpRequest对象的使用；但是，我们仍然很有必要理解这个对象的详细工作机制。 一、 引言 异步JavaScript与XML(AJAX)是一个专用术语，用于实现在客户端脚本与服务器之间的数据交互过程。这一技术的优点在于，它向开发者提供了一种从Web服务器检索数据而不必把用户当前正在观察的页面回馈给服务器。与现代浏览器的通过存取浏览器DOM结构的编程代码(JavaScript)动态地改变被显示内容的支持相配合，AJAX让开发者在浏览器端更新被显示的HTML内容而不必刷新页面。换句话说，AJAX可以使基于浏览器的应用程序更具交互性而且更类似传统型桌面应用程序。 Google的Gmail和Outlook Express就是两个使用AJAX技术的我们所熟悉的例子。而且，AJAX可以用于任何客户端脚本语言中，这包括JavaScript，Jscript和VBScript。 AJAX利用一个构建到所有现代浏览器内部的对象-XMLHttpRequest-来实现发送和接收HTTP请求与响应信息。一个经由XMLHttpRequest对象发送的HTTP请求并不要求页面中拥有或回寄一个＜form＞元素。AJAX中的"A"代表了"异步"，这意味着XMLHttpRequest对象的send()方法可以立即返回，从而让Web页面上的其它HTML/JavaScript继续其浏览器端处理而由服务器处理HTTP请求并发送响应。尽管缺省情况下请求是异步进行的，但是，你可以选择发送同步请求，这将会暂停其它Web页面的处理，直到该页面接收到服务器的响应为止。 微软在其Internet Explorer(IE) 5中作为一个ActiveX对象形式引入了XMLHttpRequest对象。其他的认识到这一对象重要性的浏览器制造商也都纷纷在他们的浏览器内实现了XMLHttpRequest对象，但是作为一个本地JavaScript对象而不是作为一个ActiveX对象实现。而如今，在认识到实现这一类型的价值及安全性特征之后，微软已经在其IE 7中把XMLHttpRequest实现为一个窗口对象属性。幸运的是，尽管其实现(因而也影响到调用方式)细节不同，但是，所有的浏览器实现都具有类似的功能，并且实质上是相同方法。目前，W3C组织正在努力进行XMLHttpRequest对象的标准化，并且已经发行了有关该W3C规范的一个草案。 本文将对XMLHttpRequest对象API进行详细讨论，并将解释其所有的属性和方法。 二、 XMLHttpRequest对象的属性和事件 XMLHttpRequest对象暴露各种属性、方法和事件以便于脚本处理和控制HTTP请求与响应。下面，我们将对此展开详细的讨论。 readyState属性 当XMLHttpRequest对象把一个HTTP请求发送到服务器时将经历若干种状态：一直等待直到请求被处理；然后，它才接收一个响应。这样以来，脚本才正确响应各种状态-XMLHttpRequest对象暴露一个描述对象的当前状态的readyState属性，如表格1所示。 表格1.XMLHttpRequest对象的ReadyState属性值列表。 ReadyState取值描述 0 描述一种"未初始化"状态；此时，已经创建一个XMLHttpRequest对象，但是还没有初始化。 1 描述一种"发送"状态；此时，代码已经调用了XMLHttpRequest open()方法并且XMLHttpRequest已经准备好把一个请求发送到服务器。 2 描述一种"发送"状态；此时，已经通过send()方法把一个请求发送到服务器端，但是还没有收到一个响应。 3 描述一种"正在接收"状态；此时，已经接收到HTTP响应头部信息，但是消息体部分还没有完全接收结束。 4 描述一种"已加载"状态；此时，响应已经被完全接收。 onreadystatechange事件 无论readyState值何时发生改变，XMLHttpRequest对象都会激发一个readystatechange事件。其中，onreadystatechange属性接收一个EventListener值-向该方法指示无论readyState值何时发生改变，该对象都将激活。 responseText属性 这个responseText属性包含客户端接收到的HTTP响应的文本内容。当readyState值为0、1或2时，responseText包含一个空字符串。当readyState值为3(正在接收)时，响应中包含客户端还未完成的响应信息。当readyState为4(已加载)时，该responseText包含完整的响应信息。 responseXML属性 此responseXML属性用于当接收到完整的HTTP响应时(readyState为4)描述XML响应；此时，Content-Type头部指定MIME(媒体)类型为text/xml，application/xml或以+xml结尾。如果Content-Type头部并不包含这些媒体类型之一，那么responseXML的值为null。无论何时，只要readyState值不为4，那么该responseXML的值也为null。 其实，这个responseXML属性值是一个文档接口类型的对象，用来描述被分析的文档。如果文档不能被分析(例如，如果文档不是良构的或不支持文档相应的字符编码)，那么responseXML的值将为null。 status属性 这个status属性描述了HTTP状态代码，而且其类型为short。而且，仅当readyState值为3(正在接收中)或4(已加载)时，这个status属性才可用。当readyState的值小于3时试图存取status的值将引发一个异常。 statusText属性 这个statusText属性描述了HTTP状态代码文本；并 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e54b9b5b3395f10ead32b98a5def84/" rel="bookmark">
			关于手机操作系统（收集整理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五年前，智能手机的代名词就是诺基亚、塞班、HTC和Windows Mobile。如今再提到智能手机，大家说的更多的是苹果和Andriod，另外一支不可忽视的力量——微软Windows Phone，根据市场调研公司Gartner数据显示，2010年其全球份额为4.2%，虽然远逊色于诺基亚Symbian的37.6%、谷歌Android的22.7%、苹果iOS的15.7%，但发展潜力很大，预计2012年微软手机操作系统份额会上升到10.8%。
如今的智能手机，就是一台超便携、可上网的个人电脑，它们所使用的操作系统，决定了手机功能的多少和个性化的大小。购买一部手机，实际上就是在购买一个平台，这个过程和你考虑选择PC还是苹果电脑是一样的。
为了看看如今智能手机的操作系统到底如何，我们花了点时间，仔细研究了一下这个市场上，在手机操作系统上面占有明显优势的顶尖五位：苹果的iPhone(iPhone 3G)、Google的Android(T-Mobile G1)、微软的Windows Mobile(HTC Touch Diamond)、Nokia的S60第三版Symbian(N96)，以及RIM的BlackBerry(BlackBerry Bold)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8765216365b4ac8325b62dcb4b1f8d2b/" rel="bookmark">
			网上绑定 for Redhat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redhat Linux的网络配置，基本上是通过修改几个配置文件来实现的，虽然也可以用ifconfig来设置IP，用route来配置默认网关，用hostname来配置主机名，但是重启后会丢失。
相关的配置文件
/ect/hosts 配置主机名和IP地址的对应
/etc/sysconfig/network 配置主机名和网关
/etc/sysconfig/network-scripts/ifcfg-eth0 eth0配置文件，eth1则文件名为ifcfg-eth1，以此类推
一、网卡配置
假设我们要配置主机名为test，eth0的IP地址192.168.168.1/24，网关地址192.168.168.250
则/etc/sysconfig/network文件内容如下：
NETWORKING=yes
HOSTNAME=test
GATEWAY=192.168.168.250
eth0对应的配置文件/etc/sysconfig/network-scripts/ifcfg-eth0内容如下：
DEVICE=eth0
BOOTPROTO=static
IPADDR=192.168.168.1
NETMASK=255.255.255.0
TYPE=Ethernet
ONBOOT=yes
二、单网卡绑定多个IP
有时，我们需要在一块网卡上配置多个IP，例如，在上面的例子中，我们还需要为eth0配置IP 192.168.168.2和192.168.168.3。那么需要再在/etc/sysconfig/network-scripts下新建两个配置文件：
ifcfg-eth0:0内容如下：
DEVICE=eth0:0
BOOTPROTO=static
IPADDR=192.168.168.2
NETMASK=255.255.255.0
ONBOOT=yes
ifcfg-eth0:1内容如下：
DEVICE=eth0:1
BOOTPROTO=static
IPADDR=192.168.168.3
NETMASK=255.255.255.0
ONBOOT=yes
三、多个网卡绑定成一块虚拟网卡
为了提供网络的高可用性，我们可能需要将多块网卡绑定成一块虚拟网卡对外提供服务，这样即使其中的一块物理网卡出现故障，也不会导致连接中断。比如我们可以将eth0和eth1绑定成虚拟网卡bond0
首先在/etc/sysconfig/network-scripts/下创建虚拟网卡bond0的配置文件ifcfg-bond0，内容如下
DEVICE=bond0
BOOTPROTO=none
BROADCAST=192.168.168.255
IPADDR=192.168.168.1
NETMASK=255.255.255.0
NETWORK=192.168.168.0
ONBOOT=yes
TYPE=Ethernet
GATEWAY=192.168.168.250
USERCTL=no
然后分别修改eth0和eth1的配置文件
ifcfg-eth0内容：
DEVICE=eth0
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
MASTER=bond0
SLAVE=yes
ifcfg-eth1内容
DEVICE=eth1
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
MASTER=bond0
SLAVE=yes
因为linux的虚拟网卡是在内核模块中实现的，所以需要安装的时候已经装好该module。在/etc/modules.conf文件中添加如下内容（如果没有该文件，则新建一个）：
alias bond0 bonding
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8765216365b4ac8325b62dcb4b1f8d2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3322a15c067698fee7d13406628cde41/" rel="bookmark">
			安装 VS2008 HRESULT -2147023293 失败解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我机器系统为 Win2003 Server，之前安装了 Office 2010，今天安装VS2008时出现了如下错误信息： [08/31/11,09:30:07] setup.exe: [2] ISetupComponent::Pre/Post/Install() failed in ISetupManager::InternalInstallManager() with HRESULT -2147023293. [08/31/11,09:30:08] VS70pgui: [2] DepCheck indicates Microsoft Visual Studio Web 创作组件 is not installed. [08/31/11,09:30:08] VS70pgui: [2] DepCheck indicates Microsoft .NET Compact Framework 2.0 SP2 was not attempted to be installed. [08/31/11,09:30:08] VS70pgui: [2] DepCheck indicates Microsoft .NET Compact Framework 3.5 was not attempted to be installed. [08/31/11,09:30:08] VS70pgui: [2] DepCheck indicates Microsoft Visual Studio Tools for the Microsoft Office system (3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3322a15c067698fee7d13406628cde41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08bad8b254bcc015c3f9c5fee6339737/" rel="bookmark">
			C&#43;&#43;中构造函数能调用虚函数吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：XPSP3 VS2005
今天黑总给应聘者出了一个在C++的构造函数中调用虚函数的问题，具体的题目要比标题复杂，大体情况可以看如下的代码：
class Base{public:Base(){Fuction();}virtual void Fuction(){cout &lt;&lt; "Base::Fuction" &lt;&lt; endl;}};class A : public Base{public:A(){Fuction();}virtual void Fuction(){cout &lt;&lt; "A::Fuction" &lt;&lt; endl;}};// 这样定义一个A的对象，会输出什么？A a; 首先回答标题的问题，调用当然是没有问题的，但是获得的是你想要的结果吗？或者说你想要什么样的结果？
有人说会输出：
A::FuctionA::Fuction 如果是这样，首先我们回顾下C++对象模型里面的构造顺序，在构造一个子类对象的时候，首先会构造它的基类，如果有多层继承关系，实际上会从最顶层的基类逐层往下构造（虚继承、多重继承这里不讨论），如果是按照上面的情形进行输出的话，那就是说在构造Base的时候，也就是在Base的构造函数中调用Fuction的时候，调用了子类A的Fuction，而实际上A还没有开始构造，这样函数的行为就是完全不可预测的，因此显然不是这样，实际的输出结果是：
Base::FuctionA::Fuction 据说在JAVA中是上一种输出（感觉有点匪夷所思）。
我们来单步看一下到底发生了什么？在A的构造函数里面首先会去调用Base的构造函数，Base的构造函数如下：
class Base
{
public:
Base()
00411600 push ebp 00411601 mov ebp,esp 00411603 sub esp,0CCh 00411609 push ebx 0041160A push esi 0041160B push edi 0041160C push ecx 0041160D lea edi,[ebp-0CCh] 00411613 mov ecx,33h 00411618 mov eax,0CCCCCCCCh 0041161D rep stos dword ptr es:[edi] 0041161F pop ecx 00411620 mov dword ptr [ebp-8],ecx 00411623 mov eax,dword ptr [this] 00411626 mov dword ptr [eax],offset Base::`vftable' (41770Ch)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08bad8b254bcc015c3f9c5fee6339737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da32ff79812e7078620a317dd92fa29/" rel="bookmark">
			Sandboxie 3.56 Final 特别版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方下载： http://www.sandboxie.com/SandboxieInstall.exe 特别补丁：Sandboxie.3.56.x32.x64.Patch.rar
下载：http://dl.dbank.com/c0j9ukvfc6
转载于:https://www.cnblogs.com/forads/archive/2011/08/27/2161075.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d637a2404605930788b5562c393966d4/" rel="bookmark">
			【C&#43;&#43;基础学习】C&#43;&#43; main():处理命令行选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先简单介绍一下命令行编译C++程序的方法。
编写如下代码，输出参数的个数和各个参数：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main(int argc,char* argv[]) { printf("argc:%d\n",argc); for(int i = 0;i &lt; argc; ++i) printf("%s\n",argv[i]); system("pause"); } 代码中，argc包括命令行选项的个数，argv包含argc个C风格字符串，代表了由空格分隔的命令选项。例如，对于如下命令行：prog -d -o ofile data0，argc被设置为5，且argv被设置为下列C风格字符串： argv[0] = "prog"; argv[0] = "-d"; argv[0] = "-o"; argv[0] = "ofile"; argv[0] = "data0";aegv[0]总是被设置为当前正在被调用的命令（程序运行生成的exe文件名，不包括扩展名）。从索引1到argc-1表示被传递给命令的实际选项。 命令行编译程序的具体步骤：
先编译运行上述代码，在将生成的exe文件拷贝至C盘目录下（自己设置）。然后打开命令提示符：
输入cd C:\切换工作目录至C盘目录。
再输入prog hust whu whut，运行结果：
下面看一下如何取出在argv中的命令行选项。在例子中，将支持下列用法：
program_name [-d] [-h] [-v] [-o output_file] [-l limit_value] file_name [file_name [file_name [...]]]。
加括号的内容是可选的。具体步骤见程序：
//C/C++处理main（）函数命令行 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;ctype.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d637a2404605930788b5562c393966d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d66a5fe3f9ab04e3906d9f2afc50575/" rel="bookmark">
			Unix/Linux下C/C&#43;&#43;开发技术概览-平台差异简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows和Unix是当前两大主流操作系统平台，基于C/C++的开发人员经常会面临这两个平台之间的移植的问题。Unix作为一个开发式的系统，其下有出现了很多个分支，包括Sun的Solaris、IBM的AIX、HP Unix、SCO Unix、Free BSD、苹果的MAC OS以及开源的Linux等。对于这些Unix的分支操作系统，其实现又有很大的差别，因此开发人员又要针对这些不同的系统进行移植。本文的目的就是介绍一下Windows平台和Unix平台之间的差别，并简单介绍一下不同Unix分支操作系统之间的差别，在移植开发过程中的一些注意事项，同时简要介绍一下Unix下开发的一般流程和常用的开发调试工具。
关于平台之间的差异，主要是Windows平台和Unix平台之间的差异，这里着重介绍一下这两个平台在C/C++开发中存在的差异，其间会穿插介绍一些Unix不同分支之间的差异。
1.1语言特性的差异 语言特性的差异，指的是不同操作系统平台中，实现C++/C时的一些细微的差异，忽略这些差异可能会带来一些特别隐蔽的错误。而且可能是致命的错误。所以，了解语言特性的差异，对于在Unix移植来说非常重要。如果考虑系统多多个平台支持，就必须了解在不同平台下语言特性的差异，从开发一开始就把这些因素考虑进去，这样才能最低限度的降低移植的过程中工作量。
1.1.1字节顺序的差异 字节顺序指的主要是整型变量在内存中的存储方式。在计算机中，数据都是以二进制方式存储的，包括在内存和硬盘中。而计算机又以8位二进制作为一个存储单元。在32位系统中，一个整型的存储需要四个存储单元。也就是说要把一个32位的整数分割成位四段分别进行存储，而每一段的存储位置就是字节顺序的差异。为了清楚的表示每段存储的先后位置，我们用16进制来表示一段的值，下表列出了在Unix系统和Windows系统中整数20000在内存中的情况。
十六进制表示
0x00004E20
Windows内存表示
20 4E 00 00
Unix内存表示
00 00 4E 20
如表中所示，Windows中存储方式和该整数的16进制表示是相反，是一种低位在前高位在后的存储顺序。而Unix下的存储顺序和正常的16进制表示的顺序相同，称为高位在前低位在后的顺序。这种差异带来的问题，主要体现在以下几个方面：
Ø 网络通信时
当Windows和Unix之间发生网络数据传输，传输一个整型数据（如一个数据包的长度）的时候，如果不经处理直接把内存中的数据传输过去，那么在对方看来完全是另一个数据，这样就会造成问题。如Windows下面发送过去一个20000（0x00004E20），在Unix下面收到的数据就会被理解成541982720（0x204E0000），这简直是天壤之别。
Ø 文件存储和读取时
跟网络传输类似，如果在Windows下面把某个整数写到了文件中，然后在Unix下面打开这个文件读取该数据，就会出现跟上面类似的问题。
这个问题主要体现在不同平台之间互操作时，在多平台开发过程中，尤其时在网络应用开发的时候，两个平台之间数据交互是非常普遍的，所以这个问题也就显的很普遍。解决这个问题的方法就是交互的双方采用一种相同的数据编码标准，就是数据在传输和存储的时候采用什么方法进行编码，具体的做法有一下几种：
1． 数字转换成字符传进行交互
2． 协商一个同意的字节顺序，根据自己平台的字节顺序还原数据
3． 采用其他标准的编码方式，如ASN1编码
跟这个问题类似，32位系统和64位系统的差异也会出现这样的问题，解决方法跟这个问题的解决方法相同。在32位系统和64位系统中，长整型（long）分别用32位和64位表示，这样，在不同系统之间交互的时候必然会出现整型数据表示方式不同的问题。目前大多数Windows系统都是32位的系统，而Unix中很多都是64位的，尤其是大型的服务器，所以这个问题必须引起重视。
1.1.2变量的作用域差异 在不同的系统下，由于编译器的不同，对变量作用域的实现机制也有所不同，这里以Windows下的VC和Solaris下的CC这两个编译器为例做一个简单的比较说明。
在C++的开发过程中，我们经常会有这样的用法：
for(int i=0;i&lt;num;i++)
{
…
}
这是一种最常用的for循环的用法，因为其中i主要使用来控制循环，所以一般没有必要拿出来单独进行声明，只是放在for语句中一起声明。这里i、j等简单的变量就成了我们常用的变量，一般不按照编程规范那样为他们命名。就是这种声明方法，在Windows下和Solaris下有了不同的理解，i的作用域不同。我们先把作用域进行划分，如下：
{
…
for(int i=0;i&lt;num;i++)
II
{ I
… }
…
…
}
我们划分出I和II两个作用域，其中作用域II包含在作用域I当中。在Windows下，变量i的作用域是I的整个范围，而Solaris下的i的作用域只是II的范围。其实标准的C++语法应该是Solaris的做法，但是微软在实现的时候没有按照这个标准实现，这就引发了我们讨论的这个问题。由于这个差异，就引发了一些微妙而隐蔽的问题。先看一下下面两端代码。
A：
for(int i=0;i&lt;num;i++)
{
…
}
…
for(i=0;i&lt;num;i++)
{
…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d66a5fe3f9ab04e3906d9f2afc50575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c53bf90e6f5c6f96d1b12dafcab7b3f/" rel="bookmark">
			关于java  JPA (小结） Java Persistence API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JPA(Java Persistence API)作为Java EE 5.0平台标准的ORM规范，将得到所有Java EE服务器的支持。Sun这次吸取了之前EJB规范惨痛失败的经历，在充分吸收现有ORM框架的基础上，得到了一个易于使用、伸缩性强的ORM规范。
JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中.
JPA已经作为一项对象持久化的标准，不但可以获得Java EE应用服务器的支持，还可以直接在Java SE中使用。开发者将无需在现有多种ORM框架中艰难地选择，按照Sun的预想，现有ORM框架头顶的光环将渐渐暗淡，不再具有以往的吸引力。
JPA的技术：
JPA包括以下3方面的技术：
(1). ORM映射元数据，JPA支持XML和JDK 5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中.
(2). JPA 的API，用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。
(3). 查询语言，这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 JPA的优势：
1 标准化 JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问 API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。
2 对容器级特性的支持 JPA 框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。 3 简单易用，集成方便 JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释；JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成。
4 可媲美JDBC的查询能力 JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。
5 支持面向对象的高级特性 JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。
JPA的实现:
JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个. 从功能上来说，JPA现在就是Hibernate功能的一个子集。Hibernate 从3.2开始，就开始兼容JPA。
在Spring 2.0.1中，正式提供对JPA的支持，这也促成了JPA的发展，要知道JPA的好处在于可以分离于容器运行，变得更加的简洁。
OpenJPA 是 Apache 组织提供的开源项目，它实现了 EJB 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c53bf90e6f5c6f96d1b12dafcab7b3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d5521926068716b5b43613fe761904b/" rel="bookmark">
			VC实现程序最小化到系统托盘功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：《VC托盘编程》 以VC编程中，经常涉及到托盘操作，比如为我们的程序添加托盘图标，添加托盘左键响应或右键菜单，我们常用的QQ就是个托盘程序。
好了下面我们来看下VC中托盘编程要注意些什么。首先我们要弄清楚一个结构体-NOTIFYICONDATA，这个结构体是托盘编程的关键。
typedef struct _NOTIFYICONDATA {
DWORD cbSize;
HWND hWnd;
UINT uID;
UINT uFlags;
UINT uCallbackMessage;
HICON hIcon;
TCHAR szTip[64];
DWORD dwState;
DWORD dwStateMask;
TCHAR szInfo[256];
union {
UINT uTimeout;
UINT uVersion;
};
TCHAR szInfoTitle[64];
DWORD dwInfoFlags;
GUID guidItem;
} NOTIFYICONDATA, *PNOTIFYICONDATA;
我们来看一下各成员变量是代表什么，其实一般应用当中注意前面十来个成员就行了，下面那几个成员用得比较少。
cbSize　结构体的大小，以字节为单位。
hWnd　窗口的句柄。标示的窗口用来接收与托盘图标相关的消息。Shell_NotifyIcon函数调用时，hWnd和uID成员用来标示具体要操作的图标。
uID 应用程序定义的任务栏图标的标识符。Shell_NotifyIcon函数调用时，hWnd和uID成员用来标示具体要操作的图标。通过将多次调用，你可以使用不同的uID将多个图标关联到一个窗口hWnd。
uFlags　此成员表明具体哪些其他成员为合法数据（即哪些成员起作用）。此成员可以为以下值的组合：
NIF_ICON　hIcon成员起作用。
NIF_MESSAGE uCallbackMessage成员起作用。
NIF_TIP szTip成员起作用。
NIF_STATE dwState和dwStateMask成员起作用。
NIF_INFO　使用气球提示代替普通的工具提示框。szInfo, uTimeout, szInfoTitle和dwInfoFlags成员起作用。
NIF_GUID　保留。
uCallbackMessage
应用程序定义的消息标示。当托盘图标区域发生鼠标事件或者使用键盘选择或激活图标时，系统将使用此标示向由hWnd成员标示的窗口发送消息。消息响应函数的wParam参数标示了消息事件发生的任务栏图标，lParam参数根据事件的不同，包含了鼠标或键盘的具体消息，例如当鼠标指针移过托盘图标时，lParam将为WM_MOUSEMOVE。
hIcon 增加、修改或删除的图标的句柄。注意，windows不同版本对于图标有不同要求。Windows XP可支持32位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d5521926068716b5b43613fe761904b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0f67e96b0b148ef8bd4f1b0c907c1d/" rel="bookmark">
			flex(twaver) 树(tree)的元素拖动的定制显示及控制问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 拖动时不显示那条黑色横线。
样式中设定
tw|Tree{ dropIndicatorSkin: ClassReference("mx.skins.ProgrammaticSkin"); } 2 定制拖动时的提示显示方式
定制样式
tw|Tree{ dropIndicatorSkin: ClassReference("定制的类"); } 定制的类
public class AAA extends ProgrammaticSkin { public function AAA() { super(); } /** * @private */ override protected function updateDisplayList(w:Number, h:Number):void {	super.updateDisplayList(w, h); if (!parent) { return; } var listBase:ListBase = parent.parent as ListBase; if (!listBase) { return; } var g:Graphics = graphics; g.clear(); g.lineStyle(2, 0x004400); g.drawRect(-5, -1, w, listBase.rowHeight); //g.drawRect(-5, -1, w, h); g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a0f67e96b0b148ef8bd4f1b0c907c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8e02535c20a1df660a34c8b21cf9aef/" rel="bookmark">
			Where 和Having的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、作用对象不同：where子句作用于表(或视图)中得行,而having子句作用于形成的组；
where子句限定查找的行，having子句限定查找的组；
2、执行顺序不同：若查询语句中同时有where子句和Having子句，执行时先去掉不满足where条件的行，然后分组，分组后再去掉不满足having条件的组；
3、where自居不能直接使用聚合函数，having子句条件中可以包含聚合函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf015ce89b0c76934c216d55655d65b9/" rel="bookmark">
			详细介绍c&#43;&#43;中的类对象内存模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://developer.51cto.com/art/201106/270265.htm 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e536c6d1baacc7a52e8e73d29cb76e9/" rel="bookmark">
			dma_alloc_writecombine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先理解cache的作用
CPU在访问内存时，首先判断所要访问的内容是否在Cache中，如果在，就称为“命中（hit）”，此时CPU直接从Cache中调用该内容；否则，就 称为“ 不命中”，CPU只好去内存中调用所需的子程序或指令了。CPU不但可以直接从Cache中读出内容，也可以直接往其中写入内容。由于Cache的存取速 率相当快，使得CPU的利用率大大提高，进而使整个系统的性能得以提升。
Cache的一致性就是直Cache中的数据，与对应的内存中的数据是一致的。
DMA是直接操作总线地址的，这里先当作物理地址来看待吧（系统总线地址和物理地址只是观察内存的角度不同）。如果cache缓存的内存区域不包括DMA分配到的区域，那么就没有一致性的问题。但是如果cache缓存包括了DMA目的地址的话，会出现什么什么问题呢？
问题出在，经过DMA操作，cache缓存对应的内存数据已经被修改了，而CPU本身不知道（DMA传输是不通过CPU的），它仍然认为cache中的数 据就是内存中的数据，以后访问Cache映射的内存时，它仍然使用旧的Cache数据。这样就发生Cache与内存的数据“不一致性”错误。
题外话：好像2.6.29内核中，6410的总线地址和物理地址是一样的，因为我在查看vir_to_bus函数的时候，发现在/arch/arm/linux/asm/memory.h中这样定义： #ifndef __virt_to_bus
#define __virt_to_bus __virt_to_phys
#define __bus_to_virt __phys_to_virt
#endif
而且用source Insight搜索了一遍，没有发现6410相关的代码中，重新定义__vit_to_bus，因此擅自认为2.6内核中，6410的总线地址就是物理地址。希望高手指点。
顺便提一下，总线地址是从设备角度上看到的内存，物理地址是CPU的角度看到的未经过转换的内存（经过转换的是虚拟地址）
由上面可以看出，DMA如果使用cache，那么一定要考虑cache的一致性。解决DMA导致的一致性的方法最简单的就是禁止DMA目标地址范围内的cache功能。但是这样就会牺牲性能。
因此在DMA是否使用cache的问题上，可以根据DMA缓冲区期望保留的的时间长短来决策。DAM的映射就分为：一致性DMA映射和流式DMA映射。
一致性DMA映射申请的缓存区能够使用cache，并且保持cache一致性。一致性映射具有很长的生命周期，在这段时间内占用的映射寄存器，即使不使用也不会释放。生命周期为该驱动的生命周期
流式DMA映射实现比较复杂，因为没具体了解，就不说明了。只知道种方式的生命周期比较短，而且禁用cache。一些硬件对流式映射有优化。建立流式DMA映射，需要告诉内核数据的流动方向。
因为LCD随时都在使用，因此在Frame buffer驱动中，使用一致性DMA映射
上面的代码中用到 dma_alloc_writecombine函数，另外还有一个一致性DMA映射函数dma_alloc_coherent
两者的区别在于：
查看两者的源代码 /*
* Allocate DMA-coherent memory space and return both the kernel remapped
* virtual and bus address for that space.
*/
void *
dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
{
void *memory;
if (dma_alloc_from_coherent(dev, size, handle, &amp;memory))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e536c6d1baacc7a52e8e73d29cb76e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3473a12cac71dee601e5ea653c6936e7/" rel="bookmark">
			HDU1237简单计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单计算器 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 6400 Accepted Submission(s): 2030 Problem Description 读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。 Input 测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。 Output 对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 Sample Input 1 + 2 4 + 2 * 5 - 7 / 11 0 Sample Output 3.00 13.36 #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#define _MAX 205
char s[_MAX];
double a[_MAX]; //存数字
char b[_MAX]; //存操作符号
int atoi(char c)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3473a12cac71dee601e5ea653c6936e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878fbc74869419b15a2d9ab5950ed319/" rel="bookmark">
			控制 Android 內置閃光燈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源： http://androidbiancheng.blogspot.com
從 API level 5 開始, 應用軟件可以調用函數 setFlashMode()控制 Android 設備的內置閃光燈, 充當臨時手電筒.
開啟內置閃光燈:
Camera camera;
Parameters parameters;
camera = Camera.open();
parameters = camera.getParameters();
parameters.setFlashMode(Parameters.FLASH_MODE_TORCH);
camera.setParameters(parameters);
關閉內置閃光燈:
parameters.setFlashMode(Parameters.FLASH_MODE_OFF);
camera.setParameters(parameters);
camera.release();
注意：
當應用程序終止時, 不要忘記調用函數 camera.release() 釋放相機功能.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a998c5da7a538a19c1ec18c01ea290b2/" rel="bookmark">
			菩提本无树，明镜亦非台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此乃六祖慧可的悟禅之言，因为其师兄的：身似菩提树，心似明镜台，时时勤拂拭，不使惹尘埃 。六祖感觉悟禅不彻底，于是他吟出了：菩提本无树,明镜亦非台,本来无一物,何处惹尘埃 。
从字面上讲：菩提树是空的，明镜台也是空的，身与心俱是空的，本来无一物的空，又怎么可能惹尘埃呢?
佛对我说：你的心上有尘。我用力地擦拭。
佛说：你错了，尘是擦不掉的。我于是将心剥了下来.
佛又说：你又错了，尘本非尘，何来有尘
我领悟不透，是什么意思？
我想这是从神秀和慧能那两个偈子引申出来。
神秀说：“身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃。”
慧能说：“菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。”
的确，要能够参透这两个偈子的确很难，就是正确的理解也不易。
参悟不透...
身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃
众生的身体就是一棵觉悟的智慧树，
众生的心灵就象一座明亮的台镜。
要时时不断地将它掸拂擦试，
不让它被尘垢污染障蔽了光明的本性。
菩提本无树，明镜亦非台，本来无一物，何处惹尘埃
菩提原本就没有树，
明亮的镜子也并不是台。
本来就是虚无没有一物，
那里会染上什么尘埃?
现在只能从字面上去理解它，惨悟不透！
心本无尘，尘即是心。无心无尘，人便死。
其实尘在外，心在内，常拂之，心净无尘；
尘在内，心在外，常剥之，无尘无心；
心中有尘，尘本是心，
何畏心中尘，无尘亦无心??正如慧能所说的 仁者心动
又如道家所说的 道可道非常道
它们的道理是一样的
佛家讲究万物在心 追求修世
道家讲究无牵无挂 追求避世
佛家想超脱今世 道家则是修行今世 而追究其原理来说都是一种修行
而最终的说的是一种超脱
却不是刻意的寻求
主旨在心
世间人，法无定法，然后知非法法也；
天下事，了犹未了，何妨以不了了之。
就我本身来讲，对于世间的事情，万物，我认为，需要一颗宁静的心，去面对这一切。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db8185214c6dcb41be944effa7d0011/" rel="bookmark">
			LCD 基本知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1　LCD控制器 LCD控制器的功能是产生显示驱动信号，驱动LCD显示器，不同的控制器可以支持无源阵列显示屏（STN）和有源阵列显示屏（TFT）的显示，包括单色和彩色，单向刷新模式和双向刷新模式等不同显示的需求。用户只需要读写一系列的寄存器，完成配置和显示控制。
1.1　概述
由处理器产生的显示数据先被存放在外部存储器的帧缓冲中，这些数据由LCD DMA控制器按顺序加载到一个先入先出（FIFO）的缓冲队列中。当采用单向刷新模式时，只有一个DMA通道在工作，同时对应一个FIFO缓冲队列。当采用双向刷新模式，两个DMA通道都会工作，同时对应两个FIFO缓冲队列。
帧缓冲中的数据称为帧缓冲数据，它们对应屏幕上一个个像素点的色彩值。帧缓冲数据可以是压缩编码后的色彩值，也可以是原始的色彩值，这要取决与LCD控制器选定的显示模式。在彩色模式中，原始的色彩值是16位的RGB色彩值，其中Red 5位、Green 6位、Blue 5位（因为人眼对绿色比较敏感，所以Green多占用了1位），一个16位的数据描述了屏幕上一个像素点的色彩。压缩编码的色彩值可以用比较少的位描述一定的色彩值，减少了每像素点的色彩数据量可以相应地提高显示的刷新速率，减少数据的传输量。但是压缩编码的色彩值需要由色彩描述板（Palette）解释后才能描述像素点真正的色彩值。
1．色彩描述板
当使用原始色彩值，即16位描述一个像素点时不使用色彩描述板。单色色彩描述板是一个256入口的8位宽的数据结构，相当于UInt8 palette[256]，可以表示256级灰度。彩色色彩描述板是一个256入口的16位宽的数据结构，相当于UInt16 palette[256]，可以表示256色的伪彩。压缩编码后的每像素色彩描述位数决定了可描述色彩的数量：每像素1位可以访问色彩描述板中2种色彩，每像素2位可以访问色彩描述板中4种色彩，每像素4位可以访问色彩描述板中16种色彩，每像素8位可以访问色彩描述板中256种色彩。
2．刷新模式
STN显示屏采用的是被动（Passive）刷新模式，有时为了提高LCD色彩的表现，可以通过使每屏图像的像素刷新多次，使用时间混合色度的方法。这个方法叫做暂时调节能量分配算法（TMED），也被称为瞬时抖动。
TFT显示屏采用的是主动（Active）刷新模式，不采用瞬时抖动的方法。
不同的显示模式最终使用的LCD数据输出引脚数也是不同的，而且双向刷新模式所使用的数据引脚数一定是对应单向刷新模式的一倍，这是因为双向刷新模式是同时刷新屏幕的上半部分和下半部分。
3．控制时钟
（1）像素时钟（Pixel Clock）
对应片上引脚L_PCLK，LCD显示器用来控制显示数据进入行显示位移寄存器（Line Shift Register）的控制时钟信号。一个时钟周期刷新屏幕上几个像素点，频率越高，行分辨率越高。在被动刷新模式中只有当有效的显示数据到来了时钟才开始翻转。在主动刷新模式中时钟是连续翻转的，数据的有效信是靠AC Bias信号来判断的。
（2）行时钟（Line Clock）
对应片上引脚L_LCLK，LCD显示器用来表示屏幕上一行像素刷新完毕的时钟信号。当行时钟信号生时就表示显示器要开始刷新下一行的像素，控制器会把存放在行显示位移寄存器中下一行的显示数据转移到显示屏，并且将行位置计数器加1。在主动刷新模式中，行时钟信号也称为水平同步信号。
（3）帧时钟（Frame Clock）
对应片上引脚L_FCLK，LCD显示器用来表示整个屏幕刷新完毕，又有新的帧等待显示时产生的时钟信号。当信号到来时显示器将行位置计数器重置到屏幕的第一行（最靠近屏幕顶端）。在主动刷新模式中，帧时钟信号也称为垂直同步信号。
4．特性
LCD控制器拥有以下几点特性。
n　显示模式：
Ø　支持单向刷新或双向刷新；
Ø　在被动单色模式中最多可以显示256级灰度（8位压缩编码）；
Ø　在主动彩色模式中最多可以显示65536种色彩（16位瞬时抖动）；
Ø　在主动彩色模式中最多可以显示65536种色彩（16位不采用瞬时抖动）；
Ø　支持被动256色伪彩单向刷新模式；
Ø　支持被动256色伪彩双向刷新模式。
n　最大分辨率可达1024×1024像素，建议最大分辨率640×480像素；
n　支持外部RAM彩色色彩描述板，256入口16位宽数据（能够在每帧开始时自动加载）；
n　压缩编码像素支持1位、2位、4位和8位；
n　可编程的像素时钟，频率范围195kHz～83MHz（100MHz/512至166MHz/2）；
n　具有双DMA通道（一个通道用来传输色彩描述板和单向刷新的数据，另一个通道用来在双向刷新模式中传输下半屏幕刷新的数据）。
1.2　LCD控制器寄存器
LCD控制器有4个控制寄存器，10个DMA寄存器，1个状态寄存器，还有1个RAM色彩描述板。所有的寄存器都必须由32位的地址来访问，并且不应该尝试对未定义的寄存器地址空间进行读写的操作，这会产生不可预料的错误。
1．控制寄存器
设置这些寄存器的对应位可以有以下功能：
n　启动和停止LCD控制器；
n　设置LCD屏幕的高度和宽度；
n　指定使用单向还是双向的屏幕刷新方式；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db8185214c6dcb41be944effa7d0011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ea72d33b1a4188a98a44d97c61201a/" rel="bookmark">
			java GC and PhantomReference
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中一共有4种类型的引用:StrongReference、SoftReference、WeakReference以及PhantomReference (幽灵引用), 这 4 种类型的引用与Java GC有着密切的关系, 让我们逐一来看它们的定义和使用场景。
1. Strong Reference
StrongReference 是 Java 的默认引用实现,它会尽可能长时间的存活于 JVM 内， 当没有任何对象指向它时Java GC 执行后将会被回收
@Test public void strongReference() { Object referent = new Object(); /** * 通过赋值创建 StrongReference */ Object strongReference = referent; assertSame(referent, strongReference); referent = null; System.gc(); /** * StrongReference 在 GC 后不会被回收 */ assertNotNull(strongReference); } @Test public void strongReference() { Object referent = new Object(); /** * 通过赋值创建 StrongReference */ Object strongReference = referent; assertSame(referent, strongReference); referent = null; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ea72d33b1a4188a98a44d97c61201a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29721cf88ae5070685b5705532acd11a/" rel="bookmark">
			2011最新QQ大盗使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小超QQ：1102091802
盗取QQ2011版本的教程首先需要下载QQ完美大盗1.0这个是最新更新的！应为是新手录制，所以事先把需要做的步骤打
出来了!大家仔细观看！成为***的主要因素就是需要耐心！
工具：QQ完美大盗1.0
大家晚上好，我是小超。今天我给大家演示这个教程。
这几天我写了一个盗取QQ2011的***，下面我先给大家看下吧。
好的，这节课呢，我主要讲下他的使用方法。下面大家看我操作。
我们来开始盗号。首先我们来配置一个***，可以收到信件，我们来配置***。（建议大家使用网易邮箱收信！)
QQ2011.exe这个呢。就是我们生成的***。下面我们来打开看下。
好的我们在来打开我们的QQ，大家看见的这个窗口其实呢就是一个***窗口，他是不可以登录QQ的。
下面我们来演示截取密码...我们来登录下。看下。我们已经收到信件了。呵呵。还有他提示密码错误吧。
下面我们在来打开我们的QQ，我们在来登录下，看下可以登录不？看到了吧.现在已经正常登录了。好了。
大家应该会使用了吧。我吧这个***的下载地址给大家写一下吧。
还是不写了，呵呵。我把他发在QQ空间和我的博客里吧. 博客：http://hi.baidu.com/夏小诗qq/home
本人QQ：1102091802 盗号软件使用教程！下载地址 http://dl.dbank.com/c0pq2tbr7a 需要软件的朋友可以加QQ：1102091802 希望大家可以支持一下我。我会给大家带来一些更精彩的内容的。 .本次教程结束 大家有不懂的地方可以加QQ：1102091802 小超感谢您的支持！下面开始配置***！哈哈。成功了。接下来
转载于:https://blog.51cto.com/3388498/624994
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d473e6c6a7c477f0f850cd4eaa90be42/" rel="bookmark">
			GPS设置及原理教程-如何通过修改gps.conf文件来提高搜星速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：http://bbs.gfan.com/viewthread.php?tid=564753
下面说的有点复杂，如果mytouch4g的朋友想试试效果，直接将gps.conf文件改成如下内容，然后看定位速度（不是搜星速度，我的搜星速度一直是10秒以内的）有没有提升，反馈一下大家能一起验证一下（我的是gmaps5.0室外信号良好不开gprs，没有wifi的情况下，从7分钟提高到2分钟，最好先备份，对硬件无任何风险）如何修改下文中有介绍
NTP_SERVER=2.cn.pool.ntp.org
NTP_SERVER=north-america.pool.ntp.org
NTP_SERVER=2.asia.pool.ntp.org
NTP_SERVER=0.asia.pool.ntp.org
XTRA_SERVER_1=http://xtra1.gpsonextra.net/xtra.bin
XTRA_SERVER_2=http://xtra2.gpsonextra.net/xtra.bin
XTRA_SERVER_3=http://xtra3.gpsonextra.net/xtra.bin
#SUPL_HOST=supl.google.com
SUPL_HOST=supl.cn.com
SUPL_PORT=7276 前言：
我的mytouch4g装的就是破解版的gmaps5.0，安装详情可参考我另一贴http://bbs.gfan.com/viewthread.php?tid=414093&amp;extra=&amp;page=1 但是有个问题就是定位速度慢，我的系统是英文原版的，早晚上班路上测试基本在7分钟左右才能定位，但是用搜星软件（GPS智慧搜星 ulysee gizmos v1.6.1）搜星速度很快几乎30秒内就能搜到8、9颗星。而且室内窗边基本就能搜到1到2颗星而且不能定位。 更改之后定位速度很快，不到2分钟，而且卫星数量也增加了2个左右，室内距离封闭阳台3米的地方平均能4克星。5楼多层。定位精度有所下降，但不大，关屏幕后再开屏幕定位时间约为20-30秒左右。 导航正在测试中，貌似定位于导航不冲突。 经过网上前辈的种种经验整理汇聚此帖，对手机等GPS设备的定位原理 第一、首先是GPS定位原理： 那GPS 是用什么来确定你和卫星的距离的呢？ 公式：距离= 速度* 时间 无线电波的速度是恒定的，那计算时间就可以得到距离了。GPS 卫星上载有原子钟，并不停地发送含有时间信息的代码。GPS 接收器（芯片）就是接收这些代码，并转译出时间信息。然后用本地的时间减去接收到的时间数据，根据无线电波的速度来确定你和卫星的距离。由于电波信号的传播速度很快，所以GPS 的时间信号是精准到纳秒级的。这就对接收器的时间精度提出了很高的要求。专业级的系统往往要附带有原子钟，至少也需要单独的时间服务器。一般的导航仪也都带有连续运行的计时芯片。 手机受到体积和使用上的限制，所以不可能拥有独立的计时系统。所以谷歌就采取了一个取巧的办法。当系统请求GPS 定位时，从网上的时间服务器（NTP ）上获取时间。用这个时间来计算你和卫星的距离。你可以试验一下，当你的手机连接无线网络（或者是用USB 连接网络）的时候，GPS 定位是非常迅速的。这是因为，有快速的网络可以迅速更新NTP 的数据。 这样我们就可以来考虑如何改善GPS 定位的工作情况了。 一、确保你可用的通信网络。当你在使用GPS 的时候，需要进行同步时间的工作。初次同步后，每1 个小时会更新一次数据，如果更新失败，5 分钟后会再次更新。所以，为了确保你定位精确，请在使用GPS 的时候，确保手机有可用的通信网络（当然，如果你对精度要求不是很高的话，只要保证初次同步时可用就可以了）。 很多朋友可能会问,如果没有移动或者wifi信号还能定位吗? 答案是肯定的，我自己测试过，也问过htc 的客服工程师，个人推测原因如下： 一方面手机同时的GPS 芯片能同时接受卫星信号和差时服务器的信号，然后通过内部计算时间，计算位置信息，但是差时服务器NTP 貌似应该不能发射无线信号啊，那是网络服务器，所以很可能就是GPS 芯片能直接接受由NTP 服务器通过移动网络或其他什么介质传送出来的时钟信号。 再有就是GPS 不通过差时服务器，直接通过卫星信息能自动校时，不过时间慢点而已。以上为个人推测还请高手指正。 二、加快NTP 的更新速度。我的mytouch4g 系统的默认NTP 地址是pool.ntp.org 计划（一个全球性的利用空置服务器提供免费时间服务的项目，目前在全球拥有1400 多台服务器。且根据地域提供服务器池功能。）的北美服务器( north-america.pool.ntp.org) 。这就意味着，所用的手机，不论所处的地域和服务器实际的情况，用GPS 的时候都会去连接那个地址。这种不合理的情况，造成很多非北美的用户GPS 定位缓慢。 知道了以上原理以后我们就可以着手修改自己的gps参数来提高定位效率了。 第 二、修改的原理 基于上面的介绍分析，可以通过如下的方面来提高定位的精度和速度。 1.手机所在地点的卫星信号（是指手机裸露在空旷室外，卫星信号强度可以用搜星软件来测试，我在青岛，坐车在室外基本能稳定在11颗卫星，10颗能导航的水平，更改gps.conf之后的数据，之前是9颗左右，稳定定位8颗） 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d473e6c6a7c477f0f850cd4eaa90be42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7002d410a022621a2359bc1b3bec658c/" rel="bookmark">
			C&#43;&#43; 声明对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在c++的类中，我如果要访问类中的成员变量或函数，有2种方法，第一种就是定义一个一个对象，如：
Class A ... A aa;
aa.xxx();
另外一种就是
Class B ...
B *aa = new B();
aa-&gt;xxx();
在java中，A a = new A（）
c++中等同于 A a；
另外在c++中还有另外一种声明和实例化就是使用指针，如：A* a= new A（）
c++中的A a；就已经构造了对象；
而在java中 A a； 就是声明，还没有分配空间
在c++中就非常的灵活，A a；在栈(stack)上分配空间，静态 A * a= new A；在堆(heap)上分配空间，动态
栈上空间自动回收，堆空间需要程序员手动回收
静态分配内存适合于编译时就已经可以确定需要占用内存多少的情况，而在编译时不能确定内存需求量时可使用动态分配内存；但静态分配内存的运行效率要比动态分配内存的效率要高，因为动态内存分配与释放需要额外的开销；动态内存管理水平严重依赖于程序员的水平，如果处理不当容易造成内存泄漏。
动、静态内存分配比较可以知道动态内存分配相对于静态内存分配的特点： 1、不需要预先分配存储空间； 2、分配的空间可以根据程序的需要扩大或缩小。 要实现根据程序的需要动态分配存储空间，就必须用到malloc函数. ps: C++: A a =new A(); 会报错
A *a=new A();
a.run();会报错(a-&gt;run())
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5988c8d984ab92630e422681a19ba30a/" rel="bookmark">
			关于makefile中的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		man gcc
...
-I dir
Add the directory dir to the list of directories to be searched for header files. ...
-Ldir
Add directory dir to the list of directories to be searched for -l.
...
-Wl,option
Pass option as an option to the linker. If option contains commas, it is split into multiple options at the commas.
...
-l是加一个编译时查找头文件的路径；
-L是加一个编译时查找动态库的路径；
-Wl 是把-rpath 传递为linker的选项；
man ld
...
-rpath dir
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5988c8d984ab92630e422681a19ba30a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/316/">«</a>
	<span class="pagination__item pagination__item--current">317/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/318/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>