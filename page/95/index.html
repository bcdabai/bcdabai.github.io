<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1606ff12f6bfa1b26b5c85417cd462/" rel="bookmark">
			C语言程序设计 第 10 讲 数据的存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据的存储 数据类型介绍数据的存储整数大端小端浮点数的存储规则 数据类型介绍 C语言基本内置类型
char	//字符数据类型 short	//短整型 int	//整形 long	//长整型 long long	//长长整形 float	//单精度浮点型 double	//双精度浮点型 类型的意义：
类型决定了开辟内存空间的大小决定了使用范围 // 1. 整形 char //字符类型底层存储的是字符的ASCII码值，所以归为整形 unsigned char	//无符号 signed char	//有符号 short unsigned short signed short int unsigned int signed int long unsigned long signed long // 2. 浮点型 float double 以上仅仅介绍了C语言当中的一些内置类型，C语言中还有许多派生类型，由用户自己定义，如数组类型，结构体类型，指针类型等。
数据的存储 整数 数据在内存中以二进制的形式存储，对于整数来说，整数的二进制有三种表示形式：原码、反码、补码
对于正整数，原码反码补码相同，负整数的三者需要进行换算
换算过程：
原码：负整数的原码最高位为符号位，1为负，0为正反码：在源码的基础上，符号位不变，其余按位取反补码：反码 +1 得到补码 //example int a = -10; // 原码：100000000000000000000000000001010 // 反码：111111111111111111111111111110101 // 补码：111111111111111111111111111110110 整数在内存中存储的是其补码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1606ff12f6bfa1b26b5c85417cd462/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c026ff8fa56ba4014dcf914da1300ed/" rel="bookmark">
			M1芯片Macbook虚拟机安装centos7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装parallels Desktop、centos7
二、安装Parallels Tools
三、安装VNC server服务
四、进程占用问题
一、安装parallels Desktop、centos7 由于centon7内核版本问题用PD18等版本安装centos7进入默认是命令行安装。
命令界面安装：
1、选数字5 回车 再按提示 c c c
2、输入8 回车，输入密码
3、输入b 回车
4、回车
图形化安装：
这里用到PD16版本的虚拟机来进行图形化安装，选带GUI安装好后等待系统安装完成就不需要重新安装图形化界面。
注意：PD16旧版本可能需要开梯子才能登录使用。
安装PD16
链接: https://pan.baidu.com/s/1aYX2IE6eMLLtuR0nTjyrAw 密码: jm4f
centos7镜像文件
链接: https://pan.baidu.com/s/1nZi-Z-QdR22tIrjUd3WJ3g 密码: k67m
安装好后重新安装新版本Parallels Desktop18即可，（PD16是旧版本）
二、安装Parallels Tools 1、点击安装Parallel Tools 加载ISO到桌面
右击ISO-在终端打开
yum方式安装kernel-devel（缺点是安装的版本和系统内核版本不一致）
yum -y install kernel-devel
所以采用本地安装
连接centos7的ISO镜像文件
mkdir -p /mnt/cdrom mount /dev/cev /mnt/cdrom cd /mnt/cdrom cd Packages rpm -Uvh kernel-devel*.rpm kernel-devel依赖包安装完成
安装gcc-8版本
yum install centos-release-scl -y yum install devtoolset-8-gcc -y 安装完成切换到gcc-8版本，默认是在gcc-4版本下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c026ff8fa56ba4014dcf914da1300ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0dcd56121d4f01e1a532b1584bf626c/" rel="bookmark">
			vscode 排除头文件搜索路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 c_cpp_properties.json 文件中可以通过 includePath 属性来添加头文件的搜索路径，但是，想要排除某个路径下的头文件，可以在 settings.json 中添加如下代码
C_Cpp.default.systemIncludePath": [null] [ ] 中的内容填要排除的路径，这里填 null 表示去掉系统的 includepath 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15db95e2f6e11600e3277576cbb2bcac/" rel="bookmark">
			什么是网站服务器VPS，如何选购最适合自己的一款?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的快速发展，越来越多的人需要建立自己的网站，这就需要有一个可靠的服务器来托管网站。而VPS服务器就是一种非常流行的托管网站的选择。本文将介绍什么是VPS服务器，以及如何选购最适合自己的一款。
什么是VPS服务器?
VPS服务器是Virtual Private Server的缩写，也被称为虚拟专用服务器。它是一种虚拟的服务器，它实际上是一个物理服务器上的虚拟机，可以模拟一个完整的操作系统。VPS服务器可以像独立服务器一样工作，但它们在物理服务器上共享资源，因此可以提供比虚拟主机更好的性能和控制。
VPS服务器的优点
VPS服务器有很多优点，包括：
更好的性能和资源控制。与虚拟主机相比，VPS服务器可以提供更好的性能和控制，因为它们不与其他网站共享资源。
更高的安全性。由于VPS服务器是独立的虚拟服务器，因此安全性更高。如果其他网站在同一物理服务器上受到攻击，它不会影响到您的网站。
更好的灵活性。VPS服务器提供更好的灵活性和可定制性，因为您可以根据需要安装自己的软件和配置服务器。
更好的扩展性。如果您的网站需要更多资源或更高的性能，您可以随时升级您的VPS服务器。
VPS服务器的缺点
然而，VPS服务器也有一些缺点：
更高的成本。与虚拟主机相比，VPS服务器的成本更高。
需要更多的技术知识。与虚拟主机相比，VPS服务器需要更多的技术知识和管理。
如何选购最适合自己的VPS服务器?
当您决定使用VPS服务器时，您需要考虑以下几个因素来选择最适合您的服务器：
1. 选择适当的操作系统
选择适当的操作系统非常重要，因为它将决定您可以运行哪些应用程序和软件。大多数VPS服务器提供Windows和Linux操作系统。如果您不确定选择哪个操作系统，我们建议您选择Linux操作系统，因为它更加稳定和安全。
2. 选择适当的硬件配置
硬件配置是另一个重要的因素。您需要根据您的需求选择适当的硬件配置，例如RAM、存储空间。
3. 选择合适的带宽和流量
选择合适的带宽和流量是非常重要的，因为它们将直接影响您的网站的访问速度和响应时间。如果您的网站有很高的流量，您需要选择更高的带宽和流量。
4. 选择可靠的数据中心
选择可靠的数据中心也是非常重要的，因为它将决定您的服务器的稳定性和可用性。您需要选择一个可靠的数据中心，它可以提供24/7的技术支持和保障，以确保您的服务器始终在线并运行顺畅。
5. 选择合适的价格和服务
最后，您需要选择适合您的预算和需求的价格和服务。不同的VPS提供商将提供不同的价格和服务，您需要根据自己的需求和预算做出选择。
结论
VPS服务器是一个可靠和灵活的托管网站的选择，但是选择适合自己的VPS服务器需要考虑多个因素，如操作系统、硬件配置、带宽和流量、数据中心和价格和服务等。我们希望本文能够帮助您选择最适合自己的VPS服务器。
https://cn.hostease.com/vps/14298.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9397a682fd12012b7fda0a12663275f/" rel="bookmark">
			在Unity3D中使用Mixamo动画资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前两天给低年级的同学答疑，有同学突然问起下载的动画在Unity中用起来错位的问题，才突然想起当初为课程大作业提供的动画资源是Mixamo这个网站（模型资源是另外单独给的游戏资源包），而且在Unity中直接下载动画并使用确实有些问题，于是决定把当时写的文档发个文章，方便后续有同样疑惑的开发者参考。
下载动画文件 网址www.mixamo.com，进入网站后需要登录Adobe账号：
登录后点击左上方Animation标签，在左侧有大量动画可供选择：
这里我们搜索walk并点击选择任意一个动画，中间为该动画预览画面，右侧可以对动画的部分细节进行调整（不同动画可以调整的参数可能略有不同）：
在右侧勾选上In Place（因为我们要使用程序来控制角色移动，不需要动画带有额外的位移），其他参数不做调整。点击右上方的下载，Format选择FBX for Unity，Skin选择Without Skin（下载的文件中不含有模型），后两个选项可以根据需要调整（或者默认就行），确认下载：
修改Unity动画文件设置 下载完毕后，将下载的fbx文件拖入unity中：
选中该文件，在Inspector窗口的Rig栏下将该文件的Animation Type调整为Humanoid（人形骨骼动画），Avatar Definition为Create From This Model，并点击下方的Apply按钮应用变更（这里留个坑，之后会解释）：
切换至Animation栏：
在该栏下方勾选如下设置，让动画能够循环播放并且不影响人物根节点的位置和旋转（此处为人物行走动画所以需要循环播放，对于不同动画设置可能不同），点击Apply应用变更：（右侧为补充的项目中翻滚动画的设置，通过动画控制了角色的XZ轴位移，供参考）
查看模型与动画匹配效果 准备已经绑定好骨骼的人物模型：
选择之前在网站上下载的模型动画文件，在Inspector窗口切换至Animation栏，并拉出最下方的预览窗口。此时可以预览该动画，默认模型为unity官方模型：
点击预览窗口右上方的小人图标选择Other并选择之前准备的模型或者直接将模型拖入该预览窗口都可以将预览模型替换为自己的模型：
点击预览窗口左上方三角，播放动画：
动画错位问题及原因 （不关心技术原理的可以不看，不影响基本使用。）
（注意，此部分为个人理解。当时在写文档时只是面向入门使用，并没有具体介绍原因，因为内容时间久远我的记忆也可能出现差错）
之前我们在动画导入设置的时候Avatar Definition选择了Create From This Model，如果你在网站上下载文件时选择了With Skin可能没什么问题，但如果只是下载了动画文件（Without Skin），那可能会发现动画好像跟之前在网站上预览的时候有些不同，总觉得有些扭曲。
在之前下载的Walk动画中，仔细观察会发现人物的左脚扭曲，与原动画明显不符：
原因是Avatar本质上是在帮我们将不同模型之间的骨骼对应至同一套Avatar，我们在选择Avatar Definition的下方点击Configure就可以看到骨骼的对应情况以及当前Avatar的一些参数设置等。
我们的模型通常默认姿势都是T-Pose。如果你在下载模型动画文件时带上了模型文件，Avatar会以模型动画文件中模型的默认姿势为Avatar的默认姿势，也就是T-Pose，这与我们实际使用的模型姿势相符合。但如果模型动画文件中没有模型资源，Avatar会以动画的第一帧的姿势为默认姿势，并自动应用Enforce T-Pose（上图Inspector窗口最下方可以手动调用），也是就上图左侧的姿势。效果看起来还算不错，但正是因为这个姿势与模型默认姿势的偏差导致了动画后续计算产生了扭曲，所以回到正题，也就是如何解决。
动画错位问题及解决 选择动画文件，在Inspector窗口点击Configure：
可以看到骨骼默认姿势并不是标准的T-Pose，在脚部错位尤其明显：
我们可以在unity中手动调整位置矫正错误，也可以使用如下方法：在mixamo中下载任意动画，Skin选择With Skin（或者搜索下载T-Pose动画，Without Skin）
同样将该文件拖入unity，并修改动画类型。点击Configure可以看到，对于带有模型文件生成了正确的T-Pose：
选择之前下载的动画文件，将Avatar Defintion修改为Copy From Other Avator，Source修改为刚才的Avatar文件，错位问题解决：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccc2f041ec5969d69aace4f279b9f8df/" rel="bookmark">
			Linux搭建jdk8环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在线下载jdk8 wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.rpm 2.赋权限 chmod +x jdk-8u131-linux-x64.rpm 3.进行安装 rpm -ivh jdk-8u131-linux-x64.rpm 4.查看是否安装成功 java -version 默认安装路径为 /usr/java/jdk1.8.0_131
5.编辑环境变量 vim /etc/profile export JAVA_HOME=/usr/java/jdk1.8.0_131 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 6.使得配置立即生效 source /etc/profile 7.查看是否安装成功 java -version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324ab8255613ed9cfd1d96df530bb401/" rel="bookmark">
			Python实现字符串反转的6种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用字符串切片 &gt;&gt;&gt; s = "python" &gt;&gt;&gt; s[::-1] 'nohtyp' &gt;&gt;&gt; 2.使用列表的reverse方法 &gt;&gt;&gt; s = "python" &gt;&gt;&gt; lst = list(s) &gt;&gt;&gt; lst.reverse() &gt;&gt;&gt; "".join(lst) 'nohtyp' &gt;&gt;&gt; 手写 reverse
&gt;&gt;&gt; def reverseString(s:str) -&gt; str: lst = list(s) i, j = 0, len(s)-1 while i &lt; j: lst[i], lst[j] = lst[j], lst[i] i , j = i + 1, j - 1 return "".join(lst) &gt;&gt;&gt; s = 'python' &gt;&gt;&gt; reverseString(s) 'nohtyp' &gt;&gt;&gt; 3.使用reduce &gt;&gt;&gt; from functools import reduce # Python3 中不可以直接调用reduce &gt;&gt;&gt; s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/324ab8255613ed9cfd1d96df530bb401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a8dc5b59160ae9d93d3ad4a6601e37/" rel="bookmark">
			信息学奥赛一本通 1057：简单计算器 | OpenJudge NOI 1.4 19:简单计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目链接】 ybt 1057：简单计算器
OpenJudge NOI 1.4 19:简单计算器
【题目考点】 1. switch语句 2. if…else if…else语句 3. 函数 【题解代码】 解法1：使用switch语句 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int x, y;//声明两个整型变量，表示参与运算的数字 char c;//声明字符型变量，表示运算符 cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;//输入变量 switch(c)//switch选择语句，看变量c与哪个case后面的常量相等 { case '+'://如果c是'+' cout &lt;&lt; x + y;//输出x+y的结果 break; case '-'://如果c是'-' cout &lt;&lt; x - y;//输出x-y的结果 break; case '*'://如果c是'*' cout &lt;&lt; x * y;//输出x*y的结果 break; case '/'://如果c是'/' if (y == 0)//如果除数是0 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0a8dc5b59160ae9d93d3ad4a6601e37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/549de3c81118e4d06c1ee0360981de35/" rel="bookmark">
			Games101学习笔记-Lecture2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、点乘的应用
1.计算向量夹角
2.判断两个向量的方向是否相同
二、叉乘的应用
1.判断点是否在三角形内部
2.生成坐标系（右手）
三、矩阵
1.矩阵的乘法
2.运算规律
3.转置矩阵
4.单位矩阵
5.向量乘法与矩阵
6.行列式
7.代数余子式
8.伴随矩阵
9.逆矩阵
一、点乘的应用 1.计算向量夹角 2.判断两个向量的方向是否相同 二、叉乘的应用 1.判断点是否在三角形内部 点与三角形三条边的同一方向（顺时针/逆时针）的向量叉乘，判断点是否在三条向量的同一侧（同为左/右）。 2.生成坐标系（右手） 可以把任意的向量放入坐标系内。
三、矩阵 1.矩阵的乘法 (1)计算：
m×n = m行n列，只有m的列等于n的行的两个矩阵才可以相乘。
注：此时M代表结果的行，P代表结果的列，N代表左矩阵的列、右矩阵的行。
(2)结果：
计算结果矩阵(i,j)位置上的数字，只需要找到左矩阵的第i行，右矩阵的第j列再进行运输。
2.运算规律 3.转置矩阵 4.单位矩阵 注：A -1为矩阵的逆
5.向量乘法与矩阵 注：A*为对偶矩阵
6.行列式 7.代数余子式 8.伴随矩阵 为各个元素代数余子式组成的矩阵的转置矩阵
9.逆矩阵 若n阶矩阵A可逆,则
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50934d9082038072dac6630bfe08ef2/" rel="bookmark">
			Cisco 动态NAT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先配置IP 内网的网关给10.1 外网的网关给20.1 交换机fa0/3 要开tr口
路由器：
Router(config)#int g0/0 进接口
Router(config-if)#ip nat inside 宣告为nat内网
Router(config-if)#int g0/1 进接口
Router(config-if)#ip nat outside 宣告为nat外网
Router(config-if)#exit 退出当前目录
Router(config)#ip nat pool 1 192.168.20.3 192.168.20.4 netmask 255.255.255.0
创建nat地址池
Router(config)#access-list 1 permit 192.168.10.0 0.0.0.255 创建数据链1 允许10网段访问
Router(config)#ip nat inside source list 1 pool 1 将内部网络与地址池1绑定在一起
Router#show ip nat translations 查看nat的替换状态
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e8f58190de9506e2774ec3d4ef504d/" rel="bookmark">
			带你深入理解线程池—ThreadPoolExecutor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程池概述
一种线程的使用模式，使用线程池方式创建线程的变化：从 创建线程使用，再关闭线程 转换为 从线程池中获取一个空闲的线程使用，使用完后将线程归还给线程池。
为什么使用线程池的方式创建线程？
系统中频繁地创建线程，当线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。
线程池的优势：线程池做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。
线程池优点总结为以下三点：
降低资源消耗（线程复用）: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。提高响应速度（控制最大并发数）: 当任务到达时，任务可以不需要等待线程创建就能立即执行。提高线程的可管理性（管理线程）: 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 1. 线程池的使用 项目开发中常使用线程池的方式创建和使用线程，接下来了解一下线程池如何使用。
线程池的工作流程
执行步骤
创建了线程池后，线程池中的线程数为零（可以通过prestartAllCoreThreads方法使得一开始就创建好核心线程数）。当调用 execute()方法添加一个请求任务时，线程池会做出如下判断： 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务。如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列。如果这个时候队列满了且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务。如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来处理。当一个线程完成任务时，它会从队列中取下一个任务来执行。当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断如果当前运行的线程数大于corePoolSize，那么这个线程就被销毁。 线程池构造器的七大参数
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 复制代码 corePoolSize：核心线程大小 概述：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使有其他空闲线程可以处理任务也会创新线程，等到工作的线程数大于核心线程数时就不会在创建了。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前把核心线程都创造好，并启动。maximumPoolSize：线程池允许创建的最大线程数 概述：此值必须大于等于1。当继续提交任务时，如果队列满了，并且已创建的线程数小于最大线程数maximumPoolSize，则线程池会再创建新的线程执行任务。如果使用了无界队列，那么所有的任务会加入队列，maximumPoolSize这个参数就不起作用了。keepAliveTime：多余的空闲线程的存活时间 概述：当线程池中线程数量超过corePoolSize时，并且多余的线程（指除了corePoolSize之外的线程）空闲时间达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止，如果任务很多，并且每个任务的执行时间比较短，避免线程重复创建和回收，可以调大这个时间，提高线程的利用率。unit：keepAliveTIme的时间单位 概述：可以选择的单位有天、小时、分钟、毫秒、微秒、千分之一毫秒和纳秒。类型使用枚举类java.util.concurrent.TimeUnit选择相应时间单位。workQueue：任务队列（阻塞队列） 概述：用来保存被提交但尚未被执行的任务，作为缓存待处理任务的阻塞队列。下面列举不同种类的阻塞队列。ArrayBlockingQueue：基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）原则对元素进行排序LinkedBlockingQueue：基于链表结构的有界（大小默认值Integer.MAX_VALUE）阻塞队列，此队列按照先进先出排序元素，吞吐量通常要高于ArrayBlockingQueue。PriorityBlockingQueue：支持优先级排序的无界阻塞队列。SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列,每个插入操作必须等到另外一个线程调用移除操作，否则插入操作一直处理阻塞状态，吞吐量通常要高于LinkedBlockingQueue.DelayQueue：使用优先级队列实现的延迟无界阻塞队列。LinkedTransferQueue：基于链表结构组成的无界阻塞队列。LinkedBlockingDeque：基于链表结构组成的双向阻塞队列。threadFactory：表示生成线程池中工作线程的线程工厂 概述：用于创建线程，一般默认工厂DefaultThreadFactory即可。可以通过自定义的线程工厂给每个新建的线程设置自定义线程名。或者使用new CustomizableThreadFactory(name)作为线程工厂即可设置自定义线程名。handler：拒绝策略 概述：线程池的饱和策略。表示当阻塞队列满了，并且工作线程大于等于线程池的最大线程数maximumPoolSize时如何拒绝继续提交的任务的策略。除了JDK提供的策略，可以通过实际的场景实现RejectedExecutionHandler接口自定义饱和策略。下面列举JDK提供的拒绝策略。CallerRunsPolicy: 该拒绝策略会将任务回退到调用者，让调用者的线程执行被拒绝的任务。适用于一般并发比较小，性能要求不高，不允许失败的场景。如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大（“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量）AbortPolicy（默认）: 丢弃任务并抛出拒绝执行RejectedExecutionException异常信息。该拒绝策略作为线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。DiscardPolicy: 该策略直接丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。DiscardOldestPolicy: 该拒绝策略会丢弃阻塞队列workQueue中最老（最前）的一个任务，并将新任务加入（抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务） 1.1 四种固定创建方式 了解完线程池工作过程及参数后，介绍四种固定的创建方式以及优缺点。
Executors.newFixedThreadPool(int nThreads)创建固定线程数的线程池 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } 复制代码 概述：创建一个可重用固定线程数的线程池，以无界队列LinkedBlockingQueue方式来运行这些线程。因为使用无界队列导致最大线程数maximumPoolSize和多余线程空闲存活时间keepAliveTime以及拒绝策略handler等参数失效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44e8f58190de9506e2774ec3d4ef504d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5641e74e2719a2bb053e411f7bac99a/" rel="bookmark">
			20220606 关于矩阵的Young不等式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 定理：原因分析： 定理： 合适维数的矩阵 A , B , C , D A, B, C, D A,B,C,D，合适维数的向量 x , y x, y x,y，有
2 x T ( ( A B ) ⊗ ( C D ) ) y ≤ x T ( A A T ⊗ C C T ) x + y T ( B T B ⊗ D T D ) y 2x^{T}\left(\left(AB\right) \otimes \left(CD\right)\right)y\leq x^T\left(AA^T \otimes CC^T\right)x + y^T\left(B^TB \otimes D^TD\right)y 2xT((AB)⊗(CD))y≤xT(AAT⊗CCT)x+yT(BTB⊗DTD)y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5641e74e2719a2bb053e411f7bac99a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abd888f1fb6a30c9d9d4f98bde9f2033/" rel="bookmark">
			Java 锁升级：从轻量级锁到重量级锁的原理与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中的锁机制是多线程编程中必不可少的一部分。在 Java 中，锁的实现主要分为四种：偏向锁、轻量级锁、重量级锁和自旋锁。其中，轻量级锁和重量级锁是常用的两种锁，对于高并发的场景来说，它们的性能表现非常重要。本篇博客将详细介绍 Java 中锁的升级过程和实现原理，以及相应的优化策略，希望能够帮助读者深入理解 Java 锁机制。
锁升级的过程 Java 中的锁分为四个级别：偏向锁、轻量级锁、重量级锁和自旋锁。在多线程环境下，锁的状态会发生改变，从而进行锁的升级。下面我们来详细介绍一下锁升级的过程。
偏向锁 偏向锁是在单线程环境下，对于同一个对象的多次加锁，只需要记录下该线程 ID 即可。当有其他线程来竞争该锁时，偏向锁会升级为轻量级锁。偏向锁的主要目的是提高单线程环境下的性能。
轻量级锁 轻量级锁是在多线程环境下，对于同一个对象的多次加锁，采用 CAS 操作来进行同步。当线程竞争的时候，轻量级锁会升级为重量级锁。轻量级锁的主要目的是提高多线程环境下的性能。
重量级锁 重量级锁是在多线程环境下，采用操作系统的互斥量来进行同步。当线程竞争的时候，锁就会升级为重量级锁。重量级锁的主要目的是保证数据的正确性。
自旋锁 自旋锁是在多线程环境下，线程在请求锁时，不会被挂起，而是采用循环的方式进行自旋。当锁的持有者释放锁时，请求锁的线程才能够获取锁。自旋锁的主要目的是减少线程挂起的时间，提高性能。
锁升级的实现原理 轻量级锁的实现原理 轻量级锁的实现原理是基于对象头 MarkWord 和线程栈帧中锁记录的状态。在没有竞争的情况下，轻量级锁的实现原理是基于对象头 MarkWord 和线程栈帧中锁记录的状态。在没有竞争的情况下，线程通过 CAS 操作将对象头 MarkWord 中的状态设置为线程 ID 和标识位，表示当前线程获得了该对象的锁。如果线程之间存在竞争，那么将发生锁升级，此时会通过自旋的方式来进行等待，如果自旋超过一定次数，那么锁就会升级为重量级锁，进入等待队列，等待被唤醒。
轻量级锁的实现原理可以用下面的伪代码来表示：
public class Lock { private volatile int state; private Thread owner; public void lock() { if (compareAndSetState(0, 1)) { owner = Thread.currentThread(); } else if (owner == Thread.currentThread()) { state++; } else { //锁升级 } } public void unlock() { if (owner == Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abd888f1fb6a30c9d9d4f98bde9f2033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a966188f4cb1ecc9934d79c7f74b9f71/" rel="bookmark">
			Linux中安装新版minio(centos7版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景需求 由于一些限制,在客户现场的Linux操作系统中,没有安装docker k8s等容器,无法直接使用镜像安装,而且客户要求只能在原始的操作系统中安装最新版的minio,(为什么需要安装最新版的minio,因为检测国网检测到之前版本的minio有漏洞,需要安装新版的minio).
2. 安装minio minio的安装比较简单,下面就开始吧
2.1 前期准备 首先需要建立你的安装目录 [root@master opt]# mkdir minio [root@master opt]# chmond 777 minio/ [root@master opt]# ll 如果不想给这么高的权限,至少保证该文件要有执行的权限
其次,在你刚刚创建的目录下,你需要再创建2个目录,一个文件.
[root@master minio]# mkdir data [root@master minio]# mkdir bin [root@master minio]# chmod 777 data/ [root@master minio]# chmod 777 bin/ [root@master minio]# touch minio.log [root@master minio]# ll 到此为止前期准备结束
2.2 下载minio 可以使用wget命令下载,或者直接下载,然后传到服务器中你刚才创建的minio文件夹下
在现场一般都是采用离线安装的,所以需要先下载好,然后传输到内网服务器中
[root@master minio]# wget https://dl.minio.io/server/minio/release/linux-amd64/minio 等待下载,下载完成后你的minio文件下会多出一个绿色minio
3. 启动minio 启动minio时,我们当时实验了两种方法
直接启动
优点:命令简单,简单粗暴
缺点:直接启动时,启动页面一直被占用,而且每次启动端口都是变化的,无法进行其他工作的开展后台启动
优点:端口可以固定,不会一直占用操作系统的页面,启动命令编写完成后,后期启动比较方便
缺点:命令复杂. 3.1 直接启动 切换到minio目录下 [root@master minio]# .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a966188f4cb1ecc9934d79c7f74b9f71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c84446375652598bb6e2b64a623f89a/" rel="bookmark">
			SomeIP 协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录
SomeIP协议
1.什么是SomeIP
1.1 someip是一种协议
1.2 someip是一个中间件
1.3 协议层
2.Some/IP的功能
2.1 序列化
2.2 远程调用
2.3 服务发现
2.4 订阅/发布
3.服务接口
Method -方法
3.1 Method
3.2 Event
3.3 filed -属性/状态
4.SomeIP报文格式
5.序列化
5.1 序列化和/反序列化
6.Some/IP SD(Service Discovery)
6.1概述
一种特殊的服务，实现服务寻找事件订阅功能
6.2 SomeIP SD报文格式
6.3 SD 启动时序 -服务器和事件的处理阶段
SomeIP协议 1.什么是SomeIP 1.1 someip是一种协议 someip是什么协议？
宝马公司制定的，是车载以太网和SOA的驱动主要提供车内娱乐信息交互的中间信息传递(例如智能座舱)可以适配各种操作系统QNX Linux等 1.2 someip是一个中间件 是操作系统/硬件/和APP之间的服务软件与APP之间使用标准的接口 1.3 协议层 基于TCP/IP的传输，以太网的方式
​
​
2.Some/IP的功能 2.1 序列化 将数据结果或者对象按照定义的规则转换成二进制的过程，便于在网络上传输 2.2 远程调用 基于网络传输方式实现节点间的方法调用 2.3 服务发现 特殊的服务：该服务，client 可以查找所需要的服务。server端可以告诉client 自己那些服务可以被使用client 端可以和server端动态建立连接 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c84446375652598bb6e2b64a623f89a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62ecf11d6b276b18e1c87d4e426eae6a/" rel="bookmark">
			记录一次Windows安装MySQL5.7.24后启动报错“服务无法启动，服务没有报告任何错误”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、报错信息如下 2、复现安装步骤 1、添加MySQL的环境变量（不做赘述）
2、添加自己的配置文件
3、管理员方式打开命令行工具，使用 mysqld --initialize-insecure 初始化mysql，如图提示，此时一切正常！！！
4、使用 mysqld -install 安装mysql服务，如图提示安装成功
5、使用 net start mysql 启动MySQL服务，问题它来了（此图来源于网上，时候想发文章忘记截图了）
3、问题所在 百度后，大部分给的办法其实我都没有遇到此类情况，此刻我便进入了 “卸载MySQL --&gt; 删除初始化的data文件夹 --&gt; 初始化MySQL --&gt; 安装MySQL服务 --&gt; 启动MySQL --&gt; 报错” 。
尝试使用 mysqld --initialize-insecure --console 命令在控制台查看了具体报错，如图
经历过一个小时的百度，知道问题所在是由于初始化MySQL后data文件夹少了系统自带的表文件。
在经过搜索，终于看到一篇文章提示MySQL配置文件中的 sql_mode不能存在空格、换行 ，于是我便查看了自己的mysql配置文件，果然，复制的sql_mode配置中带有换行。删除后保存，然后 重新“卸载MySQL --&gt; 删除初始化的data文件夹 --&gt; 初始化MySQL” 。以下是正常情况下初始化后data文件夹的情况
至此重新，安装服务，启动成功了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40530d78e7b3b218f331ef55594efb21/" rel="bookmark">
			u-picker多列用法和设置默认选中值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uview官方文档并未对多列操作和如何设置默认值做过多的说明，本文就其来做详细的使用解释：
一、简介 &lt;u-picker title="选择图书馆/岗位" keyName="name" @cancel="cancelChange" :loading="loading" ref="uPicker" @change="changeHandler" @confirm="libConfirm" :show="showChange" :columns="[changeLibList, changeDpartList]"&gt;&lt;/u-picker&gt; keyName="name" ，意思是把 name 作为 piker 选项显示的关键字columns作为一个数组，其内部有几个成员，则代表有当前piker有几列cancel、change、confirm 分别为取消、改变选值和确定执行的几个方法title为piker的顶部标题；loading为true时，会打开加载动画 二、 使用 本文的 columns = [changeLibList, changeDpartList] 里面有changeLibList 和changeDpartList 两个数组成员，changeLibList 为第一列数据，changeDpartList 为第二列数据。changeLibList 和 changeDpartList 数据结构大概如下所示：
this.changeLibList = [{"id":1,"name":"赛尔威"},{"id":2,"name":"龙岗图书馆"}] this.changeDpartList= [{"id":1,"name":"行政"},{"id":2,"name":"人事"}] 每次打开页面时，在onShow勾子中重新请求接口数据 （防止数据在别的系统有所变化，如果你的数据是固定不变的，则只获取一次即可）
this.$refs.uPicker.setIndexs(0, 0) 设置第一列的默认选中值为第一个（微信小程序无法将picker实例传出来，只能通过ref操作），但此方法只适用于小程序，app用此方法后可能会造成列表不能滑动等bug
async onShow () { // 每次都重新拿新数据 this.changeLibList = await UserApi.libraryListOfuser(this.user.id) this.changeDpartList = await UserApi.getLibraryJobList(this.changeLibList[0].id) // 防止每次默认选中值不一致，设置其每一列的默认选中值都为第一个 this.$refs.uPicker.setIndexs(0, 0) }, 在每次切换时，调用 changeHandler方法请求接口拿到对应的第二列数据，赋值给changeDpartList，如下：
async changeHandler(e){ const { value, columnIndex, } = e if (columnIndex === 0) { // 打开加载状态 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40530d78e7b3b218f331ef55594efb21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b1f3c8c6638c7587d108356e575dc7/" rel="bookmark">
			C语音中while,do{...}while,for循环，switch,if分支#详讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，什么是循环？ 循环通俗来讲就是重复做一件事情，转化在电脑上的语言就是在满足条件的时候，反复运行其内的代码，直到条件不再满足时，则继续向下运行。
二，我们为什么需要循环？ 我们的程序在有的时候需要做一些重复的指令或动作，然而这些重复的指令或动作如果让程序员一条条写出来是那将是不现实的，面对这种情况就需要我们的循环结构，以便于程序员将实现方案进行简单化。
1.1 while循环 while循环是C语言中最基本的循环结构体之一，它的用法很简单，就是包含关键词及循环条件。
当循环条件成立时进行循环，条件不成立时跳出循环，注意的是条件有时不是一成不变的，而且while没有头文件。
例子： int main() { int arr = 0; while(arr &lt; 5) { arr++; } return 0; } 解释：我们的括号里一般是写循环条件的，也有把条件写成运算的形式，那么这样久做了两件事，一个是进行运算，一个是进行了条件判断。像这个arr++是一个运算代码快，arr&lt;5时会一直执行arr++的运算，在arr++运算的过程中arr在改变，所以当arr等于5时跳出循环。while循环了五次。
注意请不要把while写成死循环。
流程图分析：
1.2 do{...}while循环 do{...}while循环它与while差不多， do{...}while循环它总比while多一次，它会先进行一次代码快的运行，再判断条件。所以do{...}while至少会将代码块执行一次。当然如果控制表达式的值为 true，那么另一次循环就会继续；如果是 false，则循环结束。
对比示范：
int main() { int i = 1;//初始化 do { printf("%d ", i); i = i + 1;//调整部分 } while (i == 0);//判断条件 return 0; 这段代码如果只是while的判断条件的话，它根本就不会执行，因为i永远不会等于0，然而如果是do{...}while循环的话，就会执行一次，这里就会执行printf及i = i + 1。
1.3 for循环 for也是C语言中最基本的循环结构体之一，甚至它比while循环还要用得多，它的理解也是比较简单的。
for（初始化表达式；条件表达式；循环变量变化表达式）{
//循环体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b1f3c8c6638c7587d108356e575dc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a88ce18ec57a1a581a4fb08b8630d563/" rel="bookmark">
			win10没有Hyper-v的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在控制面板-程序-启用或关闭Windows功能下找不到Hyper-v节点，如下图： 解决办法：
1.新建一个TXT文件，将下面命令复制到文本文档中，并将文档重命名Hyper.cmd
pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 2.用管理员身份运行该文档，如下图：
3.等待脚本执行
4.最后输入Y，进行电脑重启，如下图：
5.输入Y重启电脑后，查看控制面板-程序-启用或关闭Windows功能，可以看下Hyper-v节点已存在。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7d92e1af16abeaa9dd72729b5ea353/" rel="bookmark">
			基于Vue3封装一个好用的Websocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue3中使用Websocket可以让我们轻松地实现实时数据传输。为了方便使用，我们可以封装一个好用的Websocket类。
安装依赖 首先我们需要安装 ws 库来处理Websocket连接，使用以下命令进行安装：
npm install ws --save 封装Websocket类 我们可以新建一个 websocket.js 文件，在其中定义一个 Websocket 类，代码如下：
import WebSocket from 'ws'; class Websocket { constructor(url, options = {}) { this.url = url; this.options = options; this.ws = null; } connect() { this.ws = new WebSocket(this.url, this.options); this.ws.onopen = () =&gt; { console.log('Websocket connection opened.'); }; this.ws.onmessage = (event) =&gt; { console.log('Websocket message received.', event.data); }; this.ws.onerror = (error) =&gt; { console.error('Websocket error occurred.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b7d92e1af16abeaa9dd72729b5ea353/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4537d69bf75331409e01d36ee26dd657/" rel="bookmark">
			关于我，一个35岁的老程序员的心路历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打工十余年，从盛大、网易、电魂、再到字节，再到 130w粉 的知识博主，我都经历了什么？如果你现在正为是否要在 编程行业 深耕下去而头疼，那么可以看一下我的故事，希望可以激励到你，看完一定不会让你失望，至少一定会让你热血沸腾，开始吧！
文章目录 英雄哪里出来我的大学实习经历工作经历1、网易2、电魂网络3、字节跳动 知识分享1、公众号2、CSDN3、B站 与君共勉 英雄哪里出来 大家喜欢叫我英雄哥，88年生人，别看我头发茂密，其实我已经工作了十几年了，11届本科毕业加入 网易，从事游戏开发工作，6年后跳槽加入 电魂网络，3年后跳槽加入 字节。
曾经拿过ACM区域赛金牌，一个去过 WorldFinal 打酱油的 WF 选手，刷算法题只是我的业余爱好，通过刷题的过程，不断训练自己的思维，逐渐发现既然是爱好，还不如把它当成一个事业来做，于是通过将十几年的刷题经验整理成算法专栏，帮助更多的人入门编程，入门算法，找到心仪的工作。全网累计收获近 130w 粉丝，以下是我的一些社交账号的地址：
平台地址平台定位B站(58w)英雄哪里出来长视频教学某短视频平台(45w)英雄哪里出来短视频教学CSDN(23w)英雄哪里出来图文教学公众号夜深人静写算法免费资料领取知识星球英雄算法联盟付费打卡学习社群 我的技术能力不是很强，也比较愚钝，我也很羡慕那些反应快，能够快速把问题想清楚的人。而我，通常一个问题要想好久才能想出来，所以养成了写笔记的习惯，通过写笔记的过程，可以梳理我的思路，逐渐把问题想清楚。
我的大学 我针对我个人的情况，给大家一些建议，尤其是还在上学的同学，大学是你赶超别人的最佳时机，因为大部分人高考完就松懈了，以为步入心仪的大学，就可以吃喝玩乐，然而，进入大学，才是锻炼你自学能力的最佳时机，真正到了工作以后，没有那么多时间给你学习你想要学的东西，必然会被业务压得喘不过气来，所以，如果你还在上大学，请不要再把时间花在没有意义的事情上了。
我的大学，干了如下几件事情：
1）各大刷题网站（HDOJ、POJ）刷了 3000 道题……
2）招了个女朋友，也就是现在的老婆，带着一起去机房刷题……
3）包揽全部奖学金，和 程序员鱼皮 比较像的一点是，我也拿过几次 专业第一，以及全计算机学院只有一个名额的学院级特殊奖学金。
4）ACM 亚洲区域赛，陆续拿了铜牌，银牌，金牌，也进了World Final(世界总决赛)，也是我们学校第一支进 WorldFinal 的队伍，我的学校是 杭州电子科技大学。
由于学校鼓励 ACM 竞赛，金牌可以算 2 个绩点，也就是你平均每门课只要考 80 分，总分就能算满分，于是我靠竞赛超过了努力学习的同学，基本大多数学期都是满绩点。
那时候的我，如日中天😂😂😂……
大三结束，我觉得我的能力已经到达了瓶颈，于是退役放弃比赛，开始实习。
实习经历 【大学简历】大学四年八次一等奖学金，一次国家奖学金，一次专业第一，数次专业前三。满绩点。ACM 区域赛 金银铜牌、省赛金银牌、一次 World Final 经历。
这几句话写在简历上，还是比较有份量的，于是很顺利的去了我梦寐以求的游戏公司：盛大。
也就是那个靠传奇一路封神的上海巨头。
十二年前的盛大如日中天，有了我的加入，当然如（并）虎（无）添（卵）翼（用）😂😂😂 ……
2010年，实习工资：200 一天，那时候已经很高了，完全超出我的预期，所以我做出了人生第一次选择，开始踏上我的青云之路……
工作经历 1、网易 然而好景不长，盛大干了半年，我和女朋友一起参加了网易笔试，女朋友进了面试拿了offer，而我被笔试鄙视了😂😂😂……
现在还记忆犹新的就是，一道容斥原理的题，让我写成了动态规划，而且，还是错的。
面试官问女朋友入职有哪些顾虑，于是提到了我，想和我在同一个城市，又于是，面试官打算给我一次面试机会……
于是，在一个风雨交加的夜晚，我带着 盛大工牌 去面试网易，一道记忆犹新的算法题是：给定一个点，如何判定是否在一个任意多边形内。一顿切磋之后，当晚发了offer。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4537d69bf75331409e01d36ee26dd657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58cb9bdecbb15c5b91f2247e8380abc3/" rel="bookmark">
			【C&#43;&#43;标准库】你有所不知的set容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.set 和 vector 的区别（1）set 的排序：string 会按“字典序”来排（2）set 的排序：自定义排序函数（3）set 和 vector 迭代器的共同点（4）迭代器的五大分类（5）set 和 vector 迭代器的不同点（6）std::next 等价于 +（7）std::advance 等价于 +=（8）std::distance 等价于 -（9）迭代器系列帮手函数一览（10）打印任意 STL 容器 2.向 set 中插入元素（1）insert插入重复元素（2）insert插入的第二个返回值（3）insert插入的第一个返回值（4）glibc 中 pair 的定义（5）C++17 的结构化绑定来拆解 pair（6）在 set 中查询元素是否存在（7）从 set 中删除指定元素（8）set 增删改查操作总结（9）从 set 中删除指定范围的元素（10）lower_bound 和 upper_bound 函数（11）set 的遍历（12）set 和其他容器之间的转换（13）set 的妙用：排序（14）清空 set 所有元素（14）set 的大小（元素个数） 3.set 的不去重版本：multiset（1）查找 multiset 中的等值区间（2）equal_range（3）删除 multiset 中的等值区间（4）查找 multiset 中的等值区间（5）求 multiset 中的等值元素个数（6）multiset 也的find 函数（7）multiset 增删改查操作总结（8）set 系列成员函数总结 4.C++11 新增：unordered_set 容器（1）不同版本的 set 容器比较 5.查找方面各容器适合的领域 1.set 和 vector 的区别 都是能存储一连串数据的容器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58cb9bdecbb15c5b91f2247e8380abc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daecf326558c7fa5a5bfb3f6246ccc54/" rel="bookmark">
			电源的安规设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 电源的安规设计1、安规的含义2、执行安规的目的3、电子产品设备可能存在的危险4、安全的基本原则5、安全防护的基本思想6、电击对人的伤害7、危险电压8、人对温度的刺激表现9、根据设备所处的环境，确定其污染等级10、安全距离的确定11、安规器件的要求——X、Y电容1、安规电容定义2、分类3、安规电容为什么可以实现快速放电？ 12、安规电容1、安规电容的定义2、作用&amp;分类2.1 X电容2.2 Y电容2.3 X容与Y容的区别 3、安规电容使用注意事项4、安规电容选型5、安规电容的丝印识读6、附录：常见的安规标志 电源的安规设计 链接: 电源的安规设计
1、安规的含义 以法规的形式实现电在应用中的安全；
是安全规范（法律法规）和安全标准的简称。
2、执行安规的目的 降低电气产品对人身和财产的各种伤害，
包括电击、起火、过热、机械伤害等，
降低公司运行的风险。
3、电子产品设备可能存在的危险 1）电击；
2）能量危险（如电池的正负极短路）；
3）着火；
4）与热有关的危险；
5）机械危险；
6）化学危险；
7）辐射危险。
4、安全的基本原则 设备在正常使用及单一故障条件下，
防止引起人身伤害和着火等危险；
制造商应提供足够的资料，
说明一切必须具备的条件，
以保证用户在按制造商的规定使用设备时不会引起危险；
涉及安全的元器件，
应经公认的试验机构认证，
或作为设备的一个组成部分，承受有关试验；
避免设备在操作、安装、维修、运输或储存时引起维修，
则制造商应提供必要的说明。
与安全有关的说明书和设备标记应使用客户识别的文字和标识。
5、安全防护的基本思想 危险位置与人之间提供双重防护l防护的途径为采用合理的绝缘措施：
1、工作(功能)绝缘（F）
2、基本绝缘 （B）
3、附加绝缘 （S）
4、双重绝缘 （D）
5、加强绝缘 （R）
6、保护接地 （PE）
去除对人身安全的威胁
1、触电
2、起火
3、烫伤
4、辐射
5、机械伤害
6、电击对人的伤害 人类对电的感应
1、皮肤阻抗：人的皮肤阻抗根据皮肤的湿度改变，干的时候达到3兆欧姆，潮湿时大约500欧姆，皮肤的阻抗也会随周围环境温度、疲劳情况空气湿度、惊吓、焦虑及其它因素改变。
2、致命电流 ：99%的健康男性的心脏能通过的极限电流的时间为：（即致命电流与时间）。
7、危险电压 1、IEC 60950-1 办公室环境60Vdc,42.4Vpeak,30Vac
2、IEC 60950-22户外环境30Vdc,21.2Vpeak,15Vac
8、人对温度的刺激表现 1、肌肉组织在50℃会遭到破坏；神经组织会在更低的温度下被破坏；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daecf326558c7fa5a5bfb3f6246ccc54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bba594b52d96acccb649ff45f4efed3/" rel="bookmark">
			【从零开始学Skynet】基础篇（二）：了解Skynet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、节点和服务 在下图所示的服务端系统中，每个Skynet进程（操作系统进程）都称为一个节点，每个节点都可以开启数千个Lua服务，每个服务都是一个Actor。不同节点可以部署在不同的物理机上，提供分布式集群的能力。 在上图中，我们开启了3个节点和5个服务的服务端系统。
拓展：其实Skynet的强项主要是在于单个节点内的并行运算，对于分布式集群，它只提供一些基础设施。在Skynet引擎中，分布式程序要处理很多异常情况。
2、Skynet的目录结构 Skynet的目录结构如下图所示：
目录/文件说明3rd存放第三方的代码，如Lua、jemalloc等 examples
范例：KV数据库范例的部分服务（如main服务、simpledb服务）位于该目录下luaclib用C语言编写的程序库，如bson解析、md5解析等lualib用Lua编写的程序库lualib-srclualib目录下，库文件的源码service 包含Skynet内置的一些服务，比如KV数据库范例用到的launcher、gate cservice存放内置的用C语言编写的服务service-srccservice目录下，程序的源码skynet-src使用C写的Skynet核心代码test测试代码：如果遇到某些不懂的功能，可以参考该目录下的代码 3、启动流程 下图展示了Skynet的启动流程。图中①②③步由引擎完成，用户只需在配置文件中指定主服务即可，之后就可以从主服务开始编写程序了。
4、配置文件 Skynet提供了很多配置项，可以打开配置文件examples/config查看它的内容：
include "config.path" -- preload = "./examples/preload.lua"	-- run preload.lua before every lua service run thread = 8 logger = nil logpath = "." harbor = 1 address = "127.0.0.1:2526" master = "127.0.0.1:2013" start = "main"	-- main script bootstrap = "snlua bootstrap"	-- The service for bootstrap standalone = "0.0.0.0:2013" -- snax_interface_g = "snax_g" cpath = root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bba594b52d96acccb649ff45f4efed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb470178a3a89b3aa94c1419c806f00f/" rel="bookmark">
			【从零开始学Skynet】基础篇（一）：Skynet环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Skynet运行于Linux操作系统，我们可以在自己的电脑上搭建虚拟机系统，也可以购买阿里云、腾讯云服务器，笔者这个系列的所有代码都是在Ubuntu16.04的虚拟机系统下运行。关于Ubuntu系统的环境搭建，前面的文章已经提过了：Ubuntu16.04环境搭建
1、工具下载 在下载和编译skynet之前，我们需要先下载几个工具，使用快捷键“alt + shift + t”打开终端，输入以下命令：
sudo apt-get install git --版本控制工具sudo apt-get install autoconf --shell脚本生成工具sudo apt-get install gcc --代码编译工具 一般的桌面系统都会自带这些工具，在下载之前也可以先检查一下是否已经存在了此工具：
git --versionautoconf --versiongcc --version 2、Skynet下载 在终端中输入以下命令：
git clone https://gitee.com/mirrors/skynet.git
下载完毕之后，我们打开左边的类似文件夹的图标，就能看到skynet已经被下载到了本地；
3、编译源码 在终端中输入以下指令，准备编译：
cd skynet --进入skynet目录make linux --编译 执行指令“make linux”会自动下载第三方库“jemalloc”，如果下载“jemalloc”失败了，可以多试几次，编译成功后显示的输出内容如下：
编译成功后，skynet目录下会多出一个名为“skynet”的可执行文件。 4、运行范例 （1）运行服务端： 要启动Skynet，需指定一份配置文件，“examples/config”是KV数据库的配置文件，输入如下指令可启动它：
./skynet examples/config --启动Skynet（KV数据库范例） 运行结果上图所示，输出的内容显示Skynet依次启动了bootstrap、launcher、cmaster、simpledb、watchdog、gate等服务。图中左侧的“:0100000x”代表该条消息由哪个服务产生，可以看到，gate服务（地址为0100000f）监听了8888端口。
（2）运行客户端：
启动服务端后，接着启动客户端。客户端的代码在“examples/client.lua”中，启动客户端的代码需要Lua程序，此程序位于“3rd/lua/lua”中，是Skynet编译后生成的；
如果服务器没有安装Lua，或者Lua版本小于5.3，可以用如下命令启动客户端：
./3rd/lua/lua examples/client.lua --启动客户端 客户端的运行结果如上图所示，输入hello，会得到服务端的回应“result world”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40eb12b79c40a5e46416c7df0b82cfd/" rel="bookmark">
			【从零开始学Skynet】工具篇（一）：Ubuntu16.04环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Ubuntu系统下载 为了初学者使用方便，我们下载的是Ubuntu16系统的桌面版本：下载地址
二、VirtualBox虚拟机下载 去Virtualbox官网下载:Downloads – Oracle VM VirtualBox
点击这里进行下载，下载完之后点击客户端进行安装，安装很简单，一直点击下一步就可以了。
三、Ubuntu系统安装 Virtualbox虚拟机安装完了之后，开始进行Ubuntu系统的安装：
点击“新建”按钮，弹出“新建虚拟电脑”的对话框，输入“Name”和选择“Folder”要存放的目录，然后点击“Next”进行下一步； 配置内存大小和CPU数量，根据个人情况配置，然后点击“Next”； 配置硬盘的大小，根据个人情况配置，点击“Next”进行下一步； 弹出配置信息的对话框，点击“Finish”完成配置，回到主界面； 回到主界面后，点击“启动”按钮，继续配置Ubuntu系统； 等待一会之后，弹出对话框，找到刚才下载好的系统，点击“Mount and Retry Boot”； 点击“Install Ubuntu”，开始安装。 默认选择，点击“Continue”； 默认选择，点击“Install Now”； 此时会弹出提示的对话框，点击“Continue”即可； 时区填写China Time，然后点击“Continue”； 语言按照默认的English即可，点击“Continue”； 输入账号和密码，点击“Continue” ； 然后开始等待安装； 安装完成之后，点击“Restart Now”； 重启之后，输入密码，点击回车进入系统； 到这里Ubuntu的系统就已经全部 安装完成了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18ec685ed403882e1ffc11a8276c2652/" rel="bookmark">
			SpringBoot项目中idea提示未配置 Spring Boot 配置注解处理器解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于springboot的配置已经相当完善，出现这种情况的原因大概率是因为注解缺失 解决方案： 在启动类Application前加上注解下面即可
@ConfigurationPropertiesScan(basePackages = "{包名}")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93bdbfff40fbfbdc20abcadebd20f334/" rel="bookmark">
			umeditor粘贴图片自动上传到服务器(Java版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前功能基于PHP，其它语言流程大致相同
1.新增上传word json配置
在ueditor\php\config.json中新增如下配置：
/* 上传word配置 */
"wordActionName": "wordupload", /* 执行上传视频的action名称 */
"wordFieldName": "upfile", /* 提交的视频表单名称 */
"wordPathFormat": "/public/uploads/word/{yyyy}{mm}{dd}/{time}{rand:6}", /* 上传保存路径,可以自定义保存路径和文件名格式 */
"wordMaxSize": 102400000, /* 上传大小限制，单位B，默认100MB */
"wordAllowFiles": [".docx"] /* 仅支持docx格式的word */
2.修改编辑器配置文件，在工具栏上新增按钮
在ueditor\ueditor.config.js文件中，新增按钮名称"wordupload"，并添加鼠标悬浮提示，如下所示：
//工具栏上的所有的功能按钮和下拉框，可以在new编辑器的实例时选择自己需要的重新定义
, toolbars: [[
'fullscreen', 'source', '|', 'undo', 'redo', '|',
'bold', 'italic', 'underline', 'fontborder', 'strikethrough', 'superscript', 'subscript', 'removeformat', 'formatmatch', 'autotypeset', 'blockquote', 'pasteplain', '|', 'forecolor', 'backcolor', 'insertorderedlist', 'insertunorderedlist', 'selectall', 'cleardoc', '|',
'rowspacingtop', 'rowspacingbottom', 'lineheight', '|',
'customstyle', 'paragraph', 'fontfamily', 'fontsize', '|',
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93bdbfff40fbfbdc20abcadebd20f334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807ecf554baccc12b50076c2d0923f3a/" rel="bookmark">
			如何在Ubuntu上开机运行java程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、环境介绍
2、设备介绍
3、前期准备
3.1.给Ubuntu安装jdk
3.2.编译jar包,编译后存放在ubuntu的文件夹中,我存放在/usr/src/
4、创建autostart 文件夹
5、创建javaTest.desktop文件(名称按自己要求)
6、重启ubuntu系统 即可
总结
1、环境介绍 JAVA Intellij IDEA 2022.3.3 (Ultimate Edition)
jdk-1.8.0_77
Ubuntu Linux version 5.10.110 (root@seven-HP-ZHAN-99-Pro-G1-MT) (aarch64-none-linux-gnu-gcc (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29)) 10.3.1 20210621, GNU ld (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29)) 2.36.1.20210621) #11 SMP Fri Feb 10 18:15:24 CST 2023
openjdk version "11.0.18" 2023-01-17
OpenJDK Runtime Environment (build 11.0.18+10-post-Ubuntu-0ubuntu120.04.1)
OpenJDK 64-Bit Server VM (build 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/807ecf554baccc12b50076c2d0923f3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d803f07a6106fa42a5f4173aa8352e96/" rel="bookmark">
			JDBCUtilsByDruid封装工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.qf.dao_.utils; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import java.io.FileInputStream; import java.sql.*; import java.util.Properties; public class JDBCUtilsByDruid { //私有化数据源 private static DataSource ds; static { //实例化 Properties Properties properties = new Properties(); try { //加载properties文件 properties.load(new FileInputStream("src\\druid.properties")); //创建连接 ds = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } //编写getConnection方法 public static Connection getConnection() throws SQLException { return ds.getConnection(); } //关闭连接 //而是把使用的Connection对象放回连接池 public static void close(ResultSet rs, Statement statement, Connection connection) { try { if (rs !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d803f07a6106fa42a5f4173aa8352e96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b67eb66e20c19f9649331dc9f824c94/" rel="bookmark">
			Mybatis拦截器介绍及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis拦截器介绍及使用
1. Mybatis拦截器是什么？一般用途？
MyBatis允许使用者在映射语句执行过程中的某一些指定的节点进行拦截调用，通过织入拦截器，在不同节点修改一些执行过程中的关键属性，从而影响SQL的生成、执行和返回结果，如：来影响Mapper.xml到SQL语句的生成、执行SQL前对预编译的SQL执行参数的修改、SQL执行后返回结果到Mapper接口方法返参POJO对象的类型转换和封装等。
根据上面的对Mybatis拦截器作用的描述，可以分析其可能的用途；最常见的就是Mybatis自带的分页插件PageHelper或Rowbound参数，通过打印实际执行的SQL语句，发现我们的分页查询之前，先执行了COUNT(*)语句查询数量，然后再执行查询时修改了SQL语句即在我们写的SQL语句后拼接上了分页语句LIMIT(offset, pageSize)；
此外，实际工作中，可以使用Mybatis拦截器来做一些数据过滤、数据加密脱敏、SQL执行时间性能监控和告警等；既然要准备使用它，下面先来了解下其原理。
2. Mybatis执行过程
2.1 核心对象
从Mybatis关键代码的来看，MyBatis的主要的核心部件有以下几个：
Configuration：初始化基础配置，比如MyBatis的别名等，一些重要的类型对象，如插件，映射器，ObjectFactory和typeHandler对象，MyBatis所有的配置信息都维持在Configuration对象之中。
SqlSessionFactory：SqlSession工厂。
SqlSession：作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要的数据库增删改查功能。
Executor：MyBatis的内部执行器，它负责调用StatementHandler操作数据库，并把结果集通过ResultSetHandler进行自动映射，另外，它还处理二级缓存的操作。
StatementHandler：MyBatis直接在数据库执行SQL脚本的对象。另外它也实现了MyBatis的一级缓存。
ParameterHandler：负责将用户传递的参数转换成JDBC Statement所需要的参数。是MyBatis实现SQL入参设置的对象。
ResultSetHandler：负责将JDBC返回的ResultSet结果集对象转换成List类型的集合。是MyBatis把ResultSet集合映射成POJO的接口对象。
TypeHandler：负责Java数据类型和JDBC数据类型之间的映射和转换。
MappedStatement：MappedStatement维护了一条&lt;select|update|delete|insert&gt;节点的封装。
SqlSource ：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回。
BoundSql：表示动态生成的SQL语句以及相应的参数信息。
2.2 执行过程分析
Mybatis执行过程可以看下图：
3. 如何使用Mybatis拦截器？
自定义一个mybatis的拦截器步骤包含：
（1）.定义一个实现org.apache.ibatis.plugin.Interceptor接口的拦截器类，并实现其中的方法。
（2）添加@Intercepts注解，写上需要拦截的对象和方法，以及方法参数。
（3）在mybatis的全局配置xml中配置插件plugin；对于去xml的Spring工程，显示的注册这个拦截器Bean即可；
3.1 添加注解
MyBatis拦截器默认可以拦截的类型只有四种，即四种接口类型Executor、StatementHandler、ParameterHandler和ResultSetHandler。对于我们的自定义拦截器必须使用MyBatis提供的@Intercepts注解来指明我们要拦截的是四种类型中的哪一种接口。
3.1.1 @Signature注解
@Intercepts // 描述：标志该类是一个拦截器
@Signature // 描述：指明该拦截器需要拦截哪一个接口的哪一个方法
3.1.2 @Signature注解中的type属性
type; // 四种类型接口中的某一个接口，如Executor.class；
method; // 对应接口中的某一个方法名，比如Executor的query方法；
args; // 对应接口中的某一个方法的参数，比如Executor中query方法因为重载原因，有多个，args就是指明参数类型，从而确定是具体哪一个方法；
MyBatis拦截器默认会按顺序拦截以下的四个接口中的所有方法：
org.apache.ibatis.executor.Executor //拦截执行器方法
org.apache.ibatis.executor.statement.StatementHandler //拦截SQL语法构建处理
org.apache.ibatis.executor.parameter.ParameterHandler //拦截参数处理
org.apache.ibatis.executor.resultset.ResultSetHandler //拦截结果集处理
实际上，具体是拦截这四个接口对应的实现类：
org.apache.ibatis.executor.CachingExecutor
org.apache.ibatis.executor.statement.RoutingStatementHandler
org.apache.ibatis.scripting.defaults.DefaultParameterHandler
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b67eb66e20c19f9649331dc9f824c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b2a832a0a1c3b5cbef9dc53278a968/" rel="bookmark">
			springboot配置跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期自己搭建项目时，遇到一个跨域问题。我们以前项目解决跨域是在controller上加一个跨域注解@CrossOrigin(allowCredentials = "true")，很方便。但是在我自己搭建的项目中，启动时竟然报错了，错误如下：
When allowCredentials is true, allowedOrigins cannot contain the special value "*" since that cannot be set on the "Access-Control-Allow-Origin" response header. To allow credentials to a set of origins, list them explicitly or consider using "allowedOriginPatterns" instead.
这就很奇怪了，为什么直接拿过来不能用了呢？
错误大概意思是：
当allowCredentials为真时，allowedorigin不能包含特殊值"*"，因为不能在"访问-控制-起源“响应头中设置该值。要允许凭证到一组起源，显示地列出它们，或者考虑使用"allowedOriginPatterns”代替。
原来是以前的项目springboot是2.1，而我自己搭建的项目采用springboot2.7版本。根据错误提示，可以改成如下写法就可以了。
@CrossOrigin(allowCredentials = "true",originPatterns = "/**") 原因是在springboot2.4版本之后，不允许origins含有特殊值星号。
从注解@CrossOrigin源码可以看出，origins默认是*号
通过查看源码，我认为这样写也是OK的，如:
@CrossOrigin(allowCredentials = "true",origins = "http://localhost:8010/") 到此为止跨域报错问题解决了。
其实解决跨域有两种方式，一种是利用注解，一种写个配置类。各有利弊吧，跨域注解需要在对应的controoler上加注解，配置类写一次就可以了。
第一种方式：利用注解 @CrossOrigin(allowCredentials = "true",origins = "http://localhost:8010/") //@CrossOrigin(allowCredentials = "true",originPatterns = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73b2a832a0a1c3b5cbef9dc53278a968/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be981466400b7381debec16f4f2a79b6/" rel="bookmark">
			log4j2漏洞分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Log4j是一个流行的Java日志框架，它被广泛用于开发和生产环境中的应用程序。在2021年12月，Log4j2被曝出一个严重的漏洞，该漏洞使攻击者可以通过特殊构造的请求来远程执行任意代码，从而导致服务器被完全控制。本文将对这个漏洞进行分析。
漏洞概述 漏洞标识符为CVE-2021-44228，通常称为Log4Shell或Log4j漏洞，它存在于Log4j的JNDI查找功能中。攻击者可以通过特殊构造的请求利用此漏洞，向Log4j发送恶意请求，从而触发远程代码执行（RCE）漏洞，进而获得服务器上的完全控制权限。
这个漏洞的危害非常大，由于Log4j广泛应用于各种Java应用程序中，这意味着攻击者可以利用该漏洞轻松攻击大量的目标。
漏洞分析 漏洞原因
该漏洞的根本原因是Log4j的JNDI查找功能中存在的一个设计缺陷。具体来说，这个功能允许开发者在日志配置文件中使用类路径资源名称（例如“java：comp/env/jdbc/mydb”）作为日志输出位置。当Log4j需要将日志写入到这些位置时，它会使用Java命名和目录接口（JNDI）进行查找，并在找到资源后写入日志。
然而，这个功能也允许开发者使用像“ldap：//xxxxxx”这样的URL作为日志输出位置。当Log4j需要将日志写入到这样的位置时，它会试图从指定的LDAP服务器上查找资源，并在找到资源后写入日志。这就为攻击者提供了机会，可以通过构造一个特定的LDAP请求来执行任意代码。
漏洞利用
攻击者可以利用这个漏洞来远程执行任意代码。攻击者可以通过构造一个特殊的LDAP请求，将恶意的Java代码嵌入到请求中，并发送给Log4j。当Log4j尝试从指定的LDAP服务器上查找资源时，它会执行恶意的Java代码。攻击者可以利用这个漏洞来获取服务器的完全控制权，并进一步进行其他攻击。
漏洞影响
该漏洞影响Log4j 2.x版本，包括2.0-beta9至2.14.1之间的所有版本。根据报道，这个漏洞已经被广泛利用，许多知名组织的服务器已经受到攻击。这些
攻击包括数据窃取、勒索软件和挖矿等不同类型的攻击。
该漏洞的影响范围非常广泛，因为Log4j是一个广泛使用的Java日志框架，几乎所有使用它的应用程序都受到影响。这包括Java Web应用程序、服务器软件、安全设备、操作系统和网络设备等等。因此，该漏洞可能会对全球范围内的各种组织和企业造成重大影响。
漏洞修复 目前，Log4j官方已经发布了多个修复版本，包括2.15.0、2.14.2、2.13.4和2.12.4。建议所有使用Log4j的用户尽快升级到最新版本。
除此之外，还有一些其他的应对措施可以帮助用户减轻漏洞的影响，例如：
禁用Log4j的JNDI功能。虽然这会影响一些应用程序的日志记录，但它可以有效地避免漏洞的利用。
在应用程序的入口处过滤恶意输入，以避免攻击者利用漏洞构造恶意请求。
使用Web应用程序防火墙和入侵检测系统等安全设备，监测并阻止恶意请求。
及时备份数据，以便在受到攻击时可以恢复数据。
结论 Log4j漏洞是一个非常严重的漏洞，它已经被广泛利用来攻击各种组织和企业。该漏洞的根本原因是Log4j的JNDI查找功能存在设计缺陷，使得攻击者可以通过构造特殊的请求来执行任意代码。为了保护自己的系统，所有使用Log4j的用户都应该尽快升级到最新版本，并采取其他相应的应对措施。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df2bdc381dac25d2f77dedd79a8254d/" rel="bookmark">
			Java程序内存占用优化实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 背景堆内存调整内存还会继续上涨减少线程数量TomcatDubboLogback野线程 背景 上了微服务的当，喜欢将服务各种拆分，公有云模式下服务器比较多，还能玩得转。到了私有化部署，有的客户连个技术人员都没有，只想一键启动就能用，于是将所有服务放在一台物理机上制作母盘，实施安装时省时省力，还能清公司的服务器库存。
但是问题来了，在一台物理机上部署几十个服务，有C++服务，有Java服务，还有中间件，内存非常吃紧。15G的内存，所有服务跑起来，啥也不干，10G就没了，更别提有些服务在运行过程中还会继续申请内存。于是提出资源占用优化。
首当其冲的是Java服务，top看一下，排在上面的是一众Java进程，内存杀手的名号不是白叫的。
堆内存调整 一说到调整内存，最容易想到的就是堆内存了，连-Xms -Xmx这两个参数都不知道的Java程序员不是好curd boy。
-Xms：初始堆内存大小，也就是Java进程一起动堆就占这么多物理内存，如果发现不够用就再申请内存（假如能申请的话，通常都喜欢将-Xms和-Xmx的值设置成一样的，因为据说动态扩展会影响性能？）。-Xmx：最大可分配堆内存大小，可以理解成虚拟内存。内存不够用又无法继续扩展时，就会OOM。 如果不需要在堆内存中聚集大量数据（比如：利用堆做缓存、在堆中排序并分页），大部分对象的生命周期都比较短的话，就不需要将堆内存设置的太大。
我个人的经验是，在程序刚启动时和压测后分别统计一次垃圾回收情况，垃圾回收统计使用如下命令：
jstat -gcutil pid 输出：
重点关注FGC（Full GC 次数）和GCT（GC总耗时），在OOM之前FGC会显著增大，另外，如果花了大量时间来回收垃圾，也能说明堆内存给太少了。
根据对每个服务负载的理解，进行了一波盲调，效果还不错。
内存还会继续上涨 明明通过-Xmx限制了堆内存大小，怎么压测完内存还是有明显上涨捏？我不能接受啊。大家都说是内存泄漏了，我不信！
为了搞清楚原因，我使用NMT追踪Java进程内存使用情况，NMT全称Native Memory Tracking，是HotSpot虚拟机的功能，可跟踪HotSpot虚拟机的内部内存使用情况。
需要在启动参数中加上-XX:NativeMemoryTracking=detail开启NMT，例如：
java -XX:NativeMemoryTracking=detail -jar -Xms96m -Xmx96m ./access-1.8.2.17.jar &amp; 查看：
jcmd pid VM.native_memory summary scale=MB 输出：
解释：
Reserved：reserved memory 是指JVM 通过mmaped PROT_NONE 申请的虚拟地址空间，在页表中已经存在了记录（entries）。Committed：committed memory 是JVM向操做系统实际分配的内存（malloc/mmap），mmaped PROT_READ | PROT_WRITE，相当于程序实际申请的可用内存。committed申请的内存并不是说直接占用了物理内存，由于操作系统的内存管理是惰性的，对于已申请的内存虽然会分配地址空间，但并不会直接占用物理内存，真正使用的时候才会映射到实际的物理内存，所以committed &gt;= res。Java Heap：堆内存，一般它的reserved等于-Xmx设置的值，committed等于-Xms设置的值。Class：加载的类与方法信息。其实就是 metaspace，包含两部分： 一是metadata，被-XX:MaxMetaspaceSize限制最大大小，另外是 classspace，被-XX:CompressedClassSpaceSize限制最大大小。Thread：线程占用的内存，每个线程栈占用大小受-Xss限制，默认是1MB左右，但是总大小没有限制。Code：JIT 即时编译后（C1 C2 编译器优化）的代码占用内存，受-XX:ReservedCodeCacheSize限制。GC：垃圾回收占用内存，例如垃圾回收需要的 CardTable，标记数，区域划分记录，还有标记 GC Root等等，都需要内存。这个不受限制，一般不会很大的。Parallel GC 不会占什么内存，G1 最多会占堆内存 10%左右额外内存，ZGC 会最多会占堆内存 15~20%左右额外内存，但是这些都在不断优化。（注意，不是占用堆的内存，而是大小和堆内存里面对象占用情况相关）。Internal：命令行解析，JVMTI 使用的内存，这个不受限制，一般不会很大的。Symbol：常量池占用的大小，字符串常量池受-XX:StringTableSize个数限制，总内存大小不受限制。Native Memory Tracking：内存采集本身占用的内存大小，如果没有打开采集（那就看不到这个了）。 在程序启动时查看一次，运行一段时间后再查看一次，对比之后就知道是哪块内存在增长了，然后有针对性的去优化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df2bdc381dac25d2f77dedd79a8254d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f7ccb99a7656b49f203a1a47695323b/" rel="bookmark">
			Win10彻底删除OneDrive的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、删除程序
方法一：
运行中win+R输入 %LocalAppData%\Microsoft\OneDrive\ ，查看版本号。运行cmd 命令，输入 %LocalAppData%\Microsoft\OneDrive\版本号\OneDriveSetup /uninstall。这个命令可以卸载掉大多的OneDrive程序，剩余的可以自行删除
方法二：
先在进程中关闭掉相应的onedrive进程，然后运行中输入 %LocalAppData%\Microsoft\OneDrive ，获取权限后删除这个文件夹,可以使用腾讯管家里面的文件粉碎功能,可直接删除整个文件夹
二、删除导航栏
卸载OneDrive是不能清除导航栏里面的OneDrive，进入注册表，定位到 HKEY_CLASSES_ROOT\CLSID\{018D5C66-4533-4307-9B53-224DE2ED1FE6}\ShellFolder
，把右侧的 Attributes 属性的值 f080004d 修改为 f090004d，任务管理器中重启资源管理器后就生效了
如果需要删除另存为中的OneDrive，需要定位到注册表 HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\ 中，删除{018D5C66-4533-4307-9B53-224DE2ED1FE6}项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fbb327be1b5ca22b71d4de3ac5e9cc5/" rel="bookmark">
			左连接的表中有多条数据如何只取一条(最大或最小)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表a,有字段id,表b有字段cid,create_time,a表中的id对应b表中的cid,a表左连接b表，现在a中一条数据对应b中多条数据,如何只取b表中create_time最大的一条 ?
CREATE TABLE a (id INT);
CREATE TABLE B (cid INT, create_timeDATETIME);
INSERT INTO a SELECT 1 UNION SELECT 2;
INSERT INTO b SELECT 1,'2010-10-01'
UNION SELECT 1,'2010-10-02'
UNION SELECT 2,'2010-10-01'
UNION SELECT 2,'2010-10-02'
UNION SELECT 2,'2010-10-03';
SELECT * FROM a LEFT JOIN (SELECT MAX(create_time)AS create_time,cid FROM b GROUP BY cid) b1
ON b1.cid = a.id;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28f6173dee9ca0a96cc3a834dc491291/" rel="bookmark">
			linux编写简单脚本启动tomcat服务,以及设置开机自启动tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步:
新建一个shell脚本,命名为tomcat8.5.sh vi tomcat8.5.sh
第二步:
编写shell脚本:
#!/bin/bash
#指定tomcat路径
export TOMCAT_HOME=/usr/wangjian/software/tomcat/apache-tomcat-8.5.50
#获取到进程id
PID=$(ps x|grep $TOMCAT_HOME|grep -v grep|awk '{printf $1}')
if [ $? -eq 0 ]; then
echo "---------process id(进程id):$PID"
echo "---------begin to kill the pid(开始杀进程)---------"
kill -9 $PID
if [ $? -eq 0 ];then
echo "---------kill $TOMCAT_HOME success(成功杀死进程)---------"
else
echo "---------kill $input1 fail(杀死进程失败，可能该进程不存在)---------"
fi
else
echo "---------process $input1 not exit(该进程不存在)---------"
exit
fi
echo "---------等待tomcat被关闭,2秒后重新启动Tomcat服务---------"
#等待2秒
sleep 2s
echo "---------开始启动Tomcat服务---------"
$TOMCAT_HOME/bin/startup.sh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28f6173dee9ca0a96cc3a834dc491291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07a2156eb56988cf8fa78552024c8cb/" rel="bookmark">
			根据不同的接口编码调用对应的实现类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、枚举类
public enum TestEnums { C00001("接口A","com.xxx.impl.CodeProcessorImplA"), C00002("接口B","com.xxx.impl.CodeProcessorImplB"); private final String desc; private final String className; TestEnums(String desc, String className) { this.desc = desc; this.className = className; } public String getDesc() { return desc; } public String getClassName() { return className; } } 2、编码接收层Service
public interface CodeReceiverService { String process(String code); } 3、编码接收层Impl
import org.springframework.beans.factory.annotation.Autowired; @Service public class CodeReceiverServiceImpl implements CodeReceiverService { @Autowired private ServiceFactory serviceFactory; @Override public String process(String code) { TestEnums testEnums = TestEnums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a07a2156eb56988cf8fa78552024c8cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd908985a31c79eaf2f2630a7234193/" rel="bookmark">
			windows10没有Hyper-V的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为项目原因,需要在自己的笔记本上安装个docker,百度之后教程发现,家庭版居然没有Hyper-V,而我也不想去升级成专业版,主要是懒得去升,那就只好再去想其他办法了.以下是我的解决办法:
pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 1.新建一个文本文档,讲上面的内容复制进去,然后将文件保存为cmd后缀,比如Hyper-V.cmd
2.右键文件夹,然后选择以管理员身份运行
3.在最末处输入：Y，电脑自动重启，进行配置更新
4.配置更新重启完成以后，我们去控制面板、所有控制面板项、程序和功能，点击启用或关闭Windows功能，就会发现我们已经有了Hyper-v功能,并且已经自动勾选了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f037b2bb00e6b73c290b7cd8fbc97d3/" rel="bookmark">
			MyEclipse提示键配置、提示快捷键、提示背景色、关键字颜色、代码显示、编辑框背景色等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、提示键配置
一般默认情况下，Eclipse ，MyEclipse 的代码提示功能是比Microsoft Visual Studio的差很多的
，主要是Eclipse ，MyEclipse本身有很多选项是默认关闭的，要开发者自己去手动配置。如果开发
者不清楚的话，就不知道Eclipse ，MyEclipse的代码提示功能一样能像Microsoft Visual Studio的
代码提 示功能一样强大。
先举个简单的例子说明问题所在，例如在Eclipse ，MyEclipse代码里面，打个foreach，switch等
这些，是无法得到代码提示的（不信自己试试），其他的就更不用说了，而在Microsoft Visual
Studio 里面是得到非常友好的代码提示的。实际上，Eclipse ，MyEclipse代码里面的代码提示功能
默认的一般 是点“.”，一般是有了点“.”，才会有代码提示。
原理：“Auto Activation triggers for java”这个选项就是指触发代码提示的的选项，把“.”
改成“.abcdefghijklmnopqrstuvwxyz(,”的意思，就是指遇到26个字母和.，（这些符号就触发
代码提 示功能了。增强Eclipse，MyEclipse 的代码提示功能，具体怎么样来配置？
下面开始说步骤：
1. 打开MyEclipse ，然后“window”→“Preferences”
2. 选择“java”，展开，“Editor”，选择“Content Assist”。
3. 选择“Content Assist”，然后看到右边，右边的“Auto-Activation”下面的“Auto Activation triggers for java”这个选项。其实就是指触发代码提示的就是“.”这个符号.
4. “Auto Activation triggers for java”这个选项，在“.”后加abc字母，方便后面的查找修改。然后“apply”，点击“OK”。
5. 然后，任意选择个项目“File”→“Export”，在弹出的窗口中选择“Perferences”，点击“下一步”。
6. 选择导出文件路径，本人导出到桌面，输入“test”作为文件名，点击“保存”。
7. 在桌面找到刚在保存的文件“test.epf”,右键选择“用记事本打开”。
8. 可以看到很多配置MyEclipse 的信息
9. 按“ctrl + F”快捷键，输入“.abc”，点击“查找下一个”。
10. 查找到“.abc”的配置信息.
11. 把“.abc”改成“.abcdefghijklmnopqrstuvwxyz(,”，保存，关闭“test.epf”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f037b2bb00e6b73c290b7cd8fbc97d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3daf641dfe90616601fb135934a2c5cd/" rel="bookmark">
			【记录】算法 - 算法基础c&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础算法 （1）排序 快速排序 void quick_sort(int q[], int l, int r){ if(l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];// 以中间为分界点 while(i &lt; j){ do i++; while(q[i] &lt; x);// 找到第一个&gt;=x的数 do j--; while(q[j] &gt; x);// 找到第一个&lt;=x的数 if(i &lt; j) swap(q[i], q[j]); } // (l, i)为&lt;=x的数，(j, r)为&gt;=x的数 // quick_sort(q, l, i - 1), quick_sort(q, i, r);// 注意x=q[l]存在边界问题，死循环 quick_sort(q, l, j), quick_sort(q, j+1, r);// 注意x=q[r]存在边界问题，死循环 } // AcWing 786.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3daf641dfe90616601fb135934a2c5cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dacf602a768273cf6e7699e00a5cb1f/" rel="bookmark">
			FastDFS-5.11安装配置指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。 FastDFS由跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)构成。 2、基础环境
3、 依赖安装 yum install gcc-c++ pcre pcre-devel openssl ssl-devel perl-devel -y
安装FastDFS依赖包libfastcommon
cd /usr/local/src
wget https://github.com/happyfish100/libfastcommon/archive/V1.0.38.tar.gz tar xf V1.0.38.tar.gz cd libfastcommon-1.0.38/
./make.sh
./make.sh install
4、组件编译安装 安装FastDFS cd /usr/local/src
wget https://github.com/happyfish100/fastdfs/archive/V5.11.tar.gz
tar -zxvf V5.11.tar.gz
cd fastdfs-5.11/
./make.sh
.make.sh install
5、系统配置 将配置文件复制到系统为fdfs预设的目录
cd /usr/local/src/fastdfs-5.11/conf
cp mime.types http.conf /etc/fdfs/
#查看安装FastDFS过程中产生的可执行文件。
ls -la /usr/bin/fdfs*
配置FastDFS 分别对tracker，storage，client进行配置。 创建目录
mkdir /home/fastdfs/tracker -p
mkdir /home/fastdfs/storage -p
cd /etc/fdfs/
配置tracker cp tracker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dacf602a768273cf6e7699e00a5cb1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4e7804bbd6a98fcff275ff5be9756b/" rel="bookmark">
			Springboot框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是spring boot框架
Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程 . 理解:spring框架搭建的步骤:[1]依赖 [2]配置文件。 使用springboot可以简化上面的两个步骤。
2.spring boot的特点
（1）创建独立的Spring应用程序
（2）嵌入的Tomcat，无需部署WAR文件
（3）简化Maven配置
（4）自动配置Spring
（5）提供生产就绪型功能，如指标，健康检查和外部配置
（6）开箱即用，没有代码生成，也无需XML配置
3.快速搭建Springboot工程
点击完成后创建。
运行测试：创建一个controller包
@RestController //该类种所有方法的返回都是json格式 public class testController { @GetMapping("ctrl") public Map&lt;String, Object&gt; ctrl() { HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("name", "ctrl"); map.put("hobby1", "c"); map.put("hobby2", "t"); map.put("hobby3", "r"); map.put("hobby4", "l"); return map; } } 运行结果：
4.Spring boot常用的配置文件类型
properties和yml格式。他们的区别就是格式上不同。
properties格式（全路径配置，更直观）：
yml格式（简化路径配置，更简约）：
注：使用yml格式时一定要注意冒号后面有一个空格！！！！！
注：不管使用哪个配置文件，他们的名字必须叫application. 如果上面两个配置文件同时存在，而且里面有相同的配置。则properties优先级高于yml优先级。
5.Java如何读取配置文件里的内容
java为什么需要读取配置文件的内容，我们开发时需要把哪些内容放入配置文件。
OSS:上传文件。accessKeyId,accessKeySecret等，这些内容能写在java源代码中。硬编码文件，不利维护。 我们需要把信息写入配置文件。
读取方式有两种:
第一种方式: 在类上@ConfigurationProperties(prefix="")
@Data
@Component
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a4e7804bbd6a98fcff275ff5be9756b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de186cfe37d528c5737c3de370eaab16/" rel="bookmark">
			Ubuntu网络突然断开（无网络图标）解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先停掉网络(root用户下) service network-manager stop 查看网络状态 gedit /var/lib/NetworkManager/NetworkManager.state 这里主要观察NetworkingEnable=true ，如果为false ，就修改成true并保存
3. 重新开启网络服务
service network-manager start 网络就有用了，并且右上角的网络图标也出现了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e35e743270ff7fbc81204c06f366d422/" rel="bookmark">
			chatgpt平替，清华chatglm本地化部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGLM-6B 是一个开源的、支持中英双语的对话语言模型，基于 General Language Model (GLM) 架构，具有 62 亿参数。因为我的cpu跑不了，在linux服务器端进行部署。前提是conda已经安装并配置好，因为我的已经搞好，就不是从最初开始，但是网上有很多配置方法，操作起来也不是太难。
这里提供一些其他博主的安装和配置方法;
https://blog.csdn.net/KRISNAT/article/details/124041869#1_Anconda_1
硬件需求：
下载代码：
git clone https://github.com/THUDM/ChatGLM-6B.git
使用anaconda创建虚拟环境
pip install -r requirements.txt
启动命令：
python cli_demo.py
最终会显示命令行中进行交互式的对话，在命令行输入指示并回车即可生成回复，界面如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918ba09783684479dfdef0bc14450a63/" rel="bookmark">
			Python实验——tkinter 电子时钟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验说明： 编写程序,实现如下图所示的电子时钟。要求：
（1）不显示标题栏，总是顶端显示，不被其他窗口覆盖；
（2）实时显示日期和时间；
（3）可以用鼠标左键按住拖动，在电子时钟上右击可以结束程序；
（4）拖动时透明度变大，鼠标左键抬起时恢复半透明状态
时钟如下图所示 import tkinter as tk import time #定义一个名为Clock的类，继承自tk.Tk类。 class Clock(tk.Tk): #定义Clock类的构造函数 def __init__(self): #调用父类tk.Tk的构造函数，创建一个窗口。 super().__init__() self.overrideredirect(True) # 不显示标题栏 self.attributes('-topmost', True) # 总是顶端显示 self.geometry("+0+0") # 初始位置为屏幕左上角 self.bind("&lt;Button-1&gt;", self.start_move) self.bind("&lt;ButtonRelease-1&gt;", self.stop_move) self.bind("&lt;B1-Motion&gt;", self.on_motion) self.bind("&lt;Button-3&gt;", self.quit) self.opacity = 0.3 # 初始透明度 self.attributes("-alpha", self.opacity) self.label = tk.Label(self, font=('Courier', 40, 'bold')) self.label.pack() self.update_clock() #用于更新时钟 def update_clock(self): now = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) self.label.configure(text=now) self.after(1000, self.update_clock) #处理窗口的鼠标左键单击事件 def start_move(self, event): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/918ba09783684479dfdef0bc14450a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f69f9b218f1a56b2ebeb0306338bc0f1/" rel="bookmark">
			Idea中的NexChatGPT如何使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照下面的截图一步一步来就可以的
打开settings
找到Plugins，搜索nex，出现NexChatGpt,点击Installed
安装好了之后点击右上方设置图标，点击HTTP Proxy Settings...
勾选Auto-detect proxy settings,点击OK
切记先点击Apply，在点击OK（我总是会忽略Apply）
以上操作完成之后，在最右侧边框会发现多出一个NexChatGPT
点击之后会弹出一个搜索框，有什么问题可以在里面直接搜索，非常方便而且会直接提供代码的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f036516262bf150503aabc1e1eca69/" rel="bookmark">
			分享57个Python源码，总有一款适合您
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python源码
分享57个Python源码，总有一款适合您
57个Python源码下载链接：https://pan.baidu.com/s/1YZcrJAYFFy3OrdEN5IxnQQ?pwd=6666
提取码：6666
下面是文件的名字，我放了一些图片，文章里不是所有的图主要是放不下...，大家下载后可以看到。
参数代码 base_url = "https://down.chinaz.com" # 采集的网址 save_path = "D:\\Freedom\\Sprider\\ChinaZ\\" sprider_count = 88 # 采集数量 sprider_start_count=0# 从第几个序号开始 直接改数量即可 会做除法操作正 正在采集第32页的第16个资源 debug word_content_list = [] folder_name = "" page_end_number=0 max_pager=15 #每页的数量 haved_sprider_count =0 # 已经采集的数量 page_count = 1 # 每个栏目开始业务content="text/html; charset=gb2312" 核心代码 def sprider(self,title_name="NET"): """ 采集 PHP https://down.chinaz.com/class/572_5_1.htm NET https://down.chinaz.com/class/572_4_1.htm ASP https://down.chinaz.com/class/572_3_1.htm Pytyhon https://down.chinaz.com/class/604_572_1.htm :return: """ if title_name == "PHP": self.folder_name = "PHP源码" self.second_column_name = "572_5" elif title_name == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4f036516262bf150503aabc1e1eca69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ef146e6ac25c5b2da71a99c6890c20/" rel="bookmark">
			关于解决Vue.config.productionTip=false控制台的提示没消失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上图说话！
存在的问题如下：
Vue.config.productionTip=false控制台的提示没消失
解决办法： A.原Vue.js源码：
原来源码：productionTip=true//367行B.修改后：
productionTip=false//367行
原因分析：
在最新版本的Chrome中，在script中使用settimeout，由于是异步的，无法确定settimeout的内容先执行还是script 中productionTip=false，先执行？所以干脆把productionTip=true改为fasle！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a80c3088e77e88979c3cb8198b25c39/" rel="bookmark">
			申请微软E5开发者账号，白嫖微软OneDrive 5T存储空间和Office356教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上次发布了一篇自建 Cloudreve 的文章，存储策略就支持 OneDrive，目前用的是世纪互联的无限存储收费套餐，如果想白嫖的话，不妨看看 Office 365 E5，针对开发人员推出的，重要是免费使用，所以申请微软的 E5 开发者账号，就可以获得免费的 office 365（可用于激活 office）和 OneDrive 5T 的存储空间，用在 Cloudreve 上岂不是美滋滋？白嫖真香！
介绍 申请 Office365 E5 开发者订阅获取免费的 Microsoft 365 E5 开发人员订阅，借助沙盒订阅，你可以做自己的管理员并构建应用和解决方案的原型。包括 25 个用于开发目的的用户许可证 访问核心 Microsoft 365 工作负载和功能（不包括 Windows），包括：所有 Office 365 应用，包括 SharePoint、OneDrive、Outlook/Exchange、Teams、Planner、Word、Excel、PowerPoint 等 Office 365 高级威胁防护 Power BI 高级分析 用于合规性和信息保护的企业移动性 + 安全性 (EMS) 用于构建高级标识和访问管理解决方案的 Azure Active Directory
教程 在此之前建议你先准备以下工具：
推荐使用 edge/Google 浏览器建议开启无痕模式（Ctrl+Shift+N）魔法 一、注册 Microsoft 365 1、微软开发人员计划网址：Developer Program | Microsoft 365 Dev Center
2、创建一个新的微软账号，不建议使用自己电脑的账户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a80c3088e77e88979c3cb8198b25c39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95cf461c6af035d529bfcaca38d38a0b/" rel="bookmark">
			ios逆向工具有那些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一些常用的 iOS 逆向工具：
Cycript：一种用于在运行时动态分析和修改 iOS 应用程序的强大工具，可以与应用程序进行交互式调试和注入代码。
Frida：一个强大的动态二进制插桩工具，可以在运行时修改应用程序的行为，支持 iOS 和 Android 平台。
Hopper：一种反汇编器和逆向工程工具，可以将 Mach-O 文件转换为易于理解的汇编代码。
IDA Pro：一个强大的反汇编器和调试器，可用于分析 iOS 应用程序的二进制代码。
class-dump：一种用于从 iOS 应用程序二进制文件中提取 Objective-C 类和方法信息的工具。
Clutch：一种可以将 iOS 应用程序进行加密、去壳和导出的工具，使得逆向工程变得更加容易。
iRET：一种用于自动化 iOS 应用程序逆向工程的工具，可以提供包括类、方法、属性和协议的详细信息。
GDB：一种常用的调试器，可以用于调试 iOS 应用程序的二进制代码。
LLDB：一种新一代的调试器，可以用于调试 iOS 应用程序的二进制代码，提供了比 GDB 更好的性能和易用性。
以上是一些常用的 iOS 逆向工具，但请注意，在进行逆向工程活动时，必须遵守相关法律和道德规范，否则可能会遭受法律后果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95649d37c7372e559089f26fa0ce6790/" rel="bookmark">
			从零基础学微信小程序 二（超级详细的注释-签到打卡项目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、微信小程序签到打卡项目的实现方法 1. 创建小程序首先，我们需要在微信公众平台上创建一个小程序。在创建小程序的过程中，需要填写小程序的基本信息，如小程序名称、小程序类型、小程序描述等。创建完成后，我们需要在小程序后台进行配置，包括设置小程序的页面、导航栏、底部菜单等。
2. 实现签到打卡功能在小程序中实现签到打卡功能，需要用到微信小程序的API接口。我们可以通过调用微信小程序的API接口，获取用户的位置信息、时间信息等，从而实现签到打卡功能。
二 、 接下我们将进行实战教学 这个是实战效果图（本人承认没有美术天赋） wxml页面 这里view里面我不建议用style的样式，这里是因为我喜欢偷懒才在这里写 这里可以在wxss里面写id属性或者class属性来实现具体看下面 这个要注意的点是class属性是在wxss中是用点（.）来实现的 wxss页面 由于考虑到可能有新手第一次接触微信小程序没有基础哦，我这里会重点说明几个上面的样式的作用 flex的布局 flex是现在市面上主流一种布局方式，display:flex; js页面 这里用到了云开发知识在下一篇会具体介绍到
总结 以上就是今天的学习内容啦~
咱们下期再见老铁~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ceb9a31ec882476d3cd96c0d70af777/" rel="bookmark">
			Nuxt3 &#43; Naive UI 的SSG项目分享（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建Nuxt3项目分享 Nuxt3 自从Vue3发布后，学习Vue3就形成了一个趋势和热潮。
Vue3相比Vue2，引入tree-shaking，使得打包的整体体积变小了；在兼顾vue2的options API的同时还推出了composition API，大大增加了代码的逻辑组织和代码复用能力；采用proxy替换了之前的defineProperty，proxy有多达13种拦截方法；增加了TypeScript支持来对项目的规范做更进一步的约束等等。
Nuxt3 就是基于 Vue3 来做的一款混合式 Vue框架。
我们可以用Nuxt3来开发服务端渲染的项目，也就是常说的ssr；
SPA SPA（单页面应用），只有一个HTML页面，通过路由实现页面内的局部切换，公共资源部分只加载一次。而Vue框架所开发的项目就属于SPA项目。
平常写的普通页面就是MPA（多页面应用），通过a标签实现页面切换，每次切换页面都要重新加载公共资源部分。
优点 1.无刷新界面，内容的改变不需要重新加载整个页面，良好的交互体验；
2.基于spa这一点，减轻服务器压力，吞吐能力会提高几倍；
3.前后端工作分离模式；
缺点 1.首屏加载慢，业务随着代码量增加而增加，不利于首屏优化；
2.各个浏览器的版本兼容性不一样；
3.不利于seo，即搜索引擎抓取内容非常少；
4.页面复杂度提高；
SPA（单页面应用） 既有它的优点也有它的缺点，我们只能根据我们开发项目的业务的实际需求来进行酌情取舍。
对于SPA（单页面应用） 的首屏加载慢，我们可以采取的一些常见措施：
1.减少入口文件体积
2.静态资源本地缓存以及一些资源的压缩处理
3.UI组件按需加载
4.避免重复加载组件
5.开启gzip压缩
6.使用SSR
而SSR也就是我们所说的服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器。关于Vue项目的SSR，Vue3官网有给出一些解决方案：更通用的解决方案
而这里分享，我们则采用Nuxt3框架，它是一个构建于 Vue 生态系统之上的全栈框架，为编写 Vue SSR 应用提供开发，同时还可以把它当作一个静态站点生成器来用。
CSR 与 SSR 渲染分为客户端渲染（CSR）和服务端渲染（SSR）。
CSR CSR（client side render） 服务端只提供json格式的数据，渲染成什么样子由客户端通过JavaScript控制，而SPA的Vue项目则就是这种CSR（client side render） 客户端渲染。
&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;link rel="icon" href="/favicon.ico" /&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt; &lt;title&gt;后台管理系统&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;很抱歉，在没有启用JavaScript的情况下，默认不能正常工作&lt;/strong&gt; &lt;/noscript&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ceb9a31ec882476d3cd96c0d70af777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4221f1fecd6c44e1c6faa5b38d9487d9/" rel="bookmark">
			K8s解决Namespace迟迟不可以删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题再现 kubectl get ns kubectl get ns 二、问题的方案 方案一： #kubectl delete ns 命名空间的名字 --force --grace-period=0 kubectl delete ns dev --force --grace-period=0 方案二： 上述命令依然不行，出现如图所示，依旧在等待
使用以上命令均无法成功删除命名空间，只会使命名空间的状态为Terminating状态
1）使用命令 #kubectl get namespace 命名空间的名字 -o json &gt; devtesting.json kubectl get namespace dev -o json &gt; devtesting.json 2）文件修改 执行完这条命令后，当前文件夹会出现devtesting.json这个文件夹，打开这个文件，删除字段spec和finalizers这两个字段包含的内容。
3）使用kubectl命令 kubectl proxy --port=8080 打开新的命名窗口
curl http://localhost:8080/api/ 4）使用http接口进行删除 #curl -k -H "Content-Type: application/json" -X PUT --data-binary @devtesting.json http://127.0.0.1:8080/api/v1/namespaces/命名空间的名字/finalize curl -k -H "Content-Type: application/json" -X PUT --data-binary @devtesting.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4221f1fecd6c44e1c6faa5b38d9487d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2144deb8468650935edbac08b37e7fd/" rel="bookmark">
			Python 基于csv 读取文本文件提示：‘gbk‘ codec can‘t decode byte 0xbf in position 2: illegal multibyte sequence
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错 Python 基于csv 读取文本文件提示：‘gbk‘ codec can‘t decode byte 0xbf in position 2: illegal multibyte sequence
分析 错误大致意思：Unicode的解码（Decode）出现错误（Error）了，以gbk编码的方式去解码（该字符串变成Unicode），但是此处通过gbk的方式，却无法解码（can’t decode ）。“illegal multibyte sequence”意思是非法的多字节序列，即没法（解码）了。
解决 方法一：修改encoding方式，忽略错误
这里gb18030是比gbk更高级的方式，包含更多符号。编码方式还有"UTF-8"等。
csv_reader = csv.reader(open(data_path,'r' ,encoding='gb18030',errors='ignore')) csv_reader = csv.reader(open(data_path,'r' ,encoding='UTF-8',errors='ignore')) 我这里的背景是：通过excel将文件保存为csv格式，但读取时出错。使用第一种方法以后仍然报错，于是通过
res=[row for row in csv_reader] print(res) 检查变量的具体错误，发现是第一个变量开头多了乱码。此时可以将该变量替换，比如
res[0][0] = res[0][0].split('\ufeff')[-1]##直接从excel保存成csv会有字符读取错误，可复制到txt文件中再改后缀名为csv 或者采用第二种方法。
方法二：新建txt文档，将excel保存生成的.csv文件以记事本方式打开，ctrl+A复制所有内容到新建的txt文档中，再将txt文档的后缀名修改为.csv，这样就不会产生乱码了。
这里的区别是，之前那个excel保存的.csv文件用记事本打开时，右下方会显示“带BOM的UTF-8”，而新建txt文档再改后缀名的方式生成的.csv文件用记事本打开后右下角显示“UTF-8”，不会有“带BOM”几个字。推测应该是BOM的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4541b935f63905198370c8ad6a2c2f/" rel="bookmark">
			Linux命令·ifconfig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多windows非常熟悉ipconfig命令行工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有一个类似的工具，也就是ifconfig(interfaces config)。通常需要以root身份登录或使用sudo以便在Linux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息，还可以修改这些配置。
1．命令格式：
ifconfig [网络设备] [参数]
2．命令功能：
ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。
3．命令参数：
up 启动指定网络设备/网卡。
down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。
arp 设置指定网卡是否支持ARP协议。
-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包
-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包
-a 显示全部接口信息
-s 显示摘要信息（类似于 netstat -i）
add 给指定网卡配置IPv6地址
del 删除指定网卡的IPv6地址
&lt;硬件地址&gt; 配置网卡最大的传输单元
mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)
netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。
tunel 建立隧道
dstaddr 设定一个远端地址，建立点对点通信
-broadcast&lt;地址&gt; 为指定网卡设置广播协议
-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议
multicast 为网卡设置组播标志
address 为网卡设置IPv4地址
txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度
4．使用实例：
实例1：显示网络设备信息（激活状态的）
命令：
ifconfig
输出：
[root@localhost ~]# ifconfig
eth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:20 inet addr:192.168.120.204 Bcast:192.168.120.255 Mask:255.255.255.0
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d4541b935f63905198370c8ad6a2c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d85132c44410133cc1669cf1e2438c/" rel="bookmark">
			C&#43;&#43; : class 类与对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.对象
2.类的引入
3.class类的定义
4.类的访问限定符
5.类的实例化
1.对象 C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题、
C++是基于面向对象的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成。
eg：一杯奶茶如何制作。
在面向过程中，从杯子，接水，加奶加珍珠等一步一步完成的步骤。就是逐步解决问题、
在面向对象中，只关注，买奶茶的人，卖奶茶的店员，这些对象之间的交互完成。
2.类的引入 在C语言中，struct 结构体 可以定义变量，我们用它实现数据结构的一些操作。
而在C++中，struct 结构体不仅仅可以定义变量，还可以定义函数。
#include&lt;iostream&gt; using namespace std; struct A { int a; double b; } struct B { int add(int a,int b) { return a+b; } int a; int b; } int main() { B b; int c = b.add(1,1); return 0; } 3.class类的定义 class className { // 类体：由成员函数和成员变量组成 }; // 一定要注意后面的分号 class为定义类的关键字，ClassName为类的名字，{}中为类的主体，注意类定义结束时后面分号不能省略。
类体中内容称为类的成员：类中的变量称为类的属性或成员变量; 类中的函数称为类的方法或者成员函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2d85132c44410133cc1669cf1e2438c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c5999a06eba8a586c2d66f87533c576/" rel="bookmark">
			SQLmap使用方法，sqli-labs靶场
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 需要的环境：Kali Linux、sql-labs靶场
需要有 phpstudy 或者其他集成环境
简介 SQL-map是一个非常强大的注入的工具，自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL进行SQL注入，支持mysql、sql-service 等
必备知识点： --dbs查看所有的数据库-D 指定数据库-T --tables查看数据表-C --dump查看字段（用逗号隔开） 开始实验： 打开我们的sql靶场
查看数据库 sqlmap -u 'http://10.23.1.172:88/Less-1/?id=1' --dbs 选择数据库 sqlmap -u 'http://10.23.1.172:88/Less-1/?id=1' -D security --tables 选择数据表 sqlmap -u "http://10.23.1.172:88/Less-1/?id=1" -D security -T users --columns 查看数据字段 id password username sqlmap -u "http://10.23.1.172:88/Less-1/?id=1" -D security -T users -C id,password,uaername --dump 看到里面的所有东西，完成实验
总结 简单使用nmap进行查询数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e997bc7a836b4c5ac651f4a86473880e/" rel="bookmark">
			内网穿透加nginx 实现一条隧道部署前后端项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，通过内网穿透可以快速部署前后端项目需要两条隧道：
比如说启动前端项目-8080端口 绑定一条隧道；启动后端项目-8181端口 绑定一条隧道；
但是使用隧道绑定nginx服务器ip、端口的话，通过反向代理，可以实现前后端项目部署：流程如下
公网ip
隧道绑定nginx的ip/端口：
nginx代理配置 （类似nginx.conf文件配置）:
前端：
后端：
通过docker容器中的nginx启动前后端，
效果：使用分配的公网访问，可以看到前端项目已部署完成
且后端接口地址也被反向代理
使用的穿透工具： http://console.http01.cn/#/tunnel
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f8a5954be3bd2238c3b87bb558277b8/" rel="bookmark">
			C&#43;&#43; ： auto关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提引入:
1.类型名，在绝大多数编程时，我们都会引入类型来定义一个我们需要的数据。
类型众多，偶尔我们会遇见一串类型名，使用起来无比复杂。存在拼写错误，含义不明确导致出错的问题。
列如:
std::map&lt;std::string, std::string&gt; m{ { "apple", "苹果" }, { "orange", "橙子" }, {"pear","梨"} }; std::map&lt;std::string, std::string&gt;::iterator it = m.begin(); 在这串代码中，std::map&lt;std::string, std::string&gt;::iterator 是一个类型，但是该类型太长了，特别容易写错。如何简化呢。
在C中，typedef 作为一个可以取别名的一个关键字。确实可以省事许多，却任然存在缺陷。
typedef std::map&lt;std::string, std::string&gt; Map; 若 typedef 为指针取了别名。存在小问题。
typedef char* pstring; int main() { const pstring p1; // 编译成功还是失败？ const pstring* p2; // 编译成功还是失败？ return 0; } C++是怎么做的呢，设计师为了不想写复杂的类型，引入了auto关键字。
auto ：
1.在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量
2.C++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得
注：既然auto作为推导而得，在使用auto时，必须初始化。
auto 的使用场景
1. auto 在推导指针是，不必再加*号；
2.auto在使用引用时，必须遵循规则加上&amp;号；
3.不能作为函数的参数使用
4.不能直接用来声明数组。
5.一行多个数据推导必须同类型。
int main() { //1 int x = 10; auto a = &amp;x; auto* b = &amp;x; auto&amp; c = x; cout &lt;&lt; typeid(a).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f8a5954be3bd2238c3b87bb558277b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cfb6d9811b139830078f8c599ff64d5/" rel="bookmark">
			基于k8s&#43;prometheus实现双vip可监控Web高可用集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、规划整个项目的拓扑结构和项目的思维导图
二、修改好各个主机的主机名，并配置好每台机器的ip地址、网关和dns等
2.1修改每个主机的ip地址和主机名
2.2 关闭firewalld和selinux
三、使用k8s实现Web集群部署，实现1个master和3个node节点的k8s集群
3.1在k8s集群那4台服务器上安装好docker，这里根据官方文档进行安装
3.2 创建k8s集群，这里采用 kubeadm方式安装
3.2.1 确认docker已经安装好，启动docker，并且设置开机启动
3.2.2 配置 Docker使用systemd作为默认Cgroup驱动
3.2.3 关闭swap分区
3.2.4 修改hosts文件，和内核会读取的参数文件
3.2.5 安装kubeadm,kubelet和kubectl
3.2.6 部署Kubernetes Master
3.2.7 node节点服务器加入k8s集群
3.2.8 安装网络插件flannel(在master节点执行)
3.2.9 查看集群状态
四、编译安装nginx，制作自己的镜像
4.1建立一个一键安装nginx的脚本
4.2建立一个Dockerfile文件
五、创建NFS服务器为所有的节点提供相同Web数据，结合使用pv+pvc和卷挂载，保障数据的一致性
5.2在nfs-server服务器和4台k8s集群服务器上都安装好软件包
5.2在nfs-server服务器上创建共享文件的目录并创建共享文件
5.3在master服务器上创建pv
5.4在master服务器上创建pvc使用pv
5.5在master服务器上创建pod使用pvc
5.6创建一个service发布
5.7验证结果
六、使用Nginx+keepalived实现双VIP负载均衡高可用
6.1实现负载均衡功能 6.1.1编译一键安装nginx的脚本
6.1.2配置nginx里的负载均衡功能
6.1.3查看效果
6.1.4 查看负载均衡的分配情况
6.2用keepalived实现高可用
6.2.1 安装keepalived
6.2.2配置keepalived.conf文件
6.2.3 重启keepalived服务
6.2.4 测试访问
6.3压力测试
6.4 尝试优化整个web集群
七、使用Prometheus实现对k8s集群的监控，结合Grafana成图工具进行数据展示
7.1 搭建prometheus监控k8s集群
7.1.1 采用daemonset方式部署node-exporter
7.1.2 部署Prometheus
7.1.3 测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cfb6d9811b139830078f8c599ff64d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ab0997a6a9a7084227279cb7845817/" rel="bookmark">
			Linux文件去掉每行末尾^M
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下去掉^M的四种方法_linux shell_脚本之家
参考了上面的博客
cat -A filename 就可以看到windows下的断元字符 ^M（我用的是vi filename，也可以看到^M）
要去除^N，最简单用下面的命令：
dos2unix filename
（如果没有安装，直接使用 sudo apt install dos2unix 安装即可）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38cd664766e14068d9ef53c05a6c89f3/" rel="bookmark">
			机器学习实战——多模型实现预测功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、数据准备1.1 数据下载1.2 数据格式转换1.3 数据拆分 二、模型构建2.1 K近邻2.2 决策树与随机森林2.3 多层感知器 前言 大家好✨，这里是bio🦖。
机器学习方法已经应用到日常生活的方方面面。从自动推荐看什么电影、点什么食物、买什么商品，到个性化的在线电台和从照片中识别好友，许多现代化网站和设备的核心都是机器学习算法。
所以这次给大家带来的是机械学习模型的应用，也可以说是实战。如果你是新手这篇文展的代码将有助于你理解机械学习的应用。观看完本文（主要是代码），你将学习到：
1. 如何构建简单机械学习模型 KNN, Random Forest, Decision Tree and Multilayer Perceptron
2. 如何提高模型的表现
3. 如何对数据进行处理以及可视化展现
一、数据准备 1.1 数据下载 数据来自csdn神州数码集团2022年校园技术大赛，提取码：jc58。数据集包括train数据、test数据以及参考的预测结果格式。train数据包含User ID Gender Age AnnualSalary Purchased，简单来说就是一个二分类的问题，根据用户的性别、年龄、年收入判断用户是否购买车辆🚗。
图一，数据集展示图 1.2 数据格式转换 使用pandas读入训练数据，其展示如图二。其中Gender列包括女性和男性，可以将其从字符转换为数字0和1。
import pandas as pd train_test_data = pd.read_csv('train.csv') display(train_test_data) 图二，训练数据展示图 使用如下代码将male和female转换为0和1。
trans_form = train_test_data['Gender'] trans_form = [1 if i == "Male" else 0 for i in trans_form] train_test_data["Gender"] = trans_form display(train_test_data) 图三，训练数据格式转换展示图 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38cd664766e14068d9ef53c05a6c89f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/063e84d6af4cdc543bad921fe8b88ba6/" rel="bookmark">
			vue3 对元素拖拽、缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件一： 1、安装：npm i vue3-draggable-resizable
2、在main.js中引入：
import Vue3DraggableResizable from 'vue3-draggable-resizable' import 'vue3-draggable-resizable/dist/Vue3DraggableResizable.css' ... app.use(Vue3DraggableResizable); 3、基本用法：（这里举的例子是上传一张图片后，拿到图片的宽高，再给插件的宽高赋值）
&lt;template&gt; &lt;Vue3DraggableResizable :lock-aspect-ratio="true" :handles="['tl', 'tr', 'br', 'bl']" :min-width="100" :min-height="100" :x="insertImgLeft" :y="insertImgTop" :w="insertImgWidth" :h="insertImgHeight" @drag-end="insertDragStop" @resize-end="insertResizeStop" class="drag_box" &gt; &lt;img style="cursor: pointer" :src="insertImg" @load="onImageLoad" /&gt; &lt;/Vue3DraggableResizable&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, onMounted } from "vue"; let insertImg = ref( "https://s3.cn-northwest-1.amazonaws.com.cn/yinlulu-glint/upload/c14624c8-9020-4c37-803b-36ec7e4ace5e.jpg" ); //插图 let insertImgHeight = ref(0); //插图高度 let insertImgWidth = ref(0); //插图宽度 let insertImgLeft = ref(0); //插图坐标 let insertImgTop = ref(105); //插图坐标 // 插图停止拖动 function insertDragStop(e) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/063e84d6af4cdc543bad921fe8b88ba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/572a0b812b1b8b698185554a8ded48d0/" rel="bookmark">
			Linux时钟配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统时间不对可以通过以下三种方法修复 1、将硬件时间同步到系统时间
2、修改系统的时区
3、配置NTP客户端
系统时钟VS硬件时钟 在Linux中有硬件时钟与系统时钟等两种时钟。硬件时钟是指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟。系统时钟则是指kernel中的时钟。当Linux启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有Linux相关指令与函数都是读取系统时钟的设定。
date 查看系统时间
date -s 设置系统时间
hwclock查看硬件时间
hwclock -w 将硬件时间同步到系统时间
Linux系统时钟不对一般为时区设置有误 Centos7查询时区方法
[zyq@zyq ~]$ timedatectl Local time: Tue 2023-01-17 13:56:36 CST Universal time: Tue 2023-01-17 05:56:36 UTC RTC time: Tue 2023-01-17 05:56:36 Time zone: Asia/Shanghai (CST, +0800) NTP enabled: yes NTP synchronized: yes RTC in local TZ: no DST active: n/a Centos6查询方法
cat /etc/sysconfig/clock
如果时区不是Asia/Shanghai,通过修改时区即可修复
时区如果没有问题可通过配置时钟客户端修复
常用的时钟服务器 cn.pool.ntp.org、asia.pool.ntp.org、pool.ntp.org、hk.pool.ntp.org
配置客户端 [zyq@zyq tmp]$ grep server /etc/ntp.conf # Use public servers from the pool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/572a0b812b1b8b698185554a8ded48d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07603c07bbd1bae9bf0712a660aa769f/" rel="bookmark">
			Git使用教程：从入门到精通（以Gitee为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 Git是一款分布式版本控制系统，可以帮助开发者更好地管理代码。在众多的Git平台中，Gitee是国内最受欢迎的Git平台之一。本篇文章将介绍如何使用Git进行代码管理，并以Gitee为例，详细讲解Git的基本操作和常用命令。
二、深入了解Git的基本概念 仓库（Repository）：存放代码的地方，可以理解为一个文件夹。
分支（Branch）：Git中的分支可以让开发者在不影响主分支的情况下进行代码修改和测试。
提交（Commit）：将代码修改保存到本地仓库中。
合并（Merge）：将不同分支的代码合并到一起。
推送（Push）：将本地仓库中的代码推送到远程仓库中。
拉取（Pull）：将远程仓库中的代码拉取到本地仓库中。
三、使用Git 1. 创建一个Gitee账户 首先，我们需要在Gitee上创建一个账户。如果您已经有了一个账户，可以跳过这一步。
2. 创建一个新的仓库 在Gitee上创建一个新的仓库非常简单。只需点击页面右上角的“+”按钮，然后选择“新建仓库”。在弹出的窗口中，输入仓库的名称和描述，然后点击“创建仓库”。
3. 安装Git 在使用Git之前，您需要在本地计算机上安装Git。您可以从Git官网下载适合您操作系统的版本，并按照安装向导进行安装。
https://git-scm.com/download
4. 克隆仓库 在本地计算机上打开Git Bash，然后使用以下命令克隆您在Gitee上创建的仓库：
git clone https://gitee.com/sun-yuhang-bite/python.git 请将“sun-yuhang-bite”和“python.git”替换为您在Gitee上创建的仓库的用户名和仓库名称。
克隆完成
5. 添加文件 在本地计算机上，将您要添加到仓库中的文件放入克隆的仓库文件夹中。然后使用以下命令将文件添加到Git仓库中：
git add . 这将添加所有新文件和修改过的文件。
6. 提交更改 使用以下命令提交更改：
git commit -m "commit message" 请将“commit message”替换为您的提交消息。
7. 推送更改 使用以下命令将更改推送到Gitee上的仓库：
git push origin master 请注意，这将把更改推送到“master”分支。如果您想将更改推送到其他分支，请将“master”替换为您想要推送到的分支名称。
8. 拉取代码 如果您在Gitee上的仓库中进行了更改，您需要使用以下命令将更改拉取到本地计算机上：
git pull origin master 请注意，这将从“master”分支拉取更改。如果您想从其他分支拉取更改，请将“master”替换为您想要拉取的分支名称。
四、Git常用命令 1. 查看当前状态 git status 2. 查看提交历史 git log 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07603c07bbd1bae9bf0712a660aa769f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d3cfe48c778a0a8a1f0320f8c9a877/" rel="bookmark">
			教你们1秒钟复制百度文库中所有内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人经常会上百度搜索资料，结果发现在百度文库那边可以找到，兴奋了半天却发现下载时要币的，或者登陆上去麻烦，又或者限制VIP才能复制下载。针对这种情况，今天给大家带来一个破解百度文库下载的方法，其实非常简单，而且不用下载任何软件。
在这里插入图片描述
打开要复制的文库内容，在浏览器极速模式下点击F12或右键打开审查元素，点击Console，粘贴以下代码然后回车。
var box = document.getElementsByClassName(“ie-fix”);for(var i=0;i&lt;box.length;i++){ console.log(box[i].innerText);} 整篇文档就出现下面粘贴的代码里随便复制了，此方法仅限文字类的文档。 | | 大家喜欢的话多多支持哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21ff1eebbc337633845b8e0c4f8e174/" rel="bookmark">
			使用ceres库时报错:undefined reference to `ceres::Problem::Problem()‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编译cmake项目链接ceres库时名称没有写对导致报错:
myCeres.cpp:(.text.startup+0x247): undefined reference to `ceres::Problem::Problem()' myCeres.cpp:(.text.startup+0x2aa): undefined reference to `ceres::CostFunction::CostFunction()' myCeres.cpp:(.text.startup+0x31d): undefined reference to `ceres::Problem::AddResidualBlock(ceres::CostFunction*, ceres::LossFunction*, double* const*, int)' myCeres.cpp:(.text.startup+0x905): undefined reference to `ceres::Solve(ceres::Solver::Options const&amp;, ceres::Problem*, ceres::Solver::Summary*)' myCeres.cpp:(.text.startup+0x97b): undefined reference to `ceres::Solver::Summary::BriefReport[abi:cxx11]() const' myCeres.cpp:(.text.startup+0xa1a): undefined reference to `ceres::Problem::~Problem()' myCeres.cpp:(.text.startup+0xb83): undefined reference to `ceres::Problem::~Problem()' myCeres.cpp:(.text.startup+0xb95): undefined reference to `ceres::CostFunction::~CostFunction()' 解决方法 在链接ceres库时使用CERES_LIBRARIES,而不是CERES_LIBS
add_executable(myCeres myCeres.cpp) target_link_libraries(myCeres ${OpenCV_LIBS} ${CERES_LIBRARIES}) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c453de33f9944997d6681b92f7c9e5c/" rel="bookmark">
			PADS Layout VX2.7 PCB封装绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开PCB Layout 软件点击库
选择要创建的库，点击封装，新建
自动跳转到 封装：New
打开一个SOP8的尺寸图，上面为英寸，括号内为毫米，一般使用毫米
回到layout，点击绘图工具栏
点击端点
选择表面贴装，起始管脚编号选1
然后放置第一个引脚
右击选择端点 选择焊盘
在设置中，选择设置原点
然后点击器件，然后选择是，原点就跑到焊盘1的中心去了
再次右击选择端点，再点击焊盘，右击点击特性
可以修改引脚的坐标以及 引脚编号
点击焊盘栈，可以编辑引脚属性，我们这边画一个椭圆形的焊盘
从表得知，器件总长度为5.8MM-6.19mm，我们按最大计算，芯片的长度为3.81-3.98
我们用6.19-3.98=2.21得到2个引脚的长度为2.21，2.21/2=1.105，得到了芯片引脚的长度
贴片封装的器件一般加长0.5mm左右，这看个人习惯，不用低于0.2mm不然焊接起来不方便
1.105+0.5=1.605mm，我们这边单个引脚的长度我们选择1.6mm，再来就是引脚的宽度，从表得知，生产工艺的误差，最小0.31-0.51mm，这边我们选择加宽0.1mm，为0.6mm，需要根据封装的区别来选择，如果是很，密集的引脚分布可以选择加宽0.05mm
完成之后的焊盘
我们一排总共有4个引脚，右击选择分布和重复
选择向下，3个距离是1.27MM，距离不需要加大
确认后我们就完成了4个引脚
另外一排的焊盘间距为 1.6+3.98 = 5.58，我们选择5.5，差距不用太大即可。
这样就完成了8个焊盘的绘制
现在格点设置为0.1，接下来绘制丝印
可以右击特性把1脚设置为方形，这样可以很好区分
绘制丝印，点击2d线
右击选择矩形
双击2D线，选择父项
一般的宽度为0.15mm，一般放置在Silkscreen Top，丝印顶层，然后确定
丝印的大小，长宽根据个人喜好设置，不要画到焊盘上就可以，注意2边长度即可。
1脚标识 选择2D线按刚刚的操作，操作即可
接下来就是检查，看画的有没有错误，在工具下，点击选型
文本，中的线性，选择为3，确定
点击尺寸标志工具栏
点击水平测量，右击选择捕获到中间，就可以去测量了
绘制完成后点击保存，选择保存到哪个库中，名字叫什么，这次绘制的是SOP-8
这个时候再打开库
选择库，选择要分配的元件，编辑，PCB封装，选择对应封装，分配确认即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfb244888b8ddcfd380f26f6b1e6296/" rel="bookmark">
			STM32 第20讲 通用定时器（简介/框图/时钟源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用定时器 简介定时器框图时钟源计数器时钟源寄存器设置方法内部时钟(CK_INT)外部时钟模式1（TI1\TI2）外部时钟模式2（ETR）内部触发输入（ITRx） 基本定时器中断实验 简介 对于STM32F407有10个通用定时器，TIM2 ~ TIM5 和 TIM9 ~ TIM14。
主要特性：
16位递增、递减、中心对齐计数器（计数值：0~65535）16位预分频器（分频系数：1~65536）可用于触发DAC、ADC在更新事件、触发事件、输入捕获、输出比较时，会产生中断/DMA请求4个独立通道，可用于：输入捕获、输出比较、输出PWM、单脉冲模式使用外部信号控制定时器且可实现多个定时器互连的同步电路支持编码器和霍尔传感器电路等 定时器框图 时钟源
通用定时器有4种时钟源
①内部时钟(CK_INT)
②外部时钟模式1：外部输入引脚(TIx)，x=1，2（即只能来自于通道 1 或者通道 2）
③外部时钟模式2：外部触发输入(ETR)
④内部触发时钟：使用一个定时器作为另一定时器的预分频器控制器
控制器包括：从模式控制器、编码器接口和触发控制器（TRGO）。从模式控制器可以控制计数器复位、启动、递增/递减、计数。编码器接口针对编码器计数。触发控制器用来提供触发信号给别的外设，比如为其它定时器提供时钟或者为 DAC/ADC 的触发转换提供信号。时基单元
时基单元包括：计数器寄存器(TIMx_CNT)、预分频器寄存器(TIMx_PSC)、自动重载寄存器(TIMx_ARR)。这部分内容和基本定时器基本一样的。
不同点是：通用定时器的计数模式有三种：递增计数模式、递减计数模式和中心对齐模式输入捕获
一般应用是要和第⑤部分一起完成测量功能。
TIMx_CH1~ TIMx_CH4 表示定时器的 4 个通道，这 4 个通道都是可以独立工作的。IO 端口通过复用功能与这些通道相连。配置好 IO 端口的复用功能后，将需要测量的信号输入到相应的IO 端口，输入捕获部分可以对输入的信号的上升沿，下降沿或者双边沿进行捕获，常见的测量有：测量输入信号的脉冲宽度、测量 PWM 输入信号的频率和占空比等。输入捕获和输出比较公用部分
该部分需要结合第④部分或者第⑥部分共同完成相应功能。输出比较
一般应用是要和第⑤部分一起完成定时器输出功能。
TIMx_CH1~ TIMx_CH4 表示定时器的 4 个通道，这 4 个通道都是可以独立工作的。IO 端口通过复用功能与这些通道相连。 时钟源 计数器时钟源寄存器设置方法 内部时钟(CK_INT) STM32F4 系列的定时器 TIM2/TIM3/TIM4/TIM5/ TIM6/TIM7/ TIM12/ TIM13/ TIM14 都是挂载在 APB1 总线上，当预分频系数≥2时，时钟频率为84Mhz，APB2 总线上挂载的通用定时器 TIM9/TIM10/TIM11，以及高级定时器 TIM1 和 TIM8，同理一般为168Mhz。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfb244888b8ddcfd380f26f6b1e6296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8792ee55c670e7dd5e296987bb7a3297/" rel="bookmark">
			Mysql - last_insert_id的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
select last_insert_id语句的作用是返回自增长的最后插入的数据的ID。
实现方法：
1、在Mapper上加入@SelectKey：
@Insert("INSERT INTO application ( apId, uId, applicantSN, apApplicant, apApplicantPhone, apBeginTime, apOverTime, apContent, apNote, apSubmitTime, apState, apAcademy, apResult ) VALUES (#{apId}, #{uId}, #{applicantSN}, #{apApplicant}, #{apApplicantPhone}, #{apBeginTime}, #{apOverTime}, #{apContent}, #{apNote}, #{apSubmitTime}, #{apState}, #{apAcademy}, #{apResult})") @SelectKey(keyProperty = "apId",keyColumn = "apId",resultType = int.class,before = false,statement = "select last_insert_id()") int saveAndGetLastId(Application application); 然后此时获得返回值里的id就是自增长的id（没加之前是0）
这时候，一般直接getApId就能拿到值了
但是，因为我的返回值是json格式，直接用getApId返回的是null，所以这时候需要先对json数据进行处理。
思路一：先获得返回的result，然后将result转成实体类，然后再getApId
Result result = DatabaseUtil.insert(application,"application","insert"); Toast.makeText(BorrowApplicationActivity.this,"提交成功",Toast.LENGTH_SHORT).show(); //查询刚才存进去的application的Id,存到applicationlist里，方便后期级联删除 Application application1 = DatabaseUtil.getEntity(result,Application.class); 思路二：直接将json格式的数据解析，然后获得apId。网上有很多解析的教程，就不写了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22ed658799b494ef58f155d994f2b81/" rel="bookmark">
			软考初级-信息处理技术员笔记-基础知识&#43;操作系统 篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 信息处理技术员笔记 基础知识 篇 名词解释 VGA接口：显示器接口ISO：国际标准化组织位（Bit）：最小存储单位；1字节=8个位文件六大属性：只读、隐整、压缩、存档、索引、加密（文件右键属性可以查看）计算机病毒：是一组程序，杀毒软件不杀木马，防火墙不防病毒（硬防火墙：防硬件；软防火墙：）8421码，四位二进制（8421分别为2的3、2、1、0次幂）ACCESS2007条件：Like"??"大于，小于直接输入&gt; &lt; &gt;= &lt;= &lt;&gt;(不等于)Http：超文本传输协议（下载）Ftp：远程传输协议（上传）SMTP：邮件发送协议POP3：邮件接收协议org：非盈利性组织com：商业机构gov：政府机构edu：教育机构mil：美国军事机构cn：中国uk：英国jp：日本us：美国计算机运算速度：MIPS是计算机的性能指标MHz(GHz)：赫兹，主频MB：兆字节，存储容量（1TB&gt;1GB&gt;1MB&gt;1KB&gt;1B）MBps(b/s)：比特率，网络传输速率网络根据传输介质划分： 有线：光纤，双绞线，同轴电缆无线：微波，无线电，红外线，激光按区域分：局域网(LAN)，城域网(MAN)，广域网(WAN) 网卡（网络适配器）显示器（监视器） 操作系统 篇 1. 操作系统基础知识 操作系统概念 操作系统(Operating System,OS)是管理和控制计算机硬件与软件资源的计算机程序，是计算机系统中必不可少的核心系统软件，其他软件建立在操作系统上，并在操作系统的统一，管理和支持下运行。操作系统是用户和计算机的接口，管理计算机的硬件及软件资源。
操作系统作用： ① 屏蔽硬件物理特性和操作细节；
② 有效管理系统资源，提高系统资源的使用效率。
操作系统特征： ① 并发性（同时运行）
② 共享性（共享数据)
③ 虚拟性（对硬件虚拟映射图标)
④ 不确定性（传输时间、安装时间)
操作系统主要功能： 进程管理：不管是常驻程序或者应用程序，他们都以进程为标准执行单位。内存管理：根据帕金森定律：“你给程序再多内存，程序也会想尽办法耗光”，因此程序员通常希望系统给他无限量且无限快的存储器。文件系统：对计算机系统中软件资源的管理(外存储器)存储管理：进行资源存储管理程序管理：一个用户程序的执行自始至终是操作系统控制下进行的。作业管理：包括任务、界面管理、人机交互、语音控制设备管理：对硬件设备的管理 操作系统类型 批处理操作系统：操作系统根据作业说明书控制作业运行，无需人工干预（分为单道批处理和多道批处理）分时操作系统：计算机系统与多个终端设备相连，操作系统将CPU的工作时间划分为时间片，轮流为各个终端提供服务。实时操作系统：对外来信息能够以足够快的速度进行处理，并在呗控制对象允许的时间范围内做出反应。（安全气囊）网络操作系统：使联网计算机能共享网络资源，为网络用户提供各种服务的软件和有关协议的集合。分布式操作系统：能直接对分布式计算机系统中各类资源进行动态分配和调度、任务划分、信息传输协调，并为用户提供统一的界面。（每个计算机分散的）嵌入式操作系统：运行在嵌入式智能芯片中，特点是微型化（内存占有量少）、可定制（运营在不同的微处理器）、实时性（关键领域，迅速反应）、可靠性（防故障）、易移梢性 常见的操作系统 DOS： DOS是磁盘操作系统的缩写，是个人计算机上的一类操作系统。从1981年直到1995年的15年间，磁盘操作系统在IBM PC兼容机市场中占有举足轻重的地位。主要使用各种命令来完成各种功能及任务 Windows： 可视化图形界面，界面友好多任务的操作系统，用户对计算机的各种复杂操作只需通过点击鼠标就可以实现目前全球个人计算机中占有率最高 UNIX： 多任务、多用户，支持多种处理架构系统通过键盘写命令对操作系统进行操作通过按照GUI插件实现类似与Windods系统一样的操作方式 Linux： 类UNIX系统，它与UNIX完全兼容。20世纪1991年推出的一个多用户、多任务的操作系统源代码公开的自由及开放源码的操作系统，其内核源代码可以自由传播 IOS： iOS操作系统是由苹果公司开发的手持设备操作系统属于类UNIX的商业操作系统 Android： Android是一种以Linux为基础的开放源代码操作系统主要使用于便携设备。主要用于智能手表、平板电脑、移动设备等 2. Windows7操作系统 操作： 新建文件夹：鼠标右键-新建-文件夹我的电脑（此电脑）：双击打开文件夹与文件、快捷方式 常见的系统工具 常用快捷键 3. 文件系统 文件系统基本概念 文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NANDFlash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。
文件：文件(File)是具有符号名的、在逻辑上具有完整意义的一组相关信息的集合(例如一个源程序代加工数据、各种文档)文件夹：文件由文件目录顶和文件体组成。文件目录(文件夹由文件目录顶组成。文件目录顶包括文件名、文浒类型、存储地址、长度、访问权限等信息。 常见文件类型 文件管理操作 本部分上机完成
新建文件夹：鼠标右键-新建-文件夹新建文件：鼠标右键-新建-文件（txt/word/…）打开任务管理器：任务栏右键-任务管理器复制粘贴文件：ctrl+C ctrl+V剪切文件：右键-剪切/ctrl+X删除文件：delete/shift+delete（彻底删除）显示扩展名：组织-文件夹和搜索选项-查看-隐藏移植文件的扩展名重命名：右键-重命名（英文输入法状态特殊字符不能输入） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55137a3c6052685ab43b5a6716616409/" rel="bookmark">
			java并发之MarkWord、Monitor重量级锁，轻量级锁，偏向锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java并发之重量级锁，轻量级锁，偏向锁 一、Java对象头Mark Word结构： 二、Monitor三、重量级锁自适应自旋锁 四、轻量级锁锁膨胀 五、偏向锁 一、Java对象头 由于Java面向对象的思想，在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能，这些标记字段组成了对象头
对象头包含两部分：运行时元数据（Mark Word）和类型指针（Klass Word）
Mark Word结构： 32位
64位
二、Monitor Monitor 被翻译为监视器或管程
每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针
内存结构
三、重量级锁 图解：
如下图所示，我们有一个临界区代码，当Thread2执行到synchronized(obj)，访问共享资源的时候：
首先会将synchronized中的锁对象中对象头的MarkWord去尝试指向操作系统提供的Monitor对象，让锁对象中的MarkWord和Monitor对象相关联.
如果关联成功, 将obj对象头中的MarkWord的对象状态从01改为10。因为该Monitor没有和其他的obj的MarkWord相关联，所以Thread2就成为了该Monitor的Owner(所有者)。
然后，又来了一个Thread1执行synchronized(obj)代码，它首先会检查是否能执行临界区代码，即检查obj是否关联了Montior，此时已经有关联了,它就会去看看该Montior有没有所有者(Owner), 发现有所有者了(Thread2)；Thread1也会和该Monitor关联,
该线程就会进入到它的EntryList(阻塞队列)，EntryList是一个列表，若此时Thread3也执行到synchronized(obj)代码，也会进入阻塞队列。
-当Thread2执行完临界区代码后, Monitor的Owner(所有者)就空出来了.
此时就会通知Monitor中的EntryList阻塞队列中的线程, 这些线程通过竞争, 成为新的所有者。 刚开始 Monitor 中 Owner 为 null
当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKEDThread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55137a3c6052685ab43b5a6716616409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588eb38d8af6110c1b65feb4882da065/" rel="bookmark">
			GreenDao进阶篇 GreenDao分页查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GreenDao进阶篇
GreenDao分页查询
/** * 分页条件查询实体集合 * * @param where * @param conditions * @param properties 倒序 * @param offset * @param limit * @return */ public List&lt;SMessage&gt; querySMessage(String where, String[] conditions, Property properties, int offset, int limit) { QueryBuilder&lt;SMessage&gt; qb = mManager.getDaoSession().queryBuilder(SMessage.class) .orderDesc(properties) .where(new WhereCondition.StringCondition(where, conditions)) .offset(offset * limit) .limit(limit); return qb.list(); } 示例：
//条件查询示例 daoUtils.querySMessage("USER_ID = ? AND DEVICE_TYPE = ?", new String[]{userId, typeId}, SMessageDao.Properties.Tailtime, offset, MessageFragment.REQUEST_NUM); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b49de6c507e20692eeacd9817dc65613/" rel="bookmark">
			promise generator aysnc/await三者区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三者都是异步编程的解决方案,不同的是,promise为较早出来的,其次generator,最后为async/await,三者象征了前端进行解决异步编程的进化路程。
promise promise比较简单，也是最常用的，主要就是将原来用 回调函数异步编程的方法 转成 relsove和reject触发事件； 对象内含有四个方法，then()异步请求成功后 catch()异步请求错误的回调方法 finally()请求之后无论是什么状态都会执行 resolve()将现有对象转换为Promise对象 all()此方法用于将多个Promise实例包装成一个新的promise实例。 race()也是将多个Promise实例包装成一个新的promise实例 reject()返回一个状态为Rejected的新Promise实例。 有点：让回调函数变成了规范的链式写法，程序流程可以看的很清楚 缺点:编写的难度比传统写法高，阅读代码也不是一眼可以看懂 Generator generator是一个迭代生成器,其返回值为迭代器(lterator),是ES6标准引入的新的数据类型，主要用于异步编程,它借鉴于Python中的generator概念和语法； generator函数内有两个重要方法，1 yield表达式 2.next() Generator 函数是分段执行的，yield表达式是暂停执行的标记，而 next方法可以恢复执行 优点：1.利用循环，每调用一次，就使用一次，不占内存空间 2.打破了普通函数执行的完整性 缺点: 需要用next()方法手动调用,直接调用返回无效iterator 2. async/await async：异步函数 await：同步操作 es7中提出来的异步解决方法,是目前解决异步编程终它基极解决方案,于promise为基础,其实也就是generator的高级语法糖,本身自己就相当于一个迭代生成器(状态机),它并不需要手动通过next()来调用自己,与普通函数一样 async就相当于generator函数中的*,await相当于yield, async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 function getSomething() { return "something"; } async function testAsync() { return Promise.resolve("hello async"); } async function test() { //await是在等待一个async函数完成 const v1 = await getSomething(); //await后面不仅可以接Promise，还可以接普通函数或者直接量 const v2 = await testAsync(); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b49de6c507e20692eeacd9817dc65613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74069f7de7f2580e4f7c7b32ea726e58/" rel="bookmark">
			S32DS编译ld文件报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前好好的现在就突然报错了，不知道是什么缘故，有大神给点拨一下嘛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10dbb6e1d68b46d853888f1b4d96fa1/" rel="bookmark">
			vue3 兄弟组件通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue2 中兄弟组件通信如果不采用vuex,一般在采用事件总线的方式进行通信；在vue3中取消事件总线的方法，推荐插件 mitt(https://www.npmjs.com/package/mitt)
一、安装mitt插件
npm install --save mitt // or yarn add mitt -- save 二、引入mitt
在src/utils 路径下创建 bus.js文件，文件内容如下：
import mitt from "mitt"; const emitter = mitt(); export default emitter; 三、应用mitt
监听全部事件写法：emitter.on('*', (type, e) =&gt; console.log(type, e) )；* 代表监听事件的名称；
清除所有事件写法：emitter.all.clear()
1、在页面中应用 组件1 和组件2，代码如下：
&lt;template&gt; &lt;h2&gt;兄弟组件通信&lt;/h2&gt; &lt;child /&gt; &lt;br /&gt; &lt;child-2 /&gt; &lt;/template&gt; &lt;script setup&gt; import child from "./components/child.vue"; import child2 from "./components/child2.vue"; &lt;/script&gt; 2、组件1，代码如下：
&lt;template&gt; &lt;div class="container"&gt; 组件1 &lt;el-button type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b10dbb6e1d68b46d853888f1b4d96fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc5860508ed5a3954f96d675bde3e79/" rel="bookmark">
			Leetcode详解JAVA版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 两数之和14. 最长公共前缀15. 三数之和18. 四数之和19. 删除链表的倒数第 N 个结点21. 合并两个有序链表28. 找出字符串中第一个匹配项的下标36. 有效的数独42. 接雨水43. 字符串相乘45. 跳跃游戏 II48. 旋转图像53. 最大子数组和54. 螺旋矩阵55. 跳跃游戏62. 不同路径70. 爬楼梯73. 矩阵置零78.子集88. 合并两个有序数组98. 验证二叉搜索树102. 二叉树的层序遍历118. 杨辉三角121. 买卖股票的最佳时机122. 买卖股票的最佳时机 II142. 环形链表 II148. 排序链表152. 乘积最大子数组167. 两数之和 II - 输入有序数组198. 打家劫舍200. 岛屿数量202. 快乐数205. 同构字符串206. 反转链表213. 打家劫舍 II217. 存在重复元素234. 回文链表235. 二叉搜索树的最近公共祖先278. 第一个错误的版本299. 猜数字游戏328. 奇偶链表392. 判断子序列409. 最长回文串424. 替换后的最长重复字符438. 找到字符串中所有字母异位词509. 斐波那契数589. N 叉树的前序遍历621. 任务调度器692. 前K个高频单词704. 二分查找724. 寻找数组的中心下标733. 图像渲染740. 删除并获得点数746. 使用最小花费爬楼梯815. 公交路线844. 比较含退格的字符串876. 链表的中间结点896. 单调数列918. 环形子数组的最大和930.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bc5860508ed5a3954f96d675bde3e79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b93f9643e8cc342dc50e5da7a96e22/" rel="bookmark">
			CentOS7.9(2009) Oracle 11g 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7.9(2009) Oracle 11g 安装 环境准备： Oracle 安装包带有 Linux 内核命令的 CentOS7.9Oracle 离线依赖包。 百度云盘链接：https://pan.baidu.com/s/1_HeKG1RUmabmwRA_syhVOA
提取码：265e
一、 安装准备： 按照以下命令逐步输入 查看Swap分区空间（不能小于2G）：
grep SwapTotal /proc/meminfo 修改CentOS系统标识 (由于Oracle默认不支持CentOS)
vim /etc/redhat-release 删除CentOS Linux release 7.9.2009 (Core)（快捷键dd），改成 redhat-7
修改sysctl.conf
vim /etc/sysctl.conf 添加以下内容:
fs.aio-max-nr = 1048576 fs.file-max = 6815744 kernel.shmmni = 4096 kernel.sem = 250 32000 100 128 kernel.shmall = 2097152 kernel.shmmax = 2147483648 net.ipv4.ip_local_port_range = 9000 65500 net.ipv4.icmp_echo_ignore_broadcasts = 1 net.ipv4.conf.all.rp_filter = 1 net.core.rmem_default = 262144 net.core.rmem_max= 4194304 net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73b93f9643e8cc342dc50e5da7a96e22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9929e6e4534c24ef973afcd3d0087a94/" rel="bookmark">
			vue&#43;el-table实现展开与折叠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文会提到两种实现方法，之前我使用的是第一种，后来加了固定列，发现展开与折叠失效，故而出现了第二种方法。
一、通过class名称获取节点，并对节点进行操作（该方法表格添加固定列会失效） 1.全部展开
looAll(){ let expandElementList = document.getElementsByClassName( "el-table__expand-icon" ); if (this.dataList.length != 0 &amp;&amp; expandElementList.length != 0) { for (let i = 0; i &lt; expandElementList.length; i++) { // 添加dafult类，如已经存在，取消添加 expandElementList[i].classList.add("dafult"); } // 获取所有已经展开元素集合 const expanded = this.$el.getElementsByClassName( "el-table__expand-icon--expanded" ); if (expanded) { for (let j = 0; j &lt; expanded.length; j++) { // 如果已经展开，移除dafult类,剩余未展开的元素带有dafult类 expanded[j].classList.remove("dafult"); } // 获取所有dafult类：带有展开图标且还未展开的元素 const dafult = this.$el.getElementsByClassName("dafult"); for (let k = 0; k &lt; dafult.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9929e6e4534c24ef973afcd3d0087a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2843e92240530a9685e9c82798f29ef/" rel="bookmark">
			Windows File Recovery使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows File Recovery简介 Windows File Recovery是微软在2020年发布的命令提示符文件恢复工具，它不仅具有高成功率和高安全性，还适用于不同的文件系统和文件丢失场景。如果你需要从本地硬盘、USB设备、SD卡等设备中恢复意外丢失或删除的JPEG、PDF、PNG、MPEG、Office等文件，那你不能错过这款好用的工具。
​但由于该软件没有用户图形界面，全程需要依靠命令执行，这对于不熟悉命令的用户来说非常复杂，幸运的是，本文将向你详细介绍Windows File Recovery的使用方法，请继续往下阅读。
操作步骤：使用Windows File Recovery恢复丢失的文件 从微软商店下载并在你的电脑上安装Window File Recovery，然后打开它。 2. 打开Powershell或命令提示符（以管理员身份运行）。在命令提示符下，输入以下命令：
winfr source-drive: destination-drive [/mode] [/switches]
source-drive: 丢失文件所在的盘
destination-drive：文件还原后的盘
[/mode] ：模式选择，请根据磁盘的文件系统选择模式
[/switches] ：命令选择，请根据需要选择命令
例如：winfr E: D: /extensive /n \C:\Recycler\*.txt
3. 按“回车”等待恢复完成即可。
Windows File Recovery的代替软件 使用Windows File Recovery来恢复丢失的文件需要用户输入命令，这对于普通用户来说不是一件容易的事。不过不用担心，本文将向你介绍Windows File Recovery的代替软件。 傲梅恢复之星一款操作简单，恢复速度快的数据恢复软件，它可以自动扫描和过滤所有丢失或删除的文件，除此之外，该软件还有以下优点：
专为Windows系统设计，支持Windows 11/10/8/7 及Windows Server。
恢复速度快并且简单好操作。
可以将文件恢复到丢失或删除时的位置。
支持HDD/固态硬盘/USB/SD卡等设备，以及200多种类型文件的恢复。
支持NTFS/FAT32/exFAT/ReFS文件系统。
1. 在傲梅恢复之星主界面中选择丢失文件的盘，再点击“开始扫描”。
2. 软件会根据文件系统和数据丢失情况自动选择扫描方法，你只需耐心等待扫描完成。
3. 等待扫描完成后，选择你需要的文件，然后点击“恢复x个文件”，再选择恢复文件的保存位置即可。
以上是Windows File Recovery使用教程，想必你现在已经知道如何使用Windows File Recovery恢复文件了，但如果你觉得该工具操作麻烦，更建议你使用专业数据恢复软件，如傲梅恢复之星，该软件更适合广大普通用户使用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16d07dca568a3e83af4940a0ec2612f/" rel="bookmark">
			【MySQL入门指南】Centos7下MySQL5.7安装教程（全程图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、卸载不需要的环境三、删除默认安装包四、获取mysql官方源五、安装mysql服务六、设置免密登录 一、前言 MySQL是一个可移植的数据库，几乎能在当前所有的操作系统上运行。本文重点讲解如何在Centos7上安装MySQL。在安装过程中，推荐始终以root用户的身份运行以减少操作的成本。
二、卸载不需要的环境 在你的Centos7系统中，可能已经预装有MySQL或者mariadb（MySQL的一个分支），并在后台以守护进程的方式运行。我们首先要停止这些服务，才能将原有的安装包删除。
使用 ps ajx 显示是否存在mysqld（mariada同理，后面不再赘述）
使用 systemctl stop 指令停止mysql服务
如果系统没有mysql，则这一步跳过
三、删除默认安装包 使用 rpm -qa | grep mysql 指令来显示系统中是否安装有mysql的软件包
如果有的话，则使用 rpm -qa | grep mysql | xargs yum -y remove 指令将全部的安装包删除。xargs指令的作用是将前面的数据一条一条“喂给”后面的指令，从而达到批量操作的目的。注意 -y 不能省略，否则在批量处理时会出错删完再检查确认已经完全删除了
如果系统中找不到mysql的安装包，则这一步直接跳过
四、获取mysql官方源 [目的]：最后能使用 yum install 指令一键安装
[问题]：云服务器中默认的yum源中可能没有mysql的源
[解决]：首先从官网手动拉取mysql的yum源（注意不是下载mysql）
首先获取mysql的官方yum源 &gt;yum源链接
右击查看网页源代码可以看到更多的文件细节
在安装时注意版本问题 选择名字中带有el字样的版本。el指代 Enterprise Linux，是centos的简称
选择名字中带有 57 的版本，57表示mysql的版本为5.7，否则下载的是最新版的mysql
最好安装和自己系统一致的mysql版本，否则可能存在软件兼容性的问题。如果没有刚好合适的版本，我们的原则是选择比系统版本更新的mysql版本，一般都会向前兼容的
使用 cat /etc/redhat-release 指令查看当前centos的版本
选择适配操作系统版本mysql。下图中的都行
使用 rz 指令将本地下载好的mysql源上传到云服务器环境中
使用 rpm -ivh 指令来安装rpm软件包
至此我们已经完成了官方源的安装，再次查看yum源，发现多了两项。Linux下的安装本质就是将文件拷贝到特定路径下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b16d07dca568a3e83af4940a0ec2612f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7735e22017394dbee617c534cf6de722/" rel="bookmark">
			JVM 类加载器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 类加载器1.1 类加载器介绍1.2 类加载器的加载规则1.2 类加载器类型总结 2 双亲委派模型2.1 双亲委派模型介绍2.2 双亲委派模型的执行流程2.3 双亲委派模型的好处 回顾一下类加载过程：加载-&gt;连接-&gt;初始化。
其中连接又分为：验证-&gt;准备-&gt;解析
加载是类加载过程的第一步，主要完成下面 3 件事情：
通过全类名获取定义此类的二进制字节流将字节流所代表的静态存储结构转换为方法区的运行时数据结构在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口 1 类加载器 1.1 类加载器介绍 根据官方 API 文档的介绍：
类加载器是一个负责加载类的对象。ClassLoader 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。每个 Java 类都有一个引用指向加载它的 ClassLoader。不过，数组类不是通过 ClassLoader 创建的，而是 JVM 在需要的时候自动创建的，数组类通过getClassLoader()方法获取 ClassLoader 的时候和该数组的元素类型的 ClassLoader 是一致的。
从上面的介绍可以看出:
类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步每个 Java 类都有一个引用指向加载它的 ClassLoader。数组类不是通过 ClassLoader 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。 class Class&lt;T&gt; { ... private final ClassLoader classLoader; @CallerSensitive public ClassLoader getClassLoader() { //... } ... } 简单来说，类加载器的主要作用就是加载 Java 类的字节码（ .class 文件）到 JVM 中（在内存中生成一个代表该类的 Class 对象）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7735e22017394dbee617c534cf6de722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e26b0b9c606dec3201e655cdebd3a4c8/" rel="bookmark">
			时间轴的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有三种状态
例如：后台给的时间是6.23
一.6.23那天是红色的
二.6.23左边的数字包括轴线的颜色都是橘色
三.6.23右边的数字包括轴线的颜色是灰色
html
&lt;div class="date" ref="tabscroll"&gt; &lt;ul id="tabscroll" v-if="btnShow=='1'"&gt; &lt;li v-for="(item, index) in date_list" :key="index"&gt; &lt;p :class=" item.state == 1 ? 'day1' : item.state == 2 ? 'day2' : 'day3' " &gt; {{ item.fmt_date }} &lt;/p&gt; &lt;p @click="dayInfo(item)" :class=" item.state == 1 ? 'point1' : item.state == 2 ? 'point2' : 'point3' " &gt; &lt;span&gt;&lt;/span&gt; &lt;/p&gt; &lt;p :class="item.state == 3 ? 'border2' : 'border1'"&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e26b0b9c606dec3201e655cdebd3a4c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d40a813be6ae9e51bd33a7c3b3cee4d/" rel="bookmark">
			JavaScript 常见鼠标事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见鼠标事件类型1
1、click鼠标左键点击
2、mousedown 鼠标按下时触发
3、mouseup 鼠标弹起时触发
4、mousemove (move移动)鼠标在固定的位置一移动就触发移动，就触发
5、mouseenter 鼠标移入触发
6、mouseleave 鼠标移出触发
代码段：
&lt;!DOCTYPE html&gt; &lt;html lang="cn"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .div1{ width: 100px; height: 100px; background: #FFFFCC; margin: 50px auto; } .div2{ width: 500px; height: 500px; background: #FFFFCC; margin: 50px auto; } &lt;/style&gt; &lt;body&gt; &lt;div class="div1"&gt;盒子1&lt;/div&gt; &lt;div class="div2"&gt;盒子2&lt;/div&gt; &lt;script&gt; // 获取元素节点 let div1 =document.querySelector('.div1') //mousedown 鼠标按下时触发 div1.onmousedown=function(){ div1.style.backgroundColor='#CCFFFF' } //mouseup 鼠标弹起时触发 div1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d40a813be6ae9e51bd33a7c3b3cee4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c8b2074345def690708cfdaf75f6195/" rel="bookmark">
			idea搜索快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、全局搜索 shift + shift 双击
功能：在整个项目中搜索匹配符合关键词的位置
作用：显示当前项目中的此关键字位置，但是这个搜索支持模糊查询
效果图：
2、Ctrl + F在当前类中，页中进行查找相关方法等 功能：在当前整个类中搜索匹配符合关键词的位置
作用：显示当前整个类中此关键字位置，但是这个搜索支持模糊查询
效果图：
3、Ctrl+Shift+N按【文件名】搜索文件 功能：过滤的结果都是文件
作用：显示当前整个项目中的文件
效果图：
4. Ctrl+e 查看最近打开的文件 功能：查看最近打开修改的文件
作用：查看最近打开的文件
效果图：
5、Ctrl+H 查看类的继承关系 功能：查看类的继承关系
作用：查看类的继承关系
效果图：
6、Alt + F7 查看类在哪儿被使用 功能：查看类在哪儿被使用 作用：查看类在哪儿被使用 效果图：
7、Ctrl+F12 功能：查看当前类中的所有成员：方法、属性、内部类
作用：直接显示所有成员的列表，支持搜索功能快速定位到某个成员的位置上 效果图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a025d05ea44d699a36898a5d284dbae/" rel="bookmark">
			直接在JS里创建JSON数据然后遍历使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接在JS里创建JSON数据，然后遍历使用~
创建代码如下：（创建的是JSON对象）
var YearSelect = {}; var Year = 2014; var DateOption; for (var i = Year; i &lt; Year + 12; i++) { DateOption = {'Year':i, 'Month':i-Year+1}; / alert(DateOption.Year) YearSelect[i] = DateOption; } 这里是创建一个JSON对象，包括了年份和月份的数据。
我为什么创建JSON对象，是因为我对JSON对象比较熟悉。php后台返回的也是json对象。
json对象没有length属性~~
所以遍历的话要：
for(var key in YearSelect){ alert(YearSelect[key].Year); alert(YearSelect[key].Month); } 这样就可以了~
记住一定要分辨好json的对象和数组~不然就一直是undenfined
js数组如何添加json数据及js数组与json的区别 下面给大家介绍js数组添加json数据的两种方式。
// 第一种方式
personInfo : [], for(var i = 0; i &lt; _STAGE.passengerInfoArray.length; i++){ var name = _STAGE.passengerInfoArray[i]; var person = {v:name, text:name}; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a025d05ea44d699a36898a5d284dbae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a91813ca573611d49c61b5aafd35a979/" rel="bookmark">
			蓝易云：Linux系统常用命令-系列【5】ifconfig命令详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ifconfig是Linux系统中最常用的网络管理命令之一，可以用于查看和配置网络接口的信息。下面详细介绍ifconfig命令的用法和参数。
1. 命令格式
ifconfig [选项] [网络接口名称] [命令]
2. 常用选项
- -a：显示所有网络接口，包括未启用的。
- -s：显示网络接口汇总信息。
- -v：显示详细信息，包括MTU、广播地址等。
- -h：显示帮助信息。
3. 常用命令
- up：启用指定网络接口。
- down：禁用指定网络接口。
- mtu：设置指定网络接口的最大传输单元。
- promisc：开启或关闭网卡的混杂模式。
4. 常用参数
- 网络接口名称：可以是eth0、lo等网络接口的名称。
- IPv4地址：表示网络接口的IPv4地址。
- 子网掩码：表示网络接口的子网掩码。
- 广播地址：表示网络接口的广播地址。
5. 示例
- 显示所有网络接口：ifconfig -a
- 查看指定网络接口的详细信息：ifconfig eth0 -v
- 启用指定网络接口：ifconfig eth0 up
- 禁用指定网络接口：ifconfig eth0 down
- 设置指定网络接口的最大传输单元：ifconfig eth0 mtu 1500
- 开启或关闭网卡的混杂模式：ifconfig eth0 promisc
总之，ifconfig命令是一个非常实用的命令，可以用于管理网络接口。掌握ifconfig的使用方法，可以快速解决各种网络问题。
有关更多详细信息，请访问：www.tsyvps.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d6e2ce10107c27768341ca8be208876/" rel="bookmark">
			【爱思助手】iPhone虚拟定位打卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提准备 设备：
一台电脑一部iPhone手机 软件：
爱思助手 如何使用 先打开爱思助手，再用数据线连接手机和电脑，爱思助手会自动连接手机，这时手机界面会询问你是否信任，点击信任就好。
1、自动读取设备信息
2、点击工具箱菜单，找到虚拟定位，点击进入
3、输入你需要修改的目标位置，点击修改虚拟定位
4、等待修改定位
5、修改定位成功
6、手机可打开地图验证是否修改成功
还原定位 1、将手机定位还原，点击还原真实定位
2、点击重启设备
3、手机打开地图显示位置已还原
注意 修改完成之后，并非永久修改，iPhone自带的定位会过一段时间还原准确的定位，需要在每次使用之前再连接爱思助手重新设置！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1754b77071b907e643a8132f7b3c0f64/" rel="bookmark">
			V4L2系列 之 初识V4L2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、发展历史二、主要功能三、编程开发1、采集方式2、操作流程（编程步骤） 前言 由于进行linux音视频开发，通常会涉及到音频以及摄像头视频驱动，所以对V4L2以及ALSA驱动框架进行学习，并整理相关的笔记和大家分享！
一、发展历史 V4L2是Video for linux2的简称,为linux中关于视频设备的内核驱动。在Linux中，视频设备是设备文件，可以像访问普通文件一样对其进行读写，摄像头在/dev/video*下，如果只有一个视频设备，通常为/dev/video0。
V4L2在设计时，是要支持很多广泛的设备的，它们之中只有一部分在本质上是真正的视频设备。
V4L2有一段历史了。大约在1998的秋天，它的光芒第一次出现在Bill Dirks 的眼中。
经过长足的发展，它于2002年11 月，发布2.5.46 时，融入了内核主干之中。然而直到今天，仍有一部分内核驱动不支持新的API，这种新旧API 的转换工作仍在进行。
同时，V4L2 API也在发展，并在2.6.18 版本中进行了一些重大的改变。支持V4L2的应用依旧相对较少。V4L2在设计时，是要支持很多广泛的设备的，它们之中只有一部分在本质上是真正的视频设备，可以支持多种设备,它可以有以下几种接口:
1. 视频采集接口(video capture interface):这种应用的设备可以是高频头或者摄像头. V4L2的最初设计就是应用于这种功能的. 2. 视频输出接口(video output interface):可以驱动计算机的外围视频图像设备--像 可以输出电视信号格式的设备. 3. 直接传输视频接口(video overlay interface):它的主要工作是把从视频采集设备 采集过来的信号直接输出到输出设备之上,而不用经过系统的CPU. 4. 视频间隔消隐信号接口(VBI interface):它可以使应用可以访问传输消隐期的视频信号. 5. 收音机接口(radio interface):可用来处理从AM或FM高频头设备接收来的音频流. 二、主要功能 使程序有发现设备和操作设备的能力,它主要是用一系列的回调函数来实现这些功能。像设置摄像头的频率、帧频、视频压缩格式和图像参数等等。当然也可以用于其他多媒体的开发，如音频等。
但是此框架只能运行在Linux操作系统之上。
三、编程开发 v4L2是针对uvc免驱usb设备的编程框架 ，主要用于采集usb摄像头等， 基本开发步骤如下：
1、采集方式 打开视频设备后，可以设置该视频设备的属性，例如裁剪、缩放等。这一步是可选的。在Linux编程中，一般使用ioctl函数来对设备的I/O通道进行管理：
extern int ioctl (int __fd, unsigned long int __request, …) __THROW; __fd：设备的ID，例如刚才用open函数打开视频通道后返回的cameraFd； __request：具体的命令标志符。 在进行V4L2开发中，一般会用到以下的命令标志符： VIDIOC_REQBUFS：分配内存 VIDIOC_QUERYBUF：把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址 VIDIOC_QUERYCAP：查询驱动功能 VIDIOC_ENUM_FMT：获取当前驱动支持的视频格式 VIDIOC_S_FMT：设置当前驱动的频捕获格式 VIDIOC_G_FMT：读取当前驱动的频捕获格式 VIDIOC_TRY_FMT：验证当前驱动的显示格式 VIDIOC_CROPCAP：查询驱动的修剪能力 VIDIOC_S_CROP：设置视频信号的边框 VIDIOC_G_CROP：读取视频信号的边框 VIDIOC_QBUF：把数据放回缓存队列 VIDIOC_DQBUF：把数据从缓存中读取出来 VIDIOC_STREAMON：开始视频显示函数 VIDIOC_STREAMOFF：结束视频显示函数 VIDIOC_QUERYSTD：检查当前视频设备支持的标准，例如PAL或NTSC。 这些IO调用，有些是必须的，有些是可选择的。 2、操作流程（编程步骤） 参考学习：https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1754b77071b907e643a8132f7b3c0f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9138dcffb26ffc4d9af0f8e93d446e3c/" rel="bookmark">
			matlab学习之Bode图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reference
MATLAB入门实例——绘制伯德图 这篇文章写得还蛮好，有空再整理一下
无论学习什么软件，官方文档总是最基础的教程，matlab中用help指令可以快速调用官方文档。
在命令行窗口输入&gt;&gt;help bode，然后拖到最后面打开官方文档(蓝色的超链接)即可。
打开后我们发现，bode函数只需要内置一个tf()即可，但我们新手对于tf()也不甚了解。
怎么办呢？
简单，重新在命令行窗口输入&gt;&gt;help tf，然后查看一下tf是干什么的。
Use tf to create real-valued or complex-valued transfer function models, or to convert dynamic system model to transfer function form.
所以，tf 函数实际上是用来创建传递函数的。
接下来再看看tf函数的语法：
sys=tf([numerator],[denominator]) % 前后两个矩阵分别是分子与分母的系数 sys=tf([numerator],[denominator],ts) % 离散化的传递函数，采样时间若不指定，则参数设置为-1 然后bode函数就很简单了，直接bode(sys)就好
此外还有另外一些函数，也都很有用：
w=logspace(-2,3,100) % 指定频率范围为10^-1到10^3 bode(num,den,w) title('Bode Diagram of G(s)=') % 表格的标题 先写到这里吧，有空再整理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc8d0bd6db8a45877c11efe777b921a/" rel="bookmark">
			Nginx使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早期的业务都是基于单体节点部署，由于前期访问流量不大，因此单体结构也可满足需求，但随着业务增长，流量也越来越大，那么最终单台服务器受到的访问压力也会逐步增高。时间一长，单台服务器性能无法跟上业务增长，就会造成线上频繁宕机的现象发生，最终导致系统瘫痪无法继续处理用户的请求。
“ 从上面的描述中，主要存在两个问题：①单体结构的部署方式无法承载日益增长的业务流量。②当后端节点宕机后，整个系统会陷入瘫痪，导致整个项目不可用。
因此在这种背景下，引入负载均衡技术可带来的收益：
「系统的高可用：」 当某个节点宕机后可以迅速将流量转移至其他节点。
「系统的高性能：」 多台服务器共同对外提供服务，为整个系统提供了更高规模的吞吐。
「系统的拓展性：」 当业务再次出现增长或萎靡时，可再加入/减少节点，灵活伸缩。
OK~，既然引入负载均衡技术可给我们带来如此巨大的好处，那么又有那些方案可供选择呢？主要有两种负载方案，「「硬件层面与软件层面」」 ，比较常用的硬件负载器有A10、F5等，但这些机器动辄大几万乃至几十万的成本，因此一般大型企业会采用该方案，如银行、国企、央企等。而成本有限，但依旧想做负载均衡的项目，那么可在软件层面实现，如典型的Nginx等，软件层的负载也是本文的重点。
一、性能怪兽-Nginx概念深入浅出 Nginx是目前负载均衡技术中的主流方案，几乎绝大部分项目都会使用它，Nginx是一个轻量级的高性能HTTP反向代理服务器，同时它也是一个通用类型的代理服务器，支持绝大部分协议，如TCP、UDP、SMTP、HTTPS等。
Nginx与Redis相同，都是基于多路复用模型构建出的产物，因此它与Redis同样具备 「「资源占用少、并发支持高」」 的特点，在理论上单节点的Nginx同时支持5W并发连接，而实际生产环境中，硬件基础到位再结合简单调优后确实能达到该数值。
先来看看Nginx引入前后，客户端请求处理流程的对比：
原本客户端是直接请求目标服务器，由目标服务器直接完成请求处理工作，但加入Nginx后，所有的请求会先经过Nginx，再由其进行分发到具体的服务器处理，处理完成后再返回Nginx，最后由Nginx将最终的响应结果返回给客户端。
了解了Nginx的基本概念后，再来快速搭建一下环境，以及了解一些Nginx的高级特性，如动静分离、资源压缩、缓存配置、IP黑名单、高可用保障等。
二、Nginx环境搭建 ❶首先创建Nginx的目录并进入：
[root@localhost]# mkdir /soft &amp;&amp; mkdir /soft/nginx/ [root@localhost]# cd /soft/nginx/ ❷下载Nginx的安装包，可以通过FTP工具上传离线环境包，也可通过wget命令在线获取安装包：
[root@localhost]# wget https://nginx.org/download/nginx-1.21.6.tar.gz 没有wget命令的可通过yum命令安装：
[root@localhost]# yum -y install wget ❸解压Nginx的压缩包：
[root@localhost]# tar -xvzf nginx-1.21.6.tar.gz ❹下载并安装Nginx所需的依赖库和包：
[root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ gcc-c++ [root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ pcre pcre-devel4 [root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ zlib zlib-devel [root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ openssl openssl-devel 也可以通过yum命令一键下载（推荐上面哪种方式）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfc8d0bd6db8a45877c11efe777b921a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3455f218e4fdec08da6f523206c7dd6/" rel="bookmark">
			mysql修改root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开mysql命令终端 “MySQL 8.0 Command Line Client” ，然后输入密码进入。
紧接着输入如下命令，可将密码更改为 rootcgcl
alter user root@localhost identified by ‘rootcgcl’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f144b0387c82e243db6a50503c0ad1e6/" rel="bookmark">
			pytorch中的广播机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		广播机制 原理 广播机制有什么用？
​广播机制实际上是在运算过程中，去处理两个形状不同向量的一种手段。
什么情况下会出现广播机制？
如果相加（数学运算）的两个数组的shape不同, 就会触发广播机制。
广播机制的规则（条件）是怎样的？
1&gt; 两个张量都至少有一个维度
# 反例 x=torch.empty((0,)) y=torch.empty(2,2) 2&gt; 按从右往左顺序看两个张量的每一个维度，x和y每个对应着的两个维度都需要能够匹配上
匹配含义：
a. 这两个维度的大小相等 b. 某个维度 一个张量有，一个张量没有 c. 某个维度 一个张量有，一个张量也有但大小是1 ​ 3&gt; 对两个张量按元素进行数学运算
举例 x=torch.empty(5,3,4,1) y=torch.empty( 3,1,1) 右对齐将缺失维度修改成1将为1的维度变为对应着的维度大小。 x=torch.empty(5,3,4,1) y=torch.empty(5,3,4,1) 图示 a = torch.tensor([1,2,3]) b = torch.tensor([2]) c = a*b a,a.shape,b,b.shape,c,c.shape a = torch.tensor([[0],[10],[20],[30]]) b = torch.tensor([1,2,3]) c = a+b a,a.shape,b,b.shape,c,c.shape 在这里插入图片描述
参考博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d2d0af1ccc532c7e8126ec3cdddd8bb/" rel="bookmark">
			PTA 实验一：JAVA语言基础刷题（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
7-1 Hello World
7-2 jmu-Java-01入门-第一个PTA上Java程序
7-3 求一个三位正整数各位数字之和
7-4 二进制的前导的零
7-5 JAVA-水仙花数
7-6 sdut-sel-for-1 RDMP音乐播放器（I）（分支、循环）
7-7 java编程判断斐波那契数是质数
7-1 Hello World 写java代码，没有输入，屏幕输出“Hello World”
输入格式:
输出格式:
Hello World
输出样例:
Hello World 我的代码：
public class Main { public static void main(String[] args) { System.out.println("Hello World"); } } 7-2 jmu-Java-01入门-第一个PTA上Java程序 本题目要求读入若干对整数a和b，然后输出它们的和。
输入格式:
在一行中给出一对整数a和b。
以下输入样例只有两对，实际测试数据可能有多对值。
输出格式:
对每一组输入，如果a的绝对值&gt;1000，输出|a|&gt;1000，否则输出a+b的值。
输入样例:
18 -299 1001 -9 -1001 8 输出样例:
-281 |a|&gt;1000 |a|&gt;1000 我的代码：
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d2d0af1ccc532c7e8126ec3cdddd8bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c10e52712790d85517c82f3315c4a77f/" rel="bookmark">
			Linux编译器——gcc/g&#43;&#43;使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在上一篇，我们学习了关于文本编辑器 vim 的全部知识，今天给大家带来的是关于Linux编译器—gcc/使用的详细介绍。
本文目录
（一）温习程序的产生的过程
1、前言
2、程序的产生过程
3、🌜初步认识 gcc🌛
a） gcc的基本概念
b）gcc的基本特点
4、使用方法💻
（二）逐过程讲解🔥
1、 🤜 预处理 🤛 2、🤜 编译 🤛 3、🤜 汇编 🤛 4、🤜 链接 🤛 5、🔥巧记选项🔥
（三）动静态库的理解
1、前言摘要
2、ldd 指令
3、动静态库的理解
a）概念
b）区别
c）实例演示
d）总结动静态库的优缺点
（四）总结
（一）温习程序的产生的过程 1、前言 通过之前的学习，我们可以知道在 Linux 下编写C\CPP 程序时，在完成 .C 或 .CPP 文件的编写后，我们通常直接 gcc 或 g++ 后接文件名，就可以在当前文件夹下生成 a.out 可执行文件, 之后输入 ./a.out 即可执行该二进制可执行文件。
但实际上C语言程序从编写到运行，这期间的经历并不是这么简单，接下来我就带领大家对其探索一番，这期间具体有哪几个步骤？
2、程序的产生过程 从之前的知识来说，我们应该都知道程序的翻译经过几个阶段。我们会历经三个步骤，分别是：【预处理阶段】——&gt;【编译阶段】——&gt;【链接阶段】。但是如果我们分的更细一点，其实我们可以分成四个步骤：
通常 gcc 命令后面不加选项的话，就会默认执行 预处理、编译、汇编、链接所有步骤，若程序没有错误的话，我们就可以得到一个可执行文件，默认为 a.out， 也就是上述我代码中出现的。
3、🌜初步认识 gcc🌛 有了上述的铺垫之后，接下来我们讲讲什么是 gcc吧！！先让大家有了认识，以便我们后序的深入学习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c10e52712790d85517c82f3315c4a77f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3453de8659e681ba66e4f0633c78e91c/" rel="bookmark">
			nextcloud管理手册 --- 安装和服务器配置（在Linux上安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux上安装 部署建议在Linux上安装手动安装前提条件Apache Web服务器配置其他Apache配置 漂亮的url启用SSL安装向导SELinux配置提示Php.ini配置说明Php-fpm配置说明其他Web服务器在Windows上安装(虚拟机)通过Snap包安装通过VPS或web空间上的web安装程序进行安装在TrueNAS上安装通过安装脚本安装 部署建议 在我们的客户门户中查找针对企业的最新部署建议。
在Linux上安装 如果你更喜欢从源tarball安装，你可以使用经典的LAMP堆栈(Linux, Apache, MySQL/MariaDB, PHP)从头开始安装Nextcloud。本文档提供了使用Nextcloud .tar归档文件在Ubuntu 18.04 LTS服务器(Apache和MariaDB)上安装Nextcloud的完整操作。建议使用该方法安装Nextcloud。
支持selinux的发行版(如CentOS、Fedora和Red Hat Enterprise Linux)的管理员可能需要设置新规则以启用安装Nextcloud。有关建议的配置，请参阅SELinux配置提示。
如果你喜欢更自动化的Nextcloud安装，而你的Linux发行版没有软件包，你可以选择安装社区Snap软件包。这包括一个完整的生产就绪堆栈，将为您维护HTTPS证书，并将根据需要自动更新以保持安全。您也可以使用Nextcloud VM脚本直接安装在干净的Ubuntu服务器或NextcloudPi脚本(类似的基于Debian的项目)。它将为你设置一切，包括自动安装应用程序的脚本，如Collabora, OnlyOffice, Talk等等。请注意，Nextcloud GmbH不正式支持这三个选项。
本安装指南概述了所需的依赖项及其配置。对于特定于发行版的安装指南，请查看Ubuntu 22.04 LTS上的示例安装和CentOS 8上的示例安装。
手动安装前提条件 Nextcloudtar归档文件包含所需的所有PHP模块。本节列出所有必需和可选的PHP模块。有关模块的更多信息，请参阅PHP手册。您的Linux发行版应该包含所有必需模块的包。您可以通过输入php -m | grep -i &lt;module_name&gt;来检查模块是否存在。如果得到一个结果，则该模块存在。
要求:
PHP (有关支持的版本列表，请参阅系统要求)PHP module ctypePHP module curlPHP module domPHP module fileinfo (included with PHP)PHP module filter (only on Mageia and FreeBSD)PHP module GDPHP module hash (only on FreeBSD)PHP module JSON (included with PHP &gt;= 8.0)PHP module libxml (Linux package libxml2 must be &gt;=2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3453de8659e681ba66e4f0633c78e91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e0bee31d8ffe7abd28915e10e78a87c/" rel="bookmark">
			mac系统允许从任何途径安装软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sudo spctl --master-disable 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d445b734834be6588062b25576e311/" rel="bookmark">
			c&#43;&#43; 基础特性 内联函数和友元函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 友元函数 类的友元函数是定义在类的外部，但是有权访问类的所有私有成员和保护成员，尽管友元函数的原型在类的定义中出现过，但是友元函数不是类的成员函数。
友元可以是一个类、也可以是一个函数，但是需要声明一个函数为一个雷的友元需要在类的定义中该声明函数的原型需要使用关键字friend.
class Box { double width; public: double length; friend void printWidth( Box box ); void setWidth( double wid ); }; #include &lt;iostream&gt; using namespace std; class Box { double width; public: friend void printWidth( Box box ); void setWidth( double wid ); }; // 成员函数定义 void Box::setWidth( double wid ) { width = wid; } // printWidth() 不是任何类的成员函数 void printWidth( Box box ) { /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */ cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11d445b734834be6588062b25576e311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca64e7daac8a782bc1f0620c91ff906/" rel="bookmark">
			爱心代码——C语言特供
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情人节到了，作为一名额.......（虽说单身，但不想承认），我们拥有属于我们的浪漫。
这里我总结了几种常见的爱心代码，简单易上手。
一.这是一种最为常见的爱心代码 #include&lt;stdio.h&gt; #include&lt;Windows.h&gt; int main() { float x, y, a; for (y = 1.5; y &gt; -1.5; y -= 0.1) { for (x = -1.5; x &lt; 1.5; x += 0.05) { a = x * x + y * y - 1; putchar(a * a * a - x * x * y * y * y &lt;= 0.0 ? '*' : ' '); } system("color 0c"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ca64e7daac8a782bc1f0620c91ff906/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/94/">«</a>
	<span class="pagination__item pagination__item--current">95/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/96/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>