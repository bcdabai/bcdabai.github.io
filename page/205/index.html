<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c978230e35890c6a56110f5d33cd0d20/" rel="bookmark">
			c语言启用网络网络,c&#43;&#43; 以编程方式禁用/启用网络接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我试图提出一个解决方案，以编程方式启用/禁用网卡 – 我做了大量的研究，在XP和Vista环境中似乎都不是一个可行的解决方案。我在说的是，如果您进入控制面板的“网络连接”，右键单击并选择启用或禁用。理想情况下，我想使用一个图书馆，但如果更糟糕的是，我可以打电话给一个命令行程序，但绝对是最坏的情况。这是我迄今为止所尝试过的，何处/为什么他们失败：
这个上一篇文章：
列出了几种方法 – 第一种是使用netsh，这似乎与使用IPHelper函数SetIfEntry()相同。这样做的问题是它将接口设置为管理启用或禁用，而不是正常启用/禁用，因此它实际上不会关闭NIC。
提出的另一个解决方案是使用WMI，特别是具有Enable和Disable方法的Win32_NetworkAdapter类：
好吗？在Vista中工作正常，这些方法在普通XP安装中不存在…
另一个建议是使用DevCon，它真正使用了SetupAPI，特别是具有DICS_ENABLE的SetupDiSetClassInstallParams()。在这个美好的课堂上花了无数小时，并尝试在全球一级以及特定的配置级别(和每个组合)中禁用/启用设备，它不会始终如一地工作 – 有时工作正常，但其他时间禁用设备管理器中的设备，但仍然将其置于网络连接中并运行。
然后我尝试使用INetConnection接口，特别是INetConnection-&gt;连接/断开连接：
但是我从来没有能够对Vista或XP测试盒上的连接产生任何影响。
最后，我发现这个C#脚本叫做ToggleNic：
看起来它通过壳牌以某种方式有效地导致右键单击行为。限制(至少这个实现)是在非英语系统上不起作用(不需要修改)，我需要我的工作。为了公平起见，这个解决方案看起来是最可行的，但是我对C#的熟悉度很低，我找不到它所使用的API是否可用于C。
任何帮助或见解将不胜感激 – 或者关于如何完成C语言脚本的想法。谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878f79e752cb95cf674c68bf078a49a0/" rel="bookmark">
			c语言二级最后一道题运行是灰色的,2003年4月全国计算机等级考试二级C语言笔试试题及答案...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2003年4月全国计算机等级考试二级C语言笔试试题及答案
选择题((1)～(40)每小题1分，(41)～(55)每小题2分，共60分)
下列各题 A、B、C、D．四个选项中，只有一个选项是正确的，请将正确选项涂写在答题卡相应位置上，答在试卷上不得分。
(1) 用8位无符号二进制数能表示的最大十进制数为
A．127
B．128
C．255
D．256
(2) 在64位高档微机中，一个字长所占的二进制位数为
A．8 B．16
C．32 D．64
(3) 在Windows环境下，为了复制一个对象，在用鼠标拖动该对象时应同时按住
A．Alt键
B．Esc键
C．Shift键
D．Ctrl键
(4) 在Windows菜单中，暗淡(灰色)的命令项表示该命令
A．暂时不能用
B．正在执行
C．包含下一层菜单
D．包含对话框
(5) 在DOS环境下，为了得到TYPE命令的帮助信息，正确的DOS命令为
A．TYPE
B．TYPE/H
C．TYPE/*
D．TYPE/?
(6) 下列选项中，能作为合法DOS文件名的是
A．ANP/A.DAT
B．ABCCOM
C．ECD.BASIC
D．XY+Z.TXT
(7) 下列叙述中正确的是
A．在Windows环境下，最大化的窗口是不能移动的
B．在Windows环境下，应用程序窗口最小化后，该应用程序暂停执行
C．在Windows环境下，只有最小化的窗口才能关闭
D．在Windows环境下，不能关闭最大化的窗口
(8) 在Windows环境下，工具栏中的复制按钮是
A．打印机图标
B．剪刀标志
C．复制标志
D．粘贴标志
(9) 在Windows98环境下，若要将整个屏幕上显示的内容存入剪贴板，可以按
A．Ctrl+PrintScreen键
B．Alt+PrintScree键
C．Shift+PrintScreen键
D．PrintScreen键
(10) 目前，计算机病毒扩散最快的途径是
A．通过软件复制
B．通过网络传播
C．通过磁盘考贝
D．运行游戏软件
(11) 以下叙述中正确的是
A．C语言比其他语言高级
B．C语言可以不用编译就能被计算机识别执行
C．C语言以接近英语国家的自然语言和数学语言作为语言的表达形式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878f79e752cb95cf674c68bf078a49a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424cc89037fd04e977076bfd851aba74/" rel="bookmark">
			flink-addSource和addSink分别是kafka、自定义数据、mysql、hbase的java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flink主程序 public class FinkTest { public static void main(String[] args) throws Exception{ StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime);//摄入时间 //env.enableCheckpointing(5000); //创建kafka-topic Properties p = LoadResourcesUtils.getProperties("kafka.properties"); String inputTopic = p.getProperty("source.inputTopic"); String outputTopic = p.getProperty("source.outputTopic"); //kafka addSource DataStream&lt;String&gt; kafkaStream = env.addSource(KafkaStreamBuilder.kafkaConsumer(inputTopic)); //kafka addSink kafkaStream.addSink(KafkaSink.KafkaProducer(driversTopicPattern)); //mysql addSink kafkaStream.addSink(new OrderMySqlSink()); //hbase addSink kafkaStream..addSink(new HbaseSink(configs.topicOut)); //自定义 addSource DataStream&lt;String&gt; myStream = env.addSource(new MySource()); //mysql addSource DataStream&lt;String&gt; driverStream = env.addSource(new MySqlSource()); env.execute("my flink job"); } } addSource(kafka) import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/424cc89037fd04e977076bfd851aba74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b31a4673da14e3d30d34194b2413dec/" rel="bookmark">
			Java封装OkHttp3工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：如漩涡
https://blog.csdn.net/m0_37701381
Java封装OkHttp3工具类，适用于Java后端开发者
说实在话，用过挺多网络请求工具，有过java原生的，HttpClient3和4，但是个人感觉用了OkHttp3之后，之前的那些完全不想再用了。怎么说呢，代码轻便，使用起来很很很灵活，响应快，比起HttpClient好用许多。当然，这些是我个人观点，不喜勿喷。
准备工作 Maven项目在pom文件中引入jar包
&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt; &lt;/dependency&gt; 引入json是因为工具类中有些地方用到了，现在通信都流行使用json传输，也少不了要这个jar包
工具类代码 import com.alibaba.fastjson.JSON; import okhttp3.*; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSocketFactory; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import java.io.IOException; import java.net.URLEncoder; import java.security.SecureRandom; import java.security.cert.X509Certificate; import java.util.LinkedHashMap; import java.util.Map; import java.util.concurrent.Semaphore; import java.util.concurrent.TimeUnit; public class OkHttpUtils { private static volatile OkHttpClient okHttpClient = null; private static volatile Semaphore semaphore = null; private Map&lt;String, String&gt; headerMap; private Map&lt;String, String&gt; paramMap; private String url; private Request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b31a4673da14e3d30d34194b2413dec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb15df1a99746a17b645104b19222261/" rel="bookmark">
			【java小白入门篇】eclipse 经典快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发者的技术功底 1）打字速度 80字/每分钟
2）全面使用快捷键快速开发
基础 Ctrl+S 保存文档
Ctrl+Shift+S 保存所有
Ctrl+/ 注释，取消
Alt+/ 代码助手
Ctrl+1 快速修复
Shift+Alt+L 快速提炼局部变量
Ctrl+Shift+F 代码格式，右键菜单source/format
快速输入 main main方法 psvm
syso 控制台打印 sout
for+Alt+/ for循环 Ctrl+Alt+space 代码补全
文档 Ctrl+D: 删除当前行
Ctrl+Alt+↓ 复制当前行到下一行(复制增加)
Ctrl+Alt+↑ 复制当前行到上一行(复制增加)
Alt+↓ 当前行和下面一行交互位置
Alt+↑ 当前行和上面一行交互位置
Ctrl+A 全部选中
Ctrl+C 复制
Ctrl+V 粘贴
Ctrl+X 剪切
Ctrl+Z 撤销
窗口 Ctrl+= 放大
Ctrl± 缩小
Ctrl+M 最大化或还原
高级 Ctrl+O 快速显示 OutLine
Ctrl+T 继承结构
Ctrl+Shift+T 源码类窗口
Ctrl+Shift+O 快速导包
调试 F7 单步返回
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb15df1a99746a17b645104b19222261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/239f12c1fe9b5b25adec5366db2f552a/" rel="bookmark">
			c语言如何给结构体赋初值,c/c&#43;&#43; 结构体赋初值的小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该楼层疑似违规已被系统折叠 隐藏此楼查看此楼
转：https://blog.csdn.net/datase/article/details/78988320
1.CC++结构体的初始化
今天看到项目中对自定义结构体初始化方式有点陌生，特在此罗列一下可用的结构体初始化的方式。
对结构体
struct A {
int b;
int c;
}
有几种初始化方式：
第一种：
struct A a = {
.b = 1,
.c = 2
};
第二种：
struct A a={
b:1,
c:2
}；
第三种：
struct A a1 = { 1, 2};
Linux内核喜欢用第一种，使用第一种和第二种时，成员初始化顺序可变。
第四种：
因为C++中的struct可以看作class，结构体也可以拥有构造函数，所以我们可以通过结构体的构造函数来初始化结构体对象。
给定带有构造函数的结构体：
struct A {
A(int a,int b){
this-&gt;a=a;
this-&gt;b=b;
};
int b;
int c;
}
那么结构体对象的初始化可以像类对象的初始化那样，如下形式：
struct A a(1,2);
注意： struct如果定义了构造函数的话，就不能用大括号进行初始化了，即不能再使用前三种初始化的方式了。
2.CC++结构体的赋值
变量的赋值和初始化是不一样的，初始化是在变量定义的时候完成的，是属于变量定义的一部分，赋值是在变量定义完成之后想改变变量值的时候所采取的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/239f12c1fe9b5b25adec5366db2f552a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42794f4d5ef7e5545a1ee69b15fdb1c5/" rel="bookmark">
			数据流中的中位数 c语言,41 数据流中的中位数（时间效率）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。
测试用例：
功能测试(从数据流中读出奇数个数字；从数据流中读出偶数个数字)
边界值测试(从数据流中读出0个、1个、2个数字)
解题思路：
1)push_heap/pop_heap
中位数左边的数据比其小(用最大堆实现左边的数据容器)中位数右边的数据比其大(用最小堆实现右边的数据容器)。往堆中插入一个数据的时间效率是O(logn)。由于只需要O(1)时间就可以得到位于堆顶的数据，因此得到中位数的时间复杂度是O(1)
实现细节：
保证数据平均分配到两个堆中。约定偶数个元素时，向右侧(最小堆插入元素)。此时要判断该元素与最大堆中的最大值的关系。要保证最大堆中的所有元素都小于最小堆。
注意最大堆是降序排列的，这样最大值才能保存在头部
最小堆是升序排列的，头部保存最小值
class Solution {
public:
void Insert(int num)
{
int size = maxV.size()+minV.size();
if((size &amp; 0x1) == 0){ //偶数个元素，向最小堆插入元素 //size &amp; 0x1 == 0
//插入的元素要比最大堆的所有元素大
if(maxV.size()&gt;0 &amp;&amp; num
//先将元素插入最大堆
maxV.push_back(num);
//重新排序
push_heap(maxV.begin(),maxV.end(),less()); //最大堆降序排列，头为最大元素
//去除最大元素
num = maxV[0];
//删除最大元素
pop_heap(maxV.begin(),maxV.end(),less());
maxV.pop_back();
}
minV.push_back(num);
push_heap(minV.begin(),minV.end(),greater()); //最小堆，升序排列，最前面的元素才最小
}else{ //奇数个元素，向最大堆插入元素
//要插入的元素应该比最小堆的所有元素都小
if(minV.size()&gt;0 &amp;&amp; num&gt;minV[0]){
minV.push_back(num);
push_heap(minV.begin(),minV.end(),greater());
num = minV[0];
pop_heap(minV.begin(),minV.end(),greater());
minV.pop_back();
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42794f4d5ef7e5545a1ee69b15fdb1c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced2dfff5effae744086c415708ff1be/" rel="bookmark">
			c语言编写一个用户登录界面,怎么用C语言编写个登陆界面?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "Head.h"
#include "Chinese.c"
#include "Mouse.c"
#include "Login.c"
#include "Exit.c"
#include "Window.c"
#include "OtIT.c"
#include "Scanf.c"
void initgr(void) /* BGI初始化 */
{
int gd = DETECT, gm = 0; /* 和gd = VGA,gm = VGAHI是同样效果 */
registerbgidriver(EGAVGA_driver);/* 注册BGI驱动后没成绩不需求.BGI文档的支持运行 */
initgraph(&amp;gd, &amp;gm, "");
if(graphresult())
{
printf ("Graphics isn't available...");
getch();exit(1);
}
MskindMath();/* 计算鼠标的样子*/
Msinit();
}
void main(void)
{
initgr();/* 初始化*/
Login(); /* 登录*/
Exit(); /* 退出*/
}
。。。。。。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f598306661a67de70aca8463971bfe/" rel="bookmark">
			c语言中倒金字塔数字图形怎么,C语言倒金字塔编程.ppt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言倒金字塔编程资料
项目一 套含空心金字塔图案 项目分析 1.输入一个程序判断奇偶性 奇数 不变 偶数 加一 2.先输出三角型前面的空格 推出公式：n+1-i 3.把空心三角形分为两部分 输出， 红色为正常输出， 蓝色为特殊输出。 4.在特殊输出是调用fun 正常输出时调用fun2 5.特殊输出时 输出“*” 输出“ ” 输出“*” “*”号满足公式： 2*(i-m+2)-1 “ ”满足公式： 2*i-1-2*[2*(i-m+2)-1] 6.正常输出时 满足公式：2*i-1 7.每行最后输出换行 * *** ***** ******* ********* *********** *** *** ***** ***** ******* ******* ********* ********* ********************* 流程图 Fun(i,m)的调用程序框图 Fun2(i)的调用程序框图 源程序 #include int fun(int i,int m) { int j; for(j=1;j&lt;=2*(i-m+2)-1;j++) //输出“*” printf("*"); for(j=1;j&lt;=4*m-2*i-7;j++) printf(" ");//2*i-1-2*[2*(i-m+2)-1] for(j=1;j&lt;=2*(i-m+2)-1;j++) printf("*"); return 0; } main() {int n,i,j,m; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24f598306661a67de70aca8463971bfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/139a0ee0b250b1b9b63aae4cc5cb090b/" rel="bookmark">
			Linux下安装数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为闪耀太阳原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
原文链接：https://blog.csdn.net/qq_16804847/article/details/108450506
Linux安装MariaDB数据库 1. 下载MariaDB数据库 测试: 当前虚拟机是否可以正确的链接外网.
命令:
[root@localhost src]# yum install mariadb-2安装mariadb数据库 [root@localhost src]# yum clean all 清空已安装文件 如果下载失败之后执行的 2 确认下载 3 安装完成提示 4 数据库启动 命令:
启动命令 [root@localhost src]# systemctl start mariadb 重启命令 [root@localhost src]# systemctl restart mariadb 关闭命令 [root@localhost src]# systemctl stop mariadb 设定开机自起 [root@localhost src]# systemctl enable mariadb 关闭开机自起 [root@localhost src]# systemctl disable mariadb 5. 数据库初始化操作 命令: `mysql_secure_installation’
6. 测试数据库用户名和密码是否有效 7.导入数据表 说明:如果mysql数据库需要导入数据表命令如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/139a0ee0b250b1b9b63aae4cc5cb090b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2657887083687d872d9fba40cc2bd347/" rel="bookmark">
			华为：HarmonyOS 即将开源！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理 | 晋兆雨
出品 | CSDN（ID：CSDNnews）
5 月 24 日，在鸿蒙开发者创新大赛颁奖典礼上，华为消费者业务软件部总裁王成录宣布：HarmonyOS 将会开源开放，并在武汉大学等15个学校开展 HarmonyOS 课程。
实际上，早在 5 月 18 日的华为鸿蒙伙伴峰会上，华为 AI 与智慧场景业务部副总裁杨海松就曾宣布，HarmonyOS 在今年将依次对 128MB 到 4GB 的设备进行全栈系统开源开放，并且承诺华为不会有任何保留。 针对 HarmonyOS，华为的态度就是：完全开源开放。据了解，华为去年针对内存 128KB-128MB 的终端设备就已经进行了全栈的开源，今年则将按照既定计划做到内存 128MB-4GB 的终端设备全栈系统开源开放。
同时，华为方面表示非常欢迎第三方的手机厂商使用 HarmonyOS。
在世界范围内，手机操作系统市场一直是 iOS 系统和 Android 系统二分天下。如今华为终于宣布要开发自己的操作系统，走上了一条充满艰辛的探索之路。
回顾这几年来 HarmonyOS 的动向，会发现“开源”是必走的一步棋。
2019 年 8 月 9 日，HarmonyOS 在东莞举行的华为开发者大会正式发布。HarmonyOS 的定位是一款全场景分布式 OS，打造的“1+8+N”战略。以华为手机为核心，以电脑、平板、智能电视、智能音箱、智能手表、耳机、华为眼镜、华为车机等产品为全场景辅助设备；面向移动办公、智能家居、运动健康、影音娱乐及智能出行各大场景，提供无缝连接式智慧生活体验。
HarmonyOS 有三层架构，第一层是内核，第二层是基础服务，第三层是程序框架。
2020 年 9 月 10 日，在华为开发者大会 2020 上，华为正式发布 HarmonyOS 2.0 版本。与首先应用在荣耀智慧屏上的 HarmonyOS 1.0 不同，HarmonyOS 2.0 将由智慧屏扩展到更多的华为终端设备，如华为穿戴设备、手机、平板等。
2020 年 12 月，华为在开发者活动上正式发布了 HarmonyOS 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2657887083687d872d9fba40cc2bd347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342f115b1373c180ef72346fd0b33a4f/" rel="bookmark">
			DM DSC动态扩展节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在第三台机器上使用 DMASMCMD 工具 export 出备份 dmdcr_cfg_bak.ini
[dmdba@localhost bin]$ ./dmasmcmd DMASMCMD V8 ASM&gt;export dcrdisk '/dev/raw/raw1' to '/home/dmdba/dmdbms/data/dmdcr_cfg_bak.ini' ASMCMD export DCRDISK success.Used time: 95.013(ms). 2、为新增节点准备日志文件 ，至少两个日志文件，路径必须是 ASM 文件格式
SQL&gt; alter database add node logfile '+DMLOG/log/dsc2_log01.log' size 2048,'+DMLOG/log/dsc2_log02.log' size 2048; 操作已执行 1）使用 dmasmtool 工具登录 ASM 文件系统，也可以看到新增的节点日志文件
[dmdba@localhost bin]$ ./dmasmtool DCR_INI=/home/dmdba/dmdbms/data/dmdcr.ini DMASMTOOL V8 ASM&gt;cd DMLOG +DMLOG Used time: 1.872(ms). ASM&gt;ls dir : log total count 1. Used time: 2.331(ms). ASM&gt;cd log +DMLOG/log Used time: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/342f115b1373c180ef72346fd0b33a4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c259b9ba0be35e50d30cb76a998c49c6/" rel="bookmark">
			C语言判断m数为素数,判断数m是否为素数 c语言求素数的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写一C程序判断M是否为素数？
素数是一个因子只有1和自身的数，因为它可以被它自己的数从&amp;GT1到&amp;lt除去，如果它不能被完全除，它就是一个素数。
Int main(){
Int n=0
Int m=0
printf(“输入整数m:”)
scanf(\%d“，&amp;ampm)
for(Int i=2I&amp;ltmi){
if(m%i==0){
n]}]}
if(n==0){
printf(\%d是质数)。\N“，m)
}否则{
printf(\%d)不是素数。\N“，m)
}
返回0
}
C语言编程判断m是否为素数？
2。接下来，编写主程序。素数是一个只能被1和它本身除的数。因此，要判断一个整数m是否是素数，只需去掉2到m根之间的每一个整数，如果m不能被2到m根之间的任何整数整除，则m必须是素数。所以最好先使用sqrt来找到Q，然后使用for循环来计算每个数字：3。编程后，可以查看结果。在这里，输入17，程序判断17是一个素数。再输入几个数字之后，您会发现程序可以完美地运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc9cd86b1e0f9390145b83d077a11b9/" rel="bookmark">
			Java两数相除四舍五入保留4位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 例：
double a = 5; double b = 11; double num = a/b; BigDecimal b1 = new BigDecimal(num); //保留四位小数 double xxx= b1.setScale(4, BigDecimal.ROUND_HALF_UP).doubleValue(); System.out.println(xxxx); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc6f51e7b5c64f2909ebe99baa87fda/" rel="bookmark">
			数据结构与算法--二叉树之线索二叉树（前序、中序、后序）思路以及代码实现。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线索二叉树 1.先序线索二叉树2.后序线索二叉树3.中序线索二叉树4.代码打印结果： 1.先序线索二叉树 思路：
沿类似于上图中的先序遍历路径行走，如果发现左孩子结点或右孩子结点为空（也就是度为1或者0的结点），把它们的左空孩子结点指向它的前驱结点，把它们的右空孩子结点指向它的后继结点。当没有前驱或者后继结点时不用指。
关于如何找到它们的前驱或后继结点？
如下图：
我们可以通过图中（+）加号的看出路径，可以得到先序遍历的顺序为：
1 2 4 5 3 6 8 7
我们以图中结点4为例子：
4为叶子结点，所以它的左右孩子结点都为空结点，我们可以从先序遍历的顺序看出，4的前驱结点为2，4的后继结点为5，其他同理可得，所以得到如图的连线。
我们把上图用代码表示出来，我们使用链式存储结构，让上图可视化：
由五个域组成
lichild:用来存储左孩子所在的链结点存储地址。
lTag:当ITag为0表示左孩子结点不空;为1表示空。
rchild:用来存储右孩子所在的链结点存储地址。
rTag:当rTag为1表示右孩子结点不空;为1表示空。
data:用来存储数据。
和我们使用的是先序遍历的递归很像。顺序为：
根结点-&gt;左子树-&gt;右子树
代码如下：
void _preThread(BTNode&lt;T&gt; *p,BTNode&lt;T&gt; *&amp;pre) { if(p!=NULL) { //当遇到左结点为NULL时，把左孩子结点指向前驱结点；把lTag设为1，表示左孩子结点为空 if(p-&gt;lchild==NULL) { p-&gt;lchild=pre; p-&gt;lTag=1; } //当遇到结点不为空且右孩子结点为NULL时，把右孩子结点指向后继结点；把rTag设为1，表示右孩子结点为空 if(pre!=NULL&amp;&amp;pre-&gt;rchild==NULL) { pre-&gt;rchild=p; pre-&gt;rTag=1; } //根结点 pre=p; //左子树 if(p-&gt;lTag==0) _preThread(p-&gt;lchild,pre); //右子树 if(p-&gt;rTag==0) _preThread(p-&gt;rchild,pre); } } 虽然我们实现了先序线索二叉树 ，但是要使用它来遍历打印出数据。
思路：
首先指向根结点，然后根结点的，左子结点，左子结点的左子结点…不为空的话，就沿路打印出所到结点；然后当左结点为空时，指向它的右子结点（部分右子结点是他的后继结点）；然后继续判断左结点是否为空，这样循环就可以打印出我们想要的数据了。
打印路径：如图红色线条
因为我们没有用前驱结点，我就把它删掉了。后面的后序遍历我们就只使用前驱结点，没使用后继结点。
代码表示：
//线索二叉树前序遍历 void preThread() { BTNode&lt;T&gt; *p=NULL; BTNode&lt;T&gt; *root=_root; _preThread(root,p); while(root!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fc6f51e7b5c64f2909ebe99baa87fda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fc38bacf2c6131fce6a86ea7e9b9222/" rel="bookmark">
			技术分析之基于Python实现MA、MACD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Tushare获得一只股票，这里只供参考，不做投资建议。
stock_name = '600519.SH' ts.set_token('**********') pro = ts.pro_api() df_whole = pro.daily(ts_code=stock_name, start_data='20200501', end_data='20200507') df_whole['trade_date'] = pd.to_datetime(df_whole['trade_date'], format='%Y%m%d') df_whole.set_index('trade_date', inplace=True) df_whole = df_whole[1:300] df_whole = df_whole.sort_index(ascending=True) 首先MA(Moving Average)是一个移动平均线，类似于一个低通滤波器。在MACD计算过程中，MA取值取值区间为12，26。也就是说将一只股票的收盘价作为时间序列，去取12天作为一个区间，计算这12天内股票收盘价的一个加权平均数，同理26天类似。我认为，12天的MA可以等价于快线，而26天MA可以等价于慢线。下面展示12天、26天MA的计算方式。
df = df_whole['close'] df_whole['EMA_12_unadj'] = pd.Series.ewm(df, span=12, adjust=False).mean() df_whole['EMA_26_unadj'] = pd.Series.ewm(df, span=26, adjust=False).mean() 这两条MA的差值我定义为MACD，将所得结果取3日指数平均得到信号线，代码如下所示：
MACD = df_whole['EMA_12_unadj'] - df_whole['EMA_26_unadj'] df_whole['MACD'] = MACD df_whole['Signal_line'] = pd.Series.ewm(MACD, span=3, adjust=False).mean() 取MACD与Signal-line的插值作为histogram，代码如下：
histogram = df_whole['MACD'] - df_whole['Signal_line'] df_whole['Histogram'] = histogram 接下来对所获得的数据绘图，如下所示：
ax1 = plt.subplot2grid((9,10), (0, 0), rowspan=7, colspan=10) ax2 = plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fc38bacf2c6131fce6a86ea7e9b9222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/346dc60ae1cf917031420a17563b994c/" rel="bookmark">
			QCustomplot之安装篇（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好！这里是QCustomplot专栏，由于课题组项目的需要，在经历一段时间的开发后，有所收获。因此想开辟这样一个专栏，记录QCustomplot的一些使用技巧和干货。本篇主要介绍QCupstomplot是什么，能干什么，以及如何去安装，后续也会继续分享相关的实用技能，帮助大家快速地开发好用易用的绘图功能。
1 what is QCupstomPlot? QCustomPlot是QT的一个图标库，是QT中数据可视化的利器，可以绘制包括且不限于高质量、美观的静态/动态曲线，柱状图，蜡烛图，频谱图等，涉及到实验相关的同学可以自己做一个这样的实时绘图功能软件还是比较加分的。
2 How to use it? 第一步： 从官网获取最新的包：https://www.qcustomplot.com/index.php/download
点击QCustomPlot.tar.gz下载解压即可。
第二步： 将文件夹中的qcutomplot.cpp和qcustomplot.h加入至自己的工程中。
具体操作：将这两个文件拷贝至工程文件下面，然后打开项目，右击鼠标，点击添加现有文件，将qcutomplot.cpp和qcustomplot.h添加进来。
第三步： 配置项目
在pro文件中，添加printsupport
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets printsupport 在自己用到的项目头文件中包含该类
#include "qcustomplot.h" 第四步： 提升Widget为QCustomPlot
在设计界面中，将widget控件拖出来，单击右键，然后点击“提升”。
在提升的类名称和头文件两栏按照上图输入，然后点击“提升”即可。完成之后，再次右击widget点击“提升为”，点击“qcustomplot”就可以了。至此就可以实现对qcutomplot类的操作了。
3 At last 如果有帮到您请点个赞再走嗷！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32425b68eb79d8f56ef949fe4f2019c/" rel="bookmark">
			从零开始的临时会话WEB项目（基于SSM框架）（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面把用户登录弄好了，现在开始做websocket
后端代码： package com.wc.controller; import java.io.IOException; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import javax.websocket.OnClose; import javax.websocket.OnError; import javax.websocket.OnMessage; import javax.websocket.OnOpen; import javax.websocket.Session; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import org.apache.log4j.Logger; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import com.alibaba.fastjson.JSONObject; import com.wc.service.MessageService; @ServerEndpoint("/WebSocketServer/{userId}") public class WebSocket { @Autowired @Qualifier("messageService") private MessageService messageService; private static Logger log = Logger.getLogger(WebSocket.class); // 在线人数 private static int onlineCount = 0; // 在线用户列表 private static Map&lt;String, WebSocket&gt; clients = new ConcurrentHashMap&lt;String, WebSocket&gt;(); private Session session; private String userId; // 连接Socket触发 @OnOpen public void onOpen(@PathParam("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e32425b68eb79d8f56ef949fe4f2019c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238a4cf776a88af94b139dbc0f7fc334/" rel="bookmark">
			springboot项目功能之验证码的接口编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 验证码主要就两个部分
得到一个验证码图片得到验证码的答案 其他的就交给前端了,嘻嘻
步骤一 引入需要的依赖
&lt;!--验证码 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; 步骤二 两个工具类
1.CaptchaConfig 配置图片的属性类
2.KaptchaTextCreator 重写了DefaultTextCreator,改为数字的乘减除
1.CaptchaConfig
@Configuration public class CaptchaConfig { @Bean(name = "captchaProducer") public DefaultKaptcha getKaptchaBean() { DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); Properties properties = new Properties(); // 是否有边框 默认为true 我们可以自己设置yes，no properties.setProperty(KAPTCHA_BORDER, "yes"); // 验证码文本字符颜色 默认为Color.BLACK properties.setProperty(KAPTCHA_TEXTPRODUCER_FONT_COLOR, "black"); // 验证码图片宽度 默认为200 properties.setProperty(KAPTCHA_IMAGE_WIDTH, "80"); // 验证码图片高度 默认为50 properties.setProperty(KAPTCHA_IMAGE_HEIGHT, "38"); // 验证码文本字符大小 默认为40 properties.setProperty(KAPTCHA_TEXTPRODUCER_FONT_SIZE, "25"); // KAPTCHA_SESSION_KEY properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238a4cf776a88af94b139dbc0f7fc334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a01b0bb1bbf75fc0ffd11c905e2f95d8/" rel="bookmark">
			学习率不同导致损失值不同的问题以及不同的epoch过程中损失值的变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天写程序发现学习率不同导致训练中的损失值有着明显的差异，
在我使用learning_rate = 0.001的时候，损失值上来为5…，而当我使用learning_rate = 0.00001的时候，损失值上来就为8.3309e-04，所以损失值会影响刚开始的学习率？？？
不同的epoch过程之中损失值的变化不同，第一个epoch到第二个epoch之间损失值一般会下降的较为明显，因为此时模型已经经历过第一波数据的训练了，而第二个epoch之后的损失值往往变化得不是特别明显，因为此时模型已经达到了一个比较好的状态了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f4fc09ef4d9f78c608e9fbb4d1dcbe9/" rel="bookmark">
			两年滴滴和头条的后端开发经验！字字都是肺腑之言！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | syntax_error
来源 | https://www.nowcoder.com/discuss/351805
先简单交代一下背景吧，某不知名985的本硕，17年毕业加入滴滴，当时找工作时候也是在牛客这里跟大家一起奋战的。
今年下半年跳槽到了头条，一直从事后端研发相关的工作。之前没有实习经历，算是两年半的工作经验吧。
这两年半之间完成了一次晋升，换了一家公司，有过开心满足的时光，也有过迷茫挣扎的日子，不过还算顺利地从一只职场小菜鸟转变为了一名资深划水员。
在这个过程中，总结出了一些还算实用的划水经验，有些是自己领悟到的，有些是跟别人交流学到的，在这里跟大家分享一下。
学会深入思考，总结沉淀 我想说的第一条就是要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。
先来说深入思考。在程序员这个圈子里，常能听到一些言论：我这个工作一点技术含量都没有，每天就CRUD，再写写if-else，这TM能让我学到什么东西？抛开一部分调侃和戏谑的论调不谈，这可能确实是一部分同学的真实想法，至少曾经的我，就这么认为过。后来随着工作经验的积累，加上和一些高level的同学交流探讨之后，我发现这个想法其实是非常错误的。之所以出现没什么可学的这样的看法，基本上是思维懒惰的结果。任何一件看起来很不起眼的小事，只要进行深入思考，稍微纵向挖深或者横向拓宽一下，都是足以让人沉溺的知识海洋。
举一个例子。某次有个同学跟我说，这周有个服务OOM了，查了一周发现有个地方defer写的有问题，改了几行代码上线修复了，周报都没法写。可能大家也遇到过这样的场景，还算是有一定的代表性。其实就查bug这件事来说，是一个发现问题，排查问题，解决问题的过程，包含了触发、定位、复现、根因、修复、复盘等诸多步骤，花了一周来做这件事，一定有不断尝试与纠错的过程，这里面其实就有很多思考的空间。比如说定位，如何缩小范围的？走了哪些弯路？用了哪些分析工具？比如说根因，可以研究的点起码有linux的OOM，k8s的OOM，go的内存管理，defer机制，函数闭包的原理等等。如果这些真的都不涉及，仍然花了一周时间做这件事，那复盘应该会有很多思考，提出来几十个WHY没问题吧...
再来说下总结沉淀。这个我觉得也是大多数程序员比较欠缺的地方，只顾埋头干活，可以把一件事做的很好。但是几乎从来不做抽象总结，以至于工作好几年了，所掌握的知识还是零星的几点，不成体系，不仅容易遗忘，而且造成自己视野比较窄，看问题比较局限。适时地做一些总结沉淀是很重要的，这是一个从术到道的过程，会让自己看问题的角度更广，层次更高。遇到同类型的问题，可以按照总结好的方法论，系统化、层次化地推进和解决。
还是举一个例子。做后台服务，今天优化了1G内存，明天优化了50%的读写耗时，是不是可以做一下性能优化的总结？比如说在应用层，可以管理服务对接的应用方，梳理他们访问的合理性；在架构层，可以做缓存、预处理、读写分离、异步、并行等等；在代码层，可以做的事情更多了，资源池化、对象复用、无锁化设计、大key拆分、延迟处理、编码压缩、gc调优还有各种语言相关的高性能实践...等下次再遇到需要性能优化的场景，一整套思路立马就能套用过来了，剩下的就是工具和实操的事儿了。
还有的同学说了，我就每天跟PM撕撕逼，做做需求，也不做性能优化啊。先不讨论是否可以搞性能优化，单就做业务需求来讲，也有可以总结的地方。比如说，如何做系统建设？系统核心能力，系统边界，系统瓶颈，服务分层拆分，服务治理这些问题有思考过吗？每天跟PM讨论需求，那作为技术同学该如何培养产品思维，引导产品走向，如何做到架构先行于业务，这些问题也是可以思考和总结的吧。就想一下，连接手维护别人烂代码这种蛋疼的事情，都能让Martin Fowler整出来一套重构理论，还显得那么高大上，我们确实也没啥必要对自己的工作妄自菲薄...
所以说学习和成长是一个自驱的过程，如果觉得没什么可学的，大概率并不是真的没什么可学的，而是因为自己太懒了，不仅是行动上太懒了，思维上也太懒了。
可以多写技术文章，多分享，强迫自己去思考和总结，毕竟如果文章深度不够，大家也不好意思公开分享。
积极学习，保持技术热情 最近两年在互联网圈里广泛传播的一种焦虑论叫做35岁程序员现象，大意是说程序员这个行业干到35岁就基本等着被裁员了。不可否认，互联网行业在这一点上确实不如公务员等体制内职业。但是这个问题里35岁程序员并不是绝对生理意义上的35岁，应该是指那些工作十几年和工作两三年没什么太大区别的程序员。后面的工作基本是在吃老本，没有主动学习与充电，35岁和25岁差不多，而且没有了25岁时对学习成长的渴望，反而添了家庭生活的诸多琐事，薪资要求往往也较高，在企业看来这确实是没什么竞争力。
而如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了35岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？但是学习这件事，其实是一个反人类的过程，这就需要我们强迫自己跳出自己的安逸区，主动学习，保持技术热情。在滴滴时有一句话大概是，主动跳出自己的舒适区，感到挣扎与压力的时候，往往是黎明前的黑暗，那才是成长最快的时候。相反如果感觉自己每天都过得很安逸，工作只是在混时长，那可能真的是温水煮青蛙了。
刚毕业的这段时间，往往空闲时间还比较多，正是努力学习技术的好时候。借助这段时间夯实基础，培养出良好的学习习惯，保持积极的学习态度，应该是受益终身的。至于如何高效率学习，网上有很多大牛写这样的帖子，到了公司后内网也能找到很多这样的分享，我就不多谈了。
可以加入学习小组和技术社区，公司内和公司外的都可以，关注前沿技术。
主动承担，及时交流反馈 前两条还是从个人的角度出发来说的，希望大家可以提升个人能力，保持核心竞争力，但从公司角度来讲，公司招聘员工入职，最重要的是让员工创造出业务价值，为公司服务。虽然对于校招生一般都会有一定的培养体系，但实际上公司确实没有帮助我们成长的义务。而在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。我当初刚入职的时候，基本就是leader给分配什么任务就把本职工作做好，然后就干自己的事了，几乎从来不主动去跟别人交流或者主动去思考些能帮助项目发展的点子。自以为把本职工作保质保量完成就行了，后来发现这么做其实是非常不够的，这只是最基本的要求。而有些同学的做法则是leader只需要同步一下最近要做什么方向，下面的一系列事情基本不需要leader操心了 ，这样的同学我是leader我也喜欢啊。入职后经常会听到的一个词叫owner意识，大概就是这个意思吧。
在这个过程中，另外很重要的一点就是及时向上沟通反馈。项目进展不顺利，遇到什么问题，及时跟leader同步，技术方案拿捏不准可以跟leader探讨，一些资源协调不了可以找leader帮忙，不要有太多顾忌，认为这些会太麻烦，leader其实就是干这个事的。。如果项目进展比较顺利，确实也不需要leader介入，那也需要及时把项目的进度，取得的收益及时反馈，自己有什么想法也提出来探讨，问问leader对当前进展的建议，还有哪些地方需要改进，消除信息误差。做这些事一方面是合理利用leader的各种资源，另一方面也可以让leader了解到自己的工作量，对项目整体有所把控，毕竟leader也有leader，也是要汇报的。可能算是大家比较反感的向上管理吧，有内味了，这个其实我也做得不好。但是最基本的一点，不要接了一个任务闷着头干活甚至与世隔绝了，一个月了也没跟leader同步过，想着憋个大招之类的，那基本凉凉。
一定要主动，可以先从强迫自己在各种公开场合发言开始，有问题或想法及时one-one
除了以上几点，还有一些小点我觉得也是比较重要的，列在下面
第一件事建立信任 无论是校招还是社招，刚入职的第一件事是非常重要的，直接决定了leader和同事对自己的第一印象。入职后要做的第一件事一定要做好，最起码的要顺利完成而且不能出线上事故。这件事的目的就是为了建立信任，让团队觉得自己起码是靠谱的。如果这件事做得比较好，后面一路都会比较顺利。如果这件事就搞杂了，可能有的leader还会给第二次机会，再搞不好，后面就很难了，这一条对于社招来说更为重要。
而刚入职，公司技术栈不熟练，业务繁杂很难理清什么头绪，压力确实比较大。这时候一方面需要自己投入更多的精力，另一方面要多跟组内的同学交流，不懂就问。最有效率的学习方式，我觉得不是什么看书啊学习视频啊，而是直接去找对应的人聊，让别人讲一遍自己基本就全懂了，这效率比看文档看代码快多了，不仅省去了过滤无用信息的过程，还了解到了业务的演变历史。当然，这需要一定的沟通技巧，毕竟同事们也都很忙。
脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。
超出预期 超出预期这个词的外延范围很广，比如leader让去做个值周，解答用户群里大家的问题，结果不仅解答了大家的问题，还收集了这些问题进行分类，进而做了一个智能问答机器人解放了值周的人力，这可以算超出预期。比如leader让给运营做一个小工具，结果建设了一系列的工具甚至发展成了一个平台，成为了一个完整的项目，这也算超出预期。超出预期要求我们有把事情做大的能力，也就是想到了leader没想到的地方，并且创造了实际价值，拿到了业务收益。这个能力其实也比较重要，在工作中发现，有的人能把一个小盘子越做越大，而有的人恰好反之，那么那些有创新能力，经常超出预期的同学发展空间显然就更大一点。
这块其实比较看个人能力，暂时没想到什么太好的捷径，多想一步吧。
体系化思考，系统化建设 这句话是晋升时候总结出来的，大意就是做系统建设要有全局视野，不要局限于某一个小点，应该有良好的规划能力和清晰的演进蓝图。比如，今天加了一个监控，明天加一个报警，这些事不应该成为一个个孤岛，而是属于稳定性建设一期其中的一小步。这一期稳定性建设要做的工作是报警配置和监控梳理，包括机器监控、系统监控、业务监控、数据监控等，预期能拿到XXX的收益。这个工作还有后续的roadmap，稳定性建设二期要做容量规划，接入压测，三期要做降级演练，多活容灾，四期要做...给人的感觉就是这个人思考非常全面，办事有体系有规划。
平时积极总结沉淀，多跟别人交流，形成方法论。
提升自己的软素质能力 这里的软素质能力其实想说的就是PPT、沟通、表达、时间管理、设计、文档等方面的能力。说实话，我觉得我当时能晋升就是因为PPT做的好了一点...可能大家平时对这些能力都不怎么关注，以前我也不重视，觉得比较简单，用时候直接上就行了，但事实可能并不像想象得那样简单。比如晋升时候PPT+演讲+答辩这个工作，其实有很多细节的思考在里面，内容如何选取，排版怎么设计，怎样引导听众的情绪，如何回答评委的问题等等。晋升时候我见过很多同学PPT内容编排杂乱无章，演讲过程也不流畅自然，虽然确实做了很多实际工作，但在表达上欠缺了很多，属于会做不会说，如果再遇到不了解实际情况的外部门评委，吃亏是可以预见的。
公司内网一般都会有一些软素质培训课程，可以找一些场合刻意训练。
以上都是这些分享还都算比较伟光正，但是社会吧也不全是那么美好的。。下面这些内容有负能量倾向，三观特别正的同学以及观感不适者建议跳过。
拍马屁是真的香 拍马屁这东西入职前我是很反感的，我最初想加入互联网公司的原因就是觉得互联网公司的人情世故没那么多，事实证明，我错了...入职前几天，部门群里大leader发了一条消息，后面几十条带着大拇指的消息立马跟上，学习了，点赞，真不错，优秀，那场面，说是红旗招展锣鼓喧天鞭炮齐鸣一点也不过分。除了惊叹大家超强的信息接收能力和处理速度外，更进一步我还发现，连拍马屁都是有队形的，一级部门leader发消息，几个二级部门leader跟上，后面各组长跟上，最后是大家的狂欢，让我一度怀疑拍马屁的速度就决定了职业生涯的发展前景（没错，现在我已经不怀疑了）。
坦诚地说，我到现在也没习惯在群里拍马屁，但也不反感了，可以说把这个事当成一乐了。倒不是说我没有那个口才和能力（事实上也不需要什么口才，大家都简单直接），在某些场合，为活跃气氛的需要，我也能小嘴儿抹了蜜，甚至能把古诗文彩虹屁给leader安排上。而是我发现我的直属leader也不怎么在群里拍马屁，所以我表面上不公开拍马屁其实属于暗地里事实上迎合了leader的喜好...
但是拍马屁这个事只要掌握好度，整体来说还是香的，最多是没用，至少不会有什么坏处嘛。大家能力都差不多，每一次在群里拍马屁的机会就是一次露脸的机会，按某个同事的说法，这就叫打造个人技术影响力...
想舔就舔，不想舔也没必要酸别人，Respect Greatness。
永不缺席的撕逼甩锅实战 ‌ 有人的地方，就有江湖。虽然搞技术的大多城府也不深，但撕逼甩锅邀功抢活这些闹心的事儿基本也不会缺席，甚至我还见到过公开群发邮件撕逼的...这部分话题涉及到一些敏感信息就不多说了，而且我们低职级的遇到这些事儿的机会也不会太多。只是给大家提个醒，在工作的时候迟早都会吃到这方面的瓜，到时候留个心眼。
稍微注意一下，咱不会去欺负别人，但也不能轻易让别人给欺负了。
不要被画饼蒙蔽了双眼 说实话，我个人是比较反感灌鸡汤、打鸡血、谈梦想、讲奋斗这一类行为的，9102年都快过完了，这一套*** 治还在大行其道，真不知道是该可笑还是可悲。当然，这些词本身并没有什么问题，但是这些东西应该是自驱的，而不应该成为外界的一种强push。『我必须努力奋斗』这个句式我觉得是正常的，但是『你必须努力奋斗』这种话多少感觉有点诡异，努力奋斗所以让公司的股东们发家致富？尤其在钱没给够的情况下，这些行为无异于耍流氓。我们需要对leader的这些画饼操作保持清醒的认知，理性分析，作出决策。比如感觉钱没给够（或者职级太低，同理）的时候，可能有以下几种情况：
•leader并没有注意到你薪资较低这一事实•leader知道这个事实，但是不知道你有多强烈的涨薪需求•leader知道你有涨薪的需求，但他觉得你能力还不够•eader知道你有涨薪的需求，能力也够，但是他不想给你涨•leader想给你涨，也向上反馈和争取了，但是没有资源
这时候我们需要做的是向上反馈，跟leader沟通确认。如果是1和2，那么通过沟通可以消除信息误差。如果是3，需要分情况讨论。如果是4和5，已经可以考虑撤退了。对于这些事儿，也没必要抱怨，抱怨解决不了任何问题。我们要做的就是努力提升好个人能力，保持个人竞争力，等一个合适的时机，跳槽就完事了。
时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。
学会包装 这一条说白了就是，要会吹。忘了从哪儿看到的了，能说、会写、善做是对职场人的三大要求。能说是很重要的，能说才能要来项目，拉来资源，招来人。同样一件事，不同的人能说出来完全不一样的效果。比如我做了个小工具上线了，我就只能说出来基本事实，而让leader描述一下，这就成了，打造了XXX的工具抓手，改进了XXX的完整生态，形成了XXX的业务闭环。老哥，我服了，硬币全给你还不行嘛。据我的观察，每个互联网公司都有这么几个词，抓手、生态、闭环、拉齐、梳理、迭代、owner意识等等等等，我们需要做的就是熟读并背诵全文，啊不，是牢记并熟练使用。
这是对事情的包装，对人的包装也是一样的，尤其是在晋升和面试这样的应试型场合，特点是流程短一锤子买卖，包装显得尤为重要。晋升和面试这里就不展开说了，这里面的道和术太多了。。下面的场景提炼自面试过程中和某公司面试官的谈话，大家可以感受一下：
我们背后是一个四五百亿美金的市场...
我负责过每天千亿级别访问量的系统...
工作两年能达到这个程度挺不错的...
贵司技术氛围挺好的，业务发展前景也很广阔...
啊，彼此彼此...
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f4fc09ef4d9f78c608e9fbb4d1dcbe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda1dc679cabbb91d6d76a376e617173/" rel="bookmark">
			第十一届蓝桥杯大赛个人赛决赛（软件类）C/C&#43;&#43;大学B组题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因能力有限，题解部分参照前辈想法，并加以博主思考。
如有不足，欢迎指正~！
后半部分题解较为潦草简单，详细思路后补~
其中试题G样例通过，实际思路上有些错误；
试题J规模、时间过不了；
样例F、I尚未解决~
目录 试题A：美丽的2试题B：扩散试题C：阶乘约数试题D：本质上升序列试题E：玩具蛇试题F：皮亚诺曲线距离试题G：游园安排试题H：答疑试题I：出租车试题J：质数行者 试题A：美丽的2 题目：
【问题描述】
小蓝特别喜欢2，今年是公元2020年，他特别高兴。
他很好奇，在公元1年到公元2020年（包含）中，有多少个年份的数位中包含数字2？
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
答案：
563
题解：
本题是道简单的签到题，题目明确提出：
在 [2,2020] 中，有多少个数包含数字2
遍历每个数中的每位数，倘若是2，则计数
加注释代码如下……
#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int cnt=0; // 计数 bool judge(int); // 判断 int main(){ int i; for(i=1;i&lt;=2020;++i){ if(judge(i)) ++cnt; } // 遍历 printf("%d",cnt); return 0; } bool judge(int n){ while(n){ if(n%10==2) return true; n/=10; } // 遍历并判断各数位上的数是否等于2 return false; } 试题B：扩散 题目：
【问题描述】
小蓝在一张无限大的特殊画布上作画。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bda1dc679cabbb91d6d76a376e617173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55169191ea849a3bb81eaef3aaf56a63/" rel="bookmark">
			token什么意思中文在C语言中,token是什么意思_token中文意思_token英译汉_英汉词典...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		token
“token”的中文翻译
词典解释
美音：[
]
英音：[
]
n.[C]
1. 标记,标志;象征
His actions were a token of his loyalty to the king.
他的行动证明了他对国王的一片忠心。
I sent her a gift as a token of my congratulation.
我给她寄去一件礼物表示祝贺。
2. 纪念品
She received many birthday tokens.
她收到许多生日纪念品。
3. 代价券,(代币)筹码;凭证
He bought some tokens for the subway.
他买了一些乘地铁用的辅币。
4. 【电脑】令牌,代符
a.[Z][B]
1. 作为标记(或标志)的;象征性的;意思意思的;充场面的
a token woman on the board of directors.
董事会上象征性的女董事;董事会上充场面的女董事。
The union called a one-day token strike.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55169191ea849a3bb81eaef3aaf56a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc537a3792f633e67d1374c01972ef3/" rel="bookmark">
			Pycharm&#43;PyQt5环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pycharm+PyQt5环境配置 1. 安装pycharm、python3和pyqt52. 配置QT Designer3. 配置编译路径pyuic4. 测试 1. 安装pycharm、python3和pyqt5 python下载链接：https://www.python.org/ (建议选择3.7以上的版本)
pycharm下载链接：https://www.jetbrains.com/pycharm/download/#section=windows
选择社区版本安装
安装完成后打开pycharm，新建项目，选择虚拟环境，其中编译器选择你安装的python的路径的python.exe文件。点击File-&gt;new project，如图所示 ：
配置完成后，点击File-&gt;setting，选择project-&gt;python interpreter，如图：
点击左下方的+号，依次输入pyqt5，pyqt5-tools，pyqt5-sip，pyinstaller，点击install package进行安装，如果安装失败，可以进入该项目文件的venv文件下的Scripts文件路径下使用pip进行安装：
如cmd进入命令提示符窗口
cd path(你的项目下的scripts文件夹路径) pip install pyqt5,pyqt5-tools,pyqt5-sip,pyinstaller 如图：
安装完成之后，就可以使用pyqt5库进行页面开发了。需要注意的是，如果想在pycharm中方便的进行ui设计以及将ui编译成.py文件，需要做进一步的设置。这里涉及到配置QT Designer和pyuic，前者是进行页面设置的工具，后者是用来将ui文件编译成.py文件的工具。以下分别讲述如何将两者加入到pycharm环境中方便运行。
2. 配置QT Designer 在pycharm页面中点击File-&gt;settings-&gt;tools-&gt;external tools，选择页面右方的+号，如图：
Name设置为QT Designer，program为designer.exe的路径，需要注意，高版本的pyqt5的路径可能在不同的地方，建议到你的项目环境中进行搜索寻找designer.exe的路径。我的program路径在：
G:\UDP\venv\Lib\site-packages\qt5_applications\Qt\bin\designer.exe中。将working directory设置为：$FileDir$ ， 点击OK
3. 配置编译路径pyuic 同理，在该页面下新建+号，如下图所示：
Program设置为：
G:\UDP\venv\Scripts\pyuic5.exe 你的也有可能在其他路径下，Aruguments设置为：
$FileName$ -o $FileNameWithoutExtension$.py working directory设置为：
$FileDir$ 至此，环境配置完毕，下面设置一个简单的页面进行测试。
4. 测试 新建项目，创建一个ui文件，如图：
在弹出来的页面中选择Dialog without buttons，如图
可以自由拖动左侧的窗口的控件，选择你需要的控件，如图：
保存（crtl+s）后重命名：如图：
在pycharm页面中出现.ui文件，选择如图pyuic进行编译：
编译后出现同名.py文件，这就是你的页面文件。在main.py文件中编写下列代码运行即可测试，注意pyqt可以很好的实现页面和逻辑分离的编写，所以也可以在main.py文件中实现逻辑代码编写，这里不予展示。测试代码如下：
from PyQt5.QtWidgets import * from test import Ui_Dialog if __name__ == '__main__': import sys app = QApplication(sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc537a3792f633e67d1374c01972ef3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce32ae1f301cabb6aabf3e442bf0f93c/" rel="bookmark">
			pygame也能实现好看的雷达图，不信可以进来看看。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pygame也能实现好看的雷达图，不信可以往下看看。
这篇是我一边敲代码，一边写博客的文章，想到什么就写什么，所以思路比较直接，望理解啊。
好的，马上开始。
文章目录 一、先把pygame跑起来再说二、画雷达图（一）画十字线（二）画图心圆（三）完整代码（四）运行效果 三、画指针咯（一）初始化旋转角度（二）循环更新坐标（三）画指针（四）完整代码（五）运行效果 四、优化效果代码（一）增加蒙版层（二）循环过程中应用蒙版 五、运行效果和源码（一）运行效果（二）源码分享 一、先把pygame跑起来再说 import pygame,sys pygame.init() screen=pygame.display.set_mode((600,500)) pygame.display.set_caption('pygame和列表元素有趣的碰撞V1.0') clock=pygame.time.Clock() while True: for event in pygame.event.get(): if event.type==pygame.QUIT: pygame.quit() sys.exit() screen.fill((0,0,0)) clock.tick(300) pygame.display.update() 黑黑的框框，熟悉的味道
二、画雷达图 （一）画十字线 pygame.draw.line(screen,(0,255,0),(0,150),(300,150),1) pygame.draw.line(screen,(0,255,0),(150,0),(150,300),1) （二）画图心圆 # 画同心圆 pygame.draw.circle(bg,(255,255,0,60),(150,150),150) pygame.draw.circle(bg,(0,255,0,255),(150,150),150,2) pygame.draw.circle(bg,(255,255,0,60),(150,150),100) pygame.draw.circle(bg,(0,255,0,255),(150,150),100,2) pygame.draw.circle(bg,(255,255,0,60),(150,150),50) pygame.draw.circle(bg,(0,255,0,255),(150,150),50,2) （三）完整代码 import pygame,sys pygame.init() screen=pygame.display.set_mode((300,300)) bg = screen.copy().convert_alpha() pygame.display.set_caption('pygame画雷达图V1.0') clock=pygame.time.Clock() i = 0 while True: for event in pygame.event.get(): if event.type==pygame.QUIT: pygame.quit() sys.exit() screen.fill((0,0,0)) # 画同心圆 pygame.draw.circle(bg,(255,255,0,60),(150,150),150) pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce32ae1f301cabb6aabf3e442bf0f93c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86043bc817d7ae38b88622af0be12600/" rel="bookmark">
			tensorflow core ---Image classification图片分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		learn -tutorial -tensorflow core —Image classification
文章目录 导入TensorFlow和其他库下载并浏览数据集使用keras.preprocessing加载可视化数据配置数据集以提高性能标准化数据注意:注意： 创建模型编译模型model summary训练模型可视化training结果过度拟合Data augmentation Dropout编译和训练模型可视化training结果预测新数据注意： 总结 本教程显示如何对花朵图像进行分类。它使用
keras.Sequential
模型创建图像分类器，并使用加载数据
preprocessing.image_dataset_from_directory
您将获得以下概念的实践经验：
有效地从磁盘加载数据集。
识别过度拟合并应用techiniques 减轻过拟合，包括 data augmentation and Dropout.。
本教程遵循基本的机器学习工作流程：
检查并了解数据
建立输入管道
建立模型
训练模型
测试模型
改进模型并重复该过程
导入TensorFlow和其他库 import matplotlib.pyplot as plt import numpy as np import os import PIL import tensorflow as tf from tensorflow import keras from tensorflow.keras import layers from tensorflow.keras.models import Sequential 下载并浏览数据集 本教程使用约3700张花朵照片的数据集。数据集包含5个子目录，每个类一个：
flower_photo/ daisy/ dandelion/ roses/ sunflowers/ tulips/ import pathlib dataset_url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86043bc817d7ae38b88622af0be12600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a31fba48ec2c83a3c635320c02334306/" rel="bookmark">
			从零开始的临时会话WEB项目（基于SSM框架）（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面搭好了SSM的基本框架，这里准备正式写代码
一、引入前端框架layim 由于layim不是完全免费的，这里就不直接把本人用的资源文件直接分享给大家了。
https://gitee.com/weijg/layim/tree/master/
上面这个是layim官方的开源版（老了点，和最新的有点不一样），如果想获取最新的请前往官网https://www.layui.com/layim/
在拿到资源文件后，打开这样加入你的项目。
这是layim资源文件，这样直接放到你的项目里，就OK（如果你用的是开源版本的，引入方式会不一样）
对了，还有js文件，这里本人也上传了，1积分下载。https://download.csdn.net/download/qq_34859668/18994226
二、编写项目 1、登录
这里打算写成戳链接就能登上，方便附加到别的项目上。
后台代码
package com.wc.controller; import java.io.UnsupportedEncodingException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Controller; import org.springframework.ui.ModelMap; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; import com.wc.service.UserService; @Controller @RequestMapping("/user") public class UserController { @Autowired @Qualifier("userService") private UserService userService; @RequestMapping("/goChat.do") public ModelAndView goChat(String uid,String uid2,String username,String username2,HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException { //根据url中的参数完成登录和聊天界面创建 if (uid==null||uid.isEmpty()) { return new ModelAndView("goLogin"); }else if (uid2==null||uid2.isEmpty()) { return new ModelAndView("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a31fba48ec2c83a3c635320c02334306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f14c68f4dc56583f3aed9b0e3b308d/" rel="bookmark">
			@webServlet注解的使用（适合初次接触的朋友）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@webServlet注解的使用（适合初次接触的朋友） Servlet 3.0 ​ Servlet3.0提供了注解(annotation)，我们可以不用再web.xml里面配置servlet，只需要加上@WebServlet注解就可以修改该servlet的属性了。web.xml可以配置的servlet属性，在@WebServlet中都可以配置。
使用 导包：
&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; 注意看仔细这两个是不一样的，下面一个包应该都知道， 我这里只是拿出来说一下这两个包不一样。要使用时必须的导入上面那个包。 一. 用法（非常简单）：
​ 只需要在原来的Servlet类上面加上 @WebServlet("/login.do")
不理解？没事我们来对比一下就会更清楚了。
没用注解时：
web.xml :
&lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jiang.servlet.user.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; servlet类：
用了@WebServlet注解后：
只需要在原来的Servlet类上面加上@WebServlet("/login.do")，如图：
意思就是说你使用这个这个注解后就可以不用在写再去web.xml中部署了servlet了，使用这个注解就相当于替换了它。
二. 配置
web.xml可以配置的servlet属性，在@WebServlet中都可以配置。（我这里就不具体说了）
@WebServlet属性列表：
三. 注意事项（一定要注意啊！）
初次使用@WebServlet注解时注意一些坑，
1. 使用这个注解时web.xml文件的设置
说一说web.xml中metadata-complete属性吧：
​ 无论是Servlet，还是Filter，Listener等，在自定义Filter时，要想使它起作用，那么必须要对它进行配置，一般都有两种配置的方式,一种是基于配置式的，另一种则是基于注解式的。
metadata-complete="false"	//false是指使用注解式 metadata-complete="true"	//true是指使用配置式 2. 使用了注解式就不要使用配置式了。就是不要同时配置该Servlet的web.xml的servlet配置又在类上添加注解
3. @WebServlet("/login.do")这个括号里面不要忘了打 /
这几个注意事项都是初次使用的朋友可能会遇到的错误的原因。
四.@WebFilter过滤器
可能使用会想不用配置式了，过滤器怎么办？
使用@WebFilter注解，用法跟@WebServlet用法类似。
@WebFilter 用于将一个类声明为过滤器，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为过滤器。
@WebFilter常用属性：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda536af991d5e2e790937a0b2ef09c4/" rel="bookmark">
			c语言无头节点单链表,假设有一个循环链表的长度大于1,且表中既无头结点也无头指针。已知S为指向链表某个结点的指针(C语言)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设有一个循环链表的长度大于1,且表中既无头结点也无头指针。已知S为指向链表某个结点的指针,试编写算法在链表中删除指针S所指结点的前驱结点。
#include #include typedef struct _DLNode
{
struct _DLNode *next;
int value;
} DLNode;
/*
* 1. 如果链有没有节点，就返回NULL
* 2. 如果链表只有一个节点，输入节点的前驱节点就是它本身，则返回输入节点 * 3. 如果链表有多于一个节点，就返回输入节点的前驱节点
*/
DLNode* getPriorNode(DLNode *node)
{
DLNode *next;
if (!node)
{
return NULL;
}
next = node-&gt;next;
while (node != next-&gt;next)
{
next = next-&gt;next;
}
return next;
}
void delPriorNode(DLNode *node)
{
DLNode *prior = getPriorNode(node);
if (prior)
{
getPriorNode(prior)-&gt;next = prior-&gt;next;
/* free(prior); */ /* 只有节点是malloc的才能free */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bda536af991d5e2e790937a0b2ef09c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f8ed44b3e4987612085f9053aac780/" rel="bookmark">
			从零开始的临时会话WEB项目（基于SSM框架）（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目预览 可以发文字、图片、文件，也可以查看聊天记录，暂时就这点功能，希望大家不要嫌弃。
一、开发环境 eclipse、Tomcat、mysql（环境如何配置在此不多做介绍）
二、SSM框架搭建 之前在学校做课设时用过SSM框架开发一个火锅店用的项目，这里直接套用了，还是不难的。
1、新建项目 实际用的项目名是WeChat，这里写WeChat2只是为了不冲突。
然后把Java Resources里的src下的目录配一下。
如下结构配置，本人用的是com.wc，大家自己搭建时不必非要一样，记得做相应改变即可。 再来就是WEB-INF下的配置文件。
以上需要用到的配置文件，本人已上传至https://gitee.com/ice-wind/SSM_Resources
大家自提即可。
再来就是tomcat服务器配置（需要先把服务器里的项目先remove，才能配置）
最后就是lib里的.jar文件了（一大堆），本人打了一个包，1积分下载。https://download.csdn.net/download/qq_34859668/18978242
然后就可以着手敲代码了，具体请见本人的下一篇文章。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01dfba5695b9307a00c671d0917d1aba/" rel="bookmark">
			FIFO（原理、框图、代码、深度计算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fifo分为同步fifo和异步fifo。同步fifo是指读写时钟是同一个时钟，异步fifo是指读写时钟不是同一个时钟。不管事同步fifo还是异步fifo都能起到数据缓存的作用。Fifo有一个特征：地址是顺序+1的。
1、异步框图
图片来源于《FPGA深度解析》
2、原理：
异步fifo的设计思想：核心是状态信号的产生和跨时钟域的转换及同步
异步fifo如上图所示，主要包含写控制逻辑、写地址、状态产生、读控制逻辑产生、读地址、格雷码同步。其中状态产生分为空信号、将空信号、满信号、将满信号。格雷码同步分为写地址格雷码从写时钟域到读时钟域的同步、读地址格雷码从读时钟域到写时钟域的同步。
（1）格雷码同步
格雷码同步在异步fifo中的作用：用于状态产生。
格雷码实现多比特跨时钟域转换的原理：因为fifo中地址是逐次+1的，而格雷码相邻两位数据一次只有一位数据发生变化。因此，将写地址（读地址）变换成格雷码，虽然地址是多比特的，但是每次变化只有1bit发生变化。这就是将二进制的地址转换成格雷码的好处了。
如果是将写地址变成格雷码，转换完以后再进行垮时钟域到读时钟域去就能最大限度的降低垮时钟域带来的风险（亚稳态）。（敲黑板：先转换成格雷码再跨时钟域）
二进制到格雷码：
二进制右移一位后与原来的二进制按位异或=格雷码
格雷码转二进制：
格雷码的最高位作为二进制的最高位，然后将二进制的最高位和格雷码的次高位异或作为二进制的次高位，依次类推。
（2）空满状态的判断
要判断fifo的状态，就需要知道读写地址。通过判断读写地址的差值来判断状态。其中存在一直特殊情况：读写地址指针指向同一个地址，但是可能是满，也可能是空。
具体分析：因为fifo是回卷式的写和读，这也就是说如果fifo深度为1023，如果写地址在1023，写地址指针会重新回到0地址，如果此时读地址还在地址0，就会存在读写地址都在地址0。而空的时候，读写地址也存在都在0地址的问题。
这就带来了一个问题，当读地址和写地址都在0的时候，可能是空，也可能是满。怎么区分是满和空呢？
那就是将读写地址扩展一位，当读写地址的值相等时，为空；读写地址除最高位不同，其余相同为满。
3、关键部分代码
关键部分的代码也主要来源于《FPGA深度解析》，我最开始不能理解的就是gap计算部分，这部分我附图进行说明了。
//写地址使能 assign wen=wr_en&amp;&amp;(!full); //写地址二进制到格雷码的转换 always@(posedge wr_clk or negedge wr_reset) if(wr_reset) waddr_gray&lt;={(ADDR_WIDTH+1){1'b0}}; else waddr_gray&lt;=waddr^{1'b0,[waddr[ADDR_WIDTH:1]]};//相当于右移一位后与原来的二进制异或 //读地址格雷码转换为二进制码 always@(*) begin raddr_gray2bin={raddr_gray_sync_d[4], raddr_gray_sync_d[4]^raddr_gray_sync_d[3], raddr_gray_sync_d[4]^raddr_gray_sync_d[3]^raddr_gray_sync_d[2], raddr_gray_sync_d[4]^raddr_gray_sync_d[3]^raddr_gray_sync_d[2]^raddr_gray_sync_d[1], raddr_gray_sync_d[4]^raddr_gray_sync_d[3]^raddr_gray_sync_d[2]^raddr_gray_sync_d[1]^raddr_gray_sync_d[0] }; End 这个图片可以帮助理解rd_gap和wr_gap计算的原因：
/状态生成/ //写指针与读指针间隔计算，在写时钟域的情况,判断满信号full和将满信号almost full的产生 always@(*)//地址宽度为4bit，扩展一位后为5bit begin if(waddr[4]^raddr_gray2bin[4])//相同为0，相异为1；需要判断还有多少空格，看看啥时候写满 wr_gap=raddr_gray2bin[3:0]-waddr[3:0];//最高位不相同的情况 else wr_gap=FIFO_DEEP+raddr_gray2bin-waddr;//最高位相同的情况 end //almost_full信号的产生 always@(posedge wr_clk or wr_reset) begin if(wr_reset) almost_full&lt;=1'b0; else if(wr_gap&lt;ALMOST_FULL_GAP)//空格子比规定的格子少了 almost_full&lt;=1'b1; else almost_full&lt;=1'b0; end //full信号的产生 always@(posedge wr_clk or wr_reset) begin if(wr_reset) full&lt;=1'b0; else if(wr_gap==1&amp;&amp;wen) full&lt;=1'b1; else full&lt;=1'b0; end //读指针和写指针的间隔，在读时钟域，读空，计算的是还有几个格子不是空的 always@(posedge rd_clk or negedge rd_reset) begin if(rd_reset) ra_gap&lt;=0; else ra_gap&lt;=waddr_gray2bin-raddr; end //almost_empty信号的产生 always@(posedge rd_clk or negedge rd_reset) begin if(rd_reset) almost_empty&lt;=0; else if(ra_gap&lt;ALMOST_EMPTY_GAP)// almost_empty&lt;=1; else almost_empty&lt;=0; end //empty信号的产生 always@(posedge rd_clk or negedge rd_reset) begin if(rd_reset) empty&lt;=0; else if(rd_en&amp;&amp;rd_gap==1) empty&lt;=1; else empty&lt;=0; 4、Fifo深度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01dfba5695b9307a00c671d0917d1aba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f85439bd8f814e0d21404f693445608/" rel="bookmark">
			达梦数据库通过Shell脚本定时备份模式（vmware凝思磐石6.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、环境
三、备份方法
四、操作步骤
4.1、在备份目录新建back.sh脚本文件
4.2、创建定时任务，每天02点执行一次
五、查看执行情况
一、前言 很多项目由于存储空间限制，给数据库备份预留的空间不足，同时数据库中一些数据量大的模式不是必须备份的，这样就可以考虑只备份一些最重要的模式，确保硬件损坏等不可控因素下数据不至完全丢失。
二、环境 操作系统：凝思磐石6.0
数据库：达梦7
三、备份方法 编写shell脚本，利用达梦dexp工具、crontab定时任务、tar解压缩来做。
四、操作步骤 4.1、在备份目录新建back.sh脚本文件 dmdba@dmdsc01:~/dbbak$ touch back.sh dmdba@dmdsc01:~/dbbak$ chmod 755 back.sh dmdba@dmdsc01:~/dbbak$ vim back.sh 脚本内容如下
schname=PI6000 filename=$schname-$(date '+%Y%m%d%H%M%S') echo $filename ## 设置环境变量 export DM_HOME=/home/dmdba/dmdbms export PATH=$DM_HOME/bin:$DM_HOME/tool:$PATH:$HOME/bin export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$DM_HOME/bin ## 导出用户PI6000的数据 /home/dmdba/dmdbms/bin/dexp userid=SYSDBA/SYSDBA owner=$schname directory=/home/dmdba/dbbak/ file=$filename.dmp log=$filename.log parallel=4 ## 压缩备份文件和日志文件然后删除dmp和log文件 cd /home/dmdba/dbbak tar zcvf $filename.tar.gz *.dmp *.log --remove-files ## 保存30天备份文件，删除29天之前备份 find /home/dmdba/dbbak/ -mtime +29 -name "*.tar.gz" -exec rm -rf {} \; dexp命令参数说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f85439bd8f814e0d21404f693445608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee5137a5a6a44741a31ace3d7a2a31fe/" rel="bookmark">
			h0在c语言中可作为变量吗,电子科大《C语言（专科）》13秋在线作业1、2、3答案...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电子科大《C语言(专科)》13秋在线作业1&amp; w# A7 @ ?: m
试卷总分：100 测试时间：--
9 D4 x" ^0 e" {# _2 y. t7 l一、单选题(共20道试题，共100分。)6 v* C( e D% r. l* J3 D$ D9 k
1.C语言程序中，main函数的位置()。
0 U* H( w# g' v" Y: ?" P9 U* _* eA. 在开头
( z2 L C# T7 x5 A5 TB. 在结尾
7 j) S P- j&amp; v3 W! WC. 在中间
$ I; \* [/ D9 v&amp; S8 q0 pD. 可以任意, ^"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee5137a5a6a44741a31ace3d7a2a31fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59253a3c9f44bd07c08b9978fa34992/" rel="bookmark">
			linux命令用tar czvf .tar.gz好用的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		便于Linux Windows互传
解压：unzip FileName.zip
压缩：zip FileName.zip DirName
https://www.cnblogs.com/peng-lan/p/10814946.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0e793b5766365546b3f03a3c7679be/" rel="bookmark">
			Android Studio导入别人的Android Studio项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先感谢 https://blog.csdn.net/weixin_39220472/article/details/79947295的文章，我这个文章只是作为我的笔记，万分感谢。
导入其他的Android Studio项目 自己新建一个项目，然后run,如果能够run 成功，则直接把别人Android项目的根目录下的目整个app文件复制然后跟你的项目app进行替换。首先：去到要导入项目的目录下把.idea，*.iml，local.properties删除（表示所有）
然后进入app文件夹同理把 删除
接着打开已经run成功的项目根目录下的build.gradle,把classpath:这整句复制，,去要导入的项目中打开build.gradle进行替换。
然后添加在repositories 中添加
maven{ url ‘http://maven.aliyun.com/nexus/content/groups/public/’} 再打开gradle\wrapper\gradle-wrapper.properties复制最后一句，去到要导入的项目进行替换。
最后可以打开android studio通过open an exisiting android studio project 选项打开要导入的项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e78811ad1618ac4b2fe0cd7179cd575b/" rel="bookmark">
			ARM版本的IAR的下载和安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、IAR的下载 在搜索网页上搜素“IAR”，如下图，并点击进入官网， 进入官网后的界面如下，点击“IAR Embedded Workbench”------&gt;"Find your tool"，进入下一个界面， 界面如下所示， 点击“architecture”的下拉，选择“ARM”,如下图所示，并点击“ARM”进入下一个界面， 进入“ARM”下的界面后，找到如以下界面部分，点击“Download a free trial”右侧那个“+”，就可找到ARM版本的IAR软件，如下图所示， ARM版本的IAR软件如下所示，点击“Download Software”即可下载IAR软件。 ARM版本的IAR（含IAR注册机）已经下载放在网盘里面，网盘链接如下，有需要的同行可以下载： 链接：https://pan.baidu.com/s/12nNX-_0t0xETPk7_UlcZPg 提取码：krkm 二、IAR安装 下载IAR后，点击IAR软件，并安装， 选择“I accept the terms of the license agreement” 把IAR安装在D盘下的Software文件夹的子文件夹ARM_IAR， 然后点击“Next”, 点击“Next”, 点击“确定”, 点击“Install”进行IAR安装， IAR进行自动安装， 取消下面两个框内的勾，点击“Finish”完成IAR安装，并进行支持在IAR的下载和调试的USB驱动，直至安装完成。 一直"Next"，直到下面界面，点击“Finish”安装完成， 点击“Exit”选项退出IAR安装选项。 二、IAR注册 点击“开始”，找到“IAR System”文件，并点开它， 找到“IAR License Manager for Arm x.xx.x”, 并打开它，点击“License---&gt;Offline Activation”离线激活， 打开IAR注册机软件,如下图， 选择ARM版本的IAR,
点击“Generate”产生IAR的注册码，在左侧会产生注册码，把这个注册码复制到IAR的注册框内，如下图， 然后点击“下一步”， 在Choose locking criteria界面选项选择“No”，点击“下一步”， 点击“...”，把“ActivationInfo.txt”保存到桌面，如下图， 回到IAR注册机，点击“Browse...” 如下图， 找到刚刚保存到桌面的“ActivationInfo.txt”，并用IAR注册机打开，如下图， 然后点击IAR注册机的“Activite license” 把这个文件“ActivationResponse.txt”也保存到桌面上，如下图所示， 返回到IAR安装界面，点击“...”如下图， 找到刚刚保存到桌面的“ActivationResponse.txt”文件并打开，如下图， IAR破解成功，如下图所示，点击“Done”完成破解。 ARM版本的IAR注册（破解）到此结束！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e10dc7ad8f7cdef2c4f85d606c8a68a/" rel="bookmark">
			Linux下配置java环境版本opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #安装gcc等编译环境 yum install gcc yum install python3.8 yum install cmake yum groupinstall "Development Tools" #去官方网站下载使用的压缩包4.5.0版本 #在local目录下创建一个opencv文件夹 mkdir /usr/local/opencv #解压opencv安装包 tar -zxvf opencv-4.5.0.tar.gz mkdir build cd build cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. make make install 安装自动化编译工具ant yum install ant cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -DBUILD_TESTS=OFF .. make -j8 make install 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06feccc8a8e2570e6bce56cf2f26fc09/" rel="bookmark">
			TensorFlow Hub使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 TensorFlow Hub 是一个包含经过训练的机器学习模型的代码库，这些模型稍作调整便可部署到任何设备上。您只需几行代码即可重复使用经过训练的模型，例如 BERT 和 Faster R-CNN。
示例,利用词嵌入模型,
能将每一个句子或者单词输出为一个向量
(num_examples, embedding_dimension)。
!pip install --upgrade tensorflow_hub import tensorflow_hub as hub model = hub.KerasLayer("https://tfhub.dev/google/nnlm-en-dim128/2") embeddings = model(["The rain in Spain.", "falls", "mainly", "In the plain!"]) print(embeddings.shape) #(4,128) 指南 了解如何使用 TensorFlow Hub 及其工作原理。
TensorFlow Hub 是用于存储可重用机器学习资产的仓库和库。hub.tensorflow.google.cn
仓库中提供了许多预训练模型：文本嵌入、图像分类模型等。开发者可以从 tensorflow_hub 库下载资源，并以最少的代码量在 TensorFlow 程序中重用这些资源。
安装和使用说明 安装 tensorflow_hub tensorflow_hub 库可与 TensorFlow 1 和 TensorFlow 2 一起安装。我们建议新用户立即从 TensorFlow 2 开始，并且当前用户升级到此版本。
与 TensorFlow 2 一起使用 往常一样使用 pip 来安装 TensorFlow 2。（有关 GPU 支持的更多说明，请参阅相关文档。）随后在它旁边安装当前版本的 tensorflow-hub（必须为 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06feccc8a8e2570e6bce56cf2f26fc09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea76934820d17e9308023b8afa587abb/" rel="bookmark">
			echarts&#43;rabbitmq实现数据实时显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以Vue项目为例
1、我们采用发布订阅模式，使用STOMP协议，所以需要室内rabbitMQ的stomp插件
终端切到rabbitmq的sbin目录执行
rabbitmq-plugins enable rabbitmq_stomp
启用后，可以通过监听ws://IP:15674/ws服务地址接收后台用发布的消息
2、配置rabbitMQ客户端
写配置文件 cnonfig/rabbitmq.js
export const MQTT_SERVICE = 'ws://127.0.0.1:15674/ws' export const MQTT_USERNAME = 'guest' export const MQTT_PASSWORD = 'guest' 创建客户端，订阅消息队列，注册回调函数
&lt;template&gt; &lt;div id='image'&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Stomp from 'stompjs' import {MQTT_SERVICE, MQTT_USERNAME, MQTT_PASSWORD} from '../../config/rabbitmq' export default { name: 'Home', data() { return { client: Stomp.client(MQTT_SERVICE) //创建mq客户端 x : new Array(10) //绘制曲线x坐标 y : new Array(10) //绘制曲线y坐标 } }， method(){ onConnected1: function (frame) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea76934820d17e9308023b8afa587abb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9519cfa75a1f588f235d27391a6c41b/" rel="bookmark">
			pip install时报错ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cmd执行以下内容即可
python -m pip install --upgrade setuptools 还有一个
python -m pip install --upgrade pip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9b691949455fb7f52a56738d024559e/" rel="bookmark">
			C语言match函数的定义与用法,Match函数的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：Match函数的基本用法
Match函数的基本用法
大家好，今天和大家分享“Match函数的基本用法",这个函数的作用就是找位置，它有3个参数，第1参数查找值；第2参数：数据源；第3参数查找方式，用0精查查找，用1和-1模糊查找。用1要求第2参数升序排序，用-1要求第2参数降序排序。大家一定要记得第2参数只能是一维引用或者是一维数组
一、找位置(第3参数用0)
2、公式
=MATCH("曹丽",C3:C5,0)
查找值是“曹丽”
在单元格区域C3：C5中找，这个是一维纵向引用
第3参数用0
公式可以简写成：=MATCH("曹丽",C3:C5,)
二、找位置(第3参数用1)
2、公式
=MATCH(75,{0;60;70;80},1)
3、公式解释
第1参数：查找值75
第2参数：数据源，这个是一维纵向数组，且升序排序了，因为第3参数用了1
75在第2参数中没有，那怎么找呢？，从最小的3个中，0；60；70中找，找这3个小的中最大的那个，也就是最接近75的那个，当然是找到70这个的位置，所以返回3
公式可以简写成=MATCH(75,{0;60;70;80})
三、找位置(第3参数用-1)
1、公式截图
2、公式
=MATCH(79,A1:D1,-1)
3、公式解释
第1参数查找值79
第2参数用了降序排序
第3参数用了-1，要求第2参数用降序排序
查找值在数据源中没有，那么就找比79大的，比79大的只有80，所以返回1，如果比79大的有许多，就从大的中找最接近79的
四、查找值在第2参数重复出现
返回第一次出现的位置，这个大家要记得
1、公式截图
2、公式
=MATCH({"曹丽";"小老鼠";"丫头";"曹丽"},{"曹丽";"小老鼠";"丫头";"曹丽"},0)
3、公式解释
查找值第1参数用了数组用法，查找值有4个，返回就返回4个结果
第2参数用第1参数一样，姓名“曹丽"有重复的
第3参数用0，精确查找
返回4个结果{1;2;3;1}
五、随心所欲查找
Index+Match行+Match列
1、公式截图
2、公式
=INDEX($A$1:$D$4,MATCH($A$7,$B$1:$B$4,0),MATCH(B6,$A$1:$D$1,0))
3、公式解释
index函数这里用3个参数表达式，第1参数：数据源；第2参数：返回数据源那一行，用match找位置；第3参数返回第1参数那一列，这里也是用match函数找位置
六、新班开班通知
七、近10期文章：大家可以用手指点击就可以查找看了，如果觉得不错，记得分享到你的朋友圈返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269f8cdb24c451c1b2f512f48abdf1cd/" rel="bookmark">
			FTP/Vsftpd服务本地用户及虚拟用户访问控制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vsftpd服务本地用户及虚拟用户访问控制 1、本地用户访问控制 a）本地用户登陆控制：local_enable=NO|YES
实验步骤：
1）创建普通/本地用户lee，设定普通用户密码，lftp 172.25.254.133 -u 本地用户可以成功以本地用户身份访问ftp
2）修改vsftp服务的配置文件，重启服务，此时本地用户不能成功访问ftp，530报错即用户无法通过认证
b）更改默认访问目录：local_root=/software
实验步骤：
1）本地用户访问ftp时，默认访问的是该本地用户的家目录/home/username，新建目录/westosdir，在该目录下建立文件，修改vsftp服务的配置文件，重启服务，本地用户访问ftp时看到的是/westosdir目录下的文件
c）写权限控制：write_enable=NO|YES
实验步骤：
1）本地用户访问ftp，在该本地用户的家目录/home/username中put上传文件，550报错即服务本身拒绝，修改vsftp服务的配置文件，重启服务，本地用户再次访问ftp可以进行上传、删除文件等操作
d）上传文件权限控制：local_umask=xxx
实验步骤：
1）本地用户访问ftp，在该本地用户的家目录/home/username中put上传文件/etc/passwd，服务默认上传文件的权限为644，编写vsftp服务的配置文件，设定local_umask=077，重启服务，访问ftp在pub/中上传另一文件/etc/group，可以看到文件group权限为600（777-077-111），权限设定生效
e）用户登陆控制
/etc/vsftpd/ftpusers： 永久用户登录黑名单，在该名单中的用户无法访问ftp
/etc/vsftpd/user_list： 用户列表，默认为用户登录黑名单，在该名单中的用户无法访问ftp；可以在配置文件中设定userlist_deny=NO，此时该用户列表为用户登录白名单，不在名单中的用户不能访问ftp
实验步骤：
1）编辑永久用户登录黑名单，在其中添加lee用户后，本地用户lee无法访问ftp，530报错即用户无法通过认证
2）编写vsftp服务的配置文件，设定userlist_deny=NO，重启服务，此时用户列表为用户登录白名单，在其中添加westos用户后，只有本地用户westos可以访问ftp，不在名单中的用户不能访问ftp（包括匿名用户）
f）锁定用户到自己的家目录中：chroot_local_user=YES
实验步骤：
1）本地用户访问ftp，访问成功后该用户可以切换到FTP服务器系统的根目录中，这显然是不安全的，应该将该用户锁定到自己的家目录中
2）编写vsftp服务的配置文件，重启服务，本地用户访问ftp不成功，500报错即文件系统权限过大
3）我们需要将家目录的写权限去掉，否则无法访问，此时本地用户访问lftp成功后无法切换浏览根，该用户被锁定到自己的家目录中
g）锁定用户到自己的家目录中的白名单
chroot_local_user=YES
chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chroot_list
实验步骤：
1）编写vsftp服务的配置文件，设定chroot_local_user=YES，重启服务，编写锁定名单(/etc/vsftpd/chroot_list默认不存在)，在名单中添加用户lee，只有名单中的lee用户访问lftp后可以切换浏览根/，不在名单中的westos用户访问lftp后被锁定到自己的家目录中
h）锁定用户到自己的家目录中的黑名单
chroot_local_user=NO
chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chroot_list
实验步骤：
1）编写vsftp服务的配置文件，设定chroot_local_user=NO，重启服务，编写锁定名单(/etc/vsftpd/chroot_list默认不存在)，在名单中添加用户lee，名单中的lee用户访问lftp后被锁定到自己的家目录中不能切换浏览根/，不在名单中的westos用户访问lftp后可以切换浏览根/
2、虚拟用户访问控制 a）建立虚拟用户
实验步骤：
1）在vsftpd服务配置目录/etc/vsftpd/下建立认证文件，在其中设置虚拟用户的用户名和密码，加密该认证文件—db_load -T(转换) -t(指定转换类型) hash -f(指定加密文件) 文件名 输出文件
2）在/etc/pam.d下生成认证策略文件(注意认证策略文件路径不用写.db后缀，系统会自动添加)
3）编写vsftp服务的配置文件，指定认证策略文件，指定虚拟用户功能开启，指定虚拟用户在ftp服务器上的用户身份，重启服务，此时可以通过认证文件中设置的虚拟用户成功访问ftp
b）虚拟用户家目录的独立设定
实验步骤：
1）虚拟用户访问ftp，默认共享目录为/var/ftp ，我们为每个虚拟用户建立各自的家目录
2）编写vsftp服务的配置文件，指定虚拟用户默认访问目录位其对应家目录，从shell中提取登陆的虚拟用户名，重启服务，此时虚拟用户访问ftp后看到的是其家目录中的资源
c）虚拟用户配置独立操作（上传操作）
实验步骤：
1）虚拟用户访问ftp后，在其家目录中put上传文件，553报错即文件系统权限限制，我们需要给虚拟用户各自家目录进行权限设置
2）权限设置完成后所有虚拟用户都可以进行上传操作
3）编写vsftp服务的配置文件(注释五行；添加独立语句)，重启服务，建立与配置文件中对应的目录，在该目录下编写指定用户的独立上传文件（注意文件名要与用户名相同），只有指定用户可以上传
4）完成上述设定后只有虚拟用户user1可以上传文件，user2和user3不行(注意上传只能在家目录的子目录下，不能直接在家目录下)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42852114d4995dd74604a198c6a06b6/" rel="bookmark">
			vue |Element-ui| el-table组件的row-class-name、row-style、cell-class-name等属性样式无效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 问题描述2. 解决方案2.1 使用全局属性2.2 使用深度选择器/deep/ (css代码前加上 /deep/ 即可)2.3 全局属性，引用一个全局的css文件2.4 混合样式 1. 问题描述 vue项目中，需要给vue表格中的每一行加入自定义的样式，根据文档给组件加上row-class-name属性即可，直接加入该属性并且在当前vue组件中配置对应class发现样式并没有生效。
2. 解决方案 2.1 使用全局属性 在elementUI中，row-class-name、row-style、cell-class-name等属性要想生效必须使用全局class才能生效。因为之前的代码都是在组件中编写的，所以去除中的scoped即可该组件中的样式变为全局属性。
当然这样做有个缺陷，很容易引起因为样式重复定义导致意外错误，所以更推荐第二种解决方案。
2.2 使用深度选择器/deep/ (css代码前加上 /deep/ 即可) /deep/ #myContent input{ /* ... */ } 2.3 全局属性，引用一个全局的css文件 &lt;style scoped&gt; @import "../../assets/common.css"; // 其余作用域内样式代码 &lt;/style&gt; 2.4 混合样式 &lt;style scoped&gt; // 作用域内样式代码 &lt;style&gt; &lt;style&gt; // 位于子组件 不生效的样式代码 &lt;/style&gt; 参考：
https://blog.csdn.net/ld395353765/article/details/103992181?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242
其他文章：
vue中的css作用域、vue中的scoped坑点
https://www.cnblogs.com/goloving/p/9119460.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4605229165a353a6f21c48f6cefb86f0/" rel="bookmark">
			数据库中回表介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们如果直接用主键查找，用的是聚集索引，能找到全部的数据。如果我们是用非聚集索引查找，如果索引里不包含全部要查找的字段，则需要根据索引叶子节点存的主键值，再到聚集索引里查找需要的字段，这个过程也叫做回表。
那我们应该如何避免回表，因为如果用到了回表，就需要二次查询的过程，效率肯定更慢，很简单，回表是因为要查询的字段在非聚集索引里没有，所以在满足需求的情况下，我们尽量使非聚集索引里有要查询的索引字段。
在查询时，可以尽量用聚集索引来查（也就是用主键来查询），或者根据业务需求，建好的索引，满足索引查询字段。但是实际业务中，很难建立一个索引就能满足所有查询要求，所以，正常情况，回表也没事，只要能用到索引也能大大加快查询速度。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e23a597283b42dae75d72dca6b1d67a/" rel="bookmark">
			计算机网络:自顶向下方法 第五章编程作业-DV算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DV算法(&lt;&lt;计算机网络:自顶向下方法&gt;&gt;第五章编程作业) 目录
DV算(&lt;&lt;计算机网络:自顶向下方法&gt;&gt;第五章编程作业)
一.算法原理
1.1目标
1.2算法的核心思想
1.3算法的表格
１.４“更新”与“发布”
1.5注意事项
二．代码部分（以node0.c为例）
2.1初始化部分
２.2接收到消息
2.3更改链路开销(只在node1.c和node2.c中)
三.测试结果
第一步:初始化
第二步:初始化完成,算法收敛
第三步:更改node0到node1之间的权值,直到算法收敛
第四步:更改回初始状态,直到算法收敛
一.算法原理 1.1目标 在一个网络中,实现一个 分布式 , 异步 , 迭代 的路由算法.即距离向量(Distance-Vecto算法 1.2算法的核心思想 考虑一个网络中的一个 节点 A ,与其直接相邻的邻居节点为 ,目标节点为 B.
路由算法为: A＂询问＂其所有邻居结点到B的距离．从中选择　Ａ到邻居距离　＋　邻居到B距离
最小的一个邻居．此邻居就是Ａ选择的下一个结点，此值就是Ａ到Ｂ的距离．
将上述语言描述为公式就是：
1.3算法的表格 假设网络中由Ｎ个节点，每一个结点需要维护两个表，一个用于存储自己到邻居节点的距离，一个用于存储ＤＶ表
以作业中的此图为例，结点０需要维护的第一个表为
这个表会在初始化中完成，我们认为每一个结点可以知道到其邻居结点的距离，其中的距离是结点到邻居的距离，但不一定是
最短距离（例如：结点０到结点３的最短距离为４）
对于无法到达的结点，将其值设为　９９９。
注意：除非线路的开销发生了改变，否则这个表是不会变的
结点需要维护的第二个表就是储存了“询问”结果的表(DV表)，这个表的大小是　邻居数＊４　，由于实验中给的此表都是４＊４的，有些只使用一部分即可
以结点０为例，此表为
这是ＤＶ算法收敛时表中的内容，按照实验给出的组织方式 Distance_table[a][b] 就代表了 结点b 到 结点a 的最小开销。
可以总结出一些这个表的规律：　＃１.当算法收敛时，这个表是沿对角线对称的，ａ到ｂ的距离就是ｂ到ａ的距离（实验中的网络是无向的）
＃２.表的行数一定４，因为所有的结点个数是４，但列数不固定，是结点的邻居数（自己也加在表里了）
把不是邻居结点的结点加入列中是没有意义的，因为就算此节点可以到达目的结点，自己也没有办法到达这个结点
比如说，想要得到从　结点０　到　结点３　的最小开销，查表可得值为　４
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e23a597283b42dae75d72dca6b1d67a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e935f0476b9055abd50c2969e59b390/" rel="bookmark">
			c语言extend函数,jQuery的extend方法源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章主要分为三部分，第一部分简单介绍了extend的语法，第二部分通过实例介绍extend的用途,最后一部分是extend的源码解读，同时另附extend的另一种实现方式。
一、方法介绍
jQuery 的 API 手册中，extend 方法挂载在 jQuery 和 jQuery.fn 两个不同的对象上，但在 jQuery 内部代码实现的是相同的，只是功能各不相同。
官方解释：
jQuery.extend:Merge the contents of two or more objects together into the first object.(把两个或者多个对象合并到第一个对象当中)
jQuery.fn.extend:Merge the contents of an object onto the jQuery prototype to provide new jQuery instance methods.(把对象挂载到 jQuery 的 prototype 上以扩展一个新的 jQuery 实例方法 。)
syntax:
jQuery.extend([deep,] [target,] object1 [,objectN]);
jQuery.fn.extend([deep，] [target,] object1 [,objectN])
deep: Boolen类型，可选，表示是否进行递归合并(深/浅复制)，为true是为深复制；默认值为false，浅复制。
target:扩展对象，可选，将接收新的属性。
objectN:一个对象，包含额外的属性，扩展到目标对象(扩展对象)。
二、extend能实现的功能
将两个或者更多个对象合并到第一个对象
在这种情况下，extend方法需要至少传入两个对象，语法如下：
jQuery.extend(target, object1 [,objectN])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e935f0476b9055abd50c2969e59b390/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0eb98cfa672a9200141fc2d71fd131/" rel="bookmark">
			c语言 1累乘至100,C语言1乘到100怎么编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		匿名用户
1级
2013-07-12 回答
100的阶乘已经是大数相乘了，在c语言中没有现成的数据型可以用，所以用数组模拟计算
#include #define MAXN 1000
int a[MAXN],b[MAXN];
void pwrite(int *a,int k,int c)//将计算的结果数组[a]按每一位输出，k为所计算数字，i为计算所得位数，计算后所得结果是按从最后一位到第一位，故应该倒序输出
{
int i;
printf("%4d != ",k);
for(i= c-1;i&gt;=0;i--)
{
printf("%d",a[i]);
}
printf("\n\n");
}
void pnext(int k,int *cp);
int main(void)
{
int n,c,k;
printf("Enter the number n(n&lt;=100):");
scanf("%d",&amp;n);
a[0]=1;
c=1; //初始化长度为1，随计算位数增加
/*pwrite(a,1,c);*/
for(k=2;k&lt;=n;k++)
{
pnext(k,&amp;c); //此处计算结果，计算1*2*3*...*n
//pwrite(a,k,c);
if (k==n)
{
pwrite(a,k,c);//计算到n时输出
}
}
system("pause");
return 0;
}
void pnext(int k,int *cp) //cp此处代表计算的位数，n代表将要乘的数字
{
int i, j;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0eb98cfa672a9200141fc2d71fd131/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37dd8c1e8210c786e22b08b40f47422c/" rel="bookmark">
			漏桶算法和令牌桶算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、漏桶和令牌桶介绍
二、Redis+ lua脚本 + 令牌桶算法 实现限流控制
1、自定义一个注解，用来给限流的方法标注
2、编写lua脚本
3、读取lua脚本
4、创建拦截器拦截带有该注解的方法
5、在WebConfig中注册这个这个拦截器
6、注解使用
一、漏桶和令牌桶介绍 漏桶算法与令牌桶算法在表面看起来类似，很容易将两者混淆。但事实上，这两者具有截然不同的特性，且为不同的目的而使用。漏桶算法与令牌桶算法的区别在于：l 漏桶算法能够强行限制数据的传输速率。l 令牌桶算法能够在限制数据的平均传输速率的同
时还允许某种程度的突发传输。需要说明的是：在某些情况下，漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的
流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为网络流量提供更高效的控制。
常用的限流算法有两种：漏桶算法和令牌桶算法。
漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。
漏桶算法示意图
对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。如图2所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处
理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。
令牌桶算法示意图
并不能说明令牌桶一定比漏洞好，她们使用场景不一样。令牌桶可以用来保护自己，主要用来对调用者频率进行限流，为的是让自己不被打垮。所以如果自己本身有处理能力的时候，如果流量突发（实际消费能力强于配置的流量限制），那么实际处理速率可
以超过配置的限制。而漏桶算法，这是用来保护他人，也就是保护他所调用的系统。主要场景是，当调用的第三方系统本身没有保护机制，或者有流量限制的时候，我们的调用速度不能超过他的限制，由于我们不能更改第三方系统，所以只有在主调方控制。
这个时候，即使流量突发，也必须舍弃。因为消费能力是第三方决定的。
总结起来：如果要让自己的系统不被打垮，用令牌桶。如果保证被别人的系统不被打垮，用漏桶算法。
二、Redis+ lua脚本 + 令牌桶算法 实现限流控制 1、自定义一个注解，用来给限流的方法标注 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface RateLimit { //限流唯一标示 String key() default ""; //限流单位时间（单位为s） int time() default 1; //单位时间内限制的访问次数 int count(); //是否限制ip boolean ipLimit() default false; } 2、编写lua脚本 根据key（参数） 查询 对应的 value（令牌数） 如果为null 说明该key 是第一次进入 { 初始化 令牌桶（参数）数量;记录初始化时间 -&gt;返回 剩余令牌数 } 如果不为null { 判断 value 是否大于1 { 大于1 -&gt;value - 1 -&gt; 返回 剩余令牌数 小于1 -&gt; 判断 补充令牌时间间隔是否足够 { 足够 -&gt; 补充令牌；更新补充令牌时间-&gt; 返回 剩余令牌数 不足够	-&gt; 返回 -1 (说明超过限流访问次数) } } } redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37dd8c1e8210c786e22b08b40f47422c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2fc4fc841fcdcd5f53b8868dab07330/" rel="bookmark">
			HAL库常见报错（1）：error:  #20: identifier “HAL_StatusTypeDef“ is undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		再给HAL库工程移植标准库的GPIO功能的时候出现了error: #20: identifier "HAL_StatusTypeDef" is undefined问题。而且报错的文件还是HAL库中的文件，现象如下：
这里我是打算添加一个GPIO口模拟I2C的驱动的。
问题解决：
首先注意一下初始化的函数。GPIO_InitTypeDef结构体与标准库中的成员的大小写，可赋的值不一样。开时钟也不一样。初始化函数调用HAL库自己的。尤其是引脚不同标准库是GPIO_Pin_6，而HAL库是GPIO_PIN_6 /* 定义I2C总线连接的GPIO端口, 用户只需要修改下面4行代码即可任意改变SCL和SDA的引脚 */ #define EEPROM_GPIO_PORT_I2C	GPIOB	/* GPIO端口 */ //#define EEPROM_RCC_I2C_PORT RCC_APB2Periph_GPIOB	/* GPIO端口时钟 */ #define EEPROM_I2C_SCL_PIN	GPIO_PIN_6	/* 连接到SCL时钟线的GPIO */ #define EEPROM_I2C_SDA_PIN	GPIO_PIN_7	/* 连接到SDA数据线的GPIO */ /** @brief 配置I2C总线的GPIO，采用模拟IO的方式实现 @param 无 @return 无 */ static void i2c_CfgGpio(void) { GPIO_InitTypeDef GPIO_InitStructure; /* 打开GPIO时钟 */ __HAL_RCC_GPIOB_CLK_ENABLE(); GPIO_InitStructure.Pin = EEPROM_I2C_SCL_PIN | EEPROM_I2C_SDA_PIN; GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_OD; /* 开漏输出 */ GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2fc4fc841fcdcd5f53b8868dab07330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d32b26c8e44f8eaf78172fc914da5e9e/" rel="bookmark">
			三维重建 3D reconstruction 有哪些实用算法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“3D视觉工坊”，选择“星标”
干货第一时间送达
三维重建 3D reconstruction 有哪些实用算法？ https://www.zhihu.com/question/29885222
知乎高质量回答 一、作者：曹力科
https://www.zhihu.com/question/29885222/answer/918009389
本文来自知乎问答，仅供学习参考，著作权归作者所有。
在这个问题下，竟然没有人说大名鼎鼎的KinectFusion以及他后面的一系列工作？KinectFusion单篇论文引用都已经超过3000次了，不应该啊！
如果只想看现阶段效果最好的三维重建算法，请拉到文章最后（如有更好的算法，还请告知）。
一、KinectFusion
帝国理工的Newcombe等人在2011年提出的KinectFusion，可在不需要RGB图而只用深度图的情况下就能实时地建立三维模型。KinectFusion算法首次实现了基于廉价消费类相机的实时刚体重建，在当时是非常有影响力的工作，它极大的推动了实时稠密三维重建的商业化进程。
KinectFusion重建效果
在他们的论文中没有开源代码，最初的代码是由PCL团队实现的：https://link.zhihu.com/？target=http%3A//pointclouds.org/news/kinectfusion-open-source.html
KinectFusion的重建效果可以看这个视频：
KinectFusion之后，陆续出现了Kintinuous，ElasticFusion ElasticReconstruction，DynamicFusion，InfiniTAM，BundleFusion等非常优秀的工作。其中2017年斯坦福大学提出的BundleFusion算法，据说是目前基于RGB-D相机进行稠密三维重建效果最好的方法。
二、Kintinuous和ElasticFusion
这两个工作都是同一个人做出来的，这个人就是Thomas Whelan。这两个工作应该算KinectFusion之后影响力比较大的。
Kintinuous GitHub代码：https://github.com/mp3guy/Kintinuous
ElasticFusion GitHub代码：https://github.com/mp3guy/ElasticFusion
Kintinuous2.0重建效果：
Kintinuous2.0重建效果
ElasticFusion 重建效果：
ElasticFusion 重建效果
三、ElasticReconstruction
项目官网：http://qianyi.info/scene.html
GitHub代码：https://github.com/qianyizh/ElasticReconstruction
重建效果：
ElasticReconstruction重建效果
四、InfiniTAM
InfiniTAM提供Linux，iOS，Android平台版本，CPU可以实时重建。
官网：http://www.robots.ox.ac.uk/~victor/infinitam/
GitHub代码：https://github.com/victorprad/InfiniTAM
重建效果：
五、DynamicFusion
官网：https://grail.cs.washington.edu/projects/dynamicfusion/
代码：https://github.com/mihaibujanca/dynamicfusion
重建效果：
DynamicFusion重建效果
六、BundleFusion
官网：http://graphics.stanford.edu/projects/bundlefusion/
论文：https://arxiv.org/pdf/1604.01093.pdf
代码：https://github.com/niessner/BundleFusion
重建效果：
二、作者：徐普
https://www.zhihu.com/question/29885222/answer/48940748
本文来自知乎问答，仅供学习参考，著作权归作者所有。
我讲一下用一组图片来做3D reconstruction需要的算法吧(SFM), 使用这种方法的软件比较代表性的有 Pix4Dmapper, Autodesk 123D Catch, PhotoModeler, VisualSFM.
我用JavaScript撸了个WebSFM, 完全用Javascript实现的3D reconstruction系统，可以在浏览器里跑.
http://websfm.org , 用Chrome,Firefox,IE10+打开即可.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d32b26c8e44f8eaf78172fc914da5e9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7f9ce5cd8e6ecc2cde363cb66b158d/" rel="bookmark">
			编写计算并输出一个3＊3阶矩阵对角线元素的和。  程序运行结果示例： 请输入数组元素：（3＊3）↙ 1 2 3 4 5 6 7 8 9↙ ↙ 数组为：cqupt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编写计算并输出一个3＊3阶矩阵对角线元素的和。
程序运行结果示例：
请输入数组元素：（3＊3）↙
1 2 3 4 5 6 7 8 9↙
↙
数组为：↙
1 2 3↙
4 5 6↙
7 8 9↙
↙
对角线的和：↙
25↙
输入提示：“请输入数组元素：（3*3）\n”
输入格式："%d"
输出提示："\n数组为：\n"
输出格式："%4d"
输出提示："\n对角线的和：\n"
输出格式："%d\n"
#include&lt;stdio.h&gt; int main() { int a[3][3],sum=0; int i,j; printf("请输入数组元素：（3*3）\n"); for(i=0;i&lt;3;i++) for(j=0;j&lt;3;j++) scanf("%d",&amp;a[i][j]); printf("\n数组为：\n"); for(i=0;i&lt;3;i++) for(j=0;j&lt;3;j++) { printf("%4d",a[i][j]); if(j==2) { printf("\n"); } } sum=(a[0][0]+a[1][1]+a[2][2]+a[0][2]+a[2][0]) ; printf("\n对角线的和：\n"); printf("%d\n",sum);	} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64c42014156aae69d09f8862653f5b4/" rel="bookmark">
			keras.callbacks.Callback()回调函数ModelCheckpoint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		model_checkpoint = tf.keras.callbacks.ModelCheckpoint('net.hdf5', monitor='loss',verbose=1, save_best_only=True) model.fit(data_gen,steps_per_epoch=10,epochs=80,verbose=0,callbacks=[model_checkpoint]) 或
cp = keras.callbacks.ModelCheckpoint(model_path, monitor = "val_acc", save_best_only = True, mode="max") callbacks = [cp] history = model.fit(train_db, epochs = 20, validation_data = valid_db, callbacks = callbacks) "val_acc",既然是准确率，模式当然是最大值。
“val_loss”，模式是“min”
verbose: 0, 1 或 2。日志显示模式。 0 = 安静模式, 1 = 进度条, 2 = 每轮一行
其他 steps_per_epoch=100，如果是yield方法生成批数据，那么steps_per_epoch需指定一个值。
一般说来，这样训练
model_checkpoint = tf.keras.callbacks.ModelCheckpoint(process_str_id+".hdf5", verbose=1,monitor = "val_loss", save_best_only = True, mode="min") model_history=model.fit(train_gen,steps_per_epoch=100,epochs=8,validation_data = val_gen, validation_steps=20, callbacks=[model_checkpoint]) 设置一个验证好处很多，至少不用频繁储存系数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0deed405828b6bd68515931bb470ee28/" rel="bookmark">
			function函数的用法c语言,function函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function()函数的具体用法
请大侠具体告知,高分赠送。
function()函数语法： function 函数名(参数1 [参数2]) { 函数体 return 返回值 } 举例：
javascript 的 "。function" 是什么意思？
。function跟(function(){... })();函数意义相同，叫做立即运行的匿名函数(也叫立即调用函数)。 js中可以这样创建一个匿名函数： (function(){do something...})() //或 (function(){do something...}()) 而匿名函数后面的小括号()是为了让匿名函
HTML function函数怎么定义和调用
完全忘记了。。 我想做一个计算平方的 最好给一个例子 感激不尽
HTML function函数怎么定义和调用实例： function myFunction() { alert("Hello World。"); } Try it 扩展资料
函数声明语法 (声明定义) function functionName(parameters) { 执行的代码 } 实例： function myFunction(a, b) { return a *
function在MATLAB中怎么用
2输出3个参数，创建一个有1输入(2维)，(1维)，还有全局变量的s-function。1.新建sfunction的C语言文件打开simulink，点击User-DefinedFunctions里面的S-FunctionExamples。这个里面有多个语言版本的模板，有C，C++，Ada。
javascript 中 “ 。function(){}() ” 是什么意思？
( function(){…} )()和( function (){…} () )是两种javascript立即执行函数的常见写法，要理解立即执行函数，需要先理解一些函数的基本概念。 函数声明： function fnName () {…};使用function关键字声明一个函数，再指定一个函数名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0deed405828b6bd68515931bb470ee28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b832940f0414f90b03e57c110e55d9/" rel="bookmark">
			c语言和汇编语言程序相互嵌套,关于C语言和汇编语言相互嵌套调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、C嵌套汇编
首先说一下关于GCC编译嵌有汇编语言的c语言吧，GCC编译的汇编语言不是我们上课时学的Intel x86汇编，而是AT&amp;T汇编，两者的区别可以查看《Gcc使用的内嵌汇编语法格式小教程》。
下面是内嵌汇编的格式：语法：__asm__(“instruction
…… instruction"); //Linux gcc中支持(注意asm的下划线均为两个否则GCC将会无法编译。)
__asm{
instruction
instruction
}； //ADS中支持(注意asm的下划线均为两个否则GCC将会无法编译。)
asm(“instruction [; instruction]”); //ARM C＋＋中使用
例1是我在linux环境下，编的嵌有汇编程序的c语言，并通过了GCC的编译：
例1：
#include
int plus(int a,int b)
{
__asm__
(
“add %1,%0\n\t”:”+r”(a):”r”(b)
);
return (c);
}
int main()
{int a,b,c;
a=2;
b=1;
c=plus(a,b);
printf(“c=%d\n”,c);
}
这个程序应该是很简单的，但关键是子函数中嵌入的那段汇编程序，具体的写法可以参看其他文章。
例2同样是c语言中嵌入了汇编，与例1不同的是，这个程序的编译环境为ADS。
例2
#include void my_strcpy(char* src, const char* dst){
int ch;
__asm{
loop:
LDRB ch, [src], #1
STRB ch, [dst], #1
CMP ch, #0
BNE loop
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4b832940f0414f90b03e57c110e55d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728062c3b0a7a8b42cbd288562c58e2e/" rel="bookmark">
			《算法笔记》3.1小节——入门模拟-＞简单模拟 问题 A: 剩下的树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 A: 剩下的树 题目描述输入输出样例输入样例输出示例代码 题目描述 有一个长度为整数L(1&lt;=L&lt;=10000)的马路，可以想象成数轴上长度为L的一个线段，起点是坐标原点，在每个整数坐标点有一棵树，即在0,1,2，…，L共L+1个位置上有L+1棵树。
现在要移走一些树，移走的树的区间用一对数字表示，如 100 200表示移走从100到200之间（包括端点）所有的树。
可能有M(1&lt;=M&lt;=100)个区间，区间之间可能有重叠。现在要求移走所有区间的树之后剩下的树的个数。
输入 两个整数L(1&lt;=L&lt;=10000)和M(1&lt;=M&lt;=100)。
接下来有M组整数，每组有一对数字。
输出 可能有多组输入数据，对于每组输入数据，输出一个数，表示移走所有区间的树之后剩下的树的个数。
样例输入 4 2 1 2 0 2 11 2 1 5 4 7 0 0 样例输出 2 5 示例代码 #include&lt;iostream&gt; using namespace std; int main(){ int L,M; int n[10000]; int a,b; while(scanf("%d%d",&amp;L,&amp;M)!=EOF){ int count=0; if(L==0&amp;&amp;M==0){ break; } for(int i=0;i&lt;=L;i++){ n[i]=1; } if(L&gt;=1&amp;&amp;L&lt;=10000&amp;&amp;M&gt;=1&amp;&amp;M&lt;=100){ for(int i=0;i&lt;M;i++){ scanf("%d%d",&amp;a,&amp;b); for(a;a&lt;=b;a++){ n[a]=0; } } for(int i=0;i&lt;=L;i++){ if(n[i]==1){ count++; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728062c3b0a7a8b42cbd288562c58e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e375d0c3ef63063575a933943e9158b/" rel="bookmark">
			windows平台下,有什么好的分屏软件推荐?3款让窗口布局更合理的App
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows平台下,有什么好的分屏软件推荐?Windows 10 系统为例，系统自带功能支持二分屏/三分屏/四分屏的分屏方式。比如用户通过鼠标将应用窗口拖到屏幕边缘，窗口会自动以占据 1/2 屏幕大小的布局显示，再将另外的窗口拖到另外一半屏幕边缘，也会自动占据剩下的屏幕区域。
DisplayFusion
DisplayFusion 可以视为一款各类窗口/屏幕管理工具的「集大成者」,包括更换桌面壁纸、调整显示屏分辨率/色深调节、多显示器设备的窗口管理等等，而其中的 Window Snapping 就是可以拿来实现屏幕分屏功能。
在我的体验过程中，DisplayFusion 除了有独立安装包外，还提供了压缩免安装的版本，对于追求绿色化使用软件的用户来说，压缩包的形式还是相当便捷。通过 DisplayFusion 设置页面中「功能」中，自定义选择将哪些调整窗口大小的操作放置在应用窗口的标题栏。使用兼容性规则忽略特定的应用程序。DisplayFusion 另一特色的分屏效果就是用户可制定类似过滤规则，制定哪些程序会被 DisplayFusion 接管实现窗口管理功能，比如将 Chrome 浏览器禁用标题栏按钮，禁止对程序启用窗口吸附功能等。
MaxTo
MaxTo 前身是 Winsplit Revolution，软件支持 Windows 7(SP1)、Wimdows 8/8.1、Windows 10 系统，需安装 .NET Framework 运行环境。初次安装打开 MaxTo 后，软件会提示要求先划分屏幕区域。
可保存多个配置文件。用户可保存自定义划分好的分屏方案，只需点击 保存配置 按提示输入配置文件的名称，即可完成保存。同时通过点击 装入配置 可使用 MaxTo 官方提供的 5 个分屏配置方案。在设置好分屏的配置方案后，将窗口移动到预先划分好的某个区域，按下应用窗口的最大化按钮后，窗口会自动填满之前的划分区域。
AquaSnap
AquaSnap 是 Nurgo Software 公司开发的另一款明星产品(还有一款是 Windows 平台上窗口标签管理工具 TidyTabs)，软件支持屏幕分屏、窗口边缘吸附、自动调整窗口平铺的大小、鼠标晃动窗口置顶、键盘快捷键操作等功能，提供了个人免费版(部分功能受限)、标准专业版(18 美元/人)、商业专业版(599 美元)。下面是我认为 AquaSnap 的几个实用功能：
拖拽边缘自动分屏。与 Windows 10 内置的分屏功能类似，AquaSnap 同样支持 1/2、1/3、1/4 的分屏方式，用户将窗口拖放到屏幕边缘或者角落位置时，窗口将自动实现分屏功能，软件会以半透明的填充区域预览分屏效果，并且给出图标提示。窗口边缘吸附。窗口对齐功能类似边缘吸附的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321d5fbe564ec052e14e29a590b946cd/" rel="bookmark">
			电脑安装什么杀毒软件最好?这4款满分杀毒软件了解一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在电脑用什么杀毒软件比较适用，要结合我们当前的网络环境进行分析。简单的讲，以前我们上网，一不小心就会中病毒，现在上网，病毒好像不多见了，但是会一不小心中杀毒软件，一些流氓杀软如狗皮膏药一样，一旦沾上电脑，无论如何都卸载不掉。使用电脑频繁的人总会在自己的电脑上安装靠谱的杀毒软件，毕竟一旦电脑有了病毒会很麻烦。现在市面上有非常多的杀毒软件可供选择，我们先来梳理一下市面上有哪些常见的杀毒软件。
小红伞，来自德国的杀毒软件，有免费个人版，没有国内软件那么多花里胡哨的功能，专注于杀毒，而且德国人的严谨也完美的体现在这款软件，占用资源略高，实在是一款不可多得的杀毒软件，小红伞查杀率一流，对破解软件也蛮敏感的。但自我保护稍差，如果没防火墙，必须自己另装个防火墙。监控灵敏，但免费版只有系统防护，没有网页防护、邮件防护，没有官方中文版。
360杀毒，稳坐国内杀毒领域头把交椅，小白们将360卫士敬若神明，技术宅们对其嗤之以鼻。是奇虎360公司出品，使用国外一流杀毒软件bitdefender的09版本的引擎，查杀率中等，监控不错，没有防火墙，不过它的自我保护必须搭配360安全卫士一起使用。而且它阉割了很多监控性能，防护不是很全面，自带的软件库，还有系统优化修复功能，着实方便了很大一批小白用户，360也趁机笼络了一大批小白之心，而且360最近发展也在远离流氓之路，但是360内存占用颇大，经常会有弹窗推销自家全家桶，一不留神，360卫士，360杀毒，360浏览器，360手机助手等等一大批360就都会电脑严重拖慢了电脑速度。
金山毒霸，老牌的国产杀毒软件，当年和瑞星杀毒，江民杀毒同场争霸，现在也有些跟不上时代的潮流，市场份额不断被360侵蚀，推广也越来越流氓，其技术底子还是蛮不错的，对内存占用也不是很大，是一款可以使用的杀毒软件，但是其与电脑管家合作推广，小心再整上金山全家桶。
卡巴斯基，性能很全面，查杀率很高，监控严谨，防火墙相当好。其实占内存不多，但占CPU多，CPU不好的机子会卡。而且对网络游戏的兼容性不好。据说，它会强制删除被病毒感染的系统文件，这不是错，但是很多初用者不喜欢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb785248da67a7d1b4ca613d9b55cfd2/" rel="bookmark">
			ami码编码算法c语言,AMI码编码规则是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AMI码编码规则是：消息代码中的0，传输码中的0；消息代码中的1，传输码中的+1、-1交替。
1码通常称为传号，0码则叫空号，这是沿用了早期电报通信中的叫法。从形态上看，它已是三状态信号，所以AMI码是伪三进制码。
消息代码中的0，传输码中的0；消息代码中的1，传输码中的+1、-1交替。
例如：消息代码:1 0 1 0 1 0 0 0 1 0 1 1 1，AMI码: -1 0 +1 0 -1 0 0 0 +1 0 -1 +1 -1
由AMI码确定的基带信号中正负脉冲交替，而0电位保持不变;所以由AMI码确定的基带信号无直流分量，且只有很小的低频分量。
扩展资料
双极性码是三进制码，1为反转，0为保持零电平。根据信号是否归零，还可以划分为归零码和非归零码，归零码码元中间的信号回归到0电平，而非归零码遇1电平翻转，零时不变。
作为编码方案的双极性不归零码,"1"码和"0"码都有电流,但是"1"码是正电流,"0"码是负电流,正和负的幅度相等,故称为双极性码。
此时的判决门限为零电平,接收端使用零判决器或正负判决器,接收信号的值若在零电平以上为正,判为"1"码;若在零电平以下为负,判为"0"码。
参考资料来源：百度百科-AMI码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc2ae27ba7c31a4aac011b517f57a03/" rel="bookmark">
			电子电路基础 （11）——反馈、偏置与多级放大电路原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、偏置与反馈的概念（非常重要） 1.1 偏置的概念及原理 电极间的直流电压、直流电流通常称为偏置电压、偏置电流。就是在需要放大的信号之输入处（发射极接地时，PNP、NPN型均为基极--发射极之间）预先流通一定值的电流（或加载直流电压），这个就是偏置电压、偏置电流。
二、偏置的必要性 那么为什么要加偏置电压或是预先流通一定值的电流呢？
由于PN结的单向导电性，所以只有在ui的正半周期中为正偏，如图(a)所示基极电流流通。因此，由于集电极电流ic仅在ib流通时流通。结果出现如图(b)所示输出波形。这会有明显的失真现象。
预先对基极流通一定大小的电流，在此基础上即使输入信号稍有变动，其变化也是与输入信号相对应的。我们称这种变化为线性动作。放大电路的静态是指未加交流信号以前的起始状态。
因此，如果预先流通一定大小的直流电流。这样，即使输入波形变为负，基极-发射极之间总为正向电压，输入信号的微弱变化如实地被作为输出电阻两端的较大变化而取出（进行了放大），参看以下图示：
我们将放大电路静态时各处的电压、电流值分别用IBO、ICQ、UBEQ、UCEQ来表示。由于这一组数值代表着输入和输出特性曲线上一个点，（即是指输入信号以此点为中心进行变化）所以习惯上称他们为静态工作点（又叫直流工作点）。
三、利用反馈稳定工作点 我们知道半导体会受到温度影响（比如温度升高了，三极管放大能力增强。那么我们的工作点要是选择的电压较高，当温度升高交流信号正半轴时很容易进入饱和区，当然负半轴还在放大区；要是我们的工作点选择的电压较低，当温度升高交流信号正半轴时还在放大区，当负半轴时就很容易进入截至区）。
补充：三极管的三种状态也叫三个工作区域，即：截止区、放大区和饱和区。
截止区：三极管工作在截止状态，当发射结电压Ube小于0.6—0.7V的导通电压，发射结没有导通集电结处于反向偏置，没有放大作用。放大区：三极管的发射极加正向电压，集电极加反向电压导通后，Ib控制Ic，Ic与Ib近似于线性关系，在基极加上一个小信号电流，引起集电极大的信号电流输出。饱和区：当三极管的集电结电流IC增大到一定程度时，再增大Ib，Ic也不会增大，超出了放大区，进入了饱和区。饱和时，Ic最大，集电极和发射之间的内阻最小，电压Uce只有0.1V~0.3V，Uce&lt;Ube，发射结和集电结均处于正向电压。三极管没有放大作用，集电极和发射极相当于短路，常 与截止配合于开关电路。 为了避免上述出现的情况，我们需要：
选择合适的工作点。控制工作点。也就是当温度上升的时候，要采取措施让他任然处于放大状态，也就是让他处于不失真的状态。 为了满足上述条件，我们引入以下概念。
3.1 反馈的概念 广义的讲，凡是通过一定的方式将输出端的信号送入到输入端，并对输入端产生一定的影响的过程，都称为反馈。
放大电路中的反馈是指通过一定的方式把放大电路中的某一个电量（电压或电流）的一部分或全部送回到输入电路的过程。
3.2 正反馈和负反馈 根据反馈的极性可分为正反馈和负反馈。如果反馈信号加强了原来的输入信号，使放大的倍数增加，这样的反馈称为正反馈，如果反馈的信号削弱了原来的输入信号，使放大电路的放大倍数减小，这样的反馈称为负反馈。
3.3 利用反馈稳定工作点 温度变化对静态工作点的影响。温度升高对三极管的影响，最终将导致集电极电流IC的增大。结果使静态工作点移近饱和区，使输出波形产生严重饱和与失真。
引起工作点波动的外因是环境温度变化，内因则是三极管本身所具有的温度特性。
先设法使基极对地电位 UB基本稳定，即不受温度变化的影响（主要三极管受温度影响较大，而电阻器和三极管相比受温度影响较小，因此我们在UB下方串接一个电阻RB2，那么UB的电位取决于两个电阻的分压，相对就不会受温度的影响）。然后在发射极串接一个电阻RE，用它两端的电压UE来反映IC的变化并和UB相比较，得到IC变化后的UBE值，如果IC增加，则比较后的UBE值应使IB下降，IE也随之下降，其结果将维持IC基本不变。原理分析：温度上升 -&gt; IC上升 -&gt; IE上升，由于RE的作用 -&gt; UE上升，由于RB不变 -&gt; UBE下降 -&gt; IC下降。 如果上面看的还是不清楚，接下来我们进一步分析：
（原文出处：https://blog.csdn.net/weixin_49284870/article/details/112250686）（我对其进行了补充）
将RB1 和RB2 取代了原来的基极电阻RB，对于电源UCC 来说，RB1 和RB2 是一种串联分压的形式。故此电路就叫做分压偏置共射放大电。如果合理地选择各种器件RB1 和RB2，使得电路中的电流和电压满足 I2 &gt;&gt;IB ，VB &gt;&gt;UBE，I2 也就是RB2 上的电流远远大于基极电流 IB ，而 VB 也就是基极电位远远大于UBE，那么就可以通过VB 点的基尔霍夫电流定律，就可以认为基极这条支路视为开路。基于左边支路的串连分压关系，就可以上图中 基极电位 VB 的表达式。通过此式可以看出VB 都是由电阻、电源确定的，都是与温度无关的比较稳定的元件，所以在这种情况下，温度变化的时候基极电位基本恒定。
在此前提下，当温度升高的时候，IC 将会增大。而IC ≈ IE ， IE 是RE上的电流，必然导致 RE 上的电压降会增大，也就是会抬高射极电位VE 。由于基极电位VB 是几乎与温度无关的一个固定量，所以VB 减 VE ，也就是UBE 将会出现下降的趋势。从而根据晶体管的特性曲线知道UBE 变小 IB 自然就会变小，从而最后将本应升高的集电极电流 IC 降下来，起到稳定静态工作点的作用。通过此过程可以看到，这个分压偏置稳定静态工作点主要有两方面，一个是通过串联分压稳定了基极电位VB ，而另一个则是有赖于RE 引入的直流负反馈。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bc2ae27ba7c31a4aac011b517f57a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c53648730ab649ddba17c70165245fa/" rel="bookmark">
			c语言match是什么字符串,字符串匹配算法--暴力匹配(Brute-Force-Match)C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
暴力匹配(Brute-Force-Match)是字符串匹配算法里最基础的算法，虽然效率比较低，但胜在方便理解，在小规模数据或对时间无严格要求的情况下可以考虑。
二、代码
#include #include int bf(char *l,char *s);
int main(void)
{
char s1[201],s2[201]; //根据需要设定数组大小
printf("母串：");
scanf("%s",s1);
printf("子串：");
scanf("%s",s2);
int a=strlen(s1),b=strlen(s2),re=0;
if(a&gt;=b) //母串长度要比子串长
{
re=bf(s1,s2);
if(re==1)
printf("%s是%s的子串",s2,s1);
return 0;
}
else
printf("无法匹配");
return 0;
}
int bf(char *l,char *s)
{
if(!strcmp(l,s)) //如果两个字符串相同直接返回
return 1;
int ll=strlen(l),sl=strlen(s),di=ll-sl;
for(int i=0;i&lt;=di;i++)
{
int temp=0;
for(int j=0;j
{
if(l[i+j]==s[j])
continue;
else
{
temp=1;
break;
}
}
if(temp==1)
continue;
else if(temp==0)
return 1;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c53648730ab649ddba17c70165245fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6be3fecc7b7ca702ad4d0edab405404/" rel="bookmark">
			win10下IDEA连接虚拟机上的HDFS实现文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在windows下连接虚拟机上的HDFS首先要保证windows下有java环境和hadoop环境
这里给出hadoop在windows下的配置方法跳转windows下hadoop环境配置,java环境的配置可以搜相关教程。
IDEA实现虚拟机上HDFS的文件操作 IDEA连接虚拟机上的HDFS 一、环境准备 二、big data tools插件连接HDFS安装步骤 三、通过代码方式连接远程HDFS 四、报错解决 IDEA连接虚拟机上的HDFS 一、环境准备 JDK-13 IDEA2020.3 Ubutun 18.04 Hadoop 2.10.1 二、big data tools插件连接HDFS 安装步骤 1. 打开IDEA,进入插件下载，点击左上角File-&gt;Settings-&gt; Plugins,输入big data tools进行下载。 2. 打开big data tools 进行配置
打开侧边栏的big data tools 新增一个hdfs。
然后进行ip地址的配置.,
HDFS开放的端口地址通过如下方法可以获取，首先在虚拟机中通过ifconfig指令，获取到当前虚拟机的ip地址，然后在虚拟机hadoop安装目录下/etc/hadoop/core-site.xml文件，显示如下
，然后将big data tools的url设置为文件中的地址。这里要注意如果你的是9000端口开放则客户端无法访问到这个端口，可以将9000修改为8020。
最终如下:点击ok即可。
3. 打开big data tools 进行配置
三、通过代码方式连接远程HDFS 连接hadoop所需要的maven依赖:
&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-client --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-common --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6be3fecc7b7ca702ad4d0edab405404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35cf33eb8575db25f52d832a991fcd0c/" rel="bookmark">
			Java8 读取、写入、遍历、监控文件及目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaDoc：https://javadocs.techempower.com/
文章目录 一、读取文件1. Java 8 Stream按行读取文件2. FileReader 按行读取文件3. try-with-resources模式自动关闭流 二、写入文件1. Java 8使用BufferedWriter写入文件2. 使用Files.write（）写入文件 三、遍历迭代目录1. Files.list（）–遍历所有文件和子目录2. Files.list（）–仅列出不包括子目录的文件3. Files.newDirectoryStream（）–列出所有文件和子目录4. Files.newDirectoryStream（）–仅迭代不包含子目录的文件5. 仅列出一定范围的所有文件6. 查找目录中的所有隐藏文件 四、监视目录，子目录和文件中的更改1. 如何注册WatchService2. 观察变化事件3. 监视目录，子目录和文件中的更改示例 一、读取文件 参考链接：https://howtodoinjava.com/java8/read-file-line-by-line-in-java-8-streams-of-lines-example/
在下面的实例中，将使用Stream来一行一行的读取文件。将要读取的文件 data.txt 内容如下：
Never store password except in mind. 将上面的文件一行一行的读取，如果有一行包含 password ，将这行打印出来
1. Java 8 Stream按行读取文件 利用Java 8 Stream按行读取文件内容，过滤包含 password 的行，并取出第一条打印出来
private static void readStreamOfLinesUsingFiles() throws IOException { Stream&lt;String&gt; lines = Files.lines(Paths.get("c:/temp", "data.txt")); Optional&lt;String&gt; hasPassword = lines.filter(s -&gt; s.contains("password")).findFirst(); if(hasPassword.isPresent()) { System.out.println(hasPassword.get()); } //Close the stream and it's underlying file as well lines.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35cf33eb8575db25f52d832a991fcd0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114c9030c8803f361a2fd39ab90916cd/" rel="bookmark">
			SQL Server2008 错误源:.net SqlClient data provider的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL Server2008 错误源:.net SqlClient data provider的解决方法
参考文章：
（1）SQL Server2008 错误源:.net SqlClient data provider的解决方法
（2）https://www.cnblogs.com/yechangzhong-826217795/p/5201162.html
（3）https://www.javazxz.com/thread-3183-1-1.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dae93d7b16e769e39fd767364c697ccb/" rel="bookmark">
			Gradle之cache的问题（没解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先了解一下cache的基本概念
Android 手动下载Gradle的cache依赖包
gradle缓存位置及拷贝jar到maven资源库
上面两篇文章，我们知道gradle会把下载的包缓存到到.gradle/caches/modules-2/files-2.1目录下，而且知道了目录结构的命名规则。
FAILURE: Build failed with an exception. * What went wrong: Could not determine the dependencies of task ':SohuVideoPadMain:preDebugBuild'. &gt; Could not resolve all task dependencies for configuration ':SohuVideoPadMain:debugRuntimeClasspath'. &gt; Could not resolve com.sina.weibo.sdk:core:4.4.1. Required by: project :SohuVideoPadMain &gt; Could not resolve com.sina.weibo.sdk:core:4.4.1. &gt; Could not get resource 'https://dl.bintray.com/thelasterstar/maven/com/sina/weibo/sdk/core/4.4.1/core-4.4.1.pom'. &gt; Could not HEAD 'https://dl.bintray.com/thelasterstar/maven/com/sina/weibo/sdk/core/4.4.1/core-4.4.1.pom'. Received status code 403 from server: Forbidden 现在，我们遇到远程包下载不下来，可能是远程地址失效了，上面的错误日志。想着把别人缓存的copy过来使用。安装上面的文章好像是可以，可是，实际情况是，gradle还是去下载，在网上看到如下一篇文章：
gradle下依赖cache的使用
里面提到把缓存的包放到，Android stuido 安装路径/Contents/gradle/m2repository下面。这个可能对于老版本的AS是对的，新的AS，我得是4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dae93d7b16e769e39fd767364c697ccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1be72b986d3ab328194e001f76befa0/" rel="bookmark">
			Dubbo NoSuchMethodException: Not found method “xxx“ in class xxx问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： Caused by: org.apache.dubbo.common.bytecode.NoSuchMethodException: Not found method "getUserInfo" in class com.UserService.
问题分析： 1、UserService的getUserInfo方法传参已经修改，但是UserService对应的jar包没有更新。
解决办法：把jar包删除，重新获取一遍。
2、UserService对应的jar包包含该方法，但是部署的UserService没有该方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9c04b06598630bdc783f24971e33df3/" rel="bookmark">
			c语言在1到100取随机数,你好，怎样用c语言输出一个1到100的随机数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源程序如下：#include"pch.h"#include&lt;iostream&gt;#include&lt;time.h&gt;usingnamespacestd;intmain(){constintn=10000;intnumber[n]={NULL};srand((unsigned)time(NULL));number[0]=rand()%n; //第一个随机数无需比较cout&lt;&lt;number[0]&lt;&lt;"";for(inti=1;i&lt;n;i++) //其余随机数循环产生{intj=0；number[i]=rand()%n;while(1){if(number[i]==number[j]) //若有相同则继续循环重新安排随机数{number[i]=rand()%n;j=0; //若遇到相同的就从头遍历continue;}if(j==(i-1)) //若遍历完就跳出break;j++;}cout&lt;&lt;number[i]&lt;&lt;"";}cout&lt;&lt;endl;return0;}程序运行结果：扩展资料：其他实现方式：#include&lt;time.h&gt;//使用time函数必须引入time.h头文件#include&lt;stdlib.h&gt;intmain(){srand((int)time(0));intrand_num=rand();printf("rand_num=%d\n",rand_num);return0;}
阅读全文 &gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b8c14da85c2de64b0793bd39599e47/" rel="bookmark">
			c语言输出1 121 12321,1 121 12321 1234321 123454321 12345654321 1234567654321 123456787654321123456789876...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最佳答案1 121 12321 1234321 123454321 12345654321 1234567654321 12345678765432112345678987654321用C语言编程输出等腰三角形只定义三个变量i,j,k
/* 1
121
12321
1234321
123454321
12345654321
1234567654321
123456787654321
12345678987654321
用C语言编程输出等腰三角形
只定义三个变量i,j,k
*/
#include&lt;&gt;
main()
{
int i=0;
int j=0;
int k=0;
for(i=1;i&lt;10;i++)
{
for(k=1;k&lt;=9-i;k++)
{
printf(" ");
}
for(j=1;j&lt;=i;j++)
{
printf("%d",j);
}
for(k=j-2;k&gt;=1;k--)
{
printf("%d",k);
}
printf("\n");
}
}
重要的是自己理解思路和算法，不理解抄了也没用 补充：你找一下它们的规律就知道了，外部循环是循环几行，内部循环一：打印空格，内部循环二：打印前半段，所以自加，内部循环三：打印后半段，所以自减，这么说能明白吧 追问：你说的内部循环二、三可以合并成一个的吗 回答：我是做不到合并的，两个循环的条件及变量都不一样。再说这样不更直观么，而且符合只用三个变量。非要合并的话应该也可以，但是要加变量 追问：哦 谢谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798b9a022d71f6f6240e0dea60294bd3/" rel="bookmark">
			c语言中&amp;amp;什么意思,C语言中的符号 &amp; 和 | 是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&amp;: 在C语言中有两种意思，一种是取地址符，是单目运算符；另一种是位运算符，表示“按位与”，是双目运算符。|: 是位运算符，表示“按位或”。
资料扩展
1、符号 &amp; 和 | 这两个运算符都是二进制的按位操作符。
&amp;: 二进制“与”(都为1时，结果是1，否则是0。)，比如:1010 &amp; 1011 = 1010，1010 &amp; 1000 = 1000。
|: 二进制“或”(有1时，结果是1，都是0时，结果为0。)，比如:1010 | 1011 = 1011，1010 | 1000 = 1010。
2、位运算符将数字视为二进制值，并按位进行相应运算，运算完成后再重新转换为数字。
例如:
表达式10&amp;15表示(1010 &amp; 1111)，它将返回表示1010的值10。因为真真得真，或者是11得1，同位全是1结果也是1。
表达式10|15表示(1010 | 1111),它将返回表示1111的值15。假假得假。全零得零。
3、C语言中的符号分为10类:算术运算符、关系运算符、逻辑运算符、位操作运算符、赋值运算符、条件运算符、逗号运算符、指针运算符、求字节数运算符和特殊运算符。
4、位操作运算符:参与运算的量，按二进制位进行运算。包括位与(&amp;)、位或(|)、位非(~)、位异或(^)、左移(&lt;&gt;)六种。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2022116c7577311eaa60ee3692d552/" rel="bookmark">
			c语言输出倒字母金字塔,打印字母金字塔，昨晚看到某个帖子的题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该楼层疑似违规已被系统折叠 隐藏此楼查看此楼
编程实现打印字母金字塔
如以下形式：
A
ABA
ABCBA
ABCDCBA
ABCDEDCBA
ABCDEFEDCBA
ABCDEFGFEDCBA
ABCDEFGHGFEDCBA
ABCDEFGHIHGFEDCBA
ABCDEFGHIJIHGFEDCBA
程序代码：
#include
#include
void print1(int i,int n);//打印每行的空格
void print2(int n);//打印字母
int main()
{
int n;
loop:printf("输入你要金字塔层数n:");
scanf("%d",&amp;n);/*输入金字塔的层数*/
if(n&gt;0&amp;&amp;n&lt;27)
{
print2(n);//打印金字塔
}
else
{
printf("您的输入有误0
goto loop;
}
return 0;
}
void print1(int i,int n)/*打印每层前半部和后半部的空格*/
{
while(n-i-1&gt;0)
{
printf(" ");
i++;
}
}
void print2(int n)
{ int i,j;
char *str;
printf("%d层字母金字塔:\n",n);
str=(char*)malloc(sizeof(char)*n);/*n层金字塔包含n个字母*/
str[0]='A';/*首字母为A*/
for(i=0;i
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be2022116c7577311eaa60ee3692d552/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02331a12a242021d3aa1febbc5010848/" rel="bookmark">
			C语言中的频率函数,请计算下列C语言程式片断或函数的频率计数和时间复杂度，如下所示 .DOC...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请计算下列C语言程式片断或函数的频率计数和时间复杂度，如下所示
請計算下列C語言程式片斷或函數的頻率計數和時間複雜度，如下所示(10%)：
(a)
i = 1;1
while ( i &lt;= n ) {n+1
a = a+1;n
i++;n
}
頻率計數：3n+2
時間複雜度：O(n)
(b)
void printMoney( int level ) {
if (level == 0) {n+1
printf("$");1
} else {
printf("
printMoney(level-1);n
printf("&gt;");n
}
}
頻率計數：4n+2
時間複雜度：O(n)
請問下列哪一個關於Big Oh的敘述是錯誤的(5%)？
A. 5n2 - 6n = O(n2) B. 10n100 + 2n = O(n100)
C. 99n + 1 = O(n) D. 100 + 5 = O(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02331a12a242021d3aa1febbc5010848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd207165e8a8a9a64086acd56b91d329/" rel="bookmark">
			c语言扩展python教程,使用C语言编写Python扩展2——函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节介绍了编写扩展的基本流程。这一回介绍一下在扩展模块中的函数调用，包括在扩展函数的参数提取和关键字参数解析，以及在C语言中调用Python方法。
同样的本文中的示例代码可从 https://github.com/wusuopu/python-c-extension-sample 获取到。
参数提取
接着上一节的例子，我们继续编辑lc_hello.c文件。先往模块中添加一个名为 func1 的函数，即就是在 lc_hello_world_methods 数组中添加一项：
{"func1", (PyCFunction)func1_function, METH_VARARGS, NULL},
然后就是对该函数的实现。
参数提取是使用 PyArg_ParseTuple 方法，其定义如下：
int PyArg_ParseTuple(PyObject *arg, char *format, ...);
其中 arg
参数为Python向C函数传递的参数列表，是一个无组对象； format
参数是一个格式化字符串，它的格式可以参考 Python/C API 文档。
func1_function 函数实现如下：
static PyObject* func1_function(PyObject *self, PyObject *args)
{
int num, i, j;
long lnum=0;
const char* s1 = NULL;
PyObject *obj = NULL;
if (!PyArg_ParseTuple(args, "is(ii)|l",
&amp;num, &amp;s1, &amp;i, &amp;j, &amp;lnum)) {
printf("传入参数错误！\n");
return NULL;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd207165e8a8a9a64086acd56b91d329/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc0f187d454929de0934f47c7e618ea/" rel="bookmark">
			mac怎么用c语言写文件路径,Mac 中使用os模块更改文件路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cmd+opt+c 复制路径
path='/Applications/MAMP/htdocs/python/day04model/'
import sys
import os
sys.path.append(path)
import test01_md
test01_md.func1()
系统工作平台的名字
print(os.name)
当前脚本工作路径
print(os.getcwd())
点前文件夹下文件目录名
print(os.listdir())
改变工作路径
os.chdir('')
删除文件
os.remove('.py')
处理文件路径和文件名
n=os.path.split('/Applications/MAMP/htdocs/python/day04model/test01_md.py')
print(n)
判断文件、路径是否存在
print(os.path.exists('/Applications/MAMP/htdocs/python/day04model/test01_md.py'))
print(os.path.exists('/Applications/MAMP/htdocs/python/day04model'))
sys模块
import sys
list1= sys.version
list2= sys.path
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c385f09f6002c6adea1fc58fff88cf5/" rel="bookmark">
			线程上下文类加载器(Thread Context ClassLoader)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 线程上下文类加载器(Thread Context ClassLoader)线程上下文类加载器如何破坏双亲委派模型sun.misc.Launcher 线程上下文类加载器(Thread Context ClassLoader) 线程上下文件类加载器(Thread Context ClassLoader)
//设置线程上下文类加载器 通过java.lang.Thread类的setContextClassLoader(ClassLoader cl)方法来设置； 如果创建线程时还未设置上下文类加载器，那么当前线程将会从父线程中继承一个上下文类加载器，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。
线程上下文类加载器如何破坏双亲委派模型 https://www.cnblogs.com/liuligang/p/10519771.html
Java提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。
这些 SPI 的接口由 Java 核心库来提供，而SPI接口中的代码经常需要加载具体的实现类；
这些实现类由 独立厂商 提供，位于 classpath下；
SPI的接口是Java核心库的一部分，是由启动类加载器(Bootstrap Classloader)来加载的；SPI的实现类是由系统类加载器(System ClassLoader)来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。
在 SPI 接口的代码中直接使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。
sun.misc.Launcher https://blog.csdn.net/chaofanwei2/article/details/51335278
https://blog.csdn.net/x_iya/article/details/104459985
https://blog.csdn.net/zhouhao88410234/article/details/92708723
// sun.misc.Launcher 部分源码 static class AppClassLoader extends URLClassLoader { …… } static class ExtClassLoader extends URLClassLoader { …… } “系统类加载器AppClassLoader”、“扩展类加载器ExtClassLoader”都是位于 sun.misc.Launcher。但是它们的访问修饰符（default）导致外界无法直接访问这个加载器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c385f09f6002c6adea1fc58fff88cf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d509d2c65ea8f50c44e75602b90cfd5/" rel="bookmark">
			两种常用建图方法（vector实现邻接表，链式前向星）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、vector实现邻接表1.优点2.思路3.实现代码 二、链式前向星1.优点2.思路3.实现代码 前言 介绍两种建图的方法：
1.用vector实现的邻接表建图
2.链式前向星（邻接表的数组实现）
如果是一个稀疏图，在邻接矩阵中，会出现大量边的浪费，那么我们的思路是使用邻接表，但邻接表的实现方式也存在差异：
1.链表实现
2.vector实现
3.链式前向星
不同的实现方式在原理上存在一些差异，这里将介绍后两种方法，也是我们在做题时最常用的方法。
一、vector实现邻接表 1.优点 我们此时调用了STL中的vector，vector的特点就是它的长度是很灵活的，可以在我们输入数据的过程中自动地进行更新。
适合稀疏图。
2.思路 参考邻接矩阵的创建方法，不过此时我们采用的是vector，注意在过程中可以直接调用vector的函数。
3.实现代码 #include&lt;stdio.h&gt; #include&lt;vector&gt; using namespace std; #define SIZE 1000 vector&lt;vector&lt;int&gt; &gt;adj(SIZE); int n,m; void init() { scanf("%d%d",&amp;n,&amp;m); int i,j; int a,b; for(i=1;i&lt;=n;i++) { adj[i].clear(); //清除 } for(i=1;i&lt;=m;i++) { scanf("%d%d",&amp;a,&amp;b); adj[a].push_back(b); } } void print() { int i; int j; for(i=1;i&lt;=n;i++) { printf("dian %d:",i); for(j=0;j&lt;adj[i].size();j++) { printf("%d ",adj[i][j]); } printf("\n"); } } int main() { int t; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d509d2c65ea8f50c44e75602b90cfd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221b4768fda36032ca4e072b2ead8a18/" rel="bookmark">
			对称加密与非对称加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对称加密 对称加密的特点是加密 和 解密使用相同的密钥；
非对称加密 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）
公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；
如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6718ede1cb9b9a5a9174085814d145b9/" rel="bookmark">
			centos SSH免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SSH免密登录 SSH免密登录 准备2台节点node1、node2在node1上输入ssh-keygen,然后连续3个回车；接着输入ssh-keygen node1 以及 ssh-keygen node2,安装提示输入yes以及用户密码；node2上重复 第二、第三步；测试
node1上输入ssh node2,如果配置成功，便可以免密码登陆到node2; ssh-keygen命令会在当前用户目录下创建.ssh目录；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f92868236c951ebcff8171ab9346f48/" rel="bookmark">
			Android后台限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Andriod后台限制汇总 从Android开发者网站上，目前看到4种限制机制，分别是低电耗模式，应用待机模式，应用待机分组和省电模式。本文对这些后台限制模式进行简单的汇总。
该文章的内容均来自于Android开发者网站。对于这些限制，本人没有全部实际测试，只是为了记录。
此外，每个手机厂商可能会定制一些自己的逻辑，所以可能和Android开发者网站的描述可能不一致。
低电耗模式 低电耗模式就是doze模式。Android开发者网站对低电耗模式的描述如下：
如果用户未插接设备的电源，在屏幕关闭的情况下，让设备在一段时间内保持不活动状态，那么设备就会进入低电耗模式。在低电耗模式下，系统会尝试通过限制应用访问占用大量网络和 CPU 资源的服务来节省电量。它还会阻止应用访问网络，并延迟其作业、同步和标准闹钟。
系统会定期退出低电耗模式一小段时间，让应用完成其延迟的活动。在此维护期内，系统会运行所有待处理的同步、作业和闹钟，并允许应用访问网络。
限制：
暂停访问网络
忽略wakelock
推迟Alarm
不执行 WLAN 扫描
不运行SyncAdapter
不运行JobScheduler
命令：
adb shell dumpsys deviceidle force-idle adb shell dumpsys deviceidle unforce adb shell dumpsys battery reset 应用待机模式 应用待机模式允许系统判定应用在用户未主动使用它时是否处于闲置状态。当用户有一段时间未触摸应用时，系统便会作出此判定，以下条件均不适用：
用户正在打开应用
应用有一个前台进程
应用存在通知(锁屏通知或通知栏通知)
应用是设备管理器
命令：
adb shell dumpsys battery unplug adb shell am set-inactive &lt;packageName&gt; true adb shell am set-inactive &lt;packageName&gt; false adb shell am get-inactive &lt;packageName&gt; 应用待机分组 Android 9 引入了一项新的电池管理功能，即应用待机群组。 应用待机群组可以基于应用最近使用时间和使用频率，帮助系统排定应用请求资源的优先级。 根据使用模式，每个应用都会归类到五个优先级群组之一中。 系统将根据应用所属的群组限制每个应用可以访问的设备资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f92868236c951ebcff8171ab9346f48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1f35c45ac8ebed466ba7256b84c8af/" rel="bookmark">
			intpart在C语言中怎么运用,《数据结构和算法分析---C语言描述》读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、绪论
1、导致递归的四个基本法则：
(1)基准情形：必须总有某些基准情形，它无须递归就能解出，这就好比数学归纳法中的第一步，证明基本情况
(2)不断推进：每一次递归调用都必须要使求解状况朝接近基准情形的方向推进
(3)设计法则：所有的递归调用都能运行
(4)合成效益法则：在求解一个问题时，切勿在不同的递归调用中做重复的工作，
例如斐波那契序列不符合这一条，
f(n)= f(n-1)+f(n-2)
而f(n-1) = f(n-2)+f(n-3)，这当中就和f(n)重复了，所以效率很低。
2、只使用处理I/O的printDigit函数编写一个过程以输出任意整数(可以是负数)
/*打印出一个整数*/
voidprintOut(intn)
{
/*该整数的中间数都以正数打出*/
if(abs(n) &gt;= 10)
{
printOut(n/10);
printf("%d", abs(n%10));
} else//第一个数字按原样打出
printf("%d", n%10);
}
/*打印一个实数n，pointNum小数点位数*/
voidprintReal(doublen,intpointNum)
{
/*整数部分*/
intintPart, i, dicInt = 0;
/*小数部分*/
doubledicPart;
intPart = n;
dicPart = n - intPart;
/*打印整数部分*/
printOut(intPart);
if(pointNum &gt; 0)
{
/*打印小数点*/
printf(".");
/*将小数部分转换为整数*/
for(i = 0; i {
dicPart *= 10;
}
/*小数部分符号都弄为正数*/
dicInt = abs(dicPart);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d1f35c45ac8ebed466ba7256b84c8af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e433c369d8dbcb7381c0f599dd1fe4d1/" rel="bookmark">
			java.lang.NoSuchMethodException: org.apache.catalina.deploy.WebXml addServlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录错误java.lang.NoSuchMethodException: org.apache.catalina.deploy.WebXml addServlet -------------------------------------------------------------------------------------------------------------------
?
解决此异常的方法是：
删除您添加在Referenced Libraries 下的catalina.jar包，
然后删除Webapp下的部署程序，重新部署后一切正常。
?
---------------------------------------
?
网上另一个解决方法是：
在tomacat的context.xml里加上&lt;Loader delegate="true" /&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb690e266c9a61c18c97d739842b51d/" rel="bookmark">
			有什么做GIF的软件?这3款APP超酷炫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有什么做GIF的软件?喜欢聊微信的你们都有这种感觉吧：聊天的时候，大部分情况下都是动态图片比静态图片更能表达情绪。经常会看到一张有意思的动态图片后，像中了魔一样反复观看，说不定还会嘻嘻嘻地笑出声来吓到身边的朋友——这就是动图的魔力！下面我给大家介绍APP超酷炫的制作GIF的软件。
玩图
玩图GIF看名字就知道应该是来自玩图一家应用，这款软件感觉上是还不错，可以拍一些gif动态图，不过严格点来讲，应该是一个视频转gif工具，很不错。 玩图-全能手机P图神器，5000万用户的选择，不但基础功能强大，并且还具有画中画、拼立得等创新功能。
软件特色
【贴纸】上百款贴纸，贱萌、可爱、女神、街拍、森女、清新等超多风格可供选择。智能表情贴纸，自动识别人脸。
【美颜相机】可以一键美颜的相机。只要按一下快门，瘦脸、祛痘、美白、去眼袋同步进行!加上可调控的自然美颜效果，让你一键变白富美呦。
【经典拼图】晒多图利器百看不厌，正方形、长方形、圆角、留白、拼接等100+拼图样式!
Gif斗图制作app
Gif斗图制作app是款能一键轻松制作动图的手机软件，此外gif斗图制作软件可以将静图秒变动图，还提供N多静态+动态贴纸与特效文字，让你可快捷制作出想要的图片效果。
功能介绍
1.图片变动图：用手机内的图片制作GIF，将你的图片变成有趣的动画;
2.GIF编辑：支持对GIF帧进行排序，裁剪，隐藏，删除，复制，添加等操作，制作你的专属表情;
3.静态+动态贴纸：200+高清贴纸素材，满足你的制作需要;
4.特效文字：文字支持缩放、翻转、旋转，还可以增加闪烁，抖动，跑马灯等特效，让你的表情瞬间动起来;
5.我的GIF：保存制作的GIF到相册中，随时分享到微博，微信，小伙伴圈中。
以上就是为你推荐的gif动图制作app，想要在聊天中增加气氛，让那个男女神对于产生好感?那还等什么，gif动图制作app将会是你最好的选择。
DU GIF Maker
DU GIF Maker app是一个具有丰富gif编辑功能的客户端应用，DU GIF Maker手机版上可以将视频转化为gif，也能将多张图片合成gif，多功能助你创作出自己喜欢的。
软件特色
丰富的GIF编辑功能
将视频转为GIF图片
将多张图片合成GIF
分享你的GIF图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f77ef1e897678d05710e5b2b0ede133/" rel="bookmark">
			MapStruct、ignore
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc] 使用由Spring代理不由spring代理 其它属性ignore 原理 Json工具是通过序列化反序列化来实现的，性能低下。
MapStruct是通过getter、setter来实现的。
&lt;!--MapStruct依赖--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mapstruct/mapstruct-jdk8 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;1.0.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mapstruct/mapstruct-processor --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;1.0.0.Final&lt;/version&gt; &lt;/dependency&gt; 使用 @Data @Builder public class User { private String uname; private Integer uid; private String uaddr; } @Data @Builder @ToString @AllArgsConstructor @NoArgsConstructor public class UserDto { private String name; private Integer id; private Integer updateUserId; } 由Spring代理 import org.mapstruct.Mapper; import org.mapstruct.Mapping; import org.mapstruct.factory.Mappers; @Mapper(componentModel = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f77ef1e897678d05710e5b2b0ede133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d76ff679995b4c7d102eeb147b9a0b5/" rel="bookmark">
			c语言中fabs是什么意思,c语言fabs是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 c语言fabs是什么意思？
fabs函数是一个求绝对值的函数，求出x的绝对值，和数学上的概念相同，函数原型是extern float fabs(float x)，用法是#include 。
推荐学习：c语言视频教程
fabs()函数的声明：double fabs(double x)。其中参数x 是浮点值，这个函数返回x的绝对值。代码示例如下：int main (){int a, b;a = 1234;b = -344;printf("The absolute value of %d is %lf", a, fabs(a));printf("The absolute value of %d is %lf", b, fabs(b));return(0);}
编译和运行上面的程序，这将产生以下结果：The absolute value of 1234 is 1234.000000The absolute value of -344 is 344.000000
扩展资料：
fabs()和abs()区别：
(1)参数对象不同
abs()是对整数取绝对值, 而fabs()是对浮点数取绝对值。
(2)函数原型不同：int abs(int x)double fabs(double x)
(3)头文件不同：abs(): #include fabs(): #include 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10a768dcd7cf98c10255740809ff491/" rel="bookmark">
			c语言程序如何编写选择题,c语言程序 如何编写挑选题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		呵呵，很简单的问题呀，我这里有四种方法，你参考一下
#include
void main()
{
int a,b,c,max; //这里只能为整形，不能为double型
printf("please input three number a,b,c:\n");
scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
// method one:
max=a;
if(b&gt;=max) max=b;
if(c&gt;=max) max=c;
printf("the max is:%d\n",max);
// method two:
if(a&gt;=b&amp;&amp;a&gt;=c)
printf("the max is %d\n",a);
else if(b&gt;=a&amp;&amp;b&gt;=c)
printf("the max is %d\n",b);
else
printf("the max is %d\n",c);
// method three:
printf("the max is: %d\n",a&gt;=b&amp;&amp;a&gt;=c?a:(b&gt;=a&amp;&amp;b&gt;=c?b:c));
// method four:
int a[3],max=-32768;
for(int i=0;i&lt;3;i++)
{
scanf("%d",&amp;a[i]);
if(a[i]&gt;max) max=a[i];
}
printf("the max is:%d\n",max);
}
取消
评论
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68e75c5b0b8d4b2db9590682a75f5c32/" rel="bookmark">
			利用Debug调试代码解决0xC0000005: 读取位置 0x0000000000000000 时发生访问冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS2019利用Debug调试代码解决0xC0000005: 读取位置 0x0000000000000000 时发生访问冲突
之前一直是使用release发布代码模式进行程序编译，前天突然出现这个问题：
0xC0000005: 读取位置 0x0000000000000000 时发生访问冲突
查找资料发现大概率是出现了空指针。没有判断指针是否为空就进行后续操作导致的错误，但是release模式并没有提示问题出现在哪里，只是显示程序崩掉，并且给你错误信息，查找资料后发现Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用，但是会忽略调试信息，这不利于我们进行程序调试。（所以我只凭借经验进行初步调试，但是效率很低也没有解决实际问题）
而debug配置能够包含调试信息，并且不作任何优化，便于程序员调试程序。
这就方便我们进行程序的调试和断点设置，设置了断点就可以看到所有变量的信息。就方便我们找到问题出现在了哪里。
果然，当我将配置改为debug后，运行程序，就会自动显示下图所示地方发生错误：为nullptr，空指针。那么问题就显而易见了。
但是我在上句语句中已经获得了pGalvanometer对象指针，这里不应该是nullptr。所以我在该位置设置断点，运行后，发现hr不为S_OK，而是显示加载有问题，那么很显然问题出在我加载外部组件COM中了。
但是我并没有改变COM组件的加载代码，于是认为可能组件注册出现问题。于是我重新注册了一下COM组件。
问题成功解决！
该次经历给我的经验就是在编写调试代码时要及时切换为Debug模式，因为Debug会保留调试信息，而且代码是原汁原味的，不会做任何改变，也方便我们进行调试。我本身并不是计算机专业，所以这些很基础的经验对我来说也帮助甚大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d8562616c8c74091a24a6051902c9a/" rel="bookmark">
			为什么编程c语言大括号不变红,为什么我用了大括号之后会下面有红色波浪线，运行的时候就因为这个一直不成功。一直都是按部就班的来的...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%87%BA%E5%9B%BD%E7%A7%BB%E6%B0%91%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%9B%BD%E4%BC%81%E5%8D%95%E4%BD%8D%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%81%A5%E5%BA%B7%E8%AF%81%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%85%A5%E8%81%8C%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E7%A6%8F%E5%88%A9%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%B9%99%E8%82%9D%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BB%A3%E6%A3%80%E6%9C%BA%E6%9E%84%E5%93%AA%E5%AE%B6%E5%A5%BD%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E6%98%AF%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%85%A5%E8%81%8C%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E8%A6%81%E5%A4%9A%E5%B0%91%E9%92%B1%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E6%95%99%E5%B8%88%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E6%95%99%E5%B8%88%E4%BD%93%E6%A3%80%E4%BB%A3%E6%9B%BF%E6%8A%BD%E8%A1%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E5%AE%B9%E6%98%93%E8%A2%AB%E5%8F%91%E7%8E%B0%E4%B9%88%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E4%B8%80%E8%88%AC%E5%A4%9A%E5%B0%91%E9%92%B1%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E6%80%8E%E4%B9%88%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%8A%BD%E8%A1%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E7%94%B5%E8%AF%9D%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E5%8F%AF%E4%BB%A5%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%A3%80%E5%90%97%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%85%A5%E8%81%8C%E4%BD%93%E6%A3%80%E6%9C%89%E4%BB%A3%E6%A3%80%E7%9A%84%E5%90%97%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E6%80%8E%E4%B9%88%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BA%8B%E4%B8%9A%E5%8D%95%E4%BD%8D%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BA%8B%E4%B8%9A%E5%8D%95%E4%BD%8D%E4%BD%93%E6%A3%80%E6%80%8E%E4%B9%88%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%85%AC%E5%8A%A1%E5%91%98%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E6%88%90%E5%8A%9F%E7%8E%87%E6%9C%89%E5%A4%9A%E9%AB%98%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E6%8A%BD%E8%A1%80%E4%BB%A3%E6%9B%BF%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E6%95%99%E5%B8%88%E7%94%B2%E4%BA%A2%E4%BD%93%E6%A3%80%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%A6%82%E4%BD%95%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%9B%BF%E4%BD%93%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%B8%93%E4%B8%9A%E4%BB%A3%E6%A3%80%E6%9F%A5%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%85%A5%E8%81%8C%E4%BD%93%E6%A3%80%E4%BB%A3%E6%9B%BF%E6%8A%BD%E8%A1%80%E4%BC%9A%E8%A2%AB%E5%8F%91%E7%8E%B0%E5%90%97%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E6%80%8E%E4%B9%88%E6%89%BE%E4%BA%BA%E6%9B%BF%E4%BB%A3%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%8D%A2%E4%BA%BA%E4%BB%A3%E6%A3%80%E5%90%97%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BA%8B%E4%B8%9A%E5%8D%95%E4%BD%8D%E4%BD%93%E6%A3%80%E6%80%8E%E4%B9%88%E6%89%BE%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BB%A3%E4%BA%BA%E4%BD%93%E6%A3%80%E5%85%AC%E5%8F%B8%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E5%A6%82%E4%BD%95%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%9B%BF%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%88%AB%E4%BA%BA%E8%83%BD%E4%BB%A3%E6%9B%BF%E6%8B%8D%E7%89%87%E5%90%97%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E8%B4%B9%E7%94%A8%E6%98%AF%E5%A4%9A%E5%B0%91%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BB%A3%E6%9B%BF%E4%BD%93%E6%A3%80%E6%9C%BA%E6%9E%84%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%85%AC%E5%8A%A1%E5%91%98%E4%BB%A3%E6%9B%BF%E4%BD%93%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BD%93%E6%A3%80%E8%83%BD%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%9B%BF%E5%90%97%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E6%8A%BD%E8%A1%80%E5%8F%AF%E4%BB%A5%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%9B%BF%E5%90%97%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%A6%82%E4%BD%95%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%9B%BF%E6%8A%BD%E8%A1%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E4%BB%A3%E4%BA%BA%E4%BD%93%E6%A3%80%E7%94%B5%E8%AF%9D%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E5%85%AC%E5%8A%A1%E5%91%98%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E9%9D%A0%E8%B0%B1%E5%90%97%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%99%8B%E5%9F%8E%E8%B0%81%E5%8F%AF%E4%BB%A5%E4%BB%A3%E5%8A%9E%E5%85%A5%E8%81%8C%E4%BD%93%E6%A3%80%E5%8C%BB%E9%99%A2%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BB%A3%E6%A3%80%E4%BD%93%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E5%85%AC%E5%8A%A1%E5%91%98%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BA%8B%E4%B8%9A%E5%8D%95%E4%BD%8D%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E5%85%AC%E5%8F%B8%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E6%9C%BA%E6%9E%84%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E6%8A%BD%E8%A1%80%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E5%87%BA%E5%9B%BD%E7%A7%BB%E6%B0%91%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E5%9B%BD%E4%BC%81%E5%8D%95%E4%BD%8D%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E5%81%A5%E5%BA%B7%E8%AF%81%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E5%85%A5%E8%81%8C%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E7%A6%8F%E5%88%A9%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%B9%99%E8%82%9D%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BB%A3%E6%A3%80%E6%9C%BA%E6%9E%84%E5%93%AA%E5%AE%B6%E5%A5%BD%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E6%98%AF%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E5%85%A5%E8%81%8C%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E8%A6%81%E5%A4%9A%E5%B0%91%E9%92%B1%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E6%95%99%E5%B8%88%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E6%95%99%E5%B8%88%E4%BD%93%E6%A3%80%E4%BB%A3%E6%9B%BF%E6%8A%BD%E8%A1%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E5%AE%B9%E6%98%93%E8%A2%AB%E5%8F%91%E7%8E%B0%E4%B9%88%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E4%B8%80%E8%88%AC%E5%A4%9A%E5%B0%91%E9%92%B1%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BD%93%E6%A3%80%E6%80%8E%E4%B9%88%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%8A%BD%E8%A1%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BD%93%E6%A3%80%E4%BB%A3%E6%A3%80%E7%94%B5%E8%AF%9D%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BD%93%E6%A3%80%E5%8F%AF%E4%BB%A5%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%A3%80%E5%90%97%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E5%85%A5%E8%81%8C%E4%BD%93%E6%A3%80%E6%9C%89%E4%BB%A3%E6%A3%80%E7%9A%84%E5%90%97%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
azure.microsoft.com/zh-cn/search/documentation/?q=%E6%9C%94%E5%B7%9E%E4%BD%93%E6%A3%80%E6%80%8E%E4%B9%88%E6%89%BE%E4%BA%BA%E4%BB%A3%E6%A3%80%E3%80%90%E7%94%B515820.499.455%20%E9%A1%BA%E5%88%A9%E8%BF%87%E5%85%B3%E3%80%91
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d8562616c8c74091a24a6051902c9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c5e2dbfc6c6c12ca22a0498e33ba7da/" rel="bookmark">
			《视觉SLAM》学习笔记（二）——ch3三维空间刚体运动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《视觉SLAM》学习笔记（二）——ch3三维空间刚体运动 一、点与坐标系二、欧式变换——旋转矩阵、.旋转向量、欧拉角、四元数2.1 旋转矩阵2.2 旋转向量2.3 欧拉角（Euler Angles）2.4 四元数（Quaternion）2.4.1 四元数结构2.4.2 四元数表示旋转2.4.3 四元数表示一个空间点P及其旋转2.4.4 四元数运算 2.5 区别与联系 三、其他变换3.1 相似变换3.2 仿射变换3.3 射影变换3.4 区别与联系 四、Eigen库4.1 Eigen库简介及安装4.2 Eigen库初识4.3 Eigen库几何模块练习4.4 可视化模块练习4.5 问题及解决4.5.1 “can not find any cmake profile”4.5.2 “ Could not find a package configuration file provided by ‘Pangolin’ with any of the following names“4.5.3 “./visualizeGeometry: /lib/x86_64-linux-gnu/libz.so.1: version `ZLIB_1.2.9' not found” 课程视频地址【第二版】：https://www.bilibili.com/video/BV1D54y1G7f6
课程视频链接【第一版】：https://www.bilibili.com/video/BV16t411g7FR
课程github地址：https://github.com/gaoxiang12【第一版、第二版的代码】
电子书下载见《学习笔记（一）》1.2节
【提示】无论使用哪个版本的纸质书，先去github上对照作者给的勘误文件，纠正一下书中的错误。
《视觉SLAM十四讲》学习笔记（一）——ch1-2 预备知识，初识SLAM
《视觉SLAM十四讲》学习笔记（三）——ch4 李群李代数
《视觉SLAM十四讲》学习笔记（四）【敬请期待】
《视觉SLAM十四讲》学习笔记（五）【敬请期待】
…
Cmake官方文档：https://cmake.org/documentation/【选择自己安装的对应版本】
Eigen深入学习：https://eigen.tuxfamily.org/index.php?title=Main_Page
…
Q0：上文提到，slam问题的数学描述中位置的表达，那么如何确定Xk呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c5e2dbfc6c6c12ca22a0498e33ba7da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191a04b2c71fc6bb9a0a0af7f8e35d98/" rel="bookmark">
			print是c语言的变量吗,c语言print这个函数怎么用?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		printf后面的参数包括“格式控制字符串”和输出变量的列表“格式控制字符串”由格式控制字符和普通字符。其中前者以%开始加某一个特殊字符。比如%d为输出整数、%c输出字符。普通字符是原样输出的内容。
输出变量列表即为输出的变量，其个数要与控制字符相对于。比如有int a=3，b=4，然后pritf(“a=%d，b=%d”，a，b)。
输出结果为a=3，b=4。以printf("abc")中abc为格式控制字符串中的普通字符，原样输出。print(“%d”,i)为以整形输出变量i的值。
printf命令的作用是格式化输出函数，一般用于向标准输出设备按规定格式输出信息。printf()函数的调用格式为：printf("", )。
printf()是C语言标准库函数，在 stdio.h 中定义。输出的字符串除了可以使用字母、数字、空格和一些数字符号以外，还可以使用一些转义字符表示特殊的含义。
扩展资料：
printf函数定义：
函数声明：
int printf(char *format...)；
调用格式：
printf("", )；
格式化字符串包含三种对象，分别为：
(1)字符串常量；
(2)格式控制字符串；
(3)转义字符。
字符串常量原样输出，在显示中起提示作用。输出表列中给出了各个输出项，要求格式控制字符串和各输出项在数量和类型上应该一一对应。其中格式控制字符串是以%开头的字符串，在%后面跟有各种格式控制符，以说明输出数据的类型、宽度、精度等。
格式控制字符串format：
format-- 是字符串，包含了要被写入到标准输出 stdout 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。
printf的格式控制字符串format组成如下：
%[flags][width][.prec][length]type。
即：%[标志][最小宽度][.精度][类型长度]类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5b541de5f07122341aee5aee827164/" rel="bookmark">
			c语言只需编译 不需连接,C语言程序设计-中国大学mooc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言程序设计-中国大学mooc
http://carrottt.blog.bokee.net 2020-6-9
转载自网课答案 (www.daanplus.com) ：
完整答案请关注公众号【大学答案帮手】查看！
1、计算机只能处理由人们编写的、解决某些问题的、事先存储在计算机存储器中的二进制指令序列。
答案：正确
2、通常把高级语言源程序翻译成目标程序的程序称为( )。
A、编辑程序
B、解释程序
C、汇编程序
D、编译程序
答案：D
3、一个算法应该具有"确定性"等5个特性，下面对另外4个特性的描述中错误的是()。
A、有零个或多个输出
B、有穷性
C、有零个或多个输入
D、可行性
答案：A
4、结构化程序由三种基本结构组成，三种基本结构组成的算法，( )。
A、只能完成一些简单的任务
B、只能完成符合结构化的任务
C、可以完成任何复杂的任务
D、只能完成部分复杂的任务
答案：C
5、面向对象方法中，一个对象请求另一个对象为其服务的方式是通过发送()完成的。
A、命令
B、消息
C、口令
D、调用语句
答案：B
6、C语言规定，在一个源程序中，main函数的位置()。
A、必须在系统调用的库函数的后面
B、必须在*后
C、可以任意
D、必须在*开始
答案：C
7、以下叙述正确的是()。
A、在对一个C程序进行编译的过程中，可发现注释中的拼写错误
B、在C程序中，main函数必须位于程序的*前面
C、C语言本身没有输入输出语句
D、C程序的每行中只能写一条语句
答案：C
8、一个C程序的执行是从()。
A、本程序的main函数开始,到main函数结束
B、本程序文件的*个函数开始，到本程序main函数结束
C、本程序文件的*个函数开始，到本程序文件的*后一个函数结束
D、本程序的main函数开始，到本程序文件的*后一个函数结束
答案：A
9、以下叙述中正确的是 ()。
A、花括号"{"和"}"只能作为函数体的定界符
B、构成C程序的基本单位是函数,所有函数名都可以由用户命名
C、分号是C语句之间的分隔符,不是语句的一部分
D、C程序中注释部分可以出现在程序中任意合适的地方
答案：D
10、以下叙述正确的是( )。
A、C语言允许直接访问物理地址，可以直接对硬件进行操作
B、C语言程序不用编译，即可被计算机识别运行
C、C语言不允许直接访问物理地址，不可以直接对硬件进行操作
D、C语言程序只需编译，不需连接即可被计算机运行
答案：A
11、下面不是算法特征的是( )。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f5b541de5f07122341aee5aee827164/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea20da4963f17219b88fa97767f4f869/" rel="bookmark">
			【记录】python画图双y轴图例合并，图例位置控制，输出为svg格式，保存图片白边大小控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np import matplotlib.pyplot as plt from matplotlib import rcParams config = { "font.family": 'serif', # "font.family": 'Times New Roman', "font.size": 12, "mathtext.fontset": 'stix', "font.serif": ['SimSun'], } rcParams.update(config) # config中的font.size不能调整图片标题字体的大小 # 可设置字体为宋体或者新罗马 x = np.arange(1, 24 + 1).reshape(24).tolist() y1 = x y2 = np.arange(24, 0, -1).reshape(24).tolist() fig = plt.figure(figsize=(5, 3)) ax = fig.add_subplot(111) # zorder可以调整图片层级 ax.plot(x, y1, marker='.', label='正比例函数', zorder=2) # 第二个y轴 ax2 = ax.twinx() ax2.plot(x, y2, marker='.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea20da4963f17219b88fa97767f4f869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da24d9ab315e61d4ccdab73a7da2778/" rel="bookmark">
			微信小程序-生成保存图文海报-canvas生成图片、二维码、自定义文字样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码仓库：https://gitee.com/DerekAndroid/miniProgramAgen/tree/master/pages/canvasTest
效果：
点击保存图片- //步骤流程： 1.把二维码生成临时图片文件-2.canvas画文字+二维码图片-3.保存新的临时文件-4.保存到相册
canvas图片宽度根据设备进行适配
let unit = systemInfo.screenWidth / 375 以375px基准进行宽度适配：切换iphone6和iphone6plus对面效果
iphone6: iphone6plus: canvas两种方式实现文字居中：
1.measureText测量文字宽度实现文字居中
/********文字居中方式1:measureText测量文字宽度实现文字居中 */ ctx.setFillStyle('#000') var name = 'textAlign文字居中'; ctx.font = '28px serif' var measureText = ctx.measureText(name);//测量文字宽度 console.warn('measureText', measureText) //思路：（父类宽度-文字宽度）/2=文字居中 //在iphone6plus上，measureText.width= 238是实际的宽度，需要先转换成iPhone6的基准尺寸，然后再计算，然后再转换成iphone6plus是尺寸 ctx.fillText(name, (375 - measureText.width / unit) / 2 * unit, 150 * unit) 2.textAlign文字居中
/********文字居中方式2:textAlign文字居中 */ ctx.setFillStyle('#000') var name = 'textAlign文字居中'; ctx.font = '28px serif' ctx.textAlign = "center";//基于中线文字左右两边居中 // ctx.setTextAlign('center'); ctx.fillText(name, 375 / 2 * unit, 210 * unit) //居中开始写文字 ctx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da24d9ab315e61d4ccdab73a7da2778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9217a8fafab1dea75d057d9de18ba5aa/" rel="bookmark">
			微信小程序-同时获取麦克风、相机权限、获取多个权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码仓库：https://gitee.com/DerekAndroid/miniProgramAgen/tree/master/pages/authSetting
效果：
wxml:
&lt;button bindtap="checkScopeCamera"&gt;申请获取相机权限&lt;/button&gt; &lt;button bindtap="checkScopeCamera"&gt;申请获取相机权限-同步函数方式&lt;/button&gt; &lt;button bindtap="checkScope"&gt;同时申请获取麦克风、相机权限&lt;/button&gt; js：
// pages/authSetting/authSetting.js Page({ data: { }, onLoad: function (options) { }, onShow: function () { }, getSettingRecord(options = { scope: 'scope.record', content: '请前往设置页打开麦克风' }) { var self = this; return new Promise((resolve, reject) =&gt; { wx.getSetting({ success: (res) =&gt; { let auth = res.authSetting[options.scope] console.warn('scope.record=', auth, typeof auth) if (auth === true) { // 用户已经同意授权 resolve(true) } else if (auth === undefined) {// 首次发起授权 wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9217a8fafab1dea75d057d9de18ba5aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b45ec5e46578e05708b1e3003799155/" rel="bookmark">
			C语言编译灰色的点击不了,点击提交按钮后按钮变灰色不可用状态的三种方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法：直接按钮中加入
当点击提交后，提交按钮变灰色不可用，这样可有效防止重复提交，本代码就是实现这样一个功能。从代码就可以看出，我们只需在提交按钮上加入这一句： οnclick="javascript:{this.disabled=true;document.form1.submit();}"，意思是当按钮点击后，将按钮的不可用属性设置为true，这样按钮就变灰了
表单提交后按钮变成灰色
[Ctrl+A 全选 注:如需引入外部Js需刷新才能执行]
第二种方法：通过onSubmit事件实现，并且可以将变灰按钮变为可用
在form里面添加 onSubmit事件，如果表单加入了判断，那么这个方法直接就可以用了，记住就放到最后，否则一开始就为灰了，但我们加上了一个使提交按钮变为可用的代码，
即可防止重复提交信息，也可以防止代码问题导致不可提交的情况
function closebut(){
document.form1.imageField.disabled=true;
}
第三种，跟上面的类似
网页特效 表单提交后按钮变灰效果三
脚本之家,站长必备的高质量网页特效和广告代码。
[Ctrl+A 全选 注:如需引入外部Js需刷新才能执行]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17242f35e3e61e6f9c018ec1d579b8af/" rel="bookmark">
			AcWing 352 闇の連鎖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
传说中的暗之连锁被人们称为 Dark。
Dark 是人类内心的黑暗的产物，古今中外的勇者们都试图打倒它。
经过研究，你发现 Dark 呈现无向图的结构，图中有 N 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。
Dark 有 N–1 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。
另外，Dark 还有 M 条附加边。
你的任务是把 Dark 斩为不连通的两部分。
一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。
一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。
但是你的能力只能再切断 Dark 的一条附加边。
现在你想要知道，一共有多少种方案可以击败 Dark。
注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。
输入格式
第一行包含两个整数 N 和 M。
之后 N–1 行，每行包括两个整数 A 和 B，表示 A 和 B 之间有一条主要边。
之后 M 行以同样的格式给出附加边。
输出格式
输出一个整数表示答案。
数据范围
N≤100000,M≤200000，数据保证答案不超过2^31−1
输入样例：
4 1 1 2 2 3 1 4 3 4 输出样例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17242f35e3e61e6f9c018ec1d579b8af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17e0b988da99a067bce9fc5d8524145/" rel="bookmark">
			C语言程序设计答案黄保和编,C语言程序设计答案(黄保和编)第5章.pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		厦门大学本科生公共课 《C 程序设计基础》 教材习题答案 第五章 循环结构程序设计
一、选择题
1.设有程序段”int k=10;while(k=0)k=k-1;”，则下面叙述正确的是D 循环体语句一次也不执行
2.设有程序段”int x=0,s=0;while(!x!=0)s+=++x;printf(“%d”,s);”则A 运行程序段后输出1
3.若有语句”int x=3;do{printf(“%d\n”,x-=2);}while(!(--x));” ，则该程序段C 输出的是 1 和-2
4.下面循环语句中，错误的是D int a=1,b=2;do b--while(b= =0);
5. 已知”int i=5;” ，下列do…while 循环语句的循环次数为C 5
do{printf(“%d\n”,i--);}while(i!=0);
6.循环语句”for(int i=0,j=10;i=j=10;i++,j--)” 的循环次数是D 无限
7.循环语句”while(int i=0;)i--;”的循环次数是A 0
8.下述有关break 语句的描述中，不正确的是 C break 语句用于if 语句的内嵌语句内，它结
束该if 语句
9.下面关于循环语句的描述中，错误的是B 循环体内必须同时出现break 语句和continue 语
句
10.以下不是死循环的是D for(;(c=getchar()!=’\n’);)printf(“%c”,c);
11.执行语句”for(i=0;i++&lt;3;);”后，变量i 的值为C 4
12.语句”for(x=0,y=0;y!=1&amp;&amp;x&lt;4;x++);”是C 循环4 次
13.与语句”while(!x);”等价的语句是A while(x= =0);
14.执行下列程序段后a 的值为B 2
int a=1,b=10;
do{
b-=a;a++;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d17e0b988da99a067bce9fc5d8524145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb01bd26f571028d2177f764a0f1ee5f/" rel="bookmark">
			c语言open参数,ifstream :: open()的C类型参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我必须使用哪种类型的文件名作为ifstream.open()的参数？
int main(int argc, char *argv[]) {
string x,y,file;
string file = argv[1];
ifstream in;
in.open(file);
in &gt;&gt; x;
in &gt;&gt; y;
...
使用此代码,我收到以下错误：
main.cpp|20|error: no matching function for call to 'std::basic_ifstream
std::char_traits &gt;::open(std::string&amp;)'|
gcc\mingw32\4.4.1\include\c++\fstream|525|note: candidates are: void std::basic_ifstream&lt;_chart&gt;
_Traits&gt;::open(const char*, std::_Ios_Openmode) [with _CharT = char, _Traits = std::char_traits]|
更新：
我收到这个错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43576780f24a269ec4aadd0e00973927/" rel="bookmark">
			c语言中while(!x!=0),C语言,while(!x!=0)s&#43;=&#43;&#43;x；如何运行的,谢大神 , C语言中while(!x==0)什么意思...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航：网站首页 &gt;
C语言,while(!x!=0)s+=++x；如何运行的,谢大神 , C语言中while(!x==0)什么意思
C语言,while(!x!=0)s+=++x；如何运行的,谢大神 , C语言中while(!x==0)什么意思
匿名网友:
c语言“while(!x)”中的“！x”的意思是：变量x强制转化为布尔类型变量再取非。
“！”是C语言中的非运算符，在变量前面使用它，会构建非运算表达式，表达式的返回结果是个布尔值也就是只有true或false。
对变量使用时，如果变量不是布尔数据类型，将会强制转化为布尔类型再使用，如整形变量123将被转化为true，整形变量0将被转化为false。
扩展资料：C语言所有运算符列表：1、算术运算符用于各类数值运算，包括加+、减-、乘*、除/、求余或称模运算，%、自增++、自减--共七种。
2、关系运算符用于比较运算，包括大于&gt;、小于=。
、小于等于3、逻辑运算符用于逻辑运算，包括与&amp;&amp;、或||、非！三种。
4、位操作运算符参与运算的量，按二进制位进行运算。
包括位与&amp;、位或|、位非~、位异或^、左移&gt;六种。
5、赋值运算符用于赋值运算，分为简单赋值=、复合算术赋值+=，-=，*=，/=，%=和复合位运算赋值&amp;=，|=，^=，&gt;&gt;=，6、条件运算符这是一个三目运算符，用于条件求值？：。
7、逗号运算符用于把若干表达式组合成一个表达式，。
8、指针运算符用于取内容*和取地址&amp;二种运算。
9、求字节数运算符用于计算数据类型所占的字节数sizeof。
10、特殊运算符有括号，下标，成员→，.等几种。
参考资料来源：百度百科-c语言运算符号
匿名网友:
逗号表达式的值由最后一项决定。
while (x--,x) 当X初始值为1时，上面那条语句等价于while (1, 0)= while (0) ，所以并未执行循环之内的语句。
【注意，若是while (--x,x) 的话就等价与 while (0,0)了，注意两者的区别】 while (x,x--) 当X初始值为1时，上面那条语句等价于while (1,1)= while (1) ，所以执行了循环之内的语句。
而a=x--,x； 这条语句，等价于 a=1,0； 但由于逗号的优先级最低，所以上面等价于 a=x--,x； 整条语句的值是0，但是a却被赋值了1.
匿名网友:
首先了解下优先级与结合性1.--为自减运算符，第二优先级，自右至左2.x--这个表达式：先使用x的值，接着x=x-1;整个表达式的值为x看while(x--){循环体}首先①判断x--这个表达式的值是否为0即x的值，如果为0，不执行循环体但仍然执行x=x-1;例如：int x=0； 则不执行循环体，x最终值为-1②如果x的初值不为0，判断x--这个表达式的值是否为0，不论是否为0x=x-1,如果x--表达式的值不为0，在执行循环体.真绕...看例子例如：int x=3;while(x--){printf(＂while\n＂);}printf(＂%d\n＂,x);①3--&gt;不为0--&gt;x=x-1--&gt;x=2 执行循环体 while②2--&gt;不为0--&gt;x=x-1--&gt;x=1同上③1--&gt;不为0--&gt;x=x-1--&gt;x=0同上④注意 此时x=0，将不再执行循环体，但x=x-1;--&gt;x=-1建议你逐步调试，很清晰
问题推荐
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd920149b63385f222e8b89f88c01ea/" rel="bookmark">
			c语言字符游动程序,C语言实现扫雷小游戏详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实例为大家分享了C语言实现扫雷小游戏的具体代码，供大家参考，具体内容如下
一.实现功能
首先显示一个小菜单，选择是否玩游戏。当用户选择退出时，程序运行结束，当用户选择玩游戏时，将提示用户输入扫雷位置坐标。当用户输入坐标超出棋盘范围或者位置之前已经进行扫雷时，将提示用户重新输入。当用户输入正确坐标时，如果输入位置没雷将会显示当前位置周边有几个雷，直到将所有雷找出后，重新显示菜单。当输入位置有雷时，游戏结束，重新显示菜单。
二.分析与介绍
首先编写程序开始前，我们要清楚知道棋盘时二维的，所以这里会要用到二维数组来保存棋盘状态。由于这里我们要一张显示给用户看的棋盘，一张电脑随机埋雷的棋盘，所以我们要定义两个二维数组。然后我们只需要根据功能一步步进行程序的编写，如下。
三.代码编写
首先确定主函数main()的编写确定主要逻辑，首先显示菜单供用户选择是否玩游戏，后面对用户的选择进行判断是否玩游戏。代码块如下：
int main(){
int quit = 0; //退出变量
while (!quit){
Menu();//菜单函数
int select = 0;
scanf("%d", &amp;select);
switch (select){ //通过switch语句来判断用户是否玩游戏
case 1:
Game(); //游戏函数
break;
case 2:
quit = 1;
printf("Byebye\n");
break;
default:
printf("选择错误，请重新输入\n");
break;
}
}
return 0;
}
菜单函数Menu()代码：
void Menu(){
printf("#####################\n");
printf("##1.Play 2.Exit##\n");
printf("#####################\n");
printf("Please input you select:");
}
当用户选择玩游戏时，Game()函数是主要游戏逻辑的编写，首先对棋盘进行初始化，再电脑随机埋雷，展示棋盘让用户输入扫雷的坐标值。此时要进行判断输入坐标值是否超过棋盘范围，是否已经扫过雷，如果用户输入坐标有雷直接游戏结束。如果没雷，计算出周边雷的个数后显示出来，再进行上面的操作，直到扫完雷为止。
void Game(){
srand((unsigned long)time(NULL));
char show_board[LIN][COL];
char mine_board[LIN][COL];
//memset(show_board, '*', sizeof(show_board));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cd920149b63385f222e8b89f88c01ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57a987eabc002910eca9dde2f739a4c/" rel="bookmark">
			3步开发Oculus 2第一个应用！（unity贼简单，不信你试试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		独乐乐不如众乐乐，好的内容只有经过传播才具有价值。如果VR平台能够将UGC（User Generated Content，也就是用户生成内容）发挥到极致，每一个玩家都是一个“VR开发者”，那么整个过程所创造出的价值将无法估量。今天来给大家科普一下如何快速上手Oculus 2 开发？简单3步就搞定。
目录：
一、Unity下载安装
二、Oculus插件配置
三、Oculus设备调试
一、unity下载安装
1.下载unity，选择“长期支持版本”，选择一个2020年版本，点击“从Hub下载”
网址：https://unity.cn/releases/lts/2020
说明：
①不要自己去微信公众号找破解版本的unity（安卓开发插件不全，后期下载很麻烦，折磨了我30多个小时……）
②现在支持Oculus最新插件开发的unity版本普遍在2019.5以上，这里选择长期支持版本LTS更加稳定一些（不用频繁更新）
③从Hub下载（类似下载一个游戏盒子），先在2020年版本的Hub创建项目会很方便。如果你单独下载unity，后期还是不得不选择Hub，所以我们就一步到位。
2.安装Unity Hub，“设置”，“许可证管理”，“激活许可证”，“个人版本”
说明：
①unity hub不要安装在C盘，费内存
②必须先激活许可证，不然后面连项目都创建不了（一直转圈圈）
③激活完毕后，点“常规”，“偏好选项”，可以自定义unity引擎安装路径（不要C盘）
3.“安装”，选择unity版本，添加模块（最重要的部分！） ，等待unity下载
说明：
①unity版本尽量选它推荐的版本（通常是在第一个）
②添加的模块有三个：Android Build Support、Windows Build Support（如果是苹果系统和Linux系统请自行替换就好）、简体中文（unity自带的安装一步就到位，如果另行下载会相当麻烦）
③开发工具Dev tools建议自行安装visual studio（这下子可以从微信公众号下载破解版的了~）
④一切安装完毕的结果：unity图标下面有安卓机器人和Windows系统标志（表示支持安卓和Windows系统开发）
二、Oculus插件配置
1.下载插件oculus-adb-driver-2.0并安装（苹果系统不用）
网址：https://developer.oculus.com/downloads/package/oculus-adb-drivers/
2.下载插件Oculus Integration
网址：https://developer.oculus.com/downloads/package/oculus-adb-drivers/
说明：下载前需要注册一个unity账号，登录完毕后，点击：“添加至我的资源”，然后可以选择“在unity中打开”。这个Oculus整合包里面包含Oculus手柄，相机，手势交互等等场景，非常实用。
3.打开Unity，上面菜单栏“Window”，“Package Manager”，选择左上角“Packages：My Asset”，点击“Oculus Integration”，再点击导入“import”
说明：如果没有显示Oculus Integration的话，可以先进入unity asset商店，搜索之后，点击“在unity中打开”
4.左上角的“Packages：My Asset”切换到“packages：Unity Registry”，找到Oculus XR Plugin，点击install安装。之后再下拉，找到XR Plugin Management，选择一个版本安装。
说明：可能对于XR Plugin Management不同版本安装会报错，如果出错的话，请移除remove版本之后切换另外的版本安装
5.点最上角菜单File，“building setting”，点安卓平台（带有机器人那个），点“switch platform”
切换好之后如下图：
6.点最上角菜单Edit，“project settings”，点“XR Plug-in Management”，点右边安卓机器人，勾选下面的Oculus
7.点左下角Oculus，点右边安卓机器人，勾选对应的要求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e57a987eabc002910eca9dde2f739a4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea00ff5cb0f840ce4fd28654d611a0e/" rel="bookmark">
			五子棋c语言程序人人对战,C语言 AI智能，五子棋 人机对战，人人对战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言五子棋，人机对战，人人对战
chunli@Linux:~$ cat main.c
# include
# include
# include
# define SPA 0
# define MAN 1
# define COM 2 /* 空位置设为0 ，玩家下的位置设为1 ，电脑下的位置设为2 */
int qipan[15][15]; /* 15*15的棋盘 */
int a,b,c,d,x; /* a b为玩家下子坐标 ，c d为电脑下子坐标 x为剩余空位置*/
void start(); /* 程序的主要控制函数 */
void draw(); /* 画棋盘 */
int win(int p,int q); /* 判断胜利 p q为判断点坐标 */
void AI(int *p,int *q); /* 电脑下子 p q返回下子坐标 */
int value(int p,int q); /* 计算空点p q的价值 */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea00ff5cb0f840ce4fd28654d611a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84084e07de793c9aa68c0c7bc535828/" rel="bookmark">
			full join 与 union
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		full join 与 union 描述一、表简介二、转换步骤2.1 完整sql2.2 转换中的问题2.2.1 nvl2.2.2 full join ods_table_c_rnk 表 三、UNION效验总结 描述 有三张表需要对每个表进行去除重复后关联进行列的补充，并且保留未匹配上的所有数据。由于有列的补充并保留所有数据，所以选择了full join进行操作处理，最终使用union进行数据量的验证
提示：以下是本篇文章正文内容，下面案例可供参考
一、表简介 ods_table_a(主键 product_id , dt) 、ods_table_b(主键 product_id , dt) 、ods_table_c(主键 product_id , dt)
二、转换步骤 2.1 完整sql 代码如下（示例）：
tmp_ods_table_a as ( select *, row_number() over(PARTITION BY product_id,dt order by dt desc) rnk from ods_table_a where product_id is not null and product_id !=''), ods_table_a_rnk as ( select * from tmp_ods_table_a where rnk = 1), tmp_ods_table_b as ( select *, row_number() over(PARTITION BY product_id,dt order by dt asc) rnk from ods_table_b where product_id is not null and product_id !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a84084e07de793c9aa68c0c7bc535828/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/204/">«</a>
	<span class="pagination__item pagination__item--current">205/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/206/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>