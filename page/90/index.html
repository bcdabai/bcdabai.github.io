<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afaf801e3e31d06b61a1636000f51563/" rel="bookmark">
			windows查看端口和进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、 查看所有端口的占用情况
netstat -ano 2、 查看指定端口占用情况
netstat -ano | findstr “端口号” 3、 查看该端口的PID，注意端口号要加上双引号。
netstat -ano | findstr “PID” 4、 使用tasklist查看PID对应的进程名
tasklist | findstr “PID” 5、 结束进程
taskkill /pid PID -t -f # 强制 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc0169947aec08f8be9a0e32b89120b/" rel="bookmark">
			聚焦芯片：GPU,CPU,SOC,DSP,FPGA,ASIC,MCU,MPU,GPP,ECU等都是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上部分概念：
CPU：中央处理器（Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。中央处理器主要包括运算器（算术逻辑运算单元，ALU，Arithmetic Logic Unit）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。它与内部存储器（Memory）和输入/输出（I/O）设备合称为电子计算机三大核心部件。
GPU：图形处理器（Graphics Processing Unit），又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上图像运算工作的微处理器。用途是将计算机系统所需要的显示信息进行转换驱动，并向显示器提供行扫描信号，控制显示器的正确显示，是连接显示器和个人电脑主板的重要元件，也是“人机对话”的重要设备之一。显卡作为电脑主机里的一个重要组成部分，承担输出显示图形的任务，对于从事专业图形设计的人来说，显卡非常重要。
NPU：嵌入式神经网络处理器，采用“数据驱动并行计算”的架构，特别擅长处理视频、图像类的海量多媒体数据。嵌入式NPU的小型化、低功耗和低成本优势，加快人工智能技术落地应用。例如无人机对摄像头的重量和功耗有很高的要求，否则会影响起飞和续航能力。而“星光智能一号”只有普通邮票大小，重量仅几十克，它的诞生让诸多监控摄像头等小型设备有了人工智能化的可能，迈出了人工智能从神秘的机房，跨向生活应用的一步。
TPU：TPU（Tensor Processing Unit），是谷歌打造的处理器，是专为机器学习量身定做的，执行每个操作所需的晶体管数量更少，自然效率更高。因为它能加速其第二代人工智能系统TensorFlow的运行，而且效率也大大超过GPU——Google的深层神经网络就是由TensorFlow引擎驱动的。
MPU：MPU有两种意思，微处理器和内存保护单元。MPU是单一的一颗芯片，而芯片组则由一组芯片所构成，早期甚至多达7、8颗，但目前大多合并成2颗，一般称作北桥（North Bridge）芯片和南桥（South Bridge)芯片。MPU是计算机的计算、判断或控制中心，有人称它为”计算机的心脏”。
MCU：微控制单元(Microcontroller Unit) ，又称单片微型计算机(Single Chip Microcomputer )或者单片机，是把中央处理器(Central Process Unit)的频率与规格做适当缩减，并将内存(memory)、计数器(Timer)、USB、A/D转换、UART、PLC、DMA等周边接口，甚至LCD驱动电路都整合在单一芯片上，形成芯片级的计算机，为不同的应用场合做不同组合控制。诸如手机、PC外围、遥控器，至汽车电子、工业上的步进马达、机器手臂的控制等，都可见到MCU的身影。
SOC：SOC的定义多种多样，由于其内涵丰富、应用范围广，很难给出准确定义。一般说来， SOC称为系统级芯片，也有称片上系统，意指它是一个产品，是一个有专用目标的集成电路，其中包含完整系统并有嵌入软件的全部内容。同时它又是一种技术，用以实现从确定系统功能开始，到软/硬件划分，并完成设计的整个过程。
DSP：DSP（digital signal processor）是一种独特的微处理器，是以数字信号来处理大量信息的器件。其工作原理是接收模拟信号，转换为0或1的数字信号，再对数字信号进行修改、删除、强化，并在其他系统芯片中把数字数据解译回模拟数据或实际环境格式。它不仅具有可编程性，而且其实时运行速度可达每秒数以千万条复杂指令程序，远远超过通用微处理器，是数字化电子世界中日益重要的电脑芯片。它的强大数据处理能力和高运行速度，是最值得称道的两大特色。
讨论自动驾驶芯片的意义并非单纯理解芯片原理，更需要理解计算并非是一个软件工作而是一个软硬件配合的工作。很多算法在不同的芯片上都可以实施，但是量产过程中需要在灵活性以及成本功耗之间做出权衡。而如果要做到这点，你必须理解芯片。
一、什么是ECU? ECU 代表电子控制单元，它是一种嵌入式系统，用于控制汽车中的一个电气系统。单车可以有多个ECU，包括发动机控制模块、变速箱控制模块、动力总成控制模块、制动控制模块、防抱死制动系统、车身控制模块、悬架控制模块、电池管理系统和与车辆中的特定子系统相关的其他ECU等。
二、ECU的软硬件架构 如下图所示，这些ECU中的每一个ECU由以下组件组成：
微控制器 - 微控制器构成 ECU 的基础。微控制器接收所有输入，并使用提供的软件例程进行逻辑处理以提供所需的输出。这些微控制器读取或写入 SRAM、FLASH RAM 或 EEPROM 存储器。存储器用于存储不同的软件组件，无论是引导加载程序还是实际固件以及处理不同任务所需的其他软件参数。
输入 - 我们可以将 ECU 的输入定义为两类 1）电源 - 为 ECU 提供输入电压和电流，以启动并保证软件正常运行 2）模拟量输入和数字量输入 - 这些是 ECU 最关键的组件之一，其输入的值是影响子系统功能的关键因素。
输出 - 根据输入数据进行处理后产生输出，输出可能驱动以下器件，如用于执行器驱动器（继电器、喷射器、阀门），或用于伺服电机的 H 桥驱动器，或逻辑输出。
通信链路 - 传感器和 ECU 的位置可能位于不同的位置，从而需要在这两者之间建立通信链路。有时一辆车可能包含超过 80 个 ECU，而某些 ECU 的输出依赖于其他的 ECU所产生的输入。因此，需要 ECU 内部和ECU 之间的通信。因此，在一个ECU中建立了CAN总线协议、LIN协议、Flexray等不同通信协议的通信链路。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bc0169947aec08f8be9a0e32b89120b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b111539f0a4ec5bed71b49cf129fb6e/" rel="bookmark">
			【VMWare linux ubuntu共享文件夹设置】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开虚拟机VMWare, 选择虚拟机菜单，点击设置；
在设置页面，点击选项标签，选择共享文件，在右侧选择总是启用
在设置页面共享文件夹的右侧，点击添加按钮，安装提示点击一下步，输入或浏览windows上设置的共享文件夹路径和名称
最后点击确定，完成设置，然后在ubuntu里面打开终端，进入/mnt路径后，输入ls命令，就可以看到 hgfs文件夹了：
进入 hgfs文件夹后ls一下，就可以看到windows上共享的文件夹了：
然后cd 进入到windows上的共享文件夹下，就可以看到共享的文件了：
在前面步骤之前，需要在windows的共享文件夹(创建此文件夹，并设置共享，权限设置读写，everyone)里面放入需要共享的文件:
在VMWare ubuntu系统里面，打开终端窗口，进入/mnt/hgfs下可以找到windows上共享的文件夹，可以把相关共享的文件 copy到linux ubuntu指定的目录下了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a67a404c95e4c155a9b3b65c88f201e/" rel="bookmark">
			vue项目前端解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前后端分离项目中，跨域是一定会出现的问题，本文主要介绍跨域问题的解决思路，以及在vue项目中如何使用代理的方式在前端解决跨域问题，同时提供一个后段解决的方案。
1、产生原因 跨域问题产生的原因是浏览器的同源策略。浏览器同源策略是浏览器中的一种安全机制，用于防止一个域下的文档或脚本访问另一个域下的文档或脚本。同源指的是两个URL的协议、主机名和端口号都相同，只有这些都相同的情况下，两个文档之间才满足同源条件。
也就是指，当浏览器地址栏的地址（页面访问地址）和接口访问地址不一样时就会出现跨域问题，浏览器会拦截服务器返回的数据，并报CROS错误。
例如浏览器地址是：localhost:8080/xxx，访问的接口地址是：http://23.43.222.12:8080/xxx，这时候就会出现跨域问题。所以在前后端分离的项目，跨域问题是必然出现的。
注意：
如果主机一样，但是端口不一样也会产生跨域问题，例如浏览器地址栏：localhost:8080/xxx，接口地址：http://localhost:8081/xxx，也是跨域。 2、解决思路 从原因中可以看到，问题产生主要是浏览器的锅，两个服务（后段）之间进行接口调用是不会产生跨域的，因此我们可以使用一个代理，通过代理服务器去调用server，代理服务器返回数据到浏览器，如下图所示
此处的代理，本质就是一个后端服务，通过代理（后端服务）去调用server，拿到数据后在返回给浏览器，同时非常重要的一点，代理服务的访问地址必须和浏览器地址栏中的端口地址一样（localhost:8080），在Vue中提供了这个功能，只需要进行简单的配置即可实现。
3、问题解决 3.1 前端解决 1、找到vue项目中的vue.config.js，在其中的module.exports中添加如下代码，来配置一个代理proxy，作用见注释。
devServer: { proxy: { //配置跨域 "/api": { //url识别符 target: "http://23.43.222.12:8080/", // server地址 changOrigin: true, //允许跨域 pathRewrite: { /* 重写路径，当我们在浏览器中(f12-&gt;network中)看到请求的地址为：http://localhost:8080/api/core/getData/userInfo 时 实际上访问的地址是：http://23.43.222.12:8080/core/getData/userInfo,因为重写了 /api */ "^/api": "", }, }, }, }, 2、在使用axios等进行接口调用时，不是调用http://23.43.222.12:8080/core/getData/userInfo，而是调用http://localhost:8080/api/core/getData/userInfo
3.2 后端解决 前后端分离，java的话一般使用springboot项目，以springboot为例，添加如下配置：
@Configuration public class GlobalCorsConfig { @Bean public CorsFilter corsFilter() { //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //放行哪些原始域 config.addAllowedOrigin("*"); //是否发送Cookie信息 config.setAllowCredentials(true); //放行哪些原始域(请求方式) config.addAllowedMethod("*"); //放行哪些原始域(头部信息) config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a67a404c95e4c155a9b3b65c88f201e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4c308a075a9aceba5cb44a7105b0b4/" rel="bookmark">
			「C/C&#43;&#43;」C/C&#43;&#43;软件跨平台思维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：何曾参静谧的博客
文章专栏：「C/C++」C/C++学习
目录 相关术语一、编写可移植的代码：二、使用跨平台的C++库和框架：三、进行兼容性测试：四、用户界面设计： 相关术语 跨平台思维：是指在软件开发过程中，考虑到不同操作系统和软/硬件平台的特点和要求，使得开发出的软件能够在多个平台上运行，提高软件的适配性和可移植性。
一、编写可移植的代码： 编写可移植的C++代码是实现跨平台的关键。开发人员需要避免使用操作系统和硬件相关的API，这样可以保证代码不依赖于具体的平台。另外，C++也提供了一些跨平台的标准库，例如STL（Standard Template Library），这些标准库是优秀的跨平台代码实现方式。开发人员可以使用这些跨平台库，使代码具有更好的可移植性，能够在不同平台上复用代码。
1、 使用条件编译：
有时候，不同平台上的操作系统和硬件可能有差异，为了能够在不同平台上实现相同的功能，需要使用条件编译指令，根据不同平台上的特性和要求，选择合适的代码进行编译和运行。例如：
#include &lt;iostream&gt; #include &lt;string&gt; #ifdef _WIN32 #include &lt;Windows.h&gt; #endif int main() { int a, b; #ifdef _WIN32 std::string str = "请输入两个整数:"; MessageBoxA(NULL, str.c_str(), "输入框", MB_OK); std::cin &gt;&gt; a &gt;&gt; b; #else std::cout &lt;&lt; "请输入两个整数:"; std::cin &gt;&gt; a &gt;&gt; b; #endif std::cout &lt;&lt; "它们的和是: " &lt;&lt; a + b &lt;&lt; std::endl; return 0; } 2、 封装平台相关代码：
对于必须使用平台相关代码的部分，可以将这些代码封装到平台无关的接口中，并在不同平台上提供不同的实现。例如，针对文件系统的函数，可以将它们封装到FileSystem类中，使用FileSystem类的接口实现文件系统的访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d4c308a075a9aceba5cb44a7105b0b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473fbd5aa3b4f6cfe1343bcf997ff095/" rel="bookmark">
			mysql授予用户远程访问权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 是一个流行的关系型数据库管理系统，用户可以使用 MySQL 在本地或远程服务器上存储和检索数据。在默认情况下，MySQL 数据库仅允许在本地主机上进行访问。如果您需要远程连接到 MySQL 数据库，您需要授予用户远程访问权限，并刷新权限使其生效。下面是授予 MySQL 用户远程访问权限的步骤：
1、首先登录到您的 MySQL 数据库服务器上。您可以使用以下命令：在这里插入代码片
mysql -u root -p 这将提示您输入 MySQL 的 root 用户密码。输入密码后，您将进入 MySQL shell。
2、接下来，创建一个新的 MySQL 用户或使用现有的用户。如果您想创建一个新用户，可以使用以下命令：
CREATE USER 'newuser'@'%' IDENTIFIED BY 'password'; 这将创建一个名为“newuser”的用户，并为其设置密码。
如果您想使用现有的用户，则跳过此步骤。
3、授予用户远程访问权限。您可以使用以下命令：
GRANT ALL PRIVILEGES ON *.* TO 'newuser'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION; 这将授予名为“newuser”的用户对所有数据库的所有表的所有权限。请确保将“newuser”替换为您要授予远程访问权限的用户的名称，并将“password”替换为该用户的密码。
4、刷新权限以使其生效。您可以使用以下命令
FLUSH PRIVILEGES; 这将刷新 MySQL 的权限表，并使新的权限生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/300299c0af0ee1540693b7a742b12dd6/" rel="bookmark">
			js实现汉字转拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置字符编码 const PinYinChar = { "a": "\u554a\u963f\u9515", "ai": "\u57c3\u6328\u54ce\u5509\u54c0\u7691\u764c\u853c\u77ee\u827e\u788d\u7231\u9698\u8bf6\u6371\u55f3\u55cc\u5ad2\u7477\u66a7\u7839\u953f\u972d", "an": "\u978d\u6c28\u5b89\u4ffa\u6309\u6697\u5cb8\u80fa\u6848\u8c19\u57ef\u63de\u72b4\u5eb5\u6849\u94f5\u9e4c\u9878\u9eef", "ang": "\u80ae\u6602\u76ce", "ao": "\u51f9\u6556\u71ac\u7ff1\u8884\u50b2\u5965\u61ca\u6fb3\u5773\u62d7\u55f7\u5662\u5c99\u5ed2\u9068\u5aaa\u9a9c\u8071\u87af\u93ca\u9ccc\u93d6", "ba": "\u82ad\u634c\u6252\u53ed\u5427\u7b06\u516b\u75a4\u5df4\u62d4\u8dcb\u9776\u628a\u8019\u575d\u9738\u7f62\u7238\u8307\u83dd\u8406\u636d\u5c9c\u705e\u6777\u94af\u7c91\u9c85\u9b43", "bai": "\u767d\u67cf\u767e\u6446\u4f70\u8d25\u62dc\u7a17\u859c\u63b0\u97b4", "ban": "\u6591\u73ed\u642c\u6273\u822c\u9881\u677f\u7248\u626e\u62cc\u4f34\u74e3\u534a\u529e\u7eca\u962a\u5742\u8c73\u94a3\u7622\u764d\u8228", "bang": "\u90a6\u5e2e\u6886\u699c\u8180\u7ed1\u68d2\u78c5\u868c\u9551\u508d\u8c24\u84a1\u8783", "bao": "\u82de\u80de\u5305\u8912\u96f9\u4fdd\u5821\u9971\u5b9d\u62b1\u62a5\u66b4\u8c79\u9c8d\u7206\u52f9\u8446\u5b80\u5b62\u7172\u9e28\u8913\u8db5\u9f85", "bo": "\u5265\u8584\u73bb\u83e0\u64ad\u62e8\u94b5\u6ce2\u535a\u52c3\u640f\u94c2\u7b94\u4f2f\u5e1b\u8236\u8116\u818a\u6e24\u6cca\u9a73\u4eb3\u8543\u5575\u997d\u6a97\u64d8\u7934\u94b9\u9e41\u7c38\u8ddb", "bei": "\u676f\u7891\u60b2\u5351\u5317\u8f88\u80cc\u8d1d\u94a1\u500d\u72c8\u5907\u60eb\u7119\u88ab\u5b5b\u9642\u90b6\u57e4\u84d3\u5457\u602b\u6096\u789a\u9e4e\u8919\u943e", "ben": "\u5954\u82ef\u672c\u7b28\u755a\u574c\u951b", "beng": "\u5d29\u7ef7\u752d\u6cf5\u8e66\u8ff8\u552a\u5623\u750f", "bi": "\u903c\u9f3b\u6bd4\u9119\u7b14\u5f7c\u78a7\u84d6\u853d\u6bd5\u6bd9\u6bd6\u5e01\u5e87\u75f9\u95ed\u655d\u5f0a\u5fc5\u8f9f\u58c1\u81c2\u907f\u965b\u5315\u4ef3\u4ffe\u8298\u835c\u8378\u5421\u54d4\u72f4\u5eb3\u610e\u6ed7\u6fde\u5f3c\u59a3\u5a62\u5b16\u74a7\u8d32\u7540\u94cb\u79d5\u88e8\u7b5a\u7b85\u7be6\u822d\u895e\u8df8\u9ac0", "bian": "\u97ad\u8fb9\u7f16\u8d2c\u6241\u4fbf\u53d8\u535e\u8fa8\u8fa9\u8fab\u904d\u533e\u5f01\u82c4\u5fed\u6c74\u7f0f\u7178\u782d\u78a5\u7a39\u7a86\u8759\u7b3e\u9cca", "biao": "\u6807\u5f6a\u8198\u8868\u5a4a\u9aa0\u98d1\u98d9\u98da\u706c\u9556\u9573\u762d\u88f1\u9cd4", "bie": "\u9cd6\u618b\u522b\u762a\u8e69\u9cd8", "bin": "\u5f6c\u658c\u6fd2\u6ee8\u5bbe\u6448\u50a7\u6d5c\u7f24\u73a2\u6ba1\u8191\u9554\u9acc\u9b13", "bing": "\u5175\u51b0\u67c4\u4e19\u79c9\u997c\u70b3\u75c5\u5e76\u7980\u90b4\u6452\u7ee0\u678b\u69df\u71f9", "bu": "\u6355\u535c\u54fa\u8865\u57e0\u4e0d\u5e03\u6b65\u7c3f\u90e8\u6016\u62ca\u535f\u900b\u74ff\u6661\u949a\u91ad", "ca": "\u64e6\u5693\u7924", "cai": "\u731c\u88c1\u6750\u624d\u8d22\u776c\u8e29\u91c7\u5f69\u83dc\u8521", "can": "\u9910\u53c2\u8695\u6b8b\u60ed\u60e8\u707f\u9a96\u74a8\u7cb2\u9eea", "cang": "\u82cd\u8231\u4ed3\u6ca7\u85cf\u4f27", "cao": "\u64cd\u7cd9\u69fd\u66f9\u8349\u8279\u5608\u6f15\u87ac\u825a", "ce": "\u5395\u7b56\u4fa7\u518c\u6d4b\u5202\u5e3b\u607b", "ceng": "\u5c42\u8e6d\u564c", "cha": "\u63d2\u53c9\u832c\u8336\u67e5\u78b4\u643d\u5bdf\u5c94\u5dee\u8be7\u7339\u9987\u6c4a\u59f9\u6748\u6942\u69ce\u6aab\u9497\u9538\u9572\u8869", "chai": "\u62c6\u67f4\u8c7a\u4faa\u8308\u7625\u867f\u9f87", "chan": "\u6400\u63ba\u8749\u998b\u8c17\u7f20\u94f2\u4ea7\u9610\u98a4\u5181\u8c04\u8c36\u8487\u5edb\u5fcf\u6f7a\u6fb6\u5b71\u7fbc\u5a75\u5b17\u9aa3\u89c7\u7985\u9561\u88e3\u87fe\u8e94", "chang": "\u660c\u7316\u573a\u5c1d\u5e38\u957f\u507f\u80a0\u5382\u655e\u7545\u5531\u5021\u4f25\u9b2f\u82cc\u83d6\u5f9c\u6005\u60dd\u960a\u5a3c\u5ae6\u6636\u6c05\u9cb3", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/300299c0af0ee1540693b7a742b12dd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6126a0cef8fbf1d9a8e07653f4f9d4fc/" rel="bookmark">
			Java程序①求1!&#43;2!&#43;…&#43;10!的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 初学Java，小小小小程序，练个手。☀☀☀
/** * 编写应用程序求1！+2！+……+10！ * @author * */ public class Sum { public static void main(String[] args) { int i = 1; int a = 1; int sum = 0; for(i = 1; i &lt;= 10; i++) { a = i * a; sum = sum + a; } System.out.println("1!+2!+…+10! = " + sum); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2aa201c80afb0946a874ef7be053c0d/" rel="bookmark">
			华为云麒麟arm架构docker启动redis报错:＜jemalloc＞: Unsupported system page size
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 ARM 架构的华为云服务器上，运行 Redis 容器时出现 “jemalloc: Unsupported system page size” 错误，这通常是因为服务器的页面大小不受 jemalloc 库支持所导致的。
为了解决这个问题，您可以尝试将 Redis 容器启动命令中添加--memory-swappiness=0参数。该参数将限制内核使用交换空间（swap）的程度，并确保分配给 Redis 的内存使用物理内存而不是交换空间。这可能会减少 jemalloc 库页面大小不受支持的可能性
在 ARM 架构的华为云服务器上运行 Docker 镜像时应该使用 ARM 版本的镜像，例如从 Docker Hub 上拉取 arm64v8/redis:5.0.9 镜像。
sudo docker run -d --name redis -p 6379:6379 --memory-swappiness=0 arm64v8/redis:5.0.9 redis-server --requirepass 123456 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0e019484ab27db90df41d9145bc40d9/" rel="bookmark">
			Centos 8升级至Centos 8 Stream教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 8 Stream是CentOS 8系列的下一个发行版，它更加关注开发者和创新，以支持先进的硬件和应用程序。下面是升级CentOS 8到CentOS 8 Stream的步骤：
1.备份重要数据
在升级之前，确保备份您的重要数据以防止数据丢失或损坏。
2.更新CentOS 8
执行以下命令，以确保CentOS 8系统是最新的：
```
sudo dnf update
```
3.安装CentOS 8 Stream库
执行以下命令以安装CentOS 8 Stream库：
```
sudo dnf install centos-release-stream
```
4.升级至CentOS 8 Stream
执行以下命令以升级至CentOS 8 Stream：
```
sudo dnf swap centos-{linux,stream}-repos
sudo dnf distro-sync
```
在这个过程中，您可能会被提示将一些软件包从CentOS 8 Stream降级为CentOS 8，或者将一些软件包从CentOS 8升级为CentOS 8 Stream。您可以根据需要进行选择。
5.验证版本信息
完成升级后，您可以执行以下命令来验证您的系统是否已经升级到CentOS 8 Stream：
```
cat /etc/redhat-release
```
您应该会看到类似于以下输出：
```
CentOS Linux release 8.5.2111
```
6.重启系统
为了确保升级生效，建议重新启动系统：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0e019484ab27db90df41d9145bc40d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293d9f63f7a457557311cdb29dbf57a0/" rel="bookmark">
			Java面试题总结（附答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪 ，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于Java基础教程系列（进阶篇），本专栏是针对大学生、初级Java工程师精心打造，针对Java生态，逐个击破，不断学习，打通Java技术栈。
🏆订阅后，可以阅读Java基础教程系列（进阶篇）中全部文章，包含Java基础、Java高并发、Spring、MySQL等Java进阶技术栈。
🏆还可以订阅其姐妹篇，Java基础教程系列，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆哪吒多年工作总结：Java学习路线总结，搬砖工逆袭Java架构师。
🏆面试福音：10万字208道Java经典面试题总结(附答案)。
目录
一、JDK 和 JRE 有什么区别？
二、== 和 equals 的区别是什么？
三、final 在 java 中有什么作用？
四、java 中的 Math.round(-1.5) 等于多少？
五、String 属于基础的数据类型吗？
六、String str="i"与 String str=new String(“i”)一样吗？
七、如何将字符串反转？
八、String 类的常用方法都有那些？
九、new String("a") + new String("b") 会创建几个对象？
十、如何将字符串反转？
十一、String 类的常用方法都有那些？
十二、普通类和抽象类有哪些区别？
十三、接口和抽象类有什么区别？
十四、java 中 IO 流分为几种？
十五、BIO、NIO、AIO 有什么区别？
十六、Files的常用方法都有哪些？
十七、什么是反射？
十八、什么是 java 序列化？什么情况下需要序列化？
十九、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？
​二十、throw 和 throws 的区别？
二十一、final、finally、finalize 有什么区别？
二十二、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/293d9f63f7a457557311cdb29dbf57a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d9b5b48ffdb710611c09442a948bfc/" rel="bookmark">
			torch.cuda.OutOfMemoryError: CUDA out of memory.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		训练清华ChatGLM-6B时报错, 原因是显存不够
torch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 96.00 MiB (GPU 0; 23.70 GiB total capacity; 4.37 GiB already allocated; 64.81 MiB free; 4.37 GiB reserved in total by PyTorch) If reserved memory is &gt;&gt; allocated memory try setting max_split_size_mb to avoid fragmentation. See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF
尝试将
model = AutoModel.from_pretrained("THUDM/chatglm-6b", trust_remote_code=True).half().cuda() 改为
model = AutoModel.from_pretrained("THUDM/chatglm-6b", trust_remote_code=True).half().quantize(4).cuda() 仍然报错
RuntimeError: CUBLAS error: CUBLAS_STATUS_NOT_INITIALIZED
排错流程如下
查看服务器显存占用情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5d9b5b48ffdb710611c09442a948bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e4f38ea8f97f33905eccb5dafaa99e1/" rel="bookmark">
			【机器学习】最经典案例：手写数字识别（完整流程：DNN/CNN结构设计、模型参数保存、断点续训、acc/loss可视化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：python3.7+TensorFlow
完整代码、模型及参数、详细文档见：手写数字识别完整代码+详细文档+模型参数
文章目录 1 概述1.1 任务1.2 数据集1.3 解决方案 2 解决方案2.1 加载、查看训练集/测试集2.2 CNN网络结构设计2.3 设置优化器、损失函数2.4 存取模型，断点续训2.5 参数提取、保存2.6 acc/loss可视化 3 总结 1 概述 1.1 任务 手写数字识别任务的目的是完成手写数字到数字字符的转化，可以通过神经网络模型对手写数字图像进行特征提取和模式识别。
1.2 数据集 MNIST 是一个经典的手写数字数据集，是手写数字识别任务中最常用的数据集之一。数据集规模：包含 60000 个训练图像和 10000 个测试图像，每个图像都是 28x28 像素大小的灰度图像，即通道数为1。其重要性在于它可以帮助机器学习算法学习手写数字的特征，并进行手写数字识别。
1.3 解决方案 使用TensorFlow框架，其提供了 MNIST 数据集的 API，利用tf.keras搭建卷积神经网络架构，进行模型训练、保存、训练结果可视化，实现对手写数字图像进行特征提取和模式识别。
2 解决方案 import tensorflow as tf from matplotlib import pyplot as plt import numpy as np import os 2.1 加载、查看训练集/测试集 tf.keras提供了MNIST数据集的API，可直接加载：
mnist = tf.keras.datasets.mnist (x_train, y_train), (x_test, y_test) = mnist.load_data() 可视化训练集x_train的第一个元素，图片为灰度图，图像尺寸为28x28x1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e4f38ea8f97f33905eccb5dafaa99e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08eeec72dd9f39a1a1eb1f2a0ffcbe2/" rel="bookmark">
			无需构建步骤，渐进式增强静态的 HTML方式使用Vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Vue框架开发时，常常需要基于nodejs开发。Vue库通过包依赖，以模块形式安装在项目的node_modules目录下。在项目开发时，通过import语句导入模块相关的函数。
有没有类似于JQuery等js库的使用方式？
下面给出一个简单例子，并给出注意事项。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;link rel="icon" href="/favicon.ico"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Vite App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script type="module" src="/src/main.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 网页中通过&lt;script &gt;标签引入main.js模块，注意要指定type属性为module，让脚本以模块形式导入。
import {createApp} from "./vue.esm-browser" import * as jquery from './jquery.min' createApp({ data() { return { message: 'Hello Vue!' } } }).mount('#app') $(document).ready(function(){ $("button").click(function(){ $("p").hide(); }); }); 导入的main.js脚本，代码中要注意，导入createApp函数时，要加大括号，且vue的版本必须是 ES 模块构建版本（vue-esm-browser）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b3a53306e61529369300269b6c31de/" rel="bookmark">
			如何让服务器端的Nginx支持http2.0协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Background 如果Web服务器和客户端都支持HTTP/2.0协议，当在Web浏览器中访问站点时，浏览器将尝试使用HTTP/2.0协议。如果服务器支持HTTP/2.0协议，浏览器将自动升级到HTTP/2.0协议，而无需任何额外配置或操作。
HTTP/2.0协议的主要特点之一是它可以自动升级为HTTP/2.0协议。如果客户端请求使用HTTP/1.1协议，服务器可以在响应中指定HTTP/2.0协议，并自动升级协议。这种自动升级确保了向后兼容性，并且可以显著提高Web应用程序的性能。
需要注意的是，如果Web服务器和客户端不支持HTTP/2.0协议，则仍将使用较旧的HTTP/1.1协议。如果想在Web服务器上启用HTTP/2.0协议，需要确保HTTP服务器软件已更新到支持HTTP/2.0的版本，并进行必要的配置。
Premise LinuxNginx Process 确保您的Nginx版本是1.9.5或更高版本，因为这些版本已经支持HTTP/2.0协议。
在Nginx的配置文件中添加以下配置，以启用HTTP/2.0协议。使用 http2 参数来指定使用HTTP/2.0协议。注意，这里的端口号是80而不是443，因为我们不使用SSL/TLS加密：
server { listen 80 http2; server_name example.com; # 其他配置 ... } 又或者，在Nginx配置文件中，启用HTTP2.0支持。这可以通过在server配置中添加以下内容来实现:
http2_enable=on http2_buffering_size=4k http2_max_concurrent_streams=100 http2_stream_max_id=2 这些参数将启用HTTP2.0的各种特性，包括支持更多的并发流和更高的数据传输速率
配置SSL：确保SSL/TLS证书已安装并配置正确。因为HTTP/2.0协议只能在启用SSL/TLS的情况下使用，所以您需要为站点配置SSL/TLS证书。 server { listen 443 ssl http2; server_name example.com; # SSL/TLS 配置 ssl_certificate /path/to/ssl/cert.crt; ssl_certificate_key /path/to/ssl/key.key; # 其他配置 ... } 在以上配置中，我们使用 http2 参数来指定使用HTTP/2.0协议。也可以使用 spdy 参数指定使用SPDY协议，这是一种早期的协议版本，与HTTP/2.0协议相似。
又或者，如果Nginx需要使用SSL（安全套接字层），则需要在配置文件中启用SSL支持。这可以通过在server配置中添加以下内容来实现：
ssl_certificate /path/to/your/certificate.pem ssl_certificate_key /path/to/your/private/key.pem ssl_protocol ssl2 ssl_session_cache shared:SSL:10m; disk:100m; 将/path/to/your/certificate.pem和/path/to/your/private/key.pem替换为您的SSL证书和私钥的路径
启用SSL验证 ssl_verify_client on; ssl_session_timeout 10m; ssl_ciphers HIGH:!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01b3a53306e61529369300269b6c31de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f5c31d46353545b43101eaed6b433b9/" rel="bookmark">
			性能测试连载 (7)-jmeter 压力测试中的难点解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 新人在用jmeter做压力测试的时候，会被一些性能术语搞懵，直接导致的后果就是对测试出来的结果数据根本不能理解，更谈不上分析。这篇文章着重给大家实例解释一下jmeter压力测试的一些专有名词
问题1：什么是压力测试 问到如何做压力测试，很多人可能只会回答：“加线程组，加并发，看结果”。那么什么是压力，压力从哪里体现？这些恐怕就不得而知了。。。
到底什么是压力呢？实际上我们在压力测试中用RPS来表示
RPS RPS 就是每秒请求数（Request Per Second），它描述了施压引擎向服务器实际发出的压力大小。
从用户角度来说，rps是每秒钟点击的次数
从客户端角度来说，rps是每秒向服务端发出的请求数
使用工具的最终目的就是为了利用线程数和迭代次数模拟出和用户每秒点击相匹配的压力值，施压服务端，得到性能数据
Rps 由并发数，和服务器响应时间决定。并发数过低时可能达不到预期的 RPS，并发数过高时可能压力过大直接就压垮了服务器。
问题2：jmeter怎么调节压力 从前面的描述中我们知道压力就是每秒发出的请求数。现在再来理解一个jmeter的名词Ramp-up-period（in seconds）
Ramp-up-period jmeter在线程组中有一个可调节的数值：Ramp-up-period，它表示启动所有线程需要的时间，单位是秒
图1-1设置了100个线程，迭代次数=1，Ramp-up-period=25，那么它表示我将在25秒内启动100个线程，也就是每秒钟启动4个线程。
每个线程启动之间的间隔时间是25/100=0.25s,也就是250ms。
换个理解方式，它表示了我们预期给服务器的压力就是每秒钟发送4个请求。也就是说，设置的RPS=4/s
图1-2设置了100个线程，迭代次数=10，Ramp-up-period=25，那么它表示我将在25秒内启动100个线程，每个线程迭代10次。也就是25秒内启动100个线程并迭代10次。
此时RPS=40/s。观察聚合报告1-3，jmeter在25秒内用100个线程发起了1000次请求。
1-3
jmeter中的RPS是无法通过监听器来直观的监测到，但是在单请求下，RPS和HPS理论上是相等的。可以通过HPS监听器去验证一下。
HPS监听
TPS监听
## 问题3：jmeter中的throughput到底是什么？
各位小伙伴们在使用jmeter时，是不是常常被 throughput 搞晕？到处都是throughput ，到底是做什么用的呢？
我们先看看有哪些throughput 元件
定时器中有目标Constant Throughput 和 Throughput Shaping Timer
逻辑控制器中有吞吐量控制器
聚合报告中也有一个Throughput
撑不住了，好晕啊。。。啊。。。啊。。。。
稳住不要晕倒，下面带大家一个个的来梳理，重建jmeter世界观
先理解一下什么是Throughput
Throughput是用来衡量吞吐量的指标，通常由TPS和QPS来表示。
TPS表示每秒通过的事物数，QPS表示每秒查询接口数。
jmeter中如果只有单接口，那么TPS=QPS。
如果是多接口的混合场景，只有在事物控制器下执行，才能将其理解为TPS。
聚合报告中的 Throughput
下图Throughput表示无限迭代下的业务吞吐量TPS，大约是40/s。意思就是每秒响应完成的请求是40。
Constant Throughput Timer
现在我们在接口下添加一个 Constant Throughput Timer
这是一个吞吐量定时器，它可以控制我们的TPS。
如图，我设定了目标吞吐量是240/min,也就是4/s。
接下来运行的结果可以看到，无论我们预期的吞吐量有多大，实际的TPS都被强力压缩在4/s，同时我们的平均响应时间也变的很短
Throughput Shaping Timer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f5c31d46353545b43101eaed6b433b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52f606415f727c42770e697677bc2731/" rel="bookmark">
			财政收入影响因素分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.数据
2.代码
3.补充
1.数据 百度网盘链接
链接：https://pan.baidu.com/s/10I5FRbqSv0MGJ56SvmSTAg?pwd=1234
提取码：1234
2.代码 #-*- coding: utf-8 -*- # 代码6-1 import numpy as np import pandas as pd inputfile = './data/data.csv' # 输入的数据文件 data = pd.read_csv(inputfile) # 读取数据 # 描述性统计分析 description = [data.min(), data.max(), data.mean(), data.std()] # 依次计算最小值、最大值、均值、标准差 description = pd.DataFrame(description, index = ['Min', 'Max', 'Mean', 'STD']).T # 将结果存入数据框 print('描述性统计结果：\n',np.round(description, 2)) # 保留两位小数 # 代码6-2 # 相关性分析 corr = data.corr(method = 'pearson') # 计算相关系数矩阵 print('相关系数矩阵为：\n',np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52f606415f727c42770e697677bc2731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f3a264c26ef0a6443dee603a03e161d/" rel="bookmark">
			商务智能期中--知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据、信息、知识三者之间的关系（P7）
二、商务智能系统架构图 (P11)
三、商务智能关键技术(P12)
四、商务智能相关应用 (P17)
五、什么是数据仓库？
六、数据仓库和数据库区别？
七、ETL(P43)
八、建模阶段（解释）、方法（P147）
九、实操（Hive）（P73）
十、多维体系结构（P58）+事实表的分类、结构（P63）
十一、维度建模设计的主要流程（解释）（P65）
十二、OLAP基本概念（P87）、分类（P98）
十三、OLAP多维数据分析（P94）
十四、OLAP操作语言（P109）
十五、客户关系管理（P131）
十六、日常经营分析（P132）
一、数据、信息、知识三者之间的关系（P7） 数据、信息、知识这三者是依次递进的关系，代表着人们认知的转化过程。数据指的是未经加工的原始素材，表示的是客观的事物。而通过对大量的数据进行分析，可以从中提取出信息。人们有了大量的信息后，会对信息进行总结归纳，将其体系化，就形成了知识。数据、信息、知识的层次关系如图1-2所示。
数据是宝贵的财富，只有充分有效地利用这种财富，识别信息、获取知识、辅助商务决策，才能从中获取价值。数据、信息、知识和决策之间的关系如图1-3所示 二、商务智能系统架构图 (P11) (1)业务层，指企业的业务系统，如企业资源计划 ( Enterprise ResourcePlanning，ERP)、客户关系管理( Customer Relationship Management，CRM)、供应链管理(Supply Chain Management，SCM)和其他系统，这些系统是商务智能获取数据的来源地。
(2)技术层，负责对来自业务层的原始数据进行抽取、转换、加载等加工，并把处理好的数据放人数据仓库，以及利用数据集成服务将数据进行实时存储。
(3)功能层，将技术层处理好的数据进行分析，以辅助运营和决策支持，并将得到的模型库，知识库以及关键绩效指标提供给组织层。这些分析软件分为以用户为导向的EIS、数据分析、数据挖掘、OLAP等。
各种知识信息等，利用商业绩效(4)组织层，将功能层得到的数据分析结果、管理(Business Performance Management，BPM)、业务活动监控( Business ActivityMomiloring，BAM)、前后台信息部门分工等，确保商务智能的实施
(5)战略层，在以上4层的支撑下，实施战略规划，并利用“平衡记分卡”管理企业绩效，真正实现商务智能全球化、虚拟化、透明化 三、商务智能关键技术(P12) 商务智能利用多项技术相互配合，从大量数据中找寻隐匿在其中的信息，然后将这些信息转化为知识，进而辅助决策者进行商业决策，它是一种决策的辅助手段。此外，商务智能还是一套完整的解决方案，将数据预处理、数据仓库、数据挖掘、在线分析处理以及数据可视化技术结合起来应用到商业活动中。商务智能从大量异构数据源中收集数据，经过抽取、转换和加载的过程，将数据存储到数据仓库中，然后利用数据分析、挖掘工具和在线分析处理工具对信息进行再加工，将信息转变为可辅助决策的知识，最后将知识利用可视化工具以简单易懂的报表等形式展示给用户，以实现技术服务与决策的目的。 四、商务智能相关应用 (P17) 零售、金融、客户关系、电信、教育、电子商务和医疗业等。
五、什么是数据仓库？ 一个面向主题的（Subject Oriented）、集成的（Integrated）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策(Decision Making Support)
六、数据仓库和数据库区别？ 对比内容
数据库
数据仓库
数据内容
当前值
历史的、存档的、归纳的、计算的数据 数据目标
面向业务操作程序，重复处理
面向主题域、管理决策分析应用 数据特性
动态变化、按字段更新
静态、不能直接更新、只定时添加 数据结构
高度结构化、复杂、适合操作计算 简单、适合分析
使用频率
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f3a264c26ef0a6443dee603a03e161d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee805a74883623391892505fd2b64ab/" rel="bookmark">
			无法打开内核设备“\.\VMCIDev\VMX”: 操作成功完成。是否在安装 VMware Workstation 后重新引导? 模块“DevicePowerOn”启动失败。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开虚拟机所在目录
2.找到vmx文件
3.用记事本打开Windows 10 x64 (2).vmx，并找到vmci0.present = "True"，将TRUE改为FALSE
4.重启虚拟机
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d74cc5ee5eb92ffe724950a55dfeb00/" rel="bookmark">
			jenkins使用脚本进行前后端分离项目自动git拉取并部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 需要先安装好jenkins，配置好工作空间，然后本人是将jenkins部署到一个tomcat服务器上。
启动时执行sh脚本，脚本通过java运行war包
nohup /usr/lib/jvm/java-11/bin/java -Xms1024m -Xmx2048m -jar 你的jenkins的war目录/jenkins.war &gt; ./logs/jenkins.log 2&gt;&amp;1 &amp; echo start jenkins 直接执行./自定义sh.sh即可
需要安装插件，这里可能包含了一些不必要的插件，但是一定全，插件列表放在最后
我们的思路是在git中拉取项目到jenkins的工作空间，然后根据脚本将项目部署。
一、后端java项目 java项目使用的是springboot技术，思路是使用springboot自带的tomcat打包成一个可执行的jar包，然后将这个jar包覆盖原来的旧jar包，最后运行脚本重启服务。
前置准备是需要修改pom文件，实现输入maven命令将java项目部署成一个完整的jar包，可以参考这篇文章 请查看第二点和第三点即可
首先登录jenkins，点击左上角的新建item
先输入任务名，选中pipeline，然后点击确定
点击确定后接着输入描述
输入完描述后，先不要保存，此时是重头戏，需要复制部署用的脚本，滚动条拉到最下面，将流水线里复制以下脚本
pipeline { agent any environment { def model = "ipas-server" def DATE = sh(script: 'date +%Y%m%d_%H%M%S', returnStdout:true) def JAR_NAME= "ipas.jar"	// 打出来的jar包名字 def BASEPATH = "/opt/AppData"	def JOB_NAME = "ipas" // jenkins的工作空间，项目从git拉取后会放在此处 def workspace='/opt/jenkins-server/workspace/ipas-new' def project='ipas' } stages { stage('拉取代码') { steps { // 从git仓库中拉取代码 // get branch是git分支， // credentialsId可查看下面的Jenkins 添加配置Git账号密码凭据 // url是git的项目地址 git branch: 'dev-cll2', credentialsId: '你的credentialsId', url: 'http://你的git地址/ipas-new.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d74cc5ee5eb92ffe724950a55dfeb00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccac2fbd4bb8f6833188935074ae1058/" rel="bookmark">
			@RequestParam、@RequestBody、@RequestAttribute、@RequestPart和@PathVariable详解和具体示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. @RequestParam
常规用法
@PathVariable注解
可选参数
2. @RequestBody
常规用法
JSON格式数据
3. @RequestAttribute
4. @RequestPart
常规用法
上传多个文件
总结：
在使用Spring Web框架开发Web应用时，我们通常需要获取请求的参数、请求体、请求属性等信息。为了方便地提取这些信息，Spring Web提供了多个注解，包括@RequestParam、@RequestBody、@RequestAttribute和@RequestPart等。
在本篇博客中，我们将介绍这些注解的用法，并提供具体示例。
1. @RequestParam @RequestParam注解用于获取HTTP请求参数的值。
可以通过name、value、required、defaultValue等属性来指定参数名、是否必须、默认值等信息。如果请求参数名和方法参数名不一致，可以通过设置@RequestParam的value属性来解决。
示例代码如下：
常规用法 @Controller @RequestMapping("/user") public class UserController { @GetMapping("/info") public String userInfo(@RequestParam("user_id") int userId) { //处理业务逻辑 return "user_info"; } } 上述代码中，@RequestParam注解获取了前端页面提交的参数名为user_id的值，并赋值给方法参数userId。
@PathVariable注解 如果请求参数和方法参数名称相同，可以省略value属性。
@GetMapping("/users/{id}") public User getUserById(@PathVariable Long id, @RequestParam String name) { return userService.getUserByIdAndName(id, name); } 在这个示例中，我们使用@PathVariable注解将URL路径参数id映射到方法参数id上，并使用@RequestParam注解将请求参数name映射到方法参数name上。
可选参数 有时候，请求参数可能不是必须的。为了避免抛出异常，我们可以设置required属性为false。
@GetMapping("/users") public List&lt;User&gt; getUsers(@RequestParam(required = false) String name) { if (name == null) { return userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccac2fbd4bb8f6833188935074ae1058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0a1c5e348899be76d9a2eeeb62ae26/" rel="bookmark">
			AXI协议相关概念（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猝发（Burst） 拍（beat）：在时钟采样沿valid和ready信号同时拉高持续一个时钟周期，即为一拍，持续两个时钟周期，即为两拍，依次类推。可以概括为在时钟采样沿握手信号同时拉高的时钟周期数。
猝发长度（burst_length）：表示数据线上valid和ready信号握手次数，burst_length长度为多少，完成一次burst传输地址线就要握手多少次手（有几拍）。
猝发大小（burst_size）：表示数据线上传输数据的宽度，单位通常是word（与cpu位宽有关，多少位的cpu，一个word就是多少位），地址线的valid和ready信号每握一次手就发送一个大小为burst_size的数据。
一次猝发传输的数据量：burst_length（一次猝发有多少拍）* burst_size（一拍传输的数据量）。
猝发的类型（burst_type）：AXI协议中定义了三种猝发类型（一次猝发传输中如何计算地址）。
固定式（Fixed burst）：一次burst传输的地址固定，即每拍都从地址线的address处取数据。递增式（Incrementing burst）：相对于固定式，第一拍从地址线的address处取数据，其后的拍地址自动根据burst_size计算。如32位的CPU上，规定一次burst_length为8beats，burst_size为1个word的传输。第一拍读/写的地址为0x0000，第二拍读/写的地址为0x0004，第三拍读/写的地址为0x0008，最后一拍读/写的地址为0x001C。整个burst传输传输完毕，占据的内存空间为0x0000~0x001F（8*32bit=256bit，即32Byte）。卷绕式（Wrapping burst）：卷绕式猝发的地址与递增式的类似，也是第一拍从地址线的address处取数据，其后的拍地址自动根据burst_size计算。不同的是，当地址到达卷绕的边界后，其后的地址会从最低的地址开始递增，就像将最大的地址和最小的地址重合起来继续计算地址。如同钟表，最小的是0点，最大的是12点，12点和0点重合，当到达12点时也就意味着从0点重新计数，下一个小时是1点。以下讨论卷绕边界：
卷绕式猝发传输，每次进行传输前会根据地址和猝发的配置计算一个卷绕地址上边界和一个卷绕的下边界（地址线address，burst_length，burst_size等），猝发传输的每拍传输的数据会在卷绕地址下界~卷绕地址上界之间进行传输。卷绕的上/下边界地址计算公式如下：
下边界地址：Wrapaddr_low = (int(address/(number_byte*burst_len))) * (number_byte*burst_len)
上边界地址：Wrapaddr_high = Wrapaddr_low + number_byte*burst_len
注：number_byte即为每拍传输的数据字节数，根据burst_size计算。
address为猝发传输的起始地址。
int：为向下取整，即保留商的整数部分。
举例描述：对于Wrap类型的猝发传输， 32位CPU，burst_length为ddword（4Word，128bit），burst_length为4beat，起始地址address为0x00, 0x10, 0x20, 0x30的传输发生的卷绕情况如下：
number_byte=128/8=16Byte，起始地址0x00，0x10，0x20，0x30的卷绕上/下界都为0x00，0x40。
0x00：0x00，0x10，0x20，0x30（不发生卷绕）
0x10：0x10，0x20，0x30，0x00（发生一次地址越界，卷绕一次）
0x20：0x20，0x30，0x00，0x10（发生两次地址越界，卷绕两次）
0x30：0x30，0x00，0x10，0x20（发生三次地址越界，卷绕三次） 参考链接：
1.axi协议
2.https://blog.csdn.net/qq_28284627/article/details/120827729
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c0c76eee1a306db68d792acfaf454e/" rel="bookmark">
			java前端程序员0基础转行该如何写简历？我总结了5种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和小伙伴们分享零基础转行如何写简历。我会从个人信息、专业技能和项目描述三个板块来讲。 首先是个人信息。不要写年龄，因为大学本科毕业的年纪一般在21-22，而研究生在24-25。试想一下站在HR的角度，如果你是零基础转行，年龄大于25又不是硕士学历，简历很容易就过不了初选。
其次，如果不是计算机专业就不要把专业写在简历上。有些公司招聘要求计算机专业，但如果他没有写明硬性要求，你也可以尝试投递。学历也是如此，很多公司没有硬性要求，全日制本科我都会投体简历，因为你不写，有很小的概率会让HR默认你是符合要求的。但是你如果写个机械专业专科文凭，会让你的简历直接就标记为不符合。不要小看这些套路，说不定能帮你多一次面试机会，但这么做的前提是你真的有实力，只缺一个面试机会。如果本身专业水平不行，被HR叫过去面试让面试官很失望，则告HR怎么什么人都叫过来面试，那你很有可能就要被拉入黑名单。
然后是期望薪资这一块，如果面试机会不多就填面译，如果你的薪资有一定要求，面试机会又比较多，可以在薪资待遇写明下限，比如说7万工资8-15 k或者20-30 k，这样给不起价的公司就不会叫你去面试，也不会浪费自己的时间。
最后是照片，我的建议是男生就不要贴了，妹子的话酌情考虑处理。照片之后贴上去，懂的人自然懂。简历的个人信息就介绍完毕了，大致情况如下，大家可以参考一下。
第二个板块就是技能描述。
我把每个技术或者知识点学习深度分为4个等级，意思是手写、深入理解掌握或熟悉、了解。我们在描述技能的时候，尽量挑选你深入理解的技能去写，而不是罗列一大堆。我们先来看一些错误案例：
案例1：只提一些基础名词，把开发工具也罗列上去，甚至第2条和第6条出现重复的描述。
案例2：以打分的形式或者百分比描述技能。我自己的简历也犯过同样的错误，因为你所认为的60分跟面试官级的60分可能完全不在一个维度，甚至一个初学者写了一些3年5年简单开发都不一定全部掌握的技能上去。
案例3：恨不得把所有最流行的前段技术全部写在简历上，但实际上都只是了解，有些甚至文档都没有看过。这样写看经验，一年不到大概率不会叫过来面试。
所以，我这里总结了一套技能的写法模板：3+2+13，指的是从事前端开发工作必备的3个技能，2指跟同一批岗位竞争者你的优势，直白点说就是凭什么我要录用你，而不是录用他。这里我想强调一点，优势一定不是我比任何人都能加班，而且工资要求低，千万不要为了工作这样做。应该是我之所以要这个待遇，是因为我具备其他人不具备的能力。最后括号里面的一是根据不同公司需要的技能改动的，有些公司需要你有电商经验，需要你有后端开发经验，或者你必须会某个框架等等。当然，前面所写的技能如果已经包含了这条，可以不写。
下面是我总结的0基础找前端工作的技能模板写法：
能够使用HTML加CSS还原设计稿，能抹平浏览器兼容问题，熟悉HTML新属性以及语言化，掌握CSC3动画和Flex grade浮动等布局方式。熟悉GS数据类型以及常用API，深入理解原型链b包RIS等特性，掌握promise or sink异步等处理方案，了解浏览器事件循环标准。掌握小程序等框架，能够使用脚手架和社区提供的工具UF，独立搭建项目，能够通过Viu PAC优化项目。这三点就是你从事前端开发工作必备的3个技能，当然括号里面的描述如果你没有掌握就可以不写。控制kit floor分支管理，kit Leax常用命令，熟悉HTTP协议，能与后端同事完成数据交互。有较强的学习能力，掌握常用的设计模式数据结构和算法思想。 最后这两点根据个人掌握情况酌情编写，不要小看数据结构和算法。以我个人经历来看，一些全单知识的深度我未必达标，但通常我能在规定时间内手写面试官提出的算法题，成功获得认可通过本人面试。
最后一个模块是项目描述。这里针对的是零基础转行的同学，我们本身就没有工作经验，所以很难去写好一个项目描述。我常见一些包装出来的简历是这样写的：开发工具VSCO的，Viu ecline get，技术站等等，项目描述一大堆描述，负责开发用户管理模块，负责产品管理，实现产品的自动上架下架改价等等。我以前也这样写，坏处就是平平无奇没有亮点，罗列一堆工具库没有太大的意义，没有区分度。尝试换一种思路去写，比如因为什么样的需求和遇到什么样的困难，我决定使用什么技术或者方案去解决，过程中又出现了什么意外，我怎么一步步攻克，最终上线后的效果如何，事后我总结思考发现还有更好的方案。比如我之前也开发过后台管理系统，我是这样写的：使用vue进行后台页面开发。
对于Java工程师来说，在简历中需要突出自己的技术能力和项目经验。可以按照以下格式来写：
个人信息 姓名：学历：工作年限：电话：邮箱： 技能清单 这里可以列出自己熟练掌握的技术和工具，如Java开发框架、数据库管理等。建议按照熟悉程度从高到低排列。
项目经验 这是Java工程师最关键的部分，需要详细描述自己在项目中的角色和所负责的任务。可以按照以下格式来写：
项目名称 项目描述：开发工具：开发周期：xx年xx月-xx年xx月技术栈：责任描述： 负责XXX模块的开发和维护参与XXX功能的设计和开发解决XXX问题，提高系统性能 教育经历 这里可以列出自己的教育背景，包括学校名称、专业和学历等。
自我评价 这是一部分可以突出自己优点的地方，可以描述自己的性格特点、工作态度、学习能力等。
希望对Java工程师写简历有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1820fa09ef2f2d74bf67e431fcb77b8a/" rel="bookmark">
			深度剖析记忆化搜索（非dp）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言： 相信许多人面对记忆化搜索(Memory search,以下简称MS)会望而却步。因为原本爆搜中的状态就具有隐蔽性，难以调试。而MS中往往存在着更多的递归回溯让人难以理解。本篇内容意在用代码层面深入递归讲解各自的调用和返回问题。
记忆化搜索的概念许多人都已清楚，但它难就难在对"递归"，"回溯"，“记忆"，“返回”这四大关键转化为代码的理解。但这些问题仅仅是了解思想是完全不够的，学习MS一定要落实在代码上，网上有许多MS的题解，但都很少去解释为什么要这么递归和回溯，本篇将用尽可能详细的解释去落实到每一句核心语句上。
第一题：记忆化的典型应用
开始这里就不用传统的斐波那契数列来距离了。而是用洛谷例题:P1028 [NOIP2001 普及组] 数的计算
来讲解。此题递归状态清晰易于分析，易于初学者学习。
题目大意:假设一种合法数列x1,x2,x3...n，其中x1&gt;=x2/2, x2&gt;=x3/2 ... (n-1)&gt;=n/2。问给定n中合法数列有多少个。
看到这题必然会想到用爆搜去做即代码如下：
#include&lt;iostream&gt; using namespace std; int res,n; void dfs(int x) { if(x==1)//当x等于一时递归结束，开始回溯 { return; } for(int i=x/2;i&gt;=1;i--)//将i初始化为x的一半来枚举，符合题意 { res++; dfs(i); } } int main() { scanf("%d",&amp;n); dfs(n); printf("%d",res+1);//由于上述递归没有算到本身如例题中所示，此递归并没有将初始值6算入答案，因此答案需要+1。 return 0; } 结果:必然TLE。因为n范围1-1000，而爆搜通常是n^n，n!等时间复杂度，因此必然会爆。所以开始思考用记忆化搜索，先上代码：
#include&lt;iostream&gt; using namespace std; int book[2000]; int dfs(int x) { int res=0;//疑问1:为什么变量初始化为0 if(x==1) return 1;//疑问2：为什么当递归结束时返回1而不是其他值 if(book[x]) return book[x]; for(int i=1;i&lt;=x/2;i++) { res+=dfs(i);//疑问3：为什么是res+=dfs(i)而不是res=dfs(i) } return book[x]=res+1;//疑问4：前面已经有了那么多return，此处return有何用，并且为什么是book[x]=res+1 } int main() { int n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1820fa09ef2f2d74bf67e431fcb77b8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e30a9e3aa404f9a79a48986eed201f/" rel="bookmark">
			随笔四——IO/进程和线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO 标准IO 标准I/O，也称为stdio，是C语言标准库中提供的一套I/O函数，用于实现与外部设备（如终端、磁盘文件等）的输入和输出操作。标准I/O主要包括文件操作、缓冲区和流控制等方面的功能，是一套通用的、可移植的I/O接口。
标准I/O的优点在于它提供了一些缓冲机制，能够有效地减少对磁盘或其他外设的I/O操作次数，提高了I/O效率。此外，标准I/O还提供了一些方便的I/O控制函数，如文件定位函数、错误处理函数等，使得文件I/O操作更加简单、高效和安全。
标准I/O主要使用FILE结构体来表示文件，它包含了文件的缓冲区、文件指针、文件描述符等信息。标准I/O库中提供了许多函数来处理文件，如fopen()、fclose()、fread()、fwrite()、fseek()、ftell()等，这些函数可以进行打开、关闭、读写、定位等操作。标准I/O还支持流控制函数，如fflush()、feof()、ferror()等，用于控制流的行为。
标准I/O的缓冲机制包括全缓冲、行缓冲和不带缓冲三种模式。全缓冲模式下，输出数据会先存放在内存缓冲区中，当缓冲区满或遇到fflush()、fclose()等函数时才进行实际的写操作；行缓冲模式下，输出数据会先存放在行缓冲区中，直到缓冲区满或遇到换行符才进行实际的写操作；不带缓冲模式下，每次操作都会直接读写磁盘或其他外设，效率最低。
以下是标准IO常用的函数：
fopen()：用于打开一个文件，并返回一个指向FILE类型的指针。fclose()：用于关闭一个已打开的文件。fread()：用于从文件中读取数据。fwrite()：用于向文件中写入数据。fseek()：用于移动文件指针。ftell()：用于返回当前文件指针的位置。fflush()：用于刷新缓冲区，将缓冲区中的数据写入文件中。fprintf()：用于向文件中输出格式化的数据。fscanf()：用于从文件中读取格式化的数据。fgets()：用于从文件中读取一行数据。fputs()：用于向文件中输出一行数据。getchar()：用于从标准输入设备中读取一个字符。putchar()：用于向标准输出设备中输出一个字符。gets()：用于从标准输入设备中读取一行数据。puts()：用于向标准输出设备中输出一行数据。 在使用标准I/O时，需要注意一些问题，如缓冲区的刷新、文件位置指针的控制、文件打开模式的设置等。另外，标准I/O也存在一些缺点，如不支持并发访问、不支持定位到任意位置读写等。
文件IO 文件I/O主要通过文件描述符（File Descriptor）来实现。文件描述符是一个非负整数，用于唯一标识一个打开的文件，系统中每个进程都有一张打开文件的表格，其中每个打开的文件对应一个文件描述符。
Linux系统下的文件I/O主要包括打开文件、读取文件、写入文件、关闭文件等操作，下面分别介绍这些操作：
打开文件
在Linux系统下，可以使用open()函数来打开文件，其基本格式如下： #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; int open(const char *path, int flags, mode_t mode); 其中，path是文件路径名，flags是文件打开模式，mode是文件权限模式。flags可以是以下值的组合：
O_RDONLY：只读模式。
O_WRONLY：只写模式。
O_RDWR：读写模式。
O_CREAT：文件不存在则创建。
O_EXCL：与O_CREAT一起使用，文件存在则失败。
O_TRUNC：文件存在则截断。
O_APPEND：追加模式。
读取文件
打开文件之后，可以使用read()函数来从文件中读取数据，其基本格式如下： #include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count); 其中，fd是文件描述符，buf是读取的数据缓冲区，count是读取的字节数。如果读取成功，则返回实际读取的字节数；如果读取失败，则返回-1。
写入文件
除了读取文件，还可以使用write()函数来向文件中写入数据，其基本格式如下： #include &lt;unistd.h&gt; ssize_t write(int fd, const void *buf, size_t count); 其中，fd是文件描述符，buf是写入的数据缓冲区，count是写入的字节数。如果写入成功，则返回实际写入的字节数；如果写入失败，则返回-1。
关闭文件
在文件使用完成之后，需要使用close()函数来关闭文件，其基本格式如下： #include &lt;unistd.h&gt; int close(int fd); 其中，fd是要关闭的文件描述符。如果关闭成功，则返回0；如果关闭失败，则返回-1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e30a9e3aa404f9a79a48986eed201f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9adec91a2505f5716c0ac1af17aa404/" rel="bookmark">
			【Android】串口通信的理论与使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android系统诞生这十几年以来，Android开发工程师岗位经历了由盛转衰的过程，目前纯UI的Android APP已经鲜有公司愿意花费巨资去开发，Android APP开发的业务也仅剩游戏、物联网（Internet of Things，简称IoT）等方向。在物联网的世界中，串口通信是常见的有线通信方式，本篇文章围绕Android与串口通信，来重新认识一下串口通信。
目录 串口通信简介串口通信分类串行通信根据数据同步方式划分根据数据传输方式划分根据电气标准及协议划分 并行通信图表总结串口通信 串口通信的使用 串口通信简介 串口通信(Serial Communications)，即串口按位(bit)发送和接收字节的通信方式。
串口是显控设备与信号处理板之间通信的主要接口，也是显控设备与其他设备、设备与设备之间的协议数据帧通信传输的重要接口。
串口通信分类 根据通信方式划分，可以将串口通信划分为串行通信与并行通信。
串行通信 串行通信：通信双方按位进行，遵守时序的一种通信方式。
串行通信可以根据数据同步方式、数据传输方式、电气标准及协议再次细分为不同的种类。
根据数据同步方式划分 同步通信
同步通信：一次通信只传送一帧信息，通常含有若干个数据字符。数据格式分别为面向字符和面向bit。异步通信
异步通信：每一个字符要用起始位和停止位作为字符开始和结束的标志，以字符为单位一个个地发送和接收。在进行异步传输数据时，通信双方必须约好：字符格式、通信速率。 根据数据传输方式划分 单工
单工：通信双方中，一方固定为发送端，一方则固定为接收端。信息只能沿一个方向传输，使用一根传输线。
半双工
半双工：在通信过程的任意时刻，信息既可由A传到B，又能由B传A，但只能有一个方向上的传输存在。
全双工
全双工：通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。
根据电气标准及协议划分 串口按电气标准及协议来划分，包括EIA-RS-232C、EIA-422、EIA-485等。
EIA-RS-232C
RS-232C标准（协议）的全称是EIA-RS-232C标准，定义是“数据终端设备(DTE)和数据通讯设备(DCE)之间串行二进制数据交换接口技术标准”。它是在1970年由美国电子工业协会(EIA)联合贝尔系统、调制解调器厂家及计算机终端生产厂家共同制定的用于全双工串行通讯的标准。例如，在PC机上的COM1、COM2接口，就是RS-232C接口。 查看更多详情：EIA-RS-232C
EIA-422
EIA-422(又称为RS-422)是一系列的规定采用4线，全双工，差分传输，多点通信的数据传输协议。它采用平衡传输采用单向/非可逆，有使能端或没有使能端的传输线。和EIA-485不同的是EIA-422不允许出现多个发送端而只能有多个接受端。硬件构成上EIA-422(RS-422) 相当于两组EIA-485(RS-485)，即两个半双工的EIA-485(RS-485)构成一个全双工的RS-422(EIA-422)。 查看更多详情：EIA-422
EIA-485
EIA-485(过去叫做RS-485或者RS485)是隶属于OSI模型物理层的电气特性规定为2线、半双工、平衡传输线多点通信的标准。是由电信行业协会(TIA)及电子工业联盟(EIA)联合发布的标准。实现此标准的数字通信网可以在有电子噪声的环境下进行长距离有效率的通信。在线性多点总线的配置下，可以在一个网络上有多个接收器。因此适用在工业环境中。 查看更多详情：EIA-485
并行通信 并行通信：是指以字节(byte)或字节(byte)的倍数为传输单位，同时通过并行线进行传送，这样数据传送速度大大提高，但并行传送的线路长度受到限制，因为长度增加，干扰就会增加，数据也就容易出错，因此并行通信不适合远距离数据传输。例如：打印机端口、IDE端口等。
图表总结串口通信 串口通信的使用 作为一个Android开发者，与串口相关的很多东西我们都不需要去了解，我们基本都只需要关注如何去连接上这个串口，或许也只有硬件开发工程师，才需要了解到串口通信的原理等相关知识。
使用前先前往Github clone项目AndroidSerialPort到本地，拷贝lib_serialport模块到项目。
接着配置串口的连接所需参数：
串口号：用于串口通信协议的接口。波特率(Baud rate)：一个单位时间内传输符号的个数。如，9600的波特率表示每秒传输9600个字节，每毫秒9.6字节。数据位：计算机发送的信息包，取决于传送的信息长度。校验位：又称奇偶校验位，是校验代码传输正确性的一种校验方式。停止位：提供了校正时钟同步的机会，同时用来表示传输的结束。流控：控制数据传输的进程，实现收发双方的速度匹配，防止数据的丢失。常用的流控制是硬件流控制和软件流控制。硬件流控制常用的有RTS/CTS流控制(数据终端就绪/数据设置就绪)流控制，软件流控制常用的有XON/XOFF。 var mSerialPortHelper = SerialPortHelper() // 配置串口号 mSerialPortHelper.port = ConfigManage.serialPort // 配置波特率 mSerialPortHelper.baudRate = ConfigManage.baudRate.toInt() // 配置数据位 mSerialPortHelper.dataBits = ConfigManage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9adec91a2505f5716c0ac1af17aa404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5599b5508ea4872be35d552ecf9e093a/" rel="bookmark">
			新手做网站教程（手把手教你做网站）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给各位分享新手做网站教程的知识，其中也会对手把手教你做网站进行解释，如果能碰巧解决你现在面临的问题，别忘了关注本站，现在开始吧！
本文目录一览： 1、怎么自己做网站2、做网站的步骤3、新手怎么建自己的网站4、网站怎么制作？5、如何做网站？6、自己如何做网站？ 怎么自己做网站 自己做网站的步骤如下：
1、域名注册。网站建设首先你需要一个属于你自己的网址，也就是域名。
2、网站空间注册。网站空间是用来放网站程序的。网站空间分为ASP、PHP、NET，三种类型。
3、网站备案
国内的网站空间都需要备案，没有备案的网站不允许上线。
4、上传网站程序
网上有很多免费网站程序，论坛（discuz）、博客（Emlog、WordPress、Z-blog）、综合站（PageAdminCMS系统）等，根据自己的网站来选择程序。穗闹
5、添加网站内容。我们可以在备案期间来完成网站内容添加，添加网站内容也是比较简单。进入网站后台新建网站栏目，自己岩缺需要几个栏目就建几个。
6、解析域名和绑定域名。备案号后通过我就可以把域名解析到空间IP上了，域名解析完成后，再在空粗族辩间的管理面板上把解析好的域名绑定。在地址栏输入你的域名。就可以访问到你的网站。
做网站的步骤 私人做网站的流程：域名、空间、网站程序、网站设计、更新、推广等。
网站(Website)开始是指在因特网上漏逗根据一定的规则，使用HTML(标准通用标记语言下的一个应用)等工具制作的用于展示特定内容相关网页的集合。
简单地说，网站是一种沟通工具，人们可以通过网站来发布自己想要公开的资讯，或者利用网站来提供相关的网络服务。人们可以通过网页浏览器来访问网站，获取自己需要的资讯或者享受网络服务。
衡量一个网站的性困哗能通常从网站空间大小、网站位置、网站连接速度(俗称"网速")、网站软件配置、网站提供服务等几方面考虑，最直接的衡量标准是网站的真实流量汪搜行。
新手怎么建自己的网站 现在自己建一个网站也很简单，但就是要找一个自助建站平台。比如在凡科建站的平台上，只要注册账号就算不懂代逗碧谈码、设计也能自己做网站，具体的制作步骤如下：
1、注册一个凡科账号，这个账号可以通用的；
2、在模板库中，选定慧盯一个网站模板并创建，这山碰时就会自动生成一个网站的雏形。
3、在模板的基础上，将前期准备好的文案内容、图片，逐一替换和加入至网站模板中。
4、接着，按照事前的准备，对一些细节比如字体的大小、颜色、图片的大小等进行调整，如果有需要加入动画效果的，则可以直接选定该元素并添加动画效果。
5、最后预览整体效果，点击保存完成创建网站。
重点：在凡科建站的平台上做网站，域名和空间都是增送的呢！~
网站怎么制作？ 简单介绍一下制作主页的过程和方法：一、准备材料新手做网站教程你首先做一个小计划,准备在主页上告诉人家什么？比如介绍三个方面：自我介绍,我的爱好,我的工作,那你就先起一个总目录（文件夹,比如d:\\\\html）,来放你的所有文件新手做网站教程，然后再在这个目录建立三个子目录：myself,interest，job。文件名你可以任意，但最好全部小写，因为有的主机要认大小写。然后将你的材料copy进相应的子目录。比如你要在扮猜培你的主页里展示你的靓照，那就将你的照片扫描成JPG格式的文件，放在myself的目录下.要注意,网上只能使用JPG和GIF两种图象格式，其他诸如BMP和TIF等很通用的格式都不能用在网上,因为它们太大了,但你可以用图象软件进行转换，比如Office
97的照片编辑器。把你准备在你主页上出现的图象放进相应的目录里后,你就可以开始制作了。二、开始制作你无须去记复杂的HTML语言，你可以用Netscape4.0或者WORD7.0,我用的是Frontpage.打开Netscape,在file菜单里选厅唯Edit
Page,便可以制作了.文字的处理基本跟Word没什么两样,关键是插入图片和产生链接.我们先做关于你自我介绍的一页，你先写上“大家好，我是superboy，下面是我的照片：”这时要放图片了，只须点击Insert菜单，选取Image,在Choosefile里选取你的图象文件即可，然后把这个文件保存兆轿为myself.html文件，放在myself的目录下。好，现在必须做封面了，你在封面写：“欢迎来到superboy的主页”以下是“自我介绍，我的爱好，我的工作”。你的自我介绍要链接到下一页去，你只须用鼠标选“自我介绍”后按鼠标右键
，再选create
link，然后再选你myself目录下的myself.html，就将“自我介绍”链接到下一页了，以后在浏览器中一按，就可以跳到镶有你靓照的页面啦。在你的封面做好了所有链接和图片后，记住你必须将这一页保存为index.htm(有的主机要求必须为index.html),因为网页默认的主页名称是index.制作主页其实很简单，只要多实际制作，工多艺熟。还可以拿来主义，在网上看到什么好的主页，用另存为功能保存为.html格式的文件，细细研究人家是如何做的。还可以借用网页模版来搞，我的就是~~~~~~三、将你制作好的安放在网上要在网上安你自己的家，你必须先申请一个主页空间，即向某一个主机申请一快硬盘空间。现在有较多的主机提供免费主页空间，具体见实用链接栏目。这些主机不仅提供免费个人主页空间，并且还提供留言簿、计数器等很有用的功能。只要到有关站点申请即可，具体方法，参考相关题目。申请完成以后用FTP将你所有的主页文件上传至主机指定的目录就可以了新手做网站教程！需要注意的是，一定要保持网页的相对位置，否则会看不到网页的。
如何做网站？ 1、本地制作网站
2、上传到服务器
服务器新手做网站教程你可以去申请一个虚拟主机新手做网站教程，大约1年300元，就可以支持asp了。大小也有300mb吧
再花60－100元申请一个域名（.com，.net不要证件）
付款以后就开通了～～～
这样大概每年400元新手做网站教程的消费就够了，你将拥有自己的网上之家睁启！
如果不知道在哪里申请，给你一个地址，西部数码：west263.net
1先在网络上搜索一些东西来看
比如在稿早闭键裂BAIDU里搜索“如何做网站” 。
就能找一些最基本的教程 。
2然后是工具，现在最流行的网络三剑客，分别是DREAMER WEAVER，FLASH，FIREWORKS，作用对应为做网站，制作FLASH动画，编辑矢量图片 。
其实你只要找第一个软件就可以了，很直观的网站制作软件，想要的效果直接从软件里找，很详细。
3，然后是空间的问题，你需要找网络上的空间来存放你的网站，当然如果你有一台24小时开着的电脑且是包月的宽带，你可以考虑把你的机器当作服务器来使，因为你刚刚开始做，免费空间问题太多，而收费的空间不是贵就是便宜而不可靠，所以拿自己的机器做服务器也未尝不可 。
4，按照你说的，你想建一个WWW网站来“管理”，那么你需要做的不单单是一个HTML的静态网站，而是需要动态语言支持的交互网站，那么到时候以上三个条件你掌握差不多的时候就可以选择一门语言，比如ASP或者PHP都是不错的动态语言。
自己如何做网站？ 第一种，自己手工源码搭建：
1、买域名，必须实名认证，如果国内的服务器必须ICP备案
2、蔽改租服务器，一般的普通展示类网站1G内存1MB宽带，40GB硬盘就够了，如果流量特别大，选择更高的配置，一般CenosLinux系统比较多，win系统的比较少；Nginx和Apache的个人建议Nginx，一般企业类，商城类网站源码php的占大多数，建议php5.4以上，之前的有些老了
3、添加站点设置域名：你的买域名2设置根目录3设置ftp4数据库
4、制作源代码，几乎没有从零开始的，除非你这边有大量牛人。找些免费开源的改动内容，功能不同选择不同的系统一般通用系统：PageAdmin论坛系统：discuz购物系统：ecshop博客系统：wp，需要授权的系统需要注意授权问题，内容修改一般用deamviewer修改比较方便，如果改动很少，那就用notepad++，注：不要用windows的记事本修改，会出错，数据库文件指向一定要设置好。
5、下载xshell，安装，填写服务器ip，密码，链接，上传源码到服务器的根目录
6、设置域名解析，打开买的域名的管理后台，添加记录，填写记录类型选择A型，主机记录写www，解析线路选择默认，记录值输入服务器的ip，好扰TTL默认10分钟
在浏览器打开域名，浏览网站。
第二种，自己手工一键搭建：
第一步：百度搜索菲尔莱斯科技，打开菲尔莱斯科技官网，免费注册您的账号，注：（生成的网站二级域名会是：账号.flspt.com，不想使用二级域名可绑定自己的顶级域名）。
注册成功后进入后台页面，点击管理企业网站
填写网站标题，网站类型，进入电脑站，初次使用的用户，可以选择左上方的急速建站
选择适合自己的行业的模板，不同行业模板后期也可改动适应自己的需求
例如：选择数码、家具、家具百货栏目里的电脑类，点击使用
免费制作网站后，可对标题、栏目、图片进行上传编辑，点击右友并旦上方可以预览生成的网站，点击左上方网站管理进入网站后台管理。
后台可浏览网站数据，如需绑定自己的顶级域名，点击系统设置-网站域名，按教程进行绑定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5599b5508ea4872be35d552ecf9e093a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfbe9b6daaafeb079c0cd5eccbe22fc0/" rel="bookmark">
			SpringBoot注解&#43;AOP实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot注解+AOP实现 Java Annotation注解的详解 ​ Java注解是一种元数据，它可以用于在类、方法或其他代码结构中声明关于程序元素的信息和标记。在Java中，注解以 @ 符号开头，在编译时或运行时由Java虚拟机（JVM）或其他工具进行处理。
注解可以用于许多不同的用途，包括：
编译时检查：注解可以让编译器在编译期间检查程序是否满足一些条件，例如@Deprecated标记弃用的代码，编译器会在编译期间提示有关该代码的警告。运行时处理：注解允许代码在运行时根据指定的元数据来执行特定操作。例如，许多Web框架使用注解对请求处理器和URL进行映射。文档生成：注解可以用于生成文档以描述代码的特定方面，使得文档维护更简单方便。安全性：注解可以用于标记代码中的潜在安全漏洞，帮助开发人员快速找到和修复这些问题。 @Target指定注解针对的地方 在Java开发中，自定义注解是一种非常常见的技术手段，它可以用于定义元数据，对程序的逻辑进行标注、配置和调度等操作。@Target 是一个元注解（即注解的注解），它用来规定自定义注解可以修饰的程序单元（如类、方法、字段等）。@Target 的类型包括以下几种：
ElementType.ANNOTATION_TYPE 表示自定义的注解可以修饰其他注解，例如 @SuppressWarnings。ElementType.CONSTRUCTOR 表示自定义的注解可以修饰构造函数，用于配置依赖注入等操作。ElementType.FIELD 表示自定义的注解可以修饰类的属性（字段），用于配置依赖注入、序列化等操作。ElementType.LOCAL_VARIABLE 表示自定义的注解可以修饰局部变量，通常用于实现某些特定功能或业务逻辑的处理。ElementType.METHOD 表示自定义的注解可以修饰方法，通常用于配置事务、权限校验、缓存管理等操作。ElementType.MODULE 表示自定义的注解可以修饰 Java 9 中的模块（Module）。ElementType.PACKAGE 表示自定义的注解可以修饰 Java 包（Package）内的所有类。ElementType.PARAMETER 表示自定义的注解可以修饰方法的参数，通常用于配置参数校验、日志打印等操作。ElementType.TYPE 表示自定义的注解可以修饰类、接口（Interface）或枚举类型（Enum），通常用于配置声明周期、依赖注入、AOP等操作。 总之，通过合理使用 @Target，我们可以更加精细地控制自定义注解的使用范围，避免滥用或误用。需要注意的是，多个 @Target 可以同时出现在同一个注解上面，使用大括号括起来即可，例如：@Target({ElementType.METHOD, ElementType.FIELD}) 表示该注解可以同时修饰方法和属性。
@Retention指定注解的保留域 在Java开发中，自定义注解是一种非常常见的技术手段，它可以用于定义元数据，对程序的逻辑进行标注、配置和调度等操作。而 @Retention 是一个元注解（即注解的注解），它用来规定自定义注解的生命周期。
在Java语言中，共有三种 @Retention 类型：
RetentionPolicy.SOURCE 表示自定义注解只在源代码中保留，编译器会在编译时丢弃该注解，不会被包含在编译后生成的 class 文件中。这种类型的注解通常用于对开发者进行提示或注释，对实际的程序并没有实质性的影响。RetentionPolicy.CLASS（默认值） 表示自定义注解在编译时保留，但不会被加载到 JVM 中运行。当程序运行时，JVM 不会将该注解加载进来，因此在运行期间无法获取该注解及其信息。这种类型的注解通常用于字节码分析工具等场景。RetentionPolicy.RUNTIME 表示自定义注解在编译时与运行时都会保留，可以通过反射机制获取注解以及注解的属性。这种类型的注解通常用于在运行时进行动态处理，例如 AOP 、代理模式 等场景。 需要注意的是，@Retention 和 @Target 一样，均可以出现在自定义注解声明上，用于指定注解的生命周期及使用范围，例如：
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface MyAnnotation { // ... } 通过合理地控制 @Retention 的属性值，我们可以更好地适应程序的需求，并充分发挥自定义注解的优势和特点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfbe9b6daaafeb079c0cd5eccbe22fc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/745c677cd0c5dda0ed096ce038882c90/" rel="bookmark">
			如何查看自己的cuda环境，以及其对应版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：cmd打开命令窗口，输入conda-env list 查看有几个conda环境
第二步：选择一个环境进入conda，输入conda activate pytorch
第三步：进入python环境，输入python
第四部 ：在Python中，查看torch、cuda和cudnn的版本
1. 查看torch版本
&gt;&gt;&gt; import torch
&gt;&gt;&gt; print(torch.__version__)
1.2.0
2.查看cuda版本
&gt;&gt;&gt; print(torch.version.cuda)
10.0
3.查看cudnn版本
&gt;&gt;&gt; print(torch.backends.cudnn.version())
7401
torch torchvision cuda python对应版本 torch、torchvision、cuda 、python对应版本匹配
pip install torch == 1.3.0 torchvision ==0.4.1 默认相应cuda最高版本10.1
参考：https://pytorch.org/get-started/previous-versions/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f48196c26f0d214c048c00d135474bbb/" rel="bookmark">
			软件测试之测试的分类（重点：黑盒测试、白盒测试、单元测试、集成测试、系统测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 按照测试对象进行划分1）界面测试2）可靠性测试3）容错性测试4）文档测试5）兼容性测试6）易用性测试7）软件安装卸载的测试8）安全测试9）性能测试10）内存泄漏测试 2. 按照是否查看代码划分1）黑盒测试2）白盒测试3）灰盒测试 3. 按照开发阶段划分1）单元测试（结合 V 模型）2）集成测试3）系统测试4）验收测试5）将上面四种测试方法同 V 模型的阶段进行对应 4. 按照测试实施组织划分1）α 测试2）β 测试3）第三方测试 5. 按照是否运行进行划分1）静态测试2）动态测试 6. 按照是否手工划分1）手工测试2）自动化测试 7. 按照地域划分 1. 按照测试对象进行划分 1）界面测试 界面是直接和用户进行交互的，界面设计的好坏决定了用户使用软件的直观感受
界面测试（UI 测试）一般包括以下内容：
对比 UI 设计稿，验证系统显示界面的一致性和正确性验证界面上每个功能的正确性验证界面排版布局是否合理。字体大小、图片排版、清晰程度等验证界面控件的功能是否正常。滚动条、按钮、文本框等对不同分辨率下的界面进行测试 保证页面从大变小（或从小变大）的变化过程是丝滑顺畅、不卡顿的保证页面的字体不模糊、不重影、不消失保证页面中的图片不消失、排版布局合理保证页面的功能正常使用 2）可靠性测试 可靠性 是指系统正常运行的能力或者程度，一般用百分比表示
可靠性 = 正常运行时间 / （正常运行时间 + 非正常运行时间）
影响软件可靠性的因素：
软件本身外界因素，包括电、网络、硬件设备等 3）容错性测试 容错性 是指因为自身或者外部一些异常的操作使得系统发生异常，系统能够自我处理异常或者错误的能力
容错性测试包含以下几个方面：
用户输入异常数据时，系统会不会给出提示，或者系统内部是否做一些处理
在用户做出一些复杂操作或者可能危害数据安全的操作时，会不会给出提示信息
断电、断网或者硬件设备出问题了，是否可以无缝切换到备用服务器
灾难恢复性测试
人为使服务器发生故障，测试软件系统的环境恢复能力、系统数据恢复能力、以及恢复的时间
4）文档测试 对整个开发过程中产生的各种文档，需求文档、设计文档、功能文档、用户使用手册进行测试，验证文档的正确性、一致性和完整性
5）兼容性测试 平台的兼容： 验证系统对不同浏览器、操作系统、不同品牌手机或者电脑的兼容性软件本身的兼容： 验证软件新功能对旧功能的兼容性，新开发的功能不能影响旧功能的使用软件对用户数据的兼容性： 比如数据库中的一张表新增加一个字段，不能影响用户之前数据的存储软件对第三方软件的兼容性： 在与第三方软件有功能或者数据交互时，不能影响第三方软件的使用 6）易用性测试 易用性测试 是指验证用户在使用软件过程中的是否灵活舒适、简单易用
易用性测试一般包括以下几点：
符合标准和规范
对于现在的软件，其 UI 设计的标准已经慢慢被确立，多数用户已经习惯了这种标准和规范。比如，软件发生严重错误时给出提示时图片或者字体的颜色
直观性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f48196c26f0d214c048c00d135474bbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0335070f3c57cb0e2a8ef135500ebe94/" rel="bookmark">
			银河麒麟高级服务器配置zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 安装Java：
Zookeeper需要Java在系统中安装。您可以通过运行以下命令来安装Java：
dnf install java-11-openjdk-devel 2. 下载和安装Zookeeper：
您可以从Apache Zookeeper网站下载最新版本的Zookeeper，使用以下命令：
wget https://downloads.apache.org/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz 下载完成后，解压缩tar文件：
tar -xzf apache-zookeeper-3.7.0-bin.tar.gz 您可以将解压缩后的目录移动到/usr/local/以进行全局安装：
mv apache-zookeeper-3.7.0-bin /usr/local/zookeeper 3. 配置Zookeeper：
使用以下命令将zoo_sample.cfg文件复制到zoo.cfg：
cp /usr/local/zookeeper/conf/zoo_sample.cfg /usr/local/zookeeper/conf/zoo.cfg 编辑zoo.cfg文件并添加以下行以设置Zookeeper数据目录：
dataDir=/var/lib/zookeeper 您可以使用以下命令创建该目录：
mkdir /var/lib/zookeeper 4. 启动Zookeeper：
使用以下命令启动Zookeeper：
/usr/local/zookeeper/bin/zkServer.sh start 要检查Zookeeper的状态，请运行以下命令：
sudo /usr/local/zookeeper/bin/zkServer.sh status 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49397758803f6da49af1dfccbe64f1c1/" rel="bookmark">
			kafka集群介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、消息队列
1、为什么需要消息队列（MQ）
主要原因是由于在高并发环境下，同步请求来不及处理，请求往往会发生阻塞。比如大量的请求并发访问数据库，导致行锁表锁，最后请求线程会堆积过多，从而触发 too many connection 错误，引发雪崩效应。
我们使用消息队列，通过异步处理请求，从而缓解系统的压力。消息队列常应用于异步处理，流量削峰，应用解耦，消息通讯等场景。
当前比较常见的 MQ 中间件有 ActiveMQ、RabbitMQ、RocketMQ、Kafka 等。
2、使用消息队列的好处
（1）解耦
允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。
（2）可恢复性
系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。
（3）缓冲
有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。
（4）灵活性 &amp; 峰值处理能力
在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。
（5）异步通信
很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。
3、消息队列的两种模式
（1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）
消息生产者生产消息发送到消息队列中，然后消息消费者从消息队列中取出并且消费消息。消息被消费以后，消息队列中不再有存储，所以消息消费者不可能消费到已经被消费的消息。消息队列支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。
（2）发布/订阅模式（一对多，又叫观察者模式，消费者消费数据之后不会清除消息）
消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。
发布/订阅模式是定义对象间一种一对多的依赖关系，使得每当一个对象（目标对象）的状态发生改变，则所有依赖于它的对象（观察者对象）都会得到通知并自动更新。
二、Kafka
1、Kafka 定义
Kafka 是一个分布式的基于发布/订阅模式的消息队列（MQ，Message Queue），主要应用于大数据实时处理领域。
2、Kafka 简介
Kafka 是最初由 Linkedin 公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于 Zookeeper 协调的分布式消息中间件系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景，比如基于 hadoop 的批处理系统、低延迟的实时系统、Spark/Flink 流式处理引擎，nginx 访问日志，消息服务等等，用 scala 语言编写，
Linkedin 于 2010 年贡献给了 Apache 基金会并成为顶级开源项目。
3、Kafka 的特性
（1）高吞吐量、低延迟
Kafka 每秒可以处理几十万条消息，它的延迟最低只有几毫秒。每个 topic 可以分多个 Partition，Consumer Group 对 Partition 进行消费操作，提高负载均衡能力和消费能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49397758803f6da49af1dfccbe64f1c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9414cbbd5109e7ae6edc1b3f88125d22/" rel="bookmark">
			Ubuntu20.04安装ROS2&#43;ROS2-PX4框架搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Ubuntu20.04安装ROS2Set localeSetup SourcesInstall ROS2 packageEnvironment setup测试 ROS2-PX4框架搭建Install PX4Install ROS2Setup XRCE-DDS Agent &amp; ClientSetup the AgentStart the Client Build ROS 2 WorkspaceBuilding the WorkspaceRunning the ExampleROS 2 Offboard Control Example Ubuntu20.04安装ROS2 具体步骤参照 官方文档。此外如果安装过程中出现bug，可以参考这篇文章，写得很详细。
Set locale sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 Setup Sources sudo apt update sudo apt install curl gnupg2 lsb-release curl http://repo.ros2.org/repos.key | sudo apt-key add - sudo sh -c 'echo "deb http://packages.ros.org/ros2/ubuntu `lsb_release -cs` main"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9414cbbd5109e7ae6edc1b3f88125d22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c7166307894c352222b1bbd290bc8e/" rel="bookmark">
			Python极简讲义一本书入门机器学习和数据分析--自学笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 前言 本书有的知识点之前说，过了几节后再解释。有几个错误但是影响不大。作者自己找补说，有的没讲正常，主要靠自学。
我这里对一些没讲的作了一些补充。
这里是这本书和源码的百度链接，分享给大家。
链接： https://pan.baidu.com/s/1d4-gC7kzRvIxilWmbayrSg?pwd=ciav
提取码：ciav
还不完善: 有几章的题还没写.
1 初识python和jupyter MAKE 最小必要知识(MAKE),迅速掌握MAKE,然后缺啥补啥.
jupyter jupyter脱胎于ipython项目。ipython是一个python交互式shell，它比默认的python shell 要好用很多。而ipython正式jupyter的内核所在，我们可以理解为，jupyter是网页版的ipython。
esc 退出编辑模式
d d删除 l 显示行数 a 向上增加行 b 向下增加行
魔法函数 jupyter的魔法函数，脱离ipython的使用环境，如pycharm是用不了的。
魔法函数分为面向行和面向块的。
%matplotlib inline 内嵌
%matplotlib qt 单独
想知道用法直接%timeit? 最后追加问号
%%timeit针对代码块 两个百分号是针对整个代码块的
建议 把测试运行时长单独放置一个单元格中
%%writefile name.py 对代码块生产 .py文件
2 结构类型与程序控制结构 . 调用的是方法
不用 . 调用是内置函数
基本数据类型 数值 布尔 and 优先级比 or 高 会先运算
复数a+bj
type()只能输出一个变量的类型
多个变量同时赋值 a, b, c = 1, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c7166307894c352222b1bbd290bc8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217355c3534de27db5368f2dfd230d4a/" rel="bookmark">
			Apollo配置中心搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java
Apollo服务端：1.8+
Apollo客户端：1.7+
由于需要同时运行服务端和客户端，所以建议安装Java 1.8+。
MySQL:版本要求：5.6.5+
Apollo的表结构对timestamp 使用了多个default声明，所以需要5.6.5以上版本。
1.官网下载 https://github.com/apolloconfig/apollo/releases 2.jar拷贝 将下载的文件夹中的jar拷贝到统一文件夹下
3.数据库创建 Apollo服务端共需要两个数据库： ApolloPortalDB 和ApolloConfigDB ，ApolloPortalDB只需要在生产环境部署
一个即可，而ApolloConfigDB需要在每个环境部署一套。
1.创建ApolloPortalDB，sql脚本下载地址：
https://github.com/apolloconfig/apollo/tree/v2.1.0/scripts/sql 4.启动 确保端口未被占用
Apollo默认会启动3个服务，分别使用8070, 8080, 8090端口，请确保这3个端口当前没有被使用启动apollo-configservice，在apollo目录下执行如下命令
可通过-Dserver.port=8080修改默认端口 java ‐Xms256m ‐Xmx256m ‐Dspring.datasource.url=jdbc:mysql://localhost:3307/ApolloConfigDB?characterEncoding=utf8 ‐Dspring.datasource.username=root ‐Dspring.datasource.password=itcast0430 ‐jar apollo-configservice-2.1.0.jar 启动apollo-adminservice可通过-Dserver.port=8090修改默认端口 java ‐Xms256m ‐Xmx256m ‐Dspring.datasource.url=jdbc:mysql://localhost:3307/ApolloConfigDB?characterEncoding=utf8 ‐Dspring.datasource.username=root ‐Dspring.datasource.password=itcast0430 ‐jar apollo-adminservice-2.1.0.jar 启动apollo-portal可通过-Dserver.port=8070修改默认端口 java ‐Xms256m ‐Xmx256m ‐Ddev_meta=http://localhost:8080/ ‐Dserver.port=8070 ‐Dspring.datasource.url=jdbc:mysql://localhost:3306ApolloPortalDB?characterEncoding=utf8 ‐Dspring.datasource.username=root ‐Dspring.datasource.password=itcast0430 ‐jar apollo-portal-2.1.0.jar 这里为了方便直接编辑成脚本 echo set url="localhost:3307" set username="root" set password="root" start "configService" java -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDB?characterEncoding=utf8 -Dspring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/217355c3534de27db5368f2dfd230d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b4507d60fcb9e0236c66907192d1038/" rel="bookmark">
			VMware 虚拟机中 Linux 系统Centos7磁盘空间扩容（亲测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.修改虚拟机磁盘容量 例如之前虚拟机磁盘空间为30G，现要将磁盘容量设置为50G
打开虚拟机（必须处于关机状态），点击【编辑虚拟机设置】，然后点击【磁盘】，接着点击【扩展】，输入修改后的最大磁盘容量50G，具体操作时最大容量根据自己的需求设置即可。
输入完成最大磁盘容量后，点击扩展，出现设置成功字样后说明设置成功，接下来进入第二阶段的操作。
2.启动系统、查看分区 使用xshell工具连接并登录、查看磁盘分区表
可以看到本机有三分磁盘sda1、sda2、sda3.
3.开始添加分区 使用linux分区工具fdisk 开始给磁盘分区
[root@localhost ~]# fdisk /dev/sda 输入m查看帮助信息
输入n表示增加分区
输入p标识创建主分区
回车后，分区号输入4，因为之前已经有三个分区（sda1、sda2、sda3）
起始扇区设置，直接回车默认即可
终止扇区设置，回车设置默认即可
输入w进行保存
到此分区划分完毕。
4.修改新分区id类型为8e 通过上面的操纵，再次使用fdisk -l查看，可以看到新增加的分区sda4已经出现
上图的红色方框区域，可以看到 /dev/sda3 的 Id号为 83，需要要将其改成 8e（LVM卷文件系统的 Id），具体方法，如下图所示：
fdisk /dev/sda 输入m获取帮助信息，然后分别输入：
t---------回车
4--------回车（新增的分区号）
l---------回车
输入8e并回车
输入w保存
修改后的信息如下，可以看到已经将sda3修改为系统卷id：
重启系统reboot，这一步非常关键切记
5.开始扩充分区 使用lvs显示逻辑卷分区信息
显示卷组信息
将物理硬盘分区初始化为物理卷，以便被 LVM 使用
pvcreate /dev/sda4 扩展卷组：
centos： 是执行vgdisplay后的VG name对应的值，根据个人情况修改
vgextend centos /dev/sda4 再次显示卷组信息：可以看到Free PE从0变为10.00Gib，说明我们最多可以有 10GB 的扩充空间
扩充逻辑卷分区：
centos/root： 是根据第七部分一开头的lvs中显示的VG 和 LV内容进行的替换，根据个人情况修改。
lvextend -L+9.9G /dev/centos/root /dev/sda4 重设逻辑卷大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b4507d60fcb9e0236c66907192d1038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653c9fbef0259f8d62fae63b07928959/" rel="bookmark">
			SpringBoot 全局异常处理——解决404/500
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 全局异常处理——解决404/500 SpringBoot要全局处理 Spring Boot 应用程序中的 HTTP 404 和 500 错误，您可以自定义一个异常处理器类，并使用 @ControllerAdvice 和 @ExceptionHandler 注释来拦截和处理这些异常。
解决方案 下面是一种可能的实现方式，它捕获HTTP GET请求中PathVariable参数类型不匹配、参数格式错误以及其他所有未处理的异常，并返回一个包含错误代码和错误消息的 Map 对象：
@ControllerAdvice public class GlobalExceptionHandler { // 捕获 PathVariable 参数类型不匹配或格式错误的异常，并返回错误信息 @ExceptionHandler(MethodArgumentTypeMismatchException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) @ResponseBody public Map&lt;String, Object&gt; handleMethodArgumentTypeMismatchException(MethodArgumentTypeMismatchException ex) { return createErrorResponse(HttpStatus.BAD_REQUEST.value(), "请求参数有误: " + ex.getMessage()); } // 捕获其他未处理的异常，并返回错误信息 @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ResponseBody public Map&lt;String, Object&gt; handleUncaughtException(Exception ex) { return createErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), "系统内部错误: " + ex.getMessage()); } // 创建包含错误码和错误消息的 Map 对象 private Map&lt;String, Object&gt; createErrorResponse(int code, String message) { Map&lt;String, Object&gt; errorResponse = new HashMap&lt;&gt;(); errorResponse.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/653c9fbef0259f8d62fae63b07928959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dce0a873d8d87816e88d038f7059aa7/" rel="bookmark">
			消息队列基本原理和选型对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息队列使用场景 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，削峰填谷等问题。实现高性能、高可用、可伸缩和最终一致性架构。
解耦：多个服务监听、处理同一条消息，避免多次 rpc 调用。图片
异步消息：消息发布者不用等待消息处理的的结果。图片
削峰填谷：较大流量、写入场景，为下游 I/O 服务抗流量。当然大流量下就需要使用其他方案了。
消息驱动框架：在事件总线中，服务通过监听事件消息驱动服务完成相应动作。
消息队列模式 点对点模式，不可重复消费 多个生产者可以向同一个消息队列发送消息，一个消息在被一个消息者消费成功后，这条消息会被移除，其他消费者无法处理该消息。如果消费者处理一个消息失败了，那么这条消息会重新被消费。
图片
发布/订阅模式 发布订阅模式需要进行注册、订阅，根据注册消费对应的消息。多个生产者可以将消息写到同一个 Topic 中，多种消息可以被同一个消费者消费。一个生产者生产的消息，同样也可以被多个消费者消费，只要他们进行过消息订阅。
图片
选型参考 （1） 消息顺序：发送到队列的消息，消费时是否可以保证消费的顺序；
（2）伸缩：当消息队列性能有问题，比如消费太慢，是否可以快速支持扩容；当消费队列过多，浪费系统资源，是否可以支持缩容。
（3）消息留存：消息消费成功后，是否还会继续保留在消息队列；
（4）容错性：当一条消息消费失败后，是否有一些机制，保证这条消息一定能成功，比如异步第三方退款消息，需要保证这条消息消费掉，才能确定给用户退款成功，所以必须保证这条消息消费成功的准确性；
（5）消息可靠性：是否会存在丢消息的情况，比如有 A/B 两个消息，最后只有 B 消息能消费，A 消息丢失；
（6）消息时序：主要包括“消息存活时间”和“延迟消息”；
（7）吞吐量：支持的最高并发数；
（8）消息路由：根据路由规则，只订阅匹配路由规则的消息，比如有 A/B 两者规则的消息，消费者可以只订阅 A 消息，B 消息不会消费。
Kafka Kafka 是由 Apache 软件基金会开发的一个开源流处理平台，由 Scala 和 Java 编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。（维基百科）
基本术语 Producer ：消息生产者。一般情况下，一条消息会被发送到特定的主题上。通常情况下，写入的消息会通过轮询将消息写入各分区。生产者也可以通过设定消息 key 值将消息写入指定分区。写入分区的数据越均匀 Kafka 的性能才能更好发挥。
Topic ：Topic 是个抽象的虚拟概念，一个集群可以有多个 Topic，作为一类消息的标识。一个生产者将消息发送到 topic，消费者通过订阅 Topic 获取分区消息。
Partition ：Partition 是个物理概念，一个 Topic 对应一个或多个 Partition。新消息会以追加的方式写入分区里，在同一个 Partition 里消息是有序的。Kafka 通过分区，实现消息的冗余和伸缩性，以及支持物理上的并发读、写，大大提高了吞吐量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dce0a873d8d87816e88d038f7059aa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c38a2a0a31f6c8821481b4e9f6d9ecf/" rel="bookmark">
			java毕业设计——基于JSP&#43;sqlserver的网络超市商品销售管理系统设计与实现（毕业论文&#43;程序源码）——商品销售管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于JSP+sqlserver的网络超市商品销售管理系统设计与实现（毕业论文+程序源码） 大家好，今天给大家介绍基于JSP+sqlserver的网络超市商品销售管理系统设计与实现，文章末尾附有本毕业设计的论文和源码下载地址哦。需要下载开题报告PPT模板及论文答辩PPT模板等的小伙伴，可以进入我的博客主页查看左侧最下面栏目中的自助下载方法哦
文章目录：
基于JSP+sqlserver的网络超市商品销售管理系统设计与实现（毕业论文+程序源码）1、项目简介2、资源详情3、关键词4、毕设简介5、资源下载 1、项目简介 随着互联网日益深入我们的生活，网上商品销售的方式也逐渐被人们所接受，因而集成销售管理功能的网上销售系统也显得更加重要而实用。鉴于此，本课题设计了基于网络超市的商品销售管理系统。首先，论文简单介绍了商品销售管理系统的产生、发展和现状；然后对本系统使用的几项关键技术做了介绍；最后用软件工程的分析方法从系统需求分析、系统设计、数据库设计、系统实现等几个方面对整个系统进行了阐述。同时对系统的功能，包括商品目录显示、用户注册、用户登录、购物车、定单查询、系统维护管理等功能模块进行了实现。本系统主要运用了HTML、JSP编程技术与SQL Server数据库等关键技术进行设计、实现。设计中使用页面模块化思想，并部分采用三层架构思想，使用JavaBean 完成对数据库的操作，对销售管理、系统维护部分使用Servlet技术实现。当然系统还存在许多不足之处有待改进，特别是安全方面的问题还没有很好的考虑和实现。 2、资源详情 项目难度：中等难度
适用场景：相关题目的毕业设计
配套论文字数：15510个字36页
包含内容：全套源码+配整论文
开题报告、论文答辩、课题报告等ppt模板推荐下载方式：
3、关键词 网络超市；管理系统；JSP；JavaBean；Servlet 4、毕设简介 提示：以下为毕业论文的简略介绍，项目完整源码及完整毕业论文下载地址见文末。
引言
1.1选题背景
互联网以前所未有的速度发展，成为与报纸、广播、电视相比肩的第四媒体，同时以其便捷的传输模式改变着人们的消费方式。它有着信息传送速度快、信息覆盖面广、成本低的特点，互联网已日益成为收集和提供信息的最佳渠道并逐步进入传统的流通领域。于是电子商务开始流行起来，越来越多的商家在网上建立在线商店，打破了传统的消费观念，并向消费者展示出一种全新的购物理念。商家可以通过对信息筛选处理有用信息，并做出相应的销售策略，这能为商家带来便利和更大的利润，也能更好的管理好自己的商店。利用简单、便捷、低成本的电子通信方式，买卖双方不见面就可以进行各种商贸活动。当今商业经济网络化已经成为网络经济的大势所趋，眼下电子商务如雨后春笋般大量涌现，企业网络已经成为一种时尚。
为了兼顾商家和顾客的利益，本课题选择针对基于网络超市的商品销售管理系统进行研究设计。本课题主要讨论如何建设网上购物系统以及如何管理。网上购物是一种具有交互功能的商业信息系统，它向用户提供静态和动态两类信息资源。所谓静态信息是指那些不是经常变动或更新的资源，如公司简介、管理规范和公司制度等等；动态信息是指随时变化的信息，如商品报价，商品流动和商品信息等。商品销售系统具有强大的交互功能，可使商家和用户方便的传递信息，完成网上购物交易，加强了厂家与消费者之间的沟通，这种全新的交易方式实现了零售商家与消费者之间的无纸币交换。而对于网上销售的商家，只要使用了在线销售管理系统，他们可以轻松建立一个功能强大的网上商城，最主要的是管理员只需要登录网站后台管理就可以在线发布商品、处理订单，完全不需要任何网站建设的知识，这样节省了大量的人力、物力和财力。
1.2国内外发展现状
省略
1.3本课题的研究内容及方法
基于网络超市的商品销售管理系统，一般存在两种结构：C/S（Client/Server——客户端/服务器）架构和基于Internet的B/S（Browser/Server——浏览器/服务器）架构。B/S架构比起C/S架构有着很大的优越性，C/S架构的系统依赖于专门的操作环境，这意味着操作者的活动空间受到极大限制；而B/S架构则不需要专门的操作环境，在任何地方，只要能上网，就能够操作该系统。这也就给交互式信息的产生创造了先决条件，使得通过互联网的信息传递变得更加的便捷。因此，本文设计的基于网络超市商品销售管理系统选取的是B/S。
基于网络超市的商品销售管理系统，实质就是程序结合数据库开发的网站系统。在该系统中，主要实现用户注册、用户登录、用户留言、购物指南、商品查询、购物车、订单查询等基本功能。管理员可以实现对用户的管理、对用户留言的管理、对产品种类的管理、产品的管理、商品管理、订单管理等维护工作。商品销售管理系统不仅要设计漂亮的网页，更要有严谨的规划，每一个细小的环节都很重要，这样才能使得在网上交易的过程中避免不必要的错误发生。
对于本系统的设计开发，是以JDK+Eclipse+TOMCAT作为开发平台，JSP作为前台开发语言，负责处理页面的显示，同时结合Servlets和JavaBean 应用开发。运用JSP产生页面动态部分，HTML产生静态页面，同时在HTML中嵌入JavaScript增加动态效果。使用JavaBean完成对数据库连接的封装和对数据库的存取操作。在系统维护部分还编写简单Servlet 接收用户的输入和提交动作，并根据动作指示进行相应的业务处理。此外还需要建立SqlServer数据库。因为传统的管理信息系统信息获取方法是由专业文字录入人员将信息输入到管理系统的数据库中，这种方法适合数据量不大的时候，但是当数据量比较大并且有较强的专业性时,录入的费用和出错的可能性都会增大。特别对一个网上购物系统，经过长时间的运行，记录了大量的顾客消费的记录，不加分析，这些数据都将毫无用处。建立自己的数据库，使得所需商品信息可以及时的保存、更新，也可以更好的及时了解商品买卖的情况。
2技术理论基础及开发平台
2.1 技术理论基础
2.1.1 HTML语言
HTML（Hyper Text Markup Language 超文本标记语言）是一种用来制作超文本文档的简单标记语言。“超文本”就是指页面内可以包含图片、链接，甚至音乐，程序等非文字的元素。HTML文件是带有特定HTML插入标记的用以编排文档属性和格式的标准文本文件，它能独立于各种操作系统平台（如UNIX，WINDOWS等）。自1990年以来HTML就一直被用作WWW上的信息表示语言，用于描述Homepage的格式设计和它与WWW上其它Homepage的连结信息。HTML文档（即Homepage的源文件）是一个放置了标记的ASCII文本文件，通常它带有HTM或HTML的文件扩展名。生成一个HTML文档主要有以下三种途径：
省略
2.1.2 JSP技术
JSP（Java Server Pages）是在服务器端编译执行的WEB设计语言，其脚本采用Java技术，完全继承了Java的所有优点。JSP技术为创建显示动态生成内容的WEB页面提供了一个简捷而快速的方法，它能使你将网页的动态部分和静态部分有效分开。
JSP有如下优点：
( 1 ) 将内容的生成和显示进行分离
使用JSP技术，Web页面开发人员可以使用HTML或者XML来设计页面的静态内容；使用JSP生成页面的动态内容。JSP是服务器端技术。在服务器端，JSP引擎解释JSP，生成所有客户端的请求的内容，然后将结果以HTML或者XML页面的形式发送给客户端。这有助于开发人员既保护自己的代码，又保证任何基于HTML的Web 浏览器的完全可用性。
( 2 ) 强调可重用性组件
绝大多数JSP页面依赖于可重用的、跨平台的组件来执行应用程序所要求的更为复杂的处理。JavaBeans已经是很成熟的技术，基于组件的方法可供开发人员共享，大大加速了总体开发过程。
( 3 ) 采用标识简化页面开发
JSP技术封装了许多功能，这些功能是在生成易用的、与JSP相关的HTML或者XML的动态内容时所需要的。标准的JSP标识能够访问和实例化JavaBeans组件、设置或者检索组件属性、下载Applet，以及执行用其他方法更难编码的耗时功能。通过开发制定标识库，JSP技术是可以扩展的。开发人员可以为常用功能创建自己的标识库，从而使Web页面开发人员能够使用如同标识一样的工具来执行特定功能的构件。
( 4 ) 健壮性和安全性
由于JSP 的内置脚本语言是基于Java语言的，而且所有的JSP 都被编译成Servlets，JSP 就具有Java技术的所有好处，包括健壮的储存管理和安全性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c38a2a0a31f6c8821481b4e9f6d9ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e654c981bf29b47c2bad9cb5ba9990ce/" rel="bookmark">
			MySQL自带的数据库压力测试工具mysqlslap使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，基本介绍 mysqlslap 是 MySQL 从 5.1.4 版开始官方自带的一个压力测试工具。它通过模拟多个并发客户端访问 MySQL 来执行压力测试，我们通过结果信息可以了解数据库的性能状况。mysqlslap 是系统运维和 DBA 人员应该掌握一些常见的压力测试工具之一，其主要工作场景就是对数据库服务器做基准测试。比如：服务器的硬件资源能够支持多大的访问压力呢？优化了操作系统的内核参数后，是否提升了性能？调整了 MySQL 配置参数后，对性能有多少影响？ 2，简单用法 （1）我们执行如下命令对数据库做一个简单的自动测试，–auto-generate-sql 作用是自动生成测试 SQL。
注意：如果我们没有人为指定测试数据库，则默认是 mysqlslap（该数据库会自动创建，测试完毕自动删除）。
mysqlslap -uroot -pHangge_123 --auto-generate-sql （2）运行结果如下：
Average number of seconds to run all queries：运行所有语句的平均秒数Minimum number of seconds to run all queries：运行所有语句的最小秒数Maximum number of seconds to run all queries：运行所有语句的最大秒数Number of clients running queries：客户端数量Average number of queries per client：每个客户端运行查询的平均数 3，打印实际的测试过程 （1）测试的过程需要生成测试表，插入测试数据，我们可以添加 –only-print 来打印实际的测试过程（不会实际执行）：
mysqlslap -uroot -pHangge_123 --auto-generate-sql --only-print （2）运行结果如下，可以看到整个测试完成后会自动删除测试库，不会在数据库中留下痕迹。
4，添加并发 （1）我们可以添加如下两个参数，模拟并发处理查询请求：
–concurrency=100：指定同时有 100 个客户端连接–number-of-queries=1000：指定总的测试查询次数（并发客户端数 * 每个客户端的查询次数），这样本样例平均每个客户端查询 10 次 mysqlslap -uroot -pHangge_123 --concurrency=100 --number-of-queries=1000 --auto-generate-sql （2）运行结果如下（注意结果是完成 1000 次查询的总时间）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e654c981bf29b47c2bad9cb5ba9990ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c98f79ef8acef41e25b3f61e41468d/" rel="bookmark">
			IO与进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO 学习IO目的：为了将数据存储以及对于文件的操作
标准IO：
ANSI（美国标准协会）联合ISO（国际化标准组织）所形成的的一个C标准 （C标准：属于C库，含有一些列输入输出函数），只要操作系统支持C库，就可以使用这一类标准IO提供的函数----》移植性比较高
操作的文件一般是普通文件属于高级磁盘IO--》存在缓冲区，减少了用户态切换至内核态，最后又返回用户态这样的频繁操作，意味着减少了系统开销。通过文件流（FILE *）操作文件（打开文件时，系统会自动将该文件的信息定义结构体类型struct FILE 来进行存储，因此可以通过FILE *文件指针来操作文件） 文件IO
POSIX（可移植操作系统接口）推出的对于支持POSIX标准的系统可以操作文件的一系列函数（UNIX系统一般都会支持POSIX的标准）---》移植性不高（只能应用于UNIX系统）
操作的文件可以普通文件或者设备文件（硬件）低级磁盘IO---》没有缓冲区，每一次都是系统调用，都会存在用户空间和内核空间的频繁切换工作，好处就是可以直接对于设备进行读写操作。通过文件描述符来（非负的数字）操作文件 概念：文件被打开时，创建的结构体名为FILE的结构体指针，形象的称为“流”
分析：为啥称结构体指针为流？
--》因为标准IO存在缓冲区，所以每一次向缓冲区不断放入数据（每一次的放入数据：均是需要通过文件指针来进行读写指向的文件），存在三个特点：
有源头：APP有目的：缓冲区持续性：不断放入数据到缓冲区 ---》一旦具备以上3个特点，就会形成流，所以通过文件指针操作文件可以理解为是通过操作流来操作文件
特性函数： perror(“string”)；---》可以输出出错的原因feof(FILE* Stream)； 作用：判断文件是否抵达末尾（不管是文本文件还是二进制文件，都可以判断）
返回值：
抵达文件末尾---》返回值为非零
未抵达文件末尾---》返回值0
操作文件IO：open close read write 头文件：
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
打开文件 函数原型：
int open(const char *pathname, int flags);
功能：打开指定的文件
参数：
参数1：所需打开文件的名字（包含路径）
参数2：打开文件的方式---》主标志 | 副标志
返回值：成功代表一个大于0 的数字（文件描述符），失败返回-1（errno ie set...）
int open(const char *pathname, int flags, mode_t mode);
功能：打开指定的文件
参数：
参数1：所需打开文件的名字（包含路径）
参数2：打开文件的方式---》主标志 | 副标志
参数3：当需要O_CREAT时，就要写该参数来为创建的新文件指明权限（八进制表示）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97c98f79ef8acef41e25b3f61e41468d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67e939977cc3540e14a4ffa243d9e32/" rel="bookmark">
			HTTP协议中的响应码和实体数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
HTTP世界中的名词术语
OSI七层模型
TCP的三次握手和四次挥手
HTTP报文
HTTP/1.1中规定的八种方法
HTTP的安全与幂等
HTTP的特点
HTTP的优缺点
HTTP的响应状态码
【响应码2xx】
【响应码3xx】
【响应码4xx】
【响应码5xx】
HTTP的实体数据
HTTP传输大文件的方法
HTTP世界中的名词术语 HTTP 就是超文本传输协议，也就是HyperText Transfer Protocol。CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。应用层：有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP、HTTP。DNS 就像是我们现实世界里的电话本、查号台，统管着互联网世界里的所有网站，是一个“超级大管家”；DNS 是一个树状的分布式查询系统，但为了提高查询效率，外围有多级的缓存；使用 DNS 可以实现基于域名的负载均衡，既可以在内网，也可以在外网。 如何理解TCP和UDP：TCP 是面向连接的、可靠的、只支持点对点通信；UDP 是无连接的、不可靠的、支持一对一、一对多、多对一、多对多的通信模式。TCP就像是两个人打电话，UDP就像是马路上的广播。
如何理解WebSocket：是一种基于 TCP 的轻量级网络通信协议，在地位上是与 HTTP“平级”的。HTTP 难以应用在动态页面、即时消息、网络游戏等要求“实时通信”的领域;WebSocket 客户端和服务器都可以随时向对方发送数据。
OSI七层模型 （1）物理层：建立、维护、断开物理连接； （2）数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能； （3）网络层：进行逻辑地址寻址，实现不同网络之间的路径选择，协议有：IP。 （4）传输层：定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP和UDP，数据包一旦离开网卡即进入网络传输层。 （5）会话层：建立、管理、终止会话。 （6）表示层：数据的表示、安全、压缩。 （7）应用层：网络服务与最终用户的一个接口。协议有：HTTP、FTP、TFTP、SMTP、SNMP、DNS、TELNET、HTTPS、POP3、DHCP。 常见网络协议含义及端口：
FTP：文件传输协议，默认端口21
Telnet：用于远程登录，端口23
SMTP：简单邮件传输协议，端口25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c67e939977cc3540e14a4ffa243d9e32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262901aa6ff49736782b9531a0f845cf/" rel="bookmark">
			C&#43;&#43;实现通讯录管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
C++实现通讯录管理系统
一、设计结构体
1、联系人结构体
2、通讯录结构体
二、封装函数
1、菜单界面函数
2、添加联系人函数
3、显示联系人函数
4、删除联系人函数
5、查找联系人函数
6、修改联系人函数
7、清空联系人函数
三、通讯录管理系统总代码
C++实现通讯录管理系统 一、设计结构体 1、联系人结构体 //设计联系人结构体 struct Person { //姓名 string m_Name; //性别 1 男 2 女 int m_Sex; //年龄 int m_Age; //电话 string m_Phone; //地址 string m_Addr; }; 2、通讯录结构体 //设计通讯录结构体 struct Addressbooks { //通讯录中保存的联系人数组 struct Person personArray[MAX]; //通讯录中当前记录联系人个数 int m_Size; }; 二、封装函数 1、菜单界面函数 //菜单界面 void showMenu() { cout &lt;&lt; "***************************" &lt;&lt; endl; cout &lt;&lt; "***** 1、添加联系人 *****"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262901aa6ff49736782b9531a0f845cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1843e6a88e88676d67bad1de427cadb2/" rel="bookmark">
			若依使用的框架和技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若依（Ruoyi）框架是一个基于Spring Boot和MyBatis-Plus的开源后台管理系统快速开发框架。它在项目开发中集成了多个框架和技术，提供了丰富的功能和可扩展性。下面是若依框架使用到的一些主要框架和技术：
Spring Boot：
Spring Boot是一个用于简化Spring应用程序开发的框架，提供了自动配置、快速开发等特性。若依框架基于Spring Boot，利用了其简化配置和快速启动的特性，加快了项目的开发速度。 MyBatis-Plus：
MyBatis-Plus是一个为MyBatis框架提供增强功能的开源库，简化了数据库访问层的开发。若依框架使用MyBatis-Plus作为持久层框架，通过提供的便捷API和代码生成器，简化了数据库操作和SQL编写。 Shiro：
Shiro是一个功能强大且灵活的Java安全框架，提供了身份认证、授权、会话管理等安全相关的功能。若依框架集成了Shiro，通过配置和自定义Realm，实现了用户认证和权限管理的功能。 Redis：
Redis是一个开源的内存数据存储系统，提供了高性能的键值存储和缓存功能。若依框架使用Redis来实现缓存功能，提升系统的性能和响应速度。 Swagger：
Swagger是一个用于设计、构建、文档化和使用RESTful Web服务的工具集。若依框架集成了Swagger，方便开发人员进行API的设计、文档生成和测试。 Vue.js：
Vue.js是一个流行的JavaScript框架，用于构建用户界面。若依框架使用Vue.js作为前端框架，通过前后端分离的架构，实现了前端页面和后端接口的解耦和灵活性。 相对于其他项目，若依具有以下几个优势：
快速开发：若依框架提供了丰富的代码生成器和开发模板，可以快速生成项目的基础代码和通用功能模块，极大地提高了开发效率。开发人员只需要关注业务逻辑的实现，而无需重复编写基础代码。
高度可定制：若依框架采用模块化的设计，各个功能模块之间松耦合，开发人员可以根据实际需求选择性地引入和定制功能模块。这种灵活性使得若依框架可以适应不同规模和需求的项目。
强大的代码生成器：若依的代码生成器支持根据数据库表结构自动生成实体类、控制器、服务类、Mapper 接口等代码，减少了手动编写重复代码的工作量。同时，代码生成器还支持自定义模板和扩展，可以满足个性化的开发需求。
高度集成的开发环境：若依框架集成了许多常用的开发工具和技术，如 Shiro 安全框架、Swagger API 文档、Quartz 定时任务等，提供了开箱即用的功能。这样，开发人员可以更专注于业务开发，而无需额外配置和集成这些工具。
广泛使用的开源技术：若依框架基于 Spring Boot 和 MyBatis，这两个技术在企业应用开发中非常常用和成熟。使用这些技术可以保证项目的稳定性、可扩展性和维护性。
总之，若依框架通过提供代码生成器、模块化设计和集成常用工具等特点，旨在提高开发效率、降低开发成本，并提供灵活的可定制性。它适用于各种规模的企业级应用开发，并提供了一套规范化和标准化的开发模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7af9f04cf302a786818fc6350ec4b0db/" rel="bookmark">
			python打包资源文件（图片等）的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本步骤 （一）先使用pyinstaller命令对主程序进行打包 如果没有pyinstaller命令，先进行下载：pip install pyinstaller
打包的两种方式：
pyinstaller -D test.py # 生成一个文件夹，里面是多文件模式，启动快。
pyinstaller -F test.py # 仅仅生成一个文件，不暴露其他信息，启动较慢。
Pyinstaller -F setup.py 打包exe
Pyinstaller -F -w setup.py 不带控制台的打包
Pyinstaller -F -i xx.ico setup.py 打包指定exe图标打包
（二）修改spec文件，添加资源 1.修改datas项 datas=[('res/bg.jpg', 'res'), ('exam.db', '.')]
列表里面是元组，左边是你要添加的filename（相对路径即可），右边是拷贝到项目中之后的文件夹名字。
比如：
(‘res/bg.jpg’, ‘res’) 中的 ‘res/bg.jpg’ 表示工程根目录下res文件夹下有bg.jpg图片，拷贝到项目之后的res文件夹。
(‘exam.db’, ‘.’) 中的’exam.db’是工程根目录下的文件，’.'表示根目录，即拷贝到项目中的根目录下。
2.修改pathex项 pathex=['/Users/wenlong/exam_demo']
即添加项目地址
（三）重新编译 注意只需编译spec文件
pyinstaller test.spec
二、注意事项 （一）修改代码中资源访问路径 # 生成资源文件目录访问路径 def resource_path(relative_path): if getattr(sys, 'frozen', False): # 判断sys中是否存在frozen变量,即是否是打包程序 base_path = sys._MEIPASS # sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7af9f04cf302a786818fc6350ec4b0db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ecf25613e8e0beb735ba93aaf1404e/" rel="bookmark">
			ROS2 ERROR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS2 ERROR 长篇error合集，请善用搜索功能
1. CMake Error at /opt/ros/humble/share/rosidl_cmake/cmake/rosidl_generate_interfaces.cmake:213 (add_custom_target) CMake Error at /opt/ros/humble/share/rosidl_cmake/cmake/rosidl_generate_interfaces.cmake:213 (add_custom_target): The target name "$(PROJECT_NAME)" is reserved or not valid for certain CMake features, such as generator expressions, and may result in undefined behavior. Call Stack (most recent call first): CMakeLists.txt:15 (rosidl_generate_interfaces) 原文：
rosidl_generate_interfaces( $(PROJECT_NAME) "msg/Student.msg" ) 改成：
rosidl_generate_interfaces( ${PROJECT_NAME} "msg/Student.msg" ) 2. std::runtime_error 在运行ros2 run cpp01_topic demo04_listener_stu 时报错：
terminate called after throwing an instance of 'std::runtime_error' what(): this specialization of rclcpp::get_message_type_support_handle() should never be called [ros2run]: Aborted 重新编译后发现一个警告
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ecf25613e8e0beb735ba93aaf1404e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55d1a5022d848af431eb5591bfde10c/" rel="bookmark">
			SpringCloudStream集成RabbitMQ实现消息收发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SpringCloudStream ​ SpringCloudStream 是一个构建高扩展和事件驱动的微服务系统的框架，用于连接共有消息系统，官网地址： spring.io/projects/sp… 。整体上是把各种花里胡哨的MQ产品抽象成了一套非常简单的统一的编程框架，以实现事件驱动的编程模型。社区官方实现了RabbitMQ，Apache Kafka，Kafka Stream和Amazon Kinesis这几种产品，而其他还有很多产品比如RocketMQ，都是由产品方自行提供扩展实现。
所以可以看到，对于RabbitMQ，使用SpringCloudStream框架算是一种比较成熟的集成方案。但是需要主要注意的是，SpringCloudStream框架集成的版本通常是比RabbitMQ落后几个版本的，使用时需要注意。
​ SpringCloudStream框架封装出了三个最基础的概念来对各种消息中间件提供统一的抽象：
Destination Binders:负责集成外部消息系统的组件。Destination Binding:由Binders创建的，负责沟通外部消息系统、消息发送者和消息消费者的桥梁。Message:消息发送者与消息消费者沟通的简单数据结构。 ​ 可以看到，这个模型非常简单，使用时也会非常方便。但是简单，意味着SCStream中的各种概念模型，与RabbitMQ的基础概念之间是有比较大的差距的，例如Exchange、Queue这些原生概念，集成到SCStream框架时，都需要注意如何配置，如何转换。
1-1、引入依赖 RabbitMQ的SpringCloudStream支持是由Spring社区官网提供的，所以这也是相当成熟的一种集成方案。但是要注意，SpringCloudStream框架集成的版本通常是比RabbitMQ产品本身落后几个版本的，使用时需要注意。
​ 他的核心依赖也就一个：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;!-- artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId --&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; 复制代码 这两个Maven依赖没有什么特别大的区别，实际上，他们的github代码库是在一起的。仓库地址：github.com/spring-clou…
依赖的版本通常建议使用SpringCloud的整体版本控制。 org.springframework.cloud#spring-cloud-dependencies#Hoxton.SR6，这样各个组件之间的版本比较安全。不建议贸然尝试新版本。
1-2、配置mq相关参数 spring.rabbitmq.addresses=192.168.253.131:5672,192.168.253.132:5672,192.168.253.133:5672 spring.rabbitmq.username=admin spring.rabbitmq.password=admin spring.rabbitmq.virtual-host=/mirror 复制代码 1-3、配置启动类 需要在springboot启动类上加上如下注解
@EnableBinding({Source.class, Sink.class}) 复制代码 1-4、声明消息收费者 @Component @EnableBinding(Sink.class) public class MessageReceiver { private Logger logger = LoggerFactory.getLogger(MessageReceiver.class); @EventListener @StreamListener(Sink.INPUT) public void process(Object message) { System.out.println("received message : " + message); logger.info("received message : {}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55d1a5022d848af431eb5591bfde10c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51ef23a4ee380d620d0003fe7242651/" rel="bookmark">
			Rust-Rocket框架笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust-Rocket框架笔记 Rocket-Learn-docRocket Addr视频地址 What is RocketQuickStart下载Rocket-Rust运行Rust-Rocket-Hello-错误-端口占用解决查看端口占用情况添加Rocket.toml配置文件更改Rocket默认启动端口启动成功 GetStart-Hello world创建项目cargoIDEA 添加依赖添加Rocket.toml配置文件main.rsres Rocket-生命周期Rocket-请求方法动态路径路径保护忽略路径转发通过参数类型捕获rank默认等级 请求守卫转发守卫 Cookie隐私Cookie密钥 格式Format请求体数据Json开启json特性引入use设置请求体数据体（struct）编写方法临时文件流媒体 QueryString静态参数动态参数尾随参数 错误处理器 Rocket-响应Responder包装例子 自定义应答器简单示例完整示例 Responder实现OptionResult 响应Json模板添加依赖修改Cargo.tomlmain.rs添加页面模板 Rocket-状态管理Rocket-连接池连接数据库Mysql添加依赖设置数据库连接配置(Rocket.toml)main.rs 使用Figment提取自定义配置添加依赖设置app.tomlmain.rs Rocket-Learn-doc createTime:20230430author:syf20020816@outlook.comemail:syf20020816@outlook.com Rocket Addr 地址：https://rocket.rs/v0.5-rc/guide/introduction/
视频地址 https://www.bilibili.com/video/BV14h41177Ga/?spm_id_from=333.999.0.0&amp;vd_source=9c2ae08297163e79152407c969f04717
What is Rocket Rocket是Rust的Web框架。如果你愿意，你可以把火箭看作是一个更灵活，更友好支持热插拔,我们更愿意把火箭看作是一种新的东西。Rocket的目标是快速、简单和灵活，同时尽可能提供有保证的安全性。更重要的是，Rocket还致力于成为乐趣，它通过确保您编写尽可能少的代码来完成任务来实现这一点。
Rocket的设计围绕着三个核心理念：
安全性、正确性和开发人员体验至关重要。
阻力最小的路径应该会引导您获得最安全，最正确的Web应用程序，尽管安全性和正确性不应该以降低开发人员体验为代价。Rocket易于使用，同时采取了很好的措施来确保您的应用程序是安全和正确的，而无需认知开销。
所有请求处理信息都应该是类型化的，并且是独立的。
因为Web和HTTP本身是无类型的（或弦地 类型的，正如一些人所说的那样），这意味着某些东西或某人必须将字符串转换为本地类型。Rocket可以为你做到这一点，而且编程开销为零。更何况，火箭的请求处理是自足的 零全局状态：处理程序是具有常规参数的常规函数。
不应强迫作出决定。
模板、序列化、会话以及几乎所有其他组件都是可插拔的可选组件。虽然Rocket对每一个都有官方支持和库，但它们是完全可选和可交换的。
这三个想法决定了Rocket的界面，你会发现它们都嵌入了Rocket的核心功能
QuickStart 下载Rocket-Rust git clone https://github.com/SergioBenitez/Rocket cd Rocket/examples/hello cargo run 运行Rust-Rocket-Hello-错误-端口占用 Configured for debug. &gt;&gt; address: 127.0.0.1 &gt;&gt; port: 8000 &gt;&gt; workers: 8 &gt;&gt; max blocking threads: 512 &gt;&gt; ident: Rocket &gt;&gt; IP header: X-Real-IP &gt;&gt; limits: bytes = 8KiB, data-form = 2MiB, file = 1MiB, form = 32KiB, json = 1MiB, msgpack = 1MiB, string = 8KiB &gt;&gt; temp dir: C:\Users\SYF200~1\AppData\Local\Temp\ &gt;&gt; http/2: true &gt;&gt; keep-alive: 5s &gt;&gt; tls: disabled &gt;&gt; shutdown: ctrlc = true, force = true, grace = 2s, mercy = 3s &gt;&gt; log level: normal &gt;&gt; cli colors: true Routes: &gt;&gt; (hello) GET /?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e51ef23a4ee380d620d0003fe7242651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fb7b57e1ece16e47089fe00a24ebf49/" rel="bookmark">
			【Docker】Nacos2.0.3的配置部署与基于SpringBoot3.0.5的代码基础配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Nacos的Docker配置部署1 查看镜像2 拉取镜像3 查看已拉取镜像4 创建挂载文件夹5 启动容器以复制配置文件6 导入Nacos数据表7 停止并删除容器8 启动容器9 查看容器日志10 开放对应端口 二、搭建测试项目1 Nacos配置1.1 创建命名空间1.2 创建配置文件 2 项目信息2.1 版本2.2 依赖2.3 项目结构2.4 bootstrap.properties配置文件2.5 Application启动类 3 启动项目 一、Nacos的Docker配置部署 1 查看镜像 docker search nacos/nacos-server 2 拉取镜像 docker pull nacos/nacos-server:v2.0.3 3 查看已拉取镜像 docker images 4 创建挂载文件夹 mkdir /home/nacos/logs -p 5 启动容器以复制配置文件 5.1 启动容器
docker run \ -p 8848:8848 \ --name testnacos \ -d nacos/nacos-server:v2.0.3 5.2 复制配置文件
docker cp testnacos:/home/nacos/logs/ /home/nacos/logs/ 6 导入Nacos数据表 文件名：nacos-mysql.sql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fb7b57e1ece16e47089fe00a24ebf49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ba7c857aa76f153a1e5ca349b95b46c/" rel="bookmark">
			springboot系列四：集成log4j2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的日志框架 常见的日志框架有log4j、logback和log4j2。三者作者都是Ceki Gülcü。slf4j是The Simple Logging Facade for Java的简称，是log4j、logback和log4j2的统一开发接口封装，作为日志门面，很大程度上提高了易用性和可维护性。最早为log4j（Log for Java），再后来基于log4j开发出一套统一的接口slf4j。并在log4j和slf4j的基础上开发了logback，在性能上也做了优化。log4j2虽然与log4j有很大的相似性，但是log4j2有极大地提升了性能，并有更高的并发性，并支持异步log。
所以，无论在性能上还是并发性上，log4j2都是目前最优的日志框架。
pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; springboot默认使用的日志框架为logback，要想使用log4j2，需要从spring-boot-starter-web中排除对spring-boot-starter-logging依赖。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 然后，再引入log4j2的依赖，内部依赖了slf4j、log4j。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; log4j2配置 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!--日志级别从低到高优先级为：ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF。--&gt; &lt;!--status：设置 log4j2 自身内部的信息输出，可以不设置--&gt; &lt;!--monitorInterval：监视配置文件变化间隔时间，单位秒，Log4j2 能够自动检测配置文件是否修改，同时更新配置--&gt; &lt;configuration monitorInterval="30"&gt; &lt;!--定义属性，在下方方便维护引用--&gt; &lt;properties&gt; &lt;!--当天文件保存目录--&gt; &lt;property name="logDir"&gt;./logs&lt;/property&gt; &lt;!--历史文件保存目录--&gt; &lt;property name="historyLogDir"&gt;./logs/history&lt;/property&gt; &lt;!--如果当天日志文件大于100MB，则存档--&gt; &lt;property name="splitSize"&gt;100MB&lt;/property&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ba7c857aa76f153a1e5ca349b95b46c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3fb88834c2d8b166748cf070bfab48c/" rel="bookmark">
			一本通 C&#43;&#43;语言入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一本通的题 目录 1，入门测试题目
2，计算机输出
3，梯形面积
4，电影票
5，牛吃牧草
7，Hello,World!
8，输出第二个整数 9，对齐输出
10，字符三角形
11，地球人口承载力估计
———————————————————————————————————————————
1，入门测试题目 题目跳转
#include &lt;iostream&gt; using namespace std; int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b; } 2，计算机输出 题目跳转
#include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "Hello World!" &lt;&lt; endl; return 0; } 3，梯形面积 题目跳转
#include &lt;stdio.h&gt; int main() { double s,h,up,down; up=15; down=25; h=2*150/up; printf("s=%.2lf\n",(up+down)*h/2); } 4，电影票 题目跳转
#include &lt;iostream&gt; using namespace std; int main(){ int a,x; cin&gt;&gt;x; a=x*10; cout&lt;&lt;x&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3fb88834c2d8b166748cf070bfab48c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed038899fe0aac2adf71c7459f21477/" rel="bookmark">
			第一次项目总结(瑞吉外卖)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.项目介绍
二.主要内容
三.遇到的新知识
2.1开发流程
2.2代理工具
2.3部署结构
四.心得
一.项目介绍 瑞吉外卖项目分为后台管理端和移动端(用户端).
主要核心技术是:springboot +mybatis-plus +redis +mysql等
视频链接：黑马程序员Java项目实战《瑞吉外卖》，轻松掌握springboot + mybatis plus开发核心技术的真java实战项目_哔哩哔哩_bilibili
是一个非常适合新手学习的springboot单体项目
二.主要内容 1. 后端Controller层返回结果统一封装的R对象
后端的controller层接收完前端的请求后，要返回什么样的结果是需要按情况变化的，但如果每一个controller返回的结果不一样，前端也要用不同的数据类型进行接收。所以，为了避免麻烦定义了一个统一的返回结果类
public class R&lt;T&gt; implements Serializable { private Integer code; //编码：1成功，0和其它数字为失败 private String msg; //错误信息 private T data; //数据 private Map map = new HashMap(); //动态数据 public static &lt;T&gt; R&lt;T&gt; success(T object) { R&lt;T&gt; r = new R&lt;T&gt;(); r.data = object; r.code = 1; return r; } public static &lt;T&gt; R&lt;T&gt; error(String msg) { R r = new R(); r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eed038899fe0aac2adf71c7459f21477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ef609276bb828bffcb075146965847/" rel="bookmark">
			【微信小程序开发】微信小程序集成腾讯位置项目配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 进入官网 按照Hello World流程走 腾讯位置服务官网
1、申请密钥 当然没账号的要先注册一个账号
在我的应用里创建一个新的应用，印象中需要小程序ID，去微信开发者工具里面找到自己的小程序ID填入即可
添加key中勾选勾选WebServiceAPI
2、下载SDK 从官网里下载，我这里下载的是v1.2
3、设置域名 打开微信开发者工具
在查找小程序ID的地方下滑找到服务器域名修改，把request域名添加https://apis.map.qq.com
4、将下载的SDK压缩包放在自己需要的位置 这里我是将解压的文件放在了我项目的utils文件夹中
5、在app.js文件中导入 其实可以只在需要的位置的js文件中导入，我这里直接在app.js中导入，在其他需要的js文件中通过getAPP()来进行获取
// app.js // 按照地址引入核心类，注意是引入.min.js这个文件 var QQMapWX = require('./pages/utils/qqmap-wx-jssdk1.2/qqmap-wx-jssdk.min.js') App({ globalData:{ patrolForm: { checkaddress: "", }, // 实例化API核心类 qqmapsdk: new QQMapWX({ // 这个key就是你刚刚申请下来的key key: '填入你申请下来的key' // 必填 }) }, }) qqmapsdk中要填入自己刚刚申请下来的key
6、在所需的页面的js文件中引入 //我这里实在location/index.js中引用 // getAPP()相当于获得app.js中的数据 const app = getApp() // 实例化API核心类 // 相当于从app.js 中拿到 globalData 中的 qqmapsdk const qqmapsdk = app.globalData.qqmapsdk Page({ //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74ef609276bb828bffcb075146965847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd112f4ffdf0068603897e7ca27eeecd/" rel="bookmark">
			【微信小程序开发】【源码学习】基于微信小程序的地图获取地点信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码来源 微信小程序地图获取地点信息（打卡签到功能为例）-2020-7-26
十分感谢作者能将代码分享出来让我们学习参考，如有侵权联系删除
准备工作 前提是要了解腾讯位置服务获取自己的key并且配置在项目中,可以看这篇文章来进行配置
【微信小程序开发】微信小程序集成腾讯位置项目配置
js源码解析 wxml与wxss的代码这里暂且就不做解析了，主要是功能实现的解析
一、require分析 这里作者一共在Page前require了这些数据，其中
util常量是作者自己写的一些工具方法，主要是对时间的处理app常量是获取app.js中的数据，为了让qqmapsdk来获取app.js中数据来进行核心业务逻辑的实现urlList是作者用工具类配置向后台请求数据的部分代码qqmapsdk是实例化API的核心类 // location_check_in/location_check_in.js const util = require('../../utils/util') // getAPP()相当于获得app.js中的数据 const app = getApp() // 发送wx.request请求 const urlList = require("../../utils/api.js") // 根据实际项目自己配置 // 实例化API核心类 // 相当于从app.js 中拿到 globalData 中的 qqmapsdk const qqmapsdk = app.globalData.qqmapsdk 二、Page页面逻辑分析 这里每一个方法上都给出了注释，我这里就不一一赘述了，主要是每个方法的具体实现
1.data 正常代码阅读逻辑应该是先从生命周期函数onLoad读起，碰到变量后再去data中查看对应的意思，但是对于写文章来说会逻辑过于混乱，所以我们这里直接吧data中的每个变量的含义进行解析
一共有这些数据，下面我们来一一剖析一下
markers，这个变量主要是用于我们后续getAddress中获取当前地址信息的作用，其中的每个数据我都给出了注释解释poi，就是单纯地存储getAddress中的经纬度信息addressName，是获取当前位置的名称time，是获取当前时间，用于前端显示，只显示时分秒timer，适用于存储每秒调用setINterval获取时间这个方法的返回值，用于程序结束后停止运行这个方法，以免浪费空间timer2，与timer同理，不过这个是每20秒重新获取地址信息的setINtervalcanClick，主要用于防止用户多次点击签到，让用户只能签到一次 data: { // markers： 也就是getAddress中的msk // 获取当前地点的 // 地名 title // 经度 longitude // 维度 latitude // 当前所在位置显示的图标路径 iconPath // 图片的宽高？ width height markers: '', // poi: 也就是位置的经纬度(没有给定位置默认为当前位置) poi: { latitude: '', longitude: '' }, // 当前地点的地点名 addressName: '', // time是获取当前时间 只取时分秒 time: '', // 是setInterval的返回值 // 返回的值是当前setInterval的id // 为什么要返回这个值呢？因为有的时候要涉及到clearInterval，clearInterval(id)就能删除相应的setInterval了 // 每秒获取时间的setInterval的id timer: '', // 同上，只不过是每20秒获取一次当前的定位信息的setInterval的id timer2: '', // 用来每个一段时间自动刷新一次定位 // 允许用户点击，防止多次提交 // 在checkIn函数中，代表签到只能进行一次 canClick: true }, 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd112f4ffdf0068603897e7ca27eeecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaea90e3978f3b8aec9fefc2b5bb75a2/" rel="bookmark">
			MinIO分布式存储服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 最近项目中使用到了MinIO的分布式存储系统，记录一下Minio服务的相关概念以及使用方法。
二、基本概念 MinIO 对象存储系统是为海量数据存储、人工智能、大数据分析而设计，基于Apache License v2.0 开源协议的对象存储系统，它完全兼容 Amazon S3 接口，单个对象的最大可达 5TB，适合存储海量图片、视频、日志文件、备份数据和容器/虚拟机镜像等。作为一个开源服务，MinIO 在设计上汲取了Glusterfs的相关经验不教训，系统复杂度上作了大量简化，目前大小只有40+M，部署只需要一个命令即可完成！另外，minio舍弃了传统分布式存储扩容所需要的迁移流程，采用联盟模式添加集群的方式，极大简化了扩容流程；除此之外，minio还具有纠删编码、比特位保护、单写多读（worm)、下面来依次简要解析一下Mioio的特点及具体实现。
Object:存储到Minio的基本对象，如文件字节流，Anything。Bucket:用来存储Object的逻辑空间。每个Bucket之间的数据是相互隔离的。对于客户端而言，就相当于一个存放文件的顶层文件夹。Drive:即存储数据的磁盘，在MinlO启动时，以参数的方式传入。Minio中所有的对象数据都会存储在Drive里。Set:即-组Drive的集合，分布式部署根据集群规模自动划分一个或多个Set，每个Set中的Drive分布在不同位置。一个对象存
储在一个Set上。(For example:{1…64} is divided into 4sets each of size16) 三、特点及实现 1. 底层存储方式
元数据和数据一起存放在磁盘上。元数据以明文形式存放在元数据文件里（xl.json）。假定对象名字为key_name, 它所在桶的名字是bucket_name, disk路径就是/disk，那么存储路径就是：/disk/bucket_name/key_name，windows下C盘存放桶名为test，对象名为minio.exe，其中有两个文件part.1和xl.json。
其中part.1是实际存储数据（单机模式为原生数据，分布式为纠删码分块），xl.json是如下所示的json字符串：
{ //版本号 "version":"1.0.1", //对象的格式，MinIO 内部存储数据主要有两种数据格式:xl 和 fs。单机模式，也就是 底层数据没有做纠删分片存储格式是fs，主要做测试用，实际使用一般都是xl模式 "format":"xl", //对象状态，大小和修改时间 "stat":{ "size":47261688, "modTime":"2020-02-10T07:25:39.17335Z" }, //纠删码相关信息 "erasure":{ // algorithm 指明了此对象采用的是 Klaus Post 实现纠删码， 生成矩阵是范德蒙矩阵。 "algorithm":"klauspost/reedsolomon/vandermonde", // data，parity指明了纠删组中数据盘、校验盘的个数。 "data":3, "parity":3, // blockSize 是对象被分块的大小默认是5M "blockSize":10485760, // index指的是当前磁盘在纠删组中的序号 "index":2, // distribution:每个纠删组的数据盘、校验盘的个数是固定的，但是不同的对象的分片 写入这个纠删组的顺序是不同的。这里记录了分布顺序。 "distribution":[1,3,2,4,5,6], // checksum:下面的字段个数跟此对象的分片数量有关。在旧版本的 MinIO 对象存储 系统， 每一个分片经过 hash 函数计算出的 checksum 会记录在元数据文件的这个位置。 最新版的 MinIO 会把 checksum 直接计入分片文件（即 part.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaea90e3978f3b8aec9fefc2b5bb75a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a94ea1635f8211f72790d192d2d2f3/" rel="bookmark">
			String中StingBuilder和StringBuffer的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先StringBuilder和StringBuffer的出现是因为字符串的拼接，用String拼接字符串也是可以的，但是效率很低，因为每次拼接一个字符串要产生相当于3个对象，如下：
String类中所有对字符串的改变都会产生一个新的对象，不会对字符串本身进行操作，所以str是一个对象，abc是一个对象，拼接好的str又是一个新的对象，所以一共有3个对象，如果写成一个for循环在里边进行字符串的拼接可以想象，效率是很低的，因为创建对象也是需要时间的。
其实在String进行拼接的时候，底层是有一个StringBuilder然后调用append方法来帮我们完成拼接的，如下代码：
这个代码的效果和刚才的String进行拼接是一个效果，只是这个是String底层做的事情，首先StringBuilder先加入两个对象，然后完成拼接后再把这个StringBuilder这个对象变成string类型的。要算上StringBuilder这个对象就有4个对象了，所以在拼接的过程中产生了很多的对象。
就有了StringBuilder这个类，我现在用一个StringBuilder对象，用StringBuilder的append方法进行拼接，这个时候只有一个对象，进行拼接，效率会很高，那为啥append不会产生新的对象：
可以看到源码，它返回的是this，返回的是当前对象。
所以来介绍下StringBuilder这个类，它也是一个不能被继承的类，它里面有的方法String类中是没有的，String类中有的方法它也是没有的，入reverse字符串的逆置，还有 append，所以String和它的区别：
String进行字符串的改变是要产生新的对象的，而StringBuilder不会产生临时对象，如append方法，还有就是这两个类型不能直接进行转换，是要用append方法或者toString方法来完成转换的。
再来看下StringBuffer这个类：
使用这个类创建一个字符串也是没有问题的，和StringBuilder没啥区别，也可以append，
区别就在这里，StringBuilder的构造方法没有sychronized，可以理解为这个东西就是一个锁，在我们上厕所的时候是需要关锁的，如果不关锁，那不是别人也可以进来了吗，sychronized就是这个锁，StringBuffer这个类是用在多线程中的，这里涉及到线程安全问题，大概就是多线程的调度是随机的，不确定的，所以在写多线程代码的时候也就容易产生bug，那么如何减少一些多线程的bug呢，加上一个锁，就说明这个线程正在占用系统的这一块资源，别的线程就进不去，就无法在CPU核心上跑起来，等这个线程结束了，这个锁也就i打开了，此时别的线程就可以进来了（我也没学到加锁呢，这块是自己的理解）
但是我以后在多线程中直接用StringBuffer不完了，也是不可取的，因为在操作系统中，频繁的加锁和解锁，都是需要耗费资源的，所以这几个类都是在某些需要的场景下进行使用的。
这个就是StringBuffer和StringBuilder还有String的区别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329ccbdf92010c469ce66803da050d86/" rel="bookmark">
			1352：【例4-13】奖金
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1352：【例4-13】奖金
时间限制: 1000 ms 内存限制: 65536 KB
【题目描述】
由于无敌的凡凡在2005年世界英俊帅气男总决选中胜出，Yali Company总经理Mr.Z心情好，决定给每位员工发奖金。公司决定以每个人本年在公司的贡献为标准来计算他们得到奖金的多少。
于是Mr.Z下令召开m方会谈。每位参加会谈的代表提出了自己的意见：“我认为员工a的奖金应该比b高！”Mr.Z决定要找出一种奖金方案，满足各位代表的意见，且同时使得总奖金数最少。每位员工奖金最少为100元。
【输入】
第一行两个整数n,m，表示员工总数和代表数；
以下m行，每行2个整数a,b，表示某个代表认为第a号员工奖金应该比第b号员工高。
【输出】
若无法找到合理方案，则输出“Poor Xed”；否则输出一个数表示最少总奖金。
【输入样例】
2 1
1 2
【输出样例】
201
【提示】
【数据规模】
80％的数据满足：n≤1000，m≤2000；
100％的数据满足：n≤10000，m≤20000。
//示例代码 拓扑排序 #include&lt;iostream&gt; using namespace std; int a[10001][301] = { 0 }; // 邻接表，用于存储图的信息 int into[10001]; // 计算每个结点的入度 int ans[10001]; // 记录拓扑排序的结果 int m, n; // n：图的结点数量，m：图的边数 int money; // 统计 Xed 赚取的钱 void init() // 初始化图 { int i, x, y; cin &gt;&gt; n &gt;&gt; m; for (i = 1; i &lt;= m; i++) { cin &gt;&gt; x &gt;&gt; y; a[y][0]++; // 将 y 的出度加一 a[y][a[y][0]] = x; // 将有向边(x,y)加入邻接表中 into[x]++; // 将 x 的入度加一 } } bool topsort() // 拓扑排序 { int t, tot, k, i, j; tot = 0; k = 0; while (tot &lt; n) // 进行拓扑排序，将排序结果记录在数组 ans 中 { t = 0; // t: 当前可以被访问的入度为 0 的结点数量 for (i = 1; i &lt;= n; i++) { if (into[i] == 0) { tot++; t++; money += 100; // 访问一个结点需要花费 100 元 ans[t] = i; // 记录拓扑排序的结果 into[i] = 0xfffffff; // 将入度设置为一个非常大的数，代表该结点已经被访问过 } } if (t == 0) return false; // 如果没有入度为 0 的结点，则说明图中存在环，返回 false money += k * t; k++; // 根据 Xed 的规则计算赚取的钱 for (i = 1; i &lt;= t; i++) for (j = 1; j &lt;= a[ans[i]][0]; j++) into[a[ans[i]][j]]--; // 更新拓扑排序中各个结点的入度 } return true; } int main() { init(); money = 0; if (topsort()) cout &lt;&lt; money &lt;&lt; endl; // 进行拓扑排序并输出 Xed 赚取的钱 else cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/329ccbdf92010c469ce66803da050d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b99afb90e30c6ef908d5686baf54317/" rel="bookmark">
			ES6栈方法和队列方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 JavaScript 这门语言中，栈和队列是非常重要的数据结构，它们可以帮助我们更好地组织和管理数据。我们可以使用 ES6 标准中新增的方法来实现栈和队列的操作。这篇文章将介绍 ES6 中数组的栈方法和队列方法。
栈(Stack) 栈是一种后进先出（Last In First Out）的数据结构，它只允许在栈的顶部进行插入（push）和删除（pop）操作。ES6 提供了与栈有关的方法：push()、pop()、unshift() 和 shift()。
1 push() 方法
push() 方法用于向数组的末尾添加元素，并返回数组的新长度。
示例代码：
let arr = [1, 2, 3]; arr.push(4); console.log(arr); // [1, 2, 3, 4] 2 pop() 方法
pop() 方法用于删除数组的最后一个元素，并返回被删除的元素。
示例代码：
let arr = [1, 2, 3, 4]; let deleted = arr.pop(); console.log(deleted); // 4 console.log(arr); // [1, 2, 3] 3 unshift() 方法
unshift() 方法用于向数组的开头添加元素，并返回数组的新长度。
示例代码：
let arr = [1, 2, 3]; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b99afb90e30c6ef908d5686baf54317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81244f76727fe4ef944e018d35da8e5/" rel="bookmark">
			thinkphp6 JWT报错 ‘“kid“ empty, unable to lookup correct key‘解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JWT简介安装问题先前的代码解决办法修改后的完整代码 JWT简介 JWT全称为Json Web
Token，是一种用于在网络应用之间传递信息的简洁、安全的方式。JWT标准定义了一种简洁的、自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。由于它的简洁性、可扩展性和可传递性，成为当前最流行的跨域身份验证解决方案之一。一般来说，JWT会被用来在客户端和服务端之间传递一些敏感信息，比如用户认证信息、权限信息等等。
安装 thinkphp框架默认不带这个依赖包，需要自己安装
composer require firebase/php-jwt 使用的时候直接use即可
use \Firebase\JWT\JWT; 问题 thinkphp6使用JWT报错 ‘“kid“ empty, unable to lookup correct key‘
这个玩意简直就是一个大坑，弄了一个早上
下面是报错的内容
遇到这个问题我也很无语
最后发现是JWT包的encode 和 decode 和之前的有区别
先前的代码 public function index() { $username = Request::post('username'); $password = Request::post('password'); $user = User::where('username', $username)-&gt;find(); if (!$user) { return json([ 'code' =&gt; 401, 'message' =&gt; '用户名错误，请重试', 'data' =&gt; null ]); } if ($user-&gt;password !== md5($password)) { return json([ 'code' =&gt; 401, 'message' =&gt; '密码错误，请重试', 'data' =&gt; null ]); } // 生成 token $key = '147258369'; // 生成 token 的秘钥 $payload = array( // "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81244f76727fe4ef944e018d35da8e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbe39c22e308b8d044eec15710fe252/" rel="bookmark">
			2023年值得关注的20大网络安全趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着围绕所有企业的数字革命，无论大小，企业、组织甚至政府都依赖计算机化系统来管理他们的日常活动，从而使网络安全成为保护数据免受各种在线攻击或任何未经授权访问的主要目标。
随着数据泄露、勒索软件和黑客攻击的新闻成为常态，技术的不断变化也意味着网络安全趋势的平行转变。
以下是 2023 年的主要网络安全趋势：
1. 汽车黑客的兴起
现在的现代汽车都配备了自动化软件，为驾驶员在巡航控制、发动机正时、门锁、安全气囊和高级驾驶员辅助系统方面创造无缝连接。这些车辆使用蓝牙和 WiFi 技术进行通信，这也使它们容易受到黑客的攻击或威胁。
随着自动驾驶汽车的更多使用，预计到 2023 年，获得对车辆的控制权或使用麦克风进行窃听的情况将会增加。自动驾驶或自动驾驶车辆使用更复杂的机制，需要严格的网络安全措施。
2. 人工智能 (AI) 的潜力 随着人工智能被引入所有细分市场，这种结合机器学习的技术给网络安全带来了巨大的变化。人工智能在构建自动化安全系统、自然语言处理、人脸检测和自动威胁检测方面一直至关重要。
尽管如此，它也被用于开发智能恶意软件和攻击以绕过控制数据的最新安全协议。启用 AI 的威胁检测系统可以预测新的攻击并立即通知管理员任何数据泄露。
3. 移动是新目标 2019 年，网络安全趋势使移动银行恶意软件或攻击大幅增加(50%)，使我们的手持设备成为黑客的潜在目标。
我们所有的照片、金融交易、电子邮件和信息对个人都有更多的威胁。智能手机病毒或恶意软件可能会引起 2023 年网络安全趋势的关注。
4. 云也有潜在的脆弱性 现在越来越多的组织建立在云上，需要持续监控和更新安全措施以防止数据泄露。尽管谷歌或微软等云应用程序在其端仍然配备了良好的安全性，但用户端是错误错误、恶意软件和网络钓鱼攻击的重要来源。
5. 数据泄露：首要目标
数据将继续成为世界各地组织的主要关注点。无论是个人还是组织，保护数字数据是现在的首要目标。您的系统浏览器或软件中的任何小缺陷或错误都是黑客访问个人信息的潜在漏洞。
新的严格措施通用数据保护条例 (GDPR) 从 2018 年 5 月 25 日起开始实施，为欧盟 (EU) 的个人提供数据保护和隐私。同样，加州消费者隐私法 (CCPA) 于 2020 年 1 月 1 日后适用，以维护加州地区的消费者权益。 6. 物联网与 5G 网络：技术与风险的新时代 随着 5G 网络的出现和发展，物联网 (IoT) 将开启一个互联互通的新时代。多台设备之间的这种通信也使它们容易受到外部影响、攻击或未知软件错误的影响。即使是谷歌支持的世界上使用最多的浏览器，Chrome也被发现存在严重的错误。
5G架构在业界相对较新，需要大量的研究来寻找漏洞，使系统免受外部攻击。5G网络的每一步都可能带来大量的网络攻击我们可能不知道。在这里，制造商需要非常严格地构建复杂的 5G 硬件和软件以控制数据泄露。
7. 自动化与集成 随着数据量每天成倍增加，集成自动化以对信息进行更复杂的控制变得尤为重要。现代繁忙的工作需求也迫使专业人员和工程师提供快速、熟练的解决方案，使自动化比以往任何时候都更有价值。
在敏捷过程中纳入安全度量，以在各个方面构建更安全的软件。大型和复杂的 Web 应用程序更难以保护，使自动化和网络安全成为软件开发过程的关键概念。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cbe39c22e308b8d044eec15710fe252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0720c49ada1d303e5e5460c6139704f/" rel="bookmark">
			Java项目中，MySQL数据库中的时间字段用哪个？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.timestamp： 自带时区属性，该类型的字段会随着服务器时区的变化而变化，自动换算成相应时区的时间，存储形式为：yyyy-MM-dd HH:mm:ss，对应的Java类型为java.sql.Timestamp
缺点：只能存储到2038年的时间。
2.datetime： 不具备时区属性，无存储时间限制，存储形式为：yyyy-MM-dd HH:mm:ss，对应的Java类型为：java.util.Date 或者 jdk8的LocalDateTime
3.date： 无存储时间限制，存储形式为：yyyy-MM-dd，对应的Java类型为：java.util.Date 或者 jdk8的LocalDate，一般存储生日建议用该字段。
注： 时间存储不建议用字符串及inthuo bigint类型，因为使用字符串无法使用MySQL中的日期函数，会给查询带来不便，另外字符串存储时间占用空间较大，而使用int或bigint虽然查询效率高，但可读性太差。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0cf7924c0a9c02cd6b5ccc9715b0bd/" rel="bookmark">
			leetcode-024-两两交换链表中的节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目及测试
package pid024; /* 24. 两两交换链表中的节点 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。 你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 1： 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head = [] 输出：[] 示例 3： 输入：head = [1] 输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 */ public class main { public static void main(String[] args) { LinkList a=new LinkList(1); a.addLast(2); a.addLast(3); a.addLast(4); a.addLast(5); a.printList(); test(a.first); LinkList b=new LinkList(1); b.addLast(2); b.addLast(3); b.addLast(4); b.printList(); test(b.first);	/* LinkList c=new LinkList(1); c.addLast(2); c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b0cf7924c0a9c02cd6b5ccc9715b0bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e89cfee865416de7659f68e85012e2/" rel="bookmark">
			JavaWeb-Servlet【内含思维导图】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Servlet思维导图​编辑
1.什么是Servlet
2.Servelt概述
3.Servlet-Quickstart Your Project
3.1创建一个Web项目，导入Servlet依赖
3.1.1 选择Servlet导入依赖 3.1.2 导入Servlet依赖
3.2 在Web项目，定义类，实现Servlet接口，并重写其方法
3.2.1 Servlet 方法介绍
4. Servlet 执行流程
5. Servlet 生命周期
6. Servlet 生命周期
6.1 HttpServlet 原理
6.2 HttpServlet 使用步骤
7.Servlet urlPattern配置
7.1.一个Servlet，可以配置多个 urlPattern
7.2 urlPattern 配置规则
Servlet思维导图 1.什么是Servlet 【摘自百度百科】 Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。
狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。
最早支持Servlet标准的是JavaSoft的Java Web Server，此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。
2.Servelt概述 Servlet：Java提供的一门动态web资源开发技术
Servlet 是JavaEE 规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet
Defines methods that all servlets must implement. A servlet is a small Java program that runs within a Web server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e89cfee865416de7659f68e85012e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5cc405a109d9e4db82d8284b507610a/" rel="bookmark">
			Python基础——9.文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python基础——9.文件 Python基础——9.文件9.0 前言9.1 从文件中读取数据9.1.1 读取整个文件9.1.2 文件路径9.1.3 逐行读取9.1.4 创建一个包含文件各行内容的列表9.1.5 使用文件的内容 9.2 写入文件9.2.1 写入空文件9.2.2 写入多行9.2.3 追加到文件 9.3 使用eval函数自动处理文件内容9.4 小结Python基础——结束 Python基础——9.文件 9.0 前言 至此，你掌握了编写组织有序而易于使用的程序所需的基本技能，该考虑让程序目标更明确、用途更大了。
在本章中，你将学习处理文件，让程序能够快速地分析大量的数据；你将学习错误处理，避免程序在面对意外情形时崩溃；
你将学习异常，它们是Python创建的特殊对象，用于管理程序运行时出现的错误；你还将学习模块json ，它让你能够保存用户数据，以免在程序停止运行后丢失。
学习处理文件和保存数据可让你的程序使用起来更容易：用户将能够选择输入什么样的数据，以及在什么时候输入；
用户使用你的程序做一些工作后，可将程序关闭，以后再接着往下做。学习处理异常可帮助你应对文件不存在的情形，以及处理其他可能导致程序崩溃的问题。
这让你的程序在面对错误的数据时更健壮——不管这些错误数据源自无意的错误，还是源自破坏程序的恶意企图。
你在本章学习的技能可提高程序的适用性、可用性和稳定性。
9.1 从文件中读取数据 文本文件可存储的数据量多得难以置信：天气数据、交通数据、社会经济数据、文学作品等。
每当需要分析或修改存储在文件中的信息时，读取文件都很有用，对数据分析应用程序来说尤其如此。
例如，你可以编写一个这样的程序：读取一个文本文件的内容，重新设置这些数据的格式并将其写入文件，让浏览器能够显示这些内容。
要使用文本文件中的信息，首先需要将信息读取到内存中。为此，你可以一次性读取文件的全部内容，也可以以每次一行的方式逐步读取。
9.1.1 读取整个文件 要读取文件，需要一个包含几行文本的文件。下面首先来创建一个文件，它包含精确到小数点后30位的圆周率值，且在小数点后每10位处都换行：
以下是test.txt的内容,你也应在你的代码目录下新建一个这样的文件：
Use Python read file! Do you know it? It's very useful! 下面的程序打开并读取这个文件，再将其内容显示到屏幕上：
with open('test.txt') as f: contents = f.read() print(contents) 预想的输出结果应该是：
Use Python read file! Do you know it? It's very useful!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5cc405a109d9e4db82d8284b507610a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16f9e533febc0db4c1a6a12681b2a51/" rel="bookmark">
			Ubuntu20.04 无线网卡驱动安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无线网卡Linux 安装 Realtek 无线网卡 确认网卡版本 https://blog.csdn.net/weixin_42298105/article/details/116611448?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-116611448-blog-86761678.235%5Ev32%5Epc_relevant_default_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-116611448-blog-86761678.235%5Ev32%5Epc_relevant_default_base3&amp;utm_relevant_index=6
网络版本
-network UNCLAIMED 即表示没有驱动。
sudo lshw -C network 显示： *-network DISABLED description: Ethernet interface product: RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller vendor: Realtek Semiconductor Co., Ltd. physical id: 0 bus info: pci@0000:09:00.0 logical name: enp9s0 下载地址 https://www.realtek.com/zh/component/zoo/category/network-interface-controllers-10-100-1000m-gigabit-ethernet-usb-3-0-software
需要确认是哪个网卡
出现permission 问题 reference website https://blog.csdn.net/chuansailang4709/article/details/104157206
Network unclaimed on Ubuntu https://askubuntu.com/questions/1052311/network-unclaimed-on-ubuntu
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634a18d5ca88e7cbe4b880d551bc94ba/" rel="bookmark">
			kafka中listener和advertised.listeners的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		listener listener配置是用来绑定BrokerIP+端口地址​的，也就是只有通过绑定的地址才能够访问到该Broker。除了绑定地址之外，还可以配置该监听地址的认证协议，也就是使用该地址连接Broker时需要指定使用何种协议方式进行连接。
如下配置：
listeners: INTERNAL://172.17.0.10:9092,EXTERNAL://172.17.0.10:9094 kafka_listener_security_protocol_map: "INTERNAL:SASL_PLAINTEXT,EXTERNAL:SASL_PLAINTEXT" 连接该Broker的客户端只能通过172.17.0.10:9092​和172.17.0.10:9094​这两个地址访问kafka，并给前一个地址设置listener名称为INTERNAL​，后一个为EXTERNAL​
在kafka_listener_security_protocol_map​配置中设置listener所使用的通信协议，INTERNAL设置的是SASL_PLAINTEXT​，这也是常见的用户名和密码认证协议，EXTERNAL​设置也是该协议。
最终，kafka 客户端连接该kafka broker，需要通过172.17.0.10:9092​或172.17.0.10:9094​地址进行连接，并且都需要使用用户名和密码进行认证。
advertised.listeners 该配置指定Kafka Broker对外公开的网络IP和端口，用于告知客户端如何连接到Kafka Broker。公开的方式是通过存储在zookeeper中进行共享数据的。
如下配置：
listeners: INTERNAL://172.17.0.10:9092,EXTERNAL://172.17.0.10:9094 advertised_listeners: INTERNAL://172.17.0.10:9092,EXTERNAL://公网IP:端口 kafka_listener_security_protocol_map: "INTERNAL:SASL_PLAINTEXT,EXTERNAL:SASL_PLAINTEXT" ​listeners​和kafka_listener_security_protocol_map​的配置和上面讲的一样，而advertised_listeners​的配置和listeners​配置含义基本一致，但是它会保存在zookeeper中/brokers/ids/0​的endpoints里。
... "endpoints":["INTERNAL://172.17.0.10:9092","EXTERNAL://172.17.0.10:9094"] ... kafka客户端连接kafka broker时，会先获取所有brokers的元数据信息，获取到endpoints的信息，然后再通过其中的endpint进行对broker进行连接操作。
问题来了，我都知道了kafka broker的IP地址+端口了，为什么还需要advertised.listeners?
在需要代理才能连接kafka broker时，在这种场景时，需要将advertised.listeners​设置为代理的地址。
在公有云场景下部署kafka集群，公网IP不是在本节点网卡上的，所以无法通过listener进行绑定，所以只能通过0.0.0.0进行绑定。但是在集群外部时，kafka客户端进行连接，它是需要有能力访问kafka的每一个broker节点的，所以需要在advertised.listeners中配置公网IP，并存储在zookeeper中，这样kafka客户端就能拿到所有broker节点的公网IP并进行访问。
内外网分流 在公有云场景下，我们希望在集群内部客户端访问时不需要认证，而外部客户端访问时需要走认证加密访问。配置如下：
listeners: INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9094 advertised_listeners: INTERNAL://内网IP:9092,EXTERNAL://公网IP:9094 kafka_listener_security_protocol_map: "INTERNAL:PLAINTEXT,EXTERNAL:SASL_PLAINTEXT" listeners都设置成对0.0.0.0进行监听也就是监听所有的网卡，但它们的端口不同，9092端口使用PLAINTEXT协议，而9094端口走的是SASL_PLAINTEXT协议
advertised_listeners，内网IP使用PLAINTEXT协议，公网IP使用SASL_PLAINTEXT协议。
当内网客户端访问时，会先获取到所有brokers的advertised_listeners信息，然后通过PLAINTEXT协议走内网IP访问kafka集群。
当公网客户端访问时，会先获取到所有brokers的advertised_listeners信息，然后通过SASL_PLAINTEXT走公网IP进行访问。
‍
参考链接 https://www.finclip.com/news/f/30226.htmlhttps://juejin.cn/post/6893410969611927566 欢迎关注，互相学习，共同进步~ 我的个人博客
公众号：编程黑洞
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a51aed3aaca1a09d020e8d1809bcfbc8/" rel="bookmark">
			wget 安装报错 cannot verify dl.photoprism.app‘s certificate, issued by ‘/C=US/O=Let‘s Encrypt/CN=R3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 wget安装出现问题 cannot verify dl.photoprism.app's certificate, issued by ‘/C=US/O=Let's Encrypt/CN=R3’: Issued certificate has expired. To connect to dl.photoprism.app insecurely, use `--no-check-certificate'. 解决 wget 加上 --no-check-certificate 跳过认证 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4eaa866be817534e7a0ab9f1726a956/" rel="bookmark">
			Elasticsearch的倒排索引理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch的倒排索引
1、把原文档进行分词，并找出单词所在文档编号 2、分词后的单词，在不同文档中出现的次数(TF)
3、分词后的单词，在不同文档中出的次数(TF)、位置(POS)
4、名词解释
单词ID：记录每个单词的单词编号
单词：对应的单词
文档频率：代表文档集合中有多少个文档包含某个单词
倒排列表：包含单词ID及其它必要的信息
DOicID：单词出现的文档id
TF：单词在某个文档中出现的次数
POS：单词在文档中出现的位置
5、综合说明
以单词"大飞哥"为例，其单词编号为6，文档频率为2，代表整个文档集合中有2个文档包含这个单词。
对应的倒排列表为{(3,1,&lt;3&gt;)，(4,1,&lt;3&gt;)}，含义是在文档3、文档4中出现过这个单词，在每个文档中出现过1次。单词"大飞哥"在文档3的POS是3，即文档的第3个单词是"大飞哥"。在文档4的POS是3，即文档的第3个单词是"大飞哥"。
这个倒排索引已经是一个非常完备的索引系统，实际搜索系统的索引结构基本如此
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050b95cbdd85a08ce71f4f8744157e0e/" rel="bookmark">
			org.apache.poi 设置 Excel 单元格颜色 RGB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景说明 在使用 org.apache.poi 导出 Excel 时，需要设置部分单元格的颜色。
可以使用方法：org.apache.poi.ss.usermodel.CellStyle.setFillForegroundColor() 和 org.apache.poi.ss.usermodel.CellStyle.setFillPattern() 来设置单元格的颜色和填充模式。
示例代码如下：
package com.miracle.excel; import java.io.FileOutputStream; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.CellStyle; import org.apache.poi.ss.usermodel.FillPatternType; import org.apache.poi.ss.usermodel.IndexedColors; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import org.apache.poi.xssf.usermodel.XSSFWorkbook; public class SetCellBackgroundColorExample { public static void main(String[] args) throws Exception { Workbook workbook = new XSSFWorkbook(); //创建Workbook对象 Sheet sheet = workbook.createSheet("Sheet1"); //创建Sheet对象 Row row = sheet.createRow(0); //创建行对象 CellStyle style = workbook.createCellStyle(); //创建样式对象 Cell cell = row.createCell(0); //创建单元格 //设置样式的背景颜色为黄色 style.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/050b95cbdd85a08ce71f4f8744157e0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/344412c3f4e62710fd820c9827366a7e/" rel="bookmark">
			诛仙422单机版局域网联机方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍如何在局域网实现诛仙422单机版联机的方法。我在网上找了两天，没有一篇文章详细介绍如何实现。现在我把我的研究经验分享给大家。亲测可用。
大家需要做的准备：一台安装了VMware Workstation并挂载422服务器的电脑，一个路由器，连接在该路由器上的N台电脑。
下面是详细操作步骤。
一、关闭所有电脑的防火墙。对于现在的玩家来说这个应该很简单，如果实在不会，可以参考这个网址：怎么关闭防火墙-百度经验。
二、设置虚拟机，这些操作只在用作服务器的电脑上进行。
1、打算用作服务器的电脑安装VMware，创建完422虚拟机之后点击编辑。
2、点击虚拟网络编辑器，然后全部编辑成我画红框的样子。 3、点击主界面的网络适配器，选择桥接模式。
4、在服务器网络连接里边进行如下设置。
三、设置路由器。从浏览器登录路由器，将LAN IP改为192.168.200.1。这个步骤一定要在步骤四前完成，否则可能导致无法进入路由器。如果有问题可以参考这个链接:m.bilibili.com/video/BV1w5411878p
四、修改所有电脑的IP地址。因为诛仙服务器的IP是192.168.200.100。所以所有电脑都必须和他在一个网段。所有画红框的地方都设置为和我一样。蓝框设置为2-255中除了100以外的任何值。
五，启动服务器。打开所有电脑客户端里边的E:\诛仙\诛仙422一键端\客户端\诛仙\element中的elementclient.exe就可以联机开始游戏了。注意，如果你使用了控制台，请不要用修改过的elementclient.exe开始游戏，因为这样进不去。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dab0d2d75c568646b56e0a27fb6bf03/" rel="bookmark">
			mybatis缓存详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis的缓存 mybatis的一级缓存是Session级别的缓存。一级缓存的作用域默认是一个SqlSession。Mybatis默认开启一级缓存。
在同一个SqlSession中，执行相同的查询SQL，第一次会去数据库进行查询，并把对象放入缓存中，第二次以后是直接去缓存中取。当执行SQL查询中间发生了事务提交的操作，都会把当前SqlSession的缓存清空。
两条SQL的下列五个值相同，即可以认为是相同的SQL。
StatementId+Offset+Limit+Sql+Params CacheKey cacheKey = new CacheKey(); //MappedStatement的id // id 就是Sql语句的所在位置 包名 + 类名 + SQL名称 cacheKey.update(ms.getId()); // offset 就是 0 cacheKey.update(rowBounds.getOffset()); // limit 就是 Integer.MAXVALUE cacheKey.update(rowBounds.getLimit()); // 具体的SQL语句 cacheKey.update(boundSql.getSql()); //后面是update了sql中带的参数 cacheKey.update(value); ... 如果以上的sqlSession与sql都是同一个，那么在第二次查询的时候就会是一级缓存，而不是执行数据库查询
具体的实现如下
@Test //	@Transactional public void testMybatis2(){ SqlSession sqlSession = factory.openSession(); SysQuartzJobLogMapper sysQuartzJobLogMapper1 = sqlSession.getMapper(SysQuartzJobLogMapper.class); SysQuartzJobLogMapper sysQuartzJobLogMapper2 = sqlSession.getMapper(SysQuartzJobLogMapper.class); List&lt;Map&lt;String, Object&gt;&gt; jobLogsById = sysQuartzJobLogMapper1.getJobLogsById(new Page&lt;&gt;(1, 10), "23dedbb5-af24-11ec-a42d-0894ef72d9c4"); System.out.println(jobLogsById.size() + "==&gt;" + jobLogsById); /*try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dab0d2d75c568646b56e0a27fb6bf03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6c3f5829f4b0ca5ca2db65afffc93e/" rel="bookmark">
			2021-06-02 Multisim 14.0 74LS160异步21进制74LS161组成61进制160与161的区别154显示193加减
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 74ls160是十进制计数器，也就是说它只能记十个数从0000-1001（0-9）到9之后再来时钟就回到0，首先是clk，这是时钟。之后是rco，这是输出，MR是复位低电频有效（图上接线前面花圈的都是低电平有效）load是置数信号，当他为低电平时，在始终作用下读入D0到D3。为了使161正常工作ENP和ENT接1另外D0到D3是置数端Q0到Q3是输出端。 160与161的区别下图可以看到160只显示到9因为是十进制，161显示到F因为是二进制.。
74LS161的引脚排列和逻辑功能如图1所示。各引出端的逻辑功能如下。1脚为清零端/RD，低电平有效。2脚为时钟脉冲输入端CP，上升沿有效（CP↑）。3~6脚为数据输入端A0~A3，可预置任意四位二进制数。7脚和10脚分别为计数控制端EP和ET，当其中有一脚为低电平时计数器保持状态不变，当均为高电平时为计数状态。9脚为同步并行置数控制端/LD，低电平有效。11~14脚为数据输出端QQ30~。15脚为进位输出端RCO，高电平有效。74LS161可编程度数器的真值表如下。
表 74LS161可编程度数器的真值表
缘由74ls161设计120进制计数器-其他-CSDN问答 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6710d0b03b7c19ef6f69ccdbb0b9732/" rel="bookmark">
			Redis实现优惠券秒杀业务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.优惠券秒杀业务 优惠券分为两种，一种是普通优惠券，优惠力度较小，另一种是秒杀优惠券，秒杀优惠券优惠力度大，但是数量有限并且限定时间抢购。用户购买优惠券时首先会看优惠券是否有库存，如果有还会判断优惠券是否开始抢购。当用户抢购时，就会生成订单并保存到order表中，而订单表如果使用数据库自增ID就会存在一些问题：
id的规律性太明显
受单表数据量的限制
场景分析一：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。
场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 所以我们需要保证id的唯一性解决办法是使用全局唯一Id
1.1全局唯一Id 全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：
生成Id：为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：
组成部分：符号位：1bit，永远为0
时间戳：31bit，以秒为单位，可以使用69年
序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID
实现： package com.example.utils; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.stereotype.Component; import java.time.LocalDateTime; import java.time.ZoneOffset; import java.time.format.DateTimeFormatter; /** * 全局id生成器 */ @Component public class RedisIdWorker { /** * 开始时间戳 */ private static final long BEGIN_TIMESTAMP = 1640995200L; /** * 序列号的位数 */ private static final int COUNT_BITS = 32; private StringRedisTemplate stringRedisTemplate; public RedisIdWorker(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } public long nextId(String keyPrefix) { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6710d0b03b7c19ef6f69ccdbb0b9732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c1b66ec9cc7a12ec3afc34d7f90d7f4/" rel="bookmark">
			SpringBoot实现导出Excel功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题背景 需求要做一个导出excel的功能
2 前言 本篇着重阐述后端怎么实现，前端实现的部分只会粗略阐述。该实现方案是经过生产环境考验的，不是那些拿来练手的小demo。本文阐述的方案可以借鉴用来做毕设或者加到自己玩的项目中去。再次声明，本文是百万级数据量的企业级解决方案，不是学校里面的毕设或者自己搭环境玩玩的小demo。客户不会去一页一页地点击导出，本文阐述的是一键导出几千行甚至上万行的数据。如果本文与你了解到的方案有出入可以在评论区交流，像那种导出几行或十来行的方案就不要说了。有读者在评论里提问“请教百万行能撑住吗？”笔者没有去验证，有兴趣或者有疑问的读者可以去验证下，本文的解决方案是导出几千或上万行数据。本文也只是想介绍电商生产环境中真实的需求以及真实的解决方案，如果要导出百万行，那就只能采用异步方式去进行导出了，文末有提供思路。 3 实现思路 后端查询要导出的数据，此处简称data使用阿里的EasyExcel组件将data写到HttpServletResponse里面，返回指定的响应头、响应内容的类型、字符编码。响应出去的数据是二进制数据，此处简称bytes数据前端使用前端框架提供的方法，将 bytes数据转成blob，然后生成下载地址，然后进行下载 4 后端实现 要引入阿里的EasyExcel依赖，此处不赘述
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.1.7&lt;/version&gt; &lt;/dependency&gt; 下面是excel文件要保存的信息，需要指定列头
@Data public class UserInfoVO { @ExcelProperty(value = "用户ID",index = 0) private Long id; @ExcelProperty(value = "用户姓名",index = 1) private String username; @ExcelProperty(value = "性别",index = 2) private String sex; } 导出的伪代码如下：
@PostMapping("/xx/xxx/xxx") public void export(HttpServletResponse reponse) { // 设置响应头等 response.setHeader("Content-Disposition", "attachment;filename=" + "文件名(随便定义).xlsx"); response.setContentType("application/vnd.ms-excel"); response.setCharacterEncoding("UTF-8"); // 查数据，假如要导出UserInfo的列表信息 List&lt;UserInfoVO&gt; data = selectData(); // 导出数据 EasyExcel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c1b66ec9cc7a12ec3afc34d7f90d7f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ece4121c1c9a1f0b8addaa11ceb8fd4/" rel="bookmark">
			怎么看显存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显存就是显示内存VRAM
命令行符输入dxdiag，有框出来点否。
然后找到如下数据，可以看到我的上古老卡，只有2G的显存，如果用来跑AI那是很难的了。（某教程提出，显存至少要4G以上，用用20系的显卡）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ade4e56d3d5b985e04c33e7b15b3de05/" rel="bookmark">
			PostgreSQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 安装 我使用的操作系统为Ubuntu。
安装命令：
sudo apt-get update
sudo apt-get install postgresql postgresql-client
进入postgres：
sudo -i -u postgres
psql
退出命令：
\q
PostgreSQL启动服务等：
sudo /etc/init.d/postgresql start # 开启
sudo /etc/init.d/postgresql stop # 关闭
sudo /etc/init.d/postgresql restart # 重启
安装pgAdmin4.
首先安装公钥 curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key add
更新源 sudo sh -c ‘echo “deb [https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/ ( l s b r e l e a s e ] ( h t t p s : / / f t p .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ade4e56d3d5b985e04c33e7b15b3de05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a680b3766b8b468c5a05919c8727d0/" rel="bookmark">
			Git安装与卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git下载 官网：https://git-scm.com/downloads
点击官网链接，跳转到官网，选择对应操作系统
根据操作系统位数选择相应版本下载安装包
淘宝镜像：http://npm.taobao.org/mirrors/git-for-windows/
点击链接，下载最新年份的Git稳定版本
在官网下载的速度非常慢，可以选择镜像源
安装 1、下载完成后，双击安装包
2、安装许可声明
点击next
3、选择安装路径
选择自己的那幢路径，点击next
4、选择安装组件
上图红框内的选项是默认勾选的，建议不要动。绿色框表示是否在桌面创建快捷方式。橙色框是检查Git是否有Windows更新和是否在Windows终端使用Git Bash配置文件。这里可以根据需要自行选择
点击“Next”按钮进入下图界面：
5、选择开始菜单页
在开始菜单中的名字，这里默认即可，点击“Next”按钮进入下图界面：
6、选择Git文件默认的编辑器
这里默认即可，点击“Next”按钮进入下图界面：
7、默认分支名
这里默认即可，点击“Next”按钮进入下图界面：
8、选择path环境
第一种配置是“仅从Git Bash使用Git”。即只能在Git Bash中使用Git，这将不能通过第三方软件使用。
第二种配置是“从命令行以及第三方软件进行Git”。即可以使用第三方软件对Git进行操作
第三种配置是“从命令提示符使用Git和可选的Unix工具”。
推荐第二种配置，点击“Next”按钮继续到下图的界面：
9、选择SSH的绑定方式
第一种是内置的SSH
第二种是外部的SSH
这里默认即可，点击“Next”按钮进入下图界面：
10、选择HTTPS后端传输
第一个选项是“使用 OpenSSL 库”。服务器证书将使用ca-bundle.crt文件进行验证。这也是我们常用的选项。
第二个选项是“使用本地 Windows 安全通道库”。服务器证书将使用Windows证书存储验证。此选项还允许您使用公司的内部根CA证书，例如通过Active Directory Domain Services 。
我使用默认选项第一项，点击“Next”按钮继续到下图的界面：
11、配置行尾符号转换
第一个选项是“签出Windows风格，提交Unix风格的行尾”。签出文本文件时，Git会将LF转换为CRLF。提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Windows上的推荐设置（“ core.autocrlf”设置为“ true”）
第二个选项是“按原样签出，提交Unix样式的行尾”。签出文本文件时，Git不会执行任何转换。 提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Unix上的建议设置（“ core.autocrlf”设置为“ input”）
第三种选项是“按原样签出，按原样提交”。当签出或提交文本文件时，Git不会执行任何转换。不建议跨平台项目选择此选项（“ core.autocrlf”设置为“ false”）
默认即可，点击“Next”按钮继续到下图的界面：
12、配置终端模拟器以与Git Bash一起使用
第一种是linux风格的终端
第二种是Windows的终端
默认即可，点击“Next”按钮继续到下图的界面：
13、git默认行为
默认即可，点击“Next”按钮继续到下图的界面：
14、是否需要配置凭据助手
默认即可，点击“Next”按钮继续到下图的界面：
15、额外的配置
默认启动文件系统缓存，点击“Next”按钮继续到下图的界面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2a680b3766b8b468c5a05919c8727d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d92dd7851e6b8fbaa99357f85989bd/" rel="bookmark">
			ESP32-CAM OTA线上更新固件遇到的分区问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP32-CAM OTA线上更新固件遇到的分区问题 1、分区表什么是分区表 2、OTA更新策略问题：分区表设置问题 3、解决方法1.设置分区表2、编写两个用于OTA更新的程序3、代码4、问题：OTA更新完成之后红灯和白灯一起闪烁 参考资料 对于之前写的文章 ESP32 通过HTTPS进行OTA更新固件（在platform上进行编码）中遇到的分区表的问题，我觉得有必要写一篇文章来解释一下到底怎么回事，我又是怎么解决的。 1、分区表 什么是分区表 分区表是 ESP32 划分内部 flash 闪存的清单，它将 flash 划分为多个不同功能的区域用于其他功能。
分区类型分为两种，分别为 “应用” 和 “数据”。如应用分为Factory程序，OTA程序等，又如数据分为校准数据、文件系统数据、参数存储数据等。
分区表的长度为 0xC00 字节（最多可以保存 95 条分区表条目）。分区表数据后还保存着该表的 MD5 校验和，用于验证分区表的完整性。此外，如果芯片使能了 “安全启动” 功能，则该分区表后还会保存签名信息。
2、OTA更新策略 首次进行OTA升级时，OTA Demo向OTA_0分区烧录目标固件，并在烧录完成后，更新OTA data分区数据并重启。系统重启时获取OTA data分区数据进行计算，决定此后加载OTA_0分区的固件执行（而不是默认的Factory App分区内的固件），从而实现升级。
同理，若某次升级后ESP32已经在执行OTA_0内的固件，此时再升级时OTA Demo就会向OTA_1分区写入目标固件。再次启动后，执行OTA_1分区实现升级。以此类推。
升级的目标固件始终在OTA_0 OTA_1两个分区之间交互烧录，不会影响到出厂时的Factory App固件。
问题：分区表设置问题 我之前写的文章中提到我从AWS S3中OTA更新固件不能烧录到ESP32-CAM分区中，不能更新固件。
返回的错误信息：ESP_ERR_OTA_PARTITION_CONFLICT，原因是分区保持着正确的运行固件，不能更新到这个这个地方。
所以我在想能不能编写两个程序轮流进行OTA更新动作，这样就能解决不能烧录到分区的问题。
3、解决方法 1.设置分区表 为了解决分区表设置问题，我们自己设置一个分区表，再在配置文件中加上就能解决问题。
注意：我是通过PlatformIO进行编程的。
(1). 在项目文件夹中新建partition.csv文件。
(2). 在项目文件夹的platformio.ini文件中添加编译命令。（别忘了保存）
board_build.partitions = partition.csv
(3). 打开partition.csv，定义分区表。
根据自己需要定义分区表，比如我目前想进行OTA更新就需要两个分区（ota_0,ota_1），我就可以要定义连个分区，又比如我写的程序需要的存储空间大，我就要舍弃一个分区(ota_1)来增加另一个分区(ota_0)的大小。
开始定义分区表，我设置了两个分区。
2、编写两个用于OTA更新的程序 我编写的程序是两个闪灯程序，分别为闪白灯和闪红的（ESP32-CAM中有两个板载LED灯），这样就只要修改灯的引脚（红灯33，白灯4），就不用额外编写代码。
注意：红灯和白灯的 digitalWrite中的LOW和HIGH参数是相反的不要忘了更改。
架构图：
将闪红灯程序的.bin文档上传AWS S3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63d92dd7851e6b8fbaa99357f85989bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f1f7f3f67565fa830cf894738c68d3/" rel="bookmark">
			flutter学习之旅 - 自带图标组件和自定义图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面学习的代码差分
import 'package:flutter/material.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: const Text("我的应用 - ICON"), ), body: const MyHomePage(), ), ); } } class MyHomePage extends StatelessWidget { const MyHomePage({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return const Text("你好"); } } 自带的图标 组件: Icon
class MyHomePage extends StatelessWidget { const MyHomePage({Key?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4f1f7f3f67565fa830cf894738c68d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e5ec06ebe6c4ac18ddf5cb47262e2e/" rel="bookmark">
			MATLAB实现PSO-SVM多输入单输出回归预测（粒子群算法优化支持向量机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机 ⛄ 内容介绍 本文涉及一种基于自适应粒子群的最小二乘支持向量机预测方法,该方法根据群体的收敛程度和个体的适应值来调整惯性权重,加快训练速度,利用该算法迭代求解LSSVM中出现的矩阵方程,避免矩阵求逆,节省内存,并求得最优解.该方法可以有效简化训练样本,提高训练速度,且分类精度良好,收敛速度快,有很好的泛化能力.解决了预测时特征维数较高,特征之间存在冗余且样本有限的问题.
⛄ 部分代码 %% 粒子群算法
function [Best_pos,Best_score,curve]=PSO(pop,Max_iter,lb,ub,dim,fobj,Vmax,Vmin)
%% 参数设置
w = 0.9; % 惯性因子
c1 = 2; % 加速常数
c2 = 2; % 加速常数
Dim = dim; % 维数
sizepop = pop; % 粒子群规模
maxiter = Max_iter; % 最大迭代次数
if(max(size(ub)) == 1)
ub = ub.*ones(1,dim);
lb = lb.*ones(1,dim); end
fun = fobj; %适应度函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67e5ec06ebe6c4ac18ddf5cb47262e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d4ed853b127658ff983283e909a60a/" rel="bookmark">
			守护进程Daemon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程组、对话期和控制终端关系 每个会话有且只有一个前台进程组，但会有0个或者多个后台进程组。产生在控制终端上的输入（Input）和信号（Signal）将发送给会话的前台进程组中的所有进程。对于输出（Output）来说，则是在前台和后台共享的，即前台和后台的打印输出都会显示在屏幕上。终端上的连接断开时 (比如网络断开或 Modem 断开)，挂起信号将发送到控制进程(controlling process) 。一个用户登录后创建一个会话。一个会话中只存在一个前台进程组，但可以存在多个后台进程组。第一次登陆后第一个创建的进程是shell，也就是会话的领头进程，该领头进程缺省处于一个前台进程组中并打开一个控制终端可以进行数据的读写。【当在shell里运行一行命令后（不带&amp;）创建一个新的进程组，命令行中如果有多个命令会创建多个进程，这些进程都处于该新建进程组中，shell将该新建的进程组设置为前台进程组并将自己暂时设置为后台进程组。比如sleep 1 | sleep 2 | sleep 3】 进程ID 任何用XShell登陆，只允许一个前台进程和多个后台进程。【即在命令行运行其他进程后，就没法再让bash再对指令作出响应，说明bash被切换为后台进程】
进程除了有PID、PPID，还有组ID PGID，会话ID SID，终端进程组IDTPGID。
[yyq@VM-8-13-centos 2023_04_22_Calculator_TCPSocket]$ sleep 10000 | sleep 20000 | sleep 30000 [yyq@VM-8-13-centos 2023_04_22_Calculator_TCPSocket]$ ps ajx | head -1 &amp;&amp; ps ajx | grep sleep PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 12145 1089 12145 12145 ? -1 S 1001 0:00 sleep 180 15703 1782 1782 15703 pts/6 1782 S+ 1001 0:00 sleep 10000 15703 1783 1782 15703 pts/6 1782 S+ 1001 0:00 sleep 20000 15703 1784 1782 15703 pts/6 1782 S+ 1001 0:00 sleep 30000 12598 1895 1894 12598 pts/5 1894 S+ 1001 0:00 grep --color=auto sleep 11424 11757 11424 1227 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d4ed853b127658ff983283e909a60a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d079d7e056348d4c640524b9f360f38/" rel="bookmark">
			通信移动网络的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 随着移动通信技术的飞速发展，越来越多的移动设备连接到了移动网络。通信移动网络作为现代社会不可或缺的基础设施，对于连接全球各地的人们、提高生活质量以及推动经济社会发展都具有重要意义。本文将重点介绍通信移动网络的基本概念、网络架构以及搭建方法。
二、通信移动网络基本概念 通信移动网络是一种利用无线电波进行通信的网络，它将移动设备（如手机、平板、笔记本等）通过无线通信基站与核心网络相连，实现语音、数据和多媒体等通信服务。通信移动网络的发展经历了从1G、2G、3G、4G到5G甚至6G的演进过程，每一代技术都带来了更高的通信速率和更好的服务质量。在深入了解通信移动网络的搭建方法之前，我们首先需要了解一些与通信移动网络相关的基本概念。
1. 移动通信技术的演进 移动通信技术经历了从1G到6G的发展过程，每一代技术都带来了更高的通信速率和更好的服务质量。
1G（第一代移动通信技术）：主要以模拟信号传输为基础，实现了基本的语音通信功能。2G（第二代移动通信技术）：采用了数字信号传输技术，提供了语音和短信等基本通信服务。主要有GSM、CDMA和PDC等制式。3G（第三代移动通信技术）：引入了宽带数据传输技术，实现了高速数据通信，支持了多媒体业务和移动互联网接入。主要有WCDMA、CDMA2000和TD-SCDMA等制式。4G（第四代移动通信技术）：采用了LTE和LTE-A技术，提供了更高的数据传输速率和更低的时延，使得高清视频、在线游戏和移动互联网应用得到了广泛普及。5G（第五代移动通信技术）：具有超高速率、超低时延和超高连接密度等特点，支持大规模物联网、自动驾驶和远程医疗等创新应用。采用了NR（新无线）技术和毫米波频段等。6G（第六代移动通信技术）：尚处于研究阶段，预计将实现更高的速率、更低的时延和更强的连接能力，支持更高级别的自动驾驶、虚拟现实和智能城市等应用。 2. 无线接入技术 通信移动网络需要利用无线接入技术实现移动设备与基站之间的通信。常见的无线接入技术包括：
4. 网络切换与漫游 在通信移动网络中，为了保证用户在移动过程中可以无缝地维持通信，需要实现网络切换和漫游功能。
以上是通信移动网络的一些基本概念，通过了解这些概念，我们可以更好地理解通信移动网络的工作原理和特点。
FDMA（频分多址）：将频谱划分为多个独立的频道，每个频道分配给一个用户进行通信。TDMA（时分多址）：将时间划分为多个时隙，将不同用户的信号在时间上排列进行传输。CDMA（码分多址）：为每个用户分配一个独立的伪随机码，通过这个伪随机码将用户的信号进行扩频并进行传输。OFDMA（正交 频分多址）：将信号传输的频谱划分为多个子载波，每个子载波上的信号之间正交，可以大大提高频谱利用率。OFDMA是LTE和5G NR等技术采用的无线接入方式。
3. 无线传输技术 无线传输技术是实现移动通信中数据传输的关键技术，包括调制、编码和多天线技术等。
调制技术：将基带信号映射到射频信号上进行传输。常见的调制技术包括QPSK、16QAM、64QAM等。编码技术：对信号进行纠错编码，以提高传输信号的可靠性。常见的编码技术包括卷积编码、Turbo编码和LDPC编码等。多天线技术：通过在基站和移动设备上使用多个天线，可以提高无线信号的传输质量和速率。常见的多天线技术包括MIMO（多输入多输出）和Massive MIMO等。网络切换：当用户从一个基站覆盖区域移动到另一个基站覆盖区域时，需要将通信连接从原基站切换到新基站。网络切换包括硬切换和软切换等。漫游：当用户从一个运营商的网络区域进入另一个运营商的网络区域时，需要实现跨运营商间的通信连接。漫游功能依赖于运营商之间的互联互通和合作。 三、通信移动网络的架构 通信移动网络主要由无线接入网络（RAN）和核心网络（CN）两部分组成。
1. 无线接入网络（RAN） 无线接入网络负责为移动设备提供无线连接服务。它包括一系列无线通信基站和无线接入控制器。无线通信基站负责与移动设备之间的无线信号传输，而无线接入控制器负责管理基站、进行信号调度以及分配无线资源等。
2. 核心网络（CN） 核心网络是通信移动网络的核心部分，负责处理、转发和路由用户的通信数据。核心网络主要包括以下部分：
移动交换中心（MSC）：负责处理语音通信业务，包括呼叫建立、维护和释放等。分组交换中心（GGSN）：负责处理数据通信业务，将用户的数据分组进行路由和转发。数据库服务器：存储用户的相关信息，如位置、账户和计费数据等。 四、通信移动网络的搭建方法 搭建通信移动网络需要考虑以下几个方面：
1. 网络规划与设计 在搭建通信移动网络之前，需要进行详细的网络规划和设计。这包括选择合适的网络架构、频率分配、基站选址和覆盖区域等。
2. 设备安装与部署 根据网络规划，搭建通信移动网络需要安装和部署一系列设
备，包括无线通信基站、无线接入控制器、移动交换中心、分组交换中心和数据库服务器等。在设备安装过程中，需要注意设备之间的互联互通，以确保整个网络的稳定运行。
3. 网络优化与调整 在通信移动网络搭建完成后，需要进行网络优化和调整。这包括对基站的功率、频率和覆盖范围进行调整，以提高网络性能和覆盖效果。此外，还需要对网络进行负荷均衡和信道分配等优化，以确保用户体验。
4. 网络监控与维护 通信移动网络的运行需要进行实时监控和定期维护。网络监控主要包括对基站、无线接入控制器和核心网络设备的运行状态、信号质量等进行实时监测。网络维护则需要定期对设备进行检查、故障排查和更新等，以确保网络的稳定运行。
5. 安全与合规 通信移动网络的搭建和运行需要遵循相关法规和标准，确保网络安全和用户隐私。这包括对设备和网络进行加密保护、防火墙设置、入侵检测和应急响应等措施，以防止网络攻击和数据泄露等安全事件。
五、总结 通信移动网络的搭建涉及多个方面的工作，包括网络规划与设计、设备安装与部署、网络优化与调整、网络监控与维护以及安全与合规等。通过合理规划和有效管理，可以搭建出高效稳定的通信移动网络，为用户提供高质量的通信服务。随着通信技术的不断发展，未来的通信移动网络将更加智能化、高速化和大容量化，为社会发展和人类生活带来更多便利。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de6676073c920405b97abd40ccc60bd/" rel="bookmark">
			测试离线音频转文本模型Whisper.net的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号“dotNET跨平台”中的文章《OpenAI的离线音频转文本模型Whisper的.NET封装项目》介绍了基于.net封装的开源语音辨识Whisper神经网络项目Whisper.net，其GitHub地址见参考文献2。本文基于Whisper.net帮助文档中的示例，测试Whisper.net的基本用法。
创建基于.net6的Winform项目，然后在NuGet包管理器中搜索并安装Whisper.net包，如下图所示。注意，如果搜索Whisper，还会搜到一个名为WhisperNet的包，这个包跟Whisper.net的用法不同，也不能通用，注意不要安装错了。
在测试程序之前，需要下载语言模型文件，可以从参考文献3中下载。根据参考文献1中的介绍，下载了ggml-large.bin、ggml-medium.bin、ggml-small.bin等3个支持中文的语言模型文件，并在测试程序中优先选用ggml-large.bin进行测试。
除了语言模型文件，Whisper.net对音频文件要求比较严格，必须是采样率为16KHz的wav格式的音频文件，具体的文件格式要求参见下面列出的Whisper.net包中WaveParser类中的部分格式检查代码。
byte[] array = new byte[36]; if (waveStream.Read(array, 0, 36) != 36) { throw new CorruptedWaveException("Invalid wave file, the size is too small."); } if (array[0] != 82 || array[1] != 73 || array[2] != 70 || array[3] != 70) { throw new CorruptedWaveException("Invalid wave file RIFF header."); } if (array[8] != 87 || array[9] != 65 || array[10] != 86 || array[11] != 69 || array[12] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5de6676073c920405b97abd40ccc60bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb64ac857d31f19340c1563bafb4dc6b/" rel="bookmark">
			天启词典 5.4 英汉版（Free Edition）发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一款简明易用的英汉、汉英双向速查词典，具有模糊查询和语音朗读功能，支持设置显示字体和历史记录功能。
下载1 下载2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42191ed3915bf681bf1716d74ea7cf38/" rel="bookmark">
			数组的顺序存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组作为一种线性存储结构，对存储的数据通常只做查找和修改操作，因此数组结构的实现使用的是顺序存储结构。
要知道，对数组中存储的数据做插入和删除操作，算法的效率是很差的。
由于数组可以是多维的，而顺序存储结构是一维的，因此数组中数据的存储要制定一个先后次序。通常，数组中数据的存储有两种先后存储方式：
以列序为主（先列后行）：按照行号从小到大的顺序，依次存储每一列的元素以行序为主（先行后序）：按照列号从小到大的顺序，依次存储每一行的元素。 多维数组中，我们最常用的是二维数组。比如说，当二维数组 a[6][6] 按照列序为主的次序顺序存储时，数组在内存中的存储状态如图 1 所示：
图 1 以列序为主的二维数组存储状态
同样，当二维数组 a[6][6] 按照行序为主的次序顺序存储时，数组在内存中的存储状态如图 2 所示：
图 2 以行序为主的二维数组存储状态
C 语言中，多维数组的存储采用的是以行序为主的顺序存储方式。
通过以上内容，我们掌握了将多维数组存储在一维内存空间的方法。那么，后期如何对指定的数据进行查找和修改操作呢？
多维数组查找指定元素 当需要在顺序存储的多维数组中查找某个指定元素时，需知道以下信息：
多维数组的存储方式；多维数组在内存中存放的起始地址；该指定元素在原多维数组的坐标（比如说，二维数组中是通过行标和列标来表明数据元素的具体位置的）；数组中数组的具体类型，即数组中单个数据元素所占内存的大小，通常用字母 L 表示； 根据存储方式的不同，查找目标元素的方式也不同。如果二维数组采用以行序为主的方式，则在二维数组 anm 中查找 aij 存放位置的公式为：
LOC(i,j) = LOC(0,0) + (i*m + j) * L;
其中，LOC(i,j) 为 aij 在内存中的地址，LOC(0,0) 为二维数组在内存中存放的起始位置（也就是 a00 的位置）。
而如果采用以列存储的方式，在 anm 中查找 aij 的方式为：
LOC(i,j) = LOC(0,0) + (i*n + j) * L;
数组定义和运算
① 数组是高级语言一般都支持的数据类型，这里学习数组在计算机内部如何处理，主要是存取，地址计算；
② 从逻辑结构上看，数组可以看成是一般线性表的扩充。
二维数组视作线性表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42191ed3915bf681bf1716d74ea7cf38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bfc6a28ffbb5355d6921dcad0d2706b/" rel="bookmark">
			【QT上位机编写第一步】QT5环境搭建和了解C&#43;&#43;及类的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、QT5的环境搭建？1.1.QT5下载1.2.QT5安装 二、新建一个C++项目和编写第一个C++程序2.1.创建项目 三、C++类的讲解3.1.类的定义和访问3.2.C++类的重载特性、析构函数和构造函数、类的继承、虚函数和纯虚函数 总结 前言 本章节主要讲的是QT的环境搭建、C++语言基础、C++的类的介绍。写这个文档是博主为了工作学习QT上位机所作
提示：以下是本篇文章正文内容，下面案例可供参考
一、QT5的环境搭建？ 1.1.QT5下载 首先是登录qt的网页 添加链接描述
这里选择5.12版本，点击
这里我是用的5.12.9的版本，
这里我用的Windows 系统，直接下载
1.2.QT5安装 首先把我们下载好的qt5软件放到你想放的盘，但是注意路径不能有中文。
然后第二步要断开网络，不然安装时他会叫你去他官网注册邮箱。
最后安装成功，这时是没有软件的快捷方式的这时需要我们点击D:\QT\Tools\QtCreator\bin这里面就有QT的软件（注意博主是安装在D盘的）
二、新建一个C++项目和编写第一个C++程序 2.1.创建项目 第一步是打开QT5软件
然后点击Projects点击New
然后是选择Non-Qt project，在然后是选择Plain C++ Application最后点击Choose
然后跳出一个对话框让你修改项目名称和项目保存路径，此时注意路径和名称不能出现空格或者中文
默认选择qmake点击下一步
然后把32bit和64bit两个都勾选
然后点击下一步是配置项目管理，如果你会用git那就用，不用就选择None，然后点击完成，此时会跳到函数部分
#include &lt;iostream&gt; //调用库文件 对比 C语言的 &lt;stdio.h&gt; using namespace std; //申请一个内存空间 int main(void) { int num = 100; //定义一个整形数组 /* 1. cout() 函数是输出打印函数 对比 C语言的printf 2.&lt;&lt; 发送数据流 例如 cout &lt;&lt; "Hwllow World"; 打印 Hwllow World 3.endl 是换行意思 对比 c语言的\n */ cout &lt;&lt; num &lt;&lt; endl &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bfc6a28ffbb5355d6921dcad0d2706b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/279c8dbcf14448e34543f9d19b8d0ede/" rel="bookmark">
			微信小程序开发-云数据库导出JSON、CSV格式处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 从微信云开发控制台导出数据库文件有两种格式：JSON和CSV。
CSV格式在导出时要填写字段名，比较麻烦。
而且在导入数据时，CSV格式仅支持导入字符串（string）和数字格式（number），对于嵌套的数组数据则视为字符串导入，所以结构化数据就不太好用CSV格式了。但如果是为了导出Excel格式，方便修改数据，可以导出CSV格式，office、WPS的Excel可以直接打开，但是若含有结构化嵌套数据，导入时要转化为JSON才行。
JSON格式可以直接导出，但也存在一个问题，微信云数据库导出的JSON文件不是常规的JSON格式，使用逗号分割两条记录，而且全部用中括号括起来。
而是两条记录之间采用“行分隔”的方式，这种方式在目前主流的线上JSON格式化网站和小工具，都无法处理，要在没有格式化的状态下编辑数据，将是噩梦般的操作。
少量数据可以手动添加逗号，数据量大了就难搞了!
怎样才能方便的实现微信小程序云数据库导出、编辑、上传呢？
解决办法 一、导出JSON格式 1.JSON文件格式化 方便地直接导出，使用Notepad++软件打开，该软件有个非常好的插件管理功能。
可以安装JSON Viewer，实现JSON文件的格式化。
正如前面所说，微信小程序云数据库导出的JSON采用“行分隔”的方式，直接格式化会出错！
有个方便的方法添加逗号，不用一行行去添加。Notepad++有一个列块模式，按ALT键，鼠标点选一列，就可以在该列全部填加逗号了。
最后添加上中括号，就可以格式化了，格式化后再编辑数据，就方便多了。
2.JSON文件转换成Excel 如果觉得上面的JSON文件格式化后编辑数据仍然没有Excel方便，可以直接导出CSV格式用Excel打开，或者将JSON文件使用Python转换成Excel文件，这样有一个好处是可以将嵌套的JSON数据提取出来，在Excel中平展开，以便更好的编辑。
这里先踩了一个坑，我使用Jupyter Notebook (Anaconda3)，Python的JSON库处理小程序云数据库的Json文件，发现还是因为没有逗号间隔的原因，不能读取成功。
使用Python的pandas库处理小程序云数据库的Json文件，pandas 能够读取和写入行分隔的 json 文件，这些文件在使用 Hadoop 或 Spark 的数据处理管道中很常见，读取成功。这里必须要使用lines参数为True，即使用行分隔的方式。
其中answers字段存放的是数组，并嵌套了对象。
若要将其打开，就使用pandas的json_normalize函数：将字典或字典列表种半结构化数据规范化为一个平面表。
并可以持续的展开到最底下一层，然后合并各个字段。
最后导出为Excel表。
result = pd.concat([data_json,answers_json0,answers_json1,answers_json2,answers_json3], axis=1) result.to_excel("1111.xlsx", sheet_name="Sheet1") 点击下面链接，可以下载上述完整代码：
JSON to Excel Python源文件及模拟数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6244df80439015752b5b7174c428aae/" rel="bookmark">
			心血管疾病预测--逻辑回归实现二分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现效果 实现心血管疾病的预测准确率70%以上
二、数据集介绍 数据共计70000条，其中心血管疾病患者人数为34979，未患病人数为35021。数据特征属性12个分别为如下所示:生理指标(性别、年龄、体重、身高等)、 医疗检测指标(血压、血糖、胆固醇水平等)和患者提供的主观信息(吸烟、饮酒、运动等)：
age年龄
gender性别 1女性， 2 男性
height身高
weight 体重
ap_hi收缩压
ap_lo 舒张压
cholesterol胆固醇 1：正常； 2：高于正常； 3：远高于正常
gluc 葡萄糖，1：正常； 2：高于正常； 3：远高于正常
smoke 病人是否吸烟 alco 酒精摄入量
active 体育活动
cardio 有无心血管疾病,0:无；1：有
数据来源;http://idatascience.cn/
三、实现步骤 3.1 数据导入与分析 # 导入需要的工具包 import pandas as pd # data processing import numpy as np import matplotlib.pyplot as plt #matplotlib inline import seaborn as sns # plot from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6244df80439015752b5b7174c428aae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73be907e3705c4039a069b0dc59cc87/" rel="bookmark">
			latex排版参考文献引用，bibtex引用不出来的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献引用有两种方法。一种是直接bibitem，一条条放到latex中；另一种是bibtex，建立自己的数据库。这是后面参考文献来源的方法，具体在正文中引用，方法都一样。
第一种，bibitem（直接编译，点绿色三角） 好处是，简单，基本不会出现问题；
坏处是一条条粘贴，比较费时间精力；除此之外，好像最多只能引用99条，有数量限制。
方法是：
\begin{thebibliography}{00} \bibitem[Parente et al.(2020)]{ESG1} %item1 Parente, Manuel, Gonçalo Figueira, Pedro Amorim, and Alexandra Marques. (2020). ``Production scheduling in the context of Industry 4.0: review and trends." International Journal of Production Research 58 (17):5401-5431. doi: https://doi.org/10.1080/00207543.2020.1718794. %item2,...,itemn \end{thebibliography} 第二种，bibtex（非常推荐，先运行工具参考文献，再点绿三角生成正文） 好处是：建立了自己的数据库，后续操作起来方便，效率很高；
坏处是：可能会出现问题，我先前就是卡在这一步，正文中出现的是[?]。有人可能会说一条条bibtex导出来粘贴到.bib中比较麻烦，但其实zotero以及endnote都可以直接导出.bib文件，不必再一条条谷歌搜索粘贴bibtex了。
下面说下endnote怎么导出bib文件：
（1）首先选一个bibtex样式
一般都会自带这个样式。如果确实没有bibtex样式，那需要去官网下载。
（2）选中我们所需要的文献，然后导出，风格一定要选择bibtex，然后勾选“导出选择的文献”。至此就已经导出成功了。
细心的人会发现上面保存类型是txt，其实没关系，我们可以改为bib，就可以。
我还发现一个网址，对于我们识别各种参考文献格式很有用，Instant + Automatic Citation &amp; Bibliography Generator | Bibcitation
是艾斯维尔旗下的。我们可以在检索框里选择任意一种格式，然后观察效果。当我们想查看格式效果时可以备用。 上面提到bibtex出现问题，我大半天都没解决，在网上没找到解决办法。后来，才知道少了一步，关闭pdf预览——菜单栏：工具&gt;&gt;参考文献——编译，就成功了。本质是没建立bib数据库和tex的联系。
再来说一下步骤：
1.在.tex文件同文件夹下建立.bib文件，建立的方法是，新建个.txt，再把txt后缀改成.bib就可以了，后续仍然可以用记事本打开。
当然，也可以不放在同一文件夹，但是要备注好位置。
2.或者在谷歌学术里点bibtex引用，一篇篇粘贴；或者用zotero直接导出（网上说Mendeley也能直接导出来）；
3.在tex中写入以下语句：
（1）一开始需要调用这个包：
\usepackage[backref]{hyperref} （2）参考文献部分写入以下语句： \bibliographystyle{elsarticle-harv} %elsarticle-harv可以改，我这里用，是因为投稿它 \bibliography{refs} %refs是我第一步建立同文件夹下的refs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a73be907e3705c4039a069b0dc59cc87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad6bd9214604d57b02038e27f91c29d/" rel="bookmark">
			Java_统计字符串出现的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class CountCharOccurrence { /** 1. 输入要统计的字符串str。 2. 定义一个长度为256的数组count,每个元素初始化为0。 3. 遍历字符串str的每个字符。 4. 获取当前字符c,然后count[c]对应该字符的出现次数,加1。 5. count[c]的值最终就是该字符在字符串中出现的次数。 6. 最后统计并输出每个字符出现的次数。 时间复杂度为O(n),n为字符串长度。空间复杂度为O(1)。 */ public static void main(String[] args) { // 输入要统计的字符串 String str = "abaccdeff"; System.out.println("输入的字符串为:" + str); // 创建一个长度为256的数组,对应ASCII表中的字符个数 int[] count = new int[256]; // 遍历输入的字符串 for (int i = 0; i &lt; str.length(); i++) { // 获取当前字符 char c = str.charAt(i); // chars[c]对应c字符的出现次数,加1 count[c]++; } // 统计并输出每个字符出现的次数 for (int i = 0; i &lt; 256; i++) { if (count[i] &gt; 0) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fad6bd9214604d57b02038e27f91c29d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9970fc3cbe67cbb3bb9926390d55966/" rel="bookmark">
			h3c路由器和三层交换机之间连接配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H3C路由器和三层交换机之间的连接可以通过物理线缆连接，常用的连接方式有以下两种：
直接连接：将H3C路由器和三层交换机之间的物理接口通过网线直接连接。
间接连接：将H3C路由器和三层交换机之间的物理接口通过交换机连接。
接下来，我将为您介绍如何在H3C路由器和三层交换机之间进行配置：
直接连接方式：
在H3C路由器上配置IP地址和子网掩码，例如：
[H3C] interface GigabitEthernet0/0/1 [H3C-GigabitEthernet0/0/1] ip address 192.168.1.1 255.255.255.0 在三层交换机上配置IP地址和子网掩码，例如：
[SW] interface GigabitEthernet0/0/1 [SW-GigabitEthernet0/0/1] ip address 192.168.1.2 255.255.255.0 配置路由，使得H3C路由器和三层交换机之间可以互相通信，例如：
[H3C] ip route-static 0.0.0.0 0.0.0.0 192.168.1.2 [SW] ip route-static 0.0.0.0 0.0.0.0 192.168.1.1 间接连接方式：
在H3C路由器上配置IP地址和子网掩码，例如：
[H3C] interface GigabitEthernet0/0/1 [H3C-GigabitEthernet0/0/1] ip address 192.168.1.1 255.255.255.0 在三层交换机上配置IP地址和子网掩码，并将其连接到H3C路由器所在的网段上，例如：
[SW] interface GigabitEthernet0/0/1 [SW-GigabitEthernet0/0/1] ip address 192.168.1.2 255.255.255.0 [SW-GigabitEthernet0/0/1] port link-type trunk [SW-GigabitEthernet0/0/1] port trunk allow-pass vlan 1 在另一个接口上配置IP地址和子网掩码，并将其与目标网段连接，例如：
[SW] interface GigabitEthernet0/0/2 [SW-GigabitEthernet0/0/2] ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9970fc3cbe67cbb3bb9926390d55966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f532cefad8ffa13a4add0cea2635a1/" rel="bookmark">
			keras和tensorflow的匹配版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		keras和tensorflow版本之间的匹配是非常重要的，因为它们之间的兼容性可能存在一些问题。以下是一些keras和tensorflow之间的匹配版本：
tensorflow 1.x：keras是tensorflow 1.x的一部分，可以直接与tensorflow 1.x一起使用。具体来说，对于tensorflow 1.13 – 1.15，keras的版本应该在2.2.4 – 2.3.1之间。
tensorflow 2.0 – 2.4: tensorflow 2.0及以上版本的keras已经被作为最初的api。keras的2.3.0 版本及更高版本均支持tensorflow 2.0 – 2.4。
keras 2.4.0 及以上版本兼容 tensorflow 2.4 版本。
tensorflow 2.5版本需要使用keras的版本为2.5.0 或者更高。
总的来说，想要确保keras和tensorflow之间的兼容性，建议通过将两个框架安装到相同的虚拟环境中，并且使用支持兼容的版本。是否相兼的版本通常可以在官方文档或github上获得。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01499947c98db61318b776951c031fcb/" rel="bookmark">
			Ubuntu 22.04环境下安装labellmg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 22.04环境下安装labellmg 1. 安装Python和pip 可以先看一下当前环境中有没有它们
python3 --version &amp;&amp; pip3 --version 如果提示没有找到，则可以使用以下命令安装
sudo apt-get update sudo apt-get install python3 python3-pip 2. 安装Pyqt5 Labellmg需要Pyqt5库才能运行，可用以下命令安装
sudo apt-get install python3-pyqt5 3. 克隆Labellmg储存库 可以新建一个software目录用于存放自己安装的各种软件，然后在该目录下克隆
mkdir software cd software git clone https://github.com/tzutalin/labelImg.git 4. 安装Labellmg的依赖项 进入labellmg目录
安装PyQt5工具
从清华源安装pyqt5
cd labellmg sudo apt-get install pyqt5-dev-tools pip3 install pyqt5==5.10 -i https://pypi.tuna.tsinghua.edu.cn/simple 如果安装pyqt5时出现：
则重新安装sip
pip3 uninstall sip pip3 install sip 然后安装lxml
pip3 install lxml 至此安装成功，可以在此文件夹下使用此命令检测
make qt5py3 出现以下提示则证明安装成功
5. 打开labellmge 在labellmg文件夹下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01499947c98db61318b776951c031fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389daaebfdcd3e6cfe591cdbc1a61fa4/" rel="bookmark">
			mybatis 配置文件框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. mybatis 配置文件框架 － mybatis-config.xml &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "https://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="${driver}"/&gt; &lt;property name="url" value="${url}"/&gt; &lt;property name="username" value="${username}"/&gt; &lt;property name="password" value="${password}"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 2. mybatis 配置文件框架 －???Mapper.xml &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.BlogMapper"&gt; &lt;select id="selectBlog" resultType="Blog"&gt; select * from Blog where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/389daaebfdcd3e6cfe591cdbc1a61fa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f63128e1b30666ae3a3ea9489cc4a2c/" rel="bookmark">
			JavaScript中的回调函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		### 什么是回调函数？
回调函数是指在某个函数执行完成后自动调用的函数。回调函数通常作为参数传递给另一个函数，在另一个函数执行完毕后，回调函数被自动调用。回调函数在JavaScript中经常被用来处理异步编程，例如处理事件和回调API函数。
### 为什么需要回调函数？
回调函数通常用于处理异步编程。在JavaScript中，许多操作都是异步的，例如文件读取、网络请求、定时器等等。在这些操作完成之前，程序会继续执行下去，但是操作完成后需要处理操作结果。这时候就需要用到回调函数。
### 如何使用回调函数？
回调函数通常作为另一个函数的参数传递。例如，以下是一个简单的回调函数示例：```
function foo(callback) { setTimeout(() =&gt; { console.log('foo'); callback(); }, 1000); } function bar() { console.log('bar'); } foo(bar); ``` 上面的示例中，`foo()`函数是一个异步函数，它会在1秒钟后打印出`foo`，然后调用回调函数`callback`。`bar()`函数是回调函数，它会在`foo()`函数执行完毕后自动被调用。
当调用`foo(bar)`时，`bar()`函数作为参数传递给`foo()`函数，`foo()`函数执行完毕后会自动调用`bar()`函数。
### 回调函数的常见应用场景
回调函数在JavaScript中经常被用于处理异步编程。以下是回调函数的一些常见应用场景：
#### 事件处理
回调函数通常用于处理事件。例如，以下是一个点击事件的示例：
``` &lt;button id="btn"&gt;Click me!&lt;/button&gt; &lt;script&gt; var btn = document.getElementById('btn'); btn.addEventListener('click', function() { console.log('Button clicked!'); }); &lt;/script&gt; ```
上面的示例中，当按钮被点击时，回调函数会被调用，并打印出`Button clicked!`。
#### 定时器
回调函数也经常用于定时器。例如，以下是一个定时器的示例：
``` setTimeout(function() { console.log('Timer expired!'); }, 1000); ``` 上面的示例中，回调函数会在1秒钟后被调用，并打印出`Timer expired!`。
#### AJAX请求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f63128e1b30666ae3a3ea9489cc4a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a614413686fa3834a9980c1f1de9aa28/" rel="bookmark">
			小车沿着黑线行走
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理
以黑色的外边线为基准：
（白：70，黑：8）60比白色检测到的小一点，比黑色大一点
检测到白色时，车体往黑色方向偏转；
检测到黑色时，车往白色方向偏转。
所以它走的不是完全的直线，会小幅度稍左或稍右进行移动。
注意
在程序中，判断的数值要稍大或稍小一些。例如白色为60，那么判断值可以设为50 红外线传感器要安装得尽量低
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d3e68905ac042c635df44b7ef4d10d/" rel="bookmark">
			UNIX环境高级编程笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNIX环境编程 一、UNIX基础知识1.1 Linux 主要特性1.2 Linux 内核1.3 Linux 目录结构1.4 登录1 登录名2.shell 1.5 输入和输出1. 文件描述符2. 标准输入、标准输出、标准错误3. 不带缓冲的IO4. 标准I/O 1.6 程序和进程1. 程序2. 进程和进程ID3. 进程控制4. 线程和线程ID 1.7 出错处理1.8 用户标识1.9 信号1.10 时间值1.11 系统调用和库函数 二、UNIX标准及实现2.1 ISO C2.2 函数sysconf、pathconf、和fpathconf2.3 ISO C和IEEE POSIX 三、文件I/O3.1 文件描述符3.2 函数open和openat3.3 函数creat3.4 函数close3.5 函数lseek3.6 函数read/write3.7 I/O的效率3.8 文件共享3.9 原子操作3.10 函数dup和dup23.11 函数sync、fsync和fdatasync3.12 函数fcntl3.13 函数ioctl3.14 /dev/fd 四、文件和目录4.1 函数stat、fstat、fstatat和lstat4.2 文件类型4.3 设置用户ID和设置组ID4.4 新文件和目录的所有权4.7 函数access和faccessat4.8 函数umask4.9 函数chmod、fchmod和fchmodat4.10 函数chown、fchown、fchownat和lchown4.11 文件长度4.12 文件截断4.13 文件系统4.14 函数link、linkat、unlink、unlinkat和remove4.15 函数rename和renameat4.16 符号链接4.17 创建和读取符号链接4.18 文件时间4.19 函数futimens、utimensat和utimes4.20 函数mkdir、mkdirat和rmdir4.21 读目录4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5d3e68905ac042c635df44b7ef4d10d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1e543892621c062baa228db7c1a452e/" rel="bookmark">
			[!] Gradle threw an error while downloading artifacts from the network. Retrying to download... Runn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[!] Gradle threw an error while downloading artifacts from the network. Retrying to download… Runn
报这个错
把zip包直接放到c盘某个位置 并更改android/gradle/wrapper/gradle-wrapper.properties里的
distributionUrl 改成本地的地址 比如本人的地址
C:/Users/Administrator/.gradle/gradle-6.6.1-all.zip
就可以把这个地址填进去
distributionUrl=file:///C:/Users/Administrator/.gradle/gradle-6.6.1-all.zip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c8c3f2c4936ac918c581dc2711af0ca/" rel="bookmark">
			python表情库 emoji
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
使用方法
安装：pip install emoji
建议使用 jupyter notebook打印结果更明显
两个方法：
emoji.emojize() 根据 code 生成 emoji 表情
emoji.demojize() 根据 emoji 表情解码为 code
默认情况下，只能使用部分表情。网上说添加参数 use_aliases=True 后方可展示，但是我使用这个参数报错，在源码中搜索use_aliases，发现添加language参数，参数值为alias即可，不需要使用use_aliases
使用方法 import emoji emoji.emojize(':zzz:') # emoji.emojize() 根据code生成emoji表情 emoji.emojize(":checkered_flag:",language='alias') # emoji.demojize()根据emoji表情解码为code emoji.demojize("🌾",language='alias') 表情查询库：🎁 Emoji cheat sheet for GitHub, Basecamp, Slack &amp; more
​​​​​​​ ​​​​​​​https://www.unicode.org/emoji/charts/full-emoji-list.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df899760b198ddc3c56cd2807f72893e/" rel="bookmark">
			CloudCompare如何进行二次开发的第一步：编译？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0.引言1.准备要编译的源代码和工具2.利用CMake进行编译配置3.利用VS编译生成可执行文件 0.引言 CloudCompare是一款优秀的开源点云处理软件，在研究点云的过程中，除了利用该软件现有的功能，在基于开源情况下，可以对该软件进行二次开发，以适应未来特定的需求。要对CloudCompare进行二次开发（在源代码基础上添加新功能或者开发插件），必须先能实现对该软件的编译，后续二次开发才能顺利进行。
1.准备要编译的源代码和工具 （1）下载CloudCompare源代码
源代码仓库地址： https://github.com/cloudcompare/cloudcompare
①下载源代码：
注：这里下载2.10.x或2.11.x低版本，一般不下载高版本（bug较多不稳定）。
②查看编译要求
上面网页下滑到Compilation部分，打开BUILD.md file，查看编译工具版本要求。
（2）准备CMake工具
下载地址：https://cmake.org/
下载最新版本即可。
（3）准备VS工具
浏览器里搜索”VS2015“下载，本文采用VS2015（项目模板包括C++）。因CloudCompare源代码为C++，必须要有C++编译器，高于VS2015版本的VS需要在Visual Studio Installer中勾选与C++有关和Cmake有关的组件。
安装成功后，右键该软件，找到属性→打开文件所在位置，查看VS对应的操作系统（64位/32位）。
（4）准备QT工具
下载地址： http://download.qt.io/
这里下载5.9.6版本。
QT安装步骤如下：
2.利用CMake进行编译配置 编译配置步骤如下：
3.利用VS编译生成可执行文件 （1）编译操作步骤如下：
VS编译可能出现的问题：
问题一：VS编译报错，找不到文件。
解决思路：
①VS高于2015版的，检查一下Visual Studio Installer中是否C++和CMake相关组件都已安装；
②检查CMake中设置的QT相关路径。除了QT5_ROOT_PATH外，下面的QT5Widget**等路径也要设置对；
③检查安装的Qt库路径是否配置了系统环境变量。
（2）找到编译生成的.exe文件打开
参考资料：
[1] 李子宽. CloudCompare-win编译教程; 2019-04-30 [ accessed 2023-03-26 ].
[2] Being_young. CloudCompare二次开发编译篇(内附交流群更新通知); 2020-10-22 [ accessed 2023-03-26 ].
[3] 陶技者. 完美解决CMake时“could not find any instance of Visual Studio”的问题【每天一个小技巧】; 2020-05-14 [ accessed 2023-03-26 ].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df899760b198ddc3c56cd2807f72893e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/89/">«</a>
	<span class="pagination__item pagination__item--current">90/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/91/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>