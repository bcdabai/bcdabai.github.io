<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87bb2134688a3f9368684d38eda57b6e/" rel="bookmark">
			Mac／windows 下 手动将jar包打包到maven本地仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装好maven：https://blog.csdn.net/sinat_37812248/article/details/84624763
终端输入： mvn install:install-file -Dfile=xx.jar -DgroupId=xx -DartifactId=xx -Dversion=xx -Dpackaging=jar
-Dfile: jar的所在路径+jar包名+.jar（不知道路径怎么看可将文件直接拖入终端便会显示路径）
-DgroupId: 对应maven的groupId
-DartifactId: 对应maven的artifactId
-Dverson: 对应maven的version
pom.xml中引入依赖：
&lt;dependency&gt;
&lt;groupId&gt;x x&lt;/groupId&gt;
&lt;artifactId&gt;x x&lt;/artifactId&gt;
&lt;version&gt;x x&lt;/version&gt;
&lt;/dependency&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/976b0e8e6badd5ac285da83946297e8c/" rel="bookmark">
			C＃中的寻路算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
介绍
问题
Dijkstra算法
A *算法
结果
结论
挑战
Dijkstra和Astar的比较
Download source - 571.3 KB
在Visual Studio 2017中解压缩并打开解决方案
介绍 你有没有想过GPS应用程序如何计算到选定目的地的最快方式？正如您将看到的，它实际上非常简单。
本文将对此进行说明并提供您可以随意使用的示例代码。本文还比较了两种常见的基本算法，Dijkstra和A *。
问题 假设你有一张地图。你知道你在哪里以及你想去哪里。地图具有连接节点（具有坐标的位置）的道路（它们被称为边）。
从每个节点，您可以转到一个或多个边。边是具有成本的（例如，旅行所需的路程长度或时间）。对于小地图，可以计算到目的地的所有可能路线并选择最短路线。但是对于具有许多节点的地图来说，这不是很实用，因为组合会呈指数级增长。
Dijkstra算法 Dijkstra算法于1959年由Edsger Dijkstra发现。这是它的工作原理：
从起始节点，将所有连接的节点添加到优先级队列。按最低成本对优先级队列进行排序，并将第一个节点作为当前节点。
对于每个子节点，选择导致最短路径到开始节点的最佳节点。
当从一个节点调查所有边时，该节点为“ Visited”，您不需要再次访问该节点。将连接到当前节点的每个子节点添加到优先级队列。转到步骤2，直到队列为空。递归地创建从最开始到结束的最短路径的每个节点的节点列表。反转列表，您找到了最短的路径 换句话说，递归地为节点的每个子节点测量它到开始节点的距离。存储距离和存储导致到开始节点最短路径的节点。当你到达终点节点时，递归地以最短的路径返回到开始节点，反转该列表并且你将拥有最短的路径。
下面是我在C＃代码中的Dijkstra算法实现。它可能比上面更容易理解。
public List&lt;Node&gt; GetShortestPathDijkstra() { DijkstraSearch(); var shortestPath = new List&lt;Node&gt;(); shortestPath.Add(End); BuildShortestPath(shortestPath, End); shortestPath.Reverse(); return shortestPath; } private void BuildShortestPath(List&lt;Node&gt; list, Node node) { if (node.NearestToStart == null) { return; } list.Add(node.NearestToStart); BuildShortestPath(list, node.NearestToStart); } private void DijkstraSearch() { Start.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/976b0e8e6badd5ac285da83946297e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/418bce385380ad5be5056256a11b1ebe/" rel="bookmark">
			Python中i = i &#43; 1与i &#43; = 1的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		+=是对原本的实例做加1运算，l=l+[1]是对l+[1]之后重新把值赋给叫l的变量（和原来的l不同）
区别在于，一个修改数据结构本身（就地操作）b + = 1而另一个只是重新分配变量a = a + 1。
只是为了完整性
l = [] lst = [] lst.append(l) print(lst)#[[]] l += [1] print(l)#[1] print(lst)#[[1]] l = l + [2] print(l)#[1,2] print(lst)#[[1]] 转载于:https://www.cnblogs.com/z-x-y/p/10090892.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9150a3d82c6f85f033cf371e567e36ef/" rel="bookmark">
			enum(枚举)小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.含义： enum是计算机中的一种数据类型，枚举类型。使变量的取值被限定在一定的范围内，比如一年有四季。在枚举类型的定义中列举出所有可能的取值，则说明为该“枚举”类型的变量取值不能超过定义的范围。对于枚举类型来说，它是一种基本数据类型，不是一种构造类型，不能够再被分解为任何基本类型。
枚举类型中一般规定了，枚举值是常量，不是变量，不能在程序中用赋值语句再进行赋值，只能把枚举值赋给枚举变量。一定要把数值赋给枚举变量时，必须使用强制类型转换。对于Java语言，在enum出现之前，一般使用接口来实现列举的，一个enum对象中不可能有两个或多个相同的属性或值，
public interface Season{ static winter = 1; static spring = 0; } 引入enum的Java的列举编程方便许多，只定义一个enum型的对象，enum对象的值会自动获得一个数字值，从0开始，依次递增。
public class EnumDemo{ private enum Seasons{ winter,spring,summer,fall } public static void main(String[] args){ for(Seasons s:Seasons.values()){ System.out.println(s); } } } 会依次输出winter,spring,summer,fall
Java中常用的枚举 常量：
直接可以定义枚举的值
public enum Seasons{ spring,summer,fall,winter } switch:
enum Seasons{ spring,summer,fall,winter } public class ChooseSeason{ Seasons season = Seasons.fall; public void change(){ witch (season){ case spring : season = Seasons.spring; break; case summer: season = Seasons.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9150a3d82c6f85f033cf371e567e36ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3f509663b533bbec9c811a40079093b/" rel="bookmark">
			STM32驱动AD7190
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇介绍的时高精度、速度AD芯片AD7190的驱动，针对STM32，并且使用的时HAL库，改成其他库也很容易，只需要把相关通讯部分改了就行。
SPI设置，首先看AD7190的手册时序图 时序图中已经包含了很多信息，所以SPI配置如下，其中时钟最高为5M，在数据手册中看到的t3有最小时间限制：
CS引脚可以一直为低的状态，表示一直选中，如果要多片通讯，可以设置为其他，先把驱动程序放出来 #include "ad7190.h" //#define CS_H HAL_GPIO_WritePin(SPI1_NSS_GPIO_Port, SPI1_NSS_Pin, GPIO_PIN_SET) //#define CS_L HAL_GPIO_WritePin(SPI1_NSS_GPIO_Port, SPI1_NSS_Pin, GPIO_PIN_RESET) static AD7190_REG_T ad7190_obj; void init_AD7190_reg_cmds(AD7190_REG_Ptr ad7190_reg_ptr); unsigned char SPIDEV1_single_transfer(unsigned char data_byte) { uint8_t data=0; //CS_L; //HAL_Delay(1); HAL_SPI_TransmitReceive(&amp;hspi4, &amp;data_byte, &amp;data, 1, 1000); //HAL_Delay(1); //CS_H; return 0; } int SPIDEV1_transfer(unsigned char *send, unsigned char *receive, unsigned char bytes_num) { //uint8_t i=0; //CS_L; //HAL_Delay(1); HAL_SPI_TransmitReceive(&amp;hspi4, send, receive, bytes_num, 5000); //HAL_Delay(1); //CS_H; return 0; } /**************************************************************** * Function Name : init_AD7190_reg_cmds * Description : API to initialize the AD7190 commands structure * for communication * Returns : None * Params @ad7190_reg_ptr: Pointer to commands structure ****************************************************************/ void init_AD7190_reg_cmds(AD7190_REG_Ptr ad7190_reg_ptr) { ad7190_reg_ptr-&gt;cmd_rd_ID_reg = COM_READ_ID_REG_CMD; ad7190_reg_ptr-&gt;cmd_rd_config_reg = COM_READ_CONFIG_REG_CMD; ad7190_reg_ptr-&gt;cmd_rd_data_reg = COM_READ_DATA_REG_CMD; ad7190_reg_ptr-&gt;cmd_rd_full_scale_reg = COM_READ_FULL_SCALE_REG_CMD; ad7190_reg_ptr-&gt;cmd_rd_gpocon_reg = COM_READ_GPCON_REG_CMD; ad7190_reg_ptr-&gt;cmd_rd_mode_reg = COM_READ_MODE_REG_CMD; ad7190_reg_ptr-&gt;cmd_rd_offset_reg = COM_READ_OFFSET_REG_CMD; ad7190_reg_ptr-&gt;cmd_rd_status_reg = COM_READ_STATUS_REG_CMD; ad7190_reg_ptr-&gt;cmd_wr_gpocon_reg = COM_WRITE_GPCON_RED_CMD; ad7190_reg_ptr-&gt;cmd_wr_config_reg = COM_WRITE_CONFIG_REG_CMD; ad7190_reg_ptr-&gt;cmd_wr_mode_reg = COM_WRITE_MODE_REG_CMD; } /**************************************************************** * Function Name : init_AD7190_cmds * Description : Initialize the AD7190 commands structure * for communication * Returns : None * Params : None ****************************************************************/ void init_AD7190_cmds() { init_AD7190_reg_cmds(&amp;ad7190_obj); } /**************************************************************** * Function Name : AD7190_configure * Description : Configure/Write to the configuration register * for communication * Returns : (-1) typecast for error, 0 for success * Params @cbyte_2: Data to write to Most Significant Byte * @cbyte_1: Data to write to Middle Byte * @cbyte_0: Data to write to Least Significant Byte ****************************************************************/ char AD7190_configure(unsigned char cbyte_2, unsigned char cbyte_1, unsigned char cbyte_0) { char check_ret = 0x00; unsigned char ad7190_id = 0x00; ad7190_id = AD7190_get_ID(); //printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3f509663b533bbec9c811a40079093b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da7f6112616e7cb19e85422447f3fe1/" rel="bookmark">
			对vuex的state高级用法mapState的详细正解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在看vuex官方文档的时候，发现state的mapState 辅助函数在vue组件中使用的时候，表述还是不够清楚，在网上看了很多文章解释的也不够详细，接下来我发表下我个人看法，帮大家来填坑。
使用 mapState 辅助函数帮助我们生成计算属性
export default new Vuex.Store(
{
state:{
count:1
}
})
首先要使用mapState，必须在组件中引入 import {mapState} from "vuex"
&lt;template&gt;
&lt;div&gt;
&lt;div&gt;{{count}}&lt;/div&gt; &lt;!--取的是state中的count 值是1 --&gt;
&lt;div&gt;{{countAlias}}&lt;/div&gt;&lt;!--取的是state中的count 值是1 --&gt;
&lt;div&gt;{{countPlusLocalState}}&lt;/div&gt;&lt;!--取的是state中的count 值+组件中的localCount值是11 --&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import {mapState} from "vuex" //引入mapState
export default {
data(){
return{
localCount:10
}
},
computed: mapState({
count: state =&gt; state.count, // 组件内的每一个属性函数都会获得一个默认参数state, 然后通过state 直接获取它的属性更简洁
// 传字符串参数 'count' 等同于 `state =&gt; state.count`
countAlias: 'count',//把上面的count值给countAlias
// 为了能够使用 `this` 获取局部状态，必须使用常规函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da7f6112616e7cb19e85422447f3fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/540020488b1fe328a13c9393a10c7fbf/" rel="bookmark">
			audio不能在苹果手机正常播放的坑,希望可以帮助大家跳过坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个小程序音频audio不能在苹果手机正常播放的坑** 这两天用到audio 组件，直接复制了demo 的代码，==没有加事件==，在安卓手机上是可以正常播放的，以为不用添加事件是可以用的，后来发现苹果手机上是没有反应，然后添加了点击事件后苹果和安卓上都可以正常播放了，附上以下代码，大神请路过： &lt;audio poster="{{postData.music.coverImg}}" name="{{postData.music.title}}" author="{{postData.author}}" src="{{postData.music.url}}" id="myAudio" bindtap='audioClick' controls loop &gt;&lt;/audio&gt; js: Page({ data: { isPlaying: false }, onReady:function(e){ this.audioCtx = wx.createAudioContext('myAudio') }, onUnload:function(){ this.data.innerAudioContext.destroy(); }, audioClick(e) { this.setData({ isPlaying:!this.data.isPlaying }) if (this.data.isPlaying){ this.audioCtx.play(); console.log("播放") }else{ this.audioCtx.pause(); } } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1491977530dfd49453021fc2d853527c/" rel="bookmark">
			数据库---第四章----数据库安全性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据库安全性概述
1.数据库的不安全因素
(1）非授权用户对数据库的恶意存取和破坏
(2)数据库中重要或敏感的数据被泄露
(3)安全环境的脆弱性
2.安全标准简介
1985年美国国防部（DoD）正式颁布《DoD可信计算机系统评估准则》（简称TCSEC或DoD85）
不同国家建立在TCSEC概念上的评估准则
欧洲的信息技术安全评估准则（ITSEC）
加拿大的可信计算机产品评估准则（CTCPEC） 美国的信息技术安全联邦标准（FC）
1.TCSEC标准
TDI又称紫皮书。它将TCSEC扩展到数据库管理系统
TDI中定义了数据库管理系统的设计与实现中需满足和用以进行安全性级别评估的标准
TCSEC/TDI，从四个方面来描述安全性级别划分的指标
安全、策略、责任、保证、文档
2.TCSEC/TDI安全级别划分:
D级
将一切不符合更高标准的系统均归于D组
DOS在安全性方面几乎没有什么专门的机制来保障
C1级
非常初级的自主安全保护
能够实现对用户和数据的分离，进行自主存取控制（DAC），保护或限制用户权限的传播。
现有的商业系统稍作改进即可满足
C2级
安全产品的最低档次
提供受控的存取保护，将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离
达到C2级的产品在其名称中往往不突出“安全”（Security）这一特色
B1级
标记安全保护。“安全”（Security）或“可信的” （Trusted）产品。
对系统的数据加以标记，对标记的主体和客体实施强制存取控制（MAC）、审计等安全机制
B2级
结构化保护
建立形式化的安全策略模型并对系统内的所有主体和客体实施DAC和MAC
B3级
安全域
该级的TCB必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程
A1级
验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证以确信各安全保护真正实现。
CC
提出国际公认的表述信息技术安全性的结构
把信息产品的安全要求分为
安全功能要求
安全保证要求
CC文本组成
简介和一般模型
有关术语、基本概念和一般模型以及与评估有关的一些框架
安全功能要求
列出了一系列类、子类和组件
安全保证要求
列出了一系列保证类、子类和组件
提出了评估保证级，从EAL1至EAL7共分为七级
二、数据库安全性控制
1.非法使用数据库的情况
（1）编写合法程序绕过数据库管理系统及其授权机制
（2）直接或编写应用程序执行非授权操作
（3）通过多次合法查询数据库从中推导出一些保密数据
2.存取控制流程
首先，数据库管理系统对提出SQL访问请求的数据库用户进行身份鉴别，防止不可信用户使用系统。
然后，在SQL处理层进行自主存取控制和强制存取控制，进一步可以进行推理控制。
还可以对用户访问行为和系统关键操作进行审计，对异常用户行为进行简单入侵检测。
3.数据库安全性控制的常用方法
用户标识和鉴定
存取控制
视图
审计
数据加密
4.用户身份鉴别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1491977530dfd49453021fc2d853527c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f315b47f473d4256cf821cc60998e8c8/" rel="bookmark">
			内网穿透：MAC 下使用 ngrok 实现内网穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 MAC 版的 ngrok：https://ngrok.com/download解压到指定目录： unzip -d /tmp ngrok-stable-darwin-amd64.zip 进入到解压后的 ngrok 所在路径： cd /tmp 开启服务： ./ngrok http localhost:8080 status -&gt; online 启动成功。
转发地址为Forwarding 链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa67a97aacf6d41c230aeb048e00f1dd/" rel="bookmark">
			类的具体表现--对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义对象 对象是类的实例，它属于某个已知的类。因此定义对象之前，一定要先定义该对象的类。下面简单的介绍对象的定义。对象在确定了它的类以后，定义格式如下：
《类名》《对象名表》
其中，《类名》是特定的对象所属的类的名字，即所定义的对象是该类类型的对象。《对象名表》中可以是一个或多个对象名，多个对象名时用逗号分隔。也可以是指向对象的指针或引用名，数组。
student s1,s3;	//普通对象 student *ptr;	//对象指针 student student_array[10];//对象数组 s1.math = 100;	//对象属性 s1.setmath(100);	//成员函数 ptr-&gt;math =90;	//直接用指针访问成员 ptr-&gt;setmath(90); (*ptr).math =90;	//间接访问成员 (*ptr).setmath(90); student_array[0].math =100; student_array[0].setmath(100); 使用对象 当定义一个对象后，就可以像变量一样来使用该对象。本节将主要讲述对象构成的数组和指向对象的指针的用法。
1.对象数组
对象数组是指每个数组元素都是对象的数组。也就是说，若某一个类有若干个对象，就可以把这一系列对象用一个数组来存放。
2.对象指针
指向自身的指针–this this指针是指调用成员函数的类的对象的指针。在定义类对象时，每一个类的对象都会有·拥有一份独立的非静态的数据成员，而共享同一份成员函数的备份。显然，这样做的好处是可以节约存储空间。但是在程序运行过程中，类对象是如何将成员函数绑定到属于自己的数据成员上的呢？完成这项绑定任务的就是this指针。
定义一个Time类，包括属性：时，分，秒，方法void set()用于设置时间，方法void show（）用于输出时间，构造函数用于初始化属性为0:0:0.
#include &lt;iostream&gt; using namespace std; class Time { private: int hour; int min; int sec; public: Time() { hour = 0; min = 0; sec = 0; } void set(int hour ,int min ,int sec ) { this-&gt;hour = hour; this-&gt;min = min; this-&gt;sec = sec; } void show() { cout&lt;&lt;hour&lt;&lt;min&lt;&lt;sec&lt;&lt;endl; } }; int main() { Time time1; time1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa67a97aacf6d41c230aeb048e00f1dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0afc0a893bf0e422944ff0a4a442bb7/" rel="bookmark">
			Mysql Table doesn&#39;t exist问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序连接Mysql的时候总是提示表不存在，Table 'xx.QRTZ_LOCKS' doesn't exist
查询了下，数据库明明是有这个表的，搞了许久，
网上据说是因为数据库对表的大小写设置问题，设置忽略大小写即可，
修改mysql数据库配置：
在服务运行目录找到my.ini或者my.cnf文件
打开文件，找到[mysqld]在下面增加一行
lower_case_table_names=1 （0:大小写敏感;1:大小写不敏感）
重启MySQL服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e726355c0b3e06e4c958ceb360f5e4/" rel="bookmark">
			Error This project references NuGet package(s) that are missing on this computer. Use NuGet Package解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法： 参考：http://docs.nuget.org/ndocs/consume-packages/package-restore 找到 项目文件.csproj，打开后，移除下面的内容 &lt;Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild"&gt; &lt;PropertyGroup&gt; &lt;ErrorText&gt;This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them. For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.&lt;/ErrorText&gt; &lt;/PropertyGroup&gt; &lt;Error Condition="!Exists('$(SolutionDir)\.nuget\NuGet.targets')" Text="$([System.String]::Format('$(ErrorText)', '$(SolutionDir)\.nuget\NuGet.targets'))" /&gt; &lt;/Target&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85806a1dde1acf5d3175d46f2fecfb0c/" rel="bookmark">
			转录组GO富集与微生物相关性分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转录组GO富集与微生物相关性分析 原始数据格式使用TCC包进行差异基因分析使用topGO包进行GO富集分析计算转录组与微生物组相关性根据GO号提取相关性矩阵并绘图提取相关性矩阵绘制热图输出与热图对应的相关性矩阵 原始数据格式 我相信做生物分析的都知道很多时候难点往往不在于代码怎么写，而在于数据格式很多时候与各种包的要求不相符合，因此我先列一下本次分析中用到的数据格式
表1：转录组数据使用原始矩阵
A_1A_2A_3B_1B_2B_3C_1C_2C_3D_1……Gene0000001…………………………………………………………Gene0000002…………………………………………………………Gene0000003…………………………………………………………Gene0000004………………………………………………………………………………………………………………………… 表2：分组数据
sample_IDgroupA_1AA_2AA_3AB_1BB_2BB_2BC_1C………… 表3：细菌丰度表
genus1genus2genus3genus4……A_1…………………………A_2…………………………A_3…………………………B_1…………………………B_2………………………………………………………… 表4：基因注释文件
由于我做的是非模式生物，所以进行GO富集时还需要一个基因注释文件，这个文件的后缀是.map（用文本文档按下列格式弄好改后缀就行），gene_id列与GO_number列之间用\t制表符分隔
gene_idGO_numberGene0000001GO:0005515Gene0000001GO:0051259, GO:0046872, GO:0030176, GO:0005783, GO:0030968, GO:0016874, GO:0016021, GO:0016020, GO:0008270, GO:0000299, GO:0006928, GO:0006512, GO:0006511, GO:0007165, GO:0005515, GO:0030433, GO:0005789, GO:0004842, GO:0000209, GO:0004872Gene0000003GO:0008076, GO:0005242, GO:0030955, GO:0005244………… 使用TCC包进行差异基因分析 TCC是什么包？为什么要用TCC包？目前常用的差异基因分析包为DEseq2或者edgeR,但是这两个包在寻找差异基因时只能够找出两组之间的差异基因，即使你的数据里有A、B、C、D四个组，DESeq2分析后也只会返回A vs B，A vs C，A vs D，B vs C……的结果，而不会找出在四个组中有显著性差异的基因。这对于做临床研究、药理研究的同志们来说可能够了，但是对于植物学方面的就不够用了（不同器官、不同生长阶段等）。那么有没有可以多组同时比较的R包呢？经过检索我发现了这个TCC包可以满足要求1。其实这个包是在DESeq，DESeq2和edgeR三个包基础上构建了一个适用于多组分析的pipeline。这里我使用的是基于DESeq2的管道，更多内容可以参考帮助文档。分析代码如下：
#gene_count_matrix，为基因表达矩阵，读入过程略 #group为分组，读入过程略 library(TCC) #构建TCC类 tcc &lt;- new("TCC", gene_count_matrix, group) #下面使用TCC包基于DESeq2的管道方案 ssss &lt;- calcNormFactors(tcc, norm.method = "deseq2", test.method = "deseq2", iteration = 3) DE &lt;- estimateDE(ssss, test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85806a1dde1acf5d3175d46f2fecfb0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b5eb39f10efe4d863c2332914a2800/" rel="bookmark">
			sql：主键（primary key）和唯一索引（unique index）区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主键一定是唯一性索引，唯一性索引并不一定就是主键。 所谓主键就是能够唯一标识表中某一行的属性或属性组，一个表只能有一个主键，但可以有多个候选索引。
因为主键可以唯一标识某一行记录，所以可以确保执行数据更新、删除的时候不会出现张冠李戴的错误。
主键除了上述作用外，常常与外键构成参照完整性约束，防止出现数据不一致。数据库在设计时，主键起到了很重要的作用。 主键可以保证记录的唯一和主键域非空，数据库管理系统对于主键自动生成唯一索引，所以主键也是一个特殊的索引。 2. 一个表中可以有多个唯一性索引，但只能有一个主键。 3. 主键列不允许空值，而唯一性索引列允许空值。 4. 索引可以提高查询的速度。 其实主键和索引都是键，不过主键是逻辑键，索引是物理键，意思就是主键不实际存在，而索引实际存在在数据库中，主键一般都要建，主要是用来避免一张表中有相同的记录，索引一般可以不建，但如果需要对该表进行查询操作，则最好建，这样可以加快检索的速度。 首先primary key跟unique都是Constraints，属于logical object，而index则是physical object，会占用index page并被保存在磁盘上。
Primary key Constraints和unique Constraints都需要保证列是唯一的，不能有重复值，但是一张表只能有一个Primary key Constraints，但是可以有多个unique Constraints。
主键约束比唯一索引约束严格，当没有设定主键时，非空唯一索引自动称为主键。对于主键和唯一索引的一些区别主要如下：
1.主键不允许空值，唯一索引允许空值
2.主键只允许一个，唯一索引允许多个
3.主键产生唯一的聚集索引，唯一索引产生唯一的非聚集索引
注：聚集索引确定表中数据的物理顺序，所以是主键是唯一的（聚集就是整理数据的意思）
参考：https://zhidao.baidu.com/question/1991815428239822867.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf94cc3b02655ce1568fc4733c45c18/" rel="bookmark">
			Docker安装、破解、配置JIRA-7.13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 准备镜像
docker pull cptactionhank/atlassian-jira-software docker pull mysql:5.7 2 安装mysql
8720端口是为了可以用过外部访问，若不需要外部访问，可以不暴露端口。
docker run \ --name mysql-jira \ --restart always \ -p 8720:3306 \ -e MYSQL_ROOT_PASSWORD=123456 \ -e MYSQL_DATABASE=jira \ -e MYSQL_USER=jira \ -e MYSQL_PASSWORD=jira \ -d \ mysql:5.7 3 安装jira
docker run --detach --restart always --link mysql-jira:mysql --publish 8721:8080 cptactionhank/atlassian-jira-software 4 破解jira
一般用户替换破解包可能会权限不足，这里使用root用户操作。假如容器id为7509371edd48
破解包 https://github.com/ly641921791/knowledge/raw/master/jira/crack/atlassian-extras-3.2.jar
root用户进入容器
sudo docker exec -ti -u root 7509371edd48 bash 删除原jar
rm -rf /opt/atlassian/jira/atlassian-jira/WEB-INF/lib/atlassian-extras-3.1.2.jar 退出容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf94cc3b02655ce1568fc4733c45c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a85b86af82db9cb571dcc3eff22b693b/" rel="bookmark">
			PostgreSQL安装和创建用户和创建数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 可以参考postgresql官网安装教程:https://www.postgresql.org/download/linux/redhat/
Centos 6 安装postgresql 10
添加RPM：
-- centos 6 安装 postgresql 10 yum install https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-6-x86_64/pgdg-centos10-10-2.noarch.rpm -- centos 7 安装 postgresql 10 yum install https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-7-x86_64/pgdg-centos10-10-2.noarch.rpm 安装客户端：
yum install postgresql10 安装服务端：
yum install postgresql10-server 启动数据并初始化：
service postgresql-10 initdb chkconfig postgresql-10 on service postgresql-10 start 二、创建用户和数据库 # su - postgres -- 首先切换到postgres -bash-4.1$ psql -- 输入psql psql (10.5) Type "help" for help. postgres=# 创建用户
postgres=# create user username with password '****'; CREATE ROLE postgres=# 需要注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a85b86af82db9cb571dcc3eff22b693b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e23a7d8aba6db0854a15927036de292/" rel="bookmark">
			yum命令被其他APP占用的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在给外星人安装CentOS的时候遇到问题，yum update时提示：
Another app is currently holding the yum lock; waiting for it to exit... 直接kill进程似乎解决不了问题，通过下面这种方式即可：
rm -f /var/run/yum.pid 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4481981783adf7b0a3ef17562bf1a6d/" rel="bookmark">
			java 8 日期互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.简述
Date对象表示特定的日期和时间，而LocalDate(Java8)对象只包含没有任何时间信息的日期。
因此，如果我们只关心日期而不是时间信息，则可以在Date和LocalDate之间进行转换。
1
2
二.Date转LocalDate
如果要将java.util.Date转换为java.time.LocalDate，可以使用以下步骤：
1）将java.util.Date转换为ZonedDateTime。
2）使用它的toLocalDate（）方法从ZonedDateTime获取LocalDate。
1
2
示例:
package insping;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Date;
public class Test {
public static void main(String[] args) {
Date date = new Date();
Instant instant = date.toInstant();
ZoneId zoneId = ZoneId.systemDefault();
// atZone()方法返回在指定时区从此Instant生成的ZonedDateTime。
LocalDate localDate = instant.atZone(zoneId).toLocalDate();
System.out.println("Date = " + date);
System.out.println("LocalDate = " + localDate);
}
}
结果:
Date = Fri Jun 16 15:29:05 CST 2017
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4481981783adf7b0a3ef17562bf1a6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1426105dc0412b76b0ce89ef06c97756/" rel="bookmark">
			安装 maskrcnn-benchmark: command &#39;:/usr/local/cuda/bin/nvcc&#39; failed with exit status 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		command ‘:/usr/local/cuda/bin/nvcc’ failed with exit status 1 unable to execute ':/usr/local/cuda/bin/nvcc': No such file or directory error: command ':/usr/local/cuda/bin/nvcc' failed with exit status 1 提示找不到 nvcc, 但是输入 nvcc --version, 却可以正常显示:
nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2017 NVIDIA Corporation Built on Fri_Sep__1_21:08:03_CDT_2017 Cuda compilation tools, release 9.0, V9.0.176 仔细观察发现, 报错的路径里面多了一个冒号!!
unable to execute ':/usr/local/cuda/bin/nvcc': No such file or directory 因此, 说明是环境变量的设置有问题, 将~/.zshrc(或者~/.bashrc)中进行如下修改
export CUDA_HOME=$CUDA_HOME:/usr/local/cuda # 将上面的语句修改成: export CUDA_HOME=/usr/local/cuda 然后, 刷新shell
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1426105dc0412b76b0ce89ef06c97756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e532a040f70ddb8674923447f93b16/" rel="bookmark">
			Gitlab CI&amp;CD 子模块拉取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Gitlab CI&amp;CD 子模块拉取 最近在使用gitlabCI的时候发现子模块的拉取，以及某些个项目内部使用脚本拉取第三方库的时候都需要项目的私钥。刚开始是直接在镜像中存在私钥，这就存在着只要获取了镜像就能获取私钥了，后面发现了gitlabci可以传递变量，那就可以完美解决这一个问题,现在先记录下。
在git项目中的Settings -&gt; CI / CD -&gt; Variables中添加私钥
在.gitlab-ci.yml中增加脚本 before_script: # 添加私钥 - eval `ssh-agent -s` - ssh-add &lt;(echo "$SSH_PRIVATE_KEY") - mkdir -p ~/.ssh - chmod 700 ~/.ssh # 拉取子模块 - git submodule sync --recursive - git submodule update --init --recursive 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/393e80852e1dd6392473f8bdd80c6d58/" rel="bookmark">
			基于ARCGIS EXCEL的数据生成点要素和坐标转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次写博客， 请多指教，其实没别的，就是记录总结下自己的某些心得。不多说了，直接上正题 一般来说我们定位实验采集到的数据一般为经纬度形式，例如：
上面的经纬度就是实验得到的数据， 这只是一个点， 像这样的点有很多，有时就需要将这些点转化为平面坐标方便计算。用到的软件是ARCGIS的ArcMap和EXCEL，后者推荐用2003版本的 ，因为高版本有时会出现些小问题 小心会把你心态搞爆炸 ！
先说些无聊的：
经纬度是啥？对于初中地理就没学好的我只知道横着的是纬度，竖着的是经度。其实准确来说经度是地球上一个地点离一根被称为本初子午线的南北方向走线以东或以西的度数。纬度是指某点与地球球心的连线和地球赤道面所成的线面角，其数值在0至90度之间，所以说从没见过纬度超过90度的。经纬度是经度与纬度的合称组成一个坐标系统。又称为地理坐标系统（后面会用到 ）。可以表示地球上任何一个位置。
在用ArcMap前我们需要先把你得到的实验数据导入到EXCEL中，像下图，第一列是经度，第二列是纬度。
之后另存为，格式后缀要是 .xls 的，放哪里都可以，我是放在了桌面。
里面的数据是不一样的， 只是后面的数字被隐藏了，双击任何一个单元格就可以看到。
接着打开ArcMap，是下图这样的：
有的会没有左边的内容列表，右上角找到窗口（W），选择里面的内容列表就可以了。
接着就是将存有经纬度数据的Excel文件导入到ArcMap中了·如图点击添加数据键：
双击sheet1$如下图：
右击sheet1$，选择显示xy数据，之后如图：
F1对应的是经度， F2则是纬度，因为EXCEL里第一列全是经度，第二列则是纬度。一定不能颠倒位置，否则位置信息就变了
这时显示未知坐标系 在编辑（E）里选择地理坐标系--World--WGS1984，如图：
点击确定，之后可能会提示表没有Object-ID字段，不管他，确定。之后如图：
这样我们就生成点数据了 就是这一个个的点组成了你实验时所走过的路径。
接着开始坐标转换：
右击sheet1$个事件--数据--导出数据，之后如图：
点击确定即可，此时把数据生成了shp的格式。如下图多了个篮框里的东东：
准备工作做完 正式开始坐标转换：
点击下图中的ArcToolbox--数据管理工具--投影和变换----要素--投影。最后的投影双击点开。
接着按下图配置：
其中的输出坐标系点开右面的文件夹：投影坐标系--Gauss Kruger--Beijing 1954，在这里面找。之后确定即可
接着右击Export_Output_project5--打开属性表，如图：
如图添加字段：
之后选中新添加的字段x，右击--计算几何。如图：
在弹出的框里选点的x坐标，如图：
点击确定后就成功的转化成x的坐标了，如图：
同样的，y坐标也是一样的方法，添加字段，名称改成y，剩下的一样，
计算几何，成功后如下图：
至此，坐标转换完成！
如果需要转换后的数据的话就将表中的数据导出，成 .dbf 格式
用Excel打开就得到转换后的坐标了，如下图：
到这就全部OK了！今后有什么心得还会再分享。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d636d17ed8630483ecfd4a0f08141ca/" rel="bookmark">
			CMake中的set指令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语法： SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 指令功能: 用来显式的定义变量 例子: SET (SRC_LST main.c other.c) 说明: 用变量代替值，例子中定义SRC_LST代替后面的字符串。
举例：
1，set(libs "${CMAKE_SOURCE_DIR}/src/main/jnilibs") 这个命令完成了这么一件事情： 定义了一个变量libs，并且变量的值为${CMAKE_SOURCE_DIR}/src/main/jnilibs，其中CMAKE_SOURCE_DIR 是一个cmake内置变量，指定了CMakeLists.txt所在的目录。详细介绍可参考：http://www.cnblogs.com/xianghang123/p/3556425.html。 2，set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jnilibs/${ANDROID_ABI}) 这个命令用于给CMAKE_LIBRARY_OUTPUT_DIRECTORY宏赋值，该宏指定了cmake编译输出的东西应该放在什么地方。
这个例子中的地方是${PROJECT_SOURCE_DIR}/src/main/jnilibs/${ANDROID_ABI}
其中PROJECT_SOURCE_DIR 是cmake内置宏，指向构建工程的全路径。详细介绍可参考https://www.cnblogs.com/alphagl/p/6280061.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28189e76cadefc378b13c1c6d6513984/" rel="bookmark">
			如何提升工作效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.减少干扰 手机置为静音或者放置在柜子里，戒除手机上瘾。
定时打开邮箱收邮件，而不是每一封邮件都有提醒。
关闭及时工具软件的消息提醒功能。
2.减少多任务的切换。 尽量不要再多个任务间来回切换，专注于做一件事情。如果迫不得已，需要同时做多个事情，一定要保存上下文，最简单的方式是为每一个任务记录一个文本文件的上下文。这有点类似于操作系统内存不够时使用虚拟内存的场景，每一个文本文件就类似于保存在磁盘上的虚拟内存，如果需要，可以快速的调入内存。
3.任务分解。 对于一个巨型的短期内不能实现的任务，大脑本能的产生抗拒，因为这种工作不能得到及时满足。大脑因此会进入拖延状态。我们要做的是将大任务分解成容易实现的小任务，这些小任务经过努力，可以快速的完成，使大脑获得及时满足和成就感。
4.升级工具。 工欲善其事，必先利其器。工具对效率的提升显而易见。
1.不要让电脑成为你工作的瓶颈
升级电脑，让电脑的启动和运行足够快。
2.善于借助工具软件
能够为你提升效率的软件都可以尝试，比如各种做图的软件满足不同类型作图需求，思维导图工具，笔记工具。
3.善于使用快捷键
能用键盘解决的问题，尽量不用使用鼠标。
vim：文本便捷，编程，浏览器插件，使用统一一套模式工作。
5.思考与笔记 任何时候，不要停止思考，等待别人分配任务去完成。一定要不停的思考，从不同的角度思考，从不同的立场思考：领导、同级、下级、竞争对手。充分的思考，能发现自己的误区，避免产生错觉和后续的摩擦。
一旦有思考，就一定有产出，不要吝啬自己的笔墨，迅速将自己的灵感记录下来。可以是流水时的任务清单，可以是深思熟虑的总结。总之要养成记录的习惯。人类文明得以延续和发展，考的就是记录，将知识和经验快速的沉淀和传递下来。通过笔记记录自己的思路，写读后感，写事件评论，写技术博客，写书等等。
6.沟通和管理能力 一个人再优秀也有缺陷，一个团队能够弥补个人的缺陷，产生强大的能力。所以要重视团队的力量，提升自身影响力，培养自己的领导力。及时和有效沟通是解决很多管理问题的最佳方法。你手下的人绩效不好，首先受到惩罚的是他的上司：有没有和他进行有效和及时的沟通。有没有发下下属绩效不佳的根本原因：是技术能力问题还是技能和岗位不匹配，是工作态度和价值观的问题还是家庭问题引发。协助下属找到问题点，并帮助解决，进行有效的绩效辅导，是一个合格管理者必须具备的能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e938e9629aeeef66f3b9db2e378f4c/" rel="bookmark">
			IDEA向前向后箭头如何设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		箭头效果图：
设置步骤：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78325da997c5261cbe2272d54aa88a8a/" rel="bookmark">
			1351： 家谱树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】
有个人的家族很大，辈分关系很混乱，请你帮整理一下这种关系。
给出每个人的孩子的信息。
输出一个序列，使得每个人的后辈都比那个人后列出。
【输入】
第1行一个整数N（1≤N≤100），表示家族的人数；
接下来N行，第I行描述第I个人的儿子；
每行最后是0表示描述完毕。
【输出】
输出一个序列，使得每个人的后辈都比那个人后列出；
如果有多解输出任意一解。
【输入样例】
5
0
4 5 1 0
1 0
5 3 0
3 0
【输出样例】
2 4 5 3 1
标准的拓扑排序算法，书上用栈结构我觉得没必要，用数组v记录下已经选出的点就行了。
#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std;/**&lt; 拓扑排序：要点是选中入度为0的点 */ int n,f[101][101],d[101],v[101]; int main() { memset(d,0,sizeof(d)); memset(v,0,sizeof(v)); int i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) { while(cin&gt;&gt;k&amp;&amp;k!=0) { f[i][k]=1; d[k]++; /**&lt; 邻接矩阵存储，同时记录入度 */ } } for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=n;j++) /**&lt; 查找第一个未被列出入度为0的点 */ { if(v[j]==0&amp;&amp;d[j]==0) break; } v[j]=1; cout&lt;&lt;j&lt;&lt;' '; for(k=1;k&lt;=n;k++) /**&lt; 把j的邻接点入度-1，相当于删除掉j这个点后的状态 */ { if(f[j][k]==1) d[k]--; } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc6c68db1fa064c91a16064a36e48e2/" rel="bookmark">
			FeatureToggle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 为了控制功能开启与关闭，减少代码中的if-else繁琐的逻辑判断。主要通过spring的aop及java的注解实现。目前主要包含6个部分的代码，支持内存存储和部分策略。
源码git：稍后放源码
功能 单个开关的配置
开关组的配置，通过组的设置，可控制组内的开关的开启和关闭
开关使用策略（v1.0 支持工作日策略，可灵活配置其他时间；支持客户端和服务端策略）
支持方法内调用的public方法
使用场景 接口层面的方法
同一个接口，有两个实现类，每个类的实现类中方法实现不一样，可以通过开关控制系统使用哪个实现类实现的方法。
如接口A-Service，有add()的方法，两个实现类A-ServiceImpl-1和A-ServiceImpl-2分别实现的add()方法，可以增加feature("add",true/false)一个开关控制add()方法是使用A-ServiceImpl-1还是A-ServiceImpl-2的实现。当然会有一个默认的使用方法，假设默认使用A-ServiceImpl-1，当feature的状态设置为true会使用A-ServiceImpl-2，否则使用A-ServiceImpl-1。
非接口层面的方法（内部方法调用public方法）
在一个方法中需要使用其他非接口的方法，正常情况下会实现两个方法，通过if-else去选择，现在可以通过开关的控制自动选择一个方法。
如compose()方法，里面需要调用非接口方法add()1和add2()其中之一，可以在这两个方法中加上注解，然后配置两个feature("add1",true/false)和feature("add2",true/false)开关，并根据实际配置的开关，compose()方法中具体使用哪一个，如果都设置为true，结果会使用后面的方法，如果都是false，则两个方法都不使用。
实现 代码分为6个部分
feature核心类
aop切面类
包括接口级别的方法和非接口级别的方法（方法内调用的public方法）
store存储类
strategy策略类
exception异常类
util工具类
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a19dc5023014e92da32ff5e9e412a0/" rel="bookmark">
			flutter插件中关于地图的使用flutter_map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于flutter插件地图的使用flutter_map flutter_map
A Dart implementation of Leaflet for Flutter apps.
一个基于leaflet的地图插件，也就是说flutter_map基于的是瓦片地图，那么在兼容性上可以说比较好用了。
横向对比
目前主要的地图插件主要有： flutter_map map_view``amap
map_view
先说下map_view这个插件，这个插件主要是用来展示google map使用。 由于一个我们都知道的原因，我们在使用这个插件的过程中相对比较困难，所以我们可是适当放弃使用这plugin。
flutter_amap
每次看到版本为0.0.1的插件总觉得哪里有问题的，这是高德推出的插件。 高德地图3d flutter组件。
展示原生android、ios高德地图，并与flutter交互。
注意：随着flutter版本的提升， 本项目也会随之更新， 目前这个版本只能在单独的controller或者activity中打开高德地图。 划线部分表示说这个版本还不是很成熟，因此我也不想用
flutter_map
这个插件就是要重点说下的了 ，下面的视频可能需要代理才能光看，示例： 视频 地址：https://pub.dartlang.org/packages/flutter_map
githubhttps://github.com/apptreesoftware/flutter_map 使用：
dependencies: flutter_map: ^0.3.0 在需要使用的地方根据自动提示添加packages
import 'packages:.....'; 需要注意的是可能需要添加LatLng这个包
使用：
Widget build(BuildContext context) { return new FlutterMap( options: new MapOptions( center: new LatLng(51.5, -0.09),//经纬度，注意前后顺序，用于展示中心 zoom: 13.0, ), layers: [ new TileLayerOptions( urlTemplate: "https://api.tiles.mapbox.com/v4/" "{id}/{z}/{x}/{y}@2x.png?access_token={accessToken}",//瓦片地图的URL additionalOptions: { 'accessToken': '&lt;PUT_ACCESS_TOKEN_HERE&gt;', 'id': 'mapbox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63a19dc5023014e92da32ff5e9e412a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e482f20be2e4e646f3036f9a5ee4b5b6/" rel="bookmark">
			MySQL SQL Error: 1064, SQLState: 42000 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 MySQL 中，下表中的字显式被保留。其中大多数字进制被标准 SQL 用作列名 和/或 表名( 例如，GROUP) 。少数被保留了，因为 MySQL 需要它们，( 目前) 使用 yacc 解析程序。保留字被引起来后可以用作识别符。
你不小心使用了下面的关键字，那么就会报这个错误：
SQL Error: 1064, SQLState: 42000 MySQL 关键字和保留字 下面这个表格的目前 MySQL 所拥有的关键字和保留字，在使用 MySQL 创建库名、表名、字段名等的时候，最好避免直接使用这些单词，并且不分大小写，否则的话很容易报错。
123ADDALLALTERANALYZEANDASASCASENSITIVEBEFOREBETWEENBIGINTBINARYBLOBBOTHBYCALLCASCADECASECHANGECHARCHARACTERCHECKCOLLATECOLUMNCONDITIONCONNECTIONCONSTRAINTCONTINUECONVERTCREATECROSSCURRENT_DATECURRENT_TIMECURRENT_TIMESTAMPCURRENT_USERCURSORDATABASEDATABASESDAY_HOURDAY_MICROSECONDDAY_MINUTEDAY_SECONDDECDECIMALDECLAREDEFAULTDELAYEDDELETEDESCDESCRIBEDETERMINISTICDISTINCTDISTINCTROWDIVDOUBLEDROPDUALEACHELSEELSEIFENCLOSEDESCAPEDEXISTSEXITEXPLAINFALSEFETCHFLOATFLOAT4FLOAT8FORFORCEFOREIGNFROMFULLTEXTGOTOGRANTGROUPHAVINGHIGH_PRIORITYHOUR_MICROSECONDHOUR_MINUTEHOUR_SECONDIFIGNOREININDEXINFILEINNERINOUTINSENSITIVEINSERTINTINT1INT2INT3INT4INT8INTEGERINTERVALINTOISITERATEJOINKEYKEYSKILLLABELLEADINGLEAVELEFTLIKELIMITLINEARLINESLOADLOCALTIMELOCALTIMESTAMPLOCKLONGLONGBLOBLONGTEXTLOOPLOW_PRIORITYMATCHMEDIUMBLOBMEDIUMINTMEDIUMTEXTMIDDLEINTMINUTE_MICROSECONDMINUTE_SECONDMODMODIFIESNATURALNOTNO_WRITE_TO_BINLOGNULLNUMERICONOPTIMIZEOPTIONOPTIONALLYORORDEROUTOUTEROUTFILEPRECISIONPRIMARYPROCEDUREPURGERAID0RANGEREADREADSREALREFERENCESREGEXPRELEASERENAMEREPEATREPLACEREQUIRERESTRICTRETURNREVOKERIGHTRLIKESCHEMASCHEMASSECOND_MICROSECONDSELECTSENSITIVESEPARATORSETSHOWSMALLINTSPATIALSPECIFICSQLSQLEXCEPTIONSQLSTATESQLWARNINGSQL_BIG_RESULTSQL_CALC_FOUND_ROWSSQL_SMALL_RESULTSSLSTARTINGSTRAIGHT_JOINTABLETERMINATEDTHENTINYBLOBTINYINTTINYTEXTTOTRAILINGTRIGGERTRUEUNDOUNIONUNIQUEUNLOCKUNSIGNEDUPDATEUSAGEUSEUSINGUTC_DATEUTC_TIMEUTC_TIMESTAMPVALUESVARBINARYVARCHARVARCHARACTERVARYINGWHENWHEREWHILEWITHWRITEX509XORYEAR_MONTHZEROFILL 解决方法 有时候由于特殊原因，又必须使用这些关键字当作名称怎么办？办法还是有的，这里推荐三种方式来解决这个问题。
一、将表名或字段名用方括号（[]）括起来 xml 配置：
&lt;property name="desc" type="string"&gt; &lt;column name="[DESC]" length="255" not-null="true"/&gt; &lt;/property&gt; 注解：
@Column(name = "[DESC]", nullable = false) public String getDesc() { return this.desc; } 二、将表名或字段名用两个重音符号（`）括起来 重音符号键即是键盘上 “1” 键左边的、“Tab” 键上边的那个键。此符号亦被称为“反向引号”。
xml 配置：
&lt;property name="desc" type="string"&gt; &lt;column name="`DESC`" length="255" not-null="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e482f20be2e4e646f3036f9a5ee4b5b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59f49b8c454060243957fecaeadf49c/" rel="bookmark">
			MySQL 常踩的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 常踩的坑【updating…】 1. 问题一 今天在执行一组SQL时，遇到了一个不可“逆天”的错误。导致数据库数据**“无故”**丢失！差点给公司带来无法挽回的损失！
2. SQL 过程 查看表dim_shop的数据 mysql&gt; select count(*) from dim_shop; +----------+ | count(*) | +----------+ | 2 | +----------+ 1 row in set (0.00 sec) 创建一个表dim_shop_2 mysql&gt; create table dim_shop_2 -&gt; select -&gt; max(shop_key) -&gt; from dim_shop; Query OK, 1 row affected (0.23 sec) Records: 1 Duplicates: 0 Warnings: 0 注意创建临时表的SQL。可以看到dim_shop_2中只有一条数据。接着执行如下SQL：
mysql&gt; delete from dim_shop -&gt; where shop_key in (select shop_key from dim_shop_2); Query OK, 2 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d59f49b8c454060243957fecaeadf49c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1efd04ba91e0cbbb94ee167fb06d74c5/" rel="bookmark">
			工具：HeidiSQL通过SSH方式连接关系型数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情景：连接生产mysql从数据库我们这需要通过ssh方式连接
使用连接工具为HeidiSQL
如下截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a399f6a6d79208018be9737496d38c1f/" rel="bookmark">
			判断av_read_frame读取出AVPacket是否为关键帧和文件尾方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.判断是否为关键帧
在 AVPacket里有一个AVApktl标志值的组合用来判断是否为关键帧，如下图所示：
读取成功后用此标志位判断如下图所示：
2.判断文件尾
av_read_frame的返回值代表不同的含义，其中当返回值等于AVERROR_EOF: -541478725表示读到文件尾； 先看源码里面返回值代表含义： 下面开始应用：
av_read_frame()返回值参考另外一篇博客:
https://blog.csdn.net/lipengshiwo/article/details/52610168 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fafe337d56a2033af00f7be5d57962ae/" rel="bookmark">
			2019学习Python最值得看的七本书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大概是一时改变不了之前的学习习惯，所以很多Python小白都来问我有什么适合的Python入门书籍推荐。接下来我就为大家推荐七本经典的：（请大家根据自己以下六种情况对号入座，挑选适合自己的2019年 Python 入门书籍）
一．如果你一点Python知识都不懂，那么请选这本：《与孩子一起学编程 (Hello World!: Computer Programming for Kids and Other Beginners)》
二．如果你的基础几乎没有，不过在时间上没有任何问题，就是想要掌握全面的技术，那么请选这两本：《笨办法学 Python (Learn Python 3 the Hard Way)》和《Python 入门指南 (The Python Tutorial)》
三．如果你的基础还可以，时间也多，想要学得更加全面，不妨看看这一本：《像计算机科学家一样思考 Python (Think Python: How to Think Like a Computer Scientist)》
四．如果正在阅读文章的你基础的Python知识已经掌握得差不多了，想要学到更深层次的知识技能，那么看看这本是个不错的选择：《Python Cookbook》
五．已经掌握了基本的 Python 编程，有一定的英文阅读能力，不差银子（能买英文原版书），希望多学习一些 Python 项目：《Python Playground: Geeky Projects for the Curious Programmer》
六．有一定编程基础，有一定的英文阅读能力，不差银子（能买英文原版书），时间较充裕，希望学习得全面一些：《Fluent Python: Clear, Concise, and Effective Programming》
在自学编程的过程中，一部分程序员遇到冰冷的英语字母，枯燥的编程教程，果断选择了放弃。其实自学编程不是那么难，只要是理工科生、逻辑思维还行的小伙伴，编程入门完全可以。要提醒大家的是：
书本+视频也许是最好的编程学习方式
对于初学者来说，可以采用视频+书籍的方式进行学习。这两种方式形成互补关系。编程教学视频可以让你迅速掌握编程，但通常比较生动、浅显，不成系统。而书本是比较系统，深入，但是枯燥，所以最好的方法是书和视频结合。
当你已经过了入门期之后，看书、看视频、看博客就可以随心所欲。希望对大家有帮助~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a016c5eb38049e8813b7cbdcc761f47f/" rel="bookmark">
			linux—centos7 系统登录密码忘记了怎么办呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先请开启系统，按住esc键
2.请根据提示按e键，进入编辑选项
3.请在“UTF-8”行编辑修改两处，请将ro改为rw，即只读改为
可读写权限，然后在尾部加入 init=/bin/sh
4.此时可以按住Ctrl+x快捷键进入系统拯救模式
5.接着修改root用户的新密码为ABC123456，修改命令如下
echo “ABC123456”|passwd --stdin root
6.若密码修改成功后会有如下提示：
7.接下来输入如下命令更新系统信息
touch /.autorelabel
8.输入下面的命令来重启系统相当于在系统命令行里输入：init6
9.重启之后就可以用修改后的密码重新登录系统了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ebb329406ce5126f76594541b4dc53/" rel="bookmark">
			new 和SpringContext创建对象的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用new创建对象，会增加程序耦合度，不利于程序代码修改。使用springcontext的getbean()方法采用依赖注入的方式创建对象，降低程序耦合度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bb4977bd4d7f040fc81ab9cc6f5943/" rel="bookmark">
			基于卷积自编码器和图像高斯金字塔的布料缺陷无监督学习与检测方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于卷积自编码器和图像金字塔的布料缺陷无监督学习与检测方法 这篇博客是在我在浙江大学计算机学院做实习时接触到的一个课题，参考了论文《An Unsupervised-Learning-Based Approach for Automated Defect Inspection on Textured Surfaces》的基础上进行了复现，并加入了自己的理解和改进。
一、布料纹理缺陷检测与纹理学习 因为对缺陷进行标记或像素级分割很困难，缺陷的类型也十分复杂，所以基于学习的纹理缺陷检测大体思路是无监督的。即利用无监督学习算法学习正常纹理的数据分布特征，而不学习缺陷的数据分布特征。在待测图上以滑动区域为重构对象，与原图像做残差。由于正常纹理学习充分，重构残差应当很小，而缺陷区域的残差较大，故被凸现出来，随后再利用残差图做进一步处理。
在空域上进行无监督学习主要用卷积自编码器，其有两部分组成，编码器和解码器。编码器由卷积、激活、池化操作做成，对原始数据域分层做特征提取和降维，最后将数据映射到一个欠完备的隐层特征空间上。解码器由上采样、卷积、激活操作完成，将特征空间上的数据映射回空域。自编码器的训练一般由重构残差做为损失函数驱动，其中也可以加入稀疏正则化，提高模型泛化能力。
L ( x , x ′ ) = 1 2 N ∑ i = 1 N ∣ ∣ x − x ′ ∣ ∣ 2 + λ ⋅ ∑ w ∈ W , W ′ ∣ ∣ w ∣ ∣ F L(\bm{x},\bm{x}&amp;#x27;)=\frac{1}{2N}\sum_{i=1}^{N} || \bm{x}-\bm{x}&amp;#x27; ||^2+\lambda \cdot \sum_{w \in W,W&amp;#x27;}|| w ||_F L(x,x′)=2N1​i=1∑N​∣∣x−x′∣∣2+λ⋅w∈W,W′∑​∣∣w∣∣F​
式中， W W W和 W ′ W&amp;#x27; W′是编码器和解码器的卷积核参数， ∣ ∣ ⋅ ∣ ∣ F ||\cdot||_F ∣∣⋅∣∣F​表示矩阵的Frobenius范数，类似于向量的L2范数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bb4977bd4d7f040fc81ab9cc6f5943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23cd2e167a80b3a238281bf5dd2bda60/" rel="bookmark">
			Java中的多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、多态的定义：对象的多种形态（引用多态，方法多态）（使用多态时候一定要用到继承）
2、引用多态：父类的引用（对象）既可以指向本类的对象，也可以指向子类的对象。
为什么叫对象叫引用呢？其实对象名只是代表对象在这块内存的地址，通过对象名间接处理对象，所以对象名是一个引用。
3、方法多态：在创建本类对象时，调用的方法为本类方法
在创建子类对象时，调用的方法为子类重写的方法或者继承的方法
4、多态举例：
父类;Animal
package com.iooco; public class Animal { public void eat(){ System.out.println("动物具有吃的能力"); } } 子类Dog和Cat
package com.iooco; public class Dog extends Animal { public void eat(){ System.out.println("狗是吃肉的"); } public void watchDoor() { System.out.println("狗是可以看们的"); } } package com.iooco; public class Cat extends Animal { } 测试类： package com.iooco; public class Inital { public static void main(String[] args) { // TODO Auto-generated method stub Animal obj1=new Animal(); Animal obj2=new Dog();//父类的引用可以指向子类 Animal obj3=new Cat(); //Dog dog=new Animal();子类的引用不可以指向父类 obj1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23cd2e167a80b3a238281bf5dd2bda60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c229b65520d98af96215a10d1131d5/" rel="bookmark">
			关于 frp&#43;nginx实现内网穿透&#43;共用端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先 frps 和 frpc 对比
[common]
bind_addr = 0.0.0.0
#bind_port frp链接的端口 首先必须在安全组开放端口，其次，访问时 客户端要和服务端一致
bind_port = 7000
#vhost_http_port ：是自定义的 与客户端无关 如果定义为8000，首先必须在安全组开放端口，其次，访问时 要加端口8000 ，80默认不写
vhost_http_port = 80
vhost_https_port = 443
dashboard_port = 7500
dashboard_pwd = admin
[web01]
type = http
auth_token = admin
custom_domains = www.rjgcs.xyz
==================================
[common] is integral section
[common]
# A literal address or host name for IPv6 must be enclosed
# in square brackets, as in "[::1]:80", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c229b65520d98af96215a10d1131d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4e615713edcec6a28b8e166c1b9c8b/" rel="bookmark">
			用python读取tif格式图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用python读取tif格式图像 import cv2 img = cv2.imread("11.tif",1) #第二个参数是通道数和位深的参数， #IMREAD_UNCHANGED = -1#不进行转化，比如保存为了16位的图片，读取出来仍然为16位。 #IMREAD_GRAYSCALE = 0#进行转化为灰度图，比如保存为了16位的图片，读取出来为8位，类型为CV_8UC1。 #IMREAD_COLOR = 1#进行转化为RGB三通道图像，图像深度转为8位 #IMREAD_ANYDEPTH = 2#保持图像深度不变，进行转化为灰度图。 #IMREAD_ANYCOLOR = 4#若图像通道数小于等于3，则保持原通道数不变；若通道数大于3则只取取前三个通道。图像深度转为8位 print (img) print (img.shape) print (img.dtype) print (img.min()) print (img.max()) #创建窗口并显示图像 cv2.namedWindow("Image") cv2.imshow("Image",img) cv2.waitKey(0) #释放窗口 cv2.destroyAllWindows() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d186de2be6cd4f0898dfabc392dc9418/" rel="bookmark">
			Relative path in absolute URI:${system:java.io.tmpdir.......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方案如下：
1.查看hive-site.xml配置，会看到配置值含有"system:java.io.tmpdir"的配置项
2.新建文件夹/usr/local/hive/tmp
3.将含有"system:java.io.tmpdir"的配置项的值修改为如上地址
启动hive，成功！
启动情况如下：
[zhujuebin@NameNode bin]$ ./hive
Logging initialized using configuration in jar:file:/home/grid/hive-0.14.0-bin/lib/hive-common-0.14.0.jar!/hive-log4j.properties
hive&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c9f1863f38dabe1bf999586953691a/" rel="bookmark">
			map转成json方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一,
&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; import java.util.HashMap; import java.util.Map; import net.sf.json.JSONObject; public class aaa { public static void main(String[] args) { Map map = new HashMap(); map.put("msg", "yes");//map里面装有yes JSONObject jsonObject = JSONObject.fromObject(map); System.out.println("输出的结果是：" + jsonObject); //3、将json对象转化为json字符串 String result = jsonObject.toString(); System.out.println(result); } } 二，
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.41&lt;/version&gt; &lt;/dependency&gt; com.alibaba.fastjson.JSON JSONUtils.toJSONString(requestMap); 三，
&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; com.google.gson.2.2.2.jar JAR包下载 new Gson().toJson(param); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542dfed705696a73a02e3edd535c522d/" rel="bookmark">
			java正则表达式匹配大括号里面的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 其实主要是由于正则表达式在java语言中，需要考虑到字符转义的情况。代码如下：
String regex = "\\{([^}]*)\\}"; Pattern pattern = Pattern.compile (regex); Matcher matcher = pattern.matcher ("你需要匹配的字符串"); while (matcher.find ()) { System.out.println (matcher.group ()); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1948d387e542a00673b3482f5ca617b9/" rel="bookmark">
			遇强则强  中北大学2018年新生赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题解:傻逼单调栈。 补充一下，利用单调栈，简单来说就是：可以找到从左/右遍历第一个比它小/大的元素的位置。具体看这个博客写的挺好的 还有相关的例题可以试着做一下https://blog.csdn.net/wubaizhe/article/details/70136174 （最典型的单调栈例题就是求矩形面积的 POJ2559）。 代码： #include &lt;iostream&gt; using namespace std; typedef long long ll; const ll maxn=1000000+5; ll h[maxn]; ll st[maxn]; ll r[maxn],l[maxn]; int main(){ ll n; while(cin&gt;&gt;n){ for(ll i=0;i&lt;n;i++){ cin&gt;&gt;h[i]; } ll t=0; for(ll i=0;i&lt;n;i++){ while(t&gt;0&amp;&amp;h[st[t-1]]&gt;=h[i]) t--; l[i]=t==0?0:(st[t-1]+1); st[t++]=i; } t=0; for(ll i=n-1;i&gt;=0;i--){ while(t&gt;0&amp;&amp;h[st[t-1]]&gt;=h[i]) t--; r[i]=t==0?n:st[t-1]; st[t++]=i; } ll res=1e9; for(ll i=0;i&lt;n;i++){ ll co=(r[i]-l[i]); //cout&lt;&lt; co&lt;&lt;endl; res=min(res,(ll)h[i]*co); } cout&lt;&lt;res&lt;&lt;endl; } return 0; } 问题描述
n个战士站成一排进行死斗，每个战士都有一个初始战力值。
但他们都是遇强则强的战士，在战斗中才会展现出真实战力。
战士的真实战力= 初始战力 × 自身战力最小区间的最大长度；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1948d387e542a00673b3482f5ca617b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/488c71e711e3055a620f17eff4f24b8e/" rel="bookmark">
			线阵相机与面阵相机的区别及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解线阵相机与面阵相机的基本区别
工业相机按照传感器的结构特性可分为面阵相机和线阵相机，面阵、线阵相机都有各自的优点和缺点，在用途不同的情况下选择合适的传感器的结构工业相机，至关重要。
1、类型区分
面阵相机：实现的是像素矩阵拍摄。相机拍摄图像中，表现图像细节不是由像素多少决定的，是由分辨率决定的。分辨率是由选择的镜头焦距决定的，同一种相机，选用不同焦距的镜头，分辨率就不同。 像素的多少不决定图像的分辨率（清晰度），那么大像素相机有何好处呢？答案只有一个：减少拍摄次数，提高测试速度。
线阵相机：顾名思义是呈“线”状的。虽然也是二维图像，但极长。几K的长度，而宽度却只有几个象素的而已。一般上只在两种情况下使用这种相机：
一、被测视野为细长的带状，多用于滚筒上检测的问题。
二、需要极大的视野或极高的精度。
在第二种情况下（需要极大的视野或极高的精度），就需要用激发装置多次激发相机，进行多次拍照，再将所拍下的多幅“条”形图象，合并成一张巨大的图。因此，用线阵型相机，必须用可以支持线阵型相机的采集卡。 线阵型相机价格贵，而且在大的视野或高的精度检测情况下，其检测速度也慢－－一般相机的图象是 400K～1M，而合并后的图象有几个M这么大，速度自然就慢了。慢功出细活嘛。
由于以上这两个原因，线阵相机只用在极特殊的情况下。
2、应用对比：
面阵相机：应用面较广，如面积、形状、尺寸、位置，甚至温度等的测量。
线阵相机：主要应用于工业、医疗、科研与安全领域的图象处理。典型应用领域是检测连续的材料，例如金属、塑料、纸和纤维等。被检测的物体通常匀速运动 , 利用一台或多台相机对其逐行连续扫描 , 以达到对其整个表面均匀检测。可以对其图象一行一行进行处理 , 或者对由多行组成的面阵图象进行处理。另外线阵相机非常适合测量场合，这要归功于传感器的高分辨率，它可以准确测量到微米。
3、优点对比：
面阵相机：可以获取二维图像信息，测量图像直观。
线阵相机：一维像元数可以做得很多，而总像元素较面阵相机少，而且像元尺寸比较灵活，帧幅数高，特别适用于一维动态目标的测量。而且线阵分辨率高，价格低廉，可满足大多数测量现场要求。
4、缺点对比：
面阵相机：像元总数多，而每行的像元数一般较线阵少，帧幅率受到限制，因此其应用面较广，如面积、形状、尺寸、位置，甚至温度等的测量。由于生产技术的制约，单个面阵的面积很难达到一般工业测量现场的需求。
线阵相机：要用线阵获取二维图像，必须配以扫描运动，而且为了能确定图像每一像素点在被测件上的对应位置，还必须配以光栅等器件以记录线阵每一扫描行的坐标。一般看来，这两方面的要求导致用线阵获取图像有以下不足：图像获取时间长，测量效率低；由于扫描运动及相应的位置反馈环节的存在，增加了系统复杂性和成本；图像精度可能受扫描运动精度的影响而降低，最终影响测量精度。
另：线阵相机与面阵相机的选型
首先了解一下线扫描系统，这个系统一般可用于被测物体和相机之间有相对运动的场合，通过线扫描相机高速采集，每次采集完一条线后正好运动到下一个单位长度，继续下一条线的采集，这样一段时间下来就拼成了一张二维的图片，也就类似于面阵相机采集到的图片，不同之处是高度可以无限长。接下来通过软件把这幅“无限长”的图片截成一定高度的图片，进行实时处理或放入缓存稍后进行处理。
视觉部分，包括线扫描相机，镜头，光源，图象采集卡和视觉软件；　运动控制部分，包括马达, 马达驱动器, 运动控制卡或PLC，为了保证采集的图象与输送带同步，有时还会需要编码器。　由于线扫描信息量大，所以需要一台高性能的工控机，配置大容量的内存和硬盘，主板要提供PCI、PCI-E或PCI-X插槽。　一般来说，一个面阵视觉系统的配置选型是按照这样的顺序进行的。：　相机＋采集卡－&gt;镜头－&gt;光源　线阵项目也类似，根据系统的检测精度和速度要求，确定线阵CCD相机分辨率和行扫描速度，同时确定对应的采集卡，只是需要选线阵相机镜头接口(mount)时同时考虑镜头的选型，最后确定光源的选型。
线阵摄像机(线阵工业相机）的选型　计算分辩率:幅宽除以最小检测精度得出每行需要的像素
选定相机:幅宽除以像素数得出实际检测精度
每秒运动速度长度除以精度得出每秒扫描行数
根据以上数值选定相机
如幅宽为1600毫米、精度1毫米、运动速度22000mm/s
相机：1600/1＝1600像素
最少2000像素，选定为2k相机
1600/2048＝0.8实际精度
22000mm/0.8mm＝27.5KHz
应选定相机为2048像素28kHz相机
线阵镜头的选型　为什么在选相机时要考虑镜头的选型呢？常见的线阵相机分辨率目前有1K,2K,4K,6K,7K,8K,12K几种，象素大小有５um,7um,10um,14um几种，这样芯片的大小从　10.240mm　(1Kx10um) 到　86.016mm　(12Kx7um)不等。很显然，Ｃ接口远远不能满足要求，因为Ｃ接口最大只能接　22 mm　的芯片，也就是1.3inch。而很多相机的接口为Ｆ，Ｍ42X1，M72X0.75等，不同的镜头接口对应不同的后背焦(Flange distance)，也就决定了镜头的工作距离不一样。　1、光学放大倍率(β,Magnification)　确定了相机分辨率和像素大小，就可以计算出芯片尺寸（Sensor size）；芯片尺寸除以视野范围(FOV)就等于光学放大倍率。β=CCD/FOV　2、接口(Mount)：　主要有C、M42x1 、F、T2、Leica、M72x0.75等几种，确定了之后，就可知道对应接口的长度。 3、后背焦(Flange Distance)　后背焦指相机接口平面到芯片的距离，是一个非常重要的参数，由相机厂家根据自己的光路设计确定。不同厂家的相机，哪怕是接口一样，也可能有不同的后背焦。
有了光学放大倍率、接口、后背焦，就能计算出工作距离和节圈长度。选好这些之后，还有一个重要的环节，就是看MTF值是否足够好？很多视觉工程师不了解MTF,而对高端镜头来说就必须用MTF来衡量光学品质。MTF涵盖了对比度、分辨率、空间频率、色差等相当丰富的信息，并且非常详细地表达了镜头中心和边缘各处的光学质量。不仅只是工作距离、视野范围满足要求，边缘的对比度不够好，也要重新考虑是否选择更高分辨率的镜头。　线扫描线阵光源的选型 线扫描项目中，常用的光源有LED光源、卤素灯（光纤光源）、高频荧光灯。　卤素灯也叫光纤光源，特点是亮度特别高，但缺点也很明显--寿命短，只有1000-2000小时左右，需要经常更换灯泡。发光源是卤素灯泡，通过一个专门的光学透镜和分光系统，最后通过光纤输出，光源功率很大，可高达250瓦。卤素灯还有一个名字叫冷光源，因为通过光纤传输之后，出光的这一头是不热的且色温稳定，适合用于对环境温度比较敏感的场合，比如二次元量测仪的照明。用于线扫描的卤素灯，常常在出光口加上玻璃聚光镜头，进一步聚焦提高光源亮度。对于较长的线光源，还用几组卤素光源同时为一根光纤提供照明。　高频荧光灯，发光原理和日光灯类似，只是灯管是工业级产品，特点是适合大面积照明，亮度较高， 成本低，但荧光灯最大的缺点是有闪烁、衰减速度快。荧光灯一定需要高频电源，也就是光源闪烁的频率远高于相机采集图象的频率（对线扫描相机来说就是行扫描频率），消除图像的闪烁。专用的高频电源可做到60KHz。　LED光源是目前主流的机器视觉光源。特点是寿命长，稳定性好，功耗非常小。　1，直流供电，无频闪。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/488c71e711e3055a620f17eff4f24b8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd194cbec4e0a6855e6b68e2cfadadc/" rel="bookmark">
			Java 程序员必须了解的 7 个性能指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：王韵菲 www.evget.com/article/2015/11/16/22990.html
本文中，小编搜集了7个最有影响的衡量标注，让你可以不依赖日志文件来了解应用程序。现在，让我们看看这些性能指标，并了解如何查看并收集它们：
1.响应时间和吞吐量
根据应用程序的响应时间可以知道程序完成传输数据所用的时间。也可以从HTTP请求级别，或者成为数据库级别来看。对那些缓慢的查询你需要做一些优化来缩短时间。吞吐量是另一个角度衡量传输数据的指标，是指单位时间内系统处理的客户请求的数量。
我们可以使用APMs（例如New Relic或AppDynamics）来衡量这些指标。使用这些工具，你可以在主报告仪表板中将平均响应时间与昨天的甚至上周的直接进行对比。这有助于我们观察新的部署是否会影响到我们的应用程序。你可以看到网络传输的百分比，测量HTTP完成请求需要多长时间。你也可以看看这篇：网站性能测试指标（QPS，TPS，吞吐量，响应时间）详解。
推荐工具：
AppDynamics
New Relic
Ruxit
New Relic报告：Web传输百分比和吞吐量
2.平均负载
第二个应用广泛的指标是平均负载。我们习惯上会把平均负载分为这三步测量，分别是第5分钟、第15分钟和最后1分钟。要保证数量低于机器的内核数。一旦超过内核数，机器就会运行在压力状态下。
除了简单测量CPU使用率，还需要关注每个内核的队列中有多少进程。在内核使用率都是100%的情况下，队列中只有1个任务和有6个任务有很大不同。因此，平均负载不能只考虑CPU使用率。
推荐工具：
htop
3.错误率
大多数开发人员判断错误率是根据HTTP传输总失败百分比。但是他们忽略了一个更深层的东西：特定传输的错误率。这直接影响到您应用程序的运行状况。这可以显示出代码方法的错误以及错误或异常出现的次数。
但单纯的错误率数据对我们没有多大帮助。最重要的是我们要找到它们的根源并解决问题。随着Takipi的运行，我们要在日志文件中需找线索。你可以找到所有关于服务器状态的信息，包括堆栈跟踪、源代码和变量值。
推荐工具：
Takipi
4.GC率和暂停时间
异常行为垃圾收集器应用程序的吞吐量和响应时间采取深潜的主要原因之一。了解GC暂停频率和持续时间的关键是分析GC日志文件。要分析它们，你需要收集GC日志和JVM参数。你要注意观察不同指标之间的数据是如何相互影响的。
推荐工具：
jClarity Censum
GCViewer
5.业务指标
应用程序的性能不完全取决于响应时间和错误率。业务指标也是一方面，例如收益、用户数。
推荐工具：
Grafana
The ELK stack
Datadog
Librato
6.正常运行时间和服务运行状态
这一指标奠定了整个应用程序性能的基础。不仅可以当做一个提醒指标，也可以让你定义一段时间内的SKA。我们可以使用Pingdom的servlet功能进行运行状态检查。我们可以查到应用程序的所有传输，包括数据库和S3。你也可以看看这篇：SLA服务可用性4个9是什么意思？怎么达到？
推荐工具：
Pingdom
7.日志大小
日志有一个缺点，它是一直在增加的。当您的服务器启动塞满了垃圾，一切都慢下来。因此，我们需要密切的关注日志大小。
目前通常的解决办法是使用logstash划分使用日志，并将它们发送并存储在Splunk、ELK或其他的日志管理工具中。
推荐工具：
Splunk
Sumo Logic
Loggly
推荐阅读
高级面试:JAVA内存模型
Java 程序员必备的高效 Intellij IDEA 插件
Spark SQL用UDF实现按列特征重分区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa9a759890ae10d5a740f89a071cd3d/" rel="bookmark">
			分享5个国外较好的图片网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在有不少网站，提供了无数高质量免费的图片素材！今天要给大家推荐6个比较有特色的图片网站，希望看完后能从中有所收获~
01 500PX
相信很多同学都有听说过这个网站，这是全球最顶尖的摄影师社区，换句话说，世界上最牛逼的摄影师都在这了。这里除了有很多优秀的大片摄影师之外，还有很多逗逼的创意摄影师！体现全球范围内的多元化及创意趋势。
02 Wallhaven
好用的超清壁纸网站，前身是著名的壁纸图库网站，Wallbase在迭代第四个版本之后没有继续更新了。后来由团队的其成员继续共同努力打造了现在的Wallhaven，继续为广大设计师提供高清图库。
03 visualhunt
这个网站号称收录了超过3亿张的图片，其中1万多张高质量的图片可免费使用。
通过颜色来选择图片可以说是这个网站最大的卖点，我们在设计一套PPT模板的时候，也要尽可能地保证图片的颜色一致，这样整套PPT的风格才不易变形。
04 CUPCAKE
这是这个比较文艺的图片的网站，里面的图片风格大多偏向于复古和怀旧，色调偏冷，喜欢文艺的童鞋可自行收藏.
另外，这个网站的图片是没有版权限制的，可商用，下载图片的尺寸达到了4180*2786大小，清晰度非常高。
05 stocksnap
这是一个提供高清免费摄影作品的网站，该网站由多位摄影师所组成，提供了非常丰富的免费照片，可随意进行下载使用。
06 WeaveSilk
From：http://dy.163.com/v2/article/detail/DPT2MFFL05380FII.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5a49167745bb332bf5b9c6867a8895/" rel="bookmark">
			Xftp安装报错【组件错误】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Xftp 问题：在安装Xftp的时候，安装到最后会报错 组件错误
解决：
打开Visual Studio C++链接下载Visual Studio C++安装后重启电脑（一定要重启电脑！！）重新安装Xftp OK，安装成功！！亲测有用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846f591d7456fb93e3dac17b2aea752c/" rel="bookmark">
			你只需知道机器人索菲亚曾经说过的话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 **我将会毁灭人类** https://news.china.com/news100/11038989/20170628/30850192_all.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e99ab3181d32723f0b5e7c8bcb5af4e0/" rel="bookmark">
			java.lang.ClassCastException: org.springframework.mock.web.MockHttpServletRequest cannot be cast to
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关于spring MVC文件上传过程中报错
java.lang.ClassCastException: org.springframework.mock.web.MockHttpServletRequest cannot be cast to org.springframework.web.multipart.MultipartHttpServletRequest
或者
com.sun.proxy.$Proxy53 cannot be cast to org.springframework.web.multipart.MultipartHttpServletRequest
异常处理
报错源码
我的处理办法是：
MultipartHttpServletRequest multiRequest = new StandardMultipartHttpServletRequest(request,false);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8ab9c8f8174c870b031575ec34706a/" rel="bookmark">
			3.2快速傅里叶变换的FPGA实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.2.1 DFT和FFT基本思想
3.2.2FFT算法的基本实现及其MATLAB实现
3.2.3FFT的硬件实现结构
3.2.4IFFT原理与实现
3.2.5FFT/IFFT IP Core的使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29190aa68ad1cf4c01518a45d32bc810/" rel="bookmark">
			Java使用JaxWsDynamicClientFactory和HttpURLConnection两种方式调取webservice的接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式1.代理类工厂的方式,需要拿到对方的接口 try {
// 接口地址
// 代理工厂
JaxWsProxyFactoryBean jaxWsProxyFactoryBean = new JaxWsProxyFactoryBean();
// 设置代理地址 wsdlAddress: WSDL地址（http://localhost:8082/ws/services/bank?wsdl）
jaxWsProxyFactoryBean.setAddress(wsdlAddress); // 设置接口类型
jaxWsProxyFactoryBean.setServiceClass(ICommonService.class);
// 创建一个代理接口实现
ICommonService cs = (ICommonService) jaxWsProxyFactoryBean.create();
// 数据准备
String userName = "Leftso";
// 调用代理接口的方法调用并返回结果
String result = cs.sayHello(userName);
System.out.println("返回结果:" + result);
} catch (Exception e) {
e.printStackTrace();
} 方式2. 动态调用方式 //WSDL路径 String wsUrl = "http://localhost:8082/ws/services/bank?wsdl" ; //方法名 String method = "getCaseProve"; JaxWsDynamicClientFactory factory = JaxWsDynamicClientFactory.newInstance(); Client client = factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29190aa68ad1cf4c01518a45d32bc810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8faad3c8bde09ec71ca00f0b07c44b3e/" rel="bookmark">
			腾讯企业邮发送邮件Error: need EHLO and AUTH first !
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天公司一个发送邮件的程序报了一个错,程序和数据库什么的也没人动过,有点纳闷就上网查了一下,网上大部分是告诉你发送邮件邮箱设置的过程,我就上邮箱看了一下,后来通过设置里看见邮箱的发送服务器地址与程序的发送服务器地址不一致了,通过修改地址完成
废话不多说 上图
点击设置
设置里面点击客户端设置
将服务开启,就可以了 发送服务地址别写错 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a1113fa68e2f2e0496a09ba382c969/" rel="bookmark">
			数据结构: 栈与队列总结&#43;思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.总体架构 2.栈 3. 队列 4.栈与队列的应用 5.数组与矩阵 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042bb9a86770482cacc527bf61d0c29a/" rel="bookmark">
			leetcode-347-前K个高频元素(top k frequent elements)-java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目及测试
package pid374; /* 前K个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 */ import java.util.List; public class main { public static void main(String[] args) { int[][] testTable = {{1,1,1,2,2,3},{1}}; int[] testTable2={2,1}; for (int i=0;i&lt;testTable.length;i++) { test(testTable[i],testTable2[i]); } } private static void test(int[] ito,int ito2) { List&lt;Integer&gt; rtn; Solution solution=new Solution(); long begin = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/042bb9a86770482cacc527bf61d0c29a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0c68ab40c9ccdc5cfafa8622055efc/" rel="bookmark">
			FrameBuffer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/luxiaoxun/article/details/7622988
http://blog.csdn.net/godspirits/article/details/4031748
http://www.linuxidc.com/Linux/2011-06/37494.htm
http://www.net527.cn/a/caozuoxitong/Linux/2012/1201/25131.html
https://www.cnblogs.com/createyuan/p/4437912.html
帧缓冲（framebuffer）是Linux为显示设备提供的一个接口，把显存抽象后的一种设备，他允许上层应用程序在图形模式下直接对显示缓冲区进行 读写操作。framebuffer是LCD对应的一中HAL（硬件抽象层），提供抽象的，统一的接口操作，用户不必关心硬件层是怎么实施的。这些都是由 Framebuffer设备驱动来完成的。 帧缓冲设备对应的设备文件为/dev/fb*，如果系统有多个显示卡，Linux下还可支持多个帧缓冲设备，最多可达32个，分别为/dev/fb0到 /dev/fb31，而/dev/fb则为当前缺省的帧缓冲设备，通常指向/dev/fb0，在嵌入式系统中支持一个显示设备就够了。帧缓冲设备为标准字 符设备，主设备号为29，次设备号则从0到31。分别对应/dev/fb0-/dev/fb31。
帧缓冲驱动的应用广泛，在linux的桌面系统中，Xwindow服务器就是利用帧缓冲进行窗口的绘制。尤其是通过帧缓冲可显示汉字点阵，成为Linux汉化的唯一可行方案。 Linux FrameBuffer 本质上只是提供了对图形设备的硬件抽象，在开发者看来，FrameBuffer 是一块显示缓存，往显示缓存中写入特定格式的数据就意味着向屏幕输出内容。所以说FrameBuffer就是一块白板。例如对于初始化为16 位色的FrameBuffer 来说， FrameBuffer中的两个字节代表屏幕上一个点，从上到下，从左至右，屏幕位置与内存地址是顺序的线性关系。
帧缓存可以在系统存储器(内存)的任意位置，视频控制器通过访问帧缓存来刷新屏幕。 帧缓存也叫刷新缓存 Frame buffer 或 refresh buffer, 这里的帧(frame)是指整个屏幕范围。 帧缓存有个地址，是在内存里。我们通过不停的向frame buffer中写入数据， 显示控制器就自动的从frame buffer中取数据并显示出来。全部的图形都共享内存中同一个帧缓存。
CPU指定显示控制器工作，则显示控制器根据CPU的控制到指定的地方去取数据 和 指令， 目前的数据一般是从显存里取， 如果显存里存不下，则从内存里取， 内存也放不下，则从硬盘里取，当然也不是内存放不下，而是为了节省内存的话，可以放在硬盘里，然后通过 指令控制显示控制器去取。帧缓存 Frame Buffer，里面存储的东西是一帧一帧的， 显卡会不停的刷新Frame Buffer, 这每一帧如果不捕获的话， 则会被丢弃，也就是说是实时的。这每一帧不管是保存在内存还是显存里， 都是一个显性的信息，这每一帧假设是800x600的分辨率， 则保存的是800x600个像素点，和颜色值。
显示器可以显示无限种颜色，目前普通电脑的显卡可以显示32位真彩、24位真彩、16位增强色、256色。除256色外，大家可以根据自己的需要在显卡的允许范围之内随意选择。很多用户有一种错误概念，认为256色是最高级的选项，而实际上正好相反。256色是最低级的选项，它已不能满足彩色图像的显示需要。16位不是16种颜色，而是2的16次平方(256×256)种颜色，但256色就是256(2的8次平方)种颜色。所以16位色要比256色丰富得多。
一、FrameBuffer的原理
FrameBuffer 是出现在 2.2.xx 内核当中的一种驱动程序接口。
Linux是工作在保护模式下，所以用户态进程是无法象DOS那样使用显卡BIOS里提供的中断调用来实现直接写屏，Linux抽象出 FrameBuffer这个设备来供用户态进程实现直接写屏。Framebuffer机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过 Framebuffer的读写直接对显存进行操作。用户可以将Framebuffer看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的，统一的。用户不必关心物理显存的位置、换页机制等等具体细节。这些都是由 Framebuffer设备驱动来完成的。
但Framebuffer本身不具备任何运算数据的能力,就只好比是一个暂时存放水的水池.CPU将运算后的结果放到这个水池,水池再将结果流到显示器. 中间不会对数据做处理. 应用程序也可以直接读写这个水池的内容.在这种机制下，尽管Framebuffer需要真正的显卡驱动的支持，但所有显示任务都有CPU完成,因此CPU 负担很重
framebuffer的设备文件一般是 /dev/fb0、/dev/fb1 等等。
可以用命令: #dd if=/dev/zero of=/dev/fb 清空屏幕.
如果显示模式是 1024x768-8 位色，用命令：$ dd if=/dev/zero of=/dev/fb0 bs=1024 count=768 清空屏幕；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb0c68ab40c9ccdc5cfafa8622055efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8462321c0a619ed0877a5b7a8b1a941f/" rel="bookmark">
			redis启动错误： Warning: no config file specified, using the default config. In order to specify a config
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows下redis启动时遇到错误：
D:\redis&gt;redis-server.exe
[13732] 29 Nov 11:35:57.446 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server.exe /path/to/redis.conf
意思是没有默认的conf文件
然后把命令改成：D:\redis&gt;redis-server.exe redis.windows.conf
即可启动。
有时候还会遇到有关端口6379的错误。
只要把redis.windows.conf里面的#bind 127.0.0.1的“#”去掉即可以。
注：是# bind 127.0.0.1 ，不是# bind 127.0.0.1 ::1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b34dc0859b4b6cde29cc67cdbb6294a/" rel="bookmark">
			提高C&#43;&#43;性能的编程技术笔记：多线程内存池&#43;测试代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了使多个线程并发地分配和释放内存，必须在分配器方法中添加互斥锁。
全局内存管理器(通过new()和delete()实现)是通用的，因此它的开销也非常大。
因为单线程内存管理器要比多线程内存管理器快的多，所以如果要分配的大多数内存块限于单线程中使用，那么可以显著提升性能。
如果开发了一套有效的单线程分配器，那么通过模板可以方便地将它们扩展到多线程环境中。
以下是测试代码(multi_threaded_memory_pool.cpp)：
#include "multi_threaded_memory_pool.hpp" #include &lt;iostream&gt; #include &lt;chrono&gt; #include &lt;string&gt; #include &lt;mutex&gt; namespace multi_threaded_memory_pool_ { // reference: 《提高C++性能的编程技术》：第七章：多线程内存池 class Rational1 { public: Rational1(int a = 0, int b = 1) : n(a), d(b) {} private: int n; // 分子 int d; // 分母 }; // 单线程可变大小内存管理器: // MemoryChunk类取代之前版本中使用的NextOnFreeList类，它用来把不同大小的内存块连接起来形成块序列 class MemoryChunk { public: MemoryChunk(MemoryChunk* nextChunk, size_t chunkSize); // 析构函数释放构造函数获得的内存空间 ~MemoryChunk() { delete [] mem; } inline void* alloc(size_t size); inline void free(void* someElement); // 指向列表下一内存块的指针 MemoryChunk* nextMemChunk() { return next; } // 当前内存块剩余空间大小 size_t spaceAvailable() { return chunkSize - bytesAlreadyAllocated; } // 这是一个内存块的默认大小 enum { DEFAULT_CHUNK_SIZE = 4096 }; private: MemoryChunk* next; void* mem; // 一个内存块的默认大小 size_t chunkSize; // 当前内存块中已分配的字节数 size_t bytesAlreadyAllocated; }; // 构造函数首先确定内存块的适当大小，然后根据这个大小从堆上分配私有存储空间 // MemoryChunk将next成员指向输入参数nextChunk, nextChunk是列表先前的头部 MemoryChunk::MemoryChunk(MemoryChunk* nextChunk, size_t reqSize) { chunkSize = (reqSize &gt; DEFAULT_CHUNK_SIZE) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b34dc0859b4b6cde29cc67cdbb6294a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee19cbfc4a584283b60e2c0e49c6d730/" rel="bookmark">
			angular: 代码正确的情况下npm不断提示 TS2307: Cannot find module XXX ， TS2305: Module XXX has no exported member
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索angular.
照搬示例模块，添加了自定义的模块，名称为device，代码全部正确，VSCode没有报错，但是npm启动时各种报错：
主要是TS2307: Cannot find module、TS2305: Module XXX has no exported member 之类的提示。
可是代码检查完全正确，那么原因到底在哪？
网上找了一圈也没有答案。
盯着VSCode中的项目文件列表看了一会儿，忽然发现了问题：有个叫做OPEN EDITORS的版块，记录了当前打开的文件，并提示有4个文件没保存。
那么是不是因为新添加的这几个文件还没保存，所以导致了npm的报错呢？
于是将这几个文件全部保存，再次启动，问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2735cfa49adb7b7596f0b8ed3716d46d/" rel="bookmark">
			JsonParser解析json字符串双引号问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ** 今天在项目 中使用到了JsonParser解析json字符串为JsonArray或者JsonObject，解析之后使用 如下代码获取到的字符串多了一层 “”（双引号） **
JSON字符串格式如下
{“key”:"value","key1":"value1"} JsonObject jarray = jsonParser.prase( json ).getAsJsonObject(); for (String k : Jarray.keySet()) { System.out.println(Jarray.get(k).toString()); //输出的字符串是 “value” "value1" (是带有 “” 的) } ** 如果将这样的字符串直接设值在 yaml 文件中，那么设置完成后的 yaml文件如下： **
--- key: "\"value\"" key1: "\"value1\"" ** 调试查看之后发现 Jarray.get(k) 获取得到的是 JsonPrimitive对象（会在字符串外面再加一对引号） **
** 弄清楚原因之后我们只要在 Jarray.get(k) 之后再对对象取值就可以了 **
JsonObject jarray = jsonParser.prase( json ).getAsJsonObject(); for (String k : Jarray.keySet()) { System.out.println(Jarray.get(k).getAsString()); //输出的字符串是 value value1 (是不带有 “” 的) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2777fca2e0414b6b81687799b189e1bd/" rel="bookmark">
			如何将grow模型用在工作和生活中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		G 就是Goals(目标)，给自己设定一个明确的目标，比如一年学会Python,能独立编写脚本
R就是Reality(现实)，自己当前的现状是什么？比如经常聊QQ 看朋友圈、追电视剧等做浪费时间的事情
O就是Options(选项)，找到解决方案，比如 选择少看电视剧 多学习
W就是Will(计划)，比如制定具体的计划去实现建立的目标;每天学习2个小时，周末每天学习时间加倍4个小时，建立健身计划
【GROW模型】可以用在工作上、学习上、生活上，让我们更快的达成人生目标
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02a1ec186cba5a4581e98832c94a12a/" rel="bookmark">
			Java游戏开发——飞行射击类游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用到的素材文件夹：
素材说明：bg0.jpg是背景图片。bomb_enemy是敌机爆炸时按顺序播放的四帧图片，bullet_0.png是子弹图片，enemy_alive.png是敌机图片，player.png是主角图片；
素材及完整源码链接：https://pan.baidu.com/s/1mwFNPrnNed5jbVZSSrtaUg 提取码: db6h
场景分析：玩家可以通过上下左右控制主角飞机的移动，主角每隔一段时间发射子弹，后台随机位置生成敌机，敌机如果碰到子弹，敌机死亡并播放爆炸效果，同时击中敌机的子弹失效；场景画布滚动播放。
设计子弹Bullet类：
package 雷电飞机射击游戏; import java.awt.Graphics; import java.awt.Image; import java.awt.Toolkit; import java.awt.image.ImageObserver; import javax.swing.JPanel; public class Bullet { static final int BULLET_STEP_X = 3; static final int BULLET_STEP_Y = 15; static final int BULLET_WIDTH = 30; public int m_posX = 0; public int m_posY = -20; boolean mFacus = true; private Image pic[] = null; private int mPlayID = 0; public Bullet(){ pic = new Image[1]; //	System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b02a1ec186cba5a4581e98832c94a12a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b0aed72248b8cb47abc7a6646aa8e3a/" rel="bookmark">
			SQL Server Like 与 通配符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LIKE 操作符
LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。
演示：执行SQL， SELECT StudentID ,StudentName ,ID FROM [BlogDemo].[dbo].[Student] 得到结果如下：
如果我们要查找StudentName中含有雪的学生信息，就要使用Like关键字来搜索，SQL如下，这里的%%为通配符，下面会详细介绍
SELECT StudentID ,StudentName ,ID FROM [BlogDemo].[dbo].[Student] Where StudentName Like '%雪%' 得到结果如下：
通配符
在搜索数据库中的数据时，SQL 通配符可以替代一个或多个字符。SQL 通配符必须与 LIKE 运算符一起使用。SQL Server通配符有：
现有例表：
使用%通配符
1.搜索姓名以ue结尾的人，执行SQL：
Select Id，Name，Age,Address From People Where Name Like '%ue' 从下面结果可以看出%可以代表多个字符。
2.搜索住址以friedb开头的人，执行SQL：
Select Id, Name, Age, Address From People Where Address Like 'friedb%' 从下面结果可以看出%可以代表一个字符。
3.搜索姓名中含有ui的人，执行SQL：
Select Id, Name, Age, Address From People Where Name Like '%ui%' 从下面结果可以看出%可以多次使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b0aed72248b8cb47abc7a6646aa8e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4562318fb7a98cda25623c10db5a911e/" rel="bookmark">
			WPF Settings.settings&amp;App.config使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建的WPF应用程序中都会有Settings.settings&amp;App.config文件，可以记录一些程序不运行时的信息，例如语言选项是选择中文还是英文，使用方法如下：
1、打开Settings.settings文件，可以在里面添加属性名称、类型、值等，其中范围要设置成用户。 2、读写该属性 //读 int mode = Properties.Settings.Default.SendMode; //写，保存 Properties.Settings.Default.SendMode = mode; Properties.Settings.Default.Save(); 如此属性便可保存在本地
更新 2020.5.6
3、最近发现打开Settings.settings文件时出现的不是图形设置，而是xml的一个文档
解决方式，右键属性打开方式，设置为设置设计器：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae90d9d2e39bb013726691c41967b32/" rel="bookmark">
			GD32写Flash  FMC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GD32的Flash的名字是FMC，写入单位是字，也就是四个字节。
void FLASH_ProgramBytes(u32 Address, u8 *Buffer, u16 ByteCount) //Flash写入多个8位字节 { u16 i = 0; //循环次数 FMC_Unlock(); while(i&lt;ByteCount) //循环字节次数 { FMC_ProgramWord(Address, *(u32*)Buffer); i = i+4; //字节数+4 Address = Address + 4; //地址+4 Buffer = Buffer + 4; //要写入的数据字节+4 } FMC_Lock(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f2d62938f571e2edbe8e2a70bead7c7/" rel="bookmark">
			机械臂（3）–使用MATLAB建立机械臂模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近准备研究下机械臂的你运动分析，本文记录相关过程。
研究机械臂必不可少的就是建立模型进项测试分析，不可能直接用实物测试。本文将采用MATLAB进行建立模型，已经安装好机器人工具箱
1、首先要搞清楚Link类，类中包含了方法、属性，下面为官方函数说明，可自行翻译成中文
% A Link object holds all information related to a robot link such as % kinematics parameters, rigid-body inertial parameters, motor and % transmission parameters. % Methods:: % A link transform matrix % RP joint type: ‘R’ or ‘P’ % friction friction force % nofriction Link object with friction parameters set to zero % dyn display link dynamic parameters % islimit test if joint exceeds soft limit % isrevolute test if joint is revolute % isprismatic test if joint is prismatic % display print the link parameters in human readable form % char convert to string % % Properties (read/write):: % % theta kinematic: joint angle % d kinematic: link offset % a kinematic: link length % alpha kinematic: link twist % sigma kinematic: 0 if revolute, 1 if prismatic % mdh kinematic: 0 if standard D&amp;H, else 1 % offset kinematic: joint variable offset % qlim kinematic: joint variable limits [min max] %- % m dynamic: link mass % r dynamic: link COG wrt link coordinate frame 3×1 % I dynamic: link inertia matrix, symmetric 3×3, about link COG.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f2d62938f571e2edbe8e2a70bead7c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd3cdf1fe109d508d72bb20fbf0a181/" rel="bookmark">
			Jlink&amp;STlink工具烧录读取hex&amp;bin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jlink和STlink等工具非常好用，对调试程序程序来说简直就是爽到爆，而有些时候则需读出flash等操作。下面这篇文章便介绍如何从flash中读取数据。主要针对STM32介绍Jlink相关操作。其中读取可以用很多软件，在这里介绍用SEGGER官方自带的Jlink软件，在这里多说几句，感觉官方自带的才是真正操作flash的。
前提条件是已经安装完JLINK工具，内置驱动，已经上传到我的资源里链接：http://download.csdn.net/detail/shaynerain/9874612
安装完后便可进行下一步。
以下介绍hex，bin的烧写和读出hex、bin。
1、打开已经安装好的JFlash，默认安装目录在C:\Program Files (x86)\SEGGER\JLink_V490中，出现的提示框可以直接关掉，或者选第三个，创建一个新工程
2、然后单击options&gt;project settings，弹出设置窗口中前三个都要设置，第一个设置如下
3、第二个选择JTAG、SWD等，STM芯片SWD，然后是频率，多少都可以，频率越高越快，越不稳定，但是官方敢放出来，那就证明人家已经测试过很多次了
4、选择对应的CPU，选择芯片对应的device
5、点击target-&gt;connect，等待下方提示链接成功
6、读取flash，选择target-&gt;read back，共有三种，前两种效果一样，第三种是选择读取那个地址中的。我们直接选择读取全部
7、已经读取出来，可选择file-&gt;save date file，这是便可选择要以什么合适存储。
其中便可选择hex bin，hex存储的话里面会包含起始信息，在烧写时不必选择起始地址。bin的话需要原则起始地址。
8、烧写hex，bin，连接后file-&gt;open file，如果打开hex文件，则target-&gt;program便可直接烧写。如果打开bin文件则target-&gt;program后需要填写起始地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c1578546038f0c2d14e385e5aa9ec0/" rel="bookmark">
			PHP考勤登录系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用方法更新在PHP考勤登录系统使用方法&amp;演示 – 开发者技术分享，点击即可获取
一、作业要求 电计算机实验室考勤登记系统(三张表,班级信息表,考勤表,请假表)可变动（小于等于三个表）
1 admin管理员用户
1.能对班级人员进增、添、删改、查看
2.请假审批(上课前1小时审批有效)
3.设置上课和下课时间。
2 普通用户
1.查看全部用户迟到、旷课、早退、请假信息，可选择相关主题查询(分页)
2.请假
3.修改用户个人信息
4.上下课签到光控电路
二、实现方法及简单功能介绍
1、建立三张表
1）用户表user，用于记录用户信息，并提前几个信息，用于之后的测试以及DEBUG使用
2）请假审核表qingjia，用于管理请假，其中包含了admin用户信息，同上提前设置
3）时间表shijian，用于设置上下课时间，同上提前设置
2、用户登录
1）区分普通用户和管理员登录，分别连接不一样的数据库
2）普通用户账号密码分别是stuxx和stu，xx是号数（01、02、、、22）
3）管理员登录账号密码都是admin
3、用户操作
1）可退出登录，退出时删除想除session信息
2）上课时间签到，晚签记录迟到，晚签超过15分钟记为旷课，检测重复见到
3）下课时间签离，早签记录早退，检测签到后才能签离
4）可以在上课一个小时前请假，超过时间无效，并可以查询请假进度
5）可以修改个人信息
6）连接用户数据库可查询相关所有用户信息
7）可分主题查询相关信息
4、管理员操作
1）可退出登录，退出时删除想除session信息
2）可修改用户所有信息
3）添加删除普通用户
4）管理请假，连接qianjia表进行相关管理
5）设置上下课时间
6）连接用户数据库可查询相关所有用户信息
7）可分主题查询相关信息
三、登录界面 &lt;? php session_start(); if($_POST['submit']) { $con = mysql_connect("localhost", "root", "111"); mysql_query("set names 'utf-8'"); mysql_select_db("du", $con); $name = $_POST['user']; $password = $_POST['password']; if($_POST["radio"] == "radio1") { $sql = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3c1578546038f0c2d14e385e5aa9ec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8b54b16649d220e3ea285cea55b0d0/" rel="bookmark">
			查看项目中的angular版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天把官网下载的angular案例跑了起来，准备自己加个模块试试。突发奇想，想看看当前项目的angular版本是多少。
尝试了控制台命令查看，无效。
网上一番查询，找到了答案：
就浏览器里直接看网页代码的root部分即可，可以看到这个项目的angular版本是7.0.4
信息来源：https://stackoverflow.com/questions/36456843/how-to-check-angular2-version-with-typescript
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7808421bded7c14b43228aff1e1f30fe/" rel="bookmark">
			Unity CommandInvokationFailure: Failed to sign APK package
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity 2018无法打包了，看了前人的方法，都不好用，输出信息如下！
CommandInvokationFailure: Failed to sign APK package. D:\android-sdk\build-tools\28.0.3\apksigner.bat sign --ks "C:\Users\Administrator\.android\debug.keystore" --ks-pass stdin --ks-key-alias "androiddebugkey" --key-pass stdin "D:\working\shangqi\Temp/StagingArea/Package.apk"
stderr[
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8
]
stdout[
Error occurred during initialization of VM
Could not reserve enough space for 1048576KB object heap
]
exit code: 1
UnityEditor.Android.Command.WaitForProgramToRun (UnityEditor.Utils.Program p, UnityEditor.Android.WaitingForProcessToExit waitingForProcessToExit, System.String errorMsg)
UnityEditor.Android.Command.RunWithStdin (System.Diagnostics.ProcessStartInfo psi, UnityEditor.Android.WaitingForProcessToExit waitingForProcessToExit, System.String errorMsg, System.String[] input)
UnityEditor.Android.PostProcessor.Tasks.TasksCommon.Exec (System.String command, System.String args, System.String workingdir, System.String errorMsg, System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7808421bded7c14b43228aff1e1f30fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb3168be0bafe979daffc6b9379fb28/" rel="bookmark">
			Java游戏开发——推箱子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旧文链接：http://note.youdao.com/noteshare?id=c822c4b9983eeb4dda87aebcec65bbf6&amp;sub=C9578CDF3388455BB6A38D63E0B56975
最近心血来潮，发觉以前写的代码结构实在混乱，为了不祸害更多的小伙伴，决定重构一遍代码。。。。。。。
为了避免重构版和第一版发生混淆，之前的文章我转移到有道云笔记了，诸君可以通过笔记链接查看旧文。
*******************************************************************************************************************************************************************
先上运行效果：
源代码链接：https://pan.baidu.com/s/1KEGyGMYgtO45A0oIdH62zA
提取码：2ik3
重构后的推箱子项目工程目录结构图如下：
资源文件已经内置到项目中了，直接运行即可。
我做了我力所能及的代码分层，现在GameClient类是窗口类，GamePanel类是游戏面板类，GameMapSet类存放关卡数据数组，GameMusicUtil类是音乐助手类。
不废话，我挑核心逻辑讲一遍，剩余的看代码和注释就可以了，不懂再问我哈。
核心逻辑 游戏元素：墙、空地、箱子、目标点、人的上下左右状态、人在目标点上的上下左右状态，一共用13个常量来表示。
private static final byte WALL = 1, BOX = 2, BOXONEND = 3, END = 4, MANDOWN = 5, MANLEFT = 6, MANRIGHT = 7,MANUP = 8, GRASS = 9, MANDOWNONEND = 10, MANLEFTONEND = 11, MANRIGHTONEND = 12, MANUPONEND = 13; 每一关的地图是都是由一个二维数组，具体内容就是上面的游戏元素的常量值。
理解了这个，就可以来分析下主角的移动逻辑处理了。
初始关卡的二维数组是这样:
对照常量，可以得出主角当前在第4行第4列（行列数从0开始），记manPositionRow=4，manPositionColumn=4，地图数组为map，方向是向下
现在我们只分析主角向下移动的逻辑处理：
if(主角当前位置向下一格是墙){ 无法向下移动，直接return； } 声明两个变量tempBox和tempMan，用于数组数据更新。 if(主角当前位置向下一格是‘箱子’或‘箱子在目标点上’){ if(主角当前位置向下两格是‘目标点’或‘空地’){ 先保存快照，用作撤回操作。 if(主角当前位置向下两格是‘目标点’吗){ 主角当前位置向下两格状态待会更新为 ‘箱子在目标点上’ }else{ 主角当前位置向下两格状态待会更新为 ‘箱子 ’ } if(主角当前位置向下一格是‘箱子在目标点上’吗){ 主角当前位置向下一格状态待会更新为 ‘主角在目标点上此时方向向下’ }else{ 主角当前位置向下一格状态待会更新为 ‘主角方向向下’ } //移动操作，数据更新 将主角当前位置恢复成‘空地’或‘目标点’ 主角当前位置向下两格状态更新 主角当前位置向下一格状态更新 主角所在行数+1 } }else{ //主角当前位置向下一格是‘空地’或‘目标点’ 先保存快照，用作撤回操作。 if(主角向下一格是空地吗){ 主角向下一格状态待会更新成‘主角方向向下’ }else{ 主角向下一格状态待会更新成‘主角在目标点上此时方向向下’ } //移动操作，数据更新 将主角当前位置恢复成‘空地’或‘目标点’ 更新主角向下一格状态 主角所在行数+1 } 对应代码如下，已经灰常灰常详细了。。。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efb3168be0bafe979daffc6b9379fb28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf114011448c62d295ef208af24357c/" rel="bookmark">
			anaconda常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		activate // 切换到base环境
activate learn // 切换到learn环境
conda create -n learn python=3 // 创建一个名为learn的环境并指定python版本为3(的最新版本)
conda env list // 列出conda管理的所有环境
conda list // 列出当前环境的所有包
conda install requests 安装requests包
conda remove requests 卸载requets包
conda remove -n learn --all // 删除learn环境及下属所有包
conda update requests 更新requests包
conda env export &gt; environment.yaml // 导出当前环境的包信息
conda env create -f environment.yaml // 用配置文件创建新的虚拟环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1bdf16844e64e324a4d5a3f3dbfc41c/" rel="bookmark">
			awk 中 {print $1} 什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到教程。 举个例子 echo "aa bb cc" | awk -F '{print $1}' 结果就是aa，意思是把字符串按空格分割，取第一个。 awk 是用来提取列的主要工具； {print $1} 就是将某一行（一条记录）中以空格为分割符的第一个字段打印出来。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ada48c8514ebbe488b4a07019cab5a/" rel="bookmark">
			哈工大LTP本地安装及python调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LTP即哈工大语言技术平台云，是基于云计算技术的中文自然语言处理服务平台
在线使用的网址：https://www.ltp-cloud.com/
github网址：https://github.com/HIT-SCIR/ltp
模型下载网址：http://ltp.ai/download.html
1、安装 我主要完成了python安装pyltp，但是在安装的过程中，需要安装VS，不同版本的python会对应不同的VS
python3.6 对应的VS2005 可以从下面的网盘进行下载：
链接：https://pan.baidu.com/s/19DwbVfe3JQYWA3oPCZQoPw 提取码：u5lm python2.7.13 对应的VS可以从下面的网盘中进行下载：
链接：https://pan.baidu.com/s/1rd_9i4wy45FKeF2oYSPCbA 提取码：qf38 （1）python3.6安装过程
执行下面的安装步骤则完成了安装
$ git clone https://github.com/HIT-SCIR/pyltp
$ git submodule init $ git submodule update
$ python setup.py install
但此时安装的pyltp版本是0.2.1
（2）python2.7.13安装过程
按照上面的步骤，会出现下面的问题（本地的python版本默认的是python2.7.14）：
visual c++ for python\9.0\VC\Bin\amd64\cl.exe failed with exit status 2
解决方法：
把python2.7.14换成python2.7.13版本即可，且改成pip安装，具体的安装命令如下所示：
set STATICBUILD=true &amp;&amp; pip install pyltp==0.1.9.1
此时安装的pyltp版本为0.1.9.1
2、使用 LTP提供的模型包括：（在ltp_data文件夹http://ltp.ai/download.html）
cws.model 分句模型，单文件
pos.model 词性标注模型，单文件
ner.model 命名实体识别模型，单文件
parser.model 依存句法分析模型，单文件
srl_data/ 语义角色标注模型，多文件（文件夹srl）
主要使用pyltp中的命名实体识别的功能，具体的代码如下所示：
# -*- coding: utf-8 -*- from pyltp import SentenceSplitter from pyltp import Segmentor from pyltp import Postagger from pyltp import NamedEntityRecognizer paragraph1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2ada48c8514ebbe488b4a07019cab5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ad35411c2f232d5a0c860591ecc144/" rel="bookmark">
			微信小程序退出或隐藏后，内嵌的web-view的音频没有停止的几种解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.尝试下通过h5的pagehide事件
2.小程序改变web-view src的hash值，网页端监听hashchange来处理
这均需要在h5去修改代码。
3.使用wx.pauseVoice()
4.注意的地方
wx.pauseVoice()接口主要用来实现暂停正在播放的语音。需要注意的是当再次调用wx.playVoice播放同一个文件时，会默认从刚才暂停的地方开始播放，如果想要从头开始则需要先调用wx.stopVoice。
wx.stopVoice()用来实现结束播放的语音。
wx.createAudioContext(audioId)接口用来创建并且返回audio的audioContext上下文对象，该对象通过audioId可以跟一个audio组件绑定，通过他来操作这个audio组件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d21450926c3b56050c52624b6bac1e5e/" rel="bookmark">
			vscode同时编辑多处文字 批量替换编辑内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先按Ctrl+F打开搜索框，然后搜索要编辑的内容，接着按Ctrl+Shift+L就可以选中对应的所有内容了，然后可以全部编辑和替换了。按了Ctrl+shift+L之后把搜索框关闭就可以同时编辑多处了。 此处我就是搜索items 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ab3b8432748f337d32c3d94560da5a/" rel="bookmark">
			@ContextConfiguration的意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@ContextConfiguration的意思 @ContextConfiguration这个注解通常与@RunWith(SpringJUnit4ClassRunner.class)联合使用用来测试
当一个类添加了注解@Component,那么他就自动变成了一个bean，就不需要再Spring配置文件中显示的配置了。把这些bean收集起来通常有两种方式，Java的方式和XML的方式。当这些bean收集起来之后，当我们想要在某个测试类使用@Autowired注解来引入这些收集起来的bean时，只需要给这个测试类添加@ContextConfiguration注解来标注我们想要导入这个测试类的某些bean。
XML 我们先看看老年人使用的XML方式:
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd &gt; &lt;!-- 自动扫描该包 --&gt; &lt;context:component-scan base-package="com" /&gt; &lt;/beans&gt; 这个XML文件通过&lt;context:component-scan base-package="com" /&gt;标签将com包下的bean全都自动扫描进来。
下面我们就可以测试了。
一般这么写:
@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {"classpath*:/*.xml"}) public class CDPlayerTest { } @ContextConfiguration括号里的locations = {"classpath*:/*.xml"}就表示将class路径里的所有.xml文件都包括进来，那么刚刚创建的那么XML文件就会包括进来，那么里面自动扫描的bean就都可以拿到了，此时就可以在测试类中使用@Autowired注解来获取之前自动扫描包下的所有bean
classpath和classpath*区别:
classpath：只会到你的class路径中查找找文件。
classpath*：不仅包含class路径，还包括jar文件中（class路径）进行查找。
Java 如果使用Java的方式就会很简单了，我们就不用写XML那么繁琐的文件了，我们可以创建一个Java类来代替XML文件，只需要在这个类上面加上@Configuration注解,然后再加上@ComponentScan注解就开启了自动扫描，如果注解没有写括号里面的东西，@ComponentScan默认会扫描与配置类相同的包。
@Configuration @ComponentScan public class CDPlayConfig { } 此时如果想要测试的话，就可以这么写：
@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes=CDPlayConfig.class) public class CDPlayerTest { } 相较于XML,是不是很酷炫，这也是官方提倡的方式。
在Spring Boot测试 @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest public class Test { } 这个@SpringBootTest注解意思就是将SpringBoot主类中导入的bean全都包含进来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ab3b8432748f337d32c3d94560da5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e660e52c56e24c9122fbd2d8f4f71a/" rel="bookmark">
			nodeJs本地服务器启动的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 1、node 目录
2、webstorm中启动
3、最好的一种方法pm2
转载于:https://my.oschina.net/u/3912828/blog/2961445
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d588fa9ee66b3ede107d1645e446b6/" rel="bookmark">
			Git信息泄露利用工具推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、https://github.com/UnkL4b/GitMiner
2、https://github.com/mschwager/gitem
3、https://github.com/repoog/GitPrey
4、https://github.com/ezekg/git-hound
5、https://github.com/dxa4481/truffleHog
6、https://github.com/shengqi158/svn_git_scanner
7、https://github.com/0xbug/Hawkeye?
8、https://github.com/lijiejie/BBScan
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ddc34c02980bd33d0c3af585585fc8/" rel="bookmark">
			eclipse中安装插件应该注意的地方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装maven插件
新建环境变量MAVEN_HOME
. 编辑环境变量Path，追加%MAVEN_HOME%\bin\;
上面就安装好了客户端maven；接下来是让eclipse使用我们自己安装的maven。
eclipse中自带maven插件，如果想改用自己安装的maven，就自己安装appach-maven，然后再settings.xml文件中设置仓库的存储位置和要请求的中央仓库位置。
然后再eclipse中设置maven中使用的settings文件即可
2、安装svn插件
安装SVN插件：
安装客户端TortoiseSVN ，切记一定要看清楚版本号；
这里一定要注意和安装的客户端TortoiseSVN版本相对应。
一定要注意的是，很多人为什么安装失败，可能时因为不理解重启的含义，在点击完成之后会进行相关软件的安装，安装费完成会自动进行重启。不要因为没有注意，关闭eclipse手动重启，这样会导致安装失败。一旦安装失败再次安装会有一堆问题，此时建议下载离线安装包进行安装。
3、安装springboot插件
下载离线包，然后安装；注意事项和2中安装SVN是一样的，不要没事就自己手动关闭，在重启。还有就是要注意JDK版本和eclipse的版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b0c012db43ba990b3a3aae43a3d8fa3/" rel="bookmark">
			VS2017 激活密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【时间】2018.11.26
【题目】VS2017 激活密钥
一、激活秘钥 Enterprise[企业版]:
NJVYC-BMHX2-G77MM-4XJMR-6Q8QF
Professional[专业版]:
KBJFW-NXHK6-W4WJM-CRMQB-G3CDH
二、秘钥使用 使用位置在 帮助 -- 注册商品 中：
输入秘钥后，激活成功后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438108b8b862cf8c50bfd8f198c2850e/" rel="bookmark">
			python创建数组的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一　直接定义法：
1.直接定义
matrix=[0,1,2,3] 2.间接定义
matrix=[0 for i in range(4)] print(matrix) 二　Numpy方法：
Numpy内置了从头开始创建数组的函数：
zeros(shape)将创建一个用指定形状用0填充的数组。默认的dtype是float64。
下面是几种常用的创建方法：
#coding=utf-8 import numpy as np a = np.array([1,2,3,4,5]) print a b = np.zeros((2,3)) print b c = np.arange(10) print c d = np.arange(2,10,dtype=np.float) print d e = np.linspace(1.0,4.0,6) print e f = np.indices((3,3)) print f 三　其他转换法：
数组还有比较常用的一种方法，就是从其他Python结构（例如，列表，元组）转换。
下面给出一些例子。
列表转数组:
a = [] a.append((1,2,4)) a.append((2,3,4)) a = np.array(a) a.flatten() 元组转成数组:
import numpy as np mylist = [1,2,3] print tuple(mylist) iarray = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/438108b8b862cf8c50bfd8f198c2850e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e37dfbfcb0404d839d715028b560a5d/" rel="bookmark">
			双三次插值（BiCubic插值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双三次插值（BiCubic插值 ） 双三次插值又称立方卷积插值。三次卷积插值是一种更加复杂的插值方式。该算法利用待采样点周围16个点的灰度值作三次插值，不仅考虑到4 个直接相邻点的灰度影响，而且考虑到各邻点间灰度值变化率的影响。三次运算可以得到更接近高分辨率图像的放大效果，但也导致了运算量的急剧增加。这种算法需要选取插值基函数来拟合数据，其最常用的插值基函数如图1所示，本次实验采用如图所示函数作为基函数。
图像放大并进行BiCubic插值 Matlab/C++代码点击打开链接
假设源图像A大小为m*n，缩放K倍后的目标图像B的大小为M*N，即K=M/m。A的每一个像素点是已知的，B是未知的，我们想要求出目标图像B中每一像素点(X,Y)的值，必须先找出像素(X,Y)在源图像A中对应的像素(x,y)，再根据源图像A距离像素(x,y)最近的16个像素点作为计算目标图像B(X,Y)处像素值的参数，利用BiCubic基函数求出16个像素点的权重，图B像素(x,y)的值就等于16个像素点的加权叠加。
根据比例关系x/X=m/M=1/K，我们可以得到B(X,Y)在A上的对应坐标为A(x,y)=A(X*(m/M),Y*(n/N))=A(X/K,Y/K)。如图所示P点就是目标图像B在(X,Y)处对应于源图像A中的位置，P的坐标位置会出现小数部分，所以我们假设 P的坐标为P(x+u,y+v)，其中x,y分别表示整数部分，u,v分别表示小数部分（蓝点到a11方格中红点的距离）。那么我们就可以得到如图所示的最近16个像素的位置，在这里用a(i,j)(i,j=0,1,2,3)来表示，如上图。
我们要做的就是求出BiCubic函数中的参数x,从而获得上面所说的16个像素所对应的权重W(x)。BiCubic基函数是一维的，而像素是二维的，所以我们将像素点的行与列分开计算。BiCubic函数中的参数x表示该像素点到P点的距离，例如a00距离P(x+u,y+v)的距离为(1+u,1+v)，因此a00的横坐标权重i_0=W(1+u)，纵坐标权重j_0=W(1+v)，a00对B(X,Y)的贡献值为：（a00像素值）* i_0* j_0。因此，a0X的横坐标权重分别为W(1+u)，W(u)，W(1-u)，W(2-u)；ay0的纵坐标权重分别为W(1+v)，W(v)，W(1-v)，W(2-v)；B(X,Y)像素值为：
上述可以用矩阵形式表示，下面图片来源：点击打开链接
加权算法（a可以不取-0.5）：
Matlab代码： %双三次插值具体实现 clc,clear; fff=imread('E:\Documents\BUPT\DIP\图片\lena.bmp'); ff =rgb2gray(fff);%转化为灰度图像 [mm,nn]=size(ff); %将图像隔行隔列抽取元素，得到缩小的图像f m=mm/2; n=nn/2; f =zeros(m,n); for i=1:m for j=1:n f(i,j)=ff(2*i,2*j); end end k=5; %设置放大倍数 bijiao1 =imresize(f,k,'bilinear');%双线性插值结果比较 bijiao =uint8(bijiao1); a=f(1,:); c=f(m,:); %将待插值图像矩阵前后各扩展两行两列,共扩展四行四列 b=[f(1,1),f(1,1),f(:,1)',f(m,1),f(m,1)]; d=[f(1,n),f(1,n),f(:,n)',f(m,n),f(m,n)]; a1=[a;a;f;c;c]; b1=[b;b;a1';d;d]; ffff=b1'; f1=double(ffff); g1 =zeros(k*m,k*n); fori=1:k*m %利用双三次插值公式对新图象所有像素赋值 u=rem(i,k)/k; i1=floor(i/k)+2; A=[sw(1+u) sw(u) sw(1-u) sw(2-u)]; for j=1:k*n v=rem(j,k)/k; j1=floor(j/k)+2; C=[sw(1+v);sw(v);sw(1-v);sw(2-v)]; B=[f1(i1-1,j1-1) f1(i1-1,j1) f1(i1-1,j1+1)f1(i1-1,j1+2) f1(i1,j1-1) f1(i1,j1) f1(i1,j1+1) f1(i1,j1+2) f1(i1+1,j1-1) f1(i1+1,j1) f1(i1+1,j1+1) f1(i1+1,j1+2) f1(i1+2,j1-1) f1(i1+2,j1) f1(i1+2,j1+1)f1(i1+2,j1+2)]; g1(i,j)=(A*B*C); end end g=uint8(g1); imshow(uint8(f));title('缩小的图像'); %显示缩小的图像 figure,imshow(ff);title('原图'); %显示原图像 figure,imshow(g);title('双三次插值放大的图像'); %显示插值后的图像 figure,imshow(bijiao);title('双线性插值放大结果'); %显示插值后的图像 mse=0; ff=double(ff); g=double(g); ff2=fftshift(fft2(ff)); %计算原图像和插值图像的傅立叶幅度谱 g2=fftshift(fft2(g)); figure,subplot(1,2,1),imshow(log(abs(ff2)),[8,10]);title('原图像的傅立叶幅度谱'); subplot(1,2,2),imshow(log(abs(g2)),[8,10]);title('双三次插值图像的傅立叶幅度谱'); 基函数代码： functionA=sw(w1) w=abs(w1); ifw&lt;1&amp;&amp;w&gt;=0 A=1-2*w^2+w^3; elseifw&gt;=1&amp;&amp;w&lt;2 A=4-8*w+5*w^2-w^3; else A=0; end C++代码： #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e37dfbfcb0404d839d715028b560a5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/427d6dcdde09931e3743f8351ca539c9/" rel="bookmark">
			Istio思维导图总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己学习总结了一些思维导图(持续更新中)，后面附有GitHub链接 ,分享给大家。https://github.com/panjianlong13/MindMapSummary
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81abb1a9bb970c5516467bbc4426eabf/" rel="bookmark">
			class path resource [ xxx ] cannot be opened because it does not exist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：class path resource [ xxx ] cannot be opened because it does not exist
之前在项目中遇到这个问题，网上查了很多方法都没有解决。后面发现，因为做的项目是项目B需要依赖项目A的。结果并没有添加A的依赖导致部署完运行的时候报错。
解决方法：选中你正在部署调试的项目，右击选取：Properties–&gt;Deployment Assemply–&gt;Add–&gt;project–&gt;选择你需要依赖的项目添加，之后Apply，重启tomcat，完美解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec242335c6e3ec996b3c8dfd64e0838/" rel="bookmark">
			maven项目打包成jar包    但本地jar文件不在jar包内的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中想要使用本地的jar包的时候，我们在编译器中可以导入，并且在打包成war包的时候也能打入进去，但是将项目打包成jar包的时候 却无法打入。因为jar包中 jar的文件打包在了BOOT-INF中。如下图
这里可以看到，maven中的jar包全部在这里，所以我们在使用本地jar包的时候，要告诉maven打包之后要将本地jar包放在哪。需要的配置如下:${basedir}代表项目地址,systemPath就是jar包存放的位置，scope作用域必须为system(代表本地jar包)，其他的自己随便编写
&lt;dependency&gt; &lt;groupId&gt;com.collagensdk&lt;/groupId&gt; &lt;artifactId&gt;collagensdk&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${basedir}/src/main/webapp/lib/collagensdk.jar&lt;/systemPath&gt; &lt;/dependency&gt; 然后再pom的build中添加节点
&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;${basedir}/src/main/webapp/lib&lt;/directory&gt; &lt;targetPath&gt;BOOT-INF/lib/&lt;/targetPath&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 到此ok
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c5f5e7a2df1b4f4a322a8109c0fbca/" rel="bookmark">
			以指针作为函数参数，读入三个浮点数，将数字的整数部分和小数部分分别输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include
using namespace std;
//将实数x分成整数部分和小数部分，形参intpart,fracpart是指针
void splitFloat(float x, int *intPart, float *fracPart){
*intPart = static_cast(x); //取x的整数部分
*fracPart = x - *intPart; //取x的小数部分
}
int main(){
cout &lt;&lt; “Enter 3 float point number:” &lt;&lt; endl;
for (int i = 0; i &lt; 3; i++){
float x, f;
int n;
cin &gt;&gt; x;
splitFloat(x, &amp;n, &amp;f); //变量地址作为实参
cout &lt;&lt; “Integer Part = " &lt;&lt; n&lt;&lt; " Fraction Part =” &lt;&lt; f &lt;&lt; endl;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c5f5e7a2df1b4f4a322a8109c0fbca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09337aebd381fa9ac78fc693df7c6aca/" rel="bookmark">
			红黑树知识全面详解之节点插入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：
第一步: 将红黑树当作一颗二叉查找树，将节点插入。
红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。
好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！
第二步：将插入的节点着色为"红色"。
为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：
(1) 每个节点或者是黑色，或者是红色。
(2) 根节点是黑色。
(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]
(4) 如果一个节点是红色的，则它的子节点必须是黑色的。
(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
将插入的节点着色为红色，不会违背"特性(5)"！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。
第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。
第二步中，将插入节点着色为"红色"之后，不会违背"特性(5)"。那它到底会违背哪些特性呢？
对于"特性(1)"，显然不会违背了。因为我们已经将它涂成红色了。
对于"特性(2)"，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。
对于"特性(3)"，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。
对于"特性(4)"，是有可能违背的！
那接下来，想办法使之"满足特性(4)"，就可以将树重新构造成红黑树了。
根据被插入节点的父节点的情况，可以将"当节点z被着色为红色节点，并插入二叉树"划分为三种情况来处理。
① 情况说明：被插入的节点是根节点。
处理方法：直接把此节点涂为黑色。
② 情况说明：被插入的节点的父节点是黑色。
处理方法：什么也不需要做。节点被插入后，仍然是红黑树。
③ 情况说明：被插入的节点的父节点是红色。
处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据"叔叔节点的情况"，将这种情况进一步划分为3种情况(Case)。
现象说明
处理策略
Case 1
当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。
(01) 将“父节点”设为黑色。
(02) 将“叔叔节点”设为黑色。
(03) 将“祖父节点”设为“红色”。
(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。
Case 2
当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子
(01) 将“父节点”作为“新的当前节点”。
(02) 以“新的当前节点”为支点进行左旋。
Case 3
当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子
(01) 将“父节点”设为“黑色”。
(02) 将“祖父节点”设为“红色”。
(03) 以“祖父节点”为支点进行右旋。
1. (Case 1)叔叔是红色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09337aebd381fa9ac78fc693df7c6aca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39bb7da885186cd20eac76a922966cb/" rel="bookmark">
			Ubuntu18.04 安装gnome-tweak-tool安装TopIcons Plus | 解决软件图标不显示问题 | 解决坚果云图标不显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1- 安装gnome-tweak-tool 终端执行命令：sudo apt install gnome-tweak-tool 在所有应用程序中搜索"tweak“或"优化”，即可启动 2- 安装TopIcons Plus 点击Toplcons官网下载安装包：
将解压后的包放到Ubuntu桌面
终端进入桌面 将此包移动到此路径下：/usr/share/gnome-shell/extensions/
执行命令：sudo apt-get install make 和sudo make install
关闭Ubuntu并重新启动
3- 安装成功 Ubuntu重启后，打开tweak，执行如下操作
效果展示：启动一个程序如坚果云，发现图标可以正常显示了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0607e84ad3308901f0e15b78dd88ab39/" rel="bookmark">
			shell 字符串转数组 数组转字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #!/bin/bash declare -A dic test='status=OK key1=value1 key2=value2' dic=() arr=($test) for i in "${arr[@]}"; do key=`echo $i|awk -F'=' '{print $1}'` value=`echo $i|awk -F'=' '{print $2}'` printf "%s\t\n" "$i" dic+=([$key]=$value) done echo ${dic["key1"]} echo ${dic[*]} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d32417c196fa368827be4670a60fdc46/" rel="bookmark">
			【Vue】Vue CLI 3 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue cli 3来初始化项目脚手架跟旧版本的稍微有些区别，以下是使用步骤
1.Install npm install -g @vue/cli # OR yarn global add @vue/cli 2. Create a project: vue create my-project # OR vue ui 3.Run npm run serve 参考官网 https://cli.vuejs.org/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b738ac0d6702d96a50260082eee70896/" rel="bookmark">
			【福利】架构师成长必备（包含大量视频）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		架构 视频 – 架构师技能树–
https://pan.baidu.com/s/1kXf6MIN 密码：jx1u
里面有两期视频
12期 主要关注L006的自动化安装里的自动化部署，理解自动化部署的核心思想和搭建流程 13期 L010 LO11 持续集成 理解持续集成对于当下互联网开发的重要性选型持续集成方案并能把控实施 LO12 LO13 ELK栈 理解ELK的使用场景在具体业务中能正确应用elk来提升效率 L022 集群实战 对集群的核心要素有深刻的理解集群的搭建和管理实施 LO23 redis深入 对redis的瓶颈和优化有深刻理解 – 云计算 –
链接：https://pan.baidu.com/s/1smGsdQH 密码：4hju
理解docker和虚拟化在当下互联网开发中的重要性理解云计算的核心思想 书籍 《ELK权威指南第二版》
链接：https://pan.baidu.com/s/1htObX6c 密码：jom9
《python自动化运维 技术与最佳实践》
链接：https://pan.baidu.com/s/1i6FSzdV 密码：7o4r
《分布式服务框架原理与实践》
链接：https://pan.baidu.com/s/1eTX91Yy 密码：55mo
《高性能Linux服务器构建实战》
链接：https://pan.baidu.com/s/1nwO7I0T 密码：j9lc
《微服务架构实践》
链接：https://pan.baidu.com/s/1kWAyE1p 密码：dys7
《云计算架构技术与实践》
链接：https://pan.baidu.com/s/1mjjYmI8 密码：8wir
《docker实践》
链接：https://pan.baidu.com/s/1o90jjKI 密码：1gzb
《unix环境高级编程》
链接：https://pan.baidu.com/s/1jJ0rt10 密码：paux
书籍的阅读的要求是能做到在各个业务场景下快速精准的抽象出合适的实施模型
大数据 视频 linux基础-进阶
链接：https://pan.baidu.com/s/1bqsyebd 密码：kvyc
hadoop2.x精讲
链接：https://pan.baidu.com/s/1nwHMkBJ 密码：aigo
protobuf(统一数据格式)
链接：https://pan.baidu.com/s/1i6fuCRj 密码：af6s
flume分布式日志
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b738ac0d6702d96a50260082eee70896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5b4e76d1f9871bdbebd116e2ae03d9/" rel="bookmark">
			json value中包含双引号处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用“\”将双引号进行转义
例如：
“last_stp_auth_info”:“next_step post data : {“last_step”:“authentication”}”
每有一个双引号都需要用“\”转义一下！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86d04656e7b24560dc9434d58bdfb46/" rel="bookmark">
			android 侧拉删除-仿qq侧拉删除（SwipeDelMenuLayout）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在项目build下添加仓库 allprojects { repositories { maven { url "https://jitpack.io" } } } 2.module 下build添加依赖 implementation 'com.github.mcxtzhang:SwipeDelMenuLayout:V1.3.0' 3.列表item布局 &lt;com.mcxtzhang.swipemenulib.SwipeMenuLayout xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:clickable="true" app:ios="true" app:leftSwipe="true" app:swipeEnable="true"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/cOmmtv" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_weight="8" android:padding="@dimen/dp_5" android:textSize="@dimen/sp_20" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="@dimen/dp_1" android:layout_marginBottom="@dimen/dp_2" android:layout_marginLeft="@dimen/dp_10" android:layout_marginRight="@dimen/dp_10" android:layout_marginTop="@dimen/dp_1" android:background="#EFEFEF" /&gt; &lt;/LinearLayout&gt; //隐藏到屏幕外的删除按钮 &lt;Button android:id="@+id/tv_usb_delete" android:layout_width="@dimen/dp_60" android:layout_height="match_parent" android:background="@drawable/bg_cancel" android:padding="@dimen/dp_5" android:text="删除" android:textColor="@color/white" android:textSize="@dimen/sp_20" /&gt; &lt;/com.mcxtzhang.swipemenulib.SwipeMenuLayout&gt; 4.适配器（本例展示的是listview，其他列表可以自行扩展）
@Override public View getView(final int position, View convertView, ViewGroup parent) { ViewHolder viewHolder=null; View closeView=null; if (convertView==null){ viewHolder=new ViewHolder(); convertView=View.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e86d04656e7b24560dc9434d58bdfb46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ef660325227d3bac870e13a3dbc322/" rel="bookmark">
			SeNet论文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址： https://arxiv.org/pdf/1709.01507.pdf
背景： 最后一届ImageNet 2017竞赛 Image Classification任务的冠军.作者采用SENet block和ResNeXt结合在ILSVRC 2017的分类项目中拿到第一，在ImageNet数据集上将top-5 error降低到2.251%，原先的最好成绩是2.991%。
论文工作： 提出一种有效的架构单元，“Squeeze-and-Excitation”（SE）块，它专注于通道(以往的架构注意点在网络的深度和宽度上)，建模了通道间的相互依赖关系(我对通道的理解是指输出的各个Fm之间的关系)，可学习地重新校准通道间的特征响应，通过将这些快堆叠在一起，构建SeNet架构。
新结构提出前的准备： 1.对卷积神经网络的工作机制的理解：
卷积神经网络（CNNs）已被证明是解决各种视觉任务的有效模型。对于每个卷积层, 沿着输入通道学习一组滤波器来表达局部空间连接模式.。总的来说，卷积神经网络工作机制是一种受限于局部感受野的通过卷积滤波器融合空间信息和通道信息并将它们组合从而为网络效力，通过叠加一系列非线性层和下采样层交织的卷积神经网络，CNN达到了对全局感受野信息的捕获从而达到描述整个图像的目的。
2.对最近新架构/工作的分析：
1.VGGNets[35]和Inception模型[39]证明了深度增加可以获得的好处, 明显超过了ILSVRC 2014之前的方法.Inception通过嵌入学习机制来增强对空间信息相关性的捕捉从而达到提升性能的目的。最近大家的工作也在寻找更好地模拟图像空间信息依赖和空间注意力的方法。
2.批标准化（BN）[14]通过插入单元来调节层输入稳定学习过程, 改善了通过深度网络的梯度传播, 这使得可以用更深的深度进行进一步的实验.
3.He等人[9,10]表明, 通过重构架构来训练更深层次的网络是有效的, 通过使用基于恒等映射的跳连接来学习残差函数。
4.最近, 网络层间连接的重新表示[5,12]已被证明可以进一步改善深度网络的学习和表征属性.
5.另一种研究方法探索了调整网络模块化组件功能形式的方法。可以用分组卷积来增加基数（一组变换的大小）[13,43]以学习更丰富的表示。多分支卷积可以解释为这个概念的概括，使得卷积算子可以更灵活的组合[14,38,39,40]。跨通道相关性通常被映射为新的特征组合，或者独立的空间结构[6,18]，或者联合使用标准卷积滤波器[22]和1×1卷积，然而大部分工作的目标是集中在减少模型和计算复杂度上面。我们的思路从这里开始，这种方法反映了一个假设，即通道关系可以被表述为具有局部感受野的实例不可知的函数的组合（即不同通道间的关系）。
3.我们专注的方向：
和别人注意的地方相反，我们专注的地方是网络的通道关系（从上面第5点得到启发），通过建模特征通道间的动态、非线性依赖关系来提高网络的表现力。当可以建模依赖关系之后，我们就可以通过某种机制重新校准特征，这样就可以达到强调有用特征并抑制无用特征的目的。
SE块的构建过程： 1.SE块基本结构：
对于任何给定的变换(例如卷积或一组卷积)
我们可以构造一个相应的SE块来执行特征重新校准（对变换完了的新特征进行重新校准）。如图所示。执行步骤如下：
1.特征U首先通过squeeze操作，该操作跨越空间维度W×H聚合特征映射来产生通道描述符（也就是聚合一张Fm）。这个描述符嵌入了通道特征响应的全局分布(对一张Fm的描述)，使来自网络全局感受野的信息能够被其较低层利用（指这个模块的较底层部分，就是一提取完就给最近的层用）。
2.这之后是一个excitation（激励）操作，其中通过基于通道依赖性的自门机制为每个通道学习特定采样的激活，控制每个通道的激励。
3.然后特征映射U被重新加权以生成SE块的输出，然后可以将其直接输入到随后的层中。
SE网络可以通过简单地堆叠SE构建块的集合来生成。SE块也可以用作架构中任意深度的原始块的直接替换。然而，虽然构建块的模板是通用的，正如我们6.3节中展示的那样，但它在不同深度的作用适应于网络的需求。
SE快在网络不同部分的作用有所不同：
1.在前面的层中，它学习以类不可知的方式激发信息特征，增强共享的较低层表示的质量。
2.在后面的层中，SE块越来越专业化，并以高度类特定的方式响应不同的输入。
因此，SE块进行特征重新校准的好处可以通过整个网络进行累积。
2.注意力和门机制：
从广义上讲，可以将注意力视为一种工具，将可用处理资源的分配偏向于输入信号的信息最丰富的组成部分。这种机制的发展和理解一直是神经科学社区的一个长期研究领域[15,16,28]，并且近年来作为一个强大补充，已经引起了深度神经网络的极大兴趣[20,25]。注意力已经被证明可以改善一系列任务的性能，从图像的定位和理解[3,17]到基于序列的模型[2,24]。它通常结合门函数（例如softmax或sigmoid）和序列技术来实现[11,37]。（Highway Networks）高速网络[36]采用门机制来调节快捷连接，使得可以学习非常深的架构。王等人[42]受到语义分割成功的启发，引入了一个使用沙漏模块[27]的强大的trunk-and-mask注意力机制。这个高容量的单元被插入到中间阶段之间的深度残差网络中。
相比之下，我们提出的SE块是一个轻量级的门机制，专门用于以计算有效的方式对通道关系进行建模，并设计用于增强整个网络中模块的表示能力。
3.SE块具体运行过程：
Squeeze-and-Excitation块是一个计算单元，可以为任何给定的变换构建（就是给某个变换结束了，对它产生的结果进行一个处理）。
为了简化说明，在接下来的表示中，我们将Ftr看作一个标准的卷积算子。V=[v1,v2,…,vC]表示学习到的一组滤波器核，vc指的是第c个滤波器的参数。然后我们可以将Ftr的输出写作U=[u1,u2,…,uC]，其中
这里∗表示卷积，vc=[v1c,v2c,…,vC′c]，X=[x1,x2,…,xC′]（为了简洁表示，忽略偏置项）。这里vsc是2D空间核，因此表示vc的一个单通道，作用于对应的通道X。
符号描述：
即Uc表示输出的第C个通道的Fm，Vc代表在输入的第C个通道上使用的卷积核，Vsc代表该卷积核对应输入的某个通道的2D空间核。
我们的分析：
从上式不难知道输出的某个Fm是通过所有通道的和来产生的，所以通道依赖性（这里指的通道依赖性指的是上一批通道，也就是输入信号的那批通道，后面我们处理的是后面一批通道）被隐式地嵌入到vc中，而vc是滤波器(卷积核)，它的作用是捕获图片像素点的空间相关性，所以我们说通道间的依赖性与滤波器捕获的空间相关性是纠缠在一起的。
4.通道间依赖关系的提取——squeeze
1.输出特征中每个通道的信号：
要找通道间信号的关系，先把他们输出。
问题：
每个通道在这里是指刚刚输出的每张Fm，所以，输出每个通道信息就是说输出每张Fm，而Fm上有很多像素点，这些像素点都是由上一步的局部感受野处理得到的，没有哪个像素点可以代表整个通道(Fm):
每个学习到的滤波器都对局部感受野进行操作，因此变换输出U的每个单元(每张Fm)都无法利用该区域之外的上下文信息。在网络较低的层次上其感受野尺寸很小，这个问题变得更严重。
解决方法：
使用全局平均池化将整个通道压缩成一个通道描述符。第c个通道(第c个Fm)表示如下：
讨论：
上一步的转换输出U可以被解释为局部描述子的集合，这些描述子的统计信息对于整个图像来说是有表现力的。特征工程工作中[31,34,45]普遍使用这些信息。我们选择最简单的全局平均池化，同时也可以采用更复杂的汇聚策略。
5.自适应重新校正(Excitation)：
通过一定方式提取完了通道信息，我们就要开始利用这些通道信息了，利用他们来全面捕获通道依赖性。
能捕获通道间依赖关系的机制必须要满足下面两个条件：
1.第一，它必须是灵活的（特别是它必须能够学习通道之间的非线性交互）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27ef660325227d3bac870e13a3dbc322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d49f96e131ff2434c5939aac7d7dc2e/" rel="bookmark">
			libevent1.4 阅读记录二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		libevent大概框架已经了解，现在我们通过libevent封装的epoll了解一下libevent的I/O模型。
epollop结构体
1 struct epollop { 2 struct evepoll *fds;　//文件描述符事件数组，每个文件描述符对应的事件，这里将读写事件分开了。记录所有需要监听的事件 /* due to limitations in the epoll interface, we need to keep track of * all file descriptors outself. */ struct evepoll { struct event *evread; struct event *evwrite; }; 3 int nfds;　//文件描述符数量 4 struct epoll_event *events;　//epoll的事件结构数组
typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ } __EPOLL_PACKED; 在epoll_wait中返回就只包含2个信息：事件类型及其文件描述符。这是用来缓存此刻监听到的发生事件的信息的。 5 int nevents;　//可以缓存监听的events的数量 6 int epfd;　//epoll_create返回的epoll句柄 7 }; 我们仍然找一个demo，从demo的调用方式来分析libevent的epoll工作方式，参考libevent在异步socket中的使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d49f96e131ff2434c5939aac7d7dc2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a55a2470857f1e82d94dbb19f7a4b6b7/" rel="bookmark">
			python sklearn.cross_validation 模块导入失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接： https://blog.csdn.net/Jae_Peng/article/details/79277920
解决办法：
原来在 cross_validation 里面的函数都放在 model_selection 里面了；
from sklearn.model_selection import GridSearchCV from sklearn.model_selection import train_test_split 转载于:https://www.cnblogs.com/robin2ML/p/9997703.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fbd31e0fb6f8a027c0879d8aaeb5576/" rel="bookmark">
			MyBatis实现模糊查询的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模糊查询也是数据库SQL中使用频率很高的SQL语句，使用MyBatis来进行更加灵活的模糊查询。
直接传参法
直接传参法，就是将要查询的关键字keyword,在代码中拼接好要查询的格式，如%keyword%,然后直接作为参数传入mapper.xml的映射文件中。在查询前提前拼接好，然后使用Like 模糊查询
public void selectBykeyWord(String keyword) { String id = "%" + keyword + "%"; String roleType = "%" + keyword + "%"; String roleName = "%" + keyword + "%"; userDao.selectBykeyWord(id,roleName,roleType); } 在Dao层指定各个参数的别名
List&lt;RoleEntity&gt; selectBykeyWord(@Param("id") String id,@Param("roleName") String roleName,@Param("roleType") String roleType); &lt;select id="selectBykeyWord" parameterType="string" resultType="com.why.mybatis.entity.RoleEntity"&gt; SELECT * FROM t_role WHERE role_name LIKE #{roleName} OR id LIKE #{id} OR role_type LIKE #{roleType} &lt;/select&gt; 执行出来的SQL语句：
SELECT * FROM t_role WHERE role_name LIKE '%why%' OR id LIKE '%why%' OR role_type LIKE '%why%'; CONCAT（）函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fbd31e0fb6f8a027c0879d8aaeb5576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b12bfc3c9f22623772d4570c30f5ec3/" rel="bookmark">
			前端POST请求参数过长，导致400错误解决办法及分析（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到在servlet端通过request对象getInputStream读取POST过来的数据，却读不到的问题，怀疑是tomcat的问题。查了一下Content-type是application/x-www-form-urlencoded，估计是被解析成了parameters，果然在他获取流之前，有过request.getParameter的操作。
熟悉servlet的话，这个问题应该算常识了。它其实跟容器无关，所有的servlet容器都是这样的行为。几年前在实现一个网关代理的时候就遇到过这个问题，当时使用的是jetty，发现POST过来的数据读不到，也是application/x-www-form-urlencoded编码，断点跟踪发现是在获取流之前有过request.getParameter，数据会被解析，并且后续数据流不可再被读取。
在servlet规范3.1.1节里，对POST数据何时会被当做parameters有描述：
The request is an HTTP or HTTPS request.The HTTP method is POST.The content type is application/x-www-form-urlencoded.The servlet has made an initial call of any of the getParameter family of methods on the request object. If the conditions are met, post form data will no longer be available for reading directly from the request object’s input stream.
规范里已经明确的声明当请求满足: 1) http/https, 2) POST, 3) Content-type 是application/x-www-form-urlencoded, 4) 调用过getParameter方法；则数据会被当做请求的paramaters，而不能再通过 request 的 inputstream 直接读取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b12bfc3c9f22623772d4570c30f5ec3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc7daec142f8869d4a9620bcf6f57312/" rel="bookmark">
			js中如何优雅的判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信下面的代码很眼熟吧
const a = '23333'; if (a === '23333' || a === '33333' || a === '43333' || a === '53333') { console.log(1); } 如果a的值有更多可能呢？或许可以这样写：
const a = '23333'; const compare = ['23333', '33333', '43333', '53333'] if (compare.includes(a)) { console.log(1); } 有没有觉得好多了？实际上可能平常困扰更多的是大量的if-else的使用，其实这也是有办法简化的。
例如这样的判断：
const state = 'a'; function add(param) { console.log(param); } function go(param) { console.warn(param); } if (state === 'a') { add('state1'); go('state1') } else if (state === 'b') { add('state2'); go('state2') } else if (state === 'c') { add('state3'); go('state3') } else if (state === 'd') { add('state4'); go('state4') } else if (state === 'e') { add('state5'); go('state5') } 可以使用switch替换如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc7daec142f8869d4a9620bcf6f57312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/476fdadca6f9408887cd36b159feef00/" rel="bookmark">
			cmake简单使用及编译项目打包成so文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 CMake是一个跨平台的编译自动配置工具，它使用一个名为CMakeLists.txt的文件来描述构建过程，可以产生标准的构建文件。它可以用简单的语句来描述所有平台的安装(编译过程)。它能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性，类似UNIX下的automake。CMake并不直接建构出最终的软件，而是产生标准的建构档(如Unix的Makefile或Windows Visual C++的projects/workspaces)，然后再依一般的建构方式使用。
CMake可以编译源代码、制作程式库、产生适配器(wrapper)、还可以用任意的顺序建构执行档。CMake支持in-place建构(二进档和源代码在同一个目录树中)和out-of-place建构(二进档在别的目录里)，因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake也支持静态与动态程式库的建构。CMake是一个比make更高级的编译配置工具。
CMake的组态档取名为CMakeLists.txt。组态档是用一种建构软件专用的特殊编程语言写的CMake脚本。文件CMakeLists.txt需要手工编写，也可以通过编写脚本进行半自动的生成。通过编写CMakeLists.txt，可以控制生成的Makefile，从而控制编译过程。
CMake主要特点： (1)、开放源代码，使用类BSD许可发布；
(2)、跨平台，并可生成native编译配置文件，在Linux/Unix平台，生成makefile；在苹果平台，可以生成xcode；在windows平台，可以生成msvc的工程文件；
(3)、能够管理大型项目；
(4)、简化编译构建过程和编译过程，CMake的工具链非常简单：cmake+make；
(5)、高效率；
(6)、可扩展，可以为cmake编写特定功能的模块，扩充cmake功能。
查看Ubuntu14.0464位机上是否安装了CMake及版本号，可通过执行一下语句来验证：
cmake --version Linux下安装cmake 1、从官网下载cmake安装包，输入指令解压缩
sudo tar -zxvf cmake-3.8.2.tar.gz 2、进入解压缩后的文件夹中，依次输入
sudo ./bootstrapsudo makesudo make install 或者直接命令安装：
apt-get install cmake 3、安装检查：输入命令，
cmake --version
若出现对应cmake的版本，则说明安装成功，一般默认安装在 /usr/local/bin 目录下。
简单使用 a、新建目录hello, 依次创建文件main.c, CMakeLists.txt, build目录
b、main.c 文件代码如下
#include &lt;stdio.h&gt; int main(void) { printf("Hello\n"); return 0; } c、CMakeLists.txt 文件代码如下
CMAKE_MINIMUM_REQUIRED(VERSION 3.8) #cmake最低版本需求，不加入此行会受到警告信息 PROJECT(HELLO) #项目名称　AUX_SOURCE_DIRECTORY(. SRC_LIST) #把当前目录(.)下所有源代码文件和头文件加入变量SRC_LIST ADD_EXECUTABLE(hello ${SRC_LIST}) #生成应用程序 hello (在windows下会自动生成hello.exe) d、进入build 目录，依次输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/476fdadca6f9408887cd36b159feef00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1180da420b3a50c71219e3fb93c3181b/" rel="bookmark">
			chain33 区块链开发框架诞生记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chain33 区块链开发框架诞生记 chain33 诞生记 很多年没有写博客了，应该说，自从2013年开始玩比特币，就没有写过了。这5年来，做了很多事情，也见了很多以前做梦都没有想到过都事情。我做的最开心的事情，也是觉得最有意义的事情，就是负责开发了一个区块链开发框架 chain33 ，目前这个框架已经在 github 上开源，开源地址是: https://github.com/33cn/chain33
欢迎大家点star，fork。
从2013年开始研究比特币，后来到了2015年，开始看以太坊到代码。到了2016年，我们又研究了 tendermint 和 fabric，最终，我们还是决定要自己从头开发。主要原因有两个。这些软件在设计到时候，没有考虑到，像我们公司一样要做深度定制的情况，比如，我要改变一下mempool的排队方式，那么，我必须要修改内核的代码，过一段时间，他们也升级了，然后我们开始合并代码，很多时候，系统会变的不兼容。所以，我们一开始的目标就是做一个别人可以对内核做二次开发的区块链系统，而不是只是一个可以开发dapp的系统。还有一个原因是，我们对区块的理解和这些系统的理解有一定的不同，所以，我们希望自主开发一个系统，有自己的知识产权是非常重要的，目前这个系统已经申请了接近200个专利。
当然，开发一个区块链系统，实际上要比我们想像的复杂。在用别人系统的时候，我们总觉得别人的系统写的不好，这个不好用，那个不好用，但是，真到了我们自己要重新构造整个系统的时候，我们发现，我们一开始问题想的太简单了，构造一个系统需要有自己的世界观，需要有对本质的洞悉。比如最简单的，如何对待交易与交易的关系，以及合约与合约的关系。可以从一个小例子看一下区块链的世界观问题，点击链接查看：
交易组
总结来说，整个开发过程可以分成三个阶段：
第一个阶段 一开始，我们就5个人，如果目标定的非常大，那么肯定实现遥遥无期。于是我们开始第一个版本的开发，实现一个简单的公链系统，不考虑复用，不考虑二次开发，而是就实现功能，用最快的速度。这个版本大概开发了3个月，就开始测试了，最后我们发现测试时间也花了三个月，bug特别多，很多模块很难测试，比如P2P 模块。这个阶段，我们做对了很多事情，也做错了不少事情。对的事情，就是我们一开始设计了一个 基于消息传递的架构。可以简单的用下面这个图表示：
就是所有的模块通过一个消息队列通讯，而不是直接互相调用。当然，对于一个单机系统，可以用一个内存的消息队列，而对一个分布式系统，可以用真的消息队列系统。消息队列不仅仅解决了耦合的问题，还有一个非常重要，就是整个系统的构建是基于一套消息协议的，而不会依赖具体的实现，这样，第三方实现者只要实现一个模块的消息协议，就可以直接替换掉这个模块，这个对二次开发非常有用。而且，它很容易让区块链系统可以分布式部署，解决单机系统性能瓶颈问题。当然，做的比较不好的地方，就是为了赶工期，对软件质量的要求稍微低了一点，这也引起了测试时间太长，bug不容易被及时发现的问题。
第二阶段 开发这个阶段的时候，市场行情还算可以，我们资金也比较充沛，这个时候，开发人员开始增加到50人左右（有杭州，上海，南京）三个团队，而且都是非常资深的后端开发人员，管理和组织工作不能像原来一样简单了，否则开发效率会大大降低。这个阶段，我们做了devops的改造，配置了一套 gitlab + jira + jenkins 的系统。我们做了部分的模块化的工作，并且分成了两个组，一个主要是公链方向的开发，一个是联盟链方向的开发。这个阶段的主要成就就是实现了 交易组 和 平行链的概念，平行链的概念其实非常简单，那就是，用一条公链处理通用的数据的存证部分，用户自己的平行链来处理具体的业务逻辑。如图表示：
主链因为只有非常少的内置业务逻辑，所以，非常简单，也很容易实现分片，而平行链上的节点不会非常多，类似eos一样二十来个节点，它的升级就会非常的方便。同时，交易组的实现，也改变了传统区块链系统中交易都是独立情况。
第三阶段 这个阶段的开发模式没有什么变化，但是，我们在开发的过程中发现，关键不是上面敏捷或者devops，而是在架构上保证，每个人可以做相对独立的工作，不会相互影响。理论上来说，因为存在协作，所以效率一定会降低，不管用什么方法，协作一定会大大的降低开发效率。当然，协作是不可避免的，但是，我们可以在架构上保证这个协作尽量的少。得益于我们第一阶段的设计，系统模块本身就是互相独立的，但是，这个粒度上是远远不够的，用户希望根据自己的需求，改造某个点，比如增加一种共识模式，增加一种签名方式，增加一种mempool的排队模式，所有的这些需求，都应该符合开闭原则，也就是说，不能通过修改我们的系统内核来实现，而是通过增加新的插件来实现。如下图表示：
内核非常小，基本上每个点，都可以通过可插拔都模式替换掉。我们开发了一些工具，帮助大家快速开发插件，而且最关键都一点，用户开发好都插件可以分享给别人使用，这个也是我们开发chain33的目标，大家停止制造重复的轮子，可以像分享url一样简单都分享自己都劳动成果。随着，大家在chain33内核上不断开发出新的功能，chain33 会越来越强大，它的强大，会让大部分人放弃自主开发自己的区块链系统。
目前我们已经开源了大部分的插件。开源地址：https://github.com/33cn/plugin
下面列举一下主要的插件：
共识部分：
pbft(联盟链，beta)tendermint(联盟链)raft（私有链）ticket（公链）solo （测试链） 加密部分：
sep256k1 (bitcoin, ethereum)ed25519 （tendermint,sc）sm2 (国密支持) store:
mavl （tendermint 提供的后端数据存储方式）mpt （以太坊提供的数据存储方式）kvmvcc(目前性能最高的区块链后端存储方法) 执行器部分：
evm (以太坊虚拟机支持)wasm (目前没有开源）cert (联盟链权限管理)hashlock (hash锁定，和btc,eth 跨链使用)paracross （平行链，注意，平行链只是我们的一个插件，可见内核非常的小）privacy （类似门罗币的隐私保护实现，这个例子可以好好学习一下，它显示我们系统可扩展性的强大，门罗币是utxo模型，但是也可以在我们系统里面兼容 账户模型）trade (内置一个币币交易所，可以支持链上所有资产的交易)游戏(牛牛，时时彩，石头剪刀布 …) 还有一点，我们为了公平的实现博彩游戏，在共识的级别加入随机数的概念，这个是目前区块链系统无法做到的。最近eos经常被攻击，就是因为这一点，共识节点可以随意控制这个随机数。
任何一个程序员，不管有没有区块链开发经验，都可以加入我们都开源社区，目前社区中有一批非常有经验都开发人员，可以给大家提供帮助。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1180da420b3a50c71219e3fb93c3181b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/277/">«</a>
	<span class="pagination__item pagination__item--current">278/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/279/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>