<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d92475870691bc45bb0d01e6df5c45/" rel="bookmark">
			语法：Python与C&#43;&#43;对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
二、语句
三、函数
四、数据结构
五、类
一、概述 Python和C++都是面向对象的。
Python和C++的区别：
Python是脚本语言，脚本语言不需要编译，直接解释执行，由解释器来负责解释。程序代码即是脚本程序，也是可执行文件，只需要编写-运行。C++是编译型编程语言，需要编译成二进制代码，以可执行文件形式运行，需要经过编写-编译-链接-运行的过程。 从语法角度来说：Python更加灵活；C++逻辑更加清晰。
Python C++ import cmath
导入模块，每一个.py文件都可以认为是一个模块。Python中导入的模块可以是类的定义，函数的定义。
#include
引入头文件，头文件为类或函数的声明。
C++支持分离式编译，对源文件分别编译成目标文件，再链接生成可执行文件。通过头文件把源文件关联起来。
在python程序中直接添加sys.path，即import时寻找模块的路径 在cmakelist中设置include_directories()，即include时寻找相应头文件的路径
在程序中添加单元测试 if __name__ == "__main__":
当模块被作为脚本直接运行时，执行之后的程序块；
当模块被其他模块导入时，不执行之后的程序块。
非常方便，可以直接将单元测试脚本写在if __name__ == "__main__":后，保证程序功能正常
C++需要有一个 main 函数来作为程序的入口。如果需要单元测试需要单独写带有main函数的源文件。数据类型决定数据所占内存空间的大小、布局方式、该空间能存储的值的范围、以及数据能参与的运算对象 一切皆对象（数据类型、函数、类都是对象)。对象包含identity（Python中即为对象的内存地址，一旦创建不再改变）、类型信息、值、引用计数（用于记录当前有多少个变量在引用这个对象。一旦引用计数器为0，那么该对象就会被系统自动回收）、。
可参见：Python 中的对象概述 - 知乎
一块能存储数据并具有某种类型的内存空间变量 在python中就是个name，Names refer to objects. Names are introduced by name binding operations.
没有类型信息，是通用的（增加python的灵活性），引用一个对象。
(即变量是对象内存地址的引用）
可参见：python中的变量、对象和引用_ColourfulPanda的博客-CSDN博客_python 引用对象
命了名的对象，即具名的、存储数据并具有某种类型的内存空间
（即变量有一个名字，并在内存中占据一定的存储单元，在该存储单元中存放变量的值）
引用引用即别名，为已经存在的对象所起的另外一个名字，引用自身不是对象指针指针用来存放某个对象的地址，指针自身也是一个对象= name binding，名字绑定，变量存储对象的引用
对象分为可变对象和不可变对象，进行name binding时内存空间示意图可参见：Python中的变量、对象 - 汉尼拔草 - 博客园
把值赋给变量(对象） 二、基本操作 Python
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7d92475870691bc45bb0d01e6df5c45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8523c26650506a09d87958854196fc13/" rel="bookmark">
			前端页面的懒加载和预加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、懒加载二、预加载1）使用css和JavaScript预加载2）使用JavaScript预加载3）使用Ajax预加载 总结 前言 懒加载也就是延迟加载。当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次，俗称占位图），只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，从而减轻服务器压力，避免用户等待时间过长（一般在网站图片很多的时候使用，比如淘宝，京东等）
预加载则是在进入页面后提前加载图片等资源，等用户用到该图片或者资源时可以直接从本地缓存渲染，达到无缝加载，增加用户体验
一、懒加载 body部分代码
&lt;body&gt; &lt;div class="box"&gt; &lt;img class="lazy-load" data-src="./images/001.jpg" /&gt; &lt;img class="lazy-load" data-src="./images/002.jpg" /&gt; &lt;img class="lazy-load" data-src="./images/003.jpg" /&gt; &lt;img class="lazy-load" data-src="./images/004.jpg" /&gt; &lt;/div&gt; &lt;/body&gt; js代码
var imgs = document.getElementsByClassName('lazy-load'); lazyLoad(imgs); window.onscroll =function(){ lazyLoad(imgs); } function lazyLoad(imgs){ // 获取可视区的高度 var height = document.documentElement.clientHeight; // 获取滚动条的位置 var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; // 遍历图片 for(var i=0;i&lt;imgs.length;i++){ if(imgs[i].offsetTop &lt; height + scrollTop){ if(imgs[i].getAttribute('src') == '' || !imgs[i].getAttribute('src')){ imgs[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8523c26650506a09d87958854196fc13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc2bcfd49bcf41d54bf9753e7e0181c/" rel="bookmark">
			Android studio按钮颜色不能修改的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好 我是寒依
不知道大家在学习Android studio 开发应用的时候有没有遇到过一个问题
就是Button 按钮的背景颜色无法修改的问题。通俗点说就是怎么设置背景颜色它这斯就是始终显示紫色。自己本来在按钮属性中设置啦bankdround 的值可颜色依然没有变化，是不是很难受，那恭喜你，你遇到啦我 我将让你不在难受。
当然我能提出这样一个问题说明我是遇到啦， 好像有点废话啦。
那下面就介绍一下怎么解决。不废话啦直接上教程。看下图
打开 values 下面的themes.xml 文件 在 &lt;style name="Theme.MyAppCh5" parent="Theme.MaterialComponents.DayNight.DarkActionBar"&gt;里面parent的值最后面加上 .Bridge
即改成
&lt;style name="Theme.MyAppCh5" parent="Theme.MaterialComponents.DayNight.DarkActionBar.Bridge"&gt;
这样的就可以随意修改我们的按钮背景颜色啦 想怎么改就怎么改啦 。是不是很简单。遇到问题不要慌 先喝杯茶。打开有搜索栏的工具搜一下看看有没有小伙伴分享解决办法 因为你可以这么想，你能遇到的问题别人肯定在你前面遇到啦。永远相信自己是最幸运的。
分享一下我在学习和使用中的问题 ，希望可以帮助到遇到同样问题的小伙伴。
每天站在镜子前对自己说一遍：一天不学习 ，混身难受。
感谢大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65e9ef814c0a35d3c0727aa893790ab/" rel="bookmark">
			Verilog位拼接运算符{}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在Verilog中如何给一个多位的变量（如123bit）赋值呢?不能连续写123个1吧，此时需要位拼接运算。
一：位拼接运算符的定义 1：{}位拼接运算符用于将两个或多个信号拼接起来，表示一个整体的信号，如下：
a = {b[5],b[4:0]}
意思为 b的最高位b[5]和b的低五位拼接起来，组成的a为6位,相当于：
a = {b[5],b[4],b[3],b[2],b[1],b[0]}
2：即把某些倍号的某些位详细地列出来，中间用逗号分开，最后用大括号括起来表示一个整体信号，例如：
｛a, b[3:0], c, 3'b100｝ 也可以写成为：
｛a, b[3],b[2], b[1],b[0],c, 1'b1,1'b0,1'b0｝ 3：将d_in的最高位和d_in的低7位取反加一拼接起来，拼接之后d_out为8位；
d_out={d_in[7],~d_in[6:0]+1'b1}； 4：表示一个整体的信号例如一个一位全加器可以将进位输出和结果拼接在一起：
例如加法器：
module fulladder(a, b, cin, sum, cout); input a, b, cin; output sum, cout; assign {cout, sum} = a + b + cin; // 进位输出与和拼接在一起 endmodule 6：使用重复数字法简化拼接表达式的书写
例如要表示4bit的w {4{w}} &lt;=&gt; {w, w, w, w} 使用嵌套方式简化书写 {a, {3{b, c}}} &lt;=&gt; {a, b, c, b, c, b, c} 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65e9ef814c0a35d3c0727aa893790ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90cdc8e0fdbce8f2ac43de0bf33d52e/" rel="bookmark">
			DelayQueue使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中有使用到延时队列的场景，做个简单的记录说明；首先DelayQueue实现了BlockingQueue，加入其中的元素必须实现Delayed接口；
当生产者元素调用put往其中加入元素时，出发Delayed接口的compareTo方法进行排序，这个排序是按照时间的，按照计划执行的时间排序，先执行的在前面，后执行的排后面；消费者获取元素时，调用getDelay方法返回的值大于0，则消费者线程wait返回的这个时间后，再从队列头部取出元素；下面是个简单的例子
import org.jetbrains.annotations.NotNull; import java.util.Date; import java.util.concurrent.Delayed; import java.util.concurrent.TimeUnit; public class DelayEntity implements Delayed { private static final Long currentTime = System.currentTimeMillis(); private String str; private Long scheduleTime; public DelayEntity(String str, Long delayed) { this.str = str; scheduleTime = System.currentTimeMillis() + (1000) * delayed; } @Override public long getDelay(@NotNull TimeUnit unit) { return unit.convert(scheduleTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS); } @Override public int compareTo(@NotNull Delayed o) { return (int) (this.scheduleTime - ((DelayEntity) o).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e90cdc8e0fdbce8f2ac43de0bf33d52e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e71dbadd072714bbf0597709a6d4898/" rel="bookmark">
			第十三届蓝桥杯——java B组（部分题目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A.星期计算 B.山 C.字符统计 D.最少刷题 目录
A.星期计算
B.山
C.字符统计
D.最少刷题数
A. 这题直接求20的22次方然后对7取余，结果加上6则为答案。
public class test { public static void main(String[] args) { System.out.println(Math.pow(20, 22)%7);//结果为1， } } 答案：7
B.
这个题目考试时，没跑出来，当时只想起用字符串处理回文，不知道如何使前半部分不单调减，后半部分不单调增。后来想了下，直接暴力，分别遍历字符串的前后部分并判断是否相等即可。大概要跑个2min左右。
public class test6 { public static void main(String[] args) { Scanner in=new Scanner(System.in); int count=0; for(int i=2022;i&lt;=2022222022;i++){//3138 String s=i+""; int l=s.length(); String st=s.charAt(0)+""; String str=s.charAt(s.length()-1)+""; if(l%2!=0){//字符长度为奇数时 for(int j=1;j&lt;(l+1)/2;j++){//前半部分，从前遍历 if(s.charAt(j)&gt;=s.charAt(j)-1){ st+=s.charAt(j); } else{ break; } } for(int j=s.length()-2;j&gt;=(l-1)/2;j--){//后半部分，从后遍历 if(s.charAt(j)&gt;=s.charAt(j+1)){ str+=s.charAt(j); } else{ break; } } } else{//字符长度为偶数时 for(int j=1;j&lt;l/2;j++){//前半部分 if(s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e71dbadd072714bbf0597709a6d4898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b07478a30a5aff2cef68c3ca3d34d1/" rel="bookmark">
			Apache Impala
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 Impala 是Hadoop生态中的一个开源的、原生的分析数据库。
它的作用：
在Hadoop上做BI查询
Impala时延低、高并行的特点，非常适合做分析查询。弥补只能做批处理的Hive的不足。Impala支持多租户线性扩展。统一的基础架构
使用Hadoop集群相同的文件、数据格式、元数据、安全、资源管理框架。不需要改变基础架构和做数据迁移备份。快速的处理能力
使用和Hive相同的元数据和ODBC驱动。同样支持SQL，上手容易
不用造轮子。企业级安全
Impala与原生Hadoop安全和Kerberos认证集成。通过哨兵模块，可以保证正确的用户和应用是得到授权使用正确的数据。开源扩展了Haodoop用户生态圈
使用Impala，无论是使用SQL查询还是BI应用，更多的用户可以使用同一个仓库和元数据库。 使用Impala我们可以实时查询储存在HDFS或是HBase上的数据。
Impala和Hive有相同的元数据，SQL语法（HQL），ODBC驱动和用户界面（Hue Beeswax）。因此提供了一个熟悉的、统一的可以进行批和实时查询的平台。
2. 架构 为了降低延迟，Impala改进MapReduce可以直接通过一个接近商业并行RDBMS的、专门的、分布式查询引擎访问数据。性能比Hive快的多。
这个架构有许多优势：
数据节点上的本地处理避免了网络瓶颈。使用一个单一的、公开的、统一的元数据存储。耗时的数据格式转换不再需要。避免了开销。所有的数据都是可以立刻查询，做ETL时没有延迟。所有硬件都可以被Impala查询使用单机即可扩展。 3. 怎么用 3.1 解决方案： 客户端：包括Hue， ODBC客户端，JDBC客户端和Impala Shell. 这些接口实现查询和管理任务。Hive的元数据。让Impala知道有哪些databases可用，这些数据库的结构登。在使用create, drop, alter schema, load data into tables等SQL时，相关的元数据改变会自动广播给所有Impala节点，通过专门的catalog service。Impala是个进程运行在数据节点，coordinates 和 executes 查询。 每个Impala实例receive, plan 和 coordinate 来自 Impala 客户端的查询。Queries都被分布在Impala节点上，这些节点是workers的角色，并行的执行每个query的fragments。HBase和HDFS的数据可以被Impala查询。 3.2 query执行过程 用户程序通过 ODBC 和 JDBC 这样的统一查询接口，发送SQL queries 给 Impala。用户程序可以连接任意集群中的 impalad。这个 impalad 成为这个查询的 coordinator.Impala 解析这个 query， 然后分析它并决定集群中的 impalad 实例们应该实现哪些 tasks。然后以最优效率来计划这个 execution。HDFS 和 HBase 上的数据可以通过本地的 impalad 实例们去访问到。每个 impalad 会返回数据给到 coordinating的那个 impalad，然后这个 coordinator impalad 把这些结果返回给客户端。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3b07478a30a5aff2cef68c3ca3d34d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0538e21e143def5004f07124e47d4ef7/" rel="bookmark">
			【Delphi】逻辑型 Boolean 转字符串 简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候我们需要把逻辑型（Boolean）的True或者False转换成字符串“True”或者“False”。可以使用ToString函数中的TUseBoolStrs.True 来直接转换。
var B : Boolean; S : string; begin //默认用法 B := False; S := B.ToString; //S = "0" B := True; S := B.ToString; //S = "-1" //使用TUseBoolStrs B := False; S := B.ToString(TUseBoolStrs.True); //S = "False" B := True; S := B.ToString(TUseBoolStrs.True); //S = "True" B := False; S := B.ToString(TUseBoolStrs.False); //S = "0" B := True; S := B.ToString(TUseBoolStrs.False); //S = "-1" end; 另外，也可以使用BoolToStr函数
function BoolToStr(B: Boolean; UseBoolStrs: Boolean = False): string 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f33b2b3ffa4b770fc6c24be3c5ada9a2/" rel="bookmark">
			jmeter-JDBC Request中Query type的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JDBC Request中Query type的使用前言Query Type JDBC Request中Query type的使用 前言 ​ 莫名想到很久之前工作遇到一个这样的问题：出差去客户现场，当时环境没有什么数据，又要进行演示，所以需要把数据美化，准备1w条数据进行加工，当时一脸抓瞎，不知道该怎么办，记得是开发应该用存储过程给我进行实现了这个功能，今天看到JDBC后莫名想起了之前的无知，进行记录一下。
​ 这篇文章主要记录一下Query type的使用，如果需要看JDBC的配置和使用请参考其他的博客。
Query Type Query Type主要包括八种类型，每种类型作用都不一样，下面分别进行介绍。
Select statement 这是一个查询语句，只能进行一条sql语句的查询
如果需要进行多条sql语句的查询则需要设置query type为callable statement
Update Statement 这是一条更新语句包含insert和update，也是只能进行一条sql语句的查询
Prepared Select Statement 用于多次执行的select语句
prepared select：用于绑定变量重用执行计划，对于多次执行的SQL语句，prepared statement是最好的选择
ps：prepared select 的第一次执行消耗很高，它的性能主要体现在重复执行上
Prepared Update Statement 和我们的prepared select用法极为类似
Commit 将未存储的SQL语句写入数据库，使用不多
Rollback 撤销对SQL语句的执行过程
AutoCommit(false) 用户处于某个事务中，直到执行一条commit提交或者rollback才能重新开始一个新的事务
注：statement用于为一条sql生成测试计划，如果只执行一次sql，select/update statement是最好的选择
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154dfffff93ad2904a6aa422a2ae7a06/" rel="bookmark">
			尚硅谷-康师傅-MySQL详细笔记(10-18章)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysq详细笔记10-18章 第10章 创建和管理表10.1 基础知识10.1.1 一条数据存储的过程10.1.2 标识符命名规则10.1.3 MySQL中的数据类型 10.2 创建和管理数据库10.2.1 创建数据库10.2.2 使用数据库10.2.3 修改数据库10.2.4 删除数据库 10.3 创建表10.3.1 创建方式110.3.2 创建方式210.3.3 查看数据表结构 10.4 修改表10.4.1 追加一个列10.4.2 修改一个列10.4.3 重命名一个列10.4.4 删除一个列 10.5 重命名表10.6 删除表10.7 清空表10.8 内容拓展拓展1：阿里巴巴《Java开发手册》之MySQL字段命名拓展2：如何理解清空表、删除表等操作需谨慎？！拓展3：MySQL8新特性—DDL的原子化 第11章_数据处理之增删改11.1 插入数据11.1.1 实际问题11.1.2 方式1：VALUES的方式添加11.1.3 方式2：将查询结果插入到表中 11.2 更新数据11.3 删除数据11.4 MySQL8新特性：计算列 第12章 MySQL数据类型12.1 MySQL中的数据类型12.2 整数类型12.2.1 类型介绍12.2.2 可选属性12.2.2.1 M12.2.2.2 UNSIGNED12.2.2.3 ZEROFILL 12.2.3 适用场景12.2.4 如何选择 12.3 浮点类型12.3.1 类型介绍12.3.2 数据精度说明12.3.3 精度误差说明 12.4 定点数类型12.4.1 类型介绍 12.5. 位类型：BIT12.6 日期与时间类型12.6.1 YEAR类型12.6.2 DATE类型12.6.3 TIME类型12.6.4 DATETIME类型12.6.5 TIMESTAMP类型 12.7 文本字符串类型12.7.1 CHAR与VARCHAR类型12.7.2 TEXT类型 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/154dfffff93ad2904a6aa422a2ae7a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/689abb6015cbac92f46c70ffe3a60b16/" rel="bookmark">
			ElasticSearch底层相关原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ElasticSearch文档分值_score计算底层原理 查询的时候会对搜索到的文档进行打分（filter方式不会打分）。
1.boolean model 根据用户的query条件，先过滤出包含指定term的doc，这一步是不会打分的。
2.relevance score算法 [ˈreləvəns] 相关度
简单来说，就是计算出，一个索引中的文本，与搜索文本，他们之间的关联匹配程度
Elasticsearch使用的是 term frequency/inverse document frequency算法，简称为TF/IDF算法，ES底层是基于lucence，而lucence使用的算法：TF/IDF算法。
Term frequency：搜索文本中的各个词条在field文本中出现了多少次，出现次数越多，就越相关
#搜索请求：hello world doc1：hello you, and world is very good doc2：hello, how are you # doc1更相关 Inverse document frequency：搜索文本中的各个词条在整个索引的所有文档中出现了多少次，出现的次数越多，就越不相关。不是针对单个文档了，是针对整个索引库中的文档。（越多越不相关，可以这样理解：主要过滤一些通用词，像：的，啊之类的，所以说是反转。）
# 搜索请求：hello world # 情形：在index中有1万条document，hello这个单词在所有的document中，一共出现了1000次； # world这个单词在所有的document中，一共出现了100次 doc1：hello, tuling is very good doc2：hi world, how are you # 这个时候doc2的相关度分数要高一些，因为doc1含有hello这个单词 Field-length norm：（field长度）field越长，相关度越弱。
# 搜索请求：hello world doc1：{ "title": "hello article", "content": "...... N个单词" } doc2：{ "title": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/689abb6015cbac92f46c70ffe3a60b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/779d3b181a21c2fa29be02bfd52d76bf/" rel="bookmark">
			iOS-TestFlight的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返回上级目录：iOS测试，打包上架相关（Xcode Help）
文章目录 1.在Xcode上打包上传APP，这个过程和你上架正式的APP的过程一模一样2.在App Store Connect中点进你的APP，选中TestFlight,在构建版本中可以选择你从Xcode中上传的app版本。2.1 内部群组 App Store Connect用户,构建的版本不需要审核,测试员只能选你在用户和访问中已经添加和邀请的,可添加100名2.1.1 添加测试员，或构建新版本后会自动给测试邮箱发邀请码，在TestFlight应用中点击兑换，输入兑换码就可以下载app开始测试，随即兑换码失效（只有你能知道有效的邀请码，就能下载测试该app） 2.2 外部群组（除App Store Connect用户以外的群组),构建的版本是需要审核的,最多可添加10000个测试员2.2.1 启用公开链接 3.testflight无法接入App Store, 公开链接无法打开 文档 Xcode --&gt; Help --&gt; 搜索TestFlight 选Distribute an app using TestFlight (iOS, tvOS, watchOS)。你可以看到英文版的帮助文档 下面是中午版文档的地址：
TestFlight Beta 版测试概述（iOS、Apple tvOS、watchOS）
下面我个人来做一个简单的描述
1.在Xcode上打包上传APP，这个过程和你上架正式的APP的过程一模一样 2.在App Store Connect中点进你的APP，选中TestFlight,在构建版本中可以选择你从Xcode中上传的app版本。 2.1 内部群组 App Store Connect用户,构建的版本不需要审核,测试员只能选你在用户和访问中已经添加和邀请的,可添加100名 在内部群组App Store Connect用户中添加测试员，构建的版本不需要审核，而且测试员只能选你在用户和访问中已经添加和邀请的,可添加100名
如果选项中没有找到你想要添加的人，你应该在用户和访问中添加并邀请这个apple id.
2.1.1 添加测试员，或构建新版本后会自动给测试邮箱发邀请码，在TestFlight应用中点击兑换，输入兑换码就可以下载app开始测试，随即兑换码失效（只有你能知道有效的邀请码，就能下载测试该app） 2.2 外部群组（除App Store Connect用户以外的群组),构建的版本是需要审核的,最多可添加10000个测试员 如下图，在外部群组（除App Store Connect用户以外的群组，如下图中的test,test1）中,构建的版本是需要审核的，每个群组最多可添加10000个测试员
2.2.1 启用公开链接 如下图，当版本审核通过后，可以启用公开链接。然后你只要把链接发给测试员就可以了
打开公开链接，会出现如下的网页
3.testflight无法接入App Store, 公开链接无法打开 上面两个问题都可以用下面的解决方案：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/779d3b181a21c2fa29be02bfd52d76bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7776a56d6d0a0e49e7ebb257fd7778/" rel="bookmark">
			VSCODE Unable to launch browser:“Unable to find Chrome version ...“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决 ： 安装一下live sever插件
其他软件调用浏览器都好好的，就这个辣鸡vscode要自己配置。根据网友的方法，地址栏输入chrome://version，我查到了
并且填写上去
但是还是报错，真的很绝望，有没有大佬知道怎么回事，者须
妹想到啊
装个view in browser插件就好了，太沙雕了
上面的"\" 改成"/\" 把斜线转义一下
解决 ： 安装一下live sever插件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6c329fafc0328518bd98d7da78eb8a/" rel="bookmark">
			2022第13届蓝桥杯Java省赛B组个人题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 A. 星期计算B. 山C. 字符统计D. 最少刷题数E. 求阶乘F. 最大子矩阵G. 数组切分H. 回忆迷宫I. 红绿灯J. 拉箱子个人总结 A. 星期计算 思路解析：
大整数类的应用，计算幂后对其取余。官方给的计算器也能直接计算其值
答案：
取余结果为1，所以答案为7
代码：
package lanqiao; import java.math.BigInteger; //答案：6+1=7 public class A_星期计算 { public static void main(String[] args) { // TODO Auto-generated method stub BigInteger num = new BigInteger("20"); BigInteger ans = new BigInteger("1"); for(int i=1;i&lt;=22;i++) { ans = ans.multiply(num); } System.out.println(ans); System.out.println(ans.mod(new BigInteger("7"))); } } B. 山 思路解析：
因为只是个填空题，可以暴力枚举，判断是否为回文数（字符串翻转和原串相同）以及前n/2是否满足递增
答案：
3138
代码：
package lanqiao; public class B_山 { //答案：3138 public static void main(String[] args) { // TODO Auto-generated method stub long ans=0; for(long i=2022;i&lt;=2022222022;i++) { if(check(i)) { ans++; } } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6c329fafc0328518bd98d7da78eb8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca2eea6c5046985d5974a14787402cf/" rel="bookmark">
			vmware 安装centos 7时网络配置注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装时，一定要选择64位，否则后面将会有找不到网络设备的报错
以下以 vmware 16为例
安装时需要开启网络，如果在开如没有选择centos 7 64位时，网络设备里面就会出现没有网络设备的报错
ip可自动获取也可以手动设置，网关设置成虚拟机的IP起止范围内
如果要使用桥接网络方式，那么最好让它自动获取，在安装前将网络的模式设成桥接方式，否则安装好后连接网络的设置会很麻烦
以下是成功配置后，/etc/sysconfig/network-scripts/ifcfg-ens33配置文件
NAT模式： TYPE="Ethernet" BOOTPROTO=none DEFROUTE="yes" IPV4_FAILURE_FATAL="no" IPV6INIT="yes" IPV6_AUTOCONF="yes" IPV6_DEFROUTE="yes" IPV6_FAILURE_FATAL="no" IPV6_ADDR_GEN_MODE="stable-privacy" NAME="ens33" UUID="fc838648-650e-4977-9ebb-b40e47b3ecb1" DEVICE="ens33" ONBOOT="yes" IPADDR=192.168.85.129 PREFIX=24 IPV6_PEERDNS=yes IPV6_PEERROUTES=yes 如果在安装时忘记开启网络服务，centos7中则可以使用nmtui 命令进行开启
如果NM托管未开启，会导至报错“Connection 'ens33' is not available on device ens33 because device is strictly unmanaged”
则需以下操作：
查看托管状态 nmcli n
显示 disabled 则为本文遇到的问题，如果是 enabled 则可以不用往下看了
开启 托管
nmcli n on
重启网络服务
systemctl restart network
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb37abb0fb8cdda53b0c39a821cac5cc/" rel="bookmark">
			一份超强的 CS 自学指南！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👇👇关注后回复 “进群” ，拉你进程序员交流群👇👇
作者丨火宝
来源丨编程导航（ID：codenav）
编程导航 每周新增资源优选特辑 10
编程导航 致力于推荐优质编程资源 💎
项目开源仓库：https://github.com/liyupi/code-nav
跪求一个 star ⭐️
哈喽大家好！我是编程导航的小编火宝。
我们的一周一会 time ！一周不见我可真是想si你们啦，本周的推荐里除了好用的工具之外，还有一份超级适合自学的指南哦，卷起来（doge）
快和小编一起来看看本周有什么不错的资源吧！（排名不分先后）
（温馨提醒：近期疫情严重，大家要多多注意，并做好防护工作呀！）
CS 自学指南 新冠肆虐，网课当道，CS 爆火，这一系列的事件都让自学计算机成为了一种潮流。
CS 自学指南是一本北大信科的同学编写的计算机自学指南，其中包括了必学工具、国外高质量CS课程汇总、环境配置、经典书籍推荐等等。
任何想要自学计算机的朋友都可以参考这本书。如果你已经有了一定的计算机基础，只是对某个特定的领域感兴趣，可以选择性地挑选你感兴趣的内容进行学习。如果你是一个刚刚接触计算机的小白，这本书或许能成为你的攻略，让你花最少的时间掌握你所需要的知识和能力，你可以完全凭借这些开源社区的优质资源，少走弯路，在 2-3 年内成长为一个多方面均有所涉猎的全能程序员。
Vue Grid Layout Vue Grid Layout 一个类似于 Gridster 的可拖动并调整大小的栅格布局系统，适用于 Vue.js，灵感来源于 React Grid Layout。
它有可拖动的、可调整大小的、静态的小部件，拖拽和调整大小时还可进行边界检查，是可序列化和还原的响应式布局，在增减部件时可避免重建网格。
ByteLegend ByteLegend 是一个免费、开源的多人在线 RPG 游戏，通过这个游戏，你可以学到现实世界里的编程技能。
使用 GitHub 账号即可登录，游戏内容包括和 NPC 对话，收集物品，完成任务等等，可以边玩边获得真实世界里的高薪编程技能。在游戏里看到的任何东西都是可以修改的：游戏地图、流程、NPC对话、国际化的文本等等。它支持地球上的所有语言，只需要点击网页右上角的切换语言按钮即可。
亿图脑图 亿图脑图MindMaster 是一款基于云的跨端思维导图软件。它同时支持 MacOS、Linux、iOS、Android、Windows 等多种版本，还提供了 web 在线版本，文件可通过云端储存实现多端同步，并且支持通过小程序、网页链接的方式进行分享，支持多人实时协同，实现高效协作。
基于跨平台，云存储的产品优势，打破设备边界，让我们可以随时随地捕捉灵感、激发创意。其提供了丰富的布局、样式、主题及配色方案，更有 10万+ 的导图模板，可轻松创作出高颜值思维导图。
QuickRedis QuickRedis 是一款国人开源、免费、功能强大的 Redis 可视化管理工具。QuickRedis 支持 Windows 、 Mac OS X 和 Linux 下运行。它支持直连、哨兵、集群模式，支持亿万数量级的 key，还有令人兴奋的 UI。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb37abb0fb8cdda53b0c39a821cac5cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff123bfa191daa0f9a2f28e663041f7/" rel="bookmark">
			比较两csv文件的内容，取差集并输出成csv文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import pandas as pd import numpy as np data = pd.read_csv(r'H:\Microsoft-Malware-Detection-using-Machine-Learning-master\train_data.csv',low_memory=False) data1 = pd.read_csv(r'H:\data\test\asm.csv',low_memory=False) # print(data.columns)#获取列索引值 # print(data.index)#获取行索引值 data_Id = data['Id'] #获取名字为Id列的数据 data1_Id = data1['Id'] data_list = data_Id.values.tolist()#将csv文件中Id列中的数据保存到列表中 data1_list = data1_Id.values.tolist() a = set(data_list) b = set(data1_list) c =list(a-b) print(c) with open("non_upcode.csv", "w", newline='') as csvfile: for i in c: csvfile.write(i) csvfile.write('\n') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9700ae27b893e46bb2628db1647311dd/" rel="bookmark">
			VMware 产品多个高危漏洞 (CVE-2022-22954,CVE-2022-22955,CVE-2022-22956,CVE-2022-22957,CVE-2022-22958,CVE-2022
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞详情 VMware官方发布安全通告告，其中包含了影响VMware Workspace ONE Access、Identity Manager 和 vRealize Automation组件的多个高危漏洞（CVE-2022-22954、CVE-2022-22955、CVE-2022-22956、CVE-2022-22957、CVE-2022-22958、CVE-2022-22959、CVE-2022-22960、CVE-2022-22961），漏洞详情如下：
CVE-2022-22954
漏洞类型：远程命令执行
风险等级：严重
漏洞描述：VMware Workspace ONE Access 及 Identity Manager 存在一个由服务器模板注入导致的远程命令执行漏洞，未经身份验证的攻击者可以利用此漏洞进行远程任意代码执行。
CVE-2022-22955、CVE-2022-22956
漏洞类型：身份验证绕过
风险等级：严重
漏洞描述：VMware Workspace ONE Access 存在OAuth2 ACS 身份验证绕过漏洞。未经身份验证的攻击者可以利用该漏洞绕过身份验证机制并对系统中存在的节点进行操作
CVE-2022-22957、CVE-2022-22958
漏洞类型：远程命令执行
风险等级：严重
漏洞描述：VMware Workspace ONE Access, Identity Manager 以及 vRealize Automation 存在由 JDBC 注入导致的远程命令中执行漏洞，未经身份验证的攻击者可以利用此漏洞进行远程任意代码执行。
CVE-2022-22959
漏洞类型：跨站请求伪造
风险等级：高危
漏洞描述：VMware Workspace ONE Access, Identity Manager 以及 vRealize Automation 存在 CSRF跨站请求伪造漏洞，攻击者能够欺骗受害用户无意中完成JDBC URI的验证。
CVE-2022-22960
漏洞类型：本地权限提升
风险等级：高危
漏洞描述：VMware Workspace ONE Access, Identity Manager 以及 vRealize Automation 存在本地权限提升漏洞，攻击者可利用该漏洞将权限提升至 root。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9700ae27b893e46bb2628db1647311dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb3af0d948061846d796b30a37d95df0/" rel="bookmark">
			人人开源 fastvue npm install失败问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 node.js
➜ ~ node -v
v12.18.2
设置镜像仓库地址：
npm config set registry https://registry.npm.taobao.org 修改项目 package.json
"node-sass": "^4.14.1", 【 node12对应的sass版本是4.14 】之前安装失败的，清理缓存（可直接删除 node_modules 目录）
npm rebuild node-sass
npm uninstall node-sass
先单独从淘宝镜像把 nod-sass 下载下来，然后再进行编译：
npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/进入项目终端安装项目所有的依赖
npm install
npm run dev 编译成功。
上面转载评论：Java项目《谷粒商城》Java架构师 | 微服务 | 大型电商项目_哔哩哔哩_bilibili
Q:Can't find Python executable "python", you can set the PYTHON env variable.
1.如果没有python 安装python
2.如果安装过python WIN +R cmd下输入python 进入微软商店，如果是，再此电脑-》高级属性-》环境变量-》path中尽量上浮python的安装路径即可。cmd输入python出现版本号就是安装成功
Q: ENOENT: no such file or directory, scandir 'xxx\node-sass\vendor' 出现上述bug直接进入前端项目renre-fast-vue根路径进入cmd
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb3af0d948061846d796b30a37d95df0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c3cf6169fae17db7a1872a0105af62/" rel="bookmark">
			熟悉HDFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）熟悉HDFS操作常用的Shell命令 （1）使用hadoop用户登录Linux系统，启动Hadoop（Hadoop的安装目录为“/usr/local/hadoop”），为hadoop用户在HDFS中创建用户目录“/user/Hadoop”。
（2）接着在HDFS的目录“/user/hadoop”下，创建test文件夹，并查看文件列表。
（3）将Linux系统本地的“～/.bashrc”文件上传到HDFS的test文件夹中，并查看test。
（4）将HDFS文件夹test复制到Linux系统本地文件系统的“/usr/local/hadoop”目录下。
（二）编程实现以下功能： （1）向 HDFS 中上传任意文本文件，如果指定的文件在 HDFS 中已经存在，则由用户来
指定是追加到原有文件末尾还是覆盖原有的文件；
import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.*; import java.io.*; public class HDFSAPi1{ /** * 判断路径是否存在 */ public static boolean test(Configuration conf, String path) throws IOException { FileSystem fs = FileSystem.get(conf); return fs.exists(new Path(path)); } /** * 复制文件到指定路径 * 若路径已存在，则进行覆盖 */ public static void copyFromLocalFile(Configuration conf, String localFilePath, String remoteFilePath) throws IOException { FileSystem fs = FileSystem.get(conf); Path localPath = new Path(localFilePath); Path remotePath = new Path(remoteFilePath); /* fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c3cf6169fae17db7a1872a0105af62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7699ca18876e1e4bd1e361e4cdc7bd0/" rel="bookmark">
			Linux重置MySQL8.0密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux重置MySQL8.0密码 系统版本:CentOS 7.5.1804
MySQL版本:8.0.28
没改过密码 MySQL版本在8.0以上安装时会自动生成一个默认的密码，这个密码比较复杂可以通过命令查看
grep 'temporary password' /var/log/mysqld.log
这里 ggovBlr2yg)h就是默认密码
可以通过输入这个密码进入数据库
默认密码不正确 在mysql的配置文件 /etc/mysql.cnf中增加一个跳过输密码的配置
skip-grant-tables
重新启动mysql服务
systemctl restart mysqld.service
输入密码时直接回车即可进入数据库
进入数据库后 进入数据库后，再通过修改密码的命令来修改密码
use mysql; update user set authentication_string=password("新密码")where user="root"; 如果这里成功就直接修改成功了。注意修改成功后要，将配置文件新加的删除或者注释掉。
这里要注意，mysql默认的规则是大小写、特殊字符、8位以上，必须都要满足才能修改成功。
修改失败 如果报错就用下面的方式
update user set authentication_string='' where user='root'; 将密码设置为空，然后将配置文件新加的删除或者注释掉，重新启动MySQL服务。
systemctl restart mysqld.service
进入mysql回车即可
因为没有密码，进来就要输入新密码，其他命令无效。
这里要注意，mysql默认的规则是大小写、特殊字符、8位以上，必须都要满足才能修改成功。
ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码'; 提示OK就是修改成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32fd3158853d3d7290b6e73599269fe9/" rel="bookmark">
			c语言 -- 数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.一维数组的创建和初始化
2.一维数组的使用
3.一维数组在内存中的存储
4.二维数组的创建和初始化
5.二维数组的使用
6.二维数组在内存中的存储
7.数组作为函数参数
1.一维数组的创建和初始化 数组是什么？
数组是一组相同类型元素的集合。
数组的创建： type_t arr_name [const_n] type_t -- 数组的元素类型 ； arr_name -- 数组的命名 ; const_n是一个常量表达式，用来表示数组元素的大小 ，如 1+1 ，3，2-1等等
//创建一个数组 -- 存放整型元素，元素个数为10 int main() { int arr_1[10] ; //要注意数组的个数表示必须得是常量表达式，变量是不能放进去的！ //如 int n = 5; int arr2[n]; //上面这个数组就是错误的，因为它的括号里放的是变量而不是常量 return 0; } 数组的初始化： 数组的初始化是指，在创建数组的同时给数组的内容设定一些合理的初始化值（初始化）
首先是非字符型的初始化，设我们规定数组中有n个元素
1.如果只给x(x&lt;=n-1)个值设定初始化值，则被称为不完全初始化，不完全初始化中没被设定值的元素被默认初始化为 0 2.int arr[x] = { } (花括号中被括起来的就是被主动设定初始化值的元素，被初始化的元素的顺序是下标从0开始数，默认初始化为0的则不显示)
另一种是字符型的初始化，这一种的初始化则较为多样
1.常规的一个字符一个字符的初始化： char arr[n]={ 'a' , 'b' ,'c' }
2.用字符串来初始化 ： char arr[n] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32fd3158853d3d7290b6e73599269fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb24b948b409d7e0ac9c54c0dfac053b/" rel="bookmark">
			STM32cubeIDE初始化之IO口初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都了解stm32cubeide可以通过配置图形化界面然后直接调用函数就好了。但是做项目的时候，有些特殊情况就不能更改图形化界面，这时候我们就需要自己写初始化函数了.
一个技巧就是可以新建一个工程就是自己对应的芯片 然后根据需求进行配置 通过配置 系统会生成初始化内容 然后直接复制粘贴即可 这里简单介绍一下初始化内容的含义
GPIO
void MX_GPIO_Init(void);
GPIO_InitTypeDef GPIO_InitStruct; //定义初始化结构体
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); //使能GPIOA时钟
GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; //配置模式 推挽输出/开漏输出
GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0; //配置哪个IO口
GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; //配置IO口速度,仅输出有效
GPIO_Init(GPIOA,&amp;GPIO_InitStruct); //初始化GPIOA的参数为以上结构体
例子：GPIO_InitTypeDef GPIO_InitStruct = {0};// //定义初始化结构体
__HAL_RCC_GPIOE_CLK_ENABLE();//使能GPIOE时钟
E9
HAL_GPIO_WritePin(GPIOE, GPIO_PIN_9|GPIO_PIN_11|GPIO_PIN_13, GPIO_PIN_RESET);//写低电平
PIO_InitStruct.Pin = GPIO_PIN_9; //配置哪个IO口
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; //配置模式 推挽输出
GPIO_InitStruct.Pull = GPIO_NOPULL; //上拉下拉电阻 上拉电阻/下拉电阻/无上拉或下拉
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; //配置IO口速度,仅输出有效
HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct); //初始化GPIOA的参数为以上结构体
E11
GPIO_InitStruct.Pin = GPIO_PIN_11; //配置哪个IO口
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD; //配置模式 开漏输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb24b948b409d7e0ac9c54c0dfac053b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a0bbd49177923eb86ed9193720e75f/" rel="bookmark">
			latex subsubsubsection(四层深度)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，latex最多只有\subsubsection,即最多三层深度的section，但是如果想要用四层深度的话，得自己定义command：
\newcommand{\subsubsubsection}[1]{\paragraph{#1}\mbox{}\\} \setcounter{secnumdepth}{4} % how many sectioning levels to assign numbers to \setcounter{tocdepth}{4} % how many sectioning levels to show in ToC 如上，在导言区加上上述命令，就可以。
另外还有很多其他的方法也能实现相同的效果，参见：
How to add an extra level of sections with headings below \subsubsection
笔者从其中挑了一个最简单的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9549323e1d907116240c48da0ce0bdbb/" rel="bookmark">
			Linux下rm命令详解及C/C&#43;&#43;代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rm 命令是 Unix/Linux 操作系统中的基本命令之一。rm（即删除）命令用于删除 Linux 和其他类 Unix 操作系统上的文件和目录。此命令通常以静默方式运行，运行 rm 命令时应非常小心，因为一旦删除文件，就无法恢复文件和目录的内容。
Linux rm 命令
rm 删除命令行中指定的每个文件。 默认情况下，它不会删除目录。当使用 -r 或 -R 选项执行 rm 时，它会递归地删除任何匹配的目录、它们的子目录以及它们包含的所有文件。
rm命令的语法：
rm [选项] [-r 目录] 文件名
方括号中的项目是可选的。当仅与一个或多个文件的名称一起使用时，rm 删除所有这些文件而不需要用户确认。
以下示例将使你更好地了解该工具的工作原理。
如何使用 rm 命令删除文件
你所要做的就是将文件的名称（如果它们不在当前工作目录中，则连同路径一起）作为输入传递给 rm 命令。
以下示例中，rm 将立即删除名为 test1.txt、test2.txt
如果文件不存在或用户没有删除它的适当权限，则会返回错误消息。写保护的文件会在删除前提示用户确认（y 表示是，n 表示否）。文件位于即使这些文件没有写保护，写保护目录中的文件也永远无法删除。
如何强制 rm 忽略不存在的文件
-f（即强制）选项告诉 rm 删除所有指定的文件，无论是否写保护，而不提示用户。如果指定的文件不存在，它不会显示错误消息或返回错误状态。但是，如果尝试删除写保护目录中的文件，此选项将不会显示错误消息。
如何在每次删除之前使 rm 提示
-i（即交互式）选项告诉 rm 在删除每个文件和目录之前提示用户确认。如果同时指定了 -f 和 -i 选项，则指定的最后一个生效。
如何使用 rm 命令删除目录
作为安全措施，rm默认不删除目录，为了删除目录，需要使用-r选项，与-R选项相同，该选项递归删除参数中的目录及其内容列表；
rm -r [dir name]
也就是说，指定目录将首先清空所有子目录（包括其子目录和文件等）和文件，然后删除。通常会提示用户删除目录中的任何写保护文件，除非-使用 f 选项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9549323e1d907116240c48da0ce0bdbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c364cc344590f23e9d91c13a402efec5/" rel="bookmark">
			StampedLock（印戳锁）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简介2. 代码示例 1. 简介 StampedLock（印戳锁）是对ReentrantReadWriteLock读写锁的一种改进，主要的改进为：在没有写只有读的场景下，StampedLock支持不用加读锁而是直接进行读操作，最大程度提升读的效率，只有在发生过写操作之后，再加读锁才能进行读操作
StampedLock有以下3种模式：
悲观读锁：与ReadWriteLock的读锁类似（这里的读锁不可重入），多个线程可以同时获取悲观读锁，悲观读锁是一个共享锁。乐观读锁：相当于直接操作数据，不加任何锁，连读锁都不要。在操作数据前并没有通过CAS 设置锁的状态，仅仅通过位运算测试。如果当前没有线程持有写锁 ，则简单地返回 一个非 0 的 stamp 版本信息 ，返回0则说明有线程持有写锁。 获取该 stamp 后在具体操作数据前还需要调用validate 方法验证该 s tamp 是否己经不可用写锁：与ReadWriteLock的写锁类似，写锁和悲观读锁是互斥的。虽然写锁与乐观读锁不会互斥，但是在数据被更新之后，之前通过乐观读锁获得的数据已经变成了脏数据。是 一 个排它锁或者独占锁，某时只有 一 个线程可以获取该锁，当二个线程获取该锁后，其他请求读锁和写锁的线程必须 等待 ，这类似于ReentrantReadWriteLock 的写锁（不同点在于这里的写锁不可重入） StampedLock 的读写锁都是不可重入锁，所以在获取锁后释放锁前不应该再调用会获取锁的操作，以避免造成调用线程被阻塞
2. 代码示例 package innerlock; import java.util.Date; import java.util.HashMap; import java.util.concurrent.locks.StampedLock; public class StampedLockTest { //创建1个map 代表共享数据 final static HashMap&lt;String, String&gt; MAP=new HashMap&lt;&gt;(); //创建一个印戳锁 final static StampedLock STAMPED_LOCK=new StampedLock(); /* * 对共享数据的写操作 */ public static Object put(String key,String value) { long stamp=STAMPED_LOCK.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c364cc344590f23e9d91c13a402efec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ea960f8d980a0498204f2a524d9057/" rel="bookmark">
			C&#43;&#43;工厂模式与在反射中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++工厂模式 设计模式：可复用面向对象软件及基础：2-3 创建者模式：（Factory method）工厂方法_~怎么回事啊~的博客-CSDN博客
C++ 反射 反射的概念： 指程序在运行时，访问、检测和修改它本身状态或行为的一种能力。
简单的来说，就是一种自描述和自控制的能力。如果联想到镜子，就可以很好的理解，你能通过镜子看到自己，包括自己的动作，自己的外表。唯一不同的地方是，计算机语言的反射能力还包含对看到的自己采取措施。
反射的作用 在计算机编程语言中，反射机制可以用来：
获取类型的信息，包括属性、方法动态调用方法动态构造对象从程序集中获得类型 反射的缺点 性能：反射可以理解成是一种解释操作，这个过程总是要慢于直接调用的。当然，性能问题的程度是可以控制的，如果程序在很少涉及的地方使用，性能将不会是一个问题。
反射模糊了程序内部实际发生的事情，会比直接代码更加复杂。
缺点不能掩饰其优点，针对不同的场景使用合理的技术才是最高境界。
反射的使用场景 序列化（Serialization）和数据绑定（Data Binding）远程方法调用（RMI）对象/关系数据映射（O/R mapping） 关于c++的反射 C++ 原生是不支持反射的，需要自己造轮子。
何在C++中实现简单的反射。 场景：
C++序列化，与反序列化。序列化就是将对象编程二进制的形式存储在磁盘上，或者通过网络传输给另一台机器。反序列化就是序列化的逆过程。但是这个逆过程，必须要根据字符串来判断将二进制流转化成什么类型的对象。
工厂模式，常常是根据一个字符串来获取想要的对象。但是为了满足开闭原则，我们不能简单的在工厂类中不断的修改生产函数来扩展不同的类型。这个时候，需要利用反射，使用抽象类。
思路是：
使用map，映射字符串和生产函数每次构造新类型时，将生产函数注册到map中工厂函数通过map获得生产函数，建造不同的对象 工厂对象 #pragma once #include &lt;map&gt; #include &lt;string&gt; /// 对象创建模版函数， 用到了 c++11 的可变参数 template&lt;class YourClass, typename ...ArgType&gt; void* __createObjFunc(ArgType... arg) { return new YourClass(arg...); } /// 需要反射的类使用该宏注册 #ifndef ReflectRegister #define ReflectRegister(YourClass, ...) \ static int __type##YourClass = ObjFactory::regCreateObjFunc(#YourClass, (void*)&amp;__createObjFunc&lt;YourClass, ##__VA_ARGS__&gt;); #endif /// 对象工厂，根据类名创建 class ObjFactory { public: /// 根据类名创建 BaseClass 子类的对象 template&lt;class BaseClass, typename .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5ea960f8d980a0498204f2a524d9057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8301b340d8c3b1aac96e096a6184c52e/" rel="bookmark">
			C&#43;&#43; STL 在算法中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、vector变长数组 有clear清空操作。支持比运算，两个vector按字典序比较大小 2、string substr string substr (size_t pos = 0, size_t len = npos) const; 返回一个string中下标pos开始，长度为len的子字符串，若len超过最大长度则直接返回从pos到末尾。
c_str c_str()返回一个string中首元素的下标。用于用scanf输出一个string：
scanf("%s", a.c_str()); 3、queue push()向队尾插入一个元素
empty()判空
size()返回队列大小
front()返回队头元素
back()返回队尾元素
pop()弹出队头元素
4、pair 支持比较运算，以first为第一关键字，以second为第二关键字，进行字典序比较
5、priority_queue优先队列（实现原理是堆，默认是大根堆） 需要include&lt;queue&gt;头文件才能使用。
没有clear。push插入一个元素top返回堆顶元素pop弹出堆顶元素 如何定义小根堆？ 法一：插入元素时，插入-x。这可太妙了！法二：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap; 6、stack栈 sizeemptypush栈顶插入top返回栈顶pop弹出栈顶 7、deque双端队列（用的很少，效率太低了） sizeemptyclearfront / backpush_back / pop_backpush_front / pop_frontbegin / end[] 8、set，map，multiset，multimap（基于平衡二叉树(红黑树)，动态维护有序序列） 他们都支持：
size
empty
clear
begin / and 及其++ -- （时间复杂度也为O(logn) ）
set / multiset（下面所有操作时间复杂度为logn） insert插入一个数
find查找一个数
count返回某一个数的个数
erase：
——输入是一个具体数x，参数所有x 时间复杂度：O(k + logn) ，k是x的个数，n是元素个数——输入一个迭代器，删除这个迭代器 set的核心操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8301b340d8c3b1aac96e096a6184c52e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2116c44ca3e9873bd898c97200035b4e/" rel="bookmark">
			（三）局部加权线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 局部加权线性回归模型2. 求解方法3. 代码实现 前言 ​ 线性回归只能拟合线性曲面（广义的曲面），如果一个回归任务中的输出变量 y ( y ∈ R ) y\,\,\left( y\in \mathbb{R} \right) y(y∈R) 关于特征向量 x = ( x 0 , x 1 , ⋯ , x n ) ( x ∈ R n + 1 , x 0 = 1 ) x=\left( x_0,x_1,\cdots ,x_n \right) \,\,\left( x\in \mathbb{R} ^{n+1},x_0=1 \right) x=(x0​,x1​,⋯,xn​)(x∈Rn+1,x0​=1) 不是线性的，那怎样拟合可以比较好呢？局部加权线性回归是一种方法。
1. 局部加权线性回归模型 ​ 当两个样本点的特征向量距离较近时，它们的输出变量通常比较接近，也就是说它们具有相似的性质。现在我们有 m m m 个训练样本点 ( x ( 1 ) , y ( 1 ) ) , ( x ( 2 ) , y ( 2 ) ) , ⋯ , ( x ( m ) , y ( m ) ) \left( x^{\left( 1 \right)},y^{\left( 1 \right)} \right) ,\left( x^{\left( 2 \right)},y^{\left( 2 \right)} \right) ,\cdots ,\left( x^{\left( m \right)},y^{\left( m \right)} \right) (x(1),y(1)),(x(2),y(2)),⋯,(x(m),y(m)) 构成训练集。那么当我们给一个特征向量 x x x 时，要根据训练集中的信息预测出它的输出变量 y y y ，距离 x x x 越近的训练集中的样本点越应该被重视。换句话说，我们需要给训练集中的每个样本点一个权值，距离 x x x 越近的样本点的权值应该越大，这是赋权的一个原则，那么具体应该如何赋权呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2116c44ca3e9873bd898c97200035b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24dce881625ca505419684a4b6bbd7d/" rel="bookmark">
			PTA——7-3 我是升旗手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入格式: 输入包括两行。 第一行:包括一个整数n，表示班级里共有n位同学。 第二行:包含n个三位数，表示每一位同学的身高。
输出格式: 输出身高最高的同学的身高。
样例"&gt;输入样例: 4 130 125 129 140 输出样例: 140 #include&lt;stdio.h&gt; int main() { int n,h=0,a; scanf("%d",&amp;n); while(n!=0) { scanf("%d",&amp;a); if(a&gt;h) { h=a; } n--; } printf("%d\n",h); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ffa980db9b90397bf1037f5bf96837/" rel="bookmark">
			大众点评文字反爬
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【注】1、2022年4月10日抓取的大众点评的评论数据
2、该网站采用了字体反爬，是抓取过程中的主要难点
3、网站反爬更新的速度很快，基本上几个礼拜，一个月就会更新一次，所以本文的代码直接copy的话，可能会执行不了。但是大概思路是没问题的
1、分析网站 经过分析，发现网站的评论 被加密了。而且他不是全部加密他是有几个字进行了加密，有几个字又没有进行加密，这无疑是增加了我们爬取的工作量，但是，第一步应该还是先进行解密，即找到对应的css字体加密文件（.woff文件）
2、如何打开我们下载的woff 字体文件 这里打开方式有两种：一种下载 FontCreator 软件。第二种使用在线字体编辑器。这里两种方式都提供给大家，供大家参考使用.
FontCreator
链接：点击下载
提取码：dzd4
在线字体编辑器
链接：点击使用
3、处理下载的 woff 文件 处理woff文件，使用 fontTools 的模块去进行解析，但是需要注意几个点：
1、 woff_str_601 : 里面的文字来源于下载的woff文件，这里需要手动输入不过这里面的字体好像一直都没有变化过，理论上直接copy即可。但是时间久的话，楼主也不太确定了。
2、注意两个方法的区别： getBestCmap() 与 getGlyphOrder() getBestCmap() # 获取code和name的关系
getGlyphOrder() # 形状和字体的关系
【注】 为什么要提一个这个，因为之前用的值 getBestCmap() 转成的 十与十六进制的形式，方便与加密的字符进行匹配，最后发现其实不对，匹对的数据有误！！最后改用 getGlyphOrder() 用最原始的unicode 代码来进行匹配，可以见 下面的 步骤 第六步 最后说明一下，这里需要自己尝试，一开始谁也不能确定一定就行，所以还是需要多实践，尝试，从错误中寻找答案。
代码如下：
from fontTools.ttLib import TTFont def woff_dict(key): woff = TTFont(r'./字体文件/2850eeb5.woff') # 读取woff文件 # woff文件中ID编号为2~602的601个字符 woff_str_601 = '1234567890店中美家馆小车大市公酒行国品发电金心业商司超生装园场食有新限天面工服海华水房饰城乐汽香部利子老艺花专东肉菜学福饭人百餐茶务通味所山区门药银农龙停尚安广鑫一容动南具源兴鲜记时机烤文康信果阳理锅宝达地儿衣特产西批坊州牛佳化五米修爱北养卖建材三会鸡室红站德王光名丽油院堂烧江社合星货型村自科快便日民营和活童明器烟育宾精屋经居庄石顺林尔县手厅销用好客火雅盛体旅之鞋辣作粉包楼校鱼平彩上吧保永万物教吃设医正造丰健点汤网庆技斯洗料配汇木缘加麻联卫川泰色世方寓风幼羊烫来高厂兰阿贝皮全女拉成云维贸道术运都口博河瑞宏京际路祥青镇厨培力惠连马鸿钢训影甲助窗布富牌头四多妆吉苑沙恒隆春干饼氏里二管诚制售嘉长轩杂副清计黄讯太鸭号街交与叉附近层旁对巷栋环省桥湖段乡厦府铺内侧元购前幢滨处向座下臬凤港开关景泉塘放昌线湾政步宁解白田町溪十八古双胜本单同九迎第台玉锦底后七斜期武岭松角纪朝峰六振珠局岗洲横边济井办汉代临弄团外塔杨铁浦字年岛陵原梅进荣友虹央桂沿事津凯莲丁秀柳集紫旗张谷的是不了很还个也这我就在以可到错没去过感次要比觉看得说常真们但最喜哈么别位能较境非为欢然他挺着价那意种想出员两推做排实分间甜度起满给热完格荐喝等其再几只现朋候样直而买于般豆量选奶打每评少算又因情找些份置适什蛋师气你姐棒试总定啊足级整带虾如态且尝主话强当更板知己无酸让入啦式笑赞片酱差像提队走嫩才刚午接重串回晚微周值费性桌拍跟块调糕' # ['cmap']为字符与Unicode编码的映射关系列表 woff_unicode = woff['cmap'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ffa980db9b90397bf1037f5bf96837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f0674b85f780281556045f54e0792f/" rel="bookmark">
			数据库学习记录——错题总结（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一套 1.对关系模型叙述错误的是（ ）。
正确答案: D 你的答案: D (正确)
建立在严格的数学理论、集合论和谓词演算公式的基础之上
微机 DBMS 绝大部分采取关系数据模型
用二维表表示关系模型是其一大特点
不具有连接操作的 DBMS 也可以是关系数据库系统
关系模型是指用二维表的形式表示实体和实体间联系的数据模型。在二维表中的行定义，即对关系的描述称为关系模式。
关系模型的特点：
1、 数据结构单一：关系模型中，不管是实体还是实体之间的联系，都用关系来表示，而关系都对应一张二维数据表，数据结构简单、清晰。
2、关系规范化，并建立在严格的理论基础上：构成关系的基本规范要求关系中每个属性不可再分割，同时关系建立在具有坚实的理论基础的严格数学概念基础上。
3、概念简单，操作方便：关系模型最大的优点就是简单，用户容易理解和掌握，一个关系就是一张二维表格，用户只需用简单的查询语言就能对数据库进行操作。
故A、C正确；
常用的DBMS（数据库管理系统）如MySQL等基本上都是基于关系模型的关系型数据库，故B正确。
2.在数据库三级模式结构中，描述数据库中全体逻辑结构和特性的是？
正确答案: D 你的答案: B (错误)
外模式
内模式
存储模式
模式
用户级对应外模式，概念级对应模式，物理级对应内模式
SQL语言支持数据库三级模式结构，在SQL中，模式对应于基本表，内模式对应于存储文件，外模式对应于视图和部分基本表，元组对应于表中的行，属性对应于表中的列
模式（Schema）
模式也称为：逻辑模式，它是DB中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。模式层是数据库模式结构的中间层，既不涉及到数据的物理存储细节和硬件环境，也与具体的应用程序、应用开发工具以及高级程序设计语言无关（C、C++、JAVA等）。
模式就是数据库数据在逻辑上的视图，且一个数据库只有一个模式。实际工作中，模式就等同于程序员创建一个具体的数据库的全部操作，如：这是一个MySQL数据库，有2张表，每个表的名字，属性的名字、类型、取值范围，主键，外键，索引，其他完整性约束等等。
DBMS提供模式描述语言（模式DDL）来严格地定义模式。
外模式
外模式也称为：子模式(subschema)/用户模式，它是数据库用户（应用程序员、最终用户）能够看到的使用的局部数据的逻辑结构和特征的描述，是数据库的数据视图，是与某一个应用有关的数据的逻辑表示。
外模式通常是模式的子集。一个数据库可以有多个外模式。同一个外模式可以为某一用户的多个应用系统所使用，但一个应用系统只能使用一个外模式。
外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据是不可见的。
DBMS提供子模式描述语言（子模式DDL）来严格地定义子模式。
内模式
内模式也称为：存储模式(Storage schema)，一个数据库只有一个内模式。它是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。如：记录的存储方式是堆存储，还是按照某些属性值的升（降）存储，还是按照属性值聚簇（cluster）存储；索引按照什么方式组织，是B+树索引，还是hash索引等等。
DBMS提供内模式描述语言（内模式DDL/存储模式DDL）来严格定义内模式。
3.已知事务 T1 的封锁序列为： LOCK S(A) … LOCK S(B) … LOCK X©
… UNLOCK(B) … UNLOCK (A) … UNLOCK ©
事务 T2 的封锁序列为： LOCK S(A) … UNLOCK (A) … LOCK S(B)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f0674b85f780281556045f54e0792f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe71a94c8a1807c46fc5a8d5f15ba1ea/" rel="bookmark">
			Java学习记录——错题总结（二十五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一套 1.JVM内存不包含如下哪个部分( )
正确答案: D 你的答案: B (错误)
Stacks
PC寄存器
Heap
Heap Frame
java好像只有栈帧 没有堆帧 pc寄存器 就是 程序计数器
程序计数器是一个以线程私有的一块较小的内存空间，用于记录所属线程所执行的字节码的行号指示器；字节码解释器工作时，通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成
2.java中 String str = "hello world"下列语句错误的是？
正确答案: A B C 你的答案: C (错误)
str+=’ a’
int strlen = str.length
str=100
str=str+100
ABC在java中会报错，D可以正常运行, 所以答案是ABC.
A. ‘a’是字符,’ a’这个是空格和a，必须要用" a"才可以;
B.String有length()方法
C.int 无法直接转成String类型
D.尾部添加字符串”100“
3.下面哪个语句是创建数组的正确语句？( )
正确答案: A B D E 你的答案: A C D (错误)
float f[][] = new float[6][6]; float []f[] = new float[6][6]; float f[][] = new float[][6]; float [][]f = new float[6][6]; float [][]f = new float[6][]; ABDE都可以。也就是说数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe71a94c8a1807c46fc5a8d5f15ba1ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f27f54a0405cca85961ae0018d9e32/" rel="bookmark">
			centos7下载setoolkit并克隆网站（fishing网站）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言测试环境下载setoolkit克隆网站总结 前言 本文章只做技术探讨，任何人企图进行非法活动与本作者无关。
测试环境 一台公网centos7（自己买的服务器）一台windows10（我的本机）一个公网登录网页python3.6 下载setoolkit 下载python3.6
yum -y install python3 下载git
yum -y install git 下载setoolkit
git clone https://github.com/trustedsec/social-engineer-toolkit 下载setoolkit依赖
cd social-engineer-toolkit/ pip3.6 install -r requirements.txt 这里出现了错误，后面再解决
运行初始化脚本
python3 setup.py 这一步是给setoolkit执行权限和设置环境变量
此时可以运行setoolkit了，虽然有的模块下载失败，但是不影响部分功能使用
[root@gg social-engineer-toolkit]# setoolkit python-pycrypto这个模块，未安装会失去加密通信的能力，所以后面要想办法安装好
这里要选Y，同意条款。
同意完之后，就可以使用setoolkit了
当我尝试克隆网站的时候，出现了一个错误：No module named ‘pexpect’
下载pexpect模块
pip3.6 install pexpect 下载pycrypto模块
pycrypto 模块需要python开发包
# 我的python版本是3.6，就下载python36-devel，你们看自己的python版本进行下载开发包 yum install python36-devel -y pip3.6 install pycrypto 下载完之后，再次打开setoolkit，pycrypto未安装的提示已经不见了
至于那个metasploit path not found，是因为我的centos7上没安装metasploit，其实如果我下载了metasploit也就没有那两个红色感叹号了。
克隆网站 上面已经安装好我们的克隆工具了，我们可以在任意目录运行它
[root@gg ~]# setoolkit 然后按照下图选项选即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0f27f54a0405cca85961ae0018d9e32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa224d1f52d280081eeee7aab8ff3cb1/" rel="bookmark">
			Java Queue 常见的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 add(E), offer(E) 在尾部添加: 实现类禁止添加 null 元素，否则会报空指针 NullPointerException；不同之处在于 add() 方法在添加失败（比如队列已满）时会报 一些运行时错误 错；而 offer() 方法即使在添加失败时也不会奔溃，只会返回 false。 remove(), poll() 删除并返回头部： 当队列为空时 remove() 方法会报 NoSuchElementException 错; 而 poll() 不会奔溃，只会返回 null。 element(), peek() 获取但不删除： 当队列为空时 element() 抛出异常；peek() 不会奔溃，只会返回 null。 欢迎关注我的公众号Godyvvva,回复Java资料免费获取Java学习资料，需要自取，过时不候。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec0402c25723a8deaa7933ea9bca93b/" rel="bookmark">
			Linux之root密码忘记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Linux 6.x以及以下版本
1.重启系统，按e进入如下模式 再次按e进入如图模式（选中kernel)
2.按e进入编辑(空格+/init 1或空格+singe或空格+1)，三种选一种就行。
3.修改完成后，按回车，退回上一界面，按b保存重启
4.完成以上操作，即可进入单用户模式，passwd 直接修改，然后重启即可
二、Linux7系列版本
1.开机选中系统，按下e键进入编辑模式
2.找到图中结尾位置添加init=/bin/sh，然后ctrl+x
3.进入单用户模式，进行如下命令操作
3.1挂载根目录
mount -o remount, rw / 3.2修改密码,记得修改密码是两次输入
passwd 3.3更新系统信息
touch /.autorelabel 3.4启动系统
exec /sbin/init 4.至此密码修改成功，使用新密码登陆即可（可能多等个几分钟）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda66459b2c59e31be2e895b0d1aaba3/" rel="bookmark">
			JS代码实现击鼓传花【队列】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 击鼓传花游戏规则： 所有人围成一圈，开始数数，数到某个数字的人自动淘汰。最后剩下的这个人获得胜利，求最后剩下的人是谁？
例如：
解释说明：将这6个学生放入队列中，每个人报一个数的同时出队，并重新进入队列尾部。数到5的学生，出队后不再重新加入队列。
依次循环，直到队列中只有一个人，即为最后的胜利者。
过程：
结果：剩下1这个人
代码实现：
function passGame(nameList, num) { //1、创建一个队列结构 var queue = []; //2、把学生加入队列 for (var i = 0; i &lt; nameList.length; i++) { queue.push(nameList[i]); } //3、开始数数 while (queue.length &gt; 1) { //不是这个数，加入队尾 for (var i = 1; i &lt; num; i++) { let n = queue.shift(); queue.push(n); } //是这个数,直接删除 queue.shift(); } //4、获取最后剩下的那个人 console.log(queue[0]); } var winner = passGame([1, 2, 3, 4, 5, 6], 5); // 结果：1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/017abbf35ff87100560ed63c060a4f6a/" rel="bookmark">
			网络知识-02 物理层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 物理层概念1.1 主要功能1.2 主要特性1.3 传输方式1.3.1 串行传输1.3.1.1 同步通信（比特流/报文同步）1.3.1.2 异步传输（字符同步） 1.3.2 并行传输 2 数据通信2.1 源系统2.2 目的系统2.3 传输系统 3 传输媒体3.1 导引型传输媒体3.1.1 同轴电缆3.1.2 双绞线3.1.3 光纤3.1.4 电力线 3.2 非导引型传输媒体3.2.1 无线电波3.2.2 微波3.2.3 红外线 4 信道4.1 信号4.1.1 模拟信号4.1.2 数字信号 4.2 信号编码（编码技术）4.2.1 基带调制（编码）4.2.1.1 常用编码方式 4.2.2 带通调制（转换为模拟信号）4.2.2.1 常用基本带通调制方法 4.3 信道通信方式4.3.1 单向通信（单工）4.3.2 双向交替通信（半双工）4.3.3 双向同时通信（全双工） 4.4 码元4.5 信道的极限容量4.5.1 信道能否通过的频率范围4.5.2 信噪比 4.6 信号复用技术4.6.1 频分复用FDM(Frequency Division Multiplexing)4.6.2 时分复用TDM(Time Division Multiplexing)4.6.3 统计时分复用 STDM(Statistic TDM)4.6.4 波分复用 WDM(Wavelength Division Multiplexing)4.6.5 码分复用 CDM(Code Division Multiplexing) 5 宽带接入技术5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/017abbf35ff87100560ed63c060a4f6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/820b3c4b511862963ef54a7e99646838/" rel="bookmark">
			python &#43; Django &#43; MySQL 系列学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python + Django + MySQL 系列学习 文章目录 python + Django + MySQL 系列学习前言一、环境搭建二、学习步骤1.留言板快速开发1.1 使用python创建Django项目1.2 创建应用1.3 配置html 逻辑1.4 Django 调用Mysql 2.读入数据 前言 本文记录 python + django 的学习记录
一、环境搭建 python版本：python3.9
Django版本：Django==2.2
Pycharm 专业版
Navicat15 for MySQL
mysql for windows
django 中文文档：https://docs.djangoproject.com/zh-hans/2.0/
环境安装可自行百度进行安装，本文主要集中在如何使用Django构建项目
二、学习步骤 1.留言板快速开发 1.1 使用python创建Django项目 基础文件介绍：
（1）Message-&gt;Message-&gt;settings 中存放所有可配置的设置
（2）Message-&gt;Message-&gt;urls 中存放一些可映射的url地址
（3）Message-&gt;static 可存放一些全局静态文件（自行创建文件夹，并在setting中添加以下命令）
# 访问全局静态文件 STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static') ] （4）Message-&gt;manage.py 入口文件
（5）Message-&gt;media 可存放一些图片等信息（自行创建文件夹）
（6）Message-&gt;extra_apps 可以存放一些外部引用的应用（自行创建文件夹）
（7）Message-&gt;apps 可以存放一些自己创建的应用
（8）Message-&gt;apps-&gt;message_form-&gt;migrations 数据库迁移/修改需要用到的目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/820b3c4b511862963ef54a7e99646838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d911d66c2f79b47764a8caf0de4826c/" rel="bookmark">
			Could not find or load main class org.apache.hadoop.mapreduce.v2.app.MRAppMaster
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新部署 Hadoop 3.x 提交 MapReduce 时会出现以下报错：
Error: Could not find or load main class org.apache.hadoop.mapreduce.v2.app.MRAppMaster Please check whether your etc/hadoop/mapred-site.xml contains the below configuration: &lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=${full path of your hadoop distribution directory}&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.map.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=${full path of your hadoop distribution directory}&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.reduce.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=${full path of your hadoop distribution directory}&lt;/value&gt; &lt;/property&gt; 而网上很多的解决方案是：在mapred-site.xml配置中加入配置信息之后，分发到各个节点，再重启，但依然会有以上问题。
&lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=${HADOOP_HOME}&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.map.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=${HADOOP_HOME}&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.reduce.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=${HADOOP_HOME}&lt;/value&gt; &lt;/property&gt; 而报错中最核心的是 Could not find or load main class org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d911d66c2f79b47764a8caf0de4826c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d8e821c6aa3c1093ca77a6a4bfe821/" rel="bookmark">
			解决【bug】网页版豆瓣很多帖子点开直接跳转网站首页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		豆瓣网页跳转关闭 有时候想在网页上浏览豆瓣，然后对于分享的豆瓣链接尝试在 网页端 打开，结果就会跳转到豆瓣主页面
如下图所示
针对豆瓣的自动跳转BUG
可以通过关闭“JavaScript”解决。
用火狐浏览器示范如下 首先打开浏览器，在搜索栏搜索“about:config”
继续在打开的页面上，在顶部的“搜索首选项名称”框中，键入以下内容：“JavaScript”。然后会看到有很多选项
3. 我们将“javascript.enabled”旁边的值将变为“false”，这代表这将其进行关闭
这样的话就将浏览器的“JavaScript”进行关闭，豆瓣页面也不会跳转到主页面了 虽然有时候其他网页需要“JavaScript”的会出现一些问题，所以随用随开，或者在其他浏览器同样进行设置，用其他浏览器查看豆瓣，不影响其他网页操作。
希望大家都能好好学习~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be7918e6ca2c1a72284f73d9fb8cc096/" rel="bookmark">
			关于Caused by: org.springframework.messaging.MessagingException: No route info of this topic: xxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 提示：这里简述项目相关背景：
今天在做项目的时候，在使用RocketMQ的时候出现了一个问题，Caused by: org.springframework.messaging.MessagingException: No route info of this topic: xxx的问题。
问题描述 这个问题描述是没有找到我RocketMQ的信息，按道理所不应该，我在启动时已经使用了start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true，不应该找不到，然后网络上找了许多的答案，都不行。
解决方案： 后来发现是我maven引入依赖版本太低了，我RocketMQ下载的版本是
4.4.0的版本
而我引入的依赖版本是
之后改成
问题完美解决
大家在使用RocketMQ的时候，记得查看版本依赖会不会引入的依赖版本太低了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14cc5fcb0fc93b020a76454f8d169ec2/" rel="bookmark">
			RPC及Dubbo和ZooKeeper的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python微信订餐小程序课程视频 https://edu.csdn.net/course/detail/36074
Python实战量化交易理财系统 https://edu.csdn.net/course/detail/35475
RPC及Dubbo和ZooKeeper的安装 RPC 通信有两种方式：HTTP（无状态协议，通信协议），RPC（远程过程调用） 它两的本质没有区别，只是功能有点不一样
官方解释： RPC是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范，它允许程序调用另一个地址空间的过程和函数，而不是程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。
RPC两个核心模块：通讯（为了传输），序列化（方便我们的数据传输，数据传输需要转换）。
Dubbo和ZooKeeper的安装 Dubbo是一个高可用的RPC框架，就是通信框架（非常牛） 安装ZooKeeper步骤：
在ZooKeeper官网下载减压压缩包打开zkServer.cmd，此时我们发现它闪退了在zkServer.cmd中加入pause，查看报了什么错打开config文件，复制zoo_sample.cfg，改名为zoo.cfg，如图： 再次打开zkServer.cmd就成功了然后打开zkCli.cmd，客户端就连接上了服务端，这里zkServer.cmd要处于打开的状态，不然这里就会报错然后在zkCli.cmd中输入ls /，就会显示我们的节点 9. 这个ZooKeeper就是节点，我们可以创建节点
10. 我们可以get节点的值
我们可以通过ZooKeeper来存值取值，到这里ZooKeeper就安装完成了。
Dubbo的安装步骤：
GitHub - apache/dubbo-admin at master，去这里下载
减压压缩包
在项目目录下打包dubbo-admin-master
cmd 进入dubbo-admin-master目录输入mvn clean package -Dmaven.test.skip=true第一次打包非常慢，请耐心等待！ 执行dubbo-admin\target下的dubbo-admin-0.0.1-SNAPSHOT.jar
执行完毕，我们去访问一下 http://localhost:7001/ ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root；
Dubbo admin安装完成！
dubbo-admin是一个监控管理后台，查看我们注册了哪些服务，哪些服务被消费了（可以不要，因为它只是监控功能）
zookeeper：注册中心（必须要）
Dubbo：jar包（必须要）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dae970f98207dd6e66536680285ee03/" rel="bookmark">
			【问题记录】在使用migrate迁移生成数据表时并没有在数据库中生成数据表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： django子应用创建数据模型迁移
问题描述 在dhango中使用python manage.py migrate迁移没有生成数据表：
原因分析： 查看数据库，django_migrations数据表，发现在每一次执行迁移生成的migrations文件名称都已经存放在数据库中，在进行迁移文件建表时，会根据数据库中记录的迁移文件执行建表操作，由于已经删除了数据文件，导致出现了“ No migrations to apply.”提示
解决方案： 删除子应用中的迁移文件
一般是子应用下migrations下边的001开头的py文件 打开数据表django_migrations删除对应的迁移文件记录
(我是user中一个数据表没有生成成功，而且关联几个外键)
delete from django_migrations where app = 'users' 然后设置外键约束检查关闭，删除数据表相关联的所有数据表
SET foreign_key_checks = 0; // 先设置外键约束检查关闭 drop table table1; // 删除表，如果要删除视图，也是如此 SET foreign_key_checks = 1; // 开启外键约束检查，以保持表结构完整性 然后重新使用 python manage.py makemigrations/migrate 进行数据迁移即可。
如果数据库中没有太多数据可以直接删除数据库重新创建一个新的数据库导入数据即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dfcb214c2a43e50b42dcc685f7516b3/" rel="bookmark">
			Java面向对象编程——类与对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
类的定义 类的声明：
类的声明：
类的属性：
类的行为：
对象的创建
使用关键字new创建对象：
通过对象访问属性和行为：
属性的默认值：
构造方法
无参数的构造方法
带参数的构造方法
面向对象编程是将现实生活中的概念通过程序进行模拟，其中有两个最重要的概念：对象，类。
所有现实世界存在的具体事物都是对象，如一个人，一台计算机，一个房间等。
对象具有属性和行为，例如，人的属性包括年龄，体重等，行为包括吃饭，走路，说话等
对象是指某个具体事物，而同一类事物有其共性，前面说到的属性和行为就是其共性。例如所有人的身高，体重等基本特征，也都具有吃，喝，玩，乐等这些共性。更为好地描述一类事物，我们对这些共性进行了归纳，就形成了类，这个过程我们称为"抽象"。
类的概念：
类是对具有相同特征或属性，具有相同行为能力的一类事物的描述或称呼
对象的概念：
对象是这一类事物带有属性值,具有具体行为的个体或实例
用一句话概括类与对象的关系
类是对象的抽象 对象是类的具体
我们对类和对象已经有了一些模糊的概念，但这和编程有什么关系呢？与以前的编程方式有什么不同呢？以前的编程方式是面向过程，每个具体功能都需要我们去进行具体的实现，而面向对象的思路则不同，我们需要完成某个功能，只需要向对象发送一个“命令”而具体怎么完成功能，是由该对象所属的类去定义的。
类的定义 面向对象编程的基本元素是类，类确定了对象的形式和行为，类是一个模板，用于创建同一类型的对象，那代码中是如何表示类呢？也就是类是如何声明的
类的声明： 在Java中定义一个类使用关键字class,一个合法的标识符和一对表示程序体的大括号，实例如下：
class &lt;classname&gt;{ //class关键字 classname表示类的名称，类名是一个名词，采用大小写混合的方式 //括号里包含属性和方法的声明 } 类的声明： 下面以人类为例，看看如何写一个"人"的class,代码如下
public class Person{ //声明了一个Person类 } 这就是一个完整的类的声明，当然Person类并没有定义属性和方法，它是"面目全非"的，既没有身高，性别，年龄等属性，也没有吃，喝，玩，乐等行为，当然目前也不能做任何是。确切的说，其实"类"不具备做事的功能，事情有类来定义，但是事情是由对象来做的就好像我们听到的"张三去跳舞了",但是没有人说"人类去跳舞了",这就是类和对象的区别。类是虚拟的，对象才是实实在在的，但对象是由类这个模板产生的。
那么如何给类添加对应的属性和行为。
类的属性： 下面来看看如何用变量来表示这些"属性"，我们对"人类"进行完善，添加一些属性
Publicclass Person{ String name; //姓名 int age; //年龄 String sex //行为 String address; //地址 } 这样我们就已经学会了如何在class中声明属性
类的行为： 学完了属性，我们知道了如何反映物体的特性，现在想让对象来帮我们做一下具体的事情，以人类为例，想想人都能做些什么是事情呢？人都会吃饭，睡觉，行走.....显然这些是人都会做的，现在来学习如何声明这些"行为"，"行为"是完成某个具体的动作，我们用方法表示行为，如一下代码
Publicclass Person{ String name; //姓名 int age; //年龄 String sex //行为 String address; //地址 void eat(){ //方法：吃饭 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dfcb214c2a43e50b42dcc685f7516b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7176c685b64950ea7afa5a6fc6af80a8/" rel="bookmark">
			ACwing 797. 差分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入一个长度为 n 的整数序列。
接下来输入 m 个操作，每个操作包含三个整数 l,r,c表示将序列中 [l,r] 之间的每个数加上 c。
请你输出进行完所有操作后的序列。
输入格式
第一行包含两个整数 n 和 m。
第二行包含 n 个整数，表示整数序列。
接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。
输出格式
共一行，包含 n 个整数，表示最终序列。
数据范围
1≤n,m≤100000,
1≤l≤r≤n,
−1000≤c≤1000
−1000≤整数序列中元素的值≤1000
输入样例：
6 3 1 2 2 1 2 1 1 3 1 3 5 1 1 6 1 输出样例：
3 4 5 3 4 2 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; const int maxn = 1e5+10; int a[maxn]; int c[maxn]; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i&lt;=n;i++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7176c685b64950ea7afa5a6fc6af80a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/380127b4eabcc96038409109e7ecc83a/" rel="bookmark">
			Redis系列（2）—主从读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 主从架构 主从读写分离架构 Redis高可用性一般来说有两方面，一个是数据尽量少丢失，这个可以通过 AOF 和 RDB 来保证。另一个则是服务尽量少中断，不会出现单点故障，这个Redis的做法就是增加副本冗余，Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。
缓存一般都是用来支撑读高并发的，Redis 单机并发最多可能也就几万QPS，如果想要支持更高的并发，也需要通过主从读写分离的模式来部署 Redis，这样从节点就可以支持横向扩展，来提高读的吞吐量。接下来就来实践Redis主从架构高可用。
主从读写分离：主库、从库都可以接收读操作，而写操作先到主库执行，然后主库将写操作同步给从库。
部署主从读写分离 假设我们要部署的主从架构包含一个 master 节点和两个 slave 节点，信息如下：
节点
IP
Master
172.17.0.2:6379
Slave
172.17.0.3:6379
Slave
172.17.0.4:6379
按照前一篇文章的部署步骤，在另两台虚拟机（172.17.0.3/172.17.0.4）中各搭建一个 Redis。
注意有两个地方的IP需要更改：
/etc/redis/6379.conf 配置文件中的 bind &lt;本机IP&gt;/etc/init.d/redis_6379 脚本中 shutdown 制定的IP改为本机IP 接下来只需要在从节点的配置文件中修改一项配置即可：
# vim /etc/redis/6379.conf 将注释掉的 replicaof 打开，并配置master节点的IP和端口：
replicaof 172.17.0.2 6379 然后重启 redis 即可：
# cd /etc/init.d # ./redis_6379 stop # ./redis_6379 start 之后就可以做些测试，可以看到数据已经从主节点复制过来了，并且只能读取不能写入。
[root@centos-02 /]# redis-cli -h 172.17.0.3 172.17.0.3:6379&gt; get name "bojiangzhou" 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/380127b4eabcc96038409109e7ecc83a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7461e58eb8118bfa047a5dc22f8e08ca/" rel="bookmark">
			C&#43;&#43;基础之std::map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cartographer中要用到这里，之前都是直接用，了解不深，现在补,这里是纯搬的，手写一遍加深印象，源地址如下：
参考 std::map 容器使用详细说明_学之之博未若知之之要知之之要未若行之之实的博客-CSDN博客_std::map使用
概述：
Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。
1、map简介 map是一类关联式容器。它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。
对于迭代器来说，可以修改实值，而不能修改key。
2、map的功能 自动建立Key － value的对应。key 和 value可以是任意你需要的类型。
根据key值快速查找记录，查找的复杂度基本是Log(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。
快速插入Key -Value 记录。
快速删除记录
根据Key 修改value记录。
遍历所有记录。
3、使用map 使用map得包含map类所在的头文件
#include &lt;map&gt; //注意，STL头文件没有扩展名.h
map对象是模板类，需要关键字和存储对象两个模板参数：
std:map&lt;int,string&gt; personnel;
这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.
为了使用方便，可以对模板类进行一下类型定义，
typedef map&lt;int,CString&gt; UDT_MAP_INT_CSTRING;
UDT_MAP_INT_CSTRING enumMap;
4、 map的构造函数 map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：
map&lt;int, string&gt; mapStudent;
5、 数据的插入 在构造map容器后，我们就可以往里面插入数据了。这里讲三种插入数据的方法：
第一种：用insert函数插入pair数据，下面举例说明(以下代码虽然是随手写的，应该可以在VC和GCC下编译通过，大家可以运行下看什么效果，在VC下请加入这条语句，屏蔽4786警告 ＃pragma warning (disable:4786) )
//数据的插入--第一种：用insert函数插入pair数据 #include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() { map&lt;int, string&gt; mapStudent; mapStudent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7461e58eb8118bfa047a5dc22f8e08ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f98774194d1f5336171fece4ab865226/" rel="bookmark">
			【报错记录】ImportError: cannot import name ‘six‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错展示
File "/root/.virtualenvs/python3.6/lib/python3.6/site-packages/haystack/utils/loading.py", line 13, in &lt;module&gt;
from django.utils import six
ImportError: cannot import name 'six'
解决方案：
在使用搜索引擎创建索引的时候出错了，在网上找了大量的资料说把
from django.utils import six 改成：import six
但是我在环境里边根本找不见haystack文件夹，检查后发现django-haystack我是安装了的。最后把这个包卸载重新安装后就奇怪的出现一个新的报错
no module res_code
然后我找到该路径发现是我自己写的一些参数的包然后我把这个导入注释后重新创建索引就成功了。成功后我把注释也改回来就好了
（后来了解到报错原因为docker没有启动，启动后如果还报错可以尝试把django-haystack重新安装一下）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b97561d5513b9d334452f8ed2105667/" rel="bookmark">
			C&#43;&#43;后续：QT学习（Qt概述，创建QT项目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
声明
一. Qt概述
1.1 什么是Qt
1.2 Qt的发展史
1.3 Qt支持的平台
1.4 Qt版本
1.5 Qt的下载与安装
1.6 Qt的优点
二.创建 Qt项目 2.1 如何创建
2.2 代码解释
声明 QT不是必学的，有人说前端都是web了，Qt过时了， 其实学Qt不是单单为了学而学，而在这个过程可以巩固C++，学习面向对象编程及项目类的一些知识
一. Qt概述 1.1 什么是Qt Qt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许套正的组件编程。
1.2 Qt的发展史 1991羊Qt最早由奇趣科技开发·
1996年进入商业领域，它也是目前流行的Linux桌面环境KDE的基础
2008年奇趣科拔被诺蒸亚公司收购，Qt称为诺基亚族下的编程语言
2012 年Qt 又被Digia公司收购·
2014年4月跨平台的集成开发环境Qt Creator3.1.0发布，同年5月20日配发了Qt5.3正式版，至此Qt实现了对i0S、Android、W等各平台的全面支持。
1.3 Qt支持的平台 1.4 Qt版本 商业版
开源的LGPL版本
1.5 Qt的下载与安装 百度qt即可，不会可以看这位大佬的博客QT5.11下载与安装教程_灬杨三岁灬的博客-CSDN博客_qt安装教程
安装方面，建议组件全部选中
1.6 Qt的优点 1. 跨平台，几乎支持所有的平台
2.接口简毕，容易上手，学习QT框架对学习其他框架有参考意义。
3.一定程度上简化了内存回收机制﹐
4.开发效率高，能够快逸的构建应用程序。
5.有很好的社区氛图，市场份额在缓慢上升。
6.可以进行嵌入式开发。
二.创建 Qt项目 2.1 如何创建 打开QT
点击new
取名选路径，建议不要选英文路径
下一步后
后面一直下一步即可
2.2 代码解释 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b97561d5513b9d334452f8ed2105667/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71efe754eb32d10c67ef2602f86ddcd8/" rel="bookmark">
			Unity开发笔记（五）—— 制作第四个小游戏《坦克大战》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
使用VS传统方法制作
使用Unity制作
使用VS传统方法制作 写在前面的话
C#可以干什么？
桌面应用开发（用的少，现在市面上的桌面应用大部分是C++开发的）Unity游戏开发Web开发（用的少，现在市面上的网站是Java/PHP开发的） 开发工具：Unity、VS
注意：杀毒软件可能会把开发完成阶段生成的exe文件误当成病毒删除，所以使用时注意关闭
一、准备
进入项目后可以看到Form1.cs的设计模型框 鼠标右键选择查看代码，可查看Form1.cs的具体代码 选择视图-&gt;工具箱，在工具箱中有一些系统自带组件鼠标拖动到Form1.cs进行UI布局的设计
控制窗体显示的位置 居中显示
自定义位置显示 查看窗体事件有哪些
我们找到Paint（这个事件是用于更新画布的），然后在其后面的空格处双击，然后我们就会得到一个Form1_Paint方法
下面我们在此方法中编写代码去画一条线段
注意这里的坐标原点是表头以下部分的左上角 查看本机有哪些字体？新建一个txt文件打开，然后找到字体即可查看
绘制文字 绘制图片，双击打开Resources文件，选择图像，选择添加现有文件，选择导入即可
我们可以在Resources类下发现有自动生成的代码
同理，添加音频
编写代码 绘制图片成功
控制代码收缩，使用region和endregion 也可用Bitmap来获取图片对象且使用它可以对颜色进行透明处理
二、正式开始
1.创建画布窗口
创建窗体应用项目，设置窗口居中显示，设置标题（长宽均为15*30像素，为了对此取奇数）和游戏标题
新建一个线程 新建一个类（项目右键添加-&gt;类）
创建Start和Update方法，Start方法用于游戏启动时的初始化，Update用于游戏每帧画面的更新逻辑操作 为了优化性能，限制1s执行60次update方法
我们在调试时可以发现，当关闭窗口后主线程没有关闭，这是因为子线程没有关闭的情况下子线程是不会关闭的，我们添加一个FormClosed事件（方法见一）
修改Thread作用域，然后在FormClosed方法中调用中断线程的方法
创建画布并赋值 将画布置为黑色 (为什么要把置为黑色代码放到每一帧里面重复执行？我直接执行一次不就好了吗？答案是：因为我们在游戏中还有动态的坦克，如果只执行一次则在创建坦克时会有重复)
2.绘制地图
创建GameObject类
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace TankWar { class GameObject { public int X { get; set; } public int Y { get; set; } //上述等价于 //public int y; //public int Y { // get { // return y; // } // set { // value = y; // } //} } } 创建NotMovingThing类，继承GameObject，新建Image对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71efe754eb32d10c67ef2602f86ddcd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ca471a288d706d9ac2a0816825d076/" rel="bookmark">
			unity学习笔记（二）—— 制作第一个小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接下来我们使用unity制作第一个小游戏，我估计这也是所有unity开发者都非常熟悉的一个类似“Hello World”标致的游戏了——滚动小球
一、创建项目（名字自取），创建场景，取名为MainScene
二、创建一个地面对象（鼠标右键-&gt;3D Object-&gt;Plane），并将其position设置为0，0，0，然后把其长宽扩大1倍（即Scale设置为2，1，2）
然后我们想要改变地面对象的颜色需要这样做：首先在Assets目录下新建一个materials文件夹，然后右键如图创建一个material并命名为Ground
然后鼠标拖动此材质到对应的游戏对象上
下面介绍下Plane游戏对象的组件构成，Transform组件用于指定对象的位置、旋转、缩放；Mesh Filter组件用于指定该对象是一个什么类型对象；Mesh Renderer用于设置对象形态属性；Mesh Collider用于设置碰撞检测（一般会做两套建模，一套用来显示对象具体形象，另一套会简化用于碰撞检测的模型,例如RPG游戏，人物会用胶囊体作为碰撞检测模型，但FPS类游戏就不行）。我们在点击Gound进入到设置界面，然后单击这个位置就会弹出选色板，最后选择自己喜欢的颜色就可以了
material实现逻辑：
细心的人会发现在Plane对象中也会把Ground材质展示出来，这其实是为了方便我们快速对应材质并修改（当材质和对象很多时这样是很方便的）
三、创建小球，并命名为Player，position指定为0，3，0，同时我们给之前的Plane也起个名字命名为Ground，同时按照相同的方法创建另一个material命名为Player给小球着色
设置小球光滑程度smoothness（不让它反光太厉害）
同样的方法地面也可以设置smoothness
最终效果如图： unity引擎内置了碰撞计算和检测，我们只需要指定碰撞后需要做什么（如主角扣血或死亡）
四、为小球添加钢体组件（即重力、摩擦力、弹力）
点击小球对象-&gt;Add Component-&gt;Physics-&gt;Rigidbody
然后运行游戏即可看到小球落在了地板上
五、给小球添加滚动事件
两种方法创建：
法一：点击小球-&gt;Add component-&gt;New script-&gt;填入文件名-&gt;点击创建，即可在Assets下创建对应script，且已经与小球对象关联
法二：在Assets下新建scripts文件夹，右键-&gt;create-&gt;C# script-&gt;命名，然后将此script拖到小球对象上即可邦定
注意：组件前有一个对勾选项，代表组件是否要使用，请保证使用时是选中状态
双击创建的script文件即可用vs打开（确保此文件名与类名一致），代码中start方法用于游戏开始前的初始化工作，update方法用于游戏运行中的更新操作(每帧调用一次，每秒60帧)
添加测试代码： 将钢体组件与脚本关联，以便后续进行业务逻辑的操作
方法一：使用代码
rd = GetComponent&lt;Rigidbody&gt;(); 方法二、拖动钢体组件到简本，即拖动到如图位置（但这种方法使用较少）
然后我们再给钢体添加一个向右的力（不指定大小默认是1N），注意要再update中添加此代码，这样小球才会一直运动
如果定义钢体时设为private则不会显示对应设置，同时也无法通过拖拽绑定钢体
public
private
为小球设置一个自定义大小的力
rd.AddForce(new Vector3(10, 0, 0)); 六、通过键盘控制小球的滚动
获取键盘左右方向输入(按下A或方向左键，返回0~-1然后一直为-1；按下D或方向右键，返回0~1然后一直为1；为什么要有一个从0到1的过程？因为物理中物体运动时有一个加速度的效果)
float h = Input.GetAxis("Horizontal"); Debug.Log(h); 然后我们将键盘输入值赋值到力中
float h = Input.GetAxis("Horizontal"); rd.AddForce(new Vector3(h, 0, 0)); 同理获取键盘前后方向输入(按下W或方向上键，返回返回0~-1，按下S或方向下键，返回0~1)
float h = Input.GetAxis("Horizontal"); float v = Input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85ca471a288d706d9ac2a0816825d076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f45880eaedf1b5975df46b0ca2de9cb/" rel="bookmark">
			华清远见学习感想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过这两个月在华清远见的培训，我感触良深，归纳起来，有以下几点心得
首先，就自身而言，这次的学习提高了自身累计的代码量与专业的水平技术。我想通过这次的学习，不仅仅是学到了更加专业的前段知识，开阔了眼界，更重要地学习到了写代码时的逻辑思维。这将终身受益，只有不断地学习与总结才能不断地进步。
这两个月的培训，让自己懂得了如何在写代码中处理问题的方法和逻辑。尽量在以后工作中少走弯路一次性把项目完成好，
在整个华清远见的培训中，作为新同学的我感受到了良好同学合作精神和不断学习的氛围。还有老师的耐心讲解，大家相互帮助，相互学习，共同进步
最后这次在华清远见培训中让我对前段技术有了更深的了解，增进了不少知识，更重要的是让我对自己有了新的认识与新的奋斗目标，“水不流则腐，人不进则退”，在今后的培训中和工作中我将加倍地努力提高自己的技术，累计代码量，希望自己还有同学们以后能争取到更好的offer.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058b0557c0f85b7cf6b303413506b3b0/" rel="bookmark">
			读取、处理Yelp数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##读取、处理Yelp数据集
import pandas as pd import json reviews_path =r"../yelp_dataset/yelp_academic_dataset_review.json" ''' 读取原始数据 ''' file = open(reviews_path, 'r', encoding="utf-8") users_id = [] items_id = [] ratings = [] reviews = [] dates = [] for line in file: js = json.loads(line) print(js) if str(js['user_id']) == 'unknown': print("unknown user id") continue if str(js['business_id']) == 'unknown': print("unkown item id") continue date = str(js["date"]) _date = date.split('-')[0] if _date == '2017': reviews.append(js['text']) users_id.append(str(js['user_id'])) items_id.append(str(js['business_id'])) ratings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/058b0557c0f85b7cf6b303413506b3b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a74171127e5077db94c723719e58dbc/" rel="bookmark">
			easypoi/easyExcel导出excel（xls，xlsx）后，文件打开错误或乱码的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主问题 时间： 2022.04.08
问题描述： 在实现页面表格下载为excel文件的需求时，页面下载成功后的excel文件无法打开，图示如下。
然后F12打开控制台，发现后端返回的数据为字符串乱码。
原因分析： postman等接口调用工具去请求这种需要下载文件的接口，会有问题的。不要使用ajax，axios等异步请求去请求下载接口。
解决方法： 将“button”按钮替换为“a”，使用“href”对接口进行访问。因为本问题所需要请求的接口需要传参，可以将参数通过如下方式进行绑定。“$(‘#标签ID’).prop(‘href’,‘url地址?参数名=’ + 参数)”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cafd4d842ead0b806f42dbc1103e6ac6/" rel="bookmark">
			转录组-DESeq2筛选差异基因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要数据：表达矩阵(count数据，count值为整数，矩阵是没有标准化的)；
分组信息；
差异比较矩阵(制定差异比较对象)
getwd() mycounts&lt;-read.csv("gene_exp.csv",row.names = 1)#这个表不对，有小数，应用Count数据 head(mycounts) dim(mycounts)#几行几列 mycounts_1&lt;-mycounts[rowSums(mycounts)!=0,]#去掉行的和为0 dim(mycounts_1) mymeta&lt;-read.csv("fenzu.csv",stringsAsFactors = T)#字符串转化为因子 Mymeta colnames(mycounts_1)==mymeta$id#查看顺序是否一一对应 #source("https://bioconductor.org/biocLite.R") #载入安装工具 #BiocManager::install("DESeq2")#安装包 library(DESeq2) mycounts_1&lt;-round(mycounts_1,digits=0) #将输入数据取整，若为count数据不需要这一步 mycounts_1 dds&lt;-DESeqDataSetFromMatrix(countData = mycounts_1,#基因表达量表 colData = mymeta,#分组信息表 design = ~dex)#分组信息里的列名 dds&lt;-DESeq(dds) res&lt;-results(dds) head(res) class(res) res_1&lt;-data.frame(res) class(res_1) head(res_1) library(dplyr) res_1%&gt;% mutate(group=case_when( log2FoldChange&gt;=1&amp;pvalue&lt;=0.05~"UP", log2FoldChange&lt;=-1&amp;pvalue&lt;=0.05~"DOWN", TRUE~"NS" ))-&gt;res_2 table(res_2$group)#查看上下调个数 write.csv(res_2,file="res_2.csv") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/779df7a00a1b14acbe121a773ef13052/" rel="bookmark">
			(Jetpack TX2)ubuntu上aarch64安装anaconda3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在终端中输入sudo uname -a可以查看ubuntu的信息
2、系统是aarch64，它既不是64-Bit(x86)也不是64-Bit(Power8 and Power9)，所以使用anaconda官网(https://www.anaconda.com/products/individual)的安装包是行不通的。
因此使用大神编好的aarch64版本的anaconda（Anaconda3-linux-aarch64），见下图
将其下载下来，在目录下输入
bash Archiconda3-0.2.3-Linux-aarch64.sh 接着按提示进行即可。输入
source ~/.bashrc 验证是否安装成功
最终安装好之后，另起一个终端，输入python，弹出如下信息，
说明安装成功！
参考：https://zhuanlan.zhihu.com/p/64868319
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75108065cf28cee7ba0f8dea9f6827b2/" rel="bookmark">
			面试题：SpringBoot 的自动装配是怎样实现的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SpringBoot 的自动装配实现： 自动装配的入口是复合注解 @SpringBootApplication ，它主要是由以下三个注解组成：
@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan 装配步骤如下：
@SpringBootConfiguration 里面是封装了一个@Configuration，作用就是将配置这个注解的类加载到 IOC 容器里面，主要是替换到 xml 配置文件@ComponentScan 他的作用就是扫描指定的路径下需要装配的类, 自动装配到 spring 的 IOC 容器里面，标识需要装配的类的形式主要是 @Component、@Repository、 @Service、 @Controller 这一类注解的标识，@ComponentScan 默认会扫描当前类名所在包名下面所有的加了相关标识注解载入 IOC 容器里面@EnableAutoConfiguration 里面包含 @Import(AutoConfigurationImportSelector.class) @Impor 引入实现了 ImportSelector 接口的AutoConfigurationImportSelector类进行动态注入AutoConfigurationImportSelector 类里面的 selectImport主要是扫描MATE-INF下面的spring-autoconfiguration-matedata.properties和spring.factories文件最后进行合并， 判断那些组件需要注入，进行动态条件生成， 判断那些组件不需要注入容器 二、从 SpringBootApplication 注解开始分析自动装配 打开 SpringBootApplication 这个注解，可以看到它实际上 是一个复合注解
@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75108065cf28cee7ba0f8dea9f6827b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e6a4deefcfc8cdb069ec80b412eddd/" rel="bookmark">
			Wire.read()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Wire.read() 描述 这个函数在调用requestFrom()之后读取从外围设备传输到控制器设备的字节，或者从控制器设备传输到外围设备的字节。read()继承自Stream实用程序类。
语法 Wire.read()
参数 None.
Returns 收到的下一个字节
Example #include &lt;Wire.h&gt; void setup() { Wire.begin(); // Join I2C bus (address is optional for controller device) Serial.begin(9600); // Start serial for output } void loop() { Wire.requestFrom(2, 6); // Request 6 bytes from slave device number two // Slave may send less than requested while(Wire.available()) { char c = Wire.read(); // Receive a byte as character Serial.print(c); // Print the character } delay(500); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163af492ab3434653a6cb8073c1f94f5/" rel="bookmark">
			vs code使用GitLens — Git supercharged无法使用的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode使用git，需要下载GitLens — Git supercharged配合使用
当下载的GitLens — Git supercharged版本过新时，会提示你重新安装新版的git，不安装新版的git就一直使用不了还报错，左边也没版本控制。
解决办法，把本地的git地址配置进来，让他使用本地的git，配置如下
“git.path”: “C:/软件/gitblit/Git/bin/git.exe”, //本地的git地址
vs code重启后就可以使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924f958c958489d33b7b85bcb8672168/" rel="bookmark">
			win10安装VMware死机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你是拉跨的家庭版win10，
那么你肯定没有装hyper-v，你搜一下：家庭版怎么装hyper-v 就行了，
Win10家庭版系统Vmware启动时电脑蓝屏解决办法_亲测有效_海纳百串的博客-CSDN博客_win10系统vmware启动就蓝屏
然后看一下bios有没有开启intel vitrul technology
这两个搞好就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce71a74ed128209f88899e65dc99c32c/" rel="bookmark">
			com.fasterxml.jackson.databind.exc.InvalidFormatException解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户端使用fastjson进行序列化，服务端使用jackson反序列化失败。报错。
Caused by: com.fasterxml.jackson.databind.exc.InvalidFormatException: Cannot deserialize value of type `java.util.Date` from String "2022-04-04 04:04:04": not a valid representation (error: Failed to parse Date value '2022-04-04 04:04:04': Cannot parse date "2022-04-04 04:04:04": while it seems to fit format 'yyyy-MM-dd'T'HH:mm:ss.SSSZ', parsing fails (leniency? null))
原因：
fastjson默认使用的序列化格式：
public static String DEFFAULT_DATE_FORMAT = "yyyy-MM-dd HH:mm:ss"; jackson默认支持的日期反序列格式：​​​​​​​
("yyyy-MM-dd'T'HH:mm:ss.SSSZ", "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", "EEE, dd MMM yyyy HH:mm:ss zzz", "yyyy-MM-dd")) jackson默认的日期反序列不支持yyyy-MM-dd HH:mm:ss 这种格式，所以反序列化失败
解决办法一：重写jackson反序列化
import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.JsonProcessingException; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce71a74ed128209f88899e65dc99c32c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3caff74f37f61eb2540617e1f3f73c89/" rel="bookmark">
			【Java】线程基本使用——实现 Runnable接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 实现 Runnable 接口2. 线程使用应用案例--多线程执行3. 如何理解线程 1. 实现 Runnable 接口 说明 java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时在用继承Thread类方法来创建线程显然不可能了。java设计者们提供了另外一个方式创建线程，就是通过实现Runnable接口来创建线程 应用案例
请编写程序，该程序可以每隔1秒。在控制台输出“你好，兮动人”，当输出10次后，自动退出。
使用实现Runnable接口的方式实现。 public class Thread02 { public static void main(String[] args) { Dog dog = new Dog(); //dog.start(); //这里不能调用 start 方法 //创建了 Thread 对象，把 dog 对象(实现了 Runnable )，放入了 Thread Thread thread = new Thread(dog); thread.start(); } } class Dog implements Runnable { //通过实现Runnable接口来实现 int count = 0; @Override public void run() { //普通方法 while (true) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3caff74f37f61eb2540617e1f3f73c89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f063480edb36255ef5ee8f3af9c9f64/" rel="bookmark">
			补码(为什么按位取反再加一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、
首先，阅读这篇文章的你，肯定是一个在网上已经纠结了很久的读者，因为你查阅了所有你能查到的资料，然后他们都会很耐心的告诉你，补码：就是按位取反，然后加一。准确无误，毫无破绽。但是，你搜遍了所有俯拾即是而且准确无误的答案，却仍然选择来看这篇毫不起眼的文章，原因只有一个，只因为你还没有得到你想要的东西。
因为你想要的，不是1+1=2，而是，1+1为什么等于2。当然，我们不讨论1+1的问题。我们讨论的，是补码。
你已经困惑了很久，你明明知道补码就是按位取反，然后加一，但是你想知道的，不是它怎么求滴，而是，它怎来滴。当然，对于阅读这篇文章的你，既然想要知道这个答案，一定是有一定编程基础的读者，肯定知道补码与有符号数与无符号数的关系（有符号数指带有正负号的数，无符号可以理解为只大于0的数），你所查阅的所有资料首先都会用一个8位的二进制数给你举例，ok，我们也用一个8位的二进制数。
8位二进制数，最小00000000，最大数11111111，换算十进制为0~255，当然，所有的参考资料都会这样讲，而且这也不是你想要的，但我们必须说下去。1~255，一共255的字符，再加上最前面的0，一共256个字符。现在，我们要用一个8位二进制数字来表示一个负数，可是二进制里没有负号，谁都知道二进制里只有0,1，再无其他符号。那么所以我们必须用一种方式来代替正负，也就是我们规定，当然是人规定的，而不是电脑，我们规定这个8位的二进制数的最前面一位数来表示这个数的正负，0代表是正，1代表是负。那么当第一位是0时，我们一共可以表示00000000~01111111这么多正数，因为第一位必须是0来代表正数；当第一位是1时，我们一共可以表示10000000~11111111这么多负数，然后，我们用00000000~01111111来代表0~127，那岂不是10000000~11111111代表 -0 ~ -127？？可是网上都说不能有 负0，可是我觉的没什么不妥啊，负0不还是0 吗？10-0=10，不就是相当于10+（-0）=10吗，现在我们不讨论正负0的问题，我们来讨论一个小学生的问题。
我们现在要把00000000~11111111分成两组数，一组是正数，另一组是负数，正数是0,1,2,3,4,5,6,7,8，… 负数是 -1，-2，-3，-4，-5，-6，-7，-8，… 那么这里就有一个小学问题，那就是1+（-1）肯定要等于0，2+（-2）=0，他们是相反数，相加等于0，小学生都会。后面都是一样，那么现在我们使用上面的编码的方式进行一个计算，现在上面的编码中 1 对应的二进制是00000001，-1对应的二进制是10000001，然后你把这俩二进制数加起来，看看等于几，对，答案是10000010，不是00000000，也不是10000000, 10000010在上面的编码中代表 -2，00000000和10000000都在上面代表0，可是结果并不是他们。而00000001与10000001分别对应着1和-1，加起来理论的结果应该是0才对，也就是说上面的编码是错误的。
或许接下来很多资料又讨论了反码，但是我们不，我们来求一个一元一次函数，一个小学的函数，1+x=0,求x=？,答：-1。没错，而且准确无误。那么现在问题来了，前面的正数编码应该是没有错的，00000000代表0, 00000001代表1，这些都符合我们的习惯，那么出错的是在后面的负数编码上，我们到底该如何编码对应负数编码它才能正确呢，因为我们知道1+（-1）必须等于0，也就是他们对应的二进制相加也必须等于0，1对应00000001，那么00000001+x=00000000，里面的x就应该代替 -1的二进制编码才对，这样，我们得到 x=11111111，大家看一下这和按位取反，然后加一的结果一样吗。
所以我们的结论是，一个正数对应的负数（也就是俩相反数），这两个数的二进制编码加起来必须等于0才对，所以我们只要知道其中一个数的编码x，然后用0-x就是他对应的数的编码，这样的话，从0~127，我们用（0 - 其中一个二进制数的编码）=（另一个二进制数的编码），例如 2 的二进制编码是00000010，那么-2 的二进制编码就是0 - 00000010=11111110，因为他就应该这样，因为它就是一个小学问题，他俩加起来就应该等于0。那么1000000对应的编码是多少呢，当然也必须满足加起来等于0才行，那么10000000+x=0，求解x，答x=10000000，还是它本身，也就是在00000000~11111111这个范围里所有的二进制数都无法满足它，也就是没有一个数加上它等于0，但是两个数要有对应的编码，就必须加起来等于0才行，其实不止它没有，0也没有，0+x=0，那么x=0，也是它本身，既然这样了，那么也没有办法了，无可奈何只能做单身汉了，然后我们规定，既然10000000第一位是1，代表负数，那么我们规定它是一个负数，那么10000000就代替了-128，而且，它只自己一个人，也就是只有-128，没有正数128。
然后，他们每个数都有了自己对应的编码，而且准确无误。1~127对应-1~ -127，再加上两个单身汉0和-128。然后呢，不知道谁起的名字，就把这种编码叫做了补码，如果你乐意，你也可以给它起个名字。但是呢，还有一个问题，为什么补码的求法是按位取反再加一呢，其实当你不明白为什么各大书籍都要用按位取反来计算补码的时候，我们完全可以直接用0减去它就得到他相反数的二进制编码了，譬如随便一个十六进制数 6C ，那么我们可以直接0-6C就得到他的相反数的补码了，结果为十六进制的94，跟按位取反再加一的效果一样。
现在我们知道补码是怎么来的了，也就是为了保证两个相反数对应二进制的和必须是0，然后又不知道谁给它起了补码这个名字。补码补码，有没有感觉两个相反数是互补的呢，也就是任意两个相反数加起来一定等0，其中一个数变大，另一个就一定会变小互补保证结果为0。但是你肯定还在纠结，为啥要按位取反，为啥还要加一呢。其实，这涉及到一个二进制减法的问题，你既然知道补码这个概念，就一定会知道有进位丢失这么个东西。现在我们知道了补码是怎么来的，也就是（00000000 - 其中一个正数的补码）=（这个数相反数的补码），那么我们知道了1的二进制是00000001，那么我们来求-1的补码，也就是应该00000000 - 00000001=？，我们该怎么计算这个二进制减法呢，而且还是一个小数减去大数，连借位都没地方借，前面我们提到进位丢失这个东西，那么我们来计算一个算式，11111111+00000001=？知道进位丢失的你，肯定知道加起来后等于00000000，虽然结果应该是100000000（后面是8个0），但是只能有8位，所以最高位的1丢失了，那么现在好了，也就是说，我们可以把00000000看做（11111111+00000001）因为他俩是相等的，我们已经计算过的了，那么我们现在就可以把前面讲的公式中的00000000换成（11111111+00000001），也就是我们要计算-1的补码，我们就0-1的编码，也就是00000000-00000001，也就是（11111111+00000001）-00000001=(-1的补码)，这个算式我觉的你应该会计算了，大数减小数，到现在，或许你现在已经发现什么了，是的，你发现了之前一直迷惑你的一个东西，“按位取反再加一”，但是可能还有一点迷惑，我们继续，因为我们每次都是用一个0减去一个数的补码来得到另一个数的补码，也就是里面的（11111111+00000001）是不变的，因为它就是0，那么我们现在要求一个数的补码，就是（11111111+00000001）- 一个数的补码=它相反数的补码，咱们把括号去掉，也就是11111111 - 一个数的补码+00000001=它相反数的补码，这是加法交换法则，只是把位置交换一下，小学生都会的，然后呢再加个括号方便我们理解，也就是（1111111 - 一个数的补码）+00000001=它相反数的补码。好了，问题来了，（11111111 - 一个数的补码）的结果是什么，这个你心里应该是清楚的，你也可以算一下，它正好的等于它的反码，也就是按位取反的一个数，其实也好理解，你减几个数就看见规律了，描述好麻烦，现在好了，也就是（11111111 - 一个数的补码）=这个数的反码，也就是（11111111 - 一个数的补码）=把这个数按位取反，到现在，你应该你已经很清楚他是怎么来的了。
那么我们现在就可以把公式写成这样，（11111111 - 一个数的补码）+00000001=它相反数的补码，现在我们知道了（11111111 - 一个数的补码）=把这个数按位取反，然后把公式里的（11111111 - 一个数的补码）换成 “按位取反”，也就是 （按位取反）+000000001=它相反数的补码，现在，按位取反，再加一，就终于出来了，这就是各大书籍资料所讲的，补码=按位取反+1..。好了，真相大白
二、
正数反码：与原码相同
负数反码：符号位为“1”，数值位按位 取反。
正数补码：与原码相同
负数补码：求反加一
所有参与运算的都是以补码形式进行的 结果也是补码 因此也需要将补码转换成为原码的形式存在
下面就以一个例子进行讲解：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f063480edb36255ef5ee8f3af9c9f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89bc641efe02b9728f49ec1a9393a7fd/" rel="bookmark">
			cmake教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全栈工程师开发手册 （作者：栾鹏）
架构系列文章
基本使用 一、 基本使用
安装：下载二进制包后可直接解压使用
从源码安装则执行命令：./bootstrap; make; make install——尝试执行bootstrap失败
使用：cmake dir_path，生成工程文件或makefile文件
二、 概念
out-of-source build，与in-source build相对，即将编译输出文件与源文件放到不同目录中；
三、 基本结构
1，依赖CMakeLists.txt文件，项目主目标一个，主目录中可指定包含的子目录；
2，在项目CMakeLists.txt中使用project指定项目名称，add_subdirectory添加子目录
3，子目录CMakeLists.txt将从父目录CMakeLists.txt继承设置（TBD，待检验）
cmake基本语法 Cmake的输入是在源码目录下的CMakeLists.txt文件。这个文件可以用include或者 add_subdirectory 命令增加入其它的输入文件。
语法
CMakeList.txt文件是由注释、命令和空白字符组成。
注释是由 # 开始，到行结尾。
命令是由：命令名、（、空格分隔的参数、）组成。
例如：command (args….)
上面的command可以是一个命令名；或者是一个宏；也可以是一个函数名。
args是以空格分隔的参数例表（如果参数中包含空格，则要加双引号）
除了用于分隔参数的空白字符（空格、换行号、tabs）都是被忽略不计的。任何包含在双引号中的字符都做为一个参数。一个反斜杠用于转换码。
命令名是大小写不敏感的。
字符串(string)和字符串列表（lists）
CMake的基本数据类型是字符串（string）。CMake也支持由字符串组成的字符串列表。字符串列表可以由；或空格分隔的组成。例如：下面设置变量var是等效的。
set(var a;b;c) set(var a b c) 字符串列表可以用 foreach命令叠代（iterated）或list命令操作。
变量
CMake支持简单的变量：字符串或字符串列表。用${VAR} 语法得到变量的引用。
可以用一个set命令把一个字符串列表设置为一个变量，然后把这个变量传递给需要传递多参数的函数。例如：
set(Foo a b c) command(${Foo}) 上面两行等效 command(a b c) 如果你想传把一个字符串列表做为一个单独的参数传递给函数，用双引号包含它。例如：
Command(“${Foo}”) 等效于：command(“a b c”) 环境变量：
用$ENV{VAR}得到环境变量的引用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89bc641efe02b9728f49ec1a9393a7fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518e03b8c0bf2b39f3ea728c51cecc76/" rel="bookmark">
			基于ARM核心板实现的BMS可行性方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，国家发展改革委、国家能源局印发《“十四五”新型储能发展实施方案》（以下简称《方案》）。《方案》提出，到2025年，新型储能由商业化初期步入规模化发展阶段，具备大规模商业化应用条件。其中，电化学储能技术性能进一步提升，系统成本降低30%以上。到2030年，新型储能全面市场化发展。
《方案》的印发，无疑为新型储能行业的快速发展注入了更多动力。而特别提到的电化学储能发展目标，也释放出了电化学储能系统市场体量将进一步扩大的积极信号。
​
一、电化学储能
电化学储能是一种通过液流电池、锂离子电池以及钠硫电池等方式将电能储存起来的一种新型储能方式，主要应用于分钟至小时级的作业场景。近年来，我国电化学储能系统一直保持着较为迅速的发展趋势，据中关村储能产业技术联盟（CNESA）统计，2021年国内电化学储能新增装机高达1.9GW，同比增长58.3%。而电化学储能在全部储能市场的占比也在不断提高，且在发电侧、电网侧和用电侧均有应用。
​
电化学储能产业链
电化学储能系统，主要由电池模组，储能变流器（PCS），以及电池管理系统（BMS）和能量管理系统（EMS）组成。其中，电池模组负责储电；PCS是连接于电池系统与电网（或负荷）之间的实现电能双向转换的变流器；而BMS和EMS是储能系统的管理和控制中枢，BMS主要负责监测电池数据，保护电池安全；EMS主要通过数据采集、网络监控和能量调度来实现储能系统内部微电网的能量控制，保证微电网和整套系统正常运行。
​
电化学储能系统构成示意图
在整套系统中，电池模组和PCS成本占比较高，BMS和EMS虽然硬件成本比重不高，可作为整套系统的管理和控制中枢，其性能和功能会直接影响整套系统的运行效率和稳定性，且具有一定的开发难度，所以仍旧是业内关注的重点 。随着电化学储能系统装机量的不断提升，因项目不同、电池容量不同、冷却方式不同等差异导致BMS和EMS的需求变化将会越来越多，为此降低其开发难度变得非常关键。
目前，市面上的EMS多采用PC机+服务器的形式，而BMS硬件多采用X86工控机或嵌入式ARM主板的形式。从经济性来说，嵌入式ARM主板更具优势。同时，从BMS的产品开发角度来看，选用一款成熟稳定的嵌入式ARM核心板作为主控将会使整个产品开发过程变得简单高效，还能减少因项目变动带来的部分重复性硬件设计工作。因此，本篇文章将介绍一种基于嵌入式ARM核心板实现的BMS可行性方案，希望可帮助相关企业作为参考。
二、电池管理系统（BMS）
BMS主要由电池阵列管理单元（BAMS）、电池蔟管理单元(BCMS)以及电池管理单元（BMU）组成。
电池阵列管理单元
BMS中的“上位机”，负责对整个BMS系统的数据进行收集和分析判断、控制，具备完善的事件记录及历史数据存储，包括电池系统充放电、运行参数设定等。
电池簇管理单元
负责对电池管理单元进行监测、控制，包括电池故障诊断，均衡控制策略、剩余电量预估等。
电池管理单元
负责对电池模组的电压、温度进行采集和上传，并实现电池单体间电量双向高效主动平衡。
​
图示：电化学储能系统拓扑简图
以一兆瓦的储能电站为例，BMS需要1个电池阵列管理单元，通过CAN挂载1~4个电池簇管理单元，而每个电池簇管理单元可通过CAN挂载1~14个电池管理单元，再由电池管理单元对电池模组进行数据采集。通常情况下，每个电池模组由4并16串电池组成。
对于BMS的不同单元模块，飞凌嵌入式均有适配度很高的嵌入式ARM核心板可作为选型参考，能够帮助用户根据项目需求灵活、快速地搭建出一套稳定的BMS。
三、电化学储能BMS方案实现
1、电池阵列管理单元
推荐板卡：FET3568-C核心板 点击查看详情
FET3568-C核心板采用Rockchip RK3568处理器设计开发，四核64位Cortex-A55架构，主频高达2.0GHz。核心板功能接口丰富，支持多路CAN和UART（与电池簇管理单元和其他配套辅助设备通讯），2路千兆以太网（便于组网），RGB、LVDS、HDMI等多种显示接口（实现优秀的人机交互界面），支持PCIe3.0和STAT3.0等高速接口（连接硬盘拓展本地存储）。
​
2、电池簇管理单元
推荐板卡：FETMX6ULL-S核心板 点击查看详情
FETMX6ULL-S核心板基于NXP MCIMX6Y2处理器设计开发，Cortex-A7架构，主频800MHz，性价比出众，运行稳定，支持3路CAN（原生2路，SPI转1路）、2路千兆以太网以及8路UART，可满足电池簇管理单元的性能和成本要求。且核心板资料丰富易开发，能够快速开发出一系列同类产品。
​
3、电池管理单元
推荐板卡：FET1061-S核心板 点击查看详情
电池管理单元与电池阵列管理单元和电池簇管理单元不同，采用MCU即可实现，因此推荐FET1061-S核心板。FET1061-S核心板搭载ARM Cortex-M7内核，集微控制器的低功耗、易用性与应用处理器的高性能、高扩展性于一体。支持多路CAN、2路百兆以太网，以及高达32路高速GPIO，可轻松采集多路电池数据。
以上就是基于嵌入式ARM核心板的BMS可行性方案推荐。https://www.forlinx.com/product/44.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79141143f71fb45cbc7d05d04e51b7ae/" rel="bookmark">
			springboot&#43;thymeleaf&#43;shiro标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，pom中加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.thymeleaf/thymeleaf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;${thymeleaf.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- shiro安全框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--thymeleaf-shiro-extras--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; 2，用户-角色-权限的表关系 实体类
//用户表 public class User { private Integer userId; private String userName; private Set&lt;Role&gt; roles = new HashSet&lt;&gt;(); } //角色表 public class Role { private Integer id; private String role; private Set&lt;Module&gt; modules = new HashSet&lt;&gt;(); private Set&lt;User&gt; users = new HashSet&lt;&gt;(); } //权限表 public class Module { private Integer mid; private String mname; private Set&lt;Role&gt; roles = new HashSet&lt;&gt;(); } 查询接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79141143f71fb45cbc7d05d04e51b7ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1186c2b2cf5f8a29abd23868ecdb6c/" rel="bookmark">
			逻辑卷管理 LVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑卷管理 LVM(Logical Volume Management)
传统分区使用固定大小分区，重新调整大小十分麻烦。但是，LVM可以创建和管理“逻辑”卷，而不是直接使用物理硬盘。可以让管理员弹性的管理逻辑卷的扩大缩小，操作简单，而不损坏已存储的数据。可以随意将新的硬盘添加到LVM，以直接扩展已经存在的逻辑卷。LVM并不需要重启就可以让内核知道分区的存在。首先是实际的物理磁盘及其划分的分区和其上的物理卷（PV）。一个或多个物理卷可以用来创建卷组（VG）。然后基于卷组可以创建逻辑卷（LV）。只要在卷组中有可用空间，就可以随心所欲的创建逻辑卷。文件系统就是在逻辑卷上创建的，然后可以在操作系统挂载和访问。
逻辑卷管理的基本操作： 物理卷(Physical Volume) –创建物理卷（可以是整个磁盘或者某个磁盘分区）
pvcreate /dev/sdb
或者
pvcreate /dev/sdb1
–删除物理卷
pvremove /dev/sdb
–查看物理卷
pvdisplay
卷组(Volume Group) –创建卷组
vgcreate vg1 /dev/sdb
–删除卷组
vgremove vg1
–查看卷组
vgdisplay vg1
–扩展卷组
vgextend vg1 /dev/sdc
逻辑卷(Logical Volume ) –创建逻辑卷(在vg1中创建一个大小为5G,名为lv1的lv)
lvcreate -L 5G -n lv1 vg1
–删除逻辑卷
lvremove /dev/vg1/lv1
–查看逻辑卷
lvdisplay
扩展逻辑卷 –未格式化挂载前，扩展逻辑卷
lvresize -L 8G /dev/vg1/lv1
–已格式化挂在后，扩展逻辑卷
挂载逻辑卷
mkfs.xfs /dev/vg1/lv1
mkdir /test
mount /dev/vg1/lv1 /test
df -Th
ext4 卸载逻辑卷(扩展前需要先卸载)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1186c2b2cf5f8a29abd23868ecdb6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd84a33a214fc66aac6d2e07e16924a/" rel="bookmark">
			.NET Core 3.1 Web Api 如何跨域以及Post请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.NET Core 3.1 Web Api 如何跨域以及Post请求 文章目录 .NET Core 3.1 Web Api 如何跨域以及Post请求前言一、如何跨域？一级标题1、配置startup.cs文件首先配置ConfigureServices方法然后配置Configure方法最后则是在控制器中的引用 二、如何进行Post传值？ 前言 .net core 3.1 如何跨域以及如何通过post取值
一、如何跨域？ 一级标题 1、配置startup.cs文件 首先配置ConfigureServices方法 //此方法由运行时调用。使用此方法向容器中添加服务。 public void ConfigureServices(IServiceCollection services) { services.AddControllers(); //获取appsettings.json配置信息 var config = new ConfigurationBuilder() .SetBasePath(System.IO.Directory.GetCurrentDirectory()) .AddJsonFile("appsettings.json") .Build(); //获取允许跨域的域名配置 var alloweHosts = config["AllowedHosts"]; //配置跨域处理 services.AddCors(options=&gt; { options.AddPolicy("cors", builder =&gt; { //允许所有Origin策略 builder.WithOrigins(alloweHosts) .AllowAnyOrigin() //允许所有请求方法Get,Post,Put,Delete .AllowAnyMethod() //允许所有请求头 appliction/json .AllowAnyHeader(); //指定处理cookie,这个在.netcore 2.1的时候能用，而打了3.1就用不了了 //.AllowCredentials(); }); }); } 然后配置Configure方法 注意的是app.UseCors()方法必须在 app.UseRouting()之后，在app.UseAuthorization()之前,app.UseCors()里的参数需和上面ConfigureServices中AddPolicy设置的相同
//此方法由运行时调用。使用此方法配置HTTP请求管道。 public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { //而判断env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bd84a33a214fc66aac6d2e07e16924a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca1c4448432bc43548d928ae283659e/" rel="bookmark">
			Docker容器中编辑文件时提示：vi: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker创建好容器后，有时需要进入容器编辑相应的文件，但是进入容器后使用vi或者vim命令时提示：vi: command not found
产生问题的原因
容器中没有安装vi或者vim 解决办法
apt-get update #更新软件列表 apt-get install vim #下载 我这里使用的centos7操作系统，ubantu操作系统，使用yum下载来代替apt-get
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/509a17fc1fcc1a9658e04772ce69528f/" rel="bookmark">
			51单片机总结复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 51单片机复习 51单片机入门教程-2020版 程序全程纯手打 从零开始入门_哔哩哔哩_bilibili
串口 LED点阵屏 要知道移位寄存器工作原理
&amp;=用来清零某一位
|=用来置一某一位
^=用来取反某一位
SER=Byte&amp;0x80; 这句代码是取最高位数据，如果最高位是1，那🐟了以后就是10000000，非0，那SER就是1；如是最高位是0，那就是00000000，SER就是0
DS1302 注意读数据时 写命令SCLK先0后1 读取数据SCLK先1后0，因为下降沿就直接读出数据，为了写命令就是写命令，这样可以错开一个时钟
if（DS1302_io）是读到数据不为0，也就是1后，才进行或运算将这一位置一，读到数据0就跳过这一位，默认是0
蜂鸣器 E2PROM 地址前四位固定1010
SLAVE ADDRESS 是AT24C02的地址，WORD ADDRESS是AT24C02这个设备要写入数据的地址。
%256:取低八位
十进制形式：4544%256=192
二进制形式：
00010001 11000000&amp;
00000000 11111111 =
00000000 11000000
十六进制形式：
0x11c0&amp;0x00ff=0xc0
/256:取高八位
十进制形式：4544/256=17
二进制形式：
00010001 11000000&amp;
11111111 00000000 &gt;&gt;24=
00010001 00000000
十六进制形式：
0x11c0&amp;0xff00&gt;&gt;24=0x11
DS18b20 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1zwxAoAc-1649289240657)(https://gitee.com/bbcen/images/raw/master/img/20210903210116.png)]
LCD1602 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ab508f7dc03abe8299b1cd2a285409/" rel="bookmark">
			Vue Syntax Error: Error: Node Sass version 7.0.1 is incompatible with ^4.0.0.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 错误描述 启用 Vue 项目时报错：Syntax Error: Error: Node Sass version 7.0.1 is incompatible with ^4.0.0.
2 问题处理 上面的错误是表示安装的 Sass 版本过高，需要安装 4.x.x 版本的 Sass。
NodeJs 和 Sass 版本对照表：
NodeJSSupported node-sass versionNode ModuleNode 177.0+102Node 166.0+93Node 155.0+, &lt;7.088Node 144.14+83Node 134.13+, &lt;5.079Node 124.12+72Node 114.10+, &lt;5.067Node 104.9+, &lt;6.064Node 84.5.3+, &lt;5.057Node &lt;8&lt;5.0&lt;57 2.1 查看当前包列表，检查 Sass 版本
npm view 2.2 删除安装的高版本 Sass
npm uninstall node-sass 2.3 安装 4.x.x 版本的 Sass
npm install node-sass@4.14.1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5cf1530f26ed5b417c3161b8eb06917/" rel="bookmark">
			刷题学习记录——leetcode 55 跳跃游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。
示例 1：
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
来源：力扣（LeetCode）
初步思路 基于第一个元素的值查看能访问到最远元素的值，如果大于0就继续访问最远元素，如果=0就发生回退。但是这个思路有一个问题，你只回退一次有时候是解决不了问题的（比如遇到连续0的情况），但是你此时上一个状态已经丢失了，也没法回到上一个状态，卡在中间就有几组数据无法通过：
无法通过！！！仅记录
164 / 170 个通过测试用例
状态：解答错误
最后执行的输入：
[3,0,8,2,0,0,1]
class Solution { public boolean canJump(int[] nums) { boolean res = false; int len = nums.length; int length = nums[0]; res = jump(nums,length,0,false); return res; } public boolean jump(int[] nums,int length,int index,boolean flag){ int len = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5cf1530f26ed5b417c3161b8eb06917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b4a0c439ac0b50ce11eaaff47fedf0/" rel="bookmark">
			书qwgjcdunk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		u1lib.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065b174a91890780c569bdb47ddaf030/" rel="bookmark">
			微信信息轰炸【简易版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本版本的微信信息轰炸仅能在电脑端使用：
简单讲解下其中的原理:
在程序中输入我们想要信息轰炸的信息，然后模拟键盘输入。
其实我们就是使用了python的库pynput,模拟输入文字和信息，不多说，上代码
from pynput.keyboard import Key,Controller as key_cl from pynput.mouse import Controller,Button import time def keyboard_input(string): keyboard = key_cl() keyboard.type(string) def mouse_click(): mouse = Controller() keyboard = key_cl() mouse.press(Button.left) mouse.release(Button.left) keyboard.press(Key.enter) def main(number,string): time.sleep(7) for i in range(0,number): keyboard_input(string) mouse_click() time.sleep(0.5) if __name__ == "__main__": main(10,"Hello") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0037501073d00f3629c1f477fdf7e3aa/" rel="bookmark">
			未配置 Spring Boot 配置注解处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 未配置 Spring Boot 配置注解处理器 在pom文件中添加依赖此即可！
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528957ed7e0b0290adbe59051f82b1e8/" rel="bookmark">
			如何提高自己代码的可读性？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你自己的代码可读性怎么样，能让不懂代码的同学看懂主要逻辑吗？有没有“觉得大家的代码风格都差不多”这种感觉？
有没有被吐槽过，或者被赞扬过？
是否也写过或见过几百行的代码，内部调用的方法又是几百行？你见过可读性最好的代码是什么样的，它有什么规则？
代码可读性重要吗，它只有外延没有内涵吗？
无所谓你遇到过哪种问题，或者对某些问题感兴趣，如果说情人能带给你幸福，那么这篇文章或许可以带给你春风。
当养成了某个习惯后，这个习惯可能是好的也可能是坏的，构思代码的习惯就是一个很好的例子。 当拿到需求后经过评审之后，就知道要做什么事了，可是代码要怎么写？
写个Controller、Service 、Dao一通调用，没错这就是习惯。 如果需求量大的很有可能导致service层逐渐臃肿，业务紧密度很高，不易维护。 如果是一个新人对这大段代码来进行梳理的话，学习成本会很高，而且效益不佳。
可读性是没有标准的，只能站在调用方的角度体验调用方式，站在非己的角度去读代码。 如果很难衡量这样的一个点的话，那么可以尝试这种方式：
读一个可读性好的代码可以像读一本书那样，有目录，有章节，有小节、有内容，不同的章节写不同的内容，如果忘记某一个点在哪个章节下就从目录开始看。
一个例子：
从配置中心获取所有节点供上游使用。 如果该节点没有权重，则按照一定算法进行权重分配。 权重分配后按照一定规则进行排序，最近一次使用的配置，置顶配置，指定配置，其他的按照权重降级排序。
思路：
当拿到一个需求的时候首先要清楚逻辑，可以通过绘图或者其他方式让逻辑更清晰些，比如上述的例子中可以有这样的思路：
1、获取所有节点配置信息； 注意这个时候可能由于异常获取其他原因获取不到数据。
2、分配权重，这个时候可能大多数同学都会想到if，先不要管这个，需要知道的是，只要有分配权重这样的事情发生就要处理，所以我们很确定分配权重这件事要做，但是具体怎么做，在这件事内部做处理。 说白了if判断要在分配权重这件事内部去做，而不是在之前。
3、按照规则排序，既然有明确的规则，而这种规则可能会随便变更或者多个规则交替使用，所以把排序规则单独抽取出来一个逻辑处理层，这个处理层只负责排序这件事，这样即可保证每个处理层的职责边界，也不会让单一的处理层变得臃肿。
下面用两种编程范式大概实现下思路：
1）函数式
​​​​​
@Slf4j@Service@RequiredArgsConstructorpublic class ConfigService { private final ConfigLoader configLoader; /** * 1、根据产品线获取配置信息。 * 2、设置权重 * 3、对配置进行排序 * 4、构建返回结果 */public List&lt;ConfigResult&gt; fetchConfigList (ConfigDTO dto) { return Option.of(configLoader.fetchConfigsByProductLine(dto.getProductLine())).map(this :: buildWithWeight).map(sortConfigsFunction()).flatMap(buildToConfigResultFunction()).getOrElse(defaultResultSupplier());} } 2）命令式
@Slf4j@Service@RequiredArgsConstructorpublic class ConfigService { private final ConfigLoader configLoader; public List&lt;ConfigResult&gt; fetchConfigList (ConfigDTO dto) { // 根据产品线获取配置信息 List&lt;Config&gt; list = configLoader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528957ed7e0b0290adbe59051f82b1e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d1f8cfac3e9a9a241ddbedc6fef36e/" rel="bookmark">
			安全狗西部网络安全运营中心 护航“东数西算”工程安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，安全狗和中国电子信息产业集团所属中电算力科技应用(宁夏)有限公司签署战略合作协议。
经过与多家安全厂商的安全能力全面比对，同时安全狗系列云安全产品接受了多轮的严格测试，最终凭借综合且突出的产品矩阵与能力被选为此项目的合作安全厂商。
双方依托各自优势，携手共建西部网信产业基地，为国家“东数西算”战略布局添砖加瓦。
安全狗成立于2013年，自成立以来就致力于提供云安全领域相关产品、服务及解决方案，是国内最早引入云工作负载安全(CWPP)概念，并成功构建相应产品线的专业云安全厂商。
一、大力发展“东数西算”工程，深挖数据要素潜能
今年2月份，国家发改委、中央网信办、工业和信息化部、国家能源局联合印发文件，对全国分散、孤岛化的数据中心做了统一规划与布局，正式启动了“东数西算”工程。从国家战略发展角度来看，“东数西算”工程的落地提升了深挖数据要素潜能的效率，进一步加快我国数字经济的发展。
根据全国一体化大数据中心体系布局，宁夏作为8个国家算力枢纽节点之一，其电子信息产业成为发展重点之一。此外，宁夏自治区2022年初《政府工作报告》明确表示，要抢抓“东数西算”机遇，高水平建设全国一体化算力网络宁夏枢纽，拓展5G、大数据、人工智能等应用场景，培育上云企业1000家、服务业集聚区13个。
在此宏观背景下，做好西部网络安全城市运营中心的工控安全、云安全运营服务等建设工作对宁夏地区“东数西算”工程的稳步落地尤为重要。
二、安全狗打造工业互联网安全监测态势感知平台
根据2012年至2019年全球工控安全报告显示，工控安全事件逐年增长；此外，作为全球网络攻击最大的受害国，自2009年以来我国遭受的网络攻击增长达到15倍，其中30%针对的是国家关键基础设施，工业系统网络安全风险日益增大；随着工控安全重要性的提升，我国也颁布了多份工控安全政策与规定，旨在推进我国工控安全防护工作进一步落实。此外，工业互联网也面临着做好分级分类管理的要求。
面对国外的严峻安全形势以及国内刚需的数字经济转型发展要求，安全狗与中电算力结合宁夏产业发展优势，紧密围绕“工业态势感知”、“工业安全监测”、“工业威胁情报”三个维度建设工业互联网监测态势平台，为宁夏的“东数西算”工程做好一体化工控安全管理。
据悉，宁夏工控安全指挥平台以“安全狗工业互联网安全监测态势感知平台”为核心，围绕全区工业互联网资产，以工业安全事件告警与分析为主线，持续监测全局工业安全风险。安全狗通过实现工业安全设备集中管理与监控、日志和流量集中采集与分析、威胁统一分析与运营、事件应急响应与处置等核心功能，相关工控网络安全单位威胁情报得到共享，同时可建立和完善工控安全联动工作机制，协同应对重大工控安全事件，从整体上提升工控安全防护水平和科学应对能力，为全区工业互联网发展保驾护航。
借助安全狗工业互联网监测态势平台安全能力持续发挥作用，宁夏工业安全体系化建设进一步强化，也直接推动宁夏自治区工业互联网的安全健康发展。
三、安全狗城市安全运营中心护航宁夏“东数西算”工程安全开展
作为领先的云安全服务和解决方案提供商，安全狗城市安全运营中心以“平台+服务”的模式，依托安全狗综合且强大的安全产品矩阵和能力，充分发挥云计算集约化、服务化的能力优势，结合宁夏算力节点当前的建设需求，以一体化的工控安全平台为抓手，深度参与西部算力枢纽节点的建设工作，满足“东数西算”场景下的网络安全需求。
值得一提的是，安全狗城市安全运营中心所运用到的安全狗·云磐产品，其(云)主机安全服务能力、微隔离服务能力、容器安全服务能力等也受到国际权威机构Gartner团队的认可并入选相关技术报告。此外，作为一个立体式纵深防御安全平台，云磐也受到工业和信息化部网络安全管理局的认可。云磐先后为包括央企部委、金融行业、教育科研、大型企业、运营商等各个行业头部客户提供了到位的产品与服务，在用户市场占有率也不断扩大，累计服务了80万客户，每日拦击4亿攻击，保护了500万台服务器。
此次，安全狗依托城市安全运营中心和旗下系列产品为宁夏“东数西算”工程的安全发展输出“安全智慧大脑”能力，也为后续合作的深入开展奠定了良好的开端。这同时也是安全狗继获得中国移动主机安全集采项目第一期&amp;第二期&amp;国内大型国有银行项目，创下国内CWPP行业领域新纪录后，整体云安全能力和数据安全能力的又一次突出表现。
未来，安全狗将紧密跟踪国内外前沿安全技术发展趋势，不断洞悉用户安全需求，持续提升自身安全创新能力与水平，从多个维度深度参与宁夏“东数西算”工程的安全体系建设，为其打造适合城市发展的安全运营体系，建设技术、人才、运营三位一体的城市安全运营中心。为整体城市数字基础设施、重要数字资产和信息系统建设工作的开展提供统一的安全防护和应急处置服务，护航宁夏“东数西算”工程安全发展，为我国的数字经济转型深入发展全力以赴。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11bbdea71b79cdc5b51deaf6c9ead136/" rel="bookmark">
			Pytorch中.detach()与.data()的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里是官方文档对detach的定义
实际上，detach()就是返回一个新的tensor，并且这个tensor是从当前的计算图中分离出来的。但是返回的tensor和原来的tensor是共享内存空间的。
import torch a = torch.tensor([1.0, 2.0, 3.0], requires_grad = True) a = a.detach() # 会将requires_grad 属性设置为False print(a.requires_grad) 举个例子来说明一下detach有什么用。 如果A网络的输出被喂给B网络作为输入， 如果我们希望在梯度反传的时候只更新B中参数的值，而不更新A中的参数值，这时候就可以使用detach()
a = A(input) a = a.deatch() # 或者a.detach_()进行in_place操作 out = B(a) loss = criterion(out, labels) loss.backward() 如果希望修改A的参数， 而不希望修改B的参数， 那么就需要手动将B中参数的requires_grad属性设置为False
for param in B.parameters(): param.requires_grad = False 还有一点需要注意的是Tensor.detach()和Tensor.data()的区别
Tensor.data()和Tensor.detach()一样， 都会返回一个新的Tensor， 这个Tensor和原来的Tensor共享内存空间，一个改变，另一个也会随着改变，且都会设置新的Tensor的requires_grad属性为False。这两个方法只取出原来Tensor的tensor数据， 丢弃了grad、grad_fn等额外的信息。区别在于Tensor.data()方法不能被autograd追踪到，如果你修改了Tensor.data()返回的新Tensor，原来的Tensor也会改变， 但是这时候的微分并没有被追踪到，那么当你执行loss.backward()的时候并不会报错，但是求的梯度就是错误的！因此， 如果你使用了Tensor.data()方法， 那么切记一定不要随便修改返回的新Tensor的值。如果你使用的是Tensor.detach()方法， 当你修改他的返回值并进行求导操作，会报错。 因此，Tensor.detach()是安全的。
转载链接：https://zhuanlan.zhihu.com/p/410199046
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/230912d6fb1a4a065a842cf8fa5e38eb/" rel="bookmark">
			Spring远程命令执行漏洞（CVE-2022-22965）原理分析和思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上周网上爆出Spring框架存在RCE漏洞，野外流传了一小段时间后，Spring官方在3月31日正式发布了漏洞信息，漏洞编号为CVE-2022-22965。本文章对该漏洞进行了复现和分析，希望能够帮助到有相关有需要的人员进一步研究。
1►前置知识 1.1 SpringMVC参数绑定
为了方便编程，SpringMVC支持将HTTP请求中的的请求参数或者请求体内容，根据Controller方法的参数，自动完成类型转换和赋值。之后，Controller方法就可以直接使用这些参数，避免了需要编写大量的代码从HttpServletRequest中获取请求数据以及类型转换。下面是一个简单的示例：
import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody; @Controllerpublic class UserController { @RequestMapping("/addUser") public @ResponseBody String addUser(User user) { return "OK"; }}​​​​​​ public class User { private String name; private Department department; public String getName() { return name; } public void setName(String name) { this.name = name; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; }}​​​​ public class Department { private String name; public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/230912d6fb1a4a065a842cf8fa5e38eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5fee905029295cfde647c1f58b3d553/" rel="bookmark">
			安装pyqt5遇到的问题（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打算安装pyqt5，然后pip install PyQt5
报错：
Command "g:\python3.7\python.exe g:\python3.7\lib\site-packages\pip install --ignore-installed --no-user --prefix C:\Users\用户\AppData\Local\Temp\pip-build-env-o2fimxzi\overlay --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- "sip &gt;=6.4, &lt;7" "PyQt-builder &gt;=1.9, &lt;2"" failed with error code 2 in None
可以下载，但是安装不行。
然后发现是没安装sip，于是pip install sip
还是报错：
Command "g:\python3.7\python.exe g:\python3.7\lib\site-packages\pip\_vendor\pep517\_in_process.py prepare_metadata_for_build_wheel C:\Users\用户\AppData\Local\Temp\tmp8voqpa7g" failed with error code 1 in C:\Users\用户\AppData\Local\Temp\pip-install-_xhpmsom\sip
于是接着搜索，发现是没有wheel模块，接着pip install wheel
wheel安装成功！
继续pip install sip
报错：
error: Microsoft Visual C++ 14.0 is required. Get it with "Microsoft Visual C++ Build Tools"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5fee905029295cfde647c1f58b3d553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b30547264b341e1c7b482c57c3d9cee/" rel="bookmark">
			MacOS 指令 [rm] 删除所有 [mdfind] 查出来的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近清理 Mac上删除软件后残留下来的一些文件，可以用mdfind查找硬盘上有哪些相关名字的文件名与文件夹名，但会很多，自己手动一条一条执行又很慢，这时就可以使用组合命令，如果是linux用户应该会非常熟悉
rm -ir $(mdfind -name -0 1111 | xargs -0)
首先，rm 指令的 -i 代表每次删除前都需要询问是否删除，而 r 大家应该都很熟悉，就是删除目录。
然后大家会看到 $() 这个就是为了在一个指令中去执行另外一个指令，括号里就是写另外一个指令 mdfind
mdfind 的 -name 就不介绍了，这个-0 代表通过 '\0' 也就是 NUL 来做每个结果的分隔符号让结果连起来。接下来就是 Linux 用户都熟知的管道符号 | 这里通过管道符号对结果进行二次操作 xargs -0 的目的就是将结果中所有的 '\0' 替换为空格，这样最后的结果就会变成删除所有匹配 1111 的结果文件与目录
以上就是这篇文章的全部内容，希望可以帮助到大家。
相关阅读 [1] rm all mdfind results, handling pathnames with spaces[2] xargs(1) — Linux manual page[3] mdfind 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b662af43d4531156c13b0099578be22/" rel="bookmark">
			Cocos Creator 源码解读之Schedule
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		creator 里面的计时器相信大家不陌生，但是了解它的原理是必要的，它的运行机制和setInterval有什么不同呢，
先简单说说setInterval的原理：setInterval是每隔一段时间向事件队列里面添加回调函数，如果主线程忙的话调用时间不确定特别容易出问题，由于setInterval只负责定时向队列中添加函数，而不考虑函数的执行，setInterval有一个原则：在向队列中添加回调函数时，如果队列中存在之前由其添加的回调函数，就放弃本次添加（不会影响之后的计时），如果主线程忙的话，之前添加的计时器回调没有触发紧接着又添加一个这个时候就会放弃本次添加，是很容易出问题的。另外计时是不准确的。
但是提前说好schedule的计时也是不准确的
首先看看schedule是什么时候出生的：
cc.Director = function () { EventTarget.call(this); // paused? this._paused = false; // purge? this._purgeDirectorInNextLoop = false; this._winSizeInPoints = null; // scenes this._scene = null; this._loadingScene = ''; // FPS this._totalFrames = 0; this._lastUpdate = 0; this._deltaTime = 0.0; this._startTime = 0.0; // ParticleSystem max step delta time this._maxParticleDeltaTime = 0.0; // Scheduler for user registration update this._scheduler = null; // Scheduler for life-cycle methods in component this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b662af43d4531156c13b0099578be22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca82550b8169b25f64fabd27af4b624/" rel="bookmark">
			ros(14):sudo rosdep init和rosdep update报错解决与理论分析----应该绝对好用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错 1.1 sudo rosdep init报错 sudo rosdep init时会由于网络问题报错：
ERROR: cannot download default sources list from:
https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list
Website may be down.
示例如下:
meng@meng:~$ sudo rosdep init ERROR: cannot download default sources list from: https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list Website may be down. 1.2 rosdep update报错 同时当sudo rosdep init成功后，同样会因为网络问题而在执行rosdep update时卡住 二、报错解决与理论分析 2.1 下载rosdep文件到本地(不能访问github可以留下邮箱) rosdep是ros的“依赖项”，ros运行一般需要这些文件；rosdep官方github地址为:https://github.com/ros/rosdistro
进入网站，可以看出，只有少部分文件在近期更新，一般不是很影响(如果怕影响可以定期更新下载的文件并进行替换)，直接下载即可（举个例子，我在大四下自己用自己下载的rosdep到自己的笔记本上用，现在研一下了还可以用）
下载命令为:(如果新电脑无法下载，可以用别的电脑下载并拷贝过来)
git clone https://github.com/ros/rosdistro 2.2 创建并修改20-default.list文件 没有20-default.list文件时，创建命令如下：（有的话直接打开修改即可）
mkdir -p /etc/ros/rosdep/sources.list.d/20-default.list 并打开/etc/ros/rosdep/sources.list.d/20-default.list进行修改：
sudo gedit /etc/ros/rosdep/sources.list.d/20-default.list 填入并修改以下文件地址：（注：file://是本地文件链接方式，不同于https等）
yaml file:///home/xxx/rosdistro/rosdep/osx-homebrew.yaml osx # generic yaml file:///home/xxx/rosdistro/rosdep/base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca82550b8169b25f64fabd27af4b624/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f5277e562526aa4f31f8288cbf1910/" rel="bookmark">
			反转链表【递归】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天复习递归的时候遇见了一个大家都觉得很简单的题：反转链表
把自己别住了 想明白了觉得说这题用了这么久真的好丢人。。。。。。
详细的写下来，如果下次遇见再不会 我就打死我自己。。。。
题目：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
先把节点写出来
public class Node { int val; Node next; Node() {} Node(int val) { this.val = val; } Node(int val, ListNode next) { this.val = val; this.next = next; } } 方法一：将头结点指向null； 变成最后一个结点；提前把第2保存在temp中。第二个结点指向第一个结点.....结束条件是cur=null
代码实现： public Node reverseList(Node head) { Node temp; Node cur; Node pre; pre = null; cur = head; while (cur != null) { temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; } 方法二：递归
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f5277e562526aa4f31f8288cbf1910/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2154cbbf2d1edef5029b10656f3e1ee8/" rel="bookmark">
			Dart笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dart介绍 将 Dart 和 JavaScript 做一个对比：
开发效率高
Dart 运行时和编译器支持 Flutter 的两个关键特性的组合：
基于 JIT 的快速开发周期：Flutter 在开发阶段采用，采用 JIT 模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；基于 AOT 的发布包: Flutter 在发布时可以通过 AOT 生成高效的机器码以保证应用性能。而 JavaScript 则不具有这个能力。 高性能
Flutter 旨在提供流畅、高保真的的 UI 体验。为了实现这一点，Flutter 中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而 Dart 支持 AOT，在这一点上可以做的比 JavaScript 更好。
快速内存分配
Flutter 框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter 将无法有效地工作。当然 Chrome V8 的 JavaScript 引擎在内存分配上也已经做的很好，事实上 Dart 开发团队的很多成员都是来自Chrome 团队的，所以在内存分配上 Dart 并不能作为超越 JavaScript 的优势，而对于Flutter来说，它需要这样的特性，而 Dart 也正好满足而已。
类型安全和空安全
由于 Dart 是类型安全的语言，且 2.12 版本后也支持了空安全特性，所以 Dart 支持静态类型检测，可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript 是一个弱类型语言，也因此前端社区出现了很多给 JavaScript 代码添加静态类型检测的扩展语言和工具，如：微软的 TypeScript 以及Facebook 的 Flow。相比之下，Dart 本身就支持静态类型，这是它的一个重要优势。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2154cbbf2d1edef5029b10656f3e1ee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e8a5fbdeacfbfbed7f81b8360be920/" rel="bookmark">
			关于SpringMVC的url-pattern解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于SpringMVC的url-pattern解读 关于SpringMVC的\解读一、\的作用二、\配置详解(1) *.do(2) /(3) /* 三、静态资源访问方法一：使用方法二：使用\ 目录显示问题无法处理
关于SpringMVC的&lt;url-pattern/&gt;解读 一、&lt;url-pattern/&gt;的作用 首先我们要知道配置&lt;url-pattern/&gt;的作用：将请求当作一个controller处理，然后dispatcherServlet(中央调度器)去调用HandleMapping(处理器映射器)查找到相应的处理器。
简单的来说就是匹配到的请求会去寻找controller
二、&lt;url-pattern/&gt;配置详解 (1) *.do *.do会匹配这种格式的请求(请求地址)，然后去查看controller中是否有这样的的controller。
(2) / 匹配根目录下的所有请求，包括静态资源的获取请求，例如：.css,.js,.html等静态资源，但是不会匹配到.jsp这样的后缀的url。
​ 也就是说这些.html的请求都会被当作一个controller去请求，这样肯定是访问不到的，会报错404。
​ 但是不会匹配到.jsp这样的后缀的url，也就是说.jsp就不会被经过dispatcherServelt，可以直接被访问，因此我们配置&lt;url-pattern/&gt;为\的时候就会访问.jsp是不会报错的，能被访问到。
(3) /* 匹配根目录下的所有请求，包括静态资源的获取请求，例如：.css,.js,.html等静态资源，包括.jsp这样的后缀的url。
​ 也就是说这些，无论什么请求都会被当作一个controller来处理，所以我们在访问这些静态资源的时候都会报404错误。
三、静态资源访问 我们写成上面的/或者/*,就不能访问静态资源了，但是这样是不行的。所以我们再经过一些配置就可以访问静态资源了。
方法一：使用mvc:default-servlet-handler/ ​ 声明了后 springmvc 框 架 会 在 容 器 中 创 建DefaultServletHttpRequestHandler 处理器对象。它会像一个检查员，对进入 DispatcherServlet 的 URL 进行筛查，如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的 Servlet 处理。一般的服务器都有默认的 Servlet。
​ 在 Tomcat 中，有一个专门用于处理静态资源访问的 Servlet 名叫 DefaultServlet。其&lt;servlet-name&gt;为 default。可以处理各种静态资源访问请求。该 Servlet 注册在 Tomcat 服务 器的 web.xml 中。在 Tomcat 安装目录/conf/web.xml。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91e8a5fbdeacfbfbed7f81b8360be920/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd03a7be3fffa490031d54044150c78/" rel="bookmark">
			转录组-PCA分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PCA分析步骤：
第一步，对所有样本进行中心化
第二步，求特征协方差矩阵
第三步，求协方差矩阵的特征值和特征向量
第四步，将特征值按照从大到小的顺序排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵
第五步，将样本点投影到选取的特征向量上(用欧氏距离方程计算点间距离)
getwd() #导入三张表 gene_exp&lt;-read.csv("gene_exp.csv",header = T,row.names = 1) gene_info&lt;-read.csv("gene_info.csv",header = T,row.names = 1) sample_info&lt;-read.csv("sample_info.csv",header = T,row.names = 1) #BiocManager::install("PCAtools") library(PCAtools) 一、样本相关性分析
sample_cor&lt;-cor(gene_exp)#计算样本相关性 sample_cor2&lt;-round(sample_cor,digits = 2)#保留两位小数 library(pheatmap) pheatmap(sample_cor2) 二、样本聚类
##计算距离矩阵 sample_dist&lt;-dist(t(gene_exp))#先转置在计算距离矩阵 ##聚类 sample_hc&lt;-hclust(sample_dist) plot(sample_hc) 三、主成分分析
library(PCAtools) ##主成分分析 pca&lt;-pca(gene_exp,metadata=sample_info,removeVar = 0.1)#样本名字顺序要完全一致！ pca_loadings&lt;-pca$loadings#提取loadings信息 pca_loadings[1:4,1:4]#打印出1-4行/1-4列 pca_rotated&lt;-pca$rotated#提取rotated信息 pca_rotated[1:4,1:4] screeplot(pca)#画图:主成分对样本差异的解释度 biplot(pca,#画图:PC1/PC2图 x="PC1", y="PC2",#PC1/PC2可换 shape = "group",)#形状=分组信息 plotloadings(pca)#查看哪些gene对PCA的贡献大 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d261a0271f3087394bb6997b781df3f/" rel="bookmark">
			Tableau安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://pan.baidu.com/s/1yaE4L03ClSijWTK3R3_MSw 提取码：7s3h
1、下载安装，成功后退出（不要点击试用和激活）
2、将tabui.dll文件放到安装目录下
我的是 C:\Program Files\Tableau\Tableau Public 2021.4\bin
（找不到的话可以右击tableau，点击‘打开文件所在位置’即可）
拖动文件到该目录下，点击替换目标中文件
4、重新打开该软件即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e470445291efbacaf18252c49608ad9a/" rel="bookmark">
			项目经理值得一试的思维方式：项目成功方程式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“有没有一个一劳永逸的项目管理实践？”
“我怎样才能找到一个能够解决所有问题的方法？”
“为什么我用的都是同样的方法，但有的项目延期了？”
……
在很多敏捷群中，经常会有人问这些问题。那有没有一个可以解决所有问题的方法呢？答案是：没有，因为没有银弹。
早在1986年，弗雷德·布鲁克斯就曾在学术角度提出：没有能解决软件危机的银弹。为什么呢？其最根本的原因在于，软件本身有以下固有特性：
复杂度：软件复杂度会随着规模呈现非线性增长，出现项目成本超支、人员状态不同步、功能可用性差、结构复杂等问题；一致性：软件系统需要与现有系统进行交互，这就需要让新软件系统的接口与原有软件系统保持一致；可变性：由于用户需求、市场等外在因素是持续变化的，这要求软件需要具备可变性；不可见性：每个人对软件、需求或任务都有不同的理解，这会让沟通变得异常困难。 这些特性在软件交付项目中会产生诸多挑战，降低团队效能，甚至会导致项目失败。
面对这些挑战，我们并非没有办法。虽然在软件交付项目中没有银弹，但项目成功是一系列因素共同作用的结果。我们只要找出能够影响项目过程的因素，并立刻行动，就能推动项目成功率提高。我们可以通过一个思维方式——打造团队的项目成功方程式来推动项目成功：
从上面这个项目成功方程式，我们可以得知，项目是否成功交付，取决于各个因素的界限值。在项目中，低界限的因素将决定整个项目的上限。也就是说，如果将项目中每一个因素都能从1提升到1.01，多项的相乘也将产生巨大的成果。相对应的，如果将每一项都降低为0.99，比如管理粗糙“一点”、价值降低“一点”、行动慢“一点”……这样的项目就会漏洞百出。
那如何将项目中的因素从1提升到1.01呢？以下行动路径可以给大家一些帮助：
产品价值在整个项目成功方程式中是最特殊的一环：只有产品产生了价值，项目成功才会有意义。
项目成功方程式只是帮助项目经理们更好地思考问题的一种方式，项目成功受多方因素影响，上面列举出来的并非影响项目成功的全部因素，因此项目相关成员可以根据自己的经验和教训，不断地扩充这一项目成功方程式，改进团队项目管理方式。和我们一起来寻找每个项目的最佳实践吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3964c4d13fec9321337a485e6637c6a3/" rel="bookmark">
			java 为新员工分配部门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编写一个程序实现新入职的员工分配，要求根据用户的姓名，和招聘语言确定分配到哪个部门，如果没有此语言。则给出相关提示。
Test类 package anli01; import java.util.Scanner; public class test4 { public static void main(String[] args) { Scanner sc =new Scanner(System.in); System.out.println("请输入员工姓名"); String name= sc.next(); System.out.println("请输入应聘的语言"); String language= sc.next(); //根据应聘的语言来确定所属的部门 switch(language){ case "JAVA": case"java": System.out.println(name+"员工被分配到了java开发部门"); break; case "C#": case"c#": System.out.println(name+"员工被分配到了c#开发部门"); break; case "ASP.NET": case"asp.net": System.out.println(name+"员工被分配到了asp.net开发部门"); break; case "html": case"HTML": System.out.println(name+"员工被分配到了html开发部门"); break; default: System.out.println("对不起，本公司暂时不需要该语言的员工"); break; } } } 结果展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/990125c7e0e286cc13eac6c1cd546d9e/" rel="bookmark">
			java 超市购物程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写一个超市购物程序，在一家超市有以下商品：
牙刷（8.8元），毛巾（10.0元），水杯（18.8元），苹果（12.5元），香蕉（15.5元）。
用户通过输入商品序列号进行商品购买，用户输入购买数量后计算所需花费的钱，一次购买后，按Y继续购买，N购买结束
Test测试类 package anli01; import java.util.Scanner; public class test3 { public static void main(String[] args) { //编写5个商品数据 double toothbrush =8.8;//牙刷价格 double towel =10.0;//毛巾价格 double cup =18.8;//水杯价格 double apple =12.5;//苹果价格 double banana =15.5;//香蕉价格 //2.展示数据 System.out.println("----------黑马小商城---------"); System.out.println("1.牙刷价格是"+toothbrush+"元"); System.out.println("2.毛巾价格是"+towel+"元"); System.out.println("3.水杯价格是"+cup+"元"); System.out.println("4.苹果价格是"+apple+"元"); System.out.println("5.香蕉价格是"+banana+"元"); //3.循环接收购买数据 Scanner sc = new Scanner(System.in); String flag ="Y"; while("Y".equals(flag)){ System.out.println("请输入购买商品的序号"); int id = sc.nextInt(); //重复变量 int count=0; double money=0; switch(id){ case 1: System.out.println("请输入购买牙刷的数量"); count = sc.nextInt(); money =count*toothbrush; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/990125c7e0e286cc13eac6c1cd546d9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fd7e30943a610b5c136481be2c4df8/" rel="bookmark">
			目标检测网络中的Backbone，Neck和Head - 以YOLOv4为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目标检测网络中的Backbone，Neck和Head - 以YOLOv4为例 目标检测网络中常见到的三个概念：
Backbone：在不同图像细粒度上聚合并形成图像特征的卷积神经网络；Neck：一系列混合和组合图像特征的网络层，并将图像特征传递到预测层；Head：对图像特征进行预测，生成边界框和并预测类别； 以YOLOv4为例：
先观察YOLOv4框架：
其中，
Backbone主要是CSPDarknet53组成，其主要是由五层残差网络resblock_body组成，其输入的图像像素是608*608，其中resblock_body有专门的卷积操作来降低分辨率，每一层的resblock_body将像素逐渐降低一倍，其主要功能是提取图像数据的特征信息。Neck主要是由SPP（左下部分Conv×3到Concat+Conv×3）和PANet组成。SPP主要功能是增加感受野作用，PANet主要功能是将提取的特征信息转换为坐标、类别等信息，其主要是由上采样和下采样组成。Head继续沿袭yolov3的检测头，其三个检测头主要功能是：得到输出之后，与真实数据标注相比较，计算出损失函数（其损失函数主要是由三部分组成：①定位损失②置信度损失③分类损失），然后根据需要对数据格式进行reshape，同时对原始格点坐标做相应的激活。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d211afcd71f0424480b78927f829feb7/" rel="bookmark">
			JavaScript基础之Math、Data对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.Math对象1.1Math绝对值和三个取整方法1.2Math.random() 2.Data()日期对象2.1Date()方法的使用2.1.1获取当前时间必须实例化2.1.2`Date()`构造函数的参数 2.2日期格式化2.3获取日期的总的毫秒形式 1.Math对象 Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员
Math对象的常用属性、方法有：
&lt;script&gt; Math.PI //圆周率 Math.random() //返回一个[0,1)之间的随机数 Math.floor() //向下取整 Math.ceil() //向上取整 Math.round() //四舍五入取整 Math.abs() //取绝对值 &lt;/script&gt; 举例：
&lt;script&gt; var pi = Math.PI //PI var a = Math.floor(Math.random() * 10) //返回一个[0,10)之间的整数 var b = Math.abs(-5.5) console.log(pi, a, b); //3.141592653589793 4 5.5 &lt;/script&gt; 1.1Math绝对值和三个取整方法 Math.abs() 取绝对值Math.floor() : 向下取整Math.ceil() : 向上取整Matg.round() : 四舍五入 &lt;script&gt; //Math.abs() console.log(Math.abs(2.3)); //2.3 console.log(Math.abs(-3.1)); //3.1 //Math.floor() console.log(Math.floor(3.2)); //3 console.log(Math.floor(-3.1)); //-4 //注意负数向下取整数字变大 //Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d211afcd71f0424480b78927f829feb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e0a861ff244c39c45f11f61c4b6c13/" rel="bookmark">
			应变式传感器的原理与优点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应变式传感器是基于测量物体受力变形所产生的应变的一种传感器。电阻应变片则是其最常采用的传感元件。它是一种能将机械构件上应变的变化转换为电阻变化的传感元件。
沧正应变式压力传感器
电阻应变片一般由敏感栅、基底、引线、盖片等组成。敏感栅由直径为0.01-0.05mm、高电阻系数的细丝弯曲而成栅状，它实际上是一个电阻元件，是电阻应变片感受构件应变的敏感部分。敏感栅用粘合齐将其固定在基底上。基底的作用应保证将构件上应变准确地传递到敏感栅上去。因此它必须作得很薄，一般为0.03-0.06mm，使它能与试件及敏感栅牢固地粘结在一起。另外它还应有良好的绝缘性能、抗潮性能和耐热性能。基底材料有纸、胶膜、玻璃纤维布等。纸具有柔软、易于粘贴、应变极限大和价格低廉等优点，但耐温耐湿性差，一般工作温度低于70℃下采用。为了提高耐湿耐久性和使用温度，可浸以酚醛树脂类粘合剂使用温度可提高至180℃，且时间稳定性好，适用于测力等传感器使用。胶膜基底是由环氧树脂、酚醛树脂、聚脂树脂和聚酰亚胺等有机粘合剂制成的薄膜，胶膜基底具有比纸更好的柔性、耐湿性和耐久性，且使用温度可达100-300℃。玻璃纤维布能耐400-450℃高温，多用做中温或高温应变片基底。引出线的作用是将敏感栅电阻元件与测量电路相连接，一般由0.1-0.2mm低阻镀锡铜丝制成，并与敏感栅两输出端相焊接。
在测试时，将应变片用粘合剂牢固地粘贴在被测试件的表面上，随着试件受力变形，应变片的敏感栅也获得同样的变形，从而使其电阻随之发生变化，而此电阻变化是与试件应变成比例的，因此如果通过一定测量线路将这种电阻变化转换为电压或电流变化，然后再用显示记录仪表将其显示记录下来，就能知道被测试件应变量的大小。
应变片式压力传感器是应变式传感器的一种，其通过粘结在弹性元件上的应变片的阻值变化来测量压力值的。当被测压力传递到粘贴有电阻应变片的膜片、弹性梁或应变管后，使之产生变形，则由电阻应变片组成的电桥有不平衡电压输出，该电压与作用在压力传感器上的被测压力成正比。具有精度高、体积小、重量轻、测量范围宽、固有频率高、动态响应快等优点，同时耐振动、抗冲击性能良好。但输出信号较小，受温度影响较大。
沧正应变式压力传感器CAZF-LY10
应变式传感器具有很多优点：
1、分辨力高，能测出极微小的应变；
2、误差较小，一般小于1%；
3、尺寸小、重量轻。
4、测量范围大，从弹性变形一直可测至塑性变形（1-2%），最大可达20%；
5、既可测静态，也可测快速交变应力；
6、具有电气测量的一切优点，如测量结果便于传送、记录和处理；
7、能在各种严酷环境中工作。如从宇宙真空至数千个大气压；从接近绝对零度低温至近1000℃高温；离心加速度可达数十万个“g”；在振动、磁场、放射性、化学腐蚀等条件下，只要采取适当措施，亦能可靠地工作；
8、价格低廉、品种多样，便于选择和大量使用。如：电子秤行业中称重传感器上的应用，测力设备上的应用等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1684da461179c78d783777ac5c58ce/" rel="bookmark">
			Redis systemd 服务和 daemon no 配置的冲突问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 虚拟机安装 Reis，sudo apt install redis -y。
然后照着以前的经验修改了配置文件/etc/redis/redis.conf，关闭保护模式，设置守护线程，去掉外网访问限制：
# By default protected mode is enabled. You should disable it only if # you are sure you want clients from other hosts to connect to Redis # even if no authentication is configured, nor a specific set of interfaces # are explicitly listed using the "bind" directive. #protected-mode yes protected-mode no # By default Redis does not run as a daemon.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df1684da461179c78d783777ac5c58ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/228f0e28b3f5b52fda1346103fabf7a2/" rel="bookmark">
			Docker简介以及如何在 IDEA 中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Docker简介 1.1 什么是Docker ​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。
​
​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。
​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。
​ Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。
​ 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
1.2 为什么要用 Docker 优势
更高效的利用系统资源， 由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。更快速的启动时间， 传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。一致的运行环境， 开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。持续交付和部署， 对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。更轻松的迁移， 由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 对比传统虚拟机总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/228f0e28b3f5b52fda1346103fabf7a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4469ef1352e42c96c0f28daefbca7289/" rel="bookmark">
			Nmap的介绍、安装 并进行网络扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nmap概述 Nmap(Network Mapper(网络映射器))是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。它是网络管理员必用的软件之一，以及用以评估网络系统安全。
正如大多数被用于网络安全的工具，nmap 也是不少黑客及骇客（又称脚本小子）爱用的工具 。系统管理员可以利用nmap来探测工作环境中未经批准使用的服务器，但是黑客会利用nmap来搜集目标电脑的网络设定，从而计划攻击的方法。
Nmap包含四项基本功能：主机发现（Host Discovery）端口扫描（Port Scanning）版本侦测（Version Detection）操作系统侦测（Operating System Detection）而这四项功能之间，又存在大致的依赖关系（通常情况下的顺序关系，但特殊应用另外考虑），首先需要进行主机发现，随后确定端口状况，然后确定端口上运行具体应用程序与版本信息，然后可以进行操作系统的侦测。而在四项基本功能的基础上，Nmap提供防火墙与IDS（IntrusionDetection System,入侵检测系统）的规避技巧，可以综合应用到四个基本功能的各个阶段；另外Nmap提供强大的NSE（Nmap Scripting Language）脚本引擎功能，脚本可以对基本功能进行补充和扩展。
通常，一个简单的使用ICMP协议的ping操作可以满足一般需求；也可以深入探测UDP或者TCP端口，直至主机所 使用的操作系统；还可以将所有探测结果记录到各种格式的日志中， 供进一步分析操作。
Nmap安装 首先访问Nmap官网，获得windows对应版本的安装包。
根据提示,一直安装即可
软件主界面
可以看出其内置了很多扫描类型，支持查看多种扫描结果，UI界面比较直观
此外，还可以在linux终端内安装，更加灵活。
Nmap使用 查看linux下nmap的帮助信息。(执行命令nmpa -h)
Nmap 7.80 ( https://nmap.org )
Usage: nmap [Scan Type(s)] [Options] {target specification}
可见nmap指令的一般格式是：nmap \[扫描类型(可叠加)\] \[选项\] \[目标\]
其中目标可以有如下格式：
TARGET SPECIFICATION: Can pass hostnames, IP addresses, networks, etc. Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254 -iL &lt;inputfilename&gt;: Input from list of hosts/networks -iR &lt;num hosts&gt;: Choose random targets --exclude &lt;host1[,host2][,host3],.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4469ef1352e42c96c0f28daefbca7289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceb5d409fc29fb0389779074f5141cfa/" rel="bookmark">
			关于利用fopen函数创建文件的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数原型：FILE * fopen(const char * path,const char * mode);
相关函数：open，fclose，fopen_s，_wfopen
返回值：文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno 中。
参数说明：
参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。
mode有下列几种形态字符串:
r 以只读方式打开文件，该文件必须存在。
r+ 以可读写方式打开文件，该文件必须存在。
rb+ 读写打开一个二进制文件，允许读写数据，文件必须存在。
w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）
a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb74462f64f0bf7d2174cfb4ab4e32f/" rel="bookmark">
			Linux下安装RabbitMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下安装RabbitMQ
安装Erlang环境
安装GCC GCC-C++ Openssl等模块,安装过就不需要安装了
yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel 安装ncurses
yum -y install ncurses-devel 安装erlang环境
wget http://erlang.org/download/otp_src_18.2.1.tar.gz tar xvfz otp_src_18.2.1.tar.gz 随后移动至/usr/local/下 改名erlang：
cp -r otp_src_18.2.1 /usr/local/erlang 在 /usr/local/erlang/执行以下命令
./configure make install 安装RabbitMQ
下载rabbitmq-server-3.6.9.tar.xz
wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.9/rabbitmq-server-generic-unix-3.6.9.tar.xz 对于下载xz包进行解压，首先先下载xz压缩工具：
yum install xz 对rabbitmq包进行解压：
xz -d xz -d rabbitmq-server-generic-unix-3.6.9.tar.xz tar -xvf rabbitmq-server-generic-unix-3.6.9.tar 随后移动至/usr/local/下 改名rabbitmq：
cp -r rabbitmq_server-3.6.9 /usr/local/rabbitmq 这种下载的方式解压后直接可以使用，无需再编译安装；
进入到rabbit文件内，其命令文件存在于sbin文件夹下，因此需要将sbin文件夹的路径添加到PATH中：修改/etc/profile
export PATH=/usr/local/rabbitmq/sbin:$PATH 执行source /etc/profile使得PATH路径更新，rabbitMQ安装成功。
随后启用MQ管理方式：
到云主机服务器(腾讯云，阿里云等等)管理后台开放安全组端口
rabbitmq-plugins enable rabbitmq_management #启动后台管理 rabbitmq-server -detached #后台运行rabbitmq 设置端口号，可供外部访问：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb74462f64f0bf7d2174cfb4ab4e32f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/160/">«</a>
	<span class="pagination__item pagination__item--current">161/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/162/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>