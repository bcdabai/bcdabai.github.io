<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/830e3f0780d9376772373ce4ea2c9b8a/" rel="bookmark">
			7分钟带你细致解析4个Java算法必刷题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1] 提示：
2 &amp;lt;= nums.length &amp;lt;= 104-109 &amp;lt;= nums[i] &amp;lt;= 109-109 &amp;lt;= target &amp;lt;= 109只会存在一个有效答案 **进阶：**你可以想出一个时间复杂度小于 O(n^2) 的算法吗？
解题 1.双层循环（时间复杂度 O(n^2)）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/830e3f0780d9376772373ce4ea2c9b8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f5d4561727f9fac7fd31a6360b170ea/" rel="bookmark">
			Docker ENV 与 ARG 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Env 与 ARG 详解 Env 与ARG 差异可以用下面一张图来表示
ENV 使用说明 ENV 变量只能在容器运行时，生效
如果想在执行命令的时候，使用ENV变量需要在shell 模式下采用生效，比如我们运行spring boot 应用,
其中JAVA_OPTS 变量通过docker run -e JAVA_OPTS=xxxx imageName ，这时候我们启动容器会报错，提示识别不了“JAVA_OPTS”
FROM eclipse-temurin:17-jdk-alpine VOLUME /tmp ARG JAR_FILE=target/*.jar COPY ${JAR_FILE} app.jar ENTRYPOINT ["java","${JAVA_OPTS}","-jar","/app.jar"] 调整为
FROM eclipse-temurin:17-jdk-alpine VOLUME /tmp ARG JAR_FILE=target/*.jar COPY ${JAR_FILE} app.jar # 使用shell模式会有一个缺点，就是在shell 作为pid =1 的进程，java 执行的命令作为pid =1 的子进程。这个时候容器的生命周期就会出现问题，父进程关闭，无法通知到子进程，导致父进展kill 掉后，子进程需要一段时间才能被自动杀掉 ENTRYPOINT ["sh", "-c", "java ${JAVA_OPTS} -jar /app.jar"] 再次执行docker run -e JAVA_OPTS=xxxx imageName
补充点CMD 与 ENTRYPOINT 的知识 具体详细介绍可以查看官方文档,里面有详细的介绍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f5d4561727f9fac7fd31a6360b170ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b0aa3f4b22926478c04636910fbba7/" rel="bookmark">
			C&#43;&#43;的异常处理的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++的异常处理的方法 原因 在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：
数组下标越界除法计算时除数为0动态分配空间时空间不足… 如果不及时对这些异常进行处理，程序多数情况下都会崩溃。
解决方法 （1）try、throw和catch关键字 C++中的异常处理机制主要使用try、throw和catch三个关键字，其在程序中的用法如下：
#include &lt;iostream&gt; using namespace std; int main() { double m = 1, n = 0; try { cout &lt;&lt; "before dividing." &lt;&lt; endl; if (n == 0) throw - 1; //抛出int型异常 else if (m == 0) throw - 1.0; //拋出 double 型异常 else cout &lt;&lt; m / n &lt;&lt; endl; cout &lt;&lt; "after dividing." &lt;&lt; endl; } catch (double d) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96b0aa3f4b22926478c04636910fbba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59407add6c9c97b8f533e8cd1754b0c1/" rel="bookmark">
			Oracle [索引，视图，序列，同义词，事务，锁，数据字典]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、索引
索引分类
索引建立原则
二、视图
权限
三、序列
主键自生
四、同义词
五、事务
属性( ACID )
六、锁
七、数据字典
动态性能视图
一、索引 在查询的时候，经常被用来做为查询的字段，应该添加索引
1.用于加快数据的检索，类似于书的目录，提高查询效率，优化查询
在数据库中索引可以减少数据库程序查询结果时需要读取的数据量 = 看书通过书的目录来查找想要的内容
2.索引是建立在表上的可选对象
索引的关键在于通过一组排序后的索引键来取代默认的全表扫描检索方式 = 提高效率
3.当创建或者删除一个索引时，不会影响基本的表
4.索引一旦建立，在表上进行DML操作时，oracle会自动管理索引
（执行插入、修改、删除相关操作时）
5.索引对用户是透明的，无论表上是否有索引，sql语句的用法不变
6.oracle创建主键时会自动在该列上创建索
缺点：影响执行效率
索引分类 1. B树索引（默认索引） 保存排序过的索引列和对应的rowid值
oracle中最常用的索引
* 能够适应精确查询、模糊查询和比较查询
* 不管查询条件怎样，查询速度基本相同
* B树索引是基于二叉树结构的；叶子节点（双向链表）包含索引列和指向表中每个匹配行的ROWID值
列基数大时适合使用B数索引
列基数：列不重复值的个数
（名字=基数大 | 性别=基数小）
A表中有10条数据，查询id为8的数据，
创建索引后，那么会先判断 ID = 8
1. 属于 1-5 还是 6-10 ，
2. 进入 6-10 后，再判断输入 6 还是 7-8 还是 9-10，
3. 进入 7-8，拿到 id=8的数据。 只需要查询3次
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59407add6c9c97b8f533e8cd1754b0c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7124bf6be2fa90fdc68f526a05ea86e/" rel="bookmark">
			MySQL数据完整性实施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL提供六种约束：
1、主键约束（primary key）
2、外键约束（foreign key）
3、非空约束（not null）
4、唯一约束（unique）
5、默认约束（default）
6、检查约束（check）
主键是多个字段组成的只能定义成表级约束：primary key(字段1，字段2.......).
非空和默认约束只能设成列级。
外键约束要定义成表级：foreign key(外键) references 父表名(被参照字段）。
第一种实施数据完整性方法：在创建表时实施数据完整性。
create table 表名
( 字段名1 数据类型1 [列级完整性约束1]
[,字段名2 数据类型2 [列级完整性约束2]][,…]
[,表级完整性约束1][,…]
);
第二种实施数据完整性方法：创建完表后实施。
语法格式如下：
1、添加主键、外键、检查和唯一约束
alter table 表名 add 约束;
例：alter table 表名 add primary key(字段名);
特别的2个默认和非空：
（1）、alter table 表名 modify 字段名 数据类型 default'默认内容';
（2）、alter table 表名 modify 字段名 date not null;
2、删除主键、外键、检查和唯一约束
alter table 表名 drop 约束
例：alter table stuinfo drop foreign key;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7124bf6be2fa90fdc68f526a05ea86e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc20fc77accc9eb7cadefe549dfed7e/" rel="bookmark">
			解读%matplotlib inline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是IPython 中的一个魔法功能，可以在笔记本中呈现图形（而不是显示图形对象的转储）。 在这里可以找到一个简单的 Matplotlib 教程https://www.data-blogger.com/python-matplotlib-pyplot-a-perfect-combination/
为方便起见，我将在此处引用相关文档供您阅读：IPython 有一组预定义的“魔法函数”，您可以使用命令行样式语法调用它们。有两种魔法，面向线的和面向细胞的。行魔法以 % 字符为前缀，其工作方式与操作系统命令行调用非常相似：它们将行的其余部分作为参数获取，其中参数在不带括号或引号的情况下传递。 Lines 魔法可以返回结果，并且可以在作业的右侧使用。单元格魔法以双 %% 为前缀，它们是作为参数的函数，不仅将行的其余部分作为参数，而且将其下方的行作为单独的参数。%matplotlib inline Rich Outputs — IPython 8.6.0 documentation将 matplotlib 的后端设置为“内联”后端：使用这个后端，绘图命令的输出会在 Jupyter 笔记本等前端内联显示，直接在生成它的代码单元下方。然后，生成的图也将存储在笔记本文档中。使用“内联”后端时，您的 matplotlib 图形将包含在您的笔记本中，位于代码旁边。可能还值得阅读How to make IPython notebook matplotlib plot inline 以供参考，以了解如何在代码中使用它。如果您还想要交互性，您可以将 nbagg backend与 %matplotlib 笔记本（在 IPython 3.x 中）一起使用，如此处所述。 您可以通过输入以下命令检查可用的后端（如内联）：
%matplotlib --list 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09bca854f7db7521183b20286cc780c/" rel="bookmark">
			Hbuilder动态调试小程序与页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页面调试：
打开项目直接调试即可；也可以web设置默认打开浏览器
小程序调试：
1.需要打开微信小程序的服务端口；
设置-&gt;安全设置
2.Hbuilder 打开manifest.json，找到微信小程序，输入自己的APPID（或者直接全删除，不输入也可以热编译）；
--Appid获取 网址，注册小程序，小程序 (qq.com)
最后，打开微信开发者工具后，在Hbuilder中选择运行；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09558e0ac41f49c3a04406c74a2b948/" rel="bookmark">
			element 表格字段过长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element 表格 - 表头太长换行 解决方案一：show-overflow-tooltip Table表格，如果每列显示的内容过长则可以使用该属性，即 :show-overflow-tooltip=“true”，该属性可以让内容在一行显示，如果显示不下时，显示…,并且鼠标划过时显示全部文字。
代码如下：
&lt;el-table-column prop="attribute" label="属性" width="200" show-overflow-tooltip &gt;&lt;/el-table-column&gt; 解决方案二：使用作用域插槽 slot-scope 1、slot-scope="{ row }"可以获取到一行的信息
2、表格的内容设置一个宽度 多余的用…展示（这里使用到字符串截取）
3、使用element提供的Tooltip 文字提示或者Popover 弹出框 展示字段多的内容
el-tooltip示例 &lt;el-table-column label="订单号" width="200"&gt; &lt;div slot-scope="{ row }"&gt; &lt;div :type="row.orderNo"&gt; &lt;el-tooltip class="item" effect="dark" :content="row.orderNo" placement="top" &gt; &lt;span style="color: red"&gt; {{ row.orderNo.length &gt; 20 ? row.orderNo.substring(0, 20) + "..." : row.orderNo }}&lt;/span &gt; &lt;/el-tooltip&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-table-column&gt; el-popover示例 &lt;el-table-column label="订单号" width="200"&gt; &lt;div slot-scope="{ row }"&gt; &lt;div :type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c09558e0ac41f49c3a04406c74a2b948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0acce9b3e8260bb6b55f16852e23c4b3/" rel="bookmark">
			I2C设备注册的4种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、静态注册二、动态注册三、用户空间注册四、i2c驱动扫描注册 前言 I2C设备的4种添加方法：
1）静态注册
2）动态注册
3）用户空间注册
4）i2c驱动扫描注册
一、静态注册 静态注册就是在架构板级文件或初始化文件中添加i2c设备信息，并注册到特定位置（__i2c_board_list链表）上就可以了，如arm架构下board-xxx-yyy.c文件，x86架构下xxx-yyy-init-zzz.c文件。当系统静态注册i2c控制器（adapter）时，将会去查找这个链表，并实例化i2c设备添加到i2c总线上。注意：一定要赶在i2c控制器注册前将i2c设备信息添加到链表上。
1）定义一个 i2c_board_info 结构体
必须要有名字和设备地址，其他如中断号、私有数据非必须。
static struct i2c_board_info my_tmp75_info = { I2C_BOARD_INFO("my_tmp75", 0x48), }; @my_tmp75是设备名字，用于匹配i2c驱动。 @0x48是i2c设备的基地址。 如果有多个设备，可以定义成结构数组，一次添加多个设备信息。
2）注册设备
使用 i2c_register_board_info 函数将i2c设备信息添加到特定链表，函数原型如下
i2c_register_board_info(int busnum, struct i2c_board_info const * info, unsigned n) { devinfo-&gt;busnum = busnum; /* 组装i2c总线 */ devinfo-&gt;board_info = *info; /* 绑定设备信息 */ list_add_tail(&amp;devinfo-&gt;list, &amp;__i2c_board_list); /* 将设备信息添加进链表中 */ } @busnum：哪一条总线，也就是选择哪一个i2c控制器（adapter） @info：i2c设备信息，就是上面的结构体 @n：info中有几个设备 将在 i2c_register_adapter 函数中使用到
static int i2c_register_adapter(struct i2c_adapter *adap) { … if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num) i2c_scan_static_board_info(adap); … } static void i2c_scan_static_board_info(struct i2c_adapter *adapter) { struct i2c_devinfo *devinfo; down_read(&amp;__i2c_board_lock); list_for_each_entry(devinfo, &amp;__i2c_board_list, list) { if (devinfo-&gt;busnum == adapter-&gt;nr &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0acce9b3e8260bb6b55f16852e23c4b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a109d24aa45ca7c937412c85ca45c5/" rel="bookmark">
			VS IDE常用的小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量下方出现绿色的波浪符号是提示该变量已经定义，但还没有被使用。如果是要再次打开项目，可以在“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件打开整个项目 若debug提示有错误，在标识的那行找不到错误，往往是上条语句出错。现在的vs版本在debug时，辅助窗口不会自动关闭，如果是以前的版本往往需要添加以下两句才能持续显示辅助窗口。 cin.get(); cin.get(); 使用"/n"和endl都有换行的作用。用法为cout&lt;&lt;"/n";和cout&lt;&lt;endl;c#是用分号结束句子，因此不能漏了，挺多错误就是因为漏了个分号引起的。 IOS c++标准中，main()函数的结尾如果没有return 0;结尾语句，系统将会自动补上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d388bf6a4feb22e14962207766b31ab/" rel="bookmark">
			CDR安装包下载&#43;汉化简体中文版&#43;安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做前端程序经常会遇到要处理一些图片来做为素材，但又不好每次都叫美工来做（主要是囊中羞涩），100个不得以，凭着这些年对计算机的了解，自己动手也能做两个图出来，自我感觉还可以，哈哈哈（自己都忍不住想笑）。
第一步：下载解压后会得到一个****.exe（我以2020版本为例，名称为CDR2020.exe），点击运行它开始初始化。
第二步：等待软件初始化，初始化完成后进入下图情况，自动的生成序列号文件，然后直接点击下一步即可。
第三步：选择软件安装的类型，默认典型的即可，当然想要设置软件安装路径等信息的可以选择自定义安装。
第四步：进入自定义安装后一直点击下一步至选择软件安装路径，然后点击更改进行更改设置，确认后点击安装即可。
接下来只需要耐心的等待软件的安装，根据电脑配置不同，安装时间也不相同。 软件完成后，软件会自动的直接运行软件了，等待软件加载，然后进入软件界面，就可以使用软件的功能了 到这里就可以使用啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68931c96be2aed7a94e9307300624530/" rel="bookmark">
			【Java】构造方法及类的初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 利用构造方法给对象初始化 1. 构造方法的概念 构造方法(也称为构造器)是一个特殊的成员方法，其名字必须与类名相同，在创建对象时，由编译器自动调用，并且在整个对象的生命周期内只调用一次。
构造方法的作用就是给对象中的成员进行初始化，并不负责给对象开辟空间。
public class Date { public int year; public int month; public int day; // 构造方法： // 名字与类名相同，没有返回值类型，设置为void也不行 // 一般情况下使用public修饰 // 在创建对象时由编译器自动调用，并且在对象的生命周期内只调用一次 public Date(int year, int month, int day) { this.year = year; this.month = month; this.day = day; System.out.println("Date(int,int,int)方法被调用了"); } public void printDate() { System.out.println(year + "-" + month + "-" + day); } public static void main(String[] args) { // 此处创建了一个Date类型的对象，并没有显式调用构造方法 Date d = new Date(2021, 6, 9); // 输出Date(int,int,int)方法被调用了 d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68931c96be2aed7a94e9307300624530/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da85325485c75f7c8ad6cdc20e4c55d5/" rel="bookmark">
			execjs 调用js出现找不到windows对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装npm环境
npm install -g cnpm -registry=https://registry.npm.taobao.org
2.安装全局jsdom
npm i jsdom -g
3.js代码顶部加入：
const jsdom = require("jsdom");
const { JSDOM } = jsdom;
const dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;p&gt;Hello world&lt;/p&gt;`);
window = dom.window;
document = window.document;
XMLHttpRequest = window.XMLHttpRequest;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ace2ebf6ef82c4cafdc2dc6a3e8d1190/" rel="bookmark">
			一文看懂大数据生态圈完整知识体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着大数据行业的发展，大数据生态圈中相关的技术也在一直迭代进步，作者有幸亲身经历了国内大数据行业从零到一的发展历程，通过本文希望能够帮助大家快速构建大数据生态圈完整知识体系。
目前大数据生态圈中的核心技术总结下来如图1所示，分为以下9类，下面分别介绍。
1.数据采集技术框架
数据采集也被称为数据同步。
随着互联网、移动互联网、物联网等技术的兴起，产生了海量数据。这些数据散落在各个地方，我们需要将这些数据融合到一起，然后从这些海量数据中计算出一些有价值的内容。此时第一步需要做的是把数据采集过来。数据采集是大数据的基础，没有数据采集，何谈大数据！
数据采集技术框架包括以几种。
Flume、Logstash和FileBeat常用于日志数据实时监控采集，它们之间的细节区别见表1；
Sqoop和Datax常用于关系型数据库离线数据采集，它们之间的细节区别见表2；
Cannal和Maxwell常用于关系型数据库实时数据采集，它们之间的细节区别见表3。
表1
表2
表3
Flume、Logstash和FileBeat的技术选型如图2所示。
Sqoop和Datax之间的技术选型如图3所示。
Cannal和Maxwell之间的技术选型如图4所示。
2.数据存储技术框架
数据的快速增长推动了技术的发展，涌现出了一批优秀的、支持分布式的存储系统。 数据存储技术框架包括HDFS、HBase、Kudu、Kafka等。
HDFS它可以解决海量数据存储的问题，但是其最大的缺点是不支持单条数据的修改操作，因为它毕竟不是数据库。
HBase是一个基于HDFS的分布式NoSQL数据库。这意味着，HBase可以利用HDFS的海量数据存储能力，并支持修改操作。但HBase并不是关系型数据库，所以它无法支持传统的SQL语法。
Kudu是介于HDFS和HBase之间的技术组件，既支持数据修改，也支持基于SQL的数据分析功能；目前Kudu的定位比较尴尬，属于一个折中的方案，在实际工作中应用有限。
Kafka常用于海量数据的临时缓冲存储，对外提供高吞吐量的读写能力。
3分布式资源管理框架
在传统的IT领域中，企业的服务器资源（内存、CPU等）是有限的，也是固定的。但是，服务器的应用场景却是灵活多变的。例如，今天临时上线了一个系统，需要占用几台服务器；过了几天，需要把这个系统下线，把这几台服务器清理出来。
在大数据时代到来之前，服务器资源的变更对应的是系统的上线和下线，这些变动是有限的。
随着大数据时代的到来，临时任务的需求量大增，这些任务往往需要大量的服务器资源。
如果此时还依赖运维人员人工对接服务器资源的变更，显然是不现实的。
因此，分布式资源管理系统应运而生，常见的包括YARN、Kubernetes和Mesos，它们的典型应用领域如图5所示。
4.数据计算技术框架
数据计算分为离线数据计算和实时数据计算。 （1）离线数据计算
大数据中的离线数据计算引擎经过十几年的发展，到目前为止主要发生了3次大的变更。
MapReduce可以称得上是大数据行业的第一代离线数据计算引擎，主要用于解决大规模数据集的分布式并行计算。MapReduce计算引擎的核心思想是，将计算逻辑抽象成Map和Reduce两个阶段进行处理。
Tez计算引擎在大数据技术生态圈中的存在感较弱，实际工作中很少会单独使用Tez去开发计算程序。
Spark最大的特点就是内存计算：任务执行阶段的中间结果全部被放在内存中，不需要读写磁盘，极大地提高了数据的计算性能。Spark提供了大量高阶函数（也可以称之为算子），可以实现各种复杂逻辑的迭代计算，非常适合应用在海量数据的快速且复杂计算需求中。
（2）实时数据计算
业内最典型的实时数据计算场景是天猫“双十一”的数据大屏。
数据大屏中展现的成交总金额、订单总量等数据指标，都是实时计算出来的。
用户购买商品后，商品的金额就会被实时增加到数据大屏中的成交总金额中。
用于实时数据计算的工具主要有以下3种。
Storm主要用于实现实时数据分布式计算。
Flink属于新一代实时数据分布式计算引擎，其计算性能和生态圈都优于Storm。
Spark中的SparkStreaming组件也可以提供基于秒级别的实时数据分布式计算功能。
Spark Streaming和Storm、Flink之间的区别见表4。
表4
Storm、Spark、Flink 之间的技术选型如图6所示。
目前企业中离线计算主要使用Spark，实时计算主要使用Flink。
5.数据分析技术框架
数据分析技术框架包括Hive、Impala、Kylin、Clickhouse、Druid、Doris等，它们的典型应用场景如图7所示。
Hive、Impala和Kylin属于典型的离线OLAP数据分析引擎，主要应用在离线数据分析领域，它们之间的区别见表5。
Hive的执行效率一般，但是稳定性极高；
Impala基于内存可以提供优秀的执行效率，但是稳定性一般；
Kylin通过预计算可以提供PB级别数据毫秒级响应。
表5
Clickhouse、Druid和Drois属于典型的实时OLAP数据分析引擎，主要应用在实时数据分析领域，它们之间的区别见表6。
Druid和Doris是可以支持高并发的，ClickHouse的并发能力有限；Druid中的SQL支持是有限的，ClickHouse支持非标准SQL，Doris支持标准SQL，对SQL支持比较好。
Druid和ClickHouse的成熟程度目前相对比较高，Doris处于快速发展阶段。
表6
6.任务调度技术框架
任务调度技术框架包括Azkaban、Oozie、DolphinScheduler等。 它们适用于普通定时执行的例行化任务，以及包含复杂依赖关系的多级任务进行调度，支持分布式，保证调度系统的性能和稳定性，它们之间的区别见表7。 表7
它们之前的技术选型如图8所示。
7.大数据底层基础技术框架
大数据底层基础技术框架主要是指Zookeeper。 Zookeepe主要提供常用的基础功能（例如：命名空间、配置服务等），大数据生态圈中的Hadoop（HA）、HBase、Kafka等技术组件的运行都会用到Zookeeper。 8.数据检索技术框架
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ace2ebf6ef82c4cafdc2dc6a3e8d1190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c56bfe48a6cd5ec4d24a32dbb5140f/" rel="bookmark">
			Redis面试题总结（2022最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐶 程序猿周周
⌨️ 短视频小厂BUG攻城狮
🤺 如果文章对你有帮助，记得关注、点赞、收藏，一键三连哦，你的支持将成为我最大的动力
本文是《后端面试小册子》系列的第 2️⃣ 篇文章，该系列将整理和梳理笔者作为 Java 后端程序猿在日常工作以及面试中遇到的实际问题，通过这些问题的系统学习，也帮助笔者顺利拿到阿里、字节、华为、快手等多个大厂 Offer，也祝愿大家能够早日斩获自己心仪的 Offer。
PS：《后端面试小册子》已整理成册，目前共十三章节，总计约二十万字，欢迎👏🏻关注公众号【程序猿周周】获取电子版和更多学习资料（最新系列文章也会在此陆续更新）。公众号后台可以回复关键词「电⼦书」可获得这份面试小册子。文中所有内容都会在 Github 开源，项目地址 csnotes，如文中存在错误，欢迎指出。如果觉得文章还对你有所帮助，赶紧点个免费的 star 支持一下吧！
标题地址MySQL数据库面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/122910606Redis面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/122934938计算机网络面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/122973684操作系统面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/122994599Linux面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/122994862Spring面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/123016872Java基础面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/123080189Java集合面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/123171501Java并发面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/123266624Java虚拟机面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/123412605Java异常面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/123462676设计模式面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/123490442Dubbo面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/123538243Netty面试题总结（2022版）https://blog.csdn.net/adminpd/article/details/123564362 文章目录 在这里插入图片描述 1 基本概念1.1 常见考点1、Redis 为何这么快？2、为何使用单线程？3、缓存三大问题以及解决方案？4、先删后写还是先写后删？5、如何保证 Redis 的高并发？6、Redis 如何保证原子性？7、有哪些应用场景？ 1.2 常用命令1、Redis 有哪些常用操作？ 1.3 数据结构1、Redis 有哪些数据结构？2、String 类型的底层实现？3、说说 SDS 带来的好处？4、Redis 实现的链表有哪些特性？5、Redis 是如何实现字典的？6、什么是渐近式 rehash？7、有序集合 Zset 的底层实现？8、Zset 为何不使用红黑树等平衡树？9、什么是 Redis 的 intset？10、说说什么是压缩列表？11、什么是 RedisObject？12、五种类型分别对于哪种实现？ 1.4 数据存储1、Redis 的数据过期策略是什么？2、持久化文件对过期策略的处理？3、Redis 有哪些内存淘汰机制？4、Redis 有哪些持久化机制？5、说说 Redis 的 RDB？6、说说 Redis 的 AOF？7、RDB 和 AOF 该如何选择？ 1.5 Pipeline1、什么是 Redis 的 Pipeline？2、原生批命令 (mset, mget) 与 Pipeline 区别?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97c56bfe48a6cd5ec4d24a32dbb5140f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83cb6df3886b49dad600ce35c4a9cf6/" rel="bookmark">
			再学JavaScript ES(6-11)全版本语法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 再学JavaScript ES(6-11)全版本语法大全 学习介绍:
代码少、速度快、效率高，带你感受ES版本进化所带来的“爽、快”之感
关于ES新版本,看看这些知识点,就知道课程的细节多么用心
ECMAScript2016~2020
(ES7~11)
课程介绍 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb754d98e1a60d04dca2ac7db3d8cd7/" rel="bookmark">
			sparrow search algorithm（麻雀搜索算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jiankai Xue &amp; Bo Shen (2020) A novel swarm intelligence optimization approach: sparrow search algorithm, Systems Science &amp; Control Engineering, 8:1, 22-34, DOI:10.1080/21642583.2019.1708830
文章目录 一、 介绍二、Sparrow Search Algorithm1、生物特征2、数学模型与算法 一、 介绍 提示：这里可以添加本文要记录的大概内容：
优化问题在背包问题、数据聚类、数据分类、路径规划、机器人控制等工程应用中都很常见。
群优化算法（swarm intelligence）算法作为解决全局优化问题的主要技术：在搜索过程中引入了随机性。
而确定性算法在复杂情况下容易陷入局部最优解。
ACO（蚁群优化算法）的缺点：搜索速度慢
PSO（粒子群优化算法）的缺点：容易过早收敛
SSA（麻雀搜索算法）的灵感来源：麻雀群体的觅食和反捕食行为
提示：以下是本篇文章正文内容，下面案例可供参考
二、Sparrow Search Algorithm 1、生物特征 麻雀分为生产者和蹭食者。研究表明，个体监控着群体中其他人的行为。 同时，鸟群中的攻击者为了提高自身的捕食率，利用高摄入量来竞争同伴的食物资源。个体的能量储备在麻雀选择不同的觅食策略时可能起着重要作用，能量储备低的麻雀觅食更多。于种群外围的鸟类更容易受到捕食者的攻击，并不断尝试获得更好的位置。位于中心的动物可能会靠近邻伴，以尽量减少它们的危险领域。所有的麻雀都表现出对一切事物好奇的天生本能，同时它们总是保持警惕。 2、数学模型与算法 为了将麻雀行为理想化，制定了相应的规则：
1. 生产者通常拥有高水平的能量储备，并为所有觅食者提供觅食区域或方向。 它负责确定可以找到丰富食物来源的地区。 能量储备的水平取决于对个体适应值的评估。
2. 一旦麻雀发现了捕食者，个体就开始鸣叫作为警告信号。 当告警值大于安全阈值时，生产者需要引导所有乞讨者到安全区域。
3. 每只麻雀只要寻找到更好的食物来源，都可以成为生产者，但生产者和乞讨者在整个种群中的比例保持不变。
4. 能量较高的麻雀作为生产者，几个饥饿的乞讨者更有可能飞到其他地方觅食以获得更多的能量。
5. 乞讨者会跟随提供最好食物的生产者来寻找食物，同时，一些蹭食者会不断监视生产者并且竞争食物以提高自己的捕食率。
6. 当意识到危险时，在群体边缘的麻雀将会迅速移动到安全的地方以获得更好的位置，而在群体中间的麻雀将会随机移动以靠近其他麻雀。
麻雀的位置用下面的矩阵表示：
其中n是麻雀的数量，d表示要优化的变量的维数。 然后，所有麻雀的适应度值可以用下面的向量表示：
在SSA中，适应值较好的生产者在搜索过程中有获得食物的优先权。 此外，因为生产者负责搜寻食物和引导整个人口的流动。 因此，生产者可以比蹭食者在更广泛的地方寻找食物。
每次迭代期间，生产者的位置更新如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb754d98e1a60d04dca2ac7db3d8cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757e26715319aaf80269efa269c04ff9/" rel="bookmark">
			关于浮点数的精度丢失问题的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于浮点数的精度丢失问题的思考 一 浮点数精度丢失的原因二 精度丢失的深入提问三 浮点数精度问题的深入思考1. 浮点数的表示2. 计算机对浮点数的处理步骤3. 浮点数的存储（1）存储步骤讲解（2）指数偏移量（3）实际演示 四 float与double的范围和精度范围精度 五 解决方法 在实际编程中，我遇到了一些蛮有意思的情况，就是浮点型变量初始化是不精确的，但这个不精确数却是固定不变的？另外，为什么float和double的表示范围如此与众不同？
一 浮点数精度丢失的原因 浮点型表示单精度、双精度和扩展精度值。 C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。 通常， float 以一个字（32比特）来表示，
double 以2个字（64比特）来表示，
long double 以3或4个字（96或128比特）来表示。
一般来说，类型 float 和 double 分别有7和16个有效位；类型 long double 则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。（ 《C++ Primer第五版》 ）
由以上描述，我们不难知道，对于 float 来说，最多只有7个有效位，这也就意味着，当实际存储的精度大于 float 的精度范围时，就会出现精度丢失现象。
二 精度丢失的深入提问 问题在于，所谓的有效位很让人迷惑，我明明占了那么多位置（float占4个字节double占8字节），为什么有效位只有6个？为什么整数位越多，精度越小？
三 浮点数精度问题的深入思考 1. 浮点数的表示 依据IEEE754二进制浮点数算术标准，一个浮点数可以表示为v = s * e * f（即符号位乘以指数偏移值再乘以分数值）
2. 计算机对浮点数的处理步骤 将浮点数转化成二进制用二进制科学计数法表示表示成IEEE 754格式
其中在第一步和第三步中出现了精度丢失的情况 有了以上了解，我们就可以更好地理解浮点数的存储
3. 浮点数的存储 （1）存储步骤讲解 ①第一步
②第二步
③第三步
④一些特殊规定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/757e26715319aaf80269efa269c04ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f6e5c70bdfe8b4e6bc16c157d36edc/" rel="bookmark">
			（详解）opencv里的cv2.resize改变图片大小Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cv2.resize函数结构： image = cv2.resize(src, dsize, dst=None, fx=None, fy=None, interpolation=None) 功能： cv2.resize函数将图像src的大小调整为指定大小。
cv2.resize函数详解： src：源图像
dst：目标图像。dst图像与src图像的类型相同。
dsize：目标图像的大小。当dsize不是（0，0）时，输出图像（image）的大小为dsize的大小。
例如：
img = cv2.imread('02.png') shape = img.shape print(shape) # (467, 892, 3) img_2 = cv2.resize(img, dsize=(500, 500), dst=None, fx=2, fy=2, interpolation=cv2.INTER_NEAREST) print(img_2.shape) # (500, 500, 3) 这个时候不论fx、fy等于多少，输出图片的大小都是（500，500）
当dsize是（0，0）时或dsize=None，输出图像（image）的大小可以通过如下式子计算：
dsize = Size(round(fx*src.cols), round(fy*src.rows))
例如：
img = cv2.imread('02.png') shape = img.shape print(shape) # (467, 892, 3) img_2 = cv2.resize(img, dsize=None, dst=None, fx=2, fy=1, interpolation=cv2.INTER_NEAREST) print(img_2.shape) # (467, 1784, 3) fx ：水平轴上的比例因子。即是图像的行的大小乘以2，这里为892*2=1784
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f6e5c70bdfe8b4e6bc16c157d36edc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c21120681a5723c976b9842967d695ed/" rel="bookmark">
			SpringMVC跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转发：
1：添加成功跳转到成功页面，给出提示，失败跳转到失败页面 ---- jsp
2：添加成功后，跳转到查询的controller中 -- 另外一个程序，添加完成之后，执行查询所有的操作，跳转到所有的用户列表
3：在查询的controller中是否能够获取第一个controller中传递的参数
重定向：
1：添加成功之后重定向到页面，失败后也是定向到失败页面
2：使用重定向，跳转到controller中的其他方法
3：重定向跳转到第二个controller中，获取参数
1：转发到页面 注意：springmvc默认使用的就是转发技术，
完整的写法是：return “forward:/xx.jsp”; / - 指的是web目录，一层一层往下查找，注意：此时不走springmvc的试图解析器。
如果希望返回时走试图解析器的话，直接写一个简单的字符串即可，如：return “hello”;此时就会做视图的拼接。
2：转发到controller 转发到其他的方法：
完整的写法为： return “forward:/类上的路径/方法上的路径.do”; 这个是通用的。
如果调用方法和目标方法在同一个类中，则可以简化写法：return “方法上的路径.do”;
需求：添加一个用户信息，添加完成之后，访问查询
所有的方法，并且将刚刚添加的用户信息，添加到所有
用户信息的集合中，展示在页面上。
查询所有用户信息不接受参数。
3：转发携带参数 可以使用request对象来传递参数
2：重定向 1：重定向到页面 语法 ： return “redirect:/xxx.jsp”
注意：重定向也需要 /
需求：用户登录错误之后重定向到登录页面
2：重定向到controller return “redirect:/类上的requestMapping / 方法上的requestMapping ”
需求：登录成功之后，重定向到另外一个controller中的查询所有用户的方法，返回所有用户的列表
3：重定向携带参数问题 1：可以使用url的拼接, 在url后面通过？name=value的方式进行拼接
2：使用session传递具体的值, 在一个方法内存储在session的内容，可以在另外一个方法中获取
3：使用redirectAttributes 这个接口，在接受方法参数的前面要使用@ModelAttribute("key")来接受
3：springmvc两种跳转方式总结 转发：
转发到页面：return “forward:/具体的页面.jsp”; 如果配置了视图解析器的话同时页面也在指定的位置，return “视图名称”;
转发到方法：return “forward:/类上的路径/方法上的路径.do”, 如果目标方法是在一个类中的，可以直接写方法上的路径，return “queryUsers.do”;
参数携带：request,sesssion
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c21120681a5723c976b9842967d695ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a26a5b2c61f68d8e8e5326600ebab7/" rel="bookmark">
			酒店管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Word下载链接如下：
https://download.csdn.net/download/yw1990128/87096359
一 设计背景
1.1 课题现状 随着国家社会经济水平的提升，各酒店的发展速度越来越快，入住人员也越来越多。酒店房间的管理要求也愈来愈大，所以很多酒店正面对着前所未有的机会与挑战，怎样运用适应企业发展要求的各种技术手段来提升酒店的运营、管理水平、服务质量已成为当前酒店改革发展的关键问题。
衡南县茉莉阳光酒店有限公司成立于2020年，目前公司员工二十多人其中酒店房间经理一名。随着公司规模还在不断扩大，对客房信息系统的管理要求也愈来愈多，管理难度也愈来愈大，原来的管理方法也已无法适应管理者的实际需求，因此迫切需要一些全新的管理手段，来实现对酒店客房有关信息进行系统管理，时至今日一个全新的客房管理方法对茉莉阳光酒店房间管理人员而言，已必不可少。近几年来计算机的发展十分迅速，虽然计算机在系统管理方面的使用已经非常成熟，但是由于当前茉莉阳光房间信息的管理方式还停留在传统人工管理的水平上，这显然不符合当今时代的变迁，所以管理人员们当下殷切需要一种方便快捷、计算机化的管理系统，来取代他们庞杂、低效的传统手工管理方式，从而最终达到对客房管理的全部智能化，通过计算机化的后台管系统理则能够有效规范对房间数量和房间类型的管理，降低茉莉阳光房间的运营成本，从而提升了工作效率。
1.2 课题意义 目前市场上的相关系统已经不少了，但大都还没有完成，而利用计算机技术对酒店房间管理系统来说也算是个比较新型的管理系统方法，但随着社会经济的日益发达，人们逐渐察觉到计算机技术对各公司的管理系统与管理方法有非常大实用价值；随着酒店行业的日益发展壮大，酒店房间的信息也越来越多，而房间后台的管理工作也已不容忽视，因此迫切需要一些新型的技术手段，来实现对酒店房间的相关信息进行集中的系统管理。
本课题的主要工作是针对茉莉阳光酒店传统人工管理所带来的弊端，而开发的管理系统，该系统将为茉莉阳光酒店的管理带来十分可观的经济效益和社会效益。主要体现在：极大的提高了管理人员和工作人员的工作效率，不仅能够减少大量的人力成本，更能精确的制定房间规划，增加房间的利用率，更大程度避免了空房长期无人住的情况，使酒店管理变得正规、方便快捷、检索迅速、效率高等，这些功能会对酒店管理效率带来质的飞跃。因此，为了让茉莉阳光酒店更好的发展开发这套管理系统不可或缺。
二 开发环境及技术构架 2.1 开发环境与工具 茉莉阳光酒店管理系统是JSP技术，MySQL数据库，基于Spring Boot框架开发而成。系统所用的系统开发环境如下表2-1所示。
表2-1系统开发环境
环境
版本
IDEA
IDEA-2019.3
MySQL
MySQL-8.0
JDK
JDK-8.0
Tomcat
Tomcat-8.0
Layui
Layui-2.6.8
下面对本系统所选用的技术进行简单的介绍：
（1）前后端分离技术
本系统茉莉阳光酒店管理系统选取的是HTML技术来进行前端页面的开发。
2.2 技术架构 本酒店管理系统基于B/S模式设计，采用Spring Boot框架进行开发。
三 需求分析 3.1 功能需求 本系统是基于茉莉阳光酒店的真实管理方面需求而设计开发的一个企业型管理系统。主要内容包括：管理员登录、前台网页、后台管理系统功能。前台网页包含供客户浏览酒店信息等功能；后台管理系统包含酒店信息、酒店优点、酒店分店等功能。
3.1.1前台网页
前台网页是为了客户能在浏览器上浏览酒店信息的网页，整个网页的设计初衷也是为了提高客户体验而设计的，其主要实现功能为:
客户可以在计算机上，浏览酒店前台网页。客户可浏览本酒店概况信息。客户可浏览本酒店优点信息。客户可浏览本酒店分店信息。客户可浏览本酒店餐饮信息。 3.1.2后台管理系统
后台管理系统是对酒店所有信息进行集中管理的一个操作系统，让拥有权限的管理员能够对网站的所有信息进行修改、更新和删除，其主要功能如下:
管理员可登录茉莉阳光酒店后台管理系统。管理员可对茉莉阳光酒店信息进行删除、修改、添加。管理员可对茉莉阳光酒店优点信息进行删除、修改、添加。管理员可对茉莉阳光酒店分店信息进行删除、修改、添加。管理员可对茉莉阳光酒店餐饮信息进行删除、修改、添加。管理员可对茉莉阳光酒店房间类别信息进行删除、修改、添加。管理员可对茉莉阳光酒店房间信息进行删除、修改、添加。 3.2 性能要求 本系统有以下几个性能要求：
（1）响应时间：用户在系统中执行的95％的操作必须在5秒内响应，在管理员执行增加删除等操作时，数据库响应时间要求在2秒之内。于数据库提取的数据应准确无误且有相对应的格式，数据处理时间低于2秒。
（2）错误率：页面的DOM元素需要在5秒内全部加载完成，并且需要能支持不同的浏览器正常运行，如IE、火狐、360、谷歌等浏览器；
四 系统设计 4.1 系统功能总体设计 通过对茉莉阳光酒店管理系统的考察与需求分析，我们可以得出本系统的结构图如图4-1所示。
图4-1系统结构图
4.2 系统详细设计 4.2.1开发流程 进行开发流程时，进行需求分析，选择数据库，系统功能模块设计。然后进行开发。本系统的开发流程如图4-2所示。
图4-2系统开发流程图
4.2.2管理员登录流程 为了安全，要使用系统必须先进行登录，密码错误就无法登录，密码正确才能进行相关操作。本系统登录流程图如图4-3所示。
图4-3系统登录流程图
4.2.3后台管理系统操作流程 管理员进入后台系统后可在后台页面进行数据修改，本后台管理系统操作流程如图4-4所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27a26a5b2c61f68d8e8e5326600ebab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc69fe2a0565442ac235b6e8d433bcb3/" rel="bookmark">
			PyQt5基础知识大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyQT与Opencv结合的案例
Python 小白从零开始 PyQt5 项目实战（8）汇总篇（完整例程）
PyQt：桌面程序设计的饕餮盛宴
快速掌握PyQt5
个人QT学习笔记（部分重点内容）
生成透明ICO 制作.ico透明图标
在线生成透明ICO图标
设置窗口背景 （1）使用QSS设置窗口背景
#设置对象名称 win.setObjectName("MainWindow") #todo 1 设置窗口背景图片 win.setStyleSheet("#MainWindow{border-image:url(./images/python.jpg);}") #todo 2 设置窗口背景色 #win.setStyleSheet("#MainWindow{background-color: yellow}") （2）使用QPalette设置窗口背景
当使用QPalette（调试板）来设置背景图片时，需要考虑背景图片的尺寸
当背景图片的宽度高度大于窗口的宽度高度时，背景图片会平铺整个背景
当背景图片宽度高度小于窗口的宽度高度时，则会加载多个背景图片
palette = QPalette() palette.setBrush(QPalette.Background, QBrush(QPixmap("./images/python.jpg"))) win.setPalette(palette) # todo 1 当背景图片的宽度和高度大于窗口的宽度和高度时 # win.resize(460, 255 ) # # todo 2 当背景图片的宽度和高度小于窗口的宽度和高度时 # win.resize(800, 600) （3）实现PainEvent，使用QPainter绘制背景
def paintEvent(self, event): painter = QPainter(self) #todo 1 设置背景颜色 painter.setBrush(Qt.green) painter.drawRect(self.rect()) # #todo 2 设置背景图片，平铺到整个窗口，随着窗口改变而改变 # pixmap = QPixmap("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc69fe2a0565442ac235b6e8d433bcb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496038b482248d5e52fe34a7d578bcb3/" rel="bookmark">
			大数据—Hadoop（二十二）_ 生产调优手册_05、MapReduce
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、MapReduce跑的慢的原因2、MapReduce常用调优参数2.1 Map端2.2 Reduce端 3、MapReduce数据倾斜问题3.1 现象3.2 减少数据倾斜的方法 1、MapReduce跑的慢的原因 检查计算机性能
CPU
内存
磁盘
网络
I/O操作优化
数据倾斜
Map运行时间太长，导致Reduce等待过久
小文件过多
2、MapReduce常用调优参数 2.1 Map端 1. 自定义分区，减少数据倾斜
自定义分区时，使用随机数拼上key，就会把Map端的数据打散到不同的Reducer中去
2. 减少溢写次数
a、调大环形缓冲区大小
mapreduce.task.io.sort.mb
默认100M
可以提高到200M
b、调大环形缓冲区溢写阈值
mapreduce.map.sort.spill.percent
默认80%
可以提高到90%
3. 增加merge一次合并文件个数
mapreduce.task.io.sort.factor
内存充足情况下可以提高到20
4. 在不影响业务条件的情况下，提取预聚合
job.setCombinerClass(xxxReducer.class)
5. 减少磁盘IO，采取Snappy和LZO压缩
conf.setBoolean(“mapreduce.map.output.compress”,true);
conf.setClass(“mapreduce.map.output.compress.codec”,SnappyCodec.class,ComparessionCodec.class);
6. 调大MapTask内存
默认情况下，MapTask内存上限是1G，1G处理128M的数据绰绰有余的，但如果MapTask处理的是不可切分的压缩数据，则需要按照1G内存处理128M数据的比值做相应调整
mapreduce.map.memory.mb
7. 调大MapTask内存后，同时要调整MapTask堆内存大小
将MapTask堆内存大小调整成和MapTask内存一致，否则会OOM
mapreduce.map.java.opts
8. 如果是计算密集型任务，需要增大CPU核数
默认1核，如果是涉及到复杂的加减乘除运算，需要适当增加CPU核数
mapreduce.map.cpu.vcores
9. 异常重试
默认4次，如果服务器较差，跑任务经常失败，可以适当调大重试次数
mapreduce.map.maxattempts
2.2 Reduce端 1、每个Reduce端拉取数据的并行度
默认是5，可以提高到10
mapreduce.reduce.shuffle.parallelcopies
2、内存使用量占ReduceTask总内存的百分比
拉取后的数据首先会放在内存中，默认内存大小占ReduceTask总内存的70%，可以适当调大到80%
mapreduce.reduce.shuffle.input.buffer.percent
3、内存达到使用量比的比例达到多少时才开始写入磁盘
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496038b482248d5e52fe34a7d578bcb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d39aa6eb3153544dc7901283131a138/" rel="bookmark">
			python 使用 with open() as 读写文件的操作方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读文件: 要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：
1
&gt;&gt;&gt; f = open('E:\python\python\test.txt', 'r')
标示符'r'表示读，这样，我们就成功地打开了一个文件。
如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：
1
2
3
4
f=open('E:\python\python\notfound.txt', 'r')
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
FileNotFoundError: [Errno 2] No such file or directory: 'E:\python\python\notfound.txt'
如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：
1
2
&gt;&gt;&gt; f.read()
'Hello, python!
最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：
1
&gt;&gt;&gt; f.close()
由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：
1
2
3
4
5
6
try:
f = open('/path/', 'r')
print(f.read())
finally:
if f:
f.close()
每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：
1
2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d39aa6eb3153544dc7901283131a138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44cc0e7f6e166a768f06b93c4cfb6501/" rel="bookmark">
			Ubuntu22.04 Zabbix6.0 替换国内阿里云源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我这里系统是Ubuntu22.04 Jammy ；Zabbix版本6.0
1；替换 /etc/apt/sources.list.d/zabbix.list 内容
cat &gt; /etc/apt/sources.list.d/zabbix.list &lt;&lt; EOF deb https://mirrors.aliyun.com/zabbix/zabbix/6.0/ubuntu jammy main deb-src https://mirrors.aliyun.com/zabbix/zabbix/6.0/ubuntu jammy main EOF 2；添加 key
curl -o - "https://mirrors.aliyun.com/zabbix/zabbix-official-repo.key" | apt-key add - 记得apt update 更新下
然后就可以快速的下载zabbix软件包了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ac0d2d0cdb0f6e58ecb9964165817e/" rel="bookmark">
			移动魔百盒UNT413A卡刷固件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		魔百盒unt413A-s905L3-卡刷固件
固件说明：
1、魔百盒unt413A-s905L3-当贝桌面-卡刷固件 ，不适用高安版本，不是所有地区都适用，请慎 重使用； 2、优化系统，去除限制安装限制，解 除 原厂wifi连接 限 制，纯净系统；
3、支持原装遥控器，支持蓝牙； 4、固件压缩包有刷机教程，请一定仔细阅读。 补充：目前发现UNT413A有两款芯片，S905L3A和S905L3，区分方法：初步判断是看设备型号，设置关于里面，结尾gd2是L3 ，gd是L3A，当然拆机看是最准的。 打开a d b方法：
打开a d b
盒子开机状态下，
用遥控进入设置界面，
随后按键盘上的F 1和 F 2按键来回按 弹出原生android桌面 打开AdbConsole 在打开的界面点击 开启。 这样即可开启a d b
若无法打开，请参考 九联 打开a d b的方法进行测试。 步骤： 见底部
刷机包获取：
【最新】魔百盒M401A、UNT403A、UNT413A _S905L3A_卡刷及线刷通刷合集
教程：把3个文件复制到U盘插到机顶盒，按着盒子复位键开机5秒后放开 链接1: https://pan.baidu.com/s/1qSmtBgSEbKs6ZFm-yCr-XQ
提取码: nnw3
链接2：https://wwt.lanzoux.com/b021zs97i
提取码：509a
声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4db4ae70d08850275de8f33be7ba031/" rel="bookmark">
			C语言修仙大法！基础知识全复习（纯干货）！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		▓ 数据类型： 常量：常量包括字面常量、直接常量和符号常量；
变量：C语言规定标志符只能由字母、数字和下划线三种字符组成，且第一个字符必须是字母或者下划线；必须压迫先定义后使用；每一个变量被定义以确定类型后，在编译时就能为其分配相应的存储单元；
整数类型：整数常量有十进制、八进制和十六进制；“%d”
整形变量：数据在内存中存放形式是以二进制形式存放；有int型、short int型和long int型，无符号整型变量的范围是0~65535，有符号型为-32768—32767.通常把long定义为32位，把short定义为16位，int可以是32位也可以为16位，这都主要取决于机器字长。
实型常量的表示方法：（1）十进制，0.0；（2）指数形式，123e3
实型变量：实数型数据在内存中的存放形式，一般在内存中占4个字节，分成整数部分和小数部分存放。实型变量分为float型、double型long double型。实型数据会存在舍入误差。
实型常量的类型：C编译系统将实型常量作为双精度来处理。
字符型数组：
（一）字符常量：转义字符（\n——换行，\t——tab,\r——回车，\f——换页，\b——退格，\ddd——1到3位8进制的数代表的字符）
（二）字符变量：字符数据存储形式实际是以ASCII码存储。“%c”
字符串常量：双撇号括起来的一系列字符序列。
▓ C的运算符有以下几种： 1、算术运算符（+ - * / %）结合方向自左向右
2、关系运算符（&gt; &lt; ==""&gt;= &lt;= !=""&gt;
3、逻辑运算符(! &amp;&amp; ||)
4、位运算符(&lt;&gt;&gt; ~ | ^ &amp;)
5、赋值运算符(=及符号扩展赋值运算符)
6、条件运算符(? : )
7、逗号运算符( , )
8、指针运算符（* &amp;）
9、求字节运算符（sizeof）
10、强制类型转换运算符((类型))
11、分量运算符( . -&gt;)
12、下标运算符([])
13、其他
▓ 控制语句： 完成一定的控制功能。
1、if()~else~
2、for()~
3、while()~
4、do~while()
5、continue
6、break
7、switch
8、goto
9、return
字符数据的输入输出：
1、putchar（）输入字符变量
2、getchar（）只能接受一个字符
格式输入输出：
1、printf（%d—整型，%c—字符型，%ld，%md，%o，%u，%s，%-m.nf，%e，%g）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4db4ae70d08850275de8f33be7ba031/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef8e228de85473141d9188c4536a172/" rel="bookmark">
			An attempt was made to call a method that does not exist. The attempt was made from the following
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description: An attempt was made to call a method that does not exist. The attempt was made from the following location: com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor.&lt;clinit&gt;(PaginationInnerInterceptor.java:70) The following method did not exist: net.sf.jsqlparser.schema.Column.withColumnName(Ljava/lang/String;)Lnet/sf/jsqlparser/schema/Column; The method's class, net.sf.jsqlparser.schema.Column, is available from the following locations: jar:file:/E:/apache-maven-3.8.1-bin/localMaven3.8.1/com/github/jsqlparser/jsqlparser/3.2/jsqlparser-3.2.jar!/net/sf/jsqlparser/schema/Column.class The class hierarchy was loaded from the following locations: net.sf.jsqlparser.schema.Column: file:/E:/apache-maven-3.8.1-bin/localMaven3.8.1/com/github/jsqlparser/jsqlparser/3.2/jsqlparser-3.2.jar net.sf.jsqlparser.parser.ASTNodeAccessImpl: file:/E:/apache-maven-3.8.1-bin/localMaven3.8.1/com/github/jsqlparser/jsqlparser/3.2/jsqlparser-3.2.jar Action: Correct the classpath of your application so that it contains a single, compatible version of net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef8e228de85473141d9188c4536a172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d051b31e96d711228956009cb681f91/" rel="bookmark">
			conda和pip查看、配置源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 conda查看、配置源pip查看、配置源 conda查看、配置源 国内conda源
源地址清华大学conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
阿里云conda config --add channels https://mirrors.aliyun.com/pypi/simple/中国科技大学conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/豆瓣conda config --add channels http://pypi.douban.com/simple/ 查看当前conda源
conda config --show channels
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d051b31e96d711228956009cb681f91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a392592ee7c8690d9258aed62e89077/" rel="bookmark">
			搭建一个基于 Markdown的文档编辑框架 - vue3 - vuepress （中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3-vuepress 搭建一个基于 Markdown的文档编辑框架 - vue3 - vuepress （中）
gitee:vue3-vuepress
基础配置 1.系统的配置文件 docs &gt; .vuepress &gt; config.ts
import { defineUserConfig, defaultTheme } from 'vuepress' export default { lang: 'zh-CN', title: 'VuePress ！', description: '加载失败', theme: defaultTheme({ // 主题设置 logo: '/nm.png', repo: 'https://github.com/bobo456123/VuepressDoc.git', repoLabel: 'GitHub', navbar: require('./config/nav'), sidebar: require('./config/sidebar'), editLink: false, editLinkText: '编辑此页', editLinkPattern: '', sidebarDepth: 2, lastUpdated: true, lastUpdatedText: '更新时间', contributors: false, contributorsText: '贡献者', notFound: [ '这里什么都没有', '我们怎么到这来了？', '这是一个 404 页面', '看起来我们进入了错误的链接', ], backToHome: '返回首页', // a11y openInNewWindow: '在新窗口打开', toggleDarkMode: '切换夜间模式', toggleSidebar: '切换侧边栏', }), } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a392592ee7c8690d9258aed62e89077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e0e80edf3a3a35ba8e7fec26842985/" rel="bookmark">
			【C语言】常用占位符的总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%d------整型
%f------浮点数
输入%lf输出%f------高精度浮点数（比较特殊）
%s------字符串
%c------字符
%p------指针
%e------科学计数法
%g------小数或科学计数法
更加全面：
%d 整型int
%ld 长整型long
%lld 长长整型long long （int）
%hd 短整型short int
%u 无符号整型unsigned int
%hu 无符号短整型unsigned short int
%lu 无符号长整形unsigned long int
%llu 无符号长长整型unsigned long long
%f 浮点型float
输入%lf，输出%f 高精度浮点型double
%e（E) 以指数形式表示的浮点型
%m.nf 可控制输出小数位数
%c 字符型char
%s 字符串
%o 以八进制输出
%x 以16进制输出
%p 变量地址
%i 结构体输出
部分转载于https://blog.csdn.net/x18037177724/article/details/126511314
如何控制输出的格式%m.nf
%02d 右对齐输出，位数不够补0；
%2d右对齐输出，位数不够补/0；
%.2f输出两位小数，左对齐输出，位数不够自动补0；
（这里不含有四舍五入，只有保留位数，想要四舍五入也很简单，先乘以10^(n-1)然后加0.5强制转化就行了）
我们来实操一下：你觉得这样会输出什么？
#include &lt;stdio.h&gt; int main() { printf("%09d\n",2345); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12e0e80edf3a3a35ba8e7fec26842985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7325d1f72f6d8a97dc4da2b61e5dd355/" rel="bookmark">
			pytorch下载太慢的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 （欢迎大家关注我的公众号“机器学习面试基地”，之后将在公众号上持续记录本人从非科班转到算法路上的学习心得、笔经面经、心得体会。未来的重点也会主要放在机器学习面试上！）
—————————————————————————————————————
正文 （点进这里，就默认了你已经安装好了anaconda,并且知道去pytorch官网找安装代码了，然后遇到了安装太慢、进度不变、多次中断的情况，这时候通常的做法，是添加清华源镜像的下载路径。但是肯定会有人和我一样，路径改了也不好使啊！！！）（补充一下镜像源方案吧！）
一、清华镜像源方案 该方案就是将官网的下载路径，改到清华镜像源的路径，先用activate激活自己之前创建的环境后，在命令行输入以下代码：
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 然后再去pytorch官网复制下载代码，记得删掉后面的-c pytorch,因为它表示从官网进行下载，不从清华镜像源下。
二、手机方案 1、本地端安装 关掉wifi，手机开个4G热点，电脑连上即可
（建议先把wifi可以快速下载的附加包下载完，下载过慢或者无法下载的方法再用手机流量来下）手机流量少的慎用！！！！！！！！！！！！！！！！！！
2、服务器端安装 这个时候如果关掉wifi，就和服务器断开了。这时候建议先用4G下载好离线安装包，然后连上服务器把安装包拷到服务器上，将安装包采用离线安装的方式。
本方法同时适用于很多下载过慢的软件
三、离线方案 去清华镜像源本地下载
（linux版本）https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/linux-64/?C=M&amp;O=A或https://anaconda.org/pytorch/pytorch/files?version=1.3.0
（windows版）https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/win-64/?C=M&amp;O=A
离线安装代码：conda install --offline pytorch-1.3.0-py3.6_cuda9.2.148_cudnn7.6.3_0.tar.bz2
别忘了后面的bz2安装代码也得根据自己下载的版本来修改！offline 后面那一串都是下载的文件名，我这里示意的是linux版本的，win10版的得看你自己下载好的文件名是什么离线安装时，记得用cd命令把当前目录改到下载的离线文件所在目录torchvision也要单独安装：conda install --offline torchvision-0.4.1-py36_cu92.tar.bz2 容易出错的点：
离线安装好后，还是需要重新利用conda来在线安装一次，要用它来对相关的包来进行在线匹配(也就是根据安装好的pytorch来匹配那些对应的好多库，不是说再下载一遍pytorch)。但是一定要注意了!!!在利用官网代码时conda install pytorch torchvision cudatoolkit=9.2 -c pytorch一定要删掉后面的-c pytorch，因为它代表直接从官网去下载，不会与本地安装好的匹配，还会全部重新下载。所以改成：conda install pytorch torchvision cudatoolkit=9.2它就会自动匹配之前离线安装好的东西，然后匹配相关的库的等级、版本之类的
不匹配相关库的等级的话，就会出现以下类似错误：libcudart.so.9.2: cannot open shared object file: No such file or directory 出现这个的原因是我之前，装tensorflow时的cuda对应的是10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7325d1f72f6d8a97dc4da2b61e5dd355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b01bf04ca14feeca181969faedf9f7/" rel="bookmark">
			JVM 内存溢出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		• 堆内存溢出
– 堆内存中存在大量对象，这些对象都有被引用，当所有对象占用空间达到堆内存的最大值，
就会出现内存溢出OutOfMemory:Java heap space
• 永久代溢出
– 类的一些信息，如类名、访问修饰符、字段描述、方法描述等，所占空间大于永久代最大
值，就会出现OutOfMemoryError:PermGen space
两种内存溢出
1、堆内存溢出：本质原因是代码有问题，创建对象不合理，需要优化代码
2、元空间溢出（永久代溢出）：本质原因是项目的元空间分配太小了，需要加大元空间的初始值和最大值
Jvm常见参数及建议值
• -Xms2048m，初始堆大小，建议&lt;物理内存的1/4，默认值为物理内存的1/64
• -Xmx2048m，最大堆大小，建议与-Xms保持一致，默认值为物理内存的1/4
• -Xmn512m，新生代大小，建议不超过堆内存的1/2
• -Xss1024k,线程堆栈大小，建议256k
• -XX:PermSize=256m，永久代初始值，默认值为物理内存的1/64
• -XX:MaxPermSize=256m，永久代最大值，默认值为物理内存的1/4
• -XX:SurvivorRatio=8：年轻带中Eden区和Survivor区的比例，默认为8:1，即Eden（8），
From Space（1），ToSpace（1）
• -XX:+UseConcMarkSweepGC：开启CMS垃圾回收器
内存泄露的现象内存泄露有什么现象？
1，tps出现大幅波动，并慢慢降低，甚至降为0，响应时间随之波动，慢慢升高
2，通过jstat命令看到，Jvm中Old区不断增加，FullGC非常频繁，对应的FullGC消耗的时间也不
断增加
3，通过jconsole/jvisualvm可以看到，堆内存曲线不断上升，接近上限时，变成一条直线
4，日志报错java.lang.OutOfMemoryError: Java heap space
内存泄露怎么定位？
1，通过jmap命令：jmap -histo pid | head -20，查看当前堆内存中实例数和占用内存最多的前20
个对象
2，通过jvisualvm，进行远程堆dump，然后把dump文件下载下来，用jvisualvm打开进行分析，可
以看到更直观的jvm中对象的信息
Jmap分析结果
[C ：代表的是Char[]
[I ：代表的是Int[]
[B ：代表的是Byte[]
排查策略：
从上往下
1、找跟业务类有关的对象（一般是以com/cn开头）
2、或者第三方框架相关的对象（一般是以org*）
3、凡是以java*都可以忽略，都属于java底层对象
4、找到某些怀疑的类后，找开发一起看代码，看看代码中哪些地方创建了这个类
在什么样的场景下监控内存泄露问题？
1，在试压阶段，或任意场景都可以考虑通过jvisualvm和jstat监控jvm的情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b01bf04ca14feeca181969faedf9f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5706bd56321e7af27f355815e1508ce4/" rel="bookmark">
			docker集成jenkins、harbor搭建简易cicd平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker集成jenkins、harbor搭建简易cicd平台实现应用发布|回滚 默认已部署docker服务，关闭防火墙
软件默认安装在/opt目录下，docker容器映射目录为/opt/docker/xxx
服务器环境 服务器系统ip说明发布服务器centos7.3192.168.10.10部署docker、 jenkins、harbor应用服务器centos7.3192.168.10.12部署docker 发布服务器部署harbor 部署docker容器看板，方便查看容器 docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name portainer portainer/portainer 访问地址 http://192.168.10.10:9000/
部署docker-compose #1.下载 wget https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-linux-x86_64 #2.安装 chmod +x docker-compose-linux-x86_64 mv docker-compose-linux-x86_64 /usr/bin/docker-compose #3.查看 docker-compose version 部署harbor 配置流程如下:
修改harbor.yml执行./prepare 生成 docker-compose.yml (每次自行都会覆盖)修改docker-compose.yml自定义容器docker-compose 启动容器 #1.harbor离线部署文件获取 wget https://github.com/goharbor/harbor/releases/download/v2.4.1/harbor-offline-installer-v2.4.1.tgz #2.解压 tar xf harbor-offline-installer-v2.4.1.tgz -C /opt #3.进入解压目录 cd /opt/harbor #4.拷贝配置文件 cp harbor.yml.tmpl harbor.yml #5.修改配置 vim harbor.yml # The IP address or hostname to access admin UI and registry service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5706bd56321e7af27f355815e1508ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f5da87ff192da21792e07527014149/" rel="bookmark">
			使用python中的turtle库绘制常见图形（三角形、正方形、五边形、六边形、圆、同心圆、边切圆、奥运五环）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用python中的turtle库绘制常见图形
前言 本文主要介绍一些python的turtle库中绘制常见图形的方法，如三角形、正方形、五边形、圆。还有奥运五环、同心圆、边切圆、蟒蛇等图形的画法。
若有不对的地方欢迎大家指正
一、三角形、正方形、五边形、六边形的绘制 由于以上图形都是正多边形，所以每个图形中的旋转角度都是相同的，则在代码中使用的for循环来实现正多边形的实现。
源代码：
import turtle turtle.setup(1000,450,200,200)#画布的大小及位置 turtle.penup()#抬起画笔 turtle.fd(-400)#移动画笔，也可使用turtle.goto(x,y)让画笔移动到相应的坐标 turtle.seth(90)#改变画笔的朝向，让画笔方向从起始方向开始，逆时针旋转90度 turtle.fd(100) turtle.seth(0)#让画笔方向变为起始方向 turtle.pendown()#落下画笔 turtle.pensize(10)#调正画笔的粗细 #三角形 turtle.color("purple") for i in range (3): turtle.fd(100) turtle.seth(-120 * (i+1)) #正方形 turtle.penup() turtle.fd(200) turtle.pendown() turtle.color("blue") for i in range (4): turtle.fd(100) turtle.seth(-90 * (i+1)) #正五边形 turtle.penup() turtle.fd(200) turtle.pendown() turtle.color("red") for i in range (5): turtle.fd(100) turtle.seth(-72 * (i+1)) #正六边形 turtle.penup() turtle.fd(250) turtle.pendown() turtle.color("green") for i in range (6): turtle.fd(100) turtle.seth(-60 * (i+1)) turtle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80f5da87ff192da21792e07527014149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e574e4fa81aa663d3a2f0a6358830c9/" rel="bookmark">
			《剑指offer》专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 基础知识 面试题3：数组中重复的数字 https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/
class Solution { public int findRepeatNumber(int[] nums) { Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 1; i++) { if (nums[i] == nums[i + 1]) { return nums[i]; } } return Integer.MAX_VALUE; } } 面试题4：二维数组中的查找 https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/
class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix.length &lt; 1 || matrix[0].length &lt; 1) { return false; } int i = 0; int j = matrix[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e574e4fa81aa663d3a2f0a6358830c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf410fa1271bfaa2cf1f731b95bfbc67/" rel="bookmark">
			UE4基础学习笔记———零碎知识04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的设置：世界场景设置、项目设置、编辑器偏好设置。 2.允许选择半透明。半透明对象选择性开关。（快捷键T）
可扩展性。这里的调整只针对编辑器本身，不是调整游戏质量的。
3.实时音效。不想通过播放来听音效时进行的设置。
4.利用场景组合对象直接新建出蓝图类,无需新建蓝图类，再在里面重新搭建组合。关卡蓝图相当于场景总控，蓝图类只控制类中对象。
5.直接点击"构建"会将整个场景进行构建（构建：计算光照，使光照更加细腻）。
编译反射采集效果变化：
构建LOD（LOD：Lowlevel of Detials），例如场景拉远，远处的树木变小，模糊，消失，减轻计算机负担的效果。
仅构建光照：只想看光照阴影状态时选择 -》仅构建光照。
6.模拟。在类游戏状态下仍可编辑物体的模式。
7.几何体。
注意基础体和几何体的区别。基础体只能简单变换，几何体对象可以通过几何体编辑进行编辑。（Shift+B选中几何体所有面）
它在大纲视图中的类型为Brush。
几何体编辑模式即可对几何体的点、边、面进行简单编辑。
几何体对象的缩放：不能直接用r进行缩放，会产生贴图形变。应该从几何体编辑模式下的细节面板中的xyz进行调节。
几何体细节面板中的Brush Setting的Brush Type可以设置 布尔运算。下图为相减。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7c10df6077a20471bfa105cc32dd0e/" rel="bookmark">
			【服务器】无法进行ssh连接的问题逐一排查以及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、检查服务器网络 先检查是否是网络的问题。按快捷键Win+R，在弹出的对话框中输入cmd。
点击确定运行。在cmd窗口输入ping一下服务器的ip地址。
如果出现请求超时，解决办法如下：
在服务器端输入ifconfig命令，查看要连接的网络的状态。如果服务器网卡正常，可能是连接时输入的ip地址错误，在xshell客户端输入正确的ip重新连接即可；否则就要重新配置网卡。
二、 检查端口是否开启 如果ip地址可以ping通，就要排查端口问题。在cmd窗口中，用telnet命令进行测试。
1. 如果显示连接失败，可能是端口未开，需要在服务器上查看端口信息。 netstat -ntlp|grep 22 2. 输入命令后，如果没有22端口的信息，就需要开放端口号。执行以下命令后再使用xshell重新连接服务器。 三、 检查SSH服务 ps -le|grep ssh 上图表示SSH服务已开启。如果没有启动，则需要执行命令“service ssh start”启动服务，然后重连服务器。
四、查看运行状态并启动ssh服务时报错 查看ssh运行状态：
systemctl status sshd.service 发现服务未启动，尝试使用命令
/etc/init.d/sshd start 启动服务，结果失败
使用命令journalctl -xe查看失败的具体原因，发现：
sshd: /lib/libcrypto.so.10: version `OPENSSL_1.0.2’ not found (required by sshd)
此时执行：
cp /usr/lib64/libcrypto.so.10 /usr/lib 最后重启ssh即可
1. 无法loading libgcc_s.so.1的问题 再次报错：
rpm: error while loading shared libraries: libgcc_s.so.1: cannot open
shared object file: No such file or directory
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b7c10df6077a20471bfa105cc32dd0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fc3acd1d12f0b50a1c342cdf9fcd61c/" rel="bookmark">
			Git切换分支（创建本地分支，远程分支，合并分支代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建本地分支
git branch develop 2.本地切换到新创建的分支 对应的远程分支也会切换
git checkout develop 3.查看当前所在分支
git branch 4.删除本地分支（先切换其他分支）（删除本地dev分支）
git branch -D dev 5.创建远程分支
develop git push origin develop:develop 6.删除远程分支
git push origin --delete develop 7.提交代码
git add . git commit -m "..." git push origin develop 8.分支合并
想合并develop到master 先进入master （可以先git status看看是否有冲突）
git checkout master git merge develop git push git status 9.Git查看代码仓库远程分支
git branch -r 10.Git 查看本地和远程分支：(颜色区分，标红的是远程分支)
git branch -a 11.Git 克隆代码
git clone + 项目地址 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fc3acd1d12f0b50a1c342cdf9fcd61c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a288ad2c9c7daf58b930ff155ee66b0/" rel="bookmark">
			开发工具：git 提交时过滤不必要的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是 ABin-阿斌：写一生代码，创一世佳话，筑一览芳华。如果小伙伴们觉得不错就一键三连吧~
前言 有时候我们在 IDEA 中 git 提交时会出现一些不必要的文件让我们提交，那么这个时候我们如何避免这些文件被 git 识别到，请看下方解决方案。 问题 比如这个提交，会有很多的这种：Maven_xxx.xml 的文件，每一次提交 git 都会识别到这些文件
解决方案 点击这个选项的时候我们 IDEA 会自动展示我们隐藏起来的文件，常见的比如：.idea 文件
解决上面提交时出现批量 maven.xml，我们只需要在这个配置项中 把这个 .iml 后缀的文件过滤掉即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd87c9c018365fb12e09b62e9a4740f3/" rel="bookmark">
			linux下golang环境安装教程（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下golang环境安装教程（学习笔记） SSH远程登录linux服务器 安装 mercurial包 [root@localhost ~]# yum install mercurial
安装git包 [root@localhost ~]# yum install git
安装gcc【一般自带安装好了的】 [root@localhost ~]# yum install gcc
下载安装包 https://golang.google.cn/dl/
记得选择linux版本的 开始捣鼓 将下载好的安装包放在如下路径然后解压 [root@localhost ~]# cd /usr/local/
[root@localhost local]# tar -zxvf go1.18.linux-amd64.tar.gz
建立Go的工作空间（workspace，也就是GOPATH环境变量指向的目录） src — 里面每一个子目录，就是一个包。包内是Go的源码文件
pkg — 编译后生成的，包的目标文件
bin — 生成的可执行文件
这里，我们在/home目录下, 建立一个名为go(可以不是go, 任意名字都可以)的文件夹，
然后再建立三个子文件夹(子文件夹名必须为src、pkg、bin)。
[root@localhost local]# cd /home/
[root@localhost home]# mkdir go
[root@localhost home]# cd go/
[root@localhost go]# mkdir bin
[root@localhost go]# mkdir src
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd87c9c018365fb12e09b62e9a4740f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29449294ac1d83e392cab135965435ec/" rel="bookmark">
			51单片机定时器扫描按键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时器扫描按键 定时器每隔20毫秒扫描一次按键 问题：在之前写的按键检测函数中，要在按键按下后用Delay函数进行软件消抖，还要用while(P3_1==0)来判断是否松手，如果长期不松手，则CPU会 卡在该死循环里，不能执行其他代码，造成某些功能代码失效，这次用定时器扫描按键的方法解决该问题
key.c函数
#include &lt;REGX52.H&gt; unsigned char key_keyNumber; /** * @brief按键检测，之前要在按键按下后用Delay函数进行软件消抖，还要用while(P3_1==0)来判断是否松手，如果长期不松手，则CPU会	卡在该死循环里，不能执行其他代码 * @param无 * @retval返回被按下按键的值 */ unsigned char Key_GetState() { unsigned char keynum = 0; if(P3_1==0){keynum=1;}	//一有按键被按下，标志位keynum立即置位并返回，给key_loop函数处理 if(P3_0==0){keynum=2;} if(P3_2==0){keynum=3;} if(P3_3==0){keynum=4;} return keynum; } /** * @brief用于返回按键标志位，main函数中调用 * @param无 * @retval按键标志位 */ unsigned char key_return() { unsigned char temp = 0; temp = key_keyNumber; key_keyNumber = 0; return temp; } /** * @brief每隔20毫秒执行一次该函数，对按键状态进行扫描 * @param无 * @retval无 */ void key_loop() { static unsigned char before_state,now_state; before_state = now_state; now_state = Key_GetState();	//获取按键标志位 /*1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29449294ac1d83e392cab135965435ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76299f1dd1ec373dd03cee3fe8b7e45/" rel="bookmark">
			0-1背包详解与java实现(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0-1背包详解与算法实现(上) 仅以此记录我的学习过程
文章目录 0-1背包详解与算法实现(上)01背包问题描述概念与数学模型例子与求解 动态规划法Java实现 01背包问题描述 概念与数学模型 给定n种物品与1背包，物品 i 的重量为 w i w_{i} wi​，其价值为 v i v_{i} vi​，背包的容量为C，问如何选择物品，使得装入背包后总价值最大？
数学模型：
m a x ∑ i = 1 n v i x i max\sum_{i=1}^nv_ix_i max∑i=1n​vi​xi​
{ ∑ i = 1 n v i x i ≤ C x i ∈ { 0 , 1 } , 1 ≤ i ≤ n \left\{ \begin{aligned} \sum_{i=1}^nv_ix_i\le C \\ x_i \in \{0,1\},1\le i \le n \\ \end{aligned} \right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f76299f1dd1ec373dd03cee3fe8b7e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c4132073a09eda89234f4a264d23d81/" rel="bookmark">
			solidworks 装配体缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.装备体另存为零件格式
2.插入--特征--缩放比例，选择原点，模型全选
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95de08395f51f6825ef32ddbb249f7b0/" rel="bookmark">
			C语言之分支结构语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、C语言语句分类 1）表达式语句
2）函数调用语句
3）控制语句
4）复合语句
5）空语句
控制语句用于控制程序的执行流程，以实现程序的各种结构方式，它们由特定的语句定义符组成，C语言有九种控制语句。控制语句可分成以下三类
1）条件判断语句也叫分支语句：if语句、switch语句；
2）循环执行语句：do while语句、while语句、for语句；
3）转向语句：break语句、goto语句、continue语句、return语句。
2、分支结构之简单if语句 简单的if-else语句的基本结构，语义是如果表达式的值为真，则执行代码块1，否则执行代码块2。
注意：
1）一对 { } 就是一个代码块。
2）适当的使用{}可以使代码的逻辑更加清楚。
3）代码风格很重要。
4）左侧为常量，右侧为变量，代码的书写风格更好。
5）else的匹配，else是和它离的最近的if匹配的。
6）if()后面没有分号，直接写{}，else后面也没有分号，直接写{}。
例
int num = 1;
if (5 == num)
//= 赋值；== 判断相等
//左侧为常量，右侧为变量，不能因为少些等号 =，而把num赋值给5
//适当的使用{}代码的书写风格更好
{
printf("hello world\n");
}
3、分支结构之多重if-else语句 C语言中多重if-else语句，语义是：依次判断表达式的值，当出现某个值为真时，则执行对应代码块，否则执行代码块n。
注意：
1）当某一条件为真的时候，则不会向下执行该分支结构的其他语句。
2）存在优先级的差异，从上到下优先级由高到低。
4、分支结构之嵌套if-else语句 C语言中嵌套if-else语句。嵌套if-else语句的意思，就是在if-else语句中，再写if-else语句。
5、分支结构之switch语句 switch语句也是一种分支语句。常常用于多分支的情况。
switch语句时还应注意以下几点：
1）在case后的各常量表达式的值不能相同，否则会出现错误。
2）在case子句后如果没有break;会一直往后执行一直到遇到break;才会跳出switch语句。编程好习惯在最后一个case语句的后面加上一条 break语句。
3）break语句的实际效果是把语句列表划分为不同的分支部分。
4）switch后面的表达式语句只能是整型或者字符类型。
5）在case后，允许有多个语句，可以不用{}括起来。
6）各case和default子句的先后顺序可以变动，而不会影响程序执行结果。
7）default子句可以省略不用。
break语句的实际效果是把语句列表划分为不同的分支部分。
如果表达的值与所有的case标签的值都不匹配怎么办？
其实也没什么，结果就是所有的语句都被跳过而已。程序并不会终止，也不会报错，因为这种情况在C中并不认为是个错误。
但是，如果你并不想忽略不匹配所有标签的表达式的值时该怎么办呢？
可以在语句列表中增加一条default子句。
把标签default：; 写在任何一个case标签可以出现的位置。
当switch表达式的值并不匹配所有case标签的值时，这个default子句后面的语句就会执行。所以，每个switch语句中只能出现一条default子句。但是它可以出现在语句列表的任何位置，而且语句流会像执行一个case标签一样执行default子句。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cc4a7d4ca532c5f7d2c6e49b86e3aae/" rel="bookmark">
			JUC学习笔记——并发工具线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本系列内容中我们会对JUC做一个系统的学习，本片将会介绍JUC的并发工具线程池
我们会分为以下几部分进行介绍：
线程池介绍自定义线程池模式之Worker ThreadJDK线程池Tomcat线程池Fork/Join 线程池介绍 我们在这一小节简单介绍一下线程池
线程池简介 首先我们先来介绍线程池的产生背景：
在最开始我们对应每一个任务，都会创建一个线程，但该方法极度耗费资源后来我们就产生了线程池，在线程池中规定存放指定数目的线程，由线程池的指定系统来控制接受任务以及处理任务的规定 我们给出一张线程池基本图：
自定义线程池 我们在这一小节根据线程池基本图来自定义一个线程池
自定义拒绝策略接口 我们先来介绍一下拒绝策略接口：
我们定义该接口是为了处理线程池中暂时无法接收的数据的内容我们可以在该接口的抽象方法中重新定义各种处理方法，实现多种方法处理我们直接定义一个接口，里面只有一个方法，后续我们可以采用Lambda表达式或者方法来调用 我们给出拒绝策略接口代码：
// 拒绝策略 // 这里采用T来代表接收任务类型，可能是Runnable类型也可能是其他类型线程 // 这里的reject就是抽象方法，我们后续直接采用Lambda表达式重新构造即可 // BlockingQueue是阻塞队列，我们在后续创建；task是任务，我们直接传入即可 @FunctionalInterface interface RejectPolicy&lt;T&gt;{ void reject(BlockingQueue&lt;T&gt; queue,T task); } 自定义任务队列 我们来介绍一下任务队列：
我们的任务队列从根本上来说就是由队列组成的里面会存放我们需要完成的任务，同时我们需要设置相关参数以及方法完成线程对任务的调取以及结束任务 我们给出任务队列代码：
class BlockingQueue&lt;T&gt;{ //阻塞队列，存放任务 private Deque&lt;T&gt; queue = new ArrayDeque&lt;&gt;(); //队列的最大容量 private int capacity; //锁 private ReentrantLock lock = new ReentrantLock(); //生产者条件变量 private Condition fullWaitSet = lock.newCondition(); //消费者条件变量 private Condition emptyWaitSet = lock.newCondition(); //构造方法 public BlockingQueue(int capacity) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cc4a7d4ca532c5f7d2c6e49b86e3aae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ee9fcc861962c5ec91f7132ad63b78/" rel="bookmark">
			C&#43;&#43;-CMake命令：list
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、命令格式 list (subcommand &lt;list&gt; [args...])
subcommand为具体的列表操作子命令，例如读取、查找、修改、排序等。&lt;list&gt;为待操作的列表变量，[args...]为对列表变量操作需要使用的参数表，不同的子命令对应的参数也不一致。 list命令即对列表的一系列操作，cmake中的列表变量是用分号;分隔的一组字符串，创建列表可以使用set命令（参考set命令），例如：set (var a b c d)创建了一个列表 "a;b;c;d"，而set (var "a b c d")则是只创建了一个变量"a c c d"。list命令的具体格式根据子命令不同会有所区别。
二、命令解析 对列表的操作分为读取、查找、修改、排序等4个大类，下面按照这四个大类逐一对列表的子命令进行介绍。
Cmake命令之list介绍 - 简书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e8b01a8a0caf9f148b94c8427cef49/" rel="bookmark">
			off-by-one (b00ks)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 个人简略记录，过程不详细
gdb开始调试
vmmap查看程序基地址为 0x555555400000
继续运行，输入auth
search hollk关键字，auth存放的地址可以找出为：0x555555602040 圈起来的是溢出的 \x00
创建两个books
因为图书的结构体指针存放在off_202010中，所以存放的地址为
0x555555400000 + 0x202010 = 0x555555602010 0x555555602010存放的是地址：0x0000555555602060 ，这里存放着两个book的地址
book1: 0x0000555555603770 book2：0x00005555556037a0
如果此时随便打印任意一个图书，当展示auth时，会将book1的地址(book1_addr)打印出来
book存储的结构如下
book_id book_name book_desc 得到book2的name与desc相对于book1_addr的偏移为：
book2_name - book1_addr = 0x559512b164a8 - 0x559512b16470 = 0x38 book2_desc - book1_addr = 0x559512b164b0 - 0x559512b16470 = 0x40 然后再次修改auth_name，会导致book1_addr由 0x0000559512b16470 变为 0x0000559512b16400 而改变后的地址在book1_desc中，即这种情况：
然后打印book2_name和book2_desc的地址
当申请的内存空间比较大时，空间将由mmap进行分配，而mmap分配的内存与libc的基地址存在一个固定的偏移，也就是说我们拿分配的地址-固定偏移量，就可以得到libc基地址
然后调试计算与libc基址的偏移，然后算 __malloc_hook 或者 __free_hook 和one_gadget
然后利用fake_book与book2向同一地址写入__malloc_hook 或者 __free_hook 与one_gadget获取shell
exp
from pwn import * #from LibcSearcher import LibcSearcher context(os='linux', arch='i386', log_level='debug') context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60e8b01a8a0caf9f148b94c8427cef49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ed2f735bb7608290630c70eeea86ef/" rel="bookmark">
			递归及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归： 定义：一个函数自己调用自己 满足条件： 递归必须得有一个明确的中止条件该函数所处理的数据规模必须在递减这个转化必须是可解的 循环和递归 ​ 递归：①易于理解 ②速度慢 ③存储空间大
​ 循环：①不易理解 ②速度快 ③存储空间小
递归的引用： 树和森林就是以递归的方法定义的树和图的很多算法都是以递归来实现很多数学公式就是以递归的方式定义的斐波那契数列：1 1 2 3 5 8 13…… 找出数组中最大值： Java public static int getMax(int []array){ return process(array,0,array.length-1); } //array[L...R]范围求最大值 public static int process(int []array,int L,int R){ if(L==R){ return array[L]; } int middle = L + (R - L) &gt;&gt; 1//求中电，位运算比除法来的更快 int leftMax = process(array,L,middle); int rightMax = process(array,R,middle); return Math.max(leftMax,rightMax); } 等差求和： C语言： #include &lt;stdio.h&gt; int f(int n); int main() { int n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5ed2f735bb7608290630c70eeea86ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58424ad39ad82c968244e9822c0e2ad5/" rel="bookmark">
			音视频开发面试题集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是 2022.06 月音视频面试题集锦内容的节选：
一、如何根据 NALU 裸流数据来判断其是 H.264 编码还是 H.265 编码？ 1）通常我们不是根据 NALU 裸流数据中的信息来选择解码器，而是根据媒体封装层的信息来确定解码器。 媒体封装层是表示媒体数据是什么封装格式的，比如 MP4、FLV。在这层信息里，通常会携带码流编码格式的信息。
拿 MP4 来说，我们可以根据 Sample Description Box(moov/trak/mdia/minf/stbl/stsd) 中的信息来确定其封装的码流的编码格式。
对于 FLV，我们可以根据 VideoTagHeader 中的 CodecID 等信息来确定其封装的码流的编码格式。
这样的好处是效率比较高，解封装的时候就可以确定选择何种解码器了。
2）怎么识别 NALU 裸流数据的编码格式是 H.264 还是 H.265？ 但是，如果出现题目中的情况，没有对码流进行封装，而是直接传输码流时，这时候 NALU 中有什么字段能标识自己的编码格式吗？答案是，没有这样明确的字段能标识码流的编码格式。
但是这个问题也不是不能解决，因为 H.264、H.265 码流本身也是遵循一定格式规范的，我们可以按照它的格式规范进行探测，如果能解析出来正确的信息，那也可以确定它的编码格式。
比如，拿 H.265 来说，FFmpeg 中 hevcdec.c 就有对其码流数据进行探测的函数 hevc_probe(…)。
所以，我们可以按照编码格式规范探测，比如 H.265 如果解析出了 pps、sps、vps 的各字段信息符合规范，就认为它是 H.265 的编码；如果不是，在你们的码流格式范围中就只剩 H.264 了；接下来将码流数据交给对应的解码器解码即可。
【学习地址】：FFmpeg/WebRTC/RTMP/NDK/Android音视频流媒体高级开发
【文章福利】：免费领取更多音视频学习资料包、大厂面试题、技术视频和学习路线图，资料包括（C/C++，Linux，FFmpeg webRTC rtmp hls rtsp ffplay srs 等等）有需要的可以点击1079654574加群领取哦~
二、为什么视频会议用 UDP？如果用 TCP 实现音视频，需要建立几次连接？用 UDP 实现音视频，有什么方法可以保证通话质量？ 1）为什么视频会议用 UDP？ 视频会议场景最重要的体验指标一般是『通话延时』和『语音音质』两方面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58424ad39ad82c968244e9822c0e2ad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e192c52b4b717b617a6c149caec850/" rel="bookmark">
			uni-app混合开发中的链接跳转navigateTo、reLaunch、redirectTo、switchTab区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.navigateTo 保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面。
要注意的是navigateTo只能跳转的应用内非 tabBar 的页面的路径 , 路径后可以带参数；如果跳转url参数为tabBar的路径则无法进行跳转
2.redirectTo 关闭当前页面，跳转到应用内的某个页面。
需要跳转的应用内非 tabBar 的页面的路径，路径后可以带参数
3.reLaunch 关闭所有页面，打开到应用内的某个页面。
需要跳转的应用内页面路径 , 路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 'path?key=value&amp;key2=value2'，与redirectTo不同的是如果跳转的页面路径是 tabBar 页面则不能带参数
4.switchTab 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。
需要跳转的 tabBar 页面的路径，路径后不能带参数
注：tabBar 页面为需在 pages.json 的 tabBar 字段定义的页面
详见官网：uni.navigateTo(OBJECT) | uni-app官网 (dcloud.net.cn)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306a29778897c53f3509c60ca0f95c57/" rel="bookmark">
			firewalld防火墙简单理解总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 防火墙基于源 IP、目标端口和协议来过滤入站包。因为这种方式中，仅有几个 IP/端口/协议的组合与系统交互，而其它的方式做不到过滤。
iptables 将包通过一系列的规则进行检查，如果包与特定的 IP/端口/协议的组合匹配，规则就会被应用到这个包上，以决定包是被通过、拒绝或丢弃。
firewalld和iptables service 之间最本质的不同是：
1、FirewallD 使用区域和服务而不是链式规则。
2、它动态管理规则集，允许更新规则而不破坏现有会话和连接。
iptables在 /etc/sysconfig/iptables 中储存配置,而 firewalld将配置储存在 /usr/lib/firewalld/（不建议修改，后续升级会覆盖该区域） 和 /etc/firewalld/ （这些文件将会覆盖默认配置）中的各种XML文件里. iptables每一个单独更改意味着清除所有旧有的规则并/etc/sysconfig/iptables里读取所有新的规则,然而使用 firewalld却不会再创建任何新的规 则;仅仅运行规则中的不同之处。 因此,firewalld可以在运行时间内,改变设置而不丢失现行连接。 一、firewalld的设计流程 firewalld 可以通过定义的源 IP 和/或网络接口将入站流量分类到不同区域（zone）。每个区域基于指定的准则按自己配置去通过或拒绝包。
注释：firewalld 通过使用服务名而不是它的端口和协议去指定服务，使它更易于使用，例如，是使用 samba 而不是使用 UDP 端口 137 和 138 和 TCP 端口 139 和 445。它进一步简化语法，消除了 iptables 中对语句顺序的依赖。
二、处理优先级 我们知道每个zone就是一套规则集，但是有那么多zone，对于一个具体的请求来说应该使用哪个zone（哪套规则）来处理呢？这个问题至关重要，如果这点不弄明白其他的都是空中楼阁，即使规则设置的再好，不知道怎样用、在哪里用也不行。
对于一个接受到的请求具体使用哪个zone，firewalld是通过三种方法来判断的：
1、source，也就是源地址 优先级最高
2、interface，接收请求的网卡 优先级第二
3、firewalld.conf中配置的默认zone 优先级最低
这三个的优先级按顺序依次降低，也就是说如果按照source可以找到就不会再按interface去查找，如果前两个都找不到才会使用第三个，也就是学生在前面给大家讲过的在firewalld.conf中配置的默认zone。
三、结构介绍 1、区域 在 firewalld 中最上层的组织是区域。如果一个包匹配区域相关联的网络接口或源 IP/掩码 ，它就是区域的一部分。可用的几个预定义区域：
[root@firewall ~]# firewall-cmd --get-zones block dmz drop external home internal public trusted work 注释：默认是这九个区域 任何配置了一个网络接口和/或一个源的区域就是一个活动区域active zone。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/306a29778897c53f3509c60ca0f95c57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2833692a1f3bb918d698b42e51df0270/" rel="bookmark">
			CentOS7 离线安装 Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.前言2.下载Python及依赖环境（1）下载Python源码（2）下载Python依赖文件（3）下载gcc环境文件（备用） 3.上传至离线服务器（1）核对已下载离线文件（2）上传至离线服务器 4.服务器离线安装Python（1）gcc环境安装（2）Python 离线安装（3）配置python3系统路径。（4）验证是否安装成功 1.前言 主要过程如下：
（1）在可联网服务器上，下载 Python 源码，及其所需依赖（Yum 开发依赖及 Python 模块依赖）。详见：2.下载Python及依赖环境
（2）上传至离线服务器上。
（3）安装，编译 Python。详见：4.服务器离线安装Python
2.下载Python及依赖环境 （1）下载Python源码 1.访问 https://www.python.org/ftp/python 查询所需python版本
2.下载所需源码，下载方式：
方式一： wget方式下载
# 下载 python 源码 cd /home # 打开home文件夹，用于保存下载的文件 mkdir -p python3 wget --no-check-certificate https://www.python.org/ftp/python/3.9.12/Python-3.9.12.tgz 方式二：
浏览器下载，点在所需文件即可下载。
（2）下载Python依赖文件 # 1.安装 centos-release-scl 第三方yum源 yum install centos-release-scl # 2.安装 yum 依赖下载插件 yum install yum-plugin-downloadonly # 3.创建文件夹，用于保存下载的文件 cd /home/python3 # 打开home/python3文件夹 # 4.创建python_dependencies文件夹 mkdir -p python_dependencies # 5.下载python依赖安装包，--downloaddir=python_dependencies 用于更改保存路径 yumdownloader --resolve --destdir=python_dependencies zlib-devel bzip2-devel openssl openssl-devel ncurses-devel epel-release xz-devel readline-devel gdbm-devel sqlite-devel tk-devel db4-devel libpcap-devel libffi-devel # （备用）方式二下载，如果你已安装以下依赖，可能就不会下载，导致依赖缺失。尽量使用上面方法 # yum install zlib-devel bzip2-devel openssl-devel ncurses-devel epel-release xz-devel readline-devel gdbm-devel sqlite-devel tk-devel db4-devel libpcap-devel libffi-devel --downloadonly --downloaddir=python_dependencies 注：如果yumdownloader命令提示缺失，通过yum install yum-utils 安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2833692a1f3bb918d698b42e51df0270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ccca5042cc573d1b0dd5a1672a4b51/" rel="bookmark">
			Solr搜索引擎的使用（浅谈）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 对Solr简单地下定义是：Solr是一个面向自然语言处理的搜索引擎技术，开放源码的、基于 Lucene Java的搜索服务器，易于加入Web应用程序中。
说起搜索引擎技术,我们不得不提一下 Lucene。Lucene是一个基于Java的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene是Apache Jakarta(雅加达)家族中的一个开源项目，也是目前最为流行的基于Java开源全文检索工具包。目前已经有很多应用程序的搜索功能是基于 Lucene，比如Eclipse帮助系统的搜索功能。Lucene能够为文本类型的数据建立索引，所以只要把你要索引的数据格式转化为文本格式，Lucene就能对你的文档进行索引和搜索。我重点介绍的是Solr,，Solr与 Lucene并不是竞争对立关系,恰恰相反，Solr依存于Lucene，因为Solr底层的核心技术是使用Lucene来实现的。Solr和 Lucene的本质区别有三点：搜索服务器、企业级和管理。Lucene本质上是搜索库，不是独立的应用程序，而Solr是。Lucene专注于搜索底层的建设，而Solr专注于企业应用。Lucene不负责支撑搜索服务所必需的管理，而Solr负责。所以说 Solr是 Lucene面向企业搜索应用的扩展。
另外在介绍Solr之前，我们先来了解下什么叫全文检索。比如我们电脑里有一个文件夹，文件夹中储存了很多文件，例如Word、Excel以及PPT，我们希望根据搜索关键字的方式搜索到相应的文档，比如我们输入Solr，所有内容含有Solr这个关键字的文件就会被筛选出来，这个就是全文检索。
2.Solr简介与部署 Solr是一种开放源码的、基于 Lucene Java的搜索服务器，易于加入Web应用程序中。Solr提供了层面搜索(就是统计)、命中醒目显示并且支持多种输出格式(包括XML/XSLT 和JSON等格式)。它易于安装和配置，而且附带了一个基于HTTP的管理界面。可以使用Solr的基本搜索功能，也可以对它进行扩展从而满足企业的需要。Solr的特性包括:
1.高级的全文搜索功能。
2.专为高通量的网络流量进行的优化。
3.基于开放接口(XML和 HTTP)的标准。
4.综合的HTML管理界面。
5.可伸缩性——能够有效地复制到另矶二个Solr搏索服务器。
6.使用XML配置达到灵活性和适配性。
7.可扩展的插件体系。
了解了Solr基本概念之后，我们来简单介绍下Solr的部署步骤。Solr是Apache下的一个顶级开源项目，采用Java开发，所以在安装Solr之前我们首先需要安装JDK环境。另外，Solr提供了一个基于HTTP 的管理界面，所以需要Tomcat容器，但本篇就不用Tomcat容器，采用直接导进数据的方式来演示。
2.1 Solr的具体安装部署如下： 1)下载JDK、Solr安装包。
JDK下载地址：Java Downloads | Oracle 中国，这里我们使用的Solr的版本是6.6.0，Solr版本最好是搭配JDK1.8，虽然官网没有明确要求Solr要使用JDK1.8，但是Solr6中部分功能对servlet-api的版本有要求，所以建议使用JDK1.8.这里使用JDK版本jdk1.8.0_91。
Solr下载地址：Index of /dist/lucene/solr，这里我们使用solr-6.6.0版本。
下载完成，配置JDK，配置完成如下图所示：
a.在环境变量中建立JAVA_HOME，并在Path中加入安装好的jdk路径。 b.下载好Solr并解压到一个文件夹下，我这里解压到E:\pywork\solr-6.6.0。
c.进入solr的bin目录下，在命令窗口输入启动命令 solr start，关闭命令是 solr stop -all ：
d.在浏览器地址栏访问http://localhost:8983/solr/，即可访问到solr的可视化管理界面Solr Admin。 在E:\pywork\solr-6.6.0\bin目录下执行一下命令，建立一个核心 jcg ：
solr create -c jcg -d basic_configs 执行完命令后关闭再启动solr，就可以看到上一张图片效果。
e.导入数据
本例中我们使用solr自带的例子。
将books.csv复制到E:\pywork\solr-6.6.0\server\solr\jcg\conf文件夹下。
打开管理文件，在第一个WARNING后添加如下内容后保存，关闭重启solr：
&lt;uniqueKey&gt;id&lt;/uniqueKey&gt; &lt;!-- Fields added for books.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49ccca5042cc573d1b0dd5a1672a4b51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f832addc400818ce57f6da77d89e1635/" rel="bookmark">
			node.js 报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node安装第三方模块时报以下错 是因为权限不够
可以以管理员身份运行cmd 找到对应的文件路径 在安装模块 就可以了
当 使用npm命令的时候报错
报的是 npm 不是一个命令 (忘了截图了)
这个需要重装node.js (可能有其他方法,但是我没有找到)
卸载和重装node.js(7条消息) node.js卸载与重装_虎哈哈的博客-CSDN博客_卸载nodejs重装https://blog.csdn.net/weixin_44987713/article/details/114699900最常见的报错
没有安装express的第三方模块 用 npm i express 安装一下就可以
7.13(更新)
如果npm i 出错,以前能正常运行,可能是,npm与node.js版本不对应 可以 查一下版本是否对应
以往的版本 | Node.js (nodejs.org)
11.18(更新)
安装包成功，运行的时候出现（您可能需要一个适当的加载器来处理此文件类型，目前没有配置加载器来处理此文件。看到https://webpack.js.org/concepts加载器（这是我翻译的，忘记截图了））
找了很多文章都没有用，后来发现是写代码的时候vscode的联想自动引入的莫名其妙的模块
像这种，敲代码的时候自动引入的，删掉就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d15daeb7c99c569bd5e43ac98d5602/" rel="bookmark">
			Git如何将一个分支上的修改转移到另一个分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.未commit git stash //把暂存区内的修改存储起来
git checkout dev //切换到正确的分支
git stash pop //将存储的修改取出来
操作：
1、左上角Git–&gt;Uncommitchanges–&gt;Stash changes
2、切换到目标分支
3、左上角Git–&gt;Uncommitchanges–&gt;Stash pop
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0a5e8ea044d941bb3d9be59e3feb12/" rel="bookmark">
			【OpenMMLab实践】03MMClassification理论（CNN分类模型训练以及PyTorch简介-中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考来源：【OpenMMLab 公开课】图像分类与 MMClassification
前面一篇博文总结了传统图像分类算法的设计思路，以及后来的基于CNN的分类网络的演化过程，从AlexNet到GoogleNet，然后是ResNet、MobileNet等，以及后来的EfficientNet和注意力机制。本文总结分类模型具体的训练过程以及PyTorch框架
目录
1. 图像分类模型训练
1.1 交叉熵损失函数
1.2 训练CNN的困难之处
1.3 梯度下降算法及其改进
1.4 学习率设置策略
1.5 自适应梯度算法
1.6 权重初始化策略
1.7 防止过拟合的策略
1.8 数据增广策略
1.9 Batch Normalization
1.10 总结
2. PyTorch框架简介
2.1 PyTorch的基本模块
2.2 数值计算库torch
2.3 自动求导torch.autograd
2.4 函数库torch.nn.functional
2.5 通用模型封装torch.nn.Module
2.6 优化器torch.optim
2.7 数据工具torch.utils.data
1. 图像分类模型训练 1.1 交叉熵损失函数 分类任务的神经网络会输出K维类别向量P，y为真实类别标签，交叉熵损失为向量P的某个真实类别维度的概率值取对数然后取负号。减函数，也就是Py越大，损失越小 1.2 训练CNN的困难之处 数据量大，计算量大：例如在ImageNet数据集上训练AlexNet，有100万张图片，大约6000万个参数损失函数复杂度高（高维非凸函数）模型复杂度高，过拟合现象 1.3 梯度下降算法及其改进 梯度下降算法：给定数据集，模型和损失函数。首先初始化模型参数，设置学习率，通过前向传播，反向传播计算梯度，更新参数，直至收敛。随机梯度下降算法：（梯度下降每走一步就只要在整个数据集上计算全部参数，显然不可能，这就出现了SCD） 每次迭代随机选取样本子集（称为批Mini Batch），近似计算损失函数的梯度动量Momentum SGD：（SGD下降波动比较大，为了减小误差，不让梯度乱走。就考虑把在以往数据上计算的梯度移动延续到这次移动，引入了动量） 不是按照梯度去移动，而是按照累计值移动 1.4 学习率设置策略 学习率退火策略：最常用，在训练初始阶段使用较大的学习率，损失函数稳定后下降学习率（按步长下降，按比例下降，按倒数下降等） 学习率升温（Warmup）：在训练前几轮学习率逐渐上升，指导预设的学习率，以稳定训练的初始阶段，可以线性上升等。与退火结合使用当然，学习率这么设置的话仍然存在一个问题就是：所有的参数都按照同一个学习率下降，有时候并不希望这样，这就出现了自适应梯度算法 1.5 自适应梯度算法 不同梯度需要不同的学习率，根据梯度的幅度自动调整学习率 1.6 权重初始化策略 针对卷积层和全连接层，初始化连接权重W和偏置随机初始化方法： 朴素方法：依照均匀分布或高斯分布Xavier方法（2010）：前传时维持激活值的方差，反传维持梯度的方差Kaiming方法（2015）：同上，但针对ReLU激活函数用训练好的模型进行初始化： 替换预训练模型的分类头，进行微调训练（finetune） 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0a5e8ea044d941bb3d9be59e3feb12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b5c1c24cb56c052c35f8b9243562f9/" rel="bookmark">
			vue使用drag-verify实现滑块验证滑块登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需求 客户要求输入账号密码后，点击登录，做一个滑块验证的功能
2.实现 2.1首先在项目中安装drag-verify 下载安装依赖 不知道什么原因，我无法使用npm安装 drag-verify 最终用yarn完成的
npm i vue-drag-verify2 -S 2.2 在main.js中配置使用drag-verify import dragVerify from 'vue-drag-verify2' Vue.use(dragVerify) 2.3 &lt;/template&gt; &lt;el-form&gt; // 此处省略账号密码输入框和登录按钮 &lt;el-form-item v-show="showHk"&gt; &lt;drag-verify style="margin: 0 auto" // 让滑块保持水平居中 :width="320" // 滑块宽度 ref="dragVerify" handlerBg="#8ec6e9" // 滑块颜色 :isPassing.sync="isPassing" // 滑块状态参数名 text="请按住滑块拖动以完成登录" // 滑块内提示文字 successText="验证通过" // 滑块完成提示语 handlerIcon="el-icon-d-arrow-right" successIcon="el-icon-circle-check" @passcallback="passcallback" // 滑块完成函数 多数用了调用登录接口 &gt; &lt;i v-show="!isPassing" slot="textBefore" class="el-icon-lock"&gt;&lt;/i&gt; &lt;/drag-verify&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{ showHk: false, // 是否展示滑块 点击登录按钮是 设置为true 同时隐藏登录按钮 isPassing: false, // 滑块状态 } } methods:{ // 滑块完成函数 passcallback() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b5c1c24cb56c052c35f8b9243562f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a6abed4b0d1c7a5acbc54e042b085c/" rel="bookmark">
			C语言实现求最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：求10 个整数中最大值
思路：
1、初始化一个数组，for循环输入10个整数
2、在10个数中随便挑一个数作为最大值，用for循环遍历数组，若有比当前最大值更大的数，则将当前数替换。
3、打印最大值
#include&lt;stdio.h&gt; //求10 个整数中最大值 int main() { int arr[10] = { 0 }; int i = 0; int max = arr[0]; for (i = 0; i &lt; 10; i++) { scanf("%d", &amp;arr[i]); } for (i = 0; i &lt; 10; i++) { if (max &lt; arr[i]) max = arr[i]; } printf("%d", max); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc7fe5bfe55ad9e8c8073b8e7ca773b1/" rel="bookmark">
			Python str upper方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
描述
语法
参数
返回值
使用示例
注意事项
1. 字符串原本存在大写字母时
2. 字符串存在非字母字符
描述 upper()方法是Python的字符串方法，它将字符串中的小写字母转换成大写字母，并返回转换后的字符串。
语法 str.upper() 参数 upper()方法没有参数
返回值 返回一个修改后的新字符串
使用示例 upper()方法将字符串中的非大写字母转换成大写，并返回新的字符串。
&gt;&gt;&gt; demo = "Welcome to Beijing." &gt;&gt;&gt; id(demo) 4467791816 &gt;&gt;&gt; result = demo.upper() &gt;&gt;&gt; result 'WELCOME TO BEIJING.' &gt;&gt;&gt; id(result) 4467791960 注意事项 1. 字符串原本存在大写字母时 在使用upper()方法之前字符串原本就存在大写字母时，upper()方法将保留大写字母，并将小写字母转换成大写字母。
&gt;&gt;&gt; demo = "Golang is a new language." &gt;&gt;&gt; demo 'Golang is a new language.' &gt;&gt;&gt; demo.upper() 'GOLANG IS A NEW LANGUAGE.' 2. 字符串存在非字母字符 upper()不会处理非字母字符，更不会报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc7fe5bfe55ad9e8c8073b8e7ca773b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c53001df9f4ac44909102e61a4b04e/" rel="bookmark">
			AC/DC、DC/DC转换器基础指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，我们过一下AC（交流）和DC（直流）的概念。
何谓AC
Alternating Current（交流）的首字母缩写。
AC是大小和极性（方向）随时间呈周期性变化的电流。
电流极性在1秒内的变化次数被称为频率，以Hz为单位表示。
何谓DC
Direct Current（直流）的首字母缩写。
DC是极性（方向）不随时间变化的电流。
①流动极性（方向）和大小皆不随时间变化的电流通常被称为DC。
②流动极性不随时间变化，但大小随时间变化的电流也是DC，
通常被称为纹波电流 (Ripple current)。
一、AC/DC转换器
何谓AC/DC转换器？
AC/DC转换器是指将AC（交流电压）转换成DC（直流电压）的元件。
为什么需要AC/DC转换器？
为什么需要AC/DC转换器？
那是因为家庭住宅和楼房接收到的电压是100V或200V的AC电压。
然而大家大部分使用的电器是在5V或3.3V的DC电压下工作的。
也就是说，如果不把AC电压转换成DC电压，电器就不能工作。
其中也有电机、灯泡等可以用交流电压驱动的产品，但电机与微控制器的控制电路连在一起，灯泡也变成节能LED，因此有必要进行ACDC转换。
为什么传输的是AC电压？
可能有人会认为“既然电器使用的是DC，那为什么不一开始就传输DC？”
总所周知，电力来自水力发电站、火力发电站、核电站等。这些发电站位于山区或沿海等地区，从这些地区传输到市区，AC电压更有优势。
简而言之，通过以高电压、低电流方式传输AC电压，可以减少传输损耗（能量损耗）。
然而，在实际家庭中，由于不能直接使用高电压，所以需要通过几个变电站分阶段进行变压（降压），最后转换成100V或200V后进入家庭。这些转换也因AC更简单，所以传输的是AC电压。
全波整流和半波整流（AC/DC转换）
将AC（交流电压）转换为DC（直流电压）的整流方式有全波整流和半波整流。两种情况都利用了二极管的电流正向流通特性来进行整流。
全波整流是通过二极管桥式电路结构将输入电压的负电压成分转换为正电压后整流成直流电压（脉冲电压）。而半波整流是使用一个二极管来消除输入负电压成分后整流为直流电压（脉冲电压）。
之后，利用电容器的充电和放电功能来平滑波形，从而转换为纯净的直流电压。
因此可以说，与不利用输入负电压成分的半波整流相比，全波整流是更具高效率的整流方法。
此外，平滑后的纹波电压根据电容器容量和负载（LOAD）而变化。
全波整流和半波整流在相同的电容器容量和负载条件下，全波整流的纹波电压更小。纹波电压越小，稳定性越高、性能越优。
AC/DC转换方法
AC/DC转换有变压器方式和开关方式。
变压器方式
这是普通AC/DC转换器的变压器方式电路结构。
【变压器方式的电路结构示例】
下图显示了变压器方式电压波形的变化。
变压器方法首先需要通过变压器将交流电压降压到适当的交流电压（例如，从AC100V降至AC10V等）。这属于AC/AC转换，降压值由变压器的绕组比设定。
接下来，通过二极管桥式整流器对经过变压器降压的交流电压进行全波整流，转换为脉冲电压。
最后，经电容器平滑并输出纹波小的直流电压，这是最传统的AC/DC转换方法。
【变压器方式的波形推移】
开关方式
这是普通AC/DC转换器的开关方式电路结构。
【开关方式的电路结构示例】
下图显示了开关方式电压波形的变化。
变压器方式是首先通过变压器进行AC/AC降压，而开关方式是直接用二极管桥式整流器对交流电压进行整流。由于普通家庭的用电电压为AC100V或AC200V，所以二极管桥式整流器必须具有可承受高电压的规格。
接下来，用电容器平滑直流电压（脉冲电压）。电容器同样需要耐高压的电容器。
然后，通过开关元件的ON/OFF对直流电压进行斩波（切割），并经过高频变压器降压后传送到二次侧。此时，斩波波形变为方波。
与家用频率（50/60Hz）相比，开关元件使用的频率更高（例如，100kHz）。由于高频工作，所以可以实现变压器的小型化、轻便化。
【开关方式的波形推移】
在二次侧利用整流二极管对方波进行半波整流，之后用电容器对其进行平滑，并输出直流电压。
开关方式是利用控制电路控制开关元件，获得稳定的预期的直流输出（例如，DC12V）的方式。
与变压器方式相比，开关方式由开关元件和控制电路组成，电路结构较复杂，但由于基于高频控制可以使用小型变压器，所以有助于设备小型化，这是它的一个很大的优点。
反馈控制
何谓反馈控制？
开关式AC/DC转换器通过确认实际输出的DC电压值，并根据该电压信息对开关元件进行控制，从而确保稳定实现规定的DC输出。这种确认该输出电压值以控制开关元件的机制叫做反馈控制（FB控制）。
【开关方式电路结构示例】
反馈控制的示意图
开关式AC/DC转换器通过二极管电桥对AC电压进行整流，再通过电容器实施平滑处理，将AC电压转换为DC电压。然后，通过开关元件对该DC电压进行斩波（ON/OFF）后，通过高频变压器降压后传递到2次侧，再利用电容器进行平滑处理，输出规定的DC电压（VDC）。
FB控制电路检测实际输出的该电压值是否达到规定的目标电压值。
【经过平滑处理的输出电压示意图】
实际输出电压值低于目标电压值时，则会对开关元件进行控制，使ON时间变长。这样，输出电压值就会上升。反之，高于目标电压值时，则控制ON时间变短。
这样，反馈控制电路常时对实际输出电压值进行确认，并根据该值调整开关元件的ON/OFF时间，确保目标输出电压值的稳定。
轻负载模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77c53001df9f4ac44909102e61a4b04e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70cd8c331f899337b3e505c44a5f5da/" rel="bookmark">
			DHorse系列文章之镜像制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		制作镜像常用的工具 使用Docker制作镜像 1.使用docker commit制作
该命令使用比较简单，可以自行网上搜索教程。
2.使用Dockerfile制作
这种方式，需要编写如下的Dokerfile文件：
FROM openjdk:openjdk:13-jdk-alpine ADD client-1.0.0.jar /client.jar ENTRYPOINT ["java","-jar","/client.jar"] 并且执行如下命令：
docker build -t dhorse/client:102 . 才能完成镜像的制作。
通过以上可以看出，如果要使用docker制作镜像的话，必须要有docker环境，而且需要编写Dockerfile文件。当然，也可以不用安装docker环境，而且使用doker的远程接口：post/build。但是，在远程服务器中仍然需要安装doker环境和编写Dockerfile。
DHorse的技术选型 DHorse作为一个简单易用的DevOps开发平台，在一开始设计时就考虑到了对外部环境的依赖性。无论是从安装还是从使用的角度，都应该尽量减少对外部环境的依赖，尤其是对docker的依赖。不依赖docker还有另外一个重要的原因，k8s在高版本也逐渐不依赖docker了。而DHorse主要还是基于k8s来实现部署的，因此DHorse在构建镜像时更不能依赖docker环境。那么，在不依赖docker的情况下，是否可以通过其他技术构建镜像呢？答案是有的，比如通过Jib就可以实现。
Jib介绍 Jib是谷歌开源的一套工具，github地址，它是一个无需Docker守护进程——也无需深入掌握Docker最佳实践的情况下，为Java应用程序构建Docker和OCI镜像， 它可以作为Maven和Gradle的插件，也可以作为Java库。
个人博客推荐：白煮蛋的博客
比如，使用jib-maven-plugin插件构建镜像的代码如下：
&lt;plugin&gt; &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt; &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;configuration&gt; &lt;from&gt; &lt;image&gt;openjdk:13-jdk-alpine&lt;/image&gt; &lt;/from&gt; &lt;to&gt; &lt;image&gt;gcr.io/dhorse/client&lt;/image&gt; &lt;tags&gt; &lt;tag&gt;102&lt;/tag&gt; &lt;/tags&gt; &lt;auth&gt; &lt;!--连接镜像仓库的账号和密码 --&gt; &lt;username&gt;username&lt;/username&gt; &lt;password&gt;password&lt;/password&gt; &lt;/auth&gt; &lt;/to&gt; &lt;container&gt; &lt;ports&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/ports&gt; &lt;/container&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 然后使用命令进行构建：
mvn compile jib:build 可以看出，无需docker环境就可以实现镜像的构建。但是，要想通过平台类型的系统去为每个系统构建镜像，显然通过插件的方式，不太合适，因为需要每个被构建系统引入jib-maven-plugin插件才行，也就是需要改造每一个系统，这样就会带来一定的麻烦。那么有没有不需要改造系统的方式直接进行构建镜像呢？答案是通过Jib-core就可以实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a70cd8c331f899337b3e505c44a5f5da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4584f7d27db8a38e84244456577824/" rel="bookmark">
			drop_path理解和pytorch代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		drop_path理解和代码分析 drop_path理解drop_path代码pytorch对比dropout结果drop_path输出结果：dropout输出结果： 总结 drop_path理解 网上的说法：DropPath/drop_path 是一种正则化手段，其效果是将深度学习模型中的多分支结构随机”删除“。
实际上在网上笔者找不到官方的说法…而且drop_path的方法实际上是一个很小众的方法，使用情况极其惨淡如下图：
没错，蓝色线是drop_path，基本就是0了，笔者纯属是看了ViT的文章的代码实现才能发现这个玩意儿…
总的来说，根据代码理解其实drop_path就是在一个batch里面随机去除一部分样本，（drop_path：drop掉一部分样本前进的path…）如图为在ViT中的实现：
理解：
ViT里面结合了一个残差，可以这么理解：假设没有被drop_path的为x1，被drop_path的为x2。输入x=x1+x2，输出y=x+f(x1),这里假设f表示Layer Norm和Multi-Head Attention层。
drop_path代码pytorch def drop_path(x, drop_prob: float = 0., training: bool = False): if drop_prob == 0. or not training: return x keep_prob = 1 - drop_prob shape = (x.shape[0],) + (1,) * (x.ndim - 1) # work with diff dim tensors, not just 2D ConvNets random_tensor = keep_prob + torch.rand(shape, dtype=x.dtype, device=x.device) random_tensor.floor_() # binarize output = x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4584f7d27db8a38e84244456577824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12244291be651bbfe4f69322db5caafd/" rel="bookmark">
			一文搞懂UART、RS232、RS485、TTL等常用的接口与协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的接口与协议 PC机常用的按照接口数量细分为A型（15针），B型（25针），C型（37针），D型（50针），E型（9针）。其中，串行通信常用的是RS232——9针的DB9接口，显示器用的是VGA——15针的DB15接口。现在的笔记本电脑都已取消这种接口，一方面是因为这种接口比较笨重、逐渐被市场淘汰，另一方面，也有了更好的USB口来完美替代他，而某些需要RS232的场景也可用通过USB转RS232驱动来实现，所以顺其自然的RS232接口也就被淘汰了。 此外，我们电脑打开设备管理器，看到的端口设备（COM1、COM2…）等就是串行通讯端口，简称串口，老款的设备大多是用RS232接口，现在我们使用的鼠标、键盘、打印机等都以使用更高速、方便的USB口了。下面我们进行详细的介绍。
1. UART 在通信和计算机科学中，Serial communication是一个通用概念，泛指所有的串行的通信协议，如RS232、USB、I2C、SPI、1-Wire、Ethernet等。这里的串行（serial），是相对并行通信（parallel communication）来说的，只将准备发送的一长串0/1电平跳变信号以串行的方式发送出去。
理解了串行通信后，还需要知道一组概念，即同步通信和异步通信，这里只介绍串行的同步和异步通信。
同步串行通信：发送端在发送串行数据的同时，提供一个时钟信号，并按照一定的约定（例如在时钟信号的上升沿的时候，将数据发送出去）发送数据，接收端根据发送端提供的时钟信号，以及大家的约定，接收数据。I2C、SPI等有时钟信号的协议，都属于这种通信方式。异步串行通信：发送端在数据发送之前和之后，通过特定形式的信号（例如START信号和STOP信号），告诉接收端，可以开始（或者停止）接收数据了。与此同时，收发两方会约定一个数据发送的速度（这就是波特率），发送端在发送START信号之后，就按照固定的节奏发送串行数据，与此同时，接收端在收到START信号之后，也按照固定的节奏接收串行数据。 我们所提到的串口通信（UART）便是使用的异步串行通信方式，而我们电脑上所谓的COM口，便是针对串口通信而设计的一种端口。UART更多关注规定编码格式的标准，如波特率（baud rate）、帧格式和波特率误差等等，而将要介绍的RS232、USB、RS485等这类串行通信接口则更多关注的是电平标准和电压。还有一点需要注意的是UART已经包含了TTL电平的串口，也包含了RS232电平的串口。
2. RS232 RS-232C 标准(协议)的全称是 EIA-RS-232C 标准，其中EIA (Electronic Industry Association)代表美国电子工业协会， 是常用的串行通信接口标准之一。
引脚定义（实际只用到2、3、5三个脚）：
9芯缩写描述1CD载波检测2RXD接收数据3TXD发送数据4DTR数据终端准备好5GND信号地6DSR通信设备准备好7RTS请求发送8CTS允许发送9RI响铃指示器 电气特性：
最远通信距离是50英尺（15m）全双工通讯，最高传输速率20kbps传送的数字量采用负逻辑，且与地对称，逻辑1：-3 ～-15V ； 逻辑0：+3～+15V 优缺点：
接口的信号电平值较高，易损坏接口电路的芯片，又因为与TTL电平不兼容故需使用电平转换电路方能与TTL电路连接。
传输速率较低，在异步传输时，波特率为20Kbps；
接口使用一根信号线和一根信号返回线而构成共地的传输形式，这种共地传输容易产生共模干扰，所以抗噪声干扰性弱。
传输距离有限，且需要双方的RXD和TXD线交叉连接，注定只能进行点对点连接。
3. RS485 针对RS232出现的缺点和不足，新接口RS-485便应运而生，该接口有效的减弱了共模干扰，利用A、B两个信号线进行平衡传输。RS-485同样负责在设备和物理传输介质之间传输原始数据，并没有复杂的协议栈，是一种利用差分传输进行串口通信的半双工接口。它具有以下特点：
引脚定义：
DB9缩写描述1RS-485(A+)非反向信号2RS-485(B -)反向信号3空-4空-5GND信号地 电气特性：
接口使用差分信号，逻辑1：+2V to +6V；逻辑0：-6V to -2V。半双工通信，速率可高达10Mbit/s理论通讯距离可达1200米，具有良好的抗噪声性能，不需要考虑总线电压衰减问题 优缺点：
使用差分信号传输。长距离布线会有信号衰减，而且引入噪声和干扰的可能性更大，在线缆A和B上的表现就是电压幅度的变化，但是，采用差分线的好处就是，差值相减就会忽略掉干扰依旧能输出正常的信号，把这种差分接收器忽略两条信号线上相同电压的能力称为共模抑制。高低电平由最小差分电压决定。RS-485不需要使用特定的总线电压，在较长的电缆长度上，接收器接收到的电压可能会降低到+/- 200 mV，这对于RS-485仍然是完全可以接受的。RS-485标准中提到：若是逻辑1，线路B信号电压比线路A高；若是逻辑0，线路A信号电压比线路B高；RS485有两线制和四线制两种接线，四线制只能实现点对点的通信方式，现很少采用，多采用的是两线制接线方式，这种接线方式为总线拓扑结构，在同一总线上最多可以挂接32个节点。接口信号电平降低，不易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便与TTL电路连接。利用RS485为半双工通信方式，即每一时刻只能有一个发送者，且有RS485组成的总线网络没有CSMA/CD机制，因此大多数时候适合从机处于接收状态，等待主机向指定的从机发送数据。RS485接口传输的信号虽然是差分信号，但仍需要使用转换器转换为TTL串口将信号送去微控制器中。 4. TTL TTL（Transistor Transistor Logic）即晶体管-晶体管逻辑，TTL电平信号由TTL器件产生。TTL器件是数字集成电路的一大门类。TTL与RS485、RS232最大的区别便是TTL接口属于并行方式传输数据的接口，而后两者则遵循的是串行通信协议。
接口定义：
TTL输出接口可分为，单路6bit TTL输出接口、双路6bit TTL输出接口、双路8bit TTL输出位接口等等几类，驱动板的TTL输出接口通常包括：RGB数据信号、时钟信号和控制信号这三大类信号。例如单路6bit TTL输出接口，便共有18条RGB数据线，每个基色信号采用6bit数据（R0～R5，G0～G5，B0～B5），由于基色RGB数据为18bit，因此，也称18位或18bit TTL接口。
电气特性：
逻辑"1"：+5V/3.3V；逻辑"0"：0V，对TTL电平的器件来说，当输入电压高于2V时，会被识别为逻辑1，输入的低电平低于1.2V时，会被识别为0。全双工通信，传输速率要高于串行传输传输距离理论上为10英尺（5米），抗噪声性能差。 优缺点：
并行传输，全双工通信，传输速率极快电平信号为5V，与主控芯片之间连接不需要额外的电平转换电路，大多数使用在微控制器与外设IO之间的短距离通信上。信号电压高、连线多，因此抗电磁干扰性能也较差，并不适合长远距离传输。 除了TTL接口外，还有一点极易混淆的是：我们常用的USB转TTL、RS232转TTL指的是将不同接口的电平信号转为TTL电信号，而不是将串行转换为并行，也就是是说转换后仍然是串口通信。
5. USB USB的全名为通用串行总线（Universal Serial Bus），它的出现是为了解决计算机系统接口复杂的弊端，因为早期计算机外设接口各不相同，例如键盘的插口为圆形串口，而打印机需要DB9或25的并行接口，鼠标使用的是DB9或25的串行接口，这些接口不仅复杂，每次插拔都需要系统重启来启动驱动，基于此，USB接口横空出世，它的特点就是将所有外设接口都设计为统一规格，而且支持即插即用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12244291be651bbfe4f69322db5caafd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5eaa55afb39a30bf434b95e2e53c4e4/" rel="bookmark">
			android surfaceflinger调研
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(220条消息) AndroidR护眼模式流程分析(上)_Vampaire27的博客-CSDN博客
夕月风 - 简书 (jianshu.com)
Android Q 色彩（颜色）模式解析（一） - 简书 (jianshu.com)
(220条消息) Android图形系统之HWComposer_飞天猫_的博客-CSDN博客_hwcomposer
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1cdf77d4c4ef9a35d70d398ab3f675/" rel="bookmark">
			Colour correction with WebGL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Although cameras continuously get better, most pictures are retouched. A significant part of post-processing is finding the right balance of colours and shades that make the entire image cohesive or make the subject pop. With WebGL, we can do this on the web.
There are many situations this could be useful: when I update my avatar, share my holiday pictures, or upload an image for a blog post. We can do this with WebGL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d1cdf77d4c4ef9a35d70d398ab3f675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20dfb686ea22a198f600722c2987b7ba/" rel="bookmark">
			EGE示例程序——花火闪烁的夜晚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏：EGE专栏
专栏：EGE示例程序
示例程序下载 花火闪烁的夜晚
站点链接百度网盘示例一 花火闪烁的夜晚CSDN示例一 花火闪烁的夜晚 (无需积分) 一、烟花 在做烟花特效前，先来看看烟花的样子。
烟花各式各样，并不是只有一种烟花。而接下来要做的是下面这种比较简单的。烟花在发射后，会拖着一条尾巴快速上升，到达一定高度后快速散开，最后逐渐熄灭。
二、烟花效果的设计 1. 烟花发射过程 我们将烟花发射过程分为三个阶段，分别是准备阶段、上升阶段和爆炸阶段。
在每个阶段，我们都会给烟花设定一个在某个范围内的随机时间，这样就能够将烟花的发射时间错开，不至于过于整齐而显得比较刻意。
在准备阶段，烟花尚未点燃，不进行显示。准备阶段结束后进入发射阶段，烟花以一定的初速度上升，并且由于重力和空气阻力等因素速度减小，上升一定时间后爆炸，分成多个粒子向四周散开。粒子散开后会受到重力和空气阻力等因素影响会往下坠，一段时间后熄灭。
2. 烟花的构成 烟花可以看做由很多个有颜色的粒子组成，每一个粒子都带有各自的速度（矢量）。同一个烟花可以是五颜六色，也可以只有一种颜色。
上升过程中，粒子基本都堆在一起，炸开时分散向四面八方，会形成一个球状，受重力和空气阻力影响，粒子向外发射后会逐渐向下方坠落。受粒子本身重量、形状及大小等因素影响，不同种类的烟花在爆炸时，发射出的粒子的运动轨迹并不相同。
烟花在上升阶段是一个整体，上升到最高点后爆炸分散成大量粒子。粒子具有一定的初速度，在重力、空气阻力等影响下位置和速度都在不断地变化。
由于粒子的位置和速度并不相同，所以需要分别记录每个粒子的位置和速度信息。
在本例中，同一个烟花的粒子具有同样大小和颜色，因此并没有单独为每个粒子记录大小和颜色信息。
实际上也可以将所有粒子分成几部分，每一个部分具有相同的颜色，这样在不必记录过多颜色信息的同时也能达到较好的效果。
粒子按如下定义，记录位置和速度信息。
//速度 struct Speed { double x, y; }; //位置 struct Pos { double x, y; }; //粒子 struct Particle { Pos pos; Speed speed; }; 烟花包含多个粒子，还有发射位置、发射速度以及各阶段的持续时间。粒子的初始位置和射出速度则在爆炸时给出。
由此我们定义的烟花类包含以下成员变量：
//烟花 class Fireworks { private: static const int NUM_PARTICLE = 200;	//烟花包含的粒子数 static const float particleSpeed;	//爆炸时粒子射出的速率 private: Particle p[NUM_PARTICLE];	//粒子 color_t color;	//烟花颜色 int waitingTime;	//等待时间 int riseTime;	//上升时间 int bloomTime;	//爆炸时间 Pos pos;	//位置(上升阶段) Speed speed;	//速度(上升阶段) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20dfb686ea22a198f600722c2987b7ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f861223962fcdaa42ba2d0724f391fa7/" rel="bookmark">
			通俗地解释一下什么是泛型？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛型，“泛”就是广泛的意思，“型”就是数据类型。顾名思义，泛型就是适用于多种数据类型的一种类型，通常用Object来定义，理论上它可以存放任何类型的数据。
如果我们学过数组的话应该就会知道，数组里面存放的都是相同的数据类型，比如整型、浮点型，那么我们使用Object来定义一个数组，是不是就可以用来存放不同数据类型的数据了呢？
class MyArray{ public Object[] array=new Object[10]; } 这个数组可以存放十个Object类型的数据，我们再写一个方法为它赋值
class MyArray{ public Object[] array=new Object[10]; public void setVal(int pos,Object val){ this.array[pos]=val; } } 注意赋值的时候它的值val也要用Object来定义
为它赋值的时候，val可以是任何类型，我们也可以把它理解为，无论我们存入任何类型，都会被转换为Object型。
class MyArray{ public Object[] array=new Object[10]; public void setVal(int pos,Object val){ this.array[pos]=val; } } public class TestDemo { public static void main(String[] args) { MyArray myArray=new MyArray(); myArray.setVal(0,10); myArray.setVal(1,"hello"); myArray.setVal(2,3.14); } } 因为存入的数据都被转换为了Object型，所以我们读取时也要用一个Object类型的变量来接收，否则就要强制转换为相应的数据类型
class MyArray{ public Object[] array=new Object[10]; public Object getVal(int pos){ return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f861223962fcdaa42ba2d0724f391fa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d268c1bde50e802b97563c5f3d37e00/" rel="bookmark">
			嵌入式笔记一——代码编辑工具：Vim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、嵌入式开发为什么选择Linux系统 嵌入式开发：为什么要使用嵌入式Linux？ (baidu.com)
二、代码编辑工具：Vim Vim是一款纯命令行操作、功能可扩展、高度可定制的文本编辑工具
1.安装Vim
在Linux环境下，使用Vim之前首先要安装。虽然大多数操作系统默认已安装Vim，但也有一些操作系统，如 Ubuntu，系统自带的默认文本编辑工具是Vi，或者Vim默认运行的是Vi的兼容模式。
Vi是visual interface 的缩写。
Vim是Vi的加强版：Vi Improved。
在Ubuntu环境下安装Vim，直接在Shell命令行下输入以下命令回车即可。
sudo apt-get install vim 安装好之后，在Shell命令行下输入
vim 如果安装成功，就会启动Vim并弹出一个界面。
2.Vim工作模式
Vim有多种工作模式，不同的工作模式之间都可以通过命令来回切换。
1).普通模式：打开文件时的默认模式，在其他模式下按下 Esc 键都可以返回到该模式（普通模式下所有输入均为英文输入）。 2). 输入模式：在普通模式下，按a/i/o键进入该模式，进行内容输入操作，在Vim输入模式下，界面左下角会有单词显示。 3). 命令行模式 ：普通模式下输入英文冒号(:)后进入该模式，在 : 后面输入命令，如输入set number 或 set nu 可以显示行号。 4).可视化模式：在普通模式下按v键可以进入可视化模式。在该模式下移动光标可以移选中一块文本，然后就可以进行复制、剪切、删除、粘贴等文本操作。 3.Vim基本命令
1).单个字符移动
k：在普通模式下，点击键盘 k 键，光标向上移动一个字符
j：在普通模式下，点击键盘 j 键，光标向下移动一个字符
h：在普通模式下，点击键盘 h 键，光标向左移动一个字符
l：在普通模式下，点击键盘 l 键，光标向下移动一个字符
2).单词移动
w：光标移动到下一个单词的开头
b：光标移动到上一个单词的开头
e：光标移动到下一个单词的词尾
E：光标移动到下一个单词的词尾（忽略标点符号）
ge：光标移动到上一个单词的词尾
nw：指定移动光标n次移动到下n个单词开头
3).行移动
$：将光标移动到当前行的行尾
0：将光标移动到当前行的行首
^：将光标移动到当前行的第一个非空字符
n|：将光标移动到当前行的第n列
fx：将光标移动到光标后面的第一个字符x上（x可以是任意字符）
nfx：将光标移动到光标后面的第n个字符x上（x可以是任意字符）
%：符号间的移动，光标在(),{},[]之间跳跃
4).屏幕移动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d268c1bde50e802b97563c5f3d37e00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/341c4691e33cd858071c8c5118940909/" rel="bookmark">
			ES-分词器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 分词器是es中的一个组件，通俗意义上理解，就是将一段文本按照一定的逻辑，分析成多个词语，同时对这些词语进行常规化的一种工具；ES会将text格式的字段按照分词器进行分词，并编排成倒排索引，正是因为如此，es的查询才如此之快。
一个analyzer即分析器，无论是内置的还是自定义的，只是一个包含character filters（字符过滤器）、 tokenizers（分词器）、token filters（令牌过滤器）三个细分模块的包。
看下这三个细分模块包的作用：
character filters（字符过滤器）：分词之前的预处理，过滤无用字符
token filters（令牌过滤器）：停用词、时态转换，大小写转换、同义词转换、语气词处理等。
tokenizers（分词器）：切词
自定义分词器 先来看个自定义分词器，了解整个分析器analyzer的构造
PUT custom_analysis { "settings":{ "analysis":{	#分析配置，可以设置char_filter(字符过滤器)、filter(令牌过滤器)、tokenizer(分词器)、analyzer(分析器) "char_filter": { # 字符过滤器配置 "my_char_filter":{ #定义一个字符过滤器：my_char_filter "type":"mapping", # 字符过滤器类型：主要有三种：html_strip(标签过滤)、mapping(字符替换)、pattern_replace(正则匹配替换) "mappings":[	# mapping的参数:表示 '&amp;' 会被替换成 'and' "&amp; =&gt; and", "| =&gt; or" ] }, "html_strip_char_filter":{ "type":"html_strip", "escaped_tags":["a"] } }, "filter": {	# 令牌过滤器配置 "my_stopword":{ # 定义一个令牌过滤器：my_stopword "type":"stop", # 令牌过滤器类型：stop（停用（删除）词） "stopwords":[	# stop的参数：表示这些词会被删除 "is", "in", "the", "a", "at", "for" ] } }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/341c4691e33cd858071c8c5118940909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59c577479c79d20c85ff6a5c170e0e3/" rel="bookmark">
			ES增删改查入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文档管理 1.添加文档 模板：
PUT /{索引}/_doc/{id} {请求体数据信息json格式} 例子：
PUT /book/_doc/1 { "title":"Java程序性能", "desc":"强类型语言" } 2.修改文档 模板：
POST /{索引}/_doc/{id} {请求体数据信息json格式} 例子：
POST /book/_doc/1 { "title":"Go程序性能", "desc":"强类型语言" } 3.删除文档 模板：
DELETE /{索引}/_doc/{id} 例子
DELETE /book/_doc/1 4.获取文档 模板：
GET /{索引}/_doc/{id} 例子：
GET /book/_doc/1 5.批处理 模板：
[PUT|POST] /{索引}/_bulk {action:{metadata}} {请求体数据信息json格式} 备注：
action对应取值：
create : 创建一个文档，如果文档不存在就创建index : 创建一个新的文档，如果文档存在就更新update : 批量更新文档delete : 批量删除，不需要有请求体 例子：
POST /book/_bulk {"index":{"_id":1}} {"id":1,"title":"php入门到精通","desc":"php是世界上最好的语言"} {"index":{"_id":2}} {"id":1,"title":"java入门到精通","desc":"java是世界上最快的语言"} 二、查询数据 - query 1.查询全部数据 - match_all POST /{索引}/_search { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d59c577479c79d20c85ff6a5c170e0e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87add8c2ff1ecc9f442436cd0e8e6ec6/" rel="bookmark">
			ES倒排序索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在学习Elasticsearch的使用前，我们先来了解下es是如何实现全文搜索的。
倒排索引是 Elasticsearch 中非常 重要的索引结构，从 文档单词到文档 ID 的过程
为什么要使用倒排索引 先看下面的商品数据goods
id
标题
描述
1
小米手机
小米手机性价比贼高，为发烧而生
2
苹果手机
高端手机，生态丰富
3
三只松鼠零食大礼包
便宜实惠，高端品牌质量有保证
4
小米电脑
小米电脑性价比贼高，便宜好用
如果我们要模糊查含有手机关键词的商品，以mysql查询为例，应该是下面的语句
select * from goods where 标题 like '%手机%' or 描述 like '%手机%' 了解mysql的都知道，用上面的语句查询，索引会失效导致全表查询，如果数据量大的话就会很慢很慢。
怎么解决呢？用倒排索引
倒排索引原理 倒排索引主要包含两个过程：创建倒排索引、倒排索引搜索
创建倒排索引 先对 文档的内容进行分词，形成一个个的 token，也就是 单词，然后保存这些 token 与文档的对应关系。
如上面的商品数据goods，保存后如下所示
token
对应文档
小米
1,4
手机
1,2
苹果
2
电脑
4
三只松鼠
3
零食
3
大礼包
3
便宜
3,4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87add8c2ff1ecc9f442436cd0e8e6ec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edec63c20100a80cef7c9fe98189a572/" rel="bookmark">
			Elasticsearch与Kibana安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现有环境 windows
docker + ubuntu
Elasticsearch安装 安装包下载 ES不同平台、版本下载路径：Download Elasticsearch | Elastic
本文演示用linux
# 启动ubuntu环境，开放端口9200、9300、5601 docker run -name es -p 9200:9200 -p 9300:9300 -p 5601:5601 -t ubuntu # 进入容器 docker exec -it es /bin/bash # 创建应用目录 mkdir /app cd /app # 下载安装包，wget命令没有的话，需用apt-get安装：apt-get update 、apt-get install wget wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-8.4.2-linux-x86_64.tar.gz # 解压到当前文件夹 tar -zvf elasticsearch-8.4.2-linux-x86_64.tar.gz 目录介绍 目录名称
描述
bin
可执行脚本文件，包括启动elasticsearch服务、插件管理、函数命令等
config
配置文件目录，如es配置，角色配置、jvm配置等
lib
elasticsearch所依赖的java库
data
默认的数据存放目录，包含节点、分片、索引、文档的所有数据，生产环境要去必须修改
logs
默认的日志文件存储路径，生产环境务必修改
modules
包含索引的Elasticsearch模块，如Cluster、Discovery、Indices等。
plugins
已经安装的插件目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edec63c20100a80cef7c9fe98189a572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0223427beafeba961cb55dc0585f3ea3/" rel="bookmark">
			mybatis&#43;pageHelper分页失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		失败原因 service中多个查询sql对查询出的list数据，进行后续处理 分页 1.前端页面分页，调用后台请求时，传递分页参数
//一般在查询参数中定义分页变量
queryParams: { pageNum: 1, pageSize: 10}, //页面添加分页组件，传入分页变量
&lt;pagination v-show="total&gt;0":total="total":page.sync="queryParams.pageNum":limit.sync="queryParams.pageSize"@pagination="getList" /&gt; //调用后台方法，传入参数 获取结果
listUser(this.queryParams).then(response =&gt;{ this.userList =response.rows; this.total =response.total; } ); 后台开启分页 @PostMapping("/list") @ResponseBody publicTableDataInfo list(User user) { startPage(); //此方法配合前端完成自动分页 List&lt;User&gt; list =userService.selectUserList(user); returngetDataTable(list); } startPage开启分页解析，进入startPage 代码
protected voidstartPage() { PageDomain pageDomain =TableSupport.buildPageRequest(); Integer pageNum =pageDomain.getPageNum(); Integer pageSize =pageDomain.getPageSize(); if (StringUtils.isNotNull(pageNum) &amp;&amp;StringUtils.isNotNull(pageSize)) { String orderBy =SqlUtil.escapeOrderBySql(pageDomain.getOrderBy()); PageHelper.startPage(pageNum, pageSize, orderBy); } } 最终是调用的MyBatis的PageHelper来进行分页，只需要给其传递分页所需的两个参数和排序字段即可。
那么这两个分页参数时来自pageDomain这个实体类。
进入到生成这个实体类的方法
TableSupport.buildPageRequest public staticPageDomain buildPageRequest() { returngetPageDomain(); } 返回的是getPageDomain这个方法的返回值，进入到该方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0223427beafeba961cb55dc0585f3ea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28bdc8bf608f429005c31662eda8060d/" rel="bookmark">
			mysql安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自链接：
https://blog.csdn.net/qq_43501926/article/details/125907562
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11721f785c5c40f9f738cc8a907792ff/" rel="bookmark">
			软件设计师上午题#2程序设计语言zst_2001
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 编译程序和解释程序 1.1 教材重点内容，看一遍就行 低级语言和高级语言
计算机硬件只能识别由 0、1组成的机器指令序列，即机器指令程序，因此机器指令是最基本的计算机语言。由于机器指令是特定的计算机系统所固有的、面向机器的语言，所以用机器语言进行程序设计时效率很低，程序的可读性很差，也难以修改和维护。因此，人们就用容易记忆的符号代替0、1序列来表示机器指令，例如，用 ADD 表示加法、用SUB 表示减法等。用符号表示的指令称为汇编指令，汇编指令的集合被称为汇编语言。汇编语言与机器语言十分接近，其书写格式在很大程度上取决于特定计算机的机器指令，因此它仍然是一种面向机器的语言，人们称机器语言和汇编语言为低级语言。在此基础上，人们开发了功能更强、抽象级别更高的语言以支持程序设计，于是就产生了面向各类应用的程序设计语言，称为高级语言。常见的有 Java、C、C++、PHP、Python、Delphi、PASCAL 等。这类语言与人们使用的自然语言比较接近，提高了程序设计的效率。
编译程序和解释程序
计算机只能理解由0、1序列构成的机器语言，因此高级程序设计语言需要翻译，担负这一任务的程序称为 “语言处理程序”。语言之间的翻译形式有多种，基本方式为汇编、解释和编译。
用某种高级语言或汇编语言编写的程序称为源程序，源程序不能直按在计算机上执行。如果源程序是用汇编语言编写的，则需要一个汇编程序将其翻译成目标程序后才能执行。如果源程序是用某种高级语言编写的，则需要对应的解释程序或编译程序对其进行翻译，然后在机器上运行。
解释程序也称为解释器，它或者直按解释执行源程序，或者将源程序翻译成某种中间代码后再加以执行；而编译程序（编译器）则是将源程序翻译成目标语言程序，然后在计算机上运行目标程序。这两种语言处理程序的根本区别是：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程：而在解释方式下，解释程序和源程序(或其某种等价表示）要参与到程序的运行过程中，运行程序的控制权在解释程序。简单来说，在解释方式下，翻译源程序时不生成独立的目标程序，而编译器则将源程序翻译成独立保存的目标程序。
1.2重点总结 解释器：
翻译源程序时不生成独立的目标程序
解释程序和源程序要参与到程序的运行过程中
编译器：
翻译时将源程序翻译成独立的目标程序
机器上运行的是于源程序等价的目标程序，
源程序和编译程序都不再参与目标程序的运行过程
二. 程序设计语言基本成分 2.1 教材重点内容 2.1.2程序设计语言的基本成分
程序设计语言的基本成分包括数据、运算、控制和传输等。
1.程序设计语言的数据成分
程序设计语言的数据成分指一种程序设计语言的数据类型。数据对象总是对应着应用系统中某些有意义的东西，数据表示则指明了程序中值的组织形式。数据类型用于代表数据对象，还用于在基础机器中完成对值的布局，同时还可用于检查表达式中对运算的应用是否正确。
数据是程序操作的对象，具有存储类别、类型、名称、作用域和生存期等属性，在使用时要为它分配内存空间。数据名称由用户通过标识符命名，标识符是由字母、数字和下划线“”组成的标记：类型说明数据占用内存的大小和存放形式：存储类别说明数据在内存中的位置和生存期：作用域则说明可以使用数据的代码范围：生存期说明数据占用内存的时间特点。从不同角度可将数据进行不同的划分。
1)常量和变量
按照程序运行时数据的值能否改变，将数据分为常量和变量。程序中的数据对象可以具有左值和（或）右值，左值指存储单元(或地址、容器)，右值是值（或内容）。变量具有左值和右值，在程序运行过程中其右值可以改变：常量只有右值，在程序运行过程中其右值不能改变。
2)全局量和局部量
数据按在程序代码中的作用范围（作用域）可分为全局量和局部量。一般情况下，全局变量的作用域为整个文件或程序，系统为全局变量分配的存储空间在程序运行的过程中是不改变的，局部变量的作用域为定义它的函数或语句块，为局部变量分配的存储单元是动态改变的。
3)数据类型
按照数据组织形式的不同可将数据分为基本类型、用户定义类型、构造类型及其他类型。
C(C++)的数据类型如下。
(1)基本类型：整型(int)、字符型(char)、实型(foat、double)和布尔类型(bool).
(2)特殊类型：空类型(void).
(3)用户定义类型：枚举类型(enum).
(4)构造类型：数组、结构、联合。
(5)指针类型：ype*。
(6)抽象数据类型：类类型。
其中，布尔类型和类类型由C++语言提供。
3.程序设计语言的控制成分
控制成分指明语言允许表述的控制结构，程序员使用控制成分来构造程序中的控制逻辑。理论上已经证明，可计算问题的程序都可以用顺序、选择和循环这3种控制结构来描述。
1)顺序结构
顺序结构用来表示一个计算操作序列。计算过程从所描述的第一个操作开始，按顺序依次执行后续的操作，直到序列的最后一个操作，如图2-1所示。在顺序结构内也可以包含其他控
制结构。
2)选择结构
选择结构提供了在两种或多种分支中选择其中一个的逻辑。基本的选择结构是指定一个条件P,然后根据条件的成立与否决定控制流计算A还是计算B,从两个分支中选择一个执行，如图2-2（a）所示。选择结构中的计算A或计算B还可以包含顺序、选择和重复结构。程序设计语言中还通常提供简化了的选择结构，也就是没有计算B的分支结构，如图2-2(b)所示。
3)循环结构
循环结构描述了重复计算的过程，通常由三部分组成：初始化、循环体和循环条件，其中初始化部分有时在控制的逻辑结构中不进行显式的表示。循环结构主要有两种形式：while型循环结构和do-while型循环结构。while型结构的逻辑含义是先判断条件P,若成立，则执行循环体A,然后再去判断循环条件，否则控制流就退出重复结构，如图2-3(a)所示。do-while型结构的逻辑含义是先执行循环体A,再判断条件P,若成立则继续执行A,然后再判断条件P,否则控制流就退出循环结构，如图2-3(b)所示。
三. 传值调用与传地址调用 函数定义
函数的定义包括两部分：函数首部和函数体。函数的定义描述了函数做什么和怎么做。函数定义的一般形式为：
返回值类型 函数名 （形式参数表） //函数首部 函数名（实参表）；
{
函数体;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11721f785c5c40f9f738cc8a907792ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b912550594abb745eb5a1acf04781e/" rel="bookmark">
			Quartus 实例应用（2）——创建设计工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quartus II 简易教程 一、概念回顾二、创建设计工程2.1 创建工程2.2 新建HDL文件 三、编译工程四、下载 一、概念回顾 什么是综合？什么是设计？
答：综合就是编译，设计就是布局布线。 二、创建设计工程 2.1 创建工程 打开Quartus II 软件。 在Quartus II GUI中，选择File-&gt;New Project Wizard…，打开New Project Wizard对话框，单击Next进入下一页面，输入存储路径名，并输入工程名为demo_LED。 添加已有的源代码文件，没有的话，点Next（这里我没有代码）
单击Next进入下一页面，选FPGA型号，根据你FPGA芯片上印刷的型号选择。
比如，我使用的芯片型号如下：
Family: Arria 10
Device：10AX027H4F34I3SG。
选择综合、仿真、时序分析工具. 此处如果全部选择None，表示用Quartus自带的工具。
我们综合用的自带的，仿真使用Modelsim，需要安装这个软件。
到此，创建完成。 Modelsim查看如下：
2.2 新建HDL文件 一个工程可能包含一个或多个HDL（硬件描述语言）文件。如果没有，则要新建源文件。
选择File-&gt;New，打开对话框。
选择Verilog HDL file，单击OK。一个新的文本编辑器窗口就出现在工作区。
选择File-&gt;Save，打开Save as对话框，保存时，文件名要与module后面定义的实体名一致。即，保存demo_LED.v到你的工程文件夹内。
将该文件设置为顶层文件。
一个工程内，可以有多个源代码文件。但只有一个是顶层文件，代表最顶层设计，它可以引用工程目录内的其他源文件。
写代码，把灯点亮
module demo_LED (output wire eq0); assign eq0 = 1; endmodule 三、编译工程 编译:Processing–&gt;Start Compilation
报错了，因为下图名字要一致。
分配引脚操作：Assignment -&gt; Pin Planner，如图。分配完引脚，关闭窗口，重新编译工程。
搞完后保存重新编译。
四、下载 菜单Tools -&gt; Programmer，如下图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4b912550594abb745eb5a1acf04781e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683e32e93e844e49f4e4a488107e2bd3/" rel="bookmark">
			常见日志框架总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.体系结构
1.1日志门面
1.2日志实现
2.发展过程
2.1诞生之前
2.2 log4j(实现)
2.3 jul(实现)
2.4 jcl(门面)
2.4.1 门面的产生
2.4.2 jcl
2.5 slf4j（门面）+logback（实现）
2.6 log4j2(门面+日志)
3.常见日志详解（可直接阅读此处）
3.1 JUL
3.1.1 日志架构的介绍，其余的日志框架与其基本类似
3.1.2 创建对象及输出方式
3.1.3 日志级别
3.1.4 自定义日志级别
3.1.5 Logger之间的父子关系
3.1.6 总结
3.2 log4j
3.2.1添加依赖,简单实现
3.2.2 日志级别
3.2.3 Log4j组件（相关概念）
3.2.4 Layout的格式
3.2.5 Appender的输出
3.2.6 自定义Logger
3.3 jcl
3.4 SLF4J(推荐)
3.4.1 添加依赖，简单实现
为什么要使用SLF4J作为日志门面
3.4.2 绑定日志的实现（Binding）
3.4.3 桥接旧的日志框架（Bridging）
3.5 logback（推荐）
3.5.1 添加依赖及简单实现
3.5.2 logback配置
3.5.3logback-access（用的不多）
3.6 log4j2（推荐）
3.6.1 log4j2 作为门面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/683e32e93e844e49f4e4a488107e2bd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb56f566b3e66117df6a5881f31de60/" rel="bookmark">
			vue-cli3中PC端大屏自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第一步：安装插件第二步：装好之后在main.js 里引入 lib-flexible第三步： 在vue.config.js 中添加配置第四步：设置flexible.js的宽度根据屏幕大小自动适配， 修改flexible.js 文件，（全局搜索 flexible.js）第五步：设置完成后重新启动项目，查看效果 前期准备：
vue 2.0 vue-cli3 脚手架 flexible 插件 自适应插件 px2rem-loader 插件 将px转化为rem postcss-loader postcss gitee仓库地址
https://gitee.com/hanks_s/vue-big-screen.git 点个star⭐️！！！
第一步：安装插件 npm i lib-flexible -S npm i px2rem-loader -D npm install --save-dev postcss-loader postcss 第二步：装好之后在main.js 里引入 lib-flexible import 'lib-flexible' 第三步： 在vue.config.js 中添加配置 module.exports = { chainWebpack: config =&gt; { config.module .rule("css") .test(/\.css$/) .oneOf("vue") .resourceQuery(/\?vue/) .use("px2rem") .loader("px2rem-loader") .options({ remUnit: 192 }); } } 第四步：设置flexible.js的宽度根据屏幕大小自动适配， 修改flexible.js 文件，（全局搜索 flexible.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eb56f566b3e66117df6a5881f31de60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9676272ebb974c57b5309dd3ac6543e7/" rel="bookmark">
			NI Package Manage软件的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当NI Package Manage报错无法已安装的软件包时，如果没有好的解决方法可以删除c盘下ni软件安装的路径下的ni package manager文件夹，此时再打开控制面板找到“National Instruments Softyware”选项，点击“卸载”，找到“Ni package manager”项，选中并卸载，再进行随便一个的安装软件的“install.exe”运行即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd20ed4eb31f2018421cdbdffd53506f/" rel="bookmark">
			电力电子技术实验-单相桥式全控整流电路实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单相桥式全控整流电路实验实验数据以及实验图像请到主页的资源进行下载！ 一．实验目的
1．了解单相桥式全控整流电路的工作原理。
2．研究单相桥式全控整流电路在电阻负载、电阻—电感性负载及反电势负载时的工作。
3．熟悉触发电路（锯齿波触发电路）。
二．实验线路及原理
参见图5－1。
图5－1
三．实验内容
1．单相桥式全控整流电路供电给电阻负载。
2．单相桥式全控整流电路供电给电阻—电感性负载。
四．实验设备及仪器
1．教学实验台主控制屏 2．触发电路（锯齿波触发电路）组件 3．组式变压器组件 4．二踪示波器（自备） 5．万用表（自备）
五．注意事项
1．本实验中触发可控硅的脉冲来自触发电路（锯齿波触发电路）组件.
2．电阻Rd的调节需注意。若电阻过小，会出现电流过大造成过流保护动作（熔断丝烧断，或仪表告警）。
3．电感的值可根据需要选择。
4．变压器采用组式变压器，原边为220V，副边为110V。
5．示波器的两根地线由于同外壳相连，必须注意需接等电位，否则易造成短路事故。
6．为保护整流元件不受损坏，需注意实验步骤：
（1）在主电路不接通电源时，调试触发电路，使之正常工作。
（2）在控制电压Uc=0时(即触发角度为180度时)，接通主电路电源，然后逐渐加大Uc，使整流电路投入工作。
（3）正确选择负载电阻或电感，须注意防止过流。在不能确定的情况下，尽可能选择较大的电阻或电感，然后根据电流值来调整。
六．实验方法
1．将触发电路（锯齿波触发电路）面板左下角的同步电压输入接电源控制屏的U、V输出端。
2．断开变压器和晶闸管(T)主回路的连接线，合上控制屏主电路电源（按下绿色开关），此时锯齿波触发电路应处于工作状态。
调速系统控制单元（系统控制单元I）的G给定电位器RP1逆时针调到底"1"脚=0，使Uc=0。调节偏移电压电位器RP2，使a=90°。
断开主电源，按图5－1连线。
3．单相桥式全控整流电路供电给电阻负载。
接上电阻负载，逆时针调节电阻负载至最大，首先短接平波电抗器。闭合电源控制屏主电路电源，调节调速系统控制单元（系统控制单元I）给定"1"脚，求取在不同a角（60°、90°、120°）时整流电路的输出电压Ud=f（t），晶闸管的端电压UVT=f（t）的波形，并记录相应a角，电阻负载Ud和交流输入电压U2值。
Ud
Uvt
Id
a=60
图
图
a=90
图
图
a=120
图
图
4．单相桥式全控整流电路供电给电阻—电感性负载。
断开平波电抗器短接线，求取在不同控制电压"1"脚时的输出电压Ud=f（t），负载电流id=f（t）以及晶闸管端电压UVT=f（t）波形或数值，并记录相应a角。
Ud
Uvt
Id
a=60
图
图
a=90
图
图
a=120
图
图
注意，增加"1"脚使a前移时，若电流太大，可增加与L相串联的电阻加以限流。
实验数据以及实验图像请到主页的资源进行下载！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ac8e498aaf464dc5a1d507b2dce255/" rel="bookmark">
			java-mybatis-自定义interceptor拦截器-获取原生sql补全公共参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java-mybatis-自定义interceptor拦截器-获取原生sql补全公共参数 环境 pgsql + jdk1.8 + mybatis + springboot
一、引言 数据使用PGSQL存储，由于业务场景扩充，使用固定的Schema不能满足业务存储需求，亟需修改代码逻辑将原来在代码中写死的Schema名称改为动态可变形式。
最简单的方法是将所有引用 mySchema 的地方使用 ${schameName} 替换，再修改调用方法调用处，将schemaName传入。
--原查询脚本 select * from mySchema.myTable; --替换后的形式 select * from ${mySchema}.myTable; 之所以用${mySchema}占位符，是因为拼接表名不能使用参数化方式传参；
好吧，全局搜下需要修改的位置，看看有多少：
--查询结果为： Find in Files 300+ matches in 30+ files 分析了匹配的文件，发现引用位置有的在 xml 中，有的在 @Select、@Update等注解中，果断放弃！！！
想到了用mybatis的拦截器，不需要修改调用方法的形参，使用非侵入性的修改就可以完成参数注入；
先看下拦截器相关基础资料。
二、四种mybatis拦截器 Mybatis提供了四个可拦截对象是： Executor sql的内部执行器ParameterHandler 拦截参数的处理StatementHandler 拦截sql的构建ResultSetHandler 拦截结果的处理 这4中不同类型的拦截器的拦截顺序为从上到下的顺序为：
Executor -&gt; ParameterHandler -&gt; StatementHandler -&gt; ResultSetHandler
如果相同类型的拦截器,比如Executor类型的拦截器有两个,则执行顺序为将拦截器添加到SqlSessionFactory的逆向顺序执行；
比如SqlSessionFactory中先添加了Executor类型的A拦截器,在添加了Executor类型的B拦截器,则会先执行B拦截器,再执行A拦截器；
声明拦截器 使用@Intercepts、@Signature注解声明拦截器 @Component @Intercepts({ @Signature(type = StatementHandler.class, method = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ac8e498aaf464dc5a1d507b2dce255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b114fc6aa0dd39d78c457b3d41a376/" rel="bookmark">
			传奇外网架设常见的问题及解决办法-传奇创建人物失败/不开门/PAK显示密码错误/脚本错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传奇外网架设常见的问题及解决办法-传奇创建人物失败/不开门/PAK显示密码错误/脚本错误 在架设传奇的时候是否有遇到无法创建人物、pak密码错误等一系列情况呢？咱们都知道是架设不对的问题，但是具体是哪部分的问题，很多同学都不清楚，今天艾西就跟大家一起交流一下传奇架设经常会遇到的几个问题及解决办法
一、创建人物失败
导致创建人物失败多半是在开区的ID目录和人物目录出现错误而造成的，如果想要解决这个问题请往下看：\mirserver\mud2\DBServer\FDB
\mirserver\mud2\Logsrv\IdDB
无法创建人物有可能是这两个目录下的文件损坏，这两个目录下共5个文件，三个DB，两个索引文件，所有的文件都可以直接使用记事本打开，里面能看到密码和提示问题答案、注册信息等
第二种可能就是DBServer数据库没有勾选【允许创建新人物】，在基本设置勾选就可以了，路径：D盘/Mirserver/DBServer
另外再顺便给大家说一下行会信息的保存目录是在\mirserver\Mir200\Envir\Castle这个路径下保存的，所以，要想解决这个问题的话那么首先需要对此目录文件做出备份，以免在出现错误后无法进行解决，而且通过使用记事本打开这个目录下的文件后还可以进行修改、删除等操作
二、PAK显示密码错误
第一种情况：NewopUI.Pak文件不存在或者密码不正确。这个错误比较好解决，手动把这个服务端的登录器目录下的NewopUI.Pak文件复制到热血传奇客户端目录下，在从新打开即可解决，如果密码不正确，那么在打开登录器文件夹内的pak.txt文件，找到第一排的NewopUI.Pak文件密码，手动复制到PAK查看器上，双击密码的位置，然后粘贴，保存即可。
第二种情况：在配置登陆器的时候PAK根本看到这些文件。因为微端服务器有一个功能，就是把所有的客户端里面的文件都索引出来，但登录器不会，登录器只会读目录下pak.txt里面的内容，所以这些文件就这样出来了。
PAK显示密码错误多半是更新了登录器，PAK没有重新放进去，要重新放进去，然后配置器在重新解压不要用之前的，这样就不会报错了，好多同学都走了不少弯路
三、脚本错误
脚本错误是有分2种情况的，第一种情况先检查一下插件是否有开启，没有开启的话就开启一下 ，一般M2都会提示哪个脚本错误的 第二种情况有可能是引擎版本太低，什么0328、0538这些都是不能用了，如果是用的太低版就会导致脚本错误，需要更新为1108引擎包
四、不开门
不开门就砸门吧，找个技术砸门50，玩笑话哈哈哈。为什么会不开门呢，基本就是loginserver的原因，打开loginserver对应的目录,找到文件!addrtable.txt
请检查一下几个点：
服务器名错误---请核对这里写的服务器和你登陆游戏的游戏名是否一样
服务器IP或本在电脑IP写错---请核对这里的除了127.0.0.1的另两个IP是不是你的外网IP， 所谓外网IP是相对而不是绝对,当你准备开给网吧内部玩的时候,192.168.0.x就是外网IP，当你需要对网吧外部开放时,外网IP就是电信提供的互联网合法IP，传奇内网IP只有一种，那就是127.0.0.1
端口错误---请核对这里的端口和selgate的端口是否对应,一般这里是7100端口,但是为了防止攻击,有经验的人往往为更换这里的端口,不管换成多少,只要对应就可以了,否则不开门
有的人可以登陆,有的人开不了门，原因是因为部分人把IP和服务器写错了,请检查你的网站上登陆器和IP列表是否有错误
adsl用户开传奇,重启了就开不了,因为adsl的外网IP是动态的,每次重启都需要重新设置loginserver对应的目录!addrtable.txt这个文件
版本引擎和登录器不配套 我们知道传奇服务端有很多种，而传奇引擎也有很多种，每一种引擎都需要配上专门的登录器，否则也会无法进入游戏，不开门的情况。这种情况我们可以看看登录器配套问题，登录器的不配套也会出现不开门、不能注册、不能进入游戏的情况。
还有的是版本本身就存在一些不足，在端口正常、登录器配套、名称对应的情况下，还是无法开门，那么这种版本就应该丢了。有不少是福利版本，有的作者是连自己都没有搭建游戏起来查看的，所以难免会出现一些版本本身的问题。在这里不用怀疑自己的技术是不是有问题，是作者技术拉
五、游戏几分钟就自动掉线
游戏几分钟就自动掉线可能是因为登录器里面捆绑了插件，但登录器又不支持该插件导致的，那么插件在哪里呢？在登录器文件夹里面，有一个PlugClient的文件夹，里面就是放登录器插件的，你们打开里面，如果有一个dll文件，那么就是插件
把里面的插件删除，再重新配置一次登录器，在打开，就可以彻底解决自动掉线的问题了
GOM引擎是支持插件的，到需要更新到1108的才行，如果你玩游戏掉线，是因为插件的关系，那么你的引擎一定不是1108的，而是0325的或者其他的低级引擎，他们是不支持插件的，现在大部分GOM引擎的商业插件，都是在最新版引擎上才能支持的，你们更新到1108就可以支持了
更多传奇小知识可以关注我，我是艾西今天的分享就到这里啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1448ed0ea3d2a733f7fc6711b750d2d1/" rel="bookmark">
			网络抓包与发包程序设计(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 1、如何查看源IP地址 打开cmd
ipconfig/all 2、源MAC地址 设置中打开有线网络，查看物理地址
3、目的MAC地址 apr -a 局域网同一子网段内直接发包、以及给服务器发包，目的MAC的选择，要理解清楚，服务器是在其它的网段，那么目的MAC应该是发送者所在网段的网关MAC，网关为192.168.181.254，因此MAC地址为58-69-6c-c9-bd-a2。
二、完整代码 ConfigDialog.java
package chapter11; import java.awt.Desktop; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import javafx.geometry.Insets; import javafx.geometry.Pos; import javafx.scene.Node; import javafx.scene.Scene; import javafx.scene.control.Alert; import javafx.scene.control.Button; import javafx.scene.control.ButtonType; import javafx.scene.control.CheckBox; import javafx.scene.control.ComboBox; import javafx.scene.control.Hyperlink; import javafx.scene.control.Label; import javafx.scene.control.Separator; import javafx.scene.control.TextField; import javafx.scene.control.Alert.AlertType; import javafx.scene.layout.HBox; import javafx.scene.layout.VBox; import javafx.stage.Modality; import javafx.stage.Stage; import jpcap.JpcapCaptor; import jpcap.NetworkInterface; public class ConfigDialog { private JpcapCaptor jpcapCaptor; private String keyData; private NetworkInterface[] devices = JpcapCaptor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1448ed0ea3d2a733f7fc6711b750d2d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb02d50f5575f3dda6a7c55cc4c467e/" rel="bookmark">
			腾讯云轻量应用服务器搭配WordPress程序使用宝塔面板一键式搭建个人博客网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你想要拥有一个自己的网站吗，不在受第三方网站的约束，自由撰写文章帖子，随时随地发挥你的想象。其实搭建一个个人网站没有那么麻烦，完全小白用户也可以办到，只需要点点鼠标就可以完成，下面就详细介绍使用腾讯云轻量应用服务器以及宝塔面板使用开源程序WordPress搭建一个属于自己的网站！
说明：
服务器：腾讯云轻量应用服务器
配置：2核4G6M60GB云盘
操作系统：CentOS 7.6 64bit
PHP版本：7.4
MySQL版本：5.6
操作步骤大致分为以下几个部分：选购云服务器，选域名并备案，安装宝塔面板，安装LNMP环境，一键式安装WordPress，装修网站（配置HTTPS,安装主题，安装插件）,废话不多说，下面就开始操作吧！
一：选购云服务器 云服务器的选择有两种分别为云服务器CVM（阿里云的ECS），以及轻量应用服务器，前者可扩展性更强，可随意升级配置，月流量没有限制，缺点就是不利于新手操作，价格相当稍贵，因此建议选择轻量应用服务器，这篇文章将使用腾讯云的轻量应用服务器作为参考进行操作，配置为2核4G，宽带为6M，系统盘为SSD盘60G，月流量1000GB。这个配置搭建博客完全够用，可参考：腾讯云产品专区-tenxun.dechenyun.com
二：选购域名并备案 选购域名最好是和云服务器选择一个厂商，因为服务器是腾讯云的，因此选购域名也建议在腾讯云选购，备案的时候就比较方便了；
域名建议选择.com结尾的，比如我的dechenyun.com 普通的价格可能在50-80元之间，域名购买之后在国内上线访问是需要备案的，备案国内不是很麻烦，不过需要等半个月左右，提交信息之后，腾讯云会首次审核，客服会吧有问题的地方以及解决方法发送给你，根据要求更改完成并且完全符合要求，腾讯云会提交给工信部审核，审核通过则表示备案成功了，备案相关的可参考：腾讯云域名备案文档
域名购买之后，进入域名列表，点击解析
点击添加记录，根据提示填写主机记录，记录纸为服务器的公网ip地址，填写完成点击保存，等待记录生效即可！
三：安装宝塔面板&amp;安装运行环境 安装宝塔面板可以使接下来的操作更为简单，不在需要使用命令的形式操作，直接在浏览器点击鼠标即可完成，宝塔面板安装有两种方法，第一种是命令安装，第二种则是直接在宝塔网站，填写公网ip，登录用户名，密码即可完成安装！
安装宝塔之前需要开通8888端口，因为宝塔面板默认使用此端口访问。
进入腾讯云轻量应用服务器控制台详情页
点击 防火墙--&gt;添加规则
限制来源：勾选启动
源ip地址：0.0.0.0/0
端口：8888
填写完成之后点击确认即可
1、复制轻量应用服务器公网ip地址。
2、进入宝塔主页：www.bt.cn
点击下载安装，输入IP地址，以及上一步重置的密码，立即安装
注意事项
安装前请确保是 【全新的机器】 ，没有安装其他任何环境，否则会影响您的业务使用！填写好服务器信息， 点击“立即安装到服务器”即全自动完成安装 ，在安装过程中请勿刷新页面！数据传输过程中加密处理，不保存任何账号密码信息，请放心使用。系统兼容性推荐：Centos7.x &gt; Debian10 &gt; Ubuntu 20.04 &gt; Centos8 stream &gt; Ubuntu 18.04 &gt; 其它系统推荐浏览器：Chrome、火狐、edge，国产浏览器请使用极速模式访问面板登录地址如需在线安装请输入服务器公网IP地址 ​在弹出的对话框中选择宝塔面板+LNMP环境，其中PHP环境选择7以上的，不然会出现网站安装完成访问不了的问题。
​
3、安装成功之后，会有弹出，记录上边的内容，下一步要使用登录
​
4、复制上一步面板地址，浏览器访问，输入用户名 密码
​
5、进如宝塔之后需要绑定手机号，按要求绑定即可
​
五：一键式安装WordPress 1、这里选择一键部署的方式，点击 软件商店-&gt;一键部署-&gt;选择WordPress一键部署
​
2、因为我的域名没备案，因此我填写的是ip地址，其他的默认
​
3、安装完成之后保存账号资料
​
4、点击访问站点，出现下面弹出，选择简体中文
​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bb02d50f5575f3dda6a7c55cc4c467e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c2154752c9a3eada3e75c7e6fd91797/" rel="bookmark">
			getSingleton() 过程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在DefaultSingletonBeanRegistry中 有三个getSingleton()方法 其中一个重写，两个重载 getSingleton() 重载方法的区别： 1、访问修饰符:public protected 2、方法签名:方法重载，第一个入参类型相同，第二个入参类型不同 3、方法逻辑： public Object getSingleton(String beanName) 调用getSingleton(String beanName, boolean allowEarlyReference)方法， 允许提前引用，即 allowEarlyReference为true protected Object getSingleton(String beanName, boolean allowEarlyReference) 从注册的单例缓存中获取， 先一级、后二级、没有就看三级，三级有 lambda匿名工厂对象 就调用getEarlyBeanReference()返回bean， 并放入二级缓存，同时删除三级缓存中的记录，否则返回null public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) 在一级缓存中找bean,一级缓存没有， bean创建前，校验是否有异常 没有就通过三级缓存获取 lambda匿名工厂对象 就调用createBean() 返回bean bean创建后，校验是否有异常 此时是完整bean，需要 1、添加到一级缓存，移除二三级缓存 2、添加到单例注册名单 registeredSingletons 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4e6068eb70a5b6fc1f5500250afe59/" rel="bookmark">
			批量创建10个文件夹，只需1秒~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		* 也许有时候你也在烦恼，一个一个创建文件夹，好累呀！今天教你一个简单的方法，用一行命令就可以做到 ls 进入电脑根目录
cd Movies 进入Movies文件夹
输入创建文件夹命令
mkdir 长野博{0..9} // 0-9代表10个文件 输入代码前
输入代码后
* 如果我们想批量删除文件夹呢？ 只需要一个rmdir
rmdir 长野博{0..9} // rm代表remove的意思 输入以上命令，文件夹便全部删除成功
* 同理，如果我们想批量创建文件和删除文件呢?也很简单，用"touch"和"rm -rf"就可以做到 touch file{0..9}.txt // 创建10个文件 rm -rf file{0..9} // rm代表remove的意思 * 以上命令windows电脑和Mac电脑通用呦~ ^ - ^ 觉得对你有帮助的，点个赞再走吧~
​
好了，今天的分享就到这里了！
愿你三冬暖，愿你春不寒；愿你天黑有灯，下雨有伞。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc55458ad69132cf58c8069be208917/" rel="bookmark">
			c/c&#43;&#43;开发时直接调用dll动态库中的函数，无需使用头文件编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开发环境 我写dome用的是Qt5.14.2
二、创建dll 1、搭建生成dll的工程
使用Qt Creator新建一个C++动态库工程
设置类名和所需的Qt库，然后直接下一步
点击完成，完成工程的创建
生成的项目里有以下文件
需要其他的库可以直接在pro文件中进行配置
2、在项目文件中添加代码，实现一个可对外继承QWidget的类
.h文件，ReadDllTest 类继承自QWidget，可以使用Qt的信号与槽函数等等机制。
#include &lt;QWidget&gt; #include &lt;QString&gt; class __declspec(dllexport) ReadDllTest : public QWidget { public: ReadDllTest(QWidget *parent = nullptr); QString getObjStr(); }; .cpp文件，
ReadDllTest::ReadDllTest(QWidget *parent) :QWidget(parent) { // 设置初始位置和大小 resize(100, 100); move(500, 200); // 随意打印一个字符串 qDebug() &lt;&lt; getObjStr(); } // 非QWidget的标准函数 用于测试 QString ReadDllTest::getObjStr() { return QString("这里是对象中的str"); } 3、使用 __declspec(dllexport) 关键字来修饰dll对外的接口，用来获取dll中的对象指针或其他资源。
// 在调用此接口时返回一个基类是QWidget的对象的指针 __declspec(dllexport) QWidget* __stdcall getObj(); 函数实现
// 保存对象指针的全局变量 ReadDllTest *obj = nullptr; // 判断全局变量是否为空 返回基类为QWidget的对象的指针 QWidget *getObj() { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfc55458ad69132cf58c8069be208917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/890e5f7cdbfccbb7ace7497084f8368e/" rel="bookmark">
			css3对页面打印设置的一些特殊属性，如@page，target-counter等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司内部应业务需求，需要将html生成pdf并能打印，前后台都各有方式，这里综合比较选择用java去生成，避免了前端生成带来的诸多问题，后台用的框架是 iTextPdf
但是在做的同时发现用iText实现的pdf生成和公司的业务需要生成的pdf有些差距，在这里遇到的问题是生成的目录、目录页码及点击目录超链接到对应的内容页
有三个问题需要解决
1、生成目录 这里是java循环生成的，这里没什么可记录的
2、目录页码 java同学在这里遇到的问题是没法去生成目录，可能后台插件不到位或者写法有问题，话不多说，上干货
有几个重点需要了解的css
@page，counter(page)，target-counter
2.1 @PAGE 规则
@page规则允许你指定页面盒子的许多方面。例如，你想要指定页面尺寸。下面这条规则指定默认页面尺寸是5.5*8.5英尺
@page { size: 5.5in 8.5in; } 除了可以用长度值声明尺寸，你还可以使用纸质尺寸关键字，例如"A4"或““legal”。
@page { size: A4; } 你也可以使用关键字来指定页面方向 - ““portrait””或“landscape”。
@page { size: A4 landscape; } 2.2 页面模块
2.2.1页面左边距和右边距
页面模块的另一方面是它定义了伪类选择器来选择文档的偶数或奇数页。
@page :left { margin-left: 3cm; } @page :right { margin-left: 4cm; } 规则还定义了两个伪类选择器。:first选择器选中是文档的第一页。
@page :first {} :blank伪类选择器选中任何“故意左侧留白”的页面。要添加这样的文字，我们可以使用目标是边距盒顶部中心的生成内容。
@page :blank { @top-center { content: "This page is intentionally left blank." } } 生成内容和页面媒体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/890e5f7cdbfccbb7ace7497084f8368e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8dd30432dc3da8d6886cd519f0cc82/" rel="bookmark">
			【微信小程序】滚动锚点核心代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能说明 展示方式为竖向平铺支持点击切换Tab，并且自动锚至对应目标支持滚动切换Tab，对应锚点滚动到对应位置时自动切换tab 效果图 组件代码 获取关键元素的滚动高度位置信息，并存储起来，在点击对应tab的时候只需将标签绑定的scroll-top属性赋值对应锚点的高度即可达到点击tab滚动切换的效果 // 获取关键元素位置信息 const handleImageLoad = () =&gt; { const query = Taro.createSelectorQuery() query .select('#tabContent') .boundingClientRect(res =&gt; { content.value.headImg.top = res.top }) .exec(rect =&gt; {}) query .select('#formWrap') .boundingClientRect(res =&gt; { content.value.formTop = res.top }) .exec(rect =&gt; {}) content.value.tabMap.forEach(ele =&gt; { query .select(`#${ele.id}`) .boundingClientRect(res =&gt; { ele.top = res.top - 44 }) .exec() }) tabs.value = content.value.tabMap.filter(t =&gt; !t.tabIgnore) } 滚动切换tab的关键就是监听页面的滚动位置，在标签中可以使用@scroll="scroll"事件监听滚动位置，示例代码如下 // 监听滚动事件 const scroll = e =&gt; { scorllValue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d8dd30432dc3da8d6886cd519f0cc82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e14fb9b32e7f8503a7c67a6a5a4209/" rel="bookmark">
			JS标准内置对象 数组 的 34 个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先放一个语雀的链接： https://www.yuque.com/docs/share/13314a2f-05c0-4de6-8d61-8acd9e566ad4?# 《JS内置对象 Array》 1. at（）接收一个整数值并返回该索引对应的元素 at() 方法接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。
at() 方法是通用的。其仅期望 this 具有 length 属性和以整数为键的属性。
const array1 = [5, 12, 8, 130, 44]; let index = 2; console.log(`Using an index of ${index} the item returned is ${array1.at(index)}`); // expected output: "Using an index of 2 the item returned is 8" index = -2; console.log(`Using an index of ${index} item returned is ${array1.at(index)}`); // expected output: "Using an index of -2 item returned is 130"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1e14fb9b32e7f8503a7c67a6a5a4209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d9a272d47f3191ac1e7f8f12b1b65c/" rel="bookmark">
			springboot基础篇（快速入门 &#43; 完整项目案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.springboot简介2.REST风格1.简介2.RESTful 3.复制工程4.属性配置1.application.properties2.application.yml、.yaml3.关于写配置文件的时候没有提示的解决方案4.yaml1.语法格式2.读取数据3.封装对象 5.整合第三方技术1.整合Junit1.实现2.注意事项 2.整合mybatis3.整合mybatis-plus4.整合Druid 6.完结案例1.项目初始化2.数据库搭建&amp;数据源配置3.测试Mybatis-plus1.增删改查2.分页查询3.条件查询 4.业务层开发1.业务接口与实体类2.测试类3.MP业务层快速开发 5.表现层开发1.表现层代码2.接口测试3.表现层消息一致性处理4.异常消息处理 6.前后端协议联调 1.springboot简介 SpringBoot程序优点：
起步依赖（简化依赖配置）
parent
所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的
自动配置（简化常用工程相关配置）
stater
SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标，以达到减少依赖配置的目的
引导类
springboot的启动方式：
SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目 SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean
辅助功能（内置服务器，……）
内嵌Tomcat
2.REST风格 1.简介 REST（Representational State Transfer）： 表现形式状态转换。
传统风格资源描述形式：
http://localhost/user/getById?id=1
http://localhost/user/saveUserREST风格描述形式：
http://localhost/user/id=1
http://localhost/user优点： 隐藏资源的访问行为，无法通过地址得知对资源是何种操作 书写简化 REST风格访问资源时使用 行为动作 区分对资源进行了何种操作
查询 GET新增/修改 POST修改/更新 PUT删除 DELETE 2.RESTful RESTful：按照REST风格对资源进行访问。
通过 @RequestMapping 注解的路径设置，通过 @PathVariable 注解绑定参数
@PostMapping @GetMapping @DeleteMapping @PutMapping @RestController 类注解
基于SpringMVC的RESTful开发控制器类定义上方
设置当前控制器类为RESTful风格，等同于@Controller与@RresponseBody组合 @RequestBody、 @RequestParam 、 @PathVariable 和 @Vaild 注解的使用及区别
3.复制工程 原则：
保留工程基础结构抹掉原始工程痕迹 步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d9a272d47f3191ac1e7f8f12b1b65c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df81aad25fd5434809dfd28fb56853b/" rel="bookmark">
			如何将视频的每一帧提取成图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于如何将视频的每一帧提取成图片 有时候我们需要将视频按帧提取出来，但是一个普通的24帧的视频每秒就有24张图片，一分钟的视频就有1440张图片，如果一帧一帧的截取，那无疑十分的浪费时间，而且如何按帧播放也让人头疼，那么如何做到呢，这里我们采用ffmpeg来进行操作，关于这是什么就不赘述了，话不多说看正文。
下载 ffmpeg下载地址
安装 下载之后解压，bin文件夹里有一个ffmpeg.exe，这里我们需要用命令行打开，点击Win+R，输入CMD，打开命令行工具，然后输入ffmpeg.exe，就可以打开了。出现下面的界面即可：
操作 这个时候用cd命令切换到想要保存图片的文件夹目录下，输入ffmpeg -i src01.avi -r 5 %d.jpg，点击回车即可，就会在ffmpeg.exe的文件夹下生成1.jpg，2.jpg等，其中src01.avi是源视频文件，如果不在当前目录下需要加上路径，-r是隔帧抽取，后面跟的数字5表示隔5帧抽取一帧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bd8862543924fa770667620a800cace/" rel="bookmark">
			lsyncd实时同步工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先介绍一下架构
有3台app服务器，每次上线，是通过shell脚本将代码传输至app_1
然后app_1自动同步到app_2和app_3
代码路径为/www
有一台code服务器，专门用来下载所有服务器代码的。
路径为/data
最开始的同步策略是rsync+inotify
用了一段时间，发现有时会出现app_2和app_3没有同步代码的问题。
发现是因为inotify的shell脚本，意外终止了。
后来发现有unison，测试发现，还是要写shell脚本
再后来sersync，这个是基于rsync的，需要有rsync客户端和服务端，比较麻烦
配置文件是xml。
最后用的是lsyncd
Lysncd 实际上是lua语言封装了 inotify 和 rsync 工具，采用了 Linux 内核（2.6.13 及以后）里的 inotify 触发机制，然后通过rsync去差异同步，达到实时的效果。
完美解决了 inotify + rsync海量文件同步带来的文件频繁发送文件列表的问题 —— 通过时间延迟或累计触发事件次数实现。
有2种方法可以安装
yum安装，前提是安装了epel更新源。使用命令：yum install -y lsyncd
github下载，地址为：https://github.com/axkibe/lsyncd
我用的是github方式，因为版本是比yum要新一点
软件部署：
app_1,app_2,app_3必须要安装rsync
必须要有/usr/bin/rsync文件
这3台服务器，必须要拥有/usr/bin/rsync文件
这3台服务器，必须要拥有/usr/bin/rsync文件
这3台服务器，必须要拥有/usr/bin/rsync文件
重要的事情说三遍！
app_1必须能无密码登录app_2和app_3
ssh秘钥认证，请自行百度。
app_1只需要安装lsyncd就可以了
3台rsync配置文件，不需要创建，不需要修改
安装lua软件包
yum install -y lua lua-devel
解压下载的压缩包
unzip lsyncd-master.zip -d /usr/src/
进入目录
cd /usr/src/lsyncd-master/
使用cmake编译，如果没有安装cmake,可以yum安装一下
cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lsyncd
make &amp;&amp; make install
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bd8862543924fa770667620a800cace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da37164da652bb0c4dfe047afa29deaa/" rel="bookmark">
			Linux 压缩、解压缩和文件切割的学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Linux 压缩、解压缩和文件切割的学习笔记 单文件的压缩和解压缩compress 和 uncompressgzip、gunzip 和 zcatbzip2、bunzip2、bzcat 和 bzip2recoverxz、unxz 和 xzcat 目录打包和压缩ziptarcpio 用于分隔文件split 分割 Linux 压缩、解压缩和文件切割的学习笔记 Linux 中有许多压缩和解压的命令，有些是针对文件进行压缩，有些用于目录的归档及压缩。其中，只能用于文件压缩和解压的命令有：compress, uncompress, gzip, gunzip, bzip2, bunzip2, xz, xunzip。可以用于打包归档的有：zip, unzip, tar, cpio。用于分隔打包文件的命令有：split。 备注：以下命令的帮助文档是依据 CentOS 8.5 获取的。
单文件的压缩和解压缩 compress 和 uncompress 该工具比较古老，压缩比不高，现在不常用。如果需要安装 ncompress 包。
yum provides compress yum install -y ncompress rpm -ql ncompress /usr/bin/compress /usr/bin/uncompress ...... 格式和常用选项：
compress [options] [file...] -f 不会提示覆盖现存的文件 -d 解压缩，相当于 uncompress -c 将结果输出至标准输出，不改变原文件 -r 递归操作目录 -v 显示详情 compress 压缩后，每个文件都会替换成追加扩展名为 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da37164da652bb0c4dfe047afa29deaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d3ea23a1e029b5986efc91d30bf0dba/" rel="bookmark">
			SpringBoot项目启动后自动关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目启动后自动关闭截图: 原因：版本锁定了低版本的spring-boot-web-starter 解决方案：手动导入高一点版本的，刷新maven 运行成功： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530620644b839aa4a184b32aab7e79a1/" rel="bookmark">
			【FME实战教程】001：FME2020中文安装图文教程（附安装包下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 安装license2. 安装FME Desktop3. 安装中文语言4. FME软件下载地址 1. 安装license 打开软件安装包中的fme-flexnet-win-x64.msi，如下图所示：
点击Next。
点击Next。
单击install。
点击finish，完成。
（1）修改dummy.txt
打开安装包中的dummy.txt。从安装路径下的hostid.txt中读取两个值并修改。
修改：
（2）生成safe.lic
双击makekey.bat，生成新的safe.lic。
（3）配置服务
在安装路径下打开imtools.exe。
2. 安装FME Desktop 输入计算机名。
3. 安装中文语言 点击安装包中的FME_2020_Chinese_x64.msi开始安装。点击下一步。
点击下一步。
点击下一步。
安装完成即可。
4. FME软件下载地址 链接：https://pan.baidu.com/s/1pgq6YiqY-30E1c2rg1w9_A?pwd=albv
提取码：albv
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a0b80b42ae4f9aa5fd508e2ee1a576/" rel="bookmark">
			【Android Studio】常用布局 --- 滚动视图ScrollView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题引入：手机屏幕的显示空间有限，常常需要上下滑动或左右滑动才能拉出其余页面内容，可惜一般的布局节点 都不支持自行滚动，这时就要借助滚动视图了。与线性布局类似，滚动视图也分为垂直方向和水平方向 两类，其中垂直滚动视图名为ScrollView，水平滚动视图名为
HorizontalScrollView 这两个滚动视图的 使用并不复杂，
主要注意以下3点：
（1）垂直方向滚动时，layout_width属性值设置为match_parent，layout_height属性值设置为wrap_content。
（2）水平方向滚动时，layout_width属性值设置为wrap_content，layout_height属性值设置为match_parent。
（3）滚动视图节点下面必须且只能挂着一个子布局节点，否则会在运行时报错。
Caused by：java.lang.IllegalStateException：ScrollView can host only one direct child 下面是垂直滚动视图ScrollView和水平滚动视图HorizontalScrollView的XML例子：
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;!-- HorizontalScrollView是水平方向的滚动视图，当前高度为200dp --&gt; &lt;HorizontalScrollView android:layout_width="wrap_content" android:layout_height="200dp"&gt; &lt;!-- 水平方向的线性布局，两个子视图的颜色分别为青色和黄色 --&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;View android:layout_width="300dp" android:layout_height="match_parent" android:background="#aaffff" /&gt; &lt;View android:layout_width="300dp" android:layout_height="match_parent" android:background="#ffff00" /&gt; &lt;/LinearLayout&gt; &lt;/HorizontalScrollView&gt; &lt;!-- ScrollView是垂直方向的滚动视图，当前高度为自适应 --&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;!-- 垂直方向的线性布局，两个子视图的颜色分别为绿色和橙色 --&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;View android:layout_width="match_parent" android:layout_height="400dp" android:background="#00ff00" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24a0b80b42ae4f9aa5fd508e2ee1a576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aac95f6038ccf62ffb25dd7967564c8/" rel="bookmark">
			Linux 下 N 卡 GPU 测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在win系统下测试工具比较多，现在 N 卡多用于深度学习，有时候会在 Linux下进行 N 卡测试。
测试工具 gpu-burn: Multi-GPU CUDA stress test，github地址：https://github.com/wilicc/gpu-burn
动手能力强的同学可以直接看 README.md 文档。我来说下我的测试过程。
补充一点，现在各种信息鱼龙混杂，遇到问题先找官网资料！
主要原理：利用Nvidia发布的Cuda镜像，在容器里编译后测试。用到的软件：
CentOS/Ubuntu 等发行版系统；N卡驱动，尽量用最新的驱动；Docker-ce 和 nvidia-container-runtimeNvidia 发布的Cuda镜像gpu-burn 步骤：
1、安装系统和nvidia驱动 系统下载可以到阿里云和国内镜像源，安装可以自行搜索；
驱动安装可以到Nvidia官网下载 Linux 驱动，安装过程也很简单。
驱动地址给个官方路径：Official Drivers | NVIDIA
安装完成，可以通过 nvidia-smi 进行验证，能看到显卡信息即正常。
2、安装 docker 和 nvidia-container-runtime docker的安装可以参考阿里云的步骤，或者直接看官方资料。
安装 nvidia-container-runtime，参考文档，安装也比较简单：
https://github.com/NVIDIA/nvidia-container-runtime
nvidia-container-runtime 是帮助docker在容器里调用到宿主机GPU。
3、nvidia发布的docker镜像 cuda镜像的Docker Hub地址：nvidia/cuda Tags | Docker Hub
比如：docker pull nvidia/cuda:11.2.0-cudnn8-devel-ubuntu18.04
在选镜像的时候注意，一般下载devel版本，不要选在runtime版本，devel版本，开发用的包比较完整，一般选cudnn装好的版本，开发cuda，cudnn一般是必备的，最最重要的是cuda版本不要太高，不能高于刚刚安装的驱动支持的cuda版本，其他的根据你的爱好去选就好了。
这个过程比较考验你的网速了，现在的cuda的镜像都要2G+了
4、下载gpu burn开始测试 从github下载最新版本：GitHub - wilicc/gpu-burn: Multi-GPU CUDA stress test
https://github.com/NVIDIA/nvidia-container-runtime/archive/refs/heads/main.zip
下载好，上传到服务器上，比如放在 gputest 目录下，开始启动容器测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aac95f6038ccf62ffb25dd7967564c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5591d8b48878a6fc7889cac5296afeae/" rel="bookmark">
			三子棋游戏（超级详解，附加电脑下棋优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一，游戏规则
二，游戏步骤
三，游戏实现
3.1游戏构思和框架
3.2 棋盘的初始化和打印
3.3 玩家和电脑下棋的实现
3.4 判断输赢
3.5 游戏平局
3.6 游戏头文件game.h
四，电脑下棋优化
五，游戏总代码
前言 继上一次的猜数字小游戏以后，我们再来个更加锻炼一个逻辑的游戏，这个游戏比上个代码多，但很能考验我们的逻辑能力。逻辑能力上来了，以后做项目，编写程序的时候就不会太吃力。话不多说，先来一张美图，直接开始。
一，游戏规则 跟小时候在作业本上画个“井”子格一样，谁先连成一条线谁赢。如果棋盘满了还没有分出胜负，则平局。只不过这次在电脑上和人机下棋，在电脑上显示“井”子格。这次玩家棋子用“ # ”表示，电脑用“ * ”表示。
二，游戏步骤 游戏的步骤如下：
第一步，玩家下棋
第二步，电脑下棋
第三步，如果没分出胜负重复1,2步骤，一旦有一方胜利就终止游戏。
另外还要注意的是：
1，在游戏步骤执行之前，我们想一下，在开始之前应该有一个菜单，来满足我们是否要选择玩游戏。而游戏结束之后应该跳到菜单界面，由玩家选择是否还要玩游戏。
2，在执行游戏步骤的时候，玩家和电脑下棋之后到要进行判断输赢。
3，三子棋总共有九格，那三子棋的实现就应该是用3*3二维数组来实现，每一个格子放一个数。更何况我们不能直接在屏幕上来下，我们可以用坐标来代替，而二维数组正好可以满足要求。
三，游戏实现 3.1游戏构思和框架 这次我们把这个游戏分别放在不同的文件中，游戏框架放在test.c源文件中，游戏实现放在game.c源文件中，函数声明放在game.h头文件中。
我们现在头文件里添加个库函数&lt;stdio.h&gt;,然后把3分别赋值给ROW，LOW这样做是为了以后要是写四子棋，五子棋时只用修改ROW和LOW赋的值就行了。
//game.h #include&lt;stdio.h&gt; #defile ROW 3 #defile COL 3 然后我们将头文件test.h作为test.c的库函数（这样就相当于直接调用test.h里的内容了）和游戏框架如下所示：
//test.c #include"game.h" void mune() { printf("******************************\n"); printf("******** 1.开始游戏 **********\n"); printf("******** 0.退出游戏 **********\n"); printf("******************************\n"); } int main() { int input = 0; srand((unsigned)time(NULL)); //随机数的起点，后面会提到 do { mune();//打印游戏菜单 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5591d8b48878a6fc7889cac5296afeae/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/122/">«</a>
	<span class="pagination__item pagination__item--current">123/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/124/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>