<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844a1bec44c778107f424d55989ddf4e/" rel="bookmark">
			防止页面被客户端缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/jie_liang/article/details/54585061
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca1de671e068bd8c2b6349473cb6f4c4/" rel="bookmark">
			关于ant design vue中的自定义上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在项目中遇到了这样的一个问题，使用ant design vue中的自定义上传功能时，无法显示图片的缩略图。如下图所示:
解决方法： 在自定义上传成功后调用onSuccess()方法
1、在a-upload组件中定义:customRequest="customUpload".
&lt;a-upload list-type="picture-card" :file-list="fileList" @preview="handlePreview" @change="handleChange" :customRequest="customUpload" &gt; &lt;div v-if="fileList.length &lt; 8"&gt; &lt;a-icon type="plus" /&gt; &lt;div class="ant-upload-text"&gt;Upload&lt;/div&gt; &lt;/div&gt; &lt;/a-upload&gt; &lt;a-modal :visible="previewVisible" :footer="null" @cancel="handleCancel_"&gt; &lt;img alt="example" style="width: 100%" :src="previewImage" /&gt; &lt;/a-modal&gt; 2、在上传成功之后调用onSuccess()方法
// 自定义上传 customUpload(data) { const formData = new FormData() formData.append('fileList', data.file) formData.append('c1003Woid', this.taskForm.C1003_WOID) // 上传携带额外参数 uploadFile(formData).then((res) =&gt; { if (res.data.status == 200) data.onSuccess() // 自定义上传成功后一定要调用onSuccess(),不然就会一直保持在上传中这个状态，无法显示图片的缩略图 }) } 结果如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c86d3128a1e4be379bb56a89910588c8/" rel="bookmark">
			sql语句 where 后条件执行先后顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结论如下：
针对mysql，其条件执行顺序是 从左往右，自上而下
针对orcale，其条件执行顺序是从右往左，自下而上
mysql
where执行顺序是从左往右执行的，在数据量小的时候不用考虑，但数据量多的时候要考虑条件的先后顺序，此时应遵守一个原则：排除越多的条件放在第一个
在用MySQL查询数据库的时候，连接了很多个过滤条件，发现非常慢。例如：SELECT … WHERE p.languages_id=1 AND t.type=1 AND p.products_id IN (472,474)，这样查询需要20多秒，虽然在各个字段上都建立了索引。用分析Explain SQL一分析，发现在第一次分析过程中就返回了几万条数据：WHERE p.languages_id=1 ，然后再依次根据条件缩小范围。
然后稍微改变一下WHERE字段的位置之后，速度就有了明显地提高：WHERE p.products_id IN (472,474) AND p.languages_id=1 AND t.type=1，这样第一次的过滤条件是p.products_id IN (472,474)，它返回的结果只有不到10条，接下来还要根据其它的条件来过滤，自然在速度上有了较大的提升。经过实践发现，不要以为WHERE中的字段顺序无所谓，可以随便放在哪，应该尽可能地第一次就过滤掉大部分无用的数据，只返回最小范围的数据
最新发现：
大多时候mysql会自动根据sql语句做出优化，使用最优的sql语句进行查询
补充：
有时候mysql无法根据sql语句做出最优的优化顺序，所以还是要我们自己预判断出哪种过滤是最优，毕竟自己才最懂自己的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a141aee93557b86f01f9e7f9add8d06b/" rel="bookmark">
			Numpy将字符串数组转换为浮点数数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		e.g.
import numpy as np x = np.array(['1.1', '1.2', '1.3']) y = x.astype(np.float) 输出结果：
Python 3.8.1 (default, Jan 8 2020, 16:15:59)
[Clang 4.0.1 (tags/RELEASE_401/final)] on darwin
import numpy as np
…: x = np.array([‘1.1’, ‘2.2’, ‘3.3’])
…: y = x.astype(np.float)
print(x)
[‘1.1’ ‘2.2’ ‘3.3’]
print(y)
[1.1 2.2 3.3]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cebade87ae9ec4c46a2542b640315c/" rel="bookmark">
			Apache poi HSSFWorkbook 操作excel教程2（从excel文件导入数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://www.hangge.com/blog/cache/detail_2722.html
叙述 在之前的文章中演示了如何实现数据的导出，本文接着演示如何实现数据导入。对前端而言，数据导入就是文件上传，对后端这边则是获取上传的文件进行解析，并把解析出来的数据保存到数据库中。
解决方案 1，添加依赖
编辑项目的 pom.xml 文件，添加 poi 相关依赖：
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; 2，创建数据模型
这里我们定义一个 User 模型对象，后面将会把解析出来的数据转成这个数据模型集合。
@Getter @Setter @AllArgsConstructor @NoArgsConstructor @ToString public class User { private int id; private String name; private String gender; private Date birthday; private String workID; } 3，创建导入工具类
为方便使用，这里封装一个用于导入数据的工具类。里面主要工作是获取上传文件的流，然后进行解析，最终将得到的数据集合返回。
public class PoiUtils { // 从excel文件中导入数据 public static List&lt;User&gt; importUser2List(MultipartFile file) { List&lt;User&gt; users = new ArrayList&lt;&gt;(); try { // 根据上传文件的流获取一个 HSSFWorkbook 对象 HSSFWorkbook workbook = new HSSFWorkbook(new POIFSFileSystem(file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8cebade87ae9ec4c46a2542b640315c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41215aea304659c9a1acd990de0552fc/" rel="bookmark">
			linux下ps命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下ps命令 Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，
就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。
要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。
命令参数： a 显示所有进程 -a 显示同一终端下的所有程序 -A 显示所有进程 c 显示进程的真实名称 -N 反向选择 -e 等于“-A” e 显示环境变量 f 显示程序间的关系 -H 显示树状结构 r 显示当前终端的进程 T 显示当前终端的所有程序 u 指定用户的所有进程 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 -C&lt;命令&gt; 列出指定命令的状况 --lines&lt;行数&gt; 每页显示的行数 --width&lt;字符数&gt; 每页显示的字符数 --help 显示帮助信息 --version 显示版本显示 1. pstree pstree以树结构显示进程
$ pstree -p work | grep ad
sshd(22669)---bash(22670)---ad_preprocess(4551)-+-{ad_preprocess}(4552) |-{ad_preprocess}(4553) |-{ad_preprocess}(4554) |-{ad_preprocess}(4555) |-{ad_preprocess}(4556) `-{ad_preprocess}(4557) work为工作用户，-p为显示进程识别码，ad_preprocess共启动了6个子线程，加上主线程共7个线程
2. ps -Lf $ ps -Lf 4551
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41215aea304659c9a1acd990de0552fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9164610a422cf1bb8d87ee0b0ec70139/" rel="bookmark">
			Java 多线程总结01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 多线程 什么是进程： 进程是系统中正在运行的一个程序，程序一旦运行就是进程。
进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道，文件，套接字等。
什么是线程 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
线程的三种实现方式 3.1继承Thread类 Thread类构造方法：
1.Thread（）；
2.Thread（String name）；
3.Thread（Runable r）；
4.Thread（Runable r, String name）；
public class ExtendThread extends Thread { @Override public void run() { System.out.println("继承Thread类实现线程.......Name:"+this.getName()+" Id:"+this.getId()); } public static void main(String[] args) { Thread thread = new ExtendThread(); thread.start(); } } Thread 类常用方法
start();//启动线程
getId();//获得线程ID
getName();//获得线程名字
getPriority();//获得优先权
isAlive();//判断线程是否活动
isDaemon();//判断是否守护线程
getState();//获得线程状态
sleep(long mill);//休眠线程
join();//等待线程结束
yield();//放弃cpu使用权利
interrupt();//中断线程
currentThread();//获得正在执行的线程对象
3.2.实现Runnable接口 public class ImpRunnable implements Runnable { @Override public void run() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9164610a422cf1bb8d87ee0b0ec70139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da6176e81275de682288c34a8d8a6e5/" rel="bookmark">
			CodeMirror 使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CodeMirror 使用方法
初步建立步骤
npm install codemirror下载组件
引入核心配置包
import * as CodeMirror from 'codemirror/lib/codemirror' import 'codemirror/lib/codemirror.css' 引入后在html界面中建立textarea标签，用于生成代码框
&lt;textarea class="form-control" id="code" name="code"&gt;&lt;/textarea&gt; 根据textarea的id获取到标签元素，将容器转换为编辑器
let myTextarea = document.getElementById('editor'); this.CodeMirrorEditor = CodeMirror.fromTextArea(myTextarea, { mode:'javascript'//编辑器语言 theme:'monokai', //编辑器主题 extraKeys: {"Ctrl": "autocomplete"},//ctrl可以弹出选择项 lineNumbers: true//显示行号 }); 5.根据设置的主题，引入相应的主题包,主题包存储在theme下，使用其他主题包时设置option中theme为对应主题
import 'codemirror/theme/monokai.css' 6.根据设置的编辑器语言，引入相应工具包,以下为常用语言包
import 'codemirror/mode/javascript/javascript' import 'codemirror/mode/clike/clike' import 'codemirror/mode/go/go' import 'codemirror/mode/htmlmixed/htmlmixed' import 'codemirror/mode/http/http' import 'codemirror/mode/php/php' import 'codemirror/mode/python/python' import 'codemirror/mode/http/http' import 'codemirror/mode/sql/sql' import 'codemirror/mode/vue/vue' import 'codemirror/mode/xml/xml' 7.初始化编译器时可设置属性：
value:初始内容
Mode:设置编译器编程语言关联内容，对应的mine值
Theme:编译器的主题，需要引入对应的包
tabSize：tab的空格宽度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1da6176e81275de682288c34a8d8a6e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d719f0a0ae2535d72c50b8edaf05af8/" rel="bookmark">
			[acwing面向模型编程]背包九讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：6. 多重背包问题 III 分析： 单调队列优化多重背包，时间复杂度O(N * V)
（也可用二进制优化做，不过复杂度多一个 l o g log log）
代码： #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; //typedef __int128 lll; #define print(i) cout &lt;&lt; "debug: " &lt;&lt; i &lt;&lt; endl #define close() ios::sync_with_stdio(0), cin.tie(0), cout.tie(0) #define mem(a, b) memset(a, b, sizeof(a)) const ll mod = 1e9 + 7; const int maxn = 3e4; const int inf = 0x3f3f3f3f; int n, m; int dp[maxn], last[maxn], q[maxn]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { int w, v, num; cin &gt;&gt; w &gt;&gt; v &gt;&gt; num; memcpy(last, dp, sizeof(dp)); for(int j = 0; j &lt; w; j++) { int l = 0, r = -1; for(int k = j; k &lt;= m; k += w) { while(l &lt;= r &amp;&amp; q[l] &lt; k - num * w) l++; while(l &lt;= r &amp;&amp; last[k] &gt; last[q[l]] + (k - q[l]) / w * v) r--; q[++r] = k; dp[k] = last[q[l]] + (k - q[l]) / w * v; } } } cout &lt;&lt; dp[m] &lt;&lt; endl; } 题目：1020.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d719f0a0ae2535d72c50b8edaf05af8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07479dc898c166baa727db0d2a30b6a/" rel="bookmark">
			Spring-----声明式事务管理-xml方式配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.准备配置文件 1.1 在配置文件中引入新的命名空间 tx
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" **xmlns:tx="http://www.springframework.org/schema/tx"** xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd "&gt; 1.2 在配置文件中配置包扫描,读取配置文件,并配置数据源,配置jdbcTemplate
&lt;!--配置包扫描--&gt; &lt;context:component-scan base-package="com.sxt"/&gt; &lt;!--读取配置文件--&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!--配置数据源--&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt; &lt;property name="url" value="${jdbc.url}"/&gt; &lt;property name="username" value="${jdbc.username}"/&gt; &lt;property name="password" value="${jdbc.password}"/&gt; &lt;/bean&gt; &lt;!--配置jdbcTemolate--&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;constructor-arg name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; 二.配置事务管理器 Spring对事务的支持，必须先配置事务管理器，事务管理器已经封装了事务的具体的处理
DataSourceTransactionManager
使用JDBC,MyBatis的事务管理器；(当前案例使用的Spring的JDBC操作,所以配置这个)
&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!--事务管理器里面,需要注入dataSource --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; 三.配置事务通知/增强 &lt;tx:advice id="txAdvice" transaction-manager="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d07479dc898c166baa727db0d2a30b6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef1107c35ff6c782b63cc56b465970b/" rel="bookmark">
			AJAX跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是AJAX跨域问题、产生AJAX跨域问题的原因 什么是AJAX跨域问题
简单来说，就是前端调用后端服务接口时如果服务接口不是同一个域，就会产生跨域问题 AJAX跨域场景
前后端分离、服务化的开发模式前后端开发独立，前端需要大量调用后端接口的场景只要后端接口不是同一个域，就会产生跨域问题跨域问题很普遍，解决跨域问题也很重要 AJAX跨域原因
浏览器限制：浏览器安全校验限制跨域（协议、域名、端口任何一个不一样都会认为是跨域）XHR（XMLHttpRequest）请求 二、AJAX跨域解决方式 AJAX跨域问题解决思路
浏览器：浏览器取下跨域校验，实际价值不大XHR：不使用XHR，使用JSONP，有很多弊端，无法满足现在的开发要求跨域：被调用方修改支持跨域调用（指定参数）；调用方修改隐藏跨域（基于代理） 1、禁止浏览器检查 cmd启动的时候添加参数关闭安全检测
--disable-web-security --user-data-dir=C:MyChromeDevUserData 2、JSONP package com.xjn.ajax.server.controller; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.servlet.mvc.method.annotation.AbstractJsonpResponseBodyAdvice; /** * &lt;br&gt; * 标题: JSONP 全局处理&lt;br&gt; * 描述: 统一处理JSONP&lt;br&gt; */ @ControllerAdvice public class JsonpAdvice extends AbstractJsonpResponseBodyAdvice{ public JsonpAdvice() { // 与前端约定好回调方法名称，默认是callback super("callback"); } } $.ajax({ url: base + "/get1", dataType: "jsonp", jsonp:"callback", success: function (res) { result = res; } }); jsonp实际原理是在url后面拼接一串字符，使浏览器知道自己是jsonp请求。所以仅适用于get方法请求，后端返回来的数据经过jsonpadvice配置，返回的是javascript数据。
3、支持跨域 方法一：被调用方支持跨域
被调用方解决，基于支持跨域的解决思路，基于Http协议关于跨域的相关规定，在响应头里增加指定的字段告诉浏览器，允许调用跨域请求是直接从浏览器发送到被调用方，被调用方在响应头里增加相关信息，返回到页面，页面能正常获取请求内容。
过滤器java代码
import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ef1107c35ff6c782b63cc56b465970b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b3bcf703e58fdaa140b6cfb7c659f0/" rel="bookmark">
			PyCharm 编写 Numpy 程序时报 No module named ‘numpy‘ 错误的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者背景是 Python 3.7.1，pycharm-professional-2018.3.5，程序中 import numpy as np，编译执行时报错 No module named ‘numpy’：
解决办法是 PyCharm 安装 numpy 并导入。
打开 PyCharm，查看项目 site-packages 如下：
确实没有 numpy。
PyCharm，File --&gt; Settings… -&gt; Project: 你的项目名 -&gt; Project Interpreter，该列表中展示的就是已导入的 site-packages，点列表右侧的加号，在 Available Packages 列表中找到 numpy 并将其选中，然后点 Install Package 按钮：
安装结束后发现 numpy 已经在 Project Interpreter 中：
再次查看查看项目 site-packages 也可以看到 numpy 已导入：
最后再次执行该 Python 程序，已不再报 No module named ‘numpy’ 错误：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d513561f5b910f416e8b3beff6a89bf0/" rel="bookmark">
			[Python人工智能] 二十三.基于机器学习和TFIDF的情感分类（含详细的NLP数据清洗）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从本专栏开始，作者正式研究Python深度学习、神经网络及人工智能相关知识。前一篇文章分享了自定义情感词典（大连理工词典）实现情感分析和情绪分类的过程。这篇文章将详细讲解自然语言处理过程，基于机器学习和TFIDF的情感分类算法，并进行了各种分类算法（SVM、RF、LR、Boosting）对比。这篇文章主要结合作者的书籍《Python网络数据爬取及分析从入门到精通（分析篇）》进行讲解，再次带领大家好好看看Python中文文本分析的基本步骤。个人感觉还不错，基础性文章，希望对您有所帮助~
本专栏主要结合作者之前的博客、AI经验和相关视频及论文介绍，后面随着深入会讲解更多的Python人工智能案例及应用。基础性文章，希望对您有所帮助，如果文章中存在错误或不足之处，还请海涵！作者作为人工智能的菜鸟，希望大家能与我在这一笔一划的博客中成长起来。写了这么多年博客，尝试第一个付费专栏，为小宝赚点奶粉钱，但更多博客尤其基础性文章，还是会继续免费分享，该专栏也会用心撰写，望对得起读者。如果有问题随时私聊我，只望您能从这个系列中学到知识，一起加油喔~
TF下载地址：https://github.com/eastmountyxz/AI-for-TensorFlow
Keras下载地址：https://github.com/eastmountyxz/AI-for-Keras
情感分析地址：https://github.com/eastmountyxz/Sentiment-Analysis
文章目录 一.中文分词二.数据清洗三.特征提取及TF-IDF计算1.基本概念2.代码实现3.MemoryError内存溢出错误 四.基于逻辑回归的情感分类五.算法性能评估六.算法对比实验1.RandomForest2.SVM3.朴素贝叶斯4.KNN5.决策树6.SGD7.MLP8.GradientBoosting9.AdaBoost 七.总结 同时推荐前面作者另外五个Python系列文章。从2014年开始，作者主要写了三个Python系列文章，分别是基础知识、网络爬虫和数据分析。2018年陆续增加了Python图像识别和Python人工智能专栏。
Python基础知识系列：Python基础知识学习与提升Python网络爬虫系列：Python爬虫之Selenium+BeautifulSoup+RequestsPython数据分析系列：知识图谱、web数据挖掘及NLPPython图像识别系列：Python图像处理及图像识别Python人工智能系列：Python人工智能及知识图谱实战 前文：
[Python人工智能] 一.TensorFlow2.0环境搭建及神经网络入门
[Python人工智能] 二.TensorFlow基础及一元直线预测案例
[Python人工智能] 三.TensorFlow基础之Session、变量、传入值和激励函数
[Python人工智能] 四.TensorFlow创建回归神经网络及Optimizer优化器
[Python人工智能] 五.Tensorboard可视化基本用法及绘制整个神经网络
[Python人工智能] 六.TensorFlow实现分类学习及MNIST手写体识别案例
[Python人工智能] 七.什么是过拟合及dropout解决神经网络中的过拟合问题
[Python人工智能] 八.卷积神经网络CNN原理详解及TensorFlow编写CNN
[Python人工智能] 九.gensim词向量Word2Vec安装及《庆余年》中文短文本相似度计算
[Python人工智能] 十.Tensorflow+Opencv实现CNN自定义图像分类案例及与机器学习KNN图像分类算法对比
[Python人工智能] 十一.Tensorflow如何保存神经网络参数
[Python人工智能] 十二.循环神经网络RNN和LSTM原理详解及TensorFlow编写RNN分类案例
[Python人工智能] 十三.如何评价神经网络、loss曲线图绘制、图像分类案例的F值计算
[Python人工智能] 十四.循环神经网络LSTM RNN回归案例之sin曲线预测
[Python人工智能] 十五.无监督学习Autoencoder原理及聚类可视化案例详解
[Python人工智能] 十六.Keras环境搭建、入门基础及回归神经网络案例
[Python人工智能] 十七.Keras搭建分类神经网络及MNIST数字图像案例分析
[Python人工智能] 十八.Keras搭建卷积神经网络及CNN原理详解
[Python人工智能] 十九.Keras搭建循环神经网络分类案例及RNN原理详解
[Python人工智能] 二十.基于Keras+RNN的文本分类vs基于传统机器学习的文本分类
[Python人工智能] 二十一.Word2Vec+CNN中文文本分类详解及与机器学习（RF\DTC\SVM\KNN\NB\LR）分类对比
[Python人工智能] 二十二.基于大连理工情感词典的情感分析和情绪计算
《人工智能狂潮》读后感——什么是人工智能？(一)
在数据分析和数据挖掘中，通常需要经历前期准备、数据爬取、数据预处理、数据分析、数据可视化、评估分析等步骤，而数据分析之前的工作几乎要花费数据工程师近一半的工作时间，其中的数据预处理也将直接影响后续模型分析的好坏。图是数据预处理的基本步骤，包括中文分词、词性标注、数据清洗、特征提取（向量空间模型存储）、权重计算（TF-IDF）等。
一.中文分词 当读者使用Python爬取了中文数据集之后，首先需要对数据集进行中文分词处理。由于英文中的词与词之间是采用空格关联的，按照空格可以直接划分词组，所以不需要进行分词处理，而中文汉字之间是紧密相连的，并且存在语义，词与词之间没有明显的分隔点，所以需要借助中文分词技术将语料中的句子按空格分割，变成一段段词序列。下面开始详细介绍中文分词技术及Jiaba中文分词工具。
中文分词（Chinese Word Segmentation）指将汉字序列切分成一个个单独的词或词串序列，它能够在没有词边界的中文字符串中建立分隔标志，通常采用空格分隔。下面举个简单示例，对句子“我是程序员”进行分词操作。
输入：我是程序员 输出1：我\是\程\序\员 输出2：我是\是程\程序\序员 输出3：我\是\程序员 简单举个例子，代码中主要导入Jieba扩展包，然后调用其函数进行中文分词。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d513561f5b910f416e8b3beff6a89bf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a270d9bd92a2c4d2bec88d10d1ca2f53/" rel="bookmark">
			Python数据可视化的例子——条形图（bar）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．matplotlib模块 应用matplotlib模块绘制条形图，需要调用bar函数，关于该函数的语法和参数含义如下：
bar(x, height, width=0.8, bottom=None, color=None, edgecolor=None, linewidth=None, tick_label=None, xerr=None, yerr=None, label = None, ecolor=None, align, log=False, **kwargs) x：传递数值序列，指定条形图中x轴上的刻度值。height：传递数值序列，指定条形图y轴上的高度。width：指定条形图的宽度，默认为0.8。 bottom：用于绘制堆叠条形图。color：指定条形图的填充色。edgecolor：指定条形图的边框色。linewidth：指定条形图边框的宽度，如果指定为0，表示不绘制边框。tick_label：指定条形图的刻度标签。xerr：如果参数不为None，表示在条形图的基础上添加误差棒。yerr：参数含义同xerr。label：指定条形图的标签，一般用以添加图例。ecolor：指定条形图误差棒的颜色。align：指定x轴刻度标签的对齐方式，默认为center，表示刻度标签居中对齐，如果设置为edge，则表示在每个条形的左下角呈现刻度标签。log：bool类型参数，是否对坐标轴进行log变换，默认为False。**kwargs：关键字参数，用于对条形图进行其他设置，如透明度等。 bar函数的参数同样很多，希望读者能够认真地掌握每个参数的含义，以便使用时得心应手。下面将基于该函数绘制三类条形图，分别是单变量的垂直或水平条形图、堆叠条形图和水平交错条形图。
（1）垂直或水平条形图
首先来绘制单个离散变量的垂直或水平条形图，数据来源于互联网，反映的是2017年中国六大省份的GDP:
垂直条形图
# 绘图 x= 起始位置， bottom= 水平条的底部(左侧), y轴， height 水平条的宽度， width 水平条的长度 p1 = plt.bar(x=0, bottom=y, height=0.5, width=x, orientation="horizontal") 绘图代码如下：
import matplotlib.pyplot as plt import pandas as pd GDP_data = pd.read_excel(r'GDP.xlsx') #设置绘图风格 plt.style.use('ggplot') #处理中文乱码 plt.rcParams['font.sans-serif'] = ['Microsoft YaHei'] #绘制条形图 plt.bar(x = range(GDP_data.shape[0]), #指定条形图x轴的刻度值(有的是用left，有的要用x) height = GDP_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a270d9bd92a2c4d2bec88d10d1ca2f53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706cf14767986b483f0234eb935d7498/" rel="bookmark">
			DedeCMS最新文章、相关文章、推荐文章、热点文章、头条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DedeCMS最新文章：
&lt;ul&gt;
{dede:arclist row='10' titlelen='50'}
&lt;li&gt;&lt;a href="[field:arcurl/]"&gt;[field:title/]&lt;/a&gt;&lt;/li&gt;
{/dede:arclist}
&lt;/ul&gt;
如果要排除头条文章加上 noflag='h' 即可。
DedeCMS相关文章：
&lt;ul&gt;
{dede:likearticle row='10' titlelen='50'}
&lt;li&gt;&lt;a href='[field:arcurl/]'&gt;[field:title/]&lt;/a&gt;&lt;/li&gt;
{/dede:likearticle}
&lt;/ul&gt;
DedeCMS推荐文章：
&lt;ul&gt;
{dede:arclist row='10' titlelen='50' flag='c'}
&lt;li&gt;&lt;a href="[field:arcurl/]"&gt;[field:title/]&lt;/a&gt;&lt;/li&gt;
{/dede:arclist}
&lt;/ul&gt;
DedeCMS热点文章：
&lt;ul&gt;
{dede:arclist row='10' titlelen='50' orderby='click'}
&lt;li&gt;&lt;a href="[field:arcurl/]"&gt;[field:title/]&lt;/a&gt;&lt;/li&gt;
{/dede:arclist}
&lt;/ul&gt;
DedeCMS头条：
{dede:arclist flag='h' row='1'}
&lt;h1&gt;&lt;a href="[field:arcurl/]"&gt;[field:title/]&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;[field:info/]...&lt;/p&gt;
{/dede:arclist}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c43c4680df5100bca8b0a1c5840740e/" rel="bookmark">
			Docker OCI runtime exec failed: exec failed: container_linux.go:344: starting container process caus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker执行命令:docker exec -it 1e33b26152e1 /bin/bash 在进入容器报错:OCI runtime exec failed: exec failed: container_linux.go:344: starting container process caused "exec: \"/bin/bash\": stat /bin/bash: no such file or directory": unknown
报错场景:我是pull了一个registry镜像，准备搭建私有库。运行了registry镜像，然后进入容器产生的错误
解决办法:
docker exec -it 1e33b26152e1 /bin/sh
or
docker exec -it 1e33b26152e1 bash
or
docker exec -it 1e33b26152e1 sh
来源：
https://blog.csdn.net/ypp91zr/article/details/89061175
我的情况是 搭建 nginx-upload 导致的。
使用 docker exec -it 1e33b26152e1 /bin/sh 时可以的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daebbbb1dec57ffd85613a0fbc1f35b9/" rel="bookmark">
			mysql存储过程 动态列名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： 筛选某时间段内的面试人员，按部门及岗位进行人数汇总。
技术实现： mybatis+mysql存储过程
存储过程实现：
DELIMITER &amp;&amp; DROP PROCEDURE IF EXISTS proc_getworkorder_summary; CREATE PROCEDURE proc_getworkorder_summary( IN beginDate date, IN endDate date, OUT totalNum varchar(300) ) READS SQL DATA BEGIN #此处建议在mysql配置文件中进行永久配置 SET GLOBAL group_concat_max_len = 102400; SET SESSION group_concat_max_len = 102400; SET @sql = NULL; SET @num = 0; DROP TEMPORARY TABLE IF EXISTS tmp_work_order; IF beginDate IS NOT NULL AND endDate IS NOT NULL THEN CREATE TEMPORARY TABLE tmp_work_order SELECT * FROM sys_work_order WHERE interview_date BETWEEN beginDate AND endDate; ELSE CREATE TEMPORARY TABLE tmp_work_order SELECT * FROM sys_work_order; END IF; SELECT GROUP_CONCAT(DISTINCT CONCAT( 'sum(if(dept = ''', dept, ''', num, 0)) as ''', dept, '''' ) ) INTO @sql FROM sys_work_order WHERE ifnull(dept,'')!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daebbbb1dec57ffd85613a0fbc1f35b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2880991f88259670d0ff1a9051f69e87/" rel="bookmark">
			STM32比较器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先芯片需要使用带有比较器的型号，有些是没有带比较器的
环境 STM32F071CBT6
STM32CUBEMX
MDK5
步骤 1、使用Cube新建工程，选择相应芯片
2、设置时钟等基础设置
3、开启COMP1设置参数
参数解释 结合框图更容易明白
Input+：信号输入
Input-：比较信号，把输入的信号和该信号相比较如果大于则1小于则0，可以配置取反
Speed/Power Mode：速度，越高毛刺影响约大
Interrupt Trigger Mode：触发模式，上升沿下降沿
Hyseteresis Level：磁滞
工程 github:https://github.com/Shaynerain/STM32-COMP-DEMO
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766649aac7e47f12f5898e68deca8f12/" rel="bookmark">
			互联网公司90%的人都不会开会！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝色关注，回复“1”获取知名公司程序员和产品经理职级
这是我的第「122」篇原创文章
见字如面，我是军哥。
最近我的一位读者朋友加入一家新公司，和我聊天时感觉他神采飞扬。然而说没几天后，他告诉我公司的会议说来就来，没有一点防备，感觉很懵逼。
想请教我一下，要开好会，有什么好的实操和方法论么？
我想了一下，这是个不错的题材，想了一个周末，有了下文。
今天的文章将从以下「会前、会中、会后」三个方面逐一聊聊。
1.会前
我们要开好会，会前要做好五个 W。
What：开会的主要主题是什么？主要的目的是什么？
When：何时开会，我们不能说，明天下午开会，而是要具体到分钟级别。
Who：谁来开会，谁做主持人，谁来发言，谁是参会者，谁做会议记录，一定要通知每个人。
Where：何地开会，哪些人电话或者视频接入，哪些人到场。
Why ：为什么我们开会讲这个主题，不能简单粗暴的说，明天大家来开会，我们要把会议的目的讲清楚，让大家对此事有提前的了解，对此事的动力就会大很多，开会的效果的也会更好。
诚然，开会最重要是会议的主题，然而我见过太多的会没有主题或者被参会的人带偏，导致开了1个小时的会3小时还没搞定。说句实话，这种开会就是谋财害命。
与会的人，我认为最重要是这三类，第一、会议主持者；第二、核心发言者；第三、做会议记录的人。
我相信你见过太多的会议，没有主持人或者中途主持人离开，整个会开的一脸懵逼，当然核心发言者是不可或缺的，通常我们在公司一定需要协作，比如我们探讨一个方案，没有核心发言者，很多是方案是没有办法确定和落地的。
做会议记录的人，也可以其他人来兼任，会议不做记录这是恶习，好记性不如烂笔头呀。
有的同学说，这事吃力不讨好啊，没人干，那就大家轮着干。老板需要以身作则，这很重要。
最后要聊的是具体的开会时间，如果在公司里大家都很忙，首先要确定一个具体时间并且要通过各种方式触达到与会者，我相信你也一定见过明明通知了，最后那人没收到，安排了其他事，so，重要的会请让与会者一一确认，用Outlook等会议工具就很不错。如果是固定频率的会，最好可以拉一个微信群或者钉钉群，这样在会议开始前二次通知一次保证大家及时参会。
2.会中
我们进入到会议中，我把会议分成两大类：
第一类是，参与者都在一个固定会议室的。
我以过 PRD 和领导的周会为例：
过产品 PRD 这种会，我建议产品经理事先把 PRD 发给所有与会人，让他们提前大概了解本次讨论具体是哪些需求？而作为参会的人也能提前思考 PRD是否有合理问题，是否有逻辑问题，是否有不明确的问题等等。
在开会讨论细节中，我建议就事论事，不要言词过激，程序员或者测试同学也不用担心任务过重，毕竟我们做的需求是以给用户带来价值为第一目的，剩下的就是看看如何协调资源和制定开发周期完成这事。
我们再来讨论领导的周会，作为参会的我们需要怎么做？我有六点建议与你分享：
1、对自己要汇报的工作要做到脱稿都能对答如流，特别在一些产品或技术 KPI 时，要做到有理有据，有数据证明。
2、领导需要大家对某一个具体问题提建议，我们一定要踊跃发言，不要怕说错话，积极主动的下属哪个领导都喜欢。
3、对于领导提出一些都不在我们在座职责范围的工作，如果我们有能力也有时间请站出来解决它，这叫做突破边界，我们多次而为之我相信对于晋升等机会老板一定首先考虑我们，毕竟能解决问题是个稀缺的能力。
4、当你的观点和其他人观点或者领导不一致时，请对事不对人，做到谦虚格局大方得体。
5、不要玩手机、不要玩手机、不要玩手机，重要的事情说三遍。
6、另外，开会时如果不是特别必要请合上我们电脑，带一本纸质的笔记本就好了。不要试图假装你在工作，没意义的，尽快改正吧。
第二类是，参会者异地电话或视频会议。
因为疫情的原因或部门公司有多地的办公室，这种场景下在一起开会是非常奢望的事，我曾经开过一个会有上海、北京五环、北京望京、深圳四地的同事。
除了以上通用的建议外，我还有如下建议与你分享：
1、找一个大家都能接入的稳定视频设备并且请各自提前调试，我见过太多开会的时候调试设备，浪费太多的宝贵时间，这不是调试这是谋财害命。
2、倘若有人发言的时候，其他人请静音，还要避免开小会，这样对于发言人特别不尊重，会引起一些误会，那么会议效果一定会大打折扣。
3、会议纪要非常重要，请一定、一定做好记录并通知到与会者。
以上，就是我在开会过程中一些总结和思考，我们继续看会后......
3.会后
终于到会后这个环节了，根据我多年参加无数大小会议的经验，一个会是否成功，会后占了50%以上。
那么会后到底需要做些什么呢？
在会议中，有一类会议称之为通知类型，大家知道去执行就好了，也不需要跟踪。
有一类事需要具体的人去执行并且有专人跟进，这种叫 TODO 事项，那么这个时候最好有一个表格，如下图：
具体事项、责任人，预计完成时间、目前状态等字段都要补上，如果会上无法给出具体完成时间，那就自己主动上报。
为了这些待跟进的内容因为时间的流逝而忘记，我们可以使用工具来跟踪，比如 Teambition 等工具，若没有用 Excel 来记录然后放到参会人都能看到的 wiki 或者其他公共地方都是可以的。
最后，还有一个非常重要的 Check 环节，那就是按自己团队的情况，比如下次会议或2周做一次没有结束事项的 Review 和跟进。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/766649aac7e47f12f5898e68deca8f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa27377958ad289235c2e29b2a53c69/" rel="bookmark">
			TensorFlow 2.0教程04：Early Stopping
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在训练过程中，神经网络中的weights会更新，以使模型在训练数据上的表现更好。一段时间以来，训练集上的改进与测试集上的改进呈正相关。但是，有时会开始过度拟合训练数据，进一步的“改进”将导致泛化性能降低。这称为过度拟合。Early stopping是一种用于在过度拟合发生之前终止训练的技术。
本教程说明了如何在TensorFlow 2中实现early stopping。本教程的所有代码均可在我们的code中找到。
通过tf.keras.EarlyStopping回调函数在TensorFlow中实现early stopping
earlystop_callback = EarlyStopping( monitor='val_accuracy', min_delta=0.0001, patience=1)​ monitor跟踪用于决定是否应终止训练的quantity。在这种情况下，我们使用验证准确性。min_delta是触发终止的阈值。在这种情况下，我们要求精度至少应提高0.0001。patience是等待训练停止的“无改善时期”的数量。使用时patience = 1，训练会在第一个时期后立即终止，并且没有改善。
现在，我们可以附加early stop callback并使用early stopping进行训练：
model.fit(train_dataset, epochs=10, callbacks=[earlystop_callback], validation_data=test_dataset, validation_freq=1) ​ Epoch 1/10 390/390 [==============================] - 73s 187ms/step - loss: 2.7133 - accuracy: 0.3300 - val_loss: 6.3186 - val_accuracy: 0.1752 Epoch 2/10 390/390 [==============================] - 39s 100ms/step - loss: 2.2262 - accuracy: 0.4914 - val_loss: 2.5499 - val_accuracy: 0.4358 Epoch 3/10 390/390 [==============================] - 39s 100ms/step - loss: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aa27377958ad289235c2e29b2a53c69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855fbb160a73c746e7c39ae5a2656ccf/" rel="bookmark">
			二叉排序树之红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 红黑树的介绍
先来看下算法导论对R-BTree的介绍：
红黑树，一种二叉搜索树（BinarySearch Tree，BST），但在每个结点上增加一个存储位表示结点的颜色，可以是RED或BLACK。既然它是一种BST，它就具有BST的一般性质。
通过对任何一条从根结点到叶子结点的路径上结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。这里，必须要注意，红黑树不像AVL，是高度平衡的BST，红黑树不是绝对平衡的，它存在某结点的左右子树高度差大于二的情况。
红黑树上每个结点内一般含五个域：[parent，left，right，color，key]，分别是指向父结点指针、指向左孩子结点指针、指向右孩子结点指针、结点颜色和结点键值。如果相应的指针域没有，则设为NIL。
红黑树的NIL结点，并非NULL指针，也不同于普通的树结点，它的颜色固定为BLACK，指针域中左右孩子通常固定指向NULL，可以不存在键值项和数据项。由于红黑树中的所有叶子结点的左右孩子和根结点的父结点指针都要指向NIL结点，如果为每个指针分配不同的NIL结点，必然造成内存浪费。因此，在红黑树的具体实现中，我们仅构造一个NIL结点，然后让所有叶子结点指向左右孩子的指针和根结点指向父结点的指针都来指向这个唯一的NIL结点。
注：此处叙述的叶子结点，不同于下文陈述红黑树性质的叶子结点即NIL结点，是具有实际意义的树内数据结点。
红黑树的性质
玩游戏，就得遵守游戏规则；人类社会的发展也伴随着制度法规的发展；就连咱们技术积累的撰写和评审也不例外，也有一定的标准或要求。要想参与进来，就得了解并接受规则！
红黑树也不例外，它有一套自己的规则，只是相对小众了些。接下来，让我们先了解一下。
一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：
1）每个结点要么是红的，要么是黑的；
2）根结点是黑的；
3）每个叶结点，即空结点（NIL）是黑的；
4）如果一个结点是红的，那么它的两个孩子都是黑的；
5）对每个结点，从该结点到其子孙结点的所有路径上都包含相同数目的黑结点。
下图所示，即是一颗红黑树。此图忽略了NIL结点。
当我们在对红黑树进行插入和删除等操作时，由于树发生了变化，那么就可能会违背红黑树的基本性质。为了保持红黑树的性质，我们可以通过对树进行旋转，即修改树中某些结点的颜色及指针指向，以达到插入、删除操作后，红黑树依然保持它特有的性质（即上文所述的五点性质）。
旋转
对树进行旋转，能保持不变的只有原树的有序搜索特性，而原树的红黑性质则不能保持，所以在红黑树的结点插入或删除后，需要采用旋转和颜色重涂来恢复树的红黑性质。红黑树的旋转，仅需要使用两种单旋，即左旋和右旋。具体详见上一篇技术积累《二叉搜索树之AVL树》，这里仅给出算法导论里左旋操作的伪码，不再重述。
LEFT-ROTATE(T, x) //T指代树的管理根结构，x为旋转根结点
1 y ← right[x] //Set y
2 right[x] ← left[y] //Turn y's left subtreeinto x's right subtree.
3 p[left[y]] ← x
4 p[y] ← p[x] //Link x's parent to y.
5 if p[x] = nil[T]
6 then root[T] ← y
7 elseif x = left[p[x]]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/855fbb160a73c746e7c39ae5a2656ccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cf70be2fd6654804caca23d65cd582b/" rel="bookmark">
			亲身体验Intellij Idea从卡顿到顺畅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲身体验Intellij Idea从卡顿到顺畅 idea power save mode 指尖飘落的程序 2018-01-16 14:12:12 11991 收藏 1
分类专栏： 工具
版权
power save mode 开启后代码不提示， 省电模式（经典模式：适用低配版电脑）
https://blog.csdn.net/win7system/article/details/83754072
本人开发环境是16G内存，结合网络上的方法和自己亲身体验，总结出如下几条：
1、 卸载/关闭不需要用的插件
作为一个Java后端开发，前期不打算专注于前端知识，所以可以适当关闭前端插件，比如，对于一些默认安装的什么安卓的google的app，前端的JS框架 等插件可以卸载掉，项目中根本不用不到的一些框架----Struts，Hibernate，Ant等可以卸载。
打开settings -》plugins-》可以点击插件介绍，再根据自己的需求关闭/卸载掉自己不常用的插件，重启Idea即可。
2、减少内存
在设置项目的时候尽量不要将没有关系的项目放置在一个工程中，这样能够减少内存的使用。比如比较大的maven项目或者分布式项目都喜欢分成很多模块。但是，实际上自己只负责一个模块，可以根据自己的项目依赖只导入自己相关的module。
可以点击右键，load/unloan modules，只导入自己需要的模块。
3、修改配置文件 ---- 重点推荐的方法
关闭之后接着进入电脑中intellij idea的安装目录中去，找到其中的bin文件夹，在bin文件夹中有两个文件，分别叫做:idea.exe.vmoptions与idea64.exe.vmoptions，这是笔者的个人配置，我的电脑是windows 10 内存是16G，所以分配了4G内存堆，可以根据自己电脑的实际内存设置。
-server -Xms4096m
-Xmx4096m
-XX:NewRatio=3 -Xss16m -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:ConcGCThreads=4 -XX:ReservedCodeCacheSize=2048m
-XX:+AlwaysPreTouch -XX:+TieredCompilation -XX:+UseCompressedOops -XX:SoftRefLRUPolicyMSPerMB=50 -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -Djsse.enableSNIExtension=false -ea 4、适当关闭idea的Inspections的检查或者开发时完全关闭Inspections的检查，等开发完后在开启检查。个人感觉这个最有效。
可以全部关闭，idea右下角有一个 人头标志，可以点击，调准idea检查级别~
好了，如果有小伙伴有更好的更加精细的方法欢迎分享~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca6b18b5ed48351e2f6a05c82c13789d/" rel="bookmark">
			stm32-FreeRTOS-ESP8266-OneNET物联网远程开关，心知天气网络时间，开源代码电路原理图altium-pcb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享下自己基于OneNet物联网云平台的远程开关，可电脑 / 手机APP远程控制，亦可获取当前时间和近3日天气。
还有好多坑待填，开源仅作学习。
资源下载链接在文章末尾。stm32-FreeRTOS源码、原理图、AD-PCB。
实物展示 上电自动联网，获取开关状态、时间、天气的过程：(5FPS) OLED时间界面：(15FPS) OLED整体界面：(15FPS) 电脑控制远程开关：(15FPS) 手机APP控制远程开关：(15FPS) （现在的远程开关由于是HTTP GET的方式，每隔3S刷新一次，所以有时延）
高清图： 设计概况 硬件组成： 主控MCU：stm32F103c8t6
WIFI：ESP8266（ESP-12F/S）、EMW3080【选其一使用】
以太网：W5500
显示：SPI-OLED / SPI-TFT
运行系统：FreeRTOS
功率输出：两路250V/10A继电器、两路600V/6A可控硅（交流）
供电方式：USB / DC-5V / 18650锂电池（备用电源）
通信接口：CAN / RS485 / USB从机 / USB串口 / 2xTTL串口
传感器：红外发射（3W | 120°）、红外接收、APDS-9930（光强、接近）、DHT12（或其他I2C的温湿度传感器）
特点： 全，硬件全面，CAN / RS485 / USB从机 / USB串口 / 2xTTL串口，红外发射/接收，满足 家居/轻工控需求。
全，周全，wifi连接 / 以太网连接均可。
全，安全，18650锂电备用电源，从容应对断电情况，亦可随手携带进行场外调试。
设计初衷： 最开始只是想设计个远程开关，能放进防水盒可远程遥控，没想那么多功能。可一想打5公分的PCB也是打，打10公分的PCB也是打，干脆集成的东西多一点，可搭配出的功能也多一些。到手后发现，最重要的配网按键忘记搞了，虽然其他的方式也能弥补，例如用红外遥控器做触发，用光强做触发，但总感觉少了那个随心所欲的味道。于是搁置争议，先填好远程开关这个坑，其他功能留着以后有时间再完善。
目前实现功能： stm32F103 运行 FreeRTOS。
ESP8266（ESP-12F/S）wifi，HTTP 连接 OneNET、心知天气。
4路远程开关控制、北京时间、近3日天气。
OLED平移滚动界面：时钟界面、开关状态界面、近3日天气界面。
多种供电方式：USB / DC-5V / 18650锂电池（备用电源）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca6b18b5ed48351e2f6a05c82c13789d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2a2e8fa46ea2741f529d48c453039f/" rel="bookmark">
			hashcode()和equals()方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hashcode()和equals()方法详解
1、何为hashcode() hash是一个函数，就是通过一种算法来得到一个hash值。通过hash算法得到的hash值就存放在这张hash表中，也就是说hash表示所有的hash值组成的。hashcode通俗地讲就是在hash表中对应的位置。
每个对象都有hashcode，对象的hashcode是怎么来的呢？首先一个对象肯定有物理地址，独享的物理地址跟这个hashcode地址不一样，hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址，那么对象如何得到hashcode呢？通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode，所以，hashcode是什么呢？就是在hash表中对应的位置。这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。
2、为什么需要hashcode()方法，他有什么好处 当我们在集合中，如果该集合元素不可重复，怎么来保证和判断呢？这就是Object.equals方法。每次添加一个新的元素的时候都要和已插入元素用该方法来比较他们是否相等，当已插入数据较大时，如已经有1000个元素了，在插入第1001个元素的时候，我们就要调用1000次equals方法，大大降低了效率。于是，Java采用了哈希表的原理。可以简单的理解为hashCode方法返回的是对象存储的物理地址（实际可能不是）。这样一来，当添加新的元素的时候，先调用hashCode方法，就一下子能定位到它应该放的物理位置。如果这个位置没有元素，他就可以直接放在这个位置上，不用再进行任何比较；如果这个位置已经有元素了，这才调用equals方法与新元素进行比较，相同的话就不存了，不相同的话就散列其他地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。
3、hashcode()和equals()方法的关系 通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等，用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。
Java 对于eqauls 方法和hashCode 方法是这样规定的：
1、如果两个eqauls相同，那么它们的hashCode 值一定要相同；
2、如果两个对象的hashCode 相同，它们的eqauls并不一定相同
4、为什么equals方法重写的话，建议也一起重写hashcode方法？ 举个例子，其实就明白了这个道理，
比如：有个A类重写了equals方法，但是没有重写hashCode方法，看输出结果，对象a1和对象a2使用equals方法相等，按照上面的hashcode的用法，那么他们两个的hashcode肯定相等，但是这里由于没重写hashcode方法，他们两个hashcode并不一样，所以，我们在重写了equals方法后，尽量也重写了hashcode方法，通过一定的算法，使他们在equals相等时，也会有相同的hashcode值。
实例：现在来看一下String的源码中的equals方法和hashcode方法。这个类就重写了这两个方法，现在为什么需要重写这两个方法了吧？
equals方法：其实跟我上面写的那个例子是一样的原理，所以通过源码又知道了String的equals方法验证的是两个字符串的值是否一样。还有Double类也重写了这些方法。很多类有比较这类的，都重写了这两个方法，因为在所有类的父类Object中。equals的功能就是 ==号的功能。你们还可以比较String对象的这两者的区别啦。这里不再说明。
hashcode方法
5、为什么两个对象有相同的hashcode值，他们也不一定相等？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d4e3c2e8529fe19a266a29ddc9cd9b/" rel="bookmark">
			Spark SQL介绍和DataFrame概念以及其API的应用示范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark SQL介绍和DataFrame概念以及其API的应用示范 【以下内容都是自己在集群上学习截图展示】
Spark SQL介绍：
Spark SOL是用于结构化数据、半结构化数据处理的Spark高级模块，可用于从各种结构化数据源，例如JISON (半结构化)
文件、CSV文件、ORC文件(ORC文件格式是一种Hive的文件存储格式，可以提高Hive表的读、写以及处理数据的性能)、
Hive表、Parquest文件(新型列式存储格式，具有降低查询成本、高效压缩等优点，广泛用于大数据存储、分析领域)中读取
数据，然后在Spark程序内通过SQL语句对数据进行交互式查询，进而实现数据分析需求，也可通过标准数据库连接器
(JDBC/ODBC)连接传统关系型数据库，取出并转化关系数据库表，利用Spark SQL进行数据分析。
这里解释一下结构化数据:
结构化数据是指记录内容具有明确的结构信息且数据集内的每一条记录都符合结构规范的数据集合，是由二维表结构
来逻辑表达和实现的数据集合。可以类比传统数据库表来现解该定义，所谓的“明确结构”即是由预定义的表头(Schema)
表示的每一条记录由哪些字段组成以及各个字段的名称、类型、属性等信息。
Spark SQL的实现：
若需处理的数据集是典型结构化数据源，可在Spank程序中引入Spark SQL模块，首先读取待处理数据并将其转化为
Spark SQL的核心数据抽象---DataFrame,进而调用DataFrame API来对数据进有分析处理，也可以将DataFrame注册成表，
直接使用SQL语句在数据表上进行交互式查询。
DataFrame：
DataFrame的定义与RDD类似，即都是Spark 平台用以分布式并行计算的不可变分布式数据集合。与RDD最大的不同在于，
RDD仅仅是一条条数据的集合，并不了解每条数据的内容是怎样的，而DataFrame明确的了解何条数据有几个 命名字段组成， 即可以形象地理解为RDD是条条数据组成的一维表，面DataFrame 是何行数据 都有共同清晰的列划分的维表，每一行的内容
的Row对象组成DF。
概念上来说，它和关系型数据库的表或者R和Python中data frame 等价，只不过DataFrame在底层实现了更多优化。
从编程角度来说，DataFrame 尼Spark SQL模块所需处理的结构化数据的核心抽象，即在Spark程序中若想要使用简易的SQL
接口对数据进行分析，首先需型将所处理数据源转化为DataFrame对象，进而在DataFrame对象上调用各神API来实现需求，
DataFrame 可以从许乡结构化数据源加载并构造得到，如结构化数据文件，Hive中的表，外部数据库，已有的DataFrame API
支持多种高级程序讲言Scala、Java、 Python 和R，
DataFrame与RDD的区别：
RDD和DalaFrame均为Spark平台对数据的一种抽象，一 种组织方式，但是两者的地位或者说设计目的却截然不同。
RDD是整个Spark平台的存储、计算以及任务调度的逻辑基础，更具有通用性，适用于各类数据源，而DataFrame是只针对
结构化数据源的高层数据抽象，其中在DataFrame对象的创建过程中必须指定数据集的结构信息(Schema)，所以DataFrame
生来便具有专用性的数据抽象，只能读取具有鲜明结构的数据集。
下图直观地体现了DataFrame 和RDD的区别。左侧的RDDIPerson]虽然以Person类为类型参数，但Spark平台本身并不了解
Person 类的内部结构。而右侧的DataFrame却提供了详细的结构信息，使得Spark SQL可以清楚地知道该数据集中包含哪些列，
每列的名称和类型各是什么。DataFrame 多了数据的结构信息，即schema. RDD是分布式的Java 对象的集合，DalaFrame
则是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子操作以外，更重要的特点是利用已知的结构信息
来提升执行效率、减少数据读取以及执行计划的优化，比如filter下推、裁剪等。
Spark SQL模块的编程主入口点是SparkSession, SparkSession 对象不仅为用户提供了创建DataFrame对象、读取外部
数据源并转化为DataFrame对象以及执行sql查询的API,还负责记录着用户希望Spark应用如何在Spark集群运行的控制、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d4e3c2e8529fe19a266a29ddc9cd9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca7176eedd7ece35b994593297afd5c/" rel="bookmark">
			利用图像理解牛顿法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		符号说明
f ( x ) f(\textbf{x}) f(x)表示函数，某个 x \textbf{x} x向量对应的值是个常量。
x \textbf{x} x表示函数空间中在各个轴上的未知变量，表示为nx1的列向量。以(x,y,z)三维空间举例子, x \textbf{x} x表示x,y两个轴上的变量， f ( x ) f(\textbf{x}) f(x)代表在z轴上的映射，是一个常量。以后用 x i x_i xi​表示非 f ( x ) f(\textbf{x}) f(x)值所在的轴，y表示在 f ( x ) f(\textbf{x}) f(x)值所在的轴，比如三维空间中的点可表示成 ( x 1 , x 2 , y ) (x_1,x_2,y) (x1​,x2​,y)。
x t = ( x 1 t , x 2 t , . . . , x n t ) T \textbf{x}_t=(x_{1}^{t},x_{2}^t,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca7176eedd7ece35b994593297afd5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb04ff51c005ff9d1a141faf25ef891/" rel="bookmark">
			JdbcDaoSupport的使用以及Dao的两种编写方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际开发中，持久层可能会有多个面向不同实体操作的dao，此时每个dao中都会有封装JDBC操作的对象声明，重复代码就会增多。
这时dao有两种编写方式：
1.依然自己声明封装JDBC操作的对象，但使用注解来进行初始化；
2.不声明封装JDBC操作的对象，而是让dao类继承JdbcDaoSupport类，这个类中有JdbcTemplate成员对象，可以直接调用getJdbcTemplate方法得到JdbcTemplate对象，但此时只能通过xml配置文件来初始化dao。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee2cfb782a19eb433c2b21e0ab0122da/" rel="bookmark">
			springboot整合Elasticsearch7.6实现简单查询及高亮分词查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言集成环境准备简单查询分词高亮查询 前言 该文章需要提前准备好Elasticsearch7.6以及ik分词器的环境，如果还没准备好的可以看看之前以及发过的文章，liunx下安装elasticsearch7.6、ik分词器以及kibana可视化工具
集成环境准备 1.导入spring-data-elasticsearch依赖
版本需要与Elasticsearch一致，还需要注意自己的springboot版本是否支持
本文springboot为2.3，依赖也为2.3，elasticsearch,为7.6.2
&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;${version}.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2.elasticsearch配置文件
因为原来的配置不支持了
配置文件如下：
@Configuration public class EsConf { @Value("${elasticSearch.url}") private String edUrl; //localhost:9200 写在配置文件中就可以了 @Bean RestHighLevelClient client() { ClientConfiguration clientConfiguration = ClientConfiguration.builder() .connectedTo(edUrl)//elasticsearch地址 .build(); return RestClients.create(clientConfiguration).rest(); } } 3.实体类准备
关于实体类中的几个注解，不清楚的可以去查看文档，这里不过多介绍了
@Data @Document(indexName = "user")//索引名称 建议与实体类一致 public class User { @Id private Integer id; @Field(type = FieldType.Auto)//自动检测类型 private Integer age; @Field(type = FieldType.Keyword)//手动设置为keyword 但同时也就不能分词 private String name; @Field(type = FieldType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee2cfb782a19eb433c2b21e0ab0122da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65cc21d7c9d2af0ee94274e39720976c/" rel="bookmark">
			PCL之使用过程中遇到的坑、报错、解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇博客准备记录PCL使用过程中遇到坑
文章目录 1.编译报错：`undefined reference to pcl::search::Search::getName[ abi:cxx11]() const`解决方法 2.运行报错：`[pcl::SHOTEstimation::computeFeature] The local reference frame is not valid! Aborting description of point with index 3115`解决方法 3.编译报错 `error: ‘const class pcl::PointCloud’ has no member named ‘__getMD5Sum’`解决方法 4.编译报错 `undefined reference to pcl::search::KdTree::KdTree(bool)`解决方法 5.运行报错 `typename boost::detail::sp_member_access::type = pcl::KdTree*]: Assertion px != 0 failed.`解决方法 6.编译报错 `undefined reference to pcl::KdTreeFLANN&lt; pcl::PointXYZ, flann::L2_Simple&gt; ::KdTreeFLANN(bool)`解决方法 7.编译报错 /usr/include/pcl-1.7/pcl/octree/octree_pointcloud_changedetector.h:64:43: error: ‘Octree2BufBase’ was not declared in this scop解决方法参考链接 8.编译报错：error: ‘transformPointCloud’ is not a member of ‘pcl’解决方法 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65cc21d7c9d2af0ee94274e39720976c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e5bd63f237dee89df62003088e52d7/" rel="bookmark">
			1.hystrix 核心内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.hystrix核心主要用作服务隔离,服务熔断
hystrix服务隔离,有两种方式 1.线程池隔离方式,2,信号量的方式
1.线程池隔离方式:提供了一个抽象 Command，把某一个依赖服务所有的调用请求，都走同一个线程池中的线程， 而不会用其他的线程资源，这就叫做线程池资源隔离.
Command ：每次服务调用请求，都是使用线程池内的一个线程去执行 command 的， comman 里面是你的业务逻辑。
假设该组服务线程池是 3 个线程，同时发起了 1000 个请求， 最多也只会有 3 个线程去执行请求，那么就算这个服务故障了，也不会将所有资源耗尽
线程池隔离技术,并不是控制的tomcat的这种web线程.而是,控制自己的线程. 来保证 tomcat的线程不被卡住.快速返回.
2.信号量的隔离
信号量只是一道关卡,没有自己的线程池.只能在同时允许n个线程进来(n个线程)自己设置.如果多的线程进来,就会快速返回,做falback降级
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/273eefc606c1cfa4b6a238e7abb25133/" rel="bookmark">
			Qt使用教程（C&#43;&#43;版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、Qt的下载网址2、Qt的安装3、 Qt项目的创建 ————————————————————————————————————————————————————
1、Qt的下载网址 Qt官网（下载速度可能较慢，因网速而异）
https://www.qt.io/
2、Qt的安装 大家可以看B站的这个视频，很详细
Qt下载和安装
3、 Qt项目的创建 注：版本不同可能创建方式有稍许的差异，我使用的是5.14版本的Qt
①点击新建
②点击Application,如果要做可视化程序就点击Qt Widgets Application
③
④
⑤这时会出现三个类，关于三个类的区别可以看这篇博客
QMainWindow,QWidget,QDialog的区别
在这里我们选择QMainWindow
打钩的地方是选择使用GUI界面
⑥然后一直点下一步
⑦到这一步选择32位和64位的均可，然后一直点下一步
⑧到这一步项目就创建完成了
后续1
VS2019中使用Qt
未完待续》》》》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2701bff75548dbff133deb66ab93c049/" rel="bookmark">
			【SAP】ABAP——动态SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在选择屏幕中，select options 对象为内表，当select options 屏幕上未填值时，在SQL语句中不进行处理。对于parameters,若选择屏幕上没有填值，则表示该字段为空进行SQL，对此处理方式为使用动态SQL.
DATA:lv_string TYPE string. PARAMETERS p_vbeln TYPE char10. PARAMETERS p_vbtyp TYPE char1. DATA:lv_vbeln TYPE char10. * 动态判断 vbak-vbeln IF p_vbeln IS NOT INITIAL. CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT' EXPORTING input = p_vbeln IMPORTING output = p_vbeln. CONCATENATE lv_string 'VBELN = p_vbeln' INTO lv_string SEPARATED BY space. ENDIF. IF p_vbtyp IS NOT INITIAL. CONCATENATE lv_string 'vbtyp =' '''C''' 'AND'INTO lv_string SEPARATED BY space. ENDIF. IF lv_string IS NOT INITIAL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2701bff75548dbff133deb66ab93c049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869f8b439eb4e438d7904b222f7bf07c/" rel="bookmark">
			Markdown的替代品：ASCIIDoc标记语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASCIIDoc同Markdown一样，也是一种轻量的标记语言，区别是它比Markdown更强大丰富——当然，你没必要硬去记住和使用其全部语法，就像用Markdown进行最简单的写作只需要记住#和##、###一样，你也可以只先记住=、==、===而已，其余的用到时查阅一下，用几次就记住了。
不过对于冲着标题感兴趣进来阅读的人来说，想必都有一定的Markdown使用经验，比对着一次性多学一点也亳不困难。
本文不打算就ASCIIDoc的具体语法再赘述，有兴趣可以自己搜索一下资料。
本文主要对那些尚在Markdown里痴迷但又已经感觉其有一些限制的朋友，还有很幸运并没有在Markdown里花费多少时间而又对轻量标记语言刚刚发生兴趣的朋友，提供这样一个直接的、不需要走弯路的方向指引——略过Markdown，直奔ASCIIDoc吧。
理由如下：
Markdown的标题标识符#在一些语言中是作为注释标识的，当把这些源码内容粘贴进Markdown文章中想作为一部分时，这些注释就会被错误地标识为Markdown的标题，造成很多编辑上的不便。尽管也可以想法在自己电脑上精确设置语法或转换，但在通用性或易用性上，当然是横生枝节。而ASCIIDoc使用=来作为标题标识，想必就是已经考虑到这一点，也可证明它不是Markdown的普通并列项，而应看作是一种推陈出新的改良品。作为推陈出新的改良品的有力证明，ASCIIDoc不仅涵盖Markdown的所有功能，而且还有多处Markdown不具备的实用功能：表格跨行跨列设置，单元格与列的样式，多种提示框样式，文档头信息，嵌入视频，导入文件。而且在使用扩展插件的情况下，也支持兼容Markdown的部分主要语法。在部分语法上，比如粗体和斜体的标识上，ASCIIDoc也显示出了更为优化的设计。ASCIIDoc是著名的计算机技术书籍出版商 O’Reilly 的在线出版平台 Atlas 的推荐语言， 既能适应正规化出版的各种样式元素需要，也能支持规模化出书模式（比如导入文件功能），可嵌入视频更是提供了当前视频时代的流行资讯传播手段（而Markdown居然无视了这一点）。Markdown长期以来各种方言并存，缺乏有力且积极的主导和创新。很多急迫的需求无法短期内实现，更可能的情况就是被ASCIIDoc取代。尽管我们都希望学过的知识可以用得久一点，但推陈出新和吐故纳新总是免不了的。 所以，希望使用ASCIIDoc的人能多起来，也希望各大技术博客平台能早日支持ASCIIDoc。千里之行始于足下，GT（Go-Together）！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8801492725b99480e83d3765e523696a/" rel="bookmark">
			简单改造Markdown使之适应中文化排版风格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时至今天，国内在学习吸收国外先进事物的方面仍普遍地处于最初级的阶段，即只知道全盘吸收之后生搬硬套。而且这不只限于个人，也包括各大公司的技术人员，甚至领头人——只要看看网上技术博客平台或个人技术博客里千篇一律的西文排版风格的Markdown渲染页面样式就知道了。
在Markdown被国内普遍使用之前，我们还保有我们的中文排版风格。然后，Markdown改变了这一切，一夜之间，中国的技术专业人员或爱好者也仿佛赶时髦成了香蕉人——披着西文排版风格的外衣说着中文内容。
事实上，只需要通过简单的改造，就可以使Markdown适应中文化排版风格：
将空4个空格的行作为代码块的规则删除或注销将“正文”的规则由一个空行加顶头行变成由四个半角空格或两个全角空格或一个TAB开始的行，无需空行间隔。将顶头的行作为代码行。 这样就可以了，排版风格演示如下：
对于带有HTML预览和转换功能的，相应要对预览和转换进行上面规则的改写，同时，在HTML排版样式上进行中文式设置，比如段落的自动缩进。
六年前我即已经如此改造和使用Markdown，并一直在多个技术群里适时提到，但时至今日，没在网上见到一个人支持，更没见到一个也像我这样提出来这种观点和建议的人。
如果在写作和阅读习惯上，都能如此将就妥协，不能做以简单且必要的适应性的改造，在其它方面又能如何出息？很多东西，取决之的关键就在意识。
用Markdown的人越来越多，不明白这一点就越来越悲哀。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357d80e48dac1215ddac434fe9e308f4/" rel="bookmark">
			QT中的qmake详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于qmake，好一段时间令我一头雾水，不知道用来干嘛的，只知道怎么用，而且也只懂那么一两个命令，详细看过资料以后整理如下：
1.首先，感性的认识是，qmake可以利用源文件(包括头文件h，实现文件cpp，qt的ui文件等等)生成各种不同类型的工程，工程需要的Makefile文件，可执行的与不可执行的，这取决于所用的模板(包括app、lib、subdirs、vcapp、vclib)。
2.创建pro文件，添加各种源文件，还可以设定平台相关的不同源文件，设置各种规则，利用qmake命令生成工程。后面会介绍pro文件可以手工编写，也可以利用qmake命令智能的生成。
一般顺序是先创建.pro文件，然后由.pro文件生成Makefile文件，makefile文件保存了编译器和连接器的参数选项,还表述了所有源文件之间的关系(源代码文件需要的特定的包含文件,可执行文件要求包含的目标文件模 块及库等).创建程序(make程序)首先读取makefile文件,然后再激活编译器,汇编器,资源编译器和连接器以便产生最后的输出,最后输出并生成 的通常是可执行文件.创建程序利用内置的推理规则来激活编译器,以便通过对特定cpp文件的编译来产生特定的obj文件。
3.各种模板生成不同类型的工程，而每个模板可以用的qmake变量是不一样的：
app模板：编译一个可执行程序
选项　描述
windows　程序是Window平台的界面程序
console　App模板专用: 程序是Window平台控制台程序
当你使用这个模板,以下的一些qmake变量是能用的,你可以在pro文件使用这些变量来配置你的应用程序需要的相关的信息
HEADERS –程序中需要编译的头文件列表.
SOURCES -程序中需要编译的源文件列表.
FORMS – 由Qt Designer为程序创建的ui文件列表(qte2是INTERFACES).
LEXSOURCES – 程序用到的所有的lex 源文件列表.
YACCSOURCES -程序用到的所有的yacc 源文件列表.
TARGET –可执行程序的名字.默认是跟工程文件名一样 (根据不同的平台后缀名会自动添加).
DESTDIR –可执行文件的发布目录.
DEFINES – 程序编译时候需要的预定义的列表INCLUDEPATH –程序需要的头文件的目录列表.
DEPENDPATH –程序搜索的依赖路径.
VPATH – 查找supplied 文件的搜索路径(我还没有弄懂~_~).
DEF_FILE – Windows 平台专用: 程序需要用到的.def .
RC_FILE – Windows 平台专用: 程序的资源文件.
RES_FILE – Windows 平台专用: 程序需要连接的资源文件.
lib模板库：
lib模板告诉qmake生成的Makefile是将要编译一个库,使用这个模板的时候,另外的系统变量会加到上面app模板提到的变量,因为app模板是支持VERSION 变量,你应该在pro文件使用这些来制定一些库的库的信息
使用这个模板的时候,下面的选项可以添加到 CONFIG 变量里面来决定编译成何种库
选项　描述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/357d80e48dac1215ddac434fe9e308f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/278f00f4eedb7f82b615dc5b3642918b/" rel="bookmark">
			UE4之模型格式介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型格式全：
https://docs.fileformat.com/3d/fbx/
fbx：
AutoDesk公司搞的fbx模型格式
fbx模型
3ds:
详解3DS MAX SDK环境搭建
IGES
IFC 绝望中的惊喜，由于是一个通用的格式，后面决定专攻他了
IFC作品
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a37bbb97ca929d892dd55f895a59b5/" rel="bookmark">
			怎样去掉gif动图水印？在线编辑gif图片技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片是我们生活中随处可见的表现形式之一，相比于静态图片，动态图片的展现形式更加的生动有趣，很多用户都喜欢收藏大量的动态图片，可以用来编辑文章时作为插图，也可以在互动聊天时用作表情包。对于从网上下载的动图，很多都会带有水印或者黑边，最简单的处理方法就是使用gif裁剪，将多余部分减掉，接下来教大家使用gif制作（https://www.gif.cn/）在线编辑工具处理gif动图的技巧。
点击导航栏中的gif工具，选择gif裁剪功能，点击本地上传，将图片上传到编辑页面，也可以复制网络图片的地址，然后点击“开始制作”即可上传到编辑页面。
如果有尺寸要求的话，可以在裁剪尺寸中输入宽和高的尺寸，自动生成裁剪框的大小，移动裁剪框选择需要裁剪的部位，如果没有规定需求，只需要拖动默认裁剪框的边来调整大小即可。
点击裁剪，在下方会生成裁剪之后的图片小窗预览，点击下载即可完成操作。
按照以上的操作方式就能够将水印文字，或者黑边等多余的部分裁剪掉，非常的简单方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d06eb87898a9e6ff037acefd95c5b17/" rel="bookmark">
			Nginx 转发 SSL 的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天遇到一个问题，主机服务还没有转成https，但要转发给一个https地址，一直在报一个错
upstream server temporarily disabled while SSL handshaking to upstream, client: xxx.xxx.xxx.xxx, server: localhost
SSL_do_handshake() failed (SSL: error:1408F10B:SSL routines:ssl3_get_record:wrong version number) while SSL handshaking to upstream, client: xxx.xxx.xxx.xxx, server: localhost, request: "POST /a-path/ HTTP/1.1"
从log看应该是协议的问题，就开始找解决办法，最终解决问题，我把方法贴出来
location /a-path/ { proxy_pass https://a-address/; proxy_set_header Host $proxy_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_ssl_session_reuse off; proxy_ssl_server_name on; proxy_ssl_name $proxy_host; proxy_ssl_protocols TLSv1.2; } 关键是 proxy_ssl_protocols 和 proxy_ssl_session_reuse
记录一下，如果有问题，欢迎大牛指出，谢谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1258feaeb2232461be1336d8366c7995/" rel="bookmark">
			cad字体库大全2485种字体 附使用教程|cad字体库大全免费版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CAD工程设计中，设计图纸是不可缺少的核心，而不同的设计图纸所需要的字体也是不同的，若缺少相对应的字体，那么设计图纸文字显示就会产生乱码，严重的话还会影响布局，为此小编带来了cad字体库大全2485种字体。该字体称得上是设计人员必备的工具，可以完美解决这个问题，几乎能够覆盖99%左右的cad设计图纸，可以进行多种图形格式的转换，具有较强的数据交换能力，有了它，再不用担心字体缺少的问题了，绝对能够满足各位工程师们的需求，随后奉上详细的安装使用教程，有需要的用户快来下载吧。
功能特色
1、拥有众多的cad设计所需要的文字字体
2、能为cad设计人员提供两千多种的cad字体
3、这些字体能用于所有行业的cad设计使用
4、该字体包的字体类型众多
5、具有完善的图形绘制功能。
6、有强大的图形编辑功能。
7、可以采用多种方式进行二次开发或用户定制。
8、可以进行多种图形格式的转换，具有较强的数据交换能力。
9、支持多种硬件设备。
10、支持多种操作平台
cad字体库大全怎么安装和使用：
1、首先在本站下载解压，得到cad字体库大全2485种字体；
2、找到autocad软件安装路径，并搜索【fonts】文件夹，此文件夹就是CAD字体的存放位置；
3、然后将软件中的字体文件，复制粘贴到【Fonts】文件夹内；
注意：如果电脑中安装了多个版本的AutoCAD软件的话，则需要在每个安装目录中都拷贝字体文件
4、然后再找到TTF格式的文件，复制粘贴到系统字体文件夹中，如图所示的位置，就完成了；
5、按照以上方法安装完成之后，打开CAD软件，当需要输入文字的时候，在字体选项框中，可以找到安装后的相应字体即可；
6、ok，以上就是cad字体库大全免费版安装使用教程，希望对您有所帮助。
常见问题
1、为什么在安装时会出现"文件损坏"?
答：这是因为字库与您的系统产生冲突(特别是xp系统,因为有很多字体以前都是在win98或更早的版本下开发的。)
2、为什么安装完字体后我在使用时找不到?
答：有些字体:例如华康系列的。他们在列表显示为他的相关拼音代码,您可以在下载回来时双击字体可以看到这个字体的名字是什么。然后在选择使用这个字体时,就请选他的拼音字,就是您要的字体了。
3、为什么有些字体的字打不出来?
答：有些字库必须要在繁体输入的情况下才能打出来的。(例如金梅字库等),如果使用繁体输入法输入的文字依然无法出来,可能是字体的字库不全,是没办法打字这个字的。
友情提示
由于字体过多，如果一次性安装的话，会占用大量的空间资源，配置较低的电脑可能会产生卡顿的情况，建议可以根据需求选择性安装，当然，如果电脑配置够好，那么则可以全部安装上，基本能够解决所有的CAD字体缺失导致问号的情况了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/029412e1af69d57a2343d4606543a90b/" rel="bookmark">
			基于Jenkins和Maven实现Docker镜像的CI/CD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一篇关于如何实现Docker镜像的持续集成与持续交付的交付文档，产生这份文档的缘由是之前服务过的郑州市某家欠薪公司的及其客户一再打电话给我，希望我能提供一份相关操作文档。在我没有收到赔偿款和正式道歉视频之前，这份文档我不会披露更多细节，但可以在此大概描述一下关于Jenkins、Maven和Docker的部分。
什么是CI？CI全拼是Continuous Integration，译作持续集成，在业务语境中主要针对代码编写人员及测试人员，他们需要不定时地频繁提交代码、测试代码，以便快速发现软件工程中的代码质量问题并进行修复。这部分工作和平台运维没有任何关系，但和软件产品运维有较大关系。
什么是CD？CD全拼是Continuous Deployment或Continuous Delivery，根据协同分工的组织划分不同，CD有不同含义。在规模适当、权责明晰的产品型组织团队中，CD指代Continuous Deployment，意在将软件工程项目灵活部署到任意环境，主要供内部测试团队或尝鲜用户使用。而在规模较小而指责不清晰的管理型组织团队中，CD指代Continuous Delivery，意指将成熟的、定型的软件产品交付给终端使用者，涵盖了软件工程的部署和维保培训。在河南省的IT环境中，CD偏向于指代Continuous Delivery，有时也兼指Continuous Deployment和Continuous Delivery，比如我曾服务过的郑州市某ZY公司，总计职员27人，每个技术人员对应了5个管理人员，号称“人人皆可管理技术”。
该项目的工作流程描述：代码由《开发电脑》提交至《git》；触发《Jenkins》的自动代码编译并构建镜像，而后将镜像推送到《docker》仓库；《测试环境或生产环境》从《docker》仓库中拉取镜像进行《部署》。
项目实施环境：
Host OS：CentOS 7 1804 64Bit
Package：git、JDK、Maven、Tomcat、Jenkins
Role：Git/Registry、 Docker、Jenkins
IP Range：192.168.207.177~192.168.207.180
（一）部署git服务
[googlebigtable0@localhost Downloads]$ su root
Password:
[root@localhost Downloads]# yum install -y git
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
base: mirrors.aliyun.comextras: mirrors.aliyun.comupdates: mirrors.aliyun.com
Package git-1.8.3.1-23.el7_8.x86_64 already installed and latest version
Nothing to do
[root@localhost Downloads]# useradd git
[root@localhost Downloads]# echo git | passwd --stdin git
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/029412e1af69d57a2343d4606543a90b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d50358ae2628e4576b982dbd954837/" rel="bookmark">
			逆置单链表——递归与非递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言方式一:非递归原理图解实现代码 方式二:递归原理图解实现代码 完整实现代码运行结果 前言 单链表的逆置图解
方式一:非递归 原理 非递归逆置单链表的本质是创建一个新的链表，遍历原先的链表，利用头插法将节点插入新的链表当中去。
图解 实现代码 //链表节点定义 typedef struct link_list{ int data; struct link_list *next; }singel_link_t; /********************************************************************* * @fn reversion_head_insert * * @brief 非递归的方式创建逆置链表 * * @param link_head为需要逆置的链表表头 * * @return 返回逆置链表的头节点 */ singel_link_t *reversion_head_insert(singel_link_t *link_head) { singel_link_t *reversion_head=NULL,*node=NULL; //参数判断 if(link_head==NULL) { return NULL; } //遍历整个链表 while(link_head!=NULL) { node = (singel_link_t *)malloc(sizeof(singel_link_t)); node-&gt;data = link_head-&gt;data; if(reversion_head==NULL)//首次添加节点 { reversion_head = node; node-&gt;next = NULL; } else { //头插法插入节点 node-&gt;next = reversion_head; reversion_head = node; } link_head = link_head-&gt;next; } return reversion_head; } 方式二:递归 原理 递归的方式是将链表的范围进行缩小，分为已逆置和未逆置两部分，已逆置部分可以看成一个整体，从未逆置的部分中拿出节点，添加到已逆置的部分中去，直至全部逆置完毕。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3d50358ae2628e4576b982dbd954837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e680f5ac91faced5bd785c4e368ba66/" rel="bookmark">
			OPENCV面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.opencv中RGB2GRAY是怎么实现的
答：以R、G、B为轴建立空间直角坐标系，则RGB图的每个象素的颜色可以用该三维空间的一个点来表示，而Gray图的每个象素的颜色可以用直线R=G=B上的一个点来表示。于是rgb转gray图的本质就是寻找一个三维空间到一维空间的映射，最容易想到的就是射影（即过rgb空间的一个点向直线R=G=B做垂线），事实上Matlab也是这样做的，输出的灰度图像是RGB三种颜色通道的加权和；
Gray = 0.29900 * R + 0.58700 * G + 0.11400 * B。
灰度可以说是亮度（luminance）的量化值，而RGB的定义是客观的三个波长值，转换时需要考虑人眼对不同波长的灵敏度曲线，所以系数不相等。
目前通过卷积神经网络进行检测的方法主要分为one-stage和two-stage，分别写出了解的对应的算法。
2在共性上两类检测算法有哪些差异？
One-stage：yolov1、yolov2、yolov3、SSD、RetinaNet（2分）
Two-stage：Fast R-CNN、Faster R-CNN（2分）
Two-stage检测算法的共性，以faster r-cnn为例，使用了复杂的网络用于每个候选区域的分类和回归；ROI pooling后的feature channels数目较大，导致内存消耗和计算量都比较大。
One-stage检测算法的共性，从网络结构上看只是多分类的rpn网络，相当于faster rcnn的第一阶段，因此one-stage主要的优势是速度快。其预测结果是从feature map回归出目标的位置及分类，有的也采用了anchor的概念。而two-stage对上述结果进行roi pooling后会进一步细化，因此two-stage算法检测精度一般相对较高。还有一种观点是，two-stage的rpn部分相当于做了正负样本均衡，这也是two-stage检测效果相对较好的一个原因。one-stage算法对小目标检测效果较差，如果所有的anchor都没有覆盖到这个目标，那么这个目标就会漏检。如果一个比较大的anchor覆盖了这个目标，那么较大的感受野会弱化目标的真实特征，得分也不会高。two-stage算法中的roi pooling会对目标做resize, 小目标的特征被放大，其特征轮廓也更为清晰，因此检测也更为准确。
3.连续图像转化为数字图像需要进行哪些操作？
答：取样 量化
4. 数字图像中有哪些基本特征？
答：颜色特征、纹理特征、形状特征、空间关系特征等。
5.图像边缘检测中常用的边缘检测算子有哪些？
答：Roberts算子、Prewitt算子、Sobel算子、Canny算子、Laplacian算子等。
6对霍夫变换的理解
霍夫变换常用来提取图像中的直线和圆等几何形状。它通过一种投票算法检测具有特定形状的物体。该过程在一个参数空间中通过计算累计结果的局部最大值得到一个符合该特定形状的集合作为霍夫变换结果。
答案
针对每个像素点，使得theta从-90度到180度，使用极坐标p = xcos(theta) + ysin(theta) 计算得到共270组（p，theta）代表着霍夫空间的270条直线。将这270组值存储到H中。
如果一组点共线，则这组点中的每个值，都会使得H（p，theta）加1。
因此找到H（p，theta）值最大的直线，就是共线的点最多的直线，H（p，theta）值次大的，是共线点次多的直线。可以根据一定的阈值，将比较明显的线全部找出来
7对HOG特征的理解
问题解析
HOG（Histogram of Oriented Gridients的简写）特征检测算法，一种解决人体目标检测的图像描述子，是一种用于表征图像局部梯度方向和梯度强度分布特性的描述符。其主要思想是：在边缘具体位置未知的情况下，边缘方向的分布也可以很好的表示行人目标的外形轮廓。
整体流程简单描述如下：
1将输入图像（你要检测的目标或者扫描窗口）灰度化，即将彩色图转换为灰度图
2颜色空间归一化：采用Gamma校正法对输入图像进行颜色空间的标准化（归一化）,目的是调节图像的对比度，降低图像局部的阴影和光照变化所造成的影响，同时可以抑制噪音的干扰
3梯度计算：计算图像每个像素的梯度（包括大小和方向）；主要是为了捕获轮廓信息，同时进一步弱化光照的干扰
4梯度方向直方图：将图像划分成小cells（例如88像素/cell）, 统计每个cell的梯度直方图（不同梯度的个数），即可形成每个cell的描述符
5重叠直方图归一化：将每几个cell组成一个block（例如33个cell/block），一个block内所有cell的特征descriptor串联起来便得到该block的HOG特征描述符。
6HOG特征：将图像image内的所有block的HOG特征描述符串联起来就可以得到该image（你要检测的目标）的HOG特征描述符，就得到最终的可供分类使用的特征向量了
答案
HOG的主要思想是：在一副图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布（即梯度的统计信息，而梯度主要位于边缘的地方）很好地描述。HOG特征检测算法的几个步骤：颜色空间归一化—&gt;梯度计算—&gt;梯度方向直方图—&gt;重叠块直方图归一化—&gt;HOG特征
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e680f5ac91faced5bd785c4e368ba66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d983f7bc27d7e152e579126fc79f08/" rel="bookmark">
			python 一个.py文件如何调用另一个.py文件中的类和函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在同一个文件夹下 调用函数： A.py文件：
def add(x,y): print('和为：%d'%(x+y)) B.py文件：
import A A.add(1,2) 或
from A import add add(1,2) 调用类： A.py文件:
class A: def __init__(self,xx,yy): self.x=xx self.y=yy def add(self): print("x和y的和为：%d"%(self.x+self.y)) B.py文件：
from A import A a=A(2,3) a.add() 或
import A a=A.A(2,3) a.add() 在不同文件夹下 A.py文件的文件路径：E:\PythonProject\winycg
B.py文件：
import sys sys.path.append(r'E:\PythonProject\winycg') '''python import模块时， 是在sys.path里按顺序查找的。 sys.path是一个列表，里面以字符串的形式存储了许多路径。 使用A.py文件中的函数需要先将他的文件路径放到sys.path中''' # 这里在备注一下自己遇到的坑 # 1、导入的文件 或者 包名等 需要符合Python命名规则，比如不能有 - 之类的符号 # 2、如果导入的不是一个包，而是一个Python文件，那么不需要在后面加.py 如果加了，就会报错... import A a=A.A(2,3) a.add() STR_Liang:谢谢博主，辛苦啦~借助贵宝地写一下备注心得
1、append 里面 不需要加r 也可以
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6d983f7bc27d7e152e579126fc79f08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87a8729cc21caf12cc51fc863583fa3/" rel="bookmark">
			echarts下载图片,getDataURL获取base64地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候特殊的需求，需要自定义下载echarts的图片，没有直接调用保存图片saveAsImage的方法，但有个获取base64 的方法，getDataURL();可配参数。
var myChart = echarts.init(); var option = { ........... } myChart.setOption(option); var opts = { type: string, // 导出的格式，可选 png, jpeg pixelRatio: number,// 导出的图片分辨率比例，默认为 1。 backgroundColor: string,// 导出的图片背景色，默认使用 option 里的 backgroundColor excludeComponents: Array.&lt;string&gt; // 忽略组件的列表，例如要忽略 toolbox 就是 ['toolbox'],一般也忽略了'toolbox'这栏就够了 } var resBase64 = myChart.getDataURL(opts); //拿到base64 地址，就好下载了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6482e44852d1e50852174edba79ff59a/" rel="bookmark">
			Okhttp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Http是现在应用常用的一种交换数据和媒体的网络方式，高效地使用http能让资源加载更快，节省带宽。Okhttp是一个高效的Http客户端，它的特性如下：
支持Http/2,允许所有同一个主机地址的请求共享同一个socket连接连接池能够减少请求延时透明的GZIP压缩能够减少响应数据的大小缓存响应内容，避免一些完全重复的请求 当网络请求出现问题的时候okhttp依然坚守自己的职责，它会自动恢复一般的连接问题，如果你的服务有多个ip地址，当第一个ip请求失败时，Okhttp会交替尝试你配置的其他Ip，okhttp使用现代TLS技术初始化新的连接，当握手失败时会回退到TLS1.0
使用 异步GET请求 String url = "http://www.baidu.com"; OkHttpClient okHttpClient = new OkHttpClient(); final Request request = new Request.Builder() .url(url) .get() .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { Log.d(TAG,"onFailure"); } @Override public void onResponse(Call call, Response response) throws IOException { Log.d(TAG,"onResponse: " + response.body().string()); } }); 异步发起的请求会被加入到Dispatcher中的runningAsyncCalls双端队列中通过线程池来执行
同步GET请求 它的最后一步是通过execute（）来提交请求，这种方式会阻塞调用线程，所以在Android中应放在子线程中执行，否则可能引起ANR异常
String url = "http://www.baidu.com"; OkHttpClient okHttpClient = new OkHttpClient(); final Request request = new Request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6482e44852d1e50852174edba79ff59a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c731557e5df31f1bb7238fd8a835d61/" rel="bookmark">
			spring使用@Autowire存在两个同类型bean的时候如何注入以及在spring中bean的名称与什么有关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上结论：
当容器中的bean为单例时，@Autowire为ByType的方式注入，被注入的成员的名称可以任意取名。
当容器中的bean存在多个的情况下，@Autowire为ByName的方式注入，ByName是将bean单例池中的key（bean的名字）与被注入的成员变量的名称匹配，而不是与被注入的成员变量的类型匹配。
关于单例池中的key（bean的name）与什么有关：
如果在类上面加上bean化注解（@service、@controller、@component、@repository），则此bean的name就是这个类首字母小写的驼峰命名。
举个栗子：
@Componet public class TestObject{ } 则TestObject类在容器中的bean的name就是testObject
如果在方法上加@Bean注解，则bean的name就是 方法的名字
再举个栗子：
@Componet public class TestObject{ @Bean public TestObject getTestObjectBean(){ return new TestObject(); } } 则此时spring容器中会有两个TestObject类型的bean，一个叫testObject，一个叫getTestObjectBean。
注意：容器中同时有两个相同name的bean，spring启动会报错！
接下来验证一下容器中同事有两个不同类型的bean的时候，@Autowire如何注入的问题，上一下之前写过的验证代码：
@Component public class UserService implements UserServiceInterface { @Bean public UserService getUserService() { return new UserService(); } } 此时容器中有两个 UserService类型的bean，一个叫userService，一个叫getUserService
@Component public class Config { @Autowired private UserServiceInterface getUserService; @Autowired private UserServiceInterface userService; public UserServiceInterface getUserService() { return this.userService; } public UserServiceInterface getGetUserService() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c731557e5df31f1bb7238fd8a835d61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726306372d38b9dc74055cdc79b882f3/" rel="bookmark">
			地表最强！阿里大牛纯手码17W字，Redis成神之路电子版教程已问世
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为同时具备高性能、高可靠和高可扩展性的典型键值数据库，Redis不仅功能强大，而且稳定，理所当然地成为了大型互联网公司的首选。
众多大厂在招聘的时候，不仅会要求面试者能简单地使用Redis，还要能深入地理解底层实现原理，并且具备解决常见问题的能力。可以说，熟练掌握Redis已经成为了技术人的一个必备技能。
但是，在学习和使用Redis的过程中，总不可避免地遇见一些棘手的问题，比如：
Redis的key和数据结构应该怎么设计？有什么最佳实践？Redis集群如何均衡数据？又如何横向扩展？怎么保证数据的一致性？热点数据的问题怎么解决？RDB持久化生成的数据快照，每次更新是全量更新还是增量更新？缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题怎么解决？如何高效阅读Redis源代码？ 我根据自己多年的从业经验，梳理了一套系统的Redis学习方法。将纷繁复杂的Redis知识和问题归纳在“两大维度，三大主线”这个框架之中，帮助读者建立起系统观和全局观，从而彻底搞懂底层实现原理。让我们来看看大体内容：
Redis简介
Redis与Memcached区别Redis优点Redis缺点 Redis数据类型
StringHashListSetSorted set Redis事务
MULTI&amp;EXEC（原子执行，并非互斥）WATCH&amp;UNWATCH（原子执行+乐观锁） Redis分布式锁
排他锁 SETNX带有超时特性的锁 Redis持久化机制
RDB（Redis Database，全量模式）AOF（Append Only File，增量模式）触发方式相互比较RDB最佳策略AOF最佳策略Redis消息队列 Redis高级数据结构
BitMap（String的一些其他命令）过期策略内存淘汰策略主从复制（数据是同步的，类似于MySQL Replication）哨兵 sentinel（数据是同步的）集群（数据是分片的，sharing）Hash映射（并非一致性哈希，而是哈希槽）数据分片节点间通信协议——Gossip主从选举——Raft功能限制数据迁移/在线扩容Codistwemproxy 配置文件+应用场景+Lua脚本+与DB保持一致
Redis源码
线程模型——单线程RedisObject 这份文档从构建一个键值数据库的关键架构入手，不仅带你建立起全局观，还帮你迅速抓住核心主线。除此之外，还会具体讲解数据结构、线程模型、网络框架、持久化、主从同步和切片集群等，帮你搞懂底层原理。相信这对于所有层次的Redis使用者都是一份非常完美的教程了。
快速入手通道：（点这里）下载！诚意满满！！！
Java面试精选题、架构实战文档传送门：https://docs.qq.com/doc/DRW1nUkdhZG5zeGVi
整理不易，觉得有帮助的朋友可以帮忙点赞分享支持一下小编~
你的支持，我的动力；祝各位前程似锦，offer不断！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4cf92f5dca5c387452ff0418d81dd2/" rel="bookmark">
			JDK 各版本开发者关注的特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java SE 支持路线图
官方特性文档
1. Java 1.0 初代版本 2. Java 1.1 JDBC(Java DataBase Connectivity)内部类RMI(Remote Method Invocation)反射Java Bean 3. JDK 1.2 集合框架JIT(Just In Time)编译器jar数字签名JFC(Java Foundation Classes), 包括Swing1.0, 拖放和Java 2D类库Java 插件JDBC引入可滚动结果集, BLOB, CLOB, 批量更新和用户自定义类型Applet 声音支持JSP/Servlet,EJB 规范 4. Java 1.3 Java Sound APIjar 文件索引 5. Java 1.4 XMLJava 打印服务Logging APIJava WebJDBC 3.0 API断言Preferences API链式异常处理支持IPv6支持正则表达式引入Image I/O API 6. Java 1.5 泛型增强for循环自动装箱与拆箱类型安全的枚举可变参数静态引入元数据(注解)Instrumentation 7. Java 6 支持脚本语言JDBC 4.0 APIJava Compiler API可插拔注解增强对Native、PKI、Gss、Kerberos和LDAP 支持集成WebServices 8. Java 7 switch 语句块中支持字符串作为分支条件创建泛型对象时应用类型推断一个语句块捕获多种异常支持动态语言引入NIO 2 开发null值自动处理钻石型语法 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4cf92f5dca5c387452ff0418d81dd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dffdf9cd552e485bdfb21d9f3c90df1/" rel="bookmark">
			ideapush代码报错：Push rejected: Push xxx to origin/xxx.x was rejected by remote 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案如下：
1.切换到自己项目所在的目录，右键选择GIT BASH Here(也可以在ideal中操作)
git pull
git pull origin xxx
git pull origin xxx --allow-unrelated-histories
3.在idea中重新push自己的项目。
如果还不行： git push -u origin xxx -f
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7052f90de2b75def61094c5d2c73cd7a/" rel="bookmark">
			指令系统之指令格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、指令格式
什么是指令？ 指令其实就是机器语言0和1组成的语句，指令可以操控硬件来实现某种基本功能。多个指令组成的系统就叫指令系统。
指令系统一般和硬件设计耦合比较高，硬件一般跟随指令来设计，所以不同的硬件，同一套指令系统是不能兼容的（同一个厂商制作的硬件可能会支持）。
指令格式 一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。
一条指令通常由操作码和地址码来组成：
图 1 指令格式 上图表示的只是一个抽象的概念，并没有指出其中具体的内容。下面举个实际的例子：
图 2 指令格式 图2是A1与A2操作后将结果放在A3中，A4是下一条指令的地址，以便当前指令执行完后继续执行下一条指令。简化后就是：A1 (OP) A2 -&gt; A3, A4=.....
地址指令 上面说的指令格式其实就叫四地址指令，因为有四个地址。一个地址就是一个二进制串。
OP是整条指令需要完成的功能，后面四个是主存中取的地址。假设这条四地址指令为OP(00000000) A1( 000001) A2( 000010) A3(占位，存放结果位) A4( 000100)
设OP=00000000 代表“+”法操作，A1=000001，A2=000010， A3=000001 + 000010 = 000011,A4=000100，那么执行的过程如下图：
图 3 指令执行过程 指令对应主存中的内容为了识别方便，采用了16进制表示。
假设指令字长为32位，操作码占8位，4个地址码字段各占6（32-8=24,24/4=6）位。设存储字长为32位，即4Bit。那么A1可直接表示2^6 = 64个不同位置。一条指令的执行（假设每个地址都是主存地址）：
取指令 访问1次 （假设指令字长=存储字长，为了一次就可以取完）取2个操作数 访存2次存回结果 访存1次 共计4次
二、指令寻址方式
上面介绍了四地址指令，那么可不可以省点地址呢？上面的情况是指令和地址存放在一起，如果我们把指令归为一类，操作地址归为一类，是不是就可以不需要下一个指令地址呢？
图 4 程序计数器 有了程序计数器单元的加入，我们的指令变得精简和容易了。指令的下一条地址可以根据地址位顺位移动即可，方便查找；我们也不需要每次重复的单独给出指令地址空间，来存放下一条指令了。经过这样优化以后，就变成了“三地址指令”格式了。
寻址范围
上面说指令格式时说过，设指令字长及存储字长均为32位，操作码占8位。
图 5 四地址指令 4个地址码字段各占6位（32-8=24,24/4=6），指令操作数直接寻址范围为2^6=64，完成一条指令需要访存4次。
图 6 三地址指令 因为有了“程序计数器”，可以省略下一个指令地址存放空间。3个地址各占8位（32-8 = 24,24/3 =8），指令操作数直接寻址范围为2^8=256，完成一条指令需要访存次数还是4次（取指令，取A1，取A2，结果存回A3）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7052f90de2b75def61094c5d2c73cd7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2efcf34211722b4020e5d5ba03565585/" rel="bookmark">
			【已解决】海康威视MFC综合示例(C&#43;&#43; 官网Demo)采用VS2019编译异常如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采用VS2019编译运行海康威视MFC综合示例Demo 一、文章背景：二、操作步骤：1、海康威视设备网络SDK下载：2、VS2019 MFC开发环境配置：3、MFC综合示例编译运行： 三、小结： 一、文章背景： 今天下午有个从事海康威视监控业务的朋友突然找我帮忙，朋友从海康威视官网下载了一个 CH-HCNetSDKV6.1.4.42_build20200527_win32 海康设备SDK压缩包，其中的C++ MFC综合示例. ClientDemo.sln 采用VS2019编译报错异常无法启动。
爽快的答应后被坑了好几个小时才把Demo示例跑起来，顺手写个文章记录一下，后来者可以少踩一些坑坑。
项目已调通，可直接单击下载运行；
二、操作步骤： 1、海康威视设备网络SDK下载： 当前最新版本：SDK_V6.1.4.42(for Windows32)官方下载地址：https://www.hikvision.com/cn/download_more_401.html#prettyPhotoMFC综合示例目录：CH-HCNetSDKV6.1.4.42_build20200527_win32\Demo示例\1-
MFC综合示例\ ClientDemo.sln 2、VS2019 MFC开发环境配置： 打开 Visual Studio Installer =&gt; 修改 =&gt; 单个组件
选择 单个组件 勾选如下4个组件：
3、MFC综合示例编译运行： 用VS2019打开MFC综合示例 ClientDemo.sln：
根据IDE提示升级项目Windows SDK 版以及平台工具：
F6直接编译项目报错：
错误 C4430 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int ClientDemo E:\项目合集\CH-HCNetSDKV6.1.4.42_build20200527_win32\头文件\DecodeCardSdk.h 152
解决方法：
头文件地址： CH-HCNetSDKV6.1.4.42_build20200527_win32\头文件\DecodeCardSdk.h
第11行代码： #define DLLEXPORT_API extern “C” __declspec(dllexport) ；
extern "C"后面需要增加一个空格
F6继续编译项目报错：
（1）警告 MSB8004 Output 目录未以斜杠结尾。 此生成实例将添加斜杠，因为必须有这个斜杠才能正确计算 Output 目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2efcf34211722b4020e5d5ba03565585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b74d2be9987cb6cc095b99b23f4adb9/" rel="bookmark">
			java web&#43;前端实现 人脸登录功能（专注细节）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次的博客是自己软件工程课设的作业，写博客是为了记录自己的学习过程，然后总结，同时可以给需要的人作参考。 1、在做这个项目的时候，也是个大三学生，所以懂得并不多，因此在网上看见了一些相关的资源，但是都不是很清醒比较混乱，因此做完这个项目就想发表下自己的意见，以帮助需要的人（这里我们可以用数据库，也可以不用数据库，因为我做的这个项目并不是仅仅一个人脸识别，还有其他的业务，所以我用到了数据库，如果仅仅想弄个人脸注册登录的业务，可以不需要数据库）
让我们进入正题吧： 一、Web端人脸识别主要有三个技术思路： 1.前端的人脸识别，例如使用Tensorflow.js， 2.后台人脸识别，有很多开源或者免费的SDK可以使用 3.前后端结合，即结合以上两种方法，虽然系统复杂度提高，但对于系统的安全性，以及减轻服务器负担都有很大提升。 （本次的实验是调用百度云的Api以及前后端结合的方式去实现人脸注册以及登录的功能）
让我们先看下效果图吧： 1、登录的首页：
2、注册页面，因为我们想要人脸登录，首先要注册你自己的人脸保存百度云脸库中去
3、人脸识别登录
在这个登录页面我们要好好讲一讲，因为在做这个项目的时候，自己花了很多时间。
1、首先我们要明白，我这个前端页面调用电脑摄像头是自动截取图片的每1秒截取一张，所以不用我们点击确认登录(这里我们也没有这个按钮)，它把我们的图片以base64字节码的形式采用异步Ajax的形式传到后台。
··
4、遇到错误上后台查找原因（遇到最多的就是你的脸不在摄像头的正中间，也就是有效范围）
二、因为在百度云上申请自己的账号（免费），注册自己的人脸库 1、我的百度云人脸库
2、如何创建人脸库（刚开始你们自己肯定没有所以需要创建，创建成功会给你一个API key 及Secret Key，这回头我们在程序中调用人脸库，这个就是地址）
3、连接百度云人脸库，无论是人脸检测、人脸搜索、人脸对比，身份验证、都需要首先获取access_token(这个类百度云Api文档里面都有，我知道大家懒，所以直接复制在这里面了)
package com.baidu.ai.aip.auth; import org.json.JSONObject; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; import java.util.List; import java.util.Map; /** * 获取token类 */ public class AuthService { /** * 获取权限token * @return 返回示例： * { * "access_token": "24.460da4889caad24cccdb1fea17221975.2592000.1491995545.282335-1234567", * "expires_in": 2592000 * } */ public static String getAuth() { // 官网获取的 API Key 更新为你注册的 String clientId = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b74d2be9987cb6cc095b99b23f4adb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91f0db7422a1f002c1054b1d23c6c08/" rel="bookmark">
			unity连接手机设备调试FrameDebug和Profiler，Memory加载和卸载调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先ProjectSettings中设置：
2.直接选择 BuildAndRun会自动安装到手机并在Editor中输出，打开frameDebug，![在这里插入图片描述](https://img-blog.csdnimg.cn/20200812221226982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pzMDkwNw,size_16如上图中所示：首先点击左上角的“Enable”，然后活动右侧的进度条查看整个渲染的先后顺序和步骤。
3.如果不使用 BuildAndRun，请点击图中间的“Editor”选中“Enter IP" 输入手机设备的ip
连接成功的标志：“Editor”变为：“AutoConnectPlayer”则链接成功。
注意：连接时，手机上的所要被调试的app一定要在运行状态！！！！！！，然后才能连接成功。
4.当连接成功后，滑动进度条，手机上的画面也会随进度条变化~~。
连接Profiler进行调试，步骤也是相同的，只不过打开的时Profiler而已，这里简单介绍一下Profile工具中各按钮的意义
先选CPU，再选Hierachy，然后才会出现unity底层的引擎函数参数
在点击Record，然后在你选中某一帧后，unity会自动暂停，下面“MainThread"主线程 和“Render”渲染线程在的详细数据
接下来再介绍一下Memory的参数：
Memory加载和卸载,是否卸载干净，可以通过途中的方法查看到（记得要重新采样欧）
此处的加载和卸载，突然感觉有想说好多{ 编辑器下的加载卸载，bundle模式下的加载和卸载}，算了，想详细了解，请查看博主的其它文章吧，里面有关于加载和卸载的详细介绍
（最后）！！！！ 使用adb 数据线连接电脑，调试android手机的性能！！！！
adb连接方法
出于无奈。。。
吐槽一下 ：
（1） 手机wife和电脑不是同一个网段
（2）安装包首包不会经常打包， 其余的内容走热更新
我就问 还有谁~~，==。。。。。。。fuck。。。直接不能方便的wife连接了！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4055e864d59f8c3fbd6f7e28722070/" rel="bookmark">
			关于vue中extendAPI的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请移步这篇文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba7fc2213739418bd505b02ed47a93e/" rel="bookmark">
			相机标定过程中，根据得到的标定参数进行重投影计算的推导过程（推导公式对后续LM算法中计算Jacobian矩阵有重要作用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在研究相机标定。在得到相机初始参数之后，需要利用LM算法对初始参数进行优化，这就涉及到了在优化过程中使用的Jacobian矩阵如何计算的问题。本文推到了利用相机标定的初始参数表示的重投影坐标表达式，希望对大家理解LM算法中的Jacobian矩阵，以及优化过程有帮助。不知道为何图片无法旋转 ：(
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d169ced8a53d48787b21229c9ed0077/" rel="bookmark">
			使用Node.js在私有AWS S3中存储图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里插入代码片@TOC
AWS学习笔记（一） 因为公司没有自己的服务器，利用AWS S3来存储图片，将生成的URL值存入Postgresql数据库。
今天在这里简单介绍操作步骤，同时也感谢分享原作者gravity well (Rob Tomlin)
Amazon Web Services S3概述 亚马逊Web服务(AWS)允许用户使用其基于云的对象存储服务——亚马逊简单存储服务(Amazon Simple storage service, Amazon S3)来存储图像等文件，它们存储在S3 bucket中。
要了解关于Amazon S3的更多信息，请查看的这篇文章Jovan Hernandez和这一篇文章Gonzalo P.
在这篇文章中，主要实现通过node.js在web页面上显示存储在S3 bucket中的图像。这样就可以避免将图片存储在文件系统中。
开始部署 AWS 假设
这里假设你已经有了私有的S3 bucket，具体起什么名字都是可以的，或者就叫做upload-image
-demo。也假设你已经有了 IAM credentials或者 EC2 角色可以允许连接 S3 bucket。 我是用的是Visual Studio Code(VSCode)，并使用node.js 安装。
创建web服务器 首先，先使用express 来创建服务器
创建一个目录，并使用VSCode打开文件夹创建一个名叫index.js的文件，然后在Terminal窗口中打入如下内容来创建package.json，使index.js文件为默认。 npm init -y
在终端中输入下边一行代码安装 express npm install express
在index.js中构建我们的基础网页服务器 const express=require(‘express’);
const app=express();
const PORT=3200;
// Our default route
app.get(’/’,(req,res)=&gt;{
res.send(‘Testing’);
})
app.listen(PORT,()=&gt;{
console.log(Web Server running on port ${PORT});
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d169ced8a53d48787b21229c9ed0077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba5eb6e1f1dfcc999be8a7caf7a71eb/" rel="bookmark">
			如何将证件照修改成任意尺寸和任意存储大小（kb）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题引出 对于已经拍好的一寸证件照，在使用时总是会遇到尺寸和存储大小的问题，比如请将照片设置为800*600大小，图片的大小不超过200kb。这里就使用快捷的方式，两分钟搞定这个问题
问题解决 1、打开美图秀秀网页版 美图秀秀网址，比如单位要求照片的尺寸为800*600,这里我们创建一个对应尺寸的画布。 2、插入图片 3、保存图片 设置了尺寸大小和存储大小，大功告成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2978a9267bc3edbb7c075646afb51b/" rel="bookmark">
			当在地址栏中输入内容回车时，浏览器干了啥？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当在地址栏中输入内容回车时，浏览器干了啥？ 浏览器进程中的UI线程会监听到用户的输入，并判断输入内容类型，如果是关键字，则会使用默认配置的搜索引擎来查询，如果是域名，则会交给网络线程处理，通过DNS解析获取IP地址，接着开始与服务器建立TCP连接获取数据，获取到数据后，浏览器的安全系统会检查是否存在安全问题，如果存在，则会提示用户，用户也可选择无视，继续访问，接着网络线程会通知UI线程准备完毕，然后UI线程会创建一个渲染器进程，并通过IPC管道把数据传递给渲染器进程来渲染页面，接着渲染器进程的主线程开始逐层深入解析HTML生成DOM Tree，在解析的过程中如果发现JS脚本，则会停止解析，执行JS脚本，接着继续解析HTML，DOM Tree生成后，接着解析样式，然后基于DOM Tree和样式生成Layout Tree（Layout Tree和DOMTree并不是一一对应的，比如：display: none的节点不在Layout Tree中，而::before、::after这种伪元素不在DOM Tree中），有了Layout Tree后，我们还需要知道以什么顺序绘制（paint），主线程会遍历Layout Tree创建绘制记录表，该表记录了绘制的顺序，确保在屏幕上显示正确的层级，接着遍历Layout Tree生成Layer Tree图层树，接着主线程将Layer Tree和绘制顺序信息传递给合成器线程，合成器线程按规则进行分图层，并将每个图层栅格化，由于一层可能像整个页面一样大，所以会拆分成若干个图块，然后将每个图块发送给栅格化线程处理，栅格化线程处理完后将他们存储在GPU内存中，合成器线程将按需收集这些图块信息（draw quads）生成一个合成器帧（Compositor Frame），接着通过IPC将合成器帧传回给浏览器进程，然后交给GPU渲染展示到屏幕上，用户就看到了页面内容，当后续页面再发生变化，都会生成一个新的合成器帧，再传到GPU进行渲染，当我们改变某个元素的尺寸位置属性时，会重新进行样式计算、布局、绘制以及后面的所有流程，这种行为我们称为重排，当我们改变某个元素的颜色属性时，不会重新触发布局，但还是会触发样式计算和绘制，这个就是重绘，重排和重绘都会占用主线程，JS也是运行在主线程上，所以就会出现抢占执行时间的问题，如果写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算、布局和绘制的操作，我们知道当页面以每秒60帧的刷新率（1000/60≈每帧16ms）才不会让用户感觉到卡顿，如果在运行动画时还有大量的JS任务需要执行，当在一帧的时间内布局和绘制结束后如果还有剩余时间，JS就会拿到主线程的使用权，如果JS执行时间过长，在下一帧开始时还没有及时归还主线程，就会导致下一帧动画没有按时渲染，出现动画的卡顿，可以通过两种手段优化，第一种就是通过requestAnimationFrame()这个API来帮助我们解决，这个方法会在每一帧的剩余时间内调用，下一帧开始前暂停JS执行，归还主线程，通过API的回调，我们可以把JS任务分成一些更小的任务块，React最新的渲染引擎React Fiber就是用到了这个API来做了很多优化，第二种优化方法，由于分图层和栅格化的整个流程是不占用主线程的，只在合成器线程和栅格线程中运行，这就意味着它无需和JS抢夺主线程，我们刚才提到如果反复进行重排和重绘可能会导致掉帧，这是因为有可能JS执行阻塞了主线程，而CSS中有个动画属性叫transform，通过该属性实现的动画不会经过样式计算、布局和绘制，而是直接运行在合成器线程和栅格化线程中，所以不会受到主线程中JS执行的影响，更重要的是，节省了很多运算时间，一般位置变化，宽高变化等等，都可以使用transform来代替。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c14b63a5c916a7680843db053471f5/" rel="bookmark">
			用 LDA 方法进行数据分类的 Python 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片来源于网络，文末附本文源码下载方法
笔者之前写过一篇名为《用PCA方法进行数据降维》的文章，文章中主要讲述了如何用PCA（主成分分析）来对数据进行降维的方法。而今天笔者将介绍另一种常用的数据降维方法——LDA。
LDA的全称是linear discriminant analysis，即线性判别分析，LDA与PCA一样，都可用于数据降维，但二者既有相似也有区别，PCA主要是从特征/维度的协方差角度，去找到比较好的投影方式，即选择样本点投影具有最大方差的方向，而LDA则是寻找一个投影方向，让原先的数据在这个方向上投影后，不同类别之间数据点距离尽可能大，而同类别数据点距离尽可能小。此外PCA属于无监督式学习，很多情况下需要配合其他算法使用，而LDA属于监督式学习，本身除了可以用于降维外，还可以进行预测分析，说白了就是既可以“团战”，也可以单独打怪。而本文就主要讲述如何用LDA来进行数据分类，当然这里面肯定也会用到降维的原理。
LDA的大致原理如图1所示。图1中左图是按照常规坐标系来分析，这时可以看到数据有部分重叠，在分类时可能会有干扰，这时我们就要找到一个投影方向，让这些数据在这个方向上的投影，做到类之间距离尽可能大，类内数据尽可能聚集，如右图所示。
图1. LDA原理图
下面再简单介绍一下LDA的数学原理。
以最简单的两个类别为例，假设Xi、ui、Σi分别表示第i类样本点的集合、均值向量、协方差矩阵，若将数据投影到直线w上，则两类样本的中心在直线上的投影分别是w^Tu1和w^Tu2，在所有样本点都投影到直线上后，两类样本的协方差分别是w^TΣ1w和w^TΣ2w。我们要想让类别之间距离更大、类内距离更小，也就是要使图2中的（1）式最大。在这里我们再定义两个概念，一个是类内散度阵（within-class scatter matrix），即图2中（2）式，一个是类间散度阵（between-class scatter matrix），即图2中（3）式。那么这个让（1）式最大的问题就转化为最大化一个瑞利熵，即最大化（4）式。
图2. LDA部分推导公式
而求解（4）式也就是相当于求解图3中（5）式，用拉格朗日乘法求解，得到图3中（6）式，这就转化成了一个求特征方程的问题了，也就是求n-1个最大特征值所对应的特征向量（n是维度）。这个按照我们正常求解特征方程就可以了。
图3. LDA部分推导公式
在实际使用中，如果按照上述原理推导会非常麻烦，但是scikit-learn中已经为我们提供了现成的LDA方法，我们只要直接调用即可，下面就以scikit-learn为例，来看一下LDA在实际使用中的效果。
这次选用的数据集是鸢尾花数据集，来自seaborn库，大小为150行、5列，数据集样例如图4所示。
图4. 鸢尾花数据集样例
首先还是导入各种库。
import numpy as np import pandas as pd import seaborn as sns import matplotlib.pyplot as plt from sklearn.metrics import classification_report from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA 然后是设置训练数据集和测试数据集。熟悉鸢尾花数据集的人都知道，这个数据集中150个样本点可以分为3个类别，每个类别各有50个样本点，这三个类别是'setosa'、'versicolor'和'virginica'，可以用代码set(data['species'].values)来查看这三个值。我们在这里要设置训练集和测试集，就要在每个类别中都取得一定量的数据，笔者的方法是选取总数据集中60%的数据为训练集，即训练集一共是90个样本点，其中每个类别取前30个样本点，而测试集就是剩下的60个样本点，每个类别就是20个，代码如下。
data = sns.load_dataset('iris') #总数据集 data_train = data.iloc[np.r_[0:30, 50:80, 100:130]] #训练集 data_test = data.iloc[np.r_[30:50, 80:100, 130:150]] #测试集 train_x = data_train.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c14b63a5c916a7680843db053471f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06582b932d9c243894a5069a978c416f/" rel="bookmark">
			element-ui_NavMenu-典型导航菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element-ui_NavMenu-典型导航菜单 目录 文章目录 1、效果展示2、element-ui 导航菜单组件2.1、el-menu 菜单2.2、el-submenu 子菜单2.3、el-menu-item 菜单项 3、实现***后记*** ： 内容 1、效果展示 通过点击三根白色竖线对应的区域，实现导航菜单的展开和折叠
展开示例效果0-1：
折叠示例效果0-2：
2、element-ui 导航菜单组件 通用插槽
&lt;template slot="title"&gt; &lt;i class="el-icon-user-solid"&gt;&lt;/i&gt; &lt;span&gt;会员管理&lt;/span&gt; &lt;/template&gt; i标签：图标，class指定图标名称，具体参考官网
位置：放置在span标签前，图标出现在文字前；放置在span标签后，出现在文字后 span标签内文字：显示在菜单项中的文字
2.1、el-menu 菜单 常用属性详解 属性名类型可接受值默认描述background-colorstring-#ffffff白色背景色text-colorstring-#303133文本颜色default-activestring--默认激活的菜单项，一般设置为子菜单active-text-colorstring-#409EFF激活的菜单项字体颜色unique-openedbooleantrue/falsefalse是否只展开一个菜单及其子菜单项，即不同时展开多个菜单项（一级菜单）collapsebooleantrue/falsefalse是否折叠collapse-transitionbooleantrue/falsefalse是否显示折叠动画routerbooleantrue/falsefalse是否激活vue-router模式 2.2、el-submenu 子菜单 属性名类型可接受值默认描述indexstring--菜单项唯一标志，配合router属性使用 2.3、el-menu-item 菜单项 属性名类型可接受值默认描述indexstring--菜单项唯一标志，配合router属性使用 3、实现 template代码：
&lt;div class="btn-toggle" @click="toggleCollapse"&gt;|||&lt;/div&gt; &lt;el-menu background-color="#333744" text-color="#fff" default-active="/report" active-text-color="#ffd04b" unique-opened :collapse="isCollapse" :collapse-transition="false" router &gt; &lt;el-submenu index="/index"&gt; &lt;template slot="title"&gt; &lt;i class="el-icon-s-home"&gt;&lt;/i&gt; &lt;span&gt;首页&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index="/report"&gt; &lt;template slot="title"&gt; &lt;i class="el-icon-menu"&gt;&lt;/i&gt; &lt;span&gt;报表&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-submenu index="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06582b932d9c243894a5069a978c416f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32e9f2081303971b8faa1332427625d/" rel="bookmark">
			python对列表元素排序并返回元素索引序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在信息检索或top-n推荐中，我们会为用户推荐一个有序产品列表，这里的“有序”体现在列表中前面的产品相比于列表后面的产品被算法预测为更容易被用户选择，这要求我们按每个产品出现的概率对产品进行排序。可以参考以下示例：
# 按列表a中元素的值进行排序，并返回元素对应索引序列 a = [1, 3, 4, 5, 2, 7, 9] print('a:', a) sorted_id = sorted(range(len(a)), key=lambda k: a[k], reverse=True) print('元素索引序列：', sorted_id) 结果为： a: [1, 3, 4, 5, 2, 7, 9] 元素索引序列： [6, 5, 3, 2, 1, 4, 0] 可以看到这里用到了sorted函数，改函数可以指定键对可迭代对象进行排序，功能比较强大。关于该函数的具体使用方法可以参考：
Python3 sorted() 函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e831aca2892cc94e0f538630a77f0dc5/" rel="bookmark">
			《Spring Cloud 微服务实战》第3章 服务治理Eureka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在《Spring Cloud 微服务实战》第一章中介绍了Spring Cloud的常用模块：
Eureka是属于Spring Cloud Netflix的一部分。主要负责服务治理功能。
那什么是服务治理：
服务治理主要就是实现各个微服务之间的服务自动注册与发现。
Eureka同其他服务注册中心一样，支持高可用 配置。它依托于强一致性提供良好的服务实例可用性，通过集群部署，当集群中有分片出现故障时， 那么Eureka就转入自我保护模式。 它允许在分片故障期间继续提供服务的发现和注册， 当故障分片恢复运行时， 集群中 的其他分片会把它们的状态再次同步回来。Netflix推荐每个可 用的区域运行一个Eureka服务端，通过它来形成集群。不同可用区域的服务注册中心通过 异步模式互相复制各自的状态， 这意味着在任意给定的时间点每个实例关于所有服务的状 态是有细微差别的。
搭建注册中心 在书本的第41页
注册中心高可用
EurekaServer的高可用实际上就是将自己作为服务向其他服务注册中心注册自己， 这 样就可以形成一组互相注册的服务注册中心， 以实现服务清单的互相同步， 达到高可用的 效果。 下面我们就来尝试搭建高可用服务注册中心的集群。
服务的发现与消费
而服务消费的任务由伈bbon完成 。Ribbon是一 个基
千HTTP和TCP的客户端负载均衡器，它可以在通过客户端中配置的 ribbonServerList 服务端列表去轮询访问以达到均衡负载的作用。
服务下线
服务下限会通知注册中心，
注册中心自我保护机制：
保护网络不稳定的情况下，服务的心跳不能全部送达注册中心，注册中心会开启自我保护机制，以确保维护这些服务，但是会造成剔除有问题的服务不及时。所以可以关闭自我保护机制
eureka.server.enable-self-preservation=false
@EnableDiscoveryClient：一个客户端注册到注册中心拉取服务列表需要这个注解
下面这个两个是我所在的公司使用的注解（请忽略，我写在这里只是为了理清他们的关系）：
@EnableEurekaClient
@EnableFeignClients
真正实现服务发现的是DiscoveryClient，这个类用于帮助与Eureka Server互相协作。
Eureka Client负责下面的任务:
-向Eureka Server注册服务实例
-向Eureka Server服务租约
当服务关闭期间， 向Eureka Server取消租约
-查询Eureka Server中的服务实例列表 服务续约
eureka.instance.lease-renewa l-interval-in-seconds= 30 eureka.instance.lease-expiration-duration-in-seconds= 90
对于所有eurake服务治理体系下的服务都需要配置eurake客户端，
Eureka客户端的配置主要分为以下两个方面。
• 服务注册相关的配置信息， 包括服务注册中心的地址、 服务获取的间隔时间、 可用区域等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e831aca2892cc94e0f538630a77f0dc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c150886800c9b6049b38961e2df4c3e6/" rel="bookmark">
			Connection refused: connect问题解决方案集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）端口号被占用：杀死占用端口号（一般为8080）的进程，释放端口；彻底关闭 Tomcat 服务器，或者重新启动项目。
2）使用以下命令检查服务器中允许的最大进程数： ulimit -u。如果将此值设置为较低值，例如1024，则使用以下值将其增加到131072或无限制：ulimit -u 131072 或者 ulimit -u无限制 。
3）客户端和服务器，它们中的任何一个或两个都不在网络中。它们可能没有连接到LAN或互联网或任何其他网络，在这种情况下，Java将会抛出客户端的“ java.net.ConnectException：Connection refused ”异常。
4）服务器未运行用是服务器已关闭但未运行。在这种情况下，你也会得到java.net.ConnectException：连接被拒绝错误。可ping来检查服务器是否正在运行并侦听端口。5）服务器正在运行但没有侦听端口，客户端正在尝试连接。服务器正在运行但是正在侦听不同的端口。验证配置。如果你正在处理一个大项目，并有一个分层配置文件，它可能是默认配置或其他一些设置覆盖了您正确的设置。
6）主机端口组合不允许使用防火墙几乎每个企业网络都受防火墙保护。如果您正在连接其他公司网络，例如在任何电子交易系统中，需要提高防火墙双方要求确保他们允许彼此的IP地址和端口号。如果防火墙不允许连接，也会收到相同的java.net.ConnectException：Java应用程序中的连接拒绝异常。
7）主机端口组合不正确。提供的主机端口组合不正确，或者服务器端的早期主机端口组合已经更改。检查客户端和服务器端的最新配置。8）连接字符串中的协议不正确TCP是许多高级协议的基础协议，包括HTTP，RMI等。通过连接时字符串，你需要确保你传递正确的协议，服务器期望。例如服务器已暴露，通过 RMI 而不是连接字符串的服务应该以rmi：// 开头。
我的问题：由于个人项目是分布式，启动顺序出错而导致，这本身是个小错误，但是因为出了错就顺带看了看别的原因，大家根据自己的原因来作参考。另外感谢那些积极把自己的解决方案写出来的童鞋，我只是做了一个总结。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6cbbce8fa815a5522ff64250d57489/" rel="bookmark">
			Intel RealSense D435i &#43; BundleFusion 实现实时三维建图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容概览 摘要操作环境RealSense D435i 介绍BundleFusion工程环境配置安装 RealSense SDKRealSense SDK 本地环境配置BundleFusion 工程属性表相机类型设置修改 GlobalAppState.h 文件修改 FriedLiver.h 文件 添加 RealSense 相关实现类 生成解决方案error C3646出错原因解决方案 error LNK2001出错原因解决方案 配置文件修改修改 zParametersDefault.txt修改 zParametersBundlingDefault.txt 模型生成结语 摘要 BundleFusion由斯坦福大学、德国 MPII 以及微软研究院共同开发，用于实时构建高精度三维模型，是目前效果最好的开源算法框架。论文：《BundleFusion: Real-time Globally Consistent 3D Reconstruction using Online Surface Re-integration》。本文主要介绍了如何使用 Intel RealSense D435i 系列深度相机在开源算法框架 BundleFusion 中实现实时三维建图。
操作环境 环境项版本/型号操作系统Win10_x64开发工具集Visual Studio 2013计算架构CUDA 8.0深度相机Intel RealSense D435i显卡NVIDIA GeForce 940MX 其中，CUDA 8.0 与 DirectX SDK 的安装配置、BundleFusion 工程代码生成（包括 mLib 与 mLib external 配置、CUDA 设置以及显卡算力设置等）可参照博文《BundleFusion在win10+vs2013+cuda8.0上的实现》。
请务必将 FriedLiver.vcproj 文件中的 cuda 版本修改为本地安装版本，否则 VS2013 将无法打开 BundleFusion 工程！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba6cbbce8fa815a5522ff64250d57489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a72b721343dfa5f14762a5b7ae45ed/" rel="bookmark">
			常用类库-DateFormat（格式化日期）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 DateFormat是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化和分析日期或时间。 日期/时间格式化子类（例如SimpleDateFormat ）允许格式化（即，日期→文本），解析（文本“日期”）和规范化。 日期表示为Date对象或自1970年1月1日00:00:00 GMT以来的毫秒数。
基础知识 使用方法 public abstract class DateFormat extends Format 注意：DateFormat为抽象的类，不能直接使用
1.format方法 package DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class DateFormatTest { public static void main(String[] args) throws ParseException { SimpleDateFormat date = new SimpleDateFormat("yyyy年MM月dd日"); Date date1 = new Date(); //将Date对象转换为字符串"yyyy年MM月dd日" String test = date.format(date1); System.out.println(test); } } 作用：将Data对象转为定义的格式
结果：电脑上今天的日期
parse方法 Date date2 = date.parse("2020年1月1日"); System.out.println(date2); 作用：将按照格式写的字符串转为Date对象
结果：
计算输入的日期的差值 SimpleDateFormat date = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74a72b721343dfa5f14762a5b7ae45ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9698ef2a4029e6a3ce090fcec7217c7e/" rel="bookmark">
			OrbitControls.js:16 Uncaught ReferenceError: THREE is not defined     at OrbitControls.js:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;script src="./OrbitControls.js"&gt;&lt;/script&gt;
&lt;!-- &lt;script src="http://www.yanhuangxueyuan.com/versions/threejsR92/build/three.js"&gt;&lt;/script&gt; --&gt;
我明明引入了OrbitControls.js，为啥还是报错，
THREE.OrbitControls = function ( object, domElement ) //X
OrbitControls.js:16 Uncaught ReferenceError: THREE is not defined
at OrbitControls.js:16
————————————————————————————————————————————————
啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊
害我去找了了一圈，说引入的版本不对，那我就去在线实例里面引入了别人的地址：
&lt;script src="http://www.yanhuangxueyuan.com/versions/threejsR92/build/three.min.js"&gt;&lt;/script&gt;
&lt;script src="http://www.yanhuangxueyuan.com/versions/threejsR92/examples/js/controls/OrbitControls.js"&gt;&lt;/script&gt;
球球你们给我点个赞，奥里给。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c0e9589c1feab6a27d7b238f6ecb428/" rel="bookmark">
			spring cloud Hystix熔断机制--基本熔断配置和Fegin client熔断配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓的熔断机制和日常生活中见到电路保险丝是非常相似的，当出现了问题之后，保险丝会自动烧断，以保护我们的电器， 那么如果换到了程序之中呢？
当现在服务的提供方出现了问题之后整个的程序将出现错误的信息显示，而这个时候如果不想出现这样的错误信息，而希望替换为一个错误时的内容。
一个服务变慢了，后续的其他调用者服务跟着不能用了，这就是雪崩效应
对于熔断技术的实现需要考虑以下几种情况：
· 出现错误之后可以 fallback 错误的处理信息；
· 如果要结合 Feign 一起使用的时候还需要在 Feign（客户端）进行熔断的配置。
一、基于ribbon的Hystrix 基本配置 1、复制项目重命名为springcloud-moveServer-hystrix修改调用方 pom.xml 配置文件，追加 Hystrix 配置类： &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 2.修改程序 controller package com.pupeiyuan.controller; import java.util.ArrayList; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import com.netflix.appinfo.InstanceInfo; import com.netflix.discovery.EurekaClient; import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; import com.pupeiyuan.bean.NhReportStatusHistory; @RestController @RefreshScope public class ConfigClientController { //spring 提供用于访问rest接口的模板对象 @Autowired @Qualifier(value = "remoteRestTemplate") private RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c0e9589c1feab6a27d7b238f6ecb428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/652d463271eb73e8ddd2ffe3c8eff27c/" rel="bookmark">
			深入分析Druid存储结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章作者：吴建超
作者博客：jackywoo.cn
内容来源：作者授权
出品平台：DataFunTalk
导读：Apache Druid是一款优秀的OLAP引擎，众所周知数据存储格式对一款存储系统来说是最核心的组件，Druid的数据格式是自定义的，以此保证了在海量数据下的亚秒级查询。本文深入分析Druid V1版本数据存储格式，包括索引结构和数据在磁盘中的存储方式。在阅读本文之前希望您对Druid和数据存储有简单了解。
Druid的存储方式是列式的，每个列为一个逻辑文件，列与列之间的数据格式是相对独立的。与传统OLAP系统一样，Druid的列分为维度与度量两种，其中维度列因为需要被检检索，所以设计了索引，维度列的数据格式也是Druid数据结构的核心；相对的度量列只需要存储行值就可以。为了方便阐述数据格式，本文以一个广告效果分析作为例子进行分析，图1中是样例数据，请一定注意它是聚合后的数据，而不是原始数据。
01 维度数据结构 上文提到维度是Druid存储结构的核心，并且各个维度是相对独立存储的，所以我们可以通过分析单个维度的数据结构，来窥探Druid的存储结构。图2展示了"city"维度和两个度量的逻辑存储结构，整体上Druid维度的索引包含三部分：字典、编码后的维度值、倒排索引，接下来详细分析这三部分。
02 字典 字典是将列的所有值去重，然后按照字典顺序排序的值组成的数组，虽然字典中只存储了排序后的维度值，但是它还隐含了另一个信息，那就是每个维度值的编码值，编码值就等于数组的下标。字典的设计目的有两个：一是维度值可以使用编码后的整数表示，而不是实际的值，编码值一般可以节约存储空间；二是编码后的整数是定长的，磁盘中定长存储可以省去定位单个值的offset length等索引信息的开销，最终还是能节省存储空间。
图3展示了Druid字典的逻辑结构和物理结构，Druid字典采用了线性的数组结构。因为字典中的值是不定长的，所以物理结构中有一段index部分，其中记录了每个值的offset；data部分每个值的头部记录了该值的长度。这样的设计才能定位到任意一个行的值。
03 编码后的维度值 Druid是一个预聚合的方案，但是其聚合不是按照一个维度的group-by聚合，而是按照所有维度的group-by聚合，对于图1中的数据已经是按照聚合过了。可以看出对于单一维度而言，编码过后的维度值依然可能重复，所以每个维度的行信息不能用字典代替，而需要额外存储。
编码后的维度值都是一个个的整数。为了保证单一值在磁盘中能快速定位，在整个维度范围内这些整数需要是定长的，因为定长元素组成的数组可以通过计算直接定位到某一个元素。同时为了节约存储空间这些整数不一定需要用4个字节表示，它的长度取决于该维度在单一数据文件内的唯一值的数量，Druid采用了采用了变长整数编码的方式，具体如下：
1 – 2^8-1 =&gt; 1 byte 2^8 - 2^16-1 =&gt; 2 bytes 2^16 - 2^24-1 =&gt; 3 bytes 2^24 - 2^32-1 =&gt; 4 bytes 2^32 - 2^40-1 =&gt; 5 bytes ... 以图1中"city"维度为例，它包含唯一值3个，所以每个值用1个字节表示。
图4展示了编码后维度值的逻辑结构和物理结构，在逻辑上整个维度是一个线性的结构，但是在物理存储上数据结构中包含了offset索引和元素length部分，这很明显是存储非定长数据的。原来Druid将整个线性结构首先划分成了一个个分组，每个分组大小不超过64KB，而分组又进行了压缩，压缩后的分组已经是非定长的了，所以站在整个数据结构的角度，需要按照非定长数据的格式进行存储。
将整个整数数组进行分组压缩的设计思路，其背后的考量点主要是：一是对于磁盘存储压缩是有必要的，因为能减小空间占用和传输消耗；二是分组也是有必要的，因为绝大多数读取数据的场景不会涉及到所有的分组，而是部分分组，分组后一次查询只涉及到了少数分组，对于查询速度的提升有极大帮助。
04 倒排索引 最后是倒排索引部分，对于字典中的每个元素，Druid都会生成一个Bitmap，其中1表示该bit下标对应的行的值是对应字典元素的值，反之不是。
Bitmap数据是基于聚合后的数据的，所以它的长度和原始数据的行数是没有关系的。从图5中"Beijing"对应的Bitmap可以看出，它基于图1中的聚合后的数据，而不是原始数据，所以Bitmap的长度是4。
Druid的反向索引采用的是Bitmap的方案，因为字典中每个元素对应的Bitmap的长度都是一样的，所以物理存储上可以采用定长的方式？其实不是的，出于节省存储空间的考虑，Druid将每个Bitmap进行了压缩，一般Bitmap数据结构的压缩比例是比较大的，所以压缩的是有必要的。因为压缩后数据长度不相同了，所以存储上需要按照非定长数据进行存储。
05 数组 Druid是支持数组数据类型维度的，对于数组数据类型Druid如何存储呢？整体上数组的存储方式还是字典、编码后的维度值、倒排索引三个部分。其中字典和倒排索引部分是跟单值类型的维度的存储方式没有任何区别。
但是在编码后的维度值部分是有区别的，对于单值维度这部分的逻辑结构是一个线性列表 ( 这里暂时不考虑分组 )，但是对于数组类型的维度，它其实是一个二层的层次结构，外层是一个非定长的线性列表，线性列表的每个元素也就是内层，是一个定长的线性列表。对于整个数据结构来说，在物理结构上依然可以进行分组和压缩。
06 存储结构小结 对于物理结构来说其元素是否定长，对其存储方式起到决定作用，图6总结了定长和非定长的存储模式，请注意这里没有考虑分组和压缩。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/652d463271eb73e8ddd2ffe3c8eff27c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c889b7fb279e0c84fe916249e49d29e2/" rel="bookmark">
			【python】版本3.8.3引入numpy报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小白初学python发现引入numpy报错，版本3.8.3，大神来帮忙看看
import numpy
Traceback (most recent call last):
File "&lt;input&gt;", line 1, in &lt;module&gt;
File "C:\Program Files\JetBrains\PyCharm Community Edition 2020.1.2\plugins\python-ce\helpers\pydev\_pydev_bundle\pydev_import_hook.py", line 21, in do_import
module = self._system_import(name, *args, **kwargs)
ModuleNotFoundError: No module named 'numpy'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f073150807b6a889381485e3b7ef887/" rel="bookmark">
			java写csv文件超过16位处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //java io 写入Excel时防止第16位数字 被置0 解决办法
String newStr = "\t"+ str + "\t"; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbdfb671e59e58ba604170b930f3623/" rel="bookmark">
			IDEA 启动找不到或无法加载主类两种解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA 启动找不到或无法加载主类 问题就是spring boot项目在IDEA中，启动类右键运行，控制台提示：错误: 找不到或无法加载主类 xxx.xxx.xxx.xxxx 启动类包名。 问题原因：运行启动类的时候代码没有编译到target目录下如下图 发现编译过后的文件中并没有启动类的相关class文件,因此导致启动找不到或无法加载主类。 正常的文件内容编译过后是有启动类的如下图 解决方法一 可以使用maven来解决如下图操作 编译成功之后你会发现启动就成功了，但是太过繁琐，每次都要使用maven来操作编译（不推荐）。 解决方法二 第一步关闭当前项目，如下图 然后再重新Import导入一次项目就解决了。 然后选择你的项目文件夹 注意，我这里是Maven项目，所以直接导入Maven项目就可以了。然后一直Next即可，最后Finish就好了，这样导入一次后，再去运行启动类，就没有问题了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d890d429469e2a594bc0f9af663ceb/" rel="bookmark">
			初创公司的项目网络搭建：web服务，samba服务，NFS服务，DNS服务的混合搭建实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 公司业务的需求二.公司网络拓扑图三. 网络的构建与服务的搭建3.1 首先打通所有网络，让网络数据能联通3.11 1.对于三层交换机的设置3.12 出口路由的配置3.13 运营商路由器R2的配置 3.2 公司内部的web服务器的搭建3.3 samba,NFS服务器搭建，绑定vm1网卡3.31 搭建NFS存储共享服务3.32 搭建samba存储数据管理服务 3.4 外网web服务器，搭建apache3.5 外网的DNS解析服务器配置3.51 DNS的基本配置文件修改3.52 各个网站服务器做域名解析映射3.53 DNS 域名解析的测试内网和外网进行验证 一. 公司业务的需求 1.搭建HTTP服务，让外网服务器能访问出去公网IP
2.NFS服务创建挂在目录/opt/www 和公司web服务器/var/www/htm1/关联挂载
3.Samba服务器创建不同团队的共享目录，主账户分别是t1,t2 对应的共享目录是/opt/t1和/opt/t2,团队1下面有一个子账户tom，对t1目录只能读，不能写。团队下面有一个子账户jack 对t2目录只能读，不能写
4.要求团队1和团队2的成员能访问公司外网服务（测试用samba服务器来访问）
5.DNS服务 202.0.0.100 www.51xit.top
203.0.0.03 www.kgc.com
二.公司网络拓扑图 三. 网络的构建与服务的搭建 3.1 首先打通所有网络，让网络数据能联通 3.11 1.对于三层交换机的设置 1）交换机接口的配置
interface GigabitEthernet0/0/1 port link-type access port default vlan 10 interface GigabitEthernet0/0/2 port link-type access port default vlan 20 #interface GigabitEthernet0/0/3 port link-type access port default vlan 30 #interface GigabitEthernet0/0/4 port link-type access port default vlan 50 #interface GigabitEthernet0/0/5 port link-type access port default vlan 30 2）各个vlan配置网关地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93d890d429469e2a594bc0f9af663ceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c47706ccc3414e197fd48b73068135/" rel="bookmark">
			2020-08-09
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言50 程序通过定义学生结构体变量，存储了学生的学号、姓名和3门课的成绩。函数fun的功能是将形参a所指结构体变量s中的数据进行修
改.并把a中地址作为函数值返回主函数，在主函数中输出修改后的数据。
例如︰a所指变量s中的学号、姓名和三门课的成绩依次是∶10001、"ZhangSan’、95、80、88，修改后输出t所指变量的数据应为:
10002、“LiSi”、96、81、89。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6334979a78aa61fd25f34d33e89fe8c2/" rel="bookmark">
			SQL Server 行转列，列转行。多行转成一列（含STUFF()函数的用法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、多行转成一列（并以","隔开） 表名：A
表数据：
想要的查询结果：
查询语句
SELECT name , value = ( STUFF(( SELECT ',' + value FROM A WHERE name = Test.name FOR XML PATH('') ), 1, 1, '') ) FROM A AS Test GROUP BY name; PS：STUFF语句就是为了去掉第一个【逗号】
附STUFF用法：（从原字符的第二个开始共三个字符替换为后面的字符）
SELECT STUFF('abcdef', 2, 3, 'ijklmn'); 查询结果：aijklmnef
二、一列转成多行
表名：tb
表数据：
想要的结果：
查询语句：
SELECT a.[name],b.[value] FROM (SELECT [name],[value]=CAST('&lt;v&gt;'+REPLACE([value],',','&lt;/v&gt;&lt;v&gt;')+'&lt;/v&gt;' AS xml) FROM tb) a OUTER APPLY (SELECT [value]=T.C.value('.','varchar(50)') FROM a.[value].nodes('/v') AS T(C)) b 三、行转列（转自大神张志涛的博客 http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6334979a78aa61fd25f34d33e89fe8c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9452ddab311221a82b95d26951470a5f/" rel="bookmark">
			UDS-会话层服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.会话层服务
该服务接口定义了一组用于获取会话层功能的服务，如数据的发送、接收、协议参数的设置。
所有会话层服务定义了三组服务原语(service primitives)，服务原语定义了服务使用者（如，diagnostic application）与服务提供者（如， session layer）间的相互合作。三组服务原语如下：
-服务请求原语 S_Data.request: 应用层用来向会话层传递控制信息或需要发送的数据。结构如下：（S_Mtype, S_SA, S_TA, S_TAtype, [S_AE],S_Data [Data#1, Data#2,...], S_Length）
-服务指示原语 S_Data.indication: 会话层用来向应用层传递状态信息或接收到的数据。结构如下：（S_Mtype, S_SA, S_TA, S_TAtype, [S_AE], S_Result）
-服务确认原语 S_Data.confirm：应用层用来向会话层传递控制信息。结构如下：
（S_Mtype, S_SA, S_TA, S_TAtype, [S_AE], S_Data [Data#1, Data#2,...], S_Length, S_Result）
注：
S_Mtype: 会话层报文类型，有diagnositics, remote diagnostics两种. 如果为diagnositcs, 地址信息包括S_SA, S_TA, S_TAtype; 如果为remote diagnositcs, 地址信息包括S_SA, S_TA, S_TAtype, S_-AE;
S_SA: 会话层源地址，2 byte的无符号整型，范围0x0000 - 0xFFFF;
S_TA: 会话层目标地址，2 byte的无符号整型，范围0x0000 - 0xFFFF;
S_TAtype: 会话层目标地址类型，有physical（1对1通信），functional（1对多通信）两种；
S_AE: 会话层地址扩展（可选），2 byte的无符号整型，范围0x0000 - 0xFFFF;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9452ddab311221a82b95d26951470a5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd16194945c934a69b89519d746cfe6/" rel="bookmark">
			基于vue2.0的活动倒计时组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2-countdown 基于vue2.0的活动倒计时组件
可以使用服务端当前时间
在倒计时开始或者结束的时候,可以自定义回调
文档：https://cgygd.github.io/vue2-countdown/
demo：https://cgygd.github.io/vue2-countdown/example/index.html
示例.png
安装 1.cnpm/npm
npm install vue2-countdown --save 2.Git 下载源码
git clone https://github.com/cgygd/vue2-countdown 使用 &lt;count-down v-on:end_callback="countDownE_cb()" :currentTime="currentTime" :startTime="startTime" :endTime="endTime" :tipText="'距离订单开始还有'" :tipTextEnd="'距离订单关闭还剩'" :endText="'订单已关闭'" :dayTxt="'天'" :hourTxt="'小时'" :minutesTxt="'分钟'" :secondsTxt="'秒'"&gt; &lt;/count-down&gt; import CountDown from 'vue2-countdown' components: { CountDown }, data() { return { currentTime:0, startTime:0, endTime:0, } }, methods: { countDownS_cb: function (x) { console.log(x) }, countDownE_cb: function (x) { console.log(x) } } 参数解释 currentTime -- 当前时间戳,如果不传,默认获取用户本地的时间(建议传服务器的当前时间)
type: Number
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd16194945c934a69b89519d746cfe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de692f00658045eac44f0f56b637bac5/" rel="bookmark">
			马拉车算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.
回文就是正反读都是一样的字符串,如aba, abba等
Input
输入有多组case,不超过120组,每组输入为一行小写英文字符a,b,c…y,z组成的字符串S
两组case之间由空行隔开(该空行不用处理)
字符串长度len &lt;= 110000
Output
每一行一个整数x,对应一组case,表示该组case的字符串中所包含的最长回文长度.
Sample Input
aaaa
abab
Sample Output
4
3
马拉车算法首先将字符串前增加一个特殊符号@，然后再加入#，为了使奇 偶字符变成都变成偶字符串，方便操作。
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using namespace std; char s[211000],c[111000]; int p[211000]; void init()//这个地方的函数就是处理奇偶字符串的。 { int i,j; s[0]='@'; for(i=0;c[i]!=0;i++) { s[2*i+1]='#'; s[2*i+2]=c[i]; } s[2*i+1]='#'; s[2*i+2]=0; } int manacher() { int id=0,mx=0,i; for(i=1;s[i]!=0;i++) { if(mx&gt;i) p[i]=min(p[2*id-i],mx-i); else p[i]=1; while(s[i+p[i]] == s[i-p[i]])//上面的语句只能确定i~mx的回文情况，至于mx之后的部分是否对称，就只能老老实实去匹配了，匹配一个p[i]++ p[i]++; if(i+p[i]&gt;mx)//当t[i]匹配的 右边界超过mx时mx和id就更新 { mx=i+p[i]; id=i; } } mx=0; for(i=1;s[i]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de692f00658045eac44f0f56b637bac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4fd756efe75e4392b3b7ad95a7a6dfe/" rel="bookmark">
			[Python人工智能] 二十二.基于大连理工情感词典的情感分析和情绪计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从本专栏开始，作者正式研究Python深度学习、神经网络及人工智能相关知识。前一篇文章分享了CNN实现中文文本分类的过程，并与贝叶斯、决策树、逻辑回归、随机森林、KNN、SVM等分类算法进行对比。这篇文章将详细讲解通过自定义情感词典（大连理工词典）实现情感分析和情绪分类的过程，并与SnowNLP进行对比，为后续深度学习和自然语言处理（情感分析、实体识别、实体对齐、知识图谱构建、文本挖掘）结合做基础，希望对您有所帮助~
本专栏主要结合作者之前的博客、AI经验和相关视频及论文介绍，后面随着深入会讲解更多的Python人工智能案例及应用。基础性文章，希望对您有所帮助，如果文章中存在错误或不足之处，还请海涵！作者作为人工智能的菜鸟，希望大家能与我在这一笔一划的博客中成长起来。写了这么多年博客，尝试第一个付费专栏，为小宝赚点奶粉钱，但更多博客尤其基础性文章，还是会继续免费分享，该专栏也会用心撰写，望对得起读者。如果有问题随时私聊我，只望您能从这个系列中学到知识，一起加油喔~
TF下载地址：https://github.com/eastmountyxz/AI-for-TensorFlowKeras下载地址：https://github.com/eastmountyxz/AI-for-Keras情感分析地址：https://github.com/eastmountyxz/Sentiment-Analysis PS：本文参考了作者YX学生的学习思路，以及哈工大邓旭东老的方法，再次非常感激，向他们学习。
文章目录 一.大连理工中文情感词典二.七种情绪计算三.七种情绪词云可视化1.基本用法2.统计七种情绪特征词3.词云分析 四.自定义词典情感分析五.SnowNLP情感分析六.总结 同时推荐前面作者另外五个Python系列文章。从2014年开始，作者主要写了三个Python系列文章，分别是基础知识、网络爬虫和数据分析。2018年陆续增加了Python图像识别和Python人工智能专栏。
Python基础知识系列：Python基础知识学习与提升Python网络爬虫系列：Python爬虫之Selenium+BeautifulSoup+RequestsPython数据分析系列：知识图谱、web数据挖掘及NLPPython图像识别系列：Python图像处理及图像识别Python人工智能系列：Python人工智能及知识图谱实战 前文：
[Python人工智能] 一.TensorFlow2.0环境搭建及神经网络入门
[Python人工智能] 二.TensorFlow基础及一元直线预测案例
[Python人工智能] 三.TensorFlow基础之Session、变量、传入值和激励函数
[Python人工智能] 四.TensorFlow创建回归神经网络及Optimizer优化器
[Python人工智能] 五.Tensorboard可视化基本用法及绘制整个神经网络
[Python人工智能] 六.TensorFlow实现分类学习及MNIST手写体识别案例
[Python人工智能] 七.什么是过拟合及dropout解决神经网络中的过拟合问题
[Python人工智能] 八.卷积神经网络CNN原理详解及TensorFlow编写CNN
[Python人工智能] 九.gensim词向量Word2Vec安装及《庆余年》中文短文本相似度计算
[Python人工智能] 十.Tensorflow+Opencv实现CNN自定义图像分类案例及与机器学习KNN图像分类算法对比
[Python人工智能] 十一.Tensorflow如何保存神经网络参数
[Python人工智能] 十二.循环神经网络RNN和LSTM原理详解及TensorFlow编写RNN分类案例
[Python人工智能] 十三.如何评价神经网络、loss曲线图绘制、图像分类案例的F值计算
[Python人工智能] 十四.循环神经网络LSTM RNN回归案例之sin曲线预测
[Python人工智能] 十五.无监督学习Autoencoder原理及聚类可视化案例详解
[Python人工智能] 十六.Keras环境搭建、入门基础及回归神经网络案例
[Python人工智能] 十七.Keras搭建分类神经网络及MNIST数字图像案例分析
[Python人工智能] 十八.Keras搭建卷积神经网络及CNN原理详解
[Python人工智能] 十九.Keras搭建循环神经网络分类案例及RNN原理详解
[Python人工智能] 二十.基于Keras+RNN的文本分类vs基于传统机器学习的文本分类
[Python人工智能] 二十一.Word2Vec+CNN中文文本分类详解及与机器学习（RF\DTC\SVM\KNN\NB\LR）分类对比
《人工智能狂潮》读后感——什么是人工智能？(一)
一.大连理工中文情感词典 情感分析 (Sentiment Analysis)和情绪分类 (Emotion Classification）都是非常重要的文本挖掘手段。情感分析的基本流程如下图所示，通常包括：
自定义爬虫抓取文本信息；使用Jieba工具进行中文分词、词性标注；定义情感词典提取每行文本的情感词；通过情感词构建情感矩阵，并计算情感分数；结果评估，包括将情感分数置于0.5到-0.5之间，并可视化显示。 目前中国研究成熟的词典有大连理工大学情感词汇本体库、知网的 HowNet 情感词典及TW大学中文情感极性词典等。本文选择的基础词典是大连理工大学情感词汇本体库，此词典将情感分为“乐”“好”“怒”“哀”“惧”“恶”“惊”7 个大类和 21 个小类，其情感词的初始情感强度被设置为 1、3、5、7、9 五个等级，较其他词典而言，强度划分得更为细致。情感词的情感极性有中性、褒义、贬义 3 类，分别对应值 0、1、2。为便于计算机作情感计算，文中将代表贬义的极性值2 修改为-1。词汇的情感值公式为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4fd756efe75e4392b3b7ad95a7a6dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a959ed03fb637641ad9e688e62e1997c/" rel="bookmark">
			SpringBoot项目报错：java.sql.SQLSyntaxErrorException: Unknown database ‘mscode‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、错误描述
date:2020-08-09 10:34:16	thread:Druid-ConnectionPool-Create-1976547672	level:ERROR	logger:com.alibaba.druid.pool.DruidDataSource msg:create connection SQLException, url: jdbc:mysql://127.0.0.1:3306/mscode?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8, errorCode 1049, state 42000 java.sql.SQLSyntaxErrorException: Unknown database 'mscode' at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:120) at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97) at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122) at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:835) at com.mysql.cj.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:455) at com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:240) at com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:207) at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1643) at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1709) at com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2715) 二、引起错误的原因
原本电脑上面就有mysql，然后再运行springBoot项目的时候，需要运行一个mysql的bat文件，项目中mysql的端口号被占用
三、解决方案
停止原来安装的mysql服务，把端口号留给项目需要的mysql服务
1、以管理员身份运行cmd，输入net stop mysql
2、重新运行项目的mysql的bat文件，重新启动项目
3、在运行完毕之后，建议重新启动本机的mysql服务，避免在下次使用本机的mysql服务时产生错误。
注：在cmd中输入 net start mysql即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcdd93b5848ed852fe414d4d1288f58b/" rel="bookmark">
			前端导出表格之XLSX使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入xlsx npm install xlsx
XLSX官网
引用 import XLSX from xlsx
H5 table 导出表格 在页面创建table &lt;table border="" id="table"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td rowspan='2'&gt;表头1&lt;/td&gt; &lt;td colspan="2"&gt;表头2&lt;/td&gt; &lt;/tr&gt; &lt;tr &gt; &lt;td&gt;A1&lt;/td&gt; &lt;td&gt;B1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;A2&lt;/td&gt; &lt;td&gt;B21&lt;/td&gt; &lt;td&gt;B22&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 导出方法 downloadExl () { // 初始化 var workbook = XLSX.utils.book_new(); // 数据 var ws1 = XLSX.utils.table_to_sheet(document.getElementById('table')); // 这是 Sheet XLSX.utils.book_append_sheet(workbook, ws1, "Sheet1"); XLSX.writeFile(workbook, 'table.xlsx'); } 3.结果
得到如下图：
跟页面显示的一模一样的数据以及样式。
多个sheet表格导出 在创建一个table2。导出方法 function downloadExlSheelt () { var workbook = XLSX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcdd93b5848ed852fe414d4d1288f58b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7840a8860dcfa26ebd979ab9bf1220fe/" rel="bookmark">
			CC2530定时器T1查询和T3中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章主要讲解CC2530两种定时器控制LED的实验
首先我们了解CC2530 LED部分电路图
一、T1查询方式
T1CTL：定时器1的控制，D1D0控制运行模式，D3D2设置分频划分值
T1STAI：定时器1的状态寄存器，D4 ~ D0为通道4 ~ 0的中断标志，D5为溢出标志位，当计数到最终计数值是自动置1
IRCON：中断标志4,0为无中断请求，1为有中断请求
定时器1的工作原理：
定时器1工作在自由方式下，定时器1开始工作后从0x0000开始加1计算，一直到0xffff。0xffff再加1则溢出，发生溢出中断。此时定时器将发出一个溢出中断请求并将IRCON的D1置为1。此后定时器自动重新计数，再次从0x0000计数到0xffff。
T1定时器控制LED程序如下：
/*设置定时器，当发生溢出中断时，LED进行一次翻转*/ #include &lt;ioCC2530.h&gt; typedef unsigned char uchar; typedef unsigned int uint; #define LED1 P1_0 void LEDInit(void) { P1DIR |= 0x01; //设置P1_0为输出 LED1 = 1; //LED1初始熄灭 } void TIM1Init(void) { T1CTL |= 0x0d;//128分频，自由计数模式 T1STAT = 0x21;//通道0，中断有效 } void main(void) { uchar count = 0; LEDInit(); TIM1Init(); while(1) { if(IRCON &gt; 0) //是否发生中断 { IRCON = 0; if(count++ &gt;= 0) { count =0; LED1 = !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7840a8860dcfa26ebd979ab9bf1220fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d941abd593254658fd52950b1e73efd3/" rel="bookmark">
			Python PEP8 基本常用规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PEP8规范总结 PEP8 是什么呢，简单说就是一种编码规范，是为了让代码“更好看”，更容易被阅读。 具体有这些规范，参考 PEP 8 –Style Guide for Python Code.当然也可以使用Pycharm检查或使用pylint.下面是规范总结
缩进 不要使用 tab 缩进使用任何编辑器写 Python，请把一个 tab 展开为 4 个空格绝对不要混用 tab 和空格，否则容易出现 IndentationError 空格 在 list, dict, tuple, set, 参数的 逗号 “,” 后面加一个空格在 dict 的 “:” 后面加一个空格在注释符号 # 后面加一个空格，但是 #!/usr/bin/python 的 # 后不能有空格操作符两端加一个空格，如 +, -, *, /, |, &amp;, =接上一条，在参数列表里的 = 两端不需要空格括号（(), {}, []）内的两端不需要空格 空行 function 和 class 顶上两个空行class 的 method 之间一个空行函数内逻辑无关的段落之间空一行，不要过度使用空行不要把多个语句写在一行，然后用 “;” 隔开if/for/while 语句中，即使执行语句只有一句，也要另起一行 换行 每一行代码控制在 80 字符以内使用 \ 或 () 控制换行，举例： def foo(first, second, third, fourth, fifth, sixth, and_some_other_very_long_param): user = User.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d941abd593254658fd52950b1e73efd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d003e2ff1bbefb1d62f17c02da775e04/" rel="bookmark">
			学习笔记：计算机组成原理之系统总线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）基本概念 &lt;1&gt; 计算机系统的五大部件的连接方式有两种：（1）分散连接：各部件之间使用单独连线；（2）总线连接：将各部件连到一组公共信息传输线上。
&lt;2&gt; 总线是连接多个部件的信息传输线，是各部件共享的传输介质。在某一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息。
&lt;3&gt;总线由许多传输线或通路组成，每条线可以一位一位地传输二进制代码，一串二进制代码可以在一段时间内逐一传输完成。若干传输线可以同时传输若干位二进制代码。
&lt;4&gt;总线结构分为单总线结构和多总线结构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799665ca9911ae3b78a231b11c5eb8e0/" rel="bookmark">
			如何裁剪动图像素？gif裁剪尺寸的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用gif动图的时候，相信经常与图片打交道的小伙伴们一定遇到过gif上有一部分是不想要的，例如多余的logo、或者动图上有黑边，想要去掉黑边等等情况，那么在遇到这种情况的时候大家都是怎么解决的呢？有什么办法能简单又快速的完成gif裁剪（https://www.yasuotu.com/gifcaijian）吗？当然有，下面就来给大家推荐一款动图裁剪工具，在线就能完成动图裁剪，下面一起来看一下吧。
1.打开压缩图网站，选择所有功能-gif裁剪功能。
2.点击上传图片按钮即可将本地需要裁剪的图片上传到网站中。
3.图片上传后，可以拖动裁剪框的位置来改变裁剪位置、拖动裁剪框的边缘来改变裁剪框的大小，也可以再下方选择预设的裁剪尺寸或自行输出数值来确定裁剪框的大小。
4.确认参数无误后，点击裁剪按钮即可开始裁剪，图片裁剪完成后点击下载按钮即可将裁剪后的动图下载至本地。
以上就是带给大家的裁剪动图的步骤了，按照以上方法进行操作即可完成gif裁剪，既不用下载PS浪费时间，也不用担心裁剪后的gif变成静态图片，这么好用的gif裁剪软件大家快收藏起来吧，以后需要使用时直接可以使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5412a9f0259d5538cee5ec785a4e073b/" rel="bookmark">
			使用电脑远程操作Jetson nano桌面3--解决远程桌面无法打开终端问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.操作背景
电脑：Windows 7系统
开发板：Jetson nano ，安装ubuntu 18.04系统
现有成果：已成功实现电脑远程Jetson nano桌面
问题：远程访问桌面时，无法打开Terminal终端
2.解决方法
修改terminal指向
1）$ sudo update-alternatives --config x-terminal-emulator
2）输入xterm对应的数字:5
之后在右键，即可打开终端。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fbfdd9580239776604f1720bdb07d38/" rel="bookmark">
			通过npm安装http-server实现本地服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤一： 先创建一个文件夹，然后打开cmd命令窗口，用cd命令进入这个文件夹。
步骤二： 用cd命令进入这个文件夹后，然后通过以下命令来使用npm安装http-server：
npm install -g http-server 或者：
cnpm install -g http-server 步骤三： 安装完成后，cmd输入http-server即可开启本地服务器。
http-server 然后把你的项目文件拉入这个文件夹即可运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d042f020cdf08449d26ace119174b08/" rel="bookmark">
			bfs,dfs入门题单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文按照笔者认为的难度，对洛谷题单的部分搜索题，按难度排一个序，以便于日后能够快速回忆起搜索题的思路。
仅根据个人观点排列，不喜勿喷
简单题
P1443 马的遍历
P1596 [USACO10OCT]Lake Counting S
P1162 填涂颜色
中等题
P1019 单词接龙
P1032 字串变换
P1135 奇怪的电梯
难题
P1101 单词方阵
P1825 [USACO11OPEN]Corn Maze S
当然做完的时候会觉得这些题其实都不难，根据bfs,dfs的板子，一套就可以了，只要注意一些细节方面的东西就可以。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4adc9ad6efc56f98054df909b3a1ce7/" rel="bookmark">
			DSP学习 -- cJSON使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如需转载请注明出处 https://juyou.blog.csdn.net/article/details/107870229
JSON 需要简单的了解一下。谁知道啥时候用上呢~
一、JSON简介 参看：JSON简介
参看：cJSON使用详细教程 | 一个轻量级C语言JSON解析器
参看：千万不要点开,Cjson入门快速使用看这篇就够了(CJSON入门操作以及问题讲解，CJSON对象删除出错)
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。
JSON建构于两种结构：
“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。
值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。
这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。
JSON具有以下这些形式：
对象是一个无序的“‘名称/值’对”集合。一个对象以 {左括号 开始， }右括号 结束。每个“名称”后跟一个 :冒号 ；“‘名称/值’ 对”之间使用 ,逗号 分隔。
数组是值（value）的有序集合。一个数组以 [左中括号 开始， ]右中括号 结束。值之间使用 ,逗号 分隔。
值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。这些结构可以嵌套。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4adc9ad6efc56f98054df909b3a1ce7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fc9ec4c38bf5a2913bcb1287d836767/" rel="bookmark">
			计算机网络各层网络设备（中继器、集线器、网桥、交换机、路由器、网关）总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络中，有几个通信设备或者说网络设备名词出现的频率相当的高，它们是：中继器、集线器、网桥、交换机、路由器和网关。现在梳理一下它们各自的含义和作用，以及它们之间的联系。这些网络设备对于实际工作中并不全面，比如现在已经出现了三层交换机、四层交换机，但是理念是基本共通的。
文章目录 OSI七层模型物理层设备中继器问题：中继器是否可以无限使用？ 集线器问题：连接到一台集线器的多台计算机如何工作 数据链路层设备网桥网桥的缺点网桥的分类 局域网（以太网）交换机局域网（以太网）交换机原理以太网交换机的特点以太网交换机的两种交换模式 网络层设备路由器路由器的体系结构转发和路由选择的区别网桥和路由器的区别 网络层之上的设备：网关网络设备常见问题设备是否能分离广播域或冲突域的问题交换机和路由器的区别为什么有时候还要在路由器的后面先接1台交换机再接计算机 OSI七层模型 首先回顾下OSI七层模型
OSI分层（7层）：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。
TCP/IP分层（4层）：网络接口层，网际层，运输层，应用层
五层协议（5层）：物理层，数据链路层，网络层，运输层，应用层
物理层设备 中继器 中继器（RP repeater）又称转发器，主要功能是将信号整形并放大再转发出去，以消除信号经过一长段电缆后，因噪声或其他原因而造成的失真和衰减，使信号的波形和强度达到所需要的要求，进而扩大网络传输的距离。
原理
信号再生（而非简单地将衰减的信号放大）。中继器有两个端口，数据从一个端口输入，再从另一个端口发出。端口仅作用于信号的电气部分，而不管数据中是否有错误数据或不适于网段的数据。
中继器是局域网环境下用来扩大网络规模的最简单、最廉价的互联设备。使用中继器连接的几个网段仍然是一个局域网。一般情况下，中继器的两端连接的是相同的媒体，但有的中继器也可以完成不同媒体的转接工作。但由于中继器工作在物理层，因此它不能连接两个具有不同速率的局域网。中继器两端的网络部分是网段，而不是子网。中继器若出现故障，对相邻两个网段的工作都将产生影响。
它属于一种模拟设备，用于连接两根电缆段。中继器不理解帧、分组和头的概念，他们只理解电压值。
问题：中继器是否可以无限使用？ 在采用粗同轴电缆的10BASE5 以太网规范中，互相串联的中继器的个数不能超过4 个，而且用4 个中继器串联的5 段通信介质中只有3段可以挂接计算机，其余两段只能用作扩展通信范围的链路段，不能挂接计算机。这就是"5-4-3 规则”
集线器 集线器(Hub) 实质上是一个多端口的中继器，它也工作在物理层。当Hub工作时，一个端口接收到数据信号后，由于信号在从端口到Hub 的传输过程中已有衰减，所以Hub便将该信号进行整形放大，使之再生（恢复）到发送时的状态，紧接着转发到其他所有（除输入端口外）处于工作状态的端口。如果同时有两个或多个端口输入，那么输出时会发生冲突，致使这些数据都无效。从Hub 的工作方式可以看出，它在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，而不具备信号的定向传送能力，即信号传输的方向是固定的，是一个标准的共享式设备。
Hub 主要使用双绞线组建共享网络，是从服务器连接到桌面的最经济方案。在交换式网络中，Hub 直接与交换机相连，将交换机端口的数据送到桌面上。使用Hub 组网灵活，它把所有结点的通信集中在以其为中心的结点上，对结点相连的工作站进行集中管理，不让出问题的工作站影响整个网络的正常运行，并且用户的加入和退出也很自由。
由Hub组成的网络是共享式网络，但逻辑上仍是一个总线网。Hub的每个端口连接的网络部分是同一个网络的不同网段。同时Hub也只能在半双工状态下工作，网络的吞吐率因而受到限制。
问题：连接到一台集线器的多台计算机如何工作 多台计算机必然会发生同时通信的情形，因此集线器不能分割冲突域，所有集线器的端口都属于同一个冲突域。集线器在一个时钟周期中只能传输一组信息，如果一台集线器连接的机器数目较多，且多台机器经常需要同时通信，那么将导致信息碰撞，使得集线器的工作效率很差。比如，一个带宽为10Mb/s的集线器上连接了8 台计算机，当这8 台计算机同时工作时，每台计算机真正所拥有的带宽为10/8Mb/s = 1.25Mb/s 。
数据链路层设备 网桥 网桥(Bridge)是一个局域网与另一个局域网之间建立连接的桥梁。是早期的两端口二层网络设备。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。网桥比集线器（Hub）性能更好，集线器上各端口都是共享同一条背板总线的。后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。
虽然网桥和集线器长得很像，但是网桥处理数据的对象是帧，所以它是工作在数据链路层的设备，中继器、放大器处理数据的对象是电气信号，所以它是工作在物理层的设备。
两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就称为一个网段。网桥工作在链路层的MAC子层，可以使以太网各网段成为隔离开的冲突域。如果把网桥换成工作在物理层的转发器，那么就没有这种过滤通信量的功能。由于各网段相对独立，因此一个网段的故障不会影响到另一个网段的运行。
网桥的缺点 增大了时延（存储转发）MAC子层没有流量控制功能（流量控制要用到编号机制，编号机制的实现在LLC子层）不同的MAC子层的网段桥接在一起时，需要进行帧格式的转换网桥只适合用户数不多和通信量不大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞，这就是所谓的网络风暴 网桥的分类 使用源路由网桥可以利用最佳路由。若在两个以太网之间使用并联的源路由网桥，则还可使通信量较平均地分配给每个网桥。
采用透明网桥时，只能使用生成树，而使用生成树一般并不能保证所用的路由是最佳的，也不能在不同的链路中进行负载均衡。
局域网（以太网）交换机 桥接器的主要限制是在任一时刻通常只能执行一个帧的转发操作，于是出现了局域网交换机，又称以太网交换机。从本质上说，以太网交换机是一个多端口的网桥，它工作在数据链路层。交换机能经济地将网络分成小的冲突域，为每个工作站提供更高的带宽。以太网交换机对工作站是透明的，因此管理开销低廉，简化了网络结点的增加、移动和网络变化的操作。
局域网（以太网）交换机原理 以太网交换机的原理是，它检测从以太端口来的数据帧的源和目的地的MAC (介质访问层） 地址，然后与系统内部的动态查找表（自学习）进行比较，若数据帧的MAC 地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口。
以太网交换机的特点 以太网交换机的每个端口都直接与单台主机相连（普通网桥的端口往往连接到以太网的一个网段），并且一般都工作在全双工方式。以太网交换机能同时连通许多对端口，使每对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。以太网交换机也是一种即插即用设备（和透明网桥一样），其内部的帧的转发表也是通过自学习算法自动地逐渐建立起来的。以太网交换机由于使用了专用的交换结构芯片，因此交换速率较高。以太网交换机独占传输媒体的带宽。 对于普通l0Mb/s 的共享式以太网，若共有N 个用户，则每个用户占有的平均带宽只有总带 宽(l0Mb/s) 的1/N。在使用以太网交换机时，虽然从每个端口到主机的带宽还是10Mb/s, 但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此拥有N 对端口的交换机的总容量为N*10Mb/s 。这正是交换机的最大优点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fc9ec4c38bf5a2913bcb1287d836767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3033eb8c9b239bbaeecf40d41faa59/" rel="bookmark">
			关于TCP建立和释放连接的三次握手,四次挥手及相关问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么TCP建立与释放连接要进行三次握手和四次挥手? 接下来, 我们将逐步对这个问题进行剖析.
理解清楚TCP socket编程与三次握手和四次挥手的关系. 对于服务器端来说, 我们首先创建一个socket, 接下来调用bind绑定服务端的IP地址和端口. 绑定端口是为了内核收到数据之后知道这个数据应该交给哪个进程, 绑定IP地址主要是由于机器上可能有多个网卡,需要选择监听哪个网卡. bind之后, 就要调用listen, 将服务端之前创建的socket转为被动套接字(也就是监听套接字). 之后调用accept, 阻塞在这里等待客户端的链接请求.
对于客户端来说, 首先同样是创建socket, 接下来调用connect向服务端发起连接请求, 这一步其实就是客户端主动发起三次挥手的过程, 三次握手完成, 客户端和服务端就建立了连接, 可以进行收发数据了.
当客户端与服务端的通信完成之后, 其中一方调用close(这里我们默认认为是客户端), 客户端调用close,向服务端发送一个FIN包, 告诉服务器, 我不再发送数据了, 这个时候服务端读到FIN, 知道对方要关闭连接了, read返回0. 一段时间之后, 如果服务端也不再发送数据了, 同样调用close, 发送FIN包告诉客户端, 我也不再给你发送数据了.
理解TCP是如何实现全双工通信的 我们要知道的是, Linux下一切皆文件, 创建socket返回的是一个文件描述符, 既然是一个文件描述符, 在task_struct结构体中已打开文件的描述符数组中占用一个文件描述符, 这个数组的内容其实就是一个指针, 指向内核当中打开的文件列表, 在这个文件列表中找到对应inode.
网络文件的inode指向的并不是真正的磁盘文件, 它指向的是struct sock结构体, 在这个结构体当中有一个发送队列和一个接收队列, 这是两个独立的队列. 因此TCP可以同时进行数据的接受和发送, 进而实现全双工通信.
理清三次握手的过程 前面已经提到过, connect就是主动发起三次握手, 客户端向服务端发送SYN, 表示自己要与服务端建立连接, 自己进入SYN_SENT状态, 服务端收到连接请求, 回复SYN+ACK, 进入SYN_REVD状态, 客户端收到相应, 回复ACK, 此时就已经完成了客户端到服务端的单向连接, 客户端进入ESTABLISHED状态, 服务端收到客户端的ACK响应, 服务端进入ESTABLISHED状态, 三次握手完成, 连接建立成功.
在三次握手过程当中, connect的调用返回问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3033eb8c9b239bbaeecf40d41faa59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d4045ac942655e0c2c4499fb7354ec/" rel="bookmark">
			cmake之（1）add_library add_executable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：ADD_LIBRARY()语法
add_library(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 [source2 ...]) &lt;name&gt; ：库的名字，直接写名字即可，不要写lib，会自动加上前缀的哈。
[STATIC | SHARED | MODULE] ：类型有三种。
SHARED,动态库 STATIC,静态库 MODULE,在使用 dyld 的系统有效,如果不支持 dyld,则被当作 SHARED 对待。 EXCLUDE_FROM_ALL：这个库不会被默认构建，除非有其他的组件依赖或者手
工构建。
使用
SET(LIBHELLO_SRC hello.c) ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) #共享库 ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC}) #静态库 注意，因为默认规则是不能有相同名字的共享库（so）与静态库(a)，所以当生成静态库的时候，共享库会被删除，因为只能允许一个名字存在，相同名字的会被替代（hello），所以需要通过SET_TARGET_PROPERTIES()来解决这个问题，例子：
解决方法：改libhello_static.a的属性–输出名字
SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME "hello") 这样就可以生成libhello.so与libhello.a了
cmake在构建一个target的时候，会删除之前生成的target，一样是通过设置SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)来达到目的
动态库的版本号：
同样是通过SET_TARGET_PROPERTIES()来设置
SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)
VERSION：动态库版本
SOVERSION：API版本
最后生成的结果是：
libhello.so.1.2
libhello.so.1-&gt;libhello.so.1.2
libhello.so-&gt;libhello.so.1
安装：
INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24d4045ac942655e0c2c4499fb7354ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918f620007288f63c4979fdb7a429cc0/" rel="bookmark">
			机器学习之朴素贝叶斯法及其python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习之朴素贝叶斯法 写在前面背景介绍频率派贝叶斯派 朴素贝叶斯法基本概念参数估计学习与分类算法贝叶斯估计 python实现 写在前面 本文主要是学习记录贴，参考《统计学习方法》和部分博客完成。如有错误，欢迎积极评论指出。
背景介绍 首先，简单讲一下机器学习中的两大学派——频率学派和贝叶斯派。
频率派 频率派认为世界是确定的，即θ（表示需要求的事件）存在唯一的真值，并且这个真值是不变的，我们的目标就是找到这个真值或者说这个真值存在的范围。用个例子来说明，我们在学概统时，常说投硬币，如果我们现在投硬币100次，出现正面朝上的概率是40，那么我们用θ表示硬币正面朝上，则p(θ) = 40 / 100 = 0.4。当数据量趋于无穷大的时候，这种方法能给出准确的估计。但是在缺乏数据的时候，就可能存在很大的误差。比如现在我们投10次硬币，全部都是正面朝上的，这是我们认为正面朝上的概率就是1，这在我们的认知中，是肯定错误的。
贝叶斯派 贝叶斯派认为世界是不确定的，人们应该提前有个先验，然后通过观测数据，对这个先验进行调整，然后找到最优的用于描述这个世界的概率分布。在贝叶斯派中，有两大输入和一大输出。两大输入是先验和似然，输出的是后验。先验，p(θ)指的是在没有观察到数据时对θ的预先判断，可以通过给定的训练样本进行统计得到的。似然，p(x|θ)是假设θ已知后我们观察到的数据应该是什么样，也是可以根据训练样本进行统计得到的。后验，p(θ|x)也就是我们最后需要求的值。
朴素贝叶斯法 朴素贝叶斯法的核心是贝叶斯公式，其工作原理是根据通过某种方法求该事件所有可能性的发生概率，然后哪个高就是哪个。那么，这种方法是什么？
基本概念 首先是贝叶斯公式，如下：
P ( θ ∣ X ) = P ( X ∣ θ ) × P ( θ ) P ( X ) P(\theta|X)=\frac{P(X|\theta) \times P(\theta)}{P(X)} P(θ∣X)=P(X)P(X∣θ)×P(θ)​
公式中， P ( θ ) \ P(\theta) P(θ)表示先验概率， P ( X ∣ θ ) \ P(X|\theta) P(X∣θ)表示似然。
接下来，我们针对实际应用中，定义几个变量。首先Ck 表示不同的类，X表示给定的样本，Y表示Ck的概率。公式变换如下：
对于上面公式变换，可能会存在一个疑问，那就是为什么可以将里面的拆开成连乘？我们在概率论中，这个公式的使用是有前提条件的，也就是相互独立。那么这里面，是条件独立吗？事实上，特征向量之间大概率不是独立的，但是我们默认特征之间是独立的，最主要的原因就是简便计算。如果我们考虑其特征向量之间的联系，会使模型变得非常复杂，容易造成过拟合。所以我们就假设所有的特征向量都是相互独立的。
最后我们得到了如下公式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/918f620007288f63c4979fdb7a429cc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/617463ff86f2dca898dff542e881a26f/" rel="bookmark">
			DTC的解析与状态掩码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返回UDS系列讲解总目录
本文目录
一、DTC的构成
二、DTC状态掩码
一、DTC的构成 根据ISO 15031-6和ISO 14229-1的故障诊断码格式规定，故障码信息由四字节组成，如下表所示
其中DTCHighByte，DTCMiddleByte，DTCLowByte表示服务中的故障诊断码；StatusOfDTC表示故障码状态。DTCHighByte，DTCMiddleByte两字节表示故障内码，对应5位标准故障码，如表下所示。
5位标准故障码，第1位是字母，后面4位是数字，如P0120。第一位字母表示故障所属系统，我们把汽车系统分为四大类。分别是动力，底盘，车身，网络通信，分别用PCBU表示。
第二位数字是0、1、2或3表示故障类型，意义如下：“0”代表SAE(美国汽车工程师协会)定义的通用故障码；“1”代表汽车厂家定义的扩展故障码；“2”或“3”表示预留故障码，
第三位字符表示故障所属的子系统。例如，对于动力系统部分：该位“0”表示燃油和空气计量辅助排放控制整个系统， “1”表示燃油和空气计量系统；“2”表示燃油和空气计量系统(喷油器)；“3”表示点火系统；“4”表示废气控制系统；“5”表示巡航、怠速控制系统；“6”表示与控制单元相关；“7”“8”表示变速箱系统等。
最后两位数字表示具体故障对象和类型。
DTCLowByte描述故障种类和子类型，该部分内容描述需遵循ISO 15031-6。对于不需要该字节信息的DTC，该字节填充为0x00。
StatusOfDTC表示故障码状态。
二、DTC状态掩码 要完全理解DTC状态掩码还需要先理解下面这些概念：
1) Test：在线诊断算法，该算法决定系统的故障状态。一个算法对应于一个唯一DTC，非连续性测试在一个监控周期内仅运行一次，连续测试在每次循环中进行调用，可以是毫秒级的；
2) Failure：系统不能满足功能，则为一个故障。
3) Monitor：可以是一个test也可由多个test组成，用于决定系统故障状态；
4) Monitoring cycle：由设备制造商定义，在这个周期下Test可以运行。当然制造商也可定义其它的周期，只要这个定义满足法规要求；
5) Complete：在当前监控周期内，test决定是否有故障存在的一种指示。(不仅指failed)
bit 0 : testFailed
指示最近执行test的结果，test失败置1，但是它不一定被ECU存储到EEprom中，只有当bit2或bit3被置1时DTC才会被存储。test通过则置0，如果调用了14服务清除DTC的话，也需要重新置0。
bit1：testFailedThisMonitoringCycle
该位表示在当前test中，诊断test是否已经报告了一个testFailed结果。当新的检测循环开始时，这个位需要置0，在调用了14服务后也需要置0。如果该位置1，那么一直保持置1状态直到新的检测循环开始，因此bit1可以理解为当前DTC。如果bit2和bit3通常一起使用。
bit2：pendingDTC
根据ISO 14229的定义，当一个test结束时，若某个DTC满足故障触发条件，则bit2置1。bit2位其实是表示DTC处于testFailed和confirmedDTC之间的一个状态，称为待定DTC。因为DTC并不是一达到触发位就会被报出来的，而是故障出现一段时间后才会被确认，而中间的这个状态就用bit2位来表示，因此bit2位又可被称为待定DTC。当某个DTC刚达到判定条件的时候，bit2被置1，若一段时间后故障条件不满足了，则bit2置0，若一段时间后故障仍然存在，那么bit3就要置1了。
bit3：confirmedDTC
当bit3置1时，说明故障已经发生了一段时间，也就是bit2至少有一次被置1了。需要注意的是，bit3置1的时候，DTC被存储在EEprom中，但并不代表现在故障还存在，所以可以理解为历史故障。在调用14服务清除DTC后需要置0。
bit4：testNotCompletedSinceLastClear
因为并不是所有的DTC测试都是从上电就开始的，所以该位用来表示上次调用14服务清除诊断消息后，是否进行过完整的test。如果进行了完整的test，无论结果如何，都置0，否则置1。调用完14服务后就是置0的。
bit5：testFailedSinceLastClear
该位表示在上次调用14服务清除后DTC后，若test DTC未进行测试或者测试了但结果是pass时置0，如果test运行完成并且返回结果为fails，那么该位置1。在调用14服务清除DTC后需要置0。bit4和bit5通常一起使用。
bit6：testNotCompletedThisMonitoringCycle
该位表示在当前检测循环周期过程中DTC test是否完成，若完成了置0，未完成置1。在调用ClearDiagnosticDTC后需要置1。
bit7：warningIndicatorRequested
该位报告警告指示，比如说仪表盘上的警示灯等。但不是所有的DTC都会有警告指示，如果没有和DTC相关的警告存在，该位应置0；如果该DTC有相关警告指示，bit3置1的时候，bit7也要置1。在调用14服务清除DTC后需要置0。
返回UDS系列讲解总目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b21a4a986787ba6708ac0065ffc9ba4/" rel="bookmark">
			magics24安装教程|magics中文版下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		magics24是由Materialise公司推出的一款功能强大的平面数据处理软件，通过它，能够使用户用最短的前置时间提供高质量样品，并在此过程提供全部文件，非常实用。该软件在完整性、灵活性、强大行和易用性等各个方面都具有不可代替的优势，具有可视化、测量和处理STL文件，安装STL文件、整合外形、表面修整、双重三角检测器等特性，提供了先进的、高度自动化的STL操作，完全可以满足用户的需求，对于使用STL文件工作的人们来说，Magics是理想的、完美的软件解决方案。与此同时，magics24在上一版本的基础上增加了许多全新和改进后的功能，让用户可以通过多种方式体验到更强大的生产力，例如新增的支撑转移功能，可以自动将支撑结构转移到相似的部件，在更改设计时无需重新创建支撑，从而加快了多次设计迭代的数据准备，避免浪费时间做重复的工作，还增加了边界框叠加和3D叠加，轻松帮助用户在短时间内获得理想的结果，甚至可以在一毫秒内叠加数千个零件，非常适合打印大量小部件，以及提供了增强的可用性功能，包括改进了View Cube的导航，致力于为用户带来更简化的工作流程。
ps：小编带来了magics24软件，并且是中文版本，附带的破解补丁可完美激活软件，从而无限制使用所有功能，下文奉上了详细的安装破解图文教程，有需要的小伙伴们快来下载使用吧。
magics24破解版安装教程：
1、首先在本站下载解压，得到magics24中文原程序和Crack破解文件夹；
2、双击运行"Magics 24.0.exe"，选择Chinese简体中文语言；
3、默认软件安装路径，选择环境为China，并勾选同意许可协议选项，将改善计划的选项勾选掉，点击安装；
4、软件正在安装中，请用户耐心等待；
5、安装完成之后，先不要启动程序，直接点击右上角的关闭按钮即可；
6、进入以下路径，以管理员身份运行LicSrvConfig.exe；
默认路径【C:\Program Files (x86)\Common Files\Materialise\LicenseFiles6】
7、点击Stop停止Local License Server；
8、再将AutoPassword server URL值更改为https://localhost/MatPasswordsWS/MatPasswordsWS.asmx，点击close关闭；
9、将Crack破解文件中ServerFix文件夹下的程序复制到如下路径：
C:\Program Files (x86)\Common Files\Materialise\LicenseFiles6
C:\Program Files\Materialise\Magics 24.0
10、再次运行LicSrvConfig.exe点击Start，开启Local License Server；
11、将安装目录下的MatSDK.Common.Threads.dll重命名为MatSDK.Common.Thread.dl1；
默认路径【C:\Program Files\Materialise\Magics 24.0】
12、再将破解文件夹中MagicsFix文件的所有程序复制到软件目录下；
默认路径【C:\Program Files\Materialise\Magics 24.0】
13、这时，运行软件，选择“显示许可证和系统信息”，然后点击下一个；
14、以记事本方式打开破解文件夹中的magics24.matkey，用您的系统ID替换* .matkey中的“ AAAAAAAA-AAAA-AAAA-AAAAAAAAAAAAAAA”，在magics24.matkey中CTRL+H查找并进行替换，替换完成保存；
15、完成后，点击浏览，载入修改后的magics24.matkey许可并点击注册；
16、ok，软件已完美破解成功啦，以上就是magics24中文破解版安装教程啦。
magics24新增功能
1、便捷的支撑转移
这个新功能可以自动将支撑结构转移到相似的部件，在更改设计时无需重新创建支撑，从而加快了多次设计迭代的数据准备，避免浪费时间做重复的工作。
2、改进的叠加功能
软件的另外两项重大改进是增加了边界框叠加和增强了3D叠加。新的边界框叠加工具可以帮助用户在短时间内获得理想的结果，甚至可以在一毫秒内叠加数千个零件。它非常适合打印大量小部件。
3、性能提升
在Magics 24中改进这项操作为整个软件都带来了令人印象深刻的进步。包括包裹修复和镂空在内的功能都通过升级获得了最高3倍的速度提升。
4、全新的倒角工具
用户可以在数据准备阶段中使用该功能以避免产生尖角，不再需要回到CAD重新设计。测试人员无需来回切换，可以自始至终在Magics里处理文件，从而改善了工作流程。如果您遇到热量堆积和尖角翘曲的问题，倒角工具是解决这些问题的简便方法。
5、将信息保存到STEP文件
这个新功能会自动把在Magics数据和打印准备阶段中所做的更改，尤其是部件的方向和位置，保存到STEP文件中。如果您是应用金属3D打印的专业人士，STEP文件中保存的信息对于CNC后处理特别有用。用户无需中断工作流程，就能使STEP文件包含重新定位的部件的信息。
软件特色
1、合理筹集时间
本软件功能强大，操作界面友好，能够节约数据准备，打印和后处理等工序的操作时间，从而大大扩展项目交付时间。
2、提高成功率
智能化数据准备，能够减少资源消耗，获得更高的打印成功率，降低您的数据准备成本。
3、采用行业标准
（该软件采用了我公司几十年3D打印软件专业技术。）
4、优秀技术独立软件
无论使用任何打印机组合，都通过使用材料魔力，您和您的团队仅需选用一种软件便能完成3D打印部件准备。
5、优势整个平台
Materialise Magics是材料Magics 3D打印套件中的核心组件，完全集成到Magics 3D打印套件内部，Magics 3D打印套件是一种功能强大的软件组合，用于对增材制造流程的各个步骤进行管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b21a4a986787ba6708ac0065ffc9ba4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608e9de34a05f7c483dce73a57260b09/" rel="bookmark">
			基于Gitlab Issues为导向的分支管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Gitlab的开发分支流程规范对于日常开发十分重要，本文主要介绍下基于Issues为导向的中小型数据项目开发规范。
以Issues为导向的GIt开发规范 对于数据类项目，代码大多是Sql、Shell、Python脚本。各个模块、代码源文件关系不大，不会产生功能类错误，影响系统稳定性。因此可以采用以issue为导向的分支管理方法，来管控开发流程。大致流程如下：
1、开发人员根据需求提交Issue
开发人员A在Gitlab中首先提交一个Issue。填好Issue中的标题、描述：
同时可以填写Assignee指定这个Issue的解决人，Labels可以备注这个Issue是“confirmed”，“bug”，Due date至这个Issue的最终解决时间，点击提交Issue。
点击项目中的Issues列表，可以看到目前项目的主要问题：
2、代码审核人员查看Issue
开发人员A与代码审核人员A需要提前确认要改的Issue，比如“一个BUG标题”：
代码审核人员A如果认为bug确实需要修改，则在这个Issue中点击按钮“Create merge request and branch”，意思是 从master主分支拉取一个新分支“9-one-bug-fo-fix”（9代表Issue的id为9，one-bug-to-fix为命名的分支名称），专门来解决这个Issue反馈的BUG。
3、开发人员在分支“9-one-bug-fo-fix”上修改bug。
开发人员A打开IDE，下载代码，切换到“9-one-bug-fo-fix”，新增了“fixbug.py”文件，修改了BUG：
开发人员A将修改结果commit、push到分支“9-one-bug-fo-fix”。
此时代码审核人员A在web界面上可以实时看到开发人员A提交的修改：
其中"WIP"表示"Work In Process"，表示开发人员A正在修改代码，是不应该merge的。在下边栏Commits中，代码审核人员A可以看到开发人员A刚刚push的”fixbug.py“提交：
代码审核人员A可以点击页面中”#9“查看之前的Issue，确保开发人员A修改的代码在Issue修改范围内。
4、开发人员确认修改完成
开发人员A经过单元测试认为代码修改完成了，在web界面上点击”Resolve WIP status“，表示“9-one-bug-fo-fix”这个分支可以merge到master了：
此时Merge的按钮可以被点击。
5、代码审核人员将分支分支“9-one-bug-fo-fix”合并到master上
代码审核人员A查看代码没有问题后，确认可以合并到主分支上，点击Merge按钮。
此时页面由绿变为蓝，代表已经合并到主分支，同时会自动将Issue 9关闭：
6、查看git的分支图，可以发现”9-one-bug-fo-fix“已经提交到master上。
总结 总结下来，开发人员只需要先将BUG在Git上通过Issue描述清楚，然后在新分支修改上传代码即可。建立新分支，Merge等过程由代码审核人员完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ea81105f09c85f75cfdbfe2f50b424/" rel="bookmark">
			el-date-picker 最多只能选中一个月  选中第一个日期后  第二个日期给出可选范围限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-date-picker 选中第一个日期后 第二个日期给出可选范围 效果: 选中2020年5月13日之后 前面4月13日到5月13日可选 后面5月13日到6月13日可选
&lt;el-date-picker v-model="value2" type="datetimerange" size="small" :picker-options="pickerOptions" range-separator="至" start-placeholder="开始日期" end-placeholder="结束日期" align="right"&gt; &lt;/el-date-picker&gt; choiceDate0: '', pickerOptions: { // 设置不能选择的日期 onPick: ({ maxDate, minDate }) =&gt; { this.choiceDate0 = minDate.getTime(); if (maxDate) { this.choiceDate0 = ''; } }, disabledDate: (time) =&gt; { let choiceDateTime = new Date(this.choiceDate0).getTime(); const minTime = new Date(choiceDateTime).setMonth(new Date(choiceDateTime).getMonth() - 1); const maxTime = new Date(choiceDateTime).setMonth(new Date(choiceDateTime).getMonth() + 1); const min = minTime; const newDate = new Date(new Date().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ea81105f09c85f75cfdbfe2f50b424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/289d31221dac17e9e36d28f54f11af77/" rel="bookmark">
			STM32 控制蜂鸣器播放音乐的原理和实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 控制蜂鸣器播放音乐的原理和实例 本文通过将乐谱里的每个音符的声音频率和声音时长保存在两个数组里面。
1.使用通用定时器TIM4实现无中断的微秒级延时函数，控制每个音符的发声时长。
2.使用系统滴答时钟Systick实现带有中断的输出控制，在中断函数里实现蜂鸣器端口输出电平反转，并且根据当前播放音符的频率重新设置中断产生时间。
一、播放的原理 播放的乐谱：
1.1 C音调乐谱对应的音频（Hz）： 根据乐谱的基础知识可知，低音的下面加点，高音的上面加点，普通的不加点。
//用枚举定义，记录所有的音频。 enum Low_frequency{l_dao=262,l_re=286,l_mi=311,l_fa=349,l_sao=392,l_la=440,l_xi=494}; enum Normal_frequency{dao=523,re=587,mi=659,fa=698,sao=784,la=880,xi=987}; enum High_frequency{h_dao=1046,h_re=1174,h_mi=1318,h_fa=1396,h_sao=1567,h_la=1760,h_xi=1975}; 1.2 乐谱对应的节拍-音长： 本次乐谱的节拍为每分钟72拍，可以算出每个节拍的时长：
然后看乐谱的第一小节：
最后将整个乐谱的音频和音长记录在两个数组里。
。
二、播放音乐的具体实现 2.1 无中断的毫秒延时函数 //TIM_4初始化函数 void TIM_4(void) { TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE); TIM_TimeBaseStructure.TIM_Period = 1;	TIM_TimeBaseStructure.TIM_Prescaler=(72-1); TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Down; TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1; TIM_TimeBaseInit(TIM4, &amp;TIM_TimeBaseStructure); } //延时n个us void delay_us(unsigned int nus) { TIM4-&gt;CNT=nus-1; TIM4-&gt;CR1|=TIM_CR1_CEN; while((TIM4-&gt;SR &amp; TIM_FLAG_Update) != SET) ; TIM4-&gt;CR1&amp;=(~TIM_CR1_CEN); TIM4-&gt;SR &amp;=~(TIM_FLAG_Update); } //延时n个毫秒 void delay_ms(unsigned int nms) { int count; for(count=0;count&lt;nms;count++) delay_us(1000); } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/289d31221dac17e9e36d28f54f11af77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d4b128ccc93ea3ccc0a38f177bc86d/" rel="bookmark">
			哈希表/哈希冲突及解决方法（较全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希表的概念请参阅他人文章，关于哈希冲突的解决这篇文章基本都整理到了，还有几个常见的面试题。
解决hash冲突的几种方法 前导（题外话）：一.开放定址法（闭散列）1.线性探测再散列2.二次探测再散列3.伪随机探测再散列 二.再哈希法三.链地址法（开散列）四.建立公共溢出区五.优缺点（重要）1.开放散列（open hashing）/ 拉链法（针对桶链结构）2.封闭散列（closed hashing）/ 开放定址法 前导（题外话）： 哈希表的几个概念：
映像：由哈希函数得到的哈希表是一个映像。
冲突：如果两个关键字的哈希函数值相等，这种现象称为冲突。
关于哈希函数的选取，可以参见 这篇文章；
另外常见的字符串哈希函数及c++代码实现可以看这里。
主要有：常用的字符串Hash函数还有ELFHash，APHash等等，都是十分简单有效的方法。这些函数使用位运算使得每一个字符都对最后的函数值产生影响。另外还有以MD5和SHA1为代表的杂凑函数，这些函数几乎不可能找到碰撞。
常用字符串哈希函数有BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash等等。
BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也是较为优秀的算法。DJBHash,JSHash,RSHash与SDBMHash各有千秋。PJWHash与ELFHash效果最差，但得分相似，其算法本质是相似的。
好了，进入正题：
通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。下面以创建哈希表为例，说明解决冲突的方法。常用的解决冲突方法有以下四种：
一.开放定址法（闭散列） 开放定址法
这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。
查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。
这种方法有一个通用的再散列函数形式：
Hi=（H（key）+di）% m i=1，2，…，n
其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。
这里只给出大致的思想，更详细的具体步骤和代码可以参见这里：
哈希表的原理及解决冲突的方法
另外，散列表的查找性能，一般有两种方法，具体可以看上面这篇文章介绍。
成功平均查找长度(ASLs)
ASLs： 查找表中关键词的平均查找比较次数（其冲突次数加1）
不成功平均查找长度 (ASLu)
ASLu：不在散列表中的关键词的平均查找次数（不成功）
一般方法：将不在散列表中的关键词分若干类。
解决哈希冲突主要有以下三种：
1.线性探测再散列 线性探测再散列
dii=1，2，3，…，m-1（m是tablesize）
这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。
2.二次探测再散列 二次探测再散列
di=12，-12，22，-22，…，k2，-k2 （2是平方） ( k&lt;=m/2 )
这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。
（坏处是只能探测到哈希表长度的一半，会浪费一定空间，但若是真的探测到一半的位置了，说明哈希函数的设置有问题，应重选哈希函数）
3.伪随机探测再散列 伪随机探测再散列
di=伪随机数序列。
具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。
例如，已知哈希表长度m=11，哈希函数为：H（key）= key % 11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。
如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d4b128ccc93ea3ccc0a38f177bc86d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7a72d1550680516346bf60e5da7322/" rel="bookmark">
			[acwing面向模型编程]最长上升子序列模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目1：1012. 友好城市 题意： Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。
北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。
每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。
编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。
输入格式
第1行，一个整数N，表示城市数。
第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。
输出格式
仅一行，输出一个整数，表示政府所能批准的最多申请数。
数据范围
1≤N≤5000,
0≤xi≤10000
输入样例：
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2
输出样例：
4
分析： 这个问题难在模型的转化，考虑两个直线l1 l2，只有当l2的两个坐标都大于或者小于l1的时候，两者才不会相交。所以这个题需要先对某一岸的数值排序，然后求对岸的LIS即可
代码： #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; //typedef __int128 lll; #define print(i) cout &lt;&lt; "debug: " &lt;&lt; i &lt;&lt; endl #define close() ios::sync_with_stdio(0), cin.tie(0), cout.tie(0) #define mem(a, b) memset(a, b, sizeof(a)) const ll mod = 1e9 + 7; const int maxn = 2e6; const int inf = 0x3f3f3f3f; struct node { int a, b; node(int a = 0, int b = 0) : a(a), b(b){} }a[maxn]; int dp[maxn]; int main() { int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc7a72d1550680516346bf60e5da7322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9b3b1b647c8e46c4a1b7c649d8e767/" rel="bookmark">
			centos7的日志管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日志管理 简介 任务一：
rsyslog 系统日志管理
关心问题：哪类程序—》产生的什么日志----》放到什么地方
任务二：
logrotate日志轮转
将大量的日志，分割管理，删除旧日志。
任务一 一 处理日志的进程 rsyslogd： 系统专职日志程序。 处理绝大部分日志记录， 系统操作有关的信息，如登录信息，程序启动关闭信息，错误信息 观察 rsyslogd程序 root@localhost ~]# ps aux |grep rsyslogd
二 常见的日志文件(系统、进程、应用程序) tail -10 /var/log/messages
//系统主日志文件
tail -f /var/log/messages
//动态查看日志文件的尾部
当用户信息变更日志也会相应的变更
# tailf /var/log/secure //认证、安全 # tail /var/log/yum.log //yum # tail /var/log/maillog //跟邮件postfix相关 # tail /var/log/cron //crond、at进程产生的日志 # tail /var/log/dmesg //和系统启动相关 。。。。。。。。。。。 网站日志管理
1.yum install -y httpd安装httpd环境
2.systemctl start httpd开启httpd环境
3.systemctl stop firewalld关闭防火墙
桥接调整网络
systemctl restart network
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d9b3b1b647c8e46c4a1b7c649d8e767/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/235/">«</a>
	<span class="pagination__item pagination__item--current">236/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/237/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>