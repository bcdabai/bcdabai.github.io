<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a09b1d04c56aa24f3296902f072ff8e8/" rel="bookmark">
			VIP &#43; Nginx &#43; Keepalived
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VIP（Virtual IP Address），虚拟IP地址，主要是用来进行不同主机之间的切换，主要用在服务器的主从切换技术。主从服务器都配置同一个VIP地址，保障系统不间断切换。
Keepalived是高可用解决方案，借助VRRP协议实现高可用服务之间的故障切换转移。在 Keepalived服务正常工作时，主 Master节点会不断地向备节点发送（多播的方式）心跳消息，用以告诉备Backup节点自己还活着，当主 Master节点发生故障时，就无法发送心跳消息，备节点也就因此无法继续检测到来自主 Master节点的心跳了，于是调用自身的接管程序，接管主Master节点的 IP资源及服务。
本示例中将使用keepalived保障nginx主从代理服务器高可用。
一、环境说明： 操作系统：centos7
主机（master）：192.168.2.145
备机（backup）：192.168.2.146
VIP：192.168.2.166
两台机器均已安装nginx服务，浏览效果如下：
二、配置VIP 2.1、主机配置VIP 2.1.1 复制当前网卡的网址配置文件，名称后增加“:1”；然后编辑该文件，修改name、device和ipaddr三个数据项，如下图所示。
cd /etc/sysconfig/network-scripts/
cp ifcfg-ens33 ifcfg-ens33:1
vi ifcfg-ens33:1
2.1.2 查看效果命令
ip addr
2.1.3 浏览器访问验证VIP效果，如下图：
2.2、备机配置VIP 参见主机，略
三、安装Keepalived 3.1、主机安装配置 3.1.1 安装及编辑配置文件
yum install -y keepalived
vi keepalived.conf
3.1.2 创建并编辑nginx检测文件
vi check_nginx.sh
3.1.3 启动keepalived服务
systemctl start keepalived
3.2备机安装配置 3.2.1 安装及配置过程参见主机
3.2.2 主备配置差异说明
以下属性必须根据实际情况编写，尤其state必须有master和backup之分。
state #指定keepalived的角色，MASTER表示此主机是主服务器，BACKUP表示此主机是备服务器 interface #指定检测网络的网卡接口 priority #节点优先级，数字越大表示节点的优先级越高，在同一个VRRP实例下，MASTER的优先级必须比BACKUP高 以下属性必须一致
vrrp_instance VI_1 #VRRP实例开始的标识 VI_1为实例名称 virtual_router_id #虚拟路由标识，数字形式，同一个VRRP实例使用唯一的标识 auth_type PASS #预共享密钥认证，同一个虚拟路由器的keepalived节点必须一样 auth_pass #设置密钥 virtual_ipaddress #设置虚拟IP地址 nopreempt # 设置为非抢占模式，同一实例下主备设置必须一样 四、效果验证 使用vip访问，如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a09b1d04c56aa24f3296902f072ff8e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b036897876f012d745dc83ccc361c04/" rel="bookmark">
			VMware安装CentOS7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装CentOS
二、网络配置
三、虚拟机克隆
一、安装CentOS 1、进入VMware主页面，选择“创建新的虚拟机”
2、进入新建虚拟机向导，配置类型选择“典型”
3、“浏览”选择下载好的iso文件，CentOS7驱动下载地址：CentOS Mirrors List
4、为虚拟机命名，并选择虚拟机存放路径
5、设置磁盘大小，选择拆分成多个文件
6、进入硬件配置页面
7、根据自己需要配置硬件大小
8、点击完成，进入到正式安装页面
9、选择“Install CentOS 7”，开始安装
10、语言选择“简体中文”
11、根据需要选择其他安装信息
12、带感叹号的需要点进去手动配置
13、磁盘根据需要自定义分区，这里选择自动配置
14、点击开始安装，启动安装，设置root账号密码
15、设置root密码，如果太简单，连续点两下“完成” 16、安装完成，重启
17、重启后，选择操作系统并进入18、输入账号密码，进入系统
二、网络配置 1、选择安装的虚拟机，右键选择“设置”
2、网络适配器，选择“NAT模式”
3、在VMware workstation里，点击菜单栏上的【编辑】--&gt;【虚拟网络编辑器】，打开下方的虚拟网络编辑器。选择VMnet8（NAT模式），取消勾选【使用本地DHCP服务...】（若勾选，会设置动态IP）。
4、点击NAT设置，设置网关IP
5、进入到系统，设置静态IP，修改如下内容
#vi /etc/sysconfig/network-scripts/ifcfg-ens33
BOOTPROTO=static IPADDR=192.168.5.3 NETMASK=255.255.255.0 GATEWAY=192.168.5.2 ONBOOT=yes 6、设置DNS
#vi /etc/resolv.conf 7、设置主机名
#vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=node1 8、重启网络以生效，或重启虚拟机
service network restart 9、设置VMnet8在Windows上的IP属性，如下图。（打开控制面板--&gt;网络和Internet，在右侧点击【更改适配器设置】，进入“网络连接”页面）
10、连接测试
三、虚拟机克隆 1、虚拟机主页选择要克隆的虚拟机，右键选择克隆
2、进入到克隆向导页面
3、下一步
4、这里需要完全独立的虚拟机，所以选择“创建完整克隆”
5、为新的虚拟机命名 ，点击完成
6、启动新创建的虚拟机
7、按原虚拟机的root账号密码登录，此时ip和主机名还是和之前虚拟机一样，所以需要修改
8、修改IP为192.168.5.5，其他不变
9、修改主机名为node2，并reboot重启虚拟机
10、此时ip和主机名已经变过来了，按需是否修改root密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2434000cbf51c3ce34360cfab82f6eae/" rel="bookmark">
			【Axure教程】在PPT里演示原型模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品经理在介绍、售前、培训等场合经常会运用到PPT和原型展示，大部分产品经理会在两者中来回切换，在这个过程中就会浪费很多时间了。所以今天教大家如何在PPT里直接演示我们的做好的原型。
【模板下载】
这个模板可以在下方小程序里免费下载哦
点击或者扫码打开下方小程序，搜索能在PPT中演示Axure原型的模板，获取下载地址
01 为什么要在PPT里演示原型 1）提供直观的视觉体验
PPT页面中演示原型可以提供观众直观的视觉体验，让他们更好地理解产品功能和使用流程。与简单的文字描述相比，原型演示可以更直观地展示产品的设计和交互细节。
2）节省时间和成本
通过在PPT页面中演示原型，可以避免在实际开发之前制作成品样机，从而节省时间和成本。同时，通过演示原型，可以及时发现和修复设计上的问题，减少后期的修改成本。
3）方便与沟通和反馈
PPT页面中演示原型可以方便与他人沟通和收集反馈，帮助团队更好地理解产品需求和用户需求。同时，可以通过演示原型快速响应用户反馈和意见，及时修改设计方案。
02 怎么在PPT里演示原型 我们会以可视化大屏的原型为案例，教大家怎么在PPT中插入已经制作好的原型模板，并且也能演示ppt制作的交互。
具体效果如上图所示，将Axure制作好的原型模板，插入到ppt后，可以在ppt页面里看到该原型，而且制作好的交互，也可以触发，例如移入图表显示对应的数据。当然，全屏演示时也会有这样的效果，不过不同的机型会有所不同，有些电脑需要全屏后需要点一下页面才会进入原型页面，翻页就通过鼠标上下滚动来实现。
1. 制作原型时需要注意的事项 制作原型时，我们要考虑ppt页面的尺寸，一般是16:9或者4:3，这一个一般跟你们的显示器，可以在ppt设计选项卡，幻灯片大小里面查看或者设置。
作者的屏幕是16:9，所以我们在设置原型的时候，要按照这个比例来设置，这样才可以铺满屏幕。我们点击原型页面尺寸那里就可以设置，一般16:9的话会设置1920:1080。
那如果是以前制作的原型没有按照这个尺寸也太大关系，只是不能铺满整个页面而已，不会有其他影响的。
2. 在ppt中插入web viewer 要把原型插入到ppt，我们需要插入网页查看器webviewer的加载项，我们可以用他来浏览网页。
我们点击切换选项卡，然后点击获取加载项，在里面找到webviewer即可。
3. 将制作好的原型模板生成线上链接 我们点击Axure里的共享按钮，就可以发布到axshare，生成一个在线链接。
生成在线链接后，我们还要对链接进行处理，因为分享出来的链接是自带工具栏的，如果直接用这个地址，在ppt上也会出现工具栏，导致不能铺满屏幕。
已案例中生成的演示地址为例，共享后生成https://u7xici.axshare.com这个地址，我们对这个地址进行处理，如果对axure演示地址有研究的就会知道，c=1这个值其实就是控制不显示工具栏的，所以原地址我们只需要在后面增加/#c=1，即https://u7xici.axshare.com/#&amp;c=1即可。
当然你也可以在网页里打开https://u7xici.axshare.com这个地址，然后鼠标收起工具栏，在复制收起后的地址也可以。
4. 将地址复制到ppt web viewer里 我们把上面修改后的原型线上预览的地址复制到web viewer中。
这里需要住的的是，因为前面有https://，所以我们复制过去之后，要将前面重复的部分删除。
最后点击右下角preview按钮，就可以在这个页面里看到我们做好的原型了，或者点击放映按钮，也是可以看到的。
看到原型后，我们还要对web viewer的尺寸调整一下，因为导入后还是会有底部那栏工具，我们往下拉一点，全屏预览的时候，就看不到他了。
那以上就是本期教程的全部内容，感兴趣的同学们可以动手试试哦，感谢您的阅读，我们下期见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d6bf092c1a47d1b6fcc18b48318fff0/" rel="bookmark">
			新年展望-2023年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新年箴言 首要任务，保重身体，保持每天都是专注，心情愉悦，祝大家新年安康。
如果你一直做你能做的事情，那么，你就没法超越现在的自己。–来自《功夫熊猫》自主者，天助之。不懂失败的人，就没法承受成功的喜悦。放下包袱，不要让包袱影响到现在和未来。人总是为了某些东西而战，为的东西越重要，战意就越强。你找到这种东西了没？ 新年目标 情绪方面 控制情绪，锻炼过硬的心理素质。内心如何的波涛汹涌，脸上也要风平浪静，不喜不悲。锻炼表达能力。力求表达清晰，不卑不亢。脸皮要厚，胆子要大。 技能方面 继续深入研究Java技术栈。重新复习前端，就研究Vue。锻炼英语，能和外国人交流，完成听说读写，毫无障碍。 生活方面 上半年必须完成个人首本小说。七弦琴必须达到入门级别，熟练左右指法。厨艺继续精进，掌握常吃的川菜。 经济方面 存款上半年目标10W，全年20W+。 记录 1. 加密解密 https://blog.csdn.net/zhouzhiwengang/article/details/90037556，common包 https://blog.csdn.net/loolly/article/details/77539928，hutools包 2. URL有空格中文编码处理：https://blog.csdn.net/qq_35341203/article/details/109334607 3. Kafka学习：https://blog.csdn.net/u010886217/category_8056178.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d3e2d2508423b420e986ca7ea88949/" rel="bookmark">
			流程图拖拽视觉编程--概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般的机器视觉平台采用纯代码的编程方式，如opencv、halcon，使用门槛高、难度大、定制性强、开发周期长，因此迫切需要一个低代码开发的视觉应用平台。AOI缺陷检测的对象往往缺陷种类多，将常用的图像处理算子封装成图形节点,如抓直线、抓圆、模板匹配等，在软件上自由组合完成对缺陷的判断将大大提高效率。目前我接触到的通过流程图拖拽的方式搭建视觉应用的软件有Vision Master、Smart3、VisionTool等，下面将简单介绍下：
VisionMaster介绍 Vision Master封装了千余种海康自主开发的图像处理算子，形成了强大的视觉分析工具库，无需编程，通过简单灵活的配置，便可快速构建机器视觉应用系统。该软件平台功能丰富、 性能稳定可靠，用户操作界面友好，能够满足视觉定位、测量、检测和识别等视觉应用需求。
Smart3介绍 Smart3 智能视觉系统是一款简单易用、功能齐全、性能稳定的智能型视觉软件系统。Smart3 智能视觉软件由 OPT 公司自主研发，集成图像工具箱、定位工具箱、测量工具箱、检测工具箱、识别工具箱、通讯设置工具箱、其他工具箱和 3D 工具箱等一系列图像处理功能。支持市面上可见的绝大多数相机品牌，支持 GeniCam 协议。并支持串口、TCP 等多种通讯模式及主流的通讯协议，能够方便的与各品牌运动控制设备建立数据交互。Smart3 智能视觉系统采用图形编辑代替了代码编写，从而实现检测项目的快速开发。流程与事件触发机制的组合，能够便捷的实现大部分视觉检测项目。基于异构计算加速技术，使图像分析速度全面提升。该系统还支持在线调试功能，使应用项目能够在不停产停机的情况下，快速调整视觉参数设定以获取最优检测效果。智能视觉系统还支持用户基于自定义需求的二次开发。并基于COM 和.NET 接口技术，增加了对 VB，C#，C++多种编程语言的支持。可自由配置的模块化 UI界面，能满足用户的特殊显示需求。
VisionTool介绍 visiontool是一款以拖拽编程为主的视觉软件，大体上可划分为Task、Block及Tool三个层级，里面封装好多种视觉检测算法，机械手及相机（等硬件）控制指令，相机加机械手组合使用算法。用户需要在task层级，通过流程图的方式搭配block的运行逻辑，在block层级拖出所需的tool并做变量赋值，即可完成各种自动化任务。
借鉴以上软件自己实现了一个基于halcon的流程图拖拽编程软件
后期博客将分模块为大家介绍具体实现方式，模块划分如下：
1、流程编辑器：控件的拖拽与节点生成、流程数据保存与解析
2、工具箱：存放节点控件
3、属性编辑器：编辑每个节点的参数
4、视觉模块：halcon的封装
5、流程执行器：生成执行链表，依次执行算子。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c573a520faefa1e904afa18fc7dffbb/" rel="bookmark">
			java车辆租赁管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、项目需求二、项目结构项目源代码：1、database层1.Database类（车辆）2.UserDatabase类 2、model层1.Car类2.User类 3、 operation层1. IOpreation接口2.AddCarInfoOperation类3.DeleteCarInfoOperation类4.UpdateCarInfoOperation类5.GetCarsInfoOperation类6.BorrowOperation类7.ReturnOperation类8.ExitOperation类 4、service层1.MyCarManageService类2.UserDao类 5、test层1.Main类 三、运行截图 一、项目需求 完成一个车辆租赁管理系统，实现：
1、通过用户名、登录密码、验证码实现用户注册，并登录；
2、用户能够查看所有车辆，展示车辆的生产类型 、车名、月租金、是否借出的情况；
3、用户能够添加车辆信息（两种情况）：
3.1 新添加的书籍类型在数据集合bookMap中已存在，那么就直接将新书添加到对应类型的书籍List集合中
3.2 新添加的书籍类型在数据集合bookMap中不存在，那么需要新建键值对完成bookMap中的元素添加
4、用户能够修改车辆信息，如车辆生产类型、名称、月租金；
5、用户能够删除车辆信息，删除车辆后需要判断该车所在List集合长度是否为0，为0则该键值对一起移除；
6、用户能够租赁车辆与归还车辆；
7、退出系统
二、项目结构 项目分五个包：
1、database包：模拟数据层；
2、model包：实体对象层；
3、operation包：操作实现层；
4、service包：业务逻辑层；
5、test包：项目测试层
一个操作接口（ IOpreation接口）：
对于每一个操作都有相近的一部分，刚好可以用接口，利用接口类型的数组来进行相关的操作。
七个操作实现类：
用于实现租赁车辆的增删改查以及租赁归还等操作。
用一个protected IOpreation[] iOpreations;即接口类型的数组，主要是在它的子类中，在构造 函数中需要根据它们各自的功能实例化各个操作。
IOpreation[] iOpreations数组实例化：
public void doOperation(int choice, HashMap&lt;String, ArrayList&lt;Car&gt;&gt; CarMap) { this.iOpreations[choice].work(CarMap); } protected IOpreation[] iOpreations; /** * IOpreation[] iOpreations，在这里就实例化了 */ public MyCarManageService() { this.iOpreations = new IOpreation[]{ new GetCarsInfoOperation(), new AddCarInfoOperation(), new UpdateCarInfoOperation(), new DeleteCarInfoOperation(), new BorrowOperation(), new ReturnOperation(), new ExitOperation() }; } 将type和用例car分别作为key和value关联，使用hashMap存储；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c573a520faefa1e904afa18fc7dffbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/029e56ee6bfeff63e1a1165a961ca55f/" rel="bookmark">
			Java 死锁的原理、检测和解决死锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是死锁 两个或者多个线程互相持有对方所需要的资源（锁），都在等待对方执行完毕才能继续往下执行的时候,就称为发生了死锁，结果就是两个进程都陷入了无限的等待中。
一般是有多个锁对象的情况下并且获得锁顺序不一致造成的。
死锁产生的条件 死锁产生有四个必要条件，只要系统发生死锁则以上四个条件都必须成立。
互斥条件： 资源是独占的且排他使用，线程互斥使用资源，即任意时刻一个资源只能给一个线程使用，其他线程若申请一个资源，而该资源被另一线程占有时，则申请者等待直到资源被占有者释放。不可剥夺条件： 线程所获得的资源在未使用完毕之前，不被其他线程强行剥夺，而只能由获得该资源的线程资源释放。请求和保持条件： 线程每次申请它所需要的资源，在申请新的资源的同时，继续占用已分配到的资源。循环等待条件： 在发生死锁时必然存在一个线程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个线程等待环路，环路中每一个线程所占有的资源同时被另一个申请，也就是前一个线程占有后一个线程所申请的资源。 检测死锁 构造死锁 public class DeadLockTest { public static Object lockObj1 = new Object(); public static Object lockObj2 = new Object(); public static void main(String[] args) { Runnable r1 = DeadLockTest::lock1; Thread t1 = new Thread(r1); t1.setName("deadLockThread1"); Runnable r2 = DeadLockTest::lock2; Thread t2 = new Thread(r2); t2.setName("deadLockThread2"); t1.start(); t2.start(); } public static void lock1() { try { synchronized (lockObj1) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/029e56ee6bfeff63e1a1165a961ca55f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b5a4f084c853a559f131cd81cc53cf/" rel="bookmark">
			vue中后台管理系统的权限控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图 下载 这里是用到的一些插件
npm install axios --save npm install element-ui --save npm install stylus --save npm install stylus-loader --save 引入 在 mian.js 中引入，并写入路由权限拦截
import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' // 引入 element-ui import ElementUI from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(ElementUI) // 权限控制（这里没有做登陆拦截） router.beforeEach((to, from, next) =&gt; { // 根据路由元属性requiresAuth判断改路由是否需要控权限 if (to.matched.some(item =&gt; item.meta.requiresAuth)) { // 1、（首次访问页面）登录页面跳转过来、直接访问地址、刷新页面时，from.path为 "/", // 先请求权限接口，判断权限后再判断是否拦截 // 2、已访问本系统但权限为空 if (from.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99b5a4f084c853a559f131cd81cc53cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73eda9863f7c9e21ef2a91271a3c556e/" rel="bookmark">
			用C语言输出*组成基本的三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.输出正直角三角形2.输出倒直角三角形3.输出正等腰三角形4.输出倒等腰三角形5.输出菱形6.输出旋转90°的等腰三角形7.补充1.输出矩形阵列2.将矩阵倾斜 本篇主要为练习利用for循环语句输出*图形 1.输出正直角三角形 /* 4 * ** *** **** */ #include&lt;stdio.h&gt; int main() { int i,j,n; scanf("%d",&amp;n); //输入你想要的行数 for(i=1;i&lt;=n;i++) //系统输出的行数 { for(j=1;j&lt;=i;j++) //当前行的*数 printf("*"); printf("\n"); //每次输出一行结束后换行 } return 0; } 注意：在利用for循环嵌套时，每一个for循环都要运行完成才能跳出内层，进入外层循环。
2.输出倒直角三角形 /* 4 **** *** ** * */ #include&lt;stdio.h&gt; int main() { int i,j,n; scanf("%d",&amp;n); //输入你想要的行数 for(i=1;i&lt;=n;i++) //系统输出的行数 { for(j=1;j&lt;=n-i+1;j++) //当前行的*数 printf("*"); printf("\n"); //每次输出一行结束后换行 } return 0; } 3.输出正等腰三角形 此时需要加入空格来实现
/* 4 * *** ***** ******* */ #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73eda9863f7c9e21ef2a91271a3c556e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/722210bb0d5f9de60dc5268aba12e75b/" rel="bookmark">
			com.android.packageinstaller冻结-应用冻结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为手机使用adb冻结卸载删除内置应用方法 1、手机需要开启USB调试功能，具体可以参考《华为EMUI最新版开启开发者选项》。
2、电脑需要安装ADB驱动，具体可以参考《最新Adb驱动工具下载及使用教程》。
3、按win+r键输入cmd运行，命令行输入【adb devices】命令查看电脑上连接的手机列表，如果能够正常显示连接的手机序列号则可以使用下面命令对手机进行操作，否则请检查驱动是否安装正确，与手机是否开启adb模式。
常见命令介绍：
【adb shell pm list packages】命令可以查看手机中所有应用的包名。
【adb shell pm list packages -s】命令可以查看手机内置的所有应用包名。
【adb shell pm disable-user 包名】将应用禁用，可隐藏桌面图标、禁止后台运行，但占用空间不会减少。
【adb shell pm enable 包名】可以将禁用的应用开启。
【adb shell pm uninstall --user 0 包名】或【adb shell pm uninstall 包名】卸载应用。
注意问题：
1、建议删减应用前备份手机中重数据防止无法进入系统，通过恢复手机出厂模式可以还原。
2、不清楚具体功能的包名，建议网上搜索下具体用途，是否可以禁止或卸载，避免误删导致系统崩溃。
3、优先使用禁用功能，一旦出现问题，还可以连接电脑重新开启。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff01a3eb82de892092e7dccbc8fa1f9/" rel="bookmark">
			Docker部署SpringBoot&#43;Vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.项目部署规划 1.后端多模块项目blog以及各模块运行端口： 前台服务模块sangeng-blog-&gt;7777，后台服务模块sangeng-admin-&gt;8989，公共模块sangeng-framework
2.前端前台Vue项目：sg-blog-vue-&gt;80 3.前端后台Vue项目：sg-vue-admin-&gt;81 4.docker所需镜像 java:17（jdk17）
mysql:8.0.19
redis:6.0.8
nginx:1.18.0
5.项目部署 安装docker
拉取java:8镜像，后端项目使用maven打包，上传jar包到服务器指定目录/mydata，编写Dockerfile文件，将后端项目打成镜像文件。
拉取mysql:8.0.19、redis:6.0.8、nginx:1.18.0镜像。
编写docker-compose.yml文件，使用docker-compose容器编排管理容器运行。
配置mysql，导入sql文件
配置redis，修改redis.conf文件
配置nginx，将打好包的Vue项目放到html目录下，并配置nginx.conf文件
测试运行
镜像上传阿里云镜像仓库
6.使用工具 IDEA
Navicat
Mobaxterm
2.前置工作 2.1后端项目使用maven打包 2.2项目打包，本地运行jar包测试 进入target目录下，在文件搜索框输入cmd进入Dos窗口，使用命令运行jar包
java -jar jar包 若未报错则jar包没有问题
2.3前端项目打包 npm run build 2.4在本地测试，放在Nginx里边，测试正常即可以使用 2.6配置安全组规则 在云服务器的安全组中添加规则
我这里是阿里云ECS，添加的是入方向规则
3.Docker安装 Docker运行环境要求系统为64位、Linux系统内核版本为 3.8以上
开始安装：
一：搭建gcc环境
yum -y install gcc yum -y install gcc-c++ 二：安装需要的软件包
yum install -y yum-utils 三：安装镜像仓库
但是因为docker的服务器是在国外，所以有时候从仓库中下载镜像的时候会连接被拒绝或者连接超时的情况，所以可以使用阿里云镜像仓库
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 四：更新yum软件包索引
yum makecache fast 五：安装docker引擎
yum install docker-ce docker-ce-cli containerd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eff01a3eb82de892092e7dccbc8fa1f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0961ce0a8ccfb421b8e9cfdfc91f884a/" rel="bookmark">
			vue设置整个页面回到顶部和局部div回到顶部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：在整个页面滚动的情况下可以这样设置 ​ mounted(){ window.addEventListener('scroll', this.handleScroll) }, methods :( handleScroll() { this .scrolltop = window.pageyoffset||document.documentElement.scrollTop||document .body.scrollTop }, gotop(){ let timer = setInterval(() =&gt; { let ostop = document.documentElement.scrollTop || document.body.scrollTop let ispeed = Math.floor(-ostop/5) document.documentElement.scrollTop = document.body.scrollTop = ostop+ispeed if(ostop ==-0){ clearInterval(timer) } },30) } } ​ 方法二：一个页面里面某个盒子局部滚动回到顶部 找到需要滚动内容盒子的父盒子 let p = document.querySelector('.van-tabs_content') this.$nextTick(() =&gt; { b.scrollTop = 0 }) // 一定要加nextTick 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db652824a22e1ce3a63872306e54b17/" rel="bookmark">
			ClickHouse之常见的时间周期函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言时区相关timeZonetoTimeZonetimeZoneOf 年相关toYeartoStartOfYeartoStartOfISOYeartoRelativeYearNumtoISOYear 季度相关toQuartertoStartOfQuartertoRelativeQuarterNum 月相关toMonthtoStartOfMonthtoRelativeMonthNum 周相关toMondaytoStartOfWeek(t[,mode])toISOWeektoRelativeWeekNumtoWeek(date[,mode])toYearWeek(date[,mode]) 日相关toDayOfYeartoDayOfMonthtoDayOfWeektoRelativeDayNum 时分秒相关toHourtoMinutetoSecondtoUnixTimestamptoStartOfDaytoStartOfHourtoStartOfMinutetoStartOfSecondtoStartOfFiveMinutetoStartOfTenMinutestoStartOfFifteenMinutestoStartOfInterval(time_or_data,间隔x单位[,time_zone])toTimetoRelativeHourNumtoRelativeMinuteNumtoRelativeSecondNum 时间计算相关date_truncdate_adddate_diffdate_subtimestamp_addtimestamp_subadd**subtract**timeSlots(StartTime, Duration,[, Size]) 当前时间相关now 转日期格式相关todayyesterdaytimeSlottoYYYYMMtoYYYYMMDDtoYYYYMMDDhhmmssformatDateTimedateNameFROM_UNIXTIMEtoModifiedJulianDaytoModifiedJulianDayOrNullfromModifiedJulianDayfromModifiedJulianDayOrNull 前言 在工作中，如果使用了ClickHouse作为数据的存储的话，那么难免会遇到关于时间的转换问题
比如：字符串转时间，日期等特定格式。
时区相关 timeZone 返回服务器的时区。 如果它在分布式表的上下文中执行，那么它会生成一个普通列，其中包含与每个分片相关的值。否则它会产生一个常数值。
语法
timeZone() 返回时区，类型为： String。
toTimeZone 将Date或DateTime转换为指定的时区。 时区是Date/DateTime类型的属性。 表字段或结果集的列的内部值（秒数）不会更改，列的类型会更改，并且其字符串表示形式也会相应更改。
语法
toTimezone(value, timezone) 参数
value — 时间或日期和时间。类型为DateTime64。timezone — 返回值的时区。类型为 String。 这个参数是一个常量，因为 toTimezone 改变了列的时区（时区是 DateTime 类型的属性）。 返回类型为DateTime的日期和时间。
示例：
select now() as current_time, toTimezone(toDateTime(now()), 'Asia/Yekaterinburg') as timezone_datetime, toTypeName(toDateTime(now())) as type_name; current_time timezone_datetime type_name 2023-04-19 11:08:17 2023-04-19T08:08:17+05:00 DateTime timeZoneOf 返回DateTime或者DateTime64数据类型的时区名称。
语法
timeZoneOf(value) 参数
value — 日期和时间。类型为DateTime或者DateTime64。 返回类型为String时区名称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0db652824a22e1ce3a63872306e54b17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91be2d7c8438682402cef4041e32bbfc/" rel="bookmark">
			模拟企业业务构建基于nginx的高可用web集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、项目初步环境的搭建
二、项目描述
三、项目步骤
四、项目心得
一、项目初步环境的搭建 9台8核4G的centos7-3.10.0服务器，其中包括3台backup服务器，2台负载均衡器，1台配置了prometheus的监控服务器，1台NFS服务器，1台DNS服务器和1台压力测试机器；nginx版本为nginx-1.22.1;keepalived
二、项目描述 构建一个基于nginx的7层负载均衡web集群，模拟企业的业务项目环境实现高并发、高可用的web集群，通过ab进行压力测试整个集群的性能，并不断进行改进
三、项目步骤 0.对本次集群项目进行网络规划，搭建好9台centos7服务器，配置好网络。
（web1的配置，其余机器按此方法进行同样的配置，注意IP地址的分配）
1.首先构建3台为真正提供web服务的后端服务器（backend server），使用脚本安装部署nginx软件，实现web服务功能，配置了状态统计模块，负载均衡，https等功能模块，使用nginx实现了7层负载均衡（也可以实现4层负载均衡）。
安装脚本：
#!bin/bash/
#解决软件的依赖关系，需要安装的依赖包
yum install epel-release -y
yum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel gcc gcc-c++ autoconf automake make psmisc net-tools lsof vim wget -y
#新建用户和组
useradd luojie -s /sbin/nologin
#下载nginx软件
mkdir /usr/local/luojie99 -p
cd /usr/local/luojie99
wget http://nginx.org/download/nginx-1.22.1.tar.gz
#解压文件
tar xf nginx-1.22.1.tar.gz
#进入解压后的文件
cd nginx-1.22.1
#编译前的配置
./configure --prefix=/usr/local/scluojie99 --user=luojie --group=luojie --with-http_ssl_module --with-threads --with-http_v2_module --with-http_stub_status_module --with-stream --with-http_gunzip_module
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91be2d7c8438682402cef4041e32bbfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52e84aa786f9e2a5d0b65136dbef0b62/" rel="bookmark">
			BUUCTF--Reverse--easyre，reverse1，新年快乐(面向新手，超详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.easyre
2.reverse1
3.新年快乐
1.easyre 把附件下载下来，放到ExeinfoPe中看一下
这里主要是看一下是几位的，以及有没有壳
64位的，无壳
至于有壳长什么样，可以看第三题--新年快乐
放到IDA中
看到很多人可能感觉很复杂，不慌，咱们先shift+f12查找所有的字符串
一般flag肯定都会在字符串里有提示
直接找到了flag
flag{this_Is_a_EaSyRe} 2.reverse1 老规矩，还是先把附件下载下来，放到ExeinfoPe中看看
无壳，64位
放到IDA中
依旧是先shift+f12查找所有字符串
仔细观察一下 this is the right flag 这里肯定有flag的相关提示
{hello word}看起来很像是flag，提交一下，发现不是
那让我们双击this is the right flag看一下这个二字符串
继续ctrl+x（交叉引用）查看是哪段函数调用了该字符串
ok
肯定很多人看不懂这些乱七八糟的，咱们可以f5进入伪代码观察一下
ok
这样就可以看到咱们比较熟悉的代码了
分析一下
咱们先找到this is the right flag"代码段，从这里开始看
sub_1400111D1应该是类似于print的输出函数
这串代码的意思简单来说
检查字符串 Str2 是否与 Str1 相同。如果是，输出 "this is the right flag!"，否则输出 "wrong flag"
咱们继续往上看，找一找str1和str2都是什么内容
根据字符串的提示，不难猜出，str1应该是我们输入的内容
那str2是什么呢，咱们找一个str2双击，看一下str2是什么
str2是咱们一开始猜测的flag：{hello word}
继续回到咱们的代码，继续分析
这里明显对str的内容进行了替换
111和48很明显是ascii编码
IDA可以直接把鼠标 放到ascii编码上按“R”键就可以转换成字符
原来是将o替换成了0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52e84aa786f9e2a5d0b65136dbef0b62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0692448f03bc9dd06a7fed1061862b3/" rel="bookmark">
			LINUX操作系统开放指定端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1：开放指定端口 root@xxx# firewall-cmd --zone=public --list-ports 8282/tcp 2：重新载入 firewall-cmd --reload 查询指定端口是否开启成功
firewall-cmd --query-port=8282/tcp 移除指定端口
firewall-cmd --permanent --remove-port=8282/tcp 3：查看防火墙状态 systemctl status firewalld 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15565acbc35be87c459b151526922afd/" rel="bookmark">
			Postgresql时间处理技巧，每半天，每周，每月和每5分钟统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、每半天
如果有张表log_bus_runinfo里有一个created_date是timestamp类型，如何统计12点前的数据？
在 PostgreSQL 中，您可以使用 DATE_TRUNC 函数和 WHERE 子句来统计特定时间范围内的数据。以下是一个查询例子，用于统计 log_bus_runinfo 表中创建日期 created_date 早于当天中午 12 点的记录数：
SELECT COUNT(*) FROM log_bus_runinfo WHERE DATE_TRUNC('day', created_date) = current_date AND created_date &lt; current_date + interval '12 hours' 上述查询会使用 DATE_TRUNC 函数将 created_date 字段截断为该天（时间部分被删除），之后使用 WHERE 子句选择操作当天（而不是整个历史）的记录，并且创建日期小于这一天中午 12 点（即 current_date + interval '12 hours'）。
同样，如果处理后半天的SQL：
SELECT COUNT(*) FROM log_bus_runinfo WHERE DATE_TRUNC('day', created_date) = current_date AND created_date &gt;= current_date + interval '12 hours' 二、每周
如果有张里程表count_mileage，字段count_mileage表示每天的里程数,如何统计上一周的公里数？
SELECT created_date::DATE-(extract(isodow from created_date::TIMESTAMP)-1||'day')::interval countWeek, sum(mileage_count) mileage from count_mileage GROUP BY created_date::DATE-(extract(isodow from created_date::TIMESTAMP)-1||'day')::"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15565acbc35be87c459b151526922afd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f755917fdfe29dfc53ee74e0b7e26ec/" rel="bookmark">
			word双栏排版，删除分节符双栏就变成了单栏，删除最后空白页方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鼠标放在最后一页，点击页面布局，选择页面布局右下角的图标
“新建页”，选择为“持续本页”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9317dd42e4834028a7b9b2b4b1a7e902/" rel="bookmark">
			JavaWeb--MyBatis 通过id查看表中数据、特殊字符处理（CDATA区）、条件查询（if、choose、when、otherwise）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaWeb–MyBatis 通过id查看表中数据 1.在mapper接口中构建selectAllById方法通过MyBatisX映射到sql映像中去
注意分析此时返回的应该是一个对象
Brand selectAllById(int id); &lt;resultMap id="brandResultMap" type="brand"&gt; &lt;!-- 主键的映射 &lt;id&gt;&lt;/id&gt;--&gt; &lt;result column="brand_name" property="brandName"/&gt; &lt;result column="company_name" property="companyName"/&gt; &lt;/resultMap&gt; &lt;select id="selectAllById" resultMap="brandResultMap"&gt; select * from tb_brand where id = #{id}; &lt;/select&gt; 这里还有一个属性parameterType=“int”，因为严格要求过传过来的是int类型的
所以这里忽略也没有问题
注意事项 SQL语句一定要写正确
${id}:为字符串拼接不能防止sql注入问题，因此常用于索要查找的某些字段不确定时代替变量成为类似占位符的符号
#{id}:参数传递，防止啦sql注入，非字符串拼接。常用于做sql语句的条件判断。
特殊字符处理 因为sql语句中的某些字符会与xml文件中的格式形同导致出现某些字符无法正常使用
转译字符
2.CDATA区 &lt;select id="selectAllByd" parameterType="int" resultMap="brandResultMap"&gt; # "小于号《" 报错 所以需要代替 解决方法 # 1. &amp;lt; --&gt; "小于号"; select * from tb_brand where id &amp;lt; #{id}; # 2.CDATA select * from tb_brand where id &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9317dd42e4834028a7b9b2b4b1a7e902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e25175b3c2d6405f8cc5430d26ad0dd9/" rel="bookmark">
			在mysql中操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#【例7.1】在stusys数据库中创建V_StudentScore视图，包括学号、姓名、性别、专业、课程号、成绩，且专业为计算机。
#【例7.2】在stusys数据库中创建V_StudentCourseScore视图，包括学号、姓名、性别、课程名、成绩，按学号升序排列，且专业为计算机。
#【例7.3】 分别查询V_StudentScore视图、V_StudentCourseScore视图。
#【例7.4】 查询计算机专业学生的学号、姓名、性别、课程名。
#
【
例7.5】在stusys数据库中，以student为基表，创建专业为通信的可更新视图
#【例7.6】 向V_StudentScore视图中插入一条记录：('196006','程超','男','1998-04-28','通信', 50)。 #【例7.7】 将V_StudentScore视图中学号为196006的学生的总学分增加2分。
#【例7.8】 删除V_StudentScore视图中学号为196006的记录。
#【例7.9】 将例7.1定义的视图V_StudentScore视图进行修改，取消专业为计算机的要求。
#【例7.10】修改例7.2创建的视图V_StudentCourseScore，学号以降序排列。 #【例7.11】 在stusys数据库中，将视图V_StudentCourseScore删除。
#【例7.12】 在stusys数据库中student表的sname列上，创建一个普通索引I_studentSname。
#【例7.13】 在stusys数据库中course表的cno列上，创建一个索引I_courseCno，要求按课程号cno字段值前2个字符降序排列。
#【例7.14】 在stusys数据库中student表的tc列(降序)和sname列(升序)，创建一个组合索引I_studentTcSname。
#【例7.15】在stusys数据库teacher表的tname列，创建一个唯一性索引I_teacherTname，并按降序排列。
#【例7.16】在stusys数据库中，创建新表score1表，主键为sno和cno，同时在grade列上创建普通索引。
#【例7.17】查看例7.16所创建的score1表的索引。
#【例7.18】删除已建索引I_studentTcSname。
#【例7.19】删除已建索引I_teacherTname。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d99a2d29c73682324dbe6ac6e7aff544/" rel="bookmark">
			kafka k8s部署kafka connect(以kafka-connector-hana插件为例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kafka-connect-sap地址
创建kafka connect镜像 # 创建插件文件夹及Dockerfile mkdir plugins # 此处创建kafka-connector-hana文件夹放kafka-connector-hana的插件以及hana的jdbc jar包 mkdir plugins/kafka-connector-hana # 其他插件同理，将插件所需文件放到plugins的插件文件夹即可 # 将准备好的Jar包放到指定文件夹 mv ./ngdbc.jar ./kafka-connector-hana/plugins/kafka-connector-hana/ mv ./kafka-connector-hana_2.13-0.9.4.jar ./kafka-connector-hana/plugins/kafka-connector-hana/ vim Dockerfile -------------- FROM quay.io/strimzi/kafka:0.34.0-kafka-3.4.0 USER root:root COPY ./plugins/ /opt/kafka/plugins/ USER 1001 -------------- # 打包镜像 docker build -t xx.xx.xx.xx/kafka-connector-hana:v1 . # 上传镜像到自己的镜像仓库 docker push xx.xx.xx.xx/kafka-connector-hana:v1 创建kafka connector 部署文件 kafka-connect.yaml apiVersion: kafka.strimzi.io/v1beta2 kind: KafkaConnect metadata: name: my-connect-cluster # annotations: # # use-connector-resources configures this KafkaConnect # # to use KafkaConnector resources to avoid # # needing to call the Connect REST API directly # strimzi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d99a2d29c73682324dbe6ac6e7aff544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/190829057003e79a9d48eb1ed4c876b1/" rel="bookmark">
			SqlSugar ORM初体验(多数据库表结构迁移)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：近期要用多款数据库，所以需要使用ORM来协助自动生成实体类和根据实体类生成数据库和表结构到多个不同数据库进行替代。于是了解到了SqlSugar，发现挺好用，除了华为opengauss数据库还有点问题，其他常见数据库和国产数据库都支持的挺好。顺便弄个DbFirst和CodeFirst穿插的入门教程，供参考。
1、创建一个类库项目，选择 .net standard 2.1版本
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
2、引用最新版sqlsugarcore
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
3、新增一个存放连接数据库的连接实体类，由于可能存在多个数据库，此处做成了字典来存放。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
4、创建一个连接工厂配置类，用于自定义连接哪些数据库使用。把常用的数据库类型都定义上，备用。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
5、再定义接口，用于后面实现依赖注入使用
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
6、创建一个webapi项目，用来做测试验证使用
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
7、在项目里面，新建一个DBModels备用，用来存放数据库实体类使用。并且在配置文件内，新增一个配置项，用来配置数据库连接，先配置一个Oracle数据库进行测试
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
8、添加一个简易版的读取appsettings内容的包：Wesky.Extensions.AppsettingsExtension
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
9、创建一个启动执行代码类，用来当程序启动的时候，读取配置文件内容进行初始化使用
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
10、在program启动项里面，进行有关的服务注册
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
11、新增一个用来生成数据库或者实体类的操作类。例如现在已有一个数据库，要生成实体类，配置要生成的路径以及规则，例如大小写等。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/190829057003e79a9d48eb1ed4c876b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697b1340d714c3d1a708aa9ba55b66de/" rel="bookmark">
			RabbitMQ 基础篇 | 黑马
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、RabbitMQ简介
1、AMQP
2、基本概念
3、工作模式
4、JMS
5、小结
二、快速入门
简单模式
生产者
消费者
三、工作模式
1、Work queues 工作队列模式
2、Pub/Sub 订阅模式
3、Routing 路由模式
4、Topics 通配符模式
四、SpringBoot整合RabbitMQ
1、生产者
2、消费者
3、小结
一、RabbitMQ简介 1、AMQP AMQP，即 Advanced Message Queuing Protocol (高级消息队列协议)，是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP
2007年Rabbit 技术公司基于AMQP 标准开发的 RabbitMQ1.0 发布。
RabbitMQ采用 Erlang 语言开发，Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。
2、基本概念 Brocker：接收和分发消息的应用（RabbitMQ Server）
Virtual host：逻辑分区的概念，类似于网络中的namespace，当多个不同用户使用同一个rabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange/queue等
Connection：publisher/consumer 和 broker 之间的TCP连接
Channel：如果每次访问RabbitMQ都建立Connection。在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是connection内部建立的逻辑连接，如果应用程序支持多线程，每个thread创建单独的channel进行通信，AMQP method包含了channel id帮助客户端和message broke识别channel，所以channel之间完全是隔离的。channel作为轻量级的connection极大减少了操作系统建立TCP connection的开销。
Exchange：message到达broker的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去
Queue：消息最终被送到这里等待consumer取走
Binding：exchange和queue之间的虚拟连接，binding中包含了routing key，binding信息被包含到exchange查询表中，用户message分发依据
3、工作模式 RabbitMQ 提供了6 种工作模式：简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing路由模式、Topics 主题模式、pC 远程调用模式(程调用，不太算 MQ;暂不作介绍)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/697b1340d714c3d1a708aa9ba55b66de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4fdc1bedd112746895ffad979f0c575/" rel="bookmark">
			算法设计—分支法与回溯法的不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求解目标不同： 回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是尽快地找出满足约束条件的一个解。
搜索方法不同： 由于求解目标不同，导致分支限界法与回溯法对解空间的搜索方式也不同，回溯法采用深度优先方法搜索解空间，而分支限界法一般采用用广度优先或以最小耗费优先的方式搜索解空间。
对扩展结点的扩展方式不同： 在回溯法中，如果当前的扩展结点不能够再向纵深方向移动，则当前扩展结点就成为死结点，此时应回溯到最近的一个活结点处并使此活结点成为扩展结点
在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。
存储空间的要求不同： 分支限界法的存储空间比回溯法大得多，因此当内存容量有限时，回溯法成功的可能性更大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1649e5d783fcc8b6e6b145d6ad35c819/" rel="bookmark">
			手把手教你设置DHCP服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一:DHCP介绍
1.DHCP的含义
2.使用DHCP的好处
3.DHCP的分配方式
（1）自动分配:
（2）手动分配:
（3）动态分配:
4.DHCP的租约过程
（1）第一步：客户端在网络中搜索服务器。
（2）第二步：服务器向客户端响应服务。
（3）第三步：客户端向服务器发出服务请求。
（4）第四步：服务器向客户端提供服务。
(5)：重新登录
(6)：更新租约
二：使用DHCP动态配置主机地址
1.可分配的地址信息主要包括
2.设置全局配置
3.DHCP服务配置流程 一:DHCP介绍 1.DHCP的含义 DHCP(Dynamic Host Configuration Protocol)，专门用于为TCP/IP网络中的计算机自动分配TCP/IP参数的协议，动态主机配置协议：计算机用来获得配置信息的协议。DHCP容许给某一计算机赋以IP地址而不需要管理者在服务器数据中配置有关该计算机信息。DHCP作用就是给PC分配一个IP。在一个局域网里面，你的路由有这个功能的话，那它就会把PC的MC地址记住，然后给这个PC分配一个IP地址，然后这个MC地址的PC以后就用这个IP地址上网，作用就是可以防止外来PC上网，和避免IP地址重复使用造成的错误。
DHCP协议采用UDP作为传输协议，主机发送请求消息到DHCP服务器的67号端口，DHCP服务器回应应答消息给客户端的68号端口。
2.使用DHCP的好处 减少管理员的工作量 ，避免输入错误的可能，避免IP地址冲突。
当更改IP地址段时，不需要重新配置每个用户的I地址，提高了IP地址的利用率，方便客户端的配置。
3.DHCP的分配方式 （1）自动分配: 对于用一个客户端,DHCP服务器将永久分配给它同一个IP地址。分配到一个IP地址后永久使用。
（2）手动分配: DHCP服务器将会根据预先配置的基于客户端Mac地址的IP分配表进行分配地址。由DHCP服务器管理员专门指定IP地址。
（3）动态分配: 我们平时最常用的分配方式。管理员划定一个地址池,DHCP服务器从地址池中任意选取一个地址分配给客户端。使用完后释放该IP，供其他客户机使用。
4.DHCP的租约过程 客户机从DHCP服务器获得IP地址的过程称为DHCP的租约过程。
（1）第一步：客户端在网络中搜索服务器。 客户端通过广播发送DHCP Discover报文寻找服务器端
（2）第二步：服务器向客户端响应服务。 服务器端通过广播发送DHCP offer 报文向客户端提供IP地址等网络信息，从IP地址池中挑选一个尚未分配的Ip地址分配给客户端
（3）第三步：客户端向服务器发出服务请求。 如果有多台DHCP服务器向该客户端发来DHCP-offer报文，客户端只接受第一个收到的DHCP-offer报文并提取IP地址，然后客户端通过广播发送DHCP Request 报文告知服务器端本地选择使用该IP地址
（4）第四步：服务器向客户端提供服务。 服务器通过单播发送DHCP Ack报文告知客户端IP地址是合法可用的，并在选项字段中增加IP地址的使用租期信息
(5)：重新登录 DHCP 客户机每次重新登录网络时，不需要再发送 DHCP Discover 信息，而是直接发送包含前一次所分配的 IP 地址的 DHCP Request 请求信息。
(6)：更新租约 当 DHCP 服务器向客户机出租的 IP 地址租期达到50%时，就需要更新租约。客户机直接向提供租约的服务器发送 DHCP Request 包，要求更新现有的地址租约。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1649e5d783fcc8b6e6b145d6ad35c819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862259cfa22ec13e9d5182b54aec57a7/" rel="bookmark">
			Linux下每次进来都需要手动执行source /etc/profile的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在我的Ubuntu上安装了JDK，但是发现每次新建终端之后，java命令就失效了。
解决办法：
1.打开 ~/.bashrc 文件
open ~/.bashrc
2.在文件末尾追加如下内容后，保存并关闭。
source /etc/profile
3.source该文件
source ~/.bashrc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b35e230739f4f86d4ca7fbabfc06634/" rel="bookmark">
			测试顶顶顶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ff83b4bb68ad98415f2d3981a4c12e/" rel="bookmark">
			Sql的优化方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 不要select *
2 减少回表 （回表是定位查到对应的记录后还要通过主键ID去定位具体的行记录）
3 使用explain进行sql语句分析
4 查看索引是否失效
5 尽量将句子优化到ref或则range级别，可以利用索引字段或则添加数据范围加快数据查询
6 考虑字段冗余，减少表关联
7 应用程序方面可以考虑引入redis缓存，ElasticSearch
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f255067d7b249c298e7fe452b7b995b/" rel="bookmark">
			Mybatis二级缓存实现及原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 Mybatis二级缓存是啥？
Mybatis的二级缓存Mapper级别的，sqlSession共享，它是把namespace做作为缓存key实现的，各个namespace是独立的，互相不影响（也就是说你执行一个查询sql方法，它会找到根据Mapper接口对应的namespace找到它的缓存Key）。而具体的sql查询语句是根据命名namespace、查询语句方法名及查询参数等拼接的一个缓存key，value值是第一次从数据库查询出来的结果，value需要实现Serilizable接口（流化、字节化），因为mybatis的缓存value值是字节数组。
二 实现： SpringBoot默认是关闭二级缓存的。如果想要单独那个Mapper实现cache，可以在xxxMapper.xml文件中添加即可。注意在xml文件中配了
三 优缺点
优点：二级缓存弥补一级缓存的不足。
一级缓存为啥不足呢？Mybatis一级缓存是sqlSession级别的，各个sqlSession的缓存数据是独立的（不共享）。由于Mybatis一般跟SpringMvc整合，在不开事务的情况下，每次请求都会开启一个sqlSession，请求完之后就关于了，缓存也清空了。所以这个缓存数据根本不能复用。
假如你在Service执行俩条查询逻辑
第一条 ：userMapper.getUserByNameAndPassWord(userName, passWord); // 从数据库中查询
第二条：userMapper.getUserByNameAndPassWord(userName, passWord); // 从数据库中查询
但是开启事务就不一样了，它用的就是同一个SqlSession（为啥能用一个SqlSession，基于代理和ThreadLocal）。
缺点：对于单表查询完全没问题，但是业务开始一般都是涉及多表查询，非常容易造成脏读。
假设一个用户表t_user,用户地址表t_user_address。俩个表通过用户编码关联user_id
mapper里的定义一个查询语句查询带有用户地址信息的用户
select tu.* from t_user tu inner join t_user_address tua on tu.user_id=tua.user_id;
这样定义完全没问题，当执行之后，Mybatis会把带有地址信息的用户信息缓存起来。下次再有查询的时候，直接从缓存中获取。但是假如通过业务操作将t_user_address表中的地址信息删除了一些，Mybatis查询带地址信息的本应该从缓存中取的，但由于它是不知道t_user_address表的数据已经做了修改操作了，它还是从缓存中读数据，这时候查出来了数据比数据库多了，造成脏读。
四 弥补二级缓存缺陷
采用&lt;cache-ref namespace="com.xxx.xxx"/&gt;，作用让当前的Mapper使用其他namespace的，达到缓存数据共享。这样当用户地址表删除地址信息时，用户表的缓存信息就被情况了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dfa0397faf2ad888a3f0003b3c3438f/" rel="bookmark">
			Python爬虫实战——下载小说
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python爬虫实战——下载小说 前言第三方库的安装示例代码效果演示结尾 前言 使用requests库下载开源网站的小说
注意：本文仅用于学习交流，禁止用于盈利或侵权行为。
操作系统：windows10 家庭版
开发环境：Pycharm Conmunity 2022.3
解释器版本：Python3.8
第三方库：requests、bs4
第三方库的安装 需要安装 bs4 和 requests 库
你可以参考我的以下文章获取些许帮助：
Python第三方库安装——使用vscode、pycharm安装Python第三方库
Python中requests库使用方法详解
示例代码 import requests from bs4 import BeautifulSoup # 伪装浏览器头 header={ "User-agent":"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36 Edg/112.0.1722.48" } # 53851740 是第一章的位置 # 746 - 740 = 6， 即爬取6章 for i in range(740,746): # 选定URL url= ("https://www.bbiquge.net/book/476/53851{}.html".format(i)) # 请求页面，返回response对象 resp=requests.get(url=url,headers=header) #解析页面 html=BeautifulSoup(resp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dfa0397faf2ad888a3f0003b3c3438f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439eba9d9eeb56943defbd79b0bc2bdb/" rel="bookmark">
			Python爬虫实战——获取电影影评
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python爬虫实战——获取电影影评 前言第三方库的安装示例代码效果演示结尾 前言 使用Python爬取指定电影的影评，
注意：本文仅用于学习交流，禁止用于盈利或侵权行为。
操作系统：windows10 家庭版
开发环境：Pycharm Conmunity 2022.3
解释器版本：Python3.8
第三方库：requests、bs4
第三方库的安装 需要安装 bs4 和 requests 库
你可以参考我的以下文章获取些许帮助：
Python第三方库安装——使用vscode、pycharm安装Python第三方库
Python中requests库使用方法详解
示例代码 #code:utf-8 import requests from bs4 import BeautifulSoup import time # 如果想多爬几页可以将16修改为更大的偶数 for i in range(2,16,2): url = 'https://movie.douban.com/subject/34841067/comments?start={}0&amp;limit=20&amp;status=P&amp;sort=new_score'.format(i) headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.5 Safari/605.1.15' } # 请求 r=requests.get(url, headers=headers) # 查看状态码 print(r.status_code) # 获取标题 html = BeautifulSoup(r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/439eba9d9eeb56943defbd79b0bc2bdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ffd2c1da0cab70ba4d39191985d651/" rel="bookmark">
			中间人攻击（ARP欺骗）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Vmware常识：
vmnet:表示虚拟交换机
vmnet0:桥接模式，表示接入物理机连接的真实交换机，和物理机在同一交换机。
vmnet1:物理机上vmnet1网卡连接在此虚拟交换机。
vmnet 1-19，表示有19台虚拟交换机。
2、ARP协议：
ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。其作用是在以太网环境中，数据的传输所依懒的是MAC地址而非IP地址（交换机只能认识MAC地址），而将已知IP地址l转换为MAC地址的工作是由ARP协议来完成的。
在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。
3、ARP协议原理：
1、发送方：发送ARP广播请求。封装帧头目的MAC为FF。
2、应答方：发送ARP单播应答。封装帧头目的MAC为发送方MAC地址。
双方都会建立ARP缓存，记录IP地址与MAC地址对应关系。
命令行下：arp -a 可看本机arp缓存。
4、ARP攻击原理：
攻击人通过发送虚假的ARP应答实现ARP缓存投毒！而受害人没有办法进行身份验证！当同时有多个应答时，ARP缓存表会以谁的数据报后到达则存储谁的MAC地址，攻击人会一直发送数据报从而欺骗APR缓存表。
5、中间人攻击(Man-in-the-MiddleAttack，简称“MITM攻击”)
通过拦截正常的网络通信数据，并进行
数据篡改和嗅探，而通信的双方却毫不知情。
实施中间人攻击时，攻击者常考虑的方式是ARP欺骗或DNS欺骗等，将会话双方的通讯流暗中改变，而这种改变对于会话双方来说是完全透明的。
1）信息篡改
当主机A、和主机B通信时，都由主机C来为其“转发”。
2）信息窃取
当A、B通信时，C不主动去为其“转发”，只是把他们的传输的数据备份，以获取用户网络的活动，包括账户、密码等敏感信息，这是被动攻击也是非常难被发现的。
6、中间人攻击实验
1）Vmware虚拟机中分别安装kali、win2012、win7操作系统。
2）将三台虚拟机的网卡都设置连接到vmnet2虚拟交换机。
3）设置win7的ip地址：10.1.1.1/24
设置win2012的ip地址：10.1.1.3/24
设置kali的ip地址：10.1.1.2/24
kali系统中按ctrl+shift+"+"，可放大字符显示。
配置临时IP地址：ifconfig eth0 ip/24
查看IP地址：ifconfig eth0
4)win2012安装IIS和FTP，并测试可访问网站、可通过账号密码进入FTP目录。
iis中安装一个简易ASP站点，可测试后台登陆。
5）kali系统中ettercap工具进行中间人攻击（ARP欺骗）
ettercap工具使用：
1、sniff菜单——unoffensive——eth0（选择要攻击的网卡）
2、hosts菜单——host list 列出所有IP
3、hosts——scan for hosts 扫描IP
4、host list中选择IP:10.1.1.1——add to target 1(添加目标1)——选择另一个IP:10.1.1.3——add to target 2(添加目标2)
5、mitm——arp poisoning (arp投毒)——勾选：sniff remote connections
6）测试结果
当win7被毒化后，在命令行输入：arp -a，发现IP对应的MAC地址都是相同的。
在win7登陆win2012网站后台或FTP登陆成功后，在ettercap中会劫持到相应的账号、密码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3436a033594a2fd1eb703749d9ea2e7/" rel="bookmark">
			某省职业院校技能大赛中职网络信息安全赛项环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		竞赛时间 共计180分钟。
竞赛阶段 （一）第一阶段任务书（70分）
任务一：攻击日志分析 任务环境说明：
服务器场景：PYsystem0031服务器场景操作系统：未知服务器场景FTP用户名:anonymous 密码：空 从靶机服务器的FTP上下载attack.pcapng数据包文件，通过分析数据包attack.pcapng，找出黑客的IP地址，并将黑客的IP地址作为FLAG（形式：[IP地址]）提交；（1分）继续查看数据包文件attack.pacapng，分析出黑客扫描得到的靶机开放的端口，将靶机开放的端口作为FLAG（形式：[端口名1,端口名2,端口名3…,端口名n]）从低到高提交；（1分） 继续查看数据包文件attack.pacapng，分析出黑客成功入侵后获得的操作系统的版本号，将操作系统的版本号作为FLAG（形式：[操作系统版本号]）提交；（1分）继续查看数据包文件attack.pacapng，分析出黑客成功入侵后执行的第一条命令，并将执行的第一条命令作为FLAG（形式：[第一条命令]）提交；（1分） 继续查看数据包文件attack.pacapng，分析出黑客成功入侵后执行的第二条命令，并将执行的第二条命令作为FLAG（形式：[第二条命令]）提交；（2分） 继续查看数据包文件attack.pacapng，分析出黑客成功入侵后执行的第二条命令的返回结果，并将执行的第二条命令返回结果作为FLAG（形式：[第二条命令返回结果]）提交；（2分） 继续查看数据包文件attack.pacapng，分析出黑客成功入侵后执行的第三条命令的返回结果，并将执行的第三条命令返回结果作为FLAG（形式：[第三条命令返回结果]）提交。（2分） 任务二：系统漏洞利用与提权 任务环境说明：
服务器场景：PYsystem0033服务器场景操作系统：Ubuntu服务器场景用户名:未知 密码：未知 使用nmap扫描靶机系统，将靶机开放的端口号按从小到大的顺序作为FLAG（形式：[端口1,端口2…,端口n]）提交；（1分）通过上述端口访问靶机系统，使用弱口令进行登录，将正确的用户名和密码作为FLAG（形式：[用户名,密码]）提交；（1分）利用Kali渗透机生成反弹木马，将生成木马命令执行后提示的第四行的首个单词作为FLAG（形式：[单词]）提交；（1分）对上述木马文件进行修改后上传到靶机系统中，使用MSF开启监听，将获得的当前权限的用户名作为FLAG（形式：[用户名]）提交；（1分）查看系统内核版本信息，将系统内核版本号作为FLAG（形式：[版本号]）提交；（1分）在Kali攻击机中查找可使用的漏洞源码，将找到的漏洞源码文件名作为FLAG（形式：[文件名]）提交；（1分）利用上述漏洞源码后获得到的靶机/root下的唯一.txt文件的文件名作为FLAG（形式：[文件名]）提交；（1分）（2分）利用上述漏洞源码后将获得到的靶机/root下的唯一.txt文件的文件内容作为FLAG（形式：[文件内容]）提交。（2分） 任务三：代码审计 任务环境说明：
服务器场景：PYsystem0035服务器场景操作系统：未知服务器场景用户名:未知 密码：未知 1.在渗透机Kali Linux中访问靶机服务器Web页面，注册账号并登陆，找到存在XSS执行漏洞的页面，将该页面中存在XSS执行漏洞的对象名作为FLAG提交；（2分）
2.构造Cookie反弹JS脚本，将该JS代码中使用的对象及方法作为FLAG（形式：对象.方法）进行提交；（2分）
3.在渗透机Kali Linux中重启Web服务，将重启使用的命令作为FLAG进行提交；（2分）
4.在靶机服务器中利用原有的XSS漏洞调用上述JS脚本，在渗透机Kali Linux中开启3333端口监听，将开启端口监听使用的命令作为FLAG提交；（2分） 5.在渗透机Kali Linux中开启3333端口监听，将开启端口监听后接收回应的第一行的第一个单词作为FLAG提交；（2分）
6.在渗透机Kali Linux中开启3333端口监听，将开启端口监听后接收回应的第五行的最后一个单词作为FLAG提交。（2分）
任务四：Web安全渗透测试 任务环境说明：
服务器场景：PYsystem0043服务器场景操作系统：未知服务器场景用户名:未知 密码：未知 1.通过浏览器访问http://靶机服务器IP/1，对该页面进行渗透测试, 找到flag格式：flag｛Xxxx123｝，括号中的内容作为flag值并提交；（2分）
2.通过浏览器访问http://靶机服务器IP/2，对该页面进行渗透测试, 找到flag格式：flag｛Xxxx123｝，括号中的内容作为flag值并提交；（2分）
3.通过浏览器访问http://靶机服务器IP/3，对该页面进行渗透测试, 找到flag格式：flag｛Xxxx123｝，括号中的内容作为flag值并提交；（2分）
4.通过浏览器访问http://靶机服务器IP/4，对该页面进行渗透测试, 找到flag格式：flag｛Xxxx123｝，括号中的内容作为flag值并提交；（3分）
5.通过浏览器访问http://靶机服务器IP/5，对该页面进行渗透测试, 找到flag格式：flag｛Xxxx123｝，括号中的内容作为flag值并提交。（3分）
任务五：Linux操作系统渗透测试 任务环境说明：
服务器场景：PYsystem0040服务器场景操作系统：未知服务器场景用户名:未知 密码：未知 通过渗透机Kali对靶机服务器进行系统服务及版本扫描渗透测试，并将该操作显示结果中21端口对应的服务版本信息字符串作为Flag值提交；（1分）通过渗透机Kali对靶机服务器进行渗透测试，将该场景/var/www目录中唯一一个后缀为.bmp文件的文件名称作为Flag值提交；（1分）通过渗透机Kali对靶机服务器进行渗透测试，将该场景/var/www目录中唯一一个后缀为.bmp的图片文件中的英文单词作为Flag值提交；（1分）通过渗透机Kali对靶机服务器进行渗透测试，将该场景/home/guest目录中唯一一个后缀为.pdf文件的文件名称作为Flag值提交；（1分）通过渗透机Kali对靶机服务器进行渗透测试，将该场景/home/guest目录中唯一一个后缀为.pdf文件的文件内容作为Flag值提交；（2分）通过渗透机Kali对靶机服务器进行渗透测试，将该场景/var/vsftpd目录中唯一一个后缀为.docx文件的文件名称作为Flag值提交；（1分）通过渗透机Kali对靶机服务器进行渗透测试，将该场景/var/vsftpd目录中唯一一个后缀为.docx文件的文件内容作为Flag值提交；（2分）通过渗透机Kali对靶机服务器进行渗透测试，将该场景/root目录中唯一一个后缀为.txt文件的文件名称作为Flag值提交；（1分）通过渗透机Kali对靶机服务器进行渗透测试，将该场景/root目录中唯一一个后缀为.txt文件的文件内容作为Flag值提交。（2分） 任务六：端口扫描Python渗透测试
任务环境说明：
服务器场景：PYsystem0041服务器场景操作系统：未知服务器场景FTP用户名:anonymous 密码：空 1. 从靶机服务器的FTP上下载PortScan.py，编辑Python程序PortScan.py，实现基于TCP全开的端口扫描，填写该文件当中空缺的F1字符串，将该字符串作为Flag值提交；（1分） 2.继续编辑Python程序PortScan.py，实现基于TCP全开的端口扫描，填写该文件当中空缺的F2字符串，将该字符串作为Flag值提交；（1分） 3.继续编辑Python程序PortScan.py，实现基于TCP全开的端口扫描，填写该文件当中空缺的F3字符串，将该字符串作为Flag值提交；（1分） 4. 继续编辑Python程序PortScan.py，实现基于TCP全开的端口扫描，填写该文件当中空缺的F4字符串，将该字符串作为Flag值提交；（2分） 5. 继续编辑Python程序PortScan.py，实现基于TCP全开的端口扫描，填写该文件当中空缺的F5字符串，将该字符串作为Flag值提交；（2分） 6. 继续编辑Python程序PortScan.py，实现基于TCP全开的端口扫描，填写该文件当中空缺的F6字符串，将该字符串作为Flag值提交；（2分） 7. 继续编辑Python程序PortScan.py，实现基于TCP全开的端口扫描，填写该文件当中空缺的F7字符串，将该字符串作为Flag值提交；（2分） 8. 继续编辑Python程序PortScan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3436a033594a2fd1eb703749d9ea2e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08f2a30aca8604a849d448f019558be/" rel="bookmark">
			2022年广西壮族自治区第二届职业技能大赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B-1：Windows操作系统渗透测试 任务环境说明：
服务器场景：Server2003服务器场景操作系统：Windows7 通过本地PC中渗透测试平台Kali对服务器场景Windows进行系统服务及版本扫描渗透测试，并将该操作显示结果中Telnet服务对应的端口号作为FLAG提交；通过本地PC中渗透测试平台Kali对服务器场景Windows进行渗透测试，使用kali中hydra对服务器Telnet服务进行暴力破解（用户名为teltest），将hydra使用的必要参数当做FLAG进行提交（例：nmap -s -p 22）；（字典路径/usr/share/wordlists/dirb/small.txt）通过本地PC中渗透测试平台Kali对服务器场景Windows进行渗透测试，使用kali中hydra对服务器Telnet服务进行暴力破解（用户名为teltest），将破解成功的密码当做FLAG进行提交；（字典路径/usr/share/wordlists/dirb/small.txt）通过本地PC中渗透测试平台win7对服务器场景Windows进行渗透测试，取得的账户密码有远程桌面权限，将该场景系统中sam文件使用reg相关命令提取，将完整命令作为FLAG提交；通过本地PC中渗透测试平台win7对服务器场景Windows进行渗透测试，取得的账户密码有远程桌面权限，将该场景系统中system文件使用reg相关命令提取，将完整命令作为FLAG提交；通过本地PC中渗透测试平台win7对服务器场景Windows进行渗透测试，将sam文件与system文件提取到本地，使用桌面mimikatz工具提取teltest密码信息，将提取信息的命令作为FLAG提交;通过本地PC中渗透测试平台win7对服务器场景Windows进行渗透测试，将sam文件与system文件提取到本地，使用桌面mimikatz工具提取administrators密码信息，将提取到的hash值作为FLAG提交; B-2：Linux操作系统渗透测试 任务环境说明：
服务器场景：Server2106（关闭链接）服务器场景操作系统：Linux（版本不详） 通过本地PC中渗透测试平台Kali对服务器场景进行渗透测试，将该场景/var/www目录中唯一一个后缀为.bmp文件的文件名称作为Flag值提交；通过本地PC中渗透测试平台Kali对服务器场景进行渗透测试，将该场景/var/www目录中唯一一个后缀为.bmp的图片文件中的英文单词作为Flag值提交；通过本地PC中渗透测试平台Kali对服务器场景进行渗透测试，将该场景/var/vsftpd目录中唯一一个后缀为.docx文件的文件名称作为Flag值提交；通过本地PC中渗透测试平台Kali对服务器场景进行渗透测试，将该场景/var/vsftpd目录中唯一一个后缀为.docx文件的文件内容作为Flag值提交；通过本地PC中渗透测试平台Kali对服务器场景进行渗透测试，将该场景/home/guest目录中唯一一个后缀为.pdf文件的文件名称作为Flag值提交；通过本地PC中渗透测试平台Kali对服务器场景进行渗透测试，将该场景/home/guest目录中唯一一个后缀为.pdf文件的文件内容作为Flag值提交；通过本地PC中渗透测试平台Kali对服务器场景进行渗透测试，将该场景/root目录中唯一一个后缀为.txt文件的文件名称作为Flag值提交；通过本地PC中渗透测试平台Kali对服务器场景进行渗透测试，将该场景/root目录中唯一一个后缀为.txt文件的文件内容作为Flag值提交。 B-3：信息取证分析 任务环境说明：
服务器场景：FTPServer220817服务器场景操作系统：未知（封闭靶机）FTP用户名：wireshark0051密码：wireshark0051 从靶机服务器的FTP上下载wireshark0051.pcap数据包文件，找出黑客获取到的可成功登录目标服务器FTP的账号密码，并将黑客获取到的账号密码作为Flag值（用户名与密码之间以英文逗号分隔，例如：root,toor）提交；继续分析数据包wireshark0051.pcap，找出黑客使用获取到的账号密码登录FTP的时间，并将黑客登录FTP的时间作为Flag值（例如：14:22:08）提交；继续分析数据包wireshark0051.pcap，找出黑客连接FTP服务器时获取到的FTP服务版本号，并将获取到的FTP服务版本号作为Flag值提交；继续分析数据包wireshark0051.pcap，找出黑客成功登录FTP服务器后执行的第一条命令，并将执行的命令作为Flag值提交;继续分析数据包wireshark0051.pcap，找出黑客成功登录FTP服务器后下载的关键文件，并将下载的文件名称作为Flag值提交；继续分析数据包wireshark0051.pcap，找出黑客暴力破解目标服务器Telnet服务并成功获取到的用户名与密码，并将获取到的用户名与密码作为Flag值（用户名与密码之间以英文逗号分隔，例如：root,toor）提交；继续分析数据包wireshark0051.pcap，找出黑客在服务器网站根目录下添加的文件，并将该文件的文件名称作为Flag值提交；继续分析数据包wireshark0051.pcap，找出黑客在服务器系统中添加的用户，并将添加的用户名与密码作为Flag值（用户名与密码之间以英文逗号分隔，例如：root,toor）提交。 B-4：网络安全事件响应 任务环境说明：
服务器场景：Server2215服务器场景操作系统：未知（封闭靶机） 黑客通过网络攻入本地服务器（靶机），在Web服务器的主页上外挂了一个木马连接，请你找到此连接并删除该连接，将对应的标题名称作为Flag值提交;黑客攻入本地的数据库服务器，并添加了除admin以外的具有一个管理员权限的超级用户，将此用户的密码作为Flag值提交;黑客攻入本地服务器，在本地服务器建立了多个超级用户，请你删除除了Administrator用户以外的其他超级管理员用户，然后在命令行窗口输入net user，将Administrator右边第一个单词作为Flag值提交;黑客修改了服务器的启动内容，请你删除不必要的启动项程序，将该启动项程序的名称作为Flag值（如有多个名称之间以英文逗号分隔，如：hello,test）提交;黑客在服务器某处存放了一个木马程序，请你找到此木马程序并清除木马，将木马文件名作为Flag值提交。 B-5：代码审计 任务环境说明：
服务器场景：PYsystem002服务器场景操作系统：未知（显示链接）服务器用户名:未知 密码：未知 在渗透机Kali Linux中访问靶机服务器Web页面，注册账号并登陆，找到存在XSS执行漏洞的页面，将该页面中存在XSS执行漏洞的对象名作为FLAG提交；构造Cookie反弹JS脚本，将该JS代码中使用的对象及方法作为FLAG（形式：对象.方法）进行提交；在渗透机Kali Linux中重启Web服务，将重启使用的命令作为FLAG进行提交；在靶机服务器中利用原有的XSS漏洞调用上述JS脚本，在渗透机Kali Linux中开启3333端口监听，将开启端口监听使用的命令作为FLAG提交；在渗透机Kali Linux中开启3333端口监听，将开启端口监听后接收回应的第一行的第一个单词作为FLAG提交；在渗透机Kali Linux中开启3333端口监听，将开启端口监听后接收回应的第五行的最后一个单词作为FLAG提交。 B-6：应急响应 任务环境说明：
服务器场景：FTPServer220817服务器场景操作系统：未知（封闭靶机）FTP用户名:log密码：log 从靶机服务器的FTP上下载日志文件，分析日志文件，将黑客成功登录系统所使用的IP地址作为Flag值提交；黑客成功登录系统后修改了登录用户的用户名，将修改后的用户名作为Flag值提交；黑客成功登录系统后成功访问了一个关键位置的文件，将该文件名称（文件名称不包含后缀）作为Flag值提交；黑客成功登录系统后重启过几次数据库服务，将最后一次重启数据库服务后数据库服务的进程ID号作为Flag值提交；黑客成功登录系统后修改了登录用户的用户名并对系统执行了多次重启操作，将黑客使用修改后的用户重启系统的次数作为Flag值提交。 需要环境的私信
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa84888d08729b5145278fbc8abcbd6/" rel="bookmark">
			IDEA Alibaba规范化模板(代码格式化，注释模板化，常用自定义快捷键)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 本文意在将IDEA中的代码格式和注释格式进行统一化。
研发团队的成员的代码格式和注释格式统一化。
统一的代码格式和注释格式，能给代码阅读上带来极大的便利，给代码改动上提高极大的效率。
代码格式话模板配置（非必要配置，也可直接使用IDEA默认格式化即可） 阿里模板下载地址
https://github.com/alibaba/p3c/tree/master/p3c-formatter
下载阿里配置文件（eclipse-codestyle.xml），因为此文件是针对ecplice的，在IDEA中使用配置文件，需要安装Eclipse Code Formatter插件
配置代码格式，File-&gt;Settings-&gt;Other Settings-&gt;Eclipse Code Formatter进行idea代码格式配置：将代码格式化文件eclipse-codestyle.xml，配置到插件中： IDEA代码注释模板配置 为了减少警告以及更好的集成统一API的文档第三方工具，我们严格按照java文档注释来配置相关的模板配置。
类注释模板配置 IDEA配置导航地址：settings-&gt;Editor-&gt;File and Code Templates-&gt;Files-&gt;class
类注释模板（注释模板的上的空行也算是模板的一部分不要更改，复制到指定位置并且一定保持与给出的模板一模一样，换行以及*以及*号之间的空格都要一一对应）
/** * ${NAME} ${description} * @author ${USER} * @version ${YEAR}/${MONTH}/${DAY} ${HOUR}:${MINUTE} **/ public class ${NAME} { } 接口注释模板配置 IDEA配置导航地址：settings-&gt;Editor-&gt;File and Code Templates-&gt;Files-&gt;Interface
接口注释模板（注释模板的上的空行也算是模板的一部分不要更改，复制到指定位置并且一定保持与给出的模板一模一样，换行以及*以及*号之间的空格都要一一对应）
/** * ${NAME} ${description} * @author ${USER} * @version ${YEAR}/${MONTH}/${DAY} ${HOUR}:${MINUTE} **/ public interface ${NAME} { } 枚举注释模板配置 IDEA配置导航地址：settings-&gt;Editor-&gt;File and Code Templates-&gt;Files-&gt;Enum
枚举注释模板（注释模板的上的空行也算是模板的一部分不要更改，复制到指定位置并且一定保持与给出的模板一模一样，换行以及*以及*号之间的空格都要一一对应）
/** * ${NAME} ${description} * @author ${USER} * @version ${YEAR}/${MONTH}/${DAY} ${HOUR}:${MINUTE} **/ public enum ${NAME} { } 注解注释模板配置 注解注释模板（注释模板的上的空行也算是模板的一部分不要更改，复制到指定位置并且一定保持与给出的模板一模一样，换行以及*以及*号之间的空格都要一一对应）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa84888d08729b5145278fbc8abcbd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df9a7779f5acda31c70fc0d6d5e139d/" rel="bookmark">
			单词连连看 2023 版 发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一款基于经典游戏『连连看』的单词强化记忆软件。有助于巩固单词, 并寓学习于娱乐。
下载1 下载2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feaafe4ce10e85d00b1b8dc06a73d7e6/" rel="bookmark">
			【IoT毕设】机智云AIoT&#43;STC15&#43;承压式太阳能热水器智能控制系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 摘要:本系统采用STC15F2K60S2单片机作为控制中心，温度传感器部分采用DS18B20数字型温度传感器，同时结合物联网技术通过机智云物联网云平台创建手机APP，实现承压式太阳能热水器的远程控制。根据承压式太阳能热水器的要求设计该控制系统，实现温度与设置加热温度的显示、控制加热装置开关、通过手机APP实现远程监控和操作等功能。 0引言 我国太阳能资源丰富，多地都在大面积利用太阳能，利用太阳能可以减少对不可再生能源的浪费，降低对环境的污染。在我国对太阳能的利用形式中，承压式太阳能热水器占据重要地位，为居民提供了充足的热水资源。虽然太阳能热水器产业发展迅速，但仍面临着诸多问题，比如智能化、人性化和节能方面的不足。随着科学技术的不断创新以及物联网技术的快速发展，物联网已经成为全球研究的热点[1-2]。 本文设计了一种以STC15单片机作为控制中心，结合物联网技术的太阳能热水器控制系统。一个完整的承压式太阳能热水器控制器主要由单片机、电源、按键、温度传感器、显示模块、远程监控模块等组成。远程监控模块是结合物联网技术通过机智云物联网云平台创建手机APP来实现的。 机智云平台为开发者提供了自助式智能硬件开发工具与开放的云端服务[3]。通过“傻瓜化”的自助工具、SDK与API服务能力最大限度降低了物联网硬件开发的技术门槛，帮助开发者进行硬件智能化升级，降低了研发成本，加快了开发者的产品投产速度。该系统中STC15F2K60S2单片机通过WiFi无线通信模块将太阳能热水器相关参数和状态传输至手机APP，通过对手机APP的使用实现远程监控和操作。用户无须亲临设备现场就可以监视并控制家用太阳能热水器的运行状态及各种参数，方便用户使用，智能化、人性化程度得到提高。 1总体方案设计 承压式太阳能热水器系统结构框图如图1所示，系统主要由温度传感器、驱动电路、单片机、按键、数码管、WiFi模块、报警装置和手机APP等组成。温度传感器通过温度探头测量水箱温度，并将数据传送至单片机进行处理。驱动电路通过单片机控制继电器吸合与断开，从而控制加热装置工作[4]。根据需要设计按键，实现设置加热温度、控制加热装置开关、复位和配网等功能。数码管用来显示传感器测得的温度和用户设置的温度。报警装置在热水器工作异常时，通过LED灯闪烁和蜂鸣器发声提醒用户。 通过WiFi模块借助机智云物联网平台创建手机APP，使用户能够通过手机界面远程监控家用热水器。用户可以通过手机APP设定加热温度，如果符合加热条件，手机APP传输数据至单片机，单片机会传输信息给驱动电路，从而控制加热装置进行工作。如果不符合加热条件，单片机会发出信号控制继电器断开，使加热装置停止工作。 系统中还设计了掉电保存功能，当单片机断电后再打开电源，用户之前设置的温度值仍保存不变。本系统结合了物联网技术，并通过机智云平台创建了手机APP，具备智能家居的特点，有针对性地解决了传统控制系统的不足，提升了用户对热水器的使用体验，同时提高了热水器的智能化程度。 图1承压式太阳能热水器系统结构框图 2系统的硬件设计 2.1温度传感器模块 本系统温度检测电路中采用DS18B20数字型温度传感器。它采用单线接口方式，仅需一个端口引脚来发送和接收信息，在单片机和DS18B20之间仅需一条数据线和一条地线进行接口。DS18B20内部有3个主要数字部件：64位激光ROM、温度传感器、非易失性温度报警触发器TH和TL[5]。 本设计中DS18B20采用3～5.5V电源供电，其原理如图2所示。该温度传感器测量的结果以数字量方式串行传送，由于其数模转换已经在DS18B20内部完成，因此不需要连接A/D转换器的输入通道。将DS18B20置于水箱合适位置处，确保测得温度的精度较高。 图2DS18B20数字型温度传感器原理 2.2驱动电路与报警装置设计 承压式太阳能热水器是采用承压式水箱的太阳能热水器，水箱可以提供强劲的水压，直接利用给水管网压力作为热水出水压力，使热水压力等同于冷水压力[6]。因此，在驱动电路中只需要通过继电器实现加热操作，其驱动电路和报警装置原理如图3所示。 图3驱动电路和报警装置原理 继电器是具有隔离功能的自动开关元件，广泛应用于自动控制和电力电子等其他设备中[7]。经过分析，本系统选择了OZ-SH-112LM1型继电器。在驱动回路中，IO端口连接STC15单片机的P0.4引脚，用于控制继电器通断；继电器的1端和2端并联一个二极管，用于吸收和释放继电器线圈断电时产生的反向电动势，防止反向电动势击穿三极管并干扰其他电路；报警装置由LED灯和蜂鸣器组成。 由图3可知，当单片机控制IO端口为高电平时，三极管导通，继电器K1端通电吸合，CN1-L端口接入220V电源，CN2端口与电加热棒相连，电加热棒工作；当单片机控制IO端口为低电平时，三极管不导通，继电器K1端断电释放，电加热棒停止工作。在满足设置温度大于测得实时温度，并需要打开加热开关时，单片机使P0.4引脚输出高电平，此时继电器K1通电吸合，使得继电器输出侧A和B导通，输出回路中的加热棒通电工作，系统开始对水箱中的水进行加热，同时伴随LED2灯亮。 当加热温度达到设置温度值，单片机使P0.4引脚输出低电平，此时继电器K1断电释放，使得继电器输出侧A和B断开，输出回路中的加热棒停止工作，同时LED2灯熄灭。如果系统出现以下异常，报警装置会给用户发出异常提醒。 第一种异常情况，当设置温度小于或者等于测得实时温度时，用户按下加热按钮，控制单片机使P0.4引脚输出高电平，则系统会控制单片机的P1.4引脚输出高电平，控制P3.4引脚输出低电平，此时蜂鸣器发声以及LED3灯亮，系统控制单片机使P0.4引脚输出低电平，禁止加热棒工作。第二种异常情况，当加热温度达到设置温度时，加热棒仍然继续加热，此时系统会控制单片机的P1.4引脚输出高电平，控制P3.4引脚输出低电平，此时蜂鸣器发声以及LED3灯亮。不断检测P0.4引脚输出电平状态，直至P0.4引脚输出低电平，蜂鸣器停止发声，LED3灯熄灭。待用户操作正确后，系统恢复正常。 2.3按键与显示模块设计 本方案通过数码管显示传感器测得的温度和设置的加热温度，根据数码管的特点，选择利用两级74HC595芯片驱动数码管，其原理如图4所示。74HC595是一款漏极开路输出的CMOS一位寄存器，具有可控的三态输出端口、标准SPI串行接口[8]。 图474HC595驱动两位八段数码管原理 74HC595在正常使用时10端复位端接高电平，13端输出允许端接低电平。在14端串行数据输入端输入数据，每输入一位，11端移位寄存器输入时钟上升沿有效一次，直到8位数据输入完毕；然后，12端存储器输入时钟上升沿有效一次，输入的数据就被送到了输出端。上一级74HC595芯片的9端级联输出端，与下一级74HC595芯片的14端串行数据输入端相连，实现了两个芯片的级联。 上一级74HC595芯片的9端级联输出端，与下一级74HC595芯片的14端串行数据输入端相连，实现了两个芯片的级联。通过移位寄存器的时钟输入时钟上升沿并将数据移入和通过存储寄存器的时钟输入时钟上升沿并将数据输出，这是两个独立的过程，实际应用时互不干扰，在输出数据的同时可以移入数据。 在硬件电路中设计了多个按键，按键主要是用来设置温度，控制温度加法计数和减法计数，以及用来控制加热装置、配网和复位。按键设计原理如图5所示。 图5按键设计原理 由图5可知，按键SW1是对当前设置加热温度进行减法计数，按键SW2是对当前设置加热温度进行加法计数。在按键短按时，程序跳转至温度设置子程序，此时数码管显示设置的加热温度，并伴随LED灯的LED1或LED2闪烁，经过5s后，跳出温度设置子程序，数码管继续显示传感器测得的实时温度。按键SW3用来控制加热装置，在按键SW3短按时，程序跳转至温度加热子程序，系统控制单片机使P0.4引脚输出高电平，此时继电器K1通电吸合，输出回路中的加热棒通电工作，系统开始对水箱中的水进行加热，同时伴随LED2灯亮。 当加热温度达到设置温度值时，单片机使P0.4引脚输出低电平，此时继电器K1断电释放，输出回路中的加热棒停止工作，同时LED2灯熄灭，跳出温度加热子程序。按键SW4控制WiFi模块进行配置入网，实现单片机与手机APP的远程通信。按键SW5按键短按，进入模组复位。 2.4WiFi模块设计 远程通信部分选用ATK-esp8266-V1.3WiFi模块，采用串口与MCU通信，内置TCP/IP协议栈，能够实现串口与WiFi之间的数据传输[9]。如果要实现单片机与手机APP的通信，必须在WiFi模块中下载GAgent固件库。GAgent主要作用是数据转发，是设备数据、机智云、应用端的数据交互桥梁。GAgent固件库下载完成后，该系统中主控制芯片STC15通过WiFi无线通信模块将承压式太阳能热水器相关参数和状态发送给基于机智云平台开发的手机APP，从而实现远程通信监控。同时，在机智云平台上可以查看历史和实时的设备交互数据。 3系统软件设计 3.1主程序与网络通信控制流程 对系统上电后，控制器开始工作。在主程序中，控制器首先进行初始化，完成后进行温度采集，并对采集的数据进行处理；随后，进行配网，实现主控制器与手机APP之间的网络通信；之后，进行信息的收发以及响应。当主控制器接收到控制命令时，控制单片机执行命令；当主控制器未接收到控制命令时，控制器继续保持信息收发状态。当主控制器接收到异常状态提醒时，控制单片机触发报警装置；当主控制器未接收到异常状态提醒时，控制器继续保持信息收发状态。主程序控制流程如图6所示。 图6主程序控制流程 完成配网后，进行上报协议和控制协议处理。协议处理完成后进行用户数据采集。获取用户区的上报型数据，用户调用相关接口可以完成设备数据的变化上报以及用户区数据到上报型数据的转换，并将上报数据发送给模组。完成后进入控制反馈，进行相应数据类型的转换，根据已生成的“控制型事件”进行相应事件处理。其中，网络通信控制流程如图7所示。 3.2控制加热子程序 在热水器加热功能开启过程中，当系统上电后，温度传感器会检测水箱温度，并将数据送至控制加热子程序。首先，对加热指令进行监听。当检测到的水箱温度小于用户设置的加热温度，同时检测加热按键按下，控制器发出加热信号，执行加热指令；当不符合加热条件时，一直处于监听加热指令状态。 然后，在执行加热指令时对停止加热指令进行监听。当检测到的水箱温度大于或等于用户设置的加热温度，执行停止加热指令；当检测到的水箱温度未达到用户设置的加热温度，继续执行加热指令。热水器的加热程序流程如图8所示。 图7网络通信控制流程 图8热水器加热程序流程 4远程通信的实现 4.1云平台配置 对于实现远程通信，机智云平台是数据交互的桥梁。因此，需要对机智云平台进行配置，创建出符合用户需求的手机APP。登录机智云官网，选择对应项创建新产品，填写设备产品基本信息。技术方案选择WiFi/移动网络方案；选择通信方式为WiFi；数据传输方式为定长。 产品创建成功后，机智云为该产品分配ProductKey和ProductSecret参数。ProductKey参数由开发者写入设备MCU，并告知WiFi模块，WiFi模块登录机智云后，机智云将会识别该ProductKey的产品。产品创建完成后，需要创建数据点。结合设备的功能需求，共配置了5个对应的数据点。 4.2程序设计 数据点创建完成后，自动生成MCUSDK代码包，对需要的程序进行移植。需要移植的程序主要有机智云协议层和工具层[10]。代码移植完成后，调用相应的API接口和添加相应的逻辑处理。移植好的程序还不能实现通信，需要根据实现的功能进行相关配置，包括串口配置、定时器配置、下行处理、上行处理和配置入网。 配置串口1实现日志打印，配置串口2实现数据的接收与发送，配置定时器1为毫秒级中断。上行处理：首先要完成传感器驱动开发，然后在Gizwits目录下的gizwits＿product.c文件userHandle（）函数中实现传感器数据采集，只需要将采集到的数值赋给对应用户区的设备状态结构体数据位。 下行处理：首先要完成传感器驱动开发，然后在Gizwits目录下的gizwits＿product.c文件中找到相应函数进行修改。在该控制系统中，只选用了两种模式即WIFI＿AIRLINK＿MODE和WIFI＿RESET＿MODE，配置按键，通过按键进入AirLink模式和实现模组复位功能。 5结语 本文基于STC15单片机设计了一款承压式太阳能热水器智能控制系统，以STC15作为核心板块，通过WiFi模块借助机智云物联网平台与手机APP建立连接，实现远程通信。采用DS18B20测量水温，使用继电器控制加热棒实现加热。利用数码管、LED灯、手机APP等作为人机交互界面，整体模块化设计优化了功能，简化了安装。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd2bab0de0a4c476cdbbaa2a84aad53/" rel="bookmark">
			局域网、广域网、互联网三者的区别以及应用领域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		局域网、广域网和互联网都是计算机网络的不同类型，它们的区别在于范围和连接方式不同。 局域网（LAN）是指在一个相对较小的地理范围内，例如一个房间、一个办公室、一栋楼、一个学校等，通过局域网技术将多台计算机连接起来，使得这些计算机之间可以直接通信和共享资源。局域网通常使用以太网技术，包括网卡、集线器、交换机等设备。局域网内的计算机通常使用私有的IP地址，例如 192.168.x.x。
广域网（WAN）是指跨越大的地理范围，例如国家、洲际等范围内的计算机网络。广域网通常使用传输控制协议/因特网协议（TCP/IP）作为通信协议，包括路由器、光纤等设备。广域网的连接方式多种多样，包括传统的电话拨号、电路交换、以及现代的数字化技术，例如数字用户线（DSL）、光纤接入等。
互联网（Internet）是指全球最大的计算机网络，由许多个局域网和广域网组成，利用TCP/IP协议进行通信。互联网连接了全球的计算机，使得它们可以相互通信和交换信息。互联网的发展给人们的生活和工作带来了巨大的变化，也极大地推动了信息技术的发展。
在实际应用中，局域网通常用于公司、学校、家庭等小范围的计算机网络环境，广域网则通常用于跨城市、跨国家的计算机网络，而互联网则是全球范围内的计算机网络。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62ff79109af3e46cb7f27976184bfde/" rel="bookmark">
			sudo apt-get update 失败 的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo apt-get update 失败 的解决 一 报错情况1 及我的解决办法1 报错情况2 解决办法 一 报错情况1 及我的解决办法 参考了：执行sudo apt-get update失败的解决方案
1 报错情况 我的报错情况如下(借用了别人的，我之前使用的Ubuntu默认源，下面的报错使用的清华源)。
错误提示： 忽略:1 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal InRelease 忽略:2 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-updates InRelease 忽略:3 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-backports InRelease 忽略:4 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-security InRelease 错误:5 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal Release Certificate verification failed: The certificate is NOT trusted. The certificate chain uses expired certificate. Could not handshake: Error in the certificate verification. [IP: 101.6.15.130 443] 错误:6 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-updates Release Certificate verification failed: The certificate is NOT trusted.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62ff79109af3e46cb7f27976184bfde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2bce9140e69775a239e2c507a97db39/" rel="bookmark">
			kafka k8s部署(Strimzi/kafka)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github 地址下载文件方便后续使用 wget https://github.com/strimzi/strimzi-kafka-operator/releases/download/0.33.2/strimzi-0.33.2.tar.gz tar -xzf strimzi-0.33.2.tar.gz 安装 strimzi-cluster-operator kubectl create ns kafka kubectl create -f 'https://strimzi.io/install/latest?namespace=kafka' -n kafka # 等待pod启动完成 kubectl get pods -n kafka 部署kafka cp strimzi-0.33.2/examples/kafka/kafka-persistent.yaml ./ # 根据需求更改 kafka-persistent.yaml 例如修改存储大小和使用nodeport端口 vim kafka-persistent.yaml ----------------------------------- ... spec: kafka: version: 3.4.0 replicas: 3 listeners: - name: external port: 9094 type: nodeport tls: false configuration: bootstrap: nodePort: 30091 brokers: - broker: 0 nodePort: 30092 - broker: 1 nodePort: 30093 - broker: 2 nodePort: 30094 - name: plain port: 9092 type: internal tls: false - name: tls port: 9093 type: internal tls: true .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2bce9140e69775a239e2c507a97db39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82b98e51296c91a7f114a485d3482261/" rel="bookmark">
			SpringBoot 整合 ChatGPT API 项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 整合 ChatGPT API 项目实战
一、准备工作
二、补全接口示例
三、申请API-KEY
四、JavaScript调用API
五、SpringBoot使用ChatGPT API
体验到了ChatGPT的强大之后，那么我们会想，如果我们想基于ChatGPT开发一个自己的聊天机器人，这个能搞定吗？
ChatGPT平台已经为技术提供了一个入口了，很简单的就是实现了。
一、准备工作 （1）已成功注册 OpenAI 的账号。
（2）创建 API KEY，这个 API KEY 是用于 HTTP 请求身份验证的，可以创建多个。注意这个创建之后需要马上复制好保存，关闭弹框之后就看不到了。
（3）官方 API 文档链接：
https://platform.openai.com/docs/api-reference/authentication
（4）注意 API 调用是收费的，但是 OpenAI 已经为我们免费提供了18美元的用量，足够大家放心使用。
二、补全接口示例 该接口功能较多，支持最常用的问答功能。
（1）请求方式，Post
（2）url：https://api.openai.com/v1/completions
（3）请求体 (json)。
{ "model": "text-davinci-003", "prompt": "Say this is a test", "max_tokens": 7, "temperature": 0, "top_p": 1, "n": 1, "stream": false } （4）接口文档
https://platform.openai.com/docs/api-reference/completions/create
请求参数解析：
字段说明model可选参数。语言模型，这里选择的是text-davinci-003prompt必选参数。即用户的输入。max_tokens可选参数，默认值为 16。最大分词数，会影响返回结果的长度。temperature可选参数，默认值为 1，取值 0-2。该值越大每次返回的结果越随机，即相似度越小。top_p可选参数，与temperature类似。n可选参数，默认值为 1。表示对每条prompt生成多少条结果。stream可选参数，默认值为false。表示是否回流部分结果。 三、申请API-KEY 访问地址：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82b98e51296c91a7f114a485d3482261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b17b29a124961c9e095a0324bc8145f/" rel="bookmark">
			短视频平台-小说推文（Lofter）推广任务详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​Lofter日结内测中，可能暂只对部分优质会员开放!
注意 Lofter 关键词7天未使用，可能会被下线。
Lofter 不再需要回填视频链接了。
接Lofter官方通知 关于近期部分博主反馈播放量高但搜索量很低的问题尤其是快手平台，我们做了代码、服务器、客户端等一些列排查后，排除了技术问题:
最后发现问题出现在应用商店，部分竞品通过买榜刷流量等恶劣手段在ios&amp;安卓应用商店偷取LOFTER流量，我们已经采取技术手段，本周内会解决掉这个问题!
这周建议大家的评论区引导关键词可以设置成「老福特」，暂时先不要用LOFTER」:
另外，建议博主的口令词在视频里和评论区引导可以更明显一点。
注意 【待发布】里面的关键词需要回填视频链接，否则影响订单。
4.19-5.19活动:
单价调为 8元/单
《Lofter推广书单》
飞书文档 https://uzhyprsxpa.feishu.cn/sheets/shtcnKs B5PV35rXmhy4waUyA8Rd
腾讯文档 https://docs.gg.com/sheet/DQWhicFp4Q3IN dUVn?tab=BB08J2
只能选择书单内的小说推广
1、关键词(关键词秒审) 1.1申请关键词操作流程
[推广】→【LOFTER】→【新增关键词]
关键词:3-7个字
书籍ID:复制书单里的文章ID;非常重要，为11位的数字，一定不能填错，不能与其他书籍混淆。
1.2注意事项
(1)关键词字数:3-7个字(不能超出范围):
(2)关键词不可涉黄、涉政，不可蹭已有流量词，不能涉及敏感职业信息，军、兵、警等，不能带标点、符号、字母，空格等:
(3)关键词具有唯一性，多人不能重复使用:
(4)关键词审核成功，且自己搜索后内容对应才可以作品发布;
1.3审核时间
LOFTER关键词 秒出结果周一~周日
2、 回填 2.1 说明
(1)回填的的是视频链接，不是文章链接;(2)回填的账号就是该视频链接所在的账号:(3)每个关键词只需要回填一次即可(4)发布当天晚上21:00点之前回填
2.2操作流程
找到【待发布】里面的关键词，按照要求填写:
回填完成后会自动到【已发布】状态，等待订单结算即可。
3 、订单 第二天晚上可查(22:00点之前);
4 、结算 单价7元，周结(每周末开始打款，预计2-3天内到账);
5、 特别注意 一定要选书单内的文章，文章ID一定不能填错。
关键词申请成功后，在视频发布之前，一定要去LOFTER app搜索一下，看是否可查到，且内容对应，查不到或者不一致的，则不要使用。
立即开始做任务吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee6e78d2b50afcf9b079ffc8718bf6b/" rel="bookmark">
			el-tree 全部展开和全部收起的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先直接说实现方法
&lt;el-tree ref="folderTreeRef" :data="treeData" :props="defaultProps" node-key="id" &gt; &lt;/el-tree&gt; const nodes = this.$refs.folderTreeRef.store._getAllNodes(); nodes.forEach(item=&gt;{ item.expanded = false }) 展开就把expanded赋值为true就可以。这就是实现方法
下面解释一下以及需要注意的点：
这个方法在官网文档中没有，但是我们可以在调试的时候看到在store的原型上有这个方法
！而使用此方法前必须设置 node-key 属性。
原因看下面
在注册节点的时候，当key为空时，会直接return出去。这个key就是我们设置的node-key的值，
如果没有设置 node-key，这会导致 nodesMap 没有值，而我们的 _getAllNodes 方法就是通过遍历nodesMap来实现的，所以必须设置node-key。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff9a41cdc3a1d1b45d3af4fcccb7e57/" rel="bookmark">
			yolov5将mAP@0.5指标换成mAP@0.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载yolov5代码地址：GitHub - ultralytics/yolov5: YOLOv5 🚀 in PyTorch &gt; ONNX &gt; CoreML &gt; TFLite
在用yolov5进行目标检测的时候感觉mAP@0.5的指标很苛刻，就是最后的结果值很低，想换一个指标看着好看一些（感觉就是训练好的同一个模型，想让修饰还看一些，汤药不换），所以想记录一下换的时候都改了哪些地方
先看Root/val.py文件
第163行： iouv = torch.linspace(0.5, 0.95, 10, device=device) 改为iouv = torch.linspace(0.1, 0.55, 10, device=device) 10表示的是10列，因为从10到55共每加5算一次，共10个数，10，15，20，25，30，35，40，45，50，55。
第191行： s = ('%22s' + '%11s' * 6) % ('Class', 'Images', 'Instances', 'P', 'R', 'mAP50', 'mAP50-95')
将50改为10，95改为55
s = ('%22s' + '%11s' * 6) % ('Class', 'Images', 'Instances', 'P', 'R', 'mAP10', 'mAP10-55')
第192行：tp, fp, p, r, f1, mp, mr, map50, ap50, map = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ff9a41cdc3a1d1b45d3af4fcccb7e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eff33d658f10ec0ae5dfeea2366a44e/" rel="bookmark">
			SpringMVC笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、SpringMVC简介1、什么是MVC2、什么是SpringMVC3、SpringMVC的特点 二、HelloWorld1、开发环境2、创建maven工程a&gt;添加web模块b&gt;打包方式：warc&gt;引入依赖 3、配置web.xmla&gt;默认配置方式b&gt;扩展配置方式 4、创建请求控制器5、创建springMVC的配置文件6、测试HelloWorlda&gt;实现对首页的访问b&gt;通过超链接跳转到指定页面 7、总结 三、@RequestMapping注解1、@RequestMapping注解的功能2、@RequestMapping注解的位置3、@RequestMapping注解的value属性4、@RequestMapping注解的method属性5、@RequestMapping注解的params属性（了解）6、@RequestMapping注解的headers属性（了解）7、SpringMVC支持ant风格的路径8、SpringMVC支持路径中的占位符（重点） 四、SpringMVC获取请求参数1、通过ServletAPI获取2、通过控制器方法的形参获取请求参数3、@RequestParam4、@RequestHeader5、@CookieValue6、通过POJO获取请求参数7、解决获取请求参数的乱码问题 五、域对象共享数据1、使用ServletAPI向request域对象共享数据2、使用ModelAndView向request域对象共享数据3、使用Model向request域对象共享数据4、使用map向request域对象共享数据5、使用ModelMap向request域对象共享数据6、Model、ModelMap、Map的关系7、向session域共享数据8、向application域共享数据 六、SpringMVC的视图1、ThymeleafView2、转发视图3、重定向视图4、视图控制器view-controller 七、RESTful1、RESTful简介a&gt;资源b&gt;资源的表述c&gt;状态转移 2、RESTful的实现3、HiddenHttpMethodFilter 八、RESTful案例1、准备工作2、功能清单3、具体功能：访问首页a&gt;配置view-controllerb&gt;创建页面 4、具体功能：查询所有员工数据a&gt;控制器方法b&gt;创建employee_list.html 5、具体功能：删除a&gt;创建处理delete请求方式的表单b&gt;删除超链接绑定点击事件c&gt;控制器方法 6、具体功能：跳转到添加数据页面a&gt;配置view-controllerb&gt;创建employee_add.html 7、具体功能：执行保存a&gt;控制器方法 8、具体功能：跳转到更新数据页面a&gt;修改超链接b&gt;控制器方法c&gt;创建employee_update.html 9、具体功能：执行更新a&gt;控制器方法 八、HttpMessageConverter1、@RequestBody2、RequestEntity3、@ResponseBody4、SpringMVC处理json5、SpringMVC处理ajax6、@RestController注解7、ResponseEntity 九、文件上传和下载1、文件下载2、文件上传 十、拦截器1、拦截器的配置2、拦截器的三个抽象方法3、多个拦截器的执行顺序 十一、异常处理器1、基于配置的异常处理2、基于注解的异常处理 十二、注解配置SpringMVC1、创建初始化类，代替web.xml2、创建SpringConfig配置类，代替spring的配置文件3、创建WebConfig配置类，代替SpringMVC的配置文件4、测试功能 十三、SpringMVC执行流程1、SpringMVC常用组件2、DispatcherServlet初始化过程a&gt;初始化WebApplicationContextb&gt;创建WebApplicationContextc&gt;DispatcherServlet初始化策略 3、DispatcherServlet调用组件处理请求a&gt;processRequest()b&gt;doService()c&gt;doDispatch()d&gt;processDispatchResult() 4、SpringMVC的执行流程 一、SpringMVC简介 1、什么是MVC MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分
M：Model，模型层，指工程中的JavaBean，作用是处理数据
JavaBean分为两类：
一类称为实体类Bean：专门存储业务数据的，如 Student、User 等一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据
C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器
MVC的工作流程：
用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器
2、什么是SpringMVC SpringMVC是Spring的一个后续产品，是Spring的一个子项目
SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。
注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet
3、SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案代码清新简洁，大幅度提升开发效率内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可性能卓著，尤其适合现代大型、超大型互联网项目要求 二、HelloWorld 1、开发环境 IDE：idea 2019.2
构建工具：maven3.5.4
服务器：tomcat7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eff33d658f10ec0ae5dfeea2366a44e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea3f1941e803d083de88eb11a74651b7/" rel="bookmark">
			机器学习实战：Python基于LDA线性判别模型进行分类预测（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言1.1 线性判别模型的介绍1.2 线性判别模型的应用 2 demo数据演示2.1 导入函数2.2 训练模型2.3 预测模型 3 LDA手写数字数据演示3.1 导入函数3.2 导入数据3.3 输出图像3.4 建立模型3.5 预测模型 4 讨论 1 前言 1.1 线性判别模型的介绍 线性判别模型（Linear Discriminant Analysis，LDA）是一种经典的监督学习算法，它旨在通过学习输入特征和它们所属类别之间的线性关系来进行分类任务。线性判别模型通常可以被看作是一种分类器，可以用于二元分类和多元分类问题。
线性判别模型的主要思想是将输入特征空间中的样本投影到一条直线或者一个超平面上，从而实现对样本的分类。这个超平面的选择是通过最小化类内距离和最大化类间距离来完成的。类内距离指的是同一类别样本之间的距离，类间距离则指不同类别样本之间的距离。通过最小化类内距离和最大化类间距离，线性判别模型能够更好地区分不同类别的样本。
优点：
线性判别模型是一种经典的监督学习算法，具有较高的可解释性和可理解性，能够提供直观的结果。
线性判别模型具有较快的训练速度和较低的存储成本，适用于处理大型数据集。
线性判别模型能够在高维数据中很好地工作，并且在特征选择方面具有很好的性能。
缺点：
线性判别模型是一种线性模型，对于非线性分类问题的表现可能较差。
线性判别模型对于噪声数据和异常值比较敏感，容易造成误分类。
线性判别模型的分类效果受特征之间相关性的影响，如果存在高度相关的特征，分类效果可能较差。
1.2 线性判别模型的应用 线性判别模型广泛应用于数据分类、降维和特征提取等领域，在实际应用中有很多场景，例如：
信用评分：根据用户的个人信息和历史数据，对其信用评分进行分类，以决定是否批准贷款。
医学诊断：根据患者的生理指标和症状，将其分为健康和患病两类，以进行诊断和治疗。
人脸识别：根据人脸图像的特征向量，将其分为不同的人脸类别，以实现人脸识别和身份验证。
情感分析：根据文本内容中的关键词和情感指标，将其分为正面、负面和中性等不同的情感类别。
图像分类：根据图像的特征向量，将其分为不同的图像类别，以进行图像识别和分类等。
在生信领域还是常用于基因表达数据分析、蛋白结构预测、biomarker鉴定和药物设计，LDA可以用于分析分子结构和描述化学性质，从而优化药物设计和发现。
2 demo数据演示 2.1 导入函数 import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from sklearn.discriminant_analysis import LinearDiscriminantAnalysis from sklearn.datasets import make_classification 2.2 训练模型 # 制作四个类别的数据，每个类别100个样本 X, y = make_classification(n_samples=1000, n_features=3, n_redundant=0, n_classes=4, n_informative=2, n_clusters_per_class=1, class_sep=3, random_state=10) # 可视化分布 fig = plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea3f1941e803d083de88eb11a74651b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/385a95e0102deb4f24970416d792c3bc/" rel="bookmark">
			深元AI盒子在矿山安全生产中实现皮带跑偏、异物、煤流量、大块煤等识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：随着技术的发展，矿山安全生产已经从传统的人工监测逐步转向现代化智能化。本文旨在探讨矿山安全生产AI盒子在皮带跑偏、异物、煤流量和大块煤之外的功能，以期进一步提高矿山生产的安全性和效率。
正文：
一、引言
矿山安全生产一直是企业关注的重要问题，随着科技的不断进步，以AI为核心的智能监控已经在矿山安全生产领域取得了显著的成果。本文将分析深元AI盒子在矿山安全生产中的重要作用，为矿山安全生产提供更多的技术支持。
二、AI盒子的其他功能
人员识别：深元AI盒子可以自动识别单人经过、多人顺序经过、多人并行经过、多人徘徊等场景下的人员，生成带有标记框的证据视频，并自动统计视频中的人数。
货运车辆识别：深元AI盒子可以自动识别货运车辆，生成带有标记框的证据视频，并自动统计视频中的车辆数。
空岗识别：当识别到室内空岗场景持续时长达到3分钟时，深元AI盒子会触发事件并生成证据视频。
人员未戴安全帽识别：系统自动检测人员是否佩戴安全帽，当人员未戴安全帽时产生抓拍事件，可以选项配置人脸识别，当能获得人脸的情况下，识别是谁未戴安全帽。
人员未穿工服识别：系统自动检测人员是否穿工服，当人员未穿工服时产生抓拍事件，可以选项配置人脸识别，当能获得人脸的情况下，识别是谁未穿工服。
摄像头遮挡识别：当识别到摄像头被遮挡、挪动角度时，深元AI盒子会触发事件并生成带标记框的证据视频。
三、事件查询和实时告警
为了方便用户对接和开发，深元AI盒子提供了事件查询功能和实时告警功能。以下是功能介绍：
设备在线状态查询：用户可以查询摄像头是否在线，了解设备的实时状态。
抓拍记录查询：API接口支持查询设备抓拍历史记录，便于用户了解设备运行情况和异常事件。
实时事件告警：支持实时事件告警，用户可以实时了解设备状态和异常情况。
通过这些功能，用户可以更方便地集成和使用深元AI盒子，进一步提高矿山安全生产的智能化水平。
四、结论
深元AI盒子在矿山安全生产中不仅具有识别皮带跑偏、异物、煤流量和大块煤等功能，还具有人员识别、货运车辆识别、空岗识别、人员未戴安全帽识别、人员未穿工服识别、摄像头遮挡识别等功能。此外，AI盒子还支持二次开发功能，方便用户对接和开发。
通过使用深元AI盒子，企业可以有效提高矿山的智能化水平，保障安全生产，降低生产和管理成本，增强企业竞争力。随着AI技术的不断发展，深元AI盒子将会发挥越来越重要的作用，为矿山安全生产提供更多的技术支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461285636db697bb848e37f08601742a/" rel="bookmark">
			Filezilla连接服务器报错，认证失败,严重错误,无法连接到服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改
vi /etc/ssh/sshd_config
修改如下：密码登陆
PermitRootLogin yes
StrictModes no
PasswordAuthentication yes
重启 service sshd restart
出现 edirecting to /bin/systemctl restart sshd.service 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26fddf7e008824c71eecd82ddf55a406/" rel="bookmark">
			JavaScript的异步加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js的异步加载 JavaScript是单线程执行，即代码会一行一行自上而下执行，正常来讲，浏览器是同步加载js代码的，但是一旦遇到网速不好，或者加载的js代码文件过大，容易造成页面阻塞，整个网站将等待js加载而不进行后续的渲染工作，影响交互体验。
如：HTML元素按照其页面出现顺序渲染，此时js获取DOM对象，若DOM结构还没有加载完成，就会获取到空对象。
&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript"&gt; const ul = document.querySelector('ul') console.log(ul) // null const li = document.createElement('li') li.innerHTML = '123' ul.appendChild(li) // Uncaught TypeError: Cannot read properties of null (reading 'appendChild') &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/body&gt; 这是因为js是一行一行代码执行，js加载执行在DOM结构之前，故为null。解决：通常把&lt;script&gt;放在后面DOM结构后面。
js异步加载就是等页面加载完成之后再加载js文件。有助于提高页面故加载速度。
js异步加载的三种方式 ①defer异步加载 特点：需要等到dom文档全部解析完才会被执行，ie特有
&lt;script type = 'text/javascript' src = tools.js' defer = 'defer'&gt;&lt;/script&gt; &lt;script type = 'text/javascript' src = tools.js' defer &gt;&lt;/script&gt;	②async异步加载 特点：加载完就执行，async只能加载外部脚本，不能把js写在script标签里面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26fddf7e008824c71eecd82ddf55a406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4259924a248d211278a526a0b1cf7d7e/" rel="bookmark">
			三更博客项目后台管理系统的BUG大集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题引入分析问题一、系统管理1. 用户管理2. 角色管理 二、内容管理1. 文章管理（还有写博客）2. 分类管理 解决问题总结 问题引入 我在做三更的博客后台的时候，出现了许多的BUG，通过这篇文章来记录这些BUG，即是为了提醒自己以后不要犯这样的错，同时如果有小伙伴也在做这个项目时，如果也出现了BUG，并且还未找到解决方案时，可以看一看。
下面我来一一列举后台管理系统中出现的一些BUG：
1.关于securiry中UserDetailService实现类问题。
这是怎么被发现的呢？是因为我在做后台的时候，其实已经是写完了这个后台的用户名的认证工作了，但是呢，因为此时，其实我的后台的页面其实看不到效果的，所以我现在就去看了前台的效果，当我登录的时候，就直接出现了栈溢出错误，后面我查看了我的代码，发现缺少UserDetailsService接口的实现类。
2.一登陆就退出进不去的问题
3.文章置顶问题
下面的问题可能大家不会遇到，只是由于个人的疏忽而导致的
一、系统管理
用户管理
1.1 对用户信息进行修改，发现电话号码并未修改
1.2 点击用户状态改变按钮，不能正确的改变用户的状态角色管理
2.1 角色管理中的修改中的菜单权限展现出现问题 二、内容管理
文章管理（还有写博客）
1.1 缩略图以及文中图片无法上传分类管理
2.1 点击切换状态前端直接失效，只是一个假按钮 分析问题 对于第一个问题我将详细说明：
其实就是因为我缺少了UserDetailService实现类导致用户名的校验就走的security内部的校验流程，就会出现栈溢出问题。这就是我的问题原因；另外我想说明的是一个项目中不能同时出现两个或者更多UserDetailService的实现类，如果有同样会栈溢出，这个经过测试就知道了，当然如果是不同的模块那还是没问题的，就好像我的blog与admin同时有一个也是没有问题的。
2.一登陆就退出进不去的问题
这个我一直迷惑了很久，后来查看评论才有了思路的，up主说这一般是由于后端接口返回的数据出了问题，该有的字段没有，或者是字段名出现了问题啥的，后来我仔细检查了确实有这个问题，因为登录一进去就是访问getInfo接口，那个用户信息本应该字段名应该是user的，但是我的接口响应的是userInfo，除此之外，getRouters接口也是这样，该返回children我却返回了child，另外并不都是我的问题，前端那边也有问题，前端的push方法名写错了
在这个文件夹里面，具体哪个push我忘记了，因为我已经改了，并且也没有之前的文件了，但是在下图中的文件里面：
3.这个就是前端按钮值映射与数据库中的对应值不符合
前端选择置顶，但是传递给后端却是0，而其实数据库中0是不置顶的，前端代码在这里，同样也是更改之后的：
一、系统管理 1. 用户管理 1.1 对用户信息进行修改，发现电话号码并未修改
这是我的问题，没有为电话号码字段的更新字段，也就是只set了其它，没有set电话号码
1.2 点击用户状态改变按钮，不能正确的改变用户的状态
这个我是通过byId进行修改的，这样不对，因为我只是修改其中一个状态属性，就通过构造条件，设置setStatus即可
2. 角色管理 2.1 角色管理中的修改中的菜单权限展现出现问题
后端的数据返回错误，没有返回正确的数据，是需要所有的菜单Id的，并不是只返回角色对应的菜单Id的，并且注意这里由于超级管理员没有数据，所以不能直接联查，得特判
二、内容管理 1. 文章管理（还有写博客） 1.1 缩略图以及文中图片无法上传
在application文件中缺少了oss的配置
2. 分类管理 2.1 点击切换状态前端直接失效，只是一个假按钮
由于前端还未实现这个功能，所以得写完前端逻辑与后端逻辑（前端逻辑参考用户管理的切换状态按钮）
解决问题 这里只给出点击切换状态前端直接失效，只是一个假按钮的解决方案，其它问题解决方案在分析中已基本给出；
下面三步：
总结 确实来说，我有点马虎了。
首先是没有按照文档所给的前端接口响应数据的规范，导致一些不必要的麻烦出现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4259924a248d211278a526a0b1cf7d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be90c89b1e5c3e7060c8ec362a86d8e/" rel="bookmark">
			Go 语言读取文件的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这篇文章将讨论如何在 Golang 中读取文件。我们将使用以下包来处理这些文件。
os 包提供了一个独立于平台的接口来执行操作级操作。IOutil 软件包提供了易于使用的实用程序函数来处理文件，而无需了解太多内部实现。bufio 包实现了缓冲 IO，这有助于我们提高输入和输出操作的性能和吞吐量。log 包实现一个简单的日志记录包。我们将在整个程序中使用它。我们将在程序中使用日志包的 Fatal() 函数。 整个文件读取 我们可以很容易地一次性读取整个文件并将其存储在一个变量中。但请记住，我们不应该对大文件这样做。我们将使用ioutil.ReadFile() 函数来读取文件并将文件的内容存储在一个变量中。
首先，让我们在我们程序所在的同一目录下存储一个文件。因此，我们的文件夹结构将是下面这样的。
___ | |_ _ _ _ ilovego.txt | |_ _ _ _ main.go 我们在 main.go 函数中写入如下的内容：
package main import ( "fmt" "io/ioutil" "log" ) func main() { content, err := ioutil.ReadFile("ilovego.txt") if err != nil { log.Fatal(err) } fmt.Println(string(content)) } 但首先，让我们讨论一下 ReadFile() 函数的情况：
定义：方法声明 func ReadFile(filename string) ([]byte, error)功能：读取路径被传入函数参数的文件，并返回文件的内容。在内部使用 os.ReadFile(fileName) 方法返回：在一个字节数组中返回文件的内容和错误。一个成功的调用将返回 err == nil 内部 ReadFile 函数实现如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9be90c89b1e5c3e7060c8ec362a86d8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204894dc3d31254702aed63e3046fbcc/" rel="bookmark">
			PostMan笔记（二）发送请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 发送请求功能介绍 Postman是一款流行的API开发工具，它可以让开发人员更方便地测试、调试和使用API。其中，发送请求功能是Postman最为重要和基础的功能之一。
在Postman中，发送请求功能主要包括以下几个步骤：
选择请求方法：Postman支持多种HTTP请求方法，包括GET、POST、PUT、DELETE等。在发送请求前，需要选择相应的请求方法。 添加请求URL：在Postman的地址栏中添加请求URL，包括协议、域名、端口、路径等信息。可以使用环境变量、全局变量、预请求脚本等功能来管理请求URL。
添加请求头部：HTTP请求头部包含请求信息的附加属性，比如Content-Type、Authorization、User-Agent等。在Postman中，可以通过添加请求头部来自定义请求信息。
添加请求参数：HTTP请求参数包含请求数据的键值对，可以是查询参数、表单数据、JSON数据等。在Postman中，可以通过Params、Body、Authorization等标签页来添加请求参数。
发送请求：在完成上述步骤后，点击Send按钮即可发送请求。Postman会在请求历史中记录请求的结果和响应信息，方便开发人员查看和分析。
需要注意的是，Postman还支持多种高级功能，比如断言、变量、测试脚本、Mock等，可以让开发人员更加高效地进行API开发和测试。
2. GET 请求 2.1 传参的方式 Postman可以通过以下方式进行GET请求的传参：
2.1.1 查询参数（Query Parameters） 这是GET请求中最常用的传参方式。可以在请求URL的末尾添加查询参数，例如：http://example.com/api/users?name=John&amp;age=30。在Postman中，可以在请求的URL栏中直接添加查询参数，或者使用Params选项卡添加。
可以使用@RequestParam注解来接收查询参数，例如：
@GetMapping("/api/users") public List&lt;User&gt; getUsers(@RequestParam String name, @RequestParam int age) { // 根据查询参数查询用户 } 2.1.2 路径参数（Path Parameters） 有些API设计会要求在URL中包含动态参数，例如：http://example.com/api/users/123，其中的“123”是用户ID。在Postman中，可以在请求的URL中添加路径参数，例如：http://example.com/api/users/{{userId}}，其中“{{userId}}”是变量名，可以在请求前设置。
路径参数（Path Parameters）：可以使用@PathVariable注解来接收路径参数，例如：
@GetMapping("/api/users/{userId}") public User getUserById(@PathVariable Long userId) { // 根据用户ID查询用户 } 2.1.3 请求体参数（Request Body Parameters） 虽然GET请求通常不包含请求体，但有些API可能要求在请求体中包含参数。在Postman中，可以使用Body选项卡添加请求体，并在其中包含需要的参数。
@PostMapping("/api/users") public User addUser(@RequestBody User user) { // 添加新用户 } 总之，查询参数和路径参数是最常见的GET请求传参方式，而请求体参数则不太常用。在使用Postman发送GET请求时，应根据API的设计选择适当的传参方式。
2.2 不同的参数类型 在Postman中，可以使用以下方式传递GET请求中的不同类型的参数值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/204894dc3d31254702aed63e3046fbcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1babc286aba6d61419dcba63a5d47822/" rel="bookmark">
			在Ubuntu20.10中搭建TFTP服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TFTP（Trivial File Transfer Protocol）是用来下载远程文件的最简单的网络协议，它基于UDP协议而实现.
一、安装：
sudo apt-get install tftp-hpa tftpd-hpa tftp-hpa 为客户端，tftpd-hpa 为服务端。
二、配置：
修改tftpd-hpa相应的配置文件
sudo vi /etc/default/tftpd-hpa
原始的内容如下：
#/etc/default/tftpd-hpa TFTP_USERNAME="tftp" TFTP_DIRECTORY="/svr/tftp" TFTP_ADDRESS=":69" TFTP_OPTIONS="--secure" 修改后：
# /etc/default/tftpd-hpa TFTP_USERNAME="tftp" TFTP_DIRECTORY="/svr/tftp" TFTP_ADDRESS=":69" TFTP_OPTIONS="-l -c -s" 说明：
TFTP_USERNAME：tftp帐号，
TFTP_DIRECTORY：tftp根目录，
TFTP_ADDRESS：地址与端口号，
TFTP_OPTIONS：启动参数，(可通过命令 man tftpd,查看各种参数含义)
-l：以standalone/listen模式启动TFTP服务（--listen），不用安装网络守护进程服务程序xinetd。
-c：可上传创建新文件（--create）。默认情况下，TFTP只允许覆盖原有文件，不能创建新文件。
-s：改变TFTP启动的根目录(--secure)。为了安全性和兼容性，使用一些引导rom，很难在请求中包含目录名。
三、修改TFTP根目录（）：
如果没有则建立TFTP目录 /var/tftp，以供上传和下载。修改目录所有者；设定该目录的权限，一般就将其权限设置为最高，为所有用户组都添加所有权限（读+写+执行=4+2+1=7）：
$ sudo chown tftp:tftp /srv/tftp
sudo mkdir /var/tftp
sudo chmod 777 tftp
四、重启tftpd-hpa服务：
sudo service tftpd-hpa restart
五、查看TFTP服务状态
$ ps aux|grep tftp root 5070 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1babc286aba6d61419dcba63a5d47822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c851816a3826701ecff82055ad047371/" rel="bookmark">
			生成扩散模型收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首推https://spaces.ac.cn, 为方便本人查看学习, 特意总结关于扩散模型的部分如下:
https://spaces.ac.cn/archives/9119https://spaces.ac.cn/archives/9152https://spaces.ac.cn/archives/9164https://spaces.ac.cn/archives/9181https://spaces.ac.cn/archives/9209https://spaces.ac.cn/archives/9228https://spaces.ac.cn/archives/9245https://spaces.ac.cn/archives/9246https://spaces.ac.cn/archives/9257https://spaces.ac.cn/archives/9262https://spaces.ac.cn/archives/9271https://spaces.ac.cn/archives/9280https://spaces.ac.cn/archives/9305https://spaces.ac.cn/archives/9370https://spaces.ac.cn/archives/9379https://spaces.ac.cn/archives/9467https://spaces.ac.cn/archives/9497https://spaces.ac.cn/archives/9509 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f950aec993cb0557af8a67ee0d832704/" rel="bookmark">
			yum查看可用的软件包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 显示系统中可用的软件包及其版本：
yum list available --showduplicates | grep 'bash-completion' 在yum软件包管理器中搜索能够提供"tree"命令的软件包，并列出这些软件包的名称和版本信息：
yum provides tree 启用 EPEL 存储库：
yum install epel-release 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5098499975069db3906cc190435013b/" rel="bookmark">
			【头歌】HBase综合测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一关：HBase-shell命令 任务描述
使用 HBase shell 命令创建表： exam_tb1 ，向表中添加数据，表的数据与结构如下：
相关知识
略
编程要求
根据右侧窗口命令行内的提示，在 Begin - End 区域内进行命令行语句补充。
测试说明
本关需要你在命令行中启动 hbase ，并使用 hbase shell 操作命令行，操作完之后点击测评即可，平台会使用脚本通过表名获取你创建的表,并输出其中数据。
预期输出：
row-1 class_info:class_id 201801 class_info:class_name software user_info:age 32 user_info:name jack row-2 class_info:class_id 201802 class_info:class_name hardware user_info:age 28 user_info:name rose 开始你的任务吧，祝你成功！
代码如下：
在命令行依次输入以下命令： start-hbase.sh hbase shell create 'exam_tb1', {NAME=&gt;'user_info'},{NAME=&gt;'class_info'} put 'exam_tb1','row-1','user_info:name','jack' put 'exam_tb1','row-1','user_info:age','32' put 'exam_tb1','row-1','class_info:class_name','software' put 'exam_tb1','row-1','class_info:class_id','201801' put 'exam_tb1','row-2','user_info:name','rose' put 'exam_tb1','row-2','user_info:age','28' put 'exam_tb1','row-2','class_info:class_name','hardware' put 'exam_tb1','row-2','class_info:class_id','201802' 第2关：HBase Java API 任务描述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5098499975069db3906cc190435013b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e86896ecdb6ad1466c5928396cbde52/" rel="bookmark">
			java毕业设计——基于JSP&#43;mysql的论文格式化系统设计与实现（毕业论文&#43;程序源码）——论文格式化系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于JSP+mysql的论文格式化系统设计与实现（毕业论文+程序源码） 大家好，今天给大家介绍基于JSP+mysql的论文格式化系统设计与实现，文章末尾附有本毕业设计的论文和源码下载地址哦。需要下载开题报告PPT模板及论文答辩PPT模板等的小伙伴，可以进入我的博客主页查看左侧最下面栏目中的自助下载方法哦
文章目录：
基于JSP+mysql的论文格式化系统设计与实现（毕业论文+程序源码）1、项目简介2、资源详情3、关键词4、毕设简介5、资源下载 1、项目简介 论文的格式修改是一件很麻烦的事情，一篇论文在定稿以前为了让格式达到标准，需要修改很多次，浪费了大量时间。本系统的设计初衷就是为了解决论文书写格式的规范化，方便学者论文格式的自动生成。
本系统是基于Java平台的Web应用程序。采用JSP作为后台开发语言，HTML和JavaScript作为前台开发语言，MYSQL5.0作为后台数据库,系统具有稳定性高、可移植性强等特点。
本系统中文档数据的传输和存储均使用XML形式，以XML作为数据的中间状态，便于以后进行系统的扩展。完成了论文的格式化，生成格式化后的word文件和PDF文件，并提供给用户进行下载。
本系统设计过程中使用了当前比较流行的技术，比如使用AJAX技术来进行注册验证，系统架构使用B/S模式进行设计。
2、资源详情 项目难度：中等难度
适用场景：相关题目的毕业设计
配套论文字数：9395个字31页
包含内容：全套源码+配整论文
3、关键词 格式化；移植性；数据库 4、毕设简介 提示：以下为毕业论文的简略介绍，项目完整源码及完整毕业论文下载地址见文末。
1 引言
1.1 课题背景
在人们繁忙的工作环境中，很多资料文件都要形成规范化的文档便于分类和存放，信息化的社会已经将以前手工抄写文档全部用电脑办公平台提供的统一的文档编辑软件所取代，当然所编写的文档的格式也是统一化的，包括文档中内容的字体，字号，标记，页码等等都是统一的。比如美国微软公司的word文档格式，这种格式已经成为了世界的一种标准，全世界通用，再比如Adobe公司的PDF文档格式，也是一种世界标准，是人们常用的一种文档格式。然而在日常的办公中，人们需要在文档编辑软件中编辑文档，需要花费大量的时间和精力来编辑文档的格式，比如字体，字号等等，对于同一类的文档来说，格式都是规范化好了的，但是文档编辑器不可能提供每一个规范好了的模板，因为各个地区或者企业他都有自己的规范，人们需要自己去编辑，这样话就降低了办公的效率，对于个人和企业来说都是在浪费时间，提高了成本。于是聪明的人开始想办法解决这个问题，新的软件由此产生了，涌现出了很多的PDF、 word文档的转换软件，他们很强大，不仅可以将PDF转换为word,也可以将word转换成PDF格式，有的也可以转换其他格式的文档，比如将HTML文档转化成PDF文档。
1.2 国内外研究现状
在国外很早就开始进行文档自动化的研究了，但是都是进行底层的文档生成工作，都是提供一个底层平台，用户使用平台提供的API，基于自己的特定目标进行二次开发。很多公司都是使用开源的第三方包，在遵守开源许可证的基础上进行产品开发。
1.3 本课题研究的意义
考虑到高等学府中教师，学生也要写论文，而且所写的论文要保存为特定格式的文档，保证论文的规范化，为此，我们设计了一套系统专门提供给毕业生将论文转化为规范的格式，省去大量的论文编辑时间，提高论文发表的效率，降低论文修改的频率，给同学们带来巨大的方便。我们将系统定位于B/S模式，主要考虑到系统易用性，客户机只需要安装了IE浏览器就可以通过访问网站的形式使用论文格式化系统，只是本系统一大优势。
1.4 本课题的研究方法
通过对业界使用的各种文档转换技术进行比较分析，找到最适合本课题的技术，然后使用选择的技术构建本系统。
2 论文格式化系统总体设计
2.1 论文格式化系统的需求分析
2.1.1 功能需求
①支持用户注册
因为用户需要将文档内容保存在服务器上，所以必须实现用户的注册功能。用户需要保存的信息包括用户名、呢称、密码、性别、电子邮件地址、省份、城市、注册时间，用户信息将保存在数据库中。
②支持用户登录
用户登录以后才能进行文档的上传以及转换等操作，这就要求保持会话信息。
③支持用户取回记录
用户登录以后，可以将服务器上保存的数据取下来，进行再次修改。
④支持用户上传记录
用户第一次录入数据，或者是用户将服务器上取回的数据进行修改以后，可以将数据上传至服务器，并且在数据库中添加记录的文件名路径。
⑤支持用户转换成word文档
用户通过页面的向服务器提交转换成word文档的请求，服务器接受到请求以后，将文档转换成word文档，然后再传送给客户端，供用户下载使用。
⑥支持用户转换成PDF文档
用户通过页面的向服务器提交转换成PDF文档的请求，服务器接受到请求以后，将文档转换成PDF文档，然后再传送给客户端，供用户下载使用。
⑦支持可配置性，便于移植
模板的可配置性：针对具体的应用场景，通过修改模板文件，就可以生成合乎用户要求的文档。
环境的可配置性：数据库的用户名、密码，以及模板文件的存放路径，用户数据的存放路径，都应该通过配置文件实现。
2.1.2 性能需求
①一个用户不能看到其他用户的记录。
②充分考虑易用性和实用性。
③软件应该以B/S架构，界面简单易用。
2.2 论文格式化系统选型
对系统设计语言、后台数据库的选择直接影响到系统在各种平台上运行时性能的好坏，对日后系统性能的扩展具有决定性的作用。因此，论文格式化系统在设计初期做了详细的系统选型。
2.2.1 设计语言的选择
1、Java Server Page概述
JSP(JAVA Server Page)是由Sun公司于1999年6月推出的新技术，是基于Java Servlet以及整个JAVA体系的Web开发技术，能够实现跨平台和兼容各种Web服务器产品，而且还能够把强大的　Java服务器应用技术（Server-side Java Technology）有机的融合到HTML网页中去。它是结合markup（HTML 或XML）和JAVA代码来处理的一种动态页面。每一页第一次被调用时，通过JSP引擎自动被编译成Servlet，然后被执行，以后每次调用时，执行编译过的Servlet。JSP提供了多种方式访问Java class、Servlet、Applets和Web Server，因此，Web应用的功能可以分成多个明确定义功用接口的组件，通过JSP将它们结合在一起。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e86896ecdb6ad1466c5928396cbde52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/165e04843b9c19f34a10291d9da9446d/" rel="bookmark">
			Git：Ubuntu下安装及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在Ubuntu下安装git：
sudo apt install git
2.生成ssh key
执行:ll ~，查看用户目录，如果没有.ssh目录，说明还没有ssh key，需要通过如下命令进行生成：
ssh-keygen -t rsa -C "account_mail"
一路回车即可
3.查看~/.ssh/id_rsa.pub文件内容，并将其添加到github -&gt; settings -&gt; SSH and GPG keys
4.配置git
git config --global user.name "user_name"
git config --global user.email "mail"
配置完成后可以通过命令进行查看和确认：
git config --global --list
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6d8211908334855651709217b95770d/" rel="bookmark">
			【头歌】共享单车之数据存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：获取工作簿中的数据 任务描述 本关任务：获取data.xls文件中的数据。
相关知识 获取工作簿中的信息，我们可以使用Java POI（POI是一个提供API给Java程序对Microsoft Office格式档案读和写的功能）提供的Workbook类来操作。
为了完成本关任务，你需要掌握：如何获取Wookbook的数据。
编程要求 在右侧编辑器 Begin-End 中补充代码，获取 data.xls 文件中的数据，具体获取以下数据并将结果打印： trip_id 、开始时间、结束经度、车辆 id 。
package com.educoder.savedata; import java.io.InputStream; import java.text.DecimalFormat; import org.apache.commons.lang3.time.FastDateFormat; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import org.apache.poi.ss.usermodel.WorkbookFactory; public class SaveWookbook { public static void main(String[] args) throws Exception { /********** Begin **********/ //1.通过类加载器获取本地文件并新建一个工作簿 InputStream resourceAsStream = SaveData.class.getClassLoader().getResourceAsStream("data.xls"); Workbook workbook = WorkbookFactory.create(resourceAsStream); //2.拿到工作簿中第一个Sheet Sheet sheet = workbook.getSheetAt(0); //3.获取当前Sheet中的行数 int rows = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6d8211908334855651709217b95770d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78af4bf6c0b59952e2be97c5bf67022b/" rel="bookmark">
			Web安全之文件上传漏洞详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件上传漏洞定义 文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。
二、上传漏洞危害 1.上传文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行。
2.上传文件是病毒或者木马时，主要用于诱骗用户或者管理员下载执行或者直接自动运行；
3.上传文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为(其他通过类似方式控制策略文件的情况类似);
4.上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行。
5.上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。
除此之外，还有一些不常见的利用方法，比如将上传文件作为一个入口，溢出服务器的后台处理程序，如图片解析模块;或者上传一个合法的文本文件，其内容包含了PHP脚本，再通过"本地文件包含漏洞(Local File Include)"执行此脚本;等等。
三、上传漏洞满足条件 首先，上传的文件能够被Web容器解释执行。所以文件上传后所在的目录要是Web容器所覆盖到的路径。
其次，用户能够从Web上访问这个文件。如果文件上传了，但用户无法通过Web访问，或者无法得到Web容器解释这个脚本，那么也不能称之为漏洞。
最后，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。
四、上传漏洞产生的原因 一些web应用程序中允许上传图片，文本或者其他资源到指定的位置，文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中，再通过url去访问以执行代码.
造成文件上传漏洞的原因是:
1.服务器配置不当
2.开源编辑器上传漏洞
3.本地文件上传限制被绕过
4.过滤不严或被绕过
5.文件解析漏洞导致文件执行
6.文件路径截断
五、上传漏洞的原理 大部分的网站和应用系统都有上传功能，一些文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过Web访问的目录上传任意PHP文件，并能够将这些文件传递给PHP解释器，就可以在远程服务器上执行任意PHP脚本。
当系统存在文件上传漏洞时攻击者可以将病毒，木马，WebShell，其他恶意脚本或者是包含了脚本的图片上传到服务器，这些文件将对攻击者后续攻击提供便利。根据具体漏洞的差异，此处上传的脚本可以是正常后缀的PHP，ASP以及JSP脚本，也可以是篡改后缀后的这几类脚本。
六、上传文件检测流程 通常一个文件以HTTP协议进行上传时，将以POST请求发送至Web服务器，Web服务器接收到请求并同意后，用户与Web服务器将建立连接，并传输数据。一般文件上传过程中将会经过如下几个检测步骤：
一般一个文件上传过程中的检测如下图红色标记部分：
客户端javascript校验（一般只校验文件的扩展名） 服务端校验 文件头content-type字段校验（image/gif）文件内容头校验（GIF89a）目录路经检测（检测跟Path参数相关的内容）文件扩展名检测 (检测跟文件 extension 相关的内容)后缀名黑名单校验后缀名白名单校验自定义正则校验WAF设备校验（根据不同的WAF产品而定） 七、上传漏洞绕过 1.客服端绕过
（1）客户端校验:
一般都是在网页上写一段javascript脚本，校验上传文件的后缀名，有白名单形式也有黑名单形式。判断方式：在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包
（2）绕过方法:
1.通过火狐插件NOscript插件或者禁用IE中JS脚本
2.通过firbug插件元素审核修改代码（如删除onsubm:t=”return checkFile()”事件）
3.通过firbug元素审核javascirpt脚本中添加上传文件类型。
4.通过利用burp抓包改包，先上传一个gif类型的木马，然后通过burp将其改为asp/php/jsp后缀名即可
注意：这里修改文件名字后，请求头中的Content-Length的值也要改
演示如下：
fidder进行抓包拦截，先上传一句话图片木马如bd2.jpg，然后抓包拦截改成bd2.php
2.服务端绕过
（1）黑名单扩展名绕过
黑名单检测：一般有个专门的 blacklist 文件，里面会包含常见的危险脚本文件。绕过方法：
（1）找黑名单扩展名的漏网之鱼 - 比如 iis6.0中的asa 和 cer
（2）可能存在大小写绕过漏洞 - 比如 aSp(iis6.0中可以） 和 pHp（只能在小于php5.3.39中的linux中） 之中
（3）能被WEB容器解析的文件其他扩展名列表：
jsp, jspx ,jspf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78af4bf6c0b59952e2be97c5bf67022b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3caaf39a81279aa70e5ffd70a05cb425/" rel="bookmark">
			关于webRTC拉流及拉流步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebRTC是一种实时通讯协议，它允许浏览器进行音视频通话和数据传输。下面是WebRTC拉流的步骤：
1.获取媒体流
拉流的第一步是获取媒体流。媒体流可以是摄像头、麦克风或屏幕共享。在WebRTC中，使用getUserMedia API获取媒体流。获取到媒体流后，就可以进行处理和发送了。
2.创建RTCPeerConnection RTCPeerConnection是WebRTC中最重要的对象之一。它处理与远程对等方之间的音视频通信。在拉流的场景中，我们需要使用RTCPeerConnection来接收远程对等方发送的流。创建RTCPeerConnection的代码如下： 3.添加远程流
在接收远程流之前，我们需要告诉RTCPeerConnection我们要接收哪种类型的媒体流。我们可以使用addTrack()方法将要接收的流添加到RTCPeerConnection中。代码如下：
4.创建SDP
SDP（Session Description Protocol）是WebRTC用于交换媒体协商信息的格式。在拉流的场景中，我们需要创建一个SDP，将其发送给远程对等方，告诉它我们想要接收哪种类型的媒体流。创建SDP的代码如下： 5.发送SDP
将SDP发送给远程对等方，让它知道我们想要接收哪种类型的媒体流。可以使用WebSocket或者其他通信方式来发送SDP。
6.接收远程流
接收远程对等方发送的媒体流。当接收到远程流时，RTCPeerConnection会触发ontrack事件。我们可以在这个事件的处理函数中获取到远程流，并将其显示在页面上。代码如下：
7.设置远程SDP
接收到远程SDP后，我们需要将其设置为远程对等方的描述，让RTCPeerConnection知道远程对等方希望发送哪种类型的媒体流。代码如下：
到此为止，WebRTC拉流的过程就完成了。
WebRTC是一项实时通信技术，具有以下优点：
简便：在WebRTC出现之前，用户需要安装插件和客户端才能进行实时通信。但是，WebRTC已经内置于浏览器中，用户可以在不安装任何插件或软件的情况下使用它。
跨平台：WebRTC基于浏览器，因此可以在任何支持WebRTC的平台上运行，包括Windows、Linux、iOS和Android。
P2P优势：WebRTC使用P2P技术处理数据（音频、视频和文件等）传输，减少了服务器端的性能压力和带宽成本。
全方位解决方案：WebRTC提供了一整套实时通信解决方案，包括采集、编解码、RTP打包、流量控制、音频处理和多通道混音等。这些都是开源的代码，大大节省了开发时间和成本。
免费：虽然WebRTC技术已经相当成熟，其集成了最佳的音/视频引擎、先进的编解码器等，但是Google对于这些技术不收取任何费用。
强大的穿透能力：WebRTC技术包含了使用STUN、ICE、TURN、RTP-over-TCP的关键NAT穿透和防火墙穿透技术，并支持代理。这使得WebRTC能够在各种网络环境下实现实时通信，无论是在企业内部还是在公共互联网上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b18a432c375a0b54a25ff98a322124/" rel="bookmark">
			HTTP 和 HTTPS（请求响应报文格式 &#43; 请求方法 &#43; 响应状态码 &#43; HTTPS 加密流程 &#43; Cookie 和 Session）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. HTTP 是什么2. HTTP 请求报文和响应报文的格式1）请求报文格式2）响应报文格式3）报文中空行的作用 3. HTTP 的长连接和短连接4. URL1）在浏览器中输入 www.baidu.com 后执行的全部过程 5. HTTP 常用的请求方法6. GET 和 POST 的区别7. HTTP 常见的响应状态码8. HTTPS 是什么1）SSL 协议 9. HTTPS 怎么进行 “加密”1）对称加密2）非对称加密3）CA 证书4）HTTPS 加密的完整流程 10. HTTPS 的优缺点11. HTTPS 和 HTTP 的区别12. Cookie 和 Session1）什么是 Cookie2）什么是 Session3）Cookie 和 Session 的区别4）Cookie 和 Session 如何配合工作 1. HTTP 是什么 HTTP 全称 “ 超文本传输协议 ”，是一种基于传输层 TCP 协议实现的应用非常广泛的 应用层协议
我们平时打开一个网站，就是通过 HTTP 协议来传输数据的
当我们在浏览器中访问一个 “ 网址 ”（URL），浏览器就会给这个 URL 的服务器发送一个 HTTP 请求，服务器返回一个 HTTP 响应，这个响应被浏览器解析之后，就展现出我们看到的网页内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78b18a432c375a0b54a25ff98a322124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3200abc34a702d74b536ca952bd919/" rel="bookmark">
			RT-Thread线程管理以及内核裁剪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RT-Thread线程管理以及内核裁剪 文章目录 RT-Thread线程管理以及内核裁剪1. RTOS概述1.1 RTOS的定义 1.2 主流RTOS2. RT-Thread架构3. RT-Thread内核模型3.1 内核概述3.2 内核静态对象和动态对象3.3 内核对象管理架构 4. RT-Thread线程管理4.1 线程概述4.2 系统线程4.3 线程调度4.4 线程函数的设计准则4.5 中断与线程的联系与不同 5. RT-Thread部署5.1 内核裁剪5.2 编译器选项5.3 选择优化等级 1. RTOS概述 1.1 RTOS的定义 实时操作系统（Real-time operating system, RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。
实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。
实时运算（Real-time computing）是计算机科学中对受到“实时约束”的计算机硬件和计算机软件系统的研究，实时约束像是从事件发生到系统回应之间的最长时间限制。实时程序必须保证在严格的时间限制内响应。
教科书操作系统分类：
批处理操作系统分时操作系统实时操作系统个人操作系统网络操作系统 1.2 主流RTOS FreeRTOS、UCOS、RT-Thread，这三种RTOS为国内市场占有率最高的三种通用型RTOS。
目前国内也有很多的RTOS，如华为的Lite-OS等
RT-Thread与Lite-OS简要对比如下：
2. RT-Thread架构 RT-Thread 与其他很多 RTOS 如 FreeRTOS、uC/OS 的主要区别之一是，它不仅仅是一个实时内核，还具备丰富的中间层组件
内核层：RT-Thread 内核，是 RT-Thread 的核心部分，包括了内核系统中对象的实现，例如多线程及其调度、信号量、邮箱、消息队列、内存管理、定时器等；libcpu/BSP（芯片移植相关文件 / 板级支持包）与硬件密切相关，由外设驱动和 CPU 移植构成。
组件与服务层：组件是基于 RT-Thread 内核之上的上层软件，例如虚拟文件系统、FinSH 命令行界面、网络框架、设备框架等。采用模块化设计，做到组件内部高内聚，组件之间低耦合。
RT-Thread 软件包：运行于 RT-Thread 物联网操作系统平台上，面向不同应用领域的通用软件组件，由描述信息、源代码或库文件组成。RT-Thread 提供了开放的软件包平台，这里存放了官方提供或开发者提供的软件包，该平台为开发者提供了众多可重用软件包的选择，这也是 RT-Thread 生态的重要组成部分。软件包生态对于一个操作系统的选择至关重要，因为这些软件包具有很强的可重用性，模块化程度很高，极大的方便应用开发者在最短时间内，打造出自己想要的系统。RT-Thread 已经支持的软件包数量已经达到 400+。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3200abc34a702d74b536ca952bd919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc2c8ae1919cf9bdd85815cb44a690a/" rel="bookmark">
			Weblogic 常见漏洞分析与利用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 前言 一直没有系统的总结过 weblogic 的漏洞，今天通过 vulhub 靶场来复现几个经典的案例。
0x01 基础知识 weblogic简介： WebLogic 是美国 Oracle 公司出品的一个基于 JAVAEE 架构的中间件，是用于开发、集成、部署和管理大型分布式 Web 应用、网络应用和数据库应用的Java应用服务器。WebLogic 由纯 Java 开发，长期以来一直被认为是市场上最好的J2EE工具之一，被广泛应用于开发、部署和运行 Java 应用等适用于本地环境和云环境的企业应用。
0x02 漏洞复现 1、Weblogic 弱口令/文件读取漏洞 此测试环境存在两个漏洞，后台存在弱口令，前台存在任意文件读取漏洞。本次测试分别通过这两种漏洞对本靶场进行渗透，最终获取 weblogic 的服务器权限。
漏洞原理： 在搭建好 weblogic 服务后没有修改后台的默认密码或密码设置太简单，导致可以弱口令登录，最终获得服务器权限。
环境搭建： 进入对应目录：
vulhub/weblogic/weak_password 启动本环境：
docker-compose up -d 文件比较大，第一次下载可能时间会比较长。
Weblogic版本：10.3.6
Java版本：1.6
复现过程： 启动环境后直接访问7001端口会出现404页面，这里要访问
http://ip:7001/console 打开 weblogic 后台页面
本环境存在弱口令：weblogic/Oracle@123
使用口令登录后台（注意此环境存在登录限制，错误密码5次之后就会自动锁定）。
weblogic 常用弱口令：
用户名：weblogic、system、admin、WebLogic
密码：weblogic、weblogic123、password、security、system、admin、WebLogic
选择左侧的部署，然后点击安装
然后就可以看到有个上传文件的选项，这里可以上传一个 jsp类型的小马的 war包来拿到shell。
首先将我们的 冰蝎马 shell.jsp 打包成 test.war 。
步骤：新建一个文件夹，里面只有 shell.jsp 文件，输入命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbc2c8ae1919cf9bdd85815cb44a690a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bf3f2ed47bdb6a1332b64fb219ec21/" rel="bookmark">
			如何排查线上环境CPU100%问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何排查线上环境CPU100%问题
cpu爆满的原因可能：1、形成了死锁。2、形成了死循环
1.使用arthas
2.使用命令的方式
死锁的检查：
方式一：
可通过jps或者ps -ef | grep java的命令查看到运行程序的PID使用jstack -l pid 命令查看线程的堆栈信息，-l是小写L 方式二：
可通过jvm的jconsole或者jvisualvm工具检查死锁
分析CPU过高问题：
● 使用top命令查找出使用率比较高的进程 pid
比如这里的4049，可通过P以CPU的使用资源排序显示
● 根据top -Hp pid （这个pid就是上一步top命令找到的pid），查找耗资源的线程ID
比如4049进程下面耗资源的线程ID是4050
● 将查询到的线程ID转成十六进制
#可直接在服务器执行这个命令转换，也可以通过其他转换工具转换 printf "%x\n" 4050 执行后打印的fd2就是4050对应的十六进制
● 拿到线程ID对应的十六进制后，通过 jstack 进程ID | grep 十六进制 -A 30 查看对应的堆栈信息
比如上面查询到进程ID4049下耗资源的线程ID4050转换的十六进制fd2使用命令为：
jstack 4049 | grep fd2 -A 30 这里就可以看出代码异常的地方，查看源代码，和堆栈信息一样，代码的21行出现问题
● jstack -l 4049 &gt; /tmp/error.log，将堆栈信息导到日志文件
● 分析堆栈文件，日志里面的nid对应的值就是进程下最耗资源的线程ID转换的十六进制，然后可能根据这个nid排查具体的内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68279a150e299daac0febe5a8d83844/" rel="bookmark">
			【yt-dlp】可用的语句记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料：
使用 yt-dlp 下载 YouTube 视频和播放列表（常见用法示例） - 哔哩哔哩
首先，如果用语句报错了，可以试试把单引号改双引号（亲测有效）
1、查看视频信息
yt-dlp --list-formats https://www.youtube.com/watch?v=xxxxxxx 2、下载指定分辨率视频
yt-dlp -f "bv*[height=2160]+ba" https://www.youtube.com/watch?v=xxxxxx #height=分辨率，[]前一定要加* #如果只写了bv不需要写分辨率，则不要加* #格式是按照之前info里看到的内容决定的，可以自己用ffmpeg转啦 3、下载指定码率音频
这个比较麻烦要先看视频信息，找到对应的ID再下载
如图我想下载129k的音频，可以看到m4a格式的ID是140，于是：
yt-dlp -f140 https://www.youtube.com/watch?v=xxxxxxx #f和ID之间没有空格！ 这么做是因为，在实验的时候用'ba'这个参数下载的话，总是读不到图上的129k，只能读到110k，所以~为了音质，没办法~倔强！
如果只需要音频，还可以尝试这个网站：
📼 Dirpy | Internet DVR
获取音频是免费的，不过有假320k的嫌疑~
以后用到其他的再补充了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb462f068632c4fc500ac20cbaba6750/" rel="bookmark">
			k8s-pod控制器Deployment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制
器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会
尝试进行重启或重建pod
一、名称空间 主要作用是用来实现多套环境的资源隔离或者多租户的资源隔离
kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个
Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集
群内部的资源分配到不同的Namespace中，可以形成逻辑上的"组"，以方便不同的组的资源进行隔离使
用和管理。
可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户
的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用
量、内存使用量等等，来实现租户可用资源的管理。
名称空间下，包含了pod控制器deployment、pod等如果删除了名称空间，那么在这个名称空间下的所有资源都将会被直接删除比如名称空间test下，有5个pod，想要删除所有pod，可以直接删除名称空间，这样所有pod都被删除了 #namespace 可以简写为ns kubectl create ns test 附：查看资源简写可以使用kubectl api-resources
二、pod Pod是k8s中最小的控制单元，应该程序需要部署在容器中，而容器存在于pod中，一个pod可以有一个或多个容器，pod是容器的封装
pause为系统的容器
1.命令式对象管理方式创建pod帮助文档
#nginx-pod 为pod的名称 #-n 指定在哪个名称空间 kubectl run nginx-pod --image=nginx:latest -n test 三、pod控制器 #比如在名称空间：test下，pod控制器：deploy-nginx下 创建2个nginx pod副本 kubectl create deployment nginx-deploy --image=nginx:latest -n test --replicas=2 查询当前名称空间test下的pod控制器
四、说明
通过查看名称空间test下的pod，发现都已经成功运行了，每个pod都有自己对应虚拟ip因为之前设置了副本数为2，此时我们删除了pod控制器属下的一个pod的话，控制器会检测到只剩1个了，那么就会帮助我们再启动1个pod控制器帮我们重新启动的新pod，对应的ip地址已经变化了，不会采用老的ip如果要想删除这2个pod，可以删除pod控制器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e39dea5e5b4ff1a738a94ce01be5c433/" rel="bookmark">
			WIN10、WIN11 新电脑配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WIN10、WIN11 新电脑配置 WIN10、WIN11 新电脑配置开启管理员模式 启用power shell脚本 WIN10、WIN11 新电脑配置 开启管理员模式 WIN11 下没有安装本地安全策略组件，表现为CMD运行 secpol.msc 命令会提示异常
开启本地安全策略 @echo off pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt dir /b %SystemRoot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt for /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i" pause win+r运行secpol.msc，开本地安全策略本地策略-&gt;安全选项-&gt;用户帐户控制:以管理员批准模式运行所有管理员 设置为禁用
启用power shell脚本 开发中，idea命令行可能提示 cnpm : 因为在此系统上禁止运行脚本
1：win+x以管理员身份运行PowerShell 以管理员身份运行
2：输入set-executionpolicy remotesigned
3：在弹出的对话框中输入Y即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9163387ff39b0dc0a94953a5a3ed263/" rel="bookmark">
			Access to XMLHttpRequest at ‘ ‘ from origin ‘null‘ has been blocked by CORS policy问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 网上有很多关于此问题的解决方案，像跨域等一系列问题。但是试了好多都不行，在vscode下载了Live Sever插件试了解决跨域问题仍然没有解决。
解决方法 1.去看自己的mybatis的xml文件中的sql语句是否正确，如果sql语句有问题也会出现该种情况。
2.最大意的一种情况（本人就是这种，突然脑子断根弦），打开方式有问题。spring boot内嵌了tomcat，所以打开html文件的方式不能和servlet一样（servlet需要手动部署到tomcat目录下），不能直接去点击需要打开的html文件，而是需要自己输入地址和端口号后跟需要打开的文件。举个栗子：127.0.0.1:8080/login.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690774d124dc05b426f0933cdbcda821/" rel="bookmark">
			pyinstaller : 无法将“pyinstaller”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出错情况 pyinstaller : 无法将“pyinstaller”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1
解决方法 一，查看是否有pyinstaller包 首先，确定自己有没有pyinstaller这个包。
没有的：打开pycharm终端使用命令 pip install pyinstaller安装，
二，找到包存放路径 进入到导包这里面，将鼠标放到pyinstaller上面，会出现包存放的路径
三，进入文件，复制Scripts路径 去自己本地找到这个路径，有些文件夹是隐藏的，需要点击查看之后勾选，这样就可以看见隐藏的文件 。
存放包路径：C:\Users\Administrator\AppData\Roaming\Python\Python310\site-packages
Scripts路径：C:\Users\Administrator\AppData\Roaming\Python\Python310\Scripts
找到与存放包同级的文件Scripts，添加的系统变量环境是同级的Scripts！！！！！
找到包的存放路劲只是为了方便找到Scripts文件，需要添加到环境变量的是Scripts路径。（这只是我的路径，与你们不一样）
四，添加系统环境变量 将路径添加到系统环境变量里
目前pyinstaller支持Python.3.10版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90e95ee30679eca96affc0ab332edb8/" rel="bookmark">
			使用maven推送jar包到远程仓库和本地仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记录一下使用到公司maven私服没有的jar包。
maven推送jar包到远程仓库 mvn deploy:deploy-file -DgroupId=com.oracle -DartifactId=ojdbc -Dversion=11.2.0 -Dpackaging=jar -Dfile=D:\repository\ojdbc6.jar -Durl=http://${host-url}/repository/maven-releases/ -DrepositoryId=${id} 注：这里面的${id}要用type为hosted类型的
maven推送jar包到本地仓库 mvn install:install-file -Dfile=D:\repository\aspose-pdf-23.1.jar -DgroupId=com.aspose -DartifactId=aspose-pdf -Dversion=23.1 -Dpackaging=jar 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de845f74996b9fa13f6a046b7a528ab/" rel="bookmark">
			linux安装 redis You need tcl 8.5 or newer in order to run the Redis test
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：You need tcl 8.5 or newer in order to run the Redis test
按照错误信息的提示可知：系统中 缺少 tcl 或者 tcl 版本比较老。
检查系统中是否有 tcl：
rpm -qa | grep tcl 下载：
wget http://mirror.centos.org/centos/7/os/x86_64/Packages/tcl-8.5.13-8.el7.x86_64.rpm 安装：
rpm -ivh tcl-8.5.13-8.el7.x86_64.rpm 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e436c75e7292f9523ac84b7284f47eb7/" rel="bookmark">
			Linux配置多版本JDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 太多一个抄一个，连验证一下都不做的人了。
以下步骤经过验证
一、安装多版本JDK # 1、下载多版本JDK，并且进行解压 此处如图所下 二、配置JDK软连接 jdk8
# 命令 --安装 软连接 名称 安装路径 alternatives --install /usr/bin/java java /usr/java/jdk8 1 jdk18
alternatives --install /usr/bin/java java /usr/java/jdk18 2 三、修改环境变量配置文件（这一步很关键） #打开环境变量配置文件 vim /etc/profile #修改环境变量配置文件，这里要写的是软连接的路径 export JAVA_HOME=/usr/bin/java export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH #重新加载配置文件，使配置文件生效。 source /etc/profile 四、查看软连接 选择数字，然后再去查询版本，就可以转到自己想要的版本了。
alternatives --config java There are 2 programs which provide 'java'. Selection Command ----------------------------------------------- 1 /usr/java/jdk8 *+ 2 /usr/java/jdk18 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320862cfbff3e1e2835ff8d774449c84/" rel="bookmark">
			【LInux】MySQL高可用之主从复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Mysql主从架构技术说明 Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到 多个系统上去，这种分布的机制，是通过将Mysql的某一台主机（Master）的数据复 制到其它主（slaves）上，并重新执行一遍来实现的。 复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服 务器将更新写入二进制日志文件，这些日志可以记录发送到从服务器的更新。当一个 从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更 新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。
1. 主从复制架构图 二进制日志也就是binlog.log，它里面记录的数据库的操作；
主机数据库的操作记录在二进制日志里；
从机有两个线程：
I/O线程 用来读取主机上的二进制日志的内容，写入到中继日志（relay_log）SQL线程 将中继日志中的数据读取给从机（因为二进制日志里的内容是sql语句，所以中继日志里的内容也是sql语句，这时候就需要sql线程将中继日志的内容读取，读取后相当于在从机上执行了sql语句，这样实现了主从复制） 2、Mysql复制解决的问题 MySQL复制技术有以下一些特点：
数据分布 (Data distribution )负载平衡(load balancing)备份(Backups)高可用性和容错性 High availabilityand failover 主从复制以及主从复制的作用： 在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足 实际需求的，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发 负载能力
3、MySQL主从复制的复制方式 1）异步复制（Asynchronous replication） MySQL的复制默认是异步的，MySQL主从异步复制是最常见的复制场景。数据的完
整性依赖于主库BINLOG的不丢失，只要主库的BINLOG不丢失，那么就算主库宕机
了，我们还可以通过BINLOG把丢失的部分数据通过手工同步到从库上去。
异步复制是指 主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不
关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上
已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主
上的数据不完整。
MySQL 默认的复制策略，Master处理事务过程中，将其写入Binlog就会通知Dump thread线程处理，然后完成事务的提交，不会关心是否成功发送到任意一个slave中；
【问题】：一旦Master 崩溃，发送主从切换将会发送数据不一致性的风险。
（也就是主机崩溃了，因为是异步，主机已经不再接受数据了，而从机还在同步就可能导致数据不一致）
画外音：性能最好
2）全同步复制（Fully synchronous replication）/组复制 (MySQL Group Replication（MGR）) 指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等 待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。 需要有超时时间。
MySQL在引擎层完成Prepare操作写Redo日志之后，会被MySQL的预设Hook拦截 进入MGR层
MGR层将事务信息打包通过Paxos协议发送到全部节点上，只要集群中过半节点回复 ACK，那么将告诉所有节点数据包同步成功，然后每个节点开始自己认证（certify） 通过就开始写Binlog，提交事务或者写relay log，数据同步，如果认证不通过则 rollback；
什么是Certify？ 在不同服务器上并发执行的事务之间可能存在冲突。这种冲突是通过检查和比 较两个不同的并发事务的写入集来检测的，这个过程称为认证 在认证期间，冲突检测是在行级别执行的：如果在不同服务器上执行的两个并 发事务更新了同一行，则存在冲突。 冲突解决过程指出，首先排序的事务将在所有服务器上提交，而第二次排序的 事务将中止，因此将在原始服务器上回滚并被组中的其他服务器丢弃。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/320862cfbff3e1e2835ff8d774449c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b83e60e41cf59c7083e18cbdc675300/" rel="bookmark">
			用bp神经网络实现单目测距（训练教程&#43;推理程序&#43;exe实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在单目相机中目标检测有着众多的开源算法，但是只是检测到物体在图像中的位置是不够的，实际应用中需要得到的一般是实际物体离相机的距离，这样的话就可以实际应用到项目中了。
实现目标测距思路：
由于单目相机的检测算法一般得到的都是像素坐标，由于缺失一个维度，由二维像素坐标得到三维世界坐标的往往是极为困难的，在这篇博客中我使用了数据分析拟合训练的方法来实现测距，大致分为以下五个阶段：
1. 采集测距参数
2. 选取合适的数据拟合方法
3. 训练模型参数
4. 编写python推理程序
5. 生成测距exe文件
1. 采集测距参数
经过目标检测算法之后我们得到的一般是目标框左上角坐标以及宽高(x1,y1,w,h),当同一目标物纵向距离固定时，其目标框的大小也就固定了，横向距离只会影响左上角的坐标。但是横向距离固定时，纵向距离变大变小，目标框大小和左上角坐标都会变化，但实际上通过对数据分析可知3m到30m内距离相关的主要还是目标框的大小。由于实际需求是要预估行人纵向距离，所以我们这里的参数选为（w,h,dist)，如果你的数据均匀充足且想提高准确性参数可以选择为(x,y,w,h,dist)。(需注意此处我训练数据来源1280*720图片！图片不同于我这个最好重新采集数据进行训练，dist为行人纵向距离）。
2. 选取合适的数据拟合方法
由于二维坐标推导三维距离是一个非线性关系且输入输出变量数量较少，这里选取bp神经网络进行参数的拟合。
3. 训练模型参数
这里选用matlab中nftool工具箱训练模型(也可以用python搭建训练网络，但是推荐使用nftool):
1.matlab
打开matlab界面:
在工作区鼠标右键新建X，Y两个变量
将(w,h)复制到变量X中，(dist)复制到变量Y中：
在命令行窗口输入nftool并敲击回车
出现;
点击next,如图选择X，Y变量(注意columns和rows的选择):
然后一路next到如下界面：
点击train,从弹窗中点击第四个按钮查看效果：
四个参数都在0.9以上就是效果不错，如果差距较大点击retrain。
得到满意结果后点击next出现如下界面：
4. 编写推理程序
点击上图第二个按钮，生成如下function
从中找到如下参数(input到output)：
复制input到output参数，粘贴到以下编写好的推理程序中并替换同名变量(下面程序中变量是我根据自己数据训练出的权重参数） from math import exp import traceback import time x1_step1_gain = [0.045455,0.013986] x1_step1_xoffset = [7.000000,18.000000] x1_step1_ymin = -1.000000 b1 = [4.385133,-3.340426,2.517180,-1.870918,-0.436608,0.263311,-0.517846,2.531721,2.119660,4.962391]; IW1_1 = [[-2.794530,3.451441],[4.460429,-0.018738],[-3.789230,-2.231532],[0.634038,-4.806527],[-4.192876,0.436725],[2.580258,3.724527],[-5.181921,3.622694],[2.329938,-3.758832],[3.600565,0.679507],[4.569948,-0.008976]] b2 = 0.726103 LW2_1 = [-0.328219,0.432372,0.498732,-1.453644,1.330706,0.138778,-2.427547,1.007525,-2.388354,-2.285126] y1_step1_ymin = -1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b83e60e41cf59c7083e18cbdc675300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f590c495befd058526ac89e5d41eb43/" rel="bookmark">
			C&#43;&#43;入门基础 while循环 break continue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		朋友们好久不见，不知道大家这个春节过的怎么样，今天是初五，竹子回来更新博客了
今天讲解的是while 循环，与之差不多的还有do-while这个我就不做讲解
引入 没错是不是非常的新鲜，竹子今天居然没有直接进入正题
我们都知道如果要输出一个数，我们可以直接cout ，那么，如果要输出1到100这100个数，一个一个输出就显得非常的麻烦了，那么我们有没有什么办法，让电脑自己执行100次命令呢（明知故问）
没错我们可以用循环语句（自问自答），今天我们就介绍一种循环，名叫while
先来看while的结构 #include &lt;iostream&gt; using namespace std; int main(){ int i = 1; while(i &lt;= 100){ cout &lt;&lt; i &lt;&lt; endl; i++; } return 0; } 这段代码的作用就是上面提到的输出1到100
while后面的括号中填的是一个bool类型的数，一般我们会在while的前面设一个变量用于记录循环的次数，在while的内部更改这个变量的值，防止陷入死循环
当然也总有人会作死不写变量，例如：
#include &lt;iostream&gt; using namespace std; int main(){ long long rp = 1e9; while(1) rp++; return 0; } 没错这里就是一个死循环了
那么就有人问了，我既想直接在括号里直接填True又想避免一些不必要的循环怎么办呢
那这里就需要用到语句break和continue了
break break的作用主要是结束循环，直接执行接下来的任务
例如：
#include &lt;iostream&gt; using namespace std; int main(){ long long rp = 1e9; while(1){ rp++; if(rp &gt;= 1e18){ break; } } return 0; } 这里就是在rp的值到达1e18的时候跳出循环，等价于
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f590c495befd058526ac89e5d41eb43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a5f2438789170783ed2d577adf06f8/" rel="bookmark">
			[PTA]练习4-7 求e的近似值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[PTA]练习4-7 求e的近似值 题目： 自然常数 e 可以用级数 1+1/1!+1/2!+⋯+1/n!+⋯ 来近似计算。本题要求对给定的非负整数 n，求该级数的前 n+1 项和。
输入格式：输入第一行中给出非负整数 n（≤1000）。
输出格式：在一行中输出部分和的值，保留小数点后八位。
输入样例：10
输出样例：2.71828180
方式一：一般形式，两层循环嵌套
#include&lt;stdio.h&gt; int main() { int n = 0; double sum = 1; scanf("%d", &amp;n); if (n &lt;= 1000) { for (int i = 1; i &lt;= n; i++) { double fact = 1;//不能定义为全局变量 for (int j = 1; j &lt;= i; j++) { fact = fact * j; } sum = sum + 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6a5f2438789170783ed2d577adf06f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aff5bba4e79b16a6ea8b65eb0818c69/" rel="bookmark">
			CobaltStrike基础使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CobaltStrike简介 Cobalt Strike（简称为CS）是一款团队作战渗透测试神器，是一种可以用来进行横 向移动、数据窃取、鱼叉式钓鱼的后渗透工具，分为客户端和服务端，一个客户端可 以连接多个服务端，一个服务端也可以对应多个客户端连接。
CobaltStrike基本使用 CS安装 1.Linux安装JDK
apt search java | grep jdk apt install openjdk-11-jdk 2.Windows安装JDK
下载JDK： https://www.oracle.com/java/technologies/downloads/#java8-windows Oracle公共账号密码：http://bugmenot.com/view/oracle.com 3.环境变量配置
Java_Home =&gt; C:\Program files\jdk1.8.0_216 CLASSPATH =&gt; .;JAVA_HOME%\lib;%JAVA_HOME\lib\tools.jar PATH =&gt; %JAVA_HOME%\bin;%JAVA_HOME\jre\bin CS启动 1.启动服务端
chmod +x teamserver ./teamserver [server_ipaddress] [password] 2.启动客户端
./cobaltstrike Alias：别名，用户名@服务端IP地址
Host :服务端IP地址，可为域名
Port：服务端口号，默认50050，可进行修改
User：用户名，可随意填写，只要不冲突即可
Password: 登录密码，启动服务端时设置的密码
CS界面介绍 Connect to team server：连接服务端Disonnect from team server：断开当前服务端连接Configure Listeners：配置监听器Show sessions in graph view：展示会话列表Show sessions in table view：展示视图列表Show targets in table view：展示目标列表Credentials：查看从靶机获取的账户密码Downloaded Files：查看从靶机下载的文件Keystrokes：查看键盘记录Screenshots：查看屏幕截图Generate Windows Executable (Stageless)：生成无状态的EXE木马Setup java Signed Applet Attack：开启Web服务为自签名Java Applet提供运行 环境MS Office Macro Attack：生成OFFICE宏病毒文件Setup Scripted Web-Delivery (Stageless)：开启Web服务，供下载和执行 PayloadHost a file：开启Web服务，供下载文件Manage Web Server：管理Web服务Help：帮助文档 18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aff5bba4e79b16a6ea8b65eb0818c69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b5871bbb90cf063d52430be8e84e1f6/" rel="bookmark">
			DHCP原理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DHCP概述 DHCP(Dynamic Host Configuration Protocol),动态主机配置协议，是一个应用层协议。当我们将客户主机ip地址设置为动态获取方式时，DHCP服务器就会根据DHCP协议给客户端分配IP，使得客户机能够利用这个IP上网。专门用于为TCP/IP网络中的计算机自动分配TCP/IP参数的协议。
1.使用DHCP的好处 减少管理员的工作量避免输入错误的可能性避免IP地址冲突当更改IP地址段时，不需要重新配置每个用户的IP地址提高了IP地址的利用率方便客户端的配置 2.DHCP的特点 DHCP可以自动分配IP、子网掩码、网关、DNS。DHCP客户端使用的端口68，服务端使用端口67，使用的UDP传输协议。DHCP分配的IP地址有租期，会周期性改变。一般不为服务器分配IP，因为他们要使用固定IP，所以DHCP一般只为办公环境的主机分配IP。DHCP服务器和客户端需要在一个局域网内，在为客户端分配IP的时候需要进行多次广播。但DHCP也可以为其他网段内主机分配IP，只要连接两个网段中间的路由器能转发DHCP配置请求即可，但这要求路由器配置中继功能。 二、DHCP工作原理 客户端广播发送DISCOVER报文寻找服务端；服务端广播发送OFFER报文响应给客户端，报文中还包含地址池中的一个可用IP；客户端只会接收第一个发来的OFFER报文并提取出可用IP,再向服务端广播发送REQUEST报文请求使用这个可用IP。服务端广播发送ACK报文响应给客户端，告知IP合法可用并提供租期信息。 重新登录
DHCP客户机每次重新登录网络时，不需要再发送Discover信息，而是直接发送包含前一次所分配的 IP地址的Request请求信息。 更新租约
当 DHCP服务器向客户机出租的 IP 地址租期达到 50%时，就需要更新租约。客户机直接向提供租约的服务器发送Request包，要求更新现有的地址租约。
IP地址分配顺序：从小到大
三、安装与配置DHCP vim /etc/dhcp/dhcpd.conf subnet 网段IP netmask 子网掩码 {	#声明要分配的网段地址 range IP地址池起始IP IP地址池终止IP;	#设置地址池 option routers 默认网关IP;	#指定默认网关地址 option domain-name-servers DNS服务器IP; #可选 default-lease-time 默认租期秒数; #可选 max-lease-time 最大租期秒数; #可选 } host 自定义名称 {	#指定需要分配固定 IP地址的客户机名称 hardware ethernet MAC地址用:分隔;	#指定该主机的 MAC地址 fixed-address IP地址;	#指定保留给该主机的 IP地址 } systemctl restart dhcpd 客户端主机设置自动获取IP Linux系统：网卡配置 BOOTPROTO=dhcp 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b5871bbb90cf063d52430be8e84e1f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d84bfeafc007b4c6ada427a554dda87/" rel="bookmark">
			如何在ubuntu上安装gcc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先查一下，有没有gcc，如下
然后准备安装gcc：
1.sudo是授权，apt是一个应用管理工具，apt是本地存了一份软件包信息的列表，包括依赖、大小、vesion等。目的是为了在安装软件的时候快速检测依赖，并自动安装相关依赖。但在安装之前要先更新这个列表，即用下面语句，不然安装的软件是老版本。（update和upgrade的简单区别是：一个保存一切，一个旧的不保留了）
sudo apt update 2.安装gcc,这里我们实际上安装的是"build-essential"，它包含了 GNU 编辑器集合，GNU 调试器，和其他编译软件所必需的开发库和工具。下面这个命令将会安装一系列软件包，包括gcc，g++，和make。
sudo apt install build-essential 如下：
3.检查验证 GCC 编译器是否被成功地安装：
OK，这就安装好了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f35f05685aea3b470c607959227709/" rel="bookmark">
			HTML引入Typescript编译JS文件 ：Uncaught ReferenceError: exports is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学TypeScript，尝试在html引入ts编译出来的js文件: 报错：Uncaught ReferenceError: exports is not defined
以下是代码：
创建了TS:加入export {}形成独立的作用域，其他ts文件重复声明相同名称的变量。
export {} let str = "tt"; // str=22 //类型不对，编辑器IDE会提示错误 let a:string="44" console.log(str) tsconfig.json配置：
/* Modules */ "module": "commonjs", 编译之后生成js:
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); let str = "tt"; // str=22 //类型不对，编辑器IDE会提示错误 let a = "44"; console.log(str); HTML:
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="01-基础.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 运行时报错：Uncaught ReferenceError: exports is not defined。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54f35f05685aea3b470c607959227709/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80bd11bad288d925f35937664955f14a/" rel="bookmark">
			Spring MVC(2)-跨域、CORS、XSS、 CSFR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同源和跨域 同源 什么是同源？请求的“协议+ip(域名)+端口”被称之为“源”。
如果当前页面的url和在当前页面中要访问的url具有相同的源，那么我们称这两个请求“同源”，即它们来自或者去往同一个服务器。
跨域 什么是跨域？如果当前页面的url和请求的url非同源，那么我们就可以称之为跨域，也称之为跨源！或者说，当请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域！非同源和跨域，可以说是一种事务的不同说法！
跨域例子 假设某个页面的URL为http://mall.pplus.com/goods/detail.html，下面是常见的跨域（非同源）请求的类型：
请求的URL是否跨域（非同源）原因http://mall.pplus.com/other.html否只有访问的资源路径不同http://mall.pplus.com/dir/inner/another.html否只有访问的资源路径不同https://mall.pplus.com/dir/page.html是协议不同http://mall.pplus.com:81/dir/page.html是端口不同 ( http:// 默认端口是80)http://news.pplus.com/dir/page.html是主机（域名）不同 同源策略 什么是同源策略？同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，它的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。
如果缺少了同源策略，则浏览器的正常功能可能都会受到影响，很容易受到 XSS、 CSFR 等攻击。
同源策略对跨域（非同源）请求进行了如下限制：
无法读取非同源网页的 Cookie、LocalStorage 和IndexedDB；当然如果两个网页一级域名相同，只是次级域名不同，那么Cookie可以通过设置相同的domainName来实现共享Cookie。无法获取非同源网页的 DOM树和Js对象。无法获取非同源地址返回的响应，例如通过XMLHttpRequest发送的AJAX请求，以及标签请求的非同源图片资源，获取想要加载的各种网络字体、样式资源。 一级域名:
一级域名就是顶级域名，是同一种域名的两种叫法。
例如pplus.com是顶级域名，也是一级域名。
二级域名：
例如www.pplus.com、mall.pplus.com为二级域名。
同源策略的限制通常是浏览器自己来实现的，当同源策略触发时：
对于某些浏览器，可能已经正常发送了跨域请求，甚至服务器已经正常处理了请求并且返回了响应，只不过在处理结果时浏览器做了限制，导致无法获取服务器响应的结果！对于另一些浏览器以及某些请求方式，它会首先发送一个OPTIONS 预检请求到服务器，以获知服务器是否允许该实际请求，当服务器响应允许此次跨域时，才会发送真正的请求并且正确的处理响应结果。"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。 解决跨域 同源策略虽然带来一定的安全性，但是这往往给一些正规的跨域需求带来不便，特别是前后端分离以及服务化的项目，通常不同的服务之间是不同源但，但是它们之间需要互相调用那个。为此，我们可以采取一些方式来绕过同源策略！
解决的方案：
JSONP：一种只需要前端处理的比较简单的方法，但是只能支持get请求，不支持其他类型的请求，因此用的不多。WebSocket：一种基于HTTP升级而来的协议，它不实行同源策略，只要服务器支持，就可以通过它进行跨域通信。但是WebSocket协议的前后端代码开发和普通HTTP开发有很大区别，通常是被用于即时通信或者要求服务器实时推送数据的项目中，普通web项目为了解决跨域问题而使用WebSocket是得不偿失的！Nginx：反向代理，也是一种非常有效的解决跨域问题的方法，用的也非常多！CORS：CORS（Cross-origin resource sharing），通俗地译为跨域资源共享。CORS是一个W3C标准，是一种基于HTTP头的机制，该机制通过允许服务器标示除了它自己以外的其它origin（源，包括域、协议和端口），这样浏览器可以访问加载这些资源。 CORS解决跨域 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。
对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的OPTIONS“预检”请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。
CORS可以看作是跨源AJAX请求的一种根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。
CORS标准 W3C为CORS标准新增了一组 HTTP 首部字段，以允许服务器在响应头中通过这些字段声明和控制哪些源站通过浏览器有权限访问哪些资源。
另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。
header Access-Control-Allow-Origin：必须的字段，服务器允许的域，允许所有域设置为 *。Access-Control-Allow-Methods: 服务器允许的请求方法，允许所有方法设置为*。Access-Control-Allow-Headers:如果请求包括Access-Control-Request-Headers字段，则响应的Access-Control-Allow-Headers字段是必需的。表明服务器允许添加的请求头字段，采用“,”分隔，不限于浏览器在预检请求中传递的字段。Access-Control-Allow-Credentials：处理方式与简单请求时一致。Access-Control-Max-Age: 该预检请求响应的有效时间，单位秒时。在有效时间内，浏览器无须为同一请求再次发起预检请求。浏览器自身同样维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。 Spring MVC 对CORS支持 Spring MVC的HandlerMapping的实现为CORS提供了内置支持。在成功将request映射到handler处理器后，HandlerMaping 实现将检查给定request和handler的 CORS 配置信息，随后，将会直接处理预检请求，同时拦截、验证简单和实际 CORS 请求，并设置所需的（配置的）CORS响应头信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80bd11bad288d925f35937664955f14a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6bd1d92609080b981eab2e56e0a9806/" rel="bookmark">
			Charles安装及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 简介及安装
一、charles的使用
1.1 charles的说明
Charles其实是一款代理服务器，通过过将自己设置成系统（电脑或者浏览器）的网络访问代理服务器，然后截取请求和请求结果达到分析抓包的目的。该软件是用Java写的，能够在Windows，Mac，Linux上使用。安装Charles的时候要先装好Java环境。
Charles的主要功能：
（1）截取Http 和 Https 网络封包。
（2）支持重发网络请求，方便后端调试。
（3）支持修改网络请求参数。
（4）支持网络请求的截获并动态修改。
（5）支持模拟慢速网络。
1. 下载
Charles下载地址
地址：Download a Free Trial of Charles • Charles Web Debugging Proxy
2. 安装
一路按下next即可安装（保证电脑里没有其他charles即可）
3. 破解
Charles第一种破解方法：
打开汉化补丁 选择“中文破解版”，按下patch即可打开汉化补丁 选择“中文破解版”，按下patch即可
Charles第二种破解方法：
破解地址：Charles破解工具
生成jar文件后，放到charles安装目录的lib目录下
此时，重启charles,查看已经破解，如下图：
设置charles, Proxy-&gt;Proxy setting,就可以抓取http协议了（默认不用更改）
4. 进入界面
注意：安装好charles后，要先进行汉化破解再打开，如果先打开了软件，在汉化的话就会无效，只能重新安装再进行以上步骤。
二. 连接
1.PC抓包
由于charles会自动配置浏览器和工具的代理设置，所以说打开工具直接就已经是抓包状态了。直接打开网页就可以了。
注意：
（1）Charles支持抓去http、https协议的请求，不支持socket。
（网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket）
（2）防火墙关掉
点击上方的代理—windows代理
电脑charles客户端下载SSL证书
帮助—SSL代理—安装charles证书
选择当前用户
将所有的证书都放入下列存储—受信任的根证书颁发机构—下一步—完成
2.手机端抓包
使手机和电脑在一个局域网内，不一定非要是一个ip段，只要是同一个路由器下就可以了。
（1）首先利用cmd -config命令查看自己电脑的ip地址
配置代理服务器
菜单栏上选择“代理—代理设置，
填入代理端口xxxx
勾选启用透明HTTP代理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6bd1d92609080b981eab2e56e0a9806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c0f482d853eb36b91e6fe89ffd3e63/" rel="bookmark">
			NGINX解决第三方图片跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前端代码修改把第三方图片地址进行替换
原始图片地址：
http://192.168.1.1/pic?8dd611z2c-=s0931065c3614e-=t1i5m*=p4p9i=d1si4d667d8=*5b8i2e=
前端把原始地址替换：
http://192.168.2.5:80/crossOriginImg?referer=http://192.168.1.1/pic?8dd611z2c-=s0931065c3614e-=t1i5m*=p4p9i=d1s*i4d66*7d8=*5b8i2e=
把IP端口指定到本地同源的可以部署nginx的服务器，把源地址当作一个参数传到nginx进行解析，这样不需要提前知道第三方图片地址ip和端口。
2.配置NGINX location ~/crossOriginImg { add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; if ($args ~ "referer=(.*)"){ set $newurl "$1"; } proxy_pass $newurl; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_intercept_errors on; error_page 301 302 307 = @handle_redirect; } location @handle_redirect { add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; set $saved_redirect_location '$upstream_http_location'; proxy_pass $saved_redirect_location; } 配置说明：
1.添加允许跨域的请求头
add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9c0f482d853eb36b91e6fe89ffd3e63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1091165b6cc32f893ab065591c47a23d/" rel="bookmark">
			Arduino开发之如何连接WIFI模块？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0.引言1.WIFI模块说明2.安装ESP8266开发板库3.设置ESP8266连接WIFI4.Arduino通过ESP8266收发消息5.功能演示 0.引言 在硬件开发过程中，会将许多传感器组合，产生许多数据，这些数据需要传输到上位机进行数据融合处理才能实现硬件系统的功能，或许这些数据不急着处理，可以将数据存储到SD卡中，隔一段时间后再导出统一整理，但有时需要无线通信，远控硬件作出行动。对于无线传输控制硬件，蓝牙和WIFI都可以实现，但蓝牙更多的应用于连接设备，在传输速度上比WIFI慢，若需信息传输，可以选择WIFI。本文采用ESP8266-12E的WFI模块，在【Arduino如何进行开发？】基础上，阐述Arduino如何连接WIFI模块。
1.WIFI模块说明 WIF模块情况：
ESP8266(CP2102)，NodeMCU板载ESP-12E ( 4MB Flash) WIFI模组和USB转TTL串口(CP2102/ CH340)芯片,不用外接下载器，直接通过USB线与电脑相连，方便下载固件和调试。
引脚说明：
2.安装ESP8266开发板库 （1）将ESP8266模块通过USB连接电脑，在工具→端口选择端口，若端口不可选中，需要安装usb转串口通用驱动.EXE；
（2）在文件→首选项→其他开发板管理器地址，网址添加：
http://arduino.esp8266.com/stable/package_esp8266com_index.json
（3）在工具→开发板→开发板管理器，添加ESP8266库；
注：若因网络问题无法安装，下载ESP8266安装包，安装完成后重启Arduino，即可添加ESP8266库。
（4）在工具→管理库，添加pubsubclient库和ArduinoJson库。
3.设置ESP8266连接WIFI （1）设置热点名称、热点密码；
热点名称和密码为方便测试是否连接网络，可使用手机热点或者无线路由器。
若使用无线路由器，可在笔记本浏览器输入：tplogin.cn访问路由器管理网页。
（2）获取Sub、Pub的代码；
Sub、Pub的代码来自于易联智能物联网平台，获取步骤如下：
（3）编写设置代码；
ESP8266_SetWifi.ino
#include &lt;ESP8266WiFi.h&gt; #include &lt;PubSubClient.h&gt; #define BUILTIN_LED 2 char P_NAME[] = "F305"; //设置热点名称 char P_PSWD[] = "f305f305"; //设置热点密码 char sub[] = "Sub/100326"; //设置设备Sub代码 char pub[] = "Pub/100326"; //设置设备Pub代码 const char *ssid = P_NAME; const char *password = P_PSWD; const char *mqtt_server = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1091165b6cc32f893ab065591c47a23d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9388804872cbb0d639c85a11bcee20d5/" rel="bookmark">
			2023 年 18 种最佳 Android 测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着时间的推移，应用程序市场变得竞争异常激烈。在竞争激烈的市场中，开发人员脱颖而出的一种方法是构建和生产功能强大、可靠且无错误的移动应用程序。虽然功能是开发人员需要解决的问题，但在移动自动化测试的帮助下制作无错误的应用程序变得越来越容易。
简而言之，移动自动化测试意味着自动化移动应用程序的测试过程，并允许您在生产或最终用户遇到问题或错误之前发现它们。
当我们想到移动应用程序和操作系统时，我们脑海中只会浮现出两个名字，Android 和 iOS。这是移动市场上最流行和最主要的两个操作系统。虽然这些不是唯一的移动操作系统，但这两个正在支配市场。
在 Google Play 商店上发布的应用程序数量一直在增加，自 2022 年 6 月以来已发布了约 267 万个应用程序。洞察告诉我们，Android 应用程序被用于包括但不限于品牌推广、扩展、客户获取和保留.
Android 应用测试是用于确保应用质量和​​状态的指标。结果可用于深入了解预期行为。它包括多个方面，例如跨不同操作系统、浏览器和设备组合等测试 Android 应用程序。它给出了用户可能遇到的问题的要点，无论是错误还是性能问题等等。
为了使这更容易和更流线型，Android 测试工具被构建为自动执行重复性任务并加快发布周期。为此，他们可以利用 Android 测试工具自动执行重复性任务并加快发布周期。由于已经构建了如此多的测试工具，并且不断有新的工具问世，要找到并选择为您量身定制或符合您标准的测试工具可能会变得非常困难和不知所措。
别担心!在本文中，我们将研究市场上可用的不同 Android 测试工具。从阐明工具到讨论开发人员或团队在寻找 Android 测试工具时需要牢记的各种关键因素，并根据其功能和优势突出显示最佳工具。
到本文结束时，开发人员可以清楚地了解一些最适合他们应用程序的 Android 测试工具。
一、什么是安卓测试?
Android 测试是在构建 Android 应用程序时使用测试工具自动执行重复性任务的过程框架。它旨在发现错误、性能问题以及应用程序在向公众开放之前可能遇到或引起的任何其他问题。这有助于开发人员确保应用程序按预期工作，检查它是否对用户友好，并满足利益相关者的要求。
对 Android 应用程序使用自动化测试有几个好处。首先，自动化繁琐且耗时的手动检查可以节省时间和资源。其次，在各种硬件和软件设置上运行测试增加了测试覆盖率。第三，它有助于在开发过程的早期发现缺陷，减少修复缺陷所需的时间和金钱。
Android 自动化测试可以使用各种移动应用程序测试工具和框架执行，例如 Appium、Espresso 等。这些工具使应用程序开发人员或测试人员能够编写脚本来模拟应用程序的实际使用情况，例如探索 UI、访问功能和更多的。
二、执行 Android 测试时遇到的挑战
好吧，无论事情有多好，一切都有其自身的优点、缺点和挑战。Android 应用程序的自动化测试也不例外。它有开发人员可能遇到的一系列挑战。以下是您可能遇到或遇到的一些挑战：
1、设备碎片化
Android 是一种操作系统，各种手机制造商和公司基于 Android 构建了范围广泛的设备，每种设备都有不同的屏幕尺寸、分辨率和硬件配置。因此，跨所有设备进行测试可能既耗时又复杂。
2、跨多个平台测试
与上一点类似，各种类型的设备都是基于Android构建的，例如智能手机和平板电脑。因此，在所有可能的平台上测试应用程序可能会很乏味，并且需要额外的测试框架和工具。
3、应用复杂度
某些应用程序可能具有复杂的构建(架构)、功能、多屏幕、数据等，因此查找所有并涵盖所有边缘案例可能具有挑战性。
4、测试维护
随着应用程序随着新功能的添加而迭代和更新，测试套件需要更新和维护，这可能很耗时，而且通常需要专门的团队或一组个人来处理。
组织在测试 Android 应用程序时会遇到各种困难。然而，Android 测试工具支持克服这些障碍并提高生产力。在下一节中，我们将探讨如何从市场上可用的工具中选择 Android 测试工具。
三、如何选择最好的 Android 测试工具?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9388804872cbb0d639c85a11bcee20d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195f5b42c2853f41a17f514d190bd019/" rel="bookmark">
			使用C语言实现磁盘的文件管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目名称
磁盘文件管理系统
项
目
实
现
原
理
简
述
一、实验目的:
1.理解磁盘文件管理的概念和原理；
2.了解文件的逻辑结构和物理结构；
3.理解文件目录结构；
4.掌握磁盘存储空间管理、文件操作实现方法。
二、实验内容:
设计并实现一个简单的磁盘文件管理系统，用文件模拟磁盘，用数组模拟缓冲区。
要求实现:
1.支持多级目录结构，支持文件的绝对路径访问；
2.文件的逻辑结构采用流式（字节流）结构，物理结构采用链式结构中的显式链方式；
3.磁盘管理采用文件分配表；
4.实现文件操作命令：创建目录、列表目录、删除空目录、创建文件、删除文件、显示文件内容、打开文件、读文件、写文件（追加方式）、关闭文件、改变文件属性；
5.通过主函数对所实现的功能进行测试。
完
成
情
况
模拟磁盘的那个文件中存放的信息
开始菜单
正在上传…重新上传取消正在上传…重新上传取消
创建一个新的文件，需要输入已有的路径名
正在上传…重新上传取消正在上传…重新上传取消
Us目录中存放的文件为：
创建多级目录，可以创建不存在的目录列表
新创建的/d1目录中的内容
新创建的/d1/d2目录中的内容
显示文件中的信息，用单个字符的格式输出
往一个文件中追加方式写入
写入后的文件内容
删除前的目录信息
正在上传…重新上传取消正在上传…重新上传取消
删除一个目录/a
正在上传…重新上传取消正在上传…重新上传取消
删除后的目录信息
正在上传…重新上传取消正在上传…重新上传取消
删除不存在文件
正在上传…重新上传取消正在上传…重新上传取消
正在上传…重新上传取消正在上传…重新上传取消
正在上传…重新上传取消正在上传…重新上传取消
删除目录前的信息
正在上传…重新上传取消正在上传…重新上传取消
删除一个目录，这个目录不存在的情况
正在上传…重新上传取消正在上传…重新上传取消
删除目录前的信息
正在上传…重新上传取消正在上传…重新上传取消
删除目录/t
正在上传…重新上传取消正在上传…重新上传取消
删除后的目录内容
正在上传…重新上传取消正在上传…重新上传取消
改变文件的属性：
将普通文件改为系统文件
正在上传…重新上传取消正在上传…重新上传取消
修改后的目录信息
正在上传…重新上传取消正在上传…重新上传取消
显示FAT表中的分配情况
正在上传…重新上传取消正在上传…重新上传取消
主
要
特
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/195f5b42c2853f41a17f514d190bd019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b14aaed8efa86a45f6235070646d691/" rel="bookmark">
			node.js的http-server的安装使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http-server 是一个轻量级的 Node.js HTTP 服务器，它默认情况下不提供任何 JSON 存储功能。它只是简单地将请求的文件作为响应发送给客户端。如果您需要在 http-server 上提供 JSON 数据，则需要将 JSON 数据存储在可通过 HTTP 访问的某个位置（例如本地文件系统或远程 API 端点）上，并在服务器的处理程序中读取该数据并以 JSON 格式返回给客户端。这通常需要编写一些自定义代码来处理 JSON 数据的读取和传输。
在安装完 Node.js 后，您可以使用 npm（Node.js 包管理器）来安装 http-server。在终端或命令提示符中运行以下命令：
npm install -g http-server 这将全局安装 http-server 软件包，并使其可在任何目录下使用。
安装完成后，您可以使用以下命令启动 http-server：
http-server 这将在当前目录中启动 http-server 并将其监听在默认端口 8080 上。您可以在浏览器中访问 http://localhost:8080 来访问您的网站。
http-server 使用说明: http-server [路径] [选项] 选项: -p --port 使用的端口。如果为0，则查找空闲端口。[8080] -a 使用的地址。[0.0.0.0] -d 显示目录列表。[true] -i 显示autoIndex。[true] -g --gzip 尽可能提供gzip格式的文件。[false] -b --brotli 尽可能提供brotli格式的文件。[false] 如果gzip和brotli都启用，则brotli优先。 -e --ext 如果没有提供文件扩展名，则使用的默认文件扩展名。[none] -s --silent 抑制输出日志信息。 --cors[=headers] 通过“Access-Control-Allow-Origin”头启用CORS。可选择提供由逗号分隔的CORS头列表。 -o [路径] 启动服务器后打开浏览器窗口。可以选择提供要在浏览器窗口中打开的URL路径。 -c 缓存时间（最大年龄）（以秒为单位）。默认为[3600]秒。例如，-c10表示10秒。要禁用缓存，请使用-c-1。 -t 连接超时时间（以秒为单位）。默认为[120]秒。例如，-t60表示1分钟。要禁用超时，请使用-t0。 -U --utc 在日志信息中使用UTC时间格式。 --log-ip 启用客户端IP地址的日志记录。 -P --proxy 如果无法解析请求，则返回代理。例如：http://someurl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b14aaed8efa86a45f6235070646d691/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8224283ef77ef474521fc56f4d03c8/" rel="bookmark">
			左手Python 右手R —— 最大公约数和最小公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		左手Python 右手R —— 最大公约数和最小公倍数 前言1、 最大公约数1.1 约数1.2 最大公约数1.3 求解方法 2、 最小公倍数2.1 倍数2.2 最小公倍数2.3 求解方法 3、程序实现3.1 python 代码实现3.2 R语言代码实现 小结创作不易，都浏览到这儿了，看官可否将下面的收藏点赞帮忙点亮。 前言 此专栏为python与R语言对比学习的文章；以通俗易懂的小实验，带领大家深入浅出的理解两种语言的基本语法，并用以实际场景！感谢大家的关注，希望对大家有所帮助。
“博观而约取，厚积而薄发！”谨以此言，望诸君共勉
本文针对数学问题“最大公约数、最小公倍数”进行讲解。具体的项目介绍见下文。
1、 最大公约数 1.1 约数 在讲述最大公约数之前我们先来认识一下什么是约数。约数(又称因数),整数a除以整数b(b≠0) 除得的商正好是整数而没有余数，我们就说a能被b整除，或b能整除a。a称为b的倍数，b称为a的约数。因此不能孤立地说某个整数是约数。
如： 4 = 1 ∗ 4 = 2 ∗ 2 【则称 4 、 2 、 1 是 4 的约数】 4=1*4=2*2 【则称4、2、1是4的约数】 4=1∗4=2∗2【则称4、2、1是4的约数】
6 = 1 ∗ 6 = 2 ∗ 3 【则称 6 、 3 、 2 、 1 是 6 的约数】 6=1*6=2*3 【则称6、3、2、1是6的约数】 6=1∗6=2∗3【则称6、3、2、1是6的约数】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b8224283ef77ef474521fc56f4d03c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9af6a3239eeda807ffa1df5f0e6e614/" rel="bookmark">
			ID3决策树及Python实现（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、划分特征的评价指标：
二、决策树学习算法伪代码：
三、决策树生成实例：
四、Python实现ID3决策树：
一、划分特征的评价指标： 1、信息熵 Ent(D)：
信息熵，是度量样本集合纯度的一种指标，Ent(D)的值越小，则样本集D的纯度越高；
2、信息增益 Gain(D,a)：
信息增益越大，则意味着使用属性a来划分所获得的“纯度提升”越大；ID3决策树算法就是基于信息增益来划分属性，下面介绍ID3决策树的构建过程；
公式中各变量说明：
D：样本集；
y：标签（比如好瓜、坏瓜）；
pk：某一类样本占总样本数的比例；
V：属性的取值（比如纹理属性有3种取值：清晰、稍糊、模糊）；
Dv：属性值==V从样本集D划分出的一个样本子集；
二、决策树学习算法伪代码： 决策树的生成是一个递归的过程，在决策树基本算法中，有三种情形会导致递归返回：
当前结点包含的样本全属于同一类别，无需划分；当前属性集为空，或是所有样本在所有属性上取值相同，无法划分；当前结点包含的样本集合为空，不能划分； 三、决策树生成实例： 3.1 首先获取一个训练样本集D，作为决策树的训练依据：
3.2 计算信息增益：
1、计算信息熵 Ent(D)：
2、计算当前特征集合 {色泽,根蒂,敲声,纹理,脐部,触感} 中各个特征a的信息增益Gain(D,a)：
以“色泽”为例计算Gain(D,色泽)：
色泽的取值：{青绿,乌黑,浅白}，使用“色泽”特征对D划分可以得到3个子集：D1(色泽=青绿)={1,4,6,10,13,17}，D2(色泽=乌黑)={2,3,7,8,9,15}，D1(色泽=浅白)={5,11,12,14,16}，计算划分子集后分支结点的熵 ：
所以，得到Gain(D,色泽)：
同理，计算其他特征的信息增益Gain(D,a)：
3.3 选取最优信息增益，选取最优划分特征：
因为Gain(D,纹理)最大，所以选取“纹理”作为本轮划分的最优划分特征，继而可以得到基于“纹理”的根节点划分：
3.4 决策树算法再对每个分支进一步划分（递归）：
将每个分支可以看成一个新的样本集，进行进一步的划分，在计算各特征信息增益时，需要将上一轮选出的最优特征在样本中去掉，不需要再对该特征进行比较。
就比如D1={1,2,3,4,5,6,8,10,15}，特征集合={色泽,根蒂,敲声,脐部,触感}。基于D1计算出各特征的信息增益Gain(D1,a)：
继续选取最大的特征信息增益，选出最优划分特征，即重复3.3步骤，递归实现决策树的建立；
3.5 生成最终的决策树：
四、Python实现ID3决策树： 总样本集：
['青绿','蜷缩','浊响','清晰','凹陷','硬滑','好瓜'], ['乌黑','蜷缩','沉闷','清晰','凹陷','硬滑','好瓜'], ['乌黑','蜷缩','浊响','清晰','凹陷','硬滑','好瓜'], ['青绿','蜷缩','沉闷','清晰','凹陷','硬滑','好瓜'], ['青绿','稍蜷','浊响','清晰','稍凹','软粘','好瓜'], ['乌黑','稍蜷','浊响','稍糊','稍凹','软粘','好瓜'], ['乌黑','稍蜷','浊响','清晰','稍凹','硬滑','好瓜'], ['浅白','蜷缩','浊响','清晰','凹陷','硬滑','好瓜'], ['浅白','蜷缩','浊响','模糊','平坦','硬滑','坏瓜'], ['乌黑','稍蜷','沉闷','稍糊','稍凹','硬滑','坏瓜'], ['青绿','硬挺','清脆','清晰','平坦','软粘','坏瓜'], ['浅白','蜷缩','浊响','模糊','平坦','软粘','坏瓜'], ['青绿','稍蜷','浊响','稍糊','凹陷','硬滑','坏瓜'], ['浅白','稍蜷','沉闷','稍糊','凹陷','硬滑','坏瓜'], ['浅白','硬挺','清脆','模糊','平坦','硬滑','坏瓜'], ['乌黑','稍蜷','浊响','清晰','稍凹','软粘','坏瓜'], ['青绿','蜷缩','沉闷','稍糊','稍凹','硬滑','坏瓜'] 下面从总样本种提取序号5、12、17为验证集，剩下为训练集进行训练决策树；
（1）训练集：
['青绿','蜷缩','浊响','清晰','凹陷','硬滑','好瓜'], ['乌黑','蜷缩','沉闷','清晰','凹陷','硬滑','好瓜'], ['乌黑','蜷缩','浊响','清晰','凹陷','硬滑','好瓜'], ['青绿','蜷缩','沉闷','清晰','凹陷','硬滑','好瓜'], ['乌黑','稍蜷','浊响','稍糊','稍凹','软粘','好瓜'], ['乌黑','稍蜷','浊响','清晰','稍凹','硬滑','好瓜'], ['浅白','蜷缩','浊响','清晰','凹陷','硬滑','好瓜'], ['浅白','蜷缩','浊响','模糊','平坦','硬滑','坏瓜'], ['乌黑','稍蜷','沉闷','稍糊','稍凹','硬滑','坏瓜'], ['浅白','蜷缩','浊响','模糊','平坦','软粘','坏瓜'], ['青绿','稍蜷','浊响','稍糊','凹陷','硬滑','坏瓜'], ['浅白','稍蜷','沉闷','稍糊','凹陷','硬滑','坏瓜'], ['浅白','硬挺','清脆','模糊','平坦','硬滑','坏瓜'], ['青绿','蜷缩','沉闷','稍糊','稍凹','硬滑','坏瓜'] （2）验证集：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9af6a3239eeda807ffa1df5f0e6e614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d483c7c227058a2caa61c3af8bf8e79f/" rel="bookmark">
			GDOUCTF WEB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web hate eat snake 游戏题找js，将判断语句删掉即可
ezweb 看源码找到/src路由，找到源码
import flask app = flask.Flask(__name__) @app.route('/', methods=['GET']) def index(): return flask.send_file('index.html') @app.route('/src', methods=['GET']) def source(): return flask.send_file('app.py') @app.route('/super-secret-route-nobody-will-guess', methods=['PUT']) def flag(): return open('flag').read() 用PUT方式访问/super-secret-route-nobody-will-guess路由即可
受不了一点 源码
&lt;?php error_reporting(0); header("Content-type:text/html;charset=utf-8"); if(isset($_POST['gdou'])&amp;&amp;isset($_POST['ctf'])){ $b=$_POST['ctf']; $a=$_POST['gdou']; if($_POST['gdou']!=$_POST['ctf'] &amp;&amp; md5($a)===md5($b)){ if(isset($_COOKIE['cookie'])){ if ($_COOKIE['cookie']=='j0k3r'){ if(isset($_GET['aaa']) &amp;&amp; isset($_GET['bbb'])){ $aaa=$_GET['aaa']; $bbb=$_GET['bbb']; if($aaa==114514 &amp;&amp; $bbb==114514 &amp;&amp; $aaa!=$bbb){ $give = 'cancanwordflag'; $get ='hacker!'; if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag'])){ die($give); } if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){ die($get); } foreach ($_POST as $key =&gt; $value) { $$key = $value; } foreach ($_GET as $key =&gt; $value) { $$key = $$value; } echo $f1ag; }else{ echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d483c7c227058a2caa61c3af8bf8e79f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76fbe46401898beb543eaecce9e8411d/" rel="bookmark">
			eBPF动手实践系列一：解构内核源码eBPF样例编译过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：闻茂泉
他山之石 了解和掌握纯c语言的ebpf编译和使用，有助于我们加深对于eBPF技术原理的进一步掌握，也有助于开发符合自己业务需求的高性能的ebpf程序。目前常见和主流的纯c语言的ebpf编译使用方法，主要是两种。一种是内核源码中原生提供的编译方式。另外一种是libbpf-bootstrap项目中提供的skeleton编译方式。libbpf-bootstrap方式和社区5.x以上内核结合的比较好，以后再做介绍，今天我们选择基于4.18内核的基于内核源码的原生编译方式做介绍。
在国内学习ebpf技术，就不得不提到《Linux内核观测技术BPF》书籍译者狄卫华老师。狄老师还有一个网站《深入浅出 eBPF》。在网站里，他专门用一篇文章介绍了基于内核源码方式编译ebpf的方式，文章内容叫《【BPF入门系列-3】BPF 环境搭建》
网址：https://www.ebpf.top/post/ebpf_c_env/
我们今天将参考这篇文章内容，对基于内核源码方式的纯c语言的ebpf编译方式做进一步分析。
获取内核源码 目前主流的服务器的操作系统环境还是以8u + 4.18内核为主。因此，本文以4.18版本内核为主要分析对象。我们提供如下操作系统环境的获取建议：
获取操作系统环境 如果你自己有centos8u兼容环境操作系统，则可以使用已有的环境。如果没有，可以通过阿里云官网购买阿里云主机，选择选择centos8或者anolis8操作系统环境。
$ cat /etc/centos-release CentOS Linux release 8.5.2111 $ uname -r 4.18.0-348.7.1.el8_5.x86_64 获取开源的内核源码 可以使用wget，从aliyun官网镜像，获取开源的4.18内核源码。
$ cd /tmp/$ wget https://mirrors.aliyun.com/linux-kernel/v4.x/linux-4.18. tar.gz$ tar -zxvf linux-4.18.tar.gz$ cd linux-4.18 下载内核源码一定要确保内核版本与操作系统的一致。原因是ebpf会用到VERSION、PATCHLEVEL和SUBLEVEL这3个宏的值与内核做内核版本校验。如果版本传的不对，ebpf校验会失败。
$ cat Makefile | grep -P '^VERSION|^PATCHLEVEL|^SUBLEVEL' VERSION = 4 PATCHLEVEL = 18 SUBLEVEL = 0 初始化基础环境 需要安装ebpf编译时依赖的llvm和clang等rpm包。此外内核编译还需要依赖openssl-devel等rpm包。
$ sudo yum install bison flex openssl-devel $ sudo yum install clang llvm elfutils-libelf-devel 具体每个实验机器的环境可能略有差别，需要根据自己的情况做细节调整。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76fbe46401898beb543eaecce9e8411d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77eb1e860ccf7de6220bab9671bfb41d/" rel="bookmark">
			网络基础架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网络基础架构 1.电脑 （一个单独的计算机所拥有的层：应用层 表示层 介质访问控制层 物理层）
世界上第一台通用计算机“ENIAC”于1946年2月14日在美国宾夕法尼亚大学诞生。
2.OSI七层参考模型（开放式系统互连）---核心思想：分层 （1）应用层 （人机交互---抽象语言的键入和输出） 抽象语言---&gt;编码
（2）表示层 （表示层之下一定是二进制） 编码---&gt;二进制
（3）会话层 应用程序内部地址，区分程序内的各个终端（会话）
上三层和应用程序有关，应用程序处理层面----&gt;统称为应用层
（4）传输层 提供端口号，对数据进行分段（受MTU控制） ，实现端到端，应用到应用之间的传输。由TCP/UDP实现。
（端口号由16位二进制构成，0-65535.---一般不用0作为传输层的端口号，1-1023为注明端口号）
&lt;1&gt; MTU：最大传输单元---默认1500字节
&lt;2&gt; 端口号：0-65535
0-1023---注明端口 1024-65535---高端口（动态端口）
注明端口默认用于固定对应服务器的服务端口；高端口用于随机对应终端上的各个进程
&lt;3&gt; TCP：传输控制协议---面向连接的可靠传输协议 （完成传输层的基本工作之上，还需进一步保障传输的可靠性。）
面向连接：通过TCP三次握手建立端到端的虚链路
可靠传输：4种可靠机制---确认、重传、排序、流控（滑动窗口）
TCP报头：
优点：可靠缺点：占带宽，为达成机制，传输速率会变慢 &lt;4&gt; UDP：用户数据报文协议---非面向连接的不可靠传输协议
仅完成传输层的基本工作---分段和端口号
UDP报头：
UDP传输的过程就类似于寄信，其特点如下：
无连接：知道对端的IP和端口号就直接进行数据传输，不需要建立连接。不可靠：没有确认机制，没有重传机制；如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。 checksum：校验和就是抽样值，检验数据是否完整、正确。
延时要求高用UDP，可靠性要求高用TCP
附：生活中常见服务和对应的端口号以及选择的协议：
例：HTTP（超文本传输协议）端口号是80
（5）网络层 网络层主要应用协议----Internet协议---IP（为路由器服务，与洪泛范围有关）
根据IP地址进行编制寻址：SIP（源IP）；DIP（目标IP）
我们应如何获取目标IP地址？
直接知道服务器的IP地址通过域名访问服务器通过应用程序访问通过广播获取 （6）数据链路层 = LLC + MAC 逻辑访问控制层（LLC） 保障了二层传输的可靠性
介质访问控制层（MAC） 本质：二进制---&gt;电流 （长波为1，短波为0。控制CPU的设备）
MAC：48位二进制构成。
全球唯一格式统一 --- SMAC（源MAC） DMAC（目标MAC） 如何获取MAC地址：ARP协议（地址解析协议）---通过一种地址获取另一种地址
（7）物理层 ---相当于CPU（定义电器电压、光学特性、接口规范）
下四层用来传输数据，负责数据的传递和转发---&gt;统称为数据流层
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77eb1e860ccf7de6220bab9671bfb41d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa3dfc803a8c14b917ec5afe15e4d04/" rel="bookmark">
			芯片验证之后仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是后仿真
通常设计写完RTL后验证人员进行的仿真我们叫做前仿，前仿完成后，后端同事通常会提供两版网表：
1、综合后的网表+PreSTA产生的SDF文件（无net延时，cell延时不准确，时钟树不准确）。
2、布局布线后网表+PostSTA产生的SDF文件（包含布局布线过程中器件延时和线延时的timing信息）。
通常验证在拿到综合后的网表后会进行一次仿真，这一步通常只做纯网表仿真，由于此时SDF文件信息不准确，一般不会进行SDF仿真。在验证进行纯网表仿真的同时，后端会进行布局布线，并将布局布线过程中器件延时和线延时的timing信息提取出来，生成SDF文件，然后后端将PR后网表和SDF文件给到验证，此时一般会再基于新版本网表进行纯网表仿真（如果期间网表无变化也可省去）和加入SDF的网表仿真。我们通常将纯网表仿真和加入SDF时序信息的网表仿真统称为后仿真。
二、后仿真的意义
后端一般会进行静态时序分析（STA），静态时序分析根据一定的模型从网表中创建无向图，计算路径延迟的总和，如果所有的路径都满足时序约束和规范，那么认为电路设计满足时序约束规范。静态时序分析的方法不依赖于激励，且可以穷尽所有路径，运行速度很快，占用内存很少。对于同步设计电路，可以借助于静态时序分析工具完成时序验证的任务，但是不能对异步电路进行时序分析。所以如果设计中存在异步电路，就要借助于后仿真。
后仿真主要意义在于：
1、确认异步路径、multi cycle path、false path。
2、功能仿真不包含的信息，如DFT插入的扫描链，或者基于工艺单元的功耗评估以及时序信息等。
3、检查时序约束（SDC）的正确性，防止约束错误。
4、检查网表的完备性，防止综合、布局布线过程中的意外错误。
5、为后续流程如功耗分析、IR drop分析提供波形（后仿波形分析更准确）。
6、完整的系统初始化上电处理流程和复位流程，尤其是面对系统中存在不定态的情况。
由于后仿真较为耗时，一般不会将所有的前仿case都进行后仿，通常的做法是挑出一部分进行后仿即可，而case的挑选可以基于以上几点，将有风险的case挑选出来进行仿真。
三、后仿真如何进行
后仿真主要分为两部分，纯网表仿真和加SDF延时文件的网表仿真。
纯网表仿真主要是为了检查前仿RTL和综合后的网表行为的一致性，因为纯网表仿真虽然也耗时间，但是相对于SDF仿真，仿真时间还是可控的。如果一开始直接进行SDF仿真，当环境问题较多时，单个case要跑多次才会收敛，对于单次仿真时间动辄好几天的SDF仿真来说，无疑效率极其低下。所以一般会先进行纯网表仿真，排除一些简单的问题，然后再进行SDF仿真，这样可以加速仿真收敛时间。
四、纯网表仿真
纯网表仿真如何进行呢？
1、需要将RTL的code路径改为后端提供的网表路径。
2、纯网表仿真时需要添加以下参数：
+nospecify：Supress module path delays and timing checks in specify blocks. So post simulation with SDF must remove this option.
notimingcheck：时序检查开关，比如setup/hold/width检查等等，如使用了该option，则仿真时不检查时序，行为类似于RTL仿真。在PR未结束，sdf反标文件还没准备好时，可用该选项忽略延时，可用于功能性的粗略检查。
+delay_model_zero：将标准单元中定义的延时替换为0。
3、环境调整
环境调整又可以分为几种类型：
a、无复位端寄存器
网表内部难免有些寄存器是没有复位端的，而这些寄存器的Q端在系统复位完后还是处于X态，一旦时钟跑起来，这些X态就有可能传播出去，对仿真产生影响。因此，在项目实践中，可以让后端提供一个 no reset reg list, 他们可以用脚本非常方便的提取出来。有了这样一个list后，我们在后仿中可以利用+vcs+initreg+config+config_file，对这些没有复位端的寄存器进行初始化，config_file的写法比较简单，网上有很多教程，也可以参考VCS手册。
b、顶层端口信号
顶层的端口信号不能是不定态，要根据芯片实际情况，force为特定值，否则仿真时X态会传播，有可能导致仿真失败。
c、memory
一般可以将memory初始化为随机值（data+ecc都要初始化成随机值），防止读memory时读出X态，导致仿真失败。如果系统能保证在读memory操作前有相应地址的写操作，也可以不初始化。
d、case中的信号调整
因为网表中某些信号的层次相对前仿会有所调整，所以后仿时环境中引用的DUT内部信号需要根据后仿网表层次进行调整，一般选择用POSTSIM宏做隔离，否则编译会报错。
在后仿网表中很多地方如果路径太长，一般会加入buffer和成对的inverter，如果case中某些信号是处于成对的inverter之间，则此信号的值和前仿的值刚好相反，相应的，对此信号做的一些判断和逻辑也要相应调整。
五、SDF仿真
加SDF文件的网表仿真需要进行SDF反标，SDF文件中通常有min，typical，max三组时序值，再仿真器读入SDF的时候，要指定使用哪一组。通常我们只使用min和max两种极端情况进行仿真。常用的SDF反标方式如下：
module sdf_annotate; initial begin `ifdef MAX_DELAY $sdf_annotate("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aa3dfc803a8c14b917ec5afe15e4d04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce212fbc10cca713c85a892378abf411/" rel="bookmark">
			解决input输入框按下enter键会刷新页面得问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/350fb64fbeca8acb83bb3025fc3a5005/" rel="bookmark">
			win下jps查看不到java进出（亲自操作有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win下，jps看不到java进程，主要原因是：没有hsperfdata_用户名 文件夹权限。
hsperfdata_用户名文件夹路径：C:\Users\userid\AppData\Local\Temp\hsperfdata_userid
找到hsperfdata_XXX文件后，点击属性，切换到安全，可以看到组或者用户名
如下：
给admin用户（当前系统登录用户）赋权，确定后成功。
结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b0210dc49e1e43d8f257410ea8f50bd/" rel="bookmark">
			php使用grpc方式调用golang服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		proto协议 syntax = "proto3"; package service; option go_package = "hello_grpc"; service Greeter { rpc SayHello (HelloRequest) returns (HelloReply) {} } message HelloRequest { string name = 1; } message HelloReply { string message = 1; } 目录结构 生成命令相关工具windows版本私信 go版本文件生成 进入目录到 learn001中
protoc -I pb/ pb/hello_grpc.proto --go_out=plugins=grpc:service -I 后面指定proto文件存放目录，和proto文件–_out 这里为目标语言，这里为goservice 为 生成的目录，以上截图可以看到最终生成的service下存在一个.go文件 go服务端 package main import ( "context" "fmt" "google.golang.org/grpc" "google.golang.org/grpc/reflection" service "learn001/service" "net" ) type server struct{} func (s *server) SayHello(ctx context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b0210dc49e1e43d8f257410ea8f50bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e4e9baadd598f3ae29b88491b89574f/" rel="bookmark">
			DoIP诊断技术一点通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DoIP的全称是Diagnostic Over Internet Protocol，即基于TCP/IP协议的诊断协议。
随着以太网技术在车载领域的应用范围逐步扩大，越来越多的控制器支持通过以太网进行诊断通信，由于采用以太网通信技术，DoIP诊断具有超高的数据传输速率，速率达到了100 Mbit/s，相较于CAN总线诊断，DoIP诊断总体速率是CAN诊断的100-200倍，网络上的传输速率是CAN诊断的300-400倍。并且硬件成本低，无需使用VCI，在个人电脑上只需要一个以太网接口即可实现诊断的物理连接。DoIP技术可以完美匹配IT基础设施，固定诊断和远程诊断均能应用，车载以太网技术将是未来解决如何快速更新ECU软件及标定的主要策略之一。
DoIP诊断应用场景 场景1：单一诊断仪与车辆直连
诊断仪与车辆直连后，可以诊断单车所有DoIP节点，一般用于单车故障诊断或者ECU升级刷写等功能。
场景2：多台诊断仪并行诊断单台车辆
多台诊断仪通过交换机级联，诊断同一台汽车，各诊断信道互不干扰，可实现多团队同时作业，提高整体工作效率。
场景3：单诊断仪并行诊断多台车辆
多台车辆通过交换机级联，一台诊断仪可与这些车辆建立多个并行的诊断连接。相较于传统的CAN诊断，DoIP诊断有独有的机制，用于标识每一辆汽车及车载的各个ECU单元。单诊断仪连接多台车辆的形式一般用于产线上生产监控及ECU刷写等。
车内诊断网络布局 以上我们简要阐述了一般的应用场景，那么接下来我们走进车内网络，看看外部诊断仪是如何与车内ECU之间建立诊断连接。
下图摘自DoIP协议标准文档ISO-13400-2，我们将围绕这张图来进行说明。
图中分为车内网（Vehicle network）和车外网（External network），车内网和车外网之间，有两组重要的线束：
一组是用于数据传输的以太网线另一组是用于诊断功能激活的激活线 以太网线就是我们常见的四线制TX标准网线。
而激活线的设计，是用于车内诊断功能的激活。
处于能耗和电磁干扰的考虑，要求非诊断通信期间，与诊断相关的功能处于关闭状态，这样一方面可以降低能耗，另一方面减少对网络带宽的消耗，从而降低电磁干扰。
车内网中，直接与外部诊断仪进行物理连接的节点，叫做边缘节点（DoIP edge node）。边缘节点可作为一个网络交换机，将车内网与车外网组成同一子网；也可以作为一个网关，将车内网与车外网进行安全隔离，屏蔽非法的网络访问和网络攻击。
除了边缘节点之外，还有另一类网关，即车内的DoIP网关节点。
车内DoIP网关节点的作用，是实现以太网到其他网络总线（如CAN、LIN）的报文路由，这样便实现了DoIP诊断与传统网络总线的兼容。多种网络总线汇聚到DoIP网关，这大大的降低了布线的复杂性，并且提高了各总线网络中ECU的诊断效率。
车内网络中，还存在一般的DoIP节点，这些节点只支持对自身的诊断，而不具备路由功能。最后，还有一类网络节点（Network node），不具备DoIP诊断功能，与DoIP节点共享网络资源。
在车内网络中，各DoIP网关和DoIP节点可以全部级联于DoIP边缘节点，也可以分布于多个交换机网络，但最终都可以被边缘节点直接访问到。
对于边缘节点，人们经常通常有以上的疑问，其实透传和非透传这两种方案，没有好坏之分，都有各自适合的应用场景。
例如，连接的外接诊断仪，主要用于多车故障诊断和ECU刷写，为了实现快速的ECU访问和在线监测，要求车内各ECU享有唯一的IP地址，适合使用透传方案。若连接的是TBOX之类具有联网功能控制单元，为了避免车内网受到外部网络攻击，因此适合使用非透传方案。
DoIP协议的主要功能
DoIP协议栈作为以太网诊断软件架构的中间件，主要具备如下五大功能，这五大功能体现了DoIP诊断的特殊性，是区别于传统CAN诊断的重要特征。
接下来我们按照DoIP诊断从连接建立到诊断通信实施的流程，对各个功能模块进行简要讲解。
1、车辆发现 顾名思义，就是用来检测车辆是否在线，具体来说就是诊断仪首先发送一个广播的车辆发现报文，网络中所有接收到这条报文的ECU都将发送自己的身份信息。通过各个ECU发回的身份信息，诊断仪便可以准确得获知有哪些ECU在线，并且可以根据这些信息对这些ECU进行归类，比如各自属于那一台汽车。
2、路由激活 与传统意义上网关的“路由”不同，DoIP协议中的“路由”指的是诊断仪与被诊断节点之间的报文传输。
外部测试仪与DoIP节点之间的通信连接建立之后，应发送路由激活请求，路由激活请求被DoIP节点验证合法之后，诊断仪才能对ECU进行诊断。路由激活包含了DoIP节点对外部诊断仪的安全认证过程，ECU开发人员可以自定义安全认证的算法，用于屏蔽非法诊断仪对ECU进行的诊断。
3、诊断仪在线监测 与传统CAN总线不同，DoIP诊断需要预先与ECU建立通信连接，也就是TCP socket。
由于socket的建立会消耗内存资源，因此不能无限制创建连接。ECU在设计阶段，会定义最多能支持并行连接的诊断仪数量，并行连接的诊断仪数量达到上限之后，将无法建立新的诊断通信连接。因此这些诊断连接通道属于稀缺的资源，为了避免通道被无效占用，因此设计了诊断仪在线监测机制。DoIP节点会向现在有的诊断连接通道上，发送诊断仪在线监测请求，若有的连接上无法收到诊断仪回复的响应报文，则会将此连接复位，以待新的诊断仪接入。
4、节点信息 节点信息包含了节点的属性，例如如最大支持的并行诊断仪连接数量，最大可接受的诊断报文长度，以及当前节点的电源状态，即是否所有部件都完成上电。节点信息作为诊断通信前的诊断条件检查，以确保后续诊断通信不受外部因素干扰。
5、诊断通信 作为DoIP协议的核心功能，此功能负责诊断报文的传输。诊断报文中包含三个信息，
诊断报文发送方的逻辑地址（以下简称SA）诊断报文接收方的逻辑地址（以下简称DA）作用相当于CANID诊断数据 在CAN总线网络中，通过CANID来寻址要诊断的ECU
而在DoIP网络中，诊断报文接收方的逻辑地址的作用相当于CANID，用于寻址要诊断的目的ECU。下图通过一个以太网转CAN的诊断示例，展示SA和DA在诊断通信中的作用。
6、扩展一下： 以上介绍了DoIP诊断规范中的网络拓扑和软件功能，在实际软件开发过程中，还会涉及到诸多的技术细节，例如：
边缘节点透传与非透传方案设计；DoIP节点间IP地址分配策略，即静态IP或者动态IP的选择；各节点间GID(节点分组ID)同步策略设计；路由激活安全认证策略设计等。 针对DoIP诊断技术需求，东信创智可以提供以下三种服务模式：
DoIP协议培训服务；商用DoIP协议栈（如vector的microsar协议栈）集成和软件配置服务；DoIP网关样件，可以用于技术验证和诊断测试。 https://zhuanlan.zhihu.com/p/427437371https://zhuanlan.zhihu.com/p/427437371
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868111f7195964fd5462ee8d9fd6d31d/" rel="bookmark">
			AndroidNDK开发——使用Cmake编译生成so文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 AndroidNDK开发——使用Cmake编译生成so文件1.添加Cmake文件：2.添加Cmake依赖：3.jni文件如下：4.Android.mk文件：5.Application.mk文件6.SerialPort.c文件：7.SerialPort.h文件：8.运行项目：9.项目中引入so文件：10.Java调用so的测试代码如下：11.运行效果如下：12.打印日志如下：13.总结：14.项目源码如下： AndroidNDK开发——使用Cmake编译生成so文件 最近做串口开发需要编译不同的so文件，于是查找了各种资料，学习了一下so编译.
1.添加Cmake文件： cmake_minimum_required(VERSION 3.4.1) //cmake版本 include_directories(src/main/jni/serial_port) //引入的jni文件路径 aux_source_directory(src/main/jni SRC_FILE)	//src文件路径 add_library(serial_port SHARED ${SRC_FILE}) find_library(log-lib log) target_link_libraries(serial_port ${log-lib}) 2.添加Cmake依赖： externalNativeBuild { cmake { cppFlags "" abiFilters "arm64-v8a","armeabi-v7a"//生成的so平台类型 } } externalNativeBuild { cmake { path 'CMakeLists.txt'//Cmake地址 } } 3.jni文件如下： 4.Android.mk文件： # # Copyright 2009 Cedric Priscal # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/868111f7195964fd5462ee8d9fd6d31d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b201d3948434952fa389309f30c29b/" rel="bookmark">
			ESP32开发：从入门到精通的全面指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP32开发：从入门到精通的全面指南 ESP32 是一款功能强大的微控制器，它可以帮助开发者构建各种物联网（IoT）应用。ESP32 拥有 WiFi 和蓝牙无线连接功能，并且可以轻松地与各种传感器和设备进行通信。本文将介绍 ESP32 的基本知识和常用开发工具，以及如何开始 ESP32 的开发。
第一部分：ESP32 入门
ESP32 是一款基于 Xtensa® 双核 32 位处理器的微控制器，它支持 WiFi 和蓝牙无线连接，具有低功耗和高性能。ESP32 还拥有大量的 GPIO 引脚，可以轻松连接各种外部设备。要开始使用 ESP32 进行开发，您需要一些基本知识：
熟悉 C/C++ 编程语言。
了解电子电路和传感器的基本知识。
掌握基本的无线网络知识，包括 WiFi 和蓝牙。
第二部分：ESP32 开发工具
为了开始 ESP32 开发，您需要准备一些必要的开发工具：
ESP-IDF 开发框架：这是 ESP32 官方开发框架，提供了许多开发工具和示例代码。
Eclipse IDE：这是一款功能强大的集成开发环境，可以帮助您更轻松地编写代码和调试应用程序。
Arduino IDE：如果您熟悉 Arduino 开发，可以使用 Arduino IDE 来编写 ESP32 应用程序。
Git：这是一款版本控制工具，可以帮助您更好地管理代码。
第三部分：ESP32 开发示例
为了更好地了解如何使用 ESP32 进行开发，我们将介绍一些常用的 ESP32 开发示例：
WiFi 连接：ESP32 可以轻松连接到 WiFi 网络。您可以使用 ESP-IDF 提供的 WiFi 示例代码来开始连接 WiFi。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6b201d3948434952fa389309f30c29b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/92/">«</a>
	<span class="pagination__item pagination__item--current">93/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/94/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>