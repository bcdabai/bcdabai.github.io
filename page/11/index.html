<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da4ce81ccdc3d1e8207b89d8e58d5252/" rel="bookmark">
			【算法系列】一文彻底讲懂隐马尔可夫模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 视频讲解在我女朋友的B站『你真的理解隐马尔可夫链吗？隐马尔可夫最通俗易懂的解释』
马尔科夫链或者马尔科夫性是一个非常重要的数学概念，大家在做科研或者学习过程中或多或少都听过，马尔科夫性在SLAM问题中也是非常重要的，iSAM中的因子图也是在此基础上改进而来。很多人觉得这是一个非常复杂、难懂的概念，特别是它的一些相关概念，性质，包括前向后向算法等等。
本篇文章将为大家详细讲解马尔科夫链、马尔科夫性、以及隐马尔可夫链的相关概念和问题，下一篇文章将会以一种通俗易懂的方式，为大家讲解隐马尔可夫链的前向后向算法和维特比算法。
一、贝叶斯网络 在讲解马尔科夫链之前，我们先简单了解一下贝叶斯网络，因为这是推广到马尔科夫链的基础。
贝叶斯网络是一种用图模型表示随机变量之间概率关系的工具。它基于贝叶斯定理，用有向无环图（DAG）来表示变量之间的依赖关系，并通过概率分布来描述这些依赖关系。
在一个贝叶斯网络中：
节点表示一个或一组随机变量边表示变量之间的依赖关系 每个节点都与一个概率分布相关，该分布描述了给定其父节点值时该节点的条件概率分布。这种图形模型的结构使得我们可以通过已知信息来更新对未知变量的信念。
比如这个贝叶斯网络中，表示x2依赖于x1，x5依赖于x2和x3等等。
二、马尔科夫链 1.直观理解 马尔可夫链是一个数学概念，描述了在一系列离散事件中，从一个状态转移到另一个状态的过程。
该过程满足马尔科夫性质，即当前时刻的状态只依赖于前一时刻的状态，与更久之前的状态无关。这意味着在给定当前状态的情况下，未来的发展不受过去的影响。
马尔可夫链可以用状态空间和状态转移概率来表示。状态空间是所有可能的状态的集合，而状态转移概率描述了从一个状态到另一个状态的概率。
这个例子中，我们要观察快餐店供应什么食物，其中，每天供应的食物与前一天有关，比如今天供应了汉堡，那么明天则有0.2的概率还供应汉堡，0.6的概率供应披萨，0.2的概率供应热狗。
2.基本概念 （1）状态转移矩阵 状态转移矩阵是将每种状态(当天食物)转移到下一状态(明天食物)的概率表示为矩阵的形式，我们用A表示，那么上图的状态转移矩阵可以表示为：
A = [ 0.2 0.6 0.2 0.3 0 0.7 0.5 0 0.5 ] A=\left[ \begin{matrix} 0.2&amp; 0.6&amp; 0.2\\ 0.3&amp; 0&amp; 0.7\\ 0.5&amp; 0&amp; 0.5\\ \end{matrix} \right] A= ​0.20.30.5​0.600​0.20.70.5​ ​
第0行第0列表示：第0个状态(当天供应汉堡)转移到第0个状态(明天继续供应汉堡)的概率；
第2行第1列表示：第2个状态(当天供应热狗)转移到第1个状态(明天供应披萨)的概率，图中没有相应的有向边，因此值为0。
（2）稳态(初始状态概率向量) 初始状态概率向量的意义是，当我们某一天突然走进这个快餐店时，它会供应什么食物呢？或者说它供应每种食物的概率是多少呢？
我们在这个马尔科夫链上做随机漫步，漫步的次数足够多时，每一种食物供应的概率会趋于一个稳态，对这个概念有一种很直观的解释：
比如第一天供应披萨，那么对应的状态为[0,1,0]，那么我们做一次随机漫步，明天供应汉堡和热狗的概率是多少呢？我们可以用这个向量乘以转移矩阵A：
这与图中相对应，那么我们一直做随机漫步，当次数趋于无穷时，如果这个稳态真的存在，那么我们最终会达到这个稳态，得到的状态概率向量不再发生变化，这个过程可以表示为：
π A = π \pi A = \pi πA=π
有没有发现这个式子很像矩阵A的特征方程，这就说明，如果稳态真的存在，我们可以对A进行特征值分解，找到特征值1对应的特征向量，那么我们就可以求解出这个稳态。
三、隐马尔可夫链 我们上面讲的马尔科夫链，是所有状态都可以观测到，但实际上，我们可能并不能直接观测到(或准确观测到)对象的状态，只能通过一些传感器的测量间接的反应对象状态；
比如SLAM问题中，我们很难精确地观测到机器人的位置(状态)，只能得到一些传感器的观测值(坐标点)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da4ce81ccdc3d1e8207b89d8e58d5252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/722f7791f6e71f563d554c0dfdf14fd8/" rel="bookmark">
			PyTorch 内 LibTorch/TorchScript 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyTorch 内 LibTorch/TorchScript 的使用 1. .pt .pth .bin .onnx 格式1.1 模型的保存与加载到底在做什么？1.2 为什么要约定格式？1.3 格式汇总1.3.1 .pt .pth 格式1.3.2 .bin 格式1.3.3 直接保存完整模型1.3.4 .onnx 格式1.3.5 jit.trace1.3.6 jit.script 1.4 总结 2. TorchScript 的转换2.1 jit trace 注意事项2.2 jit trace 验证技巧2.3 混合使用 trace 和 script2.4 trace 和 script 的性能2.5 总结 3. LibTorch 的使用3.1 LibTorch 的链接3.2 接口和实现 Reference：
[Pytorch].pth转.pt文件Pytorch格式 .pt .pth .bin .onnx 详解pytorch 基于tracing/script方式转ONNX 1. .pt .pth .bin .onnx 格式 1.1 模型的保存与加载到底在做什么？ 我们在使用pytorch构建模型并且训练完成后，下一步要做的就是把这个模型放到实际场景中应用，或者是分享给其他人学习、研究、使用。因此，我们开始思考一个问题，提供哪些模型信息，能够让对方能够完全复现我们的模型？
模型代码： 包含了我们如何定义模型的结构，包括模型有多少层/每层有多少神经元等等信息；包含了我们如何定义的训练过程，包括epoch batch_size等参数；包含了我们如何加载数据和使用；包含了我们如何测试评估模型。 模型参数：提供了模型代码之后，对方确实能够复现模型，但是运行的参数需要重新训练才能得到，而没有办法在我们的模型参数基础上继续训练，因此对方还希望我们能够把模型的参数也保存下来给对方。 包含model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/722f7791f6e71f563d554c0dfdf14fd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be32e350f20ac75906b773bb2e572bf/" rel="bookmark">
			Pycharm连接远程服务器遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题一 pycharm always "uploading pycharm helpers" to same remote python interpreter when starts问题二 [Errno 2] No such file or directory/root/miniconda3/bin/python: can't open file'/root/. pycharm helpers/virtualenv-20. 24.5.pyz': 根据大佬的教程很快就配置了一半了，可是，pycharm配置服务器环境直接给我卡住了
本地Pycharm连接远程服务器详细配置过程（直接在本地使用服务器显卡，很棒）
问题一 pycharm always “uploading pycharm helpers” to same remote python interpreter when starts 似乎PyCharm在远程帮助程序文件夹中创建了一个build.txt文件，该文件仅包含当前的PyCharm内部版本号作为其内容，例如
PY-232.10072.31 需要将你pycharm中build.txt,与服务器中root/.pycharm_helpers中build.txt版本号相同
问题二 [Errno 2] No such file or directory/root/miniconda3/bin/python: can’t open file’/root/. pycharm helpers/virtualenv-20. 24.5.pyz’: 发现无法打开virtualenv-20.24.5.pyz这个文件，其实发现pycharm_helpers里没有这个文件，解决方式就是删除pycharm_helpers这个文件，然后重新下载
还有就是Location要选择的时env下载的第三方库包，默认的话就要选择System Interpreter
新版pycharm配置https://blog.csdn.net/weixin_44984671/article/details/129309805
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c69247c1e3ba686cedec59797d0e08/" rel="bookmark">
			Visual studio setup.exe 安装vs2022报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visualstudiosetup.exe 安装vs2022编辑器，在win7专业版64位系统（纯净版），报错：无法找到入口
具体内容如下：
无法定位程序输入点SetDefaultDllDirectories于动态链接库Kernel32.dll上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a97af9cd9ed6142b29ce31f4a518de16/" rel="bookmark">
			VUE3的父子数据交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE3 支持多个V-model的形式绑定
这里展示代码和需要说明的地方：
父组件
&lt;LoginDialog v-model:dialogVisible="isDialogVisible" /&gt; 注意的地方：v-model:dialogVisible="isDialogVisible"
其实就可以简单的理解为：key-&gt;value
dialogVisible，这个就是自定义命名的key
isDialogVisible，这个就是一个变量value
子组件
&lt;template&gt; &lt;el-dialog v-model="localDialogVisible"&gt; 123456 &lt;/el-dialog&gt; &lt;/template&gt; &lt;script&gt; export default { props: { dialogVisible: Boolean }, computed: { localDialogVisible: { get() { return this.dialogVisible; }, set(value) { this.$emit('update:dialogVisible', value); } } } }; &lt;/script&gt; props：就是承接父组件过来的数据，既然数据过来了，为什么不直接使用v-model="dialogVisible"? 岂不是更加简单
因为规定props是单项传递，只能接受不能修改，所以这里使用另外一个变量来保存并修改，这里我们使用了 localDialogVisible。
this.$emit('update:dialogVisible', value); 这一段就是将修改后的数据传递回父组件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e92c90047e6d62daa328aad88eaa0d/" rel="bookmark">
			Java网络编程-16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网络层级
import java.net.InetAddress; import java.net.UnknownHostException; //测试IP public class Demo { public static void main(String[] args) throws UnknownHostException { //查询本机地址 InetAddress inetAddress = InetAddress.getByName("127.0.0.1"); System.out.println(inetAddress); //查询网站ip地址 InetAddress inetAddress2 = InetAddress.getByName("www.baidu.com"); System.out.println(inetAddress2); //常用方法 System.out.println(inetAddress2.getHostAddress());//IP System.out.println(inetAddress2.getHostName());//域名 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20360e5a604c773c10c44d0b753199cd/" rel="bookmark">
			Android 通过adb命令查看应用流量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 获取应用pid号 通过adb shell ps -A | grep 包名 来获取app的 pid号
二. 查看应用流量情况 使用adb shell cat /proc/#pid#/net/dev 命令 来获取流量数据
备注：
Recevice: 表示收包
Transmit: 表示发包
bytes: 表示收发的字节数
packets: 表示收发正确的包量
errs: 表示收发错误的包量
drop: 表示收发丢弃的包量
wlan0： 表示代表的是wlan端口，wifi流量就是用的这个Interface
三. 计算使用流量 1. 先记录此时的流量情况
2. 然后操作业务场景，再记录一次流量情况
3. 前后数据相减就得到了流量使用，这里用的单位是byte 然后换成M(兆)即可
四. 网络流量诊断情况 指定 netstats 服务可提供自设备上次启动以来收集的网络使用情况统计信息。若要输出额外信息，如详细的唯一用户 ID (UID) 信息，请包含 detail 选项，如下所示：
#查看设备开机以来各应用流量的使用情况 adb shell dumpsys netstats detail #查看各应用历史流量使用情况 adb shell dumpsys netstats --full --uid --tag 输出内容因连接的设备上搭载的 Android 版本不同而异。以下部分介绍您通常会看到的信息类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20360e5a604c773c10c44d0b753199cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34ceea079090f066d5a5f7a8559369b7/" rel="bookmark">
			深入理解Rust函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述二、函数要点三、函数参数四、函数返回五、Rust中的特殊返回类型5.1、无返回值5.2、永不返回的发散函数 团队博客: 汽车电子社区
一、概述 二、函数要点 1、函数名和变量名使用蛇形命名法(snake case)，例如 fn add_two() -&gt; {}。
2、函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可。
3、每个函数参数都需要标注类型。
三、函数参数 Rust 是强类型语言，因此需要你为每一个函数参数都标识出它的具体类型，例如：
fn main() { another_function(5, 6.1); } fn another_function(x: i32, y: f32) { println!("The value of x is: {}", x); println!("The value of y is: {}", y); } 四、函数返回 在 Rust 中函数就是表达式，因此我们可以把函数的返回值直接赋给调用者。
函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用 return 提前返回，下面的函数使用最后一条表达式来返回一个值：
fn plus_five(x:i32) -&gt; i32 { x + 5 } fn main() { let x = plus_five(5); println!("The value of x is: {}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34ceea079090f066d5a5f7a8559369b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf10b18fbf338019051b4a964651c1b6/" rel="bookmark">
			不同开发语言在进程、线程和协程的设计差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同开发语言在进程、线程和协程的设计差异 1. 进程、线程和协程上的差异1.1 进程、线程、协程的定义1.2 进程、线程、协程的差异1.3 进程、线程、协程的内存成本1.4 进程、线程、协程的切换成本 2. 线程、协程之间的通信和协作方式2.1 python如何实现线程通信？2.2 java如何实现线程通信？2.3 go如何实现线程通信？ 3. 常用线程池的实现和使用方式3.1 python常用线程池3.2 java常用线程池3.3 go常用线程池 4. 疑问和思考4.1 go语言中，协程的成本已经很低，还有必要使用线程池吗？ 5. 参考文档 在多线程项目开发时，最常用、最常遇到的问题是
1，线程、协程安全
2，线程、协程间的通信和控制
本文主要探讨不同开发语言go、java、python在进程、线程和协程上的设计和开发方式的异同。
1. 进程、线程和协程上的差异 1.1 进程、线程、协程的定义 进程
进程是操作系统进行资源分配的基本单位，每个进程都有自己的独立内存空间，不同的进程之间无法相互干扰。由于进程比较重，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
线程
线程又叫做轻量级进程，是进程的一个实体，是处理器任务调度和执行的基本单位位（能够申请到cpu资源执行相关任务）。它是比进程更小的能独立运行的基本单位。线程只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
线程的执行需要申请对应的cpu资源，因此线程切换涉及CPU的资源切换（保存cpu上下文、触发软中断暂停当前线程、从就绪线程中选择一个执行），过程中会涉及用户态 -&gt; 内核态（切换cpu）-&gt; 用户态的切换，因此开销比较大。
协程
协程，又称微线程，是一种用户态的轻量级线程，协程的调度完全由用户控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，所以上下文的切换非常快（协程切换，线程不变，因此不需要切换cpu，不进行内核态切换，成本较低）。
进程、线程、协程之间的关系可以如下图诠释
1.2 进程、线程、协程的差异 线程进程的区别：
根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位，cpu运行任务是运行线程资源开销：每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一进程的线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。两者均可并发执行。 协程与线程的区别：
一个线程可以有多个协程。大多数业务场景下，线程进程可以看做是同步机制，而协程则是异步。线程是抢占式，而协程是非抢占式的，所以需要用户代码释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。协程并不是取代线程，而且抽象于线程之上。线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行。 1.3 进程、线程、协程的内存成本 进程占用内存
32 位操作系统只支持 4G 内存的内存条，这是因为进程在 32 位操作系统中最多只能占用 4G 内存在 64 位操作系统中可以占用更多内存。 线程占用内存
一般是 10MB，不同的操作系统版本之间有些差异，区间在 4M - 64M。 协程占用内
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf10b18fbf338019051b4a964651c1b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3c8a26ab2368d000a32d8f1bdf9179/" rel="bookmark">
			opencv#30 线性滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		均值滤波原理 均值滤波步骤 Step1:求和。
Step2:计算平均值。
所谓均值滤波，就是求平均值的意思。我们假设在一个3*3的范围内有一个图像，其中这个图像每一个像素可能含有噪声，也可能不含噪声，我们是不知道的，因此通过均值滤波的方式，对图像中所有像素进行求和，并除以像素个数，得到的结果就是滤波后的结果，将3*3区域的中心位置更改为滤波后的平均值，这样的过程就是均值滤波。
均值滤波和图像的卷积操作相类似，它们都是在原图像中将每一个像素分别覆盖滤波模板，也可称为滤波器，覆盖原图像后求取平均值，放入中心区域作为滤波结果，然后移动滤波器，使滤波器能够覆盖图像的每一个位置。对于上图3*3的矩阵来说，其中每一个位置都乘了1，也就是说它进行卷积的模板是一个3*3的矩阵，此矩阵中的值都为1，之后又除以了和，因此它的卷积模板（滤波器）就是一个1/9乘全为1的矩阵（3*3）。
均值滤波函数 blur() void cv::blur(InuputArray src, OutputArray dst, Size ksize, Point anchor = Point(-1,-1), int borderType = BORDER_DEFAULT ) ·src:待均值滤波的图像，图像数据类型必须是CV_8U,CV_16U,CV_16S,CV_32F和CV_64F这五种数据类型之一。均值滤波输出的结果的数据类型与输入图像的数据类型保持一致。
·dst:均值滤波后的图像，与输入图像具有相同的尺寸和数据类型。
·ksize:卷积核尺寸（滤波器尺寸：常用的是奇数正方形）。因为均值滤波中，滤波器中的每一位参数值是恒定的，因此这里面我们只需给出其尺寸即可。
·anchor:内核的基准点（锚点），其默认值为（-1，-1）代表内核基准点位于kernel的中心位置。·borderType:像素外推法选择标志。
方框滤波函数 boxFilter() void cv::boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor = Point(-1,-1), bool normalize = true, int borderType = BORDER_DEFAULT ) 方框滤波函数与均值滤波其实是等价的，只不过方框滤波运行滤波器不进行归一化，但是在均值滤波中是强制进行归一化的。 由于方框滤波是一个求和的参数，可能会出现255+255+255+....很多个255相加，最终超出255范围的情况，因此第三个参数运行用户设定输出图像的数据类型，也就是输出图像的数据类型可以与输入图像不同，但是尺寸和通道数是一致的。
·src:输入图像。
·dst:输出图像，与输入图像具有相同的尺寸和通道数。
·ddepth:输出图像的数据类型（深度），根据输入图像的数据类型不同拥有不同的取值范围。
·ksize:卷积核尺寸。
·anchor:内核的基准点（锚点），其默认值为（-1，-1）代表内核基准点位于kernel的中心位置。
·normalize:是否将卷积核进行归一化的标志，默认参数为true，表示进行归一化（在矩阵前面乘所有数值之和）。
·borderType:像素外推法选择标志。
高斯滤波原理 高斯滤波也就是滤波器是一个高斯分布的形式，如上图所示，滤波器中中间的像素值较大，而四周像素值较小的情况，是一个中心对称的滤波器。若以这样的滤波器作为卷积核与原图像进行卷积操作的时候，得到的就是一个高斯滤波之后的结果 。
高斯滤波函数 GaussianBlur() void cv::GaussianBlur(InputArray src, OutputArray dst, Size xsize, double sigmaX, double sigmaY = 0, int borderType = BORDER_DEFAULT ) ·src:待高斯滤波图像，数据类型必须为CV_8U,CV_16U,CV_16S,CV_32F或CV_64F。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3c8a26ab2368d000a32d8f1bdf9179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61dfaafcf6c38df95625d1377f79dbfb/" rel="bookmark">
			Java - 单元测试及Junit的使用讲解及练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🐶2.1 什么是单元测试
🐶2.2 测试分类：
1. 🥙黑盒测试
2. 🥙白盒测试
🐶2.3 Junit介绍
🐶2.4 Junit的基本使用步骤:(默认使用maven创建项目)
1. 🥙pom.xml中引入依赖:
2. 🥙示例编写一个java程序:
3. 🥙在测试类方法上添加注解 @Test。
4. 🥙点击测试运行
5. 🥙查看运行结果:
🐶2.5 注解的使用
🐶2.1 什么是单元测试 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。 程序单元是应用的最小可测试部件。简单来说，就是测试数据的稳定性是否达到程序的预期。
🐶2.2 测试分类： 1. 🥙黑盒测试 不需要写代码，给输入值，看程序是否能够输出期望的值。
2. 🥙白盒测试 需要写代码的。关注程序具体的执行流程。
🐶2.3 Junit介绍 Junit是一个Java语言的单元测试框架，属于白盒测试，简单理解为可以用于取代java的main方法。Junit属于第三方工具，需要导入jar包后使用。
🐶2.4 Junit的基本使用步骤:(默认使用maven创建项目) 关于maven的讲解：
Maven《一》-- 一文带你快速了解Maven-CSDN博客
1. 🥙pom.xml中引入依赖: &lt;!--单元测试的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; 2. 🥙示例编写一个java程序: package com.maven.pojo.day0122; public class Test01 { public static void main(String[] args) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61dfaafcf6c38df95625d1377f79dbfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03c338cc9264c5303b0a47abba772c68/" rel="bookmark">
			旅游网站day13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 完善首页 1.1 首页banner查询接口 1.2 搜索服务 集成ES
1. 方式1：数据独立存储与独立搜索 2. 方式2：条件搜索与主键查询 为搜索模块搭建一个服务
为什么需要api?
因为搜索也需要模型对象。
导入es依赖：
搜索api：
ES工具类封装
数据迁移：
把MySQL的数据迁移到ES中。
封装一个通用的操作ES的Service工具类。
ES数据初始化接口：（动态接口）
其余几种CASE下的查询可以使用策略模式思想来完善。
总结 存量数据已经解决
新的数据如何存入es？ 即增量数据？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fb0f780ecff9f98cdc1630fb1614711/" rel="bookmark">
			猫头虎分享： 如何解决Gradle插件发布成功却未生成本地仓库的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主猫头虎的技术世界
🌟 欢迎来到猫头虎的博客 — 探索技术的无限可能！
专栏链接：
🔗 精选专栏：
《面试题大全》 — 面试准备的宝典！《IDEA开发秘籍》 — 提升你的IDEA技能！《100天精通Golang》 — Go语言学习之旅！ 领域矩阵：
🌐 猫头虎技术领域矩阵：
深入探索各技术领域，发现知识的交汇点。了解更多，请访问：
猫头虎技术矩阵新矩阵备用链接 文章目录 如何解决Gradle插件发布成功却未生成本地仓库的问题摘要引言正文问题描述可能的原因及解决方案原因一：配置问题原因二：权限不足原因三：Gradle版本不兼容原因四：网络问题原因五：构建脚本错误原因六：依赖冲突原因七：插件本身的Bug原因八：本地仓库路径错误原因九：环境变量问题原因十：缓存问题 小结 参考资料本文核心知识点表格总结总结 如何解决Gradle插件发布成功却未生成本地仓库的问题 摘要 🔍本文详细探讨了在使用Gradle进行插件发布时，可能遇到的一个常见问题——发布成功却未在本地生成仓库。我们将深入解析此问题的各种可能原因，并提供针对性的解决方案。适合各级开发者阅读，无论是刚入门的小白还是经验丰富的大佬，都能从中获益。关键词：Gradle, 插件发布, 本地仓库, 问题解决, 开发者工具, 构建自动化。
引言 👋大家好，我是猫头虎博主，今天我们要聊的是Gradle插件发布后本地仓库未生成的问题。Gradle作为一款强大的自动化构建工具，广泛应用于各种软件开发项目中。但在实际操作过程中，我们可能会遇到一些棘手的问题，比如发布插件成功却不见本地仓库。这篇文章将为你提供一些有效的解决方案。🛠️
正文 问题描述 🧩在使用Gradle进行插件发布时，有时候我们会遇到一个问题：虽然Gradle显示插件发布成功，但是在本地仓库中却找不到相关文件。这可能会导致我们在后续的项目构建或者插件调用中遇到困难。
可能的原因及解决方案 原因一：配置问题 🔧解决方案： 检查build.gradle文件中的配置。确保你已经正确设置了仓库的路径。例如：
apply plugin: 'maven' uploadArchives { repositories { mavenDeployer { repository(url: "file://${project.buildDir}/repos") } } } 原因二：权限不足 🔑解决方案： 确保你有足够的权限来写入指定的本地仓库目录。在某些操作系统中，你可能需要管理员权限。
原因三：Gradle版本不兼容 🔄解决方案： 尝试更新或降级你的Gradle版本。有时候，插件可能不兼容当前的Gradle版本。
原因四：网络问题 🌐解决方案： 检查你的网络连接。虽然是发布到本地仓库，但在某些情况下，Gradle可能仍需要网络连接来处理某些任务。
原因五：构建脚本错误 🐛解决方案： 详细检查你的构建脚本。有时候，脚本中的小错误或遗漏可能会导致发布流程不完整。检查是否有语法错误，或者某些必要的步骤被遗漏。
原因六：依赖冲突 🤯解决方案： 检查是否存在依赖冲突。有时，项目依赖的不同版本可能会导致构建失败。使用gradle dependencies命令来诊断依赖问题，并适当调整依赖版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fb0f780ecff9f98cdc1630fb1614711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4693f4fe2624627507e95d9837a9945c/" rel="bookmark">
			Kafka-服务端-整体架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec0588c375ddea416f58af07e3b1b38/" rel="bookmark">
			Kafka-消费者-KafkaConsumer分析总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KafkaConsumer依赖SubscriptionState管理订阅的Topic集合和Partition的消费状态，通过ConsumerCoordinator与服务端的GroupCoordinator交互，完成Rebalance操作并请求最近提交的offset。
Fetcher负责从Kafka中拉取消息并进行解析，同时参与position的重置操作，提供获取指定Topic的集群元数据的操作。上述操作的所有请求都是通过ConsumerNetworkClient缓存并发送的，在ConsumerNetworkClient中还维护了定时任务队列，用来完成HearbeatTask任务和AutoCommitTask任务。NetworkClient在接收到上述请求的响应时会调用相应回调，最终交给其对应的*Handler以及RequestFuture的监听器进行处理。
KafkaConsumer并不是一个线程安全的类。为了防止多线程并发操作，KafkaConsumer提供了多线程并发的检测机制，涉及的方法是acquire和release。这两个方法的代码如下：
我们可以看出，这并不是一种锁的实现，仅实现了检测多线程并发操作的检测。这里使用CAS操作可以保证线程之间的可见性。CAS操作、可见性等相关概念请参考Java并发专栏。
面我们来分析KafkaConsumer.poll方法进行消息消费的整个流程以及相关代码：
注意，在消费完消息之后，客户端还需要commit offset,手动同步commit offset使用commitSync(),手动异步commit offset使用commitAsync(),自动commit offset使用定时任务AutoCommitTask。
在pollOnce方法中会先通过ConsumerCoordinator与GroupCoordinator交互完成Rebalance操作，之后从GroupCoordinator获取最近一次提交的offset(或重置position),最后才是使用Fetcher,从Kafka获取消息进行消费。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895b70107cfb168503168506fea55cc9/" rel="bookmark">
			shell编程-6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		akw深入学习 shell学习第6天继续学习awkif多分支小题目利用awk的system命令求和awk数组小练习练习2split切割函数substr函数---&gt;切片 难题 shell学习第6天 继续学习awk systime()是awk内部得到当前时间的函数
strftime()是awk日期格式化输出的函数，按照指定的格式输出日期
编写一个脚本，发现新增了或者删除了用户，需要知道，还有修改了密码也要知道，密码为空的用户也要知道、如果有上面的行为就记录到日志里/var/log/user_pwd.log
#!/bin/bash #定义日志文件 log_file="/var/log/user_pwd.log" #备份 /etc/passwd 和 /etc/shadow mkdir -p /backup_user cd /backup_user #手动去备份 #cp /etc/passwd passwd-$(date +%F) #cp /etc/shadow shadow-$(date +%F) #计算备份文件的md5sum passwd_md5=$(md5sum /backup_user/passwd-$(date +%F) | awk '{print $1}') shadow_md5=$(md5sum /backup_user/shadow-$(date +%F) | awk '{print $1}') #计算最近的 /etc/passwd /etc/shadow 的md5值 c_passwd_md5=$(md5sum /etc/passwd | awk '{print $1}') c_shadow_md5=$(md5sum /etc/shadow | awk '{print $1}') #判断 passwd 文件的 md5 值是否有变化 if [[ $passwd_md5 != $c_passwd_md5 ]]; then echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/895b70107cfb168503168506fea55cc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae601f5c475590c4b73097603df7ece/" rel="bookmark">
			java线程池ThreadPoolExecutor的拒绝策略RejectedExecutionHandler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期在面试时问题时问到了 ThreadPoolExecutor 的拒绝策略 RejectedExecutionHandler 的实现 CallerRunsPolicy，之前没深入思考过，在此记录一下。
拒绝策略 RejectedExecutionHandler 源码
package java.util.concurrent; /** * A handler for tasks that cannot be executed by a {@link ThreadPoolExecutor}. * * @since 1.5 * @author Doug Lea */ public interface RejectedExecutionHandler { /** * Method that may be invoked by a {@link ThreadPoolExecutor} when * {@link ThreadPoolExecutor#execute execute} cannot accept a * task. This may occur when no more threads or queue slots are * available because their bounds would be exceeded, or upon * shutdown of the Executor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ae601f5c475590c4b73097603df7ece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3befc533a371cd291f7b317fa57cfa/" rel="bookmark">
			51单片机LED点阵屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LED点阵屏 LED点阵屏是一种由许多小型LED灯组成的矩阵式显示屏。这些LED灯可以是单色、双色或全彩的，它们排列成行和列的网格，可以根据需要点亮来显示图像、文字或动画等内容。LED点阵屏广泛应用于户外广告牌、室内显示、交通信号灯、电子价格标签和其他需要显示信息的场合。
LED点阵屏的优点包括：
高亮度：LED点阵屏采用LED作为显示元素，具有高亮度和良好的可见性，即使在明亮的环境下也能清晰显示。
节能：LED点阵屏采用LED作为光源，相比传统的荧光灯和白炽灯，LED具有较低的能耗和较长的寿命。
可定制性：LED点阵屏可以根据需要定制成不同大小和形状，适应各种显示需求。
显示内容多样：LED点阵屏可以显示文字、数字、图像、动画等多种内容，具有良好的灵活性和多功能性。
LED点阵屏也有一些局限性，例如成本较高、像素密度受限等。但随着LED技术的不断进步，LED点阵屏的成本逐渐下降，像素密度和显示质量也在不断提高。因此，LED点阵屏在数字显示领域具有广阔的应用前景。
led点阵屏的显示原理
OE ：输出使能在低电平时有效
RCLK： 寄存器时钟
SRCLR：串型清零端
SRCLK/SER：串型时钟/串型数据
QH:多片级联
SER----》串型数据一个一个的通过
eg1:74HC595的使用
#include &lt;REGX52.H&gt; sbit RCK = P3^5; // 寄存器时钟 RCLK sbit SCK = P3^6; // 串型时钟 SRCLK sbit SER = P3^4; // 串型输入口 SER void _74HC595_WriteByte(unsigned char Byte){ unsigned char i; for(i=0;i&lt;8;i++){ // 将最高位取出来,使用按位右移移动 SER = Byte&amp;(0x80&gt;&gt;i); //10000000 实际上就是表示的就是一位 //非0即1 SCK = 1; // 产生上升沿数据移位 SCK = 0; //清零为下一次的移位做准备 } RCK = 1; RCK = 0; } void main(){ SCK = 0; RCK = 0; _74HC595_WriteByte(0xf0); while(1){ // 编写HCTC595代码 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b68396d90e9e13c9879269d1d95b32/" rel="bookmark">
			PythonNet，Csharp如何白嫖Python生态和使用Matplotlib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言PythonNet环境配置Python环境配置Csharp Nuget配置运行代码测试运行结果 总结 前言 我既然用Csharp去尝试学习机器视觉，我就想试试用Csharp去使用Python的库。
这个世界上有没有编程语言既有Python的开发效率，又有C/C++/
PythonNet Pythonnet 官网
C# .Net通过pythonnet调用python pyd文件
环境配置 Python环境配置 调用Python，首先你的电脑得安装Python。我这里用的是Anaconda配置的Python环境
Python+OpenCV 零基础学习笔记(1-3):anaconda+vscode+jupyter环境配置
Csharp Nuget配置 我这里的.NET版本是
visual Studio 2022.net core 8.0 Nuget安装
运行代码测试 我本地已经装好了Matplotlib了，我这里直接测试Matplotlib的代码调用
随便找一段代码
Matplotlib 教程 import matplotlib.pyplot as plt import numpy as np xpoints = np.array([0, 6]) ypoints = np.array([0, 100]) plt.plot(xpoints, ypoints) plt.show() 对应的Csharp代码
static void Main(string[] args) { //选择你Python的dll位置 Runtime.PythonDLL = @"D:\Anaconda3\python311.dll"; //创建Python环境 PythonEngine.Initialize(); //展开Python的全局解释器 using (Py.GIL()) { dynamic plt = Py.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b68396d90e9e13c9879269d1d95b32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113be09c70e44c0b50179b38c89deb31/" rel="bookmark">
			Android：RecyclerView自由拖动item
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原生就自带有可拖动item的工具：ItemTouchHelper 看下效果：
可拖动RecyclerView预览效果
接下来我们看如何使用。
1、自定义ItemTouchHelper的callback，用来限制是否可以拖动，以及拖动之后的位置更新： 其中判断条件中的item.isMovable这边是记录该item是否可以拖动，也可以换成其他判断条件比如根据位置判断等。
private static class MyItemTouchHelperCallback extends ItemTouchHelper.Callback { private final ItemAdapter itemAdapter; public MyItemTouchHelperCallback(ItemAdapter itemAdapter) { this.itemAdapter= itemAdapter; } @Override public int getMovementFlags(@NonNull RecyclerView recyclerView, @NonNull RecyclerView.ViewHolder viewHolder) { int layoutPosition = viewHolder.getLayoutPosition(); ItemInfo item = ItemAdapter.getItem(layoutPosition); if (!item.isMovable()) { //不可拖动 return makeMovementFlags(0, 0); } //这里表示可以拖动的方向，比如如果不给往上方拖动则去掉ItemTouchHelper.UP final int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT; return makeFlag(ItemTouchHelper.ACTION_STATE_DRAG, dragFlags); } @Override public boolean onMove(@NonNull RecyclerView recyclerView, @NonNull RecyclerView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/113be09c70e44c0b50179b38c89deb31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e734967d81c6b60fee5d6e7e6efa860f/" rel="bookmark">
			用ChatGPT教学、科研！亚利桑那州立大学与OpenAI合作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亚利桑那州立大学（简称“ASU”）在官网宣布与OpenAI达成技术合作。从2024年2月份开始，为所有学生提供ChatGPT企业版访问权限，主要用于学习、课程作业和学术研究等。
为了帮助学生更好地学习ChatGPT和大语言模型产品，ASU开设了一门名叫“Prompt engineering”（提示工程）的课程。学生全部学习完毕后将获得证书，可用于简历、LinkedIn 个人资料，增加就业竞争力。
据悉为了此次合作，ASU大约准备了6个月的时间，从数据安全、功能、场景化落地等多个方面对ChatGPT进行了全方位审核。
最终在确定安全、可靠的情况下，开始为学生提供服务。ASU也是全球为数不多在教育领域，大面积应用ChatGPT的高校之一。
ASU官网公布合作消息
此外，ASU将邀请教师职工提供更多的意见，来扩大ChatGPT的应用案例和业务范围，以提升学习效率和颠覆教育模式。
Prompt Engineering课程
ASU表示，“提示工程”是生成式AI领域最热门课程之一，可帮助学生深入了解学习提示词，从而更精准地向ChatGPT提问获得优质答案。
该课程一共2小时，由ASU社会创新未来学院教授-Andrew Maynard负责，向所有学生开放，无需任何专业技能背景便能立刻学习。
提示工程课程介绍
课程涵盖提示模板、创意提示结构以及为各种任务和应用程序设计的专业提示。以下是典型的提示词示例。
精准提问：当我们向ChatGPT提问时，问题不能太笼统最好有具体的指向和背景。例如，我该如何提高写作技能？
可以优化为，我是一名大二的在校学生，可提供一份关于英语写作技巧的方法和计划吗？
明确输出格式：可以让ChatGPT按照一定格式生成内容。例如，列出一些健康的食物？
可以优化为，能否按照食物类别，列出五种低卡路里、适合心脏健康的食物，以及它们的一份量热量？
简单来说，当你向ChatGPT提问时，一定要具体、逻辑清晰，这有助于AI理解你的问题并生成精准、高质量的内容。
ChatGPT可以为学生提供哪些帮助
ChatGPT是经过海量数据训练而成的生成式AI产品，精通数学、物理、化学、英语、语文、法律等学科，基本上关于常规的学习、研究问题都非常在行。以下是部分示例
解释技术概念：学生在理解数学问题、科学概念或者语言等方面遇到困难时，ChatGPT能解释复杂的技术概念，提供多种解题方法并提供简单、易懂的原理。
可视化数据分析：可以将数据文档输入到ChatGPT中，生成可视化数据列表，并提供对复杂数据集分析的建议。
文献搜索与管理：学生可以通过自定义ChatGPT，来搜索相关的专业学术文献和管理文献引用，同时提供相关研究领域的文献列表以及概述，提升论文的写作效率。
写作助手：可以将写好的内容输入到ChatGPT中，能提供写作结构建议、语言润色、以及确保文稿的逻辑清晰、连贯性和找出错别字等。
ChatGPT企业版
ChatGPT企业版（Enterprise）是OpenAI在2023年8月29日发布的一款产品。提供无限速的GPT-4访问权限，支持32K上下文输入，高级数据分析功能，自定义ChatGPT等高级功能。
除了功能强大之外，数据安全是ChatGPT企业版另外一大技术特点。用户可以完全控制ChatGPT中的数据，OpenAI不会搜集这些数据用于训练AI模型。
所有对话数据经过静态数据加密 (AES-256) 和传输中数据加密 (TLS 1.2+)，并且符合SOC 2标准。
亚利桑那州立大学校长Michael M. Crow表示，ASU认识到，生成式AI和增强性AI将会长久性的存在。并且ASU对它们成为帮助学生学习，以及更深入地理解课程的强大工具持乐观态度。ASU与OpenAI的技术合作反映了超前的教学理念，并用负责任的方式使用生成式AI。
Michael M. Crow
亚利桑那州立大学首席信息官-Lev Gonick表示，ASU与OpenAI的合作，将ChatGPT 企业版的先进功能引入到高等教育领域。为大学如何提高学习效率、创造力和学生成绩树立了典范。
关于亚利桑那州立大学
ASU成立于1885年，是美国最早设立的高等教育机构之一。
ASU是一所研究密集型大学，以创新研究项目和与行业的合作关系闻名。它的研究领域包括可持续能源、空间探索、生物医学和全球环境变化等，提供包括本科、硕士和博士在内的多个学位项目。
ASU以法学院、工程学院、商学院和教育学院等专业而知名。
本文素材来源ASU官网，如有侵权请联系删除
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e04c5ed162f5a4bd0812bfdfaab0b7/" rel="bookmark">
			js之执行上下文和作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 变量和函数的上下文决定了它们可以访问那些数据，以及它们的行为
每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都在存在于这个变量对象之上
上下文再其所以代码都执行完毕之后会被销毁，包括定义在它上面的所有变量和函数（全局上下文再应用程序退出之前才会被销毁，比如关闭网页或者退出浏览器）
let color = 'blue' function changeColor() { if (color === 'blue') { color = 'red' } else { color = 'blue' } } changeColor() 函数的作用域链包含两个对象：一个是他自己的变量对象（就是定义arguments对象的那个），另一个就是全局上下文的变量对象，函数内部值所以可以访问变量对象color,就是因为可以在作用域链找到它。
let color = 'blue' function changeColor() { let anotherColor = 'red' function addColor() { let tempColor = anotherColor console.log(tempColor); console.log(color); //在这里可以访问color,anotherColor和tempColor } //这里可以访问color和anotherColor，但访问不到tempColor addColor() } //在这里只能访问到color changeColor() 上面的代码就涉及到3个上下文，全局上下文，changeColor（）的局部上下文和addColor（）的局部上下文
全局上下文中有变量color和函数changColor()changeColor()的局部上下文中有变量anotherColor和函数addColor（），但是在这里可以访问到全局上下文中的变量coloraddColor的局部上下文有一个变量tempColor，这边变量只能在当前上下文中访问总结：内部上下文可以用过作用域链访问到外部上下中的一切，但是外部上下文无法访问内部上下中的内核东西，上下文的连接都是线性的，有序的 函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d4ce6b7bc7870ccc64cc6a081e75334/" rel="bookmark">
			喜报|超维防爆轮式智能巡检机器人荣获防爆合格证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，超维WEX-200B防爆轮式智能巡检机器人顺利通过南阳防爆电气研究所有限公司，国家车辆特种性能质量检验检测中心的资料审查、测试、及综合评估，荣获防爆合格证证书，代表着超维WEX-200B防爆轮式智能巡检机器人已经满足相关法规和标准，在拓展国内外市场上更具认可度和公信力。
此次防爆测试的产品部件包括：防爆激光雷达、防爆型无线充电器、防爆拾音器、防爆 TOF 探测器、防爆按钮、隔爆声光报警器、AGV 动力锂电池组、防爆扬声器、固定式气体检测仪、防爆一体化云台摄像机、防爆填料函等。
产品说明 防爆轮式智能巡检机器人，采用四轮独立驱动方式，动力充足，适合各种复杂路况。全防爆设计,已经取得防爆认证,防爆等级 Exd IIB T4防护等级 IP65，搭载多种防爆传感器，如激光雷达、四目云台、气体传感器、扬声器、声光报警器、拾音器等，支持自动巡检、远程遥控功能等多种模式，代替人工完成日常巡视、红外测温、仪表示数读取、气体泄漏检测及设备运行状态检测诊断等工作，实现区域全覆盖巡视。适用于石油、化工、燃气等有防爆需求的巡检场景。
系统功能：
1.导航定位
采用激光雷达+视觉+IMU融合SLAM方案，能够适应更多复杂环境。主动避障方案，自动避开前进道路上的障碍物，避免与行人、设备等碰撞。
2.机器视觉识别
表计识别、开关识别、阀门识别、跑冒滴漏识别、安全帽检测、工作服检测等。
3.红外成像
红外图像与视频画面同步显示，实现设备温度的可视化监测。
4.气体检测
日常作业巡检检测化工园区、天然气站场气体泄漏并主动预警提示，可定制气体检测类型。
5.激光甲烷检测
激光检漏仪可实现甲烷气体非接触、大范围精确检测和定位。
6.声音采集及分析功能
对动设备声波信号进行采集，可有效判断识别设备健康状态。
7.语音对讲、视频直播
通过控制室WEB客户端查看实时视频，并支持云台操作，由机器人前往现场，可用于日常巡检、远程作业监护、故障先期排查等场景。
应用案例
燕山石化板局点
扬子石化5G新基建全国样板局点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21a36a546b397b0ea191ae750092108/" rel="bookmark">
			企业固定资产智能管理系统 毕业设计-附源码 06298
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 信息化社会内需要与之针对性的信息获取途径，但是途径的扩展基本上为人们所努力的方向，由于站在的角度存在偏差，人们经常能够获得不同类型信息，这也是技术最为难以攻克的课题。针对企业固定资产智能管理系统等问题，对企业固定资产智能管理系统进行研究分析，然后开发设计出企业固定资产智能管理系统以解决问题。
企业固定资产智能管理系统主要功能模块包括个人信息、密码修改、管理员、普通用户、资产信息、盘点记录、报废记录，采取面对对象的开发模式进行软件的开发和硬体的架设，能很好的满足实际使用的需求，完善了对应的软体架设以及程序编码的工作，采取Mysql作为后台数据的主要存储单元，采用ssm框架、java技术、进行业务系统的编码及其开发，实现了本系统的全部功能。本次报告，首先分析了研究的背景、作用、意义，为研究工作的合理性打下了基础。针对企业固定资产智能管理系统的各项需求以及技术问题进行分析，证明了系统的必要性和技术可行性，然后对设计系统需要使用的技术软件以及设计思想做了基本的介绍，最后来实现企业固定资产智能管理系统和部署运行使用它。
关键词：资产智能管理系统；Java；SSM；MYSQL
Abstract
In the information society, there is a need for targeted access to information, but the expansion of the access is basically the direction of people's efforts. Because of the deviation in the perspective, people can often obtain different types of information, which is also the most difficult subject for technology to overcome. Aiming at the problems of enterprise fixed assets intelligent management system, this paper studies and analyzes the enterprise fixed assets intelligent management system, and then develops and designs the enterprise fixed assets intelligent management system to solve the problems.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b21a36a546b397b0ea191ae750092108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e086a565e968ef6dc4d7ea273cf4f4f0/" rel="bookmark">
			JavaScript——forEach()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码示例： 数组变量.forEach(值变量名 =&gt; {代码块}) //每遍历一个值，就作为形参传入给代码块，执行一次该函数头，继续遍历 举例说明：
&lt;script&gt; let arr = [1, 2, 3, 4]; //arr.forEach(val =&gt; {}); arr.forEach(val =&gt; { console.log(val); }); &lt;/script&gt; brr.forEach(val =&gt; { console.log(val + "，你好"); }) crr.forEach(o =&gt; { console.log(o.name); }) drr.forEach(o =&gt; { if(o.age &lt; 18) console.log(o.age); }) ！注意：只遍历有值的元素
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6574bc5ba7ca657657d448e1f515726/" rel="bookmark">
			在 Spring MVC 中，用于接收前端传递的参数的注解常用的有以下几种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、对于json请求体参数，
2、对于路径传参
3、对于query传参
4、对于form-data参数，
总结：
1、对于json请求体参数， 请求头的Content-Type应为application/json。在前端，可以使用data格式传参。在后端，可以使用@RequestBody注解来接收参数。
this.$axios({ method: 'post', url: 'http://localhost:8080/api/upload/editGoods', data: { id: this.id, name: this.name, price: this.price } }).then((res) =&gt; { this.$message({ message: '修改成功', type: 'success' }) }) @GetMapping("/editGoods") public Result editGoods(@RequestBody Goods goods) { return uploadFileService.editGoods(goods); } 2、对于路径传参 （例如：test/111/2222），请求头不需要设置Content-Type。在前端，可以将参数通过URL的方式传递（例如：url=/api/upload/test2/111/2222）。在后端，可以使用@PathVariable注解来接收参数。
this.$axios({ method: 'post', url: 'http://localhost:8080/api/user/deleteUser/' + userId, }).then((res) =&gt; { this.$message({ message: res.data.message, type: "success", }); // 刷新表格数据 this.selectUser(); }); }).catch(() =&gt; { // 用户点击了取消按钮 // 执行取消操作或不执行任何操作 }); @PostMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6574bc5ba7ca657657d448e1f515726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20de673bf817ee70dafcd6deb445b78e/" rel="bookmark">
			机器学习大作业——基于DEAP数据集的脑电信号识别（DNN&#43;CNN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验目的
二、实验原理介绍
2.1 数据集描述
2.2深度神经网络
2.2.1 关于DNN
2.2.2 网络模型代码实现
2.3 卷积神经网络
2.3.1 关于CNN
2.3.2 网络模型代码实现
三、模型训练与测试
3.1数据预处理
3.2 模型训练与测试
3.2.1训练前期准备
3.2.2训练模型的过程
四、实验结果与分析
4.1二元价态分类结果
五、实验总结
附录：实验代码
prepare_deap.py
reduce_dim.py
datasets.py
models.py
train.py
train.py
train_util.py
一、实验目的 1.1了解DEAP数据集的格式
1.2 熟悉深度深度神经网络DNN和卷积神经网络CNN
1.3 通过统计实验对获得的模型进行测试，以比较不同的模型
二、实验原理介绍 本部分首先将介绍本次实验采用的DEAP数据集，另外由于本次实验采用了两种不同的神经网络架构：具有完全连接层的深度神经网络（DNN）和卷积神经网络（CNN），只做了一些小的修改，本部分也将详细解释该模型的基本框架及这些模型中的训练技术。
2.1 数据集描述 本次实验采用的是DEAP数据集。DEAP是2014年发布的一个用于情绪分析的数据集。它是情感计算领域最大的公开数据集之一，还包含各种不同的生理和视频信号。
DEAP数据集由两部分组成：
（1）一个由120个一分钟音乐视频组成的数据库，每一个视频由14-16名志愿者根据效价、唤醒度和主导度进行评分。
（2）40个以上音乐视频的子集，每个视频具有32个参与者中每个参与者的相应EEG和生理信号。与第一部分一样，每个视频都是根据效价、唤醒和支配维度进行评分的。
由于完成时间有限，本次实验只使用了DEAP数据集的第二部分，其中包含EEG信号。
脑电信号是使用Biosemi ActiveTwo设备收集的，该设备记录了32个具有可配置采样率的脑电通道。
DEAP是在512Hz下收集的，但数据集的创建者也提供了EEG信号的预处理版本，下采样到128Hz，并应用了频率滤波器和其他有用的预处理步骤。
特别地，对于32个参与者中的每一个，存在以下预处理的信息：
•数据：一个40 x 40 x 8064的阵列，包含40个频道中每个频道和40个音乐视频中每个频道的8064个录音。每个视频每个频道有8064个录音，因为试验时间为63秒（3秒预审基线+60秒试验），采样率为128Hz（63 x 128=8064）。
•标签：一个40 x 4的数组，包含40个音乐视频中每个视频的效价、唤醒、支配和链接的注释。
下面展示的是准备DEAP数据集相关的部分代码。
2.2深度神经网络 2.2.1 关于DNN DNN神经网络是一个具有3个隐藏层的深度神经网络。该体系结构的近似图形方案如图2所示，而每一层的确切细节如下图所示。
上图所描绘的神经元的数量仅用于表示，每层下方都报告了神经元的真实数量。表1展示的是深度神经网络架构，表2中报告了对于DEAP数据集用于训练的超参数、优化器和损失函数。
表1:深度神经网络架构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20de673bf817ee70dafcd6deb445b78e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af35c95d91fd4e4f67ca9d7a9f260b8c/" rel="bookmark">
			three.js从入门到精通系列教程005 - three.js使用鼠标拖拽缩放浏览全景图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;three.js从入门到精通系列教程005 - three.js使用鼠标拖拽缩放浏览全景图&lt;/title&gt; &lt;script src="ThreeJS/three.js"&gt;&lt;/script&gt; &lt;script src="ThreeJS/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var isMouse = false, myMouseX = 0, myMouseY = 0, myLongitude = 0, myLatitude = 0, myTempLongitude = 0, myTempLatitude = 0, myPhi = 0, myTheta = 0; //创建渲染器 var myRenderer = new THREE.WebGLRenderer(); myRenderer.setSize(window.innerWidth, window.innerHeight); $(document.body).append(myRenderer.domElement); var myCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100); myCamera.target = new THREE.Vector3(0, 0, 0); var myScene = new THREE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af35c95d91fd4e4f67ca9d7a9f260b8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/669ac0b28195684e25a413d64871308a/" rel="bookmark">
			TS-React：useRef 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不能给 useRef 的 current 属性赋值，提示一下错误信息：
Cannot assign to ‘current’ because it is a read-only property.（不能给current属性复制，因为它是一个只读属性。）
代码如下所示：
let cameraMediaStream = useRef&lt;MediaStream&gt;(null); /** * 打开摄像头 **/ const openCamera = async (cameraId = curCameraId) =&gt; { try { // 关闭已打开的摄像头 if (cameraMediaStream) await closeCamera(); // Cannot assign to 'current' because it is a read-only property. cameraMediaStream.current = await ImageCapture.openCamera({ cameraId, video: videoRef.current, width, height }); } catch (err: any) { // 错误信息提示... } } 解决方案：将 current 属性变为非只读属性，useRef 的泛型参数中增加【| null】即可把 current 属性变为非只读属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/669ac0b28195684e25a413d64871308a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ba708233e3691d34eedf02d4076049/" rel="bookmark">
			spring boot项目启动的时候 ，运行main方法报错如下：NoClassDefFoundError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring boot项目启动的时候 ，运行main方法报错如下：NoClassDefFoundError Connected to the target VM, address: '127.0.0.1:58203', transport: 'socket'
Exception in thread "main" java.lang.NoClassDefFoundError: org/springframework/boot/SpringApplication
at com.xxx.IndstApp.main(IndstApp.java:17)
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication
at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581)
at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
... 1 more
Disconnected from the target VM, address: '127.0.0.1:58203', transport: 'socket'
Process finished with exit code 1
项目代码编译没错，运行的时候报错 NoClassDefFoundError ，这是什么鬼！！
先说解决方案吧：
找到 Edit Configurations Application选项， Shorten command line， 切换一下
Application选项， Shorten command line， 切换一下，改成 JAR mainifest， 然后重新rebuild 项目， 运行成功！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51f3763ee01f77203bdf23cd1047114/" rel="bookmark">
			2024-01-15（SpringMVC&amp;Mybatis）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.拦截器 如果我们想在多个handler方法(controller中的方法)执行之前或者之后都进行一些处理，甚至某些情况下需要拦截掉，不让handler方法执行，那么就可以使用SpringMVC为我们提供的拦截器。
拦截器和过滤器的区别：过滤器是在Servlet执行之前或者之后进行处理。而拦截器是对handler执行前后进行处理。
步骤：
① 创建并配置拦截器：
public class MyInterceptor implements HandlerInterceptor{ } ② 实现方法：
public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println("preHandle"); return HandlerInterceptor.super.preHandle(request, response, handler); } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println("postHandle"); HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e51f3763ee01f77203bdf23cd1047114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ce46f1a71af9b301042cd8059ea26c/" rel="bookmark">
			机器学习实验报告——隐式马尔可夫模型HMM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、模型介绍
1.1模型引入
1.2模型背景及发展历程
1.3模型基本假设
​​​​​​​1.4模型基本概念介绍
1.5HMM三要素
二、模型基本问题
2.1评估问题
2.1.1说明
2.1.2 解决方法
2.2 学习问题
2.2.1说明
2.2.2 解决方法
2.3 解码问题
2.3.1 说明
2.3.2 解决方法
三、模型实现
3.1 hmmlearn库简介
3.2案例实现
3.3代码实现
3.4分析​​​​​​​
四、模型讨论
4.1 优缺点讨论
4.3 HMM的应用
五、模型总结
一、模型介绍 1.1模型引入 隐式马尔科夫模型（Hidden Markov Model，HMM）可以通过日常生活中的情境来进行类比。
例如，假设你想根据某地区的天气情况预测未来几天的天气。在这个情景下，天气状况可以被视为“隐藏状态”，而每一天的具体天气现象则是你能够观测到的内容，即“观测状态”。隐藏状态是无法直接观测到的，而观测状态是实际可见的天气情况。进一步地，你可以将天气的变化看作是一个马尔科夫过程，即当前的天气状态只依赖于前一天的天气状态，类似于HMM中的状态转移概率。而观测状态则对应于你能够观测到的具体天气现象，每种天气现象发生的概率可以看作是HMM的观测概率分布。通过这个类比，你可以将天气预测问题理解为一个隐式马尔科夫模型，通过观测到的天气现象来推断隐藏状态，即未来几天的天气情况。
1.2模型背景及发展历程 隐式马尔科夫模型（Hidden Markov Model，HMM）的背景可以追溯到20世纪60年代。HMM最初由L. E. Baum和T. Petrie于1966年提出，并应用于语音识别领域。
随着时间的推移，HMM逐渐被引入到其他领域，并取得了广泛的发展和应用。以下是HMM的一些重要的发展历程：
·1970年代：HMM在自然语言处理领域得到应用，用于词性标注、句法分析等任务。这一时期的研究为之后的语言模型和基于HMM的序列标注方法奠定了基础。
·1980年代：HMM在语音识别领域取得了显著的进展。研究者们利用HMM来建模语音信号的产生过程，实现了较高准确率的语音识别系统。这个时期也见证了HMM的一些扩展，如连续混合HMM（Continuous HMM）和大词汇连续语音识别（Large Vocabulary Continuous Speech Recognition）。
·1990年代：HMM在生物信息学领域得到广泛应用。研究者们将HMM用于DNA和蛋白质序列的分析，例如基因识别、蛋白质家族分类等。HMM在这些任务中展现了强大的建模能力。
·2000年代至今：HMM在更多领域得到应用，并且继续发展和演进。随着深度学习方法的兴起，HMM往往与神经网络结合使用，形成了混合模型，如深度置信网络（Deep Belief Networks）和循环神经网络（Recurrent Neural Networks）。这些混合模型在语音识别、自然语言处理和其他序列数据建模任务中取得了重要突破。
总体来说，隐式马尔科夫模型经历了几十年的发展，从最初的语音识别到涉及自然语言处理、生物信息学、金融预测等多个领域。它的发展为时序数据的建模提供了重要的工具和理论基础，并且对后续的深度学习方法也产生了影响。
1.3模型基本假设 隐式马尔科夫模型（Hidden Markov Model，HMM）的基本假设包括：
（1）有限历史性假设（Limited History Assumption）：当前隐藏状态只依赖于有限的历史状态，而不依赖于更远的过去状态。简言之，当前状态只与前一个状态相关，与更早的状态无关。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4ce46f1a71af9b301042cd8059ea26c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b58e89e8de4129d21490e4a18d0e34c9/" rel="bookmark">
			Kafka-消费者-KafkaConsumer分析-offset操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提交offset 在进行消费者正常消费过程中以及Rebalance操作开始之前，都会提交一次offset记录Consumer当前的消费位置。提交offset的功能也是由ConsumerCoordinator实现的。
先来了解OffsetCommitRequest和OffsetCommitResponse的消息体格式，如图所示。
OffsetCommitRequest中各个字段的含义如表所示。
OffsetCommitResponse中各个字段的含义如表所示。
图展示了ConsumerCoordinator中与提交offset相关的四个方法以及它们之间的调用关系。
在SubscriptionState中使用TopicPartitionState记录了每个TopicPartition的消费状况，TopicPartitionState.position字段则记录了消费者下次要从服务端获取的消息的offset。
当没有明确指定待提交的offset值时，则将TopicPartitionState.position作为待提交offset,组织成集合，形成ConsumerCoordinator.commitOffset*()方法的第一个参数。
commitOffsetsSync()方法与commitOffsetsAsync()方法的实现类似，也是调用sendOffsetCommitRequest()方法创建并缓存OffsetCommitRequest,使用OffsetCommitResponseHandler处理OffsetCommitResponse。
但是有两点不同：
一是commitOffsetsSync()方法在发送OffsetCommitRequest时使用了ConsumerCoordinator.poll(future)阻塞等待OffsetCommitResponse处理完成，这样才实现了同步提交的功能；
二是commitOffsetsSync()方法在检测到RetriableException异常时会进行重试。commitOffsetsSync()方法的具体代码就不贴出来了。maybeAutoCommitOffsetsSync()方法会根据enable.auto.commit配置项的值决定是否调用commitOffsetsAsync()方法。
AutoCommitTask是一个定时任务，它周期性地调用commitOffsetsAsync()方法，实现了自动提交offset的功能。开启自动提交offset功能后，业务逻辑中就可以不用手动调用commitOffsets*()方法提交offset了。AutoCommitTask的代码比较简单。
OffsetCommitResponseHandler.handle方法是处理OffsetCommitResponse的入口。
fetch offset 在Rebalance操作结束之后，每个消费者都确定了其需要消费的分区。在开始消费之前，消费者需要确定拉取消息的起始位置。假设之前已经将最后的消费位置提交到了GroupCoordinator,GropeCoordinator将其保存到了Kafka内部的Offsets Topic中，此时消费者可以通过OffsetFetchRequest请求获取上次提交offset并从此处继续消费。
refreshCommittedOffsetsIfNeeded方法的主要功能是发送OffsetFetchRequest请求，从服务端拉取最近提交的offset集合，并更新到Subscriptions集合中。
Fetcher Fetcher类的主要功能是发送FetchRequest请求，获取指定的消息集合，处理FetchResponse,更新消费位置。图是Fetcher类依赖的组件。
先来了解Fetcher的核心字段。
client:ConsumerNetworkClient,负责网络通信。minBytes:在服务端收到FetchRequest之后并不是立即响应，而是当可返回的消息数据积累到至少minBytes个字节时才进行响应。这样每个FetchResponse中就包含多条消息，提高网络的有效负载。maxWaitMs:等待FetchResponse的最长时间，服务端根据此时间决定何时进行响应。fetchSize:每次fetch操作的最大字节数。maxPollRecords:每次获取Record的最大数量。metadata:记录了Kafka集群的元数据。subscriptions:记录每个TopicPartition的消费情况。completedFetches:List类型，每个FetchResponse首先会转换成CompletedFetch对象进入此队列缓存，此时并未解析消息。keyDeserializer、valueDeserializer:key和value的反序列化器。nextInLineRecords:PartitionRecords类型。PartitionRecords保存了CompletedFetch解析后的结果集合，其中有三个字段：records是消息集合，fetchOffset记录了。 records中第一个消息的offset,partition记录了消息对应的TopicPartition。
Fetcher的核心方法可以分为三类：fetch消息的相关方法，用于从Kafka获取消息；更新offset相关的方法，用于更新TopicPartitionState中的position字段；获取Metadata信息的方法，用于获取指定Topic的元信息。
Fetch消息 首先来了解FetchRequest和FetchResponse的消息体的格式，如图所示。
FetchRequest中的字段如表所示。
FetchResponse中的字段如表所示。
createFetchRequests()方法负责创建FetchRequest请求，其返回值是Map&lt;Node,FetchRequest&gt;类型，key是Node,value是发往对应Node的FetchRequest集合，其核心逻辑如下：
首先，按条件查找fetchable分区。查找条件如下： 首先是分配给当前消费者的分区，即SubscriptionState.assign集合中有对应记录的分区。分区未被标记为暂停且对应的TopicPartitionState.position不为空。nextInLineRecords中没有来自此分区的消息。completedFetches队列中没有来自此分区的CompletedFetch。 查找每个fetchable分区的Leader副本所在的Node节点，因为只有分区的Leader副本才能处理读写请求。检查步骤2中找到的Node节点，如果其在unsent集合或InFightRequest中的对应请求队列不为空，则不对此Node发送FetchRequest请求。通过SubscriptionState查找每个分区对应的position,并封装成PartitionData对象。最后，按照Node进行分类，将发往同一Node节点的所有TopicPartition封装成一个FetchRequest对象。 sendFetches方法的主要功能是将FetchRequest添加到unsent集合中等待发送，并注册FetchResponse处理函数。
FetchResponse的处理主要是解析FetchResponse后按照TopicPartition分类，将获取到的消息数据(未解析的byte数组)和offset组装成CompletedFetch对象并添加到completedFetches。
存储在completedFetches队列中的消息数据还是未解析的FetchResponse.PartitionData对象。
在fetchedRecords方法中会将CompletedFetch中的消息数据进行解析，得到Record集合并返回，同时还会修改对应TopicPartitionState的position,为下次fetch操作做好准备。
更新position 在有些场景下，例如第一次消费某个Topic的分区，服务端的内部Offsets Topic中并没有记录当前消费者在此分区上的消费位置，所以消费者无法从服务端获取最近提交的offset。
此时如果用户手动指定消费的起始offset,则可以从指定offset开始消费，否则就需要重置TopicPartitionState.position字段。
重置TopicPartitionState.position字段的过程中涉及OffsetsRequest和OffsetsResponse,先来介绍其格式，如图所示。
在OffsetsRequest中需要说明的字段是timestamp,取值为-1或-2,分别表示LATEST、EARLIEST两种重置策略。
在OffsetsResponse中需要说明的字段是offsets,它是服务端返回的offset集合。
Fetcher.updateFetchPositions方法中实现了重置TopicPartitionState.position字段的功能，其具体逻辑如下：
检测position是否为空，如果非空则不需要重置操作。如果设置了resetStrategy,则按照指定的重置策略进行重置操作。有EARLIEST、LATEST两种策略：EARLIEST策略是将position重置为当前最小的offset;而LATEST则是将position重置为当前最大的offset。上面的两种策略都会向GroupCoordinator发送OffsetsRequest,请求指定的offset。OffsetsRequest的发送逻辑和OffsetsResponse的处理逻辑与前面介绍的类似。如果没有指定重置策略，则将position重置为committed。如果committed为空，则使用默认的重置策略。默认重置策略是LATEST策略。 获取集群元数据 在Fetcher中还提供了获取Metadata信息的相关方法。涉及sendMetadataRequest、getTopicMetadata、getAllTopicMetadata三个方法，其调用关系如图所示。
基本逻辑是发送MetadataRequest请求到负载最小的Node节点，并阻塞等待MetadataResponse,正常收到响应后对其解析，得到需要的集群元数据。
需要注意的是，Fetcher提供的这三个获取集群元数据的相关方法并不会更新Fetcher.metadata字段中保存的集群元数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f6c543948d6f4e84950d2c3902b62d/" rel="bookmark">
			python实现3D玫瑰花
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在Python中实现3D玫瑰花，你可以使用matplotlib和numpy库。这里有一个简单的示例代码，演示如何创建一个简单的3D玫瑰花：
python复制代码 import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # 定义玫瑰花函数 def rose(theta, r): """返回极坐标中的玫瑰花值""" return r * np.sin(theta) * np.cos(2 * theta) # 创建数据点 theta = np.linspace(0, 2 * np.pi, 1000) r = np.linspace(0, 1, 1000) Theta, R = np.meshgrid(theta, r) Z = rose(Theta, R) # 创建3D图像 fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot_surface(Theta, R, Z, color='red') # 显示图像 plt.show() 这个代码使用numpy来生成极坐标中的数据点，并使用matplotlib的3D功能来绘制这些数据点。rose函数定义了玫瑰花的形状。你可以通过修改这个函数来改变玫瑰花的形状。
这只是一个简单的示例，你可以尝试调整参数和函数来创建更复杂的3D图形。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce206759ca28b38fe8028e0ebfb84d3/" rel="bookmark">
			React三大属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是南城余！阿里云开发者平台专家博士证书获得者！
欢迎关注我的博客！一同成长！
一名从事运维开发的worker，记录分享学习。
专注于AI，运维开发，windows Linux 系统领域的分享！
知识库链接：
D2 · 语雀
组件的实例对象三大属性
这三个核心都是建立在类定义的组件上，因为函数建立的组件没有，因此称为组件的实例对象三大属性
1. state的简写方式 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello,React study by nanchengyu&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt;&lt;/div&gt; &lt;!--引入React核心库 引入顺序有要求必须按照下方1在2前--&gt; &lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt; &lt;script type="text/babel"&gt; /*此处一定要写babel*/ //1.创建类组件 class Weather extends React.Component { //1.1 初始化状态 state ={isHot:false,wind:'微风'} render() { //读取状态 const {isHot,wind} = this.state return &lt;h2 onClick={this.changeWeather}&gt;今天天气很{isHot ? '炎热' : '凉爽'}，{wind}&lt;/h2&gt; } //1.2 自定义方法 用赋值语句的形式+箭头函数 changeWeather =()=&gt;{ const isHot = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ce206759ca28b38fe8028e0ebfb84d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f31406653cff1d865a133a52ae278b1/" rel="bookmark">
			2024-01-12（SpringMVC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.SpringMVC Spring为展现层提供的基于MVC设计理念的Web框架，是目前最主流的MVC框架之一。
SpringMVC是一种轻量级的、基于MVC的Web层应用框架。它能让我们对请求数据的出来，响应数据的处理，页面的跳转等常见的web操作变得更加简单方便。
2.SpringMVC内部依然使用Servlet来实现的，只不过帮我们进行了可以简便操作的封装。 3.@RequestMapping的value属性（缺省属性）用来执行请求路径，method属性用来指定请求类型 指定请求类型可以用以下注解代替：
更加方便
4.@RequestMapping中使用params属性来对请求参数做一些限制。可以要求必须具有某些参数，或者是某些参数必须是某个值，或者是某些参数必须不是某个值。 5.@RequestMapping注解使用headers属性来对请求头进行一些限制。（请求头可以识别和区分亲求方式，例如请求方式来自于ios，Android，....等） 6.@RequestMapping注解指定请求头Context-Type：我们可以使用consumers属性来对Context-Type这个请求头进行一些限制，表示请求头中的数据的类型是什么，是文本还是图片还是html等格式。 7.RestFul风格：RestFul是一种网络应用程序的设计风格和开发方式。企业的网络接口定义都会符合其风格。 接口和网络接口的区别：简单理解，网络接口需要走网络调用，也就是SpringMVC(Servlet)开发的接口。
主要风格如下：
① 每一个url代表一种资源。
② 客户端使用GET，POST，PUT，DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源，PUT用来更新资源，DELETE用来删除资源。
③ 简单参数例如id等，要求写到url路径上。例如：/user/1 GET：获取id=1的user信息，DELETE：删除id=1的信息。
④ 复杂的参数，要求转换成json或者xml（基本json）写到请求体中。
8.RestFul风格获取请求参数的方法 简单请求参数：
复杂请求参数（Json）：
注意：要使用@RequestBody注解从请求体中获取Json格式的数据，要在请求头Headers中设置Content-Type参数为application/json。
9.获取QueryString格式的参数 如果接口是使用QueryString格式的话，我们也可以使用SpringMVC快速获取参数。我们可以使用@RequestParam(默认也可以不加这个注解)来获取QueryString格式的参数。
QueryString格式：www.cxr.com/id=1&amp;name=whitemu&amp;sex=man&amp;age=26
① QueryString中单独参数的获取eg：
② QueryString中获取参数然后封装成实体对象eg：
10.SpringMVC中的类型转换器 虽然我们从请求中获取请求参数已经十分方便了，但是有时候还有一种情况，那就是例如我们想要把请求参数success=1的值赋给一个Boolean类型的变量，那么这个时候就涉及到类型转换了，就可以使用SpringMVC中的类型转换器。
11.响应体响应数据 无论是RestFul风格还是之前web阶段的异步请求，都需要把数据转换成json放入响应体中。
SpringMVC为我们提供了@ResponseBody注解来非常方便的把json放到响应体中。（之前原始我们是使用web原生的HttpResponse对象来响应给前端的，比较麻烦）
12.SpringMVC实现页面跳转（用的少），就是不需要@ResponseBody注解就好，此时return就是跳转页面 13.视图解析器（老项目用的东西了，例如Jsp项目） 为什么要用视图解析器：如果我们经常需要跳转页面，并且页面所在的路径比较长，我们每次写完整路径会显得有点麻烦。我们可以配置视图解析器，设置跳转路径的前缀和后缀。这样可以简化我们的书写。
14.SpringMVC获取原生对象及相关数据 我们之前在web阶段我们经常要使用到request对象，response，session对象。我们也可以通过SpringMVC获取到这些对象。（不过在MVC中我们很少获取这些对象，因为有更简便的方式，避免了我们使用这些原生对象相对繁琐的API）
15.获取请求头参数 在方法中定义一个参数，参数前面加上@RequestHeader注解，知道想要获取的请求头名即可获取对应请求头的值。
16.获取Cookie 在方法中定义一个参数，参数前加上@CookieValue注解。知道想要获取的Cookie名即可获取对应Cookie的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bf155446000fdbc1fc84daf16d73782/" rel="bookmark">
			JavaEE-SSM-订单管理-后端增删改查（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.2.5 添加 编写OrderMapper接口中的insert方法
编写OrderService接口中的save方法
编写OrderServiceImpl实现类中的save方法
编写OrderController中的add方法
编写OrderMapper接口中的insert方法
/** * 插入 * @param order * @return */ @Insert("insert into `order`(oid,price,user_id) values(#{oid},#{price},#{userId}) ") public Integer insert(Order order); 编写OrderService接口中的save方法
/** * 保存订单 * @param order 订单信息 * @return 是否成功, true成功，false失败 */ public Boolean save(Order order); 编写OrderServiceImpl实现类中的save方法
@Override public Boolean save(Order order) { // 保存 0失败，1成功 Integer result = orderMapper.insert(order); // 处理结果 //return result == 1 ? true : false; return result == 1; } 编写OrderController中的add方法 *
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bf155446000fdbc1fc84daf16d73782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb4ace1fe5c9e5f9e655f810e3ed6ab/" rel="bookmark">
			【PowerDesigner】导入sql为表结构并导出表结构为word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入sql为表结构 左上角file -&gt; Reverse Engineer -&gt; Database
导出表结构为word 第一步：新增导出选择文件
Report -&gt; Reports
第二步：在上述步骤点击OK后会跳到新增的页面中 选择Report -&gt; Report Properties
①取消自增序号
②取消页面标题
③设置导出模板
第三步：对导出的表格样式做处理 仅保留一个标题即可
第四步：右键List of Table Columns选择Layout。仅保留字段名称、默认值、数据类型、注释即可
这一点可以按照自己的需求。个人认为这四个列以及宽度就够用了，有需要的再添加主键Is Key
第五步：右键List of Table Columns选择Format 可以对标题、文本进行格式修改 这里我仅对内容做修改
第六步：导出Word 上方的Report -&gt; Generate RTF
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a3c4da93d8ebf3a2a0b7530f4891c8/" rel="bookmark">
			MySQL如何处理约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL允许您同时使用支持回滚的事务表和不支持回滚的非事务表。因此，MySQL中的约束处理与其他数据库管理系统有所不同。当在非事务表中插入或更新了大量行时，并且在发生错误时无法回滚更改时，我们必须处理这种情况。
基本理念是，MySQL服务器在解析要执行的语句时会尽可能地检测出错误，并在执行语句时尝试恢复任何发生的错误。我们在大多数情况下都是如此处理的，但并不是所有情况下都可以做到。
当错误发生时，MySQL有两个选项：停止语句的执行或尽可能地从问题中进行恢复并继续执行。默认情况下，服务器会选择后者。这意味着，例如，服务器可能会将无效的值强制转换为最接近的有效值。
有多种SQL模式选项可用于更精确地控制如何处理错误数据值，以及在错误发生时是继续语句执行还是中止。通过使用这些选项，您可以配置MySQL服务器以更接近其他拒绝不当输入的DBMS的传统方式工作。SQL模式可以在服务器启动时全局设置，以影响所有客户端。各个客户端可以在运行时设置SQL模式，使每个客户端能够选择最适合其需求的行为。
以下几节将介绍MySQL Server如何处理不同类型的约束。
主键约束（PRIMARY KEY）和唯一索引约束（UNIQUE Index） 通常，对于可能违反主键约束、唯一键约束或外键约束的数据更改语句（如INSERT或UPDATE），会发生错误。如果您使用的是诸如InnoDB之类的事务性存储引擎，MySQL会自动回滚该语句。如果您使用的是非事务性存储引擎，MySQL会在出现错误的行处停止处理该语句，并保留其他未处理的行。
MySQL支持INSERT、UPDATE等语句中的IGNORE关键字。如果使用该关键字，在发生主键或唯一键冲突时，MySQL会忽略该错误，并继续处理下一行数据。
您可以借助mysql_info() C API函数来获取实际插入或更新的行数信息。您还可以使用SHOW WARNINGS语句来查看警告信息。
InnoDB和NDB表支持外键约束。
外键约束 外键允许您在表之间进行相关数据的交叉引用，而外键约束有助于保持这些分散的数据的一致性。
MySQL在CREATE TABLE和ALTER TABLE语句中支持ON UPDATE和ON DELETE外键引用。可用的参照动作包括RESTRICT、CASCADE、SET NULL和NO ACTION（默认选项）。
MySQL Server支持SET DEFAULT，但在InnoDB中目前被拒绝为无效。由于MySQL不支持延迟约束检查，因此NO ACTION被视为RESTRICT。
允许使用MATCH FULL、MATCH PARTIAL和MATCH SIMPLE，但应尽量避免使用，因为它们会导致MySQL Server忽略同一语句中使用的任何ON DELETE或ON UPDATE子句。在MySQL中，MATCH选项没有其他影响，实际上全时强制执行MATCH SIMPLE语义。
MySQL要求对外键列进行索引；如果您创建一个具有外键约束但在某列上没有索引的表，将会自动创建索引。 您可以从Information Schema KEY_COLUMN_USAGE表中获取有关外键的信息。下面是一个针对该表的查询示例：
mysql&gt; SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, CONSTRAINT_NAME &gt; FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE &gt; WHERE REFERENCED_TABLE_SCHEMA IS NOT NULL; +--------------+---------------+-------------+-----------------+ | TABLE_SCHEMA | TABLE_NAME | COLUMN_NAME | CONSTRAINT_NAME | +--------------+---------------+-------------+-----------------+ | fk1 | myuser | myuser_id | f | | fk1 | product_order | customer_id | f2 | | fk1 | product_order | product_id | f1 | +--------------+---------------+-------------+-----------------+ 3 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5a3c4da93d8ebf3a2a0b7530f4891c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e161bcabb22a049668a76283a5542ec/" rel="bookmark">
			解决/etc/ssh/ssh_config: line 61: Bad configuration option: permitrootlogin问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 在ssh root@192.168.0.10时报错
/etc/ssh/ssh_config: line 61: Bad configuration option: permitrootlogin
分析： 根据错误提示，是因为在/etc/ssh/ssh_config配置文件中，有错误的配置项permitrootlogin导致的。
解决： permitrootlogin这个配置应该是sshd_config（服务器段配置）中的配置项，而ssh_config是客户端配置文件，所以直接把这行从ssh_config中删除就ok了。
/etc/ssh/ssh_config与/et/ssh/sshd_config的区别 通俗的理解就是ssh_config为客户端连接到服务端的配置文件；sshd_config为服务端的配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfab73a725b3ecfc353f0e9748ed6e30/" rel="bookmark">
			IDCNN（迭代扩张卷积神经网络）在NLP-NER任务中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDCNN（迭代扩张卷积神经网络）在NLP-NER任务中的应用 IDCNN（Iterated Dilated Convolutional Neural Network）是一种特别设计的卷积神经网络（CNN），用于处理自然语言处理（NLP）中的序列标注问题，例如命名实体识别（NER）。IDCNN的关键特点是使用了扩张卷积（Dilated Convolution），这是一种可以增加感受野（即网络可以观察到的输入序列的部分）而不增加参数数量的卷积类型。
主要特点： 扩张卷积：IDCNN通过扩张卷积来增加每层的感受野。在扩张卷积中，卷积核的元素之间会间隔一定数量的点，这样就能覆盖更长的输入序列，而不增加卷积核的大小或参数的数量。
迭代结构：IDCNN通过重复使用同一组卷积层来进一步增加感受野。这种迭代结构意味着网络可以在保持较小模型尺寸的同时，捕捉到长距离的依赖关系。
与其他模型的关系和区别 与BERT的关系和区别：
BERT（Bidirectional Encoder Representations from Transformers）是基于Transformer的模型，主要通过自注意力机制来捕捉长距离依赖关系。BERT在预训练阶段就学习了大量的语言知识，适合于各种下游NLP任务。IDCNN则通过卷积结构来捕捉这些依赖关系，通常需要更少的资源进行训练，但可能不如BERT那样能够有效地处理非常复杂的语言结构。 与BiLSTM/BiGRU的关系和区别：
BiLSTM（双向长短时记忆网络） 和 BiGRU（双向门控循环单元） 都是循环神经网络（RNN）的变体，主要用于处理序列数据，尤其擅长捕获序列中的时间依赖关系。相比之下，IDCNN侧重于通过卷积层来捕获局部依赖关系，并通过扩张卷积来扩大其感受野。IDCNN在处理长序列时通常比标准的RNN更加高效，但可能不如RNN变体那样擅长捕获复杂的时间依赖关系。 与CRF的关系：
CRF（条件随机场） 是一种常用于序列标注任务的模型，它在模型的最后一层用于优化标签序列，使整个标注序列更加合理。IDCNN可以与CRF结合使用，其中IDCNN用于提取特征，CRF用于序列标注。这种组合可以结合IDCNN在特征提取方面的效率和CRF在序列标注上的准确性。 总体来说，IDCNN在NLP-NER任务中提供了一种相对高效的方法来处理长距离的依赖关系，尤其适用于资源有限的情况。
然而，在处理非常复杂的语言结构时，它可能不如基于Transformer的模型（如BERT）或RNN变体（如BiLSTM/BiGRU）那样有效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b198500717a0b6f9f8bbe8c56072e8/" rel="bookmark">
			绝对实用！这些浏览器和网站让你的上网体验焕然一新！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 互联网已经成为我们生活中不可或缺的一部分，而浏览器和网站则是我们探索这个数字世界的窗口。然而，随着科技的不断进步，我们对于上网体验的要求也越来越高。我们渴望更快的速度、更安全的环境、更智能的功能，以及更轻松愉快的使用体验。
在这篇文章中，我们将向大家推荐一些令人惊叹的浏览器和网站，它们不仅满足了我们对于上网的各种需求，更让我们的上网体验达到了一个全新的高度。无论是提供了超快的加载速度，还是保护我们的隐私安全，亦或是提供了智能的搜索和个性化推荐，这些浏览器和网站都将让你的上网变得更加便捷、高效和愉快。
让我们一起来探索这些令人惊喜的浏览器和网站，让你的上网体验焕然一新！
目录
前言
好用的浏览器推荐
谷歌浏览器
火狐浏览器
Edge
宝藏级网站推荐
图像处理类
Pixlr Editor 在线PS工具
IloveIMG 图片处理工具
文档处理类
IlovePDF PDF处理工具
EasePDF PDF处理工具
封面生成类
Coverview 封面生成工具
EasyCover 封面生成工具
Figen 封面生成工具
文件格式转换类
Covertio 文件格式转换器
壁纸类
极简壁纸
WallRoom
like壁纸网
白板工具类
Amymind AI加持的画板在线工具
Excalidraw 免费的在线画板
截图快速美化
Supershots Screenzy
Ai生成式服务
LuckySJ 免费的GPT对话服务
总结
好用的浏览器推荐 谷歌浏览器 谷歌浏览器被广大用户认为是最好用的浏览器之一。它以其简洁、无广告和流畅的特点而闻名。谷歌浏览器采用了自研的内核，这使得它能够提供出色的性能和稳定性。此外，谷歌浏览器还提供了丰富的扩展和应用程序，可以根据个人需求进行定制，满足用户的各种上网需求。
火狐浏览器 火狐浏览器是另一款备受推崇的浏览器。它以其流畅和简洁的界面而受到用户的喜爱。火狐浏览器允许用户登录账号，以便同步相关数据，如收藏夹和浏览记录等。它也采用了自研的内核，以提供出色的性能和稳定性。火狐浏览器还提供了丰富的扩展和主题，可以个性化定制浏览器的外观和功能。
Edge Edge 是微软旗下的浏览器，它使用了谷歌内核。近年来，微软对 Edge 进行了全面的改进，使其成为一款备受好评的浏览器。微软 Edge 允许用户使用微软账号登录，以便同步收藏夹、浏览记录等相关配置。它还提供了一系列实用的功能，如集成的笔记和阅读模式，以及对于隐私和安全的强调。
宝藏级网站推荐 图像处理类 Pixlr Editor 在线PS工具 Pixlr是一款功能强大的在线图像编辑工具，它提供了许多专业级的编辑功能，可以帮助用户轻松地对照片和图像进行编辑和美化。
Pixlr提供了丰富的编辑工具，包括调整亮度、对比度、饱和度等基本调整功能，还有裁剪、旋转、翻转等常用的编辑操作。此外，Pixlr还提供了各种滤镜和特效，如模糊、锐化、马赛克等，可以让用户轻松地为图像添加艺术效果。
Pixlr是一个完全在线的工具，无需下载和安装，且完全免费，用户只需在浏览器中访问官方网站即可开始使用。它还提供了移动应用程序，可以在手机和平板电脑上进行图像编辑。
IloveIMG 图片处理工具 iloveimg是一个方便易用的在线图像处理工具网站。它提供了多种实用的功能，包括图像压缩、调整、转换、裁剪和合并等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52b198500717a0b6f9f8bbe8c56072e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ef2b6b86bcccc099ce3e3a47b5ebc2/" rel="bookmark">
			Linux下软件安装的命令【RPM,YUM】及常用服务安装【JDK，Tomcat，MySQL】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下软件安装的命令 源码安装
以源代码安装软件，每次都需要配置操作系统、配置编译参数、实际编译，最后还要依据个人喜好的方式来安装软件。这个过程很麻烦很累人。
RPM软件包管理 RPM安装软件的默认路径:
注意：
/etc 配置文件放置目录/usr/bin 一些可执行文件/usr/lib 一些程序使用的动态链接库/usr/share/doc 一些基本的软件使用手册与说明文件/usr/share/man 一些man page档案 常用的 RPM 软件包命令
安装软件的命令格式rpm -ivh filename.rpm升级软件的命令格式rpm -Uvh filename.rpm卸载软件的命令格式rpm -e filename.rpm查询软件描述信息的命令格式rpm -qpi filename.rpm列出软件文件信息的命令格式rpm -qpl filename.rpm查询文件属于哪个 RPM 的命令格式rpm -qf filename 参数说明：
-i：install的意思，安装-v：查看更详细的安装信息画面-h：以安装信息栏显示安装进度 软件安装 如你需要安装一个jdk，首先要到网上下载一个jdk的rpm包，如jdk-8u171-linux-x64.rpm。最简单的安装命令如下：
rpm -i jdk-8u171-linux-x64.rpm 不过，这样的参数其实无法显示安装的进度，所以通常我们执行的命令是这样：
rpm -ivh package-name 卸载软件 使用rpm的卸载过程一定要由最上层往下卸载，以rp-pppoe为例，这个软件主要是依据ppp这个软件来安装的，所以当你要卸载ppp的时候，就必须先卸载rp-pppoe才行！
删除的命令非常简单，通过-e参数就可以完成。不过，很常发生软件属性依赖导致无法山洼某些软件的问题。
rpm -e gcc 注意：
如果删除不想检查依赖关系，加 --nodeps
YUM YUM可以看作是CS架构的软件，YUM的存在很好的解决了RPM的属性依赖问题。
YUM通过依赖rpm软件包管理器, 实现了rpm软件包管理器在功能上的扩展, 因此YUM是不能脱离rpm而独立运行的。
注意：
YUM是一个在线软件管理工具，所以使用YUM进行的操作大都是需要在联网的条件下才能正常使用。
YUM的配置文件 容器说明 虽然yum是你在联网后就能直接使用，不过，由于你系统的站点镜像没选择好，会导致连接速度非常慢！所以，这时候就需要我们去手动修改yum的设置文档了。
容器查询 首先，可以先查询一下目录yum server所使用的容器有哪些。
使用命令：yum repolist all，查询结果如下：
如上图，只有当最右边的status为enabled该容器才算激活，
/etc/yum.repos.d/里面会有多个配置文件（文件名以.repo结尾），yum会从里面逐个查找，所以里面的容器名称不能有重复。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82ef2b6b86bcccc099ce3e3a47b5ebc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f21be86729f53694bb0ffb46d651fd/" rel="bookmark">
			iview使用进度条写排行榜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里使用了一个循环，直接粘贴用
&lt;div flex="~" class="rightTopBox" justify="between"&gt; &lt;div style="height: 420px; margin-top: 20px; width: 358px"&gt; &lt;div v-for="item in topList" :key="item.top" flex="~" style="margin-bottom: 19px" &gt; &lt;div class="topBox" :class=" item.top === 1 ? 'back1' : item.top === 2 ? 'back2' : 'back3' " &gt; Top{{ item.top }} &lt;/div&gt; &lt;div style="width: 290px; height: 23.55px; margin-left: 6px"&gt; &lt;div flex="~" justify="between"&gt; &lt;div class="text"&gt; {{ item.name }} &lt;/div&gt; &lt;div class="pro"&gt; {{ item.per }} &lt;span v-if="item.per"&gt;%&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;Progress :percent="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16f21be86729f53694bb0ffb46d651fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b448988d642495e6d47a21b7a0db7e4e/" rel="bookmark">
			数据分析的理念、流程、方法、工具（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据的价值
1、数据驱动企业运营
从电商平台的「猜你喜欢」到音乐平台的「心动模式」，大数据已经渗透到了我们生活的每一个场景。不论是互联网行业，还是零售业、制造业等，各行各业都在依托互联网大数据（数据采集、数据存储、数据处理、数据挖掘、数据分析、数据呈现）实现企业价值。
企业中数据从产生到应用依次要经过数据源层、数据仓库层、数据建模层，最后到数据应用层，经过层层加工逐渐支持到上游的应用环节。
数据应用层是数据产生价值的出口，通过数据挖掘、用户画像建模、推荐算法的制定，可实现千人千面的个性化内容推荐。「个性化」内涵是内容与用户的高度匹配，以达到提升体验、提升高黏性、促进销售转化的目的。
2、数据驱动产品运营
数据分析对业务发展、产品优化、精细化运营也起到了关键支持。
数据驱动产品、数据驱动运营的关键在于「可以通过数据分析提出产品优化思路，提出运营提升的举措，快速上线验证效果，重新优化，进入新的增长循环」。
数据运营的关键应用场景有：
评估产品改版（新功能）效果
发现产品改进关键点
构建用户画像，以便开展精细化运营
优化用户体验
发现业务运营中存在的问题
运营效果分析、ROI分析
数据总结与向上汇报
…
二、如何用数据驱动运营
1、数据驱动运营的内涵
数据驱动运营是一个很宽泛的概念，但拆分下来，数据驱动运营有三个内涵：
产品运营人员要具备数据意识，通过数据发现问题
产品运营人员可以通过数据管理本职工作，用数据解决问题
让数据说话，提高各部门的沟通效率
2、数据驱动运营的工作流程
1）定义数据分析目标
明确目标，意味着运营人员（或数据分析师）要站在数据结果输出对象的角度去思考。对于管理层来说，往往会关注以下几个结果：
重大决策最终反应在了哪些指标上
这些指标有什么关联
业务全局有什么变化趋势
与过去相比，哪些进步了，哪些退步了
数据暴露出了什么问题，需要做什么调整
产品运营人员则更关注细节。整体来看，运营数据分析的目标主要有三类——即「解决是什么、为什么、做什么」的问题，具体的数据分析目标还要结合实际工作来定义：
是什么：如运营举措的效果如何？产品优化的效果如何？用户使用情况是怎样的？用户的体验反馈如何？
为什么：如转化率为什么提升/降低？用户为什么会产生意料之外的行为？运营举措和产品优化为什么有效/没有效果？
做什么：如运营策略该如何调整？产品该怎么优化？业务战略该怎么调整？
2）数据指标拆解
在确定了分析目标后，就需要进行数据指标拆解。明确要分析哪些具体的数据指标，为了避免遗漏关键细节，可以先对业务（或某一个活动、使用场景）流程做梳理，得出每一个节点的数据指标项，根据分析目标需要，保留关键项，剔除多余项。
3）数据采集
定义数据源：在分析数据之前，要对数据来源、统计口径、统计周期加以定义，以便提交「数据提取」需求。
数据的获取途径：数据来源包括埋点数据、运营平台、业务平台、第三方平台、回访调研等。运营人员要对不同数据源的真实性、准确性做把关。
4）数据可视化
使用图表工具，将数据可视化，更容易发现数据的趋势、极值、联系。不同图表类型适用于不同的分析场景。
散点图：用于描述数据之间的规律
折线图：描述数据随着时间变化的趋势
面积图：折线图的延伸，更注重数据和时间趋势的变化关系
柱形图：类别之间的关系
饼状图：数据之间的占比
漏斗图：转化率分析、占比分析
雷达图：个体数据的属性和可视化，常用于用户画像、CRM
树形图：适合数据量大、类别多的情况，比如各类电商的SKU
桑基图：解释数据复杂变化的趋势，一对多或者多对一
热力图：属性和维度的规律组合，有点像折线图
关系图：不同种类的关系，常用于社交媒体
箱线图：统计学图表，用于研究和观察数据分布，对比数据分布等
标靶图：用于业务销售完成情况等
词云图：文本分析利器
地理图：数据和空间的关系
5）数据分析
解决问题是数据分析的最终落脚点。这一环节的目标是发现数据的特征、规律、数据之间的关联，通过对数据的洞察解决实际问题。
6）输出数据分析结论
数据分析的结果可以根据需要以Word或PPT的形式呈现。
报告应采取总分总的格式：
总述：阐述数据分析的背景、目的、目标、分析思路、目录、关键发现。
分述：对业务按多维度细分分析，用数据图表与相应结论阐述观点。
总结：提出结论与优化建议、行动计划、对业务发展做预测，提出策略与结论、附录。
根据实际工作需要，「报告」不一定是必须的，数据分析的结果是为了下一步的行动计划作支撑。
7）测试验证
根据数据分析结论，按照计划开展优化测试，对测试效果展开分析，以此开启新的数据分析进程，形成数据分析工作的闭环。
三、数据分析的基本指标
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b448988d642495e6d47a21b7a0db7e4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6afc010be2998820f6c1122ab01ae4/" rel="bookmark">
			Go七天实现RPC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.前言 本文是学习自7天用Go从零实现RPC框架GeeRPC | 极客兔兔
在此基础上，加入自己的学习过程与理解。
1.RPC 框架 RPC(Remote Procedure Call，远程过程调用)是一种计算机通信协议，允许调用不同进程空间的程序。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。
简单点说，是两个 不同的进程 之间进行信息的交换, 而这两个进程有可能分布在 不同的机器 上。 那就需要进行网络通信，那常用的就有HTTP协议。
2.为什么需要RPC 怎么理解rpc，既然有http请求了为啥还要用rpc？ - 知乎
怎么理解rpc，既然有http请求了为啥还要用rpc？ - 知乎
知乎上的两个回答。
大多数人疑惑既然有HTTP请求可以解决系统间调用的问题了，为什么还会有人使用RPC调用？
而RPC是先于HTTP出现的。
这两个都有各自的用途。RPC更合适用在分布式中。一般来说，RPC的性能比HTTP会更强，大多数RPC框架也提供了很多功能，
在发起下游调用的时候，有时需要做一些功能。比如我们想统计一下下游每个接口调用的耗时、超时、异常情况，这个时候就使用rpc框架非常方便了，因为大多数的rpc框架都会提供一个事件或者钩子给我们，我们就能很方便的做这些事情。除此之外，很多rpc框架还提供了强大而精准的限流、熔断等能力。
而HTTP协议在1990年才开始作为主流协议出现，而且HTTP发明的场景是用于web架构。而现在大部分的系统都是给浏览器使用的，因此HTTP协议必不可少，一些小公司用HTTP也容易搭建自己的架构，成本也低，也好维护。
3.实现RPC Go 语言广泛地应用于云计算和微服务，成熟的 RPC 框架和微服务框架汗牛充栋。grpc、rpcx等都是非常成熟的框架。一般而言，RPC 是微服务框架的一个子集，微服务框架可以自己实现 RPC 部分，当然，也可以选择不同的 RPC 框架作为通信基座。
考虑性能和功能，上述成熟的框架代码量都比较庞大，而且通常和第三方库，例如 protobuf、etcd等有比较深的耦合，难以直观地窥视框架的本质。该RPC 的目的是以最少的代码，实现 RPC 框架中最为重要的部分，帮助大家理解 RPC 框架在设计时需要考虑什么。代码简洁是第一位的，功能是第二位的。
因此，我们选择从零实现 Go 语言官方的标准库 net/rpc，并在此基础上，新增了协议交换(protocol exchange)、注册中心(registry)、服务发现(service discovery)、负载均衡(load balance)、超时处理(timeout processing)等特性。
每个版本的讲解
PRC教程 1.服务端与消息编码
RPC教程 2.支持并发与异步的客户端
RPC教程 3.服务注册
RPC教程 4.超时处理机制
完整代码： https://github.com/liwook/Go-projects/tree/main/geerpc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a634f6c60d672f81c0d21c89ce59202f/" rel="bookmark">
			RPC教程 4.超时处理机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.前言 对比原教程，这里使用context来处理子协程的泄露问题。
1.为什么需要超时处理机制 超时处理是 RPC 框架一个比较基本的能力，如果缺少超时处理机制，无论是服务端还是客户端都容易因为网络或其他错误导致挂死，资源耗尽，这些问题的出现大大地降低了服务的可用性。因此，我们需要在 RPC 框架中加入超时处理的能力。
纵观整个远程调用的过程，需要客户端处理超时的地方有：
与服务端建立连接，导致的超时
发送请求到服务端，写报文导致的超时
等待服务端处理时，等待处理导致的超时（比如服务端已挂死，迟迟不响应）
从服务端接收响应时，读报文导致的超时
需要服务端处理超时的地方有：
读取客户端请求报文时，读报文导致的超时
发送响应报文时，写报文导致的超时
调用映射服务的方法时，处理报文导致的超时
其RPC 在 3 个地方添加超时处理机制。分别是：
客户端创建连接时客户端 Client.Call() 整个过程导致的超时（不仅包含发送报文，还包括等待处理，接收报文所有阶段）服务端处理报文，即 Server.handleRequest 超时。 2.客户端创建连接超时 为了实现简单，把一些超时时间设定放在Option结构体中。有两个超时时间，连接超时ConnectTimeout，服务端处理超时HandleTimeout。
type Option struct { MagicNumber int // MagicNumber marks this's a geerpc request CodecType codec.CodeType // client may choose different Codec to encode body ConnectTimeout time.Duration //0 表示没有限制 HandleTimeout time.Duration } var DefaultOption = &amp;Option{ MagicNumber: MagicNumber, CodecType: codec.GobType, ConnectTimeout: time.Second * 10, //默认连接超时是10s } 客户端连接时候是使用Dail方法，那我们就为 Dial 添加一层超时处理的外壳即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a634f6c60d672f81c0d21c89ce59202f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aaa059b7b01290f1c599580df7fdd50/" rel="bookmark">
			echarts饼图图例显示名字和数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用echarts饼图，实现以下效果：
第一步 设置图例垂直属性
orient: "vertical",
第二步 显示名字和数据，并且数据右对齐
legend: { type: "scroll", right: 35, top: "middle",//居中显示 bottom: 20, orient: "vertical",//垂直 itemGap: 15, //图例间距 itemHeight: 10.5, //图例高度 itemWidth: 10.52,//图例宽度 textStyle: { // 数据右对齐样式 color: "#fff", rich: { a: { // legend左边的文字 width: 50, fontSize: 10, padding: [3, 10, 0, 0], // 1.左边的文字添加右边距10(可自己调整) }, b: { // legend右边的值 fontSize: 12, backgroundColor: "transparent", // 2.右边的值添加背景色 align: "right", // 3.右对齐 padding: [5, -100, 0, 0], // 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aaa059b7b01290f1c599580df7fdd50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be42dba711d735a1d3c1b41e3fe8855d/" rel="bookmark">
			RPC教程 3.服务注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 前言 这一节要熟悉Go中的反射reflet，不然可能比较难理解。在使用到反射的一些函数时候，我也会讲解关于反射reflect的用法。
1.引出反射reflect 这个例子是表示客户端想使用Foo服务的Sum方法。即是想调用Foo结构体的Sum方法。
client.Call("Foo.Sum", args, &amp;reply); 服务端那肯定还有其他结构体的，例如Say结构体，Speak结构体；Hello方法。
有这么多结构体和方法，那服务器要如何判断是用使用那个服务呢。按照硬编码实现的话，就是遍历所有的服务
switch req.ServiceMethod { case "T.MethodName": t := new(t) reply := new(T2) var argv T1 gob.NewDecoder(conn).Decode(&amp;argv) err := t.MethodName(argv, reply) server.sendMessage(reply, err) case "Foo.Sum": f := new(Foo) ... } 这肯定是很繁琐且不现实的。那之后，会想到map[string]service。例如访问"Foo.Sum",那就直接获得该service,那就要为"Foo.Sum"编写特定的执行流程，要是访问"Cat.Speak"，那就要为其编写特定的执行流程，那也又回到之前的困境了。
这时候就需要使用反射了。
同Java语言一样，Go语言也有运行时反射，这为我们提供了一种可以在运行时操作任意类型对象的能力。比如查看一个接口变量的具体类型、看看一个结构体有多少字段、修改某个字段的值等。Go语言是静态编译类语言，比如在定义一个变量的时候，已经知道了它是什么类型，那么为什么还需要反射呢？这当然是因为有些事情只有在运行时才知道。比如你定义了一个函数，它有一个any类型的参数，这也就意味着调用者可以传递任何类型的参数给这个函数。在这种情况下，如果你想知道调用者传递的是什么类型的参数，就需要用到反射。如果你想知道一个结构体有哪些字段和方法，也需要反射。
那通过反射，我们就可以知道该结构体的字段和方法，还有方法的参数返回值这些。这样我们就可以对该服务进行统一编写了。
3. 通过反射实现 service 前面我们完成了客户端和服务端。客户端相对来说功能是比较完整的，但是服务端的功能并不完整，仅仅将请求的 header 打印了出来，并没有真正地处理body。那今天的主要目的是补全这部分功能。
首先通过反射实现结构体与服务的映射关系，代码独立放置在 service.go 中。
先来看如何描述一个方法， 表示方法的结构体，用于注册服务方法
method表示方法本身的反射类型，即是其方法名字ArgType表示参数的类型，即是例子Call中的第二个参数argsreplyType表示响应的类型，即是第三参数replynumCalls：后续统计方法调用次数时会用到 type methodType struct { method reflect.Method ArgType reflect.Type replyType reflect.Type numCalls uint64 } func (m *methodType) newArgv() reflect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be42dba711d735a1d3c1b41e3fe8855d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d8cfd903fe6e072cd92727ce82d552/" rel="bookmark">
			简单但全面了解一下webSocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 webSocket是`一种协议`，设计用于提供`低延迟`、`双全工`和`长期运行`的连接什么是实时通信？ webSocket之前的世界webSocket的优势为什么需要心跳机制？webSocket的限制 webSocket是一种协议，设计用于提供低延迟、双全工和长期运行的连接 **全双工：**通信的两个参与方可以同时发送和接收数据，不需要等待对方的响应或传输完成。双全工指的是一种通信方式，通过建立全双工的持久连接客户端和服务器之间就能实现高效实时性更强的通信。
什么是实时通信？ 传统通信： 电子邮件、网页浏览存在延迟，需要用户主动请求来获取更新数据。
实时通信： 即时消息传递（即时聊天）、音视频通话、在线会议和实时数据传输等，可以实现即时的数据传输和交流，不需要用户主动请求或刷新来获取更新数据。
webSocket之前的世界 在webSocket出现之前实现实时通信主要通过以下几种技术来解决：
轮询：客户端定期向服务器发送请求，询问是否有新的数据可以用服务器在接收到请求后再检查是否有更新的数据，并将其返回给客户端。
缺点： 产生大量的请求和响应，导致不必要的网络开销和延迟。长轮询： 在客户端发出请求后，服务器会保持连接打开一段时间，等待新数据响应后再关闭连接。是基于HTTP的技术
优点：解决了无效轮询的数量
缺点：需要频繁的建立和关闭连接Comet：Comet和长轮询一样是基于HTTP的技术，和长轮询不同的是它可以在返回请求后在返回请求后继续保持连接打开，它的核心思想就是通过保持长连接来模拟实时通信并允许服务器通过流式传输，iframe等推送技术来 主动向客户端推送数据，不过Comet虽然可以模拟实时通信但是它仍然是基于HTTP的模型，在Comet中服务器推送数据给客户端的方式通常还是通过延长响应或使用推送技巧来实现的。 webSocket的优势 总的来说，webSocket相比起其他的技术，有着以下这些优势：
双向实时通信
允许在单个、长时间的连接上进行双向实时通信。需要在快速实时更新的应用程序里，比HTTP更加高效。WebSocket允许服务器主动向客户端推送数据，而不需要客户端发起请求。这种服务器推送的机制可以实现实时更新数据的功能，避免了客户端频繁地发送请求来获取最新数据的需求。
降低延迟
webSocket的连接一旦建立便会保持开放，数据可以在客户端和服务器之间比HTTP更低的延迟进行传输。
更高效的资源利用
可以减少重复请求和响应的开销，因为它的连接只需要建立一次。WebSocket在通信过程中的头部开销相对较小。HTTP协议每次请求都需要发送完整的头部信息，而WebSocket只需要在建立连接时发送一次头部信息，之后的通信只需要发送数据本身，减少了额外的开销。
二进制数据支持：
WebSocket支持传输二进制数据，而HTTP协议主要用于传输文本数据。对于一些需要传输大量二进制数据的应用场景，WebSocket可以更高效地进行数据传输。
（这里补充一下HTTP协议：HTTP是一种无状态的协议，每次请求都需要建立一个新的连接，完成请求后立即关闭连接）
可以说webSocket的出现填补了传统的HTTP协议在实时通信方面的不足，它允许客户端和服务器之间通过单个TCP连接进行双工通信，并且进行实时的数据交换，所以webSocket的协议非常适用于基于Web的游戏、聊天应用以及任何低延迟实时连接的应用程序。目前的webSocket已经得到了主流浏览器的支持，而且由于webSocket的标准定义了一套通信规范，所以无论是JavaScript、Java还是其他编程语言都存在相应的库、框架或者模块来支持WebSocket的实现和使用，比如JS就有Socket.io。
那么要如何建立一个webSocket连接呢？
webSocket的建立需要通过HTTP发送一次常规的Get请求，并且在请求头中带上Upgrade，告诉服务器我想要从HTTP升级为WebSocket连接就建立成功了，之后客户端和服务器双方便可以随时向彼此发送信息。
后端部分用的node.js
先是引用了http和webSocket模块，先创建一个http实例，然后通过它再创建webSocket服务器，当有客户端连接到wenSocket服务器时就会触发Connection事件，当从客户端接收到消息时候会触发Message事件会接收一个参数表示从客户端那里接收到的消息内容
为什么需要心跳机制？ 为了保持webSocket稳定的长连接,连接状态可能会因为各种原因发生变化，在连接建立之后，服务器和客户端之间通过心跳包来保持连接状态，以防止连接因为长连接没有数据传输而被切断。
心跳包就i是一种特殊的数据包，不包含任何实际数据，仅用来维持连接状态，通常情况下心跳包由客户端和服务器端定期发送一个空的数据帧,以确保双方的连接仍然有效，避免连接因为长时间没有数据传输而被中断，如果在一段时间内没有收到对方的心跳包就可以认为连接已经断开需要重新建立连接。
为什么发送空的数据帧就可以确保双方连接有效？
保持连接活跃：WebSocket连接在一段时间内没有数据传输时，可能会由于网络设备的超时机制或其他原因被关闭。通过定期发送空的数据帧，可以向服务器发送一个信号，告知连接仍然活跃，防止连接被关闭。
检测连接状态：发送心跳包可以帮助检测连接是否正常。如果客户端或服务器在一定时间内没有收到心跳包，就可以判断连接可能已经断开。这样可以及时采取措施，例如重新建立连接或通知用户连接中断。
节省带宽和资源：发送空的数据帧相比发送实际数据，可以减少数据传输的带宽消耗和服务器资源占用。心跳包通常只包含一些固定的控制信息，不需要传输大量的数据，因此可以降低网络负载和服务器负载。
快速检测连接中断：由于心跳包是定期发送的，一旦连接中断，客户端或服务器可以迅速发现连接断开的情况。这样可以更快地采取恢复措施，提高连接的可靠性和用户体验。
需要注意的是，心跳包的发送频率应根据具体应用的需求进行调整。发送过于频繁的心跳包可能会增加网络负载，而发送过于稀少的心跳包可能无法及时检测到连接中断。因此，需要根据实际情况选择合适的心跳包频率。
webSocket的限制 不提供加密功能
如果有安全上的需求，需采用其他方式来确保安全性，如SSL协议对webSocket连接进行加密，防止敏感信息被窃听或者篡改，另外也可以限制访问的权限，在服务端设置黑名单或者白名单只允许特定IP地址或者域名的客户端进行连接。不支持古老的浏览器
不支持IE10以前的版本。需要使用AJAX或者其他方式来进行替代优化很重要
除此之外，当webSocket连接过多时可能会对服务器的性能造成负面影响，因为webSocket是一个长连接，需要服务器不断的维护和处理连接状态，优化性能。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d54722d28d3c1d858c7a42aa8fe4f3/" rel="bookmark">
			国密算法学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、国密算法简介
国密算法是中国国家密码管理局颁布的密码算法标准，包括SM2、SM3、SM4等算法。这些算法属于非对称加密算法，意味着加密与解密的密钥是不同的。与其他国际知名的加密算法相比，国密算法具有更好的安全性和性能。其中，SM2算法是国密椭圆曲线密码算法，类似于RSA、ECC; SM3算法是国密Hash算法，类似于SHA256; SM4算法是国密分组密码算法，类似于AES。
二、SM2算法
2.1 基本概念
SM2密码算法是国产密码算法标准，是一种基于椭圆曲线密码（ECC，Elliptic Curve Cryptography）的公钥密码，椭圆曲线密码是非对称密码的一种，具有更高的安全性与更低的计算复杂性。SM2密码算法实际上是在ECC的基础上制定的一套密码系统标准。且相比于RSA算法、DSA算法等具有更高的密钥强度，因此在信息安全领域具有广泛的应用。
2.1.1 密钥对
密钥对是SM2算法中使用的公钥和私钥的组合，其中公钥用于加密数据，而私钥用于解密数据。私钥是一组秘密的随机数，而公钥则是私钥与椭圆曲线上一点的乘积。
2.1.2 曲线
国密SM2算法采用的是椭圆曲线离散对数问题（ECDLP），椭圆曲线的选取是有限域能够保证算法的安全性。具体的曲线参数是国家密码管理局推荐的一组参数。
2.2 数字签名
SM2算法的数字签名分为两个过程：签名和验签。
2.2.1 签名过程
签名过程包括以下几个步骤：
生成随机数k;
计算椭圆曲线上点(x1, y1)，其中(x1, y1) = k * G。G是椭圆曲线上的一个基点;
计算 r = (Mhash + x1) % n，其中 Mhash 为待签名消息的 SM3 Hash值，n 为椭圆曲线的阶;
计算签名值s = 1 / (k − rd) % n，其中 d为私钥.
最终，签名值为(r, s)。
2.2.2 验签过程
验签过程有以下几个步骤：
计算椭圆曲线上点Qa = d * G，其中d为私钥;
计算椭圆曲线上点R = s * G + r * Qa;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07d54722d28d3c1d858c7a42aa8fe4f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd378f74ddeea786b0b8de19e70de21/" rel="bookmark">
			css中＞＞＞、/deep/、::v-deep的作用和区别，element-ui自定义样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言1.1、`/deep/`1.2、`::v-deep`1.3、`&gt;&gt;&gt;` 二、区别三、总结四、最后 一、前言 1.1、/deep/ 在style经常用scoped属性实现组件的私有化时，要改变element-ui某个深层元素（例如.el-input__inner）或其他深层样式时，需要使用/deep/，如：
.conBox /deep/ .el-input__inner{ padding:0 10px; } 注意，/deep/在vue 3.0会报错
1.2、::v-deep 如果/deep/报错，可采用::v-deep，效果基本一样，有人说::v-deep能加快编译速度，但是我在网上没有找到相关资料，无从验证。
.conBox ::v-deep .el-input__inner{ padding:0 10px; } 1.3、&gt;&gt;&gt; 深度作用选择器 &gt;&gt;&gt;，只作用于css
但如果是sass/less的话可能无法识别，这时候需要使用 /deep/和::v-deep 选择器。
想修改element-ui某个深层元素也有其他方式解决；
解决方法之一：除非你将 scoped 移除，或者新建一个没有 scoped 的 style（一个.vue文件允许多个style）
二、区别 &gt;&gt;&gt;：原生css支持，sass/less的话可能无法识别
/deep/：sass/less可识别，/deep/在vue 3.0会报错 (未实际考察，有待验证)
::v-deep：vue 3.0支持，编译速度快 （未实际考察，有待验证）
三、总结 个人推荐vue + element-ui项目使用::v-deep修改样式
四、最后 本人每篇文章都是一字一句码出来，希望对大家有所帮助，多提提意见。顺手来个三连击，点赞👍收藏💖关注✨，一起加油☕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f68047ef94784aad222171142646924/" rel="bookmark">
			快速入门前端开发的学习技巧有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个前端开发者，学习新技术和不断提升自己的能力是非常重要的。随着互联网的快速发展，前端开发也变得越来越重要。下面我将分享一些快速入门前端开发的学习技巧，希望对初学者有所帮助。
1. 学习基础知识
在开始学习前端开发之前，首先需要掌握一些基础知识，比如HTML、CSS和JavaScript。这些是前端开发的基础，没有它们就无法进行任何开发。可以通过阅读相关书籍或者前端视频教程来学习这些知识。
2. 学习框架和库
一旦掌握了基础知识，就可以开始学习一些流行的前端框架和库，比如React、Vue.js和Angular。这些框架和库可以帮助开发者更快速、更高效地构建复杂的前端应用。可以通过官方文档、教程和实战项目来学习这些技术。
3. 实践项目
学习是为了应用。在学习新知识的过程中，一定要结合实际项目进行练习。可以选择一些简单的项目，比如个人博客、任务管理系统等，通过实践来巩固所学知识。
4. 参与开源项目
参与开源项目是一个很好的学习方式。可以在GitHub上找一些自己感兴趣的项目，然后参与其中。通过阅读源码、提交代码和与其他开发者交流，可以学到很多实用的技巧和经验。
5. 学会搜索和阅读官方文档
前端开发是一个不断变化的领域，新的技术和工具层出不穷。因此，学会使用搜索引擎来解决问题是非常重要的。此外，阅读官方文档也是提升技能的好方法，里面包含了大量实用的信息和示例。
6. 关注前端社区
加入一些前端开发的社区和论坛，比如Stack Overflow、GitHub、CSDN等。在这些平台上可以向其他开发者请教问题、分享经验，还可以了解到最新的前端技术和趋势。
7. 持续学习
前端开发是一个不断进步的领域，因此要保持学习的状态。可以通过订阅一些前端技术的博客和社交媒体账号来获取最新的资讯和教程。
总结
学习前端开发并不是一件容易的事情，需要不断地学习和实践。通过掌握基础知识、学习框架和库、实践项目、参与开源项目、学会搜索和阅读官方文档、关注前端社区以及持续学习，可以帮助初学者快速入门前端开发，并不断提升自己的技能。希望以上的学习技巧对你有所帮助，祝你在前端开发的道路上取得成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e470c154a5ef09eb6180d9fabe6f4de/" rel="bookmark">
			零基础怎样才能学好Java？这4点一定要牢记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习Java对于零基础的人来说可能会有一定的难度，但只要掌握正确的学习方法，就能够轻松地掌握这门编程语言。下面我将介绍四个学习Java的方法，希望对大家有所帮助。
第一，系统学习Java基础知识。学习任何一门编程语言都需要从基础知识开始，Java也不例外。首先要学习Java的语法规则、数据类型、运算符、流程控制、数组、类和对象等基础知识。可以选择一些经典的Java教程或者购买相关的书籍进行系统学习，同时可以通过做一些简单的练习来巩固所学知识。
第二，多做项目练习。学习编程语言最好的方法就是通过实践来巩固所学知识。可以选择一些简单的项目来进行练习，比如编写一个学生信息管理系统、一个简单的计算器程序等。通过做项目练习可以更加深入地理解Java语言的特性和用法，同时也可以提高自己的编程能力。
第三，阅读优秀的源代码。在学习Java的过程中，可以多阅读一些优秀的开源项目的源代码，比如一些知名的Java框架、工具库等。通过阅读源代码可以学习到一些优秀的编程思想和技巧，同时也可以了解到一些实际项目中的应用场景，对于提高自己的编程水平是非常有帮助的。
第四，参与开源项目或者社区。在学习Java的过程中，可以选择参与一些开源项目或者加入一些技术社区。通过参与开源项目可以学习到一些实际项目开发的经验，同时也可以结识一些志同道合的朋友，进行技术交流和分享。在社区中可以向一些经验丰富的前辈请教问题，也可以通过回答一些问题来巩固自己的知识。
总之，学习Java需要坚持不懈，同时也需要找到合适的学习方法。通过系统学习基础知识、多做项目练习、阅读优秀的源代码以及参与开源项目或者社区，相信大家一定可以轻松地掌握这门编程语言。希望以上方法对大家有所帮助，也希望大家能够在学习Java的道路上越走越远。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e30ea1735e39a85b4472c61f5a9f1a/" rel="bookmark">
			【Redis】Redis如何实现key的过期删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
🍎个人博客：个人主页
🏆个人专栏：Redis ⛳️ 功不唐捐，玉汝于成
​
目录
前言
正文
结语
我的其他博客
前言 在当今信息时代，数据的快速存储和高效检索成为了软件系统设计中的核心需求。Redis作为一款内存存储系统，以其卓越的性能和灵活的数据结构，成为众多开发者和企业构建实时应用的首选。本文将深入探讨Redis之所以如此高效的原因，从内存存储、单线程模型、非阻塞I/O到优化的数据结构，逐一剖析Redis成功的技术要素。
正文 Redis 使用过期时间来管理 key 的过期。每个 Redis 的键（key）都可以关联一个过期时间（TTL - Time To Live），当这个时间到期时，键将会被自动删除。过期时间可以通过 EXPIRE、PEXPIRE 等命令进行设置，单位可以是秒或毫秒。
以下是 Redis 如何实现 key 的过期删除的一般流程：
设置过期时间： 使用 EXPIRE、PEXPIRE、EXPIREAT 或 PEXPIREAT 等命令，为键设置过期时间。例如：
SET mykey "Hello" EXPIRE mykey 60 # 设置过期时间为60秒 上述命令将 mykey 设置为 "Hello"，并在60秒后自动过期。
定期检查： Redis 使用一种惰性（lazy）的策略来删除过期键。并不是在键到期的瞬间立即删除，而是在访问该键时才会检查它是否过期。
删除过期键： 当客户端尝试访问一个键时，Redis 会先检查该键是否已过期。如果键已经过期，Redis 将立即删除它并返回一个空值（或特殊值，具体取决于操作）。这样，Redis 通过在访问时检查键的过期状态来动态删除过期的键。
这种惰性删除的方式减少了在键到期时的系统开销，因为 Redis 不需要定期地检查每个键的过期状态。相反，它是在访问键的时候检查并删除过期的键，确保及时且高效地释放过期键所占用的资源。
总体来说，Redis通过这种基于惰性检查的机制，实现了有效的键过期删除策略，保证了数据存储的高效性和及时性。
结语 Redis的成功不仅仅源于其技术上的创新，更反映了对数据存储和访问的深刻理解。通过内存存储、单线程模型的巧妙运用，Redis在高并发和低延迟方面表现出色。其数据结构的灵活运用以及简单而强大的命令集，使得Redis成为了解决各类实时应用场景的理想选择。随着技术的不断演进，Redis将继续在数据存储领域发挥关键作用，为全球的开发者和企业提供稳定、高效的数据解决方案，为信息时代的发展贡献力量。
我的其他博客 【MySQL】数据库规范化的三大法则 — 一探范式设计原则-CSDN博客
【JAVA】线程的run()和start()有什么区别？-CSDN博客
【日常聊聊】程序员必备的面试技巧：如何在面试战场上脱颖而出-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e30ea1735e39a85b4472c61f5a9f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a57c9cea1bc105f94703a6bca3d899/" rel="bookmark">
			【开源】基于JAVA的智慧社区业务综合平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 业务类型模块2.2 基础业务模块2.3 预约业务模块2.4 反馈管理模块2.5 社区新闻模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 业务类型表3.2.2 基础业务表3.2.3 预约业务表3.2.4 反馈表3.2.5 社区新闻表 四、系统展示五、核心代码5.1 查询基础业务5.2 新增基础业务子项5.3 查询业务类型5.4 新增反馈5.5 查询预约业务子项 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的智慧社区业务综合平台，包含了业务类型模块、基本业务模块、预约业务模块、业务分析模块、工作反馈模块和社区新闻模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，智慧社区业务综合平台基于角色的访问控制，给社区管理员、社区工作人员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
智慧社区业务综合管理平台是一种基于互联网和物联网技术的智能化管理系统，旨在为社区内的各项业务提供高效便捷的管理服务。本文以某城市社区为例，从需求分析、系统设计、数据采集与处理、功能实现等方面进行了深入研究和探讨。在需求分析阶段，我们通过对用户需求和社区运营情况的调查，确定了系统所需的基本功能模块，包括物业管理、安全监控、环境卫生、社区活动等。在系统设计阶段，我们采用了分层架构设计和模块化开发思路，保证了系统的稳定性和可扩展性。该智慧社区业务综合管理平台具有方便快捷、高效精准、智能化管理等优点，可以为社区管理者提供更好的决策支持和服务，同时也为社区居民提供更加便捷的生活方式。
智慧社区业务综合管理平台基于Java语言开发，采用前后端分离的技术架构，前端采用Vue.js，后端采用SpringBoot框架，采用MySQL数据库。
1.2 项目录屏 二、功能模块 智慧社区业务综合管理平台的功能性需求主要包含业务类型模块、基础业务模块、预约业务模块、反馈管理模块、社区新闻模块这五大模块，系统是基于浏览器运行的web管理后端，其中各个模块详细说明如下。
2.1 业务类型模块 智慧社区业务综合管理平台需要业务类型模块，主要是为了实现社区服务的分类管理和精细化管理。具体来说，业务类型模块可以将社区服务按照不同的业务类型进行划分，例如物业管理、安全监控、环境卫生、社区公共服务等。这样一来，居民就能够更加清晰地了解每种业务类型所包含的具体服务内容，同时也方便管理人员对各项服务进行统筹规划和综合管理。此外，通过业务类型模块还可以实现社区服务的个性化定制和差异化管理。不同的社区可能存在着不同的服务需求和管理特点，通过业务类型模块，管理人员可以根据不同的社区情况设置相应的服务类型和服务标准，并灵活调整和优化社区服务的组织和运营方式，从而达到最佳的服务效果。因此，业务类型模块是智慧社区业务综合管理平台中非常重要的一个功能模块，它有助于提高社区服务的质量和效率，实现社区管理的科学化和智能化。
2.2 基础业务模块 智慧社区业务综合管理平台需要基础业务模块，是因为这些基础业务模块是整个平台的基础设施和核心组成部分，是保证平台正常运行和提供服务的关键。包括用户管理、角色权限管理、系统设置等功能，实现对整个平台的管理和控制。包括数据采集、存储、处理和分析等功能，确保平台数据的完整性、安全性和可靠性。包括视频监控、报警和预警等功能，实现对社区安全的全面监测和实时处理。包括公告发布、建议反馈、在线投诉等功能，提高社区居民参与社区公共事务的积极性和主动性。包括物业费管理、报修、维修等功能，保障社区内各种设施和设备的正常运行。以上这些基础业务模块是智慧社区业务综合管理平台不可或缺的基础设施，它们为平台的各种功能模块提供了支撑和保障。只有这些基础模块运转良好，整个智慧社区平台才能稳定、高效地运行，为居民提供更好的服务。
2.3 预约业务模块 智慧社区业务综合管理平台需要预约业务模块，是因为这个模块可以帮助居民更方便地安排和使用社区服务资源，并且减少服务过程中的等待时间和人员流动量，提高服务效率。居民可以通过智慧社区平台进行各种服务的预约，如家政服务、物业维修、医疗服务等，避免了居民在现场排队等待的情况，降低了服务压力。智慧社区平台可以对居民的预约信息进行全面管理，包括记录预约人员的信息、服务时间、服务内容等，方便服务提供者进行服务调度和管理。智慧社区平台可以通过短信等方式提醒居民服务时间，并且提前预警服务提供者，保证服务顺利完成。智慧社区平台可以统计居民的服务需求和服务满意度，为社区提供定制化服务，同时也为服务提供者提供数据支持，改进服务质量。因此，预约业务模块能够更好地整合社区服务资源，提高社区服务效率和质量，为社区居民提供更加便捷、高效、优质的服务。
2.4 反馈管理模块 智慧社区业务综合管理平台需要反馈管理模块，是因为反馈管理模块可以及时收集和反馈社区居民的意见和建议，从而帮助平台及时调整和改善服务，提高服务质量和用户满意度。反馈管理模块可以在平台上设置投诉和建议渠道，让社区居民随时随地提交自己的意见和建议。反馈管理模块可以将社区居民的意见和建议及时传递给相关部门，并跟踪处理进度。同时，反馈管理模块还可以向社区居民反馈处理结果，保证信息的及时性和透明度。反馈管理模块可以对社区居民的意见和建议进行数据分析和统计，帮助平台了解社区居民的需求和痛点，以便优化服务内容和形式，提高服务质量和用户满意度。因此，反馈管理模块是智慧社区业务综合管理平台不可或缺的一部分，可以有效提升平台的服务水平和社区居民的参与度，促进智慧社区建设的健康发展。
2.5 社区新闻模块 智慧社区业务综合管理平台需要社区新闻模块，社区新闻模块可以及时发布社区内的最新消息和动态，为社区居民提供即时、全面的信息服务，提高信息的传播效率。促进社区交流与互动，社区新闻模块可以为社区居民提供一个交流平台，通过互动评论等方式增加居民之间的交流与互动，促进社区凝聚力的形成。增强社区归属感，社区新闻模块能够充分展示社区的风貌和特色，让社区居民更好地了解和认识自己所居住的社区，从而增强他们的社区归属感。丰富社区服务内容，社区新闻模块可以为智慧社区平台增加一项新的服务内容，满足社区居民对于信息获取的需求，提高智慧社区平台的综合服务水平。因此，智慧社区业务综合管理平台需要社区新闻模块来为社区居民提供更好的信息服务，促进社区交流与互动，增强社区归属感，并丰富社区服务内容。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 业务类型表 3.2.2 基础业务表 3.2.3 预约业务表 3.2.4 反馈表 3.2.5 社区新闻表 四、系统展示 五、核心代码 5.1 查询基础业务 @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94a57c9cea1bc105f94703a6bca3d899/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b9b8dff5f4fbc9fa4730512af13f73/" rel="bookmark">
			数据库命令集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库必用命令合集1 1、创建数据库
语法格式：
CREATE DATABASE 数据库名;
1.1、创建数据库，并指定字符集和校对规则
语法格式：
CREATE DATABASE 数据库名
DEFAULT CHAARACTER 字符集
COLLATE 校对规则;
1.2、进入到指定数据库中
语法格式：
USE 数据库名;
1.3、修改数据库默认字符集和校对规则
语法格式：
ALTER DATABASE 数据库名
DEFAULT CHARACTER SET 字符集
DEFAULT COLLATE 校对规则;
1.4、删除数据库
语法格式：
DROP DATABASE 数据库名;
1.5、显示数据库
语法格式：
SHOW DATABASES;
2、表
2.1、创建表
语法格式：
CREATE TABLE 表名
(列名 数据类型 是否允许为空,
列名 数据类型 是否允许为空);
2.2、向表中增加列
语法格式：
ALTER TABLE 表名 ADD COLUMN 列名 数据类型 是否允许为空;
2.3、修改列的名称
语法格式：
ALTER TABLE 表名 CHANGE 旧列名 新列名 数据类型 是否允许为空;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99b9b8dff5f4fbc9fa4730512af13f73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb33f27a6147fe36fe3f57105126975b/" rel="bookmark">
			网络安全-防御保护01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全概述 网上搜索，这点网上资源很多，网络安全发展史属于是
网络安全背景 网络空间安全--Cyberspace（赛博朋克）
2023年美国提出网络空间大点概念--一个由信息基础设施组成的互相依赖的网络。
我国官方文件定义：网络空间位继海，陆，空，天意外的第五大人类活动领域
通信保密阶段---计算机安全阶段---信息系统安全---网络空间安全
APT攻击---高级持续性魏姐
2017.6《网络安全法》正式生效
2019.5《信息安全技术网络安全等级保护基本要求等三大核心标准发布》
等级保护 常见的网络OSI七层模型漏洞问题 应用层-物理损坏 链路层-MAC攻击
链路层-ARP欺骗
网络层-ICMP攻击
传输层-TCP SYN Flood攻击（Dos纯流量攻击）
介绍防御三种:
1.代理防火墙（风险转移）--每目标IP代理阈值，每目标IP丢包阈值--经验值
2.首包丢包
3.SYN cookie（把状态信息记录在cookie里面）
4.DDos攻击--僵尸网络
5.DNS欺骗
网络中有两种链路资源+算力
MTU(最大传输字节)=1500字节
恶意程序的多个特征 1.非法性
2.隐蔽性
3.潜伏性
4.可触发性
5.表现性
6.破坏性
7.传染性---蠕虫病毒的典例
8.针对性
9.变异性
10.不可预见性
病毒分类--三大类 普通病毒---以破坏为目的的病毒
木马病毒---以控制为目的的病毒
蠕虫病毒---具有传播性的病毒-
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76392c39688b3368558f31569433be7/" rel="bookmark">
			计算机毕业设计SSM基于的在线影院系统a079l9【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
vue + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 3.3 系统用例分析 在线影院系统综合网络空间开发设计要求。目的是将传统管理方式转换为在网上管理，完成在线影院的方便快捷、安全性高、交易规范做了保障，目标明确。在线影院系统可以将功能划分为管理员功能和用户功能。
（1）、管理员关键功能包括个人中心、用户管理、电影管理、电影类别管理、电影库管理、系统管理、订单管理等进行管理。管理员用例如下：
图3-1 管理员用例图
（2）、用户注册登录进入系统可以对首页、电影、影视资讯、个人中心等进行管理。用户用例如下：
图3-2 用户用例图
3.4 系统流程分析 3.4.1 登录流程 每个用户都有专属的密码和账号，在输入合法的账号和密码之后即可进入系统。登录流程如图3-3所示：
图3-3 登录流程图
3.4.2 添加信息流程 管理层人员有添加信息功能。添加信息流程如图3-4所示：
图3-4 添加信息流程图
3.4.3 修改信息流程 管理层人员有修改信息功能。修改信息流程如图3-5所示：
图3-5 修改信息流程图
3.5　本章小结
基于ssm的在线影院系统从市场、技术、经济、功能等方面分析了系统的功能需求，可以满足用户的在线影院系统管理需求，帮助用户安全、高效地找到合适的在线影院信息，因此有必要对其进行课题研究。
第4章　系统设计 系统设计是将被设计对象划分为两个模块进行构建，各个模块相互支持，相互制约，它们的组合是一个完整的系统。通过系统设计，可以最大限度地满足系统的预期目标，明确软件开发的目的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c76392c39688b3368558f31569433be7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b39fef96624fbaafed11d13e6ae7fc9/" rel="bookmark">
			计算机毕业设计SSM基于的政府办公用品管理系统12p2s9【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
vue + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 3.1功能需求分析 需求分析的首要任务是要分析用户的需求，知道用户存在的一些情况，并且要明确用户的使用状况，然后设计规划解决的问题。其中在使用定性的分析以及定量的分析，从这两个方面获取用户的需求。一方面定性的分析获得的应该是用户的基本需求，能够发现现在人们的习惯要求。所以定性的需要主要是为了多与用户交流，从而更为深刻的了解一些存在的需求问题；定量的分析则是发现一些潜在的用户，并且获得不一样的反馈内容。所以定量的需求要让用户来阐述一些情况，一定让使用者清晰的进行客观的描述，这样才能够比较全面的获得用户的需求所在。
其中获得用户需求以后，就要可以将用户需求设计为系统的功能模块。在能及时的分析和发现有关需求的情况下，需要系统同时的跟进需求设计。在政府办公用品管理过程中还需要创建需求工作的数据分析，以便于后面的分析做总结。写入一个需求的报告内容，其中需要包含完整的描述需求、以及功能需求、模型等后续开发过程中还需要用到的部分资料。
需求的分析中用户需求就是比较的重要，而且可以通过各种的路径，以及各用户对于系统的功能需求，你需要对这些内容做出整理以及分类，然后分析这些需求的现实情况下的可能原因，还需要有认真的分析过程，结合现实的情况下最终做出一系列的需求资料。在有关用户的期望分析中能够明确一些可能实现的情况，政府办公用品管理功能是许多个可以测试的功能相结合的，正是由于这些功可以使得用户能够更加积极的提供出需求，让系统功能可以变得更加的完善。这样就可以保证所有设计的功能模块都是可以用到的，而且也是可测试的，对于后续系统的开发能够有比较关键的作用，也能快速完成用户所提供的需求。 3.2系统可行性分析 3.2.1技术可行性 该系统使用java技术开发，MySQL数据库同ssm框架联合开发并实现。对于以上描述的技术，在当代都是较为成熟的技术和平台，虽然它们都有自已的体系，但在程序员的眼里，它们的配合度是很高的，网上的相关博客中每个创建项目的帖子，它们都会出现，数据库负责管理数据，开发工具负责管理项目，技术负责代码的框架，既相互独立，又相互依赖。以上描述的工具、技术都已转化为自身的技能，所以从技术角色考虑是可行的，工作人员对于技术的关注度并不高，只要程序可用即可。
3.2.2 经济可行性 经济可行性，可分为两种，支出和收入，该系统属于研究型毕业设计，所以收入部分暂不考虑。支出可分为，设备、场地、开发环境、人力、时间等一切需考虑的因素，所有信息都是影响形成系统的一部分。设备：只需一台笔记本电脑，配套的输入设备；场地：暂定为图书馆与校内的自习室；开发环境：良好；人力：自身、指导老师、同学；时间：从选题到毕业为止，大约8个月。从以上描述可知，大部分条件已经满足，所以该系统不会存在经济方面的问题，所以是可行的。
3.2.3社会可行性 社会可行性，广义而讲可涉及到道德方面、法律方面、社会方面，每个方面都会影响系统的形成[12]。本系统的是独立且没有任何传播性质的信息，更涉及不到道德层面，法律层面；本系统也没有触发法律，没有赌博、黄色等类型信息，同时也是遵从国家法律，不会显示任何触发法律层面的信息；社会方面，该系统是为方便用户提供更好的管理方式，是轻量级的政府办公用品管理系统，会为人们带来快速并有效查询的功能，也是具有贡献意义的。总体而言，该系统也是具有社会可行性的。
3.3流程图设计 流程图是用具体的图形符号和相应的线条来表示系统执行的整个过程。因为这种图可以很容易地描述系统的一系列过程，所以它的所有图形符号都是比较关键的，基本上一个图形符号可以表示一个过程的一个步骤。流程图不仅提供了一个比较完整、全面的实施过程，而且可以发现整个团队协同设计过程中可能存在的缺陷和不足，便于在后续过程中及时对系统进行修正和改进。
通过流程图可以对系统的需求和相关流程进行分析，可以详细细分为各个部分的设计。对于设计人员来说在开发过程中要能够以流程图为基础，能够快速的提高自己的逻辑思维，并且也能够指导后续的操作在系统设计中最重要的部分就是程序的设计，然后具体的编写程序，流程图是设计过程中的重要工具，下面是流程图的部分设计。
3.3.1 登录流程图 登录流程是该系统的第一个流程，登录的第一步是输入账号、密码登录，系统会验证账号与密码是否正确，正确时系统会判断账号类型再进入不同的后台；不正确时，会返回到登录的第一步，输入用户重新执行登录流程。该流程如图3-1所示。
图3-1登录流程图
3.3.2 添加新用户流程图 添加新用户的流程是先查询新用户名是否已存在，如已有该用户名，需重拟用户名并同时输入新用户的其它信息，添加新用户到数据库时会先验证数据是否完整，信息都正确且完整时，返回并刷新用户列表；信息不正确时，会返回输入信息的那一步。该流程如图3-2所示。
图3-2添加新用户流程图
第四章 系统概要设计 4.1系统设计原理 设计原理，是指一个系统的设计由来，其将需求合理拆解成功能，抽象的描述系统的模块，以模块下的功能。功能模块化后，变成可组合、可拆解的单元，在设计时，会将所有信息分解存储在各个表中，界面不会显示所有定义的字段。在设计时，会有几大要求，抽象、模块化、信息隐藏、耦合低、内聚等特性，本系统的设计也符合以上几大特性。制作和显示流程都属于程序员需要分析研究的一部分[13]。每个模块都是相对独立的，系统前台不显示账号操作权限范围外的信息。
4.2功能模块设计 该章节的功能模块设计，只是大概描述了系统的所有功能模块，将功能按权限来讲解。系统总体功能如图4-1所示。
图4-1 系统总体结构图
4.3 数据库设计 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b39fef96624fbaafed11d13e6ae7fc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b3fcecbc1354f3ba61c720f8b23dfe/" rel="bookmark">
			1.机器学习-机器学习算法分类概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1️⃣机器学习-机器学习算法分类概述 个人简介机器学习算法分类：监督学习、无监督学习、强化学习一·监督学习1. 监督学习分类任务举例：1.1 特征1.2 标签 二·无监督学习1.关键特点2.应用示例3.常见的无监督学习算法 三·强化学习1.定义2.示例场景 四·机器学习开发流程 个人简介 🏘️🏘️个人主页：以山河作礼。
🎖️🎖️:Python领域新星创作者，CSDN实力新星认证，CSDN内容合伙人，阿里云社区专家博主，新星计划导师，在职数据分析师。 🎉🎉免费学习专栏：
1. 《Python基础入门》——0基础入门
2.《Python网络爬虫》——从入门到精通
3.《Web全栈开发》——涵盖了前端、后端和数据库等多个领域
💕💕悲索之人烈焰加身，堕落者不可饶恕。永恒燃烧的羽翼，带我脱离凡间的沉沦。
机器学习算法分类：监督学习、无监督学习、强化学习 一·监督学习 监督学习是机器学习中最常用的一种重要方法，它利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程。简单来说，监督学习就是从已有的标记数据中学习模型，然后利用这个模型对新的未知数据进行预测。
在监督学习中，每个样本都包含输入特征和对应的输出标签。
输入特征也称为特征向量，是一个可以描述样本特性的值；
输出标签通常是离散的类别标签或者连续的数值标签，用来表示样本所属的类别或者具有的属性。
通过训练，模型将学会从输入特征中预测出相应的输出标签。
监督学习的应用场景非常广泛，包括但不限于分类、回归、聚类、降维等任务。分类是监督学习中最为常见的一种任务，它将输入特征映射到某个离散的类别标签上；回归则将输入特征映射到某个连续的数值标签上。
1. 监督学习分类任务举例： 假设我们有一组包含房屋信息的数据集，其中每个样本包含房屋所在街区、房屋价格、住房面积、住房格局等特征，以及一个表示该房屋是否售出的标签。我们可以使用监督学习算法来训练一个分类器，通过分析这些特征和标签的关系，预测新的房屋是否能够售出。
特征向量包括房屋所在街区、价格、面积和格局等属性；
1.1 特征 房屋所在街区：我们可以将其划分为不同的区域，比如市中心、郊区等。
房屋价格：具体的房屋售价，以货币单位表示。
住房面积：房屋的建筑面积，以平方米为单位。
住房格局：房屋的内部布局，比如一室一厅、两室一厅等。
输出标签为离散的类别标签，表示房屋是否售出。
1.2 标签 房屋是否售出：这是一个二元分类问题，可以用0和1来表示。0表示房屋未售出，1表示房屋已售出。
在这个例子中，我们的目标是构建一个分类器，通过分析输入特征（房屋所在街区、价格、面积和格局），预测输出标签（房屋是否售出）。这个任务可以被视为一个分类问题，其中每个样本的输入特征被映射到一个离散的类别标签上（0或1）。
为了解决这个问题，我们可以使用监督学习算法来训练一个分类器。常见的监督学习算法包括逻辑回归、支持向量机、决策树和随机森林等。这些算法可以根据训练数据集中的特征和标签之间的关系，构建出一个模型，用于预测新的未知数据的标签。
在训练过程中，我们需要将训练数据集分成训练集和验证集两部分。训练集用于训练模型，验证集用于评估模型的性能和调整模型参数。常见的评估指标包括准确率、精确率、召回率和F1分数等。通过不断调整模型参数和优化模型结构，我们可以提高模型的预测准确性和泛化能力。通过训练这个分类器，我们可以发现一些规律，比如在某个街区的房屋更容易售出，或者价格较高的房屋更难售出等。
二·无监督学习 无监督学习是一种机器学习训练方法，其本质是一个统计手段。在这种方法中，我们利用无标签的数据来探索和发现潜在的结构或模式。无监督学习在许多领域中都有广泛的应用，包括数据挖掘、机器视觉、自然语言处理等。
1.关键特点 无明确目标：与监督学习不同，无监督学习没有明确的预测目标。它的目的是在数据中寻找隐藏的模式或结构。不需要标签：在无监督学习中，数据集中的样本不需要预先标记或分类。学习过程是通过数据内在的相似性或关联性来进行的。效果难以量化：由于无监督学习没有明确的预测目标，因此很难用一个统一的指标来衡量其效果。通常，我们关注的是发现数据的内在结构或关系。 2.应用示例 异常值检测（风控）：在金融领域，异常值检测常用于识别潜在的欺诈行为或非正常交易模式。通过无监督学习，可以将交易数据根据其特征进行聚类，然后识别出与大多数聚类明显不同的样本，这些样本可能代表异常行为。用户细分：在市场营销中，用户细分是一个重要的步骤。通过无监督学习，可以根据用户的特征和行为将他们分成不同的群体，以便更好地理解每个群体的需求和偏好，从而制定更有针对性的营销策略。推荐系统：这是无监督学习的一个广泛应用领域。通过分析用户的浏览历史、购买记录等行为数据，推荐系统可以识别出用户可能感兴趣的商品或内容，并进行相应的推荐。这种推荐往往基于用户之间的相似性或物品之间的关联性。 3.常见的无监督学习算法 聚类算法：这类算法的目标是将相似的数据样本聚集成不同的群组或簇。常见的聚类算法包括K-means、层次聚类、DBSCAN等。聚类算法在数据挖掘和图像处理等领域有广泛应用。降维算法：这类算法用于降低数据的维度，以减少计算复杂度和更好地理解数据的内在结构。常见的降维算法包括主成分分析（PCA）、t-分布邻域嵌入算法（t-SNE）等。降维算法在可视化、特征提取和机器视觉等领域有重要应用。 三·强化学习 1.定义 强化学习（Reinforcement Learning，RL）是机器学习的一个重要分支，它主要研究智能体（agent）在与环境（environment）的交互过程中如何通过学习策略以达成回报最大化或实现特定目标的问题。强化学习的核心思想是，智能体通过与环境进行交互，不断获取新的信息并更新自身的策略，以最大化长期的累积奖励。与监督学习和无监督学习不同，强化学习没有明确的正确答案或标签，而是依赖于环境的反馈来指导学习过程。
强化学习的常见模型是标准的马尔可夫决策过程（Markov Decision Process，MDP），它由状态、动作和奖励三个基本要素组成。在强化学习中，智能体根据当前状态选择一个动作，并从环境中获得新的状态和奖励。智能体的目标是找到一个最优策略，使得在给定状态下采取最优动作能够最大化长期的累积奖励。
强化学习的算法可以分为策略搜索算法和值函数（value function）算法两类。
策略搜索算法通过直接搜索策略空间来找到最优策略，而值函数算法通过迭代更新值函数来逼近最优策略。此外，深度学习模型可以在强化学习中得到使用，形成深度强化学习。
强化学习中两个核心的概念就是：「智能体」agent和「环境」environment。环境表示智能体生存以及交互的世界。每一次交互时，智能体会观察到世界当前所处「状态」state的「观测值」observation，然后决定采取什么「动作」action。环境会随着智能体的动作而发生变化，当然环境自身也可能一直处于变化中。
智能体会从环境中接收到一个「奖励」reward信号，这个信号可能是一个数值，表示当前环境所处状态的好坏。智能体的目标是：最大化「累积奖励」cumulative reward，也称为「收益」return。强化学习方法就表示智能体通过学习行为来达到这个目标的途径。
强化学习算法的思路非常简单，以游戏为例，如果在游戏中采取某种策略可以取得较高的得分，那么就进一步「强化」这种策略，以期继续取得较好的结果。这种策略与日常生活中的各种「绩效奖励」非常类似。我们平时也常常用这样的策略来提高自己的游戏水平。
在 Flappy bird 这个游戏中，我们需要简单的点击操作来控制小鸟，躲过各种水管，飞的越远越好，因为飞的越远就能获得更高的积分奖励。
2.示例场景 这就是一个典型的强化学习场景：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b3fcecbc1354f3ba61c720f8b23dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b65b8dc5fdc67121efd28c2c01eac2/" rel="bookmark">
			新书速览|MediaPipe机器学习跨平台框架实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MediaPipe助你高效构建移动端短视频应用。MediaPipe、机器学习、短视频应用、视频特效、游戏控制
本书内容
《MediaPipe机器学习跨平台框架实战》以实际项目为线索，带领读者探索MediaPipe在不同场景中的应用，使读者既能了解理论知识，又能通过实践掌握技能。全书共9章，第1章介绍MediaPipe基础；第2章重点探讨MediaPipe的控制流、同步机制以及GPU的使用；第3章介绍MediaPipe中的Facemesh，探讨其在增强现实、AR滤镜和视频会议软件中的应用；第4章将MediaPipe与游戏控制相结合，介绍如何在体感游戏中应用MediaPipe技术；第5章以AR激光剑效果、火箭发射小游戏、空中作图等为例，展示MediaPipe在视觉特效方面的应用；第6章介绍如何使用MediaPipe实现手语识别应用；第7章展示如何通过MediaPipe打造虚拟智能健身教练；第8章通过案例介绍MediaPipe与Unity在游戏与虚拟现实领域整合应用的强大潜力；第9章展望MediaPipe的未来，为读者提供了对这一技术的更深层次的认识和思考。
本书作者
马健健，毕业于上海交通大学，硕士，拥有超过十年的软件架构经验，先后供职于国内 外多家知名公司，目前就职于上海某知名外企，主要负责大数据处理、机器学习应用和 数据挖掘方面的研究和实施工作，长期研究AI虚拟人技术。已出版图书《虚拟偶像AI实 现》《AI创意绘画与视频制作：基于Stable Diffusion和Control NET》
本书读者
《MediaPipe机器学习跨平台框架实战》内容新颖，案例丰富，代码翔实，不仅适合对机器学习感兴趣的程序员、广大编程爱好者，还适合在校学生、创业者或者普通用户学习与参考。
编辑推荐
MediaPipe是一个由谷歌研究开发并开源的多媒体机器学习模型应用框架。它是一个跨平 台框架，适用于桌面/服务器、Android、iOS和嵌入式设备，如Raspberry Pi和Jetson Nano。
MediaPipe是用于构建机器学习管道的框架，主要用于处理视频、音频等时间序列数据。 此外，该框架为流媒体提供了跨平台且可定制的机器学习解决方案。这意味着开发者可 以根据自己的需求定制适合其应用场景的机器学习模型。
MediaPipe已被广泛应用于各种机器学习任务，如人脸识别、人脸3D重建、手势检测、语音识别和对象检测等。在谷歌的一系列重要产品中，如Google Lens、ARCore、Google Home等，都已深度整合了MediaPipe。
具体来说，MediaPipe具备处理视频和音频帧流的能力，通常用于构建交互式应用程序。 例如，其中的FaceMesh模型可以从图像或视频中重建出人脸的3D结构。此外，通过 MediaPipe Solutions，开发者可以为应用配置预构建的处理流水线，为用户提供即时的 、有吸引力的有用输出。
书中以大量案例介绍了MediaPipe在移动端应用，包括增强现实、AR滤镜和视频会议软件、MdiaPipe与游戏控制的结合应用、如何在体感游 戏中应用MediaPipe技术，以AR激光剑效果、火箭发射小游戏、空中作图为例展示了 MediaPipe在视觉特效方面的应用，如何使用MediaPipe实现手语识别应用、如何通过 MediaPipe打造虚拟智能健身教练以及MediaPipe与Unity结合在游戏与虚拟现实领域的应 用等等，精彩粉呈地展现了MediaPipe的强大潜力。
本文节选自《MediaPipe机器学习跨平台框架实战》，内容发布获得作者和出版社授权。
MediaPipe机器学习跨平台框架实战—京东
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b164a2bd28f0a23eedd91414044ff5b/" rel="bookmark">
			运维职业路线技术栈梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba34ffe5191c19b3c2eed3c2a735a857/" rel="bookmark">
			【开源】基于JAVA的图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、 系统介绍二、 功能模块2.1 登录注册模块2.1 图书馆模块2.2 图书类型模块2.3 图书模块2.4 图书借阅模块2.5 公告模块 三、 源码解析3.1 图书馆模块设计3.2 图书类型模块设计3.3 图书模块设计3.4 图书借阅模块设计3.5 公告模块设计 四、 免责说明 一、 系统介绍 图书管理系统是一个用于管理图书馆资源的软件系统，该系统包括图书馆模块、图书类型模块、图书模块、图书借阅模块和公告模块。
图书馆模块是系统的核心模块，用于管理图书馆的基本信息，包括图书馆名称、地址、联系方式等。管理员可以通过该模块进行图书馆信息的添加、修改和删除。
图书类型模块用于管理图书的分类信息。管理员可以在该模块中添加不同的图书类型，如文学、历史、科技等，以便读者更方便地查找和借阅图书。
图书模块是系统中最重要的模块之一，用于管理图书的基本信息，包括图书名称、作者、出版社、ISBN等。管理员可以在该模块中添加、修改和删除图书信息，并可以设置图书的库存数量。
图书借阅模块是读者使用系统的核心模块之一，读者可以通过该模块查询图书的可借阅状态，并可以借阅和归还图书。系统会自动记录借阅记录和归还日期，并提醒读者归还图书。
公告模块用于向读者发布图书馆相关的通知和公告，管理员可以在该模块中发布公告，并可以设置公告的有效期。读者可以通过该模块查看最新的公告信息。
图书管理系统能够高效地管理图书馆的资源，提供便捷的借阅服务，并及时向读者发布图书馆相关的信息和公告。
二、 功能模块 2.1 登录注册模块 图书管理系统支持用户输入账号、密码和图形验证码完成登录，界面如下。
如果用户没有账号，可以完成自助注册，接着再登录系统，如下图所示。
进入系统后，界面如下图所示。
2.1 图书馆模块 图书馆模块是图书管理系统的核心模块之一，它主要负责管理图书馆的基本信息。
图书馆模块记录和管理图书馆的基本信息，如图书馆的名称、地址、联系方式等。这些信息对于读者来说是重要的，他们可以通过查询系统了解图书馆的位置和联系方式，方便他们前往借阅图书，主界面如下图所示。
图书馆模块允许管理员对图书馆的设置进行管理，图书馆模块可以图书馆的有关信息，添加界面如下图所示。
图书馆模块是图书管理系统中不可或缺的一部分，它提供了对图书馆基本信息、设置、资源和统计数据的管理和查询功能，有助于提高图书馆的管理效率和读者的借阅体验。
2.2 图书类型模块 图书管理系统需要图书类型模块是因为图书类型模块对于对图书的分类和管理至关重要，主界面如下图所示。
图书类型模块允许管理员对图书进行分类管理。通过将图书按照不同的类型进行分类，可以让读者更方便地查找和借阅自己感兴趣的图书。例如，可以将图书分为文学、历史、科技等类型，读者可以根据自己的兴趣和需求来选择借阅，图书类型模块的添加界面如下图所示。
图书类型模块提供了一种对图书进行快速检索的方式。读者可以根据图书类型进行搜索，从而快速找到自己想要的图书。这样可以提高读者的检索效率，节省时间，编辑界面如下图所示。
图书类型模块在图书管理系统中具有重要作用，它能够对图书进行分类和管理，方便读者查找和借阅图书，同时也提供了借阅限制和个性化推荐等功能，提升了图书管理系统的效能和读者体验，对于不需要的图书类型，用户可以进行删除操作，如下图所示。
2.3 图书模块 图书管理系统需要图书模块是因为图书模块是系统中最重要的模块之一，它用于对图书的基本信息进行管理，主界面如下。
图书模块负责记录和管理图书的基本信息，如图书名称、作者、出版社、ISBN等。管理员可以在该模块中添加、修改和删除图书信息，确保图书信息的准确性和完整性，图书的录入界面如下图所示。
读者可以通过图书模块进行图书的查询和检索。根据图书名称、作者、ISBN等关键词，读者可以快速找到自己感兴趣的图书，提高图书查找的效率。
图书模块在图书管理系统中具有关键作用，以便读者能够方便地获取和利用图书资源，同时也确保了图书管理系统的高效运行，图书的编辑界面如下图所示。
2.4 图书借阅模块 图书管理系统需要图书借阅模块是因为借阅模块是系统中的核心模块之一,它负责处理图书借阅过程的各个环节，图书借阅模块的主界面如下图所示。
图书借阅模块记录和管理借阅记录。
对于读者而言，他们可以通过查询借阅记录来了解自己的借阅历史、当前借阅状态等信息。
对于管理员而言，他们可以通过该模块对借阅记录进行统计和分析，了解图书借阅情况,制定更合理的图书采购计划。
用户可以点击添加按钮，完成图书借阅登记，如下图所示。
读者可以查询自己的借阅详情，如下图所示。
管理员可以点击归还按钮，完成学生的还书申请，如下图所示。
图书借阅模块在图书管理系统中不可或缺，它提供了借阅管理、借阅记录管理等功能，为读者提供了便利的借阅服务，同时也为管理员提供了借阅数据的管理功能。
2.5 公告模块 图书管理系统需要公告模块是为了实现与读者和管理员之间的信息交流和沟通，主界面如下图所示。
公告模块可以用于向读者和管理员发布重要通知和公告，例如图书馆临时关闭、借阅规则变动、图书采购计划等重要信息可以通过公告模块发布，确保读者和管理员能够及时了解到相关信息，管理员可以发布公告，如下图所示。
三、 源码解析 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba34ffe5191c19b3c2eed3c2a735a857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6fa00c061fc74e5b1fa685e9e20001/" rel="bookmark">
			风二西CTF流量题大集合-刷题笔记|NSSCTF流量题（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.[鹤城杯 2021]流量分析 flag{w1reshARK_ez_1sntit}
3.[CISCN 2023 初赛]被加密的生产流量 c1f_fi1g_1000
4.[GKCTF 2021]签到 flag{Welc0me_GkC4F_m1siCCCCCC!}
5.[闽盾杯 2021]Modbus的秘密 flag{HeiDun_2021_JingSai}
6.[LitCTF 2023]easy_shark 7.[CISCN 2022 初赛]ez_usb flag{20de17cc-d2c1-4b61-bebd-41159ed7172d}
8.[LitCTF 2023]Take me hand (初级) LitCTF{Give_y0ur_hand_to_me!!!_plz}
9.[NISACTF 2022]破损的flag imgulfflagiswelcometfjnu 修正 imgulfflagiswelcometofjnu
10.[HGAME 2022 week1]好康的流量 hgame{ez_1mg_Steg4n0graphy}
11.[闽盾杯 2021]日志分析 ngjfdsUbdK
12.[鹤城杯 2021]A_MISC flag{cd2c3e2fea463ded9af800d7155be7aq}
13.[蓝帽杯 2022 初赛]domainhacker 416f89c3a5deb1d398a1a1fce93862a7
14.[HUBUCTF 2022 新生赛]messy_traffic 15.[安洵杯 2019]Attack 16.[闽盾杯 2021]DNS协议分析 flag{e662ac154ca376e1c001ee8bbe81318b}
17.[SWPU 2020]来猜谜了 flag{Out9uEsS_1s_V4rY_e4sy}
18.[HNCTF 2022 WEEK2]ez_flow NSSCTF{Hacker!!!!_Y0u_g3t_nny_f10w}
19.[SDCTF 2022]Flag Trafficker sdctf{G3T_F*cK3d_W1r3SHaRK}
20.[CISCN 2021初赛]robot easy_robo_xx
md5：d4f1fb80bc11ffd722861367747c0f10
NSSCTF{d4f1fb80bc11ffd722861367747c0f10}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3eba2b55a187ba948185eb70420dda3/" rel="bookmark">
			嵌入式软件工程师面试题——2025校招社招通用(计算机网络篇)（三十二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明： 面试群，群号： 228447240面试题来源于网络书籍，公司题目以及博主原创或修改（题目大部分来源于各种公司）；文中很多题目，或许大家直接编译器写完，1分钟就出结果了。但在这里博主希望每一个题目，大家都要经过认真思考，答案不重要，重要的是通过题目理解所考知识点，好应对题目更多的变化；博主与大家一起学习，一起刷题，共同进步；写文不易，麻烦给个三连！！！ 1.对称密钥加密的优点缺点？ 答案：
对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。 优点：运算速度快缺点：无法安全地将密钥传输给通信方 2.非对称密钥加密你了解吗？优缺点？ 答案：
非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 公开密钥所有人都可以获得， 通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密， 接收方收到通信内容后使用私有密钥解密。 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。 优点：可以更安全地将公开密钥传输给通信发送方；缺点：运算速度慢。 3.HTTPS是什么 答案：
HTTPS 并不是新协议，而是让 HTTP 先和 SSL （ Secure Sockets Layer ）通信，再由 SSL 和 TCP 通 信，也就是说 HTTPS 使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 4.HTTP的缺点有哪些？ 答案：
使用明文进行通信，内容可能会被窃听；不验证通信方的身份，通信方的身份有可能遭遇伪装；无法证明报文的完整性，报文有可能遭篡改。 5.TCP对应的应用层协议 答案：
FTP：定义了文件传输协议，使用21端口.
Telnet：它是一种用于远程登陆的端口,23端口
SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。
POP3：它是和SMTP对应，POP3用于接收邮件。 6.UDP对应的应用层协议 答案：
DNS：用于域名解析服务，用的是53号端口
SNMP：简单网络管理协议，使用161号端口
TFTP(Trival File Transfer Protocal)：简单文件传输协议，69 7.可以解释一下RTO，RTT和超时重传分别是什么吗？ 答案：
超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况： 发送的数据没能到达接收端，所以对方没有响应。接收端接收到数据，但是ACK报文在返回过程中丢失。接收端拒绝或丢弃数据。 RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。 通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......重传次数到达上限之后停止重传。 RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳 定。 8.文件上传漏洞是如何发生的？你有经历过吗？ 答案： 文件上传漏洞，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。 许多第三方框架、服务，都曾经被爆出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等等，可被攻击者上传恶意代码，有可能服务端就被人黑了。 9.CSRF攻击？你知道吗？ 答案：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3eba2b55a187ba948185eb70420dda3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183e944ed8161fda149040c3bf8c54d5/" rel="bookmark">
			（附源码）django影院客服订票系统 毕业设计43697
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
摘要 1 绪论 1.1研究背景 1.2选题目的与意义 1.3django框架介绍 1.4论文结构与章节安排 2 影院客服订票系统系统分析 2.1 可行性分析 2.1.1 技术可行性分析 2.1.2 经济可行性分析 2.1.3 法律可行性分析 2.1.4 操作可行性分析 2.2 系统功能分析 2.2.1 功能性分析 2.2.2 非功能性分析 2.3 系统用例分析 2.4 系统流程分析 2.4.1 数据流程 2.4.2 业务流程 2.5本章小结 3 影院客服订票系统总体设计 3.1 系统功能模块设计 3.1.1整体功能模块设计 3.1.2用户模块设计 3.1.3 评论管理模块设计 3.1.4电影信息管理模块设计 3.2 数据库设计 3.2.1 数据库概念结构设计 3.3.2 数据库逻辑结构设计 3.4本章小结 4 影院客服订票系统详细设计与实现 4.1用户功能模块 4.1.1 前台首页界面 4.1.2 用户注册界面 4.1.3 用户登录界面 4.1.4公告栏界面 4.1.5电影资讯界面 4.1.6电影信息界面 4.1.7购票界面 4.1.8退票管理界面 4.2管理人员功能模块 4.2.1公告栏管理界面 4.2.2 系统用户管理界面 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183e944ed8161fda149040c3bf8c54d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b23157f205d3159676c5ffc9ded4fcd/" rel="bookmark">
			使用双异步后，如何保证数据一致性？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前情提要二、通过Future获取异步返回值1、FutureTask 是基于 AbstractQueuedSynchronizer实现的2、FutureTask执行流程3、get()方法执行流程 三、FutureTask源码具体分析1、FutureTask源码2、将异步方法的返回值改为```Future&lt;Integer&gt;```，将返回值放到```new AsyncResult&lt;&gt;();```中； 3、通过```Future&lt;Integer&gt;.get()```获取返回值：4、这里也可以通过新线程+Future获取Future返回值在BUG中磨砺，在优化中成长 大家好，我是哪吒。
一、前情提要 在上一篇文章中，我们通过双异步的方式导入了10万行的Excel，有个小伙伴在评论区问我，如何保证插入后数据的一致性呢？
很简单，通过对比Excel文件行数和入库数量是否相等即可。
那么，如何获取异步线程的返回值呢？
二、通过Future获取异步返回值 我们可以通过给异步方法添加Future返回值的方式获取结果。
FutureTask 除了实现 Future 接口外，还实现了 Runnable 接口。因此，FutureTask 可以交给 Executor 执行，也可以由调用线程直接执行FutureTask.run(）。
1、FutureTask 是基于 AbstractQueuedSynchronizer实现的 AbstractQueuedSynchronizer简称AQS，它是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及 维护被阻塞线程的队列。
基于 AQS 实现的同步器包括： ReentrantLock、Semaphore、ReentrantReadWriteLock、 CountDownLatch 和 FutureTask。
基于 AQS实现的同步器包含两种操作：
acquire，阻塞调用线程，直到AQS的状态允许这个线程继续执行，在FutureTask中，get()就是这个方法；release，改变AQS的状态，使state变为非阻塞状态，在FutureTask中，可以通过run()和cancel()实现。 2、FutureTask执行流程 执行@Async异步方法；建立新线程async-executor-X，执行Runnable的run()方法，（FutureTask实现RunnableFuture，RunnableFuture实现Runnable）；判断状态state； 如果未新建或者不处于AQS，直接返回；否则进入COMPLETING状态，执行异步线程代码； 如果执行cancel()方法改变AQS的状态时，会唤醒AQS等待队列中的第一个线程线程async-executor-1；线程async-executor-1被唤醒后 将自己从AQS队列中移除；然后唤醒next线程async-executor-2；改变线程async-executor-1的state；等待get()线程取值。 next等待线程被唤醒后，循环线程async-executor-1的步骤 被唤醒从AQS队列中移除唤醒next线程改变异步线程状态 新建线程async-executor-N，监听异步方法的state 如果处于EXCEPTIONAL以上状态，抛出异常；如果处于COMPLETING状态，加入AQS队列等待；如果处于NORMAL状态，返回结果； 3、get()方法执行流程 get()方法通过判断状态state观测异步线程是否已结束，如果结束直接将结果返回，否则会将等待节点扔进等待队列自旋，阻塞住线程。
自旋直至异步线程执行完毕，获取另一边的线程计算出结果或取消后，将等待队列里的所有节点依次唤醒并移除队列。
如果state小于等于COMPLETING，表示任务还在执行中； 如果线程被中断，从等待队列中移除等待节点WaitNode，抛出中断异常；如果state大于COMPLETING； 如果已有等待节点WaitNode，将线程置空；返回当前状态； 如果任务正在执行，让出时间片；如果还未构造等待节点，则new一个新的等待节点；如果未入队列，CAS尝试入队；如果有超时时间参数； 计算超时时间；如果超时，则从等待队列中移除等待节点WaitNode，返回当前状态state；阻塞队列nanos毫秒。 否则阻塞队列； 如果state大于COMPLETING； 如果执行完毕，返回结果；如果大于等于取消状态，则抛出异常。 很多小朋友对读源码，嗤之以鼻，工作3年、5年，还是没认真读过任何源码，觉得读了也没啥用，或者读了也看不懂~
其实，只要把源码的执行流程通过画图的形式呈现出来，你就会幡然醒悟，原来是这样的~
简而言之：
1. 如果异步线程还没执行完，则进入CAS自旋；
2. 其它线程获取结果或取消后，重新唤醒CAS队列中等待的线程；
3. 再通过get()判断状态state；
4. 直至返回结果或（取消、超时、异常）为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b23157f205d3159676c5ffc9ded4fcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e31e059c2d5b5377eff3021e8cda33de/" rel="bookmark">
			springboot第51集：lombok，Swagger，k8s，缓存，sentinel周刊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Getter和@Setter ：该注解可以使用在类上也可以使用在属性上。生成的getter遵循布尔属性的约定。在使用该注解时，会默认生成一个无参构造。和对应的getter、setter方法
@ToString ：该注解使用在类上，编译后toString方法返回将会以字段的名称-值的形式输出
@EqualsAndHashCode ：该注解使用在类上，同时生成equals和hashCode。
@AllArgsConstructor ：该注解使用在类上，提供全参数的构造方法，默认不提供无参构造。
@NoArgsConstructor ：该注解使用在类上，提供无参构造
@Data ：使用@Data注解就可以有下面几个注解的功能：@ToString、@Getter、@Setter、@EqualsAndHashCode、@NoArgsConstructor。
需要注意的是：同时使用@Data和@AllArgsConstructor后 ，默认的无参构造函数失效，如果需要它，要重新设置@NoArgsConstructor
@Slf4j ：在类上注解后，可直接调用log
@Synchronized ：方法中所有的代码都加入到一个代码块中，默认静态方法使用的是全局锁，普通方法使用的是对象锁，当然也可以指定锁的对象。
@SneakyThrows ：当我们需要抛出异常，在当前方法上调用，不用显示的在方法名后面写 throw
@NonNull ：增加不为空判断
@Builder：bulder 模式构建对象。
@Cleanup：自动化关闭流，相当于 try with resource
代码示例 @Api
@Api(value = "用户博客", tags = "博客接口") public class NoticeController { } @ApiOperation
@GetMapping("/detail") @ApiOperation(value = "获取用户详细信息", notes = "传入notice" , position = 2) public R&lt;Notice&gt; detail(Integer id) { Notice detail = noticeService.getOne(id); return R.data(detail ); } @ApiResponses
@GetMapping("/detail") @ApiOperation(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e31e059c2d5b5377eff3021e8cda33de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78d9ad56e43f3358e0b4888966a9839/" rel="bookmark">
			Python - 深夜数据结构与算法之 字符串常规操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.引言
二.字符串简介
1.定义
2.遍历
3.比较
三.经典算法实战
1.To-Lower-Case [709]
2.Len-Of-Last-Word [58]
3.Jewels-And-Stones [771]
4.Unique-Char [787]
5.String-To-Integer [8]
6.Longest-Common-Prefix [14]
7.Reverse-String [344]
8.Reverse-String-2 [541]
9.Reverse-Words-In-Str [151]
10.Reverse-String-In-Str 3[557]
11.Reverse-Only-Letters [917]
12.Group-Anagrams [49]
13.Valid-Palindrome [125]
14.Valid-Palindrome 2 [680]
15.Longest-Palindromic [5]
四.总结
一.引言 本文介绍字符串相关算法，以及字符串题目用到的一些关联数据结构。
二.字符串简介 1.定义 Python、Java 的 String 是不可变的，C++ 中是可变的。
2.遍历 3.比较 这里主要 Java 有区别，当使用 x==y 时，比较的是二者的指针，所以如果要比较字符串相等，需要使用 equals，如果忽略大小写则使用 IgnoreCase 的情况。
三.经典算法实战 1.To-Lower-Case [709] 转换小写: https://leetcode.cn/problems/to-lower-case/description/
◆ 题目分析
最暴力的方法就是构造 {"A": "a", ... , "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a78d9ad56e43f3358e0b4888966a9839/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd17eb12cd3f84e01be44bfe405498a0/" rel="bookmark">
			Python - 深夜数据结构与算法之 高级字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.引言
二.经典算法实战
1.Longest-Common-Sub-Seq [1143]
2.Edit-Distance [72]
3.Longest-Palindromic-Str [5]
4.Distinct-Sub-Seq [115]
5.Regular-Exp-Match [10]
三.总结
一.引言 上一节介绍了字符串的基本操作，本文介绍字符串更复杂的一些操作，主要设计动态规划与字符串扩展。
二.经典算法实战 1.Longest-Common-Sub-Seq [1143] 最长公共子序列: https://leetcode.cn/problems/longest-common-subsequence/description/
◆ 题目分析
状态转移方程:
根据二维 DP Table 理解转移方程更轻松些。
◆ 动态规划
class Solution(object): def longestCommonSubsequence(self, text1, text2): """ :type text1: str :type text2: str :rtype: int """ m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): c1 = text1[i - 1] for j in range(1, n + 1): c2 = text2[j - 1] if c1 == c2: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1] 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd17eb12cd3f84e01be44bfe405498a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965bff05b0b0da8140f6aa2164b7a673/" rel="bookmark">
			Sqoop与Kafka的集成：实时数据导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将Sqoop与Kafka集成是实现实时数据导入和流处理的关键步骤之一。Sqoop用于将数据从关系型数据库导入到Hadoop生态系统中，而Kafka则用于数据流的传输和处理。本文将深入探讨如何使用Sqoop与Kafka集成，提供详细的步骤、示例代码和最佳实践，以确保能够成功实现实时数据导入。
什么是Sqoop和Kafka？ Sqoop：Sqoop是一个开源工具，用于在Hadoop生态系统中传输数据和关系型数据库之间进行数据导入和导出。它使数据工程师能够轻松将结构化数据从关系型数据库导入到Hadoop集群中，以供进一步的数据处理和分析。
Kafka：Apache Kafka是一个分布式流处理平台，用于构建实时数据流应用程序和数据管道。Kafka提供了持久性、高可用性和可伸缩性，用于传输大规模数据流，支持发布-订阅和批处理处理模式。
步骤1：安装和配置Sqoop 要开始使用Sqoop与Kafka集成，首先需要在Hadoop集群上安装和配置Sqoop。
确保已经完成了以下步骤：
下载和安装Sqoop：可以从Sqoop官方网站下载最新版本的Sqoop，并按照安装指南进行安装。
配置数据库驱动程序：Sqoop需要适用于关系型数据库的数据库驱动程序。将数据库驱动程序（通常是一个JAR文件）放入Sqoop的lib目录中。
配置Sqoop连接：编辑Sqoop的配置文件（sqoop-site.xml）并配置数据库连接信息，包括数据库URL、用户名和密码。
步骤2：创建Kafka主题 在将数据从关系型数据库导入到Kafka之前，需要创建一个Kafka主题。Kafka主题是用于组织和存储数据流的逻辑通道。
以下是一个示例，演示如何使用Kafka命令行工具创建一个主题：
kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic mytopic 在这个示例中，创建了一个名为mytopic的Kafka主题，具有一个分区和一个副本。
步骤3：使用Sqoop将数据导入Kafka 一旦Sqoop安装和配置完成，可以使用Sqoop将数据从关系型数据库导入到Kafka主题。
以下是一个示例，演示了如何执行这一步骤：
sqoop export \ --connect jdbc:mysql://localhost:3306/mydb \ --username myuser \ --password mypassword \ --table mytable \ --export-dir /user/hadoop/mytable_data \ --input-fields-terminated-by ',' \ --columns id,name,age \ --input-lines-terminated-by '\n' \ --input-null-string '' \ --input-null-non-string '' --export \ --driver com.mysql.jdbc.Driver \ --table mytable \ --columns id,name,age \ --export-dir /user/hadoop/mytable_data \ --input-fields-terminated-by ',' \ --input-lines-terminated-by '\n' \ --input-null-string '' \ --input-null-non-string '' 解释一下这个示例的各个部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965bff05b0b0da8140f6aa2164b7a673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4b74e39597aa74953698c9e64bcd5f/" rel="bookmark">
			100天精通Python（实用脚本篇）——第113天：基于Tesseract-OCR实现OCR图片文字识别实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 专栏导读1. OCR技术介绍2. 模块介绍3. 模块安装4. 代码实战4.1 英文图片测试4.2 数字图片测试4.3 中文图片识别 书籍分享 专栏导读 🔥🔥本文已收录于《100天精通Python从入门到就业》：本专栏专门针对零基础和需要进阶提升的同学所准备的一套完整教学，从0到100的不断进阶深入，后续还有实战项目，轻松应对面试，专栏订阅地址：https://blog.csdn.net/yuan2019035055/category_11466020.html
优点：订阅限时9.9付费专栏进入千人全栈VIP答疑群，作者优先解答机会（代码指导、远程服务），群里大佬众多可以抱团取暖（大厂内推机会）专栏福利：简历指导、招聘内推、每周送实体书、80G全栈学习视频、300本IT电子书：Python、Java、前端、大数据、数据库、算法、爬虫、数据分析、机器学习、面试题库等等
1. OCR技术介绍 OCR，即光学字符识别（Optical Character Recognition），是一种将印刷体字符转化为计算机可读文字的技术。OCR技术可以将纸质文档、扫描文档、照片等转化为可编辑的电子文件，方便用户进行编辑、存储和共享。
OCR技术的应用范围非常广泛。例如，银行和保险公司可以使用OCR技术来处理各种表格和文件，包括支票、发票、合同等，从而提高办公效率。医院可以使用OCR技术来处理病历、处方和医学报告，从而提高医疗质量和效率。政府机构可以使用OCR技术来处理各种表格和文件，例如税务申报表、选民登记表等，从而提高政府服务的效率和质量。
OCR技术的原理是利用光学扫描仪将纸质文档转化为数字图像，然后通过图像处理算法将图像中的字符识别出来，并转化为计算机可读的文字。OCR技术的核心是字符识别算法，这个算法需要考虑到各种字体、字号、字距、倾斜度、噪声等因素。
OCR技术的发展历史可以追溯到20世纪50年代，当时的OCR技术只能处理单一字体、字号、字距的文本。随着计算机技术的不断发展，OCR技术也不断进步，现在的OCR技术能够处理各种字体、字号、字距、倾斜度、噪声等复杂条件下的文本，并且具备高精度和高速度的特点。
总之，OCR技术是一种非常实用的技术，可以帮助用户将纸质文档转化为电子文件，从而提高办公效率和工作质量。随着计算机技术的不断进步，OCR技术也将不断发展，为用户提供更加高效和便捷的服务。
2. 模块介绍 Tesseract OCR（Optical Character Recognition）是一个免费的开源OCR引擎，由Google开发和维护。它能够识别图像中的文本，并将其转换为可编辑和可搜索的文本格式。Tesseract支持超过100种语言的文本识别，并且具有高度的准确性和可扩展性。
3. 模块安装 1、安装Tesseract、Tesseract、Pillow模块，可以使用以下命令：
pip install pytesseract pip install pillow pip install tesseract-ocr # 如果这个安装报错就用下面的手动安装方法 2、从网上找到相应的‘Tesseract-OCR’下载安装（自行寻找对应版本）：https://digi.bib.uni-mannheim.de/tesseract/
3、无脑默认安装即可，
4、安装后的默认文件路径为（这里使用的是Windows版本）：C:\Program Files\Tesseract-OCR\
4. 代码实战 4.1 英文图片测试 1. 测试图片准备：
2、修改下面的Tesseract-OCR的安装路径和图片路径：
import cv2 import pytesseract # 1. 找到Tesseract-OCR的安装路径 pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe' # 2. 图片的路径（注意：图片路径不能有中文 img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b4b74e39597aa74953698c9e64bcd5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ebbfd5b1985f218d0bef9e2201140c/" rel="bookmark">
			AtCoder Regular Contest 170（A~B）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A - Yet Another AB Problem
给你两个字符串S和T，你可以对S执行操作，选择两个字符，将前面的改为A，后面的改为B，最少操作几次可以把S改成T。如果改不成就输出-1。
从左往右一个一个改过去，分类讨论，如果是要把A改成B。
S：A-&gt;B
T：B
那么T中该位置前面一定要有一个A，否则无法修改。
如果要把B改成A。
S：B-&gt;A
T：A
那么T中该位置后面一定要有一个B，否则无法修改。
其中可以本次修改可以更优，即S中后面有一个A，对应T后面的B（一次修改，完成两次对应）
#include &lt;bits/stdc++.h&gt; //#define int long long #define per(i,j,k) for(int (i)=(j);(i)&lt;=(k);++(i)) #define rep(i,j,k) for(int (i)=(j);(i)&gt;=(k);--(i)) #define fr first #define se second #define endl '\n' using namespace std; const int N=2e5+5; int n,ans,a; string s,t; queue&lt;int&gt;q; int b[N]; void solve(){ cin&gt;&gt;n&gt;&gt;s&gt;&gt;t; per(i,0,n-1){ if(t[i]=='B' and s[i]=='A')q.push(i); } rep(i,n-1,0){ if(t[i]=='B')b[i]++; if(i&gt;=1)b[i-1]=b[i]; } per(i,0,n-1){ if(t[i]=='A')a++; if(s[i]!=t[i]){ if(s[i]=='A'){//需要改成B,前面至少有一个A if(!a){ cout&lt;&lt;-1&lt;&lt;endl; return ; } ans++; }else{//需要改成A,后面至少有一个B if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ebbfd5b1985f218d0bef9e2201140c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf13f6f9ec453a253084225f8073943f/" rel="bookmark">
			【数据结构】树套树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（本部分未学完
文章目录 树状数组套主席树P2617 Dynamic Rankings 树状数组套主席树 P2617 Dynamic Rankings 题目链接
#include &lt;bits/stdc++.h&gt; using namespace std; // #define int long long using i64 = long long; using i128 = __int128_t; typedef pair&lt;int, int&gt; PII; const int N = 100010; struct Node { int l, r, size; }tr[40100000]; struct option { int ll, rr, k; }opt[N]; int n, m, idx, root[N], u; map&lt;int, int&gt; uni, reuni; // uni是原值对应离散 reuni是离散后对应原值 vector&lt;int&gt; a(N); // 起初存储原值 后修改为离散后的值 int lowbit(int x) { return x &amp; -x; } int update(int pre, int l, int r, int x, int f) // 在pre的基础上 添加/删去（看f是1还是-1） 值x { int now_ = ++ idx; tr[now_] = tr[pre]; tr[now_].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf13f6f9ec453a253084225f8073943f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7bd716bed2a16ec959350df087b1810/" rel="bookmark">
			（十二）Head first design patterns代理模式（c&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代理模式 代理模式：创建一个proxy对象，并为这个对象提供替身或者占位符以对这个对象进行控制。
典型例子：智能指针...
例子：比如说有一个talk接口，所有的people需要实现talk接口。但有些人有唱歌技能。不能在talk接口中实现sing功能，又不能在所有的people中实现sing功能。于是可以用代理模式去为people增加sing功能。具体的做法就是创建proxy类与people类继承同一个基类talk，将people的指针传入proxy以让proxy对象接管people对象。其实相当于proxy对象对people对象起到了装饰作用。代理模式的结构与装饰器结构类似，但目的与装饰器模式不同。装饰器模式的目的是装饰，代理模式的目的是提供一种代理来控制这个对象的访问。
Subject: 抽象主题角色，真实主题角色和代理角色都继承这个类，这样可以对真实主题角色和代理角色使用统一接口。
真实主题角色：描述了真实主题对象的细节。
代理角色：控制真实主题。
示例代码一 #include &lt;iostream&gt; using namespace std; class Italk{ public: virtual void talk(string msg){} }; class People : public Italk{ public: People(string name, string age):name(name),age(age){} string getName(){} void setName(){} string getAge(){} void setAge(){} void talk(string msg){ std::cout &lt;&lt; "[" &lt;&lt; msg &lt;&lt; "]" &lt;&lt; "hi~, My name is " &lt;&lt; name &lt;&lt; ", I'm " &lt;&lt; age &lt;&lt; "." &lt;&lt; std::endl; } private: string name; string age; }; class TalkProxy : public Italk{ public: Italk* talker; TalkProxy(Italk* talker):talker(talker){} void talk(string msg){ talker-&gt;talk(msg); } void talk(string msg, string song){ talker-&gt;talk(msg); sing(song); } void sing(string song){ std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7bd716bed2a16ec959350df087b1810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3765e950845832efd9077c3f38679b0/" rel="bookmark">
			【数据结构】二叉树算法讲解（定义&#43;算法原理&#43;源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝喜爱+、前后端领域优质创作者、本质互联网精神、坚持优质作品共享、掘金/腾讯云/阿里云等平台优质作者、擅长前后端项目开发和毕业项目实战✌有需要可以联系作者我哦！
🍅附上相关C语言版源码讲解🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
目录
一、二叉树定义（特点+结构）
二叉树算法性质：
二、算法实现（完整代码）
三、算法总结
二叉树的优点：
二叉树的缺点：
二叉树的应用：
小结
大家点赞、收藏、关注、评论啦 ！
谢谢哦！如果不懂，欢迎大家下方讨论学习哦。
一、二叉树定义（特点+结构） 二叉树是一种树形结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树具有以下定义和特点：
1. 节点：二叉树是由节点构成的集合。每个节点包含三个基本信息：
- 数据元素（或称为节点值）。
- 指向左子节点的指针/引用。
- 指向右子节点的指针/引用。
2. 根节点： 二叉树中的一个节点被称为根节点，它是整个树的起始节点。一棵二叉树只有一个根节点。
3. 叶子节点：没有子节点的节点被称为叶子节点（或叶节点）。
4. 父节点和子节点： 每个节点都有一个父节点，除了根节点。父节点指向它的子节点。
5. 深度：一个节点的深度是从根节点到该节点的唯一路径的边的数量。根节点的深度为0。
6. 高度/深度： 一棵二叉树的高度（或深度）是树中任意节点的最大深度。
7. 子树：二叉树中的任意节点和它的所有子孙节点组成的集合被称为子树。
8. 二叉搜索树（BST）：在二叉搜索树中，每个节点的左子树中的节点值都小于该节点的值，而右子树中的节点值都大于该节点的值。
9. 满二叉树：如果一棵深度为k，且有2^k - 1个节点的二叉树被称为满二叉树。
10. 完全二叉树：对于一棵深度为k的二叉树，除了最后一层外，其它各层的节点数都达到最大值，且最后一层的节点都集中在左边，被称为完全二叉树。
二叉树的定义为：
struct TreeNode { int val; // 节点值 TreeNode *left; // 左子节点指针 TreeNode *right; // 右子节点指针 TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 上述定义为C++中使用类实现的二叉树节点定义，包含节点值、左子节点指针和右子节点指针。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3765e950845832efd9077c3f38679b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9a4a2ab4d20817a2964073dd62483f0/" rel="bookmark">
			基于yolov5-master和pyqt5的森林火灾监测软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 项目背景效果演示一、实现思路① 算法原理② 程序流程图 二、系统设计与实现三、模型评估与优化 项目背景 火灾作为威胁人类生命生产安全的隐患之一，一直是人们关注的重点。传统的火灾监测装置根据温度来检测火灾，不仅灵敏度差，而且反馈时间长，常常会出现消防员收到警报消息时，火室已经无法控制。
森林火灾监测系统的设计与实现是一项基于深度学习技术的创新性研究，旨在通过自动检测和分析森林的图像数据，实时监测和预防森林火灾的发生。我们选择了PyTorch作为主要的深度学习框架，并结合了目标检测领域的主流算法YOLOv5来完成这一任务。
本系统的主要目标是提高火灾检测的准确性和实时性。为了实现这一目标，我们进行了深入的模型研究和技术实现。通过采用YOLOv5算法，我们能够在图像中准确地识别和定位火灾目标，从而有效地检测火灾的发生。同时，我们也进行了模型训练和优化，以提高系统的检测精度和性能。
在系统设计方面，我们采用了PyQt5制作了直观易用的UI界面。这一界面为用户提供了简便的操作方式，只需通过上传森林图像，系统便能自动进行火灾检测，并及时将检测结果展示给用户。这一设计使得即使是不具备专业知识的用户也能轻松利用本系统进行火灾监测。
除了实时检测功能外，本系统还具备以下优势：
首先，我们的系统可以自动分析和处理大量的图像数据，大大提高了检测效率。其次，通过不断优化算法和模型参数，我们可以提高检测的准确性和可靠性，降低误报和漏报的风险。此外，本系统还具备良好的可扩展性，可以根据实际需求添加更多功能和应用场景。
本系统的研究和实现具有重要的现实意义。通过实时监测和预防森林火灾，我们可以保护生态环境、减少自然资源的损失，并降低火灾对社会和经济的影响。此外，本系统的成功应用也为深度学习技术在森林防火领域的应用提供了有益的参考和借鉴。
效果演示 第一版软件界面
单张图片预测结果：
视频流监测效果：
第二版软件界面
单张图片预测结果
视频流检测结果：
除此之外还可以进行摄像头检测，这里就不再过多演示。
一、实现思路 ① 算法原理 YOLO(You Only Look Once) 是REDMON等提出的目标检测算法，作为单阶段(one-stage)的代表算法，目前 YOLO已经更新到了YOLOv5。相比于Two stage目标检测算法，YOLO是直接从网络中提取特征，并预测物体的类别和具体位置，一步到位。
此后，REDMON在此基础上提出了YOLO9000等检测算法，使系统的检测性能得到进一步提升。在YOLOv3的基础上继续改进升级，并最终得到 YOLOv4。YOLOv4网络结构主要由CSPDarknet53特征提取网、SPP(空间金字塔池化)模块、PANet特征融合模块、Yolo Head分类器组成。
YOLOv5算法使用CSPDarknet(跨阶段局部网络)作为特征提取网络,从输入图像中提取目标信息。如今，YOLOv5无论是在准确率还是速度上，都已经达到较好的效果。所以，本项目采用YOLOv5训练模型，结合YOLOv5算法构建火灾检测系统。
yolov5s的网络结构，它是yolov5系列中深度最小、特征图宽度最小的网络。后面的m、l、x都是在此基础上不断加深、加宽的。网络主要分为输入端、Backbone、Neck、Prediction四个部分。它和yolov3主要不同的地方：
输入端：Mosaic数据增强、自适应锚框计算、自适应图片缩放Backbone：Focus结构、CSP结构Neck：FPN+PAN结构Prediction：GIOU_Loss YOLOv5 模型在输入端(Input)增加了 Mosaic 数据增强、自适应锚框计算、自适应图片缩放等数据预处理技巧来增强数据，防止过拟合；在特征提取网络部分(Backbone)引入了Focus 模块、跨阶段局部融合网络(CrossStage Partial Network, CSPNet)等方法，在减少了计算量的同时可以保证准确率，使特征能够更好的向后传递。下图为cspnet 结构图：
CSPNet主要目的就是缓解以前需要大量推理计算的问题，它有以下优点：
增强了CNN的学习能力，能够在轻量化的同时保持准确性。降低计算瓶颈。降低内存成本。 CSPNet通过将梯度的变化从头到尾地集成到特征图中，在减少了计算量的同时可以保证准确率。
CSPNet和PRN都是一个思想，将feature map拆成两个部分，一部分进行卷积操作，另一部分和上一部分卷积操作的结果进行concate。在特征融合部分(Neck)借鉴了空间金字塔池化(Spatial Pyramid Pooling, SPP)、特征金字塔(Feature Pyramid Networks, FPN)与路径聚合网络(PathAggregation Network, PAN)等方法，有效的增加主干特征的接收范围，融合后的特征保留了丰富的语义特征和精准的定位特征；同时在预测部分(Prediction)采用了新的定位损失函数，确保定位的精准。通过引入各种高效的网络组件，使得YOLOv5 模型在保持实时目标检测速度的基础上，也实现了精度上SOTA。
Input 使用了 Mosaic 数据增强、自适应锚框计算、图片尺寸处理。Mosaic 数据增强把 4 张图片，采用随机缩放、随机裁剪、随机排布的方式进行拼接 , 极大地丰富了检测数据集，同时也能提高小目标检测的精度，除此以外，Mosaic数据增强在训练时可一次性对 4 张图片的数据进行计算，降低了 mini-batch 的大小，也减少了 GPU 的使用。YOLOv5 将自适应锚框计算嵌入代码中，通过在初始设定的锚框上输出预测框，然后和真实标签进行比对，计算损失函数，再不断更新，更新锚点框的大小，实现自适应计算并得出最佳锚框值。图片尺寸处理是对输入的各种图片的尺寸进行自适应填充处理，为了提高目标检测的速度，采用了减少灰度边缘的方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9a4a2ab4d20817a2964073dd62483f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b061b8dc3f4fb0bb77de2afbddf1d5/" rel="bookmark">
			IDEA（十）2022版本 Services中服务窗口不显示端口号解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、问题描述二、问题分析三、解决方案3.1 设置启动参数【生效】3.2 方法二：设置环境变量【不生效】3.3 方法三：删除缓存【不生效】 四、补充：如何手动控制端口显示 一、问题描述 我们在使用 IDEA 的过程中，会发现在 Services 中的服务窗口 不显示端口 了，如下所示：
这对于我们使用 IDEA 对 Spring Boot 项目进行调试的时候非常不方便，那么应该如何恢复呢？
二、问题分析 知其然，要知其所以然。
首先，我们可以看一下日志旁边的 Actuator 标签是否有报错，如下所示：
Failed to check application ready state: Timeout exceeded
Press Refresh button to reinit state checking
看这个报错提示，是要我们点击右边的刷新按钮，可是点击后经过漫长的等待还是报错。
这个报错是因为 IDEA 和 SpringBoot 项目没有在同一 JVM 环境下运行，使得 IDEA 不能连接到这个 AttachProvider。那么如何才能让 IDEA 和 SpringBoot 项目在同一 JVM 环境下运行呢？解决了这个问题，我们的端口就可以正常显示了。
三、解决方案 下面这三个方法中，亲测只有第一个好用，剩余两个方法作为补充，可以试一试。
3.1 设置启动参数【生效】 我们可以在 IDEA 的启动配置中，为 SpringBoot 项目增加下面4行 VM options 项：（端口不固定，不冲突即可）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b061b8dc3f4fb0bb77de2afbddf1d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b71173b7a97572e8617b137b63443393/" rel="bookmark">
			【数据结构】链表(单链表与双链表实现&#43;原理&#43;源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝喜爱+、前后端领域优质创作者、本质互联网精神、坚持优质作品共享、掘金/腾讯云/阿里云等平台优质作者、擅长前后端项目开发和毕业项目实战✌有需要可以联系作者我哦！
🍅附上相关C语言版源码讲解🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
文章目录 一、链表定义
二、链表实战
1、单链表（C语言实现版本）
2、双链表（C++）
三、分析总结
优点：
应用：
小结
大家点赞、收藏、关注、评论啦 ！
谢谢哦！如果不懂，欢迎大家下方讨论学习哦。
一、链表定义 链表是一种数据结构，它由一系列节点组成，这些节点按顺序连接在一起形成链式结构。每个节点包含数据和指向下一个节点的引用（指针）。链表的最后一个节点通常指向一个特定的值（如空值或null），表示链表的结束。
链表是一种数据结构，它由一系列节点组成，这些节点按顺序连接在一起形成链式结构。每个节点包含数据和指向下一个节点的引用（指针）。链表的最后一个节点通常指向一个特定的值（如空值或null），表示链表的结束。
链表可以分为单链表和双链表两种主要类型：
1. 单链表（Singly Linked List）：每个节点包含数据和指向下一个节点的指针。链表的最后一个节点指向null。
节点1 节点2 节点3 | 数据1 | -&gt; | 数据2 | -&gt; | 数据3 | -&gt; null 2. 双链表（Doubly Linked List）：每个节点包含数据、指向下一个节点的指针，以及指向前一个节点的指针。这使得在双链表中可以更方便地进行前向和后向遍历。
null &lt;- | 数据1 | &lt;-&gt; | 数据2 | &lt;-&gt; | 数据3 | -&gt; null 链表优点： 链表相对于数组的优势在于插入和删除操作的效率较高，因为不需要移动大量元素，只需调整节点的指针。然而，链表的缺点是访问元素时需要按顺序遍历，而数组可以通过索引直接访问元素。链表在内存中不需要连续的存储空间，因此可以更灵活地分配内存。
二、链表实战 1、单链表（C语言实现版本） #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 定义节点结构 struct Node { int data; // 节点数据 struct Node* next; // 指向下一个节点的指针 }; // 定义链表结构 struct LinkedList { struct Node* head; // 链表头指针 }; // 初始化链表 void initLinkedList(struct LinkedList* list) { list-&gt;head = NULL; // 将头指针初始化为NULL，表示链表为空 } // 在链表末尾添加节点 void append(struct LinkedList* list, int data) { // 创建新节点 struct Node* new_node = (struct Node*)malloc(sizeof(struct Node)); new_node-&gt;data = data; new_node-&gt;next = NULL; // 判断链表是否为空 if (list-&gt;head == NULL) { // 如果为空，将新节点设为头节点 list-&gt;head = new_node; } else { // 如果不为空，找到链表末尾，将新节点链接到末尾 struct Node* current = list-&gt;head; while (current-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b71173b7a97572e8617b137b63443393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152a231513a6ece26dead1629168d688/" rel="bookmark">
			install cmake
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://gist.github.com/1duo/38af1abd68a2c7fe5087532ab968574e
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19bb7607b58607ddd081a3911b6a374/" rel="bookmark">
			java中文乱码浅析及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 字符编码基础
2. InputStreamReader 和 OutputStreamWriter
3. 字符串转换
4. 避免默认编码
5. 使用正确的编码
6. Java虚拟机参数
7. 检查数据源
8. 使用第三方库
结语
在Java开发中，中文乱码是一个常见的问题，特别是在涉及字符编码的处理时。中文乱码通常发生在字符在不同的编码方式之间转换时，或者在读写文件、网络传输等操作中。下面是关于Java中文乱码的浅析以及一些解决方案：
1. 字符编码基础 Java中的字符串是使用Unicode编码的，而在文件、网络传输等场景中，会涉及到不同的字符编码，如UTF-8、GBK、ISO-8859-1等。中文乱码通常是因为在这些编码之间进行转换时产生的。
2. InputStreamReader 和 OutputStreamWriter 在处理字节流时，可以使用`InputStreamReader`和`OutputStreamWriter`来进行字符编码的转换。例如，使用`FileInputStream`读取文件时，通过`InputStreamReader`指定正确的字符编码：java
FileInputStream fis = new FileInputStream("文件路径"); InputStreamReader isr = new InputStreamReader(fis, "UTF-8"); BufferedReader br = new BufferedReader(isr); 3. 字符串转换 在进行字符串转换时，要确保正确指定字符编码。例如，使用`getBytes`时需要指定正确的编码：
String str = "中文字符串"; byte[] bytes = str.getBytes("UTF-8"); 4. 避免默认编码 避免使用不带字符编码参数的构造方法或方法，因为它们使用平台默认的字符编码，可能导致不同平台上的结果不一致。
5. 使用正确的编码 确保在文件、数据库、网络传输等场景中使用一致的字符编码，通常推荐使用UTF-8，因为它支持全球范围内的字符。
6. Java虚拟机参数 在启动Java虚拟机时，可以通过设置系统属性`file.encoding`来指定默认字符编码。例如：
bash
java -Dfile.encoding=UTF-8 YourMainClass 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19bb7607b58607ddd081a3911b6a374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33bf473704da32b05b113a919d6cdaa5/" rel="bookmark">
			深入探讨JavaSE：从基础到高级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. JavaSE的基础知识
2. 标准API库
3. 异常处理与调试技巧
4. JavaSE的高级特性
5. JavaSE与新技术的整合
结语
JavaSE（Java Standard Edition）是Java平台的标准版，是Java编程语言的基础。它提供了一系列核心的API和工具，为开发者提供了丰富的功能和灵活性。本博客将深入探讨JavaSE的各个方面，从基础知识到高级特性，为读者提供全面的了解和学习路径。
1. JavaSE的基础知识 JavaSE作为Java编程语言的基础，首先我们需要了解其基础知识。这包括Java的基本语法、数据类型、控制结构等内容。同时，我们将介绍Java的面向对象编程特性，如类和对象、继承、多态等，这些是Java编程的核心概念。
2. 标准API库 JavaSE提供了丰富的标准API库，涵盖了从输入输出到网络通信、数据结构、多线程等方方面面。我们将深入研究这些API的使用方法，介绍一些常用的类和接口，帮助读者更好地利用JavaSE进行开发。
3. 异常处理与调试技巧 在实际开发中，异常处理是不可避免的一部分。本博客将详细介绍JavaSE中的异常处理机制，并提供一些调试技巧，帮助开发者更轻松地定位和解决问题。
4. JavaSE的高级特性 除了基础知识和标准API库外，JavaSE还提供了一些高级特性，如Lambda表达式、流式API、模块化等。我们将深入探讨这些特性的使用方法，帮助读者写出更简洁、高效的Java代码。
5. JavaSE与新技术的整合 随着技术的不断发展，JavaSE也在不断更新迭代。我们将介绍JavaSE与一些新兴技术的整合，如JavaFX、JShell等，帮助读者了解Java在不同领域的应用。
结语 JavaSE作为Java编程的基石，其重要性不可忽视。通过深入学习JavaSE，我们可以更好地掌握Java编程语言，提高开发效率，写出更具可维护性和扩展性的代码。希望通过本博客的分享，读者能够对JavaSE有更深入的了解，并能够在实际项目中灵活应用这些知识。让我们一同探索JavaSE的奥秘，不断提升自己的编程技能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd62aadafc263267f5790964b60e7e3b/" rel="bookmark">
			Intel Arrow Lake处理器还是8&#43;16 24核心：接口换LGA1851
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Intel已经确认， 将在今年内发布未来两代处理器Arrow Lake、Lunar Lake，其中前者将弥补Meteor Lake的不足，同时用于笔记本、桌面、服务器，现在它的核心规格流出了。 这份曝光的材料再次证实，Meteor Lake原本确实规划了桌面版，只是因为性能不达标而取消，Arrow Lake则早就内部排序好了叫做15代酷睿，现在看起来将是二代酷睿Ultra。
早先传闻称，Arrow Lake的小核将翻一倍增加到32个，但现在曝光还是16个，再加上8个大核，仍然是8+16 24核心32线程的配置。
同时还有另外两种芯片，一个是6+16 22核心，另一个6+8 14核心，然后在它们基础上衍生出其他配置，比如8+12、8+8、6+12、6+4等等。
内存首次抛弃DDR4，仅支持DDR5。
PCIe 5.0通道增加4条而达到20条，其中16条给显卡、4条给SSD，还有4条PCIe 4.0也是给SSD。
接口终于更换为LGA1851——Meteor Lake的桌面版原本就计划用它了——应该能延续到后续的Panther Lake。
芯片组配套升级为800系列，支持24条PCIe 4.0，其中8条分给两个SSD。
DisplayPort 2.0 UHBR20也要来了，但只有雷电4，想要雷电5必须外挂独立主控。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0dd1d280e9c9c2d090c50acd2763947/" rel="bookmark">
			Apache Wicket 9.10.0发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Wicket 是一个开源的面向 Java 组件的 Web 应用框架，为政府、商店、大学、城市、银行、电子邮件提供商等成千上万的 Web 应用和网站提供支持。
Wicket 的开发中使用了语义版本，因此与 9.0.0 相比，9.10 版本没有出现 API 中断。
9.10 的更新内容包括：
错误修复 [WICKET-6970] - 在 AssociatedMarkupSourcingStrategy 中不必要的字符串构建[WICKET-6971] - ModificationWatcher 中的 NullPointerException[WICKET-6974] - JavaxUpgradeHttpRequest 返回一个空的 textPath[WICKET-6975] - Behavior.renderHead 可能被多次调用 改进 [WICKET-6963] - 对 PanelMarkupSourcingStrategy 使用单例[WICKET-6967] - 允许发送非阻塞的 Web socket 消息[WICKET-6969] - 允许以异步方式处理 web socket 推送消息[WICKET-6972] - 在 Localizer.java 中添加资源键来记录警告[WICKET-6977] - hashCode 计算产生过多的垃圾对象 更多详情可查看：wicket.apache.org/news/2022/0…
原文链接：Apache Wicket 9.10.0发布 - 掘金 (juejin.cn)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96593d2f3e2e16d002420d5fdbbfefab/" rel="bookmark">
			图的dfs遍历和bfs遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📑前言 本文主要是【图的dfs遍历和bfs遍历】——图遍历的文章，如果有什么需要改进的地方还请大佬指出⛺️
🎬作者简介：大家好，我是听风与他🥇
☁️博客首页：CSDN主页听风与他
🌄每日一句：狠狠沉淀，顶峰相见
目录 📑前言图的dfs遍历和bfs遍历打印结果: 📑文章末尾 图的dfs遍历和bfs遍历 以如下的无向图为例 package 图论; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; public class 图的dfs和bfs实现 { /* 8个顶点，9条边 8 9 0 1 0 2 1 3 1 4 1 5 3 4 2 6 2 7 6 7 */ static int n=0,m=0;//n个顶点,m条边 static int[][] g;//用来做邻接矩阵 static int[] visit;//用来记录哪些边已经被访问了 static int vcount=0;//记录已经访问过多少个结点 public static void main(String[] args) { // TODO Auto-generated method stub Scanner sc = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96593d2f3e2e16d002420d5fdbbfefab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147c129aec1567f4c8dbaa839d2046c4/" rel="bookmark">
			Toyota Programming Contest 2023#8（AtCoder Beginner Contest 333）（A~E）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A - Three Threes 题目大意：给你一个整数n，将这个数n输出n次。
呃呃
B - Pentagon 题目大意：给你一个正五边形ABCDE，给你任意两条边，判断是否相等
主要问题要判断一下内边：AD，AC，EB，EC，DB之间的关系，因为内边的夹角都相等，边也都相等（正五边形），所以内边都相等。要证明也可以画辅助线来证明，但是这显而易见，就不证明了。
#include &lt;bits/stdc++.h&gt; //#define int long long #define per(i,j,k) for(int (i)=(j);(i)&lt;=(k);++(i)) #define rep(i,j,k) for(int (i)=(j);(i)&gt;=(k);--(i)) #define fr first #define se second #define endl '\n' using namespace std; string s1,s2; void yes(){ cout&lt;&lt;"Yes"&lt;&lt;endl; } void no(){ cout&lt;&lt;"No"&lt;&lt;endl; } void solve(){ cin&gt;&gt;s1&gt;&gt;s2; if(s1[1]&lt;s1[0])swap(s1[0],s1[1]);//线段表示模式改成前面小端点后面大端点 if(s2[1]&lt;s2[0])swap(s2[0],s2[1]);//可以少判断一半 if(s1=="AB" or s1=="BC" or s1=="CD" or s1=="DE" or s1=="AE"){//任意外边相等 if(s2=="AB" or s2=="BC" or s2=="CD" or s2=="DE" or s2=="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/147c129aec1567f4c8dbaa839d2046c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d6fe958ecf6328f3c17d760be898c74/" rel="bookmark">
			iOS长图生成的pdf性能优化记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 某日产品拿来了一个由30多页高清长图生成的pdf，在应用中运行出现了崩溃。
排查 经过调试发现加载长图生成的pdf时，运行内存会出现缓慢增长，直至崩溃。经过代码定位发现时pdf转成image对象的过程中由于是长图生成的pdf，这一页的pdf的size相当于正常pdfsize的30多页，转换的过程中context的fill的size也是正常pdf的30多倍。经过调研，尝试，发现对于同一页的pdf，可以通过调整context的fill的size来只把pdf中的部分内容转换成image对象，内存正常也不大。
方案 原来的方案是每页pdf生成一个image对象，通过一个collectonViewCell来显示。调整后的方案为：根据屏幕大小来决定一个pdf页面生成多少个image对象，有多少个image对象，一个section里就有多少个cell。方案如下：
func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize { if pdfSize.height/pdfSize.width &gt;= 3.0 { //长图生成的pdf 备注：pdfSize 即一页pdf的大小 let visible_width = pdfSize.width let visible_height = visible_width * Board_height/Board_width let visibleSize = CGSize(width: visible_width, height: visible_height) let count:Int = Int(ceil(pdfSize.height/visible_height))// 计算需要分割的次数 let index:Int let itemSize:CGSize if indexPath.item &lt; count { index = indexPath.item } else { index = count - 1 } if CGFloat(index) * visibleSize.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d6fe958ecf6328f3c17d760be898c74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1633d07caf96a48b6a9c166664224d46/" rel="bookmark">
			element plus 下拉菜单el-dropdown 白色边框问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;div class="flex-item flex-all-center"&gt; &lt;el-dropdown trigger="hover" style="border: 0"&gt; &lt;template #dropdown&gt; &lt;el-dropdown-menu class="dropdown-menu-box"&gt; &lt;el-dropdown-item icon="Plus"&gt;选项 1&lt;/el-dropdown-item&gt; &lt;el-dropdown-item divided&gt;选项 2&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;选项 3&lt;/el-dropdown-item&gt; &lt;!-- 更多下拉选项 --&gt; &lt;/el-dropdown-menu&gt; &lt;/template&gt; &lt;/el-dropdown&gt; &lt;/div&gt; 点击 el-dropdown 时出现一个不期望的白色边框，这通常是因为浏览器默认的焦点样式（outline）导致的。当您点击页面上的元素时，浏览器可能会自动给这个元素添加一个焦点轮廓（outline），这在某些情况下可能会显得不美观。您可以通过 CSS 来去除或自定义这个焦点样式。
解决方案：
.el-dropdown, .el-dropdown * {outline: none;} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86618a3f967744afac59524b42b113b0/" rel="bookmark">
			C&#43;&#43;&amp;Python&amp;C# 三语言OpenCV从零开发(5):ROI截取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言ROI测试图片部分区域截取C++CsharpPython 颜色区域分割C++CsharpPython 颜色通道合并C++CsharpPython 总结 前言 C++&amp;Python&amp;Csharp in OpenCV 专栏
【2022B站最好的OpenCV课程推荐】OpenCV从入门到实战 全套课程（附带课程课件资料+课件笔记）
ROI ROI，本意是感兴趣区域。但是使用起来就和PS的截取部分区域差不多。
我之前写过一篇Python 的代码
Python+OpenCV 零基础学习笔记(6):ROI
其它的相关文章
OpenCV之感兴趣区域ROI（C++实现）
测试图片 部分区域截取 C++ #include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/imgproc.hpp&gt; #include&lt;iostream&gt; using namespace std; using namespace cv; int main() { Mat image = imread("D:/workspace/program/OpenCV/c--csharp--python--open-cv/Resources/cat.png"); //截取图片，Range是范围，第一个是高度范围，第二个是宽度范围 Mat roi = image(Range(0,50),Range(0,200)); imshow("C++", roi); waitKey(0); destroyAllWindows(); return 0; } Csharp using OpenCvSharp; namespace _1_HelloOpenCV { internal class Program { static void Main(string[] args) { Mat image = Cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86618a3f967744afac59524b42b113b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911ec2ad88106e0a872f2e94b579a701/" rel="bookmark">
			GPT帮我快速解决工作上的问题案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python入门容易，但精通不易。自从跟着郭老师学Python后，工作中也想偷点懒，之前排班表的问题一直困扰着我，福音来了，现在随着郭老师的小蜜蜂AI出来，说干就干。马上来到郭老师为我们提供的AI网站：http://zglg.work/index.html，选择AI智能问答，输入我想问的问题：
用python帮我写一个排班表，其中人数不定，有三种班期，按月份来输出。 好的，我可以帮你生成一个按日期排列的一个月排班表。请注意，下面的代码示例假设每个月都是30天，并且使用了三种班期轮班。 import datetime def generate_monthly_schedule(employees, month, start_day): schedules = [] shifts = ['班期1', '班期2', '班期3'] # 三种班期 days_in_month = 30 # 假设每个月都是30天 for i, employee in enumerate(employees): schedule = {'姓名': employee} current_date = start_day for day in range(days_in_month): shift = shifts[day % len(shifts)] schedule[current_date.strftime('%Y-%m-%d')] = shift current_date += datetime.timedelta(days=1) schedules.append(schedule) return schedules # 示例使用 employee_list = ['张三', '李四', '王五'] # 员工名单 month = 9 # 月份 start_day = datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911ec2ad88106e0a872f2e94b579a701/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b964b4a45150531a5176a4a736afa68/" rel="bookmark">
			2024.1.20力扣每日一题——按分隔符拆分字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.1.20 题目来源我的题解方法一 API工程师(String.split+Stream)方法二 模拟 题目来源 力扣每日一题；题序：2788
我的题解 方法一 API工程师(String.split+Stream) 直接调用相关API
时间复杂度：O(n)。没有考虑API内部时间
空间复杂度：O(1)。没考虑API内部细节
public List&lt;String&gt; splitWordsBySeparator(List&lt;String&gt; words, char separator) { List&lt;String&gt; res=new ArrayList&lt;&gt;(); for(String s :words){ res.addAll(Arrays.stream(s.split("\\"+separator)) .filter(c-&gt;!c.isEmpty()) .collect(Collectors.toList())); } return res; } 方法二 模拟 模拟分割
时间复杂度：O(nm)。n是中的字符串数，m是最长字符串的长度
空间复杂度：O(m)。在分割函数中存储结果的list大小
public List&lt;String&gt; splitWordsBySeparator(List&lt;String&gt; words, char separator) { List&lt;String&gt; res=new ArrayList&lt;&gt;(); for(String s :words){ res.addAll(split(s,separator)); } return res; } public List&lt;String&gt; split(String s,char separator){ int n=s.length(); int left=0,right=0; List&lt;String&gt; res=new ArrayList&lt;&gt;(); while(right&lt;n){ while(right&lt;n&amp;&amp;s.charAt(right)!=separator){ right++; } String t=s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b964b4a45150531a5176a4a736afa68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1093206550508ab7a902f61534016a1f/" rel="bookmark">
			web架构师编辑器内容-完成属性设置的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于业务组件来说，其属性是有很多的，如果把所有属性都平铺在页面上，就会非常长，而且想要更改其中的某些属性，可能需要向下滚动很久才能找到，对于UI的交互不是很友好，需要对属性的不同特性进行分组。
改造前：
改造后：
先来看一下通用属性：
// defaultProps.ts export interface CommonComponentProps { // actions actionType: string; url: string; // size height: string; width: string; paddingLeft: string; paddingRight: string; paddingTop: string; paddingBottom: string; // border type borderStyle: string; borderColor: string; borderWidth: string; borderRadius: string; // shadow and opacity boxShadow: string; opacity: string; // position and x,y position: string; left: string; top: string; right: string; } CommonComponentProps一开始就是按照不同的属性进行分类的，所以比较符合我们的一个需求。
首先，组件总属性分两大类：业务组件(独特属性)，通用属性(CommonComponentProps)
// 文本组件 export interface TextComponentProps extends CommonComponentProps { text: string; fontSize: string; fontFamily: string; fontWeight: string; fontStyle: string; textDecoration: string; lineHeight: string; textAlign: string; color: string; backgroundColor: string; } // 图片组件 export interface ImageComponentProps extends CommonComponentProps { src: string; } 将组件通用属性分类分多个小类： size，border type，shadow…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1093206550508ab7a902f61534016a1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b5ac4a8b76aca72e1c32a6b3f635cb/" rel="bookmark">
			《GreenPlum系列》GreenPlum初级教程-05GreenPlum语言DDL&amp;DML&amp;DQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第五章 DDL&amp;DML&amp;DQL1.DDL(Data Definition Language)数据定义语言1.1 创建数据库1.2 查询数据库1.3 删除数据库1.4 创建表1.5 修改表1.6 清除表1.7 删除表 2.DML(Data Manipulation Language)数据操作语言2.1 数据导入2.2 数据更新和删除2.3 数据导出 3.DQL(Data Query Language)数据查询语言3.1 基础语法及执行顺序3.2 基本查询3.3 分组查询3.4 联合查询3.5 排序 第五章 DDL&amp;DML&amp;DQL 1.DDL(Data Definition Language)数据定义语言 1.1 创建数据库 1）语法
CREATE DATABASE name [ [WITH] [OWNER [=] dbowner] [TEMPLATE [=] template] [ENCODING [=] encoding] [TABLESPAC [=] tablespace] [CONNECTIONE LIMIT [=] connlimit ] ] CREATE DATABASE name;
CREATE DATABASE是SQL命令，用于创建一个新的数据库。
name是自定义的数据库名称。这个名称是必须要填写的，而且在当前数据库服务器上必须是唯一的。
[WITH] [OWNER [=] dbowner]
这是一个可选项。OWNER指定了新数据库的所有者。如果未指定，新数据库的所有者默认是执行该命令的用户。
dbowner是数据库所有者的用户名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2b5ac4a8b76aca72e1c32a6b3f635cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d9398f7eb053508288f0a09ccda591a/" rel="bookmark">
			基于SpringBoot&#43;vue的在线视频教育平台的设计与实现，附源码，数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌程序员徐师兄、7年大厂程序员经历。全网粉丝30W+、csdn博客专家、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及文档编写等相关问题都可以给我留言咨询，希望帮助更多的人
一 简介 基于SpringBoot的在线视频教育平台的设计与实现，是一个大学生实战项目，基于 SpringBoot 和 Vue 开发的，该系统功能完善，可以当作毕业设计适用。
本系统采用的数据库是Mysql，使用SpringBoot框架开发，运行环境使用Tomcat服务器，ECLIPSE
是本系统的开发平台。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
功能如下
1.用户管理：注册、登录、退出、修改密码；
2类显示：显示课程的分类；
3.课程显示：按分类查询课程、按教师查询课程、通过关键字搜索课程、查看课程的详细信息；
4.购物车管理：向购物车中添加课程、删除购物车中课程、我的购物车；
5.订单管理：通过购物车中生成订单、查看我的订单、查看某个订单的详细、订单支付、取消未付款订单。
6.首页：提供一个网站首页，该网站用户的登录，注册，所有课程的一级分类，热门课程和最新课程的展示等。
7.课程管理：课程的审批、上架、下架。
8.教师管理：课程的上传、下架。
二、主要使用技术 环境需要 1.运行环境：最好是java jdk 1.8，这是目前最稳定的JDK也是被使用最多的JDK版本。
2.IDE环境：IDEA，Eclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat7/Tomcat8/Tomcat9版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.数据库：MySql 5.7版本；
6.是否Maven项目：是；
技术栈 后端：Spring+SpringMVC+Mybatis+Springboot
前端：vue+CSS+JavaScript+jQuery+elementui
使用说明 使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；
使用IDEA/Eclipse/MyEclipse导入项目，修改配置，运行项目；
将项目中applicationContext.xml配置文件中的数据库配置改为自己的配置，然后运行；
运行成功后，在浏览器中输入：http://localhost:8080/项目名
四、研究内容 系统管理也都将通过计算机进行整体智能化操作，对于在线视频教育平台所牵扯的管理及数据保存都是非常多的，
例如管理员；首页、个人中心、用户管理、教师管理、课程信息管理、课程类型管理、我的收藏管理、系统管理、订单管理，
用户；首页、个人中心、课程信息管理、我的收藏管理、订单管理、教师；首页、个人中心、课程信息管理、我的收藏管理，前台首页；首页、课程信息、个人中心、后台管理、购物车等功能
后台界面 ​
4 推荐阅读 Java基于SpringBoot+Vue的网上图书商城管理系统（附源码，教程）
基于 Python 的豆瓣电影分析、可视化系统，附源码
Java 基于SpringBoot的某家乡美食系统
Java基于SpringBoot的学生就业管理信息系统
5 源码获取： 大家点赞、收藏、关注、评论啦 、查看👇🏻获取联系方式👇🏻
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d9398f7eb053508288f0a09ccda591a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/220dec8f4d247e5202fd7a20a5c171b1/" rel="bookmark">
			C(C&#43;&#43;)和Python实现STM32F4实时操作系统(FreeRTOS)吸尘器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arm Cortex M 微控制器 STM32F4 通过 FreeRTOS 和 Mbed OS 实现的实时操作系统，使用了 C 语言（微控制器的“编程”语言）、C++语言和 MicroPython（允许在微控制器上使用 Python 语言）数字控制吸尘器。
STM32F4微控制器 STM32F4微控制器不能单独使用，除非为其构建专用开发或特定板。 作为早期学习者，我们的最佳选择是使用可用的 32F429IDISCOVERY 套件来实现此目的。 为了简单起见，我们从现在开始将这块板称为STM32F4。
STM32F4 C++编程示例 GPIO输出闪烁
#include &lt;cstdint&gt; #include &lt;STM32F4x1/Gpio.hpp&gt; #include &lt;STM32F4x1/Clock.hpp&gt; int main() { using namespace Stm32; deviceInit(); Gpio&lt;Port::C, 13&gt; ledPin; ledPin.setMode(GpioMode::Output); while(true) { ledPin.setLevel(true); for(uint32_t i = 0; i &lt; 1000000; ++i); //&lt; some delay ledPin.setLevel(false); for(uint32_t i = 0; i &lt; 1000000; ++i); //&lt; some delay } return 0; } FreeRTOS实时系统配置和主程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/220dec8f4d247e5202fd7a20a5c171b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa04c346de0e6ef94113ccb3b888bce/" rel="bookmark">
			linux 的nobody是什么用户？ 对安全有没有影响？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
一、前言：nobody是不是可疑用户？
二、Linux系统中的nobody用户？
二、有nobody用户存在，安全吗？
一、前言：nobody是不是可疑用户？ 在前面一篇文章“Linux安全问题,如何查看哪个用户是可疑用户？如何批量删除这些用户？（ http://t.csdnimg.cn/e3zKy）”中，有一段描述：
第三个参数:1000以上的,就是后面建的用户了，也就是普通用户；其它则为系统的用户.可以使用如下命令:
awk -F: '$3&gt;1000{print $1,$3}' /etc/passwd
实际操作效果如下：
[yunwei@ecs-52a1 ~]$ awk -F: '$3&gt;1000{print $1,$3}' /etc/passwd
nobody 65534
clamav 1001
vidisit 1002
yunwei 1003
这里有一个nobody 65534，文章中没有详细解释。所以有的伙伴就问了，这个nobody是不是可疑用户啊，你的机器是不是被人入侵了？
首先感谢伙伴们的关心和支持，其实我们机器一切正常。这里nobody其实是一个特殊的用户，它是系统里面的，不是可疑用户。下面，我们就详细解释一下nobody。
二、Linux系统中的nobody用户？ 在Linux系统中，“nobody”是一个特殊的用户名，通常用于运行那些不需要（也不应该）具有系统级权限的服务或进程。它是一个非特权用户，这意味着它没有任何特殊的系统权限。其UID（用户标识符）和GID（组标识符）也不提供任何特权，通常只能访问人人皆可读写的文件。在passwd文件中，nobody的那一行表述如下： nobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin nobody是一个特殊用户，UID 和 GID都是65534，它的shell设置为/usr/sbin/nologin，表示这个用户不能登录系统。
由此可以看出，nobody的特点有：
1、权限很低，用户ID和组ID都是65534，接近最低权限，也就是任何人都可以用这个账号访问某个服务，但是其 UID 和 GID 不提供任何特权，该uid和gid只能访问人人皆可读写的文件。
2、用户描述是Kernel Overflow，表示该用户是一个低权限账户，用于运行可能存在风险的服务或进程。
3、是nologin，也就是它是不允许登录系统的。
Linux的 一些服务进程如apache，aquid，nginx等都采用一些特殊的帐号来运行，比如nobody, news, games等等，这是就可以防止程序本身有安全问题的时候，不会被黑客获得root权限。
二、有nobody用户存在，安全吗？ “nobody”用户的设计初衷其实为了增强系统的安全性。通过使用这个用户来运行服务或进程，可以实现权限最小化，防止潜在的攻击者利用漏洞获得过多的系统权限。即使攻击者成功地利用了某个以“nobody”用户身份运行的服务的漏洞，他们也只能获得非常有限的访问权限，无法对系统造成严重的破坏。
“nobody”用户还用于隔离风险。通过将不同的服务或进程以不同的用户身份运行，可以实现风险的隔离，确保一个服务的安全漏洞不会影响到其他服务。
使用“nobody”用户运行服务或进程有以下几个安全相关的特点：
权限最小化：由于“nobody”用户没有任何特权，因此，任何以该用户身份运行的进程都无法访问或修改系统的重要文件或资源。这有助于减少潜在的安全风险，因为即使攻击者成功地利用了某个以“nobody”用户身份运行的服务的漏洞，他们也只能获得非常有限的访问权限。防止特权提升：在Linux系统中，如果一个进程具有过多的权限，那么攻击者可能会利用该进程的漏洞来提升自己的权限，从而完全控制整个系统。但是，如果进程以“nobody”用户身份运行，那么攻击者就无法利用该进程的漏洞来提升权限，因为他们已经处于最低权限级别。隔离风险：通过将不同的服务或进程以不同的用户身份运行，可以实现风险隔离。即使一个以“nobody”用户身份运行的服务被攻击，攻击者也无法利用该漏洞来访问或控制其他以不同用户身份运行的服务。 总之，“nobody”是Linux系统中的一个特殊用户名，用于增强系统的安全性和隔离风险， 是Linux系统中的一个重要安全机制，它有助于减少系统的安全风险并提高系统的整体安全性。
因此，nobody用户的存在，对linux不断没有风险，而且由于有了nobody的这种机制，对系统是安全的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0f12567583f270184a1598b67599b1/" rel="bookmark">
			C#学习(九)——数据库与WPF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建WPF项目链接数据库 首先创建WPF项目，在nuget安装包中下载System.Data.SqlClient
配置数据库的连接字符串来连接数据库
创建示例数据库，拥有两个table：
CREATE TABLE [dbo].[Customers] ( [Id] INT IDENTITY (1, 1) NOT NULL, [Name] NCHAR (50) NOT NULL, [IdNumber] NCHAR (18) NOT NULL, [Address] NCHAR (100) NOT NULL, PRIMARY KEY CLUSTERED ([Id] ASC) ); CREATE TABLE [dbo].Appointments ( [Id] INT NOT NULL PRIMARY KEY IDENTITY, [Time] DATETIME NOT NULL, [CustomerId] INT NOT NULL, CONSTRAINT [FK_Appointments_Customers] FOREIGN KEY (CustomerId) REFERENCES Customers(Id) ) 实现UI界面对于数据库数据的显示
MainWindow.xaml.cs
public partial class MainWindow : Window { private SqlConnection _sqlConnection; public MainWindow() { InitializeComponent(); string connectionString = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a0f12567583f270184a1598b67599b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32344eedec646c32353c5d03e0e84200/" rel="bookmark">
			install google benckmark in Centos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://installati.one/install-google-benchmark-centos-7/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ade825729c76d24cb60d6d08bef208b/" rel="bookmark">
			批量修改拓展名的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建一个文本文档
输入ren *（.你需要更改的拓展名）*.(更改后的拓展名)
注意：*前面要有空格， txt前面有一个 ". "如上图所示
注意：这个文件建在你需要更改拓展名的文件夹，此文件夹中的所有的txt文件都会替换成你所需要修改的拓展名
最后把此文件的拓展名更改成bat，运行，就大功告成了
**看到这里**如果有效的话给个赞呗，创作不易ヾ(≧▽≦*)oヾ(≧▽≦*)o
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/10/">«</a>
	<span class="pagination__item pagination__item--current">11/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/12/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>