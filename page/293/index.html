<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49501de1f5544d917d9e0b9e9581c8c8/" rel="bookmark">
			rdkafka接口说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、主要数据结构 1、typedef struct rd_kafka_conf_s rd_kafka_conf_t;
rd_kafka_conf_t是kafka的全局配置结构，通过rd_kafka_conf_new()创建，创建时即进行了默认配置，通过rd_kafka_conf_set()设置参数值，是rd_kafka_new()创建kafka处理句柄的第二个参数，是必须创建的结构。
2、typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;
rd_kafka_topic_conf_t主题配置结构，通过rd_kafka_topic_conf_new()创建，创建时即进行了默认配置，通过rd_kafka_topic_conf_set()设置参数值，是必须创建的结构。
3、typedef struct rd_kafka_s rd_kafka_t;
rd_kafka_t 是kafka 处理句柄结构，分为producer类型和consumer类型，由rd_kafka_new()第一个参数类型决定。rd_kafka_t是一个总体结构，conf和topic_conf都是为此结构服务，其中包含rk_brokers链表，rk_topics链表，是必须创建的结构。
4、typedef struct rd_kafka_topic_partition_list_s rd_kafka_topic_partition_list_t；
rd_kafka_topic_partition_list_t 可扩展长度的 主题-分区 链表，通过rd_kafka_topic_partition_list_new()创建，创建时指定长度，通过rd_kafka_topic_partition_list_add()添加 主题-分区对，用于订阅消息。
二、主要接口 1、rd_kafka_conf_t *rd_kafka_conf_new (void) 参数：无
返回值：rd_kafka_conf_t *
创建一个kafka全局配置结构，并进行默认初始化设置，返回其引用指针。
2、rd_kafka_conf_res_t rd_kafka_conf_set (rd_kafka_conf_t *conf,
const char *name,
const char *value,
char *errstr, size_t errstr_size)
参数：
conf：配置结构
vame：配置项名称
value：配置项值
errstr：错误提示
errstr_size：错误提示长度
返回值：rd_kafka_conf_res_t 枚举，错误写入errstr中
name具体的名称及作用见rd_kafka_properties 中_RK_GLOBAL类型的数据定义。调用这个函数后再调用rd_kafka_conf_set_default_topic_conf()会将之前设置的值全部用默认值覆盖掉。因为错误提示会写入errstr中，所以提前给errstr分配512字节空间。
bootstrap.servers
3、rd_kafka_topic_conf_t *rd_kafka_topic_conf_new (void)
参数：无
返回值：rd_kafka_topic_conf_t *
创建一个主题配置结构，并进行默认初始化设置，返回其引用指针。
4、rd_kafka_conf_res_t rd_kafka_topic_conf_set (rd_kafka_topic_conf_t *conf,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49501de1f5544d917d9e0b9e9581c8c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4685c6598a116f8ec9a6b54a6b2c6e/" rel="bookmark">
			android 如何获取LinearLayout的宽度和高度？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于Android程序的运行机制决定了无法再组件类外部使用getWidth和getHeight方法获得高度和宽度(在自定义组件类中可以实现)，必须使用View.getMeasuredWidth和View.getMeasureHeight方法获得当前组件的宽度和高度，在调用这两个方法之前，必须调用View.measure方法先测量组件宽度和高度。 如果想直接获取在布局文件中定义的组件的宽度和高度，可以直接使用View.getLayoutParams().width和View.getLayoutParams().height
代码如下：
[java] view plain copy View view = getLayoutInflater().inflate(R.layout.activity_main, null); LinearLayout linearlayout = (LinearLayout)view.findViewById(R.id.linearlayout); //measure方法的参数值都设为0即可 linearlayout.measure(0,0); //获取组件宽度 int width = linearlayout.getMeasuredWidth(); //获取组件高度 int height = linearlayout.getMeasuredHeight(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b163d67495a0b79c2e4428468416cd0c/" rel="bookmark">
			java算法总结之二分查找法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前提:要实现二分查找法的前提是有序的顺序存储结构. 思想:二分查找法的实现思想是:将有序的集合分成三部分,前半部分，中间点,后半部分,首先用要查找的数据与中间点索引处的数据做比较，如果比中间点索引处的数据小，就从前半部分查找，在前半部分得到新的中间点比较…以此类推，直到找到为止。如果比中间点索引处的数据大，就从后半部分查找。 实现方式分为迭代和循环两种方法。
迭代实现
private void binarySerach(int[] array, int leftIndex,int rightIndex, int searchNum){ if(leftIndex&lt;rightIndex){ system.out.println("not find"+searchNum); return; } int middleIndex=Math.round((leftIndex+rightIndex)/2); if(searchNum&lt;array[middleIndex]){ binarySearch(array,leftIndex,middleIndex-1,seachNum); }else if(searchNum&gt;array[middleIndex]){ binarySearch(array,middleIndex+1,rightIndex,seachNum); }else{ system.out.println("find data"+middleIndex); } } 循环实现
private void binarySearch(int[] array, int searchNum){ int low=0; int high=array.length-1; while(low&lt;=high){ int middle=Math.round((low+high)/2); if(searchNum&lt;array[middle]{ high=middle-1; }else if(searchNum&gt;array[middle]){ low=middle+1; }else{ system.out.printlin("find data"+middle); } } } 调用
private void test(){ int[] array={11,23,9,3,34,67}; Arrays.sort(array);//调用排序 binarySearch(array,0,array.length-1,23); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3cefcc4bf965e547f8409661422514/" rel="bookmark">
			用php获取header头信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究一晚上php关于自定义header头信息的问题。看了很多代码，但是由于本人才疏学浅。连测试demo都没跑通。实在是惭愧。这里看到个获取header信息的方法，挺不错的，记录一下。
我们可以在$_SERVER中获取header数据，自定义的数据都是使用HTTP_作为前缀的，所以可以把HTTP_前缀的数据读出。
public function get_all_header() { // 忽略获取的header数据。这个函数后面会用到。主要是起过滤作用 $ignore = array('host','accept','content-length','content-type'); $headers = array(); //这里大家有兴趣的话，可以打印一下。会出来很多的header头信息。咱们想要的部分，都是‘http_'开头的。所以下面会进行过滤输出。 /* var_dump($_SERVER); exit;*/ foreach($_SERVER as $key=&gt;$value){ if(substr($key, 0, 5)==='HTTP_'){ //这里取到的都是'http_'开头的数据。 //前去开头的前5位 $key = substr($key, 5); //把$key中的'_'下划线都替换为空字符串 $key = str_replace('_', ' ', $key); //再把$key中的空字符串替换成‘-’ $key = str_replace(' ', '-', $key); //把$key中的所有字符转换为小写 $key = strtolower($key); //这里主要是过滤上面写的$ignore数组中的数据 if(!in_array($key, $ignore)){ $headers[$key] = $value; } } } //输出获取到的header return $headers; } 越学习越发现自己到底有多菜。加油。各位圣诞节快乐！
参考链接：http://blog.csdn.net/fdipzone/article/details/49518535
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c8a6f28f755994dcdd74b932f131ac/" rel="bookmark">
			AES加密解密详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一）什么是AES？
高级加密标准（英语：Advanced Encryption Standard，缩写：AES），是一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。
那么为什么原来的DES会被取代呢，，原因就在于其使用56位密钥，比较容易被破解。而AES可以使用128、192、和256位密钥，并且用128位分组加密和解密数据，相对来说安全很多。完善的加密算法在理论上是无法破解的，除非使用穷尽法。使用穷尽法破解密钥长度在128位以上的加密数据是不现实的，仅存在理论上的可能性。统计显示，即使使用目前世界上运算速度最快的计算机，穷尽128位密钥也要花上几十亿年的时间，更不用说去破解采用256位密钥长度的AES算法了。
目前世界上还有组织在研究如何攻破AES这堵坚厚的墙，但是因为破解时间太长，AES得到保障，但是所用的时间不断缩小。随着计算机计算速度的增快，新算法的出现，AES遭到的攻击只会越来越猛烈，不会停止的。
AES现在广泛用于金融财务、在线交易、无线通信、数字存储等领域，经受了最严格的考验，但说不定哪天就会步DES的后尘。
二）JAES加密
先来一段加密代码，说明请看注释：
/** * AES加密字符串 * * @param content * 需要被加密的字符串 * @param password * 加密需要的密码 * @return 密文 */ public static byte[] encrypt(String content, String password) { try { KeyGenerator kgen = KeyGenerator.getInstance("AES");// 创建AES的Key生产者 kgen.init(128, new SecureRandom(password.getBytes()));// 利用用户密码作为随机数初始化出 // 128位的key生产者 //加密没关系，SecureRandom是生成安全随机数序列，password.getBytes()是种子，只要种子相同，序列就一样，所以解密只要有password就行 SecretKey secretKey = kgen.generateKey();// 根据用户密码，生成一个密钥 byte[] enCodeFormat = secretKey.getEncoded();// 返回基本编码格式的密钥，如果此密钥不支持编码，则返回 // null。 SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES");// 转换为AES专用密钥 Cipher cipher = Cipher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33c8a6f28f755994dcdd74b932f131ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f5c3974c0b5393265e9631e2ab8080/" rel="bookmark">
			将服务端的一个JSON格式的字符串输出给客户端js，客户端接收到的字符串里双引号被转义成“ &amp;quot;”的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将服务端的一个JSON格式的字符串输出给客户端js，客户端接收到的字符串里双引号被转义成“ &amp;quot;”了，导致将json字符串转换成json对象的时候报错。
如服务器端的字符串原为'{"姓名":"张三","性别":"男"}'
当用js接收时变成了var str = "{&amp;quot;姓名&amp;quot;:&amp;quot;张三&amp;quot;,&amp;quot;性别&amp;quot;:&amp;quot;男&amp;quot;}"。
解决方案为在js中用正则表达式替换&amp;quot;
str.replace(/&amp;quot;/g,"\"");
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e12a2e8450a8c64a20d2b2500c047c/" rel="bookmark">
			战士的一步一刺杀技术怎么练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 玩传奇游戏的玩家们非常喜欢战士，因为战士属于可以直接杀进禁区里面的一个职业，从而在玩的时候，就可以从这样的玩法里面更好的达到不错的效果，而玩家们如何能够更好地去玩，这才是非常关键性的部分，所以玩家们需要结合现在这种类型去考虑，从而正确的使用战士的刺杀技术，这样在游戏里面就可以打出来不错的进攻了，并且在卡位或者是引怪的时候，需要玩家们注意一步一刺杀的技术，使用了这样的技术之后，通过就不是那么困难了。 战士一步一刺杀技术 不过玩家们需要注意的是一步一刺杀的攻击方法的练习，因为玩家们只有真正的能够掌握了这种练习的方式之后，后续在玩的时候确实可以很好的达到一种不错的效果，但是一步一刺杀的技术在使用的时候，实际上并不是那么简单，需要玩家们能够适当的去使用这样的方式。 而目前玩家们在玩的时候，一步一刺杀的技术需要能够和走位结合起来，这样才能在游戏里面真正的打出来所具有的整体攻击性能力，从而在玩的时候，确实可以带来的实力是不一样的，这就是玩家们可以去玩的一个非常关键性的做法，同时具有的整体实力也就会完全不同。 走位的时候不要使用直线的走位方式，因为直线的走位方式是很容易直接在走位的时候就出现了卡住自己的情况，那么在游戏里面玩的时候，就很容易因为这样的走位而死在里面了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f814e858c6c366aaa1b3c6406ffb01/" rel="bookmark">
			C# MD5-16位加密实例,32位加密实例(两种方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MD5　16位加密实例 using System; using System.Collections.Generic; using System.Text; using System.Security.Cryptography; namespace md5 { class Program { static void Main(string[] args) { Console.WriteLine(UserMd5("8")); Console.WriteLine(GetMd5Str("8")); } /// &lt;summary&gt; /// MD5 16位加密 加密后密码为大写 /// &lt;/summary&gt; /// &lt;param name="ConvertString"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetMd5Str(string ConvertString) { MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); string t2 = BitConverter.ToString(md5.ComputeHash(UTF8Encoding.Default.GetBytes(ConvertString)),4, 8); t2 = t2.Replace("-", ""); return t2; } /// &lt;summary&gt; /// MD5 16位加密 加密后密码为小写 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f814e858c6c366aaa1b3c6406ffb01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6849efa985179fb60a956948c5b5abb0/" rel="bookmark">
			关于在jdk在找不到BASE64Encoder和BASE64Decoder解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现一个很奇怪的现在，BASE64Encoder明明就是jdk中的类，为什么我的jdk就是找不到该类呢，其解决方法如下：
选择访问规则
点击编辑
条件规则,选择允许
点击OK即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f747e72e2856700a4d7792c59e5cc06/" rel="bookmark">
			vue-自定义组件传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 项目中，我们经常会遇到自定义组件传值的问题，方法很多种，但是原理很简单，下述文档总结实际项目中使用的传值方式。
父组件传递给子组件某一值，子组件内会修改该值，然后父组件需要获取新值
​ 在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop给子组件下发数据，子组件通过事件给父组件发送消息。
常规prop-event 父组件
&lt;prop-event-value :address="address" @update="val =&gt; address = val" key="4"&gt;&lt;/prop-event-value&gt; &lt;script&gt; import propEventValue from './components/prop-event-value.vue' export default { name: 'app', components: { propEventValue }, data() { return { address: '' } } } &lt;/script&gt; 子组件
&lt;template&gt; &lt;div&gt; &lt;p&gt;prop-event&lt;/p&gt; &lt;label for="address"&gt;地址&lt;/label&gt; &lt;input type="text" id="address" v-model="tempAddress"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'prop-event', props: ['address'], data() { return { tempAddress: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f747e72e2856700a4d7792c59e5cc06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f543aeb12278e123b25e8d9a8088bd/" rel="bookmark">
			Android 程序运行后，界面不显示的问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在写代码的时候发现程序运行后，在onCreate里面写的布局，一点都没有显示出来，项目也没有报错，显示的界面就是一片空白，这是什么鬼？？？
刚开始我以为是主题或者 背景颜色的问题，后来都改了，结果程序运行一下还是一片空白，撞邪了？？？
平时也是在onCreate里面加载布局啊，为什么，这次加载就是加载不出新布局呢？
后面反思是不是新控件的问题，干脆我把所有的布局都删除掉，就加载一个textView，发现还是显示不出来，在design 的时候，还可以预览到布局，但是为啥程序运行后就显示不出来呢？
后来我又怀疑，是不是Android Studio 出了，问题，运行一下，以前的项目，结果布局显示没有问题， 排除了，软件的异常
后来仔细检查了，一下，原来我onCreate里面调用了两个参数的方法， 结果这个方法，就是不显示布局， 以前调用的都是一个参的
我把
// @Override // public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) { // super.onCreate(savedInstanceState, persistentState); // requestWindowFeature(Window.FEATURE_NO_TITLE); // setContentView(getLayOutID()); // init(); // } 更换成： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(getLayOutID()); } 运行下，发现，布局显示了。原来就是这里出了问题！！！ 那上面那个两个参的是方法是干什么的呢，为啥布局就是不显示呢？
带着疑问：原来也有人和我遇到过同样的问题！
找到了这个博客： http://blog.csdn.net/sunluyao_/article/details/50395791
下面是解释：
今天在我写demo的时候遇到一个问题，当我加载Activity界面的时候，打出onCreate随手回车，setContentView之后却始终无法显示界面，找遍一切可能出错的地方，最后在这个onCreate方法上面发现了猫腻。系统自动给我提供了这么一个onCreate（）。 @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) { super.onCreate(savedInstanceState, persistentState); } 1 2 3 4 第一反应，我并不认识这是一个什么玩意。打开陈旧的api文档，也没有发现PersistableBundle这个类，于是只能求助百度，Google。原来是Api21新加的特性，上一下google，找一下最新api。我们先来看一下PersistableBundle是什么东西。 A mapping from String values to various types that can be saved to persistent and later restored.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f543aeb12278e123b25e8d9a8088bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff536cbe69ca621e92f200ddab3a6870/" rel="bookmark">
			Failed to introspect annotated methods on class org.springframework.boot.web.support.SpringBootServl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种解决方式：
以Application方式启动，在pom中把tomcat的scope改为compile
&lt;!-- tomcat 的支持.--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 以spring-boot：run（maven方式）方式启动工程 （IDEA工具）
Run–》Edit Configurations–》+—》选择Maven–》配置命令为spring-boot:run右上角选择启动方式 ========================================================= 下面说一下主要造成原因，因为我们直接运行application类，而我们的servlet-api等依赖tomcat的库的scope为provide，所以我们的tomcat的scope需要改为compile 以spring-boot：run方式启动相当于直接部署工程到tomcat中，所以tomcat的scope为provide也不会影响
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae827485759be1103dcd912f72651930/" rel="bookmark">
			各版本的anaconda下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网首页总是现实最新版本的anaconda，如果我们想下载旧版本就得找半天，
所有版本在这个网站都可以下载：https://repo.continuum.io/archive/
https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ （推荐，清华大学开源软件镜像站进行下载并配置镜像）
Anaconda3-4.3.0.1-Windows-x86_64.exe 对应 python3.6.0
Anaconda3-5.1.0-Windows-x86_64.exe 对应 python3.6.3
Anaconda3-5.2.0-Windows-x86_64.exe 对应 python3.6.5
安装anaconda后
conda的使用方法：https://conda.io/docs/user-guide/tasks/manage-pkgs.html#installing-multiple-packages
https://www.cnblogs.com/luckyalan/p/6703590.html
https://www.cnblogs.com/esin/p/7073119.html
https://www.cnblogs.com/gaowengang/p/7736672.html
sudo apt-get install python3.6
sudo apt-get purge --auto-remove python3.6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d02307e451245184c778660483e52b/" rel="bookmark">
			如何学习计算机视觉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文的内容主要借鉴CSDN博主NodYoung的一篇文章，但是不知道什么原因，该博主的文章现已删除，这里，我根据自己的理解大致说明一下，对于一个初学小白来说，该如何学习计算机视觉。（有关计算机视觉入门的其它知识，可以阅读另一篇文章计算机视觉入门必读）
1.编程能力 1.1 编程语言(C++, python) 刚接触CV(computer vision)（注：本文偏向于图像学而非图形学）时，大家一般都会不假思索地选择使用C++：装个VS(Visual Studio)，配置下opencv，撸起袖子就上了。这样做非常合理，几乎所有人都是这么入门的。 不过，当你知识面扩展开后，你会感觉到很多时候C++都显得有些力不从心。比如：当你要画一些图表或做一些分析，就还得把数据导入MATLAB里做进一步处理；当你要非常快捷方便地学习或测试一个算法，C++会是你最糟糕的选择；或者当你要学习深度学习时，你绝对不会再选择使用C++….总之，有太多理由会促使你再学习一门编程语言，最好的选择没有之一：python。
1.1.1 简单介绍一下C++和python的各自特点： C++：偏底层，执行效率高，适合嵌入式等平台上使用；在视觉领域，C++生态好，用的人多，网上找资源很方便。 缺点是开发效率实在太低了，关于这一点如果你只是专注于图像处理的话可能感受不是那么真切，因为opencv库做得足够好。但是当你做到机器学习后，opencv就显得有些力不从心了，虽然它也包含一些SVM、神经网络等的简单实现，但毕竟不擅长。
python：全能语言，干啥都行，并且都相对擅长。图像处理，opencv支持有python接口；科学计算，其功能类似于matlab了：机器学习及深度学习，python是最好用的，没有之一；爬虫等网络应用，豆瓣就是用python写的；简而言之，方便，实在太方便了。 当然python也有自己的另一面。执行效率不高，这一点做嵌入式开发的可能比较忌讳。但如今手机的内存都升到6G了，tensorflow都可以在移动端跑了，Python也都可以用来控制STM32了，未来很难说。
顺便说一句也有人使用MATLAB等做图像方面的研究，如果你只是偶尔用图像处理辅助一下你的研究，可以这么做，一般情况下不建议使用。
1.1.2 C++和python学习资源推荐 C++： 初级入门 如果你是一个无编程经验的C++初学者，或者有其它语言经验的C++初学者，那强烈推荐下面的书籍。 C++ Primer作者：Stanley Lippman, Josée Lajoie, and Barbara E. Moo (更新到C++11) （不要和 C++ Primer Plus–Stephen Prata搞混了）近1千页，本书透彻的介绍了C++，以浅显和详细的方式讲到C++语言差不多所有内容。2012年8月发行的第五版包含C++11的内容 电子书：第三版（中文）、第四版（中文）、第五版（英文版）Accelerated C++ 作者：Andrew Koenig and Barbara Moo 这本书覆盖了和C++ Primer一样的内容，但厚度只有C++ Primer的四分之一。这主要是因为本书面向的不是编程的初学者，而是有其它语言经验的C++初学者。对于初学者，本书学习曲线稍显陡峭，但对于能克服这一点的学习者而言，它确实非常紧凑的介绍了C++这门语言。 电子书：中文版，英文版C++编程思想（Thinking in C++) 作者：Bruce Eckel 共两卷，第二卷主要将标准库，但还是不错的。 电子书：第二版V2（英文版）、第二版V2（中文版）最实用 Effective C++ 作者：Scott Meyers 本书以瞄准成为C++程序员必读的第二本书籍而写，Scott Meyers成功了。早期的版本面向从C语言转过来的程序员。第三版修改为面向从类似Jave等语言转来的程序员。内容覆盖了50多个很容易记住的条款，每个条款深入浅出（并且有趣）讲到了你可能没有考虑过的C++规则。 电子书：第三版（英文）、第三版（中文)C++程序设计原理与实践 （Programming: Principles and Practice Using C++ ）作者：Bjarne Stroustrup C++之父写的C++入门书籍。本书面向没有编程经验的初学者，但相信有编程经验的人也能从本书中学到不少东西。 电子书：中文版python： 基础部分看廖雪峰的python教程就可以了，然后就是用哪一块学哪一块了。python学起来很简单，看别人代码的过程就是学习的过程。对于不熟悉的用法多搜下官方文档，如python, numpy,pandas, matplot, scikit-learn。这里有几张python各种库的小抄表其实直接在网上搜这几张表也都比较方便。课程的话，我之前上过一些七月算法的课程，讲得不好，多少会给你一些知识体系和各种学习资料，总体不推荐或跳着看。python的开发环境值得说一下，因为有太多选择，这里比较建议使用pycharm和jupyter notebook吧，具体参考python入门环境搭建。下面，推荐一些入门和进阶的书籍 初级入门 《简明Python教程》 《父与子的编程之旅》 《笨办法学Python》 《深入浅出Python》 《像计算机科学家一样思考python》 《Python编程：入门到实践》 《廖雪峰Python教程》 《Python 入门指南》 进阶 《Python学习手册》 《Python核心编程第3版》 《Python进阶》 《编写高质量Python代码的59个有效方法》 《Python CookBook》 《流畅的Python》 《Python源码剖析》 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60d02307e451245184c778660483e52b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50a57890ffa5b232a7890ccec37dda78/" rel="bookmark">
			任意输入一个整数，编程判断它的奇偶性。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; int main() { int a; printf("Iputa:"); scanf("%d",&amp;a); if(a%2==0) { printf("a是偶数"); } else { printf("a是奇数"); } return 0; } 运行结果： 知识点： 1.if-else语句用于解决双分支选择的问题； 2.在if-else语句中，在两条语句中选择其中的一条来执行。
心得体会： 1.学会使用双分支条件语句编程； 2.在if-else语句中，如果表达式的值为真，执行语句1，否则执行语句2。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621a5d820e2a65ede021a268f7adf41f/" rel="bookmark">
			怎样提高数据恢复的成功率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在互联网迅速发展的时代，我们身处大数据的环境下，数据其实是随处可见的，数据丢失也不再是小概率的事件。也许你曾不小心删除过学习资料，你的U盘因为故障不得不格式化，加班到深夜突然遇到断电……这些事情其实随时都有可能发生。
很多人在数据丢失后，因为不清楚数据恢复的基本知识，随意的一些操作很可能就使得丢失数据再也无法恢复。那么怎样才能提高数据恢复的成功率呢？这也是本文接下来讲的重点。
一、首先，立刻停止对丢失分区的任何操作
如果是相机，那么不要再用这张内存卡继续拍照；如果是U盘，那么停止使用U盘；如果是电脑，在不知道如何恢复的情况下，最好先关机。电脑不比内存卡和U盘这种单纯的存储设备，它是一个多功能性的设备，就算你没有往丢失分区存入新的数据，也不排除你运行其他程序的时候，产生了临时文件，从而覆盖了数据。
二、对丢失数据进行“估价”
这个其实看个人。如果你丢失的是重要数据，类似公司机密文件的话，不建议使用软件个人操作恢复，因为任何软件都不可能给你保证是百分之百恢复成功的，直接找人工，在重要数据面前，价钱应该就没那么重要了。
相比而言不是特别重要的数据，可以尝试用软件恢复，一来软件收费低，二来软件功能简单、恢复流程简化、非常适合个人操作。像现在市面上数据恢复历史比较久的迷你兔数据恢复工具，直接就推出了删除恢复、格式化恢复、硬盘恢复和深度恢复五个功能，一目了然，我们直接选择对应的功能使用就行了，如果不懂，还可以在官网查看教程。
三、恢复数据时，不要直接保存在丢失分区
这也是为了防止数据覆盖。因为有时候丢失分区会有其他问题，诸如病毒之类的。在不清楚这个分区是否安全的情况下，为了保险，要把数据存放在其他安全分区中，也就是没有丢失过数据的分区中。一旦数据覆盖了，那么数据就算恢复出来，打开也是乱码，根本就无法使用的。
四、病毒造成数据丢失时，记得要杀毒
杀毒是必须的，病毒清楚不彻底，很可能会再次丢失数据。但是不要指望杀毒软件可以恢复数据。
另外，如果是数据覆盖或者损坏了，那么也不要想通过数据恢复软件来修复，恢复不等于修复，应该使用修复类软件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550f83b724c54bdd4f537391ec14ae6f/" rel="bookmark">
			任意android 手机支持daydream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对普通手机，最低版本支持到android 5.0
GVR修改
修改sDaydreamPhoneOverrideForTesting
修改libgvr.so
修改MutableEGLConfigChooser
修改scanlineRacer的swapmode
1.0.2
.text:000834F6 CMP R4, #0
.text:000834F8 ITE NE
.text:000834FA MOVNE R4, #4
.text:000834FC MOVEQ R4, #0
00 2C 14 BF 04 24 00 24
改为
00 2C 14 BF 04 24 04 24
只有dev-keys
1.0.3
.text:000834F6 CMP R4, #0
.text:000834F8 ITE NE
.text:000834FA MOVNE R4, #4
.text:000834FC MOVEQ R4, #0
有dev-keys和test-keys
1.1.0
.text:000834F6 CMP R4, #0
.text:000834F8 ITE NE
.text:000834FA MOVNE R4, #4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/550f83b724c54bdd4f537391ec14ae6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/198c47b9b6bc9b7527cee40a75d423dc/" rel="bookmark">
			myeclipse的 Invalid location of警告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在jsp页面使用标签过程中有时候不注意规则的话，eclipse会提示一些错误，下面针对这些错误提出相应的解决办法： 标签 1. Invalid location of tag (form) form 应该写到table外面去，并且form标签里面也不能套form标签。 2. Invalid location of tag (style) style应该写在head里面。 3. Invalid location of tag (script) script应该写到body，head里面。 4.Attribute name(Name) uses wrong case character 虽说HTML不区分大小写，但是在eclipse里面，大写的话就报错，所以要改成小写吧。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/821042df54733ac28efaca081df51480/" rel="bookmark">
			elasticsearch和lucene的关系以及elasticsearch的核心概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、lucene和elasticsearch的前世今生
2、elasticsearch的核心概念
3、elasticsearch核心概念 vs. 数据库核心概念 ----------------------------------------------------------------------------------------------------------------------------------------
1、lucene和elasticsearch的前世今生
lucene，最先进、功能最强大的搜索库，直接基于lucene开发，非常复杂，api复杂（实现一些简单的功能，写大量的java代码），需要深入理解原理（各种索引结构）
elasticsearch，基于lucene，隐藏复杂性，提供简单易用的restful api接口、java api接口（还有其他语言的api接口）
（1）分布式的文档存储引擎
（2）分布式的搜索引擎和分析引擎
（3）分布式，支持PB级数据
开箱即用，优秀的默认参数，不需要任何额外设置，完全开源
关于elasticsearch的一个传说，有一个程序员失业了，陪着自己老婆去英国伦敦学习厨师课程。程序员在失业期间想给老婆写一个菜谱搜索引擎，觉得lucene实在太复杂了，就开发了一个封装了lucene的开源项目，compass。后来程序员找到了工作，是做分布式的高性能项目的，觉得compass不够，就写了elasticsearch，让lucene变成分布式的系统。
----------------------------------------------------------------------------------------------------------------------------------------
2、elasticsearch的核心概念
（1）Near Realtime（NRT）：近实时，两个意思，从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级
（2）Cluster：集群，包含多个节点，每个节点属于哪个集群是通过一个配置（集群名称，默认是elasticsearch）来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常
（3）Node：节点，集群中的一个节点，节点也有一个名称（默认是随机分配的），节点名称很重要（在执行运维管理操作的时候），默认节点会去加入一个名称为“elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个elasticsearch集群，当然一个节点也可以组成一个elasticsearch集群
（4）Document&amp;field：文档，es中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。
product document
{
"product_id": "1",
"product_name": "高露洁牙膏",
"product_desc": "高效美白",
"category_id": "2",
"category_name": "日化用品"
}
（5）Index：索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。
（6）Type：类型，每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户数据type，博客数据type，评论数据type。
商品index，里面存放了所有的商品数据，商品document
但是商品分很多种类，每个种类的document的field可能不太一样，比如说电器商品，可能还包含一些诸如售后时间范围这样的特殊field；生鲜商品，还包含一些诸如生鲜保质期之类的特殊field
type，日化商品type，电器商品type，生鲜商品type
日化商品type：product_id，product_name，product_desc，category_id，category_name
电器商品type：product_id，product_name，product_desc，category_id，category_name，service_period
生鲜商品type：product_id，product_name，product_desc，category_id，category_name，eat_period
每一个type里面，都会包含一堆document
{
"product_id": "2",
"product_name": "长虹电视机",
"product_desc": "4k高清",
"category_id": "3",
"category_name": "电器",
"service_period": "1年"
}
{
"product_id": "3",
"product_name": "基围虾",
"product_desc": "纯天然，冰岛产",
"category_id": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/821042df54733ac28efaca081df51480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/637b39286434f871faf123115f721307/" rel="bookmark">
			C# 发送邮件  SMTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; using System.Collections.Generic; using System.Linq; using System.Net; using System.Net.Mail; using System.Text; using System.Threading.Tasks; namespace WindowsFormsApplication1 {
//在使用 System.Net.Mail组建发送邮件的时候出现了"命令顺序不正确。 服务器响应为: Error: need EHLO and AUTH first !"异常
//1. 需要开启 POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 并且记住授权码
//2. 使用授权码(不要用qq邮箱登录密码)
//3.启用smtp.EnableSsl = true;
/// &lt;summary&gt; /// Author : junlu /// Date : :2017年12月21日 /// Description : 邮件发送辅助类 /// &lt;/summary&gt; public class EmailHelper { #region [ 属性(发送Email相关) ] private string _SmtpHost = string.Empty; private int _SmtpPort = -1; private string _FromEmailAddress = string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/637b39286434f871faf123115f721307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d79ffe94bf6ed5c9b6e88e6ce27db8ff/" rel="bookmark">
			C语言判断文件夹或者文件是否存在以及权限等信息access函数和删除文件或目录 remove()函数使用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言判断文件夹或者文件是否存在以及权限等信息access函数和删除文件或目录 remove()函数使用实例 一、access函数可以判断文件夹或者文件是否存在以及获取权限等信息。 1、所需头文件和函数原型： #include &lt;unistd.h&gt;
int access(const char *pathname, int mode);
2、参数说明： filename：可以填写文件夹路径或者文件路径
mode：（F_OK） 只判断是否存在 （R_OK） 判断读权限 （W_OK） 判断写权限 （X_OK） 判断执行权限
3、返回值： 用于判断文件夹是否存在的时候， 若存在或者具有相关权限，返回值为0；不存在或者无权限，返回值为-1 。
二、remove()函数可以用来删除文件或目录 1、所需头文件和函数原型： #include &lt;stdio.h&gt; int remove(const char *pathname); 2、参数说明： filename：可以填写文件夹路径或者文件路径 3、返回值： On success, zero is returned. On error, -1 is returned, and errno is set appropriately 三、实例测试： #include&lt;stdio.h&gt; #include&lt;unistd.h&gt; char FILE_NAME[80]; int main() { printf("Please input the path's the file you want to delete:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d79ffe94bf6ed5c9b6e88e6ce27db8ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a5ceafbbd394984ba6746bd183aff5/" rel="bookmark">
			值得推荐的C/C&#43;&#43;框架和库 (真的很强大)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		值得学习的C/C++语言开源项目 (1)ACE
庞大、复杂，适合大型项目。开源、免费，不依赖第三方库，支持跨平台。
http://www.cs.wustl.edu/~schmidt/ACE.html
(2)Asio
Asio基于Boost开发的异步IO库，封装了Socket，简化基于socket程序的开发。
开源、免费，支持跨平台。
http://think-async.com/
(3)POCO
POCO C++ Libraries 提供一套 C++ 的类库用以开发基于网络的可移植的应用程序，功能涉及线程、线程同步、文件系统访问、流操作、共享库和类加载、套接字以及网络协议包括：HTTP、 FTP、SMTP 等；其本身还包含一个 HTTP 服务器，提供 XML 的解析和 SQL数据库的访问接口。POCO库的模块化、高效的设计及实现使得POCO特别适合嵌入式开发。在嵌入式开发领域，由于C++既适合底层（设备I/O、中断处理等）和高层面向对象开发，越来越流行。
http://pocoproject.org/
(4)libevent
Libevent是一个轻量级的开源高性能网络库，从它的官网标题：libevent-an event notification library就能知道它的机制是采用事件触发，封装了以下三种事件的响应:IO事件,定时器事件,信号事件。select模型来实现跨平台的操作，Windows环境下支持IOCP。
http://libevent.org/
(5)libev
libev和libevent很像，按照作者的介绍，可以作为libevent的替代者，能够提供更高的性能。
libev是一个高性能事件循环，所实现的功能就是一个强大的reactor。
http://software.schmorp.de/pkg/libev.html
(6)c++ sockets library
封装了sockets C API的C++类库。
支持SSL, IPv6, tcp 和 udp sockets, sctp sockets, http协议, 高度可定制的错误处理。
http://www.alhem.net/Sockets/
(7)libcurl
libcurl是免费的轻量级的客户端网络库，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet, TFTP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a5ceafbbd394984ba6746bd183aff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9cca5c367ed4bac4f2e47645dd59faa/" rel="bookmark">
			wangEditor的使用及上传图片（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于业务需要，最近新入手了一款富文本编辑器wangEditor，这是一款轻量级的富文本编辑器，比起百度的ueditor，这款编辑器的界面更加简单，文档也很详细。对于需求不是很高的功能来说，这款编辑器实在是不二之选。
一、wangEditor的基本显示demo 这个部分，也用不着贴代码，因为文档很详细的，具体的参考文档
https://www.kancloud.cn/wangfupeng/wangeditor2/113965
这里面有显示界面的demo。
二、关于编辑器内容的提交 1、这部分刚开始我也很奇怪，因为编辑器是在div里面，而div又没有value这个属性。所以提交表单的时候，其中的内容该怎么提交上去呢。后来想到用js，把内容同步到input框中，这样我们就可以愉快的提交了。
//这是编辑器的div &lt;div id="info1" class="text" &gt; &lt;!--可使用 min-height 实现编辑区域自动增加高度--&gt; &lt;/div&gt; //下面新增一个input输入框 &lt;input class="input-xlarge focused" name="info" type="text" id="info" &gt; 界面为： 2、新增JS代码
document.getElementById('info').addEventListener('click', function () { // 读取 html var info = editor1.txt.html(); document.getElementById("info").value=info; }, false); 这段的意思是，给下面的input框架一个点击事件。当点击input框的时候，触发点击事件，先获取editor中的html标签文字，然后，再把编辑器中的内容赋值给input的value 如图： 这样，我们提交表单的时候，就可以把编辑器中的内容提交上去了。
3、界面优化
这里如果大家觉得用这个input框多次一举的话，我们可以把input框隐藏起来。
&lt;input id='info1' type='hidden' /&gt; //下面跟表单的其他项，比如 &lt;input class="input-xlarge focused" name="info" type="text" id="info" &gt; //也就是说，当点击表单的其他项的时候,我们还是出发点击事件，然后把编辑器的值赋值给隐藏的input框，这样，页面上不会有什么反应，但是我们已经把编辑器的值随着表单提交到服务器了。 下面该说上传图片了，但是上传图片的内容比较多，所以还是下一篇讲吧，下一篇主要是上传图片到阿里云OSS，并且在编辑器上显示我们上传的图片。
end
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa847ff4761f863514c309b74342e5ea/" rel="bookmark">
			HTML表单颜色选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些情况下，我们要保存对应的颜色值，比如优惠券，会员卡根据金额的不同，颜色
值也有可能不同，那么后台如何获取颜色值呢。 1.使用H5的color输入 &lt;input type="color" name="bgColor"/&gt; 这样提交表单的时候，获取到的颜色值如下
bgColor='#d39de1'
这个会弹出
但是并不是所有的浏览器都支持，比如IE和Safari 2. 使用jquery取色插件colpicker 官网：https://xdsoft.net/jquery-plugins/colpick/
$('#picker').colpick({ layout:'hex', //使用hex 16进制布局 或者 'rgbhex' 或者 'rgb' submit:0, //是否自动提交 color:{r:241,g:22,b:25},//初始设置颜色 colorScheme:'dark', //背景颜色 onChange:function(hsb,hex,rgb,el,bySetColor) { //hsb : {h: 300, s: 80, x: 56} //hex : 8f1d8f //rgb : {r: 143, g: 29, b: 143} //el : &lt;span id=​"picker"&gt;​…​&lt;/span&gt;​ 当前元素 //bySetColor : 0 } }).keyup(function(){ $(this).colpickSetColor(this.value); }); 这个显示效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcd39ee8bee2fe35bde460309dda6368/" rel="bookmark">
			分布式系统架构常识：CAP理论。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是CAP理论？ 2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后麻省理工学院的Seth Gilbert和NancyLynch从理论上证明了CAP，之后CAP理论正式成为分布式计算领域的公认定理。
CAP理论是由下面三个概念组成的，且在分布式系统中三者不能兼得，只能同时满足两种条件。
一致性（C）
All nodes see the same data at the same time
所有数据库集群节点在同一时间点看到的数据完全一致，即所有节点能实时保持数据同步。
可用性（A）
Reads and writes always succeed
读写操作永远是成功的。即服务一直是可用的，即使集群一部分节点故障，集群整体还能正常响应客户端的读写请求。
分区容错性（P）
The system continues to operate despite arbitrary message loss or failure of part of the system
尽管系统中有任意的信息丢失或故障，系统仍在继续运行。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。
CAP权衡使用 1、保留CA，放弃P
如果想避免分区容错性问题的发生，一种做法是将所有的数据（与事务相关的）都放在一台机器上。虽然无法100%保证系统不会出错，但不会碰到由分区带来的负面效果。当然这个选择会严重的影响系统的扩展性。
作为一个分布式系统，放弃P，即相当于放弃了分布式，一旦并发性很高，单机服务根本不能承受压力。
像很多银行服务，确确实实就是舍弃了P，只用单台小型机+ORACLE保证服务可用性。
2、保留CP，放弃A
相对于放弃“分区容错性“来说，其反面就是放弃可用性。一旦遇到分区容错故障，那么受到影响的服务需要等待一定的时间，因此在等待期间系统无法对外提供服务。
作为分布式系统，有分区服务发生问题很有可能，如果因为某些服务不能用，导致整个服务都不能用，这个根本不是好的分布式系统。
3、保留AP，舍弃C
这里所说的放弃一致性，并不是完全放弃数据一致性，而是放弃数据的强一致性。即放弃了同一时刻的数据一致性，而保留数据的最终一致性。
以网络购物为例，对只剩下一件库存的商品，如果同时接受到了两份订单，那么较晚的订单将被告知商品告罄。
通常情况下，很多分布式服务系统都是采用该方案，保证可用性性，分布式服务，因为某些分区服务发生问题，先容忍，最终通过一些折中的方法达到最终数据一致性。
推荐阅读 去BAT面试完的Mysql面试题总结（55道，带完整答案）
阿里高级Java面试题（首发，70道，带详细答案）
2017派卧底去阿里、京东、美团、滴滴带回来的面试题及答案
Spring面试题（70道，史上最全）
通往大神之路，百度Java面试题前200页。
分享Java干货，高并发编程，热门技术教程，微服务及分布式技术，架构设计，区块链技术，人工智能，大数据，Java面试题，以及前沿热门资讯等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e44ce39f45e4cc255ab8b649cde2cdc/" rel="bookmark">
			[Objective C] objc_setAssociatedObject 关联详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.关联 关联是指把两个对象相互关联起来，使得其中的一个对象作为另外一个对象的一部分。关联特性只有在Mac OS X V10.6以及以后的版本上才是可用的。 2.关联本质-在类的定义之外为类增加额外的存储空间 使用关联，我们可以不用修改类的定义而为其对象增加存储空间。这在我们无法访问到类的源码的时候或者是考虑到二进制兼容性的时候是非常有用。 关联是基于关键字的，因此，我们可以为任何对象增加任意多的关联，每个都使用不同的关键字即可。关联是可以保证被关联的对象在关联对象的整个生命周期都是可用的（在垃圾自动回收环境下也不会导致资源不可回收）。
3.创建关联(原理) 创建关联要使用到Objective-C的运行时函数：objc_setAssociatedObject来把一个对象与另外一个对象进行关联。函数 void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 复制代码 参数说明 id object :表示关联者，是一个对象，变量名理所当然也是object const void *key :获取被关联者的索引key id value :被关联者，这里是一个block objc_AssociationPolicy policy :关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC 复制代码 关键字 : 是一个void类型的指针。每一个关联的关键字必须是唯一的。通常都是会采用静态变量来作为关键字。关联策略表明了相关的对象是通过赋值，保留引用还是复制的方式进行关联的；还有这种关联是原子的还是非原子的。这里的关联策略和声明属性时的很类似。这种关联策略是通过使用预先定义好的常量来表示的。 4.创建关联(步骤1) 下面的代码展示了如何把一个字符串关联到一个数组上 //1.声明一个静态变量,用作关键字.此处也可以直接用一个字符串(但不推荐) static char overviewKey; //2.创建一个数组变量 NSArray * array =[[NSArray alloc] initWidthObjects:@"One", @"Two", @"Three", nil]; //3.创建一个字符串变量 //为了演示的目的，这里使用initWithFormat:来确保字符串可以被销毁 NSString * overview = [[NSString alloc] initWithFormat:@"@",@"First three numbers"]; //4.关联代码操作(关键) objc_setAssociatedObject(array, &amp;overviewKey, overview, OBJC_ASSOCIATION_RETAIN); [overview release]; //(mrc中使用,arc中不用写)为了说明overview是否可用而写,ARC中省略 //(1) overview仍然是可用的 [array release]; //(mrc中使用,arc中不用写)为了说明overview是否可用而写,ARC中省略 //(2)overview 不可用 复制代码 说明: 在（1）处，字符串overview仍然是可用的，这是因OBJC_ASSOCIATION_RETAIN 策略指明了数组要保有相关的对象。当数组array被销毁的时候，也就是在（2）处overview也就会被释放，因此而被销毁。如果此时还想使用overview，例如想通过log来输出overview的值，则会出现运行时异常。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e44ce39f45e4cc255ab8b649cde2cdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ce948a5f646511a91521ec137e2ec6/" rel="bookmark">
			Transform.Forward和Vector3.Forward的正确使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Transform.Forward和Vector3.Forward的正确使用方法 发布：Unity3d培训 来源：unity3d培训教程 2016-07-23 浏览次数：3465
很多人对于Transform.Forward和Vector3.Forward的正确使用方法都不太清楚，那么今天菜鸟在线小编就来给大家介绍一下他们的用法，一起来看今天的Unity3d教程吧!
在某个风和日丽的下午，你们的Unity3d开发传奇师兄黄高军问我，为啥他写的控制车辆，车辆不能往正前方行驶。我扫了一下他的代码，
this.transform.Translate(transform.forward);
这样奇怪的用法我还是第一次见!
当时我就不高兴了，“高军，老师教什么你用什么，你说说这个transform.forward在哪学的?”
“你看看，车辆都绕圈走了，不会用就别乱用，乖乖用我教的方法!”
事实证明，我当时那番话说错了，后来这位传说级的师兄找到一份虚幻4的工作，圆了我毕业三年都无法圆的梦。
我惭愧不已，写下这个研究结果，以纪念我曾经带过的那么一个优秀的学生。
一切从汽车控制说起
我们都知道，改变物体的坐标，可以模拟物体移动。
场景中有辆车的位置为(0,0,0)，我们想让他向前移动，通过scene界面我们发现物体向前移动得改它的z轴，于是我们可以这么写代码
void Update () {
this.transform.position += new Vector3 (0, 0, 1);
}
这么写之后，确实就往前方跑了，但是有个问题，Update一帧执行5,60次，每帧都new 一个Vector3的话，对内存是一个消耗。
于是我们用一个系统自带的Vector3.forward(它代表Vector3(0,0,1))
void Update () {
this.transform.position += Vector3.forward;
}
所以记住，Vector3.forward是一个定值，它没有任何意义!它仅仅代表Vector3(0,0,1)，仅此而已，前往别给它任何意义。
那么上面的代码其实是有问题的。当我们把小车的旋转值改变之后，发现this.transform.position += Vector3.forward已经不能让车往前方走了，
他需要一个正确的方向向量。
于是transform.forward应运而生。他是一个用来自动对物体旋转值算出前进方向向量的变量。
void Update () {
this.transform.position += transform.forward;
}
我们把代码改成上面那样，就可以按照车辆向前的方向行驶了。
所以记住，transform.forward是一个变值，它代表物体的前方的向量!会根据物体的旋转量自动算出来，如果物体时刻在旋转，这个transform.forward是会一直变化的。
于是就有同学问了?老师不是啊，我们以前经常使用的transform.Translate(Vector3.forward)他也可以根据物体的转向进行前进动作啊，那这么说来Vector3.forward不是一个变值吗??
void Update () {
this.transform.Translate (Vector3.forward);
}
于是我们把代码改成上面那样，发现是可以根据物体旋转量进行变化，那么这里Translate是一个函数，肯定是里面偷偷进行了转换，而我们不知道。那么Unity在Translate里面偷偷做了什么转化呢?
其实很简单
void MyTranslate(Vector3 dir){
transform.position += this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33ce948a5f646511a91521ec137e2ec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208ab0b0d38ff9899f2df9ac15ca2002/" rel="bookmark">
			nginx 负载均衡时，一台tomcat宕机时的问题 自动切换(转自java版web项目-微信公众号)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果Nginx没有仅仅只能代理一台服务器的话，那它也不可能像今天这么火，Nginx可以配置代理多台服务器，当一台服务器宕机之后，仍能保持系统可用。具体配置过程如下：
1. 在http节点下，添加upstream节点。
upstream linuxidc {
server 10.0.6.108:7080;
server 10.0.0.85:8980;
}
2. 将server节点下的location节点中的proxy_pass配置为：http:// + upstream名称，即“
http://linuxidc”.
location / {
root html;
index index.html index.htm;
proxy_pass http://linuxidc;
}3. 现在负载均衡初步完成了。upstream按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能 自动剔除。虽然这种方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。适用于图片服务器集群和纯静态页面服务器集群。
除此之外，upstream还有其它的分配策略，分别如下：
weight（权重）
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。如下所示，10.0.0.88的访问比率要比10.0.0.77的访问比率高一倍。
upstream linuxidc{
server 10.0.0.77 weight=5;
server 10.0.0.88 weight=10;
}
ip_hash（访问ip）
每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
upstream favresin{
ip_hash;
server 10.0.0.10:8080;
server 10.0.0.11:8080;
}
fair（第三方）
按后端服务器的响应时间来分配请求，响应时间短的优先分配。与weight分配策略类似。
upstream favresin{ server 10.0.0.10:8080;
server 10.0.0.11:8080;
fair;
}
url_hash（第三方）
按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。
注意：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。
upstream resinserver{
server 10.0.0.10:7777;
server 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208ab0b0d38ff9899f2df9ac15ca2002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf94dd332238093b0f583ffebdb35369/" rel="bookmark">
			Linux下增加Sawp分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建磁盘分区作为swap分区
1.以root身份进入控制台（登录系统），输入
# swapoff -a #停止所有的swap分区
2. 用fdisk命令（例：# fdisk /dev/sdb）对磁盘进行分区，添加swap分区，新建分区，在fdisk中用“t”命令将新添的分区id改为82（Linux swap类型），最后用w将操作实际写入硬盘（没用w之前的操作是无效的）。
3. # mkswap /dev/sdb2 #格式化swap分区，这里的sdb2要看您加完后p命令显示的实际分区设备名
4. # swapon /dev/sdb2 #启动新的swap分区
5.为了让系统启动时能自动启用这个交换分区，可以编辑/etc/fstab,加入下面一行
/dev/sdb2 swap swap defaults 0 0
二、用文件作为Swap分区
1.创建要作为swap分区的文件:增加1GB大小的交换分区，则命令写法如下，其中的count等于想要的块的数量（bs*count=文件大小）。
# dd if=/dev/zero of=/root/swapfile bs=1M count=1024
2.格式化为交换分区文件:
# mkswap /root/swapfile #建立swap的文件系统
3.启用交换分区文件:
# swapon /root/swapfile #启用swap文件
4.使系统开机时自启用，在文件/etc/fstab中添加一行：
/root/swapfile swap swap defaults 0 0
新建和增加交换分区用到的命令为：mkswap、swapon等，而想关闭掉某个交换分区则用“swapon /dev/sdb2”这样的命令即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b666fd0b1e1fe7d682f64fa855ab8f3/" rel="bookmark">
			SMOTE实例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 采用KNN算法，计算出每个少数类样本的K个邻近；从K个邻近中随机挑选N个样本进行随机线性插值；构造新的少数类样本；将新样本放入原数据，产生新的训练集； 实现 from sklearn.neighbors import NearestNeighbors import numpy as np import random class Smote: #samples的最后一列是类标，都是1 def __init__(self, samples, N=10,k=5): self.n_samples, self.n_attrs=samples.shape self.N=N self.k=k self.samples=samples def over_sampling(self): if self.N&lt;100: old_n_samples=self.n_samples print "old_n_samples", old_n_samples self.n_samples=int(float(self.N)/100*old_n_samples) print "n_samples", self.n_samples keep=np.random.permutation(old_n_samples)[:self.n_samples] print "keep", keep new_samples=self.samples[keep] print "new_samples", new_samples self.samples=new_samples print "self.samples", self.samples self.N=100 N=int(self.N/100) #每个少数类样本应该合成的新样本个数 self.synthetic=np.zeros((self.n_samples*N, self.n_attrs)) self.new_index=0 neighbors=NearestNeighbors(n_neighbors=self.k).fit(self.samples) print "neighbors", neighbors for i in range(len(self.samples)): nnarray=neighbors.kneighbors(self.samples[i],return_distance=False)[0] #存储k个近邻的下标 self.__populate(N, i, nnarray ) return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b666fd0b1e1fe7d682f64fa855ab8f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613e870f85c5fb1b305a8835dc9de033/" rel="bookmark">
			摩拜单车红包骑行引发的潮汐问题思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：摩拜刚刚推行红包骑行的时候写的，最近比较忙一直忘记了，今天有时间发出来，言语不当之处，还望见谅，希望各位发表意见。谢谢。
PS：摩拜单车相关人员已经看过，表示还可以，谢谢。
2017 年，共享单车有很多，最先进入人们眼帘的应该是那一个类似于滴滴的颜色的摩拜单车，摩拜单车也是我本人在所有的单车里面最喜欢的单车。因为我认为这样的车才能配的上这个互联网快速发展的时代。无论是车身的设计、技术的领先、市场的占领等等方面，我都很喜欢这样的单车。但是并不是没有缺点，确实摩拜单车骑起来比较重，但是仅仅这一个问题并不能够来否定摩拜单车的优点，而且我相信就单单摩拜单车骑起来比较重这点问题，摩拜只要想解决就是能够马上解决的，毕竟自行车已经有了上百年的历史，现在的我们，已经站在了巨人的肩膀上，现在遇到的问题前人早就已经遇到，只是看我们自己是怎么样的人了。
2017年考验国民素质不再是一个难题，只需要去调查一下城市内共享单车的破损程度就能够略知一二了。可能这是比较片面的，但是这绝对是最有利的考量标准，人性在没有管辖的情况下会显露无遗。就算是国足的球迷帮助国人给世界人们树立再多的优质形象，因为共享单车的出现，再多的美好形象也轰然倒塌。
共享单车到底能共享多久，能骑多远，不是单车的质量问题决定的，主要的绝对因素是国民的素质。是不是共享的就是免费的、就可以肆无忌惮进行破坏的。因为一块钱，就要用自己的锁把车子锁起来，因为一块钱就要把二维码擦掉，难道人们真的是缺少一块钱吗，或许人们缺少的更多是素质吧，是大国人民的素质。
言归正传，现在来叙述一下潮汐问题：
潮汐问题 在摩拜单车的“潮汐问题”方面不过是引义，真正的潮汐问题，是由于月球对于地球的引力引起，每天出现两次导致潮水的上涨，在航海问题上面比较注重。通过详细的记录数据，建模会发现，潮汐问题的数学模型是正弦模型，完全能够通过有效的方法进行避免，在航海的问题上面，人们可以通过调整船舶的靠岸时间以及停泊时间有效的解决，当时在共享单车的领域，公司只是负责进行合理的布车，而不能要求用户怎么骑，骑多久，所以相对于航海来说，共享单车想要解决“潮汐问题”难度更加的大。
摩拜单车红包骑行解决潮汐问题 这是共享单车领域一定会遇到的问题，只要共享存在，就一定会存在，在大城市中尤为明显。大城市中，公共交通相对发达，人们大多选择乘坐公共交通出行，拿我所在的城市北京举例来说明。北京地铁16条线，贯穿北京城市所有地段，而且还有新建地铁，毫不夸张的说，无论你是否来过北京，只要认识文字，总是能够通过地铁去到你所有想去的地方。但是由于北京的不平衡发展导致有部分地段并没有解决人们出行的最后几公里问题，共享单车未出现之前，人们从地铁站出来大多选择黑车、摆渡车、走路回家，但是共享单车出现之后，人们完全是选择共享单车回家。这就导致了潮汐问题的存在，人们早上上班的时候，大量的单车停靠在地铁站，由于大多数都是上班族，地铁流通人员也是上班族，在五点半之前单车的利用率几乎为0，安安静静的停靠。上班族下班后，大约从晚上七点开始，单车被陆续的骑走，除去损坏车辆后地铁站没有什么车辆停留。详细统计后可以发现，这部分单车每辆单车每天的利用时间最多大约是2小左右。之前有记者曾采访摩拜单车创始人，对于盈利模式并没有给出确定的模式，只是说明，通过数据统计，只要每天单车的利用时间能够达到6小时，摩拜就能够实现盈利。但是通过整体的数据分析，摩拜单车的每天每辆的利用时间完全不足6小时。按照平均值的算法，数学上权值大部分由刚才提及的地铁单车瓜分。此时，摩拜单车的潮汐问题解决问题方案应运而生。 摩拜单车的解决方案很暴力很具有技术性，这也是 ofo 等单车不能够实现的，这里完全甩了 ofo 好几条街。因为摩拜单车存在 GPS 定位模块，公司熟知车辆的分布情况，同时能够知道车辆的使用时间。摩拜运营团队通过分析数据可以知道哪里的车是最不赚钱的车，将此部分的车辆定义为红包的车辆，人们骑行指定的红包车辆，给用户1值100元面额不等的红包，通过这样的手段，利用用户自动的将车移动至活跃地点，激活车辆，实现盈利的目的。对于摩拜单车的解决方案有以下几点：
以红包的形式投入金额相对于直接公司雇佣人员进行移动车辆少得多，而且起到推广的作用，由于微信的崛起，人们已经习惯发红包、抢红包，人们看见红包就想抢，所以摩拜单车选择红包的形式，进行所谓的补贴，属于一举多得车辆放置地点更加合理。世间本没有路，走的人多了自然成了路。摩拜的形式有点类似于此。摩拜开始时也不知道具体车辆应该布置在哪里，但是通过长时间的运营，数据的分析，完全有能力确定合理的布车地点在哪里，能够给人们提供更多的便利，日后能够实现利益最大化。举个例子，车辆在七环，合理布车点在五环。摩拜将此车设置为红包车辆，从七环骑到六环，奖励用户10元，从六环骑到五环奖励5块钱。而且停车地点还是用户下次想要骑车的点，最糟糕的情况就是下一次骑车的人还是刚刚骑车的人，但是感觉这样的情况不会很多。公司只需要投入15元便能够将车辆激活。但是如果公司雇佣人员去挪车，人工费、行车费两者要远远高于15元，同时布车地点不一定是最合理地点。所以说摩拜的红包骑行在理论方面来说绝对是最有效的，同时最能够吸引新用户的。 以上所有的优点是确实存在的，但是实现起来是需要有前提条件的，就是在理论的前提下。真正的拿到市场上，用户面前的时候，具体什么效果，完全不是公司能够左右的。同样市场已经对摩拜的红包骑行给出反应，用户市场反应并不是很好，并没有真正的解决问题，主要的原因有以下两点
用户是否真的愿意因为几块钱的红包而选择以后都不能骑到这辆车，可能不至于骑不到车辆，但是方便程度有所降低用户将车辆自锁之后，完全据为己有，不再考虑其他方面用户完全不感兴趣，还是每天上下班骑行 这还是摩拜单车的解决方案，因为摩拜单车能够进行车辆的自行定位，至于 ofo 完全不可能这样解决问题，毕竟相对来说ofo 的车并没有任何的科技含量，公司布置出去之后，公司都不知道车辆在哪里。更无法做出相应的基于数据的运营。所以在本人看来，无论从科技含量、车身质量等方面来说，摩拜单车能够走的更远、更加强大。
2017 年平常老百姓变得更加重要，平常老百姓有了另外一个名字 -- 用户，所有的公司都希望平常老百姓能够成为自己公司的用户，但是公司没有考虑到用户也有用户的问题，并不是成为你的用户之后就能够全部的听您指挥，说的直白一点用户并不是傻子。2017 年数据变得更加重要，无论是电话号码还是家庭住址，闲的尤为重要，淘宝和高德地图的合作，能够知道那栋楼哪一户下了淘宝的订单，但是从来没有人们注意数据的安全问题，总是在公众场合说着所谓的数据安全，但是反过来在背地里进行数据的交易。
希望中国的互联网能够良性发展，为人们提供便利的同时，能够保证用户的数据安全，真正为用户提供想要的东西。
2017年 03月 31日 18:28 北京开往哈尔滨西高铁 D27
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7162a4e0af00ca83e0eab2c46f03a69d/" rel="bookmark">
			损失函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 线性回归中的损失函数 用损失函数来度量预测系统的错误程度
线性回归模型 hθ(x)=θ0+θ1x 损失函数选用平方损失函数(线性回归的损失函数) L(Y,h(X))=(Y−h(X))2 经验损失函数： Rexp(h)=1m∑i=1mL(yi,h(xi)) 实例： 已拥有如下点集（1，1），（2，2），（3，3） 为了简单选取模型 hθ(x)=θx 进行拟合,则关于 θ 的经验损失函数 J(θ) 表示为： J(θ)=1m∑i=1m(yi−h(xi))2 将 h(x)=θx 与已知点集带入经验损失函数： J(θ) =13[(1−θ)2+(2−2θ)2+(3−3θ)2]=143(θ−1)2 由化简式轻易可得当 θ=1 时，经验损失函数最小， minJ(θ)=0 ，带入得最到函数 h(x)=x 实例拓展： 已然是线性回归，模型 hθ(x)=θ0+θ1x 参数有两个： θ0,θ1 损失函数： J(θ0,θ1)=12m∑mi=1(hθ(xi)−yi)2 目标： minJ(θ0,θ1) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1f126ef3b67138c7e19176b361e6857/" rel="bookmark">
			梯度下降
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		挖坑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926bbca97da1f54b3e102139e71b812e/" rel="bookmark">
			MySQL中创建数据库时的一些属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Navicat 创建数据库时，需要选择 字符集 和 排序规则 。
其中，字符集常用utf-8；而有一个长得很像的一个字符集是 utf-8mb4 ，这个兼容utf-8，且支持表情字符的保存。
然后，排序规则中：ci全称为case insensitive,意思是大小写不敏感，cs区分大小写，bin是以二进制数据存储，且区分大小写 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f010b598c924a9c8f0fab0e1d2efbff9/" rel="bookmark">
			Google 搜索常用命令和小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Google Query Operators2 Putting It All Together How to Use These Commands Operators in the Real World 2-1 Exclude Specific Terms That Arent Helpful to You2-2 Exclude More Than One Term2-3 Exclude Terms That Are Exact 3 Technical SEO Audits 3-1 Identify How a Site is Indexed3-2 Remove Multiple Subdomains3-3 Drill Deep Down Into Non-Secure Pages and Audit Your http to https Transition3-4 Finding Duplicate Content 1) Google Query Operators Here’s my Top Ten list (well, more like 20+) of Google Query Operators:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f010b598c924a9c8f0fab0e1d2efbff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6b43a1ab65d57e2a8d8807a3d48627/" rel="bookmark">
			vue中实现先请求数据再渲染dom
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中遇到了一个问题，下面是vue template中的代码：
我之前的写法是
这样做的结果是下面取dom的操作，取到的dom都是undefined，也就是没有取到。
原因是并没有按照 请求数据—&gt;渲染dom—&gt;获取dom的顺序执行，实际的执行顺序是 先获取dom，而此时数组option中还是空的，上面的v-for循环也就没有渲染出dom，所以根本取不到（不理解是为什么）
后来我又把请求数据写在了created函数中，把取dom的操作写在mounted函数中，竟然还是先执行取dom的操作（是通过alert的顺序来判断执行的顺序），我也很绝望啊
最后终于找到了解决的办法：
看到一个别人的回答是：“在数据请求的回调中使用nextTick，在nextTick的回调里试试～”
还有一个人的回答是：“如果有依赖dom必须存在的情况，就放到mounted(){this.$nextTick(() =&gt; { /* code */ })}里面”（这种之前我试过，我太好用，不懂为什么）
我把这两种方法综合起来，其实主要是第一种方法，发现好用了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf7b88669c8f97726b1ce8c4be0ff3c/" rel="bookmark">
			NWERC 2017(Connect the Dots-几何&#43;搜索)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：4*4个格点，要求一笔从小到大依次经过这16个点。求使用的最小线段数。
暴搜。 考虑任意一条线段一定满足 1.斜率为2个不超过20的整数的比值；2.至少经过1个点。 搜索状态为（当前画到了第几个点，当前所在射线的方向） 转移为： 在这个点转一下方向， 直接画到下一个点。 画到下一个点，中间转一次方向。
#include&lt;bits/stdc++.h&gt; using namespace std; #define For(i,n) for(int i=1;i&lt;=n;i++) #define Fork(i,k,n) for(int i=k;i&lt;=n;i++) #define Rep(i,n) for(int i=0;i&lt;n;i++) #define ForD(i,n) for(int i=n;i;i--) #define ForkD(i,k,n) for(int i=n;i&gt;=k;i--) #define RepD(i,n) for(int i=n;i&gt;=0;i--) #define Forp(x) for(int p=Pre[x];p;p=Next[p]) #define Forpiter(x) for(int &amp;p=iter[x];p;p=Next[p]) #define Lson (o&lt;&lt;1) #define Rson ((o&lt;&lt;1)+1) #define MEM(a) memset(a,0,sizeof(a)); #define MEMI(a) memset(a,127,sizeof(a)); #define MEMi(a) memset(a,128,sizeof(a)); #define INF (2139062143) #define F (100000007) #define pb push_back #define mp make_pair #define fi first #define se second #define vi vector&lt;int&gt; #define pi pair&lt;int,int&gt; #define SI(a) ((a).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cf7b88669c8f97726b1ce8c4be0ff3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d9330f38ac2d0992bba71d5d9debb2/" rel="bookmark">
			numpy 数组维度操作总汇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numpy中如何改变数组维度呢？
写在前面
所有的重排原则： 从原数组最深维度开始依次取元素排到转换后数组最深维度处 1、reshape &amp; resize &amp; shape 改变数组维度 reshape函数：不改变原数组维度，有返回值
resize函数：直接改变原数组维度，无返回值
shape属性：直接改变原数组维度
&gt;&gt;&gt; import numpy as np &gt;&gt;&gt; a=np.arange(12) &gt;&gt;&gt; a array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) &gt;&gt;&gt; a.reshape(2,6) array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]) &gt;&gt;&gt; a array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) &gt;&gt;&gt; a.reshape(2,3,2) array([[[ 0, 1], [ 2, 3], [ 4, 5]], [[ 6, 7], [ 8, 9], [10, 11]]]) &gt;&gt;&gt; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d9330f38ac2d0992bba71d5d9debb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59c2dda8e8152be15fb93333bb8120e/" rel="bookmark">
			oracle学习之sid_name
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 遇到问题：
ORA-12505, TNS:listener does not currently know of SID given in connect descriptor
解决方案：（参考）
jdbc连接数据库的时候，需要使用数据库的sid_name，而不是数据库的services_name.而使用plsql连接数据库的时候，只需要数据库的services_name即可，所以修改连接字符串中的services_name 为sid_name. 查询sid_name的方法 select INSTANCE_NAME from v$instance;查出PL/SQL工具中的数据库【127.0.0.1/ORCL】sid_name错了，应该为 ORCLF。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7af0037e87ae8481e0a325ec6f5f1af/" rel="bookmark">
			Java微信公众号--3--网页授权的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面在写微信公众号开发的时候，我一直有提到一个问题，那就是域名的问题，然后在补充下一个问题是，如果你看了 爱慕课上面讲的网页授权还是发现成功不了，那就可能是HTTPS请求的方式有问题了
目前以测试号为例
这个域名相对于来说就没有那么多的要求，就会简单很多 而关于这个域名，就不要出现二级域名的情况，避免跨域请求的出现； 如果你的域名不对的话可能会出现的问题：微信公众号—-多次请求，状态码（40001）
近段时间通过慕课的伙伴还发现一个这种问题，就是当你和慕课上面的代码一模一样的话，可能这个问题也会存在，就是微信公众号—-多次请求，状态码（40001） debug了下发现问题出现在HTTPS请求这边，可以用这篇文章中HTTPS请求进行代替慕课网中的请求：Java—发送HTTPS请求
下面我贴一下我的代码： 接口配置信息的URL：花生壳 网页授权回调页面域名：NATAPP jar包
代码结构： util： util里面的代码：Java—发送HTTPS请求这里面的是一样的
pojo： Info.java
package pojo; import java.util.List; /** * 通过网页授权获取用户信息 * Created by admin on 2017/11/15. */ public class Info { // 用户标识 private String openid; // 用户昵称 private String nickname; // 性别（1是男性，2是女性，0是未知） private int sex; // 国家 private String country; // 省份 private String province; // 城市 private String city; // 用户头像链接 private String headimgurl; // 用户特权信息 private List&lt;String&gt; privilege; public String getOpenid() { return openid; } public void setOpenid(String openid) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7af0037e87ae8481e0a325ec6f5f1af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460ed1dec5485d50b37cdfd3cf1f4b57/" rel="bookmark">
			SQLSERVER 2012 HADR_DATABASE_WAIT_FOR_TRANSITION_TO_VERSIONING  等待事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HADR_DATABASE_WAIT_FOR_TRANSITION_TO_VERSIONING
A query on object(s) in a readable secondary database of an AlwaysOn availability group is blocked on row versioning while waiting for commit or rollback of all transactions that were in-flight when the secondary replica was enabled for read workloads. This wait type guarantees that row versions are available before execution of a query under snapshot isolation.
问题描述
在AlwaysOn辅助副本上，做select查询运行缓慢，发现遇到HADR_DATABASE_WAIT_FOR_TRANSITION_TO_VERSIONING等待。
排查方法
确定遇到该等待事件的查询语句包含对象所在的数据库（假设为adventureworks2012）。 在主副本上运行如下查询语句查看堵塞的源头。
select * from sys.sysprocesses where open_tran&gt;0 and dbid=db_id('adventureworks2012') 如上语句运行出来的所有行，即为导致辅助副本上运行语句的堵塞会话。若该会话处于异常状态，导致无法提交，您可以选择直接kill此会话
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/460ed1dec5485d50b37cdfd3cf1f4b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ae6cacc16df4dc1426c3b69dc76ea9/" rel="bookmark">
			visual studio中头文件和库文件路径设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在程序开发中，很多时候需要用到别人开发的工具包，如OpenCV和itk。一般而言，在vs中，很少使用源文件，大部分是使用对类进行声明的头文件和封装了类的链接库（静态lib或动态dll）。如果要使用这些类，需要在文件中包含头文件的名字，如#include “cv.h”。但这个并不够，因为这个文件一般来说不在当前目录下，解决方法如下
方法一：
将所包含的头文件复制到当前目录（另一篇文章有写）下，这个比较有局限性，因为如果头文件太多，这样比较麻烦。
方法二：
步骤A: 添加头文件所在的目录
步骤A-1: 依次打开“项目——属性——配置属性——C++——常规——附加包含目录”中加入所有的路径。 这里需要注意的是： （1）路径必须指向头文件所在的子文件夹，而不能直到父文件夹就结束 （2）每个路径不需要加上双引号，输入了之后，vs2008会自动加上双引号，如果自己加可能vs2008无法识别双引号 （3）如果是多个路径，路径直接用“；”隔开。
步骤B: 添加库（libs）文件目录和lib文件名
除了头文件以外，也需要告诉编译器，类在哪里实现的，即封装类的链接库在哪里，这样程序才能执行工具包中的函数。首先需要将链接库的路径输入vs2008，即添加库（libs）文件目录。
步骤B-1：依次打开“项目——属性——配置属性——链接器——常规——附加库目录”中加入链接库的路径。 步骤B-2：添加所需“库文件”名称，即添加编译所需要（依赖）的 lib 文件 。在“项目——属性——配置属性——链接器——常规——输入——附加依赖项”中加入链接库的名字，多个lib用空格隔开。（等同于“#pragma comment(lib, “xxx.lib”) ”语句）。
一般我们推荐使用方法二，同时所有的路径使用相对路径的方式，以便于移植，相对路径宏参考资料
转载：http://blog.sina.com.cn/s/blog_77c35cff01010u7b.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e735e69a4c5fcc67f91d11787a55a31/" rel="bookmark">
			基于Vue移动音乐webapp跨域获取QQ音乐歌单接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看了一个vue移动音乐webapp教程，老师是一个来自滴滴公司的名为黄轶的前端大神，之前学习了他的一个基于vue仿饿了么webapp的初级教程，感觉非常好，十分适合新手，但是那个教程的数据都是前端模拟的一个data.json的json文件，这一次的教程的数据全都是来自QQ音乐的真实数据，需要请求它的接口，因为是线上的数据，所以许多接口需要进行跨域或者设置一些头部信息。 我的vue版本是2.5.2，用vue-cli脚手架工具搭出来的项目结构是： 说一下接口，QQ音乐歌单接口以及参数如下： 其中最需要注意的点是headers里的referer，需要设置成跟QQ音乐的请求参数一样，否则请求该接口服务端不会响应，因为前端是不能够强行修改referer的，所以需要去设置一个后台代理，这是老师的那个vue-cli版本搭出来的项目结构的方法，他的项目结构里有一个dev.server.js。 他在dev.server.js里用express框架搭了一个服务器，设置一个接口，然后让前端去请求这个接口，在这个接口里再去请求QQ音乐的歌单接口并且设置相应的头文件信息如referer等，这样就达到了目的。 由于我的vue-cli搭出来的项目结构跟老师的不一样，没有按照老师的方法去请求，但是在config文件夹下的index.js里提供了一个proxyTable属性，可以在这里进行跨域请求。 在这里配置一个接口名，对应的值是一个对象，target属性是真实请求的值，bypass对应的函数是请求之前可以进行的操作，req这个参数就是请求的信息，可以在这里设置请求头信息，然后通过pathRewrite设置一下前缀，最后在前端请求的接口写成设置的接口名就能进行请求了。 记得把参数的format传成json，这样返回的值就会是json数据了，方便进行操作。 如果你觉得我的文章有帮助，请支持我吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6bef94abedc0d7c6625f3e62a786add/" rel="bookmark">
			VS中的路径宏 OutDir、ProjectDir、SolutionDir各种路径含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 $(RemoteMachine)
设置为“调试”属性页上“远程计算机”属性的值。有关更多信息，请参见更改用于 C/C++ 调试配置的项目设置。
$(References)
以分号分隔的引用列表被添加到项目中。
$(ConfigurationName)
当前项目配置的名称（例如“Debug”）。
$(PlatformName)
当前项目平台的名称（例如“Win32”）。
$(Inherit)
指定在由项目生成系统所撰写的命令行中，继承的属性出现的顺序。默认情况下，继承的属性出现在当前属性的末尾。
$(NoInherit)
使任何将被继承的属性不被继承。若还要避免同级级别的计算，请使用$(StopEvaluating)。使用 $(NoInherit)会导致对于同一属性忽略任何出现的 $(Inherit)。
$(StopEvaluating)
立即停止计算链中宏的计算。出现在 $(StopEvaluating) 之后的任何值将不出现在宏的计算值中。如果$(StopEvaluating) 在 $(Inherit) 之前，计算链中当前位置的继承值将不会连接到宏值。$(StopEvaluating)是 $(NoInherit) 的功能超集。
$(ParentName)
包含此项目项的项的名称。该名称将是父文件夹名称或项目名称。
$(RootNameSpace)
包含应用程序的命名空间（如果有）。
$(IntDir)
为中间文件指定的相对于项目目录的目录路径。它解析为“中间目录”属性的值。
$(OutDir)
输出文件目录的路径，相对于项目目录。这解析为“输出目录”属性的值。
$(DevEnvDir)
Visual Studio .NET 的安装目录（定义形式：驱动器 + 路径）；包括尾部的反斜杠“\”。
$(InputDir)
输入文件的目录（定义形式：驱动器 + 路径）；包括尾部的反斜杠“\”。如果该项目是输入，则此宏等效于 $(ProjectDir)。
$(InputPath)
输入文件的绝对路径名（定义形式：驱动器 + 路径 + 基本名称 + 文件扩展名）。如果该项目是输入，则此宏等效于 $(ProjectPath)。
$(InputName)
输入文件的基本名称。如果该项目是输入，则此宏等效于 $(ProjectName)。
$(InputFileName)
输入文件的文件名（定义为基本名称 + 文件扩展名）。如果该项目是输入，则此宏等效于 $(ProjectFileName)。
$(InputExt)
输入文件的文件扩展名。它在文件扩展名的前面包括“.”。如果该项目是输入，则此宏等效于 $(ProjectExt)。
$(ProjectDir)
项目的目录（定义形式：驱动器 + 路径）；包括尾部的反斜杠“\”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6bef94abedc0d7c6625f3e62a786add/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e974ca5730bb2e570077b522e1d2a8/" rel="bookmark">
			[802.11]IEEE 802.11的帧格式介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IEEE 802.11的帧格式 1.1 IEEE 802.11是什么？ 802.11是国际电工电子工程学会（IEEE）为无线局域网络制定的标准。目前在802.11的基础上开发出了802.11a、802.11b、802.11g、802.11n、802.11ac。并且为了保证802.11更加安全的工作，开发出了802.1x、802.11i等协议
1.2 IEEE 802.11连接网络的过程 使用802.11协议的设备连接到无线网络需要三步
扫描（获得网络信息）
认证（确认身份）
连接（确定连接、交换数据）
1.3 IEEE 802.11的帧格式分类 802.11的帧格式类似于以太网，但是更加复杂。并且为了解决无线网络的缺陷，需要添加额外的功能。所有802.11的帧分为三类：
管理帧
控制帧
数据帧
其中的管理帧最为复杂
1.4 IEEE 802.11通用帧格式 802.11的帧格式十分复杂，但是大体上遵循一种格式
1、frame control 位
Protocol位：协议版本有连个bit构成，用以显示该帧所使用的MAC版本：0 type与subtype位：类型与次类型位用来指定所使用的帧类型
TO DS与from DSbit：这两个bit用来指示帧的目的地是否为传输系统
Morefragments bit：这个功能类似与IP的更多片位。如果上层的封包经过MAC分段的处理，最后一个分段除外，其他片段均将此位置1。
Retrybit：重传帧位。任何重传的帧会将此bit置位1，以协助接收端剔除重复的帧。
Powermanagement bit：802.11网卡为了提高电池的使用时间，通常可以关闭网卡以节省电力。此位用来指定传送端在完成目前的基本帧交换之后是否进入省电模式，1代表工作站即将进入省电模式，而0则代表工作站一直保持清醒状态。基站发出去的帧该位必为0。
Moredata bit：为服务处于省电模式的工作站，基站会将这些由“传输系统”接收而来的帧加以暂存。基站如果设定此位，代表至少有一个帧待传送给休眠的工作站。
Protectedframe bit：之前该位为WEP bit。如果帧受到链路层安全协议的保护，该位为1.
Orderbit：帧和帧片段可以按序传送，不过发送端与接收端的MAC必须付出额外的代价。一旦进行“严格依序”传送，该位为1。
2、duration/ID位
有三种可能形式
1、 设定NAV：当第15bit被设定为0时，duration/ID位会用来设定NAV，数值代表目前所进行的传输预计使用介质多少微秒。
2、 免竞争期间所传送的帧：14bit为0,15bit为1.其他位为0。因此duration/ID位为32768，这个值被解读为NAV。它让没有收到Beacon信标帧的工作站，得以公告免竞争期间，以便将NAV更新为适当的数值，避免干扰到免竞争传输。
3、 PS-poll帧（省电-轮询）：14bit为1,15bit为1。移动工作站可以关闭天线以达到省电的目的。休眠的工作站必须定期醒来。确保不至于丢失任何帧，从休眠状态醒来的工作站和必须发送一个PS-poll帧，以便从基站取得以前暂存的帧。此外，醒来的工作站会在PS-poll帧中加入连接识别码（association ID，简称AID），以显示其所隶属的BSS，AID值介于1-2007之间。
3、address位
一个802.11帧最多可以包含四个地址位。这些地址为经过编号，因为随着帧类型的不同，这些位的作用也有所差异。
基本上，address代表接收端，address2代表传送端，address3代表被接收端拿过来的过滤地址。
在基础网络中，第三个地址位会被接收端用来判定该帧是否属于其所连接网络。
注意：802.11规定工作站应该忽略那些不属于相同BSSID的帧，但大多数产品并未正确实现BSSID过滤功能，还是会将收到的所有帧传送给上层协议。
802.11所使用的定位模式，乃是依循其他IEEE802网络所使用的格式，包括以太网。地址位为48bit。如果传送给实际介质的第一个bit为0，代表是单一工作站（单播地址）。1代表组播地址。如果全为1代表广播。
目的地址：代表最后的接收端，是负责将帧交付上层协议处理的工作站
源地址：代表传输的来源。
接收端地址：代表负责处理该帧的无线工作站。
如果是无线工作站，接收端地址即为目的地址。
如果帧的目的地址是与基站连接的以太网节点，接收端即为基站的无线界面，目的地址可能是连接到以太网的一台路由器。
传送端地址：代表将帧传送至无线介质的无线界面。传送端地址通常只用于无线桥接
4、basicservice set ID（BSSID）
在基础网络里，BSSID（基本服务集标识）是基站无线界面所使用的MAC地址。而对等（adhoc）网络则会产生一个随机的BSSID，并将universal/localbit设定为1，以防止与其他官方指定的MAC地址产生冲突。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e974ca5730bb2e570077b522e1d2a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c3a95fc892e71b463a1c82bafc49e1b/" rel="bookmark">
			用Android Studio开启Android Device Monistor出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，在新电脑上安装了Android Studio等Android的开发环境，启动Android Device Monistor出现如下错误：
查看日志如下:
!SESSION 2017-12-12 15:45:03.525 -----------------------------------------------
eclipse.buildId=unknown
java.version=9.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Command-line arguments: -os win32 -ws win32 -arch x86_64 -data @noDefault
!ENTRY org.eclipse.osgi 4 0 2017-12-12 15:45:04.634
!MESSAGE Bundle reference:file:org.apache.ant_1.8.3.v201301120609/@4 not found.
!ENTRY org.eclipse.osgi 4 0 2017-12-12 15:45:04.634
!MESSAGE Bundle reference:file:org.apache.jasper.glassfish_2.2.2.v201205150955.jar@4 not found.
...........
!ENTRY org.eclipse.osgi 4 0 2017-12-12 15:45:05.196
!MESSAGE Application error
!STACK 1
java.lang.IllegalStateException: Unable to acquire application service. Ensure that the org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c3a95fc892e71b463a1c82bafc49e1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08138b52741713edec42194250a222e2/" rel="bookmark">
			jsp开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在前面的话: 处在临界点的知识，才是值得我们花大力气学习的知识
头一次写jsp页面区分 java代码/jsp代码/js代码 嘿嘿：你懂得
//java-获取用户信息 String sUserID=CurUser.getUserID(); //获取字段值 表名CTIC_USER_INFO 目标CNO BY userID String cno = Sqlca.getString(new SqlObject("Select CNO From CTIC_USER_INFO Where userID =:userID").setParameter("userID",sUserID));//座席号码 if(cno==null)cno=""; //jsp 代码 var sUserID = "&lt;%=CurUser.getUserID()%&gt;"; var params = {}; params.cno ="&lt;%=cno%&gt;"; params.cnos="&lt;%=cno%&gt;"; var tel="&lt;%=sWorkTel%&gt;"; //js 代码 function callWorkTel(){ Call(tel,params); } function doHangUp(){ HangUp(params); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b077f7a19d8372b666cadcc4bce00a33/" rel="bookmark">
			异步上传图片-ajaxSubmit提交-Poison
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异步上传是一个很蛋疼的问题，今天就来说说异步上传的故事
第一步 引入ajaxSubmit这个js插件
&lt;!--异步提交图片--&gt; &lt;script src="__PUBLIC__/js/jquery.ajaxSubmit.js"&gt;&lt;/script&gt; 这时候开始页面处理
&lt;input type="file" id="file" name="b_head" class="col-xs-6 ttee" onchange="changePhoto();" style="display: none" /&gt; &lt;label for="file"&gt; &lt;img &lt;if condition="$data.user_b_head neq ''"&gt;src="upload/{$data.user_b_head}"&lt;else/&gt;src="__PUBLIC__/image/ic_upload.png"&lt;/if&gt; id="new_pic" alt="" class="col-xs-6 img-responsive"/&gt; &lt;/label&gt; &lt;input type="hidden" name="user_b_head" id="head"/&gt; 讲file文件关联到img标签里面，点击img图片就能触发file进行选择文件
开始js处理
&lt;script&gt; $(".ttee").click(function () { $(this).wrap("&lt;form id='addPic' method='post' action="+"{:U('upload')}"+" enctype='multipart/form-data'&gt;&lt;/form&gt;"); }); function changePhoto() { $('#addPic').ajaxSubmit({ dataType:'json', success:function(data){ $('.ttee').unwrap(); $('#new_pic').attr('src',"upload/"+data.src); $("#head").val(data.id); }, error:function(err){ $('.ttee').unwrap(); console.log(JSON.stringify(err)); } }) } &lt;/script&gt; 这里不难看的出来 在点击的时候给父级包裹一层form表单
当图片选择完时候触发时间 进行插件的提交
$('.ttee').unwrap(); 这个则是进行移除form表单
后台接收和平常是一样一样的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b077f7a19d8372b666cadcc4bce00a33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16b4a0fa20aefe8cd14e98c39d5d39d/" rel="bookmark">
			javax.script详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口 Bindings A mapping of key/value pairs, all of whose keys are Strings. Compilable The optional interface implemented by ScriptEngines whose methods compile scripts to a form that can be executed repeatedly without recompilation. Invocable The optional interface implemented by ScriptEngines whose methods allow the invocation of procedures in scripts that have previously been executed. ScriptContext The interface whose implementing classes are used to connect Script Engines with objects, such as scoped Bindings, in hosting applications.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d16b4a0fa20aefe8cd14e98c39d5d39d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d34bbde60b5eb8beed17cbb21e1ccab/" rel="bookmark">
			安装API网关kong遇到的一些坑及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装API网关kong（https://getkong.org/）需要首先安装 OpenResty 和 PostgreSQL，这里就我安装的时候遇到的问题以及解决办法记录一下，供大家参考。
OpenResty安装很顺利，这里简单贴一下：
yum install -y pcre-devel openssl-devel gcc curl zlib zlib-devel ./configure --with-pcre-jit --with-ipv6 --with-http_realip_module --with-http_ssl_module --with-http_stub_status_module --with-http_v2_module make &amp;&amp; make install export PATH="$PATH:/usr/local/openresty/bin" 按照官网的方式用 yum 安装了 PostgreSQL：
yum install https://download.postgresql.org/pub/repos/yum/9.4/redhat/rhel-6-x86_64/pgdg-redhat94-9.4-2.noarch.rpm yum install postgresql94 yum install postgresql94-server service postgresql-9.4 initdb 这里竟然遇到了无法 initdb 的问题，并且只显示 Initing database [FAILED]，也没显示具体失败原因，没办法只能卸载了，然后用编译源码的方式安装，这里推荐安装 postgresql-9.5，因为9.4版在运行 kong migrations up 命令又莫名其妙的失败了：
贴一下postgresql编译安装过程：
wget https://ftp.postgresql.org/pub/source/v9.5.10/postgresql-9.5.10.tar.gz tar zxvf postgresql-9.5.10.tar.gz cd postgresql-9.5.10 ./configure make &amp;&amp; make install useradd -d /home/postgres -m postgres mkdir /usr/local/pgsql/data chown postgres /usr/local/pgsql/data su - postgres /usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data然后修改postgresql的登录验证配置文件 /usr/local/pgsql/data/pg_hba.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d34bbde60b5eb8beed17cbb21e1ccab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131af8e96430f9a668a1be891a4cbd07/" rel="bookmark">
			带你一起探究Retrofit 源码，让你不再畏惧Retrofit的面试提问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Retrofit，OkHttp，Okio Square 安卓平台网络层三板斧源码学习
基于 retrofit 2.4.0-SNAPSHOT 版本 retrofit github 地址 :
https://github.com/square/retrofit 复制代码 Retrofit 是 Square 安卓平台网络层三板斧最后一个项目，Retrofit 依赖 OkHttp 。Retrofit 让 http 网络请求更加清晰。
使用方式 一、声明一个接口，并用接口描述 request public interface GitHubService { @GET("users/{user}/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user); } 复制代码 二、方法上面的注释表示 request 的接口名 ,方法的返回类型就是 http 请求的返回值，方法的参数就是 http 的请求参数。 创建一个 Retrofit 客户端
Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .build(); GitHubService service = retrofit.create(GitHubService.class); 复制代码 Retrofit 创建的时候指定了 request 的接口地址，然后调用 retrofit.create 方法创建一个 GitHubService 实例。
三、发起网络请求 Call&lt;List&lt;Repo&gt;&gt; repos = service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131af8e96430f9a668a1be891a4cbd07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47470c19236ace4cb340214454e9a007/" rel="bookmark">
			python2中打印列表与字典内的中文字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发过程中，我们经常需要打印一些变量的值，便于调试。这个时候就会发现如果在列表与字典这些容器中，如果包含中文字符，不管是str类型，还是unicode类型，都打印不出来。如下：
&gt;&gt;&gt; print {'name': '张三'}
{'name': '\xe5\xbc\xa0\xe4\xb8\x89'}
&gt;&gt;&gt; print {'name': u'张三'}
{'name': u'\u5f20\u4e09'}
当然，我们很难自行脑补这些十六进制的意思，每次转移一下也很麻烦，有没有办法一劳永逸呢。
&gt;&gt;&gt; import sys,locale
&gt;&gt;&gt; sys.getdefaultencoding()
'ascii'
&gt;&gt;&gt; locale.getdefaultlocale()
('zh_CN', 'UTF-8')
&gt;&gt;&gt; sys.stdin.encoding
'UTF-8'
&gt;&gt;&gt; sys.stdout.encoding
'UTF-8'
首先让我们分析一下为什么无法打印包含中文的容器（dict list tuple）
&gt;&gt;&gt; data = {'严': 1, 2: ['如'], 3:'玉'}
&gt;&gt;&gt; data
{'\xe4\xb8\xa5': 1, 3: '\xe7\x8e\x89', 2: ['\xe5\xa6\x82']}
&gt;&gt;&gt; print data
{'\xe4\xb8\xa5': 1, 3: '\xe7\x8e\x89', 2: ['\xe5\xa6\x82']}
&gt;&gt;&gt; print data[3]
玉
上面data在key value中包含中文，而且也有嵌套的list，后文都使用这个data
可以看到不管是直接输出data（调用dict.__repr__），还是print data（调用dict.__str__）,都无法输出中文，而是像str.__repr__的结果。即调用容器的__str__时，事实上调用的是容器元素的__repr__方法，这个很好验证：
&gt;&gt;&gt; class OBJ(object):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47470c19236ace4cb340214454e9a007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb807036adb7cd1d14a7cb83bf5c55a9/" rel="bookmark">
			LSD（Line Segment Detector） 直线段检测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LSD的核心是像素合并于误差控制。利用合并像素来检测直线段并不是什么新鲜的方法，但是合并像素的方法通常运算量较大。LSD号称是能在线性时间（linear-time）内得到亚像素级准确度的直线段检测算法。LSD虽然号称不需人工设置任何参数，但是实际使用时，可以设置采样率和判断俩像素是否合并的方向差。我们知道，检测图像中的直线其实就是寻找图像中梯度变化较大的像素。因此，梯度和图像的level-line是LSD提及的两个基本概念。LSD首先计算每一个像素与level-line的夹角以构成一个level-line场。然后，合并这个场里方向近似相同的像素，这样可以得到一系列regions，这些 regions被称为 line support regions。如下图所示。
每一个line support region其实就是一组像素，它也是直线段（line segment）的候选。同时，对于这个line support region，我们可以观察它的最小外接矩形。直观上来讲，当一组像素构成的区域，特别细长时，那么这组像素更加可能是直线段。基于此，作者还统计了line support region的最小外接矩形的主方向。line support region中的一个像素的level-line 角度与最小外接矩形的主方向的角度差在容忍度（tolerance）2τ内的话，那么这个点被称作"aligned point"。作者统计最小外接矩形内的所有像素数和其内的alinedg points数，用来判定这个line support region是否是一个直线段。判定的准则使用的是“a contrario approach”和“Helmholtz principle”方法。在这里，aligned points的数量是我们感兴趣的信息。因此作者考虑如下假设：aligned points越多，那么region越可能是直线段。对于一副图像i和一个矩形r，记k(i,r)为aligned points的数量，n(r)为矩形r内的总像素数。那么，我们希望能够看到:
其中，Ntest是所有要考虑的矩形的数量。PH0是针对 contrario model H0的一个概率。I是在H0模型下的随机图像。在这篇文章中，作者用H0的模型，主要有以下两个属性：
（1）{LLA(j)}，其中j是像素，是一由一组随机变量组成；（2）LLA(j)在[0,2π]上均匀分布。
因此，判断一个像素是不是aligned point可以记作概率：
p = τ/π
这样，再通过误差控制，最终的直线段检测算法如下：
在上述算法中，还有两个要点我们没有解释。一是line support region具体是怎么得到了，二是怎样进行误差控制的。
前面我们说过，line support region是通过合并方向近似相同的像素得到。其实在这里，这个合并的过程更多的是依赖于区域生长算法。对于一个level-line 场LLA，种子像素P，和容忍度 τ。我们 可以通过简单的区域生长算法来得到line support region，具体的算法过程参考论文里给出的步骤吧。
至于NFA（the number of false alarms）计算，作者使用如下公式计算：
其中，N和M是采样过后图像的列和行，B(n,k,p)是一个二项分布。n依旧是矩形内所有像素数，k是矩形内的所有p-aligned point数。此处的p-aligned point是指和矩形的主方向在容忍度pπ下方向相同的像素。如果，那么可以认为结果有效。
在实际使用作者的源码时，可以调整lsd函数中的scale来调整图像采样率。此外，合并角度代码里默认是22.5度。图像越小，角度越小，得到的结果越少。不过当图像采样不同时，在同一位置可能得到差异特别大的直线段，这个暂时不知道是什么造成的。
一个比较迷人的结果：
LSD:一种直线检测算法简介 原文地址：http://blog.csdn.net/carson2005/article/details/9326847
申明：本文是笔者在阅读了相应的英文文献后，翻译整理所得，原文为：Rafael Grompone von Gioi, LSD: a Line Segment Detector
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb807036adb7cd1d14a7cb83bf5c55a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8473ae2cbab861f747c03de0ad137859/" rel="bookmark">
			TPS波动各种原因总结，做过的项目大概总结下有5中以上情况...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tps具有一定的波动性---&gt;找到tps波动原因：
①、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/574d0b01936e6750ddfd693eea1ed35d/" rel="bookmark">
			Nginx反向代理对后端服务器的容错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Nginx作为反向代理的时候，默认采用轮询方式，也就是一替一个的请求上游服务器。我们可以采用了ip_hash策略，使来自同一ip地址的人用同一台服务器响应。
如果上游服务器出现错误，比如404，500，等错误，上游服务器仍有一些服务是正常的，部服务不正常。这个时候Nginx并不会把上游服务器当做与故障来处理。
这时用户再次访问nginx的时候，经常出现404，500等错误。
解决方案 location / { proxy_pass http://ssc_backend; ... proxy_next_upstream error timeout invalid_header http_500 http_404; proxy_connect_timeout 2; } 在代理上游服务器的的location配置块中，加上上面最后的两句话，或者直接使用
proxy_next_upstream error timeout invalid_header http_500 http_404;
这句话代表，如果Nginx向后端服务器请求的时候，如果出现了错误，超时，指定错误的响应码的时候，再请求上游下一个服务器。
如此可防止上游某服务器只提供部分服务。
个人觉得，在配置反向代理的时候建议加上这句话。
proxy_next_upstream error timeout invalid_header http_500 http_404; 参考 Module ngx_http_proxy_module 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef822792ae200f309290e3518f1fdd1/" rel="bookmark">
			高斯消元法（二）：高斯消元法原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高斯消去法是一种常用的求解线性方程组的方法，通过逐次消元后，在回代求解，实际计算中常用的一种方法。
顺序消去法
将Ax=b按照从上至下、从左至右的顺序化为上三角方程组，中间过程不对矩阵进行交换，主要步骤如下。
STEP1:
将第2行至第n行，每行分别与第一行做运算，消掉每行第一个参数。公式如：
形成如下图所示新矩阵：
STEP2:
从新矩阵的a22开始（a22不能为0），以第二行为基准，将第三行至第n行分别与第二行做运算，消掉每行第二个参数。
公式如：，形成如下图所示新矩阵：
STEP K：
按照上述方法，当第k步运算时，公式为：
运算前后的矩阵为：
STEP (n-1):
经过 n-1 步，方程组也就转化为了我们希望得到的上三角方程组，如下：
再通过回代过程即可求解 X1至 Xn 的值。
顺序消去法计算量
消去过程：
回代过程： 总运算量：
顺序消去法虽然编程操作简单，但是存在以下两方面限制：
（1）每次运算时，必须保证对角线上的元素不为0（即运算中的分母不为0），否则算法无法继续进行。
（2）即使a(kk)的值不为零，但如果绝对值很小，由于第k次运算中a(kk)在分母位置，因此作除数会引起很大的误差，从而影响算法的稳定性。
正是由于顺序消去法会因为 a(kk) 的值过小而引入计算误差，为了减少计算过程中舍入误差对方程组求解的影星，因此是否可以选择绝对值尽可能大的 a(kk) 主元作为除数，基于这种思想就有了高斯消去法的改进型：列主元消去法 和 全主元消去法。
列（全）主元消去法
基本思想：
在第k步消元钱，找出k行下所有第k列元素最大的非零元素 a(pk)， 将第 p 行与第 k行进行整行交换，这样既不影响原方程的解，也可以将绝对值最大的a(pk)作为主元，放在处暑的位置上，尽可能减小引入误差。 全主元消除法与列主元消除法类似，只不过列主元消除法是从第k列中选取一个最大的元素，与第k行进行交换。 而全主元消除法释从第k行第k列开始的右下角矩阵中所有元素中选取一个最大的元素作为主元，同时交换p行与q列，从而保证稳定性。
如下面这个列主元消去法的例子：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f908e9cb74846547bc2189f180e5a9/" rel="bookmark">
			Oracle之唯一性约束(UNIQUE Constraint)用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://blog.csdn.net/jssg_tzw/article/details/40981393
1 目标 用示例演示如何创建、删除、禁用和使用唯一性约束。
2 什么是唯一性约束？ 唯一性约束指表中一个字段或者多个字段联合起来能够唯一标识一条记录的约束。联合字段中，可以包含空值。
注：在Oracle中，唯一性约束最多可以有32列。
唯一性约束可以在创建表时或使用ALTER TABLE语句创建。
3 唯一性约束和主键的区别 主键（Primary Key）：所有组成主键的列都不能包含空值。唯一性约束（Unique Constraint）：如果唯一性约束由多列组成，其中的部分列可以包含空值。Oracle中不容许在相同列上既创建主键又创建唯一性约束。 4 创建表时定义唯一性约束 1）语法： [sql] view plain copy CREATE TABLE table_name ( column1 datatype null/not null, column2 datatype null/not null, ... CONSTRAINT constraint_name UNIQUE (column1, column2,...,column_n) ); 2）基于单列的唯一性约束示例： [sql] view plain copy create table tb_supplier ( supplier_id number not null ,supplier_name varchar2(50) ,contact_name varchar2(50) ,CONSTRAINT tb_supplier_u1 UNIQUE (supplier_id)--创建表时创建唯一性约束 ); 3）基于多列的唯一性约束示例： [sql] view plain copy create table tb_products ( product_id number not null, product_name number not null, product_type varchar2(50), supplier_id number, CONSTRAINT tb_products_u1 UNIQUE (product_id, product_name) --定义复合唯一性约束 ); 5 使用ALTER TABLE语法创建唯一性约束 1）语法 [sql] view plain copy ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column1, column2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f908e9cb74846547bc2189f180e5a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a9c83c5e12fd6fbfbda8913fb49c173/" rel="bookmark">
			transform、transition方法详解及scale、zoom差异性说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS3变形处理 transform 可以对文字或图像的旋转、缩放、倾斜、移动进行变形处理。基准点为元素的中心点，可以通过transform-origin 修改基准点，如 transform-origin: left bootom;
旋转 使用rotate方法来实现文字或图像的旋转处理，在参数中指定旋转角度。
/*顺时针旋转30°*/ transform: rotate(30deg); 缩放 使用scale方法来实现文字或图像的缩放处理，在参数中指定缩放倍率。
/*水平方向、垂直方向缩小一半*/ transform: scale(0.5); /*水平方向缩小一半、垂直方向放大一倍*/ transform: scale(0.5, 2); 倾斜 使用skew方法来实现文字或图像的倾斜处理，在参数中分布指定水平方向上的倾斜角度与垂直方向上的倾斜角度。
/*水平方向、垂直方向倾斜30°*/ transform: skew(30deg, 30deg); /*只在水平方向倾斜30°*/ transform: skew(30deg); 移动 使用translate方法来实现文字或图像的移动处理，在参数中分布指定水平方向上的移动距离与垂直方向上的移动距离。
/*水平方向、垂直方向移动50px*/ transform: translate(50px, 50px); /*只在水平方向移动50px*/ transform: translate(50px); CSS3动画过渡 Transitions 将元素的某个属性从一个属性值在指定的时间内平滑过渡到另一个属性值来实现动画功能。
transition: property duration timing-function delay; /*也可以单独书写*/ transition-property: property; transition-duration: duration; transition-timing-function: timing-function; transition-delay: transition-delay; property：表示对哪个属性进行平滑过渡duration：表示在多久时间内完成属性值的平滑过渡timing-function：表示通过什么方法进行平滑过渡，缓动函数delay： 表示指定变换动画特效延迟多久后才开始执行（当触发特效后，经过delay属性指定的延迟时间后才真正开始执行特效，单位秒或者毫秒） 支持多个属性 background-color: #ff0; color: #000; width: 300px; transition: background-color 1s linear, color 2s linear, width 3s linear; scale和zoom区别 zoom的缩放是相对于左上角的；而scale默认是居中缩放，可以通过transform-origin修改基准点zoom的缩放改变了元素占据的空间大小；而scale的缩放占据的原始尺寸不变，页面布局不会发生变化（下面重点提及）对文字的缩放规则不一致。zoom缩放依然受限于最小12像素中文大小限制；而scale就是纯粹的对图形进行比例控制，文字50%原来尺寸兼容性问题。firefox下不支持zoom；scale针对IE9+ 占据空间大小 页面容器默认3840px * 2160px，通过监听onresize来动态控制缩放比例（这通常在大屏展示情况要使用），1920 &lt; 当前尺寸&lt; 2880时缩放0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a9c83c5e12fd6fbfbda8913fb49c173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68985784ccfb0da178df5bcf30b27cc0/" rel="bookmark">
			SQL的inner join、left join、right join、full  join、union、union all的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建两张表：person_a 和 person_b 两张表中有相同的name字段，分别使用inner join、left join、right join、full outer join、union、union all来进行查询看看结果。
1.inner join(内连接) select * from person_a A inner join person_b B on A.name = B.name 产生的结果是person_a表和person_b表中相同的字段
2.full join(全连接) select * from person_a A full join person_b B on A.name = B.name 结果产生的是person_a和person_b的所有内容，没有匹配到的记录显示为空值(null) 另外需要注意的是：MySQL不支持这种语法的全连接查询
3.left join 左外连接 select * from person_a A left join person_b B on A.name = B.name 结果产生的是person_a表的所有字段和person_b表中name字段相同的数据，不相同的字段(没匹配到的)显示空值(null)
4.right join 右外连接 5.union与union all union操作符用于合并两个或多个select语句的结果集 注意，union内部的select语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条select中的列顺序也必须相同，union只选取记录，而union all会列出所有记录。 ①select name from person_a union select name from person_b ②select name from person_a union all select name from person_b ③如果是查表中所有字段会将id一并显示 因为两张表中的id并不相同 select * from person_a union select * from person_b 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c0ce7d1af905e0954edc49fc3e66b2a/" rel="bookmark">
			部署.net core到CentOS系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装虚拟机
VMware Workstation Pro
安装Linux(CentOS)系统
安装时启动网络
安装桌面程序
1. 开放端口命令：/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT
2.保存：/etc/rc.d/init.d/iptablessave
3.重启服务：/etc/init.d/iptablesrestart
4.查看端口是否开放：/sbin/iptables-L -n
查看进程：ps -ef | grep supervisord
干掉进程：kill id
安装Nginx
开启命令：/usr/local/nginx/sbin/nginx -c/usr/local/nginx/conf/nginx.conf
安装守护进程(Supervisor)
安装参考网址：https://www.cnblogs.com/sss-justdDoIt/p/5631513.html
指定配置文件地址启动命令：supervisord -c /etc/supervisord.conf
启动某个网站命令：supervisorctl stop TestCoreLinux
停止某个网站命令：supervisorctl start TestCoreLinux
[program:TestCoreLinux]
command=dotnet TestCoreLinux.dll
directory=/usr/workspace/TestCore/
autorestart=true
autostart=true
stderr_logfile=/var/log/TestCoreLinux.err.log
stdout_logfile=/var/log/TestCoreLinux.out.log
environment=ASPNETCORE_ENVIRONMENT=Production
user=root
stopsignal=INT
startsecs=1
安装DOTNET环境
参考网址：https://www.microsoft.com/net/learn/get-started/linuxcentos
安装mssql2017数据库
参考网址：http://blog.csdn.net/cmzsteven/article/details/78161516?locationNum=10&amp;fps=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7c5c062de076c296bb62247457ae09e/" rel="bookmark">
			使用sklearn中的神经网络模块MLPClassifier处理分类问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MLPClassifier（多层感知器分类器） 一.首先简单使用sklearn中的neural_network,实例1:
#coding=utf-8 ''' Created on 2017-12-7 ''' from sklearn.neural_network import MLPClassifier X = [[0., 0.], [1., 1.]] y = [0, 1] mlp = MLPClassifier(solver='lbfgs', alpha=1e-5,hidden_layer_sizes=(5, 5), random_state=1) mlp.fit(X, y) print mlp.n_layers_ print mlp.n_iter_ print mlp.loss_ print mlp.out_activation_ # 输出分别为 # 4 # 15 # 0.000141233472537 # logistic 二.MNIST数据集的下载 MNIST是一些手写数字的图片，通过http://www.iro.umontreal.ca/~lisa/deep/data/mnist/mnist.pkl.gz下载数据集。 三.使用神经网络训练MNIST数据集并实现分类，实例2
#coding=utf-8 ''' Created on 2017-12-6 ''' from sklearn.neural_network import MLPClassifier from sklearn.datasets import fetch_mldata import numpy as np import pickle import gzip # 加载数据 # mnist = fetch_mldata("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7c5c062de076c296bb62247457ae09e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/340e71917985187d9574b691edf10027/" rel="bookmark">
			BeanUtils中copyProperties的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BeanUtils中copyProperties的作用是将一个对象中的属性值赋值（拷贝）给另一个对象中对应的属性，并且对象之间可以没有任何联系。其中赋值成功的属性对应的属性名和属性类型必须相同，否则对应的属性值不会从一个对象赋值给另一个对象，但是此时不影响其他属性值的拷贝。具体如下所示。
1、实体类
public class Model01 { private String name; private int age; private String city; @Override public String toString() { return "Model01{" + "name='" + name + '\'' + ", age=" + age + ", city='" + city + '\'' + '}'; } } public class Model02 { private String name; private String age; private String city; @Override public String toString() { return "Model02{" + "name='" + name + '\'' + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/340e71917985187d9574b691edf10027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef5f60ef2c88b5490b8e51ef002787f/" rel="bookmark">
			ubunti16.04安装GPU tensor flow预见的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先安装CUDA8以及cuDNN5.1，安装方法与环境配置在CSDN百度，资料很多
问题1：pip安装tensor flow时：
export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.11.0-cp27-none-linux_x86_64.whl
sudo pip install --upgrade $TF_BINARY_URL
出现错误如下：
ReadTimeoutError: HTTPSConnectionPool(host='storage.googleapis.com', port=443): Read timed out.
解决办法: 加大超时时间:
sudo pip --default-timeout=100 install --upgrade $TF_BINARY_URL
安装成功
问题二：安装python2版本的tensorflow时，切换系统默认的python版本
update-alternatives --config python
运行tensorflow深度学习google框架6章迁移学习案例出现如下问题：
问题1：
[libprotobuf ERROR google/protobuf/io/coded_stream.cc:207] A protocol message was rejected because it was too big (more than 67108864 bytes). To increase the limit (or to disable these warnings), see CodedInputStream::SetTotalBytesLimit() in google/protobuf/io/coded_stream.h.
Traceback (most recent call last):
File "qianyi.py", line 262, in &lt;module&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ef5f60ef2c88b5490b8e51ef002787f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d4ca6fbd88258c0bc3eb4d80a3826a/" rel="bookmark">
			08、PHP会不会过几年不流行了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、这句话，当年,.net的程序员08年就预测PHP会很快被替代，会不流行了。但是过去快10年了，PHP依然是Web后端最流行的语言，反倒是很多某些语言不行了。
2、由于现在Web开发以及手机App、微信、小程序等的大火，PHP依然是首选开发语言（例如从权威技术网站w3techs.com2017年7月28日的统计来看，PHP被82.7%的网站使用），而且随着PHP7的来临以及开源项目的成熟，PHP依然还会是Web开发中的第一语言。 3、广大公司是不会轻言改变公司使用了多年的编程语言，因为这涉及到很大的成本。一旦彻底改变，这家公司积累多年来的代码，和培养起来的人才，等同消失了。从这个角度来看，PHP流行趋势势必还会延长很长时间。虽然有些语言的开发者发出了唱衰PHP的声音，但从目前来看，在web端，Node.js、 GO 、 Python 、 Ruby 等语言能否和php一样被主流公司广泛使用,还是存在疑问的，更别说追上PHP了。 4、PHP是一门开源的语言，会有很多人贡献代码，去弥补PHP的缺点！比如Swoole框架的出现，就弥补了PHP不能常驻内存Server程序的缺点。比如React Native框架，弥补了之前PHP只能做APP数据传输而不能做app开发。请记住，开源的东西才是最有生命力的，不容易被取代。
转载于:https://www.cnblogs.com/xin880/p/7998541.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/708ed379ca581a6648aacd58729fb74c/" rel="bookmark">
			基于图的图像分割（Graph-Based Image Segmentation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍
基于图的图像分割（Graph-Based Image Segmentation），论文《Efficient Graph-Based Image Segmentation》，P. Felzenszwalb, D. Huttenlocher，International Journal of Computer Vision, Vol. 59, No. 2, September 2004
论文下载和论文提供的C++代码在这里。
Graph-Based Segmentation是经典的图像分割算法，其作者Felzenszwalb也是提出DPM（Deformable Parts Model）算法的大牛。
Graph-Based Segmentation算法是基于图的贪心聚类算法，实现简单，速度比较快，精度也还行。不过，目前直接用它做分割的应该比较少，很多算法用它作垫脚石，比如Object Propose的开山之作《Segmentation as Selective Search for Object Recognition》就用它来产生过分割（over segmentation）。
二、图的基本概念
因为该算法是将图像用加权图抽象化表示，所以补充图的一些基本概念。
1、图
是由顶点集V（vertices）和边集E（edges）组成，表示为G=(V, E)，顶点v∈V，在论文即为单个的像素点，连接一对顶点的边(vi, vj)具有权重w(vi, vj)，本文中的意义为顶点之间的不相似度（dissimilarity），所用的是无向图。
2、树
特殊的图，图中任意两个顶点，都有路径相连接，但是没有回路。如下图中加粗的边所连接而成的图。如果看成一团乱连的珠子，只保留树中的珠子和连线，那么随便选个珠子，都能把这棵树中所有的珠子都提起来。
如果顶点i和h这条边也保留下来，那么顶点h,i,c,f,g就构成了一个回路。
3、最小生成树（minimum spanning tree）
特殊的树，给定需要连接的顶点，选择边权之和最小的树。
论文中，初始化时每一个像素点都是一个顶点，然后逐渐合并得到一个区域，确切地说是连接这个区域中的像素点的一个MST。如下图，棕色圆圈为顶点，线段为边，合并棕色顶点所生成的MST，对应的就是一个分割区域。分割后的结果其实就是森林。
三、相似性
既然是聚类算法，那应该依据何种规则判定何时该合二为一，何时该继续划清界限呢？对于孤立的两个像素点，所不同的是灰度值，自然就用灰度的距离来衡量两点的相似性，本文中是使用RGB的距离，即
当然也可以用perceptually uniform的Luv或者Lab色彩空间，对于灰度图像就只能使用亮度值了，此外，还可以先使用纹理特征滤波，再计算距离，比如先做Census Transform再计算Hamming distance距离。
四、全局阈值 &gt;&gt; 自适应阈值，区域的类内差异、类间差异
上面提到应该用亮度值之差来衡量两个像素点之间的差异性。对于两个区域（子图）或者一个区域和一个像素点的相似性，最简单的方法即只考虑连接二者的边的不相似度。如下图，已经形成了棕色和绿色两个区域，现在通过紫色边来判断这两个区域是否合并。那么我们就可以设定一个阈值，当两个像素之间的差异（即不相似度）小于该值时，合二为一。迭代合并，最终就会合并成一个个区域，效果类似于区域生长：星星之火，可以燎原。
举例说明：
对于上右图，显然应该聚成上左图所示的3类：高频区h,斜坡区s,平坦区p。
如果我们设置一个全局阈值，那么如果h区要合并成一块的话，那么该阈值要选很大，但是那样就会把p和s区域也包含进来，分割结果太粗。如果以p为参考，那么阈值应该选特别小的值，那样的话p区是会合并成一块，但是h区就会合并成特别特别多的小块，如同一面支离破碎的镜子，分割结果太细。显然，全局阈值并不合适，那么自然就得用自适应阈值。对于p区该阈值要特别小，s区稍大，h区巨大。
先来两个定义，原文依据这两个附加信息来得到自适应阈值。
一个区域内的类内差异Int(C)：
可以近似理解为一个区域内部最大的亮度差异值，定义是MST中不相似度最大的一条边。
俩个区域的类间差异Diff(C1, C2)：
即连接两个区域所有边中，不相似度最小的边的不相似度，也就是两个区域最相似的地方的不相似度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/708ed379ca581a6648aacd58729fb74c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0927a3724ea177845b69ab9354748f61/" rel="bookmark">
			ffmpeg 提取关键帧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考key-frame 关键帧，是指动画中一个绘图，定义任何的起点和终点平滑过渡，一系列关键帧定义了观看者将看到的运动，而关键帧在电影，视频或动画上的位置定义了运动的时间。
获取方法，参考视频关键帧提取，
ffmpeg -i video_name.mp4 -vf select='eq(pict_type\,I)' -vsync 2 -s 1920*1080 -f image2 core-%02d.jpeg 各个参数解释: -i :输入文件，这里的话其实就是视频, -vf:是一个命令行，表示过滤图形的描述, 选择过滤器select会选择帧进行输出：包括过滤器常量 pict_type和对应的类型:PICT_TYPE_I 表示是I帧，即关键帧。 -vsync 2:阻止每个关键帧产生多余的拷贝 -f image2 name_%02d.jpeg:将视频帧写入到图片中，样式的格式一般是: “%d” 或者 “%0Nd” -s:分辨率，1920*1080
这样保存下来的关键帧的命名顺序是从1开始的，数字表示第几个关键帧。需要保存关键帧在原始视频中的帧的位置，参考Extracting the index of key frames from a video using ffmpeg,
ffprobe -select_streams v -show_frames -show_entries frame=pict_type -of csv bbb480.avi | grep -n I | cut -d ':' -f 1 &gt; frame_indices.txt 会生成一个 frame_indices.txt 的文件，其中保存的即为关键帧在视频中的帧的索引位置。 再将生成的关键帧与索引对应起来：
ls -1 core*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0927a3724ea177845b69ab9354748f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ccae04ba3d043e1a1f444f976a95d89/" rel="bookmark">
			java基础之变量覆盖？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人还在想这样一个问题：java的变量能被覆盖吗？
其实java的覆盖是指方法来说的，变量是不能覆盖的。
如下：
public class Test {
public static void main(String args[]) {
A a = new B();
System.out.println(a.i);
System.out.println(a.get());
}
public class B extends A {
public int i = -6;
public B() {
System.out.println("B().");
}
@Override
public int get() {
System.out.println("get B.");
return i;
}
}
public class A {
public int i = 12;
public A(){
System.out.println("A().");
}
public int get() {
System.out.println("get A.");
return i;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ccae04ba3d043e1a1f444f976a95d89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5854f14789729bc8920f915c28a0d596/" rel="bookmark">
			MySql常用函数大全讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL数据库中提供了很丰富的函数。MySQL函数包括数学函数、字符串函数、日期和时间函数、条件判断函数、系统信息函数、加密函数、格式化函数等。通过这些函数，可以简化用户的操作。例如，字符串连接函数可以很方便的将多个字符串连接在一起。在这一讲中将讲解的内容包括： 数学函数
字符串函数
日期和时间函数
条件判断函数
系统信息函数
加密函数
格式化函数 MySQL函数是MySQL数据库提供的内部函数。这些内部函数可以帮助用户更加方便的处理表中的数据。本小节中将简单介绍MySQL中包含哪几类函数，以及这几类函数的的使用范围和作用。MySQL函数包括数学函数、字符串函数、日期和时间函数、条件判断函数、系统信息函数、加密函数等。SELECT语句及其条件表达式都可以使用这些函数。同时，INSERT 、UPDATE、DELECT语句及其条件表达式也可以使用这些函数。例如，表中的某个数据是负数，现在需要将这个数据显示为正数。这就可以使用绝对值函数。从上面可以知道，MySQL函数可以对表中数据进行相应的处理，以便得到用户希望得到的数据。这些函数可以使MySQL数据库的功能更加强大。
一、数学函数 数学函数是MySQL中常用的一类函数。主要用于处理数字，包括整型、浮点数等。数学函数包括绝对值函数、正弦函数、余弦函数、获取随机数的函数等。
ABS(X):返回X的绝对值
select ABS(-32); MOD(N,M)或%:返回N被M除的余数。 select MOD(15,7); select 15 % 7; FLOOR(X):返回不大于X的最大整数值。 select FLOOR(1.23); select FLOOR(-1.23); CEILING(X):返回不小于X的最小整数值。 select CEILING(1.23); select CEILING(-1.23); ROUND(X) :返回参数X的四舍五入的一个整数。 select ROUND(1.58); select ROUND(-1.58); 二、字符串函数 ASCII(str):返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL。 select ASCII('2'); select ASCII(2); select ASCII('dx') CONCAT(str1,str2,...):返回来自于参数连结的字符串。如果任何参数是NULL，返回NULL。可以有超过2个的参数。一个数字参数被变换为等价的字符串形式。 select CONCAT('My', 'S', 'QL'); select CONCAT('My', NULL, 'QL'); select CONCAT(14.3); LENGTH(str):返回字符串str的长度。 select LENGTH('text'); LOCATE(substr,str):返回子串substr在字符串str第一个出现的位置，如果substr不是在str里面，返回0. select LOCATE('bar', 'foobarbar'); select LOCATE('xbar', 'foobar'); INSTR(str,substr):返回子串substr在字符串str中的第一个出现的位置。 select INSTR('foobarbar', 'bar'); select INSTR('xbar', 'foobar'); LEFT(str,len):返回字符串str的最左面len个字符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5854f14789729bc8920f915c28a0d596/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916c91ba99f7b58cf56a86dd0a08da8b/" rel="bookmark">
			Latex——natbib宏包使用说明中文版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://hi.baidu.com/lukespring/blog/item/d982973028495390a8018e57 .html 宏包加载\usepackage[option]{natbib}
具体的 option 有
round: (default) 使用圆括号square: 使用方括号curly: 使用花括号angle: 使用尖括号colon: (default) 用引号分隔多个引用comma: 用逗号分隔多个引用authoryear: (default) 使用作者--年引用形式numbers: 使用编号引用形式super: 使用 Nature 那样的上标编号引用sort: 多个引用按照首字母排序sort&amp;compress: 除排序外，多个引用可以合并 (如 3-6, 15)longnamesfirst: 多个作者的文献第一次被引用时列出所有作者，以后的引用可以缩写为 et al.sectionbib: 重定义了 \thebibliography 使用 \section* 而不是 \chapter*。这样使用 chapterbib 宏包时，参考文献名称为 section 一级nonamebreak: 在一行排版所有作者名字，这可能引起 overfull hbox 警告但是消除了跨行的 hyperref 问题 引用命令 \citet{jon90} Jones et al. (1990) \citet[chap. 2]{jon90} Jones et al. (1990, chap. 2) \citep{jon90} (Jones et al., 1990) \citep[chap. 2]{jon90} (Jones et al., 1990, chap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/916c91ba99f7b58cf56a86dd0a08da8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/709fc08fecc6ba0e5960b3b9f33f2300/" rel="bookmark">
			让Vue的v-for支持迭代器遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事情的缘由 在写一个项目的时候希望使用Map来进行遍历，然后我取出了Map的keys，keys是一个Map Iterator（迭代器，ES6引入的Symbol.iterator）类型，这时我尝试使用v-for来对迭代器进行遍历，当然我的期望是能够遍历出来。 我们都知道vue的v-for提供了两种遍历方式，
v-for="item in items" v-for="item of items" 复制代码 而js中可以使用
for (index in items) for (item of items) // 这种写法支持对迭代器的遍历 复制代码 这时我不禁就想，既然如此，v-for当中of的遍历方式应该是支持迭代器的遍历的，但是事实尝试下来是不可以的，那么为什么不可以呢，然后就去翻查了一下Vue的源码，从中找到了这么一段代码。
/** * Runtime helper for rendering v-for lists. */ function renderList ( val, render ) { var ret, i, l, keys, key if (Array.isArray(val) || typeof val === 'string') { ret = new Array(val.length) for (i = 0, l = val.length; i &lt; l; i++) { ret[i] = render(val[i], i) } } else if (typeof val === 'number') { ret = new Array(val) for (i = 0; i &lt; val; i++) { ret[i] = render(i + 1, i) } } else if (isObject(val)) { keys = Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/709fc08fecc6ba0e5960b3b9f33f2300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d935df3ce87700f498086b2a03c47d91/" rel="bookmark">
			11-Thrift_JavaScript的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thrift_JavaScript使用 Thrift的JavaScript端一般只用来制作Client，Server需要使用Node.js等其他语言来完成。 Server端 参考上一篇的服务，着重Multiple的服务（其他的Processor比这个简单）。 要求：（否则JS无法解析） Json Protocol打包协议Http Transport通信MultipleProtocol/Processer（非必需） Client端 JS版也依赖Thrift的js库，下载地址：Url 1. js源代码 同其他语言，使用thrift编译工具，将xxx.thrift文件编译为xx.js文件，加上thrift.js文件，一块引入HTML文件中即可。 参考命令：thrift -o . -out ./robot --gen js Robot.thrift 2. 具体实现Demo &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Thrift Robot js client Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Robot接口测试~&lt;/h1&gt; &lt;textarea id="id_msg"&gt;你好，我叫小薇&lt;/textarea&gt; &lt;br/&gt; &lt;button onclick="javascripts:btn_msg();"&gt;发送&lt;/button&gt; &lt;!-- thrift自身的库 --&gt; &lt;script src="thrift.js" type="text/javascript"&gt;&lt;/script&gt; &lt;!-- thrift生成 --&gt; &lt;script src="Robot_types.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="Audio.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script&gt; var mp = new Thrift.Multiplexer(); var transport = new Thrift.Transport("http://127.0.0.1:9000/robot"); var protocol = new Thrift.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d935df3ce87700f498086b2a03c47d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08b849c26cb472c02d7a546974d1483/" rel="bookmark">
			ubuntu 关闭开机启动服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当用户使用sudo apt-get install安装完apache和mysql之后，这些服务默认是开机启动的，但是有的时候需要关闭这些服务的开机启动。 首先普及一个概念，以下转自维基百科： 运行级别（Runlevel）指的是Unix或者Linux等类Unix操作系统下不同的运行模式。运行级别通常分为7等，分别是从0到6，但如果必要的话也可以更多。
例如在大多数linux操作系统下一共有如下6个典型的运行级别：
0 停机 1 单用户，Does not configure network interfaces, start daemons, or allow non-root logins 2 多用户，无网络连接 Does not configure network interfaces or start daemons 3 多用户，启动网络连接 Starts the system normally. 4 用户自定义 5 多用户带图形界面 6 重启 在Debian Linux中2－5这四个运行级别都集中在级别2上。这个级别也是系统预设的正常运行级别。
（注：对于这些运行级别我们不必太过纠结与到底什么意思，只需要知道在Debian/Ubuntu（Ubuntu是Debian的分支）Linux中默认都是在级别(Runlevel)2启动的）
在Debian Linux中，下列路径对应不同的运行级别。当系统启动时，通过其中的脚本文件来启动相应的服务。 /etc/rc0.d Run level 0 /etc/rc1.d Run level 1 /etc/rc2.d Run level 2 /etc/rc3.d Run level 3 /etc/rc4.d Run level 4 /etc/rc5.d Run level 5 /etc/rc6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08b849c26cb472c02d7a546974d1483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c513d2a3871a684a9e97f4a527ffbb4e/" rel="bookmark">
			VTK读取DICOM医学图片进行体绘制的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意的是：VTK中不同的vtkVolumeMapper支持不同的数据类型。比如vtkVolumeRayCastMapper和vtkVolumeTextureMapper2D只能支持单分组VTK_UNSIGNED_CHAR和VTK_UNSIGNED_SHORT类型数据，因此当读入其他类型的图像数据时，需要对数据进行转换，比如采用vtkImageCast或者vtkImageScale:而vtkVolumeTextMapper3D则支持任意数据类型，但是必须是单分组数据或者多元独立数据。vtkFixedPointVolumeRayCastMapper灵活性最高，可以支持所有类型数据，最高四元数据。
使用vtkFixedPointVolumeRayCastMapper类 #include "vtkRenderer.h" #include "vtkRenderWindow.h" #include "vtkRenderWindowInteractor.h" #include "vtkActor.h" #include "vtkSmartPointer.h" #include "vtkProperty.h" #include "vtkCamera.h" #include "vtkDICOMImageReader.h" #include "vtkImageCast.h" #include "vtkPiecewiseFunction.h" #include "vtkColorTransferFunction.h" #include "vtkVolumeProperty.h" #include "vtkVolumeRayCastCompositeFunction.h" #include "vtkVolumeRayCastMapper.h" #include "vtkVolume.h" #include "vtkAutoInit.h" #include "vtkFixedPointVolumeRayCastMapper.h" VTK_MODULE_INIT(vtkRenderingOpenGL); VTK_MODULE_INIT(vtkInteractionStyle); VTK_MODULE_INIT(vtkRenderingFreeType); VTK_MODULE_INIT(vtkRenderingVolumeOpenGL); int main() { std::string str = "F:\\CT3"; vtkSmartPointer&lt;vtkDICOMImageReader&gt; reader = vtkSmartPointer&lt;vtkDICOMImageReader&gt;::New(); reader-&gt;SetDirectoryName(str.c_str()); reader-&gt;Update(); vtkSmartPointer&lt;vtkPiecewiseFunction&gt; opacityFun = vtkSmartPointer&lt;vtkPiecewiseFunction&gt;::New(); opacityFun-&gt;AddPoint(120,0.0); opacityFun-&gt;AddPoint(250,1.0); opacityFun-&gt;AddPoint(520,1.0); opacityFun-&gt;AddPoint(650,0.0); vtkSmartPointer&lt;vtkColorTransferFunction&gt; TransferFun = vtkSmartPointer&lt;vtkColorTransferFunction&gt;::New(); TransferFun-&gt;AddRGBPoint(120, 255 / 255.0, 98 / 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c513d2a3871a684a9e97f4a527ffbb4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6c0d24069e90a16ae8f8d16e12971c/" rel="bookmark">
			Latex中bib文件制作(参考文献制作)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文参考文献的组织是一个挺麻烦的事情，刚开始写论文的时候自己很多东西不知道，参考文献在自己组织，自己填写各个item，真是麻烦啊，网搜上了搜，还真找到一些好方法，google的是自己常用的，不知道还有哪些方法大家可以共享啊。
一、用Google来做Latex的bib文件
1. 打开scholar.google.com
2. 定制 Scholar Preferences-&gt;Bibliography Manager -&gt;Show links to import citations int o BibTeX (选中这个)
3. search something like "multicast" in the scholar.google.com, in the result list, kick "Import into BibTeX" copy the text to bibtex database directly,
4 直接去编译，不用任何修改
二、 LaTeX技巧心得23:BIBTeX制作参考文献 23BibTeX 是一种格式和一个程序, 用于协调LaTeX的参考文献处理.
BibTeX 使用数据库的的方式来管理参考文献. BibTeX 文件的后缀名为 .bib . 先来看一个例子
@article{name1, author = {作者, 多个作者用 and 连接}, title = {标题}, journal = {期刊名}, volume = {卷20}, number = {页码}, year = {年份}, abstract = {摘要, 这个主要是引用的时候自己参考的, 这一行不是必须的} }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6c0d24069e90a16ae8f8d16e12971c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dd2d4a2dfd7af6d98c98ac73a7b094a/" rel="bookmark">
			Ubuntu(deepin)系统下常用基础命令（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、apt-get中常用命令 packagename指代为软件包的名称。 所有命令必须添加sudo，否则没有权限
在修改/etc/apt/sources.list或/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。
apt-get update
安装一个新软件包（参见下文的aptitude）
apt-get install packagename
卸载一个已安装的软件包（保留配置文档）
apt-get remove packagename
卸载一个已安装的软件包（删除配置文档）
apt-get remove –purge packagename
删除包及其依赖的软件包
apt-get autoremove packagename
删除包及其依赖的软件包+配置文件，比上面的要删除的彻底一点
apt-get autoremove –purge packagname
有些软件很难卸载，而且还阻止了别的软件的应用，就能够用这个，但是有点冒险。
dpkg –force-all –purge packagename
apt会把已装或已卸的软件都备份在硬盘上，所以假如需要空间的话，能够让这个命令来删除您已卸载掉的软件的备份。
apt-get autoclean
这个命令会把安装的软件的备份也删除，但是这样不会影响软件的使用。
apt-get clean
可以使用这条命令更新软件包，apt-get upgrade不仅可以从相同版本号的发布版中更新软件包，也可以从新版本号的发布版中更新软件包，尽管实现后一种更新的推荐命令为apt-get dist-upgrade。
apt-get upgrade
将系统升级到新版本。
apt-get dist-upgrade
在软件包列表中搜索字符串。
apt-cache search string
周详查看已安装或可用的软件包。和apt-get类似，aptitude能够通过命令行方式调用，但仅限于某些命令——最常见的有安装和卸载命令。 由于aptitude比apt-get了解更多信息，能够说他更适合用来进行安装和卸载。
aptitude
显示软件包信息。
apt-cache showpkg packagename
打印可用软件包列表。
apt-cache dumpavail
显示软件包记录，类似于dpkg –print-avail。
apt-cache show pkgs
打印软件包列表中任何软件包的名称。
apt-cache pkgnames
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dd2d4a2dfd7af6d98c98ac73a7b094a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df74b2b21480dd339f5cb1792701b376/" rel="bookmark">
			尝试读取或写入受保护的内存。这通常指示其他内存已损坏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用ReportViewer打印。 程序运行后进入打印设置，提示 :“尝试读取或写入受保护的内存。这通常指示其他内存已损坏。 原因是： 项目生成的目标平台是Anycpu， 选择x86后就OK 了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e4171c71938d6c3d2eac385579cfff4/" rel="bookmark">
			必备数学知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章 必备数学知识 在这一章我会介绍一些必不可少的数学知识，其中一些可能贯穿了整本书，不学透其中一些你也许会寸步难行。
在这一章开始我们都会按照“教学内容”、“例题精讲”、“编程开发”、“习题”这几部分来组织文章，使读者可以循序渐进学习。可能会有人对这种“小学式”的教学模式嗤之以鼻，但是机器学习是一门严谨的学科，它一点也不轻松，也不会那么容易学习，要想让它为你所用，没有捷径可走，一个定理一个定理地推导，一行代码一行代码地敲，才能牢牢掌握。
教学内容 1、张量 张量（Tensor），从它的英文名Tensor来说你也许听过Google大名鼎鼎的深度学习库“TensorFlow”。
要理解张量就必须理解基向量，对于基向量我有个自己的理解。比如我们熟知的 XYZ 坐标系中基向量的大小是1方向分别是 XYZ ，那么， (1,1,0) 就表示先沿 X 方向移动1个单位，再向Y方向移动1个单位。
这对应到现实里是什么？比如你要从木樨地去中关村，先搭1号线3站，再搭10号线5站，如果每站长度是单位大小，不同线的地铁是基向量方向，那么从木樨地去中关村就是 (3,5) 。
那么张量，可以简单地看作高维矩阵，比如我们平时接触的是 m×n 的矩阵，现在有一个3阶张量，那么它对应的就是三维矩阵，顺便一提，张量阶和我们熟知的数学量对应如下：
张量数学量0阶张量标量1阶张量向量2阶张量矩阵 为什么需要引入张量呢？就是为了获取“更丰富的表达能力”。举个例子，你需要记录你某个状态下的体重，如果只能用标量，那么你只有一个值，体重；如果可以用向量，你可以记录你在不同时候的体重，比如你用向量 V(24) 来记录你一天的体重，那么 V(12)=54 代表你中午12点的体重是54kg，更丰富的，当你使用张量 T(24,3,35) 来表达体重，那么 T(12,2,20)=54 代表在中午12点时、你吃了2顿饭、且当日气温为20度时你的体重为54kg，这样是不是就获得了更丰富的表达能力？
总之，张量可以理解为一个带有很多维度信息的数据结构，它本身对应我们在编程中熟知的多维数组。在机器学习中，它可以组织较高维的数据。
2、生成子空间 生成子空间(span)是一个线性代数的概念，线性代数里是这样定义它的：一组不线性相关的向量的线性组合集合称之为它们的生成子空间。 最常见的例子，就像二维空间的笛卡尔坐标系 XY ，有向量 x=(1,0) 和 y=(0,1) ,很明显整个坐标系 XY 就是这两个向量的生成子空间。 数学表达上，是指有一系列向量 V=(v1,v2...vn) 构成了任意的 v ： v=∑icivi 其中 ci 为任意实数。 如果想形象描述生成子空间，可以这么想，这一组向量相当于我们汉语里一个个汉字，线性累加运算相当于我们组合这些汉字来造句，那么生成子空间这个集合(其本质是一个集合)的大小相当于我们能用这些字表达多少意思。
3、范数 范数(norm)是数学中的一种基本概念。在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。
这段话或许有些费解，其实我们可以从需求来考虑范数这个工具(本质是一个数学工具，设计来解决某个痛处)的需求是什么。当你只做标量运算时，它们的大小很好比较，因为比如5的大小就是5(它本身)，那向量的大小呢？矩阵的大小呢？怎么度量？为了可计算可比较，就引入了范数这个工具。
其实早在初中时大家都学过绝对值，这是为了比较所有实数(包括了正负数)的大小而设计的一种工具，可以认为绝对值也是一种范数。
下面就介绍几种范数，对于向量 v 来说，范数||v||是将其从多维空间映射到正实数的一个变换，也就是 Rn→R+ ： 无穷范数 ||x||=max|xi| 1-范数 ||x||1=∑ni=0|xi| 2-范数 ||x||2=∑ni=0x2i 对于矩阵来说也需要大小的度量，列举一些矩阵的范数: 行范数 ||A||=maxi∑nj=0|aij| 列范数 ||A||=maxj∑ni=0|aij| Frobenius范数 F(A)=(∑aij2)1/2 如果想形象理解范数可以这么想，现在需要对一组人进行度量，人这个事物不是一个数，怎么度量？就可以构造一种范数，比如取这个人的身高，或者这个人的高考分数，亦或者其工资数目都是将人映射到正实数的变换，那就是一种范数(严格来说也需要满足范数的三大条件)。总之范数是一种数学变换工具，要用活它。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e4171c71938d6c3d2eac385579cfff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d36219a69f82bde65568921b90957e/" rel="bookmark">
			哈希表 (桶)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前博文提到的平衡二叉搜索树 （AVL 树 和 红黑树）可以在 O(logN) 的时间复杂度内进行增删等操作，下面要介绍的哈希表 (hashtable) 在增删等操作表现更为出色，时间复杂度为 O(1)。
完整实现代码 概述 不同于之前的树形数据结构，此处的哈希表是一种表 (或者字典) 结构，这种结构的好处是提供常数时间复杂度的基本操作，就像数组那样，想要访问某个元素，通过下标一步就可以找到该元素。
事实上，哈希表就是借助数组下标定位的这种方法来达到常数时间复杂度的操作的。
看个例子： 假如此处有一组数据，其类型皆为 unsigned char (即范围为 0 ~ 255)，那么通过一个大小为 256 的数组A 储存 这组元素，数组的 256 个位置上初始值皆为 0， 当插入 i 时， 就执行 A[i]++， 当删除 j 时， 就执行 a[j]--，要查找 k ，则判断 0 == a[k]，以上的操作时间复杂度都为 O(1)。 很显然，这种方法存在几个缺陷。
如果此处只有 20 个 unsigned char 类型的数据， 那么我们还是需要一个大小为 256 的数组，空间浪费严重。如果数据类型为 32bit 位的 int，那么这个储存数据的数组就需要 4GB，这显然大的不切实际。如果数据是字符串或者其他复杂类型，就无法拿来当数组索引。 我们可以通过某种映射函数来解决上述问题，将大数据转换为我们可以接受的小数据，这个映射函数我们称之为 哈希函数。 常见的哈希函数的构造方法有以下几种：数字分析法，平方取中法，分段叠加法，伪随机数法，除留余数法。通常采用除留余数法。 使用哈希函数存在一个问题：不同的值会被映射到相同位置。这种现象叫做哈希碰撞（或者哈希冲突）。我们可以通过下面的方法解决哈希碰撞。
哈希碰撞 负载因子：元素个数除以表格大小。对于线性探测和二次探测的负载因子一般为 0~0.7 ，不让数据过于饱满而造成严重的哈希碰撞。对于开链法负载因子则可以设置为 0 ~ 1。在每次插入元素时，都会检查负载因子，当负载因子超过限定值时，就重新分配空间，并且重新哈希（将数据搬移到新表中）。 下面介绍解决哈希碰撞的方法（线性探测、二次探测、开链法）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d36219a69f82bde65568921b90957e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cadcb5ed9610b21275e1f2f98dd2be9/" rel="bookmark">
			nginx公网IP无法访问浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置服务器时候发现的问题，真的是搜肠刮肚的找答案，找一下午，终于找到了答案。
一、开始找原因 在浏览器输入：http://ip，正常的话，会有页面，welcome to nginx 我这里是浏览器访问失败， 查找原因：
1、在服务器上访问Ip 执行：curl http://ip 结果：超时，未连接成功
查看nginxaccess.log日志，发现日志未滚动，代表本机访问不到公网ip
2、确认网络是否可达 telnet 12x.xx.x.xx 80 Trying 12x.xx.x.xx... Connected to 12x.xx.x.xx. Escape character is '^]'. 这样就说明网络上可达，并且TCP三次握手可以完成，因为能telnet通，排除了网络不通的情况 但是我本地的网络不通。
3、是否受防火墙安全控制等。 将iptables和selinux关闭 以下4条命令清除iptables的配置
iptables -F iptables -F -t nat iptables -X iptables -X -t nat setenforce 0 #关闭selinux 重新远程访问，还是失败。说明不是防火墙的原因。这里因为我是debian，所以默认是没有开启防火墙的，所以不是这个原因。
4、去/var/log/nginx/error.log查看错误日志 日志报错：Address already in use 这里就已经确认错误在哪了，原来是80端口被占用的问题。
5、解决方案 1）执行：lsof -i:80 查看此时哪个进程正在使用80端口 我这边发现是阿里云盾正在使用80端口
2）杀掉云盾进程，重启nginx试试 kill -s 9 pid 具体参考博客：http://blog.csdn.net/ljfphp/article/details/78666376
6、好吧，惊奇的发现，通过浏览器还是访问不了nginx，但是此刻我的80端口已经被nginx监听了。继续查看错误日志。错误日志并没刷新。 7、百度发现有人说是iptables防火墙的原因，但是debian系统的安装默认是没有iptables,所以应该不是防火墙的原因。
8、看到有人说，是没有备案域名的原因，80端口默认是关闭状态。好吧，我准备改成8080端口，看看能不能行吧。（这个没来得及试）
二、真正的凶手 终于找到问题了，眼泪差点掉下来。原来是阿里云的问题。我刚开通的服务器，没有设置安全组规则。下面给大家演示一下安全组怎么设置。 1、进入云服务控制台
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cadcb5ed9610b21275e1f2f98dd2be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b0cea51ae3927f809d9753be1e6960/" rel="bookmark">
			将字符串插入另一个字符串的指定位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：编写一个函数，将一个字符串插入到另一个字符串的某个位置后面（例如：将”abc”插入到”abcdef”的第三个字符位置后面，结果为”abcabcdef”）。编写程序时，请在必要的地方加以注释(注：不能用该程序语言的内置函数或过程)。
思路：
将str1字符串的指定位置后的内容复制到另一个字符串中，空间换时间降低时间复杂度；再将str2字符串（待插入字符串）复制到str1的指定位置；将str1和tmp拼接起来（这里用到了字符串拼接函数）。 代码实现：
#include &lt;iostream&gt; #define Max_num 1000 int myStrlen(const char *str) { int len = 0; while (*str++) len++; return len; } void myStrcat(char *str1, char *str2) //拼接函数 { int len1 = strlen(str1); int len2 = strlen(str2); for (int i = 0;i &lt; len2;i++) { str1[len1 + i] = str2[i]; } str1[len1 + len2] = '\0'; } void myLink(char *str1, char *str2,int pos) { int len1 = myStrlen(str1); int len2 = myStrlen(str2); char *tmp= (char *)malloc(sizeof(char)); int cnt = 0; for (int i = pos; i &lt;= len1;i++) { //*tmp++ = str1[i]; //指针要初始化或者有相应的值，这样是错误的 tmp[cnt++] = str1[i]; } int j; for ( j = 0;j &lt; len2;j++) { str1[ pos + j] = *str2++; } str1[pos + j] = '\0'; myStrcat(str1, tmp); } int main() { char str1[Max_num], str2[Max_num]; int n; while (cin&gt;&gt;str1&gt;&gt;str2) { cin &gt;&gt; n; myLink(str1, str2, n); cout &lt;&lt; str1 &lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c05d045efa299b96cc647e1c27e5ce/" rel="bookmark">
			Ceph集群部署文档（4节点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ceph集群部署文档（4节点）
一、 背景 Ceph是一个分布式存储，可以提供对象存储、块存储和文件存储，其中对象存储和块存储可以很好地和各大云平台集成。一个Ceph集群中有Monitor节点、MDS节点（可选，用于文件存储）、至少两个OSD守护进程。 Ceph OSD：OSD守护进程，用于存储数据、处理数据拷贝、恢复、回滚、均衡，并通过心跳程序向Monitor提供部分监控信息。一个Ceph集群中至少需要两个OSD守护进程。 Monitor：维护集群的状态映射信息，包括monitor、OSD、Placement Group（PG）。还维护了Monitor、OSD和PG的状态改变历史信息。 MDS：存储Ceph文件系统的元数据。
二、 环境规划 1、四节点Centos7主机，其中ceph-admin节点为管理节点和监控节点，ceph-1、ceph-2为osd节点，每个节点3个2T的磁盘（分别命名为sdb、sdc、sdd）。ceph-client为客户端，方便以后进行存储测试。所有节点都安装CeontOS7。
2、集群配置如下：
主机
IP
功能
ceph-admin
192.168.56.100
ceph-deploy、mon、ntp server
ceph-1
192.168.56.101
osd.0、mds
ceph-2
192.168.56.102
osd.1
ceph-client
192.168.56.103
客户端，主要利用它挂载ceph集群提供的存储进行测试
3、节点关系图
三、前期准备，安装ceph-deploy工具 所有的节点都是root用户登录的。 1、修改每个节点的主机名，并重启。 # hostnamectl set-hostname ceph-admin(ceph-1/ceph-2/ceph-client)
2、配置防火墙启动端口 需要在每个节点上执行以下命令：
# firewall-cmd--zone=public --add-port=6789/tcp –permanent
# firewall-cmd--zone=public --add-port=6800-7100/tcp–permanent
# firewall-cmd–reload
# firewall-cmd--zone=public --list-all
3、禁用selinux 需要在每个节点上执行以下命令：
# setenforce 0
# vim /etc/selinux/config
将SELINUX设置为disabled
4、配置ceph-admin节点的hosts文件 # vi /etc/hosts
192.168.56.100 ceph-admin
192.168.56.101 ceph-1
192.168.56.102 ceph-2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26c05d045efa299b96cc647e1c27e5ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/738d4b42513c0355c8ea51bbd8a8e680/" rel="bookmark">
			Wireshark 捕获过滤器的语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.csdn.net/qq_29277155/article/details/52077239
前言 我们都知道，wireshark可以实现本地抓包，同时Wireshark也支持remote packet capture protocol（rpcapd）协议远程抓包，只要在远程主机上安装相应的rpcapd服务例程就可以实现在本地电脑执行wireshark 捕获远程电脑的流量了。但是各种协议的流量非常巨大，如果我们捕获所有协议的流量，那么数小时内，捕获到的流量将到达几百M，甚至几G。硬盘空间很快就被填满了。所以很有必要，只捕获特定的流量或者不捕获某些流量而捕获其他所有的流量。
捕捉过滤器语法 语法：&lt;Protocol&gt; &lt;Direction&gt; &lt;Host(s)&gt; &lt; Value&gt; &lt; Logical Operations&gt; &lt;Other expression&gt;
Protocol（协议）: ether，fddi， ip，arp，rarp，decnet，lat， sca，moprc，mopdl， tcp ， udp 等，如果没指明协议类型，则默认为捕捉所有支持的协议。
Direction（方向）:src， dst，src and dst， src or dst等，如果没指明方向，则默认使用 “src or dst” 作为关键字。
Host(s): net, port, host, portrange等，默认使用”host”关键字，”src 10.1.1.1″与”src host 10.1.1.1″等价。
Logical Operations（逻辑运算）:not, and, or 等，否(“not”)具有最高的优先级。或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。
常见使用的捕获过滤语句 1.1 只（不）捕获某主机的HTTP流量
host 192.168.5.231 and port 80 and http#只捕获主机192.168.5.231 的http流量。注意如果你的HTTP端口为8080，把80 改为8080。
port 80 and http#捕获所有经过该接口的http流量。注意如果你的HTTP端口为8080，把80 改为8080。
host 192.168.5.231 and not port 80# 捕获主机192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/738d4b42513c0355c8ea51bbd8a8e680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa539d8958f57186e7f17166b7e99897/" rel="bookmark">
			ES6: import和export
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块化 前端模块化的好处都已经被说烂了，归纳为两点：
避免全局变量污染有效的处理依赖关系 ES2015（ES6）终于引入了模块的概念，最近学习了下，顺便记下笔记。
准备工作 借助Babel演示Demo。
创建个module目录，并在该目录里执行：
npm init -y 然后安装各种依赖：
npm install --save-dev babel-cli babel-preset-env babel-preset-es2015 接着创建.babelrc文件：
{ "presets": [ "es2015", "env" ] } 修改package.json文件的"scripts"配置：
"scripts": { "build": "babel src --out-dir dist" } 最终的目录结构如：
模块导出 一个文件定义一个模块，通过export语句导出该模块输出的变量。export语句有两种语法格式：命名导出， 默认导出。
1 命名导出 命名导出就是显示指定导出变量的名称。
在src目录下创建math.js，index.js文件。
math.js内容：
// Case 1: export后面跟变量输出声明语句 var PI = 3.14; export { PI }; // 导出变量PI，花括号不可省略 // Case 2: export后面直接跟变量定义语句 export var add = function (x, y) { // 导出函数print return x + y; } 这表示math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa539d8958f57186e7f17166b7e99897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b773feef0bf709bd4a6284efb888ebf/" rel="bookmark">
			ROS——rplidar在rviz中三维显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求分析 rplidar A1和rplidar A2使用相同的接口和SDK，因此可以均可以使用该代码。官方的DEMO实现了激光雷达的二维扫描，并将扫描结果事实显示在rviz中，可以满足基本的需求。官方DEMO中将扫描结果在rviz的“LaserScan”中显示，但是由于“LaserScan”只能显示二维坐标，所以当需要使用二维激光雷达三维建模时官方DEMO便不能使用，因此我将其移植到rviz的“PointCloud2”中显示。
消息类型查看 输入以下命令查询“LaserScan”参数：
rosmsg show sensor_msgs/LaserScan 显示如下
std_msgs/Header header uint32 seq time stamp string frame_id float32 angle_min float32 angle_max float32 angle_increment float32 time_increment float32 scan_time float32 range_min float32 range_max float32[] ranges float32[] intensities 输入以下命令查询“PointCloud2”参数：
rosmsg show sensor_msgs/PointCloud2 显示如下
std_msgs/Header header uint32 seq time stamp string frame_id uint32 height uint32 width sensor_msgs/PointField[] fields uint8 INT8=1 uint8 UINT8=2 uint8 INT16=3 uint8 UINT16=4 uint8 INT32=5 uint8 UINT32=6 uint8 FLOAT32=7 uint8 FLOAT64=8 string name uint32 offset uint8 datatype uint32 count bool is_bigendian uint32 point_step uint32 row_step uint8[] data bool is_dense 修改后完整代码 从“LaserScan”和“PointCloud2”参数对比可以看出，“PointCloud2”可以满足三维显示的需求，因此修改rplidar_ros。其中“client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b773feef0bf709bd4a6284efb888ebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2739cb3c5d9a528f9062e2c60d94edf/" rel="bookmark">
			在线java编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发下一个完整，里面有各种编程语言的编译工具，可以在线编辑使用。
收藏下。
在线java编译器地址。
https://www.tutorialspoint.com/compile_java_online.php
Linux在线客户端
https://www.tutorialspoint.com/unix_terminal_online.php
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9db8a069b3e9033ceaea69899a1799/" rel="bookmark">
			【MongoDB学习笔记13】MongoDB的更新（update）操作进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、批量更新
默认只对符合条件的一条文档更新
1 2 3 4 5 6 7 8 &gt; db.post. find () { "_id" : ObjectId( "54a530c3ff0df3732bac1681" ), "id" : 2, "name" : "joe" , "age" : 49 } { "_id" : ObjectId( "54a530c3ff0df3732bac1680" ), "id" : 1, "name" : "joe" , "age" : 21, "comments" : [ "test2" , "test9" , "test5" ] } &gt; db.post.update({ "name" : "joe" }, {$ set :{ "age" :70}}) WriteResult({ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b9db8a069b3e9033ceaea69899a1799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aea88d3f971d76b2c98b4676deea646/" rel="bookmark">
			第五周周总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周主要学习了css3 制作了一个简单的动态网页,感觉对css3的很多属性还不是特别了解,对网页的布局还存在问题.经过这周的学习我深知视频学习的快速.但感觉只看视频的话理解是不够深入的.各种基本属性还是要自己去看才能印象更深,然后通过视频去学习别人的代码格式,自己写代码的时候思路才会更加清晰. 其他方面的话感觉很乱,c++实验原本准备答辩的,人太多了又没答成,数据库感觉有点麻烦,又是交代码又是画模型又是交报告....
下周任务:
完善css3网页,增加响应式布局
备考算法和概统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b1e4830d700c0ce5f4e9172ddace9b2/" rel="bookmark">
			Java中矩阵运算(math3的使用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		math3简介 math3是Apache下的一款进行数学计算的一款java开源工具。jar包名称为：commons-math3-3.6.1.jar。大家可以通过maven或者其他网站进行下载。
math3是一款非常好用的工具，里面提供了各种运算的方法及类，方便大家调用。其API文档为：http://commons.apache.org/proper/commons-math/javadocs/api-3.2/index.html。可以参照API文档进行学习，也可以在实战中，进行学习。比如，从正太分布中采样，从逆威沙特分布分布中采样等等，都可以基于此工具完成。具体可参考这一篇博客http://blog.csdn.net/qy20115549/article/details/54317981。
math3中的矩阵操作 由于在写算法时，经常遇到矩阵的运算，如数组转化为矩阵，矩阵的逆，矩阵的转置，矩阵的乘法，矩阵转为数组等等。下面写了一个小程序演示一下，相关操作。具体请看注释。
package sampling.method;import org.apache.commons.math3.linear.Array2DRowRealMatrix;import org.apache.commons.math3.linear.LUDecomposition;import org.apache.commons.math3.linear.RealMatrix;/* * author:合肥工业大学 管院学院 钱洋 *1563178220@qq.com *博客地址:http://blog.csdn.net/qy20115549/*/public class MathMethod { public static void main(String args[]){ double b [][] = new double[5][5]; for(int i = 0; i &lt; b.length; i++) { b[i][i] = 1; } //将数组转化为矩阵 RealMatrix matrix = new Array2DRowRealMatrix(b); System.out.println("创建的数组为：\t"+matrix); //获取矩阵的列数 getColumnDimension() System.out.println("矩阵的列数为:\t"+matrix.getColumnDimension()); //获取矩阵的行数 System.out.println("矩阵的行数为:\t"+matrix.getRowDimension()); //获取矩阵的某一行,返回,仍然为矩阵 System.out.println("矩阵的第一行为:\t"+ matrix.getRowMatrix(0)); //获取矩阵的某一行,返回,转化为向量 System.out.println("矩阵的第一行向量表示为:\t"+ matrix.getRowVector(1) ); //矩阵的乘法 double testmatrix[][] = new double[2][2]; testmatrix[0][0] = 1; testmatrix[0][1] = 2; testmatrix[1][0] = 3; testmatrix[1][1] = 4; RealMatrix testmatrix1 = new Array2DRowRealMatrix(testmatrix); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b1e4830d700c0ce5f4e9172ddace9b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41cdcc25fe6e7380c6c75fdcb45208aa/" rel="bookmark">
			聚集索引:三级阶梯SQL Server索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://www.sqlservercentral.com/articles/Stairway+Series/72351/
聚集索引:三级阶梯SQL Server索引 通过大卫·杜兰特,2013/01/25(第一次出版:2011/06/22)
该系列 本文是楼梯系列的一部分:SQL Server的阶梯索引
索引数据库设计的基础,告诉开发人员使用数据库设计者的意图。 不幸的是索引时往往是后加上的性能问题出现。 终于在这里是一个简单的系列文章,应该让任何数据库专业迅速“加速”
前面的水平在这个楼梯概述了非聚集索引的索引一般和特别。 结论用以下关于SQL Server关键概念索引。 当一个请求到达您的数据库,一个SELECT语句或一个INSERT、UPDATE或DELETE语句,SQL Server只有三种可能的方法来访问数据表中引用的声明:
访问非聚集索引,避免访问表。 这只可能在索引中包含的所有数据查询这个表所要求的使用搜索键(s)来访问索引,然后使用所选的书签(s)来访问表的单个行。忽略了索引和搜索请求的表行。 这个水平首先关注的第三选择上面的列表; 搜索表。 反过来,这将导致我们的讨论集群索引; 一个被提及的话题,但没有涵盖,在2级。
主AdventureWorks我们将使用的数据库表是在这个水平SalesOrderDetail表。 在121317行,足以说明一些好处有聚集索引的表。 有两个外键,它是复杂的足以说明一些设计决策,你必须使你的聚集索引。
示例数据库 尽管我们已经讨论了在一级sample数据库,值得重复。 在整个楼梯,我们将使用示例来说明概念。 这些例子是基于微软的AdventureWorks示例数据库。 我们专注于销售订单。 五表将给我们一个良好的事务性和非事务性数据;客户,销售人员,产品,SalesOrderHeader,SalesOrderDetail。 为了保持专注,我们使用列的一个子集。 因为AdventureWorks规范化,销售人员信息分解成三个表:销售人员,员工和联系。
整个楼梯我们使用以下两个术语,指一行订单互换:“行项目”和“订单细节”。 前者是更常见的业务术语; 后者的名字出现在一个AdventureWorks表。
完整的一套表,和它们之间的关系,如图1所示。
Zoom in | Open in new window
图1:表中使用的例子在这个楼梯
注意:
所有TSQL代码所示这楼梯水平随着文章可以下载。
聚集索引 我们先问以下问题:有多少工作需要找到表中的一行(s)如果不使用非聚集索引? 搜索请求的行表意味着扫描一个无序表中每一行吗? 永久或SQL Server序列表的行,以便它可以快速访问他们的搜索键,就像快速访问非聚集索引的搜索键的条目吗? 答案取决于你是否指示SQL Server上创建一个聚集索引表。
与非聚集索引是一个单独的对象,占据自己的空间,聚集索引和表是一样的。 通过创建聚集索引,您指示SQL Server排序表的行索引键序列,在未来保持序列数据的修改。 即将到来的水平会看看生成的内部数据结构来完成这个。 但是现在,想到一个聚集索引排序表。 鉴于连续索引键值,SQL Server可以快速访问这一行; 并且可以通过表的行顺序进行。
出于演示的目的,我们创建两个我们的示例表的副本,SalesOrderDetail; 一个没有索引,一个聚集索引。 关于索引的键列,我们的设计师做出同样的选择AdventureWorks数据库:SalesOrderID/SalesOrderDetailID。 清单1中的代码的副本SalesOrderDetail表。 我们可以随时重新运行这段代码,我们希望从一个“白纸”开始。
如果存在(选择*从sys.tables&amp;# 160;在哪里OBJECT_ID=OBJECT_ID(“dbo.SalesOrderDetail_index”))删除表dbo.SalesOrderDetail_index;去如果存在(选择*从sys.tables&amp;# 160;在哪里OBJECT_ID=OBJECT_ID(“dbo.SalesOrderDetail_noindex”))删除表dbo.SalesOrderDetail_noindex;去选择*成dbo.SalesOrderDetail_index从Sales.SalesOrderDetail;选择*成dbo.SalesOrderDetail_noindex从Sales.SalesOrderDetail;去创建聚集索引IX_SalesOrderDetail在dbo.SalesOrderDetail_index(SalesOrderID,SalesOrderDetailID)去
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41cdcc25fe6e7380c6c75fdcb45208aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9edfaa97c3f7a87f8c545c0337dc7e46/" rel="bookmark">
			Oracle SQL Developer修改错误JDK路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 安装好Oracle11g后，第一次使用 Oracle SQL Developer，会提示选择JDK路径。选择了本机的JDK1.8路径，但是出现闪退的问题，无法进入Oracle SQL Developer。 解决方案 Oracle SQL Developer选择的JDK应该是Oracle安装目录下的product\11.2.0\dbhome_1\jdk路径，而不是我们自己安装的JDK路径。
安装Oracle后，正确选择JDK路径，可以正常进入程序。
如果第一次路径选择错误，可以通过修改 sqldeveloper.conf 文件中的 JavaHome 项来修改路径。
文件路径：Oracle安装目录\product\11.2.0\dbhome_1\sqldeveloper\sqldeveloper\bin 更改JavaHome：SetJavaHome E:\Work\Environment\Oracle\product\11.2.0\dbhome_1\jdk 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6024f16569ed4ceefb9d945bbef95a4/" rel="bookmark">
			Shiro SimpleAuthenticationInfo使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SimpleAuthenticationInfo这里原理很简单，又有一些值得挖掘的东西。
//此处使用的是user对象，不是username SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo( user, user.getPassword(), getName() ); 这个东西是在realm中的，第一个参数user，这里好多地方传的时候都是user对象，但是都在备注用户名。可是我如果传入username，就会报类型转换问题。
但是在开涛大神的博客中，无状态的shiro里，那边给出的例子是传username。我自己测试的，可以传username，也可以传user对象，仅限他那边一段代码。网上有文章说，这里其实是user和username的集合，后端是分两个字段接收的。由于时间的问题，没有深入里了解这块，传user对象是OK的。
第二个字段是user.getPassword()，注意这里是指从数据库中获取的password。
第三个字段是realm，即当前realm的名称。
看了几篇文章介绍说，这块对比逻辑是先对比username，但是username肯定是相等的，所以真正对比的是password。从这里传入的password（这里是从数据库获取的）和token（filter中登录时生成的）中的password做对比，如果相同就允许登录，不相同就抛出异常。
如果验证成功，最终这里返回的信息authenticationInfo 的值与传入的第一个字段的值相同（我这里传的是user对象）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe41c3d6414174f8d1bc8f68cf53eded/" rel="bookmark">
			selenium&#43;python设置爬虫代理IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 selenium+python设置爬虫代理IP 1. 背景 在使用selenium浏览器渲染技术，爬取网站信息时，一般来说，速度是很慢的。而且一般需要用到这种技术爬取的网站，反爬技术都比较厉害，对IP的访问频率应该有相当的限制。所以，如果想提升selenium抓取数据的速度，可以从两个方面出发：
第一，提高抓取频率，出现验证信息时进行破解，一般是验证码或者用户登录。第二，使用多线程 + 代理IP， 这种方式，需要电脑有足够的内存和充足稳定的代理IP 。 2. 为chrome设置代理IP from selenium import webdriver chromeOptions = webdriver.ChromeOptions() # 设置代理 chromeOptions.add_argument("--proxy-server=http://202.20.16.82:10152") # 一定要注意，=两边不能有空格，不能是这样--proxy-server = http://202.20.16.82:10152 browser = webdriver.Chrome(chrome_options = chromeOptions) # 查看本机ip，查看代理是否起作用 browser.get("http://httpbin.org/ip") print(browser.page_source) # 退出，清除浏览器缓存 browser.quit() 注意事项： 第一，代理IP最好是稳定的固定IP，不要选动态IP。我们常用的爬虫IP是高匿名动态IP，是通过拨号动态产生的，时效性很短，一般在1~3分钟。对于scrapy这种并发度很高，又不需要登录的爬虫来说，非常合适，但是在浏览器渲染类爬虫中并不适用。第二，代理IP的速度。因为selenium爬虫采用的是浏览器渲染技术，本身速度就很慢。如果选择的代理IP速度较慢，就会大大增加爬取的时间。第三，电脑内存要够大。因为chrome占内存较大，在并发度很高的情况下，容易造成浏览器崩溃，也就是程序崩溃。第四，在程序结束时，调用 browser.quit( ) 清除浏览器缓存。 3. 需要用户名密码验证的代理 参考文章： Selenium chrome配置代理Python版：https://www.cnblogs.com/roystime/p/6935543.htmlGitHub：https://github.com/RobinDev/Selenium-Chrome-HTTP-Private-Proxy 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb7dfcfe57ae598f40dd85671410d84f/" rel="bookmark">
			在Makefile中使用shell命令的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Makefile文件的处理格式
目标: 依赖项（可以是多个，可以写成多行，但是要以\作为续航符）
[tab符]执行命令
执行的Shell命令在用到变量引用的时候需要对"$"符号进行转义，需要写两个"$$"符号来转义成"$"符号
例如如下for循环的例子中，就连awk中的变量引用也需要使用两个"$"符号来进行转义
#自动循环c文件生成目标
CC = gcc SRCS = auto_dec.c get_func.c all: $(SRCS) @for i in $(SRCS); do o=`echo $$i | awk 'BEGIN{FS=".";} {print $$1;}'`; echo "o="$$o ;gcc -o $$o $$i; done 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5336c476c7541d3eb7bb61e1789ebb/" rel="bookmark">
			序列化与反序列化（其实就是一种将各种数据转换成二进制流与二进制流的读取的概念）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序列化：将数据结构转换称为二进制数据流或者文本流的过程。序列化后的数据方便在网络上传输和在硬盘上存储。
反序列化：与序列化相反，是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程。
本质其实还是一种协议，一种数据格式，方便数据的存储和传输。
为什么需要序列化？
我们知道，计算机世界往往是根据二进制来区分数据的，例如一个字节、两个字节、三个字节等等，但是，由于在内存中或者磁盘上，或者平台的环境不同，为了方便数据在不同的地方能够具有相同的含义，我们需要将数据转换为一种大家都能识别的格式，二进制或者编码格式是大家都认同的方式，而序列化正好是将一种数据格式转换为二进制数据流的过程或者方法，那么该数据结构就能够在任何地方保持其原有的含义，这就是序列化的意义。
什么是编码？与序列化的区别？
编码也是一种约定数据的含义的方式。与序列化不同，其约定的是更底层一些的数据含义，例如字符的表示，有ASCII、UTF-8、GBK等等，例如整数的表示，1=00000001一个字节，编码约定了数据格式的最小单元，序列化是依赖于字符编码之上的一种数据格式。
二进制流和文本流的区别：二进制流是以二进制为最小单位进行编码，例如多少个bit代表什么，文本流是以字符来进行编码，约定好多少个字节（通常是以字节为单位）代表什么。
最后附一个C/C++序列化库，boost serialization。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6307e6f85586c5f7b857a702f27bf225/" rel="bookmark">
			漫步最优化四十五——矩阵S的生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想赖着你每一天， 耽误多一秒都不愿意。 想把你捧在手心， 给你我最奢侈的温柔。 感恩节快乐， 感谢有你。 ——畅宝宝的傻逼哥哥 令 f(x)∈C2 是 En 中的函数并假设 f(x) 在点 xk,xk+1 处的梯度分别为 gk,gk+1 ，如果 xk+1=xk+δk 那么根据泰勒级数可以得出 gk+1 的元素为 g(k+1)m=gkm+∑i=1n∂gkm∂xkiδki+12∑i=1n∑j=1n∂2gkm∂xki∂xkjδkiδkj+⋯ 其中 m=1,2,…,n 。接下来如果 f(x) 是二次的，那么 f(x) 的二阶导为常数， gkm 的二阶导为令，所以 g(k+1)m=gkm+∑i=1n∂gkm∂xkiδki 又因为 gkm=∂fk∂xkm 因此我们有 g(k+1)m=gkm+∑i=1n∂2fk∂xki∂xkmδki 其中 m=1,2,…,n ，也就是 gk+1=gk+Hδk 其中 H 是 f(x) 的海森矩阵。或者我们可以写成 γk=Hδk 其中 δk=xk+1−xkγk=gk+1−gk 上面的分析表明，如果 f(x) 在点 xk,xk+1 处的梯度已知，那么可以得到上面的关系，这给出了矩阵 H 的部分信息。因为 H 中有 n2 个未知量(或者如果 H 是实对称矩阵，那么存在 n(n+1)/2 个未知量)，而等式2只提供了 n 个等式，不能唯一的确定H，然而，如果对连续 n+1 个点的梯度进行估计，也就是点 x0,x1,…,xn ，使得 x 的变化量组成一个线性无关向量的集合，那么我们就有充分的信息来唯一的确定 H ，其中 x 的变化量就是 δ0=x1−x0δ1=x2−x1⋮δn−1=xn−xn−1 为了证明这个事实，我们将等式2给出的 n 个等式重新写成 [γ0 γ1 ⋯ γn−1]=H[δ0 δ1 ⋯ δn−1] 因此 H=[γ0 γ1 ⋯ γn−1][δ0 δ1 ⋯ δn−1]−1 如果 δ0,δ1,…,δn−1 构成一个线性无关向量集，那么解就存在。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6307e6f85586c5f7b857a702f27bf225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bb9b9616a753cb8d6596c41ae8541d/" rel="bookmark">
			查看xcode证书路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shift+command+G 打开文件夹路径快捷键
~/Library/MobileDevice/Provisioning Profiles
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877571cdbbe1e4909d15a68de54e3faa/" rel="bookmark">
			Python---copy()、deepcopy()与赋值的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		copy()与deepcopy()之间的主要区别是python对数据的存储方式。
首先直接上结论：
—–深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。 —–而等于赋值，并不会产生一个独立的对象单独存在，他只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。
—–而浅复制要分两种情况进行讨论：
1）当浅复制的值是不可变对象（数值，字符串，元组）时和“等于赋值”的情况一样，对象的id值与浅复制原来的值相同。
2）当浅复制的值是可变对象（列表和元组）时会产生一个“不是那么独立的对象”存在。有两种情况：
第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。
第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表），如果不改变其中复杂子对象，浅复制的值改变并不会影响原来的值。 但是改变原来的值 中的复杂子对象的值 会影响浅复制的值。
对于简单的 object，例如不可变对象（数值，字符串，元组），用 shallow copy 和 deep copy 没区别
复杂的 object， 如 list 中套着 list 的情况，shallow copy 中的 子list，并未从原 object 真的「独立」出来。也就是说，如果你改变原 object 的子 list 中的一个元素，你的 copy 就会跟着一起变。这跟我们直觉上对「复制」的理解不同。
当浅复制的值是不可变对象（数值，字符串，元组）时，代码如下：
&gt;&gt;&gt; a="1234567" &gt;&gt;&gt; b=a &gt;&gt;&gt; id(a) 4367619440 &gt;&gt;&gt; id(b) 4367619440 &gt;&gt;&gt; c=copy.copy(a) &gt;&gt;&gt; id(c) 4367619440 &gt;&gt;&gt; d=copy.deepcopy(a) &gt;&gt;&gt; id(d) 4367619440 当浅复制的值是可变对象（列表，字典）时，改变的值不是 复杂子对象 代码如下：
&gt;&gt;&gt; l1=[1,2,3] &gt;&gt;&gt; l2=l1 &gt;&gt;&gt; l3=copy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/877571cdbbe1e4909d15a68de54e3faa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3abd240586cd4ba38703fae9983e949e/" rel="bookmark">
			7-2 输出全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-2 输出全排列（20 分） 请编写程序输出前n个正整数的全排列（n&lt;10），并通过9个测试用例（即n从1到9）观察n逐步增大时程序的运行时间。
输入格式: 输入给出正整数n（&lt;10）。
输出格式: 输出1到n的全排列。每种排列占一行，数字间无空格。排列的输出顺序为字典序，即序列a​1​​,a​2​​,⋯,a​n​​排在序列b​1​​,b​2​​,⋯,b​n​​之前，如果存在k使得a​1​​=b​1​​,⋯,a​k​​=b​k​​ 并且 a​k+1​​&lt;b​k+1​​。
输入样例： 3 输出样例： 123 132 213 231 312 321 思路：假想有一棵树，树的第一层为1 2 3 ，然后第二层下的1分支又有1 2 3 ，2又有1 2 3,3又有1 2 3；首先遍历是从1开始的，遍历完1之后，就把1用标记数组标记为1，当len==n后，就代表这一次遍历结束，我们要返回上一层次，但是返回的过程中，有一个“还原”的过程，还原就是把当前这个数字的标记去掉，使visited【k】=0；就拿第一次输出123来做例子，我们输出123之后，要返回上一层，就把3的标记去掉，返回上一层之后，2我们遍历了，也标记了，就访问下一个数字3，然后把3的标记，然后3下面有数字1 2 3,在1 3 ？这一分支中，2没有被标记，所以？=2；所以就输出了132 #include&lt;stdio.h&gt; int a[1000]; int visited[1000]; void perm(int n,int len) { int i,k; if(len==n) { for(i=0;i&lt;n-1;i++) printf("%d",a[i]); printf("%d\n",a[n-1]); } for(k=1;k&lt;=n;k++) { if(visited[k]==0) { a[len++]=k;//把当前的数字放进数组，并且本层的len值加1 visited[k]=1;//把当前的数字加1 perm(n,len);//递归调用，继续往下深入，如若满足了len==n 就做输出，然后执行下面的还原语句 len--;//因为当前层次的len值做了加1 要还原本层的len值，就要len--； visited[k]=0;//把当前数字的标记去掉，然后返回上一层，继续再往下执行 } } } int main() { int n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3abd240586cd4ba38703fae9983e949e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553f896f85935d2ddfab54088ed1229a/" rel="bookmark">
			用java代码写的简易计算器（可以实现基本的加减乘除功能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算器使我们在日常生活中经常使用的一个工具。这学期学java的时候，做的一个实验报告就是用swing组件或awt组件写一个简易计算器。
在此记录以下（用swing组件写的简易计算器），代码如下（经测试）：
import java.awt.BorderLayout; import java.awt.GridLayout; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.StringTokenizer; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.JTextField; public class JiSuan extends JFrame{ JPanel panel; JTextField text; JButton jb0,jb1,jb2,jb3,jb4,jb5,jb6,jb7,jb8,jb9;	//0~9四个数字（可写成数组） JButton bot,add,sub,mul,div,equ;	//加减乘除以及小数点五个符号 public JiSuan(){ this.setBounds(300, 200, 400, 300);	//窗体大小 this.setTitle("计算器");	//窗体名称 this.setLayout(new BorderLayout());	//设置计算机窗体的布局方式 text = new JTextField(15);	//计算区域 //新建数字按钮 jb0 = new JButton("0"); jb1 = new JButton("1"); jb2 = new JButton("2"); jb3 = new JButton("3"); jb4 = new JButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/553f896f85935d2ddfab54088ed1229a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b41a7bce9abb5490eedae4a3528acc/" rel="bookmark">
			iOS-贝塞尔曲线之自定义饼图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中需要统计数据展现, 采用了饼图形式展现.如下图所示:
第一步: 了解贝塞尔曲线相关概念 贝塞尔曲线相关概念: UIBezierPath ：画贝塞尔曲线的path类 UIBezierPath定义 ： 贝赛尔曲线的每一个顶点都有两个控制点，用于控制在该顶点两侧的曲线的弧度。 曲线的定义有四个点：起始点、终止点（也称锚点）以及两个相互分离的中间点。 滑动两个中间点，贝塞尔曲线的形状会发生变化。 UIBezierPath：对象是CGPathRef数据类型的封装，可以方便的让我们画出矩形 、 椭圆 或者 直线和曲线的组合形状.
使用贝塞尔曲线的基本步骤: （1）创建一个Bezier path对象。 （2）使用方法moveToPoint:去设置初始线段的起点。 （3）添加line或者curve去定义一个或者多个subpaths。 （4）改变UIBezierPath对象跟绘图相关的属性。
初始化方法：
+ (instancetype)bezierPath; 创建一个矩形:
+ (instancetype)bezierPathWithRect:(CGRect)rect; 创建圆形或者椭圆形:
+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect; + (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; // rounds all corners with the same horizontal and vertical radius + (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii; + (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise; + (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath; 最基本的使用方法是：
// 设置描绘的起点 - (void)moveToPoint:(CGPoint)point; // 画直线 - (void)addLineToPoint:(CGPoint)point; // 画曲线 // a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02b41a7bce9abb5490eedae4a3528acc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/292/">«</a>
	<span class="pagination__item pagination__item--current">293/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/294/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>