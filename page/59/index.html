<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cbbd3e2d30a7aa674ff29ec8d8fe42d/" rel="bookmark">
			element-ui里el-progress：进度条问题的解决Invalid prop: custom validator check failed for prop “percentage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：Progress 数值大于100报错处理 &lt;el-progress type="circle" color="#509234" :show-text="false" :percentage="TargetReportObj.sksRatio&gt;100?100:parseFloat(TargetReportObj.sksRatio)" :stroke-width="7" stroke-linecap="square" :width="150" /&gt; 重点这句，绑定值不能大于100 （100 ? 100 : parseInt(value)"） :percentage="TargetReportObj.sksRatio&gt;100?100:parseFloat(TargetReportObj.sksRatio)" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33700065e8a33de7ec23548ec7a4adb/" rel="bookmark">
			134. 加油站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Powered by:NEFU AB-IN
Link
文章目录 134. 加油站题意思路代码 134. 加油站 题意 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
思路 假设i为起点，且i最多不能走到j，结论：[i, j]之前任意起点也 不能走到j
证明：k是可以走到的，所以left[k] &gt;= 0（即从左边走过来还剩下有油）。 如果把k当作起点即left[k]=0,那么还是走不到j，所以下一次枚举起点，可以直接跳过[i- j],O(n)
代码 class Solution { public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) { int n = gas.size(); for (int i = 0, j; i &lt; n; ) { // 枚举起点 int left = 0; for (j = 0; j &lt; n; j ++ ) { int k = (i + j) % n; left += gas[k] - cost[k]; if (left &lt; 0) break; } if (j == n) return i; i = i + j + 1; } return -1; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85c59d4e1606bcd605e4f7c033c73f0/" rel="bookmark">
			微信小程序实现连续签到七天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		签到满了七天之后，签到第八天会回到第一天重新开始签到
断签之后会从第一天重新开始
&lt;template&gt; &lt;view class="content" style="height: 100vh;background: white;"&gt; &lt;view class="back"&gt; &lt;view style="position: absolute;bottom: 200rpx;left: 40rpx;width: 90%;"&gt; &lt;image :src="headimgUrl" mode="widthFix" style="width: 92rpx;height: 92rpx;border-radius: 50%;float: left;margin-top: -6rpx;margin-right: 14rpx;"&gt;&lt;/image&gt; &lt;view style="float: left;"&gt; &lt;span style="font-size: 32rpx; font-weight: bold; color: #FFFFFF;"&gt;连续签到 &lt;/span&gt; &lt;span style="font-size: 44rpx;color: #FF7D00;line-height: 40rpx;"&gt;{{ days }}&lt;/span&gt;&lt;span style="font-size: 32rpx; font-weight: bold; color: #FFFFFF;"&gt;天&lt;/span&gt; &lt;view style="font-size: 24rpx; font-weight: 100; color: #FFFFFF;"&gt;连续签到七天可获得{{ sevenDay }}积分&lt;/view&gt; &lt;/view&gt; &lt;uni-calendar ref="calendar" class="uni-calendar--hook" :clear-date="true" :date="info.date" :insert="info.insert" :startDate="info.startDate" :endDate="info.endDate" :range="info.range" @confirm="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d85c59d4e1606bcd605e4f7c033c73f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0255a478245427caa4769518d174f26c/" rel="bookmark">
			Java基于UDP协议点对点聊天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java基于UDP协议实现点对点聊天，只要有一方输入88，双方就都下线了，下面是代码：
发送端代码(简称甲方)：
package Demo0915; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.util.Scanner; /** * &lt;p&gt;基于UDP协议发送消息者&lt;/p&gt; * * @author 波波老师(weixin : javabobo0513) */ public class SenderUDP { public static void main(String[] args) throws Exception { DatagramSocket ds = new DatagramSocket(); //创建目的地对象 InetAddress ia = InetAddress.getByName("192.168.2.95"); Scanner sc = new Scanner(System.in); byte[] contentArray = new byte[1024]; //创建数据包 DatagramPacket dp = new DatagramPacket(contentArray, contentArray.length, ia, 48080); byte[] content = new byte[1024]; //2、创建接收数据的数据包 DatagramPacket dp2 = new DatagramPacket(content, content.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0255a478245427caa4769518d174f26c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/863909c19737388c228d4f3e6fdaa096/" rel="bookmark">
			cve-2023-3079漏洞与patch分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POC function set(arr, key, val) { arr[key] = val; } function leak_hole() { for(let i = 0; i &lt; 10; i++) { set(arguments, "foo", 1); } set(new Array(), 0, 1); set(arguments, 0, 1); return arguments[1]; } %DebugPrint(leak_hole()); 分析 通过对此漏洞的patch分析可知，此漏洞主要是由于没有检查传入的receiver是否是arguments对象并对其做特殊处理导致的：
当在循环执行到第9次时将会触发内联缓调用（前八次都将是no_feedback）AccessorAssembler::KeyedStoreIC(const StoreICParameters* p)函数，由于第一次触发IC所有会进入miss分支，此分支会进入Runtime_KeyedStoreIC_Miss函数：
在Runtime_KeyedStoreIC_Miss函数中会调用KeyedStoreIC::Store以此来获取Store操作对应的StoreHandler对象，此对象中保存着具体用于从receiver获取属性内容的code：
从KeyedStoreIC::Store函数开始就将会进入漏洞的主要触发流程，在第九次执行set(arguments, "foo", 1);时由于key是属性name类型会直接在调用完StoreIC::Store函数后结束:
在执行set(new Array(), 0, 1);时会与前一个处理过的arguments对象相同，由于receiver与key都不同所以将会触发miss分支，并调用KeyedStoreIC::Store函数，与上一行代码不同的是set(new Array(), 0, 1);key不是一个属性name类型，而是一个元素索引类型，所以KeyedStoreIC::Store函数会先执行到以下位置：
此处主要用于获取is_arguments、old_receiver_map、key_is_valid_inde、store_mode几个变量，其中store_mode比较重要，因为在生成StoreHandle时会根据它来选择具体的存储代码，由于此处处理的是array所以is_arguments与is_proxy都将会是false，而key是0也是一个有效的index，所以此处会通过GetStoreMode来获取具体的存储模式：
存储模式主要有四种，根据poc来分析漏洞的话可知此处我们需要STORE_AND_GROW_HANDLE_COW模式，此模式是一个可扩展的存储模式，由于可扩展模式没有比较严格的边界检查所以会导致之后的问题，想要得到这种模式，要满足四个条件：
receiver是一个JSArray对象必须得是越界访问当前索引必须小于JSArray最大索引数数组元素必须连续，也就是说必须是PACKED_ELEMENTS类型的数组 之后将会去调用UpdateElements函数，UpdateElements函数会先初始化一个target_maps_and_handlers列表，通过调试可知这个列表的内容与feedback反馈槽中保存的内容是一至的，通过名称可知这个列表里主要保存map与handler：
map通过执行lambda表达式通过map的过渡树向上遍历map转换关系得到更新后的map，而handler则是通过反馈网络对象获取：
获取完target_maps_and_handlers后会对单态会用直接用StoreElementHandler函数去获取StoreHandler，如果不满足单态那就用多态的处理函数StoreElementPolymorphicHandlers去获取StoreHandler，此处会进入多态处理函数：
StoreElementPolymorphicHandlers函数会遍历处理target_maps_and_handlers列表中的每一个map与handler，并且会根据当前map是否具有过渡map来进入不同分支，此处列表中的两个map都不存在过渡，所以会直接去执行StoreElementHandler函数，StoreElementHandler函数中会根据store_mode来获取具体的code，而store_mode在前面已经提到过是通过当前正在处理的对象，也就是Array对象获取到的STORE_AND_GROW_HANDLE_COW，所以在遍历中无论是处理Arguments map还是处理Array map都是用STORE_AND_GROW_HANDLE_COW模式来获取code：
最后得到一个结构如下的feedback，0是arguments对象的map，1为STORE_AND_GROW_HANDLE_COW模式的code，2为Array对象的map，3同1一样也是STORE_AND_GROW_HANDLE_COW模式的code:
最后在执行set(arguments, 0, 1)时由于COW(写入时拷贝)的原因当在具体向arguments对象elelments写入内容时会将elements中的内容完整的拷贝到一块新的elements中并将要写入的内容写入。最后通过arguments[1]越界读取内容时就会将hole错误的读出来导致hole泄露。
而在官方的patch中的修复方案也比较简单，当在StoreElementHandler遇到arguments map并且elements是PACKED_ELEMENTS时，直接不使用外部传入的store_mode，而是直接用标准存储模式STANDARD_STORE：
利用 可以在存在此漏洞的老版本上参考2021-38003的利用方法，也可以参考之后版本的一种新的利用方法2023-2033
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/863909c19737388c228d4f3e6fdaa096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a175aa65653c0635b4c41269ffd9b9db/" rel="bookmark">
			【计算机视觉 | 图像模型】常见的计算机视觉 image model（CNNs &amp; Transformers） 的介绍合集（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Co-Scale Conv-attentional Image Transformer（CoaT）二、Pyramid Vision Transformer v2(PVTv2)三、Class-Attention in Image Transformers（CaiT）四、PoolFormer五、ScaleNet六、VoVNet七、Siamese U-Net八、Single-path NAS九、XCiT十、CrossViT十一、PeleeNet十二、ConViT十三、CrossTransformers十四、SKNet十五、SqueezeNeXt 一、Co-Scale Conv-attentional Image Transformer（CoaT） Co-Scale Conv-Attentional Image Transformer (CoaT) 是一种基于 Transformer 的图像分类器，配备了 co-scale 和 conv-attention 机制。 首先，共尺度机制保持了 Transformers 编码器分支在各个尺度上的完整性，同时允许在不同尺度上学习的表示有效地相互通信。 其次，通过在因子化注意力模块中实现相对位置嵌入公式来设计卷积注意力机制，并采用高效的类似卷积的实现。 CoaT 为图像 Transformers 提供了丰富的多尺度和上下文建模功能。
二、Pyramid Vision Transformer v2(PVTv2) Pyramid Vision Transformer v2 (PVTv2) 是一种用于检测和分割任务的 Vision Transformer。 它通过多项设计改进对 PVTv1 进行了改进：(1) 重叠补丁嵌入，(2) 卷积前馈网络，以及 (3) 与 PVTv1 框架正交的线性复杂性注意层。
三、Class-Attention in Image Transformers（CaiT） CaiT（图像变换器中的类注意力）是一种视觉变换器，在原始 ViT 的基础上进行了一些设计更改。 首先使用一种称为 LayerScale 的新层缩放方法，在每个残差块的输出上添加可学习的对角矩阵，初始化为接近（但不是）0，从而提高了训练动态。 其次，该架构中引入了类注意层。 这创建了一个架构，其中涉及补丁之间自注意力的变换器层与类注意力层明确分离——类注意力层致力于将处理后的补丁的内容提取到单个向量中，以便可以将其馈送到线性分类器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a175aa65653c0635b4c41269ffd9b9db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e836a15b2ee568a2a29660c0edf06cf/" rel="bookmark">
			家庭智慧助手项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.上位机开发 上位机主要就是Qt开发，编写代码逻辑和功能实现。
2.下位机开发 下位机负责驱动代码的编写，给应用层提供接口。
3.服务器开发 服务器分为MQTT服务器和TCP服务器，MQTT服务器主要用于发布和订阅消息的，还有将数据写入数据库中；TCP服务器用来做登录和验证的，处理一些上位机发送过来的请求。
视频效果链接：编程vlog_哔哩哔哩_bilibili 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d8851b8a4ddf7944da4c7fa3b1b353/" rel="bookmark">
			MySQL 导出和导入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一，导出数据（一）使用SELECT ... INTO OUTFILE语句导出数据（二）使用mysqldump工具导出数据（三）使用SELECT ... INTO DUMPFILE语句导出数据 二，导入数据（一）使用 LOAD DATA 导入数据（二）使用 mysqlimport 导入数据（三）mysqlimport的常用选项 一，导出数据 MySQL导出数据的主要作用是将数据库中的数据以某种格式（如CSV、SQL等）导出到一个文件中，以便在需要时进行导入或备份。
导出数据的作用包括但不限于以下几个方面：
数据备份：导出数据可以将数据库中的数据备份到文件中，以防止数据丢失或意外删除。数据迁移：如果需要将数据库从一个服务器迁移到另一个服务器，可以将数据导出到文件中，然后在目标服务器上导入数据。数据共享：如果需要与其他人共享数据库中的数据，可以将数据导出到CSV等通用格式的文件中，然后将其发送给其他人。数据分析：如果需要对数据库中的数据进行分析或处理，可以将其导出到文件中，然后使用其他工具（如Excel、Python等）进行处理。 （一）使用SELECT … INTO OUTFILE语句导出数据 SELECT … INTO OUTFILE语句是MySQL中用于将查询结果导出为CSV文件的方法。它允许您将查询结果保存到指定的文件路径中，以便进行后续处理或备份。
示例：
假设我们有一个名为"users"的表格，其中包含用户的姓名、年龄和电子邮件地址。要导出这些数据到一个CSV文件中，可以使用以下语句：
SELECT * INTO OUTFILE '/path/to/output/file.csv' FIELDS TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY '\n' FROM users; 这将导出"users"表中的所有数据，并将其保存到指定路径的CSV文件中。文件中的每行代表一个用户，每个字段用逗号分隔，并用双引号包围。
参数说明：
INTO OUTFILE 'file_path': 指定要导出数据的文件路径。可以是本地路径或Web服务器上的路径。FIELDS TERMINATED BY 'delimiter': 指定字段之间的分隔符。默认情况下使用制表符（\t）作为分隔符。ENCLOSED BY 'enclosure': 指定字段内容的引号包围符号。默认情况下不使用引号包围。LINES TERMINATED BY 'line_break': 指定每行数据之间的分隔符。默认情况下使用换行符（\n）作为行分隔符。FROM table_name: 指定要导出数据的表格名称。 注意事项：
使用SELECT … INTO OUTFILE语句导出数据需要具有相应的权限。确保您具有足够的权限来执行此操作。导出的文件路径必须是MySQL服务器可以访问的路径。如果路径无法访问，您将无法导出数据。如果指定的文件已经存在，将会覆盖该文件。请确保在导出数据之前备份重要的文件。 （二）使用mysqldump工具导出数据 mysqldump是MySQL数据库的一个命令行工具，用于备份和导出数据库、表格和数据。以下是使用mysqldump工具导出数据的基本语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50d8851b8a4ddf7944da4c7fa3b1b353/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de62bb4fa5d25cf8734eddc12855b0ca/" rel="bookmark">
			解决报错：Module not found: Error: ‘element-plus/lib/theme-chalk/index.css 和 Can‘t resolve...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当在使用element-plus的icon时有以下两种报错的解决方法
报错1：
解决方法：打开 element.js 文件（路径为 src &gt; plugins &gt; element.js）
// 将文件中的两条数据都改了: import 'element-plus/lib/theme-chalk/index.css' import locale from 'element-plus/lib/locale/lang/zh-cn' // 改为: import 'element-plus/theme-chalk/index.css' // 直接将该条的 lib 去除即可，否则会报错 import locale from 'element-plus/es/locale/lang/zh-cn' // 将 lib 换成 es 当报以下错误时
解决方法：打开 element.js 文件
将文件中的
import 'element-plus/es/theme-chalk/index.css'
改为
import 'element-plus/theme-chalk/index.css'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea080917554faa4ecb488808dff1708/" rel="bookmark">
			2023年最适合0基础上手的—学生管理系统制作，另赠福利：GUI学生管理系统源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
嗨喽~大家好呀，这里是小曼呐 ❤ ~!
环境使用:
python3.8解释器Pycharm 编辑器 可领取福利:
GUI学生管理系统源码
代码展示
从学生信息数据库&lt;文本文件&gt;里面读取数据
f = open('学生信息.txt', encoding='utf-8') info_list = f.readlines() 创建一个空列表
student_info = [] for循环遍历, 把列表里面元素一个一个提取出来
遇到问题没人解答？可以加小曼vx：python10010 发送验证时记得备注 “M”噢（这样小曼才知道是我的粉丝哦） 寻找有志同道合的小伙伴，互帮互助,还给大家准备了有不错的视频学习教程和PDF电子书！ for info in info_list: """ str.replace('\n', '') 字符串替换方法, 把\n替换成空的 str.split(',') 字符串分割方法, 以 , 作为分割, 把字符串分割成列表 """ content = info.replace('\n', '').split(',') 创建字典
dit = { '姓名': content[0], '语文': content[1], '数学': content[2], '英语': content[3], '总分': content[4], } 列表添加元素
student_info.append(dit) 读取出来, 并且整理好数据内容, 列表数据容器, 把所有信息放到里面存储
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea080917554faa4ecb488808dff1708/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1432aaf2dc9a6d06cd4ddea23d45768c/" rel="bookmark">
			项目实战— pytorch搭建CNN处理MNIST数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目文件夹介绍 项目文件夹 CNN_MNIST_practice文件夹是整个项目的文件夹，里面存放了六个子文件夹以及四个 .py 程序，接下来我们分别来介绍这些文件的内容。
其中 minist_all_CPU.py 是CPU版本的模型训练＋测试程序，而 minist_all_GPU.py 则是GPU版本的模型训练＋测试程序。
minist_convert_png.py 是将MNIST数据集中的训练集和测试集转换为图像的程序。test_minist_nine.py 是用于测试一个手写数字 2 的程序。
pixel_show文件夹中包含了一个程序和一个 .txt 文件，该程序用于将某一个图片进行像素化展示，该文件夹中的程序名为: pixel_show.py；.txt 文件中包括了对这个要进行像素化展示的图片每个像素点的值。
pixel_show文件夹 model与model_GPU 两个文件夹中包括了训练好的模型，共训练了五轮。其中model文件夹中存放的是CPU版本的模型，而model_GPU文件夹存放的是GPU版本的模型。
训练好的模型及优化器模型 MNIST文件夹包括了MNIST数据集所有信息，这其中也包括了转换好的图片部分。 batch_size_graph_show文件夹中包括了一个名为 batch_show.py 的程序，该程序用于绘制某一个batch_size的图像。
数据集介绍 MNIST数据集
MNIST数据集（Mixed National Institute of Standards and Technology database）是一个用来训练各种图像处理系统的二进制图像数据集，广泛应用于机器学习中的训练和测试。
MNIST数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST)。训练集（training set）由来自250个不同人手写的数字构成，其中50%是高中学生，50%来自人口普查局（the Census Bureau）的工作人员。测试集（test set）也是同样比例的手写数字数据，但保证了测试集和训练集的作者集不相交。
MNIST数据集一共有7万张图片，其中6万张是训练集，1万张是测试集。每张图片是28 × 28 28的 0 − 9 的手写数字图片组成。每个图片是黑底白字的形式，黑底用0表示，白字用0-1之间的浮点数表示，越接近1，颜色越白。
MNIST数据集下载地址是http://yann.lecun.com/exdb/mnist/，它包含了 4 个部分：
训练数据集：train-images-idx3-ubyte.gz （9.45 MB，包含60,000个样本）。
训练数据集标签：train-labels-idx1-ubyte.gz（28.2 KB，包含60,000个标签）。
测试数据集：t10k-images-idx3-ubyte.gz（1.57 MB ，包含10,000个样本）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1432aaf2dc9a6d06cd4ddea23d45768c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e2bde307f8fe55b4fc1aec578bfff0/" rel="bookmark">
			【docker】在windows下使用ssh连接docker并且在dockers里边在跑一个docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在windows下使用ssh连接docker并且在dockers里边在跑一个docker 开始准备(不想自己构建的直接看下一步)启动容器并使用ssh连接使用cmd连接docker 开始准备(不想自己构建的直接看下一步) 拉取官方镜像 这里用到的是centos7.9 docker pull centos:7.9
进入到镜像安装常用工具 docker run -it centos:7.9 bash
# 更新yum yum -y update # 安装vim yum install vim # 安装ssh yum install openssh-server # 修改配置 vim /etc/ssh/sshd_config # 取消以下注释 # PermitRootLogin yes # Port=22 # docker 安装 #安装工具包 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 yum install docker-ce docker-ce-cli containerd.io # 安装docker-compose yum -y install epel-release yum install python-pip wget https://github.com/docker/compose/releases/download/1.14.0-rc2/docker-compose-Linux-x86_64 mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose -version # 修改root密码 yum install passwd # 设置root初始密码 passwd root # 输入你的密码 打包成新的镜像方便以后使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1e2bde307f8fe55b4fc1aec578bfff0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4dae474776ee12566640f2e5b9636e9/" rel="bookmark">
			STM32F103 外部中断（EXTI）介绍以及代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 外部中断/事件控制器由19个产生事件/中断要求的边沿检测器组成。每个输入线可以独立地配置输入类型(脉冲或挂起)和对应的触发事件(上升沿或下降沿或者双边沿都触发)。每个输入线都可以被独立的屏蔽。挂起寄存器保持着状态线的中断要求。
对以上序号进行说明：
①InputLine：外部信号输入线，总共有 19 个来源，分别是 GPIO0~15（总共 16 个），正好连接到 EXTI0~15，EXTI16 连接到 PVD 输出，EXTI17 连接到 RTC 闹钟事件，EXTI18 连接到 USB，所以 /19 代表 19 个通道
②Edge Detect ：边缘检测，可以是上升沿触发，也可以是下降沿触发，还可以是上升沿和下降沿都可以分别触发，对应图中 ②-1 和 ②-2
③Software interrupt event register：软件中断事件寄存器
④Pending request register：挂起寄存器
⑤interrupt mask register：中断屏蔽寄存器
整个外部中断的流程是这样的
1、选择外部信号输入线
2、信号选择以什么方式来触发，可以是上升沿或下降沿等
3、信号经过或门到 Pending request register，如果发生了触发，该寄存器的 PRx 位将置 1
4、最后，整个信号和中断屏蔽寄存器经过与门到 NVIC，这要求中断屏蔽寄存器必须置 1
如果用 GPIO 作为外部中断，需要配置 AFIO，来选择是哪个端口，可以是 GPIOA/GPIOB/GPIOC/GPIOD/GPIOE/GPIOF/GPIOG,需要注意的是，对于同一个 Pin 脚，只能选择配置一个端口，例如我配置 Pin15 为 GPIOC，那么就不能再用用 GPIOA/B/D/E/F/G 15 作为 EXTI ，如下图所示
代码设计思路：
1、初始化 GPIOC15 为下拉输入模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4dae474776ee12566640f2e5b9636e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ebdceef53678c023870058cb7ef433f/" rel="bookmark">
			K8S：Pod概念、分类及相关的策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.pod相关概念１.Pod基础概念２.Kubrenetes集群中Pod两种使用方式３.pause容器的Pod中的所有容器共享的资源４.kubernetes中的pause容器主要为每个容器提供功能：５.Kubernetes设计这样的Pod概念和特殊组成结构有什么用意６.Pod分为两类： 二.Pod容器的分类1.基础容器（infrastructure container）（1）作用（2）配置 2.初始化容器（initcontainers）（1）概念（2）Init 容器与普通的容器的差异（3）Init 的容器作用 3、应用容器（Maincontainer）（1）概念（2）示例 三.镜像拉取策略（image PullPolicy）1.概念2.用户指定的方式 四.重启策略1.重启策略概念2.重启策略分类3.重启策略示例 五.部署harbor创建私有项目1.部署前操作2.部署 Harbor 服务3.在 Harbor 中创建一个新项目4.登录测试5.创建凭证并查看上传镜像 一.pod相关概念 １.Pod基础概念 Pod是kubernetes中最小的资源管理组件，Pod也是最小化运行容器化应用的资源对象。一个Pod代表着集群中运行的一个进程。kubernetes中其他大多数组件都是围绕着Pod来进行支撑和扩展Pod功能的，例如，用于管理Pod运行的StatefulSet和Deployment等控制器对象，用于暴露Pod应用的Service和Ingress对象，为Pod提供存储的PersistentVolume存储资源对象等。
总：pod是k8s 最小的创建和运行单元 ２.Kubrenetes集群中Pod两种使用方式 （１）一个Pod中运行一个容器。“每个Pod中一个容器”的模式是最常见的用法；在这种使用方式中，你可以把Pod想象成是单个容器的封装，kuberentes管理的是Pod而不是直接管理容器。
（２）在一个Pod中同时运行多个容器。一个Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器可以互相协作成为一个service单位，比如一个容器共享文件，另一个“sidecar”容器来更新这些文件。Pod将这些容器的存储资源作为一个实体来管理。
一个Pod下的容器必须运行于同一节点上。现代容器技术建议一个容器只运行一个进程，该进程在容器-中PID命令空间中的进程号为1，可直接接收并处理信号，进程终止时容器生命周期也就结束了。若想在容器内运行多个进程，需要有一个类似Linux操作系统init进程的管控类进程，以树状结构完成多进程的生命周期管理。运行于各自容器内的进程无法直接完成网络通信，这是由于容器间的隔离机制导致，k8s中的Pod资源抽象正是解决此类问题，Pod对象是一组容器的集合，这些容器共享Network、UTS及IPC命令空间，因此具有相同的域名、主机名和网络接口，并可通过IPC直接通信。
Pod资源中针对各容器提供网络命令空间等共享机制的是底层基础容器pause，基础容器（也可称为父容器）pause就是为了管理Pod容器间的共享操作，这个父容器需要能够准确地知道如何去创建共享运行环境的容器，还能管理这些容器的生命周期。为了实现这个父容器的构想，kubernetes中，用pause容器来作为一个Pod中所有容器的父容器。这个pause容器有两个核心的功能，一是它提供整个Pod的Linux命名空间的基础。二来启用PID命名空间，它在每个Pod中都作为PID为1进程（init进程），并回收僵尸进程。
总：一个pod包含几个容器————————一个根容器/父容器/基础容器 pod里面容器共享目前使用的经常使用的有：net uts ipc 命名空间 除此之外还有mnt、pid、user pause容器里面有一个或者多个应用容器/业务容器 ３.pause容器的Pod中的所有容器共享的资源 （１）网络：
每个Pod都会被分配一个唯一的IP地址。Pod中的所有容器共享网络空间，包括IP地址和端口。Pod内部的容器可以使用localhost互相通信。Pod中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。
（２）存储：
Pod可以指定多个共享的Volume。Pod中的所有容器都可以访问共享的Volume。Volume也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失。
总：每个Pod都有一个特殊的被称为“基础容器”的Pause容器。Pause容器对应的镜像属于Kubernetes平台的一部分，除了Pause容器，每个Pod还包含一个或者多个紧密相关的用户应用容器。 ４.kubernetes中的pause容器主要为每个容器提供功能： （１）在pod中担任Linux命名空间（如网络命令空间）共享的基础；
（２）启用PID命名空间，开启init进程。
５.Kubernetes设计这样的Pod概念和特殊组成结构有什么用意 （１）原因一：在一组容器作为一个单元的情况下，难以对整体的容器简单地进行判断及有效地进行行动。比如，一个容器死亡了，此时是算整体挂了么？那么引入与业务无关的Pause容器作为Pod的基础容器，以它的状态代表着整个容器组的状态，这样就可以解决该问题。
（２）原因二：Pod里的多个应用容器共享Pause容器的IP，共享Pause容器挂载的Volume，这样简化了应用容器之间的通信问题，也解决了容器之间的文件共享问题。
６.Pod分为两类： ●自主式Pod
这种Pod本身是不能自我修复的，当Pod被创建后（不论是由你直接创建还是被其他Controller），都会被Kuberentes调度到集群的Node上。直到Pod的进程终止、被删掉、因为缺少资源而被驱逐、或者Node故障之前这个Pod都会一直保持在那个Node上。Pod不会自愈。如果Pod运行的Node故障，或者是调度器本身故障，这个Pod就会被删除。同样的，如果Pod所在Node缺少资源或者Pod处于维护状态，Pod也会被驱逐。
●控制器管理的Pod
Kubernetes使用更高级的称为Controller的抽象层，来管理Pod实例。Controller可以创建和管理多个Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个Node故障，Controller就能自动将该节点上的Pod调度到其他健康的Node上。虽然可以直接使用Pod，但是在Kubernetes中通常是使用Controller来管理Pod的。
总：k8创建pod分为两种： （1）自主式/静态pod：不被控制器管理的pod，没有自愈能力，一旦pod挂了，不会被重新拉起，而且副本数量也不会因为达不到期望值而创建新的pod （2）控制器管理的pod：被控制器管理的pod，有自愈能力，一旦pod挂了，会重新拉起，而且副本数量会因为达不到期望值而创建新的pod 二.Pod容器的分类 1.基础容器（infrastructure container） （1）作用 维护整个 Pod 网络和存储空间
（2）配置 #node 节点中操作 #启动一个Pod时，k8s会自动启动一个基础容器 cat /opt/kubernetes/cfg/kubelet ...... --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google-containers/pause-amd64:3.0" #每次创建 Pod 时候就会创建，运行的每一个Pod都有一个 pause-amd64 的基础容器自动会运行，对于用户是透明的 docker ps -a registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ebdceef53678c023870058cb7ef433f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d2cd462293c0d8dda19825460732cf3/" rel="bookmark">
			k8s集群中部署服务之Dockerfile文件准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务项目各微服务Dockerfile文件准备 一、获取jar的方法 二、各微服务Dockerfile文件准备 2.1 mall-auth FROM openjdk:8 ENV TZ Asia/Shanghai EXPOSE 30000 VOLUME /tmp ADD target/*.jar /app.jar ENTRYPOINT ["java","-jar","/app.jar"] 2.2 mall-cart FROM openjdk:8 ENV TZ Asia/Shanghai EXPOSE 22200 VOLUME /tmp ADD target/*.jar /app.jar ENTRYPOINT ["java","-jar","/app.jar"] 2.3 mall-coupon FROM openjdk:8 ENV TZ Asia/Shanghai EXPOSE 8010 VOLUME /tmp ADD target/*.jar /app.jar ENTRYPOINT ["java","-jar","/app.jar"] 2.4 mall-gateway FROM openjdk:8 ENV TZ Asia/Shanghai EXPOSE 8072 VOLUME /tmp ADD target/*.jar /app.jar ENTRYPOINT ["java","-jar","/app.jar"] 2.5 mall-member FROM openjdk:8 ENV TZ Asia/Shanghai EXPOSE 20300 VOLUME /tmp ADD target/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d2cd462293c0d8dda19825460732cf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7596b4c06d48e5e6668691aa990415c0/" rel="bookmark">
			Mann-Kendall 检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、M-K 趋势检验 Mann-Kendall 突变检验是一种非参数的假设检验方法，用于检验时间序列数据中的趋势性变化。该检验方法通过比较每个数据点与其之前数据点的大小，来检测时间序列数据中的单调趋势（上升、下降或没有趋势）。具体来说，Mann-Kendall测试将时间序列中的每个数据点与所有之前的数据点进行比较，计算出每个数据点之前比它小的数据点数目和比它大的数据点数目，然后比较这两个数量的大小关系，以确定是否存在单调趋势。
Mann-Kendall检验的优点是不需要对数据进行任何假设，可以用于各种类型的时间序列数据，包括非正态数据。但是它的缺点是无法检测出具体的趋势形式，如线性、非线性等。此外，它对时间序列数据中的周期性变化不敏感。
当Z的绝对值大于等于1.64、 1.96、 2.58时则说明该时间序列分别通过了置信水平90%、95%、99%的显著性检验。
import numpy as np from scipy.stats import norm def mann_kendall_test(x): """ Mann-Kendall trend test for a given data sequence x. Args: x: A list or numpy array of data sequence. Returns: trend: The calculated trend (positive, negative or no trend). p_value: The p-value of the test. """ n = len(x) s = 0 for i in range(n - 1): for j in range(i + 1, n): s += np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7596b4c06d48e5e6668691aa990415c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af5676402ea90ae665e73821574f5735/" rel="bookmark">
			从零入门激光SLAM（一）——什么是SLAM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好呀，我是一个SLAM方向的在读博士，深知SLAM学习过程一路走来的坎坷，也十分感谢各位大佬的优质文章和源码。随着知识的越来越多，越来越细，我准备整理一个自己的激光SLAM学习笔记专栏，从0带大家快速上手激光SLAM，也方便想入门SLAM的同学和小白学习参考，相信看完会有一定的收获。如有不对的地方欢迎指出，欢迎各位大佬交流讨论，一起进步。 博主创建了一个科研互助群Q：772356582，欢迎大家加入讨论。 1.什么是SLAM SLAM的全称是Simultaneous Localization and Mapping即时定位与地图构建，为解决机器人自主导航的问题。人在一个未知的环境下也不知如何行进，我们闭着眼睛也不知道怎么走路，机器人如人一样，也需要一个“眼睛”与环境之间交互知道自己的位置，并且能够建立一个地图来让机器人自主导航。如下图所是，相机相当于我们的眼睛，激光雷达像是成千上万个很长的拐棍去勘测障碍物，地图相当于我们日常用的导航地图。机器人有了这些东西就可以进行走路（决策、规划、控制）。
在过去的十年里，SLAM问题的解决方案一直是机器人邻域最显著的成就之一。SLAM作为一种理论方法，它被以多种不同形式的方式被提出并解决，它被广泛的应用到了室内、室外、水下和空中等的环境中。同时SLAM技术对于无人驾驶来说是一项必不可少的技术。在GPS精度差，信号不稳定的环境中，SLAM技术是实现自主导航的前提。
现在你只需要知道SLAM问题可以分为以下两部分：
Localization：在给定地图的情况下，估计机器人的位姿；
Mapping：在给定机器人位姿的情况下，估计环境地图；
2.SLAM发展历程 2.1传统时代 Classical Age(1986-2004):SLAM问题的提出，并将该问题转换为一个状态估计问题，利用扩展卡尔曼滤波、粒子滤波及最大似然估计等手段来求解。第一个挑战是效率和数据关联（求解位姿）的鲁棒性问题。
2.2算法分析时代 algorithmic-analysis age: (2004-2015)研究SLAM的基本特性，包括观测性、收敛性和一致性。研究者们理解了稀疏特征在高效SLAM解决方案中的重要角色，开发了主要开源SLAM库。
2.3鲁棒性-预测性时代 robust-perception（2015-）：鲁棒性、高级别的场景理解，多传感器融合，计算资源优化，任务驱动的环境感知。
2.4未来发展 未来SLAM的发展方向可以归结为以下几点：
（1）解决鲁棒性问题
（2）基于监督学习的特征点提取方法
（3）基于监督学习的图像深度估计
（4）基于无监督学习图像深度与里程计估计
（5）语义地图的建立与表达
（6）主动式SLAM
（7）基于新的非传统的传感器的SLAM
（8）多节点车路协同下的SLAM
在理论和概念层面上，SLAM现在可以被认为是一个已解决的问题了。然而，在实际实现更通用的SLAM解决方案方面，尤其是在构建和使用感知丰富的地图作为SLAM算法的一部分方面，仍然存在大量棘手的问题。例如一个地下车库停车的SLAM场景就需要在已有的SLAM算法基础上进行优化和多传感器融合才能达到不错的效果。
3.SLAM种类 3.1 SLAM种类介绍 SLAM的种类与传感器的发展息息相关，最开始的图像SLAM到后面的激光SLAM。近年来，随着激光雷达、摄像机、惯性测量单元等传感器的快速发展，SLAM技术应运而生。常见的SLAM分类有激光SLAM、视觉SLAM、多传感器融合SLAM和基于深度学习的SLAM。
各传感器的特点也决定了各种SLAM算法的特点，下面将简单介绍一下常见传感器的优缺点。
激光雷达：机械、固态、混合
优点：精度高、频率快、不受光线影响、计算量小
缺点：成本高、信息量有限、功耗大
摄像头：单目、双目、RGB-D相机、全景相机
优点：便宜、体积小、信息丰富
缺点：计算量大、易受干扰、对环境假设强
惯性测量单元：IMU、轮速计
优点：可以测量出载体的加速度和角加速度，结合数学方法快速计算出载体的位置和姿态信息。
缺点：随着时间增加会有漂移误差
3.2激光雷达简介 本专栏将围绕激光SLAM的基础展开，激光SLAM即是围绕激光雷达为主传感器进行感知的算法。激光雷达目前主要分为机械式和固态式，那么下面就介绍一下激光雷达是什么。
机械激光雷达
机械激光雷达体积更大，总体来说价格更为昂贵，但测量精度相对较高。机械激光雷达的工作原理是利用激光束在周围环境中反射并返回到传感器的时间来确定距离。当激光束照射到一个物体上时，它会被反射回传感器，并且传感器可以通过测量返回的激光脉冲的时间来计算物体的距离。通过不断旋转反射镜，激光束可以在水平和垂直方向上扫描周围环境，并创建出物体的三维点云图，通常可以扫描360度。
来一个通俗点的解释，想像出一个竖起来的梳子，每个梳齿向外发射激光并接收，现在让它旋转起来，每一个梳齿都会扫描一圈，有多少个梳齿就是我们常说的多少线激光雷达。下图右上的图是点云投影到图片的，可以看到像梳子一样一条一条排列的，右下是一帧的三维点云。
固态激光雷达
固态激光雷达尺寸较小，成本低，但测量精度相对会低一些。一些非完全旋转的激光雷达也被统称为“固态激光雷达”，它们具备了固态激光雷达很多的性能特点，如分辨率高、有限水平FOV（前向而不是360°）等。
固态激光雷达则采用固态光电元件，如半导体激光器和光电探测器，代替了机械部件，从而提高了可靠性和稳定性。固态激光雷达的工作原理与机械激光雷达类似，也是利用激光束发射并接收反射回来的信号来测量距离，但其发射和接收是由固态电路实现的，可以通过电子控制来调整激光束的方向和强度。这种激光雷达具有更快的测量速度和更高的精度，但由于使用了固态光电元件，其成本相对较高。
因此，机械激光雷达和固态激光雷达的主要区别在于技术实现方式，机械激光雷达需要旋转部件来扫描整个场景，而固态激光雷达使用固态电路来控制激光束的方向和强度。下图是livox的avia的工作原理，点云形状像是一朵花。
真实用起来点云是这样的：
利用光学相控阵扫描技术的固态激光雷达的确有很多优势，例如：
①其结构简单，尺寸小，无需旋转部件，在结构和尺寸上可以大大压缩，提高使用寿命并使其成本降低。
②扫描精度高，光学相控阵的扫描精度取决于控制电信号的精度，可以达到千分之一度量级以上。
③可控性好，在允许的角度范围内可以做到任意指向，可以在重点区域进行高密度的扫描。
④扫描速度快，光学相控阵的扫描速度取决于所用材料的电子学特性，一般都可以达到MHz量级。
当然固态激光雷达也同样存在一些劣势，如：
①扫描角有限，固态意味着激光雷达不能进行360度旋转，只能探测前方。因此要实现全方位扫描，需在不同方向布置多个（至少前后两个）固态激光雷达
②旁瓣问题，光栅衍射除了中央明纹外还会形成其他明纹，这一问题会让激光在最大功率方向以外形成旁瓣，分散激光的能量。
③加工难度高，光学相控阵要求阵列单元尺寸必须不大于半个波长，一般目前激光雷达的工作波长均在1微米左右，故阵列单元的尺寸必须不大于500nm。而且阵列密度越高，能量也越集中，这都提高了对加工精度的要求，需要一定的技术突破。
④接收面大、信噪比差：传统机械雷达只需要很小的接收窗口，但固态激光雷达却需要一整个接收面，因此会引入较多的环境光噪声，增加了扫描解析的难度。
3.3 激光SLAM 上面说了那么多，总算引出我们的主角激光SLAM，激光SLAM就是根据前后帧之间的点云匹配，估算出位姿，再根据点云和计算出的位姿进行建图。下图就是两个点云进行匹配，具体算法后面会介绍，现在只需要知道位姿是通过点云匹配计算来的就好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af5676402ea90ae665e73821574f5735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f5ea3b47303c1c4f162c174caf2069/" rel="bookmark">
			异步fifo格雷码的sdc问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异步fifo的格雷码的约束核心在于各个bit走线延时的skew，也就是set_max_delay-set_min_delay，保证各个bit的走线尽可能一致。
为什么会有这样的要求？这个问题的根源在于为什么使用格雷码，格雷码的好处很明显，也就是相邻两位最多有1bit不同，那么对应到fifo中，指针都是逐一递增或者逐一递减的，
不设置max_delay的影响，最大的影响就是上面所提到的，数据错乱导致功能完全不能用，这里其实还暗含着一个问题，也就是性能下降的问题，如果格雷码走线延时太大，几个cycle，就会导致异步fifo可用的时间滞后，造成性能下降，极限的情况，delay3个cycle，深度为2，这也是不能使用的了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a49b5b870119505e0960a413d1ce22a9/" rel="bookmark">
			【仿牛客论坛java项目】第七章1 项目进阶，构建安全高效的企业服务：Spring Security、权限控制、置顶、加精、删除、Redis高级数据类型、网站数据统计、任务执行和调度热帖排行生成长图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Spring Security基本原理导入依赖测试结果 二、权限控制1、登录检查2、授权配置404——HomeController权限授权——SecurityConfig 3、认证方案获得用户权限——UserService构建用户认证的结果存入SecurityContext——LoginTicketInterceptor 4、CSRF配置CSRF攻击异步情况 三、置顶、加精、删除1、功能实现导入包数据访问层dao——DiscussPostMapper业务层service——DiscussPostService表现层controller——DiscussPostController消费删帖事件——EventConsumer处理页面——discuss-detail.html 2、权限管理SecurityConfig测试 3、按钮显示discuss-detail.html测试 四、Redis高级数据类型RedisTests统计20万个重复数据的独立总数将3组数据合并, 再统计合并后的重复数据的独立总数 查看内存使用情况RedisTests统计一组数据的布尔值统计3组数据的布尔值, 并对这3组数据做OR运算 五、 网站数据统计1、redis数据RedisKeyUtil 2、业务层DataService拦截器——DataInterceptor 3、表现层DataController页面——data.html 测试 六、任务执行和调度1、基础知识JDK线程池Spring线程池分布式定时任务 2、线程演示——ThreadPoolTestsapplication.propertiesThreadPoolConfig.java 3、 Spring Quartz依赖导入表格详情AlphaJob对AlphaJob进行配置——QuartzConfig测试删除数据——QuartzTests 七、热帖排行1、Redis——RedisKeyUtil2、影响帖子分数的操作DiscussPostController评论——CommentController点赞——LikeController 3、算分数——PostScoreRefreshJob补充更新分数方法 4、做配置——QuartzConfig5、最热帖子排序数据访问层DiscussPostMapperdiscusspost-mapper.xml 业务层方法——HomeController表现层——index.html 八、生成长图—wkhtmltopdf1、测试wkhtmltopdf生成pdf生成图片生成压缩图片在java中生成图片 2、配置wkhtmltopdfapplication.propertiesWkConfig 3、实现wkhtmltopdf分享请求——ShareController消费分享事件——EventConsumer 4、测试 一、Spring Security 基本原理 Spring Security 底层原理比较难11个filterSpring Security 管理整个系统推荐学习网站：www.spring4all.com，网站 导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 生成随机页面
重定向
转发
测试结果 二、权限控制 1、登录检查 之前采用拦截器实现了登录检查，这是简单的权限管理方案，现在将其废弃。在WebMvcConfigurer中，将登录拦截方法去掉
2、授权配置 对当前系统内包含的所有的请求，分配访问权限（普通用户、版主、管理员）。 没有权限，跳404
404——HomeController /** * 没有权限，跳404 * @return */ @RequestMapping(path = "/denied", method = RequestMethod.GET) public String getDeniedPage() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a49b5b870119505e0960a413d1ce22a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9731d8de745d8cac1d2808b256ebcbc2/" rel="bookmark">
			Java 中的四种引用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Java 中的四种引用方式1、强引用（Strong Reference）（1）弱化方式1（2）弱化方式2 2、软引用（Soft Reference）3、弱引用（Weak Reference）4、虚引用（Phantom Reference） Java 中的四种引用方式 1、强引用（Strong Reference） 强引用是最普遍的引用当一个对象是强引用，垃圾回收器绝不会回收他当内存不足时，JVM 宁愿抛出 OutOfMemoryError 错误，也不会回收具有强引用的对象，来解决内存不足问题 Object strongReference = new Object(); 如果强引用对象不使用时，需要 弱化从而使 GC 能够回收 （1）弱化方式1 显示的设置 strongReference 对象为null，则 gc 认为该对象不存在引用，这时就可以回收这个对象
如果 strongReference 是 全局变量，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。
strongReference = null; 应用场景：在ArrayList集合类中定义elementData数组，在调用clear()方法清空集合元素时，将每个数组元素被赋值为null。目的是为了将内存数组中存放的引用类型进行内存释放，可以及时释放内存。不选择将elementData=null，是为了避免在后续调用add()等方法添加新元素时，需要进行内存的重新分配
//ArrayList 源码 public void clear() { modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; } （2）弱化方式2 让对象超出作用域范围，即缩小强引用的作用范围
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9731d8de745d8cac1d2808b256ebcbc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3234d10db5b310c8db888e5988b5b46a/" rel="bookmark">
			greenDao分页加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于GreenDao，可以通过使用QueryBuilder和limit()方法来实现分页查询。以下是一个示例代码片段，演示了如何进行分页查询：
int pageSize = 10; // 每页的数据量
int pageNumber = 1; // 页码
DaoSession daoSession = daoMaster.newSession();
// 请确保你已经创建了DaoSession对象 YourEntityDao yourEntityDao = daoSession.getYourEntityDao(); QueryBuilder&lt;YourEntity&gt; queryBuilder = yourEntityDao.queryBuilder(); queryBuilder.offset((pageNumber - 1) * pageSize).limit(pageSize);
List&lt;YourEntity&gt; resultList = queryBuilder.list();
在上面的代码中，我们设置了每页的数据量为10，页码为1。然后，我们使用offset()方法来设置查询的起始位置，即跳过前面的数据条目。最后，使用limit()方法来限制查询结果的数量。通过调用list()方法，我们可以获取到分页查询的结果列表。
请注意，你需要将上述代码片段中的YourEntity替换为你自己的实体类名，同时确保你已经创建了正确的DaoSession和Dao对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78719d4957c152b555b79e12b0f9306/" rel="bookmark">
			用matlab在hfss中建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hfss可以导入vbs语言建模
怎么生成建模的vbs文档？
1.在hfss中建模建一遍
导出建模的vbs，然后笔记本打开vbs，需要改的话直接改。
参考 https://blog.csdn.net/m0_56117494/article/details/128007860 一文
这个方法朴实无华
但是需要写vbs语言，很麻烦
2.matlab编写vbs
还是用vbs，只是在matlab里编辑，通过fprintf和fid 在vbs里加入语句
实际上还是写vbs，如果不知道对应的vbs是什么就完了
和自己在vbs里敲代码没啥区别
3.matlab-hfss-api
当成函数库就行，注意要添加路径才能调用
这里加入了很多简单的hfss开头的函数
嘎嘎好用
这个代码的本质还是写vbs，只不过matlab程序和vbs的对应关系封装到这些函数里了
写完之后打开vbs可以看到生成了和前两种方式一样的vbs
tool→run script
就可以了
分享一个代码案例
close all; clc; addpath(genpath("D:\MATLAB\R2022a\MatlaHFSSApi")); %加入调用api的路径，很重要，不然会报错 false = 0; true = 1; tmpPrjFile = 'E:\NYM\2023.9 HWHUIGENGSI\HFSSVBS\test20230914\Conical_Horn.hfss'; tmpDataFile = 'E:\NYM\2023.9 HWHUIGENGSI\HFSSVBS\test20230914\tmpData.m'; tmpScriptFile = 'E:\NYM\2023.9 HWHUIGENGSI\HFSSVBS\test20230914\Conical_Horn.vbs'; % HFSS Executable Path. hfssExePath = '"C:\Program Files\AnsysEM\HFSS15.0\Win64\hfss.exe"'; fid = fopen('E:\NYM\2023.9 HWHUIGENGSI\HFSSVBS\test20230914\Conical_Horn_18GHz.vbs', 'wt'); % 'wt'表示以文本模式打开文件，可写，覆盖原有内容 % 创建一个新的工程并插入一个新的设计 hfssNewProject(fid); hfssInsertDesign(fid, 'Conical_Horn'); f = 18; %GHZ hfssaddVar(fid,'f0',f,[]) f1 = 14; f2 = 22; lambda_in = '1in*300/f0 /25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78719d4957c152b555b79e12b0f9306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ff2b17bceec4c5a4d221b58ef81ad5/" rel="bookmark">
			Vue前端框架12 组件生命周期、生命周期的应用、动态组件、组件保持存活、异步组件、依赖注入、Vue应用原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、组件生命周期二、生命周期的应用三、动态组件四、组件保持存活五、异步组件六、依赖注入七、Vue应用 一、组件生命周期 每个Vue组件在创建时需要经历一系列的初始化步骤，比如设置侦听，编译模板，挂载实例到DOM，或者数据改变时更新DOM。
在这个过程中，也会运行生命周期钩子函数，可以让我们在特定阶段运行自己的代码。
&lt;template&gt; &lt;h3&gt;组件的生命周期&lt;/h3&gt; &lt;p&gt;{{message}}&lt;/p&gt; &lt;button @click="updateMessage"&gt;更新数据&lt;/button&gt; &lt;/template&gt; &lt;script&gt; /** * 生命周期函数分为四个时期 * 创建期：beforeCreate、created * 挂载期：beforeMount、mounted * 更新期：beforeUpdate、updated * 销毁期：beforeUnmount、unmounted */ export default { name: 'App', data(){ return{ message:"更新之前" } }, methods:{ updateMessage(){ this.message="更新之后" } }, beforeCreate(){ console.log("组件创建之前") }, created(){ console.log("组件创建") }, beforeMount(){ console.log("组件挂载之前") }, mounted(){ console.log("组件挂载") }, beforeUpdate(){ console.log("组件更新之前") }, updated(){ console.log("组件更新") }, beforeUnmount(){ console.log("组件销毁之前") }, unmounted(){ console.log("组件销毁") } } &lt;/script&gt; 二、生命周期的应用 主要俩个应用：
1、通过ref获取元素DOM结构
2、模拟网络请求渲染数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4ff2b17bceec4c5a4d221b58ef81ad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/274cb8afe9181b403189b6305516a1ac/" rel="bookmark">
			xargs 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xargs 命令是 Unix 系统中一个功能强大的实用工具，它允许用户从标准输入中**参数并执行命令。它经常与其他命令一起使用，例如 find，grep，ls 等等。
以下是一些 xargs 命令的常用选项和示例的解释：
-n：指定每次执行命令使用的最大参数数量。例如，xargs -n 1 command 将逐个执行 command 的一个参数。-I：将命令中指定的占位符字符串替换为标准输入中的参数。例如，xargs -I {} command {} 将使用标准输入中的参数替换 {}。-t：在执行命令之前将要执行的命令打印到标准错误输出。例如，xargs -t command 将在执行命令之前打印要执行的命令。-p：在执行每个命令之前提示用户确认。例如，xargs -p command 将在执行每个命令之前提示用户确认。-0：指定输入项以空字符而不是空格分隔。当处理包含空格或其他特殊字符的文件名时，这非常有用。例如，find . -name '*.txt' -print0 | xargs -0 command 将在所有以 .txt 结尾的文件上执行 command。 以下是 xargs 的一些示例用法：
要删除以 .bak 结尾的目录中的所有文件，可以使用以下命令： find . -name '*.bak' -print0 | xargs -0 rm
要在特定扩展名的所有文件中搜索字符串，可以使用以下命令： find . -name '*.txt' -print0 | xargs -0 grep 'search_string' 要同时在多个文件上执行命令，可以使用以下命令： ls *.txt | xargs command
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/274cb8afe9181b403189b6305516a1ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25372b4594789a5c403db75f4072ab95/" rel="bookmark">
			防火墙概述及实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、概述
（一）、防火墙分类
（二）、防火墙性能
（三）、iptables
（四）、iptables中表的概念
二、iptables规则匹配条件分类
（一）、基本匹配条件
（二）、显式匹配使用选项及功能
（三）、iptables规则
三、iptables应用
（一）、进行标记，可在LVS调度器中应用
（二）、iptables nat表应用案例
四、什么是防火墙
五、FireWalld防火墙的配置
（一）、Firewalld默认共9个zone
（二）、端口和服务名称的对应关系
总结
前言 防火墙是一种综合性的技术，涉及到计算机网络技术、密码技术、安全技术、软件技术、安全协议、网络标准化组织的安全规范以及安全操作系统等多方面。
一、概述 在计算机领域，防火墙是用于保护信息安全的设备，其会依照用户定义的规则，允许或限制数据的传输。
作用
用于保护内网安全的一种设备
依据规则进行防护
用户定义规则
允许或拒绝外部用户访问
（一）、防火墙分类 逻辑上划分
防火墙可以大体分为主机防火墙和网络防火墙
主机防火墙
针对于单个主机进行防护
网络防火墙
针对网络进行防护，处于网络边缘，防火墙背后是本地局域网网络防火墙主外(服务集体)，主机防火墙主内(服务个人)
物理上划分
防火墙可分为硬件防火墙和软件防火墙
硬件防火墙
在硬件级别实现防火墙功能，另一部分基于软件实现，其性能高，硬件成本高
软件防火墙
应用软件处理逻辑运行于通用硬件平台之上的防火墙，其性能相较于硬件防火墙低，成本较低，对于
Linux系统已自带，直接使用即可
硬件防火墙定义
硬件防火墙是指把具备配置数据包通过规则的软件嵌入硬件设备中，为网络提供安全防护的硬件设备。多见于网络边缘。
硬件防火墙作用（拓扑图 ups）
硬件防火墙品牌：Juniper、cisco（思科ASA） 、华为、天融信等
软件防火墙定义
软件防火墙是单独使用具备配置数据包通过规则的软件来实现数据包过滤。多见于单主机系统或个人计算机。
硬件防火墙与软件防火墙比较
硬件防火墙有独立的硬件设备，运算效率较高，价格略高，可为计算机网络提供安全防护。
软件防火墙必须部署在主机系统之上，相较于硬件防火墙运算效率低，在一定程度上会影响到主机系统性能，一般用 于单机系统或个人计算机中，不直接用于计算机网络中。
Web应用防火墙(WAF)
Web应用防火墙是对web防护(网页保护)的安全防护设备(软件)，主要用于截获所有HTTP数据或仅仅满足某些规则的 会话。多见于云平台中。
（二）、防火墙性能 吞吐量
并发连接
新建连接
时延
抖动
（三）、iptables iptables是什么？
iptables不是防火墙，是防火墙用户代理用于把用户的安全设置添加到“安全框架”中 “安全框架”是防火墙，“安全框架”的名称为netﬁlter。
netﬁlter位于内核空间中，是Linux操作系统核心层内部的一个数据包处理模块iptables是用于在用户空间对内核空间的netﬁlter进行操作的命令行工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25372b4594789a5c403db75f4072ab95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4800fc9c0a2ecfedb68be5f846c7a664/" rel="bookmark">
			盘点java写入文件的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了java写入文件的几种方法,需要的朋友可以参考下
一，FileWritter写入文件
FileWritter, 字符流写入字符到文件。默认情况下，它会使用新的内容取代所有现有的内容，然而，当指定一个true （布尔）值作为FileWritter构造函数的第二个参数，它会保留现有的内容，并追加新内容在文件的末尾。
1. 替换所有现有的内容与新的内容。
new FileWriter(file);2. 保留现有的内容和附加在该文件的末尾的新内容。
new FileWriter(file,true);
追加文件示例
一个文本文件，命名为“javaio-appendfile.txt”，并包含以下内容。
ABC Hello追加新内容 new FileWriter(file,true)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
package com.yiibai.file;
import java.io.File;
import java.io.FileWriter;
import java.io.BufferedWriter;
import java.io.IOException;
public class AppendToFileExample {
public static void main( String[] args )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4800fc9c0a2ecfedb68be5f846c7a664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a428d416f1e043dcd30fb4db027d27d3/" rel="bookmark">
			数字签名算法之SHA256withRSA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、算法使用介绍 SHA256withRSA算法是一种数字签名算法，其工作原理是将正文通过SHA256数字摘要处理后，再次通过RSA公钥加密生成数字签名，并将明文与密文以及公钥发送给对方。对方拿到私钥/公钥对数字签名进行解密，然后解密后的明文经过SHA256加密与原明文进行比较，如果一致则通过。
二、功能实现 工具类代码及使用方法如下：
import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.PublicKey; import java.security.SecureRandom; import java.security.Signature; import java.util.Base64; /** * SHA256withRSA签名算法工具类 * @since 2023-09-14 10:23 * */ public class SHA256withRSAUtil { private static final String RSA = "RSA"; private static final String SHA256WITHRSA = "SHA256withRSA"; /** * 生成RSA密钥 * @return * @throws NoSuchAlgorithmException */ public static KeyPair generateKeyPair() throws NoSuchAlgorithmException { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(RSA); keyPairGenerator.initialize(2048, new SecureRandom()); return keyPairGenerator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a428d416f1e043dcd30fb4db027d27d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95b064a92505ffe7fd43dd17df41e88/" rel="bookmark">
			新魔百和HM201_CW代工_S905L_8189无线_卡刷固件包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新魔百和HM201_CW代工_S905L_8189无线_卡刷固件包（内有教程）
特点：
1、适用于对应型号的电视盒子刷机；
2、开放原厂固件屏蔽的市场安装和u盘安装apk；
3、修改dns，三网通用；
4、大量精简内置的没用的软件，运行速度提升，多出大量的存储空间；
5、去除应用安装限制；
6、支持开机自启动、开机密码锁、儿童应用锁、应用隐藏、开机自动进入HDMI等各种花式功能 ；
u盘刷机步骤：
1、准备一个FAT32格式单分区8GU盘，将压缩包里的recovery.img、update.zip、
factory_update_param.aml 三个文件拷贝到U盘根目录；
2、U盘插入机顶盒usb端口，盒子按下电源开关加电开机，通电同时连续按遥控右键刷机；
3、刷机完成后盒子会自动重启，优化系统程序完成启动到主界面会自动安装当贝市场，
自己手上有什么好用的直播、点播程序都可以放在YueMe_BOX文件夹完成自动安装；
4、系统设置-有线网络处按遥控器左键10次输密码10086开启无线网络。
刷机固件： 链接: https://pan.baidu.com/s/1Y122MiSw6YKNwNuz21OtDw 提取码: 1122 备用链接：https://wwt.lanzoux.com/b021zvjkj 提取码：6l1n
固件路径：B《其他桌面--固件大全》&gt;2《中兴盒子固件合集》&gt;1《魔百和 CM／M 系列 固件合集》&gt;《HM201》
A合集里面也有的
声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9801af6d13ef862ff83215ac2f27b079/" rel="bookmark">
			DSP开发，使用CCS软件建立工程以及烧录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DSP开发，使用CCS软件建立工程以及烧录 1 概述1.1 资源概述1.2 DSP介绍 2 工程建立2.1 详细步骤 3 工程建立总结4 烧录到flash中4.1 增加必要文件4.2 增加预编译宏（非必须） 5 程序烧录5.1 官方烧录工具 Uniflash5.1.1 双核芯片烧录-使用Uniflash 5.2 第三方烧录软件C2Prog5.2.1 C2Prog串口烧录5.2.2 C2Prog JTAG烧录5.2.3 C2Prog JTAG烧录支持的仿真器类型5.2.4 C2Prog JTAG双核烧录 5.3 烧录注意事项 6 串口说明 1 概述 本文讲述了CCS建立DSP工程文件以及烧录相关的教程。
1.1 资源概述 开发板: 普中DSP开发板
CCS版本：6.1.3
主控芯片型号：TMS320F28335
1.2 DSP介绍 德州仪器DSP在电机控制领域使用非常多，在最近20年接近霸主的存在，计算能力完胜早期的arm，典型的型号有2407和2812。但是最近两年arm上升势头非常明显，差距越来越小，而且在外设方面完爆DSP。中美贸易战后中国很多公司开始去美国化，在新一代的产品中不再选用德州仪器的DSP，而是选择ST的ARM芯片或者国产的一些arm芯片。但是旧的基于DSP平台开发的产品还是要维护，新的平台也需要从dsp上迁移过来，所以有必要熟悉DSP的应用。
2 工程建立 2.1 详细步骤 1，在需要建立的工程的文件夹内新建一个工程文件夹，此文件夹名字以及所在路径不能包含中文名。
2，打开CCS软件，在弹出的Workspace内指向刚才建立的文件夹。
3，建立新工程
4，填入工程的相关信息，器件型号，工程名字，路径以及工程类型。进行第4步，在选择编译器的时候，需要特别注意，尽量使用与原工程相同或者相近版本的编译器，否则将会出现不可预知的错误。
5，新建后的工程，只包含两个文件以及一个文件夹，文件为系统必须的头文件路径，RAM连接的配置文件28335_RAM_Ink.cmd。
28335_RAM_Ink.cmd文件可以在工程properties选项里边进行选择。
6，在工程文件夹下建立4个文件夹，其中LIB拷贝TI官方的库C文件,头文件以及汇编文件。这里的C文件用到哪些拷贝哪些，缺失或者多余将会导致报错，报错的类型是变量没有定义或者被重复定义。头文件需要全部进行拷贝，即使那些看起来风马牛不相及的文件，因为这些文件在系统初始化或者中断向量表中均有引用。（stm32的arm工程只需要拷贝需要的文件）。
Lib-&gt;include文件夹的头文件
Lib-&gt;source文件夹的库函数文件,IQmath.lib为数学函数库，官方已经封装好。本例程中没有使用到复杂的数学计算，也可以不要。
user里边放置main.c文件，Hardware里边放置和硬件相关的文件，这里放置LED.c和LED.h。添加完后整个工程的结构是这样的
7，增加头文件路径，选中工程，右键，点击Properties。
选择头文件路径，其中workspace是相对路径，库文件必须在工程文件夹下，工程建立完成后即使挪动工程也不会导致头文件路径失效，因此建议选择。browse是绝对路径，必须确保库文件路径不发生变化，否则将导致报错，variables是环境变量定义的库函数路径。还不知怎么使用。
8，编译工程，没有错误和警告，编译完成后在工程树下可以看到生成了可供烧录的out文件。
烧录用的.OUT文件
9，烧录下载，这里和arm不同，这里只是烧录到了DSP的RAM，而不是FLASH。当断电或者重启时，程序将丢失，重新引导Flash里边的程序，如果要烧录到Flash需要进行另外的操作。点击烧录后会弹出对话框，配置调试的参数。
生成配置文件，点击YES，在新弹出的对话框中填入文件名，并确认
10，选择仿真器和芯片型号型号，插入仿真器，点击右侧的 Test Connection。
若正常，在最后的几行将会弹出仿真器连接成功提示信息
11，再点击下载调试按钮，将会打开下载调试界面，可以单步调试添加断点等。
3 工程建立总结 建立工程编译通过需要下述文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9801af6d13ef862ff83215ac2f27b079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ac8db789de8c11a0b692cd311d872a/" rel="bookmark">
			macOS取色器里的彩铅色值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用过apple办公三件套（Keynote、Pages和Numbers)的小伙伴，一定使用过macOS内置的取色器，个人对里面铅笔色彩比较有印象。
&amp;nbsp;
铅黑色、钨黑、铁黑色、铁灰色、锡灰色和镍灰色，用金属来描述黑色的浓淡，有点“墨分五色”的赶脚。
🍆茄紫色、🍇葡萄紫、🌶辣椒红、🍒樱桃红、🍓草莓红、芦笋绿、🌰栗色、🍋柠檬黄、🍌香蕉黄、🫐蓝莓色……，看了直流口水。
较真一点来讲，金属、食物 和 水果是三维世界里面的物体，光线变化，色值就不一样，但是有人指着葡萄说它的颜色可以用这个色值表示，是哦，它的颜色差不多就是这样，好的，这就加入色彩搭配全家桶。
再说说它的交互，当鼠标滑过时，指针下方的铅笔会滑出，就好像手里拿了一盒彩铅，抽出一根，啊，另一个色彩好像更好看一点，然后抽出另一根，就这样选啊选，非常Make sense。
&amp;nbsp;
最近看到bejson的“前端”栏目下面多了一个48色蜡笔，完美复刻了这部分交互。
链接：https://www.bejson.com/ui/crayons/
不过铅笔的样子少了原版的工业设计质感，感觉有点low，不过色彩的中英文名都有，而且点击色值还能复制。不用mac的时候打开这个页面还能怀旧一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/284eb281cbfe9ad7286fabc5ef204963/" rel="bookmark">
			华为云云耀云服务器L实例评测｜ ultralytics最先进模型YOLOv8深度学习AI训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言 登录服务器
安装pyhton
部署yolov8
安装Pytorch
下载权重文件
训练模型
模型使用
前言 前几期我们在云耀云服务器L实例上分别使用docker和直接在centos上部署了yolov5识别API，前端项目vue，后端项目.net Core Web Api,但是从监控图上来看，都没什么压力，调用接口也很流畅。
在实例介绍中看到，华为云擎天架构加持，软硬协同结合顶尖AI算法智能调度。于是有了一个疯狂的想法，这期我们给服务器来点压力，[坏笑!]，这期我们要在服务器上部署yolov8进行AI模型训练。
YOLOv8 发布于2023 年 1月 10 号，是 ultralytics 公司在 开源的 YOLOv5 的下一个重大更新版本，是一种尖端的、最先进的 （SOTA） 模型
登录服务器 因为要训练AI模型，我们要处理图片，查看图片效果，方便起见，这次服务器我选择了系统镜像Windows Server
拿到服务器，第一步还是要重置密码，在控制台，找到对应的服务器，点击操作列的更多、重置密码。
记得一定要勾选自动重启，这样我们的密码才能立马生效！ 然后我们有两种方式来登录，一种是直接点击操作列的远程登录，在其他方式这里，点击立即登录来使用控制台提供的VNC方式登录！
或者快捷键Win + R ，在弹出的页面中输入 mstsc，确定！
然后在弹出的远程桌面连接中，输入我们服务器的弹性IP
然后在验证界面，点击下面的更多选择，选择其他账户
用户名：Administrator 密码：刚刚重置密码时你设置的密码
弹出的无法验证身份，点击是 ！
然后就连上我们的服务器了，桌面非常干净，只有一个回收站！
安装pyhton 因为服务器上什么环境都没有，我们先来安装python3，在官网随便下一个大于大于3.8的python安装包，选择amd64的exe版本，安装的时候勾选最底下的帮我们添加环境变量
等待一会之后，出现下面这个界面就是安装成功了。
打开控制台，执行 python -V 和 pip -V ，看看我们的环境变量是否设置成功。
部署yolov8 去官网将yolov8的源码下载下来
ultralytics/ultralytics: NEW - YOLOv8 🚀 in PyTorch &gt; ONNX &gt; OpenVINO &gt; CoreML &gt; TFLite (github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/284eb281cbfe9ad7286fabc5ef204963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a399cc801a698a7e29b39ef5e0d4a4/" rel="bookmark">
			Jetpack Compose 介绍和快速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Compose版本发展 19年，Compose在Google IO大会横空出世，大家都议论纷纷，为其前途堪忧。
21年7月Compose 1.0的正式发布，却让大家看到了Google在推广Compose上的坚决，这也注定Compose会成为UI开发的新风向。
23年1月 发布了1.4版本, 在不断更新迭代......
Compose是什么 Compose则是一个全新的UI库，隶属Jetpack中的一员，它的出现是为了重新定义Android UI的开发方式——声明式UI编程
Compose的优势 声明式UI，它基于声明式的UI编程模型，当数据发生改变时，UI将自动刷新。这意味着不再需要编写命令式代码来控制 UI 的每一个细节去掉XML，完全解除了混合写法（xml+Java、kotlin）的局限性超强兼容性，大多数常用库（如Navigation、ViewModel和Kotlin协程）都适用于Compose，Compose 能够与现有 View 体系并存，你可以为一个既有项目引入 Compose加速开发，为我们提供了很多开箱即用的Material 组件，如果的APP是使用的material设计的话，那么使用Jetpack Compose 能让你节省不少精力。精简代码数量，减少bug的出现实时预览，Compose 预览机制可以做到与真机无异，真正的所见所即得 Compose和View的关系 Compose 是基于 Canvas渲染，它的原理是通过AndroidComposeView的dispatchDraw分发绘制，通过dispatchTouchEvent分发手势，来实现「在同一个 View 的内部完成整个 UI 组件树」的效果。
AndroidComposeView的作用是承上启下，作为Compose和View混合开发的桥梁，从而实现API互相调用的能力
Compose 是不会有能力上的天然限制的，也就是传统 View 方案能做的事 Compose 全都可以做，比如各种复杂的动画、手势、嵌套的多层级布局，Compose 都可以做到。
Compose 没有做出对等实现的只有 SurfaceView 和 TextureView 这两个类，它们是用于高速刷新的内容的，比如视频播放或者相机的取景器界面。需要使用原生的 SurfaceView 或者 TextureView。
扩展: 直接在Android上使用skia引擎进行绘制UI，这样就和flutter完全一致了，不过google为了兼容原来的view没有选择skia这个方案，兼容性是有了，但是也限制了compose的性能。
声明式UI &amp; 命令式UI 声明式UI和命令式UI是两种不同的编程风格。
在命令式UI中，需要手动构建一个全功能的UI实例，比如一个TextView文本，在随后UI发生变化时，调用set方法手动刷新UI。
fun timer(){ var count = 0 textView.setOnClickListener{ count+=1 textView.text = "count:${count}"" } } 而在声明式UI中，开发人员描述当前的UI状态，数据更新后UI的刷新交给Compose框架。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2a399cc801a698a7e29b39ef5e0d4a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0dc174caa4141e93229960f940b3b8/" rel="bookmark">
			关于ST-LINK connection error的解决（*带注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于ST-LINK connection error的解决
-----------------------------------------------------------
要点： 1. 不能连接这个问题，使用不同的软件工具，给出的错误提示也不同。
keil 报错：ST-link connection error
2. 直接使用 ST 官方工具 的STM32 ST-LINK Utility，解决起来最方便。
好像只能使用 ST官方的工具，如 ST-LINK 调试工具？
3. 遇到有关 MCU 本身的问题，应该首先考虑使用官方工具来解决，这是第一选择。
假如官方自己都没有能力解决，那么，这就有问题了？
==================================
关于ST-LINK connection error的解决 在烧录程序的时候，我的stm32h750北极星板突然芯片被锁了，就很难受找了很多关于这类问题的解决方法，但本人使用完后没有任何效果，后面就使用了ST官方的STM32 ST-LINK Utility软件，发现实在太方便了，可以解决大部分的问题！！！（注意：这个问题，必须使用 ST 官方的，解决起来才方便）
STM32 ST-LINK Utility的官方下载链接如下 https://www.st.com/en/development-tools/stsw-link004.html#get-software
我当时最先想到的办法是用flymcu去解决问题的，但是我发现试了很久都是无法链接到芯片，意思就是不行，后面使用STM32 ST-LINK Utility擦除全部程序完美解决问题。(之后我去问了正点原子的 技术支持，给出的回复是flymcu目前仅支持FI/F4系列的，如果要使用F7/H7系列的需要添加算法，我表示懵逼)
STM32 ST-LINK Utility安装很简单，官网下载完后直接安装就行，相当简单。
下载完打开STM32 ST-LINK Utility软件
选择这个连接模式，
按下芯片复位键的同时，点击连接。参考：https://blog.csdn.net/weixin_51098277/article/details/127942783
注：忘记具体的操作步骤了，但似乎是这样的：何时按下？何时释放复位键？&lt;&lt; 这是关键：
1：必须一直按住 stm32 的复位键？等擦除完成后，再松开？
2：擦除完成后，需要再按一次复位键？
3. 必须先退出 STM32 ST-LINK Utility工具，然后，在 keil 中才能正常连接。
最后拔出st-link下载器，在重新装上，之后就可以下载自己需要的程序了，问题到此解决。
————————————————
版权声明：本文为CSDN博主「山海也有意难平☜」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a0dc174caa4141e93229960f940b3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b44a903eb0261929c3ffb812b9b35435/" rel="bookmark">
			Day13-作业（SpringBootWeb AOP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作业1：基于springAOP技术完成如下需求。 需求：
记录当前 tlias 智能学习辅助系统中所有员工的登录操作，无论登录成功还是失败，都需要记录日志。日志信息包含如下信息：
用户名 （登录时，输入的用户名）
密码 （登录时，输入的密码）
操作时间 （什么时间，员工登录的）
登录是否成功
登录成功后，下发的jwt令牌
登录操作耗时
提示:
获取到原始方法运行的参数，也是可以根据实际情况强转的。 比如：
//获取方法参数 Object[] args = proceedingJoinPoint.getArgs(); Emp emp = (Emp)args[0]; 原始方法运行的结果虽然是Object，但是我们可以根据实际切入点表达式匹配的方法， 根据情况来进行强转的 ，比如：
//调用原始方法 Object obj = proceedingJoinPoint.proceed(); //获取登录结果,是否成功 Result result = (Result) obj; 表结构：
在tlias系统的数据库 tlias 中，创建如下表结构。
-- 登录日志表 create table emp_login_log( id int unsigned primary key auto_increment comment 'ID', username varchar(20) comment '用户名', password varchar(32) comment '密码', login_time datetime comment '登录时间', is_success tinyint unsigned comment '是否成功, 1:成功, 0:失败', jwt varchar(1000) comment 'JWT令牌', cost_time bigint unsigned comment '耗时, 单位:ms' ) comment '登录日志表'; 实体类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b44a903eb0261929c3ffb812b9b35435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ffcb84b8c46ea288934f03f704f6f2/" rel="bookmark">
			核心实验18_ospf高级_ENSP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 核心实验18_ospf高级_ENSP
多区域虚链路
实搭拓扑图： 具体操作： R1: [R1]ospf 1 router-id 1.1.1.1 [R1-ospf-1]area 0 [R1-ospf-1-area-0.0.0.0]net 1.1.1.0 0.0.0.255 [R1-ospf-1-area-0.0.0.0]net 10.1.12.0 0.0.0.255 [R1-ospf-1-area-0.0.0.0]area 0.0.0.1 [R1-ospf-1-area-0.0.0.1]net 10.1.16.0 0.0.0.255 R2: [R2]ospf 1 router-id 2.2.2.2 [R2-ospf-1]area 0 [R2-ospf-1-area-0.0.0.0]net 2.2.2.2 0.0.0.0 [R2-ospf-1-area-0.0.0.0]net 12.1.12.2 0.0.0.0 [R2-ospf-1-area-0.0.0.0]area 0.0.0.2 [R2-ospf-1-area-0.0.0.2]net 12.1.27.0 0.0.0.255 [R2-ospf-1-area-0.0.0.2]vlink-peer 3.3.3.3 （3.3.3.3是对方路由器的router id） R3: [garliccc-R3]ospf 1 router-id 3.3.3.3 [garliccc-R3-ospf-1]area 0.0.0.2 [garliccc-R3-ospf-1-area-0.0.0.2]vlink-peer 2.2.2.2 /建立虚链路 [garliccc-R3-ospf-1-area-0.0.0.2]net 3.3.3.0 0.0.0.255 [garliccc-R3-ospf-1-area-0.0.0.2]net 10.1.37.0 0.0.0.255	[garliccc-R3-ospf-1-area-0.0.0.2]area 0.0.0.3 [garliccc-R3-ospf-1-area-0.0.0.3]net 10.1.34.0 0.0.0.255 R4: [garliccc-R4]ospf 1 router-id 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95ffcb84b8c46ea288934f03f704f6f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc0f968493bf6c95fee056d43efa698a/" rel="bookmark">
			【数据库】数据库系统概论（二）— 关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关系数据库 关系数据库是支持关系模型的数据库系统。
关系模型的数据结构：关系；逻辑结构：扁平的二维表
域 是一组具有相同数据类型的值的集合。
例如：{a,b,c}、{0,1,2,3}等等
笛卡尔积 定义 笛卡尔积是域上的一种集合运算。
计算公式 给定一组域为：D1,D2,D3,…,Dn 【允许有重复的域】
笛卡尔积的计算公式为：
D 1 × D 2 × D 3 × … × D n = { ( d 1 , d 2 , d 3 , … , d n ) ∣ d i ∈ D i , i = 1 , 2 , … , n } D1×D2×D3×…×Dn = {\{(d1,d2,d3,…,dn) | di ∈Di, i = 1,2,…,n\}} D1×D2×D3×…×Dn={(d1,d2,d3,…,dn)∣di∈Di,i=1,2,…,n}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc0f968493bf6c95fee056d43efa698a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe14eab6879aa07fb68faa56e4799db7/" rel="bookmark">
			【大数据之Kafka】十二、Kafka之offset位移及漏消费和重复消费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 offset的默认维护位置 Kafka0.9版本之前， consumer默认将offset保存在Zookeeper中。从0.9版本开始，consumer默认将offset保存在Kafka一个内置的topic中，该topic为 consumer_offsets。
consumer_offsets 主题里面采用 key 和 value 的方式存储数据。key 是 group.id+topic+分区号，value 就是当前 offset 的值。每隔一段时间， kafka 内部会对这个 topic 进行 compact，也就是每个group.id+topic+分区号就保留最新数据。
消费offset案例：
（1） consumer_offsets 作为Kafka 中的 topic，那就可以通过消费者进行消费。
在配置文件 config/consumer.properties 中添加配置 exclude.internal.topics=false， 默认是 true，表示不能消费系统主题。为了查看该系统主题数据，所以该参数修改为 false，并分发。
（2）hadoop102用命令行方式，创建一个新的topic。
bin/kafka-topics.sh --bootstrap-server hadoop102:9092,hadoop103:9092 --create --topic newtopic --partitions 2 --replication-factor 2 （3）hadoop102启动生产者往 newtopic 生产数据。
bin/kafka-console-producer.sh --bootstrap-server hadoop102:9092,hadoop103:9092 --topic newtopic （4）hadoop104启动消费者消费 newtopic 数据。注意：指定消费者组名称，更好观察数据存储位置（key 是 group.id+topic+分区号）。
bin/kafka-console-consumer.sh --bootstrap-server hadoop102:9092,hadoop103:9092 --topic newtopic --group test （5）hadoop103查看消费者消费主题 consumer_offsets。
bin/kafka-console-consumer.sh --bootstrap-server hadoop102:9092,hadoop103:9092 --topic consumer_offsets --consumer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe14eab6879aa07fb68faa56e4799db7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ed773589bcbda7516f719ee1b4e912/" rel="bookmark">
			(CVPR-2023)InternImage：利用可变形卷积探索大规模视觉基础模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		InternImage：利用可变形卷积探索大规模视觉基础模型 Title：InternImage: Exploring Large-Scale Vision Foundation Models with Deformable Convolutions
paper是上海AI Lab发表在CVPR 2023的工作
paper链接
Abstract 与近年来大规模视觉变换器（ViT）的巨大进步相比，基于卷积神经网络（CNN）的大规模模型仍处于早期状态。这项工作提出了一种新的基于 CNN 的大规模基础模型，称为 InternImage，它可以从增加参数和训练数据（如 ViT）中获得增益。与最近关注大密集核的CNN不同，InternImage以可变形卷积作为核心算子，使得我们的模型不仅具有检测和分割等下游任务所需的大有效感受野，而且还具有自适应空间聚合以输入和任务信息为条件。因此，所提出的 InternImage 减少了传统 CNN 的严格归纳偏置，并使从 ViT 等海量数据中学习具有大规模参数的更强、更鲁棒的模式成为可能。我们模型的有效性在 ImageNet、COCO 和 ADE20K 等具有挑战性的基准测试中得到了证明。值得一提的是，InternImage-H在COCO test-dev上取得了新纪录65.4 mAP，在ADE20K上取得了62.9 mIoU，超越了当前领先的CNN和ViT。
1. Introduction 随着Transformers在大规模语言模型中取得的显着成功[3-8]，视觉Transformers（ViTs）[2, 9-15]也席卷了计算机视觉领域，并正在成为大规模语言模型研究和实践的首选。视觉基础模型。一些先驱者 [16-20] 尝试将 ViT 扩展到具有超过 10 亿个参数的大型模型，击败卷积神经网络 (CNN)，并显着提升各种计算机视觉任务的性能极限，包括基本分类、检测和分割。虽然这些结果表明 CNN 在海量参数和数据时代不如 ViT，但我们认为，当配备类似的算子/架构级设计时，基于 CNN 的基础模型也可以实现与 ViT 相当甚至更好的性能，参数设置、海量数据。
为了弥合CNN和ViT之间的差距，我们首先从两个方面总结它们的差异：（1）从算子级别[9,21,22]来看，ViT的多头自注意力（MHSA）具有长程依赖性和自适应空间聚合（见图1（a））。受益于灵活的 MHSA，ViT 可以从海量数据中学习比 CNN 更强大、更稳健的表示。 （2）从架构角度来看[9,22,23]，除了MHSA之外，ViT还包含一系列标准CNN中未包含的高级组件，例如层归一化（LN）[24]、前馈网络（FFN） ) [1]、GELU [25] 等。尽管最近的工作 [21,22] 做出了有意义的尝试，通过使用具有非常大内核（例如 31×31）的密集卷积将长程依赖性引入 CNN，如图所示如图1（c）所示，在性能和模型规模方面与最先进的大规模ViT[16,18-20,26]仍有相当大的差距。
图1.不同核心操作的比较。 (a) 显示了多头自注意力 (MHSA) [1] 的全局聚合，其计算和内存成本在需要高分辨率输入的下游任务中非常昂贵。 (b) 将 MHSA 的范围限制在局部窗口 [2] 以降低成本。 © 是具有非常大的内核的深度卷积，用于模拟长程依赖关系。 (d) 是可变形卷积，它与 MHSA 具有类似的有利特性，并且对于大规模模型来说足够有效。我们从它开始构建一个大规模的CNN。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ed773589bcbda7516f719ee1b4e912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdde1592ddd411304f9971745c664ceb/" rel="bookmark">
			【备忘录】英译汉接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import requests import random import json from hashlib import md5 # Set your own appid/appkey. appid = '2xxx' appkey = 'kxxx' # For list of language codes, please refer to `https://api.fanyi.baidu.com/doc/21` from_lang = 'en' to_lang = 'zh' endpoint = 'http://api.fanyi.baidu.com' path = '/api/trans/vip/translate' url = endpoint + path query = 'Hello World! This is 1st paragraph.This is 2nd paragraph.' # Generate salt and sign def make_md5(s, encoding='utf-8'): return md5(s.encode(encoding)).hexdigest() def baidu_api(query,from_lang,to_lang): salt = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdde1592ddd411304f9971745c664ceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e321f3d5c1ed1bfbc738929f72ee2f71/" rel="bookmark">
			核心实验17_IRF堆叠_H3C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 核心实验17_堆叠_H3C
堆叠：CSS（框式） 、iStack（盒式）
思科：VSS
华三：IRF
锐捷：VSU
实搭拓扑图： 具体操作： 左上: [garliccc-1]irf member 1 priority 5 /将优先级配置为5 使其称为master [garliccc-1]int Ten-GigabitEthernet 1/0/49 [garliccc-1-Ten-GigabitEthernet1/0/49]shutdown /接口需先shutdown [garliccc-1]irf-port 1/1 /创建irf接口1/1 前者1表示member ID;后者1表示irf接口ID [garliccc-1-irf-port1/1]port group interface Ten-GigabitEthernet 1/0/49 [garliccc-1]int ten 1/0/49 [garliccc-1-Ten-GigabitEthernet1/0/49]undo shut &lt;garliccc-1&gt;save 建议先将堆叠线拔下来，然后在激活，激活完成之后再插线 [garliccc-1]irf-port-configuration active /激活irf 右上： [garliccc-2]irf member 1 renumber 2 /重新编号2 &lt;garliccc-2&gt;save &lt;garliccc-2&gt;reboot [garliccc-2]int Ten-GigabitEthernet 2/0/49 [garliccc-2-Ten-GigabitEthernet2/0/49]shutdown [garliccc-2]irf-port 2/2 [garliccc-2-irf-port2/2]port group interface Ten-GigabitEthernet 2/0/49 [garliccc-2]int ten 1/0/49 [garliccc-2-Ten-GigabitEthernet1/0/49]undo shut &lt;garliccc-2&gt;save 建议先将堆叠线拔下来，然后在激活，激活完成之后再插线 [garliccc-2]irf-port-configuration active /激活irf 完成效果： 实现堆叠，左上设备为主：master，右上设备为备：standby。配置全同步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e321f3d5c1ed1bfbc738929f72ee2f71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f443b0353be92d97d87927e059c472/" rel="bookmark">
			服务器上一个域名对应多个前端项目的nginx转发配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：
当有两个前端项目A,B的时候，项目A（对应端口8000）和项目B（对应端口8001）分别部署在服务器的不同位置，通过服务器ip+端口都能正常访问单独的项目A和项目B；现在要求两个项目共用一个域名~~也就是说访问http://10.111.182.xxx:8000的时候默认访问项目A的资源，访问http://10.111.182.xxx:8000/pages的时候自动代理到项目B的资源
业务场景：h5嵌入原生开发，有多套独立的h5，要求嵌入原生的域名不分不变，但是路由发生变化的时候代理到不同的独立h5项目，也就是2个前端项目，如何通过一个端口来访问
服务器配置
部署单个项目并为其配置单独的ngx转发
1.将打包后的静态资源放置服务器上，位置自己选择但是记住路径
2.配置nginx;通常在服务器上的/etc/nginx/conf.d
新建一个后缀为.conf的文件
server { #指定服务器监听的端口号，这里是 8001 listen 8001; #定义服务器名称，在这里是 localhost。 server_name localhost; # 根请求会指向的页面，指定服务器的根目录，将请求映射到该目录下的文件。 root /home/wwwroot/testB; #在响应头中添加跨域请求的允许访问源。这里的配置允许来自任何来源的请求。 add_header 'Access-Control-Allow-Origin' '*'; # 根请求会指向的页面定义请求路径为根路径时的处理逻辑。使用 try_files 指令尝试按照顺序查找 对应的文件，如果找不到则返回 index.html。 location / { try_files $uri $uri/ /index.html;	} # 开启gzip 压缩 gzip on; # 设置gzip所需的http协议最低版本 （HTTP/1.1, HTTP/1.0） gzip_http_version 1.1; # 设置压缩级别，压缩级别越高压缩时间越长 （1-9） gzip_comp_level 4; # 设置压缩的最小字节数， 页面Content-Length获取 gzip_min_length 1000; # 设置压缩文件的类型 （text/html) gzip_types text/plain application/javascript text/css; } 到此B项目的部署完成可以用ip+端口进行访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7f443b0353be92d97d87927e059c472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a5f3adc10b4483dc502969492e6197/" rel="bookmark">
			MySQL四种备份表的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没有发布文章啦，直接上内容！
一、将表备份到物理机
mysqldump -h 域名 -P 端口 -u用户 -p密码 库名 表名 &gt; /路径/表名.{$date}.bak 二、将表备份在库里面（create复制表结构、insert复制表内容）
create table one_bak like one; //复制表结构 insert into one_bak select * from one; //复制表内容 三、将表备份在库里面（create table as备份）
注:与2步骤备份在库里面不同的是 as 备份表不会备份主键和外键，只备份表数据
create table one_bak as select * from one; 四、大家都知道日志文件，具有“只追加写不修改”的属性，历史表和日志文件差不多，也具有这个属性。
同时和日志文件一样，历史表也具有“顺序读”和“随机读”的特点，所以有时历史表会加一些索引。
随着时间的推移，历史表数据会越来越多，使其“追加写”的性能越来越差，可以使用历史表热备的方法。
1.按照原历史表新增一个新表（空表）
mysql&gt; show create table history_log\G mysql&gt; create table history_log_new ...; 2.给历史表重命名，并将新表重命名为历史表
mysql&gt; RENAME TABLE history_log to history_log_bak_20230717, history_log_new to history_log; 分享完毕！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc695d71237b6932f8baec2ae666a45e/" rel="bookmark">
			VS, VSCode, Unity, 乌龟SVN 常用快捷键和踩的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熟练使用快捷键能提高工作效率, 敲出更多的bug
VS2017常用的快捷键 如果你的快捷键不是这样的, 那就需要在VS设置里重置一下;
要是还不行, 也可能是跟输入法快捷键冲突了, 找到输入法的快捷键设置, 把快捷键全都关了!
1. 敲上"for", 然后按两下Tab: 自动补全
for (int i = 0; i &lt; length; i++) { } 2. 在方法后的小括号里按Ctrl+Shift+空格: 提示本方法所需的参数类型
3. 敲出左大括号它会自动补全右大括号, 此时接着再敲一下回车: 自动对齐大括号
{ } 4. 选中代码, 按Ctrl+K, 然后再按Ctrl+C: 注释选中的代码
5. 选中代码, 按Ctrl+K, 然后再按Ctrl+U: 取消注释
6. Ctrl+K, 然后再按Ctrl+D: 自动对齐代码
7. 按住Alt, 再按↑或者↓: 移动本行代码
8. 点击一个变量, 按住Ctrl, 按2下R: 重命名这个变量
9. 双击一个变量: 选中这个变量
10. Ctrl+S: 保存当前代码页, Ctrl+Shift+S: 保存全部修改过的代码页
11. 不用先选中整行再Ctrl+C, Ctrl+V, 直接点击本行Ctrl+C, 就可以Ctrl+V了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc695d71237b6932f8baec2ae666a45e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9024454e2274a808b4e9c49495b2e3/" rel="bookmark">
			vue3实现tabs导航栏，点击每个导航项有下划线动画效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="navigation"&gt; &lt;div v-for="(item, index) in items" :key="index" class="navigation-item" :class="{ active: index === activeIndex }" @click="activeIndex = index" ref="itemRefs" &gt; {{ item }} &lt;/div&gt; &lt;div class="navigation-underline" :class="{ active: activeIndex !== -1 }" :style="underlineStyle" ref="underlineRef" &gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, watch, onMounted } from "vue"; const activeIndex = ref(0); const items = ref(["Home", "About", "Services", "Services"]); const underlineStyle = ref({ transform: "translateX(0)", }); const itemRefs = ref([]); const underlineRef = ref(null); const updateUnderline = () =&gt; { // 获取标题的宽度，减去下划线的宽度除以2，可以使下划线在标题下居中显示 const item = itemRefs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c9024454e2274a808b4e9c49495b2e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04243349cb14bf403ade3601931dadb0/" rel="bookmark">
			CSDN博客专家证书发放名单（已暂停）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
证书发放频次
6月（第一批）证书发放名单（80位）
7月（第二批）证书发放名单（50位）
8月（第三批）证书发放名单（54位）
9月（第四批）证书发放名单（51位）
10月（第五批）证书发放名单（53位）
11月（第五批）证书发放名单（54位）
12月（第六批）证书发放名单（59位）
2023年1月份（47位）
2023年2月份（54位）
2023年3月份（60位）
2023年4月份（60位）
2023年5月份（53位）
2023年6月份（60位） 证书发放以及邮寄时间
问题&amp;回答
其他
「博客专家」（博客专家申请规则）是CSDN给予影响力较大的技术类博客的荣誉称谓，代表了官方对其博客的肯定。要想成为博客专家首先得有影响力，其次是其博客技术内容质量必须得好，成为博客专家后会得到我们一系列的服务，如在头像上加象征荣誉的专家勋章、有专属专家社群，有专人对接提供服务，不仅如此，我们还将为专家博主发放实体证书，具体详情请往↓看。
证书发放频次 每个月根据当月专家发文/活跃情况进行发放，每月发放一次，每个博客专家只可获取一次专属证书
6月（第一批）证书发放名单（80位） CSDN ID昵称博客主页feiying0canglangIT利刃出鞘https://blog.csdn.net/feiying0canglangi042416汪子熙https://blog.csdn.net/i042416zhuoqingjoking97298卓晴https://blog.csdn.net/zhuoqingjoking97298qq_27489007芝麻粒儿https://blog.csdn.net/qq_27489007xixihahaleleheheghostwrittenhttps://blog.csdn.net/xixihahaleleheheadmansJackieZhengChinahttps://blog.csdn.net/admanshoward2005howard2005https://blog.csdn.net/howard2005commshare等风来不如迎风去https://blog.csdn.net/commshareu011068702码莎拉蒂 .https://blog.csdn.net/u011068702jacke121AI视觉网奇https://blog.csdn.net/jacke121frank2102小兔子编程https://blog.csdn.net/frank2102weixin_42250835全栈哈士奇https://blog.csdn.net/weixin_42250835ZhangRelayzhangrelayhttps://blog.csdn.net/ZhangRelayweixin_40816738gblfyhttps://blog.csdn.net/weixin_40816738xiaoweite1Lansonlihttps://blog.csdn.net/xiaoweite1qq_22182989南北极之间https://blog.csdn.net/qq_22182989qq_43762191看，未来https://blog.csdn.net/qq_43762191WhereIsHeroFrom英雄哪里出来https://blog.csdn.net/WhereIsHeroFromqq_37865996千里ZLPhttps://blog.csdn.net/qq_37865996qq_41185868一个处女座的程序猿https://blog.csdn.net/qq_41185868wenyusuran文宇肃然https://blog.csdn.net/wenyusuranqq_23934063不太灵光的程序员https://blog.csdn.net/qq_23934063mouday彭世瑜https://blog.csdn.net/moudayImagineCode前端修罗场https://blog.csdn.net/ImagineCodefeixiaoxing嵌入式-老费https://blog.csdn.net/feixiaoxinghuangbangqing12虚坏叔叔https://blog.csdn.net/huangbangqing12duan_zhihua段智华https://blog.csdn.net/duan_zhihuaMinggeQingchunMinggeQingchunhttps://blog.csdn.net/MinggeQingchunyaoxin521123yaoxin521123https://blog.csdn.net/yaoxin521123hiwoshixiaoyu编程小鱼酱https://blog.csdn.net/hiwoshixiaoyuqq_40374604JavaPub-roderthttps://blog.csdn.net/qq_40374604uncle_lluncle_llhttps://blog.csdn.net/uncle_llweixin_41445387Vuko-wxhhttps://blog.csdn.net/weixin_41445387Forever_wj╰つ栺尖篴夢ゞhttps://blog.csdn.net/Forever_wjjdsjlzx一叶飘舟https://blog.csdn.net/jdsjlzxweixin_41605937庄小焱https://blog.csdn.net/weixin_41605937chenlyclydvlinkerhttps://blog.csdn.net/chenlyclyHandsomeHong奇妙之二进制https://blog.csdn.net/HandsomeHongfyfugoyfa叶庭云https://blog.csdn.net/fyfugoyfaqq21497936长沙红胖子Qthttps://blog.csdn.net/qq21497936syc000666一一哥Sunhttps://blog.csdn.net/syc000666AA5279AA失落夏天https://blog.csdn.net/AA5279AAqq_36686437点云侠https://blog.csdn.net/qq_36686437A7572912281_bithttps://blog.csdn.net/A757291228liuhao9999紫微前端https://blog.csdn.net/liuhao9999dog250dog250https://blog.csdn.net/dog250weixin_46192679一只特立独行的兔先森https://blog.csdn.net/weixin_46192679weixin_56128392马晓东国云数据CEOhttps://blog.csdn.net/weixin_56128392fanjufei123456嵌入式职场https://blog.csdn.net/fanjufei123456github_35631540拿我格子衫来https://blog.csdn.net/github_35631540lfdfhl谷哥的小弟https://blog.csdn.net/lfdfhlwhirlwind526编程指南针https://blog.csdn.net/whirlwind526weixin_38633659瓜子三百克https://blog.csdn.net/weixin_38633659yellow_hillFranklinhttps://blog.csdn.net/yellow_hillgithub_39655029村雨遥https://blog.csdn.net/github_39655029stevensxiaodingdingfishhttps://blog.csdn.net/stevensxiaoweixin_42135087代码改变世界ctwhttps://blog.csdn.net/weixin_42135087a486259万里鹏程转瞬至https://blog.csdn.net/a486259hihell梦想橡皮擦https://blog.csdn.net/hihellleyi520二当家的白帽子https://blog.csdn.net/leyi520feiyangqingyunfeiyangqingyunhttps://blog.csdn.net/feiyangqingyunqq_38322527专注写bughttps://blog.csdn.net/qq_38322527shi_hong_fei_hei小虚竹https://blog.csdn.net/shi_hong_fei_heiu010634066石臻臻的杂货铺https://blog.csdn.net/u010634066u012562943科技D人生https://blog.csdn.net/u012562943ITzhongziITzhongzihttps://blog.csdn.net/ITzhongzim0_37422217GoatGuihttps://blog.csdn.net/m0_37422217u014534808码农飞哥https://blog.csdn.net/u014534808weixin_44953658Jiangxl~https://blog.csdn.net/weixin_44953658xiangzhihong8xiangzhihong8https://blog.csdn.net/xiangzhihong8yuanziokLeo.yuanhttps://blog.csdn.net/yuanziokFENGQIYUNRANFeelTouch Labshttps://blog.csdn.net/FENGQIYUNRANm0_38106923不脱发的程序猿https://blog.csdn.net/m0_38106923qq_34125999响彻天堂丶https://blog.csdn.net/qq_34125999wangjiaweiweiWangLanguagerhttps://blog.csdn.net/wangjiaweiweiwylfengyujianchengYeliang Wuhttps://blog.csdn.net/wylfengyujianchenglidew521脑瓜凉https://blog.csdn.net/lidew521oscar999oscar999https://blog.csdn.net/oscar999arv002三雷科技https://blog.csdn.net/arv002david_520042厦门德仔https://blog.csdn.net/david_520042 7月（第二批）证书发放名单（50位） CSDN ID用户昵称主页链接it_xiangqiang全栈技术博客https://blog.csdn.net/it_xiangqiangqq_19309473Roc-xbhttps://blog.csdn.net/qq_19309473iamonlymeYoungerChinahttps://blog.csdn.net/iamonlymetoto1297488504to.tohttps://blog.csdn.net/toto1297488504wizardforcel布客飞龙https://blog.csdn.net/wizardforcelqq_34414530蚂蚁小兵https://blog.csdn.net/qq_34414530heihaozi万猫学社https://blog.csdn.net/heihaozimeiqi0538科皮子菊https://blog.csdn.net/meiqi0538youanyyouJava技术栈https://blog.csdn.net/youanyyouinthat西京刀客https://blog.csdn.net/inthatweixin_39541632Jia minghttps://blog.csdn.net/weixin_39541632f641385712方向盘(YourBatman)https://blog.csdn.net/f641385712jiangguilong2000流子https://blog.csdn.net/jiangguilong2000lj2048静静喜欢大白https://blog.csdn.net/lj2048weixin_44225182海轰Prohttps://blog.csdn.net/weixin_44225182qq_33589510JavaEdge.https://blog.csdn.net/qq_33589510han1202012韩曙亮https://blog.csdn.net/han1202012weixin_43510203Sumaruahttps://blog.csdn.net/weixin_43510203w605283073明明如月学长https://blog.csdn.net/w605283073qq_38880380worthsenhttps://blog.csdn.net/qq_38880380u011018979iOS逆向https://blog.csdn.net/u011018979shaoyezhangliwei再见孙悟空_https://blog.csdn.net/shaoyezhangliweiu013468614windSeShttps://blog.csdn.net/u013468614qq_35427589共饮一杯无https://blog.csdn.net/qq_35427589wangyaninglmshiterhttps://blog.csdn.net/wangyaninglmxiaolong1126626497DS小龙哥https://blog.csdn.net/xiaolong1126626497zhangchen124teayearhttps://blog.csdn.net/zhangchen124cui_yonghuacui_yonghuahttps://blog.csdn.net/cui_yonghuaweixin_43135178马鹏森https://blog.csdn.net/weixin_43135178qq_41684621兮动人https://blog.csdn.net/qq_41684621lovely_yoshinoHermit_Rabbithttps://blog.csdn.net/lovely_yoshinoqq_24312945记帖https://blog.csdn.net/qq_24312945wodeyijia911多则惑少则明https://blog.csdn.net/wodeyijia911qq_33487044内核笔记https://blog.csdn.net/qq_33487044weixin_43178406爱编程的喵喵https://blog.csdn.net/weixin_43178406caimousecaimousehttps://blog.csdn.net/caimouseguorui_java哪 吒https://blog.csdn.net/guorui_javasuiyingyCoding的叶子https://blog.csdn.net/suiyingyqq_35387940小目标青年https://blog.csdn.net/qq_35387940w1014074794斗者_2013https://blog.csdn.net/w1014074794lixiaogang_theanswer内核之道https://blog.csdn.net/lixiaogang_theanswerm0_37602827little_fat_sheephttps://blog.csdn.net/m0_37602827wl1780852311顾道长生'https://blog.csdn.net/wl1780852311weixin_35770067安替-AnTihttps://blog.csdn.net/weixin_35770067weixin_39709134java李杨勇https://blog.csdn.net/weixin_39709134u022812849morris131https://blog.csdn.net/u022812849qq_35812205山顶夕景https://blog.csdn.net/qq_35812205u012410733carl-zhaohttps://blog.csdn.net/u012410733superfjjflydean程序那些事https://blog.csdn.net/superfjjhzw2312BUG胡汉三https://blog.csdn.net/hzw2312 8月（第三批）证书发放名单（54位） CSDN ID用户昵称主页链接lvoelife念兮为美念兮为美的博客_CSDN博客-java,mysql,springboot领域博主qq_42229253听雪闻歌听雪闻歌的博客_CSDN博客-三维建模(3dmax/SketchUp)初级、进阶与高级,Java基础与进阶,Creo初级与进阶领域博主weixin_38239050小星星丨U3D开发支持小星星丨U3D开发支持的博客_CSDN博客-C#,Unity功能点,⭐️U3D实用插件集合⭐️领域博主weixin_47723732王小王-123王小王-123的博客_CSDN博客-数据库原理及其应用,《50篇》机器学习之Python开源教程,数据炫酷可视化之模板大全领域博主yetaodiaoyetaodiao的博客_CSDN博客-php,java,web领域博主YuDBL华哥折腾历险记华哥折腾历险记的博客_CSDN博客-web前端（H5）,错误累积（错题本）,安卓开发领域博主Jmilk范桂飓https://blog.csdn.net/Jmilku012486840somnus_小凯somnus_小凯的博客_CSDN博客-linux,java,nginx领域博主weixin_43949535孤傲小二~阿沐孤傲小二~阿沐的博客_CSDN博客-PostgreSQL的学习心得和知识总结,数据结构与算法,C++的学习心得和知识总结领域博主huyuchengusHoneyMooseHoneyMoose的博客_CSDN博客-Confluence,CWIKIUS,Java领域博主qq_38403590我要用代码向我喜欢的女孩表白我要用代码向我喜欢的女孩表白的博客_CSDN博客-BUG,bigdata-大数据专栏,java领域博主Together_CZTogether_CZTogether_CZ的博客_CSDN博客-编程技术,python实践,机器学习领域博主qq_29235677奇点_97https://blog.csdn.net/qq_29235677ReCclayReCclayhttps://blog.csdn.net/ReCclaykangweijian小康师兄小康师兄的博客_CSDN博客-Android,ESP32-C3入门教程,杂七杂八领域博主promsing小小张自由—&gt;张有博https://blog.csdn.net/promsingA_art_xiang秃了也弱了。秃了也弱了。的博客_CSDN博客-java,springboot,jvm领域博主jingerppp私房菜https://blog.csdn.net/jingerppphy592070616von Neumannvon Neumann的博客_CSDN博客-机器学习中的数学,算法设计与分析,系统学习Python领域博主SunnyYoona@SmartSihttps://blog.csdn.net/SunnyYoonaqq449245884@大迁世界@大迁世界的博客_CSDN博客-前端,javascript,Vue领域博主liangklfangliangklfanghttps://blog.csdn.net/liangklfangu012515223SpikeKinghttps://blog.csdn.net/u012515223lyndon_liLi-Yongjunhttps://blog.csdn.net/lyndon_lihhhhhhhhhhwwwwwwwwwwAI浩AI浩的博客_CSDN博客-人工智能,C#和WinFrom,图像分类领域博主Octopus21ZWZhangYuZWZhangYu的博客_CSDN博客-分布式和微服务理论与实践,数据库,开发工具和组件领域博主shanglianlmmingo_敏https://blog.csdn.net/shanglianlmqq_36478920Swift社区Swift社区的博客_CSDN博客-Swift,iOS集,python集领域博主weixin_43013761江南才尽，年少无知！江南才尽，年少无知！的博客_CSDN博客-RK3399移植,姿态估计,(01)ORB-SLAM2源码无死角解析-免费领域博主qq_36380426pingan8787pingan8787的博客_CSDN博客-Cute-JavaScript,3-JavaScript,4-Vuejs2.0领域博主s_lishengchirpylichirpyli的博客_CSDN博客-数据库,Rust,区块链领域博主mydo大熊猫侯佩大熊猫侯佩的博客_CSDN博客-Cocos2D苹果游戏开发,iOS开发之旅,Apple开发入门领域博主wirelessqa毕小烦https://blog.csdn.net/wirelessqaqq_41895747沉迷单车的追风少年沉迷单车的追风少年的博客_CSDN博客-经验问题汇总,LeetCode,Qt开发领域博主CielleeCielleeXCielleeX的博客_CSDN博客-Linux内核,数据结构与算法,Qualcomm经验总结领域博主java_wxidjava_wxidjava_wxid的博客_CSDN博客-中级开发进阶,高级开发进阶,Redis领域博主fengyuwuzu0519【星星之火】【星星之火】的博客_CSDN博客-S3C2440,S3C2440学习之旅,Linux子系统领域博主universsky2015禅与计算机程序设计艺术禅与计算机程序设计艺术的博客_CSDN博客-Kotlin 开发者社区,Kotlin,架构设计领域博主l848168技术武器库https://blog.csdn.net/l848168Dr_Guo光于前裕于后光于前裕于后的博客_CSDN博客-大数据动物园,大数据基础知识,Spark领域博主qq_39591494延瓒@yankerp延瓒@yankerp的博客_CSDN博客-自动化运维脚本开发,Python全栈开发【持续更新中....】,解决方案领域博主qq8864特立独行的猫ahttps://blog.csdn.net/qq8864u013253075咸鱼弟咸鱼弟的博客_CSDN博客-单片机设计,Linux,计算机类设计领域博主qq_22473611四月天03四月天03的博客_CSDN博客-数据治理DAMA,数仓&amp;数据中台,Flink领域博主BIT_666BIT_666https://blog.csdn.net/BIT_666leftfist左直拳左直拳的博客_CSDN博客-.NET,学习笔记,JavaScript领域博主qq_34137397穆雄雄穆雄雄的博客_CSDN博客-java技术,JavaScript,数据库领域博主u011344545MJ卡尔曼的鱼MJ卡尔曼的鱼的博客_CSDN博客-卫星导航,程序语言设计（C语言、C++、Matlab、Python等）,MATLAB之计算机视觉与深度学习领域博主qq_21950671小秋SLAM实战教程小秋SLAM实战教程的博客_CSDN博客-从零开始学习SLAM,ORB_SLAM2代码实战教程,OpenCV代码实战教程领域博主weixin_44259720Java Punkhttps://blog.csdn.net/weixin_44259720dpjcn1990单片机菜鸟哥https://blog.csdn.net/dpjcn1990xw1680Amo Xianghttps://blog.csdn.net/xw1680zong596568821xp宗而研之宗而研之的博客_CSDN博客-Linux,Python,NVIDIA Jetson领域博主zhouzhiwengang在奋斗的大道在奋斗的大道的博客_CSDN博客-python 学习笔记,java 基础知识,微服务springboot领域博主 9月（第四批）证书发放名单（51位） CSDN ID昵称博客主页LSGO_MYP青少年编程竞赛交流青少年编程竞赛交流的博客_CSDN博客-Scratch四级真题解析【电子学会】,Scratch三级真题解析【电子学会】,Scratch一级真题解析【电子学会】领域博主jiaoyangwm呆呆的猫呆呆的猫的博客_CSDN博客-目标检测,Android,python学习笔记领域博主zhengzaifeidelushang勇敢羊羊在飞奔勇敢羊羊在飞奔的博客_CSDN博客-大数据,日常分享专栏,软考高级系统架构设计师考试领域博主weixin_42981560前端技术栈前端技术栈的博客_CSDN博客-前端面试题,js,vue领域博主inthirtiesinthirtiesinthirties的博客_CSDN博客-跟Inthirties学Oracle,Oracle 每日一帖,Oracle数据库管理专栏领域博主walykyy与自己作战与自己作战的博客_CSDN博客-Linux,Java基础,MySQL领域博主TZ845195485所得皆惊喜所得皆惊喜的博客_CSDN博客-JUC并发编程,JVM虚拟机,商城项目 - Mall Project领域博主qq_38526573波波烤鸭波波烤鸭的博客_CSDN博客-SPRING-CLOUD系列,面试题汇总,SPRINGBOOT系列领域博主uniquewonderqThink_BiggerThink_Bigger的博客_CSDN博客-Java专栏,算法,ElasticSearch 从入门到实战领域博主qq_41112170乔卿乔卿的博客_CSDN博客-程序设计实验,程序设计与算法,数据库系统领域博主hebtu666兔老大RabbitMQ兔老大RabbitMQ的博客_CSDN博客-leetcode,os/设计模式/耳机/测试/导图/资源 杂记,数据结构与算法领域博主slandarerslandarerslandarer的博客_CSDN博客-MATLAB 笔记,MATLAB 科学绘图,MATLAB 游戏领域博主sinat_33087001存在morning存在morning的博客_CSDN博客-高频算法题训练,C#技术合集,软件设计模式领域博主Xin_101天然玩家天然玩家的博客_CSDN博客-Java ABC,Spring,架构设计领域博主Mculover666Mculover666Mculover666的博客_CSDN博客-STM32全链路开发实战教程,i.MX6ULL开发笔记,linux领域博主qq_22695001白鹿第一帅白鹿第一帅的博客_CSDN博客-Java 基础与高级开发应用,集成开发环境应用与开发（IDE）,开源社区与技术测评（开源布道师）领域博主hacker_long言有三言有三的博客_CSDN博客-deep learning,AI工程师修行之路,开源框架领域博主YangCheneyOxYGCOxYGC的博客_CSDN博客-Java / C++ / C# ....,Install / Deploy / Release,Unix / Linux / Windows / OS领域博主qq_38723677莫逸风莫逸风的博客_CSDN博客-E__随笔,B5__算法刷题,MYF_牛客面试笔刷101题（Java版）领域博主lucky51222刘一哥GIS刘一哥GIS的博客_CSDN博客-《GIS/ArcGIS风暴》,《VS/C/C++/C#》,《GIS程序设计》领域博主weixin_43838785李响Superb李响Superb的博客_CSDN博客-算法,深度学习入门到精通系列讲解,Android开发领域博主WannaHaha林锋Space林锋Space的博客_CSDN博客-windows,网络,路由交换配置领域博主qq446282412字节卷动字节卷动的博客_CSDN博客-我的Android进阶之旅,Android常见错误解决之道,渲染技术：OpenGL ES、Filament领域博主chehec2010月疯月疯的博客_CSDN博客-【健康医疗】,【HTML5】,【web前端基础知识】领域博主weixin_44936889BIT可达鸭BIT可达鸭的博客_CSDN博客-▶ 深度学习-计算机视觉,深度学习-模型压缩（蒸馏剪枝量化）,多模态Vision+Language领域博主qq_36119192谢公子谢公子的博客_CSDN博客-域环境渗透,网络安全工具使用集锦,linux系统安全领域博主Naisu_kunNaisu XuNaisu Xu的博客_CSDN博客-ESP32与ESP8266相关,Web与JS相关,嵌入式Linux与设备相关领域博主weixin_43734095萌宅鹿同学萌宅鹿同学的博客_CSDN博客-《Java 从 0 到架构师》,《恋上数据结构》,《黑马设计模式详解》领域博主JiShuiSanQianLi击水三千里击水三千里的博客_CSDN博客-算法,大数据,面试领域博主CC1991_三掌柜666三掌柜666的博客_CSDN博客-iOS开发--付费,萌新程序猿疑问解答--付费,常识领域博主weixin_38316697栗子~~栗子~~的博客_CSDN博客-JAVA,多线程/高并发,dos领域博主bisalbisal(Chen Liu)bisal(Chen Liu)的博客_CSDN博客-技术之我见,Oracle,个人心得领域博主weixin_43606158吴迪98吴迪98的博客_CSDN博客-吴小迪专栏之原生JS,React的专栏,笔者个人小笔记领域博主weixin_43823808宋子浩宋子浩的博客_CSDN博客-【Java刷题】,Python刷题（轻工业OJ）,【JavaSE核心内容】领域博主CodingFireCodingFireCodingFire的博客_CSDN博客-iOS日常开发,Core Animation,Flutter实用开发技巧合集领域博主Jun-53小羊子说小羊子说的博客_CSDN博客-Android,Android 架构之路,Android 性能优化领域博主david_lvdavid_lvdavid_lv的博客_CSDN博客-领域博主K346K346恋喵大鲤鱼恋喵大鲤鱼的博客_CSDN博客-Linux 命令,C++,算法与数据结构领域博主u013818205黄菊华老师黄菊华老师的博客_CSDN博客-毕业设计,视频教程,uni-app领域博主qq_34623621C君莫笑C君莫笑的博客_CSDN博客-Qt 学习之路,人生苦短-我用Python,OpenCV图像处理领域博主fengbingchunfengbingchunfengbingchun的博客_CSDN博客-C/C++/C++11,OpenCV,Deep Learning领域博主wuyoudeyuerCarl_奕然Carl_奕然的博客_CSDN博客-Python开发实战及代码示例讲解,Selenium(从入门到框架设计),全链路压测(从理论到流量平台选型搭建再到真实系统改造预演)领域博主vbirdbest风流 少年风流 少年的博客_CSDN博客-Spring Boot从入门到实战,iOS,Axure RP 从入门到精通领域博主FUTEROXHuteroxHuterox的博客_CSDN博客-突发奇想,笔记,web学习领域博主u012702547_江南一点雨_江南一点雨的博客_CSDN博客-关于Spring Boot,管中窥豹,java领域博主weixin_42782150Yale曼陀罗Yale曼陀罗的博客_CSDN博客-数据分析-pandas,Mac系统Python环境配置,Linux系统领域博主qq_45034708吾仄lo咚锵吾仄lo咚锵的博客_CSDN博客-算法,Java,安装配置教程领域博主diandianxiyu小雨青年小雨青年的博客_CSDN博客-PHP实践问题集锦,琐事杂谈,PMP新考纲备考笔记领域博主elim168elim168elim168的博客_CSDN博客-Spring,Spring核心之bean,SpringMVC简介领域博主qq_38131812漫游嵌入式漫游嵌入式的博客_CSDN博客-嵌入式Linux实战开发教程,Linux图形驱动与桌面,《ARMv8架构初学者指南》领域博主melody157398布道师Peter布道师Peter的博客_CSDN博客-Android,linux,Multimedia领域博主 10月（第五批）证书发放名单（53位） CSDN ID昵称博客主页qq_21137441林中静月下仙林中静月下仙的博客_CSDN博客-C++,Linux,奇怪的知识领域博主m0_37816922微小冷微小冷的博客_CSDN博客-一些过时的内容,Python,Python标准库领域博主yangshangwei小小工匠小小工匠的博客_CSDN博客-【小工匠聊架構】,【ES-Elasticsearch】,【Oracle基础】领域博主super828CodeAllen嵌入式编程CodeAllen嵌入式编程的博客_CSDN博客-②-STM32深入实践教程,CodeAllen （嵌入式编程）,高级C语言领域博主lifetragedyTGITCICTGITCIC的博客_CSDN博客-架构师修练之道,架构师之路,flink领域博主FMC_WBL小明java问道之路小明java问道之路的博客_CSDN博客-《计算机底层原理》[更新中],精讲笔试面试企业题库,程序人生领域博主abu935009066lakernotelakernote的博客_CSDN博客-《从零搭建开发脚手架》,《Spring Cloud - 实战》,《你悟了没 - 架构之路》领域博主qq_22795513我去热饭我去热饭的博客_CSDN博客-有手就会写的接口测试平台,饭谈,测试开发日记领域博主weixin_44593822深海鱼肝油ya深海鱼肝油ya的博客_CSDN博客-PyQt5,Blue_Bridge,CV领域博主qq_15719613TwcatL_treeTwcatL_tree的博客_CSDN博客-JAVA_Web,我和我的C语言,Java领域博主Leytton李乾文李乾文的博客_CSDN博客-【电子嵌入式】,【机器学习】,【前端开发】领域博主qq_19734597张志翔 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04243349cb14bf403ade3601931dadb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e909247d92164ee1eb072361057a7ac9/" rel="bookmark">
			SpringCloud OpenFeign token中转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenFeign 的本质是调用指定服务的 Controller。
前后端分离项目，调用 Controller 是需要传递 token 的。
OpenFeign 并不会自动携带 token 去访问 Controller，所以需要手动进行中转。
手动进行 token 中转比较简单，只需要一个配置类即可实现。
import cn.hutool.core.util.ObjUtil; import feign.RequestInterceptor; import lombok.extern.slf4j.Slf4j; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.http.HttpServletRequest; @Slf4j @Configuration public class OpenFeignConfig { @Bean public RequestInterceptor requestInterceptor() { return requestTemplate -&gt; { String token; // 请求方 ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (ObjUtil.isEmpty(requestAttributes)) { return; } else { // 获取请求方token HttpServletRequest request = requestAttributes.getRequest(); token = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e909247d92164ee1eb072361057a7ac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ddcc67af00cb34f94e5932d8c74290/" rel="bookmark">
			redis缓存为什么要延时双删
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、只先删缓存 问题：先删缓存，在改库前，其他事务又把旧数据放到缓存里去了。
二、只后删缓存 问题1：改了库，清理缓存前，有部分事务还是会拿到旧缓存
问题2：为了避免缓存清除失败带来的风险，起到在每次操作数据库之前，都还原到没有产生缓存之前的效果。（当然如果能够做好回滚与配置好数据库隔离级别，这条可以忽略）
三、普通双删 问题：第一次清空缓存后、更新数据库前：其他事务查询了数据库hang住
第二次清空缓存后：其他事务更新缓存，此时又会把旧数据更新到缓存
四、为什么需要延时双删？ 在三中，第二次清空缓存之前，多延时一会儿，等B更新缓存结束了，再删除缓存，这样就缓存就不存在了，其他事务查询到的为新缓存。
延时是确保 修改数据库 -&gt; 清空缓存前，其他事务的更改缓存操作已经执行完。
五、以上策略还能不能完善 四中说到，采用延时删最后一次缓存，但这其中难免还是会大量的查询到旧缓存数据的。
这时候可以通过加锁来解决，一次性不让太多的线程都来请求，另外从图上看，我们可以尽量缩短第一次删除缓存和更新数据库的时间差，这样可以使得其他事务第一时间获取到更新数据库后的数据。另外，该方式（第5种，相对第2种，只后删缓存的，可以大大的减少获取到旧缓存的数量）
可以参考：缓存处理流程
参考redis缓存为什么要延时双删
更细粒度的（Key级别）互斥锁
分段锁使用注意事项
分段锁 /** * * @Explain: key锁（要保证key的hashCode不变,否则无法释放锁。即加锁之后不要手动更改lockMap） */ @Component public class LoadKeyLock&lt;T&gt; { //默认分段数量 private Integer segments = 16; private final HashMap&lt;Integer, ReentrantLock&gt; lockMap = new HashMap&lt;&gt;(); public LoadKeyLock() { init(null, false); } public LoadKeyLock(Integer counts, boolean fair) { init(counts, fair); } private void init(Integer counts, boolean fair) { if (counts !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31ddcc67af00cb34f94e5932d8c74290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06a41034dec28e4f3e0e194555b791b/" rel="bookmark">
			undefined reference to `XXX::staticMetaObject‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：此篇文章是个人学习笔记，并非教程，所以内容可能不够严谨。可作参考，但不保证绝对正确。如果你发现我的文章有什么错误，非常欢迎指正，谢谢哦。
当手动为自定义的类添加Q_OBJECT后进行编译时产生了此错误。
只需要右键项目，选择执行qmake，再重新编译运行即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b16a5d2f27cba603e06e7f35502864/" rel="bookmark">
			pnpm install 报 ERR_PNPM_LINKING_FAILED Error: EPERM: operation not permitted, rename
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过 nvm 安装了某个版本的 node,之后又通过 npm install pnpm -g 安装 pnpm 了, 此时 pnpm 版本号是 v8.7.5,然后在项目中执行 pnpm install 报如下错误: ERR_PNPM_LINKING_FAILED Error: EPERM: operation not permitted, rename 然后自己查找解决方案, 包括网友们给的各种方案, 都没有解决我遇到的这个问题
可能我的这个问题产生的原因比较特殊吧, 后来不经意的一个念头想了想, 回退下 pnpm 的版本呢, 然后直接就成功呢
原因可能是 pnpm 版本太高, 校验太严格了导致的
总结–我的这个问题的解决方案是:
降低 pnpm 的版本就好了 npm install -g pnpm@8.6.2 降低版本后, 然后再 pnpm install , 我的项目就不报上面的错误了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12bb3458a13a1064b2187c2bfee181c1/" rel="bookmark">
			有哪些常用的压力测试工具，移动网站压力测试流程有哪些内容？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压力测试工具
在移动网络飞速发展的今天，移动网站成为企业对外宣传、开展业务的重要窗口，
对于访客量大的网站来说，一旦其无法承受过于巨大的流量，就会使网站崩溃，进而影响公司正常的业务。与之相对应的，做好移动网站的压力测试工作刻不容缓。
一、什么是软件压力测试？
压力测试是软件测试的一种类型，它要求在计算机数量较少或系统资源匮乏的条件下运行测试，考察的是不同软硬件环境下系统软件对于多用户的承受能力，是正确评估软件产品性能的一种测试类型。
二、有哪些常用的压力测试工具？
1. Webbench
Webbench是知名的网站压力测试工具，由Lionbridge公司开发，它能测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。
2. Apache Bench
Apache Bench是Apache服务器的一个web压力测试工具，简称ab。它可以模拟多个用户对某个网站发起访问，灵活小巧、易学易用，适合中小型互联网企业，但它的测试结果不能以图形显示。
3. Loadrunner
Loadrunner模拟用户的效果极其逼真，可进行独立的单元测试，可它学习成本高，需要专业素养较强的人方可熟练使用。
三、移动网站压力测试流程
1. 确定测试需求
根据用户需求确定测试点，明确测试人员职责、所需工具、时间和地点。
2. 编写测试用例
测试人员根据测试需求编写测试用例。
3. 执行测试用例
确定操作用户数量、时间要求等；通过测试工具模拟操作用户数量，用户同时在线数量等，以及不同用户值情况下系统的响应时间等。
标签：性能测试、压力测试
文章来源：有哪些常用的压力测试工具，移动网站压力测试流程有哪些内容？ - 成都柯信优创信息技术服务有限公司
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b842cb2a47ca9890a0a11f198a443ff3/" rel="bookmark">
			越面越退步，腾讯QQ、技术中台&amp;amp；美团基础研发平台一面挂集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题解 | #简单密码#
import sysmap_before = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'map
东方财富秋招 | 上海|南京|成都多base可选
投递链接： 投递链接内推码：NTAWaXE待遇丰厚，签字费dd
HoYoverse（米哈游新加坡）数据岗校招
岗位是Data Analyst - StarRail (Fresh Grad)，也就是星铁的数分虽然机会渺茫，但是还是想问问有没有同学是申请同一个岗的！目前我在
xxxx
额呃呃呃
蚂蚁意向
蚂蚁转正意向发啦，开摆！
题解（适合萌新 ）| #密码验证合格程序#
import redef kind_is_ok(strs): # 判断种类是否大于等于3种 kind = [0, 0, 0, 0] for
题解 | #计算一元二次方程#
#include &lt;stdio.h&gt;#include&lt;math.h&gt;int main() { float a, b, c; 许愿顺利拿到大疆offer
佬，满帮集团了解一下，流程快，薪资高
极氪面经
面试智驾算法岗，主要都是按照简历问的，问做过的项目，之后根据项目提问题，一道手撕（没撕出来），无八股，面试总时长是一个半小时左右，三个面试官，但是只有一个面试官
秋招拿不到offer，我将引爆地球。
哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈都给我鼠！
这个时候收到大疆一面应该是KPI了吧
而且时间有点赶不过来，看看能不能调整面试时间，一轮游，主打体验😂😂😂 #晒一晒我的offer# #24届软开秋招面试经验大赏# #大疆求职进展汇总# #秋
海康威视前端笔试题
在做题之前会让选择框架选择题 = 单选题 + 多选题多选题 考了webpack vite相关简答题 2道 ：1）看程序写结果 Promise嵌套setTimeo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b842cb2a47ca9890a0a11f198a443ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c24d330da0d79e4b37f72484445ad0/" rel="bookmark">
			分享Linux 查看内存使用情况的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 查看内存使用情况的几种方法包括使用 free 命令、top 命令、htop 命令、vmstat 命令和/proc/meminfo 文件。这些方法可以帮助用户了解系统内存的使用情况，包括总内存、已用内存、空闲内存、缓存和交换分区等信息。
在运行 Linux 系统的过程中为了让电脑或者服务器以最佳水平运行，常常需要监控内存统计信息。
那么今天我们就来看看有哪些方法可以访问所有相关信息并帮助管理员监控内存统计信息。
查看或者获取 Linux 中的内存使用情况既可以通过命令的方式，也可以通过桌面端的GUI程序查看。
以下的过程，所有命令和结果都是使用 Linux 发行版 Ubuntu 18.04。
GUI 查看 如果你使用的环境是带有图形界面的 Linux 版本，那么必定是支持使用图形界面进行服务器管理的。那么，内存使用情况的可视化会使得某些数据集更加清晰自然。
如何访问系统监视器： 导航到显示应用程序。 在搜索栏中输入 System Monitor 并访问该应用程序。 选择资源选项卡。 显示实时内存消耗的图形概览，包括历史信息。
命令获取 虚拟文件 /proc/meminfo 在 linux 系统中，/proc/meminfo 是一个报告可用和已用内存量的虚拟文件，它包含有关系统内存使用情况以及内核使用的缓冲区和共享内存的实时信息。根据所讨论的计算机体系结构和操作系统版本，从该文件读取的输出可能略有不同。
输入指令
cat /proc/meminfo 指令返回
命令 free 在命令终端中键入 free
数据表示已用/可用内存和以KB为单位的交换内存大小。
total总安装内存used正在运行的进程当前正在使用的内存(used= total – free – buff/cache)free未使用的内存（free= total – used – buff/cache）shared多个进程共享的内存buffers作系统保留的内存，在进程需要时分配为缓冲区cached存储在 RAM 中最近使用的文件buff/cacheBuffers + Cacheavailable可用于启动新应用程序，无需交换的内存大小 和读取 /proc/meminfo 文件相比，free 命令提供的信息较为精简，但是它更容易理解。
为了更灵活输出结果，free 命令可以添加多个选项标志用来格式化输出。下表列出了 free 命令最有用的选项标志。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68c24d330da0d79e4b37f72484445ad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56687f6f696fc080caef11cf93ac738/" rel="bookmark">
			jvm的内存调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1) 堆
运行时数据区域，所有类实例和数组的内存均从此处分配。Java 虚拟机启动时创建。对象的堆内存由称为垃圾回收器 的自动内存管理系统回收。
堆由两部分组成:
其中eden+fromspace+tospace也叫年轻代(young),old space叫旧生代.
其中还有S1,S0(在JDK的自带工具输出中会看到),分别指的是Survivor space,存放每次垃圾回收后存活的对象.
Old Generation , 主要存放应用程序中生命周期长的存活对象
垃圾回收主要是对Young Generation块和Old Generation块内存进行回收，YG用来放新产生的对象，经过几次回收还没回收掉的对象往OG中移动，
对YG进行垃圾回收又叫做MinorGC，对OG垃圾回收叫MajorGC，两块内存回收互不干涉
2) 非堆内存
JVM具有一个由所有线程共享的方法区。方法区属于非堆内存。它存储每个类结构，如运行时常数池、字段和方法数据，以及方法和构造方法的代码。它是在 Java 虚拟机启动时创建的。
除了方法区外，Java 虚拟机实现可能需要用于内部处理或优化的内存，这种内存也是非堆内存。 例如，JIT 编译器需要内存来存储从 Java 虚拟机代码转换而来的本机代码，从而获得高性能。 Permanent Generation （图中的Permanent Space） 存放JVM自己的反射对象，比如类对象和方法对象
3) 回收算法和过程
JVM采用一种分代回收 (generational collection) 的策略，用较高的频率对年轻的对象(young generation)进行扫描和回收，这种叫做minor collection，而对老对象(old generation)的检查回收频率要低很多，称为major collection。这样就不需要每次GC都将内存中所有对象都检查一遍。
当一个URL被访问时，内存申请过程 如下：
A. JVM会试图为相关Java对象在Eden中初始化一块内存区域
B. 当Eden空间足够时，内存申请结束。否则到下一步
C. JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）, 释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区
D. Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区
E. 当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集（0级）
F. 完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”
对象衰老的过程
young generation的内存，由一块Eden(伊甸园，有意思)和两块Survivor Space(1.4文档中称为semi-space)构成。新创建的对象的内存都分配自eden。两块Survivor Space总有会一块是空闲的，用作copying collection的目标空间。Minor collection的过程就是将eden和在用survivor space中的活对象copy到空闲survivor space中。所谓survivor，也就是大部分对象在伊甸园出生后，根本活不过一次GC。对象在young generation里经历了一定次数的minor collection后，年纪大了，就会被移到old generation中，称为tenuring。(是否仅当survivor space不足的时候才会将老对象tenuring?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f56687f6f696fc080caef11cf93ac738/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33831aadf2edd75034afbe2b23700e84/" rel="bookmark">
			Redis安装配置，哨兵模式配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 入门简介 Redis（Remote Dictionary Server 远程字典服务）是一个开源的高性能key-value数据库，它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型，官网：https://redis.io/。
Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供 list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。
Redis 安装部署 linux下载地址 wget http://download.redis.io/releases/redis-5.0.7.tar.gz 解压/编译文件 tar xzf cd redis-5.0.7/ make 编译成功后，进入 src 文件夹，执行 make install 进行 Redis 安装。 cd src/ make install 安装成功后显示
部署 由于 src 下文件非常多，我们可以将几个常用的命令和 conf 配置文件复制出来进行统一管理，如下：
新建 bin 和 etc 文件夹 cd /root/redis-5.0.7/ mkdir etc mkdir bin 回到安装目录，将redis.conf复制到 ect 文件夹下 cp redis.conf /root/redis-5.0.7/etc 进入 src 文件夹下，将mkreleasehdr.sh、redis-benchmark、redis-check-aof、redis-check-rdb、redis-cli、redis-server、redis-sentinel文件复制到 bin 文件夹 cd src/ cp mkreleasehdr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33831aadf2edd75034afbe2b23700e84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd480eee161eaeb9537e95945825099c/" rel="bookmark">
			efuse相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		efuse 文章目录 efuse背景知识Secure BootCPU内部安全机制bootROMiRAMefuseSecurity EngineFirst Stage Bootloader（FSBL）根信任建立 NVMPROM &amp; OTPPROMOTP memory 结构memory repairhardrepairsoftrepair macro 概述efuse是什么？efuse的作用及应用场景Antifuseefuse是如何使用的 efuse的工作模式相关信号eFuse操作模式编程模式（Program Mode）读取模式（Read Mode）非活动模式（Inactivate Mode） Efuse设计思路 背景知识 Secure Boot 【NVMEM子系统】一、Efuse介绍及安全启动浅析 安全启动Secure Boot，其主要目的是：以限制消费者能力，防止消费者从软硬件层面，对产品的部分关键系统进行读写，调试等高级权限，达到对产品的商业保密，知识产权的保护。
安全启动的安全模型是建立在消费者是攻击者的假设之上，一般常见的操作有：
刷机安装自定义的操作系统绕过厂家封闭的支付平台绕过系统保护，复制厂家保护的数字产品。 除此之外呢，有的比较专业的消费者，还可以：
使用数字示波器监听 CPU 和 RAM 、eMMC 之间的数据传输来读取非常底层的数据传输而且像 eMMC 这种芯片通常都是业界标准化的，攻击者甚至可以把芯片拆下来，然后用市面上现成的通用 eMMC 编程工具来读写上面的内容。 安全启动等级也有一个上限：这个上限通常是认为攻击者不至于能够剥离芯片的封装，然后用电子显微镜等纳米级别精度的显像设备来逆向芯片的内部结构。
简单来说：能成功攻破芯片安全机制的一次性投资成本至少需要在十万美元以上才可以认为是安全的。
CPU内部安全机制 【NVMEM子系统】一、Efuse介绍及安全启动浅析 bootROM BootROM是集成在CPU芯片的一个ROM空间，其主要用于存放一小段可执行程序，出厂的时候被烧录进去写死，不可修改。
CPU在通电之后，执行的第一条程序就在BootROM，用于初始化Secure Boot安全机制，加载Secure Boot Key密钥，从 存储介质中加载并验证 First Stage Bootloader（FSBL）；最后跳转进 FSBL 中。
iRAM 为了避免使用外部的RAM，支持Secure Boot的CPU都会内置一块很小的RAM，通常只有 16KB 到 64KB ，我们称之为 iRAM。
这块 iRAM 上的空间非常宝贵，bootROM 一般会用 4KB 的 iRAM 作为它的堆栈。FSBL 也会被直接加载到 iRAM 上执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd480eee161eaeb9537e95945825099c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621698fe9aa55c9cddf9367e19796d67/" rel="bookmark">
			C&#43;&#43;中的双冒号(::) 使用小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、类外定义成员函数 class MyClass { public: void myFunction(); }; void MyClass::myFunction() { // 函数体 } 在这里双冒号用来指定成员方法属于哪一个类。
2、用于访问命名空间的元素 namespace MyNamespace { int myVariable = 42; } int main() { int x = MyNamespace::myVariable; return 0; } 这里用来指明变量所属的命名空间。
3、用于访问静态成员 class MyClass { public: static int myStaticVariable; }; int MyClass::myStaticVariable = 42; int main() { int x = MyClass::myStaticVariable; return 0; } 这里用于访问类的静态成员，这种方式并不需要一个实例便可访问。
4、用于访问基类成员 class BaseClass { public: void myFunction() { // ... } }; class DerivedClass : public BaseClass { public: void myFunction() { // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/621698fe9aa55c9cddf9367e19796d67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be01dfe3ffd26d43f29db1a61d65437/" rel="bookmark">
			《树莓派4B家庭服务器搭建指南》第二十一期：安装开源远程桌面服务rustdesk, 内网丝滑,外网流畅控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: 《树莓派4B家庭服务器搭建指南》第二十一期：安装开源远程桌面服务rustdesk, 内网丝滑,外网流畅控制Windows,macOS,Linux设备
tags:
个人成长
categories:树莓派不吃灰 前段时间, 有一台老式MacBook Pro被我改造成了影视资源解码主机, 《树莓派4B家庭服务器搭建指南》第十七期：树莓派配合性能更好的闲置笔记本搭建开源免费jellyfin私人影院 https://v2fy.com/p/2023-06-10-jellyfin-1686388142000/ , 我想通过远程桌面访问这台MacBook Pro, 发现Mac虽然原生支持VNC连接，但实际用起来经常画面撕裂，于是我找了一款开源的远程桌面程序rustdesk, 将其服务部署在树莓派上，实现局域网设备丝滑访问, 外网设备也可以通过内网穿透直接访问macOS
rustdesk 的Github开源地址 https://github.com/rustdesk/rustdesk
在树莓派部署rustdesk，实现局域网Windows控制macOS # 创建挂载目录 mkdir -p /opt/rustdesk chmod 755 -R /opt/rustdesk # 创建用于存放docker-compose.yml的目录 mkdir -p /opt/rustdesk-docker-compose-yml chmod 755 -R /opt/rustdesk-docker-compose-yml # 创建docker-compose.yml touch /opt/rustdesk-docker-compose-yml/docker-compose.yml 在docker-compose.yml中写入配置内容
cat &lt;&lt; 'EOF' &gt; /opt/rustdesk-docker-compose-yml/docker-compose.yml version: '3' networks: rustdesk-net: external: false services: hbbs: container_name: hbbs ports: - 21115:21115 - 21116:21116 - 21116:21116/udp - 21118:21118 image: rustdesk/rustdesk-server:latest command: hbbs -r rustdesk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8be01dfe3ffd26d43f29db1a61d65437/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d21d1ac0318aa7f9e160f44d8520abc/" rel="bookmark">
			scss的&amp;-
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.代码scss样式多层嵌套的问题
&amp; 用在嵌套代码里，来引用父元素
.swiper-slide { .comic{ .comic-content{ .comic-top{ } } } } 改为：
.swiper-slide { &amp;-comic{ } &amp;-comic-content{ } &amp;-comic-top{ } } 转换成css为
.swiper-slide-comic{ } .swiper-slide-comic-content{ } .swiper-slide-comic-top{ } 更改的代码的链接：
https://git.woa.com/TAFE/act-mobile-2022/commit/2ca445e1134ca793240742275804d34b50bfb635?view=parallel
2.Html的 规范：普通标签使用小写，外部引入的组件标签使用大写
3.使代码简洁，不要写大量重复的逻辑代码（公共方法需封装，公共样式提取到公共样式中）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e512416147af38dc71ee02ce08681dd/" rel="bookmark">
			element el-table 设置fixed导致行错乱问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看有问题的样式：
解决：
// 解决左右 对不齐 的情况 // el-table 左右有列固定时，fixed为left和right时，行未对齐解决办法 // * 产生原因： el-table底部有滚动条，固定列底部没有滚动条 // * 解决办法： 在el-table的表格中设置padding-bottom的内边距跟滚动条等高 /deep/.el-table__fixed, /deep/.el-table__fixed-left, /deep/.el-table__fixed-right { // 10 是我这里全局定义的滚动条的高度 height: calc(100% - 10px) !important; } /deep/.el-table__fixed-body-wrapper { height: 100% !important; } /deep/.el-table__fixed-body-wrapper .el-table__body { /*滚动条高度*/ // 10 是我这里全局定义的滚动条的高度 padding-bottom: 10px !important; } el-table 左右有列固定时，fixed为left和right时，行未对齐解决办法
产生原因： el-table底部有滚动条，固定列底部没有滚动条解决办法： 在el-table的表格中设置padding-bottom的内边距跟滚动条等高 参考：
el-table 设置fixed导致行错乱问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b7b02d5b00c075776596600035c4776/" rel="bookmark">
			Git在已有的项目中引入Submodule子模块管理：添加、更新、删除（实战示例代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在进行Git版本控制的过程中，有时候我们需要在已有的项目中引入子模块，以便复用其他独立的Git存储库的代码或文件。本文将详细介绍如何在已有项目下添加、更新和删除Git的Submodule子模块，并提供相关的示例代码。
实战场景 假设我们已经有一个主项目（my-main-project）的Git存储库，并且需要在该项目中创建一个名为devices的文件夹，并引入两个子模块module1和module2。
一、添加子模块 首先，进入my-main-project目录，在命令行或终端中执行以下命令来添加子模块。其中，URL-to-module1和URL-to-module2是指module1和module2的Git存储库的URL地址。
cd my-main-project git submodule add &lt;URL-to-module1&gt; devices/module1 git submodule add &lt;URL-to-module2&gt; devices/module2 添加后，Git会自动为子模块创建一个独立的目录，并从远程仓库中克隆子模块的代码到这个目录中。
二、提交子模块 添加完子模块后，需要将这些修改提交到主项目的Git存储库中。执行以下命令：
git commit -m "Add submodule: module1 and module2" 这将把子模块的修改作为一个提交记录添加到主项目的版本历史中。
提交完不要忘了合并到主分支上，要不然其他项目开发人员更新不到子模块。这里LZ是master提交的子模块，所以pull最新的代码，push上去即可
git pull origin master git push origin master 三、更新子模块 在其他开发人员克隆主项目之后，他们需要执行一些额外的步骤来初始化和更新子模块。他们可以通过以下命令完成初始化和更新子模块：
git submodule init git submodule update 这将初始化子模块并将其拉取到本地。
四、删除子模块 在某些情况下，我们可能需要删除不再需要的子模块。要删除子模块，可以执行以下步骤：
删除主项目的.gitmodules文件中子模块的相关条目，删除所有的子模块的话，整个.gitmodules文件删掉即可，否则会报错。删除主项目的.git/config 删除配置项中子模块相关条目。删除主项目的.git/module/* 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可删除子模块的目录及其内容。在以上的示例中，删除devices文件夹下要删除的子模块目录，如果删除所有子模块，那整个文件夹都删除。执行1-4步骤后，再执行添加子模块命令时候，如果仍然报错，执行如下命令删除暂存区下主项目的.git目录中与子模块相关的条目 #删除主项目的.git目录中与子模块相关的条目：git rm --cached 子模块名称 git rm --cached devices/module1 git rm --cached devices/module2 再次提交这些修改：
git commit -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b7b02d5b00c075776596600035c4776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6d57b4539b9f85b02f3ddb66f3d03b/" rel="bookmark">
			向量的点乘 a·b 和叉乘 a×b
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点乘: 点乘, 即|a|·|b|·cosθ, (结果是一个数字)
即: a的长度 * b的长度 * ab的夹角
夹角&lt;90°, 则cosθ&gt;0, 则结果&gt;0
夹角&gt;90°, 则cosθ&lt;0, 则结果&lt;0
用来判断敌人在我前面还是后面
我向前方发一条射线, 作为向量a
我向敌人发一条射线, 作为向量b
计算点乘结果
如果是正, 即夹角小于90°, 即敌人在我面前180°内
如果是负, 即夹角大于90°, 即敌人在我身后180°内
Vector3 a = me.forward; Vector3 b = enemy.position - me.position; float dot = Vector3.Dot(a, b); if(dot &gt; 0) { //敌人在我前边 } 还有什么用处呢?
1.求b在a上的投影长度
因为: a·b = |a|·|b|·cosθ
又因为: 投影长度 = |b|·cosθ
则: 投影长度 = a·b ÷ |a|
2.求θ的角度
已知a·b的情况下
cosθ = a·b ÷ |a| ÷ |b|
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6d57b4539b9f85b02f3ddb66f3d03b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f408ffba8f77e29cae9a722163f6d24e/" rel="bookmark">
			Chrome浏览器禁止更新调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Chrome浏览器禁止更新 打开Chrome浏览器，在地址栏中输入chrome://help，按下回车键
谷歌无法启动更新检查(错误代码为4: 0x80070005-system level) 快捷键 Win+R 输入：services.msc
找到 “Google 更新服务 (gupdatem)”、“Google 更新服务 (gupdate)”服务，改为手动。右键启动。
重新更新即可
Chrome浏览器翻译插件 https://github.com/Ponderfly/GoogleTranslateIpCheckWindow https://github.com/Ponderfly/GoogleTranslateIpCheck/releases/download/1.6/GoogleTranslateIpCheck-win-x64.zip Windows 需要使用管理员权限运行
Mac和Linux运行 需要执行
chmod +x GoogleTranslateIpCheck sudo ./GoogleTranslateIpCheck 如果所有IP都超时,请检查是否开了代理Mac 中使用: 打开终端 输入cd 把解压后的文件夹拖进终端，点击回车 复制粘贴代码，点击回车
chmod +x GoogleTranslateIpCheck
sudo ./GoogleTranslateIpCheckMac 提示来自不明身份: 系统偏好设置－－&gt;安全性与隐私—&gt;选择允许 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a11ace691dbea97f514e330738c414/" rel="bookmark">
			油烟在线监测仪-油烟监测系统-旭华智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在城市化进程不断加速的今天，餐饮业的繁荣发展与环境污染之间的矛盾日益凸显。其中，油烟污染问题更是备受关注。如何有效解决这一问题，切实保障员工和周边居民的健康，成为餐饮业亟待解决的难题。幸运的是，油烟在线监测仪的出现在一定程度上为这个问题提供了解决方案。
旭华智能油烟在线监测仪是一款专门针对饮食行业油烟排放监管的智能设备，它具备实时监测、智能控制、远程管理等功能，主要监测餐饮业废气中的油烟浓度、颗粒物浓度、非甲烷总烃浓度、温湿度以及风机净化器开关状态。并且该设备支持多烟道安装，一台主机可以安装多个监测探头，降低设备运行成本。
这款监控仪采用了硬件与软件结合的方式，油烟在线监测仪连接烟道、风机、净化器，并给净化器单独配备监控仪，连接到主机上，并将数据通过无线网络传输到云端平台进行存储和分析。一旦发现油烟浓度超标，系统会自动启动智能控制功能，调整设备运行状态，减少油烟的产生和排放，从而有效降低对环境和员工的危害。同时，饮食业油烟浓度在线监控仪还具备远程管理功能，管理者可以通过手机APP随时随地掌握油烟状况，及时采取措施。
此外旭华智能的这款产品，可实现监管和执法联动，设备通讯符合各地环保平台接入要求，并且和多地区达成了餐饮油烟在线自动监控（监测）系统数据传输协议，从而达到监管的目的。可以应用于餐饮单位、居民餐饮油烟集中治理、排放油烟的食品加工单位和非营利性单位食堂等油烟集中排放的场所，如酒店、中央厨房、快餐店、烧烤店、职工食堂等。
油烟在线监测仪的出现在餐饮业油烟污染治理方面具有里程碑式的意义。它不仅提高了餐饮业的环保意识和治理效果，还切实保障了员工的生活和健康。相信随着这款设备的广泛应用和推广，未来的餐饮业将更加健康、环保，让我们共同期待这一美好的未来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789a67399b666d21e595c1824fc5f058/" rel="bookmark">
			MySQL数据库的多种连接方式及工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQl命令行客户端 在Mysql安装完成后，Mysql命令行会自动配置在计算机上，在菜单中找到MySql 8.0 Command Line Client,输入密码即可进入。（密码在安装过程中设定的）
二、CMD命令进行连接 1.、按住win+r 建进入命令行
然后cd 到mysql的bin目录下，例如
cd D:
cd D:\Program Files\MySQL\MySQL Server 8.0\bin
mysql -u root -p 123456
2、或者直接去到bin目录里在目录框里输入cmd
mysql -u root -p 123456
3、直接进入，但要配置好环境。
按住win+r 建进入命令行
mysql -u root -p 123456
注意： -u后面为用户名，-p为密码
以上直接输入mysql -u root -p后报错是因为没有配置环境。找到环境变量进行配置，将Mysql的bin目录放到环境变量path中即可
在学习过程中比较快速的进入应选择第三中方法，配置好环境，win+R 进入命令框，在输入mysql -u root -p 123456即可，即可对数据库进行操作。
三、MySQL图形化管理工具 Mysql图形化管理工具采用C/S架构，用户通过安装在桌面计算机上的客户端软件连接并操作后台的Mysql数据库，客户端是图形化用户GUI，下面来介绍初学者使用的软件。
1、Navicat Premium 的使用 Navicat Premium 是一套数据库管理工具，让你以单一程序同時连接到 MySQL、MariaDB、SQL Server、SQLite、Oracle 和 PostgreSQL 数据库。 此外，它与 Drizzle、OurDelta 和 Percona Server 兼容，并支持 Amazon RDS、Amazon Aurora、Amazon Redshift、SQL Azure、Oracle Cloud 和 Google Cloud 等云数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/789a67399b666d21e595c1824fc5f058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e439c8c69ef67b970c5e93b2f18a6224/" rel="bookmark">
			Mac环境下如何配置Vue？一文就够！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装Homebrew Homebrew 是类似于 Mac App Store 的一个软件商店，对于Mac用户是必不可少的！如果没有安装的话，只需要在终端复制下面这段代码即可。
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 测试 Homebrew 是否正确安装
输入brew -v 出现版本信息即为安装成功。
2.安装node.js 已经安装Homebrew后，我们就用brew来安装 在终端中输入以下代码（也可以在官网 nodejs链接下安装）
brew install nodejs 安装完成后输入
node -v nom -v 若出现版本信息即为安装成功
3.安装cnpm 为了提高我们的效率，可以使用淘宝的镜像：http://npm.taobao.org/ ，在终端中输入以下代码：
npm install -g cnpm --registry=https://registry.npm.taobao.org 4.安装Vue.js 选择用package manager工具-npm ，在终端中输入以下代码：
npm install -g vue-cli 5.创建Vue项目 vue init webpack project_one “project_one” 替换成自己的项目名称即可。
接下来会出现一些设置选项，按步骤输入项目信息，注意Project name不支持大写字母为项目名，项目创建好后，它也给出了提示信息，继续操作即可。可以根据自己的需要进行选择，也可以直接按回车默认选项。
安装参数说明：
Vue build =&gt; 打包方式，回车即可；
Install vue-router =&gt; 是否要安装 vue-router 要 Y 回车；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e439c8c69ef67b970c5e93b2f18a6224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452e8e81ab786aed48bd856b38b7aaca/" rel="bookmark">
			如何在Excel中创建VBA程序--基于Office 365版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一 VBA程序简介二 为何选择VBA程序1. 高效便捷2. 自定义程度高3. 兼容性好 三 如何创建VBA程序1. 插入VBA程序：2. 使用VBA程序： 四 VBA程序应用场景示例1. 数据处理与分析2. 自定义函数3. 数据验证 五 VBA程序的优缺点及未来发展优点缺点 了解如何在Excel中创建VBA程序，对于提高数据处理和分析的效率非常有帮助。
本文将带你走进VBA的世界，介绍VBA程序的基础知识、在Excel中的使用和实际应用场景。
一 VBA程序简介 VBA，全称Visual Basic for Applications，是一种基于Visual Basic的编程语言，专为Microsoft Office软件套装设计。VBA的应用范围广泛，包括Excel、Word、Access等Office软件。通过VBA，我们可以编写自定义宏，自动执行重复性任务，简化日常工作流程。
二 为何选择VBA程序 1. 高效便捷 VBA程序可帮助我们在Excel中快速处理大量数据，实现自动化，提高工作效率。
2. 自定义程度高 可根据个人需求编写特定功能的宏，实现个性化定制。
3. 兼容性好 VBA程序可在多个Office软件中通用，方便用户在不同环境中使用。
三 如何创建VBA程序 1. 插入VBA程序： 在Office 365中，开启Excel，按下AltF11键，即可进入VBA编辑器。
2. 使用VBA程序： 在VBA编辑器中，可以通过插入模块的方式编写VBA代码。例如，在模块中输入以下代码，可在Excel工作表中的A列自动填充数字1到10：
Sub FillNumbers() Dim i As Integer For i = 1 To 10 Cells(i, 1).Value = i Next i End Sub 在Excel中打开VBA编辑器，在左侧的项目树中选择该工作簿，然后选择“运行”-&gt;“运行子/用户表单”（或直接按F5键），即可执行该宏，自动填充数字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452e8e81ab786aed48bd856b38b7aaca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d5a539605989eab27b4002d9f4dfc52/" rel="bookmark">
			Vue用JSEncrypt对长文本json加密以及发现解密失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽 大家好啊，最近发现进行加密后 超长文本后端解密失败，经过看其他博主修改
JSEncrypt原生代码如下：
// 分段加密，支持中文 JSEncrypt.prototype.encryptUnicodeLong = function (string) { var k = this.getKey(); //根据key所能编码的最大长度来定分段长度。key size - 11：11字节随机padding使每次加密结果都不同。 var maxLength = ((k.n.bitLength()+7)&gt;&gt;3)-11; try { var subStr="", encryptedString = ""; var subStart = 0, subEnd=0; var bitLen=0, tmpPoint=0; for(var i = 0, len = string.length; i &lt; len; i++){ //js 是使用 Unicode 编码的，每个字符所占用的字节数不同 var charCode = string.charCodeAt(i); if(charCode &lt;= 0x007f) { bitLen += 1; }else if(charCode &lt;= 0x07ff){ bitLen += 2; }else if(charCode &lt;= 0xffff){ bitLen += 3; }else{ bitLen += 4; } //字节数到达上限，获取子字符串加密并追加到总字符串后。更新下一个字符串起始位置及字节计算。 if(bitLen&gt;maxLength){ subStr=string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d5a539605989eab27b4002d9f4dfc52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d222cf692f68a32a2ef24abacf1bebfa/" rel="bookmark">
			【网络基础】——HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
HTTPS背景知识
HTTPS是什么？
加密解密
为什么要加密 常见的加密方式
对称加密
非对称加密
数据摘要&amp;&amp;数据指纹 数字签名 HTTPS工作过程探究
方案1：只使用对称加密
方案2：只使用非对称加密
方案3：双方都使用非对称加密
​编辑
方案4：非对称加密+对称加密
中间人攻击
证书的引入
数据签名
查看CA机构
方案5：非对称加密+对称加密+证书认证
HTTPS完整流程
HTTPS背景知识 HTTPS是什么？ HTTPS也是⼀个应用层协议。是在HTTP协议的基础上引入了⼀个加密层。
HTTP协议内容都是按照文本的方式明文传输的。这就会导致在传输过程中出现一些被篡改的情况。早期很多公司刚起步的时候，使用的应用层协议都是HTTP，而HTTP无论是用GET方法还是POST方法传参，都是没有经过任何加密的，因此早期很多的信息都是可以通过抓包工具抓到的。
为了解决这个问题，于是出现了HTTPS协议，HTTPS实际就是在应用层和传输层协议之间加了一层加密层（SSL&amp;TLS），这层加密层本身也是属于应用层的，它会对用户的个人信息进行各种程度的加密。HTTPS在交付数据时先把数据交给加密层，由加密层对数据加密后再交给传输层。
当然，通信双方使用的应用层协议必须是一样的，因此对端的应用层也必须使用HTTPS，当对端的传输层收到数据后，会先将数据交给加密层，由加密层对数据进行解密后再将数据交给应用层。
此时数据只有在用户层（应用层）是没有被加密的，而在应用层往下以及网络当中都是加密的，这就叫做HTTPS。
加密解密 什么是加密和解密？
加密就是把明文( 要传输的信息)进行一系列变换，生成密文。解密就是把密文再进行一系列变换，还原成明文。 在这个过程中，往往需要一个或者多个中间的数据，辅助进行这个过程，这样的数据被称为密钥（正确发音是yue四声，但是大家都读作yao四声）。
例如在电影《火烧圆明园》中，有人要谋反干掉慈禧太后。恭亲王奕䜣给慈禧递的折子。折子内容只是扯⼀扯家常，但是套上⼀张挖了洞的纸就能看到真实要表达的意思。慈禧通过一张挖了洞的纸解密出了折子要传递的信息。
在这个例子中：
明⽂:"当心肃顺，端华，戴恒密文：奏折全文密钥：挖了洞的纸 因此在古代其实人们早已能够运用加密和解密，而加密解密到如今已经发展成为一门独立的学科：密码学。而密码学的奠基人，也正是计算机科学的祖师爷之一，艾伦·麦席森·图灵。
计算机领域中的最高荣誉就是以他名字命名的“图灵奖”。
为什么要加密 早期接触互联网的人应该都或多或少地了解臭名昭著的“运营商劫持”事件。比如当我们要想下载一个软件的时候。未被劫持的效果，点击下载按钮，就会弹出你想要下载的软件的下载链接。
但是由于你发出的HTTP请求是明文传输的，并且一定要经过运营商的路由器，那么路由器收到你的HTTP请求之后经过分析得知你想要下载某一个软件，此时它便可以响应一个其它软件的下载链接给你，如果这时候你稍微一不注意就会下载到某些流氓软件。
劫持的具体过程如下：
中间人攻击
因为http的内容是明文传输的，明⽂数据会经过路由器、wifi热点、通信服务运营商、代理服务
器等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是中间人攻击 ，所以我们才需要对信息进行加密。
不止运营商可以劫持，其他的黑客也可以用类似的⼿段进行劫持，来窃取用户隐私信息，或者篡改内容.试想⼀下，如果黑客在用户登陆支付宝的时候获取到用户账户余额，甚⾄获取到用户的支付密码.....在互联网上，明文传输是非常较危险的事情!!!
HTTPS就是在HTTP的基础上进⾏了加密，进⼀步的来保证用户的信息安全。
常见的加密方式 对称加密 采⽤单钥密码系统的加密⽅法，同⼀个密钥可以同时⽤作信息的加密和解密，这种加密⽅法称为对称加密，也称为单密钥加密，特征：加密和解密所用的密钥是相同的常见的对称加密算法：DES、3DES、AES、TDEA、Blowfish、RC2等等特点：算法公开，计算量小，加密速度快，加密效率高 对称加密的原理
如果你还想知道更多的非对称加密算法，可以了解一下RSA，这是一个基于因式分解的非对称加密算法。下面我们简单理解一下对称加密，对称加密最典型的例子就是异或运算。
我们用A异或B得到一个中间值C，此时如果我们采用C异或B就能重新得到A。在这个过程中，A就相当于通信双方想要交互的数据，B就相当于对称加密当中的密钥，C就相当于被密钥加密后的数据，异或运算实际就是一个简单的对称加密算法。当然按位异或只是一个简单的对称加密。HTTPS使用的对称加密算法要复杂许多。
非对称加密 需要两个密钥来进行加密解密，这两个密钥是公开密钥和私有密钥常见的非对称算法：RSA、DSA、ECDSA特点：算法强度复杂，安全性依赖于算法与密钥，但是由于算法复杂，加密解密速度极慢 非对称加密要用到两个密钥，一个公钥一个私钥，可以：
通过公钥对明文加密，通过私钥对密文解密通过私钥对明文加密，通过公钥对密文解密 非对称原理涉及到的数学知识比较复杂，这里不作过多解释。
数据摘要&amp;&amp;数据指纹 数字指纹(数据摘要),其基本原理是利用单向散列函数(Hash函数)对信息进行运算，生成⼀串固定长度的数字摘要。数字指纹并不是⼀种加密机制,但可以用来判断数据有没有被窜改。摘要常见算法：有MD5、SHA1、SHA256、SHA512等，算法把无限的映射成有限，因此可能会有碰撞（两个不同的信息，算出的摘要相同，但是概率非常低）摘要特征：和加密算法的区别是，摘要严格意义不是加密，因为没有解密，只不过从摘要很难反推原信息，通常用来进行数据对比。 一般地，把对一个信息的摘要称为该消息的指纹或数字签名，数字签名是保证信息的完整性和不可否认性的方法。数据的完整性是指信宿接收到的消息一定是信源发送的信息，而中间绝无任何更改；信息的不可否认性是指信源不能否认曾经发送过的信息。其实，通过数字签名还能实现对信源的身份识别（认证），即确定"信源"是否是信宿意定的通信伙伴。 数字签名应该具有唯一性，即不同的消息的签名是不一样的；同时还应具有不可伪造性，即不可能找到另一个消息，使其签名与已有的消息的签名一样；还应具有不可逆性，即无法根据签名还原被签名的消息的任何信息。这些特征恰恰都是消息摘要算法的特征，所以消息摘要算法适合作为数字签名算法。
应用场景
比如某一个网站支持VIP功能，那么当VIP访问该网站的时候就需要输入密码来验证身份，如果直接将密码发送到网络当中，无论使用哪种协议总会有泄漏的可能性，因此我们可以将密码利用数据摘要算法生成⼀串固定长度的数字摘要。
网站的服务器数据库里面存储的同样是数字摘要，虽然我们不知道密码的具体内容，但是可以通过比较两个摘要来确定密码的正确性从而验证登录者的身份，这样就避免了直接用网络传输密码，从根本上保证了安全。
数字签名 摘要经过加密生成数字签名（主要应用于证书，后面详细解释）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d222cf692f68a32a2ef24abacf1bebfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b970a455575c8b9cea13b2bec273fe/" rel="bookmark">
			Redis Redis的数据结构 - 通用命令 - String类型命令 - Hash类型命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Redis的数据结构：
Redis命令：
通用命令：（通用指令是部分数据类型的，都可以使用的指令）
KEYS查询命令：
DEL删除命令：
EXISTS判断命令：
EXPIPE有效期设置命令：
TTL查看剩余期限命令：
String类型：
String的3种类型：
String类型的常见命令：
SET插入数据命令：
MSET多重插入命令：
GET获取数据命令：
MGET多重获取命令：
INCR自增命令：
INCRBY指定自增命令：
INCRBYFLOAT指定浮点数自增命令：
SETNX添加String类型键值对命令（前提是key不存在，否则不执行）
SETEX添加Sting类型键值对命令（指定有效期）
Redis的key的格式：
问题：Redis没有类似Mysql的Table的概念，我们该如何区分不同类型的key呢？
key的结构：
Hash类型
为什么需要使用Hash类型呢？ Hash类型的常见命令：
HSET key field value:添加或者修改hash类型的key和fired的值
HGET key field：获取一个hash类型的key的field的值
HMSET：添加多个hash类型的key的field值
HMGET：获取多个hash类型的key的field值
HGETALL：获取一个hash类型的key中所有的field和value
HKEYS：获取一个hash类型的key中的所有的field
HVALS：获取一个hash类型的key中的所有的value
HINCRBY：让一个hash类型key的字段值自增并指定步长
HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行
参考视频：黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目
Redis的数据结构： 我们能通过官方网站提供的文档来了解我们需要使用的redis数据类型
或者是使用命令help来查看
Redis命令： 通用命令：（通用指令是部分数据类型的，都可以使用的指令） 192.168.1.209:6379&gt; help @generic KEYS查询命令： 我们能通过help [command]可以查看一个命令的具体用法
192.168.1.209:6379&gt; help KEYS KEYS pattern summary: Find all keys matching the given pattern since: 1.0.0 group: generic 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1b970a455575c8b9cea13b2bec273fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f653180cc57419e834e9ff30ab9237f/" rel="bookmark">
			python_pip_配置_ 修改下载镜像源地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 python中pip配置下载镜像源1.1 Windows配置pip下载源1.2 Unix/类Unix 2 命令行修改法（1）命令行临时修改法（2）命令行永久修改法 3 国内源URL分享4 其他4.1 查看Python版本和pip的版本4.2 搜索需要安装的Python第三方库4.3 安装Python第三方库4.4 卸载Python第三方库4.5 指定库的版本号4.6 升级Python第三方库 1 python中pip配置下载镜像源 ​ pip是管理python的的第三方依赖包管理容器
1.1 Windows配置pip下载源 在c:\user\用户名 目录中创建pip目录，在目录里新建pip.ini文件，输入以下内容：
C:\Users\Administrator\pip\pip.ini文件中，自己配置的是：
[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 其他多余配置：
[global] index-url = https://mirrors.aliyun.com/pypi/simple/ [install] trusted-host = mirrors.aliyun.com 当下在第三方包时，配置的是清华源就会自动去此地址中下载
1.2 Unix/类Unix 在家目录下建立一个隐藏的pip目录，然后再创建一个名为pip.conf的配置文件,在pip.conf文件中输入如下内容即可
[root@~]# mkdir ~.pip [root@~]# vim ~.pip/pip.conf [root@~]# cat ~/.pip/pip.conf [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 2 命令行修改法 （1）命令行临时修改法 在用pypi下载python包的时候，可以直接使用pip install packagename -i参数,指定下载源的URL
pip install ping3 -i https://pypi.tuna.tsinghua.edu.cn/simple （2）命令行永久修改法 使用pip config set global.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f653180cc57419e834e9ff30ab9237f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5846db68978f1be73e39798f91d34237/" rel="bookmark">
			Java—JDK8新特性—重复注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
重复注解是什么？
常见的重复注解的应用场景
源码（JDK中哪里？）
在实际开发中哪里使用了注解（举例）
使用步骤
案例
重复注解是什么？ 重复注解，一个注解可以在一个类、方法、字段上同时使用多次
重复注解的主要应用场景是对同一个元素可以多次使用同一个注解。这种情况下，我们可以使用重复注解来简化代码，提高可读性
常见的重复注解的应用场景 1.参数校验：重复注解可以用于对方法参数进行校验
例如，可以定义一个 @NotNull 注解来标记非空的参数，并且可以重复使用该注解来标记多个参数
public void someMethod(@NotNull String param1, @NotNull String param2) { // 方法体 } 2.权限控制：重复注解可以用于标记访问权限
例如，可以定义一个 @Role 注解来标记用户角色，并且可以重复使用该注解来为某个方法或类指定多个角色
@Role("admin") @Role("manager") public void someMethod() { // 方法体 } 3.日志记录：重复注解可以用于标记日志级别
例如，可以定义一个 @LogLevel 注解来指定日志级别，并且可以重复使用该注解来记录不同级别的日志。
@LogLevel(LogLevel.INFO) @LogLevel(LogLevel.ERROR) public void someMethod() { // 方法体 } 源码（JDK中哪里？） Module java.base
Package java.lang.annotation
Annotation Interface Repeatable
package java.lang.annotation; /** * The annotation interface {@code java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5846db68978f1be73e39798f91d34237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47109cd269b42f5892412c952fa468b3/" rel="bookmark">
			列表对象复制属性到另一个列表对象 从List＜Object＞另一个List＜Object＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 事件起因环境和工具解决办法结束语 事件起因 在写一个市级的项目时，遇到了一个问题，这个项目涉及的数据内容非常大，光是数据库文件的大小就已经达到了12G，数据的规模大致是在百万级的，光是我这次参与处理的数据就有10w（最后我跑出来的数据是10w，但处理的数据不止如此）
本次运行的数据库，因为我的盘大小不够，我还额外装了一块2T硬盘
在处理这个项目的数据的过程中有一个 将数据存在原来多个表的同一个物料的信息汇总起来然后放入我所要进行存储的一张表中去，大致过程是：物料有唯一的sn码，然后每个阶段物料都有进行流转会产生业务流程的数据，这个数据分别在不同的表中，比如说物料入库，出库，入下级仓库，出下级仓库，入暂存点，出暂存点和安装，每个阶段都会产生业务数据信息，然后我要将每个阶段的信息进行汇总，（每个阶段的信息都在不同的数据库表中，单表的数据量都很大，上10w级）此时使用连表在数据库中去执行这样的效率比较低下，所以采用的是在每个阶段去查询满足查询条件的当前阶段的数据，然后在java的代码中去处理这些数据，让相同的物料编码sn去将这些实体属性的信息合并，
下面是这个实体的属性的展示，这个实体目前是有130多个属性值：（各阶段分别占有10多个属性）
现在各个阶段都查到了对应的数据，比如说，入库阶段有入库sn和入库相关信息，出库阶段有出库sn和出库相关信息，现要做的是将各个阶段同一sn的所有信息合并
环境和工具 jdk1.8
maven
idea2023
解决办法 在处理这个情况的方法在初步就有了，比如说，双重循环这两个列表，去遍历每一个对象，然后判断这些对象的sn是否相同，但是这样已经匹配的sn对象也会继续拿到其他的对象中去匹配，效率比较低下
有两个对象列表 List snInfo1 和List snInfo2
现优化这种情况，将其中的一个列表对象修改为map，其中的属性sn作为key，对应的每个对象作为value，代码如下：
/** * 对象复制到对象 source是之前就有的列表对象 */ private List&lt;SnInfoExtend&gt; copyListToListBySn(List&lt;SnInfoExtend&gt; source, List&lt;SnInfoExtend&gt; source2){ // 创建一个 Map，将 sn 作为键，Market 对象作为值 Map&lt;String, SnInfoExtend&gt; snMap = source.stream() .collect(Collectors.toMap(SnInfoExtend::getSourceSn, market -&gt; market, (existing, replacement) -&gt; replacement)); // 合并 snList2 中的数据到 snList 关于下面那儿为什么要用toUpperCase: 因为 前面的流程 sn全是大写字母，到了安装的时候却变为了小写字母 source2.forEach(market -&gt; snMap.merge(market.getSourceSn().toUpperCase().trim(), market, (existing, replacement) -&gt; { //仓库出库，这个比较特殊 只能根据箱码进行更新 箱码的话，肯定是会重复的 //入暂存点 8个字段更新 if(replacement.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47109cd269b42f5892412c952fa468b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/466368fbf65dfb519169fc85d9fcd37b/" rel="bookmark">
			MySQL——root用户密码忘记，重置的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1: 通过任务管理器或者服务管理，关掉mysqld(服务进程) 2: 通过命令行+特殊参数开启
mysqld mysqld -- defaults-file="D:\ProgramFiles\mysql\MySQLServer5.7Data\my.ini" --skip-grant-tables
3: 此时，mysqld服务进程已经打开。并且不需要权限检查
4: mysql -uroot 无密码登陆服务器。另启动一个客户端进行 5: 修改权限表 (1) use mysql; (2) update user set authentication_string=password('新密码') where user='root' and Host='localhost'; (3) flush privileges; 6: 通过任务管理器，关掉mysqld服务进程。
7: 再次通过服务管理，打开mysql服务。
8: 即可用修改后的新密码登陆。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0da51486615788b153cc9c81f7ac5e6/" rel="bookmark">
			Linux系统编程：文件编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 常用API 打开、创建、关闭文件，读写文件，利用man指令查询相关说明
open &amp; create man 2 open
或
man 2 create
NAME open, creat - open and possibly create a file or device SYNOPSIS #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; int open(const char *pathname, int flags); int open(const char *pathname, int flags, mode_t mode); int creat(const char *pathname, mode_t mode); close man 2 close
NAME close - close a file descriptor SYNOPSIS #include &lt;unistd.h&gt; int close(int fd); write man 2 write
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0da51486615788b153cc9c81f7ac5e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54fde74b572d3fafdb3946ea1e3884ab/" rel="bookmark">
			张量的连续性、contiguous函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pytorch中，tensor的实际数据以一维数组（storage）的形式存储于某个连续的内存中，以“行优先”进行存储。
tensor的连续性 tensor连续（contiguous）是指tensor的storage元素排列顺序与其按行优先时的元素排列顺序相同。如下图所示：
上图中，tensor b是tensor a经过转置而来的，即使用了 tensor.t() 方法。
出现不连续现象，本质上是由于pytorch中不同tensor可能共用同一个storage导致的。
pytorch的很多操作都会导致tensor不连续，如tensor.transpose()（tensor.t()）、tensor.narrow()、tensor.expand()。
以转置为例，因为转置操作前后共用同一个storage，但显然转置后的tensor按照行优先排列成1维后与原storage不同了，因此转置后结果属于不连续（见下例）。
2. tensor.is_contiguous() is_contiguous直观的解释是Tensor底层一维数组元素的存储顺序与Tensor按行优先一维展开的元素顺序是否一致。
如果想要变得连续使用contiguous方法，如果Tensor不是连续的，则会重新开辟一块内存空间保证数据是在内存中是连续的；如果Tensor是连续的，则contiguous无操作。
tensor.is_contiguous()用于判断tensor是否连续，以转置为例说明：
import torch a = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(a) print(a.storage()) print(a.is_contiguous()) # a是连续的 """ tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 1 2 3 4 5 6 7 8 9 [torch.LongStorage of size 9] True """ b = a.t() # b是a的转置 print(b) print(b.storage()) print(b.is_contiguous()) # b是不连续的 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54fde74b572d3fafdb3946ea1e3884ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e7d748bf71350e8b24473f50ab7948/" rel="bookmark">
			Modbus RTU/Modbus TCP协议详细、区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modbus RTU/Modbus TCP协议详细、区别 一、什么是Modbus-RTU ？Modbus-RTU报文示例1 读取线圈 0x请求报文：正常响应报文：异常响应报文： 2 写入单个线圈 0x请求报文：正常响应报文：异常响应报文： 3 写入多个线圈 0x请求报文：正常响应报文：异常响应报文： 4 读输入离散量 1x请求报文：正常响应报文：异常响应报文： 5 读输入寄存器 3x请求报文：正常响应报文：异常响应报文： 6 读保持寄存器 4x请求报文：正常响应报文：异常响应报文： 7 写入单个保持寄存器 4x请求报文：正常响应报文：异常响应报文： 8 写入多个保持寄存器 4x请求报文：正常响应报文：异常响应报文： 9 异常响应中其他常见的异常码： 三、什么是Modbus-TCP？通信方式通信过程TCP与RTU两种协议的区别Modbus-TCP报文示例请求读取多个输入寄存器：数据请求：请求读取输入寄存器， 请求写入多个保持寄存器：数据请求：请求写入多个保持寄存器 总结 一、什么是Modbus-RTU ？ MODBUS RTU协议是一种开放的、主要基于串行链路(RS232C或RS485)的通信协议,也有在TCP或者UDP方式下使用这种标准通信协议的，名称中的RTU是英文 “Remote Terminal Unit"的缩写,即"远程终端设备”，支持多种电气接口，如RS-232、RS-485等，还可以在各种介质上传送，如双绞线、光纤、无线等，目前，支持Modbus的厂家超过400家，支持Modbus的产品超过600种。
在Modbus RTU协议里，通讯的双方被称为“主站”和“从站”。主站会向从站发出查询或者写入命令，然后从站被动接收命令然后根据功能码和寄存器号反馈相应的数据结果或者执行写入命令，一个485网络里理论上最多可以挂254个从站，实际应用中考虑线路损耗和干扰一般不会超过100个，否则建议用以太网通讯。
Modbus中常用的功能码有8个，可以分为位操作和字操作两类：
读操作：
01(读线圈寄存器 位操作)
02(读离散量输入寄存器 位操作)
03(读保持寄存器 字操作)
04(读输入寄存器 字操作)
写操作：
05(写单个线圈寄存器 位操作)
06(写单个保持寄存器 字操作)
0F(写多个线圈寄存器 位操作)
10(写多个保持寄存器 字操作)
Modbus-RTU报文示例 1 读取线圈 0x 请求报文： Tx：01 01 00 00 00 0A BC 0D
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7e7d748bf71350e8b24473f50ab7948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a65da20b615cc0c1c1a431b640c1441/" rel="bookmark">
			Vue3&#43;Ts&#43;Vite项目(第三篇)——配置husky、stylelint、commitlint，配置git提交代码校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介一、项目环境1.1 node.js v16.0.0 及以上 （我 v16.14.1）1.2 pnpm v8.0.0 及以上（我 v8.6.6） 二、创建项目2.1 安装 pnpm2.2 创建项目-不多赘述 三、配置 eslint3.1 安装 eslint3.2 生成eslint配置文件3.3 完善 .eslintrc.cjs 文件中的 rules 对象3.4 新建忽略文件3.5 添加脚本3.6 检测是否生效 四、配置 prettier4.1 安装 prettier4.2 运行 pnpm run lint4.3 新建 prettier 配置文件4.4 新建忽略文件4.5 完善 .eslintrc.cjs 文件4.6 添加脚本 五、配置stylelint5.1 安装 stylelint5.2 装包完成后5.3 新建 stylelint 配置文件5.4 新建 stylelint 忽略文件5.5 添加脚本 六、配置 husky6.1 安装 husky6.2 生成 husky 配置文件 七、配置 commitlint7.1 安装 commitlint7.2 新建 commitlint 配置文件7.3 添加脚本7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a65da20b615cc0c1c1a431b640c1441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d40be1dfc8a21145064c4f2fc16a2e/" rel="bookmark">
			Linux计划任务-定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux计划任务-定时任务 at单次计划任务at命令格式查看at任务取消at计划任务创建1分钟后的单次任务 定时任务分类安装crontabcron`系统任务调度`/etc/crontab文件格式 用户任务调度conrtab常用添加计划任务指定用户创建计划任务 查看用户的计划任务计划任务日志存储目录查看所有用户的计划任务 删除计划任务查看计划任务日志禁止任务发邮件方法1: `&amp;&gt;/dev/null`方法2: `MAILTO=""` 清空邮件 定时格式多个时间计划任务间隔时间计划任务每分钟执行一次的任务每2分钟执行一次任务 计划任务加锁 at单次计划任务 at命令：使用它在一个特定的时间运行一些特殊的作业，或在晚一些的非负荷高峰时间段或高峰负荷时间段运行。
# 安装at yum install at -y # 开启atd服务 systemctl enable --now atd 对于其他用户，是否执行某个命令或脚本取决于/etc/at.allow
at命令格式 # at命令：时间 # at&gt;要运行的命令 [root@localhost ~]# at 11:32 at&gt; ls at&gt; reboot # 写完后CTrl+D 退出 at命令示例：
# 在22年6月8日上午10点执行slocate -u命令 at 10:00 6/8/22 at&gt; socate -u 敲回车 查看at任务 # 显示用户待执行任务列表 [root@localhost ~]# atq 2	Fri Nov 5 08:08:00 2021 a root # 查看任务 [root@localhost ~]# at -l 3 Sun Aug 15 11:36:00 2021 a root # 查看指定编号的计划任务 ## at -l 如果查看处有多条计划任务的话,用at -c 编号,即可查看信息 at -c 1 取消at计划任务 # 取消计划任务 atrm 编号 atrm 1 # -r 清除作业--可能不兼容该命令 ## -m 作业完成后给用户发邮件 at -rm 作业id # 查看计划任务是否已经删除 at -l 创建1分钟后的单次任务 at now + 1 min &gt; useradd tgb # 写完后CTrl+D 退出 定时任务分类 Linux下的任务调度分为两类，系统任务调度和用户任务调度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d40be1dfc8a21145064c4f2fc16a2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02769e66aab870088f323ffb0b5a90fd/" rel="bookmark">
			FastChat工作原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在了解FastChat如何完成大模型部署前，先了解下Huggingface提供的Transformer库。
Hugggingface提供的Transformer库
Hugging Face 的 Transformers 库是一个用于自然语言处理（NLP）任务的 Python 库，旨在简化和加速使用预训练语言模型（如BERT、GPT-2等）的开发和应用。这个库的主要作用包括：
预训练模型的加载和使用： Transformers 库提供了易于使用的接口，允许用户加载各种预训练语言模型，如BERT、GPT-2、T5等。这些模型在大规模文本数据上进行了预训练，并可以用于各种自然语言处理任务，如文本分类、命名实体识别、文本生成等。
文本编码和解码： Transformers 库提供了文本编码和解码功能，可以将文本数据转换为模型可以理解的输入，并将生成的输出转换回文本。这对于处理不同任务的输入和输出数据非常有用。
支持多种任务： 该库支持多种自然语言处理任务，并提供了预训练模型的封装，以便用户可以轻松地在这些任务上进行微调和应用。这些任务包括文本分类、情感分析、命名实体识别、机器翻译等。
模型微调： Transformers 库允许用户对预训练模型进行微调，以适应特定的任务或领域。这使得用户可以在有限的数据集上实现高性能的自然语言处理应用。
模型交流和共享： Hugging Face 的 Transformers Hub 提供了一个平台，允许用户分享、发布和发现预训练模型和相关资源。这有助于加速 NLP 社区的发展和合作。
支持多种深度学习框架： Transformers 库支持多种深度学习框架，包括PyTorch、TensorFlow和JAX，以满足不同用户的需求。
以通过HuggingFace提供的Tranformer加载和使用预训练大模型为例，下面的代码加载了Bert模型，首先是加载了Bert模型的BertTokennizer用户后面对输入输出新的encode和decode，接着是通过model_name来加载大模型。
# 安装 Transformers 库（如果尚未安装） # pip install transformers from transformers import BertTokenizer, BertForSequenceClassification import torch # 1. 加载预训练的BERT模型和标记器 model_name = "bert-base-uncased" # 预训练模型的名称 tokenizer = BertTokenizer.from_pretrained(model_name) model = BertForSequenceClassification.from_pretrained(model_name) # 2. 准备输入文本 text = "Hugging Face Transformers库使自然语言处理变得非常容易。"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02769e66aab870088f323ffb0b5a90fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719ae5b2ebea9a2e9192cf8dda9c9cab/" rel="bookmark">
			Python（Web时代）—— Django的模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 作为一个网络框架，Django 需要一种方便的方式来动态生成 HTML。最常见的方法是依靠模板。一个模板包含了所需 HTML 输出的静态部分，以及一些特殊的语法，描述了如何插入动态内容。目前流行的 Web 框架基本都采用 MVC 的架构，而 Django 在这个架构基础上做了一点改变，即 MTV 框架，这里的 T 就是今天我们要讲的 Django 的模板系统（ Template ）。
一个 Django 项目可以配置一个或多个模板引擎（如果你不使用模板，甚至可以不配置模板）。Django 默认内置了一个模板系统 DTL（ Django template language ）,在一般的项目开发中足够应用了
Django 模板是使用 Django 模板语言标记的一个文本文档或Python字符串。模板引擎可以识别和解释一些构造。主要是变量和标签。
模板主要包含两块内容： HTML的静态内容
动态插入的内容（Django 模板语言，简写 DTL，定义在 django.template 包中）
由 startproject 命令生成的 settings.py 定义关于模板的值：
DIRS 定义了一个目录列表，模板引擎按列表顺序搜索这些目录以查找模板源文件。
APP_DIRS 告诉模板引擎是否应该在每个已安装的应用中查找模板。
模板的使用 Django 模板系统其实是 Python 的一个库，使用模板通过以下两种方法 第一步：通过Template对象，传入一个字符串或者模板的文本文件
第二步：调用Template对象的 render() 方法，然后传入相应的动态变量
以下我们继续以之前的TestDjango项目下的 score应用为例，进入到score应用的 views.py文件中，修改如下
方式一：采用字符串模板
# score/views.py # 导入模板相关库 from django.template import Template, Context def index(request): # 定义模板 t = Template('你好&lt;h1 style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/719ae5b2ebea9a2e9192cf8dda9c9cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258ba6bf01c0d92e2a871e4e0a6064e1/" rel="bookmark">
			基于nginx的tomcat负载均衡和集群(超简单)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看到"基于apache的tomcat负载均衡和集群配置 "这篇文章成为javaEye热点。
略看了一下，感觉太复杂，要配置的东西太多，因此在这里写出一种更简洁的方法。
要集群tomcat主要是解决SESSION共享的问题，因此我利用memcached来保存session，多台TOMCAT服务器即可共享SESSION了。
你可以自己写tomcat的扩展来保存SESSION到memcached。
这里推荐使用memcached-session-manager这个开源项目（http://code.google.com/p/memcached-session-manager/ ），下面简称msm。
如何安装nginx、memcached、tomcat这些就不多说了。
先说明一下测试环境:
tomcat1、nginx、memcached安装在192.168.1.11
tomcat2安装在192.168.1.101
下面分步实现基于nginx的tomcat负载均衡和集群配置
一，tomcat集群
1，先下载msm及其依赖包
http://memcached-session-manager.googlecode.com/files/memcached-session-manager-1.3.0.jar
http://memcached-session-manager.googlecode.com/files/msm-javolution-serializer-jodatime-1.3.0.jar
http://memcached-session-manager.googlecode.com/files/msm-javolution-serializer-cglib-1.3.0.jar
http://spymemcached.googlecode.com/files/memcached-2.4.2.jar
http://memcached-session-manager.googlecode.com/files/javolution-5.4.3.1.jar
2，将这5个包放到$TOMCAT_HOME/lib目录下
3，修改$TOMCAT_HOME/conf/server.xml
&lt;Context docBase="E:/java_codes/TestSession/WebContent" path="" reloadable="true" &gt; &lt;Manager className="de.javakaffee.web.msm.MemcachedBackupSessionManager" memcachedNodes="n1:localhost:11211" requestUriIgnorePattern=".*\.(png|gif|jpg|css|js)$" sessionBackupAsync="false" sessionBackupTimeout="100" transcoderFactoryClass="de.javakaffee.web.msm.serializer.javolution.JavolutionTranscoderFactory" copyCollectionsForSerialization="false" /&gt; &lt;/Context&gt; 这里的memcachedNodes是填写memcached节点,多个节点时可以以空隔分开，如:
n1:localhost:11211 n2:localhost:11212
sessionBackupTimeout的单位为分钟
E:/java_codes/TestSession/WebContent 替换成你的WEB目录
修改后重启两个TOMCAT即可,这个时候已经解决SESSION的共享问题.
二，配置nginx实现负载均衡
以我的nginx.conf为例
#user nobody; worker_processes 1; error_log logs/error.log; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; #gzip on; upstream www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/258ba6bf01c0d92e2a871e4e0a6064e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1260960c8665ddbae0b646c33c593473/" rel="bookmark">
			浅入 Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Docker 简介1.1 什么是虚拟化1.2 什么是Docker1.3 容器与虚拟机比较 2. Docker 组件2.1 Docker服务器与客户端2.2 Docker镜像与容器2.3 Registry（注册中心） 3. Docker安装与启动3.1 安装Docker3.2 设置Docker镜像3.3 Docker的启动与停止 4. Docker镜像4.1 镜像搜索 docker search4.2 下载镜像 docker pull4.3 查看本地镜像 docker images4.4 删除镜像 docker rmi4.5 镜像保存备份 docker save 5. Docker 容器5.1 查看正在运行的容器 docker ps5.2 创建与启动容器 docker run5.3 目录挂载，端口映射5.4 停止与启动容器5.5 删除容器 docker rm5.6 文件拷贝 docker cp5.7 查看容器IP地址5.8 docker 启动时容器自动启动 6. 应用部署6.1 Nginx部署6.2 Redis部署 7. Dockerfile7.1 什么是 Dockerfile7.2 常用命令7.3 使用脚本创建镜像 8. Docker私有仓库8.1 私有仓库搭建与配置8.2 镜像上传至私有仓库 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1260960c8665ddbae0b646c33c593473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323c5cdebcb5203ad18663bea6eeb613/" rel="bookmark">
			Callable接口中的call方法及返回对象Future 和CountDownLatch计数器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jdk1.5中的实现Callable接口中实现call方法创建线程与之前Thread类中或Runnable接口中的重写/实现run方法的不同
首选call方法最大不同就是增加了抛出异常及其返回值的功能。
Callable接口与Future, 多线程并发情况下利用Future对象接收返回值，上代码。
import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; public class TestCallable { public static void main(String[] args) throws Exception{ ExecutorService es = Executors.newCachedThreadPool(); Callable&lt;Integer&gt; task1 = new Callable&lt;Integer&gt;(){ public Integer call() throws Exception{ System.out.println("task1 start working"); int result = 0 ; for(int i = 1 ; i &lt; 100 ; i+=2){ result += i; Thread.sleep(100); } System.out.println("task1 end working"); return result; } }; Callable&lt;Integer&gt; task2 = new Callable&lt;Integer&gt;(){ public Integer call() throws Exception{ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/323c5cdebcb5203ad18663bea6eeb613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9889e8949d93d77bda8cf96a94a0f05c/" rel="bookmark">
			MySQL的权限管理与远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的权限管理 1、授予权限 授权命令： grant 权限1,权限2,…权限n on 数据库名称.表名称 to 用户名@用户地址 identified by ‘连接口令’;
该权限如果发现没有该用户，则会直接新建一个用户。
比如 grant select,insert,delete,drop on atguigudb.* to li4@localhost ; #给li4用户用本地命令行方式下，授予atguigudb这个库下的所有表的插删改查的权限。 grant all privileges on *.* to joe@'%' identified by '123'; #授予通过网络方式登录的的joe用户 ，对所有库所有表的全部权限，密码设为123。 2、收回权限 1）查看当前用户权限
show grants; 2）收回权限命令：
revoke 权限1,权限2,…权限n on 数据库名称.表名称 from用户名@用户地址 ; REVOKE ALL PRIVILEGES ON mysql.* FROM joe@localhost; #收回全库全表的所有权限。 REVOKE select,insert,update,delete ON mysql.* FROM joe@localhost; #收回mysql库下的所有表的插删改查权限。 必须用户重新登录后才能生效。 3、查看权限 1）查看当前用户权限
show grants; 2）查看某用户的全局权限
select * from user ; 3）查看某用户的某个表的权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9889e8949d93d77bda8cf96a94a0f05c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e763417614e47a10f4c8745fab1198e/" rel="bookmark">
			《Python趣味工具》——自制emoji（1）绘制爱心应援牌❤️
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目目标：
本项目旨在学习如何自制emoji，学习内容主要分为3个方面，分3次来讲，根本在于了解了turtle的使用！
1.完成一个爱心应援牌
2.完成静态的emoji
3.让emoji动起来！
今天我们来学习第一个部分。
文章目录 一、效果展示：导入turtle模块： 二、步骤拆解：1. 绘制左边线：pensize()pencolor()left()forward() 2. 绘制左半圆：right()circle() 3. 绘制右半圆：4. 绘制右边线：5. 填充颜色：fillcolor()begin_fill ()end_fill() 6. 填充表白文字goto()write()penup()hideturtle() 三、彩蛋——circle函数详解三、拓展训练：绘制一个四叶草绘制五角星绘制奥运五环 一、效果展示： turtle，中文名小海龟，是一种Logo编程语言。
可以用它来实现绘图，制作简单游戏等功能。
导入turtle模块： 可以用两种方式来导入turtle。
1️⃣方法1:
import turtle：直接导入turtle模块。
在使用过程中，如果需要使用turtle模块中的函数，方法是：
turtle.pensize()，turtle.pencolor()
2️⃣方法2:
from turtle import *：从turtle模块中导入所有的函数
这样就可以直接使用turtle模块中的函数，例如：
pensize()，pencolor()
好了，废话不多说，直接上代码：
下面这部分代码是利用turtle()的各种函数绘制了一个心形应援牌。
# 从turtle中导入所有函数 from turtle import * # 绘制心形 # 使用pensize()函数将画笔粗细设置为5 pensize(5) # 使用pencolor()函数设置颜色 # 画笔颜色为"red" pencolor("red") # 使用fillcolor()函数设置填充颜色 # 填充颜色为"pink" fillcolor("pink") # 使用begin_fill()函数准备开始填充图形 begin_fill() # 使用left()函数向左转135度 left(135) # 使用forward()函数向前进100步 forward(100) # 使用right()函数右转180度 right(180) # 使用circle()函数画半圆，半径为50，角度-180度 circle(50,-180) # 使用left()函数向左转90度 left(90) # 使用circle()函数画半圆，半径为50，角度-180度 circle(50,-180) # 使用right()函数右转180度 right(180) # 使用forward()函数向前进100步 forward(100) # 使用end_fill()函数填充完成 end_fill() # 填充文字 # 使用penup()函数抬起画笔 penup() # 使用pencolor()函数设置画笔颜色为黑色 pencolor("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e763417614e47a10f4c8745fab1198e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fd92205a8ffd3fb8c6e1e4d3380064/" rel="bookmark">
			基于freeRTOS制作音乐播放器方案和框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于freeRTOS制作音乐播放器方案和框架 创建一个音乐播放器软件是一个相当复杂的任务，涉及到多个步骤和模块，包括但不限于硬件驱动开发，文件系统的实现，音频解码，以及用户界面的设计。以下是一个非常基本的步骤和注意事项，来帮助你开始基于STM32F103ZET6和FreeRTOS或RT-thread创建音乐播放器软件：
第1步: 硬件准备 确保你的硬件平台已准备好并具备音乐播放所需的所有外设，如SD卡接口（用于存储音乐文件）和音频输出接口。
第2步: 开发环境配置 设置STM32CubeMX和Keil或其他你熟悉的IDE。配置STM32F103ZET6的外设和中断。 第3步: 操作系统选择与配置 根据你的需要选择FreeRTOS或RT-thread。在你的IDE中导入选定的操作系统的源代码。根据STM32F103ZET6的硬件配置来配置RTOS的设置。 第4步: 驱动程序开发 开发必要的驱动程序来控制硬件，包括：
SD卡驱动程序。DAC或PWM音频输出驱动程序。 第5步: 文件系统实现 实现一个文件系统来处理音乐文件，这通常包括：
文件的读取。文件的解析（例如MP3解码器）。 第6步: 用户界面 开发一个简单的用户界面来控制音乐播放器，这可以是通过物理按钮或触摸屏来实现。
第7步: 音乐播放功能 实现音乐播放的核心功能，包括：
读取音乐文件从SD卡。解码音乐文件。输出音频到一个扬声器或耳机。 第8步: 测试和调试 完成基本功能后，进行测试并修复可能出现的问题。
第9步: 完成和优化 在确认所有功能正常工作后，进行进一步的优化和改进，以提高性能和用户体验。
这只是一个非常高层次的概述，每个步骤都需要深入的技术知识和经验来实现。建议你分步进行，首先确保硬件和开发环境正确设置，然后逐步实现每个模块，同时不断测试和验证你的进展。
继续从之前的步骤，我们现在来详细看看一些重要的开发阶段：
第10步: 音频解码 音频格式支持：决定你的播放器将支持哪些音频格式（如MP3，WAV等）。你可能需要找到或编写相应格式的解码器。
解码库的整合：探索是否有现成的开源库可以用于解码所选择的音频格式。例如，你可以查找现有的MP3解码库并将其整合到你的项目中。
第11步: 创建播放控制逻辑 播放控制：创建任务或线程来控制播放逻辑，包括播放、暂停、下一曲和上一曲等功能。
音量控制：实现一个可以控制音量的功能。
第12步: 用户界面(UI) UI设计：基于你的硬件平台设计UI。如果你有一个图形屏幕，你可以设计一个图形用户界面(GUI)。否则，你需要设计一个基于物理按钮的界面。
实时反馈：确保用户可以得到关于当前播放状态的实时反馈，这可以通过屏幕或LED灯来实现。
第13步: 文件浏览和选择 文件浏览：实现一个可以浏览SD卡上文件和文件夹的系统，让用户可以选择要播放的音乐。
播放列表：允许用户创建和编辑播放列表。
第14步: 测试 单元测试：进行单元测试来验证各个模块的功能。
集成测试：进行集成测试来验证系统作为一个整体的功能。
第15步: 文档和用户手册 技术文档：创建技术文档来记录你的系统的架构和代码。
用户手册：创建一个用户手册来帮助用户了解如何使用你的音乐播放器。
第16步: 质量保证和调优 优化：根据测试结果优化你的系统来提高性能和可靠性。
错误处理和恢复：确保你的系统可以优雅地处理错误，并在出现问题时提供适当的恢复机制。
第17步: 项目结论 用户反馈：如果可能的话，收集用户反馈来进一步改进你的产品。
项目总结：总结你在项目中学到的东西，以及你可以在未来项目中应用的教训。
编写一个完整的音乐播放器源代码超出了这里能提供的帮助，这是一个庞大的项目，需要很多时间和专业知识。但我可以帮你开始这个项目，提供一个简单的框架和一些你可能会找到的有用资源。下面是一个非常基本的Freertos任务结构，可用于创建主要任务：
#include "FreeRTOS.h" #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7fd92205a8ffd3fb8c6e1e4d3380064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54fa7d2090096992e6dd686e46619aaf/" rel="bookmark">
			问题记录：com.alibaba.nacos.shaded.io.grpc.StatusRuntimeException: UNAVAILABLE: io exception
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：参考链接
问题描述： nacos服务端因一次异常停止以后，进行重启，然后客户端就连接不上了，但是服务端重启后显示一切正常。
报错信息 这是客户端报错：com.alibaba.nacos.shaded.io.grpc.StatusRuntimeException: UNAVAILABLE: io exception
问题原因 nacos服务端默认端口是8848，此外还需要两个端口，需要在此端口上进行便宜，一个是+1000，一个是+1001，如果不暴露者两个端口就有可能出现上述问题，且不是必现，这个就很搞笑了。所以如果我们使用的是8848，那么还需要额外暴露9849和9849两个端口。我使用的是Docker，所以需要增加这两个端口的映射。刚开始测试了几天都没有问题，突然出现问题。增加这两个端口的暴露以后问题解决。
下面是单机Docker的启动脚本
docker run \ --name my-nacos -d \ -p 8848:8848 \ -p 9848:9848 \ -p 9849:8849 \ --env PREFER_HOST_MODE=ip --env MODE=standalone \ -v /apps/nacos/logs:/home/nacos/logs \ -v /apps/nacos/conf/application.properties:/home/nacos/conf/application.properties \ nacos/nacos-server:v2.0.4 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c06d499627e31b7b8b0cb65cd2917907/" rel="bookmark">
			数据结构--并查集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：
1. 初始化：
假如有编号为1,2,3,.., n的n个元素，我们用一个数组p来存储每个元素的父节点。一开始，我们先将它们的父节点设为自己
int p[N]; for(int i = 1;i &lt;= n;i ++) p[i] = i; 2. 查询
找到i的祖先直接返回,未进行路径压缩
int find(int i){ if(p[i] == i) return i; else return find(p[i]); } 3.合并
void union(int i,int j){ p[find(i)] = find(j); //i的祖先指向i的祖先。 } 路径压缩:
int find(int x){ //返回x的祖宗节点 + 路径压缩 if(p[x] != x) p[x] = find(p[x]); return p[x]; } 例题：836. 合并集合 - AcWing题库
一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。
现在要进行 m 个操作，操作共有两种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c06d499627e31b7b8b0cb65cd2917907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ea837d5cf11789cd2799a978ea9ac7/" rel="bookmark">
			创建vue项目的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过Vue CLI创建 Vue CLI（正在维护…）是 Vue 早期推出的一款脚手架，使用 webpack 创建 Vue 项目，可以选择安装需要的各种插件。
首先要安装脚手架
npm install -g @vue/cli
然后使用
vue create my-project // 打开命令行配置界面
or
vue ui // 打开可视化配置界面
创建项目。
预设配置和插件：
选项解释Choose Vue versionvue版本选择Babel是否兼容低版本浏览器TypeScript是否扩展JavaScriptProgressive Web App (PWA) Support是否支持渐进式Web应用程序Router是否配置路由Vuex是否配置状态管理模式（相当于本地存储）CSS Pre-processors是否配置CSS预处理器Linter / Formatter格式化程序规范选择Unit Testing是否创建单元测试E2E Testing是否创建端到端测试 通过create-vue创建 create-vue是一个全新的脚手架工具。
create-vue使用命令
npm create vue@latest
就能快如闪电般初始化好基于vite的Vue3项目。
Vite是一种新型前端构建工具，能够显著提升前端开发体验。
创建并配置项目：
可选功能：
选项解释Project name:项目名称，默认值：vue-project。Add TypeScript?是否加入TypeScript组件？默认值：No。Add JSX Support?是否加入JSX支持？默认值：No。Add Vue Router for Single Page Application development?是否为单页应用程序开发添加Vue Router路由管理组件？默认值：No。Add Pinia for state management?是否添加Pinia组件来进行状态管理？默认值：No。Add Vitest for Unit testing?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54ea837d5cf11789cd2799a978ea9ac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6b64c5f6338a8aad0bf998def9b26d/" rel="bookmark">
			Java将毫秒(时间戳)转时分秒格式或者年月日，日期时间转时间戳，时间工具类、秒转时间，附实验结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算获得时间戳后转时分秒格式，附实验结果 /** * @Author： Be.insighted * Description： * @date Create on 2020/7/14 16:35 **/ ​ public class TimeUtils{ ​ /** * 把时间戳转换为：时分秒 * * @param millisecond ：毫秒，传入单位为毫秒 */ public static String getTimeString(final long millisecond) { if (millisecond &lt; 1000) { return "0" + "秒"; } long second = millisecond / 1000; long seconds = second % 60; long minutes = second / 60; long hours = 0; if (minutes &gt;= 60) { hours = minutes / 60; minutes = minutes % 60; } String timeString = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6b64c5f6338a8aad0bf998def9b26d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd9df23c8748dcfd1db42d9f1f2a253/" rel="bookmark">
			题解 | #Flipping Pancake#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯面经 一面
数分和数开哪个学历门槛高啊，本人二本，能往这个方面发展吗
运营岗位面试问题复盘（网易，新东方，知乎）
能骗中国电科或者研究所说自己本科是211吗 收到好多电话，问完本科，客套几句挂电话了 有没有人知道能
海康威视一面 9.6 c++软件开发
面试经验
🥭01-C++面试之C++11新特性总结
前端八股文（2022）
我真的犯贱啊
今年的秋招搞得像去年的提前批
华为技术有限公司供应链管理工程师面试经验
银行类前端面试简单版01
23届春招 巨人网络 游戏开发面经（已OC）
想不到第一个大offer是导师给的
哨哥的有问必答环节：银行等金融科技&amp;国企的求职Q&amp;A
#招银网络科技2024校招# 还有大量后端HC~~最后的机会
校招入职不到1年，公司让我负责项目，直接跟CTO汇报
歌尔2024届精英计划
题解 | #链表的奇偶重排#
import java.util.*;/* * public class ListNode { * int val; * ListNode next =
题解 | #字符串合并处理#
#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#inclu
前端薪资现在多少合适啊？
各城市本科前端一般薪资多少？uu们
题解 | #判断两个IP是否属于同一子网#
while True: try: mask,ip1,ip2=input().split('.'),input().split('.'),in
题解 | #合并两群能量值#
/** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : TP-LINK普联 提前批 面经
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd9df23c8748dcfd1db42d9f1f2a253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f9688aa5774e4ce21da804fdec2e6e5/" rel="bookmark">
			Spring3.2.3&#43;Quartz2.2.1 整合配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤：
1、下载相关包
quartz-2.2.1.jar
quartz-jobs-2.2.1.jar
spring相关jar包
2、编写配置文件静态
&lt;bean id="activateCardJobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
&lt;property name="targetObject"&gt; &lt;!-- targetObject是Spring定时器的特殊属性 --&gt;
&lt;ref bean="dispatchService" /&gt; &lt;!-- 这个就是具体实现类，如果是注解，则必须为component指定value --&gt;
&lt;/property&gt;
&lt;property name="targetMethod"&gt; &lt;!-- targetMethod是Spring定时器的特殊属性 --&gt;
&lt;value&gt;say&lt;/value&gt;&lt;!-- 就是java类中的任务方法 --&gt;
&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="sayRunTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt;
&lt;property name="jobDetail"&gt;&lt;!-- jobDetail是Spring定时器的特殊属性 --&gt;
&lt;ref bean="activateCardJobDetail" /&gt;
&lt;/property&gt;
&lt;property name="cronExpression"&gt;
&lt;value&gt;*/10 * * ? * *&lt;/value&gt;&lt;!-- cronExpression是Spring定时器的特殊属性 --&gt;
&lt;/property&gt;
&lt;/bean&gt;
&lt;bean autowire="no" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
&lt;property name="triggers"&gt; &lt;!-- triggers是Spring定时器的特殊属性 --&gt;
&lt;list&gt;
&lt;ref local="sayRunTrigger" /&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f9688aa5774e4ce21da804fdec2e6e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f30942b5f771949b456b756541da0ffd/" rel="bookmark">
			Nginx 转发 404 问题的排查和思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		theme: cyanosis 本篇文章原自当前业务遇到的一个实际问题，因为受到所在网络环境的因素影响，所以整体排查下来耗费了很大精力，记录一下。
项目背景 项目是 toG 项目，部署的网络环境是一个大的内网环境(又具体分为内网和内网互联网区)，项目涉及到小程序、前端、后端(又包括 JAVA 和 GO 两个项目)的部署。整体的部署拓扑图大致如下： 虚拟 IP 映射：大多数内网如何需要暴露对外访问，会在出口的核心路由上配置一个虚拟的 IP 作为对外的统一访问入口。比如你的内网地址及端口是 10.13.3.177:8080，则通过虚拟 IP 映射的地址及端口可能是：10.31.31.253:8080。
在这个业务流程程，访问路径是：公网(小程序前台)-&gt; 内网互联网区【10.31.1.142(nginx + 小程序后台)】 -&gt; 【10.31.31.253 -&gt; 10.13.3.177(nginx+后端)】 -&gt; 【10.233.1.2 -&gt; 172.13.7.249(nginx+后端)】。其中 10.13.3.177 和 172.13.7.249 是两台虚拟机，虚拟机上部署了nginx 和 后端服务。
PS：上述所有的 IP 均已做过处理，非正式 IP。
问题 访问步骤及问题节点：
1、小程序访小程序后台服务2、小程序后台服务发起调用到 10.31.31.253(这里实际上是 10.31.1.142 要调用 10.233.1.2 的服务，因为 10.31.1.142 不能直接访问 10.233.1.2，所以借用 10.31.31.253 来实现一层转发逻辑)。 这里会涉及到两个转发，
10.31.31.253 对应的 10.13.3.177 这台机器上的 nginx 需要将 10.31.1.142 的请求转发给 10.233.1.210.233.1.2 对应的 nginx 需要将请求到当前机器的后台服务上 在转发时通过 10.31.31.253 调用 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f30942b5f771949b456b756541da0ffd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77517e7a96b65da5725115de2df838f/" rel="bookmark">
			EasyExcel入门(最简单的读)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网：EasyExcel官方文档 - 基于Java的Excel处理工具 | Easy Excel (alibaba.com)
因为暂时项目没有用到，所以不急，知道了这个技术。就想着学着用一下！
最简单的读 先看官方文档给的用法和解释！！！
导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.70&lt;/version&gt; &lt;/dependency&gt; 创建实体类 自己准备一个Excel表格。
@Data public class DemoData { private String name; private String sex; private String age; } 测试 官方提供了4种写法
写法一： final String fileName = "C:\\Users\\gong'chao\\Desktop\\58_com_resumes_bj.xls"; /** * 最简单的读 - 01 */ @Test void readExcel01(){ AtomicInteger i = new AtomicInteger(); EasyExcel.read(fileName, DemoData.class, new PageReadListener&lt;DemoData&gt;(dataList -&gt; { for (DemoData demoData : dataList) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b77517e7a96b65da5725115de2df838f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c29d09ca3c407c44a6f41aeaacd165/" rel="bookmark">
			安装Burp suitev过程中出现错误--illegal-access=permit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决To run Burp Suite using Java 16 or above,supply the following JVM argument: --illgal-access=permit run后出现这个问题是吧
原因是因为你jdk乱了，下面跟我来：
最简单 最快的解决
你的安装包里面 肯定有这两个jar，找到他们
然后放在你的jdk文件夹的bin里面（jdk的版本无所吊谓）
再然后，在目录那写个cmd 回车
然后运行你的jar
就ojbk了，希望有用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/900f0fc8316a267a6f0f930c59b7ef84/" rel="bookmark">
			【FPGA零基础学习之旅#12】三线制数码管驱动（74HC595）串行移位寄存器驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉欢迎来到FPGA专栏~三线制数码管驱动
☆* o(≧▽≦)o *☆嗨~我是小夏与酒🍹 ✨博客主页：小夏与酒的博客 🎈该系列文章专栏：FPGA学习之旅 文章作者技术和水平有限，如果文中出现错误，希望大家能指正🙏📜 欢迎大家关注！ ❤️
🎉 目录-三线制数码管驱动 一、效果演示二、电路结构三、代码详解3.1 总体结构设计3.2 驱动74HC595芯片3.3 HEX8模块3.4 顶层模块 四、按键控制改变数据值 一、效果演示 🥝ISSP调试演示：
程序配置完成：
调试：
🥝按键控制演示：
二、电路结构 在三线制的数码管驱动中，使用74HC595芯片来减少FPGA的管脚数量使用。
关于74HC595芯片的介绍和时序图，参考文章：74HC595介绍 和 74HC595 驱动。
在AC620开发板上的数码管驱动电路：
AC620开发板使用的是74HC595芯片的级联来驱动显示：
三、代码详解 3.1 总体结构设计 先上RTL视图：
HEX8模块将seg和sel信号传给m74HC595_Driver模块，然后将接收到的信号转换为DS、SH_CP和ST_CP信号；ISSP模块用于调试。
3.2 驱动74HC595芯片 关于74HC595芯片的驱动，主要参考该时序图进行代码编写：
74HC595是8位串行移位寄存器，带有存储寄存器和三态寄存器，其中移位寄存器和存储寄存器分别采用不同的时钟。其可以把串行的信号转为并行的信号，因此常用做各种数码管以及点阵屏的驱动芯片。
该芯片的主要IO：
IO名称功能DS / SER串行数据输入端STCP / RCK存储寄存器的时钟输入。上升沿时移位寄存器中的数据进入存储寄存器，下降沿时存储寄存器中的数据保持不变。应用时通常将 ST_CP 置为低点平，移位结束后再在 ST_CP 端产生一个正脉冲更新显示数据。SHCP / SCK移位寄存器的时钟输入。上升沿时移位寄存器中的数据依次移动一位，即 Q0 中的数据移到 Q1 中，Q1 中的数据移到 Q2 中，依次类推；下降沿时移位寄存器中的数据保持不变。 由于在AC620开发板中芯片采用3.3V供电，这样在设计74HC595工作频率时，直接使用50M晶振四分频后的时钟作为其工作时钟。
74HC595的驱动代码，由于模块命名不能以数字开头，所以加了个m：
m74HC595_Driver.v：
module m74HC595_Driver( Clk, Rst_n, Data, S_EN, SH_CP,	//SCK ST_CP,	//RCK DS	//Data ); parameter DATA_WIDTH = 16; input Clk; input Rst_n; input [DATA_WIDTH-1 : 0] Data;	//data to send input S_EN;	//send en output reg SH_CP;	//shift clock output reg ST_CP;	//latch data clock output reg DS;	//shift serial data parameter CNT_MAX = 4; reg [15:0] divider_cnt;//分频计数器 wire sck_pluse; reg [4:0]SHCP_EDGE_CNT;//SH_CP EDGE counter reg [15:0]r_data; always@(posedge Clk or negedge Rst_n)begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/900f0fc8316a267a6f0f930c59b7ef84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb5c04a8368b9ffad2f2084e4e9f933/" rel="bookmark">
			矩阵论—线性子空间、生成子空间、核空间、零度、子空间的交与和、直和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性子空间定义 如果，V1称为平凡子空间，否则称为非平凡子空间。
生成子空间 核空间、零度 解：
rank(A)=2; n(A)=N-rank(A)=3-2=1，这里N表示的是未知量的个数。
n(A)也可以理解为基础解系的个数，即基础解系中有几个向量。
结论：
（1）rnak(A) + n(A) = A 的列数
（2）n(A) - n(A^T) = (A的列数) -（A的行数）
子空间的交与和 例题：
直和 综合例题：
解：
再例如：
再例如： 再求两个子空间交的维数：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c336347b64ad142c43d74591a80f9a38/" rel="bookmark">
			Vivado2019&#43;Modelsim仿真环境搭建(保姆式说明)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装准备
二、安装与配置
2.1 Vivado安装
2.2 modelsim安装
2.3 Vivado设置modelsim仿真环境
1）仿真库生成设置
2）modelsim添加仿真库（逐个添加）
3）modelsim添加仿真库（批量添加）
2.4 示例结果展示
三、常见问题
3.1 Flow Navigator窗口中无法执行simulation操作
3.2 切换工程文件和源文件，仿真失败
3.3 仿真输出结果为z
3.4 license无效
四、参考网址
一、安装准备 平台环境：windows系统
安装包：vivado2019 安装包，modelsim安装包
下载链接：https://pan.baidu.com/s/1Yy-w_7VfSa6cMzUyPw7atg 提取码: c4x4
磁盘空间：至少85G
注：百度网盘链接中vivado为可使用的版本，只需安装，modelsim的安装包中已包含相关安装文件
1）vivado的安装包较大，将近45G，包含了压缩包和解压后的文件。
2）解压后还需35G的空间，因此共需约至少80G的空间
3）modelsim安装包 750M+安装大小1.5G
二、安装与配置 2.1 Vivado安装 将下载的vivado安装包解压，因为文件较大，所有压缩时是分卷压缩的，任选一个rar文件解压，输入解压密码（在安装包的“解压密码.txt”中）。 解压后，进入到解压后的文件夹中，如下图所示，双击“xsetup.exe”进行安装 进入安装界面
直接点击“next”， 勾选三个“I agree”，再点左下角“next”
选择版本安装，有4个选项，一般是选择“Vivado HL Design Edition”或“Vivado HL System Edition”区别是前者包含了基于C语言设计的vivado 高级综合，实现，验证程序，后者是多了DSP的系统生成器，本人安装选择的前者
进入此界面，红色框中的"Engineering Sample Device"可勾选也可不勾选，勾选的作用是安装时后会提供一些工程的模块
进入安装路径选择界面，左上角根据实际情况设置安装路径，设置了安装路径后会发现右下角的“Next”图标仍是置灰状态。
此时需要对右上角的内容进行更改，取消勾选“Create progream group entries”即可。
点击“Install”进行安装
安装中，左上角有安装进度显示
安装完后桌面会有以下三个图标，点击“Vivado 2019.1”打开
进入到“Help-&gt;Manage License”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c336347b64ad142c43d74591a80f9a38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ef396227c8a002c630006efbddf393/" rel="bookmark">
			基于k8s&#43;docker&#43;Prometheus的可监控高可用web集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文章目录
项目名称
项目环境
项目描述
项目步骤
1.规划设计整个集群的网络拓扑结构，配置防火墙和堡垒机，在堡垒机上安装部署ansible服务。
1.1.规划设计集群的网络拓扑结构
1.2.前期准备工作
1.3.配置防火墙
1.4.在堡垒机上安装部署ansible服务
2.安装Kubeadm部署单master的集群，形成1台master2台node的集群环境。使用deployment在集群中启动nginx的pod作为web应用。
2.1.k8s集群搭建
2.2.在集群中启动nginx
3.安装metrics-server，采用HPA技术，让pod达到自动缩放效果。当CPU使用率达到50%进行水平扩缩，实现启动最小20个pod，最多40个pod。
3.1.安装好metrics-server，运行php-apache
3.2.上传hpa.example.tar的镜像到两个node节点上
3.3.修改php-apache.yaml
3.4.启动pod
3.5.增加水平扩缩，创建hpa
3.6.验证效果
4.部署NFS服务器，实现集群的数据一致性，在nginx容器中使用PV和PVC与NFS融合，保证容器提供的web服务内容一致。
4.1.搭建好nfs服务器
4.2.创建pv使用nfs服务器上的共享目录（在master上操作）
4.3.创建pvc使用pv
4.4.指定pod使用pvc
5.构建CI/CD环境，安装gitlab，Jenkins，harbor实现代码发布、镜像制作、数据备份等流水线工作。
5.1.搭建私有仓库harbor
5.1.1.环境准备：
5.1.2.harbor安装过程
5.1.3.本机上传拉取镜像
5.2.搭建gitlab
5.3.安装Jenkins
6.使用Prometheus对k8s集群进行监控，在Grafana中配置好Prometheus的数据源进行数据展示，更直观地监控整个web集群的性能。
6.1.使用Docker容器部署Prometheus
6.2.配置Grafana
7.部署ingress给web业务进行负载均衡，使用探针（liveless\readiness\startup）的httpGET和exec方法试探pod能否正常提供服务，增强业务pod的可靠性
7.1.定义探针
7.2.部署ingress实现负载均衡
7.2.1.安装部署ingress controller
7.2.2.检查pod是否启动
7.3.创建ingress资源
7.3.1.启动service，暴露nginx
7.3.2.创建yaml文件，启动ingress
7.3.3.查看创建是否成功
7.3.4.验证
8.安装k8s的dashboard对整个集群资源进行掌控了解
8.1.准备工作
8.2.启动dashboard
8.2.1.应用配置文件
8.2.2.查看是否启动dashboard的启动情况
8.2.3.浏览器访问（使用https协议访问）
项目心得
项目名称
基于k8s+docker+Prometheus的可监控高可用web集群
项目环境 centos 7.9、Kubernetes v1.20.6、Docker 23.0.3、ansible 2.9.27、Prometheus 2.42、Grafana 9.1.2等
项目描述 模拟企业中的生产环境，底层采用k8s管理的docker集群提供web服务，通过ansible实现自动化运维，使用NFS实现数据同源，利用Prometheus实现监控功能并通过Grafana进行监控数据可视化，搭建Jenkins构建CI/CD环境，构造一个高并发，高可用的web集群。
项目步骤 1.规划设计整个集群的网络拓扑结构，配置防火墙和堡垒机，在堡垒机上安装部署ansible服务。 1.1.规划设计集群的网络拓扑结构 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ef396227c8a002c630006efbddf393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aeb1c3bf44cf878be431c2228847918/" rel="bookmark">
			【Mac】编译Spring 源码和Idea导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们开始Spring源码的阅读之旅。阅读Spring的源码的第一步当然是编译Spring源码。首先我们要去GitHub上将spring源码给clone下来。
笔者编译环境如下：
Spring版本：5.28 https://github.com/spring-projects/spring-framework/tree/v5.2.8.RELEASE https://github.com/spring-projects/spring-framework/wiki/Build-from-Source 根据官网的编译文档可知我们需要的JDK版本
自行配置
根据源码路径
spring-framework\gradle\wrapper\gradle-wrapper.properties
distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists #distributionUrl=https\://services.gradle.org/distributions/gradle-8.3-bin.zip distributionUrl=file\:/Users/xxxx/Source/gradle-8.3/gradle-8.3-bin.zip networkTimeout=10000 validateDistributionUrl=true zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists 我们知道当前源码需要的gradle版本以及需要的gradle配置
下载对应的gradle
https://gradle.org/releases/
配置mac环境变量
GRADLE_USER_HOME=/Users/king/JavaLibrary/gradle-8.3 export GRADLE_USER_HOME 还需要在源码上方位置更换成本地gradle
distributionUrl=file\:/Users/xxxx/Source/gradle-8.3/gradle-8.3-bin.zip 进行编译
./gradlew build 发生如下错误
Caused by: org.gradle.jvm.toolchain.internal.NoToolchainAvailableException: No matching toolchains found for requested specification: {languageVersion=21, vendor=any, implementation=vendor-specific} for MAC_OS on x86_64. at org.gradle.jvm.toolchain.internal.JavaToolchainQueryService.downloadToolchain(JavaToolchainQueryService.java:180) at org.gradle.jvm.toolchain.internal.JavaToolchainQueryService.lambda$query$2(JavaToolchainQueryService.java:146) at org.gradle.jvm.toolchain.internal.JavaToolchainQueryService.query(JavaToolchainQueryService.java:146) at org.gradle.jvm.toolchain.internal.JavaToolchainQueryService.lambda$resolveToolchain$1(JavaToolchainQueryService.java:124) at org.gradle.jvm.toolchain.internal.JavaToolchainQueryService.resolveToolchain(JavaToolchainQueryService.java:122) at org.gradle.jvm.toolchain.internal.JavaToolchainQueryService.lambda$findMatchingToolchain$0(JavaToolchainQueryService.java:103) at org.gradle.api.internal.provider.DefaultProvider.calculateOwnValue(DefaultProvider.java:72) at org.gradle.api.internal.provider.AbstractMinimalProvider.calculateValue(AbstractMinimalProvider.java:108) at org.gradle.api.internal.provider.WithSideEffectProvider.calculateOwnValue(WithSideEffectProvider.java:54) at org.gradle.api.internal.provider.AbstractMinimalProvider.calculateValue(AbstractMinimalProvider.java:108) at org.gradle.api.internal.provider.TransformBackedProvider.calculateOwnValue(TransformBackedProvider.java:82) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aeb1c3bf44cf878be431c2228847918/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/58/">«</a>
	<span class="pagination__item pagination__item--current">59/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/60/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>