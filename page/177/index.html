<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151718dc2c4af9fa63057b73053a4d6e/" rel="bookmark">
			jQuery时髦的背景粒子效果插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址
一个jQuery时髦的背景粒子效果插件 ，包含一个可选的控制鼠标视差效果在桌面设备和移动设备上，工作在任何浏览器支持HTML5画布。用法$("#your-element").particleground();可以通过设置选项的选择对象的构造函数。下面是一个示例的设置粒子系统点和线的颜色:$("#your-element").particleground({ dotColor: "#ff0000", lineColor: "#ff0000"});暂停$("#your-element").particlegound("pause");开始$("#your-element").particlegound("start");销毁$("#your-element").particlegound("destroy");
dd:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a5ff56d20db4f18daff790cc55a5c9/" rel="bookmark">
			@Resource详解-代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Resource注解详解 属性介绍@Resource 的装配规则灵魂总结先来看下@Resource的应用场景 代码演示默认情况装配代码运行测试分析 byName (name默认属性名)装配代码运行测试分析 byName (name显示指定)装配代码运行测试分析 byType 显示指定装配代码运行测试分析 finally 此注解来源于JSR规范（Java Specification Requests）,其作用是找到依赖的组件注入到应用来，它利用了JNDI（Java Naming and Directory Interface Java命名目录接口 J2EE规范之一）技术查找所需的资源。 网上查了些资料看的有点晕晕, 这里用例子来说明 @Resource的用法 , 以及需要注意的问题
属性介绍 name： 资源的JNDI名称。在spring的注入时，指定bean的唯一标识。 type： 指定bean的类型。 lookup: 引用指向的资源的名称。它可以使用全局JNDI名称链接到任何兼容的资源。 authenticationType: 指定资源的身份验证类型。它只能为任何受支持类型的连接工厂的资源指定此选项，而不能为其他类型的资源指定此选项。 shareable： 指定此资源是否可以在此组件和其他组件之间共享。 mappedName： 指定资源的映射名称。 description： 指定资源的描述。 @Resource 的装配规则 默认情况下，即所有属性都不指定，它默认按照byType的方式装配bean对象。
如果指定了name，没有指定type，则采用byName。
如果没有指定name，而是指定了type，则按照byType装配bean对象。
当byName和byType都指定了，两个都会校验，如果找不到,或者找到多个(比如byName的方式找到了BeanA, ByType的方式找到了BeanB ) 这种情况也是不会成功的.
上述略显官方的味道的解释,相信不少人也是晕晕的 , 也对这个"默认值" 情况解释的不到位 , 下面来个灵魂总结.
灵魂总结 注意: !!! type和name的根本逻辑就是 type是划定一个范围 , 然后name 在其中选择一个
举个栗子:
如果 type 只匹配了 一个 ( 1 ) , 那么成功装备结果 必然是 1 , 如果name只有找到了1 , 或者没有找到的情况下才会配置成功( 没有显示指定name值, 默认为变量名) , name如果在容器中找到了非1 的bean ,则会报类型错误.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a5ff56d20db4f18daff790cc55a5c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327adcae13ca0757a127ec1a5a9aa4cd/" rel="bookmark">
			Linux中screen的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
本文转载自https://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html，主要讲述了linux中screen命令的使用，可以用这个命令来实现程序的后台运行，这样即使服务器连接断了，程序也能继续运行。
【具体而言】
1.使用指令screen -S name 打开新窗口，输入程序运行后，使用快捷键Ctrl+A+D,关闭窗口即可实现程序的后台运行。
2.要想重现窗口，使用指令screen -r name。
3.要想关闭后台进程，先使用screen -ls查看所有后台窗口，从中可以看到进程号，再使用kill 进程号关闭进程。
三、语法
screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;] 参数说明
-A 将所有的视窗都调整为目前终端机的大小。
-d &lt;作业名称&gt; 将指定的screen作业离线。
-h &lt;行数&gt; 指定视窗的缓冲区行数。
-m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。
-r &lt;作业名称&gt; 恢复离线的screen作业。
-R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。
-s 指定建立新视窗时，所要执行的shell。
-S &lt;作业名称&gt; 指定screen作业的名称。
-v 显示版本信息。
-x 恢复之前离线的screen作业。
-ls或–list 显示目前所有的screen作业。
-wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。
四、常用screen参数
screen -S yourname -&gt; 新建一个叫yourname的session
screen -ls -&gt; 列出当前所有的session
screen -r yourname -&gt; 回到yourname这个session
screen -d yourname -&gt; 远程detach某个session
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/327adcae13ca0757a127ec1a5a9aa4cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e39665e11fe82b59e8de5700a9890822/" rel="bookmark">
			better-scroll的学习和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		better-scroll的学习和初始化 介绍 在日常的移动端开发中，列表滚动条的处理是非常常见的需求，横竖的滚动条使用better-scroll都可以帮助我们在开发中实现。
什么是better-scroll better-scroll是一个移动端滚动的解决方案，他不仅可以做普通的滚动列表，也可以做轮播投，prcker等等。
better-scroll的滚动原理 原始的浏览器的滚动条很常见，当页面内容的高度超过视口高度的时候就会出现纵向滚动条，超出视口宽度的时候会出现横向的滚动条，也就是当我们的视口展示不下内容的时候，会通过滚动条的方式让用户滚动屏幕看到剩余的内容。better-scroll也是一样的道理。
better-scroll最常见的结构 下图可能更加直观：
绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 BetterScroll 的滚动原理。
初始化better-scroll html文件中使用
在script标签中引用，进行初始化，直接引用即可
【官网地址】
Vue中使用better-scroll
安装 npm install @better-scroll/core --save 在main中使用插件 import BScroll from '@better-scroll/core' import Pullup from '@better-scroll/pull-up' BScroll.use(Pullup) 引入 import BScroll from '@better-scroll/core' 初始化
html代码： &lt;template&gt; &lt;div class="wrapper"&gt; &lt;ul class="content"&gt; ... &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; script代码：
&lt;script&gt; import BScroll from '@better-scroll/core' export default { data(){ return{ scroll:null } }, mounted(){ this.scroll = new BScroll(document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e39665e11fe82b59e8de5700a9890822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e1850841f9319e99ec70664dbe9493/" rel="bookmark">
			Prometheus 监控体系、部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Prometheus的概述
1.Prometheus简介
2.Prometheus优点
3."抓取"数据的方式
4.Prometheus特性
5.Prometheus生态组件
二、运维监控平台设计思路
1.设计三个步骤
2.细划分为6层
三、部署 prometheus
1.关掉防火墙机制
2.安装prometheus
3.浏览器查看
一、Prometheus的概述 1.Prometheus简介 Prometheus是一款具备开源的监控，是一种TSDB(时序数据库)，复制于谷歌的borgmon监控系统，对k8s容器的监控非常适用。
Prometheus可以很好地记录任何纯数字时间序列。是位可靠性而设计的，既适用于以机器为中心的监视，也适用于高度动态的面向服务的体系结构的监视，系统中断期间依旧可以监控使用的系统。
2.Prometheus优点 (1)可以自定义多维数据模型，储存更加高效
(2)具有灵活且强大的查询语句（PromQL），不依赖分布式储存
(3)支持单节点工作，可通过pull方式采集时序数据
(4)可以通过push gateway进行时序列数据库推送
(5)可以通过服务发现或静态配置去获取要采集的目标服务器（sd server discover）多种可视化图表及仪表盘支持
3."抓取"数据的方式 首先收集数据分为白盒监控、黑盒监控
白盒监控：自省方式，被监控端内部，可以自己生成指标，只要等待监控系统来采集时提供出去即可
黑盒监控：对于被监控系统没有侵入性，对其没有直接"影响"，这种类似于基于探针机制进行监控（snmp协议）
其次Prometheus属于白盒监控，支持通过以下三种类型的途径从木板上抓取指标数据
Exporters ：指标暴露器；工作在被监控端，周期性的抓取数据并转换为pro兼容格式等待prometheus来收集，自己并不推送
Instrumentation：应用程序内置的指标暴露器；指被监控对象内部自身有数据收集、监控的功能，只需要prometheus直接去获取
Pushgateway：专用于收集短周期、临时的任务，等待prometheus拉取
4.Prometheus特性 ①多维的数据模型(基于时间序列的Key、value键值对)
②灵活的查询和聚合语言PromQL
③提供本地存储和分布式存储
④通过基于HTTP和HTTPS的Pull模型采集时间序列数据（pull数据的拉取，时间序列:每段 时间点的数据值指标，持续性的产生。横轴标识时间，纵轴为数据值，一段时间内数值的动态变化，所有的点连线形成大盘式的折线图)
⑤可利用Pushgateway (Prometheus的可选中间件）实现Push模式
⑥可通过动态服务发现或静态配置发现目标机器（通过consul自动发现和收缩)
⑥支持多种图表和数据大盘
5.Prometheus生态组件 Prometheus Server收集和储存时间序列数据 Client Library
目的在于为那些期望原生提供Instrumentation功能的应用程序提供便捷的开发途径 Exporters
指标暴露器Push Gateway 接收那些通常由短期作业生成的指标数据的网关
Prometheus Service Discovery(sd) 服务动态发现待监控的Target，发送告警信息
Prometheus scrape 数据采集器
Alertmanager
由告警规则对接 应用程序内置的指标暴露器
InstrumentationData Visualization（Dashboards） (prome-UI界面)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62e1850841f9319e99ec70664dbe9493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c83c8946217edd6942af90e04592b16/" rel="bookmark">
			使用FinalShell连接已经搭好的虚拟机（centos 7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前提环境 1.本机Windows上已经下载好FinalShell 2.VMWare上已经搭建好服务器（承载centos 7操作系统） 二、操作 1.查看centos 7的IP，记住这个IP（前提打开网络） 2. 打开FinalShell，具体操作如下 3.接着双击配好的连接打开它 初次连接，接受并保存秘钥 4.成功 5. 接着就可以尝试敲一些命令来验证了 以上这些就是为了让我们能熟悉一下FinalShell的功能以及用法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d86241791985c7baf0539016bb1c3051/" rel="bookmark">
			在服务器（Ubuntu）上，修改默认的python版本3.8==＞3.7（不删除原版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、降级python3.7
conda create -n py37 python=3.7 anaconda 注：他会重新安装所有包，花点时间有的多
我在conda命令行安装的
安装好后，会有提示：
To activate this environment, use
$ conda activate py37 To deactivate an active environment, use
$ conda deactivate 2、确定安装好的py37的路径
这是我的安装路径，用VScode找的。
3、用户级修改
为某个特定用户修改Python版本，只需要在其home目录下创建一个alias。
打开该用户的~/.bashrc文件：
vim ~/.bashrc 添加新的别名来修改默认Python版本：
输入i 进行修改
alias python='地址' 修改完 按esc :wq保存退出。
重新登录或者重新加载.bashrc文件，使操作生效：
$ . ~/.bashrc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5795867a931af8a9f4cc345c7d53739/" rel="bookmark">
			java泛型 枚举
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛型 在学习集合的时候，我们知道把数据存放到集合中之后，数据就会被提升成Object类型，在取出的时候，取出来的数据依然Object类型，如果要使用对象的特有功能时，特有数据时，就需要向下转型，只要是向下转型，就有可能发生异常。
在取出集合中元素的时候，由于集合中元素的类型不统一，导致在取出向下转型的时候，可能会发生ClassCastException，这个异常是在运行的时候才发生的。发生这个异常的原因是在给集合中存放对象的时候，由于存储了不同的类型数据，在运行程序过程中，取出时才发生了问题。如果我们能够控制在存放的时候，保证类型统一，那么在取出的时候，就不会发生问题了。
可以借助数组的思想，把集合在定义的时候，就让类型统一起来，如果在源码中给集合中存放数据的时候，如果类型不一致，就不让当前这个程序编译通过，那么就可以避免运行时期的问题了。
运用： List&lt;String&gt; list = new ArrayList&lt;String&gt;()； // 这个集合只能存字符串 Map&lt;String ,Object&gt; map= new HashMap&lt;String,Object&gt;(); // mapd的key 只能是字符串 , // value 可以是Obj 工具类collections用于操作集合类，如List,Set,常用方法有:
sort():排序
binarySearch()：查找,如果搜索到了，返回位置（从0开始）,找不到，返回一个负数
max()\min():查找最大\最小值
枚举 enum 的全称为 enumeration， 是 JDK 1.5 中引入的新特性，存放在 java.lang 包中。
JDK1.5 之前，我们定义常量都是： public static fianl.... 现在又有了枚举，可以把相关的常量分组到一个枚举类型里
枚举指由一组固定的常量组成的类型
声明
//声明枚举时必须使用 enum 关键字修饰 Public enum enumname{ enum-body, //一般写常量 } 运用
package oop3; public enum Enumname { 男, 女 } class Cla{ private Enumname sex; public Enumname getSex() { return sex; } public void setSex(Enumname sex) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5795867a931af8a9f4cc345c7d53739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e49f7842cd1be1a2cf47b5386cdb789/" rel="bookmark">
			微信小程序开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 小程序与普通网页开发的区别 (1) 运行环境的不同
网页运行在浏览器汇总,小程序运行在微信环境中
(2) api不同
(3) 开发模式不同
2 小程序代码的构成-项目结构 (1) 目录结构
(2) 页面的组成部分
组件: 一个完整的前端功能的整体,页面(html),功能(script),样式(style)
(3) json配置文件
① app.json
page: 用来记录当前小程序所有页面的路径windows: 全局定义小程序所有页面的背景色,文字颜色等style: 全局定义小程序组件所使用的的样式版本(v2表示新版样式)tabBar: 小程序的tabBar效果的配置sitemapLocation: 用来指明sitemap.json的位置 ② project.config.json(用来记录小程序开发工具所做的个性化配置)
setting: 保存了编译相关的配置(在设置中进行的设置会体现在setting中)
projectname : 保存的是项目名称 appid: 保存的是小程序的账号 ID
checkSiteMap: 控制台sitemap警告
③ sitemap.json
微信现已开放小程序内搜索，效果类似于 PC 网页的 SEO 。 sitemap.json 文件用来配置小程序 页面是否允许微信索引 当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索 关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。 ④ 页面.json
小程序中的每一个页面,可以使用.json文件来对本页面的窗口外观进行配置,页面中的配置项会覆盖app.json的window中相同的配置项,不需要写window对象名,直接写
3 新增小程序页面 在app.json -&gt; pages 中新增页面存放路径,小程序开发者工具可帮助我们自动创建对应的页面文件: 'pages/list/list',pages配置项的第一项作为首页显示
4 小程序代码的构成 4.1 WXML模板 (1) WXML和HTML的区别
标签名称不同
HTML(div, span, img, a)WXML(view, text, image, navigator) 属性节点不同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e49f7842cd1be1a2cf47b5386cdb789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5383d40c06bcbf18b54af119ca3c59bb/" rel="bookmark">
			开发环境 dns-client占用cpu过高问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：使用idea开发 ，启动项目，dns-client这个程序就会占用大量cpu资源，最高达到60%。
网上基本说的没什么用。
如果你的使用场景和我差不多，那可以试试以下解决办法。
首先dns-client这个服务你可以把它禁用掉，因为他并不是dns的客户端，禁用后对dns不会产生什么太大的影响。
2. 查看你项目的配置文件或者其他连接中间件的工具，连接本地中间件的ip地址不要写127.0.0.1这个回环地址，换成其他的本机ip。（效果显著！！！！！！！！！！）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93e9d3bf7af4d7d1b48524a3dd7e1007/" rel="bookmark">
			js之iframe子页面与父页面通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、同域下父子页面的通信 父页面parent.html &lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; function say(){ alert("parent.html"); } function callChild(){ myFrame.say(); myFrame.document.getElementById("button").value="调用结束"; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id="button" type="button" value="调用child.html中的函数say()" οnclick="callChild()"/&gt; &lt;iframe name="myFrame" src="child.html"&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 子页面child.html &lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; function say(){ alert("child.html"); } function callParent(){ parent.say(); parent.window.document.getElementById("button").value="调用结束"; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id="button" type="button" value="调用parent.html中的say()函数" οnclick="callParent()"/&gt; &lt;/body&gt; &lt;/html&gt; 方法调用 父页面调用子页面方法：FrameName.window.childMethod();
子页面调用父页面方法：parent.window.parentMethod();
DOM元素访问 获取到页面的window.document对象后，即可访问DOM元素
注意事项
要确保在iframe加载完成后再进行操作，如果iframe还未加载完成就开始调用里面的方法或变量，会产生错误。判断iframe是否加载完成有两种方法：
1. iframe上用onload事件
2. 用document.readyState=="complete"来判断
二、跨域父子页面通信方法 如果iframe所链接的是外部页面，因为安全机制就不能使用同域名下的通信方式了。
父页面向子页面传递数据 实现的技巧是利用location对象的hash值，通过它传递通信数据。在父页面设置iframe的src后面多加个data字符串，然后在子页面中通过某种方式能即时的获取到这儿的data就可以了，例如：
1. 在子页面中通过setInterval方法设置定时器，监听location.href的变化即可获得上面的data信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93e9d3bf7af4d7d1b48524a3dd7e1007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d31ac03ac57671c604013a54c3b1f1/" rel="bookmark">
			flink入门（wordcount）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink快速上手 1.在IDEA创建maven工程FlinkTutorial
2.在pom.xml中添加依赖和maven插件
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-scala_2.11&lt;/artifactId&gt; &lt;version&gt;1.10.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-streaming-scala --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-scala_2.11&lt;/artifactId&gt; &lt;version&gt;1.10.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-kafka-0.11_2.12&lt;/artifactId&gt; &lt;version&gt;1.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.bahir&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-redis_2.11&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-java_2.11&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-elasticsearch6_2.12&lt;/artifactId&gt; &lt;version&gt;1.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.44&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-statebackend-rocksdb_2.12&lt;/artifactId&gt; &lt;version&gt;1.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner_2.12&lt;/artifactId&gt; &lt;version&gt;1.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner-blink_2.12&lt;/artifactId&gt; &lt;version&gt;1.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-csv&lt;/artifactId&gt; &lt;version&gt;1.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-json&lt;/artifactId&gt; &lt;version&gt;1.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33d31ac03ac57671c604013a54c3b1f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f105847e5bcb2850c02c46972543b6/" rel="bookmark">
			SpringMVC中使用GetMapping等注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SpringMVC中使用REST风格 第一种方式第二种方式使用配置文件的方式使用java代码的方式jsp页面 在springmvc中，使用REST风格有两种方式 第一种使用@RequestMapping注解
第二种使用@GetMapping等注解
第一种方式 @RequestMapping (value = “/地址”，method = RequestMethod.GET) 使用RequestMapping里面的参数，method，设置GET/POST等方
第二种方式 @GetMapping ("/地址") 这种方式等同于第一种方式，GetMapping等同于设置了method=RequestMethod.GET的RequestMapping
但是如果想要使用这种注解的话，需要在配置文件中开启注解驱动
&lt;mvc:annotation-driven/&gt; 但是form只能支持get还有post格式，所以需要配置过滤器
使用配置文件的方式 &lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;methodParam&lt;/param-name&gt; &lt;param-value&gt;_m&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 使用java代码的方式 @Configuration public class AppConfig { @Bean public HiddenHttpMethodFilter filter(){ HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); hiddenHttpMethodFilter.setMethodParam("_m"); return hiddenHttpMethodFilter; } } jsp页面 &lt;form action="地址" method="post"&gt; &lt;input type="hidden" name="_m" value="DELETE"/&gt; &lt;input type="text" name="name"/&gt; &lt;input type="text" name="age"/&gt; &lt;input type="submit"/&gt; &lt;/form&gt; 其中_m是上面通过配置文件/java代码设置的，value设置的是请求方式，可以是DELETE/PUT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4f105847e5bcb2850c02c46972543b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fdd6295c06079b6fb37df5d469a47b/" rel="bookmark">
			Leetcode 2、141：两数相加-环形链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两数相加
var addTwoNumbers = function (l1, l2) { let cur1 = l1; let cur2 = l2; let newLinkHead = new ListNode(0); let result = newLinkHead; let yu = 0; // 余数 let carrybit = 0; // 进位 let val1; let val2; while (cur1 || cur2) { val1 = (cur1 &amp;&amp; cur1.val) || 0; val2 = (cur2 &amp;&amp; cur2.val) || 0; yu = (val1 + val2 + carrybit) % 10; result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68fdd6295c06079b6fb37df5d469a47b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db35df630dfd0338510806c51b19ad56/" rel="bookmark">
			mongodb分页排序问题 Sort exceeded memory limit of 104857600 bytes, but did not opt in to external sorting.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息： Sort exceeded memory limit of 104857600 bytes, but did not opt in to external sorting. Aborting operation. Pass allowDiskUse:true to opt in.
错误原因： MongoDB：排序超出了内存限制的104857600字节
laravel操作mongodb分页遇到的问题
"msg": "Sort exceeded memory limit of 104857600 bytes, but did not opt in to external sorting. Aborting operation. Pass allowDiskUse:true to opt in.",
实际上是mongodb排序超出了 104857600 字节的内存限制
需要在查询中加上allowDiskUse = true
mongodb语句如下： 查询时候需要加上 allowDiskUse = true
db.bigdata.aggregate( [ {$group : {_id : "$range", total : { $sum : 1 }}}, {$sort : {total : -1}} ], {allowDiskUse: true} ); 那么在laravel中怎么体现的呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db35df630dfd0338510806c51b19ad56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce057a45a7f0a53f6cad82e50651f737/" rel="bookmark">
			Pandas API 文档索引中文翻译版（一）—— Series
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：以Pandas官方API文档https://pandas.pydata.org/docs/reference/index.html为依据，根据使用频率对次序稍作整理，翻译API功能，计划补充API详细解读。
当前版本：1.3.4
Series Constructor：构造函数 API功能解读Series([data, index, dtype, name, copy, …])构造带轴标签的一维ndarry数组。 Attributes：属性 Axes
API功能解读Series.indexSeries的索引（轴标签）。Series.array返回以数组形式（ndarray的简易包装）返回Series的基础数据。Series.values根据dtype返以数组或类数组形式返回Series数组。Series.dtype返回基础数据的dtype对象。Series.shape以元组形式返回基础数据的形状（shape）。Series.nbytes返回基础数据的字节数。（相当于memory_usage(index=False)）Series.ndim返回基础数据的维数。Series.size返回基础数据的元素个数。Series.T返回Series的转置。Series.memory_usage([index, deep])返回Series的内存使用量。（可设置不包含索引的使用量）Series.hasnans返回Series是否有空值（nans），启用各种性能加速。Series.empty标识Series是否为空。Series.dtypes返回基础数据的dtype对象。Series.name返回Series的名称。Series.flags获取与Series对象相关联的属性。Series.set_flags(*[, copy, …])返回更新属性后的Series对象。 Conversion：转换 API功能解读Series.astype(dtype[, copy, errors])按dtype格式对Series对象进行转换。Series.convert_dtypes([infer_objects, …])使用支持 pd.NA的dtypes转换列。Series.infer_objects()尝试为Series对象列推断更好的数据类型。Series.copy([deep])创建一个Series对象的索引和数据的拷贝。Series.bool()Return the bool of a single element Series or DataFrame.Series.to_numpy([dtype, copy, na_value])以ndarray的形式返回Series 对象或 Index对象的值。Series.to_period([freq, copy])将Series 格式从DatetimeIndex转换为PeriodIndex。Series.to_timestamp([freq, how, copy])Cast to DatetimeIndex of Timestamps, at beginning of period.Series.to_list()以列表形式返回Series值。Series.__array__([dtype])Return the values as a NumPy array. Indexing, iteration：索引，迭代 API功能解读Series.at根据行/列标签对获取单独的一个值。Series.iat根据整数位置对获取单独的一个值。Series.loc根据标签获取一个行/列组或者布尔数组。Series.iloc根据整数位置索引数据。Series.__iter__()返回一个Series.values属性的迭代器。Series.items()返回一个(index, value)元组形式的惰性迭代器。Series.iteritems()返回一个(index, value)元组形式的惰性迭代器。Series.get(key[, default])根据给定的键获取对象的元素，如果未找到键，返回默认值。Series.keys()返回索引的别名。Series.pop(item)根据标签弹出项，并返回弹出项。Series.item()以Python标量形式返回Series基础数据的第一个元素。（已废弃）Series.xs(key[, axis, level, drop_level])Return cross-section from the Series/DataFrame. For more information on .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce057a45a7f0a53f6cad82e50651f737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/421648c4b23a18a6a4bb80144ba967e8/" rel="bookmark">
			超参数优化之贝叶斯优化（Bayesian Optimization)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Ⅰ.Grid Search/Random SearchⅡ.Bayesian Optimization Ⅰ.Grid Search/Random Search Grid Search:神经网络训练由许多超参数决定，例如网络深度、学习率、卷积核大小等等。为了找到一个最好的超参数组合，最直观的想法就是Grid Search, 其实也就是穷举搜索。
Random Search:为了提高搜索效率，提出随机搜索。虽然随机搜索得到的结果互相之间差异较大，但是实验证明随机搜索的确比网格搜索效果要好
Ⅱ.Bayesian Optimization 贝叶斯优化的大体思路：
假设一组超参数组合是 X = x 1 , x 2 , . . . , x n X = x_1,x_2, ...,x_n X=x1​,x2​,...,xn​, 贝叶斯优化假设超参数与需要优化的损失函数存在一个函数关系。
假设函数 f ： x → R ， 我 们 需 要 在 x ⊂ X 内 找 到 \ f ：x → R， 我们需要在 x \subset X内找到 f：x→R，我们需要在x⊂X内找到
x ∗ = a r g m i n x ∈ X f ( x ) （ 1 ） x^* =\mathop{argmin}\limits_{x \in X}f(x) \qquad （1） x∗=x∈Xargmin​f(x)（1）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/421648c4b23a18a6a4bb80144ba967e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85071b7e6a19b7f7d7628bf9548d8c2/" rel="bookmark">
			vue强制刷新后跳转首页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题: vue使用Pubsub.js遇到了publish页面未打开触发subscribe页面订阅不到数据的问题，没办法只能在强制刷新页面后先自动跳转到publish页面触发
解决办法：在mounted内创建监听事件
window.addEventListener(‘load’, e =&gt; this.beforeunloadFn(e)); methods里写方法
beforeunloadFn(e){ if (this.$route.path !== '/Data'){ this.$router.push({name:'Data'}) } } , type类型选择load,在js语法里是onload,这里省去on,onload指页面加载完成后执行window.onload()里的js函数,首次加载页面是建立一个onload的监听事件并不执行,针对的是当前页面的下一次加载即刷新去执行onload里的方法,配合
destroyed() {window.removeEventListener(‘load’, e =&gt; this.beforeunloadFn(e))} ,可解决某一vue单页面刷新跳转另一页面的问题。
错误尝试:
window.addEventListener(‘beforeunload’, e =&gt;this.beforeunloadFn(e)); type类型为beforunload是指页面刷新前执行的最后函数所以即使跳转另一页面也会在刷新完成后跳转回原页面,此方法适用与刷新页面前提交表格数据或阻止刷新的操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6acb4b293edfd455a2aa611dfdeae0/" rel="bookmark">
			解决mmdetection训练过程loss为nan的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我之前遇到多次loss为nan，一次是由于数据标注出现问题，换不同的模型参数均出现此问题，因此需要仔细检查数据格式；有一次是换了个neck的结构，loss变为nan，后面通过将学习率调为原来的1/10（根据实际情况调整），就没有出现了；还有一次是注释掉fp16训练即可。下面参考了官方文档给出的解决方案以及自身经验，应该可以解决大部分问题。
检查数据的标注是否正常， 长或宽为 0 的框可能会导致回归 loss 变为 nan，一些小尺寸（宽度或高度小于 1）的框在数据增强（例如，instaboost）后也会导致此问题。 因此，可以检查标注并过滤掉那些特别小甚至面积为 0 的框，并关闭一些可能会导致 0 面积框出现数据增强。
降低学习率：由于某些原因，例如 batch size 大小的变化， 导致当前学习率可能太大。 您可以降低为可以稳定训练模型的值。
optimizer = dict(type='AdamW', lr=0.0001, betas=(0.9, 0.999), weight_decay=0.05, # 0.001 paramwise_cfg=dict(custom_keys={'absolute_pos_embed': dict(decay_mult=0.), 'relative_position_bias_table': dict(decay_mult=0.), 'norm': dict(decay_mult=0.)})) 延长 warm up 的时间：一些模型在训练初始时对学习率很敏感，您可以把 warmup_iters 从 500 更改为 1000 或 2000。
lr_config = dict( policy='step', warmup='linear', warmup_iters=500, # 修改这里 Epoch [1][500/xxxx]之前的学习率的意思 warmup_ratio=0.001, step=[8, 11]) 添加 gradient clipping: 一些模型需要梯度裁剪来稳定训练过程。 默认的 grad_clip 是 None, 你可以在 config 设置 optimizer_config=dict(_delete_=True, grad_clip=dict(max_norm=35, norm_type=2)) 如果你的 config 没有继承任何包含 optimizer_config=dict(grad_clip=None), 你可以直接设置optimizer_config=dict(grad_clip=dict(max_norm=35, norm_type=2)).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd6acb4b293edfd455a2aa611dfdeae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/587e857e0d95ab2fa5359b3b892dd267/" rel="bookmark">
			关于在阅读论文中常见的简写说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		w.r.t. ： with respect to 的缩写。是 【关于…；谈及，谈到】的意思。
i.e. ：源自拉丁文id est.【也就是；亦即；换而言之】的意思。
s.t.：subject to 的缩写，一般用在公式中，表示约束条件。【使得…满足…】的意思。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce1a226fa41de0ee2b01e8eb67d5597/" rel="bookmark">
			R语言|栅格处理-crop函数按经纬度裁剪栅格数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bio #为已有的栅格数据，数据集或栅格图层都可以。extent为现在的大小范围，我想按照经纬度范围裁剪的小一点。
e&lt;-extent(90,180,45,80) #设置我想要的范围，这里只改变了纬度范围，经度范围没有改变。
bioe&lt;-crop（bio，e）#第一个位置输入原来的栅格，第二个位置输入你想要的栅格，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/675b1c0b1d5060038940cc374df3a9fd/" rel="bookmark">
			数据结构与算法——29. 图（Graph）的概念及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、图（Graph）的概念1. 图的相关术语2. 图的定义 二、图抽象数据类型（ADT Graph）1. 邻接矩阵实现图2. 邻接列表实现图3. python代码实现 三、图的应用：词梯问题1. 构建单词关系图2. python代码实现 一、图（Graph）的概念 图Graph是比树更为一般的结构，也是由节点和边构成。而实际上树是一种具有特殊性质的图。
图可以用来表示现实世界中很多事物：道路交通系统、航班线路、互联网连接、或者是大学中课程的先修次序。
一旦我们对图相关问题进行了准确的描述，就可以采用处理图的标准算法来解决那些看起来很艰深的问题。
对于人来说，人脑的识别模式能够轻而易举地判断地图中不同地点的相互关联；但如果用图来表示地图，就可以解决很多地图专家才能解决的问题，甚至远远超越；
互联网是由成千上万的计算机所连接起来的复杂网络，也可以通过图算法来确定计算机之间达成通讯的最短、最快或者最有效的路径。
1. 图的相关术语 顶点（Vertex，也称“节点node”）：
是图的基本组成部分，定点具有名称标识key，也可以携带数据项payload。
边 （Edge，也称“弧Arc”）：
作为2个顶点之间关系的表示，边连接两个顶点；边可以是有向的或者无向的，相应的图称做“有向图”和“无向图”。
权重（Weight）：
为了表达从一个顶点到另一个顶点的“代价”，可以给边赋权；
例如公交网络中两个站点之间的“距离”、“通行时间”和“票价”都可以作为权重。
路径（Path）：
图中的路径，是由边依次链接起来的顶点序列；无权路径的长度为边的数量；带权路径的长度为所有边权重的和；
如下图的一条路径(v3,v4,v0,v1)：
圈（Cycle）：
圈或环是首尾顶点相同的路径，如上图中（V5,V2,V3,V5）。
如果有向图中不存在任何圈，则称为“有向无圈图 directed acyclic graph：DAG”。如果一个问题能表示成DAG，那么就可以用图算法很好地解决。我们之前学的树结构，其实就是一种DAG。
2. 图的定义 一个图G可以定义为G=(V, E)。其中V是顶点的集合，E是边的集合，E中的每条
边e=(v, w)，v和w都是V中的顶点；
如果是赋权图（边带有权重的图，也叫带权图），则可以在e中添加权重分量子图：V和E的子集。比如下面的有向赋权图：
V = { V 0 , V 1 , V 2 , V 3 , V 4 , V 5 } V=\{V0,V1,V2,V3,V4,V5\} V={V0,V1,V2,V3,V4,V5}
E = { ( v 0 , v 1 , 5 ) , ( v 1 , v 2 , 4 ) , ( v 2 , v 3 , 9 ) , ( v 3 , v 4 , 7 ) , ( v 4 , v 0 , 1 ) , ( v 0 , v 5 , 2 ) , ( v 5 , v 4 , 8 ) , ( v 3 , v 5 , 3 ) , ( v 5 , v 2 , 1 ) } E=\{(v0,v1,5),(v1,v2,4),(v2,v3,9),(v3,v4,7),(v4,v0,1),(v0,v5,2),(v5,v4,8),(v3,v5,3),(v5,v2,1)\} E={(v0,v1,5),(v1,v2,4),(v2,v3,9),(v3,v4,7),(v4,v0,1),(v0,v5,2),(v5,v4,8),(v3,v5,3),(v5,v2,1)}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/675b1c0b1d5060038940cc374df3a9fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4c9d8726cfa55852bc29a023298280/" rel="bookmark">
			axios封装后，export导出路由为undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： 对axios进行简单的封装后，store下的文件导入路由routes，结果返回的是undefined。没封装前路由是可以正常导入的，但是封装后就无法正常导入了。
解决方法： 以前的导入方式是
import routes from './router/index'
改为require方式
const routes = require('./router/index') 接下来就可以正常使用了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cedb4b2e7773857f7fa6775156cea68/" rel="bookmark">
			IDEA创建python项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建项目前安装python插件 PythonPycharm cell modeBashSupport 2、创建项目选择python 选择Python，配置python安装路径，点击next、next、输入项目名选择项目路径点击finish
3、创建python包 New–&gt;Python Package，命名为python，创建后目录结构如图所示，在python包下自动生成的_init_.py文件。
4、编写语句并运行 在_init_.py文件中编写python代码，运行调试。
转自：IDEA学习三：在IDEA创建第一个python工程（项目）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54fe9a4c79d62e40df4008a0c8eadf66/" rel="bookmark">
			MYSQL数据库学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据库概述 1.1、为什么要使用数据库
1.2、数据库与数据库管理系统
为什么要使用数据库？
持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。
持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。
数据库与数据库管理系统
DB：数据库（Database）
即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。
DBMS：数据库管理系统（Database Management System）
是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。
SQL：结构化查询语言（Structured Query Language）
数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。
数据库管理系统、数据库和表的关系如图所示：
常见的数据库管理系统排名（DBMS）
目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、Sybase、Informix这几种。 查看数据库最新排名对应的走势图
2、MYSQL介绍 MySQL是一个开放源代码的关系型数据库管理系统，由瑞典MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的 No.1。2008被Sun收购（10亿美金），2009年Sun被Oracle收购。MariaDB应运而生。（MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB）MySQL6.x 版本之后分为社区版和商业版。MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL是开源的，所以你不需要支付额外的费用。MySQL是可以定制的，采用了GPL（GNU General Public License）协议，你可以修改源码来开发自己的MySQL系统。MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。MySQL使用标准的SQL数据语言形式。MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等 Why Choose MySQL
1、开放源代码，使用成本低。
2.、性能卓越，服务稳定。
3、软件体积小，使用简单，并且易于维护。
4、历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。
5、许多互联网公司在用，经过了时间的验证。
Oracle vs MySQL
Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。
MySQL 由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。
3、使用正则表达式查询 正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。
MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。
示例：
1. 查询以特定字符或字符串开头的记录
字符‘^’匹配以特定字符或者字符串开头的文本。
在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下：
mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP '^b'; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54fe9a4c79d62e40df4008a0c8eadf66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/129b081a266390a79a76a473e7742619/" rel="bookmark">
			charles连不上手机解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6442e04ccce78498089a1c073a8c8c/" rel="bookmark">
			Go 学习笔记（82）— Go 第三方库之 viper（解析配置文件、热更新配置文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. viper 特点 viper 是一个完整的 Go应用程序的配置解决方案，它被设计为在应用程序中工作，并能处理所有类型的配置需求和格式。支持特性功能如下：
设置默认值读取 JSON、TOML、YAML、HCL、envfile和 Java属性的配置文件监控配置文件改动，并热加载配置文件从环境变量中读取从远程配置中心读取配置（etcd/consul），并监控变动从命令行标志中读取从缓冲区读取支持直接设置配置项的值 viper读取配置文件的优先级顺序：
viper.Set() 所设置的值命令行 flag环境变量配置文件配置中心etcd/consul默认值 注意：viper的配置键是不区分大小写的。
2. 安装 官网地址：https://github.com/spf13/viper 安装命令
go get github.com/spf13/viper 3. 将配置注册到 viper 3.1 创建默认值 viper.SetDefault("Name", "wohu") viper.SetDefault("Gender", "male") viper.SetDefault("City", map[string]string{"country": "China", "Province": "Beijing"}) 3.2 从配置文件读取值 viper默认不配置文件的搜索路径，将配置文件路径的搜索决定权放在用户程序中。
viper.SetConfigName("config") // 配置文件名字，注意没有扩展名 viper.SetConfigType("yaml") // 如果配置文件的名称中没有包含扩展名，那么该字段是必需的 viper.AddConfigPath("/etc/appname/") // 配置文件的路径 viper.AddConfigPath("$HOME/.appname") // 多次调用添加多个配置文件的路径 viper.AddConfigPath(".") // 在当前工作目录寻找配置文件 err := viper.ReadInConfig() // 查找并读取配置文件 if err != nil { panic(fmt.Errorf("Fatal error config file: %w \n", err)) } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f6442e04ccce78498089a1c073a8c8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/301b9ebd2d721507c56db459a10e1b8c/" rel="bookmark">
			Golang---interface
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d710054e6b7d6baebd73a5ca0d2837/" rel="bookmark">
			Linux下使用bash脚本监控程序并自动在screen中重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因 最近写了一个爬取程序，但是时不时的会因为网络波动断掉，又经常想不起来取检查，因此有时候一断就是浪费了好几天的时间，因此多方查找总结，自己写了一个bash脚本，可以实现：
每隔一段时间检查一遍程序是否还在运行如果停止则自动在对应的screen窗口中运行对应的指令 监控脚本 #!/bin/sh CheckProcess() { if [ `ps -ef|grep $1 | grep -v grep |wc -l` -gt 0 ]; then echo "${1}正在运行" else echo "$(date "+%Y-%m-%d %H:%M:%S") ${1}已停止" echo "正在重启${1}" # 重启指令 fi } while [[ true ]]; do echo "$(date "+%Y-%m-%d %H:%M:%S")" do CheckProcess "ProcessName" done sleep 5m done 下面来对这段代码进行讲解：
首先来看 if 判断条件中的这句话
if [ `ps -ef|grep $1 | grep -v grep |wc -l` -gt 0 ] -gt是一个比较函数，意思是测试一个数是否大于另一个数；大于，为真；否则，为假。ps -ef|grep $1 | grep -v grep |wc -l的作用是打印出系统中所有包含参数 $1 的命令，例如我需要监控的程序的命令行输入为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84d710054e6b7d6baebd73a5ca0d2837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae8f58fb5219c877752920fa2f36c9e/" rel="bookmark">
			java 什么是迭代器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、迭代器是什么
二、如何获取一个迭代器
三、迭代器的语法
四、迭代器在集合中的使用
一、迭代器是什么 迭代器是一个对象，它能够循环便利容器中的全部元素，获得每一个元素值。前提是该容器是有序有索引的。迭代器和foreach的用法相似。迭代器不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。迭代器是可以返回相同类型值的有序序列的一段代码。
二、如何获取一个迭代器 Iterator 是 Java 中迭代器的实现，ListIterator 是 Collection中的子接口。
实现迭代器代码如下：
import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class demo1 { public static void main(String[] args) { // 创建集合 List list = new ArrayList(); // 获取迭代器 Iterator it = list.iterator(); } } 三、迭代器的语法 迭代器 it 的三个基本语法是 next()、hasNext() 和 remove()。
调用 it.next() 会返回迭代器的下一个元素。
调用 it.hasNext() 用于检测集合中是否还有元素，返回一个布尔类型。
调用 it.remove() 将迭代器返回的元素删除。
Iterator 类位于 java.util 包中，使用前需要引入它，语法格式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ae8f58fb5219c877752920fa2f36c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c533e753f6fc5f4ce8833abdeba85ba/" rel="bookmark">
			使用多态完成给宠物喂食
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主程序类：
package com.bdqn; ​ public class PetTest { public static void main(String[] args) { Master master = new Master(); Pet dog = new Dog(); dog.setName("黑鼻"); dog.setHealth(88); dog.setLove(78); ((Dog) dog).setStrain(1); dog.print(); master.feed(dog); ​ System.out.println("**********************"); ​ Pet penguin = new Penguin(); penguin.setName("QQ"); penguin.setHealth(100); penguin.setLove(76); ((Penguin) penguin).setSex(1); penguin.print(); master.feed(penguin); } } 主人类
package com.bdqn; ​ public class Master { public void feed(Pet pet){ if(pet instanceof Dog){ Dog dog = (Dog)pet; dog.eat(); }else if(pet instanceof Penguin){ Penguin penguin = (Penguin) pet; penguin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c533e753f6fc5f4ce8833abdeba85ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88821756c6b00c7f7f6a726e331c04ff/" rel="bookmark">
			图解23种设计模式，不信你学不会！（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注公众号，实用技术文章及时了解
来源：blog.csdn.net/zsjlovesm521/article/details/94382666 一、单一职责原则 就一个类而言，应该仅有一个引起它变化的原因。
如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱他的设计，当变化发生时，设计会遭受到意想不到的破坏；软件设计真正要做的许多内容就是发现职责并把那些职责相互分离。
二、开放-封闭原则 软件实体应该可以扩展，但不可修改。该原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的可维护、可扩展、可复用、灵活性好。
设计人员必须对于他设计的模块应该对哪种变化封闭做出选择，必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。最初编写程序时假设变化不会发生，当变化发生时，就创建抽象来隔离以后发生的同类变化，拒绝不成熟的抽象。
三、里氏代换原则 子类型必须能够替换掉它们的父类型。由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。
四、依赖倒转原则 高层模块不应该依赖低层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。
要针对接口编程，不要针对实现编程。该原则可以说是面向对象设计的标志，编写时考虑的是如何对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口。
五、迪迷特原则（最少知识原则） 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
该原则其根本思想，是强调了类之间的松耦合；类之间的耦合越弱，越利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。
六、合成/聚合复用原则 尽量使用合成/聚合，尽量不要使用类继承。
聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。
优先使用对象的合成/聚合将有助于你保持每个类被封装，并被击中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。
七、UML例图 ‘+’表示public，‘-’表示private，‘#’表示protected；
接口顶端有《interface》显示，只有两行；同时另一个表示方法为棒棒糖表示法；
聚合表示一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；
合成是一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样；
在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)
1. 泛化（Generalization） 【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。
【箭头指向】：带三角箭头的实线，箭头指向父类
2. 实现（Realization） 【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.
【箭头指向】：带三角箭头的虚线，箭头指向接口
3. 关联（Association) 【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。
【代码体现】：成员变量
【箭头及指向】：带普通箭头的实心线，指向被拥有者
上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。
下图为自身关联：
4. 聚合（Aggregation） 【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。
聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。
【代码体现】：成员变量
【箭头及指向】：带空心菱形的实心线，菱形指向整体
5. 组合(Composition) 【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。
组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。
【代码体现】：成员变量
【箭头及指向】：带实心菱形的实线，菱形指向整体
6. 依赖(Dependency) 【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.
【代码表现】：局部变量、方法的参数或者对静态方法的调用
【箭头及指向】：带箭头的虚线，指向被使用者
各种关系的强弱顺序：
泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88821756c6b00c7f7f6a726e331c04ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b93e7120016bda612187024b79c70d/" rel="bookmark">
			CVE-2021-22205:GitLab 远程命令执行漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、漏洞介绍 近日，GitLab远程代码执行漏洞(CVE-2021-22205) 被广泛利用。该漏洞是由于GitLab没有正确处理传入的图像文件，造成某些端点的路径存在无需授权的风险，攻击者可以在无需认证的情况下构造恶意图片文件并上传到GitLab，从而执行远程命令，导致服务器敏感信息泄露。
受影响版本
11.9 &lt;= Gitlab CE/EE &lt; 13.8.8
13.9 &lt;= Gitlab CE/EE &lt; 13.9.6
13.10 &lt;= Gitlab CE/EE &lt; 13.10.3
2、漏洞检测 测试应用http://ip:port，可访问
POC脚本下载地址：https://github.com/Al1ex/CVE-2021-22205
python CVE-2021-22205.py -v true -t http://IP:Port
3、漏洞利用 （1）开启HTTP服务
（2）远程命令执行脚本：python3 CVE-2021-22205.py -a true -t http://ip:port -c command
4、修复建议 （1）目前Gitlab官方已发布漏洞补丁，针对受影响的资产及时更新至安全版本。
参考链接：https://about.gitlab.com/releases/2021/04/14/security-release-gitlab-13-10-3-released/。
（2）配置访问控制策略，避免受影响的GitLab暴露在公网。
参考链接：https://www.cnblogs.com/cn-gov/p/15490588.html
https://hackerone.com/reports/1154542
https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html
https://security.humanativaspa.it/gitlab-ce-cve-2021-22205-in-the-wild/
https://github.com/projectdiscovery/nuclei-templates/blob/master/cves/2021/CVE-2021-22205.yaml
https://github.com/vulhub/vulhub/blob/master/gitlab/CVE-2021-22205/README.zh-cn.md
注：公布的测试脚本需要微改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b6c83d76cb6d7bf3d1ed074ea6ccd78/" rel="bookmark">
			Linux报错 vi /etc/sysconfig/network-scripts/ifcfg-ens33编辑后无法保存,出现E212：Can‘t open file for writing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行 vi /etc/sysconfig/network-scripts/ifcfg-ens33，修改之后 ,然后 :wq 进行保存退出，退出不了，一直出现这个提示：Can't open file for writing
只能:q! 先退出。
然后ip addr 仔细看了下自己的文件是 eth0，而不是ens33，想到每个电脑的文件名可能是不一样的。所以需要改成 ：vi /etc/sysconfig/network-scripts/ifcfg-eth0
先 su root 进入root用户，
然后： vi /etc/sysconfig/network-scripts/ifcfg-eth0 打开后该怎么改就怎么改了。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca927e2c9d7b202a59334d3721c009a/" rel="bookmark">
			实战：git中正确删除文件的方法-2021.12.07
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 文章目录 目录实验环境实验软件1、实验目的2、配置方法3、命令总结1.正确删除文件的方法：`rm命令`2.借Github的merge button，讲解GitHub的三种merge方式 关于我最后 实验环境 win10 git version 2.17.0.windows.1 实验软件 无
1、实验目的 正确删除文件的方法
现在我想在以后的commit中不包含某个文件，我该如何把这个文件删除呢？
2、配置方法 🍀 查看当前环境：现在我想删除readme.md这个文件，该怎么做呢？
hg@LAPTOP-G8TUFE0T MINGW64 /d/IT/01 IT/github_repo/01 极客时间：git学习测试库/git_learning (temp) $ gs On branch temp nothing to commit, working tree clean hg@LAPTOP-G8TUFE0T MINGW64 /d/IT/01 IT/github_repo/01 极客时间：git学习测试库/git_learning (temp) $ ls images/ index.html readme.md styles/ hg@LAPTOP-G8TUFE0T MINGW64 /d/IT/01 IT/github_repo/01 极客时间：git学习测试库/git_learning (temp) 🍀 方法1：常规命令删除
常规的做法就是通过2条命令进行删除，先使用rm删除文件，再用git rm把删除的添加到暂存区，过程如下：
$ rm -rf readme.md $ gs $ git rm readme.md $ gs $ ls 🍀 方法2：现在有个更简单的方法，用1条命令直接一步到位即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bca927e2c9d7b202a59334d3721c009a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b964b2cb13c9201824194d13020adca2/" rel="bookmark">
			C语言--指针、数组、字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6-1计算输入的两数的和与差的简单函数。 函数接口定义： void sum_diff( float op1, float op2, float *psum, float *pdiff ); 其中op1和op2是输入的两个实数，*psum和*pdiff是计算得出的和与差。
裁判测试程序样例： #include &lt;stdio.h&gt; void sum_diff( float op1, float op2, float *psum, float *pdiff ); int main() { float a, b, sum, diff; scanf("%f %f", &amp;a, &amp;b); sum_diff(a, b, &amp;sum, &amp;diff); printf("The sum is %.2f\nThe diff is %.2f\n", sum, diff); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： 4 6 结尾无空行
输出样例： The sum is 10.00 The diff is -2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b964b2cb13c9201824194d13020adca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffdd35a8ebbd06e3cd494891071319e6/" rel="bookmark">
			css修改兄弟节点样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如界面样式
&lt;div className={a}&gt;&lt;/div&gt;
&lt;div className={b}&gt;&lt;/div&gt;
scss文件里面 .a+.b{}为a状态下b的属性
例如.a:hover+.b为a hover下b的状态
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e160b642ddbcda09b2f0ae08874133bd/" rel="bookmark">
			python tkinter出牌洗牌
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python tkinter 出牌洗牌 利用Tkinter模块设计出扑克牌发牌窗体程序，要求4名牌手打牌，计算机随机将52张牌（不含大小王）发给4名牌手，在屏幕上显示每位牌手的牌。程序运行结果如图所示。
本程序只是实现一个界面和出牌洗牌的功能，不是斗地主游戏！！！有两个问题没有解决：洗牌的动画效果不好每次出牌后不能把新打出的牌放到最顶层 源代码：
from functools import partial from tkinter import * import random import time from PIL import Image,ImageTk tk=Tk() tk.title("洗牌，出牌") tk.geometry("800x600+250+30") tk.resizable(0,0) bu=Button() buttons=[bu]*52#记录所有选中的按钮 delbuttons=[]#记录所有按钮 sign=[] imgs=[] for i in range(1,5): for j in range(1,14): imgs.insert((i-1)*13+(j-1),PhotoImage(file='images\\'+str(i)+'-'+str(j)+'.gif')) #为窗口添加背景图片 can=Canvas(tk,width=800,height=600) im=Image.open('images\\bg.gif') img=ImageTk.PhotoImage(im.resize((800,600))) can.create_image(400,300,image=img) can.pack() #洗牌后删除所有牌函数 def delbutton(): for i in range(0,52): buttons[i]=bu buttons[i].place_forget() for i in range(0,len(delbuttons)): delbuttons[i].place_forget() tk.after(500,washcard1) #洗牌 def washcard1(): #打乱图片列表的顺序 random.shuffle(imgs) #创建第一行 a=230 #b=[0]*13 for i in range(0,13): l1=Button(tk,image=imgs[i],compound=CENTER) command = partial(downclik, l1,a,i) #command=upclik(l1,a)结果为：打印了13个hello l1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e160b642ddbcda09b2f0ae08874133bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8e18f2cbca76cc7158049a0c309c77/" rel="bookmark">
			卡巴斯基企业版本杀毒软件防火墙，支持windows服务器系统安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 卡巴斯基企业版本杀毒软件防火墙，支持windows服务器系统安装
windows服务器版本杀毒软件防火墙
授权5000天
链接: https://pan.baidu.com/s/1QHRPVbF1VoDHFE5NobFfVA 提取码: 7285 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5903956be55b3232dd569ac7f1fd7b/" rel="bookmark">
			QT学习记录：编译错误“no matching function for call toXXX“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学QT，在尝试用connect手动关联一个按钮和QlineEdit的时候编译报错，如下：
然后贴上主要代码块：
//以下是mainwindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include &lt;QMainWindow&gt; QT_BEGIN_NAMESPACE namespace Ui { class MainWindow; } QT_END_NAMESPACE class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); private: Ui::MainWindow *ui; public slots: void self_pushButton_clicked(); }; #endif // MAINWINDOW_H //以下是mainwindow.cpp #include "mainwindow.h" #include "ui_mainwindow.h" #include&lt;QPushButton&gt; #include&lt;QLineEdit&gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-&gt;setupUi(this); ui-&gt;myline-&gt;setText("hello"); ui-&gt;mybtn-&gt;setText("clicked me"); connect(ui-&gt;mybtn,&amp;QPushButton::clicked,ui-&gt;myline,&amp;MainWindow::self_pushButton_clicked); } MainWindow::~MainWindow() { delete ui; } void MainWindow::self_pushButton_clicked() { ui-&gt;myline-&gt;setText("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e5903956be55b3232dd569ac7f1fd7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441073181d96ca44abe9f3abdb4519b6/" rel="bookmark">
			Java实现人脸识别(各项目结构都有案例说明)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能简述 感觉人脸识别功能有点意思，就尝试写了一个小demo，然后将其整合到自己的项目中；下面是基于Java实现的人脸识别demo。
功能流程 调用摄像头获取图像
判断是否为新用户 然后就会跳转：
下面会具体分析
SDK 这个人脸识别的功能是调用的第三方SDK，自己不会写~~。
注册之后，可以免费使用100个应用；且适用于多平台，我这里是windows64位；
下载后的SDK目录如下：
里面有说明文档、jar包以及依赖文件和一个demo。
JavaWeb版 这里是官网给的JavaWeb版案例，我做了一些注释：
import com.arcsoft.face.*; import com.arcsoft.face.enums.*; import com.arcsoft.face.toolkit.ImageInfo; import java.io.File; import java.util.ArrayList; import java.util.List; import com.arcsoft.face.toolkit.ImageInfoEx; import static com.arcsoft.face.toolkit.ImageFactory.getGrayData; import static com.arcsoft.face.toolkit.ImageFactory.getRGBData; public class FaceEngineTest { public static void main(String[] args) { //从官网获取 String appId = ""; String sdkKey = ""; FaceEngine faceEngine = new FaceEngine("D:\\arcsoft_lib"); //激活引擎，只需要一次 int errorCode = faceEngine.activeOnline(appId, sdkKey); if (errorCode != ErrorInfo.MOK.getValue() &amp;&amp; errorCode !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/441073181d96ca44abe9f3abdb4519b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772338e85a2cef5b44a779433ffb1e71/" rel="bookmark">
			统计学习方法——机器学习和统计学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行分析与预测的一门学科。统计学习包括监督学习、非监督学习、半监督学习和强化学习。
2．统计学习方法三要素——模型、策略、算法，对理解统计学习方法起到提纲挈领的作用。
3．本书主要讨论监督学习，监督学习可以概括如下：从给定有限的训练数据出发， 假设数据是独立同分布的，而且假设模型属于某个假设空间，应用某一评价准则，从假设空间中选取一个最优的模型，使它对已给训练数据及未知测试数据在给定评价标准意义下有最准确的预测。
4．统计学习中，进行模型选择或者说提高学习的泛化能力是一个重要问题。如果只考虑减少训练误差，就可能产生过拟合现象。模型选择的方法有正则化与交叉验证。学习方法泛化能力的分析是统计学习理论研究的重要课题。
5．分类问题、标注问题和回归问题都是监督学习的重要问题。本书中介绍的统计学习方法包括感知机、 𝑘 近邻法、朴素贝叶斯法、决策树、逻辑斯谛回归与最大熵模型、支持向量机、提升方法、EM算法、隐马尔可夫模型和条件随机场。这些方法是主要的分类、标注以及回归方法。它们又可以归类为生成方法与判别方法。
使用最小二乘法拟和曲线 import numpy as np import scipy as sp from scipy.optimize import leastsq import matplotlib.pyplot as plt # 目标函数 def real_func(x): return np.sin(2*np.pi*x) # 多项式 def fit_func(p, x): f = np.poly1d(p) return f(x) # 残差 def residuals_func(p, x, y): ret = fit_func(p, x) - y return ret # 十个点 x = np.linspace(0, 1, 10) x_points = np.linspace(0, 1, 1000) # 加上正态分布噪音的目标函数的值 y_ = real_func(x) y = [np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/772338e85a2cef5b44a779433ffb1e71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e73d3f9c3680457fe9574efe64722a4/" rel="bookmark">
			大数据技术之flink实现简单的wordcount
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.java版实现 离线版 本地运行 pom文件
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.antg&lt;/groupId&gt; &lt;artifactId&gt;worldcount&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;${project.artifactId}&lt;/name&gt; &lt;description&gt;My wonderfull scala app&lt;/description&gt; &lt;inceptionYear&gt;2018&lt;/inceptionYear&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;scala.version&gt;2.11.11&lt;/scala.version&gt; &lt;scala.compile.at.version&gt;2.11&lt;/scala.compile.at.version&gt; &lt;flink.version&gt;1.13.1&lt;/flink.version&gt; &lt;jdk.version&gt;1.8&lt;/jdk.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- flink包依赖配置-start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-java&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-clients_${scala.compile.at.version}&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- flink包依赖配置-end --&gt; &lt;!-- 日志类引入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 因为往往是scala和java在一起混合开发，故需要设置多个源文件目录，故需要maven新插件build-helper-maven-plugin来支持设置多个源文件夹,也可以设置多个资源路径 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e73d3f9c3680457fe9574efe64722a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ecdf837c23f6ae6f1c52558bb21356/" rel="bookmark">
			快手视频以及评论获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要安装的第三方库
requests、json、xlwt
第一步：
进入快手网页版并登录，找到需要下载的视频用户，并进入主页，按F12进入开发者模式。刷新并点击XHR类型：
第二步： 左侧Name下的graphql就是储存用户以及视频的地方，顺序不一定，但大多数的视频信息储存在第二个graphql中
点击Preview就可以看到视频的信息，既然找到了，我们只需把它弄出来。但是我们发现每个graphql返回的url是相同的，所以我们不能用.get方法获取任何信息。因此，我们需要向url中传递一定的信息，才能返回我们需要的东西 而我们所需要传递的信息都在graphql的headers中（最底下）
！！！cookie的值需要登录后获取
#头部信息 headers = { "Cookie":"", "User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36" } #向浏览器传递的信息 post = { "operationName":"visionProfilePhotoList", "variables":{ "userId":userId, "pcursor":pcursor, "page":"profile" }, "query":"query visionProfilePhotoList($pcursor: String, $userId: String, $page: String, $webPageArea: String) {\n visionProfilePhotoList(pcursor: $pcursor, userId: $userId, page: $page, webPageArea: $webPageArea) {\n result\n llsid\n webPageArea\n feeds {\n type\n author {\n id\n name\n following\n headerUrl\n headerUrls {\n cdn\n url\n __typename\n }\n __typename\n }\n tags {\n type\n name\n __typename\n }\n photo {\n id\n duration\n caption\n likeCount\n realLikeCount\n coverUrl\n coverUrls {\n cdn\n url\n __typename\n }\n photoUrls {\n cdn\n url\n __typename\n }\n photoUrl\n liked\n timestamp\n expTag\n animatedCoverUrl\n stereoType\n videoRatio\n profileUserTopPhoto\n __typename\n }\n canAddComment\n currentPcursor\n llsid\n status\n __typename\n }\n hostName\n pcursor\n __typename\n }\n}\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78ecdf837c23f6ae6f1c52558bb21356/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e039414f0363ed46e2880606a101f2f/" rel="bookmark">
			ATL炒冷饭学习之三：CoInitialize/CoUninitialize
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CoInitialize
CoInitialize是Windows提供的API函数，用来告诉 Windows以单线程的方式创建com对象。应用程序调用com库函数（除CoGetMalloc和内存分配函数）之前必须初始化com库。
HRESULT CoInitialize(
_In_opt_ LPVOID pvReserved
);
参数被保留，且必须为NULL。
​
S_OK : 该线程中COM库初始化成功
S_FALSE: 该线程中COM库已经被初始化 CoInitialize () 标明以单线程方式创建。
使用 CoInitialize 创建可以使对象直接与线程连接，得到最高的性能。
CoInitialize并不装载COM 库，它只用来初始化当前线程使用什么样的套件。使用这个函数后，线程就和一个套件建立了对应关系。线程的套件模式决定了该线程如何调用COM对象，是否需要列集等。
CoInitialize ()并不会干扰客户和服务器之间的通信，它所做的事情是让线程注册一个套件，而线程运行过程中必然在此套件。
CoInitialize和CoUninitialize必须成对使用。
创建新的应用程序就调用CoInitializeEx代替CoInitialize。
二、CoUninitialize
CoUninitialize关闭当前线程的COM库,卸载线程加载的所有dll,释放任何其他的资源,关闭在线程上维护所有的RPC连接。
void CoUninitialize();
备注:
一个线程必须调用 CoUninitialize 一次在每次成功调用CoInitialize或CoInitializeEx。只有CoUninitialize对应于CoInitialize调用对应CoInitialize或CoInitializeEx调用他们初始化库能关闭它。
调用OleInitialize必须通过调用OleUninitialize平衡。OleUninitialize 函数调用的OleUninitialize内部,所以应用程序调用OleUninitialize不也需要调用CoUninitialize。
CoUninitialize应该在应用程序关闭后调用,作为最后一次调用COM库在应用程序主窗户隐藏,消息循环结束之后。如果有剩余的对话开着，CoUninitialize开始了模态消息循环和派发任何挂起的消息在容器或服务器里对于这个COM应用程序。通过派发信息,CoUninitialize 在确保应用程序等待所有它的消息接收之前不退出。Non-COM信息被丢弃。
因为没有办法控制顺序进程内服务器加载或卸载, 从DllMain函数中调用CoInitialize, CoInitializeEx,或者 CoUninitialize 是不安全的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbf0a8f0e31536042ca0a296cab03e89/" rel="bookmark">
			r语言报错|Error in plot.window(...) : ‘xlim‘值不能是无限的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		plot（）绘制图层时报错
错误提示：
Error in plot.window(...) : 'xlim'值不能是无限的
In addition: Warning messages:
1: In min(x) : no non-missing arguments to min; returning Inf
2: In max(x) : no non-missing arguments to max; returning -Inf
3: In min(x) : no non-missing arguments to min; returning Inf
4: In max(x) : no non-missing arguments to max; returning -Inf
原因：数据中含有空值
解决办法：
na.omit(数据名)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4981d9e68089a820a653473caf1ca05/" rel="bookmark">
			element ui 两个弹层 背景变灰色问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在第二个弹层里面加上:append-to-body=“true” 完美解决
&lt;el-dialog :visible.sync="dialogVisiblelistone" :append-to-body="true"&gt; &lt;img width="100%" :src="dialogImageUrlone" class="avatar" /&gt; &lt;/el-dialog&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/086a619d95a08692aee6e024de9574dc/" rel="bookmark">
			软件测试工程师必备技能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本技能
一、熟练使用SQL掌握常用的sql语句，如增删改查。了解数据库的事务，会编写存储过程，熟练常用的系统函数。了解并可以进行数据库的备份，迁移，还原，镜像等。
二、Linux
1.Linux是测试人员的基本功，不需要掌握太难或者很不常见的Linux命令，正常能做到查看日志，定位问题就可以了。
2.初级测试人员工作是经常遇到，发现bug，开发不承认或者不愿意解决的情况，测试人员怎么摆脱这样的问题呢？
根据发现的bug日志级别，来查看日志，定位问题，那这里首先要说一下日志级别。日志级别越高，输出的信息越少。
info：代码info信息，不包括sql语句等一些debug信息。 warning ：代码警告信息。 error : 程序本身报错信息 一般不符合需求的bug在debug中，程序本身报错的在error中。
三、测试用例
1.在测试中最重要的文档，他是测试工作的核心，是一组在测试时输入输出的标准，是软件需求的具体对照。编写测试用例，是测试人员的基本功，真正能写好的人并不多。
2.测试用例包含的内容：用例编号，用例标题，用例级别，前置条件，操作步骤，预期结果，实际结果。
3.当测试小伙伴拿到第一个需求文档的时候，进行分析，编写测试方案。提取测试点，编写测试用例，然后叫上开发，产品以及相关人员进行用例评审。
4.编写测试用例常用的方法：等价类划分法，边界值分析法，错误推断法，流程图法等。
四、了解业务
首先明确一点一定要了解业务，只有了解业务，才能把功能测试做好，并且会有一定的提高。
提升技能 一、web自动化测试
掌握Git的使用方式；
掌握Jenkins持续集成的环境配置；
熟练掌握Selenium；
能够熟练搭建Web自动化测试环境；
熟练掌握元素的定位方法和元素操作；
掌握鼠标键盘操作及HTML特殊元素的处理；
掌握使用UnitTest管理自动化测试的脚本
二、APP自动化测试
熟练掌握appium（其余与web相同）
三、接口测试
熟练使用postman/jmeter进行接口测试；
掌握fidder抓包工具
四、性能测试
熟悉JMeter性能测试的使用方法；
熟悉Loadrunner工作原理
更多软件测试相关知识重点关注微信公众号【软件测试大牛】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844dd4110f62674f9c7748f63c9d5215/" rel="bookmark">
			小明都可以买什么(JAVA基础案例教程第二章-课后作业)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写一个智能购物的小程序
商品名称价格书本12铅笔1橡皮2可乐3零食5 假如小明带了20元，且必须购买一本书，剩余的钱还可以购买那种商品，可以购买几件，购买完还剩余多少钱？
package com.xiaoming; import java.util.Scanner; public class Xiaoming { public static void main(String[] args) { Scanner sc=new Scanner(System.in); System.out.print("请输入需要购买商品:"); String x=sc.next(); //获取键盘输入 int money = 20; int book = 12; int pencil = 1; int eraer = 2; int coke = 3; int lingshi = 5; int shengyu = money-book; switch (x){ case "铅笔": System.out.println("可以买铅笔"+shengyu/pencil+"个剩余"+shengyu%pencil+"元"); break; case "橡皮": System.out.println("可以买橡皮"+shengyu/eraer+"个剩余"+shengyu%eraer+"元"); break; case "可乐": System.out.println("可以买可乐"+shengyu/coke+"个剩余"+shengyu%coke+"元"); break; case "零食": System.out.println("可以买零食"+shengyu/lingshi+"个剩余"+shengyu%lingshi+"元"); break; } } } 欢迎进群交流:937864538
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/844dd4110f62674f9c7748f63c9d5215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa599da37167de4740b2de6e87850c7/" rel="bookmark">
			VuePress基本用法与踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、VuePress是什么？三、环境搭建四、基础配置4.1 目录结构4.2 导航栏4.3 侧边栏4.4 自动生成侧边栏 五、自定义主题六、避坑指南6.1 侧边栏无法正常使用6.2 生成静态网页时出现解析错误6.3 部署站点无法使用相对路径6.4 预览或编译时内存溢出（OOM）6.5 页面刷新异常或点击前进/返回异常：6.6 生成静态网页时内存消耗过多 一、前言 近期由于工作需要，接触了一些静态网页生成器，选中了 VuePress，具体可以先看看：云文档托管方案分析。
二、VuePress是什么？ VuePress是尤雨溪尤大为了支持 Vue 及其子项目的文档需求而写的一个项目，VuePress界面十分简洁，并且非常容易上手，花少量时间就可以将项目架构搭好，具体效果可以看：VuePress的官方文档。
一个 VuePress 网站是一个由 Vue 、Vue Router 和 webpack 驱动的单页应用，其基于Vue实现，因此可以嵌入各种Vue组件来实现扩展功能。
三、环境搭建 环境要求：
Node.js &gt;= 8.6；
新建一个文件夹，如：mydocs；
新建 mydocs/package.json 文件，并安装 VuePress：
npm install -D vuepress 在 package.json 中加入以下脚本： { "scripts": { "docs:dev": "vuepress dev docs", "docs:build": "vuepress build docs", } } 在 mydocs 下新建 docs 目录，并新建 docs/README.md 文件，并在其中添加文本 “Hello VuePress!!!”；
执行以下命令预览效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa599da37167de4740b2de6e87850c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8851f9980668e125247f7f16f0995a79/" rel="bookmark">
			java 与(&amp;)、或(|)、异或(^)、按位取反(~)、左移（＜＜）、右移（＞＞）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以一个字节 8位做演算
a的2进制 00011100
b的2进制：00110111
int a = 28; int b = 55; a: 00011100
b: 00110111
一、按位与(&amp;)运算 全1为1 见0为0 a: 00011100
b: 00110111
a&amp;b: 00010100
二、按位或（|）运算 见1为1 全0为0
a: 00011100
b: 00110111
a|b: 00111111
三、异或(^) 不同为0 相同为1
a: 00011100
b: 00110111
a^b: 00101011
四、左移(&lt;&lt;) 左移 n 位
二进制左移 n位
相当于10进制乘2的n次方
a: 00011100
b: 00110111
a&lt;&lt;3: 11100000 10进制值：224 扩大 8倍
五、右移(&gt;&gt;)
右移 n 位
二进制右 n位
相当于10进制除2的n次方(每次除了之后若有小数都是取整数部分)
a: 00011100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8851f9980668e125247f7f16f0995a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d77b1566a05ef4788e5e7804f909c1/" rel="bookmark">
			2021黑盾杯CTF部分WP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 Signin 通过观察附件得到附件为一个文本 全由01组成
根据以往的经验来是这个应该是是通过PIL库将01转换为像素点来构造二维码
from PIL import Image MAX = 500 pic = Image.new("RGB", (MAX, MAX)) str="1111...1111" #文档太大所以省略了文档内容" i = 0 for y in range(0, MAX): for x in range(0, MAX): if str[i] == '1': pic.putpixel([x, y], (0, 0, 0)) else: pic.putpixel([x, y], (255, 255, 255)) i = i + 1 pic.show() pic.save("flag.png") 构造出这么一个二维码
这个二维码是不完整的缺少一个定位角但是无伤大雅有这么一个神奇的网站https://demo.dynamsoft.com/barcode-reader/
缺少一个定位角扫描对他来说都不是事（可惜了是个在线工具建议大家还是学一下咋补定位角）
扫描出来的结果就是这段就是flagflag{5E57527B60}
二、 日志分析 解压后得到一个access.log,用notepad++打开，尝试搜索password查看其中sql语句发现规律，看得出来他是尝试枚举进行暴力破解密码
一共十个字母，经过分析发现，状态码200后面的数字，跟前面的select语句有关系
675代表True，678代表False，所以可以看出，经过筛选后的ASCII码有十个相对应的字母，加上flag{}提交即可
三、 ICS-Modbus的秘密 解压后得到modbus的秘密.pcap用Wireshark打开根据提示直接找最长的modbus，flag就在里
四、 Decode 文本给了三组nec，常见题型，直接写脚本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8d77b1566a05ef4788e5e7804f909c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f9bb6988a19f08318599604d41ecea9/" rel="bookmark">
			Java并发编程的艺术(5-10)学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考学习Java并发编程的艺术
第5章 Java中的锁 5.1 Lock接口 synchronized没有的特性 尝试非阻塞获取锁能够中断获取锁超时获取锁 5.2 队列同步器 队列同步器AbstractQueuedSynchronizer用来构建锁，或者其它同步组件。用一个int成员变量表示同步状态。通过内置的FIFO队列完成资源获取线程的排队工作。同步器的实现主要是继承，同步器需要提供（getState()、setState(int newState)和compareAndSetState(int expect,int update)）方法来获取同步的状态。同步器支持独占或者是共享地获取锁。 5.2.1 队列同步器的接口与示例 同步器的实现基于模板方法。继承并重写。 模板方法包括3类，独占式的获取和释放同步状态，共享式的获取和释放同步状态，查询同步队列的等待状态线程情况。 通过独占锁来说明情况
独占锁只能一个线程获取锁。其它线程只能进入到同步队列。 import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.AbstractQueuedSynchronizer; import java.util.concurrent.locks.Condition; class Mutex implements Lock { // 静态内部类，自定义同步器 private static class Sync extends AbstractQueuedSynchronizer { // 是否处于占用状态 protected boolean isHeldExclusively() { return getState() == 1; } // 当状态为0的时候获取锁 public boolean tryAcquire(int acquires) { if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } // 释放锁，将状态设置为0 protected boolean tryRelease(int releases) { if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; } // 返回一个Condition，每个condition都包含了一个condition队列 Condition newCondition() { return new ConditionObject(); } } // 仅需要将操作代理到Sync上即可 private final Sync sync = new Sync(); public void lock() { sync.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f9bb6988a19f08318599604d41ecea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50aa96247b1f457e08aac0beb5062742/" rel="bookmark">
			解决IDEA控制台输出中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法一： 1.打开tomcat配置页面，Edit Configurations。
2.在配置项VM options文本框中输入-Dfile.encoding=UTF-8，
添加一条JAVA_TOOL_OPTIONS，
点击Apply，OK即可。
3.尝试重启Tomcat。
解决方法二： 1.打开idea本地安装目录中bin文件夹下的
idea.exe.vmoptions和
idea64.exe.vmoptions这两个文件。
2.分别在这两个文件内容的末尾添加-Dfile.encoding=UTF-8。
3.点击File–&gt;Settings–&gt;Editor&gt;File Encodings，
将三处设置成UTF-8，
点击Apply，OK。
4.重启idea。
解决方法三： 1.修改idea的vmoptions文件，
点击Help–&gt;Edit Custom VM Options，
在文本末尾加上：
-Dfile.encoding=UTF-8
-Dconsole.encoding=UTF-8
2.修改Tomcat的默认编码，
打开Tomcat安装目录下conf/service.xml文件，
给Connector节点加上配置URIEncoding=“UTF-8”，如下图所示。
3.重启idea。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b1f450998c461a9b9826f1c5e2ba57/" rel="bookmark">
			vscode的c/c&#43;&#43;环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： vscode的c/c++环境配置
解决方案： 参考大佬的教程：20秒 一键配置 VSCode (Visual Studio Code) C/C++开发环境
1.mingw的安装及环境变量的配置
2.vscode的c工程文件的相关配置
命令行编译运行c：
命令行编译c：
gcc test.c 默认会生成a.exe文件
也可以修改默认生成文件的名字 ：gcc test.c -o test.exe 注：-o是修改名称的参数
命令行运行c：
cmd窗口：a.exe或 .\a.exe
powshell窗口：.\a.exe 注：powshell窗口下不能直接运行a.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76dfeb9a84b3b35bf55fc9ecd785211f/" rel="bookmark">
			C&#43;&#43;11 - thread多线程编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 线程创建与结束 C++11 新标准中引入了四个头文件来支持多线程编程，他们分别是&lt;atomic&gt; ,&lt;thread&gt;,&lt;mutex&gt;,&lt;condition_variable&gt;和&lt;future&gt;。
&lt;atomic&gt;：该头文主要声明了两个类, std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。&lt;thread&gt;：该头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在该头文件中。&lt;mutex&gt;：该头文件主要声明了与互斥量(mutex)相关的类，包括 std::mutex 系列类，std::lock_guard, std::unique_lock, 以及其他的类型和函数。&lt;condition_variable&gt;：该头文件主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any。&lt;future&gt;：该头文件主要声明了 std::promise, std::package_task 两个 Provider 类，以及 std::future 和 std::shared_future 两个 Future 类，另外还有一些与之相关的类型和函数，std::async() 函数就声明在此头文件中。 #include &lt;iostream&gt; #include &lt;utility&gt; #include &lt;thread&gt; #include &lt;chrono&gt; #include &lt;functional&gt; #include &lt;atomic&gt; void f1(int n) { for (int i = 0; i &lt; 5; ++i) { std::cout &lt;&lt; "Thread " &lt;&lt; n &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76dfeb9a84b3b35bf55fc9ecd785211f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c28fb1465f7757814df4c215a37f59f/" rel="bookmark">
			Unity ScriptableObject 序列化遇到一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 序列化需要继承 ScriptableObject。 具体代码如下：
[Serializable] public struct ExcelItemData { public int ItemID; public string ItemPath; public int ItemColorID; } public class ExeclItemConfig : ScriptableObject { public ExcelItemData[] excelItemDatas; } 结构体标注[Serializable] 可以让这个脚本实例化到本地时，能够在属性面板看到数值信息。
2. 使用Editor脚本实例化
[MenuItem("LoadExcelData/LoadItemData")] static void LoadItemData() { ExcelItemInfo excelItemInfo = new ExcelItemInfo(GlobalData.Excel_ItemPath); ExeclItemConfig execlItemConfig = ScriptableObject.CreateInstance&lt;ExeclItemConfig&gt;(); execlItemConfig.excelItemDatas = excelItemInfo.Data; string SavePath = "Assets/Resources/" + ".asset"; Debug.Log(SavePath); AssetDatabase.CreateAsset(execlItemConfig, SavePath); AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); } 这里需要注意 保存路径需要从 AssetDatabase 保存资源 的路径需要从Assets开始
3. 读取方式 ExeclItemConfig execlItemConfig = Resources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c28fb1465f7757814df4c215a37f59f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa12d621ccf097cf92dbf662a3ae3170/" rel="bookmark">
			无法从 START_OBJECT 令牌反序列化 `java.util.ArrayList＜cn.wolfcode.domain.Product＞` 的实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错异常信息：Caused by: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize instance of `java.util.ArrayList&lt;cn.wolfcode.domain.Product&gt;` out of START_OBJECT token at [Source: (PushbackInputStream); line: 1, column: 1]
1.查看类型返回是否相同：在微服务场景下，看一下远程调用的方法和定义的Feign接口是否相同，返回类型不相同就会报该错；
我排查了很久，就突然发现我定义的远程调用的接口的返回值是List，但是在我的远程服务里的controller中的方法返回的是result&lt;List&lt;&gt;&gt;，然后我后来把返回值统一改成返回result，就可以了！！敲代码一定要有思路、条理、多细心观察代码之间是关联关系。
小白记录自己的bug生活！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/951217c051c3f7e0de4b4bb7ce7af1de/" rel="bookmark">
			navicate 15 连接oracle 11g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载，Version 19.9.0.0.0
instantclient-basic-XXX.zip
instantclient-sqlplus-XXX.zip
https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html
2、配置 工具-》选项
3、重启连接
如果是sys用户 的话，用户名是 sys as sysdba
来自：https://blog.csdn.net/yonghutwo/article/details/110193100
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8851ee1b44fa9fbbd0e4dde09568435b/" rel="bookmark">
			内网远程协助工具_分享几个常用的免费远程软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://blog.csdn.net/weixin_39806779/article/details/110962599
1、说到远程工具，首先我们想到的是影子(Radmin),外网需要映射端口，较不安全，内网远程无敌，界面如下图。
Radmin是收费的，我在网络收集了两个版本，出处我也忘了，反正使用了蛮久了，也挺正常，装完请自行修改端口和密码即可。
2、深蓝远程(Dbadmin)，无需做端口映射，也无需安装，给对方远程码即可，界面如图：
深蓝远程的作者前几天又更新了一次版本，现在已经升级到3.1版本了，需要的朋友可以自己去作者的官网下载。
深蓝远程 https://slsup.com/
3、向日葵远程，十年老品牌，功能强大，速度快，无需映射端口，可手机直接远程，方便快捷,下载完以绿色版运行，如图：
向日葵远程 https://sunlogin.oray.com/personal
4、TTVNC 老品牌，早期用户非常多，现在也很多远程功能都是集成的该模块，程序小巧绿色，发图：
TTVNC www.ttvnc.com
今天给大家推荐的免费远程协助软件就是这几个，第二、三、四个都可以去官网下载，如果需要Radmin软件的关注我的头条号，给我发私信，我会单独发送给您。
相关资源：局域网远程工具radmin_局域网远程工具,局域网内远程工具-其它工具…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e745ae3fc17967edcbfacb12f2903c78/" rel="bookmark">
			解决MobaXterm无法连接虚拟机问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决MobaXterm无法连接虚拟机问题 主问题 时间：2021.12.03
问题描述：升级centos内核后，使用MobaXterm连接虚拟机，出现连接失败的情况如下图：
问题根因：虚拟机 的 SSH 服务没有打开，MobaXterm无法与虚拟机进行通信。
解决方法：
1、更新源：sudo yum update
2、安装SSH：sudo yum install openssh-server
3、 启动SSH：/etc/init.d/ssh start
其他问题 时间：2021.12.03
问题描述：在解决主问题过程中，使用百度到的更新源命令时，百度到的更新源命令如下图：
运行此更新源命令，会出现如下图问题：
问题根因：命令使用错误，系统是centOS，需要用yum命令。
解决方法：直接替换apt-get即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54386d3f4a1a89b4022b90386c9ce42a/" rel="bookmark">
			配色基础入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配色基础入门 色相类似色补色相反色暖色冷色中性色无彩色有彩色明度彩度色调130色基调色，补充色，强调色配色技巧色相配色色调配色同类色配色对比色配色间隔配色类似色配色清色配色浊色配色 RGB 和 CMYK 色相 10类色相：红色，橙色，黄色，黄绿色，绿色，蓝绿色，蓝色，蓝紫色，紫色，紫红色
【10色相环】
类似色 某一色彩相邻的色相成为类似色，类似色为相邻，所以为两种，例如：红色，橙色
补色 相反位置的色相称为补色，颜色对面色
相反色 补色在内的与补色相邻的左右两个色，也就是五个色为相反色
暖色 红色，橙色，黄色
冷色 蓝色，蓝绿色
中性色 紫色，绿色
无彩色 白色，黑色，灰色等没有颜色色彩的颜色，也就是没有色相和彩度，只用明度表示
明度最高的事白色，明度最低的是黑色
有彩色 具备色相，彩度，明度三种颜色的属性
明度 明度是指色彩的明亮程度
明度高的色彩，给人明快，轻松，柔和的感觉
明度低的色彩，给人厚重，沉稳的感觉
彩度 色彩的鲜艳程度
彩度高的色彩，给人明快，华丽的感觉
彩度低的色彩，给人低调，朴素的感觉
色调 由明度和彩度组合起来表示色彩的色调。
色调分12个种类，4种类型【华丽2，朴素4，明亮3，沉暗3】
130色 色相10和色调12共分为120种有彩色+白色，黑色，灰色等10种无彩色，整合为130色
基调色，补充色，强调色 色彩搭配时，根据该色彩在配色中所占的面积比例命名为基调色【占面积最大】，补充色【其次】，强调色
配色思路：基调色与作为背景颜色统一，选择稍微改变“类似色”色调的颜色作为补充色，相反色和相反色调的颜色作为强调色，已突出强调效果
配色技巧 色相配色 色调配色 同类色配色 对比色配色 间隔配色 类似色配色 清色配色 浊色配色 RGB 和 CMYK RGB：电视机和电脑的显示器等输出装置由红色Red，绿色Green，蓝色Blue
CMYK：印刷品是由青色Cyan，洋红Magenta，黄色Yellow和黑色Black，进行组合表现色彩
青色Cyan：蓝色和绿色组成
洋红Magenta：红色和蓝色组成
黄色Yellow：红色和绿色组成
而由RGB的颜色模式制作的色彩可以用CMYK转换出来
所以在电脑显示器等数字化工具进行输出的时候，应该使用RGB模式
但是如果是印刷，则需要将RGB模式转为CMYK模式，调整数值【软件自动调整也可以】，使印刷色彩更接近屏幕显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1392a3c4d0ed9b8af0e6b34d2750cf17/" rel="bookmark">
			Prometheus_Grafana
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.Prometheus简介2.Prometheus优势1.易于管理2.监控服务的内部运行状态3.强大的数据模型4.强大的查询语言PromQL5.高效6.可扩展7.易于集成8.可视化9.开放性 Prometheus架构3.安装安装Prometheus安装Pushgateway安装node_exporter安装alertmanager 4.启动5.PromSQL1.瞬时时间2.时间范围3.时间位移操作4.聚合操作5.标量与字符串 6.Prometheus和grafana 1.Prometheus简介 Prometheus受启发于Google的Brogmon监控系统（相似的Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师在Soundcloud以开源软件的形式进行研发，并且于2015年早期对外发布早期版本。2016年5月继Kubernetes之后成为第二个正式加入CNCF基金会的项目，同年6月正式发布1.0版本。2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合。
2.Prometheus优势 1.易于管理 Prometheus核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。
Prometheus基于Pull模型的架构方式，可以在任何地方（本地电脑，开发环境，测试环境）搭建我们的监控系统。对于一些复杂的情况，还可以使用Prometheus服务发现(Service Discovery)的能力动态管理监控目标。
2.监控服务的内部运行状态 Pometheus鼓励用户监控服务的内部状态，基于Prometheus丰富的Client库，用户可以轻松的在应用程序中添加对Prometheus的支持，从而让用户可以获取服务和应用内部真正的运行状态。
3.强大的数据模型 所有采集的监控数据均以指标(metric)的形式保存在内置的时间序列数据库当中(TSDB)。所有的样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。
每一条时间序列由指标名称(Metrics Name)以及一组标签(Labels)唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。
表示维度的标签可能来源于你的监控对象的状态，比如code=404或者content_path=/api/path。也可能来源于的你的环境定义，比如environment=produment。基于这些Labels我们可以方便地对监控数据进行聚合，过滤，裁剪。
4.强大的查询语言PromQL Prometheus内置了一个强大的数据查询语言PromQL。 通过PromQL可以实现对监控数据的查询、聚合。同时PromQL也被应用于数据可视化(如Grafana)以及告警当中。
通过PromQL可以轻松回答类似于以下问题：
在过去一段时间中95%应用延迟时间的分布范围？预测在4小时后，磁盘空间占用大致会是什么情况？CPU占用率前5位的服务有哪些？(过滤) 5.高效 对于监控系统而言，大量的监控任务必然导致有大量的数据产生。而Prometheus可以高效地处理这些数据，对于单一Prometheus Server实例而言它可以处理：
数以百万的监控指标每秒处理数十万的数据点。 6.可扩展 Prometheus是如此简单，因此你可以在每个数据中心、每个团队运行独立的Prometheus Sevrer。Prometheus对于联邦集群的支持，可以让多个Prometheus实例产生一个逻辑集群，当单实例Prometheus Server处理的任务量过大时，通过使用功能分区(sharding)+联邦集群(federation)可以对其进行扩展。
7.易于集成 使用Prometheus可以快速搭建监控服务，并且可以非常方便地在应用程序中进行集成。目前支持： Java， JMX， Python， Go，Ruby， .Net， Node.js等等语言的客户端SDK，基于这些SDK可以快速让应用程序纳入到Prometheus的监控当中，或者开发自己的监控数据收集程序。同时这些客户端收集的监控数据，不仅仅支持Prometheus，还能支持Graphite这些其他的监控工具。
同时Prometheus还支持与其他的监控系统进行集成：Graphite， Statsd， Collected， Scollector， muini， Nagios等。
Prometheus社区还提供了大量第三方实现的监控数据采集支持：JMX， CloudWatch， EC2， MySQL， PostgresSQL， Haskell， Bash， SNMP， Consul， Haproxy， Mesos， Bind， CouchDB， Django， Memcached， RabbitMQ， Redis， RethinkDB， Rsyslog等等。
8.可视化 Prometheus Server中自带了一个Prometheus UI，通过这个UI可以方便地直接对数据进行查询，并且支持直接以图形化的形式展示数据。同时Prometheus还提供了一个独立的基于Ruby On Rails的Dashboard解决方案Promdash。最新的Grafana可视化工具也已经提供了完整的Prometheus支持，基于Grafana可以创建更加精美的监控图标。基于Prometheus提供的API还可以实现自己的监控可视化UI。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1392a3c4d0ed9b8af0e6b34d2750cf17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc07e8afdecd44c5383fb5c65803b4b/" rel="bookmark">
			【redis集群】Node xxx is not empty 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[root@localhost redis-6.2.4]# redis-cli --cluster create --cluster-replicas 1 192.168.136.160:7001 192.168.136.160:7002 192.168.136.160:7003 192.168.136.160:8001 192.168.136.160:8002 192.168.136.160:8003 [ERR] Node 192.168.136.160:8001 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0. 今天创建redis集群 胡搞乱搞 一会创建哨兵 一会搞主从 又删除之前的 搞分片,后来出问题了
1.重置对应端口的节点 redis-cli -p 8001 cluster reset
2. 然后重新执行创建集群命令
redis-cli --cluster create --cluster-replicas 1 192.168.136.160:7001 192.168.136.160:7002 192.168.136.160:7003 192.168.136.160:8001 192.168.136.160:8002 192.168.136.160:8003
3.
今天在redis中执行192.168.136.160:7003&gt; set a 1
(error) MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc07e8afdecd44c5383fb5c65803b4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0188d028d82e555a99b4a7de15779ce9/" rel="bookmark">
			记录:@JSONField和@JsonProperty和@ApiModelProperty一起使用，swagger显示不正常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@JSONField(name = "C-API-Status") @JsonProperty("C-API-Status") @ApiModelProperty(value = "响应码") private String CApiStatus; @JSONField(name = "C-Response-Code") @JsonProperty("C-Response-Code") @ApiModelProperty(value = "888888") private String CResponseCode; @JSONField(name = "C-Response-Desc") @JsonProperty("C-Response-Desc") @ApiModelProperty(value = "响应信息") private String CResponseDesc; @JSONField(name = "C-Response-Body") @JsonProperty("C-Response-Body") @ApiModelProperty(value = "响应数据") private String CResponseBody; 按理而言，应该不会有问题，结果打开，显示如下:
一看，什么鬼？查阅资料，得知：
jackson2对POJO类型(没有遵循特定的java对象模型，约定或者框架的对象)序列化处理流程：
Jackson2在初始化序列器时，在收集POJO类型对象的属性信息，属性包括成员变量及方法时，会将属性名称和处理后的方法名称作为key保存到LinkedHashMap中。收集过程当中会调用com.fasterxml.jackson.databind.util.BeanUtil中的legacyManglePropertyName方法用来处理方法名称，它会将get/set方法前缀，即get或set去掉，并将其后面的连续大写字符转换成小写字符返回。例如: getCApiStatus会转变成capistatus返回。
所以，jackson2对POJO类型进行处理，因为名称不冲突能够同时存在HashMap中。收集完属性信息后，后续步骤中会删除掉非可见的属性（私有成员变量），swagger中就不会显示，但因为@JsonProperty注释，Jackson2会认为这个属性是可见的，不会删除，这时这两个表示同一个值的属性就会被一同序列化。
知道了原因，修改起来就方便了，结合以上知识点:
1.jackson默认序列化时只去get和set方法的字段，私有字段不参与序列化。
2.@JsonProperty 注解在私有属性上，标明该私有字段在序列化时可见，另外能够指定序列化的名称。
解决办法：
@JsonProperty 标注在get set方法上（get set方法手写）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d96e922901bc61db50f7274552e6942f/" rel="bookmark">
			编写一个实现串的置换操作Replace(&amp;S,T,V)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串的置换操作 用串v置换出 串s中与t相同的所有非空串 /* 编写一个实现串的置换操作Replace(&amp;S,T,V). */ #include &lt;stdio.h&gt; //获取串长度 int get_stringSize(char *p); //打印 void print_string(char *p); // 串的置换操作 用串v置换出 串s中与t相同的所有非空串 void replace(char s[],char t[],char v[]) { int len_v = get_stringSize(v); int len_t = get_stringSize(t); int len_s = get_stringSize(s); if(len_s &lt; len_t || len_v == 0 || len_t == 0 || len_s == 0)//串不能为空,且子串 不能比主串长 { printf("替换失败,串不符合规定!!!\n"); return; } int i = 0,j = 0; for(i = 0;s[i] != '\0';i ++) { for(j = 0;t[j] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d96e922901bc61db50f7274552e6942f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d479f165ffee158dab4324e26bf61c/" rel="bookmark">
			VS生成自己的DLL并调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、生成dll
二、调用dll
三、从dll中导出函数的define
四、dll解读
一、生成dll 新建空项目，然后在属性里更改这两个地方
代码如下：
fun.h
//fun.h #pragma once #include&lt;iostream&gt; //定义导出函数，DLLEXAMPLE_EXPORT_API在函数类型前，若是类，则在class和类名之间 #define DLLEXAMPLE_EXPORT_API __declspec(dllexport) DLLEXAMPLE_EXPORT_API int add(int a, int b); fun.cpp
#include"fun.h" DLLEXAMPLE_EXPORT_API int add(int a, int b) { return a + b; } 然后选择生成项目，此时会生成一个dll和一个lib，lib说明函数具体位置，dll说明函数具体内容
二、调用dll 新建空白项目，直接使用dll的头文件，并添加一个cpp源文件，直接使用头文件里面的函数即可，因为dll项目里面已经定义了可以在外部项目，通过dll调用函数
main.cpp #include"fun.h" #pragma comment(lib, "dll.lib") int main() { std::cout &lt;&lt; "输出a+b=" &lt;&lt; add(9, 6) &lt;&lt; std::endl; return 0; } 运行此项目时，必须把dll和lib复制到源码所在的路径下 三、从dll中导出函数的define #define MYDLL2_API __declspec(dllexport) #else #define MYDLL2_API __declspec(dllimport) #endif 可以使用这个更为全面，可以从dll导入导出函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d479f165ffee158dab4324e26bf61c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f784e4fbf1ae2d83f0d7a66a229bf5/" rel="bookmark">
			Charles抓包使用及常用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Charles其实是一款代理服务器，通过成为电脑或者浏览器的代理，然后截取请求和请求结果达到分析抓包的目的。该软件是用Java写的，能够在Windows，Mac，Linux上使用，安装Charles的时候要先装好Java环境。
Charles是在 常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 HTTP协议。
Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。（可以自行网上查找破解版软件）
Charles 主要的功能包括：
截取 Http 和 Https 网络封包。
支持重发网络请求，方便后端调试。
支持修改网络请求参数。
支持网络请求的截获并动态修改。
支持模拟慢速网络。
1. Charles安装
前提先安装配置好Java环境，官网下载安装Charles:https://www.charlesproxy.com/download/
2. HTTP抓包
（1）查看电脑IP地址
方法一： 打开”运行”（快捷键：win+R键；或者在任务栏的”搜索”按钮中查找并点击”运行”），输入“cmd”后进入命令行窗口，在命令行窗口中输入”ipconfig”命令查看IP 方法二： 在charles中查看 ：Help -&gt; Local IP Address
（2）Charles代理设置
接下来打开Charles的代理设置：Proxy-&gt;Proxy Settings，设置一下端口号，默认的是8888，这个只要不和其他程序的冲突即可,并且勾选Enable transparent HTTP proxying。
（3）在手机设备、模拟器或者远程浏览器上设置代理，抓取手机设备上的请求包（手机和电脑必须在同一个局域网内，并关闭电脑防火墙、其他代理或者翻墙软件）
第一步：在手机wifi 上设置代理 -&gt; 长按无线网络--&gt;修改网络--&gt;高级选项--&gt;代理 手动--&gt;手动输入输入IP、端口号
服务器IP：PC机器的IP（通过之前介绍的查看IP的方法）
端口号：8888（通过之前介绍的查看端口的方法） 第二步：Charles弹出询问“allow”或者“deny”,点击“allow”按钮允许；出现手机的HTTP请求列表
安装证书
第三步：抓取https数据需要在手机上安装证书，HTTPS的抓包需要在HTTP抓包基础上再进行设置
如果我们需要在iOS或Android机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。
设置前抓包HTTPS接口显示unknown（图左），设置后接口正常展示，如下图右
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9f784e4fbf1ae2d83f0d7a66a229bf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14085679cb3958e35fd7560805c59f0a/" rel="bookmark">
			Impala入门操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Impala简介 用于处理存储在Hadoop集群中的大量数据的大规模并行处理SQL查询引擎，高性能低延迟
底层基于C++编写
优点
执行数据处理时，不需要对存储在Hadoop上的数据进行转换或移动
可以用传统的SQL处理数据
使用Rarquet文件格式
缺点
不提供对序列化和反序列化的支持
只能读取文本文件，不能读取自定义二进制文件
架构 Impala daemon
即所谓的impalad，是运行在集群每个节点的守护进程，主要负责读写数据，接受其他接口的查询请求，并于其他节点分布式并行工作，将本节点的查询结果返回给中心协调点。
Impala Statestore
用于检查集群中impalad节点的健康情况，保证不将请求放给不可用的节点上
对集群各节点进行信息同步，相当于监控功能
Impala Catalog Serveice
即catalogd，当impala集群中执行的SQL语句会引起元数据变化时，catalog服务会将这些变化推送到其他的impalad进程节点上
一般将statestore和catalog放在一个节点上
查询处理接口
Impala-shell：命令行
Hue：浏览器
ODBC/JDBC驱动程序
语句命令 数据库命令
-- 创建数据库 creat database if not exisis my_database; ​ -- 选择数据库 use my_database; ​ -- 删除数据库 drop database is exsis my_database; ​ 表命令
基础增删改查
-- 新建表 create table if not exists my_database.my_table(col1 type2, col2 type2); create table my_table_copy as selet * from my_table; ​ -- 插入数据（追加） insert into my_table value (v1, v2); ​ -- 插入数据（覆盖） insert overwrite my_table value (v1, v2); ​ -- 获取数据 select col1, col2 from my_table; ​ -- 查看描述 describe my_table; ​ -- 改名表 alter table my_table rename to table_new; ​ -- 插入列 alter table my_table add columns (col3 type3, col4 type4); ​ -- 删除列,column可加可不加 alter table my_table drop [column] col4; ​ -- 更改column的数据类型和名称 alter table my_table change col3 col4 type4; ​ -- 删除表, drop为删除整个表，truncate为删除表数据 drop table if exists table_copy; truncate table if exists table_copy; ​ -- 显示数据库中的所有表 use my_database; show tables; ​ -- 创建视图，视图和临时表类似，但是他不是物理表而是虚拟表，主要是方便查询，同时可以不改变原表的结构 create view if not exists table_view as select col1, col2 from my_table; ​ -- 更改视图 alter view table_view as select col1, col3 from my_table; ​ -- 删除视图 drop view table_view; 其他基础操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14085679cb3958e35fd7560805c59f0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67db93423d6f8e1eed94932693b9218b/" rel="bookmark">
			软考过了，可以评职称吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在拿到软考证书后，很多人最关心的一个问题就是关于职称评聘问题，今天开锐教育小编就以软考证书如何申请评中级职称及职称申请流程的详细介绍，希望可以帮到大家。
所谓职称其实是一个专业技术职务，每个单位根据上级单位要求设置相应比例的高、中、初级专业技术岗位，比如2:5:3比例。根据总人数控制你们单位高、中、初级专业技术人员名额。如果你单位有空余岗位，你又有相应专业技术资格证书，且符合相应专业技术人员要求，就可以申请。
软考，是以考代评，以一个考试来代替提交若干材料的评职称的过程。国人部发[2003]39号文件，第11条明确如此规定：计算机专业技术资格(水平)实施全国统一考试后，不再进行计算机技术与软件相应专业和级别的专业技术职务任职资格评审工作。
但是评聘是分开的，就是指评审或考试后取得专业技术资格证书(职称证书)，也需要你们单位聘任你才可以享受相应职称工资待遇，担任相应专业技术职位。国人部发[2003]39号文件，第10条又规定：用人单位可根据《工程技术人员职务试行条例》有关规定和工作需要，从获得计算机专业技术资格(水平)证书的人员中择优聘任相应专业技术职务。也就是说，你拿到系统集成项目管理工程师的证书后，相当于具备的中级职称的能力水平。至于单位是否聘你为相应的职务和相应的待遇，就需要看单位的具体情况。
有的人问到评职称还需要考职称英语的情况，因为系统集成项目管理工程师的考试中涵盖了英语考试。而国家人事部早在96年就有规定，如参加全国统一组织的以考代评专业技术资格考试，如有英语内容，可以不用参加英语职称考试，由各聘任单位(也就是你们自己单位)自行决定。
事业单位如何评聘职称？事业单位评聘职称，执行的哪个文件？执行的是1986年4月16日中央职称改革工作领导小组发布的《工程技术人员职务试行条例》。本条例的第24条，明确规定：本条例适用于国家机关、事业单位。事业单位必须按照这个规定来！而事业单位想评聘职称，那就必须是干部身份！
那对于如何申报的情况，如果你是正式单位的职工，你的职称是由单位向本地职称办申报的。你要先看自己从事的职业类型可以评哪种职称，然后再去问本单位的人事部门自己何时可以评职称，给职工报评职称是人事部门的职责，所以你不用害怕什么。你直接告诉人家自己是什么专业的，现在做什么工作，干人事的都懂这个，就会告诉你要评哪种职称，何时给你申报，你要提交的材料有哪些。
可能有的小伙伴还是晕，下面我们再聊聊软考、职称资格、职称之间的关系，以及软考在2017年证书重印之后的变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596f5ebe41175ca4254c4ba6af13f986/" rel="bookmark">
			反转列表-递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public ListNode reverseList(ListNode head) { //返回原链表的尾节点，每次递归都返回这个节点 if (head == null || head.next == null) { return head; } ListNode p = reverseList(head.next); //形成环 head.next.next = head; //断开环 head.next = null; return p; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f70b9f9017573a2793ff3ca5ef2ba85/" rel="bookmark">
			java循环栅栏CyclicBarrier 使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. CyclicBarrier 是什么？ 从字面上的意思可以知道，这个类的中文意思是“循环栅栏”。大概的意思就是一个可循环利用的屏障。
它的作用就是会让所有线程都等待完成后才会继续下一步行动。
举个例子，就像生活中我们会约朋友们到某个餐厅一起吃饭，有些朋友可能会早到，有些朋友可能会晚到，但是这个餐厅规定必须等到所有人到齐之后才会让我们进去。这里的朋友们就是各个线程，餐厅就是 CyclicBarrier。
2. 怎么使用 CyclicBarrier 构造方法 public CyclicBarrier(int parties) public CyclicBarrier(int parties, Runnable barrierAction) 解析：
parties 是参与线程的个数第二个构造方法有一个 Runnable 参数，这个参数的意思是最后一个到达线程要做的任务 重要方法 public int await() throws InterruptedException, BrokenBarrierException public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException 解析：
线程调用 await() 表示自己已经到达栅栏BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时 3.基本使用 一个线程组的线程需要等待所有线程完成任务后再继续执行下一次任务
public class CyclicBarrierDemo { static class TaskThread extends Thread { CyclicBarrier barrier; public TaskThread(CyclicBarrier barrier) { this.barrier = barrier; } @Override public void run() { try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f70b9f9017573a2793ff3ca5ef2ba85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce048a7fab3138bc97864524dad6b00c/" rel="bookmark">
			MyBatis-Plus的 Insert 插入数据后直接获取实体类ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是实体类
package com.feng.dao.pojo; import lombok.Data; /** * Article文章表 */ @Data public class Article { private Long id; // 标题 private String title; //简介 private String summary; } 这个时候我们假设在业务层模拟插入一条数据
@Service public class ArticleServiceImpl implements ArticleService { @Autowired private ArticleMapper articleMapper; public void add(){ Article article = new Article(); article.setTitle("你好！"); article.setSummary("你好！"); //我们这个时候是没有设置id的，由MP默认直接生成 articleMapper.insert(article); //但是这里没有进行查询，可以直接获取插入实体类的id System.out.println(article.getId()); //结果是 1466227475858649089 } } 上面这个我们没有显式设置主键的生成策略，默认是雪花算法生成的，我们并没有查询获取，为啥可以直接get()获取到呢？
原因
官方解释：会自动回填 set 实体的 id 字段
简化了我们的查询操作，更加快捷高效！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9ecded6041f74d3059b5559bc07db9/" rel="bookmark">
			Xcode模拟器上安装.app的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xcode模拟器上安装app的方法 (.app) 背景：
因为项目中有用到es6的语法，导致前端页面在低版本系统的ios手机上显示白屏。我这ios11.1系统就开始显示白屏了，由于公司没有这个系统的测试机，只能用 Xcode 模拟机了。
注意:
在Xcode 上的模拟机上安装应用，安装的包不是安卓包(以 .apk 为扩展名的)，也不是ios的包( 以.ipa 为扩展名的)。而是开发人员的debug 安装包(以 .app 为扩展名的)
我是找ios开发人员要的，安卓不知道有没有这个.app的包。（由于代码保密原则，ios开发人员不能在我电脑上跑ios代码，所以只能这样做了 😅😅😅😅😅😅）
如下图：
实现步骤 在Xcode 上安装模拟机的方法
打开下载好的模拟机Xcode 提供了一个 simctl 命令，可以对模拟器做各种操作。
simctl 命令的路径是： /Applications/Xcode.app/Contents/Developer/usr/bin/simctl 进入simctl所在的usr路径下
cd /Applications/Xcode.app/Contents/Developer/usr 找到ios开发人员给你的.app的包的目录 ， 比如我的.app是放在 /Users/xiaoming/Downloads下 然后在终端执行一下指令：
bin/simctl install booted /Users/xiaoming/Downloads/test.app/ 执行完成之后，你会在模拟器上看到安装的应用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40014f943afa133a9e1ab173c01546b5/" rel="bookmark">
			每天五分钟玩转K8S（八）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来了解一下数据持久化的问题。
一、volume 本节我们讨论Kubernetes的存储模型Volume， 学习如何将各种持久化存储映射到容器。
我们经常会说： 容器和Pod是短暂的。 其含义是它们的生命周期可能很短， 会被频繁地销毁和创建。 容器销毁时， 保存在容器内部 文件系统中的数据都会被清除。
为了持久化保存容器的数据， 可以使用Kubernetes Volume。
Volume的生命周期独立于容器， Pod中的容器可能被销毁和重建， 但Volume会被保留。
本质上， Kubernetes Volume是一个目录， 这一点与Docker Volume类似。 当Volume被mount到Pod， Pod中的所有容器都可以访问这个Volume。 Kubernetes Volume也支持多种backend类型， 包括emptyDir、 hostPath、 GCE Persistent Disk、 AWS Elastic Block Store、NFS、 Ceph等。
1.emptyDir
emptyDir Volume对于容器来说是持久的，对于Pod则不是。当Pod从节点删除时， Volume的内容也会被删除。但如果只是容器被销毁而Pod还在， 则Volume不受影响。也就是说： emptyDir Volume的生命周期与Pod一致。
模拟一下producer-consumer场景，它们共享了一个Volume，producer负责写，consumer负责读。
文件最底部volumes定义了一个emptyDir类型的Volume shared-volume。producer容器将shared-volume mount到/producer_dir目录。producer通过echo将数据写到文件hello里。consumer容器将shared-volume mount到/consumer_dir目录。consumer通过cat从文件hello读数据。mountPath指在容器中的挂载点
实现在share-volume读写数据的效果
在node1上查询容器的名字
分别查询它们的mount
k8s_consumer_producer-consumer_default_425531ec-7f6c-4764-a99a-00732692e2e6_0
k8s_producer_producer-consumer_default_425531ec-7f6c-4764-a99a-00732692e2e6_0
果然是挂载同一个目录下。 emptyDir是Host上创建的临时目录， 其优点是能够方便地为Pod中的容器提供共享存储， 不需要额外的配置。 它不具备持久性， 如果Pod不存在了， emptyDir也就没有了。 根据这个特性， emptyDir特别适合Pod中的容器需要临时共享存储空间的场景， 比如前面的生产者消费者用例。
二、hostPath hostPath Volume的作用是将Docker Host文件系统中已经存在的目录mount给Pod的容器。 大部分应用都不会使用hostPath Volume， 因为这实际上增加了Pod与节点的耦合， 限制了Pod的使用。 不过那些需要访问Kubernetes或Docker内部数据（配置文件和二进制库） 的应用则需要使用hostPath。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40014f943afa133a9e1ab173c01546b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b26b2956ccc07d2fc8a403d3deea6e/" rel="bookmark">
			操作系统Ucore:Lab1QA(五)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来回答一下Lab1的问题
Ucore lab1 系列
操作系统实验Ucore:Bootasm启动(一)
操作系统实验Ucore:bootmain(二)
操作系统实验Ucore:kernel_init（三）
操作系统实验Ucore:Kernel_init(四)
操作系统Ucore:Lab1QA(五)
练习1：理解通过make生成执行文件的过程。 1.1操作系统镜像文件ucore.img是如何一步一步生成的？
ucore.img由kernel的bootblock组成，bootblock由bootasm和bootmain编译生成，最后由sign.c填充。kernel则由kern目录下的文件编译而成。
最后使用dd命令构造ucore.img
1.2一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？
最后两个字节是0x55AA
练习2：使用qemu执行并调试lab1中的软件。 跳过
练习3：分析bootloader进入保护模式的过程。 3.1为何开启A20，以及如何开启A20
在8086中，虽然只有20位的总线，但是实际最大的CS：IP是FFFF：FFFF = 10 FFEF 已经超出了1MB的限制，所以如果地址超出了20位，就会发生回滚。也就是 FFFFF + 1 = 00000，在8086下，第20位地址线总是为0的，如果不使能A20，就只能访问奇数MB的内存。
如何开启A20？和特定的端口交互
3.2如何初始化GDT表
使用ldgt指令把内存里的GDT表装上，然后手动设置段寄存器，最后ljmp刷新CS寄存器
3.3如何使能和进入保护模式
使能CR0的PE位
练习4：分析bootloader加载ELF格式的OS的过程。 bootloader把ELF文件加载到内存的0x1_0000位置然后再将ELF的数据段和代码段加载到0x10_0000位置，最后跳转到此处，开始执行内核代码
练习5，6 在前面的文章里已经分析过了，略
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c407a09a411c0e3c40eed184cc430bf/" rel="bookmark">
			HALCON类型 未将对象引用设置到对象的实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HALCON多层调用可能导致无法序列化的类型：
HTuple
先压缩后序列化 序列化方法：
public bool Save(string fileName) { //保存对象到文本文件中(序列化) FileStream fs = new FileStream(fileName, FileMode.Create); MemoryStream fs1 = new MemoryStream(); try { //创建二进制格式化器 BinaryFormatter bf = new BinaryFormatter(); //调用序列化方法 bf.Serialize(fs1, this); byte[] buffer = fs1.ToArray(); GZipStream ComStream = new GZipStream(fs, CompressionMode.Compress, true); ComStream.Write(buffer, 0, buffer.Length); ComStream.Close(); return true; } catch (Exception e) { return false; } finally { //关闭数据流 fs.Close(); fs1.Close(); } } 导致未将对象引用设置到对象的实例错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255e27271fc2faef16937c0304edcb8d/" rel="bookmark">
			每天五分钟玩转K8S（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天要了解的是k8s的rolling update（滚动更新）。
一、了解一下滚动更新的操作 先创建一个httpd:2.2.31的deployment，然后更新到2.2.32
yml文件如下
看到images的信息是2.2.31
现在将yml文件改成2.2.32版本
看到已经开始更新，特点是每次只更新替换一个pod，保证deployment的健壮性
通过查询kubectl describe deployment httpd2可以完整地看到整个scale up/down过程
（可以很清楚的看到数量的变化）
其中，k8s提供了参数来控制每次替换的pod数量，maxSurge和maxUnavailable。
二、探索回滚的过程 我们先分别执行三次不同版本的httpd的deployment
记得加上–record
镜像分别是16.17.18
通过kubectl rollout history deployment httpd2查询到历史版本
部署完毕，现在的版本如下：
可以通过
kubectl rollout undo deployment httpd2 --to-revision=1 来进行版本回退，效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb3a8ddb23a539fc36c89c447d6888b/" rel="bookmark">
			Arduino方式开发ESP32笔记：使用Preferences保存数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文大部分参考使用Arduino开发ESP32（18）：使用Preferences保存数据
引出 在其他单片机上我们可以使用单片机自带Flash来保存一些数据，在ESP32上也可以这样，在ESP32的Flash上存在一个叫做nvs的分区，使用Arduino方式来开发的话，可以直接使用Preferences库来操作它。
大小 Arduino core for the ESP32中默认分区（ Partition Scheme: “Default 4MB with spiffs (1.2MB APP /1.5MB SPIFFS)” ）情况下nvs分区的大小为 20480 字节，实际可存放的数据大小要小于这个值（ 单个数据来说最大为496K或者97%的nvs分区大小 ）。
组织关系 Preferences中数据以键值对（key - value）的方式存储。
在键值对之上还有一层命名空间（namespace），不同命名空间中可以有相同的键名存在。在Preferences中命名空间和键名均为字符串，并且长度不大于15个字节。
命名空间和键名的关系，可以理解为结构体名和内部元素的关系。
使用演示 基础读写 #include &lt;Preferences.h&gt; void setup() { Serial.begin(115200); Serial.println(); delay(2000); Preferences prefs; // 声明Preferences对象 prefs.begin("mynamespace"); // 打开命名空间mynamespace uint32_t count = prefs.getUInt("count", 0); // 获取当前命名空间中的键名为"count"的值 // 如果没有该元素则返回默认值0 count++; // 累加计数 Serial.printf("这是系统第 %u 次启动\n", count); prefs.putUInt("count", count); // 将数据保存到当前命名空间的"count"键中 prefs.end(); // 关闭当前命名空间 delay(5000); ESP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbb3a8ddb23a539fc36c89c447d6888b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab3a96c244b2e4e53f128238ec69fe3/" rel="bookmark">
			MATLAB 成绩排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 已知成绩表形成一个矩阵A，第1列为学号，第2列~第4列分别为数学、语文、英语成绩
现要求完成统计，按指定的排列方式进行输出。
输入1，对应数学降序输出
输入2，对应语文降序输出
输入3，对应英语降序输出
输入4，对应总分降序输出
A矩阵为：
1700201 98 86 83
1700202 85 90 78
1700203 92 78 95
1700204 88 88 85
1700205 78 95 88
输入 一行整数，表述按某种方式排序输出
输出 一个排列完成的矩阵
样例输入 Copy 1 样例输出 Copy 1700201 98 86 83 267 1700203 92 78 95 265 1700204 88 88 85 261 1700202 85 90 78 253 1700205 78 95 88 261 程序代码 A = [1700201, 98, 86, 83; 1700202, 85, 90, 78; 1700203, 92, 78, 95; 1700204, 88, 88, 85; 1700205, 78, 95, 88]; A = [A, sum(A(:,2:4), 2)]; n = input(''); switch n case 1 [~,I]=sort(-A(:,2)); A = A(I,:); case 2 [~,I]=sort(-A(:,3)); A = A(I,:); case 3 [~,I]=sort(-A(:,4)); A = A(I,:); case 4 [~,I]=sort(-A(:,5)); A = A(I,:); end disp(num2str(A)); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b694d8416d8d33d53af5746eeddf4646/" rel="bookmark">
			浮点数精度丢失分析及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java语言在处理浮点数，其实现逻辑与整数不同，如果使用不当可能会造成精度丢失、计算不准确、死循环等问题，严重的话，会造成经济损失。本文将从浮点数精度丢失入手，详细介绍下浮点数的原理及使用。
为什么会出现精度丢失 计算机使用二进制存储数据，由于二进制自身局限性，导致其无法精确的表示所有小数。而浮点数是由整数部分和小数部分组成，这也就意味着，计算机无法精确表示浮点数。也即，在计算机中，浮点数存在精度丢失的问题。这里将以十进制小数转为二进制数为例，介绍下为何二进制无法精确表示小数。
十进制小数转换成二进制小数采用"乘2取整，顺序排列"的做法。基本思想如下：用二乘以当前十进制小数，然后将乘积的整数部分取出，如果乘积中的小数部分为零或者达到所要求的精度则停止计算。否则再用二乘以余下的小数部分，又得到一个乘积，再将积的整数部分取出，如此进行。完成计算后，把每次执行取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。这里介绍下如何把十进制小数0.8125转换为二进制小数。
当然，也存在无法准确适用二进制表示的小数。如十进制小数0.7。
对于无法用二进制表示的小数，只能根据精度近似的表示。
浮点数底层存储实现 与整数存储数值不同，浮点数在计算机的存储时，会拆分成是三个部分：符号位、指数位、尾数位。其抽象公式是：
( − 1 ) S ∗ ( 1. M . . . ) ∗ 2 E (-1)^S*(1.M...)*2^E (−1)S∗(1.M...)∗2E
其中， S S S表示符号(正数、负数)、E表示指数、M表示尾数。在Java中，float是32位存储，double是64存储，各部分的存储长度是：
因为指数位影响数的大小，指数位决定大小范围。而小数位则决定计算精度，小数位能表示的数越大，则能计算的精度越大。
float 的小数位只有 23 位，即二进制的 23 位，能表示的最大的十进制数为 2 的 23 次方，即 8388608，即十进制的 7 位，严格点，精度只能百分百保证十进制的 6 位运算。
double 的小数位有 52 位，对应十进制最大值为 4 503 599 627 370 496，这个数有 16 位，所以计算精度只能百分百保证十进制的 15 位运算。
浮点数操作 既然浮点数不能精确表示小数，那么在执行浮点数操作时(算数运算、比较运算等)，要考虑精度丢失可能带来的问题。这里以浮点数比较为例，介绍两个浮点数比较带来的死循环问题。
public void createEndlessLoop() { double a = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b694d8416d8d33d53af5746eeddf4646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b213bc1d791562f54ac35b0e99a4524d/" rel="bookmark">
			python公交查询系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python公交查询系统 公交查询系统实验可以实现一个方便、快捷的公交信息查询方式。要求实现以下功能：1.线路查询：可以获得要查询公交所通过的各个站点；2.站点查询：通过输入的指定站点查询经过该站点的公交；3.换乘查询：分为公交直达、公交一次换乘，主要体现那些不可直达需要转车的路线的所有换乘方法；4.后台管理：用于管理员登入，添加、修改、删除公交线路等功能。
本系统用字典实现，key对应公交车号，value对应路线列表换乘功能只能找到直达和换乘一次的情况不是很完美，望大佬评论指出意见 ''' 管理员密码：1 注意点： 1.公交车号唯一 修改key dict={'a':1, 'b':2} dict["c"] = dict.pop("a") 判断key是否存在 num in dict.key() 2.添加完成保存到文件 ''' import os path=[]#存储站点 bus={'001':['a','b','e'],'002':['b','c','g'],'003':['h','c','d']}#存储公交路线,初始化3条路线 #线路查询功能 def linefind(): num=input("请输入要查询的公交车号：") if num not in bus.keys(): print("没有该线路信息，查询失败") return False for b,r in bus.items(): if(num==b): print("该公交车的线路为：",r) return True #站点查询功能 def addrfind(addr): tmp=[] #addr=input("请输入要查询的站点名称") for b,r in bus.items(): if addr in r: tmp.append(b) if( not tmp): print("对不起，此站点没有公交车经过") return tmp return tmp #换乘查询 def change(): startaddr=input("请输入出发地：") slist=addrfind(startaddr)#经过出发地的公交车 if( not slist): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b213bc1d791562f54ac35b0e99a4524d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f3b11b4ac94b2a82fe763a9dbc0fff/" rel="bookmark">
			报错：found character ‘@‘ that cannot start any token. (Do not use @ for indentation) bootstrap.yml
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot项目的配置文件，bootstrap.yml，在引用pom.xml中的内容值时，编译报错，但实际中并不影响代码运行，如下图：
解决方法：
原因是yml文件无法解析特殊字符“@”，需要用单引号或双引号将@@之间的内容括起来即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80015a25e2711c6934410585cab654ce/" rel="bookmark">
			图像处理——matlab人脸识别（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、相关程序
（一）主函数
（二）图库生成函数
（三）图库图像命名函数
（四）待识别图库生成函数
（五）待识别图库命名函数
（六）图像数据导入函数
（七）PCA简单主成分分析函数
（八）图像匹配函数
三、识别效果
一、前言 近期，要做一个人脸识别的课题，于是在前人的基础上做了一些。对于图像处理我还属于初学阶段，在人脸识别算法上没有采用很高级的算法。
参考的文章：
利用MATLAB截取图片某个区域_蓝天萝卜-CSDN博客
Matlab实现人脸识别_王小壮的博客-CSDN博客_matlab人脸识别
MATLAB中cell（元胞）数组的基本用法_脉望虫的博客-CSDN博客_matlab中cell函数
程序的主思路是：
1.首先确定两张待检测图片，一张图（图1）作为生成的图库使用，另外一张（图2）作为目标图片进行识别，一般来讲，图1中的人脸数要多余图2中的人脸数，否则可能会导致重复识别。
2.对与图片中人脸的检索用matlab自带的vision.CascadeObjectDetector()函数检测照片上的图片（vision.CascadeObjectDetector()的用法参见之前发的一篇博客：基于matlab实现的人脸检测_xiaolizi_331的博客-CSDN博客）
3.将图1和图2中的图片检测出以后，对图像进行分割转化，存入元胞数组中，以便进行下一步数据分析。
4.是图像识别的核心部分，采用简单主成分分析算法和范数将目标图片与图库中最接近目标图片的图进行匹配，完成人脸识别。
二、相关程序 （一）主函数 ori_pic=imread('yangliwei.jpeg'); lib_pic=imread('hangtianyuan.jpeg'); [facebox_aim,pic_cell_aim]=aim_face(ori_pic); [facebox_lib,pic_cell_lib,file_name]=lib_face(lib_pic); %% %%定义目标个数 n_f=size(pic_cell_aim,2);%定义目标图像个数 for i=1:n_f img=imgdata(file_name); %图片矩阵数据 Cell_ten=PCA(img,2);% 调用PCA函数 pic_aim=cell2mat(pic_cell_aim(i)); %将元胞数组转为矩阵不然会报错 face1=facefind(Cell_ten,pic_aim); figure,subplot(1,2,1) imshow(pic_aim) title('目标图像') subplot(1,2,2) imshow(strcat(num2str(face1),'.jpg')) title('自建库中图像') end （二）图库生成函数 function [facebox_lib,pic_cell_lib,file_name]=lib_face(lib_pic) faceDetector = vision.CascadeObjectDetector(); % 构造检测器对象。 %lib_pic = imread('hangtianyuan.jpeg'); % 读取包含面部的图像。 facebox_lib = step(faceDetector, lib_pic); % 开始检测，将结果存储到facebox变量中 finalImage = insertShape(lib_pic, 'Rectangle', facebox_lib,'LineWidth',5); figure; imshow(finalImage); %% ================================= % pic = imread('face2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80015a25e2711c6934410585cab654ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d12a3a3628695ae0c304c130b9b6a6/" rel="bookmark">
			Ubuntu 18.04 安装网卡驱动（有线连接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直用小米的驱动，但是感觉太慢了，所以还是决定使用有线连接。
但是之前进入Linux系统后，有线连接没有，所以需要安装驱动。
01 查询网卡类型（Windows） 进入windows系统，进入CMD命令行，输入systeminfo
查询网卡类型
网卡: 安装了 2 个 NIC。 [01]: Realtek PCIe 2.5GbE Family Controller 连接名: 以太网 2 启用 DHCP: 是 DHCP 服务器: 10.193.0.1 IP 地址 [01]: 10.193.194.9 [02]: fe80::9b6:1e28:e575:69cd [03]: 2001:da8:1002:8040::2:939c [02]: Xiaomi 802.11n USB Wireless Adapter 连接名: WLAN 2 状态: 媒体连接已中断 02 查询网卡驱动（Ubuntu） 在 Ubuntu打开终端，输入lspci -v 查看网卡驱动
如果末尾显示：Kernel driver in use:r8169
说明驱动版本不符，需要重新安装驱动，要安装RTL8125
选择安装RTL8125，是根据windows查询到的网卡类型选择的
查询结果如下：
guyue@guyue:~$ lspci -v 00:00.0 Host bridge: Intel Corporation Device 9b53 (rev 03) Subsystem: ASUSTeK Computer Inc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44d12a3a3628695ae0c304c130b9b6a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36439551991aeef92b321e3053696197/" rel="bookmark">
			Vue-cli3.0布局实战篇---组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、灰色背景的组件，使用场景：1.1 编写组件代码：在项目根目录\src\components文件夹下新增background.vue，里边写入以下代码1.2 在vue文件中使用组件 2 顶部导航栏，使用场景如下：2.1 编写组件代码，在项目根目录\src\components文件夹下新增Navbar.vue，写入以下代码2.2 在vue文件中使用Navbar组件 3 精选推荐组件，使用场景如下：3.1 编写组件代码，在项目根目录\src\components文件夹下新增GoodListCpt.vue，写入以下代码3.2 使用GoodCpt组件 总结 前言 本文所采用技术栈：vue3+vue-router4+vuex4+vant3，在我们实际开发项目中，会有一些重复的代码块，比如单页应用的底部工具栏，页面的顶部导航栏，甚至一些特定应用里的推荐商品等等，如果我们每个页面都单独去写这些代码，一是影响开发效率二是不方便维护。而vue中的组件components，就可以解决这样的问题，通过组件的复用，来实现这些相同的页面效果。今天就给大家带来，在vue-cli3.0开发中，几种最常见的组件使用方法。
1、灰色背景的组件，使用场景： 1.1 编写组件代码：在项目根目录\src\components文件夹下新增background.vue，里边写入以下代码 &lt;template&gt; &lt;div class="bg" :style="{height: height}"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "background", props: { height: String } } &lt;/script&gt; &lt;style scoped&gt; .bg{ background-color: #f4f4f4; } &lt;/style&gt; 以上代码声明了一个名字为background的组件，组件通过height来改变灰色背景的高度。
1.2 在vue文件中使用组件 &lt;script&gt; import background from "../components/background"; export default { name: "member", components: { background, }, setup(){ } } &lt;/script&gt; &lt;template&gt; &lt;div class="member-box"&gt; &lt;background height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36439551991aeef92b321e3053696197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e2114b5a3736a5158d1fadafe38ac5/" rel="bookmark">
			遥感影像掩膜操作——使用ENVI和ArcGIS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ENVI 5.1掩膜方法：
第一步：加载矢量文件or ROI范围，打开需要掩膜的遥感影像。
第二步：根据已有矢量文件or ROI建立掩膜文件。在ENVI的工具栏找到栅格管理(Raster management)—&gt;掩膜(Masking)—&gt;建立掩膜（Built mask）或者直接搜索mask。点击后按照对话框提示操作，选中需要掩膜的遥感影像。（这一步的目的是得到待掩膜影像的范围）
第三步：导入矢量文件（evf格式）或者ROI。这里以导入ROI为例，点击后会弹出一个选择ROI的对话框，选中后OK，然后保存掩膜文件，ENVI就会生成一个只有0和1的二值栅格文件。
第四步：根据创建好的掩膜文件裁剪影像。点击“Apply Mask”，按照对话框进行操作，保存文件文件。
2. ArcGIS掩膜方法：
①根据矢量文件掩膜
第一步：在ArcGIS中，按矢量文件掩膜的操作较简便。打开矢量文件和需要裁剪的栅格数据后，在ArcToolbox里找到空间分析工具—&gt;提取—&gt;根据掩膜文件提取
第二步：按照对话框提示输入相应文件。
②根据栅格文件掩膜
在ArcGIS里根据栅格文件对遥感影像掩膜和矢量的操作步骤一样，只是掩膜文件的要求不同。ArcGIS要求的栅格类型掩膜文件只将标记为Nodata的像元掩膜掉，而且掩膜后的遥感影像被裁剪区域的值也是Nodata。
因此，栅格类型的掩膜文件注意将需要裁剪的范围内的像元设置为Nodata，比如可以用重分类工具来设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3565441d78cbaaff75b6e35b0dd6f37/" rel="bookmark">
			SpringBootTest注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@SpringBootTest注解 --基于SpringBoot2.5.7版本 SpringBootTest介绍 可以在运行基于Spring Boot的测试的测试类上指定的注释。在常规的Spring TestContext框架之上提供了以下特性:
默认提供SpringBootContextLoader作为ContextLoader，也通过 @ContextConfiguration(loader=…)来自定义
若没有显示指定，将查找嵌套的@Configuration类，然后返回到SpringBootConfiguration搜索配置
允许使用properties属性定义自定义环境属性。
允许使用args属性定义应用程序参数。
支持不同webEnvironment模式,包括自定义运行web服务器监听或默认为随机端口
web服务模式下，自动注册一个TestRestTemplate和/或WebTestClient bean用于web测试
配置名称备注value配置属性properties配置属性args应用启动参数classes指定加载容器上下文配置类，等同于@ContextConfiguration中的class，若没有显示指定，将查找嵌套的@Configuration类，然后返回到SpringBootConfiguration搜索配置 关于 aliasFor可以参考 spring 官方
SpringBootTest源码 @Target(ElementType.TYPE)//注解只能用于Class, interface (including annotation type), or enum declaration @Retention(RetentionPolicy.RUNTIME)//注释将由编译器记录在类文件中，并在运行时由VM保留，因此可以反射性地读取它们。 @Documented @Inherited //允许子类继承 @BootstrapWith(SpringBootTestContextBootstrapper.class) @ExtendWith(SpringExtension.class) public @interface SpringBootTest { /** * Alias for {@link #properties()}. * @return the properties to apply */ @AliasFor("properties") String[] value() default {}; /** * Properties in form {@literal key=value} that should be added to the Spring * {@link Environment} before the test runs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3565441d78cbaaff75b6e35b0dd6f37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410cdd57fcb78cf3af990386ae4169d5/" rel="bookmark">
			simscape做一个简单倒立摆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周导师要求用滑模控制做一个倒立摆，细细了解了一下倒立摆这个模型，看了一些视频，激发了我的兴趣，在完成导师任务之后，想做一个可视化的倒立摆，发现了Simulink里的Simscape这个东西，于是就参考教程做了一个极其简单的PD控制的倒立摆。
Simscape官网介绍：
Simscape™ 可让您在 Simulink® 环境中迅速创建物理系统的模型。通过 Simscape，您可以基于物理连接直接相连模块框图建立物理组件模型。通过将基础组件依照原理图装配，为电机、桥式整流器、液压致动器和制冷系统等系统建模。Simscape 附加产品提供了更多复杂组件和分析功能。
Simscape 可帮助您开发控制系统并测试系统级性能。您可以利用基于 MATLAB® 的 Simscape 语言，使用文本定义物理建模组件、域和库，从而创建自定义组件模型。您可以利用 MATLAB 变量和表达式参数化您的模型，使用 Simulink 设计用于物理系统的控制系统。为了将模型部署到其他仿真环境，包括硬件在环 (HIL) 系统，Simscape 还支持生成 C 代码。
单摆 单摆的Simscape连接： 仿真结果： 单摆simulink程序
倒立摆： 加PD控制的倒立摆连接 仿真结果 未加控制的倒立摆 加入PD控制后 位置输出和角度输出 倒立摆simulink程序（适配matlab2021）
参考资料： SimMechanics入门：做一个单摆
一步一步做一个倒立摆
Simscape模型装配坐标问题详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698a59141628a080288909163001ba18/" rel="bookmark">
			IntelliJ IDEA Remote Development 使用体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IntelliJ IDEA Remote Development 使用体验 前天JetBrains发布新一代IDE —— Fleet，其中有我最感兴趣的分布式开发，因为本人从事 CI/CD 相关工作，所以特地关注了一下。
刚刚今天IDEA 提示更新新版本，看有Remote Development，特来体验一下。
准备 本地准备2个项目，分别 Spring Boot、 Android 项目，并且能正确运行，然后上传到git仓库，如 Gitlab 或 Github。
准备一个远程服务器，我这里是Ubuntu 系统，SpringBoot 与 Android 编译环境已经预先设置，平常用作实验与打包，机器配置稍微高一点，然后下载以上2个项目代码。
使用 下载或者更新到最新的IDEA，我这里是2021.3， 打开就会有 Remote Development功能。
然后使用ssh连接到远程服务器，先测试spring-boot项目。
IDE VERSION 选择 IntelliJ IDEA，最后选择下载和启动，因为我预先测试过，所以我这里显示 Installed。
测试的时候启动失败，但是打开启动界面是有记录的，直接打开即可。
开始加载和建立索引，此过程比较慢，不知道是我的机器性能问题，还是网络问题，有卡顿现象。
运行与测试。
远程使用localhost，本地使用IP直连。
Android 测试 根据以上步骤，打开Android测试项目。
结果可以编译与识别手机设备，但是无法安装apk，不知道是不是bug。
总结 界面显示是Beta功能，部分功能不太稳定，经常出现崩溃与卡顿现象。 运行Spring Boot 项目是成功的，Android有点问题，总体来说体验不错。
以前也用过 code-server 与 vscode 的 Remote Development，相比而言，IDEA 的 remote development 有天然的优势，代码提示与使用体验基本与本地一致。
本人从事 Android 与 Java 相关开发，IDEA 的提示功能还是强依赖的，使用s纯文本编辑器来开发还是有压力的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3bcd308a48799d8457827587e00ce51/" rel="bookmark">
			vue-cli 配置 vue.config.js 创建代理服务器 解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤： 1、创建 vue.config.js 文件 2、在 vue.config.js 中配置 devServer 3、发送请求时，把远程服务器的域名端口改成本地域名、本地端口 vue-cli 3.x 以后的版本，不会在项目根目录生成 vue.config.js ，所以需要自己手动创建一个，以下是vue-cli官网的介绍：
创建 vue.config.js 文件： 修改此文件 需要重启vue项目才能生效 module.exports = { // lintOnSave: false, /** * 代理服务器跨域请求 原理： * 建立一个代理服务器 A ，端口与域名都与本地一致 * 代理服务器 A 收到本地请求，进而向远程服务器 B 转发请求，获取数据 * (服务器间的通信，是最原始的 http 通信，没有浏览器同源策略，所以不会有跨域问题) * 代理服务器 A 向 服务器 B 请求到数据，返回本地。实现跨域请求。 * * 代理服务器发送请求，会先访问本地服务器(vue-cli所在服务器)的 public 文件夹， * 如果访问的数据 public 文件夹下有，会优先返回本地文件 */ /**s * 开启代理服务器 方式一： 简版 * 缺点： * 请求的文件，如果本地有，会优先返回本地资源 * 只能配置一个代理服务器 */ // devServer: { // proxy: 'http://localhost:8888' // } /** * 开启代理服务器 方式二： * * 可以开启多个代理服务器 * * 可以自定义请求前缀，避免访问到本地服务器资源 */ devServer: { proxy: { // 这里配置请求前缀 该代理服务器 使用前缀 /api 调用 '/api': { // 目标服务器以及端口 target: 'http://localhost:8888', // 代理服务器转发请求时，去除自定义的 api 字段 pathRewrite: { '^/api': '' }, // 用于配置支持 webSocket ws: true, // 用于配置请求头中的 host 字段 若为 true ， 则字段为目标服务器的 地址+端口 changeOrigin: true } } } } vue 组件： &lt;template&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3bcd308a48799d8457827587e00ce51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e10c146888bf7ea53ed2d0d63e1bb86/" rel="bookmark">
			腾讯云-OCR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本软件使用腾讯OCR引擎，每月有1000次调用量，可以自动识别语言，后期会持续更新ocr引擎，提高调用量。
效果： 功能一：屏幕OCR。 在屏幕选择任意矩形区域后，按回车键确认，即可进行文字识别。
功能二：单图片或多图片OCR。 选择单个图片或按下ctrl键选择多个图片，即可进行文字识别。
功能三：多图片识别。 选择图片所在文件夹即可。软件会检索该文件夹下的jpg或png格式图片，并创建每个图片名称对应的txt文件，把识别结果保存在对应txt文件中。
附上 github 链接 https://github.com/aqqwvfbukn/TencentOcr 最后上代码 import sys from PyQt5.QtCore import qAbs, QRect from PyQt5.QtGui import QGuiApplication, QColor, QPen, QPainter from PyQt5.QtWidgets import QApplication import os from PyQt5.QtCore import pyqtSlot, pyqtSignal, QSize, Qt from PyQt5.QtGui import QMovie, QPixmap, QIcon from PyQt5.QtWidgets import QWidget, QFileDialog from PyQt5 import QtCore, QtWidgets from QCandyUi.CandyWindow import colorful import ctypes import json import base64 from tencentcloud.common import credential from tencentcloud.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e10c146888bf7ea53ed2d0d63e1bb86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c75ac091066b63f19979529a325f700/" rel="bookmark">
			每天五分钟玩转K8S（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、service的必要性 对于k8s，pod不需要是robust的，因为可以通过controller来动态创建和销毁pod来保证应用整体的健壮性。由于每个pod都有自己的地址，所以当controller用新pod替代发生故障的pod时，新pod会分配新的ip地址。那么会导致ip地址发生变化，这时候就需要使用service来维护一个对外网络。
Kubernetes Service从逻辑上代表了一组Pod， 具体是哪些Pod则是由label来挑选的。 Service有自己的IP， 而且这个IP是不变的。 客户端只需要访问Service的IP， Kubernetes则负责建立和维护Service与Pod的映射关系。 无论后端Pod如何变化， 对客户端不会有任何影响， 因为Service没有变。
二、创建一个service 首先先创建一个deployment，记得加上selector
创建成功！
例行检查一下pod的情况，kubectl get pod -o wide
pod分配了各自的ip，这些ip只能被集群中的容器和节点访问
接着我们来创建一个service，老办法，先查询一下service的版本
kubectl api-resources | grep Service 创建service的yml文件
字段解释：
selector指明挑选那些label为run:httpd的pod作为service的后端
service的8080端口映射到pod的80端口，使用tcp协议
检查一下service的状况，
经操作，发现连接不到这个服务，查书才知道，原来service是通过selector指明挑选那些label为run:httpd的pod作为service的后端。
而在上面的deployment文件中，我将label设置为app:httpd，所以service不能成功挑选。修改后如下：
重新尝试访问，果然成功了
总结：service是创建了一个统一的访问接口，对内屏蔽了各个容器的具体接口，只需要关注service的接口即可使用。
（如果需要从外部访问service的话，还得再进行别的设置此时就该NodePort出场了）
利用kubectl describe可以查看httpd-svc和pod的对应关系，
Endpoints罗列了三个Pod的IP和端口。 我们知道Pod的IP是在容器中配置的， 那么Service的Cluster IP又是配置在哪里的呢？CLUSTERIP又是如何映射到Pod IP的呢？答案就是通过iptables这尊大佛
三、cluster ip底层实现 通过iptables-save命令查询具体的iptables规则
这两条规则是：
（1）如果Cluster内的Pod（源地址来自10.244.0.0/16） 要访问httpd-svc， 则允许。
（2）其他源地址访问httpd-svc， 跳转到规则KUBE-SVC-IYRDZZKXS5EOQ6Q6
KUBE-SVC-IYRDZZKXS5EOQ6Q6的规则是
（1）1/3跳转到
（2）1/3概率（剩下2/3的一半）跳转到
（3）1/3概率跳转到
总结：iptables将访问service的流量转发到后端pod，而且使用类似轮询的负载均衡策略。而且cluter的每一个节点都配置了相同的iptables规则，这样就可以确保整个cluster都能够通过service的clusterip访问service
四、dns访问service kubeadm部署时会默认安装kube-dns组件
每当有新的service被创建，就会添加该service的dns记录。cluster的pod可以通过service_name.namespace_name访问service
尝试使用http-svc.default访问service httpd-svc
五、外网访问service 除了Cluster内部可以访问Service， 很多情况下我们也希望应用的Service能够暴露给Cluster外部。 Kubernetes提供了多种类型的Service， 默认是ClusterIP。
ClusterIP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c75ac091066b63f19979529a325f700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b0ade5420a5fd00125532d48e6dbac/" rel="bookmark">
			操作系统实验Ucore:Kernel_init(四)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发于我的博客
上一节进行到了kernel_init的printf_kernelinfo，继续往下分析
1.pmm_init 这个函数，顾名思义是用来初始化物理内存的函数，这个函数只会调用gdt_init()
这里我稍微修改了一下代码框架，原本的gdt_pd的定义为注释部分
这段代码看上去没问题，但是实际跑的时候就会发现gdt_pd的两个字段都是0。
我写了一个程序来模拟这种情况，看上去好像没有问题，但这个程序是无法通过编译的。
这个错误告诉我们编译器无法在执行前算出a1的地址。所以不可以这样初始化变量。
至于为什么会这样，改天再研究吧。现在先关注到实验上来。总之，这样改完之后，程序就可以正确运行了。
关于TSS的部分现在先不用管，然后就到了lgdt函数的位置了
我们要执行pmm_init的意义就在于我们需要重新为内核建立段描述符。第一次建立段描述符还是在bootasm中，那时候我们刚从实模式进入保护模式，那时候建立的段描述符有3个
空描述符
代码段描述符
数据段描述符
现在内核需要建立六个描述符
对于我们的操作系统来说，所有的段描述符都是可以访问4G的内存的，唯一的区别在于权限的不同，我们实际上并没有使用分段机制，这叫做 平坦内存模型(Flat memory model)。
在使用lgdt指令加载完gdt之后，刷新各个段寄存器。最后还会执行一条ljmp指令
关于这个ljmp，在实模式进入保护模式时也有涉及，但当时没有注意，现在看到书上的描述，才知道这样做的意义。
使用ljmp指令可以重新加载CS段寄存器，并刷新其对应的缓存器，使其指向正确的地址
在实模式进入保护模式时，这样做的另一个目的是清空流水线，在进入把保护模式时，ljmp之后的指令已经进入了流水线，而且完成了译码阶段，所以要清空流水线，重新按照32位模式加载指令。（理解这部分内容需要了解CPU流水线）
至此，内存的段描述符就建立完成了。gdt_init函数也全部执行完了
2.pic_init 这段程序没有深入的研究，其和操作系统的内核也没有太大的关系，主要是和初始化外设（另一个原因是我也不会…）。暂时先了解：
这个东西是 8259A芯片，pic的全称是（Programmable Interrupt Controller）可编程的中断控制器
所有的外部中断都不直接于CPU进行通讯，而是由8259A统一收集中断请求后再交给CPU
8259A芯片可以编程屏蔽部分外界中断，对于一个中断，其能被处理的先决条件是没有被8259A芯片屏蔽且CPU没有屏蔽外界中断（Eflags 寄存器的 IF 位）
一个8259A只有八个中断引脚，一般使用两个8259A组成级联（Cascade）关系。这样一共支持15个外部中断，我们可以编程来给中断引脚分配中断号
outb(IO_PIC1 + 1, IRQ_OFFSET);
outb(IO_PIC2 + 1, IRQ_OFFSET + 8);
这两句话比较关键，告诉我们主片的中断号从32开始，从片的从40开始
至于为什么从这里开始，是因为Intel将32以下的终端号保留使用，用户正常情况下可以使用32-255号中断
3.idt_init 初始化完8259之后，就要初始化中断的处理了。
这个部分比较复杂，需要多看几次才能理解，我也尽量讲清楚。
在idt_init中，需要初始化中断描述符表，这个表的位置在数据段中。一共有255个表项，对应着可以接收的255个中断号。由于CPU在接收到中断的时候会根据此项来确定中断处理函数的地址，所以一个idt表项中应当含有中断处理函数的CS：IP值，在这里就是CS段选择子和中断处理程序的偏移量。
我们使用kernel的代码段作为段选择子，偏移由__vectors数组指定。注意，现在所有的段选择子的基址都是0，也即是说，偏移的地址就是实际的物理地址。
__vectors数组存放在数据段中，依据255 * 4 的方式组织，每一项是一个指向对应异常处理函数地址的指针。
异常处理函数有255个，由vector开头加上异常号，这些函数连续的放在代码段中。
每一个异常处理函数的工作都是类似的，先push异常号，然后跳转，至于为什么这样，后文再说。
现在来总结一下一共用到了哪些变量
idt[256] 位置：数据段 作用：用来根据异常号选择异常处理程序。__vectors 位置：数据段 作用：用来初始化idt，与中断处理无关。vectorX函数 位置：代码段 作用：实际的异常处理函数。 4.中断 之后就是初始化时钟，使能中断，我们主要来看看中断时如何处理 的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8b0ade5420a5fd00125532d48e6dbac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0547140fac844b9440c0f06272a01df/" rel="bookmark">
			SpringCloud Gateway路由配置方式(不包含熔断)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果请求的目标地址，是单个的URI资源路径，配置文件示例如下：
server: port: 8080 spring: application: name: api-gateway cloud: gateway: routes: -id: url-proxy-1 uri: https://blog.csdn.net predicates: -Path=/csdn 各字段含义如下：
id：我们自定义的路由 ID，保持唯一
uri：目标服务地址
predicates：路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。
上面这段配置的意思是，配置了一个 id 为 url-proxy-1的URI代理规则，路由的规则为：
当访问地址http://localhost:8080/csdn/1.jsp时，
会路由到上游地址https://blog.csdn.net/1.jsp。
2.2 基于代码的路由配置方式 转发功能同样可以通过代码来实现，我们可以在启动类 GateWayApplication 中添加方法 customRouteLocator() 来定制转发规则。
package com.springcloud.gateway; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.gateway.route.RouteLocator; import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder; import org.springframework.context.annotation.Bean; @SpringBootApplication public class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class, args); } @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) { return builder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0547140fac844b9440c0f06272a01df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d63f18c632f08e5373543852afe69c33/" rel="bookmark">
			JavaScript进阶七（对象）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是对象二、为什么需要对象三、创建对象的三种方法1、利用字面量创建对象2、用new Object创建对象3、利用构造函数创建对象new关键字执行过程 四、变量、属性、函数、方法的区别1、变量和属性2、函数和方法 五、对象与构造函数的区别六、遍历对象 一、什么是对象 所有的事物都是对象，例如字符串、数值、数组、函数等。对象是由属性和方法组成的。在面向对象中把’属性’称为对象的成员(成员变量)，把’行为’称为成员方法(成员函数)。在JavaScript中，对象是一种数据类型，是一组无序的相关属性和方法的集合。
属性：事物的特征，在对象中用属性来表示，反映的是对象的静态特征（常用名词）
方法：事物的行为，在对象中用方法来表示，反映对象的动态特征（常用动词）
二、为什么需要对象 变量可以保存一个值，数组可以保存多个值，但是如果想要保存多个信息时，就可以使用对象。它的表达结构更清晰，更强大。
三、创建对象的三种方法 用"{}“表示一个对象,在”{}“中包裹了对象的成员(包括属性和方法)
以"key:value”(键-值对)方式存储各成员。"key"是成员名,"value"是成员的值。
对成员的访问格式是：
对象名.属性名 或 对象名[‘属性名’]
对象名.方法名([参数]) 或 对象名 [‘方法名’] ([参数])
1、利用字面量创建对象 对象的字面量就是用花括号“{ }”来包裹对象中的成员，每个成员使用“key: value”的形式来保存，key表示属性名或方法名，value表示对应的值。多个对象成员之间用“,”隔开。
举例如下：
var person1 = { name : '旺旺', age : 12, skill(){ console.log("hahahaha!"); } }; console.log(person1.name);//.我们可以理解为‘的’ console.log(person1['age']);//注意方括号里面的属性必须加引号 person1.skill(); //输出为： 旺旺 12 hahahaha! 2、用new Object创建对象 Object：是JavaScript中的超级对象,即用户创建的对象都直接或间接的继承了该对象的某些特性。
创建方式：
var 对象名 = new Object();
var person2 = new Object(); person2.name = '嘻嘻'; person2.age = 13; person2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d63f18c632f08e5373543852afe69c33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13be7c09882c1cd6ce714c11327d32bc/" rel="bookmark">
			每天五分钟玩转K8S（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接着上一篇介绍完k8s架构后，我们就开始学习k8s中的一个重要概念：deployment
一、部署deployment kubectl create deployment nginx-deployment --image=nginx:1.7.9 --replicas=2 （最下面的events记录的是replicas的启动过程，证明了deployment可以通过replicas来管理pod）
接着我们将
使用kubectl describe replicaset查询replica的情况
查询各个pod的情况，先用kubectl get pod获取pod的名字，然后使用kubectl describe pod (podname)
可以看到pod的具体情况，如果有error的话，可以通过这种方法来查询具体的错误情况（描述的非常详细）
用户通过kubectl创建deployment-&gt;deployment创建replicaset-&gt;replicaset创建pod
如果有replica的话，就要用到replicaset，如果没有的话deployment直接动手
二、使用yaml来部署 之前我们一直是直接使用命令行直接部署deployment的，但在实际中，更多的是用yaml文件来部署，先贴上书上的栗子
在1中，需要通过查询支持apiVersion的版本，如果稳妥的话，在创建不同kind的yaml文件前都应该先查询。
kubectl api-resources | grep deployment 在本机查到的是
所以在apiVersion中需要填写apps/v1。
由于版本原因，需要在文件中加多一个标签，selector。修改后如下：
接着就可以成功运行了
其中常用的查询指令是：
kubectl get pod -o wide 三、调整replica的个数 可以直接在yaml文件中修改replicas的数量
再运行一次kubectl apply -f nginx.yml即可。
四、用label来控制scheduler调度的策略 我们给node1打上label，然后查询label的tag，看到已经成功打上了。
在yaml文件中，加上nodeSelector字段，指定要scheduler将该pod调度到有这个tag的node上。（需要注意的是，格式一定要正确，要不就不能成功识别，container和nodeSelector的缩进要一样）
执行kubectl apply -f nginx.yaml，稍等片刻，可以看到都部署到node1上了。
在这里需要注意的是，即时删除了tag，pod不会重新部署，除非重新运行yaml文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb4305f469c632b89de83455766bbea1/" rel="bookmark">
			wordpress4.9漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞介绍： WordPress可以说是当今最受欢迎的（我想说没有之一）基于PHP的开源CMS，其目前的全球用户高达数百万，并拥有超过4600万次的超高下载量。它是一个开源的系统，其次它的功能也十分强大。也正因为此，WordPress也成了众多黑客的攻击目标，一旦得手也就意味着数百万用户的沦陷。这种广泛的采用使其成为网络犯罪分子的一个有趣目标。这次实验的漏洞是在WordPress核心中的一个经过身份验证的任意文件删除漏洞CVE-2018-20714
该漏洞可能导致攻击者执行任意代码。该漏洞自发现到报告给WordPress安全团队7个月，但仍未修补。自首次报告以来已经过去很长时间没有任何补丁或具体计划。现在wordpress4.9.6及以下版本都存在此漏洞。
漏洞的利用条件： 为了利用下面讨论的漏洞，攻击者需要获得预先编辑和删除媒体文件的权限。也就是拥有作者权限。这里我们也要了解一下wordpress有哪些权限用户。
超级管理员（Super Admin） – 有权访问站点网络管理功能和所有其他功能。
管理员（Administrator） – 有权访问单个站点内的所有管理功能。
编辑（Editor） – 可以发布和管理帖子，包括其他用户的帖子。
作者（Author） – 可以发布和管理自己帖子。
贡献者（Contributor ） – 可以编写和管理他们自己的帖子但不能发布。
订阅者（Subscriber ） – 只能管理他们个人资料的人。
我们发现作者权限用户原本只可以发布和管理自己的帖子，但通过这个漏洞却可以劫持整个网站并在服务器上执行任意代码，也就是通过这个WordPress漏洞，黑客可轻松控制网站。
该漏洞存在于用户永久删除上传图像的缩略图时在后台运行的WordPress核心功能之一。
漏洞危害： 至少一个作者帐户的要求会在某种程度上自动降低此漏洞的严重程度，这可能会被流氓内容撰稿人或黑客利用网络钓鱼，密码重用或其他攻击以某种方式获取作者的凭证所利用。
利用此漏洞可以使攻击者能够删除WordPress安装的任何文件（+ PHP进程用户具有删除权限的服务器上的任何其他文件）。除了擦除整个WordPress安装的可能性，如果没有可用的当前备份可能会带来灾难性的后果，攻击者可以利用任意文件删除的能力来规避一些安全措施并在Web服务器上执行任意代码。更准确地说，可以删除以下文件：
.htaccess：通常，删除此文件不会产生任何安全后果。但是，在某些情况下，.htaccess文件包含与安全性相关的约束（例如，对某些文件夹的访问约束）。删除此文件将停用这些安全约束。
index.php文件：通常将空的index.php文件放入目录中，以防止Web服务器无法执行此操作的目录列表。删除这些文件会向攻击者授予受此度量保护的目录中所有文件的列表。 wp-config.php：删除WordPress安装的这个文件会在下次访问网站时触发WordPress安装过程。这是因为wp-config.php包含数据库凭据，并且没有它的存在，WordPress就像尚未安装一样。攻击者可以删除此文件，使用他为管理员帐户选择的凭据进行安装过程，最后在服务器上执行任意代码。
但是，应该注意的是，由于攻击者无法直接读取wp-config.php文件的内容来知道现有的“数据库名称”，“mysql用户名”及其“密码”，所以他可以重新设置目标站点在他的控制下使用远程数据库服务器。一旦完成，攻击者可以创建一个新的管理员帐户并完全控制网站，包括在服务器上执行任意代码的能力。“除了删除整个WordPress安装的可能性，如果没有当前的备份可用会造成灾难性的后果，攻击者可以利用任意文件删除的功能来规避一些安全措施并在Web服务器上执行任意代码
漏洞复现： 使用wpscan 进行简单扫描
wpscan --url http://whalwl.site:8043/ ，发现版本号
使用wpscan对其用户进行枚举
wpscan --url http://whalwl.site:8043/ --enumerate u
使用author去登录的时候却提示账户不存在，推测author是改了名字
使用之前推荐的字典，进行用户名枚举 Top500_Username
枚举出 用户名 admin test
爆破admin test 账户得到test密码：1qaz2wsx 密码字典
下面使用Metasploit wp_crop_rce漏洞利用模块
直接利用会提示失败，我们需要修改一下利用模块
登录进来
找到wp_crop_rce漏洞利用模块路径：
vim /usr/share/metasploit-framework/modules/exploits/multi/http/wp_crop_rce.rb
修改第313行 @backdoor = Rex::Text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb4305f469c632b89de83455766bbea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434266f2a452d95bb516d18846abd027/" rel="bookmark">
			水很深的深度学习Task05
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 计算图循环神经网络RNN的发展历程RNN案例长短时记忆网络LSTM 循环神经网络的主要应用问答系统自动作曲机器翻译 计算图 计算图的引入是为了后面更方便的表示网络，计算图是描述计算结构的一种图，它的元素包括节点(node)和边(edge)，节点表示变量，可以是标量、矢量、张量等，而边表示的是某个操作，即函数。
下面这个计算图表示复合函数
循环神经网络 上一章我们已经介绍了CNN，可能我们会想这里为什么还需要构建一种新的网络RNN呢？因为现实生活中存在很多序列化结构，我们需要建立一种更优秀的序列数据模型。
文本：字母和词汇的序列语音：音节的序列视频：图像帧的序列时态数据：气象观测数据，股票交易数据、房价数据等 RNN的发展历程 循环神经网络是一种人工神经网络，它的节点间的连接形成一个遵循时间序列的有向图，它的核心思想是，样本间存在顺序关系，每个样本和它之前的样本存在关联。通过神经网络在时序上的展开，我们能够找到样本之间的序列相关性。
下面给出RNN的一般结构：
其中各个符号的表示： x t , s t , o t x_ t,s_t, o_t xt​,st​,ot​分别表示t时刻的输入、记忆和输出， U , V , W U,V,W U,V,W是RNN的连接权重， b s , b o b_s, b_o bs​,bo​是RNN的偏置， σ , φ σ, φ σ,φ是激活函数， σ σ σ通常选tanh或sigmoid， φ φ φ通常选用softmax。
RNN案例 比如词性标注，
我/n,爱/v购物/n,我/n在/pre华联/n购物/v
Word Embedding：自然语言处理(NLP)中的 一组语言建模和特征学习技术的统称，其中来自词汇表的单词或短语被映射到实数的向量。比如这里映射到三个向量然后输入：
将神经元的输出存到memory中，memory中值会作为下一时刻的输入。在最开始时刻，给定 memory初始值，然后逐次更新memory中的值。 各种不同的RNN结构
长短时记忆网络 在RNN中，存在一个很重要的问题，就是梯度消失问题，一开始我们不能有效的解决长时依赖问题，其中梯度消失的原因有两个：BPTT算法和激活函数Tanh
有两种解决方案，分别是ReLU函数和门控RNN(LSTM).
LSTM LSTM，即长短时记忆网络，于1997年被Sepp Hochreiter 和Jürgen Schmidhuber提出来，LSTM是一种用于深度学习领域的人工循环神经网络（RNN）结构。一个LSTM单元由输入门、输出门和遗忘门组成，三个门控制信息进出单元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/434266f2a452d95bb516d18846abd027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528b7dd0b2cf66d33ff588df0a99df38/" rel="bookmark">
			查看mysql的binlog日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开启binlog
log-bin=mysql-bin #binlog有三种模式、row、statement、mixed binlog_format=mixed 默认binlog的位置在mysq数据目录data下面，mysqlbinlog工具在安装目录的bin文件夹下。
mysqlbinlog的参数
-d, --database=name 仅显示指定数据库的转储内容。 -o, --offset=# 跳过前N行的日志条目。 -r, --result-file=name 将输入的文本格式的文件转储到指定的文件。 -s, --short-form 使用简单格式。 --set-charset=name 在转储文件的开头增加'SET NAMES character_set'语句。 --start-datetime=name 转储日志的起始时间。 --stop-datetime=name 转储日志的截止时间。 -j, --start-position=# 转储日志的起始位置。 --stop-position=# 转储日志的截止位置。 -v, --verbose 自动生成带注释的SQL语句（在行事件中重构伪SQL语句,row格式下的sql语句是base64的字符串） 比如查看某个binlog文件
./mysqlbinlog binlog文件路径 -d 数据库名称 -s --start-datetime="2021-12-01 00:00:00" --stop-datetime="2021-12-01 23:59:59" &gt; 输出到某个目录下方便查看
./mysqlbinlog /var/mysql/data/mysql-bin.000050 -d procrm -s --start-datetime="2021-12-01 00:00:00" --stop-datetime="2021-12-01 23:59:59" &gt; /mnt/b.log 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/176/">«</a>
	<span class="pagination__item pagination__item--current">177/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/178/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>