<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a7b98c8e4c4f3869c3b882e933fc008/" rel="bookmark">
			Linux入门级教程（一）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此文针对VMware和Linux系统的安装与配置进行了较为简单的阐述，目的是为了让一些刚刚接触的朋友对此有一个大概的认知，但可能不够详尽，欢迎各位朋友在评论区进行交流。 1、认识和了解Linux Linux是开源、稳定、漏洞少，主要定位是服务器端操作系统，个人操作系统Windows还是具有很大优势的，操作方便，应用软件多，生态完善。比如：可在Windows下使用idea进行软件开发，开发完毕后发布到Linux服务器上。
Linux-全程GNU/Linux，是一套免费使用和自由传播的类Unix操作系统。 内核由林纳斯·本纳迪克特·托瓦兹（个人感觉这名字真的难记）于1991年10月5日首次发布。 2、虚拟机 虚拟机（virtual machine）就是指通过软件技术虚拟出来的一台计算机，但它从使用层面来说，与真实的计算机没有什么区别。
市面上比较常见的虚拟机有：VMware Workstation简称VMware、VirtualBox、MicrosoftVirtualPC等，各位可自行选择，个人感觉其实都差不多，毕竟以后对虚拟机的操作一般都是使用远程工具来完成的。
在虚拟机系统中，每一台虚拟产生的计算机都被称为“虚拟机”，而用来存储所有虚拟机的计算机则被称为“宿主机”。图解如下：
3、虚拟机的安装 3.1、安装虚拟机引擎 安装之前请关闭电脑的杀毒软件、防火墙、360等，不然很有可能在安装过程中出现意想不到的情况。
如果在安装的过程当中出现了下图当中的情况，不用急，这只是你的bios中的虚拟化支持没开，进到BIOS当中设置一下即可，设置方法在图后：
如何在BIOS中开启虚拟化技术：
虚拟化技术目前主要依赖于您电脑的CPU型号及BIOS，某些CPU或者BIOS暂时还不能支持虚拟化技术。支持虚拟化技术的可以在BIOS中开启，开启方法如下：
1、进入BIOS。开机时按F2或F12或DEL或ESC等键（各电脑有所不同）。
2、进入BIOS后，找到Configuration选项，选择Intel Virtual Technology并回车，将光标移至Enabled，然后再回车，最后按F10保存并退出。
如果找不到Configuration选项，可以试试下面的方法：
（1）某些HP（惠普）电脑进入BIOS后，需要选择SystemConfiguration（系统配置）菜单，然后选择Device Configuration（设备配置），找到Virtualization Technology，设置为Enabled。
（2）某些联想Thinkpad电脑进入BIOS后，需要选择Security菜单，然后选择Virtualization，设置为Enabled。
（3）某些DELL（戴尔）电脑进入BIOS后，需要选择Processor Settings菜单，然后选择VirtualizationTechnology，设置为Enabled。
如果还没有合适的开启方法，可以回复帖子，告知电脑或者主板的品牌型号，会有网友或者工作人员告知您。
找不到BIOS中开启虚拟化技术的开关?：
目前已知部分型号的Acer台式机和笔记本，虽然其CPU支持虚拟化技术，但主板BIOS中没有提供开关。如果您遇到此情况，请回复本帖并联系厂商解决。
在BIOS中打开了开关仍然提示不能开启?：
因为硬件虚拟化技术目前大多数软件厂商会对其进行独占式的使用，比如Avast杀毒软件的新版本沙箱功能使用了硬件虚拟化技术，如果遇到类似问题，请在这类软件的设置选项中取消勾选类似“使用硬件虚拟化技术”字样的开关。 重启电脑后就可以正常开启360核晶防护。
安装成功之后会增加两个虚拟网卡，如下图：
安装后查看“虚拟网络编辑器”，如下图：
3.2、虚拟机安装过程中可能会出现的问题 1、安装VMware成功，但是安装Linux经常出现蓝屏：
这种情况一般与Windows和VMware的版本匹配有关，个人尝试升级为VMware16之后，情况消失。
2、安装VMware在安装网络位置长时间等待，到最后也没有出现两个虚拟网卡：
建议清理一下注册表，有可能是某些资源被占用，需要软件的话可以私信我，并备注来意，看到后我会回复的。
4、创建虚拟机镜像 1、点击新建虚拟机
2、点击下一步即可，根据自己的需要进行选择，我选择的是稍后安装系统
3、对虚拟机进行命名和位置选择，建议不要将虚拟机放在c盘，因为虚机较大，而且启动后比较占用内存，容易发生一些难以预料的事情
4、然后编辑虚拟机设置，修改网络，这个在安装的过程中会有提示，下图仅作参考。
5、至于内存和处理器之类的配置就根据个人需要了，一般情况下，下图的配置足够支撑起大部分新手的操作了。
5、安装Linux 虚拟机和宿主机之间进行切换的快捷键是：单击虚拟机即可进入虚拟机，退出虚拟机则使用CTRL+alt快捷键即可。
这里使用最小安装（最小安装没有图形化界面，只有一个类似cmd的黑色窗口，但是体积小，占用空间小）
注意：一定要打开右上角以太网的按钮，不然没网，后面配置起来会有些麻烦
到上面这一步就基本上已经宣告成功了。
下面简单提及一下各种网络模式之间的区别，如图：
6、安装成功后的操作 到这里就安装成功了，会出现如下图提示输入账号密码的界面：
输入ifconfig或者ip addr命令查看虚拟机当前地址：
注意：虚机IP地址为下图ens33当中红框内的地址
Windows当中则使用ipconfig查看IP地址。
在Linux当中使用Ping（空格）+宿主机ip测试网络是否连通
如果连通不成功，可尝试关闭两边的防火墙后再次尝试，一般是虚拟机当中防火墙未关闭导致的。
Linux当中操作防火墙的命令为：
1、查看防火墙：systemctl(空格)status(空格）firewalld
一般情况下， 刚刚安装成功的虚拟机防火墙都是处于开启状态，状态为alive且字体高亮
2、关闭防火墙：systemctl(空格)stop(空格)firewalld
3、永久关闭（防止自启）防火墙：systemctl(空格)disable(空格)firewalld
4、启用防火墙：systemctl(空格)start(空格)firewalld
5、防火墙开启自启：systemctl(空格)enable(空格)firewalld
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a7b98c8e4c4f3869c3b882e933fc008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a912fd6484dc3052dd1ced3ec84bfc3a/" rel="bookmark">
			L1-025 正整数A&#43;B（c语言调用函数基础写法）&#43;详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题的目标很简单，就是求两个正整数A和B的和，其中A和B都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。
输入格式： 输入在一行给出A和B，其间以空格分开。问题是A和B不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。
注意：我们把输入中出现的第1个空格认为是A和B的分隔。题目保证至少存在一个空格，并且B不是一个空字符串。
输出格式： 如果输入的确是两个正整数，则按格式A + B = 和输出。如果某个输入不合要求，则在相应位置输出?，显然此时和也是?。
输入样例1： 123 456 输出样例1： 123 + 456 = 579 输入样例2： 22. 18 输出样例2： ? + 18 = ? 输入样例3： -100 blabla bla...33 输出样例3： ? + ? = ? #include&lt;stdio.h&gt; //分两个小函数，一个转数字，一个判断是不是数字 #include&lt;string.h&gt; int flag(char a[]){//1为数字，0为字符 int n; int i; n=strlen(a); for(i=0;i&lt;n;i++){ if(a[i]&lt;'0'||a[i]&gt;'9'){ return 0; } } return 1; } int zhuan(char a){//字符转换为数字 switch(a){ case '0':return 0;break; case '1':return 1;break; case '2':return 2;break; case '3':return 3;break; case '4':return 4;break; case '5':return 5;break; case '6':return 6;break; case '7':return 7;break; case '8':return 8;break; case '9':return 9;break; } } int main(){ char a[100];//放第一个 char b[100];//放第二个 char ch; int n,i,m,n1,m1; m=0; m1=0; i=0; while((ch=getchar())!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a912fd6484dc3052dd1ced3ec84bfc3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251be939c59b578a34ceb740a060b383/" rel="bookmark">
			矩阵理论复习（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内积空间的定义
模与内积
向量x和y的夹角
正交向量、正交组和正交矩阵
度量矩阵
基向量内积、度量矩阵、任意向量内积之间的关系
欧式空间的两个基对应的度量矩阵彼此合同
度量矩阵的行列式的几何问题
正交补子空间
内积空间=子空间U与U的正交补子空间的直和
正交补子空间的性质和应用
值域和零空间的正交补关系
正交投影
内积空间中的线性变换——保距变换
T是等距变换——对应的A是酉矩阵
设A是Hermite矩阵，若对于任意向量x均有xHAx=0,则A=0
等距变换
Householder变换
Givens变换
对称变换与对称矩阵
初等矩阵的定义
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a160f9e4883210645edc36a21046a662/" rel="bookmark">
			JAVA NIO详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Java NIO
1.1阻塞IO概述
通常在进行同步I/О操作时，如果读取数据，代码会阻塞直至有可供读取的数据。同样，写入调用将会阻塞直至数据能够写入。传统的Server/Client模式会基于TPR(Thread per Request),服务器会为每个客戌端请求建立一个线程，由该线程单独负责处理一个客户请求。这种模式带来的一个问题就是线程数量的剧增，大量的线程会增大服务器的开销。大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量，这由带来了新的问题，如果线程池中有100个线程，而有100个用户都在进行大文件下载，会导致第101个用户的请求无法及时处理，即便第101个用户只想请求一个几KB大小的页面。
1.2 NIO（非阻塞IO）概述
当有读或写的注册事件发生，可以从Selector中获取相应的SelectionKey，同时可以从SelectionKey中找到发生的时间和发生的具体的SelectableChannel。非阻塞指的是IO事件本身不阻塞,但是获取IO事件的select()方法是需要阻塞等待的.区别是阻塞的IO会阻塞在IO操作上， NIO阻塞在事件获取上,没有事件就没有IO,从高层次看IO就不阻塞了.也就是说只有IO已经发生那么我们才评估IO是否阻塞,但是select()阻塞的时候IO还没有发生,何谈IO的阻塞呢?NIO的本质是延迟IO操作到真正发生IO的时候,而不是以前的只要IO流打开了就一直等待IO操作。 1.2.1JAVA NIO 组成
Channel
Channel是一个通道，可以通过它读取和写入数据，它就像水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向上移动(一个流必须是 InputStream 或者OutputStream的子类)，而且通道可以用于读、写或者同时用于读写。因为Channel是全双工的，所以它可以比流更好地映射底层操作系统的APl。NIO中通过channel封装了对数据源的操作，通过channel我们可以操作数据源，但又不必关心数据源的具体物理结构。这个数据源可能是多种的。比如，可以是文件，也可以是网络socket。在大多数应用中，channel与文件描述符或者socket是——对应的。Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。 分类
FileChannel从文件中读写数据。DatagramChannel能通过UDP读写网络中的数据。SocketChannel 能通过TCP读写网络中的数据。’ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。 1.2.2 Scatter/Gather
分散(Scatter)
从Channel中读取数据，数据分散到多个buffer中去。 聚集(Gather)
将多个buffer中的数据聚集到一个channel中去。 2.1 Buffer
缓冲区。本质上为可以读取数据，也可以写入数据的一块内存。
2.1.1 使用Buffer步骤
写数据到Buffer调用filp()方法从Buffer读取数据调用clear()方法或compact()方法 (clear会清空缓冲区，compact会清空已经读过的数据) 2.1.2 Buffer的三个属性
(1) Capacity
内存块的大小,一旦Buffer满了，需要清空。 (2) Position
写模式中，position表示当前写入的位置，position最大为capacity-1。读模式下，为读入数据的当前位置。 (3) limit
写数据时，能写入多少的数据，写模式下，limit等于capacity。读数据时，表示有多少数据可读，在写模式下就是position。 2.2 缓冲区分片（根据现有缓冲区分片多个子缓冲区）
只读缓冲区：只能读数据，不能写入。直接缓冲区：为了加快I/O速度。内存映射文件I/O。 3.1 Selector
可以使用单线程管理多个channel，也就是管理多个网络连接，selector相当于多路复用器，使用更少的线程，相比使用多个线程，避免上下文切换。一些channel是不可被复用，例如filechannel，只有继承了SelectorableChannel才能被复用。 3.1.2 channel注册到Selector
注册
Channel.resiter(Selector sel,int ops)
sel为选择器，ops为需要查询的通道的操作(可读，可写，连接，接收)选择键
(1) Channel注册到后，并且一旦通道处于某种就绪的状态，就可以被选择器查询到。这个工作，使用选择器Selector的select ()方法完成。select方法的作用，对感兴趣的通道操作，进行就绪状态的查询。
(2) Selector可以不断的查询Channel中发生的操作的就绪状态。并且挑选感兴趣的操作就绪状态。一旦通道有操作的就绪状态达成，并且是Selector感兴趣的操作，就会被Selector选中，放入选择键集合中。
(3）一个选择键，首先是包含了注册在Selector的通道操作的类型，比方说SelectionKey.OP.READ。也包含了特定的通道与特定的选择器之间的注册关系。开发应用程序是，选择键是编程的关键。NIO的编程，就是根据对应的选择键，进行不同的业务逻辑处理。 3.2 NIO管道(pipe)
Java NIO管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。
3.3 文件锁(FileLock)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a160f9e4883210645edc36a21046a662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218c902c9f5f87deac35918edb67e86f/" rel="bookmark">
			排序算法之选择排序(带优化后方案)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择排序 什么是选择排序？ 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的中数据元素选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。
案例演示 **解释：**如上图，第一趟从整个数组里面选出最小的数，让他跟第一个位置的数进行交换，然后取出剩下的里面最小的数，在跟第二个位置的数进行交换，最终我们得到了一个有序的序列，这就是选择排序。
时间复杂度 如上图，9个数据按照冒泡排序一共比较了8+7+6+5+4+3+2+1次，根据这个规律我们推导到n个数呢？
那就是(n-1) * (n-2) * (n-3) * … * (3) * (2) * (1)=n*(n-1)/2=n²/2-n/2
所以冒泡排序的复杂度就是O(n²)。
算法实现 我们首先把第一个数字的值和下边存下来，然后遍历整个列表，如果遇到值比第一个值还小的，就把他的值和下标记录下来，一遍下来，我们得到了最小的数和下表，我们把最小的数和第一个数进行交换，然后第二遍我们把第二个数的值和下标记录，然后遍历，遇见比他小的就记录，遍历完就和第二个数进行交换，直到最后得到一个从小到大的有序数组。
代码实现 //选择排序实现 public static void select(int[] arr) { int min = 0; int minIndex = 0; for (int i = 0; i &lt; arr.length - 1; i++) { min = arr[i]; minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) { if (arr[j] &lt; min) {//如果遇见比min小的值就赋给 min = arr[j]; minIndex = j; } } arr[minIndex] = arr[i]; arr[i] = min; } } 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/218c902c9f5f87deac35918edb67e86f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b43f6684746187aba0e5cc081224000/" rel="bookmark">
			微信小程序（四）--- 自定义组件详解（properties，数据监听器，纯数据字段，插槽，父子间通信，behaviors）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、创建组件
二、引用组件
1、局部引用
2、全局引用
三、组件和页面的区别
四、组件样式隔离
1、注意点
2、修改组件的样式隔离选项
五、数据、方法、属性
1、data数据
2、methods方法
3、properties属性
4、data和properties的区别
5、使用setData修改properties的值
六、数据监听器
1、语法格式
2、基本用法
3、监听对象属性的变化
4、监听对象中所有属性的变化
七、纯数据字段
1、使用规则
2、使用纯数据字段改造数据监听器
八、组件的生命周期
1、created,attached,detached
2、lifetimes节点
九、组件所在页面的生命周期
1、pageLifetimes节点
十、插槽
1、单个插槽
2、启用和定义多个插槽
十一、父子组件通信
1、属性绑定（父---&gt;子）
2、事件绑定（子---&gt;父）
3、获取组件实例
十二、behaviors
1、创建behavior
2、导入并使用behavior
3、behavior中所有可用的节点
4、同名字段的覆盖和组合规则
一、创建组件 在项目的根目录中，鼠标右键，创建components -&gt; test 文件夹在新建的components -&gt; test文件夹上，鼠标右键，点击“新建Component"键入组件的名称之后回车，会自动生成组件对应的4个文件，后缀名分别为.js，.json，.wxml和.wxss
二、引用组件 1、局部引用 在页面的.json配置文件中引用组件的方式，叫做“局部引用”。示例代码如下：
{ "component": true, "usingComponents": { "my-test":"/components/test/test" } } 可在.wxml中使用组件：&lt;my-test&gt;&lt;/my-test&gt; 2、全局引用 在app.json 全局配置文件中引用组件的方式，叫做“全局引用”。使用与上面代码相同，全局不用写"component":true
data:{ n1:0, n2:0, sum:0 }, methods:{ addN1(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b43f6684746187aba0e5cc081224000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc312f673791a21cb93ee29c2b2a67f3/" rel="bookmark">
			神经网络模型训练简记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络模型训练简记（一） 一、概念介绍1.1人工智能、机器学习、神经网络与深度学习1.2backbone与pretrain_model1.3batch_size、learning_rate、epoch与iteration1.4模型评价指标 二、官方数据集简介2.1ImageNet数据集2.2 ILSVRC竞赛2.3 MS COCO数据集2.4 PASCAL VOC数据集2.5 Cityscapes数据集 三、机器视觉网络模型分类及简介3.1图像分类3.1.1LeNet3.1.2AlexNet3.1.3ZFNet3.1.4VGGNet3.1.5GoogLeNet3.1.6Inception V23.1.7Inception V33.1.8ResNet3.1.9GBD-Net3.1.10Inception V4、Inception-ResNet-v1与Inception-ResNet-v23.1.11SENet 未完待续 参考文档 一、概念介绍 首先进行几个概念介绍：
1.1人工智能、机器学习、神经网络与深度学习 （1）人工智能：人工智能是研发用于模拟、延伸和拓展人的智能的理论、方法、技术及应用系统的一门技术学科。人工智能是个较为宽泛的概念，存在很多的分支，机器学习是实现人工智能的一种比较热门而有效的分支。
（2）机器学习：机器学习是一门开发算法和统计模型的科学，它依靠计算机系统研究怎样通过算法和模型，来获取新的知识和技能，达到模拟或实现人类的学习行为。机器学习的实现可分为两步：训练与预测，即归纳和演绎。
（3）神经网络与深度学习： 神经网络与深度学习是机器学习的一种算法，所以实现步骤与机器学习类似。神经网络是受到人类大脑的生理结构——互相交叉相连的神经元启发被提出，自1940s被首次提出至今经历了长期的发展。神经网络包含多个网络层，通过使用数据对各层各神经元的权重与阈值进行调整训练来拟合输入与输出的关系。而网络层数越多，能够拟合的关系越复杂，一般超过三层的神经网络就被称为深度神经网络，对应的实现过程就被称为深度学习。
1.2backbone与pretrain_model （1）backbone：网络模型的主干部分，如ResNet、VGGNet等，主要用于特征提取。通常是一些被证明特征提取效果好的成熟网络，将其接在自己网络中，并搭配pretrain_model，提升自己网络模型的效果。
（2）pretrain_model：使用backbone在一些官方大型图像数据集如ImageNet、MSCOCO、PASCAL VOC上训练好的模型，以pretrain_model作为自己搭建的网络的预训练模型，可以提升模型训练效果。
1.3batch_size、learning_rate、epoch与iteration batch_size、learning_rate、epoch属于模型训练的超参数，超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，设定一组最优超参数，以提高模型训练的性能。可以使用经验法则，在其他问题上使用复制值，或通过反复试验来搜索最佳值。
（1）batch_size：一次训练所选取的样本数。batch_size的大小影响模型的优化程度和速度，同时其上限会受到GPU内存的限制。
（2）learning_rate：网络模型每次参数更新的幅度，会影响模型训练的时间与模型收敛的效果。
（3）epoch：一次使用所有训练数据训练模型的过程。
（4）iteration：epoch除以batch_size就等于iteration，该参数并不是超参数。
1.4模型评价指标 模型训练完成后，需要对模型性能进行评价，以此确定是否已达到要求或需继续进行优化，模型评价指标较多，以下介绍几种常用的评价指标。
（1）混淆矩阵：绘制一个表格，表格每一行是真正的类别，每一列是预测的类别，这个列表矩阵即为混淆矩阵。例如在缺陷检测任务中，目标只分为两类，一类为1（合格品），一类为0（缺陷品），混淆矩阵如下：
TP：对合格品进行判定，将合格品判定为合格品，判断正确；
TN：对不合格品进行判定，将不合格品判定为不合格品，判断正确；
FP：对不合格品进行判定，将不合格品判定为合格品，判断错误；
FN：对合格品进行判定，将合格品判定为不合格品，判断错误。
（2）正确率或准确率（Accuracy）：对所有目标中所有类，判定正确的比例，公式如下
（3）平均正确率或准确率（Average per-class Accuracy）：对所有目标中每个类别分别计算准确率，然后取算术平均值，公式如下：
（4）精准率（Precision）：判定为合格品中，判定正确的比例，公式如下
（5）召回率（Recall）：针对合格品判定，判定正确的比例，公式如下
（6）PR曲线：理想情况下，精准率和召回率两者都越高越好。然而事实上这两者在某些情况下是矛盾的，精准率高时，召回率低；精准率低时，召回率高，可以通过观察PR曲线查看两者关系：
（7）交并比（Intersection over Union，IoU）：每个类中真实值和预测值都为真在真实值与预测值有一值为真的比例，公式如下：
在目标检测或语义分割任务中，IoU定义为两个矩形交集的面积/两个矩形的并集面积，两个矩形分别为预测框与标记框：
（8）平均精度（Average Precision，AP）：针对待检测所有目标中的某一类，计算平均精度。简单来说就是对PR曲线上的Precision值求均值。对于pr曲线来说，我们使用积分来进行计算。
在实际应用中，我们并不直接对该PR曲线进行计算，而是对PR曲线进行平滑处理。即对PR曲线上的每个点，Precision的值取该点右侧最大的Precision的值。详细计算说明可参考知乎目标检测中的AP，mAP
（9）平均精度均值（mean Average Precision，mAP）：是一个反映全局性能的指标，对待检测所有目标中的每一类计算平均精度，然后取均值。
二、官方数据集简介 2.1ImageNet数据集 ImageNet 是一个包含超过 1500 万张带标签的高分辨率图像的数据集，大约有 22,000 个类别，并在至少100万张图像中提供了边框。ImageNet包含2万多个典型类别，例如“气球”或“草莓”，每一类包含数百张图像。尽管实际图像不归ImageNet所有，但可以直接从ImageNet免费获得标注的第三方图像URL。官方网站：ImageNet。
AI研究员李飞飞从2006年开始研究ImageNet的想法。在大多数AI研究专注于模型和算法的时候，李飞飞则希望扩展和改进可用于训练AI算法的数据。2007年，李飞飞与普林斯顿大学教授克里斯蒂安·费尔鲍姆（Christiane Fellbaum）会面讨论了该项目，他是WordNet的创建者之一。之后李继续从WordNet的单词数据库开始构建ImageNet，并使用了其许多功能。作为普林斯顿大学的助理教授，李飞飞组建了一个研究团队，致力于ImageNet项目。他们使用Amazon Mechanical Turk来帮助分类图像。他们在2009年美国佛罗里达州举行的计算机视觉与模式识别会议（CVPR）上首次以学术海报的形式展示了自己的数据库。
2.2 ILSVRC竞赛 ILSVR（ImageNet Large Scale Visual Recognition Competition）是由ImageNet所举办的年度大规模视觉识别挑战赛，自2010年开办以來，全球各知名AI企业莫不以取得此项比赛最高名次为殊荣，以宣告其图像识别技术已达登封之境。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc312f673791a21cb93ee29c2b2a67f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1ef2cac2612e662f636bfba0a43800/" rel="bookmark">
			ArcGIS之字段计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FieldCalculator Python
本次技巧在ArcGIS字段计算器模式下进行，可快速实现字段数值处理，记录下来作为笔记以备以后查用方便，同时作为技术交流与大家分享，互相学习。
标题 01 顺序编号
a = 0
def num():
global a
a+=1
return a
结果:
num()
02 自动补齐数位 String(N - Len( [A] ),"0") &amp; [A] *N为所需位数。前面用0补齐。
03 保留小数位（四舍五入）
round（[N]，n），n为小数位
补充：
4. 数字转大写字母：chr([num]+64)
5. 数字转小写字母：chr([num]+96)
6. 计算几何面积：!Shape.Area！
7. 计算椭球体面积：!Shape.GeodesicArea!
8. 左侧提取字符：left([string],a)，a为所需字符数量
9. 右侧提取字符：right([string],a)，a为所需字符数量
10. 中间提取字符：mid([string],a,b)，a开始字符位置,b字符数量。 11. 合并属性字段：[A]&amp;[B]&amp;[C]
12. 删除属性字段多余空格：Replace([name]，“ ”，“”)
*所有标点符号均为英文格式。
作为ArcGIS应用笔记分享出来，后续大家在应用过程中如有问题，欢迎留言，同时也可以提出自己的需求，在下虽不才，但有意愿上下而求索。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/568bf1dec8b4b6fb26b0064aa705f7f8/" rel="bookmark">
			郑州大学编译原理实验四LR(0)分析算法JAVA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验四 LR分析方法的设计与实现（选做） 一、实验目的 通过LR分析方法的实现，加深对自下而上语法分析方法及语法分析程序自动生成过程的理解。
二、实验要求 输入上下文无关文法，对给定的输入串，给出其LR分析过程及正确与否的判断。
1．参考数据结构
typedef struct{/文法/
char head;//产生式左部符号
char b[20];//用于存放产生式
int point;
int lg;//产生式的长度
}regular;
typedef struct{
int l; //文法数量
int m; //vn 数量
int n; //vt 数量
regular re[20];
nfinal vn[20];//非终结符
final vt[20];//终结符
}condition;
condition cd[20];//项目
regular first[20];//产生式
2. 使用闭包函数（CLOSURE）和转换函数(GO(I,X))构造文法G’的LR(0)的项目集规范族。
构造LR（0）分析表
LR分析算法描述
5、对给定输入串输出其准确与否的分析过程。
package StringToJAVA; import javafx.util.Pair; import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.util.*; /** * @author [25'h] * @datetime 2022.11.03 */ public class LastReducing { public static List&lt;Node&gt; allNode = new ArrayList&lt;&gt;(); public static String startLabel;//开始符 public static ArrayList&lt;String&gt; terSymbol = new ArrayList&lt;&gt;();// 终结符 public static ArrayList&lt;String&gt; non_ter = new ArrayList&lt;&gt;();// 非终结符 public static HashMap&lt;String, List&lt;String&gt;&gt; formula = new HashMap&lt;&gt;();//产生式 public static List&lt;Pair&lt;String, String&gt;&gt; formulaList = new ArrayList&lt;&gt;();// 所有的推导式子，使用Pair对象存储 public static Integer[][] ACTION;// ACTION表格 public static Boolean[][] SorRActionTable;// 判断ACTION表是状态还是文法式子序号 public static Integer[][] GOTO;// GOTO表格 public static String objString;// 目标串 public static Node startNode;// LR分析表起始 public static Stack&lt;Integer&gt; conStack = new Stack&lt;&gt;();// 状态栈 public static Stack&lt;String&gt; subStack = new Stack&lt;&gt;();// 字符栈 public static void main(String[] args) { File file = new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/568bf1dec8b4b6fb26b0064aa705f7f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b7f17efc5050bc65a8fc16a69abca7/" rel="bookmark">
			郑州大学编译原理实验三算符优先分析算法JAVA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 实验目的 根据算符优先分析法，对表达式进行语法分析，使其能够判断一个表达式是否正确。通过算符优先分析方法的实现，加深对自下而上语法分析方法的理解。
二、 实验内容 1、输入文法。可以是如下算术表达式的文法（你可以根据需要适当改变）：
E→E+T|E-T|T
T→T*F|T/F|F
F→（E）|i
2、对给定表达式进行分析，输出表达式正确与否的判断。
程序输入/输出示例：
输入：1+2;
输出：正确
输入：(1+2)/3+4-(5+6/7);
输出：正确
输入：((1-2)/3+4
输出：错误
输入：1+2-3+(*4/5)
输出：错误
3、参考数据结构
char *VN=0,*VT=0;//非终结符和终结符数组
char firstvt[N][N],lastvt[N][N],table[N][N];
typedef struct //符号对(P,a)
{
char Vn;
char Vt;
} VN_VT;
typedef struct //栈
{
VN_VT *top;
VN_VT *bollow;
int size;
}stack;
4、根据文法求FIRSTVT集和LASTVT集
5、构造算符优先分析表
6、构造总控程序
7、对给定的表达式，给出准确与否的分析过程
8、给出表达式的计算结果。（本步骤可选作）
import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.util.*; /** * @author [25'h] * @datetime 2022.11.02 */ public class Reducing { public static String startLabel;//开始符 public static ArrayList&lt;String&gt; terSymbol = new ArrayList&lt;&gt;();// 终结符 public static ArrayList&lt;String&gt; non_ter = new ArrayList&lt;&gt;();// 非终结符 public static HashMap&lt;String, List&lt;String&gt;&gt; formula = new HashMap&lt;&gt;();//产生式 public static HashMap&lt;String, Set&lt;String&gt;[]&gt; firstvtAndLastvt = new HashMap&lt;&gt;();//FIRST 和 FOLLOW /* firstvtAndLastvt的数据含义： - key : 非终结符 - value : 非终结符对应的FIRSTVT 和 FOLLOWVT 集 - 1 非终结符对应的FIRSTVT - 2 非终结符对应的FOLLOWVT */ public static boolean[] booleansFirst;// 辅助变量 public static boolean[] booleansLast; public static String[][] table;//优先表 public static String objString;// 目标匹配字符串 public static LinkedList&lt;String&gt; deque; public static void main(String[] args) { File file = new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2b7f17efc5050bc65a8fc16a69abca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba4079350ff27974e3059762df95c59c/" rel="bookmark">
			Unity C# Microsoft.Common.CurrentVersion.targets(1177, 5): [MSB3644] 找不到 .NETFramework,Version
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity工程 编辑完C#代码编译后，莫名其妙出现整个工程C#都爆红出错，重新Build时出现错误日志
Microsoft.Common.CurrentVersion.targets(1177, 5): [MSB3644] 找不到 .NETFramework,Version=v4.7.1 的引用程序集。要解决此问题，请为此框架版本安装开发人员工具包(SDK/目标包)或者重新定向应用程序。可在 https://aka.ms/msbuild/developerpacks 处下载 .NET Framework 开发人员工具包
尝试安装NETFramework4.7.1不解决问题，最后发现日志中的重新定向应用程序，检查Unity的Edit-&gt;Preferences-&gt;ExternalToos-&gt;External Script Editor 发现没有选择Rider编辑器，重新选择一下，问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a27ce775750ab18c0b3666f8c5633ee/" rel="bookmark">
			郑州大学编译原理实验一词法分析器JAVA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 设计并实现一个包含预处理功能的词法分析程序，加深对编译中词法分析过程的理解。
二、 实验要求 实现预处理功能
源程序中可能包含有对程序执行无意义的符号，要求将其剔除。
首先编制一个源程序的输入过程，从键盘、文件或文本框输入若干行语句，依次存入输入缓冲区（字符型数据）；然后编制一个预处理子程序，去掉输入串中的回车符、换行符和跳格符等编辑性文字；把多个空白符合并为一个；去掉注释。实现词法分析功能
输入：所给文法的源程序字符串。
输出：二元组（syn,token或sum）构成的序列。其中，
syn为单词种别码。
Token为存放的单词自身字符串。
Sum为整型常量。
具体实现时，可以将单词的二元组用结构进行处理。待分析的C语言子集的词法(可以自行扩充，也可以按照C语言的词法定义)
1）关键字
main if then while do static int double struct break else long switch case typedef char return const float short continue for void default sizeof do
所有的关键字都是小写。
2）运算符和界符
± * / : := &lt; &lt;&gt; &lt;= &gt; &gt;= = ; ( ) #
3）其他标记ID和NUM
通过以下正规式定义其他标记：
ID→letter(letter|digit)*
NUM→digit digit*
letter→a|…|z|A|…|Z
digit→0|…|9…
4）空格由空白、制表符和换行符组成
空格一般用来分隔ID、NUM、专用符号和关键字，词法分析阶段通常被忽略。各种单词符号对应的种别码
表1 各种单词符号的种别码
单词符号 种别码 单词符号 种别码 main 1 ; 41 if 2 ( 42 then 3 ) 43 while 4 int 7 do 5 double 8 static 6 struct 9 ID 25 break 10 NUM 26 else 11 + 27 long 12 - 28 switch 13 * 29 case 14 / 30 typedef 15 : 31 char 16 := 32 return 17 &lt; 33 const 18 &lt;&gt; 34 float 19 &lt;= 35 short 20 &gt; 36 continue 21 &gt;= 37 for 22 = 38 void 23 default 39 sizeof 24 do 40 # 0 词法分析程序的主要算法思想
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a27ce775750ab18c0b3666f8c5633ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/385b0af14fcc3ccc3d4a5c525e69828a/" rel="bookmark">
			mongo实现批量更新数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mongo普通语句，只能实现全局批量更新，那么怎么实现批量实现数据呢？
mongo原生方式：
参考MongoDB Bulk批量操作 - MongoDB教程 - 一点教程
Bulk() — MongoDB Manual
使用initializeUnorderedBulkOp
var HexagonCasterNft = new Mongo.Collection("my_collection"); var bulkOps = HexagonCasterNft.rawCollection().initializeUnorderedBulkOp(); // mount是主键 mountArr，addressArr addressArr.forEach(function (addressItem, index) { bulkOps.find( { mount: mountArr[index] } ).update( { $set: {"userAddress":addressItem, "nftCreateTime": new Date().getTime()} } ); }) if (addressArr.length &gt; 0) { // 批量更新 bulkOps.execute(function(err, result) { if (!err) { console.log("批量更新成功"); } else { console.log("批量更新失败"); } }); } mongoose方式：
var bulkOps = []; mountArr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/385b0af14fcc3ccc3d4a5c525e69828a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2beceab3075ddd1728937ae0df7f2ac7/" rel="bookmark">
			C语言，Linux，贪吃蛇游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//贪吃蛇游戏
#include&lt;curses.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;pthread.h&gt;
#define UP 1
#define DOWN -1
#define LEFT 2
#define RIGHT -2
struct Snake//结构体（链表用）
{
int row;//行
int column;//列
struct Snake *next; };
struct Snake *head=NULL;//蛇尾，链表头
struct Snake *tail=NULL; //蛇头，链表尾
int key;//按键
int dir;//方向
int count=0;//计分用
int *pc=&amp;count;//计分用
struct Snake food;
void initFood()//食物初始化
{ int x=rand()%19;//随机数
int y=rand()%19;//随机数
food.row=x;
food.column=y;
}
int linkSnake(int i,int j)//蛇显示（gameBorder函数遍历时判断行列所在位置是否有蛇身）
{
struct Snake *p=head;
while(p!=NULL){
if(p-&gt;row==i &amp;&amp; p-&gt;column==j){ return 1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2beceab3075ddd1728937ae0df7f2ac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fd2f4220ad4def74c08d7f58b6e2fa7/" rel="bookmark">
			（电脑软件启动无法验证）win10专业版如何解决无法验证发布者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 出现这个问题 可能是 原因：
1、软件在下载安装过程中没有完成！
2、安装目录选择不正确
3、运行权限收限制
解决方法：
1、将出现提示的软件进行卸载再到官号重新下载安装
2、在安装软件时，部分小伙伴都是默认选择的安装目录，在这里建议更换安装的目录，软件安装在C盘外的盘符最佳！
3、如果是软件运行权限收限制，我们可以在可右键打开快捷方式属性，在“高级”标签页中，勾选“用管理员身份运行”点击应用后，再打开软件。
再或者win10的可以用下的方式尝试一下
win10系统使用过程中，发现win10系统经常会自动弹出“无法验证发布者”的提示窗口，遇见这样的情况总是令人很揪心，有没有什么好的方法可以解决无法验证发布者问题呢？下面就一起来看看解决无法验证发布者的方法。
1.使用组合快捷键win键+r键打开运行窗口，在打开的运行窗口中输入“regedit”回车确认打开注册表编辑器，在打开的注册表编辑器窗口中依次展开：HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Associations项（没有Associations项的用户可以新建一个Associations项）。
如下图所示
2.在Associations项右侧界面中，右键新建一个字符串值，并且将其命名为“LowRiskFileTypes”。如下图所示
3.双击打开LowRiskFileTypes，在弹出的编辑字符串窗口中将其数值数据修改为“.zip;.rar;.nfo;.txt;.exe;.bat;.vbs;.com;.cmd;.reg;.msi;.htm;.html;.gif;.bmp;.jpg;.avi;.mpg;.mpeg;.mov;.mp3;.m3u;.wav;”，点击确定完成操作。
如下图所示 如若不行 请关闭防火墙。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f1b40feee17003324ddbc8a29e49a6e/" rel="bookmark">
			MySQL查询计划key_len如何计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 key_len 解释key_len 规则key_len 实战鸣谢修订记录 最近在分析一个联合索引执行效率，其中key_len可以分析这个sql可以用到联合索引的哪些列。事后收集资料总结下。
key_len 解释 desc 中的 key_len 表示使用的索引长度，是以字节为单位。根据这个值，就可以判断索引使用情况，特别在使用联合索引的时候，判断有多少的索引字段能被查询用到。
key_len 规则 如果索引列是字符型，比如 CHAR(M) 类型占用空间为 M * Maxlen 。
字符型计算key_len需要考虑字符集，Maxlen 表示某个字符集中表示一个字符最多需要使用的字节数，utf8 Maxlen 为3，utf8mb4 Maxlen 为4。如果索引列是变长的(比如 varchar,varbinary)，则在索引列数据类型本身占用空间的基础上再加 2 ,比如 varchar(3) utf8mb4 not null，则实际占用空间是 3*4+2 = 14。如果索引列可以为空，则在索引列数据类型本身占用空间基础上加1。比如 varchar(3) utf8mb4 null，则实际占用空间是 3*4+2+1 = 15。 如果索引列是整数类型见下图：
如果索引列是日期和时间类型见下图，mysql版本也对存储空间有不同要求：
MySQL5.6.4及之后版本，TIME、DATETIME、TIMESTAMP这几种类型添加了对毫秒、微妙的支持。由于毫秒、微秒都不到1秒，所以也被称为小数秒，MySQL最多支持6位小数秒的精度，比如DATETIME(0)表示精确到秒，DATETIME(3)表示精确到毫秒，DATETIME(5)表示精确到10微秒。所以如果你在使用TIME、DATETIME、TIMESTAMP这几种类型的时候精确到了小数秒，那么需要额外的存储空间，不同的小数秒精度需要的存储空间不同，如下表：
如果索引列是浮点数类型见下图：
如果索引列是定点数类型：
DECIMAL(M, D) M指的是总的位数，D指的就是小数位数。M的范围是1 - 65，D的范围是0 - 30，且D的值不能超过M。 定点数是精确的小数，小数点前与小数点后的数字分开存储,且以9位数为1组,用4个字节保存,如果低于9位数,需要的字节数如下：
例如：
decimal(20,6)=&gt; 小数点左边14位,小数点右边6位 =&gt; 小数点左边分组为5 + 9,需要3个字节+4个字节存储,小数点右边一个分组,需要3个字节存储 =&gt; 总共需要10个字节
decimal(18,9)=&gt; 小数点左边9位数,小数点右边9位数 =&gt; 分别使用4个字节存储 =&gt; 共需要 8个字节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f1b40feee17003324ddbc8a29e49a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba0ecd66ca354cf6de6071ef356f051/" rel="bookmark">
			el-table 合并布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考地址
elementui中table的合计功能、以及合计行合并https://blog.csdn.net/m0_60622481/article/details/125632573element合并表格？https://blog.csdn.net/Dark_programmer/article/details/119805108
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5d04c990e706843fa0636e1988c7eb/" rel="bookmark">
			Py2neo:一种快速导入百万数据到Neo4j的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Py2neo:一种快速导入百万数据到Neo4j的方式 Py2neo是一个可以和Neo4j图数据库进行交互的python包。虽然py2neo操作简单方便，但是当节点和关系达几十上百万时，直接创建和导入节点、关系的方式会越来越耗时。本文提供一个py2neo小技巧，通过简单的代码，能够以每秒1万节点/关系的速度快速将数据导入Neo4j。
本文目录 Py2neo:一种快速导入百万数据到Neo4j的方式1、Neo4j与Py2neo2、Py2neo常规导入节点/关系到Neo4j的方法3、Py2neo快速导入节点/关系到Neo4j的方法4、Neo4j快速清库大量数据的方法总结 1、Neo4j与Py2neo 对于已构建知识图谱，通过可视化技术能够清晰、直观的呈现实体与实体之间的关系。Neo4j图数据库作为高性能和轻量级的知识存储与可视化工具，在实践中的应用越来越广泛。
Py2neo为python代码操作Neo4j提供了便利，简单好用，具体可访问其操作手册。
Neo4j官网
Py2neo手册
2、Py2neo常规导入节点/关系到Neo4j的方法 Py2neo导入知识图谱到Neo4j的一般方式是，利用Node和Relationship分别实例化节点和关系，然后利用Graph的create()方法创建相应的节点和关系，具体示例如下：
from py2neo import Graph, Node, Relationship if __name__ == '__main__': # 连接neo4j graph = Graph("http://localhost:7474", auth=("neo4j", "123456")) # 创建两个节点 node_1 = Node("py2neo", name="py2neo") graph.create(node_1) node_2 = Node("neo4j", name="neo4j") graph.create(node_2) # 创建两个节点之间的关系 relation = Relationship(node_1, "Subgraph()导入节点/关系就是快", node_2) graph.create(relation) 3、Py2neo快速导入节点/关系到Neo4j的方法 第2节中的方法对于少量数据速度尚可，但是不适合大数据量的情形。为此，可利用py2neo的Subgraph类构造子图，并在Transaction中批量创建节点和关系。此处详细文档可参考：详细文档
Py2neo批量创建节点/关系示例如下：
from py2neo import Graph, Subgraph, Node, Relationship def batch_create(graph, nodes_list, relations_list): """ 批量创建节点/关系,nodes_list和relations_list不同时为空即可 特别的：当利用关系创建节点时，可使得nodes_list=[] :param graph: Graph() :param nodes_list: Node()集合 :param relations_list: Relationship集合 :return: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e5d04c990e706843fa0636e1988c7eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db19832541a9614b10a9c72ef78bbfef/" rel="bookmark">
			MySQL库表结构和数据导出导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- [导出数据库] -- 导出dbname表结构 mysqldump -uroot -p123456 -d dbname &gt; dbname.sql -- 导出dbname表数据 mysqldump -uroot -p123456 -t dbname &gt; dbname.sql -- 导出dbname表结构和数据 mysqldump -uroot -p123456 dbname &gt; dbname.sql -- [导出数据库中指定表] -- 导出dbname下的test表结构 mysqldump -uroot -p123456 -d dbname test &gt; test.sql -- 导出dbname下的test表数据 mysqldump -uroot -p123456 -t dbname test &gt; test.sql -- 导出dbname下的test表结构和数据 mysqldump -uroot -p123456 dbname test &gt; test.sql -- 创建数据库 create database dbname; -- 数据导入 mysql -uroot -p123456 dbname &lt; dbname.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db19832541a9614b10a9c72ef78bbfef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b375bac613862ffd95890471b3d19ec8/" rel="bookmark">
			MySQL设置远程访问权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在日常开发中；需要连接其他同事的数据库或者其他服务器的数据库；可能会出现以下情况
我们输入的用户和密码都正确；但是提示我们用户没有权限；这个用户指的是远程连接的电脑ip没有访问权限；不是mysql的用户没有权限
意味着该用户访问mysql被拒绝；也就是该用户所在的ip没有访问权限
我们可以按照以下步骤；设置mysql服务的信息
第一步在mysql所在目录打开cmd进入黑窗口
1：输入用户名 mysql -u root -p
2 ：输入密码
3：打开mysql的数据库 ：====》输入指令
show databases
4： 我们会发现有一个名为mysql的数据库；进入该数据库；输入指令 use mysql
5：输入以下指令==》 OPTION后面的;也要带上
GRANT ALL PRIVILEGES ON . TO ‘root’@‘%’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION;
这句话是允许所有ip都可以连接到此mysql服务器
‘%’ 指所有ip都可远程连接此电脑。如果%变成ip 仅指定该ip可以远程连接至此电脑
6：刷新指令 flush privileges;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046f839294272439f5db1997957074b4/" rel="bookmark">
			Python基于改进Unet的新冠肺炎等级分割系统（源码＆教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.研究背景 新冠肺炎给人类带来极大威胁,自动精确分割新冠肺炎CT图像感染区域可以辅助医生进行诊断治疗,但新冠肺炎的弥漫性感染、感染区域形状多变、与其他肺部组织极易混淆等给CT图像分割带来挑战。为此,提出新冠肺炎肺部CT图像分割新模型XR-MSF-Unet,采用XR卷积模块代替U-Net的两层卷积,XR各分支的不同卷积核使模型能够提取更多有用特征;提出即插即用的融合多尺度特征的注意力模块MSF ,融合不同感受野、全局、局部和空间特征,强化网络的细节分割效果。在COVID-19 CT公开数据集的实验表明:提出的XR模块能够增强模型的特征提取能力,提出的MSF模块结合XR模块,能够有效提高模型对新冠肺炎感染区域的分割效果;提出的XR-MSF-Unet模型取得了很好的分割效果,其Dice,IOU 、F1-Score和Sensitivity指标分别比基模型U-Net的相应指标高出3.21、5.96,1.22和4.83个百分点,且优于同类模型的分割效果,实现了新冠肺炎肺部CT图像的自动有效分割。
2.图片演示 3.视频演示 Python基于改进Unet的新冠肺炎等级分割系统（源码＆教程）_哔哩哔哩_bilibili
4.U-Net网络简介 传统语义分割采用基于颜色、形状等低级语义信息P,无法很好分割复杂图像。深度学习技术使用高级语义信息进行分割。2015年,Long等人P3首次使用全卷积神经网络对自然图像进行端到端分割,实现了从传统方法到深度学习方法的突破。2015年Ronneberger等人"在全卷积神经网络基础上提出U-Net结构,在ISBI细胞分割挑战赛中获得第一名。U-Net网络包含编码和解码两部分,编码器进行下采样操作,提取原始图像空间特征,解码器进行上采样操作,根据编码器所提取的空间特征构造出图像。为了防止对应特征丢失,对应编码器和解码器之间有跳跃连接。U-Net的编码器采用两层3x3卷积、ReLU激活函数和2×2最大池化,来提取图像特征,共进行4次下采样,该过程降低特征图尺寸,增加通道数,最终通道数为原来的16倍。解码器部分使用2×2反卷积进行上采样,减少通道数,逐渐恢复特征图尺寸。然而,新冠肺炎CT图像十分复杂,U-Net在编码器每一个阶段仅使用普通的两层卷积和池化操作来提取特征,相较于经过设计的卷积组合,这样的特征提取方式容易导致模型无法提取到全部有用的特征信息,甚至还会有一部分特征在这个过程中丢失。此外,U-Net的解码器在逐步恢复图像时也采用简单的两层卷积和反卷积进行,这样又会导致一定的特征信息损失,最终使得网络无法完全恢复图像的复杂特征信息。另外,U-Net没有考虑全局、局部和不同空间位置的特征差异。为了提取新冠肺炎CT图像的复杂特征,提升对该类CT图像感染区域分割的准确性,本文将对U-Net的特征提取结构进行改进。
5.多尺度特征融合注意力模块 MSF 新冠肺炎感染区域大多为弥漫性感染,整幅图像中各个角落都可能存在感染区。卷积感受野大小决定特征关注区域大小,感受野过大或过小可能会使CT图像部分感染区域被分割错误。另外,新冠肺炎感染区域位置不定,形状复杂,极易与其他肺部结构混淆,因此,为使模型能发现感染区域并增加其发现感染区域的能力,提出如图所示的融合多尺度特征的即插即用注意力模块MSF(multi-scale features fusionmodule)。
为了避免感受野不同给模型特征提取带来的问题,MSF模块使用3×3、5×5和7×7三种不同大小感受野的卷积核以并行的方式提取特征,这三种不同大小的卷积核分别具有小、中、大三种不同大小的感受野,提取的特征分别经过批归一化BN和ReLU激活后进行特征融合,这样并行的特征提取策略可以最大程度地减少串行卷积带来的特征损失,可以保证融合后的特征图中尽可能多地包含图像的各种特征信息。之后,融合的特征分别经过全局注意力模块(global attention module, GAM)和空间注意力模块(spatial attention module, SAM)构成的一个分支以及局部注意力模块(local attention module ,LAM)和空间注意力模块SAM构成的另一个分支,最后将两支注意力模块特征加和,实现不同大小感受野、全局、局部和不同空间特征的融合,使最终输出的特征图包含不同尺度和位置的信息,从各种维度最大限度保证模型提取到图像更多的特征信息。
假设输入通道数、高、宽分别为C、H和W的特征图F=RC×H*W,图3融合不同大小感受野的特征F’可表达为式(1)。其中,Conv"差XI”表示大小为m×m 、步长为stride的卷积。特征F′分别经过全局注意力模块GAM和局部注意力模块LAM,得到式(2)和式(3)的特征F。和F，。特征F。和F,分别经过空间注意力模块SAM融合位置信息,然后对应分量加和得到式(4)融合不同感受野、关注全局、局部细节信息以及空间位置的新特征图NF.
6.新冠肺炎分割数据集（2937张专业标注＆文末附下载链接） 使用该博客分享的包含约60名新冠肺炎患者的共100张轴向CT图像和放射科医生对这100张CT图像感染区域的标注图像。COVID-19-2数据集由Radio-paedia 的9个不同病例的共829张轴向二维CT切片组成,其中有373张为新冠肺炎切片,由放射科医生进行了感染区域的分割标注,原始数据格式为NIFTI。COVID-19-3数据集由Coronacases Initiative和 Radiopaedia的20个不同病例的共1844张新冠肺炎CT切片组成,感染区域由有经验的放射科医生进行标注。COVID-19-4数据集来源于俄罗斯莫斯科市立医院,包含2937个病例的肺部CT图像,本文使用的为来自其中50个病例的有专家标注图像感染区域的785张确诊新冠肺炎CT图像。
7. MSF模块的特征加和权重测试和训练结果 参考该博客提出的MSF模块对经过SAM模块的融合全局与空间信息的特征图FC。和融合局部信息与空间信息的特征图Fs的对应元素相加得到融合特征。为了确定Fc和Fs这两个特征图加和时的权重比,分别对这两个特征赋予不同权重进行加和,测试对U-Net模型性能的影响。实验结果如表所示,加粗表示最好结果。
实验结果显示,当两部分特征图加和时的权重比为1∶1时,MSF模块能提取到分割性能最好的特征。当两部分特征图的权重比分别为2:3、3∶7和1∶4时,MSF模块获得的特征的分割性能非常差,各项分割指标基本趋于0,而当权重比为3∶2、4∶1、7:3时，MSF模块提取的特征的分割性能优于相反的权重比,说明Fes特征对MSF模块提取的特征的分割性能影响较大。
8.代码实现 class Decoder(nn.Module): def __init__(self, in_channels, middle_channels, out_channels): super(Decoder, self).__init__() self.up = nn.ConvTranspose2d(in_channels, out_channels, kernel_size=2, stride=2) self.conv_relu = nn.Sequential( nn.Conv2d(middle_channels, out_channels, kernel_size=3, padding=1), nn.ReLU(inplace=True) ) def forward(self, x1, x2): x1 = self.up(x1) x1 = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/046f839294272439f5db1997957074b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b253b3f464d805f9a43a6b46e32463/" rel="bookmark">
			Linux同步时间的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：非生产时使用 第一种是在所有机器上，使用连接工具的并发命令功能，同时运行修改时间命令，比如执行date -s “2019-05-25 17:00:00” ，这个方法适合自己测试环境用
第二种就是安装了一个ntpdate命令，然后同步时间的master是一个所有人都可以用的master
安装工具 yum -y install ntp ntpdate 同步网络时间 ntpdate cn.pool.ntp.org 方法二：NTP服务 使用ntpd server，为多台机器同步时间，这里以三台机器为例
第一步：在三台机器上运行ntpdate命令，验证是否安装有ntpdate，如果没有运行yum -y install ntp安装该服务
第二步：选出一台机器，做master，编辑它的/etc/ntp.conf文件
进入配置文件之后，首先将配置文件中所有的restrict开头的行注释掉，如下面这种
其后另写一条生效的服务配置
restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap 格式：restrict 允许的ip范围一般默认就行 mask 允许同步的网段子网掩码 nomodify notrap 将所有server开头的行全部注释，添加如下的新信息
server 127.127.1.0 fudge 127.127.1.0 stratum 10 第三步：master启动ntp服务并开机自启
service ntpd restart chkconfig ntpd on 第四步：所有子节点运行命令，同步master的时间。
ntpdate master节点ip 如果子节点运行命令之后，如果提示no server那就等两分钟左右在在运行 如果提示`the NTP socket is in use, exiting`说明当前子节点的ntp服务启动了，你要关掉它 第五步：让集群自己同步时间，有两种方式
第一种方式：通过crontab来完成同步，推荐这种，容易控制时间同步频率 所有子节点配置定时任务，半分钟同步一次，命令如下： crontab -e 上面的命令会打开linux自带的定时任务列表在其中添加如下一条信息： 30 * * * * /usr/sbin/ntpdate master的ip或域名 &gt;&gt; /root/ntpdate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b253b3f464d805f9a43a6b46e32463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eb0b81420b989234fe7810730409aba/" rel="bookmark">
			银河麒麟V4服务器升级openssh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先添加源地址
vi /etc/apt/sources.list
deb http://archive.kylinos.cn/kylin/KYLIN-ALL 4.0.2sp2-server-ft2000 main restricted universe multiverse
第一步：
#卸载原openssh
apt-get remove openssh-server openssh-client
#安装 libpam0g-dev
apt-get install libpam0g-dev
第二步：
正式开始安装openssl和openssh，在各个官网下载openssl,openssh和zlib的源码包。
1.安装zlib
tar -xvzf zlib-1.2.11.tar.gz cd zlib-1.2.11
./configure --prefix=/usr/local/zlib
make &amp;&amp; make install
2.升级openssl
tar -xvzf openssl-1.0.2o.tar.gz （换成你自己下载包的名称，具体的版本可能不一样）
cd openssl-1.0.2o
./config --prefix=/usr/local/openssl shared zlib #一定要加上shared 参数，要不在安装openssh的时候就无法找到,最好指定安装路径，不然找不到安装好的openssl在哪
make &amp;&amp; make install
#备份原来的openssl
mv /usr/bin/openssl /usr/bin/openssl.bak
mv /usr/include/openssl /usr/include/openssl.bak
#因为源码安装默认安装的位置是 /usr/local/openssl 需要将创建软链接到系统位置
ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl
ln -s /usr/local/openssl/include/openssl /usr/include/openssl
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eb0b81420b989234fe7810730409aba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c02752cf5da19da7d46f2b97f0671fc/" rel="bookmark">
			jquery---动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、隐藏与显示
1.show显示
show() 只适用于通过 jQuery 方法和 CSS 中 display 属性隐藏的元素，不适用于通过 visibility 隐藏的元素。
$().show(speed, easing, callback); 2.hide隐藏
$().hide(speed, easing, callback); 二、淡入淡出
1.fadeIn淡入，让不透明度从0到1
2.fadeOut淡出，让透明度从1到0
// 淡入 $().fadeIn(speed, easing, callback); // 淡出 $().fadeOut(speed, easing, callback); 三、自定义动画animate
$().animate({ style }, speed, callback); style 是样式属性列表，speed 是动画持续的时间，callback 是动画结束后所执行的函数。 $(".btn2").click(function () { // 元素的宽度变为 300 个像素 $("div").animate({ width: "300px" }); }); 四、队列动画（执行多个动画效果）
$().animate().animate()....animate(); 执行完前边的再执行后边的，具有顺序，在animate中写多个属性的时候是同时执行的，所以需要区别。
五、回调函数callback
$().animate({ style }, speed, callback); 回调函数是在animate执行之后再执行的。
六、停止动画stop
打断动画的执行
$().stop(stopAll, goToEnd); 七、延迟动画deplay
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c02752cf5da19da7d46f2b97f0671fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d410f348b686a8962d94a1a01dedfaf2/" rel="bookmark">
			软考高项——计算专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可用性 项目整体管理 项目选择方法 1. 净现值分析（Net Present Value，NPV） t 表示现金流的持续时间，A表示每年的现金流量，r是折现率（贴现率）。
记住下面计算公式，如果折现率是10%，顺便记住下面数字，如果不是10%则带入计算。
第一年的折现因子为 1/1.1，折现就是A*0.91
第二年的折现因子为1/1.21，折现为A*0.83
第三年的折现因子为1/1.33，折现为A*0.75
第四年的折现因子为1/1.46，折现为A*0.68
第五年的折现因子为1/1.61，折现为A*0.62
A为（成本 + 收益），注意成本应加上负号。
举例：
注意：投资金额相同，时间相同的情况下，净现值越大越好。 2.投资收益率分析（ROI，Return on InvestMent） ROI= （总的折现收益一总的折现成本）／折现成本。 画表格： 201620172018201920202021收入6666支出121.51.51.51.5现金流-124.54.54.54.5 1. 投资回收期
2016年算为0年，第三年2019年收回9万，还差3万，3/4.5 = 1.67， 静态投资回收期为3.67。D
2. 投资收益率
总成本：18
总收益：24
ROI = (24 - 18) / 18 = 0.33; B
3.投资回收期分析 当累计折现成本减去累计折现收益开始大于0时，回收就完成了。
注意区分动态回收期和静态回收期（不需要折现）。
举例：
根据上图可以画出下面的表：
0一二三四五1000-1000300300300300300 第三年收回900，还差100，100/300 = 0.3，所以静态投资回收期为3.3，答案是D。
这题是求动态投资回收期的，需要折现。
注意这题的初期投资，不算是一年答案是B。
2011年置为0年
注意：计算过程中要四舍五入。
4 投资回收率分析 进度管理 衡量项目规模 用 LOC (Line of Code ）衡量项目规模。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d410f348b686a8962d94a1a01dedfaf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025a39a012c8f63561151aba9b9c40ab/" rel="bookmark">
			IDEA必备的10款插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Vuesion Theme
2、lombok
3、File Expander
4、GitToolBox
5、Maven Helper
6、Translation
7、arthas idea
8、Free Mybatis plugin
9、VisualGC
10、CheckStyle-IDEA
1、Vuesion Theme 颜值是生产力的第一要素，IDE 整好看了，每天对着它也是神清气爽，有木有？就 Intellij IDEA 提供的暗黑和亮白主色，虽然说已经非常清爽了，但时间久了总觉得需要再来点新鲜感？
Vuesion Theme 这个主题装上后，你会感觉整个 Intellij IDEA 更高级了。
安装完插件就立马生效了，瞧这该死的漂亮，整个代码着色，以及文件的图标，都更炫酷了：
2、lombok 可能提到 lombok，多多少少有些争议，但不得不说，这玩意的确是很能省代码，并且很多开源的第三方 jar 包，以及 Intellij IDEA 2020.3 以后的版本也都默认加了 lombok。
这么多注解可以选择，在写 VO、DO、DTO 的时候是真的省心省力。
如果没有 lombok 的帮助，那整个代码就要炸了呀。对比一下，是不是感受还挺明显的？
当然了，要使用 lombok，你得在 pom.xml 文件中引入 lombok 的依赖包。
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 3、File Expander 这个插件不仅可以反编译，还可以打开 tar.gz，zip 等压缩文件，
如果有小伙伴反驳说自己不装插件也可以打开 jar 包里的代码，那是因为你的 jar 在 classpath。如果单独打开一个 jar 包，不装插件是看不了的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/025a39a012c8f63561151aba9b9c40ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df645a8d15c2744add9c82b5f3fbfeaf/" rel="bookmark">
			Java对象传递和返回的细节问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.传递引用2. 创建本地副本2.1 值传递2.2 对象克隆2.3 浅拷贝问题2.4 深拷贝2.4.1 引用类型逐个浅拷贝2.4.2 序列化方式进行深拷贝 1.传递引用 在一个方法中将一个对象的引用传递给另外一个方法，引用指向的对象是同一个 public class Person { int age; String name; public Person(int age, String name) { this.age = age; this.name = name; } public static void main(String[] args) { Person p=new Person(18, "tom"); System.out.println("main: "+p); f(p); } public static void f(Person p) { System.out.println("f(): "+p); } } 引用别名
public static void main(String[] args) { Person p=new Person(18, "tom"); Person p2=p; p2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df645a8d15c2744add9c82b5f3fbfeaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab509e33dfb98726880981f2d65b96b/" rel="bookmark">
			【项目设计】基于HLW8110计量芯片的电量计设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.原理图 原理图如下所示：
二.PCB部分 三. 实物示意图 文章内容将在后续逐步完善，需要相关实物，亦或是任何技术问题。欢迎私信本人，CSDN@风雨同舟1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4026adc33fd00ada51e77b590daac97e/" rel="bookmark">
			利用malloc函数分配二维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用malloc()函数分配的内存是连续的的，我们可以先分配二维数组的行（即行指针），然后利用分配的行指针，再分配列指针。咱们以分配一个4x5的二维数组为例，如下图（）：
1、先分配连续的4块内存作为行，这些分配内存是连续的，并将S指向它
S = (char**)malloc(sizeof(char*) * row); 2、利用之前分配好的4块内存，每块内存（即对应的行）再分配5块内存作为列，每行指向对应分配好的5块内存（相当列）
for (i = 0; i &lt; row; i++) S[i] = (char*)malloc(sizeof(char) * col); 注：每一行分配的内存是连续，但相邻两行的内存不一定连续（由于每次用malloc()给一行分配内存（这行内存分配的内存是连续的），下一次给下一行分配内存，不一定紧接着上一行最后的内存的地址，故相邻两行的内存不一定连续，即整体不连续）
3、测试程序
/*获取的二维数组，只有一行一行是连续的，但整体不是连续的*/ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { char** S; int row, col, i, j; printf("请输入你需要创建的二维数组的行和列！！！\n"); printf("请输入行："); scanf("%d", &amp;row); printf("请输入列："); scanf("%d", &amp;col); /*利用malloc申请内存*/ S = (char**)malloc(sizeof(char*) * row); // 分配行 for (i = 0; i &lt; row; i++) S[i] = (char*)malloc(sizeof(char) * col); // 分配列 for (i = 0; i &lt; row; i++) { for (j = 0; j &lt; col; j++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4026adc33fd00ada51e77b590daac97e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1873f97ab26c67d236f445f34da1248a/" rel="bookmark">
			mybatis缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、mybatis缓存机制 mybatis为减轻数据库压力，提高数据库性能。提供了两级缓存机制：
一级缓存：
SqlSession级别的缓存，缓存的数据只在SqlSession内有效。
一级缓存mybatis已近为我们自动开启，不用我们手动操作，而且我们是关闭不了的！！但是我们可以手动清除缓存。
一级缓存是sqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个基于 PerpetualCache的HashMap本地缓存数据结构，用于缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互不影响的。
二级缓存：
mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的。
二级缓存需要我们手动开启。
二级缓存（全局级别） 是mapper级别的缓存，多个sqlSession去操作同一个Mapper的sql语句，多个sqlSession可以共用二级缓存，二级缓存是跨sqlSession的。
2、一级缓存 一级缓存原理：
第一次查询用户id为1的用户信息，先去缓存中查询是否有id为1的用户信息，如果没有，从数据库中查询用户信息。得到用户信息后再将用户信息储存到一级缓存中。如果sqlSession去执行commit 操作（插入、更新、删除），就会清空sqlSession中的一级缓存，保证缓存中始终保存的是最新的信息，避免脏读。第二次查询用户id为1的用户信息，先去缓存中查询是否有id为1的用户信息，如缓存中有，直接从缓存中获取。注意：两次查询须在同一个sqlsession中完成，否则将不会走mybatis的一级缓存。在mybatis与spring进行整合开发时，事务控制在service中进行，重复调用两次servcie将不会走一级缓存，因为在第二次调用时session方法结束，SqlSession就关闭了 注意事项：
mybatis默认是开启一级缓存，不需要配置如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前SqlSession缓存中的所有缓存数据，这样可以保证缓存中存的数据永远和数据库中一致，避免出现脏读一个SqlSession结束后那么它里面的一级缓存也就不存在了。mybatis的缓存是基于 [ namespace:sql语句:参数 ] 来进行缓存的。意思就是，SqlSession的HashMap存储缓存数据时，是使用 [ namespace:sql:参数 ] 作为key，查询返回的语句作为value保存的。 3、二级缓存 二级缓存与一级缓存原理相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper ( Namespace )，并且可自定义存储源，如 Ehcache。作用域为 namespance 是指对该 namespance 对应的配置文件中所有的 select 操作结果都缓存，这样不同线程之间就可以共用二级缓存。
二级缓存是基于映射文件的缓存（namespace），缓存范围比一级缓存更大，不同的SQLSession可以访问二级缓存的内容。哪些数据放入二级缓存需要自己指定
二级缓存可以设置返回的缓存对象策略：
readOnly=“true”（只读）：MyBatis 认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。MyBatis 为了加快获取数据，直接就会将数据在缓存中的引用交给用户 。不安全，速度快。readOnly=“false”（读写，默认）：MyBatis 觉得获取的数据可能会被修改，MyBatis 会利用序列化或反序列化的技术克隆一份新的数据。安全，速度相对慢。 二级缓存的具体流程：
当一个sqlseesion执行了一次select后，并关闭此session的时候，就会将查询结果存储到二级缓存中当另一个sqlsession执行相同select时，首先会查询二级缓存，二级缓存中无对应数据，再去查询一级缓存，一级缓存中也没有，最后去数据库查找，从而减少了数据库压力提高了性能 注意事项:
如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前mapper缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读mybatis的缓存是基于[ namespace:sql语句:参数 ]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[ namespace:sql:参数 ]作为key，查询返回的语句作为value保存的。开启了二级缓存后，还需要将要缓存的pojo实现Serializable接口，为了将缓存数据取出执行反序列化操作 4、开启mybatis二级缓存 4.1.1、通过application.yml配置二级缓存开启 # mybatis相关配置 mybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启MyBatis的二级缓存 cache-enabled: true 4.1.2、通过MyBatis配置文件开启二级缓存【在MyBatis-config.xml 文件中添加如下代码】 &lt;setting name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1873f97ab26c67d236f445f34da1248a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7c2e10f3a6e6c09be81835eb03c266/" rel="bookmark">
			Mac 安装 vue 环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 nodejs 首先，安装 nodejs，官网下载node：https://nodejs.org/zh-cn/
接下来，安装下载下来的软件包：
安装完成后，在终端输入 node -v 查看是否安装成功：
安装 cnpm 终端输入：
sudo npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成：
通过查看版本号查看安装状态：cnpm -v
安装 webpack 获取权限 在mac下依赖包要写入系统重要文件夹里，需要先获取root权限，所以先在命令行输入sudo -s后，再输入电脑密码
安装 webpack 然后，终端输入：
npm install webpack -g 安装完成：
安装vue-cli脚手架 终端输入：
npm install vue-cli -g 安装完成：
查看版本号 ：
vue -V 如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7205ed0f498f0264f6d56df808296d3b/" rel="bookmark">
			vue11Vuex解说&#43;子父传参详细使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. vue组件间通讯
1.1 父子组件
1.2 消息总线
1.3 vuex
2. vuex使用
2.1 简介
2.2 安装
2.3 创建store模块
2.4 创建vuex的store实例并注册上面引入的各大模块
2.5 在main.js中导入vuex
3. 将折叠和展开效果使用vuex实现
3.1 在state.js中声明全局参数
3.2 设置全局参数
3.3 Main.vue组件
3.3.1 直接通过state获取状态值
3.3.2 getter方式获取store中的值
3.4 LeftAside.vue组件
4. 异步处理
4.1 异步修改参数
5. 异步调用后台方法
6. Vuex的常用辅助函数
7. vuex的模块化
8. vuex状态持久化
1. vue组件间通讯 1.1 父子组件 父组件--&gt;子组件，通过子组件的自定义属性：props子组件--&gt;父组件，通过自定义事件：this.$emit('事件名',参数1,参数2,...); 1.2 消息总线 这种方式需要另外创建一个vue实例，用来当做消息总线
1.3 vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。可以想象为一个“前端数据库”（数据仓库）， 让其在各个页面上实现数据的共享包括状态，并且可操作。
Vuex分成五个部分：
1.State：单一状态树
2.Getters：状态获取
3.Mutations：触发同步事件
4.Actions：提交mutation，可以包含异步操作
5.Module：将vuex进行分模块
2. vuex使用 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7205ed0f498f0264f6d56df808296d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60019c623d584d8b1f8cf2fa6ca2d21d/" rel="bookmark">
			FlinkSql的窗口使用以及运用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 flinkSQL窗口概述 1.1 窗口定义: 可理解为时间轴，可将无界流切分成有界流
1.2 窗口分类： TimeWindow：通过时间切割窗口，但是不知道窗口有多少数据 滑动窗口
滚动窗口
会话窗口
CountWindow：按照数据量来切割窗口 滑动窗口滚动窗口会话窗口 自定义窗口 1.3 TimeWindow分类 滚动窗口：有固定的窗口长度往前进行滚动，数据不重复计算
滑动窗口：由固定的窗口长度和滑动间隔组成，数据可以重复
会话窗口：由一系列事件指定事件长度间隙组成，类比wed应用的session
group windows
键控window：keyvalue非键控window 2 flinkSQL窗口使用 2.1 窗口函数类型 flinkSQL中通过Groupby Windows函数来定义分组窗口
TUMBLE(time_attr,interval)：定义滚动窗口HOP(time_attr,interval,interval)：定义滑动窗口，第二个参数表示滑动步长，第三个参数表示窗口大小SESSION(time_attr,interval)：定义会话窗口 2.2 滚动窗口案例 数据 data_time,price,product_id,buyername 1666620609,44,1,白天磊 1666620610,45,1,陈智渊 1666620611,46,1,崔钰轩 1666620612,47,1,吴鹏飞 1666620613,48,1,毛明辉 1666620614,49,1,侯弘文 1666620615,50,1,曾伟祺 1666620616,51,1,郝瑞霖 1666620617,52,1,陆熠彤 1666620618,53,1,余弘文 1666620619,54,1,石哲瀚 1666620620,55,1,任擎苍 1666620621,56,1,卢文轩 1666620622,57,1,吕晋鹏 1666620623,58,1,罗晟睿 1666620624,59,1,周建辉 1666620625,60,1,卢皓轩 1666620626,61,1,沈煜城 1666620627,62,1,万鑫鹏 1666620628,63,1,沈思远 需求 上表是product_id为1的商品被不同的用户在不同的时间下单以及金额数据，使用flinkSQL当中当中的滚动窗口计算：每隔2秒钟的金额的最大值 代码实现 定义Userproduct类定义字段 //使用插件生成有无参构造器以及重写一些方法 @Data//完成了Getter,Setter,equals,hasCode,toString 等方法 @Builder//省去写很多构造函数的麻烦 @NoArgsConstructor//自动添加一个无参构造函数 @AllArgsConstructor//为自动添加一个构造函数 public class Userproduct { private Integer product_id; private String buyer_name; private Long date_time; private Double price; } 构造执行环境 StreamExecutionEnvironment senv = StreamExecutionEnvironment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60019c623d584d8b1f8cf2fa6ca2d21d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93a0795ab4f717f7d8ea8c9ab3f18ac/" rel="bookmark">
			高校实验室设备预约管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开放管理
建立实验室区域、楼层、房间号、设备名称数量等基础信息，可灵活设置实验室的开放规则、开放时间，如：学期、月、周、日、时间段等；
二、预约管理
1、注册登录
（1）实验老师批量导入学生信息；
（2）学生注册、实验老师审核通过后登录；
2、预约申请
学生可查询已经开放的教学实验资源，并根据自己的课时安排进行开放实验预约；
3、预约审核
教学实验中心或教务处或实验室管理员对学生申请预约实验室进行审核；
4、预约实验室
按照预约时间预约人刷脸或刷卡进入实验室上课；非预约人、非授权时间任何人刷脸/刷卡门禁不能打开，管理员除外；
5、预约设备
进入实验室后，再次刷脸或刷卡设备通电开始做实验，做完实验后可提前断电或到时系统自动断电；
6、预约查询
学生可查询开放实验室预约申请是否通过审核。若通过审核则按时到实验室参加实验；若未通过审核可查询其原因；
7、暂停预约
可设置若 N 次失约，冻结账户，须向管理员申请审核后开通；
三、智能排课
1、预约后系统自动生成实验室预约时间状态表；
2、实验预约排课功能，对预约实验室一目了然，系统能够检测学员预约课程是否存在冲突，审核学员预约课程 ，然后自动生成排课表；
3、同时可以与手机端同步，减少沟通成本，大大提高学校管理效率。
四、电子班牌
电子班牌可显示当前实验室名称、预约人数、预约开始结束时间、实验内容以及通知公告；
五、结算管理
通过公式计算自动生成设备使用缴费明细，内部人员可自动从项目或导师账户扣减金额，外部访客人员可发送消息通知结算；
六、移动端
支持小程序或校微信公众号，盛元广通实验室预约系统智能手机预约端分学生和老师两种角色，分别持有不同权限；
1、学生端
（1）学生通过该系统来预约实验室，老师审核通过后即可预约实验室做实验：
（2）支持查看实验室及设备预约信息，实验室开放时间、实验室预约情况等；
容许提前 N 天取消预约
2、实验员管理员/实验教师端：
（1）对所管辖实验室学生的预约进行审核；
（2）实时查看实验室预约情况，对实验预约进行修改。增删等权限；
3、支持移动端远程门禁开锁、查看实验室视频监控、远程操控实验室照明电源、动力电源回路、设备通断电。
七、统计分析 盛元广通高校实验室设备预约管理系统实时追踪记录实验室预约使用情况，能够让管理者方便直观的了解实验室的使用情况，自动生成统计数据报表及统计图表；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c889bd754eba32d3286bf8f295d4493f/" rel="bookmark">
			OpenFeign详细使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Feign 是由 Netflix 团队开发的一款基于 Java 实现的 HTTP client，借鉴了 Retrofit、 JAXRS-2.0、WebSocket 等类库。通过 Feign，我们可以像调用方法一样非常简单地访问 HTTP API。 OpenFeign是spring cloud在Feigh的基础上支持了springmvc的注解，如果@RequseMappering等等。OpenFeign的@FeignClient可以解析springmvc的@REquestMappering注解下的接口，并通过动态代理的方式产生实现类实现类中作负载均衡并调用其他服务 OpenFeign内含有ribbon负载均衡
使用 添加注解
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 主启动类上添加@EnableFeignClients
添加接口加注解
@Component @FeignClient(value = "CLOUD-PAYMENT-SERVICE")//server的名称 public interface PaymentService { @GetMapping( "/payment/get/{id}") public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable("id") Long id); ​ } controller层
@RestController @Slf4j public class OrderController { ​ @Resource private PaymentService paymentService; @GetMapping( "/consumer/payment/get/{id}") public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable("id") Long id){ return paymentService.getPaymentById(id); } } 可以像调用方法一样调用服务，不用spring的层层包装
而且自带负载均衡（ribbon）
openfeign超时控制 默认等待一秒超过一秒则报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c889bd754eba32d3286bf8f295d4493f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4732e195de4a4f675f4f2a37d29aefb/" rel="bookmark">
			在Windows电脑上修改图片内存大小的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在网上进行一些报名操作时一般都会需要我们提供个人证件照，但是通常还会对证件照的内存占用大小进行限制，下面小编分享一下在电脑上修改证件照内存占用大小的方法：
1.找到需要修改大小的照片，鼠标右击照片打开快捷菜单，点击“打开方式——画图”。
此时在左下方就会显示当前照片占用内存的大小。
2.点击上方工具栏中的“图像——重设大小”。
3. 在弹出的对话框中对“百分比”或“像素”进行相应的调整，然后点击“确定”。
4.点击左上角的“保存”，在下方就会发现图像的内存占用大小已经发生了改变。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc1c204038755391857ca41f9de419e/" rel="bookmark">
			XShell登录云服务器，后续git配置 系统为Centos7.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		购买云服务器后，在Xshell进行操作。购买云服务器后，要先在控制台处进行重置密码。
XShell登录云服务器 1、输入
ssh root@43.143.229.43 点击 接受并保存密钥。
2、在SSH用户身份验证中，输入密码
注意这里输入的是云服务器的密码 3、创建用户
adduser yyq 4、为新用户创建密码
passwd yyq 5、输入密码
注意这里不会回显 后续登录就可以使用
ssh yyq@43.143.229.43 XShell的git配置 此处用的是gitee仓库。
1、更新git Centos7自带git版本是1.7，在远程操作仓库的时候会报错，所以要先更新git。
以下步骤更新的是git version 2.31.1
[root@VM-8-13-centos ~]# yum -y install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm 然后安装git
yum -y install git 2、生成公钥 在xshell上配置git
第1步，生成ssh公钥
[yyq@VM-8-13-centos ~]$ ssh-keygen -t rsa -C "yingyq0118@163.com" 第2步，查看XShell生成的公钥
[yyq@VM-8-13-centos ~]$ cd .ssh [yyq@VM-8-13-centos .ssh]$ cat id_rsa.pub 将密钥复制粘贴到gitee的ssh公钥处。
接下来回到XShell，输入如下命令
git config --global user.email "you@example.com" git config --global user.name "Your Name"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bc1c204038755391857ca41f9de419e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c8aec1f8306cb73f0d6b1666f3ac93d/" rel="bookmark">
			vue中pdf.js在线展示base64文件流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些情况下后端返回的数据流是base64编码，无法用过viewer.html?file=的方式绘制在线预览pdf页面，所以需要自己动手写pdfjs的解析方法
一、官网：http://mozilla.github.io/pdf.js/ 下载PDF.js目录如下
将文件存放在项目文件夹’src/pdfjs’
二、使用方法 1.创建previewPdf.js文件，用来解析base64编码文件流 // src/previewPdf.js import pdfjsLib from '@/pdfjs/build/pdf.js' let loadingTask = null; let scale = 0.85 //检查操作系统 function detectOS() { var sPlatform = navigator.platform; var isLinux = (String(sPlatform).indexOf("Linux") &gt; -1); if (isLinux) return "Linux"; } function renderPdfJs(pdfData){ let userAgent = navigator.userAgent; if (userAgent &amp;&amp; userAgent.indexOf("Firefox") &gt; -1) { pdfjsLib.GlobalWorkerOptions.workerSrc = '@/pdfjs/build/pdf.worker.js' //火狐系统配置 } var OsName = detectOS(); //获取操作系统 if (OsName == "Linux") { //操作系统是linux时，需要载入字体 var CMAP_URL = '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c8aec1f8306cb73f0d6b1666f3ac93d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f063fda25bae9e371fd8a33209c06d14/" rel="bookmark">
			python yield含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、yield迭代器二、使用步骤1.引入库2.读入数据 总结 前言 提示：这里可以添加本文要记录的大概内容：
例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
一、yield迭代器 在python深度学习模型读取数据时，经常遇到yield，互联网搜索后，将比较容易理解的说明记录一下。
二、使用步骤 1.引入库 代码如下（示例）：
def batch(data, batch_size): for ex in data: yield ex 2.读入数据 代码如下（示例）：
p_batch = batch(p_batch, self.batch_size) 总结 如果不太好理解yield，可以先把yield当作return的同胞兄弟来看，他们都在函数中使用，并履行着返回某种结果的职责。
这两者的区别是：
有return的函数直接返回所有结果，程序终止不再运行，并销毁局部变量；
def batch(data, batch_size): for ex in data: return ex 而有yield的函数则返回一个可迭代的 generator（生成器）对象，你可以使用for循环或者调用next()方法遍历生成器对象来提取结果。
什么是生成器呢？在 Python 中，使用了yield的函数被称为生成器。有点套娃的感觉，但事实就是这样，调用一个yield函数，就会返回一个生成器对象。
def test: x=1 y=10 while x&lt;y: yield x x+=1 t = test() 在调用生成器函数的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息（保留局部变量），返回yield的值, 并在下一次执行next()方法时从当前位置继续运行，直到生成器被全部遍历完。
举个例子
def test: x=1 yield x yield x+1 yield x+2 t = test() for tmp in t: print(tmp) #输出结果为： 1 2 3 也可以调用next方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f063fda25bae9e371fd8a33209c06d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bd9d0f2b3f85afeb8ddc85d29646817/" rel="bookmark">
			NVDLA NV_small代码生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前提条件 代码链接：GitHub - nvdla/hw: RTL, Cmodel, and testbench for NVDLA
nvdla/hw 默认的代码分支为nvdlav1,在这个分支下 ，采用nv_small.spec生成的代码不是期望的，中间具体原因不详。
因此选择需要采用master 分支。
2. 注意事项 与nvdlav1分支类似，tmake脚本中 对应的几个perl 的模块，需要安装。
此处需要安装perl 模块有 YAML 和 Capture::Tiny
其中 Capture::Tiny 可参考安装链接为：
linux下使用CPAN安装Perl模块 - —小郑同学— - 博客园
再次执行报错如下图所示，解决方法： 安装 XML/Simple.pm 对应模块下载链接： http://search.cpan.org/CPAN/authors/id/G/GR/GRANTM/XML-Simple-2.20.tar.gz
3. 代码修改 当上述工作执行完成后， 执行 ./tool/bin/tmake -build vmod, 依然会报错，错误如下图所示：
修改方案：
报错是出现在NV_NVDLA_CSC_dl.v文件中， 且错误的原因 是Global symbol “$quat” requires explicit package name , 这个错误的解决方案 是 写成 MY $quat。
因此在 vmod 目录下 打开 NV_NVDLA_CSC_dl.v， 搜索 dat_rsp_sft_d2_en 找到对应位置，即使在第一次出现的时候已经 定义了 MY $quat， 但在后边对应位置也要加上。 此时，不再报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef6197af0aa86407edc5e9519e1d1074/" rel="bookmark">
			本地h5页面如何在手机上预览 ---完美实现。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装node环境。在当前所在项目文件夹下输入命令： npm install anywhere -g 运行项目： anywhere 此时会弹出一个地址，手机上访问这个地址就可以了。亲测有效。 原文链接： (3条消息) 本地h5页面如何在手机上预览 ---完美实现。_邱志刚的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4584a45be2295d0cc43e656ace80fffd/" rel="bookmark">
			mcdf_rgm_pkg——MCDF验证环境（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rgm_pkg的内容是每个寄存器都是一个单独的class，再加上一个顶层rgm继承于uvm_reg_block来对每一个寄存器做例化、配置、build，再将所有的reg加入到map中，做后门访问的配置。
首先是注册，域的声明，声明成随机变量rand uvm_reg_field slv_en；
然后写覆盖组covergroup value_cg；写明覆盖点以及位数；
new函数的参数要包含寄存器位数32和打开覆盖率的选项UVM_CVR_ALL；然后设置覆盖率选项，在has的时候例化覆盖组；
build函数是virtual的，做域的例化和配置，配置参数一共有9个，第一个是this，第二和第三个是位数，第四个是状态RW/RO，后面的五个参数固定为0初始值100。
最后是sample函数，参数是寄存器自己操作的trans——uvm_reg_bus_op中的两个data_t（data， byte_en）、bit is_read、uvm_reg_map map，一共四个参数，先写类型后写名，内容是调用super的后调用自定义的sample_values()函数；
sample_values()函数也调用super的，然后用if判断是否get了coverage，是的话就调用覆盖组的sample（）采样函数。
slv_en_reg 第一个版本
覆盖组需要触发条件吗？域的位数怎么声明在覆盖组中？
（这里不需要；在覆盖点中域名.value[位数]）
域的例化用new还是工厂？配置怎么写？
（用工厂，类型就是声明时的uvm_reg_field；域.configure（9个参数），reserved的属性是RO）
class slv_en_reg extends uvm_reg; `uvm_object_utils(slv_en_reg) rand uvm_reg_field slv_en; rand uvm_reg_field reserved; covergroup value_cg @(posedge clk iff rstn); slv_en: coverpoint slv_en{ type_option.weight=0; bins en={1}; bins reserved={0}; } function new(32, UVM_CVR_ALL); endfunction virtual function void build(); slv_en= slv_en.configure(this,3,0,"RW",0,'h0,1,0,0); endfunction function void sample(	uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map); super.sample(data, byte_en, is_read, map); sample_values(); endfunction function void sample_values(); super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4584a45be2295d0cc43e656ace80fffd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5402c245a93885a6785c644d21fc254d/" rel="bookmark">
			《计算机网络：自顶向下方法》读书笔记 2：应用层和运输层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 应用层 网络应用是计算机网络存在的理由，如果我们不能构想出任何有用的应用，也就没有任何必要去设计支持它们的网络协议了。
1.1 网络应用程序体系结构 两种主流的网络应用程序体系结构：客户-服务器体系结构、对等(P2P)体系结构。
客户-服务器体系结构：有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况，为此，配备大量主机的数据中心常被用于创建强大的虚拟服务器。
P2P体系结构：对位于数据中心的专用服务器有最小的依赖。相反，应用程序在间接连接的主机对之间使用直接通信，这些主机对被称为对等方。
1.2 进程通信 一个进程可以被认为是运行在端系统中的一个程序。
在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信。发送进程生成并向网络中发送报文；接收进程接收这些报文并可能通过将报文发送回去进行响应。
在给定的一对进程之间的通信会话场景中，发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。
进程通过一个被称为套接字(socket)的软件接口向网络发送报文和从网络接收报文。
套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口(API)。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。
应用程序开发者对于运输层的控制仅限于选择运输层协议，也许能设定几个运输层参数。一旦应用程序开发者选择了一个运输层协议，则应用程序就建立在由该协议提供的运输层服务上。
一个运输层协议能够为调用它的应用程序提供什么样的服务呢？
1 可靠数据传输：分组在计算机网络中可能丢失，而对于一些应用，数据丢失是无法容忍的事情，必须确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。如果一个协议提供了这样的确保数据交付服务，就认为提供了可靠数据传输。运输层协议能够潜在地向应用程序提供可靠数据传输。
2 吞吐量：运输层协议能够以某种特定的速率提供确保的可用吞吐量。具有吞吐量要求的应用程序被称为带宽敏感的应用。与之相对的是弹性应用。
3 定时：运输层协议也能提供定时保证。
4 安全性：运输协议能够为应用程序提供一种或多种安全性服务。
因特网为应用程序提供两个运输层协议，即UDP和TCP。这两个协议会在运输层详细介绍，在这里只需要知道TCP协议提供了可靠数据传输服务，UDP没有提供可靠数据传输服务即可。
在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息：
1 主机的地址，由IP地址(IP address)标识。
2 定义在目的主机中的接收进程的标识符，由端口号(port number)标识。
1.3 Web和HTTP Web指的是万维网(World Wide Web)，即全球广域网。
Web是一个引起公众注意的因特网应用，极大地改变了人们与工作环境内外交流的方式。
Web的应用层协议是超文本传输协议(HyperText Transfer Protocol, HTTP)，它是Web的核心。
HTTP由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。
当用户请求一个Web页面(如点击一个超链接)时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。
HTTP使用TCP作为它的支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。
一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制。TCP为HTTP提供了可靠数据传输服务，这意味着客户进程发出的每个HTTP请求报文最终能完整地到达服务器；类似地，服务器进程发出的每个HTTP响应报文最终能完整地到达客户。从这里我们可以看到分层体系结构最大的优点是HTTP协议不用担心数据丢失。
注意到，服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个特定用户在几秒钟内两次请求同一个对象，服务器并不会因为刚刚为客户提供了该对象就不再做出反应，而是重新发送该对象。所以我们说HTTP是一个无状态协议。
1.4 HTTP报文格式 HTTP报文分为请求报文和响应报文。
1.4.1 HTTP请求报文 一个典型的HTTP请求报文：
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-Language: fr
HTTP请求报文的第一行叫做请求行，其后继的行叫做首部行。
请求行有3个字段：方法字段、URL字段和HTTP版本字段。
方法字段可以取的值包括GET、POST、HEAD、PUT和DELETE，用的最多的还是GET。
首部行Host: www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5402c245a93885a6785c644d21fc254d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c8272e76ac5e6a2bec0e9748155bcc/" rel="bookmark">
			学习黑马JVM的笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM详解 一、JVM介绍1.什么是JVM？2.有什么好处3.学习路线 二、内存结构1.程序计数器(Program Counter Registe)1.定义2.作用3.特点4.演示 2.虚拟机栈(Java Virtual Machine Stacks)1.定义2.演示3.问题解析4.栈内存溢出5.线程运行诊断（linux中） 3.本地方法栈4.堆(Heap)1.定义2.特点3.堆内存溢出4.堆内存诊断1.jps工具2.jmap工具3.jconsole工具4.演示1.jps2.jmap3.jconsole4.jvisualvm 也是一个可视化工具，功能更加强大 5.方法区1.定义2.特点3.组成4.方法区内存溢出1.8以前导致永久代内存溢出1.8以后导致元空间内存溢出 5.运行时常量池6.StringTable(串池)1.StringTable特性2.StringTable位置3.StringTable垃圾回收4.StringTable性能调优 6.直接内存1.定义2.ByteBuffer3.直接内存内存溢出4.直接内存释放原理5.分配和回收原理6.禁用显示回收对直接内存的影响 三、垃圾回收1.如何判断对象可以回收1.引用计数法1.定义2.弊端 2.可达性分析算法（java虚拟机采用的方法）1.定义2.哪些对象可以作为GC Root？3.如何查看GC Root对象 3.五种引用1.强引用：2.软引用：3.弱引用4.虚引用：5.终结器引用： 2.垃圾回收算法1.标记清除算法2.标记整理算法3.复制算法 3.分代回收3.1相关VM参数 4.垃圾回收器1.相关概念1.并行收集2.并发收集3.吞吐量 2.串行回收器1.特点2.Serial收集器3.ParNew 收集器4.Serial Old 收集器 3.吞吐量优先1.Parallel Scavenge 收集器2.**Parallel Old 收集器** 4.响应时间优先1.CMS 收集器 5.G11.定义2.使用场景3.相关JVM参数4.G1垃圾回收阶段1.Young Collection(新生代收集)2.Young Collection+ Concurrent Mark(新生代收集+并发标记)3.Mixed Collection(混合收集) 5.Full GC6.Young Collection 跨代引用7.Remark（重新标记）8.JDK 8u20 字符串去重9.JDK 8u40 并发标记类卸载10.JDK 8u60 回收巨型对象11.JDK 9并发标记起始时间的调整 5.垃圾回收调优5.GC 调优1.调优领域2.确定目标3.最快的GC是不发生GC4.新生代调优5.幸存区调优6.老年代调优 四、类加载与字节码技术1.类文件结构1.魔数2.版本3.常量池4.访问标识与继承信息5.Field信息6.Method信息7 附加属性 2.字节码指令1.入门2 javap 工具3.图解方法执行流程1.代码2.编译后的字节码文件3.**常量池载入运行时常量池**4.**方法字节码载入方法区**5.main 线程开始运行，分配栈帧内存 4.通过字节码指令来分析问题5.构造方法1.cinit()V2.init()V 6.方法调用7.多态原理8.异常处理try-catch多个single-catchfinallyfinally中的return被吞掉的异常finally不带return 3.语法糖 编译器处理1.默认构造函数2.自动拆装箱3.泛型集合取值4.可变参数5.foreach6.switch字符串7.switch枚举8.枚举类9.匿名内部类 4.类加载阶段1.加载2.链接1.验证2.准备3.解析 3.初始化1.发生时机2.以下情况不会初始化 5.类加载器1.基本介绍2.启动类加载器3.扩展类加载器4.应用程序类加载器5.双亲委派模式概念 6.线程上下文类加载器7.自定义类加载器1.使用场景2.步骤3.案例 8.破坏双亲委派模式 6.运行期优化1.即时编译1.分层编译2.既时编译器(JIT)与解释器的区别3.逃逸分析4.方法内联1.**内联函数****2.JVM内联函数**5.字段优化 2.反射优化 五、内存模型1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5c8272e76ac5e6a2bec0e9748155bcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa198d5b3047fa5f1498b7540e1312d/" rel="bookmark">
			基础模型量化学习扩展仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目地址（GitHub）：https://github.com/Ranking666/Base-quantization
~~~欢迎各位交流、star、fork、issues~~~
项目介绍：
本仓库是基MNIST数据集，使用VGG作为模型进行各种量化方法的集成。
目前支持更换per_tensor和per_channel量化，支持基于Minmax, EmaMinmax, omse, Histogram, adaround, bias_correction的PTQ量化方法，支持基于Minmax, EmaMinmax，omse, Histogram，Dorefa, LSQ的QAT量化方法。
代码风格简单，便于学习量化方法，扩展量化新方法，迁移到不同的模型和框架中
后续，将会支持更多量化方法，量化框架，欢迎大家持续关注。
欢迎大家有问题，错误，想法都可以积极交流，探讨，学习，本项目长期维护，持续更新，各位的star，就是对本项目的大力支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8684b6910dca3612e5739ae58e0a5cf3/" rel="bookmark">
			【java基础17：继承】子类调用父类方法 何时使用继承 Object中有哪些方法 println()方法的解释 toString 方法的测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继承（extends） 什么是继承？继承有什么用？
继承：在现实世界中也存在，例如：父亲有钱，儿子不用努力也很有钱
继承的作用：
基本作用：子类继承父类，代码可以得到复用。
主要/重要作用：有了继承关系，才有了后期的方法覆盖和多态机制
继承的相关特性
B类继承A类：A类为超类(superclass)、父类、基类。
B类则称为子类(subclass)、派生类、扩展类
class A{} class B extends A{} //我们平时聊天说的比较多的是：父类和子类。 suoperclass 父类 subclass 子类 java中的继承只支持单继承，不支持多继承 ，C++中支持多继承
这也是java体现简单性的一点，换句话说，java中不允许这样写代码:
class B extends A,C{}//这样写是错误的. 虽然java不支持多继承，但有的时候会产生间接继承的效果,例如:
calss C extends B{} class B extends A{} //也就是说:c直接继承B、其实C还间接继承A. public class ExtendsTest02 {public static void main(String[] args){}} class AA{} class BB{} class CC extends AA{} class DD extends BB{} //语法错误 //java只允许单继承，不允许多继承。java是简单的，C++支持多继承。 //C++更接近现实一些。现实中：儿子同时继承父母亲的基因。 //class EE extends AA,BB{} class XX{} class YY extends XX{} //其实这样也说明了ZZ是继承XX和YY的。 //详细描述：ZZ直接继承了YY ，间接继承了XX。 class ZZ extends YY{} java中规定:子类继承父类，除了构造方法不能继承外，剩下的都可以继承，但是私有的属性无法在子类中直接访问。（父类中private修饰的不能在子类中直接访问，可以通过间接的手段访问，如：使用set和get方法）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8684b6910dca3612e5739ae58e0a5cf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/594cb5ad914b4d16cfddd8148c1eb394/" rel="bookmark">
			【STM32 HAL】串口中断控制相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 HAL库 串口中断控制 引言串口中断类型中断管理函数使能中断 __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)关闭中断 __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)获取中断状态 __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__) 中断标志位种类中断标志位管理查询中断标志 __HAL_UART_GET_FLAG(__HANDLE__, __FLAG__)清除中断标志 __HAL_UART_CLEAR_FLAG(__HANDLE__, __FLAG__)特殊专用接口 引言 在移植modbus时需要进行串口接收与发送中断的控制，由于hal库封装比较复杂，不便于精细操作。在此记录串口中断的控制函数，不详细介绍串口的寄存器控制，仅就如何使用入手。如果不理解请自行学习。
串口中断类型 STM32F103系列较为常用，打开文件&lt;stm32f1xx_hal_uart.h&gt;可以看到所有hal库中关于串口的操作接口与说明。其中串口中断管理部分的函数说明中有写明可操作的串口中断种类有：
* @arg UART_IT_CTS: CTS change interrupt * @arg UART_IT_LBD: LIN Break detection interrupt * @arg UART_IT_TXE: Transmit Data Register empty interrupt * @arg UART_IT_TC: Transmission complete interrupt * @arg UART_IT_RXNE: Receive Data register not empty interrupt * @arg UART_IT_IDLE: Idle line detection interrupt * @arg UART_IT_PE: Parity Error interrupt * @arg UART_IT_ERR: Error interrupt(Frame error, noise error, overrun error) 中断管理函数 中断管理主要是开启中断、关闭中断和获取中断状态，在文件中也能看到。三条接口均是宏定义直接操作寄存器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/594cb5ad914b4d16cfddd8148c1eb394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/856a49ef24e5caadf1c371767847a34b/" rel="bookmark">
			FPGA新起点V1开发板（三）——Quartus II软件的使用（流水灯的烧录以及sof转jic的方法记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、开发流程二、新建文件夹（不许出现中文路径）三、新建工程三、添加设计文件四、配置工程五、分析与综合六、分配引脚七、编译工程八、下载程序附、修改成jic文件 一、开发流程 二、新建文件夹（不许出现中文路径） 先创建一个工程文件夹flow_led再创建四个子文件夹
doc存放工程的设计文档或者其他一些datasheet文档、数据手册
par存放工程文件
rtl存放设计文件，也就代码
sim存放工程的仿真文件
第一个第四个可以为空，但是做此可以有良好的习惯
三、新建工程 这是打开一个工程向导
这是选择FPGA的芯片型号的
选择第三方EDA的工具的
最后的信息确认
三、添加设计文件 选择Verilog语言进行编写
四、配置工程 咳咳上面应该才是配置工程，三和四写反了
找一个流水灯的代码
module flow_led( input sys_clk , //系统时钟 input sys_rst_n, //系统复位，低电平有效 output reg [3:0] led //4个LED灯 ); //reg define reg [23:0] counter; //***************************************************** //** main code //***************************************************** //计数器对系统时钟计数，计时0.2秒 always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) counter &lt;= 24'd0; else if (counter &lt; 24'd1000_0000) counter &lt;= counter + 1'b1; else counter &lt;= 24'd0; end //通过移位寄存器控制IO口的高低电平，从而改变LED的显示状态 always @(posedge sys_clk or negedge sys_rst_n) begin if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/856a49ef24e5caadf1c371767847a34b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a476b729d9f35bef0251946c804e8e4/" rel="bookmark">
			请问swat输出的是有机氮、 有机磷、 硝态氮等，但目前只有总磷、总氮和氨氮的数据，该怎么率定呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		受全球环境变化和经济快速发展的影响，面源污染已逐渐成为水环境污染的第一因素。但面源污染由于具有排放分散、隐蔽，排污随机、不确定、不易监测等特点，再加上单位面积上的污染负荷小，人们往往忽视其宏观效应。因此，打好面源污染防治攻坚战，是当前水资源、水环境和水生态管理的主要工作之一。在面源污染防治中，首要的前提是需要结合一定的面源污染模型进行污染负荷量的估算并分析其空间特征，并探讨流域内各部分之间的联系与反馈机制
SWAT模型在水文水资源、面源污染模拟中的实践技术应用及典型案例分析
SWAT模型及应用及经验分享
面源污染概要
SWAT模型及应用
SWAT模型原理
SWAT模型输入文件
ArcGIS与SWAT关系
SWAT模型中GIS必备技术
GIS软件平台 ArcGIS10.6安装和注意事项
ArcGIS入门 ArcGIS常见数据格式
ArcGIS数据浏览
SWAT模型操作流程
SWAT模型安装 建立SWAT项目
SWAT模型子流域划分 HRU划分
气象数据及其它数据输入 SWAT运行及结果读取
SWAT结果分析及地图制作
SWAT模型构建完备数据制备
构建流域SWAT模型所需数据及参数库
DEM数据制备 土地利用数据制备
土壤数据制备 气象数据制备
点源数据制备 SWAT模型参数库制备
SWAT-CUP率定与验证
参数率定与结果验证原理 SWAT-CUP软件介绍
SWAT-CUP水量率定与验证 SWAT-CUP水质率定与验证
参数敏感性分析 率定验证后参数回带及模拟
关键源区及BMPs设置
最佳管理措施介绍 关键源区分析
SWAT中BMP的设置 BMP效果分析
SWAT模型结果分析-水资源
地表径流分析
地下径流分析
蒸散发分析
水源涵养量分析
SWAT模型结果分析-农业面源
子流域农业面源分析
河道农业面源分析
面源污染时空变化分析
SWAT模型结果分析-水土流失
SWAT模型泥沙分析
水土保持措施分析
综合案例分析:基于SWAT模型的三峡库区典型小流域水资源时空分布特征
SWAT模型高阶应用暨无资料地区建模、不确定分析与气候变化、土地利用对面源污染影响模型改进及案例分析
SWAT模型应用热点分析
SWAT模型应用文献解析及热点剖析
讨论
无资料地区快速建立SWAT模型
无资料地区DEM数据制备 无资料地区土地利用制备
无资料地区土壤数据制备 无资料地区气象数据制备
无资料地区SWAT模型率定验证
案例分析：遥感产品和SWAT模型结合研究
ArcGIS高级及应用
ArcGIS高级操作
ArcGIS水文分析及SWAT应用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a476b729d9f35bef0251946c804e8e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d076aea2ded8ef053f738c55a50810d1/" rel="bookmark">
			ssh连接失败报错：Socket error Event: 32 Error: 10053.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：使用远程连接工具ssh连接局域网内的主机，刚连接成功一会儿就断开连接，报下面的错误信息
Socket error Event: 32 Error: 10053. Connection closing...Socket close. Connection closed by foreign host. Disconnected from remote host(192.168.63.24) at 16:23:12. Type `help' to learn how to use Xshell prompt. 原因：IP冲突，主板自动获取到的IP地址与局域网内另一台设置的静态IP地址重合。
解决方案：修改IP冲突的其中一台主机的IP地址即可解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/832f9394bc472615717668d11df819be/" rel="bookmark">
			【ArcGIS教程】专题图制作-人口密度分布图——人口密度分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇以湖北省为例，制作人口密度分布图；这里所使用的为湖北省的省、市、县三个级别的行政区划矢量数据，以及居民点数据，进而进行密度分析。
示例数据来源于地理遥感生态网，该网站更新了很多有关地理的数据，30米土地利用二级分类数据、DEM高程、乡镇边界、气象数据、径流量数据等。
示例数据下载链接：数据下载链接
第一步 准备数据 如下为湖北省各级别行政区划与居民点数据
第二步 符号化显示 将湖北的市级行政区划矢量数据进行简单的符号化，观察一下所加载的数据，如下：
第三步 添加标注 首先为湖北省的市级行政区划添加标注显示
第四步 核密度分析 这里就是重点步骤了！
当然你也可以使用点密度进行分析，核密度与点密度两者分析有什么区别呢？百度吧！
环境设置：（为了确保数据精度，不要嫌麻烦）
核密度分析完成，如下：
第五步 核密度符号化 就是让核密度分析的结果显示的更好看嘞！
第六步 叠加图层显示 将标注、市级分界线添加至核密度分析结果数据之上。
第七步 添加底图 为了好看添加一个地图吧！你也可以不加！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aba64263c7a4b4fef171c2207802483/" rel="bookmark">
			为什么 vm._data.date1 vm.date1 都可以访问，并且访问 同一个变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var vm = new Vue({
el: ‘#app’,
data: {
tableData:[],
Filter: [],
currentPage:1, // 右边 当前批次分页
pageSize:10, // 右边 批次分页大小
total: 100, // 总行数
SearchKey: “”,//搜索内容
date1: ‘’,
date2: ‘’,
txtzInvCode: ‘’,
txtVersion:‘’,
},
....................
我用 vm._data.date1 vm.date1 都可以访问，并且访问 同一个变量，我就不懂了，这两种写法有什么区别，是用 vm._data 合理，还是 vm.date1 合理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40fb3ece09857f8102a1017cdb2ac003/" rel="bookmark">
			Aurix DLMU 使用不当导致软件bug问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Aurix TC357datasheet中一段的说明如下：
B000 0000H - B000 FFFFH 64 Kbyte LMU (CPU0 DLMU) Access Access
该段地址属于CPU0的LMU，该RAM中的数据在warm reset时数据不会被清空，只有cold reset才能reset其中内容。
如果该地址段已经被其他软件用过了，而新的软件又没有清零该地址，有可能会获取到一个任意的值，导致软件出bug。这点需要注意。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2d97cc26844f2349550384cdac34a28/" rel="bookmark">
			分布式理论CAP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是CAP理论 CAP理论，指的是在一个分布式系统中，Consistency(一致性)、Availability(可用性)、Partition Tolerance(分区容错性)，不能同时成立。
CAP理论是分布式架构中提出来的一种设计思想模型，全称是由Consistency、Availability、Partition Tolerance三个词组成，通过单词便可知其意，其实，这三个词分别代表着不同的含义，在做分布式架构设计时，只能在其三中选其二，并不能同时满足三个思想模型。
分布式理论CAP三者的定义如下：
一致性(C ) ：保证所有节点上的数据始终同步。可用性(A )：无论响应成功还是失败，每个请求都是有效的，并不会发生网络超时等情况。分区容错性(P ) ：系统内部（某个节点的分区）中丢失消息，系统也应该可以继续提供服务。一致性和可用性是分布式系统的固有属性。 二、CAP分布模型 CAP理论分布模型是基于区域约束来实现的，包含C（一致性）、A（可用性）、P（分区容错性）三者的关系所形成的理论模型。那么CAP理论模型中这三者是怎么联系起来的呢？由于分布式理论CAP特性，只能同时满足三个领域中的两个，所以，我们在思考过程中也知道，可形成三种情况供选择。CAP分布模型图构建和三者之间的关系如下图：
三、CAP核心思想 CAP理论是分布式架构设计中心思想，其核心思想是在分布式架构体系下，基于什么样的场景构建稳定、健壮、安全、可用的软件系统。那么多年来，CAP理论在互联网界广为人知，被称为“帽子理论”。 这是Eric Brewer教授在2000年举办的ACM研讨会上提出的著名猜想：一致性、可用性、分区容错性(partition-tolerrity )。 2003年，MIT的Gilbert和Lynch正式证明这三者确实不可兼得。 而且CAP被认为是分布式领域的重要理论，被很多人认为是分布式系统设计的金律。
四、CAP解决了什么问题 通过对分布式理论CAP认知，我们都应该了解到软件系统在分布式架构场景下会引发哪些问题，而这些问题的背后又是用什么技术手段或方法去解决的呢？那么我们就带着这个问题去寻找答案，切入点如下图：
我这边画了一张便于理解的系统架构链路分析图，其实，在图中已经解答了我上面所提出的问题。那么图中都隐含了什么呢？下面通过 3 个场景去解答，如下：
1、如何保证数据一致性
首先，需要先理解一致性的概念，指的是在主数据和多副本同步过程中实时保持数据是一致的。CAP理论中所描述的一致性是强一致性的，但在分布式系统场景下是很难保证强一性，通过图中的主库和从库之间一旦发生延迟或超时等其它情况，则无法保证数据的强一致性。而为了避免这种问题，后面又提出了不能保证强一致性的同时，可以保证数据的最终一致性，并不要求实时数据一致的情况。其实，在这里有引入了一个理论，那就是Base理论模型，对于这个理论模型下一篇再深入的进行说明。
2、如何保证系统可用性
那么在分布式架构里面为什么要保证系统可用性，提出的一点就是随着业务量的增长，单系统可承受的压力是受限的，为了解决这个问题，引入了分布式架构多副本、集群模式，这样就解决了系统单点问题。通过图中蓝框部分实现了系统集群化和系统架构高可用，避免因为图中红框里面部分系统中断，造成系统不可用状态。在这里面也隐含的表达了Base理论里面的基本可用特征。
3、为什么要选择分区容错性
在解答这个问题之前，我们先要理解分区容错性的概念，也就是什么是分区容错性。分区容错性是在系统通信层面，能够避免系统的某个分区或网络分区出现问题，导致系统中断不可用状态。那么了解了什么是分区容错性以后，我们接着看图中的蓝框里面的三个系统，在分布式架构下，通常一个请求是由多系统协作完成的。若此时B、C系统内部网络通信发生局部异常，则会直接使系统网络通信之间中断并导致不可用，而在有分区容错性的保证下则会对系统网络通信异常分区隔离，并不会影响整个系统的不可用，所以在分布式架构下分区容错性是必选的，那么对于我们的选择的就只有C和A之间做权衡了。
五、CAP应用场景 CAP理论证明限制在原子读写场景中，声明不支持数据库事务等场景。 将分区的容错性总结为关于网络环境的描述，而不是以前的独立条件。
相对于CAP理论应用场景，一般情况下可根据实际业务场景做选择，但我想提的一点就是主要应用于分布式架构当中，为什么这么说呢？因为你的业务足够简单且单应用架构中，像这种场景下是应用不到的。那么CAP一般都适用于哪些场景呢？通过CAP分布模型（实际业务情况下）分为如下三种情况：
CA：该方案保证的是系统一致性和可用性，但损失了分区容错性，在基于此方案的前提下，若业务系统构 建于分布式架构场景下，则在系统、服务之间的网络通信分区发生中断，某一块分区出现损坏时，会 导致整个业务系统不可用状态，不管你的系统是否保证了高可用。因为在该方案下，只能在系统和网 络层面去保证网络的分区问题。由于采用该方案的业务系统几乎很少，弊端也明显，所以我们在做业 务架构中做出正确的选择，避免出现不可挽回的损失。CP：保证了分布式架构中数据的一致性，该方案适用于对于一致性要求苛刻的业务场景下，会选择此方 案。例如 zookeeper 的内部实现机制就是基于分布式一致性的，能够保证数据的存储不丢失，但某一 时刻出现服务中断，则会导致服务不可用状态。那么大家可能会有疑问，集群化不就行了，但是你要考 虑的前提是单集群里面只有一个leader，若leader服务不可用了，选举情况下也会有一段时间不可用 状态，所以像采用这种方案的情况下只能保证数据一致性，并不能保证服务可用性，但可以尽量做到缩 短选举的时间，间接的保证服务可用性。AP：保证了服务在分布式架构中可用性，现在大部分业务系统都是基于此方案去实现的，若是你的业务系 统是对可用性要求比较高，则可采用该方案去实现。那么随着业务量的增长，系统可用性的要求也越 来越高，只要保证有一台服务可用，便可处理内外部请求。但是可用性得到了保证，数据一致性也是 尤为重要的，对于数据一致性要求没那么高的情况下，可以间接的保证数据最终一致性，该特性是基于 Base理论模型中提出来的，也是为了解决分布式架构下一致性问题的致命缺陷。
六、总结 分布式理论CAP是基于系统之间的不断重现而精进的，CAP并不是普遍的普通原理和指导思想，它只适用于原子读写的NoSQL和系统架构设计场景，而不适用于数据库系统。现在的分布式系统也不是多年前的简单系统。 如今，分布式系统具有可扩展性、自动化等诸多特性，想成为架构师不仅需要理解 CAP 问题，还需要在设计和开发系统时拓展视野。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7cf5374a89588fab6c96f756ffdc9d9/" rel="bookmark">
			文献检索与下载的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://sci-hub.se/+'DOI编号（见百度学术）'VPN链接外网+进入Google网址或必应网址，然后直接用英文搜索 https://libgen.is/（搜书专用，这个网址经常变，进入不了可以直接搜Liberty Genesis查找新网址）https://www.sciencedirect.com/（根据关键词进行搜索）https://www.webofscience.com//（根据关键词进行搜索）https://arxiv.org/search/（根据关键词进行搜索）https://epubs.siam.org/（根据关键词进行搜索）https://onlinelibrary.wiley.com/https://arxiv.org/pdf/2000.00004.pdf or https://arxiv.org/abs/2000.00004https://www.worldscientific.com/doi/epdf/10.1142/S0219530521500019 对于ArXiv文章编号，见arXiv编号前四位不是都是论文发表的年份么？ - 知乎 https://www.zhihu.com/question/410631415
例子：https://onlinelibrary.wiley.com/doi/epdf/10.1002/nme.5440
https://onlinelibrary.wiley.com/doi/epdf/+‘DOI编号’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ccff57dfa8b1983c2da464e08d8f929/" rel="bookmark">
			Allegro 17.4设置中文界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Allegro 17.4 中文界面效果 二. Allegro 17.4 中文界面设置方法 2.1 需要打上此时（20210820）最新的S019的升级补丁 2.2 设置环境变量 变量名：intl_enabled
变量值：1
要去除中文显示的方法是删除此环境变量，改变量值为0或者False等都没有用。
三. 中英文双显示（效果不佳，太占空间了） 设置环境变量，如下图：
变量名：intl_show_bilingual
变量值：1
效果图：
要去除中英文双显示的方法是删除此环境变量，改变量值为0或者False等都没有用。
徐晓康的博客持续分享高质量硬件、FPGA与嵌入式知识，软件，工具等内容，欢迎大家关注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626ff0054738ccc9e0fdaa562b968c16/" rel="bookmark">
			魔兽世界开服一条龙服务端架设服务器搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		魔兽世界开服一条龙服务端架设服务器搭建 作为魔兽世界资深玩家，你是否有想过自己开服当服主？ 相信能看到此篇文章的你心里是有想法的。首先你需要知道开魔兽需要准备哪些东西，
我是艾西今天带您了解下魔兽世界开服需要的东西
想要搭建一个魔兽商业服，需要有魔兽世界服务端、网站系统、和一台服务器，若是自己不会技术，就要请个技术进行架设、调试，顺便把技术学了毕竟这是个一劳永逸的事情。
目前最完美的魔兽世界服务端AzerothCore
60级经典旧世版本
70级燃烧的远征版版本
80级巫妖王之怒版本
85级大地的裂变版本
90级熊猫人之谜版本
100级德拉诺之王版本
R110级军团再临版本
120级争霸艾泽拉斯版本
原版AzerothCore编译，仿官，集成Lua，无人数限制，无机器限制，无bug是目前修复最好的魔兽服务端了！
开服需要：服务器、服务端
包含地图文件和数据库（已汉化）全程技术教学有任何都可以及时解决
服务器:一个游戏整体的游戏体验感以及流畅度都是由服务器决定的。
魔兽的服务端以及客户端都比较大，对服务器的要求也会比较高建议配置E5系列，再强一些i9游戏高频系列。
需要用到的软件：
WAMP5 v1.7.exe （这个是为排行榜提供数据库服务，为Mysql数据库）
解压到任意盘根目录（建议解压缩到到D:\）
先解压MySQL.zip到文件夹pvpgn内，
再解压PvPGN-1.8.2-0-Win32-SQLite-3.5.1-BIN.zip,并覆盖到刚才的pvpgn文件夹
再解压pvpgn-support-1.1.zip，将解压出来的文件复制到D:\pvpgn\files下
到D:\pvpgn\conf下，打开文件bnetd.conf，找到
storage_path=file:mode=plain;dir=var\users;clan=var\clans;team=var\teams;default=conf\bnetd_default_user.plain 这一行，
在前面添加#符号注释掉，然后在下面添加
storage_path=sql:mode=mysql;host=127.0.0.1;name=pvpgn；user=ouc;pass=oucwar3;default=0
上面的name为我们刚才建立的数据库的名字，这里为pvpgn，user和pass分别为刚才添加的用户名及其密码。
再找到w3routeaddr = "0.0.0.0:6200"
将其改为w3routeaddr = "103.219.39.181:6200" ，这里的103.2190.39.181是我的服务器IP地址，你需要将它该为你自己的服务器IP，保存退出！
好了，到这里就设置完毕。第一次运行PGPGN.exe的时候，程序会自动在pvpgn这个库里建立需要的数据表
安装pvpgnstats2.44CN(vsLan fixed).zip
解压缩pvpgnstats2.44CN(vsLan fixed).zip到D:\ pvpgnstats2.44CN目录下
数据库的安装
1. 下载并安装WAMP5 v1.7.exe，在安装过程中会提示你选择www目录，选择我们解压的D:\ pvpgnstats2.44CN目录点击确定即可。
2. 在wamp任务栏图标上右击，选择语言为中文。
3. 在wamp任务栏图标上左击，选择“切换到在线状态(z)”.
4.在phpMyAdmin的主页面建一个pvpgn的库----------“创建一个新的数据库”在它下面输入新的数据库的名字（这里为pvpgn），点击下面的“创建”即可。完成后（会进入表创建页面，不去管他，点击网页左上的小房子图标即“主目录”回到phpMyAdmin的主页面），这时，可以看到新创建的pvpgn数据库已经在左边出现了
给PGPGN创建一个自己的用户--------点击“权限”---〉“添加新用户”，进入新用户设置页面，用户名，我这里取aixi。“主机”如果你的pvpgn和MYSQL在同一台主机，那就选“本地”，否则就选“任意主机”吧。如果你的PGPGN是固定IP的，也可以选择“使用文本域”，然后在后面的框里输入IP地址，密码，你自己设一个吧，我设为aixi3。下面的“全局权限”里什么权限都不用给，点击最下面的执行，用户就添加完毕了。
6.给新添加的用户操作数据库的权利---------回到用户设置页面，用户设置页面的中部有一个“按数据库指定权限”，在下面的“在下列数据库添加权限：”下拉，选择刚才建的那个pvpgn的库，然后页面会自动跳到pvpgn的库的授权页面（注意看清楚了，页面的最上面的提示信息现在是“用户 '*****'@'localhost' - 数据库 pvpgn ”，表明是在对pvpgn这个库授权），这里就可以给它全部权限了（全部打钩），下面的表可以不用指定的。
下面我们启动pvpgn.exe，即可开始运行。
一、PVPGN服务器架设好以后，我们在pvpgn数据库中建立pvpgnstats的表文件：
在解压出来的pvpgnstats\SQL Files\zion文件夹下有2个sql文件，看pvpgn的表头类型，使用相应的sql文件。这里使用bnet，打开复制里面的内容，然后在在phpMyAdmin页面的pvpgn数据库下面选中sql查询，粘贴进去，执行即可创建两个新的表条目。如下图所示：
1.默认应该是没有表头的，对应使用的sql文件为：bnet.sql，这里就是bnet.sql
2.对于PVPGN 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/626ff0054738ccc9e0fdaa562b968c16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c38bd650c6c3edb15e6ae7287e69c0/" rel="bookmark">
			VBA实现全文件快速替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家对于VBA处理文本文件并不陌生，Open打开文件，Line Input逐行读取处理，然后再使用Print写入到目标文件，整个过程并不复杂，但是如果源文件数据行数较多，那么逐行读取将花费较多的时间。
Sub demo() FN1 = FreeFile Open OutFile For Output As FN1 FN2 = FreeFile Open InFile For Input As FN2 Do Until EOF(1) Line Input #1, textline '数据处理代码 Print FN2, textline Loop Close FN2 Close FN1 End Sub VBA内置的打开文本文件的方法，并无法实现读取全部文件内容，借助FileSystemObject可以实现一次性快速替换。
示例代码如下
Sub ReplaceTxt() strSrcFile = "C:\temp\test.txt" strOldTxt = "c:\111\" strNewTxt = "d:\333\" Set fso = CreateObject("Scripting.FileSystemObject") Set objRead = fso.OpenTextFile(strSrcFile, 1) strIn = objRead.readall objRead.Close Set objWrite = fso.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05c38bd650c6c3edb15e6ae7287e69c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca133891809ff6ef74df5403a73c8da/" rel="bookmark">
			使用递归解决简单迷宫寻路问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 有一个迷宫，如图所示，红色方块部分为墙，白色区域为路
使用二维数组表示该迷宫
我们规定：0为未曾到过的路，1为墙，2为通路（即四周至少有一个为0的格子），3为3为到过且不通的路
int[][] maze = new int[8][7]; for (int i = 0; i &lt; 7; i++) { maze[0][i] = 1; maze[7][i] = 1; } for (int i = 0; i &lt; 8; i++) { maze[i][0] = 1; maze[i][6] = 1; } maze[3][1] = 1; maze[3][2] = 1; 需要从起点maze[1][1]到终点maze[6][5]
寻路策略 寻路通常需要指定寻路策略，这里我们制定的策略为 下右上左 即先向下判断是否能走通；
如果不能走通，再判断向右；
如果不能走通，再判断向上；
如果不能走通，再判断向左；
如果四个方向都不能走通，说明此点为死路，回退到上一个点
按照 下右上左 的策略，该题的行动路径为下图所示
代码实现 package recursion; /** * @author Watching * * @date 2022/11/1 * * Describe:使用递归解决迷宫问题 * &lt;p&gt; * 使用二维数组代表迷宫 * 1为墙，0为未曾到过的路，2为通路，3为到过且不通的路 */ public class Maze { public static void main(String[] args) { //初始化迷宫 int[][] maze = new int[8][7]; for (int i = 0; i &lt; 7; i++) { maze[0][i] = 1; maze[7][i] = 1; } for (int i = 0; i &lt; 8; i++) { maze[i][0] = 1; maze[i][6] = 1; } maze[3][1] = 1; maze[3][2] = 1; for (int i = 0; i &lt; 8; i++) { for (int j = 0; j &lt; 7; j++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca133891809ff6ef74df5403a73c8da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda4f084d251e87501a8906982204a47/" rel="bookmark">
			Git 批量拉取（git pull）多个仓库 bat脚本实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鄙人有个习惯，每天上班打开电脑第一件事，就是把所有本地git仓库拉取更新，保证取到最新的代码。
但本地git仓库实在太多，挨个执行 git pull 太麻烦，于是决定写下一个bat脚本，把这种重复的事情交给电脑。
运行前注意 你使用的是 Windows 系统你需要批量拉取代码的git仓库都在 同一个文件夹下 ，bat脚本也在此文件夹下。此脚本递归遍历当前路径下的文件夹，直到找到存在 .git 文件的文件夹，然后执行 git pull，然后继续遍历… git_pull.bat @echo off setlocal @REM normalize the relative path to a shorter absolute path. pushd "%~dp0" set repos_path=%CD% popd call :find_and_pull %repos_path% echo. &amp; echo Finished. &amp; pause&gt;nul goto :EOF ::------------------------------------- :: @name find_and_pull :: @param %1 base directory to find .git :: @usage call :find_and_pull %base_dir% ::------------------------------------- :find_and_pull for /d %%i in (%1\*) do ( cd %%i if exist .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda4f084d251e87501a8906982204a47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b21c7984b64868c83cfe747322f4aa/" rel="bookmark">
			Pyuic出现No module named ‘PyQt5.sip‘问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyuic出现No module named ‘PyQt5.sip‘问题解决
跟着网上教程安装anaconda + pycharm + PyQt5 安装完成后，在PyCharm创建项目，随便建了一个test.ui。 然后在test.ui上右键 -&gt; External Tools -&gt; PyUIC， 然后就遇到一堆错误： ModuleNotFoundError: No module named
的时候报告错误：
1
No module named 'PyQt5.sip'
解决方法如下：
1
2
3
4
5
6
7
8
9
$ python3 -m pip install --upgrade pip
$ pip3 install SIP
$ pip3 install pyQt5
$ pip3 install --upgrade PyQt5
$ pip3 install PyQtWebEngine
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79ebdaaffb74b4f680d250fd9e54ae57/" rel="bookmark">
			JUC 并发编程学习笔记（总）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 什么是JUC2. 进程和线程2.1 进程2.2 线程2.3 并发2.4 并行2.5 线程的状态2.6 wait 和 sleep 的区别 3. Lock锁（重点）3.1 传统Synchronized3.2 Lock接口3.3 Synchronized 和 Lock的区别 4. 生产者和消费者问题4.1 Synchronized版的生产者和消费者问题Synchronized版4.2 JUC版的生产者和消费者问题4.3 Condition 精确的通知和唤醒线程 5. 八锁现象6. 集合类不安全6.1 List不安全6.2 Set不安全6.3 Map不安全 7. Callable(简单)8. 常用的辅助类（必会）8.1 CountDownLatch8.2 CyclicBarrier8.3 Semaphore 9. 读写锁10. 阻塞队列10.1 阻塞队列BlockingQueue10.2 BlockingQueue四组API10.3 SynchronousQueue同步队列 11. 线程池（重点）12. 四大函数式接口（必须掌握）13. Stream流式计算14. ForkJoin15. 异步回调16. JMM17. Volatile18. 单例模式19. 深入理解CAS20. 原子引用21. 各种锁的理解21.1 公平锁、非公平锁21.1 可重入锁21.3 自旋锁21.4 死锁 1. 什么是JUC JUC 指的就是 java.util.concurrent 工具包的简称，里面的工具类可以很方便的实现多线程的开发。
java.util 工具包、包、分类。
业务：普通的线程代码 Thread。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79ebdaaffb74b4f680d250fd9e54ae57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f31b9cf6b112057c501e6dc08a145e7/" rel="bookmark">
			PDManer安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDManer下载：
PDManer: PDManer元数建模，是一款多操作系统开源免费的桌面版关系数据库模型建模工具，相对于PowerDesigner，他具备界面简洁美观，操作简单，上手容易等特点。支持Windows,Mac,Linux等操作系统，也能够支持国产操作系统。PDMan-2 --&gt; CHINER-3 --&gt; PDManer-4,数据库建模产品的升级延续
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f92887f5c7cc02f060bdfdc8137231c/" rel="bookmark">
			《数学之美》读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用1：搜索引擎 搜索引擎的原理其实非常简单，建立一个搜索引擎大致需要做这样几件事：自动下载尽可能多的网页；建立快速有效的索引；根据相关性对网页进行公平准确的排序。
1 下载 互联网虽然很复杂，但说穿了其实就是一张大图而已——可以把每一个网页当作一个节点，把网页上的超链接当作连接各个网页的弧。有了超链接，就可以从任何一个网页出发，用图的遍历算法（一般是BFS，目的是在有限时间里最多地爬下最重要的网页），自动地访问到每一个网页并把它们存起来。完成这个功能的程序叫作网络爬虫。
假定从一家门户网站的首页出发，先下载这个网页，然后通过分析这个网页，可以找到页面里的所有超链接，也就等于知道了这家门户网站首页所直接链接的全部网页。接下来访问、下载并分析这家门户网站的邮件等网页，又能找到其他相连的网页。让计算机不停地做下去，就能下载整个的互联网。当然，也要记载哪个网页下载过了，以免重复。在网络爬虫中，人们使用哈希表而不是一个记事本记录网页是否下载过的信息。
2 索引 用一个很长的二进制数表示一个关键字是否出现在了每个网页中（互联网上有多少个网页，这个二进制数就有多少位）。比如关键字“原子能”对应的二进制数是0100100011000001……，表示第2、第5、第9、第10、第16个网页中包含这个关键字。同样，假定“应用”对应的二进制数是0010100110000001……，那么要找到同时包含“原子能”和“应用”的网页时，只要将这两个二进制数进行布尔运算AND。结果为0000100000000001……，表示第5、第16个网页满足要求。
为了保证对任何搜索都能提供相关的网页，常见的搜索引擎都会对所有的词进行索引。这个索引是巨大的，在万亿字节这个量级。
为了将这么大的索引存储到服务器上，需要用到数据压缩、分布式存储等技术。
3 排序 总的来讲，对于一个特定的查询，搜索结果的排名取决于两组信息：关于网页的质量信息（Quality），以及这个查询与每个网页的相关性信息（Relevance）。
网页的质量 在互联网上，如果一个网页被很多其他网页所链接，说明它受到普遍的承认和信赖，那么它的排名就高。这就是PageRank的核心思想。
Google的PageRank算法实际上要复杂得多。比如说，对来自不同网页的链接区别对待，因为那些排名高的网页的链接更可靠，于是要给这些链接以较大的权重。
一个网页Y的排名应该来自于所有指向这个网页的其他网页X1，X2，…，Xk的权重之和。而X1，X2，…，Xk的权重分别是这些网页本身的网页排名。
计算搜索结果的网页排名过程需要用到网页本身的排名，计算网页的初始排名是靠【二维矩阵相乘+迭代】的方法解决的。
网页和查询的相关性 使用TF-IDF对搜索关键词的重要性进行度量。
TF：Term Frequency，词频。一般来说，篇幅长的网页比篇幅短的网页包含的关键词要多些。因此，度量网页和查询的相关性，直接使用各个关键词在网页中出现的总词频。
IDF：Inverse Document Frequency，逆文本频率指数。如果一个关键词只在很少的网页中出现，通过它就容易锁定搜索模板，它的权重也就应该大。反之，如果一个词在大量网页中出现，看到它仍然不很清楚要找什么内容，它的权重就应该小。
应用2：新闻的自动分类 计算机根本读不懂新闻，本质上只能做快速计算，这就要求我们先把文字的新闻变成一组可计算的数字，然后再设计一个算法来算出任意两篇新闻的相似性。
首先我们将所有可能与新闻主题有关的实词全部收集起来，建立一张词汇表。
对某一篇特定的新闻，计算出词汇表中每个实词的TF-IDF值（其中大部分是0）。把这些值按照对应的实词在词汇表的位置依次排列，就得到一个向量（词汇表有多少词，这个向量就有多少维度）。
我们就用这个向量来代表这篇新闻，称之为新闻的特征向量。每一篇新闻都可以对应一个特征向量，向量每一个维度的大小代表每个词对这篇新闻主题的贡献。
我们可以定量地衡量两个特征向量之间的相似性。不同的新闻，因为文本长度的不同，它们的特征向量各个维度的数值也不同。但是，如果两个向量的方向一致，说明相应的新闻用词的比例基本一致。因此，可以通过计算两个向量的夹角来判断对应的新闻主题的接近程度。
而要计算两个向量的夹角，就要用到余弦定理。新闻X和新闻Y夹角的余弦等于
​​​​​​​
假定我们已知一些新闻类别的特征向量，那么对于任何一个要被分类的新闻Y，很容易计算出它和各类新闻特征向量的余弦相似性，并将其归入它该去的那一类中。
从理论上讲，这种算法非常漂亮，但是因为要对所有新闻做两两计算，而且要进行很多次迭代，耗时会特别长，尤其是当新闻的数量很大且词表也很大的时候。我们希望有一个办法，一次就能把所有新闻相关性计算出来。这个一步到位的办法利用的是矩阵运算中的奇异值分解。
应用3：YouTube视频反盗版 任何一段信息（包括文字、语音、视频、图片等），都可以对应一个不太长的随机数，作为区别这段信息和其他信息的指纹（Fingerprint）。
信息指纹的计算方法一般分两步。首先，将信息看成是一个特殊的、很长的整数。这一步非常容易，因为所有的字符在计算机里都是按照整数来存储的。接下来就需要用到一个产生信息指纹的关键算法：伪随机数产生器算法（Pseudo-Random Number Generator，简称PRNG），通过它将任意很长的整数转换成特定长度的伪随机数。
只要算法设计得好，任意两段信息的指纹都很难重复（如果用MD5指纹，每一千八百亿亿次才能重复一次），就如同人类的指纹一样。
MPEG视频（在NTSC制的显示器上播放）虽然每秒有30帧图像，但是每一帧之间的差异不大（否则我们看起来就不连贯了）。一般来说，每一秒或若干秒才有一帧是完整的图像，这些帧称为关键帧。其余帧存储的只是和关键帧相比的差异值。因此，处理视频图像首先是找到关键帧，接下来就是用一组信息指纹来表示这些关键帧了。
有了信息指纹后，检测是否盗版就类似于比较两个集合元素是否相同了。
应用4：公开密钥 今天大多数互联网安全协议的基础是公开密钥和电子签名的方法。
每一种公开密钥的加密算法都有如下共同点：
1. 它们都有两个完全不同的密钥，一个用于加密，一个用于解密。
2. 这两个看上去无关的密钥，在数学上是关联的。
RSA算法 以RSA算法为例，加密的方法为：
1. 找两个很大的质数P和Q，越大越好，比如100位长的，然后计算它们的乘积。
N=P×Q
M=(P-1)×(Q-1)
2. 找一个和M互质的整数E。
3. 找一个整数D，使得E×D除以M余1，即E×DmodM=1。
其中E是公钥，谁都可以用来加密，D是私钥用于解密。联系公钥和私钥的乘积N是公开的。
4. 用公式(X^E)modN=Y，得到密码Y。
现在如果没有密钥D，就无法从Y中恢复X。
5. 如果知道D，根据费尔马小定理，按公式(Y^D)modN=X就可以轻而易举地从Y中得到X。
如果想破解公开密钥的加密方式，至今的研究结果表明最彻底的办法还是对大数N进行因数分解，即通过N反过来找到P和Q，这样密码就被破解了。而找P和Q目前只有一个笨方法，就是用计算机把所有可能的数字试一遍。这实际上是在拼计算机的速度，这也就是为什么P和Q都需要非常大。
世界上没有永远破不了的密码，但一种加密方法只要保证50年内计算机破解不了，也就算是满意了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f92887f5c7cc02f060bdfdc8137231c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c3b266c683760426622112ff6d81da/" rel="bookmark">
			fastadmin bootstrapTable 表格无刷新代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		setInterval(function() { var TableOptions = $('#table').bootstrapTable('getOptions'); console.log("ok"); $.ajax({ data: { limit: TableOptions.pageSize, offset: (TableOptions.pageNumber - 1) * TableOptions.pageSize }, type: "post", url: $.fn.bootstrapTable.defaults.extend.dashboard_url, async: true, timeout:3000,//超时时间 success: function(msg) { if (msg.code == '1') { for (var j = 0; j &lt; msg.rows.length; j++) { changeData(j, msg.rows[j]); } }else{ console.log('ok'); } }, error: function () { msgToast.error("查询数据出错"); } }); }, 10000); function changeData(i,msg){ $('#table').bootstrapTable('updateRow', { //i表示第几行，从0开始 index: i, row: { nickname: msg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4c3b266c683760426622112ff6d81da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f9df293feed481bf15d00d2e10076f/" rel="bookmark">
			一台显示器，两台不同的局域网计算机的切换需求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境介绍 业务环境： 根据需求，划分为【内网】【外网】两个不同的局域网，其中【外网】即英特尔互联网，可以访问百度、微博等网站；而【内网】与【外网】互相隔离，两者不能互相访问对方的资源，即【内网】的所有计算机都无法访问来自【外网】的网站、邮件等，同时【外网】的计算机也无法访问【内网】的服务器等。
办公环境： 每一个办公室根据计算机工位的划分，分配对应的【外网】和【内网】网口。
物理设备： 一个工位配备：【外网】计算机一台、【内网】计算机一台、显示器一台、键鼠、宏正CS22U切换器一个、打印机一台、打印机共享切换器一个。
方案需求： 一台显示器可以任意切换为【内网】或【外网】的网络环境。
关键技术 宏正CS22U切换器： USB接口×2、USB插口×4、VGA接口×1、VGA插口×2、一键切换按钮×1
其中，两个USB插口和一个VGA插口作为一套输入的切换目标，共两套。
打印机共享切换器： 方法说明 一台显示器通过一根两端都为VGA插口的数据线，将显示器的VGA接口与切换器主体的VGA接口相连接，切换器的一套输入插口（VGA插口×1、USB插口×2）接到【内网】的计算机，另一套接到剩下的另一台【外网】计算机，键鼠的USB（支持无线键鼠）插入切换器主体的两个USB接口。将对应的网线接入对应的计算机。将一台打印机的USB插口通过打印机自带数据线与一个打印机共享切换器的USB接口相连，将打印机共享切换器自带的两根数据线分别与【内网】和【外网】计算机的USB接口相连。最后只需一键按钮切换即可做到【内网】与【外网】办公环境的切换了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862db56654013618f9959a6f5327e445/" rel="bookmark">
			目标检测tricks总结(记录)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Anchor 可以根据实际任务，修改anchor预设的大小和scale ，也就是说stride + anchor ratio + anchor scales都可以调整，选择不同stride确定了feature map的大小，stride就是说下采样的比例，4就是256*256变成64*64，ratio确定了纵横比和尺度。
2. IoU loss与focal loss IoU loss：用来计算pred box与ground true之间的差异，用来边界框损失函数的计算；focal loss：用来平衡正负样本不均衡的问题，由RetinaNet提出使用与One-Step目标检测算法上的一个技巧 IOU的进化史可以分为Smooth L1 loss、iou loss、giou loss、diou loss、ciou loss， α-iou
具体那个IOU可以查一下
focal loss 出资retinanet，计算流程如下：
focal loss也有一些问题，如果让模型过多关注 难分样本 会引发一些问题，比如样本中的离群点（outliers），已经收敛的模型可能会因为这些离群点还是被判别错误，总而言之，我们不应该过多关注易分样本，但也不应该过多关注难分样本；
focal loss变体 ：
Equalized Focal Loss：Equalized Focal Loss for Dense Long-Tailed Object Detection 就是说focal对于所有的类都一样，而这里认为存在不同类别的正负样本不均衡性的问题，意思就是，对于长尾数据集中的长尾数据来说，正样本更少了，意思是正负样本就更不均衡了，所以需要r变大点，对稀少样本的负样本加以抑制，所以rb就是focal中的r，多了一个rvj就是说对于不同的类别设置的不同，对于稀少样本rvj更大
这里借鉴一篇其他论文的思想，用正负样本的梯度累计来做，对于正负样本均衡的gj就大，对于稀少的样本gj就小，为了满足，我们把限制到[0,1]范围内。超参数s用来缩放EFL中的的上限。
但是这又带来了新的问题，对于相同的，γ越大，loss越小。这导致了当我们想要更加关注一个类别的训练的时候，我们不得不牺牲掉其loss在整个训练过程中的贡献。这导致了稀少类别无法取得更好的效果。也就是说，原本的稀少样本的loss，因为更大的r，确实对于负样本抑制了，但是同时正样本也更小了，整体稀少样本对于loss的贡献更小了，这有肯定不行
所以就有前面这一坨，可以看到r越大，那么EFL对于稀少类别的loss的贡献显著增加了。
cyclical focal loss：提出一种新颖的cyclical focal loss，并证明它是比交叉熵 softmax 损失或focal loss更通用的损失函数，为平衡、不平衡或长尾数据集提供了卓越的性能。 虽然已经发现focal loss损失在具有不平衡类数据的任务中是有益的，但它通常会在使用更平衡的数据集进行训练时降低性能。因此，对于大多数应用来说，focal loss 并不能很好地替代 cross-entropysoftmax 损失。 核心一段话，就是说开始和后期对于简单样本加权，中期开始着重训练困难样本，
看起来很扯，就是把focal中的剪换成加，那这样做的意义在于 看图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/862db56654013618f9959a6f5327e445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b5c8e42fe27bd54414cc87c7b1649b5/" rel="bookmark">
			【BUG记录】Windows server 2008虚拟机下载安装wireshark和npcap后，打开仍然显示没有接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 Windows server 2008虚拟机下载安装wireshark和npcap后，打开wireshark仍然显示没有接口。
尝试使用net start npf，多次结果都不可使用。卸载重装版本比较老的wireshark也不行。
解决方案： 1.首先卸载已安装的npcap。
控制面板-&gt;程序或更改程序-&gt;右击npcap-&gt;卸载。
ps：在安装wireshark的时候，中途就会跳出一个安装npcap，通常都会打勾安装（但是安装了并不能使用，显示没有接口，于是选择删除npcap，安装WinPcap试试）；截图的时候已经卸载了npcap。
2.安装WinPcap。本人是通过共享文件夹的方式向虚拟机送入WinPcap的安装包。
ps：如何向虚拟机传输信息：点击虚拟机左上角设备-&gt;选择增强功能-&gt;然后在计算机处会显示一个光盘-&gt;进去以后点击倒数第三个应用程序进行运行-&gt;一路默认安装即可-&gt;安装完毕之后可以在主机新建一个共享文件，并设置为共享属性-&gt;重新点击虚拟机左上角设备-&gt;点击共享文件夹-&gt;加入主机上刚新建的共享文件夹即可。最终，可以在计算机处看到主机共享的文件。
一路默认next即可。安装好以后进行共享文件夹的设置。
配置好共享文件夹以后就可以在计算机处看到共享的文件夹。并且可以直接在主机里想要传输到虚拟机的文件放入这个共享文件夹即可。
WinPcap的安装包链接：https://www.winpcap.org/install/bin/WinPcap_4_1_3.exe
成功将安装包传输到虚拟机后，双击点开WinPcap安装包，一路默认选择next安装即可。
3.安装好WinPcap后，再次点开wireshark，即显示有接口。而后进行抓包实验，成功抓到网络中的协议包。
结束语 折磨了我两三天的BUG，浅浅记录下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04323b78ef9dada46b1a8498f45dcd33/" rel="bookmark">
			关于如何在markdown文本中书写数学符号和公式（Latex）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown数学符号&amp;公式 为了方便自己以及广大网友查阅，特总结如下：
新增： 向量表示：
\vec{a} -----&gt; a ⃗ \vec{a} a 空格表示：
二元关系符号：
希腊字母：
大尺寸运算符和各种箭头：
定界符：
数学字母：
其它符号：
加^号 输入\hat{a} 或 \widehat{a}，例： a ^ \hat{a} a^ 或 a ^ \widehat{a} a 加横线 输入 \overline{a} ，例： a ‾ \overline{a} a
加波浪线 输入 \widetilde{a} ，例： a ~ \widetilde{a} a 加一个点 \dot{a}，加两个点 \ddot{a} ，例： a ˙ \dot{a} a˙ 或 a ¨ \ddot{a} a¨
嵌入表格：
普通表格的语法：
| 一个普通标题 | 一个普通标题 | 一个普通标题 | | ------ | ------ | ------ | | 短文本 | 中等文本 | 稍微长一点的文本 | | 稍微长一点的文本 | 短文本 | 中等文本 | 真实显示的样式为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04323b78ef9dada46b1a8498f45dcd33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8ab860fca6ff6fae711d00c14e89e1/" rel="bookmark">
			基本注解详解@RequestMapping，@GetMapping
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本注解详解@RequestMapping，@GetMapping 1. @RequestMapping注解 @RequestMapping注解是一个用来处理请求地址映射的注解，可用于映射一个请求或一个方法，可以用在类或方法上。
@RequestMapping注解可以标注的位置 标注在方法上
用于方法上，表示在类的父路径下追加方法上注解中的地址将会访问到
该方法
标注在类和方法上
用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
@RequestMapping的属性 1.1@RequestMapping的value属性 @RequestMapping 的 value 属性必须设值；
@RequestMapping 的 value 属性是通过当前请求的请求地址来匹配请求；
从上面的源码中可以看到value属性是一个字符串类型的数组，因此说明可以将多个请求映射到一个方法上，只需要给 value 来指定一个包含多个路径的数组。
设置value的属性的值
@Controller public class RequestMappingController { @RequestMapping(value = {"/testRequest","/test"}) public String testRequest(){ return "success"; } } 1.2 @RequestMapping的method属性* @RequestMapping的method属性是通过当前请求的请求方式来匹配请求；浏览器向服务器发送请求，请求方式有很多GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS、TRACE。可以使用 method 属性来约束请求方式。 设置请求方式为get:
@Controller public class RequestMappingController { @RequestMapping(value = "/testRequest",method = RequestMethod.GET) public String testRequest(){ return "success"; } } 如果以post方式请求
映射方法中明确要求请求方式为get，所以post方式不被允许，只有修改为get，才能够请求成功，如果要想两种方式都支持，只需在@RequestMapping注解的method属性中添加另一种方式即可，中间用英文逗号隔开。
扩展：
@GetMapping：处理get方式请求的映射
@PostMapping：处理post方式请求的映射
@PutMapping：处理put方式请求的映射
@DeleteMapping：处理delete方式请求的映射
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f8ab860fca6ff6fae711d00c14e89e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28be645e69f97c7f80de3e9a2cf2eca6/" rel="bookmark">
			学习HTML的知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网页
1、：什么是网页
网站是指在因特网上根据一定规律，使用HTML等制作用于展示特定内容的网页集合
网页是网站中的一“页”，通常是HTML格式的文件，他要通过浏览器来阅读。
网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素构成。通常我们看到的网页，常见以.htm或.html后缀结尾的文件，因此将其俗称为HTML文件
2、什么是HTML：
HTML指的是超文本标记语言（Hyper Text Markup Language)，它是用来描述网页的一种语言。
HTML不是一种编程语言，而是一种标记语言（markup language）。
标记语言是一套标记标签（markup tag).
所谓超文本，有2层含义：
2.1、他可以加入图片、声音、动画、多媒体等内容（超越了文本限制）
2.2、它还可以从一个文件跳转到另一个文件，与世界各地主机的文件链接（超级链接文本）。
2.3、网页的形成
网页是由网页元素组成的，这些元素是利用html标签名描述出来，然后通过浏览器解析来显示给用户的。
2.4、网页总结：
网页是图片、链接、声音、文字、视频等元素组成，其实就是一个html文件（后缀为html）。
网页生成制作：由前端人员书写HTML文件，然后浏览器打开，就能看到了网页。
HTML：超文本标记语言，用来制作网页的一门语言，由标签组成的，比如图片标签、链接标签、视频标签等
二、常用浏览器：
1、浏览器概念:浏览器是网页显示、运行的平台，常用的有IE、火狐、谷歌、Safari和Opera等，称为五大浏览器。
2、浏览器内核：
三、Web标准（重点）
Web标准是由W3C组织和其他标准化组织制定的一系列标准的集合。W3C（万维网组织）是国际最著名的标准化组织.
1、为什么需要Web标准：浏览器不同，他们显示页面或者排版就有些许差异，遵循Web标准除了可以让不同的开发人员写出的爷庙更标准、更统一外，还有一下优点：
1.1、让Web的发展前景更广阔。
1.2、内容能被更广泛的设备访问。
1.3、更容易被搜索引擎搜索。
1.4、降低网站流量费用。
1.5、是网站更易于维护。
1.6、提高页面浏览速度。
2、Web标准的构成
主要包括结构、表现和行为三个方面。
2.1、第一个HTML网页：每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这写基本标签上写的，HTML页面也成为HTML文档。
3、开发工具
3.1、文档类型声明标签
4、HTML常用标签
4.1、标题标签
~ (重要)
标签语义：作为标题使用，并且一句重要性递减。特点：加了标题的文字会加粗，字号依次变大；一个标题独占一行
4.2、段落和换行标签（重要）
段落标签：
标签语义：可以把HTML文档分割为若干段落。特点：文本在一个段落中会根据浏览器窗口的大小自动换行；段落和段落之间保有空隙。
换行标签：
(中间的/可以省略)
标签语义：强制换行。特点：
是单标签；
标签只是简单的开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。
4.3、文本格式化标签：有时侯需要为文字设置粗体，斜体，下划线等效果
标签语义：突出重要性，比普通文字更总要。
4.4、和标签：
和是没有予以的，他们就是一个盒子，用来装内容的。
特点：标签是用来布局，但是一行只能放一个
。大盒子；标签是用来布局，一行可以放多个。小盒子。
4.5、图像标签和路径(重点):
图像标签：用于定义HTML中的图像(单标签)。
格式：&lt;img src="图像URL"/&gt;；src是的必须属性，它用于指定图像文件的路径和文件名。
注意：图像标签可以有多个属性，必须写在标签名后；属性不分先后顺序，标签名与属性、属性与属性之间均以空格分开；属性采取键值对的格式，即key=“value”的格式，属性=“属性值”
路径：(1)目录文件夹和根目录。
目录文件夹：就是普通文件夹，里面只不过存放了我们做页面所需要的相关素材，比如html文件、图片等。
根目录：打开目录文件夹的第一层就是根目录。
路径分为相对路径和绝对路径。
相对路径：以引用文件所在位置为参考基础，而建立出的目录路径，简单来说就是图片相对于HTML页面的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28be645e69f97c7f80de3e9a2cf2eca6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814b9089793da67b6bc1fc015adf6c74/" rel="bookmark">
			本地安装brat标注平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地安装brat标注平台 一、官网下载brat安装包
http://brat.nlplab.org/index.html
官网有更详细的安装教程
http://brat.nlplab.org/installation.html#quick_start_installation_using_cgi
二、解压下载的文件
tar xzf brat-v1.3_Crunchy_Frog.tar.gz 三、进入子目录中
cd brat-v1.3_Crunchy_Frog 四、输入登录的账号密码以及邮箱
运行./install.sh 进行安装 user password email 五、安装成功brat就可以运行了
python standalone.py python必须是2.5以上的2.*版本
六、会打印出运行地址
Serving brat at http://127.0.0.1:8001 七、打开链接就可以看到brat运行界面了
八、brat本身是不支持中文模式的，添加中文模式，需要在server/src/projectconfig.py文件中的第163行后面插入一行
n = re.sub(u'[^a-zA-Z\u4e00-\u9fa5&lt;&gt;,0-9_-]', '_',n) 九、添加用户
在brat-v1.3_Crunchy_Frog目录下的config.py文件中找到
USER_PASSWORD = { 'admin': 'admin', 'test':'test', # (add USERNAME:PASSWORD pairs below this line.) } 直接添加用户名密码重新运行brat就可以用刚添加的用户密码登录了。
十、添加数据
定义自己的项目，每个项目里都要有.txt文件和对应的.ann文件，再添加自己的标签配置文件，否则系统会调用默认的标签
在自己的项目中更改annotation.conf 文件来配置自己所需的标签。实体、关系都可以
1.entities用来定义标注的实体名称，其格式为每行一个实体类型， 比如：人名、地名、英雄名、技能名等，可以采用tab来增加二级标注， hero hero1 2.relations用来定义实体间的关系，格式为每行定义一种关系，第一列为关系类型， ArgNrelations用来定义实体间的关系，格式为每行定义一种关系，第一列为关系类型， 随后是用逗号分隔的ArgN:实体名，用来表示关系的各个相关者。 relation1 Arg1:hero1, Arg2:hero1 3.events用来定义事件，每行定义一类事件，第一列为事件名，随后是用逗号分隔的Participant:实体名， 用来表示事件的各个参与者。 4.attributes用来定义属性，每行一个属性，第一列为属性名，随后是用逗号分隔的Arg:&lt;模块类型&gt;, Value:属性值，注意属性值可以有多个 [entities] # Definition of entities.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/814b9089793da67b6bc1fc015adf6c74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf3e8797aef3fbedcfb70a4eaf1d506f/" rel="bookmark">
			ElementUI中的上传文件表单验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		未上传文件
成功上传文件
如何实现以上效果：
1.首先el-uoload里面有很多函数钩子，on-change可以很好的反馈文件上传表示文件状态改变时的钩子，on-remove这个钩子就是当你列表移除这个文件的状态
2.el-form里面校验规则除了比较常用的validate方法外，可是还有变的方法的，这里我们使用validateField对部分表单字段进行校验的方法
代码实现：
&lt;template&gt; &lt;el-form ref="exampleForm" :model="formModel" :rules="rules"&gt; &lt;el-form-item label="上传文件" prop="file"&gt; &lt;el-upload class="upload-demo" ref="upload" :action="fileUploadUrl" :auto-upload="false" :on-change="fileChange" :on-remove="fileRemove" :file-list="fileList" :limit="1" accept=".doc,.docx,.xls,.xlsx,.ppt,.pptx,.pdf"&gt; &lt;el-button slot="trigger" type="primary" size="small"&gt;选择文件&lt;/el-button&gt; &lt;span slot="tip" style="margin-left: 20px"&gt;只能上传doc/docx/xls/xlsx/ppt/pptx/pdf文件&lt;/span&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { formModel: { file: null }, rules: { file: [ { required: true, message: '请至少选择一个产品标签', trigger: 'change' } ] }, } }, methods: { fileChange(uploadFile, fileList) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf3e8797aef3fbedcfb70a4eaf1d506f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/644b554b4b95c5831f423f4442ab62d0/" rel="bookmark">
			C#学习 winform实现简单音乐播放器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#学习 winform实现简单音乐播放器 窗体设计 代码实现 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.IO; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using WMPLib; namespace _31_MusicPlayer { public partial class Form1 : Form { //声明一个list，用来存储文件的路径 List&lt;string&gt; urlList = new List&lt;string&gt;(); double max, min; public Form1() { InitializeComponent(); } //添加歌曲 private void btnInput_Click(object sender, EventArgs e) { //实例化一个打开文件的对话框 OpenFileDialog ofd = new OpenFileDialog(); //让选择器可以同时选择多个文件 ofd.Multiselect = true; ofd.Title = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/644b554b4b95c5831f423f4442ab62d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe26ec47c01e37bd1d9dd91e4858ec65/" rel="bookmark">
			tomcat的宏观架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 什么是tomcat Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为比较流行的Web 应用服务器。
Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。
二. tomcat的组件 首先tomcat是一个Servlet容器，Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。Servlet有三个基本的功能：
创建Request 包装接收客户端请求数据创建Response 包装响应客户端请求的数据以Request 和Response 为参数调用Servlet的service方法做出请求响应 当有了一个Servlet之后，要运行起来就需要一个Servlet容器，于是就有了tomcat。所以Tomcat 就是一个 Servlet 容器, 能接收用户从浏览器发来的请求, 然后转发给 Servlet 处理, 把处理完的响应数据发回浏览器。
在网上找了几张图贴一下，很清晰的展示了tomcat的组件之间的关系。
接下来列一下tomcat的各种组件以及他们的作用：
Server：服务器，就是整个tomcat容器Service：服务，Service是Server的内部组件，一个Service包含多个Server，他把多个Connector绑定到一个Container(Engine)上Connector：连接器，处理与客户端之间连接通信的，负责接收客户端请求并转给相关的容器处理，最后向客户端返回信息，总的来说Connector就是解析Http或Ajp请求的Container：容器，包含Engine、Host、Context、Wrapper这四种类型，这四种容器是父子级关系。其中Engine表示整个 Catalina 的 Servlet 引擎，用来管理多个虚拟站点。Host代表一个虚拟主机，或者说一个站点，可以给 Tomcat 配置多个虚拟主机地址，而一个虚拟主机下可包含多个 Context。Context表示一个 Web 应用程序，一个Web应用可包含多个 Wrapper。Wrapper表示一个Servlet，负责管理整个 Servlet 的生命周期，包括装载、初始化、资源回收等。Component：其他组件，Manager用作session管理、logger 用作日志记录、loader用作启动context以及管理这个context的classloader用的、pipeline用作上下级容器传递信息的通道、valve用作通道(pipeline)中的各种阀门 三. tomcat组件的生命周期 经过上面这些分析，大致的了解了tomcat的整体内容以及组件和组件之间的关系。那么tomcat有这么的组件，是如何进行初始化等等的管理呢？这就到tomcat的Lifecycle 了。
tomcat从设计之初就是指定了完整的生命周期机制
从图中可以看出tomcat自己定制了Lifecycle 接口用以定制生命周期，同时还实现了JMX管理java对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe26ec47c01e37bd1d9dd91e4858ec65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb24b50a078894cca7eebd1651085860/" rel="bookmark">
			死锁的成因和对应的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是死锁
二、产生死锁的三个典型场景 🌰案例一（一个线程一把锁）
🌰案例二（两个线程两把锁）
死锁原因分析
解决办法
🌰案例三（N个线程M把锁）
解决办法
三、形成死锁的四个条件
一、什么是死锁 所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。
比如我和我朋友在吃饺子，我朋友吃饺子蘸醋，我吃饺子蘸辣椒。但我觉得吃饺子光蘸辣椒不过瘾，即蘸辣椒又蘸醋才过瘾。于是我对我朋友说：兄弟，你先把你面前的醋给我好吗？等我吃完了饺子，就把醋和辣椒都给你！！！但我这个时候也对我说：我也想即蘸醋又蘸辣椒，要不你先把你的东西给我，我吃完了饺子，再把醋和辣椒都给你！！！
于是我们就产生了争执，谁也不肯把对方想要的给对方，同时我们又都很执拗，如果不能做到同时即蘸醋又蘸辣椒，就不吃饺子。结果我们谁也吃不完饺子，于是也无法把对方所需要的醋或者辣椒给对方。
其中，我和朋友就相当于是两个进程，醋和辣椒就是两把锁。我和朋友都想同时即蘸醋又蘸辣椒（获取到对方的锁）然后再结束各自的进程，释放锁。但谁都不肯先释放锁，都等着对方释放锁，结果就是谁都无法正常的释放锁，都陷入了阻塞等待中，这也被称为死锁。
二、产生死锁的三个典型场景 🌰案例一（一个线程一把锁） 如果一个线程对同一把锁，连续加了两次锁，并且该锁还是不可重入锁的时候，就会产生死锁。
对可重入锁和不可重入锁的补充
如果同一个线程在重复获取同一把锁的过程中，形成了死锁。这把锁又被称为不可重入锁。而可重入锁的字面意思是“可以重新进入的锁”，即允许同一个线程多次获取同一把锁，不会出现死锁的情况。synchronized 是可重入锁
🌰案例二（两个线程两把锁） package Thread2; import java.util.concurrent.*; import java.util.concurrent.locks.ReentrantLock; public class demo22 { private static Object locker1 = new Object(); // 相当于醋 private static Object locker2 = new Object(); // 相当于辣椒 public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { // t1线程相当于是我朋友，再有醋locker1的情况下，还想获取到我的辣椒locker2 synchronized (locker1) { System.out.println("我目前有醋，但我还想蘸辣椒"); try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb24b50a078894cca7eebd1651085860/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5315122f2bba367ab5bc17c7197ff858/" rel="bookmark">
			python实现word内容替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		doc文件与docx文件不同 存储方式的不同： doc 是二进制存储，docx是打包文件（docx文件可以解压，能看到里面的文件结构，主要是xml 等组成的打包文件）；docx易于跨平台，docx更小；docx对于处理一些复杂对象比如公式、表格、图片更得心应手，因为可以通过xml的配置进行。 1. python-docx #pip install python-docx import docx # 创建文档对象,获得word文档 doc = docx.Document(path) #每一段的内容 for para in doc.paragraphs: print(para.text) #每一段的编号、内容 for i in range(len(doc.paragraphs)): print(str(i), doc.paragraphs[i].text) doc = docx.Document('test.docx') for paragraph in doc.paragraphs: tmp = '' runs = paragraph.runs for i, run in enumerate(runs): tmp += run.text # 合并run字符串 if '需要替换的字符串' in tmp: # 如果存在匹配得字符串，那么将当前得run替换成合并后得字符串 run.text = run.text.replace(run.text, tmp) run.text = run.text.replace('需要替换的字符串', '我是替换后的字符串') tmp = '' else: # 如果没匹配到目标字符串则把当前run置空 run.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5315122f2bba367ab5bc17c7197ff858/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dcf05041a94ea87da6dc097a834e326/" rel="bookmark">
			光场深度探索（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、数据集 数据集统一采用” A Dataset and Evaluation Methodology for Depth Estimation on 4D Light Fields”所提供的HCI 4D 光场数据集。由四个分层场景、四个测试场景和四个训练场景组成。分层场景的设计是为了呈现特定的、孤立的挑战，并在空间上增加难度。为了保证对算法性能的深入和全面的理解，我们量化了各种特征，如前景增肥、纹理敏感性和对噪声的鲁棒性。对于分层和训练场景，我们提供了高分辨率的gt视差图、法线贴图和三维深度点云。另外12个场景也提供了相同的信息转自（原文）
1、数据集下载（可参照链接）： 例如：采用wget http://lightfield-analysis.net/benchmark/downloads/additional.zip在Linux上下载数据集。
2、数据集解压 由于unzip只能解压文件代销小于2G的数据文件，采用unzip解压会报错cannot find or open training.zip, training.zip.zip or training.zip.ZIP.
解决方法
sudo apt-get install fastjar jar xvf a.zip linux系统文件夹命名需要注意不能有太多空格，否则会出现 cd: too many arguments报错！
3、分析数据集 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed49c0bb35c7cc763b8ae9a76ffd5572/" rel="bookmark">
			IDEA中如何使用Git提交代码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、下载Git并在IDEA中配置
二、设置SSH公钥和创建远程仓库
三、在IDEA中提交代码
四、结束语
一、下载Git并在IDEA中配置 详情参考如下链接：
https://blog.csdn.net/weixin_58726101/article/details/127588012
二、设置SSH公钥和创建远程仓库 1、进入官网：Gitee - 基于 Git 的代码托管和研发协作平台，没有账号需要先注册账号。（推荐使用码云，GitHub由于不是国内的，进入网站太慢了）
2、设置SSH公钥，可以让你在你的电脑和Gitee通讯的时候使用安全连接，每次提交代码的时候不用输入密码。点击设置——&gt;SSH公钥，找到C:\Users\***\.ssh中的id_rsa.pub文件，把里面的内容复制到公钥中，点击确定即可。
注：如果.ssh文件夹中没有文件，可以在.ssh文件夹中右键鼠标，点击Git Bash Here，输入ssh-keygen -t rsa命令，一直点击回车创建公钥，也可以参考怎样生成公钥生成公钥。
3、找到新建仓库，填写仓库名称，设置好仓库参数，点击创建。
4、复制仓库的地址。
三、在IDEA中提交代码 1、git init：在当前目录下新建一个Git代码库。
选择要提交的工程项目，在终端中输入git init命令新建一个Git代码库，可以看到IDEA中文件颜色有变化。
打开本地存放工程的文件夹，可以看到多了一个.git文件夹。 2、在菜单栏找到Git，点击Manage Remotes...，配置好git上传远程仓库的地址。
3、git pull 远程仓库地址 远程分支:本地分支，拉取远程仓库代码。
第一次提交前需要先pull一下远程仓库的代码，如果报错可以使用下面命令pull代码：
git pull 远程仓库地址 远程分支:本地分支 --allow-unrelated-histories
4、在项目根目录下创建.gitignore文件，设置不需要提交的文件。（只对还没有添加的文件生效，已添加到暂存区的文件需要使用git rm -r --cached .命令清除缓存）
.gitignore文件如下：
# Compiled class file *.class # Log file *.log # BlueJ files *.ctxt # Mobile Tools for Java (J2ME) .mtj.tmp/ # Package Files # *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed49c0bb35c7cc763b8ae9a76ffd5572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfbc32f0cb96b0a087987fd5624501c0/" rel="bookmark">
			在pycharm里跑pytorch模型时缺少包，且在pycharm里安装慢，提示安装失败，这时候可以在Anaconda里pytorch环境里下载，conda list与pip list区别详细说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题截图 深度学习在pycharm里跑pytorch模型时缺少包，且在pycharm里安装特别慢，还提示安装失败.红线是要安装包，红圈pycharm在装。可能很慢也会失败。
二、conda list与pip list区别 查看两个命令出来的结果
区别：Conda 除了当前虚拟环境下包有的，还有关联文件下的；Pip只有当前虚拟环境下的。当关联环境下有这个包，再用conda在其他虚拟环境下下载该包就会直接关联不用下载。比如说base环境下有包，在另一个环境下下载同样的包，就会关联上，不用真的下载，直接复制过去或者关联即可，验证得到：pip下的list是conda下list的子集。
pip list和conda list列表却不一致，conda数量 &gt; pip，conda 安装包路径是 xxxxx\Anaconda3\pkgs
pip 安装包路径在虚拟环境下是 xxxx\Anaconda3\envs\a_conda_env\Lib\site-packages
所以当前环境下pip list只列举出当前包list，此处需要留意如果使用conda install 多个环境时，对于同一个包只需要安装一次。有conda集中管理。但是如果使用pip因为每个环境安装使用的pip在不同的路径下，故会重复安装，而包会从缓存中取。
(pytorch38) C:\Users\Administrator&gt;pip list Package Version -------------------- ----------- argon2-cffi 21.3.0 argon2-cffi-bindings 21.2.0 asttokens 2.0.5 attrs 21.4.0 backcall 0.2.0 beautifulsoup4 4.11.1 bleach 4.1.0 brotlipy 0.7.0 certifi 2022.9.24 cffi 1.15.1 charset-normalizer 2.0.4 colorama 0.4.5 cryptography 38.0.1 debugpy 1.5.1 decorator 5.1.1 defusedxml 0.7.1 entrypoints 0.4 executing 0.8.3 fastjsonschema 2.16.2 idna 3.4 importlib-resources 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfbc32f0cb96b0a087987fd5624501c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5570d63dd5678322227555c6dcfa89d3/" rel="bookmark">
			输入一个日期，判断这一天属于这一年的第几天（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一
import datetime date = input("请输入某年某月某日，格式是 yyyy-mm-dd: ") y = int(date[0:4]) # 获取年 m = int(date[5:7]) # 获取月 d = int(date[8:]) # 获取日 targetdate = datetime.date(y,m,d) # 将输入的日期转化为标准日期 thisyeardate = datetime.date(y,1,1) # 获取当前年第一天的标准日期 daycount = (targetdate - thisyeardate + 1).days print(daycount) 方法二
date = input("请输入某年某月某日，格式是 yyyy-mm-dd: ") y = int(date[0:4]) # 获取年 m = int(date[5:7]) # 获取月 d = int(date[8:]) # 获取日 # 能被4整除但不能被100整除的年份为普通闰年,能被400整除的为世纪闰年。 if y%100 == 0: if y%400 == 0: ms = [31,29,31,30,31,30,31,31,30,31,30,31] elif y%4 == 0: ms = [31,29,31,30,31,30,31,31,30,31,30,31] else: ms = [31,28,31,30,31,30,31,31,30,31,30,31] days = 0 for i in range(1,13): # 确定月份 if i == m : for j in range(i-1): # 确定月份后将该月前的天数累加 days += ms[j] print(days) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b6909de308844c104d82aa333d7e66/" rel="bookmark">
			关于调起系统日历预填信息问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开发遇到一个问题，需要调起系统日历，添加日历事件，但是会出现有些手机无法预填信息的情况；在这里对这个问题做个小记录；
调起系统日历的方法很简单，用Intent就行，如下：
Intent intent = new Intent(Intent.ACTION_EDIT) .setType("vnd.android.cursor.item/event") .putExtra(CalendarContract.Events.TITLE, "title") .putExtra(CalendarContract.Events.DESCRIPTION, "description" .putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, "开始时间") .putExtra(CalendarContract.EXTRA_EVENT_END_TIME, “结束时间”) .putExtra(CalendarContract.EXTRA_EVENT_ALL_DAY, “1”) .putExtra(CalendarContract.Events.HAS_ALARM, “1”); 通过这些方法测试，发现在部分手机上出现无法预填信息的情况，及传递的参数在系统日历上无法显示出来。
这里我们使用的是Intent.ACTION_EDIT，不能说不对，只能说不是很恰当，因为带有编辑的意思，并将extra中由常量指定的任何已知联系人信息包括在 ContactsContract.Intents.Insert中，Intent.ACTION_EDIT比较适合用在编辑现有联系人。官方API解释如下
基于官方的解释，我们看看官方对于添加日历事件的解释，如下：
很明显，需要使用的是ACTION_INSERT，并指定具有 Events.CONTENT_URI 的数据 URI，所以修改后代码如下：
Intent intent = new Intent(Intent.ACTION_INSERT); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setData(CalendarContract.Events.CONTENT_URI) .putExtra(CalendarContract.Events.TITLE, "title") .putExtra(CalendarContract.Events.DESCRIPTION, "description" .putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, "开始时间") .putExtra(CalendarContract.EXTRA_EVENT_END_TIME, “结束时间”) .putExtra(CalendarContract.EXTRA_EVENT_ALL_DAY, “1”) .putExtra(CalendarContract.Events.HAS_ALARM, “1”); 经过测试，以手上有限的测试机测试，目前发现OPPO、小米、华为、三星、1+都能正常调起系统日历且能预填信息成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de4473f20ca9e800d3d37e387e0599a/" rel="bookmark">
			python redis 获取所有key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用scan代替getKeys 线上的登录用户有几百万，数据量比较多；keys算法是遍历算法，复杂度是O(n)，也就是数据越多，时间越高。
数据量达到几百万，keys这个指令就会导致 Redis 服务卡顿，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。
正式环境不能使用getKeys，使用scan代替
import time from random import sample import redis r = redis.StrictRedis("127.0.0.1", "6379", 1, decode_responses=True, password="123456") print(len(r.scan(cursor=0,match="ONLINE_USER*",count=1000000)[1])) 参考1. 正确访问Redis中的海量数据
参考2. Redis中有几百万数据量，如何进行高效访问
参考2.https://redis.io/commands/keys/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d080114d64a3ea7461083136f3a74f/" rel="bookmark">
			DISABLE_B162428_XA_FIX 配置参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 DISABLE_B162428_XA_FIX 配置参数来指定释放事务的时刻。
onconfig.std 值
不在 onconfig.std 文件中。
值
0 = （缺省）仅当调用 xa_rollback 时释放事务。
1 = 如果是非 xa_rollback 的事务回滚，则释放事务。
单位
整数
生效
编辑 onconfig 文件并重启数据库服务器之后。
用法
设置 DISABLE_B162428_XA_FIX 为 1，在事务回滚之后立即释放所有全局事务。
您可用 IFX_XASTDCOMPLIANCE_XAEND 环境变量取代客户端会话的 DISABLE_B162428_XA_FIX 配置参数。
设置 IFX_XASTDCOMPLIANCE_XAEND 为 1，则仅当调用 xa_rollback 时释放事务。设置 IFX_XASTDCOMPLIANCE_XAEND 为 0， 则在非 xa_rollback 的事务回滚时释放事务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d3db9446136a6635e5e74619671ac63/" rel="bookmark">
			DIRECTIVES 配置参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 DIRECTIVES 配置参数来启用或禁用优化器指令。这些指令指定在开发 SELECT、 UPDATE 和 DELETE 语句的查询计划中查询优化器的行为。
onconfig.std 值
DIRECTIVES 1
值
0 = 禁用优化器指令
1 = 启用优化器指令
生效
编辑 onconfig 文件并重启数据库服务器之后。
当您通过运行 onmode -wf 命令在 onconfig 文件中动态地重置该值时。
当您通过运行 onmode -wm 命令重置内存中的该值时。
环境变量
IFX_DIRECTIVES
用法
设置 DIRECTIVES 为缺省值 1，来启用数据库服务器处理优化器指令。
设置 DIRECTIVES 为 0 来禁用数据库服务器处理指令。
客户端程序还可设置 IFX_DIRECTIVES 环境变量为 ON 或 OFF 来启用或禁用数据库服 务器处理指令。 IFX_DIRECTIVES 环境变量的设置取代 DIRECTIVES 配置参数的设置。 如果您不设置 IFX_DIRECTIVES 环境变量，则客户端的所有会话继承数据库服务器配置 处理指令。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66280b263a50cab9ac3868d6bea80b44/" rel="bookmark">
			DIRECT_IO 配置参数（UNIX）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 DIRECT_IO 配置参数来控制用于 dbspace chunk 的熟文件直接 I/O。 该参数在 UNIX™ 平台上启用直接 I/O （绕过文件系统缓冲）或在 AIX® 操作系统上启 用并发 IO（绕过文件系统缓冲和不必要的写串行化。）
onconfig.std 值
DIRECT_IO 0
值
0 = 不使用直接 I/O 或并发 I/O
1 = 如果可以使用，则直接 I/O，绕过文件系统缓冲
2 = 在 AIX 操作系统上启用并发 I/O（并发 I/O 选项包括直接 I/O 和并发 I/O。）
生效
编辑 onconfig 文件并重启数据库服务器之后。
用法
直接 I/O 仅可用于 dbspace chunk，其文件系统支持页大小的直接 I/O。
通过使用直接 I/O，您能减少 AIO 虚拟处理器的数目。
如果启用直接 I/O，则使用文件系统支持的 KAIO（内核异步 I/O）。然而，如果设置环境 变量 KAIOOFF，则不使用 KAIO。当直接 IO 和 KAIO 都使用时，可减少 AIO 虚拟处 理器的数目。如果使用直接 IO，但不使用 KAIO，则不应减少 AIO 虚拟处理器的数目。 对于用作临时 dbspace chunk 的熟文件，GBase 8s 不使用直接或并发 I/O。 在 AIX 上，如果 GBase 8s 使用 chunk 的并发 I/O，则另一个程序（比如一个联机外部 备份程序）必须也使用并发 I/O。否则，文件打开操作将失败。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66280b263a50cab9ac3868d6bea80b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7161fdaf35e294cd066e653307eeed70/" rel="bookmark">
			毕业设计 : 基于深度学习的口罩佩戴检测【全网最详细】 - opencv 卷积神经网络 机器视觉 深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚩 0 简介🚩1 课题背景🚩 2 口罩佩戴算法实现2.1 YOLO 模型概览2.2 YOLOv32.3 YOLO 口罩佩戴检测实现数据集 2.4 实现代码2.5 检测效果 🚩 3 口罩佩戴检测算法评价指标3.1 准确率（Accuracy）3.2 精确率(Precision)和召回率(Recall)3.3 平均精度(Average precision AP) 🚩 4 最后 🚩 0 简介 今天学长向大家介绍一个机器视觉的毕设项目
基于深度学习的口罩佩戴检测【全网最详细】 - opencv 卷积神经网络 机器视觉 深度学习
🚩1 课题背景 从2019年末开始，新型冠状病毒肺炎（COVID-19）在我国全面爆发并迅速传播，同时国家卫生健康委员会也积极响应密切关注全国疫情的动态变化并且发布了相关的预防指南，强调个人出行需要做好安全措施，在公共场合必须严格按照要求佩戴口罩。自从新型冠状病毒蔓延以来，各行各业都受到了巨大的冲击，严重影响到人们正常生产和生活。
新型冠状病毒具有很强的传播和生存能力，只要条件合适能存活五天之久，并且可以通过唾液，飞沫等多种方式进行传播，为有效的减少病毒的传播佩戴口罩是一个很好的办法。尽管这一时期国外的形势不容乐观，但是在全国上下齐心努力之下我国的防疫取得了阶段性成功，各行业都在积极复苏，管理也随之变化进入到常态化阶段。在这一阶段复工复产也是大势所趋，口罩出行也成为了一种常态。正确佩戴口罩能够有效减少飞沫传染的风险，特别是在公共场所，这种举措尤为重要。但是，仍然还需要提高公众对主动佩戴口罩的观念，在常态化管理下人们的防范意识越来越薄弱，口罩随意佩戴或者不佩戴的情况屡见不鲜。
因此，在这期间，有意识地戴口罩不仅仅是每个公民的公共道德还是自我修养的表现。这不但需要个人积极配合，而且还需要某些监管以及有效的治理方法。
🚩 2 口罩佩戴算法实现 2.1 YOLO 模型概览 YOLO 的缩写是 You only look once。YOLO 模型可以直接根据图片输出包含对象的区域与区域对应的分类，一步到位，不像 RCNN 系列的模型需要先计算包含对象的区域，再根据区域判断对应的分类，YOLO 模型的速度比 RCNN 系列的模型要快很多。
YOLO 模型的结构如下：
是不是觉得有点熟悉？看上去就像 Faster-RCNN 的区域生成网络 (RPN) 啊。的确，YOLO 模型原理上就是寻找区域的同时判断区域包含的对象分类，YOLO 模型与区域生成网络有以下的不同：
YOLO 模型会输出各个区域是否包含对象中心，而不是包含对象的一部分YOLO 模型会同时输出对象分类YOLO 模型输出的区域偏移会根据对象中心点计算，具体算法在下面说明 YOLO 模型与 Faster-RCNN 的区域生成网络最大的不同是会判断各个区域是否包含对象中心，如下图中狗脸覆盖了四个区域，但只有左下角的区域包含了狗脸的中心，YOLO 模型应该只判断这个区域包含对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7161fdaf35e294cd066e653307eeed70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f5eab0f500f4151789bc6c95586255/" rel="bookmark">
			-bash: vim: command not found(快速解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Step1 : vim /etc/hosts
Step2 : 检查系统中是否存在安装包。rpm -qa|grep vim
Step3: 安装vim yum -y install vim*
Step 4: 测试 vim /etc/hosts
[root@localhost etc]# vim /etc/hosts
-bash: vim: command not found
[root@localhost etc]# vim hosts
-bash: vim: command not found
[root@localhost etc]# rpm -qa|grep vim
vim-minimal-7.4.629-8.el7_9.x86_64
[root@localhost etc]# yum -y install vim*
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
* base: mirrors.nju.edu.cn
* epel: mirrors.tuna.tsinghua.edu.cn
* extras: mirrors.nju.edu.cn
* updates: mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2f5eab0f500f4151789bc6c95586255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f3ef03e5f9e251bd4b7ecbe55fbd03/" rel="bookmark">
			YOLOv5网络结构模块（YOLOv5 5.0版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出于学习的目的，总结一下关于YOLOv5的一些知识点，也是我第一次写文章，如有错误，希望能够得到指导出来。
先是YOLOv5的整体网络结构
引用了(1条消息) yolov5网络结构学习_「已注销」的博客-CSDN博客_yolov5结构博客中的图片
YOLOv5的网络结构主要分为三个部分：Backbone，Neck，Prediction。
输入端：使用了马赛克数据增强的方法，在源码中的主要步骤有：首先YOLOv5是按照一个批次一个批次的送入网络模型进行训练，然后通过超参数可以选择是否打开马赛克数据增强。首先随机取一个生成后的马赛克增强图片的中心点，然后随机选择其他三张需要增强的图片的索引；通过一个for循环遍历图片的索引，然后在需要生成的马赛克大图上进行图片的“存放”，源码中从上到下的顺序是左上角，右上角，左下角，右下角（当前索引到的图片具体放在大图中的那个位置是通过计算得出的不是乱放的，并且还要通过计算得到小图中哪一部分放到大图中，因为有可能会出现越界的情况，此时就会截取小图的一部分放进去）；然后有一个重新计算标签位置的操作，因为现在重新生成了一个增强的大图，所以目标框标签的位置也要重新计算了，计算完成后就要进行标签位置的调整；接着还有一种情况，那就是增强后的大图中，有的小图目标框可能在大图外面，此时就需要重新调整这一部分的目标框，让它们重新放到大图中来；此时就得到了mosaic增强后的大图了；最后，还要对得到的这个大图进行随机旋转，平移，缩放，裁剪等传统的数据增强操作，此时就是最后得到的马赛克增强大图了。（源码中有mosaic和mosaic9两种增强方法）。在mosaic数据增强的代码下方，还有一个if not mosaic分支，这是为了当我们选择不使用马赛克增强的时候，模型会自动帮我们选择自带的数据增强操作（例如有：随即改变图片的色调，饱和度，亮度等）。这些大致就是输入端对图片主要进行的预处理操作了。注：马赛克数据增强是在输入一个批次一个批次的时候进行的，不是整体输入的时候进行的，它针对的是一个batch_size。马赛克数据增强对于小目标的检测有一定的帮助。
backbone：backbone的主要作用就是用来提取目标的网络特征的（有一种说法是如果要修改网络结构尽量在neck特征融合层和输出头改，因为backbone训练的挺好的了）。下面分别记录backbone的主要网络模块。
首先是Focus结构，这个模块不涉及深度学习的相关操作，就是简单的把图片分片了，并且是在原始图片上跳跃地进行分片（我认为这么做的好处是：卷积核进行卷积是按照一定的步长进行的，因此原图上相隔较远的地方就不能通过一个卷积核卷积到，通过这种跳跃式的分片连接，相当于在一定程度上增加了感受野），这个模块的作用：主要是为了提升模型的训练速度，对AP没有提高的作用。
随后是CBL结构，通过图可以看出来，这个模块由三个模块组成，分别是Conv卷积，BN层，激活函数，图中采用的是leacky relu激活函数，v5 6.0版本采用了Silu激活函数。Conv目的是学习目标特征，BN层目的是防止过拟合，便于模型训练，激活函数是为了引入非线性因素，便于模型更好的进行目标对象的拟合。
随后是CSP1_X结构（neck层中采用的是CSP2_X结构，6.0版本中全部统一替换成为了C3结构），其实CSP1_X和CSP2_X结构很类似，无非就是其中是否包含要给ResUnit结构罢了，ResUnit结果通过观察可以发现，它大致就是进行了前几层的特征和后几层特征的一个融合，这样可以防止一些特征在卷积过程中丢失。
backbone中最后就是SPP结构了，通过图中可以看出，SPP结构就是把输入特征图分为了四个方向（三个方向使用了不同大小的池化核进行最大池化操作，另外一条路直接连接最终结果）。
Neck：YOLOv5的Neck采用了FPN + PAN的结构，如下图所示（同样是引用了上面的博主的图片）
作用：FPN结构的走向是自顶向下进行的，PAN结构的走向是自底向上进行的。因此，FPN可以从上往下传递强语义特征，而PAN可以自底向上传递强定位信息，因此，这两个结构的结合，让模型在不同的层得到的参数进行聚合，得到了强语义信息和强定位信息。（注意在不同层的聚合过程中，要保证他们之间的特征大小一致）
Prediction：YOLOv5采用的损失函数分为三个部分：
（1）Bounding Box损失函数(box_loss)，YOLOv5在这一块采用的是CIOU|_LOSS作为目标框的回归损失，box loss用来表示目标框的大小和精确的位置。
（2）分类损失(cls_loss)：计算预测框和对应的类别是否正确。这里采用的损失函数是BCEWithLogistsLoss损失。
（3）置信度损失(obj_loss)：用来计算目标的置信度，这里采用的损失函数也是BCEWithLogistsLoss损失。置信度的作用：用来表示预测框的可信程度，取值范围0-1，值越大说明预测框中越可能存在目标。
每一次训练输入网络一个batch_size大小的图片数据，通过64/batch_size次的前向传播训练累计得到的损失，利用这个得到的损失进行一次反向传播，进行梯度的更新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0cb5bc26fa35a2cda02ba4af9df495f/" rel="bookmark">
			day3.python基础中下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件操作 打开文件 open(file,mode)函数：
file参数指定的是文件路径和文件名，如果没有传入路径(绝对/相对)，默认就是将文件创建在python的主文件夹下面
mode:【可选参数】，打开的模式，常见参数：
参数值作用‘r’读取（默认）‘w’写入（如果文件已存在，则先截断、清空文件）‘x’排他性创建文件（如果文件已存在，则打开失败）‘a’追加（如果文件已存在，则在末尾追加内容）‘b’二进制模式‘t’文本模式（默认）‘+’更新文件（读取和写入） ​
文件对象 文件对象的各种方法及含义：
方法名作用f.close()关闭文件对象f.flush()将文件对象中的缓存数据写入到文件中（不一定有效）f.read(size=-1,/)从文件对象中读取指定数量的字符（或者遇到EOF停止）；当未指定该参数时，或者该参数为负值的时候，读取剩余的所有字符f.readable()判断该文件对象是否支持读取（如果返回值为False，则顶用read()方法会导致OSError异常）f.readline(size=-1,/)从文件对象中读取一行字符串（包括换行符），如果指定了size 参数，则表示读取size个 字符f.seek(offset,whence=0,/)修改文件指针的位置，从whence参数指定的位置（0代表文件的起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节，返回值是新的索引位置f.seekable()-判断该文件对象是否支持修改文件指针的位置（如果返回的值为False,则调用seek()，tell(),truncate()方法都会导致OSError异常）f.tell返回当前文件指针在对象中的位置f.truncate(pos=None,/)将文件对象截取到pos的位置，默认是截取到文件指针当前的位置f.write(text,/)将字符串写入到问价对象中，并返回写入的字符数量（字符长度）f.writable()判断该文件对象是否支持写入（如果返回的值是False，则调用write()方法会导致OSError异常）f.writelines(lines,/)将一系列字符串写入到文件对象中（不会自动添加换行符，所以通产是认为的加在每个字符串的末尾） （只介绍部分参数，更多的详情,请参考官方文档）
路径处理 ​ pathlin–面向对象的文件系统路径，pathlib是python3.4之后添加的模块，可以让文件和路径操作变得快捷方便，完美带了os.path
pathlib中path模块中文件对象： is_dir():判断一个路径是否为一个文件夹is_file()：判断一个路径是否为一个文件exists():检测一个路径是否存在name属性:获取路径的最后一部分stem属性：获取文件名suffix属性:获取文件的后缀parent属性：获取父级目录parents属性：获取逻辑祖先路径构成的一个不可变序列parts:将路径的各个组件拆分成元组stat():查询文件或文件夹的信息iterdir()；获取当前路径下所有子文件和子文件夹mkdir():创建文件夹，如果已创建的文件存在，就会报错,将参数exist_ok = True，已经存在就不会报错；如果参数exist_ok = True,但路径中存在多个不存在的父级路径目录，也会报错，将parents = True就可以open():Path包内部还打包了一个open（）方法，跟open方法一样，不过路径参数不使用rename():修改文件或文件夹的名字，会移动文件repalce():替换指定的文件或文件夹rmdir:删除文件夹unlink():删除文件glob():查找功能 相对路径和绝对路径的转换： resolve():可以将相对路径转换为绝对路径
Path('../Python310').resolve() WindowsPath('C:/Users/Administrator/AppData/Local/Programs/Python/Python310') with语句和上下文管理器 为文件操作提供了一种更为便捷的方式，传统操作文件的方式是：打开文件，获得文件对象，写入文件内容，最后关闭文件；而使用with上下文管理器：
##f = open('./day1.a.txt','a') ##f.write('叮当叮当丁呀丁呀叮当') ##f.close() #使用with with open('./day1.a.txt','a') as f: f.wirte('with的使用方法') 使用with上下文管理最大的优势：它能够确保资源的释放，即自动关闭文件；因为手动f.close()关闭文件之前有可能发生保证，打断文件的正常关闭：
with open('./day1.a.txt','a') as f: f.write(r'\nwith的使用方法') 1/0 ​4. pickle pickle模块可以将python对象序列化(将python对象转换Wie二进制字节流)，解决的就是永久存储python对象的问题，它允许你将字符串、列表、字典这些python对象给保存为文件形式
​ ​ 相关函数：
​
dump:将python对象写入后缀.pkl
import pickle strs = 'Hello Python !I love you forever' x,y,z = 1,2,3 l = [1,2,3,4,5] d = {'name':'小张', 'age':18} with open('data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0cb5bc26fa35a2cda02ba4af9df495f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28d68c83d81ecc506b839ae9d42261fd/" rel="bookmark">
			Java订单编号生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、订单编号是什么？二、使用步骤1.引入库2.生成订单编号3.生成结果 三、代码效率1.生成100万的订单编号2.生成100万的订单编号耗时 总结 前言 开发过程当中可能会遇见生成订单编号，那么订单编号分为有序的，也分为无序的编号，今天本文介绍有序的订单编号，根据时间戳来生成订单编号。
一、订单编号是什么？ 订单编号代表该单据在一个系统当中独一无二的存在，不可能会有第二个订单编号的存在，在平时购物的时候，吃饭的时候等都会生成对应的订单编号，吃饭的时候生成流水号，购物的时候生成订单编号和交易号，都会有相关的编码规则来实现。
二、使用步骤 1.引入库 代码如下（示例）：
import java.text.SimpleDateFormat; import java.util.Date; import java.util.Random; 2.生成订单编号 该代码是根据时间戳来生成14位的时间格式编号，后面getRandom方法又是随机生成6位数的编码，这样订单编码就是20位，中间有6位并发线程。什么意思呢，中间的6为随机号可以承载的并发量也就是10万级别的，保证在一秒以内生成的订单编号就不会出现重复，里面设置了24位数的限制，如果不满24位数可以通过0来补齐，在实际的开发当中也可能生成固定位数订单编码，所以是可以通过这个长度来进行控制，满足实际的开发需求。
代码如下（示例）：
public class orderNoCreate { public static void main(String[] args) { System.out.println(randomOrderCode()); } public static String randomOrderCode() { SimpleDateFormat dmDate = new SimpleDateFormat("yyyyMMddHHmmss"); String randata = getRandom(6); Date date = new Date(); String dateran = dmDate.format(date); String Xsode = "XS" + dateran + randata; if (Xsode.length() &lt; 24) { Xsode = Xsode + 0; } return Xsode; } public static String getRandom(int len) { Random r = new Random(); StringBuilder rs = new StringBuilder(); for (int i = 0; i &lt; len; i++) { rs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28d68c83d81ecc506b839ae9d42261fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/573c2805a176aed9be112e3bc49f8948/" rel="bookmark">
			解决Beego安装过程中遇到的各种问题(亲测有效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1 问题 % go get -u github.com/beego/beego/v2 package github.com/beego/beego/v2: cannot find package "github.com/beego/beego/v2" in any of: /usr/local/go/src/github.com/beego/beego/v2 (from $GOROOT) /Users/guands/go/src/github.com/beego/beego/v2 (from $GOPATH) 解决办法 添加环境变量
低版本: export GO111MODULE=on
高版本: go env -w GO111MODULE=on
问题2 问题 go get网络太慢
解决办法 添加环境变量
低版本: export GOPROXY=https://goproxy.cn
高版本: go env -w GOPROXY=https://goproxy.cn
问题3 问题 go: github.com/codahale/hdrhistogram@v1.1.2: parsing go.mod: unexpected module path "github.com/HdrHistogram/hdrhistogram-go" go: gopkg.in/fsnotify.v1@v1.6.0: go.mod has non-....v1 module path "github.com/fsnotify/fsnotify" at revision v1.6.0 go: github.com/circonus-labs/circonusllhist@v0.3.0: parsing go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/573c2805a176aed9be112e3bc49f8948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2841c48310fe68678e8ecf2a39b8ae11/" rel="bookmark">
			【C语言练习题】abc&#43;cba=1333
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 已知a，b，c都是1位整数，求当三位整数abc、cba的和为1333时a、b、c的值。
#include&lt;stdio.h&gt; int main() { int i,j,k; for(i=0;i&lt;10;i++) { for(j=0;j&lt;10;j++) { for(k=0;k&lt;10;k++) { if(i*100+j*10+k+k*100+j*10+i==1333) { printf("%d %d %d",i,j,k); printf("\n"); printf("-----\n"); } } } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ab9b63b3b50e5c01f5d8dbd30339b8/" rel="bookmark">
			导出开发板根文件系统rootfs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： 1、Windows子系统Linux Ubuntu18（没有安装子系统的，虚拟机也是一样），需要注意的是Windows子系统Linux Ubuntu18需要是WSL2版本。
2、开发板RK3288，安装SSH，并允许root登录
3、开发板和Ubuntu18都需要安装rsync服务
一、从设备导出根文件系统 1、Ubuntu18和RK3288都更新一下：
apt-get update apt-get upgrade
如出现Errors were encountered while processing报错，解决：
cd /var/lib/dpkg sudo mv info info.bak sudo mkdir info sudo apt-get upgrade 2、Ubuntu18和RK3288安装rsync服务
sudo apt install rsync
3、在Ubuntu18上创建一个操作目录，如 /ubuntu/
make /ubuntu/
4、在/ubuntu/下在建立存文件的目录，如rootfs
make /ubuntu/rootfs
备注：第3、4步骤可以合并为一个操作：
make -p /ubuntu/rootfs
5、进入/ubuntu/目录进行下一步，使用ifconfig命令查询到RK3288开发板的IP地址并记住
cd /ubuntu
6、把开发板上的根文件系统克隆到rootfs文件夹，此处假设开发板IP为192.168.1.102
rsync -avx root@192.168.1.102:/ rootfs
命令执行完后，/ubuntu/rootfs里就保存着和开发板系统上一样的文件系统内容了。
二、打包生成rootfs.img文件 1、制作镜像了，用dd工具创建镜像文件：
cd /ubuntu/
sudo du -h --max-depth=0 rootfs dd if=/dev/zero of=rootfs.img bs=1M count=4096
2、格式化镜像文件，并加入linuxroot卷标：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ab9b63b3b50e5c01f5d8dbd30339b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b08a2995b816fb8d83c8b377c0799c2/" rel="bookmark">
			Java网上订餐管理系统餐饮就餐订餐餐厅（含源码&#43;论文&#43;答辩PPT等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该项目采用技术JSP、Servlet、jdbc、Tomcat服务器、MySQL数据库 ，项目含有源码、论文、配套开发软件、软件安装教程、项目发布教程
网上订餐管理系统总共2个模块
1.前台模块： （1）食品展示模块 （2）食品查询模块 （3）购物车模块 （4）收银台模块 （5）用户维护模块 （6）订单查询模块 （7）公告模块
2.后台模块： （1）食品管理模块 （2）用户管理模块 （3）管理员维护模块 （4）订单管理模块 （5）公告管理模块 （6）留言管理模块
网上订餐管理系统主要包括了9张数据表：
餐品菜品信息数据表c_book
用户顾客注册数据表表member
管理员数据表admin
餐品菜品类别数据表c_booktype
用户评论数据表comment
订餐车数据表gouwuche
营养小贴士数据表news
订单数据表num
订单详情信息数据表orderbook
下面是系统运行起来后的部分截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1007d153f6a591cc0aaac30c84f2d4e7/" rel="bookmark">
			2022护网日记，护网工作内容、护网事件、告警流量分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「作者主页」：士别三日wyx
「作者简介」：CSDN top100、阿里云博客专家、华为云享专家、网络安全领域优质创作者
2022护网日记 一、监控设备二、工作内容三、安全事件 1）失陷主机排查2）后门网站修复 四、告警流量分析 1）信息泄露2）SQL注入3）文件上传4）XSS（跨站脚本）5）代码执行 今年HW总共15天，7月25号开始，到8月8号结束。
总的来说，人坐在电脑前的时候，风平浪静，时不时蹦出几个告警。
可一到换班或去厕所的时候，就会突然冒出几百条告警。
我一度怀疑我们的摄像头是不是已经被入侵了，一看到我人离开就开始攻击。
如果你问我，今年HW最大的收获是什么，我一定会说：我收获了一个强大的膀胱！！！
一、监控设备 首先是设备，（本人）这次HW使用的安全产品主要有两个：天眼和椒图。
产品全称天眼奇安信天眼威胁检测与分析系统椒图奇安信网神云锁服务器安全管理系统 天眼负责流量分析，部署在旁路，对交换机镜像过来的流量进行监测、分析和溯源。
椒图负责服务器的系统防护，通过在服务器上安装的客户端，将收集到的主机信息发送到控制中心集中分析。
二、工作内容 防守方主要分为三个组：安全监控组、事件研判组、应急处置组。
1）监控组分析安全设备的告警，确定是攻击就提交给处置组封禁IP；分析不出来就提交给研判组分析。
2）研判组负责分析监控组提交的告警是否为攻击，必要时可以访问受害网站复现攻击，或者联系受害网站的负责人验证是不是正常业务/人为操作。
3）处置组主要负责封禁IP，如果是webshell这种攻击，还需要联系受害网站的负责人，协助修复漏洞或者加固网站。
三个组通过指挥调度管理系统进行协作防护：
大家上班第一件事就是登录管理系统，监控组向管理系统提交告警的攻击/受害IP、告警类型以及payload，处置组/研判组看到管理系统上有新的告警了就封禁IP/分析告警事件。
原则上来说，我一个安全监控组，只需要盯着安全设备，简单分析一下然后提交告警就可以了。
由于公司就来了我一个，只要是我们产品相关的事，都会把我喊过去。
因此，除了设备监控外，我的工作还包括但不限于：分析webshell文件、分析病毒木马文件、升级/加固安全产品、对失陷主机进行后门扫描和病毒查杀、以及协助失陷网站修整加固。。。
三、安全事件 好了，撇开厕所不谈，下面分享几个印象比较深的攻击事件吧：
1）失陷主机排查 青藤云的蜜罐检查到，有个用户电脑访问了蜜罐的80端口，用户断网以后用360和火绒查杀了三个毒以后，重新上线，结果又踩了蜜罐，用户又用360和火绒扫了一遍，啥也没扫出来，就喊我过去处理。
当时我就一脸懵逼：这是我一个安全监控该干的事吗？
但架不住一群人直勾勾的盯着我，只能硬着头皮去干
先是用椒图扫了一遍webshell和后门文件。
确认没有后门以后，用专杀工具全盘扫描，扫出来7个病毒。
扔到ti威胁情报中心鉴定，确定就是高危病毒。
然后提交到二线做病毒分析，确认是远控木马类病毒，与触发蜜罐的告警有相关性。
最后删掉病毒，重新上线，没有再出现异常现象。
2）后门网站修复 椒图检测到一个服务器上存在webshell，通知用户紧急下线网站，开始排查和加固。
一群人围在哪里分析了半天，然后理所应当的把这事扔给了我：“你们家的设备，当然要你去处理呀~”
老规矩，先用椒图扫一下webshell和后门，在Temp目录下扫出来一个webshell。
跟用户的开发核实后，确认不是业务文件，是被人上传了文件。
于是删掉webshell，取消了Temp目录的所有用户权限，在椒图上吧这台服务器的防护全部开启（默认只检测不拦截）。
开发也临时关闭了上传的功能，然后准备重新上线。
结果上线后，网站访问不了。。。
在重新部署了n遍项目，外加换了两台备用服务器后，时间已经来到了凌晨六点，距离规定的上线时间还差三个小时。
“实在不行，咱们就写个静态主页跳404吧，点啥功能都给跳到404，最起码，他们一时半会儿不会怀疑是我们的问题，咱们也能多点时间排查问题。”
开发的嘴角慢慢上扬，空洞的眼神里重新亮起了光。
不幸的是，这话被项目经理偷听到了，在经理的谴责声中，我看到，开发的眼神，竟慢慢的黯淡下来，直到剩下两个黑黑的眼眶。
兴许是一晚上没去厕所的原因，在换到第三台备用服务器的时候，网站终于恢复了。
事后，我问开发：“你们的运维咋没过来呢？”
“我就是运维。”
“那，开发呢？”
“开发也是我。”
“？？？，那，你们项目组。。。”
“只有我自己~”
四、告警流量分析 平均下来，一天得有三千多条告警，但其中大部分都是误报，接下来分享一些简单的告警流量特征。
1）信息泄露 看访问路径中是否存在特殊文件或路径。
比如，访问备份文件.zip
访问默认文件
或者特殊类型的文件
客户授权的话，可以访问该路径，查看返回结果中是否包含敏感信息，以判断是否攻击成功。
2）SQL注入 看请求参数、请求头或请求体中是否包含SQL语句或关键字。
比如，GET请求中包含SQL语句（联合查询注入）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1007d153f6a591cc0aaac30c84f2d4e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd9318533c874f49a40225fd85129022/" rel="bookmark">
			gitee码云平台上进行一次完整的pull、modify、push、pull request开源流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向新手小白，让小白也能体会到为开源项目贡献力量的感觉！ git平台：gitee
使用项目：https://gitee.com/aaa124578/LinuxAbc
指导教师：吉林大学 郭东副教授
依托开源中国社区推出的基于 Git 的代码托管服务平台码云(gitee)，为开源项目LinuxAbc贡献自己的力量，学习软件开源开发方法，体会开源协作模式与开源精神，成为一名开源贡献者。步骤及要求如下：
注册自己的码云账号，并签署贡献许可协议CLA（Contribution License Agreement）。
CLA签署地址：https://clasign.osinfra.cn/sign/gitee_openeuler-1611298811283968340
登录码云网站，将LinuxAbc（https://gitee.com/aaa124578/LinuxAbc/）的代码Fork一份到自己的仓库。
点击红框进行fork，这一步就是将原项目中的库复制一份到你自己的库中。
安装Git，将自己库中的LinuxAbc代码克隆到本地开发环境中。
这一步需要相关的git知识，具体可参考：https://www.bilibili.com/video/BV1db4y1d79C/?spm_id_from=333.999.0.0
从0开始恶补一下git知识！
克隆到本地之后就可以对于这个项目进行相关的修改，包括但不限于：在command.csv中添加linux命令、代码优化、功能增加与完善、界面美化、BUG发现与建议等。
之后合并自己的branch，git add提交到暂存区，再commit提交，最后git push到自己的库中。一系列操作做完之后会在这里看到：
这里显示的是你commit时设置的名字的话就算成功！
点击pull requests：（注意这里是自己的库中的pull requests）
点击新建pull requests:
下面这张图片的意思是将player55200831用户的LinuxAbc库中的master分支pull requests到aa124578用户的LInuxAbc库中的master分支中：
创建好之后，你的代码已经被提交给管理这个代码的人了！经过他的审核痛过之后，你的代码就会被合并到本来的代码中去！至此，你成功完成了一次开源实践！Congratulations!
最后，再次感谢吉林大学 郭东副教授全程的耐心指导，本博客的内容来源自郭东副教授的UNIX/Linux操作系统课程（吉林大学创新示范课程）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2955c011985f0d6a3ad785f6f18b2fec/" rel="bookmark">
			Android 系统的异常信息捕获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 Android tombstone 记录native进程crash 奔溃时， 系统的数据信息。
TOMBSTONE 是 Android 用来记录 native 进程崩溃的 core dump 日志, 系统服务在启动完成后会增加一个 Observer 来侦测 tombstone 日志文件的变化, 每当生成新的 tombstone 文件, 就会增加一条 SYSTEM_TOMBSTONE 记录到 DropBoxManager 中.
What a Terrible Failure简称WTF，WTF是Android系统记录错误的一种方式，报告一个永远不应该发生的情况，有些只是打印Error stack trace和存异常信息文件到dropbox，有些会crash app。
二、dropbox Android DropBox 是 Android 用来持续化存储系统数据的一个管理类，主要用于记录 Android 运行过程中, 内核, 系统进程, 用户进程等出现严重问题时的 log, 可以认为这是一个可持续存储的系统级别的 logcat。
系统服务dropbox以文件形式记录了系统各种异常信息，例如app crash、native crash、anr、kernel panic等等。
/frameworks/base/core/java/android/os/DropBoxManager.java
/frameworks/base/services/core/java/com/android/server/DropBoxManagerService.java
dropbox日志路径：/data/system/dropbox
1、DropBoxManager dropbox = (DropBoxManager)getSystemService(Context.DROPBOX_SERVICE) 例如，dropbox.addText可实现把需要记录的数据丢给dropbox进行存储。
2、监听广播android.intent.action.DROPBOX_ENTRY_ADDED，可知系统发生了异常 注意权限：android.permission.READ_LOGS --- 平台签名或priv-app。
java层：handleApplicationCrashInner("crash", r, processName, crashInfo); native层： mAm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2955c011985f0d6a3ad785f6f18b2fec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e09bd2ec2987ed55ec1e96b4974a3fbd/" rel="bookmark">
			腾讯开源云原生成本优化神器 - FinOps Crane
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Crane 是一个基于 FinOps 的云资源分析与成本优化平台，它的愿景是在保证客户应用运行质量的前提下实现极致的降本。Crane 已经在腾讯内部自研业务实现了大规模落地，部署数百个 K8s 集群、管控 CPU 核数达百万，在降本增效方面取得了阶段性成果。以腾讯某部门集群优化为例，通过使用 FinOps Crane，该部门在保障业务稳定的情况下，资源利用率提升了 3 倍；腾讯另一自研业务落地 Crane 后，在一个月内实现了总 CPU 规模 40 万核的节省量，相当于成本节约超 1000 万元/月。
Crane 会通过下面 3 个方面来开启成本优化之旅：
成本展示: Kubernetes 资源( Deployments, StatefulSets )的多维度聚合与展示。
成本分析: 周期性的分析集群资源的状态并提供优化建议。
成本优化: 通过丰富的优化工具更新配置达成降本的目标。
核心功能包括：成本可视化和优化评估；内置了多种推荐器 - 资源推荐、副本推荐、闲置资源推荐；基于预测的水平弹性器；负载感知的调度器；基于 QOS 的混部。下面我们来详细了解下 Crane 的各项功能。
安装 我们这里使用 Helm 的方式来进行安装，首先需要安装 Prometheus 和 Grafana（如果您已经在环境中部署了 Prometheus 和 Grafana，可以跳过该步骤）。
Crane 使用 Prometheus 获取集群工作负载对资源的使用情况，可以使用如下所示命令安装 Prometheus：
$ helm repo add prometheus-community https://finops-helm.pkg.coding.net/gocrane/prometheus-community $ helm upgrade --install prometheus -n crane-system \ --set pushgateway.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e09bd2ec2987ed55ec1e96b4974a3fbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310ff7d7461765d3dd102e611a11623f/" rel="bookmark">
			传统图片超分算法——双三次插值 (Bicubic)、附C&#43;&#43;源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		呼，花了一个下午，终于是写完加调试完了所有的代码。
双三次插值介绍 之前我写的这篇博客中讲了什么是超分，并实现了单线性插值算法和双线性插值算法。在这里将再介绍一种插值算法——双三次插值算法。
首先，双三次插值法需要参考16个点（4x4），因此插值效果会比双线性插值法要好，但同时时间开销也会更大。在 OpenCV 中，可在 cv::resize 函数中使用 cv::INTER_CUBIC 选项选择使用双三次插值算法改变图像大小。
在学习的过程中，我参考了这篇博客，其中的插值算法写成表达式的形式为：
f ( x , y ) = ∑ i = 0 3 ∑ j = 0 3 f ( x i , y j ) W ( x − x i ) W ( y − y j ) f(x,y)=\sum_{i=0}^3\sum_{j=0}^3f(x_i,y_j)W(x-x_i)W(y-y_j) f(x,y)=i=0∑3​j=0∑3​f(xi​,yj​)W(x−xi​)W(y−yj​)
其中，(x,y) 表示待插值的像素点的坐标，f(x,y)表示经过计算待插值像素点应该插入的值， ( x i , y j ) (x_i,y_j) (xi​,yj​) i , j = 0 , 1 , 2 , 3 i,j=0,1,2,3 i,j=0,1,2,3 表示待插值点附近的 4x4 领域的点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310ff7d7461765d3dd102e611a11623f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/125/">«</a>
	<span class="pagination__item pagination__item--current">126/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/127/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>